{
  "module_name": "devtmpfs.c",
  "hash_id": "1b86470dc50f4405435443d55d57a3c9b244a1e1e88eb09ab8447e01508839b8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/base/devtmpfs.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"devtmpfs: \" fmt\n\n#include <linux/kernel.h>\n#include <linux/syscalls.h>\n#include <linux/mount.h>\n#include <linux/device.h>\n#include <linux/blkdev.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/shmem_fs.h>\n#include <linux/ramfs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/init_syscalls.h>\n#include <uapi/linux/mount.h>\n#include \"base.h\"\n\n#ifdef CONFIG_DEVTMPFS_SAFE\n#define DEVTMPFS_MFLAGS       (MS_SILENT | MS_NOEXEC | MS_NOSUID)\n#else\n#define DEVTMPFS_MFLAGS       (MS_SILENT)\n#endif\n\nstatic struct task_struct *thread;\n\nstatic int __initdata mount_dev = IS_ENABLED(CONFIG_DEVTMPFS_MOUNT);\n\nstatic DEFINE_SPINLOCK(req_lock);\n\nstatic struct req {\n\tstruct req *next;\n\tstruct completion done;\n\tint err;\n\tconst char *name;\n\tumode_t mode;\t \n\tkuid_t uid;\n\tkgid_t gid;\n\tstruct device *dev;\n} *requests;\n\nstatic int __init mount_param(char *str)\n{\n\tmount_dev = simple_strtoul(str, NULL, 0);\n\treturn 1;\n}\n__setup(\"devtmpfs.mount=\", mount_param);\n\nstatic struct vfsmount *mnt;\n\nstatic struct dentry *public_dev_mount(struct file_system_type *fs_type, int flags,\n\t\t      const char *dev_name, void *data)\n{\n\tstruct super_block *s = mnt->mnt_sb;\n\tint err;\n\n\tatomic_inc(&s->s_active);\n\tdown_write(&s->s_umount);\n\terr = reconfigure_single(s, flags, data);\n\tif (err < 0) {\n\t\tdeactivate_locked_super(s);\n\t\treturn ERR_PTR(err);\n\t}\n\treturn dget(s->s_root);\n}\n\nstatic struct file_system_type internal_fs_type = {\n\t.name = \"devtmpfs\",\n#ifdef CONFIG_TMPFS\n\t.init_fs_context = shmem_init_fs_context,\n#else\n\t.init_fs_context = ramfs_init_fs_context,\n#endif\n\t.kill_sb = kill_litter_super,\n};\n\nstatic struct file_system_type dev_fs_type = {\n\t.name = \"devtmpfs\",\n\t.mount = public_dev_mount,\n};\n\nstatic int devtmpfs_submit_req(struct req *req, const char *tmp)\n{\n\tinit_completion(&req->done);\n\n\tspin_lock(&req_lock);\n\treq->next = requests;\n\trequests = req;\n\tspin_unlock(&req_lock);\n\n\twake_up_process(thread);\n\twait_for_completion(&req->done);\n\n\tkfree(tmp);\n\n\treturn req->err;\n}\n\nint devtmpfs_create_node(struct device *dev)\n{\n\tconst char *tmp = NULL;\n\tstruct req req;\n\n\tif (!thread)\n\t\treturn 0;\n\n\treq.mode = 0;\n\treq.uid = GLOBAL_ROOT_UID;\n\treq.gid = GLOBAL_ROOT_GID;\n\treq.name = device_get_devnode(dev, &req.mode, &req.uid, &req.gid, &tmp);\n\tif (!req.name)\n\t\treturn -ENOMEM;\n\n\tif (req.mode == 0)\n\t\treq.mode = 0600;\n\tif (is_blockdev(dev))\n\t\treq.mode |= S_IFBLK;\n\telse\n\t\treq.mode |= S_IFCHR;\n\n\treq.dev = dev;\n\n\treturn devtmpfs_submit_req(&req, tmp);\n}\n\nint devtmpfs_delete_node(struct device *dev)\n{\n\tconst char *tmp = NULL;\n\tstruct req req;\n\n\tif (!thread)\n\t\treturn 0;\n\n\treq.name = device_get_devnode(dev, NULL, NULL, NULL, &tmp);\n\tif (!req.name)\n\t\treturn -ENOMEM;\n\n\treq.mode = 0;\n\treq.dev = dev;\n\n\treturn devtmpfs_submit_req(&req, tmp);\n}\n\nstatic int dev_mkdir(const char *name, umode_t mode)\n{\n\tstruct dentry *dentry;\n\tstruct path path;\n\tint err;\n\n\tdentry = kern_path_create(AT_FDCWD, name, &path, LOOKUP_DIRECTORY);\n\tif (IS_ERR(dentry))\n\t\treturn PTR_ERR(dentry);\n\n\terr = vfs_mkdir(&nop_mnt_idmap, d_inode(path.dentry), dentry, mode);\n\tif (!err)\n\t\t \n\t\td_inode(dentry)->i_private = &thread;\n\tdone_path_create(&path, dentry);\n\treturn err;\n}\n\nstatic int create_path(const char *nodepath)\n{\n\tchar *path;\n\tchar *s;\n\tint err = 0;\n\n\t \n\tpath = kstrdup(nodepath, GFP_KERNEL);\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\ts = path;\n\tfor (;;) {\n\t\ts = strchr(s, '/');\n\t\tif (!s)\n\t\t\tbreak;\n\t\ts[0] = '\\0';\n\t\terr = dev_mkdir(path, 0755);\n\t\tif (err && err != -EEXIST)\n\t\t\tbreak;\n\t\ts[0] = '/';\n\t\ts++;\n\t}\n\tkfree(path);\n\treturn err;\n}\n\nstatic int handle_create(const char *nodename, umode_t mode, kuid_t uid,\n\t\t\t kgid_t gid, struct device *dev)\n{\n\tstruct dentry *dentry;\n\tstruct path path;\n\tint err;\n\n\tdentry = kern_path_create(AT_FDCWD, nodename, &path, 0);\n\tif (dentry == ERR_PTR(-ENOENT)) {\n\t\tcreate_path(nodename);\n\t\tdentry = kern_path_create(AT_FDCWD, nodename, &path, 0);\n\t}\n\tif (IS_ERR(dentry))\n\t\treturn PTR_ERR(dentry);\n\n\terr = vfs_mknod(&nop_mnt_idmap, d_inode(path.dentry), dentry, mode,\n\t\t\tdev->devt);\n\tif (!err) {\n\t\tstruct iattr newattrs;\n\n\t\tnewattrs.ia_mode = mode;\n\t\tnewattrs.ia_uid = uid;\n\t\tnewattrs.ia_gid = gid;\n\t\tnewattrs.ia_valid = ATTR_MODE|ATTR_UID|ATTR_GID;\n\t\tinode_lock(d_inode(dentry));\n\t\tnotify_change(&nop_mnt_idmap, dentry, &newattrs, NULL);\n\t\tinode_unlock(d_inode(dentry));\n\n\t\t \n\t\td_inode(dentry)->i_private = &thread;\n\t}\n\tdone_path_create(&path, dentry);\n\treturn err;\n}\n\nstatic int dev_rmdir(const char *name)\n{\n\tstruct path parent;\n\tstruct dentry *dentry;\n\tint err;\n\n\tdentry = kern_path_locked(name, &parent);\n\tif (IS_ERR(dentry))\n\t\treturn PTR_ERR(dentry);\n\tif (d_really_is_positive(dentry)) {\n\t\tif (d_inode(dentry)->i_private == &thread)\n\t\t\terr = vfs_rmdir(&nop_mnt_idmap, d_inode(parent.dentry),\n\t\t\t\t\tdentry);\n\t\telse\n\t\t\terr = -EPERM;\n\t} else {\n\t\terr = -ENOENT;\n\t}\n\tdput(dentry);\n\tinode_unlock(d_inode(parent.dentry));\n\tpath_put(&parent);\n\treturn err;\n}\n\nstatic int delete_path(const char *nodepath)\n{\n\tchar *path;\n\tint err = 0;\n\n\tpath = kstrdup(nodepath, GFP_KERNEL);\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tfor (;;) {\n\t\tchar *base;\n\n\t\tbase = strrchr(path, '/');\n\t\tif (!base)\n\t\t\tbreak;\n\t\tbase[0] = '\\0';\n\t\terr = dev_rmdir(path);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\n\tkfree(path);\n\treturn err;\n}\n\nstatic int dev_mynode(struct device *dev, struct inode *inode, struct kstat *stat)\n{\n\t \n\tif (inode->i_private != &thread)\n\t\treturn 0;\n\n\t \n\tif (is_blockdev(dev)) {\n\t\tif (!S_ISBLK(stat->mode))\n\t\t\treturn 0;\n\t} else {\n\t\tif (!S_ISCHR(stat->mode))\n\t\t\treturn 0;\n\t}\n\tif (stat->rdev != dev->devt)\n\t\treturn 0;\n\n\t \n\treturn 1;\n}\n\nstatic int handle_remove(const char *nodename, struct device *dev)\n{\n\tstruct path parent;\n\tstruct dentry *dentry;\n\tint deleted = 0;\n\tint err;\n\n\tdentry = kern_path_locked(nodename, &parent);\n\tif (IS_ERR(dentry))\n\t\treturn PTR_ERR(dentry);\n\n\tif (d_really_is_positive(dentry)) {\n\t\tstruct kstat stat;\n\t\tstruct path p = {.mnt = parent.mnt, .dentry = dentry};\n\t\terr = vfs_getattr(&p, &stat, STATX_TYPE | STATX_MODE,\n\t\t\t\t  AT_STATX_SYNC_AS_STAT);\n\t\tif (!err && dev_mynode(dev, d_inode(dentry), &stat)) {\n\t\t\tstruct iattr newattrs;\n\t\t\t \n\t\t\tnewattrs.ia_uid = GLOBAL_ROOT_UID;\n\t\t\tnewattrs.ia_gid = GLOBAL_ROOT_GID;\n\t\t\tnewattrs.ia_mode = stat.mode & ~0777;\n\t\t\tnewattrs.ia_valid =\n\t\t\t\tATTR_UID|ATTR_GID|ATTR_MODE;\n\t\t\tinode_lock(d_inode(dentry));\n\t\t\tnotify_change(&nop_mnt_idmap, dentry, &newattrs, NULL);\n\t\t\tinode_unlock(d_inode(dentry));\n\t\t\terr = vfs_unlink(&nop_mnt_idmap, d_inode(parent.dentry),\n\t\t\t\t\t dentry, NULL);\n\t\t\tif (!err || err == -ENOENT)\n\t\t\t\tdeleted = 1;\n\t\t}\n\t} else {\n\t\terr = -ENOENT;\n\t}\n\tdput(dentry);\n\tinode_unlock(d_inode(parent.dentry));\n\n\tpath_put(&parent);\n\tif (deleted && strchr(nodename, '/'))\n\t\tdelete_path(nodename);\n\treturn err;\n}\n\n \nint __init devtmpfs_mount(void)\n{\n\tint err;\n\n\tif (!mount_dev)\n\t\treturn 0;\n\n\tif (!thread)\n\t\treturn 0;\n\n\terr = init_mount(\"devtmpfs\", \"dev\", \"devtmpfs\", DEVTMPFS_MFLAGS, NULL);\n\tif (err)\n\t\tpr_info(\"error mounting %d\\n\", err);\n\telse\n\t\tpr_info(\"mounted\\n\");\n\treturn err;\n}\n\nstatic __initdata DECLARE_COMPLETION(setup_done);\n\nstatic int handle(const char *name, umode_t mode, kuid_t uid, kgid_t gid,\n\t\t  struct device *dev)\n{\n\tif (mode)\n\t\treturn handle_create(name, mode, uid, gid, dev);\n\telse\n\t\treturn handle_remove(name, dev);\n}\n\nstatic void __noreturn devtmpfs_work_loop(void)\n{\n\twhile (1) {\n\t\tspin_lock(&req_lock);\n\t\twhile (requests) {\n\t\t\tstruct req *req = requests;\n\t\t\trequests = NULL;\n\t\t\tspin_unlock(&req_lock);\n\t\t\twhile (req) {\n\t\t\t\tstruct req *next = req->next;\n\t\t\t\treq->err = handle(req->name, req->mode,\n\t\t\t\t\t\t  req->uid, req->gid, req->dev);\n\t\t\t\tcomplete(&req->done);\n\t\t\t\treq = next;\n\t\t\t}\n\t\t\tspin_lock(&req_lock);\n\t\t}\n\t\t__set_current_state(TASK_INTERRUPTIBLE);\n\t\tspin_unlock(&req_lock);\n\t\tschedule();\n\t}\n}\n\nstatic noinline int __init devtmpfs_setup(void *p)\n{\n\tint err;\n\n\terr = ksys_unshare(CLONE_NEWNS);\n\tif (err)\n\t\tgoto out;\n\terr = init_mount(\"devtmpfs\", \"/\", \"devtmpfs\", DEVTMPFS_MFLAGS, NULL);\n\tif (err)\n\t\tgoto out;\n\tinit_chdir(\"/..\");  \n\tinit_chroot(\".\");\nout:\n\t*(int *)p = err;\n\treturn err;\n}\n\n \nstatic int __ref devtmpfsd(void *p)\n{\n\tint err = devtmpfs_setup(p);\n\n\tcomplete(&setup_done);\n\tif (err)\n\t\treturn err;\n\tdevtmpfs_work_loop();\n\treturn 0;\n}\n\n \nint __init devtmpfs_init(void)\n{\n\tchar opts[] = \"mode=0755\";\n\tint err;\n\n\tmnt = vfs_kern_mount(&internal_fs_type, 0, \"devtmpfs\", opts);\n\tif (IS_ERR(mnt)) {\n\t\tpr_err(\"unable to create devtmpfs %ld\\n\", PTR_ERR(mnt));\n\t\treturn PTR_ERR(mnt);\n\t}\n\terr = register_filesystem(&dev_fs_type);\n\tif (err) {\n\t\tpr_err(\"unable to register devtmpfs type %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tthread = kthread_run(devtmpfsd, &err, \"kdevtmpfs\");\n\tif (!IS_ERR(thread)) {\n\t\twait_for_completion(&setup_done);\n\t} else {\n\t\terr = PTR_ERR(thread);\n\t\tthread = NULL;\n\t}\n\n\tif (err) {\n\t\tpr_err(\"unable to create devtmpfs %d\\n\", err);\n\t\tunregister_filesystem(&dev_fs_type);\n\t\tthread = NULL;\n\t\treturn err;\n\t}\n\n\tpr_info(\"initialized\\n\");\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}