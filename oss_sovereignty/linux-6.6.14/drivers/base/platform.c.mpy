{
  "module_name": "platform.c",
  "hash_id": "c055397542f5af8e850f5793dcdf9d42dd830a10ce2e9a7f965e542c719a9ecd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/base/platform.c",
  "human_readable_source": "\n \n\n#include <linux/string.h>\n#include <linux/platform_device.h>\n#include <linux/of_device.h>\n#include <linux/of_irq.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/ioport.h>\n#include <linux/dma-mapping.h>\n#include <linux/memblock.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/pm_runtime.h>\n#include <linux/pm_domain.h>\n#include <linux/idr.h>\n#include <linux/acpi.h>\n#include <linux/clk/clk-conf.h>\n#include <linux/limits.h>\n#include <linux/property.h>\n#include <linux/kmemleak.h>\n#include <linux/types.h>\n#include <linux/iommu.h>\n#include <linux/dma-map-ops.h>\n\n#include \"base.h\"\n#include \"power/power.h\"\n\n \nstatic DEFINE_IDA(platform_devid_ida);\n\nstruct device platform_bus = {\n\t.init_name\t= \"platform\",\n};\nEXPORT_SYMBOL_GPL(platform_bus);\n\n \nstruct resource *platform_get_resource(struct platform_device *dev,\n\t\t\t\t       unsigned int type, unsigned int num)\n{\n\tu32 i;\n\n\tfor (i = 0; i < dev->num_resources; i++) {\n\t\tstruct resource *r = &dev->resource[i];\n\n\t\tif (type == resource_type(r) && num-- == 0)\n\t\t\treturn r;\n\t}\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(platform_get_resource);\n\nstruct resource *platform_get_mem_or_io(struct platform_device *dev,\n\t\t\t\t\tunsigned int num)\n{\n\tu32 i;\n\n\tfor (i = 0; i < dev->num_resources; i++) {\n\t\tstruct resource *r = &dev->resource[i];\n\n\t\tif ((resource_type(r) & (IORESOURCE_MEM|IORESOURCE_IO)) && num-- == 0)\n\t\t\treturn r;\n\t}\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(platform_get_mem_or_io);\n\n#ifdef CONFIG_HAS_IOMEM\n \nvoid __iomem *\ndevm_platform_get_and_ioremap_resource(struct platform_device *pdev,\n\t\t\t\tunsigned int index, struct resource **res)\n{\n\tstruct resource *r;\n\n\tr = platform_get_resource(pdev, IORESOURCE_MEM, index);\n\tif (res)\n\t\t*res = r;\n\treturn devm_ioremap_resource(&pdev->dev, r);\n}\nEXPORT_SYMBOL_GPL(devm_platform_get_and_ioremap_resource);\n\n \nvoid __iomem *devm_platform_ioremap_resource(struct platform_device *pdev,\n\t\t\t\t\t     unsigned int index)\n{\n\treturn devm_platform_get_and_ioremap_resource(pdev, index, NULL);\n}\nEXPORT_SYMBOL_GPL(devm_platform_ioremap_resource);\n\n \nvoid __iomem *\ndevm_platform_ioremap_resource_byname(struct platform_device *pdev,\n\t\t\t\t      const char *name)\n{\n\tstruct resource *res;\n\n\tres = platform_get_resource_byname(pdev, IORESOURCE_MEM, name);\n\treturn devm_ioremap_resource(&pdev->dev, res);\n}\nEXPORT_SYMBOL_GPL(devm_platform_ioremap_resource_byname);\n#endif  \n\n \nint platform_get_irq_optional(struct platform_device *dev, unsigned int num)\n{\n\tint ret;\n#ifdef CONFIG_SPARC\n\t \n\tif (!dev || num >= dev->archdata.num_irqs)\n\t\tgoto out_not_found;\n\tret = dev->archdata.irqs[num];\n\tgoto out;\n#else\n\tstruct resource *r;\n\n\tif (IS_ENABLED(CONFIG_OF_IRQ) && dev->dev.of_node) {\n\t\tret = of_irq_get(dev->dev.of_node, num);\n\t\tif (ret > 0 || ret == -EPROBE_DEFER)\n\t\t\tgoto out;\n\t}\n\n\tr = platform_get_resource(dev, IORESOURCE_IRQ, num);\n\tif (has_acpi_companion(&dev->dev)) {\n\t\tif (r && r->flags & IORESOURCE_DISABLED) {\n\t\t\tret = acpi_irq_get(ACPI_HANDLE(&dev->dev), num, r);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\n\t \n\tif (r && r->flags & IORESOURCE_BITS) {\n\t\tstruct irq_data *irqd;\n\n\t\tirqd = irq_get_irq_data(r->start);\n\t\tif (!irqd)\n\t\t\tgoto out_not_found;\n\t\tirqd_set_trigger_type(irqd, r->flags & IORESOURCE_BITS);\n\t}\n\n\tif (r) {\n\t\tret = r->start;\n\t\tgoto out;\n\t}\n\n\t \n\tif (num == 0 && has_acpi_companion(&dev->dev)) {\n\t\tret = acpi_dev_gpio_irq_get(ACPI_COMPANION(&dev->dev), num);\n\t\t \n\t\tif (ret >= 0 || ret == -EPROBE_DEFER)\n\t\t\tgoto out;\n\t}\n\n#endif\nout_not_found:\n\tret = -ENXIO;\nout:\n\tif (WARN(!ret, \"0 is an invalid IRQ number\\n\"))\n\t\treturn -EINVAL;\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(platform_get_irq_optional);\n\n \nint platform_get_irq(struct platform_device *dev, unsigned int num)\n{\n\tint ret;\n\n\tret = platform_get_irq_optional(dev, num);\n\tif (ret < 0)\n\t\treturn dev_err_probe(&dev->dev, ret,\n\t\t\t\t     \"IRQ index %u not found\\n\", num);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(platform_get_irq);\n\n \nint platform_irq_count(struct platform_device *dev)\n{\n\tint ret, nr = 0;\n\n\twhile ((ret = platform_get_irq_optional(dev, nr)) >= 0)\n\t\tnr++;\n\n\tif (ret == -EPROBE_DEFER)\n\t\treturn ret;\n\n\treturn nr;\n}\nEXPORT_SYMBOL_GPL(platform_irq_count);\n\nstruct irq_affinity_devres {\n\tunsigned int count;\n\tunsigned int irq[];\n};\n\nstatic void platform_disable_acpi_irq(struct platform_device *pdev, int index)\n{\n\tstruct resource *r;\n\n\tr = platform_get_resource(pdev, IORESOURCE_IRQ, index);\n\tif (r)\n\t\tirqresource_disabled(r, 0);\n}\n\nstatic void devm_platform_get_irqs_affinity_release(struct device *dev,\n\t\t\t\t\t\t    void *res)\n{\n\tstruct irq_affinity_devres *ptr = res;\n\tint i;\n\n\tfor (i = 0; i < ptr->count; i++) {\n\t\tirq_dispose_mapping(ptr->irq[i]);\n\n\t\tif (has_acpi_companion(dev))\n\t\t\tplatform_disable_acpi_irq(to_platform_device(dev), i);\n\t}\n}\n\n \nint devm_platform_get_irqs_affinity(struct platform_device *dev,\n\t\t\t\t    struct irq_affinity *affd,\n\t\t\t\t    unsigned int minvec,\n\t\t\t\t    unsigned int maxvec,\n\t\t\t\t    int **irqs)\n{\n\tstruct irq_affinity_devres *ptr;\n\tstruct irq_affinity_desc *desc;\n\tsize_t size;\n\tint i, ret, nvec;\n\n\tif (!affd)\n\t\treturn -EPERM;\n\n\tif (maxvec < minvec)\n\t\treturn -ERANGE;\n\n\tnvec = platform_irq_count(dev);\n\tif (nvec < 0)\n\t\treturn nvec;\n\n\tif (nvec < minvec)\n\t\treturn -ENOSPC;\n\n\tnvec = irq_calc_affinity_vectors(minvec, nvec, affd);\n\tif (nvec < minvec)\n\t\treturn -ENOSPC;\n\n\tif (nvec > maxvec)\n\t\tnvec = maxvec;\n\n\tsize = sizeof(*ptr) + sizeof(unsigned int) * nvec;\n\tptr = devres_alloc(devm_platform_get_irqs_affinity_release, size,\n\t\t\t   GFP_KERNEL);\n\tif (!ptr)\n\t\treturn -ENOMEM;\n\n\tptr->count = nvec;\n\n\tfor (i = 0; i < nvec; i++) {\n\t\tint irq = platform_get_irq(dev, i);\n\t\tif (irq < 0) {\n\t\t\tret = irq;\n\t\t\tgoto err_free_devres;\n\t\t}\n\t\tptr->irq[i] = irq;\n\t}\n\n\tdesc = irq_create_affinity_masks(nvec, affd);\n\tif (!desc) {\n\t\tret = -ENOMEM;\n\t\tgoto err_free_devres;\n\t}\n\n\tfor (i = 0; i < nvec; i++) {\n\t\tret = irq_update_affinity_desc(ptr->irq[i], &desc[i]);\n\t\tif (ret) {\n\t\t\tdev_err(&dev->dev, \"failed to update irq%d affinity descriptor (%d)\\n\",\n\t\t\t\tptr->irq[i], ret);\n\t\t\tgoto err_free_desc;\n\t\t}\n\t}\n\n\tdevres_add(&dev->dev, ptr);\n\n\tkfree(desc);\n\n\t*irqs = ptr->irq;\n\n\treturn nvec;\n\nerr_free_desc:\n\tkfree(desc);\nerr_free_devres:\n\tdevres_free(ptr);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(devm_platform_get_irqs_affinity);\n\n \nstruct resource *platform_get_resource_byname(struct platform_device *dev,\n\t\t\t\t\t      unsigned int type,\n\t\t\t\t\t      const char *name)\n{\n\tu32 i;\n\n\tfor (i = 0; i < dev->num_resources; i++) {\n\t\tstruct resource *r = &dev->resource[i];\n\n\t\tif (unlikely(!r->name))\n\t\t\tcontinue;\n\n\t\tif (type == resource_type(r) && !strcmp(r->name, name))\n\t\t\treturn r;\n\t}\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(platform_get_resource_byname);\n\nstatic int __platform_get_irq_byname(struct platform_device *dev,\n\t\t\t\t     const char *name)\n{\n\tstruct resource *r;\n\tint ret;\n\n\tret = fwnode_irq_get_byname(dev_fwnode(&dev->dev), name);\n\tif (ret > 0 || ret == -EPROBE_DEFER)\n\t\treturn ret;\n\n\tr = platform_get_resource_byname(dev, IORESOURCE_IRQ, name);\n\tif (r) {\n\t\tif (WARN(!r->start, \"0 is an invalid IRQ number\\n\"))\n\t\t\treturn -EINVAL;\n\t\treturn r->start;\n\t}\n\n\treturn -ENXIO;\n}\n\n \nint platform_get_irq_byname(struct platform_device *dev, const char *name)\n{\n\tint ret;\n\n\tret = __platform_get_irq_byname(dev, name);\n\tif (ret < 0)\n\t\treturn dev_err_probe(&dev->dev, ret, \"IRQ %s not found\\n\",\n\t\t\t\t     name);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(platform_get_irq_byname);\n\n \nint platform_get_irq_byname_optional(struct platform_device *dev,\n\t\t\t\t     const char *name)\n{\n\treturn __platform_get_irq_byname(dev, name);\n}\nEXPORT_SYMBOL_GPL(platform_get_irq_byname_optional);\n\n \nint platform_add_devices(struct platform_device **devs, int num)\n{\n\tint i, ret = 0;\n\n\tfor (i = 0; i < num; i++) {\n\t\tret = platform_device_register(devs[i]);\n\t\tif (ret) {\n\t\t\twhile (--i >= 0)\n\t\t\t\tplatform_device_unregister(devs[i]);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(platform_add_devices);\n\nstruct platform_object {\n\tstruct platform_device pdev;\n\tchar name[];\n};\n\n \nstatic void setup_pdev_dma_masks(struct platform_device *pdev)\n{\n\tpdev->dev.dma_parms = &pdev->dma_parms;\n\n\tif (!pdev->dev.coherent_dma_mask)\n\t\tpdev->dev.coherent_dma_mask = DMA_BIT_MASK(32);\n\tif (!pdev->dev.dma_mask) {\n\t\tpdev->platform_dma_mask = DMA_BIT_MASK(32);\n\t\tpdev->dev.dma_mask = &pdev->platform_dma_mask;\n\t}\n};\n\n \nvoid platform_device_put(struct platform_device *pdev)\n{\n\tif (!IS_ERR_OR_NULL(pdev))\n\t\tput_device(&pdev->dev);\n}\nEXPORT_SYMBOL_GPL(platform_device_put);\n\nstatic void platform_device_release(struct device *dev)\n{\n\tstruct platform_object *pa = container_of(dev, struct platform_object,\n\t\t\t\t\t\t  pdev.dev);\n\n\tof_node_put(pa->pdev.dev.of_node);\n\tkfree(pa->pdev.dev.platform_data);\n\tkfree(pa->pdev.mfd_cell);\n\tkfree(pa->pdev.resource);\n\tkfree(pa->pdev.driver_override);\n\tkfree(pa);\n}\n\n \nstruct platform_device *platform_device_alloc(const char *name, int id)\n{\n\tstruct platform_object *pa;\n\n\tpa = kzalloc(sizeof(*pa) + strlen(name) + 1, GFP_KERNEL);\n\tif (pa) {\n\t\tstrcpy(pa->name, name);\n\t\tpa->pdev.name = pa->name;\n\t\tpa->pdev.id = id;\n\t\tdevice_initialize(&pa->pdev.dev);\n\t\tpa->pdev.dev.release = platform_device_release;\n\t\tsetup_pdev_dma_masks(&pa->pdev);\n\t}\n\n\treturn pa ? &pa->pdev : NULL;\n}\nEXPORT_SYMBOL_GPL(platform_device_alloc);\n\n \nint platform_device_add_resources(struct platform_device *pdev,\n\t\t\t\t  const struct resource *res, unsigned int num)\n{\n\tstruct resource *r = NULL;\n\n\tif (res) {\n\t\tr = kmemdup(res, sizeof(struct resource) * num, GFP_KERNEL);\n\t\tif (!r)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tkfree(pdev->resource);\n\tpdev->resource = r;\n\tpdev->num_resources = num;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(platform_device_add_resources);\n\n \nint platform_device_add_data(struct platform_device *pdev, const void *data,\n\t\t\t     size_t size)\n{\n\tvoid *d = NULL;\n\n\tif (data) {\n\t\td = kmemdup(data, size, GFP_KERNEL);\n\t\tif (!d)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tkfree(pdev->dev.platform_data);\n\tpdev->dev.platform_data = d;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(platform_device_add_data);\n\n \nint platform_device_add(struct platform_device *pdev)\n{\n\tu32 i;\n\tint ret;\n\n\tif (!pdev)\n\t\treturn -EINVAL;\n\n\tif (!pdev->dev.parent)\n\t\tpdev->dev.parent = &platform_bus;\n\n\tpdev->dev.bus = &platform_bus_type;\n\n\tswitch (pdev->id) {\n\tdefault:\n\t\tdev_set_name(&pdev->dev, \"%s.%d\", pdev->name,  pdev->id);\n\t\tbreak;\n\tcase PLATFORM_DEVID_NONE:\n\t\tdev_set_name(&pdev->dev, \"%s\", pdev->name);\n\t\tbreak;\n\tcase PLATFORM_DEVID_AUTO:\n\t\t \n\t\tret = ida_alloc(&platform_devid_ida, GFP_KERNEL);\n\t\tif (ret < 0)\n\t\t\tgoto err_out;\n\t\tpdev->id = ret;\n\t\tpdev->id_auto = true;\n\t\tdev_set_name(&pdev->dev, \"%s.%d.auto\", pdev->name, pdev->id);\n\t\tbreak;\n\t}\n\n\tfor (i = 0; i < pdev->num_resources; i++) {\n\t\tstruct resource *p, *r = &pdev->resource[i];\n\n\t\tif (r->name == NULL)\n\t\t\tr->name = dev_name(&pdev->dev);\n\n\t\tp = r->parent;\n\t\tif (!p) {\n\t\t\tif (resource_type(r) == IORESOURCE_MEM)\n\t\t\t\tp = &iomem_resource;\n\t\t\telse if (resource_type(r) == IORESOURCE_IO)\n\t\t\t\tp = &ioport_resource;\n\t\t}\n\n\t\tif (p) {\n\t\t\tret = insert_resource(p, r);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(&pdev->dev, \"failed to claim resource %d: %pR\\n\", i, r);\n\t\t\t\tgoto failed;\n\t\t\t}\n\t\t}\n\t}\n\n\tpr_debug(\"Registering platform device '%s'. Parent at %s\\n\",\n\t\t dev_name(&pdev->dev), dev_name(pdev->dev.parent));\n\n\tret = device_add(&pdev->dev);\n\tif (ret == 0)\n\t\treturn ret;\n\n failed:\n\tif (pdev->id_auto) {\n\t\tida_free(&platform_devid_ida, pdev->id);\n\t\tpdev->id = PLATFORM_DEVID_AUTO;\n\t}\n\n\twhile (i--) {\n\t\tstruct resource *r = &pdev->resource[i];\n\t\tif (r->parent)\n\t\t\trelease_resource(r);\n\t}\n\n err_out:\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(platform_device_add);\n\n \nvoid platform_device_del(struct platform_device *pdev)\n{\n\tu32 i;\n\n\tif (!IS_ERR_OR_NULL(pdev)) {\n\t\tdevice_del(&pdev->dev);\n\n\t\tif (pdev->id_auto) {\n\t\t\tida_free(&platform_devid_ida, pdev->id);\n\t\t\tpdev->id = PLATFORM_DEVID_AUTO;\n\t\t}\n\n\t\tfor (i = 0; i < pdev->num_resources; i++) {\n\t\t\tstruct resource *r = &pdev->resource[i];\n\t\t\tif (r->parent)\n\t\t\t\trelease_resource(r);\n\t\t}\n\t}\n}\nEXPORT_SYMBOL_GPL(platform_device_del);\n\n \nint platform_device_register(struct platform_device *pdev)\n{\n\tdevice_initialize(&pdev->dev);\n\tsetup_pdev_dma_masks(pdev);\n\treturn platform_device_add(pdev);\n}\nEXPORT_SYMBOL_GPL(platform_device_register);\n\n \nvoid platform_device_unregister(struct platform_device *pdev)\n{\n\tplatform_device_del(pdev);\n\tplatform_device_put(pdev);\n}\nEXPORT_SYMBOL_GPL(platform_device_unregister);\n\n \nstruct platform_device *platform_device_register_full(\n\t\tconst struct platform_device_info *pdevinfo)\n{\n\tint ret;\n\tstruct platform_device *pdev;\n\n\tpdev = platform_device_alloc(pdevinfo->name, pdevinfo->id);\n\tif (!pdev)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tpdev->dev.parent = pdevinfo->parent;\n\tpdev->dev.fwnode = pdevinfo->fwnode;\n\tpdev->dev.of_node = of_node_get(to_of_node(pdev->dev.fwnode));\n\tpdev->dev.of_node_reused = pdevinfo->of_node_reused;\n\n\tif (pdevinfo->dma_mask) {\n\t\tpdev->platform_dma_mask = pdevinfo->dma_mask;\n\t\tpdev->dev.dma_mask = &pdev->platform_dma_mask;\n\t\tpdev->dev.coherent_dma_mask = pdevinfo->dma_mask;\n\t}\n\n\tret = platform_device_add_resources(pdev,\n\t\t\tpdevinfo->res, pdevinfo->num_res);\n\tif (ret)\n\t\tgoto err;\n\n\tret = platform_device_add_data(pdev,\n\t\t\tpdevinfo->data, pdevinfo->size_data);\n\tif (ret)\n\t\tgoto err;\n\n\tif (pdevinfo->properties) {\n\t\tret = device_create_managed_software_node(&pdev->dev,\n\t\t\t\t\t\t\t  pdevinfo->properties, NULL);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\tret = platform_device_add(pdev);\n\tif (ret) {\nerr:\n\t\tACPI_COMPANION_SET(&pdev->dev, NULL);\n\t\tplatform_device_put(pdev);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\treturn pdev;\n}\nEXPORT_SYMBOL_GPL(platform_device_register_full);\n\n \nint __platform_driver_register(struct platform_driver *drv,\n\t\t\t\tstruct module *owner)\n{\n\tdrv->driver.owner = owner;\n\tdrv->driver.bus = &platform_bus_type;\n\n\treturn driver_register(&drv->driver);\n}\nEXPORT_SYMBOL_GPL(__platform_driver_register);\n\n \nvoid platform_driver_unregister(struct platform_driver *drv)\n{\n\tdriver_unregister(&drv->driver);\n}\nEXPORT_SYMBOL_GPL(platform_driver_unregister);\n\nstatic int platform_probe_fail(struct platform_device *pdev)\n{\n\treturn -ENXIO;\n}\n\nstatic int is_bound_to_driver(struct device *dev, void *driver)\n{\n\tif (dev->driver == driver)\n\t\treturn 1;\n\treturn 0;\n}\n\n \nint __init_or_module __platform_driver_probe(struct platform_driver *drv,\n\t\tint (*probe)(struct platform_device *), struct module *module)\n{\n\tint retval;\n\n\tif (drv->driver.probe_type == PROBE_PREFER_ASYNCHRONOUS) {\n\t\tpr_err(\"%s: drivers registered with %s can not be probed asynchronously\\n\",\n\t\t\t drv->driver.name, __func__);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tdrv->driver.probe_type = PROBE_FORCE_SYNCHRONOUS;\n\n\t \n\tdrv->prevent_deferred_probe = true;\n\n\t \n\tdrv->driver.suppress_bind_attrs = true;\n\n\t \n\tdrv->probe = probe;\n\tretval = __platform_driver_register(drv, module);\n\tif (retval)\n\t\treturn retval;\n\n\t \n\tdrv->probe = platform_probe_fail;\n\n\t \n\tif (!bus_for_each_dev(&platform_bus_type, NULL, &drv->driver, is_bound_to_driver)) {\n\t\tretval = -ENODEV;\n\t\tplatform_driver_unregister(drv);\n\t}\n\n\treturn retval;\n}\nEXPORT_SYMBOL_GPL(__platform_driver_probe);\n\n \nstruct platform_device * __init_or_module __platform_create_bundle(\n\t\t\tstruct platform_driver *driver,\n\t\t\tint (*probe)(struct platform_device *),\n\t\t\tstruct resource *res, unsigned int n_res,\n\t\t\tconst void *data, size_t size, struct module *module)\n{\n\tstruct platform_device *pdev;\n\tint error;\n\n\tpdev = platform_device_alloc(driver->driver.name, -1);\n\tif (!pdev) {\n\t\terror = -ENOMEM;\n\t\tgoto err_out;\n\t}\n\n\terror = platform_device_add_resources(pdev, res, n_res);\n\tif (error)\n\t\tgoto err_pdev_put;\n\n\terror = platform_device_add_data(pdev, data, size);\n\tif (error)\n\t\tgoto err_pdev_put;\n\n\terror = platform_device_add(pdev);\n\tif (error)\n\t\tgoto err_pdev_put;\n\n\terror = __platform_driver_probe(driver, probe, module);\n\tif (error)\n\t\tgoto err_pdev_del;\n\n\treturn pdev;\n\nerr_pdev_del:\n\tplatform_device_del(pdev);\nerr_pdev_put:\n\tplatform_device_put(pdev);\nerr_out:\n\treturn ERR_PTR(error);\n}\nEXPORT_SYMBOL_GPL(__platform_create_bundle);\n\n \nint __platform_register_drivers(struct platform_driver * const *drivers,\n\t\t\t\tunsigned int count, struct module *owner)\n{\n\tunsigned int i;\n\tint err;\n\n\tfor (i = 0; i < count; i++) {\n\t\tpr_debug(\"registering platform driver %ps\\n\", drivers[i]);\n\n\t\terr = __platform_driver_register(drivers[i], owner);\n\t\tif (err < 0) {\n\t\t\tpr_err(\"failed to register platform driver %ps: %d\\n\",\n\t\t\t       drivers[i], err);\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\treturn 0;\n\nerror:\n\twhile (i--) {\n\t\tpr_debug(\"unregistering platform driver %ps\\n\", drivers[i]);\n\t\tplatform_driver_unregister(drivers[i]);\n\t}\n\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(__platform_register_drivers);\n\n \nvoid platform_unregister_drivers(struct platform_driver * const *drivers,\n\t\t\t\t unsigned int count)\n{\n\twhile (count--) {\n\t\tpr_debug(\"unregistering platform driver %ps\\n\", drivers[count]);\n\t\tplatform_driver_unregister(drivers[count]);\n\t}\n}\nEXPORT_SYMBOL_GPL(platform_unregister_drivers);\n\nstatic const struct platform_device_id *platform_match_id(\n\t\t\tconst struct platform_device_id *id,\n\t\t\tstruct platform_device *pdev)\n{\n\twhile (id->name[0]) {\n\t\tif (strcmp(pdev->name, id->name) == 0) {\n\t\t\tpdev->id_entry = id;\n\t\t\treturn id;\n\t\t}\n\t\tid++;\n\t}\n\treturn NULL;\n}\n\n#ifdef CONFIG_PM_SLEEP\n\nstatic int platform_legacy_suspend(struct device *dev, pm_message_t mesg)\n{\n\tstruct platform_driver *pdrv = to_platform_driver(dev->driver);\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tint ret = 0;\n\n\tif (dev->driver && pdrv->suspend)\n\t\tret = pdrv->suspend(pdev, mesg);\n\n\treturn ret;\n}\n\nstatic int platform_legacy_resume(struct device *dev)\n{\n\tstruct platform_driver *pdrv = to_platform_driver(dev->driver);\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tint ret = 0;\n\n\tif (dev->driver && pdrv->resume)\n\t\tret = pdrv->resume(pdev);\n\n\treturn ret;\n}\n\n#endif  \n\n#ifdef CONFIG_SUSPEND\n\nint platform_pm_suspend(struct device *dev)\n{\n\tstruct device_driver *drv = dev->driver;\n\tint ret = 0;\n\n\tif (!drv)\n\t\treturn 0;\n\n\tif (drv->pm) {\n\t\tif (drv->pm->suspend)\n\t\t\tret = drv->pm->suspend(dev);\n\t} else {\n\t\tret = platform_legacy_suspend(dev, PMSG_SUSPEND);\n\t}\n\n\treturn ret;\n}\n\nint platform_pm_resume(struct device *dev)\n{\n\tstruct device_driver *drv = dev->driver;\n\tint ret = 0;\n\n\tif (!drv)\n\t\treturn 0;\n\n\tif (drv->pm) {\n\t\tif (drv->pm->resume)\n\t\t\tret = drv->pm->resume(dev);\n\t} else {\n\t\tret = platform_legacy_resume(dev);\n\t}\n\n\treturn ret;\n}\n\n#endif  \n\n#ifdef CONFIG_HIBERNATE_CALLBACKS\n\nint platform_pm_freeze(struct device *dev)\n{\n\tstruct device_driver *drv = dev->driver;\n\tint ret = 0;\n\n\tif (!drv)\n\t\treturn 0;\n\n\tif (drv->pm) {\n\t\tif (drv->pm->freeze)\n\t\t\tret = drv->pm->freeze(dev);\n\t} else {\n\t\tret = platform_legacy_suspend(dev, PMSG_FREEZE);\n\t}\n\n\treturn ret;\n}\n\nint platform_pm_thaw(struct device *dev)\n{\n\tstruct device_driver *drv = dev->driver;\n\tint ret = 0;\n\n\tif (!drv)\n\t\treturn 0;\n\n\tif (drv->pm) {\n\t\tif (drv->pm->thaw)\n\t\t\tret = drv->pm->thaw(dev);\n\t} else {\n\t\tret = platform_legacy_resume(dev);\n\t}\n\n\treturn ret;\n}\n\nint platform_pm_poweroff(struct device *dev)\n{\n\tstruct device_driver *drv = dev->driver;\n\tint ret = 0;\n\n\tif (!drv)\n\t\treturn 0;\n\n\tif (drv->pm) {\n\t\tif (drv->pm->poweroff)\n\t\t\tret = drv->pm->poweroff(dev);\n\t} else {\n\t\tret = platform_legacy_suspend(dev, PMSG_HIBERNATE);\n\t}\n\n\treturn ret;\n}\n\nint platform_pm_restore(struct device *dev)\n{\n\tstruct device_driver *drv = dev->driver;\n\tint ret = 0;\n\n\tif (!drv)\n\t\treturn 0;\n\n\tif (drv->pm) {\n\t\tif (drv->pm->restore)\n\t\t\tret = drv->pm->restore(dev);\n\t} else {\n\t\tret = platform_legacy_resume(dev);\n\t}\n\n\treturn ret;\n}\n\n#endif  \n\n \nstatic ssize_t modalias_show(struct device *dev,\n\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tint len;\n\n\tlen = of_device_modalias(dev, buf, PAGE_SIZE);\n\tif (len != -ENODEV)\n\t\treturn len;\n\n\tlen = acpi_device_modalias(dev, buf, PAGE_SIZE - 1);\n\tif (len != -ENODEV)\n\t\treturn len;\n\n\treturn sysfs_emit(buf, \"platform:%s\\n\", pdev->name);\n}\nstatic DEVICE_ATTR_RO(modalias);\n\nstatic ssize_t numa_node_show(struct device *dev,\n\t\t\t      struct device_attribute *attr, char *buf)\n{\n\treturn sysfs_emit(buf, \"%d\\n\", dev_to_node(dev));\n}\nstatic DEVICE_ATTR_RO(numa_node);\n\nstatic ssize_t driver_override_show(struct device *dev,\n\t\t\t\t    struct device_attribute *attr, char *buf)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tssize_t len;\n\n\tdevice_lock(dev);\n\tlen = sysfs_emit(buf, \"%s\\n\", pdev->driver_override);\n\tdevice_unlock(dev);\n\n\treturn len;\n}\n\nstatic ssize_t driver_override_store(struct device *dev,\n\t\t\t\t     struct device_attribute *attr,\n\t\t\t\t     const char *buf, size_t count)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tint ret;\n\n\tret = driver_set_override(dev, &pdev->driver_override, buf, count);\n\tif (ret)\n\t\treturn ret;\n\n\treturn count;\n}\nstatic DEVICE_ATTR_RW(driver_override);\n\nstatic struct attribute *platform_dev_attrs[] = {\n\t&dev_attr_modalias.attr,\n\t&dev_attr_numa_node.attr,\n\t&dev_attr_driver_override.attr,\n\tNULL,\n};\n\nstatic umode_t platform_dev_attrs_visible(struct kobject *kobj, struct attribute *a,\n\t\tint n)\n{\n\tstruct device *dev = container_of(kobj, typeof(*dev), kobj);\n\n\tif (a == &dev_attr_numa_node.attr &&\n\t\t\tdev_to_node(dev) == NUMA_NO_NODE)\n\t\treturn 0;\n\n\treturn a->mode;\n}\n\nstatic const struct attribute_group platform_dev_group = {\n\t.attrs = platform_dev_attrs,\n\t.is_visible = platform_dev_attrs_visible,\n};\n__ATTRIBUTE_GROUPS(platform_dev);\n\n\n \nstatic int platform_match(struct device *dev, struct device_driver *drv)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tstruct platform_driver *pdrv = to_platform_driver(drv);\n\n\t \n\tif (pdev->driver_override)\n\t\treturn !strcmp(pdev->driver_override, drv->name);\n\n\t \n\tif (of_driver_match_device(dev, drv))\n\t\treturn 1;\n\n\t \n\tif (acpi_driver_match_device(dev, drv))\n\t\treturn 1;\n\n\t \n\tif (pdrv->id_table)\n\t\treturn platform_match_id(pdrv->id_table, pdev) != NULL;\n\n\t \n\treturn (strcmp(pdev->name, drv->name) == 0);\n}\n\nstatic int platform_uevent(const struct device *dev, struct kobj_uevent_env *env)\n{\n\tconst struct platform_device *pdev = to_platform_device(dev);\n\tint rc;\n\n\t \n\trc = of_device_uevent_modalias(dev, env);\n\tif (rc != -ENODEV)\n\t\treturn rc;\n\n\trc = acpi_device_uevent_modalias(dev, env);\n\tif (rc != -ENODEV)\n\t\treturn rc;\n\n\tadd_uevent_var(env, \"MODALIAS=%s%s\", PLATFORM_MODULE_PREFIX,\n\t\t\tpdev->name);\n\treturn 0;\n}\n\nstatic int platform_probe(struct device *_dev)\n{\n\tstruct platform_driver *drv = to_platform_driver(_dev->driver);\n\tstruct platform_device *dev = to_platform_device(_dev);\n\tint ret;\n\n\t \n\tif (unlikely(drv->probe == platform_probe_fail))\n\t\treturn -ENXIO;\n\n\tret = of_clk_set_defaults(_dev->of_node, false);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = dev_pm_domain_attach(_dev, true);\n\tif (ret)\n\t\tgoto out;\n\n\tif (drv->probe) {\n\t\tret = drv->probe(dev);\n\t\tif (ret)\n\t\t\tdev_pm_domain_detach(_dev, true);\n\t}\n\nout:\n\tif (drv->prevent_deferred_probe && ret == -EPROBE_DEFER) {\n\t\tdev_warn(_dev, \"probe deferral not supported\\n\");\n\t\tret = -ENXIO;\n\t}\n\n\treturn ret;\n}\n\nstatic void platform_remove(struct device *_dev)\n{\n\tstruct platform_driver *drv = to_platform_driver(_dev->driver);\n\tstruct platform_device *dev = to_platform_device(_dev);\n\n\tif (drv->remove_new) {\n\t\tdrv->remove_new(dev);\n\t} else if (drv->remove) {\n\t\tint ret = drv->remove(dev);\n\n\t\tif (ret)\n\t\t\tdev_warn(_dev, \"remove callback returned a non-zero value. This will be ignored.\\n\");\n\t}\n\tdev_pm_domain_detach(_dev, true);\n}\n\nstatic void platform_shutdown(struct device *_dev)\n{\n\tstruct platform_device *dev = to_platform_device(_dev);\n\tstruct platform_driver *drv;\n\n\tif (!_dev->driver)\n\t\treturn;\n\n\tdrv = to_platform_driver(_dev->driver);\n\tif (drv->shutdown)\n\t\tdrv->shutdown(dev);\n}\n\nstatic int platform_dma_configure(struct device *dev)\n{\n\tstruct platform_driver *drv = to_platform_driver(dev->driver);\n\tenum dev_dma_attr attr;\n\tint ret = 0;\n\n\tif (dev->of_node) {\n\t\tret = of_dma_configure(dev, dev->of_node, true);\n\t} else if (has_acpi_companion(dev)) {\n\t\tattr = acpi_get_dma_attr(to_acpi_device_node(dev->fwnode));\n\t\tret = acpi_dma_configure(dev, attr);\n\t}\n\n\tif (!ret && !drv->driver_managed_dma) {\n\t\tret = iommu_device_use_default_domain(dev);\n\t\tif (ret)\n\t\t\tarch_teardown_dma_ops(dev);\n\t}\n\n\treturn ret;\n}\n\nstatic void platform_dma_cleanup(struct device *dev)\n{\n\tstruct platform_driver *drv = to_platform_driver(dev->driver);\n\n\tif (!drv->driver_managed_dma)\n\t\tiommu_device_unuse_default_domain(dev);\n}\n\nstatic const struct dev_pm_ops platform_dev_pm_ops = {\n\tSET_RUNTIME_PM_OPS(pm_generic_runtime_suspend, pm_generic_runtime_resume, NULL)\n\tUSE_PLATFORM_PM_SLEEP_OPS\n};\n\nstruct bus_type platform_bus_type = {\n\t.name\t\t= \"platform\",\n\t.dev_groups\t= platform_dev_groups,\n\t.match\t\t= platform_match,\n\t.uevent\t\t= platform_uevent,\n\t.probe\t\t= platform_probe,\n\t.remove\t\t= platform_remove,\n\t.shutdown\t= platform_shutdown,\n\t.dma_configure\t= platform_dma_configure,\n\t.dma_cleanup\t= platform_dma_cleanup,\n\t.pm\t\t= &platform_dev_pm_ops,\n};\nEXPORT_SYMBOL_GPL(platform_bus_type);\n\nstatic inline int __platform_match(struct device *dev, const void *drv)\n{\n\treturn platform_match(dev, (struct device_driver *)drv);\n}\n\n \nstruct device *platform_find_device_by_driver(struct device *start,\n\t\t\t\t\t      const struct device_driver *drv)\n{\n\treturn bus_find_device(&platform_bus_type, start, drv,\n\t\t\t       __platform_match);\n}\nEXPORT_SYMBOL_GPL(platform_find_device_by_driver);\n\nvoid __weak __init early_platform_cleanup(void) { }\n\nint __init platform_bus_init(void)\n{\n\tint error;\n\n\tearly_platform_cleanup();\n\n\terror = device_register(&platform_bus);\n\tif (error) {\n\t\tput_device(&platform_bus);\n\t\treturn error;\n\t}\n\terror =  bus_register(&platform_bus_type);\n\tif (error)\n\t\tdevice_unregister(&platform_bus);\n\n\treturn error;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}