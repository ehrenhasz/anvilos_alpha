{
  "module_name": "attribute_container.c",
  "hash_id": "2775c314b8a3e4464f077c14336402ebfdf414d1ea4f65a6af825980e31380a1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/base/attribute_container.c",
  "human_readable_source": "\n \n\n#include <linux/attribute_container.h>\n#include <linux/device.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n\n#include \"base.h\"\n\n \nstruct internal_container {\n\tstruct klist_node node;\n\tstruct attribute_container *cont;\n\tstruct device classdev;\n};\n\nstatic void internal_container_klist_get(struct klist_node *n)\n{\n\tstruct internal_container *ic =\n\t\tcontainer_of(n, struct internal_container, node);\n\tget_device(&ic->classdev);\n}\n\nstatic void internal_container_klist_put(struct klist_node *n)\n{\n\tstruct internal_container *ic =\n\t\tcontainer_of(n, struct internal_container, node);\n\tput_device(&ic->classdev);\n}\n\n\n \nstruct attribute_container *\nattribute_container_classdev_to_container(struct device *classdev)\n{\n\tstruct internal_container *ic =\n\t\tcontainer_of(classdev, struct internal_container, classdev);\n\treturn ic->cont;\n}\nEXPORT_SYMBOL_GPL(attribute_container_classdev_to_container);\n\nstatic LIST_HEAD(attribute_container_list);\n\nstatic DEFINE_MUTEX(attribute_container_mutex);\n\n \nint\nattribute_container_register(struct attribute_container *cont)\n{\n\tINIT_LIST_HEAD(&cont->node);\n\tklist_init(&cont->containers, internal_container_klist_get,\n\t\t   internal_container_klist_put);\n\n\tmutex_lock(&attribute_container_mutex);\n\tlist_add_tail(&cont->node, &attribute_container_list);\n\tmutex_unlock(&attribute_container_mutex);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(attribute_container_register);\n\n \nint\nattribute_container_unregister(struct attribute_container *cont)\n{\n\tint retval = -EBUSY;\n\n\tmutex_lock(&attribute_container_mutex);\n\tspin_lock(&cont->containers.k_lock);\n\tif (!list_empty(&cont->containers.k_list))\n\t\tgoto out;\n\tretval = 0;\n\tlist_del(&cont->node);\n out:\n\tspin_unlock(&cont->containers.k_lock);\n\tmutex_unlock(&attribute_container_mutex);\n\treturn retval;\n\n}\nEXPORT_SYMBOL_GPL(attribute_container_unregister);\n\n \nstatic void attribute_container_release(struct device *classdev)\n{\n\tstruct internal_container *ic\n\t\t= container_of(classdev, struct internal_container, classdev);\n\tstruct device *dev = classdev->parent;\n\n\tkfree(ic);\n\tput_device(dev);\n}\n\n \nvoid\nattribute_container_add_device(struct device *dev,\n\t\t\t       int (*fn)(struct attribute_container *,\n\t\t\t\t\t struct device *,\n\t\t\t\t\t struct device *))\n{\n\tstruct attribute_container *cont;\n\n\tmutex_lock(&attribute_container_mutex);\n\tlist_for_each_entry(cont, &attribute_container_list, node) {\n\t\tstruct internal_container *ic;\n\n\t\tif (attribute_container_no_classdevs(cont))\n\t\t\tcontinue;\n\n\t\tif (!cont->match(cont, dev))\n\t\t\tcontinue;\n\n\t\tic = kzalloc(sizeof(*ic), GFP_KERNEL);\n\t\tif (!ic) {\n\t\t\tdev_err(dev, \"failed to allocate class container\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tic->cont = cont;\n\t\tdevice_initialize(&ic->classdev);\n\t\tic->classdev.parent = get_device(dev);\n\t\tic->classdev.class = cont->class;\n\t\tcont->class->dev_release = attribute_container_release;\n\t\tdev_set_name(&ic->classdev, \"%s\", dev_name(dev));\n\t\tif (fn)\n\t\t\tfn(cont, dev, &ic->classdev);\n\t\telse\n\t\t\tattribute_container_add_class_device(&ic->classdev);\n\t\tklist_add_tail(&ic->node, &cont->containers);\n\t}\n\tmutex_unlock(&attribute_container_mutex);\n}\n\n \n#define klist_for_each_entry(pos, head, member, iter) \\\n\tfor (klist_iter_init(head, iter); (pos = ({ \\\n\t\tstruct klist_node *n = klist_next(iter); \\\n\t\tn ? container_of(n, typeof(*pos), member) : \\\n\t\t\t({ klist_iter_exit(iter) ; NULL; }); \\\n\t})) != NULL;)\n\n\n \nvoid\nattribute_container_remove_device(struct device *dev,\n\t\t\t\t  void (*fn)(struct attribute_container *,\n\t\t\t\t\t     struct device *,\n\t\t\t\t\t     struct device *))\n{\n\tstruct attribute_container *cont;\n\n\tmutex_lock(&attribute_container_mutex);\n\tlist_for_each_entry(cont, &attribute_container_list, node) {\n\t\tstruct internal_container *ic;\n\t\tstruct klist_iter iter;\n\n\t\tif (attribute_container_no_classdevs(cont))\n\t\t\tcontinue;\n\n\t\tif (!cont->match(cont, dev))\n\t\t\tcontinue;\n\n\t\tklist_for_each_entry(ic, &cont->containers, node, &iter) {\n\t\t\tif (dev != ic->classdev.parent)\n\t\t\t\tcontinue;\n\t\t\tklist_del(&ic->node);\n\t\t\tif (fn)\n\t\t\t\tfn(cont, dev, &ic->classdev);\n\t\t\telse {\n\t\t\t\tattribute_container_remove_attrs(&ic->classdev);\n\t\t\t\tdevice_unregister(&ic->classdev);\n\t\t\t}\n\t\t}\n\t}\n\tmutex_unlock(&attribute_container_mutex);\n}\n\nstatic int\ndo_attribute_container_device_trigger_safe(struct device *dev,\n\t\t\t\t\t   struct attribute_container *cont,\n\t\t\t\t\t   int (*fn)(struct attribute_container *,\n\t\t\t\t\t\t     struct device *, struct device *),\n\t\t\t\t\t   int (*undo)(struct attribute_container *,\n\t\t\t\t\t\t       struct device *, struct device *))\n{\n\tint ret;\n\tstruct internal_container *ic, *failed;\n\tstruct klist_iter iter;\n\n\tif (attribute_container_no_classdevs(cont))\n\t\treturn fn(cont, dev, NULL);\n\n\tklist_for_each_entry(ic, &cont->containers, node, &iter) {\n\t\tif (dev == ic->classdev.parent) {\n\t\t\tret = fn(cont, dev, &ic->classdev);\n\t\t\tif (ret) {\n\t\t\t\tfailed = ic;\n\t\t\t\tklist_iter_exit(&iter);\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n\nfail:\n\tif (!undo)\n\t\treturn ret;\n\n\t \n\tklist_for_each_entry(ic, &cont->containers, node, &iter) {\n\t\tif (ic == failed) {\n\t\t\tklist_iter_exit(&iter);\n\t\t\tbreak;\n\t\t}\n\t\tif (dev == ic->classdev.parent)\n\t\t\tundo(cont, dev, &ic->classdev);\n\t}\n\treturn ret;\n}\n\n \nint\nattribute_container_device_trigger_safe(struct device *dev,\n\t\t\t\t\tint (*fn)(struct attribute_container *,\n\t\t\t\t\t\t  struct device *,\n\t\t\t\t\t\t  struct device *),\n\t\t\t\t\tint (*undo)(struct attribute_container *,\n\t\t\t\t\t\t    struct device *,\n\t\t\t\t\t\t    struct device *))\n{\n\tstruct attribute_container *cont, *failed = NULL;\n\tint ret = 0;\n\n\tmutex_lock(&attribute_container_mutex);\n\n\tlist_for_each_entry(cont, &attribute_container_list, node) {\n\n\t\tif (!cont->match(cont, dev))\n\t\t\tcontinue;\n\n\t\tret = do_attribute_container_device_trigger_safe(dev, cont,\n\t\t\t\t\t\t\t\t fn, undo);\n\t\tif (ret) {\n\t\t\tfailed = cont;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (ret && !WARN_ON(!undo)) {\n\t\tlist_for_each_entry(cont, &attribute_container_list, node) {\n\n\t\t\tif (failed == cont)\n\t\t\t\tbreak;\n\n\t\t\tif (!cont->match(cont, dev))\n\t\t\t\tcontinue;\n\n\t\t\tdo_attribute_container_device_trigger_safe(dev, cont,\n\t\t\t\t\t\t\t\t   undo, NULL);\n\t\t}\n\t}\n\n\tmutex_unlock(&attribute_container_mutex);\n\treturn ret;\n\n}\n\n \nvoid\nattribute_container_device_trigger(struct device *dev,\n\t\t\t\t   int (*fn)(struct attribute_container *,\n\t\t\t\t\t     struct device *,\n\t\t\t\t\t     struct device *))\n{\n\tstruct attribute_container *cont;\n\n\tmutex_lock(&attribute_container_mutex);\n\tlist_for_each_entry(cont, &attribute_container_list, node) {\n\t\tstruct internal_container *ic;\n\t\tstruct klist_iter iter;\n\n\t\tif (!cont->match(cont, dev))\n\t\t\tcontinue;\n\n\t\tif (attribute_container_no_classdevs(cont)) {\n\t\t\tfn(cont, dev, NULL);\n\t\t\tcontinue;\n\t\t}\n\n\t\tklist_for_each_entry(ic, &cont->containers, node, &iter) {\n\t\t\tif (dev == ic->classdev.parent)\n\t\t\t\tfn(cont, dev, &ic->classdev);\n\t\t}\n\t}\n\tmutex_unlock(&attribute_container_mutex);\n}\n\n \nvoid\nattribute_container_trigger(struct device *dev,\n\t\t\t    int (*fn)(struct attribute_container *,\n\t\t\t\t      struct device *))\n{\n\tstruct attribute_container *cont;\n\n\tmutex_lock(&attribute_container_mutex);\n\tlist_for_each_entry(cont, &attribute_container_list, node) {\n\t\tif (cont->match(cont, dev))\n\t\t\tfn(cont, dev);\n\t}\n\tmutex_unlock(&attribute_container_mutex);\n}\n\n \nint\nattribute_container_add_attrs(struct device *classdev)\n{\n\tstruct attribute_container *cont =\n\t\tattribute_container_classdev_to_container(classdev);\n\tstruct device_attribute **attrs = cont->attrs;\n\tint i, error;\n\n\tBUG_ON(attrs && cont->grp);\n\n\tif (!attrs && !cont->grp)\n\t\treturn 0;\n\n\tif (cont->grp)\n\t\treturn sysfs_create_group(&classdev->kobj, cont->grp);\n\n\tfor (i = 0; attrs[i]; i++) {\n\t\tsysfs_attr_init(&attrs[i]->attr);\n\t\terror = device_create_file(classdev, attrs[i]);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\n \nint\nattribute_container_add_class_device(struct device *classdev)\n{\n\tint error = device_add(classdev);\n\n\tif (error)\n\t\treturn error;\n\treturn attribute_container_add_attrs(classdev);\n}\n\n \nint\nattribute_container_add_class_device_adapter(struct attribute_container *cont,\n\t\t\t\t\t     struct device *dev,\n\t\t\t\t\t     struct device *classdev)\n{\n\treturn attribute_container_add_class_device(classdev);\n}\n\n \nvoid\nattribute_container_remove_attrs(struct device *classdev)\n{\n\tstruct attribute_container *cont =\n\t\tattribute_container_classdev_to_container(classdev);\n\tstruct device_attribute **attrs = cont->attrs;\n\tint i;\n\n\tif (!attrs && !cont->grp)\n\t\treturn;\n\n\tif (cont->grp) {\n\t\tsysfs_remove_group(&classdev->kobj, cont->grp);\n\t\treturn ;\n\t}\n\n\tfor (i = 0; attrs[i]; i++)\n\t\tdevice_remove_file(classdev, attrs[i]);\n}\n\n \nvoid\nattribute_container_class_device_del(struct device *classdev)\n{\n\tattribute_container_remove_attrs(classdev);\n\tdevice_del(classdev);\n}\n\n \nstruct device *\nattribute_container_find_class_device(struct attribute_container *cont,\n\t\t\t\t      struct device *dev)\n{\n\tstruct device *cdev = NULL;\n\tstruct internal_container *ic;\n\tstruct klist_iter iter;\n\n\tklist_for_each_entry(ic, &cont->containers, node, &iter) {\n\t\tif (ic->classdev.parent == dev) {\n\t\t\tcdev = &ic->classdev;\n\t\t\t \n\t\t\tklist_iter_exit(&iter);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn cdev;\n}\nEXPORT_SYMBOL_GPL(attribute_container_find_class_device);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}