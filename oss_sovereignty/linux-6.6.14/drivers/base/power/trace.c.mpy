{
  "module_name": "trace.c",
  "hash_id": "60fc88673234bb5a2f651dafd5a805c73521d79d517df01023e85c1fee8393b2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/base/power/trace.c",
  "human_readable_source": "\n \n#define pr_fmt(fmt) \"PM: \" fmt\n\n#include <linux/pm-trace.h>\n#include <linux/export.h>\n#include <linux/rtc.h>\n#include <linux/suspend.h>\n#include <linux/init.h>\n\n#include <linux/mc146818rtc.h>\n\n#include \"power.h\"\n\n \n#define USERHASH (16)\n#define FILEHASH (997)\n#define DEVHASH (1009)\n\n#define DEVSEED (7919)\n\nbool pm_trace_rtc_abused __read_mostly;\nEXPORT_SYMBOL_GPL(pm_trace_rtc_abused);\n\nstatic unsigned int dev_hash_value;\n\nstatic int set_magic_time(unsigned int user, unsigned int file, unsigned int device)\n{\n\tunsigned int n = user + USERHASH*(file + FILEHASH*device);\n\n\t \n\tstatic struct rtc_time time = {\n\t\t.tm_sec = 0,\n\t\t.tm_min = 0,\n\t\t.tm_hour = 0,\n\t\t.tm_mday = 7,\n\t\t.tm_mon = 5,\t \n\t\t.tm_year = 106,\n\t\t.tm_wday = 3,\n\t\t.tm_yday = 160,\n\t\t.tm_isdst = 1\n\t};\n\n\ttime.tm_year = (n % 100);\n\tn /= 100;\n\ttime.tm_mon = (n % 12);\n\tn /= 12;\n\ttime.tm_mday = (n % 28) + 1;\n\tn /= 28;\n\ttime.tm_hour = (n % 24);\n\tn /= 24;\n\ttime.tm_min = (n % 20) * 3;\n\tn /= 20;\n\tmc146818_set_time(&time);\n\tpm_trace_rtc_abused = true;\n\treturn n ? -1 : 0;\n}\n\nstatic unsigned int read_magic_time(void)\n{\n\tstruct rtc_time time;\n\tunsigned int val;\n\n\tif (mc146818_get_time(&time) < 0) {\n\t\tpr_err(\"Unable to read current time from RTC\\n\");\n\t\treturn 0;\n\t}\n\n\tpr_info(\"RTC time: %ptRt, date: %ptRd\\n\", &time, &time);\n\tval = time.tm_year;\t\t\t\t \n\tif (val > 100)\n\t\tval -= 100;\n\tval += time.tm_mon * 100;\t\t\t \n\tval += (time.tm_mday-1) * 100 * 12;\t\t \n\tval += time.tm_hour * 100 * 12 * 28;\t\t \n\tval += (time.tm_min / 3) * 100 * 12 * 28 * 24;\t \n\treturn val;\n}\n\n \nstatic unsigned int hash_string(unsigned int seed, const char *data, unsigned int mod)\n{\n\tunsigned char c;\n\twhile ((c = *data++) != 0) {\n\t\tseed = (seed << 16) + (seed << 6) - seed + c;\n\t}\n\treturn seed % mod;\n}\n\nvoid set_trace_device(struct device *dev)\n{\n\tdev_hash_value = hash_string(DEVSEED, dev_name(dev), DEVHASH);\n}\nEXPORT_SYMBOL(set_trace_device);\n\n \nvoid generate_pm_trace(const void *tracedata, unsigned int user)\n{\n\tunsigned short lineno = *(unsigned short *)tracedata;\n\tconst char *file = *(const char **)(tracedata + 2);\n\tunsigned int user_hash_value, file_hash_value;\n\n\tif (!x86_platform.legacy.rtc)\n\t\treturn;\n\n\tuser_hash_value = user % USERHASH;\n\tfile_hash_value = hash_string(lineno, file, FILEHASH);\n\tset_magic_time(user_hash_value, file_hash_value, dev_hash_value);\n}\nEXPORT_SYMBOL(generate_pm_trace);\n\nextern char __tracedata_start[], __tracedata_end[];\nstatic int show_file_hash(unsigned int value)\n{\n\tint match;\n\tchar *tracedata;\n\n\tmatch = 0;\n\tfor (tracedata = __tracedata_start ; tracedata < __tracedata_end ;\n\t\t\ttracedata += 2 + sizeof(unsigned long)) {\n\t\tunsigned short lineno = *(unsigned short *)tracedata;\n\t\tconst char *file = *(const char **)(tracedata + 2);\n\t\tunsigned int hash = hash_string(lineno, file, FILEHASH);\n\t\tif (hash != value)\n\t\t\tcontinue;\n\t\tpr_info(\"  hash matches %s:%u\\n\", file, lineno);\n\t\tmatch++;\n\t}\n\treturn match;\n}\n\nstatic int show_dev_hash(unsigned int value)\n{\n\tint match = 0;\n\tstruct list_head *entry;\n\n\tdevice_pm_lock();\n\tentry = dpm_list.prev;\n\twhile (entry != &dpm_list) {\n\t\tstruct device * dev = to_device(entry);\n\t\tunsigned int hash = hash_string(DEVSEED, dev_name(dev), DEVHASH);\n\t\tif (hash == value) {\n\t\t\tdev_info(dev, \"hash matches\\n\");\n\t\t\tmatch++;\n\t\t}\n\t\tentry = entry->prev;\n\t}\n\tdevice_pm_unlock();\n\treturn match;\n}\n\nstatic unsigned int hash_value_early_read;\n\nint show_trace_dev_match(char *buf, size_t size)\n{\n\tunsigned int value = hash_value_early_read / (USERHASH * FILEHASH);\n\tint ret = 0;\n\tstruct list_head *entry;\n\n\t \n\tdevice_pm_lock();\n\tentry = dpm_list.prev;\n\twhile (size && entry != &dpm_list) {\n\t\tstruct device *dev = to_device(entry);\n\t\tunsigned int hash = hash_string(DEVSEED, dev_name(dev),\n\t\t\t\t\t\tDEVHASH);\n\t\tif (hash == value) {\n\t\t\tint len = snprintf(buf, size, \"%s\\n\",\n\t\t\t\t\t    dev_driver_string(dev));\n\t\t\tif (len > size)\n\t\t\t\tlen = size;\n\t\t\tbuf += len;\n\t\t\tret += len;\n\t\t\tsize -= len;\n\t\t}\n\t\tentry = entry->prev;\n\t}\n\tdevice_pm_unlock();\n\treturn ret;\n}\n\nstatic int\npm_trace_notify(struct notifier_block *nb, unsigned long mode, void *_unused)\n{\n\tswitch (mode) {\n\tcase PM_POST_HIBERNATION:\n\tcase PM_POST_SUSPEND:\n\t\tif (pm_trace_rtc_abused) {\n\t\t\tpm_trace_rtc_abused = false;\n\t\t\tpr_warn(\"Possible incorrect RTC due to pm_trace, please use 'ntpdate' or 'rdate' to reset it.\\n\");\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic struct notifier_block pm_trace_nb = {\n\t.notifier_call = pm_trace_notify,\n};\n\nstatic int __init early_resume_init(void)\n{\n\tif (!x86_platform.legacy.rtc)\n\t\treturn 0;\n\n\thash_value_early_read = read_magic_time();\n\tregister_pm_notifier(&pm_trace_nb);\n\treturn 0;\n}\n\nstatic int __init late_resume_init(void)\n{\n\tunsigned int val = hash_value_early_read;\n\tunsigned int user, file, dev;\n\n\tif (!x86_platform.legacy.rtc)\n\t\treturn 0;\n\n\tuser = val % USERHASH;\n\tval = val / USERHASH;\n\tfile = val % FILEHASH;\n\tval = val / FILEHASH;\n\tdev = val  ;\n\n\tpr_info(\"  Magic number: %d:%d:%d\\n\", user, file, dev);\n\tshow_file_hash(file);\n\tshow_dev_hash(dev);\n\treturn 0;\n}\n\ncore_initcall(early_resume_init);\nlate_initcall(late_resume_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}