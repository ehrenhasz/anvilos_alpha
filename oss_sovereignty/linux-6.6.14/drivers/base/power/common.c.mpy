{
  "module_name": "common.c",
  "hash_id": "f4e5e755931008fcc8a88b39598517493ae56d0f7e5190cbe581e00aba04ede7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/base/power/common.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/pm_clock.h>\n#include <linux/acpi.h>\n#include <linux/pm_domain.h>\n\n#include \"power.h\"\n\n \nint dev_pm_get_subsys_data(struct device *dev)\n{\n\tstruct pm_subsys_data *psd;\n\n\tpsd = kzalloc(sizeof(*psd), GFP_KERNEL);\n\tif (!psd)\n\t\treturn -ENOMEM;\n\n\tspin_lock_irq(&dev->power.lock);\n\n\tif (dev->power.subsys_data) {\n\t\tdev->power.subsys_data->refcount++;\n\t} else {\n\t\tspin_lock_init(&psd->lock);\n\t\tpsd->refcount = 1;\n\t\tdev->power.subsys_data = psd;\n\t\tpm_clk_init(dev);\n\t\tpsd = NULL;\n\t}\n\n\tspin_unlock_irq(&dev->power.lock);\n\n\t \n\tkfree(psd);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(dev_pm_get_subsys_data);\n\n \nvoid dev_pm_put_subsys_data(struct device *dev)\n{\n\tstruct pm_subsys_data *psd;\n\n\tspin_lock_irq(&dev->power.lock);\n\n\tpsd = dev_to_psd(dev);\n\tif (!psd)\n\t\tgoto out;\n\n\tif (--psd->refcount == 0)\n\t\tdev->power.subsys_data = NULL;\n\telse\n\t\tpsd = NULL;\n\n out:\n\tspin_unlock_irq(&dev->power.lock);\n\tkfree(psd);\n}\nEXPORT_SYMBOL_GPL(dev_pm_put_subsys_data);\n\n \nint dev_pm_domain_attach(struct device *dev, bool power_on)\n{\n\tint ret;\n\n\tif (dev->pm_domain)\n\t\treturn 0;\n\n\tret = acpi_dev_pm_attach(dev, power_on);\n\tif (!ret)\n\t\tret = genpd_dev_pm_attach(dev);\n\n\treturn ret < 0 ? ret : 0;\n}\nEXPORT_SYMBOL_GPL(dev_pm_domain_attach);\n\n \nstruct device *dev_pm_domain_attach_by_id(struct device *dev,\n\t\t\t\t\t  unsigned int index)\n{\n\tif (dev->pm_domain)\n\t\treturn ERR_PTR(-EEXIST);\n\n\treturn genpd_dev_pm_attach_by_id(dev, index);\n}\nEXPORT_SYMBOL_GPL(dev_pm_domain_attach_by_id);\n\n \nstruct device *dev_pm_domain_attach_by_name(struct device *dev,\n\t\t\t\t\t    const char *name)\n{\n\tif (dev->pm_domain)\n\t\treturn ERR_PTR(-EEXIST);\n\n\treturn genpd_dev_pm_attach_by_name(dev, name);\n}\nEXPORT_SYMBOL_GPL(dev_pm_domain_attach_by_name);\n\n \nvoid dev_pm_domain_detach(struct device *dev, bool power_off)\n{\n\tif (dev->pm_domain && dev->pm_domain->detach)\n\t\tdev->pm_domain->detach(dev, power_off);\n}\nEXPORT_SYMBOL_GPL(dev_pm_domain_detach);\n\n \nint dev_pm_domain_start(struct device *dev)\n{\n\tif (dev->pm_domain && dev->pm_domain->start)\n\t\treturn dev->pm_domain->start(dev);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(dev_pm_domain_start);\n\n \nvoid dev_pm_domain_set(struct device *dev, struct dev_pm_domain *pd)\n{\n\tif (dev->pm_domain == pd)\n\t\treturn;\n\n\tWARN(pd && device_is_bound(dev),\n\t     \"PM domains can only be changed for unbound devices\\n\");\n\tdev->pm_domain = pd;\n\tdevice_pm_check_callbacks(dev);\n}\nEXPORT_SYMBOL_GPL(dev_pm_domain_set);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}