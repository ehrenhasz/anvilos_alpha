{
  "module_name": "wakeirq.c",
  "hash_id": "d2dd0755c58c6006dee1eb9710d487e02c961583df4242e73c3e298ba026406b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/base/power/wakeirq.c",
  "human_readable_source": "\n \n#include <linux/device.h>\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/slab.h>\n#include <linux/pm_runtime.h>\n#include <linux/pm_wakeirq.h>\n\n#include \"power.h\"\n\n \nstatic int dev_pm_attach_wake_irq(struct device *dev, struct wake_irq *wirq)\n{\n\tunsigned long flags;\n\n\tif (!dev || !wirq)\n\t\treturn -EINVAL;\n\n\tspin_lock_irqsave(&dev->power.lock, flags);\n\tif (dev_WARN_ONCE(dev, dev->power.wakeirq,\n\t\t\t  \"wake irq already initialized\\n\")) {\n\t\tspin_unlock_irqrestore(&dev->power.lock, flags);\n\t\treturn -EEXIST;\n\t}\n\n\tdev->power.wakeirq = wirq;\n\tdevice_wakeup_attach_irq(dev, wirq);\n\n\tspin_unlock_irqrestore(&dev->power.lock, flags);\n\treturn 0;\n}\n\n \nint dev_pm_set_wake_irq(struct device *dev, int irq)\n{\n\tstruct wake_irq *wirq;\n\tint err;\n\n\tif (irq < 0)\n\t\treturn -EINVAL;\n\n\twirq = kzalloc(sizeof(*wirq), GFP_KERNEL);\n\tif (!wirq)\n\t\treturn -ENOMEM;\n\n\twirq->dev = dev;\n\twirq->irq = irq;\n\n\terr = dev_pm_attach_wake_irq(dev, wirq);\n\tif (err)\n\t\tkfree(wirq);\n\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(dev_pm_set_wake_irq);\n\n \nvoid dev_pm_clear_wake_irq(struct device *dev)\n{\n\tstruct wake_irq *wirq = dev->power.wakeirq;\n\tunsigned long flags;\n\n\tif (!wirq)\n\t\treturn;\n\n\tspin_lock_irqsave(&dev->power.lock, flags);\n\tdevice_wakeup_detach_irq(dev);\n\tdev->power.wakeirq = NULL;\n\tspin_unlock_irqrestore(&dev->power.lock, flags);\n\n\tif (wirq->status & WAKE_IRQ_DEDICATED_ALLOCATED) {\n\t\tfree_irq(wirq->irq, wirq);\n\t\twirq->status &= ~WAKE_IRQ_DEDICATED_MASK;\n\t}\n\tkfree(wirq->name);\n\tkfree(wirq);\n}\nEXPORT_SYMBOL_GPL(dev_pm_clear_wake_irq);\n\n \nstatic irqreturn_t handle_threaded_wake_irq(int irq, void *_wirq)\n{\n\tstruct wake_irq *wirq = _wirq;\n\tint res;\n\n\t \n\tif (irqd_is_wakeup_set(irq_get_irq_data(irq))) {\n\t\tpm_wakeup_event(wirq->dev, 0);\n\n\t\treturn IRQ_HANDLED;\n\t}\n\n\t \n\tres = pm_runtime_resume(wirq->dev);\n\tif (res < 0)\n\t\tdev_warn(wirq->dev,\n\t\t\t \"wake IRQ with no resume: %i\\n\", res);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int __dev_pm_set_dedicated_wake_irq(struct device *dev, int irq, unsigned int flag)\n{\n\tstruct wake_irq *wirq;\n\tint err;\n\n\tif (irq < 0)\n\t\treturn -EINVAL;\n\n\twirq = kzalloc(sizeof(*wirq), GFP_KERNEL);\n\tif (!wirq)\n\t\treturn -ENOMEM;\n\n\twirq->name = kasprintf(GFP_KERNEL, \"%s:wakeup\", dev_name(dev));\n\tif (!wirq->name) {\n\t\terr = -ENOMEM;\n\t\tgoto err_free;\n\t}\n\n\twirq->dev = dev;\n\twirq->irq = irq;\n\n\t \n\tirq_set_status_flags(irq, IRQ_DISABLE_UNLAZY);\n\n\t \n\terr = request_threaded_irq(irq, NULL, handle_threaded_wake_irq,\n\t\t\t\t   IRQF_ONESHOT | IRQF_NO_AUTOEN,\n\t\t\t\t   wirq->name, wirq);\n\tif (err)\n\t\tgoto err_free_name;\n\n\terr = dev_pm_attach_wake_irq(dev, wirq);\n\tif (err)\n\t\tgoto err_free_irq;\n\n\twirq->status = WAKE_IRQ_DEDICATED_ALLOCATED | flag;\n\n\treturn err;\n\nerr_free_irq:\n\tfree_irq(irq, wirq);\nerr_free_name:\n\tkfree(wirq->name);\nerr_free:\n\tkfree(wirq);\n\n\treturn err;\n}\n\n \nint dev_pm_set_dedicated_wake_irq(struct device *dev, int irq)\n{\n\treturn __dev_pm_set_dedicated_wake_irq(dev, irq, 0);\n}\nEXPORT_SYMBOL_GPL(dev_pm_set_dedicated_wake_irq);\n\n \nint dev_pm_set_dedicated_wake_irq_reverse(struct device *dev, int irq)\n{\n\treturn __dev_pm_set_dedicated_wake_irq(dev, irq, WAKE_IRQ_DEDICATED_REVERSE);\n}\nEXPORT_SYMBOL_GPL(dev_pm_set_dedicated_wake_irq_reverse);\n\n \nvoid dev_pm_enable_wake_irq_check(struct device *dev,\n\t\t\t\t  bool can_change_status)\n{\n\tstruct wake_irq *wirq = dev->power.wakeirq;\n\n\tif (!wirq || !(wirq->status & WAKE_IRQ_DEDICATED_MASK))\n\t\treturn;\n\n\tif (likely(wirq->status & WAKE_IRQ_DEDICATED_MANAGED)) {\n\t\tgoto enable;\n\t} else if (can_change_status) {\n\t\twirq->status |= WAKE_IRQ_DEDICATED_MANAGED;\n\t\tgoto enable;\n\t}\n\n\treturn;\n\nenable:\n\tif (!can_change_status || !(wirq->status & WAKE_IRQ_DEDICATED_REVERSE)) {\n\t\tenable_irq(wirq->irq);\n\t\twirq->status |= WAKE_IRQ_DEDICATED_ENABLED;\n\t}\n}\n\n \nvoid dev_pm_disable_wake_irq_check(struct device *dev, bool cond_disable)\n{\n\tstruct wake_irq *wirq = dev->power.wakeirq;\n\n\tif (!wirq || !(wirq->status & WAKE_IRQ_DEDICATED_MASK))\n\t\treturn;\n\n\tif (cond_disable && (wirq->status & WAKE_IRQ_DEDICATED_REVERSE))\n\t\treturn;\n\n\tif (wirq->status & WAKE_IRQ_DEDICATED_MANAGED) {\n\t\twirq->status &= ~WAKE_IRQ_DEDICATED_ENABLED;\n\t\tdisable_irq_nosync(wirq->irq);\n\t}\n}\n\n \nvoid dev_pm_enable_wake_irq_complete(struct device *dev)\n{\n\tstruct wake_irq *wirq = dev->power.wakeirq;\n\n\tif (!wirq || !(wirq->status & WAKE_IRQ_DEDICATED_MASK))\n\t\treturn;\n\n\tif (wirq->status & WAKE_IRQ_DEDICATED_MANAGED &&\n\t    wirq->status & WAKE_IRQ_DEDICATED_REVERSE)\n\t\tenable_irq(wirq->irq);\n}\n\n \nvoid dev_pm_arm_wake_irq(struct wake_irq *wirq)\n{\n\tif (!wirq)\n\t\treturn;\n\n\tif (device_may_wakeup(wirq->dev)) {\n\t\tif (wirq->status & WAKE_IRQ_DEDICATED_ALLOCATED &&\n\t\t    !(wirq->status & WAKE_IRQ_DEDICATED_ENABLED))\n\t\t\tenable_irq(wirq->irq);\n\n\t\tenable_irq_wake(wirq->irq);\n\t}\n}\n\n \nvoid dev_pm_disarm_wake_irq(struct wake_irq *wirq)\n{\n\tif (!wirq)\n\t\treturn;\n\n\tif (device_may_wakeup(wirq->dev)) {\n\t\tdisable_irq_wake(wirq->irq);\n\n\t\tif (wirq->status & WAKE_IRQ_DEDICATED_ALLOCATED &&\n\t\t    !(wirq->status & WAKE_IRQ_DEDICATED_ENABLED))\n\t\t\tdisable_irq_nosync(wirq->irq);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}