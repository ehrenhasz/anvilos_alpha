{
  "module_name": "sysfs.c",
  "hash_id": "8de005c51355a898dc117f0b21785bcb31bfb9318da857a01ce5226784c8cc8b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/base/power/sysfs.c",
  "human_readable_source": "\n \n#include <linux/device.h>\n#include <linux/kobject.h>\n#include <linux/string.h>\n#include <linux/export.h>\n#include <linux/pm_qos.h>\n#include <linux/pm_runtime.h>\n#include <linux/pm_wakeup.h>\n#include <linux/atomic.h>\n#include <linux/jiffies.h>\n#include \"power.h\"\n\n \n\nconst char power_group_name[] = \"power\";\nEXPORT_SYMBOL_GPL(power_group_name);\n\nstatic const char ctrl_auto[] = \"auto\";\nstatic const char ctrl_on[] = \"on\";\n\nstatic ssize_t control_show(struct device *dev, struct device_attribute *attr,\n\t\t\t    char *buf)\n{\n\treturn sysfs_emit(buf, \"%s\\n\",\n\t\t\t  dev->power.runtime_auto ? ctrl_auto : ctrl_on);\n}\n\nstatic ssize_t control_store(struct device * dev, struct device_attribute *attr,\n\t\t\t     const char * buf, size_t n)\n{\n\tdevice_lock(dev);\n\tif (sysfs_streq(buf, ctrl_auto))\n\t\tpm_runtime_allow(dev);\n\telse if (sysfs_streq(buf, ctrl_on))\n\t\tpm_runtime_forbid(dev);\n\telse\n\t\tn = -EINVAL;\n\tdevice_unlock(dev);\n\treturn n;\n}\n\nstatic DEVICE_ATTR_RW(control);\n\nstatic ssize_t runtime_active_time_show(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tchar *buf)\n{\n\tu64 tmp = pm_runtime_active_time(dev);\n\n\tdo_div(tmp, NSEC_PER_MSEC);\n\n\treturn sysfs_emit(buf, \"%llu\\n\", tmp);\n}\n\nstatic DEVICE_ATTR_RO(runtime_active_time);\n\nstatic ssize_t runtime_suspended_time_show(struct device *dev,\n\t\t\t\t\t   struct device_attribute *attr,\n\t\t\t\t\t   char *buf)\n{\n\tu64 tmp = pm_runtime_suspended_time(dev);\n\n\tdo_div(tmp, NSEC_PER_MSEC);\n\n\treturn sysfs_emit(buf, \"%llu\\n\", tmp);\n}\n\nstatic DEVICE_ATTR_RO(runtime_suspended_time);\n\nstatic ssize_t runtime_status_show(struct device *dev,\n\t\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tconst char *output;\n\n\tif (dev->power.runtime_error) {\n\t\toutput = \"error\";\n\t} else if (dev->power.disable_depth) {\n\t\toutput = \"unsupported\";\n\t} else {\n\t\tswitch (dev->power.runtime_status) {\n\t\tcase RPM_SUSPENDED:\n\t\t\toutput = \"suspended\";\n\t\t\tbreak;\n\t\tcase RPM_SUSPENDING:\n\t\t\toutput = \"suspending\";\n\t\t\tbreak;\n\t\tcase RPM_RESUMING:\n\t\t\toutput = \"resuming\";\n\t\t\tbreak;\n\t\tcase RPM_ACTIVE:\n\t\t\toutput = \"active\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\treturn sysfs_emit(buf, \"%s\\n\", output);\n}\n\nstatic DEVICE_ATTR_RO(runtime_status);\n\nstatic ssize_t autosuspend_delay_ms_show(struct device *dev,\n\t\t\t\t\t struct device_attribute *attr,\n\t\t\t\t\t char *buf)\n{\n\tif (!dev->power.use_autosuspend)\n\t\treturn -EIO;\n\n\treturn sysfs_emit(buf, \"%d\\n\", dev->power.autosuspend_delay);\n}\n\nstatic ssize_t autosuspend_delay_ms_store(struct device *dev,\n\t\tstruct device_attribute *attr, const char *buf, size_t n)\n{\n\tlong delay;\n\n\tif (!dev->power.use_autosuspend)\n\t\treturn -EIO;\n\n\tif (kstrtol(buf, 10, &delay) != 0 || delay != (int) delay)\n\t\treturn -EINVAL;\n\n\tdevice_lock(dev);\n\tpm_runtime_set_autosuspend_delay(dev, delay);\n\tdevice_unlock(dev);\n\treturn n;\n}\n\nstatic DEVICE_ATTR_RW(autosuspend_delay_ms);\n\nstatic ssize_t pm_qos_resume_latency_us_show(struct device *dev,\n\t\t\t\t\t     struct device_attribute *attr,\n\t\t\t\t\t     char *buf)\n{\n\ts32 value = dev_pm_qos_requested_resume_latency(dev);\n\n\tif (value == 0)\n\t\treturn sysfs_emit(buf, \"n/a\\n\");\n\tif (value == PM_QOS_RESUME_LATENCY_NO_CONSTRAINT)\n\t\tvalue = 0;\n\n\treturn sysfs_emit(buf, \"%d\\n\", value);\n}\n\nstatic ssize_t pm_qos_resume_latency_us_store(struct device *dev,\n\t\t\t\t\t      struct device_attribute *attr,\n\t\t\t\t\t      const char *buf, size_t n)\n{\n\ts32 value;\n\tint ret;\n\n\tif (!kstrtos32(buf, 0, &value)) {\n\t\t \n\t\tif (value < 0 || value == PM_QOS_RESUME_LATENCY_NO_CONSTRAINT)\n\t\t\treturn -EINVAL;\n\n\t\tif (value == 0)\n\t\t\tvalue = PM_QOS_RESUME_LATENCY_NO_CONSTRAINT;\n\t} else if (sysfs_streq(buf, \"n/a\")) {\n\t\tvalue = 0;\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\n\tret = dev_pm_qos_update_request(dev->power.qos->resume_latency_req,\n\t\t\t\t\tvalue);\n\treturn ret < 0 ? ret : n;\n}\n\nstatic DEVICE_ATTR_RW(pm_qos_resume_latency_us);\n\nstatic ssize_t pm_qos_latency_tolerance_us_show(struct device *dev,\n\t\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\t\tchar *buf)\n{\n\ts32 value = dev_pm_qos_get_user_latency_tolerance(dev);\n\n\tif (value < 0)\n\t\treturn sysfs_emit(buf, \"%s\\n\", \"auto\");\n\tif (value == PM_QOS_LATENCY_ANY)\n\t\treturn sysfs_emit(buf, \"%s\\n\", \"any\");\n\n\treturn sysfs_emit(buf, \"%d\\n\", value);\n}\n\nstatic ssize_t pm_qos_latency_tolerance_us_store(struct device *dev,\n\t\t\t\t\t\t struct device_attribute *attr,\n\t\t\t\t\t\t const char *buf, size_t n)\n{\n\ts32 value;\n\tint ret;\n\n\tif (kstrtos32(buf, 0, &value) == 0) {\n\t\t \n\t\tif (value < 0)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tif (sysfs_streq(buf, \"auto\"))\n\t\t\tvalue = PM_QOS_LATENCY_TOLERANCE_NO_CONSTRAINT;\n\t\telse if (sysfs_streq(buf, \"any\"))\n\t\t\tvalue = PM_QOS_LATENCY_ANY;\n\t\telse\n\t\t\treturn -EINVAL;\n\t}\n\tret = dev_pm_qos_update_user_latency_tolerance(dev, value);\n\treturn ret < 0 ? ret : n;\n}\n\nstatic DEVICE_ATTR_RW(pm_qos_latency_tolerance_us);\n\nstatic ssize_t pm_qos_no_power_off_show(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tchar *buf)\n{\n\treturn sysfs_emit(buf, \"%d\\n\", !!(dev_pm_qos_requested_flags(dev)\n\t\t\t\t\t  & PM_QOS_FLAG_NO_POWER_OFF));\n}\n\nstatic ssize_t pm_qos_no_power_off_store(struct device *dev,\n\t\t\t\t\t struct device_attribute *attr,\n\t\t\t\t\t const char *buf, size_t n)\n{\n\tint ret;\n\n\tif (kstrtoint(buf, 0, &ret))\n\t\treturn -EINVAL;\n\n\tif (ret != 0 && ret != 1)\n\t\treturn -EINVAL;\n\n\tret = dev_pm_qos_update_flags(dev, PM_QOS_FLAG_NO_POWER_OFF, ret);\n\treturn ret < 0 ? ret : n;\n}\n\nstatic DEVICE_ATTR_RW(pm_qos_no_power_off);\n\n#ifdef CONFIG_PM_SLEEP\nstatic const char _enabled[] = \"enabled\";\nstatic const char _disabled[] = \"disabled\";\n\nstatic ssize_t wakeup_show(struct device *dev, struct device_attribute *attr,\n\t\t\t   char *buf)\n{\n\treturn sysfs_emit(buf, \"%s\\n\", device_can_wakeup(dev)\n\t\t\t  ? (device_may_wakeup(dev) ? _enabled : _disabled)\n\t\t\t  : \"\");\n}\n\nstatic ssize_t wakeup_store(struct device *dev, struct device_attribute *attr,\n\t\t\t    const char *buf, size_t n)\n{\n\tif (!device_can_wakeup(dev))\n\t\treturn -EINVAL;\n\n\tif (sysfs_streq(buf, _enabled))\n\t\tdevice_set_wakeup_enable(dev, 1);\n\telse if (sysfs_streq(buf, _disabled))\n\t\tdevice_set_wakeup_enable(dev, 0);\n\telse\n\t\treturn -EINVAL;\n\treturn n;\n}\n\nstatic DEVICE_ATTR_RW(wakeup);\n\nstatic ssize_t wakeup_count_show(struct device *dev,\n\t\t\t\t struct device_attribute *attr, char *buf)\n{\n\tunsigned long count;\n\tbool enabled = false;\n\n\tspin_lock_irq(&dev->power.lock);\n\tif (dev->power.wakeup) {\n\t\tcount = dev->power.wakeup->wakeup_count;\n\t\tenabled = true;\n\t}\n\tspin_unlock_irq(&dev->power.lock);\n\n\tif (!enabled)\n\t\treturn sysfs_emit(buf, \"\\n\");\n\treturn sysfs_emit(buf, \"%lu\\n\", count);\n}\n\nstatic DEVICE_ATTR_RO(wakeup_count);\n\nstatic ssize_t wakeup_active_count_show(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tchar *buf)\n{\n\tunsigned long count;\n\tbool enabled = false;\n\n\tspin_lock_irq(&dev->power.lock);\n\tif (dev->power.wakeup) {\n\t\tcount = dev->power.wakeup->active_count;\n\t\tenabled = true;\n\t}\n\tspin_unlock_irq(&dev->power.lock);\n\n\tif (!enabled)\n\t\treturn sysfs_emit(buf, \"\\n\");\n\treturn sysfs_emit(buf, \"%lu\\n\", count);\n}\n\nstatic DEVICE_ATTR_RO(wakeup_active_count);\n\nstatic ssize_t wakeup_abort_count_show(struct device *dev,\n\t\t\t\t       struct device_attribute *attr,\n\t\t\t\t       char *buf)\n{\n\tunsigned long count;\n\tbool enabled = false;\n\n\tspin_lock_irq(&dev->power.lock);\n\tif (dev->power.wakeup) {\n\t\tcount = dev->power.wakeup->wakeup_count;\n\t\tenabled = true;\n\t}\n\tspin_unlock_irq(&dev->power.lock);\n\n\tif (!enabled)\n\t\treturn sysfs_emit(buf, \"\\n\");\n\treturn sysfs_emit(buf, \"%lu\\n\", count);\n}\n\nstatic DEVICE_ATTR_RO(wakeup_abort_count);\n\nstatic ssize_t wakeup_expire_count_show(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tchar *buf)\n{\n\tunsigned long count;\n\tbool enabled = false;\n\n\tspin_lock_irq(&dev->power.lock);\n\tif (dev->power.wakeup) {\n\t\tcount = dev->power.wakeup->expire_count;\n\t\tenabled = true;\n\t}\n\tspin_unlock_irq(&dev->power.lock);\n\n\tif (!enabled)\n\t\treturn sysfs_emit(buf, \"\\n\");\n\treturn sysfs_emit(buf, \"%lu\\n\", count);\n}\n\nstatic DEVICE_ATTR_RO(wakeup_expire_count);\n\nstatic ssize_t wakeup_active_show(struct device *dev,\n\t\t\t\t  struct device_attribute *attr, char *buf)\n{\n\tunsigned int active;\n\tbool enabled = false;\n\n\tspin_lock_irq(&dev->power.lock);\n\tif (dev->power.wakeup) {\n\t\tactive = dev->power.wakeup->active;\n\t\tenabled = true;\n\t}\n\tspin_unlock_irq(&dev->power.lock);\n\n\tif (!enabled)\n\t\treturn sysfs_emit(buf, \"\\n\");\n\treturn sysfs_emit(buf, \"%u\\n\", active);\n}\n\nstatic DEVICE_ATTR_RO(wakeup_active);\n\nstatic ssize_t wakeup_total_time_ms_show(struct device *dev,\n\t\t\t\t\t struct device_attribute *attr,\n\t\t\t\t\t char *buf)\n{\n\ts64 msec;\n\tbool enabled = false;\n\n\tspin_lock_irq(&dev->power.lock);\n\tif (dev->power.wakeup) {\n\t\tmsec = ktime_to_ms(dev->power.wakeup->total_time);\n\t\tenabled = true;\n\t}\n\tspin_unlock_irq(&dev->power.lock);\n\n\tif (!enabled)\n\t\treturn sysfs_emit(buf, \"\\n\");\n\treturn sysfs_emit(buf, \"%lld\\n\", msec);\n}\n\nstatic DEVICE_ATTR_RO(wakeup_total_time_ms);\n\nstatic ssize_t wakeup_max_time_ms_show(struct device *dev,\n\t\t\t\t       struct device_attribute *attr, char *buf)\n{\n\ts64 msec;\n\tbool enabled = false;\n\n\tspin_lock_irq(&dev->power.lock);\n\tif (dev->power.wakeup) {\n\t\tmsec = ktime_to_ms(dev->power.wakeup->max_time);\n\t\tenabled = true;\n\t}\n\tspin_unlock_irq(&dev->power.lock);\n\n\tif (!enabled)\n\t\treturn sysfs_emit(buf, \"\\n\");\n\treturn sysfs_emit(buf, \"%lld\\n\", msec);\n}\n\nstatic DEVICE_ATTR_RO(wakeup_max_time_ms);\n\nstatic ssize_t wakeup_last_time_ms_show(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tchar *buf)\n{\n\ts64 msec;\n\tbool enabled = false;\n\n\tspin_lock_irq(&dev->power.lock);\n\tif (dev->power.wakeup) {\n\t\tmsec = ktime_to_ms(dev->power.wakeup->last_time);\n\t\tenabled = true;\n\t}\n\tspin_unlock_irq(&dev->power.lock);\n\n\tif (!enabled)\n\t\treturn sysfs_emit(buf, \"\\n\");\n\treturn sysfs_emit(buf, \"%lld\\n\", msec);\n}\n\nstatic inline int dpm_sysfs_wakeup_change_owner(struct device *dev, kuid_t kuid,\n\t\t\t\t\t\tkgid_t kgid)\n{\n\tif (dev->power.wakeup && dev->power.wakeup->dev)\n\t\treturn device_change_owner(dev->power.wakeup->dev, kuid, kgid);\n\treturn 0;\n}\n\nstatic DEVICE_ATTR_RO(wakeup_last_time_ms);\n\n#ifdef CONFIG_PM_AUTOSLEEP\nstatic ssize_t wakeup_prevent_sleep_time_ms_show(struct device *dev,\n\t\t\t\t\t\t struct device_attribute *attr,\n\t\t\t\t\t\t char *buf)\n{\n\ts64 msec;\n\tbool enabled = false;\n\n\tspin_lock_irq(&dev->power.lock);\n\tif (dev->power.wakeup) {\n\t\tmsec = ktime_to_ms(dev->power.wakeup->prevent_sleep_time);\n\t\tenabled = true;\n\t}\n\tspin_unlock_irq(&dev->power.lock);\n\n\tif (!enabled)\n\t\treturn sysfs_emit(buf, \"\\n\");\n\treturn sysfs_emit(buf, \"%lld\\n\", msec);\n}\n\nstatic DEVICE_ATTR_RO(wakeup_prevent_sleep_time_ms);\n#endif  \n#else  \nstatic inline int dpm_sysfs_wakeup_change_owner(struct device *dev, kuid_t kuid,\n\t\t\t\t\t\tkgid_t kgid)\n{\n\treturn 0;\n}\n#endif\n\n#ifdef CONFIG_PM_ADVANCED_DEBUG\nstatic ssize_t runtime_usage_show(struct device *dev,\n\t\t\t\t  struct device_attribute *attr, char *buf)\n{\n\treturn sysfs_emit(buf, \"%d\\n\", atomic_read(&dev->power.usage_count));\n}\nstatic DEVICE_ATTR_RO(runtime_usage);\n\nstatic ssize_t runtime_active_kids_show(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tchar *buf)\n{\n\treturn sysfs_emit(buf, \"%d\\n\", dev->power.ignore_children ?\n\t\t\t  0 : atomic_read(&dev->power.child_count));\n}\nstatic DEVICE_ATTR_RO(runtime_active_kids);\n\nstatic ssize_t runtime_enabled_show(struct device *dev,\n\t\t\t\t    struct device_attribute *attr, char *buf)\n{\n\tconst char *output;\n\n\tif (dev->power.disable_depth && !dev->power.runtime_auto)\n\t\toutput = \"disabled & forbidden\";\n\telse if (dev->power.disable_depth)\n\t\toutput = \"disabled\";\n\telse if (!dev->power.runtime_auto)\n\t\toutput = \"forbidden\";\n\telse\n\t\toutput = \"enabled\";\n\n\treturn sysfs_emit(buf, \"%s\\n\", output);\n}\nstatic DEVICE_ATTR_RO(runtime_enabled);\n\n#ifdef CONFIG_PM_SLEEP\nstatic ssize_t async_show(struct device *dev, struct device_attribute *attr,\n\t\t\t  char *buf)\n{\n\treturn sysfs_emit(buf, \"%s\\n\",\n\t\t\t  device_async_suspend_enabled(dev) ?\n\t\t\t  _enabled : _disabled);\n}\n\nstatic ssize_t async_store(struct device *dev, struct device_attribute *attr,\n\t\t\t   const char *buf, size_t n)\n{\n\tif (sysfs_streq(buf, _enabled))\n\t\tdevice_enable_async_suspend(dev);\n\telse if (sysfs_streq(buf, _disabled))\n\t\tdevice_disable_async_suspend(dev);\n\telse\n\t\treturn -EINVAL;\n\treturn n;\n}\n\nstatic DEVICE_ATTR_RW(async);\n\n#endif  \n#endif  \n\nstatic struct attribute *power_attrs[] = {\n#ifdef CONFIG_PM_ADVANCED_DEBUG\n#ifdef CONFIG_PM_SLEEP\n\t&dev_attr_async.attr,\n#endif\n\t&dev_attr_runtime_status.attr,\n\t&dev_attr_runtime_usage.attr,\n\t&dev_attr_runtime_active_kids.attr,\n\t&dev_attr_runtime_enabled.attr,\n#endif  \n\tNULL,\n};\nstatic const struct attribute_group pm_attr_group = {\n\t.name\t= power_group_name,\n\t.attrs\t= power_attrs,\n};\n\nstatic struct attribute *wakeup_attrs[] = {\n#ifdef CONFIG_PM_SLEEP\n\t&dev_attr_wakeup.attr,\n\t&dev_attr_wakeup_count.attr,\n\t&dev_attr_wakeup_active_count.attr,\n\t&dev_attr_wakeup_abort_count.attr,\n\t&dev_attr_wakeup_expire_count.attr,\n\t&dev_attr_wakeup_active.attr,\n\t&dev_attr_wakeup_total_time_ms.attr,\n\t&dev_attr_wakeup_max_time_ms.attr,\n\t&dev_attr_wakeup_last_time_ms.attr,\n#ifdef CONFIG_PM_AUTOSLEEP\n\t&dev_attr_wakeup_prevent_sleep_time_ms.attr,\n#endif\n#endif\n\tNULL,\n};\nstatic const struct attribute_group pm_wakeup_attr_group = {\n\t.name\t= power_group_name,\n\t.attrs\t= wakeup_attrs,\n};\n\nstatic struct attribute *runtime_attrs[] = {\n#ifndef CONFIG_PM_ADVANCED_DEBUG\n\t&dev_attr_runtime_status.attr,\n#endif\n\t&dev_attr_control.attr,\n\t&dev_attr_runtime_suspended_time.attr,\n\t&dev_attr_runtime_active_time.attr,\n\t&dev_attr_autosuspend_delay_ms.attr,\n\tNULL,\n};\nstatic const struct attribute_group pm_runtime_attr_group = {\n\t.name\t= power_group_name,\n\t.attrs\t= runtime_attrs,\n};\n\nstatic struct attribute *pm_qos_resume_latency_attrs[] = {\n\t&dev_attr_pm_qos_resume_latency_us.attr,\n\tNULL,\n};\nstatic const struct attribute_group pm_qos_resume_latency_attr_group = {\n\t.name\t= power_group_name,\n\t.attrs\t= pm_qos_resume_latency_attrs,\n};\n\nstatic struct attribute *pm_qos_latency_tolerance_attrs[] = {\n\t&dev_attr_pm_qos_latency_tolerance_us.attr,\n\tNULL,\n};\nstatic const struct attribute_group pm_qos_latency_tolerance_attr_group = {\n\t.name\t= power_group_name,\n\t.attrs\t= pm_qos_latency_tolerance_attrs,\n};\n\nstatic struct attribute *pm_qos_flags_attrs[] = {\n\t&dev_attr_pm_qos_no_power_off.attr,\n\tNULL,\n};\nstatic const struct attribute_group pm_qos_flags_attr_group = {\n\t.name\t= power_group_name,\n\t.attrs\t= pm_qos_flags_attrs,\n};\n\nint dpm_sysfs_add(struct device *dev)\n{\n\tint rc;\n\n\t \n\tif (device_pm_not_required(dev))\n\t\treturn 0;\n\n\trc = sysfs_create_group(&dev->kobj, &pm_attr_group);\n\tif (rc)\n\t\treturn rc;\n\n\tif (!pm_runtime_has_no_callbacks(dev)) {\n\t\trc = sysfs_merge_group(&dev->kobj, &pm_runtime_attr_group);\n\t\tif (rc)\n\t\t\tgoto err_out;\n\t}\n\tif (device_can_wakeup(dev)) {\n\t\trc = sysfs_merge_group(&dev->kobj, &pm_wakeup_attr_group);\n\t\tif (rc)\n\t\t\tgoto err_runtime;\n\t}\n\tif (dev->power.set_latency_tolerance) {\n\t\trc = sysfs_merge_group(&dev->kobj,\n\t\t\t\t       &pm_qos_latency_tolerance_attr_group);\n\t\tif (rc)\n\t\t\tgoto err_wakeup;\n\t}\n\trc = pm_wakeup_source_sysfs_add(dev);\n\tif (rc)\n\t\tgoto err_latency;\n\treturn 0;\n\n err_latency:\n\tsysfs_unmerge_group(&dev->kobj, &pm_qos_latency_tolerance_attr_group);\n err_wakeup:\n\tsysfs_unmerge_group(&dev->kobj, &pm_wakeup_attr_group);\n err_runtime:\n\tsysfs_unmerge_group(&dev->kobj, &pm_runtime_attr_group);\n err_out:\n\tsysfs_remove_group(&dev->kobj, &pm_attr_group);\n\treturn rc;\n}\n\nint dpm_sysfs_change_owner(struct device *dev, kuid_t kuid, kgid_t kgid)\n{\n\tint rc;\n\n\tif (device_pm_not_required(dev))\n\t\treturn 0;\n\n\trc = sysfs_group_change_owner(&dev->kobj, &pm_attr_group, kuid, kgid);\n\tif (rc)\n\t\treturn rc;\n\n\tif (!pm_runtime_has_no_callbacks(dev)) {\n\t\trc = sysfs_group_change_owner(\n\t\t\t&dev->kobj, &pm_runtime_attr_group, kuid, kgid);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\tif (device_can_wakeup(dev)) {\n\t\trc = sysfs_group_change_owner(&dev->kobj, &pm_wakeup_attr_group,\n\t\t\t\t\t      kuid, kgid);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\trc = dpm_sysfs_wakeup_change_owner(dev, kuid, kgid);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\tif (dev->power.set_latency_tolerance) {\n\t\trc = sysfs_group_change_owner(\n\t\t\t&dev->kobj, &pm_qos_latency_tolerance_attr_group, kuid,\n\t\t\tkgid);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\treturn 0;\n}\n\nint wakeup_sysfs_add(struct device *dev)\n{\n\tint ret = sysfs_merge_group(&dev->kobj, &pm_wakeup_attr_group);\n\n\tif (!ret)\n\t\tkobject_uevent(&dev->kobj, KOBJ_CHANGE);\n\n\treturn ret;\n}\n\nvoid wakeup_sysfs_remove(struct device *dev)\n{\n\tsysfs_unmerge_group(&dev->kobj, &pm_wakeup_attr_group);\n\tkobject_uevent(&dev->kobj, KOBJ_CHANGE);\n}\n\nint pm_qos_sysfs_add_resume_latency(struct device *dev)\n{\n\treturn sysfs_merge_group(&dev->kobj, &pm_qos_resume_latency_attr_group);\n}\n\nvoid pm_qos_sysfs_remove_resume_latency(struct device *dev)\n{\n\tsysfs_unmerge_group(&dev->kobj, &pm_qos_resume_latency_attr_group);\n}\n\nint pm_qos_sysfs_add_flags(struct device *dev)\n{\n\treturn sysfs_merge_group(&dev->kobj, &pm_qos_flags_attr_group);\n}\n\nvoid pm_qos_sysfs_remove_flags(struct device *dev)\n{\n\tsysfs_unmerge_group(&dev->kobj, &pm_qos_flags_attr_group);\n}\n\nint pm_qos_sysfs_add_latency_tolerance(struct device *dev)\n{\n\treturn sysfs_merge_group(&dev->kobj,\n\t\t\t\t &pm_qos_latency_tolerance_attr_group);\n}\n\nvoid pm_qos_sysfs_remove_latency_tolerance(struct device *dev)\n{\n\tsysfs_unmerge_group(&dev->kobj, &pm_qos_latency_tolerance_attr_group);\n}\n\nvoid rpm_sysfs_remove(struct device *dev)\n{\n\tsysfs_unmerge_group(&dev->kobj, &pm_runtime_attr_group);\n}\n\nvoid dpm_sysfs_remove(struct device *dev)\n{\n\tif (device_pm_not_required(dev))\n\t\treturn;\n\tsysfs_unmerge_group(&dev->kobj, &pm_qos_latency_tolerance_attr_group);\n\tdev_pm_qos_constraints_destroy(dev);\n\trpm_sysfs_remove(dev);\n\tsysfs_unmerge_group(&dev->kobj, &pm_wakeup_attr_group);\n\tsysfs_remove_group(&dev->kobj, &pm_attr_group);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}