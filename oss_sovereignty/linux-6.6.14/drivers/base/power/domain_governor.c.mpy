{
  "module_name": "domain_governor.c",
  "hash_id": "54e55aac093850887076901b249ec0710577850161b9c940670f63cc1967a6a6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/base/power/domain_governor.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n#include <linux/pm_domain.h>\n#include <linux/pm_qos.h>\n#include <linux/hrtimer.h>\n#include <linux/cpuidle.h>\n#include <linux/cpumask.h>\n#include <linux/ktime.h>\n\nstatic int dev_update_qos_constraint(struct device *dev, void *data)\n{\n\ts64 *constraint_ns_p = data;\n\ts64 constraint_ns;\n\n\tif (dev->power.subsys_data && dev->power.subsys_data->domain_data) {\n\t\tstruct gpd_timing_data *td = dev_gpd_data(dev)->td;\n\n\t\t \n\t\tconstraint_ns = td ? td->effective_constraint_ns :\n\t\t\t\tPM_QOS_RESUME_LATENCY_NO_CONSTRAINT_NS;\n\t} else {\n\t\t \n\t\tconstraint_ns = dev_pm_qos_read_value(dev, DEV_PM_QOS_RESUME_LATENCY);\n\t\tconstraint_ns *= NSEC_PER_USEC;\n\t}\n\n\tif (constraint_ns < *constraint_ns_p)\n\t\t*constraint_ns_p = constraint_ns;\n\n\treturn 0;\n}\n\n \nstatic bool default_suspend_ok(struct device *dev)\n{\n\tstruct gpd_timing_data *td = dev_gpd_data(dev)->td;\n\tunsigned long flags;\n\ts64 constraint_ns;\n\n\tdev_dbg(dev, \"%s()\\n\", __func__);\n\n\tspin_lock_irqsave(&dev->power.lock, flags);\n\n\tif (!td->constraint_changed) {\n\t\tbool ret = td->cached_suspend_ok;\n\n\t\tspin_unlock_irqrestore(&dev->power.lock, flags);\n\t\treturn ret;\n\t}\n\ttd->constraint_changed = false;\n\ttd->cached_suspend_ok = false;\n\ttd->effective_constraint_ns = 0;\n\tconstraint_ns = __dev_pm_qos_resume_latency(dev);\n\n\tspin_unlock_irqrestore(&dev->power.lock, flags);\n\n\tif (constraint_ns == 0)\n\t\treturn false;\n\n\tconstraint_ns *= NSEC_PER_USEC;\n\t \n\tif (!dev->power.ignore_children)\n\t\tdevice_for_each_child(dev, &constraint_ns,\n\t\t\t\t      dev_update_qos_constraint);\n\n\tif (constraint_ns == PM_QOS_RESUME_LATENCY_NO_CONSTRAINT_NS) {\n\t\t \n\t\ttd->effective_constraint_ns = PM_QOS_RESUME_LATENCY_NO_CONSTRAINT_NS;\n\t\ttd->cached_suspend_ok = true;\n\t} else if (constraint_ns == 0) {\n\t\t \n\t\treturn false;\n\t} else {\n\t\tconstraint_ns -= td->suspend_latency_ns +\n\t\t\t\ttd->resume_latency_ns;\n\t\t \n\t\tif (constraint_ns <= 0)\n\t\t\treturn false;\n\n\t\ttd->effective_constraint_ns = constraint_ns;\n\t\ttd->cached_suspend_ok = true;\n\t}\n\n\t \n\treturn td->cached_suspend_ok;\n}\n\nstatic void update_domain_next_wakeup(struct generic_pm_domain *genpd, ktime_t now)\n{\n\tktime_t domain_wakeup = KTIME_MAX;\n\tktime_t next_wakeup;\n\tstruct pm_domain_data *pdd;\n\tstruct gpd_link *link;\n\n\tif (!(genpd->flags & GENPD_FLAG_MIN_RESIDENCY))\n\t\treturn;\n\n\t \n\tlist_for_each_entry(pdd, &genpd->dev_list, list_node) {\n\t\tnext_wakeup = to_gpd_data(pdd)->td->next_wakeup;\n\t\tif (next_wakeup != KTIME_MAX && !ktime_before(next_wakeup, now))\n\t\t\tif (ktime_before(next_wakeup, domain_wakeup))\n\t\t\t\tdomain_wakeup = next_wakeup;\n\t}\n\n\tlist_for_each_entry(link, &genpd->parent_links, parent_node) {\n\t\tstruct genpd_governor_data *cgd = link->child->gd;\n\n\t\tnext_wakeup = cgd ? cgd->next_wakeup : KTIME_MAX;\n\t\tif (next_wakeup != KTIME_MAX && !ktime_before(next_wakeup, now))\n\t\t\tif (ktime_before(next_wakeup, domain_wakeup))\n\t\t\t\tdomain_wakeup = next_wakeup;\n\t}\n\n\tgenpd->gd->next_wakeup = domain_wakeup;\n}\n\nstatic bool next_wakeup_allows_state(struct generic_pm_domain *genpd,\n\t\t\t\t     unsigned int state, ktime_t now)\n{\n\tktime_t domain_wakeup = genpd->gd->next_wakeup;\n\ts64 idle_time_ns, min_sleep_ns;\n\n\tmin_sleep_ns = genpd->states[state].power_off_latency_ns +\n\t\t       genpd->states[state].residency_ns;\n\n\tidle_time_ns = ktime_to_ns(ktime_sub(domain_wakeup, now));\n\n\treturn idle_time_ns >= min_sleep_ns;\n}\n\nstatic bool __default_power_down_ok(struct dev_pm_domain *pd,\n\t\t\t\t     unsigned int state)\n{\n\tstruct generic_pm_domain *genpd = pd_to_genpd(pd);\n\tstruct gpd_link *link;\n\tstruct pm_domain_data *pdd;\n\ts64 min_off_time_ns;\n\ts64 off_on_time_ns;\n\n\toff_on_time_ns = genpd->states[state].power_off_latency_ns +\n\t\tgenpd->states[state].power_on_latency_ns;\n\n\tmin_off_time_ns = -1;\n\t \n\tlist_for_each_entry(link, &genpd->parent_links, parent_node) {\n\t\tstruct genpd_governor_data *cgd = link->child->gd;\n\n\t\ts64 sd_max_off_ns = cgd ? cgd->max_off_time_ns : -1;\n\n\t\tif (sd_max_off_ns < 0)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (sd_max_off_ns <= off_on_time_ns)\n\t\t\treturn false;\n\n\t\tif (min_off_time_ns > sd_max_off_ns || min_off_time_ns < 0)\n\t\t\tmin_off_time_ns = sd_max_off_ns;\n\t}\n\n\t \n\tlist_for_each_entry(pdd, &genpd->dev_list, list_node) {\n\t\tstruct gpd_timing_data *td;\n\t\ts64 constraint_ns;\n\n\t\t \n\t\ttd = to_gpd_data(pdd)->td;\n\t\tconstraint_ns = td->effective_constraint_ns;\n\t\t \n\t\tif (constraint_ns == PM_QOS_RESUME_LATENCY_NO_CONSTRAINT_NS)\n\t\t\tcontinue;\n\n\t\tif (constraint_ns <= off_on_time_ns)\n\t\t\treturn false;\n\n\t\tif (min_off_time_ns > constraint_ns || min_off_time_ns < 0)\n\t\t\tmin_off_time_ns = constraint_ns;\n\t}\n\n\t \n\tif (min_off_time_ns < 0)\n\t\treturn true;\n\n\t \n\tgenpd->gd->max_off_time_ns = min_off_time_ns -\n\t\tgenpd->states[state].power_on_latency_ns;\n\treturn true;\n}\n\n \nstatic bool _default_power_down_ok(struct dev_pm_domain *pd, ktime_t now)\n{\n\tstruct generic_pm_domain *genpd = pd_to_genpd(pd);\n\tstruct genpd_governor_data *gd = genpd->gd;\n\tint state_idx = genpd->state_count - 1;\n\tstruct gpd_link *link;\n\n\t \n\tupdate_domain_next_wakeup(genpd, now);\n\tif ((genpd->flags & GENPD_FLAG_MIN_RESIDENCY) && (gd->next_wakeup != KTIME_MAX)) {\n\t\t \n\t\twhile (state_idx >= 0) {\n\t\t\tif (next_wakeup_allows_state(genpd, state_idx, now)) {\n\t\t\t\tgd->max_off_time_changed = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tstate_idx--;\n\t\t}\n\n\t\tif (state_idx < 0) {\n\t\t\tstate_idx = 0;\n\t\t\tgd->cached_power_down_ok = false;\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\tif (!gd->max_off_time_changed) {\n\t\tgenpd->state_idx = gd->cached_power_down_state_idx;\n\t\treturn gd->cached_power_down_ok;\n\t}\n\n\t \n\tlist_for_each_entry(link, &genpd->child_links, child_node) {\n\t\tstruct genpd_governor_data *pgd = link->parent->gd;\n\n\t\tif (pgd)\n\t\t\tpgd->max_off_time_changed = true;\n\t}\n\n\tgd->max_off_time_ns = -1;\n\tgd->max_off_time_changed = false;\n\tgd->cached_power_down_ok = true;\n\n\t \n\twhile (!__default_power_down_ok(pd, state_idx)) {\n\t\tif (state_idx == 0) {\n\t\t\tgd->cached_power_down_ok = false;\n\t\t\tbreak;\n\t\t}\n\t\tstate_idx--;\n\t}\n\ndone:\n\tgenpd->state_idx = state_idx;\n\tgd->cached_power_down_state_idx = genpd->state_idx;\n\treturn gd->cached_power_down_ok;\n}\n\nstatic bool default_power_down_ok(struct dev_pm_domain *pd)\n{\n\treturn _default_power_down_ok(pd, ktime_get());\n}\n\n#ifdef CONFIG_CPU_IDLE\nstatic bool cpu_power_down_ok(struct dev_pm_domain *pd)\n{\n\tstruct generic_pm_domain *genpd = pd_to_genpd(pd);\n\tstruct cpuidle_device *dev;\n\tktime_t domain_wakeup, next_hrtimer;\n\tktime_t now = ktime_get();\n\ts64 idle_duration_ns;\n\tint cpu, i;\n\n\t \n\tif (!_default_power_down_ok(pd, now))\n\t\treturn false;\n\n\tif (!(genpd->flags & GENPD_FLAG_CPU_DOMAIN))\n\t\treturn true;\n\n\t \n\tdomain_wakeup = ktime_set(KTIME_SEC_MAX, 0);\n\tfor_each_cpu_and(cpu, genpd->cpus, cpu_online_mask) {\n\t\tdev = per_cpu(cpuidle_devices, cpu);\n\t\tif (dev) {\n\t\t\tnext_hrtimer = READ_ONCE(dev->next_hrtimer);\n\t\t\tif (ktime_before(next_hrtimer, domain_wakeup))\n\t\t\t\tdomain_wakeup = next_hrtimer;\n\t\t}\n\t}\n\n\t \n\tidle_duration_ns = ktime_to_ns(ktime_sub(domain_wakeup, now));\n\tif (idle_duration_ns <= 0)\n\t\treturn false;\n\n\t \n\tgenpd->gd->next_hrtimer = domain_wakeup;\n\n\t \n\ti = genpd->state_idx;\n\tdo {\n\t\tif (idle_duration_ns >= (genpd->states[i].residency_ns +\n\t\t    genpd->states[i].power_off_latency_ns)) {\n\t\t\tgenpd->state_idx = i;\n\t\t\treturn true;\n\t\t}\n\t} while (--i >= 0);\n\n\treturn false;\n}\n\nstruct dev_power_governor pm_domain_cpu_gov = {\n\t.suspend_ok = default_suspend_ok,\n\t.power_down_ok = cpu_power_down_ok,\n};\n#endif\n\nstruct dev_power_governor simple_qos_governor = {\n\t.suspend_ok = default_suspend_ok,\n\t.power_down_ok = default_power_down_ok,\n};\n\n \nstruct dev_power_governor pm_domain_always_on_gov = {\n\t.suspend_ok = default_suspend_ok,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}