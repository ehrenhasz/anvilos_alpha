{
  "module_name": "wakeup_stats.c",
  "hash_id": "a51fae426b2b1023e1a54478d3767032aaa7a5b7a5654daca9206297877692a3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/base/power/wakeup_stats.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/idr.h>\n#include <linux/init.h>\n#include <linux/kdev_t.h>\n#include <linux/kernel.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/timekeeping.h>\n\n#include \"power.h\"\n\nstatic struct class *wakeup_class;\n\n#define wakeup_attr(_name)\t\t\t\t\t\t\\\nstatic ssize_t _name##_show(struct device *dev,\t\t\t\t\\\n\t\t\t    struct device_attribute *attr, char *buf)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct wakeup_source *ws = dev_get_drvdata(dev);\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\treturn sysfs_emit(buf, \"%lu\\n\", ws->_name);\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\nstatic DEVICE_ATTR_RO(_name)\n\nwakeup_attr(active_count);\nwakeup_attr(event_count);\nwakeup_attr(wakeup_count);\nwakeup_attr(expire_count);\n\nstatic ssize_t active_time_ms_show(struct device *dev,\n\t\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tstruct wakeup_source *ws = dev_get_drvdata(dev);\n\tktime_t active_time =\n\t\tws->active ? ktime_sub(ktime_get(), ws->last_time) : 0;\n\n\treturn sysfs_emit(buf, \"%lld\\n\", ktime_to_ms(active_time));\n}\nstatic DEVICE_ATTR_RO(active_time_ms);\n\nstatic ssize_t total_time_ms_show(struct device *dev,\n\t\t\t\t  struct device_attribute *attr, char *buf)\n{\n\tstruct wakeup_source *ws = dev_get_drvdata(dev);\n\tktime_t active_time;\n\tktime_t total_time = ws->total_time;\n\n\tif (ws->active) {\n\t\tactive_time = ktime_sub(ktime_get(), ws->last_time);\n\t\ttotal_time = ktime_add(total_time, active_time);\n\t}\n\n\treturn sysfs_emit(buf, \"%lld\\n\", ktime_to_ms(total_time));\n}\nstatic DEVICE_ATTR_RO(total_time_ms);\n\nstatic ssize_t max_time_ms_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct wakeup_source *ws = dev_get_drvdata(dev);\n\tktime_t active_time;\n\tktime_t max_time = ws->max_time;\n\n\tif (ws->active) {\n\t\tactive_time = ktime_sub(ktime_get(), ws->last_time);\n\t\tif (active_time > max_time)\n\t\t\tmax_time = active_time;\n\t}\n\n\treturn sysfs_emit(buf, \"%lld\\n\", ktime_to_ms(max_time));\n}\nstatic DEVICE_ATTR_RO(max_time_ms);\n\nstatic ssize_t last_change_ms_show(struct device *dev,\n\t\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tstruct wakeup_source *ws = dev_get_drvdata(dev);\n\n\treturn sysfs_emit(buf, \"%lld\\n\", ktime_to_ms(ws->last_time));\n}\nstatic DEVICE_ATTR_RO(last_change_ms);\n\nstatic ssize_t name_show(struct device *dev, struct device_attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct wakeup_source *ws = dev_get_drvdata(dev);\n\n\treturn sysfs_emit(buf, \"%s\\n\", ws->name);\n}\nstatic DEVICE_ATTR_RO(name);\n\nstatic ssize_t prevent_suspend_time_ms_show(struct device *dev,\n\t\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t\t    char *buf)\n{\n\tstruct wakeup_source *ws = dev_get_drvdata(dev);\n\tktime_t prevent_sleep_time = ws->prevent_sleep_time;\n\n\tif (ws->active && ws->autosleep_enabled) {\n\t\tprevent_sleep_time = ktime_add(prevent_sleep_time,\n\t\t\tktime_sub(ktime_get(), ws->start_prevent_time));\n\t}\n\n\treturn sysfs_emit(buf, \"%lld\\n\", ktime_to_ms(prevent_sleep_time));\n}\nstatic DEVICE_ATTR_RO(prevent_suspend_time_ms);\n\nstatic struct attribute *wakeup_source_attrs[] = {\n\t&dev_attr_name.attr,\n\t&dev_attr_active_count.attr,\n\t&dev_attr_event_count.attr,\n\t&dev_attr_wakeup_count.attr,\n\t&dev_attr_expire_count.attr,\n\t&dev_attr_active_time_ms.attr,\n\t&dev_attr_total_time_ms.attr,\n\t&dev_attr_max_time_ms.attr,\n\t&dev_attr_last_change_ms.attr,\n\t&dev_attr_prevent_suspend_time_ms.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(wakeup_source);\n\nstatic void device_create_release(struct device *dev)\n{\n\tkfree(dev);\n}\n\nstatic struct device *wakeup_source_device_create(struct device *parent,\n\t\t\t\t\t\t  struct wakeup_source *ws)\n{\n\tstruct device *dev = NULL;\n\tint retval;\n\n\tdev = kzalloc(sizeof(*dev), GFP_KERNEL);\n\tif (!dev) {\n\t\tretval = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\tdevice_initialize(dev);\n\tdev->devt = MKDEV(0, 0);\n\tdev->class = wakeup_class;\n\tdev->parent = parent;\n\tdev->groups = wakeup_source_groups;\n\tdev->release = device_create_release;\n\tdev_set_drvdata(dev, ws);\n\tdevice_set_pm_not_required(dev);\n\n\tretval = dev_set_name(dev, \"wakeup%d\", ws->id);\n\tif (retval)\n\t\tgoto error;\n\n\tretval = device_add(dev);\n\tif (retval)\n\t\tgoto error;\n\n\treturn dev;\n\nerror:\n\tput_device(dev);\n\treturn ERR_PTR(retval);\n}\n\n \nint wakeup_source_sysfs_add(struct device *parent, struct wakeup_source *ws)\n{\n\tstruct device *dev;\n\n\tdev = wakeup_source_device_create(parent, ws);\n\tif (IS_ERR(dev))\n\t\treturn PTR_ERR(dev);\n\tws->dev = dev;\n\n\treturn 0;\n}\n\n \nint pm_wakeup_source_sysfs_add(struct device *parent)\n{\n\tif (!parent->power.wakeup || parent->power.wakeup->dev)\n\t\treturn 0;\n\n\treturn wakeup_source_sysfs_add(parent, parent->power.wakeup);\n}\n\n \nvoid wakeup_source_sysfs_remove(struct wakeup_source *ws)\n{\n\tdevice_unregister(ws->dev);\n}\n\nstatic int __init wakeup_sources_sysfs_init(void)\n{\n\twakeup_class = class_create(\"wakeup\");\n\n\treturn PTR_ERR_OR_ZERO(wakeup_class);\n}\npostcore_initcall(wakeup_sources_sysfs_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}