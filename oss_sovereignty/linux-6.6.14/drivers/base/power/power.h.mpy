{
  "module_name": "power.h",
  "hash_id": "e72badc79e196bb56e4bfd3a3e50b143f64ccf8433cefc2735afc8a98c602b79",
  "original_prompt": "Ingested from linux-6.6.14/drivers/base/power/power.h",
  "human_readable_source": " \n#include <linux/pm_qos.h>\n\nstatic inline void device_pm_init_common(struct device *dev)\n{\n\tif (!dev->power.early_init) {\n\t\tspin_lock_init(&dev->power.lock);\n\t\tdev->power.qos = NULL;\n\t\tdev->power.early_init = true;\n\t}\n}\n\n#ifdef CONFIG_PM\n\nstatic inline void pm_runtime_early_init(struct device *dev)\n{\n\tdev->power.disable_depth = 1;\n\tdevice_pm_init_common(dev);\n}\n\nextern void pm_runtime_init(struct device *dev);\nextern void pm_runtime_reinit(struct device *dev);\nextern void pm_runtime_remove(struct device *dev);\nextern u64 pm_runtime_active_time(struct device *dev);\n\n#define WAKE_IRQ_DEDICATED_ALLOCATED\tBIT(0)\n#define WAKE_IRQ_DEDICATED_MANAGED\tBIT(1)\n#define WAKE_IRQ_DEDICATED_REVERSE\tBIT(2)\n#define WAKE_IRQ_DEDICATED_MASK\t\t(WAKE_IRQ_DEDICATED_ALLOCATED | \\\n\t\t\t\t\t WAKE_IRQ_DEDICATED_MANAGED | \\\n\t\t\t\t\t WAKE_IRQ_DEDICATED_REVERSE)\n#define WAKE_IRQ_DEDICATED_ENABLED\tBIT(3)\n\nstruct wake_irq {\n\tstruct device *dev;\n\tunsigned int status;\n\tint irq;\n\tconst char *name;\n};\n\nextern void dev_pm_arm_wake_irq(struct wake_irq *wirq);\nextern void dev_pm_disarm_wake_irq(struct wake_irq *wirq);\nextern void dev_pm_enable_wake_irq_check(struct device *dev,\n\t\t\t\t\t bool can_change_status);\nextern void dev_pm_disable_wake_irq_check(struct device *dev, bool cond_disable);\nextern void dev_pm_enable_wake_irq_complete(struct device *dev);\n\n#ifdef CONFIG_PM_SLEEP\n\nextern void device_wakeup_attach_irq(struct device *dev, struct wake_irq *wakeirq);\nextern void device_wakeup_detach_irq(struct device *dev);\nextern void device_wakeup_arm_wake_irqs(void);\nextern void device_wakeup_disarm_wake_irqs(void);\n\n#else\n\nstatic inline void device_wakeup_attach_irq(struct device *dev,\n\t\t\t\t\t    struct wake_irq *wakeirq) {}\n\nstatic inline void device_wakeup_detach_irq(struct device *dev)\n{\n}\n\n#endif  \n\n \n\nextern int dpm_sysfs_add(struct device *dev);\nextern void dpm_sysfs_remove(struct device *dev);\nextern void rpm_sysfs_remove(struct device *dev);\nextern int wakeup_sysfs_add(struct device *dev);\nextern void wakeup_sysfs_remove(struct device *dev);\nextern int pm_qos_sysfs_add_resume_latency(struct device *dev);\nextern void pm_qos_sysfs_remove_resume_latency(struct device *dev);\nextern int pm_qos_sysfs_add_flags(struct device *dev);\nextern void pm_qos_sysfs_remove_flags(struct device *dev);\nextern int pm_qos_sysfs_add_latency_tolerance(struct device *dev);\nextern void pm_qos_sysfs_remove_latency_tolerance(struct device *dev);\nextern int dpm_sysfs_change_owner(struct device *dev, kuid_t kuid, kgid_t kgid);\n\n#else  \n\nstatic inline void pm_runtime_early_init(struct device *dev)\n{\n\tdevice_pm_init_common(dev);\n}\n\nstatic inline void pm_runtime_init(struct device *dev) {}\nstatic inline void pm_runtime_reinit(struct device *dev) {}\nstatic inline void pm_runtime_remove(struct device *dev) {}\n\nstatic inline int dpm_sysfs_add(struct device *dev) { return 0; }\nstatic inline void dpm_sysfs_remove(struct device *dev) {}\nstatic inline int dpm_sysfs_change_owner(struct device *dev, kuid_t kuid,\n\t\t\t\t\t kgid_t kgid) { return 0; }\n\n#endif\n\n#ifdef CONFIG_PM_SLEEP\n\n \nextern int pm_async_enabled;\n\n \nextern struct list_head dpm_list;\t \n\nstatic inline struct device *to_device(struct list_head *entry)\n{\n\treturn container_of(entry, struct device, power.entry);\n}\n\nextern void device_pm_sleep_init(struct device *dev);\nextern void device_pm_add(struct device *);\nextern void device_pm_remove(struct device *);\nextern void device_pm_move_before(struct device *, struct device *);\nextern void device_pm_move_after(struct device *, struct device *);\nextern void device_pm_move_last(struct device *);\nextern void device_pm_check_callbacks(struct device *dev);\n\nstatic inline bool device_pm_initialized(struct device *dev)\n{\n\treturn dev->power.in_dpm_list;\n}\n\n \nextern int wakeup_source_sysfs_add(struct device *parent,\n\t\t\t\t   struct wakeup_source *ws);\nextern void wakeup_source_sysfs_remove(struct wakeup_source *ws);\n\nextern int pm_wakeup_source_sysfs_add(struct device *parent);\n\n#else  \n\nstatic inline void device_pm_sleep_init(struct device *dev) {}\n\nstatic inline void device_pm_add(struct device *dev) {}\n\nstatic inline void device_pm_remove(struct device *dev)\n{\n\tpm_runtime_remove(dev);\n}\n\nstatic inline void device_pm_move_before(struct device *deva,\n\t\t\t\t\t struct device *devb) {}\nstatic inline void device_pm_move_after(struct device *deva,\n\t\t\t\t\tstruct device *devb) {}\nstatic inline void device_pm_move_last(struct device *dev) {}\n\nstatic inline void device_pm_check_callbacks(struct device *dev) {}\n\nstatic inline bool device_pm_initialized(struct device *dev)\n{\n\treturn device_is_registered(dev);\n}\n\nstatic inline int pm_wakeup_source_sysfs_add(struct device *parent)\n{\n\treturn 0;\n}\n\n#endif  \n\nstatic inline void device_pm_init(struct device *dev)\n{\n\tdevice_pm_init_common(dev);\n\tdevice_pm_sleep_init(dev);\n\tpm_runtime_init(dev);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}