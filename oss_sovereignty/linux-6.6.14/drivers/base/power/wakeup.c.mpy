{
  "module_name": "wakeup.c",
  "hash_id": "edb9f8e5f18fe019d1ea877c9a6062b7145342cf552b10cb6393fa6c9469e9c0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/base/power/wakeup.c",
  "human_readable_source": "\n \n#define pr_fmt(fmt) \"PM: \" fmt\n\n#include <linux/device.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pm_wakeirq.h>\n#include <trace/events/power.h>\n\n#include \"power.h\"\n\n#define list_for_each_entry_rcu_locked(pos, head, member) \\\n\tlist_for_each_entry_rcu(pos, head, member, \\\n\t\tsrcu_read_lock_held(&wakeup_srcu))\n \nbool events_check_enabled __read_mostly;\n\n \nstatic unsigned int wakeup_irq[2] __read_mostly;\nstatic DEFINE_RAW_SPINLOCK(wakeup_irq_lock);\n\n \nstatic atomic_t pm_abort_suspend __read_mostly;\n\n \nstatic atomic_t combined_event_count = ATOMIC_INIT(0);\n\n#define IN_PROGRESS_BITS\t(sizeof(int) * 4)\n#define MAX_IN_PROGRESS\t\t((1 << IN_PROGRESS_BITS) - 1)\n\nstatic void split_counters(unsigned int *cnt, unsigned int *inpr)\n{\n\tunsigned int comb = atomic_read(&combined_event_count);\n\n\t*cnt = (comb >> IN_PROGRESS_BITS);\n\t*inpr = comb & MAX_IN_PROGRESS;\n}\n\n \nstatic unsigned int saved_count;\n\nstatic DEFINE_RAW_SPINLOCK(events_lock);\n\nstatic void pm_wakeup_timer_fn(struct timer_list *t);\n\nstatic LIST_HEAD(wakeup_sources);\n\nstatic DECLARE_WAIT_QUEUE_HEAD(wakeup_count_wait_queue);\n\nDEFINE_STATIC_SRCU(wakeup_srcu);\n\nstatic struct wakeup_source deleted_ws = {\n\t.name = \"deleted\",\n\t.lock =  __SPIN_LOCK_UNLOCKED(deleted_ws.lock),\n};\n\nstatic DEFINE_IDA(wakeup_ida);\n\n \nstruct wakeup_source *wakeup_source_create(const char *name)\n{\n\tstruct wakeup_source *ws;\n\tconst char *ws_name;\n\tint id;\n\n\tws = kzalloc(sizeof(*ws), GFP_KERNEL);\n\tif (!ws)\n\t\tgoto err_ws;\n\n\tws_name = kstrdup_const(name, GFP_KERNEL);\n\tif (!ws_name)\n\t\tgoto err_name;\n\tws->name = ws_name;\n\n\tid = ida_alloc(&wakeup_ida, GFP_KERNEL);\n\tif (id < 0)\n\t\tgoto err_id;\n\tws->id = id;\n\n\treturn ws;\n\nerr_id:\n\tkfree_const(ws->name);\nerr_name:\n\tkfree(ws);\nerr_ws:\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(wakeup_source_create);\n\n \nstatic void wakeup_source_record(struct wakeup_source *ws)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&deleted_ws.lock, flags);\n\n\tif (ws->event_count) {\n\t\tdeleted_ws.total_time =\n\t\t\tktime_add(deleted_ws.total_time, ws->total_time);\n\t\tdeleted_ws.prevent_sleep_time =\n\t\t\tktime_add(deleted_ws.prevent_sleep_time,\n\t\t\t\t  ws->prevent_sleep_time);\n\t\tdeleted_ws.max_time =\n\t\t\tktime_compare(deleted_ws.max_time, ws->max_time) > 0 ?\n\t\t\t\tdeleted_ws.max_time : ws->max_time;\n\t\tdeleted_ws.event_count += ws->event_count;\n\t\tdeleted_ws.active_count += ws->active_count;\n\t\tdeleted_ws.relax_count += ws->relax_count;\n\t\tdeleted_ws.expire_count += ws->expire_count;\n\t\tdeleted_ws.wakeup_count += ws->wakeup_count;\n\t}\n\n\tspin_unlock_irqrestore(&deleted_ws.lock, flags);\n}\n\nstatic void wakeup_source_free(struct wakeup_source *ws)\n{\n\tida_free(&wakeup_ida, ws->id);\n\tkfree_const(ws->name);\n\tkfree(ws);\n}\n\n \nvoid wakeup_source_destroy(struct wakeup_source *ws)\n{\n\tif (!ws)\n\t\treturn;\n\n\t__pm_relax(ws);\n\twakeup_source_record(ws);\n\twakeup_source_free(ws);\n}\nEXPORT_SYMBOL_GPL(wakeup_source_destroy);\n\n \nvoid wakeup_source_add(struct wakeup_source *ws)\n{\n\tunsigned long flags;\n\n\tif (WARN_ON(!ws))\n\t\treturn;\n\n\tspin_lock_init(&ws->lock);\n\ttimer_setup(&ws->timer, pm_wakeup_timer_fn, 0);\n\tws->active = false;\n\n\traw_spin_lock_irqsave(&events_lock, flags);\n\tlist_add_rcu(&ws->entry, &wakeup_sources);\n\traw_spin_unlock_irqrestore(&events_lock, flags);\n}\nEXPORT_SYMBOL_GPL(wakeup_source_add);\n\n \nvoid wakeup_source_remove(struct wakeup_source *ws)\n{\n\tunsigned long flags;\n\n\tif (WARN_ON(!ws))\n\t\treturn;\n\n\traw_spin_lock_irqsave(&events_lock, flags);\n\tlist_del_rcu(&ws->entry);\n\traw_spin_unlock_irqrestore(&events_lock, flags);\n\tsynchronize_srcu(&wakeup_srcu);\n\n\tdel_timer_sync(&ws->timer);\n\t \n\tws->timer.function = NULL;\n}\nEXPORT_SYMBOL_GPL(wakeup_source_remove);\n\n \nstruct wakeup_source *wakeup_source_register(struct device *dev,\n\t\t\t\t\t     const char *name)\n{\n\tstruct wakeup_source *ws;\n\tint ret;\n\n\tws = wakeup_source_create(name);\n\tif (ws) {\n\t\tif (!dev || device_is_registered(dev)) {\n\t\t\tret = wakeup_source_sysfs_add(dev, ws);\n\t\t\tif (ret) {\n\t\t\t\twakeup_source_free(ws);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t\twakeup_source_add(ws);\n\t}\n\treturn ws;\n}\nEXPORT_SYMBOL_GPL(wakeup_source_register);\n\n \nvoid wakeup_source_unregister(struct wakeup_source *ws)\n{\n\tif (ws) {\n\t\twakeup_source_remove(ws);\n\t\tif (ws->dev)\n\t\t\twakeup_source_sysfs_remove(ws);\n\n\t\twakeup_source_destroy(ws);\n\t}\n}\nEXPORT_SYMBOL_GPL(wakeup_source_unregister);\n\n \nint wakeup_sources_read_lock(void)\n{\n\treturn srcu_read_lock(&wakeup_srcu);\n}\nEXPORT_SYMBOL_GPL(wakeup_sources_read_lock);\n\n \nvoid wakeup_sources_read_unlock(int idx)\n{\n\tsrcu_read_unlock(&wakeup_srcu, idx);\n}\nEXPORT_SYMBOL_GPL(wakeup_sources_read_unlock);\n\n \nstruct wakeup_source *wakeup_sources_walk_start(void)\n{\n\tstruct list_head *ws_head = &wakeup_sources;\n\n\treturn list_entry_rcu(ws_head->next, struct wakeup_source, entry);\n}\nEXPORT_SYMBOL_GPL(wakeup_sources_walk_start);\n\n \nstruct wakeup_source *wakeup_sources_walk_next(struct wakeup_source *ws)\n{\n\tstruct list_head *ws_head = &wakeup_sources;\n\n\treturn list_next_or_null_rcu(ws_head, &ws->entry,\n\t\t\t\tstruct wakeup_source, entry);\n}\nEXPORT_SYMBOL_GPL(wakeup_sources_walk_next);\n\n \nstatic int device_wakeup_attach(struct device *dev, struct wakeup_source *ws)\n{\n\tspin_lock_irq(&dev->power.lock);\n\tif (dev->power.wakeup) {\n\t\tspin_unlock_irq(&dev->power.lock);\n\t\treturn -EEXIST;\n\t}\n\tdev->power.wakeup = ws;\n\tif (dev->power.wakeirq)\n\t\tdevice_wakeup_attach_irq(dev, dev->power.wakeirq);\n\tspin_unlock_irq(&dev->power.lock);\n\treturn 0;\n}\n\n \nint device_wakeup_enable(struct device *dev)\n{\n\tstruct wakeup_source *ws;\n\tint ret;\n\n\tif (!dev || !dev->power.can_wakeup)\n\t\treturn -EINVAL;\n\n\tif (pm_suspend_target_state != PM_SUSPEND_ON)\n\t\tdev_dbg(dev, \"Suspicious %s() during system transition!\\n\", __func__);\n\n\tws = wakeup_source_register(dev, dev_name(dev));\n\tif (!ws)\n\t\treturn -ENOMEM;\n\n\tret = device_wakeup_attach(dev, ws);\n\tif (ret)\n\t\twakeup_source_unregister(ws);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(device_wakeup_enable);\n\n \nvoid device_wakeup_attach_irq(struct device *dev,\n\t\t\t     struct wake_irq *wakeirq)\n{\n\tstruct wakeup_source *ws;\n\n\tws = dev->power.wakeup;\n\tif (!ws)\n\t\treturn;\n\n\tif (ws->wakeirq)\n\t\tdev_err(dev, \"Leftover wakeup IRQ found, overriding\\n\");\n\n\tws->wakeirq = wakeirq;\n}\n\n \nvoid device_wakeup_detach_irq(struct device *dev)\n{\n\tstruct wakeup_source *ws;\n\n\tws = dev->power.wakeup;\n\tif (ws)\n\t\tws->wakeirq = NULL;\n}\n\n \nvoid device_wakeup_arm_wake_irqs(void)\n{\n\tstruct wakeup_source *ws;\n\tint srcuidx;\n\n\tsrcuidx = srcu_read_lock(&wakeup_srcu);\n\tlist_for_each_entry_rcu_locked(ws, &wakeup_sources, entry)\n\t\tdev_pm_arm_wake_irq(ws->wakeirq);\n\tsrcu_read_unlock(&wakeup_srcu, srcuidx);\n}\n\n \nvoid device_wakeup_disarm_wake_irqs(void)\n{\n\tstruct wakeup_source *ws;\n\tint srcuidx;\n\n\tsrcuidx = srcu_read_lock(&wakeup_srcu);\n\tlist_for_each_entry_rcu_locked(ws, &wakeup_sources, entry)\n\t\tdev_pm_disarm_wake_irq(ws->wakeirq);\n\tsrcu_read_unlock(&wakeup_srcu, srcuidx);\n}\n\n \nstatic struct wakeup_source *device_wakeup_detach(struct device *dev)\n{\n\tstruct wakeup_source *ws;\n\n\tspin_lock_irq(&dev->power.lock);\n\tws = dev->power.wakeup;\n\tdev->power.wakeup = NULL;\n\tspin_unlock_irq(&dev->power.lock);\n\treturn ws;\n}\n\n \nint device_wakeup_disable(struct device *dev)\n{\n\tstruct wakeup_source *ws;\n\n\tif (!dev || !dev->power.can_wakeup)\n\t\treturn -EINVAL;\n\n\tws = device_wakeup_detach(dev);\n\twakeup_source_unregister(ws);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(device_wakeup_disable);\n\n \nvoid device_set_wakeup_capable(struct device *dev, bool capable)\n{\n\tif (!!dev->power.can_wakeup == !!capable)\n\t\treturn;\n\n\tdev->power.can_wakeup = capable;\n\tif (device_is_registered(dev) && !list_empty(&dev->power.entry)) {\n\t\tif (capable) {\n\t\t\tint ret = wakeup_sysfs_add(dev);\n\n\t\t\tif (ret)\n\t\t\t\tdev_info(dev, \"Wakeup sysfs attributes not added\\n\");\n\t\t} else {\n\t\t\twakeup_sysfs_remove(dev);\n\t\t}\n\t}\n}\nEXPORT_SYMBOL_GPL(device_set_wakeup_capable);\n\n \nint device_set_wakeup_enable(struct device *dev, bool enable)\n{\n\treturn enable ? device_wakeup_enable(dev) : device_wakeup_disable(dev);\n}\nEXPORT_SYMBOL_GPL(device_set_wakeup_enable);\n\n \nstatic bool wakeup_source_not_registered(struct wakeup_source *ws)\n{\n\t \n\treturn ws->timer.function != pm_wakeup_timer_fn;\n}\n\n \n\n \nstatic void wakeup_source_activate(struct wakeup_source *ws)\n{\n\tunsigned int cec;\n\n\tif (WARN_ONCE(wakeup_source_not_registered(ws),\n\t\t\t\"unregistered wakeup source\\n\"))\n\t\treturn;\n\n\tws->active = true;\n\tws->active_count++;\n\tws->last_time = ktime_get();\n\tif (ws->autosleep_enabled)\n\t\tws->start_prevent_time = ws->last_time;\n\n\t \n\tcec = atomic_inc_return(&combined_event_count);\n\n\ttrace_wakeup_source_activate(ws->name, cec);\n}\n\n \nstatic void wakeup_source_report_event(struct wakeup_source *ws, bool hard)\n{\n\tws->event_count++;\n\t \n\tif (events_check_enabled)\n\t\tws->wakeup_count++;\n\n\tif (!ws->active)\n\t\twakeup_source_activate(ws);\n\n\tif (hard)\n\t\tpm_system_wakeup();\n}\n\n \nvoid __pm_stay_awake(struct wakeup_source *ws)\n{\n\tunsigned long flags;\n\n\tif (!ws)\n\t\treturn;\n\n\tspin_lock_irqsave(&ws->lock, flags);\n\n\twakeup_source_report_event(ws, false);\n\tdel_timer(&ws->timer);\n\tws->timer_expires = 0;\n\n\tspin_unlock_irqrestore(&ws->lock, flags);\n}\nEXPORT_SYMBOL_GPL(__pm_stay_awake);\n\n \nvoid pm_stay_awake(struct device *dev)\n{\n\tunsigned long flags;\n\n\tif (!dev)\n\t\treturn;\n\n\tspin_lock_irqsave(&dev->power.lock, flags);\n\t__pm_stay_awake(dev->power.wakeup);\n\tspin_unlock_irqrestore(&dev->power.lock, flags);\n}\nEXPORT_SYMBOL_GPL(pm_stay_awake);\n\n#ifdef CONFIG_PM_AUTOSLEEP\nstatic void update_prevent_sleep_time(struct wakeup_source *ws, ktime_t now)\n{\n\tktime_t delta = ktime_sub(now, ws->start_prevent_time);\n\tws->prevent_sleep_time = ktime_add(ws->prevent_sleep_time, delta);\n}\n#else\nstatic inline void update_prevent_sleep_time(struct wakeup_source *ws,\n\t\t\t\t\t     ktime_t now) {}\n#endif\n\n \nstatic void wakeup_source_deactivate(struct wakeup_source *ws)\n{\n\tunsigned int cnt, inpr, cec;\n\tktime_t duration;\n\tktime_t now;\n\n\tws->relax_count++;\n\t \n\tif (ws->relax_count != ws->active_count) {\n\t\tws->relax_count--;\n\t\treturn;\n\t}\n\n\tws->active = false;\n\n\tnow = ktime_get();\n\tduration = ktime_sub(now, ws->last_time);\n\tws->total_time = ktime_add(ws->total_time, duration);\n\tif (ktime_to_ns(duration) > ktime_to_ns(ws->max_time))\n\t\tws->max_time = duration;\n\n\tws->last_time = now;\n\tdel_timer(&ws->timer);\n\tws->timer_expires = 0;\n\n\tif (ws->autosleep_enabled)\n\t\tupdate_prevent_sleep_time(ws, now);\n\n\t \n\tcec = atomic_add_return(MAX_IN_PROGRESS, &combined_event_count);\n\ttrace_wakeup_source_deactivate(ws->name, cec);\n\n\tsplit_counters(&cnt, &inpr);\n\tif (!inpr && waitqueue_active(&wakeup_count_wait_queue))\n\t\twake_up(&wakeup_count_wait_queue);\n}\n\n \nvoid __pm_relax(struct wakeup_source *ws)\n{\n\tunsigned long flags;\n\n\tif (!ws)\n\t\treturn;\n\n\tspin_lock_irqsave(&ws->lock, flags);\n\tif (ws->active)\n\t\twakeup_source_deactivate(ws);\n\tspin_unlock_irqrestore(&ws->lock, flags);\n}\nEXPORT_SYMBOL_GPL(__pm_relax);\n\n \nvoid pm_relax(struct device *dev)\n{\n\tunsigned long flags;\n\n\tif (!dev)\n\t\treturn;\n\n\tspin_lock_irqsave(&dev->power.lock, flags);\n\t__pm_relax(dev->power.wakeup);\n\tspin_unlock_irqrestore(&dev->power.lock, flags);\n}\nEXPORT_SYMBOL_GPL(pm_relax);\n\n \nstatic void pm_wakeup_timer_fn(struct timer_list *t)\n{\n\tstruct wakeup_source *ws = from_timer(ws, t, timer);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ws->lock, flags);\n\n\tif (ws->active && ws->timer_expires\n\t    && time_after_eq(jiffies, ws->timer_expires)) {\n\t\twakeup_source_deactivate(ws);\n\t\tws->expire_count++;\n\t}\n\n\tspin_unlock_irqrestore(&ws->lock, flags);\n}\n\n \nvoid pm_wakeup_ws_event(struct wakeup_source *ws, unsigned int msec, bool hard)\n{\n\tunsigned long flags;\n\tunsigned long expires;\n\n\tif (!ws)\n\t\treturn;\n\n\tspin_lock_irqsave(&ws->lock, flags);\n\n\twakeup_source_report_event(ws, hard);\n\n\tif (!msec) {\n\t\twakeup_source_deactivate(ws);\n\t\tgoto unlock;\n\t}\n\n\texpires = jiffies + msecs_to_jiffies(msec);\n\tif (!expires)\n\t\texpires = 1;\n\n\tif (!ws->timer_expires || time_after(expires, ws->timer_expires)) {\n\t\tmod_timer(&ws->timer, expires);\n\t\tws->timer_expires = expires;\n\t}\n\n unlock:\n\tspin_unlock_irqrestore(&ws->lock, flags);\n}\nEXPORT_SYMBOL_GPL(pm_wakeup_ws_event);\n\n \nvoid pm_wakeup_dev_event(struct device *dev, unsigned int msec, bool hard)\n{\n\tunsigned long flags;\n\n\tif (!dev)\n\t\treturn;\n\n\tspin_lock_irqsave(&dev->power.lock, flags);\n\tpm_wakeup_ws_event(dev->power.wakeup, msec, hard);\n\tspin_unlock_irqrestore(&dev->power.lock, flags);\n}\nEXPORT_SYMBOL_GPL(pm_wakeup_dev_event);\n\nvoid pm_print_active_wakeup_sources(void)\n{\n\tstruct wakeup_source *ws;\n\tint srcuidx, active = 0;\n\tstruct wakeup_source *last_activity_ws = NULL;\n\n\tsrcuidx = srcu_read_lock(&wakeup_srcu);\n\tlist_for_each_entry_rcu_locked(ws, &wakeup_sources, entry) {\n\t\tif (ws->active) {\n\t\t\tpm_pr_dbg(\"active wakeup source: %s\\n\", ws->name);\n\t\t\tactive = 1;\n\t\t} else if (!active &&\n\t\t\t   (!last_activity_ws ||\n\t\t\t    ktime_to_ns(ws->last_time) >\n\t\t\t    ktime_to_ns(last_activity_ws->last_time))) {\n\t\t\tlast_activity_ws = ws;\n\t\t}\n\t}\n\n\tif (!active && last_activity_ws)\n\t\tpm_pr_dbg(\"last active wakeup source: %s\\n\",\n\t\t\tlast_activity_ws->name);\n\tsrcu_read_unlock(&wakeup_srcu, srcuidx);\n}\nEXPORT_SYMBOL_GPL(pm_print_active_wakeup_sources);\n\n \nbool pm_wakeup_pending(void)\n{\n\tunsigned long flags;\n\tbool ret = false;\n\n\traw_spin_lock_irqsave(&events_lock, flags);\n\tif (events_check_enabled) {\n\t\tunsigned int cnt, inpr;\n\n\t\tsplit_counters(&cnt, &inpr);\n\t\tret = (cnt != saved_count || inpr > 0);\n\t\tevents_check_enabled = !ret;\n\t}\n\traw_spin_unlock_irqrestore(&events_lock, flags);\n\n\tif (ret) {\n\t\tpm_pr_dbg(\"Wakeup pending, aborting suspend\\n\");\n\t\tpm_print_active_wakeup_sources();\n\t}\n\n\treturn ret || atomic_read(&pm_abort_suspend) > 0;\n}\nEXPORT_SYMBOL_GPL(pm_wakeup_pending);\n\nvoid pm_system_wakeup(void)\n{\n\tatomic_inc(&pm_abort_suspend);\n\ts2idle_wake();\n}\nEXPORT_SYMBOL_GPL(pm_system_wakeup);\n\nvoid pm_system_cancel_wakeup(void)\n{\n\tatomic_dec_if_positive(&pm_abort_suspend);\n}\n\nvoid pm_wakeup_clear(unsigned int irq_number)\n{\n\traw_spin_lock_irq(&wakeup_irq_lock);\n\n\tif (irq_number && wakeup_irq[0] == irq_number)\n\t\twakeup_irq[0] = wakeup_irq[1];\n\telse\n\t\twakeup_irq[0] = 0;\n\n\twakeup_irq[1] = 0;\n\n\traw_spin_unlock_irq(&wakeup_irq_lock);\n\n\tif (!irq_number)\n\t\tatomic_set(&pm_abort_suspend, 0);\n}\n\nvoid pm_system_irq_wakeup(unsigned int irq_number)\n{\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&wakeup_irq_lock, flags);\n\n\tif (wakeup_irq[0] == 0)\n\t\twakeup_irq[0] = irq_number;\n\telse if (wakeup_irq[1] == 0)\n\t\twakeup_irq[1] = irq_number;\n\telse\n\t\tirq_number = 0;\n\n\tpm_pr_dbg(\"Triggering wakeup from IRQ %d\\n\", irq_number);\n\n\traw_spin_unlock_irqrestore(&wakeup_irq_lock, flags);\n\n\tif (irq_number)\n\t\tpm_system_wakeup();\n}\n\nunsigned int pm_wakeup_irq(void)\n{\n\treturn wakeup_irq[0];\n}\n\n \nbool pm_get_wakeup_count(unsigned int *count, bool block)\n{\n\tunsigned int cnt, inpr;\n\n\tif (block) {\n\t\tDEFINE_WAIT(wait);\n\n\t\tfor (;;) {\n\t\t\tprepare_to_wait(&wakeup_count_wait_queue, &wait,\n\t\t\t\t\tTASK_INTERRUPTIBLE);\n\t\t\tsplit_counters(&cnt, &inpr);\n\t\t\tif (inpr == 0 || signal_pending(current))\n\t\t\t\tbreak;\n\t\t\tpm_print_active_wakeup_sources();\n\t\t\tschedule();\n\t\t}\n\t\tfinish_wait(&wakeup_count_wait_queue, &wait);\n\t}\n\n\tsplit_counters(&cnt, &inpr);\n\t*count = cnt;\n\treturn !inpr;\n}\n\n \nbool pm_save_wakeup_count(unsigned int count)\n{\n\tunsigned int cnt, inpr;\n\tunsigned long flags;\n\n\tevents_check_enabled = false;\n\traw_spin_lock_irqsave(&events_lock, flags);\n\tsplit_counters(&cnt, &inpr);\n\tif (cnt == count && inpr == 0) {\n\t\tsaved_count = count;\n\t\tevents_check_enabled = true;\n\t}\n\traw_spin_unlock_irqrestore(&events_lock, flags);\n\treturn events_check_enabled;\n}\n\n#ifdef CONFIG_PM_AUTOSLEEP\n \nvoid pm_wakep_autosleep_enabled(bool set)\n{\n\tstruct wakeup_source *ws;\n\tktime_t now = ktime_get();\n\tint srcuidx;\n\n\tsrcuidx = srcu_read_lock(&wakeup_srcu);\n\tlist_for_each_entry_rcu_locked(ws, &wakeup_sources, entry) {\n\t\tspin_lock_irq(&ws->lock);\n\t\tif (ws->autosleep_enabled != set) {\n\t\t\tws->autosleep_enabled = set;\n\t\t\tif (ws->active) {\n\t\t\t\tif (set)\n\t\t\t\t\tws->start_prevent_time = now;\n\t\t\t\telse\n\t\t\t\t\tupdate_prevent_sleep_time(ws, now);\n\t\t\t}\n\t\t}\n\t\tspin_unlock_irq(&ws->lock);\n\t}\n\tsrcu_read_unlock(&wakeup_srcu, srcuidx);\n}\n#endif  \n\n \nstatic int print_wakeup_source_stats(struct seq_file *m,\n\t\t\t\t     struct wakeup_source *ws)\n{\n\tunsigned long flags;\n\tktime_t total_time;\n\tktime_t max_time;\n\tunsigned long active_count;\n\tktime_t active_time;\n\tktime_t prevent_sleep_time;\n\n\tspin_lock_irqsave(&ws->lock, flags);\n\n\ttotal_time = ws->total_time;\n\tmax_time = ws->max_time;\n\tprevent_sleep_time = ws->prevent_sleep_time;\n\tactive_count = ws->active_count;\n\tif (ws->active) {\n\t\tktime_t now = ktime_get();\n\n\t\tactive_time = ktime_sub(now, ws->last_time);\n\t\ttotal_time = ktime_add(total_time, active_time);\n\t\tif (active_time > max_time)\n\t\t\tmax_time = active_time;\n\n\t\tif (ws->autosleep_enabled)\n\t\t\tprevent_sleep_time = ktime_add(prevent_sleep_time,\n\t\t\t\tktime_sub(now, ws->start_prevent_time));\n\t} else {\n\t\tactive_time = 0;\n\t}\n\n\tseq_printf(m, \"%-12s\\t%lu\\t\\t%lu\\t\\t%lu\\t\\t%lu\\t\\t%lld\\t\\t%lld\\t\\t%lld\\t\\t%lld\\t\\t%lld\\n\",\n\t\t   ws->name, active_count, ws->event_count,\n\t\t   ws->wakeup_count, ws->expire_count,\n\t\t   ktime_to_ms(active_time), ktime_to_ms(total_time),\n\t\t   ktime_to_ms(max_time), ktime_to_ms(ws->last_time),\n\t\t   ktime_to_ms(prevent_sleep_time));\n\n\tspin_unlock_irqrestore(&ws->lock, flags);\n\n\treturn 0;\n}\n\nstatic void *wakeup_sources_stats_seq_start(struct seq_file *m,\n\t\t\t\t\tloff_t *pos)\n{\n\tstruct wakeup_source *ws;\n\tloff_t n = *pos;\n\tint *srcuidx = m->private;\n\n\tif (n == 0) {\n\t\tseq_puts(m, \"name\\t\\tactive_count\\tevent_count\\twakeup_count\\t\"\n\t\t\t\"expire_count\\tactive_since\\ttotal_time\\tmax_time\\t\"\n\t\t\t\"last_change\\tprevent_suspend_time\\n\");\n\t}\n\n\t*srcuidx = srcu_read_lock(&wakeup_srcu);\n\tlist_for_each_entry_rcu_locked(ws, &wakeup_sources, entry) {\n\t\tif (n-- <= 0)\n\t\t\treturn ws;\n\t}\n\n\treturn NULL;\n}\n\nstatic void *wakeup_sources_stats_seq_next(struct seq_file *m,\n\t\t\t\t\tvoid *v, loff_t *pos)\n{\n\tstruct wakeup_source *ws = v;\n\tstruct wakeup_source *next_ws = NULL;\n\n\t++(*pos);\n\n\tlist_for_each_entry_continue_rcu(ws, &wakeup_sources, entry) {\n\t\tnext_ws = ws;\n\t\tbreak;\n\t}\n\n\tif (!next_ws)\n\t\tprint_wakeup_source_stats(m, &deleted_ws);\n\n\treturn next_ws;\n}\n\nstatic void wakeup_sources_stats_seq_stop(struct seq_file *m, void *v)\n{\n\tint *srcuidx = m->private;\n\n\tsrcu_read_unlock(&wakeup_srcu, *srcuidx);\n}\n\n \nstatic int wakeup_sources_stats_seq_show(struct seq_file *m, void *v)\n{\n\tstruct wakeup_source *ws = v;\n\n\tprint_wakeup_source_stats(m, ws);\n\n\treturn 0;\n}\n\nstatic const struct seq_operations wakeup_sources_stats_seq_ops = {\n\t.start = wakeup_sources_stats_seq_start,\n\t.next  = wakeup_sources_stats_seq_next,\n\t.stop  = wakeup_sources_stats_seq_stop,\n\t.show  = wakeup_sources_stats_seq_show,\n};\n\nstatic int wakeup_sources_stats_open(struct inode *inode, struct file *file)\n{\n\treturn seq_open_private(file, &wakeup_sources_stats_seq_ops, sizeof(int));\n}\n\nstatic const struct file_operations wakeup_sources_stats_fops = {\n\t.owner = THIS_MODULE,\n\t.open = wakeup_sources_stats_open,\n\t.read = seq_read,\n\t.llseek = seq_lseek,\n\t.release = seq_release_private,\n};\n\nstatic int __init wakeup_sources_debugfs_init(void)\n{\n\tdebugfs_create_file(\"wakeup_sources\", 0444, NULL, NULL,\n\t\t\t    &wakeup_sources_stats_fops);\n\treturn 0;\n}\n\npostcore_initcall(wakeup_sources_debugfs_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}