{
  "module_name": "base.h",
  "hash_id": "6adb4f4306af767bb7f6a32c56f38ff708e38335b8b1a87c76bb28e9030c7c67",
  "original_prompt": "Ingested from linux-6.6.14/drivers/base/base.h",
  "human_readable_source": " \n \n#include <linux/notifier.h>\n\n \nstruct subsys_private {\n\tstruct kset subsys;\n\tstruct kset *devices_kset;\n\tstruct list_head interfaces;\n\tstruct mutex mutex;\n\n\tstruct kset *drivers_kset;\n\tstruct klist klist_devices;\n\tstruct klist klist_drivers;\n\tstruct blocking_notifier_head bus_notifier;\n\tunsigned int drivers_autoprobe:1;\n\tconst struct bus_type *bus;\n\tstruct device *dev_root;\n\n\tstruct kset glue_dirs;\n\tconst struct class *class;\n\n\tstruct lock_class_key lock_key;\n};\n#define to_subsys_private(obj) container_of_const(obj, struct subsys_private, subsys.kobj)\n\nstatic inline struct subsys_private *subsys_get(struct subsys_private *sp)\n{\n\tif (sp)\n\t\tkset_get(&sp->subsys);\n\treturn sp;\n}\n\nstatic inline void subsys_put(struct subsys_private *sp)\n{\n\tif (sp)\n\t\tkset_put(&sp->subsys);\n}\n\nstruct subsys_private *class_to_subsys(const struct class *class);\n\nstruct driver_private {\n\tstruct kobject kobj;\n\tstruct klist klist_devices;\n\tstruct klist_node knode_bus;\n\tstruct module_kobject *mkobj;\n\tstruct device_driver *driver;\n};\n#define to_driver(obj) container_of(obj, struct driver_private, kobj)\n\n \nstruct device_private {\n\tstruct klist klist_children;\n\tstruct klist_node knode_parent;\n\tstruct klist_node knode_driver;\n\tstruct klist_node knode_bus;\n\tstruct klist_node knode_class;\n\tstruct list_head deferred_probe;\n\tstruct device_driver *async_driver;\n\tchar *deferred_probe_reason;\n\tstruct device *device;\n\tu8 dead:1;\n};\n#define to_device_private_parent(obj)\t\\\n\tcontainer_of(obj, struct device_private, knode_parent)\n#define to_device_private_driver(obj)\t\\\n\tcontainer_of(obj, struct device_private, knode_driver)\n#define to_device_private_bus(obj)\t\\\n\tcontainer_of(obj, struct device_private, knode_bus)\n#define to_device_private_class(obj)\t\\\n\tcontainer_of(obj, struct device_private, knode_class)\n\n \nint devices_init(void);\nint buses_init(void);\nint classes_init(void);\nint firmware_init(void);\n#ifdef CONFIG_SYS_HYPERVISOR\nint hypervisor_init(void);\n#else\nstatic inline int hypervisor_init(void) { return 0; }\n#endif\nint platform_bus_init(void);\nvoid cpu_dev_init(void);\nvoid container_dev_init(void);\n#ifdef CONFIG_AUXILIARY_BUS\nvoid auxiliary_bus_init(void);\n#else\nstatic inline void auxiliary_bus_init(void) { }\n#endif\n\nstruct kobject *virtual_device_parent(struct device *dev);\n\nint bus_add_device(struct device *dev);\nvoid bus_probe_device(struct device *dev);\nvoid bus_remove_device(struct device *dev);\nvoid bus_notify(struct device *dev, enum bus_notifier_event value);\nbool bus_is_registered(const struct bus_type *bus);\n\nint bus_add_driver(struct device_driver *drv);\nvoid bus_remove_driver(struct device_driver *drv);\nvoid device_release_driver_internal(struct device *dev, struct device_driver *drv,\n\t\t\t\t    struct device *parent);\n\nvoid driver_detach(struct device_driver *drv);\nvoid driver_deferred_probe_del(struct device *dev);\nvoid device_set_deferred_probe_reason(const struct device *dev, struct va_format *vaf);\nstatic inline int driver_match_device(struct device_driver *drv,\n\t\t\t\t      struct device *dev)\n{\n\treturn drv->bus->match ? drv->bus->match(dev, drv) : 1;\n}\n\nstatic inline void dev_sync_state(struct device *dev)\n{\n\tif (dev->bus->sync_state)\n\t\tdev->bus->sync_state(dev);\n\telse if (dev->driver && dev->driver->sync_state)\n\t\tdev->driver->sync_state(dev);\n}\n\nint driver_add_groups(struct device_driver *drv, const struct attribute_group **groups);\nvoid driver_remove_groups(struct device_driver *drv, const struct attribute_group **groups);\nvoid device_driver_detach(struct device *dev);\n\nint devres_release_all(struct device *dev);\nvoid device_block_probing(void);\nvoid device_unblock_probing(void);\nvoid deferred_probe_extend_timeout(void);\nvoid driver_deferred_probe_trigger(void);\nconst char *device_get_devnode(const struct device *dev, umode_t *mode,\n\t\t\t       kuid_t *uid, kgid_t *gid, const char **tmp);\n\n \nextern struct kset *devices_kset;\nvoid devices_kset_move_last(struct device *dev);\n\n#if defined(CONFIG_MODULES) && defined(CONFIG_SYSFS)\nvoid module_add_driver(struct module *mod, struct device_driver *drv);\nvoid module_remove_driver(struct device_driver *drv);\n#else\nstatic inline void module_add_driver(struct module *mod,\n\t\t\t\t     struct device_driver *drv) { }\nstatic inline void module_remove_driver(struct device_driver *drv) { }\n#endif\n\n#ifdef CONFIG_DEVTMPFS\nint devtmpfs_init(void);\n#else\nstatic inline int devtmpfs_init(void) { return 0; }\n#endif\n\n#ifdef CONFIG_BLOCK\nextern struct class block_class;\nstatic inline bool is_blockdev(struct device *dev)\n{\n\treturn dev->class == &block_class;\n}\n#else\nstatic inline bool is_blockdev(struct device *dev) { return false; }\n#endif\n\n \nint device_links_read_lock(void);\nvoid device_links_read_unlock(int idx);\nint device_links_read_lock_held(void);\nint device_links_check_suppliers(struct device *dev);\nvoid device_links_force_bind(struct device *dev);\nvoid device_links_driver_bound(struct device *dev);\nvoid device_links_driver_cleanup(struct device *dev);\nvoid device_links_no_driver(struct device *dev);\nbool device_links_busy(struct device *dev);\nvoid device_links_unbind_consumers(struct device *dev);\nvoid fw_devlink_drivers_done(void);\nvoid fw_devlink_probing_done(void);\n\n \nvoid device_pm_move_to_tail(struct device *dev);\n\n#ifdef CONFIG_DEVTMPFS\nint devtmpfs_create_node(struct device *dev);\nint devtmpfs_delete_node(struct device *dev);\n#else\nstatic inline int devtmpfs_create_node(struct device *dev) { return 0; }\nstatic inline int devtmpfs_delete_node(struct device *dev) { return 0; }\n#endif\n\nvoid software_node_notify(struct device *dev);\nvoid software_node_notify_remove(struct device *dev);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}