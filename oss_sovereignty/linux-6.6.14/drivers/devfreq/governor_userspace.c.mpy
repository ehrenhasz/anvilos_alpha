{
  "module_name": "governor_userspace.c",
  "hash_id": "f5f021b26308fe44af3bef8cc611bb307e4aefbc02de577320263929910d2845",
  "original_prompt": "Ingested from linux-6.6.14/drivers/devfreq/governor_userspace.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <linux/device.h>\n#include <linux/devfreq.h>\n#include <linux/pm.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include \"governor.h\"\n\nstruct userspace_data {\n\tunsigned long user_frequency;\n\tbool valid;\n};\n\nstatic int devfreq_userspace_func(struct devfreq *df, unsigned long *freq)\n{\n\tstruct userspace_data *data = df->governor_data;\n\n\tif (data->valid)\n\t\t*freq = data->user_frequency;\n\telse\n\t\t*freq = df->previous_freq;  \n\n\treturn 0;\n}\n\nstatic ssize_t set_freq_store(struct device *dev, struct device_attribute *attr,\n\t\t\t      const char *buf, size_t count)\n{\n\tstruct devfreq *devfreq = to_devfreq(dev);\n\tstruct userspace_data *data;\n\tunsigned long wanted;\n\tint err = 0;\n\n\tmutex_lock(&devfreq->lock);\n\tdata = devfreq->governor_data;\n\n\tsscanf(buf, \"%lu\", &wanted);\n\tdata->user_frequency = wanted;\n\tdata->valid = true;\n\terr = update_devfreq(devfreq);\n\tif (err == 0)\n\t\terr = count;\n\tmutex_unlock(&devfreq->lock);\n\treturn err;\n}\n\nstatic ssize_t set_freq_show(struct device *dev,\n\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tstruct devfreq *devfreq = to_devfreq(dev);\n\tstruct userspace_data *data;\n\tint err = 0;\n\n\tmutex_lock(&devfreq->lock);\n\tdata = devfreq->governor_data;\n\n\tif (data->valid)\n\t\terr = sprintf(buf, \"%lu\\n\", data->user_frequency);\n\telse\n\t\terr = sprintf(buf, \"undefined\\n\");\n\tmutex_unlock(&devfreq->lock);\n\treturn err;\n}\n\nstatic DEVICE_ATTR_RW(set_freq);\nstatic struct attribute *dev_entries[] = {\n\t&dev_attr_set_freq.attr,\n\tNULL,\n};\nstatic const struct attribute_group dev_attr_group = {\n\t.name\t= DEVFREQ_GOV_USERSPACE,\n\t.attrs\t= dev_entries,\n};\n\nstatic int userspace_init(struct devfreq *devfreq)\n{\n\tint err = 0;\n\tstruct userspace_data *data = kzalloc(sizeof(struct userspace_data),\n\t\t\t\t\t      GFP_KERNEL);\n\n\tif (!data) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\tdata->valid = false;\n\tdevfreq->governor_data = data;\n\n\terr = sysfs_create_group(&devfreq->dev.kobj, &dev_attr_group);\nout:\n\treturn err;\n}\n\nstatic void userspace_exit(struct devfreq *devfreq)\n{\n\t \n\tif (devfreq->dev.kobj.sd)\n\t\tsysfs_remove_group(&devfreq->dev.kobj, &dev_attr_group);\n\n\tkfree(devfreq->governor_data);\n\tdevfreq->governor_data = NULL;\n}\n\nstatic int devfreq_userspace_handler(struct devfreq *devfreq,\n\t\t\tunsigned int event, void *data)\n{\n\tint ret = 0;\n\n\tswitch (event) {\n\tcase DEVFREQ_GOV_START:\n\t\tret = userspace_init(devfreq);\n\t\tbreak;\n\tcase DEVFREQ_GOV_STOP:\n\t\tuserspace_exit(devfreq);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic struct devfreq_governor devfreq_userspace = {\n\t.name = DEVFREQ_GOV_USERSPACE,\n\t.get_target_freq = devfreq_userspace_func,\n\t.event_handler = devfreq_userspace_handler,\n};\n\nstatic int __init devfreq_userspace_init(void)\n{\n\treturn devfreq_add_governor(&devfreq_userspace);\n}\nsubsys_initcall(devfreq_userspace_init);\n\nstatic void __exit devfreq_userspace_exit(void)\n{\n\tint ret;\n\n\tret = devfreq_remove_governor(&devfreq_userspace);\n\tif (ret)\n\t\tpr_err(\"%s: failed remove governor %d\\n\", __func__, ret);\n\n\treturn;\n}\nmodule_exit(devfreq_userspace_exit);\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}