{
  "module_name": "mtk-cci-devfreq.c",
  "hash_id": "3247cc8833d778173d1a1d04c725a148a8b474cbf53d759dff138940b3aa8865",
  "original_prompt": "Ingested from linux-6.6.14/drivers/devfreq/mtk-cci-devfreq.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/devfreq.h>\n#include <linux/minmax.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm_opp.h>\n#include <linux/regulator/consumer.h>\n\nstruct mtk_ccifreq_platform_data {\n\tint min_volt_shift;\n\tint max_volt_shift;\n\tint proc_max_volt;\n\tint sram_min_volt;\n\tint sram_max_volt;\n};\n\nstruct mtk_ccifreq_drv {\n\tstruct device *dev;\n\tstruct devfreq *devfreq;\n\tstruct regulator *proc_reg;\n\tstruct regulator *sram_reg;\n\tstruct clk *cci_clk;\n\tstruct clk *inter_clk;\n\tint inter_voltage;\n\tunsigned long pre_freq;\n\t \n\tstruct mutex reg_lock;\n\tstruct notifier_block opp_nb;\n\tconst struct mtk_ccifreq_platform_data *soc_data;\n\tint vtrack_max;\n};\n\nstatic int mtk_ccifreq_set_voltage(struct mtk_ccifreq_drv *drv, int new_voltage)\n{\n\tconst struct mtk_ccifreq_platform_data *soc_data = drv->soc_data;\n\tstruct device *dev = drv->dev;\n\tint pre_voltage, pre_vsram, new_vsram, vsram, voltage, ret;\n\tint retry_max = drv->vtrack_max;\n\n\tif (!drv->sram_reg) {\n\t\tret = regulator_set_voltage(drv->proc_reg, new_voltage,\n\t\t\t\t\t    drv->soc_data->proc_max_volt);\n\t\treturn ret;\n\t}\n\n\tpre_voltage = regulator_get_voltage(drv->proc_reg);\n\tif (pre_voltage < 0) {\n\t\tdev_err(dev, \"invalid vproc value: %d\\n\", pre_voltage);\n\t\treturn pre_voltage;\n\t}\n\n\tpre_vsram = regulator_get_voltage(drv->sram_reg);\n\tif (pre_vsram < 0) {\n\t\tdev_err(dev, \"invalid vsram value: %d\\n\", pre_vsram);\n\t\treturn pre_vsram;\n\t}\n\n\tnew_vsram = clamp(new_voltage + soc_data->min_volt_shift,\n\t\t\t  soc_data->sram_min_volt, soc_data->sram_max_volt);\n\n\tdo {\n\t\tif (pre_voltage <= new_voltage) {\n\t\t\tvsram = clamp(pre_voltage + soc_data->max_volt_shift,\n\t\t\t\t      soc_data->sram_min_volt, new_vsram);\n\t\t\tret = regulator_set_voltage(drv->sram_reg, vsram,\n\t\t\t\t\t\t    soc_data->sram_max_volt);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\tif (vsram == soc_data->sram_max_volt ||\n\t\t\t    new_vsram == soc_data->sram_min_volt)\n\t\t\t\tvoltage = new_voltage;\n\t\t\telse\n\t\t\t\tvoltage = vsram - soc_data->min_volt_shift;\n\n\t\t\tret = regulator_set_voltage(drv->proc_reg, voltage,\n\t\t\t\t\t\t    soc_data->proc_max_volt);\n\t\t\tif (ret) {\n\t\t\t\tregulator_set_voltage(drv->sram_reg, pre_vsram,\n\t\t\t\t\t\t      soc_data->sram_max_volt);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t} else if (pre_voltage > new_voltage) {\n\t\t\tvoltage = max(new_voltage,\n\t\t\t\t      pre_vsram - soc_data->max_volt_shift);\n\t\t\tret = regulator_set_voltage(drv->proc_reg, voltage,\n\t\t\t\t\t\t    soc_data->proc_max_volt);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\tif (voltage == new_voltage)\n\t\t\t\tvsram = new_vsram;\n\t\t\telse\n\t\t\t\tvsram = max(new_vsram,\n\t\t\t\t\t    voltage + soc_data->min_volt_shift);\n\n\t\t\tret = regulator_set_voltage(drv->sram_reg, vsram,\n\t\t\t\t\t\t    soc_data->sram_max_volt);\n\t\t\tif (ret) {\n\t\t\t\tregulator_set_voltage(drv->proc_reg, pre_voltage,\n\t\t\t\t\t\t      soc_data->proc_max_volt);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\n\t\tpre_voltage = voltage;\n\t\tpre_vsram = vsram;\n\n\t\tif (--retry_max < 0) {\n\t\t\tdev_err(dev,\n\t\t\t\t\"over loop count, failed to set voltage\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t} while (voltage != new_voltage || vsram != new_vsram);\n\n\treturn 0;\n}\n\nstatic int mtk_ccifreq_target(struct device *dev, unsigned long *freq,\n\t\t\t      u32 flags)\n{\n\tstruct mtk_ccifreq_drv *drv = dev_get_drvdata(dev);\n\tstruct clk *cci_pll;\n\tstruct dev_pm_opp *opp;\n\tunsigned long opp_rate;\n\tint voltage, pre_voltage, inter_voltage, target_voltage, ret;\n\n\tif (!drv)\n\t\treturn -EINVAL;\n\n\tif (drv->pre_freq == *freq)\n\t\treturn 0;\n\n\tinter_voltage = drv->inter_voltage;\n\tcci_pll = clk_get_parent(drv->cci_clk);\n\n\topp_rate = *freq;\n\topp = devfreq_recommended_opp(dev, &opp_rate, 1);\n\tif (IS_ERR(opp)) {\n\t\tdev_err(dev, \"failed to find opp for freq: %ld\\n\", opp_rate);\n\t\treturn PTR_ERR(opp);\n\t}\n\n\tmutex_lock(&drv->reg_lock);\n\n\tvoltage = dev_pm_opp_get_voltage(opp);\n\tdev_pm_opp_put(opp);\n\n\tpre_voltage = regulator_get_voltage(drv->proc_reg);\n\tif (pre_voltage < 0) {\n\t\tdev_err(dev, \"invalid vproc value: %d\\n\", pre_voltage);\n\t\tret = pre_voltage;\n\t\tgoto out_unlock;\n\t}\n\n\t \n\ttarget_voltage = max(inter_voltage, voltage);\n\tif (pre_voltage <= target_voltage) {\n\t\tret = mtk_ccifreq_set_voltage(drv, target_voltage);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"failed to scale up voltage\\n\");\n\t\t\tgoto out_restore_voltage;\n\t\t}\n\t}\n\n\t \n\tret = clk_set_parent(drv->cci_clk, drv->inter_clk);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to re-parent cci clock\\n\");\n\t\tgoto out_restore_voltage;\n\t}\n\n\t \n\tret = clk_set_rate(cci_pll, *freq);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to set cci pll rate: %d\\n\", ret);\n\t\tclk_set_parent(drv->cci_clk, cci_pll);\n\t\tgoto out_restore_voltage;\n\t}\n\n\t \n\tret = clk_set_parent(drv->cci_clk, cci_pll);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to re-parent cci clock\\n\");\n\t\tmtk_ccifreq_set_voltage(drv, inter_voltage);\n\t\tgoto out_unlock;\n\t}\n\n\t \n\tif (voltage < inter_voltage || voltage < pre_voltage) {\n\t\tret = mtk_ccifreq_set_voltage(drv, voltage);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"failed to scale down voltage\\n\");\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\tdrv->pre_freq = *freq;\n\tmutex_unlock(&drv->reg_lock);\n\n\treturn 0;\n\nout_restore_voltage:\n\tmtk_ccifreq_set_voltage(drv, pre_voltage);\n\nout_unlock:\n\tmutex_unlock(&drv->reg_lock);\n\treturn ret;\n}\n\nstatic int mtk_ccifreq_opp_notifier(struct notifier_block *nb,\n\t\t\t\t    unsigned long event, void *data)\n{\n\tstruct dev_pm_opp *opp = data;\n\tstruct mtk_ccifreq_drv *drv;\n\tunsigned long freq, volt;\n\n\tdrv = container_of(nb, struct mtk_ccifreq_drv, opp_nb);\n\n\tif (event == OPP_EVENT_ADJUST_VOLTAGE) {\n\t\tfreq = dev_pm_opp_get_freq(opp);\n\n\t\tmutex_lock(&drv->reg_lock);\n\t\t \n\t\tif (freq == drv->pre_freq) {\n\t\t\tvolt = dev_pm_opp_get_voltage(opp);\n\t\t\tmtk_ccifreq_set_voltage(drv, volt);\n\t\t}\n\t\tmutex_unlock(&drv->reg_lock);\n\t}\n\n\treturn 0;\n}\n\nstatic struct devfreq_dev_profile mtk_ccifreq_profile = {\n\t.target = mtk_ccifreq_target,\n};\n\nstatic int mtk_ccifreq_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct mtk_ccifreq_drv *drv;\n\tstruct devfreq_passive_data *passive_data;\n\tstruct dev_pm_opp *opp;\n\tunsigned long rate, opp_volt;\n\tint ret;\n\n\tdrv = devm_kzalloc(dev, sizeof(*drv), GFP_KERNEL);\n\tif (!drv)\n\t\treturn -ENOMEM;\n\n\tdrv->dev = dev;\n\tdrv->soc_data = (const struct mtk_ccifreq_platform_data *)\n\t\t\t\tof_device_get_match_data(&pdev->dev);\n\tmutex_init(&drv->reg_lock);\n\tplatform_set_drvdata(pdev, drv);\n\n\tdrv->cci_clk = devm_clk_get(dev, \"cci\");\n\tif (IS_ERR(drv->cci_clk)) {\n\t\tret = PTR_ERR(drv->cci_clk);\n\t\treturn dev_err_probe(dev, ret, \"failed to get cci clk\\n\");\n\t}\n\n\tdrv->inter_clk = devm_clk_get(dev, \"intermediate\");\n\tif (IS_ERR(drv->inter_clk)) {\n\t\tret = PTR_ERR(drv->inter_clk);\n\t\treturn dev_err_probe(dev, ret,\n\t\t\t\t     \"failed to get intermediate clk\\n\");\n\t}\n\n\tdrv->proc_reg = devm_regulator_get_optional(dev, \"proc\");\n\tif (IS_ERR(drv->proc_reg)) {\n\t\tret = PTR_ERR(drv->proc_reg);\n\t\treturn dev_err_probe(dev, ret,\n\t\t\t\t     \"failed to get proc regulator\\n\");\n\t}\n\n\tret = regulator_enable(drv->proc_reg);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to enable proc regulator\\n\");\n\t\treturn ret;\n\t}\n\n\tdrv->sram_reg = devm_regulator_get_optional(dev, \"sram\");\n\tif (IS_ERR(drv->sram_reg)) {\n\t\tret = PTR_ERR(drv->sram_reg);\n\t\tif (ret == -EPROBE_DEFER)\n\t\t\tgoto out_free_resources;\n\n\t\tdrv->sram_reg = NULL;\n\t} else {\n\t\tret = regulator_enable(drv->sram_reg);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"failed to enable sram regulator\\n\");\n\t\t\tgoto out_free_resources;\n\t\t}\n\t}\n\n\t \n\tdrv->vtrack_max = 3 * DIV_ROUND_UP(max(drv->soc_data->sram_max_volt,\n\t\t\t\t\t       drv->soc_data->proc_max_volt),\n\t\t\t\t\t   drv->soc_data->min_volt_shift);\n\n\tret = clk_prepare_enable(drv->cci_clk);\n\tif (ret)\n\t\tgoto out_free_resources;\n\n\tret = dev_pm_opp_of_add_table(dev);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to add opp table: %d\\n\", ret);\n\t\tgoto out_disable_cci_clk;\n\t}\n\n\trate = clk_get_rate(drv->inter_clk);\n\topp = dev_pm_opp_find_freq_ceil(dev, &rate);\n\tif (IS_ERR(opp)) {\n\t\tret = PTR_ERR(opp);\n\t\tdev_err(dev, \"failed to get intermediate opp: %d\\n\", ret);\n\t\tgoto out_remove_opp_table;\n\t}\n\tdrv->inter_voltage = dev_pm_opp_get_voltage(opp);\n\tdev_pm_opp_put(opp);\n\n\trate = U32_MAX;\n\topp = dev_pm_opp_find_freq_floor(drv->dev, &rate);\n\tif (IS_ERR(opp)) {\n\t\tdev_err(dev, \"failed to get opp\\n\");\n\t\tret = PTR_ERR(opp);\n\t\tgoto out_remove_opp_table;\n\t}\n\n\topp_volt = dev_pm_opp_get_voltage(opp);\n\tdev_pm_opp_put(opp);\n\tret = mtk_ccifreq_set_voltage(drv, opp_volt);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to scale to highest voltage %lu in proc_reg\\n\",\n\t\t\topp_volt);\n\t\tgoto out_remove_opp_table;\n\t}\n\n\tpassive_data = devm_kzalloc(dev, sizeof(*passive_data), GFP_KERNEL);\n\tif (!passive_data) {\n\t\tret = -ENOMEM;\n\t\tgoto out_remove_opp_table;\n\t}\n\n\tpassive_data->parent_type = CPUFREQ_PARENT_DEV;\n\tdrv->devfreq = devm_devfreq_add_device(dev, &mtk_ccifreq_profile,\n\t\t\t\t\t       DEVFREQ_GOV_PASSIVE,\n\t\t\t\t\t       passive_data);\n\tif (IS_ERR(drv->devfreq)) {\n\t\tret = -EPROBE_DEFER;\n\t\tdev_err(dev, \"failed to add devfreq device: %ld\\n\",\n\t\t\tPTR_ERR(drv->devfreq));\n\t\tgoto out_remove_opp_table;\n\t}\n\n\tdrv->opp_nb.notifier_call = mtk_ccifreq_opp_notifier;\n\tret = dev_pm_opp_register_notifier(dev, &drv->opp_nb);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to register opp notifier: %d\\n\", ret);\n\t\tgoto out_remove_opp_table;\n\t}\n\treturn 0;\n\nout_remove_opp_table:\n\tdev_pm_opp_of_remove_table(dev);\n\nout_disable_cci_clk:\n\tclk_disable_unprepare(drv->cci_clk);\n\nout_free_resources:\n\tif (regulator_is_enabled(drv->proc_reg))\n\t\tregulator_disable(drv->proc_reg);\n\tif (drv->sram_reg && regulator_is_enabled(drv->sram_reg))\n\t\tregulator_disable(drv->sram_reg);\n\n\treturn ret;\n}\n\nstatic int mtk_ccifreq_remove(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct mtk_ccifreq_drv *drv;\n\n\tdrv = platform_get_drvdata(pdev);\n\n\tdev_pm_opp_unregister_notifier(dev, &drv->opp_nb);\n\tdev_pm_opp_of_remove_table(dev);\n\tclk_disable_unprepare(drv->cci_clk);\n\tregulator_disable(drv->proc_reg);\n\tif (drv->sram_reg)\n\t\tregulator_disable(drv->sram_reg);\n\n\treturn 0;\n}\n\nstatic const struct mtk_ccifreq_platform_data mt8183_platform_data = {\n\t.min_volt_shift = 100000,\n\t.max_volt_shift = 200000,\n\t.proc_max_volt = 1150000,\n};\n\nstatic const struct mtk_ccifreq_platform_data mt8186_platform_data = {\n\t.min_volt_shift = 100000,\n\t.max_volt_shift = 250000,\n\t.proc_max_volt = 1118750,\n\t.sram_min_volt = 850000,\n\t.sram_max_volt = 1118750,\n};\n\nstatic const struct of_device_id mtk_ccifreq_machines[] = {\n\t{ .compatible = \"mediatek,mt8183-cci\", .data = &mt8183_platform_data },\n\t{ .compatible = \"mediatek,mt8186-cci\", .data = &mt8186_platform_data },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, mtk_ccifreq_machines);\n\nstatic struct platform_driver mtk_ccifreq_platdrv = {\n\t.probe\t= mtk_ccifreq_probe,\n\t.remove\t= mtk_ccifreq_remove,\n\t.driver = {\n\t\t.name = \"mtk-ccifreq\",\n\t\t.of_match_table = mtk_ccifreq_machines,\n\t},\n};\nmodule_platform_driver(mtk_ccifreq_platdrv);\n\nMODULE_DESCRIPTION(\"MediaTek CCI devfreq driver\");\nMODULE_AUTHOR(\"Jia-Wei Chang <jia-wei.chang@mediatek.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}