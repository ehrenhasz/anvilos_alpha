{
  "module_name": "imx8m-ddrc.c",
  "hash_id": "6ed65c3f395b171d4dd13887b8e6f7743a7f56ede6453cd20da4dd1862ae262c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/devfreq/imx8m-ddrc.c",
  "human_readable_source": "\n \n\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/device.h>\n#include <linux/platform_device.h>\n#include <linux/devfreq.h>\n#include <linux/pm_opp.h>\n#include <linux/clk.h>\n#include <linux/clk-provider.h>\n#include <linux/arm-smccc.h>\n\n#define IMX_SIP_DDR_DVFS\t\t\t0xc2000004\n\n \n#define IMX_SIP_DDR_DVFS_GET_FREQ_COUNT\t\t0x10\n#define IMX_SIP_DDR_DVFS_GET_FREQ_INFO\t\t0x11\n\n \nstruct imx8m_ddrc_freq {\n\tunsigned long rate;\n\tunsigned long smcarg;\n\tint dram_core_parent_index;\n\tint dram_alt_parent_index;\n\tint dram_apb_parent_index;\n};\n\n \n#define IMX8M_DDRC_MAX_FREQ_COUNT 4\n\n \nstruct imx8m_ddrc {\n\tstruct devfreq_dev_profile profile;\n\tstruct devfreq *devfreq;\n\n\t \n\tstruct clk *dram_core;\n\tstruct clk *dram_pll;\n\tstruct clk *dram_alt;\n\tstruct clk *dram_apb;\n\n\tint freq_count;\n\tstruct imx8m_ddrc_freq freq_table[IMX8M_DDRC_MAX_FREQ_COUNT];\n};\n\nstatic struct imx8m_ddrc_freq *imx8m_ddrc_find_freq(struct imx8m_ddrc *priv,\n\t\t\t\t\t\t    unsigned long rate)\n{\n\tstruct imx8m_ddrc_freq *freq;\n\tint i;\n\n\t \n\trate = DIV_ROUND_CLOSEST(rate, 250000);\n\tfor (i = 0; i < priv->freq_count; ++i) {\n\t\tfreq = &priv->freq_table[i];\n\t\tif (freq->rate == rate ||\n\t\t\t\tfreq->rate + 1 == rate ||\n\t\t\t\tfreq->rate - 1 == rate)\n\t\t\treturn freq;\n\t}\n\n\treturn NULL;\n}\n\nstatic void imx8m_ddrc_smc_set_freq(int target_freq)\n{\n\tstruct arm_smccc_res res;\n\tu32 online_cpus = 0;\n\tint cpu;\n\n\tlocal_irq_disable();\n\n\tfor_each_online_cpu(cpu)\n\t\tonline_cpus |= (1 << (cpu * 8));\n\n\t \n\tarm_smccc_smc(IMX_SIP_DDR_DVFS, target_freq, online_cpus,\n\t\t\t0, 0, 0, 0, 0, &res);\n\n\tlocal_irq_enable();\n}\n\nstatic struct clk *clk_get_parent_by_index(struct clk *clk, int index)\n{\n\tstruct clk_hw *hw;\n\n\thw = clk_hw_get_parent_by_index(__clk_get_hw(clk), index);\n\n\treturn hw ? hw->clk : NULL;\n}\n\nstatic int imx8m_ddrc_set_freq(struct device *dev, struct imx8m_ddrc_freq *freq)\n{\n\tstruct imx8m_ddrc *priv = dev_get_drvdata(dev);\n\tstruct clk *new_dram_core_parent;\n\tstruct clk *new_dram_alt_parent;\n\tstruct clk *new_dram_apb_parent;\n\tint ret;\n\n\t \n\tnew_dram_core_parent = clk_get_parent_by_index(\n\t\t\tpriv->dram_core, freq->dram_core_parent_index - 1);\n\tif (!new_dram_core_parent) {\n\t\tdev_err(dev, \"failed to fetch new dram_core parent\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (freq->dram_alt_parent_index) {\n\t\tnew_dram_alt_parent = clk_get_parent_by_index(\n\t\t\t\tpriv->dram_alt,\n\t\t\t\tfreq->dram_alt_parent_index - 1);\n\t\tif (!new_dram_alt_parent) {\n\t\t\tdev_err(dev, \"failed to fetch new dram_alt parent\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else\n\t\tnew_dram_alt_parent = NULL;\n\n\tif (freq->dram_apb_parent_index) {\n\t\tnew_dram_apb_parent = clk_get_parent_by_index(\n\t\t\t\tpriv->dram_apb,\n\t\t\t\tfreq->dram_apb_parent_index - 1);\n\t\tif (!new_dram_apb_parent) {\n\t\t\tdev_err(dev, \"failed to fetch new dram_apb parent\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else\n\t\tnew_dram_apb_parent = NULL;\n\n\t \n\tret = clk_prepare_enable(new_dram_core_parent);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to enable new dram_core parent: %d\\n\",\n\t\t\tret);\n\t\tgoto out;\n\t}\n\tret = clk_prepare_enable(new_dram_alt_parent);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to enable new dram_alt parent: %d\\n\",\n\t\t\tret);\n\t\tgoto out_disable_core_parent;\n\t}\n\tret = clk_prepare_enable(new_dram_apb_parent);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to enable new dram_apb parent: %d\\n\",\n\t\t\tret);\n\t\tgoto out_disable_alt_parent;\n\t}\n\n\timx8m_ddrc_smc_set_freq(freq->smcarg);\n\n\t \n\tret = clk_set_parent(priv->dram_core, new_dram_core_parent);\n\tif (ret)\n\t\tdev_warn(dev, \"failed to set dram_core parent: %d\\n\", ret);\n\tif (new_dram_alt_parent) {\n\t\tret = clk_set_parent(priv->dram_alt, new_dram_alt_parent);\n\t\tif (ret)\n\t\t\tdev_warn(dev, \"failed to set dram_alt parent: %d\\n\",\n\t\t\t\t ret);\n\t}\n\tif (new_dram_apb_parent) {\n\t\tret = clk_set_parent(priv->dram_apb, new_dram_apb_parent);\n\t\tif (ret)\n\t\t\tdev_warn(dev, \"failed to set dram_apb parent: %d\\n\",\n\t\t\t\t ret);\n\t}\n\n\t \n\tclk_get_rate(priv->dram_pll);\n\n\t \n\tclk_disable_unprepare(new_dram_apb_parent);\nout_disable_alt_parent:\n\tclk_disable_unprepare(new_dram_alt_parent);\nout_disable_core_parent:\n\tclk_disable_unprepare(new_dram_core_parent);\nout:\n\treturn ret;\n}\n\nstatic int imx8m_ddrc_target(struct device *dev, unsigned long *freq, u32 flags)\n{\n\tstruct imx8m_ddrc *priv = dev_get_drvdata(dev);\n\tstruct imx8m_ddrc_freq *freq_info;\n\tstruct dev_pm_opp *new_opp;\n\tunsigned long old_freq, new_freq;\n\tint ret;\n\n\tnew_opp = devfreq_recommended_opp(dev, freq, flags);\n\tif (IS_ERR(new_opp)) {\n\t\tret = PTR_ERR(new_opp);\n\t\tdev_err(dev, \"failed to get recommended opp: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\tdev_pm_opp_put(new_opp);\n\n\told_freq = clk_get_rate(priv->dram_core);\n\tif (*freq == old_freq)\n\t\treturn 0;\n\n\tfreq_info = imx8m_ddrc_find_freq(priv, *freq);\n\tif (!freq_info)\n\t\treturn -EINVAL;\n\n\t \n\tret = imx8m_ddrc_set_freq(dev, freq_info);\n\n\tnew_freq = clk_get_rate(priv->dram_core);\n\tif (ret)\n\t\tdev_err(dev, \"ddrc failed freq switch to %lu from %lu: error %d. now at %lu\\n\",\n\t\t\t*freq, old_freq, ret, new_freq);\n\telse if (*freq != new_freq)\n\t\tdev_err(dev, \"ddrc failed freq update to %lu from %lu, now at %lu\\n\",\n\t\t\t*freq, old_freq, new_freq);\n\telse\n\t\tdev_dbg(dev, \"ddrc freq set to %lu (was %lu)\\n\",\n\t\t\t*freq, old_freq);\n\n\treturn ret;\n}\n\nstatic int imx8m_ddrc_get_cur_freq(struct device *dev, unsigned long *freq)\n{\n\tstruct imx8m_ddrc *priv = dev_get_drvdata(dev);\n\n\t*freq = clk_get_rate(priv->dram_core);\n\n\treturn 0;\n}\n\nstatic int imx8m_ddrc_init_freq_info(struct device *dev)\n{\n\tstruct imx8m_ddrc *priv = dev_get_drvdata(dev);\n\tstruct arm_smccc_res res;\n\tint index;\n\n\t \n\tarm_smccc_smc(IMX_SIP_DDR_DVFS, IMX_SIP_DDR_DVFS_GET_FREQ_COUNT,\n\t\t\t0, 0, 0, 0, 0, 0, &res);\n\tpriv->freq_count = res.a0;\n\tif (priv->freq_count <= 0 ||\n\t\t\tpriv->freq_count > IMX8M_DDRC_MAX_FREQ_COUNT)\n\t\treturn -ENODEV;\n\n\tfor (index = 0; index < priv->freq_count; ++index) {\n\t\tstruct imx8m_ddrc_freq *freq = &priv->freq_table[index];\n\n\t\tarm_smccc_smc(IMX_SIP_DDR_DVFS, IMX_SIP_DDR_DVFS_GET_FREQ_INFO,\n\t\t\t      index, 0, 0, 0, 0, 0, &res);\n\t\t \n\t\tif ((long)res.a0 <= 0)\n\t\t\treturn -ENODEV;\n\n\t\tfreq->rate = res.a0;\n\t\tfreq->smcarg = index;\n\t\tfreq->dram_core_parent_index = res.a1;\n\t\tfreq->dram_alt_parent_index = res.a2;\n\t\tfreq->dram_apb_parent_index = res.a3;\n\n\t\t \n\t\tif (freq->dram_core_parent_index != 1 &&\n\t\t\t\tfreq->dram_core_parent_index != 2)\n\t\t\treturn -ENODEV;\n\t\t \n\t\tif (freq->dram_alt_parent_index > 8 ||\n\t\t\t\tfreq->dram_apb_parent_index > 8)\n\t\t\treturn -ENODEV;\n\t\t \n\t\tif (freq->dram_core_parent_index == 2 &&\n\t\t\t\tfreq->dram_alt_parent_index == 0)\n\t\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\nstatic int imx8m_ddrc_check_opps(struct device *dev)\n{\n\tstruct imx8m_ddrc *priv = dev_get_drvdata(dev);\n\tstruct imx8m_ddrc_freq *freq_info;\n\tstruct dev_pm_opp *opp;\n\tunsigned long freq;\n\tint i, opp_count;\n\n\t \n\topp_count = dev_pm_opp_get_opp_count(dev);\n\tif (opp_count < 0)\n\t\treturn opp_count;\n\tfor (i = 0, freq = 0; i < opp_count; ++i, ++freq) {\n\t\topp = dev_pm_opp_find_freq_ceil(dev, &freq);\n\t\tif (IS_ERR(opp)) {\n\t\t\tdev_err(dev, \"Failed enumerating OPPs: %ld\\n\",\n\t\t\t\tPTR_ERR(opp));\n\t\t\treturn PTR_ERR(opp);\n\t\t}\n\t\tdev_pm_opp_put(opp);\n\n\t\tfreq_info = imx8m_ddrc_find_freq(priv, freq);\n\t\tif (!freq_info) {\n\t\t\tdev_info(dev, \"Disable unsupported OPP %luHz %luMT/s\\n\",\n\t\t\t\t\tfreq, DIV_ROUND_CLOSEST(freq, 250000));\n\t\t\tdev_pm_opp_disable(dev, freq);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void imx8m_ddrc_exit(struct device *dev)\n{\n\tdev_pm_opp_of_remove_table(dev);\n}\n\nstatic int imx8m_ddrc_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct imx8m_ddrc *priv;\n\tconst char *gov = DEVFREQ_GOV_USERSPACE;\n\tint ret;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, priv);\n\n\tret = imx8m_ddrc_init_freq_info(dev);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to init firmware freq info: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tpriv->dram_core = devm_clk_get(dev, \"core\");\n\tif (IS_ERR(priv->dram_core)) {\n\t\tret = PTR_ERR(priv->dram_core);\n\t\tdev_err(dev, \"failed to fetch core clock: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\tpriv->dram_pll = devm_clk_get(dev, \"pll\");\n\tif (IS_ERR(priv->dram_pll)) {\n\t\tret = PTR_ERR(priv->dram_pll);\n\t\tdev_err(dev, \"failed to fetch pll clock: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\tpriv->dram_alt = devm_clk_get(dev, \"alt\");\n\tif (IS_ERR(priv->dram_alt)) {\n\t\tret = PTR_ERR(priv->dram_alt);\n\t\tdev_err(dev, \"failed to fetch alt clock: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\tpriv->dram_apb = devm_clk_get(dev, \"apb\");\n\tif (IS_ERR(priv->dram_apb)) {\n\t\tret = PTR_ERR(priv->dram_apb);\n\t\tdev_err(dev, \"failed to fetch apb clock: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = dev_pm_opp_of_add_table(dev);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to get OPP table\\n\");\n\t\treturn ret;\n\t}\n\n\tret = imx8m_ddrc_check_opps(dev);\n\tif (ret < 0)\n\t\tgoto err;\n\n\tpriv->profile.target = imx8m_ddrc_target;\n\tpriv->profile.exit = imx8m_ddrc_exit;\n\tpriv->profile.get_cur_freq = imx8m_ddrc_get_cur_freq;\n\tpriv->profile.initial_freq = clk_get_rate(priv->dram_core);\n\n\tpriv->devfreq = devm_devfreq_add_device(dev, &priv->profile,\n\t\t\t\t\t\tgov, NULL);\n\tif (IS_ERR(priv->devfreq)) {\n\t\tret = PTR_ERR(priv->devfreq);\n\t\tdev_err(dev, \"failed to add devfreq device: %d\\n\", ret);\n\t\tgoto err;\n\t}\n\n\treturn 0;\n\nerr:\n\tdev_pm_opp_of_remove_table(dev);\n\treturn ret;\n}\n\nstatic const struct of_device_id imx8m_ddrc_of_match[] = {\n\t{ .compatible = \"fsl,imx8m-ddrc\", },\n\t{   },\n};\nMODULE_DEVICE_TABLE(of, imx8m_ddrc_of_match);\n\nstatic struct platform_driver imx8m_ddrc_platdrv = {\n\t.probe\t\t= imx8m_ddrc_probe,\n\t.driver = {\n\t\t.name\t= \"imx8m-ddrc-devfreq\",\n\t\t.of_match_table = imx8m_ddrc_of_match,\n\t},\n};\nmodule_platform_driver(imx8m_ddrc_platdrv);\n\nMODULE_DESCRIPTION(\"i.MX8M DDR Controller frequency driver\");\nMODULE_AUTHOR(\"Leonard Crestez <leonard.crestez@nxp.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}