{
  "module_name": "devfreq-event.c",
  "hash_id": "7fdca6e6ea14d09f2b7a6ead81085c31cfb906c7e7b5a7ba0c95081cec2edd28",
  "original_prompt": "Ingested from linux-6.6.14/drivers/devfreq/devfreq-event.c",
  "human_readable_source": "\n \n\n#include <linux/devfreq-event.h>\n#include <linux/kernel.h>\n#include <linux/err.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/of.h>\n\nstatic struct class *devfreq_event_class;\n\n \nstatic LIST_HEAD(devfreq_event_list);\nstatic DEFINE_MUTEX(devfreq_event_list_lock);\n\n#define to_devfreq_event(DEV) container_of(DEV, struct devfreq_event_dev, dev)\n\n \nint devfreq_event_enable_edev(struct devfreq_event_dev *edev)\n{\n\tint ret = 0;\n\n\tif (!edev || !edev->desc)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&edev->lock);\n\tif (edev->desc->ops && edev->desc->ops->enable\n\t\t\t&& edev->enable_count == 0) {\n\t\tret = edev->desc->ops->enable(edev);\n\t\tif (ret < 0)\n\t\t\tgoto err;\n\t}\n\tedev->enable_count++;\nerr:\n\tmutex_unlock(&edev->lock);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(devfreq_event_enable_edev);\n\n \nint devfreq_event_disable_edev(struct devfreq_event_dev *edev)\n{\n\tint ret = 0;\n\n\tif (!edev || !edev->desc)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&edev->lock);\n\tif (edev->enable_count <= 0) {\n\t\tdev_warn(&edev->dev, \"unbalanced enable_count\\n\");\n\t\tret = -EIO;\n\t\tgoto err;\n\t}\n\n\tif (edev->desc->ops && edev->desc->ops->disable\n\t\t\t&& edev->enable_count == 1) {\n\t\tret = edev->desc->ops->disable(edev);\n\t\tif (ret < 0)\n\t\t\tgoto err;\n\t}\n\tedev->enable_count--;\nerr:\n\tmutex_unlock(&edev->lock);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(devfreq_event_disable_edev);\n\n \nbool devfreq_event_is_enabled(struct devfreq_event_dev *edev)\n{\n\tbool enabled = false;\n\n\tif (!edev || !edev->desc)\n\t\treturn enabled;\n\n\tmutex_lock(&edev->lock);\n\n\tif (edev->enable_count > 0)\n\t\tenabled = true;\n\n\tmutex_unlock(&edev->lock);\n\n\treturn enabled;\n}\nEXPORT_SYMBOL_GPL(devfreq_event_is_enabled);\n\n \nint devfreq_event_set_event(struct devfreq_event_dev *edev)\n{\n\tint ret;\n\n\tif (!edev || !edev->desc)\n\t\treturn -EINVAL;\n\n\tif (!edev->desc->ops || !edev->desc->ops->set_event)\n\t\treturn -EINVAL;\n\n\tif (!devfreq_event_is_enabled(edev))\n\t\treturn -EPERM;\n\n\tmutex_lock(&edev->lock);\n\tret = edev->desc->ops->set_event(edev);\n\tmutex_unlock(&edev->lock);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(devfreq_event_set_event);\n\n \nint devfreq_event_get_event(struct devfreq_event_dev *edev,\n\t\t\t    struct devfreq_event_data *edata)\n{\n\tint ret;\n\n\tif (!edev || !edev->desc)\n\t\treturn -EINVAL;\n\n\tif (!edev->desc->ops || !edev->desc->ops->get_event)\n\t\treturn -EINVAL;\n\n\tif (!devfreq_event_is_enabled(edev))\n\t\treturn -EINVAL;\n\n\tedata->total_count = edata->load_count = 0;\n\n\tmutex_lock(&edev->lock);\n\tret = edev->desc->ops->get_event(edev, edata);\n\tif (ret < 0)\n\t\tedata->total_count = edata->load_count = 0;\n\tmutex_unlock(&edev->lock);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(devfreq_event_get_event);\n\n \nint devfreq_event_reset_event(struct devfreq_event_dev *edev)\n{\n\tint ret = 0;\n\n\tif (!edev || !edev->desc)\n\t\treturn -EINVAL;\n\n\tif (!devfreq_event_is_enabled(edev))\n\t\treturn -EPERM;\n\n\tmutex_lock(&edev->lock);\n\tif (edev->desc->ops && edev->desc->ops->reset)\n\t\tret = edev->desc->ops->reset(edev);\n\tmutex_unlock(&edev->lock);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(devfreq_event_reset_event);\n\n \nstruct devfreq_event_dev *devfreq_event_get_edev_by_phandle(struct device *dev,\n\t\t\t\t\tconst char *phandle_name, int index)\n{\n\tstruct device_node *node;\n\tstruct devfreq_event_dev *edev;\n\n\tif (!dev->of_node || !phandle_name)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tnode = of_parse_phandle(dev->of_node, phandle_name, index);\n\tif (!node)\n\t\treturn ERR_PTR(-ENODEV);\n\n\tmutex_lock(&devfreq_event_list_lock);\n\tlist_for_each_entry(edev, &devfreq_event_list, node) {\n\t\tif (edev->dev.parent && device_match_of_node(edev->dev.parent, node))\n\t\t\tgoto out;\n\t}\n\n\tlist_for_each_entry(edev, &devfreq_event_list, node) {\n\t\tif (of_node_name_eq(node, edev->desc->name))\n\t\t\tgoto out;\n\t}\n\tedev = NULL;\nout:\n\tmutex_unlock(&devfreq_event_list_lock);\n\n\tif (!edev) {\n\t\tof_node_put(node);\n\t\treturn ERR_PTR(-ENODEV);\n\t}\n\n\tof_node_put(node);\n\n\treturn edev;\n}\nEXPORT_SYMBOL_GPL(devfreq_event_get_edev_by_phandle);\n\n \nint devfreq_event_get_edev_count(struct device *dev, const char *phandle_name)\n{\n\tint count;\n\n\tif (!dev->of_node || !phandle_name) {\n\t\tdev_err(dev, \"device does not have a device node entry\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tcount = of_property_count_elems_of_size(dev->of_node, phandle_name,\n\t\t\t\t\t\tsizeof(u32));\n\tif (count < 0) {\n\t\tdev_err(dev,\n\t\t\t\"failed to get the count of devfreq-event in %pOF node\\n\",\n\t\t\tdev->of_node);\n\t\treturn count;\n\t}\n\n\treturn count;\n}\nEXPORT_SYMBOL_GPL(devfreq_event_get_edev_count);\n\nstatic void devfreq_event_release_edev(struct device *dev)\n{\n\tstruct devfreq_event_dev *edev = to_devfreq_event(dev);\n\n\tkfree(edev);\n}\n\n \nstruct devfreq_event_dev *devfreq_event_add_edev(struct device *dev,\n\t\t\t\t\t\tstruct devfreq_event_desc *desc)\n{\n\tstruct devfreq_event_dev *edev;\n\tstatic atomic_t event_no = ATOMIC_INIT(-1);\n\tint ret;\n\n\tif (!dev || !desc)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (!desc->name || !desc->ops)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (!desc->ops->set_event || !desc->ops->get_event)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tedev = kzalloc(sizeof(struct devfreq_event_dev), GFP_KERNEL);\n\tif (!edev)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmutex_init(&edev->lock);\n\tedev->desc = desc;\n\tedev->enable_count = 0;\n\tedev->dev.parent = dev;\n\tedev->dev.class = devfreq_event_class;\n\tedev->dev.release = devfreq_event_release_edev;\n\n\tdev_set_name(&edev->dev, \"event%d\", atomic_inc_return(&event_no));\n\tret = device_register(&edev->dev);\n\tif (ret < 0) {\n\t\tput_device(&edev->dev);\n\t\treturn ERR_PTR(ret);\n\t}\n\tdev_set_drvdata(&edev->dev, edev);\n\n\tINIT_LIST_HEAD(&edev->node);\n\n\tmutex_lock(&devfreq_event_list_lock);\n\tlist_add(&edev->node, &devfreq_event_list);\n\tmutex_unlock(&devfreq_event_list_lock);\n\n\treturn edev;\n}\nEXPORT_SYMBOL_GPL(devfreq_event_add_edev);\n\n \nint devfreq_event_remove_edev(struct devfreq_event_dev *edev)\n{\n\tif (!edev)\n\t\treturn -EINVAL;\n\n\tWARN_ON(edev->enable_count);\n\n\tmutex_lock(&devfreq_event_list_lock);\n\tlist_del(&edev->node);\n\tmutex_unlock(&devfreq_event_list_lock);\n\n\tdevice_unregister(&edev->dev);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(devfreq_event_remove_edev);\n\nstatic int devm_devfreq_event_match(struct device *dev, void *res, void *data)\n{\n\tstruct devfreq_event_dev **r = res;\n\n\tif (WARN_ON(!r || !*r))\n\t\treturn 0;\n\n\treturn *r == data;\n}\n\nstatic void devm_devfreq_event_release(struct device *dev, void *res)\n{\n\tdevfreq_event_remove_edev(*(struct devfreq_event_dev **)res);\n}\n\n \nstruct devfreq_event_dev *devm_devfreq_event_add_edev(struct device *dev,\n\t\t\t\t\t\tstruct devfreq_event_desc *desc)\n{\n\tstruct devfreq_event_dev **ptr, *edev;\n\n\tptr = devres_alloc(devm_devfreq_event_release, sizeof(*ptr),\n\t\t\t\tGFP_KERNEL);\n\tif (!ptr)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tedev = devfreq_event_add_edev(dev, desc);\n\tif (IS_ERR(edev)) {\n\t\tdevres_free(ptr);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\t*ptr = edev;\n\tdevres_add(dev, ptr);\n\n\treturn edev;\n}\nEXPORT_SYMBOL_GPL(devm_devfreq_event_add_edev);\n\n \nvoid devm_devfreq_event_remove_edev(struct device *dev,\n\t\t\t\tstruct devfreq_event_dev *edev)\n{\n\tWARN_ON(devres_release(dev, devm_devfreq_event_release,\n\t\t\t       devm_devfreq_event_match, edev));\n}\nEXPORT_SYMBOL_GPL(devm_devfreq_event_remove_edev);\n\n \nstatic ssize_t name_show(struct device *dev, struct device_attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct devfreq_event_dev *edev = to_devfreq_event(dev);\n\n\tif (!edev || !edev->desc)\n\t\treturn -EINVAL;\n\n\treturn sprintf(buf, \"%s\\n\", edev->desc->name);\n}\nstatic DEVICE_ATTR_RO(name);\n\nstatic ssize_t enable_count_show(struct device *dev,\n\t\t\t\t  struct device_attribute *attr, char *buf)\n{\n\tstruct devfreq_event_dev *edev = to_devfreq_event(dev);\n\n\tif (!edev || !edev->desc)\n\t\treturn -EINVAL;\n\n\treturn sprintf(buf, \"%d\\n\", edev->enable_count);\n}\nstatic DEVICE_ATTR_RO(enable_count);\n\nstatic struct attribute *devfreq_event_attrs[] = {\n\t&dev_attr_name.attr,\n\t&dev_attr_enable_count.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(devfreq_event);\n\nstatic int __init devfreq_event_init(void)\n{\n\tdevfreq_event_class = class_create(\"devfreq-event\");\n\tif (IS_ERR(devfreq_event_class)) {\n\t\tpr_err(\"%s: couldn't create class\\n\", __FILE__);\n\t\treturn PTR_ERR(devfreq_event_class);\n\t}\n\n\tdevfreq_event_class->dev_groups = devfreq_event_groups;\n\n\treturn 0;\n}\nsubsys_initcall(devfreq_event_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}