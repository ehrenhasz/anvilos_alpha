{
  "module_name": "exynos-bus.c",
  "hash_id": "e1f9a20e1db2d8bc82e37530c1776e1d844b7888214f6cc209c96eb4befcfe58",
  "original_prompt": "Ingested from linux-6.6.14/drivers/devfreq/exynos-bus.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/devfreq.h>\n#include <linux/devfreq-event.h>\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/pm_opp.h>\n#include <linux/platform_device.h>\n#include <linux/regulator/consumer.h>\n\n#define DEFAULT_SATURATION_RATIO\t40\n\nstruct exynos_bus {\n\tstruct device *dev;\n\tstruct platform_device *icc_pdev;\n\n\tstruct devfreq *devfreq;\n\tstruct devfreq_event_dev **edev;\n\tunsigned int edev_count;\n\tstruct mutex lock;\n\n\tunsigned long curr_freq;\n\n\tint opp_token;\n\tstruct clk *clk;\n\tunsigned int ratio;\n};\n\n \n#define exynos_bus_ops_edev(ops)\t\t\t\t\\\nstatic int exynos_bus_##ops(struct exynos_bus *bus)\t\t\\\n{\t\t\t\t\t\t\t\t\\\n\tint i, ret;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\\\n\tfor (i = 0; i < bus->edev_count; i++) {\t\t\t\\\n\t\tif (!bus->edev[i])\t\t\t\t\\\n\t\t\tcontinue;\t\t\t\t\\\n\t\tret = devfreq_event_##ops(bus->edev[i]);\t\\\n\t\tif (ret < 0)\t\t\t\t\t\\\n\t\t\treturn ret;\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\\\n\treturn 0;\t\t\t\t\t\t\\\n}\nexynos_bus_ops_edev(enable_edev);\nexynos_bus_ops_edev(disable_edev);\nexynos_bus_ops_edev(set_event);\n\nstatic int exynos_bus_get_event(struct exynos_bus *bus,\n\t\t\t\tstruct devfreq_event_data *edata)\n{\n\tstruct devfreq_event_data event_data;\n\tunsigned long load_count = 0, total_count = 0;\n\tint i, ret = 0;\n\n\tfor (i = 0; i < bus->edev_count; i++) {\n\t\tif (!bus->edev[i])\n\t\t\tcontinue;\n\n\t\tret = devfreq_event_get_event(bus->edev[i], &event_data);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tif (i == 0 || event_data.load_count > load_count) {\n\t\t\tload_count = event_data.load_count;\n\t\t\ttotal_count = event_data.total_count;\n\t\t}\n\t}\n\n\tedata->load_count = load_count;\n\tedata->total_count = total_count;\n\n\treturn ret;\n}\n\n \nstatic int exynos_bus_target(struct device *dev, unsigned long *freq, u32 flags)\n{\n\tstruct exynos_bus *bus = dev_get_drvdata(dev);\n\tstruct dev_pm_opp *new_opp;\n\tint ret = 0;\n\n\t \n\tnew_opp = devfreq_recommended_opp(dev, freq, flags);\n\tif (IS_ERR(new_opp)) {\n\t\tdev_err(dev, \"failed to get recommended opp instance\\n\");\n\t\treturn PTR_ERR(new_opp);\n\t}\n\n\tdev_pm_opp_put(new_opp);\n\n\t \n\tmutex_lock(&bus->lock);\n\tret = dev_pm_opp_set_rate(dev, *freq);\n\tif (!ret)\n\t\tbus->curr_freq = *freq;\n\n\tmutex_unlock(&bus->lock);\n\n\treturn ret;\n}\n\nstatic int exynos_bus_get_dev_status(struct device *dev,\n\t\t\t\t     struct devfreq_dev_status *stat)\n{\n\tstruct exynos_bus *bus = dev_get_drvdata(dev);\n\tstruct devfreq_event_data edata;\n\tint ret;\n\n\tstat->current_frequency = bus->curr_freq;\n\n\tret = exynos_bus_get_event(bus, &edata);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to get event from devfreq-event devices\\n\");\n\t\tstat->total_time = stat->busy_time = 0;\n\t\tgoto err;\n\t}\n\n\tstat->busy_time = (edata.load_count * 100) / bus->ratio;\n\tstat->total_time = edata.total_count;\n\n\tdev_dbg(dev, \"Usage of devfreq-event : %lu/%lu\\n\", stat->busy_time,\n\t\t\t\t\t\t\tstat->total_time);\n\nerr:\n\tret = exynos_bus_set_event(bus);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to set event to devfreq-event devices\\n\");\n\t\treturn ret;\n\t}\n\n\treturn ret;\n}\n\nstatic void exynos_bus_exit(struct device *dev)\n{\n\tstruct exynos_bus *bus = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = exynos_bus_disable_edev(bus);\n\tif (ret < 0)\n\t\tdev_warn(dev, \"failed to disable the devfreq-event devices\\n\");\n\n\tplatform_device_unregister(bus->icc_pdev);\n\n\tdev_pm_opp_of_remove_table(dev);\n\tclk_disable_unprepare(bus->clk);\n\tdev_pm_opp_put_regulators(bus->opp_token);\n}\n\nstatic void exynos_bus_passive_exit(struct device *dev)\n{\n\tstruct exynos_bus *bus = dev_get_drvdata(dev);\n\n\tplatform_device_unregister(bus->icc_pdev);\n\n\tdev_pm_opp_of_remove_table(dev);\n\tclk_disable_unprepare(bus->clk);\n}\n\nstatic int exynos_bus_parent_parse_of(struct device_node *np,\n\t\t\t\t\tstruct exynos_bus *bus)\n{\n\tstruct device *dev = bus->dev;\n\tconst char *supplies[] = { \"vdd\", NULL };\n\tint i, ret, count, size;\n\n\tret = dev_pm_opp_set_regulators(dev, supplies);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to set regulators %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tbus->opp_token = ret;\n\n\t \n\tcount = devfreq_event_get_edev_count(dev, \"devfreq-events\");\n\tif (count < 0) {\n\t\tdev_err(dev, \"failed to get the count of devfreq-event dev\\n\");\n\t\tret = count;\n\t\tgoto err_regulator;\n\t}\n\tbus->edev_count = count;\n\n\tsize = sizeof(*bus->edev) * count;\n\tbus->edev = devm_kzalloc(dev, size, GFP_KERNEL);\n\tif (!bus->edev) {\n\t\tret = -ENOMEM;\n\t\tgoto err_regulator;\n\t}\n\n\tfor (i = 0; i < count; i++) {\n\t\tbus->edev[i] = devfreq_event_get_edev_by_phandle(dev,\n\t\t\t\t\t\t\t\"devfreq-events\", i);\n\t\tif (IS_ERR(bus->edev[i])) {\n\t\t\tret = -EPROBE_DEFER;\n\t\t\tgoto err_regulator;\n\t\t}\n\t}\n\n\t \n\tif (of_property_read_u32(np, \"exynos,saturation-ratio\", &bus->ratio))\n\t\tbus->ratio = DEFAULT_SATURATION_RATIO;\n\n\treturn 0;\n\nerr_regulator:\n\tdev_pm_opp_put_regulators(bus->opp_token);\n\n\treturn ret;\n}\n\nstatic int exynos_bus_parse_of(struct device_node *np,\n\t\t\t      struct exynos_bus *bus)\n{\n\tstruct device *dev = bus->dev;\n\tstruct dev_pm_opp *opp;\n\tunsigned long rate;\n\tint ret;\n\n\t \n\tbus->clk = devm_clk_get(dev, \"bus\");\n\tif (IS_ERR(bus->clk)) {\n\t\tdev_err(dev, \"failed to get bus clock\\n\");\n\t\treturn PTR_ERR(bus->clk);\n\t}\n\n\tret = clk_prepare_enable(bus->clk);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to get enable clock\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tret = dev_pm_opp_of_add_table(dev);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to get OPP table\\n\");\n\t\tgoto err_clk;\n\t}\n\n\trate = clk_get_rate(bus->clk);\n\n\topp = devfreq_recommended_opp(dev, &rate, 0);\n\tif (IS_ERR(opp)) {\n\t\tdev_err(dev, \"failed to find dev_pm_opp\\n\");\n\t\tret = PTR_ERR(opp);\n\t\tgoto err_opp;\n\t}\n\tbus->curr_freq = dev_pm_opp_get_freq(opp);\n\tdev_pm_opp_put(opp);\n\n\treturn 0;\n\nerr_opp:\n\tdev_pm_opp_of_remove_table(dev);\nerr_clk:\n\tclk_disable_unprepare(bus->clk);\n\n\treturn ret;\n}\n\nstatic int exynos_bus_profile_init(struct exynos_bus *bus,\n\t\t\t\t   struct devfreq_dev_profile *profile)\n{\n\tstruct device *dev = bus->dev;\n\tstruct devfreq_simple_ondemand_data *ondemand_data;\n\tint ret;\n\n\t \n\tprofile->polling_ms = 50;\n\tprofile->target = exynos_bus_target;\n\tprofile->get_dev_status = exynos_bus_get_dev_status;\n\tprofile->exit = exynos_bus_exit;\n\n\tondemand_data = devm_kzalloc(dev, sizeof(*ondemand_data), GFP_KERNEL);\n\tif (!ondemand_data)\n\t\treturn -ENOMEM;\n\n\tondemand_data->upthreshold = 40;\n\tondemand_data->downdifferential = 5;\n\n\t \n\tbus->devfreq = devm_devfreq_add_device(dev, profile,\n\t\t\t\t\t\tDEVFREQ_GOV_SIMPLE_ONDEMAND,\n\t\t\t\t\t\tondemand_data);\n\tif (IS_ERR(bus->devfreq)) {\n\t\tdev_err(dev, \"failed to add devfreq device\\n\");\n\t\treturn PTR_ERR(bus->devfreq);\n\t}\n\n\t \n\tret = devm_devfreq_register_opp_notifier(dev, bus->devfreq);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to register opp notifier\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tret = exynos_bus_enable_edev(bus);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to enable devfreq-event devices\\n\");\n\t\treturn ret;\n\t}\n\n\tret = exynos_bus_set_event(bus);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to set event to devfreq-event devices\\n\");\n\t\tgoto err_edev;\n\t}\n\n\treturn 0;\n\nerr_edev:\n\tif (exynos_bus_disable_edev(bus))\n\t\tdev_warn(dev, \"failed to disable the devfreq-event devices\\n\");\n\n\treturn ret;\n}\n\nstatic int exynos_bus_profile_init_passive(struct exynos_bus *bus,\n\t\t\t\t\t   struct devfreq_dev_profile *profile)\n{\n\tstruct device *dev = bus->dev;\n\tstruct devfreq_passive_data *passive_data;\n\tstruct devfreq *parent_devfreq;\n\n\t \n\tprofile->target = exynos_bus_target;\n\tprofile->exit = exynos_bus_passive_exit;\n\n\t \n\tparent_devfreq = devfreq_get_devfreq_by_phandle(dev, \"devfreq\", 0);\n\tif (IS_ERR(parent_devfreq))\n\t\treturn -EPROBE_DEFER;\n\n\tpassive_data = devm_kzalloc(dev, sizeof(*passive_data), GFP_KERNEL);\n\tif (!passive_data)\n\t\treturn -ENOMEM;\n\n\tpassive_data->parent = parent_devfreq;\n\n\t \n\tbus->devfreq = devm_devfreq_add_device(dev, profile, DEVFREQ_GOV_PASSIVE,\n\t\t\t\t\t\tpassive_data);\n\tif (IS_ERR(bus->devfreq)) {\n\t\tdev_err(dev,\n\t\t\t\"failed to add devfreq dev with passive governor\\n\");\n\t\treturn PTR_ERR(bus->devfreq);\n\t}\n\n\treturn 0;\n}\n\nstatic int exynos_bus_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np = dev->of_node, *node;\n\tstruct devfreq_dev_profile *profile;\n\tstruct exynos_bus *bus;\n\tint ret, max_state;\n\tunsigned long min_freq, max_freq;\n\tbool passive = false;\n\n\tif (!np) {\n\t\tdev_err(dev, \"failed to find devicetree node\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tbus = devm_kzalloc(&pdev->dev, sizeof(*bus), GFP_KERNEL);\n\tif (!bus)\n\t\treturn -ENOMEM;\n\tmutex_init(&bus->lock);\n\tbus->dev = &pdev->dev;\n\tplatform_set_drvdata(pdev, bus);\n\n\tprofile = devm_kzalloc(dev, sizeof(*profile), GFP_KERNEL);\n\tif (!profile)\n\t\treturn -ENOMEM;\n\n\tnode = of_parse_phandle(dev->of_node, \"devfreq\", 0);\n\tif (node) {\n\t\tof_node_put(node);\n\t\tpassive = true;\n\t} else {\n\t\tret = exynos_bus_parent_parse_of(np, bus);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\t \n\tret = exynos_bus_parse_of(np, bus);\n\tif (ret < 0)\n\t\tgoto err_reg;\n\n\tif (passive)\n\t\tret = exynos_bus_profile_init_passive(bus, profile);\n\telse\n\t\tret = exynos_bus_profile_init(bus, profile);\n\n\tif (ret < 0)\n\t\tgoto err;\n\n\t \n\tif (of_property_present(dev->of_node, \"#interconnect-cells\")) {\n\t\tbus->icc_pdev = platform_device_register_data(\n\t\t\t\t\t\tdev, \"exynos-generic-icc\",\n\t\t\t\t\t\tPLATFORM_DEVID_AUTO, NULL, 0);\n\n\t\tif (IS_ERR(bus->icc_pdev)) {\n\t\t\tret = PTR_ERR(bus->icc_pdev);\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\tmax_state = bus->devfreq->max_state;\n\tmin_freq = (bus->devfreq->freq_table[0] / 1000);\n\tmax_freq = (bus->devfreq->freq_table[max_state - 1] / 1000);\n\tpr_info(\"exynos-bus: new bus device registered: %s (%6ld KHz ~ %6ld KHz)\\n\",\n\t\t\tdev_name(dev), min_freq, max_freq);\n\n\treturn 0;\n\nerr:\n\tdev_pm_opp_of_remove_table(dev);\n\tclk_disable_unprepare(bus->clk);\nerr_reg:\n\tdev_pm_opp_put_regulators(bus->opp_token);\n\n\treturn ret;\n}\n\nstatic void exynos_bus_shutdown(struct platform_device *pdev)\n{\n\tstruct exynos_bus *bus = dev_get_drvdata(&pdev->dev);\n\n\tdevfreq_suspend_device(bus->devfreq);\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int exynos_bus_resume(struct device *dev)\n{\n\tstruct exynos_bus *bus = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = exynos_bus_enable_edev(bus);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to enable the devfreq-event devices\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int exynos_bus_suspend(struct device *dev)\n{\n\tstruct exynos_bus *bus = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = exynos_bus_disable_edev(bus);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to disable the devfreq-event devices\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n#endif\n\nstatic const struct dev_pm_ops exynos_bus_pm = {\n\tSET_SYSTEM_SLEEP_PM_OPS(exynos_bus_suspend, exynos_bus_resume)\n};\n\nstatic const struct of_device_id exynos_bus_of_match[] = {\n\t{ .compatible = \"samsung,exynos-bus\", },\n\t{   },\n};\nMODULE_DEVICE_TABLE(of, exynos_bus_of_match);\n\nstatic struct platform_driver exynos_bus_platdrv = {\n\t.probe\t\t= exynos_bus_probe,\n\t.shutdown\t= exynos_bus_shutdown,\n\t.driver = {\n\t\t.name\t= \"exynos-bus\",\n\t\t.pm\t= &exynos_bus_pm,\n\t\t.of_match_table = exynos_bus_of_match,\n\t},\n};\nmodule_platform_driver(exynos_bus_platdrv);\n\nMODULE_SOFTDEP(\"pre: exynos_ppmu\");\nMODULE_DESCRIPTION(\"Generic Exynos Bus frequency driver\");\nMODULE_AUTHOR(\"Chanwoo Choi <cw00.choi@samsung.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}