{
  "module_name": "governor_passive.c",
  "hash_id": "0645296ffa4f6aa9f8d85581efe4d120e6ffda1bcb60ffadfdfd7666f9bd44a4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/devfreq/governor_passive.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/cpu.h>\n#include <linux/cpufreq.h>\n#include <linux/cpumask.h>\n#include <linux/slab.h>\n#include <linux/device.h>\n#include <linux/devfreq.h>\n#include <linux/units.h>\n#include \"governor.h\"\n\nstatic struct devfreq_cpu_data *\nget_parent_cpu_data(struct devfreq_passive_data *p_data,\n\t\t    struct cpufreq_policy *policy)\n{\n\tstruct devfreq_cpu_data *parent_cpu_data;\n\n\tif (!p_data || !policy)\n\t\treturn NULL;\n\n\tlist_for_each_entry(parent_cpu_data, &p_data->cpu_data_list, node)\n\t\tif (parent_cpu_data->first_cpu == cpumask_first(policy->related_cpus))\n\t\t\treturn parent_cpu_data;\n\n\treturn NULL;\n}\n\nstatic void delete_parent_cpu_data(struct devfreq_passive_data *p_data)\n{\n\tstruct devfreq_cpu_data *parent_cpu_data, *tmp;\n\n\tlist_for_each_entry_safe(parent_cpu_data, tmp, &p_data->cpu_data_list, node) {\n\t\tlist_del(&parent_cpu_data->node);\n\n\t\tif (parent_cpu_data->opp_table)\n\t\t\tdev_pm_opp_put_opp_table(parent_cpu_data->opp_table);\n\n\t\tkfree(parent_cpu_data);\n\t}\n}\n\nstatic unsigned long get_target_freq_by_required_opp(struct device *p_dev,\n\t\t\t\t\t\tstruct opp_table *p_opp_table,\n\t\t\t\t\t\tstruct opp_table *opp_table,\n\t\t\t\t\t\tunsigned long *freq)\n{\n\tstruct dev_pm_opp *opp = NULL, *p_opp = NULL;\n\tunsigned long target_freq;\n\n\tif (!p_dev || !p_opp_table || !opp_table || !freq)\n\t\treturn 0;\n\n\tp_opp = devfreq_recommended_opp(p_dev, freq, 0);\n\tif (IS_ERR(p_opp))\n\t\treturn 0;\n\n\topp = dev_pm_opp_xlate_required_opp(p_opp_table, opp_table, p_opp);\n\tdev_pm_opp_put(p_opp);\n\n\tif (IS_ERR(opp))\n\t\treturn 0;\n\n\ttarget_freq = dev_pm_opp_get_freq(opp);\n\tdev_pm_opp_put(opp);\n\n\treturn target_freq;\n}\n\nstatic int get_target_freq_with_cpufreq(struct devfreq *devfreq,\n\t\t\t\t\tunsigned long *target_freq)\n{\n\tstruct devfreq_passive_data *p_data =\n\t\t\t\t(struct devfreq_passive_data *)devfreq->data;\n\tstruct devfreq_cpu_data *parent_cpu_data;\n\tstruct cpufreq_policy *policy;\n\tunsigned long cpu, cpu_cur, cpu_min, cpu_max, cpu_percent;\n\tunsigned long dev_min, dev_max;\n\tunsigned long freq = 0;\n\tint ret = 0;\n\n\tfor_each_online_cpu(cpu) {\n\t\tpolicy = cpufreq_cpu_get(cpu);\n\t\tif (!policy) {\n\t\t\tret = -EINVAL;\n\t\t\tcontinue;\n\t\t}\n\n\t\tparent_cpu_data = get_parent_cpu_data(p_data, policy);\n\t\tif (!parent_cpu_data) {\n\t\t\tcpufreq_cpu_put(policy);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tcpu_cur = parent_cpu_data->cur_freq * HZ_PER_KHZ;\n\t\tfreq = get_target_freq_by_required_opp(parent_cpu_data->dev,\n\t\t\t\t\tparent_cpu_data->opp_table,\n\t\t\t\t\tdevfreq->opp_table, &cpu_cur);\n\t\tif (freq) {\n\t\t\t*target_freq = max(freq, *target_freq);\n\t\t\tcpufreq_cpu_put(policy);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tdevfreq_get_freq_range(devfreq, &dev_min, &dev_max);\n\n\t\tcpu_min = parent_cpu_data->min_freq;\n\t\tcpu_max = parent_cpu_data->max_freq;\n\t\tcpu_cur = parent_cpu_data->cur_freq;\n\n\t\tcpu_percent = ((cpu_cur - cpu_min) * 100) / (cpu_max - cpu_min);\n\t\tfreq = dev_min + mult_frac(dev_max - dev_min, cpu_percent, 100);\n\n\t\t*target_freq = max(freq, *target_freq);\n\t\tcpufreq_cpu_put(policy);\n\t}\n\n\treturn ret;\n}\n\nstatic int get_target_freq_with_devfreq(struct devfreq *devfreq,\n\t\t\t\t\tunsigned long *freq)\n{\n\tstruct devfreq_passive_data *p_data\n\t\t\t= (struct devfreq_passive_data *)devfreq->data;\n\tstruct devfreq *parent_devfreq = (struct devfreq *)p_data->parent;\n\tunsigned long child_freq = ULONG_MAX;\n\tint i, count;\n\n\t \n\tchild_freq = get_target_freq_by_required_opp(parent_devfreq->dev.parent,\n\t\t\t\t\t\tparent_devfreq->opp_table,\n\t\t\t\t\t\tdevfreq->opp_table, freq);\n\tif (child_freq)\n\t\tgoto out;\n\n\t \n\tfor (i = 0; i < parent_devfreq->max_state; i++)\n\t\tif (parent_devfreq->freq_table[i] == *freq)\n\t\t\tbreak;\n\n\tif (i == parent_devfreq->max_state)\n\t\treturn -EINVAL;\n\n\tif (i < devfreq->max_state) {\n\t\tchild_freq = devfreq->freq_table[i];\n\t} else {\n\t\tcount = devfreq->max_state;\n\t\tchild_freq = devfreq->freq_table[count - 1];\n\t}\n\nout:\n\t*freq = child_freq;\n\n\treturn 0;\n}\n\nstatic int devfreq_passive_get_target_freq(struct devfreq *devfreq,\n\t\t\t\t\t   unsigned long *freq)\n{\n\tstruct devfreq_passive_data *p_data =\n\t\t\t\t(struct devfreq_passive_data *)devfreq->data;\n\tint ret;\n\n\tif (!p_data)\n\t\treturn -EINVAL;\n\n\t \n\tif (p_data->get_target_freq)\n\t\treturn p_data->get_target_freq(devfreq, freq);\n\n\tswitch (p_data->parent_type) {\n\tcase DEVFREQ_PARENT_DEV:\n\t\tret = get_target_freq_with_devfreq(devfreq, freq);\n\t\tbreak;\n\tcase CPUFREQ_PARENT_DEV:\n\t\tret = get_target_freq_with_cpufreq(devfreq, freq);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tdev_err(&devfreq->dev, \"Invalid parent type\\n\");\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int cpufreq_passive_notifier_call(struct notifier_block *nb,\n\t\t\t\t\t unsigned long event, void *ptr)\n{\n\tstruct devfreq_passive_data *p_data =\n\t\t\tcontainer_of(nb, struct devfreq_passive_data, nb);\n\tstruct devfreq *devfreq = (struct devfreq *)p_data->this;\n\tstruct devfreq_cpu_data *parent_cpu_data;\n\tstruct cpufreq_freqs *freqs = ptr;\n\tunsigned int cur_freq;\n\tint ret;\n\n\tif (event != CPUFREQ_POSTCHANGE || !freqs)\n\t\treturn 0;\n\n\tparent_cpu_data = get_parent_cpu_data(p_data, freqs->policy);\n\tif (!parent_cpu_data || parent_cpu_data->cur_freq == freqs->new)\n\t\treturn 0;\n\n\tcur_freq = parent_cpu_data->cur_freq;\n\tparent_cpu_data->cur_freq = freqs->new;\n\n\tmutex_lock(&devfreq->lock);\n\tret = devfreq_update_target(devfreq, freqs->new);\n\tmutex_unlock(&devfreq->lock);\n\tif (ret) {\n\t\tparent_cpu_data->cur_freq = cur_freq;\n\t\tdev_err(&devfreq->dev, \"failed to update the frequency.\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int cpufreq_passive_unregister_notifier(struct devfreq *devfreq)\n{\n\tstruct devfreq_passive_data *p_data\n\t\t\t= (struct devfreq_passive_data *)devfreq->data;\n\tint ret;\n\n\tif (p_data->nb.notifier_call) {\n\t\tret = cpufreq_unregister_notifier(&p_data->nb,\n\t\t\t\t\tCPUFREQ_TRANSITION_NOTIFIER);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tdelete_parent_cpu_data(p_data);\n\n\treturn 0;\n}\n\nstatic int cpufreq_passive_register_notifier(struct devfreq *devfreq)\n{\n\tstruct devfreq_passive_data *p_data\n\t\t\t= (struct devfreq_passive_data *)devfreq->data;\n\tstruct device *dev = devfreq->dev.parent;\n\tstruct opp_table *opp_table = NULL;\n\tstruct devfreq_cpu_data *parent_cpu_data;\n\tstruct cpufreq_policy *policy;\n\tstruct device *cpu_dev;\n\tunsigned int cpu;\n\tint ret;\n\n\tp_data->cpu_data_list\n\t\t= (struct list_head)LIST_HEAD_INIT(p_data->cpu_data_list);\n\n\tp_data->nb.notifier_call = cpufreq_passive_notifier_call;\n\tret = cpufreq_register_notifier(&p_data->nb, CPUFREQ_TRANSITION_NOTIFIER);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to register cpufreq notifier\\n\");\n\t\tp_data->nb.notifier_call = NULL;\n\t\tgoto err;\n\t}\n\n\tfor_each_possible_cpu(cpu) {\n\t\tpolicy = cpufreq_cpu_get(cpu);\n\t\tif (!policy) {\n\t\t\tret = -EPROBE_DEFER;\n\t\t\tgoto err;\n\t\t}\n\n\t\tparent_cpu_data = get_parent_cpu_data(p_data, policy);\n\t\tif (parent_cpu_data) {\n\t\t\tcpufreq_cpu_put(policy);\n\t\t\tcontinue;\n\t\t}\n\n\t\tparent_cpu_data = kzalloc(sizeof(*parent_cpu_data),\n\t\t\t\t\t\tGFP_KERNEL);\n\t\tif (!parent_cpu_data) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err_put_policy;\n\t\t}\n\n\t\tcpu_dev = get_cpu_device(cpu);\n\t\tif (!cpu_dev) {\n\t\t\tdev_err(dev, \"failed to get cpu device\\n\");\n\t\t\tret = -ENODEV;\n\t\t\tgoto err_free_cpu_data;\n\t\t}\n\n\t\topp_table = dev_pm_opp_get_opp_table(cpu_dev);\n\t\tif (IS_ERR(opp_table)) {\n\t\t\tdev_err(dev, \"failed to get opp_table of cpu%d\\n\", cpu);\n\t\t\tret = PTR_ERR(opp_table);\n\t\t\tgoto err_free_cpu_data;\n\t\t}\n\n\t\tparent_cpu_data->dev = cpu_dev;\n\t\tparent_cpu_data->opp_table = opp_table;\n\t\tparent_cpu_data->first_cpu = cpumask_first(policy->related_cpus);\n\t\tparent_cpu_data->cur_freq = policy->cur;\n\t\tparent_cpu_data->min_freq = policy->cpuinfo.min_freq;\n\t\tparent_cpu_data->max_freq = policy->cpuinfo.max_freq;\n\n\t\tlist_add_tail(&parent_cpu_data->node, &p_data->cpu_data_list);\n\t\tcpufreq_cpu_put(policy);\n\t}\n\n\tmutex_lock(&devfreq->lock);\n\tret = devfreq_update_target(devfreq, 0L);\n\tmutex_unlock(&devfreq->lock);\n\tif (ret)\n\t\tdev_err(dev, \"failed to update the frequency\\n\");\n\n\treturn ret;\n\nerr_free_cpu_data:\n\tkfree(parent_cpu_data);\nerr_put_policy:\n\tcpufreq_cpu_put(policy);\nerr:\n\n\treturn ret;\n}\n\nstatic int devfreq_passive_notifier_call(struct notifier_block *nb,\n\t\t\t\tunsigned long event, void *ptr)\n{\n\tstruct devfreq_passive_data *data\n\t\t\t= container_of(nb, struct devfreq_passive_data, nb);\n\tstruct devfreq *devfreq = (struct devfreq *)data->this;\n\tstruct devfreq *parent = (struct devfreq *)data->parent;\n\tstruct devfreq_freqs *freqs = (struct devfreq_freqs *)ptr;\n\tunsigned long freq = freqs->new;\n\tint ret = 0;\n\n\tmutex_lock_nested(&devfreq->lock, SINGLE_DEPTH_NESTING);\n\tswitch (event) {\n\tcase DEVFREQ_PRECHANGE:\n\t\tif (parent->previous_freq > freq)\n\t\t\tret = devfreq_update_target(devfreq, freq);\n\n\t\tbreak;\n\tcase DEVFREQ_POSTCHANGE:\n\t\tif (parent->previous_freq < freq)\n\t\t\tret = devfreq_update_target(devfreq, freq);\n\t\tbreak;\n\t}\n\tmutex_unlock(&devfreq->lock);\n\n\tif (ret < 0)\n\t\tdev_warn(&devfreq->dev,\n\t\t\t\"failed to update devfreq using passive governor\\n\");\n\n\treturn NOTIFY_DONE;\n}\n\nstatic int devfreq_passive_unregister_notifier(struct devfreq *devfreq)\n{\n\tstruct devfreq_passive_data *p_data\n\t\t\t= (struct devfreq_passive_data *)devfreq->data;\n\tstruct devfreq *parent = (struct devfreq *)p_data->parent;\n\tstruct notifier_block *nb = &p_data->nb;\n\n\treturn devfreq_unregister_notifier(parent, nb, DEVFREQ_TRANSITION_NOTIFIER);\n}\n\nstatic int devfreq_passive_register_notifier(struct devfreq *devfreq)\n{\n\tstruct devfreq_passive_data *p_data\n\t\t\t= (struct devfreq_passive_data *)devfreq->data;\n\tstruct devfreq *parent = (struct devfreq *)p_data->parent;\n\tstruct notifier_block *nb = &p_data->nb;\n\n\tif (!parent)\n\t\treturn -EPROBE_DEFER;\n\n\tnb->notifier_call = devfreq_passive_notifier_call;\n\treturn devfreq_register_notifier(parent, nb, DEVFREQ_TRANSITION_NOTIFIER);\n}\n\nstatic int devfreq_passive_event_handler(struct devfreq *devfreq,\n\t\t\t\tunsigned int event, void *data)\n{\n\tstruct devfreq_passive_data *p_data\n\t\t\t= (struct devfreq_passive_data *)devfreq->data;\n\tint ret = 0;\n\n\tif (!p_data)\n\t\treturn -EINVAL;\n\n\tp_data->this = devfreq;\n\n\tswitch (event) {\n\tcase DEVFREQ_GOV_START:\n\t\tif (p_data->parent_type == DEVFREQ_PARENT_DEV)\n\t\t\tret = devfreq_passive_register_notifier(devfreq);\n\t\telse if (p_data->parent_type == CPUFREQ_PARENT_DEV)\n\t\t\tret = cpufreq_passive_register_notifier(devfreq);\n\t\tbreak;\n\tcase DEVFREQ_GOV_STOP:\n\t\tif (p_data->parent_type == DEVFREQ_PARENT_DEV)\n\t\t\tWARN_ON(devfreq_passive_unregister_notifier(devfreq));\n\t\telse if (p_data->parent_type == CPUFREQ_PARENT_DEV)\n\t\t\tWARN_ON(cpufreq_passive_unregister_notifier(devfreq));\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic struct devfreq_governor devfreq_passive = {\n\t.name = DEVFREQ_GOV_PASSIVE,\n\t.flags = DEVFREQ_GOV_FLAG_IMMUTABLE,\n\t.get_target_freq = devfreq_passive_get_target_freq,\n\t.event_handler = devfreq_passive_event_handler,\n};\n\nstatic int __init devfreq_passive_init(void)\n{\n\treturn devfreq_add_governor(&devfreq_passive);\n}\nsubsys_initcall(devfreq_passive_init);\n\nstatic void __exit devfreq_passive_exit(void)\n{\n\tint ret;\n\n\tret = devfreq_remove_governor(&devfreq_passive);\n\tif (ret)\n\t\tpr_err(\"%s: failed remove governor %d\\n\", __func__, ret);\n}\nmodule_exit(devfreq_passive_exit);\n\nMODULE_AUTHOR(\"Chanwoo Choi <cw00.choi@samsung.com>\");\nMODULE_AUTHOR(\"MyungJoo Ham <myungjoo.ham@samsung.com>\");\nMODULE_DESCRIPTION(\"DEVFREQ Passive governor\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}