{
  "module_name": "devfreq.c",
  "hash_id": "2becb72818598bb3c137e57f1bc8d68281c741243ecddde6f426da891e0a76e5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/devfreq/devfreq.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/devfreq_cooling.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/pm_opp.h>\n#include <linux/devfreq.h>\n#include <linux/workqueue.h>\n#include <linux/platform_device.h>\n#include <linux/list.h>\n#include <linux/printk.h>\n#include <linux/hrtimer.h>\n#include <linux/of.h>\n#include <linux/pm_qos.h>\n#include <linux/units.h>\n#include \"governor.h\"\n\n#define CREATE_TRACE_POINTS\n#include <trace/events/devfreq.h>\n\n#define IS_SUPPORTED_FLAG(f, name) ((f & DEVFREQ_GOV_FLAG_##name) ? true : false)\n#define IS_SUPPORTED_ATTR(f, name) ((f & DEVFREQ_GOV_ATTR_##name) ? true : false)\n\nstatic struct class *devfreq_class;\nstatic struct dentry *devfreq_debugfs;\n\n \nstatic struct workqueue_struct *devfreq_wq;\n\n \nstatic LIST_HEAD(devfreq_governor_list);\n \nstatic LIST_HEAD(devfreq_list);\nstatic DEFINE_MUTEX(devfreq_list_lock);\n\nstatic const char timer_name[][DEVFREQ_NAME_LEN] = {\n\t[DEVFREQ_TIMER_DEFERRABLE] = { \"deferrable\" },\n\t[DEVFREQ_TIMER_DELAYED] = { \"delayed\" },\n};\n\n \nstatic struct devfreq *find_device_devfreq(struct device *dev)\n{\n\tstruct devfreq *tmp_devfreq;\n\n\tlockdep_assert_held(&devfreq_list_lock);\n\n\tif (IS_ERR_OR_NULL(dev)) {\n\t\tpr_err(\"DEVFREQ: %s: Invalid parameters\\n\", __func__);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tlist_for_each_entry(tmp_devfreq, &devfreq_list, node) {\n\t\tif (tmp_devfreq->dev.parent == dev)\n\t\t\treturn tmp_devfreq;\n\t}\n\n\treturn ERR_PTR(-ENODEV);\n}\n\nstatic unsigned long find_available_min_freq(struct devfreq *devfreq)\n{\n\tstruct dev_pm_opp *opp;\n\tunsigned long min_freq = 0;\n\n\topp = dev_pm_opp_find_freq_ceil(devfreq->dev.parent, &min_freq);\n\tif (IS_ERR(opp))\n\t\tmin_freq = 0;\n\telse\n\t\tdev_pm_opp_put(opp);\n\n\treturn min_freq;\n}\n\nstatic unsigned long find_available_max_freq(struct devfreq *devfreq)\n{\n\tstruct dev_pm_opp *opp;\n\tunsigned long max_freq = ULONG_MAX;\n\n\topp = dev_pm_opp_find_freq_floor(devfreq->dev.parent, &max_freq);\n\tif (IS_ERR(opp))\n\t\tmax_freq = 0;\n\telse\n\t\tdev_pm_opp_put(opp);\n\n\treturn max_freq;\n}\n\n \nvoid devfreq_get_freq_range(struct devfreq *devfreq,\n\t\t\t    unsigned long *min_freq,\n\t\t\t    unsigned long *max_freq)\n{\n\tunsigned long *freq_table = devfreq->freq_table;\n\ts32 qos_min_freq, qos_max_freq;\n\n\tlockdep_assert_held(&devfreq->lock);\n\n\t \n\tif (freq_table[0] < freq_table[devfreq->max_state - 1]) {\n\t\t*min_freq = freq_table[0];\n\t\t*max_freq = freq_table[devfreq->max_state - 1];\n\t} else {\n\t\t*min_freq = freq_table[devfreq->max_state - 1];\n\t\t*max_freq = freq_table[0];\n\t}\n\n\t \n\tqos_min_freq = dev_pm_qos_read_value(devfreq->dev.parent,\n\t\t\t\t\t     DEV_PM_QOS_MIN_FREQUENCY);\n\tqos_max_freq = dev_pm_qos_read_value(devfreq->dev.parent,\n\t\t\t\t\t     DEV_PM_QOS_MAX_FREQUENCY);\n\t*min_freq = max(*min_freq, (unsigned long)HZ_PER_KHZ * qos_min_freq);\n\tif (qos_max_freq != PM_QOS_MAX_FREQUENCY_DEFAULT_VALUE)\n\t\t*max_freq = min(*max_freq,\n\t\t\t\t(unsigned long)HZ_PER_KHZ * qos_max_freq);\n\n\t \n\t*min_freq = max(*min_freq, devfreq->scaling_min_freq);\n\t*max_freq = min(*max_freq, devfreq->scaling_max_freq);\n\n\tif (*min_freq > *max_freq)\n\t\t*min_freq = *max_freq;\n}\nEXPORT_SYMBOL(devfreq_get_freq_range);\n\n \nstatic int devfreq_get_freq_level(struct devfreq *devfreq, unsigned long freq)\n{\n\tint lev;\n\n\tfor (lev = 0; lev < devfreq->max_state; lev++)\n\t\tif (freq == devfreq->freq_table[lev])\n\t\t\treturn lev;\n\n\treturn -EINVAL;\n}\n\nstatic int set_freq_table(struct devfreq *devfreq)\n{\n\tstruct dev_pm_opp *opp;\n\tunsigned long freq;\n\tint i, count;\n\n\t \n\tcount = dev_pm_opp_get_opp_count(devfreq->dev.parent);\n\tif (count <= 0)\n\t\treturn -EINVAL;\n\n\tdevfreq->max_state = count;\n\tdevfreq->freq_table = devm_kcalloc(devfreq->dev.parent,\n\t\t\t\t\t   devfreq->max_state,\n\t\t\t\t\t   sizeof(*devfreq->freq_table),\n\t\t\t\t\t   GFP_KERNEL);\n\tif (!devfreq->freq_table)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0, freq = 0; i < devfreq->max_state; i++, freq++) {\n\t\topp = dev_pm_opp_find_freq_ceil(devfreq->dev.parent, &freq);\n\t\tif (IS_ERR(opp)) {\n\t\t\tdevm_kfree(devfreq->dev.parent, devfreq->freq_table);\n\t\t\treturn PTR_ERR(opp);\n\t\t}\n\t\tdev_pm_opp_put(opp);\n\t\tdevfreq->freq_table[i] = freq;\n\t}\n\n\treturn 0;\n}\n\n \nint devfreq_update_status(struct devfreq *devfreq, unsigned long freq)\n{\n\tint lev, prev_lev, ret = 0;\n\tu64 cur_time;\n\n\tlockdep_assert_held(&devfreq->lock);\n\tcur_time = get_jiffies_64();\n\n\t \n\tif (!devfreq->previous_freq)\n\t\tgoto out;\n\n\tprev_lev = devfreq_get_freq_level(devfreq, devfreq->previous_freq);\n\tif (prev_lev < 0) {\n\t\tret = prev_lev;\n\t\tgoto out;\n\t}\n\n\tdevfreq->stats.time_in_state[prev_lev] +=\n\t\t\tcur_time - devfreq->stats.last_update;\n\n\tlev = devfreq_get_freq_level(devfreq, freq);\n\tif (lev < 0) {\n\t\tret = lev;\n\t\tgoto out;\n\t}\n\n\tif (lev != prev_lev) {\n\t\tdevfreq->stats.trans_table[\n\t\t\t(prev_lev * devfreq->max_state) + lev]++;\n\t\tdevfreq->stats.total_trans++;\n\t}\n\nout:\n\tdevfreq->stats.last_update = cur_time;\n\treturn ret;\n}\nEXPORT_SYMBOL(devfreq_update_status);\n\n \nstatic struct devfreq_governor *find_devfreq_governor(const char *name)\n{\n\tstruct devfreq_governor *tmp_governor;\n\n\tlockdep_assert_held(&devfreq_list_lock);\n\n\tif (IS_ERR_OR_NULL(name)) {\n\t\tpr_err(\"DEVFREQ: %s: Invalid parameters\\n\", __func__);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tlist_for_each_entry(tmp_governor, &devfreq_governor_list, node) {\n\t\tif (!strncmp(tmp_governor->name, name, DEVFREQ_NAME_LEN))\n\t\t\treturn tmp_governor;\n\t}\n\n\treturn ERR_PTR(-ENODEV);\n}\n\n \nstatic struct devfreq_governor *try_then_request_governor(const char *name)\n{\n\tstruct devfreq_governor *governor;\n\tint err = 0;\n\n\tlockdep_assert_held(&devfreq_list_lock);\n\n\tif (IS_ERR_OR_NULL(name)) {\n\t\tpr_err(\"DEVFREQ: %s: Invalid parameters\\n\", __func__);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tgovernor = find_devfreq_governor(name);\n\tif (IS_ERR(governor)) {\n\t\tmutex_unlock(&devfreq_list_lock);\n\n\t\tif (!strncmp(name, DEVFREQ_GOV_SIMPLE_ONDEMAND,\n\t\t\t     DEVFREQ_NAME_LEN))\n\t\t\terr = request_module(\"governor_%s\", \"simpleondemand\");\n\t\telse\n\t\t\terr = request_module(\"governor_%s\", name);\n\t\t \n\t\tmutex_lock(&devfreq_list_lock);\n\t\tif (err)\n\t\t\treturn (err < 0) ? ERR_PTR(err) : ERR_PTR(-EINVAL);\n\n\t\tgovernor = find_devfreq_governor(name);\n\t}\n\n\treturn governor;\n}\n\nstatic int devfreq_notify_transition(struct devfreq *devfreq,\n\t\tstruct devfreq_freqs *freqs, unsigned int state)\n{\n\tif (!devfreq)\n\t\treturn -EINVAL;\n\n\tswitch (state) {\n\tcase DEVFREQ_PRECHANGE:\n\t\tsrcu_notifier_call_chain(&devfreq->transition_notifier_list,\n\t\t\t\tDEVFREQ_PRECHANGE, freqs);\n\t\tbreak;\n\n\tcase DEVFREQ_POSTCHANGE:\n\t\tsrcu_notifier_call_chain(&devfreq->transition_notifier_list,\n\t\t\t\tDEVFREQ_POSTCHANGE, freqs);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int devfreq_set_target(struct devfreq *devfreq, unsigned long new_freq,\n\t\t\t      u32 flags)\n{\n\tstruct devfreq_freqs freqs;\n\tunsigned long cur_freq;\n\tint err = 0;\n\n\tif (devfreq->profile->get_cur_freq)\n\t\tdevfreq->profile->get_cur_freq(devfreq->dev.parent, &cur_freq);\n\telse\n\t\tcur_freq = devfreq->previous_freq;\n\n\tfreqs.old = cur_freq;\n\tfreqs.new = new_freq;\n\tdevfreq_notify_transition(devfreq, &freqs, DEVFREQ_PRECHANGE);\n\n\terr = devfreq->profile->target(devfreq->dev.parent, &new_freq, flags);\n\tif (err) {\n\t\tfreqs.new = cur_freq;\n\t\tdevfreq_notify_transition(devfreq, &freqs, DEVFREQ_POSTCHANGE);\n\t\treturn err;\n\t}\n\n\t \n\tif (trace_devfreq_frequency_enabled() && new_freq != cur_freq)\n\t\ttrace_devfreq_frequency(devfreq, new_freq, cur_freq);\n\n\tfreqs.new = new_freq;\n\tdevfreq_notify_transition(devfreq, &freqs, DEVFREQ_POSTCHANGE);\n\n\tif (devfreq_update_status(devfreq, new_freq))\n\t\tdev_warn(&devfreq->dev,\n\t\t\t \"Couldn't update frequency transition information.\\n\");\n\n\tdevfreq->previous_freq = new_freq;\n\n\tif (devfreq->suspend_freq)\n\t\tdevfreq->resume_freq = new_freq;\n\n\treturn err;\n}\n\n \nint devfreq_update_target(struct devfreq *devfreq, unsigned long freq)\n{\n\tunsigned long min_freq, max_freq;\n\tint err = 0;\n\tu32 flags = 0;\n\n\tlockdep_assert_held(&devfreq->lock);\n\n\tif (!devfreq->governor)\n\t\treturn -EINVAL;\n\n\t \n\terr = devfreq->governor->get_target_freq(devfreq, &freq);\n\tif (err)\n\t\treturn err;\n\tdevfreq_get_freq_range(devfreq, &min_freq, &max_freq);\n\n\tif (freq < min_freq) {\n\t\tfreq = min_freq;\n\t\tflags &= ~DEVFREQ_FLAG_LEAST_UPPER_BOUND;  \n\t}\n\tif (freq > max_freq) {\n\t\tfreq = max_freq;\n\t\tflags |= DEVFREQ_FLAG_LEAST_UPPER_BOUND;  \n\t}\n\n\treturn devfreq_set_target(devfreq, freq, flags);\n}\nEXPORT_SYMBOL(devfreq_update_target);\n\n \n\n \nint update_devfreq(struct devfreq *devfreq)\n{\n\treturn devfreq_update_target(devfreq, 0L);\n}\nEXPORT_SYMBOL(update_devfreq);\n\n \nstatic void devfreq_monitor(struct work_struct *work)\n{\n\tint err;\n\tstruct devfreq *devfreq = container_of(work,\n\t\t\t\t\tstruct devfreq, work.work);\n\n\tmutex_lock(&devfreq->lock);\n\terr = update_devfreq(devfreq);\n\tif (err)\n\t\tdev_err(&devfreq->dev, \"dvfs failed with (%d) error\\n\", err);\n\n\tqueue_delayed_work(devfreq_wq, &devfreq->work,\n\t\t\t\tmsecs_to_jiffies(devfreq->profile->polling_ms));\n\tmutex_unlock(&devfreq->lock);\n\n\ttrace_devfreq_monitor(devfreq);\n}\n\n \nvoid devfreq_monitor_start(struct devfreq *devfreq)\n{\n\tif (IS_SUPPORTED_FLAG(devfreq->governor->flags, IRQ_DRIVEN))\n\t\treturn;\n\n\tswitch (devfreq->profile->timer) {\n\tcase DEVFREQ_TIMER_DEFERRABLE:\n\t\tINIT_DEFERRABLE_WORK(&devfreq->work, devfreq_monitor);\n\t\tbreak;\n\tcase DEVFREQ_TIMER_DELAYED:\n\t\tINIT_DELAYED_WORK(&devfreq->work, devfreq_monitor);\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\tif (devfreq->profile->polling_ms)\n\t\tqueue_delayed_work(devfreq_wq, &devfreq->work,\n\t\t\tmsecs_to_jiffies(devfreq->profile->polling_ms));\n}\nEXPORT_SYMBOL(devfreq_monitor_start);\n\n \nvoid devfreq_monitor_stop(struct devfreq *devfreq)\n{\n\tif (IS_SUPPORTED_FLAG(devfreq->governor->flags, IRQ_DRIVEN))\n\t\treturn;\n\n\tcancel_delayed_work_sync(&devfreq->work);\n}\nEXPORT_SYMBOL(devfreq_monitor_stop);\n\n \nvoid devfreq_monitor_suspend(struct devfreq *devfreq)\n{\n\tmutex_lock(&devfreq->lock);\n\tif (devfreq->stop_polling) {\n\t\tmutex_unlock(&devfreq->lock);\n\t\treturn;\n\t}\n\n\tdevfreq_update_status(devfreq, devfreq->previous_freq);\n\tdevfreq->stop_polling = true;\n\tmutex_unlock(&devfreq->lock);\n\n\tif (IS_SUPPORTED_FLAG(devfreq->governor->flags, IRQ_DRIVEN))\n\t\treturn;\n\n\tcancel_delayed_work_sync(&devfreq->work);\n}\nEXPORT_SYMBOL(devfreq_monitor_suspend);\n\n \nvoid devfreq_monitor_resume(struct devfreq *devfreq)\n{\n\tunsigned long freq;\n\n\tmutex_lock(&devfreq->lock);\n\n\tif (IS_SUPPORTED_FLAG(devfreq->governor->flags, IRQ_DRIVEN))\n\t\tgoto out_update;\n\n\tif (!devfreq->stop_polling)\n\t\tgoto out;\n\n\tif (!delayed_work_pending(&devfreq->work) &&\n\t\t\tdevfreq->profile->polling_ms)\n\t\tqueue_delayed_work(devfreq_wq, &devfreq->work,\n\t\t\tmsecs_to_jiffies(devfreq->profile->polling_ms));\n\nout_update:\n\tdevfreq->stats.last_update = get_jiffies_64();\n\tdevfreq->stop_polling = false;\n\n\tif (devfreq->profile->get_cur_freq &&\n\t\t!devfreq->profile->get_cur_freq(devfreq->dev.parent, &freq))\n\t\tdevfreq->previous_freq = freq;\n\nout:\n\tmutex_unlock(&devfreq->lock);\n}\nEXPORT_SYMBOL(devfreq_monitor_resume);\n\n \nvoid devfreq_update_interval(struct devfreq *devfreq, unsigned int *delay)\n{\n\tunsigned int cur_delay = devfreq->profile->polling_ms;\n\tunsigned int new_delay = *delay;\n\n\tmutex_lock(&devfreq->lock);\n\tdevfreq->profile->polling_ms = new_delay;\n\n\tif (IS_SUPPORTED_FLAG(devfreq->governor->flags, IRQ_DRIVEN))\n\t\tgoto out;\n\n\tif (devfreq->stop_polling)\n\t\tgoto out;\n\n\t \n\tif (!new_delay) {\n\t\tmutex_unlock(&devfreq->lock);\n\t\tcancel_delayed_work_sync(&devfreq->work);\n\t\treturn;\n\t}\n\n\t \n\tif (!cur_delay) {\n\t\tqueue_delayed_work(devfreq_wq, &devfreq->work,\n\t\t\tmsecs_to_jiffies(devfreq->profile->polling_ms));\n\t\tgoto out;\n\t}\n\n\t \n\tif (cur_delay > new_delay) {\n\t\tmutex_unlock(&devfreq->lock);\n\t\tcancel_delayed_work_sync(&devfreq->work);\n\t\tmutex_lock(&devfreq->lock);\n\t\tif (!devfreq->stop_polling)\n\t\t\tqueue_delayed_work(devfreq_wq, &devfreq->work,\n\t\t\t\tmsecs_to_jiffies(devfreq->profile->polling_ms));\n\t}\nout:\n\tmutex_unlock(&devfreq->lock);\n}\nEXPORT_SYMBOL(devfreq_update_interval);\n\n \nstatic int devfreq_notifier_call(struct notifier_block *nb, unsigned long type,\n\t\t\t\t void *devp)\n{\n\tstruct devfreq *devfreq = container_of(nb, struct devfreq, nb);\n\tint err = -EINVAL;\n\n\tmutex_lock(&devfreq->lock);\n\n\tdevfreq->scaling_min_freq = find_available_min_freq(devfreq);\n\tif (!devfreq->scaling_min_freq)\n\t\tgoto out;\n\n\tdevfreq->scaling_max_freq = find_available_max_freq(devfreq);\n\tif (!devfreq->scaling_max_freq) {\n\t\tdevfreq->scaling_max_freq = ULONG_MAX;\n\t\tgoto out;\n\t}\n\n\terr = update_devfreq(devfreq);\n\nout:\n\tmutex_unlock(&devfreq->lock);\n\tif (err)\n\t\tdev_err(devfreq->dev.parent,\n\t\t\t\"failed to update frequency from OPP notifier (%d)\\n\",\n\t\t\terr);\n\n\treturn NOTIFY_OK;\n}\n\n \nstatic int qos_notifier_call(struct devfreq *devfreq)\n{\n\tint err;\n\n\tmutex_lock(&devfreq->lock);\n\terr = update_devfreq(devfreq);\n\tmutex_unlock(&devfreq->lock);\n\tif (err)\n\t\tdev_err(devfreq->dev.parent,\n\t\t\t\"failed to update frequency from PM QoS (%d)\\n\",\n\t\t\terr);\n\n\treturn NOTIFY_OK;\n}\n\n \nstatic int qos_min_notifier_call(struct notifier_block *nb,\n\t\t\t\t\t unsigned long val, void *ptr)\n{\n\treturn qos_notifier_call(container_of(nb, struct devfreq, nb_min));\n}\n\n \nstatic int qos_max_notifier_call(struct notifier_block *nb,\n\t\t\t\t\t unsigned long val, void *ptr)\n{\n\treturn qos_notifier_call(container_of(nb, struct devfreq, nb_max));\n}\n\n \nstatic void devfreq_dev_release(struct device *dev)\n{\n\tstruct devfreq *devfreq = to_devfreq(dev);\n\tint err;\n\n\tmutex_lock(&devfreq_list_lock);\n\tlist_del(&devfreq->node);\n\tmutex_unlock(&devfreq_list_lock);\n\n\terr = dev_pm_qos_remove_notifier(devfreq->dev.parent, &devfreq->nb_max,\n\t\t\t\t\t DEV_PM_QOS_MAX_FREQUENCY);\n\tif (err && err != -ENOENT)\n\t\tdev_warn(dev->parent,\n\t\t\t\"Failed to remove max_freq notifier: %d\\n\", err);\n\terr = dev_pm_qos_remove_notifier(devfreq->dev.parent, &devfreq->nb_min,\n\t\t\t\t\t DEV_PM_QOS_MIN_FREQUENCY);\n\tif (err && err != -ENOENT)\n\t\tdev_warn(dev->parent,\n\t\t\t\"Failed to remove min_freq notifier: %d\\n\", err);\n\n\tif (dev_pm_qos_request_active(&devfreq->user_max_freq_req)) {\n\t\terr = dev_pm_qos_remove_request(&devfreq->user_max_freq_req);\n\t\tif (err < 0)\n\t\t\tdev_warn(dev->parent,\n\t\t\t\t\"Failed to remove max_freq request: %d\\n\", err);\n\t}\n\tif (dev_pm_qos_request_active(&devfreq->user_min_freq_req)) {\n\t\terr = dev_pm_qos_remove_request(&devfreq->user_min_freq_req);\n\t\tif (err < 0)\n\t\t\tdev_warn(dev->parent,\n\t\t\t\t\"Failed to remove min_freq request: %d\\n\", err);\n\t}\n\n\tif (devfreq->profile->exit)\n\t\tdevfreq->profile->exit(devfreq->dev.parent);\n\n\tif (devfreq->opp_table)\n\t\tdev_pm_opp_put_opp_table(devfreq->opp_table);\n\n\tmutex_destroy(&devfreq->lock);\n\tsrcu_cleanup_notifier_head(&devfreq->transition_notifier_list);\n\tkfree(devfreq);\n}\n\nstatic void create_sysfs_files(struct devfreq *devfreq,\n\t\t\t\tconst struct devfreq_governor *gov);\nstatic void remove_sysfs_files(struct devfreq *devfreq,\n\t\t\t\tconst struct devfreq_governor *gov);\n\n \nstruct devfreq *devfreq_add_device(struct device *dev,\n\t\t\t\t   struct devfreq_dev_profile *profile,\n\t\t\t\t   const char *governor_name,\n\t\t\t\t   void *data)\n{\n\tstruct devfreq *devfreq;\n\tstruct devfreq_governor *governor;\n\tunsigned long min_freq, max_freq;\n\tint err = 0;\n\n\tif (!dev || !profile || !governor_name) {\n\t\tdev_err(dev, \"%s: Invalid parameters.\\n\", __func__);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tmutex_lock(&devfreq_list_lock);\n\tdevfreq = find_device_devfreq(dev);\n\tmutex_unlock(&devfreq_list_lock);\n\tif (!IS_ERR(devfreq)) {\n\t\tdev_err(dev, \"%s: devfreq device already exists!\\n\",\n\t\t\t__func__);\n\t\terr = -EINVAL;\n\t\tgoto err_out;\n\t}\n\n\tdevfreq = kzalloc(sizeof(struct devfreq), GFP_KERNEL);\n\tif (!devfreq) {\n\t\terr = -ENOMEM;\n\t\tgoto err_out;\n\t}\n\n\tmutex_init(&devfreq->lock);\n\tmutex_lock(&devfreq->lock);\n\tdevfreq->dev.parent = dev;\n\tdevfreq->dev.class = devfreq_class;\n\tdevfreq->dev.release = devfreq_dev_release;\n\tINIT_LIST_HEAD(&devfreq->node);\n\tdevfreq->profile = profile;\n\tdevfreq->previous_freq = profile->initial_freq;\n\tdevfreq->last_status.current_frequency = profile->initial_freq;\n\tdevfreq->data = data;\n\tdevfreq->nb.notifier_call = devfreq_notifier_call;\n\n\tif (devfreq->profile->timer < 0\n\t\t|| devfreq->profile->timer >= DEVFREQ_TIMER_NUM) {\n\t\tmutex_unlock(&devfreq->lock);\n\t\terr = -EINVAL;\n\t\tgoto err_dev;\n\t}\n\n\tif (!devfreq->profile->max_state || !devfreq->profile->freq_table) {\n\t\tmutex_unlock(&devfreq->lock);\n\t\terr = set_freq_table(devfreq);\n\t\tif (err < 0)\n\t\t\tgoto err_dev;\n\t\tmutex_lock(&devfreq->lock);\n\t} else {\n\t\tdevfreq->freq_table = devfreq->profile->freq_table;\n\t\tdevfreq->max_state = devfreq->profile->max_state;\n\t}\n\n\tdevfreq->scaling_min_freq = find_available_min_freq(devfreq);\n\tif (!devfreq->scaling_min_freq) {\n\t\tmutex_unlock(&devfreq->lock);\n\t\terr = -EINVAL;\n\t\tgoto err_dev;\n\t}\n\n\tdevfreq->scaling_max_freq = find_available_max_freq(devfreq);\n\tif (!devfreq->scaling_max_freq) {\n\t\tmutex_unlock(&devfreq->lock);\n\t\terr = -EINVAL;\n\t\tgoto err_dev;\n\t}\n\n\tdevfreq_get_freq_range(devfreq, &min_freq, &max_freq);\n\n\tdevfreq->suspend_freq = dev_pm_opp_get_suspend_opp_freq(dev);\n\tdevfreq->opp_table = dev_pm_opp_get_opp_table(dev);\n\tif (IS_ERR(devfreq->opp_table))\n\t\tdevfreq->opp_table = NULL;\n\n\tatomic_set(&devfreq->suspend_count, 0);\n\n\tdev_set_name(&devfreq->dev, \"%s\", dev_name(dev));\n\terr = device_register(&devfreq->dev);\n\tif (err) {\n\t\tmutex_unlock(&devfreq->lock);\n\t\tput_device(&devfreq->dev);\n\t\tgoto err_out;\n\t}\n\n\tdevfreq->stats.trans_table = devm_kzalloc(&devfreq->dev,\n\t\t\tarray3_size(sizeof(unsigned int),\n\t\t\t\t    devfreq->max_state,\n\t\t\t\t    devfreq->max_state),\n\t\t\tGFP_KERNEL);\n\tif (!devfreq->stats.trans_table) {\n\t\tmutex_unlock(&devfreq->lock);\n\t\terr = -ENOMEM;\n\t\tgoto err_devfreq;\n\t}\n\n\tdevfreq->stats.time_in_state = devm_kcalloc(&devfreq->dev,\n\t\t\tdevfreq->max_state,\n\t\t\tsizeof(*devfreq->stats.time_in_state),\n\t\t\tGFP_KERNEL);\n\tif (!devfreq->stats.time_in_state) {\n\t\tmutex_unlock(&devfreq->lock);\n\t\terr = -ENOMEM;\n\t\tgoto err_devfreq;\n\t}\n\n\tdevfreq->stats.total_trans = 0;\n\tdevfreq->stats.last_update = get_jiffies_64();\n\n\tsrcu_init_notifier_head(&devfreq->transition_notifier_list);\n\n\tmutex_unlock(&devfreq->lock);\n\n\terr = dev_pm_qos_add_request(dev, &devfreq->user_min_freq_req,\n\t\t\t\t     DEV_PM_QOS_MIN_FREQUENCY, 0);\n\tif (err < 0)\n\t\tgoto err_devfreq;\n\terr = dev_pm_qos_add_request(dev, &devfreq->user_max_freq_req,\n\t\t\t\t     DEV_PM_QOS_MAX_FREQUENCY,\n\t\t\t\t     PM_QOS_MAX_FREQUENCY_DEFAULT_VALUE);\n\tif (err < 0)\n\t\tgoto err_devfreq;\n\n\tdevfreq->nb_min.notifier_call = qos_min_notifier_call;\n\terr = dev_pm_qos_add_notifier(dev, &devfreq->nb_min,\n\t\t\t\t      DEV_PM_QOS_MIN_FREQUENCY);\n\tif (err)\n\t\tgoto err_devfreq;\n\n\tdevfreq->nb_max.notifier_call = qos_max_notifier_call;\n\terr = dev_pm_qos_add_notifier(dev, &devfreq->nb_max,\n\t\t\t\t      DEV_PM_QOS_MAX_FREQUENCY);\n\tif (err)\n\t\tgoto err_devfreq;\n\n\tmutex_lock(&devfreq_list_lock);\n\n\tgovernor = try_then_request_governor(governor_name);\n\tif (IS_ERR(governor)) {\n\t\tdev_err(dev, \"%s: Unable to find governor for the device\\n\",\n\t\t\t__func__);\n\t\terr = PTR_ERR(governor);\n\t\tgoto err_init;\n\t}\n\n\tdevfreq->governor = governor;\n\terr = devfreq->governor->event_handler(devfreq, DEVFREQ_GOV_START,\n\t\t\t\t\t\tNULL);\n\tif (err) {\n\t\tdev_err_probe(dev, err,\n\t\t\t\"%s: Unable to start governor for the device\\n\",\n\t\t\t __func__);\n\t\tgoto err_init;\n\t}\n\tcreate_sysfs_files(devfreq, devfreq->governor);\n\n\tlist_add(&devfreq->node, &devfreq_list);\n\n\tmutex_unlock(&devfreq_list_lock);\n\n\tif (devfreq->profile->is_cooling_device) {\n\t\tdevfreq->cdev = devfreq_cooling_em_register(devfreq, NULL);\n\t\tif (IS_ERR(devfreq->cdev))\n\t\t\tdevfreq->cdev = NULL;\n\t}\n\n\treturn devfreq;\n\nerr_init:\n\tmutex_unlock(&devfreq_list_lock);\nerr_devfreq:\n\tdevfreq_remove_device(devfreq);\n\tdevfreq = NULL;\nerr_dev:\n\tkfree(devfreq);\nerr_out:\n\treturn ERR_PTR(err);\n}\nEXPORT_SYMBOL(devfreq_add_device);\n\n \nint devfreq_remove_device(struct devfreq *devfreq)\n{\n\tif (!devfreq)\n\t\treturn -EINVAL;\n\n\tdevfreq_cooling_unregister(devfreq->cdev);\n\n\tif (devfreq->governor) {\n\t\tdevfreq->governor->event_handler(devfreq,\n\t\t\t\t\t\t DEVFREQ_GOV_STOP, NULL);\n\t\tremove_sysfs_files(devfreq, devfreq->governor);\n\t}\n\n\tdevice_unregister(&devfreq->dev);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(devfreq_remove_device);\n\nstatic int devm_devfreq_dev_match(struct device *dev, void *res, void *data)\n{\n\tstruct devfreq **r = res;\n\n\tif (WARN_ON(!r || !*r))\n\t\treturn 0;\n\n\treturn *r == data;\n}\n\nstatic void devm_devfreq_dev_release(struct device *dev, void *res)\n{\n\tdevfreq_remove_device(*(struct devfreq **)res);\n}\n\n \nstruct devfreq *devm_devfreq_add_device(struct device *dev,\n\t\t\t\t\tstruct devfreq_dev_profile *profile,\n\t\t\t\t\tconst char *governor_name,\n\t\t\t\t\tvoid *data)\n{\n\tstruct devfreq **ptr, *devfreq;\n\n\tptr = devres_alloc(devm_devfreq_dev_release, sizeof(*ptr), GFP_KERNEL);\n\tif (!ptr)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tdevfreq = devfreq_add_device(dev, profile, governor_name, data);\n\tif (IS_ERR(devfreq)) {\n\t\tdevres_free(ptr);\n\t\treturn devfreq;\n\t}\n\n\t*ptr = devfreq;\n\tdevres_add(dev, ptr);\n\n\treturn devfreq;\n}\nEXPORT_SYMBOL(devm_devfreq_add_device);\n\n#ifdef CONFIG_OF\n \nstruct devfreq *devfreq_get_devfreq_by_node(struct device_node *node)\n{\n\tstruct devfreq *devfreq;\n\n\tif (!node)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tmutex_lock(&devfreq_list_lock);\n\tlist_for_each_entry(devfreq, &devfreq_list, node) {\n\t\tif (devfreq->dev.parent\n\t\t\t&& device_match_of_node(devfreq->dev.parent, node)) {\n\t\t\tmutex_unlock(&devfreq_list_lock);\n\t\t\treturn devfreq;\n\t\t}\n\t}\n\tmutex_unlock(&devfreq_list_lock);\n\n\treturn ERR_PTR(-ENODEV);\n}\n\n \nstruct devfreq *devfreq_get_devfreq_by_phandle(struct device *dev,\n\t\t\t\t\tconst char *phandle_name, int index)\n{\n\tstruct device_node *node;\n\tstruct devfreq *devfreq;\n\n\tif (!dev || !phandle_name)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (!dev->of_node)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tnode = of_parse_phandle(dev->of_node, phandle_name, index);\n\tif (!node)\n\t\treturn ERR_PTR(-ENODEV);\n\n\tdevfreq = devfreq_get_devfreq_by_node(node);\n\tof_node_put(node);\n\n\treturn devfreq;\n}\n\n#else\nstruct devfreq *devfreq_get_devfreq_by_node(struct device_node *node)\n{\n\treturn ERR_PTR(-ENODEV);\n}\n\nstruct devfreq *devfreq_get_devfreq_by_phandle(struct device *dev,\n\t\t\t\t\tconst char *phandle_name, int index)\n{\n\treturn ERR_PTR(-ENODEV);\n}\n#endif  \nEXPORT_SYMBOL_GPL(devfreq_get_devfreq_by_node);\nEXPORT_SYMBOL_GPL(devfreq_get_devfreq_by_phandle);\n\n \nvoid devm_devfreq_remove_device(struct device *dev, struct devfreq *devfreq)\n{\n\tWARN_ON(devres_release(dev, devm_devfreq_dev_release,\n\t\t\t       devm_devfreq_dev_match, devfreq));\n}\nEXPORT_SYMBOL(devm_devfreq_remove_device);\n\n \nint devfreq_suspend_device(struct devfreq *devfreq)\n{\n\tint ret;\n\n\tif (!devfreq)\n\t\treturn -EINVAL;\n\n\tif (atomic_inc_return(&devfreq->suspend_count) > 1)\n\t\treturn 0;\n\n\tif (devfreq->governor) {\n\t\tret = devfreq->governor->event_handler(devfreq,\n\t\t\t\t\tDEVFREQ_GOV_SUSPEND, NULL);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (devfreq->suspend_freq) {\n\t\tmutex_lock(&devfreq->lock);\n\t\tret = devfreq_set_target(devfreq, devfreq->suspend_freq, 0);\n\t\tmutex_unlock(&devfreq->lock);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(devfreq_suspend_device);\n\n \nint devfreq_resume_device(struct devfreq *devfreq)\n{\n\tint ret;\n\n\tif (!devfreq)\n\t\treturn -EINVAL;\n\n\tif (atomic_dec_return(&devfreq->suspend_count) >= 1)\n\t\treturn 0;\n\n\tif (devfreq->resume_freq) {\n\t\tmutex_lock(&devfreq->lock);\n\t\tret = devfreq_set_target(devfreq, devfreq->resume_freq, 0);\n\t\tmutex_unlock(&devfreq->lock);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (devfreq->governor) {\n\t\tret = devfreq->governor->event_handler(devfreq,\n\t\t\t\t\tDEVFREQ_GOV_RESUME, NULL);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(devfreq_resume_device);\n\n \nvoid devfreq_suspend(void)\n{\n\tstruct devfreq *devfreq;\n\tint ret;\n\n\tmutex_lock(&devfreq_list_lock);\n\tlist_for_each_entry(devfreq, &devfreq_list, node) {\n\t\tret = devfreq_suspend_device(devfreq);\n\t\tif (ret)\n\t\t\tdev_err(&devfreq->dev,\n\t\t\t\t\"failed to suspend devfreq device\\n\");\n\t}\n\tmutex_unlock(&devfreq_list_lock);\n}\n\n \nvoid devfreq_resume(void)\n{\n\tstruct devfreq *devfreq;\n\tint ret;\n\n\tmutex_lock(&devfreq_list_lock);\n\tlist_for_each_entry(devfreq, &devfreq_list, node) {\n\t\tret = devfreq_resume_device(devfreq);\n\t\tif (ret)\n\t\t\tdev_warn(&devfreq->dev,\n\t\t\t\t \"failed to resume devfreq device\\n\");\n\t}\n\tmutex_unlock(&devfreq_list_lock);\n}\n\n \nint devfreq_add_governor(struct devfreq_governor *governor)\n{\n\tstruct devfreq_governor *g;\n\tstruct devfreq *devfreq;\n\tint err = 0;\n\n\tif (!governor) {\n\t\tpr_err(\"%s: Invalid parameters.\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&devfreq_list_lock);\n\tg = find_devfreq_governor(governor->name);\n\tif (!IS_ERR(g)) {\n\t\tpr_err(\"%s: governor %s already registered\\n\", __func__,\n\t\t       g->name);\n\t\terr = -EINVAL;\n\t\tgoto err_out;\n\t}\n\n\tlist_add(&governor->node, &devfreq_governor_list);\n\n\tlist_for_each_entry(devfreq, &devfreq_list, node) {\n\t\tint ret = 0;\n\t\tstruct device *dev = devfreq->dev.parent;\n\n\t\tif (!strncmp(devfreq->governor->name, governor->name,\n\t\t\t     DEVFREQ_NAME_LEN)) {\n\t\t\t \n\t\t\tif (devfreq->governor) {\n\t\t\t\tdev_warn(dev,\n\t\t\t\t\t \"%s: Governor %s already present\\n\",\n\t\t\t\t\t __func__, devfreq->governor->name);\n\t\t\t\tret = devfreq->governor->event_handler(devfreq,\n\t\t\t\t\t\t\tDEVFREQ_GOV_STOP, NULL);\n\t\t\t\tif (ret) {\n\t\t\t\t\tdev_warn(dev,\n\t\t\t\t\t\t \"%s: Governor %s stop = %d\\n\",\n\t\t\t\t\t\t __func__,\n\t\t\t\t\t\t devfreq->governor->name, ret);\n\t\t\t\t}\n\t\t\t\t \n\t\t\t}\n\t\t\tdevfreq->governor = governor;\n\t\t\tret = devfreq->governor->event_handler(devfreq,\n\t\t\t\t\t\tDEVFREQ_GOV_START, NULL);\n\t\t\tif (ret) {\n\t\t\t\tdev_warn(dev, \"%s: Governor %s start=%d\\n\",\n\t\t\t\t\t __func__, devfreq->governor->name,\n\t\t\t\t\t ret);\n\t\t\t}\n\t\t}\n\t}\n\nerr_out:\n\tmutex_unlock(&devfreq_list_lock);\n\n\treturn err;\n}\nEXPORT_SYMBOL(devfreq_add_governor);\n\nstatic void devm_devfreq_remove_governor(void *governor)\n{\n\tWARN_ON(devfreq_remove_governor(governor));\n}\n\n \nint devm_devfreq_add_governor(struct device *dev,\n\t\t\t      struct devfreq_governor *governor)\n{\n\tint err;\n\n\terr = devfreq_add_governor(governor);\n\tif (err)\n\t\treturn err;\n\n\treturn devm_add_action_or_reset(dev, devm_devfreq_remove_governor,\n\t\t\t\t\tgovernor);\n}\nEXPORT_SYMBOL(devm_devfreq_add_governor);\n\n \nint devfreq_remove_governor(struct devfreq_governor *governor)\n{\n\tstruct devfreq_governor *g;\n\tstruct devfreq *devfreq;\n\tint err = 0;\n\n\tif (!governor) {\n\t\tpr_err(\"%s: Invalid parameters.\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&devfreq_list_lock);\n\tg = find_devfreq_governor(governor->name);\n\tif (IS_ERR(g)) {\n\t\tpr_err(\"%s: governor %s not registered\\n\", __func__,\n\t\t       governor->name);\n\t\terr = PTR_ERR(g);\n\t\tgoto err_out;\n\t}\n\tlist_for_each_entry(devfreq, &devfreq_list, node) {\n\t\tint ret;\n\t\tstruct device *dev = devfreq->dev.parent;\n\n\t\tif (!strncmp(devfreq->governor->name, governor->name,\n\t\t\t     DEVFREQ_NAME_LEN)) {\n\t\t\t \n\t\t\tif (!devfreq->governor) {\n\t\t\t\tdev_warn(dev, \"%s: Governor %s NOT present\\n\",\n\t\t\t\t\t __func__, governor->name);\n\t\t\t\tcontinue;\n\t\t\t\t \n\t\t\t}\n\t\t\tret = devfreq->governor->event_handler(devfreq,\n\t\t\t\t\t\tDEVFREQ_GOV_STOP, NULL);\n\t\t\tif (ret) {\n\t\t\t\tdev_warn(dev, \"%s: Governor %s stop=%d\\n\",\n\t\t\t\t\t __func__, devfreq->governor->name,\n\t\t\t\t\t ret);\n\t\t\t}\n\t\t\tdevfreq->governor = NULL;\n\t\t}\n\t}\n\n\tlist_del(&governor->node);\nerr_out:\n\tmutex_unlock(&devfreq_list_lock);\n\n\treturn err;\n}\nEXPORT_SYMBOL(devfreq_remove_governor);\n\nstatic ssize_t name_show(struct device *dev,\n\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct devfreq *df = to_devfreq(dev);\n\treturn sprintf(buf, \"%s\\n\", dev_name(df->dev.parent));\n}\nstatic DEVICE_ATTR_RO(name);\n\nstatic ssize_t governor_show(struct device *dev,\n\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tstruct devfreq *df = to_devfreq(dev);\n\n\tif (!df->governor)\n\t\treturn -EINVAL;\n\n\treturn sprintf(buf, \"%s\\n\", df->governor->name);\n}\n\nstatic ssize_t governor_store(struct device *dev, struct device_attribute *attr,\n\t\t\t      const char *buf, size_t count)\n{\n\tstruct devfreq *df = to_devfreq(dev);\n\tint ret;\n\tchar str_governor[DEVFREQ_NAME_LEN + 1];\n\tconst struct devfreq_governor *governor, *prev_governor;\n\n\tif (!df->governor)\n\t\treturn -EINVAL;\n\n\tret = sscanf(buf, \"%\" __stringify(DEVFREQ_NAME_LEN) \"s\", str_governor);\n\tif (ret != 1)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&devfreq_list_lock);\n\tgovernor = try_then_request_governor(str_governor);\n\tif (IS_ERR(governor)) {\n\t\tret = PTR_ERR(governor);\n\t\tgoto out;\n\t}\n\tif (df->governor == governor) {\n\t\tret = 0;\n\t\tgoto out;\n\t} else if (IS_SUPPORTED_FLAG(df->governor->flags, IMMUTABLE)\n\t\t|| IS_SUPPORTED_FLAG(governor->flags, IMMUTABLE)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t \n\tret = df->governor->event_handler(df, DEVFREQ_GOV_STOP, NULL);\n\tif (ret) {\n\t\tdev_warn(dev, \"%s: Governor %s not stopped(%d)\\n\",\n\t\t\t __func__, df->governor->name, ret);\n\t\tgoto out;\n\t}\n\tremove_sysfs_files(df, df->governor);\n\n\t \n\tprev_governor = df->governor;\n\tdf->governor = governor;\n\tret = df->governor->event_handler(df, DEVFREQ_GOV_START, NULL);\n\tif (ret) {\n\t\tdev_warn(dev, \"%s: Governor %s not started(%d)\\n\",\n\t\t\t __func__, df->governor->name, ret);\n\n\t\t \n\t\tdf->governor = prev_governor;\n\t\tret = df->governor->event_handler(df, DEVFREQ_GOV_START, NULL);\n\t\tif (ret) {\n\t\t\tdev_err(dev,\n\t\t\t\t\"%s: reverting to Governor %s failed (%d)\\n\",\n\t\t\t\t__func__, prev_governor->name, ret);\n\t\t\tdf->governor = NULL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t \n\tcreate_sysfs_files(df, df->governor);\n\nout:\n\tmutex_unlock(&devfreq_list_lock);\n\n\tif (!ret)\n\t\tret = count;\n\treturn ret;\n}\nstatic DEVICE_ATTR_RW(governor);\n\nstatic ssize_t available_governors_show(struct device *d,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tchar *buf)\n{\n\tstruct devfreq *df = to_devfreq(d);\n\tssize_t count = 0;\n\n\tif (!df->governor)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&devfreq_list_lock);\n\n\t \n\tif (IS_SUPPORTED_FLAG(df->governor->flags, IMMUTABLE)) {\n\t\tcount = scnprintf(&buf[count], DEVFREQ_NAME_LEN,\n\t\t\t\t  \"%s \", df->governor->name);\n\t \n\t} else {\n\t\tstruct devfreq_governor *governor;\n\n\t\tlist_for_each_entry(governor, &devfreq_governor_list, node) {\n\t\t\tif (IS_SUPPORTED_FLAG(governor->flags, IMMUTABLE))\n\t\t\t\tcontinue;\n\t\t\tcount += scnprintf(&buf[count], (PAGE_SIZE - count - 2),\n\t\t\t\t\t   \"%s \", governor->name);\n\t\t}\n\t}\n\n\tmutex_unlock(&devfreq_list_lock);\n\n\t \n\tif (count)\n\t\tcount--;\n\n\tcount += sprintf(&buf[count], \"\\n\");\n\n\treturn count;\n}\nstatic DEVICE_ATTR_RO(available_governors);\n\nstatic ssize_t cur_freq_show(struct device *dev, struct device_attribute *attr,\n\t\t\t     char *buf)\n{\n\tunsigned long freq;\n\tstruct devfreq *df = to_devfreq(dev);\n\n\tif (!df->profile)\n\t\treturn -EINVAL;\n\n\tif (df->profile->get_cur_freq &&\n\t\t!df->profile->get_cur_freq(df->dev.parent, &freq))\n\t\treturn sprintf(buf, \"%lu\\n\", freq);\n\n\treturn sprintf(buf, \"%lu\\n\", df->previous_freq);\n}\nstatic DEVICE_ATTR_RO(cur_freq);\n\nstatic ssize_t target_freq_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct devfreq *df = to_devfreq(dev);\n\n\treturn sprintf(buf, \"%lu\\n\", df->previous_freq);\n}\nstatic DEVICE_ATTR_RO(target_freq);\n\nstatic ssize_t min_freq_store(struct device *dev, struct device_attribute *attr,\n\t\t\t      const char *buf, size_t count)\n{\n\tstruct devfreq *df = to_devfreq(dev);\n\tunsigned long value;\n\tint ret;\n\n\t \n\tif (!dev_pm_qos_request_active(&df->user_min_freq_req))\n\t\treturn -EAGAIN;\n\n\tret = sscanf(buf, \"%lu\", &value);\n\tif (ret != 1)\n\t\treturn -EINVAL;\n\n\t \n\tret = dev_pm_qos_update_request(&df->user_min_freq_req,\n\t\t\t\t\tvalue / HZ_PER_KHZ);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn count;\n}\n\nstatic ssize_t min_freq_show(struct device *dev, struct device_attribute *attr,\n\t\t\t     char *buf)\n{\n\tstruct devfreq *df = to_devfreq(dev);\n\tunsigned long min_freq, max_freq;\n\n\tmutex_lock(&df->lock);\n\tdevfreq_get_freq_range(df, &min_freq, &max_freq);\n\tmutex_unlock(&df->lock);\n\n\treturn sprintf(buf, \"%lu\\n\", min_freq);\n}\nstatic DEVICE_ATTR_RW(min_freq);\n\nstatic ssize_t max_freq_store(struct device *dev, struct device_attribute *attr,\n\t\t\t      const char *buf, size_t count)\n{\n\tstruct devfreq *df = to_devfreq(dev);\n\tunsigned long value;\n\tint ret;\n\n\t \n\tif (!dev_pm_qos_request_active(&df->user_max_freq_req))\n\t\treturn -EINVAL;\n\n\tret = sscanf(buf, \"%lu\", &value);\n\tif (ret != 1)\n\t\treturn -EINVAL;\n\n\t \n\tif (value)\n\t\tvalue = DIV_ROUND_UP(value, HZ_PER_KHZ);\n\telse\n\t\tvalue = PM_QOS_MAX_FREQUENCY_DEFAULT_VALUE;\n\n\tret = dev_pm_qos_update_request(&df->user_max_freq_req, value);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn count;\n}\n\nstatic ssize_t max_freq_show(struct device *dev, struct device_attribute *attr,\n\t\t\t     char *buf)\n{\n\tstruct devfreq *df = to_devfreq(dev);\n\tunsigned long min_freq, max_freq;\n\n\tmutex_lock(&df->lock);\n\tdevfreq_get_freq_range(df, &min_freq, &max_freq);\n\tmutex_unlock(&df->lock);\n\n\treturn sprintf(buf, \"%lu\\n\", max_freq);\n}\nstatic DEVICE_ATTR_RW(max_freq);\n\nstatic ssize_t available_frequencies_show(struct device *d,\n\t\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t\t  char *buf)\n{\n\tstruct devfreq *df = to_devfreq(d);\n\tssize_t count = 0;\n\tint i;\n\n\tif (!df->profile)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&df->lock);\n\n\tfor (i = 0; i < df->max_state; i++)\n\t\tcount += scnprintf(&buf[count], (PAGE_SIZE - count - 2),\n\t\t\t\t\"%lu \", df->freq_table[i]);\n\n\tmutex_unlock(&df->lock);\n\t \n\tif (count)\n\t\tcount--;\n\n\tcount += sprintf(&buf[count], \"\\n\");\n\n\treturn count;\n}\nstatic DEVICE_ATTR_RO(available_frequencies);\n\nstatic ssize_t trans_stat_show(struct device *dev,\n\t\t\t       struct device_attribute *attr, char *buf)\n{\n\tstruct devfreq *df = to_devfreq(dev);\n\tssize_t len;\n\tint i, j;\n\tunsigned int max_state;\n\n\tif (!df->profile)\n\t\treturn -EINVAL;\n\tmax_state = df->max_state;\n\n\tif (max_state == 0)\n\t\treturn sprintf(buf, \"Not Supported.\\n\");\n\n\tmutex_lock(&df->lock);\n\tif (!df->stop_polling &&\n\t\t\tdevfreq_update_status(df, df->previous_freq)) {\n\t\tmutex_unlock(&df->lock);\n\t\treturn 0;\n\t}\n\tmutex_unlock(&df->lock);\n\n\tlen = sprintf(buf, \"     From  :   To\\n\");\n\tlen += sprintf(buf + len, \"           :\");\n\tfor (i = 0; i < max_state; i++)\n\t\tlen += sprintf(buf + len, \"%10lu\",\n\t\t\t\tdf->freq_table[i]);\n\n\tlen += sprintf(buf + len, \"   time(ms)\\n\");\n\n\tfor (i = 0; i < max_state; i++) {\n\t\tif (df->freq_table[i] == df->previous_freq)\n\t\t\tlen += sprintf(buf + len, \"*\");\n\t\telse\n\t\t\tlen += sprintf(buf + len, \" \");\n\n\t\tlen += sprintf(buf + len, \"%10lu:\", df->freq_table[i]);\n\t\tfor (j = 0; j < max_state; j++)\n\t\t\tlen += sprintf(buf + len, \"%10u\",\n\t\t\t\tdf->stats.trans_table[(i * max_state) + j]);\n\n\t\tlen += sprintf(buf + len, \"%10llu\\n\", (u64)\n\t\t\tjiffies64_to_msecs(df->stats.time_in_state[i]));\n\t}\n\n\tlen += sprintf(buf + len, \"Total transition : %u\\n\",\n\t\t\t\t\tdf->stats.total_trans);\n\treturn len;\n}\n\nstatic ssize_t trans_stat_store(struct device *dev,\n\t\t\t\tstruct device_attribute *attr,\n\t\t\t\tconst char *buf, size_t count)\n{\n\tstruct devfreq *df = to_devfreq(dev);\n\tint err, value;\n\n\tif (!df->profile)\n\t\treturn -EINVAL;\n\n\tif (df->max_state == 0)\n\t\treturn count;\n\n\terr = kstrtoint(buf, 10, &value);\n\tif (err || value != 0)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&df->lock);\n\tmemset(df->stats.time_in_state, 0, (df->max_state *\n\t\t\t\t\tsizeof(*df->stats.time_in_state)));\n\tmemset(df->stats.trans_table, 0, array3_size(sizeof(unsigned int),\n\t\t\t\t\tdf->max_state,\n\t\t\t\t\tdf->max_state));\n\tdf->stats.total_trans = 0;\n\tdf->stats.last_update = get_jiffies_64();\n\tmutex_unlock(&df->lock);\n\n\treturn count;\n}\nstatic DEVICE_ATTR_RW(trans_stat);\n\nstatic struct attribute *devfreq_attrs[] = {\n\t&dev_attr_name.attr,\n\t&dev_attr_governor.attr,\n\t&dev_attr_available_governors.attr,\n\t&dev_attr_cur_freq.attr,\n\t&dev_attr_available_frequencies.attr,\n\t&dev_attr_target_freq.attr,\n\t&dev_attr_min_freq.attr,\n\t&dev_attr_max_freq.attr,\n\t&dev_attr_trans_stat.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(devfreq);\n\nstatic ssize_t polling_interval_show(struct device *dev,\n\t\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tstruct devfreq *df = to_devfreq(dev);\n\n\tif (!df->profile)\n\t\treturn -EINVAL;\n\n\treturn sprintf(buf, \"%d\\n\", df->profile->polling_ms);\n}\n\nstatic ssize_t polling_interval_store(struct device *dev,\n\t\t\t\t      struct device_attribute *attr,\n\t\t\t\t      const char *buf, size_t count)\n{\n\tstruct devfreq *df = to_devfreq(dev);\n\tunsigned int value;\n\tint ret;\n\n\tif (!df->governor)\n\t\treturn -EINVAL;\n\n\tret = sscanf(buf, \"%u\", &value);\n\tif (ret != 1)\n\t\treturn -EINVAL;\n\n\tdf->governor->event_handler(df, DEVFREQ_GOV_UPDATE_INTERVAL, &value);\n\tret = count;\n\n\treturn ret;\n}\nstatic DEVICE_ATTR_RW(polling_interval);\n\nstatic ssize_t timer_show(struct device *dev,\n\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tstruct devfreq *df = to_devfreq(dev);\n\n\tif (!df->profile)\n\t\treturn -EINVAL;\n\n\treturn sprintf(buf, \"%s\\n\", timer_name[df->profile->timer]);\n}\n\nstatic ssize_t timer_store(struct device *dev, struct device_attribute *attr,\n\t\t\t      const char *buf, size_t count)\n{\n\tstruct devfreq *df = to_devfreq(dev);\n\tchar str_timer[DEVFREQ_NAME_LEN + 1];\n\tint timer = -1;\n\tint ret = 0, i;\n\n\tif (!df->governor || !df->profile)\n\t\treturn -EINVAL;\n\n\tret = sscanf(buf, \"%16s\", str_timer);\n\tif (ret != 1)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < DEVFREQ_TIMER_NUM; i++) {\n\t\tif (!strncmp(timer_name[i], str_timer, DEVFREQ_NAME_LEN)) {\n\t\t\ttimer = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (timer < 0) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (df->profile->timer == timer) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tmutex_lock(&df->lock);\n\tdf->profile->timer = timer;\n\tmutex_unlock(&df->lock);\n\n\tret = df->governor->event_handler(df, DEVFREQ_GOV_STOP, NULL);\n\tif (ret) {\n\t\tdev_warn(dev, \"%s: Governor %s not stopped(%d)\\n\",\n\t\t\t __func__, df->governor->name, ret);\n\t\tgoto out;\n\t}\n\n\tret = df->governor->event_handler(df, DEVFREQ_GOV_START, NULL);\n\tif (ret)\n\t\tdev_warn(dev, \"%s: Governor %s not started(%d)\\n\",\n\t\t\t __func__, df->governor->name, ret);\nout:\n\treturn ret ? ret : count;\n}\nstatic DEVICE_ATTR_RW(timer);\n\n#define CREATE_SYSFS_FILE(df, name)\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tint ret;\t\t\t\t\t\t\t\\\n\tret = sysfs_create_file(&df->dev.kobj, &dev_attr_##name.attr);\t\\\n\tif (ret < 0) {\t\t\t\t\t\t\t\\\n\t\tdev_warn(&df->dev,\t\t\t\t\t\\\n\t\t\t\"Unable to create attr(%s)\\n\", \"##name\");\t\\\n\t}\t\t\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\n\n \nstatic void create_sysfs_files(struct devfreq *devfreq,\n\t\t\t\tconst struct devfreq_governor *gov)\n{\n\tif (IS_SUPPORTED_ATTR(gov->attrs, POLLING_INTERVAL))\n\t\tCREATE_SYSFS_FILE(devfreq, polling_interval);\n\tif (IS_SUPPORTED_ATTR(gov->attrs, TIMER))\n\t\tCREATE_SYSFS_FILE(devfreq, timer);\n}\n\n \nstatic void remove_sysfs_files(struct devfreq *devfreq,\n\t\t\t\tconst struct devfreq_governor *gov)\n{\n\tif (IS_SUPPORTED_ATTR(gov->attrs, POLLING_INTERVAL))\n\t\tsysfs_remove_file(&devfreq->dev.kobj,\n\t\t\t\t&dev_attr_polling_interval.attr);\n\tif (IS_SUPPORTED_ATTR(gov->attrs, TIMER))\n\t\tsysfs_remove_file(&devfreq->dev.kobj, &dev_attr_timer.attr);\n}\n\n \nstatic int devfreq_summary_show(struct seq_file *s, void *data)\n{\n\tstruct devfreq *devfreq;\n\tstruct devfreq *p_devfreq = NULL;\n\tunsigned long cur_freq, min_freq, max_freq;\n\tunsigned int polling_ms;\n\tunsigned int timer;\n\n\tseq_printf(s, \"%-30s %-30s %-15s %-10s %10s %12s %12s %12s\\n\",\n\t\t\t\"dev\",\n\t\t\t\"parent_dev\",\n\t\t\t\"governor\",\n\t\t\t\"timer\",\n\t\t\t\"polling_ms\",\n\t\t\t\"cur_freq_Hz\",\n\t\t\t\"min_freq_Hz\",\n\t\t\t\"max_freq_Hz\");\n\tseq_printf(s, \"%30s %30s %15s %10s %10s %12s %12s %12s\\n\",\n\t\t\t\"------------------------------\",\n\t\t\t\"------------------------------\",\n\t\t\t\"---------------\",\n\t\t\t\"----------\",\n\t\t\t\"----------\",\n\t\t\t\"------------\",\n\t\t\t\"------------\",\n\t\t\t\"------------\");\n\n\tmutex_lock(&devfreq_list_lock);\n\n\tlist_for_each_entry_reverse(devfreq, &devfreq_list, node) {\n#if IS_ENABLED(CONFIG_DEVFREQ_GOV_PASSIVE)\n\t\tif (!strncmp(devfreq->governor->name, DEVFREQ_GOV_PASSIVE,\n\t\t\t\t\t\t\tDEVFREQ_NAME_LEN)) {\n\t\t\tstruct devfreq_passive_data *data = devfreq->data;\n\n\t\t\tif (data)\n\t\t\t\tp_devfreq = data->parent;\n\t\t} else {\n\t\t\tp_devfreq = NULL;\n\t\t}\n#endif\n\n\t\tmutex_lock(&devfreq->lock);\n\t\tcur_freq = devfreq->previous_freq;\n\t\tdevfreq_get_freq_range(devfreq, &min_freq, &max_freq);\n\t\ttimer = devfreq->profile->timer;\n\n\t\tif (IS_SUPPORTED_ATTR(devfreq->governor->attrs, POLLING_INTERVAL))\n\t\t\tpolling_ms = devfreq->profile->polling_ms;\n\t\telse\n\t\t\tpolling_ms = 0;\n\t\tmutex_unlock(&devfreq->lock);\n\n\t\tseq_printf(s,\n\t\t\t\"%-30s %-30s %-15s %-10s %10d %12ld %12ld %12ld\\n\",\n\t\t\tdev_name(&devfreq->dev),\n\t\t\tp_devfreq ? dev_name(&p_devfreq->dev) : \"null\",\n\t\t\tdevfreq->governor->name,\n\t\t\tpolling_ms ? timer_name[timer] : \"null\",\n\t\t\tpolling_ms,\n\t\t\tcur_freq,\n\t\t\tmin_freq,\n\t\t\tmax_freq);\n\t}\n\n\tmutex_unlock(&devfreq_list_lock);\n\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(devfreq_summary);\n\nstatic int __init devfreq_init(void)\n{\n\tdevfreq_class = class_create(\"devfreq\");\n\tif (IS_ERR(devfreq_class)) {\n\t\tpr_err(\"%s: couldn't create class\\n\", __FILE__);\n\t\treturn PTR_ERR(devfreq_class);\n\t}\n\n\tdevfreq_wq = create_freezable_workqueue(\"devfreq_wq\");\n\tif (!devfreq_wq) {\n\t\tclass_destroy(devfreq_class);\n\t\tpr_err(\"%s: couldn't create workqueue\\n\", __FILE__);\n\t\treturn -ENOMEM;\n\t}\n\tdevfreq_class->dev_groups = devfreq_groups;\n\n\tdevfreq_debugfs = debugfs_create_dir(\"devfreq\", NULL);\n\tdebugfs_create_file(\"devfreq_summary\", 0444,\n\t\t\t\tdevfreq_debugfs, NULL,\n\t\t\t\t&devfreq_summary_fops);\n\n\treturn 0;\n}\nsubsys_initcall(devfreq_init);\n\n \n\n \nstruct dev_pm_opp *devfreq_recommended_opp(struct device *dev,\n\t\t\t\t\t   unsigned long *freq,\n\t\t\t\t\t   u32 flags)\n{\n\tstruct dev_pm_opp *opp;\n\n\tif (flags & DEVFREQ_FLAG_LEAST_UPPER_BOUND) {\n\t\t \n\t\topp = dev_pm_opp_find_freq_floor(dev, freq);\n\n\t\t \n\t\tif (opp == ERR_PTR(-ERANGE))\n\t\t\topp = dev_pm_opp_find_freq_ceil(dev, freq);\n\t} else {\n\t\t \n\t\topp = dev_pm_opp_find_freq_ceil(dev, freq);\n\n\t\t \n\t\tif (opp == ERR_PTR(-ERANGE))\n\t\t\topp = dev_pm_opp_find_freq_floor(dev, freq);\n\t}\n\n\treturn opp;\n}\nEXPORT_SYMBOL(devfreq_recommended_opp);\n\n \nint devfreq_register_opp_notifier(struct device *dev, struct devfreq *devfreq)\n{\n\treturn dev_pm_opp_register_notifier(dev, &devfreq->nb);\n}\nEXPORT_SYMBOL(devfreq_register_opp_notifier);\n\n \nint devfreq_unregister_opp_notifier(struct device *dev, struct devfreq *devfreq)\n{\n\treturn dev_pm_opp_unregister_notifier(dev, &devfreq->nb);\n}\nEXPORT_SYMBOL(devfreq_unregister_opp_notifier);\n\nstatic void devm_devfreq_opp_release(struct device *dev, void *res)\n{\n\tdevfreq_unregister_opp_notifier(dev, *(struct devfreq **)res);\n}\n\n \nint devm_devfreq_register_opp_notifier(struct device *dev,\n\t\t\t\t       struct devfreq *devfreq)\n{\n\tstruct devfreq **ptr;\n\tint ret;\n\n\tptr = devres_alloc(devm_devfreq_opp_release, sizeof(*ptr), GFP_KERNEL);\n\tif (!ptr)\n\t\treturn -ENOMEM;\n\n\tret = devfreq_register_opp_notifier(dev, devfreq);\n\tif (ret) {\n\t\tdevres_free(ptr);\n\t\treturn ret;\n\t}\n\n\t*ptr = devfreq;\n\tdevres_add(dev, ptr);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(devm_devfreq_register_opp_notifier);\n\n \nvoid devm_devfreq_unregister_opp_notifier(struct device *dev,\n\t\t\t\t\t struct devfreq *devfreq)\n{\n\tWARN_ON(devres_release(dev, devm_devfreq_opp_release,\n\t\t\t       devm_devfreq_dev_match, devfreq));\n}\nEXPORT_SYMBOL(devm_devfreq_unregister_opp_notifier);\n\n \nint devfreq_register_notifier(struct devfreq *devfreq,\n\t\t\t      struct notifier_block *nb,\n\t\t\t      unsigned int list)\n{\n\tint ret = 0;\n\n\tif (!devfreq)\n\t\treturn -EINVAL;\n\n\tswitch (list) {\n\tcase DEVFREQ_TRANSITION_NOTIFIER:\n\t\tret = srcu_notifier_chain_register(\n\t\t\t\t&devfreq->transition_notifier_list, nb);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL(devfreq_register_notifier);\n\n \nint devfreq_unregister_notifier(struct devfreq *devfreq,\n\t\t\t\tstruct notifier_block *nb,\n\t\t\t\tunsigned int list)\n{\n\tint ret = 0;\n\n\tif (!devfreq)\n\t\treturn -EINVAL;\n\n\tswitch (list) {\n\tcase DEVFREQ_TRANSITION_NOTIFIER:\n\t\tret = srcu_notifier_chain_unregister(\n\t\t\t\t&devfreq->transition_notifier_list, nb);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL(devfreq_unregister_notifier);\n\nstruct devfreq_notifier_devres {\n\tstruct devfreq *devfreq;\n\tstruct notifier_block *nb;\n\tunsigned int list;\n};\n\nstatic void devm_devfreq_notifier_release(struct device *dev, void *res)\n{\n\tstruct devfreq_notifier_devres *this = res;\n\n\tdevfreq_unregister_notifier(this->devfreq, this->nb, this->list);\n}\n\n \nint devm_devfreq_register_notifier(struct device *dev,\n\t\t\t\tstruct devfreq *devfreq,\n\t\t\t\tstruct notifier_block *nb,\n\t\t\t\tunsigned int list)\n{\n\tstruct devfreq_notifier_devres *ptr;\n\tint ret;\n\n\tptr = devres_alloc(devm_devfreq_notifier_release, sizeof(*ptr),\n\t\t\t\tGFP_KERNEL);\n\tif (!ptr)\n\t\treturn -ENOMEM;\n\n\tret = devfreq_register_notifier(devfreq, nb, list);\n\tif (ret) {\n\t\tdevres_free(ptr);\n\t\treturn ret;\n\t}\n\n\tptr->devfreq = devfreq;\n\tptr->nb = nb;\n\tptr->list = list;\n\tdevres_add(dev, ptr);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(devm_devfreq_register_notifier);\n\n \nvoid devm_devfreq_unregister_notifier(struct device *dev,\n\t\t\t\t      struct devfreq *devfreq,\n\t\t\t\t      struct notifier_block *nb,\n\t\t\t\t      unsigned int list)\n{\n\tWARN_ON(devres_release(dev, devm_devfreq_notifier_release,\n\t\t\t       devm_devfreq_dev_match, devfreq));\n}\nEXPORT_SYMBOL(devm_devfreq_unregister_notifier);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}