{
  "module_name": "sun8i-a33-mbus.c",
  "hash_id": "c45ffb2de4f2dcfa70722eaab0e8075e3d6a56cca3e28c5f27c9420527af3c2c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/devfreq/sun8i-a33-mbus.c",
  "human_readable_source": "\n\n\n\n\n#include <linux/clk.h>\n#include <linux/devfreq.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/property.h>\n\n#define MBUS_CR\t\t\t\t0x0000\n#define MBUS_CR_GET_DRAM_TYPE(x)\t(((x) >> 16) & 0x7)\n#define MBUS_CR_DRAM_TYPE_DDR2\t\t2\n#define MBUS_CR_DRAM_TYPE_DDR3\t\t3\n#define MBUS_CR_DRAM_TYPE_DDR4\t\t4\n#define MBUS_CR_DRAM_TYPE_LPDDR2\t6\n#define MBUS_CR_DRAM_TYPE_LPDDR3\t7\n\n#define MBUS_TMR\t\t\t0x000c\n#define MBUS_TMR_PERIOD(x)\t\t((x) - 1)\n\n#define MBUS_PMU_CFG\t\t\t0x009c\n#define MBUS_PMU_CFG_PERIOD(x)\t\t(((x) - 1) << 16)\n#define MBUS_PMU_CFG_UNIT\t\t(0x3 << 1)\n#define MBUS_PMU_CFG_UNIT_B\t\t(0x0 << 1)\n#define MBUS_PMU_CFG_UNIT_KB\t\t(0x1 << 1)\n#define MBUS_PMU_CFG_UNIT_MB\t\t(0x2 << 1)\n#define MBUS_PMU_CFG_ENABLE\t\t(0x1 << 0)\n\n#define MBUS_PMU_BWCR(n)\t\t(0x00a0 + (0x04 * (n)))\n\n#define MBUS_TOTAL_BWCR\t\t\tMBUS_PMU_BWCR(5)\n#define MBUS_TOTAL_BWCR_H616\t\tMBUS_PMU_BWCR(13)\n\n#define MBUS_MDFSCR\t\t\t0x0100\n#define MBUS_MDFSCR_BUFFER_TIMING\t(0x1 << 15)\n#define MBUS_MDFSCR_PAD_HOLD\t\t(0x1 << 13)\n#define MBUS_MDFSCR_BYPASS\t\t(0x1 << 4)\n#define MBUS_MDFSCR_MODE\t\t(0x1 << 1)\n#define MBUS_MDFSCR_MODE_DFS\t\t(0x0 << 1)\n#define MBUS_MDFSCR_MODE_CFS\t\t(0x1 << 1)\n#define MBUS_MDFSCR_START\t\t(0x1 << 0)\n\n#define MBUS_MDFSMRMR\t\t\t0x0108\n\n#define DRAM_PWRCTL\t\t\t0x0004\n#define DRAM_PWRCTL_SELFREF_EN\t\t(0x1 << 0)\n\n#define DRAM_RFSHTMG\t\t\t0x0090\n#define DRAM_RFSHTMG_TREFI(x)\t\t((x) << 16)\n#define DRAM_RFSHTMG_TRFC(x)\t\t((x) << 0)\n\n#define DRAM_VTFCR\t\t\t0x00b8\n#define DRAM_VTFCR_VTF_ENABLE\t\t(0x3 << 8)\n\n#define DRAM_ODTMAP\t\t\t0x0120\n\n#define DRAM_DX_MAX\t\t\t4\n\n#define DRAM_DXnGCR0(n)\t\t\t(0x0344 + 0x80 * (n))\n#define DRAM_DXnGCR0_DXODT\t\t(0x3 << 4)\n#define DRAM_DXnGCR0_DXODT_DYNAMIC\t(0x0 << 4)\n#define DRAM_DXnGCR0_DXODT_ENABLED\t(0x1 << 4)\n#define DRAM_DXnGCR0_DXODT_DISABLED\t(0x2 << 4)\n#define DRAM_DXnGCR0_DXEN\t\t(0x1 << 0)\n\nstruct sun8i_a33_mbus_variant {\n\tu32\t\t\t\t\tmin_dram_divider;\n\tu32\t\t\t\t\tmax_dram_divider;\n\tu32\t\t\t\t\todt_freq_mhz;\n};\n\nstruct sun8i_a33_mbus {\n\tconst struct sun8i_a33_mbus_variant\t*variant;\n\tvoid __iomem\t\t\t\t*reg_dram;\n\tvoid __iomem\t\t\t\t*reg_mbus;\n\tstruct clk\t\t\t\t*clk_bus;\n\tstruct clk\t\t\t\t*clk_dram;\n\tstruct clk\t\t\t\t*clk_mbus;\n\tstruct devfreq\t\t\t\t*devfreq_dram;\n\tstruct devfreq_simple_ondemand_data\tgov_data;\n\tstruct devfreq_dev_profile\t\tprofile;\n\tu32\t\t\t\t\tdata_width;\n\tu32\t\t\t\t\tnominal_bw;\n\tu32\t\t\t\t\todtmap;\n\tu32\t\t\t\t\ttREFI_ns;\n\tu32\t\t\t\t\ttRFC_ns;\n\tunsigned long\t\t\t\tfreq_table[];\n};\n\n \nstatic int pmu_period = 50000;\nmodule_param(pmu_period, int, 0644);\nMODULE_PARM_DESC(pmu_period, \"Bandwidth measurement period (microseconds)\");\n\nstatic u32 sun8i_a33_mbus_get_peak_bw(struct sun8i_a33_mbus *priv)\n{\n\t \n\treturn readl_relaxed(priv->reg_mbus + MBUS_TOTAL_BWCR);\n}\n\nstatic void sun8i_a33_mbus_restart_pmu_counters(struct sun8i_a33_mbus *priv)\n{\n\tu32 pmu_cfg = MBUS_PMU_CFG_PERIOD(pmu_period) | MBUS_PMU_CFG_UNIT_KB;\n\n\t \n\twritel_relaxed(pmu_cfg,\n\t\t       priv->reg_mbus + MBUS_PMU_CFG);\n\twritel_relaxed(pmu_cfg | MBUS_PMU_CFG_ENABLE,\n\t\t       priv->reg_mbus + MBUS_PMU_CFG);\n\n}\n\nstatic void sun8i_a33_mbus_update_nominal_bw(struct sun8i_a33_mbus *priv,\n\t\t\t\t\t     u32 ddr_freq_mhz)\n{\n\t \n\tpriv->nominal_bw = ddr_freq_mhz * pmu_period * priv->data_width / 1024;\n}\n\nstatic int sun8i_a33_mbus_set_dram_freq(struct sun8i_a33_mbus *priv,\n\t\t\t\t\tunsigned long freq)\n{\n\tu32  ddr_freq_mhz = freq / USEC_PER_SEC;  \n\tu32 dram_freq_mhz =    ddr_freq_mhz / 2;  \n\tu32 mctl_freq_mhz =   dram_freq_mhz / 2;  \n\tu32 dxodt, mdfscr, pwrctl, vtfcr;\n\tu32 i, tREFI_32ck, tRFC_ck;\n\tint ret;\n\n\t \n\tret = clk_set_rate(priv->clk_dram, freq);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tpwrctl = readl_relaxed(priv->reg_dram + DRAM_PWRCTL) &\n\t\t ~DRAM_PWRCTL_SELFREF_EN;\n\twritel_relaxed(pwrctl, priv->reg_dram + DRAM_PWRCTL);\n\tvtfcr = readl_relaxed(priv->reg_dram + DRAM_VTFCR);\n\twritel_relaxed(vtfcr & ~DRAM_VTFCR_VTF_ENABLE,\n\t\t       priv->reg_dram + DRAM_VTFCR);\n\n\t \n\tmdfscr = MBUS_MDFSCR_MODE_DFS |\n\t\t MBUS_MDFSCR_BYPASS |\n\t\t MBUS_MDFSCR_PAD_HOLD |\n\t\t MBUS_MDFSCR_BUFFER_TIMING;\n\twritel(mdfscr, priv->reg_mbus + MBUS_MDFSCR);\n\n\t \n\ttREFI_32ck = priv->tREFI_ns * mctl_freq_mhz / 1000 / 32;\n\ttRFC_ck = DIV_ROUND_UP(priv->tRFC_ns * mctl_freq_mhz, 1000);\n\twritel(DRAM_RFSHTMG_TREFI(tREFI_32ck) | DRAM_RFSHTMG_TRFC(tRFC_ck),\n\t       priv->reg_dram + DRAM_RFSHTMG);\n\n\t \n\tif (priv->odtmap && dram_freq_mhz > priv->variant->odt_freq_mhz) {\n\t\tdxodt = DRAM_DXnGCR0_DXODT_DYNAMIC;\n\t\twritel(priv->odtmap, priv->reg_dram + DRAM_ODTMAP);\n\t} else {\n\t\tdxodt = DRAM_DXnGCR0_DXODT_DISABLED;\n\t\twritel(0, priv->reg_dram + DRAM_ODTMAP);\n\t}\n\tfor (i = 0; i < DRAM_DX_MAX; ++i) {\n\t\tvoid __iomem *reg = priv->reg_dram + DRAM_DXnGCR0(i);\n\n\t\twritel((readl(reg) & ~DRAM_DXnGCR0_DXODT) | dxodt, reg);\n\t}\n\n\tdev_dbg(priv->devfreq_dram->dev.parent,\n\t\t\"Setting DRAM to %u MHz, tREFI=%u, tRFC=%u, ODT=%s\\n\",\n\t\tdram_freq_mhz, tREFI_32ck, tRFC_ck,\n\t\tdxodt == DRAM_DXnGCR0_DXODT_DYNAMIC ? \"dynamic\" : \"disabled\");\n\n\t \n\twritel(mdfscr | MBUS_MDFSCR_START, priv->reg_mbus + MBUS_MDFSCR);\n\tret = readl_poll_timeout_atomic(priv->reg_mbus + MBUS_MDFSCR, mdfscr,\n\t\t\t\t\t!(mdfscr & MBUS_MDFSCR_START), 10, 1000);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\twritel(0, priv->reg_mbus + MBUS_MDFSCR);\n\n\t \n\twritel_relaxed(vtfcr, priv->reg_dram + DRAM_VTFCR);\n\n\t \n\tif (freq == priv->freq_table[0])\n\t\tpwrctl |= DRAM_PWRCTL_SELFREF_EN;\n\twritel_relaxed(pwrctl, priv->reg_dram + DRAM_PWRCTL);\n\n\tsun8i_a33_mbus_restart_pmu_counters(priv);\n\tsun8i_a33_mbus_update_nominal_bw(priv, ddr_freq_mhz);\n\n\treturn 0;\n}\n\nstatic int sun8i_a33_mbus_set_dram_target(struct device *dev,\n\t\t\t\t\t  unsigned long *freq, u32 flags)\n{\n\tstruct sun8i_a33_mbus *priv = dev_get_drvdata(dev);\n\tstruct devfreq *devfreq = priv->devfreq_dram;\n\tstruct dev_pm_opp *opp;\n\tint ret;\n\n\topp = devfreq_recommended_opp(dev, freq, flags);\n\tif (IS_ERR(opp))\n\t\treturn PTR_ERR(opp);\n\n\tdev_pm_opp_put(opp);\n\n\tif (*freq == devfreq->previous_freq)\n\t\treturn 0;\n\n\tret = sun8i_a33_mbus_set_dram_freq(priv, *freq);\n\tif (ret) {\n\t\tdev_warn(dev, \"failed to set DRAM frequency: %d\\n\", ret);\n\t\t*freq = devfreq->previous_freq;\n\t}\n\n\treturn ret;\n}\n\nstatic int sun8i_a33_mbus_get_dram_status(struct device *dev,\n\t\t\t\t\t  struct devfreq_dev_status *stat)\n{\n\tstruct sun8i_a33_mbus *priv = dev_get_drvdata(dev);\n\n\tstat->busy_time\t\t= sun8i_a33_mbus_get_peak_bw(priv);\n\tstat->total_time\t= priv->nominal_bw;\n\tstat->current_frequency\t= priv->devfreq_dram->previous_freq;\n\n\tsun8i_a33_mbus_restart_pmu_counters(priv);\n\n\tdev_dbg(dev, \"Using %lu/%lu (%lu%%) at %lu MHz\\n\",\n\t\tstat->busy_time, stat->total_time,\n\t\tDIV_ROUND_CLOSEST(stat->busy_time * 100, stat->total_time),\n\t\tstat->current_frequency / USEC_PER_SEC);\n\n\treturn 0;\n}\n\nstatic int sun8i_a33_mbus_hw_init(struct device *dev,\n\t\t\t\t  struct sun8i_a33_mbus *priv,\n\t\t\t\t  unsigned long ddr_freq)\n{\n\tu32 i, mbus_cr, mbus_freq_mhz;\n\n\t \n\tmbus_cr = readl_relaxed(priv->reg_mbus + MBUS_CR);\n\tswitch (MBUS_CR_GET_DRAM_TYPE(mbus_cr)) {\n\tcase MBUS_CR_DRAM_TYPE_DDR2:\n\tcase MBUS_CR_DRAM_TYPE_DDR3:\n\tcase MBUS_CR_DRAM_TYPE_DDR4:\n\t\tpriv->tREFI_ns = 7800;\n\t\tpriv->tRFC_ns = 350;\n\t\tbreak;\n\tcase MBUS_CR_DRAM_TYPE_LPDDR2:\n\tcase MBUS_CR_DRAM_TYPE_LPDDR3:\n\t\tpriv->tREFI_ns = 3900;\n\t\tpriv->tRFC_ns = 210;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tpriv->odtmap = readl_relaxed(priv->reg_dram + DRAM_ODTMAP);\n\n\t \n\tfor (i = 0; i < DRAM_DX_MAX; ++i) {\n\t\tvoid __iomem *reg = priv->reg_dram + DRAM_DXnGCR0(i);\n\n\t\tif (!(readl_relaxed(reg) & DRAM_DXnGCR0_DXEN))\n\t\t\tbreak;\n\t}\n\tpriv->data_width = i;\n\n\tdev_dbg(dev, \"Detected %u-bit %sDDRx with%s ODT\\n\",\n\t\tpriv->data_width * 8,\n\t\tMBUS_CR_GET_DRAM_TYPE(mbus_cr) > 4 ? \"LP\" : \"\",\n\t\tpriv->odtmap ? \"\" : \"out\");\n\n\t \n\tmbus_freq_mhz = clk_get_rate(priv->clk_mbus) / USEC_PER_SEC;\n\twritel_relaxed(MBUS_TMR_PERIOD(mbus_freq_mhz),\n\t\t       priv->reg_mbus + MBUS_TMR);\n\n\t \n\twritel_relaxed(0xffffffff, priv->reg_mbus + MBUS_MDFSMRMR);\n\n\tsun8i_a33_mbus_restart_pmu_counters(priv);\n\tsun8i_a33_mbus_update_nominal_bw(priv, ddr_freq / USEC_PER_SEC);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused sun8i_a33_mbus_suspend(struct device *dev)\n{\n\tstruct sun8i_a33_mbus *priv = dev_get_drvdata(dev);\n\n\tclk_disable_unprepare(priv->clk_bus);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused sun8i_a33_mbus_resume(struct device *dev)\n{\n\tstruct sun8i_a33_mbus *priv = dev_get_drvdata(dev);\n\n\treturn clk_prepare_enable(priv->clk_bus);\n}\n\nstatic int sun8i_a33_mbus_probe(struct platform_device *pdev)\n{\n\tconst struct sun8i_a33_mbus_variant *variant;\n\tstruct device *dev = &pdev->dev;\n\tstruct sun8i_a33_mbus *priv;\n\tunsigned long base_freq;\n\tunsigned int max_state;\n\tconst char *err;\n\tint i, ret;\n\n\tvariant = device_get_match_data(dev);\n\tif (!variant)\n\t\treturn -EINVAL;\n\n\tmax_state = variant->max_dram_divider - variant->min_dram_divider + 1;\n\n\tpriv = devm_kzalloc(dev, struct_size(priv, freq_table, max_state), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, priv);\n\n\tpriv->variant = variant;\n\n\tpriv->reg_dram = devm_platform_ioremap_resource_byname(pdev, \"dram\");\n\tif (IS_ERR(priv->reg_dram))\n\t\treturn PTR_ERR(priv->reg_dram);\n\n\tpriv->reg_mbus = devm_platform_ioremap_resource_byname(pdev, \"mbus\");\n\tif (IS_ERR(priv->reg_mbus))\n\t\treturn PTR_ERR(priv->reg_mbus);\n\n\tpriv->clk_bus = devm_clk_get(dev, \"bus\");\n\tif (IS_ERR(priv->clk_bus))\n\t\treturn dev_err_probe(dev, PTR_ERR(priv->clk_bus),\n\t\t\t\t     \"failed to get bus clock\\n\");\n\n\tpriv->clk_dram = devm_clk_get(dev, \"dram\");\n\tif (IS_ERR(priv->clk_dram))\n\t\treturn dev_err_probe(dev, PTR_ERR(priv->clk_dram),\n\t\t\t\t     \"failed to get dram clock\\n\");\n\n\tpriv->clk_mbus = devm_clk_get(dev, \"mbus\");\n\tif (IS_ERR(priv->clk_mbus))\n\t\treturn dev_err_probe(dev, PTR_ERR(priv->clk_mbus),\n\t\t\t\t     \"failed to get mbus clock\\n\");\n\n\tret = clk_prepare_enable(priv->clk_bus);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret,\n\t\t\t\t     \"failed to enable bus clock\\n\");\n\n\t \n\tret = clk_rate_exclusive_get(priv->clk_dram);\n\tif (ret) {\n\t\terr = \"failed to lock dram clock rate\\n\";\n\t\tgoto err_disable_bus;\n\t}\n\n\t \n\tret = clk_rate_exclusive_get(priv->clk_mbus);\n\tif (ret) {\n\t\terr = \"failed to lock mbus clock rate\\n\";\n\t\tgoto err_unlock_dram;\n\t}\n\n\tpriv->gov_data.upthreshold\t= 10;\n\tpriv->gov_data.downdifferential\t=  5;\n\n\tpriv->profile.initial_freq\t= clk_get_rate(priv->clk_dram);\n\tpriv->profile.polling_ms\t= 1000;\n\tpriv->profile.target\t\t= sun8i_a33_mbus_set_dram_target;\n\tpriv->profile.get_dev_status\t= sun8i_a33_mbus_get_dram_status;\n\tpriv->profile.freq_table\t= priv->freq_table;\n\tpriv->profile.max_state\t\t= max_state;\n\n\tret = devm_pm_opp_set_clkname(dev, \"dram\");\n\tif (ret) {\n\t\terr = \"failed to add OPP table\\n\";\n\t\tgoto err_unlock_mbus;\n\t}\n\n\tbase_freq = clk_get_rate(clk_get_parent(priv->clk_dram));\n\tfor (i = 0; i < max_state; ++i) {\n\t\tunsigned int div = variant->max_dram_divider - i;\n\n\t\tpriv->freq_table[i] = base_freq / div;\n\n\t\tret = dev_pm_opp_add(dev, priv->freq_table[i], 0);\n\t\tif (ret) {\n\t\t\terr = \"failed to add OPPs\\n\";\n\t\t\tgoto err_remove_opps;\n\t\t}\n\t}\n\n\tret = sun8i_a33_mbus_hw_init(dev, priv, priv->profile.initial_freq);\n\tif (ret) {\n\t\terr = \"failed to init hardware\\n\";\n\t\tgoto err_remove_opps;\n\t}\n\n\tpriv->devfreq_dram = devfreq_add_device(dev, &priv->profile,\n\t\t\t\t\t\tDEVFREQ_GOV_SIMPLE_ONDEMAND,\n\t\t\t\t\t\t&priv->gov_data);\n\tif (IS_ERR(priv->devfreq_dram)) {\n\t\tret = PTR_ERR(priv->devfreq_dram);\n\t\terr = \"failed to add devfreq device\\n\";\n\t\tgoto err_remove_opps;\n\t}\n\n\t \n\tpriv->devfreq_dram->suspend_freq = priv->freq_table[0];\n\n\treturn 0;\n\nerr_remove_opps:\n\tdev_pm_opp_remove_all_dynamic(dev);\nerr_unlock_mbus:\n\tclk_rate_exclusive_put(priv->clk_mbus);\nerr_unlock_dram:\n\tclk_rate_exclusive_put(priv->clk_dram);\nerr_disable_bus:\n\tclk_disable_unprepare(priv->clk_bus);\n\n\treturn dev_err_probe(dev, ret, err);\n}\n\nstatic int sun8i_a33_mbus_remove(struct platform_device *pdev)\n{\n\tstruct sun8i_a33_mbus *priv = platform_get_drvdata(pdev);\n\tunsigned long initial_freq = priv->profile.initial_freq;\n\tstruct device *dev = &pdev->dev;\n\tint ret;\n\n\tdevfreq_remove_device(priv->devfreq_dram);\n\n\tret = sun8i_a33_mbus_set_dram_freq(priv, initial_freq);\n\tif (ret)\n\t\tdev_warn(dev, \"failed to restore DRAM frequency: %d\\n\", ret);\n\n\tdev_pm_opp_remove_all_dynamic(dev);\n\tclk_rate_exclusive_put(priv->clk_mbus);\n\tclk_rate_exclusive_put(priv->clk_dram);\n\tclk_disable_unprepare(priv->clk_bus);\n\n\treturn 0;\n}\n\nstatic const struct sun8i_a33_mbus_variant sun50i_a64_mbus = {\n\t.min_dram_divider\t= 1,\n\t.max_dram_divider\t= 4,\n\t.odt_freq_mhz\t\t= 400,\n};\n\nstatic const struct of_device_id sun8i_a33_mbus_of_match[] = {\n\t{ .compatible = \"allwinner,sun50i-a64-mbus\", .data = &sun50i_a64_mbus },\n\t{ .compatible = \"allwinner,sun50i-h5-mbus\", .data = &sun50i_a64_mbus },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, sun8i_a33_mbus_of_match);\n\nstatic SIMPLE_DEV_PM_OPS(sun8i_a33_mbus_pm_ops,\n\t\t\t sun8i_a33_mbus_suspend, sun8i_a33_mbus_resume);\n\nstatic struct platform_driver sun8i_a33_mbus_driver = {\n\t.probe\t= sun8i_a33_mbus_probe,\n\t.remove\t= sun8i_a33_mbus_remove,\n\t.driver\t= {\n\t\t.name\t\t= \"sun8i-a33-mbus\",\n\t\t.of_match_table\t= sun8i_a33_mbus_of_match,\n\t\t.pm\t\t= pm_ptr(&sun8i_a33_mbus_pm_ops),\n\t},\n};\nmodule_platform_driver(sun8i_a33_mbus_driver);\n\nMODULE_AUTHOR(\"Samuel Holland <samuel@sholland.org>\");\nMODULE_DESCRIPTION(\"Allwinner sun8i/sun50i MBUS DEVFREQ Driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}