{
  "module_name": "tegra30-devfreq.c",
  "hash_id": "d74bfa8e122a463e388d2d24ff27c20fdb8133b4ceb17ea18e7a3f96f3042618",
  "original_prompt": "Ingested from linux-6.6.14/drivers/devfreq/tegra30-devfreq.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/cpufreq.h>\n#include <linux/devfreq.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/irq.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm_opp.h>\n#include <linux/reset.h>\n#include <linux/workqueue.h>\n\n#include <soc/tegra/fuse.h>\n\n#include \"governor.h\"\n\n#define ACTMON_GLB_STATUS\t\t\t\t\t0x0\n#define ACTMON_GLB_PERIOD_CTRL\t\t\t\t\t0x4\n\n#define ACTMON_DEV_CTRL\t\t\t\t\t\t0x0\n#define ACTMON_DEV_CTRL_K_VAL_SHIFT\t\t\t\t10\n#define ACTMON_DEV_CTRL_ENB_PERIODIC\t\t\t\tBIT(18)\n#define ACTMON_DEV_CTRL_AVG_BELOW_WMARK_EN\t\t\tBIT(20)\n#define ACTMON_DEV_CTRL_AVG_ABOVE_WMARK_EN\t\t\tBIT(21)\n#define ACTMON_DEV_CTRL_CONSECUTIVE_BELOW_WMARK_NUM_SHIFT\t23\n#define ACTMON_DEV_CTRL_CONSECUTIVE_ABOVE_WMARK_NUM_SHIFT\t26\n#define ACTMON_DEV_CTRL_CONSECUTIVE_BELOW_WMARK_EN\t\tBIT(29)\n#define ACTMON_DEV_CTRL_CONSECUTIVE_ABOVE_WMARK_EN\t\tBIT(30)\n#define ACTMON_DEV_CTRL_ENB\t\t\t\t\tBIT(31)\n\n#define ACTMON_DEV_CTRL_STOP\t\t\t\t\t0x00000000\n\n#define ACTMON_DEV_UPPER_WMARK\t\t\t\t\t0x4\n#define ACTMON_DEV_LOWER_WMARK\t\t\t\t\t0x8\n#define ACTMON_DEV_INIT_AVG\t\t\t\t\t0xc\n#define ACTMON_DEV_AVG_UPPER_WMARK\t\t\t\t0x10\n#define ACTMON_DEV_AVG_LOWER_WMARK\t\t\t\t0x14\n#define ACTMON_DEV_COUNT_WEIGHT\t\t\t\t\t0x18\n#define ACTMON_DEV_AVG_COUNT\t\t\t\t\t0x20\n#define ACTMON_DEV_INTR_STATUS\t\t\t\t\t0x24\n\n#define ACTMON_INTR_STATUS_CLEAR\t\t\t\t0xffffffff\n\n#define ACTMON_DEV_INTR_CONSECUTIVE_UPPER\t\t\tBIT(31)\n#define ACTMON_DEV_INTR_CONSECUTIVE_LOWER\t\t\tBIT(30)\n\n#define ACTMON_ABOVE_WMARK_WINDOW\t\t\t\t1\n#define ACTMON_BELOW_WMARK_WINDOW\t\t\t\t3\n#define ACTMON_BOOST_FREQ_STEP\t\t\t\t\t16000\n\n \n#define ACTMON_AVERAGE_WINDOW_LOG2\t\t\t6\n#define ACTMON_SAMPLING_PERIOD\t\t\t\t12  \n#define ACTMON_DEFAULT_AVG_BAND\t\t\t\t6   \n\n#define KHZ\t\t\t\t\t\t\t1000\n\n#define KHZ_MAX\t\t\t\t\t\t(ULONG_MAX / KHZ)\n\n \n#define BUS_SATURATION_RATIO\t\t\t\t\t25\n\n \nstruct tegra_devfreq_device_config {\n\tu32\t\toffset;\n\tu32\t\tirq_mask;\n\n\t \n\tunsigned int\tboost_up_coeff;\n\tunsigned int\tboost_down_coeff;\n\n\t \n\tunsigned int\tboost_up_threshold;\n\tunsigned int\tboost_down_threshold;\n\n\t \n\tu32\t\tavg_dependency_threshold;\n};\n\nenum tegra_actmon_device {\n\tMCALL = 0,\n\tMCCPU,\n};\n\nstatic const struct tegra_devfreq_device_config tegra124_device_configs[] = {\n\t{\n\t\t \n\t\t.offset = 0x1c0,\n\t\t.irq_mask = 1 << 26,\n\t\t.boost_up_coeff = 200,\n\t\t.boost_down_coeff = 50,\n\t\t.boost_up_threshold = 60,\n\t\t.boost_down_threshold = 40,\n\t},\n\t{\n\t\t \n\t\t.offset = 0x200,\n\t\t.irq_mask = 1 << 25,\n\t\t.boost_up_coeff = 800,\n\t\t.boost_down_coeff = 40,\n\t\t.boost_up_threshold = 27,\n\t\t.boost_down_threshold = 10,\n\t\t.avg_dependency_threshold = 16000,  \n\t},\n};\n\nstatic const struct tegra_devfreq_device_config tegra30_device_configs[] = {\n\t{\n\t\t \n\t\t.offset = 0x1c0,\n\t\t.irq_mask = 1 << 26,\n\t\t.boost_up_coeff = 200,\n\t\t.boost_down_coeff = 50,\n\t\t.boost_up_threshold = 20,\n\t\t.boost_down_threshold = 10,\n\t},\n\t{\n\t\t \n\t\t.offset = 0x200,\n\t\t.irq_mask = 1 << 25,\n\t\t.boost_up_coeff = 800,\n\t\t.boost_down_coeff = 40,\n\t\t.boost_up_threshold = 27,\n\t\t.boost_down_threshold = 10,\n\t\t.avg_dependency_threshold = 16000,  \n\t},\n};\n\n \nstruct tegra_devfreq_device {\n\tconst struct tegra_devfreq_device_config *config;\n\tvoid __iomem *regs;\n\n\t \n\tu32 avg_count;\n\n\t \n\tunsigned long boost_freq;\n\n\t \n\tunsigned long target_freq;\n};\n\nstruct tegra_devfreq_soc_data {\n\tconst struct tegra_devfreq_device_config *configs;\n\t \n\tunsigned int count_weight;\n};\n\nstruct tegra_devfreq {\n\tstruct devfreq\t\t*devfreq;\n\n\tstruct reset_control\t*reset;\n\tstruct clk\t\t*clock;\n\tvoid __iomem\t\t*regs;\n\n\tstruct clk\t\t*emc_clock;\n\tunsigned long\t\tmax_freq;\n\tunsigned long\t\tcur_freq;\n\tstruct notifier_block\tclk_rate_change_nb;\n\n\tstruct delayed_work\tcpufreq_update_work;\n\tstruct notifier_block\tcpu_rate_change_nb;\n\n\tstruct tegra_devfreq_device devices[2];\n\n\tunsigned int\t\tirq;\n\n\tbool\t\t\tstarted;\n\n\tconst struct tegra_devfreq_soc_data *soc;\n};\n\nstruct tegra_actmon_emc_ratio {\n\tunsigned long cpu_freq;\n\tunsigned long emc_freq;\n};\n\nstatic const struct tegra_actmon_emc_ratio actmon_emc_ratios[] = {\n\t{ 1400000,    KHZ_MAX },\n\t{ 1200000,    750000 },\n\t{ 1100000,    600000 },\n\t{ 1000000,    500000 },\n\t{  800000,    375000 },\n\t{  500000,    200000 },\n\t{  250000,    100000 },\n};\n\nstatic u32 actmon_readl(struct tegra_devfreq *tegra, u32 offset)\n{\n\treturn readl_relaxed(tegra->regs + offset);\n}\n\nstatic void actmon_writel(struct tegra_devfreq *tegra, u32 val, u32 offset)\n{\n\twritel_relaxed(val, tegra->regs + offset);\n}\n\nstatic u32 device_readl(struct tegra_devfreq_device *dev, u32 offset)\n{\n\treturn readl_relaxed(dev->regs + offset);\n}\n\nstatic void device_writel(struct tegra_devfreq_device *dev, u32 val,\n\t\t\t  u32 offset)\n{\n\twritel_relaxed(val, dev->regs + offset);\n}\n\nstatic unsigned long do_percent(unsigned long long val, unsigned int pct)\n{\n\tval = val * pct;\n\tdo_div(val, 100);\n\n\t \n\treturn min_t(u64, val, U32_MAX);\n}\n\nstatic void tegra_devfreq_update_avg_wmark(struct tegra_devfreq *tegra,\n\t\t\t\t\t   struct tegra_devfreq_device *dev)\n{\n\tu32 avg_band_freq = tegra->max_freq * ACTMON_DEFAULT_AVG_BAND / KHZ;\n\tu32 band = avg_band_freq * tegra->devfreq->profile->polling_ms;\n\tu32 avg;\n\n\tavg = min(dev->avg_count, U32_MAX - band);\n\tdevice_writel(dev, avg + band, ACTMON_DEV_AVG_UPPER_WMARK);\n\n\tavg = max(dev->avg_count, band);\n\tdevice_writel(dev, avg - band, ACTMON_DEV_AVG_LOWER_WMARK);\n}\n\nstatic void tegra_devfreq_update_wmark(struct tegra_devfreq *tegra,\n\t\t\t\t       struct tegra_devfreq_device *dev)\n{\n\tu32 val = tegra->cur_freq * tegra->devfreq->profile->polling_ms;\n\n\tdevice_writel(dev, do_percent(val, dev->config->boost_up_threshold),\n\t\t      ACTMON_DEV_UPPER_WMARK);\n\n\tdevice_writel(dev, do_percent(val, dev->config->boost_down_threshold),\n\t\t      ACTMON_DEV_LOWER_WMARK);\n}\n\nstatic void actmon_isr_device(struct tegra_devfreq *tegra,\n\t\t\t      struct tegra_devfreq_device *dev)\n{\n\tu32 intr_status, dev_ctrl;\n\n\tdev->avg_count = device_readl(dev, ACTMON_DEV_AVG_COUNT);\n\ttegra_devfreq_update_avg_wmark(tegra, dev);\n\n\tintr_status = device_readl(dev, ACTMON_DEV_INTR_STATUS);\n\tdev_ctrl = device_readl(dev, ACTMON_DEV_CTRL);\n\n\tif (intr_status & ACTMON_DEV_INTR_CONSECUTIVE_UPPER) {\n\t\t \n\t\tdev->boost_freq = do_percent(dev->boost_freq,\n\t\t\t\t\t     dev->config->boost_up_coeff);\n\t\tdev->boost_freq += ACTMON_BOOST_FREQ_STEP;\n\n\t\tdev_ctrl |= ACTMON_DEV_CTRL_CONSECUTIVE_BELOW_WMARK_EN;\n\n\t\tif (dev->boost_freq >= tegra->max_freq) {\n\t\t\tdev_ctrl &= ~ACTMON_DEV_CTRL_CONSECUTIVE_ABOVE_WMARK_EN;\n\t\t\tdev->boost_freq = tegra->max_freq;\n\t\t}\n\t} else if (intr_status & ACTMON_DEV_INTR_CONSECUTIVE_LOWER) {\n\t\t \n\t\tdev->boost_freq = do_percent(dev->boost_freq,\n\t\t\t\t\t     dev->config->boost_down_coeff);\n\n\t\tdev_ctrl |= ACTMON_DEV_CTRL_CONSECUTIVE_ABOVE_WMARK_EN;\n\n\t\tif (dev->boost_freq < (ACTMON_BOOST_FREQ_STEP >> 1)) {\n\t\t\tdev_ctrl &= ~ACTMON_DEV_CTRL_CONSECUTIVE_BELOW_WMARK_EN;\n\t\t\tdev->boost_freq = 0;\n\t\t}\n\t}\n\n\tdevice_writel(dev, dev_ctrl, ACTMON_DEV_CTRL);\n\n\tdevice_writel(dev, ACTMON_INTR_STATUS_CLEAR, ACTMON_DEV_INTR_STATUS);\n}\n\nstatic unsigned long actmon_cpu_to_emc_rate(struct tegra_devfreq *tegra,\n\t\t\t\t\t    unsigned long cpu_freq)\n{\n\tunsigned int i;\n\tconst struct tegra_actmon_emc_ratio *ratio = actmon_emc_ratios;\n\n\tfor (i = 0; i < ARRAY_SIZE(actmon_emc_ratios); i++, ratio++) {\n\t\tif (cpu_freq >= ratio->cpu_freq) {\n\t\t\tif (ratio->emc_freq >= tegra->max_freq)\n\t\t\t\treturn tegra->max_freq;\n\t\t\telse\n\t\t\t\treturn ratio->emc_freq;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic unsigned long actmon_device_target_freq(struct tegra_devfreq *tegra,\n\t\t\t\t\t       struct tegra_devfreq_device *dev)\n{\n\tunsigned int avg_sustain_coef;\n\tunsigned long target_freq;\n\n\ttarget_freq = dev->avg_count / tegra->devfreq->profile->polling_ms;\n\tavg_sustain_coef = 100 * 100 / dev->config->boost_up_threshold;\n\ttarget_freq = do_percent(target_freq, avg_sustain_coef);\n\n\treturn target_freq;\n}\n\nstatic void actmon_update_target(struct tegra_devfreq *tegra,\n\t\t\t\t struct tegra_devfreq_device *dev)\n{\n\tunsigned long cpu_freq = 0;\n\tunsigned long static_cpu_emc_freq = 0;\n\n\tdev->target_freq = actmon_device_target_freq(tegra, dev);\n\n\tif (dev->config->avg_dependency_threshold &&\n\t    dev->config->avg_dependency_threshold <= dev->target_freq) {\n\t\tcpu_freq = cpufreq_quick_get(0);\n\t\tstatic_cpu_emc_freq = actmon_cpu_to_emc_rate(tegra, cpu_freq);\n\n\t\tdev->target_freq += dev->boost_freq;\n\t\tdev->target_freq = max(dev->target_freq, static_cpu_emc_freq);\n\t} else {\n\t\tdev->target_freq += dev->boost_freq;\n\t}\n}\n\nstatic irqreturn_t actmon_thread_isr(int irq, void *data)\n{\n\tstruct tegra_devfreq *tegra = data;\n\tbool handled = false;\n\tunsigned int i;\n\tu32 val;\n\n\tmutex_lock(&tegra->devfreq->lock);\n\n\tval = actmon_readl(tegra, ACTMON_GLB_STATUS);\n\tfor (i = 0; i < ARRAY_SIZE(tegra->devices); i++) {\n\t\tif (val & tegra->devices[i].config->irq_mask) {\n\t\t\tactmon_isr_device(tegra, tegra->devices + i);\n\t\t\thandled = true;\n\t\t}\n\t}\n\n\tif (handled)\n\t\tupdate_devfreq(tegra->devfreq);\n\n\tmutex_unlock(&tegra->devfreq->lock);\n\n\treturn handled ? IRQ_HANDLED : IRQ_NONE;\n}\n\nstatic int tegra_actmon_clk_notify_cb(struct notifier_block *nb,\n\t\t\t\t      unsigned long action, void *ptr)\n{\n\tstruct clk_notifier_data *data = ptr;\n\tstruct tegra_devfreq *tegra;\n\tstruct tegra_devfreq_device *dev;\n\tunsigned int i;\n\n\tif (action != POST_RATE_CHANGE)\n\t\treturn NOTIFY_OK;\n\n\ttegra = container_of(nb, struct tegra_devfreq, clk_rate_change_nb);\n\n\ttegra->cur_freq = data->new_rate / KHZ;\n\n\tfor (i = 0; i < ARRAY_SIZE(tegra->devices); i++) {\n\t\tdev = &tegra->devices[i];\n\n\t\ttegra_devfreq_update_wmark(tegra, dev);\n\t}\n\n\treturn NOTIFY_OK;\n}\n\nstatic void tegra_actmon_delayed_update(struct work_struct *work)\n{\n\tstruct tegra_devfreq *tegra = container_of(work, struct tegra_devfreq,\n\t\t\t\t\t\t   cpufreq_update_work.work);\n\n\tmutex_lock(&tegra->devfreq->lock);\n\tupdate_devfreq(tegra->devfreq);\n\tmutex_unlock(&tegra->devfreq->lock);\n}\n\nstatic unsigned long\ntegra_actmon_cpufreq_contribution(struct tegra_devfreq *tegra,\n\t\t\t\t  unsigned int cpu_freq)\n{\n\tstruct tegra_devfreq_device *actmon_dev = &tegra->devices[MCCPU];\n\tunsigned long static_cpu_emc_freq, dev_freq;\n\n\tdev_freq = actmon_device_target_freq(tegra, actmon_dev);\n\n\t \n\tif (dev_freq < actmon_dev->config->avg_dependency_threshold)\n\t\treturn 0;\n\n\tstatic_cpu_emc_freq = actmon_cpu_to_emc_rate(tegra, cpu_freq);\n\n\tif (dev_freq + actmon_dev->boost_freq >= static_cpu_emc_freq)\n\t\treturn 0;\n\n\treturn static_cpu_emc_freq;\n}\n\nstatic int tegra_actmon_cpu_notify_cb(struct notifier_block *nb,\n\t\t\t\t      unsigned long action, void *ptr)\n{\n\tstruct cpufreq_freqs *freqs = ptr;\n\tstruct tegra_devfreq *tegra;\n\tunsigned long old, new, delay;\n\n\tif (action != CPUFREQ_POSTCHANGE)\n\t\treturn NOTIFY_OK;\n\n\ttegra = container_of(nb, struct tegra_devfreq, cpu_rate_change_nb);\n\n\t \n\tif (mutex_trylock(&tegra->devfreq->lock)) {\n\t\told = tegra_actmon_cpufreq_contribution(tegra, freqs->old);\n\t\tnew = tegra_actmon_cpufreq_contribution(tegra, freqs->new);\n\t\tmutex_unlock(&tegra->devfreq->lock);\n\n\t\t \n\t\tif (old == new)\n\t\t\treturn NOTIFY_OK;\n\t}\n\n\t \n\tdelay = msecs_to_jiffies(ACTMON_SAMPLING_PERIOD);\n\tschedule_delayed_work(&tegra->cpufreq_update_work, delay);\n\n\treturn NOTIFY_OK;\n}\n\nstatic void tegra_actmon_configure_device(struct tegra_devfreq *tegra,\n\t\t\t\t\t  struct tegra_devfreq_device *dev)\n{\n\tu32 val = 0;\n\n\t \n\tdev->boost_freq = 0;\n\n\tdev->target_freq = tegra->cur_freq;\n\n\tdev->avg_count = tegra->cur_freq * tegra->devfreq->profile->polling_ms;\n\tdevice_writel(dev, dev->avg_count, ACTMON_DEV_INIT_AVG);\n\n\ttegra_devfreq_update_avg_wmark(tegra, dev);\n\ttegra_devfreq_update_wmark(tegra, dev);\n\n\tdevice_writel(dev, tegra->soc->count_weight, ACTMON_DEV_COUNT_WEIGHT);\n\tdevice_writel(dev, ACTMON_INTR_STATUS_CLEAR, ACTMON_DEV_INTR_STATUS);\n\n\tval |= ACTMON_DEV_CTRL_ENB_PERIODIC;\n\tval |= (ACTMON_AVERAGE_WINDOW_LOG2 - 1)\n\t\t<< ACTMON_DEV_CTRL_K_VAL_SHIFT;\n\tval |= (ACTMON_BELOW_WMARK_WINDOW - 1)\n\t\t<< ACTMON_DEV_CTRL_CONSECUTIVE_BELOW_WMARK_NUM_SHIFT;\n\tval |= (ACTMON_ABOVE_WMARK_WINDOW - 1)\n\t\t<< ACTMON_DEV_CTRL_CONSECUTIVE_ABOVE_WMARK_NUM_SHIFT;\n\tval |= ACTMON_DEV_CTRL_AVG_ABOVE_WMARK_EN;\n\tval |= ACTMON_DEV_CTRL_AVG_BELOW_WMARK_EN;\n\tval |= ACTMON_DEV_CTRL_CONSECUTIVE_ABOVE_WMARK_EN;\n\tval |= ACTMON_DEV_CTRL_ENB;\n\n\tdevice_writel(dev, val, ACTMON_DEV_CTRL);\n}\n\nstatic void tegra_actmon_stop_devices(struct tegra_devfreq *tegra)\n{\n\tstruct tegra_devfreq_device *dev = tegra->devices;\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(tegra->devices); i++, dev++) {\n\t\tdevice_writel(dev, ACTMON_DEV_CTRL_STOP, ACTMON_DEV_CTRL);\n\t\tdevice_writel(dev, ACTMON_INTR_STATUS_CLEAR,\n\t\t\t      ACTMON_DEV_INTR_STATUS);\n\t}\n}\n\nstatic int tegra_actmon_resume(struct tegra_devfreq *tegra)\n{\n\tunsigned int i;\n\tint err;\n\n\tif (!tegra->devfreq->profile->polling_ms || !tegra->started)\n\t\treturn 0;\n\n\tactmon_writel(tegra, tegra->devfreq->profile->polling_ms - 1,\n\t\t      ACTMON_GLB_PERIOD_CTRL);\n\n\t \n\terr = clk_notifier_register(tegra->emc_clock,\n\t\t\t\t    &tegra->clk_rate_change_nb);\n\tif (err) {\n\t\tdev_err(tegra->devfreq->dev.parent,\n\t\t\t\"Failed to register rate change notifier\\n\");\n\t\treturn err;\n\t}\n\n\ttegra->cur_freq = clk_get_rate(tegra->emc_clock) / KHZ;\n\n\tfor (i = 0; i < ARRAY_SIZE(tegra->devices); i++)\n\t\ttegra_actmon_configure_device(tegra, &tegra->devices[i]);\n\n\t \n\terr = cpufreq_register_notifier(&tegra->cpu_rate_change_nb,\n\t\t\t\t\tCPUFREQ_TRANSITION_NOTIFIER);\n\tif (err) {\n\t\tdev_err(tegra->devfreq->dev.parent,\n\t\t\t\"Failed to register rate change notifier: %d\\n\", err);\n\t\tgoto err_stop;\n\t}\n\n\tenable_irq(tegra->irq);\n\n\treturn 0;\n\nerr_stop:\n\ttegra_actmon_stop_devices(tegra);\n\n\tclk_notifier_unregister(tegra->emc_clock, &tegra->clk_rate_change_nb);\n\n\treturn err;\n}\n\nstatic int tegra_actmon_start(struct tegra_devfreq *tegra)\n{\n\tint ret = 0;\n\n\tif (!tegra->started) {\n\t\ttegra->started = true;\n\n\t\tret = tegra_actmon_resume(tegra);\n\t\tif (ret)\n\t\t\ttegra->started = false;\n\t}\n\n\treturn ret;\n}\n\nstatic void tegra_actmon_pause(struct tegra_devfreq *tegra)\n{\n\tif (!tegra->devfreq->profile->polling_ms || !tegra->started)\n\t\treturn;\n\n\tdisable_irq(tegra->irq);\n\n\tcpufreq_unregister_notifier(&tegra->cpu_rate_change_nb,\n\t\t\t\t    CPUFREQ_TRANSITION_NOTIFIER);\n\n\tcancel_delayed_work_sync(&tegra->cpufreq_update_work);\n\n\ttegra_actmon_stop_devices(tegra);\n\n\tclk_notifier_unregister(tegra->emc_clock, &tegra->clk_rate_change_nb);\n}\n\nstatic void tegra_actmon_stop(struct tegra_devfreq *tegra)\n{\n\ttegra_actmon_pause(tegra);\n\ttegra->started = false;\n}\n\nstatic int tegra_devfreq_target(struct device *dev, unsigned long *freq,\n\t\t\t\tu32 flags)\n{\n\tstruct dev_pm_opp *opp;\n\tint ret;\n\n\topp = devfreq_recommended_opp(dev, freq, flags);\n\tif (IS_ERR(opp)) {\n\t\tdev_err(dev, \"Failed to find opp for %lu Hz\\n\", *freq);\n\t\treturn PTR_ERR(opp);\n\t}\n\n\tret = dev_pm_opp_set_opp(dev, opp);\n\tdev_pm_opp_put(opp);\n\n\treturn ret;\n}\n\nstatic int tegra_devfreq_get_dev_status(struct device *dev,\n\t\t\t\t\tstruct devfreq_dev_status *stat)\n{\n\tstruct tegra_devfreq *tegra = dev_get_drvdata(dev);\n\tstruct tegra_devfreq_device *actmon_dev;\n\tunsigned long cur_freq;\n\n\tcur_freq = READ_ONCE(tegra->cur_freq);\n\n\t \n\tstat->private_data = tegra;\n\n\t \n\tstat->current_frequency = cur_freq * KHZ;\n\n\tactmon_dev = &tegra->devices[MCALL];\n\n\t \n\tstat->busy_time = device_readl(actmon_dev, ACTMON_DEV_AVG_COUNT);\n\n\t \n\tstat->busy_time *= 100 / BUS_SATURATION_RATIO;\n\n\t \n\tstat->total_time = tegra->devfreq->profile->polling_ms * cur_freq;\n\n\tstat->busy_time = min(stat->busy_time, stat->total_time);\n\n\treturn 0;\n}\n\nstatic struct devfreq_dev_profile tegra_devfreq_profile = {\n\t.polling_ms\t= ACTMON_SAMPLING_PERIOD,\n\t.target\t\t= tegra_devfreq_target,\n\t.get_dev_status\t= tegra_devfreq_get_dev_status,\n\t.is_cooling_device = true,\n};\n\nstatic int tegra_governor_get_target(struct devfreq *devfreq,\n\t\t\t\t     unsigned long *freq)\n{\n\tstruct devfreq_dev_status *stat;\n\tstruct tegra_devfreq *tegra;\n\tstruct tegra_devfreq_device *dev;\n\tunsigned long target_freq = 0;\n\tunsigned int i;\n\tint err;\n\n\terr = devfreq_update_stats(devfreq);\n\tif (err)\n\t\treturn err;\n\n\tstat = &devfreq->last_status;\n\n\ttegra = stat->private_data;\n\n\tfor (i = 0; i < ARRAY_SIZE(tegra->devices); i++) {\n\t\tdev = &tegra->devices[i];\n\n\t\tactmon_update_target(tegra, dev);\n\n\t\ttarget_freq = max(target_freq, dev->target_freq);\n\t}\n\n\t \n\t*freq = target_freq * KHZ;\n\n\treturn 0;\n}\n\nstatic int tegra_governor_event_handler(struct devfreq *devfreq,\n\t\t\t\t\tunsigned int event, void *data)\n{\n\tstruct tegra_devfreq *tegra = dev_get_drvdata(devfreq->dev.parent);\n\tunsigned int *new_delay = data;\n\tint ret = 0;\n\n\t \n\ttegra->devfreq = devfreq;\n\n\tswitch (event) {\n\tcase DEVFREQ_GOV_START:\n\t\tdevfreq_monitor_start(devfreq);\n\t\tret = tegra_actmon_start(tegra);\n\t\tbreak;\n\n\tcase DEVFREQ_GOV_STOP:\n\t\ttegra_actmon_stop(tegra);\n\t\tdevfreq_monitor_stop(devfreq);\n\t\tbreak;\n\n\tcase DEVFREQ_GOV_UPDATE_INTERVAL:\n\t\t \n\t\tif (*new_delay > 256) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\ttegra_actmon_pause(tegra);\n\t\tdevfreq_update_interval(devfreq, new_delay);\n\t\tret = tegra_actmon_resume(tegra);\n\t\tbreak;\n\n\tcase DEVFREQ_GOV_SUSPEND:\n\t\ttegra_actmon_stop(tegra);\n\t\tdevfreq_monitor_suspend(devfreq);\n\t\tbreak;\n\n\tcase DEVFREQ_GOV_RESUME:\n\t\tdevfreq_monitor_resume(devfreq);\n\t\tret = tegra_actmon_start(tegra);\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic struct devfreq_governor tegra_devfreq_governor = {\n\t.name = \"tegra_actmon\",\n\t.attrs = DEVFREQ_GOV_ATTR_POLLING_INTERVAL,\n\t.flags = DEVFREQ_GOV_FLAG_IMMUTABLE\n\t\t| DEVFREQ_GOV_FLAG_IRQ_DRIVEN,\n\t.get_target_freq = tegra_governor_get_target,\n\t.event_handler = tegra_governor_event_handler,\n};\n\nstatic void devm_tegra_devfreq_deinit_hw(void *data)\n{\n\tstruct tegra_devfreq *tegra = data;\n\n\treset_control_reset(tegra->reset);\n\tclk_disable_unprepare(tegra->clock);\n}\n\nstatic int devm_tegra_devfreq_init_hw(struct device *dev,\n\t\t\t\t      struct tegra_devfreq *tegra)\n{\n\tint err;\n\n\terr = clk_prepare_enable(tegra->clock);\n\tif (err) {\n\t\tdev_err(dev, \"Failed to prepare and enable ACTMON clock\\n\");\n\t\treturn err;\n\t}\n\n\terr = devm_add_action_or_reset(dev, devm_tegra_devfreq_deinit_hw,\n\t\t\t\t       tegra);\n\tif (err)\n\t\treturn err;\n\n\terr = reset_control_reset(tegra->reset);\n\tif (err) {\n\t\tdev_err(dev, \"Failed to reset hardware: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\treturn err;\n}\n\nstatic int tegra_devfreq_config_clks_nop(struct device *dev,\n\t\t\t\t\t struct opp_table *opp_table,\n\t\t\t\t\t struct dev_pm_opp *opp, void *data,\n\t\t\t\t\t bool scaling_down)\n{\n\t \n\treturn 0;\n}\n\nstatic int tegra_devfreq_probe(struct platform_device *pdev)\n{\n\tu32 hw_version = BIT(tegra_sku_info.soc_speedo_id);\n\tstruct tegra_devfreq_device *dev;\n\tstruct tegra_devfreq *tegra;\n\tstruct devfreq *devfreq;\n\tunsigned int i;\n\tlong rate;\n\tint err;\n\tconst char *clk_names[] = { \"actmon\", NULL };\n\tstruct dev_pm_opp_config config = {\n\t\t.supported_hw = &hw_version,\n\t\t.supported_hw_count = 1,\n\t\t.clk_names = clk_names,\n\t\t.config_clks = tegra_devfreq_config_clks_nop,\n\t};\n\n\ttegra = devm_kzalloc(&pdev->dev, sizeof(*tegra), GFP_KERNEL);\n\tif (!tegra)\n\t\treturn -ENOMEM;\n\n\ttegra->soc = of_device_get_match_data(&pdev->dev);\n\n\ttegra->regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(tegra->regs))\n\t\treturn PTR_ERR(tegra->regs);\n\n\ttegra->reset = devm_reset_control_get(&pdev->dev, \"actmon\");\n\tif (IS_ERR(tegra->reset)) {\n\t\tdev_err(&pdev->dev, \"Failed to get reset\\n\");\n\t\treturn PTR_ERR(tegra->reset);\n\t}\n\n\ttegra->clock = devm_clk_get(&pdev->dev, \"actmon\");\n\tif (IS_ERR(tegra->clock)) {\n\t\tdev_err(&pdev->dev, \"Failed to get actmon clock\\n\");\n\t\treturn PTR_ERR(tegra->clock);\n\t}\n\n\ttegra->emc_clock = devm_clk_get(&pdev->dev, \"emc\");\n\tif (IS_ERR(tegra->emc_clock))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(tegra->emc_clock),\n\t\t\t\t     \"Failed to get emc clock\\n\");\n\n\terr = platform_get_irq(pdev, 0);\n\tif (err < 0)\n\t\treturn err;\n\n\ttegra->irq = err;\n\n\tirq_set_status_flags(tegra->irq, IRQ_NOAUTOEN);\n\n\terr = devm_request_threaded_irq(&pdev->dev, tegra->irq, NULL,\n\t\t\t\t\tactmon_thread_isr, IRQF_ONESHOT,\n\t\t\t\t\t\"tegra-devfreq\", tegra);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"Interrupt request failed: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\terr = devm_pm_opp_set_config(&pdev->dev, &config);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"Failed to set OPP config: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\terr = devm_pm_opp_of_add_table_indexed(&pdev->dev, 0);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"Failed to add OPP table: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\terr = devm_tegra_devfreq_init_hw(&pdev->dev, tegra);\n\tif (err)\n\t\treturn err;\n\n\trate = clk_round_rate(tegra->emc_clock, ULONG_MAX);\n\tif (rate <= 0) {\n\t\tdev_err(&pdev->dev, \"Failed to round clock rate: %ld\\n\", rate);\n\t\treturn rate ?: -EINVAL;\n\t}\n\n\ttegra->max_freq = rate / KHZ;\n\n\tfor (i = 0; i < ARRAY_SIZE(tegra->devices); i++) {\n\t\tdev = tegra->devices + i;\n\t\tdev->config = tegra->soc->configs + i;\n\t\tdev->regs = tegra->regs + dev->config->offset;\n\t}\n\n\tplatform_set_drvdata(pdev, tegra);\n\n\ttegra->clk_rate_change_nb.notifier_call = tegra_actmon_clk_notify_cb;\n\ttegra->cpu_rate_change_nb.notifier_call = tegra_actmon_cpu_notify_cb;\n\n\tINIT_DELAYED_WORK(&tegra->cpufreq_update_work,\n\t\t\t  tegra_actmon_delayed_update);\n\n\terr = devm_devfreq_add_governor(&pdev->dev, &tegra_devfreq_governor);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"Failed to add governor: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\ttegra_devfreq_profile.initial_freq = clk_get_rate(tegra->emc_clock);\n\n\tdevfreq = devm_devfreq_add_device(&pdev->dev, &tegra_devfreq_profile,\n\t\t\t\t\t  \"tegra_actmon\", NULL);\n\tif (IS_ERR(devfreq)) {\n\t\tdev_err(&pdev->dev, \"Failed to add device: %pe\\n\", devfreq);\n\t\treturn PTR_ERR(devfreq);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct tegra_devfreq_soc_data tegra124_soc = {\n\t.configs = tegra124_device_configs,\n\n\t \n\t.count_weight = 4 * 256,\n};\n\nstatic const struct tegra_devfreq_soc_data tegra30_soc = {\n\t.configs = tegra30_device_configs,\n\t.count_weight = 2 * 256,\n};\n\nstatic const struct of_device_id tegra_devfreq_of_match[] = {\n\t{ .compatible = \"nvidia,tegra30-actmon\",  .data = &tegra30_soc, },\n\t{ .compatible = \"nvidia,tegra124-actmon\", .data = &tegra124_soc, },\n\t{ },\n};\n\nMODULE_DEVICE_TABLE(of, tegra_devfreq_of_match);\n\nstatic struct platform_driver tegra_devfreq_driver = {\n\t.probe\t= tegra_devfreq_probe,\n\t.driver = {\n\t\t.name = \"tegra-devfreq\",\n\t\t.of_match_table = tegra_devfreq_of_match,\n\t},\n};\nmodule_platform_driver(tegra_devfreq_driver);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"Tegra devfreq driver\");\nMODULE_AUTHOR(\"Tomeu Vizoso <tomeu.vizoso@collabora.com>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}