{
  "module_name": "rk3399_dmc.c",
  "hash_id": "a832ff767531c75c789af22480477dbd26d77566b597aa3b2309daed38e2b92c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/devfreq/rk3399_dmc.c",
  "human_readable_source": "\n \n\n#include <linux/arm-smccc.h>\n#include <linux/bitfield.h>\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/devfreq.h>\n#include <linux/devfreq-event.h>\n#include <linux/interrupt.h>\n#include <linux/mfd/syscon.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm_opp.h>\n#include <linux/regmap.h>\n#include <linux/regulator/consumer.h>\n#include <linux/rwsem.h>\n#include <linux/suspend.h>\n\n#include <soc/rockchip/pm_domains.h>\n#include <soc/rockchip/rk3399_grf.h>\n#include <soc/rockchip/rockchip_sip.h>\n\n#define NS_TO_CYCLE(NS, MHz)\t\t\t\t(((NS) * (MHz)) / NSEC_PER_USEC)\n\n#define RK3399_SET_ODT_PD_0_SR_IDLE\t\t\tGENMASK(7, 0)\n#define RK3399_SET_ODT_PD_0_SR_MC_GATE_IDLE\t\tGENMASK(15, 8)\n#define RK3399_SET_ODT_PD_0_STANDBY_IDLE\t\tGENMASK(31, 16)\n\n#define RK3399_SET_ODT_PD_1_PD_IDLE\t\t\tGENMASK(11, 0)\n#define RK3399_SET_ODT_PD_1_SRPD_LITE_IDLE\t\tGENMASK(27, 16)\n\n#define RK3399_SET_ODT_PD_2_ODT_ENABLE\t\t\tBIT(0)\n\nstruct rk3399_dmcfreq {\n\tstruct device *dev;\n\tstruct devfreq *devfreq;\n\tstruct devfreq_dev_profile profile;\n\tstruct devfreq_simple_ondemand_data ondemand_data;\n\tstruct clk *dmc_clk;\n\tstruct devfreq_event_dev *edev;\n\tstruct mutex lock;\n\tstruct regulator *vdd_center;\n\tstruct regmap *regmap_pmu;\n\tunsigned long rate, target_rate;\n\tunsigned long volt, target_volt;\n\tunsigned int odt_dis_freq;\n\n\tunsigned int pd_idle_ns;\n\tunsigned int sr_idle_ns;\n\tunsigned int sr_mc_gate_idle_ns;\n\tunsigned int srpd_lite_idle_ns;\n\tunsigned int standby_idle_ns;\n\tunsigned int ddr3_odt_dis_freq;\n\tunsigned int lpddr3_odt_dis_freq;\n\tunsigned int lpddr4_odt_dis_freq;\n\n\tunsigned int pd_idle_dis_freq;\n\tunsigned int sr_idle_dis_freq;\n\tunsigned int sr_mc_gate_idle_dis_freq;\n\tunsigned int srpd_lite_idle_dis_freq;\n\tunsigned int standby_idle_dis_freq;\n};\n\nstatic int rk3399_dmcfreq_target(struct device *dev, unsigned long *freq,\n\t\t\t\t u32 flags)\n{\n\tstruct rk3399_dmcfreq *dmcfreq = dev_get_drvdata(dev);\n\tstruct dev_pm_opp *opp;\n\tunsigned long old_clk_rate = dmcfreq->rate;\n\tunsigned long target_volt, target_rate;\n\tunsigned int ddrcon_mhz;\n\tstruct arm_smccc_res res;\n\tint err;\n\n\tu32 odt_pd_arg0 = 0;\n\tu32 odt_pd_arg1 = 0;\n\tu32 odt_pd_arg2 = 0;\n\n\topp = devfreq_recommended_opp(dev, freq, flags);\n\tif (IS_ERR(opp))\n\t\treturn PTR_ERR(opp);\n\n\ttarget_rate = dev_pm_opp_get_freq(opp);\n\ttarget_volt = dev_pm_opp_get_voltage(opp);\n\tdev_pm_opp_put(opp);\n\n\tif (dmcfreq->rate == target_rate)\n\t\treturn 0;\n\n\tmutex_lock(&dmcfreq->lock);\n\n\t \n\terr = rockchip_pmu_block();\n\tif (err) {\n\t\tdev_err(dev, \"Failed to block PMU: %d\\n\", err);\n\t\tgoto out_unlock;\n\t}\n\n\t \n\tddrcon_mhz = target_rate / USEC_PER_SEC / 2;\n\n\tu32p_replace_bits(&odt_pd_arg1,\n\t\t\t  NS_TO_CYCLE(dmcfreq->pd_idle_ns, ddrcon_mhz),\n\t\t\t  RK3399_SET_ODT_PD_1_PD_IDLE);\n\tu32p_replace_bits(&odt_pd_arg0,\n\t\t\t  NS_TO_CYCLE(dmcfreq->standby_idle_ns, ddrcon_mhz),\n\t\t\t  RK3399_SET_ODT_PD_0_STANDBY_IDLE);\n\tu32p_replace_bits(&odt_pd_arg0,\n\t\t\t  DIV_ROUND_UP(NS_TO_CYCLE(dmcfreq->sr_idle_ns,\n\t\t\t\t\t\t   ddrcon_mhz), 1024),\n\t\t\t  RK3399_SET_ODT_PD_0_SR_IDLE);\n\tu32p_replace_bits(&odt_pd_arg0,\n\t\t\t  DIV_ROUND_UP(NS_TO_CYCLE(dmcfreq->sr_mc_gate_idle_ns,\n\t\t\t\t\t\t   ddrcon_mhz), 1024),\n\t\t\t  RK3399_SET_ODT_PD_0_SR_MC_GATE_IDLE);\n\tu32p_replace_bits(&odt_pd_arg1,\n\t\t\t  DIV_ROUND_UP(NS_TO_CYCLE(dmcfreq->srpd_lite_idle_ns,\n\t\t\t\t\t\t   ddrcon_mhz), 1024),\n\t\t\t  RK3399_SET_ODT_PD_1_SRPD_LITE_IDLE);\n\n\tif (dmcfreq->regmap_pmu) {\n\t\tif (target_rate >= dmcfreq->sr_idle_dis_freq)\n\t\t\todt_pd_arg0 &= ~RK3399_SET_ODT_PD_0_SR_IDLE;\n\n\t\tif (target_rate >= dmcfreq->sr_mc_gate_idle_dis_freq)\n\t\t\todt_pd_arg0 &= ~RK3399_SET_ODT_PD_0_SR_MC_GATE_IDLE;\n\n\t\tif (target_rate >= dmcfreq->standby_idle_dis_freq)\n\t\t\todt_pd_arg0 &= ~RK3399_SET_ODT_PD_0_STANDBY_IDLE;\n\n\t\tif (target_rate >= dmcfreq->pd_idle_dis_freq)\n\t\t\todt_pd_arg1 &= ~RK3399_SET_ODT_PD_1_PD_IDLE;\n\n\t\tif (target_rate >= dmcfreq->srpd_lite_idle_dis_freq)\n\t\t\todt_pd_arg1 &= ~RK3399_SET_ODT_PD_1_SRPD_LITE_IDLE;\n\n\t\tif (target_rate >= dmcfreq->odt_dis_freq)\n\t\t\todt_pd_arg2 |= RK3399_SET_ODT_PD_2_ODT_ENABLE;\n\n\t\t \n\t\tarm_smccc_smc(ROCKCHIP_SIP_DRAM_FREQ, odt_pd_arg0, odt_pd_arg1,\n\t\t\t      ROCKCHIP_SIP_CONFIG_DRAM_SET_ODT_PD, odt_pd_arg2,\n\t\t\t      0, 0, 0, &res);\n\t}\n\n\t \n\tif (old_clk_rate < target_rate) {\n\t\terr = regulator_set_voltage(dmcfreq->vdd_center, target_volt,\n\t\t\t\t\t    target_volt);\n\t\tif (err) {\n\t\t\tdev_err(dev, \"Cannot set voltage %lu uV\\n\",\n\t\t\t\ttarget_volt);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\terr = clk_set_rate(dmcfreq->dmc_clk, target_rate);\n\tif (err) {\n\t\tdev_err(dev, \"Cannot set frequency %lu (%d)\\n\", target_rate,\n\t\t\terr);\n\t\tregulator_set_voltage(dmcfreq->vdd_center, dmcfreq->volt,\n\t\t\t\t      dmcfreq->volt);\n\t\tgoto out;\n\t}\n\n\t \n\tdmcfreq->rate = clk_get_rate(dmcfreq->dmc_clk);\n\n\t \n\tif (dmcfreq->rate != target_rate) {\n\t\tdev_err(dev, \"Got wrong frequency, Request %lu, Current %lu\\n\",\n\t\t\ttarget_rate, dmcfreq->rate);\n\t\tregulator_set_voltage(dmcfreq->vdd_center, dmcfreq->volt,\n\t\t\t\t      dmcfreq->volt);\n\t\tgoto out;\n\t} else if (old_clk_rate > target_rate)\n\t\terr = regulator_set_voltage(dmcfreq->vdd_center, target_volt,\n\t\t\t\t\t    target_volt);\n\tif (err)\n\t\tdev_err(dev, \"Cannot set voltage %lu uV\\n\", target_volt);\n\n\tdmcfreq->rate = target_rate;\n\tdmcfreq->volt = target_volt;\n\nout:\n\trockchip_pmu_unblock();\nout_unlock:\n\tmutex_unlock(&dmcfreq->lock);\n\treturn err;\n}\n\nstatic int rk3399_dmcfreq_get_dev_status(struct device *dev,\n\t\t\t\t\t struct devfreq_dev_status *stat)\n{\n\tstruct rk3399_dmcfreq *dmcfreq = dev_get_drvdata(dev);\n\tstruct devfreq_event_data edata;\n\tint ret = 0;\n\n\tret = devfreq_event_get_event(dmcfreq->edev, &edata);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tstat->current_frequency = dmcfreq->rate;\n\tstat->busy_time = edata.load_count;\n\tstat->total_time = edata.total_count;\n\n\treturn ret;\n}\n\nstatic int rk3399_dmcfreq_get_cur_freq(struct device *dev, unsigned long *freq)\n{\n\tstruct rk3399_dmcfreq *dmcfreq = dev_get_drvdata(dev);\n\n\t*freq = dmcfreq->rate;\n\n\treturn 0;\n}\n\nstatic __maybe_unused int rk3399_dmcfreq_suspend(struct device *dev)\n{\n\tstruct rk3399_dmcfreq *dmcfreq = dev_get_drvdata(dev);\n\tint ret = 0;\n\n\tret = devfreq_event_disable_edev(dmcfreq->edev);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to disable the devfreq-event devices\\n\");\n\t\treturn ret;\n\t}\n\n\tret = devfreq_suspend_device(dmcfreq->devfreq);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to suspend the devfreq devices\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic __maybe_unused int rk3399_dmcfreq_resume(struct device *dev)\n{\n\tstruct rk3399_dmcfreq *dmcfreq = dev_get_drvdata(dev);\n\tint ret = 0;\n\n\tret = devfreq_event_enable_edev(dmcfreq->edev);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to enable the devfreq-event devices\\n\");\n\t\treturn ret;\n\t}\n\n\tret = devfreq_resume_device(dmcfreq->devfreq);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to resume the devfreq devices\\n\");\n\t\treturn ret;\n\t}\n\treturn ret;\n}\n\nstatic SIMPLE_DEV_PM_OPS(rk3399_dmcfreq_pm, rk3399_dmcfreq_suspend,\n\t\t\t rk3399_dmcfreq_resume);\n\nstatic int rk3399_dmcfreq_of_props(struct rk3399_dmcfreq *data,\n\t\t\t\t   struct device_node *np)\n{\n\tint ret = 0;\n\n\t \n\tdata->pd_idle_dis_freq =\n\t\tdata->sr_idle_dis_freq =\n\t\tdata->sr_mc_gate_idle_dis_freq =\n\t\tdata->srpd_lite_idle_dis_freq =\n\t\tdata->standby_idle_dis_freq = UINT_MAX;\n\n\tret |= of_property_read_u32(np, \"rockchip,pd-idle-ns\",\n\t\t\t\t    &data->pd_idle_ns);\n\tret |= of_property_read_u32(np, \"rockchip,sr-idle-ns\",\n\t\t\t\t    &data->sr_idle_ns);\n\tret |= of_property_read_u32(np, \"rockchip,sr-mc-gate-idle-ns\",\n\t\t\t\t    &data->sr_mc_gate_idle_ns);\n\tret |= of_property_read_u32(np, \"rockchip,srpd-lite-idle-ns\",\n\t\t\t\t    &data->srpd_lite_idle_ns);\n\tret |= of_property_read_u32(np, \"rockchip,standby-idle-ns\",\n\t\t\t\t    &data->standby_idle_ns);\n\tret |= of_property_read_u32(np, \"rockchip,ddr3_odt_dis_freq\",\n\t\t\t\t    &data->ddr3_odt_dis_freq);\n\tret |= of_property_read_u32(np, \"rockchip,lpddr3_odt_dis_freq\",\n\t\t\t\t    &data->lpddr3_odt_dis_freq);\n\tret |= of_property_read_u32(np, \"rockchip,lpddr4_odt_dis_freq\",\n\t\t\t\t    &data->lpddr4_odt_dis_freq);\n\n\tret |= of_property_read_u32(np, \"rockchip,pd-idle-dis-freq-hz\",\n\t\t\t\t    &data->pd_idle_dis_freq);\n\tret |= of_property_read_u32(np, \"rockchip,sr-idle-dis-freq-hz\",\n\t\t\t\t    &data->sr_idle_dis_freq);\n\tret |= of_property_read_u32(np, \"rockchip,sr-mc-gate-idle-dis-freq-hz\",\n\t\t\t\t    &data->sr_mc_gate_idle_dis_freq);\n\tret |= of_property_read_u32(np, \"rockchip,srpd-lite-idle-dis-freq-hz\",\n\t\t\t\t    &data->srpd_lite_idle_dis_freq);\n\tret |= of_property_read_u32(np, \"rockchip,standby-idle-dis-freq-hz\",\n\t\t\t\t    &data->standby_idle_dis_freq);\n\n\treturn ret;\n}\n\nstatic int rk3399_dmcfreq_probe(struct platform_device *pdev)\n{\n\tstruct arm_smccc_res res;\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np = pdev->dev.of_node, *node;\n\tstruct rk3399_dmcfreq *data;\n\tint ret;\n\tstruct dev_pm_opp *opp;\n\tu32 ddr_type;\n\tu32 val;\n\n\tdata = devm_kzalloc(dev, sizeof(struct rk3399_dmcfreq), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&data->lock);\n\n\tdata->vdd_center = devm_regulator_get(dev, \"center\");\n\tif (IS_ERR(data->vdd_center))\n\t\treturn dev_err_probe(dev, PTR_ERR(data->vdd_center),\n\t\t\t\t     \"Cannot get the regulator \\\"center\\\"\\n\");\n\n\tdata->dmc_clk = devm_clk_get(dev, \"dmc_clk\");\n\tif (IS_ERR(data->dmc_clk))\n\t\treturn dev_err_probe(dev, PTR_ERR(data->dmc_clk),\n\t\t\t\t     \"Cannot get the clk dmc_clk\\n\");\n\n\tdata->edev = devfreq_event_get_edev_by_phandle(dev, \"devfreq-events\", 0);\n\tif (IS_ERR(data->edev))\n\t\treturn -EPROBE_DEFER;\n\n\tret = devfreq_event_enable_edev(data->edev);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to enable devfreq-event devices\\n\");\n\t\treturn ret;\n\t}\n\n\trk3399_dmcfreq_of_props(data, np);\n\n\tnode = of_parse_phandle(np, \"rockchip,pmu\", 0);\n\tif (!node)\n\t\tgoto no_pmu;\n\n\tdata->regmap_pmu = syscon_node_to_regmap(node);\n\tof_node_put(node);\n\tif (IS_ERR(data->regmap_pmu)) {\n\t\tret = PTR_ERR(data->regmap_pmu);\n\t\tgoto err_edev;\n\t}\n\n\tregmap_read(data->regmap_pmu, RK3399_PMUGRF_OS_REG2, &val);\n\tddr_type = (val >> RK3399_PMUGRF_DDRTYPE_SHIFT) &\n\t\t    RK3399_PMUGRF_DDRTYPE_MASK;\n\n\tswitch (ddr_type) {\n\tcase RK3399_PMUGRF_DDRTYPE_DDR3:\n\t\tdata->odt_dis_freq = data->ddr3_odt_dis_freq;\n\t\tbreak;\n\tcase RK3399_PMUGRF_DDRTYPE_LPDDR3:\n\t\tdata->odt_dis_freq = data->lpddr3_odt_dis_freq;\n\t\tbreak;\n\tcase RK3399_PMUGRF_DDRTYPE_LPDDR4:\n\t\tdata->odt_dis_freq = data->lpddr4_odt_dis_freq;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto err_edev;\n\t}\n\nno_pmu:\n\tarm_smccc_smc(ROCKCHIP_SIP_DRAM_FREQ, 0, 0,\n\t\t      ROCKCHIP_SIP_CONFIG_DRAM_INIT,\n\t\t      0, 0, 0, 0, &res);\n\n\t \n\tif (devm_pm_opp_of_add_table(dev)) {\n\t\tdev_err(dev, \"Invalid operating-points in device tree.\\n\");\n\t\tret = -EINVAL;\n\t\tgoto err_edev;\n\t}\n\n\tdata->ondemand_data.upthreshold = 25;\n\tdata->ondemand_data.downdifferential = 15;\n\n\tdata->rate = clk_get_rate(data->dmc_clk);\n\n\topp = devfreq_recommended_opp(dev, &data->rate, 0);\n\tif (IS_ERR(opp)) {\n\t\tret = PTR_ERR(opp);\n\t\tgoto err_edev;\n\t}\n\n\tdata->rate = dev_pm_opp_get_freq(opp);\n\tdata->volt = dev_pm_opp_get_voltage(opp);\n\tdev_pm_opp_put(opp);\n\n\tdata->profile = (struct devfreq_dev_profile) {\n\t\t.polling_ms\t= 200,\n\t\t.target\t\t= rk3399_dmcfreq_target,\n\t\t.get_dev_status\t= rk3399_dmcfreq_get_dev_status,\n\t\t.get_cur_freq\t= rk3399_dmcfreq_get_cur_freq,\n\t\t.initial_freq\t= data->rate,\n\t};\n\n\tdata->devfreq = devm_devfreq_add_device(dev,\n\t\t\t\t\t   &data->profile,\n\t\t\t\t\t   DEVFREQ_GOV_SIMPLE_ONDEMAND,\n\t\t\t\t\t   &data->ondemand_data);\n\tif (IS_ERR(data->devfreq)) {\n\t\tret = PTR_ERR(data->devfreq);\n\t\tgoto err_edev;\n\t}\n\n\tdevm_devfreq_register_opp_notifier(dev, data->devfreq);\n\n\tdata->dev = dev;\n\tplatform_set_drvdata(pdev, data);\n\n\treturn 0;\n\nerr_edev:\n\tdevfreq_event_disable_edev(data->edev);\n\n\treturn ret;\n}\n\nstatic int rk3399_dmcfreq_remove(struct platform_device *pdev)\n{\n\tstruct rk3399_dmcfreq *dmcfreq = dev_get_drvdata(&pdev->dev);\n\n\tdevfreq_event_disable_edev(dmcfreq->edev);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id rk3399dmc_devfreq_of_match[] = {\n\t{ .compatible = \"rockchip,rk3399-dmc\" },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, rk3399dmc_devfreq_of_match);\n\nstatic struct platform_driver rk3399_dmcfreq_driver = {\n\t.probe\t= rk3399_dmcfreq_probe,\n\t.remove = rk3399_dmcfreq_remove,\n\t.driver = {\n\t\t.name\t= \"rk3399-dmc-freq\",\n\t\t.pm\t= &rk3399_dmcfreq_pm,\n\t\t.of_match_table = rk3399dmc_devfreq_of_match,\n\t},\n};\nmodule_platform_driver(rk3399_dmcfreq_driver);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Lin Huang <hl@rock-chips.com>\");\nMODULE_DESCRIPTION(\"RK3399 dmcfreq driver with devfreq framework\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}