{
  "module_name": "rockchip-dfi.c",
  "hash_id": "4d08cbe182d5c039ba424efd82a795598ed0984e0ed0b57f1daaff948e713d69",
  "original_prompt": "Ingested from linux-6.6.14/drivers/devfreq/event/rockchip-dfi.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/devfreq-event.h>\n#include <linux/kernel.h>\n#include <linux/err.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <linux/mfd/syscon.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/of.h>\n\n#include <soc/rockchip/rk3399_grf.h>\n\n#define RK3399_DMC_NUM_CH\t2\n\n \n#define DDRMON_CTRL\t0x04\n#define CLR_DDRMON_CTRL\t(0x1f0000 << 0)\n#define LPDDR4_EN\t(0x10001 << 4)\n#define HARDWARE_EN\t(0x10001 << 3)\n#define LPDDR3_EN\t(0x10001 << 2)\n#define SOFTWARE_EN\t(0x10001 << 1)\n#define SOFTWARE_DIS\t(0x10000 << 1)\n#define TIME_CNT_EN\t(0x10001 << 0)\n\n#define DDRMON_CH0_COUNT_NUM\t\t0x28\n#define DDRMON_CH0_DFI_ACCESS_NUM\t0x2c\n#define DDRMON_CH1_COUNT_NUM\t\t0x3c\n#define DDRMON_CH1_DFI_ACCESS_NUM\t0x40\n\nstruct dmc_usage {\n\tu32 access;\n\tu32 total;\n};\n\n \nstruct rockchip_dfi {\n\tstruct devfreq_event_dev *edev;\n\tstruct devfreq_event_desc *desc;\n\tstruct dmc_usage ch_usage[RK3399_DMC_NUM_CH];\n\tstruct device *dev;\n\tvoid __iomem *regs;\n\tstruct regmap *regmap_pmu;\n\tstruct clk *clk;\n};\n\nstatic void rockchip_dfi_start_hardware_counter(struct devfreq_event_dev *edev)\n{\n\tstruct rockchip_dfi *info = devfreq_event_get_drvdata(edev);\n\tvoid __iomem *dfi_regs = info->regs;\n\tu32 val;\n\tu32 ddr_type;\n\n\t \n\tregmap_read(info->regmap_pmu, RK3399_PMUGRF_OS_REG2, &val);\n\tddr_type = (val >> RK3399_PMUGRF_DDRTYPE_SHIFT) &\n\t\t    RK3399_PMUGRF_DDRTYPE_MASK;\n\n\t \n\twritel_relaxed(CLR_DDRMON_CTRL, dfi_regs + DDRMON_CTRL);\n\n\t \n\tif (ddr_type == RK3399_PMUGRF_DDRTYPE_LPDDR3)\n\t\twritel_relaxed(LPDDR3_EN, dfi_regs + DDRMON_CTRL);\n\telse if (ddr_type == RK3399_PMUGRF_DDRTYPE_LPDDR4)\n\t\twritel_relaxed(LPDDR4_EN, dfi_regs + DDRMON_CTRL);\n\n\t \n\twritel_relaxed(SOFTWARE_EN, dfi_regs + DDRMON_CTRL);\n}\n\nstatic void rockchip_dfi_stop_hardware_counter(struct devfreq_event_dev *edev)\n{\n\tstruct rockchip_dfi *info = devfreq_event_get_drvdata(edev);\n\tvoid __iomem *dfi_regs = info->regs;\n\n\twritel_relaxed(SOFTWARE_DIS, dfi_regs + DDRMON_CTRL);\n}\n\nstatic int rockchip_dfi_get_busier_ch(struct devfreq_event_dev *edev)\n{\n\tstruct rockchip_dfi *info = devfreq_event_get_drvdata(edev);\n\tu32 tmp, max = 0;\n\tu32 i, busier_ch = 0;\n\tvoid __iomem *dfi_regs = info->regs;\n\n\trockchip_dfi_stop_hardware_counter(edev);\n\n\t \n\tfor (i = 0; i < RK3399_DMC_NUM_CH; i++) {\n\t\tinfo->ch_usage[i].access = readl_relaxed(dfi_regs +\n\t\t\t\tDDRMON_CH0_DFI_ACCESS_NUM + i * 20) * 4;\n\t\tinfo->ch_usage[i].total = readl_relaxed(dfi_regs +\n\t\t\t\tDDRMON_CH0_COUNT_NUM + i * 20);\n\t\ttmp = info->ch_usage[i].access;\n\t\tif (tmp > max) {\n\t\t\tbusier_ch = i;\n\t\t\tmax = tmp;\n\t\t}\n\t}\n\trockchip_dfi_start_hardware_counter(edev);\n\n\treturn busier_ch;\n}\n\nstatic int rockchip_dfi_disable(struct devfreq_event_dev *edev)\n{\n\tstruct rockchip_dfi *info = devfreq_event_get_drvdata(edev);\n\n\trockchip_dfi_stop_hardware_counter(edev);\n\tclk_disable_unprepare(info->clk);\n\n\treturn 0;\n}\n\nstatic int rockchip_dfi_enable(struct devfreq_event_dev *edev)\n{\n\tstruct rockchip_dfi *info = devfreq_event_get_drvdata(edev);\n\tint ret;\n\n\tret = clk_prepare_enable(info->clk);\n\tif (ret) {\n\t\tdev_err(&edev->dev, \"failed to enable dfi clk: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\trockchip_dfi_start_hardware_counter(edev);\n\treturn 0;\n}\n\nstatic int rockchip_dfi_set_event(struct devfreq_event_dev *edev)\n{\n\treturn 0;\n}\n\nstatic int rockchip_dfi_get_event(struct devfreq_event_dev *edev,\n\t\t\t\t  struct devfreq_event_data *edata)\n{\n\tstruct rockchip_dfi *info = devfreq_event_get_drvdata(edev);\n\tint busier_ch;\n\n\tbusier_ch = rockchip_dfi_get_busier_ch(edev);\n\n\tedata->load_count = info->ch_usage[busier_ch].access;\n\tedata->total_count = info->ch_usage[busier_ch].total;\n\n\treturn 0;\n}\n\nstatic const struct devfreq_event_ops rockchip_dfi_ops = {\n\t.disable = rockchip_dfi_disable,\n\t.enable = rockchip_dfi_enable,\n\t.get_event = rockchip_dfi_get_event,\n\t.set_event = rockchip_dfi_set_event,\n};\n\nstatic const struct of_device_id rockchip_dfi_id_match[] = {\n\t{ .compatible = \"rockchip,rk3399-dfi\" },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, rockchip_dfi_id_match);\n\nstatic int rockchip_dfi_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct rockchip_dfi *data;\n\tstruct devfreq_event_desc *desc;\n\tstruct device_node *np = pdev->dev.of_node, *node;\n\n\tdata = devm_kzalloc(dev, sizeof(struct rockchip_dfi), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tdata->regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(data->regs))\n\t\treturn PTR_ERR(data->regs);\n\n\tdata->clk = devm_clk_get(dev, \"pclk_ddr_mon\");\n\tif (IS_ERR(data->clk))\n\t\treturn dev_err_probe(dev, PTR_ERR(data->clk),\n\t\t\t\t     \"Cannot get the clk pclk_ddr_mon\\n\");\n\n\tnode = of_parse_phandle(np, \"rockchip,pmu\", 0);\n\tif (!node)\n\t\treturn dev_err_probe(&pdev->dev, -ENODEV, \"Can't find pmu_grf registers\\n\");\n\n\tdata->regmap_pmu = syscon_node_to_regmap(node);\n\tof_node_put(node);\n\tif (IS_ERR(data->regmap_pmu))\n\t\treturn PTR_ERR(data->regmap_pmu);\n\n\tdata->dev = dev;\n\n\tdesc = devm_kzalloc(dev, sizeof(*desc), GFP_KERNEL);\n\tif (!desc)\n\t\treturn -ENOMEM;\n\n\tdesc->ops = &rockchip_dfi_ops;\n\tdesc->driver_data = data;\n\tdesc->name = np->name;\n\tdata->desc = desc;\n\n\tdata->edev = devm_devfreq_event_add_edev(&pdev->dev, desc);\n\tif (IS_ERR(data->edev)) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"failed to add devfreq-event device\\n\");\n\t\treturn PTR_ERR(data->edev);\n\t}\n\n\tplatform_set_drvdata(pdev, data);\n\n\treturn 0;\n}\n\nstatic struct platform_driver rockchip_dfi_driver = {\n\t.probe\t= rockchip_dfi_probe,\n\t.driver = {\n\t\t.name\t= \"rockchip-dfi\",\n\t\t.of_match_table = rockchip_dfi_id_match,\n\t},\n};\nmodule_platform_driver(rockchip_dfi_driver);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Lin Huang <hl@rock-chips.com>\");\nMODULE_DESCRIPTION(\"Rockchip DFI driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}