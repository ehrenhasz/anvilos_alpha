{
  "module_name": "exynos-ppmu.c",
  "hash_id": "8fbf297574592df4f325dc2a03f14cdac2023382c907af08df369a5c13e07aa0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/devfreq/event/exynos-ppmu.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of_address.h>\n#include <linux/of_device.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/suspend.h>\n#include <linux/devfreq-event.h>\n\n#include \"exynos-ppmu.h\"\n\nenum exynos_ppmu_type {\n\tEXYNOS_TYPE_PPMU,\n\tEXYNOS_TYPE_PPMU_V2,\n};\n\nstruct exynos_ppmu_data {\n\tstruct clk *clk;\n};\n\nstruct exynos_ppmu {\n\tstruct devfreq_event_dev **edev;\n\tstruct devfreq_event_desc *desc;\n\tunsigned int num_events;\n\n\tstruct device *dev;\n\tstruct regmap *regmap;\n\n\tstruct exynos_ppmu_data ppmu;\n\tenum exynos_ppmu_type ppmu_type;\n};\n\n#define PPMU_EVENT(name)\t\t\t\\\n\t{ \"ppmu-event0-\"#name, PPMU_PMNCNT0 },\t\\\n\t{ \"ppmu-event1-\"#name, PPMU_PMNCNT1 },\t\\\n\t{ \"ppmu-event2-\"#name, PPMU_PMNCNT2 },\t\\\n\t{ \"ppmu-event3-\"#name, PPMU_PMNCNT3 }\n\nstatic struct __exynos_ppmu_events {\n\tchar *name;\n\tint id;\n} ppmu_events[] = {\n\t \n\tPPMU_EVENT(g3d),\n\tPPMU_EVENT(fsys),\n\n\t \n\tPPMU_EVENT(dmc0),\n\tPPMU_EVENT(dmc1),\n\tPPMU_EVENT(cpu),\n\tPPMU_EVENT(rightbus),\n\tPPMU_EVENT(leftbus),\n\tPPMU_EVENT(lcd0),\n\tPPMU_EVENT(camif),\n\n\t \n\tPPMU_EVENT(mfc),\n\n\t \n\tPPMU_EVENT(mfc-left),\n\tPPMU_EVENT(mfc-right),\n\n\t \n\tPPMU_EVENT(drex0-s0),\n\tPPMU_EVENT(drex0-s1),\n\tPPMU_EVENT(drex1-s0),\n\tPPMU_EVENT(drex1-s1),\n\tPPMU_EVENT(eagle),\n\tPPMU_EVENT(kfc),\n\tPPMU_EVENT(isp),\n\tPPMU_EVENT(fimc),\n\tPPMU_EVENT(gscl),\n\tPPMU_EVENT(mscl),\n\tPPMU_EVENT(fimd0x),\n\tPPMU_EVENT(fimd1x),\n\n\t \n\tPPMU_EVENT(d0-cpu),\n\tPPMU_EVENT(d0-general),\n\tPPMU_EVENT(d0-rt),\n\tPPMU_EVENT(d1-cpu),\n\tPPMU_EVENT(d1-general),\n\tPPMU_EVENT(d1-rt),\n\n\t \n\tPPMU_EVENT(dmc0_0),\n\tPPMU_EVENT(dmc0_1),\n\tPPMU_EVENT(dmc1_0),\n\tPPMU_EVENT(dmc1_1),\n\t \n\tPPMU_EVENT(dmc0-0),\n\tPPMU_EVENT(dmc0-1),\n\tPPMU_EVENT(dmc1-0),\n\tPPMU_EVENT(dmc1-1),\n};\n\nstatic int __exynos_ppmu_find_ppmu_id(const char *edev_name)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(ppmu_events); i++)\n\t\tif (!strcmp(edev_name, ppmu_events[i].name))\n\t\t\treturn ppmu_events[i].id;\n\n\treturn -EINVAL;\n}\n\nstatic int exynos_ppmu_find_ppmu_id(struct devfreq_event_dev *edev)\n{\n\treturn __exynos_ppmu_find_ppmu_id(edev->desc->name);\n}\n\n \nstatic int exynos_ppmu_disable(struct devfreq_event_dev *edev)\n{\n\tstruct exynos_ppmu *info = devfreq_event_get_drvdata(edev);\n\tint ret;\n\tu32 pmnc;\n\n\t \n\tret = regmap_write(info->regmap, PPMU_CNTENC,\n\t\t\t\tPPMU_CCNT_MASK |\n\t\t\t\tPPMU_PMCNT0_MASK |\n\t\t\t\tPPMU_PMCNT1_MASK |\n\t\t\t\tPPMU_PMCNT2_MASK |\n\t\t\t\tPPMU_PMCNT3_MASK);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = regmap_read(info->regmap, PPMU_PMNC, &pmnc);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tpmnc &= ~PPMU_PMNC_ENABLE_MASK;\n\tret = regmap_write(info->regmap, PPMU_PMNC, pmnc);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int exynos_ppmu_set_event(struct devfreq_event_dev *edev)\n{\n\tstruct exynos_ppmu *info = devfreq_event_get_drvdata(edev);\n\tint id = exynos_ppmu_find_ppmu_id(edev);\n\tint ret;\n\tu32 pmnc, cntens;\n\n\tif (id < 0)\n\t\treturn id;\n\n\t \n\tret = regmap_read(info->regmap, PPMU_CNTENS, &cntens);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tcntens |= (PPMU_CCNT_MASK | (PPMU_ENABLE << id));\n\tret = regmap_write(info->regmap, PPMU_CNTENS, cntens);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = regmap_write(info->regmap, PPMU_BEVTxSEL(id),\n\t\t\t   edev->desc->event_type);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = regmap_read(info->regmap, PPMU_PMNC, &pmnc);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tpmnc &= ~(PPMU_PMNC_ENABLE_MASK\n\t\t\t| PPMU_PMNC_COUNTER_RESET_MASK\n\t\t\t| PPMU_PMNC_CC_RESET_MASK);\n\tpmnc |= (PPMU_ENABLE << PPMU_PMNC_ENABLE_SHIFT);\n\tpmnc |= (PPMU_ENABLE << PPMU_PMNC_COUNTER_RESET_SHIFT);\n\tpmnc |= (PPMU_ENABLE << PPMU_PMNC_CC_RESET_SHIFT);\n\tret = regmap_write(info->regmap, PPMU_PMNC, pmnc);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int exynos_ppmu_get_event(struct devfreq_event_dev *edev,\n\t\t\t\tstruct devfreq_event_data *edata)\n{\n\tstruct exynos_ppmu *info = devfreq_event_get_drvdata(edev);\n\tint id = exynos_ppmu_find_ppmu_id(edev);\n\tunsigned int total_count, load_count;\n\tunsigned int pmcnt3_high, pmcnt3_low;\n\tunsigned int pmnc, cntenc;\n\tint ret;\n\n\tif (id < 0)\n\t\treturn -EINVAL;\n\n\t \n\tret = regmap_read(info->regmap, PPMU_PMNC, &pmnc);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tpmnc &= ~PPMU_PMNC_ENABLE_MASK;\n\tret = regmap_write(info->regmap, PPMU_PMNC, pmnc);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = regmap_read(info->regmap, PPMU_CCNT, &total_count);\n\tif (ret < 0)\n\t\treturn ret;\n\tedata->total_count = total_count;\n\n\t \n\tswitch (id) {\n\tcase PPMU_PMNCNT0:\n\tcase PPMU_PMNCNT1:\n\tcase PPMU_PMNCNT2:\n\t\tret = regmap_read(info->regmap, PPMU_PMNCT(id), &load_count);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tedata->load_count = load_count;\n\t\tbreak;\n\tcase PPMU_PMNCNT3:\n\t\tret = regmap_read(info->regmap, PPMU_PMCNT3_HIGH, &pmcnt3_high);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tret = regmap_read(info->regmap, PPMU_PMCNT3_LOW, &pmcnt3_low);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tedata->load_count = ((pmcnt3_high << 8) | pmcnt3_low);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tret = regmap_read(info->regmap, PPMU_CNTENC, &cntenc);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tcntenc |= (PPMU_CCNT_MASK | (PPMU_ENABLE << id));\n\tret = regmap_write(info->regmap, PPMU_CNTENC, cntenc);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdev_dbg(&edev->dev, \"%s (event: %ld/%ld)\\n\", edev->desc->name,\n\t\t\t\t\tedata->load_count, edata->total_count);\n\n\treturn 0;\n}\n\nstatic const struct devfreq_event_ops exynos_ppmu_ops = {\n\t.disable = exynos_ppmu_disable,\n\t.set_event = exynos_ppmu_set_event,\n\t.get_event = exynos_ppmu_get_event,\n};\n\n \nstatic int exynos_ppmu_v2_disable(struct devfreq_event_dev *edev)\n{\n\tstruct exynos_ppmu *info = devfreq_event_get_drvdata(edev);\n\tint ret;\n\tu32 pmnc, clear;\n\n\t \n\tclear = (PPMU_CCNT_MASK | PPMU_PMCNT0_MASK | PPMU_PMCNT1_MASK\n\t\t| PPMU_PMCNT2_MASK | PPMU_PMCNT3_MASK);\n\tret = regmap_write(info->regmap, PPMU_V2_FLAG, clear);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = regmap_write(info->regmap, PPMU_V2_INTENC, clear);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = regmap_write(info->regmap, PPMU_V2_CNTENC, clear);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = regmap_write(info->regmap, PPMU_V2_CNT_RESET, clear);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = regmap_write(info->regmap, PPMU_V2_CIG_CFG0, 0x0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = regmap_write(info->regmap, PPMU_V2_CIG_CFG1, 0x0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = regmap_write(info->regmap, PPMU_V2_CIG_CFG2, 0x0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = regmap_write(info->regmap, PPMU_V2_CIG_RESULT, 0x0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = regmap_write(info->regmap, PPMU_V2_CNT_AUTO, 0x0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = regmap_write(info->regmap, PPMU_V2_CH_EV0_TYPE, 0x0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = regmap_write(info->regmap, PPMU_V2_CH_EV1_TYPE, 0x0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = regmap_write(info->regmap, PPMU_V2_CH_EV2_TYPE, 0x0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = regmap_write(info->regmap, PPMU_V2_CH_EV3_TYPE, 0x0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = regmap_write(info->regmap, PPMU_V2_SM_ID_V, 0x0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = regmap_write(info->regmap, PPMU_V2_SM_ID_A, 0x0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = regmap_write(info->regmap, PPMU_V2_SM_OTHERS_V, 0x0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = regmap_write(info->regmap, PPMU_V2_SM_OTHERS_A, 0x0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = regmap_write(info->regmap, PPMU_V2_INTERRUPT_RESET, 0x0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = regmap_read(info->regmap, PPMU_V2_PMNC, &pmnc);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tpmnc &= ~PPMU_PMNC_ENABLE_MASK;\n\tret = regmap_write(info->regmap, PPMU_V2_PMNC, pmnc);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int exynos_ppmu_v2_set_event(struct devfreq_event_dev *edev)\n{\n\tstruct exynos_ppmu *info = devfreq_event_get_drvdata(edev);\n\tunsigned int pmnc, cntens;\n\tint id = exynos_ppmu_find_ppmu_id(edev);\n\tint ret;\n\n\t \n\tret = regmap_read(info->regmap, PPMU_V2_CNTENS, &cntens);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tcntens |= (PPMU_CCNT_MASK | (PPMU_ENABLE << id));\n\tret = regmap_write(info->regmap, PPMU_V2_CNTENS, cntens);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = regmap_write(info->regmap, PPMU_V2_CH_EVx_TYPE(id),\n\t\t\t   edev->desc->event_type);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = regmap_read(info->regmap, PPMU_V2_PMNC, &pmnc);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tpmnc &= ~(PPMU_PMNC_ENABLE_MASK\n\t\t\t| PPMU_PMNC_COUNTER_RESET_MASK\n\t\t\t| PPMU_PMNC_CC_RESET_MASK\n\t\t\t| PPMU_PMNC_CC_DIVIDER_MASK\n\t\t\t| PPMU_V2_PMNC_START_MODE_MASK);\n\tpmnc |= (PPMU_ENABLE << PPMU_PMNC_ENABLE_SHIFT);\n\tpmnc |= (PPMU_ENABLE << PPMU_PMNC_COUNTER_RESET_SHIFT);\n\tpmnc |= (PPMU_ENABLE << PPMU_PMNC_CC_RESET_SHIFT);\n\tpmnc |= (PPMU_V2_MODE_MANUAL << PPMU_V2_PMNC_START_MODE_SHIFT);\n\n\tret = regmap_write(info->regmap, PPMU_V2_PMNC, pmnc);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int exynos_ppmu_v2_get_event(struct devfreq_event_dev *edev,\n\t\t\t\t    struct devfreq_event_data *edata)\n{\n\tstruct exynos_ppmu *info = devfreq_event_get_drvdata(edev);\n\tint id = exynos_ppmu_find_ppmu_id(edev);\n\tint ret;\n\tunsigned int pmnc, cntenc;\n\tunsigned int pmcnt_high, pmcnt_low;\n\tunsigned int total_count, count;\n\tunsigned long load_count = 0;\n\n\t \n\tret = regmap_read(info->regmap, PPMU_V2_PMNC, &pmnc);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tpmnc &= ~PPMU_PMNC_ENABLE_MASK;\n\tret = regmap_write(info->regmap, PPMU_V2_PMNC, pmnc);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = regmap_read(info->regmap, PPMU_V2_CCNT, &total_count);\n\tif (ret < 0)\n\t\treturn ret;\n\tedata->total_count = total_count;\n\n\tswitch (id) {\n\tcase PPMU_PMNCNT0:\n\tcase PPMU_PMNCNT1:\n\tcase PPMU_PMNCNT2:\n\t\tret = regmap_read(info->regmap, PPMU_V2_PMNCT(id), &count);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tload_count = count;\n\t\tbreak;\n\tcase PPMU_PMNCNT3:\n\t\tret = regmap_read(info->regmap, PPMU_V2_PMCNT3_HIGH,\n\t\t\t\t\t\t&pmcnt_high);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tret = regmap_read(info->regmap, PPMU_V2_PMCNT3_LOW, &pmcnt_low);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tload_count = ((u64)((pmcnt_high & 0xff)) << 32)+ (u64)pmcnt_low;\n\t\tbreak;\n\t}\n\tedata->load_count = load_count;\n\n\t \n\tret = regmap_read(info->regmap, PPMU_V2_CNTENC, &cntenc);\n\tif (ret < 0)\n\t\treturn 0;\n\n\tcntenc |= (PPMU_CCNT_MASK | (PPMU_ENABLE << id));\n\tret = regmap_write(info->regmap, PPMU_V2_CNTENC, cntenc);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdev_dbg(&edev->dev, \"%25s (load: %ld / %ld)\\n\", edev->desc->name,\n\t\t\t\t\tedata->load_count, edata->total_count);\n\treturn 0;\n}\n\nstatic const struct devfreq_event_ops exynos_ppmu_v2_ops = {\n\t.disable = exynos_ppmu_v2_disable,\n\t.set_event = exynos_ppmu_v2_set_event,\n\t.get_event = exynos_ppmu_v2_get_event,\n};\n\nstatic const struct of_device_id exynos_ppmu_id_match[] = {\n\t{\n\t\t.compatible = \"samsung,exynos-ppmu\",\n\t\t.data = (void *)EXYNOS_TYPE_PPMU,\n\t}, {\n\t\t.compatible = \"samsung,exynos-ppmu-v2\",\n\t\t.data = (void *)EXYNOS_TYPE_PPMU_V2,\n\t},\n\t{   },\n};\nMODULE_DEVICE_TABLE(of, exynos_ppmu_id_match);\n\nstatic int of_get_devfreq_events(struct device_node *np,\n\t\t\t\t struct exynos_ppmu *info)\n{\n\tstruct devfreq_event_desc *desc;\n\tstruct device *dev = info->dev;\n\tstruct device_node *events_np, *node;\n\tint i, j, count;\n\tconst struct of_device_id *of_id;\n\tint ret;\n\n\tevents_np = of_get_child_by_name(np, \"events\");\n\tif (!events_np) {\n\t\tdev_err(dev,\n\t\t\t\"failed to get child node of devfreq-event devices\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tcount = of_get_child_count(events_np);\n\tdesc = devm_kcalloc(dev, count, sizeof(*desc), GFP_KERNEL);\n\tif (!desc) {\n\t\tof_node_put(events_np);\n\t\treturn -ENOMEM;\n\t}\n\tinfo->num_events = count;\n\n\tof_id = of_match_device(exynos_ppmu_id_match, dev);\n\tif (of_id)\n\t\tinfo->ppmu_type = (enum exynos_ppmu_type)of_id->data;\n\telse {\n\t\tof_node_put(events_np);\n\t\treturn -EINVAL;\n\t}\n\n\tj = 0;\n\tfor_each_child_of_node(events_np, node) {\n\t\tfor (i = 0; i < ARRAY_SIZE(ppmu_events); i++) {\n\t\t\tif (!ppmu_events[i].name)\n\t\t\t\tcontinue;\n\n\t\t\tif (of_node_name_eq(node, ppmu_events[i].name))\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (i == ARRAY_SIZE(ppmu_events)) {\n\t\t\tdev_warn(dev,\n\t\t\t\t\"don't know how to configure events : %pOFn\\n\",\n\t\t\t\tnode);\n\t\t\tcontinue;\n\t\t}\n\n\t\tswitch (info->ppmu_type) {\n\t\tcase EXYNOS_TYPE_PPMU:\n\t\t\tdesc[j].ops = &exynos_ppmu_ops;\n\t\t\tbreak;\n\t\tcase EXYNOS_TYPE_PPMU_V2:\n\t\t\tdesc[j].ops = &exynos_ppmu_v2_ops;\n\t\t\tbreak;\n\t\t}\n\n\t\tdesc[j].driver_data = info;\n\n\t\tof_property_read_string(node, \"event-name\", &desc[j].name);\n\t\tret = of_property_read_u32(node, \"event-data-type\",\n\t\t\t\t\t   &desc[j].event_type);\n\t\tif (ret) {\n\t\t\t \n\t\t\tif (info->ppmu_type == EXYNOS_TYPE_PPMU_V2) {\n\t\t\t\t \n\t\t\t\tswitch (ppmu_events[i].id) {\n\t\t\t\tcase PPMU_PMNCNT0:\n\t\t\t\tcase PPMU_PMNCNT1:\n\t\t\t\tcase PPMU_PMNCNT2:\n\t\t\t\t\tdesc[j].event_type = PPMU_V2_RO_DATA_CNT\n\t\t\t\t\t\t| PPMU_V2_WO_DATA_CNT;\n\t\t\t\t\tbreak;\n\t\t\t\tcase PPMU_PMNCNT3:\n\t\t\t\t\tdesc[j].event_type =\n\t\t\t\t\t\tPPMU_V2_EVT3_RW_DATA_CNT;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdesc[j].event_type = PPMU_RO_DATA_CNT |\n\t\t\t\t\tPPMU_WO_DATA_CNT;\n\t\t\t}\n\t\t}\n\n\t\tj++;\n\t}\n\tinfo->desc = desc;\n\n\tof_node_put(events_np);\n\n\treturn 0;\n}\n\nstatic struct regmap_config exynos_ppmu_regmap_config = {\n\t.reg_bits = 32,\n\t.val_bits = 32,\n\t.reg_stride = 4,\n};\n\nstatic int exynos_ppmu_parse_dt(struct platform_device *pdev,\n\t\t\t\tstruct exynos_ppmu *info)\n{\n\tstruct device *dev = info->dev;\n\tstruct device_node *np = dev->of_node;\n\tstruct resource *res;\n\tvoid __iomem *base;\n\tint ret = 0;\n\n\tif (!np) {\n\t\tdev_err(dev, \"failed to find devicetree node\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tbase = devm_platform_get_and_ioremap_resource(pdev, 0, &res);\n\tif (IS_ERR(base))\n\t\treturn PTR_ERR(base);\n\n\texynos_ppmu_regmap_config.max_register = resource_size(res) - 4;\n\tinfo->regmap = devm_regmap_init_mmio(dev, base,\n\t\t\t\t\t&exynos_ppmu_regmap_config);\n\tif (IS_ERR(info->regmap)) {\n\t\tdev_err(dev, \"failed to initialize regmap\\n\");\n\t\treturn PTR_ERR(info->regmap);\n\t}\n\n\tinfo->ppmu.clk = devm_clk_get(dev, \"ppmu\");\n\tif (IS_ERR(info->ppmu.clk)) {\n\t\tinfo->ppmu.clk = NULL;\n\t\tdev_warn(dev, \"cannot get PPMU clock\\n\");\n\t}\n\n\tret = of_get_devfreq_events(np, info);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to parse exynos ppmu dt node\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int exynos_ppmu_probe(struct platform_device *pdev)\n{\n\tstruct exynos_ppmu *info;\n\tstruct devfreq_event_dev **edev;\n\tstruct devfreq_event_desc *desc;\n\tint i, ret = 0, size;\n\n\tinfo = devm_kzalloc(&pdev->dev, sizeof(*info), GFP_KERNEL);\n\tif (!info)\n\t\treturn -ENOMEM;\n\n\tinfo->dev = &pdev->dev;\n\n\t \n\tret = exynos_ppmu_parse_dt(pdev, info);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"failed to parse devicetree for resource\\n\");\n\t\treturn ret;\n\t}\n\tdesc = info->desc;\n\n\tsize = sizeof(struct devfreq_event_dev *) * info->num_events;\n\tinfo->edev = devm_kzalloc(&pdev->dev, size, GFP_KERNEL);\n\tif (!info->edev)\n\t\treturn -ENOMEM;\n\n\tedev = info->edev;\n\tplatform_set_drvdata(pdev, info);\n\n\tfor (i = 0; i < info->num_events; i++) {\n\t\tedev[i] = devm_devfreq_event_add_edev(&pdev->dev, &desc[i]);\n\t\tif (IS_ERR(edev[i])) {\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"failed to add devfreq-event device\\n\");\n\t\t\treturn PTR_ERR(edev[i]);\n\t\t}\n\n\t\tpr_info(\"exynos-ppmu: new PPMU device registered %s (%s)\\n\",\n\t\t\tdev_name(&pdev->dev), desc[i].name);\n\t}\n\n\tret = clk_prepare_enable(info->ppmu.clk);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to prepare ppmu clock\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int exynos_ppmu_remove(struct platform_device *pdev)\n{\n\tstruct exynos_ppmu *info = platform_get_drvdata(pdev);\n\n\tclk_disable_unprepare(info->ppmu.clk);\n\n\treturn 0;\n}\n\nstatic struct platform_driver exynos_ppmu_driver = {\n\t.probe\t= exynos_ppmu_probe,\n\t.remove\t= exynos_ppmu_remove,\n\t.driver = {\n\t\t.name\t= \"exynos-ppmu\",\n\t\t.of_match_table = exynos_ppmu_id_match,\n\t},\n};\nmodule_platform_driver(exynos_ppmu_driver);\n\nMODULE_DESCRIPTION(\"Exynos PPMU(Platform Performance Monitoring Unit) driver\");\nMODULE_AUTHOR(\"Chanwoo Choi <cw00.choi@samsung.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}