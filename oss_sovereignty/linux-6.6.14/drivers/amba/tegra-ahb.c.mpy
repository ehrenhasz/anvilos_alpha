{
  "module_name": "tegra-ahb.c",
  "hash_id": "936f681ddff04a57caf9f14e09ccc0a46e74abae9d94a5fc2624114cab87fef2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/amba/tegra-ahb.c",
  "human_readable_source": "\n \n\n#include <linux/err.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/io.h>\n#include <linux/of.h>\n\n#include <soc/tegra/ahb.h>\n\n#define DRV_NAME \"tegra-ahb\"\n\n#define AHB_ARBITRATION_DISABLE\t\t0x04\n#define AHB_ARBITRATION_PRIORITY_CTRL\t0x08\n#define   AHB_PRIORITY_WEIGHT(x)\t(((x) & 0x7) << 29)\n#define   PRIORITY_SELECT_USB BIT(6)\n#define   PRIORITY_SELECT_USB2 BIT(18)\n#define   PRIORITY_SELECT_USB3 BIT(17)\n\n#define AHB_GIZMO_AHB_MEM\t\t0x10\n#define   ENB_FAST_REARBITRATE BIT(2)\n#define   DONT_SPLIT_AHB_WR     BIT(7)\n\n#define AHB_GIZMO_APB_DMA\t\t0x14\n#define AHB_GIZMO_IDE\t\t\t0x1c\n#define AHB_GIZMO_USB\t\t\t0x20\n#define AHB_GIZMO_AHB_XBAR_BRIDGE\t0x24\n#define AHB_GIZMO_CPU_AHB_BRIDGE\t0x28\n#define AHB_GIZMO_COP_AHB_BRIDGE\t0x2c\n#define AHB_GIZMO_XBAR_APB_CTLR\t\t0x30\n#define AHB_GIZMO_VCP_AHB_BRIDGE\t0x34\n#define AHB_GIZMO_NAND\t\t\t0x40\n#define AHB_GIZMO_SDMMC4\t\t0x48\n#define AHB_GIZMO_XIO\t\t\t0x4c\n#define AHB_GIZMO_BSEV\t\t\t0x64\n#define AHB_GIZMO_BSEA\t\t\t0x74\n#define AHB_GIZMO_NOR\t\t\t0x78\n#define AHB_GIZMO_USB2\t\t\t0x7c\n#define AHB_GIZMO_USB3\t\t\t0x80\n#define   IMMEDIATE\tBIT(18)\n\n#define AHB_GIZMO_SDMMC1\t\t0x84\n#define AHB_GIZMO_SDMMC2\t\t0x88\n#define AHB_GIZMO_SDMMC3\t\t0x8c\n#define AHB_MEM_PREFETCH_CFG_X\t\t0xdc\n#define AHB_ARBITRATION_XBAR_CTRL\t0xe0\n#define AHB_MEM_PREFETCH_CFG3\t\t0xe4\n#define AHB_MEM_PREFETCH_CFG4\t\t0xe8\n#define AHB_MEM_PREFETCH_CFG1\t\t0xf0\n#define AHB_MEM_PREFETCH_CFG2\t\t0xf4\n#define   PREFETCH_ENB\tBIT(31)\n#define   MST_ID(x)\t(((x) & 0x1f) << 26)\n#define   AHBDMA_MST_ID\tMST_ID(5)\n#define   USB_MST_ID\tMST_ID(6)\n#define   USB2_MST_ID\tMST_ID(18)\n#define   USB3_MST_ID\tMST_ID(17)\n#define   ADDR_BNDRY(x)\t(((x) & 0xf) << 21)\n#define   INACTIVITY_TIMEOUT(x)\t(((x) & 0xffff) << 0)\n\n#define AHB_ARBITRATION_AHB_MEM_WRQUE_MST_ID\t0xfc\n\n#define AHB_ARBITRATION_XBAR_CTRL_SMMU_INIT_DONE BIT(17)\n\n \n#define INCORRECT_BASE_ADDR_LOW_BYTE\t\t0x4\n\nstatic struct platform_driver tegra_ahb_driver;\n\nstatic const u32 tegra_ahb_gizmo[] = {\n\tAHB_ARBITRATION_DISABLE,\n\tAHB_ARBITRATION_PRIORITY_CTRL,\n\tAHB_GIZMO_AHB_MEM,\n\tAHB_GIZMO_APB_DMA,\n\tAHB_GIZMO_IDE,\n\tAHB_GIZMO_USB,\n\tAHB_GIZMO_AHB_XBAR_BRIDGE,\n\tAHB_GIZMO_CPU_AHB_BRIDGE,\n\tAHB_GIZMO_COP_AHB_BRIDGE,\n\tAHB_GIZMO_XBAR_APB_CTLR,\n\tAHB_GIZMO_VCP_AHB_BRIDGE,\n\tAHB_GIZMO_NAND,\n\tAHB_GIZMO_SDMMC4,\n\tAHB_GIZMO_XIO,\n\tAHB_GIZMO_BSEV,\n\tAHB_GIZMO_BSEA,\n\tAHB_GIZMO_NOR,\n\tAHB_GIZMO_USB2,\n\tAHB_GIZMO_USB3,\n\tAHB_GIZMO_SDMMC1,\n\tAHB_GIZMO_SDMMC2,\n\tAHB_GIZMO_SDMMC3,\n\tAHB_MEM_PREFETCH_CFG_X,\n\tAHB_ARBITRATION_XBAR_CTRL,\n\tAHB_MEM_PREFETCH_CFG3,\n\tAHB_MEM_PREFETCH_CFG4,\n\tAHB_MEM_PREFETCH_CFG1,\n\tAHB_MEM_PREFETCH_CFG2,\n\tAHB_ARBITRATION_AHB_MEM_WRQUE_MST_ID,\n};\n\nstruct tegra_ahb {\n\tvoid __iomem\t*regs;\n\tstruct device\t*dev;\n\tu32\t\tctx[];\n};\n\nstatic inline u32 gizmo_readl(struct tegra_ahb *ahb, u32 offset)\n{\n\treturn readl(ahb->regs + offset);\n}\n\nstatic inline void gizmo_writel(struct tegra_ahb *ahb, u32 value, u32 offset)\n{\n\twritel(value, ahb->regs + offset);\n}\n\n#ifdef CONFIG_TEGRA_IOMMU_SMMU\nint tegra_ahb_enable_smmu(struct device_node *dn)\n{\n\tstruct device *dev;\n\tu32 val;\n\tstruct tegra_ahb *ahb;\n\n\tdev = driver_find_device_by_of_node(&tegra_ahb_driver.driver, dn);\n\tif (!dev)\n\t\treturn -EPROBE_DEFER;\n\tahb = dev_get_drvdata(dev);\n\tval = gizmo_readl(ahb, AHB_ARBITRATION_XBAR_CTRL);\n\tval |= AHB_ARBITRATION_XBAR_CTRL_SMMU_INIT_DONE;\n\tgizmo_writel(ahb, val, AHB_ARBITRATION_XBAR_CTRL);\n\treturn 0;\n}\nEXPORT_SYMBOL(tegra_ahb_enable_smmu);\n#endif\n\nstatic int __maybe_unused tegra_ahb_suspend(struct device *dev)\n{\n\tint i;\n\tstruct tegra_ahb *ahb = dev_get_drvdata(dev);\n\n\tfor (i = 0; i < ARRAY_SIZE(tegra_ahb_gizmo); i++)\n\t\tahb->ctx[i] = gizmo_readl(ahb, tegra_ahb_gizmo[i]);\n\treturn 0;\n}\n\nstatic int __maybe_unused tegra_ahb_resume(struct device *dev)\n{\n\tint i;\n\tstruct tegra_ahb *ahb = dev_get_drvdata(dev);\n\n\tfor (i = 0; i < ARRAY_SIZE(tegra_ahb_gizmo); i++)\n\t\tgizmo_writel(ahb, ahb->ctx[i], tegra_ahb_gizmo[i]);\n\treturn 0;\n}\n\nstatic UNIVERSAL_DEV_PM_OPS(tegra_ahb_pm,\n\t\t\t    tegra_ahb_suspend,\n\t\t\t    tegra_ahb_resume, NULL);\n\nstatic void tegra_ahb_gizmo_init(struct tegra_ahb *ahb)\n{\n\tu32 val;\n\n\tval = gizmo_readl(ahb, AHB_GIZMO_AHB_MEM);\n\tval |= ENB_FAST_REARBITRATE | IMMEDIATE | DONT_SPLIT_AHB_WR;\n\tgizmo_writel(ahb, val, AHB_GIZMO_AHB_MEM);\n\n\tval = gizmo_readl(ahb, AHB_GIZMO_USB);\n\tval |= IMMEDIATE;\n\tgizmo_writel(ahb, val, AHB_GIZMO_USB);\n\n\tval = gizmo_readl(ahb, AHB_GIZMO_USB2);\n\tval |= IMMEDIATE;\n\tgizmo_writel(ahb, val, AHB_GIZMO_USB2);\n\n\tval = gizmo_readl(ahb, AHB_GIZMO_USB3);\n\tval |= IMMEDIATE;\n\tgizmo_writel(ahb, val, AHB_GIZMO_USB3);\n\n\tval = gizmo_readl(ahb, AHB_ARBITRATION_PRIORITY_CTRL);\n\tval |= PRIORITY_SELECT_USB |\n\t\tPRIORITY_SELECT_USB2 |\n\t\tPRIORITY_SELECT_USB3 |\n\t\tAHB_PRIORITY_WEIGHT(7);\n\tgizmo_writel(ahb, val, AHB_ARBITRATION_PRIORITY_CTRL);\n\n\tval = gizmo_readl(ahb, AHB_MEM_PREFETCH_CFG1);\n\tval &= ~MST_ID(~0);\n\tval |= PREFETCH_ENB |\n\t\tAHBDMA_MST_ID |\n\t\tADDR_BNDRY(0xc) |\n\t\tINACTIVITY_TIMEOUT(0x1000);\n\tgizmo_writel(ahb, val, AHB_MEM_PREFETCH_CFG1);\n\n\tval = gizmo_readl(ahb, AHB_MEM_PREFETCH_CFG2);\n\tval &= ~MST_ID(~0);\n\tval |= PREFETCH_ENB |\n\t\tUSB_MST_ID |\n\t\tADDR_BNDRY(0xc) |\n\t\tINACTIVITY_TIMEOUT(0x1000);\n\tgizmo_writel(ahb, val, AHB_MEM_PREFETCH_CFG2);\n\n\tval = gizmo_readl(ahb, AHB_MEM_PREFETCH_CFG3);\n\tval &= ~MST_ID(~0);\n\tval |= PREFETCH_ENB |\n\t\tUSB3_MST_ID |\n\t\tADDR_BNDRY(0xc) |\n\t\tINACTIVITY_TIMEOUT(0x1000);\n\tgizmo_writel(ahb, val, AHB_MEM_PREFETCH_CFG3);\n\n\tval = gizmo_readl(ahb, AHB_MEM_PREFETCH_CFG4);\n\tval &= ~MST_ID(~0);\n\tval |= PREFETCH_ENB |\n\t\tUSB2_MST_ID |\n\t\tADDR_BNDRY(0xc) |\n\t\tINACTIVITY_TIMEOUT(0x1000);\n\tgizmo_writel(ahb, val, AHB_MEM_PREFETCH_CFG4);\n}\n\nstatic int tegra_ahb_probe(struct platform_device *pdev)\n{\n\tstruct resource *res;\n\tstruct tegra_ahb *ahb;\n\tsize_t bytes;\n\n\tbytes = sizeof(*ahb) + sizeof(u32) * ARRAY_SIZE(tegra_ahb_gizmo);\n\tahb = devm_kzalloc(&pdev->dev, bytes, GFP_KERNEL);\n\tif (!ahb)\n\t\treturn -ENOMEM;\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\n\t \n\tif (res &&\n\t    (res->start & INCORRECT_BASE_ADDR_LOW_BYTE) ==\n\t    INCORRECT_BASE_ADDR_LOW_BYTE) {\n\t\tdev_warn(&pdev->dev, \"incorrect AHB base address in DT data - enabling workaround\\n\");\n\t\tres->start -= INCORRECT_BASE_ADDR_LOW_BYTE;\n\t}\n\n\tahb->regs = devm_ioremap_resource(&pdev->dev, res);\n\tif (IS_ERR(ahb->regs))\n\t\treturn PTR_ERR(ahb->regs);\n\n\tahb->dev = &pdev->dev;\n\tplatform_set_drvdata(pdev, ahb);\n\ttegra_ahb_gizmo_init(ahb);\n\treturn 0;\n}\n\nstatic const struct of_device_id tegra_ahb_of_match[] = {\n\t{ .compatible = \"nvidia,tegra30-ahb\", },\n\t{ .compatible = \"nvidia,tegra20-ahb\", },\n\t{},\n};\n\nstatic struct platform_driver tegra_ahb_driver = {\n\t.probe = tegra_ahb_probe,\n\t.driver = {\n\t\t.name = DRV_NAME,\n\t\t.of_match_table = tegra_ahb_of_match,\n\t\t.pm = &tegra_ahb_pm,\n\t},\n};\nmodule_platform_driver(tegra_ahb_driver);\n\nMODULE_AUTHOR(\"Hiroshi DOYU <hdoyu@nvidia.com>\");\nMODULE_DESCRIPTION(\"Tegra AHB driver\");\nMODULE_ALIAS(\"platform:\" DRV_NAME);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}