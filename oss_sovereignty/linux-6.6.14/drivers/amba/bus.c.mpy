{
  "module_name": "bus.c",
  "hash_id": "e2f12b7d6e925720fa06a4e2f4480c289b2676cf28d09ea4fe5d82a1f93445f5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/amba/bus.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/pm.h>\n#include <linux/pm_runtime.h>\n#include <linux/pm_domain.h>\n#include <linux/amba/bus.h>\n#include <linux/sizes.h>\n#include <linux/limits.h>\n#include <linux/clk/clk-conf.h>\n#include <linux/platform_device.h>\n#include <linux/reset.h>\n#include <linux/of_irq.h>\n#include <linux/of_device.h>\n#include <linux/acpi.h>\n#include <linux/iommu.h>\n#include <linux/dma-map-ops.h>\n\n#define to_amba_driver(d)\tcontainer_of(d, struct amba_driver, drv)\n\n \nstatic int\namba_cs_uci_id_match(const struct amba_id *table, struct amba_device *dev)\n{\n\tint ret = 0;\n\tstruct amba_cs_uci_id *uci;\n\n\tuci = table->data;\n\n\t \n\tif (!uci || (uci->devarch_mask == 0))\n\t\treturn 1;\n\n\t \n\tret = (dev->uci.devtype == uci->devtype) &&\n\t\t((dev->uci.devarch & uci->devarch_mask) == uci->devarch);\n\treturn ret;\n}\n\nstatic const struct amba_id *\namba_lookup(const struct amba_id *table, struct amba_device *dev)\n{\n\twhile (table->mask) {\n\t\tif (((dev->periphid & table->mask) == table->id) &&\n\t\t\t((dev->cid != CORESIGHT_CID) ||\n\t\t\t (amba_cs_uci_id_match(table, dev))))\n\t\t\treturn table;\n\t\ttable++;\n\t}\n\treturn NULL;\n}\n\nstatic int amba_get_enable_pclk(struct amba_device *pcdev)\n{\n\tint ret;\n\n\tpcdev->pclk = clk_get(&pcdev->dev, \"apb_pclk\");\n\tif (IS_ERR(pcdev->pclk))\n\t\treturn PTR_ERR(pcdev->pclk);\n\n\tret = clk_prepare_enable(pcdev->pclk);\n\tif (ret)\n\t\tclk_put(pcdev->pclk);\n\n\treturn ret;\n}\n\nstatic void amba_put_disable_pclk(struct amba_device *pcdev)\n{\n\tclk_disable_unprepare(pcdev->pclk);\n\tclk_put(pcdev->pclk);\n}\n\n\nstatic ssize_t driver_override_show(struct device *_dev,\n\t\t\t\t    struct device_attribute *attr, char *buf)\n{\n\tstruct amba_device *dev = to_amba_device(_dev);\n\tssize_t len;\n\n\tdevice_lock(_dev);\n\tlen = sprintf(buf, \"%s\\n\", dev->driver_override);\n\tdevice_unlock(_dev);\n\treturn len;\n}\n\nstatic ssize_t driver_override_store(struct device *_dev,\n\t\t\t\t     struct device_attribute *attr,\n\t\t\t\t     const char *buf, size_t count)\n{\n\tstruct amba_device *dev = to_amba_device(_dev);\n\tint ret;\n\n\tret = driver_set_override(_dev, &dev->driver_override, buf, count);\n\tif (ret)\n\t\treturn ret;\n\n\treturn count;\n}\nstatic DEVICE_ATTR_RW(driver_override);\n\n#define amba_attr_func(name,fmt,arg...)\t\t\t\t\t\\\nstatic ssize_t name##_show(struct device *_dev,\t\t\t\t\\\n\t\t\t   struct device_attribute *attr, char *buf)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct amba_device *dev = to_amba_device(_dev);\t\t\t\\\n\treturn sprintf(buf, fmt, arg);\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\nstatic DEVICE_ATTR_RO(name)\n\namba_attr_func(id, \"%08x\\n\", dev->periphid);\namba_attr_func(resource, \"\\t%016llx\\t%016llx\\t%016lx\\n\",\n\t (unsigned long long)dev->res.start, (unsigned long long)dev->res.end,\n\t dev->res.flags);\n\nstatic struct attribute *amba_dev_attrs[] = {\n\t&dev_attr_id.attr,\n\t&dev_attr_resource.attr,\n\t&dev_attr_driver_override.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(amba_dev);\n\nstatic int amba_read_periphid(struct amba_device *dev)\n{\n\tstruct reset_control *rstc;\n\tu32 size, pid, cid;\n\tvoid __iomem *tmp;\n\tint i, ret;\n\n\tret = dev_pm_domain_attach(&dev->dev, true);\n\tif (ret) {\n\t\tdev_dbg(&dev->dev, \"can't get PM domain: %d\\n\", ret);\n\t\tgoto err_out;\n\t}\n\n\tret = amba_get_enable_pclk(dev);\n\tif (ret) {\n\t\tdev_dbg(&dev->dev, \"can't get pclk: %d\\n\", ret);\n\t\tgoto err_pm;\n\t}\n\n\t \n\trstc = of_reset_control_array_get_optional_shared(dev->dev.of_node);\n\tif (IS_ERR(rstc)) {\n\t\tret = PTR_ERR(rstc);\n\t\tif (ret != -EPROBE_DEFER)\n\t\t\tdev_err(&dev->dev, \"can't get reset: %d\\n\", ret);\n\t\tgoto err_clk;\n\t}\n\treset_control_deassert(rstc);\n\treset_control_put(rstc);\n\n\tsize = resource_size(&dev->res);\n\ttmp = ioremap(dev->res.start, size);\n\tif (!tmp) {\n\t\tret = -ENOMEM;\n\t\tgoto err_clk;\n\t}\n\n\t \n\tfor (pid = 0, i = 0; i < 4; i++)\n\t\tpid |= (readl(tmp + size - 0x20 + 4 * i) & 255) << (i * 8);\n\tfor (cid = 0, i = 0; i < 4; i++)\n\t\tcid |= (readl(tmp + size - 0x10 + 4 * i) & 255) << (i * 8);\n\n\tif (cid == CORESIGHT_CID) {\n\t\t \n\t\tvoid __iomem *csbase = tmp + size - 4096;\n\n\t\tdev->uci.devarch = readl(csbase + UCI_REG_DEVARCH_OFFSET);\n\t\tdev->uci.devtype = readl(csbase + UCI_REG_DEVTYPE_OFFSET) & 0xff;\n\t}\n\n\tif (cid == AMBA_CID || cid == CORESIGHT_CID) {\n\t\tdev->periphid = pid;\n\t\tdev->cid = cid;\n\t}\n\n\tif (!dev->periphid)\n\t\tret = -ENODEV;\n\n\tiounmap(tmp);\n\nerr_clk:\n\tamba_put_disable_pclk(dev);\nerr_pm:\n\tdev_pm_domain_detach(&dev->dev, true);\nerr_out:\n\treturn ret;\n}\n\nstatic int amba_match(struct device *dev, struct device_driver *drv)\n{\n\tstruct amba_device *pcdev = to_amba_device(dev);\n\tstruct amba_driver *pcdrv = to_amba_driver(drv);\n\n\tmutex_lock(&pcdev->periphid_lock);\n\tif (!pcdev->periphid) {\n\t\tint ret = amba_read_periphid(pcdev);\n\n\t\t \n\t\tif (ret) {\n\t\t\tmutex_unlock(&pcdev->periphid_lock);\n\t\t\treturn -EPROBE_DEFER;\n\t\t}\n\t\tdev_set_uevent_suppress(dev, false);\n\t\tkobject_uevent(&dev->kobj, KOBJ_ADD);\n\t}\n\tmutex_unlock(&pcdev->periphid_lock);\n\n\t \n\tif (pcdev->driver_override)\n\t\treturn !strcmp(pcdev->driver_override, drv->name);\n\n\treturn amba_lookup(pcdrv->id_table, pcdev) != NULL;\n}\n\nstatic int amba_uevent(const struct device *dev, struct kobj_uevent_env *env)\n{\n\tconst struct amba_device *pcdev = to_amba_device(dev);\n\tint retval = 0;\n\n\tretval = add_uevent_var(env, \"AMBA_ID=%08x\", pcdev->periphid);\n\tif (retval)\n\t\treturn retval;\n\n\tretval = add_uevent_var(env, \"MODALIAS=amba:d%08X\", pcdev->periphid);\n\treturn retval;\n}\n\nstatic int of_amba_device_decode_irq(struct amba_device *dev)\n{\n\tstruct device_node *node = dev->dev.of_node;\n\tint i, irq = 0;\n\n\tif (IS_ENABLED(CONFIG_OF_IRQ) && node) {\n\t\t \n\t\tfor (i = 0; i < AMBA_NR_IRQS; i++) {\n\t\t\tirq = of_irq_get(node, i);\n\t\t\tif (irq < 0) {\n\t\t\t\tif (irq == -EPROBE_DEFER)\n\t\t\t\t\treturn irq;\n\t\t\t\tirq = 0;\n\t\t\t}\n\n\t\t\tdev->irq[i] = irq;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic int amba_probe(struct device *dev)\n{\n\tstruct amba_device *pcdev = to_amba_device(dev);\n\tstruct amba_driver *pcdrv = to_amba_driver(dev->driver);\n\tconst struct amba_id *id = amba_lookup(pcdrv->id_table, pcdev);\n\tint ret;\n\n\tdo {\n\t\tret = of_amba_device_decode_irq(pcdev);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tret = of_clk_set_defaults(dev->of_node, false);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\n\t\tret = dev_pm_domain_attach(dev, true);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tret = amba_get_enable_pclk(pcdev);\n\t\tif (ret) {\n\t\t\tdev_pm_domain_detach(dev, true);\n\t\t\tbreak;\n\t\t}\n\n\t\tpm_runtime_get_noresume(dev);\n\t\tpm_runtime_set_active(dev);\n\t\tpm_runtime_enable(dev);\n\n\t\tret = pcdrv->probe(pcdev, id);\n\t\tif (ret == 0)\n\t\t\tbreak;\n\n\t\tpm_runtime_disable(dev);\n\t\tpm_runtime_set_suspended(dev);\n\t\tpm_runtime_put_noidle(dev);\n\n\t\tamba_put_disable_pclk(pcdev);\n\t\tdev_pm_domain_detach(dev, true);\n\t} while (0);\n\n\treturn ret;\n}\n\nstatic void amba_remove(struct device *dev)\n{\n\tstruct amba_device *pcdev = to_amba_device(dev);\n\tstruct amba_driver *drv = to_amba_driver(dev->driver);\n\n\tpm_runtime_get_sync(dev);\n\tif (drv->remove)\n\t\tdrv->remove(pcdev);\n\tpm_runtime_put_noidle(dev);\n\n\t \n\tpm_runtime_disable(dev);\n\tpm_runtime_set_suspended(dev);\n\tpm_runtime_put_noidle(dev);\n\n\tamba_put_disable_pclk(pcdev);\n\tdev_pm_domain_detach(dev, true);\n}\n\nstatic void amba_shutdown(struct device *dev)\n{\n\tstruct amba_driver *drv;\n\n\tif (!dev->driver)\n\t\treturn;\n\n\tdrv = to_amba_driver(dev->driver);\n\tif (drv->shutdown)\n\t\tdrv->shutdown(to_amba_device(dev));\n}\n\nstatic int amba_dma_configure(struct device *dev)\n{\n\tstruct amba_driver *drv = to_amba_driver(dev->driver);\n\tenum dev_dma_attr attr;\n\tint ret = 0;\n\n\tif (dev->of_node) {\n\t\tret = of_dma_configure(dev, dev->of_node, true);\n\t} else if (has_acpi_companion(dev)) {\n\t\tattr = acpi_get_dma_attr(to_acpi_device_node(dev->fwnode));\n\t\tret = acpi_dma_configure(dev, attr);\n\t}\n\n\tif (!ret && !drv->driver_managed_dma) {\n\t\tret = iommu_device_use_default_domain(dev);\n\t\tif (ret)\n\t\t\tarch_teardown_dma_ops(dev);\n\t}\n\n\treturn ret;\n}\n\nstatic void amba_dma_cleanup(struct device *dev)\n{\n\tstruct amba_driver *drv = to_amba_driver(dev->driver);\n\n\tif (!drv->driver_managed_dma)\n\t\tiommu_device_unuse_default_domain(dev);\n}\n\n#ifdef CONFIG_PM\n \nstatic int amba_pm_runtime_suspend(struct device *dev)\n{\n\tstruct amba_device *pcdev = to_amba_device(dev);\n\tint ret = pm_generic_runtime_suspend(dev);\n\n\tif (ret == 0 && dev->driver) {\n\t\tif (pm_runtime_is_irq_safe(dev))\n\t\t\tclk_disable(pcdev->pclk);\n\t\telse\n\t\t\tclk_disable_unprepare(pcdev->pclk);\n\t}\n\n\treturn ret;\n}\n\nstatic int amba_pm_runtime_resume(struct device *dev)\n{\n\tstruct amba_device *pcdev = to_amba_device(dev);\n\tint ret;\n\n\tif (dev->driver) {\n\t\tif (pm_runtime_is_irq_safe(dev))\n\t\t\tret = clk_enable(pcdev->pclk);\n\t\telse\n\t\t\tret = clk_prepare_enable(pcdev->pclk);\n\t\t \n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn pm_generic_runtime_resume(dev);\n}\n#endif  \n\nstatic const struct dev_pm_ops amba_pm = {\n\tSET_RUNTIME_PM_OPS(\n\t\tamba_pm_runtime_suspend,\n\t\tamba_pm_runtime_resume,\n\t\tNULL\n\t)\n};\n\n \nstruct bus_type amba_bustype = {\n\t.name\t\t= \"amba\",\n\t.dev_groups\t= amba_dev_groups,\n\t.match\t\t= amba_match,\n\t.uevent\t\t= amba_uevent,\n\t.probe\t\t= amba_probe,\n\t.remove\t\t= amba_remove,\n\t.shutdown\t= amba_shutdown,\n\t.dma_configure\t= amba_dma_configure,\n\t.dma_cleanup\t= amba_dma_cleanup,\n\t.pm\t\t= &amba_pm,\n};\nEXPORT_SYMBOL_GPL(amba_bustype);\n\nstatic int __init amba_init(void)\n{\n\treturn bus_register(&amba_bustype);\n}\n\npostcore_initcall(amba_init);\n\nstatic int amba_proxy_probe(struct amba_device *adev,\n\t\t\t    const struct amba_id *id)\n{\n\tWARN(1, \"Stub driver should never match any device.\\n\");\n\treturn -ENODEV;\n}\n\nstatic const struct amba_id amba_stub_drv_ids[] = {\n\t{ 0, 0 },\n};\n\nstatic struct amba_driver amba_proxy_drv = {\n\t.drv = {\n\t\t.name = \"amba-proxy\",\n\t},\n\t.probe = amba_proxy_probe,\n\t.id_table = amba_stub_drv_ids,\n};\n\nstatic int __init amba_stub_drv_init(void)\n{\n\tif (!IS_ENABLED(CONFIG_MODULES))\n\t\treturn 0;\n\n\t \n\treturn amba_driver_register(&amba_proxy_drv);\n}\nlate_initcall_sync(amba_stub_drv_init);\n\n \nint amba_driver_register(struct amba_driver *drv)\n{\n\tif (!drv->probe)\n\t\treturn -EINVAL;\n\n\tdrv->drv.bus = &amba_bustype;\n\n\treturn driver_register(&drv->drv);\n}\nEXPORT_SYMBOL(amba_driver_register);\n\n \nvoid amba_driver_unregister(struct amba_driver *drv)\n{\n\tdriver_unregister(&drv->drv);\n}\nEXPORT_SYMBOL(amba_driver_unregister);\n\nstatic void amba_device_release(struct device *dev)\n{\n\tstruct amba_device *d = to_amba_device(dev);\n\n\tof_node_put(d->dev.of_node);\n\tif (d->res.parent)\n\t\trelease_resource(&d->res);\n\tmutex_destroy(&d->periphid_lock);\n\tkfree(d);\n}\n\n \nint amba_device_add(struct amba_device *dev, struct resource *parent)\n{\n\tint ret;\n\n\tret = request_resource(parent, &dev->res);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (!dev->periphid) {\n\t\t \n\t\tif (amba_read_periphid(dev))\n\t\t\tdev_set_uevent_suppress(&dev->dev, true);\n\t}\n\n\tret = device_add(&dev->dev);\n\tif (ret)\n\t\trelease_resource(&dev->res);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(amba_device_add);\n\nstatic void amba_device_initialize(struct amba_device *dev, const char *name)\n{\n\tdevice_initialize(&dev->dev);\n\tif (name)\n\t\tdev_set_name(&dev->dev, \"%s\", name);\n\tdev->dev.release = amba_device_release;\n\tdev->dev.bus = &amba_bustype;\n\tdev->dev.dma_mask = &dev->dev.coherent_dma_mask;\n\tdev->dev.dma_parms = &dev->dma_parms;\n\tdev->res.name = dev_name(&dev->dev);\n\tmutex_init(&dev->periphid_lock);\n}\n\n \nstruct amba_device *amba_device_alloc(const char *name, resource_size_t base,\n\tsize_t size)\n{\n\tstruct amba_device *dev;\n\n\tdev = kzalloc(sizeof(*dev), GFP_KERNEL);\n\tif (dev) {\n\t\tamba_device_initialize(dev, name);\n\t\tdev->res.start = base;\n\t\tdev->res.end = base + size - 1;\n\t\tdev->res.flags = IORESOURCE_MEM;\n\t}\n\n\treturn dev;\n}\nEXPORT_SYMBOL_GPL(amba_device_alloc);\n\n \nint amba_device_register(struct amba_device *dev, struct resource *parent)\n{\n\tamba_device_initialize(dev, dev->dev.init_name);\n\tdev->dev.init_name = NULL;\n\n\treturn amba_device_add(dev, parent);\n}\nEXPORT_SYMBOL(amba_device_register);\n\n \nvoid amba_device_put(struct amba_device *dev)\n{\n\tput_device(&dev->dev);\n}\nEXPORT_SYMBOL_GPL(amba_device_put);\n\n \nvoid amba_device_unregister(struct amba_device *dev)\n{\n\tdevice_unregister(&dev->dev);\n}\nEXPORT_SYMBOL(amba_device_unregister);\n\n \nint amba_request_regions(struct amba_device *dev, const char *name)\n{\n\tint ret = 0;\n\tu32 size;\n\n\tif (!name)\n\t\tname = dev->dev.driver->name;\n\n\tsize = resource_size(&dev->res);\n\n\tif (!request_mem_region(dev->res.start, size, name))\n\t\tret = -EBUSY;\n\n\treturn ret;\n}\nEXPORT_SYMBOL(amba_request_regions);\n\n \nvoid amba_release_regions(struct amba_device *dev)\n{\n\tu32 size;\n\n\tsize = resource_size(&dev->res);\n\trelease_mem_region(dev->res.start, size);\n}\nEXPORT_SYMBOL(amba_release_regions);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}