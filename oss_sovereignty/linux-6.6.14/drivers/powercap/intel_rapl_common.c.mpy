{
  "module_name": "intel_rapl_common.c",
  "hash_id": "b36713795ce1a914bfd6ef5156f7d177b6f8d2d7c0019ac7e82e2ea07565f761",
  "original_prompt": "Ingested from linux-6.6.14/drivers/powercap/intel_rapl_common.c",
  "human_readable_source": "\n \n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/list.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/slab.h>\n#include <linux/log2.h>\n#include <linux/bitmap.h>\n#include <linux/delay.h>\n#include <linux/sysfs.h>\n#include <linux/cpu.h>\n#include <linux/powercap.h>\n#include <linux/suspend.h>\n#include <linux/intel_rapl.h>\n#include <linux/processor.h>\n#include <linux/platform_device.h>\n\n#include <asm/iosf_mbi.h>\n#include <asm/cpu_device_id.h>\n#include <asm/intel-family.h>\n\n \n#define ENERGY_STATUS_MASK      0xffffffff\n\n#define POWER_LIMIT1_MASK       0x7FFF\n#define POWER_LIMIT1_ENABLE     BIT(15)\n#define POWER_LIMIT1_CLAMP      BIT(16)\n\n#define POWER_LIMIT2_MASK       (0x7FFFULL<<32)\n#define POWER_LIMIT2_ENABLE     BIT_ULL(47)\n#define POWER_LIMIT2_CLAMP      BIT_ULL(48)\n#define POWER_HIGH_LOCK         BIT_ULL(63)\n#define POWER_LOW_LOCK          BIT(31)\n\n#define POWER_LIMIT4_MASK\t\t0x1FFF\n\n#define TIME_WINDOW1_MASK       (0x7FULL<<17)\n#define TIME_WINDOW2_MASK       (0x7FULL<<49)\n\n#define POWER_UNIT_OFFSET\t0\n#define POWER_UNIT_MASK\t\t0x0F\n\n#define ENERGY_UNIT_OFFSET\t0x08\n#define ENERGY_UNIT_MASK\t0x1F00\n\n#define TIME_UNIT_OFFSET\t0x10\n#define TIME_UNIT_MASK\t\t0xF0000\n\n#define POWER_INFO_MAX_MASK     (0x7fffULL<<32)\n#define POWER_INFO_MIN_MASK     (0x7fffULL<<16)\n#define POWER_INFO_MAX_TIME_WIN_MASK     (0x3fULL<<48)\n#define POWER_INFO_THERMAL_SPEC_MASK     0x7fff\n\n#define PERF_STATUS_THROTTLE_TIME_MASK 0xffffffff\n#define PP_POLICY_MASK         0x1F\n\n \n#define PSYS_POWER_LIMIT1_MASK       0x1FFFF\n#define PSYS_POWER_LIMIT1_ENABLE     BIT(17)\n\n#define PSYS_POWER_LIMIT2_MASK       (0x1FFFFULL<<32)\n#define PSYS_POWER_LIMIT2_ENABLE     BIT_ULL(49)\n\n#define PSYS_TIME_WINDOW1_MASK       (0x7FULL<<19)\n#define PSYS_TIME_WINDOW2_MASK       (0x7FULL<<51)\n\n \n#define TPMI_POWER_LIMIT_MASK\t0x3FFFF\n#define TPMI_POWER_LIMIT_ENABLE\tBIT_ULL(62)\n#define TPMI_TIME_WINDOW_MASK\t(0x7FULL<<18)\n#define TPMI_INFO_SPEC_MASK\t0x3FFFF\n#define TPMI_INFO_MIN_MASK\t(0x3FFFFULL << 18)\n#define TPMI_INFO_MAX_MASK\t(0x3FFFFULL << 36)\n#define TPMI_INFO_MAX_TIME_WIN_MASK\t(0x7FULL << 54)\n\n \n#define RAPL_PRIMITIVE_DERIVED       BIT(1)\t \n#define RAPL_PRIMITIVE_DUMMY         BIT(2)\n\n#define TIME_WINDOW_MAX_MSEC 40000\n#define TIME_WINDOW_MIN_MSEC 250\n#define ENERGY_UNIT_SCALE    1000\t \nenum unit_type {\n\tARBITRARY_UNIT,\t\t \n\tPOWER_UNIT,\n\tENERGY_UNIT,\n\tTIME_UNIT,\n};\n\n \n#define NR_RAW_PRIMITIVES (NR_RAPL_PRIMITIVES - 2)\n\n#define\tDOMAIN_STATE_INACTIVE           BIT(0)\n#define\tDOMAIN_STATE_POWER_LIMIT_SET    BIT(1)\n\nstatic const char *pl_names[NR_POWER_LIMITS] = {\n\t[POWER_LIMIT1] = \"long_term\",\n\t[POWER_LIMIT2] = \"short_term\",\n\t[POWER_LIMIT4] = \"peak_power\",\n};\n\nenum pl_prims {\n\tPL_ENABLE,\n\tPL_CLAMP,\n\tPL_LIMIT,\n\tPL_TIME_WINDOW,\n\tPL_MAX_POWER,\n\tPL_LOCK,\n};\n\nstatic bool is_pl_valid(struct rapl_domain *rd, int pl)\n{\n\tif (pl < POWER_LIMIT1 || pl > POWER_LIMIT4)\n\t\treturn false;\n\treturn rd->rpl[pl].name ? true : false;\n}\n\nstatic int get_pl_lock_prim(struct rapl_domain *rd, int pl)\n{\n\tif (rd->rp->priv->type == RAPL_IF_TPMI) {\n\t\tif (pl == POWER_LIMIT1)\n\t\t\treturn PL1_LOCK;\n\t\tif (pl == POWER_LIMIT2)\n\t\t\treturn PL2_LOCK;\n\t\tif (pl == POWER_LIMIT4)\n\t\t\treturn PL4_LOCK;\n\t}\n\n\t \n\tif (pl == POWER_LIMIT4)\n\t\treturn -EINVAL;\n\n\t \n\tif (rd->rp->priv->limits[rd->id] & BIT(POWER_LIMIT2))\n\t\treturn FW_HIGH_LOCK;\n\treturn FW_LOCK;\n}\n\nstatic int get_pl_prim(struct rapl_domain *rd, int pl, enum pl_prims prim)\n{\n\tswitch (pl) {\n\tcase POWER_LIMIT1:\n\t\tif (prim == PL_ENABLE)\n\t\t\treturn PL1_ENABLE;\n\t\tif (prim == PL_CLAMP && rd->rp->priv->type != RAPL_IF_TPMI)\n\t\t\treturn PL1_CLAMP;\n\t\tif (prim == PL_LIMIT)\n\t\t\treturn POWER_LIMIT1;\n\t\tif (prim == PL_TIME_WINDOW)\n\t\t\treturn TIME_WINDOW1;\n\t\tif (prim == PL_MAX_POWER)\n\t\t\treturn THERMAL_SPEC_POWER;\n\t\tif (prim == PL_LOCK)\n\t\t\treturn get_pl_lock_prim(rd, pl);\n\t\treturn -EINVAL;\n\tcase POWER_LIMIT2:\n\t\tif (prim == PL_ENABLE)\n\t\t\treturn PL2_ENABLE;\n\t\tif (prim == PL_CLAMP && rd->rp->priv->type != RAPL_IF_TPMI)\n\t\t\treturn PL2_CLAMP;\n\t\tif (prim == PL_LIMIT)\n\t\t\treturn POWER_LIMIT2;\n\t\tif (prim == PL_TIME_WINDOW)\n\t\t\treturn TIME_WINDOW2;\n\t\tif (prim == PL_MAX_POWER)\n\t\t\treturn MAX_POWER;\n\t\tif (prim == PL_LOCK)\n\t\t\treturn get_pl_lock_prim(rd, pl);\n\t\treturn -EINVAL;\n\tcase POWER_LIMIT4:\n\t\tif (prim == PL_LIMIT)\n\t\t\treturn POWER_LIMIT4;\n\t\tif (prim == PL_ENABLE)\n\t\t\treturn PL4_ENABLE;\n\t\t \n\t\tif (prim == PL_MAX_POWER)\n\t\t\treturn MAX_POWER;\n\t\tif (prim == PL_LOCK)\n\t\t\treturn get_pl_lock_prim(rd, pl);\n\t\treturn -EINVAL;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\n#define power_zone_to_rapl_domain(_zone) \\\n\tcontainer_of(_zone, struct rapl_domain, power_zone)\n\nstruct rapl_defaults {\n\tu8 floor_freq_reg_addr;\n\tint (*check_unit)(struct rapl_domain *rd);\n\tvoid (*set_floor_freq)(struct rapl_domain *rd, bool mode);\n\tu64 (*compute_time_window)(struct rapl_domain *rd, u64 val,\n\t\t\t\t    bool to_raw);\n\tunsigned int dram_domain_energy_unit;\n\tunsigned int psys_domain_energy_unit;\n\tbool spr_psys_bits;\n};\nstatic struct rapl_defaults *defaults_msr;\nstatic const struct rapl_defaults defaults_tpmi;\n\nstatic struct rapl_defaults *get_defaults(struct rapl_package *rp)\n{\n\treturn rp->priv->defaults;\n}\n\n \n#define IOSF_CPU_POWER_BUDGET_CTL_BYT (0x2)\n#define IOSF_CPU_POWER_BUDGET_CTL_TNG (0xdf)\n\n#define PACKAGE_PLN_INT_SAVED   BIT(0)\n#define MAX_PRIM_NAME (32)\n\n \nstruct rapl_primitive_info {\n\tconst char *name;\n\tu64 mask;\n\tint shift;\n\tenum rapl_domain_reg_id id;\n\tenum unit_type unit;\n\tu32 flag;\n};\n\n#define PRIMITIVE_INFO_INIT(p, m, s, i, u, f) {\t\\\n\t\t.name = #p,\t\t\t\\\n\t\t.mask = m,\t\t\t\\\n\t\t.shift = s,\t\t\t\\\n\t\t.id = i,\t\t\t\\\n\t\t.unit = u,\t\t\t\\\n\t\t.flag = f\t\t\t\\\n\t}\n\nstatic void rapl_init_domains(struct rapl_package *rp);\nstatic int rapl_read_data_raw(struct rapl_domain *rd,\n\t\t\t      enum rapl_primitives prim,\n\t\t\t      bool xlate, u64 *data);\nstatic int rapl_write_data_raw(struct rapl_domain *rd,\n\t\t\t       enum rapl_primitives prim,\n\t\t\t       unsigned long long value);\nstatic int rapl_read_pl_data(struct rapl_domain *rd, int pl,\n\t\t\t      enum pl_prims pl_prim,\n\t\t\t      bool xlate, u64 *data);\nstatic int rapl_write_pl_data(struct rapl_domain *rd, int pl,\n\t\t\t       enum pl_prims pl_prim,\n\t\t\t       unsigned long long value);\nstatic u64 rapl_unit_xlate(struct rapl_domain *rd,\n\t\t\t   enum unit_type type, u64 value, int to_raw);\nstatic void package_power_limit_irq_save(struct rapl_package *rp);\n\nstatic LIST_HEAD(rapl_packages);\t \n\nstatic const char *const rapl_domain_names[] = {\n\t\"package\",\n\t\"core\",\n\t\"uncore\",\n\t\"dram\",\n\t\"psys\",\n};\n\nstatic int get_energy_counter(struct powercap_zone *power_zone,\n\t\t\t      u64 *energy_raw)\n{\n\tstruct rapl_domain *rd;\n\tu64 energy_now;\n\n\t \n\tcpus_read_lock();\n\trd = power_zone_to_rapl_domain(power_zone);\n\n\tif (!rapl_read_data_raw(rd, ENERGY_COUNTER, true, &energy_now)) {\n\t\t*energy_raw = energy_now;\n\t\tcpus_read_unlock();\n\n\t\treturn 0;\n\t}\n\tcpus_read_unlock();\n\n\treturn -EIO;\n}\n\nstatic int get_max_energy_counter(struct powercap_zone *pcd_dev, u64 *energy)\n{\n\tstruct rapl_domain *rd = power_zone_to_rapl_domain(pcd_dev);\n\n\t*energy = rapl_unit_xlate(rd, ENERGY_UNIT, ENERGY_STATUS_MASK, 0);\n\treturn 0;\n}\n\nstatic int release_zone(struct powercap_zone *power_zone)\n{\n\tstruct rapl_domain *rd = power_zone_to_rapl_domain(power_zone);\n\tstruct rapl_package *rp = rd->rp;\n\n\t \n\tif (rd->id == RAPL_DOMAIN_PACKAGE) {\n\t\tkfree(rd);\n\t\trp->domains = NULL;\n\t}\n\n\treturn 0;\n\n}\n\nstatic int find_nr_power_limit(struct rapl_domain *rd)\n{\n\tint i, nr_pl = 0;\n\n\tfor (i = 0; i < NR_POWER_LIMITS; i++) {\n\t\tif (is_pl_valid(rd, i))\n\t\t\tnr_pl++;\n\t}\n\n\treturn nr_pl;\n}\n\nstatic int set_domain_enable(struct powercap_zone *power_zone, bool mode)\n{\n\tstruct rapl_domain *rd = power_zone_to_rapl_domain(power_zone);\n\tstruct rapl_defaults *defaults = get_defaults(rd->rp);\n\tint ret;\n\n\tcpus_read_lock();\n\tret = rapl_write_pl_data(rd, POWER_LIMIT1, PL_ENABLE, mode);\n\tif (!ret && defaults->set_floor_freq)\n\t\tdefaults->set_floor_freq(rd, mode);\n\tcpus_read_unlock();\n\n\treturn ret;\n}\n\nstatic int get_domain_enable(struct powercap_zone *power_zone, bool *mode)\n{\n\tstruct rapl_domain *rd = power_zone_to_rapl_domain(power_zone);\n\tu64 val;\n\tint ret;\n\n\tif (rd->rpl[POWER_LIMIT1].locked) {\n\t\t*mode = false;\n\t\treturn 0;\n\t}\n\tcpus_read_lock();\n\tret = rapl_read_pl_data(rd, POWER_LIMIT1, PL_ENABLE, true, &val);\n\tif (!ret)\n\t\t*mode = val;\n\tcpus_read_unlock();\n\n\treturn ret;\n}\n\n \nstatic const struct powercap_zone_ops zone_ops[] = {\n\t \n\t{\n\t .get_energy_uj = get_energy_counter,\n\t .get_max_energy_range_uj = get_max_energy_counter,\n\t .release = release_zone,\n\t .set_enable = set_domain_enable,\n\t .get_enable = get_domain_enable,\n\t },\n\t \n\t{\n\t .get_energy_uj = get_energy_counter,\n\t .get_max_energy_range_uj = get_max_energy_counter,\n\t .release = release_zone,\n\t .set_enable = set_domain_enable,\n\t .get_enable = get_domain_enable,\n\t },\n\t \n\t{\n\t .get_energy_uj = get_energy_counter,\n\t .get_max_energy_range_uj = get_max_energy_counter,\n\t .release = release_zone,\n\t .set_enable = set_domain_enable,\n\t .get_enable = get_domain_enable,\n\t },\n\t \n\t{\n\t .get_energy_uj = get_energy_counter,\n\t .get_max_energy_range_uj = get_max_energy_counter,\n\t .release = release_zone,\n\t .set_enable = set_domain_enable,\n\t .get_enable = get_domain_enable,\n\t },\n\t \n\t{\n\t .get_energy_uj = get_energy_counter,\n\t .get_max_energy_range_uj = get_max_energy_counter,\n\t .release = release_zone,\n\t .set_enable = set_domain_enable,\n\t .get_enable = get_domain_enable,\n\t },\n};\n\n \nstatic int contraint_to_pl(struct rapl_domain *rd, int cid)\n{\n\tint i, j;\n\n\tfor (i = POWER_LIMIT1, j = 0; i < NR_POWER_LIMITS; i++) {\n\t\tif (is_pl_valid(rd, i) && j++ == cid) {\n\t\t\tpr_debug(\"%s: index %d\\n\", __func__, i);\n\t\t\treturn i;\n\t\t}\n\t}\n\tpr_err(\"Cannot find matching power limit for constraint %d\\n\", cid);\n\n\treturn -EINVAL;\n}\n\nstatic int set_power_limit(struct powercap_zone *power_zone, int cid,\n\t\t\t   u64 power_limit)\n{\n\tstruct rapl_domain *rd;\n\tstruct rapl_package *rp;\n\tint ret = 0;\n\tint id;\n\n\tcpus_read_lock();\n\trd = power_zone_to_rapl_domain(power_zone);\n\tid = contraint_to_pl(rd, cid);\n\trp = rd->rp;\n\n\tret = rapl_write_pl_data(rd, id, PL_LIMIT, power_limit);\n\tif (!ret)\n\t\tpackage_power_limit_irq_save(rp);\n\tcpus_read_unlock();\n\treturn ret;\n}\n\nstatic int get_current_power_limit(struct powercap_zone *power_zone, int cid,\n\t\t\t\t   u64 *data)\n{\n\tstruct rapl_domain *rd;\n\tu64 val;\n\tint ret = 0;\n\tint id;\n\n\tcpus_read_lock();\n\trd = power_zone_to_rapl_domain(power_zone);\n\tid = contraint_to_pl(rd, cid);\n\n\tret = rapl_read_pl_data(rd, id, PL_LIMIT, true, &val);\n\tif (!ret)\n\t\t*data = val;\n\n\tcpus_read_unlock();\n\n\treturn ret;\n}\n\nstatic int set_time_window(struct powercap_zone *power_zone, int cid,\n\t\t\t   u64 window)\n{\n\tstruct rapl_domain *rd;\n\tint ret = 0;\n\tint id;\n\n\tcpus_read_lock();\n\trd = power_zone_to_rapl_domain(power_zone);\n\tid = contraint_to_pl(rd, cid);\n\n\tret = rapl_write_pl_data(rd, id, PL_TIME_WINDOW, window);\n\n\tcpus_read_unlock();\n\treturn ret;\n}\n\nstatic int get_time_window(struct powercap_zone *power_zone, int cid,\n\t\t\t   u64 *data)\n{\n\tstruct rapl_domain *rd;\n\tu64 val;\n\tint ret = 0;\n\tint id;\n\n\tcpus_read_lock();\n\trd = power_zone_to_rapl_domain(power_zone);\n\tid = contraint_to_pl(rd, cid);\n\n\tret = rapl_read_pl_data(rd, id, PL_TIME_WINDOW, true, &val);\n\tif (!ret)\n\t\t*data = val;\n\n\tcpus_read_unlock();\n\n\treturn ret;\n}\n\nstatic const char *get_constraint_name(struct powercap_zone *power_zone,\n\t\t\t\t       int cid)\n{\n\tstruct rapl_domain *rd;\n\tint id;\n\n\trd = power_zone_to_rapl_domain(power_zone);\n\tid = contraint_to_pl(rd, cid);\n\tif (id >= 0)\n\t\treturn rd->rpl[id].name;\n\n\treturn NULL;\n}\n\nstatic int get_max_power(struct powercap_zone *power_zone, int cid, u64 *data)\n{\n\tstruct rapl_domain *rd;\n\tu64 val;\n\tint ret = 0;\n\tint id;\n\n\tcpus_read_lock();\n\trd = power_zone_to_rapl_domain(power_zone);\n\tid = contraint_to_pl(rd, cid);\n\n\tret = rapl_read_pl_data(rd, id, PL_MAX_POWER, true, &val);\n\tif (!ret)\n\t\t*data = val;\n\n\t \n\tif (id == POWER_LIMIT4)\n\t\t*data = *data * 2;\n\n\tcpus_read_unlock();\n\n\treturn ret;\n}\n\nstatic const struct powercap_zone_constraint_ops constraint_ops = {\n\t.set_power_limit_uw = set_power_limit,\n\t.get_power_limit_uw = get_current_power_limit,\n\t.set_time_window_us = set_time_window,\n\t.get_time_window_us = get_time_window,\n\t.get_max_power_uw = get_max_power,\n\t.get_name = get_constraint_name,\n};\n\n \nstatic int get_rid(struct rapl_package *rp)\n{\n\treturn rp->lead_cpu >= 0 ? rp->lead_cpu : rp->id;\n}\n\n \nstatic void rapl_init_domains(struct rapl_package *rp)\n{\n\tenum rapl_domain_type i;\n\tenum rapl_domain_reg_id j;\n\tstruct rapl_domain *rd = rp->domains;\n\n\tfor (i = 0; i < RAPL_DOMAIN_MAX; i++) {\n\t\tunsigned int mask = rp->domain_map & (1 << i);\n\t\tint t;\n\n\t\tif (!mask)\n\t\t\tcontinue;\n\n\t\trd->rp = rp;\n\n\t\tif (i == RAPL_DOMAIN_PLATFORM && rp->id > 0) {\n\t\t\tsnprintf(rd->name, RAPL_DOMAIN_NAME_LENGTH, \"psys-%d\",\n\t\t\t\trp->lead_cpu >= 0 ? topology_physical_package_id(rp->lead_cpu) :\n\t\t\t\trp->id);\n\t\t} else {\n\t\t\tsnprintf(rd->name, RAPL_DOMAIN_NAME_LENGTH, \"%s\",\n\t\t\t\trapl_domain_names[i]);\n\t\t}\n\n\t\trd->id = i;\n\n\t\t \n\t\trp->priv->limits[i] |= BIT(POWER_LIMIT1);\n\n\t\tfor (t = POWER_LIMIT1; t < NR_POWER_LIMITS; t++) {\n\t\t\tif (rp->priv->limits[i] & BIT(t))\n\t\t\t\trd->rpl[t].name = pl_names[t];\n\t\t}\n\n\t\tfor (j = 0; j < RAPL_DOMAIN_REG_MAX; j++)\n\t\t\trd->regs[j] = rp->priv->regs[i][j];\n\n\t\trd++;\n\t}\n}\n\nstatic u64 rapl_unit_xlate(struct rapl_domain *rd, enum unit_type type,\n\t\t\t   u64 value, int to_raw)\n{\n\tu64 units = 1;\n\tstruct rapl_defaults *defaults = get_defaults(rd->rp);\n\tu64 scale = 1;\n\n\tswitch (type) {\n\tcase POWER_UNIT:\n\t\tunits = rd->power_unit;\n\t\tbreak;\n\tcase ENERGY_UNIT:\n\t\tscale = ENERGY_UNIT_SCALE;\n\t\tunits = rd->energy_unit;\n\t\tbreak;\n\tcase TIME_UNIT:\n\t\treturn defaults->compute_time_window(rd, value, to_raw);\n\tcase ARBITRARY_UNIT:\n\tdefault:\n\t\treturn value;\n\t}\n\n\tif (to_raw)\n\t\treturn div64_u64(value, units) * scale;\n\n\tvalue *= units;\n\n\treturn div64_u64(value, scale);\n}\n\n \nstatic struct rapl_primitive_info rpi_msr[NR_RAPL_PRIMITIVES] = {\n\t \n\t[POWER_LIMIT1] = PRIMITIVE_INFO_INIT(POWER_LIMIT1, POWER_LIMIT1_MASK, 0,\n\t\t\t    RAPL_DOMAIN_REG_LIMIT, POWER_UNIT, 0),\n\t[POWER_LIMIT2] = PRIMITIVE_INFO_INIT(POWER_LIMIT2, POWER_LIMIT2_MASK, 32,\n\t\t\t    RAPL_DOMAIN_REG_LIMIT, POWER_UNIT, 0),\n\t[POWER_LIMIT4] = PRIMITIVE_INFO_INIT(POWER_LIMIT4, POWER_LIMIT4_MASK, 0,\n\t\t\t\tRAPL_DOMAIN_REG_PL4, POWER_UNIT, 0),\n\t[ENERGY_COUNTER] = PRIMITIVE_INFO_INIT(ENERGY_COUNTER, ENERGY_STATUS_MASK, 0,\n\t\t\t    RAPL_DOMAIN_REG_STATUS, ENERGY_UNIT, 0),\n\t[FW_LOCK] = PRIMITIVE_INFO_INIT(FW_LOCK, POWER_LOW_LOCK, 31,\n\t\t\t    RAPL_DOMAIN_REG_LIMIT, ARBITRARY_UNIT, 0),\n\t[FW_HIGH_LOCK] = PRIMITIVE_INFO_INIT(FW_LOCK, POWER_HIGH_LOCK, 63,\n\t\t\t    RAPL_DOMAIN_REG_LIMIT, ARBITRARY_UNIT, 0),\n\t[PL1_ENABLE] = PRIMITIVE_INFO_INIT(PL1_ENABLE, POWER_LIMIT1_ENABLE, 15,\n\t\t\t    RAPL_DOMAIN_REG_LIMIT, ARBITRARY_UNIT, 0),\n\t[PL1_CLAMP] = PRIMITIVE_INFO_INIT(PL1_CLAMP, POWER_LIMIT1_CLAMP, 16,\n\t\t\t    RAPL_DOMAIN_REG_LIMIT, ARBITRARY_UNIT, 0),\n\t[PL2_ENABLE] = PRIMITIVE_INFO_INIT(PL2_ENABLE, POWER_LIMIT2_ENABLE, 47,\n\t\t\t    RAPL_DOMAIN_REG_LIMIT, ARBITRARY_UNIT, 0),\n\t[PL2_CLAMP] = PRIMITIVE_INFO_INIT(PL2_CLAMP, POWER_LIMIT2_CLAMP, 48,\n\t\t\t    RAPL_DOMAIN_REG_LIMIT, ARBITRARY_UNIT, 0),\n\t[TIME_WINDOW1] = PRIMITIVE_INFO_INIT(TIME_WINDOW1, TIME_WINDOW1_MASK, 17,\n\t\t\t    RAPL_DOMAIN_REG_LIMIT, TIME_UNIT, 0),\n\t[TIME_WINDOW2] = PRIMITIVE_INFO_INIT(TIME_WINDOW2, TIME_WINDOW2_MASK, 49,\n\t\t\t    RAPL_DOMAIN_REG_LIMIT, TIME_UNIT, 0),\n\t[THERMAL_SPEC_POWER] = PRIMITIVE_INFO_INIT(THERMAL_SPEC_POWER, POWER_INFO_THERMAL_SPEC_MASK,\n\t\t\t    0, RAPL_DOMAIN_REG_INFO, POWER_UNIT, 0),\n\t[MAX_POWER] = PRIMITIVE_INFO_INIT(MAX_POWER, POWER_INFO_MAX_MASK, 32,\n\t\t\t    RAPL_DOMAIN_REG_INFO, POWER_UNIT, 0),\n\t[MIN_POWER] = PRIMITIVE_INFO_INIT(MIN_POWER, POWER_INFO_MIN_MASK, 16,\n\t\t\t    RAPL_DOMAIN_REG_INFO, POWER_UNIT, 0),\n\t[MAX_TIME_WINDOW] = PRIMITIVE_INFO_INIT(MAX_TIME_WINDOW, POWER_INFO_MAX_TIME_WIN_MASK, 48,\n\t\t\t    RAPL_DOMAIN_REG_INFO, TIME_UNIT, 0),\n\t[THROTTLED_TIME] = PRIMITIVE_INFO_INIT(THROTTLED_TIME, PERF_STATUS_THROTTLE_TIME_MASK, 0,\n\t\t\t    RAPL_DOMAIN_REG_PERF, TIME_UNIT, 0),\n\t[PRIORITY_LEVEL] = PRIMITIVE_INFO_INIT(PRIORITY_LEVEL, PP_POLICY_MASK, 0,\n\t\t\t    RAPL_DOMAIN_REG_POLICY, ARBITRARY_UNIT, 0),\n\t[PSYS_POWER_LIMIT1] = PRIMITIVE_INFO_INIT(PSYS_POWER_LIMIT1, PSYS_POWER_LIMIT1_MASK, 0,\n\t\t\t    RAPL_DOMAIN_REG_LIMIT, POWER_UNIT, 0),\n\t[PSYS_POWER_LIMIT2] = PRIMITIVE_INFO_INIT(PSYS_POWER_LIMIT2, PSYS_POWER_LIMIT2_MASK, 32,\n\t\t\t    RAPL_DOMAIN_REG_LIMIT, POWER_UNIT, 0),\n\t[PSYS_PL1_ENABLE] = PRIMITIVE_INFO_INIT(PSYS_PL1_ENABLE, PSYS_POWER_LIMIT1_ENABLE, 17,\n\t\t\t    RAPL_DOMAIN_REG_LIMIT, ARBITRARY_UNIT, 0),\n\t[PSYS_PL2_ENABLE] = PRIMITIVE_INFO_INIT(PSYS_PL2_ENABLE, PSYS_POWER_LIMIT2_ENABLE, 49,\n\t\t\t    RAPL_DOMAIN_REG_LIMIT, ARBITRARY_UNIT, 0),\n\t[PSYS_TIME_WINDOW1] = PRIMITIVE_INFO_INIT(PSYS_TIME_WINDOW1, PSYS_TIME_WINDOW1_MASK, 19,\n\t\t\t    RAPL_DOMAIN_REG_LIMIT, TIME_UNIT, 0),\n\t[PSYS_TIME_WINDOW2] = PRIMITIVE_INFO_INIT(PSYS_TIME_WINDOW2, PSYS_TIME_WINDOW2_MASK, 51,\n\t\t\t    RAPL_DOMAIN_REG_LIMIT, TIME_UNIT, 0),\n\t \n\t[AVERAGE_POWER] = PRIMITIVE_INFO_INIT(AVERAGE_POWER, 0, 0, 0, POWER_UNIT,\n\t\t\t    RAPL_PRIMITIVE_DERIVED),\n};\n\n \nstatic struct rapl_primitive_info rpi_tpmi[NR_RAPL_PRIMITIVES] = {\n\t \n\t[POWER_LIMIT1] = PRIMITIVE_INFO_INIT(POWER_LIMIT1, TPMI_POWER_LIMIT_MASK, 0,\n\t\tRAPL_DOMAIN_REG_LIMIT, POWER_UNIT, 0),\n\t[POWER_LIMIT2] = PRIMITIVE_INFO_INIT(POWER_LIMIT2, TPMI_POWER_LIMIT_MASK, 0,\n\t\tRAPL_DOMAIN_REG_PL2, POWER_UNIT, 0),\n\t[POWER_LIMIT4] = PRIMITIVE_INFO_INIT(POWER_LIMIT4, TPMI_POWER_LIMIT_MASK, 0,\n\t\tRAPL_DOMAIN_REG_PL4, POWER_UNIT, 0),\n\t[ENERGY_COUNTER] = PRIMITIVE_INFO_INIT(ENERGY_COUNTER, ENERGY_STATUS_MASK, 0,\n\t\tRAPL_DOMAIN_REG_STATUS, ENERGY_UNIT, 0),\n\t[PL1_LOCK] = PRIMITIVE_INFO_INIT(PL1_LOCK, POWER_HIGH_LOCK, 63,\n\t\tRAPL_DOMAIN_REG_LIMIT, ARBITRARY_UNIT, 0),\n\t[PL2_LOCK] = PRIMITIVE_INFO_INIT(PL2_LOCK, POWER_HIGH_LOCK, 63,\n\t\tRAPL_DOMAIN_REG_PL2, ARBITRARY_UNIT, 0),\n\t[PL4_LOCK] = PRIMITIVE_INFO_INIT(PL4_LOCK, POWER_HIGH_LOCK, 63,\n\t\tRAPL_DOMAIN_REG_PL4, ARBITRARY_UNIT, 0),\n\t[PL1_ENABLE] = PRIMITIVE_INFO_INIT(PL1_ENABLE, TPMI_POWER_LIMIT_ENABLE, 62,\n\t\tRAPL_DOMAIN_REG_LIMIT, ARBITRARY_UNIT, 0),\n\t[PL2_ENABLE] = PRIMITIVE_INFO_INIT(PL2_ENABLE, TPMI_POWER_LIMIT_ENABLE, 62,\n\t\tRAPL_DOMAIN_REG_PL2, ARBITRARY_UNIT, 0),\n\t[PL4_ENABLE] = PRIMITIVE_INFO_INIT(PL4_ENABLE, TPMI_POWER_LIMIT_ENABLE, 62,\n\t\tRAPL_DOMAIN_REG_PL4, ARBITRARY_UNIT, 0),\n\t[TIME_WINDOW1] = PRIMITIVE_INFO_INIT(TIME_WINDOW1, TPMI_TIME_WINDOW_MASK, 18,\n\t\tRAPL_DOMAIN_REG_LIMIT, TIME_UNIT, 0),\n\t[TIME_WINDOW2] = PRIMITIVE_INFO_INIT(TIME_WINDOW2, TPMI_TIME_WINDOW_MASK, 18,\n\t\tRAPL_DOMAIN_REG_PL2, TIME_UNIT, 0),\n\t[THERMAL_SPEC_POWER] = PRIMITIVE_INFO_INIT(THERMAL_SPEC_POWER, TPMI_INFO_SPEC_MASK, 0,\n\t\tRAPL_DOMAIN_REG_INFO, POWER_UNIT, 0),\n\t[MAX_POWER] = PRIMITIVE_INFO_INIT(MAX_POWER, TPMI_INFO_MAX_MASK, 36,\n\t\tRAPL_DOMAIN_REG_INFO, POWER_UNIT, 0),\n\t[MIN_POWER] = PRIMITIVE_INFO_INIT(MIN_POWER, TPMI_INFO_MIN_MASK, 18,\n\t\tRAPL_DOMAIN_REG_INFO, POWER_UNIT, 0),\n\t[MAX_TIME_WINDOW] = PRIMITIVE_INFO_INIT(MAX_TIME_WINDOW, TPMI_INFO_MAX_TIME_WIN_MASK, 54,\n\t\tRAPL_DOMAIN_REG_INFO, TIME_UNIT, 0),\n\t[THROTTLED_TIME] = PRIMITIVE_INFO_INIT(THROTTLED_TIME, PERF_STATUS_THROTTLE_TIME_MASK, 0,\n\t\tRAPL_DOMAIN_REG_PERF, TIME_UNIT, 0),\n\t \n\t[AVERAGE_POWER] = PRIMITIVE_INFO_INIT(AVERAGE_POWER, 0, 0, 0,\n\t\tPOWER_UNIT, RAPL_PRIMITIVE_DERIVED),\n};\n\nstatic struct rapl_primitive_info *get_rpi(struct rapl_package *rp, int prim)\n{\n\tstruct rapl_primitive_info *rpi = rp->priv->rpi;\n\n\tif (prim < 0 || prim > NR_RAPL_PRIMITIVES || !rpi)\n\t\treturn NULL;\n\n\treturn &rpi[prim];\n}\n\nstatic int rapl_config(struct rapl_package *rp)\n{\n\tswitch (rp->priv->type) {\n\t \n\tcase RAPL_IF_MMIO:\n\tcase RAPL_IF_MSR:\n\t\trp->priv->defaults = (void *)defaults_msr;\n\t\trp->priv->rpi = (void *)rpi_msr;\n\t\tbreak;\n\tcase RAPL_IF_TPMI:\n\t\trp->priv->defaults = (void *)&defaults_tpmi;\n\t\trp->priv->rpi = (void *)rpi_tpmi;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic enum rapl_primitives\nprim_fixups(struct rapl_domain *rd, enum rapl_primitives prim)\n{\n\tstruct rapl_defaults *defaults = get_defaults(rd->rp);\n\n\tif (!defaults->spr_psys_bits)\n\t\treturn prim;\n\n\tif (rd->id != RAPL_DOMAIN_PLATFORM)\n\t\treturn prim;\n\n\tswitch (prim) {\n\tcase POWER_LIMIT1:\n\t\treturn PSYS_POWER_LIMIT1;\n\tcase POWER_LIMIT2:\n\t\treturn PSYS_POWER_LIMIT2;\n\tcase PL1_ENABLE:\n\t\treturn PSYS_PL1_ENABLE;\n\tcase PL2_ENABLE:\n\t\treturn PSYS_PL2_ENABLE;\n\tcase TIME_WINDOW1:\n\t\treturn PSYS_TIME_WINDOW1;\n\tcase TIME_WINDOW2:\n\t\treturn PSYS_TIME_WINDOW2;\n\tdefault:\n\t\treturn prim;\n\t}\n}\n\n \nstatic int rapl_read_data_raw(struct rapl_domain *rd,\n\t\t\t      enum rapl_primitives prim, bool xlate, u64 *data)\n{\n\tu64 value;\n\tenum rapl_primitives prim_fixed = prim_fixups(rd, prim);\n\tstruct rapl_primitive_info *rpi = get_rpi(rd->rp, prim_fixed);\n\tstruct reg_action ra;\n\n\tif (!rpi || !rpi->name || rpi->flag & RAPL_PRIMITIVE_DUMMY)\n\t\treturn -EINVAL;\n\n\tra.reg = rd->regs[rpi->id];\n\tif (!ra.reg.val)\n\t\treturn -EINVAL;\n\n\t \n\tif (rpi->flag & RAPL_PRIMITIVE_DERIVED) {\n\t\t*data = rd->rdd.primitives[prim];\n\t\treturn 0;\n\t}\n\n\tra.mask = rpi->mask;\n\n\tif (rd->rp->priv->read_raw(get_rid(rd->rp), &ra)) {\n\t\tpr_debug(\"failed to read reg 0x%llx for %s:%s\\n\", ra.reg.val, rd->rp->name, rd->name);\n\t\treturn -EIO;\n\t}\n\n\tvalue = ra.value >> rpi->shift;\n\n\tif (xlate)\n\t\t*data = rapl_unit_xlate(rd, rpi->unit, value, 0);\n\telse\n\t\t*data = value;\n\n\treturn 0;\n}\n\n \nstatic int rapl_write_data_raw(struct rapl_domain *rd,\n\t\t\t       enum rapl_primitives prim,\n\t\t\t       unsigned long long value)\n{\n\tenum rapl_primitives prim_fixed = prim_fixups(rd, prim);\n\tstruct rapl_primitive_info *rpi = get_rpi(rd->rp, prim_fixed);\n\tu64 bits;\n\tstruct reg_action ra;\n\tint ret;\n\n\tif (!rpi || !rpi->name || rpi->flag & RAPL_PRIMITIVE_DUMMY)\n\t\treturn -EINVAL;\n\n\tbits = rapl_unit_xlate(rd, rpi->unit, value, 1);\n\tbits <<= rpi->shift;\n\tbits &= rpi->mask;\n\n\tmemset(&ra, 0, sizeof(ra));\n\n\tra.reg = rd->regs[rpi->id];\n\tra.mask = rpi->mask;\n\tra.value = bits;\n\n\tret = rd->rp->priv->write_raw(get_rid(rd->rp), &ra);\n\n\treturn ret;\n}\n\nstatic int rapl_read_pl_data(struct rapl_domain *rd, int pl,\n\t\t\t      enum pl_prims pl_prim, bool xlate, u64 *data)\n{\n\tenum rapl_primitives prim = get_pl_prim(rd, pl, pl_prim);\n\n\tif (!is_pl_valid(rd, pl))\n\t\treturn -EINVAL;\n\n\treturn rapl_read_data_raw(rd, prim, xlate, data);\n}\n\nstatic int rapl_write_pl_data(struct rapl_domain *rd, int pl,\n\t\t\t       enum pl_prims pl_prim,\n\t\t\t       unsigned long long value)\n{\n\tenum rapl_primitives prim = get_pl_prim(rd, pl, pl_prim);\n\n\tif (!is_pl_valid(rd, pl))\n\t\treturn -EINVAL;\n\n\tif (rd->rpl[pl].locked) {\n\t\tpr_debug(\"%s:%s:%s locked by BIOS\\n\", rd->rp->name, rd->name, pl_names[pl]);\n\t\treturn -EACCES;\n\t}\n\n\treturn rapl_write_data_raw(rd, prim, value);\n}\n \nstatic int rapl_check_unit_core(struct rapl_domain *rd)\n{\n\tstruct reg_action ra;\n\tu32 value;\n\n\tra.reg = rd->regs[RAPL_DOMAIN_REG_UNIT];\n\tra.mask = ~0;\n\tif (rd->rp->priv->read_raw(get_rid(rd->rp), &ra)) {\n\t\tpr_err(\"Failed to read power unit REG 0x%llx on %s:%s, exit.\\n\",\n\t\t\tra.reg.val, rd->rp->name, rd->name);\n\t\treturn -ENODEV;\n\t}\n\n\tvalue = (ra.value & ENERGY_UNIT_MASK) >> ENERGY_UNIT_OFFSET;\n\trd->energy_unit = ENERGY_UNIT_SCALE * 1000000 / (1 << value);\n\n\tvalue = (ra.value & POWER_UNIT_MASK) >> POWER_UNIT_OFFSET;\n\trd->power_unit = 1000000 / (1 << value);\n\n\tvalue = (ra.value & TIME_UNIT_MASK) >> TIME_UNIT_OFFSET;\n\trd->time_unit = 1000000 / (1 << value);\n\n\tpr_debug(\"Core CPU %s:%s energy=%dpJ, time=%dus, power=%duW\\n\",\n\t\t rd->rp->name, rd->name, rd->energy_unit, rd->time_unit, rd->power_unit);\n\n\treturn 0;\n}\n\nstatic int rapl_check_unit_atom(struct rapl_domain *rd)\n{\n\tstruct reg_action ra;\n\tu32 value;\n\n\tra.reg = rd->regs[RAPL_DOMAIN_REG_UNIT];\n\tra.mask = ~0;\n\tif (rd->rp->priv->read_raw(get_rid(rd->rp), &ra)) {\n\t\tpr_err(\"Failed to read power unit REG 0x%llx on %s:%s, exit.\\n\",\n\t\t\tra.reg.val, rd->rp->name, rd->name);\n\t\treturn -ENODEV;\n\t}\n\n\tvalue = (ra.value & ENERGY_UNIT_MASK) >> ENERGY_UNIT_OFFSET;\n\trd->energy_unit = ENERGY_UNIT_SCALE * 1 << value;\n\n\tvalue = (ra.value & POWER_UNIT_MASK) >> POWER_UNIT_OFFSET;\n\trd->power_unit = (1 << value) * 1000;\n\n\tvalue = (ra.value & TIME_UNIT_MASK) >> TIME_UNIT_OFFSET;\n\trd->time_unit = 1000000 / (1 << value);\n\n\tpr_debug(\"Atom %s:%s energy=%dpJ, time=%dus, power=%duW\\n\",\n\t\t rd->rp->name, rd->name, rd->energy_unit, rd->time_unit, rd->power_unit);\n\n\treturn 0;\n}\n\nstatic void power_limit_irq_save_cpu(void *info)\n{\n\tu32 l, h = 0;\n\tstruct rapl_package *rp = (struct rapl_package *)info;\n\n\t \n\trdmsr_safe(MSR_IA32_PACKAGE_THERM_INTERRUPT, &l, &h);\n\tif (!(rp->power_limit_irq & PACKAGE_PLN_INT_SAVED)) {\n\t\trp->power_limit_irq = l & PACKAGE_THERM_INT_PLN_ENABLE;\n\t\trp->power_limit_irq |= PACKAGE_PLN_INT_SAVED;\n\t}\n\tl &= ~PACKAGE_THERM_INT_PLN_ENABLE;\n\twrmsr_safe(MSR_IA32_PACKAGE_THERM_INTERRUPT, l, h);\n}\n\n \n\nstatic void package_power_limit_irq_save(struct rapl_package *rp)\n{\n\tif (rp->lead_cpu < 0)\n\t\treturn;\n\n\tif (!boot_cpu_has(X86_FEATURE_PTS) || !boot_cpu_has(X86_FEATURE_PLN))\n\t\treturn;\n\n\tsmp_call_function_single(rp->lead_cpu, power_limit_irq_save_cpu, rp, 1);\n}\n\n \nstatic void package_power_limit_irq_restore(struct rapl_package *rp)\n{\n\tu32 l, h;\n\n\tif (rp->lead_cpu < 0)\n\t\treturn;\n\n\tif (!boot_cpu_has(X86_FEATURE_PTS) || !boot_cpu_has(X86_FEATURE_PLN))\n\t\treturn;\n\n\t \n\tif (!(rp->power_limit_irq & PACKAGE_PLN_INT_SAVED))\n\t\treturn;\n\n\trdmsr_safe(MSR_IA32_PACKAGE_THERM_INTERRUPT, &l, &h);\n\n\tif (rp->power_limit_irq & PACKAGE_THERM_INT_PLN_ENABLE)\n\t\tl |= PACKAGE_THERM_INT_PLN_ENABLE;\n\telse\n\t\tl &= ~PACKAGE_THERM_INT_PLN_ENABLE;\n\n\twrmsr_safe(MSR_IA32_PACKAGE_THERM_INTERRUPT, l, h);\n}\n\nstatic void set_floor_freq_default(struct rapl_domain *rd, bool mode)\n{\n\tint i;\n\n\t \n\trapl_write_pl_data(rd, POWER_LIMIT1, PL_CLAMP, mode);\n\n\tfor (i = POWER_LIMIT2; i < NR_POWER_LIMITS; i++) {\n\t\trapl_write_pl_data(rd, i, PL_ENABLE, mode);\n\t\trapl_write_pl_data(rd, i, PL_CLAMP, mode);\n\t}\n}\n\nstatic void set_floor_freq_atom(struct rapl_domain *rd, bool enable)\n{\n\tstatic u32 power_ctrl_orig_val;\n\tstruct rapl_defaults *defaults = get_defaults(rd->rp);\n\tu32 mdata;\n\n\tif (!defaults->floor_freq_reg_addr) {\n\t\tpr_err(\"Invalid floor frequency config register\\n\");\n\t\treturn;\n\t}\n\n\tif (!power_ctrl_orig_val)\n\t\tiosf_mbi_read(BT_MBI_UNIT_PMC, MBI_CR_READ,\n\t\t\t      defaults->floor_freq_reg_addr,\n\t\t\t      &power_ctrl_orig_val);\n\tmdata = power_ctrl_orig_val;\n\tif (enable) {\n\t\tmdata &= ~(0x7f << 8);\n\t\tmdata |= 1 << 8;\n\t}\n\tiosf_mbi_write(BT_MBI_UNIT_PMC, MBI_CR_WRITE,\n\t\t       defaults->floor_freq_reg_addr, mdata);\n}\n\nstatic u64 rapl_compute_time_window_core(struct rapl_domain *rd, u64 value,\n\t\t\t\t\t bool to_raw)\n{\n\tu64 f, y;\t\t \n\n\t \n\tif (!to_raw) {\n\t\tf = (value & 0x60) >> 5;\n\t\ty = value & 0x1f;\n\t\tvalue = (1 << y) * (4 + f) * rd->time_unit / 4;\n\t} else {\n\t\tif (value < rd->time_unit)\n\t\t\treturn 0;\n\n\t\tdo_div(value, rd->time_unit);\n\t\ty = ilog2(value);\n\n\t\t \n\t\tif (y > 0x1f)\n\t\t\treturn 0x7f;\n\n\t\tf = div64_u64(4 * (value - (1ULL << y)), 1ULL << y);\n\t\tvalue = (y & 0x1f) | ((f & 0x3) << 5);\n\t}\n\treturn value;\n}\n\nstatic u64 rapl_compute_time_window_atom(struct rapl_domain *rd, u64 value,\n\t\t\t\t\t bool to_raw)\n{\n\t \n\tif (!to_raw)\n\t\treturn (value) ? value * rd->time_unit : rd->time_unit;\n\n\tvalue = div64_u64(value, rd->time_unit);\n\n\treturn value;\n}\n\n \n#define TPMI_POWER_UNIT_OFFSET\tPOWER_UNIT_OFFSET\n#define TPMI_POWER_UNIT_MASK\tPOWER_UNIT_MASK\n#define TPMI_ENERGY_UNIT_OFFSET\t0x06\n#define TPMI_ENERGY_UNIT_MASK\t0x7C0\n#define TPMI_TIME_UNIT_OFFSET\t0x0C\n#define TPMI_TIME_UNIT_MASK\t0xF000\n\nstatic int rapl_check_unit_tpmi(struct rapl_domain *rd)\n{\n\tstruct reg_action ra;\n\tu32 value;\n\n\tra.reg = rd->regs[RAPL_DOMAIN_REG_UNIT];\n\tra.mask = ~0;\n\tif (rd->rp->priv->read_raw(get_rid(rd->rp), &ra)) {\n\t\tpr_err(\"Failed to read power unit REG 0x%llx on %s:%s, exit.\\n\",\n\t\t\tra.reg.val, rd->rp->name, rd->name);\n\t\treturn -ENODEV;\n\t}\n\n\tvalue = (ra.value & TPMI_ENERGY_UNIT_MASK) >> TPMI_ENERGY_UNIT_OFFSET;\n\trd->energy_unit = ENERGY_UNIT_SCALE * 1000000 / (1 << value);\n\n\tvalue = (ra.value & TPMI_POWER_UNIT_MASK) >> TPMI_POWER_UNIT_OFFSET;\n\trd->power_unit = 1000000 / (1 << value);\n\n\tvalue = (ra.value & TPMI_TIME_UNIT_MASK) >> TPMI_TIME_UNIT_OFFSET;\n\trd->time_unit = 1000000 / (1 << value);\n\n\tpr_debug(\"Core CPU %s:%s energy=%dpJ, time=%dus, power=%duW\\n\",\n\t\t rd->rp->name, rd->name, rd->energy_unit, rd->time_unit, rd->power_unit);\n\n\treturn 0;\n}\n\nstatic const struct rapl_defaults defaults_tpmi = {\n\t.check_unit = rapl_check_unit_tpmi,\n\t \n\t.set_floor_freq = set_floor_freq_default,\n\t.compute_time_window = rapl_compute_time_window_core,\n};\n\nstatic const struct rapl_defaults rapl_defaults_core = {\n\t.floor_freq_reg_addr = 0,\n\t.check_unit = rapl_check_unit_core,\n\t.set_floor_freq = set_floor_freq_default,\n\t.compute_time_window = rapl_compute_time_window_core,\n};\n\nstatic const struct rapl_defaults rapl_defaults_hsw_server = {\n\t.check_unit = rapl_check_unit_core,\n\t.set_floor_freq = set_floor_freq_default,\n\t.compute_time_window = rapl_compute_time_window_core,\n\t.dram_domain_energy_unit = 15300,\n};\n\nstatic const struct rapl_defaults rapl_defaults_spr_server = {\n\t.check_unit = rapl_check_unit_core,\n\t.set_floor_freq = set_floor_freq_default,\n\t.compute_time_window = rapl_compute_time_window_core,\n\t.psys_domain_energy_unit = 1000000000,\n\t.spr_psys_bits = true,\n};\n\nstatic const struct rapl_defaults rapl_defaults_byt = {\n\t.floor_freq_reg_addr = IOSF_CPU_POWER_BUDGET_CTL_BYT,\n\t.check_unit = rapl_check_unit_atom,\n\t.set_floor_freq = set_floor_freq_atom,\n\t.compute_time_window = rapl_compute_time_window_atom,\n};\n\nstatic const struct rapl_defaults rapl_defaults_tng = {\n\t.floor_freq_reg_addr = IOSF_CPU_POWER_BUDGET_CTL_TNG,\n\t.check_unit = rapl_check_unit_atom,\n\t.set_floor_freq = set_floor_freq_atom,\n\t.compute_time_window = rapl_compute_time_window_atom,\n};\n\nstatic const struct rapl_defaults rapl_defaults_ann = {\n\t.floor_freq_reg_addr = 0,\n\t.check_unit = rapl_check_unit_atom,\n\t.set_floor_freq = NULL,\n\t.compute_time_window = rapl_compute_time_window_atom,\n};\n\nstatic const struct rapl_defaults rapl_defaults_cht = {\n\t.floor_freq_reg_addr = 0,\n\t.check_unit = rapl_check_unit_atom,\n\t.set_floor_freq = NULL,\n\t.compute_time_window = rapl_compute_time_window_atom,\n};\n\nstatic const struct rapl_defaults rapl_defaults_amd = {\n\t.check_unit = rapl_check_unit_core,\n};\n\nstatic const struct x86_cpu_id rapl_ids[] __initconst = {\n\tX86_MATCH_INTEL_FAM6_MODEL(SANDYBRIDGE,\t\t&rapl_defaults_core),\n\tX86_MATCH_INTEL_FAM6_MODEL(SANDYBRIDGE_X,\t&rapl_defaults_core),\n\n\tX86_MATCH_INTEL_FAM6_MODEL(IVYBRIDGE,\t\t&rapl_defaults_core),\n\tX86_MATCH_INTEL_FAM6_MODEL(IVYBRIDGE_X,\t\t&rapl_defaults_core),\n\n\tX86_MATCH_INTEL_FAM6_MODEL(HASWELL,\t\t&rapl_defaults_core),\n\tX86_MATCH_INTEL_FAM6_MODEL(HASWELL_L,\t\t&rapl_defaults_core),\n\tX86_MATCH_INTEL_FAM6_MODEL(HASWELL_G,\t\t&rapl_defaults_core),\n\tX86_MATCH_INTEL_FAM6_MODEL(HASWELL_X,\t\t&rapl_defaults_hsw_server),\n\n\tX86_MATCH_INTEL_FAM6_MODEL(BROADWELL,\t\t&rapl_defaults_core),\n\tX86_MATCH_INTEL_FAM6_MODEL(BROADWELL_G,\t\t&rapl_defaults_core),\n\tX86_MATCH_INTEL_FAM6_MODEL(BROADWELL_D,\t\t&rapl_defaults_core),\n\tX86_MATCH_INTEL_FAM6_MODEL(BROADWELL_X,\t\t&rapl_defaults_hsw_server),\n\n\tX86_MATCH_INTEL_FAM6_MODEL(SKYLAKE,\t\t&rapl_defaults_core),\n\tX86_MATCH_INTEL_FAM6_MODEL(SKYLAKE_L,\t\t&rapl_defaults_core),\n\tX86_MATCH_INTEL_FAM6_MODEL(SKYLAKE_X,\t\t&rapl_defaults_hsw_server),\n\tX86_MATCH_INTEL_FAM6_MODEL(KABYLAKE_L,\t\t&rapl_defaults_core),\n\tX86_MATCH_INTEL_FAM6_MODEL(KABYLAKE,\t\t&rapl_defaults_core),\n\tX86_MATCH_INTEL_FAM6_MODEL(CANNONLAKE_L,\t&rapl_defaults_core),\n\tX86_MATCH_INTEL_FAM6_MODEL(ICELAKE_L,\t\t&rapl_defaults_core),\n\tX86_MATCH_INTEL_FAM6_MODEL(ICELAKE,\t\t&rapl_defaults_core),\n\tX86_MATCH_INTEL_FAM6_MODEL(ICELAKE_NNPI,\t&rapl_defaults_core),\n\tX86_MATCH_INTEL_FAM6_MODEL(ICELAKE_X,\t\t&rapl_defaults_hsw_server),\n\tX86_MATCH_INTEL_FAM6_MODEL(ICELAKE_D,\t\t&rapl_defaults_hsw_server),\n\tX86_MATCH_INTEL_FAM6_MODEL(COMETLAKE_L,\t\t&rapl_defaults_core),\n\tX86_MATCH_INTEL_FAM6_MODEL(COMETLAKE,\t\t&rapl_defaults_core),\n\tX86_MATCH_INTEL_FAM6_MODEL(TIGERLAKE_L,\t\t&rapl_defaults_core),\n\tX86_MATCH_INTEL_FAM6_MODEL(TIGERLAKE,\t\t&rapl_defaults_core),\n\tX86_MATCH_INTEL_FAM6_MODEL(ROCKETLAKE,\t\t&rapl_defaults_core),\n\tX86_MATCH_INTEL_FAM6_MODEL(ALDERLAKE,\t\t&rapl_defaults_core),\n\tX86_MATCH_INTEL_FAM6_MODEL(ALDERLAKE_L,\t\t&rapl_defaults_core),\n\tX86_MATCH_INTEL_FAM6_MODEL(ATOM_GRACEMONT,\t&rapl_defaults_core),\n\tX86_MATCH_INTEL_FAM6_MODEL(RAPTORLAKE,\t\t&rapl_defaults_core),\n\tX86_MATCH_INTEL_FAM6_MODEL(RAPTORLAKE_P,        &rapl_defaults_core),\n\tX86_MATCH_INTEL_FAM6_MODEL(RAPTORLAKE_S,\t&rapl_defaults_core),\n\tX86_MATCH_INTEL_FAM6_MODEL(METEORLAKE,\t\t&rapl_defaults_core),\n\tX86_MATCH_INTEL_FAM6_MODEL(METEORLAKE_L,\t&rapl_defaults_core),\n\tX86_MATCH_INTEL_FAM6_MODEL(SAPPHIRERAPIDS_X,\t&rapl_defaults_spr_server),\n\tX86_MATCH_INTEL_FAM6_MODEL(EMERALDRAPIDS_X,\t&rapl_defaults_spr_server),\n\tX86_MATCH_INTEL_FAM6_MODEL(LAKEFIELD,\t\t&rapl_defaults_core),\n\n\tX86_MATCH_INTEL_FAM6_MODEL(ATOM_SILVERMONT,\t&rapl_defaults_byt),\n\tX86_MATCH_INTEL_FAM6_MODEL(ATOM_AIRMONT,\t&rapl_defaults_cht),\n\tX86_MATCH_INTEL_FAM6_MODEL(ATOM_SILVERMONT_MID,\t&rapl_defaults_tng),\n\tX86_MATCH_INTEL_FAM6_MODEL(ATOM_AIRMONT_MID,\t&rapl_defaults_ann),\n\tX86_MATCH_INTEL_FAM6_MODEL(ATOM_GOLDMONT,\t&rapl_defaults_core),\n\tX86_MATCH_INTEL_FAM6_MODEL(ATOM_GOLDMONT_PLUS,\t&rapl_defaults_core),\n\tX86_MATCH_INTEL_FAM6_MODEL(ATOM_GOLDMONT_D,\t&rapl_defaults_core),\n\tX86_MATCH_INTEL_FAM6_MODEL(ATOM_TREMONT,\t&rapl_defaults_core),\n\tX86_MATCH_INTEL_FAM6_MODEL(ATOM_TREMONT_D,\t&rapl_defaults_core),\n\tX86_MATCH_INTEL_FAM6_MODEL(ATOM_TREMONT_L,\t&rapl_defaults_core),\n\n\tX86_MATCH_INTEL_FAM6_MODEL(XEON_PHI_KNL,\t&rapl_defaults_hsw_server),\n\tX86_MATCH_INTEL_FAM6_MODEL(XEON_PHI_KNM,\t&rapl_defaults_hsw_server),\n\n\tX86_MATCH_VENDOR_FAM(AMD, 0x17, &rapl_defaults_amd),\n\tX86_MATCH_VENDOR_FAM(AMD, 0x19, &rapl_defaults_amd),\n\tX86_MATCH_VENDOR_FAM(HYGON, 0x18, &rapl_defaults_amd),\n\t{}\n};\nMODULE_DEVICE_TABLE(x86cpu, rapl_ids);\n\n \nstatic void rapl_update_domain_data(struct rapl_package *rp)\n{\n\tint dmn, prim;\n\tu64 val;\n\n\tfor (dmn = 0; dmn < rp->nr_domains; dmn++) {\n\t\tpr_debug(\"update %s domain %s data\\n\", rp->name,\n\t\t\t rp->domains[dmn].name);\n\t\t \n\t\tfor (prim = 0; prim < NR_RAW_PRIMITIVES; prim++) {\n\t\t\tstruct rapl_primitive_info *rpi = get_rpi(rp, prim);\n\n\t\t\tif (!rapl_read_data_raw(&rp->domains[dmn], prim,\n\t\t\t\t\t\trpi->unit, &val))\n\t\t\t\trp->domains[dmn].rdd.primitives[prim] = val;\n\t\t}\n\t}\n\n}\n\nstatic int rapl_package_register_powercap(struct rapl_package *rp)\n{\n\tstruct rapl_domain *rd;\n\tstruct powercap_zone *power_zone = NULL;\n\tint nr_pl, ret;\n\n\t \n\trapl_update_domain_data(rp);\n\n\t \n\tfor (rd = rp->domains; rd < rp->domains + rp->nr_domains; rd++) {\n\t\tif (rd->id == RAPL_DOMAIN_PACKAGE) {\n\t\t\tnr_pl = find_nr_power_limit(rd);\n\t\t\tpr_debug(\"register package domain %s\\n\", rp->name);\n\t\t\tpower_zone = powercap_register_zone(&rd->power_zone,\n\t\t\t\t\t    rp->priv->control_type, rp->name,\n\t\t\t\t\t    NULL, &zone_ops[rd->id], nr_pl,\n\t\t\t\t\t    &constraint_ops);\n\t\t\tif (IS_ERR(power_zone)) {\n\t\t\t\tpr_debug(\"failed to register power zone %s\\n\",\n\t\t\t\t\t rp->name);\n\t\t\t\treturn PTR_ERR(power_zone);\n\t\t\t}\n\t\t\t \n\t\t\trp->power_zone = power_zone;\n\t\t\t \n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!power_zone) {\n\t\tpr_err(\"no package domain found, unknown topology!\\n\");\n\t\treturn -ENODEV;\n\t}\n\t \n\tfor (rd = rp->domains; rd < rp->domains + rp->nr_domains; rd++) {\n\t\tstruct powercap_zone *parent = rp->power_zone;\n\n\t\tif (rd->id == RAPL_DOMAIN_PACKAGE)\n\t\t\tcontinue;\n\t\tif (rd->id == RAPL_DOMAIN_PLATFORM)\n\t\t\tparent = NULL;\n\t\t \n\t\tnr_pl = find_nr_power_limit(rd);\n\t\tpower_zone = powercap_register_zone(&rd->power_zone,\n\t\t\t\t\t\t    rp->priv->control_type,\n\t\t\t\t\t\t    rd->name, parent,\n\t\t\t\t\t\t    &zone_ops[rd->id], nr_pl,\n\t\t\t\t\t\t    &constraint_ops);\n\n\t\tif (IS_ERR(power_zone)) {\n\t\t\tpr_debug(\"failed to register power_zone, %s:%s\\n\",\n\t\t\t\t rp->name, rd->name);\n\t\t\tret = PTR_ERR(power_zone);\n\t\t\tgoto err_cleanup;\n\t\t}\n\t}\n\treturn 0;\n\nerr_cleanup:\n\t \n\twhile (--rd >= rp->domains) {\n\t\tpr_debug(\"unregister %s domain %s\\n\", rp->name, rd->name);\n\t\tpowercap_unregister_zone(rp->priv->control_type,\n\t\t\t\t\t &rd->power_zone);\n\t}\n\n\treturn ret;\n}\n\nstatic int rapl_check_domain(int domain, struct rapl_package *rp)\n{\n\tstruct reg_action ra;\n\n\tswitch (domain) {\n\tcase RAPL_DOMAIN_PACKAGE:\n\tcase RAPL_DOMAIN_PP0:\n\tcase RAPL_DOMAIN_PP1:\n\tcase RAPL_DOMAIN_DRAM:\n\tcase RAPL_DOMAIN_PLATFORM:\n\t\tra.reg = rp->priv->regs[domain][RAPL_DOMAIN_REG_STATUS];\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"invalid domain id %d\\n\", domain);\n\t\treturn -EINVAL;\n\t}\n\t \n\n\tra.mask = ENERGY_STATUS_MASK;\n\tif (rp->priv->read_raw(get_rid(rp), &ra) || !ra.value)\n\t\treturn -ENODEV;\n\n\treturn 0;\n}\n\n \nstatic int rapl_get_domain_unit(struct rapl_domain *rd)\n{\n\tstruct rapl_defaults *defaults = get_defaults(rd->rp);\n\tint ret;\n\n\tif (!rd->regs[RAPL_DOMAIN_REG_UNIT].val) {\n\t\tif (!rd->rp->priv->reg_unit.val) {\n\t\t\tpr_err(\"No valid Unit register found\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\t\trd->regs[RAPL_DOMAIN_REG_UNIT] = rd->rp->priv->reg_unit;\n\t}\n\n\tif (!defaults->check_unit) {\n\t\tpr_err(\"missing .check_unit() callback\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tret = defaults->check_unit(rd);\n\tif (ret)\n\t\treturn ret;\n\n\tif (rd->id == RAPL_DOMAIN_DRAM && defaults->dram_domain_energy_unit)\n\t\trd->energy_unit = defaults->dram_domain_energy_unit;\n\tif (rd->id == RAPL_DOMAIN_PLATFORM && defaults->psys_domain_energy_unit)\n\t\trd->energy_unit = defaults->psys_domain_energy_unit;\n\treturn 0;\n}\n\n \nstatic void rapl_detect_powerlimit(struct rapl_domain *rd)\n{\n\tu64 val64;\n\tint i;\n\n\tfor (i = POWER_LIMIT1; i < NR_POWER_LIMITS; i++) {\n\t\tif (!rapl_read_pl_data(rd, i, PL_LOCK, false, &val64)) {\n\t\t\tif (val64) {\n\t\t\t\trd->rpl[i].locked = true;\n\t\t\t\tpr_info(\"%s:%s:%s locked by BIOS\\n\",\n\t\t\t\t\trd->rp->name, rd->name, pl_names[i]);\n\t\t\t}\n\t\t}\n\n\t\tif (rapl_read_pl_data(rd, i, PL_LIMIT, false, &val64))\n\t\t\trd->rpl[i].name = NULL;\n\t}\n}\n\n \nstatic int rapl_detect_domains(struct rapl_package *rp)\n{\n\tstruct rapl_domain *rd;\n\tint i;\n\n\tfor (i = 0; i < RAPL_DOMAIN_MAX; i++) {\n\t\t \n\t\tif (!rapl_check_domain(i, rp)) {\n\t\t\trp->domain_map |= 1 << i;\n\t\t\tpr_info(\"Found RAPL domain %s\\n\", rapl_domain_names[i]);\n\t\t}\n\t}\n\trp->nr_domains = bitmap_weight(&rp->domain_map, RAPL_DOMAIN_MAX);\n\tif (!rp->nr_domains) {\n\t\tpr_debug(\"no valid rapl domains found in %s\\n\", rp->name);\n\t\treturn -ENODEV;\n\t}\n\tpr_debug(\"found %d domains on %s\\n\", rp->nr_domains, rp->name);\n\n\trp->domains = kcalloc(rp->nr_domains, sizeof(struct rapl_domain),\n\t\t\t      GFP_KERNEL);\n\tif (!rp->domains)\n\t\treturn -ENOMEM;\n\n\trapl_init_domains(rp);\n\n\tfor (rd = rp->domains; rd < rp->domains + rp->nr_domains; rd++) {\n\t\trapl_get_domain_unit(rd);\n\t\trapl_detect_powerlimit(rd);\n\t}\n\n\treturn 0;\n}\n\n \nvoid rapl_remove_package(struct rapl_package *rp)\n{\n\tstruct rapl_domain *rd, *rd_package = NULL;\n\n\tpackage_power_limit_irq_restore(rp);\n\n\tfor (rd = rp->domains; rd < rp->domains + rp->nr_domains; rd++) {\n\t\tint i;\n\n\t\tfor (i = POWER_LIMIT1; i < NR_POWER_LIMITS; i++) {\n\t\t\trapl_write_pl_data(rd, i, PL_ENABLE, 0);\n\t\t\trapl_write_pl_data(rd, i, PL_CLAMP, 0);\n\t\t}\n\n\t\tif (rd->id == RAPL_DOMAIN_PACKAGE) {\n\t\t\trd_package = rd;\n\t\t\tcontinue;\n\t\t}\n\t\tpr_debug(\"remove package, undo power limit on %s: %s\\n\",\n\t\t\t rp->name, rd->name);\n\t\tpowercap_unregister_zone(rp->priv->control_type,\n\t\t\t\t\t &rd->power_zone);\n\t}\n\t \n\tpowercap_unregister_zone(rp->priv->control_type,\n\t\t\t\t &rd_package->power_zone);\n\tlist_del(&rp->plist);\n\tkfree(rp);\n}\nEXPORT_SYMBOL_GPL(rapl_remove_package);\n\n \nstruct rapl_package *rapl_find_package_domain(int id, struct rapl_if_priv *priv, bool id_is_cpu)\n{\n\tstruct rapl_package *rp;\n\tint uid;\n\n\tif (id_is_cpu)\n\t\tuid = topology_logical_die_id(id);\n\telse\n\t\tuid = id;\n\n\tlist_for_each_entry(rp, &rapl_packages, plist) {\n\t\tif (rp->id == uid\n\t\t    && rp->priv->control_type == priv->control_type)\n\t\t\treturn rp;\n\t}\n\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(rapl_find_package_domain);\n\n \nstruct rapl_package *rapl_add_package(int id, struct rapl_if_priv *priv, bool id_is_cpu)\n{\n\tstruct rapl_package *rp;\n\tint ret;\n\n\trp = kzalloc(sizeof(struct rapl_package), GFP_KERNEL);\n\tif (!rp)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (id_is_cpu) {\n\t\trp->id = topology_logical_die_id(id);\n\t\trp->lead_cpu = id;\n\t\tif (topology_max_die_per_package() > 1)\n\t\t\tsnprintf(rp->name, PACKAGE_DOMAIN_NAME_LENGTH, \"package-%d-die-%d\",\n\t\t\t\t topology_physical_package_id(id), topology_die_id(id));\n\t\telse\n\t\t\tsnprintf(rp->name, PACKAGE_DOMAIN_NAME_LENGTH, \"package-%d\",\n\t\t\t\t topology_physical_package_id(id));\n\t} else {\n\t\trp->id = id;\n\t\trp->lead_cpu = -1;\n\t\tsnprintf(rp->name, PACKAGE_DOMAIN_NAME_LENGTH, \"package-%d\", id);\n\t}\n\n\trp->priv = priv;\n\tret = rapl_config(rp);\n\tif (ret)\n\t\tgoto err_free_package;\n\n\t \n\tif (rapl_detect_domains(rp)) {\n\t\tret = -ENODEV;\n\t\tgoto err_free_package;\n\t}\n\tret = rapl_package_register_powercap(rp);\n\tif (!ret) {\n\t\tINIT_LIST_HEAD(&rp->plist);\n\t\tlist_add(&rp->plist, &rapl_packages);\n\t\treturn rp;\n\t}\n\nerr_free_package:\n\tkfree(rp->domains);\n\tkfree(rp);\n\treturn ERR_PTR(ret);\n}\nEXPORT_SYMBOL_GPL(rapl_add_package);\n\nstatic void power_limit_state_save(void)\n{\n\tstruct rapl_package *rp;\n\tstruct rapl_domain *rd;\n\tint ret, i;\n\n\tcpus_read_lock();\n\tlist_for_each_entry(rp, &rapl_packages, plist) {\n\t\tif (!rp->power_zone)\n\t\t\tcontinue;\n\t\trd = power_zone_to_rapl_domain(rp->power_zone);\n\t\tfor (i = POWER_LIMIT1; i < NR_POWER_LIMITS; i++) {\n\t\t\tret = rapl_read_pl_data(rd, i, PL_LIMIT, true,\n\t\t\t\t\t\t &rd->rpl[i].last_power_limit);\n\t\t\tif (ret)\n\t\t\t\trd->rpl[i].last_power_limit = 0;\n\t\t}\n\t}\n\tcpus_read_unlock();\n}\n\nstatic void power_limit_state_restore(void)\n{\n\tstruct rapl_package *rp;\n\tstruct rapl_domain *rd;\n\tint i;\n\n\tcpus_read_lock();\n\tlist_for_each_entry(rp, &rapl_packages, plist) {\n\t\tif (!rp->power_zone)\n\t\t\tcontinue;\n\t\trd = power_zone_to_rapl_domain(rp->power_zone);\n\t\tfor (i = POWER_LIMIT1; i < NR_POWER_LIMITS; i++)\n\t\t\tif (rd->rpl[i].last_power_limit)\n\t\t\t\trapl_write_pl_data(rd, i, PL_LIMIT,\n\t\t\t\t\t       rd->rpl[i].last_power_limit);\n\t}\n\tcpus_read_unlock();\n}\n\nstatic int rapl_pm_callback(struct notifier_block *nb,\n\t\t\t    unsigned long mode, void *_unused)\n{\n\tswitch (mode) {\n\tcase PM_SUSPEND_PREPARE:\n\t\tpower_limit_state_save();\n\t\tbreak;\n\tcase PM_POST_SUSPEND:\n\t\tpower_limit_state_restore();\n\t\tbreak;\n\t}\n\treturn NOTIFY_OK;\n}\n\nstatic struct notifier_block rapl_pm_notifier = {\n\t.notifier_call = rapl_pm_callback,\n};\n\nstatic struct platform_device *rapl_msr_platdev;\n\nstatic int __init rapl_init(void)\n{\n\tconst struct x86_cpu_id *id;\n\tint ret;\n\n\tid = x86_match_cpu(rapl_ids);\n\tif (id) {\n\t\tdefaults_msr = (struct rapl_defaults *)id->driver_data;\n\n\t\trapl_msr_platdev = platform_device_alloc(\"intel_rapl_msr\", 0);\n\t\tif (!rapl_msr_platdev)\n\t\t\treturn -ENOMEM;\n\n\t\tret = platform_device_add(rapl_msr_platdev);\n\t\tif (ret) {\n\t\t\tplatform_device_put(rapl_msr_platdev);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tret = register_pm_notifier(&rapl_pm_notifier);\n\tif (ret && rapl_msr_platdev) {\n\t\tplatform_device_del(rapl_msr_platdev);\n\t\tplatform_device_put(rapl_msr_platdev);\n\t}\n\n\treturn ret;\n}\n\nstatic void __exit rapl_exit(void)\n{\n\tplatform_device_unregister(rapl_msr_platdev);\n\tunregister_pm_notifier(&rapl_pm_notifier);\n}\n\nfs_initcall(rapl_init);\nmodule_exit(rapl_exit);\n\nMODULE_DESCRIPTION(\"Intel Runtime Average Power Limit (RAPL) common code\");\nMODULE_AUTHOR(\"Jacob Pan <jacob.jun.pan@intel.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}