{
  "module_name": "intel_rapl_tpmi.c",
  "hash_id": "5534eb2f8bf4652da4aed713e5c05b6ef46da2d5dec7d77d61cf03c1361dae0e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/powercap/intel_rapl_tpmi.c",
  "human_readable_source": "\n \n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/auxiliary_bus.h>\n#include <linux/io.h>\n#include <linux/intel_tpmi.h>\n#include <linux/intel_rapl.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\n#define TPMI_RAPL_VERSION 1\n\n \n#define TPMI_RAPL_DOMAIN_SIZE 128\n\nenum tpmi_rapl_domain_type {\n\tTPMI_RAPL_DOMAIN_INVALID,\n\tTPMI_RAPL_DOMAIN_SYSTEM,\n\tTPMI_RAPL_DOMAIN_PACKAGE,\n\tTPMI_RAPL_DOMAIN_RESERVED,\n\tTPMI_RAPL_DOMAIN_MEMORY,\n\tTPMI_RAPL_DOMAIN_MAX,\n};\n\nenum tpmi_rapl_register {\n\tTPMI_RAPL_REG_HEADER,\n\tTPMI_RAPL_REG_UNIT,\n\tTPMI_RAPL_REG_PL1,\n\tTPMI_RAPL_REG_PL2,\n\tTPMI_RAPL_REG_PL3,\n\tTPMI_RAPL_REG_PL4,\n\tTPMI_RAPL_REG_RESERVED,\n\tTPMI_RAPL_REG_ENERGY_STATUS,\n\tTPMI_RAPL_REG_PERF_STATUS,\n\tTPMI_RAPL_REG_POWER_INFO,\n\tTPMI_RAPL_REG_INTERRUPT,\n\tTPMI_RAPL_REG_MAX = 15,\n};\n\nstruct tpmi_rapl_package {\n\tstruct rapl_if_priv priv;\n\tstruct intel_tpmi_plat_info *tpmi_info;\n\tstruct rapl_package *rp;\n\tvoid __iomem *base;\n\tstruct list_head node;\n};\n\nstatic LIST_HEAD(tpmi_rapl_packages);\nstatic DEFINE_MUTEX(tpmi_rapl_lock);\n\nstatic struct powercap_control_type *tpmi_control_type;\n\nstatic int tpmi_rapl_read_raw(int id, struct reg_action *ra)\n{\n\tif (!ra->reg.mmio)\n\t\treturn -EINVAL;\n\n\tra->value = readq(ra->reg.mmio);\n\n\tra->value &= ra->mask;\n\treturn 0;\n}\n\nstatic int tpmi_rapl_write_raw(int id, struct reg_action *ra)\n{\n\tu64 val;\n\n\tif (!ra->reg.mmio)\n\t\treturn -EINVAL;\n\n\tval = readq(ra->reg.mmio);\n\n\tval &= ~ra->mask;\n\tval |= ra->value;\n\n\twriteq(val, ra->reg.mmio);\n\treturn 0;\n}\n\nstatic struct tpmi_rapl_package *trp_alloc(int pkg_id)\n{\n\tstruct tpmi_rapl_package *trp;\n\tint ret;\n\n\tmutex_lock(&tpmi_rapl_lock);\n\n\tif (list_empty(&tpmi_rapl_packages)) {\n\t\ttpmi_control_type = powercap_register_control_type(NULL, \"intel-rapl\", NULL);\n\t\tif (IS_ERR(tpmi_control_type)) {\n\t\t\tret = PTR_ERR(tpmi_control_type);\n\t\t\tgoto err_unlock;\n\t\t}\n\t}\n\n\ttrp = kzalloc(sizeof(*trp), GFP_KERNEL);\n\tif (!trp) {\n\t\tret = -ENOMEM;\n\t\tgoto err_del_powercap;\n\t}\n\n\tlist_add(&trp->node, &tpmi_rapl_packages);\n\n\tmutex_unlock(&tpmi_rapl_lock);\n\treturn trp;\n\nerr_del_powercap:\n\tif (list_empty(&tpmi_rapl_packages))\n\t\tpowercap_unregister_control_type(tpmi_control_type);\nerr_unlock:\n\tmutex_unlock(&tpmi_rapl_lock);\n\treturn ERR_PTR(ret);\n}\n\nstatic void trp_release(struct tpmi_rapl_package *trp)\n{\n\tmutex_lock(&tpmi_rapl_lock);\n\tlist_del(&trp->node);\n\n\tif (list_empty(&tpmi_rapl_packages))\n\t\tpowercap_unregister_control_type(tpmi_control_type);\n\n\tkfree(trp);\n\tmutex_unlock(&tpmi_rapl_lock);\n}\n\nstatic int parse_one_domain(struct tpmi_rapl_package *trp, u32 offset)\n{\n\tu8 tpmi_domain_version;\n\tenum rapl_domain_type domain_type;\n\tenum tpmi_rapl_domain_type tpmi_domain_type;\n\tenum tpmi_rapl_register reg_index;\n\tenum rapl_domain_reg_id reg_id;\n\tint tpmi_domain_size, tpmi_domain_flags;\n\tu64 tpmi_domain_header = readq(trp->base + offset);\n\n\t \n\ttpmi_domain_version = tpmi_domain_header & 0xff;\n\ttpmi_domain_type = tpmi_domain_header >> 8 & 0xff;\n\ttpmi_domain_size = tpmi_domain_header >> 16 & 0xff;\n\ttpmi_domain_flags = tpmi_domain_header >> 32 & 0xffff;\n\n\tif (tpmi_domain_version != TPMI_RAPL_VERSION) {\n\t\tpr_warn(FW_BUG \"Unsupported version:%d\\n\", tpmi_domain_version);\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tif (tpmi_domain_size != 1) {\n\t\tpr_warn(FW_BUG \"Invalid Domain size %d\\n\", tpmi_domain_size);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (!(tpmi_domain_flags & BIT(TPMI_RAPL_REG_UNIT)) ||\n\t    !(tpmi_domain_flags & BIT(TPMI_RAPL_REG_ENERGY_STATUS))) {\n\t\tpr_warn(FW_BUG \"Invalid Domain flag 0x%x\\n\", tpmi_domain_flags);\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (tpmi_domain_type) {\n\tcase TPMI_RAPL_DOMAIN_PACKAGE:\n\t\tdomain_type = RAPL_DOMAIN_PACKAGE;\n\t\tbreak;\n\tcase TPMI_RAPL_DOMAIN_SYSTEM:\n\t\tdomain_type = RAPL_DOMAIN_PLATFORM;\n\t\tbreak;\n\tcase TPMI_RAPL_DOMAIN_MEMORY:\n\t\tdomain_type = RAPL_DOMAIN_DRAM;\n\t\tbreak;\n\tdefault:\n\t\tpr_warn(FW_BUG \"Unsupported Domain type %d\\n\", tpmi_domain_type);\n\t\treturn -EINVAL;\n\t}\n\n\tif (trp->priv.regs[domain_type][RAPL_DOMAIN_REG_UNIT].mmio) {\n\t\tpr_warn(FW_BUG \"Duplicate Domain type %d\\n\", tpmi_domain_type);\n\t\treturn -EINVAL;\n\t}\n\n\treg_index = TPMI_RAPL_REG_HEADER;\n\twhile (++reg_index != TPMI_RAPL_REG_MAX) {\n\t\tif (!(tpmi_domain_flags & BIT(reg_index)))\n\t\t\tcontinue;\n\n\t\tswitch (reg_index) {\n\t\tcase TPMI_RAPL_REG_UNIT:\n\t\t\treg_id = RAPL_DOMAIN_REG_UNIT;\n\t\t\tbreak;\n\t\tcase TPMI_RAPL_REG_PL1:\n\t\t\treg_id = RAPL_DOMAIN_REG_LIMIT;\n\t\t\ttrp->priv.limits[domain_type] |= BIT(POWER_LIMIT1);\n\t\t\tbreak;\n\t\tcase TPMI_RAPL_REG_PL2:\n\t\t\treg_id = RAPL_DOMAIN_REG_PL2;\n\t\t\ttrp->priv.limits[domain_type] |= BIT(POWER_LIMIT2);\n\t\t\tbreak;\n\t\tcase TPMI_RAPL_REG_PL4:\n\t\t\treg_id = RAPL_DOMAIN_REG_PL4;\n\t\t\ttrp->priv.limits[domain_type] |= BIT(POWER_LIMIT4);\n\t\t\tbreak;\n\t\tcase TPMI_RAPL_REG_ENERGY_STATUS:\n\t\t\treg_id = RAPL_DOMAIN_REG_STATUS;\n\t\t\tbreak;\n\t\tcase TPMI_RAPL_REG_PERF_STATUS:\n\t\t\treg_id = RAPL_DOMAIN_REG_PERF;\n\t\t\tbreak;\n\t\tcase TPMI_RAPL_REG_POWER_INFO:\n\t\t\treg_id = RAPL_DOMAIN_REG_INFO;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcontinue;\n\t\t}\n\t\ttrp->priv.regs[domain_type][reg_id].mmio = trp->base + offset + reg_index * 8;\n\t}\n\n\treturn 0;\n}\n\nstatic int intel_rapl_tpmi_probe(struct auxiliary_device *auxdev,\n\t\t\t\t const struct auxiliary_device_id *id)\n{\n\tstruct tpmi_rapl_package *trp;\n\tstruct intel_tpmi_plat_info *info;\n\tstruct resource *res;\n\tu32 offset;\n\tint ret;\n\n\tinfo = tpmi_get_platform_data(auxdev);\n\tif (!info)\n\t\treturn -ENODEV;\n\n\ttrp = trp_alloc(info->package_id);\n\tif (IS_ERR(trp))\n\t\treturn PTR_ERR(trp);\n\n\tif (tpmi_get_resource_count(auxdev) > 1) {\n\t\tdev_err(&auxdev->dev, \"does not support multiple resources\\n\");\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tres = tpmi_get_resource_at_index(auxdev, 0);\n\tif (!res) {\n\t\tdev_err(&auxdev->dev, \"can't fetch device resource info\\n\");\n\t\tret = -EIO;\n\t\tgoto err;\n\t}\n\n\ttrp->base = devm_ioremap_resource(&auxdev->dev, res);\n\tif (IS_ERR(trp->base)) {\n\t\tret = PTR_ERR(trp->base);\n\t\tgoto err;\n\t}\n\n\tfor (offset = 0; offset < resource_size(res); offset += TPMI_RAPL_DOMAIN_SIZE) {\n\t\tret = parse_one_domain(trp, offset);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\ttrp->tpmi_info = info;\n\ttrp->priv.type = RAPL_IF_TPMI;\n\ttrp->priv.read_raw = tpmi_rapl_read_raw;\n\ttrp->priv.write_raw = tpmi_rapl_write_raw;\n\ttrp->priv.control_type = tpmi_control_type;\n\n\t \n\ttrp->rp = rapl_find_package_domain(info->package_id, &trp->priv, false);\n\tif (trp->rp) {\n\t\tdev_err(&auxdev->dev, \"Domain for Package%d already exists\\n\", info->package_id);\n\t\tret = -EEXIST;\n\t\tgoto err;\n\t}\n\n\ttrp->rp = rapl_add_package(info->package_id, &trp->priv, false);\n\tif (IS_ERR(trp->rp)) {\n\t\tdev_err(&auxdev->dev, \"Failed to add RAPL Domain for Package%d, %ld\\n\",\n\t\t\tinfo->package_id, PTR_ERR(trp->rp));\n\t\tret = PTR_ERR(trp->rp);\n\t\tgoto err;\n\t}\n\n\tauxiliary_set_drvdata(auxdev, trp);\n\n\treturn 0;\nerr:\n\ttrp_release(trp);\n\treturn ret;\n}\n\nstatic void intel_rapl_tpmi_remove(struct auxiliary_device *auxdev)\n{\n\tstruct tpmi_rapl_package *trp = auxiliary_get_drvdata(auxdev);\n\n\trapl_remove_package(trp->rp);\n\ttrp_release(trp);\n}\n\nstatic const struct auxiliary_device_id intel_rapl_tpmi_ids[] = {\n\t{.name = \"intel_vsec.tpmi-rapl\" },\n\t{ }\n};\n\nMODULE_DEVICE_TABLE(auxiliary, intel_rapl_tpmi_ids);\n\nstatic struct auxiliary_driver intel_rapl_tpmi_driver = {\n\t.probe = intel_rapl_tpmi_probe,\n\t.remove = intel_rapl_tpmi_remove,\n\t.id_table = intel_rapl_tpmi_ids,\n};\n\nmodule_auxiliary_driver(intel_rapl_tpmi_driver)\n\nMODULE_IMPORT_NS(INTEL_TPMI);\n\nMODULE_DESCRIPTION(\"Intel RAPL TPMI Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}