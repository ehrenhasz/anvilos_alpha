{
  "module_name": "dtpm.c",
  "hash_id": "df4d71f76cc695ab480f132cf483ee0ce52c653d72358175c78242a3ec2851c2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/powercap/dtpm.c",
  "human_readable_source": "\n \n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/dtpm.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/powercap.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/of.h>\n\n#include \"dtpm_subsys.h\"\n\n#define DTPM_POWER_LIMIT_FLAG 0\n\nstatic const char *constraint_name[] = {\n\t\"Instantaneous\",\n};\n\nstatic DEFINE_MUTEX(dtpm_lock);\nstatic struct powercap_control_type *pct;\nstatic struct dtpm *root;\n\nstatic int get_time_window_us(struct powercap_zone *pcz, int cid, u64 *window)\n{\n\treturn -ENOSYS;\n}\n\nstatic int set_time_window_us(struct powercap_zone *pcz, int cid, u64 window)\n{\n\treturn -ENOSYS;\n}\n\nstatic int get_max_power_range_uw(struct powercap_zone *pcz, u64 *max_power_uw)\n{\n\tstruct dtpm *dtpm = to_dtpm(pcz);\n\n\t*max_power_uw = dtpm->power_max - dtpm->power_min;\n\n\treturn 0;\n}\n\nstatic int __get_power_uw(struct dtpm *dtpm, u64 *power_uw)\n{\n\tstruct dtpm *child;\n\tu64 power;\n\tint ret = 0;\n\n\tif (dtpm->ops) {\n\t\t*power_uw = dtpm->ops->get_power_uw(dtpm);\n\t\treturn 0;\n\t}\n\n\t*power_uw = 0;\n\n\tlist_for_each_entry(child, &dtpm->children, sibling) {\n\t\tret = __get_power_uw(child, &power);\n\t\tif (ret)\n\t\t\tbreak;\n\t\t*power_uw += power;\n\t}\n\n\treturn ret;\n}\n\nstatic int get_power_uw(struct powercap_zone *pcz, u64 *power_uw)\n{\n\treturn __get_power_uw(to_dtpm(pcz), power_uw);\n}\n\nstatic void __dtpm_rebalance_weight(struct dtpm *dtpm)\n{\n\tstruct dtpm *child;\n\n\tlist_for_each_entry(child, &dtpm->children, sibling) {\n\n\t\tpr_debug(\"Setting weight '%d' for '%s'\\n\",\n\t\t\t child->weight, child->zone.name);\n\n\t\tchild->weight = DIV64_U64_ROUND_CLOSEST(\n\t\t\tchild->power_max * 1024, dtpm->power_max);\n\n\t\t__dtpm_rebalance_weight(child);\n\t}\n}\n\nstatic void __dtpm_sub_power(struct dtpm *dtpm)\n{\n\tstruct dtpm *parent = dtpm->parent;\n\n\twhile (parent) {\n\t\tparent->power_min -= dtpm->power_min;\n\t\tparent->power_max -= dtpm->power_max;\n\t\tparent->power_limit -= dtpm->power_limit;\n\t\tparent = parent->parent;\n\t}\n}\n\nstatic void __dtpm_add_power(struct dtpm *dtpm)\n{\n\tstruct dtpm *parent = dtpm->parent;\n\n\twhile (parent) {\n\t\tparent->power_min += dtpm->power_min;\n\t\tparent->power_max += dtpm->power_max;\n\t\tparent->power_limit += dtpm->power_limit;\n\t\tparent = parent->parent;\n\t}\n}\n\n \nint dtpm_update_power(struct dtpm *dtpm)\n{\n\tint ret;\n\n\t__dtpm_sub_power(dtpm);\n\n\tret = dtpm->ops->update_power_uw(dtpm);\n\tif (ret)\n\t\tpr_err(\"Failed to update power for '%s': %d\\n\",\n\t\t       dtpm->zone.name, ret);\n\n\tif (!test_bit(DTPM_POWER_LIMIT_FLAG, &dtpm->flags))\n\t\tdtpm->power_limit = dtpm->power_max;\n\n\t__dtpm_add_power(dtpm);\n\n\tif (root)\n\t\t__dtpm_rebalance_weight(root);\n\n\treturn ret;\n}\n\n \nint dtpm_release_zone(struct powercap_zone *pcz)\n{\n\tstruct dtpm *dtpm = to_dtpm(pcz);\n\tstruct dtpm *parent = dtpm->parent;\n\n\tif (!list_empty(&dtpm->children))\n\t\treturn -EBUSY;\n\n\tif (parent)\n\t\tlist_del(&dtpm->sibling);\n\n\t__dtpm_sub_power(dtpm);\n\n\tif (dtpm->ops)\n\t\tdtpm->ops->release(dtpm);\n\telse\n\t\tkfree(dtpm);\n\n\treturn 0;\n}\n\nstatic int get_power_limit_uw(struct powercap_zone *pcz,\n\t\t\t      int cid, u64 *power_limit)\n{\n\t*power_limit = to_dtpm(pcz)->power_limit;\n\t\n\treturn 0;\n}\n\n \nstatic int __set_power_limit_uw(struct dtpm *dtpm, int cid, u64 power_limit)\n{\n\tstruct dtpm *child;\n\tint ret = 0;\n\tu64 power;\n\n\t \n\tif (power_limit == dtpm->power_max) {\n\t\tclear_bit(DTPM_POWER_LIMIT_FLAG, &dtpm->flags);\n\t} else {\n\t\tset_bit(DTPM_POWER_LIMIT_FLAG, &dtpm->flags);\n\t}\n\n\tpr_debug(\"Setting power limit for '%s': %llu uW\\n\",\n\t\t dtpm->zone.name, power_limit);\n\n\t \n\tif (dtpm->ops) {\n\t\tdtpm->power_limit = dtpm->ops->set_power_uw(dtpm, power_limit);\n\t} else {\n\t\tdtpm->power_limit = 0;\n\n\t\tlist_for_each_entry(child, &dtpm->children, sibling) {\n\n\t\t\t \n\t\t\tif (power_limit == dtpm->power_max) {\n\t\t\t\tpower = child->power_max;\n\t\t\t} else if (power_limit == dtpm->power_min) {\n\t\t\t\tpower = child->power_min;\n\t\t\t} else {\n\t\t\t\tpower = DIV_ROUND_CLOSEST_ULL(\n\t\t\t\t\tpower_limit * child->weight, 1024);\n\t\t\t}\n\n\t\t\tpr_debug(\"Setting power limit for '%s': %llu uW\\n\",\n\t\t\t\t child->zone.name, power);\n\n\t\t\tret = __set_power_limit_uw(child, cid, power);\n\t\t\tif (!ret)\n\t\t\t\tret = get_power_limit_uw(&child->zone, cid, &power);\n\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\n\t\t\tdtpm->power_limit += power;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic int set_power_limit_uw(struct powercap_zone *pcz,\n\t\t\t      int cid, u64 power_limit)\n{\n\tstruct dtpm *dtpm = to_dtpm(pcz);\n\tint ret;\n\n\t \n\tpower_limit = clamp_val(power_limit, dtpm->power_min, dtpm->power_max);\n\n\tret = __set_power_limit_uw(dtpm, cid, power_limit);\n\n\tpr_debug(\"%s: power limit: %llu uW, power max: %llu uW\\n\",\n\t\t dtpm->zone.name, dtpm->power_limit, dtpm->power_max);\n\n\treturn ret;\n}\n\nstatic const char *get_constraint_name(struct powercap_zone *pcz, int cid)\n{\n\treturn constraint_name[cid];\n}\n\nstatic int get_max_power_uw(struct powercap_zone *pcz, int id, u64 *max_power)\n{\n\t*max_power = to_dtpm(pcz)->power_max;\n\n\treturn 0;\n}\n\nstatic struct powercap_zone_constraint_ops constraint_ops = {\n\t.set_power_limit_uw = set_power_limit_uw,\n\t.get_power_limit_uw = get_power_limit_uw,\n\t.set_time_window_us = set_time_window_us,\n\t.get_time_window_us = get_time_window_us,\n\t.get_max_power_uw = get_max_power_uw,\n\t.get_name = get_constraint_name,\n};\n\nstatic struct powercap_zone_ops zone_ops = {\n\t.get_max_power_range_uw = get_max_power_range_uw,\n\t.get_power_uw = get_power_uw,\n\t.release = dtpm_release_zone,\n};\n\n \nvoid dtpm_init(struct dtpm *dtpm, struct dtpm_ops *ops)\n{\n\tif (dtpm) {\n\t\tINIT_LIST_HEAD(&dtpm->children);\n\t\tINIT_LIST_HEAD(&dtpm->sibling);\n\t\tdtpm->weight = 1024;\n\t\tdtpm->ops = ops;\n\t}\n}\n\n \nvoid dtpm_unregister(struct dtpm *dtpm)\n{\n\tpowercap_unregister_zone(pct, &dtpm->zone);\n\n\tpr_debug(\"Unregistered dtpm node '%s'\\n\", dtpm->zone.name);\n}\n\n \nint dtpm_register(const char *name, struct dtpm *dtpm, struct dtpm *parent)\n{\n\tstruct powercap_zone *pcz;\n\n\tif (!pct)\n\t\treturn -EAGAIN;\n\n\tif (root && !parent)\n\t\treturn -EBUSY;\n\n\tif (!root && parent)\n\t\treturn -EINVAL;\n\n\tif (parent && parent->ops)\n\t\treturn -EINVAL;\n\n\tif (!dtpm)\n\t\treturn -EINVAL;\n\n\tif (dtpm->ops && !(dtpm->ops->set_power_uw &&\n\t\t\t   dtpm->ops->get_power_uw &&\n\t\t\t   dtpm->ops->update_power_uw &&\n\t\t\t   dtpm->ops->release))\n\t\treturn -EINVAL;\n\n\tpcz = powercap_register_zone(&dtpm->zone, pct, name,\n\t\t\t\t     parent ? &parent->zone : NULL,\n\t\t\t\t     &zone_ops, MAX_DTPM_CONSTRAINTS,\n\t\t\t\t     &constraint_ops);\n\tif (IS_ERR(pcz))\n\t\treturn PTR_ERR(pcz);\n\n\tif (parent) {\n\t\tlist_add_tail(&dtpm->sibling, &parent->children);\n\t\tdtpm->parent = parent;\n\t} else {\n\t\troot = dtpm;\n\t}\n\n\tif (dtpm->ops && !dtpm->ops->update_power_uw(dtpm)) {\n\t\t__dtpm_add_power(dtpm);\n\t\tdtpm->power_limit = dtpm->power_max;\n\t}\n\n\tpr_debug(\"Registered dtpm node '%s' / %llu-%llu uW, \\n\",\n\t\t dtpm->zone.name, dtpm->power_min, dtpm->power_max);\n\n\treturn 0;\n}\n\nstatic struct dtpm *dtpm_setup_virtual(const struct dtpm_node *hierarchy,\n\t\t\t\t       struct dtpm *parent)\n{\n\tstruct dtpm *dtpm;\n\tint ret;\n\n\tdtpm = kzalloc(sizeof(*dtpm), GFP_KERNEL);\n\tif (!dtpm)\n\t\treturn ERR_PTR(-ENOMEM);\n\tdtpm_init(dtpm, NULL);\n\n\tret = dtpm_register(hierarchy->name, dtpm, parent);\n\tif (ret) {\n\t\tpr_err(\"Failed to register dtpm node '%s': %d\\n\",\n\t\t       hierarchy->name, ret);\n\t\tkfree(dtpm);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\treturn dtpm;\n}\n\nstatic struct dtpm *dtpm_setup_dt(const struct dtpm_node *hierarchy,\n\t\t\t\t  struct dtpm *parent)\n{\n\tstruct device_node *np;\n\tint i, ret;\n\n\tnp = of_find_node_by_path(hierarchy->name);\n\tif (!np) {\n\t\tpr_err(\"Failed to find '%s'\\n\", hierarchy->name);\n\t\treturn ERR_PTR(-ENXIO);\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(dtpm_subsys); i++) {\n\n\t\tif (!dtpm_subsys[i]->setup)\n\t\t\tcontinue;\n\n\t\tret = dtpm_subsys[i]->setup(parent, np);\n\t\tif (ret) {\n\t\t\tpr_err(\"Failed to setup '%s': %d\\n\", dtpm_subsys[i]->name, ret);\n\t\t\tof_node_put(np);\n\t\t\treturn ERR_PTR(ret);\n\t\t}\n\t}\n\n\tof_node_put(np);\n\n\t \n\treturn NULL;\n}\n\ntypedef struct dtpm * (*dtpm_node_callback_t)(const struct dtpm_node *, struct dtpm *);\n\nstatic dtpm_node_callback_t dtpm_node_callback[] = {\n\t[DTPM_NODE_VIRTUAL] = dtpm_setup_virtual,\n\t[DTPM_NODE_DT] = dtpm_setup_dt,\n};\n\nstatic int dtpm_for_each_child(const struct dtpm_node *hierarchy,\n\t\t\t       const struct dtpm_node *it, struct dtpm *parent)\n{\n\tstruct dtpm *dtpm;\n\tint i, ret;\n\n\tfor (i = 0; hierarchy[i].name; i++) {\n\n\t\tif (hierarchy[i].parent != it)\n\t\t\tcontinue;\n\n\t\tdtpm = dtpm_node_callback[hierarchy[i].type](&hierarchy[i], parent);\n\n\t\t \n\t\tif (!dtpm)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (IS_ERR(dtpm)) {\n\t\t\tpr_warn(\"Failed to create '%s' in the hierarchy\\n\",\n\t\t\t\thierarchy[i].name);\n\t\t\tcontinue;\n\t\t}\n\n\t\tret = dtpm_for_each_child(hierarchy, &hierarchy[i], dtpm);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n \nint dtpm_create_hierarchy(struct of_device_id *dtpm_match_table)\n{\n\tconst struct of_device_id *match;\n\tconst struct dtpm_node *hierarchy;\n\tstruct device_node *np;\n\tint i, ret;\n\n\tmutex_lock(&dtpm_lock);\n\n\tif (pct) {\n\t\tret = -EBUSY;\n\t\tgoto out_unlock;\n\t}\n\n\tpct = powercap_register_control_type(NULL, \"dtpm\", NULL);\n\tif (IS_ERR(pct)) {\n\t\tpr_err(\"Failed to register control type\\n\");\n\t\tret = PTR_ERR(pct);\n\t\tgoto out_pct;\n\t}\n\n\tret = -ENODEV;\n\tnp = of_find_node_by_path(\"/\");\n\tif (!np)\n\t\tgoto out_err;\n\n\tmatch = of_match_node(dtpm_match_table, np);\n\n\tof_node_put(np);\n\n\tif (!match)\n\t\tgoto out_err;\n\n\thierarchy = match->data;\n\tif (!hierarchy) {\n\t\tret = -EFAULT;\n\t\tgoto out_err;\n\t}\n\n\tret = dtpm_for_each_child(hierarchy, NULL, NULL);\n\tif (ret)\n\t\tgoto out_err;\n\t\n\tfor (i = 0; i < ARRAY_SIZE(dtpm_subsys); i++) {\n\n\t\tif (!dtpm_subsys[i]->init)\n\t\t\tcontinue;\n\n\t\tret = dtpm_subsys[i]->init();\n\t\tif (ret)\n\t\t\tpr_info(\"Failed to initialize '%s': %d\",\n\t\t\t\tdtpm_subsys[i]->name, ret);\n\t}\n\n\tmutex_unlock(&dtpm_lock);\n\n\treturn 0;\n\nout_err:\n\tpowercap_unregister_control_type(pct);\nout_pct:\n\tpct = NULL;\nout_unlock:\n\tmutex_unlock(&dtpm_lock);\n\t\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(dtpm_create_hierarchy);\n\nstatic void __dtpm_destroy_hierarchy(struct dtpm *dtpm)\n{\n\tstruct dtpm *child, *aux;\n\n\tlist_for_each_entry_safe(child, aux, &dtpm->children, sibling)\n\t\t__dtpm_destroy_hierarchy(child);\n\n\t \n\tdtpm_unregister(dtpm);\n}\n\nvoid dtpm_destroy_hierarchy(void)\n{\n\tint i;\n\n\tmutex_lock(&dtpm_lock);\n\n\tif (!pct)\n\t\tgoto out_unlock;\n\n\t__dtpm_destroy_hierarchy(root);\n\t\n\n\tfor (i = 0; i < ARRAY_SIZE(dtpm_subsys); i++) {\n\n\t\tif (!dtpm_subsys[i]->exit)\n\t\t\tcontinue;\n\n\t\tdtpm_subsys[i]->exit();\n\t}\n\n\tpowercap_unregister_control_type(pct);\n\n\tpct = NULL;\n\n\troot = NULL;\n\nout_unlock:\n\tmutex_unlock(&dtpm_lock);\n}\nEXPORT_SYMBOL_GPL(dtpm_destroy_hierarchy);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}