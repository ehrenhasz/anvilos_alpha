{
  "module_name": "powercap_sys.c",
  "hash_id": "e84a4c400129c8040eb27bb08dc61043effed2222c463c8af3f0210d321d4fea",
  "original_prompt": "Ingested from linux-6.6.14/drivers/powercap/powercap_sys.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/kstrtox.h>\n#include <linux/slab.h>\n#include <linux/powercap.h>\n\n#define to_powercap_zone(n) container_of(n, struct powercap_zone, dev)\n#define to_powercap_control_type(n) \\\n\t\t\tcontainer_of(n, struct powercap_control_type, dev)\n\n \n#define define_power_zone_show(_attr)\t\t\\\nstatic ssize_t _attr##_show(struct device *dev, \\\n\t\t\t\t\tstruct device_attribute *dev_attr,\\\n\t\t\t\t\tchar *buf) \\\n{ \\\n\tu64 value; \\\n\tssize_t len = -EINVAL; \\\n\tstruct powercap_zone *power_zone = to_powercap_zone(dev); \\\n\t\\\n\tif (power_zone->ops->get_##_attr) { \\\n\t\tif (!power_zone->ops->get_##_attr(power_zone, &value)) \\\n\t\t\tlen = sprintf(buf, \"%lld\\n\", value); \\\n\t} \\\n\t\\\n\treturn len; \\\n}\n\n \n#define define_power_zone_store(_attr)\t\t\\\nstatic ssize_t _attr##_store(struct device *dev,\\\n\t\t\t\tstruct device_attribute *dev_attr, \\\n\t\t\t\tconst char *buf, size_t count) \\\n{ \\\n\tint err; \\\n\tstruct powercap_zone *power_zone = to_powercap_zone(dev); \\\n\tu64 value; \\\n\t\\\n\terr = kstrtoull(buf, 10, &value); \\\n\tif (err) \\\n\t\treturn -EINVAL; \\\n\tif (value) \\\n\t\treturn count; \\\n\tif (power_zone->ops->reset_##_attr) { \\\n\t\tif (!power_zone->ops->reset_##_attr(power_zone)) \\\n\t\t\treturn count; \\\n\t} \\\n\t\\\n\treturn -EINVAL; \\\n}\n\n \n#define define_power_zone_constraint_show(_attr) \\\nstatic ssize_t show_constraint_##_attr(struct device *dev, \\\n\t\t\t\tstruct device_attribute *dev_attr,\\\n\t\t\t\tchar *buf) \\\n{ \\\n\tu64 value; \\\n\tssize_t len = -ENODATA; \\\n\tstruct powercap_zone *power_zone = to_powercap_zone(dev); \\\n\tint id; \\\n\tstruct powercap_zone_constraint *pconst;\\\n\t\\\n\tif (!sscanf(dev_attr->attr.name, \"constraint_%d_\", &id)) \\\n\t\treturn -EINVAL; \\\n\tif (id >= power_zone->const_id_cnt)\t\\\n\t\treturn -EINVAL; \\\n\tpconst = &power_zone->constraints[id]; \\\n\tif (pconst && pconst->ops && pconst->ops->get_##_attr) { \\\n\t\tif (!pconst->ops->get_##_attr(power_zone, id, &value)) \\\n\t\t\tlen = sprintf(buf, \"%lld\\n\", value); \\\n\t} \\\n\t\\\n\treturn len; \\\n}\n\n \n#define define_power_zone_constraint_store(_attr) \\\nstatic ssize_t store_constraint_##_attr(struct device *dev,\\\n\t\t\t\tstruct device_attribute *dev_attr, \\\n\t\t\t\tconst char *buf, size_t count) \\\n{ \\\n\tint err; \\\n\tu64 value; \\\n\tstruct powercap_zone *power_zone = to_powercap_zone(dev); \\\n\tint id; \\\n\tstruct powercap_zone_constraint *pconst;\\\n\t\\\n\tif (!sscanf(dev_attr->attr.name, \"constraint_%d_\", &id)) \\\n\t\treturn -EINVAL; \\\n\tif (id >= power_zone->const_id_cnt)\t\\\n\t\treturn -EINVAL; \\\n\tpconst = &power_zone->constraints[id]; \\\n\terr = kstrtoull(buf, 10, &value); \\\n\tif (err) \\\n\t\treturn -EINVAL; \\\n\tif (pconst && pconst->ops && pconst->ops->set_##_attr) { \\\n\t\tif (!pconst->ops->set_##_attr(power_zone, id, value)) \\\n\t\t\treturn count; \\\n\t} \\\n\t\\\n\treturn -ENODATA; \\\n}\n\n \ndefine_power_zone_show(power_uw);\ndefine_power_zone_show(max_power_range_uw);\ndefine_power_zone_show(energy_uj);\ndefine_power_zone_store(energy_uj);\ndefine_power_zone_show(max_energy_range_uj);\n\n \nstatic DEVICE_ATTR_RO(max_power_range_uw);\nstatic DEVICE_ATTR_RO(power_uw);\nstatic DEVICE_ATTR_RO(max_energy_range_uj);\nstatic DEVICE_ATTR_RW(energy_uj);\n\n \ndefine_power_zone_constraint_show(power_limit_uw);\ndefine_power_zone_constraint_store(power_limit_uw);\ndefine_power_zone_constraint_show(time_window_us);\ndefine_power_zone_constraint_store(time_window_us);\ndefine_power_zone_constraint_show(max_power_uw);\ndefine_power_zone_constraint_show(min_power_uw);\ndefine_power_zone_constraint_show(max_time_window_us);\ndefine_power_zone_constraint_show(min_time_window_us);\n\n \nstruct powercap_constraint_attr {\n\tstruct device_attribute power_limit_attr;\n\tstruct device_attribute time_window_attr;\n\tstruct device_attribute max_power_attr;\n\tstruct device_attribute min_power_attr;\n\tstruct device_attribute max_time_window_attr;\n\tstruct device_attribute min_time_window_attr;\n\tstruct device_attribute name_attr;\n};\n\nstatic struct powercap_constraint_attr\n\t\t\t\tconstraint_attrs[MAX_CONSTRAINTS_PER_ZONE];\n\n \nstatic LIST_HEAD(powercap_cntrl_list);\n \nstatic DEFINE_MUTEX(powercap_cntrl_list_lock);\n\n#define POWERCAP_CONSTRAINT_NAME_LEN\t30  \nstatic ssize_t show_constraint_name(struct device *dev,\n\t\t\t\tstruct device_attribute *dev_attr,\n\t\t\t\tchar *buf)\n{\n\tconst char *name;\n\tstruct powercap_zone *power_zone = to_powercap_zone(dev);\n\tint id;\n\tssize_t len = -ENODATA;\n\tstruct powercap_zone_constraint *pconst;\n\n\tif (!sscanf(dev_attr->attr.name, \"constraint_%d_\", &id))\n\t\treturn -EINVAL;\n\tif (id >= power_zone->const_id_cnt)\n\t\treturn -EINVAL;\n\tpconst = &power_zone->constraints[id];\n\n\tif (pconst && pconst->ops && pconst->ops->get_name) {\n\t\tname = pconst->ops->get_name(power_zone, id);\n\t\tif (name) {\n\t\t\tsprintf(buf, \"%.*s\\n\", POWERCAP_CONSTRAINT_NAME_LEN - 1,\n\t\t\t\tname);\n\t\t\tlen = strlen(buf);\n\t\t}\n\t}\n\n\treturn len;\n}\n\nstatic int create_constraint_attribute(int id, const char *name,\n\t\t\t\tint mode,\n\t\t\t\tstruct device_attribute *dev_attr,\n\t\t\t\tssize_t (*show)(struct device *,\n\t\t\t\t\tstruct device_attribute *, char *),\n\t\t\t\tssize_t (*store)(struct device *,\n\t\t\t\t\tstruct device_attribute *,\n\t\t\t\tconst char *, size_t)\n\t\t\t\t)\n{\n\n\tdev_attr->attr.name = kasprintf(GFP_KERNEL, \"constraint_%d_%s\",\n\t\t\t\t\t\t\t\tid, name);\n\tif (!dev_attr->attr.name)\n\t\treturn -ENOMEM;\n\tdev_attr->attr.mode = mode;\n\tdev_attr->show = show;\n\tdev_attr->store = store;\n\n\treturn 0;\n}\n\nstatic void free_constraint_attributes(void)\n{\n\tint i;\n\n\tfor (i = 0; i < MAX_CONSTRAINTS_PER_ZONE; ++i) {\n\t\tkfree(constraint_attrs[i].power_limit_attr.attr.name);\n\t\tkfree(constraint_attrs[i].time_window_attr.attr.name);\n\t\tkfree(constraint_attrs[i].name_attr.attr.name);\n\t\tkfree(constraint_attrs[i].max_power_attr.attr.name);\n\t\tkfree(constraint_attrs[i].min_power_attr.attr.name);\n\t\tkfree(constraint_attrs[i].max_time_window_attr.attr.name);\n\t\tkfree(constraint_attrs[i].min_time_window_attr.attr.name);\n\t}\n}\n\nstatic int seed_constraint_attributes(void)\n{\n\tint i;\n\tint ret;\n\n\tfor (i = 0; i < MAX_CONSTRAINTS_PER_ZONE; ++i) {\n\t\tret = create_constraint_attribute(i, \"power_limit_uw\",\n\t\t\t\t\tS_IWUSR | S_IRUGO,\n\t\t\t\t\t&constraint_attrs[i].power_limit_attr,\n\t\t\t\t\tshow_constraint_power_limit_uw,\n\t\t\t\t\tstore_constraint_power_limit_uw);\n\t\tif (ret)\n\t\t\tgoto err_alloc;\n\t\tret = create_constraint_attribute(i, \"time_window_us\",\n\t\t\t\t\tS_IWUSR | S_IRUGO,\n\t\t\t\t\t&constraint_attrs[i].time_window_attr,\n\t\t\t\t\tshow_constraint_time_window_us,\n\t\t\t\t\tstore_constraint_time_window_us);\n\t\tif (ret)\n\t\t\tgoto err_alloc;\n\t\tret = create_constraint_attribute(i, \"name\", S_IRUGO,\n\t\t\t\t&constraint_attrs[i].name_attr,\n\t\t\t\tshow_constraint_name,\n\t\t\t\tNULL);\n\t\tif (ret)\n\t\t\tgoto err_alloc;\n\t\tret = create_constraint_attribute(i, \"max_power_uw\", S_IRUGO,\n\t\t\t\t&constraint_attrs[i].max_power_attr,\n\t\t\t\tshow_constraint_max_power_uw,\n\t\t\t\tNULL);\n\t\tif (ret)\n\t\t\tgoto err_alloc;\n\t\tret = create_constraint_attribute(i, \"min_power_uw\", S_IRUGO,\n\t\t\t\t&constraint_attrs[i].min_power_attr,\n\t\t\t\tshow_constraint_min_power_uw,\n\t\t\t\tNULL);\n\t\tif (ret)\n\t\t\tgoto err_alloc;\n\t\tret = create_constraint_attribute(i, \"max_time_window_us\",\n\t\t\t\tS_IRUGO,\n\t\t\t\t&constraint_attrs[i].max_time_window_attr,\n\t\t\t\tshow_constraint_max_time_window_us,\n\t\t\t\tNULL);\n\t\tif (ret)\n\t\t\tgoto err_alloc;\n\t\tret = create_constraint_attribute(i, \"min_time_window_us\",\n\t\t\t\tS_IRUGO,\n\t\t\t\t&constraint_attrs[i].min_time_window_attr,\n\t\t\t\tshow_constraint_min_time_window_us,\n\t\t\t\tNULL);\n\t\tif (ret)\n\t\t\tgoto err_alloc;\n\n\t}\n\n\treturn 0;\n\nerr_alloc:\n\tfree_constraint_attributes();\n\n\treturn ret;\n}\n\nstatic int create_constraints(struct powercap_zone *power_zone,\n\t\t\tint nr_constraints,\n\t\t\tconst struct powercap_zone_constraint_ops *const_ops)\n{\n\tint i;\n\tint ret = 0;\n\tint count;\n\tstruct powercap_zone_constraint *pconst;\n\n\tif (!power_zone || !const_ops || !const_ops->get_power_limit_uw ||\n\t\t\t\t\t!const_ops->set_power_limit_uw ||\n\t\t\t\t\t!const_ops->get_time_window_us ||\n\t\t\t\t\t!const_ops->set_time_window_us)\n\t\treturn -EINVAL;\n\n\tcount = power_zone->zone_attr_count;\n\tfor (i = 0; i < nr_constraints; ++i) {\n\t\tpconst = &power_zone->constraints[i];\n\t\tpconst->ops = const_ops;\n\t\tpconst->id = power_zone->const_id_cnt;\n\t\tpower_zone->const_id_cnt++;\n\t\tpower_zone->zone_dev_attrs[count++] =\n\t\t\t\t&constraint_attrs[i].power_limit_attr.attr;\n\t\tpower_zone->zone_dev_attrs[count++] =\n\t\t\t\t&constraint_attrs[i].time_window_attr.attr;\n\t\tif (pconst->ops->get_name)\n\t\t\tpower_zone->zone_dev_attrs[count++] =\n\t\t\t\t&constraint_attrs[i].name_attr.attr;\n\t\tif (pconst->ops->get_max_power_uw)\n\t\t\tpower_zone->zone_dev_attrs[count++] =\n\t\t\t\t&constraint_attrs[i].max_power_attr.attr;\n\t\tif (pconst->ops->get_min_power_uw)\n\t\t\tpower_zone->zone_dev_attrs[count++] =\n\t\t\t\t&constraint_attrs[i].min_power_attr.attr;\n\t\tif (pconst->ops->get_max_time_window_us)\n\t\t\tpower_zone->zone_dev_attrs[count++] =\n\t\t\t\t&constraint_attrs[i].max_time_window_attr.attr;\n\t\tif (pconst->ops->get_min_time_window_us)\n\t\t\tpower_zone->zone_dev_attrs[count++] =\n\t\t\t\t&constraint_attrs[i].min_time_window_attr.attr;\n\t}\n\tpower_zone->zone_attr_count = count;\n\n\treturn ret;\n}\n\nstatic bool control_type_valid(void *control_type)\n{\n\tstruct powercap_control_type *pos = NULL;\n\tbool found = false;\n\n\tmutex_lock(&powercap_cntrl_list_lock);\n\n\tlist_for_each_entry(pos, &powercap_cntrl_list, node) {\n\t\tif (pos == control_type) {\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&powercap_cntrl_list_lock);\n\n\treturn found;\n}\n\nstatic ssize_t name_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr,\n\t\t\t\tchar *buf)\n{\n\tstruct powercap_zone *power_zone = to_powercap_zone(dev);\n\n\treturn sprintf(buf, \"%s\\n\", power_zone->name);\n}\n\nstatic DEVICE_ATTR_RO(name);\n\n \nstatic void create_power_zone_common_attributes(\n\t\t\t\t\tstruct powercap_zone *power_zone)\n{\n\tint count = 0;\n\n\tpower_zone->zone_dev_attrs[count++] = &dev_attr_name.attr;\n\tif (power_zone->ops->get_max_energy_range_uj)\n\t\tpower_zone->zone_dev_attrs[count++] =\n\t\t\t\t\t&dev_attr_max_energy_range_uj.attr;\n\tif (power_zone->ops->get_energy_uj) {\n\t\tif (power_zone->ops->reset_energy_uj)\n\t\t\tdev_attr_energy_uj.attr.mode = S_IWUSR | S_IRUSR;\n\t\telse\n\t\t\tdev_attr_energy_uj.attr.mode = S_IRUSR;\n\t\tpower_zone->zone_dev_attrs[count++] =\n\t\t\t\t\t&dev_attr_energy_uj.attr;\n\t}\n\tif (power_zone->ops->get_power_uw)\n\t\tpower_zone->zone_dev_attrs[count++] =\n\t\t\t\t\t&dev_attr_power_uw.attr;\n\tif (power_zone->ops->get_max_power_range_uw)\n\t\tpower_zone->zone_dev_attrs[count++] =\n\t\t\t\t\t&dev_attr_max_power_range_uw.attr;\n\tpower_zone->zone_dev_attrs[count] = NULL;\n\tpower_zone->zone_attr_count = count;\n}\n\nstatic void powercap_release(struct device *dev)\n{\n\tbool allocated;\n\n\tif (dev->parent) {\n\t\tstruct powercap_zone *power_zone = to_powercap_zone(dev);\n\n\t\t \n\t\tallocated = power_zone->allocated;\n\t\t \n\t\tidr_remove(power_zone->parent_idr, power_zone->id);\n\t\t \n\t\tidr_destroy(&power_zone->idr);\n\t\tkfree(power_zone->name);\n\t\tkfree(power_zone->zone_dev_attrs);\n\t\tkfree(power_zone->constraints);\n\t\tif (power_zone->ops->release)\n\t\t\tpower_zone->ops->release(power_zone);\n\t\tif (allocated)\n\t\t\tkfree(power_zone);\n\t} else {\n\t\tstruct powercap_control_type *control_type =\n\t\t\t\t\t\tto_powercap_control_type(dev);\n\n\t\t \n\t\tallocated = control_type->allocated;\n\t\tidr_destroy(&control_type->idr);\n\t\tmutex_destroy(&control_type->lock);\n\t\tif (control_type->ops && control_type->ops->release)\n\t\t\tcontrol_type->ops->release(control_type);\n\t\tif (allocated)\n\t\t\tkfree(control_type);\n\t}\n}\n\nstatic ssize_t enabled_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr,\n\t\t\t\tchar *buf)\n{\n\tbool mode = true;\n\n\t \n\tif (dev->parent) {\n\t\tstruct powercap_zone *power_zone = to_powercap_zone(dev);\n\t\tif (power_zone->ops->get_enable)\n\t\t\tif (power_zone->ops->get_enable(power_zone, &mode))\n\t\t\t\tmode = false;\n\t} else {\n\t\tstruct powercap_control_type *control_type =\n\t\t\t\t\t\tto_powercap_control_type(dev);\n\t\tif (control_type->ops && control_type->ops->get_enable)\n\t\t\tif (control_type->ops->get_enable(control_type, &mode))\n\t\t\t\tmode = false;\n\t}\n\n\treturn sprintf(buf, \"%d\\n\", mode);\n}\n\nstatic ssize_t enabled_store(struct device *dev,\n\t\t\t\tstruct device_attribute *attr,\n\t\t\t\tconst char *buf,  size_t len)\n{\n\tbool mode;\n\n\tif (kstrtobool(buf, &mode))\n\t\treturn -EINVAL;\n\tif (dev->parent) {\n\t\tstruct powercap_zone *power_zone = to_powercap_zone(dev);\n\t\tif (power_zone->ops->set_enable)\n\t\t\tif (!power_zone->ops->set_enable(power_zone, mode))\n\t\t\t\treturn len;\n\t} else {\n\t\tstruct powercap_control_type *control_type =\n\t\t\t\t\t\tto_powercap_control_type(dev);\n\t\tif (control_type->ops && control_type->ops->set_enable)\n\t\t\tif (!control_type->ops->set_enable(control_type, mode))\n\t\t\t\treturn len;\n\t}\n\n\treturn -ENOSYS;\n}\n\nstatic DEVICE_ATTR_RW(enabled);\n\nstatic struct attribute *powercap_attrs[] = {\n\t&dev_attr_enabled.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(powercap);\n\nstatic struct class powercap_class = {\n\t.name = \"powercap\",\n\t.dev_release = powercap_release,\n\t.dev_groups = powercap_groups,\n};\n\nstruct powercap_zone *powercap_register_zone(\n\t\t\tstruct powercap_zone *power_zone,\n\t\t\tstruct powercap_control_type *control_type,\n\t\t\tconst char *name,\n\t\t\tstruct powercap_zone *parent,\n\t\t\tconst struct powercap_zone_ops *ops,\n\t\t\tint nr_constraints,\n\t\t\tconst struct powercap_zone_constraint_ops *const_ops)\n{\n\tint result;\n\tint nr_attrs;\n\n\tif (!name || !control_type || !ops ||\n\t\t\tnr_constraints > MAX_CONSTRAINTS_PER_ZONE ||\n\t\t\t(!ops->get_energy_uj && !ops->get_power_uw) ||\n\t\t\t!control_type_valid(control_type))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (power_zone) {\n\t\tif (!ops->release)\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\tmemset(power_zone, 0, sizeof(*power_zone));\n\t} else {\n\t\tpower_zone = kzalloc(sizeof(*power_zone), GFP_KERNEL);\n\t\tif (!power_zone)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\tpower_zone->allocated = true;\n\t}\n\tpower_zone->ops = ops;\n\tpower_zone->control_type_inst = control_type;\n\tif (!parent) {\n\t\tpower_zone->dev.parent = &control_type->dev;\n\t\tpower_zone->parent_idr = &control_type->idr;\n\t} else {\n\t\tpower_zone->dev.parent = &parent->dev;\n\t\tpower_zone->parent_idr = &parent->idr;\n\t}\n\tpower_zone->dev.class = &powercap_class;\n\n\tmutex_lock(&control_type->lock);\n\t \n\tresult = idr_alloc(power_zone->parent_idr, NULL, 0, 0, GFP_KERNEL);\n\tif (result < 0)\n\t\tgoto err_idr_alloc;\n\n\tpower_zone->id = result;\n\tidr_init(&power_zone->idr);\n\tresult = -ENOMEM;\n\tpower_zone->name = kstrdup(name, GFP_KERNEL);\n\tif (!power_zone->name)\n\t\tgoto err_name_alloc;\n\tpower_zone->constraints = kcalloc(nr_constraints,\n\t\t\t\t\t  sizeof(*power_zone->constraints),\n\t\t\t\t\t  GFP_KERNEL);\n\tif (!power_zone->constraints)\n\t\tgoto err_const_alloc;\n\n\tnr_attrs = nr_constraints * POWERCAP_CONSTRAINTS_ATTRS +\n\t\t\t\t\t\tPOWERCAP_ZONE_MAX_ATTRS + 1;\n\tpower_zone->zone_dev_attrs = kcalloc(nr_attrs, sizeof(void *),\n\t\t\t\t\t     GFP_KERNEL);\n\tif (!power_zone->zone_dev_attrs)\n\t\tgoto err_attr_alloc;\n\tcreate_power_zone_common_attributes(power_zone);\n\tresult = create_constraints(power_zone, nr_constraints, const_ops);\n\tif (result)\n\t\tgoto err_dev_ret;\n\n\tpower_zone->zone_dev_attrs[power_zone->zone_attr_count] = NULL;\n\tpower_zone->dev_zone_attr_group.attrs = power_zone->zone_dev_attrs;\n\tpower_zone->dev_attr_groups[0] = &power_zone->dev_zone_attr_group;\n\tpower_zone->dev_attr_groups[1] = NULL;\n\tpower_zone->dev.groups = power_zone->dev_attr_groups;\n\tdev_set_name(&power_zone->dev, \"%s:%x\",\n\t\t\t\t\tdev_name(power_zone->dev.parent),\n\t\t\t\t\tpower_zone->id);\n\tresult = device_register(&power_zone->dev);\n\tif (result) {\n\t\tput_device(&power_zone->dev);\n\t\tmutex_unlock(&control_type->lock);\n\n\t\treturn ERR_PTR(result);\n\t}\n\n\tcontrol_type->nr_zones++;\n\tmutex_unlock(&control_type->lock);\n\n\treturn power_zone;\n\nerr_dev_ret:\n\tkfree(power_zone->zone_dev_attrs);\nerr_attr_alloc:\n\tkfree(power_zone->constraints);\nerr_const_alloc:\n\tkfree(power_zone->name);\nerr_name_alloc:\n\tidr_remove(power_zone->parent_idr, power_zone->id);\nerr_idr_alloc:\n\tif (power_zone->allocated)\n\t\tkfree(power_zone);\n\tmutex_unlock(&control_type->lock);\n\n\treturn ERR_PTR(result);\n}\nEXPORT_SYMBOL_GPL(powercap_register_zone);\n\nint powercap_unregister_zone(struct powercap_control_type *control_type,\n\t\t\t\tstruct powercap_zone *power_zone)\n{\n\tif (!power_zone || !control_type)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&control_type->lock);\n\tcontrol_type->nr_zones--;\n\tmutex_unlock(&control_type->lock);\n\n\tdevice_unregister(&power_zone->dev);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(powercap_unregister_zone);\n\nstruct powercap_control_type *powercap_register_control_type(\n\t\t\t\tstruct powercap_control_type *control_type,\n\t\t\t\tconst char *name,\n\t\t\t\tconst struct powercap_control_type_ops *ops)\n{\n\tint result;\n\n\tif (!name)\n\t\treturn ERR_PTR(-EINVAL);\n\tif (control_type) {\n\t\tif (!ops || !ops->release)\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\tmemset(control_type, 0, sizeof(*control_type));\n\t} else {\n\t\tcontrol_type = kzalloc(sizeof(*control_type), GFP_KERNEL);\n\t\tif (!control_type)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\tcontrol_type->allocated = true;\n\t}\n\tmutex_init(&control_type->lock);\n\tcontrol_type->ops = ops;\n\tINIT_LIST_HEAD(&control_type->node);\n\tcontrol_type->dev.class = &powercap_class;\n\tdev_set_name(&control_type->dev, \"%s\", name);\n\tresult = device_register(&control_type->dev);\n\tif (result) {\n\t\tif (control_type->allocated)\n\t\t\tkfree(control_type);\n\t\treturn ERR_PTR(result);\n\t}\n\tidr_init(&control_type->idr);\n\n\tmutex_lock(&powercap_cntrl_list_lock);\n\tlist_add_tail(&control_type->node, &powercap_cntrl_list);\n\tmutex_unlock(&powercap_cntrl_list_lock);\n\n\treturn control_type;\n}\nEXPORT_SYMBOL_GPL(powercap_register_control_type);\n\nint powercap_unregister_control_type(struct powercap_control_type *control_type)\n{\n\tstruct powercap_control_type *pos = NULL;\n\n\tif (control_type->nr_zones) {\n\t\tdev_err(&control_type->dev, \"Zones of this type still not freed\\n\");\n\t\treturn -EINVAL;\n\t}\n\tmutex_lock(&powercap_cntrl_list_lock);\n\tlist_for_each_entry(pos, &powercap_cntrl_list, node) {\n\t\tif (pos == control_type) {\n\t\t\tlist_del(&control_type->node);\n\t\t\tmutex_unlock(&powercap_cntrl_list_lock);\n\t\t\tdevice_unregister(&control_type->dev);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tmutex_unlock(&powercap_cntrl_list_lock);\n\n\treturn -ENODEV;\n}\nEXPORT_SYMBOL_GPL(powercap_unregister_control_type);\n\nstatic int __init powercap_init(void)\n{\n\tint result;\n\n\tresult = seed_constraint_attributes();\n\tif (result)\n\t\treturn result;\n\n\treturn class_register(&powercap_class);\n}\n\nfs_initcall(powercap_init);\n\nMODULE_DESCRIPTION(\"PowerCap sysfs Driver\");\nMODULE_AUTHOR(\"Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}