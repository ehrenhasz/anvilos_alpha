{
  "module_name": "idle_inject.c",
  "hash_id": "cf62bf7f0bd32480ad33405a6810e54ef2604a1622f04f2e2c5fa5ccebabca23",
  "original_prompt": "Ingested from linux-6.6.14/drivers/powercap/idle_inject.c",
  "human_readable_source": "\n \n#define pr_fmt(fmt) \"ii_dev: \" fmt\n\n#include <linux/cpu.h>\n#include <linux/hrtimer.h>\n#include <linux/kthread.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/smpboot.h>\n#include <linux/idle_inject.h>\n\n#include <uapi/linux/sched/types.h>\n\n \nstruct idle_inject_thread {\n\tstruct task_struct *tsk;\n\tint should_run;\n};\n\n \nstruct idle_inject_device {\n\tstruct hrtimer timer;\n\tunsigned int idle_duration_us;\n\tunsigned int run_duration_us;\n\tunsigned int latency_us;\n\tbool (*update)(void);\n\tunsigned long cpumask[];\n};\n\nstatic DEFINE_PER_CPU(struct idle_inject_thread, idle_inject_thread);\nstatic DEFINE_PER_CPU(struct idle_inject_device *, idle_inject_device);\n\n \nstatic void idle_inject_wakeup(struct idle_inject_device *ii_dev)\n{\n\tstruct idle_inject_thread *iit;\n\tunsigned int cpu;\n\n\tfor_each_cpu_and(cpu, to_cpumask(ii_dev->cpumask), cpu_online_mask) {\n\t\tiit = per_cpu_ptr(&idle_inject_thread, cpu);\n\t\tiit->should_run = 1;\n\t\twake_up_process(iit->tsk);\n\t}\n}\n\n \nstatic enum hrtimer_restart idle_inject_timer_fn(struct hrtimer *timer)\n{\n\tunsigned int duration_us;\n\tstruct idle_inject_device *ii_dev =\n\t\tcontainer_of(timer, struct idle_inject_device, timer);\n\n\tif (!ii_dev->update || (ii_dev->update && ii_dev->update()))\n\t\tidle_inject_wakeup(ii_dev);\n\n\tduration_us = READ_ONCE(ii_dev->run_duration_us);\n\tduration_us += READ_ONCE(ii_dev->idle_duration_us);\n\n\thrtimer_forward_now(timer, ns_to_ktime(duration_us * NSEC_PER_USEC));\n\n\treturn HRTIMER_RESTART;\n}\n\n \nstatic void idle_inject_fn(unsigned int cpu)\n{\n\tstruct idle_inject_device *ii_dev;\n\tstruct idle_inject_thread *iit;\n\n\tii_dev = per_cpu(idle_inject_device, cpu);\n\tiit = per_cpu_ptr(&idle_inject_thread, cpu);\n\n\t \n\tiit->should_run = 0;\n\n\tplay_idle_precise(READ_ONCE(ii_dev->idle_duration_us) * NSEC_PER_USEC,\n\t\t\t  READ_ONCE(ii_dev->latency_us) * NSEC_PER_USEC);\n}\n\n \nvoid idle_inject_set_duration(struct idle_inject_device *ii_dev,\n\t\t\t      unsigned int run_duration_us,\n\t\t\t      unsigned int idle_duration_us)\n{\n\tif (run_duration_us + idle_duration_us) {\n\t\tWRITE_ONCE(ii_dev->run_duration_us, run_duration_us);\n\t\tWRITE_ONCE(ii_dev->idle_duration_us, idle_duration_us);\n\t}\n\tif (!run_duration_us)\n\t\tpr_debug(\"CPU is forced to 100 percent idle\\n\");\n}\nEXPORT_SYMBOL_NS_GPL(idle_inject_set_duration, IDLE_INJECT);\n\n \nvoid idle_inject_get_duration(struct idle_inject_device *ii_dev,\n\t\t\t      unsigned int *run_duration_us,\n\t\t\t      unsigned int *idle_duration_us)\n{\n\t*run_duration_us = READ_ONCE(ii_dev->run_duration_us);\n\t*idle_duration_us = READ_ONCE(ii_dev->idle_duration_us);\n}\nEXPORT_SYMBOL_NS_GPL(idle_inject_get_duration, IDLE_INJECT);\n\n \nvoid idle_inject_set_latency(struct idle_inject_device *ii_dev,\n\t\t\t     unsigned int latency_us)\n{\n\tWRITE_ONCE(ii_dev->latency_us, latency_us);\n}\nEXPORT_SYMBOL_NS_GPL(idle_inject_set_latency, IDLE_INJECT);\n\n \nint idle_inject_start(struct idle_inject_device *ii_dev)\n{\n\tunsigned int idle_duration_us = READ_ONCE(ii_dev->idle_duration_us);\n\tunsigned int run_duration_us = READ_ONCE(ii_dev->run_duration_us);\n\n\tif (!(idle_duration_us + run_duration_us))\n\t\treturn -EINVAL;\n\n\tpr_debug(\"Starting injecting idle cycles on CPUs '%*pbl'\\n\",\n\t\t cpumask_pr_args(to_cpumask(ii_dev->cpumask)));\n\n\tidle_inject_wakeup(ii_dev);\n\n\thrtimer_start(&ii_dev->timer,\n\t\t      ns_to_ktime((idle_duration_us + run_duration_us) *\n\t\t\t\t  NSEC_PER_USEC),\n\t\t      HRTIMER_MODE_REL);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_NS_GPL(idle_inject_start, IDLE_INJECT);\n\n \nvoid idle_inject_stop(struct idle_inject_device *ii_dev)\n{\n\tstruct idle_inject_thread *iit;\n\tunsigned int cpu;\n\n\tpr_debug(\"Stopping idle injection on CPUs '%*pbl'\\n\",\n\t\t cpumask_pr_args(to_cpumask(ii_dev->cpumask)));\n\n\thrtimer_cancel(&ii_dev->timer);\n\n\t \n\tcpu_hotplug_disable();\n\n\t \n\tfor_each_cpu(cpu, to_cpumask(ii_dev->cpumask)) {\n\t\tiit = per_cpu_ptr(&idle_inject_thread, cpu);\n\t\tiit->should_run = 0;\n\n\t\twait_task_inactive(iit->tsk, TASK_ANY);\n\t}\n\n\tcpu_hotplug_enable();\n}\nEXPORT_SYMBOL_NS_GPL(idle_inject_stop, IDLE_INJECT);\n\n \nstatic void idle_inject_setup(unsigned int cpu)\n{\n\tsched_set_fifo(current);\n}\n\n \nstatic int idle_inject_should_run(unsigned int cpu)\n{\n\tstruct idle_inject_thread *iit =\n\t\tper_cpu_ptr(&idle_inject_thread, cpu);\n\n\treturn iit->should_run;\n}\n\n \n\nstruct idle_inject_device *idle_inject_register_full(struct cpumask *cpumask,\n\t\t\t\t\t\t     bool (*update)(void))\n{\n\tstruct idle_inject_device *ii_dev;\n\tint cpu, cpu_rb;\n\n\tii_dev = kzalloc(sizeof(*ii_dev) + cpumask_size(), GFP_KERNEL);\n\tif (!ii_dev)\n\t\treturn NULL;\n\n\tcpumask_copy(to_cpumask(ii_dev->cpumask), cpumask);\n\thrtimer_init(&ii_dev->timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);\n\tii_dev->timer.function = idle_inject_timer_fn;\n\tii_dev->latency_us = UINT_MAX;\n\tii_dev->update = update;\n\n\tfor_each_cpu(cpu, to_cpumask(ii_dev->cpumask)) {\n\n\t\tif (per_cpu(idle_inject_device, cpu)) {\n\t\t\tpr_err(\"cpu%d is already registered\\n\", cpu);\n\t\t\tgoto out_rollback;\n\t\t}\n\n\t\tper_cpu(idle_inject_device, cpu) = ii_dev;\n\t}\n\n\treturn ii_dev;\n\nout_rollback:\n\tfor_each_cpu(cpu_rb, to_cpumask(ii_dev->cpumask)) {\n\t\tif (cpu == cpu_rb)\n\t\t\tbreak;\n\t\tper_cpu(idle_inject_device, cpu_rb) = NULL;\n\t}\n\n\tkfree(ii_dev);\n\n\treturn NULL;\n}\nEXPORT_SYMBOL_NS_GPL(idle_inject_register_full, IDLE_INJECT);\n\n \nstruct idle_inject_device *idle_inject_register(struct cpumask *cpumask)\n{\n\treturn idle_inject_register_full(cpumask, NULL);\n}\nEXPORT_SYMBOL_NS_GPL(idle_inject_register, IDLE_INJECT);\n\n \nvoid idle_inject_unregister(struct idle_inject_device *ii_dev)\n{\n\tunsigned int cpu;\n\n\tidle_inject_stop(ii_dev);\n\n\tfor_each_cpu(cpu, to_cpumask(ii_dev->cpumask))\n\t\tper_cpu(idle_inject_device, cpu) = NULL;\n\n\tkfree(ii_dev);\n}\nEXPORT_SYMBOL_NS_GPL(idle_inject_unregister, IDLE_INJECT);\n\nstatic struct smp_hotplug_thread idle_inject_threads = {\n\t.store = &idle_inject_thread.tsk,\n\t.setup = idle_inject_setup,\n\t.thread_fn = idle_inject_fn,\n\t.thread_comm = \"idle_inject/%u\",\n\t.thread_should_run = idle_inject_should_run,\n};\n\nstatic int __init idle_inject_init(void)\n{\n\treturn smpboot_register_percpu_thread(&idle_inject_threads);\n}\nearly_initcall(idle_inject_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}