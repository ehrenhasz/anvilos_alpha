{
  "module_name": "dtpm_devfreq.c",
  "hash_id": "0b9b9b9863096352bbb20c1d1e2513fb2a142a889b8cb56dc9fd3cd6242dc41b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/powercap/dtpm_devfreq.c",
  "human_readable_source": "\n \n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/cpumask.h>\n#include <linux/devfreq.h>\n#include <linux/dtpm.h>\n#include <linux/energy_model.h>\n#include <linux/of.h>\n#include <linux/pm_qos.h>\n#include <linux/slab.h>\n#include <linux/units.h>\n\nstruct dtpm_devfreq {\n\tstruct dtpm dtpm;\n\tstruct dev_pm_qos_request qos_req;\n\tstruct devfreq *devfreq;\n};\n\nstatic struct dtpm_devfreq *to_dtpm_devfreq(struct dtpm *dtpm)\n{\n\treturn container_of(dtpm, struct dtpm_devfreq, dtpm);\n}\n\nstatic int update_pd_power_uw(struct dtpm *dtpm)\n{\n\tstruct dtpm_devfreq *dtpm_devfreq = to_dtpm_devfreq(dtpm);\n\tstruct devfreq *devfreq = dtpm_devfreq->devfreq;\n\tstruct device *dev = devfreq->dev.parent;\n\tstruct em_perf_domain *pd = em_pd_get(dev);\n\n\tdtpm->power_min = pd->table[0].power;\n\n\tdtpm->power_max = pd->table[pd->nr_perf_states - 1].power;\n\n\treturn 0;\n}\n\nstatic u64 set_pd_power_limit(struct dtpm *dtpm, u64 power_limit)\n{\n\tstruct dtpm_devfreq *dtpm_devfreq = to_dtpm_devfreq(dtpm);\n\tstruct devfreq *devfreq = dtpm_devfreq->devfreq;\n\tstruct device *dev = devfreq->dev.parent;\n\tstruct em_perf_domain *pd = em_pd_get(dev);\n\tunsigned long freq;\n\tint i;\n\n\tfor (i = 0; i < pd->nr_perf_states; i++) {\n\t\tif (pd->table[i].power > power_limit)\n\t\t\tbreak;\n\t}\n\n\tfreq = pd->table[i - 1].frequency;\n\n\tdev_pm_qos_update_request(&dtpm_devfreq->qos_req, freq);\n\n\tpower_limit = pd->table[i - 1].power;\n\n\treturn power_limit;\n}\n\nstatic void _normalize_load(struct devfreq_dev_status *status)\n{\n\tif (status->total_time > 0xfffff) {\n\t\tstatus->total_time >>= 10;\n\t\tstatus->busy_time >>= 10;\n\t}\n\n\tstatus->busy_time <<= 10;\n\tstatus->busy_time /= status->total_time ? : 1;\n\n\tstatus->busy_time = status->busy_time ? : 1;\n\tstatus->total_time = 1024;\n}\n\nstatic u64 get_pd_power_uw(struct dtpm *dtpm)\n{\n\tstruct dtpm_devfreq *dtpm_devfreq = to_dtpm_devfreq(dtpm);\n\tstruct devfreq *devfreq = dtpm_devfreq->devfreq;\n\tstruct device *dev = devfreq->dev.parent;\n\tstruct em_perf_domain *pd = em_pd_get(dev);\n\tstruct devfreq_dev_status status;\n\tunsigned long freq;\n\tu64 power;\n\tint i;\n\n\tmutex_lock(&devfreq->lock);\n\tstatus = devfreq->last_status;\n\tmutex_unlock(&devfreq->lock);\n\n\tfreq = DIV_ROUND_UP(status.current_frequency, HZ_PER_KHZ);\n\t_normalize_load(&status);\n\n\tfor (i = 0; i < pd->nr_perf_states; i++) {\n\n\t\tif (pd->table[i].frequency < freq)\n\t\t\tcontinue;\n\n\t\tpower = pd->table[i].power;\n\t\tpower *= status.busy_time;\n\t\tpower >>= 10;\n\n\t\treturn power;\n\t}\n\n\treturn 0;\n}\n\nstatic void pd_release(struct dtpm *dtpm)\n{\n\tstruct dtpm_devfreq *dtpm_devfreq = to_dtpm_devfreq(dtpm);\n\n\tif (dev_pm_qos_request_active(&dtpm_devfreq->qos_req))\n\t\tdev_pm_qos_remove_request(&dtpm_devfreq->qos_req);\n\n\tkfree(dtpm_devfreq);\n}\n\nstatic struct dtpm_ops dtpm_ops = {\n\t.set_power_uw = set_pd_power_limit,\n\t.get_power_uw = get_pd_power_uw,\n\t.update_power_uw = update_pd_power_uw,\n\t.release = pd_release,\n};\n\nstatic int __dtpm_devfreq_setup(struct devfreq *devfreq, struct dtpm *parent)\n{\n\tstruct device *dev = devfreq->dev.parent;\n\tstruct dtpm_devfreq *dtpm_devfreq;\n\tstruct em_perf_domain *pd;\n\tint ret = -ENOMEM;\n\n\tpd = em_pd_get(dev);\n\tif (!pd) {\n\t\tret = dev_pm_opp_of_register_em(dev, NULL);\n\t\tif (ret) {\n\t\t\tpr_err(\"No energy model available for '%s'\\n\", dev_name(dev));\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tdtpm_devfreq = kzalloc(sizeof(*dtpm_devfreq), GFP_KERNEL);\n\tif (!dtpm_devfreq)\n\t\treturn -ENOMEM;\n\n\tdtpm_init(&dtpm_devfreq->dtpm, &dtpm_ops);\n\n\tdtpm_devfreq->devfreq = devfreq;\n\n\tret = dtpm_register(dev_name(dev), &dtpm_devfreq->dtpm, parent);\n\tif (ret) {\n\t\tpr_err(\"Failed to register '%s': %d\\n\", dev_name(dev), ret);\n\t\tkfree(dtpm_devfreq);\n\t\treturn ret;\n\t}\n\n\tret = dev_pm_qos_add_request(dev, &dtpm_devfreq->qos_req,\n\t\t\t\t     DEV_PM_QOS_MAX_FREQUENCY,\n\t\t\t\t     PM_QOS_MAX_FREQUENCY_DEFAULT_VALUE);\n\tif (ret) {\n\t\tpr_err(\"Failed to add QoS request: %d\\n\", ret);\n\t\tgoto out_dtpm_unregister;\n\t}\n\n\tdtpm_update_power(&dtpm_devfreq->dtpm);\n\n\treturn 0;\n\nout_dtpm_unregister:\n\tdtpm_unregister(&dtpm_devfreq->dtpm);\n\n\treturn ret;\n}\n\nstatic int dtpm_devfreq_setup(struct dtpm *dtpm, struct device_node *np)\n{\n\tstruct devfreq *devfreq;\n\n\tdevfreq = devfreq_get_devfreq_by_node(np);\n\tif (IS_ERR(devfreq))\n\t\treturn 0;\n\n\treturn __dtpm_devfreq_setup(devfreq, dtpm);\n}\n\nstruct dtpm_subsys_ops dtpm_devfreq_ops = {\n\t.name = KBUILD_MODNAME,\n\t.setup = dtpm_devfreq_setup,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}