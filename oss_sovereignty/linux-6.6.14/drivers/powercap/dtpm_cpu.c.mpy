{
  "module_name": "dtpm_cpu.c",
  "hash_id": "111cf16d0c83e69ca03f68b2cf1606c0686954b3405b591bf8d52e0e0d0d8892",
  "original_prompt": "Ingested from linux-6.6.14/drivers/powercap/dtpm_cpu.c",
  "human_readable_source": "\n \n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/cpumask.h>\n#include <linux/cpufreq.h>\n#include <linux/cpuhotplug.h>\n#include <linux/dtpm.h>\n#include <linux/energy_model.h>\n#include <linux/of.h>\n#include <linux/pm_qos.h>\n#include <linux/slab.h>\n\nstruct dtpm_cpu {\n\tstruct dtpm dtpm;\n\tstruct freq_qos_request qos_req;\n\tint cpu;\n};\n\nstatic DEFINE_PER_CPU(struct dtpm_cpu *, dtpm_per_cpu);\n\nstatic struct dtpm_cpu *to_dtpm_cpu(struct dtpm *dtpm)\n{\n\treturn container_of(dtpm, struct dtpm_cpu, dtpm);\n}\n\nstatic u64 set_pd_power_limit(struct dtpm *dtpm, u64 power_limit)\n{\n\tstruct dtpm_cpu *dtpm_cpu = to_dtpm_cpu(dtpm);\n\tstruct em_perf_domain *pd = em_cpu_get(dtpm_cpu->cpu);\n\tstruct cpumask cpus;\n\tunsigned long freq;\n\tu64 power;\n\tint i, nr_cpus;\n\n\tcpumask_and(&cpus, cpu_online_mask, to_cpumask(pd->cpus));\n\tnr_cpus = cpumask_weight(&cpus);\n\n\tfor (i = 0; i < pd->nr_perf_states; i++) {\n\n\t\tpower = pd->table[i].power * nr_cpus;\n\n\t\tif (power > power_limit)\n\t\t\tbreak;\n\t}\n\n\tfreq = pd->table[i - 1].frequency;\n\n\tfreq_qos_update_request(&dtpm_cpu->qos_req, freq);\n\n\tpower_limit = pd->table[i - 1].power * nr_cpus;\n\n\treturn power_limit;\n}\n\nstatic u64 scale_pd_power_uw(struct cpumask *pd_mask, u64 power)\n{\n\tunsigned long max, sum_util = 0;\n\tint cpu;\n\n\t \n\tmax = arch_scale_cpu_capacity(cpumask_first(pd_mask));\n\n\tfor_each_cpu_and(cpu, pd_mask, cpu_online_mask)\n\t\tsum_util += sched_cpu_util(cpu);\n\n\treturn (power * ((sum_util << 10) / max)) >> 10;\n}\n\nstatic u64 get_pd_power_uw(struct dtpm *dtpm)\n{\n\tstruct dtpm_cpu *dtpm_cpu = to_dtpm_cpu(dtpm);\n\tstruct em_perf_domain *pd;\n\tstruct cpumask *pd_mask;\n\tunsigned long freq;\n\tint i;\n\n\tpd = em_cpu_get(dtpm_cpu->cpu);\n\n\tpd_mask = em_span_cpus(pd);\n\n\tfreq = cpufreq_quick_get(dtpm_cpu->cpu);\n\n\tfor (i = 0; i < pd->nr_perf_states; i++) {\n\n\t\tif (pd->table[i].frequency < freq)\n\t\t\tcontinue;\n\n\t\treturn scale_pd_power_uw(pd_mask, pd->table[i].power);\n\t}\n\n\treturn 0;\n}\n\nstatic int update_pd_power_uw(struct dtpm *dtpm)\n{\n\tstruct dtpm_cpu *dtpm_cpu = to_dtpm_cpu(dtpm);\n\tstruct em_perf_domain *em = em_cpu_get(dtpm_cpu->cpu);\n\tstruct cpumask cpus;\n\tint nr_cpus;\n\n\tcpumask_and(&cpus, cpu_online_mask, to_cpumask(em->cpus));\n\tnr_cpus = cpumask_weight(&cpus);\n\n\tdtpm->power_min = em->table[0].power;\n\tdtpm->power_min *= nr_cpus;\n\n\tdtpm->power_max = em->table[em->nr_perf_states - 1].power;\n\tdtpm->power_max *= nr_cpus;\n\n\treturn 0;\n}\n\nstatic void pd_release(struct dtpm *dtpm)\n{\n\tstruct dtpm_cpu *dtpm_cpu = to_dtpm_cpu(dtpm);\n\tstruct cpufreq_policy *policy;\n\n\tif (freq_qos_request_active(&dtpm_cpu->qos_req))\n\t\tfreq_qos_remove_request(&dtpm_cpu->qos_req);\n\n\tpolicy = cpufreq_cpu_get(dtpm_cpu->cpu);\n\tif (policy) {\n\t\tfor_each_cpu(dtpm_cpu->cpu, policy->related_cpus)\n\t\t\tper_cpu(dtpm_per_cpu, dtpm_cpu->cpu) = NULL;\n\n\t\tcpufreq_cpu_put(policy);\n\t}\n\t\n\tkfree(dtpm_cpu);\n}\n\nstatic struct dtpm_ops dtpm_ops = {\n\t.set_power_uw\t = set_pd_power_limit,\n\t.get_power_uw\t = get_pd_power_uw,\n\t.update_power_uw = update_pd_power_uw,\n\t.release\t = pd_release,\n};\n\nstatic int cpuhp_dtpm_cpu_offline(unsigned int cpu)\n{\n\tstruct dtpm_cpu *dtpm_cpu;\n\n\tdtpm_cpu = per_cpu(dtpm_per_cpu, cpu);\n\tif (dtpm_cpu)\n\t\tdtpm_update_power(&dtpm_cpu->dtpm);\n\n\treturn 0;\n}\n\nstatic int cpuhp_dtpm_cpu_online(unsigned int cpu)\n{\n\tstruct dtpm_cpu *dtpm_cpu;\n\n\tdtpm_cpu = per_cpu(dtpm_per_cpu, cpu);\n\tif (dtpm_cpu)\n\t\treturn dtpm_update_power(&dtpm_cpu->dtpm);\n\n\treturn 0;\n}\n\nstatic int __dtpm_cpu_setup(int cpu, struct dtpm *parent)\n{\n\tstruct dtpm_cpu *dtpm_cpu;\n\tstruct cpufreq_policy *policy;\n\tstruct em_perf_domain *pd;\n\tchar name[CPUFREQ_NAME_LEN];\n\tint ret = -ENOMEM;\n\n\tdtpm_cpu = per_cpu(dtpm_per_cpu, cpu);\n\tif (dtpm_cpu)\n\t\treturn 0;\n\n\tpolicy = cpufreq_cpu_get(cpu);\n\tif (!policy)\n\t\treturn 0;\n\n\tpd = em_cpu_get(cpu);\n\tif (!pd || em_is_artificial(pd)) {\n\t\tret = -EINVAL;\n\t\tgoto release_policy;\n\t}\n\n\tdtpm_cpu = kzalloc(sizeof(*dtpm_cpu), GFP_KERNEL);\n\tif (!dtpm_cpu) {\n\t\tret = -ENOMEM;\n\t\tgoto release_policy;\n\t}\n\n\tdtpm_init(&dtpm_cpu->dtpm, &dtpm_ops);\n\tdtpm_cpu->cpu = cpu;\n\n\tfor_each_cpu(cpu, policy->related_cpus)\n\t\tper_cpu(dtpm_per_cpu, cpu) = dtpm_cpu;\n\n\tsnprintf(name, sizeof(name), \"cpu%d-cpufreq\", dtpm_cpu->cpu);\n\n\tret = dtpm_register(name, &dtpm_cpu->dtpm, parent);\n\tif (ret)\n\t\tgoto out_kfree_dtpm_cpu;\n\n\tret = freq_qos_add_request(&policy->constraints,\n\t\t\t\t   &dtpm_cpu->qos_req, FREQ_QOS_MAX,\n\t\t\t\t   pd->table[pd->nr_perf_states - 1].frequency);\n\tif (ret)\n\t\tgoto out_dtpm_unregister;\n\n\tcpufreq_cpu_put(policy);\n\treturn 0;\n\nout_dtpm_unregister:\n\tdtpm_unregister(&dtpm_cpu->dtpm);\n\tdtpm_cpu = NULL;\n\nout_kfree_dtpm_cpu:\n\tfor_each_cpu(cpu, policy->related_cpus)\n\t\tper_cpu(dtpm_per_cpu, cpu) = NULL;\n\tkfree(dtpm_cpu);\n\nrelease_policy:\n\tcpufreq_cpu_put(policy);\n\treturn ret;\n}\n\nstatic int dtpm_cpu_setup(struct dtpm *dtpm, struct device_node *np)\n{\n\tint cpu;\n\n\tcpu = of_cpu_node_to_id(np);\n\tif (cpu < 0)\n\t\treturn 0;\n\n\treturn __dtpm_cpu_setup(cpu, dtpm);\n}\n\nstatic int dtpm_cpu_init(void)\n{\n\tint ret;\n\n\t \n\tret = cpuhp_setup_state(CPUHP_AP_DTPM_CPU_DEAD, \"dtpm_cpu:offline\",\n\t\t\t\tNULL, cpuhp_dtpm_cpu_offline);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = cpuhp_setup_state(CPUHP_AP_ONLINE_DYN, \"dtpm_cpu:online\",\n\t\t\t\tcpuhp_dtpm_cpu_online, NULL);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic void dtpm_cpu_exit(void)\n{\n\tcpuhp_remove_state_nocalls(CPUHP_AP_ONLINE_DYN);\n\tcpuhp_remove_state_nocalls(CPUHP_AP_DTPM_CPU_DEAD);\n}\n\nstruct dtpm_subsys_ops dtpm_cpu_ops = {\n\t.name = KBUILD_MODNAME,\n\t.init = dtpm_cpu_init,\n\t.exit = dtpm_cpu_exit,\n\t.setup = dtpm_cpu_setup,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}