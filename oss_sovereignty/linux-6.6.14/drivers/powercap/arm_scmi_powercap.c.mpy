{
  "module_name": "arm_scmi_powercap.c",
  "hash_id": "827f984ee8878957526c5894eaeaac8b41e27436c39b41b383abafd2b8759761",
  "original_prompt": "Ingested from linux-6.6.14/drivers/powercap/arm_scmi_powercap.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/math.h>\n#include <linux/limits.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/powercap.h>\n#include <linux/scmi_protocol.h>\n#include <linux/slab.h>\n\n#define to_scmi_powercap_zone(z)\t\t\\\n\tcontainer_of(z, struct scmi_powercap_zone, zone)\n\nstatic const struct scmi_powercap_proto_ops *powercap_ops;\n\nstruct scmi_powercap_zone {\n\tbool registered;\n\tbool invalid;\n\tunsigned int height;\n\tstruct device *dev;\n\tstruct scmi_protocol_handle *ph;\n\tconst struct scmi_powercap_info *info;\n\tstruct scmi_powercap_zone *spzones;\n\tstruct powercap_zone zone;\n\tstruct list_head node;\n};\n\nstruct scmi_powercap_root {\n\tunsigned int num_zones;\n\tstruct scmi_powercap_zone *spzones;\n\tstruct list_head *registered_zones;\n\tstruct list_head scmi_zones;\n};\n\nstatic struct powercap_control_type *scmi_top_pcntrl;\n\nstatic int scmi_powercap_zone_release(struct powercap_zone *pz)\n{\n\treturn 0;\n}\n\nstatic int scmi_powercap_get_max_power_range_uw(struct powercap_zone *pz,\n\t\t\t\t\t\tu64 *max_power_range_uw)\n{\n\t*max_power_range_uw = U32_MAX;\n\treturn 0;\n}\n\nstatic int scmi_powercap_get_power_uw(struct powercap_zone *pz,\n\t\t\t\t      u64 *power_uw)\n{\n\tstruct scmi_powercap_zone *spz = to_scmi_powercap_zone(pz);\n\tu32 avg_power, pai;\n\tint ret;\n\n\tif (!spz->info->powercap_monitoring)\n\t\treturn -EINVAL;\n\n\tret = powercap_ops->measurements_get(spz->ph, spz->info->id, &avg_power,\n\t\t\t\t\t     &pai);\n\tif (ret)\n\t\treturn ret;\n\n\t*power_uw = avg_power;\n\tif (spz->info->powercap_scale_mw)\n\t\t*power_uw *= 1000;\n\n\treturn 0;\n}\n\nstatic int scmi_powercap_zone_enable_set(struct powercap_zone *pz, bool mode)\n{\n\tstruct scmi_powercap_zone *spz = to_scmi_powercap_zone(pz);\n\n\treturn powercap_ops->cap_enable_set(spz->ph, spz->info->id, mode);\n}\n\nstatic int scmi_powercap_zone_enable_get(struct powercap_zone *pz, bool *mode)\n{\n\tstruct scmi_powercap_zone *spz = to_scmi_powercap_zone(pz);\n\n\treturn powercap_ops->cap_enable_get(spz->ph, spz->info->id, mode);\n}\n\nstatic const struct powercap_zone_ops zone_ops = {\n\t.get_max_power_range_uw = scmi_powercap_get_max_power_range_uw,\n\t.get_power_uw = scmi_powercap_get_power_uw,\n\t.release = scmi_powercap_zone_release,\n\t.set_enable = scmi_powercap_zone_enable_set,\n\t.get_enable = scmi_powercap_zone_enable_get,\n};\n\nstatic void scmi_powercap_normalize_cap(const struct scmi_powercap_zone *spz,\n\t\t\t\t\tu64 power_limit_uw, u32 *norm)\n{\n\tbool scale_mw = spz->info->powercap_scale_mw;\n\tu64 val;\n\n\tval = scale_mw ? DIV_ROUND_UP_ULL(power_limit_uw, 1000) : power_limit_uw;\n\t \n\t*norm = clamp_t(u32, val, spz->info->min_power_cap,\n\t\t\tspz->info->max_power_cap);\n\t*norm = rounddown(*norm, spz->info->power_cap_step);\n\n\tval = (scale_mw) ? *norm * 1000 : *norm;\n\tif (power_limit_uw != val)\n\t\tdev_dbg(spz->dev,\n\t\t\t\"Normalized %s:CAP - requested:%llu - normalized:%llu\\n\",\n\t\t\tspz->info->name, power_limit_uw, val);\n}\n\nstatic int scmi_powercap_set_power_limit_uw(struct powercap_zone *pz, int cid,\n\t\t\t\t\t    u64 power_uw)\n{\n\tstruct scmi_powercap_zone *spz = to_scmi_powercap_zone(pz);\n\tu32 norm_power;\n\n\tif (!spz->info->powercap_cap_config)\n\t\treturn -EINVAL;\n\n\tscmi_powercap_normalize_cap(spz, power_uw, &norm_power);\n\n\treturn powercap_ops->cap_set(spz->ph, spz->info->id, norm_power, false);\n}\n\nstatic int scmi_powercap_get_power_limit_uw(struct powercap_zone *pz, int cid,\n\t\t\t\t\t    u64 *power_limit_uw)\n{\n\tstruct scmi_powercap_zone *spz = to_scmi_powercap_zone(pz);\n\tu32 power;\n\tint ret;\n\n\tret = powercap_ops->cap_get(spz->ph, spz->info->id, &power);\n\tif (ret)\n\t\treturn ret;\n\n\t*power_limit_uw = power;\n\tif (spz->info->powercap_scale_mw)\n\t\t*power_limit_uw *= 1000;\n\n\treturn 0;\n}\n\nstatic void scmi_powercap_normalize_time(const struct scmi_powercap_zone *spz,\n\t\t\t\t\t u64 time_us, u32 *norm)\n{\n\t \n\t*norm = clamp_t(u32, time_us, spz->info->min_pai, spz->info->max_pai);\n\t*norm = rounddown(*norm, spz->info->pai_step);\n\n\tif (time_us != *norm)\n\t\tdev_dbg(spz->dev,\n\t\t\t\"Normalized %s:PAI - requested:%llu - normalized:%u\\n\",\n\t\t\tspz->info->name, time_us, *norm);\n}\n\nstatic int scmi_powercap_set_time_window_us(struct powercap_zone *pz, int cid,\n\t\t\t\t\t    u64 time_window_us)\n{\n\tstruct scmi_powercap_zone *spz = to_scmi_powercap_zone(pz);\n\tu32 norm_pai;\n\n\tif (!spz->info->powercap_pai_config)\n\t\treturn -EINVAL;\n\n\tscmi_powercap_normalize_time(spz, time_window_us, &norm_pai);\n\n\treturn powercap_ops->pai_set(spz->ph, spz->info->id, norm_pai);\n}\n\nstatic int scmi_powercap_get_time_window_us(struct powercap_zone *pz, int cid,\n\t\t\t\t\t    u64 *time_window_us)\n{\n\tstruct scmi_powercap_zone *spz = to_scmi_powercap_zone(pz);\n\tint ret;\n\tu32 pai;\n\n\tret = powercap_ops->pai_get(spz->ph, spz->info->id, &pai);\n\tif (ret)\n\t\treturn ret;\n\n\t*time_window_us = pai;\n\n\treturn 0;\n}\n\nstatic int scmi_powercap_get_max_power_uw(struct powercap_zone *pz, int cid,\n\t\t\t\t\t  u64 *max_power_uw)\n{\n\tstruct scmi_powercap_zone *spz = to_scmi_powercap_zone(pz);\n\n\t*max_power_uw = spz->info->max_power_cap;\n\tif (spz->info->powercap_scale_mw)\n\t\t*max_power_uw *= 1000;\n\n\treturn 0;\n}\n\nstatic int scmi_powercap_get_min_power_uw(struct powercap_zone *pz, int cid,\n\t\t\t\t\t  u64 *min_power_uw)\n{\n\tstruct scmi_powercap_zone *spz = to_scmi_powercap_zone(pz);\n\n\t*min_power_uw = spz->info->min_power_cap;\n\tif (spz->info->powercap_scale_mw)\n\t\t*min_power_uw *= 1000;\n\n\treturn 0;\n}\n\nstatic int scmi_powercap_get_max_time_window_us(struct powercap_zone *pz,\n\t\t\t\t\t\tint cid, u64 *time_window_us)\n{\n\tstruct scmi_powercap_zone *spz = to_scmi_powercap_zone(pz);\n\n\t*time_window_us = spz->info->max_pai;\n\n\treturn 0;\n}\n\nstatic int scmi_powercap_get_min_time_window_us(struct powercap_zone *pz,\n\t\t\t\t\t\tint cid, u64 *time_window_us)\n{\n\tstruct scmi_powercap_zone *spz = to_scmi_powercap_zone(pz);\n\n\t*time_window_us = (u64)spz->info->min_pai;\n\n\treturn 0;\n}\n\nstatic const char *scmi_powercap_get_name(struct powercap_zone *pz, int cid)\n{\n\treturn \"SCMI power-cap\";\n}\n\nstatic const struct powercap_zone_constraint_ops constraint_ops  = {\n\t.set_power_limit_uw = scmi_powercap_set_power_limit_uw,\n\t.get_power_limit_uw = scmi_powercap_get_power_limit_uw,\n\t.set_time_window_us = scmi_powercap_set_time_window_us,\n\t.get_time_window_us = scmi_powercap_get_time_window_us,\n\t.get_max_power_uw = scmi_powercap_get_max_power_uw,\n\t.get_min_power_uw = scmi_powercap_get_min_power_uw,\n\t.get_max_time_window_us = scmi_powercap_get_max_time_window_us,\n\t.get_min_time_window_us = scmi_powercap_get_min_time_window_us,\n\t.get_name = scmi_powercap_get_name,\n};\n\nstatic void scmi_powercap_unregister_all_zones(struct scmi_powercap_root *pr)\n{\n\tint i;\n\n\t \n\tfor (i = pr->num_zones - 1; i >= 0; i--) {\n\t\tif (!list_empty(&pr->registered_zones[i])) {\n\t\t\tstruct scmi_powercap_zone *spz;\n\n\t\t\tlist_for_each_entry(spz, &pr->registered_zones[i], node)\n\t\t\t\tpowercap_unregister_zone(scmi_top_pcntrl,\n\t\t\t\t\t\t\t &spz->zone);\n\t\t}\n\t}\n}\n\nstatic inline unsigned int\nscmi_powercap_get_zone_height(struct scmi_powercap_zone *spz)\n{\n\tif (spz->info->parent_id == SCMI_POWERCAP_ROOT_ZONE_ID)\n\t\treturn 0;\n\n\treturn spz->spzones[spz->info->parent_id].height + 1;\n}\n\nstatic inline struct scmi_powercap_zone *\nscmi_powercap_get_parent_zone(struct scmi_powercap_zone *spz)\n{\n\tif (spz->info->parent_id == SCMI_POWERCAP_ROOT_ZONE_ID)\n\t\treturn NULL;\n\n\treturn &spz->spzones[spz->info->parent_id];\n}\n\nstatic int scmi_powercap_register_zone(struct scmi_powercap_root *pr,\n\t\t\t\t       struct scmi_powercap_zone *spz,\n\t\t\t\t       struct scmi_powercap_zone *parent)\n{\n\tint ret = 0;\n\tstruct powercap_zone *z;\n\n\tif (spz->invalid) {\n\t\tlist_del(&spz->node);\n\t\treturn -EINVAL;\n\t}\n\n\tz = powercap_register_zone(&spz->zone, scmi_top_pcntrl, spz->info->name,\n\t\t\t\t   parent ? &parent->zone : NULL,\n\t\t\t\t   &zone_ops, 1, &constraint_ops);\n\tif (!IS_ERR(z)) {\n\t\tspz->height = scmi_powercap_get_zone_height(spz);\n\t\tspz->registered = true;\n\t\tlist_move(&spz->node, &pr->registered_zones[spz->height]);\n\t\tdev_dbg(spz->dev, \"Registered node %s - parent %s - height:%d\\n\",\n\t\t\tspz->info->name, parent ? parent->info->name : \"ROOT\",\n\t\t\tspz->height);\n\t} else {\n\t\tlist_del(&spz->node);\n\t\tret = PTR_ERR(z);\n\t\tdev_err(spz->dev,\n\t\t\t\"Error registering node:%s - parent:%s - h:%d - ret:%d\\n\",\n\t\t\tspz->info->name,\n\t\t\tparent ? parent->info->name : \"ROOT\",\n\t\t\tspz->height, ret);\n\t}\n\n\treturn ret;\n}\n\n \nstatic int scmi_zones_register(struct device *dev,\n\t\t\t       struct scmi_powercap_root *pr)\n{\n\tint ret = 0;\n\tunsigned int sp = 0, reg_zones = 0;\n\tstruct scmi_powercap_zone *spz, **zones_stack;\n\n\tzones_stack = kcalloc(pr->num_zones, sizeof(spz), GFP_KERNEL);\n\tif (!zones_stack)\n\t\treturn -ENOMEM;\n\n\tspz = list_first_entry_or_null(&pr->scmi_zones,\n\t\t\t\t       struct scmi_powercap_zone, node);\n\twhile (spz) {\n\t\tstruct scmi_powercap_zone *parent;\n\n\t\tparent = scmi_powercap_get_parent_zone(spz);\n\t\tif (parent && !parent->registered) {\n\t\t\tzones_stack[sp++] = spz;\n\t\t\tspz = parent;\n\t\t} else {\n\t\t\tret = scmi_powercap_register_zone(pr, spz, parent);\n\t\t\tif (!ret) {\n\t\t\t\treg_zones++;\n\t\t\t} else if (sp) {\n\t\t\t\t \n\t\t\t\tdev_err(dev,\n\t\t\t\t\t\"Failed to register non-leaf zone - ret:%d\\n\",\n\t\t\t\t\tret);\n\t\t\t\tscmi_powercap_unregister_all_zones(pr);\n\t\t\t\treg_zones = 0;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\t \n\t\t\tif (sp)\n\t\t\t\tspz = zones_stack[--sp];\n\t\t\telse\n\t\t\t\tspz = list_first_entry_or_null(&pr->scmi_zones,\n\t\t\t\t\t\t\t       struct scmi_powercap_zone,\n\t\t\t\t\t\t\t       node);\n\t\t}\n\t}\n\nout:\n\tkfree(zones_stack);\n\tdev_info(dev, \"Registered %d SCMI Powercap domains !\\n\", reg_zones);\n\n\treturn ret;\n}\n\nstatic int scmi_powercap_probe(struct scmi_device *sdev)\n{\n\tint ret, i;\n\tstruct scmi_powercap_root *pr;\n\tstruct scmi_powercap_zone *spz;\n\tstruct scmi_protocol_handle *ph;\n\tstruct device *dev = &sdev->dev;\n\n\tif (!sdev->handle)\n\t\treturn -ENODEV;\n\n\tpowercap_ops = sdev->handle->devm_protocol_get(sdev,\n\t\t\t\t\t\t       SCMI_PROTOCOL_POWERCAP,\n\t\t\t\t\t\t       &ph);\n\tif (IS_ERR(powercap_ops))\n\t\treturn PTR_ERR(powercap_ops);\n\n\tpr = devm_kzalloc(dev, sizeof(*pr), GFP_KERNEL);\n\tif (!pr)\n\t\treturn -ENOMEM;\n\n\tret = powercap_ops->num_domains_get(ph);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"number of powercap domains not found\\n\");\n\t\treturn ret;\n\t}\n\tpr->num_zones = ret;\n\n\tpr->spzones = devm_kcalloc(dev, pr->num_zones,\n\t\t\t\t   sizeof(*pr->spzones), GFP_KERNEL);\n\tif (!pr->spzones)\n\t\treturn -ENOMEM;\n\n\t \n\tpr->registered_zones = devm_kcalloc(dev, pr->num_zones,\n\t\t\t\t\t    sizeof(*pr->registered_zones),\n\t\t\t\t\t    GFP_KERNEL);\n\tif (!pr->registered_zones)\n\t\treturn -ENOMEM;\n\n\tINIT_LIST_HEAD(&pr->scmi_zones);\n\n\tfor (i = 0, spz = pr->spzones; i < pr->num_zones; i++, spz++) {\n\t\t \n\t\tspz->info = powercap_ops->info_get(ph, i);\n\n\t\tspz->dev = dev;\n\t\tspz->ph = ph;\n\t\tspz->spzones = pr->spzones;\n\t\tINIT_LIST_HEAD(&spz->node);\n\t\tINIT_LIST_HEAD(&pr->registered_zones[i]);\n\n\t\tlist_add_tail(&spz->node, &pr->scmi_zones);\n\t\t \n\t\tif (!spz->info->powercap_scale_uw &&\n\t\t    !spz->info->powercap_scale_mw) {\n\t\t\tdev_warn(dev,\n\t\t\t\t \"Abstract power scale not supported. Skip %s.\\n\",\n\t\t\t\t spz->info->name);\n\t\t\tspz->invalid = true;\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\t \n\tret = scmi_zones_register(dev, pr);\n\tif (ret)\n\t\treturn ret;\n\n\tdev_set_drvdata(dev, pr);\n\n\treturn ret;\n}\n\nstatic void scmi_powercap_remove(struct scmi_device *sdev)\n{\n\tstruct device *dev = &sdev->dev;\n\tstruct scmi_powercap_root *pr = dev_get_drvdata(dev);\n\n\tscmi_powercap_unregister_all_zones(pr);\n}\n\nstatic const struct scmi_device_id scmi_id_table[] = {\n\t{ SCMI_PROTOCOL_POWERCAP, \"powercap\" },\n\t{ },\n};\nMODULE_DEVICE_TABLE(scmi, scmi_id_table);\n\nstatic struct scmi_driver scmi_powercap_driver = {\n\t.name = \"scmi-powercap\",\n\t.probe = scmi_powercap_probe,\n\t.remove = scmi_powercap_remove,\n\t.id_table = scmi_id_table,\n};\n\nstatic int __init scmi_powercap_init(void)\n{\n\tint ret;\n\n\tscmi_top_pcntrl = powercap_register_control_type(NULL, \"arm-scmi\", NULL);\n\tif (IS_ERR(scmi_top_pcntrl))\n\t\treturn PTR_ERR(scmi_top_pcntrl);\n\n\tret = scmi_register(&scmi_powercap_driver);\n\tif (ret)\n\t\tpowercap_unregister_control_type(scmi_top_pcntrl);\n\n\treturn ret;\n}\nmodule_init(scmi_powercap_init);\n\nstatic void __exit scmi_powercap_exit(void)\n{\n\tscmi_unregister(&scmi_powercap_driver);\n\n\tpowercap_unregister_control_type(scmi_top_pcntrl);\n}\nmodule_exit(scmi_powercap_exit);\n\nMODULE_AUTHOR(\"Cristian Marussi <cristian.marussi@arm.com>\");\nMODULE_DESCRIPTION(\"ARM SCMI Powercap driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}