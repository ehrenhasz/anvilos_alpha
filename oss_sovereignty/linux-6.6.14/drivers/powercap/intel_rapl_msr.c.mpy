{
  "module_name": "intel_rapl_msr.c",
  "hash_id": "372995a7b2e1181907677da411d7b46ba3f3847fe983bc0936d421007f1a44b0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/powercap/intel_rapl_msr.c",
  "human_readable_source": "\n \n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/list.h>\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/slab.h>\n#include <linux/log2.h>\n#include <linux/bitmap.h>\n#include <linux/delay.h>\n#include <linux/sysfs.h>\n#include <linux/cpu.h>\n#include <linux/powercap.h>\n#include <linux/suspend.h>\n#include <linux/intel_rapl.h>\n#include <linux/processor.h>\n#include <linux/platform_device.h>\n\n#include <asm/cpu_device_id.h>\n#include <asm/intel-family.h>\n\n \n#define MSR_PLATFORM_POWER_LIMIT\t0x0000065C\n#define MSR_VR_CURRENT_CONFIG\t\t0x00000601\n\n \nstatic struct rapl_if_priv *rapl_msr_priv;\n\nstatic struct rapl_if_priv rapl_msr_priv_intel = {\n\t.type = RAPL_IF_MSR,\n\t.reg_unit.msr = MSR_RAPL_POWER_UNIT,\n\t.regs[RAPL_DOMAIN_PACKAGE][RAPL_DOMAIN_REG_LIMIT].msr\t= MSR_PKG_POWER_LIMIT,\n\t.regs[RAPL_DOMAIN_PACKAGE][RAPL_DOMAIN_REG_STATUS].msr\t= MSR_PKG_ENERGY_STATUS,\n\t.regs[RAPL_DOMAIN_PACKAGE][RAPL_DOMAIN_REG_PERF].msr\t= MSR_PKG_PERF_STATUS,\n\t.regs[RAPL_DOMAIN_PACKAGE][RAPL_DOMAIN_REG_INFO].msr\t= MSR_PKG_POWER_INFO,\n\t.regs[RAPL_DOMAIN_PP0][RAPL_DOMAIN_REG_LIMIT].msr\t= MSR_PP0_POWER_LIMIT,\n\t.regs[RAPL_DOMAIN_PP0][RAPL_DOMAIN_REG_STATUS].msr\t= MSR_PP0_ENERGY_STATUS,\n\t.regs[RAPL_DOMAIN_PP0][RAPL_DOMAIN_REG_POLICY].msr\t= MSR_PP0_POLICY,\n\t.regs[RAPL_DOMAIN_PP1][RAPL_DOMAIN_REG_LIMIT].msr\t= MSR_PP1_POWER_LIMIT,\n\t.regs[RAPL_DOMAIN_PP1][RAPL_DOMAIN_REG_STATUS].msr\t= MSR_PP1_ENERGY_STATUS,\n\t.regs[RAPL_DOMAIN_PP1][RAPL_DOMAIN_REG_POLICY].msr\t= MSR_PP1_POLICY,\n\t.regs[RAPL_DOMAIN_DRAM][RAPL_DOMAIN_REG_LIMIT].msr\t= MSR_DRAM_POWER_LIMIT,\n\t.regs[RAPL_DOMAIN_DRAM][RAPL_DOMAIN_REG_STATUS].msr\t= MSR_DRAM_ENERGY_STATUS,\n\t.regs[RAPL_DOMAIN_DRAM][RAPL_DOMAIN_REG_PERF].msr\t= MSR_DRAM_PERF_STATUS,\n\t.regs[RAPL_DOMAIN_DRAM][RAPL_DOMAIN_REG_INFO].msr\t= MSR_DRAM_POWER_INFO,\n\t.regs[RAPL_DOMAIN_PLATFORM][RAPL_DOMAIN_REG_LIMIT].msr\t= MSR_PLATFORM_POWER_LIMIT,\n\t.regs[RAPL_DOMAIN_PLATFORM][RAPL_DOMAIN_REG_STATUS].msr\t= MSR_PLATFORM_ENERGY_STATUS,\n\t.limits[RAPL_DOMAIN_PACKAGE] = BIT(POWER_LIMIT2),\n\t.limits[RAPL_DOMAIN_PLATFORM] = BIT(POWER_LIMIT2),\n};\n\nstatic struct rapl_if_priv rapl_msr_priv_amd = {\n\t.type = RAPL_IF_MSR,\n\t.reg_unit.msr = MSR_AMD_RAPL_POWER_UNIT,\n\t.regs[RAPL_DOMAIN_PACKAGE][RAPL_DOMAIN_REG_STATUS].msr\t= MSR_AMD_PKG_ENERGY_STATUS,\n\t.regs[RAPL_DOMAIN_PP0][RAPL_DOMAIN_REG_STATUS].msr\t= MSR_AMD_CORE_ENERGY_STATUS,\n};\n\n \nstatic int rapl_cpu_online(unsigned int cpu)\n{\n\tstruct rapl_package *rp;\n\n\trp = rapl_find_package_domain(cpu, rapl_msr_priv, true);\n\tif (!rp) {\n\t\trp = rapl_add_package(cpu, rapl_msr_priv, true);\n\t\tif (IS_ERR(rp))\n\t\t\treturn PTR_ERR(rp);\n\t}\n\tcpumask_set_cpu(cpu, &rp->cpumask);\n\treturn 0;\n}\n\nstatic int rapl_cpu_down_prep(unsigned int cpu)\n{\n\tstruct rapl_package *rp;\n\tint lead_cpu;\n\n\trp = rapl_find_package_domain(cpu, rapl_msr_priv, true);\n\tif (!rp)\n\t\treturn 0;\n\n\tcpumask_clear_cpu(cpu, &rp->cpumask);\n\tlead_cpu = cpumask_first(&rp->cpumask);\n\tif (lead_cpu >= nr_cpu_ids)\n\t\trapl_remove_package(rp);\n\telse if (rp->lead_cpu == cpu)\n\t\trp->lead_cpu = lead_cpu;\n\treturn 0;\n}\n\nstatic int rapl_msr_read_raw(int cpu, struct reg_action *ra)\n{\n\tif (rdmsrl_safe_on_cpu(cpu, ra->reg.msr, &ra->value)) {\n\t\tpr_debug(\"failed to read msr 0x%x on cpu %d\\n\", ra->reg.msr, cpu);\n\t\treturn -EIO;\n\t}\n\tra->value &= ra->mask;\n\treturn 0;\n}\n\nstatic void rapl_msr_update_func(void *info)\n{\n\tstruct reg_action *ra = info;\n\tu64 val;\n\n\tra->err = rdmsrl_safe(ra->reg.msr, &val);\n\tif (ra->err)\n\t\treturn;\n\n\tval &= ~ra->mask;\n\tval |= ra->value;\n\n\tra->err = wrmsrl_safe(ra->reg.msr, val);\n}\n\nstatic int rapl_msr_write_raw(int cpu, struct reg_action *ra)\n{\n\tint ret;\n\n\tret = smp_call_function_single(cpu, rapl_msr_update_func, ra, 1);\n\tif (WARN_ON_ONCE(ret))\n\t\treturn ret;\n\n\treturn ra->err;\n}\n\n \nstatic const struct x86_cpu_id pl4_support_ids[] = {\n\tX86_MATCH_INTEL_FAM6_MODEL(TIGERLAKE_L, NULL),\n\tX86_MATCH_INTEL_FAM6_MODEL(ALDERLAKE, NULL),\n\tX86_MATCH_INTEL_FAM6_MODEL(ALDERLAKE_L, NULL),\n\tX86_MATCH_INTEL_FAM6_MODEL(ATOM_GRACEMONT, NULL),\n\tX86_MATCH_INTEL_FAM6_MODEL(RAPTORLAKE, NULL),\n\tX86_MATCH_INTEL_FAM6_MODEL(RAPTORLAKE_P, NULL),\n\tX86_MATCH_INTEL_FAM6_MODEL(METEORLAKE, NULL),\n\tX86_MATCH_INTEL_FAM6_MODEL(METEORLAKE_L, NULL),\n\t{}\n};\n\nstatic int rapl_msr_probe(struct platform_device *pdev)\n{\n\tconst struct x86_cpu_id *id = x86_match_cpu(pl4_support_ids);\n\tint ret;\n\n\tswitch (boot_cpu_data.x86_vendor) {\n\tcase X86_VENDOR_INTEL:\n\t\trapl_msr_priv = &rapl_msr_priv_intel;\n\t\tbreak;\n\tcase X86_VENDOR_HYGON:\n\tcase X86_VENDOR_AMD:\n\t\trapl_msr_priv = &rapl_msr_priv_amd;\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"intel-rapl does not support CPU vendor %d\\n\", boot_cpu_data.x86_vendor);\n\t\treturn -ENODEV;\n\t}\n\trapl_msr_priv->read_raw = rapl_msr_read_raw;\n\trapl_msr_priv->write_raw = rapl_msr_write_raw;\n\n\tif (id) {\n\t\trapl_msr_priv->limits[RAPL_DOMAIN_PACKAGE] |= BIT(POWER_LIMIT4);\n\t\trapl_msr_priv->regs[RAPL_DOMAIN_PACKAGE][RAPL_DOMAIN_REG_PL4].msr =\n\t\t\tMSR_VR_CURRENT_CONFIG;\n\t\tpr_info(\"PL4 support detected.\\n\");\n\t}\n\n\trapl_msr_priv->control_type = powercap_register_control_type(NULL, \"intel-rapl\", NULL);\n\tif (IS_ERR(rapl_msr_priv->control_type)) {\n\t\tpr_debug(\"failed to register powercap control_type.\\n\");\n\t\treturn PTR_ERR(rapl_msr_priv->control_type);\n\t}\n\n\tret = cpuhp_setup_state(CPUHP_AP_ONLINE_DYN, \"powercap/rapl:online\",\n\t\t\t\trapl_cpu_online, rapl_cpu_down_prep);\n\tif (ret < 0)\n\t\tgoto out;\n\trapl_msr_priv->pcap_rapl_online = ret;\n\n\treturn 0;\n\nout:\n\tif (ret)\n\t\tpowercap_unregister_control_type(rapl_msr_priv->control_type);\n\treturn ret;\n}\n\nstatic int rapl_msr_remove(struct platform_device *pdev)\n{\n\tcpuhp_remove_state(rapl_msr_priv->pcap_rapl_online);\n\tpowercap_unregister_control_type(rapl_msr_priv->control_type);\n\treturn 0;\n}\n\nstatic const struct platform_device_id rapl_msr_ids[] = {\n\t{ .name = \"intel_rapl_msr\", },\n\t{}\n};\nMODULE_DEVICE_TABLE(platform, rapl_msr_ids);\n\nstatic struct platform_driver intel_rapl_msr_driver = {\n\t.probe = rapl_msr_probe,\n\t.remove = rapl_msr_remove,\n\t.id_table = rapl_msr_ids,\n\t.driver = {\n\t\t.name = \"intel_rapl_msr\",\n\t},\n};\n\nmodule_platform_driver(intel_rapl_msr_driver);\n\nMODULE_DESCRIPTION(\"Driver for Intel RAPL (Running Average Power Limit) control via MSR interface\");\nMODULE_AUTHOR(\"Zhang Rui <rui.zhang@intel.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}