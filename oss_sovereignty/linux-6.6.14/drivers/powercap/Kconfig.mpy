{
  "module_name": "Kconfig",
  "hash_id": "93a27c25c9a87918cfdaca82125d71bd5f687d7f37ce3f418cab6dd5e208ab23",
  "original_prompt": "Ingested from linux-6.6.14/drivers/powercap/Kconfig",
  "human_readable_source": "# SPDX-License-Identifier: GPL-2.0-only\n#\n# Generic power capping sysfs interface configuration\n#\n\nmenuconfig POWERCAP\n\tbool \"Generic powercap sysfs driver\"\n\thelp\n\t  The power capping sysfs interface allows kernel subsystems to expose power\n\t  capping settings to user space in a consistent way.  Usually, it consists\n\t  of multiple control types that determine which settings may be exposed and\n\t  power zones representing parts of the system that can be subject to power\n\t  capping.\n\n\t  If you want this code to be compiled in, say Y here.\n\nif POWERCAP\n# Client driver configurations go here.\nconfig INTEL_RAPL_CORE\n\ttristate\n\tdepends on PCI\n\tselect IOSF_MBI\n\nconfig INTEL_RAPL\n\ttristate \"Intel RAPL Support via MSR Interface\"\n\tdepends on X86 && PCI\n\tselect INTEL_RAPL_CORE\n\thelp\n\t  This enables support for the Intel Running Average Power Limit (RAPL)\n\t  technology via MSR interface, which allows power limits to be enforced\n\t  and monitored on modern Intel processors (Sandy Bridge and later).\n\n\t  In RAPL, the platform level settings are divided into domains for\n\t  fine grained control. These domains include processor package, DRAM\n\t  controller, CPU core (Power Plane 0), graphics uncore (Power Plane\n\t  1), etc.\n\nconfig INTEL_RAPL_TPMI\n\ttristate \"Intel RAPL Support via TPMI Interface\"\n\tdepends on X86\n\tdepends on INTEL_TPMI\n\tselect INTEL_RAPL_CORE\n\thelp\n\t  This enables support for the Intel Running Average Power Limit (RAPL)\n\t  technology via TPMI interface, which allows power limits to be enforced\n\t  and monitored.\n\n\t  In RAPL, the platform level settings are divided into domains for\n\t  fine grained control. These domains include processor package, DRAM\n\t  controller, platform, etc.\n\nconfig IDLE_INJECT\n\tbool \"Idle injection framework\"\n\tdepends on CPU_IDLE\n\tdefault n\n\thelp\n\t  This enables support for the idle injection framework. It\n\t  provides a way to force idle periods on a set of specified\n\t  CPUs for power capping. Idle period can be injected\n\t  synchronously on a set of specified CPUs or alternatively\n\t  on a per CPU basis.\n\nconfig ARM_SCMI_POWERCAP\n\ttristate \"ARM SCMI Powercap driver\"\n\tdepends on ARM_SCMI_PROTOCOL\n\thelp\n\t  This enables support for the ARM Powercap based on ARM SCMI\n\t  Powercap protocol.\n\n\t  ARM SCMI Powercap protocol allows power limits to be enforced\n\t  and monitored against the SCMI Powercap domains advertised as\n\t  available by the SCMI platform firmware.\n\n\t  When compiled as module it will be called arm_scmi_powercap.ko.\n\nconfig DTPM\n\tbool \"Power capping for Dynamic Thermal Power Management (EXPERIMENTAL)\"\n\tdepends on OF\n\thelp\n\t  This enables support for the power capping for the dynamic\n\t  thermal power management userspace engine.\n\nconfig DTPM_CPU\n\tbool \"Add CPU power capping based on the energy model\"\n\tdepends on DTPM && ENERGY_MODEL\n\thelp\n\t  This enables support for CPU power limitation based on\n\t  energy model.\n\nconfig DTPM_DEVFREQ\n\tbool \"Add device power capping based on the energy model\"\n\tdepends on DTPM && ENERGY_MODEL\n\thelp\n\t  This enables support for device power limitation based on\n\t  energy model.\nendif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}