{
  "module_name": "nftlcore.c",
  "hash_id": "71bb3ab2d94975e0e0a3dd0db0eb19016a60e8d1cf1ff994e232bb89d0555052",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/nftlcore.c",
  "human_readable_source": "\n \n\n#define PRERELEASE\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <asm/errno.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hdreg.h>\n#include <linux/blkdev.h>\n\n#include <linux/kmod.h>\n#include <linux/mtd/mtd.h>\n#include <linux/mtd/rawnand.h>\n#include <linux/mtd/nftl.h>\n#include <linux/mtd/blktrans.h>\n\n \n\n#define MAX_LOOPS 10000\n\n\nstatic void nftl_add_mtd(struct mtd_blktrans_ops *tr, struct mtd_info *mtd)\n{\n\tstruct NFTLrecord *nftl;\n\tunsigned long temp;\n\n\tif (!mtd_type_is_nand(mtd) || mtd->size > UINT_MAX)\n\t\treturn;\n\t \n\tif (memcmp(mtd->name, \"DiskOnChip\", 10))\n\t\treturn;\n\n\tpr_debug(\"NFTL: add_mtd for %s\\n\", mtd->name);\n\n\tnftl = kzalloc(sizeof(struct NFTLrecord), GFP_KERNEL);\n\n\tif (!nftl)\n\t\treturn;\n\n\tnftl->mbd.mtd = mtd;\n\tnftl->mbd.devnum = -1;\n\n\tnftl->mbd.tr = tr;\n\n        if (NFTL_mount(nftl) < 0) {\n\t\tprintk(KERN_WARNING \"NFTL: could not mount device\\n\");\n\t\tkfree(nftl);\n\t\treturn;\n        }\n\n\t \n\n\t \n\tnftl->cylinders = 1024;\n\tnftl->heads = 16;\n\n\ttemp = nftl->cylinders * nftl->heads;\n\tnftl->sectors = nftl->mbd.size / temp;\n\tif (nftl->mbd.size % temp) {\n\t\tnftl->sectors++;\n\t\ttemp = nftl->cylinders * nftl->sectors;\n\t\tnftl->heads = nftl->mbd.size / temp;\n\n\t\tif (nftl->mbd.size % temp) {\n\t\t\tnftl->heads++;\n\t\t\ttemp = nftl->heads * nftl->sectors;\n\t\t\tnftl->cylinders = nftl->mbd.size / temp;\n\t\t}\n\t}\n\n\tif (nftl->mbd.size != nftl->heads * nftl->cylinders * nftl->sectors) {\n\t\t \n\t\tprintk(KERN_WARNING \"NFTL: cannot calculate a geometry to \"\n\t\t       \"match size of 0x%lx.\\n\", nftl->mbd.size);\n\t\tprintk(KERN_WARNING \"NFTL: using C:%d H:%d S:%d \"\n\t\t\t\"(== 0x%lx sects)\\n\",\n\t\t\tnftl->cylinders, nftl->heads , nftl->sectors,\n\t\t\t(long)nftl->cylinders * (long)nftl->heads *\n\t\t\t(long)nftl->sectors );\n\t}\n\n\tif (add_mtd_blktrans_dev(&nftl->mbd)) {\n\t\tkfree(nftl->ReplUnitTable);\n\t\tkfree(nftl->EUNtable);\n\t\tkfree(nftl);\n\t\treturn;\n\t}\n#ifdef PSYCHO_DEBUG\n\tprintk(KERN_INFO \"NFTL: Found new nftl%c\\n\", nftl->mbd.devnum + 'a');\n#endif\n}\n\nstatic void nftl_remove_dev(struct mtd_blktrans_dev *dev)\n{\n\tstruct NFTLrecord *nftl = (void *)dev;\n\n\tpr_debug(\"NFTL: remove_dev (i=%d)\\n\", dev->devnum);\n\n\tdel_mtd_blktrans_dev(dev);\n\tkfree(nftl->ReplUnitTable);\n\tkfree(nftl->EUNtable);\n}\n\n \nint nftl_read_oob(struct mtd_info *mtd, loff_t offs, size_t len,\n\t\t  size_t *retlen, uint8_t *buf)\n{\n\tloff_t mask = mtd->writesize - 1;\n\tstruct mtd_oob_ops ops = { };\n\tint res;\n\n\tops.mode = MTD_OPS_PLACE_OOB;\n\tops.ooboffs = offs & mask;\n\tops.ooblen = len;\n\tops.oobbuf = buf;\n\tops.datbuf = NULL;\n\n\tres = mtd_read_oob(mtd, offs & ~mask, &ops);\n\t*retlen = ops.oobretlen;\n\treturn res;\n}\n\n \nint nftl_write_oob(struct mtd_info *mtd, loff_t offs, size_t len,\n\t\t   size_t *retlen, uint8_t *buf)\n{\n\tloff_t mask = mtd->writesize - 1;\n\tstruct mtd_oob_ops ops = { };\n\tint res;\n\n\tops.mode = MTD_OPS_PLACE_OOB;\n\tops.ooboffs = offs & mask;\n\tops.ooblen = len;\n\tops.oobbuf = buf;\n\tops.datbuf = NULL;\n\n\tres = mtd_write_oob(mtd, offs & ~mask, &ops);\n\t*retlen = ops.oobretlen;\n\treturn res;\n}\n\n#ifdef CONFIG_NFTL_RW\n\n \nstatic int nftl_write(struct mtd_info *mtd, loff_t offs, size_t len,\n\t\t      size_t *retlen, uint8_t *buf, uint8_t *oob)\n{\n\tloff_t mask = mtd->writesize - 1;\n\tstruct mtd_oob_ops ops = { };\n\tint res;\n\n\tops.mode = MTD_OPS_PLACE_OOB;\n\tops.ooboffs = offs & mask;\n\tops.ooblen = mtd->oobsize;\n\tops.oobbuf = oob;\n\tops.datbuf = buf;\n\tops.len = len;\n\n\tres = mtd_write_oob(mtd, offs & ~mask, &ops);\n\t*retlen = ops.retlen;\n\treturn res;\n}\n\n \n \nstatic u16 NFTL_findfreeblock(struct NFTLrecord *nftl, int desperate )\n{\n\t \n\t \n\tu16 pot = nftl->LastFreeEUN;\n\tint silly = nftl->nb_blocks;\n\n\t \n\tif (!desperate && nftl->numfreeEUNs < 2) {\n\t\tpr_debug(\"NFTL_findfreeblock: there are too few free EUNs\\n\");\n\t\treturn BLOCK_NIL;\n\t}\n\n\t \n\tdo {\n\t\tif (nftl->ReplUnitTable[pot] == BLOCK_FREE) {\n\t\t\tnftl->LastFreeEUN = pot;\n\t\t\tnftl->numfreeEUNs--;\n\t\t\treturn pot;\n\t\t}\n\n\t\t \n\t\tif (++pot > nftl->lastEUN)\n\t\t\tpot = le16_to_cpu(nftl->MediaHdr.FirstPhysicalEUN);\n\n\t\tif (!silly--) {\n\t\t\tprintk(\"Argh! No free blocks found! LastFreeEUN = %d, \"\n\t\t\t       \"FirstEUN = %d\\n\", nftl->LastFreeEUN,\n\t\t\t       le16_to_cpu(nftl->MediaHdr.FirstPhysicalEUN));\n\t\t\treturn BLOCK_NIL;\n\t\t}\n\t} while (pot != nftl->LastFreeEUN);\n\n\treturn BLOCK_NIL;\n}\n\nstatic u16 NFTL_foldchain (struct NFTLrecord *nftl, unsigned thisVUC, unsigned pendingblock )\n{\n\tstruct mtd_info *mtd = nftl->mbd.mtd;\n\tu16 BlockMap[MAX_SECTORS_PER_UNIT];\n\tunsigned char BlockLastState[MAX_SECTORS_PER_UNIT];\n\tunsigned char BlockFreeFound[MAX_SECTORS_PER_UNIT];\n\tunsigned int thisEUN;\n\tint block;\n\tint silly;\n\tunsigned int targetEUN;\n\tstruct nftl_oob oob;\n\tint inplace = 1;\n\tsize_t retlen;\n\n\tmemset(BlockMap, 0xff, sizeof(BlockMap));\n\tmemset(BlockFreeFound, 0, sizeof(BlockFreeFound));\n\n\tthisEUN = nftl->EUNtable[thisVUC];\n\n\tif (thisEUN == BLOCK_NIL) {\n\t\tprintk(KERN_WARNING \"Trying to fold non-existent \"\n\t\t       \"Virtual Unit Chain %d!\\n\", thisVUC);\n\t\treturn BLOCK_NIL;\n\t}\n\n\t \n\tsilly = MAX_LOOPS;\n\ttargetEUN = BLOCK_NIL;\n\twhile (thisEUN <= nftl->lastEUN ) {\n\t\tunsigned int status, foldmark;\n\n\t\ttargetEUN = thisEUN;\n\t\tfor (block = 0; block < nftl->EraseSize / 512; block ++) {\n\t\t\tnftl_read_oob(mtd, (thisEUN * nftl->EraseSize) +\n\t\t\t\t      (block * 512), 16 , &retlen,\n\t\t\t\t      (char *)&oob);\n\t\t\tif (block == 2) {\n\t\t\t\tfoldmark = oob.u.c.FoldMark | oob.u.c.FoldMark1;\n\t\t\t\tif (foldmark == FOLD_MARK_IN_PROGRESS) {\n\t\t\t\t\tpr_debug(\"Write Inhibited on EUN %d\\n\", thisEUN);\n\t\t\t\t\tinplace = 0;\n\t\t\t\t} else {\n\t\t\t\t\t \n\t\t\t\t\tinplace = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tstatus = oob.b.Status | oob.b.Status1;\n\t\t\tBlockLastState[block] = status;\n\n\t\t\tswitch(status) {\n\t\t\tcase SECTOR_FREE:\n\t\t\t\tBlockFreeFound[block] = 1;\n\t\t\t\tbreak;\n\n\t\t\tcase SECTOR_USED:\n\t\t\t\tif (!BlockFreeFound[block])\n\t\t\t\t\tBlockMap[block] = thisEUN;\n\t\t\t\telse\n\t\t\t\t\tprintk(KERN_WARNING\n\t\t\t\t\t       \"SECTOR_USED found after SECTOR_FREE \"\n\t\t\t\t\t       \"in Virtual Unit Chain %d for block %d\\n\",\n\t\t\t\t\t       thisVUC, block);\n\t\t\t\tbreak;\n\t\t\tcase SECTOR_DELETED:\n\t\t\t\tif (!BlockFreeFound[block])\n\t\t\t\t\tBlockMap[block] = BLOCK_NIL;\n\t\t\t\telse\n\t\t\t\t\tprintk(KERN_WARNING\n\t\t\t\t\t       \"SECTOR_DELETED found after SECTOR_FREE \"\n\t\t\t\t\t       \"in Virtual Unit Chain %d for block %d\\n\",\n\t\t\t\t\t       thisVUC, block);\n\t\t\t\tbreak;\n\n\t\t\tcase SECTOR_IGNORE:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tprintk(\"Unknown status for block %d in EUN %d: %x\\n\",\n\t\t\t\t       block, thisEUN, status);\n\t\t\t}\n\t\t}\n\n\t\tif (!silly--) {\n\t\t\tprintk(KERN_WARNING \"Infinite loop in Virtual Unit Chain 0x%x\\n\",\n\t\t\t       thisVUC);\n\t\t\treturn BLOCK_NIL;\n\t\t}\n\n\t\tthisEUN = nftl->ReplUnitTable[thisEUN];\n\t}\n\n\tif (inplace) {\n\t\t \n\t\tfor (block = 0; block < nftl->EraseSize / 512 ; block++) {\n\t\t\tif (BlockLastState[block] != SECTOR_FREE &&\n\t\t\t    BlockMap[block] != BLOCK_NIL &&\n\t\t\t    BlockMap[block] != targetEUN) {\n\t\t\t\tpr_debug(\"Setting inplace to 0. VUC %d, \"\n\t\t\t\t      \"block %d was %x lastEUN, \"\n\t\t\t\t      \"and is in EUN %d (%s) %d\\n\",\n\t\t\t\t      thisVUC, block, BlockLastState[block],\n\t\t\t\t      BlockMap[block],\n\t\t\t\t      BlockMap[block]== targetEUN ? \"==\" : \"!=\",\n\t\t\t\t      targetEUN);\n\t\t\t\tinplace = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (pendingblock >= (thisVUC * (nftl->EraseSize / 512)) &&\n\t\t    pendingblock < ((thisVUC + 1)* (nftl->EraseSize / 512)) &&\n\t\t    BlockLastState[pendingblock - (thisVUC * (nftl->EraseSize / 512))] !=\n\t\t    SECTOR_FREE) {\n\t\t\tpr_debug(\"Pending write not free in EUN %d. \"\n\t\t\t      \"Folding out of place.\\n\", targetEUN);\n\t\t\tinplace = 0;\n\t\t}\n\t}\n\n\tif (!inplace) {\n\t\tpr_debug(\"Cannot fold Virtual Unit Chain %d in place. \"\n\t\t      \"Trying out-of-place\\n\", thisVUC);\n\t\t \n\t\ttargetEUN = NFTL_findfreeblock(nftl, 1);\n\t\tif (targetEUN == BLOCK_NIL) {\n\t\t\t \n\t\t\tprintk(KERN_WARNING\n\t\t\t       \"NFTL_findfreeblock(desperate) returns 0xffff.\\n\");\n\t\t\treturn BLOCK_NIL;\n\t\t}\n\t} else {\n\t\t \n\t\toob.u.c.FoldMark = oob.u.c.FoldMark1 = cpu_to_le16(FOLD_MARK_IN_PROGRESS);\n\t\toob.u.c.unused = 0xffffffff;\n\t\tnftl_write_oob(mtd, (nftl->EraseSize * targetEUN) + 2 * 512 + 8,\n\t\t\t       8, &retlen, (char *)&oob.u);\n\t}\n\n\t \n\tpr_debug(\"Folding chain %d into unit %d\\n\", thisVUC, targetEUN);\n\tfor (block = 0; block < nftl->EraseSize / 512 ; block++) {\n\t\tunsigned char movebuf[512];\n\t\tint ret;\n\n\t\t \n\t\tif (BlockMap[block] == targetEUN ||\n\t\t    (pendingblock == (thisVUC * (nftl->EraseSize / 512) + block))) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (BlockMap[block] == BLOCK_NIL)\n\t\t\tcontinue;\n\n\t\tret = mtd_read(mtd,\n\t\t\t       (nftl->EraseSize * BlockMap[block]) + (block * 512),\n\t\t\t       512,\n\t\t\t       &retlen,\n\t\t\t       movebuf);\n\t\tif (ret < 0 && !mtd_is_bitflip(ret)) {\n\t\t\tret = mtd_read(mtd,\n\t\t\t\t       (nftl->EraseSize * BlockMap[block]) + (block * 512),\n\t\t\t\t       512,\n\t\t\t\t       &retlen,\n\t\t\t\t       movebuf);\n\t\t\tif (ret != -EIO)\n\t\t\t\tprintk(\"Error went away on retry.\\n\");\n\t\t}\n\t\tmemset(&oob, 0xff, sizeof(struct nftl_oob));\n\t\toob.b.Status = oob.b.Status1 = SECTOR_USED;\n\n\t\tnftl_write(nftl->mbd.mtd, (nftl->EraseSize * targetEUN) +\n\t\t\t   (block * 512), 512, &retlen, movebuf, (char *)&oob);\n\t}\n\n\t \n\toob.u.a.VirtUnitNum = oob.u.a.SpareVirtUnitNum = cpu_to_le16(thisVUC);\n\toob.u.a.ReplUnitNum = oob.u.a.SpareReplUnitNum = BLOCK_NIL;\n\n\tnftl_write_oob(mtd, (nftl->EraseSize * targetEUN) + 8,\n\t\t       8, &retlen, (char *)&oob.u);\n\n\t \n\n\t \n\tthisEUN = nftl->EUNtable[thisVUC];\n\tpr_debug(\"Want to erase\\n\");\n\n\t \n\twhile (thisEUN <= nftl->lastEUN && thisEUN != targetEUN) {\n\t\tunsigned int EUNtmp;\n\n\t\tEUNtmp = nftl->ReplUnitTable[thisEUN];\n\n\t\tif (NFTL_formatblock(nftl, thisEUN) < 0) {\n\t\t\t \n\t\t\tnftl->ReplUnitTable[thisEUN] = BLOCK_RESERVED;\n\t\t} else {\n\t\t\t \n\t\t\tnftl->ReplUnitTable[thisEUN] = BLOCK_FREE;\n\t\t\tnftl->numfreeEUNs++;\n\t\t}\n\t\tthisEUN = EUNtmp;\n\t}\n\n\t \n\tnftl->ReplUnitTable[targetEUN] = BLOCK_NIL;\n\tnftl->EUNtable[thisVUC] = targetEUN;\n\n\treturn targetEUN;\n}\n\nstatic u16 NFTL_makefreeblock( struct NFTLrecord *nftl , unsigned pendingblock)\n{\n\t \n\tu16 LongestChain = 0;\n\tu16 ChainLength = 0, thislen;\n\tu16 chain, EUN;\n\n\tfor (chain = 0; chain < le32_to_cpu(nftl->MediaHdr.FormattedSize) / nftl->EraseSize; chain++) {\n\t\tEUN = nftl->EUNtable[chain];\n\t\tthislen = 0;\n\n\t\twhile (EUN <= nftl->lastEUN) {\n\t\t\tthislen++;\n\t\t\t\n\t\t\tEUN = nftl->ReplUnitTable[EUN] & 0x7fff;\n\t\t\tif (thislen > 0xff00) {\n\t\t\t\tprintk(\"Endless loop in Virtual Chain %d: Unit %x\\n\",\n\t\t\t\t       chain, EUN);\n\t\t\t}\n\t\t\tif (thislen > 0xff10) {\n\t\t\t\t \n\t\t\t\tthislen = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (thislen > ChainLength) {\n\t\t\t \n\t\t\tChainLength = thislen;\n\t\t\tLongestChain = chain;\n\t\t}\n\t}\n\n\tif (ChainLength < 2) {\n\t\tprintk(KERN_WARNING \"No Virtual Unit Chains available for folding. \"\n\t\t       \"Failing request\\n\");\n\t\treturn BLOCK_NIL;\n\t}\n\n\treturn NFTL_foldchain (nftl, LongestChain, pendingblock);\n}\n\n \nstatic inline u16 NFTL_findwriteunit(struct NFTLrecord *nftl, unsigned block)\n{\n\tu16 lastEUN;\n\tu16 thisVUC = block / (nftl->EraseSize / 512);\n\tstruct mtd_info *mtd = nftl->mbd.mtd;\n\tunsigned int writeEUN;\n\tunsigned long blockofs = (block * 512) & (nftl->EraseSize -1);\n\tsize_t retlen;\n\tint silly, silly2 = 3;\n\tstruct nftl_oob oob;\n\n\tdo {\n\t\t \n\n\t\t \n\t\tlastEUN = BLOCK_NIL;\n\t\twriteEUN = nftl->EUNtable[thisVUC];\n\t\tsilly = MAX_LOOPS;\n\t\twhile (writeEUN <= nftl->lastEUN) {\n\t\t\tstruct nftl_bci bci;\n\t\t\tsize_t retlen;\n\t\t\tunsigned int status;\n\n\t\t\tlastEUN = writeEUN;\n\n\t\t\tnftl_read_oob(mtd,\n\t\t\t\t      (writeEUN * nftl->EraseSize) + blockofs,\n\t\t\t\t      8, &retlen, (char *)&bci);\n\n\t\t\tpr_debug(\"Status of block %d in EUN %d is %x\\n\",\n\t\t\t      block , writeEUN, le16_to_cpu(bci.Status));\n\n\t\t\tstatus = bci.Status | bci.Status1;\n\t\t\tswitch(status) {\n\t\t\tcase SECTOR_FREE:\n\t\t\t\treturn writeEUN;\n\n\t\t\tcase SECTOR_DELETED:\n\t\t\tcase SECTOR_USED:\n\t\t\tcase SECTOR_IGNORE:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (!silly--) {\n\t\t\t\tprintk(KERN_WARNING\n\t\t\t\t       \"Infinite loop in Virtual Unit Chain 0x%x\\n\",\n\t\t\t\t       thisVUC);\n\t\t\t\treturn BLOCK_NIL;\n\t\t\t}\n\n\t\t\t \n\t\t\twriteEUN = nftl->ReplUnitTable[writeEUN];\n\t\t}\n\n\t\t \n\n\t\t \n\t\twriteEUN = NFTL_findfreeblock(nftl, 0);\n\n\t\tif (writeEUN == BLOCK_NIL) {\n\t\t\t \n\n\t\t\t \n\t\t\t \n\n\t\t\t \n\t\t\twriteEUN = NFTL_makefreeblock(nftl, BLOCK_NIL);\n\n\t\t\tif (writeEUN == BLOCK_NIL) {\n\t\t\t\t \n\t\t\t\tpr_debug(\"Using desperate==1 to find free EUN to accommodate write to VUC %d\\n\", thisVUC);\n\t\t\t\twriteEUN = NFTL_findfreeblock(nftl, 1);\n\t\t\t}\n\t\t\tif (writeEUN == BLOCK_NIL) {\n\t\t\t\t \n\t\t\t\tprintk(KERN_WARNING \"Cannot make free space.\\n\");\n\t\t\t\treturn BLOCK_NIL;\n\t\t\t}\n\t\t\t\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\n\t\tif (lastEUN != BLOCK_NIL) {\n\t\t\tthisVUC |= 0x8000;  \n\t\t} else {\n\t\t\t \n\t\t\tnftl->EUNtable[thisVUC] = writeEUN;\n\t\t}\n\n\t\t \n\t\t \n\t\tnftl->ReplUnitTable[writeEUN] = BLOCK_NIL;\n\n\t\t \n\t\tnftl_read_oob(mtd, writeEUN * nftl->EraseSize + 8, 8,\n\t\t\t      &retlen, (char *)&oob.u);\n\n\t\toob.u.a.VirtUnitNum = oob.u.a.SpareVirtUnitNum = cpu_to_le16(thisVUC);\n\n\t\tnftl_write_oob(mtd, writeEUN * nftl->EraseSize + 8, 8,\n\t\t\t       &retlen, (char *)&oob.u);\n\n\t\t \n\t\tif (lastEUN != BLOCK_NIL) {\n\t\t\t \n\t\t\tnftl->ReplUnitTable[lastEUN] = writeEUN;\n\t\t\t \n\t\t\tnftl_read_oob(mtd, (lastEUN * nftl->EraseSize) + 8,\n\t\t\t\t      8, &retlen, (char *)&oob.u);\n\n\t\t\toob.u.a.ReplUnitNum = oob.u.a.SpareReplUnitNum\n\t\t\t\t= cpu_to_le16(writeEUN);\n\n\t\t\tnftl_write_oob(mtd, (lastEUN * nftl->EraseSize) + 8,\n\t\t\t\t       8, &retlen, (char *)&oob.u);\n\t\t}\n\n\t\treturn writeEUN;\n\n\t} while (silly2--);\n\n\tprintk(KERN_WARNING \"Error folding to make room for Virtual Unit Chain 0x%x\\n\",\n\t       thisVUC);\n\treturn BLOCK_NIL;\n}\n\nstatic int nftl_writeblock(struct mtd_blktrans_dev *mbd, unsigned long block,\n\t\t\t   char *buffer)\n{\n\tstruct NFTLrecord *nftl = (void *)mbd;\n\tu16 writeEUN;\n\tunsigned long blockofs = (block * 512) & (nftl->EraseSize - 1);\n\tsize_t retlen;\n\tstruct nftl_oob oob;\n\n\twriteEUN = NFTL_findwriteunit(nftl, block);\n\n\tif (writeEUN == BLOCK_NIL) {\n\t\tprintk(KERN_WARNING\n\t\t       \"NFTL_writeblock(): Cannot find block to write to\\n\");\n\t\t \n\t\treturn 1;\n\t}\n\n\tmemset(&oob, 0xff, sizeof(struct nftl_oob));\n\toob.b.Status = oob.b.Status1 = SECTOR_USED;\n\n\tnftl_write(nftl->mbd.mtd, (writeEUN * nftl->EraseSize) + blockofs,\n\t\t   512, &retlen, (char *)buffer, (char *)&oob);\n\treturn 0;\n}\n#endif  \n\nstatic int nftl_readblock(struct mtd_blktrans_dev *mbd, unsigned long block,\n\t\t\t  char *buffer)\n{\n\tstruct NFTLrecord *nftl = (void *)mbd;\n\tstruct mtd_info *mtd = nftl->mbd.mtd;\n\tu16 lastgoodEUN;\n\tu16 thisEUN = nftl->EUNtable[block / (nftl->EraseSize / 512)];\n\tunsigned long blockofs = (block * 512) & (nftl->EraseSize - 1);\n\tunsigned int status;\n\tint silly = MAX_LOOPS;\n\tsize_t retlen;\n\tstruct nftl_bci bci;\n\n\tlastgoodEUN = BLOCK_NIL;\n\n\tif (thisEUN != BLOCK_NIL) {\n\t\twhile (thisEUN < nftl->nb_blocks) {\n\t\t\tif (nftl_read_oob(mtd, (thisEUN * nftl->EraseSize) +\n\t\t\t\t\t  blockofs, 8, &retlen,\n\t\t\t\t\t  (char *)&bci) < 0)\n\t\t\t\tstatus = SECTOR_IGNORE;\n\t\t\telse\n\t\t\t\tstatus = bci.Status | bci.Status1;\n\n\t\t\tswitch (status) {\n\t\t\tcase SECTOR_FREE:\n\t\t\t\t \n\t\t\t\tgoto the_end;\n\t\t\tcase SECTOR_DELETED:\n\t\t\t\tlastgoodEUN = BLOCK_NIL;\n\t\t\t\tbreak;\n\t\t\tcase SECTOR_USED:\n\t\t\t\tlastgoodEUN = thisEUN;\n\t\t\t\tbreak;\n\t\t\tcase SECTOR_IGNORE:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tprintk(\"Unknown status for block %ld in EUN %d: %x\\n\",\n\t\t\t\t       block, thisEUN, status);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (!silly--) {\n\t\t\t\tprintk(KERN_WARNING \"Infinite loop in Virtual Unit Chain 0x%lx\\n\",\n\t\t\t\t       block / (nftl->EraseSize / 512));\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tthisEUN = nftl->ReplUnitTable[thisEUN];\n\t\t}\n\t}\n\n the_end:\n\tif (lastgoodEUN == BLOCK_NIL) {\n\t\t \n\t\tmemset(buffer, 0, 512);\n\t} else {\n\t\tloff_t ptr = (lastgoodEUN * nftl->EraseSize) + blockofs;\n\t\tsize_t retlen;\n\t\tint res = mtd_read(mtd, ptr, 512, &retlen, buffer);\n\n\t\tif (res < 0 && !mtd_is_bitflip(res))\n\t\t\treturn -EIO;\n\t}\n\treturn 0;\n}\n\nstatic int nftl_getgeo(struct mtd_blktrans_dev *dev,  struct hd_geometry *geo)\n{\n\tstruct NFTLrecord *nftl = (void *)dev;\n\n\tgeo->heads = nftl->heads;\n\tgeo->sectors = nftl->sectors;\n\tgeo->cylinders = nftl->cylinders;\n\n\treturn 0;\n}\n\n \n\n\nstatic struct mtd_blktrans_ops nftl_tr = {\n\t.name\t\t= \"nftl\",\n\t.major\t\t= NFTL_MAJOR,\n\t.part_bits\t= NFTL_PARTN_BITS,\n\t.blksize \t= 512,\n\t.getgeo\t\t= nftl_getgeo,\n\t.readsect\t= nftl_readblock,\n#ifdef CONFIG_NFTL_RW\n\t.writesect\t= nftl_writeblock,\n#endif\n\t.add_mtd\t= nftl_add_mtd,\n\t.remove_dev\t= nftl_remove_dev,\n\t.owner\t\t= THIS_MODULE,\n};\n\nmodule_mtd_blktrans(nftl_tr);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"David Woodhouse <dwmw2@infradead.org>, Fabrice Bellard <fabrice.bellard@netgem.com> et al.\");\nMODULE_DESCRIPTION(\"Support code for NAND Flash Translation Layer, used on M-Systems DiskOnChip 2000 and Millennium\");\nMODULE_ALIAS_BLOCKDEV_MAJOR(NFTL_MAJOR);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}