{
  "module_name": "cfi_cmdset_0001.c",
  "hash_id": "f675cb74461d57f4c4d1a6b5af3fd0a7589ae521ed4d5c90a2bd4714e1515b23",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/chips/cfi_cmdset_0001.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <asm/io.h>\n#include <asm/byteorder.h>\n\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/reboot.h>\n#include <linux/bitmap.h>\n#include <linux/mtd/xip.h>\n#include <linux/mtd/map.h>\n#include <linux/mtd/mtd.h>\n#include <linux/mtd/cfi.h>\n\n \n \n\n\n#define FORCE_WORD_WRITE 0\n\n \n#define I82802AB\t0x00ad\n#define I82802AC\t0x00ac\n#define PF38F4476\t0x881c\n#define M28F00AP30\t0x8963\n \n#define M50LPW080       0x002F\n#define M50FLW080A\t0x0080\n#define M50FLW080B\t0x0081\n \n#define AT49BV640D\t0x02de\n#define AT49BV640DT\t0x02db\n \n#define LH28F640BFHE_PTTL90\t0x00b0\n#define LH28F640BFHE_PBTL90\t0x00b1\n#define LH28F640BFHE_PTTL70A\t0x00b2\n#define LH28F640BFHE_PBTL70A\t0x00b3\n\nstatic int cfi_intelext_read (struct mtd_info *, loff_t, size_t, size_t *, u_char *);\nstatic int cfi_intelext_write_words(struct mtd_info *, loff_t, size_t, size_t *, const u_char *);\nstatic int cfi_intelext_write_buffers(struct mtd_info *, loff_t, size_t, size_t *, const u_char *);\nstatic int cfi_intelext_writev(struct mtd_info *, const struct kvec *, unsigned long, loff_t, size_t *);\nstatic int cfi_intelext_erase_varsize(struct mtd_info *, struct erase_info *);\nstatic void cfi_intelext_sync (struct mtd_info *);\nstatic int cfi_intelext_lock(struct mtd_info *mtd, loff_t ofs, uint64_t len);\nstatic int cfi_intelext_unlock(struct mtd_info *mtd, loff_t ofs, uint64_t len);\nstatic int cfi_intelext_is_locked(struct mtd_info *mtd, loff_t ofs,\n\t\t\t\t  uint64_t len);\n#ifdef CONFIG_MTD_OTP\nstatic int cfi_intelext_read_fact_prot_reg (struct mtd_info *, loff_t, size_t, size_t *, u_char *);\nstatic int cfi_intelext_read_user_prot_reg (struct mtd_info *, loff_t, size_t, size_t *, u_char *);\nstatic int cfi_intelext_write_user_prot_reg(struct mtd_info *, loff_t, size_t,\n\t\t\t\t\t    size_t *, const u_char *);\nstatic int cfi_intelext_lock_user_prot_reg (struct mtd_info *, loff_t, size_t);\nstatic int cfi_intelext_get_fact_prot_info(struct mtd_info *, size_t,\n\t\t\t\t\t   size_t *, struct otp_info *);\nstatic int cfi_intelext_get_user_prot_info(struct mtd_info *, size_t,\n\t\t\t\t\t   size_t *, struct otp_info *);\n#endif\nstatic int cfi_intelext_suspend (struct mtd_info *);\nstatic void cfi_intelext_resume (struct mtd_info *);\nstatic int cfi_intelext_reboot (struct notifier_block *, unsigned long, void *);\n\nstatic void cfi_intelext_destroy(struct mtd_info *);\n\nstruct mtd_info *cfi_cmdset_0001(struct map_info *, int);\n\nstatic struct mtd_info *cfi_intelext_setup (struct mtd_info *);\nstatic int cfi_intelext_partition_fixup(struct mtd_info *, struct cfi_private **);\n\nstatic int cfi_intelext_point (struct mtd_info *mtd, loff_t from, size_t len,\n\t\t     size_t *retlen, void **virt, resource_size_t *phys);\nstatic int cfi_intelext_unpoint(struct mtd_info *mtd, loff_t from, size_t len);\n\nstatic int chip_ready (struct map_info *map, struct flchip *chip, unsigned long adr, int mode);\nstatic int get_chip(struct map_info *map, struct flchip *chip, unsigned long adr, int mode);\nstatic void put_chip(struct map_info *map, struct flchip *chip, unsigned long adr);\n#include \"fwh_lock.h\"\n\n\n\n \n\nstatic struct mtd_chip_driver cfi_intelext_chipdrv = {\n\t.probe\t\t= NULL,  \n\t.destroy\t= cfi_intelext_destroy,\n\t.name\t\t= \"cfi_cmdset_0001\",\n\t.module\t\t= THIS_MODULE\n};\n\n \n \n\n#ifdef DEBUG_CFI_FEATURES\nstatic void cfi_tell_features(struct cfi_pri_intelext *extp)\n{\n\tint i;\n\tprintk(\"  Extended Query version %c.%c\\n\", extp->MajorVersion, extp->MinorVersion);\n\tprintk(\"  Feature/Command Support:      %4.4X\\n\", extp->FeatureSupport);\n\tprintk(\"     - Chip Erase:              %s\\n\", extp->FeatureSupport&1?\"supported\":\"unsupported\");\n\tprintk(\"     - Suspend Erase:           %s\\n\", extp->FeatureSupport&2?\"supported\":\"unsupported\");\n\tprintk(\"     - Suspend Program:         %s\\n\", extp->FeatureSupport&4?\"supported\":\"unsupported\");\n\tprintk(\"     - Legacy Lock/Unlock:      %s\\n\", extp->FeatureSupport&8?\"supported\":\"unsupported\");\n\tprintk(\"     - Queued Erase:            %s\\n\", extp->FeatureSupport&16?\"supported\":\"unsupported\");\n\tprintk(\"     - Instant block lock:      %s\\n\", extp->FeatureSupport&32?\"supported\":\"unsupported\");\n\tprintk(\"     - Protection Bits:         %s\\n\", extp->FeatureSupport&64?\"supported\":\"unsupported\");\n\tprintk(\"     - Page-mode read:          %s\\n\", extp->FeatureSupport&128?\"supported\":\"unsupported\");\n\tprintk(\"     - Synchronous read:        %s\\n\", extp->FeatureSupport&256?\"supported\":\"unsupported\");\n\tprintk(\"     - Simultaneous operations: %s\\n\", extp->FeatureSupport&512?\"supported\":\"unsupported\");\n\tprintk(\"     - Extended Flash Array:    %s\\n\", extp->FeatureSupport&1024?\"supported\":\"unsupported\");\n\tfor (i=11; i<32; i++) {\n\t\tif (extp->FeatureSupport & (1<<i))\n\t\t\tprintk(\"     - Unknown Bit %X:      supported\\n\", i);\n\t}\n\n\tprintk(\"  Supported functions after Suspend: %2.2X\\n\", extp->SuspendCmdSupport);\n\tprintk(\"     - Program after Erase Suspend: %s\\n\", extp->SuspendCmdSupport&1?\"supported\":\"unsupported\");\n\tfor (i=1; i<8; i++) {\n\t\tif (extp->SuspendCmdSupport & (1<<i))\n\t\t\tprintk(\"     - Unknown Bit %X:               supported\\n\", i);\n\t}\n\n\tprintk(\"  Block Status Register Mask: %4.4X\\n\", extp->BlkStatusRegMask);\n\tprintk(\"     - Lock Bit Active:      %s\\n\", extp->BlkStatusRegMask&1?\"yes\":\"no\");\n\tprintk(\"     - Lock-Down Bit Active: %s\\n\", extp->BlkStatusRegMask&2?\"yes\":\"no\");\n\tfor (i=2; i<3; i++) {\n\t\tif (extp->BlkStatusRegMask & (1<<i))\n\t\t\tprintk(\"     - Unknown Bit %X Active: yes\\n\",i);\n\t}\n\tprintk(\"     - EFA Lock Bit:         %s\\n\", extp->BlkStatusRegMask&16?\"yes\":\"no\");\n\tprintk(\"     - EFA Lock-Down Bit:    %s\\n\", extp->BlkStatusRegMask&32?\"yes\":\"no\");\n\tfor (i=6; i<16; i++) {\n\t\tif (extp->BlkStatusRegMask & (1<<i))\n\t\t\tprintk(\"     - Unknown Bit %X Active: yes\\n\",i);\n\t}\n\n\tprintk(\"  Vcc Logic Supply Optimum Program/Erase Voltage: %d.%d V\\n\",\n\t       extp->VccOptimal >> 4, extp->VccOptimal & 0xf);\n\tif (extp->VppOptimal)\n\t\tprintk(\"  Vpp Programming Supply Optimum Program/Erase Voltage: %d.%d V\\n\",\n\t\t       extp->VppOptimal >> 4, extp->VppOptimal & 0xf);\n}\n#endif\n\n \nstatic void fixup_convert_atmel_pri(struct mtd_info *mtd)\n{\n\tstruct map_info *map = mtd->priv;\n\tstruct cfi_private *cfi = map->fldrv_priv;\n\tstruct cfi_pri_intelext *extp = cfi->cmdset_priv;\n\tstruct cfi_pri_atmel atmel_pri;\n\tuint32_t features = 0;\n\n\t \n\textp->FeatureSupport = cpu_to_le32(extp->FeatureSupport);\n\textp->BlkStatusRegMask = cpu_to_le16(extp->BlkStatusRegMask);\n\textp->ProtRegAddr = cpu_to_le16(extp->ProtRegAddr);\n\n\tmemcpy(&atmel_pri, extp, sizeof(atmel_pri));\n\tmemset((char *)extp + 5, 0, sizeof(*extp) - 5);\n\n\tprintk(KERN_ERR \"atmel Features: %02x\\n\", atmel_pri.Features);\n\n\tif (atmel_pri.Features & 0x01)  \n\t\tfeatures |= (1<<0);\n\tif (atmel_pri.Features & 0x02)  \n\t\tfeatures |= (1<<1);\n\tif (atmel_pri.Features & 0x04)  \n\t\tfeatures |= (1<<2);\n\tif (atmel_pri.Features & 0x08)  \n\t\tfeatures |= (1<<9);\n\tif (atmel_pri.Features & 0x20)  \n\t\tfeatures |= (1<<7);\n\tif (atmel_pri.Features & 0x40)  \n\t\tfeatures |= (1<<4);\n\tif (atmel_pri.Features & 0x80)  \n\t\tfeatures |= (1<<6);\n\n\textp->FeatureSupport = features;\n\n\t \n\tcfi->cfiq->BufWriteTimeoutTyp = 0;\n\tcfi->cfiq->BufWriteTimeoutMax = 0;\n}\n\nstatic void fixup_at49bv640dx_lock(struct mtd_info *mtd)\n{\n\tstruct map_info *map = mtd->priv;\n\tstruct cfi_private *cfi = map->fldrv_priv;\n\tstruct cfi_pri_intelext *cfip = cfi->cmdset_priv;\n\n\tcfip->FeatureSupport |= (1 << 5);\n\tmtd->flags |= MTD_POWERUP_LOCK;\n}\n\n#ifdef CMDSET0001_DISABLE_ERASE_SUSPEND_ON_WRITE\n \nstatic void fixup_intel_strataflash(struct mtd_info *mtd)\n{\n\tstruct map_info *map = mtd->priv;\n\tstruct cfi_private *cfi = map->fldrv_priv;\n\tstruct cfi_pri_intelext *extp = cfi->cmdset_priv;\n\n\tprintk(KERN_WARNING \"cfi_cmdset_0001: Suspend \"\n\t                    \"erase on write disabled.\\n\");\n\textp->SuspendCmdSupport &= ~1;\n}\n#endif\n\n#ifdef CMDSET0001_DISABLE_WRITE_SUSPEND\nstatic void fixup_no_write_suspend(struct mtd_info *mtd)\n{\n\tstruct map_info *map = mtd->priv;\n\tstruct cfi_private *cfi = map->fldrv_priv;\n\tstruct cfi_pri_intelext *cfip = cfi->cmdset_priv;\n\n\tif (cfip && (cfip->FeatureSupport&4)) {\n\t\tcfip->FeatureSupport &= ~4;\n\t\tprintk(KERN_WARNING \"cfi_cmdset_0001: write suspend disabled\\n\");\n\t}\n}\n#endif\n\nstatic void fixup_st_m28w320ct(struct mtd_info *mtd)\n{\n\tstruct map_info *map = mtd->priv;\n\tstruct cfi_private *cfi = map->fldrv_priv;\n\n\tcfi->cfiq->BufWriteTimeoutTyp = 0;\t \n\tcfi->cfiq->BufWriteTimeoutMax = 0;\t \n}\n\nstatic void fixup_st_m28w320cb(struct mtd_info *mtd)\n{\n\tstruct map_info *map = mtd->priv;\n\tstruct cfi_private *cfi = map->fldrv_priv;\n\n\t \n\tcfi->cfiq->EraseRegionInfo[1] =\n\t\t(cfi->cfiq->EraseRegionInfo[1] & 0xffff0000) | 0x3e;\n};\n\nstatic int is_LH28F640BF(struct cfi_private *cfi)\n{\n\t \n\tif (cfi->mfr == CFI_MFR_SHARP && (\n\t    cfi->id == LH28F640BFHE_PTTL90 || cfi->id == LH28F640BFHE_PBTL90 ||\n\t    cfi->id == LH28F640BFHE_PTTL70A || cfi->id == LH28F640BFHE_PBTL70A))\n\t\treturn 1;\n\treturn 0;\n}\n\nstatic void fixup_LH28F640BF(struct mtd_info *mtd)\n{\n\tstruct map_info *map = mtd->priv;\n\tstruct cfi_private *cfi = map->fldrv_priv;\n\tstruct cfi_pri_intelext *extp = cfi->cmdset_priv;\n\n\t \n\tif (is_LH28F640BF(cfi)) {\n\t\tprintk(KERN_INFO \"Reset Partition Config. Register: 1 Partition of 4 planes\\n\");\n\t\tmap_write(map, CMD(0x60), 0);\n\t\tmap_write(map, CMD(0x04), 0);\n\n\t\t \n\t\tprintk(KERN_INFO \"cfi_cmdset_0001: Simultaneous Operations disabled\\n\");\n\t\textp->FeatureSupport &= ~512;\n\t}\n}\n\nstatic void fixup_use_point(struct mtd_info *mtd)\n{\n\tstruct map_info *map = mtd->priv;\n\tif (!mtd->_point && map_is_linear(map)) {\n\t\tmtd->_point   = cfi_intelext_point;\n\t\tmtd->_unpoint = cfi_intelext_unpoint;\n\t}\n}\n\nstatic void fixup_use_write_buffers(struct mtd_info *mtd)\n{\n\tstruct map_info *map = mtd->priv;\n\tstruct cfi_private *cfi = map->fldrv_priv;\n\tif (cfi->cfiq->BufWriteTimeoutTyp) {\n\t\tprintk(KERN_INFO \"Using buffer write method\\n\" );\n\t\tmtd->_write = cfi_intelext_write_buffers;\n\t\tmtd->_writev = cfi_intelext_writev;\n\t}\n}\n\n \nstatic void fixup_unlock_powerup_lock(struct mtd_info *mtd)\n{\n\tstruct map_info *map = mtd->priv;\n\tstruct cfi_private *cfi = map->fldrv_priv;\n\tstruct cfi_pri_intelext *cfip = cfi->cmdset_priv;\n\n\tif (cfip->FeatureSupport&32) {\n\t\tprintk(KERN_INFO \"Using auto-unlock on power-up/resume\\n\" );\n\t\tmtd->flags |= MTD_POWERUP_LOCK;\n\t}\n}\n\nstatic struct cfi_fixup cfi_fixup_table[] = {\n\t{ CFI_MFR_ATMEL, CFI_ID_ANY, fixup_convert_atmel_pri },\n\t{ CFI_MFR_ATMEL, AT49BV640D, fixup_at49bv640dx_lock },\n\t{ CFI_MFR_ATMEL, AT49BV640DT, fixup_at49bv640dx_lock },\n#ifdef CMDSET0001_DISABLE_ERASE_SUSPEND_ON_WRITE\n\t{ CFI_MFR_ANY, CFI_ID_ANY, fixup_intel_strataflash },\n#endif\n#ifdef CMDSET0001_DISABLE_WRITE_SUSPEND\n\t{ CFI_MFR_ANY, CFI_ID_ANY, fixup_no_write_suspend },\n#endif\n#if !FORCE_WORD_WRITE\n\t{ CFI_MFR_ANY, CFI_ID_ANY, fixup_use_write_buffers },\n#endif\n\t{ CFI_MFR_ST, 0x00ba,   fixup_st_m28w320ct },\n\t{ CFI_MFR_ST, 0x00bb,   fixup_st_m28w320cb },\n\t{ CFI_MFR_INTEL, CFI_ID_ANY, fixup_unlock_powerup_lock },\n\t{ CFI_MFR_SHARP, CFI_ID_ANY, fixup_unlock_powerup_lock },\n\t{ CFI_MFR_SHARP, CFI_ID_ANY, fixup_LH28F640BF },\n\t{ 0, 0, NULL }\n};\n\nstatic struct cfi_fixup jedec_fixup_table[] = {\n\t{ CFI_MFR_INTEL, I82802AB,   fixup_use_fwh_lock },\n\t{ CFI_MFR_INTEL, I82802AC,   fixup_use_fwh_lock },\n\t{ CFI_MFR_ST,    M50LPW080,  fixup_use_fwh_lock },\n\t{ CFI_MFR_ST,    M50FLW080A, fixup_use_fwh_lock },\n\t{ CFI_MFR_ST,    M50FLW080B, fixup_use_fwh_lock },\n\t{ 0, 0, NULL }\n};\nstatic struct cfi_fixup fixup_table[] = {\n\t \n\t{ CFI_MFR_ANY, CFI_ID_ANY, fixup_use_point },\n\t{ 0, 0, NULL }\n};\n\nstatic void cfi_fixup_major_minor(struct cfi_private *cfi,\n\t\t\t\t\t\tstruct cfi_pri_intelext *extp)\n{\n\tif (cfi->mfr == CFI_MFR_INTEL &&\n\t\t\tcfi->id == PF38F4476 && extp->MinorVersion == '3')\n\t\textp->MinorVersion = '1';\n}\n\nstatic int cfi_is_micron_28F00AP30(struct cfi_private *cfi, struct flchip *chip)\n{\n\t \n\tif (cfi->mfr == CFI_MFR_INTEL && cfi->id == M28F00AP30)\n\t\treturn 1;\n\treturn 0;\n}\n\nstatic inline struct cfi_pri_intelext *\nread_pri_intelext(struct map_info *map, __u16 adr)\n{\n\tstruct cfi_private *cfi = map->fldrv_priv;\n\tstruct cfi_pri_intelext *extp;\n\tunsigned int extra_size = 0;\n\tunsigned int extp_size = sizeof(*extp);\n\n again:\n\textp = (struct cfi_pri_intelext *)cfi_read_pri(map, adr, extp_size, \"Intel/Sharp\");\n\tif (!extp)\n\t\treturn NULL;\n\n\tcfi_fixup_major_minor(cfi, extp);\n\n\tif (extp->MajorVersion != '1' ||\n\t    (extp->MinorVersion < '0' || extp->MinorVersion > '5')) {\n\t\tprintk(KERN_ERR \"  Unknown Intel/Sharp Extended Query \"\n\t\t       \"version %c.%c.\\n\",  extp->MajorVersion,\n\t\t       extp->MinorVersion);\n\t\tkfree(extp);\n\t\treturn NULL;\n\t}\n\n\t \n\textp->FeatureSupport = le32_to_cpu(extp->FeatureSupport);\n\textp->BlkStatusRegMask = le16_to_cpu(extp->BlkStatusRegMask);\n\textp->ProtRegAddr = le16_to_cpu(extp->ProtRegAddr);\n\n\tif (extp->MinorVersion >= '0') {\n\t\textra_size = 0;\n\n\t\t \n\t\tif (extp->NumProtectionFields) {\n\t\t\tstruct cfi_intelext_otpinfo *otp =\n\t\t\t\t(struct cfi_intelext_otpinfo *)&extp->extra[0];\n\n\t\t\textra_size += (extp->NumProtectionFields - 1) *\n\t\t\t\tsizeof(struct cfi_intelext_otpinfo);\n\n\t\t\tif (extp_size >= sizeof(*extp) + extra_size) {\n\t\t\t\tint i;\n\n\t\t\t\t \n\t\t\t\tfor (i = 0; i < extp->NumProtectionFields - 1; i++) {\n\t\t\t\t\totp->ProtRegAddr = le32_to_cpu(otp->ProtRegAddr);\n\t\t\t\t\totp->FactGroups = le16_to_cpu(otp->FactGroups);\n\t\t\t\t\totp->UserGroups = le16_to_cpu(otp->UserGroups);\n\t\t\t\t\totp++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (extp->MinorVersion >= '1') {\n\t\t \n\t\textra_size += 2;\n\t\tif (extp_size < sizeof(*extp) + extra_size)\n\t\t\tgoto need_more;\n\t\textra_size += extp->extra[extra_size - 1];\n\t}\n\n\tif (extp->MinorVersion >= '3') {\n\t\tint nb_parts, i;\n\n\t\t \n\t\textra_size += 1;\n\t\tif (extp_size < sizeof(*extp) + extra_size)\n\t\t\tgoto need_more;\n\t\tnb_parts = extp->extra[extra_size - 1];\n\n\t\t \n\t\tif (extp->MinorVersion >= '4')\n\t\t\textra_size += 2;\n\n\t\tfor (i = 0; i < nb_parts; i++) {\n\t\t\tstruct cfi_intelext_regioninfo *rinfo;\n\t\t\trinfo = (struct cfi_intelext_regioninfo *)&extp->extra[extra_size];\n\t\t\textra_size += sizeof(*rinfo);\n\t\t\tif (extp_size < sizeof(*extp) + extra_size)\n\t\t\t\tgoto need_more;\n\t\t\trinfo->NumIdentPartitions=le16_to_cpu(rinfo->NumIdentPartitions);\n\t\t\textra_size += (rinfo->NumBlockTypes - 1)\n\t\t\t\t      * sizeof(struct cfi_intelext_blockinfo);\n\t\t}\n\n\t\tif (extp->MinorVersion >= '4')\n\t\t\textra_size += sizeof(struct cfi_intelext_programming_regioninfo);\n\n\t\tif (extp_size < sizeof(*extp) + extra_size) {\n\t\t\tneed_more:\n\t\t\textp_size = sizeof(*extp) + extra_size;\n\t\t\tkfree(extp);\n\t\t\tif (extp_size > 4096) {\n\t\t\t\tprintk(KERN_ERR\n\t\t\t\t\t\"%s: cfi_pri_intelext is too fat\\n\",\n\t\t\t\t\t__func__);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tgoto again;\n\t\t}\n\t}\n\n\treturn extp;\n}\n\nstruct mtd_info *cfi_cmdset_0001(struct map_info *map, int primary)\n{\n\tstruct cfi_private *cfi = map->fldrv_priv;\n\tstruct mtd_info *mtd;\n\tint i;\n\n\tmtd = kzalloc(sizeof(*mtd), GFP_KERNEL);\n\tif (!mtd)\n\t\treturn NULL;\n\tmtd->priv = map;\n\tmtd->type = MTD_NORFLASH;\n\n\t \n\tmtd->_erase   = cfi_intelext_erase_varsize;\n\tmtd->_read    = cfi_intelext_read;\n\tmtd->_write   = cfi_intelext_write_words;\n\tmtd->_sync    = cfi_intelext_sync;\n\tmtd->_lock    = cfi_intelext_lock;\n\tmtd->_unlock  = cfi_intelext_unlock;\n\tmtd->_is_locked = cfi_intelext_is_locked;\n\tmtd->_suspend = cfi_intelext_suspend;\n\tmtd->_resume  = cfi_intelext_resume;\n\tmtd->flags   = MTD_CAP_NORFLASH;\n\tmtd->name    = map->name;\n\tmtd->writesize = 1;\n\tmtd->writebufsize = cfi_interleave(cfi) << cfi->cfiq->MaxBufWriteSize;\n\n\tmtd->reboot_notifier.notifier_call = cfi_intelext_reboot;\n\n\tif (cfi->cfi_mode == CFI_MODE_CFI) {\n\t\t \n\t\t__u16 adr = primary?cfi->cfiq->P_ADR:cfi->cfiq->A_ADR;\n\t\tstruct cfi_pri_intelext *extp;\n\n\t\textp = read_pri_intelext(map, adr);\n\t\tif (!extp) {\n\t\t\tkfree(mtd);\n\t\t\treturn NULL;\n\t\t}\n\n\t\t \n\t\tcfi->cmdset_priv = extp;\n\n\t\tcfi_fixup(mtd, cfi_fixup_table);\n\n#ifdef DEBUG_CFI_FEATURES\n\t\t \n\t\tcfi_tell_features(extp);\n#endif\n\n\t\tif(extp->SuspendCmdSupport & 1) {\n\t\t\tprintk(KERN_NOTICE \"cfi_cmdset_0001: Erase suspend on write enabled\\n\");\n\t\t}\n\t}\n\telse if (cfi->cfi_mode == CFI_MODE_JEDEC) {\n\t\t \n\t\tcfi_fixup(mtd, jedec_fixup_table);\n\t}\n\t \n\tcfi_fixup(mtd, fixup_table);\n\n\tfor (i=0; i< cfi->numchips; i++) {\n\t\tif (cfi->cfiq->WordWriteTimeoutTyp)\n\t\t\tcfi->chips[i].word_write_time =\n\t\t\t\t1<<cfi->cfiq->WordWriteTimeoutTyp;\n\t\telse\n\t\t\tcfi->chips[i].word_write_time = 50000;\n\n\t\tif (cfi->cfiq->BufWriteTimeoutTyp)\n\t\t\tcfi->chips[i].buffer_write_time =\n\t\t\t\t1<<cfi->cfiq->BufWriteTimeoutTyp;\n\t\t \n\n\t\tif (cfi->cfiq->BlockEraseTimeoutTyp)\n\t\t\tcfi->chips[i].erase_time =\n\t\t\t\t1000<<cfi->cfiq->BlockEraseTimeoutTyp;\n\t\telse\n\t\t\tcfi->chips[i].erase_time = 2000000;\n\n\t\tif (cfi->cfiq->WordWriteTimeoutTyp &&\n\t\t    cfi->cfiq->WordWriteTimeoutMax)\n\t\t\tcfi->chips[i].word_write_time_max =\n\t\t\t\t1<<(cfi->cfiq->WordWriteTimeoutTyp +\n\t\t\t\t    cfi->cfiq->WordWriteTimeoutMax);\n\t\telse\n\t\t\tcfi->chips[i].word_write_time_max = 50000 * 8;\n\n\t\tif (cfi->cfiq->BufWriteTimeoutTyp &&\n\t\t    cfi->cfiq->BufWriteTimeoutMax)\n\t\t\tcfi->chips[i].buffer_write_time_max =\n\t\t\t\t1<<(cfi->cfiq->BufWriteTimeoutTyp +\n\t\t\t\t    cfi->cfiq->BufWriteTimeoutMax);\n\n\t\tif (cfi->cfiq->BlockEraseTimeoutTyp &&\n\t\t    cfi->cfiq->BlockEraseTimeoutMax)\n\t\t\tcfi->chips[i].erase_time_max =\n\t\t\t\t1000<<(cfi->cfiq->BlockEraseTimeoutTyp +\n\t\t\t\t       cfi->cfiq->BlockEraseTimeoutMax);\n\t\telse\n\t\t\tcfi->chips[i].erase_time_max = 2000000 * 8;\n\n\t\tcfi->chips[i].ref_point_counter = 0;\n\t\tinit_waitqueue_head(&(cfi->chips[i].wq));\n\t}\n\n\tmap->fldrv = &cfi_intelext_chipdrv;\n\n\treturn cfi_intelext_setup(mtd);\n}\nstruct mtd_info *cfi_cmdset_0003(struct map_info *map, int primary) __attribute__((alias(\"cfi_cmdset_0001\")));\nstruct mtd_info *cfi_cmdset_0200(struct map_info *map, int primary) __attribute__((alias(\"cfi_cmdset_0001\")));\nEXPORT_SYMBOL_GPL(cfi_cmdset_0001);\nEXPORT_SYMBOL_GPL(cfi_cmdset_0003);\nEXPORT_SYMBOL_GPL(cfi_cmdset_0200);\n\nstatic struct mtd_info *cfi_intelext_setup(struct mtd_info *mtd)\n{\n\tstruct map_info *map = mtd->priv;\n\tstruct cfi_private *cfi = map->fldrv_priv;\n\tunsigned long offset = 0;\n\tint i,j;\n\tunsigned long devsize = (1<<cfi->cfiq->DevSize) * cfi->interleave;\n\n\t \n\n\tmtd->size = devsize * cfi->numchips;\n\n\tmtd->numeraseregions = cfi->cfiq->NumEraseRegions * cfi->numchips;\n\tmtd->eraseregions = kcalloc(mtd->numeraseregions,\n\t\t\t\t    sizeof(struct mtd_erase_region_info),\n\t\t\t\t    GFP_KERNEL);\n\tif (!mtd->eraseregions)\n\t\tgoto setup_err;\n\n\tfor (i=0; i<cfi->cfiq->NumEraseRegions; i++) {\n\t\tunsigned long ernum, ersize;\n\t\tersize = ((cfi->cfiq->EraseRegionInfo[i] >> 8) & ~0xff) * cfi->interleave;\n\t\ternum = (cfi->cfiq->EraseRegionInfo[i] & 0xffff) + 1;\n\n\t\tif (mtd->erasesize < ersize) {\n\t\t\tmtd->erasesize = ersize;\n\t\t}\n\t\tfor (j=0; j<cfi->numchips; j++) {\n\t\t\tmtd->eraseregions[(j*cfi->cfiq->NumEraseRegions)+i].offset = (j*devsize)+offset;\n\t\t\tmtd->eraseregions[(j*cfi->cfiq->NumEraseRegions)+i].erasesize = ersize;\n\t\t\tmtd->eraseregions[(j*cfi->cfiq->NumEraseRegions)+i].numblocks = ernum;\n\t\t\tmtd->eraseregions[(j*cfi->cfiq->NumEraseRegions)+i].lockmap = kmalloc(ernum / 8 + 1, GFP_KERNEL);\n\t\t\tif (!mtd->eraseregions[(j*cfi->cfiq->NumEraseRegions)+i].lockmap)\n\t\t\t\tgoto setup_err;\n\t\t}\n\t\toffset += (ersize * ernum);\n\t}\n\n\tif (offset != devsize) {\n\t\t \n\t\tprintk(KERN_WARNING \"Sum of regions (%lx) != total size of set of interleaved chips (%lx)\\n\", offset, devsize);\n\t\tgoto setup_err;\n\t}\n\n\tfor (i=0; i<mtd->numeraseregions;i++){\n\t\tprintk(KERN_DEBUG \"erase region %d: offset=0x%llx,size=0x%x,blocks=%d\\n\",\n\t\t       i,(unsigned long long)mtd->eraseregions[i].offset,\n\t\t       mtd->eraseregions[i].erasesize,\n\t\t       mtd->eraseregions[i].numblocks);\n\t}\n\n#ifdef CONFIG_MTD_OTP\n\tmtd->_read_fact_prot_reg = cfi_intelext_read_fact_prot_reg;\n\tmtd->_read_user_prot_reg = cfi_intelext_read_user_prot_reg;\n\tmtd->_write_user_prot_reg = cfi_intelext_write_user_prot_reg;\n\tmtd->_lock_user_prot_reg = cfi_intelext_lock_user_prot_reg;\n\tmtd->_get_fact_prot_info = cfi_intelext_get_fact_prot_info;\n\tmtd->_get_user_prot_info = cfi_intelext_get_user_prot_info;\n#endif\n\n\t \n\tif (cfi_intelext_partition_fixup(mtd, &cfi) != 0)\n\t\tgoto setup_err;\n\n\t__module_get(THIS_MODULE);\n\tregister_reboot_notifier(&mtd->reboot_notifier);\n\treturn mtd;\n\n setup_err:\n\tif (mtd->eraseregions)\n\t\tfor (i=0; i<cfi->cfiq->NumEraseRegions; i++)\n\t\t\tfor (j=0; j<cfi->numchips; j++)\n\t\t\t\tkfree(mtd->eraseregions[(j*cfi->cfiq->NumEraseRegions)+i].lockmap);\n\tkfree(mtd->eraseregions);\n\tkfree(mtd);\n\tkfree(cfi->cmdset_priv);\n\treturn NULL;\n}\n\nstatic int cfi_intelext_partition_fixup(struct mtd_info *mtd,\n\t\t\t\t\tstruct cfi_private **pcfi)\n{\n\tstruct map_info *map = mtd->priv;\n\tstruct cfi_private *cfi = *pcfi;\n\tstruct cfi_pri_intelext *extp = cfi->cmdset_priv;\n\n\t \n\tif (extp && extp->MajorVersion == '1' && extp->MinorVersion >= '3'\n\t    && extp->FeatureSupport & (1 << 9)) {\n\t\tint offs = 0;\n\t\tstruct cfi_private *newcfi;\n\t\tstruct flchip *chip;\n\t\tstruct flchip_shared *shared;\n\t\tint numregions, numparts, partshift, numvirtchips, i, j;\n\n\t\t \n\t\tif (extp->NumProtectionFields)\n\t\t\toffs = (extp->NumProtectionFields - 1) *\n\t\t\t       sizeof(struct cfi_intelext_otpinfo);\n\n\t\t \n\t\toffs += extp->extra[offs+1]+2;\n\n\t\t \n\t\tnumregions = extp->extra[offs];\n\t\toffs += 1;\n\n\t\t \n\t\tif (extp->MinorVersion >= '4')\n\t\t\toffs += 2;\n\n\t\t \n\t\tnumparts = 0;\n\t\tfor (i = 0; i < numregions; i++) {\n\t\t\tstruct cfi_intelext_regioninfo *rinfo;\n\t\t\trinfo = (struct cfi_intelext_regioninfo *)&extp->extra[offs];\n\t\t\tnumparts += rinfo->NumIdentPartitions;\n\t\t\toffs += sizeof(*rinfo)\n\t\t\t\t+ (rinfo->NumBlockTypes - 1) *\n\t\t\t\t  sizeof(struct cfi_intelext_blockinfo);\n\t\t}\n\n\t\tif (!numparts)\n\t\t\tnumparts = 1;\n\n\t\t \n\t\tif (extp->MinorVersion >= '4') {\n\t\t\tstruct cfi_intelext_programming_regioninfo *prinfo;\n\t\t\tprinfo = (struct cfi_intelext_programming_regioninfo *)&extp->extra[offs];\n\t\t\tmtd->writesize = cfi->interleave << prinfo->ProgRegShift;\n\t\t\tmtd->flags &= ~MTD_BIT_WRITEABLE;\n\t\t\tprintk(KERN_DEBUG \"%s: program region size/ctrl_valid/ctrl_inval = %d/%d/%d\\n\",\n\t\t\t       map->name, mtd->writesize,\n\t\t\t       cfi->interleave * prinfo->ControlValid,\n\t\t\t       cfi->interleave * prinfo->ControlInvalid);\n\t\t}\n\n\t\t \n\t\tpartshift = cfi->chipshift - __ffs(numparts);\n\n\t\tif ((1 << partshift) < mtd->erasesize) {\n\t\t\tprintk( KERN_ERR\n\t\t\t\t\"%s: bad number of hw partitions (%d)\\n\",\n\t\t\t\t__func__, numparts);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tnumvirtchips = cfi->numchips * numparts;\n\t\tnewcfi = kmalloc(struct_size(newcfi, chips, numvirtchips),\n\t\t\t\t GFP_KERNEL);\n\t\tif (!newcfi)\n\t\t\treturn -ENOMEM;\n\t\tshared = kmalloc_array(cfi->numchips,\n\t\t\t\t       sizeof(struct flchip_shared),\n\t\t\t\t       GFP_KERNEL);\n\t\tif (!shared) {\n\t\t\tkfree(newcfi);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tmemcpy(newcfi, cfi, sizeof(struct cfi_private));\n\t\tnewcfi->numchips = numvirtchips;\n\t\tnewcfi->chipshift = partshift;\n\n\t\tchip = &newcfi->chips[0];\n\t\tfor (i = 0; i < cfi->numchips; i++) {\n\t\t\tshared[i].writing = shared[i].erasing = NULL;\n\t\t\tmutex_init(&shared[i].lock);\n\t\t\tfor (j = 0; j < numparts; j++) {\n\t\t\t\t*chip = cfi->chips[i];\n\t\t\t\tchip->start += j << partshift;\n\t\t\t\tchip->priv = &shared[i];\n\t\t\t\t \n\t\t\t\tinit_waitqueue_head(&chip->wq);\n\t\t\t\tmutex_init(&chip->mutex);\n\t\t\t\tchip++;\n\t\t\t}\n\t\t}\n\n\t\tprintk(KERN_DEBUG \"%s: %d set(s) of %d interleaved chips \"\n\t\t\t\t  \"--> %d partitions of %d KiB\\n\",\n\t\t\t\t  map->name, cfi->numchips, cfi->interleave,\n\t\t\t\t  newcfi->numchips, 1<<(newcfi->chipshift-10));\n\n\t\tmap->fldrv_priv = newcfi;\n\t\t*pcfi = newcfi;\n\t\tkfree(cfi);\n\t}\n\n\treturn 0;\n}\n\n \nstatic int chip_ready (struct map_info *map, struct flchip *chip, unsigned long adr, int mode)\n{\n\tDECLARE_WAITQUEUE(wait, current);\n\tstruct cfi_private *cfi = map->fldrv_priv;\n\tmap_word status, status_OK = CMD(0x80), status_PWS = CMD(0x01);\n\tstruct cfi_pri_intelext *cfip = cfi->cmdset_priv;\n\tunsigned long timeo = jiffies + HZ;\n\n\t \n\tif (mode == FL_SYNCING && chip->oldstate != FL_READY)\n\t\tgoto sleep;\n\n\tswitch (chip->state) {\n\n\tcase FL_STATUS:\n\t\tfor (;;) {\n\t\t\tstatus = map_read(map, adr);\n\t\t\tif (map_word_andequal(map, status, status_OK, status_OK))\n\t\t\t\tbreak;\n\n\t\t\t \n\t\t\tif (chip->priv && map_word_andequal(map, status, status_PWS, status_PWS))\n\t\t\t\tbreak;\n\n\t\t\tmutex_unlock(&chip->mutex);\n\t\t\tcfi_udelay(1);\n\t\t\tmutex_lock(&chip->mutex);\n\t\t\t \n\t\t\treturn -EAGAIN;\n\t\t}\n\t\tfallthrough;\n\tcase FL_READY:\n\tcase FL_CFI_QUERY:\n\tcase FL_JEDEC_QUERY:\n\t\treturn 0;\n\n\tcase FL_ERASING:\n\t\tif (!cfip ||\n\t\t    !(cfip->FeatureSupport & 2) ||\n\t\t    !(mode == FL_READY || mode == FL_POINT ||\n\t\t     (mode == FL_WRITING && (cfip->SuspendCmdSupport & 1))))\n\t\t\tgoto sleep;\n\n\t\t \n\t\tif ((adr & chip->in_progress_block_mask) ==\n\t\t    chip->in_progress_block_addr)\n\t\t\tgoto sleep;\n\n\t\t \n\t\tif (cfi_is_micron_28F00AP30(cfi, chip) &&\n\t\t    (chip->in_progress_block_mask == ~(0x8000-1)))\n\t\t\tgoto sleep;\n\n\t\t \n\t\tmap_write(map, CMD(0xB0), chip->in_progress_block_addr);\n\n\t\t \n\t\tmap_write(map, CMD(0x70), chip->in_progress_block_addr);\n\t\tchip->oldstate = FL_ERASING;\n\t\tchip->state = FL_ERASE_SUSPENDING;\n\t\tchip->erase_suspended = 1;\n\t\tfor (;;) {\n\t\t\tstatus = map_read(map, chip->in_progress_block_addr);\n\t\t\tif (map_word_andequal(map, status, status_OK, status_OK))\n\t\t\t        break;\n\n\t\t\tif (time_after(jiffies, timeo)) {\n\t\t\t\t \n\t\t\t\tput_chip(map, chip, adr);\n\t\t\t\tprintk(KERN_ERR \"%s: Chip not ready after erase \"\n\t\t\t\t       \"suspended: status = 0x%lx\\n\", map->name, status.x[0]);\n\t\t\t\treturn -EIO;\n\t\t\t}\n\n\t\t\tmutex_unlock(&chip->mutex);\n\t\t\tcfi_udelay(1);\n\t\t\tmutex_lock(&chip->mutex);\n\t\t\t \n\t\t}\n\t\tchip->state = FL_STATUS;\n\t\treturn 0;\n\n\tcase FL_XIP_WHILE_ERASING:\n\t\tif (mode != FL_READY && mode != FL_POINT &&\n\t\t    (mode != FL_WRITING || !cfip || !(cfip->SuspendCmdSupport&1)))\n\t\t\tgoto sleep;\n\t\tchip->oldstate = chip->state;\n\t\tchip->state = FL_READY;\n\t\treturn 0;\n\n\tcase FL_SHUTDOWN:\n\t\t \n\t\treturn -EIO;\n\tcase FL_POINT:\n\t\t \n\t\tif (mode == FL_READY && chip->oldstate == FL_READY)\n\t\t\treturn 0;\n\t\tfallthrough;\n\tdefault:\n\tsleep:\n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\tadd_wait_queue(&chip->wq, &wait);\n\t\tmutex_unlock(&chip->mutex);\n\t\tschedule();\n\t\tremove_wait_queue(&chip->wq, &wait);\n\t\tmutex_lock(&chip->mutex);\n\t\treturn -EAGAIN;\n\t}\n}\n\nstatic int get_chip(struct map_info *map, struct flchip *chip, unsigned long adr, int mode)\n{\n\tint ret;\n\tDECLARE_WAITQUEUE(wait, current);\n\n retry:\n\tif (chip->priv &&\n\t    (mode == FL_WRITING || mode == FL_ERASING || mode == FL_OTP_WRITE\n\t    || mode == FL_SHUTDOWN) && chip->state != FL_SYNCING) {\n\t\t \n\t\tstruct flchip_shared *shared = chip->priv;\n\t\tstruct flchip *contender;\n\t\tmutex_lock(&shared->lock);\n\t\tcontender = shared->writing;\n\t\tif (contender && contender != chip) {\n\t\t\t \n\t\t\tret = mutex_trylock(&contender->mutex);\n\t\t\tmutex_unlock(&shared->lock);\n\t\t\tif (!ret)\n\t\t\t\tgoto retry;\n\t\t\tmutex_unlock(&chip->mutex);\n\t\t\tret = chip_ready(map, contender, contender->start, mode);\n\t\t\tmutex_lock(&chip->mutex);\n\n\t\t\tif (ret == -EAGAIN) {\n\t\t\t\tmutex_unlock(&contender->mutex);\n\t\t\t\tgoto retry;\n\t\t\t}\n\t\t\tif (ret) {\n\t\t\t\tmutex_unlock(&contender->mutex);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tmutex_lock(&shared->lock);\n\n\t\t\t \n\t\t\tif (chip->state == FL_SYNCING) {\n\t\t\t\tput_chip(map, contender, contender->start);\n\t\t\t\tmutex_unlock(&contender->mutex);\n\t\t\t\tgoto retry;\n\t\t\t}\n\t\t\tmutex_unlock(&contender->mutex);\n\t\t}\n\n\t\t \n\t\tif (mode == FL_ERASING && shared->erasing\n\t\t    && shared->erasing->oldstate == FL_ERASING) {\n\t\t\tmutex_unlock(&shared->lock);\n\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\tadd_wait_queue(&chip->wq, &wait);\n\t\t\tmutex_unlock(&chip->mutex);\n\t\t\tschedule();\n\t\t\tremove_wait_queue(&chip->wq, &wait);\n\t\t\tmutex_lock(&chip->mutex);\n\t\t\tgoto retry;\n\t\t}\n\n\t\t \n\t\tshared->writing = chip;\n\t\tif (mode == FL_ERASING)\n\t\t\tshared->erasing = chip;\n\t\tmutex_unlock(&shared->lock);\n\t}\n\tret = chip_ready(map, chip, adr, mode);\n\tif (ret == -EAGAIN)\n\t\tgoto retry;\n\n\treturn ret;\n}\n\nstatic void put_chip(struct map_info *map, struct flchip *chip, unsigned long adr)\n{\n\tstruct cfi_private *cfi = map->fldrv_priv;\n\n\tif (chip->priv) {\n\t\tstruct flchip_shared *shared = chip->priv;\n\t\tmutex_lock(&shared->lock);\n\t\tif (shared->writing == chip && chip->oldstate == FL_READY) {\n\t\t\t \n\t\t\tshared->writing = shared->erasing;\n\t\t\tif (shared->writing && shared->writing != chip) {\n\t\t\t\t \n\t\t\t\tstruct flchip *loaner = shared->writing;\n\t\t\t\tmutex_lock(&loaner->mutex);\n\t\t\t\tmutex_unlock(&shared->lock);\n\t\t\t\tmutex_unlock(&chip->mutex);\n\t\t\t\tput_chip(map, loaner, loaner->start);\n\t\t\t\tmutex_lock(&chip->mutex);\n\t\t\t\tmutex_unlock(&loaner->mutex);\n\t\t\t\twake_up(&chip->wq);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tshared->erasing = NULL;\n\t\t\tshared->writing = NULL;\n\t\t} else if (shared->erasing == chip && shared->writing != chip) {\n\t\t\t \n\t\t\tmutex_unlock(&shared->lock);\n\t\t\twake_up(&chip->wq);\n\t\t\treturn;\n\t\t}\n\t\tmutex_unlock(&shared->lock);\n\t}\n\n\tswitch(chip->oldstate) {\n\tcase FL_ERASING:\n\t\t \n\t\tmap_write(map, CMD(0xd0), chip->in_progress_block_addr);\n\t\tmap_write(map, CMD(0x70), chip->in_progress_block_addr);\n\t\tchip->oldstate = FL_READY;\n\t\tchip->state = FL_ERASING;\n\t\tbreak;\n\n\tcase FL_XIP_WHILE_ERASING:\n\t\tchip->state = chip->oldstate;\n\t\tchip->oldstate = FL_READY;\n\t\tbreak;\n\n\tcase FL_READY:\n\tcase FL_STATUS:\n\tcase FL_JEDEC_QUERY:\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_ERR \"%s: put_chip() called with oldstate %d!!\\n\", map->name, chip->oldstate);\n\t}\n\twake_up(&chip->wq);\n}\n\n#ifdef CONFIG_MTD_XIP\n\n \n\nstatic void xip_disable(struct map_info *map, struct flchip *chip,\n\t\t\tunsigned long adr)\n{\n\t \n\t(void) map_read(map, adr);  \n\tlocal_irq_disable();\n}\n\nstatic void __xipram xip_enable(struct map_info *map, struct flchip *chip,\n\t\t\t\tunsigned long adr)\n{\n\tstruct cfi_private *cfi = map->fldrv_priv;\n\tif (chip->state != FL_POINT && chip->state != FL_READY) {\n\t\tmap_write(map, CMD(0xff), adr);\n\t\tchip->state = FL_READY;\n\t}\n\t(void) map_read(map, adr);\n\txip_iprefetch();\n\tlocal_irq_enable();\n}\n\n \n\nstatic int __xipram xip_wait_for_operation(\n\t\tstruct map_info *map, struct flchip *chip,\n\t\tunsigned long adr, unsigned int chip_op_time_max)\n{\n\tstruct cfi_private *cfi = map->fldrv_priv;\n\tstruct cfi_pri_intelext *cfip = cfi->cmdset_priv;\n\tmap_word status, OK = CMD(0x80);\n\tunsigned long usec, suspended, start, done;\n\tflstate_t oldstate, newstate;\n\n       \tstart = xip_currtime();\n\tusec = chip_op_time_max;\n\tif (usec == 0)\n\t\tusec = 500000;\n\tdone = 0;\n\n\tdo {\n\t\tcpu_relax();\n\t\tif (xip_irqpending() && cfip &&\n\t\t    ((chip->state == FL_ERASING && (cfip->FeatureSupport&2)) ||\n\t\t     (chip->state == FL_WRITING && (cfip->FeatureSupport&4))) &&\n\t\t    (cfi_interleave_is_1(cfi) || chip->oldstate == FL_READY)) {\n\t\t\t \n\t\t\tusec -= done;\n\t\t\tmap_write(map, CMD(0xb0), adr);\n\t\t\tmap_write(map, CMD(0x70), adr);\n\t\t\tsuspended = xip_currtime();\n\t\t\tdo {\n\t\t\t\tif (xip_elapsed_since(suspended) > 100000) {\n\t\t\t\t\t \n\t\t\t\t\treturn -EIO;\n\t\t\t\t}\n\t\t\t\tstatus = map_read(map, adr);\n\t\t\t} while (!map_word_andequal(map, status, OK, OK));\n\n\t\t\t \n\t\t\toldstate = chip->state;\n\t\t\tif (oldstate == FL_ERASING) {\n\t\t\t\tif (!map_word_bitsset(map, status, CMD(0x40)))\n\t\t\t\t\tbreak;\n\t\t\t\tnewstate = FL_XIP_WHILE_ERASING;\n\t\t\t\tchip->erase_suspended = 1;\n\t\t\t} else {\n\t\t\t\tif (!map_word_bitsset(map, status, CMD(0x04)))\n\t\t\t\t\tbreak;\n\t\t\t\tnewstate = FL_XIP_WHILE_WRITING;\n\t\t\t\tchip->write_suspended = 1;\n\t\t\t}\n\t\t\tchip->state = newstate;\n\t\t\tmap_write(map, CMD(0xff), adr);\n\t\t\t(void) map_read(map, adr);\n\t\t\txip_iprefetch();\n\t\t\tlocal_irq_enable();\n\t\t\tmutex_unlock(&chip->mutex);\n\t\t\txip_iprefetch();\n\t\t\tcond_resched();\n\n\t\t\t \n\t\t\tmutex_lock(&chip->mutex);\n\t\t\twhile (chip->state != newstate) {\n\t\t\t\tDECLARE_WAITQUEUE(wait, current);\n\t\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\t\tadd_wait_queue(&chip->wq, &wait);\n\t\t\t\tmutex_unlock(&chip->mutex);\n\t\t\t\tschedule();\n\t\t\t\tremove_wait_queue(&chip->wq, &wait);\n\t\t\t\tmutex_lock(&chip->mutex);\n\t\t\t}\n\t\t\t \n\t\t\tlocal_irq_disable();\n\n\t\t\t \n\t\t\tmap_write(map, CMD(0xd0), adr);\n\t\t\tmap_write(map, CMD(0x70), adr);\n\t\t\tchip->state = oldstate;\n\t\t\tstart = xip_currtime();\n\t\t} else if (usec >= 1000000/HZ) {\n\t\t\t \n\t\t\txip_cpu_idle();\n\t\t}\n\t\tstatus = map_read(map, adr);\n\t\tdone = xip_elapsed_since(start);\n\t} while (!map_word_andequal(map, status, OK, OK)\n\t\t && done < usec);\n\n\treturn (done >= usec) ? -ETIME : 0;\n}\n\n \n#define XIP_INVAL_CACHED_RANGE(map, from, size)  \\\n\tINVALIDATE_CACHED_RANGE(map, from, size)\n\n#define INVAL_CACHE_AND_WAIT(map, chip, cmd_adr, inval_adr, inval_len, usec, usec_max) \\\n\txip_wait_for_operation(map, chip, cmd_adr, usec_max)\n\n#else\n\n#define xip_disable(map, chip, adr)\n#define xip_enable(map, chip, adr)\n#define XIP_INVAL_CACHED_RANGE(x...)\n#define INVAL_CACHE_AND_WAIT inval_cache_and_wait_for_operation\n\nstatic int inval_cache_and_wait_for_operation(\n\t\tstruct map_info *map, struct flchip *chip,\n\t\tunsigned long cmd_adr, unsigned long inval_adr, int inval_len,\n\t\tunsigned int chip_op_time, unsigned int chip_op_time_max)\n{\n\tstruct cfi_private *cfi = map->fldrv_priv;\n\tmap_word status, status_OK = CMD(0x80);\n\tint chip_state = chip->state;\n\tunsigned int timeo, sleep_time, reset_timeo;\n\n\tmutex_unlock(&chip->mutex);\n\tif (inval_len)\n\t\tINVALIDATE_CACHED_RANGE(map, inval_adr, inval_len);\n\tmutex_lock(&chip->mutex);\n\n\ttimeo = chip_op_time_max;\n\tif (!timeo)\n\t\ttimeo = 500000;\n\treset_timeo = timeo;\n\tsleep_time = chip_op_time / 2;\n\n\tfor (;;) {\n\t\tif (chip->state != chip_state) {\n\t\t\t \n\t\t\tDECLARE_WAITQUEUE(wait, current);\n\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\tadd_wait_queue(&chip->wq, &wait);\n\t\t\tmutex_unlock(&chip->mutex);\n\t\t\tschedule();\n\t\t\tremove_wait_queue(&chip->wq, &wait);\n\t\t\tmutex_lock(&chip->mutex);\n\t\t\tcontinue;\n\t\t}\n\n\t\tstatus = map_read(map, cmd_adr);\n\t\tif (map_word_andequal(map, status, status_OK, status_OK))\n\t\t\tbreak;\n\n\t\tif (chip->erase_suspended && chip_state == FL_ERASING)  {\n\t\t\t \n\t\t\ttimeo = reset_timeo;\n\t\t\tchip->erase_suspended = 0;\n\t\t}\n\t\tif (chip->write_suspended && chip_state == FL_WRITING)  {\n\t\t\t \n\t\t\ttimeo = reset_timeo;\n\t\t\tchip->write_suspended = 0;\n\t\t}\n\t\tif (!timeo) {\n\t\t\tmap_write(map, CMD(0x70), cmd_adr);\n\t\t\tchip->state = FL_STATUS;\n\t\t\treturn -ETIME;\n\t\t}\n\n\t\t \n\t\tmutex_unlock(&chip->mutex);\n\t\tif (sleep_time >= 1000000/HZ) {\n\t\t\t \n\t\t\tmsleep(sleep_time/1000);\n\t\t\ttimeo -= sleep_time;\n\t\t\tsleep_time = 1000000/HZ;\n\t\t} else {\n\t\t\tudelay(1);\n\t\t\tcond_resched();\n\t\t\ttimeo--;\n\t\t}\n\t\tmutex_lock(&chip->mutex);\n\t}\n\n\t \n \tchip->state = FL_STATUS;\n\treturn 0;\n}\n\n#endif\n\n#define WAIT_TIMEOUT(map, chip, adr, udelay, udelay_max) \\\n\tINVAL_CACHE_AND_WAIT(map, chip, adr, 0, 0, udelay, udelay_max);\n\n\nstatic int do_point_onechip (struct map_info *map, struct flchip *chip, loff_t adr, size_t len)\n{\n\tunsigned long cmd_addr;\n\tstruct cfi_private *cfi = map->fldrv_priv;\n\tint ret;\n\n\tadr += chip->start;\n\n\t \n\tcmd_addr = adr & ~(map_bankwidth(map)-1);\n\n\tmutex_lock(&chip->mutex);\n\n\tret = get_chip(map, chip, cmd_addr, FL_POINT);\n\n\tif (!ret) {\n\t\tif (chip->state != FL_POINT && chip->state != FL_READY)\n\t\t\tmap_write(map, CMD(0xff), cmd_addr);\n\n\t\tchip->state = FL_POINT;\n\t\tchip->ref_point_counter++;\n\t}\n\tmutex_unlock(&chip->mutex);\n\n\treturn ret;\n}\n\nstatic int cfi_intelext_point(struct mtd_info *mtd, loff_t from, size_t len,\n\t\tsize_t *retlen, void **virt, resource_size_t *phys)\n{\n\tstruct map_info *map = mtd->priv;\n\tstruct cfi_private *cfi = map->fldrv_priv;\n\tunsigned long ofs, last_end = 0;\n\tint chipnum;\n\tint ret;\n\n\tif (!map->virt)\n\t\treturn -EINVAL;\n\n\t \n\n\t \n\tchipnum = (from >> cfi->chipshift);\n\tofs = from - (chipnum << cfi->chipshift);\n\n\t*virt = map->virt + cfi->chips[chipnum].start + ofs;\n\tif (phys)\n\t\t*phys = map->phys + cfi->chips[chipnum].start + ofs;\n\n\twhile (len) {\n\t\tunsigned long thislen;\n\n\t\tif (chipnum >= cfi->numchips)\n\t\t\tbreak;\n\n\t\t \n\t\tif (!last_end)\n\t\t\tlast_end = cfi->chips[chipnum].start;\n\t\telse if (cfi->chips[chipnum].start != last_end)\n\t\t\tbreak;\n\n\t\tif ((len + ofs -1) >> cfi->chipshift)\n\t\t\tthislen = (1<<cfi->chipshift) - ofs;\n\t\telse\n\t\t\tthislen = len;\n\n\t\tret = do_point_onechip(map, &cfi->chips[chipnum], ofs, thislen);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\t*retlen += thislen;\n\t\tlen -= thislen;\n\n\t\tofs = 0;\n\t\tlast_end += 1 << cfi->chipshift;\n\t\tchipnum++;\n\t}\n\treturn 0;\n}\n\nstatic int cfi_intelext_unpoint(struct mtd_info *mtd, loff_t from, size_t len)\n{\n\tstruct map_info *map = mtd->priv;\n\tstruct cfi_private *cfi = map->fldrv_priv;\n\tunsigned long ofs;\n\tint chipnum, err = 0;\n\n\t \n\n\t \n\tchipnum = (from >> cfi->chipshift);\n\tofs = from - (chipnum <<  cfi->chipshift);\n\n\twhile (len && !err) {\n\t\tunsigned long thislen;\n\t\tstruct flchip *chip;\n\n\t\tchip = &cfi->chips[chipnum];\n\t\tif (chipnum >= cfi->numchips)\n\t\t\tbreak;\n\n\t\tif ((len + ofs -1) >> cfi->chipshift)\n\t\t\tthislen = (1<<cfi->chipshift) - ofs;\n\t\telse\n\t\t\tthislen = len;\n\n\t\tmutex_lock(&chip->mutex);\n\t\tif (chip->state == FL_POINT) {\n\t\t\tchip->ref_point_counter--;\n\t\t\tif(chip->ref_point_counter == 0)\n\t\t\t\tchip->state = FL_READY;\n\t\t} else {\n\t\t\tprintk(KERN_ERR \"%s: Error: unpoint called on non pointed region\\n\", map->name);\n\t\t\terr = -EINVAL;\n\t\t}\n\n\t\tput_chip(map, chip, chip->start);\n\t\tmutex_unlock(&chip->mutex);\n\n\t\tlen -= thislen;\n\t\tofs = 0;\n\t\tchipnum++;\n\t}\n\n\treturn err;\n}\n\nstatic inline int do_read_onechip(struct map_info *map, struct flchip *chip, loff_t adr, size_t len, u_char *buf)\n{\n\tunsigned long cmd_addr;\n\tstruct cfi_private *cfi = map->fldrv_priv;\n\tint ret;\n\n\tadr += chip->start;\n\n\t \n\tcmd_addr = adr & ~(map_bankwidth(map)-1);\n\n\tmutex_lock(&chip->mutex);\n\tret = get_chip(map, chip, cmd_addr, FL_READY);\n\tif (ret) {\n\t\tmutex_unlock(&chip->mutex);\n\t\treturn ret;\n\t}\n\n\tif (chip->state != FL_POINT && chip->state != FL_READY) {\n\t\tmap_write(map, CMD(0xff), cmd_addr);\n\n\t\tchip->state = FL_READY;\n\t}\n\n\tmap_copy_from(map, buf, adr, len);\n\n\tput_chip(map, chip, cmd_addr);\n\n\tmutex_unlock(&chip->mutex);\n\treturn 0;\n}\n\nstatic int cfi_intelext_read (struct mtd_info *mtd, loff_t from, size_t len, size_t *retlen, u_char *buf)\n{\n\tstruct map_info *map = mtd->priv;\n\tstruct cfi_private *cfi = map->fldrv_priv;\n\tunsigned long ofs;\n\tint chipnum;\n\tint ret = 0;\n\n\t \n\tchipnum = (from >> cfi->chipshift);\n\tofs = from - (chipnum <<  cfi->chipshift);\n\n\twhile (len) {\n\t\tunsigned long thislen;\n\n\t\tif (chipnum >= cfi->numchips)\n\t\t\tbreak;\n\n\t\tif ((len + ofs -1) >> cfi->chipshift)\n\t\t\tthislen = (1<<cfi->chipshift) - ofs;\n\t\telse\n\t\t\tthislen = len;\n\n\t\tret = do_read_onechip(map, &cfi->chips[chipnum], ofs, thislen, buf);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\t*retlen += thislen;\n\t\tlen -= thislen;\n\t\tbuf += thislen;\n\n\t\tofs = 0;\n\t\tchipnum++;\n\t}\n\treturn ret;\n}\n\nstatic int __xipram do_write_oneword(struct map_info *map, struct flchip *chip,\n\t\t\t\t     unsigned long adr, map_word datum, int mode)\n{\n\tstruct cfi_private *cfi = map->fldrv_priv;\n\tmap_word status, write_cmd;\n\tint ret;\n\n\tadr += chip->start;\n\n\tswitch (mode) {\n\tcase FL_WRITING:\n\t\twrite_cmd = (cfi->cfiq->P_ID != P_ID_INTEL_PERFORMANCE) ? CMD(0x40) : CMD(0x41);\n\t\tbreak;\n\tcase FL_OTP_WRITE:\n\t\twrite_cmd = CMD(0xc0);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&chip->mutex);\n\tret = get_chip(map, chip, adr, mode);\n\tif (ret) {\n\t\tmutex_unlock(&chip->mutex);\n\t\treturn ret;\n\t}\n\n\tXIP_INVAL_CACHED_RANGE(map, adr, map_bankwidth(map));\n\tENABLE_VPP(map);\n\txip_disable(map, chip, adr);\n\tmap_write(map, write_cmd, adr);\n\tmap_write(map, datum, adr);\n\tchip->state = mode;\n\n\tret = INVAL_CACHE_AND_WAIT(map, chip, adr,\n\t\t\t\t   adr, map_bankwidth(map),\n\t\t\t\t   chip->word_write_time,\n\t\t\t\t   chip->word_write_time_max);\n\tif (ret) {\n\t\txip_enable(map, chip, adr);\n\t\tprintk(KERN_ERR \"%s: word write error (status timeout)\\n\", map->name);\n\t\tgoto out;\n\t}\n\n\t \n\tstatus = map_read(map, adr);\n\tif (map_word_bitsset(map, status, CMD(0x1a))) {\n\t\tunsigned long chipstatus = MERGESTATUS(status);\n\n\t\t \n\t\tmap_write(map, CMD(0x50), adr);\n\t\tmap_write(map, CMD(0x70), adr);\n\t\txip_enable(map, chip, adr);\n\n\t\tif (chipstatus & 0x02) {\n\t\t\tret = -EROFS;\n\t\t} else if (chipstatus & 0x08) {\n\t\t\tprintk(KERN_ERR \"%s: word write error (bad VPP)\\n\", map->name);\n\t\t\tret = -EIO;\n\t\t} else {\n\t\t\tprintk(KERN_ERR \"%s: word write error (status 0x%lx)\\n\", map->name, chipstatus);\n\t\t\tret = -EINVAL;\n\t\t}\n\n\t\tgoto out;\n\t}\n\n\txip_enable(map, chip, adr);\n out:\tDISABLE_VPP(map);\n\tput_chip(map, chip, adr);\n\tmutex_unlock(&chip->mutex);\n\treturn ret;\n}\n\n\nstatic int cfi_intelext_write_words (struct mtd_info *mtd, loff_t to , size_t len, size_t *retlen, const u_char *buf)\n{\n\tstruct map_info *map = mtd->priv;\n\tstruct cfi_private *cfi = map->fldrv_priv;\n\tint ret;\n\tint chipnum;\n\tunsigned long ofs;\n\n\tchipnum = to >> cfi->chipshift;\n\tofs = to  - (chipnum << cfi->chipshift);\n\n\t \n\tif (ofs & (map_bankwidth(map)-1)) {\n\t\tunsigned long bus_ofs = ofs & ~(map_bankwidth(map)-1);\n\t\tint gap = ofs - bus_ofs;\n\t\tint n;\n\t\tmap_word datum;\n\n\t\tn = min_t(int, len, map_bankwidth(map)-gap);\n\t\tdatum = map_word_ff(map);\n\t\tdatum = map_word_load_partial(map, datum, buf, gap, n);\n\n\t\tret = do_write_oneword(map, &cfi->chips[chipnum],\n\t\t\t\t\t       bus_ofs, datum, FL_WRITING);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tlen -= n;\n\t\tofs += n;\n\t\tbuf += n;\n\t\t(*retlen) += n;\n\n\t\tif (ofs >> cfi->chipshift) {\n\t\t\tchipnum ++;\n\t\t\tofs = 0;\n\t\t\tif (chipnum == cfi->numchips)\n\t\t\t\treturn 0;\n\t\t}\n\t}\n\n\twhile(len >= map_bankwidth(map)) {\n\t\tmap_word datum = map_word_load(map, buf);\n\n\t\tret = do_write_oneword(map, &cfi->chips[chipnum],\n\t\t\t\t       ofs, datum, FL_WRITING);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tofs += map_bankwidth(map);\n\t\tbuf += map_bankwidth(map);\n\t\t(*retlen) += map_bankwidth(map);\n\t\tlen -= map_bankwidth(map);\n\n\t\tif (ofs >> cfi->chipshift) {\n\t\t\tchipnum ++;\n\t\t\tofs = 0;\n\t\t\tif (chipnum == cfi->numchips)\n\t\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (len & (map_bankwidth(map)-1)) {\n\t\tmap_word datum;\n\n\t\tdatum = map_word_ff(map);\n\t\tdatum = map_word_load_partial(map, datum, buf, 0, len);\n\n\t\tret = do_write_oneword(map, &cfi->chips[chipnum],\n\t\t\t\t       ofs, datum, FL_WRITING);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t(*retlen) += len;\n\t}\n\n\treturn 0;\n}\n\n\nstatic int __xipram do_write_buffer(struct map_info *map, struct flchip *chip,\n\t\t\t\t    unsigned long adr, const struct kvec **pvec,\n\t\t\t\t    unsigned long *pvec_seek, int len)\n{\n\tstruct cfi_private *cfi = map->fldrv_priv;\n\tmap_word status, write_cmd, datum;\n\tunsigned long cmd_adr;\n\tint ret, wbufsize, word_gap, words;\n\tconst struct kvec *vec;\n\tunsigned long vec_seek;\n\tunsigned long initial_adr;\n\tint initial_len = len;\n\n\twbufsize = cfi_interleave(cfi) << cfi->cfiq->MaxBufWriteSize;\n\tadr += chip->start;\n\tinitial_adr = adr;\n\tcmd_adr = adr & ~(wbufsize-1);\n\n\t \n\tif (is_LH28F640BF(cfi))\n\t\tcmd_adr = adr;\n\n\t \n\twrite_cmd = (cfi->cfiq->P_ID != P_ID_INTEL_PERFORMANCE) ? CMD(0xe8) : CMD(0xe9);\n\n\tmutex_lock(&chip->mutex);\n\tret = get_chip(map, chip, cmd_adr, FL_WRITING);\n\tif (ret) {\n\t\tmutex_unlock(&chip->mutex);\n\t\treturn ret;\n\t}\n\n\tXIP_INVAL_CACHED_RANGE(map, initial_adr, initial_len);\n\tENABLE_VPP(map);\n\txip_disable(map, chip, cmd_adr);\n\n\t \n\tif (chip->state != FL_STATUS) {\n\t\tmap_write(map, CMD(0x70), cmd_adr);\n\t\tchip->state = FL_STATUS;\n\t}\n\tstatus = map_read(map, cmd_adr);\n\tif (map_word_bitsset(map, status, CMD(0x30))) {\n\t\txip_enable(map, chip, cmd_adr);\n\t\tprintk(KERN_WARNING \"SR.4 or SR.5 bits set in buffer write (status %lx). Clearing.\\n\", status.x[0]);\n\t\txip_disable(map, chip, cmd_adr);\n\t\tmap_write(map, CMD(0x50), cmd_adr);\n\t\tmap_write(map, CMD(0x70), cmd_adr);\n\t}\n\n\tchip->state = FL_WRITING_TO_BUFFER;\n\tmap_write(map, write_cmd, cmd_adr);\n\tret = WAIT_TIMEOUT(map, chip, cmd_adr, 0, 0);\n\tif (ret) {\n\t\t \n\t\tmap_word Xstatus = map_read(map, cmd_adr);\n\t\tmap_write(map, CMD(0x70), cmd_adr);\n\t\tchip->state = FL_STATUS;\n\t\tstatus = map_read(map, cmd_adr);\n\t\tmap_write(map, CMD(0x50), cmd_adr);\n\t\tmap_write(map, CMD(0x70), cmd_adr);\n\t\txip_enable(map, chip, cmd_adr);\n\t\tprintk(KERN_ERR \"%s: Chip not ready for buffer write. Xstatus = %lx, status = %lx\\n\",\n\t\t\t\tmap->name, Xstatus.x[0], status.x[0]);\n\t\tgoto out;\n\t}\n\n\t \n\tword_gap = (-adr & (map_bankwidth(map)-1));\n\twords = DIV_ROUND_UP(len - word_gap, map_bankwidth(map));\n\tif (!word_gap) {\n\t\twords--;\n\t} else {\n\t\tword_gap = map_bankwidth(map) - word_gap;\n\t\tadr -= word_gap;\n\t\tdatum = map_word_ff(map);\n\t}\n\n\t \n\tmap_write(map, CMD(words), cmd_adr );\n\n\t \n\tvec = *pvec;\n\tvec_seek = *pvec_seek;\n\tdo {\n\t\tint n = map_bankwidth(map) - word_gap;\n\t\tif (n > vec->iov_len - vec_seek)\n\t\t\tn = vec->iov_len - vec_seek;\n\t\tif (n > len)\n\t\t\tn = len;\n\n\t\tif (!word_gap && len < map_bankwidth(map))\n\t\t\tdatum = map_word_ff(map);\n\n\t\tdatum = map_word_load_partial(map, datum,\n\t\t\t\t\t      vec->iov_base + vec_seek,\n\t\t\t\t\t      word_gap, n);\n\n\t\tlen -= n;\n\t\tword_gap += n;\n\t\tif (!len || word_gap == map_bankwidth(map)) {\n\t\t\tmap_write(map, datum, adr);\n\t\t\tadr += map_bankwidth(map);\n\t\t\tword_gap = 0;\n\t\t}\n\n\t\tvec_seek += n;\n\t\tif (vec_seek == vec->iov_len) {\n\t\t\tvec++;\n\t\t\tvec_seek = 0;\n\t\t}\n\t} while (len);\n\t*pvec = vec;\n\t*pvec_seek = vec_seek;\n\n\t \n\tmap_write(map, CMD(0xd0), cmd_adr);\n\tchip->state = FL_WRITING;\n\n\tret = INVAL_CACHE_AND_WAIT(map, chip, cmd_adr,\n\t\t\t\t   initial_adr, initial_len,\n\t\t\t\t   chip->buffer_write_time,\n\t\t\t\t   chip->buffer_write_time_max);\n\tif (ret) {\n\t\tmap_write(map, CMD(0x70), cmd_adr);\n\t\tchip->state = FL_STATUS;\n\t\txip_enable(map, chip, cmd_adr);\n\t\tprintk(KERN_ERR \"%s: buffer write error (status timeout)\\n\", map->name);\n\t\tgoto out;\n\t}\n\n\t \n\tstatus = map_read(map, cmd_adr);\n\tif (map_word_bitsset(map, status, CMD(0x1a))) {\n\t\tunsigned long chipstatus = MERGESTATUS(status);\n\n\t\t \n\t\tmap_write(map, CMD(0x50), cmd_adr);\n\t\tmap_write(map, CMD(0x70), cmd_adr);\n\t\txip_enable(map, chip, cmd_adr);\n\n\t\tif (chipstatus & 0x02) {\n\t\t\tret = -EROFS;\n\t\t} else if (chipstatus & 0x08) {\n\t\t\tprintk(KERN_ERR \"%s: buffer write error (bad VPP)\\n\", map->name);\n\t\t\tret = -EIO;\n\t\t} else {\n\t\t\tprintk(KERN_ERR \"%s: buffer write error (status 0x%lx)\\n\", map->name, chipstatus);\n\t\t\tret = -EINVAL;\n\t\t}\n\n\t\tgoto out;\n\t}\n\n\txip_enable(map, chip, cmd_adr);\n out:\tDISABLE_VPP(map);\n\tput_chip(map, chip, cmd_adr);\n\tmutex_unlock(&chip->mutex);\n\treturn ret;\n}\n\nstatic int cfi_intelext_writev (struct mtd_info *mtd, const struct kvec *vecs,\n\t\t\t\tunsigned long count, loff_t to, size_t *retlen)\n{\n\tstruct map_info *map = mtd->priv;\n\tstruct cfi_private *cfi = map->fldrv_priv;\n\tint wbufsize = cfi_interleave(cfi) << cfi->cfiq->MaxBufWriteSize;\n\tint ret;\n\tint chipnum;\n\tunsigned long ofs, vec_seek, i;\n\tsize_t len = 0;\n\n\tfor (i = 0; i < count; i++)\n\t\tlen += vecs[i].iov_len;\n\n\tif (!len)\n\t\treturn 0;\n\n\tchipnum = to >> cfi->chipshift;\n\tofs = to - (chipnum << cfi->chipshift);\n\tvec_seek = 0;\n\n\tdo {\n\t\t \n\t\tint size = wbufsize - (ofs & (wbufsize-1));\n\n\t\tif (size > len)\n\t\t\tsize = len;\n\t\tret = do_write_buffer(map, &cfi->chips[chipnum],\n\t\t\t\t      ofs, &vecs, &vec_seek, size);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tofs += size;\n\t\t(*retlen) += size;\n\t\tlen -= size;\n\n\t\tif (ofs >> cfi->chipshift) {\n\t\t\tchipnum ++;\n\t\t\tofs = 0;\n\t\t\tif (chipnum == cfi->numchips)\n\t\t\t\treturn 0;\n\t\t}\n\n\t\t \n\t\tcond_resched();\n\n\t} while (len);\n\n\treturn 0;\n}\n\nstatic int cfi_intelext_write_buffers (struct mtd_info *mtd, loff_t to,\n\t\t\t\t       size_t len, size_t *retlen, const u_char *buf)\n{\n\tstruct kvec vec;\n\n\tvec.iov_base = (void *) buf;\n\tvec.iov_len = len;\n\n\treturn cfi_intelext_writev(mtd, &vec, 1, to, retlen);\n}\n\nstatic int __xipram do_erase_oneblock(struct map_info *map, struct flchip *chip,\n\t\t\t\t      unsigned long adr, int len, void *thunk)\n{\n\tstruct cfi_private *cfi = map->fldrv_priv;\n\tmap_word status;\n\tint retries = 3;\n\tint ret;\n\n\tadr += chip->start;\n\n retry:\n\tmutex_lock(&chip->mutex);\n\tret = get_chip(map, chip, adr, FL_ERASING);\n\tif (ret) {\n\t\tmutex_unlock(&chip->mutex);\n\t\treturn ret;\n\t}\n\n\tXIP_INVAL_CACHED_RANGE(map, adr, len);\n\tENABLE_VPP(map);\n\txip_disable(map, chip, adr);\n\n\t \n\tmap_write(map, CMD(0x50), adr);\n\n\t \n\tmap_write(map, CMD(0x20), adr);\n\tmap_write(map, CMD(0xD0), adr);\n\tchip->state = FL_ERASING;\n\tchip->erase_suspended = 0;\n\tchip->in_progress_block_addr = adr;\n\tchip->in_progress_block_mask = ~(len - 1);\n\n\tret = INVAL_CACHE_AND_WAIT(map, chip, adr,\n\t\t\t\t   adr, len,\n\t\t\t\t   chip->erase_time,\n\t\t\t\t   chip->erase_time_max);\n\tif (ret) {\n\t\tmap_write(map, CMD(0x70), adr);\n\t\tchip->state = FL_STATUS;\n\t\txip_enable(map, chip, adr);\n\t\tprintk(KERN_ERR \"%s: block erase error: (status timeout)\\n\", map->name);\n\t\tgoto out;\n\t}\n\n\t \n\tmap_write(map, CMD(0x70), adr);\n\tchip->state = FL_STATUS;\n\tstatus = map_read(map, adr);\n\n\t \n\tif (map_word_bitsset(map, status, CMD(0x3a))) {\n\t\tunsigned long chipstatus = MERGESTATUS(status);\n\n\t\t \n\t\tmap_write(map, CMD(0x50), adr);\n\t\tmap_write(map, CMD(0x70), adr);\n\t\txip_enable(map, chip, adr);\n\n\t\tif ((chipstatus & 0x30) == 0x30) {\n\t\t\tprintk(KERN_ERR \"%s: block erase error: (bad command sequence, status 0x%lx)\\n\", map->name, chipstatus);\n\t\t\tret = -EINVAL;\n\t\t} else if (chipstatus & 0x02) {\n\t\t\t \n\t\t\tret = -EROFS;\n\t\t} else if (chipstatus & 0x8) {\n\t\t\t \n\t\t\tprintk(KERN_ERR \"%s: block erase error: (bad VPP)\\n\", map->name);\n\t\t\tret = -EIO;\n\t\t} else if (chipstatus & 0x20 && retries--) {\n\t\t\tprintk(KERN_DEBUG \"block erase failed at 0x%08lx: status 0x%lx. Retrying...\\n\", adr, chipstatus);\n\t\t\tDISABLE_VPP(map);\n\t\t\tput_chip(map, chip, adr);\n\t\t\tmutex_unlock(&chip->mutex);\n\t\t\tgoto retry;\n\t\t} else {\n\t\t\tprintk(KERN_ERR \"%s: block erase failed at 0x%08lx (status 0x%lx)\\n\", map->name, adr, chipstatus);\n\t\t\tret = -EIO;\n\t\t}\n\n\t\tgoto out;\n\t}\n\n\txip_enable(map, chip, adr);\n out:\tDISABLE_VPP(map);\n\tput_chip(map, chip, adr);\n\tmutex_unlock(&chip->mutex);\n\treturn ret;\n}\n\nstatic int cfi_intelext_erase_varsize(struct mtd_info *mtd, struct erase_info *instr)\n{\n\treturn cfi_varsize_frob(mtd, do_erase_oneblock, instr->addr,\n\t\t\t\tinstr->len, NULL);\n}\n\nstatic void cfi_intelext_sync (struct mtd_info *mtd)\n{\n\tstruct map_info *map = mtd->priv;\n\tstruct cfi_private *cfi = map->fldrv_priv;\n\tint i;\n\tstruct flchip *chip;\n\tint ret = 0;\n\n\tfor (i=0; !ret && i<cfi->numchips; i++) {\n\t\tchip = &cfi->chips[i];\n\n\t\tmutex_lock(&chip->mutex);\n\t\tret = get_chip(map, chip, chip->start, FL_SYNCING);\n\n\t\tif (!ret) {\n\t\t\tchip->oldstate = chip->state;\n\t\t\tchip->state = FL_SYNCING;\n\t\t\t \n\t\t}\n\t\tmutex_unlock(&chip->mutex);\n\t}\n\n\t \n\n\tfor (i--; i >=0; i--) {\n\t\tchip = &cfi->chips[i];\n\n\t\tmutex_lock(&chip->mutex);\n\n\t\tif (chip->state == FL_SYNCING) {\n\t\t\tchip->state = chip->oldstate;\n\t\t\tchip->oldstate = FL_READY;\n\t\t\twake_up(&chip->wq);\n\t\t}\n\t\tmutex_unlock(&chip->mutex);\n\t}\n}\n\nstatic int __xipram do_getlockstatus_oneblock(struct map_info *map,\n\t\t\t\t\t\tstruct flchip *chip,\n\t\t\t\t\t\tunsigned long adr,\n\t\t\t\t\t\tint len, void *thunk)\n{\n\tstruct cfi_private *cfi = map->fldrv_priv;\n\tint status, ofs_factor = cfi->interleave * cfi->device_type;\n\n\tadr += chip->start;\n\txip_disable(map, chip, adr+(2*ofs_factor));\n\tmap_write(map, CMD(0x90), adr+(2*ofs_factor));\n\tchip->state = FL_JEDEC_QUERY;\n\tstatus = cfi_read_query(map, adr+(2*ofs_factor));\n\txip_enable(map, chip, 0);\n\treturn status;\n}\n\n#ifdef DEBUG_LOCK_BITS\nstatic int __xipram do_printlockstatus_oneblock(struct map_info *map,\n\t\t\t\t\t\tstruct flchip *chip,\n\t\t\t\t\t\tunsigned long adr,\n\t\t\t\t\t\tint len, void *thunk)\n{\n\tprintk(KERN_DEBUG \"block status register for 0x%08lx is %x\\n\",\n\t       adr, do_getlockstatus_oneblock(map, chip, adr, len, thunk));\n\treturn 0;\n}\n#endif\n\n#define DO_XXLOCK_ONEBLOCK_LOCK\t\t((void *) 1)\n#define DO_XXLOCK_ONEBLOCK_UNLOCK\t((void *) 2)\n\nstatic int __xipram do_xxlock_oneblock(struct map_info *map, struct flchip *chip,\n\t\t\t\t       unsigned long adr, int len, void *thunk)\n{\n\tstruct cfi_private *cfi = map->fldrv_priv;\n\tstruct cfi_pri_intelext *extp = cfi->cmdset_priv;\n\tint mdelay;\n\tint ret;\n\n\tadr += chip->start;\n\n\tmutex_lock(&chip->mutex);\n\tret = get_chip(map, chip, adr, FL_LOCKING);\n\tif (ret) {\n\t\tmutex_unlock(&chip->mutex);\n\t\treturn ret;\n\t}\n\n\tENABLE_VPP(map);\n\txip_disable(map, chip, adr);\n\n\tmap_write(map, CMD(0x60), adr);\n\tif (thunk == DO_XXLOCK_ONEBLOCK_LOCK) {\n\t\tmap_write(map, CMD(0x01), adr);\n\t\tchip->state = FL_LOCKING;\n\t} else if (thunk == DO_XXLOCK_ONEBLOCK_UNLOCK) {\n\t\tmap_write(map, CMD(0xD0), adr);\n\t\tchip->state = FL_UNLOCKING;\n\t} else\n\t\tBUG();\n\n\t \n\t \n\tmdelay = (!extp || !(extp->FeatureSupport & (1 << 5))) ? 1500 : 0;\n\n\tret = WAIT_TIMEOUT(map, chip, adr, mdelay, mdelay * 1000);\n\tif (ret) {\n\t\tmap_write(map, CMD(0x70), adr);\n\t\tchip->state = FL_STATUS;\n\t\txip_enable(map, chip, adr);\n\t\tprintk(KERN_ERR \"%s: block unlock error: (status timeout)\\n\", map->name);\n\t\tgoto out;\n\t}\n\n\txip_enable(map, chip, adr);\n out:\tDISABLE_VPP(map);\n\tput_chip(map, chip, adr);\n\tmutex_unlock(&chip->mutex);\n\treturn ret;\n}\n\nstatic int cfi_intelext_lock(struct mtd_info *mtd, loff_t ofs, uint64_t len)\n{\n\tint ret;\n\n#ifdef DEBUG_LOCK_BITS\n\tprintk(KERN_DEBUG \"%s: lock status before, ofs=0x%08llx, len=0x%08X\\n\",\n\t       __func__, ofs, len);\n\tcfi_varsize_frob(mtd, do_printlockstatus_oneblock,\n\t\tofs, len, NULL);\n#endif\n\n\tret = cfi_varsize_frob(mtd, do_xxlock_oneblock,\n\t\tofs, len, DO_XXLOCK_ONEBLOCK_LOCK);\n\n#ifdef DEBUG_LOCK_BITS\n\tprintk(KERN_DEBUG \"%s: lock status after, ret=%d\\n\",\n\t       __func__, ret);\n\tcfi_varsize_frob(mtd, do_printlockstatus_oneblock,\n\t\tofs, len, NULL);\n#endif\n\n\treturn ret;\n}\n\nstatic int cfi_intelext_unlock(struct mtd_info *mtd, loff_t ofs, uint64_t len)\n{\n\tint ret;\n\n#ifdef DEBUG_LOCK_BITS\n\tprintk(KERN_DEBUG \"%s: lock status before, ofs=0x%08llx, len=0x%08X\\n\",\n\t       __func__, ofs, len);\n\tcfi_varsize_frob(mtd, do_printlockstatus_oneblock,\n\t\tofs, len, NULL);\n#endif\n\n\tret = cfi_varsize_frob(mtd, do_xxlock_oneblock,\n\t\t\t\t\tofs, len, DO_XXLOCK_ONEBLOCK_UNLOCK);\n\n#ifdef DEBUG_LOCK_BITS\n\tprintk(KERN_DEBUG \"%s: lock status after, ret=%d\\n\",\n\t       __func__, ret);\n\tcfi_varsize_frob(mtd, do_printlockstatus_oneblock,\n\t\tofs, len, NULL);\n#endif\n\n\treturn ret;\n}\n\nstatic int cfi_intelext_is_locked(struct mtd_info *mtd, loff_t ofs,\n\t\t\t\t  uint64_t len)\n{\n\treturn cfi_varsize_frob(mtd, do_getlockstatus_oneblock,\n\t\t\t\tofs, len, NULL) ? 1 : 0;\n}\n\n#ifdef CONFIG_MTD_OTP\n\ntypedef int (*otp_op_t)(struct map_info *map, struct flchip *chip,\n\t\t\tu_long data_offset, u_char *buf, u_int size,\n\t\t\tu_long prot_offset, u_int groupno, u_int groupsize);\n\nstatic int __xipram\ndo_otp_read(struct map_info *map, struct flchip *chip, u_long offset,\n\t    u_char *buf, u_int size, u_long prot, u_int grpno, u_int grpsz)\n{\n\tstruct cfi_private *cfi = map->fldrv_priv;\n\tint ret;\n\n\tmutex_lock(&chip->mutex);\n\tret = get_chip(map, chip, chip->start, FL_JEDEC_QUERY);\n\tif (ret) {\n\t\tmutex_unlock(&chip->mutex);\n\t\treturn ret;\n\t}\n\n\t \n\tINVALIDATE_CACHED_RANGE(map, chip->start + offset, size);\n\n\txip_disable(map, chip, chip->start);\n\tif (chip->state != FL_JEDEC_QUERY) {\n\t\tmap_write(map, CMD(0x90), chip->start);\n\t\tchip->state = FL_JEDEC_QUERY;\n\t}\n\tmap_copy_from(map, buf, chip->start + offset, size);\n\txip_enable(map, chip, chip->start);\n\n\t \n\tINVALIDATE_CACHED_RANGE(map, chip->start + offset, size);\n\n\tput_chip(map, chip, chip->start);\n\tmutex_unlock(&chip->mutex);\n\treturn 0;\n}\n\nstatic int\ndo_otp_write(struct map_info *map, struct flchip *chip, u_long offset,\n\t     u_char *buf, u_int size, u_long prot, u_int grpno, u_int grpsz)\n{\n\tint ret;\n\n\twhile (size) {\n\t\tunsigned long bus_ofs = offset & ~(map_bankwidth(map)-1);\n\t\tint gap = offset - bus_ofs;\n\t\tint n = min_t(int, size, map_bankwidth(map)-gap);\n\t\tmap_word datum = map_word_ff(map);\n\n\t\tdatum = map_word_load_partial(map, datum, buf, gap, n);\n\t\tret = do_write_oneword(map, chip, bus_ofs, datum, FL_OTP_WRITE);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\toffset += n;\n\t\tbuf += n;\n\t\tsize -= n;\n\t}\n\n\treturn 0;\n}\n\nstatic int\ndo_otp_lock(struct map_info *map, struct flchip *chip, u_long offset,\n\t    u_char *buf, u_int size, u_long prot, u_int grpno, u_int grpsz)\n{\n\tstruct cfi_private *cfi = map->fldrv_priv;\n\tmap_word datum;\n\n\t \n\tif (size != grpsz)\n\t\treturn -EXDEV;\n\n\tdatum = map_word_ff(map);\n\tdatum = map_word_clr(map, datum, CMD(1 << grpno));\n\treturn do_write_oneword(map, chip, prot, datum, FL_OTP_WRITE);\n}\n\nstatic int cfi_intelext_otp_walk(struct mtd_info *mtd, loff_t from, size_t len,\n\t\t\t\t size_t *retlen, u_char *buf,\n\t\t\t\t otp_op_t action, int user_regs)\n{\n\tstruct map_info *map = mtd->priv;\n\tstruct cfi_private *cfi = map->fldrv_priv;\n\tstruct cfi_pri_intelext *extp = cfi->cmdset_priv;\n\tstruct flchip *chip;\n\tstruct cfi_intelext_otpinfo *otp;\n\tu_long devsize, reg_prot_offset, data_offset;\n\tu_int chip_num, chip_step, field, reg_fact_size, reg_user_size;\n\tu_int groups, groupno, groupsize, reg_fact_groups, reg_user_groups;\n\tint ret;\n\n\t*retlen = 0;\n\n\t \n\tif (!extp || !(extp->FeatureSupport & 64) || !extp->NumProtectionFields)\n\t\treturn -ENODATA;\n\n\t \n\tdevsize = (1 << cfi->cfiq->DevSize) * cfi->interleave;\n\tchip_step = devsize >> cfi->chipshift;\n\tchip_num = 0;\n\n\t \n\tif (cfi->mfr == CFI_MFR_INTEL) {\n\t\tswitch (cfi->id) {\n\t\tcase 0x880b:\n\t\tcase 0x880c:\n\t\tcase 0x880d:\n\t\t\tchip_num = chip_step - 1;\n\t\t}\n\t}\n\n\tfor ( ; chip_num < cfi->numchips; chip_num += chip_step) {\n\t\tchip = &cfi->chips[chip_num];\n\t\totp = (struct cfi_intelext_otpinfo *)&extp->extra[0];\n\n\t\t \n\t\tfield = 0;\n\t\treg_prot_offset = extp->ProtRegAddr;\n\t\treg_fact_groups = 1;\n\t\treg_fact_size = 1 << extp->FactProtRegSize;\n\t\treg_user_groups = 1;\n\t\treg_user_size = 1 << extp->UserProtRegSize;\n\n\t\twhile (len > 0) {\n\t\t\t \n\t\t\tdata_offset = reg_prot_offset + 1;\n\t\t\tdata_offset *= cfi->interleave * cfi->device_type;\n\t\t\treg_prot_offset *= cfi->interleave * cfi->device_type;\n\t\t\treg_fact_size *= cfi->interleave;\n\t\t\treg_user_size *= cfi->interleave;\n\n\t\t\tif (user_regs) {\n\t\t\t\tgroups = reg_user_groups;\n\t\t\t\tgroupsize = reg_user_size;\n\t\t\t\t \n\t\t\t\tgroupno = reg_fact_groups;\n\t\t\t\tdata_offset += reg_fact_groups * reg_fact_size;\n\t\t\t} else {\n\t\t\t\tgroups = reg_fact_groups;\n\t\t\t\tgroupsize = reg_fact_size;\n\t\t\t\tgroupno = 0;\n\t\t\t}\n\n\t\t\twhile (len > 0 && groups > 0) {\n\t\t\t\tif (!action) {\n\t\t\t\t\t \n\t\t\t\t\tstruct otp_info *otpinfo;\n\t\t\t\t\tmap_word lockword;\n\t\t\t\t\tlen -= sizeof(struct otp_info);\n\t\t\t\t\tif (len <= 0)\n\t\t\t\t\t\treturn -ENOSPC;\n\t\t\t\t\tret = do_otp_read(map, chip,\n\t\t\t\t\t\t\t  reg_prot_offset,\n\t\t\t\t\t\t\t  (u_char *)&lockword,\n\t\t\t\t\t\t\t  map_bankwidth(map),\n\t\t\t\t\t\t\t  0, 0,  0);\n\t\t\t\t\tif (ret)\n\t\t\t\t\t\treturn ret;\n\t\t\t\t\totpinfo = (struct otp_info *)buf;\n\t\t\t\t\totpinfo->start = from;\n\t\t\t\t\totpinfo->length = groupsize;\n\t\t\t\t\totpinfo->locked =\n\t\t\t\t\t   !map_word_bitsset(map, lockword,\n\t\t\t\t\t\t\t     CMD(1 << groupno));\n\t\t\t\t\tfrom += groupsize;\n\t\t\t\t\tbuf += sizeof(*otpinfo);\n\t\t\t\t\t*retlen += sizeof(*otpinfo);\n\t\t\t\t} else if (from >= groupsize) {\n\t\t\t\t\tfrom -= groupsize;\n\t\t\t\t\tdata_offset += groupsize;\n\t\t\t\t} else {\n\t\t\t\t\tint size = groupsize;\n\t\t\t\t\tdata_offset += from;\n\t\t\t\t\tsize -= from;\n\t\t\t\t\tfrom = 0;\n\t\t\t\t\tif (size > len)\n\t\t\t\t\t\tsize = len;\n\t\t\t\t\tret = action(map, chip, data_offset,\n\t\t\t\t\t\t     buf, size, reg_prot_offset,\n\t\t\t\t\t\t     groupno, groupsize);\n\t\t\t\t\tif (ret < 0)\n\t\t\t\t\t\treturn ret;\n\t\t\t\t\tbuf += size;\n\t\t\t\t\tlen -= size;\n\t\t\t\t\t*retlen += size;\n\t\t\t\t\tdata_offset += size;\n\t\t\t\t}\n\t\t\t\tgroupno++;\n\t\t\t\tgroups--;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (++field == extp->NumProtectionFields)\n\t\t\t\tbreak;\n\t\t\treg_prot_offset = otp->ProtRegAddr;\n\t\t\treg_fact_groups = otp->FactGroups;\n\t\t\treg_fact_size = 1 << otp->FactProtRegSize;\n\t\t\treg_user_groups = otp->UserGroups;\n\t\t\treg_user_size = 1 << otp->UserProtRegSize;\n\t\t\totp++;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int cfi_intelext_read_fact_prot_reg(struct mtd_info *mtd, loff_t from,\n\t\t\t\t\t   size_t len, size_t *retlen,\n\t\t\t\t\t    u_char *buf)\n{\n\treturn cfi_intelext_otp_walk(mtd, from, len, retlen,\n\t\t\t\t     buf, do_otp_read, 0);\n}\n\nstatic int cfi_intelext_read_user_prot_reg(struct mtd_info *mtd, loff_t from,\n\t\t\t\t\t   size_t len, size_t *retlen,\n\t\t\t\t\t    u_char *buf)\n{\n\treturn cfi_intelext_otp_walk(mtd, from, len, retlen,\n\t\t\t\t     buf, do_otp_read, 1);\n}\n\nstatic int cfi_intelext_write_user_prot_reg(struct mtd_info *mtd, loff_t from,\n\t\t\t\t\t    size_t len, size_t *retlen,\n\t\t\t\t\t    const u_char *buf)\n{\n\treturn cfi_intelext_otp_walk(mtd, from, len, retlen,\n\t\t\t\t     (u_char *)buf, do_otp_write, 1);\n}\n\nstatic int cfi_intelext_lock_user_prot_reg(struct mtd_info *mtd,\n\t\t\t\t\t   loff_t from, size_t len)\n{\n\tsize_t retlen;\n\treturn cfi_intelext_otp_walk(mtd, from, len, &retlen,\n\t\t\t\t     NULL, do_otp_lock, 1);\n}\n\nstatic int cfi_intelext_get_fact_prot_info(struct mtd_info *mtd, size_t len,\n\t\t\t\t\t   size_t *retlen, struct otp_info *buf)\n\n{\n\treturn cfi_intelext_otp_walk(mtd, 0, len, retlen, (u_char *)buf,\n\t\t\t\t     NULL, 0);\n}\n\nstatic int cfi_intelext_get_user_prot_info(struct mtd_info *mtd, size_t len,\n\t\t\t\t\t   size_t *retlen, struct otp_info *buf)\n{\n\treturn cfi_intelext_otp_walk(mtd, 0, len, retlen, (u_char *)buf,\n\t\t\t\t     NULL, 1);\n}\n\n#endif\n\nstatic void cfi_intelext_save_locks(struct mtd_info *mtd)\n{\n\tstruct mtd_erase_region_info *region;\n\tint block, status, i;\n\tunsigned long adr;\n\tsize_t len;\n\n\tfor (i = 0; i < mtd->numeraseregions; i++) {\n\t\tregion = &mtd->eraseregions[i];\n\t\tif (!region->lockmap)\n\t\t\tcontinue;\n\n\t\tfor (block = 0; block < region->numblocks; block++){\n\t\t\tlen = region->erasesize;\n\t\t\tadr = region->offset + block * len;\n\n\t\t\tstatus = cfi_varsize_frob(mtd,\n\t\t\t\t\tdo_getlockstatus_oneblock, adr, len, NULL);\n\t\t\tif (status)\n\t\t\t\tset_bit(block, region->lockmap);\n\t\t\telse\n\t\t\t\tclear_bit(block, region->lockmap);\n\t\t}\n\t}\n}\n\nstatic int cfi_intelext_suspend(struct mtd_info *mtd)\n{\n\tstruct map_info *map = mtd->priv;\n\tstruct cfi_private *cfi = map->fldrv_priv;\n\tstruct cfi_pri_intelext *extp = cfi->cmdset_priv;\n\tint i;\n\tstruct flchip *chip;\n\tint ret = 0;\n\n\tif ((mtd->flags & MTD_POWERUP_LOCK)\n\t    && extp && (extp->FeatureSupport & (1 << 5)))\n\t\tcfi_intelext_save_locks(mtd);\n\n\tfor (i=0; !ret && i<cfi->numchips; i++) {\n\t\tchip = &cfi->chips[i];\n\n\t\tmutex_lock(&chip->mutex);\n\n\t\tswitch (chip->state) {\n\t\tcase FL_READY:\n\t\tcase FL_STATUS:\n\t\tcase FL_CFI_QUERY:\n\t\tcase FL_JEDEC_QUERY:\n\t\t\tif (chip->oldstate == FL_READY) {\n\t\t\t\t \n\t\t\t\tmap_write(map, CMD(0xFF), cfi->chips[i].start);\n\t\t\t\tchip->oldstate = chip->state;\n\t\t\t\tchip->state = FL_PM_SUSPENDED;\n\t\t\t\t \n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tprintk(KERN_NOTICE \"Flash device refused suspend due to pending operation (oldstate %d)\\n\", chip->oldstate);\n\t\t\t\tret = -EAGAIN;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t \n\t\t\tprintk(KERN_NOTICE \"Flash device refused suspend due to active operation (state %d)\\n\", chip->state);\n\t\t\tret = -EAGAIN;\n\t\t\tbreak;\n\t\tcase FL_PM_SUSPENDED:\n\t\t\tbreak;\n\t\t}\n\t\tmutex_unlock(&chip->mutex);\n\t}\n\n\t \n\n\tif (ret) {\n\t\tfor (i--; i >=0; i--) {\n\t\t\tchip = &cfi->chips[i];\n\n\t\t\tmutex_lock(&chip->mutex);\n\n\t\t\tif (chip->state == FL_PM_SUSPENDED) {\n\t\t\t\t \n\t\t\t\tchip->state = chip->oldstate;\n\t\t\t\tchip->oldstate = FL_READY;\n\t\t\t\twake_up(&chip->wq);\n\t\t\t}\n\t\t\tmutex_unlock(&chip->mutex);\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic void cfi_intelext_restore_locks(struct mtd_info *mtd)\n{\n\tstruct mtd_erase_region_info *region;\n\tint block, i;\n\tunsigned long adr;\n\tsize_t len;\n\n\tfor (i = 0; i < mtd->numeraseregions; i++) {\n\t\tregion = &mtd->eraseregions[i];\n\t\tif (!region->lockmap)\n\t\t\tcontinue;\n\n\t\tfor_each_clear_bit(block, region->lockmap, region->numblocks) {\n\t\t\tlen = region->erasesize;\n\t\t\tadr = region->offset + block * len;\n\t\t\tcfi_intelext_unlock(mtd, adr, len);\n\t\t}\n\t}\n}\n\nstatic void cfi_intelext_resume(struct mtd_info *mtd)\n{\n\tstruct map_info *map = mtd->priv;\n\tstruct cfi_private *cfi = map->fldrv_priv;\n\tstruct cfi_pri_intelext *extp = cfi->cmdset_priv;\n\tint i;\n\tstruct flchip *chip;\n\n\tfor (i=0; i<cfi->numchips; i++) {\n\n\t\tchip = &cfi->chips[i];\n\n\t\tmutex_lock(&chip->mutex);\n\n\t\t \n\t\tif (chip->state == FL_PM_SUSPENDED) {\n\t\t\t \n\t\t\tfixup_LH28F640BF(mtd);\n\t\t\tmap_write(map, CMD(0xFF), cfi->chips[i].start);\n\t\t\tchip->oldstate = chip->state = FL_READY;\n\t\t\twake_up(&chip->wq);\n\t\t}\n\n\t\tmutex_unlock(&chip->mutex);\n\t}\n\n\tif ((mtd->flags & MTD_POWERUP_LOCK)\n\t    && extp && (extp->FeatureSupport & (1 << 5)))\n\t\tcfi_intelext_restore_locks(mtd);\n}\n\nstatic int cfi_intelext_reset(struct mtd_info *mtd)\n{\n\tstruct map_info *map = mtd->priv;\n\tstruct cfi_private *cfi = map->fldrv_priv;\n\tint i, ret;\n\n\tfor (i=0; i < cfi->numchips; i++) {\n\t\tstruct flchip *chip = &cfi->chips[i];\n\n\t\t \n\t\tmutex_lock(&chip->mutex);\n\t\tret = get_chip(map, chip, chip->start, FL_SHUTDOWN);\n\t\tif (!ret) {\n\t\t\tmap_write(map, CMD(0xff), chip->start);\n\t\t\tchip->state = FL_SHUTDOWN;\n\t\t\tput_chip(map, chip, chip->start);\n\t\t}\n\t\tmutex_unlock(&chip->mutex);\n\t}\n\n\treturn 0;\n}\n\nstatic int cfi_intelext_reboot(struct notifier_block *nb, unsigned long val,\n\t\t\t       void *v)\n{\n\tstruct mtd_info *mtd;\n\n\tmtd = container_of(nb, struct mtd_info, reboot_notifier);\n\tcfi_intelext_reset(mtd);\n\treturn NOTIFY_DONE;\n}\n\nstatic void cfi_intelext_destroy(struct mtd_info *mtd)\n{\n\tstruct map_info *map = mtd->priv;\n\tstruct cfi_private *cfi = map->fldrv_priv;\n\tstruct mtd_erase_region_info *region;\n\tint i;\n\tcfi_intelext_reset(mtd);\n\tunregister_reboot_notifier(&mtd->reboot_notifier);\n\tkfree(cfi->cmdset_priv);\n\tkfree(cfi->cfiq);\n\tkfree(cfi->chips[0].priv);\n\tkfree(cfi);\n\tfor (i = 0; i < mtd->numeraseregions; i++) {\n\t\tregion = &mtd->eraseregions[i];\n\t\tkfree(region->lockmap);\n\t}\n\tkfree(mtd->eraseregions);\n}\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"David Woodhouse <dwmw2@infradead.org> et al.\");\nMODULE_DESCRIPTION(\"MTD chip driver for Intel/Sharp flash chips\");\nMODULE_ALIAS(\"cfi_cmdset_0003\");\nMODULE_ALIAS(\"cfi_cmdset_0200\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}