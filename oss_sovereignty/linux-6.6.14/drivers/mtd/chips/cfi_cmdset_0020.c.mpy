{
  "module_name": "cfi_cmdset_0020.c",
  "hash_id": "4ff472396d414a98e12a4572b59df22dd02206e05d616c429362db25abe729b1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/chips/cfi_cmdset_0020.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <asm/io.h>\n#include <asm/byteorder.h>\n\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/mtd/map.h>\n#include <linux/mtd/cfi.h>\n#include <linux/mtd/mtd.h>\n\n\nstatic int cfi_staa_read(struct mtd_info *, loff_t, size_t, size_t *, u_char *);\nstatic int cfi_staa_write_buffers(struct mtd_info *, loff_t, size_t, size_t *, const u_char *);\nstatic int cfi_staa_writev(struct mtd_info *mtd, const struct kvec *vecs,\n\t\tunsigned long count, loff_t to, size_t *retlen);\nstatic int cfi_staa_erase_varsize(struct mtd_info *, struct erase_info *);\nstatic void cfi_staa_sync (struct mtd_info *);\nstatic int cfi_staa_lock(struct mtd_info *mtd, loff_t ofs, uint64_t len);\nstatic int cfi_staa_unlock(struct mtd_info *mtd, loff_t ofs, uint64_t len);\nstatic int cfi_staa_suspend (struct mtd_info *);\nstatic void cfi_staa_resume (struct mtd_info *);\n\nstatic void cfi_staa_destroy(struct mtd_info *);\n\nstruct mtd_info *cfi_cmdset_0020(struct map_info *, int);\n\nstatic struct mtd_info *cfi_staa_setup (struct map_info *);\n\nstatic struct mtd_chip_driver cfi_staa_chipdrv = {\n\t.probe\t\t= NULL,  \n\t.destroy\t= cfi_staa_destroy,\n\t.name\t\t= \"cfi_cmdset_0020\",\n\t.module\t\t= THIS_MODULE\n};\n\n \n\n\n#ifdef DEBUG_CFI_FEATURES\nstatic void cfi_tell_features(struct cfi_pri_intelext *extp)\n{\n        int i;\n        printk(\"  Feature/Command Support: %4.4X\\n\", extp->FeatureSupport);\n\tprintk(\"     - Chip Erase:         %s\\n\", extp->FeatureSupport&1?\"supported\":\"unsupported\");\n\tprintk(\"     - Suspend Erase:      %s\\n\", extp->FeatureSupport&2?\"supported\":\"unsupported\");\n\tprintk(\"     - Suspend Program:    %s\\n\", extp->FeatureSupport&4?\"supported\":\"unsupported\");\n\tprintk(\"     - Legacy Lock/Unlock: %s\\n\", extp->FeatureSupport&8?\"supported\":\"unsupported\");\n\tprintk(\"     - Queued Erase:       %s\\n\", extp->FeatureSupport&16?\"supported\":\"unsupported\");\n\tprintk(\"     - Instant block lock: %s\\n\", extp->FeatureSupport&32?\"supported\":\"unsupported\");\n\tprintk(\"     - Protection Bits:    %s\\n\", extp->FeatureSupport&64?\"supported\":\"unsupported\");\n\tprintk(\"     - Page-mode read:     %s\\n\", extp->FeatureSupport&128?\"supported\":\"unsupported\");\n\tprintk(\"     - Synchronous read:   %s\\n\", extp->FeatureSupport&256?\"supported\":\"unsupported\");\n\tfor (i=9; i<32; i++) {\n\t\tif (extp->FeatureSupport & (1<<i))\n\t\t\tprintk(\"     - Unknown Bit %X:      supported\\n\", i);\n\t}\n\n\tprintk(\"  Supported functions after Suspend: %2.2X\\n\", extp->SuspendCmdSupport);\n\tprintk(\"     - Program after Erase Suspend: %s\\n\", extp->SuspendCmdSupport&1?\"supported\":\"unsupported\");\n\tfor (i=1; i<8; i++) {\n\t\tif (extp->SuspendCmdSupport & (1<<i))\n\t\t\tprintk(\"     - Unknown Bit %X:               supported\\n\", i);\n\t}\n\n\tprintk(\"  Block Status Register Mask: %4.4X\\n\", extp->BlkStatusRegMask);\n\tprintk(\"     - Lock Bit Active:      %s\\n\", extp->BlkStatusRegMask&1?\"yes\":\"no\");\n\tprintk(\"     - Valid Bit Active:     %s\\n\", extp->BlkStatusRegMask&2?\"yes\":\"no\");\n\tfor (i=2; i<16; i++) {\n\t\tif (extp->BlkStatusRegMask & (1<<i))\n\t\t\tprintk(\"     - Unknown Bit %X Active: yes\\n\",i);\n\t}\n\n\tprintk(\"  Vcc Logic Supply Optimum Program/Erase Voltage: %d.%d V\\n\",\n\t       extp->VccOptimal >> 8, extp->VccOptimal & 0xf);\n\tif (extp->VppOptimal)\n\t\tprintk(\"  Vpp Programming Supply Optimum Program/Erase Voltage: %d.%d V\\n\",\n\t\t       extp->VppOptimal >> 8, extp->VppOptimal & 0xf);\n}\n#endif\n\n \nstruct mtd_info *cfi_cmdset_0020(struct map_info *map, int primary)\n{\n\tstruct cfi_private *cfi = map->fldrv_priv;\n\tint i;\n\n\tif (cfi->cfi_mode) {\n\t\t \n\t\t__u16 adr = primary?cfi->cfiq->P_ADR:cfi->cfiq->A_ADR;\n\t\tstruct cfi_pri_intelext *extp;\n\n\t\textp = (struct cfi_pri_intelext*)cfi_read_pri(map, adr, sizeof(*extp), \"ST Microelectronics\");\n\t\tif (!extp)\n\t\t\treturn NULL;\n\n\t\tif (extp->MajorVersion != '1' ||\n\t\t    (extp->MinorVersion < '0' || extp->MinorVersion > '3')) {\n\t\t\tprintk(KERN_ERR \"  Unknown ST Microelectronics\"\n\t\t\t       \" Extended Query version %c.%c.\\n\",\n\t\t\t       extp->MajorVersion, extp->MinorVersion);\n\t\t\tkfree(extp);\n\t\t\treturn NULL;\n\t\t}\n\n\t\t \n\t\textp->FeatureSupport = cfi32_to_cpu(map, extp->FeatureSupport);\n\t\textp->BlkStatusRegMask = cfi32_to_cpu(map,\n\t\t\t\t\t\textp->BlkStatusRegMask);\n\n#ifdef DEBUG_CFI_FEATURES\n\t\t \n\t\tcfi_tell_features(extp);\n#endif\n\n\t\t \n\t\tcfi->cmdset_priv = extp;\n\t}\n\n\tfor (i=0; i< cfi->numchips; i++) {\n\t\tcfi->chips[i].word_write_time = 128;\n\t\tcfi->chips[i].buffer_write_time = 128;\n\t\tcfi->chips[i].erase_time = 1024;\n\t\tcfi->chips[i].ref_point_counter = 0;\n\t\tinit_waitqueue_head(&(cfi->chips[i].wq));\n\t}\n\n\treturn cfi_staa_setup(map);\n}\nEXPORT_SYMBOL_GPL(cfi_cmdset_0020);\n\nstatic struct mtd_info *cfi_staa_setup(struct map_info *map)\n{\n\tstruct cfi_private *cfi = map->fldrv_priv;\n\tstruct mtd_info *mtd;\n\tunsigned long offset = 0;\n\tint i,j;\n\tunsigned long devsize = (1<<cfi->cfiq->DevSize) * cfi->interleave;\n\n\tmtd = kzalloc(sizeof(*mtd), GFP_KERNEL);\n\t \n\n\tif (!mtd) {\n\t\tkfree(cfi->cmdset_priv);\n\t\treturn NULL;\n\t}\n\n\tmtd->priv = map;\n\tmtd->type = MTD_NORFLASH;\n\tmtd->size = devsize * cfi->numchips;\n\n\tmtd->numeraseregions = cfi->cfiq->NumEraseRegions * cfi->numchips;\n\tmtd->eraseregions = kmalloc_array(mtd->numeraseregions,\n\t\t\t\t\t  sizeof(struct mtd_erase_region_info),\n\t\t\t\t\t  GFP_KERNEL);\n\tif (!mtd->eraseregions) {\n\t\tkfree(cfi->cmdset_priv);\n\t\tkfree(mtd);\n\t\treturn NULL;\n\t}\n\n\tfor (i=0; i<cfi->cfiq->NumEraseRegions; i++) {\n\t\tunsigned long ernum, ersize;\n\t\tersize = ((cfi->cfiq->EraseRegionInfo[i] >> 8) & ~0xff) * cfi->interleave;\n\t\ternum = (cfi->cfiq->EraseRegionInfo[i] & 0xffff) + 1;\n\n\t\tif (mtd->erasesize < ersize) {\n\t\t\tmtd->erasesize = ersize;\n\t\t}\n\t\tfor (j=0; j<cfi->numchips; j++) {\n\t\t\tmtd->eraseregions[(j*cfi->cfiq->NumEraseRegions)+i].offset = (j*devsize)+offset;\n\t\t\tmtd->eraseregions[(j*cfi->cfiq->NumEraseRegions)+i].erasesize = ersize;\n\t\t\tmtd->eraseregions[(j*cfi->cfiq->NumEraseRegions)+i].numblocks = ernum;\n\t\t}\n\t\toffset += (ersize * ernum);\n\t}\n\n\tif (offset != devsize) {\n\t\t \n\t\tprintk(KERN_WARNING \"Sum of regions (%lx) != total size of set of interleaved chips (%lx)\\n\", offset, devsize);\n\t\tkfree(mtd->eraseregions);\n\t\tkfree(cfi->cmdset_priv);\n\t\tkfree(mtd);\n\t\treturn NULL;\n\t}\n\n\tfor (i=0; i<mtd->numeraseregions;i++){\n\t\tprintk(KERN_DEBUG \"%d: offset=0x%llx,size=0x%x,blocks=%d\\n\",\n\t\t       i, (unsigned long long)mtd->eraseregions[i].offset,\n\t\t       mtd->eraseregions[i].erasesize,\n\t\t       mtd->eraseregions[i].numblocks);\n\t}\n\n\t \n\tmtd->_erase = cfi_staa_erase_varsize;\n\tmtd->_read = cfi_staa_read;\n\tmtd->_write = cfi_staa_write_buffers;\n\tmtd->_writev = cfi_staa_writev;\n\tmtd->_sync = cfi_staa_sync;\n\tmtd->_lock = cfi_staa_lock;\n\tmtd->_unlock = cfi_staa_unlock;\n\tmtd->_suspend = cfi_staa_suspend;\n\tmtd->_resume = cfi_staa_resume;\n\tmtd->flags = MTD_CAP_NORFLASH & ~MTD_BIT_WRITEABLE;\n\tmtd->writesize = 8;  \n\tmtd->writebufsize = cfi_interleave(cfi) << cfi->cfiq->MaxBufWriteSize;\n\tmap->fldrv = &cfi_staa_chipdrv;\n\t__module_get(THIS_MODULE);\n\tmtd->name = map->name;\n\treturn mtd;\n}\n\n\nstatic inline int do_read_onechip(struct map_info *map, struct flchip *chip, loff_t adr, size_t len, u_char *buf)\n{\n\tmap_word status, status_OK;\n\tunsigned long timeo;\n\tDECLARE_WAITQUEUE(wait, current);\n\tint suspended = 0;\n\tunsigned long cmd_addr;\n\tstruct cfi_private *cfi = map->fldrv_priv;\n\n\tadr += chip->start;\n\n\t \n\tcmd_addr = adr & ~(map_bankwidth(map)-1);\n\n\t \n\tstatus_OK = CMD(0x80);\n\n\ttimeo = jiffies + HZ;\n retry:\n\tmutex_lock(&chip->mutex);\n\n\t \n\tswitch (chip->state) {\n\tcase FL_ERASING:\n\t\tif (!(((struct cfi_pri_intelext *)cfi->cmdset_priv)->FeatureSupport & 2))\n\t\t\tgoto sleep;  \n\n\t\tmap_write (map, CMD(0xb0), cmd_addr);\n\t\t \n\t\tmap_write(map, CMD(0x70), cmd_addr);\n\t\tchip->oldstate = FL_ERASING;\n\t\tchip->state = FL_ERASE_SUSPENDING;\n\t\t \n\t\tfor (;;) {\n\t\t\tstatus = map_read(map, cmd_addr);\n\t\t\tif (map_word_andequal(map, status, status_OK, status_OK))\n\t\t\t\tbreak;\n\n\t\t\tif (time_after(jiffies, timeo)) {\n\t\t\t\t \n\t\t\t\tmap_write(map, CMD(0xd0), cmd_addr);\n\t\t\t\t \n\t\t\t\tmap_write(map, CMD(0x70), cmd_addr);\n\t\t\t\tchip->state = FL_ERASING;\n\t\t\t\twake_up(&chip->wq);\n\t\t\t\tmutex_unlock(&chip->mutex);\n\t\t\t\tprintk(KERN_ERR \"Chip not ready after erase \"\n\t\t\t\t       \"suspended: status = 0x%lx\\n\", status.x[0]);\n\t\t\t\treturn -EIO;\n\t\t\t}\n\n\t\t\tmutex_unlock(&chip->mutex);\n\t\t\tcfi_udelay(1);\n\t\t\tmutex_lock(&chip->mutex);\n\t\t}\n\n\t\tsuspended = 1;\n\t\tmap_write(map, CMD(0xff), cmd_addr);\n\t\tchip->state = FL_READY;\n\t\tbreak;\n\n#if 0\n\tcase FL_WRITING:\n\t\t \n#endif\n\n\tcase FL_READY:\n\t\tbreak;\n\n\tcase FL_CFI_QUERY:\n\tcase FL_JEDEC_QUERY:\n\t\tmap_write(map, CMD(0x70), cmd_addr);\n\t\tchip->state = FL_STATUS;\n\t\tfallthrough;\n\tcase FL_STATUS:\n\t\tstatus = map_read(map, cmd_addr);\n\t\tif (map_word_andequal(map, status, status_OK, status_OK)) {\n\t\t\tmap_write(map, CMD(0xff), cmd_addr);\n\t\t\tchip->state = FL_READY;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (time_after(jiffies, timeo)) {\n\t\t\tmutex_unlock(&chip->mutex);\n\t\t\tprintk(KERN_ERR \"waiting for chip to be ready timed out in read. WSM status = %lx\\n\", status.x[0]);\n\t\t\treturn -EIO;\n\t\t}\n\n\t\t \n\t\tmutex_unlock(&chip->mutex);\n\t\tcfi_udelay(1);\n\t\tgoto retry;\n\n\tdefault:\n\tsleep:\n\t\t \n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\tadd_wait_queue(&chip->wq, &wait);\n\t\tmutex_unlock(&chip->mutex);\n\t\tschedule();\n\t\tremove_wait_queue(&chip->wq, &wait);\n\t\ttimeo = jiffies + HZ;\n\t\tgoto retry;\n\t}\n\n\tmap_copy_from(map, buf, adr, len);\n\n\tif (suspended) {\n\t\tchip->state = chip->oldstate;\n\t\t \n\t\tmap_write(map, CMD(0xd0), cmd_addr);\n\t\tmap_write(map, CMD(0x70), cmd_addr);\n\t}\n\n\twake_up(&chip->wq);\n\tmutex_unlock(&chip->mutex);\n\treturn 0;\n}\n\nstatic int cfi_staa_read (struct mtd_info *mtd, loff_t from, size_t len, size_t *retlen, u_char *buf)\n{\n\tstruct map_info *map = mtd->priv;\n\tstruct cfi_private *cfi = map->fldrv_priv;\n\tunsigned long ofs;\n\tint chipnum;\n\tint ret = 0;\n\n\t \n\tchipnum = (from >> cfi->chipshift);\n\tofs = from - (chipnum <<  cfi->chipshift);\n\n\twhile (len) {\n\t\tunsigned long thislen;\n\n\t\tif (chipnum >= cfi->numchips)\n\t\t\tbreak;\n\n\t\tif ((len + ofs -1) >> cfi->chipshift)\n\t\t\tthislen = (1<<cfi->chipshift) - ofs;\n\t\telse\n\t\t\tthislen = len;\n\n\t\tret = do_read_onechip(map, &cfi->chips[chipnum], ofs, thislen, buf);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\t*retlen += thislen;\n\t\tlen -= thislen;\n\t\tbuf += thislen;\n\n\t\tofs = 0;\n\t\tchipnum++;\n\t}\n\treturn ret;\n}\n\nstatic int do_write_buffer(struct map_info *map, struct flchip *chip,\n\t\t\t\t  unsigned long adr, const u_char *buf, int len)\n{\n\tstruct cfi_private *cfi = map->fldrv_priv;\n\tmap_word status, status_OK;\n\tunsigned long cmd_adr, timeo;\n\tDECLARE_WAITQUEUE(wait, current);\n\tint wbufsize, z;\n\n         \n        if (adr & (map_bankwidth(map)-1))\n            return -EINVAL;\n\n        wbufsize = cfi_interleave(cfi) << cfi->cfiq->MaxBufWriteSize;\n        adr += chip->start;\n\tcmd_adr = adr & ~(wbufsize-1);\n\n\t \n        status_OK = CMD(0x80);\n\n\ttimeo = jiffies + HZ;\n retry:\n\n#ifdef DEBUG_CFI_FEATURES\n       printk(\"%s: chip->state[%d]\\n\", __func__, chip->state);\n#endif\n\tmutex_lock(&chip->mutex);\n\n\t \n\tswitch (chip->state) {\n\tcase FL_READY:\n\t\tbreak;\n\n\tcase FL_CFI_QUERY:\n\tcase FL_JEDEC_QUERY:\n\t\tmap_write(map, CMD(0x70), cmd_adr);\n                chip->state = FL_STATUS;\n#ifdef DEBUG_CFI_FEATURES\n\tprintk(\"%s: 1 status[%x]\\n\", __func__, map_read(map, cmd_adr));\n#endif\n\t\tfallthrough;\n\tcase FL_STATUS:\n\t\tstatus = map_read(map, cmd_adr);\n\t\tif (map_word_andequal(map, status, status_OK, status_OK))\n\t\t\tbreak;\n\t\t \n\t\tif (time_after(jiffies, timeo)) {\n\t\t\tmutex_unlock(&chip->mutex);\n                        printk(KERN_ERR \"waiting for chip to be ready timed out in buffer write Xstatus = %lx, status = %lx\\n\",\n                               status.x[0], map_read(map, cmd_adr).x[0]);\n\t\t\treturn -EIO;\n\t\t}\n\n\t\t \n\t\tmutex_unlock(&chip->mutex);\n\t\tcfi_udelay(1);\n\t\tgoto retry;\n\n\tdefault:\n\t\t \n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\tadd_wait_queue(&chip->wq, &wait);\n\t\tmutex_unlock(&chip->mutex);\n\t\tschedule();\n\t\tremove_wait_queue(&chip->wq, &wait);\n\t\ttimeo = jiffies + HZ;\n\t\tgoto retry;\n\t}\n\n\tENABLE_VPP(map);\n\tmap_write(map, CMD(0xe8), cmd_adr);\n\tchip->state = FL_WRITING_TO_BUFFER;\n\n\tz = 0;\n\tfor (;;) {\n\t\tstatus = map_read(map, cmd_adr);\n\t\tif (map_word_andequal(map, status, status_OK, status_OK))\n\t\t\tbreak;\n\n\t\tmutex_unlock(&chip->mutex);\n\t\tcfi_udelay(1);\n\t\tmutex_lock(&chip->mutex);\n\n\t\tif (++z > 100) {\n\t\t\t \n\t\t\tDISABLE_VPP(map);\n                        map_write(map, CMD(0x70), cmd_adr);\n\t\t\tchip->state = FL_STATUS;\n\t\t\tmutex_unlock(&chip->mutex);\n\t\t\tprintk(KERN_ERR \"Chip not ready for buffer write. Xstatus = %lx\\n\", status.x[0]);\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\t \n\tmap_write(map, CMD(len/map_bankwidth(map)-1), cmd_adr );\n\n\t \n\tfor (z = 0; z < len;\n\t     z += map_bankwidth(map), buf += map_bankwidth(map)) {\n\t\tmap_word d;\n\t\td = map_word_load(map, buf);\n\t\tmap_write(map, d, adr+z);\n\t}\n\t \n\tmap_write(map, CMD(0xd0), cmd_adr);\n\tchip->state = FL_WRITING;\n\n\tmutex_unlock(&chip->mutex);\n\tcfi_udelay(chip->buffer_write_time);\n\tmutex_lock(&chip->mutex);\n\n\ttimeo = jiffies + (HZ/2);\n\tz = 0;\n\tfor (;;) {\n\t\tif (chip->state != FL_WRITING) {\n\t\t\t \n\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\tadd_wait_queue(&chip->wq, &wait);\n\t\t\tmutex_unlock(&chip->mutex);\n\t\t\tschedule();\n\t\t\tremove_wait_queue(&chip->wq, &wait);\n\t\t\ttimeo = jiffies + (HZ / 2);  \n\t\t\tmutex_lock(&chip->mutex);\n\t\t\tcontinue;\n\t\t}\n\n\t\tstatus = map_read(map, cmd_adr);\n\t\tif (map_word_andequal(map, status, status_OK, status_OK))\n\t\t\tbreak;\n\n\t\t \n\t\tif (time_after(jiffies, timeo)) {\n                         \n                        map_write(map, CMD(0x50), cmd_adr);\n                         \n                        map_write(map, CMD(0x70), adr);\n\t\t\tchip->state = FL_STATUS;\n\t\t\tDISABLE_VPP(map);\n\t\t\tmutex_unlock(&chip->mutex);\n\t\t\tprintk(KERN_ERR \"waiting for chip to be ready timed out in bufwrite\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\n\t\t \n\t\tmutex_unlock(&chip->mutex);\n\t\tcfi_udelay(1);\n\t\tz++;\n\t\tmutex_lock(&chip->mutex);\n\t}\n\tif (!z) {\n\t\tchip->buffer_write_time--;\n\t\tif (!chip->buffer_write_time)\n\t\t\tchip->buffer_write_time++;\n\t}\n\tif (z > 1)\n\t\tchip->buffer_write_time++;\n\n\t \n\tDISABLE_VPP(map);\n\tchip->state = FL_STATUS;\n\n         \n        if (map_word_bitsset(map, status, CMD(0x3a))) {\n#ifdef DEBUG_CFI_FEATURES\n\t\tprintk(\"%s: 2 status[%lx]\\n\", __func__, status.x[0]);\n#endif\n\t\t \n\t\tmap_write(map, CMD(0x50), cmd_adr);\n\t\t \n\t\tmap_write(map, CMD(0x70), adr);\n\t\twake_up(&chip->wq);\n\t\tmutex_unlock(&chip->mutex);\n\t\treturn map_word_bitsset(map, status, CMD(0x02)) ? -EROFS : -EIO;\n\t}\n\twake_up(&chip->wq);\n\tmutex_unlock(&chip->mutex);\n\n        return 0;\n}\n\nstatic int cfi_staa_write_buffers (struct mtd_info *mtd, loff_t to,\n\t\t\t\t       size_t len, size_t *retlen, const u_char *buf)\n{\n\tstruct map_info *map = mtd->priv;\n\tstruct cfi_private *cfi = map->fldrv_priv;\n\tint wbufsize = cfi_interleave(cfi) << cfi->cfiq->MaxBufWriteSize;\n\tint ret;\n\tint chipnum;\n\tunsigned long ofs;\n\n\tchipnum = to >> cfi->chipshift;\n\tofs = to  - (chipnum << cfi->chipshift);\n\n#ifdef DEBUG_CFI_FEATURES\n\tprintk(\"%s: map_bankwidth(map)[%x]\\n\", __func__, map_bankwidth(map));\n\tprintk(\"%s: chipnum[%x] wbufsize[%x]\\n\", __func__, chipnum, wbufsize);\n\tprintk(\"%s: ofs[%x] len[%x]\\n\", __func__, ofs, len);\n#endif\n\n         \n        while (len > 0) {\n\t\t \n\t\tint size = wbufsize - (ofs & (wbufsize-1));\n\n                if (size > len)\n                    size = len;\n\n                ret = do_write_buffer(map, &cfi->chips[chipnum],\n\t\t\t\t      ofs, buf, size);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tofs += size;\n\t\tbuf += size;\n\t\t(*retlen) += size;\n\t\tlen -= size;\n\n\t\tif (ofs >> cfi->chipshift) {\n\t\t\tchipnum ++;\n\t\t\tofs = 0;\n\t\t\tif (chipnum == cfi->numchips)\n\t\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \n#define ECCBUF_SIZE (mtd->writesize)\n#define ECCBUF_DIV(x) ((x) & ~(ECCBUF_SIZE - 1))\n#define ECCBUF_MOD(x) ((x) &  (ECCBUF_SIZE - 1))\nstatic int\ncfi_staa_writev(struct mtd_info *mtd, const struct kvec *vecs,\n\t\tunsigned long count, loff_t to, size_t *retlen)\n{\n\tunsigned long i;\n\tsize_t\t totlen = 0, thislen;\n\tint\t ret = 0;\n\tsize_t\t buflen = 0;\n\tchar *buffer;\n\n\tif (!ECCBUF_SIZE) {\n\t\t \n\t\treturn -EIO;\n\t}\n\tbuffer = kmalloc(ECCBUF_SIZE, GFP_KERNEL);\n\tif (!buffer)\n\t\treturn -ENOMEM;\n\n\tfor (i=0; i<count; i++) {\n\t\tsize_t elem_len = vecs[i].iov_len;\n\t\tvoid *elem_base = vecs[i].iov_base;\n\t\tif (!elem_len)  \n\t\t\tcontinue;\n\t\tif (buflen) {  \n\t\t\tif (buflen + elem_len < ECCBUF_SIZE) {  \n\t\t\t\tmemcpy(buffer+buflen, elem_base, elem_len);\n\t\t\t\tbuflen += elem_len;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tmemcpy(buffer+buflen, elem_base, ECCBUF_SIZE-buflen);\n\t\t\tret = mtd_write(mtd, to, ECCBUF_SIZE, &thislen,\n\t\t\t\t\tbuffer);\n\t\t\ttotlen += thislen;\n\t\t\tif (ret || thislen != ECCBUF_SIZE)\n\t\t\t\tgoto write_error;\n\t\t\telem_len -= thislen-buflen;\n\t\t\telem_base += thislen-buflen;\n\t\t\tto += ECCBUF_SIZE;\n\t\t}\n\t\tif (ECCBUF_DIV(elem_len)) {  \n\t\t\tret = mtd_write(mtd, to, ECCBUF_DIV(elem_len),\n\t\t\t\t\t&thislen, elem_base);\n\t\t\ttotlen += thislen;\n\t\t\tif (ret || thislen != ECCBUF_DIV(elem_len))\n\t\t\t\tgoto write_error;\n\t\t\tto += thislen;\n\t\t}\n\t\tbuflen = ECCBUF_MOD(elem_len);  \n\t\tif (buflen) {\n\t\t\tmemset(buffer, 0xff, ECCBUF_SIZE);\n\t\t\tmemcpy(buffer, elem_base + thislen, buflen);\n\t\t}\n\t}\n\tif (buflen) {  \n\t\t \n\t\tret = mtd_write(mtd, to, buflen, &thislen, buffer);\n\t\ttotlen += thislen;\n\t\tif (ret || thislen != ECCBUF_SIZE)\n\t\t\tgoto write_error;\n\t}\nwrite_error:\n\tif (retlen)\n\t\t*retlen = totlen;\n\tkfree(buffer);\n\treturn ret;\n}\n\n\nstatic inline int do_erase_oneblock(struct map_info *map, struct flchip *chip, unsigned long adr)\n{\n\tstruct cfi_private *cfi = map->fldrv_priv;\n\tmap_word status, status_OK;\n\tunsigned long timeo;\n\tint retries = 3;\n\tDECLARE_WAITQUEUE(wait, current);\n\tint ret = 0;\n\n\tadr += chip->start;\n\n\t \n\tstatus_OK = CMD(0x80);\n\n\ttimeo = jiffies + HZ;\nretry:\n\tmutex_lock(&chip->mutex);\n\n\t \n\tswitch (chip->state) {\n\tcase FL_CFI_QUERY:\n\tcase FL_JEDEC_QUERY:\n\tcase FL_READY:\n\t\tmap_write(map, CMD(0x70), adr);\n\t\tchip->state = FL_STATUS;\n\t\tfallthrough;\n\tcase FL_STATUS:\n\t\tstatus = map_read(map, adr);\n\t\tif (map_word_andequal(map, status, status_OK, status_OK))\n\t\t\tbreak;\n\n\t\t \n\t\tif (time_after(jiffies, timeo)) {\n\t\t\tmutex_unlock(&chip->mutex);\n\t\t\tprintk(KERN_ERR \"waiting for chip to be ready timed out in erase\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\n\t\t \n\t\tmutex_unlock(&chip->mutex);\n\t\tcfi_udelay(1);\n\t\tgoto retry;\n\n\tdefault:\n\t\t \n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\tadd_wait_queue(&chip->wq, &wait);\n\t\tmutex_unlock(&chip->mutex);\n\t\tschedule();\n\t\tremove_wait_queue(&chip->wq, &wait);\n\t\ttimeo = jiffies + HZ;\n\t\tgoto retry;\n\t}\n\n\tENABLE_VPP(map);\n\t \n\tmap_write(map, CMD(0x50), adr);\n\n\t \n\tmap_write(map, CMD(0x20), adr);\n\tmap_write(map, CMD(0xD0), adr);\n\tchip->state = FL_ERASING;\n\n\tmutex_unlock(&chip->mutex);\n\tmsleep(1000);\n\tmutex_lock(&chip->mutex);\n\n\t \n\t \n\n\ttimeo = jiffies + (HZ*20);\n\tfor (;;) {\n\t\tif (chip->state != FL_ERASING) {\n\t\t\t \n\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\tadd_wait_queue(&chip->wq, &wait);\n\t\t\tmutex_unlock(&chip->mutex);\n\t\t\tschedule();\n\t\t\tremove_wait_queue(&chip->wq, &wait);\n\t\t\ttimeo = jiffies + (HZ*20);  \n\t\t\tmutex_lock(&chip->mutex);\n\t\t\tcontinue;\n\t\t}\n\n\t\tstatus = map_read(map, adr);\n\t\tif (map_word_andequal(map, status, status_OK, status_OK))\n\t\t\tbreak;\n\n\t\t \n\t\tif (time_after(jiffies, timeo)) {\n\t\t\tmap_write(map, CMD(0x70), adr);\n\t\t\tchip->state = FL_STATUS;\n\t\t\tprintk(KERN_ERR \"waiting for erase to complete timed out. Xstatus = %lx, status = %lx.\\n\", status.x[0], map_read(map, adr).x[0]);\n\t\t\tDISABLE_VPP(map);\n\t\t\tmutex_unlock(&chip->mutex);\n\t\t\treturn -EIO;\n\t\t}\n\n\t\t \n\t\tmutex_unlock(&chip->mutex);\n\t\tcfi_udelay(1);\n\t\tmutex_lock(&chip->mutex);\n\t}\n\n\tDISABLE_VPP(map);\n\tret = 0;\n\n\t \n\tmap_write(map, CMD(0x70), adr);\n\tchip->state = FL_STATUS;\n\tstatus = map_read(map, adr);\n\n\t \n\tif (map_word_bitsset(map, status, CMD(0x3a))) {\n\t\tunsigned char chipstatus = status.x[0];\n\t\tif (!map_word_equal(map, status, CMD(chipstatus))) {\n\t\t\tint i, w;\n\t\t\tfor (w=0; w<map_words(map); w++) {\n\t\t\t\tfor (i = 0; i<cfi_interleave(cfi); i++) {\n\t\t\t\t\tchipstatus |= status.x[w] >> (cfi->device_type * 8);\n\t\t\t\t}\n\t\t\t}\n\t\t\tprintk(KERN_WARNING \"Status is not identical for all chips: 0x%lx. Merging to give 0x%02x\\n\",\n\t\t\t       status.x[0], chipstatus);\n\t\t}\n\t\t \n\t\tmap_write(map, CMD(0x50), adr);\n\t\tmap_write(map, CMD(0x70), adr);\n\n\t\tif ((chipstatus & 0x30) == 0x30) {\n\t\t\tprintk(KERN_NOTICE \"Chip reports improper command sequence: status 0x%x\\n\", chipstatus);\n\t\t\tret = -EIO;\n\t\t} else if (chipstatus & 0x02) {\n\t\t\t \n\t\t\tret = -EROFS;\n\t\t} else if (chipstatus & 0x8) {\n\t\t\t \n\t\t\tprintk(KERN_WARNING \"Chip reports voltage low on erase: status 0x%x\\n\", chipstatus);\n\t\t\tret = -EIO;\n\t\t} else if (chipstatus & 0x20) {\n\t\t\tif (retries--) {\n\t\t\t\tprintk(KERN_DEBUG \"Chip erase failed at 0x%08lx: status 0x%x. Retrying...\\n\", adr, chipstatus);\n\t\t\t\ttimeo = jiffies + HZ;\n\t\t\t\tchip->state = FL_STATUS;\n\t\t\t\tmutex_unlock(&chip->mutex);\n\t\t\t\tgoto retry;\n\t\t\t}\n\t\t\tprintk(KERN_DEBUG \"Chip erase failed at 0x%08lx: status 0x%x\\n\", adr, chipstatus);\n\t\t\tret = -EIO;\n\t\t}\n\t}\n\n\twake_up(&chip->wq);\n\tmutex_unlock(&chip->mutex);\n\treturn ret;\n}\n\nstatic int cfi_staa_erase_varsize(struct mtd_info *mtd,\n\t\t\t\t  struct erase_info *instr)\n{\tstruct map_info *map = mtd->priv;\n\tstruct cfi_private *cfi = map->fldrv_priv;\n\tunsigned long adr, len;\n\tint chipnum, ret;\n\tint i, first;\n\tstruct mtd_erase_region_info *regions = mtd->eraseregions;\n\n\t \n\n\ti = 0;\n\n\t \n\n\twhile (i < mtd->numeraseregions && instr->addr >= regions[i].offset)\n\t       i++;\n\ti--;\n\n\t \n\n\tif (instr->addr & (regions[i].erasesize-1))\n\t\treturn -EINVAL;\n\n\t \n\tfirst = i;\n\n\t \n\n\twhile (i<mtd->numeraseregions && (instr->addr + instr->len) >= regions[i].offset)\n\t\ti++;\n\n\t \n\ti--;\n\n\tif ((instr->addr + instr->len) & (regions[i].erasesize-1))\n\t\treturn -EINVAL;\n\n\tchipnum = instr->addr >> cfi->chipshift;\n\tadr = instr->addr - (chipnum << cfi->chipshift);\n\tlen = instr->len;\n\n\ti=first;\n\n\twhile(len) {\n\t\tret = do_erase_oneblock(map, &cfi->chips[chipnum], adr);\n\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tadr += regions[i].erasesize;\n\t\tlen -= regions[i].erasesize;\n\n\t\tif (adr % (1<< cfi->chipshift) == (((unsigned long)regions[i].offset + (regions[i].erasesize * regions[i].numblocks)) %( 1<< cfi->chipshift)))\n\t\t\ti++;\n\n\t\tif (adr >> cfi->chipshift) {\n\t\t\tadr = 0;\n\t\t\tchipnum++;\n\n\t\t\tif (chipnum >= cfi->numchips)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void cfi_staa_sync (struct mtd_info *mtd)\n{\n\tstruct map_info *map = mtd->priv;\n\tstruct cfi_private *cfi = map->fldrv_priv;\n\tint i;\n\tstruct flchip *chip;\n\tint ret = 0;\n\tDECLARE_WAITQUEUE(wait, current);\n\n\tfor (i=0; !ret && i<cfi->numchips; i++) {\n\t\tchip = &cfi->chips[i];\n\n\tretry:\n\t\tmutex_lock(&chip->mutex);\n\n\t\tswitch(chip->state) {\n\t\tcase FL_READY:\n\t\tcase FL_STATUS:\n\t\tcase FL_CFI_QUERY:\n\t\tcase FL_JEDEC_QUERY:\n\t\t\tchip->oldstate = chip->state;\n\t\t\tchip->state = FL_SYNCING;\n\t\t\t \n\t\t\tfallthrough;\n\t\tcase FL_SYNCING:\n\t\t\tmutex_unlock(&chip->mutex);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t \n\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\tadd_wait_queue(&chip->wq, &wait);\n\n\t\t\tmutex_unlock(&chip->mutex);\n\t\t\tschedule();\n\t\t        remove_wait_queue(&chip->wq, &wait);\n\n\t\t\tgoto retry;\n\t\t}\n\t}\n\n\t \n\n\tfor (i--; i >=0; i--) {\n\t\tchip = &cfi->chips[i];\n\n\t\tmutex_lock(&chip->mutex);\n\n\t\tif (chip->state == FL_SYNCING) {\n\t\t\tchip->state = chip->oldstate;\n\t\t\twake_up(&chip->wq);\n\t\t}\n\t\tmutex_unlock(&chip->mutex);\n\t}\n}\n\nstatic inline int do_lock_oneblock(struct map_info *map, struct flchip *chip, unsigned long adr)\n{\n\tstruct cfi_private *cfi = map->fldrv_priv;\n\tmap_word status, status_OK;\n\tunsigned long timeo = jiffies + HZ;\n\tDECLARE_WAITQUEUE(wait, current);\n\n\tadr += chip->start;\n\n\t \n\tstatus_OK = CMD(0x80);\n\n\ttimeo = jiffies + HZ;\nretry:\n\tmutex_lock(&chip->mutex);\n\n\t \n\tswitch (chip->state) {\n\tcase FL_CFI_QUERY:\n\tcase FL_JEDEC_QUERY:\n\tcase FL_READY:\n\t\tmap_write(map, CMD(0x70), adr);\n\t\tchip->state = FL_STATUS;\n\t\tfallthrough;\n\tcase FL_STATUS:\n\t\tstatus = map_read(map, adr);\n\t\tif (map_word_andequal(map, status, status_OK, status_OK))\n\t\t\tbreak;\n\n\t\t \n\t\tif (time_after(jiffies, timeo)) {\n\t\t\tmutex_unlock(&chip->mutex);\n\t\t\tprintk(KERN_ERR \"waiting for chip to be ready timed out in lock\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\n\t\t \n\t\tmutex_unlock(&chip->mutex);\n\t\tcfi_udelay(1);\n\t\tgoto retry;\n\n\tdefault:\n\t\t \n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\tadd_wait_queue(&chip->wq, &wait);\n\t\tmutex_unlock(&chip->mutex);\n\t\tschedule();\n\t\tremove_wait_queue(&chip->wq, &wait);\n\t\ttimeo = jiffies + HZ;\n\t\tgoto retry;\n\t}\n\n\tENABLE_VPP(map);\n\tmap_write(map, CMD(0x60), adr);\n\tmap_write(map, CMD(0x01), adr);\n\tchip->state = FL_LOCKING;\n\n\tmutex_unlock(&chip->mutex);\n\tmsleep(1000);\n\tmutex_lock(&chip->mutex);\n\n\t \n\t \n\n\ttimeo = jiffies + (HZ*2);\n\tfor (;;) {\n\n\t\tstatus = map_read(map, adr);\n\t\tif (map_word_andequal(map, status, status_OK, status_OK))\n\t\t\tbreak;\n\n\t\t \n\t\tif (time_after(jiffies, timeo)) {\n\t\t\tmap_write(map, CMD(0x70), adr);\n\t\t\tchip->state = FL_STATUS;\n\t\t\tprintk(KERN_ERR \"waiting for lock to complete timed out. Xstatus = %lx, status = %lx.\\n\", status.x[0], map_read(map, adr).x[0]);\n\t\t\tDISABLE_VPP(map);\n\t\t\tmutex_unlock(&chip->mutex);\n\t\t\treturn -EIO;\n\t\t}\n\n\t\t \n\t\tmutex_unlock(&chip->mutex);\n\t\tcfi_udelay(1);\n\t\tmutex_lock(&chip->mutex);\n\t}\n\n\t \n\tchip->state = FL_STATUS;\n\tDISABLE_VPP(map);\n\twake_up(&chip->wq);\n\tmutex_unlock(&chip->mutex);\n\treturn 0;\n}\nstatic int cfi_staa_lock(struct mtd_info *mtd, loff_t ofs, uint64_t len)\n{\n\tstruct map_info *map = mtd->priv;\n\tstruct cfi_private *cfi = map->fldrv_priv;\n\tunsigned long adr;\n\tint chipnum, ret;\n#ifdef DEBUG_LOCK_BITS\n\tint ofs_factor = cfi->interleave * cfi->device_type;\n#endif\n\n\tif (ofs & (mtd->erasesize - 1))\n\t\treturn -EINVAL;\n\n\tif (len & (mtd->erasesize -1))\n\t\treturn -EINVAL;\n\n\tchipnum = ofs >> cfi->chipshift;\n\tadr = ofs - (chipnum << cfi->chipshift);\n\n\twhile(len) {\n\n#ifdef DEBUG_LOCK_BITS\n\t\tcfi_send_gen_cmd(0x90, 0x55, 0, map, cfi, cfi->device_type, NULL);\n\t\tprintk(\"before lock: block status register is %x\\n\",cfi_read_query(map, adr+(2*ofs_factor)));\n\t\tcfi_send_gen_cmd(0xff, 0x55, 0, map, cfi, cfi->device_type, NULL);\n#endif\n\n\t\tret = do_lock_oneblock(map, &cfi->chips[chipnum], adr);\n\n#ifdef DEBUG_LOCK_BITS\n\t\tcfi_send_gen_cmd(0x90, 0x55, 0, map, cfi, cfi->device_type, NULL);\n\t\tprintk(\"after lock: block status register is %x\\n\",cfi_read_query(map, adr+(2*ofs_factor)));\n\t\tcfi_send_gen_cmd(0xff, 0x55, 0, map, cfi, cfi->device_type, NULL);\n#endif\n\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tadr += mtd->erasesize;\n\t\tlen -= mtd->erasesize;\n\n\t\tif (adr >> cfi->chipshift) {\n\t\t\tadr = 0;\n\t\t\tchipnum++;\n\n\t\t\tif (chipnum >= cfi->numchips)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}\nstatic inline int do_unlock_oneblock(struct map_info *map, struct flchip *chip, unsigned long adr)\n{\n\tstruct cfi_private *cfi = map->fldrv_priv;\n\tmap_word status, status_OK;\n\tunsigned long timeo = jiffies + HZ;\n\tDECLARE_WAITQUEUE(wait, current);\n\n\tadr += chip->start;\n\n\t \n\tstatus_OK = CMD(0x80);\n\n\ttimeo = jiffies + HZ;\nretry:\n\tmutex_lock(&chip->mutex);\n\n\t \n\tswitch (chip->state) {\n\tcase FL_CFI_QUERY:\n\tcase FL_JEDEC_QUERY:\n\tcase FL_READY:\n\t\tmap_write(map, CMD(0x70), adr);\n\t\tchip->state = FL_STATUS;\n\t\tfallthrough;\n\tcase FL_STATUS:\n\t\tstatus = map_read(map, adr);\n\t\tif (map_word_andequal(map, status, status_OK, status_OK))\n\t\t\tbreak;\n\n\t\t \n\t\tif (time_after(jiffies, timeo)) {\n\t\t\tmutex_unlock(&chip->mutex);\n\t\t\tprintk(KERN_ERR \"waiting for chip to be ready timed out in unlock\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\n\t\t \n\t\tmutex_unlock(&chip->mutex);\n\t\tcfi_udelay(1);\n\t\tgoto retry;\n\n\tdefault:\n\t\t \n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\tadd_wait_queue(&chip->wq, &wait);\n\t\tmutex_unlock(&chip->mutex);\n\t\tschedule();\n\t\tremove_wait_queue(&chip->wq, &wait);\n\t\ttimeo = jiffies + HZ;\n\t\tgoto retry;\n\t}\n\n\tENABLE_VPP(map);\n\tmap_write(map, CMD(0x60), adr);\n\tmap_write(map, CMD(0xD0), adr);\n\tchip->state = FL_UNLOCKING;\n\n\tmutex_unlock(&chip->mutex);\n\tmsleep(1000);\n\tmutex_lock(&chip->mutex);\n\n\t \n\t \n\n\ttimeo = jiffies + (HZ*2);\n\tfor (;;) {\n\n\t\tstatus = map_read(map, adr);\n\t\tif (map_word_andequal(map, status, status_OK, status_OK))\n\t\t\tbreak;\n\n\t\t \n\t\tif (time_after(jiffies, timeo)) {\n\t\t\tmap_write(map, CMD(0x70), adr);\n\t\t\tchip->state = FL_STATUS;\n\t\t\tprintk(KERN_ERR \"waiting for unlock to complete timed out. Xstatus = %lx, status = %lx.\\n\", status.x[0], map_read(map, adr).x[0]);\n\t\t\tDISABLE_VPP(map);\n\t\t\tmutex_unlock(&chip->mutex);\n\t\t\treturn -EIO;\n\t\t}\n\n\t\t \n\t\tmutex_unlock(&chip->mutex);\n\t\tcfi_udelay(1);\n\t\tmutex_lock(&chip->mutex);\n\t}\n\n\t \n\tchip->state = FL_STATUS;\n\tDISABLE_VPP(map);\n\twake_up(&chip->wq);\n\tmutex_unlock(&chip->mutex);\n\treturn 0;\n}\nstatic int cfi_staa_unlock(struct mtd_info *mtd, loff_t ofs, uint64_t len)\n{\n\tstruct map_info *map = mtd->priv;\n\tstruct cfi_private *cfi = map->fldrv_priv;\n\tunsigned long adr;\n\tint chipnum, ret;\n#ifdef DEBUG_LOCK_BITS\n\tint ofs_factor = cfi->interleave * cfi->device_type;\n#endif\n\n\tchipnum = ofs >> cfi->chipshift;\n\tadr = ofs - (chipnum << cfi->chipshift);\n\n#ifdef DEBUG_LOCK_BITS\n\t{\n\t\tunsigned long temp_adr = adr;\n\t\tunsigned long temp_len = len;\n\n\t\tcfi_send_gen_cmd(0x90, 0x55, 0, map, cfi, cfi->device_type, NULL);\n                while (temp_len) {\n\t\t\tprintk(\"before unlock %x: block status register is %x\\n\",temp_adr,cfi_read_query(map, temp_adr+(2*ofs_factor)));\n\t\t\ttemp_adr += mtd->erasesize;\n\t\t\ttemp_len -= mtd->erasesize;\n\t\t}\n\t\tcfi_send_gen_cmd(0xff, 0x55, 0, map, cfi, cfi->device_type, NULL);\n\t}\n#endif\n\n\tret = do_unlock_oneblock(map, &cfi->chips[chipnum], adr);\n\n#ifdef DEBUG_LOCK_BITS\n\tcfi_send_gen_cmd(0x90, 0x55, 0, map, cfi, cfi->device_type, NULL);\n\tprintk(\"after unlock: block status register is %x\\n\",cfi_read_query(map, adr+(2*ofs_factor)));\n\tcfi_send_gen_cmd(0xff, 0x55, 0, map, cfi, cfi->device_type, NULL);\n#endif\n\n\treturn ret;\n}\n\nstatic int cfi_staa_suspend(struct mtd_info *mtd)\n{\n\tstruct map_info *map = mtd->priv;\n\tstruct cfi_private *cfi = map->fldrv_priv;\n\tint i;\n\tstruct flchip *chip;\n\tint ret = 0;\n\n\tfor (i=0; !ret && i<cfi->numchips; i++) {\n\t\tchip = &cfi->chips[i];\n\n\t\tmutex_lock(&chip->mutex);\n\n\t\tswitch(chip->state) {\n\t\tcase FL_READY:\n\t\tcase FL_STATUS:\n\t\tcase FL_CFI_QUERY:\n\t\tcase FL_JEDEC_QUERY:\n\t\t\tchip->oldstate = chip->state;\n\t\t\tchip->state = FL_PM_SUSPENDED;\n\t\t\t \n\t\t\tbreak;\n\n\t\tcase FL_PM_SUSPENDED:\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tret = -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\t\tmutex_unlock(&chip->mutex);\n\t}\n\n\t \n\n\tif (ret) {\n\t\tfor (i--; i >=0; i--) {\n\t\t\tchip = &cfi->chips[i];\n\n\t\t\tmutex_lock(&chip->mutex);\n\n\t\t\tif (chip->state == FL_PM_SUSPENDED) {\n\t\t\t\t \n\t\t\t\tchip->state = chip->oldstate;\n\t\t\t\twake_up(&chip->wq);\n\t\t\t}\n\t\t\tmutex_unlock(&chip->mutex);\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic void cfi_staa_resume(struct mtd_info *mtd)\n{\n\tstruct map_info *map = mtd->priv;\n\tstruct cfi_private *cfi = map->fldrv_priv;\n\tint i;\n\tstruct flchip *chip;\n\n\tfor (i=0; i<cfi->numchips; i++) {\n\n\t\tchip = &cfi->chips[i];\n\n\t\tmutex_lock(&chip->mutex);\n\n\t\t \n\t\tif (chip->state == FL_PM_SUSPENDED) {\n\t\t\tmap_write(map, CMD(0xFF), 0);\n\t\t\tchip->state = FL_READY;\n\t\t\twake_up(&chip->wq);\n\t\t}\n\n\t\tmutex_unlock(&chip->mutex);\n\t}\n}\n\nstatic void cfi_staa_destroy(struct mtd_info *mtd)\n{\n\tstruct map_info *map = mtd->priv;\n\tstruct cfi_private *cfi = map->fldrv_priv;\n\tkfree(cfi->cmdset_priv);\n\tkfree(cfi);\n}\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}