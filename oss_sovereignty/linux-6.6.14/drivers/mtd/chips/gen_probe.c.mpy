{
  "module_name": "gen_probe.c",
  "hash_id": "324dd330ac4566225471b6e95fe0ec0d37a9acdd862fb72001e8c152b4f59e82",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/chips/gen_probe.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mtd/mtd.h>\n#include <linux/mtd/map.h>\n#include <linux/mtd/cfi.h>\n#include <linux/mtd/gen_probe.h>\n\nstatic struct mtd_info *check_cmd_set(struct map_info *, int);\nstatic struct cfi_private *genprobe_ident_chips(struct map_info *map,\n\t\t\t\t\t\tstruct chip_probe *cp);\nstatic int genprobe_new_chip(struct map_info *map, struct chip_probe *cp,\n\t\t\t     struct cfi_private *cfi);\n\nstruct mtd_info *mtd_do_chip_probe(struct map_info *map, struct chip_probe *cp)\n{\n\tstruct mtd_info *mtd;\n\tstruct cfi_private *cfi;\n\n\t \n\tcfi = genprobe_ident_chips(map, cp);\n\n\tif (!cfi)\n\t\treturn NULL;\n\n\tmap->fldrv_priv = cfi;\n\t \n\n\tmtd = check_cmd_set(map, 1);  \n\tif (!mtd)\n\t\tmtd = check_cmd_set(map, 0);  \n\n\tif (mtd) {\n\t\tif (mtd->size > map->size) {\n\t\t\tprintk(KERN_WARNING \"Reducing visibility of %ldKiB chip to %ldKiB\\n\",\n\t\t\t       (unsigned long)mtd->size >> 10,\n\t\t\t       (unsigned long)map->size >> 10);\n\t\t\tmtd->size = map->size;\n\t\t}\n\t\treturn mtd;\n\t}\n\n\tprintk(KERN_WARNING\"gen_probe: No supported Vendor Command Set found\\n\");\n\n\tkfree(cfi->cfiq);\n\tkfree(cfi);\n\tmap->fldrv_priv = NULL;\n\treturn NULL;\n}\nEXPORT_SYMBOL(mtd_do_chip_probe);\n\n\nstatic struct cfi_private *genprobe_ident_chips(struct map_info *map, struct chip_probe *cp)\n{\n\tstruct cfi_private cfi;\n\tstruct cfi_private *retcfi;\n\tunsigned long *chip_map;\n\tint max_chips;\n\tint i, j;\n\n\tmemset(&cfi, 0, sizeof(cfi));\n\n\t \n\tif (!genprobe_new_chip(map, cp, &cfi)) {\n\t\t \n\t\tpr_debug(\"%s: Found no %s device at location zero\\n\",\n\t\t\t cp->name, map->name);\n\t\treturn NULL;\n\t}\n\n#if 0  \n\tif (cfi.cfiq->NumEraseRegions == 0) {\n\t\tprintk(KERN_WARNING \"Number of erase regions is zero\\n\");\n\t\tkfree(cfi.cfiq);\n\t\treturn NULL;\n\t}\n#endif\n\tcfi.chipshift = cfi.cfiq->DevSize;\n\n\tif (cfi_interleave_is_1(&cfi)) {\n\t\t;\n\t} else if (cfi_interleave_is_2(&cfi)) {\n\t\tcfi.chipshift++;\n\t} else if (cfi_interleave_is_4((&cfi))) {\n\t\tcfi.chipshift += 2;\n\t} else if (cfi_interleave_is_8(&cfi)) {\n\t\tcfi.chipshift += 3;\n\t} else {\n\t\tBUG();\n\t}\n\n\tcfi.numchips = 1;\n\n\t \n\tmax_chips = map->size >> cfi.chipshift;\n\tif (!max_chips) {\n\t\tprintk(KERN_WARNING \"NOR chip too large to fit in mapping. Attempting to cope...\\n\");\n\t\tmax_chips = 1;\n\t}\n\n\tchip_map = bitmap_zalloc(max_chips, GFP_KERNEL);\n\tif (!chip_map) {\n\t\tkfree(cfi.cfiq);\n\t\treturn NULL;\n\t}\n\n\tset_bit(0, chip_map);  \n\n\t \n\n\tfor (i = 1; i < max_chips; i++) {\n\t\tcp->probe_chip(map, i << cfi.chipshift, chip_map, &cfi);\n\t}\n\n\t \n\n\tretcfi = kmalloc(struct_size(retcfi, chips, cfi.numchips), GFP_KERNEL);\n\n\tif (!retcfi) {\n\t\tkfree(cfi.cfiq);\n\t\tbitmap_free(chip_map);\n\t\treturn NULL;\n\t}\n\n\tmemcpy(retcfi, &cfi, sizeof(cfi));\n\tmemset(&retcfi->chips[0], 0, sizeof(struct flchip) * cfi.numchips);\n\n\tfor (i = 0, j = 0; (j < cfi.numchips) && (i < max_chips); i++) {\n\t\tif(test_bit(i, chip_map)) {\n\t\t\tstruct flchip *pchip = &retcfi->chips[j++];\n\n\t\t\tpchip->start = (i << cfi.chipshift);\n\t\t\tpchip->state = FL_READY;\n\t\t\tinit_waitqueue_head(&pchip->wq);\n\t\t\tmutex_init(&pchip->mutex);\n\t\t}\n\t}\n\n\tbitmap_free(chip_map);\n\treturn retcfi;\n}\n\n\nstatic int genprobe_new_chip(struct map_info *map, struct chip_probe *cp,\n\t\t\t     struct cfi_private *cfi)\n{\n\tint min_chips = (map_bankwidth(map)/4?:1);  \n\tint max_chips = map_bankwidth(map);  \n\tint nr_chips, type;\n\n\tfor (nr_chips = max_chips; nr_chips >= min_chips; nr_chips >>= 1) {\n\n\t\tif (!cfi_interleave_supported(nr_chips))\n\t\t    continue;\n\n\t\tcfi->interleave = nr_chips;\n\n\t\t \n\t\ttype = map_bankwidth(map) / nr_chips;\n\n\t\tfor (; type <= CFI_DEVICETYPE_X32; type<<=1) {\n\t\t\tcfi->device_type = type;\n\n\t\t\tif (cp->probe_chip(map, 0, NULL, cfi))\n\t\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\ntypedef struct mtd_info *cfi_cmdset_fn_t(struct map_info *, int);\n\nextern cfi_cmdset_fn_t cfi_cmdset_0001;\nextern cfi_cmdset_fn_t cfi_cmdset_0002;\nextern cfi_cmdset_fn_t cfi_cmdset_0020;\n\nstatic inline struct mtd_info *cfi_cmdset_unknown(struct map_info *map,\n\t\t\t\t\t\t  int primary)\n{\n\tstruct cfi_private *cfi = map->fldrv_priv;\n\t__u16 type = primary?cfi->cfiq->P_ID:cfi->cfiq->A_ID;\n#ifdef CONFIG_MODULES\n\tcfi_cmdset_fn_t *probe_function;\n\tchar *probename;\n\n\tprobename = kasprintf(GFP_KERNEL, \"cfi_cmdset_%4.4X\", type);\n\tif (!probename)\n\t\treturn NULL;\n\n\tprobe_function = __symbol_get(probename);\n\tif (!probe_function) {\n\t\trequest_module(\"cfi_cmdset_%4.4X\", type);\n\t\tprobe_function = __symbol_get(probename);\n\t}\n\tkfree(probename);\n\n\tif (probe_function) {\n\t\tstruct mtd_info *mtd;\n\n\t\tmtd = (*probe_function)(map, primary);\n\t\t \n\t\tsymbol_put_addr(probe_function);\n\t\treturn mtd;\n\t}\n#endif\n\tprintk(KERN_NOTICE \"Support for command set %04X not present\\n\", type);\n\n\treturn NULL;\n}\n\nstatic struct mtd_info *check_cmd_set(struct map_info *map, int primary)\n{\n\tstruct cfi_private *cfi = map->fldrv_priv;\n\t__u16 type = primary?cfi->cfiq->P_ID:cfi->cfiq->A_ID;\n\n\tif (type == P_ID_NONE || type == P_ID_RESERVED)\n\t\treturn NULL;\n\n\tswitch(type){\n\t\t \n#ifdef CONFIG_MTD_CFI_INTELEXT\n\tcase P_ID_INTEL_EXT:\n\tcase P_ID_INTEL_STD:\n\tcase P_ID_INTEL_PERFORMANCE:\n\t\treturn cfi_cmdset_0001(map, primary);\n#endif\n#ifdef CONFIG_MTD_CFI_AMDSTD\n\tcase P_ID_AMD_STD:\n\tcase P_ID_SST_OLD:\n\tcase P_ID_WINBOND:\n\t\treturn cfi_cmdset_0002(map, primary);\n#endif\n#ifdef CONFIG_MTD_CFI_STAA\n        case P_ID_ST_ADV:\n\t\treturn cfi_cmdset_0020(map, primary);\n#endif\n\tdefault:\n\t\treturn cfi_cmdset_unknown(map, primary);\n\t}\n}\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"David Woodhouse <dwmw2@infradead.org>\");\nMODULE_DESCRIPTION(\"Helper routines for flash chip probe code\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}