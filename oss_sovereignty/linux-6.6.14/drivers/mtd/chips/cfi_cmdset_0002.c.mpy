{
  "module_name": "cfi_cmdset_0002.c",
  "hash_id": "7931cef791b89e0a5091a3e3c1dfbcf02018ca1ad35ca98c7979007fd18c7061",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/chips/cfi_cmdset_0002.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <asm/io.h>\n#include <asm/byteorder.h>\n\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/reboot.h>\n#include <linux/of.h>\n#include <linux/mtd/map.h>\n#include <linux/mtd/mtd.h>\n#include <linux/mtd/cfi.h>\n#include <linux/mtd/xip.h>\n\n#define AMD_BOOTLOC_BUG\n#define FORCE_WORD_WRITE 0\n\n#define MAX_RETRIES 3\n\n#define SST49LF004B\t\t0x0060\n#define SST49LF040B\t\t0x0050\n#define SST49LF008A\t\t0x005a\n#define AT49BV6416\t\t0x00d6\n#define S29GL064N_MN12\t\t0x0c01\n\n \n#define CFI_SR_DRB\t\tBIT(7)\n#define CFI_SR_ESB\t\tBIT(5)\n#define CFI_SR_PSB\t\tBIT(4)\n#define CFI_SR_WBASB\t\tBIT(3)\n#define CFI_SR_SLSB\t\tBIT(1)\n\nenum cfi_quirks {\n\tCFI_QUIRK_DQ_TRUE_DATA = BIT(0),\n};\n\nstatic int cfi_amdstd_read (struct mtd_info *, loff_t, size_t, size_t *, u_char *);\nstatic int cfi_amdstd_write_words(struct mtd_info *, loff_t, size_t, size_t *, const u_char *);\n#if !FORCE_WORD_WRITE\nstatic int cfi_amdstd_write_buffers(struct mtd_info *, loff_t, size_t, size_t *, const u_char *);\n#endif\nstatic int cfi_amdstd_erase_chip(struct mtd_info *, struct erase_info *);\nstatic int cfi_amdstd_erase_varsize(struct mtd_info *, struct erase_info *);\nstatic void cfi_amdstd_sync (struct mtd_info *);\nstatic int cfi_amdstd_suspend (struct mtd_info *);\nstatic void cfi_amdstd_resume (struct mtd_info *);\nstatic int cfi_amdstd_reboot(struct notifier_block *, unsigned long, void *);\nstatic int cfi_amdstd_get_fact_prot_info(struct mtd_info *, size_t,\n\t\t\t\t\t size_t *, struct otp_info *);\nstatic int cfi_amdstd_get_user_prot_info(struct mtd_info *, size_t,\n\t\t\t\t\t size_t *, struct otp_info *);\nstatic int cfi_amdstd_secsi_read (struct mtd_info *, loff_t, size_t, size_t *, u_char *);\nstatic int cfi_amdstd_read_fact_prot_reg(struct mtd_info *, loff_t, size_t,\n\t\t\t\t\t size_t *, u_char *);\nstatic int cfi_amdstd_read_user_prot_reg(struct mtd_info *, loff_t, size_t,\n\t\t\t\t\t size_t *, u_char *);\nstatic int cfi_amdstd_write_user_prot_reg(struct mtd_info *, loff_t, size_t,\n\t\t\t\t\t  size_t *, const u_char *);\nstatic int cfi_amdstd_lock_user_prot_reg(struct mtd_info *, loff_t, size_t);\n\nstatic int cfi_amdstd_panic_write(struct mtd_info *mtd, loff_t to, size_t len,\n\t\t\t\t  size_t *retlen, const u_char *buf);\n\nstatic void cfi_amdstd_destroy(struct mtd_info *);\n\nstruct mtd_info *cfi_cmdset_0002(struct map_info *, int);\nstatic struct mtd_info *cfi_amdstd_setup (struct mtd_info *);\n\nstatic int get_chip(struct map_info *map, struct flchip *chip, unsigned long adr, int mode);\nstatic void put_chip(struct map_info *map, struct flchip *chip, unsigned long adr);\n#include \"fwh_lock.h\"\n\nstatic int cfi_atmel_lock(struct mtd_info *mtd, loff_t ofs, uint64_t len);\nstatic int cfi_atmel_unlock(struct mtd_info *mtd, loff_t ofs, uint64_t len);\n\nstatic int cfi_ppb_lock(struct mtd_info *mtd, loff_t ofs, uint64_t len);\nstatic int cfi_ppb_unlock(struct mtd_info *mtd, loff_t ofs, uint64_t len);\nstatic int cfi_ppb_is_locked(struct mtd_info *mtd, loff_t ofs, uint64_t len);\n\nstatic struct mtd_chip_driver cfi_amdstd_chipdrv = {\n\t.probe\t\t= NULL,  \n\t.destroy\t= cfi_amdstd_destroy,\n\t.name\t\t= \"cfi_cmdset_0002\",\n\t.module\t\t= THIS_MODULE\n};\n\n \nstatic int cfi_use_status_reg(struct cfi_private *cfi)\n{\n\tstruct cfi_pri_amdstd *extp = cfi->cmdset_priv;\n\tu8 poll_mask = CFI_POLL_STATUS_REG | CFI_POLL_DQ;\n\n\treturn extp && extp->MinorVersion >= '5' &&\n\t\t(extp->SoftwareFeatures & poll_mask) == CFI_POLL_STATUS_REG;\n}\n\nstatic int cfi_check_err_status(struct map_info *map, struct flchip *chip,\n\t\t\t\tunsigned long adr)\n{\n\tstruct cfi_private *cfi = map->fldrv_priv;\n\tmap_word status;\n\n\tif (!cfi_use_status_reg(cfi))\n\t\treturn 0;\n\n\tcfi_send_gen_cmd(0x70, cfi->addr_unlock1, chip->start, map, cfi,\n\t\t\t cfi->device_type, NULL);\n\tstatus = map_read(map, adr);\n\n\t \n\tif (!map_word_bitsset(map, status, CMD(CFI_SR_DRB)))\n\t\treturn 0;\n\n\tif (map_word_bitsset(map, status, CMD(0x3a))) {\n\t\tunsigned long chipstatus = MERGESTATUS(status);\n\n\t\tif (chipstatus & CFI_SR_ESB)\n\t\t\tpr_err(\"%s erase operation failed, status %lx\\n\",\n\t\t\t       map->name, chipstatus);\n\t\tif (chipstatus & CFI_SR_PSB)\n\t\t\tpr_err(\"%s program operation failed, status %lx\\n\",\n\t\t\t       map->name, chipstatus);\n\t\tif (chipstatus & CFI_SR_WBASB)\n\t\t\tpr_err(\"%s buffer program command aborted, status %lx\\n\",\n\t\t\t       map->name, chipstatus);\n\t\tif (chipstatus & CFI_SR_SLSB)\n\t\t\tpr_err(\"%s sector write protected, status %lx\\n\",\n\t\t\t       map->name, chipstatus);\n\n\t\t \n\t\tif (chipstatus & (CFI_SR_ESB | CFI_SR_PSB))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n \n\n\n#ifdef DEBUG_CFI_FEATURES\nstatic void cfi_tell_features(struct cfi_pri_amdstd *extp)\n{\n\tconst char* erase_suspend[3] = {\n\t\t\"Not supported\", \"Read only\", \"Read/write\"\n\t};\n\tconst char* top_bottom[6] = {\n\t\t\"No WP\", \"8x8KiB sectors at top & bottom, no WP\",\n\t\t\"Bottom boot\", \"Top boot\",\n\t\t\"Uniform, Bottom WP\", \"Uniform, Top WP\"\n\t};\n\n\tprintk(\"  Silicon revision: %d\\n\", extp->SiliconRevision >> 1);\n\tprintk(\"  Address sensitive unlock: %s\\n\",\n\t       (extp->SiliconRevision & 1) ? \"Not required\" : \"Required\");\n\n\tif (extp->EraseSuspend < ARRAY_SIZE(erase_suspend))\n\t\tprintk(\"  Erase Suspend: %s\\n\", erase_suspend[extp->EraseSuspend]);\n\telse\n\t\tprintk(\"  Erase Suspend: Unknown value %d\\n\", extp->EraseSuspend);\n\n\tif (extp->BlkProt == 0)\n\t\tprintk(\"  Block protection: Not supported\\n\");\n\telse\n\t\tprintk(\"  Block protection: %d sectors per group\\n\", extp->BlkProt);\n\n\n\tprintk(\"  Temporary block unprotect: %s\\n\",\n\t       extp->TmpBlkUnprotect ? \"Supported\" : \"Not supported\");\n\tprintk(\"  Block protect/unprotect scheme: %d\\n\", extp->BlkProtUnprot);\n\tprintk(\"  Number of simultaneous operations: %d\\n\", extp->SimultaneousOps);\n\tprintk(\"  Burst mode: %s\\n\",\n\t       extp->BurstMode ? \"Supported\" : \"Not supported\");\n\tif (extp->PageMode == 0)\n\t\tprintk(\"  Page mode: Not supported\\n\");\n\telse\n\t\tprintk(\"  Page mode: %d word page\\n\", extp->PageMode << 2);\n\n\tprintk(\"  Vpp Supply Minimum Program/Erase Voltage: %d.%d V\\n\",\n\t       extp->VppMin >> 4, extp->VppMin & 0xf);\n\tprintk(\"  Vpp Supply Maximum Program/Erase Voltage: %d.%d V\\n\",\n\t       extp->VppMax >> 4, extp->VppMax & 0xf);\n\n\tif (extp->TopBottom < ARRAY_SIZE(top_bottom))\n\t\tprintk(\"  Top/Bottom Boot Block: %s\\n\", top_bottom[extp->TopBottom]);\n\telse\n\t\tprintk(\"  Top/Bottom Boot Block: Unknown value %d\\n\", extp->TopBottom);\n}\n#endif\n\n#ifdef AMD_BOOTLOC_BUG\n \nstatic void fixup_amd_bootblock(struct mtd_info *mtd)\n{\n\tstruct map_info *map = mtd->priv;\n\tstruct cfi_private *cfi = map->fldrv_priv;\n\tstruct cfi_pri_amdstd *extp = cfi->cmdset_priv;\n\t__u8 major = extp->MajorVersion;\n\t__u8 minor = extp->MinorVersion;\n\n\tif (((major << 8) | minor) < 0x3131) {\n\t\t \n\n\t\tpr_debug(\"%s: JEDEC Vendor ID is 0x%02X Device ID is 0x%02X\\n\",\n\t\t\tmap->name, cfi->mfr, cfi->id);\n\n\t\t \n\t\tif (((cfi->id == 0xBA) || (cfi->id == 0x22BA)) &&\n\n\t\t\t \n\t\t\t(cfi->mfr == CFI_MFR_MACRONIX)) {\n\t\t\tpr_debug(\"%s: Macronix MX29LV400C with bottom boot block\"\n\t\t\t\t\" detected\\n\", map->name);\n\t\t\textp->TopBottom = 2;\t \n\t\t} else\n\t\tif (cfi->id & 0x80) {\n\t\t\tprintk(KERN_WARNING \"%s: JEDEC Device ID is 0x%02X. Assuming broken CFI table.\\n\", map->name, cfi->id);\n\t\t\textp->TopBottom = 3;\t \n\t\t} else {\n\t\t\textp->TopBottom = 2;\t \n\t\t}\n\n\t\tpr_debug(\"%s: AMD CFI PRI V%c.%c has no boot block field;\"\n\t\t\t\" deduced %s from Device ID\\n\", map->name, major, minor,\n\t\t\textp->TopBottom == 2 ? \"bottom\" : \"top\");\n\t}\n}\n#endif\n\n#if !FORCE_WORD_WRITE\nstatic void fixup_use_write_buffers(struct mtd_info *mtd)\n{\n\tstruct map_info *map = mtd->priv;\n\tstruct cfi_private *cfi = map->fldrv_priv;\n\n\tif (cfi->mfr == CFI_MFR_AMD && cfi->id == 0x2201)\n\t\treturn;\n\n\tif (cfi->cfiq->BufWriteTimeoutTyp) {\n\t\tpr_debug(\"Using buffer write method\\n\");\n\t\tmtd->_write = cfi_amdstd_write_buffers;\n\t}\n}\n#endif  \n\n \nstatic void fixup_convert_atmel_pri(struct mtd_info *mtd)\n{\n\tstruct map_info *map = mtd->priv;\n\tstruct cfi_private *cfi = map->fldrv_priv;\n\tstruct cfi_pri_amdstd *extp = cfi->cmdset_priv;\n\tstruct cfi_pri_atmel atmel_pri;\n\n\tmemcpy(&atmel_pri, extp, sizeof(atmel_pri));\n\tmemset((char *)extp + 5, 0, sizeof(*extp) - 5);\n\n\tif (atmel_pri.Features & 0x02)\n\t\textp->EraseSuspend = 2;\n\n\t \n\tif (cfi->id == AT49BV6416) {\n\t\tif (atmel_pri.BottomBoot)\n\t\t\textp->TopBottom = 3;\n\t\telse\n\t\t\textp->TopBottom = 2;\n\t} else {\n\t\tif (atmel_pri.BottomBoot)\n\t\t\textp->TopBottom = 2;\n\t\telse\n\t\t\textp->TopBottom = 3;\n\t}\n\n\t \n\tcfi->cfiq->BufWriteTimeoutTyp = 0;\n\tcfi->cfiq->BufWriteTimeoutMax = 0;\n}\n\nstatic void fixup_use_secsi(struct mtd_info *mtd)\n{\n\t \n\tmtd->_read_user_prot_reg = cfi_amdstd_secsi_read;\n\tmtd->_read_fact_prot_reg = cfi_amdstd_secsi_read;\n}\n\nstatic void fixup_use_erase_chip(struct mtd_info *mtd)\n{\n\tstruct map_info *map = mtd->priv;\n\tstruct cfi_private *cfi = map->fldrv_priv;\n\tif ((cfi->cfiq->NumEraseRegions == 1) &&\n\t\t((cfi->cfiq->EraseRegionInfo[0] & 0xffff) == 0)) {\n\t\tmtd->_erase = cfi_amdstd_erase_chip;\n\t}\n\n}\n\n \nstatic void fixup_use_atmel_lock(struct mtd_info *mtd)\n{\n\tmtd->_lock = cfi_atmel_lock;\n\tmtd->_unlock = cfi_atmel_unlock;\n\tmtd->flags |= MTD_POWERUP_LOCK;\n}\n\nstatic void fixup_old_sst_eraseregion(struct mtd_info *mtd)\n{\n\tstruct map_info *map = mtd->priv;\n\tstruct cfi_private *cfi = map->fldrv_priv;\n\n\t \n\tcfi->cfiq->NumEraseRegions = 1;\n}\n\nstatic void fixup_sst39vf(struct mtd_info *mtd)\n{\n\tstruct map_info *map = mtd->priv;\n\tstruct cfi_private *cfi = map->fldrv_priv;\n\n\tfixup_old_sst_eraseregion(mtd);\n\n\tcfi->addr_unlock1 = 0x5555;\n\tcfi->addr_unlock2 = 0x2AAA;\n}\n\nstatic void fixup_sst39vf_rev_b(struct mtd_info *mtd)\n{\n\tstruct map_info *map = mtd->priv;\n\tstruct cfi_private *cfi = map->fldrv_priv;\n\n\tfixup_old_sst_eraseregion(mtd);\n\n\tcfi->addr_unlock1 = 0x555;\n\tcfi->addr_unlock2 = 0x2AA;\n\n\tcfi->sector_erase_cmd = CMD(0x50);\n}\n\nstatic void fixup_sst38vf640x_sectorsize(struct mtd_info *mtd)\n{\n\tstruct map_info *map = mtd->priv;\n\tstruct cfi_private *cfi = map->fldrv_priv;\n\n\tfixup_sst39vf_rev_b(mtd);\n\n\t \n\tcfi->cfiq->EraseRegionInfo[0] = 0x002003ff;\n\tpr_warn(\"%s: Bad 38VF640x CFI data; adjusting sector size from 64 to 8KiB\\n\",\n\t\tmtd->name);\n}\n\nstatic void fixup_s29gl064n_sectors(struct mtd_info *mtd)\n{\n\tstruct map_info *map = mtd->priv;\n\tstruct cfi_private *cfi = map->fldrv_priv;\n\n\tif ((cfi->cfiq->EraseRegionInfo[0] & 0xffff) == 0x003f) {\n\t\tcfi->cfiq->EraseRegionInfo[0] |= 0x0040;\n\t\tpr_warn(\"%s: Bad S29GL064N CFI data; adjust from 64 to 128 sectors\\n\",\n\t\t\tmtd->name);\n\t}\n}\n\nstatic void fixup_s29gl032n_sectors(struct mtd_info *mtd)\n{\n\tstruct map_info *map = mtd->priv;\n\tstruct cfi_private *cfi = map->fldrv_priv;\n\n\tif ((cfi->cfiq->EraseRegionInfo[1] & 0xffff) == 0x007e) {\n\t\tcfi->cfiq->EraseRegionInfo[1] &= ~0x0040;\n\t\tpr_warn(\"%s: Bad S29GL032N CFI data; adjust from 127 to 63 sectors\\n\",\n\t\t\tmtd->name);\n\t}\n}\n\nstatic void fixup_s29ns512p_sectors(struct mtd_info *mtd)\n{\n\tstruct map_info *map = mtd->priv;\n\tstruct cfi_private *cfi = map->fldrv_priv;\n\n\t \n\tcfi->cfiq->EraseRegionInfo[0] = 0x020001ff;\n\tpr_warn(\"%s: Bad S29NS512P CFI data; adjust to 512 sectors\\n\",\n\t\tmtd->name);\n}\n\nstatic void fixup_quirks(struct mtd_info *mtd)\n{\n\tstruct map_info *map = mtd->priv;\n\tstruct cfi_private *cfi = map->fldrv_priv;\n\n\tif (cfi->mfr == CFI_MFR_AMD && cfi->id == S29GL064N_MN12)\n\t\tcfi->quirks |= CFI_QUIRK_DQ_TRUE_DATA;\n}\n\n \nstatic struct cfi_fixup cfi_nopri_fixup_table[] = {\n\t{ CFI_MFR_SST, 0x234a, fixup_sst39vf },  \n\t{ CFI_MFR_SST, 0x234b, fixup_sst39vf },  \n\t{ CFI_MFR_SST, 0x235a, fixup_sst39vf },  \n\t{ CFI_MFR_SST, 0x235b, fixup_sst39vf },  \n\t{ CFI_MFR_SST, 0x235c, fixup_sst39vf_rev_b },  \n\t{ CFI_MFR_SST, 0x235d, fixup_sst39vf_rev_b },  \n\t{ CFI_MFR_SST, 0x236c, fixup_sst39vf_rev_b },  \n\t{ CFI_MFR_SST, 0x236d, fixup_sst39vf_rev_b },  \n\t{ 0, 0, NULL }\n};\n\nstatic struct cfi_fixup cfi_fixup_table[] = {\n\t{ CFI_MFR_ATMEL, CFI_ID_ANY, fixup_convert_atmel_pri },\n#ifdef AMD_BOOTLOC_BUG\n\t{ CFI_MFR_AMD, CFI_ID_ANY, fixup_amd_bootblock },\n\t{ CFI_MFR_AMIC, CFI_ID_ANY, fixup_amd_bootblock },\n\t{ CFI_MFR_MACRONIX, CFI_ID_ANY, fixup_amd_bootblock },\n#endif\n\t{ CFI_MFR_AMD, 0x0050, fixup_use_secsi },\n\t{ CFI_MFR_AMD, 0x0053, fixup_use_secsi },\n\t{ CFI_MFR_AMD, 0x0055, fixup_use_secsi },\n\t{ CFI_MFR_AMD, 0x0056, fixup_use_secsi },\n\t{ CFI_MFR_AMD, 0x005C, fixup_use_secsi },\n\t{ CFI_MFR_AMD, 0x005F, fixup_use_secsi },\n\t{ CFI_MFR_AMD, S29GL064N_MN12, fixup_s29gl064n_sectors },\n\t{ CFI_MFR_AMD, 0x1301, fixup_s29gl064n_sectors },\n\t{ CFI_MFR_AMD, 0x1a00, fixup_s29gl032n_sectors },\n\t{ CFI_MFR_AMD, 0x1a01, fixup_s29gl032n_sectors },\n\t{ CFI_MFR_AMD, 0x3f00, fixup_s29ns512p_sectors },\n\t{ CFI_MFR_SST, 0x536a, fixup_sst38vf640x_sectorsize },  \n\t{ CFI_MFR_SST, 0x536b, fixup_sst38vf640x_sectorsize },  \n\t{ CFI_MFR_SST, 0x536c, fixup_sst38vf640x_sectorsize },  \n\t{ CFI_MFR_SST, 0x536d, fixup_sst38vf640x_sectorsize },  \n#if !FORCE_WORD_WRITE\n\t{ CFI_MFR_ANY, CFI_ID_ANY, fixup_use_write_buffers },\n#endif\n\t{ CFI_MFR_ANY, CFI_ID_ANY, fixup_quirks },\n\t{ 0, 0, NULL }\n};\nstatic struct cfi_fixup jedec_fixup_table[] = {\n\t{ CFI_MFR_SST, SST49LF004B, fixup_use_fwh_lock },\n\t{ CFI_MFR_SST, SST49LF040B, fixup_use_fwh_lock },\n\t{ CFI_MFR_SST, SST49LF008A, fixup_use_fwh_lock },\n\t{ 0, 0, NULL }\n};\n\nstatic struct cfi_fixup fixup_table[] = {\n\t \n\t{ CFI_MFR_ANY, CFI_ID_ANY, fixup_use_erase_chip },\n\t{ CFI_MFR_ATMEL, AT49BV6416, fixup_use_atmel_lock },\n\t{ 0, 0, NULL }\n};\n\n\nstatic void cfi_fixup_major_minor(struct cfi_private *cfi,\n\t\t\t\t  struct cfi_pri_amdstd *extp)\n{\n\tif (cfi->mfr == CFI_MFR_SAMSUNG) {\n\t\tif ((extp->MajorVersion == '0' && extp->MinorVersion == '0') ||\n\t\t    (extp->MajorVersion == '3' && extp->MinorVersion == '3')) {\n\t\t\t \n\t\t\tprintk(KERN_NOTICE \"  Fixing Samsung's Amd/Fujitsu\"\n\t\t\t       \" Extended Query version to 1.%c\\n\",\n\t\t\t       extp->MinorVersion);\n\t\t\textp->MajorVersion = '1';\n\t\t}\n\t}\n\n\t \n\tif (cfi->mfr == CFI_MFR_SST && (cfi->id >> 4) == 0x0536) {\n\t\textp->MajorVersion = '1';\n\t\textp->MinorVersion = '0';\n\t}\n}\n\nstatic int is_m29ew(struct cfi_private *cfi)\n{\n\tif (cfi->mfr == CFI_MFR_INTEL &&\n\t    ((cfi->device_type == CFI_DEVICETYPE_X8 && (cfi->id & 0xff) == 0x7e) ||\n\t     (cfi->device_type == CFI_DEVICETYPE_X16 && cfi->id == 0x227e)))\n\t\treturn 1;\n\treturn 0;\n}\n\n \nstatic void cfi_fixup_m29ew_erase_suspend(struct map_info *map,\n\t\t\t\t\t  unsigned long adr)\n{\n\tstruct cfi_private *cfi = map->fldrv_priv;\n\t \n\tif (is_m29ew(cfi))\n\t\tmap_write(map, CMD(0xF0), adr);\n}\n\n \nstatic void cfi_fixup_m29ew_delay_after_resume(struct cfi_private *cfi)\n{\n\t \n\tif (is_m29ew(cfi))\n\t\tcfi_udelay(500);\n}\n\nstruct mtd_info *cfi_cmdset_0002(struct map_info *map, int primary)\n{\n\tstruct cfi_private *cfi = map->fldrv_priv;\n\tstruct device_node __maybe_unused *np = map->device_node;\n\tstruct mtd_info *mtd;\n\tint i;\n\n\tmtd = kzalloc(sizeof(*mtd), GFP_KERNEL);\n\tif (!mtd)\n\t\treturn NULL;\n\tmtd->priv = map;\n\tmtd->type = MTD_NORFLASH;\n\n\t \n\tmtd->_erase   = cfi_amdstd_erase_varsize;\n\tmtd->_write   = cfi_amdstd_write_words;\n\tmtd->_read    = cfi_amdstd_read;\n\tmtd->_sync    = cfi_amdstd_sync;\n\tmtd->_suspend = cfi_amdstd_suspend;\n\tmtd->_resume  = cfi_amdstd_resume;\n\tmtd->_read_user_prot_reg = cfi_amdstd_read_user_prot_reg;\n\tmtd->_read_fact_prot_reg = cfi_amdstd_read_fact_prot_reg;\n\tmtd->_get_fact_prot_info = cfi_amdstd_get_fact_prot_info;\n\tmtd->_get_user_prot_info = cfi_amdstd_get_user_prot_info;\n\tmtd->_write_user_prot_reg = cfi_amdstd_write_user_prot_reg;\n\tmtd->_lock_user_prot_reg = cfi_amdstd_lock_user_prot_reg;\n\tmtd->flags   = MTD_CAP_NORFLASH;\n\tmtd->name    = map->name;\n\tmtd->writesize = 1;\n\tmtd->writebufsize = cfi_interleave(cfi) << cfi->cfiq->MaxBufWriteSize;\n\n\tpr_debug(\"MTD %s(): write buffer size %d\\n\", __func__,\n\t\t\tmtd->writebufsize);\n\n\tmtd->_panic_write = cfi_amdstd_panic_write;\n\tmtd->reboot_notifier.notifier_call = cfi_amdstd_reboot;\n\n\tif (cfi->cfi_mode==CFI_MODE_CFI){\n\t\tunsigned char bootloc;\n\t\t__u16 adr = primary?cfi->cfiq->P_ADR:cfi->cfiq->A_ADR;\n\t\tstruct cfi_pri_amdstd *extp;\n\n\t\textp = (struct cfi_pri_amdstd*)cfi_read_pri(map, adr, sizeof(*extp), \"Amd/Fujitsu\");\n\t\tif (extp) {\n\t\t\t \n\t\t\tcfi_fixup_major_minor(cfi, extp);\n\n\t\t\t \n\t\t\tif (extp->MajorVersion != '1' ||\n\t\t\t    (extp->MajorVersion == '1' && (extp->MinorVersion < '0' || extp->MinorVersion > '5'))) {\n\t\t\t\tprintk(KERN_ERR \"  Unknown Amd/Fujitsu Extended Query \"\n\t\t\t\t       \"version %c.%c (%#02x/%#02x).\\n\",\n\t\t\t\t       extp->MajorVersion, extp->MinorVersion,\n\t\t\t\t       extp->MajorVersion, extp->MinorVersion);\n\t\t\t\tkfree(extp);\n\t\t\t\tkfree(mtd);\n\t\t\t\treturn NULL;\n\t\t\t}\n\n\t\t\tprintk(KERN_INFO \"  Amd/Fujitsu Extended Query version %c.%c.\\n\",\n\t\t\t       extp->MajorVersion, extp->MinorVersion);\n\n\t\t\t \n\t\t\tcfi->cmdset_priv = extp;\n\n\t\t\t \n\t\t\tcfi_fixup(mtd, cfi_fixup_table);\n\n#ifdef DEBUG_CFI_FEATURES\n\t\t\t \n\t\t\tcfi_tell_features(extp);\n#endif\n\n#ifdef CONFIG_OF\n\t\t\tif (np && of_property_read_bool(\n\t\t\t\t    np, \"use-advanced-sector-protection\")\n\t\t\t    && extp->BlkProtUnprot == 8) {\n\t\t\t\tprintk(KERN_INFO \"  Advanced Sector Protection (PPB Locking) supported\\n\");\n\t\t\t\tmtd->_lock = cfi_ppb_lock;\n\t\t\t\tmtd->_unlock = cfi_ppb_unlock;\n\t\t\t\tmtd->_is_locked = cfi_ppb_is_locked;\n\t\t\t}\n#endif\n\n\t\t\tbootloc = extp->TopBottom;\n\t\t\tif ((bootloc < 2) || (bootloc > 5)) {\n\t\t\t\tprintk(KERN_WARNING \"%s: CFI contains unrecognised boot \"\n\t\t\t\t       \"bank location (%d). Assuming bottom.\\n\",\n\t\t\t\t       map->name, bootloc);\n\t\t\t\tbootloc = 2;\n\t\t\t}\n\n\t\t\tif (bootloc == 3 && cfi->cfiq->NumEraseRegions > 1) {\n\t\t\t\tprintk(KERN_WARNING \"%s: Swapping erase regions for top-boot CFI table.\\n\", map->name);\n\n\t\t\t\tfor (i=0; i<cfi->cfiq->NumEraseRegions / 2; i++) {\n\t\t\t\t\tint j = (cfi->cfiq->NumEraseRegions-1)-i;\n\n\t\t\t\t\tswap(cfi->cfiq->EraseRegionInfo[i],\n\t\t\t\t\t     cfi->cfiq->EraseRegionInfo[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\t \n\t\t\tcfi->addr_unlock1 = 0x555;\n\t\t\tcfi->addr_unlock2 = 0x2aa;\n\t\t}\n\t\tcfi_fixup(mtd, cfi_nopri_fixup_table);\n\n\t\tif (!cfi->addr_unlock1 || !cfi->addr_unlock2) {\n\t\t\tkfree(mtd);\n\t\t\treturn NULL;\n\t\t}\n\n\t}  \n\telse if (cfi->cfi_mode == CFI_MODE_JEDEC) {\n\t\t \n\t\tcfi_fixup(mtd, jedec_fixup_table);\n\t}\n\t \n\tcfi_fixup(mtd, fixup_table);\n\n\tfor (i=0; i< cfi->numchips; i++) {\n\t\tcfi->chips[i].word_write_time = 1<<cfi->cfiq->WordWriteTimeoutTyp;\n\t\tcfi->chips[i].buffer_write_time = 1<<cfi->cfiq->BufWriteTimeoutTyp;\n\t\tcfi->chips[i].erase_time = 1<<cfi->cfiq->BlockEraseTimeoutTyp;\n\t\t \n\t\tif (cfi->cfiq->BufWriteTimeoutTyp &&\n\t\t    cfi->cfiq->BufWriteTimeoutMax)\n\t\t\tcfi->chips[i].buffer_write_time_max =\n\t\t\t\t1 << (cfi->cfiq->BufWriteTimeoutTyp +\n\t\t\t\t      cfi->cfiq->BufWriteTimeoutMax);\n\t\telse\n\t\t\tcfi->chips[i].buffer_write_time_max = 0;\n\n\t\tcfi->chips[i].buffer_write_time_max =\n\t\t\tmax(cfi->chips[i].buffer_write_time_max, 2000);\n\n\t\tcfi->chips[i].ref_point_counter = 0;\n\t\tinit_waitqueue_head(&(cfi->chips[i].wq));\n\t}\n\n\tmap->fldrv = &cfi_amdstd_chipdrv;\n\n\treturn cfi_amdstd_setup(mtd);\n}\nstruct mtd_info *cfi_cmdset_0006(struct map_info *map, int primary) __attribute__((alias(\"cfi_cmdset_0002\")));\nstruct mtd_info *cfi_cmdset_0701(struct map_info *map, int primary) __attribute__((alias(\"cfi_cmdset_0002\")));\nEXPORT_SYMBOL_GPL(cfi_cmdset_0002);\nEXPORT_SYMBOL_GPL(cfi_cmdset_0006);\nEXPORT_SYMBOL_GPL(cfi_cmdset_0701);\n\nstatic struct mtd_info *cfi_amdstd_setup(struct mtd_info *mtd)\n{\n\tstruct map_info *map = mtd->priv;\n\tstruct cfi_private *cfi = map->fldrv_priv;\n\tunsigned long devsize = (1<<cfi->cfiq->DevSize) * cfi->interleave;\n\tunsigned long offset = 0;\n\tint i,j;\n\n\tprintk(KERN_NOTICE \"number of %s chips: %d\\n\",\n\t       (cfi->cfi_mode == CFI_MODE_CFI)?\"CFI\":\"JEDEC\",cfi->numchips);\n\t \n\tmtd->size = devsize * cfi->numchips;\n\n\tmtd->numeraseregions = cfi->cfiq->NumEraseRegions * cfi->numchips;\n\tmtd->eraseregions = kmalloc_array(mtd->numeraseregions,\n\t\t\t\t\t  sizeof(struct mtd_erase_region_info),\n\t\t\t\t\t  GFP_KERNEL);\n\tif (!mtd->eraseregions)\n\t\tgoto setup_err;\n\n\tfor (i=0; i<cfi->cfiq->NumEraseRegions; i++) {\n\t\tunsigned long ernum, ersize;\n\t\tersize = ((cfi->cfiq->EraseRegionInfo[i] >> 8) & ~0xff) * cfi->interleave;\n\t\ternum = (cfi->cfiq->EraseRegionInfo[i] & 0xffff) + 1;\n\n\t\tif (mtd->erasesize < ersize) {\n\t\t\tmtd->erasesize = ersize;\n\t\t}\n\t\tfor (j=0; j<cfi->numchips; j++) {\n\t\t\tmtd->eraseregions[(j*cfi->cfiq->NumEraseRegions)+i].offset = (j*devsize)+offset;\n\t\t\tmtd->eraseregions[(j*cfi->cfiq->NumEraseRegions)+i].erasesize = ersize;\n\t\t\tmtd->eraseregions[(j*cfi->cfiq->NumEraseRegions)+i].numblocks = ernum;\n\t\t}\n\t\toffset += (ersize * ernum);\n\t}\n\tif (offset != devsize) {\n\t\t \n\t\tprintk(KERN_WARNING \"Sum of regions (%lx) != total size of set of interleaved chips (%lx)\\n\", offset, devsize);\n\t\tgoto setup_err;\n\t}\n\n\t__module_get(THIS_MODULE);\n\tregister_reboot_notifier(&mtd->reboot_notifier);\n\treturn mtd;\n\n setup_err:\n\tkfree(mtd->eraseregions);\n\tkfree(mtd);\n\tkfree(cfi->cmdset_priv);\n\treturn NULL;\n}\n\n \nstatic int __xipram chip_ready(struct map_info *map, struct flchip *chip,\n\t\t\t       unsigned long addr, map_word *expected)\n{\n\tstruct cfi_private *cfi = map->fldrv_priv;\n\tmap_word oldd, curd;\n\tint ret;\n\n\tif (cfi_use_status_reg(cfi)) {\n\t\tmap_word ready = CMD(CFI_SR_DRB);\n\t\t \n\t\tcfi_send_gen_cmd(0x70, cfi->addr_unlock1, chip->start, map, cfi,\n\t\t\t\t cfi->device_type, NULL);\n\t\tcurd = map_read(map, addr);\n\n\t\treturn map_word_andequal(map, curd, ready, ready);\n\t}\n\n\toldd = map_read(map, addr);\n\tcurd = map_read(map, addr);\n\n\tret = map_word_equal(map, oldd, curd);\n\n\tif (!ret || !expected)\n\t\treturn ret;\n\n\treturn map_word_equal(map, curd, *expected);\n}\n\nstatic int __xipram chip_good(struct map_info *map, struct flchip *chip,\n\t\t\t      unsigned long addr, map_word *expected)\n{\n\tstruct cfi_private *cfi = map->fldrv_priv;\n\tmap_word *datum = expected;\n\n\tif (cfi->quirks & CFI_QUIRK_DQ_TRUE_DATA)\n\t\tdatum = NULL;\n\n\treturn chip_ready(map, chip, addr, datum);\n}\n\nstatic int get_chip(struct map_info *map, struct flchip *chip, unsigned long adr, int mode)\n{\n\tDECLARE_WAITQUEUE(wait, current);\n\tstruct cfi_private *cfi = map->fldrv_priv;\n\tunsigned long timeo;\n\tstruct cfi_pri_amdstd *cfip = (struct cfi_pri_amdstd *)cfi->cmdset_priv;\n\n resettime:\n\ttimeo = jiffies + HZ;\n retry:\n\tswitch (chip->state) {\n\n\tcase FL_STATUS:\n\t\tfor (;;) {\n\t\t\tif (chip_ready(map, chip, adr, NULL))\n\t\t\t\tbreak;\n\n\t\t\tif (time_after(jiffies, timeo)) {\n\t\t\t\tprintk(KERN_ERR \"Waiting for chip to be ready timed out.\\n\");\n\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t\tmutex_unlock(&chip->mutex);\n\t\t\tcfi_udelay(1);\n\t\t\tmutex_lock(&chip->mutex);\n\t\t\t \n\t\t\tgoto retry;\n\t\t}\n\t\treturn 0;\n\n\tcase FL_READY:\n\tcase FL_CFI_QUERY:\n\tcase FL_JEDEC_QUERY:\n\t\treturn 0;\n\n\tcase FL_ERASING:\n\t\tif (!cfip || !(cfip->EraseSuspend & (0x1|0x2)) ||\n\t\t    !(mode == FL_READY || mode == FL_POINT ||\n\t\t    (mode == FL_WRITING && (cfip->EraseSuspend & 0x2))))\n\t\t\tgoto sleep;\n\n\t\t \n\t\tif ((adr & chip->in_progress_block_mask) ==\n\t\t    chip->in_progress_block_addr)\n\t\t\tgoto sleep;\n\n\t\t \n\t\t \n\t\tmap_write(map, CMD(0xB0), chip->in_progress_block_addr);\n\t\tchip->oldstate = FL_ERASING;\n\t\tchip->state = FL_ERASE_SUSPENDING;\n\t\tchip->erase_suspended = 1;\n\t\tfor (;;) {\n\t\t\tif (chip_ready(map, chip, adr, NULL))\n\t\t\t\tbreak;\n\n\t\t\tif (time_after(jiffies, timeo)) {\n\t\t\t\t \n\t\t\t\tput_chip(map, chip, adr);\n\t\t\t\tprintk(KERN_ERR \"MTD %s(): chip not ready after erase suspend\\n\", __func__);\n\t\t\t\treturn -EIO;\n\t\t\t}\n\n\t\t\tmutex_unlock(&chip->mutex);\n\t\t\tcfi_udelay(1);\n\t\t\tmutex_lock(&chip->mutex);\n\t\t\t \n\t\t}\n\t\tchip->state = FL_READY;\n\t\treturn 0;\n\n\tcase FL_XIP_WHILE_ERASING:\n\t\tif (mode != FL_READY && mode != FL_POINT &&\n\t\t    (!cfip || !(cfip->EraseSuspend&2)))\n\t\t\tgoto sleep;\n\t\tchip->oldstate = chip->state;\n\t\tchip->state = FL_READY;\n\t\treturn 0;\n\n\tcase FL_SHUTDOWN:\n\t\t \n\t\treturn -EIO;\n\n\tcase FL_POINT:\n\t\t \n\t\tif (mode == FL_READY && chip->oldstate == FL_READY)\n\t\t\treturn 0;\n\t\tfallthrough;\n\tdefault:\n\tsleep:\n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\tadd_wait_queue(&chip->wq, &wait);\n\t\tmutex_unlock(&chip->mutex);\n\t\tschedule();\n\t\tremove_wait_queue(&chip->wq, &wait);\n\t\tmutex_lock(&chip->mutex);\n\t\tgoto resettime;\n\t}\n}\n\n\nstatic void put_chip(struct map_info *map, struct flchip *chip, unsigned long adr)\n{\n\tstruct cfi_private *cfi = map->fldrv_priv;\n\n\tswitch(chip->oldstate) {\n\tcase FL_ERASING:\n\t\tcfi_fixup_m29ew_erase_suspend(map,\n\t\t\tchip->in_progress_block_addr);\n\t\tmap_write(map, cfi->sector_erase_cmd, chip->in_progress_block_addr);\n\t\tcfi_fixup_m29ew_delay_after_resume(cfi);\n\t\tchip->oldstate = FL_READY;\n\t\tchip->state = FL_ERASING;\n\t\tbreak;\n\n\tcase FL_XIP_WHILE_ERASING:\n\t\tchip->state = chip->oldstate;\n\t\tchip->oldstate = FL_READY;\n\t\tbreak;\n\n\tcase FL_READY:\n\tcase FL_STATUS:\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_ERR \"MTD: put_chip() called with oldstate %d!!\\n\", chip->oldstate);\n\t}\n\twake_up(&chip->wq);\n}\n\n#ifdef CONFIG_MTD_XIP\n\n \n\nstatic void xip_disable(struct map_info *map, struct flchip *chip,\n\t\t\tunsigned long adr)\n{\n\t \n\t(void) map_read(map, adr);  \n\tlocal_irq_disable();\n}\n\nstatic void __xipram xip_enable(struct map_info *map, struct flchip *chip,\n\t\t\t\tunsigned long adr)\n{\n\tstruct cfi_private *cfi = map->fldrv_priv;\n\n\tif (chip->state != FL_POINT && chip->state != FL_READY) {\n\t\tmap_write(map, CMD(0xf0), adr);\n\t\tchip->state = FL_READY;\n\t}\n\t(void) map_read(map, adr);\n\txip_iprefetch();\n\tlocal_irq_enable();\n}\n\n \n\nstatic void __xipram xip_udelay(struct map_info *map, struct flchip *chip,\n\t\t\t\tunsigned long adr, int usec)\n{\n\tstruct cfi_private *cfi = map->fldrv_priv;\n\tstruct cfi_pri_amdstd *extp = cfi->cmdset_priv;\n\tmap_word status, OK = CMD(0x80);\n\tunsigned long suspended, start = xip_currtime();\n\tflstate_t oldstate;\n\n\tdo {\n\t\tcpu_relax();\n\t\tif (xip_irqpending() && extp &&\n\t\t    ((chip->state == FL_ERASING && (extp->EraseSuspend & 2))) &&\n\t\t    (cfi_interleave_is_1(cfi) || chip->oldstate == FL_READY)) {\n\t\t\t \n\t\t\tmap_write(map, CMD(0xb0), adr);\n\t\t\tusec -= xip_elapsed_since(start);\n\t\t\tsuspended = xip_currtime();\n\t\t\tdo {\n\t\t\t\tif (xip_elapsed_since(suspended) > 100000) {\n\t\t\t\t\t \n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tstatus = map_read(map, adr);\n\t\t\t} while (!map_word_andequal(map, status, OK, OK));\n\n\t\t\t \n\t\t\toldstate = chip->state;\n\t\t\tif (!map_word_bitsset(map, status, CMD(0x40)))\n\t\t\t\tbreak;\n\t\t\tchip->state = FL_XIP_WHILE_ERASING;\n\t\t\tchip->erase_suspended = 1;\n\t\t\tmap_write(map, CMD(0xf0), adr);\n\t\t\t(void) map_read(map, adr);\n\t\t\txip_iprefetch();\n\t\t\tlocal_irq_enable();\n\t\t\tmutex_unlock(&chip->mutex);\n\t\t\txip_iprefetch();\n\t\t\tcond_resched();\n\n\t\t\t \n\t\t\tmutex_lock(&chip->mutex);\n\t\t\twhile (chip->state != FL_XIP_WHILE_ERASING) {\n\t\t\t\tDECLARE_WAITQUEUE(wait, current);\n\t\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\t\tadd_wait_queue(&chip->wq, &wait);\n\t\t\t\tmutex_unlock(&chip->mutex);\n\t\t\t\tschedule();\n\t\t\t\tremove_wait_queue(&chip->wq, &wait);\n\t\t\t\tmutex_lock(&chip->mutex);\n\t\t\t}\n\t\t\t \n\t\t\tlocal_irq_disable();\n\n\t\t\t \n\t\t\tcfi_fixup_m29ew_erase_suspend(map, adr);\n\t\t\t \n\t\t\tmap_write(map, cfi->sector_erase_cmd, adr);\n\t\t\tchip->state = oldstate;\n\t\t\tstart = xip_currtime();\n\t\t} else if (usec >= 1000000/HZ) {\n\t\t\t \n\t\t\txip_cpu_idle();\n\t\t}\n\t\tstatus = map_read(map, adr);\n\t} while (!map_word_andequal(map, status, OK, OK)\n\t\t && xip_elapsed_since(start) < usec);\n}\n\n#define UDELAY(map, chip, adr, usec)  xip_udelay(map, chip, adr, usec)\n\n \n#define XIP_INVAL_CACHED_RANGE(map, from, size)  \\\n\tINVALIDATE_CACHED_RANGE(map, from, size)\n\n#define INVALIDATE_CACHE_UDELAY(map, chip, adr, len, usec)  \\\n\tUDELAY(map, chip, adr, usec)\n\n \n\n#else\n\n#define xip_disable(map, chip, adr)\n#define xip_enable(map, chip, adr)\n#define XIP_INVAL_CACHED_RANGE(x...)\n\n#define UDELAY(map, chip, adr, usec)  \\\ndo {  \\\n\tmutex_unlock(&chip->mutex);  \\\n\tcfi_udelay(usec);  \\\n\tmutex_lock(&chip->mutex);  \\\n} while (0)\n\n#define INVALIDATE_CACHE_UDELAY(map, chip, adr, len, usec)  \\\ndo {  \\\n\tmutex_unlock(&chip->mutex);  \\\n\tINVALIDATE_CACHED_RANGE(map, adr, len);  \\\n\tcfi_udelay(usec);  \\\n\tmutex_lock(&chip->mutex);  \\\n} while (0)\n\n#endif\n\nstatic inline int do_read_onechip(struct map_info *map, struct flchip *chip, loff_t adr, size_t len, u_char *buf)\n{\n\tunsigned long cmd_addr;\n\tstruct cfi_private *cfi = map->fldrv_priv;\n\tint ret;\n\n\tadr += chip->start;\n\n\t \n\tcmd_addr = adr & ~(map_bankwidth(map)-1);\n\n\tmutex_lock(&chip->mutex);\n\tret = get_chip(map, chip, cmd_addr, FL_READY);\n\tif (ret) {\n\t\tmutex_unlock(&chip->mutex);\n\t\treturn ret;\n\t}\n\n\tif (chip->state != FL_POINT && chip->state != FL_READY) {\n\t\tmap_write(map, CMD(0xf0), cmd_addr);\n\t\tchip->state = FL_READY;\n\t}\n\n\tmap_copy_from(map, buf, adr, len);\n\n\tput_chip(map, chip, cmd_addr);\n\n\tmutex_unlock(&chip->mutex);\n\treturn 0;\n}\n\n\nstatic int cfi_amdstd_read (struct mtd_info *mtd, loff_t from, size_t len, size_t *retlen, u_char *buf)\n{\n\tstruct map_info *map = mtd->priv;\n\tstruct cfi_private *cfi = map->fldrv_priv;\n\tunsigned long ofs;\n\tint chipnum;\n\tint ret = 0;\n\n\t \n\tchipnum = (from >> cfi->chipshift);\n\tofs = from - (chipnum <<  cfi->chipshift);\n\n\twhile (len) {\n\t\tunsigned long thislen;\n\n\t\tif (chipnum >= cfi->numchips)\n\t\t\tbreak;\n\n\t\tif ((len + ofs -1) >> cfi->chipshift)\n\t\t\tthislen = (1<<cfi->chipshift) - ofs;\n\t\telse\n\t\t\tthislen = len;\n\n\t\tret = do_read_onechip(map, &cfi->chips[chipnum], ofs, thislen, buf);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\t*retlen += thislen;\n\t\tlen -= thislen;\n\t\tbuf += thislen;\n\n\t\tofs = 0;\n\t\tchipnum++;\n\t}\n\treturn ret;\n}\n\ntypedef int (*otp_op_t)(struct map_info *map, struct flchip *chip,\n\t\t\tloff_t adr, size_t len, u_char *buf, size_t grouplen);\n\nstatic inline void otp_enter(struct map_info *map, struct flchip *chip,\n\t\t\t     loff_t adr, size_t len)\n{\n\tstruct cfi_private *cfi = map->fldrv_priv;\n\n\tcfi_send_gen_cmd(0xAA, cfi->addr_unlock1, chip->start, map, cfi,\n\t\t\t cfi->device_type, NULL);\n\tcfi_send_gen_cmd(0x55, cfi->addr_unlock2, chip->start, map, cfi,\n\t\t\t cfi->device_type, NULL);\n\tcfi_send_gen_cmd(0x88, cfi->addr_unlock1, chip->start, map, cfi,\n\t\t\t cfi->device_type, NULL);\n\n\tINVALIDATE_CACHED_RANGE(map, chip->start + adr, len);\n}\n\nstatic inline void otp_exit(struct map_info *map, struct flchip *chip,\n\t\t\t    loff_t adr, size_t len)\n{\n\tstruct cfi_private *cfi = map->fldrv_priv;\n\n\tcfi_send_gen_cmd(0xAA, cfi->addr_unlock1, chip->start, map, cfi,\n\t\t\t cfi->device_type, NULL);\n\tcfi_send_gen_cmd(0x55, cfi->addr_unlock2, chip->start, map, cfi,\n\t\t\t cfi->device_type, NULL);\n\tcfi_send_gen_cmd(0x90, cfi->addr_unlock1, chip->start, map, cfi,\n\t\t\t cfi->device_type, NULL);\n\tcfi_send_gen_cmd(0x00, cfi->addr_unlock1, chip->start, map, cfi,\n\t\t\t cfi->device_type, NULL);\n\n\tINVALIDATE_CACHED_RANGE(map, chip->start + adr, len);\n}\n\nstatic inline int do_read_secsi_onechip(struct map_info *map,\n\t\t\t\t\tstruct flchip *chip, loff_t adr,\n\t\t\t\t\tsize_t len, u_char *buf,\n\t\t\t\t\tsize_t grouplen)\n{\n\tDECLARE_WAITQUEUE(wait, current);\n\n retry:\n\tmutex_lock(&chip->mutex);\n\n\tif (chip->state != FL_READY){\n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\tadd_wait_queue(&chip->wq, &wait);\n\n\t\tmutex_unlock(&chip->mutex);\n\n\t\tschedule();\n\t\tremove_wait_queue(&chip->wq, &wait);\n\n\t\tgoto retry;\n\t}\n\n\tadr += chip->start;\n\n\tchip->state = FL_READY;\n\n\totp_enter(map, chip, adr, len);\n\tmap_copy_from(map, buf, adr, len);\n\totp_exit(map, chip, adr, len);\n\n\twake_up(&chip->wq);\n\tmutex_unlock(&chip->mutex);\n\n\treturn 0;\n}\n\nstatic int cfi_amdstd_secsi_read (struct mtd_info *mtd, loff_t from, size_t len, size_t *retlen, u_char *buf)\n{\n\tstruct map_info *map = mtd->priv;\n\tstruct cfi_private *cfi = map->fldrv_priv;\n\tunsigned long ofs;\n\tint chipnum;\n\tint ret = 0;\n\n\t \n\t \n\tchipnum=from>>3;\n\tofs=from & 7;\n\n\twhile (len) {\n\t\tunsigned long thislen;\n\n\t\tif (chipnum >= cfi->numchips)\n\t\t\tbreak;\n\n\t\tif ((len + ofs -1) >> 3)\n\t\t\tthislen = (1<<3) - ofs;\n\t\telse\n\t\t\tthislen = len;\n\n\t\tret = do_read_secsi_onechip(map, &cfi->chips[chipnum], ofs,\n\t\t\t\t\t    thislen, buf, 0);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\t*retlen += thislen;\n\t\tlen -= thislen;\n\t\tbuf += thislen;\n\n\t\tofs = 0;\n\t\tchipnum++;\n\t}\n\treturn ret;\n}\n\nstatic int __xipram do_write_oneword(struct map_info *map, struct flchip *chip,\n\t\t\t\t     unsigned long adr, map_word datum,\n\t\t\t\t     int mode);\n\nstatic int do_otp_write(struct map_info *map, struct flchip *chip, loff_t adr,\n\t\t\tsize_t len, u_char *buf, size_t grouplen)\n{\n\tint ret;\n\twhile (len) {\n\t\tunsigned long bus_ofs = adr & ~(map_bankwidth(map)-1);\n\t\tint gap = adr - bus_ofs;\n\t\tint n = min_t(int, len, map_bankwidth(map) - gap);\n\t\tmap_word datum = map_word_ff(map);\n\n\t\tif (n != map_bankwidth(map)) {\n\t\t\t \n\t\t\totp_enter(map, chip, bus_ofs, map_bankwidth(map));\n\t\t\tdatum = map_read(map, bus_ofs);\n\t\t\totp_exit(map, chip, bus_ofs, map_bankwidth(map));\n\t\t}\n\n\t\tdatum = map_word_load_partial(map, datum, buf, gap, n);\n\t\tret = do_write_oneword(map, chip, bus_ofs, datum, FL_OTP_WRITE);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tadr += n;\n\t\tbuf += n;\n\t\tlen -= n;\n\t}\n\n\treturn 0;\n}\n\nstatic int do_otp_lock(struct map_info *map, struct flchip *chip, loff_t adr,\n\t\t       size_t len, u_char *buf, size_t grouplen)\n{\n\tstruct cfi_private *cfi = map->fldrv_priv;\n\tuint8_t lockreg;\n\tunsigned long timeo;\n\tint ret;\n\n\t \n\tif ((adr != 0) || (len != grouplen))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&chip->mutex);\n\tret = get_chip(map, chip, chip->start, FL_LOCKING);\n\tif (ret) {\n\t\tmutex_unlock(&chip->mutex);\n\t\treturn ret;\n\t}\n\tchip->state = FL_LOCKING;\n\n\t \n\tcfi_send_gen_cmd(0xAA, cfi->addr_unlock1, chip->start, map, cfi,\n\t\t\t cfi->device_type, NULL);\n\tcfi_send_gen_cmd(0x55, cfi->addr_unlock2, chip->start, map, cfi,\n\t\t\t cfi->device_type, NULL);\n\tcfi_send_gen_cmd(0x40, cfi->addr_unlock1, chip->start, map, cfi,\n\t\t\t cfi->device_type, NULL);\n\n\t \n\tlockreg = cfi_read_query(map, 0);\n\n\t \n\tlockreg &= ~0x01;\n\n\t \n\t \n\tmap_write(map, CMD(0xA0), chip->start);\n\tmap_write(map, CMD(lockreg), chip->start);\n\n\t \n\ttimeo = jiffies + msecs_to_jiffies(2);\n\tfor (;;) {\n\t\tif (chip_ready(map, chip, adr, NULL))\n\t\t\tbreak;\n\n\t\tif (time_after(jiffies, timeo)) {\n\t\t\tpr_err(\"Waiting for chip to be ready timed out.\\n\");\n\t\t\tret = -EIO;\n\t\t\tbreak;\n\t\t}\n\t\tUDELAY(map, chip, 0, 1);\n\t}\n\n\t \n\tmap_write(map, CMD(0x90), chip->start);\n\tmap_write(map, CMD(0x00), chip->start);\n\n\tchip->state = FL_READY;\n\tput_chip(map, chip, chip->start);\n\tmutex_unlock(&chip->mutex);\n\n\treturn ret;\n}\n\nstatic int cfi_amdstd_otp_walk(struct mtd_info *mtd, loff_t from, size_t len,\n\t\t\t       size_t *retlen, u_char *buf,\n\t\t\t       otp_op_t action, int user_regs)\n{\n\tstruct map_info *map = mtd->priv;\n\tstruct cfi_private *cfi = map->fldrv_priv;\n\tint ofs_factor = cfi->interleave * cfi->device_type;\n\tunsigned long base;\n\tint chipnum;\n\tstruct flchip *chip;\n\tuint8_t otp, lockreg;\n\tint ret;\n\n\tsize_t user_size, factory_size, otpsize;\n\tloff_t user_offset, factory_offset, otpoffset;\n\tint user_locked = 0, otplocked;\n\n\t*retlen = 0;\n\n\tfor (chipnum = 0; chipnum < cfi->numchips; chipnum++) {\n\t\tchip = &cfi->chips[chipnum];\n\t\tfactory_size = 0;\n\t\tuser_size = 0;\n\n\t\t \n\t\tif (is_m29ew(cfi)) {\n\t\t\tbase = chip->start;\n\n\t\t\t \n\t\t\tmutex_lock(&chip->mutex);\n\t\t\tret = get_chip(map, chip, base, FL_CFI_QUERY);\n\t\t\tif (ret) {\n\t\t\t\tmutex_unlock(&chip->mutex);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tcfi_qry_mode_on(base, map, cfi);\n\t\t\totp = cfi_read_query(map, base + 0x3 * ofs_factor);\n\t\t\tcfi_qry_mode_off(base, map, cfi);\n\t\t\tput_chip(map, chip, base);\n\t\t\tmutex_unlock(&chip->mutex);\n\n\t\t\tif (otp & 0x80) {\n\t\t\t\t \n\t\t\t\tfactory_offset = 0;\n\t\t\t\tfactory_size = 0x100;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tuser_offset = 0;\n\t\t\t\tuser_size = 0x100;\n\n\t\t\t\tmutex_lock(&chip->mutex);\n\t\t\t\tret = get_chip(map, chip, base, FL_LOCKING);\n\t\t\t\tif (ret) {\n\t\t\t\t\tmutex_unlock(&chip->mutex);\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\n\t\t\t\t \n\t\t\t\tcfi_send_gen_cmd(0xAA, cfi->addr_unlock1,\n\t\t\t\t\t\t chip->start, map, cfi,\n\t\t\t\t\t\t cfi->device_type, NULL);\n\t\t\t\tcfi_send_gen_cmd(0x55, cfi->addr_unlock2,\n\t\t\t\t\t\t chip->start, map, cfi,\n\t\t\t\t\t\t cfi->device_type, NULL);\n\t\t\t\tcfi_send_gen_cmd(0x40, cfi->addr_unlock1,\n\t\t\t\t\t\t chip->start, map, cfi,\n\t\t\t\t\t\t cfi->device_type, NULL);\n\t\t\t\t \n\t\t\t\tlockreg = cfi_read_query(map, 0);\n\t\t\t\t \n\t\t\t\tmap_write(map, CMD(0x90), chip->start);\n\t\t\t\tmap_write(map, CMD(0x00), chip->start);\n\t\t\t\tput_chip(map, chip, chip->start);\n\t\t\t\tmutex_unlock(&chip->mutex);\n\n\t\t\t\tuser_locked = ((lockreg & 0x01) == 0x00);\n\t\t\t}\n\t\t}\n\n\t\totpsize = user_regs ? user_size : factory_size;\n\t\tif (!otpsize)\n\t\t\tcontinue;\n\t\totpoffset = user_regs ? user_offset : factory_offset;\n\t\totplocked = user_regs ? user_locked : 1;\n\n\t\tif (!action) {\n\t\t\t \n\t\t\tstruct otp_info *otpinfo;\n\t\t\tlen -= sizeof(*otpinfo);\n\t\t\tif (len <= 0)\n\t\t\t\treturn -ENOSPC;\n\t\t\totpinfo = (struct otp_info *)buf;\n\t\t\totpinfo->start = from;\n\t\t\totpinfo->length = otpsize;\n\t\t\totpinfo->locked = otplocked;\n\t\t\tbuf += sizeof(*otpinfo);\n\t\t\t*retlen += sizeof(*otpinfo);\n\t\t\tfrom += otpsize;\n\t\t} else if ((from < otpsize) && (len > 0)) {\n\t\t\tsize_t size;\n\t\t\tsize = (len < otpsize - from) ? len : otpsize - from;\n\t\t\tret = action(map, chip, otpoffset + from, size, buf,\n\t\t\t\t     otpsize);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\n\t\t\tbuf += size;\n\t\t\tlen -= size;\n\t\t\t*retlen += size;\n\t\t\tfrom = 0;\n\t\t} else {\n\t\t\tfrom -= otpsize;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int cfi_amdstd_get_fact_prot_info(struct mtd_info *mtd, size_t len,\n\t\t\t\t\t size_t *retlen, struct otp_info *buf)\n{\n\treturn cfi_amdstd_otp_walk(mtd, 0, len, retlen, (u_char *)buf,\n\t\t\t\t   NULL, 0);\n}\n\nstatic int cfi_amdstd_get_user_prot_info(struct mtd_info *mtd, size_t len,\n\t\t\t\t\t size_t *retlen, struct otp_info *buf)\n{\n\treturn cfi_amdstd_otp_walk(mtd, 0, len, retlen, (u_char *)buf,\n\t\t\t\t   NULL, 1);\n}\n\nstatic int cfi_amdstd_read_fact_prot_reg(struct mtd_info *mtd, loff_t from,\n\t\t\t\t\t size_t len, size_t *retlen,\n\t\t\t\t\t u_char *buf)\n{\n\treturn cfi_amdstd_otp_walk(mtd, from, len, retlen,\n\t\t\t\t   buf, do_read_secsi_onechip, 0);\n}\n\nstatic int cfi_amdstd_read_user_prot_reg(struct mtd_info *mtd, loff_t from,\n\t\t\t\t\t size_t len, size_t *retlen,\n\t\t\t\t\t u_char *buf)\n{\n\treturn cfi_amdstd_otp_walk(mtd, from, len, retlen,\n\t\t\t\t   buf, do_read_secsi_onechip, 1);\n}\n\nstatic int cfi_amdstd_write_user_prot_reg(struct mtd_info *mtd, loff_t from,\n\t\t\t\t\t  size_t len, size_t *retlen,\n\t\t\t\t\t  const u_char *buf)\n{\n\treturn cfi_amdstd_otp_walk(mtd, from, len, retlen, (u_char *)buf,\n\t\t\t\t   do_otp_write, 1);\n}\n\nstatic int cfi_amdstd_lock_user_prot_reg(struct mtd_info *mtd, loff_t from,\n\t\t\t\t\t size_t len)\n{\n\tsize_t retlen;\n\treturn cfi_amdstd_otp_walk(mtd, from, len, &retlen, NULL,\n\t\t\t\t   do_otp_lock, 1);\n}\n\nstatic int __xipram do_write_oneword_once(struct map_info *map,\n\t\t\t\t\t  struct flchip *chip,\n\t\t\t\t\t  unsigned long adr, map_word datum,\n\t\t\t\t\t  int mode, struct cfi_private *cfi)\n{\n\tunsigned long timeo;\n\t \n\tunsigned long uWriteTimeout = (HZ / 1000) + 1;\n\tint ret = 0;\n\n\tcfi_send_gen_cmd(0xAA, cfi->addr_unlock1, chip->start, map, cfi, cfi->device_type, NULL);\n\tcfi_send_gen_cmd(0x55, cfi->addr_unlock2, chip->start, map, cfi, cfi->device_type, NULL);\n\tcfi_send_gen_cmd(0xA0, cfi->addr_unlock1, chip->start, map, cfi, cfi->device_type, NULL);\n\tmap_write(map, datum, adr);\n\tchip->state = mode;\n\n\tINVALIDATE_CACHE_UDELAY(map, chip,\n\t\t\t\tadr, map_bankwidth(map),\n\t\t\t\tchip->word_write_time);\n\n\t \n\ttimeo = jiffies + uWriteTimeout;\n\tfor (;;) {\n\t\tif (chip->state != mode) {\n\t\t\t \n\t\t\tDECLARE_WAITQUEUE(wait, current);\n\n\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\tadd_wait_queue(&chip->wq, &wait);\n\t\t\tmutex_unlock(&chip->mutex);\n\t\t\tschedule();\n\t\t\tremove_wait_queue(&chip->wq, &wait);\n\t\t\ttimeo = jiffies + (HZ / 2);  \n\t\t\tmutex_lock(&chip->mutex);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (time_after(jiffies, timeo) &&\n\t\t    !chip_good(map, chip, adr, &datum)) {\n\t\t\txip_enable(map, chip, adr);\n\t\t\tprintk(KERN_WARNING \"MTD %s(): software timeout\\n\", __func__);\n\t\t\txip_disable(map, chip, adr);\n\t\t\tret = -EIO;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (chip_good(map, chip, adr, &datum)) {\n\t\t\tif (cfi_check_err_status(map, chip, adr))\n\t\t\t\tret = -EIO;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tUDELAY(map, chip, adr, 1);\n\t}\n\n\treturn ret;\n}\n\nstatic int __xipram do_write_oneword_start(struct map_info *map,\n\t\t\t\t\t   struct flchip *chip,\n\t\t\t\t\t   unsigned long adr, int mode)\n{\n\tint ret;\n\n\tmutex_lock(&chip->mutex);\n\n\tret = get_chip(map, chip, adr, mode);\n\tif (ret) {\n\t\tmutex_unlock(&chip->mutex);\n\t\treturn ret;\n\t}\n\n\tif (mode == FL_OTP_WRITE)\n\t\totp_enter(map, chip, adr, map_bankwidth(map));\n\n\treturn ret;\n}\n\nstatic void __xipram do_write_oneword_done(struct map_info *map,\n\t\t\t\t\t   struct flchip *chip,\n\t\t\t\t\t   unsigned long adr, int mode)\n{\n\tif (mode == FL_OTP_WRITE)\n\t\totp_exit(map, chip, adr, map_bankwidth(map));\n\n\tchip->state = FL_READY;\n\tDISABLE_VPP(map);\n\tput_chip(map, chip, adr);\n\n\tmutex_unlock(&chip->mutex);\n}\n\nstatic int __xipram do_write_oneword_retry(struct map_info *map,\n\t\t\t\t\t   struct flchip *chip,\n\t\t\t\t\t   unsigned long adr, map_word datum,\n\t\t\t\t\t   int mode)\n{\n\tstruct cfi_private *cfi = map->fldrv_priv;\n\tint ret = 0;\n\tmap_word oldd;\n\tint retry_cnt = 0;\n\n\t \n\toldd = map_read(map, adr);\n\tif (map_word_equal(map, oldd, datum)) {\n\t\tpr_debug(\"MTD %s(): NOP\\n\", __func__);\n\t\treturn ret;\n\t}\n\n\tXIP_INVAL_CACHED_RANGE(map, adr, map_bankwidth(map));\n\tENABLE_VPP(map);\n\txip_disable(map, chip, adr);\n\n retry:\n\tret = do_write_oneword_once(map, chip, adr, datum, mode, cfi);\n\tif (ret) {\n\t\t \n\t\tmap_write(map, CMD(0xF0), chip->start);\n\t\t \n\n\t\tif (++retry_cnt <= MAX_RETRIES) {\n\t\t\tret = 0;\n\t\t\tgoto retry;\n\t\t}\n\t}\n\txip_enable(map, chip, adr);\n\n\treturn ret;\n}\n\nstatic int __xipram do_write_oneword(struct map_info *map, struct flchip *chip,\n\t\t\t\t     unsigned long adr, map_word datum,\n\t\t\t\t     int mode)\n{\n\tint ret;\n\n\tadr += chip->start;\n\n\tpr_debug(\"MTD %s(): WRITE 0x%.8lx(0x%.8lx)\\n\", __func__, adr,\n\t\t datum.x[0]);\n\n\tret = do_write_oneword_start(map, chip, adr, mode);\n\tif (ret)\n\t\treturn ret;\n\n\tret = do_write_oneword_retry(map, chip, adr, datum, mode);\n\n\tdo_write_oneword_done(map, chip, adr, mode);\n\n\treturn ret;\n}\n\n\nstatic int cfi_amdstd_write_words(struct mtd_info *mtd, loff_t to, size_t len,\n\t\t\t\t  size_t *retlen, const u_char *buf)\n{\n\tstruct map_info *map = mtd->priv;\n\tstruct cfi_private *cfi = map->fldrv_priv;\n\tint ret;\n\tint chipnum;\n\tunsigned long ofs, chipstart;\n\tDECLARE_WAITQUEUE(wait, current);\n\n\tchipnum = to >> cfi->chipshift;\n\tofs = to  - (chipnum << cfi->chipshift);\n\tchipstart = cfi->chips[chipnum].start;\n\n\t \n\tif (ofs & (map_bankwidth(map)-1)) {\n\t\tunsigned long bus_ofs = ofs & ~(map_bankwidth(map)-1);\n\t\tint i = ofs - bus_ofs;\n\t\tint n = 0;\n\t\tmap_word tmp_buf;\n\n retry:\n\t\tmutex_lock(&cfi->chips[chipnum].mutex);\n\n\t\tif (cfi->chips[chipnum].state != FL_READY) {\n\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\tadd_wait_queue(&cfi->chips[chipnum].wq, &wait);\n\n\t\t\tmutex_unlock(&cfi->chips[chipnum].mutex);\n\n\t\t\tschedule();\n\t\t\tremove_wait_queue(&cfi->chips[chipnum].wq, &wait);\n\t\t\tgoto retry;\n\t\t}\n\n\t\t \n\t\ttmp_buf = map_read(map, bus_ofs+chipstart);\n\n\t\tmutex_unlock(&cfi->chips[chipnum].mutex);\n\n\t\t \n\t\tn = min_t(int, len, map_bankwidth(map)-i);\n\n\t\ttmp_buf = map_word_load_partial(map, tmp_buf, buf, i, n);\n\n\t\tret = do_write_oneword(map, &cfi->chips[chipnum],\n\t\t\t\t       bus_ofs, tmp_buf, FL_WRITING);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tofs += n;\n\t\tbuf += n;\n\t\t(*retlen) += n;\n\t\tlen -= n;\n\n\t\tif (ofs >> cfi->chipshift) {\n\t\t\tchipnum ++;\n\t\t\tofs = 0;\n\t\t\tif (chipnum == cfi->numchips)\n\t\t\t\treturn 0;\n\t\t}\n\t}\n\n\t \n\twhile(len >= map_bankwidth(map)) {\n\t\tmap_word datum;\n\n\t\tdatum = map_word_load(map, buf);\n\n\t\tret = do_write_oneword(map, &cfi->chips[chipnum],\n\t\t\t\t       ofs, datum, FL_WRITING);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tofs += map_bankwidth(map);\n\t\tbuf += map_bankwidth(map);\n\t\t(*retlen) += map_bankwidth(map);\n\t\tlen -= map_bankwidth(map);\n\n\t\tif (ofs >> cfi->chipshift) {\n\t\t\tchipnum ++;\n\t\t\tofs = 0;\n\t\t\tif (chipnum == cfi->numchips)\n\t\t\t\treturn 0;\n\t\t\tchipstart = cfi->chips[chipnum].start;\n\t\t}\n\t}\n\n\t \n\tif (len & (map_bankwidth(map)-1)) {\n\t\tmap_word tmp_buf;\n\n retry1:\n\t\tmutex_lock(&cfi->chips[chipnum].mutex);\n\n\t\tif (cfi->chips[chipnum].state != FL_READY) {\n\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\tadd_wait_queue(&cfi->chips[chipnum].wq, &wait);\n\n\t\t\tmutex_unlock(&cfi->chips[chipnum].mutex);\n\n\t\t\tschedule();\n\t\t\tremove_wait_queue(&cfi->chips[chipnum].wq, &wait);\n\t\t\tgoto retry1;\n\t\t}\n\n\t\ttmp_buf = map_read(map, ofs + chipstart);\n\n\t\tmutex_unlock(&cfi->chips[chipnum].mutex);\n\n\t\ttmp_buf = map_word_load_partial(map, tmp_buf, buf, 0, len);\n\n\t\tret = do_write_oneword(map, &cfi->chips[chipnum],\n\t\t\t\t       ofs, tmp_buf, FL_WRITING);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t(*retlen) += len;\n\t}\n\n\treturn 0;\n}\n\n#if !FORCE_WORD_WRITE\nstatic int __xipram do_write_buffer_wait(struct map_info *map,\n\t\t\t\t\t struct flchip *chip, unsigned long adr,\n\t\t\t\t\t map_word datum)\n{\n\tunsigned long timeo;\n\tunsigned long u_write_timeout;\n\tint ret = 0;\n\n\t \n\tu_write_timeout = usecs_to_jiffies(chip->buffer_write_time_max);\n\ttimeo = jiffies + u_write_timeout;\n\n\tfor (;;) {\n\t\tif (chip->state != FL_WRITING) {\n\t\t\t \n\t\t\tDECLARE_WAITQUEUE(wait, current);\n\n\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\tadd_wait_queue(&chip->wq, &wait);\n\t\t\tmutex_unlock(&chip->mutex);\n\t\t\tschedule();\n\t\t\tremove_wait_queue(&chip->wq, &wait);\n\t\t\ttimeo = jiffies + (HZ / 2);  \n\t\t\tmutex_lock(&chip->mutex);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (time_after(jiffies, timeo) &&\n\t\t    !chip_good(map, chip, adr, &datum)) {\n\t\t\tpr_err(\"MTD %s(): software timeout, address:0x%.8lx.\\n\",\n\t\t\t       __func__, adr);\n\t\t\tret = -EIO;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (chip_good(map, chip, adr, &datum)) {\n\t\t\tif (cfi_check_err_status(map, chip, adr))\n\t\t\t\tret = -EIO;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tUDELAY(map, chip, adr, 1);\n\t}\n\n\treturn ret;\n}\n\nstatic void __xipram do_write_buffer_reset(struct map_info *map,\n\t\t\t\t\t   struct flchip *chip,\n\t\t\t\t\t   struct cfi_private *cfi)\n{\n\t \n\tcfi_send_gen_cmd(0xAA, cfi->addr_unlock1, chip->start, map, cfi,\n\t\t\t cfi->device_type, NULL);\n\tcfi_send_gen_cmd(0x55, cfi->addr_unlock2, chip->start, map, cfi,\n\t\t\t cfi->device_type, NULL);\n\tcfi_send_gen_cmd(0xF0, cfi->addr_unlock1, chip->start, map, cfi,\n\t\t\t cfi->device_type, NULL);\n\n\t \n}\n\n \nstatic int __xipram do_write_buffer(struct map_info *map, struct flchip *chip,\n\t\t\t\t    unsigned long adr, const u_char *buf,\n\t\t\t\t    int len)\n{\n\tstruct cfi_private *cfi = map->fldrv_priv;\n\tint ret;\n\tunsigned long cmd_adr;\n\tint z, words;\n\tmap_word datum;\n\n\tadr += chip->start;\n\tcmd_adr = adr;\n\n\tmutex_lock(&chip->mutex);\n\tret = get_chip(map, chip, adr, FL_WRITING);\n\tif (ret) {\n\t\tmutex_unlock(&chip->mutex);\n\t\treturn ret;\n\t}\n\n\tdatum = map_word_load(map, buf);\n\n\tpr_debug(\"MTD %s(): WRITE 0x%.8lx(0x%.8lx)\\n\",\n\t\t __func__, adr, datum.x[0]);\n\n\tXIP_INVAL_CACHED_RANGE(map, adr, len);\n\tENABLE_VPP(map);\n\txip_disable(map, chip, cmd_adr);\n\n\tcfi_send_gen_cmd(0xAA, cfi->addr_unlock1, chip->start, map, cfi, cfi->device_type, NULL);\n\tcfi_send_gen_cmd(0x55, cfi->addr_unlock2, chip->start, map, cfi, cfi->device_type, NULL);\n\n\t \n\tmap_write(map, CMD(0x25), cmd_adr);\n\n\tchip->state = FL_WRITING_TO_BUFFER;\n\n\t \n\twords = len / map_bankwidth(map);\n\tmap_write(map, CMD(words - 1), cmd_adr);\n\t \n\tz = 0;\n\twhile(z < words * map_bankwidth(map)) {\n\t\tdatum = map_word_load(map, buf);\n\t\tmap_write(map, datum, adr + z);\n\n\t\tz += map_bankwidth(map);\n\t\tbuf += map_bankwidth(map);\n\t}\n\tz -= map_bankwidth(map);\n\n\tadr += z;\n\n\t \n\tmap_write(map, CMD(0x29), cmd_adr);\n\tchip->state = FL_WRITING;\n\n\tINVALIDATE_CACHE_UDELAY(map, chip,\n\t\t\t\tadr, map_bankwidth(map),\n\t\t\t\tchip->word_write_time);\n\n\tret = do_write_buffer_wait(map, chip, adr, datum);\n\tif (ret)\n\t\tdo_write_buffer_reset(map, chip, cfi);\n\n\txip_enable(map, chip, adr);\n\n\tchip->state = FL_READY;\n\tDISABLE_VPP(map);\n\tput_chip(map, chip, adr);\n\tmutex_unlock(&chip->mutex);\n\n\treturn ret;\n}\n\n\nstatic int cfi_amdstd_write_buffers(struct mtd_info *mtd, loff_t to, size_t len,\n\t\t\t\t    size_t *retlen, const u_char *buf)\n{\n\tstruct map_info *map = mtd->priv;\n\tstruct cfi_private *cfi = map->fldrv_priv;\n\tint wbufsize = cfi_interleave(cfi) << cfi->cfiq->MaxBufWriteSize;\n\tint ret;\n\tint chipnum;\n\tunsigned long ofs;\n\n\tchipnum = to >> cfi->chipshift;\n\tofs = to  - (chipnum << cfi->chipshift);\n\n\t \n\tif (ofs & (map_bankwidth(map)-1)) {\n\t\tsize_t local_len = (-ofs)&(map_bankwidth(map)-1);\n\t\tif (local_len > len)\n\t\t\tlocal_len = len;\n\t\tret = cfi_amdstd_write_words(mtd, ofs + (chipnum<<cfi->chipshift),\n\t\t\t\t\t     local_len, retlen, buf);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tofs += local_len;\n\t\tbuf += local_len;\n\t\tlen -= local_len;\n\n\t\tif (ofs >> cfi->chipshift) {\n\t\t\tchipnum ++;\n\t\t\tofs = 0;\n\t\t\tif (chipnum == cfi->numchips)\n\t\t\t\treturn 0;\n\t\t}\n\t}\n\n\t \n\twhile (len >= map_bankwidth(map) * 2) {\n\t\t \n\t\tint size = wbufsize - (ofs & (wbufsize-1));\n\n\t\tif (size > len)\n\t\t\tsize = len;\n\t\tif (size % map_bankwidth(map))\n\t\t\tsize -= size % map_bankwidth(map);\n\n\t\tret = do_write_buffer(map, &cfi->chips[chipnum],\n\t\t\t\t      ofs, buf, size);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tofs += size;\n\t\tbuf += size;\n\t\t(*retlen) += size;\n\t\tlen -= size;\n\n\t\tif (ofs >> cfi->chipshift) {\n\t\t\tchipnum ++;\n\t\t\tofs = 0;\n\t\t\tif (chipnum == cfi->numchips)\n\t\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (len) {\n\t\tsize_t retlen_dregs = 0;\n\n\t\tret = cfi_amdstd_write_words(mtd, ofs + (chipnum<<cfi->chipshift),\n\t\t\t\t\t     len, &retlen_dregs, buf);\n\n\t\t*retlen += retlen_dregs;\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n#endif  \n\n \nstatic int cfi_amdstd_panic_wait(struct map_info *map, struct flchip *chip,\n\t\t\t\t unsigned long adr)\n{\n\tstruct cfi_private *cfi = map->fldrv_priv;\n\tint retries = 10;\n\tint i;\n\n\t \n\tif (chip->state == FL_READY && chip_ready(map, chip, adr, NULL))\n\t\treturn 0;\n\n\t \n\twhile (retries > 0) {\n\t\tconst unsigned long timeo = (HZ / 1000) + 1;\n\n\t\t \n\t\tmap_write(map, CMD(0xF0), chip->start);\n\n\t\t \n\t\tfor (i = 0; i < jiffies_to_usecs(timeo); i++) {\n\t\t\tif (chip_ready(map, chip, adr, NULL))\n\t\t\t\treturn 0;\n\n\t\t\tudelay(1);\n\t\t}\n\n\t\tretries--;\n\t}\n\n\t \n\treturn -EBUSY;\n}\n\n \nstatic int do_panic_write_oneword(struct map_info *map, struct flchip *chip,\n\t\t\t\t  unsigned long adr, map_word datum)\n{\n\tconst unsigned long uWriteTimeout = (HZ / 1000) + 1;\n\tstruct cfi_private *cfi = map->fldrv_priv;\n\tint retry_cnt = 0;\n\tmap_word oldd;\n\tint ret;\n\tint i;\n\n\tadr += chip->start;\n\n\tret = cfi_amdstd_panic_wait(map, chip, adr);\n\tif (ret)\n\t\treturn ret;\n\n\tpr_debug(\"MTD %s(): PANIC WRITE 0x%.8lx(0x%.8lx)\\n\",\n\t\t\t__func__, adr, datum.x[0]);\n\n\t \n\toldd = map_read(map, adr);\n\tif (map_word_equal(map, oldd, datum)) {\n\t\tpr_debug(\"MTD %s(): NOP\\n\", __func__);\n\t\tgoto op_done;\n\t}\n\n\tENABLE_VPP(map);\n\nretry:\n\tcfi_send_gen_cmd(0xAA, cfi->addr_unlock1, chip->start, map, cfi, cfi->device_type, NULL);\n\tcfi_send_gen_cmd(0x55, cfi->addr_unlock2, chip->start, map, cfi, cfi->device_type, NULL);\n\tcfi_send_gen_cmd(0xA0, cfi->addr_unlock1, chip->start, map, cfi, cfi->device_type, NULL);\n\tmap_write(map, datum, adr);\n\n\tfor (i = 0; i < jiffies_to_usecs(uWriteTimeout); i++) {\n\t\tif (chip_ready(map, chip, adr, NULL))\n\t\t\tbreak;\n\n\t\tudelay(1);\n\t}\n\n\tif (!chip_ready(map, chip, adr, &datum) ||\n\t    cfi_check_err_status(map, chip, adr)) {\n\t\t \n\t\tmap_write(map, CMD(0xF0), chip->start);\n\t\t \n\n\t\tif (++retry_cnt <= MAX_RETRIES)\n\t\t\tgoto retry;\n\n\t\tret = -EIO;\n\t}\n\nop_done:\n\tDISABLE_VPP(map);\n\treturn ret;\n}\n\n \nstatic int cfi_amdstd_panic_write(struct mtd_info *mtd, loff_t to, size_t len,\n\t\t\t\t  size_t *retlen, const u_char *buf)\n{\n\tstruct map_info *map = mtd->priv;\n\tstruct cfi_private *cfi = map->fldrv_priv;\n\tunsigned long ofs, chipstart;\n\tint ret;\n\tint chipnum;\n\n\tchipnum = to >> cfi->chipshift;\n\tofs = to - (chipnum << cfi->chipshift);\n\tchipstart = cfi->chips[chipnum].start;\n\n\t \n\tif (ofs & (map_bankwidth(map) - 1)) {\n\t\tunsigned long bus_ofs = ofs & ~(map_bankwidth(map) - 1);\n\t\tint i = ofs - bus_ofs;\n\t\tint n = 0;\n\t\tmap_word tmp_buf;\n\n\t\tret = cfi_amdstd_panic_wait(map, &cfi->chips[chipnum], bus_ofs);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t \n\t\ttmp_buf = map_read(map, bus_ofs + chipstart);\n\n\t\t \n\t\tn = min_t(int, len, map_bankwidth(map) - i);\n\n\t\ttmp_buf = map_word_load_partial(map, tmp_buf, buf, i, n);\n\n\t\tret = do_panic_write_oneword(map, &cfi->chips[chipnum],\n\t\t\t\t\t     bus_ofs, tmp_buf);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tofs += n;\n\t\tbuf += n;\n\t\t(*retlen) += n;\n\t\tlen -= n;\n\n\t\tif (ofs >> cfi->chipshift) {\n\t\t\tchipnum++;\n\t\t\tofs = 0;\n\t\t\tif (chipnum == cfi->numchips)\n\t\t\t\treturn 0;\n\t\t}\n\t}\n\n\t \n\twhile (len >= map_bankwidth(map)) {\n\t\tmap_word datum;\n\n\t\tdatum = map_word_load(map, buf);\n\n\t\tret = do_panic_write_oneword(map, &cfi->chips[chipnum],\n\t\t\t\t\t     ofs, datum);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tofs += map_bankwidth(map);\n\t\tbuf += map_bankwidth(map);\n\t\t(*retlen) += map_bankwidth(map);\n\t\tlen -= map_bankwidth(map);\n\n\t\tif (ofs >> cfi->chipshift) {\n\t\t\tchipnum++;\n\t\t\tofs = 0;\n\t\t\tif (chipnum == cfi->numchips)\n\t\t\t\treturn 0;\n\n\t\t\tchipstart = cfi->chips[chipnum].start;\n\t\t}\n\t}\n\n\t \n\tif (len & (map_bankwidth(map) - 1)) {\n\t\tmap_word tmp_buf;\n\n\t\tret = cfi_amdstd_panic_wait(map, &cfi->chips[chipnum], ofs);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\ttmp_buf = map_read(map, ofs + chipstart);\n\n\t\ttmp_buf = map_word_load_partial(map, tmp_buf, buf, 0, len);\n\n\t\tret = do_panic_write_oneword(map, &cfi->chips[chipnum],\n\t\t\t\t\t     ofs, tmp_buf);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t(*retlen) += len;\n\t}\n\n\treturn 0;\n}\n\n\n \nstatic int __xipram do_erase_chip(struct map_info *map, struct flchip *chip)\n{\n\tstruct cfi_private *cfi = map->fldrv_priv;\n\tunsigned long timeo = jiffies + HZ;\n\tunsigned long int adr;\n\tDECLARE_WAITQUEUE(wait, current);\n\tint ret;\n\tint retry_cnt = 0;\n\tmap_word datum = map_word_ff(map);\n\n\tadr = cfi->addr_unlock1;\n\n\tmutex_lock(&chip->mutex);\n\tret = get_chip(map, chip, adr, FL_ERASING);\n\tif (ret) {\n\t\tmutex_unlock(&chip->mutex);\n\t\treturn ret;\n\t}\n\n\tpr_debug(\"MTD %s(): ERASE 0x%.8lx\\n\",\n\t       __func__, chip->start);\n\n\tXIP_INVAL_CACHED_RANGE(map, adr, map->size);\n\tENABLE_VPP(map);\n\txip_disable(map, chip, adr);\n\n retry:\n\tcfi_send_gen_cmd(0xAA, cfi->addr_unlock1, chip->start, map, cfi, cfi->device_type, NULL);\n\tcfi_send_gen_cmd(0x55, cfi->addr_unlock2, chip->start, map, cfi, cfi->device_type, NULL);\n\tcfi_send_gen_cmd(0x80, cfi->addr_unlock1, chip->start, map, cfi, cfi->device_type, NULL);\n\tcfi_send_gen_cmd(0xAA, cfi->addr_unlock1, chip->start, map, cfi, cfi->device_type, NULL);\n\tcfi_send_gen_cmd(0x55, cfi->addr_unlock2, chip->start, map, cfi, cfi->device_type, NULL);\n\tcfi_send_gen_cmd(0x10, cfi->addr_unlock1, chip->start, map, cfi, cfi->device_type, NULL);\n\n\tchip->state = FL_ERASING;\n\tchip->erase_suspended = 0;\n\tchip->in_progress_block_addr = adr;\n\tchip->in_progress_block_mask = ~(map->size - 1);\n\n\tINVALIDATE_CACHE_UDELAY(map, chip,\n\t\t\t\tadr, map->size,\n\t\t\t\tchip->erase_time*500);\n\n\ttimeo = jiffies + (HZ*20);\n\n\tfor (;;) {\n\t\tif (chip->state != FL_ERASING) {\n\t\t\t \n\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\tadd_wait_queue(&chip->wq, &wait);\n\t\t\tmutex_unlock(&chip->mutex);\n\t\t\tschedule();\n\t\t\tremove_wait_queue(&chip->wq, &wait);\n\t\t\tmutex_lock(&chip->mutex);\n\t\t\tcontinue;\n\t\t}\n\t\tif (chip->erase_suspended) {\n\t\t\t \n\t\t\ttimeo = jiffies + (HZ*20);  \n\t\t\tchip->erase_suspended = 0;\n\t\t}\n\n\t\tif (chip_ready(map, chip, adr, &datum)) {\n\t\t\tif (cfi_check_err_status(map, chip, adr))\n\t\t\t\tret = -EIO;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (time_after(jiffies, timeo)) {\n\t\t\tprintk(KERN_WARNING \"MTD %s(): software timeout\\n\",\n\t\t\t       __func__);\n\t\t\tret = -EIO;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tUDELAY(map, chip, adr, 1000000/HZ);\n\t}\n\t \n\tif (ret) {\n\t\t \n\t\tmap_write(map, CMD(0xF0), chip->start);\n\t\t \n\n\t\tif (++retry_cnt <= MAX_RETRIES) {\n\t\t\tret = 0;\n\t\t\tgoto retry;\n\t\t}\n\t}\n\n\tchip->state = FL_READY;\n\txip_enable(map, chip, adr);\n\tDISABLE_VPP(map);\n\tput_chip(map, chip, adr);\n\tmutex_unlock(&chip->mutex);\n\n\treturn ret;\n}\n\n\nstatic int __xipram do_erase_oneblock(struct map_info *map, struct flchip *chip, unsigned long adr, int len, void *thunk)\n{\n\tstruct cfi_private *cfi = map->fldrv_priv;\n\tunsigned long timeo = jiffies + HZ;\n\tDECLARE_WAITQUEUE(wait, current);\n\tint ret;\n\tint retry_cnt = 0;\n\tmap_word datum = map_word_ff(map);\n\n\tadr += chip->start;\n\n\tmutex_lock(&chip->mutex);\n\tret = get_chip(map, chip, adr, FL_ERASING);\n\tif (ret) {\n\t\tmutex_unlock(&chip->mutex);\n\t\treturn ret;\n\t}\n\n\tpr_debug(\"MTD %s(): ERASE 0x%.8lx\\n\",\n\t\t __func__, adr);\n\n\tXIP_INVAL_CACHED_RANGE(map, adr, len);\n\tENABLE_VPP(map);\n\txip_disable(map, chip, adr);\n\n retry:\n\tcfi_send_gen_cmd(0xAA, cfi->addr_unlock1, chip->start, map, cfi, cfi->device_type, NULL);\n\tcfi_send_gen_cmd(0x55, cfi->addr_unlock2, chip->start, map, cfi, cfi->device_type, NULL);\n\tcfi_send_gen_cmd(0x80, cfi->addr_unlock1, chip->start, map, cfi, cfi->device_type, NULL);\n\tcfi_send_gen_cmd(0xAA, cfi->addr_unlock1, chip->start, map, cfi, cfi->device_type, NULL);\n\tcfi_send_gen_cmd(0x55, cfi->addr_unlock2, chip->start, map, cfi, cfi->device_type, NULL);\n\tmap_write(map, cfi->sector_erase_cmd, adr);\n\n\tchip->state = FL_ERASING;\n\tchip->erase_suspended = 0;\n\tchip->in_progress_block_addr = adr;\n\tchip->in_progress_block_mask = ~(len - 1);\n\n\tINVALIDATE_CACHE_UDELAY(map, chip,\n\t\t\t\tadr, len,\n\t\t\t\tchip->erase_time*500);\n\n\ttimeo = jiffies + (HZ*20);\n\n\tfor (;;) {\n\t\tif (chip->state != FL_ERASING) {\n\t\t\t \n\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\tadd_wait_queue(&chip->wq, &wait);\n\t\t\tmutex_unlock(&chip->mutex);\n\t\t\tschedule();\n\t\t\tremove_wait_queue(&chip->wq, &wait);\n\t\t\tmutex_lock(&chip->mutex);\n\t\t\tcontinue;\n\t\t}\n\t\tif (chip->erase_suspended) {\n\t\t\t \n\t\t\ttimeo = jiffies + (HZ*20);  \n\t\t\tchip->erase_suspended = 0;\n\t\t}\n\n\t\tif (chip_ready(map, chip, adr, &datum)) {\n\t\t\tif (cfi_check_err_status(map, chip, adr))\n\t\t\t\tret = -EIO;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (time_after(jiffies, timeo)) {\n\t\t\tprintk(KERN_WARNING \"MTD %s(): software timeout\\n\",\n\t\t\t       __func__);\n\t\t\tret = -EIO;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tUDELAY(map, chip, adr, 1000000/HZ);\n\t}\n\t \n\tif (ret) {\n\t\t \n\t\tmap_write(map, CMD(0xF0), chip->start);\n\t\t \n\n\t\tif (++retry_cnt <= MAX_RETRIES) {\n\t\t\tret = 0;\n\t\t\tgoto retry;\n\t\t}\n\t}\n\n\tchip->state = FL_READY;\n\txip_enable(map, chip, adr);\n\tDISABLE_VPP(map);\n\tput_chip(map, chip, adr);\n\tmutex_unlock(&chip->mutex);\n\treturn ret;\n}\n\n\nstatic int cfi_amdstd_erase_varsize(struct mtd_info *mtd, struct erase_info *instr)\n{\n\treturn cfi_varsize_frob(mtd, do_erase_oneblock, instr->addr,\n\t\t\t\tinstr->len, NULL);\n}\n\n\nstatic int cfi_amdstd_erase_chip(struct mtd_info *mtd, struct erase_info *instr)\n{\n\tstruct map_info *map = mtd->priv;\n\tstruct cfi_private *cfi = map->fldrv_priv;\n\n\tif (instr->addr != 0)\n\t\treturn -EINVAL;\n\n\tif (instr->len != mtd->size)\n\t\treturn -EINVAL;\n\n\treturn do_erase_chip(map, &cfi->chips[0]);\n}\n\nstatic int do_atmel_lock(struct map_info *map, struct flchip *chip,\n\t\t\t unsigned long adr, int len, void *thunk)\n{\n\tstruct cfi_private *cfi = map->fldrv_priv;\n\tint ret;\n\n\tmutex_lock(&chip->mutex);\n\tret = get_chip(map, chip, adr + chip->start, FL_LOCKING);\n\tif (ret)\n\t\tgoto out_unlock;\n\tchip->state = FL_LOCKING;\n\n\tpr_debug(\"MTD %s(): LOCK 0x%08lx len %d\\n\", __func__, adr, len);\n\n\tcfi_send_gen_cmd(0xAA, cfi->addr_unlock1, chip->start, map, cfi,\n\t\t\t cfi->device_type, NULL);\n\tcfi_send_gen_cmd(0x55, cfi->addr_unlock2, chip->start, map, cfi,\n\t\t\t cfi->device_type, NULL);\n\tcfi_send_gen_cmd(0x80, cfi->addr_unlock1, chip->start, map, cfi,\n\t\t\t cfi->device_type, NULL);\n\tcfi_send_gen_cmd(0xAA, cfi->addr_unlock1, chip->start, map, cfi,\n\t\t\t cfi->device_type, NULL);\n\tcfi_send_gen_cmd(0x55, cfi->addr_unlock2, chip->start, map, cfi,\n\t\t\t cfi->device_type, NULL);\n\tmap_write(map, CMD(0x40), chip->start + adr);\n\n\tchip->state = FL_READY;\n\tput_chip(map, chip, adr + chip->start);\n\tret = 0;\n\nout_unlock:\n\tmutex_unlock(&chip->mutex);\n\treturn ret;\n}\n\nstatic int do_atmel_unlock(struct map_info *map, struct flchip *chip,\n\t\t\t   unsigned long adr, int len, void *thunk)\n{\n\tstruct cfi_private *cfi = map->fldrv_priv;\n\tint ret;\n\n\tmutex_lock(&chip->mutex);\n\tret = get_chip(map, chip, adr + chip->start, FL_UNLOCKING);\n\tif (ret)\n\t\tgoto out_unlock;\n\tchip->state = FL_UNLOCKING;\n\n\tpr_debug(\"MTD %s(): LOCK 0x%08lx len %d\\n\", __func__, adr, len);\n\n\tcfi_send_gen_cmd(0xAA, cfi->addr_unlock1, chip->start, map, cfi,\n\t\t\t cfi->device_type, NULL);\n\tmap_write(map, CMD(0x70), adr);\n\n\tchip->state = FL_READY;\n\tput_chip(map, chip, adr + chip->start);\n\tret = 0;\n\nout_unlock:\n\tmutex_unlock(&chip->mutex);\n\treturn ret;\n}\n\nstatic int cfi_atmel_lock(struct mtd_info *mtd, loff_t ofs, uint64_t len)\n{\n\treturn cfi_varsize_frob(mtd, do_atmel_lock, ofs, len, NULL);\n}\n\nstatic int cfi_atmel_unlock(struct mtd_info *mtd, loff_t ofs, uint64_t len)\n{\n\treturn cfi_varsize_frob(mtd, do_atmel_unlock, ofs, len, NULL);\n}\n\n \n\nstruct ppb_lock {\n\tstruct flchip *chip;\n\tunsigned long adr;\n\tint locked;\n};\n\n#define DO_XXLOCK_ONEBLOCK_LOCK\t\t((void *)1)\n#define DO_XXLOCK_ONEBLOCK_UNLOCK\t((void *)2)\n#define DO_XXLOCK_ONEBLOCK_GETLOCK\t((void *)3)\n\nstatic int __maybe_unused do_ppb_xxlock(struct map_info *map,\n\t\t\t\t\tstruct flchip *chip,\n\t\t\t\t\tunsigned long adr, int len, void *thunk)\n{\n\tstruct cfi_private *cfi = map->fldrv_priv;\n\tunsigned long timeo;\n\tint ret;\n\n\tadr += chip->start;\n\tmutex_lock(&chip->mutex);\n\tret = get_chip(map, chip, adr, FL_LOCKING);\n\tif (ret) {\n\t\tmutex_unlock(&chip->mutex);\n\t\treturn ret;\n\t}\n\n\tpr_debug(\"MTD %s(): XXLOCK 0x%08lx len %d\\n\", __func__, adr, len);\n\n\tcfi_send_gen_cmd(0xAA, cfi->addr_unlock1, chip->start, map, cfi,\n\t\t\t cfi->device_type, NULL);\n\tcfi_send_gen_cmd(0x55, cfi->addr_unlock2, chip->start, map, cfi,\n\t\t\t cfi->device_type, NULL);\n\t \n\tcfi_send_gen_cmd(0xC0, cfi->addr_unlock1, chip->start, map, cfi,\n\t\t\t cfi->device_type, NULL);\n\n\tif (thunk == DO_XXLOCK_ONEBLOCK_LOCK) {\n\t\tchip->state = FL_LOCKING;\n\t\tmap_write(map, CMD(0xA0), adr);\n\t\tmap_write(map, CMD(0x00), adr);\n\t} else if (thunk == DO_XXLOCK_ONEBLOCK_UNLOCK) {\n\t\t \n\t\tchip->state = FL_UNLOCKING;\n\t\tmap_write(map, CMD(0x80), chip->start);\n\t\tmap_write(map, CMD(0x30), chip->start);\n\t} else if (thunk == DO_XXLOCK_ONEBLOCK_GETLOCK) {\n\t\tchip->state = FL_JEDEC_QUERY;\n\t\t \n\t\tret = !cfi_read_query(map, adr);\n\t} else\n\t\tBUG();\n\n\t \n\ttimeo = jiffies + msecs_to_jiffies(2000);\t \n\tfor (;;) {\n\t\tif (chip_ready(map, chip, adr, NULL))\n\t\t\tbreak;\n\n\t\tif (time_after(jiffies, timeo)) {\n\t\t\tprintk(KERN_ERR \"Waiting for chip to be ready timed out.\\n\");\n\t\t\tret = -EIO;\n\t\t\tbreak;\n\t\t}\n\n\t\tUDELAY(map, chip, adr, 1);\n\t}\n\n\t \n\tmap_write(map, CMD(0x90), chip->start);\n\tmap_write(map, CMD(0x00), chip->start);\n\n\tchip->state = FL_READY;\n\tput_chip(map, chip, adr);\n\tmutex_unlock(&chip->mutex);\n\n\treturn ret;\n}\n\nstatic int __maybe_unused cfi_ppb_lock(struct mtd_info *mtd, loff_t ofs,\n\t\t\t\t       uint64_t len)\n{\n\treturn cfi_varsize_frob(mtd, do_ppb_xxlock, ofs, len,\n\t\t\t\tDO_XXLOCK_ONEBLOCK_LOCK);\n}\n\nstatic int __maybe_unused cfi_ppb_unlock(struct mtd_info *mtd, loff_t ofs,\n\t\t\t\t\t uint64_t len)\n{\n\tstruct mtd_erase_region_info *regions = mtd->eraseregions;\n\tstruct map_info *map = mtd->priv;\n\tstruct cfi_private *cfi = map->fldrv_priv;\n\tstruct ppb_lock *sect;\n\tunsigned long adr;\n\tloff_t offset;\n\tuint64_t length;\n\tint chipnum;\n\tint i;\n\tint sectors;\n\tint ret;\n\tint max_sectors;\n\n\t \n\tmax_sectors = 0;\n\tfor (i = 0; i < mtd->numeraseregions; i++)\n\t\tmax_sectors += regions[i].numblocks;\n\n\tsect = kcalloc(max_sectors, sizeof(struct ppb_lock), GFP_KERNEL);\n\tif (!sect)\n\t\treturn -ENOMEM;\n\n\t \n\ti = 0;\n\tchipnum = 0;\n\tadr = 0;\n\tsectors = 0;\n\toffset = 0;\n\tlength = mtd->size;\n\n\twhile (length) {\n\t\tint size = regions[i].erasesize;\n\n\t\t \n\t\tif ((offset < ofs) || (offset >= (ofs + len))) {\n\t\t\tsect[sectors].chip = &cfi->chips[chipnum];\n\t\t\tsect[sectors].adr = adr;\n\t\t\tsect[sectors].locked = do_ppb_xxlock(\n\t\t\t\tmap, &cfi->chips[chipnum], adr, 0,\n\t\t\t\tDO_XXLOCK_ONEBLOCK_GETLOCK);\n\t\t}\n\n\t\tadr += size;\n\t\toffset += size;\n\t\tlength -= size;\n\n\t\tif (offset == regions[i].offset + size * regions[i].numblocks)\n\t\t\ti++;\n\n\t\tif (adr >> cfi->chipshift) {\n\t\t\tif (offset >= (ofs + len))\n\t\t\t\tbreak;\n\t\t\tadr = 0;\n\t\t\tchipnum++;\n\n\t\t\tif (chipnum >= cfi->numchips)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tsectors++;\n\t\tif (sectors >= max_sectors) {\n\t\t\tprintk(KERN_ERR \"Only %d sectors for PPB locking supported!\\n\",\n\t\t\t       max_sectors);\n\t\t\tkfree(sect);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t \n\tret = cfi_varsize_frob(mtd, do_ppb_xxlock, ofs, len,\n\t\t\t       DO_XXLOCK_ONEBLOCK_UNLOCK);\n\tif (ret) {\n\t\tkfree(sect);\n\t\treturn ret;\n\t}\n\n\t \n\tfor (i = 0; i < sectors; i++) {\n\t\tif (sect[i].locked)\n\t\t\tdo_ppb_xxlock(map, sect[i].chip, sect[i].adr, 0,\n\t\t\t\t      DO_XXLOCK_ONEBLOCK_LOCK);\n\t}\n\n\tkfree(sect);\n\treturn ret;\n}\n\nstatic int __maybe_unused cfi_ppb_is_locked(struct mtd_info *mtd, loff_t ofs,\n\t\t\t\t\t    uint64_t len)\n{\n\treturn cfi_varsize_frob(mtd, do_ppb_xxlock, ofs, len,\n\t\t\t\tDO_XXLOCK_ONEBLOCK_GETLOCK) ? 1 : 0;\n}\n\nstatic void cfi_amdstd_sync (struct mtd_info *mtd)\n{\n\tstruct map_info *map = mtd->priv;\n\tstruct cfi_private *cfi = map->fldrv_priv;\n\tint i;\n\tstruct flchip *chip;\n\tint ret = 0;\n\tDECLARE_WAITQUEUE(wait, current);\n\n\tfor (i=0; !ret && i<cfi->numchips; i++) {\n\t\tchip = &cfi->chips[i];\n\n\tretry:\n\t\tmutex_lock(&chip->mutex);\n\n\t\tswitch(chip->state) {\n\t\tcase FL_READY:\n\t\tcase FL_STATUS:\n\t\tcase FL_CFI_QUERY:\n\t\tcase FL_JEDEC_QUERY:\n\t\t\tchip->oldstate = chip->state;\n\t\t\tchip->state = FL_SYNCING;\n\t\t\t \n\t\t\tfallthrough;\n\t\tcase FL_SYNCING:\n\t\t\tmutex_unlock(&chip->mutex);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t \n\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\tadd_wait_queue(&chip->wq, &wait);\n\n\t\t\tmutex_unlock(&chip->mutex);\n\n\t\t\tschedule();\n\n\t\t\tremove_wait_queue(&chip->wq, &wait);\n\n\t\t\tgoto retry;\n\t\t}\n\t}\n\n\t \n\n\tfor (i--; i >=0; i--) {\n\t\tchip = &cfi->chips[i];\n\n\t\tmutex_lock(&chip->mutex);\n\n\t\tif (chip->state == FL_SYNCING) {\n\t\t\tchip->state = chip->oldstate;\n\t\t\twake_up(&chip->wq);\n\t\t}\n\t\tmutex_unlock(&chip->mutex);\n\t}\n}\n\n\nstatic int cfi_amdstd_suspend(struct mtd_info *mtd)\n{\n\tstruct map_info *map = mtd->priv;\n\tstruct cfi_private *cfi = map->fldrv_priv;\n\tint i;\n\tstruct flchip *chip;\n\tint ret = 0;\n\n\tfor (i=0; !ret && i<cfi->numchips; i++) {\n\t\tchip = &cfi->chips[i];\n\n\t\tmutex_lock(&chip->mutex);\n\n\t\tswitch(chip->state) {\n\t\tcase FL_READY:\n\t\tcase FL_STATUS:\n\t\tcase FL_CFI_QUERY:\n\t\tcase FL_JEDEC_QUERY:\n\t\t\tchip->oldstate = chip->state;\n\t\t\tchip->state = FL_PM_SUSPENDED;\n\t\t\t \n\t\t\tbreak;\n\t\tcase FL_PM_SUSPENDED:\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tret = -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\t\tmutex_unlock(&chip->mutex);\n\t}\n\n\t \n\n\tif (ret) {\n\t\tfor (i--; i >=0; i--) {\n\t\t\tchip = &cfi->chips[i];\n\n\t\t\tmutex_lock(&chip->mutex);\n\n\t\t\tif (chip->state == FL_PM_SUSPENDED) {\n\t\t\t\tchip->state = chip->oldstate;\n\t\t\t\twake_up(&chip->wq);\n\t\t\t}\n\t\t\tmutex_unlock(&chip->mutex);\n\t\t}\n\t}\n\n\treturn ret;\n}\n\n\nstatic void cfi_amdstd_resume(struct mtd_info *mtd)\n{\n\tstruct map_info *map = mtd->priv;\n\tstruct cfi_private *cfi = map->fldrv_priv;\n\tint i;\n\tstruct flchip *chip;\n\n\tfor (i=0; i<cfi->numchips; i++) {\n\n\t\tchip = &cfi->chips[i];\n\n\t\tmutex_lock(&chip->mutex);\n\n\t\tif (chip->state == FL_PM_SUSPENDED) {\n\t\t\tchip->state = FL_READY;\n\t\t\tmap_write(map, CMD(0xF0), chip->start);\n\t\t\twake_up(&chip->wq);\n\t\t}\n\t\telse\n\t\t\tprintk(KERN_ERR \"Argh. Chip not in PM_SUSPENDED state upon resume()\\n\");\n\n\t\tmutex_unlock(&chip->mutex);\n\t}\n}\n\n\n \nstatic int cfi_amdstd_reset(struct mtd_info *mtd)\n{\n\tstruct map_info *map = mtd->priv;\n\tstruct cfi_private *cfi = map->fldrv_priv;\n\tint i, ret;\n\tstruct flchip *chip;\n\n\tfor (i = 0; i < cfi->numchips; i++) {\n\n\t\tchip = &cfi->chips[i];\n\n\t\tmutex_lock(&chip->mutex);\n\n\t\tret = get_chip(map, chip, chip->start, FL_SHUTDOWN);\n\t\tif (!ret) {\n\t\t\tmap_write(map, CMD(0xF0), chip->start);\n\t\t\tchip->state = FL_SHUTDOWN;\n\t\t\tput_chip(map, chip, chip->start);\n\t\t}\n\n\t\tmutex_unlock(&chip->mutex);\n\t}\n\n\treturn 0;\n}\n\n\nstatic int cfi_amdstd_reboot(struct notifier_block *nb, unsigned long val,\n\t\t\t       void *v)\n{\n\tstruct mtd_info *mtd;\n\n\tmtd = container_of(nb, struct mtd_info, reboot_notifier);\n\tcfi_amdstd_reset(mtd);\n\treturn NOTIFY_DONE;\n}\n\n\nstatic void cfi_amdstd_destroy(struct mtd_info *mtd)\n{\n\tstruct map_info *map = mtd->priv;\n\tstruct cfi_private *cfi = map->fldrv_priv;\n\n\tcfi_amdstd_reset(mtd);\n\tunregister_reboot_notifier(&mtd->reboot_notifier);\n\tkfree(cfi->cmdset_priv);\n\tkfree(cfi->cfiq);\n\tkfree(cfi);\n\tkfree(mtd->eraseregions);\n}\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Crossnet Co. <info@crossnet.co.jp> et al.\");\nMODULE_DESCRIPTION(\"MTD chip driver for AMD/Fujitsu flash chips\");\nMODULE_ALIAS(\"cfi_cmdset_0006\");\nMODULE_ALIAS(\"cfi_cmdset_0701\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}