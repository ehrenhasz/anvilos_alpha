{
  "module_name": "Kconfig",
  "hash_id": "684cb4b8a64550ada2495792361f16b50e1ffa761bf0cae1251d960ee93c0b91",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/chips/Kconfig",
  "human_readable_source": "# SPDX-License-Identifier: GPL-2.0-only\nmenu \"RAM/ROM/Flash chip drivers\"\n\tdepends on MTD!=n\n\nconfig MTD_CFI\n\ttristate \"Detect flash chips by Common Flash Interface (CFI) probe\"\n\tselect MTD_GEN_PROBE\n\tselect MTD_CFI_UTIL\n\thelp\n\t  The Common Flash Interface specification was developed by Intel,\n\t  AMD and other flash manufactures that provides a universal method\n\t  for probing the capabilities of flash devices. If you wish to\n\t  support any device that is CFI-compliant, you need to enable this\n\t  option. Visit <https://www.amd.com/products/nvd/overview/cfi.html>\n\t  for more information on CFI.\n\nconfig MTD_JEDECPROBE\n\ttristate \"Detect non-CFI AMD/JEDEC-compatible flash chips\"\n\tselect MTD_GEN_PROBE\n\tselect MTD_CFI_UTIL\n\thelp\n\t  This option enables JEDEC-style probing of flash chips which are not\n\t  compatible with the Common Flash Interface, but will use the common\n\t  CFI-targeted flash drivers for any chips which are identified which\n\t  are in fact compatible in all but the probe method. This actually\n\t  covers most AMD/Fujitsu-compatible chips and also non-CFI\n\t  Intel chips.\n\nconfig MTD_GEN_PROBE\n\ttristate\n\nconfig MTD_CFI_ADV_OPTIONS\n\tbool \"Flash chip driver advanced configuration options\"\n\tdepends on MTD_GEN_PROBE\n\thelp\n\t  If you need to specify a specific endianness for access to flash\n\t  chips, or if you wish to reduce the size of the kernel by including\n\t  support for only specific arrangements of flash chips, say 'Y'. This\n\t  option does not directly affect the code, but will enable other\n\t  configuration options which allow you to do so.\n\n\t  If unsure, say 'N'.\n\nchoice\n\tprompt \"Flash cmd/query data swapping\"\n\tdepends on MTD_CFI_ADV_OPTIONS\n\tdefault MTD_CFI_NOSWAP\n\thelp\n\t  This option defines the way in which the CPU attempts to arrange\n\t  data bits when writing the 'magic' commands to the chips. Saying\n\t  'NO', which is the default when CONFIG_MTD_CFI_ADV_OPTIONS isn't\n\t  enabled, means that the CPU will not do any swapping; the chips\n\t  are expected to be wired to the CPU in 'host-endian' form.\n\t  Specific arrangements are possible with the BIG_ENDIAN_BYTE and\n\t  LITTLE_ENDIAN_BYTE, if the bytes are reversed.\n\nconfig MTD_CFI_NOSWAP\n\tdepends on !ARCH_IXP4XX || CPU_BIG_ENDIAN\n\tbool \"NO\"\n\nconfig MTD_CFI_BE_BYTE_SWAP\n\tbool \"BIG_ENDIAN_BYTE\"\n\nconfig MTD_CFI_LE_BYTE_SWAP\n\tdepends on !ARCH_IXP4XX\n\tbool \"LITTLE_ENDIAN_BYTE\"\n\nendchoice\n\nconfig MTD_CFI_GEOMETRY\n\tbool \"Specific CFI Flash geometry selection\"\n\tdepends on MTD_CFI_ADV_OPTIONS\n\tselect MTD_MAP_BANK_WIDTH_1 if  !(MTD_MAP_BANK_WIDTH_2 || \\\n\t\t MTD_MAP_BANK_WIDTH_4  || MTD_MAP_BANK_WIDTH_8 || \\\n\t\t MTD_MAP_BANK_WIDTH_16 || MTD_MAP_BANK_WIDTH_32)\n\tselect MTD_CFI_I1 if !(MTD_CFI_I2 || MTD_CFI_I4 || MTD_CFI_I8)\n\thelp\n\t  This option does not affect the code directly, but will enable\n\t  some other configuration options which would allow you to reduce\n\t  the size of the kernel by including support for only certain\n\t  arrangements of CFI chips. If unsure, say 'N' and all options\n\t  which are supported by the current code will be enabled.\n\nconfig MTD_MAP_BANK_WIDTH_1\n\tbool \"Support  8-bit buswidth\" if MTD_CFI_GEOMETRY\n\tdefault y\n\thelp\n\t  If you wish to support CFI devices on a physical bus which is\n\t  8 bits wide, say 'Y'.\n\nconfig MTD_MAP_BANK_WIDTH_2\n\tbool \"Support 16-bit buswidth\" if MTD_CFI_GEOMETRY\n\tdefault y\n\thelp\n\t  If you wish to support CFI devices on a physical bus which is\n\t  16 bits wide, say 'Y'.\n\nconfig MTD_MAP_BANK_WIDTH_4\n\tbool \"Support 32-bit buswidth\" if MTD_CFI_GEOMETRY\n\tdefault y\n\thelp\n\t  If you wish to support CFI devices on a physical bus which is\n\t  32 bits wide, say 'Y'.\n\nconfig MTD_MAP_BANK_WIDTH_8\n\tbool \"Support 64-bit buswidth\" if MTD_CFI_GEOMETRY\n\tdefault n\n\thelp\n\t  If you wish to support CFI devices on a physical bus which is\n\t  64 bits wide, say 'Y'.\n\nconfig MTD_MAP_BANK_WIDTH_16\n\tbool \"Support 128-bit buswidth\" if MTD_CFI_GEOMETRY\n\tdefault n\n\thelp\n\t  If you wish to support CFI devices on a physical bus which is\n\t  128 bits wide, say 'Y'.\n\nconfig MTD_MAP_BANK_WIDTH_32\n\tbool \"Support 256-bit buswidth\" if MTD_CFI_GEOMETRY\n\tselect MTD_COMPLEX_MAPPINGS if HAS_IOMEM\n\tdefault n\n\thelp\n\t  If you wish to support CFI devices on a physical bus which is\n\t  256 bits wide, say 'Y'.\n\nconfig MTD_CFI_I1\n\tbool \"Support 1-chip flash interleave\" if MTD_CFI_GEOMETRY\n\tdefault y\n\thelp\n\t  If your flash chips are not interleaved - i.e. you only have one\n\t  flash chip addressed by each bus cycle, then say 'Y'.\n\nconfig MTD_CFI_I2\n\tbool \"Support 2-chip flash interleave\" if MTD_CFI_GEOMETRY\n\tdefault y\n\thelp\n\t  If your flash chips are interleaved in pairs - i.e. you have two\n\t  flash chips addressed by each bus cycle, then say 'Y'.\n\nconfig MTD_CFI_I4\n\tbool \"Support 4-chip flash interleave\" if MTD_CFI_GEOMETRY\n\tdefault n\n\thelp\n\t  If your flash chips are interleaved in fours - i.e. you have four\n\t  flash chips addressed by each bus cycle, then say 'Y'.\n\nconfig MTD_CFI_I8\n\tbool \"Support 8-chip flash interleave\" if MTD_CFI_GEOMETRY\n\tdefault n\n\thelp\n\t  If your flash chips are interleaved in eights - i.e. you have eight\n\t  flash chips addressed by each bus cycle, then say 'Y'.\n\nconfig MTD_OTP\n\tbool \"Protection Registers aka one-time programmable (OTP) bits\"\n\tdepends on MTD_CFI_ADV_OPTIONS\n\tdefault n\n\thelp\n\t  This enables support for reading, writing and locking so called\n\t  \"Protection Registers\" present on some flash chips.\n\t  A subset of them are pre-programmed at the factory with a\n\t  unique set of values. The rest is user-programmable.\n\n\t  The user-programmable Protection Registers contain one-time\n\t  programmable (OTP) bits; when programmed, register bits cannot be\n\t  erased. Each Protection Register can be accessed multiple times to\n\t  program individual bits, as long as the register remains unlocked.\n\n\t  Each Protection Register has an associated Lock Register bit. When a\n\t  Lock Register bit is programmed, the associated Protection Register\n\t  can only be read; it can no longer be programmed. Additionally,\n\t  because the Lock Register bits themselves are OTP, when programmed,\n\t  Lock Register bits cannot be erased. Therefore, when a Protection\n\t  Register is locked, it cannot be unlocked.\n\n\t  This feature should therefore be used with extreme care. Any mistake\n\t  in the programming of OTP bits will waste them.\n\nconfig MTD_CFI_INTELEXT\n\ttristate \"Support for CFI command set 0001 (Intel/Sharp chips)\"\n\tdepends on MTD_GEN_PROBE\n\tselect MTD_CFI_UTIL\n\thelp\n\t  The Common Flash Interface defines a number of different command\n\t  sets which a CFI-compliant chip may claim to implement. This code\n\t  provides support for command set 0001, used on Intel StrataFlash\n\t  and other parts.\n\nconfig MTD_CFI_AMDSTD\n\ttristate \"Support for CFI command set 0002 (AMD/Fujitsu/Spansion chips)\"\n\tdepends on MTD_GEN_PROBE\n\tselect MTD_CFI_UTIL\n\thelp\n\t  The Common Flash Interface defines a number of different command\n\t  sets which a CFI-compliant chip may claim to implement. This code\n\t  provides support for command set 0002, used on chips including\n\t  the AMD Am29LV320.\n\nconfig MTD_CFI_STAA\n\ttristate \"Support for CFI command set 0020 (ST (Advanced Architecture) chips)\"\n\tdepends on MTD_GEN_PROBE\n\tselect MTD_CFI_UTIL\n\thelp\n\t  The Common Flash Interface defines a number of different command\n\t  sets which a CFI-compliant chip may claim to implement. This code\n\t  provides support for command set 0020.\n\nconfig MTD_CFI_UTIL\n\ttristate\n\nconfig MTD_RAM\n\ttristate \"Support for RAM chips in bus mapping\"\n\thelp\n\t  This option enables basic support for RAM chips accessed through\n\t  a bus mapping driver.\n\nconfig MTD_ROM\n\ttristate \"Support for ROM chips in bus mapping\"\n\thelp\n\t  This option enables basic support for ROM chips accessed through\n\t  a bus mapping driver.\n\nconfig MTD_ABSENT\n\ttristate \"Support for absent chips in bus mapping\"\n\thelp\n\t  This option enables support for a dummy probing driver used to\n\t  allocated placeholder MTD devices on systems that have socketed\n\t  or removable media.  Use of this driver as a fallback chip probe\n\t  preserves the expected registration order of MTD device nodes on\n\t  the system regardless of media presence.  Device nodes created\n\t  with this driver will return -ENODEV upon access.\n\nconfig MTD_XIP\n\tbool \"XIP aware MTD support\"\n\tdepends on !SMP && (MTD_CFI_INTELEXT || MTD_CFI_AMDSTD) && ARCH_MTD_XIP\n\tdefault y if XIP_KERNEL\n\thelp\n\t  This allows MTD support to work with flash memory which is also\n\t  used for XIP purposes.  If you're not sure what this is all about\n\t  then say N.\n\nendmenu\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}