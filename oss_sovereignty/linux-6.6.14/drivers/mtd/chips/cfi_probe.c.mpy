{
  "module_name": "cfi_probe.c",
  "hash_id": "40b9a4df935f5df07e91bff0e9c8e5dd981788e334df9ed467aecb59a0187bbc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/chips/cfi_probe.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <asm/io.h>\n#include <asm/byteorder.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n\n#include <linux/mtd/xip.h>\n#include <linux/mtd/map.h>\n#include <linux/mtd/cfi.h>\n#include <linux/mtd/gen_probe.h>\n\n\n\n#ifdef DEBUG_CFI\nstatic void print_cfi_ident(struct cfi_ident *);\n#endif\n\nstatic int cfi_probe_chip(struct map_info *map, __u32 base,\n\t\t\t  unsigned long *chip_map, struct cfi_private *cfi);\nstatic int cfi_chip_setup(struct map_info *map, struct cfi_private *cfi);\n\nstruct mtd_info *cfi_probe(struct map_info *map);\n\n#ifdef CONFIG_MTD_XIP\n\n \n#define xip_disable()\tlocal_irq_disable()\n\n#define xip_allowed(base, map) \\\ndo { \\\n\t(void) map_read(map, base); \\\n\txip_iprefetch(); \\\n\tlocal_irq_enable(); \\\n} while (0)\n\n#define xip_enable(base, map, cfi) \\\ndo { \\\n\tcfi_qry_mode_off(base, map, cfi);\t\t\\\n\txip_allowed(base, map); \\\n} while (0)\n\n#define xip_disable_qry(base, map, cfi) \\\ndo { \\\n\txip_disable(); \\\n\tcfi_qry_mode_on(base, map, cfi); \\\n} while (0)\n\n#else\n\n#define xip_disable()\t\t\tdo { } while (0)\n#define xip_allowed(base, map)\t\tdo { } while (0)\n#define xip_enable(base, map, cfi)\tdo { } while (0)\n#define xip_disable_qry(base, map, cfi) do { } while (0)\n\n#endif\n\n \nstruct cfi_early_fixup {\n\tuint16_t mfr;\n\tuint16_t id;\n\tvoid (*fixup)(struct cfi_private *cfi);\n};\n\nstatic void cfi_early_fixup(struct cfi_private *cfi,\n\t\t\t    const struct cfi_early_fixup *fixups)\n{\n\tconst struct cfi_early_fixup *f;\n\n\tfor (f = fixups; f->fixup; f++) {\n\t\tif (((f->mfr == CFI_MFR_ANY) || (f->mfr == cfi->mfr)) &&\n\t\t    ((f->id == CFI_ID_ANY) || (f->id == cfi->id))) {\n\t\t\tf->fixup(cfi);\n\t\t}\n\t}\n}\n\n \n\nstatic int __xipram cfi_probe_chip(struct map_info *map, __u32 base,\n\t\t\t\t   unsigned long *chip_map, struct cfi_private *cfi)\n{\n\tint i;\n\n\tif ((base + 0) >= map->size) {\n\t\tprintk(KERN_NOTICE\n\t\t\t\"Probe at base[0x00](0x%08lx) past the end of the map(0x%08lx)\\n\",\n\t\t\t(unsigned long)base, map->size -1);\n\t\treturn 0;\n\t}\n\tif ((base + 0xff) >= map->size) {\n\t\tprintk(KERN_NOTICE\n\t\t\t\"Probe at base[0x55](0x%08lx) past the end of the map(0x%08lx)\\n\",\n\t\t\t(unsigned long)base + 0x55, map->size -1);\n\t\treturn 0;\n\t}\n\n\txip_disable();\n\tif (!cfi_qry_mode_on(base, map, cfi)) {\n\t\txip_enable(base, map, cfi);\n\t\treturn 0;\n\t}\n\n\tif (!cfi->numchips) {\n\t\t \n\t\treturn cfi_chip_setup(map, cfi);\n\t}\n\n\t \n \tfor (i=0; i < (base >> cfi->chipshift); i++) {\n \t\tunsigned long start;\n \t\tif(!test_bit(i, chip_map)) {\n\t\t\t \n \t\t\tcontinue;\n \t\t}\n \t\tstart = i << cfi->chipshift;\n\t\t \n\t\tif (cfi_qry_present(map, start, cfi)) {\n\t\t\t \n\t\t\tcfi_qry_mode_off(start, map, cfi);\n\n\t\t\t \n\t\t\tif (!cfi_qry_present(map, start, cfi)) {\n\t\t\t\txip_allowed(base, map);\n\t\t\t\tprintk(KERN_DEBUG \"%s: Found an alias at 0x%x for the chip at 0x%lx\\n\",\n\t\t\t\t       map->name, base, start);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t \n\t\t\t \n\t\t\tcfi_qry_mode_off(base, map, cfi);\n\n\t\t\tif (cfi_qry_present(map, base, cfi)) {\n\t\t\t\txip_allowed(base, map);\n\t\t\t\tprintk(KERN_DEBUG \"%s: Found an alias at 0x%x for the chip at 0x%lx\\n\",\n\t\t\t\t       map->name, base, start);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tset_bit((base >> cfi->chipshift), chip_map);  \n\tcfi->numchips++;\n\n\t \n\tcfi_qry_mode_off(base, map, cfi);\n\txip_allowed(base, map);\n\n\tprintk(KERN_INFO \"%s: Found %d x%d devices at 0x%x in %d-bit bank\\n\",\n\t       map->name, cfi->interleave, cfi->device_type*8, base,\n\t       map->bankwidth*8);\n\n\treturn 1;\n}\n\nstatic void fixup_s70gl02gs_chips(struct cfi_private *cfi)\n{\n\t \n\tcfi->cfiq->DevSize = 27;\n\tcfi->cfiq->EraseRegionInfo[0] = 0x20003ff;\n\tpr_warn(\"Bad S70GL02GS CFI data; adjust to detect 2 chips\\n\");\n}\n\nstatic const struct cfi_early_fixup cfi_early_fixup_table[] = {\n\t{ CFI_MFR_AMD, 0x4801, fixup_s70gl02gs_chips },\n\t{ },\n};\n\nstatic int __xipram cfi_chip_setup(struct map_info *map,\n\t\t\t\t   struct cfi_private *cfi)\n{\n\tint ofs_factor = cfi->interleave*cfi->device_type;\n\t__u32 base = 0;\n\tint num_erase_regions = cfi_read_query(map, base + (0x10 + 28)*ofs_factor);\n\tint i;\n\tint addr_unlock1 = 0x555, addr_unlock2 = 0x2AA;\n\n\txip_enable(base, map, cfi);\n#ifdef DEBUG_CFI\n\tprintk(\"Number of erase regions: %d\\n\", num_erase_regions);\n#endif\n\tif (!num_erase_regions)\n\t\treturn 0;\n\n\tcfi->cfiq = kmalloc(sizeof(struct cfi_ident) + num_erase_regions * 4, GFP_KERNEL);\n\tif (!cfi->cfiq)\n\t\treturn 0;\n\n\tmemset(cfi->cfiq,0,sizeof(struct cfi_ident));\n\n\tcfi->cfi_mode = CFI_MODE_CFI;\n\n\tcfi->sector_erase_cmd = CMD(0x30);\n\n\t \n\txip_disable_qry(base, map, cfi);\n\tfor (i=0; i<(sizeof(struct cfi_ident) + num_erase_regions * 4); i++)\n\t\t((unsigned char *)cfi->cfiq)[i] = cfi_read_query(map,base + (0x10 + i)*ofs_factor);\n\n\t \n\tcfi->cfiq->P_ID = le16_to_cpu(cfi->cfiq->P_ID);\n\n\tcfi->cfiq->P_ADR = le16_to_cpu(cfi->cfiq->P_ADR);\n\tcfi->cfiq->A_ID = le16_to_cpu(cfi->cfiq->A_ID);\n\tcfi->cfiq->A_ADR = le16_to_cpu(cfi->cfiq->A_ADR);\n\tcfi->cfiq->InterfaceDesc = le16_to_cpu(cfi->cfiq->InterfaceDesc);\n\tcfi->cfiq->MaxBufWriteSize = le16_to_cpu(cfi->cfiq->MaxBufWriteSize);\n\n#ifdef DEBUG_CFI\n\t \n\tprint_cfi_ident(cfi->cfiq);\n#endif\n\n\tfor (i=0; i<cfi->cfiq->NumEraseRegions; i++) {\n\t\tcfi->cfiq->EraseRegionInfo[i] = le32_to_cpu(cfi->cfiq->EraseRegionInfo[i]);\n\n#ifdef DEBUG_CFI\n\t\tprintk(\"  Erase Region #%d: BlockSize 0x%4.4X bytes, %d blocks\\n\",\n\t\t       i, (cfi->cfiq->EraseRegionInfo[i] >> 8) & ~0xff,\n\t\t       (cfi->cfiq->EraseRegionInfo[i] & 0xffff) + 1);\n#endif\n\t}\n\n\tif (cfi->cfiq->P_ID == P_ID_SST_OLD) {\n\t\taddr_unlock1 = 0x5555;\n\t\taddr_unlock2 = 0x2AAA;\n\t}\n\n\t \n\tcfi_send_gen_cmd(0xf0,     0, base, map, cfi, cfi->device_type, NULL);\n\tcfi_send_gen_cmd(0xaa, addr_unlock1, base, map, cfi, cfi->device_type, NULL);\n\tcfi_send_gen_cmd(0x55, addr_unlock2, base, map, cfi, cfi->device_type, NULL);\n\tcfi_send_gen_cmd(0x90, addr_unlock1, base, map, cfi, cfi->device_type, NULL);\n\tcfi->mfr = cfi_read_query16(map, base);\n\tcfi->id = cfi_read_query16(map, base + ofs_factor);\n\n\t \n\tif (cfi->mfr == CFI_MFR_AMD && (cfi->id & 0xff) == 0x7e)\n\t\tcfi->id = cfi_read_query(map, base + 0xe * ofs_factor) << 8 |\n\t\t\t  cfi_read_query(map, base + 0xf * ofs_factor);\n\n\t \n\tcfi_qry_mode_off(base, map, cfi);\n\txip_allowed(base, map);\n\n\tcfi_early_fixup(cfi, cfi_early_fixup_table);\n\n\tprintk(KERN_INFO \"%s: Found %d x%d devices at 0x%x in %d-bit bank. Manufacturer ID %#08x Chip ID %#08x\\n\",\n\t       map->name, cfi->interleave, cfi->device_type*8, base,\n\t       map->bankwidth*8, cfi->mfr, cfi->id);\n\n\treturn 1;\n}\n\n#ifdef DEBUG_CFI\nstatic char *vendorname(__u16 vendor)\n{\n\tswitch (vendor) {\n\tcase P_ID_NONE:\n\t\treturn \"None\";\n\n\tcase P_ID_INTEL_EXT:\n\t\treturn \"Intel/Sharp Extended\";\n\n\tcase P_ID_AMD_STD:\n\t\treturn \"AMD/Fujitsu Standard\";\n\n\tcase P_ID_INTEL_STD:\n\t\treturn \"Intel/Sharp Standard\";\n\n\tcase P_ID_AMD_EXT:\n\t\treturn \"AMD/Fujitsu Extended\";\n\n\tcase P_ID_WINBOND:\n\t\treturn \"Winbond Standard\";\n\n\tcase P_ID_ST_ADV:\n\t\treturn \"ST Advanced\";\n\n\tcase P_ID_MITSUBISHI_STD:\n\t\treturn \"Mitsubishi Standard\";\n\n\tcase P_ID_MITSUBISHI_EXT:\n\t\treturn \"Mitsubishi Extended\";\n\n\tcase P_ID_SST_PAGE:\n\t\treturn \"SST Page Write\";\n\n\tcase P_ID_SST_OLD:\n\t\treturn \"SST 39VF160x/39VF320x\";\n\n\tcase P_ID_INTEL_PERFORMANCE:\n\t\treturn \"Intel Performance Code\";\n\n\tcase P_ID_INTEL_DATA:\n\t\treturn \"Intel Data\";\n\n\tcase P_ID_RESERVED:\n\t\treturn \"Not Allowed / Reserved for Future Use\";\n\n\tdefault:\n\t\treturn \"Unknown\";\n\t}\n}\n\n\nstatic void print_cfi_ident(struct cfi_ident *cfip)\n{\n#if 0\n\tif (cfip->qry[0] != 'Q' || cfip->qry[1] != 'R' || cfip->qry[2] != 'Y') {\n\t\tprintk(\"Invalid CFI ident structure.\\n\");\n\t\treturn;\n\t}\n#endif\n\tprintk(\"Primary Vendor Command Set: %4.4X (%s)\\n\", cfip->P_ID, vendorname(cfip->P_ID));\n\tif (cfip->P_ADR)\n\t\tprintk(\"Primary Algorithm Table at %4.4X\\n\", cfip->P_ADR);\n\telse\n\t\tprintk(\"No Primary Algorithm Table\\n\");\n\n\tprintk(\"Alternative Vendor Command Set: %4.4X (%s)\\n\", cfip->A_ID, vendorname(cfip->A_ID));\n\tif (cfip->A_ADR)\n\t\tprintk(\"Alternate Algorithm Table at %4.4X\\n\", cfip->A_ADR);\n\telse\n\t\tprintk(\"No Alternate Algorithm Table\\n\");\n\n\n\tprintk(\"Vcc Minimum: %2d.%d V\\n\", cfip->VccMin >> 4, cfip->VccMin & 0xf);\n\tprintk(\"Vcc Maximum: %2d.%d V\\n\", cfip->VccMax >> 4, cfip->VccMax & 0xf);\n\tif (cfip->VppMin) {\n\t\tprintk(\"Vpp Minimum: %2d.%d V\\n\", cfip->VppMin >> 4, cfip->VppMin & 0xf);\n\t\tprintk(\"Vpp Maximum: %2d.%d V\\n\", cfip->VppMax >> 4, cfip->VppMax & 0xf);\n\t}\n\telse\n\t\tprintk(\"No Vpp line\\n\");\n\n\tprintk(\"Typical byte/word write timeout: %d \u00b5s\\n\", 1<<cfip->WordWriteTimeoutTyp);\n\tprintk(\"Maximum byte/word write timeout: %d \u00b5s\\n\", (1<<cfip->WordWriteTimeoutMax) * (1<<cfip->WordWriteTimeoutTyp));\n\n\tif (cfip->BufWriteTimeoutTyp || cfip->BufWriteTimeoutMax) {\n\t\tprintk(\"Typical full buffer write timeout: %d \u00b5s\\n\", 1<<cfip->BufWriteTimeoutTyp);\n\t\tprintk(\"Maximum full buffer write timeout: %d \u00b5s\\n\", (1<<cfip->BufWriteTimeoutMax) * (1<<cfip->BufWriteTimeoutTyp));\n\t}\n\telse\n\t\tprintk(\"Full buffer write not supported\\n\");\n\n\tprintk(\"Typical block erase timeout: %d ms\\n\", 1<<cfip->BlockEraseTimeoutTyp);\n\tprintk(\"Maximum block erase timeout: %d ms\\n\", (1<<cfip->BlockEraseTimeoutMax) * (1<<cfip->BlockEraseTimeoutTyp));\n\tif (cfip->ChipEraseTimeoutTyp || cfip->ChipEraseTimeoutMax) {\n\t\tprintk(\"Typical chip erase timeout: %d ms\\n\", 1<<cfip->ChipEraseTimeoutTyp);\n\t\tprintk(\"Maximum chip erase timeout: %d ms\\n\", (1<<cfip->ChipEraseTimeoutMax) * (1<<cfip->ChipEraseTimeoutTyp));\n\t}\n\telse\n\t\tprintk(\"Chip erase not supported\\n\");\n\n\tprintk(\"Device size: 0x%X bytes (%d MiB)\\n\", 1 << cfip->DevSize, 1<< (cfip->DevSize - 20));\n\tprintk(\"Flash Device Interface description: 0x%4.4X\\n\", cfip->InterfaceDesc);\n\tswitch(cfip->InterfaceDesc) {\n\tcase CFI_INTERFACE_X8_ASYNC:\n\t\tprintk(\"  - x8-only asynchronous interface\\n\");\n\t\tbreak;\n\n\tcase CFI_INTERFACE_X16_ASYNC:\n\t\tprintk(\"  - x16-only asynchronous interface\\n\");\n\t\tbreak;\n\n\tcase CFI_INTERFACE_X8_BY_X16_ASYNC:\n\t\tprintk(\"  - supports x8 and x16 via BYTE# with asynchronous interface\\n\");\n\t\tbreak;\n\n\tcase CFI_INTERFACE_X32_ASYNC:\n\t\tprintk(\"  - x32-only asynchronous interface\\n\");\n\t\tbreak;\n\n\tcase CFI_INTERFACE_X16_BY_X32_ASYNC:\n\t\tprintk(\"  - supports x16 and x32 via Word# with asynchronous interface\\n\");\n\t\tbreak;\n\n\tcase CFI_INTERFACE_NOT_ALLOWED:\n\t\tprintk(\"  - Not Allowed / Reserved\\n\");\n\t\tbreak;\n\n\tdefault:\n\t\tprintk(\"  - Unknown\\n\");\n\t\tbreak;\n\t}\n\n\tprintk(\"Max. bytes in buffer write: 0x%x\\n\", 1<< cfip->MaxBufWriteSize);\n\tprintk(\"Number of Erase Block Regions: %d\\n\", cfip->NumEraseRegions);\n\n}\n#endif  \n\nstatic struct chip_probe cfi_chip_probe = {\n\t.name\t\t= \"CFI\",\n\t.probe_chip\t= cfi_probe_chip\n};\n\nstruct mtd_info *cfi_probe(struct map_info *map)\n{\n\t \n\treturn mtd_do_chip_probe(map, &cfi_chip_probe);\n}\n\nstatic struct mtd_chip_driver cfi_chipdrv = {\n\t.probe\t\t= cfi_probe,\n\t.name\t\t= \"cfi_probe\",\n\t.module\t\t= THIS_MODULE\n};\n\nstatic int __init cfi_probe_init(void)\n{\n\tregister_mtd_chip_driver(&cfi_chipdrv);\n\treturn 0;\n}\n\nstatic void __exit cfi_probe_exit(void)\n{\n\tunregister_mtd_chip_driver(&cfi_chipdrv);\n}\n\nmodule_init(cfi_probe_init);\nmodule_exit(cfi_probe_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"David Woodhouse <dwmw2@infradead.org> et al.\");\nMODULE_DESCRIPTION(\"Probe code for CFI-compliant flash chips\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}