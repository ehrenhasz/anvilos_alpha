{
  "module_name": "cfi_util.c",
  "hash_id": "078821df4fa7e1d9978c6970dd0d880fb0302fb55bb83453a87ef5bc0c02332c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/chips/cfi_util.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <asm/io.h>\n#include <asm/byteorder.h>\n\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/mtd/xip.h>\n#include <linux/mtd/mtd.h>\n#include <linux/mtd/map.h>\n#include <linux/mtd/cfi.h>\n\nvoid cfi_udelay(int us)\n{\n\tif (us >= 1000) {\n\t\tmsleep(DIV_ROUND_UP(us, 1000));\n\t} else {\n\t\tudelay(us);\n\t\tcond_resched();\n\t}\n}\nEXPORT_SYMBOL(cfi_udelay);\n\n \nuint32_t cfi_build_cmd_addr(uint32_t cmd_ofs,\n\t\t\t\tstruct map_info *map, struct cfi_private *cfi)\n{\n\tunsigned bankwidth = map_bankwidth(map);\n\tunsigned interleave = cfi_interleave(cfi);\n\tunsigned type = cfi->device_type;\n\tuint32_t addr;\n\n\taddr = (cmd_ofs * type) * interleave;\n\n\t \n\tif (((type * interleave) > bankwidth) && ((cmd_ofs & 0xff) == 0xaa))\n\t\taddr |= (type >> 1)*interleave;\n\n\treturn  addr;\n}\nEXPORT_SYMBOL(cfi_build_cmd_addr);\n\n \nmap_word cfi_build_cmd(u_long cmd, struct map_info *map, struct cfi_private *cfi)\n{\n\tmap_word val = { {0} };\n\tint wordwidth, words_per_bus, chip_mode, chips_per_word;\n\tunsigned long onecmd;\n\tint i;\n\n\t \n\tif (map_bankwidth_is_large(map)) {\n\t\twordwidth = sizeof(unsigned long);\n\t\twords_per_bus = (map_bankwidth(map)) / wordwidth; \n\t} else {\n\t\twordwidth = map_bankwidth(map);\n\t\twords_per_bus = 1;\n\t}\n\n\tchip_mode = map_bankwidth(map) / cfi_interleave(cfi);\n\tchips_per_word = wordwidth * cfi_interleave(cfi) / map_bankwidth(map);\n\n\t \n\tswitch (chip_mode) {\n\tdefault: BUG();\n\tcase 1:\n\t\tonecmd = cmd;\n\t\tbreak;\n\tcase 2:\n\t\tonecmd = cpu_to_cfi16(map, cmd);\n\t\tbreak;\n\tcase 4:\n\t\tonecmd = cpu_to_cfi32(map, cmd);\n\t\tbreak;\n\t}\n\n\t \n\tswitch (chips_per_word) {\n\tdefault: BUG();\n#if BITS_PER_LONG >= 64\n\tcase 8:\n\t\tonecmd |= (onecmd << (chip_mode * 32));\n\t\tfallthrough;\n#endif\n\tcase 4:\n\t\tonecmd |= (onecmd << (chip_mode * 16));\n\t\tfallthrough;\n\tcase 2:\n\t\tonecmd |= (onecmd << (chip_mode * 8));\n\t\tfallthrough;\n\tcase 1:\n\t\t;\n\t}\n\n\t \n\tfor (i=0; i < words_per_bus; i++) {\n\t\tval.x[i] = onecmd;\n\t}\n\n\treturn val;\n}\nEXPORT_SYMBOL(cfi_build_cmd);\n\nunsigned long cfi_merge_status(map_word val, struct map_info *map,\n\t\t\t\t\t   struct cfi_private *cfi)\n{\n\tint wordwidth, words_per_bus, chip_mode, chips_per_word;\n\tunsigned long onestat, res = 0;\n\tint i;\n\n\t \n\tif (map_bankwidth_is_large(map)) {\n\t\twordwidth = sizeof(unsigned long);\n\t\twords_per_bus = (map_bankwidth(map)) / wordwidth; \n\t} else {\n\t\twordwidth = map_bankwidth(map);\n\t\twords_per_bus = 1;\n\t}\n\n\tchip_mode = map_bankwidth(map) / cfi_interleave(cfi);\n\tchips_per_word = wordwidth * cfi_interleave(cfi) / map_bankwidth(map);\n\n\tonestat = val.x[0];\n\t \n\tfor (i=1; i < words_per_bus; i++) {\n\t\tonestat |= val.x[i];\n\t}\n\n\tres = onestat;\n\tswitch(chips_per_word) {\n\tdefault: BUG();\n#if BITS_PER_LONG >= 64\n\tcase 8:\n\t\tres |= (onestat >> (chip_mode * 32));\n\t\tfallthrough;\n#endif\n\tcase 4:\n\t\tres |= (onestat >> (chip_mode * 16));\n\t\tfallthrough;\n\tcase 2:\n\t\tres |= (onestat >> (chip_mode * 8));\n\t\tfallthrough;\n\tcase 1:\n\t\t;\n\t}\n\n\t \n\tswitch (chip_mode) {\n\tcase 1:\n\t\tbreak;\n\tcase 2:\n\t\tres = cfi16_to_cpu(map, res);\n\t\tbreak;\n\tcase 4:\n\t\tres = cfi32_to_cpu(map, res);\n\t\tbreak;\n\tdefault: BUG();\n\t}\n\treturn res;\n}\nEXPORT_SYMBOL(cfi_merge_status);\n\n \nuint32_t cfi_send_gen_cmd(u_char cmd, uint32_t cmd_addr, uint32_t base,\n\t\t\t\tstruct map_info *map, struct cfi_private *cfi,\n\t\t\t\tint type, map_word *prev_val)\n{\n\tmap_word val;\n\tuint32_t addr = base + cfi_build_cmd_addr(cmd_addr, map, cfi);\n\tval = cfi_build_cmd(cmd, map, cfi);\n\n\tif (prev_val)\n\t\t*prev_val = map_read(map, addr);\n\n\tmap_write(map, val, addr);\n\n\treturn addr - base;\n}\nEXPORT_SYMBOL(cfi_send_gen_cmd);\n\nint __xipram cfi_qry_present(struct map_info *map, __u32 base,\n\t\t\t     struct cfi_private *cfi)\n{\n\tint osf = cfi->interleave * cfi->device_type;\t \n\tmap_word val[3];\n\tmap_word qry[3];\n\n\tqry[0] = cfi_build_cmd('Q', map, cfi);\n\tqry[1] = cfi_build_cmd('R', map, cfi);\n\tqry[2] = cfi_build_cmd('Y', map, cfi);\n\n\tval[0] = map_read(map, base + osf*0x10);\n\tval[1] = map_read(map, base + osf*0x11);\n\tval[2] = map_read(map, base + osf*0x12);\n\n\tif (!map_word_equal(map, qry[0], val[0]))\n\t\treturn 0;\n\n\tif (!map_word_equal(map, qry[1], val[1]))\n\t\treturn 0;\n\n\tif (!map_word_equal(map, qry[2], val[2]))\n\t\treturn 0;\n\n\treturn 1; \t \n}\nEXPORT_SYMBOL_GPL(cfi_qry_present);\n\nint __xipram cfi_qry_mode_on(uint32_t base, struct map_info *map,\n\t\t\t     struct cfi_private *cfi)\n{\n\tcfi_send_gen_cmd(0xF0, 0, base, map, cfi, cfi->device_type, NULL);\n\tcfi_send_gen_cmd(0x98, 0x55, base, map, cfi, cfi->device_type, NULL);\n\tif (cfi_qry_present(map, base, cfi))\n\t\treturn 1;\n\t \n\t \n\tcfi_send_gen_cmd(0xF0, 0, base, map, cfi, cfi->device_type, NULL);\n\tcfi_send_gen_cmd(0xFF, 0, base, map, cfi, cfi->device_type, NULL);\n\tcfi_send_gen_cmd(0x98, 0x55, base, map, cfi, cfi->device_type, NULL);\n\tif (cfi_qry_present(map, base, cfi))\n\t\treturn 1;\n\t \n\tcfi_send_gen_cmd(0xF0, 0, base, map, cfi, cfi->device_type, NULL);\n\tcfi_send_gen_cmd(0x98, 0x555, base, map, cfi, cfi->device_type, NULL);\n\tif (cfi_qry_present(map, base, cfi))\n\t\treturn 1;\n\t \n\tcfi_send_gen_cmd(0xF0, 0, base, map, cfi, cfi->device_type, NULL);\n\tcfi_send_gen_cmd(0xAA, 0x5555, base, map, cfi, cfi->device_type, NULL);\n\tcfi_send_gen_cmd(0x55, 0x2AAA, base, map, cfi, cfi->device_type, NULL);\n\tcfi_send_gen_cmd(0x98, 0x5555, base, map, cfi, cfi->device_type, NULL);\n\tif (cfi_qry_present(map, base, cfi))\n\t\treturn 1;\n\t \n\tcfi_send_gen_cmd(0xF0, 0, base, map, cfi, cfi->device_type, NULL);\n\tcfi_send_gen_cmd(0xAA, 0x555, base, map, cfi, cfi->device_type, NULL);\n\tcfi_send_gen_cmd(0x55, 0x2AA, base, map, cfi, cfi->device_type, NULL);\n\tcfi_send_gen_cmd(0x98, 0x555, base, map, cfi, cfi->device_type, NULL);\n\tif (cfi_qry_present(map, base, cfi))\n\t\treturn 1;\n\t \n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(cfi_qry_mode_on);\n\nvoid __xipram cfi_qry_mode_off(uint32_t base, struct map_info *map,\n\t\t\t       struct cfi_private *cfi)\n{\n\tcfi_send_gen_cmd(0xF0, 0, base, map, cfi, cfi->device_type, NULL);\n\tcfi_send_gen_cmd(0xFF, 0, base, map, cfi, cfi->device_type, NULL);\n\t \n\tif ((cfi->mfr == CFI_MFR_ST) && (cfi->id == 0x227E || cfi->id == 0x7E))\n\t\tcfi_send_gen_cmd(0xF0, 0, base, map, cfi, cfi->device_type, NULL);\n}\nEXPORT_SYMBOL_GPL(cfi_qry_mode_off);\n\nstruct cfi_extquery *\n__xipram cfi_read_pri(struct map_info *map, __u16 adr, __u16 size, const char* name)\n{\n\tstruct cfi_private *cfi = map->fldrv_priv;\n\t__u32 base = 0; \n\tint ofs_factor = cfi->interleave * cfi->device_type;\n\tint i;\n\tstruct cfi_extquery *extp = NULL;\n\n\tif (!adr)\n\t\tgoto out;\n\n\tprintk(KERN_INFO \"%s Extended Query Table at 0x%4.4X\\n\", name, adr);\n\n\textp = kmalloc(size, GFP_KERNEL);\n\tif (!extp)\n\t\tgoto out;\n\n#ifdef CONFIG_MTD_XIP\n\tlocal_irq_disable();\n#endif\n\n\t \n\tcfi_qry_mode_on(base, map, cfi);\n\t \n\tfor (i=0; i<size; i++) {\n\t\t((unsigned char *)extp)[i] =\n\t\t\tcfi_read_query(map, base+((adr+i)*ofs_factor));\n\t}\n\n\t \n\tcfi_qry_mode_off(base, map, cfi);\n\n#ifdef CONFIG_MTD_XIP\n\t(void) map_read(map, base);\n\txip_iprefetch();\n\tlocal_irq_enable();\n#endif\n\n out:\treturn extp;\n}\n\nEXPORT_SYMBOL(cfi_read_pri);\n\nvoid cfi_fixup(struct mtd_info *mtd, struct cfi_fixup *fixups)\n{\n\tstruct map_info *map = mtd->priv;\n\tstruct cfi_private *cfi = map->fldrv_priv;\n\tstruct cfi_fixup *f;\n\n\tfor (f=fixups; f->fixup; f++) {\n\t\tif (((f->mfr == CFI_MFR_ANY) || (f->mfr == cfi->mfr)) &&\n\t\t    ((f->id  == CFI_ID_ANY)  || (f->id  == cfi->id))) {\n\t\t\tf->fixup(mtd);\n\t\t}\n\t}\n}\n\nEXPORT_SYMBOL(cfi_fixup);\n\nint cfi_varsize_frob(struct mtd_info *mtd, varsize_frob_t frob,\n\t\t\t\t     loff_t ofs, size_t len, void *thunk)\n{\n\tstruct map_info *map = mtd->priv;\n\tstruct cfi_private *cfi = map->fldrv_priv;\n\tunsigned long adr;\n\tint chipnum, ret = 0;\n\tint i, first;\n\tstruct mtd_erase_region_info *regions = mtd->eraseregions;\n\n\t \n\n\ti = 0;\n\n\t \n\n\twhile (i < mtd->numeraseregions && ofs >= regions[i].offset)\n\t       i++;\n\ti--;\n\n\t \n\n\tif (ofs & (regions[i].erasesize-1))\n\t\treturn -EINVAL;\n\n\t \n\tfirst = i;\n\n\t \n\n\twhile (i<mtd->numeraseregions && (ofs + len) >= regions[i].offset)\n\t\ti++;\n\n\t \n\ti--;\n\n\tif ((ofs + len) & (regions[i].erasesize-1))\n\t\treturn -EINVAL;\n\n\tchipnum = ofs >> cfi->chipshift;\n\tadr = ofs - (chipnum << cfi->chipshift);\n\n\ti=first;\n\n\twhile(len) {\n\t\tint size = regions[i].erasesize;\n\n\t\tret = (*frob)(map, &cfi->chips[chipnum], adr, size, thunk);\n\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tadr += size;\n\t\tofs += size;\n\t\tlen -= size;\n\n\t\tif (ofs == regions[i].offset + size * regions[i].numblocks)\n\t\t\ti++;\n\n\t\tif (adr >> cfi->chipshift) {\n\t\t\tadr = 0;\n\t\t\tchipnum++;\n\n\t\t\tif (chipnum >= cfi->numchips)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nEXPORT_SYMBOL(cfi_varsize_frob);\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}