{
  "module_name": "ftl.c",
  "hash_id": "3048c83e4b641f4d41845357a1b073e078430f3ae5851ec06e1a23487bfa5d9d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/ftl.c",
  "human_readable_source": " \n \n#include <linux/mtd/blktrans.h>\n#include <linux/module.h>\n#include <linux/mtd/mtd.h>\n \n\n#include <linux/kernel.h>\n#include <linux/ptrace.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/timer.h>\n#include <linux/major.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/hdreg.h>\n#include <linux/vmalloc.h>\n#include <linux/blkpg.h>\n#include <linux/uaccess.h>\n\n#include <linux/mtd/ftl.h>\n\n \n\n \nstatic int shuffle_freq = 50;\nmodule_param(shuffle_freq, int, 0);\n\n \n\n \n#ifndef FTL_MAJOR\n#define FTL_MAJOR\t44\n#endif\n\n\n \n\n \n#define MAX_DEV\t\t4\n\n \n#define MAX_REGION\t4\n\n \n#define PART_BITS\t4\n\n \n#define MAX_ERASE\t8\n\n \n#define SECTOR_SIZE\t512\n\n\n \ntypedef struct partition_t {\n    struct mtd_blktrans_dev mbd;\n    uint32_t\t\tstate;\n    uint32_t\t\t*VirtualBlockMap;\n    uint32_t\t\tFreeTotal;\n    struct eun_info_t {\n\tuint32_t\t\tOffset;\n\tuint32_t\t\tEraseCount;\n\tuint32_t\t\tFree;\n\tuint32_t\t\tDeleted;\n    } *EUNInfo;\n    struct xfer_info_t {\n\tuint32_t\t\tOffset;\n\tuint32_t\t\tEraseCount;\n\tuint16_t\t\tstate;\n    } *XferInfo;\n    uint16_t\t\tbam_index;\n    uint32_t\t\t*bam_cache;\n    uint16_t\t\tDataUnits;\n    uint32_t\t\tBlocksPerUnit;\n    erase_unit_header_t\theader;\n} partition_t;\n\n \n#define FTL_FORMATTED\t0x01\n\n \n#define XFER_UNKNOWN\t0x00\n#define XFER_ERASING\t0x01\n#define XFER_ERASED\t0x02\n#define XFER_PREPARED\t0x03\n#define XFER_FAILED\t0x04\n\n \n\nstatic int scan_header(partition_t *part)\n{\n    erase_unit_header_t header;\n    loff_t offset, max_offset;\n    size_t ret;\n    int err;\n    part->header.FormattedSize = 0;\n    max_offset = (0x100000<part->mbd.mtd->size)?0x100000:part->mbd.mtd->size;\n     \n    for (offset = 0;\n\t (offset + sizeof(header)) < max_offset;\n\t offset += part->mbd.mtd->erasesize ? : 0x2000) {\n\n\terr = mtd_read(part->mbd.mtd, offset, sizeof(header), &ret,\n                       (unsigned char *)&header);\n\n\tif (err)\n\t    return err;\n\n\tif (strcmp(header.DataOrgTuple+3, \"FTL100\") == 0) break;\n    }\n\n    if (offset == max_offset) {\n\tprintk(KERN_NOTICE \"ftl_cs: FTL header not found.\\n\");\n\treturn -ENOENT;\n    }\n    if (header.BlockSize != 9 ||\n\t(header.EraseUnitSize < 10) || (header.EraseUnitSize > 31) ||\n\t(header.NumTransferUnits >= le16_to_cpu(header.NumEraseUnits))) {\n\tprintk(KERN_NOTICE \"ftl_cs: FTL header corrupt!\\n\");\n\treturn -1;\n    }\n    if ((1 << header.EraseUnitSize) != part->mbd.mtd->erasesize) {\n\tprintk(KERN_NOTICE \"ftl: FTL EraseUnitSize %x != MTD erasesize %x\\n\",\n\t       1 << header.EraseUnitSize,part->mbd.mtd->erasesize);\n\treturn -1;\n    }\n    part->header = header;\n    return 0;\n}\n\nstatic int build_maps(partition_t *part)\n{\n    erase_unit_header_t header;\n    uint16_t xvalid, xtrans, i;\n    unsigned blocks, j;\n    int hdr_ok, ret = -1;\n    ssize_t retval;\n    loff_t offset;\n\n     \n    part->DataUnits = le16_to_cpu(part->header.NumEraseUnits) -\n\tpart->header.NumTransferUnits;\n    part->EUNInfo = kmalloc_array(part->DataUnits, sizeof(struct eun_info_t),\n                                  GFP_KERNEL);\n    if (!part->EUNInfo)\n\t    goto out;\n    for (i = 0; i < part->DataUnits; i++)\n\tpart->EUNInfo[i].Offset = 0xffffffff;\n    part->XferInfo =\n\tkmalloc_array(part->header.NumTransferUnits,\n                      sizeof(struct xfer_info_t),\n                      GFP_KERNEL);\n    if (!part->XferInfo)\n\t    goto out_EUNInfo;\n\n    xvalid = xtrans = 0;\n    for (i = 0; i < le16_to_cpu(part->header.NumEraseUnits); i++) {\n\toffset = ((i + le16_to_cpu(part->header.FirstPhysicalEUN))\n\t\t      << part->header.EraseUnitSize);\n\tret = mtd_read(part->mbd.mtd, offset, sizeof(header), &retval,\n                       (unsigned char *)&header);\n\n\tif (ret)\n\t    goto out_XferInfo;\n\n\tret = -1;\n\t \n\thdr_ok = (strcmp(header.DataOrgTuple+3, \"FTL100\") == 0);\n\tif (hdr_ok && (le16_to_cpu(header.LogicalEUN) < part->DataUnits) &&\n\t    (part->EUNInfo[le16_to_cpu(header.LogicalEUN)].Offset == 0xffffffff)) {\n\t    part->EUNInfo[le16_to_cpu(header.LogicalEUN)].Offset = offset;\n\t    part->EUNInfo[le16_to_cpu(header.LogicalEUN)].EraseCount =\n\t\tle32_to_cpu(header.EraseCount);\n\t    xvalid++;\n\t} else {\n\t    if (xtrans == part->header.NumTransferUnits) {\n\t\tprintk(KERN_NOTICE \"ftl_cs: format error: too many \"\n\t\t       \"transfer units!\\n\");\n\t\tgoto out_XferInfo;\n\t    }\n\t    if (hdr_ok && (le16_to_cpu(header.LogicalEUN) == 0xffff)) {\n\t\tpart->XferInfo[xtrans].state = XFER_PREPARED;\n\t\tpart->XferInfo[xtrans].EraseCount = le32_to_cpu(header.EraseCount);\n\t    } else {\n\t\tpart->XferInfo[xtrans].state = XFER_UNKNOWN;\n\t\t \n\t\tpart->XferInfo[xtrans].EraseCount =\n\t\t    le32_to_cpu(part->header.EraseCount);\n\t    }\n\t    part->XferInfo[xtrans].Offset = offset;\n\t    xtrans++;\n\t}\n    }\n     \n    header = part->header;\n    if ((xtrans != header.NumTransferUnits) ||\n\t(xvalid+xtrans != le16_to_cpu(header.NumEraseUnits))) {\n\tprintk(KERN_NOTICE \"ftl_cs: format error: erase units \"\n\t       \"don't add up!\\n\");\n\tgoto out_XferInfo;\n    }\n\n     \n    blocks = le32_to_cpu(header.FormattedSize) >> header.BlockSize;\n    part->VirtualBlockMap = vmalloc(array_size(blocks, sizeof(uint32_t)));\n    if (!part->VirtualBlockMap)\n\t    goto out_XferInfo;\n\n    memset(part->VirtualBlockMap, 0xff, blocks * sizeof(uint32_t));\n    part->BlocksPerUnit = (1 << header.EraseUnitSize) >> header.BlockSize;\n\n    part->bam_cache = kmalloc_array(part->BlocksPerUnit, sizeof(uint32_t),\n                                    GFP_KERNEL);\n    if (!part->bam_cache)\n\t    goto out_VirtualBlockMap;\n\n    part->bam_index = 0xffff;\n    part->FreeTotal = 0;\n\n    for (i = 0; i < part->DataUnits; i++) {\n\tpart->EUNInfo[i].Free = 0;\n\tpart->EUNInfo[i].Deleted = 0;\n\toffset = part->EUNInfo[i].Offset + le32_to_cpu(header.BAMOffset);\n\n\tret = mtd_read(part->mbd.mtd, offset,\n                       part->BlocksPerUnit * sizeof(uint32_t), &retval,\n                       (unsigned char *)part->bam_cache);\n\n\tif (ret)\n\t\tgoto out_bam_cache;\n\n\tfor (j = 0; j < part->BlocksPerUnit; j++) {\n\t    if (BLOCK_FREE(le32_to_cpu(part->bam_cache[j]))) {\n\t\tpart->EUNInfo[i].Free++;\n\t\tpart->FreeTotal++;\n\t    } else if ((BLOCK_TYPE(le32_to_cpu(part->bam_cache[j])) == BLOCK_DATA) &&\n\t\t     (BLOCK_NUMBER(le32_to_cpu(part->bam_cache[j])) < blocks))\n\t\tpart->VirtualBlockMap[BLOCK_NUMBER(le32_to_cpu(part->bam_cache[j]))] =\n\t\t    (i << header.EraseUnitSize) + (j << header.BlockSize);\n\t    else if (BLOCK_DELETED(le32_to_cpu(part->bam_cache[j])))\n\t\tpart->EUNInfo[i].Deleted++;\n\t}\n    }\n\n    ret = 0;\n    goto out;\n\nout_bam_cache:\n    kfree(part->bam_cache);\nout_VirtualBlockMap:\n    vfree(part->VirtualBlockMap);\nout_XferInfo:\n    kfree(part->XferInfo);\nout_EUNInfo:\n    kfree(part->EUNInfo);\nout:\n    return ret;\n}  \n\n \n\nstatic int erase_xfer(partition_t *part,\n\t\t      uint16_t xfernum)\n{\n    int ret;\n    struct xfer_info_t *xfer;\n    struct erase_info *erase;\n\n    xfer = &part->XferInfo[xfernum];\n    pr_debug(\"ftl_cs: erasing xfer unit at 0x%x\\n\", xfer->Offset);\n    xfer->state = XFER_ERASING;\n\n     \n\n\n    erase=kmalloc(sizeof(struct erase_info), GFP_KERNEL);\n    if (!erase)\n            return -ENOMEM;\n\n    erase->addr = xfer->Offset;\n    erase->len = 1 << part->header.EraseUnitSize;\n\n    ret = mtd_erase(part->mbd.mtd, erase);\n    if (!ret) {\n\txfer->state = XFER_ERASED;\n\txfer->EraseCount++;\n    } else {\n\txfer->state = XFER_FAILED;\n\tpr_notice(\"ftl_cs: erase failed: err = %d\\n\", ret);\n    }\n\n    kfree(erase);\n\n    return ret;\n}  \n\n \n\nstatic int prepare_xfer(partition_t *part, int i)\n{\n    erase_unit_header_t header;\n    struct xfer_info_t *xfer;\n    int nbam, ret;\n    uint32_t ctl;\n    ssize_t retlen;\n    loff_t offset;\n\n    xfer = &part->XferInfo[i];\n    xfer->state = XFER_FAILED;\n\n    pr_debug(\"ftl_cs: preparing xfer unit at 0x%x\\n\", xfer->Offset);\n\n     \n    header = part->header;\n    header.LogicalEUN = cpu_to_le16(0xffff);\n    header.EraseCount = cpu_to_le32(xfer->EraseCount);\n\n    ret = mtd_write(part->mbd.mtd, xfer->Offset, sizeof(header), &retlen,\n                    (u_char *)&header);\n\n    if (ret) {\n\treturn ret;\n    }\n\n     \n    nbam = DIV_ROUND_UP(part->BlocksPerUnit * sizeof(uint32_t) +\n\t\t\tle32_to_cpu(part->header.BAMOffset), SECTOR_SIZE);\n\n    offset = xfer->Offset + le32_to_cpu(part->header.BAMOffset);\n    ctl = cpu_to_le32(BLOCK_CONTROL);\n\n    for (i = 0; i < nbam; i++, offset += sizeof(uint32_t)) {\n\n\tret = mtd_write(part->mbd.mtd, offset, sizeof(uint32_t), &retlen,\n                        (u_char *)&ctl);\n\n\tif (ret)\n\t    return ret;\n    }\n    xfer->state = XFER_PREPARED;\n    return 0;\n\n}  \n\n \n\nstatic int copy_erase_unit(partition_t *part, uint16_t srcunit,\n\t\t\t   uint16_t xferunit)\n{\n    u_char buf[SECTOR_SIZE];\n    struct eun_info_t *eun;\n    struct xfer_info_t *xfer;\n    uint32_t src, dest, free, i;\n    uint16_t unit;\n    int ret;\n    ssize_t retlen;\n    loff_t offset;\n    uint16_t srcunitswap = cpu_to_le16(srcunit);\n\n    eun = &part->EUNInfo[srcunit];\n    xfer = &part->XferInfo[xferunit];\n    pr_debug(\"ftl_cs: copying block 0x%x to 0x%x\\n\",\n\t  eun->Offset, xfer->Offset);\n\n\n     \n    if (part->bam_index != srcunit) {\n\n\toffset = eun->Offset + le32_to_cpu(part->header.BAMOffset);\n\n\tret = mtd_read(part->mbd.mtd, offset,\n                       part->BlocksPerUnit * sizeof(uint32_t), &retlen,\n                       (u_char *)(part->bam_cache));\n\n\t \n\tpart->bam_index = 0xffff;\n\n\tif (ret) {\n\t    printk( KERN_WARNING \"ftl: Failed to read BAM cache in copy_erase_unit()!\\n\");\n\t    return ret;\n\t}\n    }\n\n     \n    xfer->state = XFER_UNKNOWN;\n    offset = xfer->Offset + 20;  \n    unit = cpu_to_le16(0x7fff);\n\n    ret = mtd_write(part->mbd.mtd, offset, sizeof(uint16_t), &retlen,\n                    (u_char *)&unit);\n\n    if (ret) {\n\tprintk( KERN_WARNING \"ftl: Failed to write back to BAM cache in copy_erase_unit()!\\n\");\n\treturn ret;\n    }\n\n     \n    src = eun->Offset; dest = xfer->Offset;\n\n    free = 0;\n    ret = 0;\n    for (i = 0; i < part->BlocksPerUnit; i++) {\n\tswitch (BLOCK_TYPE(le32_to_cpu(part->bam_cache[i]))) {\n\tcase BLOCK_CONTROL:\n\t     \n\t    break;\n\tcase BLOCK_DATA:\n\tcase BLOCK_REPLACEMENT:\n\t    ret = mtd_read(part->mbd.mtd, src, SECTOR_SIZE, &retlen,\n                           (u_char *)buf);\n\t    if (ret) {\n\t\tprintk(KERN_WARNING \"ftl: Error reading old xfer unit in copy_erase_unit\\n\");\n\t\treturn ret;\n            }\n\n\n\t    ret = mtd_write(part->mbd.mtd, dest, SECTOR_SIZE, &retlen,\n                            (u_char *)buf);\n\t    if (ret)  {\n\t\tprintk(KERN_WARNING \"ftl: Error writing new xfer unit in copy_erase_unit\\n\");\n\t\treturn ret;\n            }\n\n\t    break;\n\tdefault:\n\t     \n\t    part->bam_cache[i] = cpu_to_le32(0xffffffff);\n\t    free++;\n\t    break;\n\t}\n\tsrc += SECTOR_SIZE;\n\tdest += SECTOR_SIZE;\n    }\n\n     \n    ret = mtd_write(part->mbd.mtd,\n                    xfer->Offset + le32_to_cpu(part->header.BAMOffset),\n                    part->BlocksPerUnit * sizeof(int32_t),\n                    &retlen,\n                    (u_char *)part->bam_cache);\n    if (ret) {\n\tprintk( KERN_WARNING \"ftl: Error writing BAM in copy_erase_unit\\n\");\n\treturn ret;\n    }\n\n\n     \n    ret = mtd_write(part->mbd.mtd, xfer->Offset + 20, sizeof(uint16_t),\n                    &retlen, (u_char *)&srcunitswap);\n\n    if (ret) {\n\tprintk(KERN_WARNING \"ftl: Error writing new LogicalEUN in copy_erase_unit\\n\");\n\treturn ret;\n    }\n\n\n     \n    swap(xfer->EraseCount, eun->EraseCount);\n    swap(xfer->Offset, eun->Offset);\n    part->FreeTotal -= eun->Free;\n    part->FreeTotal += free;\n    eun->Free = free;\n    eun->Deleted = 0;\n\n     \n    part->bam_index = srcunit;\n\n    return 0;\n}  \n\n \n\nstatic int reclaim_block(partition_t *part)\n{\n    uint16_t i, eun, xfer;\n    uint32_t best;\n    int queued, ret;\n\n    pr_debug(\"ftl_cs: reclaiming space...\\n\");\n    pr_debug(\"NumTransferUnits == %x\\n\", part->header.NumTransferUnits);\n     \n    best = 0xffffffff; xfer = 0xffff;\n    do {\n\tqueued = 0;\n\tfor (i = 0; i < part->header.NumTransferUnits; i++) {\n\t    int n=0;\n\t    if (part->XferInfo[i].state == XFER_UNKNOWN) {\n\t\tpr_debug(\"XferInfo[%d].state == XFER_UNKNOWN\\n\",i);\n\t\tn=1;\n\t\terase_xfer(part, i);\n\t    }\n\t    if (part->XferInfo[i].state == XFER_ERASING) {\n\t\tpr_debug(\"XferInfo[%d].state == XFER_ERASING\\n\",i);\n\t\tn=1;\n\t\tqueued = 1;\n\t    }\n\t    else if (part->XferInfo[i].state == XFER_ERASED) {\n\t\tpr_debug(\"XferInfo[%d].state == XFER_ERASED\\n\",i);\n\t\tn=1;\n\t\tprepare_xfer(part, i);\n\t    }\n\t    if (part->XferInfo[i].state == XFER_PREPARED) {\n\t\tpr_debug(\"XferInfo[%d].state == XFER_PREPARED\\n\",i);\n\t\tn=1;\n\t\tif (part->XferInfo[i].EraseCount <= best) {\n\t\t    best = part->XferInfo[i].EraseCount;\n\t\t    xfer = i;\n\t\t}\n\t    }\n\t\tif (!n)\n\t\t    pr_debug(\"XferInfo[%d].state == %x\\n\",i, part->XferInfo[i].state);\n\n\t}\n\tif (xfer == 0xffff) {\n\t    if (queued) {\n\t\tpr_debug(\"ftl_cs: waiting for transfer \"\n\t\t      \"unit to be prepared...\\n\");\n\t\tmtd_sync(part->mbd.mtd);\n\t    } else {\n\t\tstatic int ne = 0;\n\t\tif (++ne < 5)\n\t\t    printk(KERN_NOTICE \"ftl_cs: reclaim failed: no \"\n\t\t\t   \"suitable transfer units!\\n\");\n\t\telse\n\t\t    pr_debug(\"ftl_cs: reclaim failed: no \"\n\t\t\t  \"suitable transfer units!\\n\");\n\n\t\treturn -EIO;\n\t    }\n\t}\n    } while (xfer == 0xffff);\n\n    eun = 0;\n    if ((jiffies % shuffle_freq) == 0) {\n\tpr_debug(\"ftl_cs: recycling freshest block...\\n\");\n\tbest = 0xffffffff;\n\tfor (i = 0; i < part->DataUnits; i++)\n\t    if (part->EUNInfo[i].EraseCount <= best) {\n\t\tbest = part->EUNInfo[i].EraseCount;\n\t\teun = i;\n\t    }\n    } else {\n\tbest = 0;\n\tfor (i = 0; i < part->DataUnits; i++)\n\t    if (part->EUNInfo[i].Deleted >= best) {\n\t\tbest = part->EUNInfo[i].Deleted;\n\t\teun = i;\n\t    }\n\tif (best == 0) {\n\t    static int ne = 0;\n\t    if (++ne < 5)\n\t\tprintk(KERN_NOTICE \"ftl_cs: reclaim failed: \"\n\t\t       \"no free blocks!\\n\");\n\t    else\n\t\tpr_debug(\"ftl_cs: reclaim failed: \"\n\t\t       \"no free blocks!\\n\");\n\n\t    return -EIO;\n\t}\n    }\n    ret = copy_erase_unit(part, eun, xfer);\n    if (!ret)\n\terase_xfer(part, xfer);\n    else\n\tprintk(KERN_NOTICE \"ftl_cs: copy_erase_unit failed!\\n\");\n    return ret;\n}  \n\n \n\n#ifdef PSYCHO_DEBUG\nstatic void dump_lists(partition_t *part)\n{\n    int i;\n    printk(KERN_DEBUG \"ftl_cs: Free total = %d\\n\", part->FreeTotal);\n    for (i = 0; i < part->DataUnits; i++)\n\tprintk(KERN_DEBUG \"ftl_cs:   unit %d: %d phys, %d free, \"\n\t       \"%d deleted\\n\", i,\n\t       part->EUNInfo[i].Offset >> part->header.EraseUnitSize,\n\t       part->EUNInfo[i].Free, part->EUNInfo[i].Deleted);\n}\n#endif\n\nstatic uint32_t find_free(partition_t *part)\n{\n    uint16_t stop, eun;\n    uint32_t blk;\n    size_t retlen;\n    int ret;\n\n     \n    stop = (part->bam_index == 0xffff) ? 0 : part->bam_index;\n    eun = stop;\n    do {\n\tif (part->EUNInfo[eun].Free != 0) break;\n\t \n\tif (++eun == part->DataUnits) eun = 0;\n    } while (eun != stop);\n\n    if (part->EUNInfo[eun].Free == 0)\n\treturn 0;\n\n     \n    if (eun != part->bam_index) {\n\t \n\tpart->bam_index = 0xffff;\n\n\tret = mtd_read(part->mbd.mtd,\n                       part->EUNInfo[eun].Offset + le32_to_cpu(part->header.BAMOffset),\n                       part->BlocksPerUnit * sizeof(uint32_t),\n                       &retlen,\n                       (u_char *)(part->bam_cache));\n\n\tif (ret) {\n\t    printk(KERN_WARNING\"ftl: Error reading BAM in find_free\\n\");\n\t    return 0;\n\t}\n\tpart->bam_index = eun;\n    }\n\n     \n    for (blk = 0; blk < part->BlocksPerUnit; blk++)\n\tif (BLOCK_FREE(le32_to_cpu(part->bam_cache[blk]))) break;\n    if (blk == part->BlocksPerUnit) {\n#ifdef PSYCHO_DEBUG\n\tstatic int ne = 0;\n\tif (++ne == 1)\n\t    dump_lists(part);\n#endif\n\tprintk(KERN_NOTICE \"ftl_cs: bad free list!\\n\");\n\treturn 0;\n    }\n    pr_debug(\"ftl_cs: found free block at %d in %d\\n\", blk, eun);\n    return blk;\n\n}  \n\n\n \n\nstatic int ftl_read(partition_t *part, caddr_t buffer,\n\t\t    u_long sector, u_long nblocks)\n{\n    uint32_t log_addr, bsize;\n    u_long i;\n    int ret;\n    size_t offset, retlen;\n\n    pr_debug(\"ftl_cs: ftl_read(0x%p, 0x%lx, %ld)\\n\",\n\t  part, sector, nblocks);\n    if (!(part->state & FTL_FORMATTED)) {\n\tprintk(KERN_NOTICE \"ftl_cs: bad partition\\n\");\n\treturn -EIO;\n    }\n    bsize = 1 << part->header.EraseUnitSize;\n\n    for (i = 0; i < nblocks; i++) {\n\tif (((sector+i) * SECTOR_SIZE) >= le32_to_cpu(part->header.FormattedSize)) {\n\t    printk(KERN_NOTICE \"ftl_cs: bad read offset\\n\");\n\t    return -EIO;\n\t}\n\tlog_addr = part->VirtualBlockMap[sector+i];\n\tif (log_addr == 0xffffffff)\n\t    memset(buffer, 0, SECTOR_SIZE);\n\telse {\n\t    offset = (part->EUNInfo[log_addr / bsize].Offset\n\t\t\t  + (log_addr % bsize));\n\t    ret = mtd_read(part->mbd.mtd, offset, SECTOR_SIZE, &retlen,\n                           (u_char *)buffer);\n\n\t    if (ret) {\n\t\tprintk(KERN_WARNING \"Error reading MTD device in ftl_read()\\n\");\n\t\treturn ret;\n\t    }\n\t}\n\tbuffer += SECTOR_SIZE;\n    }\n    return 0;\n}  \n\n \n\nstatic int set_bam_entry(partition_t *part, uint32_t log_addr,\n\t\t\t uint32_t virt_addr)\n{\n    uint32_t bsize, blk, le_virt_addr;\n#ifdef PSYCHO_DEBUG\n    uint32_t old_addr;\n#endif\n    uint16_t eun;\n    int ret;\n    size_t retlen, offset;\n\n    pr_debug(\"ftl_cs: set_bam_entry(0x%p, 0x%x, 0x%x)\\n\",\n\t  part, log_addr, virt_addr);\n    bsize = 1 << part->header.EraseUnitSize;\n    eun = log_addr / bsize;\n    blk = (log_addr % bsize) / SECTOR_SIZE;\n    offset = (part->EUNInfo[eun].Offset + blk * sizeof(uint32_t) +\n\t\t  le32_to_cpu(part->header.BAMOffset));\n\n#ifdef PSYCHO_DEBUG\n    ret = mtd_read(part->mbd.mtd, offset, sizeof(uint32_t), &retlen,\n                   (u_char *)&old_addr);\n    if (ret) {\n\tprintk(KERN_WARNING\"ftl: Error reading old_addr in set_bam_entry: %d\\n\",ret);\n\treturn ret;\n    }\n    old_addr = le32_to_cpu(old_addr);\n\n    if (((virt_addr == 0xfffffffe) && !BLOCK_FREE(old_addr)) ||\n\t((virt_addr == 0) && (BLOCK_TYPE(old_addr) != BLOCK_DATA)) ||\n\t(!BLOCK_DELETED(virt_addr) && (old_addr != 0xfffffffe))) {\n\tstatic int ne = 0;\n\tif (++ne < 5) {\n\t    printk(KERN_NOTICE \"ftl_cs: set_bam_entry() inconsistency!\\n\");\n\t    printk(KERN_NOTICE \"ftl_cs:   log_addr = 0x%x, old = 0x%x\"\n\t\t   \", new = 0x%x\\n\", log_addr, old_addr, virt_addr);\n\t}\n\treturn -EIO;\n    }\n#endif\n    le_virt_addr = cpu_to_le32(virt_addr);\n    if (part->bam_index == eun) {\n#ifdef PSYCHO_DEBUG\n\tif (le32_to_cpu(part->bam_cache[blk]) != old_addr) {\n\t    static int ne = 0;\n\t    if (++ne < 5) {\n\t\tprintk(KERN_NOTICE \"ftl_cs: set_bam_entry() \"\n\t\t       \"inconsistency!\\n\");\n\t\tprintk(KERN_NOTICE \"ftl_cs:   log_addr = 0x%x, cache\"\n\t\t       \" = 0x%x\\n\",\n\t\t       le32_to_cpu(part->bam_cache[blk]), old_addr);\n\t    }\n\t    return -EIO;\n\t}\n#endif\n\tpart->bam_cache[blk] = le_virt_addr;\n    }\n    ret = mtd_write(part->mbd.mtd, offset, sizeof(uint32_t), &retlen,\n                    (u_char *)&le_virt_addr);\n\n    if (ret) {\n\tprintk(KERN_NOTICE \"ftl_cs: set_bam_entry() failed!\\n\");\n\tprintk(KERN_NOTICE \"ftl_cs:   log_addr = 0x%x, new = 0x%x\\n\",\n\t       log_addr, virt_addr);\n    }\n    return ret;\n}  \n\nstatic int ftl_write(partition_t *part, caddr_t buffer,\n\t\t     u_long sector, u_long nblocks)\n{\n    uint32_t bsize, log_addr, virt_addr, old_addr, blk;\n    u_long i;\n    int ret;\n    size_t retlen, offset;\n\n    pr_debug(\"ftl_cs: ftl_write(0x%p, %ld, %ld)\\n\",\n\t  part, sector, nblocks);\n    if (!(part->state & FTL_FORMATTED)) {\n\tprintk(KERN_NOTICE \"ftl_cs: bad partition\\n\");\n\treturn -EIO;\n    }\n     \n    while (part->FreeTotal < nblocks) {\n\tret = reclaim_block(part);\n\tif (ret)\n\t    return ret;\n    }\n\n    bsize = 1 << part->header.EraseUnitSize;\n\n    virt_addr = sector * SECTOR_SIZE | BLOCK_DATA;\n    for (i = 0; i < nblocks; i++) {\n\tif (virt_addr >= le32_to_cpu(part->header.FormattedSize)) {\n\t    printk(KERN_NOTICE \"ftl_cs: bad write offset\\n\");\n\t    return -EIO;\n\t}\n\n\t \n\tblk = find_free(part);\n\tif (blk == 0) {\n\t    static int ne = 0;\n\t    if (++ne < 5)\n\t\tprintk(KERN_NOTICE \"ftl_cs: internal error: \"\n\t\t       \"no free blocks!\\n\");\n\t    return -ENOSPC;\n\t}\n\n\t \n\tlog_addr = part->bam_index * bsize + blk * SECTOR_SIZE;\n\tpart->EUNInfo[part->bam_index].Free--;\n\tpart->FreeTotal--;\n\tif (set_bam_entry(part, log_addr, 0xfffffffe))\n\t    return -EIO;\n\tpart->EUNInfo[part->bam_index].Deleted++;\n\toffset = (part->EUNInfo[part->bam_index].Offset +\n\t\t      blk * SECTOR_SIZE);\n\tret = mtd_write(part->mbd.mtd, offset, SECTOR_SIZE, &retlen, buffer);\n\n\tif (ret) {\n\t    printk(KERN_NOTICE \"ftl_cs: block write failed!\\n\");\n\t    printk(KERN_NOTICE \"ftl_cs:   log_addr = 0x%x, virt_addr\"\n\t\t   \" = 0x%x, Offset = 0x%zx\\n\", log_addr, virt_addr,\n\t\t   offset);\n\t    return -EIO;\n\t}\n\n\t \n\told_addr = part->VirtualBlockMap[sector+i];\n\tif (old_addr != 0xffffffff) {\n\t    part->VirtualBlockMap[sector+i] = 0xffffffff;\n\t    part->EUNInfo[old_addr/bsize].Deleted++;\n\t    if (set_bam_entry(part, old_addr, 0))\n\t\treturn -EIO;\n\t}\n\n\t \n\tif (set_bam_entry(part, log_addr, virt_addr))\n\t    return -EIO;\n\tpart->VirtualBlockMap[sector+i] = log_addr;\n\tpart->EUNInfo[part->bam_index].Deleted--;\n\n\tbuffer += SECTOR_SIZE;\n\tvirt_addr += SECTOR_SIZE;\n    }\n    return 0;\n}  \n\nstatic int ftl_getgeo(struct mtd_blktrans_dev *dev, struct hd_geometry *geo)\n{\n\tpartition_t *part = container_of(dev, struct partition_t, mbd);\n\tu_long sect;\n\n\t \n\tsect = le32_to_cpu(part->header.FormattedSize)/SECTOR_SIZE;\n\n\tgeo->heads = 1;\n\tgeo->sectors = 8;\n\tgeo->cylinders = sect >> 3;\n\n\treturn 0;\n}\n\nstatic int ftl_readsect(struct mtd_blktrans_dev *dev,\n\t\t\t      unsigned long block, char *buf)\n{\n\treturn ftl_read((void *)dev, buf, block, 1);\n}\n\nstatic int ftl_writesect(struct mtd_blktrans_dev *dev,\n\t\t\t      unsigned long block, char *buf)\n{\n\treturn ftl_write((void *)dev, buf, block, 1);\n}\n\nstatic int ftl_discardsect(struct mtd_blktrans_dev *dev,\n\t\t\t   unsigned long sector, unsigned nr_sects)\n{\n\tpartition_t *part = container_of(dev, struct partition_t, mbd);\n\tuint32_t bsize = 1 << part->header.EraseUnitSize;\n\n\tpr_debug(\"FTL erase sector %ld for %d sectors\\n\",\n\t      sector, nr_sects);\n\n\twhile (nr_sects) {\n\t\tuint32_t old_addr = part->VirtualBlockMap[sector];\n\t\tif (old_addr != 0xffffffff) {\n\t\t\tpart->VirtualBlockMap[sector] = 0xffffffff;\n\t\t\tpart->EUNInfo[old_addr/bsize].Deleted++;\n\t\t\tif (set_bam_entry(part, old_addr, 0))\n\t\t\t\treturn -EIO;\n\t\t}\n\t\tnr_sects--;\n\t\tsector++;\n\t}\n\n\treturn 0;\n}\n \n\nstatic void ftl_freepart(partition_t *part)\n{\n\tvfree(part->VirtualBlockMap);\n\tpart->VirtualBlockMap = NULL;\n\tkfree(part->EUNInfo);\n\tpart->EUNInfo = NULL;\n\tkfree(part->XferInfo);\n\tpart->XferInfo = NULL;\n\tkfree(part->bam_cache);\n\tpart->bam_cache = NULL;\n}  \n\nstatic void ftl_add_mtd(struct mtd_blktrans_ops *tr, struct mtd_info *mtd)\n{\n\tpartition_t *partition;\n\n\tpartition = kzalloc(sizeof(partition_t), GFP_KERNEL);\n\n\tif (!partition) {\n\t\tprintk(KERN_WARNING \"No memory to scan for FTL on %s\\n\",\n\t\t       mtd->name);\n\t\treturn;\n\t}\n\n\tpartition->mbd.mtd = mtd;\n\n\tif ((scan_header(partition) == 0) &&\n\t    (build_maps(partition) == 0)) {\n\n\t\tpartition->state = FTL_FORMATTED;\n#ifdef PCMCIA_DEBUG\n\t\tprintk(KERN_INFO \"ftl_cs: opening %d KiB FTL partition\\n\",\n\t\t       le32_to_cpu(partition->header.FormattedSize) >> 10);\n#endif\n\t\tpartition->mbd.size = le32_to_cpu(partition->header.FormattedSize) >> 9;\n\n\t\tpartition->mbd.tr = tr;\n\t\tpartition->mbd.devnum = -1;\n\t\tif (!add_mtd_blktrans_dev(&partition->mbd))\n\t\t\treturn;\n\t}\n\n\tkfree(partition);\n}\n\nstatic void ftl_remove_dev(struct mtd_blktrans_dev *dev)\n{\n\tdel_mtd_blktrans_dev(dev);\n\tftl_freepart((partition_t *)dev);\n}\n\nstatic struct mtd_blktrans_ops ftl_tr = {\n\t.name\t\t= \"ftl\",\n\t.major\t\t= FTL_MAJOR,\n\t.part_bits\t= PART_BITS,\n\t.blksize \t= SECTOR_SIZE,\n\t.readsect\t= ftl_readsect,\n\t.writesect\t= ftl_writesect,\n\t.discard\t= ftl_discardsect,\n\t.getgeo\t\t= ftl_getgeo,\n\t.add_mtd\t= ftl_add_mtd,\n\t.remove_dev\t= ftl_remove_dev,\n\t.owner\t\t= THIS_MODULE,\n};\n\nmodule_mtd_blktrans(ftl_tr);\n\nMODULE_LICENSE(\"Dual MPL/GPL\");\nMODULE_AUTHOR(\"David Hinds <dahinds@users.sourceforge.net>\");\nMODULE_DESCRIPTION(\"Support code for Flash Translation Layer, used on PCMCIA devices\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}