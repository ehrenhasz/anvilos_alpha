{
  "module_name": "scx200_docflash.c",
  "hash_id": "e40f81c7b7207b963660258869fc0f5e12cbbb1fd70b82364c28d9d33c125a47",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/maps/scx200_docflash.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <asm/io.h>\n#include <linux/mtd/mtd.h>\n#include <linux/mtd/map.h>\n#include <linux/mtd/partitions.h>\n\n#include <linux/pci.h>\n#include <linux/scx200.h>\n\n#define NAME \"scx200_docflash\"\n\nMODULE_AUTHOR(\"Christer Weinigel <wingel@hack.org>\");\nMODULE_DESCRIPTION(\"NatSemi SCx200 DOCCS Flash Driver\");\nMODULE_LICENSE(\"GPL\");\n\nstatic int probe = 0;\t\t \nstatic unsigned size = 0x1000000;  \nstatic unsigned width = 8;\t \nstatic char *flashtype = \"cfi_probe\";\n\nmodule_param(probe, int, 0);\nMODULE_PARM_DESC(probe, \"Probe for a BIOS mapping\");\nmodule_param(size, int, 0);\nMODULE_PARM_DESC(size, \"Size of the flash mapping\");\nmodule_param(width, int, 0);\nMODULE_PARM_DESC(width, \"Data width of the flash mapping (8/16)\");\nmodule_param(flashtype, charp, 0);\nMODULE_PARM_DESC(flashtype, \"Type of MTD probe to do\");\n\nstatic struct resource docmem = {\n\t.flags = IORESOURCE_MEM,\n\t.name  = \"NatSemi SCx200 DOCCS Flash\",\n};\n\nstatic struct mtd_info *mymtd;\n\nstatic struct mtd_partition partition_info[] = {\n\t{\n\t\t.name   = \"DOCCS Boot kernel\",\n\t\t.offset = 0,\n\t\t.size   = 0xc0000\n\t},\n\t{\n\t\t.name   = \"DOCCS Low BIOS\",\n\t\t.offset = 0xc0000,\n\t\t.size   = 0x40000\n\t},\n\t{\n\t\t.name   = \"DOCCS File system\",\n\t\t.offset = 0x100000,\n\t\t.size   = ~0\t \n\t},\n\t{\n\t\t.name   = \"DOCCS High BIOS\",\n\t\t.offset = ~0, \t \n\t\t.size   = 0x80000\n\t},\n};\n#define NUM_PARTITIONS ARRAY_SIZE(partition_info)\n\nstatic struct map_info scx200_docflash_map = {\n\t.name      = \"NatSemi SCx200 DOCCS Flash\",\n};\n\nstatic int __init init_scx200_docflash(void)\n{\n\tunsigned u;\n\tunsigned base;\n\tunsigned ctrl;\n\tunsigned pmr;\n\tstruct pci_dev *bridge;\n\n\tprintk(KERN_DEBUG NAME \": NatSemi SCx200 DOCCS Flash Driver\\n\");\n\n\tif ((bridge = pci_get_device(PCI_VENDOR_ID_NS,\n\t\t\t\t      PCI_DEVICE_ID_NS_SCx200_BRIDGE,\n\t\t\t\t      NULL)) == NULL)\n\t\treturn -ENODEV;\n\n\t \n\tif (!scx200_cb_present()) {\n\t\tpci_dev_put(bridge);\n\t\treturn -ENODEV;\n\t}\n\n\tif (probe) {\n\t\t \n\t\tpci_read_config_dword(bridge, SCx200_DOCCS_BASE, &base);\n\t\tpci_read_config_dword(bridge, SCx200_DOCCS_CTRL, &ctrl);\n\t\tpci_dev_put(bridge);\n\n\t\tpmr = inl(scx200_cb_base + SCx200_PMR);\n\n\t\tif (base == 0\n\t\t    || (ctrl & 0x07000000) != 0x07000000\n\t\t    || (ctrl & 0x0007ffff) == 0)\n\t\t\treturn -ENODEV;\n\n\t\tsize = ((ctrl&0x1fff)<<13) + (1<<13);\n\n\t\tfor (u = size; u > 1; u >>= 1)\n\t\t\t;\n\t\tif (u != 1)\n\t\t\treturn -ENODEV;\n\n\t\tif (pmr & (1<<6))\n\t\t\twidth = 16;\n\t\telse\n\t\t\twidth = 8;\n\n\t\tdocmem.start = base;\n\t\tdocmem.end = base + size;\n\n\t\tif (request_resource(&iomem_resource, &docmem)) {\n\t\t\tprintk(KERN_ERR NAME \": unable to allocate memory for flash mapping\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\t} else {\n\t\tpci_dev_put(bridge);\n\t\tfor (u = size; u > 1; u >>= 1)\n\t\t\t;\n\t\tif (u != 1) {\n\t\t\tprintk(KERN_ERR NAME \": invalid size for flash mapping\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (width != 8 && width != 16) {\n\t\t\tprintk(KERN_ERR NAME \": invalid bus width for flash mapping\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (allocate_resource(&iomem_resource, &docmem,\n\t\t\t\t      size,\n\t\t\t\t      0xc0000000, 0xffffffff,\n\t\t\t\t      size, NULL, NULL)) {\n\t\t\tprintk(KERN_ERR NAME \": unable to allocate memory for flash mapping\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tctrl = 0x07000000 | ((size-1) >> 13);\n\n\t\tprintk(KERN_INFO \"DOCCS BASE=0x%08lx, CTRL=0x%08lx\\n\", (long)docmem.start, (long)ctrl);\n\n\t\tpci_write_config_dword(bridge, SCx200_DOCCS_BASE, docmem.start);\n\t\tpci_write_config_dword(bridge, SCx200_DOCCS_CTRL, ctrl);\n\t\tpmr = inl(scx200_cb_base + SCx200_PMR);\n\n\t\tif (width == 8) {\n\t\t\tpmr &= ~(1<<6);\n\t\t} else {\n\t\t\tpmr |= (1<<6);\n\t\t}\n\t\toutl(pmr, scx200_cb_base + SCx200_PMR);\n\t}\n\n\tprintk(KERN_INFO NAME \": DOCCS mapped at %pR, width %d\\n\",\n\t       &docmem, width);\n\n\tscx200_docflash_map.size = size;\n\tif (width == 8)\n\t\tscx200_docflash_map.bankwidth = 1;\n\telse\n\t\tscx200_docflash_map.bankwidth = 2;\n\n\tsimple_map_init(&scx200_docflash_map);\n\n\tscx200_docflash_map.phys = docmem.start;\n\tscx200_docflash_map.virt = ioremap(docmem.start, scx200_docflash_map.size);\n\tif (!scx200_docflash_map.virt) {\n\t\tprintk(KERN_ERR NAME \": failed to ioremap the flash\\n\");\n\t\trelease_resource(&docmem);\n\t\treturn -EIO;\n\t}\n\n\tmymtd = do_map_probe(flashtype, &scx200_docflash_map);\n\tif (!mymtd) {\n\t\tprintk(KERN_ERR NAME \": unable to detect flash\\n\");\n\t\tiounmap(scx200_docflash_map.virt);\n\t\trelease_resource(&docmem);\n\t\treturn -ENXIO;\n\t}\n\n\tif (size < mymtd->size)\n\t\tprintk(KERN_WARNING NAME \": warning, flash mapping is smaller than flash size\\n\");\n\n\tmymtd->owner = THIS_MODULE;\n\n\tpartition_info[3].offset = mymtd->size-partition_info[3].size;\n\tpartition_info[2].size = partition_info[3].offset-partition_info[2].offset;\n\tmtd_device_register(mymtd, partition_info, NUM_PARTITIONS);\n\n\treturn 0;\n}\n\nstatic void __exit cleanup_scx200_docflash(void)\n{\n\tif (mymtd) {\n\t\tmtd_device_unregister(mymtd);\n\t\tmap_destroy(mymtd);\n\t}\n\tif (scx200_docflash_map.virt) {\n\t\tiounmap(scx200_docflash_map.virt);\n\t\trelease_resource(&docmem);\n\t}\n}\n\nmodule_init(init_scx200_docflash);\nmodule_exit(cleanup_scx200_docflash);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}