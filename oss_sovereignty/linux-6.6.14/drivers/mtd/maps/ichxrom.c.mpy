{
  "module_name": "ichxrom.c",
  "hash_id": "058f5419751e4e44bc95f5ab283a8a8fbf500e359e0daafd1b5cc638db0e99d7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/maps/ichxrom.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <asm/io.h>\n#include <linux/mtd/mtd.h>\n#include <linux/mtd/map.h>\n#include <linux/mtd/cfi.h>\n#include <linux/mtd/flashchip.h>\n#include <linux/pci.h>\n#include <linux/pci_ids.h>\n#include <linux/list.h>\n\n#define xstr(s) str(s)\n#define str(s) #s\n#define MOD_NAME xstr(KBUILD_BASENAME)\n\n#define ADDRESS_NAME_LEN 18\n\n#define ROM_PROBE_STEP_SIZE (64*1024)  \n\n#define BIOS_CNTL\t0x4e\n#define FWH_DEC_EN1\t0xE3\n#define FWH_DEC_EN2\t0xF0\n#define FWH_SEL1\t0xE8\n#define FWH_SEL2\t0xEE\n\nstruct ichxrom_window {\n\tvoid __iomem* virt;\n\tunsigned long phys;\n\tunsigned long size;\n\tstruct list_head maps;\n\tstruct resource rsrc;\n\tstruct pci_dev *pdev;\n};\n\nstruct ichxrom_map_info {\n\tstruct list_head list;\n\tstruct map_info map;\n\tstruct mtd_info *mtd;\n\tstruct resource rsrc;\n\tchar map_name[sizeof(MOD_NAME) + 2 + ADDRESS_NAME_LEN];\n};\n\nstatic struct ichxrom_window ichxrom_window = {\n\t.maps = LIST_HEAD_INIT(ichxrom_window.maps),\n};\n\nstatic void ichxrom_cleanup(struct ichxrom_window *window)\n{\n\tstruct ichxrom_map_info *map, *scratch;\n\tu16 word;\n\tint ret;\n\n\t \n\tret = pci_read_config_word(window->pdev, BIOS_CNTL, &word);\n\tif (!ret)\n\t\tpci_write_config_word(window->pdev, BIOS_CNTL, word & ~1);\n\tpci_dev_put(window->pdev);\n\n\t \n\tlist_for_each_entry_safe(map, scratch, &window->maps, list) {\n\t\tif (map->rsrc.parent)\n\t\t\trelease_resource(&map->rsrc);\n\t\tmtd_device_unregister(map->mtd);\n\t\tmap_destroy(map->mtd);\n\t\tlist_del(&map->list);\n\t\tkfree(map);\n\t}\n\tif (window->rsrc.parent)\n\t\trelease_resource(&window->rsrc);\n\tif (window->virt) {\n\t\tiounmap(window->virt);\n\t\twindow->virt = NULL;\n\t\twindow->phys = 0;\n\t\twindow->size = 0;\n\t\twindow->pdev = NULL;\n\t}\n}\n\n\nstatic int __init ichxrom_init_one(struct pci_dev *pdev,\n\t\t\t\t   const struct pci_device_id *ent)\n{\n\tstatic char *rom_probe_types[] = { \"cfi_probe\", \"jedec_probe\", NULL };\n\tstruct ichxrom_window *window = &ichxrom_window;\n\tstruct ichxrom_map_info *map = NULL;\n\tunsigned long map_top;\n\tu8 byte;\n\tu16 word;\n\n\t \n\twindow->pdev = pdev;\n\n\t \n\twindow->phys = 0;\n\tpci_read_config_byte(pdev, FWH_DEC_EN1, &byte);\n\tif (byte == 0xff) {\n\t\twindow->phys = 0xffc00000;\n\t\tpci_read_config_byte(pdev, FWH_DEC_EN2, &byte);\n\t\tif ((byte & 0x0f) == 0x0f) {\n\t\t\twindow->phys = 0xff400000;\n\t\t}\n\t\telse if ((byte & 0x0e) == 0x0e) {\n\t\t\twindow->phys = 0xff500000;\n\t\t}\n\t\telse if ((byte & 0x0c) == 0x0c) {\n\t\t\twindow->phys = 0xff600000;\n\t\t}\n\t\telse if ((byte & 0x08) == 0x08) {\n\t\t\twindow->phys = 0xff700000;\n\t\t}\n\t}\n\telse if ((byte & 0xfe) == 0xfe) {\n\t\twindow->phys = 0xffc80000;\n\t}\n\telse if ((byte & 0xfc) == 0xfc) {\n\t\twindow->phys = 0xffd00000;\n\t}\n\telse if ((byte & 0xf8) == 0xf8) {\n\t\twindow->phys = 0xffd80000;\n\t}\n\telse if ((byte & 0xf0) == 0xf0) {\n\t\twindow->phys = 0xffe00000;\n\t}\n\telse if ((byte & 0xe0) == 0xe0) {\n\t\twindow->phys = 0xffe80000;\n\t}\n\telse if ((byte & 0xc0) == 0xc0) {\n\t\twindow->phys = 0xfff00000;\n\t}\n\telse if ((byte & 0x80) == 0x80) {\n\t\twindow->phys = 0xfff80000;\n\t}\n\n\tif (window->phys == 0) {\n\t\tprintk(KERN_ERR MOD_NAME \": Rom window is closed\\n\");\n\t\tgoto out;\n\t}\n\twindow->phys -= 0x400000UL;\n\twindow->size = (0xffffffffUL - window->phys) + 1UL;\n\n\t \n\tpci_read_config_word(pdev, BIOS_CNTL, &word);\n\tif (!(word & 1)  && (word & (1<<1))) {\n\t\t \n\t\tprintk(KERN_ERR MOD_NAME \": firmware access control, I can't enable writes\\n\");\n\t\tgoto out;\n\t}\n\tpci_write_config_word(pdev, BIOS_CNTL, word | 1);\n\n\t \n\twindow->rsrc.name = MOD_NAME;\n\twindow->rsrc.start = window->phys;\n\twindow->rsrc.end   = window->phys + window->size - 1;\n\twindow->rsrc.flags = IORESOURCE_MEM | IORESOURCE_BUSY;\n\tif (request_resource(&iomem_resource, &window->rsrc)) {\n\t\twindow->rsrc.parent = NULL;\n\t\tprintk(KERN_DEBUG MOD_NAME \": \"\n\t\t       \"%s(): Unable to register resource %pR - kernel bug?\\n\",\n\t\t       __func__, &window->rsrc);\n\t}\n\n\t \n\twindow->virt = ioremap(window->phys, window->size);\n\tif (!window->virt) {\n\t\tprintk(KERN_ERR MOD_NAME \": ioremap(%08lx, %08lx) failed\\n\",\n\t\t\twindow->phys, window->size);\n\t\tgoto out;\n\t}\n\n\t \n\tmap_top = window->phys;\n\tif ((window->phys & 0x3fffff) != 0) {\n\t\tmap_top = window->phys + 0x400000;\n\t}\n#if 1\n\t \n\tif (map_top < 0xffc00000) {\n\t\tmap_top = 0xffc00000;\n\t}\n#endif\n\t \n\twhile((map_top - 1) < 0xffffffffUL) {\n\t\tstruct cfi_private *cfi;\n\t\tunsigned long offset;\n\t\tint i;\n\n\t\tif (!map) {\n\t\t\tmap = kmalloc(sizeof(*map), GFP_KERNEL);\n\t\t\tif (!map)\n\t\t\t\tgoto out;\n\t\t}\n\t\tmemset(map, 0, sizeof(*map));\n\t\tINIT_LIST_HEAD(&map->list);\n\t\tmap->map.name = map->map_name;\n\t\tmap->map.phys = map_top;\n\t\toffset = map_top - window->phys;\n\t\tmap->map.virt = (void __iomem *)\n\t\t\t(((unsigned long)(window->virt)) + offset);\n\t\tmap->map.size = 0xffffffffUL - map_top + 1UL;\n\t\t \n\t\tsprintf(map->map_name, \"%s @%08Lx\",\n\t\t\tMOD_NAME, (unsigned long long)map->map.phys);\n\n\t\t \n\t\tfor(map->map.bankwidth = 32; map->map.bankwidth;\n\t\t\tmap->map.bankwidth >>= 1)\n\t\t{\n\t\t\tchar **probe_type;\n\t\t\t \n\t\t\tif (!map_bankwidth_supported(map->map.bankwidth))\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tsimple_map_init(&map->map);\n\n\t\t\t \n\t\t\tprobe_type = rom_probe_types;\n\t\t\tfor(; *probe_type; probe_type++) {\n\t\t\t\tmap->mtd = do_map_probe(*probe_type, &map->map);\n\t\t\t\tif (map->mtd)\n\t\t\t\t\tgoto found;\n\t\t\t}\n\t\t}\n\t\tmap_top += ROM_PROBE_STEP_SIZE;\n\t\tcontinue;\n\tfound:\n\t\t \n\t\tif (map->mtd->size > map->map.size) {\n\t\t\tprintk(KERN_WARNING MOD_NAME\n\t\t\t\t\" rom(%llu) larger than window(%lu). fixing...\\n\",\n\t\t\t\t(unsigned long long)map->mtd->size, map->map.size);\n\t\t\tmap->mtd->size = map->map.size;\n\t\t}\n\t\tif (window->rsrc.parent) {\n\t\t\t \n\t\t\tmap->rsrc.name  = map->map_name;\n\t\t\tmap->rsrc.start = map->map.phys;\n\t\t\tmap->rsrc.end   = map->map.phys + map->mtd->size - 1;\n\t\t\tmap->rsrc.flags = IORESOURCE_MEM | IORESOURCE_BUSY;\n\t\t\tif (request_resource(&window->rsrc, &map->rsrc)) {\n\t\t\t\tprintk(KERN_ERR MOD_NAME\n\t\t\t\t\t\": cannot reserve MTD resource\\n\");\n\t\t\t\tmap->rsrc.parent = NULL;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tmap->map.virt = window->virt;\n\t\tmap->map.phys = window->phys;\n\t\tcfi = map->map.fldrv_priv;\n\t\tfor(i = 0; i < cfi->numchips; i++) {\n\t\t\tcfi->chips[i].start += offset;\n\t\t}\n\n\t\t \n\t\tmap->mtd->owner = THIS_MODULE;\n\t\tif (mtd_device_register(map->mtd, NULL, 0)) {\n\t\t\tmap_destroy(map->mtd);\n\t\t\tmap->mtd = NULL;\n\t\t\tgoto out;\n\t\t}\n\n\n\t\t \n\t\tmap_top += map->mtd->size;\n\n\t\t \n\t\tlist_add(&map->list, &window->maps);\n\t\tmap = NULL;\n\t}\n\n out:\n\t \n\tkfree(map);\n\n\t \n\tif (list_empty(&window->maps)) {\n\t\tichxrom_cleanup(window);\n\t\treturn -ENODEV;\n\t}\n\treturn 0;\n}\n\n\nstatic void ichxrom_remove_one(struct pci_dev *pdev)\n{\n\tstruct ichxrom_window *window = &ichxrom_window;\n\tichxrom_cleanup(window);\n}\n\nstatic const struct pci_device_id ichxrom_pci_tbl[] = {\n\t{ PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_82801BA_0,\n\t  PCI_ANY_ID, PCI_ANY_ID, },\n\t{ PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_82801CA_0,\n\t  PCI_ANY_ID, PCI_ANY_ID, },\n\t{ PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_82801DB_0,\n\t  PCI_ANY_ID, PCI_ANY_ID, },\n\t{ PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_82801EB_0,\n\t  PCI_ANY_ID, PCI_ANY_ID, },\n\t{ PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_ESB_1,\n\t  PCI_ANY_ID, PCI_ANY_ID, },\n\t{ 0, },\n};\n\n#if 0\nMODULE_DEVICE_TABLE(pci, ichxrom_pci_tbl);\n\nstatic struct pci_driver ichxrom_driver = {\n\t.name =\t\tMOD_NAME,\n\t.id_table =\tichxrom_pci_tbl,\n\t.probe =\tichxrom_init_one,\n\t.remove =\tichxrom_remove_one,\n};\n#endif\n\nstatic int __init init_ichxrom(void)\n{\n\tstruct pci_dev *pdev;\n\tconst struct pci_device_id *id;\n\n\tpdev = NULL;\n\tfor (id = ichxrom_pci_tbl; id->vendor; id++) {\n\t\tpdev = pci_get_device(id->vendor, id->device, NULL);\n\t\tif (pdev) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (pdev) {\n\t\treturn ichxrom_init_one(pdev, &ichxrom_pci_tbl[0]);\n\t}\n\treturn -ENXIO;\n#if 0\n\treturn pci_register_driver(&ichxrom_driver);\n#endif\n}\n\nstatic void __exit cleanup_ichxrom(void)\n{\n\tichxrom_remove_one(ichxrom_window.pdev);\n}\n\nmodule_init(init_ichxrom);\nmodule_exit(cleanup_ichxrom);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Eric Biederman <ebiederman@lnxi.com>\");\nMODULE_DESCRIPTION(\"MTD map driver for BIOS chips on the ICHX southbridge\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}