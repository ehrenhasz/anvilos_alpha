{
  "module_name": "pci.c",
  "hash_id": "69ffbff1d29c245f50788f2ec224346921674632ed37d84fa5ad005bf3486ca9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/maps/pci.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/pci.h>\n#include <linux/slab.h>\n\n#include <linux/mtd/mtd.h>\n#include <linux/mtd/map.h>\n#include <linux/mtd/partitions.h>\n\nstruct map_pci_info;\n\nstruct mtd_pci_info {\n\tint  (*init)(struct pci_dev *dev, struct map_pci_info *map);\n\tvoid (*exit)(struct pci_dev *dev, struct map_pci_info *map);\n\tunsigned long (*translate)(struct map_pci_info *map, unsigned long ofs);\n\tconst char *map_name;\n};\n\nstruct map_pci_info {\n\tstruct map_info map;\n\tvoid __iomem *base;\n\tvoid (*exit)(struct pci_dev *dev, struct map_pci_info *map);\n\tunsigned long (*translate)(struct map_pci_info *map, unsigned long ofs);\n\tstruct pci_dev *dev;\n};\n\nstatic map_word mtd_pci_read8(struct map_info *_map, unsigned long ofs)\n{\n\tstruct map_pci_info *map = (struct map_pci_info *)_map;\n\tmap_word val;\n\tval.x[0]= readb(map->base + map->translate(map, ofs));\n\treturn val;\n}\n\nstatic map_word mtd_pci_read32(struct map_info *_map, unsigned long ofs)\n{\n\tstruct map_pci_info *map = (struct map_pci_info *)_map;\n\tmap_word val;\n\tval.x[0] = readl(map->base + map->translate(map, ofs));\n\treturn val;\n}\n\nstatic void mtd_pci_copyfrom(struct map_info *_map, void *to, unsigned long from, ssize_t len)\n{\n\tstruct map_pci_info *map = (struct map_pci_info *)_map;\n\tmemcpy_fromio(to, map->base + map->translate(map, from), len);\n}\n\nstatic void mtd_pci_write8(struct map_info *_map, map_word val, unsigned long ofs)\n{\n\tstruct map_pci_info *map = (struct map_pci_info *)_map;\n\twriteb(val.x[0], map->base + map->translate(map, ofs));\n}\n\nstatic void mtd_pci_write32(struct map_info *_map, map_word val, unsigned long ofs)\n{\n\tstruct map_pci_info *map = (struct map_pci_info *)_map;\n\twritel(val.x[0], map->base + map->translate(map, ofs));\n}\n\nstatic void mtd_pci_copyto(struct map_info *_map, unsigned long to, const void *from, ssize_t len)\n{\n\tstruct map_pci_info *map = (struct map_pci_info *)_map;\n\tmemcpy_toio(map->base + map->translate(map, to), from, len);\n}\n\nstatic const struct map_info mtd_pci_map = {\n\t.phys =\t\tNO_XIP,\n\t.copy_from =\tmtd_pci_copyfrom,\n\t.copy_to =\tmtd_pci_copyto,\n};\n\n \n\nstatic int\nintel_iq80310_init(struct pci_dev *dev, struct map_pci_info *map)\n{\n\tu32 win_base;\n\n\tmap->map.bankwidth = 1;\n\tmap->map.read = mtd_pci_read8;\n\tmap->map.write = mtd_pci_write8;\n\n\tmap->map.size     = 0x00800000;\n\tmap->base         = ioremap(pci_resource_start(dev, 0),\n\t\t\t\t\t    pci_resource_len(dev, 0));\n\n\tif (!map->base)\n\t\treturn -ENOMEM;\n\n\t \n\tpci_read_config_dword(dev, 0x44, &win_base);\n\tpci_write_config_dword(dev, 0x44, 0);\n\n\tmap->map.map_priv_2 = win_base;\n\n\treturn 0;\n}\n\nstatic void\nintel_iq80310_exit(struct pci_dev *dev, struct map_pci_info *map)\n{\n\tif (map->base)\n\t\tiounmap(map->base);\n\tpci_write_config_dword(dev, 0x44, map->map.map_priv_2);\n}\n\nstatic unsigned long\nintel_iq80310_translate(struct map_pci_info *map, unsigned long ofs)\n{\n\tunsigned long page_addr = ofs & 0x00400000;\n\n\t \n\tif (page_addr) {\n\t\twritel(0x00000008, map->base + 0x1558);\n\t\twritel(0x00000000, map->base + 0x1550);\n\t} else {\n\t\twritel(0x00000007, map->base + 0x1558);\n\t\twritel(0x00800000, map->base + 0x1550);\n\t\tofs += 0x00800000;\n\t}\n\n\treturn ofs;\n}\n\nstatic struct mtd_pci_info intel_iq80310_info = {\n\t.init =\t\tintel_iq80310_init,\n\t.exit =\t\tintel_iq80310_exit,\n\t.translate =\tintel_iq80310_translate,\n\t.map_name =\t\"cfi_probe\",\n};\n\n \n\nstatic int\nintel_dc21285_init(struct pci_dev *dev, struct map_pci_info *map)\n{\n\tunsigned long base, len;\n\n\tbase = pci_resource_start(dev, PCI_ROM_RESOURCE);\n\tlen  = pci_resource_len(dev, PCI_ROM_RESOURCE);\n\n\tif (!len || !base) {\n\t\t \n\t\tbase = pci_resource_start(dev, 2);\n\t\tlen  = pci_resource_len(dev, 2);\n\n\t\t \n\t} else {\n\t\t \n\t\tpci_enable_rom(dev);\n\t\tprintk(\"%s: enabling expansion ROM\\n\", pci_name(dev));\n\t}\n\n\tif (!len || !base)\n\t\treturn -ENXIO;\n\n\tmap->map.bankwidth = 4;\n\tmap->map.read = mtd_pci_read32;\n\tmap->map.write = mtd_pci_write32;\n\tmap->map.size     = len;\n\tmap->base         = ioremap(base, len);\n\n\tif (!map->base)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic void\nintel_dc21285_exit(struct pci_dev *dev, struct map_pci_info *map)\n{\n\tif (map->base)\n\t\tiounmap(map->base);\n\n\t \n\tpci_disable_rom(dev);\n}\n\nstatic unsigned long\nintel_dc21285_translate(struct map_pci_info *map, unsigned long ofs)\n{\n\treturn ofs & 0x00ffffc0 ? ofs : (ofs ^ (1 << 5));\n}\n\nstatic struct mtd_pci_info intel_dc21285_info = {\n\t.init =\t\tintel_dc21285_init,\n\t.exit =\t\tintel_dc21285_exit,\n\t.translate =\tintel_dc21285_translate,\n\t.map_name =\t\"jedec_probe\",\n};\n\n \n\nstatic const struct pci_device_id mtd_pci_ids[] = {\n\t{\n\t\t.vendor =\tPCI_VENDOR_ID_INTEL,\n\t\t.device =\t0x530d,\n\t\t.subvendor =\tPCI_ANY_ID,\n\t\t.subdevice =\tPCI_ANY_ID,\n\t\t.class =\tPCI_CLASS_MEMORY_OTHER << 8,\n\t\t.class_mask =\t0xffff00,\n\t\t.driver_data =\t(unsigned long)&intel_iq80310_info,\n\t},\n\t{\n\t\t.vendor =\tPCI_VENDOR_ID_DEC,\n\t\t.device =\tPCI_DEVICE_ID_DEC_21285,\n\t\t.subvendor =\t0,\t \n\t\t.subdevice =\t0,\t \n\t\t.driver_data =\t(unsigned long)&intel_dc21285_info,\n\t},\n\t{ 0, }\n};\n\n \n\nstatic int mtd_pci_probe(struct pci_dev *dev, const struct pci_device_id *id)\n{\n\tstruct mtd_pci_info *info = (struct mtd_pci_info *)id->driver_data;\n\tstruct map_pci_info *map = NULL;\n\tstruct mtd_info *mtd = NULL;\n\tint err;\n\n\terr = pci_enable_device(dev);\n\tif (err)\n\t\tgoto out;\n\n\terr = pci_request_regions(dev, \"pci mtd\");\n\tif (err)\n\t\tgoto out;\n\n\tmap = kmalloc(sizeof(*map), GFP_KERNEL);\n\terr = -ENOMEM;\n\tif (!map)\n\t\tgoto release;\n\n\tmap->map       = mtd_pci_map;\n\tmap->map.name  = pci_name(dev);\n\tmap->dev       = dev;\n\tmap->exit      = info->exit;\n\tmap->translate = info->translate;\n\n\terr = info->init(dev, map);\n\tif (err)\n\t\tgoto release;\n\n\tmtd = do_map_probe(info->map_name, &map->map);\n\terr = -ENODEV;\n\tif (!mtd)\n\t\tgoto release;\n\n\tmtd->owner = THIS_MODULE;\n\tmtd_device_register(mtd, NULL, 0);\n\n\tpci_set_drvdata(dev, mtd);\n\n\treturn 0;\n\nrelease:\n\tif (map) {\n\t\tmap->exit(dev, map);\n\t\tkfree(map);\n\t}\n\n\tpci_release_regions(dev);\nout:\n\treturn err;\n}\n\nstatic void mtd_pci_remove(struct pci_dev *dev)\n{\n\tstruct mtd_info *mtd = pci_get_drvdata(dev);\n\tstruct map_pci_info *map = mtd->priv;\n\n\tmtd_device_unregister(mtd);\n\tmap_destroy(mtd);\n\tmap->exit(dev, map);\n\tkfree(map);\n\n\tpci_release_regions(dev);\n}\n\nstatic struct pci_driver mtd_pci_driver = {\n\t.name =\t\t\"MTD PCI\",\n\t.probe =\tmtd_pci_probe,\n\t.remove =\tmtd_pci_remove,\n\t.id_table =\tmtd_pci_ids,\n};\n\nmodule_pci_driver(mtd_pci_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Russell King <rmk@arm.linux.org.uk>\");\nMODULE_DESCRIPTION(\"Generic PCI map driver\");\nMODULE_DEVICE_TABLE(pci, mtd_pci_ids);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}