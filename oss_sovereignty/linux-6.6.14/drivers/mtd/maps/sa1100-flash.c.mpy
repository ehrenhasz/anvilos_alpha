{
  "module_name": "sa1100-flash.c",
  "hash_id": "3de92d17d8da9e010e3857d6b7b50b519883955add68f37d1e42fe0b5fb021ef",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/maps/sa1100-flash.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/ioport.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/platform_device.h>\n#include <linux/err.h>\n#include <linux/io.h>\n\n#include <linux/mtd/mtd.h>\n#include <linux/mtd/map.h>\n#include <linux/mtd/partitions.h>\n#include <linux/mtd/concat.h>\n\n#include <mach/hardware.h>\n#include <linux/sizes.h>\n#include <asm/mach/flash.h>\n\nstruct sa_subdev_info {\n\tchar name[16];\n\tstruct map_info map;\n\tstruct mtd_info *mtd;\n\tstruct flash_platform_data *plat;\n};\n\nstruct sa_info {\n\tstruct mtd_info\t\t*mtd;\n\tint\t\t\tnum_subdev;\n\tstruct sa_subdev_info\tsubdev[];\n};\n\nstatic DEFINE_SPINLOCK(sa1100_vpp_lock);\nstatic int sa1100_vpp_refcnt;\nstatic void sa1100_set_vpp(struct map_info *map, int on)\n{\n\tstruct sa_subdev_info *subdev = container_of(map, struct sa_subdev_info, map);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&sa1100_vpp_lock, flags);\n\tif (on) {\n\t\tif (++sa1100_vpp_refcnt == 1)    \n\t\t\tsubdev->plat->set_vpp(1);\n\t} else {\n\t\tif (--sa1100_vpp_refcnt == 0)    \n\t\t\tsubdev->plat->set_vpp(0);\n\t}\n\tspin_unlock_irqrestore(&sa1100_vpp_lock, flags);\n}\n\nstatic void sa1100_destroy_subdev(struct sa_subdev_info *subdev)\n{\n\tif (subdev->mtd)\n\t\tmap_destroy(subdev->mtd);\n\tif (subdev->map.virt)\n\t\tiounmap(subdev->map.virt);\n\trelease_mem_region(subdev->map.phys, subdev->map.size);\n}\n\nstatic int sa1100_probe_subdev(struct sa_subdev_info *subdev, struct resource *res)\n{\n\tunsigned long phys;\n\tunsigned int size;\n\tint ret;\n\n\tphys = res->start;\n\tsize = res->end - phys + 1;\n\n\t \n\tswitch (phys) {\n\tdefault:\n\t\tprintk(KERN_WARNING \"SA1100 flash: unknown base address \"\n\t\t       \"0x%08lx, assuming CS0\\n\", phys);\n\t\tfallthrough;\n\tcase SA1100_CS0_PHYS:\n\t\tsubdev->map.bankwidth = (MSC0 & MSC_RBW) ? 2 : 4;\n\t\tbreak;\n\n\tcase SA1100_CS1_PHYS:\n\t\tsubdev->map.bankwidth = ((MSC0 >> 16) & MSC_RBW) ? 2 : 4;\n\t\tbreak;\n\t}\n\n\tif (!request_mem_region(phys, size, subdev->name)) {\n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tif (subdev->plat->set_vpp)\n\t\tsubdev->map.set_vpp = sa1100_set_vpp;\n\n\tsubdev->map.phys = phys;\n\tsubdev->map.size = size;\n\tsubdev->map.virt = ioremap(phys, size);\n\tif (!subdev->map.virt) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tsimple_map_init(&subdev->map);\n\n\t \n\tsubdev->mtd = do_map_probe(subdev->plat->map_name, &subdev->map);\n\tif (subdev->mtd == NULL) {\n\t\tret = -ENXIO;\n\t\tgoto err;\n\t}\n\n\tprintk(KERN_INFO \"SA1100 flash: CFI device at 0x%08lx, %uMiB, %d-bit\\n\",\n\t\tphys, (unsigned)(subdev->mtd->size >> 20),\n\t\tsubdev->map.bankwidth * 8);\n\n\treturn 0;\n\n err:\n\tsa1100_destroy_subdev(subdev);\n out:\n\treturn ret;\n}\n\nstatic void sa1100_destroy(struct sa_info *info, struct flash_platform_data *plat)\n{\n\tint i;\n\n\tif (info->mtd) {\n\t\tmtd_device_unregister(info->mtd);\n\t\tif (info->mtd != info->subdev[0].mtd)\n\t\t\tmtd_concat_destroy(info->mtd);\n\t}\n\n\tfor (i = info->num_subdev - 1; i >= 0; i--)\n\t\tsa1100_destroy_subdev(&info->subdev[i]);\n\tkfree(info);\n\n\tif (plat->exit)\n\t\tplat->exit();\n}\n\nstatic struct sa_info *sa1100_setup_mtd(struct platform_device *pdev,\n\t\t\t\t\tstruct flash_platform_data *plat)\n{\n\tstruct sa_info *info;\n\tint nr, size, i, ret = 0;\n\n\t \n\tfor (nr = 0; ; nr++)\n\t\tif (!platform_get_resource(pdev, IORESOURCE_MEM, nr))\n\t\t\tbreak;\n\n\tif (nr == 0) {\n\t\tret = -ENODEV;\n\t\tgoto out;\n\t}\n\n\tsize = sizeof(struct sa_info) + sizeof(struct sa_subdev_info) * nr;\n\n\t \n\tinfo = kzalloc(size, GFP_KERNEL);\n\tif (!info) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tif (plat->init) {\n\t\tret = plat->init();\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\t \n\tfor (i = 0; i < nr; i++) {\n\t\tstruct sa_subdev_info *subdev = &info->subdev[i];\n\t\tstruct resource *res;\n\n\t\tres = platform_get_resource(pdev, IORESOURCE_MEM, i);\n\t\tif (!res)\n\t\t\tbreak;\n\n\t\tsubdev->map.name = subdev->name;\n\t\tsprintf(subdev->name, \"%s-%d\", plat->name, i);\n\t\tsubdev->plat = plat;\n\n\t\tret = sa1100_probe_subdev(subdev, res);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\tinfo->num_subdev = i;\n\n\t \n\tif (ret != 0 && !(ret == -ENXIO && info->num_subdev > 0))\n\t\tgoto err;\n\n\t \n\tif (info->num_subdev == 1) {\n\t\tstrcpy(info->subdev[0].name, plat->name);\n\t\tinfo->mtd = info->subdev[0].mtd;\n\t\tret = 0;\n\t} else if (info->num_subdev > 1) {\n\t\tstruct mtd_info **cdev;\n\n\t\tcdev = kmalloc_array(nr, sizeof(*cdev), GFP_KERNEL);\n\t\tif (!cdev) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err;\n\t\t}\n\n\t\t \n\t\tfor (i = 0; i < info->num_subdev; i++)\n\t\t\tcdev[i] = info->subdev[i].mtd;\n\n\t\tinfo->mtd = mtd_concat_create(cdev, info->num_subdev,\n\t\t\t\t\t      plat->name);\n\t\tkfree(cdev);\n\t\tif (info->mtd == NULL) {\n\t\t\tret = -ENXIO;\n\t\t\tgoto err;\n\t\t}\n\t}\n\tinfo->mtd->dev.parent = &pdev->dev;\n\n\tif (ret == 0)\n\t\treturn info;\n\n err:\n\tsa1100_destroy(info, plat);\n out:\n\treturn ERR_PTR(ret);\n}\n\nstatic const char * const part_probes[] = { \"cmdlinepart\", \"RedBoot\", NULL };\n\nstatic int sa1100_mtd_probe(struct platform_device *pdev)\n{\n\tstruct flash_platform_data *plat = dev_get_platdata(&pdev->dev);\n\tstruct sa_info *info;\n\tint err;\n\n\tif (!plat)\n\t\treturn -ENODEV;\n\n\tinfo = sa1100_setup_mtd(pdev, plat);\n\tif (IS_ERR(info)) {\n\t\terr = PTR_ERR(info);\n\t\tgoto out;\n\t}\n\n\t \n\tmtd_device_parse_register(info->mtd, part_probes, NULL, plat->parts,\n\t\t\t\t  plat->nr_parts);\n\n\tplatform_set_drvdata(pdev, info);\n\terr = 0;\n\n out:\n\treturn err;\n}\n\nstatic int sa1100_mtd_remove(struct platform_device *pdev)\n{\n\tstruct sa_info *info = platform_get_drvdata(pdev);\n\tstruct flash_platform_data *plat = dev_get_platdata(&pdev->dev);\n\n\tsa1100_destroy(info, plat);\n\n\treturn 0;\n}\n\nstatic struct platform_driver sa1100_mtd_driver = {\n\t.probe\t\t= sa1100_mtd_probe,\n\t.remove\t\t= sa1100_mtd_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"sa1100-mtd\",\n\t},\n};\n\nmodule_platform_driver(sa1100_mtd_driver);\n\nMODULE_AUTHOR(\"Nicolas Pitre\");\nMODULE_DESCRIPTION(\"SA1100 CFI map driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:sa1100-mtd\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}