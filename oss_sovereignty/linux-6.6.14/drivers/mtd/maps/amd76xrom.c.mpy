{
  "module_name": "amd76xrom.c",
  "hash_id": "7bfed1ff142ec55585ba65459f1d1bb12aa3d7b1d1534f6d48bf9d0e3b8f2735",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/maps/amd76xrom.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <asm/io.h>\n#include <linux/mtd/mtd.h>\n#include <linux/mtd/map.h>\n#include <linux/mtd/cfi.h>\n#include <linux/mtd/flashchip.h>\n#include <linux/pci.h>\n#include <linux/pci_ids.h>\n#include <linux/list.h>\n\n\n#define xstr(s) str(s)\n#define str(s) #s\n#define MOD_NAME xstr(KBUILD_BASENAME)\n\n#define ADDRESS_NAME_LEN 18\n\n#define ROM_PROBE_STEP_SIZE (64*1024)  \n\nstruct amd76xrom_window {\n\tvoid __iomem *virt;\n\tunsigned long phys;\n\tunsigned long size;\n\tstruct list_head maps;\n\tstruct resource rsrc;\n\tstruct pci_dev *pdev;\n};\n\nstruct amd76xrom_map_info {\n\tstruct list_head list;\n\tstruct map_info map;\n\tstruct mtd_info *mtd;\n\tstruct resource rsrc;\n\tchar map_name[sizeof(MOD_NAME) + 2 + ADDRESS_NAME_LEN];\n};\n\n \nstatic uint win_size_bits;\nmodule_param(win_size_bits, uint, 0);\nMODULE_PARM_DESC(win_size_bits, \"ROM window size bits override for 0x43 byte, normally set by BIOS.\");\n\nstatic struct amd76xrom_window amd76xrom_window = {\n\t.maps = LIST_HEAD_INIT(amd76xrom_window.maps),\n};\n\nstatic void amd76xrom_cleanup(struct amd76xrom_window *window)\n{\n\tstruct amd76xrom_map_info *map, *scratch;\n\tu8 byte;\n\n\tif (window->pdev) {\n\t\t \n\t\tpci_read_config_byte(window->pdev, 0x40, &byte);\n\t\tpci_write_config_byte(window->pdev, 0x40, byte & ~1);\n\t\tpci_dev_put(window->pdev);\n\t}\n\n\t \n\tlist_for_each_entry_safe(map, scratch, &window->maps, list) {\n\t\tif (map->rsrc.parent) {\n\t\t\trelease_resource(&map->rsrc);\n\t\t}\n\t\tmtd_device_unregister(map->mtd);\n\t\tmap_destroy(map->mtd);\n\t\tlist_del(&map->list);\n\t\tkfree(map);\n\t}\n\tif (window->rsrc.parent)\n\t\trelease_resource(&window->rsrc);\n\n\tif (window->virt) {\n\t\tiounmap(window->virt);\n\t\twindow->virt = NULL;\n\t\twindow->phys = 0;\n\t\twindow->size = 0;\n\t\twindow->pdev = NULL;\n\t}\n}\n\n\nstatic int amd76xrom_init_one(struct pci_dev *pdev,\n\t\t\t      const struct pci_device_id *ent)\n{\n\tstatic char *rom_probe_types[] = { \"cfi_probe\", \"jedec_probe\", NULL };\n\tu8 byte;\n\tstruct amd76xrom_window *window = &amd76xrom_window;\n\tstruct amd76xrom_map_info *map = NULL;\n\tunsigned long map_top;\n\n\t \n\twindow->pdev = pdev;\n\n\t \n\tpci_read_config_byte(pdev, 0x43, &byte);\n\tpci_write_config_byte(pdev, 0x43, byte | win_size_bits );\n\n\t \n\tpci_read_config_byte(pdev, 0x43, &byte);\n\tif ((byte & ((1<<7)|(1<<6))) == ((1<<7)|(1<<6))) {\n\t\twindow->phys = 0xffb00000;  \n\t}\n\telse if ((byte & (1<<7)) == (1<<7)) {\n\t\twindow->phys = 0xffc00000;  \n\t}\n\telse {\n\t\twindow->phys = 0xffff0000;  \n\t}\n\twindow->size = 0xffffffffUL - window->phys + 1UL;\n\n\t \n\twindow->rsrc.name = MOD_NAME;\n\twindow->rsrc.start = window->phys;\n\twindow->rsrc.end   = window->phys + window->size - 1;\n\twindow->rsrc.flags = IORESOURCE_MEM | IORESOURCE_BUSY;\n\tif (request_resource(&iomem_resource, &window->rsrc)) {\n\t\twindow->rsrc.parent = NULL;\n\t\tprintk(KERN_ERR MOD_NAME\n\t\t       \" %s(): Unable to register resource %pR - kernel bug?\\n\",\n\t\t       __func__, &window->rsrc);\n\t\treturn -EBUSY;\n\t}\n\n\n\t \n\tpci_read_config_byte(pdev, 0x40, &byte);\n\tpci_write_config_byte(pdev, 0x40, byte | 1);\n\n\t \n\n\t \n\twindow->virt = ioremap(window->phys, window->size);\n\tif (!window->virt) {\n\t\tprintk(KERN_ERR MOD_NAME \": ioremap(%08lx, %08lx) failed\\n\",\n\t\t\twindow->phys, window->size);\n\t\tgoto out;\n\t}\n\n\t \n\tmap_top = window->phys;\n#if 1\n\t \n\tif (map_top < 0xffc00000) {\n\t\tmap_top = 0xffc00000;\n\t}\n#endif\n\t \n\twhile((map_top - 1) < 0xffffffffUL) {\n\t\tstruct cfi_private *cfi;\n\t\tunsigned long offset;\n\t\tint i;\n\n\t\tif (!map) {\n\t\t\tmap = kmalloc(sizeof(*map), GFP_KERNEL);\n\t\t\tif (!map)\n\t\t\t\tgoto out;\n\t\t}\n\t\tmemset(map, 0, sizeof(*map));\n\t\tINIT_LIST_HEAD(&map->list);\n\t\tmap->map.name = map->map_name;\n\t\tmap->map.phys = map_top;\n\t\toffset = map_top - window->phys;\n\t\tmap->map.virt = (void __iomem *)\n\t\t\t(((unsigned long)(window->virt)) + offset);\n\t\tmap->map.size = 0xffffffffUL - map_top + 1UL;\n\t\t \n\t\tsprintf(map->map_name, \"%s @%08Lx\",\n\t\t\tMOD_NAME, (unsigned long long)map->map.phys);\n\n\t\t \n\t\tfor(map->map.bankwidth = 32; map->map.bankwidth;\n\t\t\tmap->map.bankwidth >>= 1)\n\t\t{\n\t\t\tchar **probe_type;\n\t\t\t \n\t\t\tif (!map_bankwidth_supported(map->map.bankwidth))\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tsimple_map_init(&map->map);\n\n\t\t\t \n\t\t\tprobe_type = rom_probe_types;\n\t\t\tfor(; *probe_type; probe_type++) {\n\t\t\t\tmap->mtd = do_map_probe(*probe_type, &map->map);\n\t\t\t\tif (map->mtd)\n\t\t\t\t\tgoto found;\n\t\t\t}\n\t\t}\n\t\tmap_top += ROM_PROBE_STEP_SIZE;\n\t\tcontinue;\n\tfound:\n\t\t \n\t\tif (map->mtd->size > map->map.size) {\n\t\t\tprintk(KERN_WARNING MOD_NAME\n\t\t\t\t\" rom(%llu) larger than window(%lu). fixing...\\n\",\n\t\t\t\t(unsigned long long)map->mtd->size, map->map.size);\n\t\t\tmap->mtd->size = map->map.size;\n\t\t}\n\t\tif (window->rsrc.parent) {\n\t\t\t \n\t\t\tmap->rsrc.name  = map->map_name;\n\t\t\tmap->rsrc.start = map->map.phys;\n\t\t\tmap->rsrc.end   = map->map.phys + map->mtd->size - 1;\n\t\t\tmap->rsrc.flags = IORESOURCE_MEM | IORESOURCE_BUSY;\n\t\t\tif (request_resource(&window->rsrc, &map->rsrc)) {\n\t\t\t\tprintk(KERN_ERR MOD_NAME\n\t\t\t\t\t\": cannot reserve MTD resource\\n\");\n\t\t\t\tmap->rsrc.parent = NULL;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tmap->map.virt = window->virt;\n\t\tmap->map.phys = window->phys;\n\t\tcfi = map->map.fldrv_priv;\n\t\tfor(i = 0; i < cfi->numchips; i++) {\n\t\t\tcfi->chips[i].start += offset;\n\t\t}\n\n\t\t \n\t\tmap->mtd->owner = THIS_MODULE;\n\t\tif (mtd_device_register(map->mtd, NULL, 0)) {\n\t\t\tmap_destroy(map->mtd);\n\t\t\tmap->mtd = NULL;\n\t\t\tgoto out;\n\t\t}\n\n\n\t\t \n\t\tmap_top += map->mtd->size;\n\n\t\t \n\t\tlist_add(&map->list, &window->maps);\n\t\tmap = NULL;\n\t}\n\n out:\n\t \n\tkfree(map);\n\t \n\tif (list_empty(&window->maps)) {\n\t\tamd76xrom_cleanup(window);\n\t\treturn -ENODEV;\n\t}\n\treturn 0;\n}\n\n\nstatic void amd76xrom_remove_one(struct pci_dev *pdev)\n{\n\tstruct amd76xrom_window *window = &amd76xrom_window;\n\n\tamd76xrom_cleanup(window);\n}\n\nstatic const struct pci_device_id amd76xrom_pci_tbl[] = {\n\t{ PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_VIPER_7410,\n\t\tPCI_ANY_ID, PCI_ANY_ID, },\n\t{ PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_VIPER_7440,\n\t\tPCI_ANY_ID, PCI_ANY_ID, },\n\t{ PCI_VENDOR_ID_AMD, 0x7468 },  \n\t{ 0, }\n};\n\nMODULE_DEVICE_TABLE(pci, amd76xrom_pci_tbl);\n\n#if 0\nstatic struct pci_driver amd76xrom_driver = {\n\t.name =\t\tMOD_NAME,\n\t.id_table =\tamd76xrom_pci_tbl,\n\t.probe =\tamd76xrom_init_one,\n\t.remove =\tamd76xrom_remove_one,\n};\n#endif\n\nstatic int __init init_amd76xrom(void)\n{\n\tstruct pci_dev *pdev;\n\tconst struct pci_device_id *id;\n\tpdev = NULL;\n\tfor(id = amd76xrom_pci_tbl; id->vendor; id++) {\n\t\tpdev = pci_get_device(id->vendor, id->device, NULL);\n\t\tif (pdev) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (pdev) {\n\t\treturn amd76xrom_init_one(pdev, &amd76xrom_pci_tbl[0]);\n\t}\n\treturn -ENXIO;\n#if 0\n\treturn pci_register_driver(&amd76xrom_driver);\n#endif\n}\n\nstatic void __exit cleanup_amd76xrom(void)\n{\n\tamd76xrom_remove_one(amd76xrom_window.pdev);\n}\n\nmodule_init(init_amd76xrom);\nmodule_exit(cleanup_amd76xrom);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Eric Biederman <ebiederman@lnxi.com>\");\nMODULE_DESCRIPTION(\"MTD map driver for BIOS chips on the AMD76X southbridge\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}