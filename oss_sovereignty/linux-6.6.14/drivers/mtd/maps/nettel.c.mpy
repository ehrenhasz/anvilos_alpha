{
  "module_name": "nettel.c",
  "hash_id": "908fa633912409ed200e4e636c90128958c172127370f8e83cb83919dac03912",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/maps/nettel.c",
  "human_readable_source": "\n \n\n \n\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/mtd/mtd.h>\n#include <linux/mtd/map.h>\n#include <linux/mtd/partitions.h>\n#include <linux/mtd/cfi.h>\n#include <linux/reboot.h>\n#include <linux/err.h>\n#include <linux/kdev_t.h>\n#include <linux/root_dev.h>\n#include <asm/io.h>\n\n \n\n#define INTEL_BUSWIDTH\t\t1\n#define AMD_WINDOW_MAXSIZE\t0x00200000\n#define AMD_BUSWIDTH\t \t1\n\n \n#define SC520_PAR_ADDR_MASK\t0x00003fff\n#define SC520_PAR_ADDR_SHIFT\t16\n#define SC520_PAR_TO_ADDR(par) \\\n\t(((par)&SC520_PAR_ADDR_MASK) << SC520_PAR_ADDR_SHIFT)\n\n#define SC520_PAR_SIZE_MASK\t0x01ffc000\n#define SC520_PAR_SIZE_SHIFT\t2\n#define SC520_PAR_TO_SIZE(par) \\\n\t((((par)&SC520_PAR_SIZE_MASK) << SC520_PAR_SIZE_SHIFT) + (64*1024))\n\n#define SC520_PAR(cs, addr, size) \\\n\t((cs) | \\\n\t((((size)-(64*1024)) >> SC520_PAR_SIZE_SHIFT) & SC520_PAR_SIZE_MASK) | \\\n\t(((addr) >> SC520_PAR_ADDR_SHIFT) & SC520_PAR_ADDR_MASK))\n\n#define SC520_PAR_BOOTCS\t0x8a000000\n#define\tSC520_PAR_ROMCS1\t0xaa000000\n#define SC520_PAR_ROMCS2\t0xca000000\t \n\nstatic void *nettel_mmcrp = NULL;\n\n#ifdef CONFIG_MTD_CFI_INTELEXT\nstatic struct mtd_info *intel_mtd;\n#endif\nstatic struct mtd_info *amd_mtd;\n\n \n\n \n\n#ifdef CONFIG_MTD_CFI_INTELEXT\nstatic struct map_info nettel_intel_map = {\n\t.name = \"SnapGear Intel\",\n\t.size = 0,\n\t.bankwidth = INTEL_BUSWIDTH,\n};\n\nstatic struct mtd_partition nettel_intel_partitions[] = {\n\t{\n\t\t.name = \"SnapGear kernel\",\n\t\t.offset = 0,\n\t\t.size = 0x000e0000\n\t},\n\t{\n\t\t.name = \"SnapGear filesystem\",\n\t\t.offset = 0x00100000,\n\t},\n\t{\n\t\t.name = \"SnapGear config\",\n\t\t.offset = 0x000e0000,\n\t\t.size = 0x00020000\n\t},\n\t{\n\t\t.name = \"SnapGear Intel\",\n\t\t.offset = 0\n\t},\n\t{\n\t\t.name = \"SnapGear BIOS Config\",\n\t\t.offset = 0x007e0000,\n\t\t.size = 0x00020000\n\t},\n\t{\n\t\t.name = \"SnapGear BIOS\",\n\t\t.offset = 0x007e0000,\n\t\t.size = 0x00020000\n\t},\n};\n#endif\n\nstatic struct map_info nettel_amd_map = {\n\t.name = \"SnapGear AMD\",\n\t.size = AMD_WINDOW_MAXSIZE,\n\t.bankwidth = AMD_BUSWIDTH,\n};\n\nstatic const struct mtd_partition nettel_amd_partitions[] = {\n\t{\n\t\t.name = \"SnapGear BIOS config\",\n\t\t.offset = 0x000e0000,\n\t\t.size = 0x00010000\n\t},\n\t{\n\t\t.name = \"SnapGear BIOS\",\n\t\t.offset = 0x000f0000,\n\t\t.size = 0x00010000\n\t},\n\t{\n\t\t.name = \"SnapGear AMD\",\n\t\t.offset = 0\n\t},\n\t{\n\t\t.name = \"SnapGear high BIOS\",\n\t\t.offset = 0x001f0000,\n\t\t.size = 0x00010000\n\t}\n};\n\n#define NUM_AMD_PARTITIONS ARRAY_SIZE(nettel_amd_partitions)\n\n \n\n#ifdef CONFIG_MTD_CFI_INTELEXT\n\n \nstatic int nettel_reboot_notifier(struct notifier_block *nb, unsigned long val, void *v)\n{\n\tstruct cfi_private *cfi = nettel_intel_map.fldrv_priv;\n\tunsigned long b;\n\n\t \n\tfor (b = 0; (b < nettel_intel_partitions[3].size); b += 0x100000) {\n\t\tcfi_send_gen_cmd(0xff, 0x55, b, &nettel_intel_map, cfi,\n\t\t\tcfi->device_type, NULL);\n\t}\n\treturn(NOTIFY_OK);\n}\n\nstatic struct notifier_block nettel_notifier_block = {\n\tnettel_reboot_notifier, NULL, 0\n};\n\n#endif\n\n \n\nstatic int __init nettel_init(void)\n{\n\tvolatile unsigned long *amdpar;\n\tunsigned long amdaddr, maxsize;\n\tint num_amd_partitions=0;\n#ifdef CONFIG_MTD_CFI_INTELEXT\n\tvolatile unsigned long *intel0par, *intel1par;\n\tunsigned long orig_bootcspar, orig_romcs1par;\n\tunsigned long intel0addr, intel0size;\n\tunsigned long intel1addr, intel1size;\n\tint intelboot, intel0cs, intel1cs;\n\tint num_intel_partitions;\n#endif\n\tint rc = 0;\n\n\tnettel_mmcrp = (void *) ioremap(0xfffef000, 4096);\n\tif (nettel_mmcrp == NULL) {\n\t\tprintk(\"SNAPGEAR: failed to disable MMCR cache??\\n\");\n\t\treturn(-EIO);\n\t}\n\n\t \n\t*((unsigned char *) (nettel_mmcrp + 0xc64)) = 0x01;\n\n\tamdpar = (volatile unsigned long *) (nettel_mmcrp + 0xc4);\n\n#ifdef CONFIG_MTD_CFI_INTELEXT\n\tintelboot = 0;\n\tintel0cs = SC520_PAR_ROMCS1;\n\tintel0par = (volatile unsigned long *) (nettel_mmcrp + 0xc0);\n\tintel1cs = SC520_PAR_ROMCS2;\n\tintel1par = (volatile unsigned long *) (nettel_mmcrp + 0xbc);\n\n\t \n\torig_bootcspar = *amdpar;\n\torig_romcs1par = *intel0par;\n\t*intel0par = 0;\n\t*intel1par = 0;\n#endif\n\n\t \n\tamdaddr = 0x20000000;\n\tmaxsize = AMD_WINDOW_MAXSIZE;\n\n\t*amdpar = SC520_PAR(SC520_PAR_BOOTCS, amdaddr, maxsize);\n\t__asm__ (\"wbinvd\");\n\n\tnettel_amd_map.phys = amdaddr;\n\tnettel_amd_map.virt = ioremap(amdaddr, maxsize);\n\tif (!nettel_amd_map.virt) {\n\t\tprintk(\"SNAPGEAR: failed to ioremap() BOOTCS\\n\");\n\t\tiounmap(nettel_mmcrp);\n\t\treturn(-EIO);\n\t}\n\tsimple_map_init(&nettel_amd_map);\n\n\tif ((amd_mtd = do_map_probe(\"jedec_probe\", &nettel_amd_map))) {\n\t\tprintk(KERN_NOTICE \"SNAPGEAR: AMD flash device size = %dK\\n\",\n\t\t\t(int)(amd_mtd->size>>10));\n\n\t\tamd_mtd->owner = THIS_MODULE;\n\n\t\t \n\t\tnum_amd_partitions = NUM_AMD_PARTITIONS;\n\t\tif (amd_mtd->size < AMD_WINDOW_MAXSIZE)\n\t\t\tnum_amd_partitions--;\n\t\t \n\n#ifdef CONFIG_MTD_CFI_INTELEXT\n\t\t \n\t\tmaxsize = SC520_PAR_TO_SIZE(orig_romcs1par);\n\t\tif (maxsize < (32 * 1024 * 1024))\n\t\t\tmaxsize = (32 * 1024 * 1024);\n\t\tintel0addr = amdaddr + maxsize;\n#endif\n\t} else {\n#ifdef CONFIG_MTD_CFI_INTELEXT\n\t\t \n\t\tintelboot++;\n\n\t\tif (!orig_romcs1par) {\n\t\t\tintel0cs = SC520_PAR_BOOTCS;\n\t\t\tintel0par = (volatile unsigned long *)\n\t\t\t\t(nettel_mmcrp + 0xc4);\n\t\t\tintel1cs = SC520_PAR_ROMCS1;\n\t\t\tintel1par = (volatile unsigned long *)\n\t\t\t\t(nettel_mmcrp + 0xc0);\n\n\t\t\tintel0addr = SC520_PAR_TO_ADDR(orig_bootcspar);\n\t\t\tmaxsize = SC520_PAR_TO_SIZE(orig_bootcspar);\n\t\t} else {\n\t\t\t \n\t\t\tintel0cs = SC520_PAR_ROMCS1;\n\t\t\tintel0par = (volatile unsigned long *)\n\t\t\t\t(nettel_mmcrp + 0xc0);\n\t\t\tintel1cs = SC520_PAR_BOOTCS;\n\t\t\tintel1par = (volatile unsigned long *)\n\t\t\t\t(nettel_mmcrp + 0xc4);\n\n\t\t\tintel0addr = SC520_PAR_TO_ADDR(orig_romcs1par);\n\t\t\tmaxsize = SC520_PAR_TO_SIZE(orig_romcs1par);\n\t\t}\n\n\t\t \n\t\tamd_mtd = NULL;\n\t\tiounmap(nettel_amd_map.virt);\n\t\tnettel_amd_map.virt = NULL;\n#else\n\t\t \n\t\trc = -ENXIO;\n\t\tgoto out_unmap2;\n#endif\n\t}\n\n#ifdef CONFIG_MTD_CFI_INTELEXT\n\t \n\n\t \n\tif (maxsize < (32 * 1024 * 1024))\n\t\tmaxsize = (32 * 1024 * 1024);\n\t*intel0par = SC520_PAR(intel0cs, intel0addr, maxsize);\n\n\t \n\t*intel1par = 0;\n\n\t \n\tnettel_intel_map.size = maxsize;\n\tnettel_intel_map.phys = intel0addr;\n\tnettel_intel_map.virt = ioremap(intel0addr, maxsize);\n\tif (!nettel_intel_map.virt) {\n\t\tprintk(\"SNAPGEAR: failed to ioremap() ROMCS1\\n\");\n\t\trc = -EIO;\n\t\tgoto out_unmap2;\n\t}\n\tsimple_map_init(&nettel_intel_map);\n\n\tintel_mtd = do_map_probe(\"cfi_probe\", &nettel_intel_map);\n\tif (!intel_mtd) {\n\t\trc = -ENXIO;\n\t\tgoto out_unmap1;\n\t}\n\n\t \n\tintel0size = intel_mtd->size;\n\t*intel0par = SC520_PAR(intel0cs, intel0addr, intel0size);\n\n\t \n\tintel1addr = intel0addr + intel0size;\n\t*intel1par = SC520_PAR(intel1cs, intel1addr, maxsize);\n\t__asm__ (\"wbinvd\");\n\n\tmaxsize += intel0size;\n\n\t \n\tmap_destroy(intel_mtd);\n\tintel_mtd = NULL;\n\tiounmap(nettel_intel_map.virt);\n\n\tnettel_intel_map.size = maxsize;\n\tnettel_intel_map.virt = ioremap(intel0addr, maxsize);\n\tif (!nettel_intel_map.virt) {\n\t\tprintk(\"SNAPGEAR: failed to ioremap() ROMCS1/2\\n\");\n\t\trc = -EIO;\n\t\tgoto out_unmap2;\n\t}\n\n\tintel_mtd = do_map_probe(\"cfi_probe\", &nettel_intel_map);\n\tif (! intel_mtd) {\n\t\trc = -ENXIO;\n\t\tgoto out_unmap1;\n\t}\n\n\tintel1size = intel_mtd->size - intel0size;\n\tif (intel1size > 0) {\n\t\t*intel1par = SC520_PAR(intel1cs, intel1addr, intel1size);\n\t\t__asm__ (\"wbinvd\");\n\t} else {\n\t\t*intel1par = 0;\n\t}\n\n\tprintk(KERN_NOTICE \"SNAPGEAR: Intel flash device size = %lldKiB\\n\",\n\t       (unsigned long long)(intel_mtd->size >> 10));\n\n\tintel_mtd->owner = THIS_MODULE;\n\n\tnum_intel_partitions = ARRAY_SIZE(nettel_intel_partitions);\n\n\tif (intelboot) {\n\t\t \n\t\tnettel_intel_partitions[1].size = (intel0size + intel1size) -\n\t\t\t(1024*1024 + intel_mtd->erasesize);\n\t\tnettel_intel_partitions[3].size = intel0size + intel1size;\n\t\tnettel_intel_partitions[4].offset =\n\t\t\t(intel0size + intel1size) - intel_mtd->erasesize;\n\t\tnettel_intel_partitions[4].size = intel_mtd->erasesize;\n\t\tnettel_intel_partitions[5].offset =\n\t\t\tnettel_intel_partitions[4].offset;\n\t\tnettel_intel_partitions[5].size =\n\t\t\tnettel_intel_partitions[4].size;\n\t} else {\n\t\t \n\t\tnum_intel_partitions -= 2;\n\t}\n\trc = mtd_device_register(intel_mtd, nettel_intel_partitions,\n\t\t\t\t num_intel_partitions);\n\tif (rc)\n\t\tgoto out_map_destroy;\n#endif\n\n\tif (amd_mtd) {\n\t\trc = mtd_device_register(amd_mtd, nettel_amd_partitions,\n\t\t\t\t\t num_amd_partitions);\n\t\tif (rc)\n\t\t\tgoto out_mtd_unreg;\n\t}\n\n#ifdef CONFIG_MTD_CFI_INTELEXT\n\tregister_reboot_notifier(&nettel_notifier_block);\n#endif\n\n\treturn rc;\n\nout_mtd_unreg:\n#ifdef CONFIG_MTD_CFI_INTELEXT\n\tmtd_device_unregister(intel_mtd);\nout_map_destroy:\n\tmap_destroy(intel_mtd);\nout_unmap1:\n\tiounmap(nettel_intel_map.virt);\n#endif\n\nout_unmap2:\n\tiounmap(nettel_mmcrp);\n\tiounmap(nettel_amd_map.virt);\n\n\treturn rc;\n}\n\n \n\nstatic void __exit nettel_cleanup(void)\n{\n#ifdef CONFIG_MTD_CFI_INTELEXT\n\tunregister_reboot_notifier(&nettel_notifier_block);\n#endif\n\tif (amd_mtd) {\n\t\tmtd_device_unregister(amd_mtd);\n\t\tmap_destroy(amd_mtd);\n\t}\n\tif (nettel_mmcrp) {\n\t\tiounmap(nettel_mmcrp);\n\t\tnettel_mmcrp = NULL;\n\t}\n\tif (nettel_amd_map.virt) {\n\t\tiounmap(nettel_amd_map.virt);\n\t\tnettel_amd_map.virt = NULL;\n\t}\n#ifdef CONFIG_MTD_CFI_INTELEXT\n\tif (intel_mtd) {\n\t\tmtd_device_unregister(intel_mtd);\n\t\tmap_destroy(intel_mtd);\n\t}\n\tif (nettel_intel_map.virt) {\n\t\tiounmap(nettel_intel_map.virt);\n\t\tnettel_intel_map.virt = NULL;\n\t}\n#endif\n}\n\n \n\nmodule_init(nettel_init);\nmodule_exit(nettel_cleanup);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Greg Ungerer <gerg@snapgear.com>\");\nMODULE_DESCRIPTION(\"SnapGear/SecureEdge FLASH support\");\n\n \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}