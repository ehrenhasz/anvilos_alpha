{
  "module_name": "physmap-gemini.c",
  "hash_id": "e76cd5912b7f65109ab5b8238d45287e96594d92127ff3c05f7969875b35b390",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/maps/physmap-gemini.c",
  "human_readable_source": "\n \n#include <linux/export.h>\n#include <linux/of.h>\n#include <linux/mtd/map.h>\n#include <linux/mtd/xip.h>\n#include <linux/mfd/syscon.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/bitops.h>\n#include <linux/pinctrl/consumer.h>\n#include \"physmap-gemini.h\"\n\n \n#define GLOBAL_STATUS\t\t\t0x04\n#define FLASH_TYPE_MASK\t\t\t(0x3 << 24)\n#define FLASH_TYPE_NAND_2K\t\t(0x3 << 24)\n#define FLASH_TYPE_NAND_512\t\t(0x2 << 24)\n#define FLASH_TYPE_PARALLEL\t\t(0x1 << 24)\n#define FLASH_TYPE_SERIAL\t\t(0x0 << 24)\n \n#define FLASH_WIDTH_16BIT\t\t(1 << 23)\t \n \n#define FLASH_ATMEL\t\t\t(1 << 23)\t \n\n#define FLASH_SIZE_MASK\t\t\t(0x3 << 21)\n#define NAND_256M\t\t\t(0x3 << 21)\t \n#define NAND_128M\t\t\t(0x2 << 21)\n#define NAND_64M\t\t\t(0x1 << 21)\n#define NAND_32M\t\t\t(0x0 << 21)\n#define ATMEL_16M\t\t\t(0x3 << 21)\t \n#define ATMEL_8M\t\t\t(0x2 << 21)\n#define ATMEL_4M_2M\t\t\t(0x1 << 21)\n#define ATMEL_1M\t\t\t(0x0 << 21)\t \n#define STM_32M\t\t\t\t(1 << 22)\t \n#define STM_16M\t\t\t\t(0 << 22)\t \n\n#define FLASH_PARALLEL_HIGH_PIN_CNT\t(1 << 20)\t \n\nstruct gemini_flash {\n\tstruct device *dev;\n\tstruct pinctrl *p;\n\tstruct pinctrl_state *enabled_state;\n\tstruct pinctrl_state *disabled_state;\n};\n\n \nstatic struct gemini_flash *gf;\n\nstatic void gemini_flash_enable_pins(void)\n{\n\tint ret;\n\n\tif (IS_ERR(gf->enabled_state))\n\t\treturn;\n\tret = pinctrl_select_state(gf->p, gf->enabled_state);\n\tif (ret)\n\t\tdev_err(gf->dev, \"failed to enable pins\\n\");\n}\n\nstatic void gemini_flash_disable_pins(void)\n{\n\tint ret;\n\n\tif (IS_ERR(gf->disabled_state))\n\t\treturn;\n\tret = pinctrl_select_state(gf->p, gf->disabled_state);\n\tif (ret)\n\t\tdev_err(gf->dev, \"failed to disable pins\\n\");\n}\n\nstatic map_word __xipram gemini_flash_map_read(struct map_info *map,\n\t\t\t\t\t       unsigned long ofs)\n{\n\tmap_word ret;\n\n\tgemini_flash_enable_pins();\n\tret = inline_map_read(map, ofs);\n\tgemini_flash_disable_pins();\n\n\treturn ret;\n}\n\nstatic void __xipram gemini_flash_map_write(struct map_info *map,\n\t\t\t\t\t    const map_word datum,\n\t\t\t\t\t    unsigned long ofs)\n{\n\tgemini_flash_enable_pins();\n\tinline_map_write(map, datum, ofs);\n\tgemini_flash_disable_pins();\n}\n\nstatic void __xipram gemini_flash_map_copy_from(struct map_info *map,\n\t\t\t\t\t\tvoid *to, unsigned long from,\n\t\t\t\t\t\tssize_t len)\n{\n\tgemini_flash_enable_pins();\n\tinline_map_copy_from(map, to, from, len);\n\tgemini_flash_disable_pins();\n}\n\nstatic void __xipram gemini_flash_map_copy_to(struct map_info *map,\n\t\t\t\t\t      unsigned long to,\n\t\t\t\t\t      const void *from, ssize_t len)\n{\n\tgemini_flash_enable_pins();\n\tinline_map_copy_to(map, to, from, len);\n\tgemini_flash_disable_pins();\n}\n\nint of_flash_probe_gemini(struct platform_device *pdev,\n\t\t\t  struct device_node *np,\n\t\t\t  struct map_info *map)\n{\n\tstruct regmap *rmap;\n\tstruct device *dev = &pdev->dev;\n\tu32 val;\n\tint ret;\n\n\t \n\tif (!of_device_is_compatible(np, \"cortina,gemini-flash\"))\n\t\treturn 0;\n\n\tgf = devm_kzalloc(dev, sizeof(*gf), GFP_KERNEL);\n\tif (!gf)\n\t\treturn -ENOMEM;\n\tgf->dev = dev;\n\n\trmap = syscon_regmap_lookup_by_phandle(np, \"syscon\");\n\tif (IS_ERR(rmap)) {\n\t\tdev_err(dev, \"no syscon\\n\");\n\t\treturn PTR_ERR(rmap);\n\t}\n\n\tret = regmap_read(rmap, GLOBAL_STATUS, &val);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to read global status register\\n\");\n\t\treturn -ENODEV;\n\t}\n\tdev_dbg(dev, \"global status reg: %08x\\n\", val);\n\n\t \n\tif ((val & FLASH_TYPE_MASK) != FLASH_TYPE_PARALLEL) {\n\t\tdev_err(dev, \"flash is not parallel\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tif (val & FLASH_WIDTH_16BIT) {\n\t\tif (map->bankwidth != 2)\n\t\t\tdev_warn(dev, \"flash hardware say flash is 16 bit wide but DT says it is %d bits wide\\n\",\n\t\t\t\t map->bankwidth * 8);\n\t} else {\n\t\tif (map->bankwidth != 1)\n\t\t\tdev_warn(dev, \"flash hardware say flash is 8 bit wide but DT says it is %d bits wide\\n\",\n\t\t\t\t map->bankwidth * 8);\n\t}\n\n\tgf->p = devm_pinctrl_get(dev);\n\tif (IS_ERR(gf->p)) {\n\t\tdev_err(dev, \"no pinctrl handle\\n\");\n\t\tret = PTR_ERR(gf->p);\n\t\treturn ret;\n\t}\n\n\tgf->enabled_state = pinctrl_lookup_state(gf->p, \"enabled\");\n\tif (IS_ERR(gf->enabled_state))\n\t\tdev_err(dev, \"no enabled pin control state\\n\");\n\n\tgf->disabled_state = pinctrl_lookup_state(gf->p, \"disabled\");\n\tif (IS_ERR(gf->enabled_state)) {\n\t\tdev_err(dev, \"no disabled pin control state\\n\");\n\t} else {\n\t\tret = pinctrl_select_state(gf->p, gf->disabled_state);\n\t\tif (ret)\n\t\t\tdev_err(gf->dev, \"failed to disable pins\\n\");\n\t}\n\n\tmap->read = gemini_flash_map_read;\n\tmap->write = gemini_flash_map_write;\n\tmap->copy_from = gemini_flash_map_copy_from;\n\tmap->copy_to = gemini_flash_map_copy_to;\n\n\tdev_info(dev, \"initialized Gemini-specific physmap control\\n\");\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}