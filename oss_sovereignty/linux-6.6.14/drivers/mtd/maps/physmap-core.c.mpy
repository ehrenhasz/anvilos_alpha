{
  "module_name": "physmap-core.c",
  "hash_id": "e073e9c4a9f27daf20b958f0672faf7cacc56a661c0dab661e3a9f039639745e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/maps/physmap-core.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/device.h>\n#include <linux/platform_device.h>\n#include <linux/mtd/mtd.h>\n#include <linux/mtd/map.h>\n#include <linux/mtd/partitions.h>\n#include <linux/mtd/physmap.h>\n#include <linux/mtd/concat.h>\n#include <linux/mtd/cfi_endian.h>\n#include <linux/io.h>\n#include <linux/of_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/gpio/consumer.h>\n\n#include \"physmap-bt1-rom.h\"\n#include \"physmap-gemini.h\"\n#include \"physmap-ixp4xx.h\"\n#include \"physmap-versatile.h\"\n\nstruct physmap_flash_info {\n\tunsigned int\t\tnmaps;\n\tstruct mtd_info\t\t**mtds;\n\tstruct mtd_info\t\t*cmtd;\n\tstruct map_info\t\t*maps;\n\tspinlock_t\t\tvpp_lock;\n\tint\t\t\tvpp_refcnt;\n\tconst char\t\t*probe_type;\n\tconst char * const\t*part_types;\n\tunsigned int\t\tnparts;\n\tconst struct mtd_partition *parts;\n\tstruct gpio_descs\t*gpios;\n\tunsigned int\t\tgpio_values;\n\tunsigned int\t\twin_order;\n};\n\nstatic int physmap_flash_remove(struct platform_device *dev)\n{\n\tstruct physmap_flash_info *info;\n\tstruct physmap_flash_data *physmap_data;\n\tint i;\n\n\tinfo = platform_get_drvdata(dev);\n\n\tif (info->cmtd) {\n\t\tWARN_ON(mtd_device_unregister(info->cmtd));\n\n\t\tif (info->cmtd != info->mtds[0])\n\t\t\tmtd_concat_destroy(info->cmtd);\n\t}\n\n\tfor (i = 0; i < info->nmaps; i++) {\n\t\tif (info->mtds[i])\n\t\t\tmap_destroy(info->mtds[i]);\n\t}\n\n\tphysmap_data = dev_get_platdata(&dev->dev);\n\tif (physmap_data && physmap_data->exit)\n\t\tphysmap_data->exit(dev);\n\n\tpm_runtime_put(&dev->dev);\n\tpm_runtime_disable(&dev->dev);\n\treturn 0;\n}\n\nstatic void physmap_set_vpp(struct map_info *map, int state)\n{\n\tstruct platform_device *pdev;\n\tstruct physmap_flash_data *physmap_data;\n\tstruct physmap_flash_info *info;\n\tunsigned long flags;\n\n\tpdev = (struct platform_device *)map->map_priv_1;\n\tphysmap_data = dev_get_platdata(&pdev->dev);\n\n\tif (!physmap_data->set_vpp)\n\t\treturn;\n\n\tinfo = platform_get_drvdata(pdev);\n\n\tspin_lock_irqsave(&info->vpp_lock, flags);\n\tif (state) {\n\t\tif (++info->vpp_refcnt == 1)     \n\t\t\tphysmap_data->set_vpp(pdev, 1);\n\t} else {\n\t\tif (--info->vpp_refcnt == 0)     \n\t\t\tphysmap_data->set_vpp(pdev, 0);\n\t}\n\tspin_unlock_irqrestore(&info->vpp_lock, flags);\n}\n\n#if IS_ENABLED(CONFIG_MTD_PHYSMAP_GPIO_ADDR)\nstatic void physmap_set_addr_gpios(struct physmap_flash_info *info,\n\t\t\t\t   unsigned long ofs)\n{\n\tunsigned int i;\n\n\tofs >>= info->win_order;\n\tif (info->gpio_values == ofs)\n\t\treturn;\n\n\tfor (i = 0; i < info->gpios->ndescs; i++) {\n\t\tif ((BIT(i) & ofs) == (BIT(i) & info->gpio_values))\n\t\t\tcontinue;\n\n\t\tgpiod_set_value(info->gpios->desc[i], !!(BIT(i) & ofs));\n\t}\n\n\tinfo->gpio_values = ofs;\n}\n\n#define win_mask(order)\t\t(BIT(order) - 1)\n\nstatic map_word physmap_addr_gpios_read(struct map_info *map,\n\t\t\t\t\tunsigned long ofs)\n{\n\tstruct platform_device *pdev;\n\tstruct physmap_flash_info *info;\n\tmap_word mw;\n\tu16 word;\n\n\tpdev = (struct platform_device *)map->map_priv_1;\n\tinfo = platform_get_drvdata(pdev);\n\tphysmap_set_addr_gpios(info, ofs);\n\n\tword = readw(map->virt + (ofs & win_mask(info->win_order)));\n\tmw.x[0] = word;\n\treturn mw;\n}\n\nstatic void physmap_addr_gpios_copy_from(struct map_info *map, void *buf,\n\t\t\t\t\t unsigned long ofs, ssize_t len)\n{\n\tstruct platform_device *pdev;\n\tstruct physmap_flash_info *info;\n\n\tpdev = (struct platform_device *)map->map_priv_1;\n\tinfo = platform_get_drvdata(pdev);\n\n\twhile (len) {\n\t\tunsigned int winofs = ofs & win_mask(info->win_order);\n\t\tunsigned int chunklen = min_t(unsigned int, len,\n\t\t\t\t\t      BIT(info->win_order) - winofs);\n\n\t\tphysmap_set_addr_gpios(info, ofs);\n\t\tmemcpy_fromio(buf, map->virt + winofs, chunklen);\n\t\tlen -= chunklen;\n\t\tbuf += chunklen;\n\t\tofs += chunklen;\n\t}\n}\n\nstatic void physmap_addr_gpios_write(struct map_info *map, map_word mw,\n\t\t\t\t     unsigned long ofs)\n{\n\tstruct platform_device *pdev;\n\tstruct physmap_flash_info *info;\n\tu16 word;\n\n\tpdev = (struct platform_device *)map->map_priv_1;\n\tinfo = platform_get_drvdata(pdev);\n\tphysmap_set_addr_gpios(info, ofs);\n\n\tword = mw.x[0];\n\twritew(word, map->virt + (ofs & win_mask(info->win_order)));\n}\n\nstatic void physmap_addr_gpios_copy_to(struct map_info *map, unsigned long ofs,\n\t\t\t\t       const void *buf, ssize_t len)\n{\n\tstruct platform_device *pdev;\n\tstruct physmap_flash_info *info;\n\n\tpdev = (struct platform_device *)map->map_priv_1;\n\tinfo = platform_get_drvdata(pdev);\n\n\twhile (len) {\n\t\tunsigned int winofs = ofs & win_mask(info->win_order);\n\t\tunsigned int chunklen = min_t(unsigned int, len,\n\t\t\t\t\t      BIT(info->win_order) - winofs);\n\n\t\tphysmap_set_addr_gpios(info, ofs);\n\t\tmemcpy_toio(map->virt + winofs, buf, chunklen);\n\t\tlen -= chunklen;\n\t\tbuf += chunklen;\n\t\tofs += chunklen;\n\t}\n}\n\nstatic int physmap_addr_gpios_map_init(struct map_info *map)\n{\n\tmap->phys = NO_XIP;\n\tmap->read = physmap_addr_gpios_read;\n\tmap->copy_from = physmap_addr_gpios_copy_from;\n\tmap->write = physmap_addr_gpios_write;\n\tmap->copy_to = physmap_addr_gpios_copy_to;\n\n\treturn 0;\n}\n#else\nstatic int physmap_addr_gpios_map_init(struct map_info *map)\n{\n\treturn -ENOTSUPP;\n}\n#endif\n\n#if IS_ENABLED(CONFIG_MTD_PHYSMAP_OF)\nstatic const struct of_device_id of_flash_match[] = {\n\t{\n\t\t.compatible = \"cfi-flash\",\n\t\t.data = \"cfi_probe\",\n\t},\n\t{\n\t\t \n\t\t.compatible = \"jedec-flash\",\n\t\t.data = \"jedec_probe\",\n\t},\n\t{\n\t\t.compatible = \"mtd-ram\",\n\t\t.data = \"map_ram\",\n\t},\n\t{\n\t\t.compatible = \"mtd-rom\",\n\t\t.data = \"map_rom\",\n\t},\n\t{\n\t\t.type = \"rom\",\n\t\t.compatible = \"direct-mapped\"\n\t},\n\t{   },\n};\nMODULE_DEVICE_TABLE(of, of_flash_match);\n\nstatic const char * const of_default_part_probes[] = {\n\t\"cmdlinepart\", \"RedBoot\", \"ofpart\", \"ofoldpart\", NULL\n};\n\nstatic const char * const *of_get_part_probes(struct platform_device *dev)\n{\n\tstruct device_node *dp = dev->dev.of_node;\n\tconst char **res;\n\tint count;\n\n\tcount = of_property_count_strings(dp, \"linux,part-probe\");\n\tif (count < 0)\n\t\treturn of_default_part_probes;\n\n\tres = devm_kcalloc(&dev->dev, count + 1, sizeof(*res), GFP_KERNEL);\n\tif (!res)\n\t\treturn NULL;\n\n\tcount = of_property_read_string_array(dp, \"linux,part-probe\", res,\n\t\t\t\t\t      count);\n\tif (count < 0)\n\t\treturn NULL;\n\n\treturn res;\n}\n\nstatic const char *of_select_probe_type(struct platform_device *dev)\n{\n\tstruct device_node *dp = dev->dev.of_node;\n\tconst struct of_device_id *match;\n\tconst char *probe_type;\n\n\tmatch = of_match_device(of_flash_match, &dev->dev);\n\tif (!match)\n\t\treturn NULL;\n\n\tprobe_type = match->data;\n\tif (probe_type)\n\t\treturn probe_type;\n\n\tdev_warn(&dev->dev,\n\t\t \"Device tree uses obsolete \\\"direct-mapped\\\" flash binding\\n\");\n\n\tof_property_read_string(dp, \"probe-type\", &probe_type);\n\tif (!probe_type)\n\t\treturn NULL;\n\n\tif (!strcmp(probe_type, \"CFI\")) {\n\t\tprobe_type = \"cfi_probe\";\n\t} else if (!strcmp(probe_type, \"JEDEC\")) {\n\t\tprobe_type = \"jedec_probe\";\n\t} else if (!strcmp(probe_type, \"ROM\")) {\n\t\tprobe_type = \"map_rom\";\n\t} else {\n\t\tdev_warn(&dev->dev,\n\t\t\t \"obsolete_probe: don't know probe type '%s', mapping as rom\\n\",\n\t\t\t probe_type);\n\t\tprobe_type = \"map_rom\";\n\t}\n\n\treturn probe_type;\n}\n\nstatic int physmap_flash_of_init(struct platform_device *dev)\n{\n\tstruct physmap_flash_info *info = platform_get_drvdata(dev);\n\tstruct device_node *dp = dev->dev.of_node;\n\tconst char *mtd_name = NULL;\n\tint err, swap = 0;\n\tbool map_indirect;\n\tunsigned int i;\n\tu32 bankwidth;\n\n\tif (!dp)\n\t\treturn -EINVAL;\n\n\tinfo->probe_type = of_select_probe_type(dev);\n\n\tinfo->part_types = of_get_part_probes(dev);\n\tif (!info->part_types)\n\t\treturn -ENOMEM;\n\n\tof_property_read_string(dp, \"linux,mtd-name\", &mtd_name);\n\n\tmap_indirect = of_property_read_bool(dp, \"no-unaligned-direct-access\");\n\n\terr = of_property_read_u32(dp, \"bank-width\", &bankwidth);\n\tif (err) {\n\t\tdev_err(&dev->dev, \"Can't get bank width from device tree\\n\");\n\t\treturn err;\n\t}\n\n\tif (of_property_read_bool(dp, \"big-endian\"))\n\t\tswap = CFI_BIG_ENDIAN;\n\telse if (of_property_read_bool(dp, \"little-endian\"))\n\t\tswap = CFI_LITTLE_ENDIAN;\n\n\tfor (i = 0; i < info->nmaps; i++) {\n\t\tinfo->maps[i].name = mtd_name;\n\t\tinfo->maps[i].swap = swap;\n\t\tinfo->maps[i].bankwidth = bankwidth;\n\t\tinfo->maps[i].device_node = dp;\n\n\t\terr = of_flash_probe_bt1_rom(dev, dp, &info->maps[i]);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\terr = of_flash_probe_gemini(dev, dp, &info->maps[i]);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\terr = of_flash_probe_ixp4xx(dev, dp, &info->maps[i]);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\terr = of_flash_probe_versatile(dev, dp, &info->maps[i]);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\t \n\t\tif (map_indirect)\n\t\t\tinfo->maps[i].phys = NO_XIP;\n\t}\n\n\treturn 0;\n}\n#else  \n#define of_flash_match NULL\n\nstatic int physmap_flash_of_init(struct platform_device *dev)\n{\n\treturn -ENOTSUPP;\n}\n#endif  \n\nstatic const char * const rom_probe_types[] = {\n\t\"cfi_probe\", \"jedec_probe\", \"qinfo_probe\", \"map_rom\",\n};\n\nstatic const char * const part_probe_types[] = {\n\t\"cmdlinepart\", \"RedBoot\", \"afs\", NULL\n};\n\nstatic int physmap_flash_pdata_init(struct platform_device *dev)\n{\n\tstruct physmap_flash_info *info = platform_get_drvdata(dev);\n\tstruct physmap_flash_data *physmap_data;\n\tunsigned int i;\n\tint err;\n\n\tphysmap_data = dev_get_platdata(&dev->dev);\n\tif (!physmap_data)\n\t\treturn -EINVAL;\n\n\tinfo->probe_type = physmap_data->probe_type;\n\tinfo->part_types = physmap_data->part_probe_types ? : part_probe_types;\n\tinfo->parts = physmap_data->parts;\n\tinfo->nparts = physmap_data->nr_parts;\n\n\tif (physmap_data->init) {\n\t\terr = physmap_data->init(dev);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tfor (i = 0; i < info->nmaps; i++) {\n\t\tinfo->maps[i].bankwidth = physmap_data->width;\n\t\tinfo->maps[i].pfow_base = physmap_data->pfow_base;\n\t\tinfo->maps[i].set_vpp = physmap_set_vpp;\n\t}\n\n\treturn 0;\n}\n\nstatic int physmap_flash_probe(struct platform_device *dev)\n{\n\tstruct physmap_flash_info *info;\n\tint err = 0;\n\tint i;\n\n\tif (!dev->dev.of_node && !dev_get_platdata(&dev->dev))\n\t\treturn -EINVAL;\n\n\tinfo = devm_kzalloc(&dev->dev, sizeof(*info), GFP_KERNEL);\n\tif (!info)\n\t\treturn -ENOMEM;\n\n\twhile (platform_get_resource(dev, IORESOURCE_MEM, info->nmaps))\n\t\tinfo->nmaps++;\n\n\tif (!info->nmaps)\n\t\treturn -ENODEV;\n\n\tinfo->maps = devm_kzalloc(&dev->dev,\n\t\t\t\t  sizeof(*info->maps) * info->nmaps,\n\t\t\t\t  GFP_KERNEL);\n\tif (!info->maps)\n\t\treturn -ENOMEM;\n\n\tinfo->mtds = devm_kzalloc(&dev->dev,\n\t\t\t\t  sizeof(*info->mtds) * info->nmaps,\n\t\t\t\t  GFP_KERNEL);\n\tif (!info->mtds)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(dev, info);\n\n\tinfo->gpios = devm_gpiod_get_array_optional(&dev->dev, \"addr\",\n\t\t\t\t\t\t    GPIOD_OUT_LOW);\n\tif (IS_ERR(info->gpios))\n\t\treturn PTR_ERR(info->gpios);\n\n\tif (info->gpios && info->nmaps > 1) {\n\t\tdev_err(&dev->dev, \"addr-gpios only supported for nmaps == 1\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tpm_runtime_enable(&dev->dev);\n\tpm_runtime_get_sync(&dev->dev);\n\n\tif (dev->dev.of_node)\n\t\terr = physmap_flash_of_init(dev);\n\telse\n\t\terr = physmap_flash_pdata_init(dev);\n\n\tif (err) {\n\t\tpm_runtime_put(&dev->dev);\n\t\tpm_runtime_disable(&dev->dev);\n\t\treturn err;\n\t}\n\n\tfor (i = 0; i < info->nmaps; i++) {\n\t\tstruct resource *res;\n\n\t\tinfo->maps[i].virt = devm_platform_get_and_ioremap_resource(dev, i, &res);\n\t\tif (IS_ERR(info->maps[i].virt)) {\n\t\t\terr = PTR_ERR(info->maps[i].virt);\n\t\t\tgoto err_out;\n\t\t}\n\n\t\tdev_notice(&dev->dev, \"physmap platform flash device: %pR\\n\",\n\t\t\t   res);\n\n\t\tif (!info->maps[i].name)\n\t\t\tinfo->maps[i].name = dev_name(&dev->dev);\n\n\t\tif (!info->maps[i].phys)\n\t\t\tinfo->maps[i].phys = res->start;\n\n\t\tinfo->win_order = get_bitmask_order(resource_size(res)) - 1;\n\t\tinfo->maps[i].size = BIT(info->win_order +\n\t\t\t\t\t (info->gpios ?\n\t\t\t\t\t  info->gpios->ndescs : 0));\n\n\t\tinfo->maps[i].map_priv_1 = (unsigned long)dev;\n\n\t\tif (info->gpios) {\n\t\t\terr = physmap_addr_gpios_map_init(&info->maps[i]);\n\t\t\tif (err)\n\t\t\t\tgoto err_out;\n\t\t}\n\n#ifdef CONFIG_MTD_COMPLEX_MAPPINGS\n\t\t \n\t\tif (!info->maps[i].read)\n\t\t\tsimple_map_init(&info->maps[i]);\n#else\n\t\tsimple_map_init(&info->maps[i]);\n#endif\n\n\t\tif (info->probe_type) {\n\t\t\tinfo->mtds[i] = do_map_probe(info->probe_type,\n\t\t\t\t\t\t     &info->maps[i]);\n\n\t\t\t \n\t\t\tif (!info->mtds[i] && IS_ENABLED(CONFIG_MTD_ROM) &&\n\t\t\t    strcmp(info->probe_type, \"map_rom\")) {\n\t\t\t\tdev_warn(&dev->dev,\n\t\t\t\t\t \"map_probe() failed for type %s\\n\",\n\t\t\t\t\t info->probe_type);\n\n\t\t\t\tinfo->mtds[i] = do_map_probe(\"map_rom\",\n\t\t\t\t\t\t\t     &info->maps[i]);\n\t\t\t}\n\t\t} else {\n\t\t\tint j;\n\n\t\t\tfor (j = 0; j < ARRAY_SIZE(rom_probe_types); j++) {\n\t\t\t\tinfo->mtds[i] = do_map_probe(rom_probe_types[j],\n\t\t\t\t\t\t\t     &info->maps[i]);\n\t\t\t\tif (info->mtds[i])\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!info->mtds[i]) {\n\t\t\tdev_err(&dev->dev, \"map_probe failed\\n\");\n\t\t\terr = -ENXIO;\n\t\t\tgoto err_out;\n\t\t}\n\t\tinfo->mtds[i]->dev.parent = &dev->dev;\n\t}\n\n\tif (info->nmaps == 1) {\n\t\tinfo->cmtd = info->mtds[0];\n\t} else {\n\t\t \n\t\tinfo->cmtd = mtd_concat_create(info->mtds, info->nmaps,\n\t\t\t\t\t       dev_name(&dev->dev));\n\t\tif (!info->cmtd)\n\t\t\terr = -ENXIO;\n\t}\n\tif (err)\n\t\tgoto err_out;\n\n\tspin_lock_init(&info->vpp_lock);\n\n\tmtd_set_of_node(info->cmtd, dev->dev.of_node);\n\terr = mtd_device_parse_register(info->cmtd, info->part_types, NULL,\n\t\t\t\t\tinfo->parts, info->nparts);\n\tif (err)\n\t\tgoto err_out;\n\n\treturn 0;\n\nerr_out:\n\tphysmap_flash_remove(dev);\n\treturn err;\n}\n\n#ifdef CONFIG_PM\nstatic void physmap_flash_shutdown(struct platform_device *dev)\n{\n\tstruct physmap_flash_info *info = platform_get_drvdata(dev);\n\tint i;\n\n\tfor (i = 0; i < info->nmaps && info->mtds[i]; i++)\n\t\tif (mtd_suspend(info->mtds[i]) == 0)\n\t\t\tmtd_resume(info->mtds[i]);\n}\n#else\n#define physmap_flash_shutdown NULL\n#endif\n\nstatic struct platform_driver physmap_flash_driver = {\n\t.probe\t\t= physmap_flash_probe,\n\t.remove\t\t= physmap_flash_remove,\n\t.shutdown\t= physmap_flash_shutdown,\n\t.driver\t\t= {\n\t\t.name\t= \"physmap-flash\",\n\t\t.of_match_table = of_flash_match,\n\t},\n};\n\n#ifdef CONFIG_MTD_PHYSMAP_COMPAT\nstatic struct physmap_flash_data physmap_flash_data = {\n\t.width\t\t= CONFIG_MTD_PHYSMAP_BANKWIDTH,\n};\n\nstatic struct resource physmap_flash_resource = {\n\t.start\t\t= CONFIG_MTD_PHYSMAP_START,\n\t.end\t\t= CONFIG_MTD_PHYSMAP_START + CONFIG_MTD_PHYSMAP_LEN - 1,\n\t.flags\t\t= IORESOURCE_MEM,\n};\n\nstatic struct platform_device physmap_flash = {\n\t.name\t\t= \"physmap-flash\",\n\t.id\t\t= 0,\n\t.dev\t\t= {\n\t\t.platform_data\t= &physmap_flash_data,\n\t},\n\t.num_resources\t= 1,\n\t.resource\t= &physmap_flash_resource,\n};\n#endif\n\nstatic int __init physmap_init(void)\n{\n\tint err;\n\n\terr = platform_driver_register(&physmap_flash_driver);\n#ifdef CONFIG_MTD_PHYSMAP_COMPAT\n\tif (err == 0) {\n\t\terr = platform_device_register(&physmap_flash);\n\t\tif (err)\n\t\t\tplatform_driver_unregister(&physmap_flash_driver);\n\t}\n#endif\n\n\treturn err;\n}\n\nstatic void __exit physmap_exit(void)\n{\n#ifdef CONFIG_MTD_PHYSMAP_COMPAT\n\tplatform_device_unregister(&physmap_flash);\n#endif\n\tplatform_driver_unregister(&physmap_flash_driver);\n}\n\nmodule_init(physmap_init);\nmodule_exit(physmap_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"David Woodhouse <dwmw2@infradead.org>\");\nMODULE_AUTHOR(\"Vitaly Wool <vwool@ru.mvista.com>\");\nMODULE_AUTHOR(\"Mike Frysinger <vapier@gentoo.org>\");\nMODULE_DESCRIPTION(\"Generic configurable MTD map driver\");\n\n \n#ifndef CONFIG_MTD_PHYSMAP_COMPAT\n \nMODULE_ALIAS(\"platform:physmap-flash\");\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}