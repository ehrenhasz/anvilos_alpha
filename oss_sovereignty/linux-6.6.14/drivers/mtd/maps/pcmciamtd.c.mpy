{
  "module_name": "pcmciamtd.c",
  "hash_id": "b19af32a40c2a3e5e8e3fa4d575fe95ef3e54e8418482851302353fc0a1c9b9b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/maps/pcmciamtd.c",
  "human_readable_source": " \n\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/timer.h>\n#include <linux/init.h>\n#include <asm/io.h>\n\n#include <pcmcia/cistpl.h>\n#include <pcmcia/ds.h>\n\n#include <linux/mtd/map.h>\n#include <linux/mtd/mtd.h>\n\n#define info(format, arg...) printk(KERN_INFO \"pcmciamtd: \" format \"\\n\" , ## arg)\n\n#define DRIVER_DESC\t\"PCMCIA Flash memory card driver\"\n\n \n#define MAX_PCMCIA_ADDR\t0x4000000\n\nstruct pcmciamtd_dev {\n\tstruct pcmcia_device\t*p_dev;\n\tvoid __iomem\t*win_base;\t \n\tunsigned int\twin_size;\t \n\tunsigned int\toffset;\t\t \n\tstruct map_info\tpcmcia_map;\n\tstruct mtd_info\t*mtd_info;\n\tint\t\tvpp;\n\tchar\t\tmtd_name[sizeof(struct cistpl_vers_1_t)];\n};\n\n\n \n\n \nstatic int bankwidth = 2;\n\n \nstatic int mem_speed;\n\n \nstatic int force_size;\n\n \nstatic int vpp;\n\n \nstatic int setvpp;\n\n \nstatic int mem_type;\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Simon Evans <spse@secret.org.uk>\");\nMODULE_DESCRIPTION(DRIVER_DESC);\nmodule_param(bankwidth, int, 0);\nMODULE_PARM_DESC(bankwidth, \"Set bankwidth (1=8 bit, 2=16 bit, default=2)\");\nmodule_param(mem_speed, int, 0);\nMODULE_PARM_DESC(mem_speed, \"Set memory access speed in ns\");\nmodule_param(force_size, int, 0);\nMODULE_PARM_DESC(force_size, \"Force size of card in MiB (1-64)\");\nmodule_param(setvpp, int, 0);\nMODULE_PARM_DESC(setvpp, \"Set Vpp (0=Never, 1=On writes, 2=Always on, default=0)\");\nmodule_param(vpp, int, 0);\nMODULE_PARM_DESC(vpp, \"Vpp value in 1/10ths eg 33=3.3V 120=12V (Dangerous)\");\nmodule_param(mem_type, int, 0);\nMODULE_PARM_DESC(mem_type, \"Set Memory type (0=Flash, 1=RAM, 2=ROM, default=0)\");\n\n\n \nstatic void __iomem *remap_window(struct map_info *map, unsigned long to)\n{\n\tstruct pcmciamtd_dev *dev = (struct pcmciamtd_dev *)map->map_priv_1;\n\tstruct resource *win = (struct resource *) map->map_priv_2;\n\tunsigned int offset;\n\tint ret;\n\n\tif (!pcmcia_dev_present(dev->p_dev)) {\n\t\tpr_debug(\"device removed\\n\");\n\t\treturn NULL;\n\t}\n\n\toffset = to & ~(dev->win_size-1);\n\tif (offset != dev->offset) {\n\t\tpr_debug(\"Remapping window from 0x%8.8x to 0x%8.8x\\n\",\n\t\t      dev->offset, offset);\n\t\tret = pcmcia_map_mem_page(dev->p_dev, win, offset);\n\t\tif (ret != 0)\n\t\t\treturn NULL;\n\t\tdev->offset = offset;\n\t}\n\treturn dev->win_base + (to & (dev->win_size-1));\n}\n\n\nstatic map_word pcmcia_read8_remap(struct map_info *map, unsigned long ofs)\n{\n\tvoid __iomem *addr;\n\tmap_word d = {{0}};\n\n\taddr = remap_window(map, ofs);\n\tif(!addr)\n\t\treturn d;\n\n\td.x[0] = readb(addr);\n\tpr_debug(\"ofs = 0x%08lx (%p) data = 0x%02lx\\n\", ofs, addr, d.x[0]);\n\treturn d;\n}\n\n\nstatic map_word pcmcia_read16_remap(struct map_info *map, unsigned long ofs)\n{\n\tvoid __iomem *addr;\n\tmap_word d = {{0}};\n\n\taddr = remap_window(map, ofs);\n\tif(!addr)\n\t\treturn d;\n\n\td.x[0] = readw(addr);\n\tpr_debug(\"ofs = 0x%08lx (%p) data = 0x%04lx\\n\", ofs, addr, d.x[0]);\n\treturn d;\n}\n\n\nstatic void pcmcia_copy_from_remap(struct map_info *map, void *to, unsigned long from, ssize_t len)\n{\n\tstruct pcmciamtd_dev *dev = (struct pcmciamtd_dev *)map->map_priv_1;\n\tunsigned long win_size = dev->win_size;\n\n\tpr_debug(\"to = %p from = %lu len = %zd\\n\", to, from, len);\n\twhile(len) {\n\t\tint toread = win_size - (from & (win_size-1));\n\t\tvoid __iomem *addr;\n\n\t\tif(toread > len)\n\t\t\ttoread = len;\n\n\t\taddr = remap_window(map, from);\n\t\tif(!addr)\n\t\t\treturn;\n\n\t\tpr_debug(\"memcpy from %p to %p len = %d\\n\", addr, to, toread);\n\t\tmemcpy_fromio(to, addr, toread);\n\t\tlen -= toread;\n\t\tto += toread;\n\t\tfrom += toread;\n\t}\n}\n\n\nstatic void pcmcia_write8_remap(struct map_info *map, map_word d, unsigned long adr)\n{\n\tvoid __iomem *addr = remap_window(map, adr);\n\n\tif(!addr)\n\t\treturn;\n\n\tpr_debug(\"adr = 0x%08lx (%p)  data = 0x%02lx\\n\", adr, addr, d.x[0]);\n\twriteb(d.x[0], addr);\n}\n\n\nstatic void pcmcia_write16_remap(struct map_info *map, map_word d, unsigned long adr)\n{\n\tvoid __iomem *addr = remap_window(map, adr);\n\tif(!addr)\n\t\treturn;\n\n\tpr_debug(\"adr = 0x%08lx (%p)  data = 0x%04lx\\n\", adr, addr, d.x[0]);\n\twritew(d.x[0], addr);\n}\n\n\nstatic void pcmcia_copy_to_remap(struct map_info *map, unsigned long to, const void *from, ssize_t len)\n{\n\tstruct pcmciamtd_dev *dev = (struct pcmciamtd_dev *)map->map_priv_1;\n\tunsigned long win_size = dev->win_size;\n\n\tpr_debug(\"to = %lu from = %p len = %zd\\n\", to, from, len);\n\twhile(len) {\n\t\tint towrite = win_size - (to & (win_size-1));\n\t\tvoid __iomem *addr;\n\n\t\tif(towrite > len)\n\t\t\ttowrite = len;\n\n\t\taddr = remap_window(map, to);\n\t\tif(!addr)\n\t\t\treturn;\n\n\t\tpr_debug(\"memcpy from %p to %p len = %d\\n\", from, addr, towrite);\n\t\tmemcpy_toio(addr, from, towrite);\n\t\tlen -= towrite;\n\t\tto += towrite;\n\t\tfrom += towrite;\n\t}\n}\n\n\n \n\n#define DEV_REMOVED(x)  (!(pcmcia_dev_present(((struct pcmciamtd_dev *)map->map_priv_1)->p_dev)))\n\nstatic map_word pcmcia_read8(struct map_info *map, unsigned long ofs)\n{\n\tvoid __iomem *win_base = (void __iomem *)map->map_priv_2;\n\tmap_word d = {{0}};\n\n\tif(DEV_REMOVED(map))\n\t\treturn d;\n\n\td.x[0] = readb(win_base + ofs);\n\tpr_debug(\"ofs = 0x%08lx (%p) data = 0x%02lx\\n\",\n\t      ofs, win_base + ofs, d.x[0]);\n\treturn d;\n}\n\n\nstatic map_word pcmcia_read16(struct map_info *map, unsigned long ofs)\n{\n\tvoid __iomem *win_base = (void __iomem *)map->map_priv_2;\n\tmap_word d = {{0}};\n\n\tif(DEV_REMOVED(map))\n\t\treturn d;\n\n\td.x[0] = readw(win_base + ofs);\n\tpr_debug(\"ofs = 0x%08lx (%p) data = 0x%04lx\\n\",\n\t      ofs, win_base + ofs, d.x[0]);\n\treturn d;\n}\n\n\nstatic void pcmcia_copy_from(struct map_info *map, void *to, unsigned long from, ssize_t len)\n{\n\tvoid __iomem *win_base = (void __iomem *)map->map_priv_2;\n\n\tif(DEV_REMOVED(map))\n\t\treturn;\n\n\tpr_debug(\"to = %p from = %lu len = %zd\\n\", to, from, len);\n\tmemcpy_fromio(to, win_base + from, len);\n}\n\n\nstatic void pcmcia_write8(struct map_info *map, map_word d, unsigned long adr)\n{\n\tvoid __iomem *win_base = (void __iomem *)map->map_priv_2;\n\n\tif(DEV_REMOVED(map))\n\t\treturn;\n\n\tpr_debug(\"adr = 0x%08lx (%p)  data = 0x%02lx\\n\",\n\t      adr, win_base + adr, d.x[0]);\n\twriteb(d.x[0], win_base + adr);\n}\n\n\nstatic void pcmcia_write16(struct map_info *map, map_word d, unsigned long adr)\n{\n\tvoid __iomem *win_base = (void __iomem *)map->map_priv_2;\n\n\tif(DEV_REMOVED(map))\n\t\treturn;\n\n\tpr_debug(\"adr = 0x%08lx (%p)  data = 0x%04lx\\n\",\n\t      adr, win_base + adr, d.x[0]);\n\twritew(d.x[0], win_base + adr);\n}\n\n\nstatic void pcmcia_copy_to(struct map_info *map, unsigned long to, const void *from, ssize_t len)\n{\n\tvoid __iomem *win_base = (void __iomem *)map->map_priv_2;\n\n\tif(DEV_REMOVED(map))\n\t\treturn;\n\n\tpr_debug(\"to = %lu from = %p len = %zd\\n\", to, from, len);\n\tmemcpy_toio(win_base + to, from, len);\n}\n\n\nstatic DEFINE_MUTEX(pcmcia_vpp_lock);\nstatic int pcmcia_vpp_refcnt;\nstatic void pcmciamtd_set_vpp(struct map_info *map, int on)\n{\n\tstruct pcmciamtd_dev *dev = (struct pcmciamtd_dev *)map->map_priv_1;\n\tstruct pcmcia_device *link = dev->p_dev;\n\n\tpr_debug(\"dev = %p on = %d vpp = %d\\n\\n\", dev, on, dev->vpp);\n\tmutex_lock(&pcmcia_vpp_lock);\n\tif (on) {\n\t\tif (++pcmcia_vpp_refcnt == 1)    \n\t\t\tpcmcia_fixup_vpp(link, dev->vpp);\n\t} else {\n\t\tif (--pcmcia_vpp_refcnt == 0)    \n\t\t\tpcmcia_fixup_vpp(link, 0);\n\t}\n\tmutex_unlock(&pcmcia_vpp_lock);\n}\n\n\nstatic void pcmciamtd_release(struct pcmcia_device *link)\n{\n\tstruct pcmciamtd_dev *dev = link->priv;\n\n\tpr_debug(\"link = 0x%p\\n\", link);\n\n\tif (link->resource[2]->end) {\n\t\tif(dev->win_base) {\n\t\t\tiounmap(dev->win_base);\n\t\t\tdev->win_base = NULL;\n\t\t}\n\t}\n\tpcmcia_disable_device(link);\n}\n\n\nstatic int pcmciamtd_cistpl_format(struct pcmcia_device *p_dev,\n\t\t\t\ttuple_t *tuple,\n\t\t\t\tvoid *priv_data)\n{\n\tcisparse_t parse;\n\n\tif (!pcmcia_parse_tuple(tuple, &parse)) {\n\t\tcistpl_format_t *t = &parse.format;\n\t\t(void)t;  \n\t\tpr_debug(\"Format type: %u, Error Detection: %u, offset = %u, length =%u\\n\",\n\t\t\tt->type, t->edc, t->offset, t->length);\n\t}\n\treturn -ENOSPC;\n}\n\nstatic int pcmciamtd_cistpl_jedec(struct pcmcia_device *p_dev,\n\t\t\t\ttuple_t *tuple,\n\t\t\t\tvoid *priv_data)\n{\n\tcisparse_t parse;\n\tint i;\n\n\tif (!pcmcia_parse_tuple(tuple, &parse)) {\n\t\tcistpl_jedec_t *t = &parse.jedec;\n\t\tfor (i = 0; i < t->nid; i++)\n\t\t\tpr_debug(\"JEDEC: 0x%02x 0x%02x\\n\",\n\t\t\t      t->id[i].mfr, t->id[i].info);\n\t}\n\treturn -ENOSPC;\n}\n\nstatic int pcmciamtd_cistpl_device(struct pcmcia_device *p_dev,\n\t\t\t\ttuple_t *tuple,\n\t\t\t\tvoid *priv_data)\n{\n\tstruct pcmciamtd_dev *dev = priv_data;\n\tcisparse_t parse;\n\tcistpl_device_t *t = &parse.device;\n\tint i;\n\n\tif (pcmcia_parse_tuple(tuple, &parse))\n\t\treturn -EINVAL;\n\n\tpr_debug(\"Common memory:\\n\");\n\tdev->pcmcia_map.size = t->dev[0].size;\n\t \n\tfor (i = 0; i < t->ndev; i++) {\n\t\tpr_debug(\"Region %d, type = %u\\n\", i, t->dev[i].type);\n\t\tpr_debug(\"Region %d, wp = %u\\n\", i, t->dev[i].wp);\n\t\tpr_debug(\"Region %d, speed = %u ns\\n\", i, t->dev[i].speed);\n\t\tpr_debug(\"Region %d, size = %u bytes\\n\", i, t->dev[i].size);\n\t}\n\treturn 0;\n}\n\nstatic int pcmciamtd_cistpl_geo(struct pcmcia_device *p_dev,\n\t\t\t\ttuple_t *tuple,\n\t\t\t\tvoid *priv_data)\n{\n\tstruct pcmciamtd_dev *dev = priv_data;\n\tcisparse_t parse;\n\tcistpl_device_geo_t *t = &parse.device_geo;\n\tint i;\n\n\tif (pcmcia_parse_tuple(tuple, &parse))\n\t\treturn -EINVAL;\n\n\tdev->pcmcia_map.bankwidth = t->geo[0].buswidth;\n\t \n\tfor (i = 0; i < t->ngeo; i++) {\n\t\tpr_debug(\"region: %d bankwidth = %u\\n\", i, t->geo[i].buswidth);\n\t\tpr_debug(\"region: %d erase_block = %u\\n\", i, t->geo[i].erase_block);\n\t\tpr_debug(\"region: %d read_block = %u\\n\", i, t->geo[i].read_block);\n\t\tpr_debug(\"region: %d write_block = %u\\n\", i, t->geo[i].write_block);\n\t\tpr_debug(\"region: %d partition = %u\\n\", i, t->geo[i].partition);\n\t\tpr_debug(\"region: %d interleave = %u\\n\", i, t->geo[i].interleave);\n\t}\n\treturn 0;\n}\n\n\nstatic void card_settings(struct pcmciamtd_dev *dev, struct pcmcia_device *p_dev, int *new_name)\n{\n\tint i;\n\n\tif (p_dev->prod_id[0]) {\n\t\tdev->mtd_name[0] = '\\0';\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tif (i)\n\t\t\t\tstrcat(dev->mtd_name, \" \");\n\t\t\tif (p_dev->prod_id[i])\n\t\t\t\tstrcat(dev->mtd_name, p_dev->prod_id[i]);\n\t\t}\n\t\tpr_debug(\"Found name: %s\\n\", dev->mtd_name);\n\t}\n\n\tpcmcia_loop_tuple(p_dev, CISTPL_FORMAT, pcmciamtd_cistpl_format, NULL);\n\tpcmcia_loop_tuple(p_dev, CISTPL_JEDEC_C, pcmciamtd_cistpl_jedec, NULL);\n\tpcmcia_loop_tuple(p_dev, CISTPL_DEVICE, pcmciamtd_cistpl_device, dev);\n\tpcmcia_loop_tuple(p_dev, CISTPL_DEVICE_GEO, pcmciamtd_cistpl_geo, dev);\n\n\tif(!dev->pcmcia_map.size)\n\t\tdev->pcmcia_map.size = MAX_PCMCIA_ADDR;\n\n\tif(!dev->pcmcia_map.bankwidth)\n\t\tdev->pcmcia_map.bankwidth = 2;\n\n\tif(force_size) {\n\t\tdev->pcmcia_map.size = force_size << 20;\n\t\tpr_debug(\"size forced to %dM\\n\", force_size);\n\t}\n\n\tif(bankwidth) {\n\t\tdev->pcmcia_map.bankwidth = bankwidth;\n\t\tpr_debug(\"bankwidth forced to %d\\n\", bankwidth);\n\t}\n\n\tdev->pcmcia_map.name = dev->mtd_name;\n\tif(!dev->mtd_name[0]) {\n\t\tstrcpy(dev->mtd_name, \"PCMCIA Memory card\");\n\t\t*new_name = 1;\n\t}\n\n\tpr_debug(\"Device: Size: %lu Width:%d Name: %s\\n\",\n\t      dev->pcmcia_map.size,\n\t      dev->pcmcia_map.bankwidth << 3, dev->mtd_name);\n}\n\n\nstatic int pcmciamtd_config(struct pcmcia_device *link)\n{\n\tstruct pcmciamtd_dev *dev = link->priv;\n\tstruct mtd_info *mtd = NULL;\n\tint ret;\n\tint i, j = 0;\n\tstatic char *probes[] = { \"jedec_probe\", \"cfi_probe\" };\n\tint new_name = 0;\n\n\tpr_debug(\"link=0x%p\\n\", link);\n\n\tcard_settings(dev, link, &new_name);\n\n\tdev->pcmcia_map.phys = NO_XIP;\n\tdev->pcmcia_map.copy_from = pcmcia_copy_from_remap;\n\tdev->pcmcia_map.copy_to = pcmcia_copy_to_remap;\n\tif (dev->pcmcia_map.bankwidth == 1) {\n\t\tdev->pcmcia_map.read = pcmcia_read8_remap;\n\t\tdev->pcmcia_map.write = pcmcia_write8_remap;\n\t} else {\n\t\tdev->pcmcia_map.read = pcmcia_read16_remap;\n\t\tdev->pcmcia_map.write = pcmcia_write16_remap;\n\t}\n\tif(setvpp == 1)\n\t\tdev->pcmcia_map.set_vpp = pcmciamtd_set_vpp;\n\n\t \n\n\tlink->resource[2]->flags |=  WIN_MEMORY_TYPE_CM | WIN_ENABLE;\n\tlink->resource[2]->flags |= (dev->pcmcia_map.bankwidth == 1) ?\n\t\t\t\t\tWIN_DATA_WIDTH_8 : WIN_DATA_WIDTH_16;\n\tlink->resource[2]->start = 0;\n\tlink->resource[2]->end = (force_size) ? force_size << 20 :\n\t\t\t\t\tMAX_PCMCIA_ADDR;\n\tdev->win_size = 0;\n\n\tdo {\n\t\tint ret;\n\t\tpr_debug(\"requesting window with size = %luKiB memspeed = %d\\n\",\n\t\t\t(unsigned long) resource_size(link->resource[2]) >> 10,\n\t\t\tmem_speed);\n\t\tret = pcmcia_request_window(link, link->resource[2], mem_speed);\n\t\tpr_debug(\"ret = %d dev->win_size = %d\\n\", ret, dev->win_size);\n\t\tif(ret) {\n\t\t\tj++;\n\t\t\tlink->resource[2]->start = 0;\n\t\t\tlink->resource[2]->end = (force_size) ?\n\t\t\t\t\tforce_size << 20 : MAX_PCMCIA_ADDR;\n\t\t\tlink->resource[2]->end >>= j;\n\t\t} else {\n\t\t\tpr_debug(\"Got window of size %luKiB\\n\", (unsigned long)\n\t\t\t\tresource_size(link->resource[2]) >> 10);\n\t\t\tdev->win_size = resource_size(link->resource[2]);\n\t\t\tbreak;\n\t\t}\n\t} while (link->resource[2]->end >= 0x1000);\n\n\tpr_debug(\"dev->win_size = %d\\n\", dev->win_size);\n\n\tif(!dev->win_size) {\n\t\tdev_err(&dev->p_dev->dev, \"Cannot allocate memory window\\n\");\n\t\tpcmciamtd_release(link);\n\t\treturn -ENODEV;\n\t}\n\tpr_debug(\"Allocated a window of %dKiB\\n\", dev->win_size >> 10);\n\n\t \n\tdev->win_base = ioremap(link->resource[2]->start,\n\t\t\t\tresource_size(link->resource[2]));\n\tif(!dev->win_base) {\n\t\tdev_err(&dev->p_dev->dev, \"ioremap(%pR) failed\\n\",\n\t\t\tlink->resource[2]);\n\t\tpcmciamtd_release(link);\n\t\treturn -ENODEV;\n\t}\n\tpr_debug(\"mapped window dev = %p @ %pR, base = %p\\n\",\n\t      dev, link->resource[2], dev->win_base);\n\n\tdev->offset = 0;\n\tdev->pcmcia_map.map_priv_1 = (unsigned long)dev;\n\tdev->pcmcia_map.map_priv_2 = (unsigned long)link->resource[2];\n\n\tdev->vpp = (vpp) ? vpp : link->socket->socket.Vpp;\n\tif(setvpp == 2) {\n\t\tlink->vpp = dev->vpp;\n\t} else {\n\t\tlink->vpp = 0;\n\t}\n\n\tlink->config_index = 0;\n\tpr_debug(\"Setting Configuration\\n\");\n\tret = pcmcia_enable_device(link);\n\tif (ret != 0) {\n\t\tif (dev->win_base) {\n\t\t\tiounmap(dev->win_base);\n\t\t\tdev->win_base = NULL;\n\t\t}\n\t\treturn -ENODEV;\n\t}\n\n\tif(mem_type == 1) {\n\t\tmtd = do_map_probe(\"map_ram\", &dev->pcmcia_map);\n\t} else if(mem_type == 2) {\n\t\tmtd = do_map_probe(\"map_rom\", &dev->pcmcia_map);\n\t} else {\n\t\tfor(i = 0; i < ARRAY_SIZE(probes); i++) {\n\t\t\tpr_debug(\"Trying %s\\n\", probes[i]);\n\t\t\tmtd = do_map_probe(probes[i], &dev->pcmcia_map);\n\t\t\tif(mtd)\n\t\t\t\tbreak;\n\n\t\t\tpr_debug(\"FAILED: %s\\n\", probes[i]);\n\t\t}\n\t}\n\n\tif(!mtd) {\n\t\tpr_debug(\"Can not find an MTD\\n\");\n\t\tpcmciamtd_release(link);\n\t\treturn -ENODEV;\n\t}\n\n\tdev->mtd_info = mtd;\n\tmtd->owner = THIS_MODULE;\n\n\tif(new_name) {\n\t\tint size = 0;\n\t\tchar unit = ' ';\n\t\t \n\t\tif(mtd->size < 1048576) {  \n\t\t\tsize = mtd->size >> 10;\n\t\t\tunit = 'K';\n\t\t} else {\n\t\t\tsize = mtd->size >> 20;\n\t\t\tunit = 'M';\n\t\t}\n\t\tsnprintf(dev->mtd_name, sizeof(dev->mtd_name), \"%d%ciB %s\", size, unit, \"PCMCIA Memory card\");\n\t}\n\n\t \n\tif(mtd->size <= dev->win_size) {\n\t\tpr_debug(\"Using non remapping memory functions\\n\");\n\t\tdev->pcmcia_map.map_priv_2 = (unsigned long)dev->win_base;\n\t\tif (dev->pcmcia_map.bankwidth == 1) {\n\t\t\tdev->pcmcia_map.read = pcmcia_read8;\n\t\t\tdev->pcmcia_map.write = pcmcia_write8;\n\t\t} else {\n\t\t\tdev->pcmcia_map.read = pcmcia_read16;\n\t\t\tdev->pcmcia_map.write = pcmcia_write16;\n\t\t}\n\t\tdev->pcmcia_map.copy_from = pcmcia_copy_from;\n\t\tdev->pcmcia_map.copy_to = pcmcia_copy_to;\n\t}\n\n\tif (mtd_device_register(mtd, NULL, 0)) {\n\t\tmap_destroy(mtd);\n\t\tdev->mtd_info = NULL;\n\t\tdev_err(&dev->p_dev->dev,\n\t\t\t\"Could not register the MTD device\\n\");\n\t\tpcmciamtd_release(link);\n\t\treturn -ENODEV;\n\t}\n\tdev_info(&dev->p_dev->dev, \"mtd%d: %s\\n\", mtd->index, mtd->name);\n\treturn 0;\n}\n\n\nstatic int pcmciamtd_suspend(struct pcmcia_device *dev)\n{\n\tpr_debug(\"EVENT_PM_RESUME\\n\");\n\n\t \n\n\treturn 0;\n}\n\nstatic int pcmciamtd_resume(struct pcmcia_device *dev)\n{\n\tpr_debug(\"EVENT_PM_SUSPEND\\n\");\n\n\t \n\n\treturn 0;\n}\n\n\nstatic void pcmciamtd_detach(struct pcmcia_device *link)\n{\n\tstruct pcmciamtd_dev *dev = link->priv;\n\n\tpr_debug(\"link=0x%p\\n\", link);\n\n\tif(dev->mtd_info) {\n\t\tmtd_device_unregister(dev->mtd_info);\n\t\tdev_info(&dev->p_dev->dev, \"mtd%d: Removing\\n\",\n\t\t\t dev->mtd_info->index);\n\t\tmap_destroy(dev->mtd_info);\n\t}\n\n\tpcmciamtd_release(link);\n}\n\n\nstatic int pcmciamtd_probe(struct pcmcia_device *link)\n{\n\tstruct pcmciamtd_dev *dev;\n\n\t \n\tdev = kzalloc(sizeof(*dev), GFP_KERNEL);\n\tif (!dev) return -ENOMEM;\n\tpr_debug(\"dev=0x%p\\n\", dev);\n\n\tdev->p_dev = link;\n\tlink->priv = dev;\n\n\treturn pcmciamtd_config(link);\n}\n\nstatic const struct pcmcia_device_id pcmciamtd_ids[] = {\n\tPCMCIA_DEVICE_FUNC_ID(1),\n\tPCMCIA_DEVICE_PROD_ID123(\"IO DATA\", \"PCS-2M\", \"2MB SRAM\", 0x547e66dc, 0x1fed36cd, 0x36eadd21),\n\tPCMCIA_DEVICE_PROD_ID12(\"IBM\", \"2MB SRAM\", 0xb569a6e5, 0x36eadd21),\n\tPCMCIA_DEVICE_PROD_ID12(\"IBM\", \"4MB FLASH\", 0xb569a6e5, 0x8bc54d2a),\n\tPCMCIA_DEVICE_PROD_ID12(\"IBM\", \"8MB FLASH\", 0xb569a6e5, 0x6df1be3e),\n\tPCMCIA_DEVICE_PROD_ID12(\"Intel\", \"S2E20SW\", 0x816cc815, 0xd14c9dcf),\n\tPCMCIA_DEVICE_PROD_ID12(\"Intel\", \"S2E8 SW\", 0x816cc815, 0xa2d7dedb),\n\tPCMCIA_DEVICE_PROD_ID12(\"intel\", \"SERIES2-02 \", 0x40ade711, 0x145cea5c),\n\tPCMCIA_DEVICE_PROD_ID12(\"intel\", \"SERIES2-04 \", 0x40ade711, 0x42064dda),\n\tPCMCIA_DEVICE_PROD_ID12(\"intel\", \"SERIES2-20 \", 0x40ade711, 0x25ee5cb0),\n\tPCMCIA_DEVICE_PROD_ID12(\"intel\", \"VALUE SERIES 100 \", 0x40ade711, 0xdf8506d8),\n\tPCMCIA_DEVICE_PROD_ID12(\"KINGMAX TECHNOLOGY INC.\", \"SRAM 256K Bytes\", 0x54d0c69c, 0xad12c29c),\n\tPCMCIA_DEVICE_PROD_ID12(\"Maxtor\", \"MAXFL MobileMax Flash Memory Card\", 0xb68968c8, 0x2dfb47b0),\n\tPCMCIA_DEVICE_PROD_ID123(\"M-Systems\", \"M-SYS Flash Memory Card\", \"(c) M-Systems\", 0x7ed2ad87, 0x675dc3fb, 0x7aef3965),\n\tPCMCIA_DEVICE_PROD_ID12(\"PRETEC\", \"  2MB SRAM CARD\", 0xebf91155, 0x805360ca),\n\tPCMCIA_DEVICE_PROD_ID12(\"PRETEC\", \"  4MB SRAM CARD\", 0xebf91155, 0x20b6bf17),\n\tPCMCIA_DEVICE_PROD_ID12(\"SEIKO EPSON\", \"WWB101EN20\", 0xf9876baf, 0xad0b207b),\n\tPCMCIA_DEVICE_PROD_ID12(\"SEIKO EPSON\", \"WWB513EN20\", 0xf9876baf, 0xe8d884ad),\n\tPCMCIA_DEVICE_PROD_ID12(\"SMART Modular Technologies\", \" 4MB FLASH Card\", 0x96fd8277, 0x737a5b05),\n\tPCMCIA_DEVICE_PROD_ID12(\"Starfish, Inc.\", \"REX-3000\", 0x05ddca47, 0xe7d67bca),\n\tPCMCIA_DEVICE_PROD_ID12(\"Starfish, Inc.\", \"REX-4100\", 0x05ddca47, 0x7bc32944),\n\t \n\t \n#ifdef CONFIG_MTD_PCMCIA_ANONYMOUS\n\t{ .match_flags = PCMCIA_DEV_ID_MATCH_ANONYMOUS, },\n#endif\n\tPCMCIA_DEVICE_NULL\n};\nMODULE_DEVICE_TABLE(pcmcia, pcmciamtd_ids);\n\nstatic struct pcmcia_driver pcmciamtd_driver = {\n\t.name\t\t= \"pcmciamtd\",\n\t.probe\t\t= pcmciamtd_probe,\n\t.remove\t\t= pcmciamtd_detach,\n\t.owner\t\t= THIS_MODULE,\n\t.id_table\t= pcmciamtd_ids,\n\t.suspend\t= pcmciamtd_suspend,\n\t.resume\t\t= pcmciamtd_resume,\n};\n\n\nstatic int __init init_pcmciamtd(void)\n{\n\tif(bankwidth && bankwidth != 1 && bankwidth != 2) {\n\t\tinfo(\"bad bankwidth (%d), using default\", bankwidth);\n\t\tbankwidth = 2;\n\t}\n\tif(force_size && (force_size < 1 || force_size > 64)) {\n\t\tinfo(\"bad force_size (%d), using default\", force_size);\n\t\tforce_size = 0;\n\t}\n\tif(mem_type && mem_type != 1 && mem_type != 2) {\n\t\tinfo(\"bad mem_type (%d), using default\", mem_type);\n\t\tmem_type = 0;\n\t}\n\treturn pcmcia_register_driver(&pcmciamtd_driver);\n}\n\n\nstatic void __exit exit_pcmciamtd(void)\n{\n\tpr_debug(DRIVER_DESC \" unloading\");\n\tpcmcia_unregister_driver(&pcmciamtd_driver);\n}\n\nmodule_init(init_pcmciamtd);\nmodule_exit(exit_pcmciamtd);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}