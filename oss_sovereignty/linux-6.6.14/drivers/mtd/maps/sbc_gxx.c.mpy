{
  "module_name": "sbc_gxx.c",
  "hash_id": "65b0235f0aad65915e61e2a97a3472e04428741035fb9d283b7d414b48c5f7e2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/maps/sbc_gxx.c",
  "human_readable_source": "\n \n\n\n\n#include <linux/module.h>\n#include <linux/ioport.h>\n#include <linux/init.h>\n#include <asm/io.h>\n\n#include <linux/mtd/mtd.h>\n#include <linux/mtd/map.h>\n#include <linux/mtd/partitions.h>\n\n\n\n\n\n#define WINDOW_START 0xdc000\n\n \n#define WINDOW_SHIFT 14\n#define WINDOW_LENGTH (1 << WINDOW_SHIFT)\n\n \n#define WINDOW_MASK (WINDOW_LENGTH-1)\n#define PAGE_IO 0x258\n#define PAGE_IO_SIZE 2\n\n \n#define DEVICE_ENABLE 0x8000\n\n\n\n#define MAX_SIZE_KiB             16384\n#define BOOT_PARTITION_SIZE_KiB  768\n#define DATA_PARTITION_SIZE_KiB  1280\n#define APP_PARTITION_SIZE_KiB   6144\n\n\n\nstatic volatile int page_in_window = -1; \nstatic void __iomem *iomapadr;\nstatic DEFINE_SPINLOCK(sbc_gxx_spin);\n\n \nstatic const struct mtd_partition partition_info[] = {\n    { .name = \"SBC-GXx flash boot partition\",\n      .offset = 0,\n      .size =   BOOT_PARTITION_SIZE_KiB*1024 },\n    { .name = \"SBC-GXx flash data partition\",\n      .offset = BOOT_PARTITION_SIZE_KiB*1024,\n      .size = (DATA_PARTITION_SIZE_KiB)*1024 },\n    { .name = \"SBC-GXx flash application partition\",\n      .offset = (BOOT_PARTITION_SIZE_KiB+DATA_PARTITION_SIZE_KiB)*1024 }\n};\n\n#define NUM_PARTITIONS 3\n\nstatic inline void sbc_gxx_page(struct map_info *map, unsigned long ofs)\n{\n\tunsigned long page = ofs >> WINDOW_SHIFT;\n\n\tif( page!=page_in_window ) {\n\t\toutw( page | DEVICE_ENABLE, PAGE_IO );\n\t\tpage_in_window = page;\n\t}\n}\n\n\nstatic map_word sbc_gxx_read8(struct map_info *map, unsigned long ofs)\n{\n\tmap_word ret;\n\tspin_lock(&sbc_gxx_spin);\n\tsbc_gxx_page(map, ofs);\n\tret.x[0] = readb(iomapadr + (ofs & WINDOW_MASK));\n\tspin_unlock(&sbc_gxx_spin);\n\treturn ret;\n}\n\nstatic void sbc_gxx_copy_from(struct map_info *map, void *to, unsigned long from, ssize_t len)\n{\n\twhile(len) {\n\t\tunsigned long thislen = len;\n\t\tif (len > (WINDOW_LENGTH - (from & WINDOW_MASK)))\n\t\t\tthislen = WINDOW_LENGTH-(from & WINDOW_MASK);\n\n\t\tspin_lock(&sbc_gxx_spin);\n\t\tsbc_gxx_page(map, from);\n\t\tmemcpy_fromio(to, iomapadr + (from & WINDOW_MASK), thislen);\n\t\tspin_unlock(&sbc_gxx_spin);\n\t\tto += thislen;\n\t\tfrom += thislen;\n\t\tlen -= thislen;\n\t}\n}\n\nstatic void sbc_gxx_write8(struct map_info *map, map_word d, unsigned long adr)\n{\n\tspin_lock(&sbc_gxx_spin);\n\tsbc_gxx_page(map, adr);\n\twriteb(d.x[0], iomapadr + (adr & WINDOW_MASK));\n\tspin_unlock(&sbc_gxx_spin);\n}\n\nstatic void sbc_gxx_copy_to(struct map_info *map, unsigned long to, const void *from, ssize_t len)\n{\n\twhile(len) {\n\t\tunsigned long thislen = len;\n\t\tif (len > (WINDOW_LENGTH - (to & WINDOW_MASK)))\n\t\t\tthislen = WINDOW_LENGTH-(to & WINDOW_MASK);\n\n\t\tspin_lock(&sbc_gxx_spin);\n\t\tsbc_gxx_page(map, to);\n\t\tmemcpy_toio(iomapadr + (to & WINDOW_MASK), from, thislen);\n\t\tspin_unlock(&sbc_gxx_spin);\n\t\tto += thislen;\n\t\tfrom += thislen;\n\t\tlen -= thislen;\n\t}\n}\n\nstatic struct map_info sbc_gxx_map = {\n\t.name = \"SBC-GXx flash\",\n\t.phys = NO_XIP,\n\t.size = MAX_SIZE_KiB*1024,  \n\t.bankwidth = 1,\n\t.read = sbc_gxx_read8,\n\t.copy_from = sbc_gxx_copy_from,\n\t.write = sbc_gxx_write8,\n\t.copy_to = sbc_gxx_copy_to\n};\n\n \nstatic struct mtd_info *all_mtd;\n\nstatic void cleanup_sbc_gxx(void)\n{\n\tif( all_mtd ) {\n\t\tmtd_device_unregister(all_mtd);\n\t\tmap_destroy( all_mtd );\n\t}\n\n\tiounmap(iomapadr);\n\trelease_region(PAGE_IO,PAGE_IO_SIZE);\n}\n\nstatic int __init init_sbc_gxx(void)\n{\n  \tiomapadr = ioremap(WINDOW_START, WINDOW_LENGTH);\n\tif (!iomapadr) {\n\t\tprintk( KERN_ERR\"%s: failed to ioremap memory region\\n\",\n\t\t\tsbc_gxx_map.name );\n\t\treturn -EIO;\n\t}\n\n\tif (!request_region( PAGE_IO, PAGE_IO_SIZE, \"SBC-GXx flash\")) {\n\t\tprintk( KERN_ERR\"%s: IO ports 0x%x-0x%x in use\\n\",\n\t\t\tsbc_gxx_map.name,\n\t\t\tPAGE_IO, PAGE_IO+PAGE_IO_SIZE-1 );\n\t\tiounmap(iomapadr);\n\t\treturn -EAGAIN;\n\t}\n\n\n\tprintk( KERN_INFO\"%s: IO:0x%x-0x%x MEM:0x%x-0x%x\\n\",\n\t\tsbc_gxx_map.name,\n\t\tPAGE_IO, PAGE_IO+PAGE_IO_SIZE-1,\n\t\tWINDOW_START, WINDOW_START+WINDOW_LENGTH-1 );\n\n\t \n\tall_mtd = do_map_probe( \"cfi_probe\", &sbc_gxx_map );\n\tif( !all_mtd ) {\n\t\tcleanup_sbc_gxx();\n\t\treturn -ENXIO;\n\t}\n\n\tall_mtd->owner = THIS_MODULE;\n\n\t \n\tmtd_device_register(all_mtd, partition_info, NUM_PARTITIONS);\n\n\treturn 0;\n}\n\nmodule_init(init_sbc_gxx);\nmodule_exit(cleanup_sbc_gxx);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Arcom Control Systems Ltd.\");\nMODULE_DESCRIPTION(\"MTD map driver for SBC-GXm and SBC-GX1 series boards\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}