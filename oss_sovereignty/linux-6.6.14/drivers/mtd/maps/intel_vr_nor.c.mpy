{
  "module_name": "intel_vr_nor.c",
  "hash_id": "0716b9f5b84eec5656d498e2bbf87df361e77caafa886073068be33737b041c0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/maps/intel_vr_nor.c",
  "human_readable_source": " \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pci.h>\n#include <linux/mtd/mtd.h>\n#include <linux/mtd/map.h>\n#include <linux/mtd/partitions.h>\n#include <linux/mtd/cfi.h>\n#include <linux/mtd/flashchip.h>\n\n#define DRV_NAME \"vr_nor\"\n\nstruct vr_nor_mtd {\n\tvoid __iomem *csr_base;\n\tstruct map_info map;\n\tstruct mtd_info *info;\n\tstruct pci_dev *dev;\n};\n\n \n#define EXP_CSR_MBAR 0\n \n#define EXP_WIN_MBAR 1\n \n#define CS0_SIZE 0x04000000\n \n#define CS0_START 0x0\n \n#define EXP_TIMING_CS0 0x00\n#define TIMING_CS_EN\t\t(1 << 31)\t \n#define TIMING_BOOT_ACCEL_DIS\t(1 <<  8)\t \n#define TIMING_WR_EN\t\t(1 <<  1)\t \n#define TIMING_BYTE_EN\t\t(1 <<  0)\t \n#define TIMING_MASK\t\t0x3FFF0000\n\nstatic void vr_nor_destroy_partitions(struct vr_nor_mtd *p)\n{\n\tmtd_device_unregister(p->info);\n}\n\nstatic int vr_nor_init_partitions(struct vr_nor_mtd *p)\n{\n\t \n\t \n\treturn mtd_device_register(p->info, NULL, 0);\n}\n\nstatic void vr_nor_destroy_mtd_setup(struct vr_nor_mtd *p)\n{\n\tmap_destroy(p->info);\n}\n\nstatic int vr_nor_mtd_setup(struct vr_nor_mtd *p)\n{\n\tstatic const char * const probe_types[] =\n\t    { \"cfi_probe\", \"jedec_probe\", NULL };\n\tconst char * const *type;\n\n\tfor (type = probe_types; !p->info && *type; type++)\n\t\tp->info = do_map_probe(*type, &p->map);\n\tif (!p->info)\n\t\treturn -ENODEV;\n\n\tp->info->dev.parent = &p->dev->dev;\n\n\treturn 0;\n}\n\nstatic void vr_nor_destroy_maps(struct vr_nor_mtd *p)\n{\n\tunsigned int exp_timing_cs0;\n\n\t \n\texp_timing_cs0 = readl(p->csr_base + EXP_TIMING_CS0);\n\texp_timing_cs0 &= ~TIMING_WR_EN;\n\twritel(exp_timing_cs0, p->csr_base + EXP_TIMING_CS0);\n\n\t \n\tiounmap(p->map.virt);\n\n\t \n\tiounmap(p->csr_base);\n}\n\n \nstatic int vr_nor_init_maps(struct vr_nor_mtd *p)\n{\n\tunsigned long csr_phys, csr_len;\n\tunsigned long win_phys, win_len;\n\tunsigned int exp_timing_cs0;\n\tint err;\n\n\tcsr_phys = pci_resource_start(p->dev, EXP_CSR_MBAR);\n\tcsr_len = pci_resource_len(p->dev, EXP_CSR_MBAR);\n\twin_phys = pci_resource_start(p->dev, EXP_WIN_MBAR);\n\twin_len = pci_resource_len(p->dev, EXP_WIN_MBAR);\n\n\tif (!csr_phys || !csr_len || !win_phys || !win_len)\n\t\treturn -ENODEV;\n\n\tif (win_len < (CS0_START + CS0_SIZE))\n\t\treturn -ENXIO;\n\n\tp->csr_base = ioremap(csr_phys, csr_len);\n\tif (!p->csr_base)\n\t\treturn -ENOMEM;\n\n\texp_timing_cs0 = readl(p->csr_base + EXP_TIMING_CS0);\n\tif (!(exp_timing_cs0 & TIMING_CS_EN)) {\n\t\tdev_warn(&p->dev->dev, \"Expansion Bus Chip Select 0 \"\n\t\t       \"is disabled.\\n\");\n\t\terr = -ENODEV;\n\t\tgoto release;\n\t}\n\tif ((exp_timing_cs0 & TIMING_MASK) == TIMING_MASK) {\n\t\tdev_warn(&p->dev->dev, \"Expansion Bus Chip Select 0 \"\n\t\t       \"is configured for maximally slow access times.\\n\");\n\t}\n\tp->map.name = DRV_NAME;\n\tp->map.bankwidth = (exp_timing_cs0 & TIMING_BYTE_EN) ? 1 : 2;\n\tp->map.phys = win_phys + CS0_START;\n\tp->map.size = CS0_SIZE;\n\tp->map.virt = ioremap(p->map.phys, p->map.size);\n\tif (!p->map.virt) {\n\t\terr = -ENOMEM;\n\t\tgoto release;\n\t}\n\tsimple_map_init(&p->map);\n\n\t \n\texp_timing_cs0 |= TIMING_BOOT_ACCEL_DIS | TIMING_WR_EN;\n\twritel(exp_timing_cs0, p->csr_base + EXP_TIMING_CS0);\n\n\treturn 0;\n\n      release:\n\tiounmap(p->csr_base);\n\treturn err;\n}\n\nstatic const struct pci_device_id vr_nor_pci_ids[] = {\n\t{PCI_DEVICE(PCI_VENDOR_ID_INTEL, 0x500D)},\n\t{0,}\n};\n\nstatic void vr_nor_pci_remove(struct pci_dev *dev)\n{\n\tstruct vr_nor_mtd *p = pci_get_drvdata(dev);\n\n\tvr_nor_destroy_partitions(p);\n\tvr_nor_destroy_mtd_setup(p);\n\tvr_nor_destroy_maps(p);\n\tkfree(p);\n\tpci_release_regions(dev);\n\tpci_disable_device(dev);\n}\n\nstatic int vr_nor_pci_probe(struct pci_dev *dev, const struct pci_device_id *id)\n{\n\tstruct vr_nor_mtd *p = NULL;\n\tunsigned int exp_timing_cs0;\n\tint err;\n\n\terr = pci_enable_device(dev);\n\tif (err)\n\t\tgoto out;\n\n\terr = pci_request_regions(dev, DRV_NAME);\n\tif (err)\n\t\tgoto disable_dev;\n\n\tp = kzalloc(sizeof(*p), GFP_KERNEL);\n\terr = -ENOMEM;\n\tif (!p)\n\t\tgoto release;\n\n\tp->dev = dev;\n\n\terr = vr_nor_init_maps(p);\n\tif (err)\n\t\tgoto release;\n\n\terr = vr_nor_mtd_setup(p);\n\tif (err)\n\t\tgoto destroy_maps;\n\n\terr = vr_nor_init_partitions(p);\n\tif (err)\n\t\tgoto destroy_mtd_setup;\n\n\tpci_set_drvdata(dev, p);\n\n\treturn 0;\n\n      destroy_mtd_setup:\n\tmap_destroy(p->info);\n\n      destroy_maps:\n\t \n\texp_timing_cs0 = readl(p->csr_base + EXP_TIMING_CS0);\n\texp_timing_cs0 &= ~TIMING_WR_EN;\n\twritel(exp_timing_cs0, p->csr_base + EXP_TIMING_CS0);\n\n\t \n\tiounmap(p->map.virt);\n\n\t \n\tiounmap(p->csr_base);\n\n      release:\n\tkfree(p);\n\tpci_release_regions(dev);\n\n      disable_dev:\n\tpci_disable_device(dev);\n\n      out:\n\treturn err;\n}\n\nstatic struct pci_driver vr_nor_pci_driver = {\n\t.name = DRV_NAME,\n\t.probe = vr_nor_pci_probe,\n\t.remove = vr_nor_pci_remove,\n\t.id_table = vr_nor_pci_ids,\n};\n\nmodule_pci_driver(vr_nor_pci_driver);\n\nMODULE_AUTHOR(\"Andy Lowe\");\nMODULE_DESCRIPTION(\"MTD map driver for NOR flash on Intel Vermilion Range\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DEVICE_TABLE(pci, vr_nor_pci_ids);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}