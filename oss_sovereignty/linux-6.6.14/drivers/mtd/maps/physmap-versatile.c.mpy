{
  "module_name": "physmap-versatile.c",
  "hash_id": "c7e78cd9bd7a489341d1e4fe63f540c96f6f6815df3cd3325a50297e8737d511",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/maps/physmap-versatile.c",
  "human_readable_source": "\n \n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/mtd/map.h>\n#include <linux/mfd/syscon.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/bitops.h>\n#include \"physmap-versatile.h\"\n\nstatic struct regmap *syscon_regmap;\n\nenum versatile_flashprot {\n\tINTEGRATOR_AP_FLASHPROT,\n\tINTEGRATOR_CP_FLASHPROT,\n\tVERSATILE_FLASHPROT,\n\tREALVIEW_FLASHPROT,\n};\n\nstatic const struct of_device_id syscon_match[] = {\n\t{\n\t\t.compatible = \"arm,integrator-ap-syscon\",\n\t\t.data = (void *)INTEGRATOR_AP_FLASHPROT,\n\t},\n\t{\n\t\t.compatible = \"arm,integrator-cp-syscon\",\n\t\t.data = (void *)INTEGRATOR_CP_FLASHPROT,\n\t},\n\t{\n\t\t.compatible = \"arm,core-module-versatile\",\n\t\t.data = (void *)VERSATILE_FLASHPROT,\n\t},\n\t{\n\t\t.compatible = \"arm,realview-eb-syscon\",\n\t\t.data = (void *)REALVIEW_FLASHPROT,\n\t},\n\t{\n\t\t.compatible = \"arm,realview-pb1176-syscon\",\n\t\t.data = (void *)REALVIEW_FLASHPROT,\n\t},\n\t{\n\t\t.compatible = \"arm,realview-pb11mp-syscon\",\n\t\t.data = (void *)REALVIEW_FLASHPROT,\n\t},\n\t{\n\t\t.compatible = \"arm,realview-pba8-syscon\",\n\t\t.data = (void *)REALVIEW_FLASHPROT,\n\t},\n\t{\n\t\t.compatible = \"arm,realview-pbx-syscon\",\n\t\t.data = (void *)REALVIEW_FLASHPROT,\n\t},\n\t{},\n};\n\n \n#define INTEGRATOR_SC_CTRLS_OFFSET\t0x08\n#define INTEGRATOR_SC_CTRLC_OFFSET\t0x0C\n#define INTEGRATOR_SC_CTRL_FLVPPEN\tBIT(1)\n#define INTEGRATOR_SC_CTRL_FLWP\t\tBIT(2)\n\n#define INTEGRATOR_EBI_CSR1_OFFSET\t0x04\n \n#define INTEGRATOR_EBI_WRITE_ENABLE\tBIT(3)\n#define INTEGRATOR_EBI_LOCK_OFFSET\t0x20\n#define INTEGRATOR_EBI_LOCK_VAL\t\t0xA05F\n\nstatic const struct of_device_id ebi_match[] = {\n\t{ .compatible = \"arm,external-bus-interface\"},\n\t{ },\n};\n\nstatic int ap_flash_init(struct platform_device *pdev)\n{\n\tstruct device_node *ebi;\n\tvoid __iomem *ebi_base;\n\tu32 val;\n\tint ret;\n\n\t \n\tebi = of_find_matching_node(NULL, ebi_match);\n\tif (!ebi) {\n\t\treturn -ENODEV;\n\t}\n\tebi_base = of_iomap(ebi, 0);\n\tof_node_put(ebi);\n\tif (!ebi_base)\n\t\treturn -ENODEV;\n\n\t \n\tret = regmap_write(syscon_regmap,\n\t\tINTEGRATOR_SC_CTRLC_OFFSET,\n\t\tINTEGRATOR_SC_CTRL_FLVPPEN | INTEGRATOR_SC_CTRL_FLWP);\n\tif (ret)\n\t\tdev_err(&pdev->dev, \"error clearing Integrator VPP/WP\\n\");\n\n\t \n\twritel(INTEGRATOR_EBI_LOCK_VAL, ebi_base + INTEGRATOR_EBI_LOCK_OFFSET);\n\n\t \n\tval = readl(ebi_base + INTEGRATOR_EBI_CSR1_OFFSET);\n\tval |= INTEGRATOR_EBI_WRITE_ENABLE;\n\twritel(val, ebi_base + INTEGRATOR_EBI_CSR1_OFFSET);\n\n\t \n\twritel(0, ebi_base + INTEGRATOR_EBI_LOCK_OFFSET);\n\tiounmap(ebi_base);\n\n\treturn 0;\n}\n\nstatic void ap_flash_set_vpp(struct map_info *map, int on)\n{\n\tint ret;\n\n\tif (on) {\n\t\tret = regmap_write(syscon_regmap,\n\t\t\tINTEGRATOR_SC_CTRLS_OFFSET,\n\t\t\tINTEGRATOR_SC_CTRL_FLVPPEN | INTEGRATOR_SC_CTRL_FLWP);\n\t\tif (ret)\n\t\t\tpr_err(\"error enabling AP VPP\\n\");\n\t} else {\n\t\tret = regmap_write(syscon_regmap,\n\t\t\tINTEGRATOR_SC_CTRLC_OFFSET,\n\t\t\tINTEGRATOR_SC_CTRL_FLVPPEN | INTEGRATOR_SC_CTRL_FLWP);\n\t\tif (ret)\n\t\t\tpr_err(\"error disabling AP VPP\\n\");\n\t}\n}\n\n \n\n#define INTCP_FLASHPROG_OFFSET\t\t0x04\n#define CINTEGRATOR_FLVPPEN\t\tBIT(0)\n#define CINTEGRATOR_FLWREN\t\tBIT(1)\n#define CINTEGRATOR_FLMASK\t\tBIT(0)|BIT(1)\n\nstatic void cp_flash_set_vpp(struct map_info *map, int on)\n{\n\tint ret;\n\n\tif (on) {\n\t\tret = regmap_update_bits(syscon_regmap,\n\t\t\t\tINTCP_FLASHPROG_OFFSET,\n\t\t\t\tCINTEGRATOR_FLMASK,\n\t\t\t\tCINTEGRATOR_FLVPPEN | CINTEGRATOR_FLWREN);\n\t\tif (ret)\n\t\t\tpr_err(\"error setting CP VPP\\n\");\n\t} else {\n\t\tret = regmap_update_bits(syscon_regmap,\n\t\t\t\tINTCP_FLASHPROG_OFFSET,\n\t\t\t\tCINTEGRATOR_FLMASK,\n\t\t\t\t0);\n\t\tif (ret)\n\t\t\tpr_err(\"error setting CP VPP\\n\");\n\t}\n}\n\n \n\n#define VERSATILE_SYS_FLASH_OFFSET            0x4C\n\nstatic void versatile_flash_set_vpp(struct map_info *map, int on)\n{\n\tint ret;\n\n\tret = regmap_update_bits(syscon_regmap, VERSATILE_SYS_FLASH_OFFSET,\n\t\t\t\t 0x01, !!on);\n\tif (ret)\n\t\tpr_err(\"error setting Versatile VPP\\n\");\n}\n\nint of_flash_probe_versatile(struct platform_device *pdev,\n\t\t\t     struct device_node *np,\n\t\t\t     struct map_info *map)\n{\n\tstruct device_node *sysnp;\n\tconst struct of_device_id *devid;\n\tstruct regmap *rmap;\n\tstatic enum versatile_flashprot versatile_flashprot;\n\tint ret;\n\n\t \n\tif (!of_device_is_compatible(np, \"arm,versatile-flash\"))\n\t\treturn 0;\n\n\t \n\tif (!syscon_regmap) {\n\t\tsysnp = of_find_matching_node_and_match(NULL,\n\t\t\t\t\t\t\tsyscon_match,\n\t\t\t\t\t\t\t&devid);\n\t\tif (!sysnp)\n\t\t\treturn -ENODEV;\n\n\t\tversatile_flashprot = (uintptr_t)devid->data;\n\t\trmap = syscon_node_to_regmap(sysnp);\n\t\tof_node_put(sysnp);\n\t\tif (IS_ERR(rmap))\n\t\t\treturn PTR_ERR(rmap);\n\n\t\tsyscon_regmap = rmap;\n\t}\n\n\tswitch (versatile_flashprot) {\n\tcase INTEGRATOR_AP_FLASHPROT:\n\t\tret = ap_flash_init(pdev);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tmap->set_vpp = ap_flash_set_vpp;\n\t\tdev_info(&pdev->dev, \"Integrator/AP flash protection\\n\");\n\t\tbreak;\n\tcase INTEGRATOR_CP_FLASHPROT:\n\t\tmap->set_vpp = cp_flash_set_vpp;\n\t\tdev_info(&pdev->dev, \"Integrator/CP flash protection\\n\");\n\t\tbreak;\n\tcase VERSATILE_FLASHPROT:\n\tcase REALVIEW_FLASHPROT:\n\t\tmap->set_vpp = versatile_flash_set_vpp;\n\t\tdev_info(&pdev->dev, \"versatile/realview flash protection\\n\");\n\t\tbreak;\n\tdefault:\n\t\tdev_info(&pdev->dev, \"device marked as Versatile flash \"\n\t\t\t \"but no system controller was found\\n\");\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}