{
  "module_name": "sun_uflash.c",
  "hash_id": "c6478dd05cffb15bace38cf6c92fa836c5310fb5546648c0b48b3cf33663da78",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/maps/sun_uflash.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/ioport.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <asm/prom.h>\n#include <linux/uaccess.h>\n#include <asm/io.h>\n\n#include <linux/mtd/mtd.h>\n#include <linux/mtd/map.h>\n\n#define UFLASH_OBPNAME\t\"flashprom\"\n#define DRIVER_NAME\t\"sun_uflash\"\n#define PFX\t\tDRIVER_NAME \": \"\n\n#define UFLASH_WINDOW_SIZE\t0x200000\n#define UFLASH_BUSWIDTH\t\t1\t\t\t \n\nMODULE_AUTHOR(\"Eric Brower <ebrower@usa.net>\");\nMODULE_DESCRIPTION(\"User-programmable flash device on Sun Microsystems boardsets\");\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(\"2.1\");\n\nstruct uflash_dev {\n\tconst char\t\t*name;\t \n\tstruct map_info \tmap;\t \n\tstruct mtd_info\t\t*mtd;\t \n};\n\nstruct map_info uflash_map_templ = {\n\t.name =\t\t\"SUNW,???-????\",\n\t.size =\t\tUFLASH_WINDOW_SIZE,\n\t.bankwidth =\tUFLASH_BUSWIDTH,\n};\n\nint uflash_devinit(struct platform_device *op, struct device_node *dp)\n{\n\tstruct uflash_dev *up;\n\n\tif (op->resource[1].flags) {\n\t\t \n\t\tprintk(KERN_ERR PFX \"Unsupported device at %pOF, 0x%llx\\n\",\n\t\t       dp, (unsigned long long)op->resource[0].start);\n\n\t\treturn -ENODEV;\n\t}\n\n\tup = kzalloc(sizeof(struct uflash_dev), GFP_KERNEL);\n\tif (!up)\n\t\treturn -ENOMEM;\n\n\t \n\tmemcpy(&up->map, &uflash_map_templ, sizeof(uflash_map_templ));\n\n\tup->map.size = resource_size(&op->resource[0]);\n\n\tup->name = of_get_property(dp, \"model\", NULL);\n\tif (up->name && 0 < strlen(up->name))\n\t\tup->map.name = up->name;\n\n\tup->map.phys = op->resource[0].start;\n\n\tup->map.virt = of_ioremap(&op->resource[0], 0, up->map.size,\n\t\t\t\t  DRIVER_NAME);\n\tif (!up->map.virt) {\n\t\tprintk(KERN_ERR PFX \"Failed to map device.\\n\");\n\t\tkfree(up);\n\n\t\treturn -EINVAL;\n\t}\n\n\tsimple_map_init(&up->map);\n\n\t \n\tup->mtd = do_map_probe(\"cfi_probe\", &up->map);\n\tif (!up->mtd) {\n\t\tof_iounmap(&op->resource[0], up->map.virt, up->map.size);\n\t\tkfree(up);\n\n\t\treturn -ENXIO;\n\t}\n\n\tup->mtd->owner = THIS_MODULE;\n\n\tmtd_device_register(up->mtd, NULL, 0);\n\n\tdev_set_drvdata(&op->dev, up);\n\n\treturn 0;\n}\n\nstatic int uflash_probe(struct platform_device *op)\n{\n\tstruct device_node *dp = op->dev.of_node;\n\n\t \n\tif (!of_property_read_bool(dp, \"user\"))\n\t\treturn -ENODEV;\n\n\treturn uflash_devinit(op, dp);\n}\n\nstatic int uflash_remove(struct platform_device *op)\n{\n\tstruct uflash_dev *up = dev_get_drvdata(&op->dev);\n\n\tif (up->mtd) {\n\t\tmtd_device_unregister(up->mtd);\n\t\tmap_destroy(up->mtd);\n\t}\n\tif (up->map.virt) {\n\t\tof_iounmap(&op->resource[0], up->map.virt, up->map.size);\n\t\tup->map.virt = NULL;\n\t}\n\n\tkfree(up);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id uflash_match[] = {\n\t{\n\t\t.name = UFLASH_OBPNAME,\n\t},\n\t{},\n};\n\nMODULE_DEVICE_TABLE(of, uflash_match);\n\nstatic struct platform_driver uflash_driver = {\n\t.driver = {\n\t\t.name = DRIVER_NAME,\n\t\t.of_match_table = uflash_match,\n\t},\n\t.probe\t\t= uflash_probe,\n\t.remove\t\t= uflash_remove,\n};\n\nmodule_platform_driver(uflash_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}