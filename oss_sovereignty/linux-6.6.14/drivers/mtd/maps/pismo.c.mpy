{
  "module_name": "pismo.c",
  "hash_id": "4207175c160b2859af283ece0b2f4d3d8c7efc351b80dee747fc5bc1c7831779",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/maps/pismo.c",
  "human_readable_source": "\n \n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/i2c.h>\n#include <linux/slab.h>\n#include <linux/platform_device.h>\n#include <linux/spinlock.h>\n#include <linux/mutex.h>\n#include <linux/mtd/physmap.h>\n#include <linux/mtd/plat-ram.h>\n#include <linux/mtd/pismo.h>\n\n#define PISMO_NUM_CS\t5\n\nstruct pismo_cs_block {\n\tu8\ttype;\n\tu8\twidth;\n\t__le16\taccess;\n\t__le32\tsize;\n\tu32\treserved[2];\n\tchar\tdevice[32];\n} __packed;\n\nstruct pismo_eeprom {\n\tstruct pismo_cs_block cs[PISMO_NUM_CS];\n\tchar\tboard[15];\n\tu8\tsum;\n} __packed;\n\nstruct pismo_mem {\n\tphys_addr_t base;\n\tu32\tsize;\n\tu16\taccess;\n\tu8\twidth;\n\tu8\ttype;\n};\n\nstruct pismo_data {\n\tstruct i2c_client\t*client;\n\tvoid\t\t\t(*vpp)(void *, int);\n\tvoid\t\t\t*vpp_data;\n\tstruct platform_device\t*dev[PISMO_NUM_CS];\n};\n\nstatic void pismo_set_vpp(struct platform_device *pdev, int on)\n{\n\tstruct i2c_client *client = to_i2c_client(pdev->dev.parent);\n\tstruct pismo_data *pismo = i2c_get_clientdata(client);\n\n\tpismo->vpp(pismo->vpp_data, on);\n}\n\nstatic unsigned int pismo_width_to_bytes(unsigned int width)\n{\n\twidth &= 15;\n\tif (width > 2)\n\t\treturn 0;\n\treturn 1 << width;\n}\n\nstatic int pismo_eeprom_read(struct i2c_client *client, void *buf, u8 addr,\n\t\t\t     size_t size)\n{\n\tint ret;\n\tstruct i2c_msg msg[] = {\n\t\t{\n\t\t\t.addr = client->addr,\n\t\t\t.len = sizeof(addr),\n\t\t\t.buf = &addr,\n\t\t}, {\n\t\t\t.addr = client->addr,\n\t\t\t.flags = I2C_M_RD,\n\t\t\t.len = size,\n\t\t\t.buf = buf,\n\t\t},\n\t};\n\n\tret = i2c_transfer(client->adapter, msg, ARRAY_SIZE(msg));\n\n\treturn ret == ARRAY_SIZE(msg) ? size : -EIO;\n}\n\nstatic int pismo_add_device(struct pismo_data *pismo, int i,\n\t\t\t    struct pismo_mem *region, const char *name,\n\t\t\t    void *pdata, size_t psize)\n{\n\tstruct platform_device *dev;\n\tstruct resource res = { };\n\tphys_addr_t base = region->base;\n\tint ret;\n\n\tif (base == ~0)\n\t\treturn -ENXIO;\n\n\tres.start = base;\n\tres.end = base + region->size - 1;\n\tres.flags = IORESOURCE_MEM;\n\n\tdev = platform_device_alloc(name, i);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\tdev->dev.parent = &pismo->client->dev;\n\n\tdo {\n\t\tret = platform_device_add_resources(dev, &res, 1);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tret = platform_device_add_data(dev, pdata, psize);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tret = platform_device_add(dev);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tpismo->dev[i] = dev;\n\t\treturn 0;\n\t} while (0);\n\n\tplatform_device_put(dev);\n\treturn ret;\n}\n\nstatic int pismo_add_nor(struct pismo_data *pismo, int i,\n\t\t\t struct pismo_mem *region)\n{\n\tstruct physmap_flash_data data = {\n\t\t.width = region->width,\n\t};\n\n\tif (pismo->vpp)\n\t\tdata.set_vpp = pismo_set_vpp;\n\n\treturn pismo_add_device(pismo, i, region, \"physmap-flash\",\n\t\t&data, sizeof(data));\n}\n\nstatic int pismo_add_sram(struct pismo_data *pismo, int i,\n\t\t\t  struct pismo_mem *region)\n{\n\tstruct platdata_mtd_ram data = {\n\t\t.bankwidth = region->width,\n\t};\n\n\treturn pismo_add_device(pismo, i, region, \"mtd-ram\",\n\t\t&data, sizeof(data));\n}\n\nstatic void pismo_add_one(struct pismo_data *pismo, int i,\n\t\t\t  const struct pismo_cs_block *cs, phys_addr_t base)\n{\n\tstruct device *dev = &pismo->client->dev;\n\tstruct pismo_mem region;\n\n\tregion.base = base;\n\tregion.type = cs->type;\n\tregion.width = pismo_width_to_bytes(cs->width);\n\tregion.access = le16_to_cpu(cs->access);\n\tregion.size = le32_to_cpu(cs->size);\n\n\tif (region.width == 0) {\n\t\tdev_err(dev, \"cs%u: bad width: %02x, ignoring\\n\", i, cs->width);\n\t\treturn;\n\t}\n\n\t \n\n\tdev_info(dev, \"cs%u: %.32s: type %02x access %u00ps size %uK\\n\",\n\t\ti, cs->device, region.type, region.access, region.size / 1024);\n\n\tswitch (region.type) {\n\tcase 0:\n\t\tbreak;\n\tcase 1:\n\t\t \n\t\tbreak;\n\tcase 2:\n\t\t \n\t\tpismo_add_nor(pismo, i, &region);\n\t\tbreak;\n\tcase 3:\n\t\t \n\t\tpismo_add_sram(pismo, i, &region);\n\t\tbreak;\n\t}\n}\n\nstatic void pismo_remove(struct i2c_client *client)\n{\n\tstruct pismo_data *pismo = i2c_get_clientdata(client);\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(pismo->dev); i++)\n\t\tplatform_device_unregister(pismo->dev[i]);\n\n\tkfree(pismo);\n}\n\nstatic int pismo_probe(struct i2c_client *client)\n{\n\tstruct pismo_pdata *pdata = client->dev.platform_data;\n\tstruct pismo_eeprom eeprom;\n\tstruct pismo_data *pismo;\n\tint ret, i;\n\n\tif (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {\n\t\tdev_err(&client->dev, \"functionality mismatch\\n\");\n\t\treturn -EIO;\n\t}\n\n\tpismo = kzalloc(sizeof(*pismo), GFP_KERNEL);\n\tif (!pismo)\n\t\treturn -ENOMEM;\n\n\tpismo->client = client;\n\tif (pdata) {\n\t\tpismo->vpp = pdata->set_vpp;\n\t\tpismo->vpp_data = pdata->vpp_data;\n\t}\n\ti2c_set_clientdata(client, pismo);\n\n\tret = pismo_eeprom_read(client, &eeprom, 0, sizeof(eeprom));\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"error reading EEPROM: %d\\n\", ret);\n\t\tgoto exit_free;\n\t}\n\n\tdev_info(&client->dev, \"%.15s board found\\n\", eeprom.board);\n\n\tfor (i = 0; i < ARRAY_SIZE(eeprom.cs); i++)\n\t\tif (eeprom.cs[i].type != 0xff)\n\t\t\tpismo_add_one(pismo, i, &eeprom.cs[i],\n\t\t\t\t      pdata->cs_addrs[i]);\n\n\treturn 0;\n\n exit_free:\n\tkfree(pismo);\n\treturn ret;\n}\n\nstatic const struct i2c_device_id pismo_id[] = {\n\t{ \"pismo\" },\n\t{ },\n};\nMODULE_DEVICE_TABLE(i2c, pismo_id);\n\nstatic struct i2c_driver pismo_driver = {\n\t.driver\t= {\n\t\t.name\t= \"pismo\",\n\t},\n\t.probe\t\t= pismo_probe,\n\t.remove\t\t= pismo_remove,\n\t.id_table\t= pismo_id,\n};\n\nstatic int __init pismo_init(void)\n{\n\tBUILD_BUG_ON(sizeof(struct pismo_cs_block) != 48);\n\tBUILD_BUG_ON(sizeof(struct pismo_eeprom) != 256);\n\n\treturn i2c_add_driver(&pismo_driver);\n}\nmodule_init(pismo_init);\n\nstatic void __exit pismo_exit(void)\n{\n\ti2c_del_driver(&pismo_driver);\n}\nmodule_exit(pismo_exit);\n\nMODULE_AUTHOR(\"Russell King <linux@arm.linux.org.uk>\");\nMODULE_DESCRIPTION(\"PISMO memory driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}