{
  "module_name": "esb2rom.c",
  "hash_id": "631902a24b13a936952c9a9f0157e255e8e7fed30dc4f895733365a4d0a3b6dd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/maps/esb2rom.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <asm/io.h>\n#include <linux/mtd/mtd.h>\n#include <linux/mtd/map.h>\n#include <linux/mtd/cfi.h>\n#include <linux/mtd/flashchip.h>\n#include <linux/pci.h>\n#include <linux/pci_ids.h>\n#include <linux/list.h>\n\n#define MOD_NAME KBUILD_BASENAME\n\n#define ADDRESS_NAME_LEN 18\n\n#define ROM_PROBE_STEP_SIZE (64*1024)  \n\n#define BIOS_CNTL\t\t0xDC\n#define BIOS_LOCK_ENABLE\t0x02\n#define BIOS_WRITE_ENABLE\t0x01\n\n \n#define FWH_DEC_EN1\t0xD8\n#define FWH_F8_EN\t0x8000\n#define FWH_F0_EN\t0x4000\n#define FWH_E8_EN\t0x2000\n#define FWH_E0_EN\t0x1000\n#define FWH_D8_EN\t0x0800\n#define FWH_D0_EN\t0x0400\n#define FWH_C8_EN\t0x0200\n#define FWH_C0_EN\t0x0100\n#define FWH_LEGACY_F_EN\t0x0080\n#define FWH_LEGACY_E_EN\t0x0040\n \n#define FWH_70_EN\t0x0008\n#define FWH_60_EN\t0x0004\n#define FWH_50_EN\t0x0002\n#define FWH_40_EN\t0x0001\n\n \n#define FWH_SEL1\t0xD0\n#define FWH_SEL2\t0xD4\n\n#define FWH_8MiB\t(FWH_F8_EN | FWH_F0_EN | FWH_E8_EN | FWH_E0_EN | \\\n\t\t\t FWH_D8_EN | FWH_D0_EN | FWH_C8_EN | FWH_C0_EN | \\\n\t\t\t FWH_70_EN | FWH_60_EN | FWH_50_EN | FWH_40_EN)\n\n#define FWH_7MiB\t(FWH_F8_EN | FWH_F0_EN | FWH_E8_EN | FWH_E0_EN | \\\n\t\t\t FWH_D8_EN | FWH_D0_EN | FWH_C8_EN | FWH_C0_EN | \\\n\t\t\t FWH_70_EN | FWH_60_EN | FWH_50_EN)\n\n#define FWH_6MiB\t(FWH_F8_EN | FWH_F0_EN | FWH_E8_EN | FWH_E0_EN | \\\n\t\t\t FWH_D8_EN | FWH_D0_EN | FWH_C8_EN | FWH_C0_EN | \\\n\t\t\t FWH_70_EN | FWH_60_EN)\n\n#define FWH_5MiB\t(FWH_F8_EN | FWH_F0_EN | FWH_E8_EN | FWH_E0_EN | \\\n\t\t\t FWH_D8_EN | FWH_D0_EN | FWH_C8_EN | FWH_C0_EN | \\\n\t\t\t FWH_70_EN)\n\n#define FWH_4MiB\t(FWH_F8_EN | FWH_F0_EN | FWH_E8_EN | FWH_E0_EN | \\\n\t\t\t FWH_D8_EN | FWH_D0_EN | FWH_C8_EN | FWH_C0_EN)\n\n#define FWH_3_5MiB\t(FWH_F8_EN | FWH_F0_EN | FWH_E8_EN | FWH_E0_EN | \\\n\t\t\t FWH_D8_EN | FWH_D0_EN | FWH_C8_EN)\n\n#define FWH_3MiB\t(FWH_F8_EN | FWH_F0_EN | FWH_E8_EN | FWH_E0_EN | \\\n\t\t\t FWH_D8_EN | FWH_D0_EN)\n\n#define FWH_2_5MiB\t(FWH_F8_EN | FWH_F0_EN | FWH_E8_EN | FWH_E0_EN | \\\n\t\t\t FWH_D8_EN)\n\n#define FWH_2MiB\t(FWH_F8_EN | FWH_F0_EN | FWH_E8_EN | FWH_E0_EN)\n\n#define FWH_1_5MiB\t(FWH_F8_EN | FWH_F0_EN | FWH_E8_EN)\n\n#define FWH_1MiB\t(FWH_F8_EN | FWH_F0_EN)\n\n#define FWH_0_5MiB\t(FWH_F8_EN)\n\n\nstruct esb2rom_window {\n\tvoid __iomem* virt;\n\tunsigned long phys;\n\tunsigned long size;\n\tstruct list_head maps;\n\tstruct resource rsrc;\n\tstruct pci_dev *pdev;\n};\n\nstruct esb2rom_map_info {\n\tstruct list_head list;\n\tstruct map_info map;\n\tstruct mtd_info *mtd;\n\tstruct resource rsrc;\n\tchar map_name[sizeof(MOD_NAME) + 2 + ADDRESS_NAME_LEN];\n};\n\nstatic struct esb2rom_window esb2rom_window = {\n\t.maps = LIST_HEAD_INIT(esb2rom_window.maps),\n};\n\nstatic void esb2rom_cleanup(struct esb2rom_window *window)\n{\n\tstruct esb2rom_map_info *map, *scratch;\n\tu8 byte;\n\n\t \n\tpci_read_config_byte(window->pdev, BIOS_CNTL, &byte);\n\tpci_write_config_byte(window->pdev, BIOS_CNTL,\n\t\tbyte & ~BIOS_WRITE_ENABLE);\n\n\t \n\tlist_for_each_entry_safe(map, scratch, &window->maps, list) {\n\t\tif (map->rsrc.parent)\n\t\t\trelease_resource(&map->rsrc);\n\t\tmtd_device_unregister(map->mtd);\n\t\tmap_destroy(map->mtd);\n\t\tlist_del(&map->list);\n\t\tkfree(map);\n\t}\n\tif (window->rsrc.parent)\n\t\trelease_resource(&window->rsrc);\n\tif (window->virt) {\n\t\tiounmap(window->virt);\n\t\twindow->virt = NULL;\n\t\twindow->phys = 0;\n\t\twindow->size = 0;\n\t}\n\tpci_dev_put(window->pdev);\n}\n\nstatic int __init esb2rom_init_one(struct pci_dev *pdev,\n\t\t\t\t   const struct pci_device_id *ent)\n{\n\tstatic char *rom_probe_types[] = { \"cfi_probe\", \"jedec_probe\", NULL };\n\tstruct esb2rom_window *window = &esb2rom_window;\n\tstruct esb2rom_map_info *map = NULL;\n\tunsigned long map_top;\n\tu8 byte;\n\tu16 word;\n\n\t \n\twindow->pdev = pci_dev_get(pdev);\n\n\t \n\n \n\n\t \n\twindow->phys = 0;\n\tpci_read_config_word(pdev, FWH_DEC_EN1, &word);\n\tprintk(KERN_DEBUG \"pci_read_config_word : %x\\n\", word);\n\n\tif ((word & FWH_8MiB) == FWH_8MiB)\n\t\twindow->phys = 0xff400000;\n\telse if ((word & FWH_7MiB) == FWH_7MiB)\n\t\twindow->phys = 0xff500000;\n\telse if ((word & FWH_6MiB) == FWH_6MiB)\n\t\twindow->phys = 0xff600000;\n\telse if ((word & FWH_5MiB) == FWH_5MiB)\n\t\twindow->phys = 0xFF700000;\n\telse if ((word & FWH_4MiB) == FWH_4MiB)\n\t\twindow->phys = 0xffc00000;\n\telse if ((word & FWH_3_5MiB) == FWH_3_5MiB)\n\t\twindow->phys = 0xffc80000;\n\telse if ((word & FWH_3MiB) == FWH_3MiB)\n\t\twindow->phys = 0xffd00000;\n\telse if ((word & FWH_2_5MiB) == FWH_2_5MiB)\n\t\twindow->phys = 0xffd80000;\n\telse if ((word & FWH_2MiB) == FWH_2MiB)\n\t\twindow->phys = 0xffe00000;\n\telse if ((word & FWH_1_5MiB) == FWH_1_5MiB)\n\t\twindow->phys = 0xffe80000;\n\telse if ((word & FWH_1MiB) == FWH_1MiB)\n\t\twindow->phys = 0xfff00000;\n\telse if ((word & FWH_0_5MiB) == FWH_0_5MiB)\n\t\twindow->phys = 0xfff80000;\n\n\tif (window->phys == 0) {\n\t\tprintk(KERN_ERR MOD_NAME \": Rom window is closed\\n\");\n\t\tgoto out;\n\t}\n\n\t \n\twindow->phys -= 0x400000UL;\n\twindow->size = (0xffffffffUL - window->phys) + 1UL;\n\n\t \n\tpci_read_config_byte(pdev, BIOS_CNTL, &byte);\n\tif (!(byte & BIOS_WRITE_ENABLE)  && (byte & (BIOS_LOCK_ENABLE))) {\n\t\t \n\t\tprintk(KERN_ERR MOD_NAME \": firmware access control, I can't enable writes\\n\");\n\t\tgoto out;\n\t}\n\tpci_write_config_byte(pdev, BIOS_CNTL, byte | BIOS_WRITE_ENABLE);\n\n\t \n\twindow->rsrc.name = MOD_NAME;\n\twindow->rsrc.start = window->phys;\n\twindow->rsrc.end   = window->phys + window->size - 1;\n\twindow->rsrc.flags = IORESOURCE_MEM | IORESOURCE_BUSY;\n\tif (request_resource(&iomem_resource, &window->rsrc)) {\n\t\twindow->rsrc.parent = NULL;\n\t\tprintk(KERN_DEBUG MOD_NAME \": \"\n\t\t       \"%s(): Unable to register resource %pR - kernel bug?\\n\",\n\t\t\t__func__, &window->rsrc);\n\t}\n\n\t \n\twindow->virt = ioremap(window->phys, window->size);\n\tif (!window->virt) {\n\t\tprintk(KERN_ERR MOD_NAME \": ioremap(%08lx, %08lx) failed\\n\",\n\t\t\twindow->phys, window->size);\n\t\tgoto out;\n\t}\n\n\t \n\tmap_top = window->phys;\n\tif ((window->phys & 0x3fffff) != 0) {\n\t\t \n\t\tmap_top = window->phys + 0x400000;\n\t}\n#if 1\n\t \n\tif (map_top < 0xffc00000)\n\t\tmap_top = 0xffc00000;\n#endif\n\t \n\twhile ((map_top - 1) < 0xffffffffUL) {\n\t\tstruct cfi_private *cfi;\n\t\tunsigned long offset;\n\t\tint i;\n\n\t\tif (!map) {\n\t\t\tmap = kmalloc(sizeof(*map), GFP_KERNEL);\n\t\t\tif (!map)\n\t\t\t\tgoto out;\n\t\t}\n\t\tmemset(map, 0, sizeof(*map));\n\t\tINIT_LIST_HEAD(&map->list);\n\t\tmap->map.name = map->map_name;\n\t\tmap->map.phys = map_top;\n\t\toffset = map_top - window->phys;\n\t\tmap->map.virt = (void __iomem *)\n\t\t\t(((unsigned long)(window->virt)) + offset);\n\t\tmap->map.size = 0xffffffffUL - map_top + 1UL;\n\t\t \n\t\tsprintf(map->map_name, \"%s @%08Lx\",\n\t\t\tMOD_NAME, (unsigned long long)map->map.phys);\n\n\t\t \n\t\tfor(map->map.bankwidth = 32; map->map.bankwidth;\n\t\t\tmap->map.bankwidth >>= 1) {\n\t\t\tchar **probe_type;\n\t\t\t \n\t\t\tif (!map_bankwidth_supported(map->map.bankwidth))\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tsimple_map_init(&map->map);\n\n\t\t\t \n\t\t\tprobe_type = rom_probe_types;\n\t\t\tfor(; *probe_type; probe_type++) {\n\t\t\t\tmap->mtd = do_map_probe(*probe_type, &map->map);\n\t\t\t\tif (map->mtd)\n\t\t\t\t\tgoto found;\n\t\t\t}\n\t\t}\n\t\tmap_top += ROM_PROBE_STEP_SIZE;\n\t\tcontinue;\n\tfound:\n\t\t \n\t\tif (map->mtd->size > map->map.size) {\n\t\t\tprintk(KERN_WARNING MOD_NAME\n\t\t\t\t\" rom(%llu) larger than window(%lu). fixing...\\n\",\n\t\t\t\t(unsigned long long)map->mtd->size, map->map.size);\n\t\t\tmap->mtd->size = map->map.size;\n\t\t}\n\t\tif (window->rsrc.parent) {\n\t\t\t \n\t\t\tmap->rsrc.name  = map->map_name;\n\t\t\tmap->rsrc.start = map->map.phys;\n\t\t\tmap->rsrc.end   = map->map.phys + map->mtd->size - 1;\n\t\t\tmap->rsrc.flags = IORESOURCE_MEM | IORESOURCE_BUSY;\n\t\t\tif (request_resource(&window->rsrc, &map->rsrc)) {\n\t\t\t\tprintk(KERN_ERR MOD_NAME\n\t\t\t\t\t\": cannot reserve MTD resource\\n\");\n\t\t\t\tmap->rsrc.parent = NULL;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tmap->map.virt = window->virt;\n\t\tmap->map.phys = window->phys;\n\t\tcfi = map->map.fldrv_priv;\n\t\tfor(i = 0; i < cfi->numchips; i++)\n\t\t\tcfi->chips[i].start += offset;\n\n\t\t \n\t\tmap->mtd->owner = THIS_MODULE;\n\t\tif (mtd_device_register(map->mtd, NULL, 0)) {\n\t\t\tmap_destroy(map->mtd);\n\t\t\tmap->mtd = NULL;\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\tmap_top += map->mtd->size;\n\n\t\t \n\t\tlist_add(&map->list, &window->maps);\n\t\tmap = NULL;\n\t}\n\n out:\n\t \n\tkfree(map);\n\n\t \n\tif (list_empty(&window->maps)) {\n\t\tesb2rom_cleanup(window);\n\t\treturn -ENODEV;\n\t}\n\treturn 0;\n}\n\nstatic void esb2rom_remove_one(struct pci_dev *pdev)\n{\n\tstruct esb2rom_window *window = &esb2rom_window;\n\tesb2rom_cleanup(window);\n}\n\nstatic const struct pci_device_id esb2rom_pci_tbl[] = {\n\t{ PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_82801BA_0,\n\t  PCI_ANY_ID, PCI_ANY_ID, },\n\t{ PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_82801CA_0,\n\t  PCI_ANY_ID, PCI_ANY_ID, },\n\t{ PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_82801DB_0,\n\t  PCI_ANY_ID, PCI_ANY_ID, },\n\t{ PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_82801EB_0,\n\t  PCI_ANY_ID, PCI_ANY_ID, },\n\t{ PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_ESB_1,\n\t  PCI_ANY_ID, PCI_ANY_ID, },\n\t{ PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_ESB2_0,\n\t  PCI_ANY_ID, PCI_ANY_ID, },\n\t{ 0, },\n};\n\n#if 0\nMODULE_DEVICE_TABLE(pci, esb2rom_pci_tbl);\n\nstatic struct pci_driver esb2rom_driver = {\n\t.name =\t\tMOD_NAME,\n\t.id_table =\tesb2rom_pci_tbl,\n\t.probe =\tesb2rom_init_one,\n\t.remove =\tesb2rom_remove_one,\n};\n#endif\n\nstatic int __init init_esb2rom(void)\n{\n\tstruct pci_dev *pdev;\n\tconst struct pci_device_id *id;\n\tint retVal;\n\n\tpdev = NULL;\n\tfor (id = esb2rom_pci_tbl; id->vendor; id++) {\n\t\tprintk(KERN_DEBUG \"device id = %x\\n\", id->device);\n\t\tpdev = pci_get_device(id->vendor, id->device, NULL);\n\t\tif (pdev) {\n\t\t\tprintk(KERN_DEBUG \"matched device = %x\\n\", id->device);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (pdev) {\n\t\tprintk(KERN_DEBUG \"matched device id %x\\n\", id->device);\n\t\tretVal = esb2rom_init_one(pdev, &esb2rom_pci_tbl[0]);\n\t\tpci_dev_put(pdev);\n\t\tprintk(KERN_DEBUG \"retVal = %d\\n\", retVal);\n\t\treturn retVal;\n\t}\n\treturn -ENXIO;\n#if 0\n\treturn pci_register_driver(&esb2rom_driver);\n#endif\n}\n\nstatic void __exit cleanup_esb2rom(void)\n{\n\tesb2rom_remove_one(esb2rom_window.pdev);\n}\n\nmodule_init(init_esb2rom);\nmodule_exit(cleanup_esb2rom);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Lew Glendenning <lglendenning@lnxi.com>\");\nMODULE_DESCRIPTION(\"MTD map driver for BIOS chips on the ESB2 southbridge\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}