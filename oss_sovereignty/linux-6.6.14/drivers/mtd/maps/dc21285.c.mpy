{
  "module_name": "dc21285.c",
  "hash_id": "ef924727cdf4250ee5853e5704367a78eba1d0b997386047a69307310fd15960",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/maps/dc21285.c",
  "human_readable_source": " \n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n\n#include <linux/mtd/mtd.h>\n#include <linux/mtd/map.h>\n#include <linux/mtd/partitions.h>\n\n#include <asm/io.h>\n#include <asm/hardware/dec21285.h>\n#include <asm/mach-types.h>\n\n\nstatic struct mtd_info *dc21285_mtd;\n\n#ifdef CONFIG_ARCH_NETWINDER\n \nstatic void nw_en_write(void)\n{\n\tunsigned long flags;\n\n\t \n\traw_spin_lock_irqsave(&nw_gpio_lock, flags);\n\tnw_cpld_modify(CPLD_FLASH_WR_ENABLE, CPLD_FLASH_WR_ENABLE);\n\traw_spin_unlock_irqrestore(&nw_gpio_lock, flags);\n\n\t \n\tudelay(25);\n}\n#else\n#define nw_en_write() do { } while (0)\n#endif\n\nstatic map_word dc21285_read8(struct map_info *map, unsigned long ofs)\n{\n\tmap_word val;\n\tval.x[0] = *(uint8_t*)(map->virt + ofs);\n\treturn val;\n}\n\nstatic map_word dc21285_read16(struct map_info *map, unsigned long ofs)\n{\n\tmap_word val;\n\tval.x[0] = *(uint16_t*)(map->virt + ofs);\n\treturn val;\n}\n\nstatic map_word dc21285_read32(struct map_info *map, unsigned long ofs)\n{\n\tmap_word val;\n\tval.x[0] = *(uint32_t*)(map->virt + ofs);\n\treturn val;\n}\n\nstatic void dc21285_copy_from(struct map_info *map, void *to, unsigned long from, ssize_t len)\n{\n\tmemcpy(to, (void*)(map->virt + from), len);\n}\n\nstatic void dc21285_write8(struct map_info *map, const map_word d, unsigned long adr)\n{\n\tif (machine_is_netwinder())\n\t\tnw_en_write();\n\t*CSR_ROMWRITEREG = adr & 3;\n\tadr &= ~3;\n\t*(uint8_t*)(map->virt + adr) = d.x[0];\n}\n\nstatic void dc21285_write16(struct map_info *map, const map_word d, unsigned long adr)\n{\n\tif (machine_is_netwinder())\n\t\tnw_en_write();\n\t*CSR_ROMWRITEREG = adr & 3;\n\tadr &= ~3;\n\t*(uint16_t*)(map->virt + adr) = d.x[0];\n}\n\nstatic void dc21285_write32(struct map_info *map, const map_word d, unsigned long adr)\n{\n\tif (machine_is_netwinder())\n\t\tnw_en_write();\n\t*(uint32_t*)(map->virt + adr) = d.x[0];\n}\n\nstatic void dc21285_copy_to_32(struct map_info *map, unsigned long to, const void *from, ssize_t len)\n{\n\twhile (len > 0) {\n\t\tmap_word d;\n\t\td.x[0] = *((uint32_t*)from);\n\t\tdc21285_write32(map, d, to);\n\t\tfrom += 4;\n\t\tto += 4;\n\t\tlen -= 4;\n\t}\n}\n\nstatic void dc21285_copy_to_16(struct map_info *map, unsigned long to, const void *from, ssize_t len)\n{\n\twhile (len > 0) {\n\t\tmap_word d;\n\t\td.x[0] = *((uint16_t*)from);\n\t\tdc21285_write16(map, d, to);\n\t\tfrom += 2;\n\t\tto += 2;\n\t\tlen -= 2;\n\t}\n}\n\nstatic void dc21285_copy_to_8(struct map_info *map, unsigned long to, const void *from, ssize_t len)\n{\n\tmap_word d;\n\td.x[0] = *((uint8_t*)from);\n\tdc21285_write8(map, d, to);\n\tfrom++;\n\tto++;\n\tlen--;\n}\n\nstatic struct map_info dc21285_map = {\n\t.name = \"DC21285 flash\",\n\t.phys = NO_XIP,\n\t.size = 16*1024*1024,\n\t.copy_from = dc21285_copy_from,\n};\n\n \nstatic const char * const probes[] = { \"RedBoot\", \"cmdlinepart\", NULL };\n\nstatic int __init init_dc21285(void)\n{\n\t \n\tswitch (*CSR_SA110_CNTL & (3<<14)) {\n\t\tcase SA110_CNTL_ROMWIDTH_8:\n\t\t\tdc21285_map.bankwidth = 1;\n\t\t\tdc21285_map.read = dc21285_read8;\n\t\t\tdc21285_map.write = dc21285_write8;\n\t\t\tdc21285_map.copy_to = dc21285_copy_to_8;\n\t\t\tbreak;\n\t\tcase SA110_CNTL_ROMWIDTH_16:\n\t\t\tdc21285_map.bankwidth = 2;\n\t\t\tdc21285_map.read = dc21285_read16;\n\t\t\tdc21285_map.write = dc21285_write16;\n\t\t\tdc21285_map.copy_to = dc21285_copy_to_16;\n\t\t\tbreak;\n\t\tcase SA110_CNTL_ROMWIDTH_32:\n\t\t\tdc21285_map.bankwidth = 4;\n\t\t\tdc21285_map.read = dc21285_read32;\n\t\t\tdc21285_map.write = dc21285_write32;\n\t\t\tdc21285_map.copy_to = dc21285_copy_to_32;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintk (KERN_ERR \"DC21285 flash: undefined bankwidth\\n\");\n\t\t\treturn -ENXIO;\n\t}\n\tprintk (KERN_NOTICE \"DC21285 flash support (%d-bit bankwidth)\\n\",\n\t\tdc21285_map.bankwidth*8);\n\n\t \n\tdc21285_map.virt = ioremap(DC21285_FLASH, 16*1024*1024);\n\tif (!dc21285_map.virt) {\n\t\tprintk(\"Failed to ioremap\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (machine_is_ebsa285()) {\n\t\tdc21285_mtd = do_map_probe(\"cfi_probe\", &dc21285_map);\n\t} else {\n\t\tdc21285_mtd = do_map_probe(\"jedec_probe\", &dc21285_map);\n\t}\n\n\tif (!dc21285_mtd) {\n\t\tiounmap(dc21285_map.virt);\n\t\treturn -ENXIO;\n\t}\n\n\tdc21285_mtd->owner = THIS_MODULE;\n\n\tmtd_device_parse_register(dc21285_mtd, probes, NULL, NULL, 0);\n\n\tif(machine_is_ebsa285()) {\n\t\t \n\t\t \n\t\t*CSR_SA110_CNTL = ((*CSR_SA110_CNTL & ~0x000f0000) | (7 << 16));\n\t\t \n\t\t*CSR_SA110_CNTL = ((*CSR_SA110_CNTL & ~0x00f00000) | (7 << 20));\n\t\t \n\t\t*CSR_SA110_CNTL = ((*CSR_SA110_CNTL & ~0x0f000000) | (7 << 24));\n\t}\n\n\treturn 0;\n}\n\nstatic void __exit cleanup_dc21285(void)\n{\n\tmtd_device_unregister(dc21285_mtd);\n\tmap_destroy(dc21285_mtd);\n\tiounmap(dc21285_map.virt);\n}\n\nmodule_init(init_dc21285);\nmodule_exit(cleanup_dc21285);\n\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Nicolas Pitre <nico@fluxnic.net>\");\nMODULE_DESCRIPTION(\"MTD map driver for DC21285 boards\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}