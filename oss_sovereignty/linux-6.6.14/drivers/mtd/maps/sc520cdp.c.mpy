{
  "module_name": "sc520cdp.c",
  "hash_id": "3adb0a3b6b81e7e117837e23fbbcd4c27ee5b01fdb347abb7046f7c208096b92",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/maps/sc520cdp.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <asm/io.h>\n#include <linux/mtd/mtd.h>\n#include <linux/mtd/map.h>\n#include <linux/mtd/concat.h>\n\n \n#define REPROGRAM_PAR\n\n\n\n#ifdef REPROGRAM_PAR\n\n \n#define WINDOW_ADDR_0\t0x08800000\n#define WINDOW_ADDR_1\t0x09000000\n#define WINDOW_ADDR_2\t0x09800000\n\n \n#define WINDOW_ADDR_0_BIOS\t0x08400000\n#define WINDOW_ADDR_1_BIOS\t0x08c00000\n#define WINDOW_ADDR_2_BIOS\t0x09400000\n\n#else\n\n#define WINDOW_ADDR_0\t0x08400000\n#define WINDOW_ADDR_1\t0x08C00000\n#define WINDOW_ADDR_2\t0x09400000\n\n#endif\n\n#define WINDOW_SIZE_0\t0x00800000\n#define WINDOW_SIZE_1\t0x00800000\n#define WINDOW_SIZE_2\t0x00080000\n\n\nstatic struct map_info sc520cdp_map[] = {\n\t{\n\t\t.name = \"SC520CDP Flash Bank #0\",\n\t\t.size = WINDOW_SIZE_0,\n\t\t.bankwidth = 4,\n\t\t.phys = WINDOW_ADDR_0\n\t},\n\t{\n\t\t.name = \"SC520CDP Flash Bank #1\",\n\t\t.size = WINDOW_SIZE_1,\n\t\t.bankwidth = 4,\n\t\t.phys = WINDOW_ADDR_1\n\t},\n\t{\n\t\t.name = \"SC520CDP DIL Flash\",\n\t\t.size = WINDOW_SIZE_2,\n\t\t.bankwidth = 1,\n\t\t.phys = WINDOW_ADDR_2\n\t},\n};\n\n#define NUM_FLASH_BANKS\tARRAY_SIZE(sc520cdp_map)\n\nstatic struct mtd_info *mymtd[NUM_FLASH_BANKS];\nstatic struct mtd_info *merged_mtd;\n\n#ifdef REPROGRAM_PAR\n\n \n#define SC520_MMCR_BASE\t\t0xFFFEF000\n#define SC520_MMCR_EXTENT\t0x1000\n#define SC520_PAR(x)\t\t((0x88/sizeof(unsigned long)) + (x))\n#define NUM_SC520_PAR\t\t16\t \n\n \n#define SC520_PAR_BOOTCS\t(0x4<<29)\n#define SC520_PAR_ROMCS0\t(0x5<<29)\n#define SC520_PAR_ROMCS1\t(0x6<<29)\n#define SC520_PAR_TRGDEV\t(0x7<<29)\n\n \n#define SC520_PAR_WRPROT\t(1<<26)\t \n#define SC520_PAR_NOCACHE\t(1<<27)\t \n#define SC520_PAR_NOEXEC\t(1<<28)\t \n\n\n \n#define SC520_PAR_PG_SIZ4\t(0<<25)\n#define SC520_PAR_PG_SIZ64\t(1<<25)\n\n \n#define SC520_PAR_ENTRY(trgdev, address, size) \\\n\t((trgdev) | SC520_PAR_NOCACHE | SC520_PAR_PG_SIZ64 | \\\n\t(address) >> 16 | (((size) >> 16) - 1) << 14)\n\nstruct sc520_par_table\n{\n\tunsigned long trgdev;\n\tunsigned long new_par;\n\tunsigned long default_address;\n};\n\nstatic const struct sc520_par_table par_table[NUM_FLASH_BANKS] =\n{\n\t{\t \n\t\tSC520_PAR_ROMCS0,\n\t\tSC520_PAR_ENTRY(SC520_PAR_ROMCS0, WINDOW_ADDR_0, WINDOW_SIZE_0),\n\t\tWINDOW_ADDR_0_BIOS\n\t},\n\t{\t \n\t\tSC520_PAR_ROMCS1,\n\t\tSC520_PAR_ENTRY(SC520_PAR_ROMCS1, WINDOW_ADDR_1, WINDOW_SIZE_1),\n\t\tWINDOW_ADDR_1_BIOS\n\t},\n\t{\t \n\t\tSC520_PAR_BOOTCS,\n\t\tSC520_PAR_ENTRY(SC520_PAR_BOOTCS, WINDOW_ADDR_2, WINDOW_SIZE_2),\n\t\tWINDOW_ADDR_2_BIOS\n\t}\n};\n\n\nstatic void sc520cdp_setup_par(void)\n{\n\tunsigned long __iomem *mmcr;\n\tunsigned long mmcr_val;\n\tint i, j;\n\n\t \n\tmmcr = ioremap(SC520_MMCR_BASE, SC520_MMCR_EXTENT);\n\tif(!mmcr) {  \n\t\t \n\t\tfor(i = 0; i < NUM_FLASH_BANKS; i++)\n\t\t\tsc520cdp_map[i].phys = par_table[i].default_address;\n\t\treturn;\n\t}\n\n\t \n\tfor(i = 0; i < NUM_FLASH_BANKS; i++) {\t\t \n\t\tfor(j = 0; j < NUM_SC520_PAR; j++) {\t \n\t\t\tmmcr_val = readl(&mmcr[SC520_PAR(j)]);\n\t\t\t \n\t\t\tif((mmcr_val & SC520_PAR_TRGDEV) == par_table[i].trgdev)\n\t\t\t{\n\t\t\t\twritel(par_table[i].new_par, &mmcr[SC520_PAR(j)]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(j == NUM_SC520_PAR)\n\t\t{\t \n\t\t\tprintk(KERN_NOTICE \"Could not find PAR responsible for %s\\n\",\n\t\t\t\tsc520cdp_map[i].name);\n\t\t\tprintk(KERN_NOTICE \"Trying default address 0x%lx\\n\",\n\t\t\t\tpar_table[i].default_address);\n\t\t\tsc520cdp_map[i].phys = par_table[i].default_address;\n\t\t}\n\t}\n\tiounmap(mmcr);\n}\n#endif\n\n\nstatic int __init init_sc520cdp(void)\n{\n\tint i, j, devices_found = 0;\n\n#ifdef REPROGRAM_PAR\n\t \n\tsc520cdp_setup_par();\n#endif\n\n\tfor (i = 0; i < NUM_FLASH_BANKS; i++) {\n\t\tprintk(KERN_NOTICE \"SC520 CDP flash device: 0x%Lx at 0x%Lx\\n\",\n\t\t\t(unsigned long long)sc520cdp_map[i].size,\n\t\t\t(unsigned long long)sc520cdp_map[i].phys);\n\n\t\tsc520cdp_map[i].virt = ioremap(sc520cdp_map[i].phys, sc520cdp_map[i].size);\n\n\t\tif (!sc520cdp_map[i].virt) {\n\t\t\tprintk(\"Failed to ioremap\\n\");\n\t\t\tfor (j = 0; j < i; j++) {\n\t\t\t\tif (mymtd[j]) {\n\t\t\t\t\tmap_destroy(mymtd[j]);\n\t\t\t\t\tiounmap(sc520cdp_map[j].virt);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tsimple_map_init(&sc520cdp_map[i]);\n\n\t\tmymtd[i] = do_map_probe(\"cfi_probe\", &sc520cdp_map[i]);\n\t\tif(!mymtd[i])\n\t\t\tmymtd[i] = do_map_probe(\"jedec_probe\", &sc520cdp_map[i]);\n\t\tif(!mymtd[i])\n\t\t\tmymtd[i] = do_map_probe(\"map_rom\", &sc520cdp_map[i]);\n\n\t\tif (mymtd[i]) {\n\t\t\tmymtd[i]->owner = THIS_MODULE;\n\t\t\t++devices_found;\n\t\t}\n\t\telse {\n\t\t\tiounmap(sc520cdp_map[i].virt);\n\t\t}\n\t}\n\tif(devices_found >= 2) {\n\t\t \n\t\tmerged_mtd = mtd_concat_create(mymtd, 2, \"SC520CDP Flash Banks #0 and #1\");\n\t\tif(merged_mtd)\n\t\t\tmtd_device_register(merged_mtd, NULL, 0);\n\t}\n\tif(devices_found == 3)  \n\t\tmtd_device_register(mymtd[2], NULL, 0);\n\treturn(devices_found ? 0 : -ENXIO);\n}\n\nstatic void __exit cleanup_sc520cdp(void)\n{\n\tint i;\n\n\tif (merged_mtd) {\n\t\tmtd_device_unregister(merged_mtd);\n\t\tmtd_concat_destroy(merged_mtd);\n\t}\n\tif (mymtd[2])\n\t\tmtd_device_unregister(mymtd[2]);\n\n\tfor (i = 0; i < NUM_FLASH_BANKS; i++) {\n\t\tif (mymtd[i])\n\t\t\tmap_destroy(mymtd[i]);\n\t\tif (sc520cdp_map[i].virt) {\n\t\t\tiounmap(sc520cdp_map[i].virt);\n\t\t\tsc520cdp_map[i].virt = NULL;\n\t\t}\n\t}\n}\n\nmodule_init(init_sc520cdp);\nmodule_exit(cleanup_sc520cdp);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Sysgo Real-Time Solutions GmbH\");\nMODULE_DESCRIPTION(\"MTD map driver for AMD SC520 Customer Development Platform\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}