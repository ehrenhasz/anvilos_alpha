{
  "module_name": "vmu-flash.c",
  "hash_id": "313a7dc4ee47c1c831b85320a145941d94946dc191c217e1b63af3f072aca4f6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/maps/vmu-flash.c",
  "human_readable_source": "\n \n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/maple.h>\n#include <linux/mtd/mtd.h>\n#include <linux/mtd/map.h>\n\nstruct vmu_cache {\n\tunsigned char *buffer;\t\t \n\tunsigned int block;\t\t \n\tunsigned long jiffies_atc;\t \n\tint valid;\n};\n\nstruct mdev_part {\n\tstruct maple_device *mdev;\n\tint partition;\n};\n\nstruct vmupart {\n\tu16 user_blocks;\n\tu16 root_block;\n\tu16 numblocks;\n\tchar *name;\n\tstruct vmu_cache *pcache;\n};\n\nstruct memcard {\n\tu16 tempA;\n\tu16 tempB;\n\tu32 partitions;\n\tu32 blocklen;\n\tu32 writecnt;\n\tu32 readcnt;\n\tu32 removable;\n\tint partition;\n\tint read;\n\tunsigned char *blockread;\n\tstruct vmupart *parts;\n\tstruct mtd_info *mtd;\n};\n\nstruct vmu_block {\n\tunsigned int num;  \n\tunsigned int ofs;  \n};\n\nstatic struct vmu_block *ofs_to_block(unsigned long src_ofs,\n\tstruct mtd_info *mtd, int partition)\n{\n\tstruct vmu_block *vblock;\n\tstruct maple_device *mdev;\n\tstruct memcard *card;\n\tstruct mdev_part *mpart;\n\tint num;\n\n\tmpart = mtd->priv;\n\tmdev = mpart->mdev;\n\tcard = maple_get_drvdata(mdev);\n\n\tif (src_ofs >= card->parts[partition].numblocks * card->blocklen)\n\t\tgoto failed;\n\n\tnum = src_ofs / card->blocklen;\n\tif (num > card->parts[partition].numblocks)\n\t\tgoto failed;\n\n\tvblock = kmalloc(sizeof(struct vmu_block), GFP_KERNEL);\n\tif (!vblock)\n\t\tgoto failed;\n\n\tvblock->num = num;\n\tvblock->ofs = src_ofs % card->blocklen;\n\treturn vblock;\n\nfailed:\n\treturn NULL;\n}\n\n \nstatic void vmu_blockread(struct mapleq *mq)\n{\n\tstruct maple_device *mdev;\n\tstruct memcard *card;\n\n\tmdev = mq->dev;\n\tcard = maple_get_drvdata(mdev);\n\t \n\n\tif (unlikely(!card->blockread))\n\t\treturn;\n\n\tmemcpy(card->blockread, mq->recvbuf->buf + 12,\n\t\tcard->blocklen/card->readcnt);\n\n}\n\n \nstatic int maple_vmu_read_block(unsigned int num, unsigned char *buf,\n\tstruct mtd_info *mtd)\n{\n\tstruct memcard *card;\n\tstruct mdev_part *mpart;\n\tstruct maple_device *mdev;\n\tint partition, error = 0, x, wait;\n\tunsigned char *blockread = NULL;\n\tstruct vmu_cache *pcache;\n\t__be32 sendbuf;\n\n\tmpart = mtd->priv;\n\tmdev = mpart->mdev;\n\tpartition = mpart->partition;\n\tcard = maple_get_drvdata(mdev);\n\tpcache = card->parts[partition].pcache;\n\tpcache->valid = 0;\n\n\t \n\tif (!pcache->buffer) {\n\t\tpcache->buffer = kmalloc(card->blocklen, GFP_KERNEL);\n\t\tif (!pcache->buffer) {\n\t\t\tdev_err(&mdev->dev, \"VMU at (%d, %d) - read fails due\"\n\t\t\t\t\" to lack of memory\\n\", mdev->port,\n\t\t\t\tmdev->unit);\n\t\t\terror = -ENOMEM;\n\t\t\tgoto outB;\n\t\t}\n\t}\n\n\t \n\tfor (x = 0; x < card->readcnt; x++) {\n\t\tsendbuf = cpu_to_be32(partition << 24 | x << 16 | num);\n\n\t\tif (atomic_read(&mdev->busy) == 1) {\n\t\t\twait_event_interruptible_timeout(mdev->maple_wait,\n\t\t\t\tatomic_read(&mdev->busy) == 0, HZ);\n\t\t\tif (atomic_read(&mdev->busy) == 1) {\n\t\t\t\tdev_notice(&mdev->dev, \"VMU at (%d, %d)\"\n\t\t\t\t\t\" is busy\\n\", mdev->port, mdev->unit);\n\t\t\t\terror = -EAGAIN;\n\t\t\t\tgoto outB;\n\t\t\t}\n\t\t}\n\n\t\tatomic_set(&mdev->busy, 1);\n\t\tblockread = kmalloc(card->blocklen/card->readcnt, GFP_KERNEL);\n\t\tif (!blockread) {\n\t\t\terror = -ENOMEM;\n\t\t\tatomic_set(&mdev->busy, 0);\n\t\t\tgoto outB;\n\t\t}\n\t\tcard->blockread = blockread;\n\n\t\tmaple_getcond_callback(mdev, vmu_blockread, 0,\n\t\t\tMAPLE_FUNC_MEMCARD);\n\t\terror = maple_add_packet(mdev, MAPLE_FUNC_MEMCARD,\n\t\t\t\tMAPLE_COMMAND_BREAD, 2, &sendbuf);\n\t\t \n\t\twait = wait_event_interruptible_timeout(mdev->maple_wait,\n\t\t\t(atomic_read(&mdev->busy) == 0 ||\n\t\t\tatomic_read(&mdev->busy) == 2), HZ * 3);\n\t\t \n\t\tif (error || atomic_read(&mdev->busy) == 2) {\n\t\t\tif (atomic_read(&mdev->busy) == 2)\n\t\t\t\terror = -ENXIO;\n\t\t\tatomic_set(&mdev->busy, 0);\n\t\t\tcard->blockread = NULL;\n\t\t\tgoto outA;\n\t\t}\n\t\tif (wait == 0 || wait == -ERESTARTSYS) {\n\t\t\tcard->blockread = NULL;\n\t\t\tatomic_set(&mdev->busy, 0);\n\t\t\terror = -EIO;\n\t\t\tlist_del_init(&(mdev->mq->list));\n\t\t\tkfree(mdev->mq->sendbuf);\n\t\t\tmdev->mq->sendbuf = NULL;\n\t\t\tif (wait == -ERESTARTSYS) {\n\t\t\t\tdev_warn(&mdev->dev, \"VMU read on (%d, %d)\"\n\t\t\t\t\t\" interrupted on block 0x%X\\n\",\n\t\t\t\t\tmdev->port, mdev->unit, num);\n\t\t\t} else\n\t\t\t\tdev_notice(&mdev->dev, \"VMU read on (%d, %d)\"\n\t\t\t\t\t\" timed out on block 0x%X\\n\",\n\t\t\t\t\tmdev->port, mdev->unit, num);\n\t\t\tgoto outA;\n\t\t}\n\n\t\tmemcpy(buf + (card->blocklen/card->readcnt) * x, blockread,\n\t\t\tcard->blocklen/card->readcnt);\n\n\t\tmemcpy(pcache->buffer + (card->blocklen/card->readcnt) * x,\n\t\t\tcard->blockread, card->blocklen/card->readcnt);\n\t\tcard->blockread = NULL;\n\t\tpcache->block = num;\n\t\tpcache->jiffies_atc = jiffies;\n\t\tpcache->valid = 1;\n\t\tkfree(blockread);\n\t}\n\n\treturn error;\n\noutA:\n\tkfree(blockread);\noutB:\n\treturn error;\n}\n\n \nstatic int maple_vmu_write_block(unsigned int num, const unsigned char *buf,\n\tstruct mtd_info *mtd)\n{\n\tstruct memcard *card;\n\tstruct mdev_part *mpart;\n\tstruct maple_device *mdev;\n\tint partition, error, locking, x, phaselen, wait;\n\t__be32 *sendbuf;\n\n\tmpart = mtd->priv;\n\tmdev = mpart->mdev;\n\tpartition = mpart->partition;\n\tcard = maple_get_drvdata(mdev);\n\n\tphaselen = card->blocklen/card->writecnt;\n\n\tsendbuf = kmalloc(phaselen + 4, GFP_KERNEL);\n\tif (!sendbuf) {\n\t\terror = -ENOMEM;\n\t\tgoto fail_nosendbuf;\n\t}\n\tfor (x = 0; x < card->writecnt; x++) {\n\t\tsendbuf[0] = cpu_to_be32(partition << 24 | x << 16 | num);\n\t\tmemcpy(&sendbuf[1], buf + phaselen * x, phaselen);\n\t\t \n\t\tif (atomic_read(&mdev->busy) == 1) {\n\t\t\twait_event_interruptible_timeout(mdev->maple_wait,\n\t\t\t\tatomic_read(&mdev->busy) == 0, HZ);\n\t\t\tif (atomic_read(&mdev->busy) == 1) {\n\t\t\t\terror = -EBUSY;\n\t\t\t\tdev_notice(&mdev->dev, \"VMU write at (%d, %d)\"\n\t\t\t\t\t\"failed - device is busy\\n\",\n\t\t\t\t\tmdev->port, mdev->unit);\n\t\t\t\tgoto fail_nolock;\n\t\t\t}\n\t\t}\n\t\tatomic_set(&mdev->busy, 1);\n\n\t\tlocking = maple_add_packet(mdev, MAPLE_FUNC_MEMCARD,\n\t\t\tMAPLE_COMMAND_BWRITE, phaselen / 4 + 2, sendbuf);\n\t\twait = wait_event_interruptible_timeout(mdev->maple_wait,\n\t\t\tatomic_read(&mdev->busy) == 0, HZ/10);\n\t\tif (locking) {\n\t\t\terror = -EIO;\n\t\t\tatomic_set(&mdev->busy, 0);\n\t\t\tgoto fail_nolock;\n\t\t}\n\t\tif (atomic_read(&mdev->busy) == 2) {\n\t\t\tatomic_set(&mdev->busy, 0);\n\t\t} else if (wait == 0 || wait == -ERESTARTSYS) {\n\t\t\terror = -EIO;\n\t\t\tdev_warn(&mdev->dev, \"Write at (%d, %d) of block\"\n\t\t\t\t\" 0x%X at phase %d failed: could not\"\n\t\t\t\t\" communicate with VMU\", mdev->port,\n\t\t\t\tmdev->unit, num, x);\n\t\t\tatomic_set(&mdev->busy, 0);\n\t\t\tkfree(mdev->mq->sendbuf);\n\t\t\tmdev->mq->sendbuf = NULL;\n\t\t\tlist_del_init(&(mdev->mq->list));\n\t\t\tgoto fail_nolock;\n\t\t}\n\t}\n\tkfree(sendbuf);\n\n\treturn card->blocklen;\n\nfail_nolock:\n\tkfree(sendbuf);\nfail_nosendbuf:\n\tdev_err(&mdev->dev, \"VMU (%d, %d): write failed\\n\", mdev->port,\n\t\tmdev->unit);\n\treturn error;\n}\n\n \nstatic unsigned char vmu_flash_read_char(unsigned long ofs, int *retval,\n\tstruct mtd_info *mtd)\n{\n\tstruct vmu_block *vblock;\n\tstruct memcard *card;\n\tstruct mdev_part *mpart;\n\tstruct maple_device *mdev;\n\tunsigned char *buf, ret;\n\tint partition, error;\n\n\tmpart = mtd->priv;\n\tmdev = mpart->mdev;\n\tpartition = mpart->partition;\n\tcard = maple_get_drvdata(mdev);\n\t*retval =  0;\n\n\tbuf = kmalloc(card->blocklen, GFP_KERNEL);\n\tif (!buf) {\n\t\t*retval = 1;\n\t\tret = -ENOMEM;\n\t\tgoto finish;\n\t}\n\n\tvblock = ofs_to_block(ofs, mtd, partition);\n\tif (!vblock) {\n\t\t*retval = 3;\n\t\tret = -ENOMEM;\n\t\tgoto out_buf;\n\t}\n\n\terror = maple_vmu_read_block(vblock->num, buf, mtd);\n\tif (error) {\n\t\tret = error;\n\t\t*retval = 2;\n\t\tgoto out_vblock;\n\t}\n\n\tret = buf[vblock->ofs];\n\nout_vblock:\n\tkfree(vblock);\nout_buf:\n\tkfree(buf);\nfinish:\n\treturn ret;\n}\n\n \nstatic int vmu_flash_read(struct mtd_info *mtd, loff_t from, size_t len,\n\tsize_t *retlen,  u_char *buf)\n{\n\tstruct maple_device *mdev;\n\tstruct memcard *card;\n\tstruct mdev_part *mpart;\n\tstruct vmu_cache *pcache;\n\tstruct vmu_block *vblock;\n\tint index = 0, retval, partition, leftover, numblocks;\n\tunsigned char cx;\n\n\tmpart = mtd->priv;\n\tmdev = mpart->mdev;\n\tpartition = mpart->partition;\n\tcard = maple_get_drvdata(mdev);\n\n\tnumblocks = card->parts[partition].numblocks;\n\tif (from + len > numblocks * card->blocklen)\n\t\tlen = numblocks * card->blocklen - from;\n\tif (len == 0)\n\t\treturn -EIO;\n\t \n\tpcache = card->parts[partition].pcache;\n\tdo {\n\t\tvblock =  ofs_to_block(from + index, mtd, partition);\n\t\tif (!vblock)\n\t\t\treturn -ENOMEM;\n\t\t \n\t\tif (pcache->valid &&\n\t\t\ttime_before(jiffies, pcache->jiffies_atc + HZ) &&\n\t\t\t(pcache->block == vblock->num)) {\n\t\t\t \n\t\t\tleftover = card->blocklen - vblock->ofs;\n\t\t\tif (vblock->ofs + len - index < card->blocklen) {\n\t\t\t\t \n\t\t\t\tmemcpy(buf + index,\n\t\t\t\t\tpcache->buffer + vblock->ofs,\n\t\t\t\t\tlen - index);\n\t\t\t\tindex = len;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tmemcpy(buf + index, pcache->buffer +\n\t\t\t\t\tvblock->ofs, leftover);\n\t\t\t\tindex += leftover;\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tcx = vmu_flash_read_char(from + index, &retval, mtd);\n\t\t\tif (retval) {\n\t\t\t\t*retlen = index;\n\t\t\t\tkfree(vblock);\n\t\t\t\treturn cx;\n\t\t\t}\n\t\t\tmemset(buf + index, cx, 1);\n\t\t\tindex++;\n\t\t}\n\t\tkfree(vblock);\n\t} while (len > index);\n\t*retlen = index;\n\n\treturn 0;\n}\n\nstatic int vmu_flash_write(struct mtd_info *mtd, loff_t to, size_t len,\n\tsize_t *retlen, const u_char *buf)\n{\n\tstruct maple_device *mdev;\n\tstruct memcard *card;\n\tstruct mdev_part *mpart;\n\tint index = 0, partition, error = 0, numblocks;\n\tstruct vmu_cache *pcache;\n\tstruct vmu_block *vblock;\n\tunsigned char *buffer;\n\n\tmpart = mtd->priv;\n\tmdev = mpart->mdev;\n\tpartition = mpart->partition;\n\tcard = maple_get_drvdata(mdev);\n\n\tnumblocks = card->parts[partition].numblocks;\n\tif (to + len > numblocks * card->blocklen)\n\t\tlen = numblocks * card->blocklen - to;\n\tif (len == 0) {\n\t\terror = -EIO;\n\t\tgoto failed;\n\t}\n\n\tvblock = ofs_to_block(to, mtd, partition);\n\tif (!vblock) {\n\t\terror = -ENOMEM;\n\t\tgoto failed;\n\t}\n\n\tbuffer = kmalloc(card->blocklen, GFP_KERNEL);\n\tif (!buffer) {\n\t\terror = -ENOMEM;\n\t\tgoto fail_buffer;\n\t}\n\n\tdo {\n\t\t \n\t\terror = maple_vmu_read_block(vblock->num, buffer, mtd);\n\t\tif (error)\n\t\t\tgoto fail_io;\n\n\t\tdo {\n\t\t\tbuffer[vblock->ofs] = buf[index];\n\t\t\tvblock->ofs++;\n\t\t\tindex++;\n\t\t\tif (index >= len)\n\t\t\t\tbreak;\n\t\t} while (vblock->ofs < card->blocklen);\n\n\t\t \n\t\terror = maple_vmu_write_block(vblock->num, buffer, mtd);\n\t\t \n\t\tpcache = card->parts[partition].pcache;\n\t\tpcache->valid = 0;\n\n\t\tif (error != card->blocklen)\n\t\t\tgoto fail_io;\n\n\t\tvblock->num++;\n\t\tvblock->ofs = 0;\n\t} while (len > index);\n\n\tkfree(buffer);\n\t*retlen = index;\n\tkfree(vblock);\n\treturn 0;\n\nfail_io:\n\tkfree(buffer);\nfail_buffer:\n\tkfree(vblock);\nfailed:\n\tdev_err(&mdev->dev, \"VMU write failing with error %d\\n\", error);\n\treturn error;\n}\n\nstatic void vmu_flash_sync(struct mtd_info *mtd)\n{\n\t \n}\n\n \nstatic void vmu_queryblocks(struct mapleq *mq)\n{\n\tstruct maple_device *mdev;\n\tunsigned short *res;\n\tstruct memcard *card;\n\t__be32 partnum;\n\tstruct vmu_cache *pcache;\n\tstruct mdev_part *mpart;\n\tstruct mtd_info *mtd_cur;\n\tstruct vmupart *part_cur;\n\tint error;\n\n\tmdev = mq->dev;\n\tcard = maple_get_drvdata(mdev);\n\tres = (unsigned short *) (mq->recvbuf->buf);\n\tcard->tempA = res[12];\n\tcard->tempB = res[6];\n\n\tdev_info(&mdev->dev, \"VMU device at partition %d has %d user \"\n\t\t\"blocks with a root block at %d\\n\", card->partition,\n\t\tcard->tempA, card->tempB);\n\n\tpart_cur = &card->parts[card->partition];\n\tpart_cur->user_blocks = card->tempA;\n\tpart_cur->root_block = card->tempB;\n\tpart_cur->numblocks = card->tempB + 1;\n\tpart_cur->name = kmalloc(12, GFP_KERNEL);\n\tif (!part_cur->name)\n\t\tgoto fail_name;\n\n\tsprintf(part_cur->name, \"vmu%d.%d.%d\",\n\t\tmdev->port, mdev->unit, card->partition);\n\tmtd_cur = &card->mtd[card->partition];\n\tmtd_cur->name = part_cur->name;\n\tmtd_cur->type = 8;\n\tmtd_cur->flags = MTD_WRITEABLE|MTD_NO_ERASE;\n\tmtd_cur->size = part_cur->numblocks * card->blocklen;\n\tmtd_cur->erasesize = card->blocklen;\n\tmtd_cur->_write = vmu_flash_write;\n\tmtd_cur->_read = vmu_flash_read;\n\tmtd_cur->_sync = vmu_flash_sync;\n\tmtd_cur->writesize = card->blocklen;\n\n\tmpart = kmalloc(sizeof(struct mdev_part), GFP_KERNEL);\n\tif (!mpart)\n\t\tgoto fail_mpart;\n\n\tmpart->mdev = mdev;\n\tmpart->partition = card->partition;\n\tmtd_cur->priv = mpart;\n\tmtd_cur->owner = THIS_MODULE;\n\n\tpcache = kzalloc(sizeof(struct vmu_cache), GFP_KERNEL);\n\tif (!pcache)\n\t\tgoto fail_cache_create;\n\tpart_cur->pcache = pcache;\n\n\terror = mtd_device_register(mtd_cur, NULL, 0);\n\tif (error)\n\t\tgoto fail_mtd_register;\n\n\tmaple_getcond_callback(mdev, NULL, 0,\n\t\tMAPLE_FUNC_MEMCARD);\n\n\t \n\tif (++card->partition < card->partitions) {\n\t\tpartnum = cpu_to_be32(card->partition << 24);\n\t\tmaple_getcond_callback(mdev, vmu_queryblocks, 0,\n\t\t\tMAPLE_FUNC_MEMCARD);\n\t\tmaple_add_packet(mdev, MAPLE_FUNC_MEMCARD,\n\t\t\tMAPLE_COMMAND_GETMINFO, 2, &partnum);\n\t}\n\treturn;\n\nfail_mtd_register:\n\tdev_err(&mdev->dev, \"Could not register maple device at (%d, %d)\"\n\t\t\"error is 0x%X\\n\", mdev->port, mdev->unit, error);\n\tfor (error = 0; error <= card->partition; error++) {\n\t\tkfree(((card->parts)[error]).pcache);\n\t\t((card->parts)[error]).pcache = NULL;\n\t}\nfail_cache_create:\nfail_mpart:\n\tfor (error = 0; error <= card->partition; error++) {\n\t\tkfree(((card->mtd)[error]).priv);\n\t\t((card->mtd)[error]).priv = NULL;\n\t}\n\tmaple_getcond_callback(mdev, NULL, 0,\n\t\tMAPLE_FUNC_MEMCARD);\n\tkfree(part_cur->name);\nfail_name:\n\treturn;\n}\n\n \nstatic int vmu_connect(struct maple_device *mdev)\n{\n\tunsigned long test_flash_data, basic_flash_data;\n\tint c, error;\n\tstruct memcard *card;\n\tu32 partnum = 0;\n\n\ttest_flash_data = be32_to_cpu(mdev->devinfo.function);\n\t \n\tc = hweight_long(test_flash_data);\n\n\tbasic_flash_data = be32_to_cpu(mdev->devinfo.function_data[c - 1]);\n\n\tcard = kmalloc(sizeof(struct memcard), GFP_KERNEL);\n\tif (!card) {\n\t\terror = -ENOMEM;\n\t\tgoto fail_nomem;\n\t}\n\n\tcard->partitions = (basic_flash_data >> 24 & 0xFF) + 1;\n\tcard->blocklen = ((basic_flash_data >> 16 & 0xFF) + 1) << 5;\n\tcard->writecnt = basic_flash_data >> 12 & 0xF;\n\tcard->readcnt = basic_flash_data >> 8 & 0xF;\n\tcard->removable = basic_flash_data >> 7 & 1;\n\n\tcard->partition = 0;\n\n\t \n\tcard->parts = kmalloc_array(card->partitions, sizeof(struct vmupart),\n\t\t\t\t    GFP_KERNEL);\n\tif (!card->parts) {\n\t\terror = -ENOMEM;\n\t\tgoto fail_partitions;\n\t}\n\n\tcard->mtd = kmalloc_array(card->partitions, sizeof(struct mtd_info),\n\t\t\t\t  GFP_KERNEL);\n\tif (!card->mtd) {\n\t\terror = -ENOMEM;\n\t\tgoto fail_mtd_info;\n\t}\n\n\tmaple_set_drvdata(mdev, card);\n\n\t \n\tmaple_getcond_callback(mdev, vmu_queryblocks, 0,\n\t\tMAPLE_FUNC_MEMCARD);\n\n\t \n\tif (atomic_read(&mdev->busy) == 1) {\n\t\twait_event_interruptible_timeout(mdev->maple_wait,\n\t\t\tatomic_read(&mdev->busy) == 0, HZ);\n\t\tif (atomic_read(&mdev->busy) == 1) {\n\t\t\tdev_notice(&mdev->dev, \"VMU at (%d, %d) is busy\\n\",\n\t\t\t\tmdev->port, mdev->unit);\n\t\t\terror = -EAGAIN;\n\t\t\tgoto fail_device_busy;\n\t\t}\n\t}\n\n\tatomic_set(&mdev->busy, 1);\n\n\t \n\terror = maple_add_packet(mdev, MAPLE_FUNC_MEMCARD,\n\t\tMAPLE_COMMAND_GETMINFO, 2, &partnum);\n\tif (error) {\n\t\tdev_err(&mdev->dev, \"Could not lock VMU at (%d, %d)\"\n\t\t\t\" error is 0x%X\\n\", mdev->port, mdev->unit, error);\n\t\tgoto fail_mtd_info;\n\t}\n\treturn 0;\n\nfail_device_busy:\n\tkfree(card->mtd);\nfail_mtd_info:\n\tkfree(card->parts);\nfail_partitions:\n\tkfree(card);\nfail_nomem:\n\treturn error;\n}\n\nstatic void vmu_disconnect(struct maple_device *mdev)\n{\n\tstruct memcard *card;\n\tstruct mdev_part *mpart;\n\tint x;\n\n\tmdev->callback = NULL;\n\tcard = maple_get_drvdata(mdev);\n\tfor (x = 0; x < card->partitions; x++) {\n\t\tmpart = ((card->mtd)[x]).priv;\n\t\tmpart->mdev = NULL;\n\t\tmtd_device_unregister(&((card->mtd)[x]));\n\t\tkfree(((card->parts)[x]).name);\n\t}\n\tkfree(card->parts);\n\tkfree(card->mtd);\n\tkfree(card);\n}\n\n \nstatic int vmu_can_unload(struct maple_device *mdev)\n{\n\tstruct memcard *card;\n\tint x;\n\tstruct mtd_info *mtd;\n\n\tcard = maple_get_drvdata(mdev);\n\tfor (x = 0; x < card->partitions; x++) {\n\t\tmtd = &((card->mtd)[x]);\n\t\tif (mtd->usecount > 0)\n\t\t\treturn 0;\n\t}\n\treturn 1;\n}\n\n#define ERRSTR \"VMU at (%d, %d) file error -\"\n\nstatic void vmu_file_error(struct maple_device *mdev, void *recvbuf)\n{\n\tenum maple_file_errors error = ((int *)recvbuf)[1];\n\n\tswitch (error) {\n\n\tcase MAPLE_FILEERR_INVALID_PARTITION:\n\t\tdev_notice(&mdev->dev, ERRSTR \" invalid partition number\\n\",\n\t\t\tmdev->port, mdev->unit);\n\t\tbreak;\n\n\tcase MAPLE_FILEERR_PHASE_ERROR:\n\t\tdev_notice(&mdev->dev, ERRSTR \" phase error\\n\",\n\t\t\tmdev->port, mdev->unit);\n\t\tbreak;\n\n\tcase MAPLE_FILEERR_INVALID_BLOCK:\n\t\tdev_notice(&mdev->dev, ERRSTR \" invalid block number\\n\",\n\t\t\tmdev->port, mdev->unit);\n\t\tbreak;\n\n\tcase MAPLE_FILEERR_WRITE_ERROR:\n\t\tdev_notice(&mdev->dev, ERRSTR \" write error\\n\",\n\t\t\tmdev->port, mdev->unit);\n\t\tbreak;\n\n\tcase MAPLE_FILEERR_INVALID_WRITE_LENGTH:\n\t\tdev_notice(&mdev->dev, ERRSTR \" invalid write length\\n\",\n\t\t\tmdev->port, mdev->unit);\n\t\tbreak;\n\n\tcase MAPLE_FILEERR_BAD_CRC:\n\t\tdev_notice(&mdev->dev, ERRSTR \" bad CRC\\n\",\n\t\t\tmdev->port, mdev->unit);\n\t\tbreak;\n\n\tdefault:\n\t\tdev_notice(&mdev->dev, ERRSTR \" 0x%X\\n\",\n\t\t\tmdev->port, mdev->unit, error);\n\t}\n}\n\n\nstatic int probe_maple_vmu(struct device *dev)\n{\n\tstruct maple_device *mdev = to_maple_dev(dev);\n\tstruct maple_driver *mdrv = to_maple_driver(dev->driver);\n\n\tmdev->can_unload = vmu_can_unload;\n\tmdev->fileerr_handler = vmu_file_error;\n\tmdev->driver = mdrv;\n\n\treturn vmu_connect(mdev);\n}\n\nstatic int remove_maple_vmu(struct device *dev)\n{\n\tstruct maple_device *mdev = to_maple_dev(dev);\n\n\tvmu_disconnect(mdev);\n\treturn 0;\n}\n\nstatic struct maple_driver vmu_flash_driver = {\n\t.function =\tMAPLE_FUNC_MEMCARD,\n\t.drv = {\n\t\t.name =\t\t\"Dreamcast_visual_memory\",\n\t\t.probe =\tprobe_maple_vmu,\n\t\t.remove =\tremove_maple_vmu,\n\t},\n};\n\nstatic int __init vmu_flash_map_init(void)\n{\n\treturn maple_driver_register(&vmu_flash_driver);\n}\n\nstatic void __exit vmu_flash_map_exit(void)\n{\n\tmaple_driver_unregister(&vmu_flash_driver);\n}\n\nmodule_init(vmu_flash_map_init);\nmodule_exit(vmu_flash_map_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Adrian McMenamin\");\nMODULE_DESCRIPTION(\"Flash mapping for Sega Dreamcast visual memory\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}