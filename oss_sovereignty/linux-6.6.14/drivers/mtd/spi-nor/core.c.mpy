{
  "module_name": "core.c",
  "hash_id": "ca95b14ce7ec82f95d888aa353c0dda890258c27ebd6698818658ac235812c50",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/spi-nor/core.c",
  "human_readable_source": "\n \n\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/mtd/mtd.h>\n#include <linux/mtd/spi-nor.h>\n#include <linux/mutex.h>\n#include <linux/of_platform.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sizes.h>\n#include <linux/slab.h>\n#include <linux/spi/flash.h>\n\n#include \"core.h\"\n\n \n\n \n#define DEFAULT_READY_WAIT_JIFFIES\t\t(40UL * HZ)\n\n \n#define CHIP_ERASE_2MB_READY_WAIT_JIFFIES\t(40UL * HZ)\n\n#define SPI_NOR_MAX_ADDR_NBYTES\t4\n\n#define SPI_NOR_SRST_SLEEP_MIN 200\n#define SPI_NOR_SRST_SLEEP_MAX 400\n\n \nstatic u8 spi_nor_get_cmd_ext(const struct spi_nor *nor,\n\t\t\t      const struct spi_mem_op *op)\n{\n\tswitch (nor->cmd_ext_type) {\n\tcase SPI_NOR_EXT_INVERT:\n\t\treturn ~op->cmd.opcode;\n\n\tcase SPI_NOR_EXT_REPEAT:\n\t\treturn op->cmd.opcode;\n\n\tdefault:\n\t\tdev_err(nor->dev, \"Unknown command extension type\\n\");\n\t\treturn 0;\n\t}\n}\n\n \nvoid spi_nor_spimem_setup_op(const struct spi_nor *nor,\n\t\t\t     struct spi_mem_op *op,\n\t\t\t     const enum spi_nor_protocol proto)\n{\n\tu8 ext;\n\n\top->cmd.buswidth = spi_nor_get_protocol_inst_nbits(proto);\n\n\tif (op->addr.nbytes)\n\t\top->addr.buswidth = spi_nor_get_protocol_addr_nbits(proto);\n\n\tif (op->dummy.nbytes)\n\t\top->dummy.buswidth = spi_nor_get_protocol_addr_nbits(proto);\n\n\tif (op->data.nbytes)\n\t\top->data.buswidth = spi_nor_get_protocol_data_nbits(proto);\n\n\tif (spi_nor_protocol_is_dtr(proto)) {\n\t\t \n\t\top->cmd.dtr = true;\n\t\top->addr.dtr = true;\n\t\top->dummy.dtr = true;\n\t\top->data.dtr = true;\n\n\t\t \n\t\top->dummy.nbytes *= 2;\n\n\t\text = spi_nor_get_cmd_ext(nor, op);\n\t\top->cmd.opcode = (op->cmd.opcode << 8) | ext;\n\t\top->cmd.nbytes = 2;\n\t}\n}\n\n \nstatic bool spi_nor_spimem_bounce(struct spi_nor *nor, struct spi_mem_op *op)\n{\n\t \n\tif (object_is_on_stack(op->data.buf.in) ||\n\t    !virt_addr_valid(op->data.buf.in)) {\n\t\tif (op->data.nbytes > nor->bouncebuf_size)\n\t\t\top->data.nbytes = nor->bouncebuf_size;\n\t\top->data.buf.in = nor->bouncebuf;\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n \nstatic int spi_nor_spimem_exec_op(struct spi_nor *nor, struct spi_mem_op *op)\n{\n\tint error;\n\n\terror = spi_mem_adjust_op_size(nor->spimem, op);\n\tif (error)\n\t\treturn error;\n\n\treturn spi_mem_exec_op(nor->spimem, op);\n}\n\nint spi_nor_controller_ops_read_reg(struct spi_nor *nor, u8 opcode,\n\t\t\t\t    u8 *buf, size_t len)\n{\n\tif (spi_nor_protocol_is_dtr(nor->reg_proto))\n\t\treturn -EOPNOTSUPP;\n\n\treturn nor->controller_ops->read_reg(nor, opcode, buf, len);\n}\n\nint spi_nor_controller_ops_write_reg(struct spi_nor *nor, u8 opcode,\n\t\t\t\t     const u8 *buf, size_t len)\n{\n\tif (spi_nor_protocol_is_dtr(nor->reg_proto))\n\t\treturn -EOPNOTSUPP;\n\n\treturn nor->controller_ops->write_reg(nor, opcode, buf, len);\n}\n\nstatic int spi_nor_controller_ops_erase(struct spi_nor *nor, loff_t offs)\n{\n\tif (spi_nor_protocol_is_dtr(nor->reg_proto))\n\t\treturn -EOPNOTSUPP;\n\n\treturn nor->controller_ops->erase(nor, offs);\n}\n\n \nstatic ssize_t spi_nor_spimem_read_data(struct spi_nor *nor, loff_t from,\n\t\t\t\t\tsize_t len, u8 *buf)\n{\n\tstruct spi_mem_op op =\n\t\tSPI_MEM_OP(SPI_MEM_OP_CMD(nor->read_opcode, 0),\n\t\t\t   SPI_MEM_OP_ADDR(nor->addr_nbytes, from, 0),\n\t\t\t   SPI_MEM_OP_DUMMY(nor->read_dummy, 0),\n\t\t\t   SPI_MEM_OP_DATA_IN(len, buf, 0));\n\tbool usebouncebuf;\n\tssize_t nbytes;\n\tint error;\n\n\tspi_nor_spimem_setup_op(nor, &op, nor->read_proto);\n\n\t \n\top.dummy.nbytes = (nor->read_dummy * op.dummy.buswidth) / 8;\n\tif (spi_nor_protocol_is_dtr(nor->read_proto))\n\t\top.dummy.nbytes *= 2;\n\n\tusebouncebuf = spi_nor_spimem_bounce(nor, &op);\n\n\tif (nor->dirmap.rdesc) {\n\t\tnbytes = spi_mem_dirmap_read(nor->dirmap.rdesc, op.addr.val,\n\t\t\t\t\t     op.data.nbytes, op.data.buf.in);\n\t} else {\n\t\terror = spi_nor_spimem_exec_op(nor, &op);\n\t\tif (error)\n\t\t\treturn error;\n\t\tnbytes = op.data.nbytes;\n\t}\n\n\tif (usebouncebuf && nbytes > 0)\n\t\tmemcpy(buf, op.data.buf.in, nbytes);\n\n\treturn nbytes;\n}\n\n \nssize_t spi_nor_read_data(struct spi_nor *nor, loff_t from, size_t len, u8 *buf)\n{\n\tif (nor->spimem)\n\t\treturn spi_nor_spimem_read_data(nor, from, len, buf);\n\n\treturn nor->controller_ops->read(nor, from, len, buf);\n}\n\n \nstatic ssize_t spi_nor_spimem_write_data(struct spi_nor *nor, loff_t to,\n\t\t\t\t\t size_t len, const u8 *buf)\n{\n\tstruct spi_mem_op op =\n\t\tSPI_MEM_OP(SPI_MEM_OP_CMD(nor->program_opcode, 0),\n\t\t\t   SPI_MEM_OP_ADDR(nor->addr_nbytes, to, 0),\n\t\t\t   SPI_MEM_OP_NO_DUMMY,\n\t\t\t   SPI_MEM_OP_DATA_OUT(len, buf, 0));\n\tssize_t nbytes;\n\tint error;\n\n\tif (nor->program_opcode == SPINOR_OP_AAI_WP && nor->sst_write_second)\n\t\top.addr.nbytes = 0;\n\n\tspi_nor_spimem_setup_op(nor, &op, nor->write_proto);\n\n\tif (spi_nor_spimem_bounce(nor, &op))\n\t\tmemcpy(nor->bouncebuf, buf, op.data.nbytes);\n\n\tif (nor->dirmap.wdesc) {\n\t\tnbytes = spi_mem_dirmap_write(nor->dirmap.wdesc, op.addr.val,\n\t\t\t\t\t      op.data.nbytes, op.data.buf.out);\n\t} else {\n\t\terror = spi_nor_spimem_exec_op(nor, &op);\n\t\tif (error)\n\t\t\treturn error;\n\t\tnbytes = op.data.nbytes;\n\t}\n\n\treturn nbytes;\n}\n\n \nssize_t spi_nor_write_data(struct spi_nor *nor, loff_t to, size_t len,\n\t\t\t   const u8 *buf)\n{\n\tif (nor->spimem)\n\t\treturn spi_nor_spimem_write_data(nor, to, len, buf);\n\n\treturn nor->controller_ops->write(nor, to, len, buf);\n}\n\n \nint spi_nor_read_any_reg(struct spi_nor *nor, struct spi_mem_op *op,\n\t\t\t enum spi_nor_protocol proto)\n{\n\tif (!nor->spimem)\n\t\treturn -EOPNOTSUPP;\n\n\tspi_nor_spimem_setup_op(nor, op, proto);\n\treturn spi_nor_spimem_exec_op(nor, op);\n}\n\n \nint spi_nor_write_any_volatile_reg(struct spi_nor *nor, struct spi_mem_op *op,\n\t\t\t\t   enum spi_nor_protocol proto)\n{\n\tint ret;\n\n\tif (!nor->spimem)\n\t\treturn -EOPNOTSUPP;\n\n\tret = spi_nor_write_enable(nor);\n\tif (ret)\n\t\treturn ret;\n\tspi_nor_spimem_setup_op(nor, op, proto);\n\treturn spi_nor_spimem_exec_op(nor, op);\n}\n\n \nint spi_nor_write_enable(struct spi_nor *nor)\n{\n\tint ret;\n\n\tif (nor->spimem) {\n\t\tstruct spi_mem_op op = SPI_NOR_WREN_OP;\n\n\t\tspi_nor_spimem_setup_op(nor, &op, nor->reg_proto);\n\n\t\tret = spi_mem_exec_op(nor->spimem, &op);\n\t} else {\n\t\tret = spi_nor_controller_ops_write_reg(nor, SPINOR_OP_WREN,\n\t\t\t\t\t\t       NULL, 0);\n\t}\n\n\tif (ret)\n\t\tdev_dbg(nor->dev, \"error %d on Write Enable\\n\", ret);\n\n\treturn ret;\n}\n\n \nint spi_nor_write_disable(struct spi_nor *nor)\n{\n\tint ret;\n\n\tif (nor->spimem) {\n\t\tstruct spi_mem_op op = SPI_NOR_WRDI_OP;\n\n\t\tspi_nor_spimem_setup_op(nor, &op, nor->reg_proto);\n\n\t\tret = spi_mem_exec_op(nor->spimem, &op);\n\t} else {\n\t\tret = spi_nor_controller_ops_write_reg(nor, SPINOR_OP_WRDI,\n\t\t\t\t\t\t       NULL, 0);\n\t}\n\n\tif (ret)\n\t\tdev_dbg(nor->dev, \"error %d on Write Disable\\n\", ret);\n\n\treturn ret;\n}\n\n \nint spi_nor_read_id(struct spi_nor *nor, u8 naddr, u8 ndummy, u8 *id,\n\t\t    enum spi_nor_protocol proto)\n{\n\tint ret;\n\n\tif (nor->spimem) {\n\t\tstruct spi_mem_op op =\n\t\t\tSPI_NOR_READID_OP(naddr, ndummy, id, SPI_NOR_MAX_ID_LEN);\n\n\t\tspi_nor_spimem_setup_op(nor, &op, proto);\n\t\tret = spi_mem_exec_op(nor->spimem, &op);\n\t} else {\n\t\tret = nor->controller_ops->read_reg(nor, SPINOR_OP_RDID, id,\n\t\t\t\t\t\t    SPI_NOR_MAX_ID_LEN);\n\t}\n\treturn ret;\n}\n\n \nint spi_nor_read_sr(struct spi_nor *nor, u8 *sr)\n{\n\tint ret;\n\n\tif (nor->spimem) {\n\t\tstruct spi_mem_op op = SPI_NOR_RDSR_OP(sr);\n\n\t\tif (nor->reg_proto == SNOR_PROTO_8_8_8_DTR) {\n\t\t\top.addr.nbytes = nor->params->rdsr_addr_nbytes;\n\t\t\top.dummy.nbytes = nor->params->rdsr_dummy;\n\t\t\t \n\t\t\top.data.nbytes = 2;\n\t\t}\n\n\t\tspi_nor_spimem_setup_op(nor, &op, nor->reg_proto);\n\n\t\tret = spi_mem_exec_op(nor->spimem, &op);\n\t} else {\n\t\tret = spi_nor_controller_ops_read_reg(nor, SPINOR_OP_RDSR, sr,\n\t\t\t\t\t\t      1);\n\t}\n\n\tif (ret)\n\t\tdev_dbg(nor->dev, \"error %d reading SR\\n\", ret);\n\n\treturn ret;\n}\n\n \nint spi_nor_read_cr(struct spi_nor *nor, u8 *cr)\n{\n\tint ret;\n\n\tif (nor->spimem) {\n\t\tstruct spi_mem_op op = SPI_NOR_RDCR_OP(cr);\n\n\t\tspi_nor_spimem_setup_op(nor, &op, nor->reg_proto);\n\n\t\tret = spi_mem_exec_op(nor->spimem, &op);\n\t} else {\n\t\tret = spi_nor_controller_ops_read_reg(nor, SPINOR_OP_RDCR, cr,\n\t\t\t\t\t\t      1);\n\t}\n\n\tif (ret)\n\t\tdev_dbg(nor->dev, \"error %d reading CR\\n\", ret);\n\n\treturn ret;\n}\n\n \nint spi_nor_set_4byte_addr_mode_en4b_ex4b(struct spi_nor *nor, bool enable)\n{\n\tint ret;\n\n\tif (nor->spimem) {\n\t\tstruct spi_mem_op op = SPI_NOR_EN4B_EX4B_OP(enable);\n\n\t\tspi_nor_spimem_setup_op(nor, &op, nor->reg_proto);\n\n\t\tret = spi_mem_exec_op(nor->spimem, &op);\n\t} else {\n\t\tret = spi_nor_controller_ops_write_reg(nor,\n\t\t\t\t\t\t       enable ? SPINOR_OP_EN4B :\n\t\t\t\t\t\t\t\tSPINOR_OP_EX4B,\n\t\t\t\t\t\t       NULL, 0);\n\t}\n\n\tif (ret)\n\t\tdev_dbg(nor->dev, \"error %d setting 4-byte mode\\n\", ret);\n\n\treturn ret;\n}\n\n \nint spi_nor_set_4byte_addr_mode_wren_en4b_ex4b(struct spi_nor *nor, bool enable)\n{\n\tint ret;\n\n\tret = spi_nor_write_enable(nor);\n\tif (ret)\n\t\treturn ret;\n\n\tret = spi_nor_set_4byte_addr_mode_en4b_ex4b(nor, enable);\n\tif (ret)\n\t\treturn ret;\n\n\treturn spi_nor_write_disable(nor);\n}\n\n \nint spi_nor_set_4byte_addr_mode_brwr(struct spi_nor *nor, bool enable)\n{\n\tint ret;\n\n\tnor->bouncebuf[0] = enable << 7;\n\n\tif (nor->spimem) {\n\t\tstruct spi_mem_op op = SPI_NOR_BRWR_OP(nor->bouncebuf);\n\n\t\tspi_nor_spimem_setup_op(nor, &op, nor->reg_proto);\n\n\t\tret = spi_mem_exec_op(nor->spimem, &op);\n\t} else {\n\t\tret = spi_nor_controller_ops_write_reg(nor, SPINOR_OP_BRWR,\n\t\t\t\t\t\t       nor->bouncebuf, 1);\n\t}\n\n\tif (ret)\n\t\tdev_dbg(nor->dev, \"error %d setting 4-byte mode\\n\", ret);\n\n\treturn ret;\n}\n\n \nint spi_nor_sr_ready(struct spi_nor *nor)\n{\n\tint ret;\n\n\tret = spi_nor_read_sr(nor, nor->bouncebuf);\n\tif (ret)\n\t\treturn ret;\n\n\treturn !(nor->bouncebuf[0] & SR_WIP);\n}\n\n \nstatic bool spi_nor_use_parallel_locking(struct spi_nor *nor)\n{\n\treturn nor->flags & SNOR_F_RWW;\n}\n\n \nstatic int spi_nor_rww_start_rdst(struct spi_nor *nor)\n{\n\tstruct spi_nor_rww *rww = &nor->rww;\n\tint ret = -EAGAIN;\n\n\tmutex_lock(&nor->lock);\n\n\tif (rww->ongoing_io || rww->ongoing_rd)\n\t\tgoto busy;\n\n\trww->ongoing_io = true;\n\trww->ongoing_rd = true;\n\tret = 0;\n\nbusy:\n\tmutex_unlock(&nor->lock);\n\treturn ret;\n}\n\nstatic void spi_nor_rww_end_rdst(struct spi_nor *nor)\n{\n\tstruct spi_nor_rww *rww = &nor->rww;\n\n\tmutex_lock(&nor->lock);\n\n\trww->ongoing_io = false;\n\trww->ongoing_rd = false;\n\n\tmutex_unlock(&nor->lock);\n}\n\nstatic int spi_nor_lock_rdst(struct spi_nor *nor)\n{\n\tif (spi_nor_use_parallel_locking(nor))\n\t\treturn spi_nor_rww_start_rdst(nor);\n\n\treturn 0;\n}\n\nstatic void spi_nor_unlock_rdst(struct spi_nor *nor)\n{\n\tif (spi_nor_use_parallel_locking(nor)) {\n\t\tspi_nor_rww_end_rdst(nor);\n\t\twake_up(&nor->rww.wait);\n\t}\n}\n\n \nstatic int spi_nor_ready(struct spi_nor *nor)\n{\n\tint ret;\n\n\tret = spi_nor_lock_rdst(nor);\n\tif (ret)\n\t\treturn 0;\n\n\t \n\tif (nor->params->ready)\n\t\tret = nor->params->ready(nor);\n\telse\n\t\tret = spi_nor_sr_ready(nor);\n\n\tspi_nor_unlock_rdst(nor);\n\n\treturn ret;\n}\n\n \nstatic int spi_nor_wait_till_ready_with_timeout(struct spi_nor *nor,\n\t\t\t\t\t\tunsigned long timeout_jiffies)\n{\n\tunsigned long deadline;\n\tint timeout = 0, ret;\n\n\tdeadline = jiffies + timeout_jiffies;\n\n\twhile (!timeout) {\n\t\tif (time_after_eq(jiffies, deadline))\n\t\t\ttimeout = 1;\n\n\t\tret = spi_nor_ready(nor);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tif (ret)\n\t\t\treturn 0;\n\n\t\tcond_resched();\n\t}\n\n\tdev_dbg(nor->dev, \"flash operation timed out\\n\");\n\n\treturn -ETIMEDOUT;\n}\n\n \nint spi_nor_wait_till_ready(struct spi_nor *nor)\n{\n\treturn spi_nor_wait_till_ready_with_timeout(nor,\n\t\t\t\t\t\t    DEFAULT_READY_WAIT_JIFFIES);\n}\n\n \nint spi_nor_global_block_unlock(struct spi_nor *nor)\n{\n\tint ret;\n\n\tret = spi_nor_write_enable(nor);\n\tif (ret)\n\t\treturn ret;\n\n\tif (nor->spimem) {\n\t\tstruct spi_mem_op op = SPI_NOR_GBULK_OP;\n\n\t\tspi_nor_spimem_setup_op(nor, &op, nor->reg_proto);\n\n\t\tret = spi_mem_exec_op(nor->spimem, &op);\n\t} else {\n\t\tret = spi_nor_controller_ops_write_reg(nor, SPINOR_OP_GBULK,\n\t\t\t\t\t\t       NULL, 0);\n\t}\n\n\tif (ret) {\n\t\tdev_dbg(nor->dev, \"error %d on Global Block Unlock\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn spi_nor_wait_till_ready(nor);\n}\n\n \nint spi_nor_write_sr(struct spi_nor *nor, const u8 *sr, size_t len)\n{\n\tint ret;\n\n\tret = spi_nor_write_enable(nor);\n\tif (ret)\n\t\treturn ret;\n\n\tif (nor->spimem) {\n\t\tstruct spi_mem_op op = SPI_NOR_WRSR_OP(sr, len);\n\n\t\tspi_nor_spimem_setup_op(nor, &op, nor->reg_proto);\n\n\t\tret = spi_mem_exec_op(nor->spimem, &op);\n\t} else {\n\t\tret = spi_nor_controller_ops_write_reg(nor, SPINOR_OP_WRSR, sr,\n\t\t\t\t\t\t       len);\n\t}\n\n\tif (ret) {\n\t\tdev_dbg(nor->dev, \"error %d writing SR\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn spi_nor_wait_till_ready(nor);\n}\n\n \nstatic int spi_nor_write_sr1_and_check(struct spi_nor *nor, u8 sr1)\n{\n\tint ret;\n\n\tnor->bouncebuf[0] = sr1;\n\n\tret = spi_nor_write_sr(nor, nor->bouncebuf, 1);\n\tif (ret)\n\t\treturn ret;\n\n\tret = spi_nor_read_sr(nor, nor->bouncebuf);\n\tif (ret)\n\t\treturn ret;\n\n\tif (nor->bouncebuf[0] != sr1) {\n\t\tdev_dbg(nor->dev, \"SR1: read back test failed\\n\");\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int spi_nor_write_16bit_sr_and_check(struct spi_nor *nor, u8 sr1)\n{\n\tint ret;\n\tu8 *sr_cr = nor->bouncebuf;\n\tu8 cr_written;\n\n\t \n\tif (!(nor->flags & SNOR_F_NO_READ_CR)) {\n\t\tret = spi_nor_read_cr(nor, &sr_cr[1]);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else if (spi_nor_get_protocol_width(nor->read_proto) == 4 &&\n\t\t   spi_nor_get_protocol_width(nor->write_proto) == 4 &&\n\t\t   nor->params->quad_enable) {\n\t\t \n\t\tsr_cr[1] = SR2_QUAD_EN_BIT1;\n\t} else {\n\t\tsr_cr[1] = 0;\n\t}\n\n\tsr_cr[0] = sr1;\n\n\tret = spi_nor_write_sr(nor, sr_cr, 2);\n\tif (ret)\n\t\treturn ret;\n\n\tret = spi_nor_read_sr(nor, sr_cr);\n\tif (ret)\n\t\treturn ret;\n\n\tif (sr1 != sr_cr[0]) {\n\t\tdev_dbg(nor->dev, \"SR: Read back test failed\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (nor->flags & SNOR_F_NO_READ_CR)\n\t\treturn 0;\n\n\tcr_written = sr_cr[1];\n\n\tret = spi_nor_read_cr(nor, &sr_cr[1]);\n\tif (ret)\n\t\treturn ret;\n\n\tif (cr_written != sr_cr[1]) {\n\t\tdev_dbg(nor->dev, \"CR: read back test failed\\n\");\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\n \nint spi_nor_write_16bit_cr_and_check(struct spi_nor *nor, u8 cr)\n{\n\tint ret;\n\tu8 *sr_cr = nor->bouncebuf;\n\tu8 sr_written;\n\n\t \n\tret = spi_nor_read_sr(nor, sr_cr);\n\tif (ret)\n\t\treturn ret;\n\n\tsr_cr[1] = cr;\n\n\tret = spi_nor_write_sr(nor, sr_cr, 2);\n\tif (ret)\n\t\treturn ret;\n\n\tsr_written = sr_cr[0];\n\n\tret = spi_nor_read_sr(nor, sr_cr);\n\tif (ret)\n\t\treturn ret;\n\n\tif (sr_written != sr_cr[0]) {\n\t\tdev_dbg(nor->dev, \"SR: Read back test failed\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (nor->flags & SNOR_F_NO_READ_CR)\n\t\treturn 0;\n\n\tret = spi_nor_read_cr(nor, &sr_cr[1]);\n\tif (ret)\n\t\treturn ret;\n\n\tif (cr != sr_cr[1]) {\n\t\tdev_dbg(nor->dev, \"CR: read back test failed\\n\");\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\n \nint spi_nor_write_sr_and_check(struct spi_nor *nor, u8 sr1)\n{\n\tif (nor->flags & SNOR_F_HAS_16BIT_SR)\n\t\treturn spi_nor_write_16bit_sr_and_check(nor, sr1);\n\n\treturn spi_nor_write_sr1_and_check(nor, sr1);\n}\n\n \nstatic int spi_nor_write_sr2(struct spi_nor *nor, const u8 *sr2)\n{\n\tint ret;\n\n\tret = spi_nor_write_enable(nor);\n\tif (ret)\n\t\treturn ret;\n\n\tif (nor->spimem) {\n\t\tstruct spi_mem_op op = SPI_NOR_WRSR2_OP(sr2);\n\n\t\tspi_nor_spimem_setup_op(nor, &op, nor->reg_proto);\n\n\t\tret = spi_mem_exec_op(nor->spimem, &op);\n\t} else {\n\t\tret = spi_nor_controller_ops_write_reg(nor, SPINOR_OP_WRSR2,\n\t\t\t\t\t\t       sr2, 1);\n\t}\n\n\tif (ret) {\n\t\tdev_dbg(nor->dev, \"error %d writing SR2\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn spi_nor_wait_till_ready(nor);\n}\n\n \nstatic int spi_nor_read_sr2(struct spi_nor *nor, u8 *sr2)\n{\n\tint ret;\n\n\tif (nor->spimem) {\n\t\tstruct spi_mem_op op = SPI_NOR_RDSR2_OP(sr2);\n\n\t\tspi_nor_spimem_setup_op(nor, &op, nor->reg_proto);\n\n\t\tret = spi_mem_exec_op(nor->spimem, &op);\n\t} else {\n\t\tret = spi_nor_controller_ops_read_reg(nor, SPINOR_OP_RDSR2, sr2,\n\t\t\t\t\t\t      1);\n\t}\n\n\tif (ret)\n\t\tdev_dbg(nor->dev, \"error %d reading SR2\\n\", ret);\n\n\treturn ret;\n}\n\n \nstatic int spi_nor_erase_chip(struct spi_nor *nor)\n{\n\tint ret;\n\n\tdev_dbg(nor->dev, \" %lldKiB\\n\", (long long)(nor->mtd.size >> 10));\n\n\tif (nor->spimem) {\n\t\tstruct spi_mem_op op = SPI_NOR_CHIP_ERASE_OP;\n\n\t\tspi_nor_spimem_setup_op(nor, &op, nor->reg_proto);\n\n\t\tret = spi_mem_exec_op(nor->spimem, &op);\n\t} else {\n\t\tret = spi_nor_controller_ops_write_reg(nor,\n\t\t\t\t\t\t       SPINOR_OP_CHIP_ERASE,\n\t\t\t\t\t\t       NULL, 0);\n\t}\n\n\tif (ret)\n\t\tdev_dbg(nor->dev, \"error %d erasing chip\\n\", ret);\n\n\treturn ret;\n}\n\nstatic u8 spi_nor_convert_opcode(u8 opcode, const u8 table[][2], size_t size)\n{\n\tsize_t i;\n\n\tfor (i = 0; i < size; i++)\n\t\tif (table[i][0] == opcode)\n\t\t\treturn table[i][1];\n\n\t \n\treturn opcode;\n}\n\nu8 spi_nor_convert_3to4_read(u8 opcode)\n{\n\tstatic const u8 spi_nor_3to4_read[][2] = {\n\t\t{ SPINOR_OP_READ,\tSPINOR_OP_READ_4B },\n\t\t{ SPINOR_OP_READ_FAST,\tSPINOR_OP_READ_FAST_4B },\n\t\t{ SPINOR_OP_READ_1_1_2,\tSPINOR_OP_READ_1_1_2_4B },\n\t\t{ SPINOR_OP_READ_1_2_2,\tSPINOR_OP_READ_1_2_2_4B },\n\t\t{ SPINOR_OP_READ_1_1_4,\tSPINOR_OP_READ_1_1_4_4B },\n\t\t{ SPINOR_OP_READ_1_4_4,\tSPINOR_OP_READ_1_4_4_4B },\n\t\t{ SPINOR_OP_READ_1_1_8,\tSPINOR_OP_READ_1_1_8_4B },\n\t\t{ SPINOR_OP_READ_1_8_8,\tSPINOR_OP_READ_1_8_8_4B },\n\n\t\t{ SPINOR_OP_READ_1_1_1_DTR,\tSPINOR_OP_READ_1_1_1_DTR_4B },\n\t\t{ SPINOR_OP_READ_1_2_2_DTR,\tSPINOR_OP_READ_1_2_2_DTR_4B },\n\t\t{ SPINOR_OP_READ_1_4_4_DTR,\tSPINOR_OP_READ_1_4_4_DTR_4B },\n\t};\n\n\treturn spi_nor_convert_opcode(opcode, spi_nor_3to4_read,\n\t\t\t\t      ARRAY_SIZE(spi_nor_3to4_read));\n}\n\nstatic u8 spi_nor_convert_3to4_program(u8 opcode)\n{\n\tstatic const u8 spi_nor_3to4_program[][2] = {\n\t\t{ SPINOR_OP_PP,\t\tSPINOR_OP_PP_4B },\n\t\t{ SPINOR_OP_PP_1_1_4,\tSPINOR_OP_PP_1_1_4_4B },\n\t\t{ SPINOR_OP_PP_1_4_4,\tSPINOR_OP_PP_1_4_4_4B },\n\t\t{ SPINOR_OP_PP_1_1_8,\tSPINOR_OP_PP_1_1_8_4B },\n\t\t{ SPINOR_OP_PP_1_8_8,\tSPINOR_OP_PP_1_8_8_4B },\n\t};\n\n\treturn spi_nor_convert_opcode(opcode, spi_nor_3to4_program,\n\t\t\t\t      ARRAY_SIZE(spi_nor_3to4_program));\n}\n\nstatic u8 spi_nor_convert_3to4_erase(u8 opcode)\n{\n\tstatic const u8 spi_nor_3to4_erase[][2] = {\n\t\t{ SPINOR_OP_BE_4K,\tSPINOR_OP_BE_4K_4B },\n\t\t{ SPINOR_OP_BE_32K,\tSPINOR_OP_BE_32K_4B },\n\t\t{ SPINOR_OP_SE,\t\tSPINOR_OP_SE_4B },\n\t};\n\n\treturn spi_nor_convert_opcode(opcode, spi_nor_3to4_erase,\n\t\t\t\t      ARRAY_SIZE(spi_nor_3to4_erase));\n}\n\nstatic bool spi_nor_has_uniform_erase(const struct spi_nor *nor)\n{\n\treturn !!nor->params->erase_map.uniform_erase_type;\n}\n\nstatic void spi_nor_set_4byte_opcodes(struct spi_nor *nor)\n{\n\tnor->read_opcode = spi_nor_convert_3to4_read(nor->read_opcode);\n\tnor->program_opcode = spi_nor_convert_3to4_program(nor->program_opcode);\n\tnor->erase_opcode = spi_nor_convert_3to4_erase(nor->erase_opcode);\n\n\tif (!spi_nor_has_uniform_erase(nor)) {\n\t\tstruct spi_nor_erase_map *map = &nor->params->erase_map;\n\t\tstruct spi_nor_erase_type *erase;\n\t\tint i;\n\n\t\tfor (i = 0; i < SNOR_ERASE_TYPE_MAX; i++) {\n\t\t\terase = &map->erase_type[i];\n\t\t\terase->opcode =\n\t\t\t\tspi_nor_convert_3to4_erase(erase->opcode);\n\t\t}\n\t}\n}\n\nstatic int spi_nor_prep(struct spi_nor *nor)\n{\n\tint ret = 0;\n\n\tif (nor->controller_ops && nor->controller_ops->prepare)\n\t\tret = nor->controller_ops->prepare(nor);\n\n\treturn ret;\n}\n\nstatic void spi_nor_unprep(struct spi_nor *nor)\n{\n\tif (nor->controller_ops && nor->controller_ops->unprepare)\n\t\tnor->controller_ops->unprepare(nor);\n}\n\nstatic void spi_nor_offset_to_banks(u64 bank_size, loff_t start, size_t len,\n\t\t\t\t    u8 *first, u8 *last)\n{\n\t \n\t*first = DIV_ROUND_DOWN_ULL(start, bank_size);\n\t*last = DIV_ROUND_DOWN_ULL(start + len - 1, bank_size);\n}\n\n \nstatic bool spi_nor_rww_start_io(struct spi_nor *nor)\n{\n\tstruct spi_nor_rww *rww = &nor->rww;\n\tbool start = false;\n\n\tmutex_lock(&nor->lock);\n\n\tif (rww->ongoing_io)\n\t\tgoto busy;\n\n\trww->ongoing_io = true;\n\tstart = true;\n\nbusy:\n\tmutex_unlock(&nor->lock);\n\treturn start;\n}\n\nstatic void spi_nor_rww_end_io(struct spi_nor *nor)\n{\n\tmutex_lock(&nor->lock);\n\tnor->rww.ongoing_io = false;\n\tmutex_unlock(&nor->lock);\n}\n\nstatic int spi_nor_lock_device(struct spi_nor *nor)\n{\n\tif (!spi_nor_use_parallel_locking(nor))\n\t\treturn 0;\n\n\treturn wait_event_killable(nor->rww.wait, spi_nor_rww_start_io(nor));\n}\n\nstatic void spi_nor_unlock_device(struct spi_nor *nor)\n{\n\tif (spi_nor_use_parallel_locking(nor)) {\n\t\tspi_nor_rww_end_io(nor);\n\t\twake_up(&nor->rww.wait);\n\t}\n}\n\n \nstatic bool spi_nor_rww_start_exclusive(struct spi_nor *nor)\n{\n\tstruct spi_nor_rww *rww = &nor->rww;\n\tbool start = false;\n\n\tmutex_lock(&nor->lock);\n\n\tif (rww->ongoing_io || rww->ongoing_rd || rww->ongoing_pe)\n\t\tgoto busy;\n\n\trww->ongoing_io = true;\n\trww->ongoing_rd = true;\n\trww->ongoing_pe = true;\n\tstart = true;\n\nbusy:\n\tmutex_unlock(&nor->lock);\n\treturn start;\n}\n\nstatic void spi_nor_rww_end_exclusive(struct spi_nor *nor)\n{\n\tstruct spi_nor_rww *rww = &nor->rww;\n\n\tmutex_lock(&nor->lock);\n\trww->ongoing_io = false;\n\trww->ongoing_rd = false;\n\trww->ongoing_pe = false;\n\tmutex_unlock(&nor->lock);\n}\n\nint spi_nor_prep_and_lock(struct spi_nor *nor)\n{\n\tint ret;\n\n\tret = spi_nor_prep(nor);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!spi_nor_use_parallel_locking(nor))\n\t\tmutex_lock(&nor->lock);\n\telse\n\t\tret = wait_event_killable(nor->rww.wait,\n\t\t\t\t\t  spi_nor_rww_start_exclusive(nor));\n\n\treturn ret;\n}\n\nvoid spi_nor_unlock_and_unprep(struct spi_nor *nor)\n{\n\tif (!spi_nor_use_parallel_locking(nor)) {\n\t\tmutex_unlock(&nor->lock);\n\t} else {\n\t\tspi_nor_rww_end_exclusive(nor);\n\t\twake_up(&nor->rww.wait);\n\t}\n\n\tspi_nor_unprep(nor);\n}\n\n \nstatic bool spi_nor_rww_start_pe(struct spi_nor *nor, loff_t start, size_t len)\n{\n\tstruct spi_nor_rww *rww = &nor->rww;\n\tunsigned int used_banks = 0;\n\tbool started = false;\n\tu8 first, last;\n\tint bank;\n\n\tmutex_lock(&nor->lock);\n\n\tif (rww->ongoing_io || rww->ongoing_rd || rww->ongoing_pe)\n\t\tgoto busy;\n\n\tspi_nor_offset_to_banks(nor->params->bank_size, start, len, &first, &last);\n\tfor (bank = first; bank <= last; bank++) {\n\t\tif (rww->used_banks & BIT(bank))\n\t\t\tgoto busy;\n\n\t\tused_banks |= BIT(bank);\n\t}\n\n\trww->used_banks |= used_banks;\n\trww->ongoing_pe = true;\n\tstarted = true;\n\nbusy:\n\tmutex_unlock(&nor->lock);\n\treturn started;\n}\n\nstatic void spi_nor_rww_end_pe(struct spi_nor *nor, loff_t start, size_t len)\n{\n\tstruct spi_nor_rww *rww = &nor->rww;\n\tu8 first, last;\n\tint bank;\n\n\tmutex_lock(&nor->lock);\n\n\tspi_nor_offset_to_banks(nor->params->bank_size, start, len, &first, &last);\n\tfor (bank = first; bank <= last; bank++)\n\t\trww->used_banks &= ~BIT(bank);\n\n\trww->ongoing_pe = false;\n\n\tmutex_unlock(&nor->lock);\n}\n\nstatic int spi_nor_prep_and_lock_pe(struct spi_nor *nor, loff_t start, size_t len)\n{\n\tint ret;\n\n\tret = spi_nor_prep(nor);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!spi_nor_use_parallel_locking(nor))\n\t\tmutex_lock(&nor->lock);\n\telse\n\t\tret = wait_event_killable(nor->rww.wait,\n\t\t\t\t\t  spi_nor_rww_start_pe(nor, start, len));\n\n\treturn ret;\n}\n\nstatic void spi_nor_unlock_and_unprep_pe(struct spi_nor *nor, loff_t start, size_t len)\n{\n\tif (!spi_nor_use_parallel_locking(nor)) {\n\t\tmutex_unlock(&nor->lock);\n\t} else {\n\t\tspi_nor_rww_end_pe(nor, start, len);\n\t\twake_up(&nor->rww.wait);\n\t}\n\n\tspi_nor_unprep(nor);\n}\n\n \nstatic bool spi_nor_rww_start_rd(struct spi_nor *nor, loff_t start, size_t len)\n{\n\tstruct spi_nor_rww *rww = &nor->rww;\n\tunsigned int used_banks = 0;\n\tbool started = false;\n\tu8 first, last;\n\tint bank;\n\n\tmutex_lock(&nor->lock);\n\n\tif (rww->ongoing_io || rww->ongoing_rd)\n\t\tgoto busy;\n\n\tspi_nor_offset_to_banks(nor->params->bank_size, start, len, &first, &last);\n\tfor (bank = first; bank <= last; bank++) {\n\t\tif (rww->used_banks & BIT(bank))\n\t\t\tgoto busy;\n\n\t\tused_banks |= BIT(bank);\n\t}\n\n\trww->used_banks |= used_banks;\n\trww->ongoing_io = true;\n\trww->ongoing_rd = true;\n\tstarted = true;\n\nbusy:\n\tmutex_unlock(&nor->lock);\n\treturn started;\n}\n\nstatic void spi_nor_rww_end_rd(struct spi_nor *nor, loff_t start, size_t len)\n{\n\tstruct spi_nor_rww *rww = &nor->rww;\n\tu8 first, last;\n\tint bank;\n\n\tmutex_lock(&nor->lock);\n\n\tspi_nor_offset_to_banks(nor->params->bank_size, start, len, &first, &last);\n\tfor (bank = first; bank <= last; bank++)\n\t\tnor->rww.used_banks &= ~BIT(bank);\n\n\trww->ongoing_io = false;\n\trww->ongoing_rd = false;\n\n\tmutex_unlock(&nor->lock);\n}\n\nstatic int spi_nor_prep_and_lock_rd(struct spi_nor *nor, loff_t start, size_t len)\n{\n\tint ret;\n\n\tret = spi_nor_prep(nor);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!spi_nor_use_parallel_locking(nor))\n\t\tmutex_lock(&nor->lock);\n\telse\n\t\tret = wait_event_killable(nor->rww.wait,\n\t\t\t\t\t  spi_nor_rww_start_rd(nor, start, len));\n\n\treturn ret;\n}\n\nstatic void spi_nor_unlock_and_unprep_rd(struct spi_nor *nor, loff_t start, size_t len)\n{\n\tif (!spi_nor_use_parallel_locking(nor)) {\n\t\tmutex_unlock(&nor->lock);\n\t} else {\n\t\tspi_nor_rww_end_rd(nor, start, len);\n\t\twake_up(&nor->rww.wait);\n\t}\n\n\tspi_nor_unprep(nor);\n}\n\nstatic u32 spi_nor_convert_addr(struct spi_nor *nor, loff_t addr)\n{\n\tif (!nor->params->convert_addr)\n\t\treturn addr;\n\n\treturn nor->params->convert_addr(nor, addr);\n}\n\n \nint spi_nor_erase_sector(struct spi_nor *nor, u32 addr)\n{\n\tint i;\n\n\taddr = spi_nor_convert_addr(nor, addr);\n\n\tif (nor->spimem) {\n\t\tstruct spi_mem_op op =\n\t\t\tSPI_NOR_SECTOR_ERASE_OP(nor->erase_opcode,\n\t\t\t\t\t\tnor->addr_nbytes, addr);\n\n\t\tspi_nor_spimem_setup_op(nor, &op, nor->reg_proto);\n\n\t\treturn spi_mem_exec_op(nor->spimem, &op);\n\t} else if (nor->controller_ops->erase) {\n\t\treturn spi_nor_controller_ops_erase(nor, addr);\n\t}\n\n\t \n\tfor (i = nor->addr_nbytes - 1; i >= 0; i--) {\n\t\tnor->bouncebuf[i] = addr & 0xff;\n\t\taddr >>= 8;\n\t}\n\n\treturn spi_nor_controller_ops_write_reg(nor, nor->erase_opcode,\n\t\t\t\t\t\tnor->bouncebuf, nor->addr_nbytes);\n}\n\n \nstatic u64 spi_nor_div_by_erase_size(const struct spi_nor_erase_type *erase,\n\t\t\t\t     u64 dividend, u32 *remainder)\n{\n\t \n\t*remainder = (u32)dividend & erase->size_mask;\n\treturn dividend >> erase->size_shift;\n}\n\n \nstatic const struct spi_nor_erase_type *\nspi_nor_find_best_erase_type(const struct spi_nor_erase_map *map,\n\t\t\t     const struct spi_nor_erase_region *region,\n\t\t\t     u64 addr, u32 len)\n{\n\tconst struct spi_nor_erase_type *erase;\n\tu32 rem;\n\tint i;\n\tu8 erase_mask = region->offset & SNOR_ERASE_TYPE_MASK;\n\n\t \n\tfor (i = SNOR_ERASE_TYPE_MAX - 1; i >= 0; i--) {\n\t\t \n\t\tif (!(erase_mask & BIT(i)))\n\t\t\tcontinue;\n\n\t\terase = &map->erase_type[i];\n\t\tif (!erase->size)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (region->offset & SNOR_OVERLAID_REGION &&\n\t\t    region->size <= len)\n\t\t\treturn erase;\n\n\t\t \n\t\tif (erase->size > len)\n\t\t\tcontinue;\n\n\t\tspi_nor_div_by_erase_size(erase, addr, &rem);\n\t\tif (!rem)\n\t\t\treturn erase;\n\t}\n\n\treturn NULL;\n}\n\nstatic u64 spi_nor_region_is_last(const struct spi_nor_erase_region *region)\n{\n\treturn region->offset & SNOR_LAST_REGION;\n}\n\nstatic u64 spi_nor_region_end(const struct spi_nor_erase_region *region)\n{\n\treturn (region->offset & ~SNOR_ERASE_FLAGS_MASK) + region->size;\n}\n\n \nstruct spi_nor_erase_region *\nspi_nor_region_next(struct spi_nor_erase_region *region)\n{\n\tif (spi_nor_region_is_last(region))\n\t\treturn NULL;\n\tregion++;\n\treturn region;\n}\n\n \nstatic struct spi_nor_erase_region *\nspi_nor_find_erase_region(const struct spi_nor_erase_map *map, u64 addr)\n{\n\tstruct spi_nor_erase_region *region = map->regions;\n\tu64 region_start = region->offset & ~SNOR_ERASE_FLAGS_MASK;\n\tu64 region_end = region_start + region->size;\n\n\twhile (addr < region_start || addr >= region_end) {\n\t\tregion = spi_nor_region_next(region);\n\t\tif (!region)\n\t\t\treturn ERR_PTR(-EINVAL);\n\n\t\tregion_start = region->offset & ~SNOR_ERASE_FLAGS_MASK;\n\t\tregion_end = region_start + region->size;\n\t}\n\n\treturn region;\n}\n\n \nstatic struct spi_nor_erase_command *\nspi_nor_init_erase_cmd(const struct spi_nor_erase_region *region,\n\t\t       const struct spi_nor_erase_type *erase)\n{\n\tstruct spi_nor_erase_command *cmd;\n\n\tcmd = kmalloc(sizeof(*cmd), GFP_KERNEL);\n\tif (!cmd)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tINIT_LIST_HEAD(&cmd->list);\n\tcmd->opcode = erase->opcode;\n\tcmd->count = 1;\n\n\tif (region->offset & SNOR_OVERLAID_REGION)\n\t\tcmd->size = region->size;\n\telse\n\t\tcmd->size = erase->size;\n\n\treturn cmd;\n}\n\n \nstatic void spi_nor_destroy_erase_cmd_list(struct list_head *erase_list)\n{\n\tstruct spi_nor_erase_command *cmd, *next;\n\n\tlist_for_each_entry_safe(cmd, next, erase_list, list) {\n\t\tlist_del(&cmd->list);\n\t\tkfree(cmd);\n\t}\n}\n\n \nstatic int spi_nor_init_erase_cmd_list(struct spi_nor *nor,\n\t\t\t\t       struct list_head *erase_list,\n\t\t\t\t       u64 addr, u32 len)\n{\n\tconst struct spi_nor_erase_map *map = &nor->params->erase_map;\n\tconst struct spi_nor_erase_type *erase, *prev_erase = NULL;\n\tstruct spi_nor_erase_region *region;\n\tstruct spi_nor_erase_command *cmd = NULL;\n\tu64 region_end;\n\tint ret = -EINVAL;\n\n\tregion = spi_nor_find_erase_region(map, addr);\n\tif (IS_ERR(region))\n\t\treturn PTR_ERR(region);\n\n\tregion_end = spi_nor_region_end(region);\n\n\twhile (len) {\n\t\terase = spi_nor_find_best_erase_type(map, region, addr, len);\n\t\tif (!erase)\n\t\t\tgoto destroy_erase_cmd_list;\n\n\t\tif (prev_erase != erase ||\n\t\t    erase->size != cmd->size ||\n\t\t    region->offset & SNOR_OVERLAID_REGION) {\n\t\t\tcmd = spi_nor_init_erase_cmd(region, erase);\n\t\t\tif (IS_ERR(cmd)) {\n\t\t\t\tret = PTR_ERR(cmd);\n\t\t\t\tgoto destroy_erase_cmd_list;\n\t\t\t}\n\n\t\t\tlist_add_tail(&cmd->list, erase_list);\n\t\t} else {\n\t\t\tcmd->count++;\n\t\t}\n\n\t\taddr += cmd->size;\n\t\tlen -= cmd->size;\n\n\t\tif (len && addr >= region_end) {\n\t\t\tregion = spi_nor_region_next(region);\n\t\t\tif (!region)\n\t\t\t\tgoto destroy_erase_cmd_list;\n\t\t\tregion_end = spi_nor_region_end(region);\n\t\t}\n\n\t\tprev_erase = erase;\n\t}\n\n\treturn 0;\n\ndestroy_erase_cmd_list:\n\tspi_nor_destroy_erase_cmd_list(erase_list);\n\treturn ret;\n}\n\n \nstatic int spi_nor_erase_multi_sectors(struct spi_nor *nor, u64 addr, u32 len)\n{\n\tLIST_HEAD(erase_list);\n\tstruct spi_nor_erase_command *cmd, *next;\n\tint ret;\n\n\tret = spi_nor_init_erase_cmd_list(nor, &erase_list, addr, len);\n\tif (ret)\n\t\treturn ret;\n\n\tlist_for_each_entry_safe(cmd, next, &erase_list, list) {\n\t\tnor->erase_opcode = cmd->opcode;\n\t\twhile (cmd->count) {\n\t\t\tdev_vdbg(nor->dev, \"erase_cmd->size = 0x%08x, erase_cmd->opcode = 0x%02x, erase_cmd->count = %u\\n\",\n\t\t\t\t cmd->size, cmd->opcode, cmd->count);\n\n\t\t\tret = spi_nor_lock_device(nor);\n\t\t\tif (ret)\n\t\t\t\tgoto destroy_erase_cmd_list;\n\n\t\t\tret = spi_nor_write_enable(nor);\n\t\t\tif (ret) {\n\t\t\t\tspi_nor_unlock_device(nor);\n\t\t\t\tgoto destroy_erase_cmd_list;\n\t\t\t}\n\n\t\t\tret = spi_nor_erase_sector(nor, addr);\n\t\t\tspi_nor_unlock_device(nor);\n\t\t\tif (ret)\n\t\t\t\tgoto destroy_erase_cmd_list;\n\n\t\t\tret = spi_nor_wait_till_ready(nor);\n\t\t\tif (ret)\n\t\t\t\tgoto destroy_erase_cmd_list;\n\n\t\t\taddr += cmd->size;\n\t\t\tcmd->count--;\n\t\t}\n\t\tlist_del(&cmd->list);\n\t\tkfree(cmd);\n\t}\n\n\treturn 0;\n\ndestroy_erase_cmd_list:\n\tspi_nor_destroy_erase_cmd_list(&erase_list);\n\treturn ret;\n}\n\n \nstatic int spi_nor_erase(struct mtd_info *mtd, struct erase_info *instr)\n{\n\tstruct spi_nor *nor = mtd_to_spi_nor(mtd);\n\tu32 addr, len;\n\tuint32_t rem;\n\tint ret;\n\n\tdev_dbg(nor->dev, \"at 0x%llx, len %lld\\n\", (long long)instr->addr,\n\t\t\t(long long)instr->len);\n\n\tif (spi_nor_has_uniform_erase(nor)) {\n\t\tdiv_u64_rem(instr->len, mtd->erasesize, &rem);\n\t\tif (rem)\n\t\t\treturn -EINVAL;\n\t}\n\n\taddr = instr->addr;\n\tlen = instr->len;\n\n\tret = spi_nor_prep_and_lock_pe(nor, instr->addr, instr->len);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (len == mtd->size && !(nor->flags & SNOR_F_NO_OP_CHIP_ERASE)) {\n\t\tunsigned long timeout;\n\n\t\tret = spi_nor_lock_device(nor);\n\t\tif (ret)\n\t\t\tgoto erase_err;\n\n\t\tret = spi_nor_write_enable(nor);\n\t\tif (ret) {\n\t\t\tspi_nor_unlock_device(nor);\n\t\t\tgoto erase_err;\n\t\t}\n\n\t\tret = spi_nor_erase_chip(nor);\n\t\tspi_nor_unlock_device(nor);\n\t\tif (ret)\n\t\t\tgoto erase_err;\n\n\t\t \n\t\ttimeout = max(CHIP_ERASE_2MB_READY_WAIT_JIFFIES,\n\t\t\t      CHIP_ERASE_2MB_READY_WAIT_JIFFIES *\n\t\t\t      (unsigned long)(mtd->size / SZ_2M));\n\t\tret = spi_nor_wait_till_ready_with_timeout(nor, timeout);\n\t\tif (ret)\n\t\t\tgoto erase_err;\n\n\t \n\n\t \n\t} else if (spi_nor_has_uniform_erase(nor)) {\n\t\twhile (len) {\n\t\t\tret = spi_nor_lock_device(nor);\n\t\t\tif (ret)\n\t\t\t\tgoto erase_err;\n\n\t\t\tret = spi_nor_write_enable(nor);\n\t\t\tif (ret) {\n\t\t\t\tspi_nor_unlock_device(nor);\n\t\t\t\tgoto erase_err;\n\t\t\t}\n\n\t\t\tret = spi_nor_erase_sector(nor, addr);\n\t\t\tspi_nor_unlock_device(nor);\n\t\t\tif (ret)\n\t\t\t\tgoto erase_err;\n\n\t\t\tret = spi_nor_wait_till_ready(nor);\n\t\t\tif (ret)\n\t\t\t\tgoto erase_err;\n\n\t\t\taddr += mtd->erasesize;\n\t\t\tlen -= mtd->erasesize;\n\t\t}\n\n\t \n\t} else {\n\t\tret = spi_nor_erase_multi_sectors(nor, addr, len);\n\t\tif (ret)\n\t\t\tgoto erase_err;\n\t}\n\n\tret = spi_nor_write_disable(nor);\n\nerase_err:\n\tspi_nor_unlock_and_unprep_pe(nor, instr->addr, instr->len);\n\n\treturn ret;\n}\n\n \nint spi_nor_sr1_bit6_quad_enable(struct spi_nor *nor)\n{\n\tint ret;\n\n\tret = spi_nor_read_sr(nor, nor->bouncebuf);\n\tif (ret)\n\t\treturn ret;\n\n\tif (nor->bouncebuf[0] & SR1_QUAD_EN_BIT6)\n\t\treturn 0;\n\n\tnor->bouncebuf[0] |= SR1_QUAD_EN_BIT6;\n\n\treturn spi_nor_write_sr1_and_check(nor, nor->bouncebuf[0]);\n}\n\n \nint spi_nor_sr2_bit1_quad_enable(struct spi_nor *nor)\n{\n\tint ret;\n\n\tif (nor->flags & SNOR_F_NO_READ_CR)\n\t\treturn spi_nor_write_16bit_cr_and_check(nor, SR2_QUAD_EN_BIT1);\n\n\tret = spi_nor_read_cr(nor, nor->bouncebuf);\n\tif (ret)\n\t\treturn ret;\n\n\tif (nor->bouncebuf[0] & SR2_QUAD_EN_BIT1)\n\t\treturn 0;\n\n\tnor->bouncebuf[0] |= SR2_QUAD_EN_BIT1;\n\n\treturn spi_nor_write_16bit_cr_and_check(nor, nor->bouncebuf[0]);\n}\n\n \nint spi_nor_sr2_bit7_quad_enable(struct spi_nor *nor)\n{\n\tu8 *sr2 = nor->bouncebuf;\n\tint ret;\n\tu8 sr2_written;\n\n\t \n\tret = spi_nor_read_sr2(nor, sr2);\n\tif (ret)\n\t\treturn ret;\n\tif (*sr2 & SR2_QUAD_EN_BIT7)\n\t\treturn 0;\n\n\t \n\t*sr2 |= SR2_QUAD_EN_BIT7;\n\n\tret = spi_nor_write_sr2(nor, sr2);\n\tif (ret)\n\t\treturn ret;\n\n\tsr2_written = *sr2;\n\n\t \n\tret = spi_nor_read_sr2(nor, sr2);\n\tif (ret)\n\t\treturn ret;\n\n\tif (*sr2 != sr2_written) {\n\t\tdev_dbg(nor->dev, \"SR2: Read back test failed\\n\");\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct spi_nor_manufacturer *manufacturers[] = {\n\t&spi_nor_atmel,\n\t&spi_nor_catalyst,\n\t&spi_nor_eon,\n\t&spi_nor_esmt,\n\t&spi_nor_everspin,\n\t&spi_nor_fujitsu,\n\t&spi_nor_gigadevice,\n\t&spi_nor_intel,\n\t&spi_nor_issi,\n\t&spi_nor_macronix,\n\t&spi_nor_micron,\n\t&spi_nor_st,\n\t&spi_nor_spansion,\n\t&spi_nor_sst,\n\t&spi_nor_winbond,\n\t&spi_nor_xilinx,\n\t&spi_nor_xmc,\n};\n\nstatic const struct flash_info spi_nor_generic_flash = {\n\t.name = \"spi-nor-generic\",\n\t.n_banks = 1,\n\t \n\t.page_size = 256,\n\t.parse_sfdp = true,\n};\n\nstatic const struct flash_info *spi_nor_match_id(struct spi_nor *nor,\n\t\t\t\t\t\t const u8 *id)\n{\n\tconst struct flash_info *part;\n\tunsigned int i, j;\n\n\tfor (i = 0; i < ARRAY_SIZE(manufacturers); i++) {\n\t\tfor (j = 0; j < manufacturers[i]->nparts; j++) {\n\t\t\tpart = &manufacturers[i]->parts[j];\n\t\t\tif (part->id_len &&\n\t\t\t    !memcmp(part->id, id, part->id_len)) {\n\t\t\t\tnor->manufacturer = manufacturers[i];\n\t\t\t\treturn part;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\nstatic const struct flash_info *spi_nor_detect(struct spi_nor *nor)\n{\n\tconst struct flash_info *info;\n\tu8 *id = nor->bouncebuf;\n\tint ret;\n\n\tret = spi_nor_read_id(nor, 0, 0, id, nor->reg_proto);\n\tif (ret) {\n\t\tdev_dbg(nor->dev, \"error %d reading JEDEC ID\\n\", ret);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\t \n\tnor->id = devm_kmemdup(nor->dev, id, SPI_NOR_MAX_ID_LEN, GFP_KERNEL);\n\tif (!nor->id)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinfo = spi_nor_match_id(nor, id);\n\n\t \n\tif (!info) {\n\t\tret = spi_nor_check_sfdp_signature(nor);\n\t\tif (!ret)\n\t\t\tinfo = &spi_nor_generic_flash;\n\t}\n\n\tif (!info) {\n\t\tdev_err(nor->dev, \"unrecognized JEDEC id bytes: %*ph\\n\",\n\t\t\tSPI_NOR_MAX_ID_LEN, id);\n\t\treturn ERR_PTR(-ENODEV);\n\t}\n\treturn info;\n}\n\nstatic int spi_nor_read(struct mtd_info *mtd, loff_t from, size_t len,\n\t\t\tsize_t *retlen, u_char *buf)\n{\n\tstruct spi_nor *nor = mtd_to_spi_nor(mtd);\n\tloff_t from_lock = from;\n\tsize_t len_lock = len;\n\tssize_t ret;\n\n\tdev_dbg(nor->dev, \"from 0x%08x, len %zd\\n\", (u32)from, len);\n\n\tret = spi_nor_prep_and_lock_rd(nor, from_lock, len_lock);\n\tif (ret)\n\t\treturn ret;\n\n\twhile (len) {\n\t\tloff_t addr = from;\n\n\t\taddr = spi_nor_convert_addr(nor, addr);\n\n\t\tret = spi_nor_read_data(nor, addr, len, buf);\n\t\tif (ret == 0) {\n\t\t\t \n\t\t\tret = -EIO;\n\t\t\tgoto read_err;\n\t\t}\n\t\tif (ret < 0)\n\t\t\tgoto read_err;\n\n\t\tWARN_ON(ret > len);\n\t\t*retlen += ret;\n\t\tbuf += ret;\n\t\tfrom += ret;\n\t\tlen -= ret;\n\t}\n\tret = 0;\n\nread_err:\n\tspi_nor_unlock_and_unprep_rd(nor, from_lock, len_lock);\n\n\treturn ret;\n}\n\n \nstatic int spi_nor_write(struct mtd_info *mtd, loff_t to, size_t len,\n\tsize_t *retlen, const u_char *buf)\n{\n\tstruct spi_nor *nor = mtd_to_spi_nor(mtd);\n\tsize_t page_offset, page_remain, i;\n\tssize_t ret;\n\tu32 page_size = nor->params->page_size;\n\n\tdev_dbg(nor->dev, \"to 0x%08x, len %zd\\n\", (u32)to, len);\n\n\tret = spi_nor_prep_and_lock_pe(nor, to, len);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < len; ) {\n\t\tssize_t written;\n\t\tloff_t addr = to + i;\n\n\t\t \n\t\tif (is_power_of_2(page_size)) {\n\t\t\tpage_offset = addr & (page_size - 1);\n\t\t} else {\n\t\t\tuint64_t aux = addr;\n\n\t\t\tpage_offset = do_div(aux, page_size);\n\t\t}\n\t\t \n\t\tpage_remain = min_t(size_t, page_size - page_offset, len - i);\n\n\t\taddr = spi_nor_convert_addr(nor, addr);\n\n\t\tret = spi_nor_lock_device(nor);\n\t\tif (ret)\n\t\t\tgoto write_err;\n\n\t\tret = spi_nor_write_enable(nor);\n\t\tif (ret) {\n\t\t\tspi_nor_unlock_device(nor);\n\t\t\tgoto write_err;\n\t\t}\n\n\t\tret = spi_nor_write_data(nor, addr, page_remain, buf + i);\n\t\tspi_nor_unlock_device(nor);\n\t\tif (ret < 0)\n\t\t\tgoto write_err;\n\t\twritten = ret;\n\n\t\tret = spi_nor_wait_till_ready(nor);\n\t\tif (ret)\n\t\t\tgoto write_err;\n\t\t*retlen += written;\n\t\ti += written;\n\t}\n\nwrite_err:\n\tspi_nor_unlock_and_unprep_pe(nor, to, len);\n\n\treturn ret;\n}\n\nstatic int spi_nor_check(struct spi_nor *nor)\n{\n\tif (!nor->dev ||\n\t    (!nor->spimem && !nor->controller_ops) ||\n\t    (!nor->spimem && nor->controller_ops &&\n\t    (!nor->controller_ops->read ||\n\t     !nor->controller_ops->write ||\n\t     !nor->controller_ops->read_reg ||\n\t     !nor->controller_ops->write_reg))) {\n\t\tpr_err(\"spi-nor: please fill all the necessary fields!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (nor->spimem && nor->controller_ops) {\n\t\tdev_err(nor->dev, \"nor->spimem and nor->controller_ops are mutually exclusive, please set just one of them.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nvoid\nspi_nor_set_read_settings(struct spi_nor_read_command *read,\n\t\t\t  u8 num_mode_clocks,\n\t\t\t  u8 num_wait_states,\n\t\t\t  u8 opcode,\n\t\t\t  enum spi_nor_protocol proto)\n{\n\tread->num_mode_clocks = num_mode_clocks;\n\tread->num_wait_states = num_wait_states;\n\tread->opcode = opcode;\n\tread->proto = proto;\n}\n\nvoid spi_nor_set_pp_settings(struct spi_nor_pp_command *pp, u8 opcode,\n\t\t\t     enum spi_nor_protocol proto)\n{\n\tpp->opcode = opcode;\n\tpp->proto = proto;\n}\n\nstatic int spi_nor_hwcaps2cmd(u32 hwcaps, const int table[][2], size_t size)\n{\n\tsize_t i;\n\n\tfor (i = 0; i < size; i++)\n\t\tif (table[i][0] == (int)hwcaps)\n\t\t\treturn table[i][1];\n\n\treturn -EINVAL;\n}\n\nint spi_nor_hwcaps_read2cmd(u32 hwcaps)\n{\n\tstatic const int hwcaps_read2cmd[][2] = {\n\t\t{ SNOR_HWCAPS_READ,\t\tSNOR_CMD_READ },\n\t\t{ SNOR_HWCAPS_READ_FAST,\tSNOR_CMD_READ_FAST },\n\t\t{ SNOR_HWCAPS_READ_1_1_1_DTR,\tSNOR_CMD_READ_1_1_1_DTR },\n\t\t{ SNOR_HWCAPS_READ_1_1_2,\tSNOR_CMD_READ_1_1_2 },\n\t\t{ SNOR_HWCAPS_READ_1_2_2,\tSNOR_CMD_READ_1_2_2 },\n\t\t{ SNOR_HWCAPS_READ_2_2_2,\tSNOR_CMD_READ_2_2_2 },\n\t\t{ SNOR_HWCAPS_READ_1_2_2_DTR,\tSNOR_CMD_READ_1_2_2_DTR },\n\t\t{ SNOR_HWCAPS_READ_1_1_4,\tSNOR_CMD_READ_1_1_4 },\n\t\t{ SNOR_HWCAPS_READ_1_4_4,\tSNOR_CMD_READ_1_4_4 },\n\t\t{ SNOR_HWCAPS_READ_4_4_4,\tSNOR_CMD_READ_4_4_4 },\n\t\t{ SNOR_HWCAPS_READ_1_4_4_DTR,\tSNOR_CMD_READ_1_4_4_DTR },\n\t\t{ SNOR_HWCAPS_READ_1_1_8,\tSNOR_CMD_READ_1_1_8 },\n\t\t{ SNOR_HWCAPS_READ_1_8_8,\tSNOR_CMD_READ_1_8_8 },\n\t\t{ SNOR_HWCAPS_READ_8_8_8,\tSNOR_CMD_READ_8_8_8 },\n\t\t{ SNOR_HWCAPS_READ_1_8_8_DTR,\tSNOR_CMD_READ_1_8_8_DTR },\n\t\t{ SNOR_HWCAPS_READ_8_8_8_DTR,\tSNOR_CMD_READ_8_8_8_DTR },\n\t};\n\n\treturn spi_nor_hwcaps2cmd(hwcaps, hwcaps_read2cmd,\n\t\t\t\t  ARRAY_SIZE(hwcaps_read2cmd));\n}\n\nint spi_nor_hwcaps_pp2cmd(u32 hwcaps)\n{\n\tstatic const int hwcaps_pp2cmd[][2] = {\n\t\t{ SNOR_HWCAPS_PP,\t\tSNOR_CMD_PP },\n\t\t{ SNOR_HWCAPS_PP_1_1_4,\t\tSNOR_CMD_PP_1_1_4 },\n\t\t{ SNOR_HWCAPS_PP_1_4_4,\t\tSNOR_CMD_PP_1_4_4 },\n\t\t{ SNOR_HWCAPS_PP_4_4_4,\t\tSNOR_CMD_PP_4_4_4 },\n\t\t{ SNOR_HWCAPS_PP_1_1_8,\t\tSNOR_CMD_PP_1_1_8 },\n\t\t{ SNOR_HWCAPS_PP_1_8_8,\t\tSNOR_CMD_PP_1_8_8 },\n\t\t{ SNOR_HWCAPS_PP_8_8_8,\t\tSNOR_CMD_PP_8_8_8 },\n\t\t{ SNOR_HWCAPS_PP_8_8_8_DTR,\tSNOR_CMD_PP_8_8_8_DTR },\n\t};\n\n\treturn spi_nor_hwcaps2cmd(hwcaps, hwcaps_pp2cmd,\n\t\t\t\t  ARRAY_SIZE(hwcaps_pp2cmd));\n}\n\n \nstatic int spi_nor_spimem_check_op(struct spi_nor *nor,\n\t\t\t\t   struct spi_mem_op *op)\n{\n\t \n\top->addr.nbytes = 4;\n\tif (!spi_mem_supports_op(nor->spimem, op)) {\n\t\tif (nor->params->size > SZ_16M)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\t \n\t\top->addr.nbytes = 3;\n\t\tif (!spi_mem_supports_op(nor->spimem, op))\n\t\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int spi_nor_spimem_check_readop(struct spi_nor *nor,\n\t\t\t\t       const struct spi_nor_read_command *read)\n{\n\tstruct spi_mem_op op = SPI_NOR_READ_OP(read->opcode);\n\n\tspi_nor_spimem_setup_op(nor, &op, read->proto);\n\n\t \n\top.dummy.nbytes = (read->num_mode_clocks + read->num_wait_states) *\n\t\t\t  op.dummy.buswidth / 8;\n\tif (spi_nor_protocol_is_dtr(nor->read_proto))\n\t\top.dummy.nbytes *= 2;\n\n\treturn spi_nor_spimem_check_op(nor, &op);\n}\n\n \nstatic int spi_nor_spimem_check_pp(struct spi_nor *nor,\n\t\t\t\t   const struct spi_nor_pp_command *pp)\n{\n\tstruct spi_mem_op op = SPI_NOR_PP_OP(pp->opcode);\n\n\tspi_nor_spimem_setup_op(nor, &op, pp->proto);\n\n\treturn spi_nor_spimem_check_op(nor, &op);\n}\n\n \nstatic void\nspi_nor_spimem_adjust_hwcaps(struct spi_nor *nor, u32 *hwcaps)\n{\n\tstruct spi_nor_flash_parameter *params = nor->params;\n\tunsigned int cap;\n\n\t \n\t*hwcaps &= ~SNOR_HWCAPS_X_X_X;\n\n\t \n\tif (nor->flags & SNOR_F_BROKEN_RESET)\n\t\t*hwcaps &= ~(SNOR_HWCAPS_X_X_X | SNOR_HWCAPS_X_X_X_DTR);\n\n\tfor (cap = 0; cap < sizeof(*hwcaps) * BITS_PER_BYTE; cap++) {\n\t\tint rdidx, ppidx;\n\n\t\tif (!(*hwcaps & BIT(cap)))\n\t\t\tcontinue;\n\n\t\trdidx = spi_nor_hwcaps_read2cmd(BIT(cap));\n\t\tif (rdidx >= 0 &&\n\t\t    spi_nor_spimem_check_readop(nor, &params->reads[rdidx]))\n\t\t\t*hwcaps &= ~BIT(cap);\n\n\t\tppidx = spi_nor_hwcaps_pp2cmd(BIT(cap));\n\t\tif (ppidx < 0)\n\t\t\tcontinue;\n\n\t\tif (spi_nor_spimem_check_pp(nor,\n\t\t\t\t\t    &params->page_programs[ppidx]))\n\t\t\t*hwcaps &= ~BIT(cap);\n\t}\n}\n\n \nvoid spi_nor_set_erase_type(struct spi_nor_erase_type *erase, u32 size,\n\t\t\t    u8 opcode)\n{\n\terase->size = size;\n\terase->opcode = opcode;\n\t \n\terase->size_shift = ffs(erase->size) - 1;\n\terase->size_mask = (1 << erase->size_shift) - 1;\n}\n\n \nvoid spi_nor_mask_erase_type(struct spi_nor_erase_type *erase)\n{\n\terase->size = 0;\n}\n\n \nvoid spi_nor_init_uniform_erase_map(struct spi_nor_erase_map *map,\n\t\t\t\t    u8 erase_mask, u64 flash_size)\n{\n\t \n\tmap->uniform_region.offset = (erase_mask & SNOR_ERASE_TYPE_MASK) |\n\t\t\t\t     SNOR_LAST_REGION;\n\tmap->uniform_region.size = flash_size;\n\tmap->regions = &map->uniform_region;\n\tmap->uniform_erase_type = erase_mask;\n}\n\nint spi_nor_post_bfpt_fixups(struct spi_nor *nor,\n\t\t\t     const struct sfdp_parameter_header *bfpt_header,\n\t\t\t     const struct sfdp_bfpt *bfpt)\n{\n\tint ret;\n\n\tif (nor->manufacturer && nor->manufacturer->fixups &&\n\t    nor->manufacturer->fixups->post_bfpt) {\n\t\tret = nor->manufacturer->fixups->post_bfpt(nor, bfpt_header,\n\t\t\t\t\t\t\t   bfpt);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (nor->info->fixups && nor->info->fixups->post_bfpt)\n\t\treturn nor->info->fixups->post_bfpt(nor, bfpt_header, bfpt);\n\n\treturn 0;\n}\n\nstatic int spi_nor_select_read(struct spi_nor *nor,\n\t\t\t       u32 shared_hwcaps)\n{\n\tint cmd, best_match = fls(shared_hwcaps & SNOR_HWCAPS_READ_MASK) - 1;\n\tconst struct spi_nor_read_command *read;\n\n\tif (best_match < 0)\n\t\treturn -EINVAL;\n\n\tcmd = spi_nor_hwcaps_read2cmd(BIT(best_match));\n\tif (cmd < 0)\n\t\treturn -EINVAL;\n\n\tread = &nor->params->reads[cmd];\n\tnor->read_opcode = read->opcode;\n\tnor->read_proto = read->proto;\n\n\t \n\tnor->read_dummy = read->num_mode_clocks + read->num_wait_states;\n\treturn 0;\n}\n\nstatic int spi_nor_select_pp(struct spi_nor *nor,\n\t\t\t     u32 shared_hwcaps)\n{\n\tint cmd, best_match = fls(shared_hwcaps & SNOR_HWCAPS_PP_MASK) - 1;\n\tconst struct spi_nor_pp_command *pp;\n\n\tif (best_match < 0)\n\t\treturn -EINVAL;\n\n\tcmd = spi_nor_hwcaps_pp2cmd(BIT(best_match));\n\tif (cmd < 0)\n\t\treturn -EINVAL;\n\n\tpp = &nor->params->page_programs[cmd];\n\tnor->program_opcode = pp->opcode;\n\tnor->write_proto = pp->proto;\n\treturn 0;\n}\n\n \nstatic const struct spi_nor_erase_type *\nspi_nor_select_uniform_erase(struct spi_nor_erase_map *map,\n\t\t\t     const u32 wanted_size)\n{\n\tconst struct spi_nor_erase_type *tested_erase, *erase = NULL;\n\tint i;\n\tu8 uniform_erase_type = map->uniform_erase_type;\n\n\tfor (i = SNOR_ERASE_TYPE_MAX - 1; i >= 0; i--) {\n\t\tif (!(uniform_erase_type & BIT(i)))\n\t\t\tcontinue;\n\n\t\ttested_erase = &map->erase_type[i];\n\n\t\t \n\t\tif (!tested_erase->size)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (tested_erase->size == wanted_size) {\n\t\t\terase = tested_erase;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (!erase && tested_erase->size)\n\t\t\terase = tested_erase;\n\t\t\t \n\t}\n\n\tif (!erase)\n\t\treturn NULL;\n\n\t \n\tmap->uniform_erase_type &= ~SNOR_ERASE_TYPE_MASK;\n\tmap->uniform_erase_type |= BIT(erase - map->erase_type);\n\treturn erase;\n}\n\nstatic int spi_nor_select_erase(struct spi_nor *nor)\n{\n\tstruct spi_nor_erase_map *map = &nor->params->erase_map;\n\tconst struct spi_nor_erase_type *erase = NULL;\n\tstruct mtd_info *mtd = &nor->mtd;\n\tu32 wanted_size = nor->info->sector_size;\n\tint i;\n\n\t \n#ifdef CONFIG_MTD_SPI_NOR_USE_4K_SECTORS\n\t \n\twanted_size = 4096u;\n#endif\n\n\tif (spi_nor_has_uniform_erase(nor)) {\n\t\terase = spi_nor_select_uniform_erase(map, wanted_size);\n\t\tif (!erase)\n\t\t\treturn -EINVAL;\n\t\tnor->erase_opcode = erase->opcode;\n\t\tmtd->erasesize = erase->size;\n\t\treturn 0;\n\t}\n\n\t \n\tfor (i = SNOR_ERASE_TYPE_MAX - 1; i >= 0; i--) {\n\t\tif (map->erase_type[i].size) {\n\t\t\terase = &map->erase_type[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!erase)\n\t\treturn -EINVAL;\n\n\tmtd->erasesize = erase->size;\n\treturn 0;\n}\n\nstatic int spi_nor_default_setup(struct spi_nor *nor,\n\t\t\t\t const struct spi_nor_hwcaps *hwcaps)\n{\n\tstruct spi_nor_flash_parameter *params = nor->params;\n\tu32 ignored_mask, shared_mask;\n\tint err;\n\n\t \n\tshared_mask = hwcaps->mask & params->hwcaps.mask;\n\n\tif (nor->spimem) {\n\t\t \n\t\tspi_nor_spimem_adjust_hwcaps(nor, &shared_mask);\n\t} else {\n\t\t \n\t\tignored_mask = SNOR_HWCAPS_X_X_X | SNOR_HWCAPS_X_X_X_DTR;\n\t\tif (shared_mask & ignored_mask) {\n\t\t\tdev_dbg(nor->dev,\n\t\t\t\t\"SPI n-n-n protocols are not supported.\\n\");\n\t\t\tshared_mask &= ~ignored_mask;\n\t\t}\n\t}\n\n\t \n\terr = spi_nor_select_read(nor, shared_mask);\n\tif (err) {\n\t\tdev_dbg(nor->dev,\n\t\t\t\"can't select read settings supported by both the SPI controller and memory.\\n\");\n\t\treturn err;\n\t}\n\n\t \n\terr = spi_nor_select_pp(nor, shared_mask);\n\tif (err) {\n\t\tdev_dbg(nor->dev,\n\t\t\t\"can't select write settings supported by both the SPI controller and memory.\\n\");\n\t\treturn err;\n\t}\n\n\t \n\terr = spi_nor_select_erase(nor);\n\tif (err) {\n\t\tdev_dbg(nor->dev,\n\t\t\t\"can't select erase settings supported by both the SPI controller and memory.\\n\");\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int spi_nor_set_addr_nbytes(struct spi_nor *nor)\n{\n\tif (nor->params->addr_nbytes) {\n\t\tnor->addr_nbytes = nor->params->addr_nbytes;\n\t} else if (nor->read_proto == SNOR_PROTO_8_8_8_DTR) {\n\t\t \n\t\tnor->addr_nbytes = 4;\n\t} else if (nor->info->addr_nbytes) {\n\t\tnor->addr_nbytes = nor->info->addr_nbytes;\n\t} else {\n\t\tnor->addr_nbytes = 3;\n\t}\n\n\tif (nor->addr_nbytes == 3 && nor->params->size > 0x1000000) {\n\t\t \n\t\tnor->addr_nbytes = 4;\n\t}\n\n\tif (nor->addr_nbytes > SPI_NOR_MAX_ADDR_NBYTES) {\n\t\tdev_dbg(nor->dev, \"The number of address bytes is too large: %u\\n\",\n\t\t\tnor->addr_nbytes);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (nor->addr_nbytes == 4 && nor->flags & SNOR_F_4B_OPCODES &&\n\t    !(nor->flags & SNOR_F_HAS_4BAIT))\n\t\tspi_nor_set_4byte_opcodes(nor);\n\n\treturn 0;\n}\n\nstatic int spi_nor_setup(struct spi_nor *nor,\n\t\t\t const struct spi_nor_hwcaps *hwcaps)\n{\n\tint ret;\n\n\tif (nor->params->setup)\n\t\tret = nor->params->setup(nor, hwcaps);\n\telse\n\t\tret = spi_nor_default_setup(nor, hwcaps);\n\tif (ret)\n\t\treturn ret;\n\n\treturn spi_nor_set_addr_nbytes(nor);\n}\n\n \nstatic void spi_nor_manufacturer_init_params(struct spi_nor *nor)\n{\n\tif (nor->manufacturer && nor->manufacturer->fixups &&\n\t    nor->manufacturer->fixups->default_init)\n\t\tnor->manufacturer->fixups->default_init(nor);\n\n\tif (nor->info->fixups && nor->info->fixups->default_init)\n\t\tnor->info->fixups->default_init(nor);\n}\n\n \nstatic void spi_nor_no_sfdp_init_params(struct spi_nor *nor)\n{\n\tstruct spi_nor_flash_parameter *params = nor->params;\n\tstruct spi_nor_erase_map *map = &params->erase_map;\n\tconst u8 no_sfdp_flags = nor->info->no_sfdp_flags;\n\tu8 i, erase_mask;\n\n\tif (no_sfdp_flags & SPI_NOR_DUAL_READ) {\n\t\tparams->hwcaps.mask |= SNOR_HWCAPS_READ_1_1_2;\n\t\tspi_nor_set_read_settings(&params->reads[SNOR_CMD_READ_1_1_2],\n\t\t\t\t\t  0, 8, SPINOR_OP_READ_1_1_2,\n\t\t\t\t\t  SNOR_PROTO_1_1_2);\n\t}\n\n\tif (no_sfdp_flags & SPI_NOR_QUAD_READ) {\n\t\tparams->hwcaps.mask |= SNOR_HWCAPS_READ_1_1_4;\n\t\tspi_nor_set_read_settings(&params->reads[SNOR_CMD_READ_1_1_4],\n\t\t\t\t\t  0, 8, SPINOR_OP_READ_1_1_4,\n\t\t\t\t\t  SNOR_PROTO_1_1_4);\n\t}\n\n\tif (no_sfdp_flags & SPI_NOR_OCTAL_READ) {\n\t\tparams->hwcaps.mask |= SNOR_HWCAPS_READ_1_1_8;\n\t\tspi_nor_set_read_settings(&params->reads[SNOR_CMD_READ_1_1_8],\n\t\t\t\t\t  0, 8, SPINOR_OP_READ_1_1_8,\n\t\t\t\t\t  SNOR_PROTO_1_1_8);\n\t}\n\n\tif (no_sfdp_flags & SPI_NOR_OCTAL_DTR_READ) {\n\t\tparams->hwcaps.mask |= SNOR_HWCAPS_READ_8_8_8_DTR;\n\t\tspi_nor_set_read_settings(&params->reads[SNOR_CMD_READ_8_8_8_DTR],\n\t\t\t\t\t  0, 20, SPINOR_OP_READ_FAST,\n\t\t\t\t\t  SNOR_PROTO_8_8_8_DTR);\n\t}\n\n\tif (no_sfdp_flags & SPI_NOR_OCTAL_DTR_PP) {\n\t\tparams->hwcaps.mask |= SNOR_HWCAPS_PP_8_8_8_DTR;\n\t\t \n\t\tspi_nor_set_pp_settings(&params->page_programs[SNOR_CMD_PP_8_8_8_DTR],\n\t\t\t\t\tSPINOR_OP_PP, SNOR_PROTO_8_8_8_DTR);\n\t}\n\n\t \n\terase_mask = 0;\n\ti = 0;\n\tif (no_sfdp_flags & SECT_4K) {\n\t\terase_mask |= BIT(i);\n\t\tspi_nor_set_erase_type(&map->erase_type[i], 4096u,\n\t\t\t\t       SPINOR_OP_BE_4K);\n\t\ti++;\n\t}\n\terase_mask |= BIT(i);\n\tspi_nor_set_erase_type(&map->erase_type[i], nor->info->sector_size,\n\t\t\t       SPINOR_OP_SE);\n\tspi_nor_init_uniform_erase_map(map, erase_mask, params->size);\n}\n\n \nstatic void spi_nor_init_flags(struct spi_nor *nor)\n{\n\tstruct device_node *np = spi_nor_get_flash_node(nor);\n\tconst u16 flags = nor->info->flags;\n\n\tif (of_property_read_bool(np, \"broken-flash-reset\"))\n\t\tnor->flags |= SNOR_F_BROKEN_RESET;\n\n\tif (of_property_read_bool(np, \"no-wp\"))\n\t\tnor->flags |= SNOR_F_NO_WP;\n\n\tif (flags & SPI_NOR_SWP_IS_VOLATILE)\n\t\tnor->flags |= SNOR_F_SWP_IS_VOLATILE;\n\n\tif (flags & SPI_NOR_HAS_LOCK)\n\t\tnor->flags |= SNOR_F_HAS_LOCK;\n\n\tif (flags & SPI_NOR_HAS_TB) {\n\t\tnor->flags |= SNOR_F_HAS_SR_TB;\n\t\tif (flags & SPI_NOR_TB_SR_BIT6)\n\t\t\tnor->flags |= SNOR_F_HAS_SR_TB_BIT6;\n\t}\n\n\tif (flags & SPI_NOR_4BIT_BP) {\n\t\tnor->flags |= SNOR_F_HAS_4BIT_BP;\n\t\tif (flags & SPI_NOR_BP3_SR_BIT6)\n\t\t\tnor->flags |= SNOR_F_HAS_SR_BP3_BIT6;\n\t}\n\n\tif (flags & NO_CHIP_ERASE)\n\t\tnor->flags |= SNOR_F_NO_OP_CHIP_ERASE;\n\n\tif (flags & SPI_NOR_RWW && nor->info->n_banks > 1 &&\n\t    !nor->controller_ops)\n\t\tnor->flags |= SNOR_F_RWW;\n}\n\n \nstatic void spi_nor_init_fixup_flags(struct spi_nor *nor)\n{\n\tconst u8 fixup_flags = nor->info->fixup_flags;\n\n\tif (fixup_flags & SPI_NOR_4B_OPCODES)\n\t\tnor->flags |= SNOR_F_4B_OPCODES;\n\n\tif (fixup_flags & SPI_NOR_IO_MODE_EN_VOLATILE)\n\t\tnor->flags |= SNOR_F_IO_MODE_EN_VOLATILE;\n}\n\n \nstatic int spi_nor_late_init_params(struct spi_nor *nor)\n{\n\tstruct spi_nor_flash_parameter *params = nor->params;\n\tint ret;\n\n\tif (nor->manufacturer && nor->manufacturer->fixups &&\n\t    nor->manufacturer->fixups->late_init) {\n\t\tret = nor->manufacturer->fixups->late_init(nor);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (nor->info->fixups && nor->info->fixups->late_init) {\n\t\tret = nor->info->fixups->late_init(nor);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\tif (!params->set_4byte_addr_mode)\n\t\tparams->set_4byte_addr_mode = spi_nor_set_4byte_addr_mode_brwr;\n\n\tspi_nor_init_flags(nor);\n\tspi_nor_init_fixup_flags(nor);\n\n\t \n\tif (nor->flags & SNOR_F_HAS_LOCK && !nor->params->locking_ops)\n\t\tspi_nor_init_default_locking_ops(nor);\n\n\tif (nor->info->n_banks > 1)\n\t\tparams->bank_size = div64_u64(params->size, nor->info->n_banks);\n\n\treturn 0;\n}\n\n \nstatic void spi_nor_sfdp_init_params_deprecated(struct spi_nor *nor)\n{\n\tstruct spi_nor_flash_parameter sfdp_params;\n\n\tmemcpy(&sfdp_params, nor->params, sizeof(sfdp_params));\n\n\tif (spi_nor_parse_sfdp(nor)) {\n\t\tmemcpy(nor->params, &sfdp_params, sizeof(*nor->params));\n\t\tnor->flags &= ~SNOR_F_4B_OPCODES;\n\t}\n}\n\n \nstatic void spi_nor_init_params_deprecated(struct spi_nor *nor)\n{\n\tspi_nor_no_sfdp_init_params(nor);\n\n\tspi_nor_manufacturer_init_params(nor);\n\n\tif (nor->info->no_sfdp_flags & (SPI_NOR_DUAL_READ |\n\t\t\t\t\tSPI_NOR_QUAD_READ |\n\t\t\t\t\tSPI_NOR_OCTAL_READ |\n\t\t\t\t\tSPI_NOR_OCTAL_DTR_READ))\n\t\tspi_nor_sfdp_init_params_deprecated(nor);\n}\n\n \nstatic void spi_nor_init_default_params(struct spi_nor *nor)\n{\n\tstruct spi_nor_flash_parameter *params = nor->params;\n\tconst struct flash_info *info = nor->info;\n\tstruct device_node *np = spi_nor_get_flash_node(nor);\n\n\tparams->quad_enable = spi_nor_sr2_bit1_quad_enable;\n\tparams->otp.org = &info->otp_org;\n\n\t \n\tnor->flags |= SNOR_F_HAS_16BIT_SR;\n\n\t \n\tparams->writesize = 1;\n\tparams->size = (u64)info->sector_size * info->n_sectors;\n\tparams->bank_size = params->size;\n\tparams->page_size = info->page_size;\n\n\tif (!(info->flags & SPI_NOR_NO_FR)) {\n\t\t \n\t\tparams->hwcaps.mask |= SNOR_HWCAPS_READ_FAST;\n\n\t\t \n\t\tif (np && !of_property_read_bool(np, \"m25p,fast-read\"))\n\t\t\tparams->hwcaps.mask &= ~SNOR_HWCAPS_READ_FAST;\n\t}\n\n\t \n\tparams->hwcaps.mask |= SNOR_HWCAPS_READ;\n\tspi_nor_set_read_settings(&params->reads[SNOR_CMD_READ],\n\t\t\t\t  0, 0, SPINOR_OP_READ,\n\t\t\t\t  SNOR_PROTO_1_1_1);\n\n\tif (params->hwcaps.mask & SNOR_HWCAPS_READ_FAST)\n\t\tspi_nor_set_read_settings(&params->reads[SNOR_CMD_READ_FAST],\n\t\t\t\t\t  0, 8, SPINOR_OP_READ_FAST,\n\t\t\t\t\t  SNOR_PROTO_1_1_1);\n\t \n\tparams->hwcaps.mask |= SNOR_HWCAPS_PP;\n\tspi_nor_set_pp_settings(&params->page_programs[SNOR_CMD_PP],\n\t\t\t\tSPINOR_OP_PP, SNOR_PROTO_1_1_1);\n\n\tif (info->flags & SPI_NOR_QUAD_PP) {\n\t\tparams->hwcaps.mask |= SNOR_HWCAPS_PP_1_1_4;\n\t\tspi_nor_set_pp_settings(&params->page_programs[SNOR_CMD_PP_1_1_4],\n\t\t\t\t\tSPINOR_OP_PP_1_1_4, SNOR_PROTO_1_1_4);\n\t}\n}\n\n \nstatic int spi_nor_init_params(struct spi_nor *nor)\n{\n\tint ret;\n\n\tnor->params = devm_kzalloc(nor->dev, sizeof(*nor->params), GFP_KERNEL);\n\tif (!nor->params)\n\t\treturn -ENOMEM;\n\n\tspi_nor_init_default_params(nor);\n\n\tif (nor->info->parse_sfdp) {\n\t\tret = spi_nor_parse_sfdp(nor);\n\t\tif (ret) {\n\t\t\tdev_err(nor->dev, \"BFPT parsing failed. Please consider using SPI_NOR_SKIP_SFDP when declaring the flash\\n\");\n\t\t\treturn ret;\n\t\t}\n\t} else if (nor->info->no_sfdp_flags & SPI_NOR_SKIP_SFDP) {\n\t\tspi_nor_no_sfdp_init_params(nor);\n\t} else {\n\t\tspi_nor_init_params_deprecated(nor);\n\t}\n\n\treturn spi_nor_late_init_params(nor);\n}\n\n \nstatic int spi_nor_set_octal_dtr(struct spi_nor *nor, bool enable)\n{\n\tint ret;\n\n\tif (!nor->params->set_octal_dtr)\n\t\treturn 0;\n\n\tif (!(nor->read_proto == SNOR_PROTO_8_8_8_DTR &&\n\t      nor->write_proto == SNOR_PROTO_8_8_8_DTR))\n\t\treturn 0;\n\n\tif (!(nor->flags & SNOR_F_IO_MODE_EN_VOLATILE))\n\t\treturn 0;\n\n\tret = nor->params->set_octal_dtr(nor, enable);\n\tif (ret)\n\t\treturn ret;\n\n\tif (enable)\n\t\tnor->reg_proto = SNOR_PROTO_8_8_8_DTR;\n\telse\n\t\tnor->reg_proto = SNOR_PROTO_1_1_1;\n\n\treturn 0;\n}\n\n \nstatic int spi_nor_quad_enable(struct spi_nor *nor)\n{\n\tif (!nor->params->quad_enable)\n\t\treturn 0;\n\n\tif (!(spi_nor_get_protocol_width(nor->read_proto) == 4 ||\n\t      spi_nor_get_protocol_width(nor->write_proto) == 4))\n\t\treturn 0;\n\n\treturn nor->params->quad_enable(nor);\n}\n\n \nint spi_nor_set_4byte_addr_mode(struct spi_nor *nor, bool enable)\n{\n\tstruct spi_nor_flash_parameter *params = nor->params;\n\tint ret;\n\n\tret = params->set_4byte_addr_mode(nor, enable);\n\tif (ret && ret != -ENOTSUPP)\n\t\treturn ret;\n\n\tif (enable) {\n\t\tparams->addr_nbytes = 4;\n\t\tparams->addr_mode_nbytes = 4;\n\t} else {\n\t\tparams->addr_nbytes = 3;\n\t\tparams->addr_mode_nbytes = 3;\n\t}\n\n\treturn 0;\n}\n\nstatic int spi_nor_init(struct spi_nor *nor)\n{\n\tint err;\n\n\terr = spi_nor_set_octal_dtr(nor, true);\n\tif (err) {\n\t\tdev_dbg(nor->dev, \"octal mode not supported\\n\");\n\t\treturn err;\n\t}\n\n\terr = spi_nor_quad_enable(nor);\n\tif (err) {\n\t\tdev_dbg(nor->dev, \"quad mode not supported\\n\");\n\t\treturn err;\n\t}\n\n\t \n\tif (IS_ENABLED(CONFIG_MTD_SPI_NOR_SWP_DISABLE) ||\n\t    (IS_ENABLED(CONFIG_MTD_SPI_NOR_SWP_DISABLE_ON_VOLATILE) &&\n\t     nor->flags & SNOR_F_SWP_IS_VOLATILE))\n\t\tspi_nor_try_unlock_all(nor);\n\n\tif (nor->addr_nbytes == 4 &&\n\t    nor->read_proto != SNOR_PROTO_8_8_8_DTR &&\n\t    !(nor->flags & SNOR_F_4B_OPCODES)) {\n\t\t \n\t\tWARN_ONCE(nor->flags & SNOR_F_BROKEN_RESET,\n\t\t\t  \"enabling reset hack; may not recover from unexpected reboots\\n\");\n\t\terr = spi_nor_set_4byte_addr_mode(nor, true);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\n \nstatic void spi_nor_soft_reset(struct spi_nor *nor)\n{\n\tstruct spi_mem_op op;\n\tint ret;\n\n\top = (struct spi_mem_op)SPINOR_SRSTEN_OP;\n\n\tspi_nor_spimem_setup_op(nor, &op, nor->reg_proto);\n\n\tret = spi_mem_exec_op(nor->spimem, &op);\n\tif (ret) {\n\t\tdev_warn(nor->dev, \"Software reset failed: %d\\n\", ret);\n\t\treturn;\n\t}\n\n\top = (struct spi_mem_op)SPINOR_SRST_OP;\n\n\tspi_nor_spimem_setup_op(nor, &op, nor->reg_proto);\n\n\tret = spi_mem_exec_op(nor->spimem, &op);\n\tif (ret) {\n\t\tdev_warn(nor->dev, \"Software reset failed: %d\\n\", ret);\n\t\treturn;\n\t}\n\n\t \n\tusleep_range(SPI_NOR_SRST_SLEEP_MIN, SPI_NOR_SRST_SLEEP_MAX);\n}\n\n \nstatic int spi_nor_suspend(struct mtd_info *mtd)\n{\n\tstruct spi_nor *nor = mtd_to_spi_nor(mtd);\n\tint ret;\n\n\t \n\tret = spi_nor_set_octal_dtr(nor, false);\n\tif (ret)\n\t\tdev_err(nor->dev, \"suspend() failed\\n\");\n\n\treturn ret;\n}\n\n \nstatic void spi_nor_resume(struct mtd_info *mtd)\n{\n\tstruct spi_nor *nor = mtd_to_spi_nor(mtd);\n\tstruct device *dev = nor->dev;\n\tint ret;\n\n\t \n\tret = spi_nor_init(nor);\n\tif (ret)\n\t\tdev_err(dev, \"resume() failed\\n\");\n}\n\nstatic int spi_nor_get_device(struct mtd_info *mtd)\n{\n\tstruct mtd_info *master = mtd_get_master(mtd);\n\tstruct spi_nor *nor = mtd_to_spi_nor(master);\n\tstruct device *dev;\n\n\tif (nor->spimem)\n\t\tdev = nor->spimem->spi->controller->dev.parent;\n\telse\n\t\tdev = nor->dev;\n\n\tif (!try_module_get(dev->driver->owner))\n\t\treturn -ENODEV;\n\n\treturn 0;\n}\n\nstatic void spi_nor_put_device(struct mtd_info *mtd)\n{\n\tstruct mtd_info *master = mtd_get_master(mtd);\n\tstruct spi_nor *nor = mtd_to_spi_nor(master);\n\tstruct device *dev;\n\n\tif (nor->spimem)\n\t\tdev = nor->spimem->spi->controller->dev.parent;\n\telse\n\t\tdev = nor->dev;\n\n\tmodule_put(dev->driver->owner);\n}\n\nstatic void spi_nor_restore(struct spi_nor *nor)\n{\n\tint ret;\n\n\t \n\tif (nor->addr_nbytes == 4 && !(nor->flags & SNOR_F_4B_OPCODES) &&\n\t    nor->flags & SNOR_F_BROKEN_RESET) {\n\t\tret = spi_nor_set_4byte_addr_mode(nor, false);\n\t\tif (ret)\n\t\t\t \n\t\t\tdev_err(nor->dev, \"Failed to exit 4-byte address mode, err = %d\\n\", ret);\n\t}\n\n\tif (nor->flags & SNOR_F_SOFT_RESET)\n\t\tspi_nor_soft_reset(nor);\n}\n\nstatic const struct flash_info *spi_nor_match_name(struct spi_nor *nor,\n\t\t\t\t\t\t   const char *name)\n{\n\tunsigned int i, j;\n\n\tfor (i = 0; i < ARRAY_SIZE(manufacturers); i++) {\n\t\tfor (j = 0; j < manufacturers[i]->nparts; j++) {\n\t\t\tif (!strcmp(name, manufacturers[i]->parts[j].name)) {\n\t\t\t\tnor->manufacturer = manufacturers[i];\n\t\t\t\treturn &manufacturers[i]->parts[j];\n\t\t\t}\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\nstatic const struct flash_info *spi_nor_get_flash_info(struct spi_nor *nor,\n\t\t\t\t\t\t       const char *name)\n{\n\tconst struct flash_info *info = NULL;\n\n\tif (name)\n\t\tinfo = spi_nor_match_name(nor, name);\n\t \n\tif (!info)\n\t\treturn spi_nor_detect(nor);\n\n\t \n\tif (name && info->id_len) {\n\t\tconst struct flash_info *jinfo;\n\n\t\tjinfo = spi_nor_detect(nor);\n\t\tif (IS_ERR(jinfo)) {\n\t\t\treturn jinfo;\n\t\t} else if (jinfo != info) {\n\t\t\t \n\t\t\tdev_warn(nor->dev, \"found %s, expected %s\\n\",\n\t\t\t\t jinfo->name, info->name);\n\t\t\tinfo = jinfo;\n\t\t}\n\t}\n\n\treturn info;\n}\n\nstatic void spi_nor_set_mtd_info(struct spi_nor *nor)\n{\n\tstruct mtd_info *mtd = &nor->mtd;\n\tstruct device *dev = nor->dev;\n\n\tspi_nor_set_mtd_locking_ops(nor);\n\tspi_nor_set_mtd_otp_ops(nor);\n\n\tmtd->dev.parent = dev;\n\tif (!mtd->name)\n\t\tmtd->name = dev_name(dev);\n\tmtd->type = MTD_NORFLASH;\n\tmtd->flags = MTD_CAP_NORFLASH;\n\t \n\tif (nor->flags & SNOR_F_ECC)\n\t\tmtd->flags &= ~MTD_BIT_WRITEABLE;\n\tif (nor->info->flags & SPI_NOR_NO_ERASE)\n\t\tmtd->flags |= MTD_NO_ERASE;\n\telse\n\t\tmtd->_erase = spi_nor_erase;\n\tmtd->writesize = nor->params->writesize;\n\tmtd->writebufsize = nor->params->page_size;\n\tmtd->size = nor->params->size;\n\tmtd->_read = spi_nor_read;\n\t \n\tif (!mtd->_write)\n\t\tmtd->_write = spi_nor_write;\n\tmtd->_suspend = spi_nor_suspend;\n\tmtd->_resume = spi_nor_resume;\n\tmtd->_get_device = spi_nor_get_device;\n\tmtd->_put_device = spi_nor_put_device;\n}\n\nstatic int spi_nor_hw_reset(struct spi_nor *nor)\n{\n\tstruct gpio_desc *reset;\n\n\treset = devm_gpiod_get_optional(nor->dev, \"reset\", GPIOD_OUT_LOW);\n\tif (IS_ERR_OR_NULL(reset))\n\t\treturn PTR_ERR_OR_ZERO(reset);\n\n\t \n\tusleep_range(1, 5);\n\tgpiod_set_value_cansleep(reset, 1);\n\tusleep_range(100, 150);\n\tgpiod_set_value_cansleep(reset, 0);\n\tusleep_range(1000, 1200);\n\n\treturn 0;\n}\n\nint spi_nor_scan(struct spi_nor *nor, const char *name,\n\t\t const struct spi_nor_hwcaps *hwcaps)\n{\n\tconst struct flash_info *info;\n\tstruct device *dev = nor->dev;\n\tstruct mtd_info *mtd = &nor->mtd;\n\tint ret;\n\tint i;\n\n\tret = spi_nor_check(nor);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tnor->reg_proto = SNOR_PROTO_1_1_1;\n\tnor->read_proto = SNOR_PROTO_1_1_1;\n\tnor->write_proto = SNOR_PROTO_1_1_1;\n\n\t \n\tnor->bouncebuf_size = PAGE_SIZE;\n\tnor->bouncebuf = devm_kmalloc(dev, nor->bouncebuf_size,\n\t\t\t\t      GFP_KERNEL);\n\tif (!nor->bouncebuf)\n\t\treturn -ENOMEM;\n\n\tret = spi_nor_hw_reset(nor);\n\tif (ret)\n\t\treturn ret;\n\n\tinfo = spi_nor_get_flash_info(nor, name);\n\tif (IS_ERR(info))\n\t\treturn PTR_ERR(info);\n\n\tnor->info = info;\n\n\tmutex_init(&nor->lock);\n\n\t \n\tret = spi_nor_init_params(nor);\n\tif (ret)\n\t\treturn ret;\n\n\tif (spi_nor_use_parallel_locking(nor))\n\t\tinit_waitqueue_head(&nor->rww.wait);\n\n\t \n\tret = spi_nor_setup(nor, hwcaps);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = spi_nor_init(nor);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tspi_nor_set_mtd_info(nor);\n\n\tdev_info(dev, \"%s (%lld Kbytes)\\n\", info->name,\n\t\t\t(long long)mtd->size >> 10);\n\n\tdev_dbg(dev,\n\t\t\"mtd .name = %s, .size = 0x%llx (%lldMiB), \"\n\t\t\".erasesize = 0x%.8x (%uKiB) .numeraseregions = %d\\n\",\n\t\tmtd->name, (long long)mtd->size, (long long)(mtd->size >> 20),\n\t\tmtd->erasesize, mtd->erasesize / 1024, mtd->numeraseregions);\n\n\tif (mtd->numeraseregions)\n\t\tfor (i = 0; i < mtd->numeraseregions; i++)\n\t\t\tdev_dbg(dev,\n\t\t\t\t\"mtd.eraseregions[%d] = { .offset = 0x%llx, \"\n\t\t\t\t\".erasesize = 0x%.8x (%uKiB), \"\n\t\t\t\t\".numblocks = %d }\\n\",\n\t\t\t\ti, (long long)mtd->eraseregions[i].offset,\n\t\t\t\tmtd->eraseregions[i].erasesize,\n\t\t\t\tmtd->eraseregions[i].erasesize / 1024,\n\t\t\t\tmtd->eraseregions[i].numblocks);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(spi_nor_scan);\n\nstatic int spi_nor_create_read_dirmap(struct spi_nor *nor)\n{\n\tstruct spi_mem_dirmap_info info = {\n\t\t.op_tmpl = SPI_MEM_OP(SPI_MEM_OP_CMD(nor->read_opcode, 0),\n\t\t\t\t      SPI_MEM_OP_ADDR(nor->addr_nbytes, 0, 0),\n\t\t\t\t      SPI_MEM_OP_DUMMY(nor->read_dummy, 0),\n\t\t\t\t      SPI_MEM_OP_DATA_IN(0, NULL, 0)),\n\t\t.offset = 0,\n\t\t.length = nor->params->size,\n\t};\n\tstruct spi_mem_op *op = &info.op_tmpl;\n\n\tspi_nor_spimem_setup_op(nor, op, nor->read_proto);\n\n\t \n\top->dummy.nbytes = (nor->read_dummy * op->dummy.buswidth) / 8;\n\tif (spi_nor_protocol_is_dtr(nor->read_proto))\n\t\top->dummy.nbytes *= 2;\n\n\t \n\top->data.buswidth = spi_nor_get_protocol_data_nbits(nor->read_proto);\n\n\tnor->dirmap.rdesc = devm_spi_mem_dirmap_create(nor->dev, nor->spimem,\n\t\t\t\t\t\t       &info);\n\treturn PTR_ERR_OR_ZERO(nor->dirmap.rdesc);\n}\n\nstatic int spi_nor_create_write_dirmap(struct spi_nor *nor)\n{\n\tstruct spi_mem_dirmap_info info = {\n\t\t.op_tmpl = SPI_MEM_OP(SPI_MEM_OP_CMD(nor->program_opcode, 0),\n\t\t\t\t      SPI_MEM_OP_ADDR(nor->addr_nbytes, 0, 0),\n\t\t\t\t      SPI_MEM_OP_NO_DUMMY,\n\t\t\t\t      SPI_MEM_OP_DATA_OUT(0, NULL, 0)),\n\t\t.offset = 0,\n\t\t.length = nor->params->size,\n\t};\n\tstruct spi_mem_op *op = &info.op_tmpl;\n\n\tif (nor->program_opcode == SPINOR_OP_AAI_WP && nor->sst_write_second)\n\t\top->addr.nbytes = 0;\n\n\tspi_nor_spimem_setup_op(nor, op, nor->write_proto);\n\n\t \n\top->data.buswidth = spi_nor_get_protocol_data_nbits(nor->write_proto);\n\n\tnor->dirmap.wdesc = devm_spi_mem_dirmap_create(nor->dev, nor->spimem,\n\t\t\t\t\t\t       &info);\n\treturn PTR_ERR_OR_ZERO(nor->dirmap.wdesc);\n}\n\nstatic int spi_nor_probe(struct spi_mem *spimem)\n{\n\tstruct spi_device *spi = spimem->spi;\n\tstruct flash_platform_data *data = dev_get_platdata(&spi->dev);\n\tstruct spi_nor *nor;\n\t \n\tconst struct spi_nor_hwcaps hwcaps = { .mask = SNOR_HWCAPS_ALL };\n\tchar *flash_name;\n\tint ret;\n\n\tnor = devm_kzalloc(&spi->dev, sizeof(*nor), GFP_KERNEL);\n\tif (!nor)\n\t\treturn -ENOMEM;\n\n\tnor->spimem = spimem;\n\tnor->dev = &spi->dev;\n\tspi_nor_set_flash_node(nor, spi->dev.of_node);\n\n\tspi_mem_set_drvdata(spimem, nor);\n\n\tif (data && data->name)\n\t\tnor->mtd.name = data->name;\n\n\tif (!nor->mtd.name)\n\t\tnor->mtd.name = spi_mem_get_name(spimem);\n\n\t \n\tif (data && data->type)\n\t\tflash_name = data->type;\n\telse if (!strcmp(spi->modalias, \"spi-nor\"))\n\t\tflash_name = NULL;  \n\telse\n\t\tflash_name = spi->modalias;\n\n\tret = spi_nor_scan(nor, flash_name, &hwcaps);\n\tif (ret)\n\t\treturn ret;\n\n\tspi_nor_debugfs_register(nor);\n\n\t \n\tif (nor->params->page_size > PAGE_SIZE) {\n\t\tnor->bouncebuf_size = nor->params->page_size;\n\t\tdevm_kfree(nor->dev, nor->bouncebuf);\n\t\tnor->bouncebuf = devm_kmalloc(nor->dev,\n\t\t\t\t\t      nor->bouncebuf_size,\n\t\t\t\t\t      GFP_KERNEL);\n\t\tif (!nor->bouncebuf)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tret = spi_nor_create_read_dirmap(nor);\n\tif (ret)\n\t\treturn ret;\n\n\tret = spi_nor_create_write_dirmap(nor);\n\tif (ret)\n\t\treturn ret;\n\n\treturn mtd_device_register(&nor->mtd, data ? data->parts : NULL,\n\t\t\t\t   data ? data->nr_parts : 0);\n}\n\nstatic int spi_nor_remove(struct spi_mem *spimem)\n{\n\tstruct spi_nor *nor = spi_mem_get_drvdata(spimem);\n\n\tspi_nor_restore(nor);\n\n\t \n\treturn mtd_device_unregister(&nor->mtd);\n}\n\nstatic void spi_nor_shutdown(struct spi_mem *spimem)\n{\n\tstruct spi_nor *nor = spi_mem_get_drvdata(spimem);\n\n\tspi_nor_restore(nor);\n}\n\n \nstatic const struct spi_device_id spi_nor_dev_ids[] = {\n\t \n\t{\"spi-nor\"},\n\n\t \n\t{\"s25sl064a\"},\t{\"w25x16\"},\t{\"m25p10\"},\t{\"m25px64\"},\n\n\t \n\t{\"at25df321a\"},\t{\"at25df641\"},\t{\"at26df081a\"},\n\t{\"mx25l4005a\"},\t{\"mx25l1606e\"},\t{\"mx25l6405d\"},\t{\"mx25l12805d\"},\n\t{\"mx25l25635e\"},{\"mx66l51235l\"},\n\t{\"n25q064\"},\t{\"n25q128a11\"},\t{\"n25q128a13\"},\t{\"n25q512a\"},\n\t{\"s25fl256s1\"},\t{\"s25fl512s\"},\t{\"s25sl12801\"},\t{\"s25fl008k\"},\n\t{\"s25fl064k\"},\n\t{\"sst25vf040b\"},{\"sst25vf016b\"},{\"sst25vf032b\"},{\"sst25wf040\"},\n\t{\"m25p40\"},\t{\"m25p80\"},\t{\"m25p16\"},\t{\"m25p32\"},\n\t{\"m25p64\"},\t{\"m25p128\"},\n\t{\"w25x80\"},\t{\"w25x32\"},\t{\"w25q32\"},\t{\"w25q32dw\"},\n\t{\"w25q80bl\"},\t{\"w25q128\"},\t{\"w25q256\"},\n\n\t \n\t{\"m25p05-nonjedec\"},\t{\"m25p10-nonjedec\"},\t{\"m25p20-nonjedec\"},\n\t{\"m25p40-nonjedec\"},\t{\"m25p80-nonjedec\"},\t{\"m25p16-nonjedec\"},\n\t{\"m25p32-nonjedec\"},\t{\"m25p64-nonjedec\"},\t{\"m25p128-nonjedec\"},\n\n\t \n\t{ \"mr25h128\" },  \n\t{ \"mr25h256\" },  \n\t{ \"mr25h10\" },   \n\t{ \"mr25h40\" },   \n\n\t{ },\n};\nMODULE_DEVICE_TABLE(spi, spi_nor_dev_ids);\n\nstatic const struct of_device_id spi_nor_of_table[] = {\n\t \n\t{ .compatible = \"jedec,spi-nor\" },\n\t{   },\n};\nMODULE_DEVICE_TABLE(of, spi_nor_of_table);\n\n \nstatic struct spi_mem_driver spi_nor_driver = {\n\t.spidrv = {\n\t\t.driver = {\n\t\t\t.name = \"spi-nor\",\n\t\t\t.of_match_table = spi_nor_of_table,\n\t\t\t.dev_groups = spi_nor_sysfs_groups,\n\t\t},\n\t\t.id_table = spi_nor_dev_ids,\n\t},\n\t.probe = spi_nor_probe,\n\t.remove = spi_nor_remove,\n\t.shutdown = spi_nor_shutdown,\n};\n\nstatic int __init spi_nor_module_init(void)\n{\n\treturn spi_mem_driver_register(&spi_nor_driver);\n}\nmodule_init(spi_nor_module_init);\n\nstatic void __exit spi_nor_module_exit(void)\n{\n\tspi_mem_driver_unregister(&spi_nor_driver);\n\tspi_nor_debugfs_shutdown();\n}\nmodule_exit(spi_nor_module_exit);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Huang Shijie <shijie8@gmail.com>\");\nMODULE_AUTHOR(\"Mike Lavender\");\nMODULE_DESCRIPTION(\"framework for SPI NOR\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}