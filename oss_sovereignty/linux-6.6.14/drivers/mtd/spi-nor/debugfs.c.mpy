{
  "module_name": "debugfs.c",
  "hash_id": "592f9c293f4ce8418575f1d895dc5aa0a496f7f858ba1ca4d85b615ea3b72d34",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/spi-nor/debugfs.c",
  "human_readable_source": "\n\n#include <linux/debugfs.h>\n#include <linux/mtd/spi-nor.h>\n#include <linux/spi/spi.h>\n#include <linux/spi/spi-mem.h>\n\n#include \"core.h\"\n\n#define SPI_NOR_DEBUGFS_ROOT \"spi-nor\"\n\n#define SNOR_F_NAME(name) [ilog2(SNOR_F_##name)] = #name\nstatic const char *const snor_f_names[] = {\n\tSNOR_F_NAME(HAS_SR_TB),\n\tSNOR_F_NAME(NO_OP_CHIP_ERASE),\n\tSNOR_F_NAME(BROKEN_RESET),\n\tSNOR_F_NAME(4B_OPCODES),\n\tSNOR_F_NAME(HAS_4BAIT),\n\tSNOR_F_NAME(HAS_LOCK),\n\tSNOR_F_NAME(HAS_16BIT_SR),\n\tSNOR_F_NAME(NO_READ_CR),\n\tSNOR_F_NAME(HAS_SR_TB_BIT6),\n\tSNOR_F_NAME(HAS_4BIT_BP),\n\tSNOR_F_NAME(HAS_SR_BP3_BIT6),\n\tSNOR_F_NAME(IO_MODE_EN_VOLATILE),\n\tSNOR_F_NAME(SOFT_RESET),\n\tSNOR_F_NAME(SWP_IS_VOLATILE),\n\tSNOR_F_NAME(RWW),\n\tSNOR_F_NAME(ECC),\n\tSNOR_F_NAME(NO_WP),\n};\n#undef SNOR_F_NAME\n\nstatic const char *spi_nor_protocol_name(enum spi_nor_protocol proto)\n{\n\tswitch (proto) {\n\tcase SNOR_PROTO_1_1_1:     return \"1S-1S-1S\";\n\tcase SNOR_PROTO_1_1_2:     return \"1S-1S-2S\";\n\tcase SNOR_PROTO_1_1_4:     return \"1S-1S-4S\";\n\tcase SNOR_PROTO_1_1_8:     return \"1S-1S-8S\";\n\tcase SNOR_PROTO_1_2_2:     return \"1S-2S-2S\";\n\tcase SNOR_PROTO_1_4_4:     return \"1S-4S-4S\";\n\tcase SNOR_PROTO_1_8_8:     return \"1S-8S-8S\";\n\tcase SNOR_PROTO_2_2_2:     return \"2S-2S-2S\";\n\tcase SNOR_PROTO_4_4_4:     return \"4S-4S-4S\";\n\tcase SNOR_PROTO_8_8_8:     return \"8S-8S-8S\";\n\tcase SNOR_PROTO_1_1_1_DTR: return \"1D-1D-1D\";\n\tcase SNOR_PROTO_1_2_2_DTR: return \"1D-2D-2D\";\n\tcase SNOR_PROTO_1_4_4_DTR: return \"1D-4D-4D\";\n\tcase SNOR_PROTO_1_8_8_DTR: return \"1D-8D-8D\";\n\tcase SNOR_PROTO_8_8_8_DTR: return \"8D-8D-8D\";\n\t}\n\n\treturn \"<unknown>\";\n}\n\nstatic void spi_nor_print_flags(struct seq_file *s, unsigned long flags,\n\t\t\t\tconst char *const *names, int names_len)\n{\n\tbool sep = false;\n\tint i;\n\n\tfor (i = 0; i < sizeof(flags) * BITS_PER_BYTE; i++) {\n\t\tif (!(flags & BIT(i)))\n\t\t\tcontinue;\n\t\tif (sep)\n\t\t\tseq_puts(s, \" | \");\n\t\tsep = true;\n\t\tif (i < names_len && names[i])\n\t\t\tseq_puts(s, names[i]);\n\t\telse\n\t\t\tseq_printf(s, \"1<<%d\", i);\n\t}\n}\n\nstatic int spi_nor_params_show(struct seq_file *s, void *data)\n{\n\tstruct spi_nor *nor = s->private;\n\tstruct spi_nor_flash_parameter *params = nor->params;\n\tstruct spi_nor_erase_map *erase_map = &params->erase_map;\n\tstruct spi_nor_erase_region *region;\n\tconst struct flash_info *info = nor->info;\n\tchar buf[16], *str;\n\tint i;\n\n\tseq_printf(s, \"name\\t\\t%s\\n\", info->name);\n\tseq_printf(s, \"id\\t\\t%*ph\\n\", SPI_NOR_MAX_ID_LEN, nor->id);\n\tstring_get_size(params->size, 1, STRING_UNITS_2, buf, sizeof(buf));\n\tseq_printf(s, \"size\\t\\t%s\\n\", buf);\n\tseq_printf(s, \"write size\\t%u\\n\", params->writesize);\n\tseq_printf(s, \"page size\\t%u\\n\", params->page_size);\n\tseq_printf(s, \"address nbytes\\t%u\\n\", nor->addr_nbytes);\n\n\tseq_puts(s, \"flags\\t\\t\");\n\tspi_nor_print_flags(s, nor->flags, snor_f_names, sizeof(snor_f_names));\n\tseq_puts(s, \"\\n\");\n\n\tseq_puts(s, \"\\nopcodes\\n\");\n\tseq_printf(s, \" read\\t\\t0x%02x\\n\", nor->read_opcode);\n\tseq_printf(s, \"  dummy cycles\\t%u\\n\", nor->read_dummy);\n\tseq_printf(s, \" erase\\t\\t0x%02x\\n\", nor->erase_opcode);\n\tseq_printf(s, \" program\\t0x%02x\\n\", nor->program_opcode);\n\n\tswitch (nor->cmd_ext_type) {\n\tcase SPI_NOR_EXT_NONE:\n\t\tstr = \"none\";\n\t\tbreak;\n\tcase SPI_NOR_EXT_REPEAT:\n\t\tstr = \"repeat\";\n\t\tbreak;\n\tcase SPI_NOR_EXT_INVERT:\n\t\tstr = \"invert\";\n\t\tbreak;\n\tdefault:\n\t\tstr = \"<unknown>\";\n\t\tbreak;\n\t}\n\tseq_printf(s, \" 8D extension\\t%s\\n\", str);\n\n\tseq_puts(s, \"\\nprotocols\\n\");\n\tseq_printf(s, \" read\\t\\t%s\\n\",\n\t\t   spi_nor_protocol_name(nor->read_proto));\n\tseq_printf(s, \" write\\t\\t%s\\n\",\n\t\t   spi_nor_protocol_name(nor->write_proto));\n\tseq_printf(s, \" register\\t%s\\n\",\n\t\t   spi_nor_protocol_name(nor->reg_proto));\n\n\tseq_puts(s, \"\\nerase commands\\n\");\n\tfor (i = 0; i < SNOR_ERASE_TYPE_MAX; i++) {\n\t\tstruct spi_nor_erase_type *et = &erase_map->erase_type[i];\n\n\t\tif (et->size) {\n\t\t\tstring_get_size(et->size, 1, STRING_UNITS_2, buf,\n\t\t\t\t\tsizeof(buf));\n\t\t\tseq_printf(s, \" %02x (%s) [%d]\\n\", et->opcode, buf, i);\n\t\t}\n\t}\n\n\tif (!(nor->flags & SNOR_F_NO_OP_CHIP_ERASE)) {\n\t\tstring_get_size(params->size, 1, STRING_UNITS_2, buf, sizeof(buf));\n\t\tseq_printf(s, \" %02x (%s)\\n\", SPINOR_OP_CHIP_ERASE, buf);\n\t}\n\n\tseq_puts(s, \"\\nsector map\\n\");\n\tseq_puts(s, \" region (in hex)   | erase mask | flags\\n\");\n\tseq_puts(s, \" ------------------+------------+----------\\n\");\n\tfor (region = erase_map->regions;\n\t     region;\n\t     region = spi_nor_region_next(region)) {\n\t\tu64 start = region->offset & ~SNOR_ERASE_FLAGS_MASK;\n\t\tu64 flags = region->offset & SNOR_ERASE_FLAGS_MASK;\n\t\tu64 end = start + region->size - 1;\n\n\t\tseq_printf(s, \" %08llx-%08llx |     [%c%c%c%c] | %s\\n\",\n\t\t\t   start, end,\n\t\t\t   flags & BIT(0) ? '0' : ' ',\n\t\t\t   flags & BIT(1) ? '1' : ' ',\n\t\t\t   flags & BIT(2) ? '2' : ' ',\n\t\t\t   flags & BIT(3) ? '3' : ' ',\n\t\t\t   flags & SNOR_OVERLAID_REGION ? \"overlaid\" : \"\");\n\t}\n\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(spi_nor_params);\n\nstatic void spi_nor_print_read_cmd(struct seq_file *s, u32 cap,\n\t\t\t\t   struct spi_nor_read_command *cmd)\n{\n\tseq_printf(s, \" %s%s\\n\", spi_nor_protocol_name(cmd->proto),\n\t\t   cap == SNOR_HWCAPS_READ_FAST ? \" (fast read)\" : \"\");\n\tseq_printf(s, \"  opcode\\t0x%02x\\n\", cmd->opcode);\n\tseq_printf(s, \"  mode cycles\\t%u\\n\", cmd->num_mode_clocks);\n\tseq_printf(s, \"  dummy cycles\\t%u\\n\", cmd->num_wait_states);\n}\n\nstatic void spi_nor_print_pp_cmd(struct seq_file *s,\n\t\t\t\t struct spi_nor_pp_command *cmd)\n{\n\tseq_printf(s, \" %s\\n\", spi_nor_protocol_name(cmd->proto));\n\tseq_printf(s, \"  opcode\\t0x%02x\\n\", cmd->opcode);\n}\n\nstatic int spi_nor_capabilities_show(struct seq_file *s, void *data)\n{\n\tstruct spi_nor *nor = s->private;\n\tstruct spi_nor_flash_parameter *params = nor->params;\n\tu32 hwcaps = params->hwcaps.mask;\n\tint i, cmd;\n\n\tseq_puts(s, \"Supported read modes by the flash\\n\");\n\tfor (i = 0; i < sizeof(hwcaps) * BITS_PER_BYTE; i++) {\n\t\tif (!(hwcaps & BIT(i)))\n\t\t\tcontinue;\n\n\t\tcmd = spi_nor_hwcaps_read2cmd(BIT(i));\n\t\tif (cmd < 0)\n\t\t\tcontinue;\n\n\t\tspi_nor_print_read_cmd(s, BIT(i), &params->reads[cmd]);\n\t\thwcaps &= ~BIT(i);\n\t}\n\n\tseq_puts(s, \"\\nSupported page program modes by the flash\\n\");\n\tfor (i = 0; i < sizeof(hwcaps) * BITS_PER_BYTE; i++) {\n\t\tif (!(hwcaps & BIT(i)))\n\t\t\tcontinue;\n\n\t\tcmd = spi_nor_hwcaps_pp2cmd(BIT(i));\n\t\tif (cmd < 0)\n\t\t\tcontinue;\n\n\t\tspi_nor_print_pp_cmd(s, &params->page_programs[cmd]);\n\t\thwcaps &= ~BIT(i);\n\t}\n\n\tif (hwcaps)\n\t\tseq_printf(s, \"\\nunknown hwcaps 0x%x\\n\", hwcaps);\n\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(spi_nor_capabilities);\n\nstatic void spi_nor_debugfs_unregister(void *data)\n{\n\tstruct spi_nor *nor = data;\n\n\tdebugfs_remove(nor->debugfs_root);\n\tnor->debugfs_root = NULL;\n}\n\nstatic struct dentry *rootdir;\n\nvoid spi_nor_debugfs_register(struct spi_nor *nor)\n{\n\tstruct dentry *d;\n\tint ret;\n\n\tif (!rootdir)\n\t\trootdir = debugfs_create_dir(SPI_NOR_DEBUGFS_ROOT, NULL);\n\n\tret = devm_add_action(nor->dev, spi_nor_debugfs_unregister, nor);\n\tif (ret)\n\t\treturn;\n\n\td = debugfs_create_dir(dev_name(nor->dev), rootdir);\n\tnor->debugfs_root = d;\n\n\tdebugfs_create_file(\"params\", 0444, d, nor, &spi_nor_params_fops);\n\tdebugfs_create_file(\"capabilities\", 0444, d, nor,\n\t\t\t    &spi_nor_capabilities_fops);\n}\n\nvoid spi_nor_debugfs_shutdown(void)\n{\n\tdebugfs_remove(rootdir);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}