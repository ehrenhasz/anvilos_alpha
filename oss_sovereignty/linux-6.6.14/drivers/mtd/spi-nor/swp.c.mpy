{
  "module_name": "swp.c",
  "hash_id": "caf27a9b0f8abdd973f2fb1d3adc4e26b6771ce8456c7551502faae3b52ced43",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/spi-nor/swp.c",
  "human_readable_source": "\n \n#include <linux/mtd/mtd.h>\n#include <linux/mtd/spi-nor.h>\n\n#include \"core.h\"\n\nstatic u8 spi_nor_get_sr_bp_mask(struct spi_nor *nor)\n{\n\tu8 mask = SR_BP2 | SR_BP1 | SR_BP0;\n\n\tif (nor->flags & SNOR_F_HAS_SR_BP3_BIT6)\n\t\treturn mask | SR_BP3_BIT6;\n\n\tif (nor->flags & SNOR_F_HAS_4BIT_BP)\n\t\treturn mask | SR_BP3;\n\n\treturn mask;\n}\n\nstatic u8 spi_nor_get_sr_tb_mask(struct spi_nor *nor)\n{\n\tif (nor->flags & SNOR_F_HAS_SR_TB_BIT6)\n\t\treturn SR_TB_BIT6;\n\telse\n\t\treturn SR_TB_BIT5;\n}\n\nstatic u64 spi_nor_get_min_prot_length_sr(struct spi_nor *nor)\n{\n\tunsigned int bp_slots, bp_slots_needed;\n\tu8 mask = spi_nor_get_sr_bp_mask(nor);\n\n\t \n\tbp_slots = (1 << hweight8(mask)) - 2;\n\tbp_slots_needed = ilog2(nor->info->n_sectors);\n\n\tif (bp_slots_needed > bp_slots)\n\t\treturn nor->info->sector_size <<\n\t\t\t(bp_slots_needed - bp_slots);\n\telse\n\t\treturn nor->info->sector_size;\n}\n\nstatic void spi_nor_get_locked_range_sr(struct spi_nor *nor, u8 sr, loff_t *ofs,\n\t\t\t\t\tuint64_t *len)\n{\n\tstruct mtd_info *mtd = &nor->mtd;\n\tu64 min_prot_len;\n\tu8 mask = spi_nor_get_sr_bp_mask(nor);\n\tu8 tb_mask = spi_nor_get_sr_tb_mask(nor);\n\tu8 bp, val = sr & mask;\n\n\tif (nor->flags & SNOR_F_HAS_SR_BP3_BIT6 && val & SR_BP3_BIT6)\n\t\tval = (val & ~SR_BP3_BIT6) | SR_BP3;\n\n\tbp = val >> SR_BP_SHIFT;\n\n\tif (!bp) {\n\t\t \n\t\t*ofs = 0;\n\t\t*len = 0;\n\t\treturn;\n\t}\n\n\tmin_prot_len = spi_nor_get_min_prot_length_sr(nor);\n\t*len = min_prot_len << (bp - 1);\n\n\tif (*len > mtd->size)\n\t\t*len = mtd->size;\n\n\tif (nor->flags & SNOR_F_HAS_SR_TB && sr & tb_mask)\n\t\t*ofs = 0;\n\telse\n\t\t*ofs = mtd->size - *len;\n}\n\n \nstatic bool spi_nor_check_lock_status_sr(struct spi_nor *nor, loff_t ofs,\n\t\t\t\t\t uint64_t len, u8 sr, bool locked)\n{\n\tloff_t lock_offs, lock_offs_max, offs_max;\n\tuint64_t lock_len;\n\n\tif (!len)\n\t\treturn true;\n\n\tspi_nor_get_locked_range_sr(nor, sr, &lock_offs, &lock_len);\n\n\tlock_offs_max = lock_offs + lock_len;\n\toffs_max = ofs + len;\n\n\tif (locked)\n\t\t \n\t\treturn (offs_max <= lock_offs_max) && (ofs >= lock_offs);\n\telse\n\t\t \n\t\treturn (ofs >= lock_offs_max) || (offs_max <= lock_offs);\n}\n\nstatic bool spi_nor_is_locked_sr(struct spi_nor *nor, loff_t ofs, uint64_t len,\n\t\t\t\t u8 sr)\n{\n\treturn spi_nor_check_lock_status_sr(nor, ofs, len, sr, true);\n}\n\nstatic bool spi_nor_is_unlocked_sr(struct spi_nor *nor, loff_t ofs,\n\t\t\t\t   uint64_t len, u8 sr)\n{\n\treturn spi_nor_check_lock_status_sr(nor, ofs, len, sr, false);\n}\n\n \nstatic int spi_nor_sr_lock(struct spi_nor *nor, loff_t ofs, uint64_t len)\n{\n\tstruct mtd_info *mtd = &nor->mtd;\n\tu64 min_prot_len;\n\tint ret, status_old, status_new;\n\tu8 mask = spi_nor_get_sr_bp_mask(nor);\n\tu8 tb_mask = spi_nor_get_sr_tb_mask(nor);\n\tu8 pow, val;\n\tloff_t lock_len;\n\tbool can_be_top = true, can_be_bottom = nor->flags & SNOR_F_HAS_SR_TB;\n\tbool use_top;\n\n\tret = spi_nor_read_sr(nor, nor->bouncebuf);\n\tif (ret)\n\t\treturn ret;\n\n\tstatus_old = nor->bouncebuf[0];\n\n\t \n\tif (spi_nor_is_locked_sr(nor, ofs, len, status_old))\n\t\treturn 0;\n\n\t \n\tif (!spi_nor_is_locked_sr(nor, 0, ofs, status_old))\n\t\tcan_be_bottom = false;\n\n\t \n\tif (!spi_nor_is_locked_sr(nor, ofs + len, mtd->size - (ofs + len),\n\t\t\t\t  status_old))\n\t\tcan_be_top = false;\n\n\tif (!can_be_bottom && !can_be_top)\n\t\treturn -EINVAL;\n\n\t \n\tuse_top = can_be_top;\n\n\t \n\tif (use_top)\n\t\tlock_len = mtd->size - ofs;\n\telse\n\t\tlock_len = ofs + len;\n\n\tif (lock_len == mtd->size) {\n\t\tval = mask;\n\t} else {\n\t\tmin_prot_len = spi_nor_get_min_prot_length_sr(nor);\n\t\tpow = ilog2(lock_len) - ilog2(min_prot_len) + 1;\n\t\tval = pow << SR_BP_SHIFT;\n\n\t\tif (nor->flags & SNOR_F_HAS_SR_BP3_BIT6 && val & SR_BP3)\n\t\t\tval = (val & ~SR_BP3) | SR_BP3_BIT6;\n\n\t\tif (val & ~mask)\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\tif (!(val & mask))\n\t\t\treturn -EINVAL;\n\t}\n\n\tstatus_new = (status_old & ~mask & ~tb_mask) | val;\n\n\t \n\tif (!(nor->flags & SNOR_F_NO_WP))\n\t\tstatus_new |= SR_SRWD;\n\n\tif (!use_top)\n\t\tstatus_new |= tb_mask;\n\n\t \n\tif (status_new == status_old)\n\t\treturn 0;\n\n\t \n\tif ((status_new & mask) < (status_old & mask))\n\t\treturn -EINVAL;\n\n\treturn spi_nor_write_sr_and_check(nor, status_new);\n}\n\n \nstatic int spi_nor_sr_unlock(struct spi_nor *nor, loff_t ofs, uint64_t len)\n{\n\tstruct mtd_info *mtd = &nor->mtd;\n\tu64 min_prot_len;\n\tint ret, status_old, status_new;\n\tu8 mask = spi_nor_get_sr_bp_mask(nor);\n\tu8 tb_mask = spi_nor_get_sr_tb_mask(nor);\n\tu8 pow, val;\n\tloff_t lock_len;\n\tbool can_be_top = true, can_be_bottom = nor->flags & SNOR_F_HAS_SR_TB;\n\tbool use_top;\n\n\tret = spi_nor_read_sr(nor, nor->bouncebuf);\n\tif (ret)\n\t\treturn ret;\n\n\tstatus_old = nor->bouncebuf[0];\n\n\t \n\tif (spi_nor_is_unlocked_sr(nor, ofs, len, status_old))\n\t\treturn 0;\n\n\t \n\tif (!spi_nor_is_unlocked_sr(nor, 0, ofs, status_old))\n\t\tcan_be_top = false;\n\n\t \n\tif (!spi_nor_is_unlocked_sr(nor, ofs + len, mtd->size - (ofs + len),\n\t\t\t\t    status_old))\n\t\tcan_be_bottom = false;\n\n\tif (!can_be_bottom && !can_be_top)\n\t\treturn -EINVAL;\n\n\t \n\tuse_top = can_be_top;\n\n\t \n\tif (use_top)\n\t\tlock_len = mtd->size - (ofs + len);\n\telse\n\t\tlock_len = ofs;\n\n\tif (lock_len == 0) {\n\t\tval = 0;  \n\t} else {\n\t\tmin_prot_len = spi_nor_get_min_prot_length_sr(nor);\n\t\tpow = ilog2(lock_len) - ilog2(min_prot_len) + 1;\n\t\tval = pow << SR_BP_SHIFT;\n\n\t\tif (nor->flags & SNOR_F_HAS_SR_BP3_BIT6 && val & SR_BP3)\n\t\t\tval = (val & ~SR_BP3) | SR_BP3_BIT6;\n\n\t\t \n\t\tif (val & ~mask)\n\t\t\treturn -EINVAL;\n\t}\n\n\tstatus_new = (status_old & ~mask & ~tb_mask) | val;\n\n\t \n\tif (lock_len == 0)\n\t\tstatus_new &= ~SR_SRWD;\n\n\tif (!use_top)\n\t\tstatus_new |= tb_mask;\n\n\t \n\tif (status_new == status_old)\n\t\treturn 0;\n\n\t \n\tif ((status_new & mask) > (status_old & mask))\n\t\treturn -EINVAL;\n\n\treturn spi_nor_write_sr_and_check(nor, status_new);\n}\n\n \nstatic int spi_nor_sr_is_locked(struct spi_nor *nor, loff_t ofs, uint64_t len)\n{\n\tint ret;\n\n\tret = spi_nor_read_sr(nor, nor->bouncebuf);\n\tif (ret)\n\t\treturn ret;\n\n\treturn spi_nor_is_locked_sr(nor, ofs, len, nor->bouncebuf[0]);\n}\n\nstatic const struct spi_nor_locking_ops spi_nor_sr_locking_ops = {\n\t.lock = spi_nor_sr_lock,\n\t.unlock = spi_nor_sr_unlock,\n\t.is_locked = spi_nor_sr_is_locked,\n};\n\nvoid spi_nor_init_default_locking_ops(struct spi_nor *nor)\n{\n\tnor->params->locking_ops = &spi_nor_sr_locking_ops;\n}\n\nstatic int spi_nor_lock(struct mtd_info *mtd, loff_t ofs, uint64_t len)\n{\n\tstruct spi_nor *nor = mtd_to_spi_nor(mtd);\n\tint ret;\n\n\tret = spi_nor_prep_and_lock(nor);\n\tif (ret)\n\t\treturn ret;\n\n\tret = nor->params->locking_ops->lock(nor, ofs, len);\n\n\tspi_nor_unlock_and_unprep(nor);\n\treturn ret;\n}\n\nstatic int spi_nor_unlock(struct mtd_info *mtd, loff_t ofs, uint64_t len)\n{\n\tstruct spi_nor *nor = mtd_to_spi_nor(mtd);\n\tint ret;\n\n\tret = spi_nor_prep_and_lock(nor);\n\tif (ret)\n\t\treturn ret;\n\n\tret = nor->params->locking_ops->unlock(nor, ofs, len);\n\n\tspi_nor_unlock_and_unprep(nor);\n\treturn ret;\n}\n\nstatic int spi_nor_is_locked(struct mtd_info *mtd, loff_t ofs, uint64_t len)\n{\n\tstruct spi_nor *nor = mtd_to_spi_nor(mtd);\n\tint ret;\n\n\tret = spi_nor_prep_and_lock(nor);\n\tif (ret)\n\t\treturn ret;\n\n\tret = nor->params->locking_ops->is_locked(nor, ofs, len);\n\n\tspi_nor_unlock_and_unprep(nor);\n\treturn ret;\n}\n\n \nvoid spi_nor_try_unlock_all(struct spi_nor *nor)\n{\n\tint ret;\n\n\tif (!(nor->flags & SNOR_F_HAS_LOCK))\n\t\treturn;\n\n\tdev_dbg(nor->dev, \"Unprotecting entire flash array\\n\");\n\n\tret = spi_nor_unlock(&nor->mtd, 0, nor->params->size);\n\tif (ret)\n\t\tdev_dbg(nor->dev, \"Failed to unlock the entire flash memory array\\n\");\n}\n\nvoid spi_nor_set_mtd_locking_ops(struct spi_nor *nor)\n{\n\tstruct mtd_info *mtd = &nor->mtd;\n\n\tif (!nor->params->locking_ops)\n\t\treturn;\n\n\tmtd->_lock = spi_nor_lock;\n\tmtd->_unlock = spi_nor_unlock;\n\tmtd->_is_locked = spi_nor_is_locked;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}