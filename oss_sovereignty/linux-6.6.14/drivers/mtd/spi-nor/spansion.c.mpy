{
  "module_name": "spansion.c",
  "hash_id": "0911c9734adafe2fa031c3da98b141ae60c15c1a0a86b5f71b15dbab7d8e739f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/spi-nor/spansion.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/device.h>\n#include <linux/errno.h>\n#include <linux/mtd/spi-nor.h>\n\n#include \"core.h\"\n\n \n#define USE_CLSR\tBIT(0)\n#define USE_CLPEF\tBIT(1)\n\n#define SPINOR_OP_CLSR\t\t0x30\t \n#define SPINOR_OP_CLPEF\t\t0x82\t \n#define SPINOR_OP_RD_ANY_REG\t\t\t0x65\t \n#define SPINOR_OP_WR_ANY_REG\t\t\t0x71\t \n#define SPINOR_REG_CYPRESS_VREG\t\t\t0x00800000\n#define SPINOR_REG_CYPRESS_STR1\t\t\t0x0\n#define SPINOR_REG_CYPRESS_STR1V\t\t\t\t\t\\\n\t(SPINOR_REG_CYPRESS_VREG + SPINOR_REG_CYPRESS_STR1)\n#define SPINOR_REG_CYPRESS_CFR1\t\t\t0x2\n#define SPINOR_REG_CYPRESS_CFR1_QUAD_EN\t\tBIT(1)\t \n#define SPINOR_REG_CYPRESS_CFR2\t\t\t0x3\n#define SPINOR_REG_CYPRESS_CFR2V\t\t\t\t\t\\\n\t(SPINOR_REG_CYPRESS_VREG + SPINOR_REG_CYPRESS_CFR2)\n#define SPINOR_REG_CYPRESS_CFR2_MEMLAT_MASK\tGENMASK(3, 0)\n#define SPINOR_REG_CYPRESS_CFR2_MEMLAT_11_24\t0xb\n#define SPINOR_REG_CYPRESS_CFR2_ADRBYT\t\tBIT(7)\n#define SPINOR_REG_CYPRESS_CFR3\t\t\t0x4\n#define SPINOR_REG_CYPRESS_CFR3_PGSZ\t\tBIT(4)  \n#define SPINOR_REG_CYPRESS_CFR5\t\t\t0x6\n#define SPINOR_REG_CYPRESS_CFR5_BIT6\t\tBIT(6)\n#define SPINOR_REG_CYPRESS_CFR5_DDR\t\tBIT(1)\n#define SPINOR_REG_CYPRESS_CFR5_OPI\t\tBIT(0)\n#define SPINOR_REG_CYPRESS_CFR5_OCT_DTR_EN\t\t\t\t\\\n\t(SPINOR_REG_CYPRESS_CFR5_BIT6 |\tSPINOR_REG_CYPRESS_CFR5_DDR |\t\\\n\t SPINOR_REG_CYPRESS_CFR5_OPI)\n#define SPINOR_REG_CYPRESS_CFR5_OCT_DTR_DS\tSPINOR_REG_CYPRESS_CFR5_BIT6\n#define SPINOR_OP_CYPRESS_RD_FAST\t\t0xee\n#define SPINOR_REG_CYPRESS_ARCFN\t\t0x00000006\n\n \n#define CYPRESS_NOR_WR_ANY_REG_OP(naddr, addr, ndata, buf)\t\t\\\n\tSPI_MEM_OP(SPI_MEM_OP_CMD(SPINOR_OP_WR_ANY_REG, 0),\t\t\\\n\t\t   SPI_MEM_OP_ADDR(naddr, addr, 0),\t\t\t\\\n\t\t   SPI_MEM_OP_NO_DUMMY,\t\t\t\t\t\\\n\t\t   SPI_MEM_OP_DATA_OUT(ndata, buf, 0))\n\n#define CYPRESS_NOR_RD_ANY_REG_OP(naddr, addr, ndummy, buf)\t\t\\\n\tSPI_MEM_OP(SPI_MEM_OP_CMD(SPINOR_OP_RD_ANY_REG, 0),\t\t\\\n\t\t   SPI_MEM_OP_ADDR(naddr, addr, 0),\t\t\t\\\n\t\t   SPI_MEM_OP_DUMMY(ndummy, 0),\t\t\t\t\\\n\t\t   SPI_MEM_OP_DATA_IN(1, buf, 0))\n\n#define SPANSION_OP(opcode)\t\t\t\t\t\t\\\n\tSPI_MEM_OP(SPI_MEM_OP_CMD(opcode, 0),\t\t\t\t\\\n\t\t   SPI_MEM_OP_NO_ADDR,\t\t\t\t\t\\\n\t\t   SPI_MEM_OP_NO_DUMMY,\t\t\t\t\t\\\n\t\t   SPI_MEM_OP_NO_DATA)\n\n \nstruct spansion_nor_params {\n\tu8 clsr;\n};\n\n \nstatic void spansion_nor_clear_sr(struct spi_nor *nor)\n{\n\tconst struct spansion_nor_params *priv_params = nor->params->priv;\n\tint ret;\n\n\tif (nor->spimem) {\n\t\tstruct spi_mem_op op = SPANSION_OP(priv_params->clsr);\n\n\t\tspi_nor_spimem_setup_op(nor, &op, nor->reg_proto);\n\n\t\tret = spi_mem_exec_op(nor->spimem, &op);\n\t} else {\n\t\tret = spi_nor_controller_ops_write_reg(nor, SPINOR_OP_CLSR,\n\t\t\t\t\t\t       NULL, 0);\n\t}\n\n\tif (ret)\n\t\tdev_dbg(nor->dev, \"error %d clearing SR\\n\", ret);\n}\n\nstatic int cypress_nor_sr_ready_and_clear_reg(struct spi_nor *nor, u64 addr)\n{\n\tstruct spi_nor_flash_parameter *params = nor->params;\n\tstruct spi_mem_op op =\n\t\tCYPRESS_NOR_RD_ANY_REG_OP(params->addr_mode_nbytes, addr,\n\t\t\t\t\t  0, nor->bouncebuf);\n\tint ret;\n\n\tif (nor->reg_proto == SNOR_PROTO_8_8_8_DTR) {\n\t\top.dummy.nbytes = params->rdsr_dummy;\n\t\top.data.nbytes = 2;\n\t}\n\n\tret = spi_nor_read_any_reg(nor, &op, nor->reg_proto);\n\tif (ret)\n\t\treturn ret;\n\n\tif (nor->bouncebuf[0] & (SR_E_ERR | SR_P_ERR)) {\n\t\tif (nor->bouncebuf[0] & SR_E_ERR)\n\t\t\tdev_err(nor->dev, \"Erase Error occurred\\n\");\n\t\telse\n\t\t\tdev_err(nor->dev, \"Programming Error occurred\\n\");\n\n\t\tspansion_nor_clear_sr(nor);\n\n\t\tret = spi_nor_write_disable(nor);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\treturn -EIO;\n\t}\n\n\treturn !(nor->bouncebuf[0] & SR_WIP);\n}\n \nstatic int cypress_nor_sr_ready_and_clear(struct spi_nor *nor)\n{\n\tstruct spi_nor_flash_parameter *params = nor->params;\n\tu64 addr;\n\tint ret;\n\tu8 i;\n\n\tfor (i = 0; i < params->n_dice; i++) {\n\t\taddr = params->vreg_offset[i] + SPINOR_REG_CYPRESS_STR1;\n\t\tret = cypress_nor_sr_ready_and_clear_reg(nor, addr);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\telse if (ret == 0)\n\t\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\nstatic int cypress_nor_set_memlat(struct spi_nor *nor, u64 addr)\n{\n\tstruct spi_mem_op op;\n\tu8 *buf = nor->bouncebuf;\n\tint ret;\n\tu8 addr_mode_nbytes = nor->params->addr_mode_nbytes;\n\n\top = (struct spi_mem_op)\n\t\tCYPRESS_NOR_RD_ANY_REG_OP(addr_mode_nbytes, addr, 0, buf);\n\n\tret = spi_nor_read_any_reg(nor, &op, nor->reg_proto);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\t*buf &= ~SPINOR_REG_CYPRESS_CFR2_MEMLAT_MASK;\n\t*buf |= FIELD_PREP(SPINOR_REG_CYPRESS_CFR2_MEMLAT_MASK,\n\t\t\t   SPINOR_REG_CYPRESS_CFR2_MEMLAT_11_24);\n\top = (struct spi_mem_op)\n\t\tCYPRESS_NOR_WR_ANY_REG_OP(addr_mode_nbytes, addr, 1, buf);\n\n\tret = spi_nor_write_any_volatile_reg(nor, &op, nor->reg_proto);\n\tif (ret)\n\t\treturn ret;\n\n\tnor->read_dummy = 24;\n\n\treturn 0;\n}\n\nstatic int cypress_nor_set_octal_dtr_bits(struct spi_nor *nor, u64 addr)\n{\n\tstruct spi_mem_op op;\n\tu8 *buf = nor->bouncebuf;\n\n\t \n\tbuf[0] = SPINOR_REG_CYPRESS_CFR5_OCT_DTR_EN;\n\top = (struct spi_mem_op)\n\t\tCYPRESS_NOR_WR_ANY_REG_OP(nor->params->addr_mode_nbytes,\n\t\t\t\t\t  addr, 1, buf);\n\n\treturn spi_nor_write_any_volatile_reg(nor, &op, nor->reg_proto);\n}\n\nstatic int cypress_nor_octal_dtr_en(struct spi_nor *nor)\n{\n\tconst struct spi_nor_flash_parameter *params = nor->params;\n\tu8 *buf = nor->bouncebuf;\n\tu64 addr;\n\tint i, ret;\n\n\tfor (i = 0; i < params->n_dice; i++) {\n\t\taddr = params->vreg_offset[i] + SPINOR_REG_CYPRESS_CFR2;\n\t\tret = cypress_nor_set_memlat(nor, addr);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\taddr = params->vreg_offset[i] + SPINOR_REG_CYPRESS_CFR5;\n\t\tret = cypress_nor_set_octal_dtr_bits(nor, addr);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\tret = spi_nor_read_id(nor, nor->addr_nbytes, 3, buf,\n\t\t\t      SNOR_PROTO_8_8_8_DTR);\n\tif (ret) {\n\t\tdev_dbg(nor->dev, \"error %d reading JEDEC ID after enabling 8D-8D-8D mode\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (memcmp(buf, nor->info->id, nor->info->id_len))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int cypress_nor_set_single_spi_bits(struct spi_nor *nor, u64 addr)\n{\n\tstruct spi_mem_op op;\n\tu8 *buf = nor->bouncebuf;\n\n\t \n\tbuf[0] = SPINOR_REG_CYPRESS_CFR5_OCT_DTR_DS;\n\tbuf[1] = 0;\n\top = (struct spi_mem_op)\n\t\tCYPRESS_NOR_WR_ANY_REG_OP(nor->addr_nbytes, addr, 2, buf);\n\treturn spi_nor_write_any_volatile_reg(nor, &op, SNOR_PROTO_8_8_8_DTR);\n}\n\nstatic int cypress_nor_octal_dtr_dis(struct spi_nor *nor)\n{\n\tconst struct spi_nor_flash_parameter *params = nor->params;\n\tu8 *buf = nor->bouncebuf;\n\tu64 addr;\n\tint i, ret;\n\n\tfor (i = 0; i < params->n_dice; i++) {\n\t\taddr = params->vreg_offset[i] + SPINOR_REG_CYPRESS_CFR5;\n\t\tret = cypress_nor_set_single_spi_bits(nor, addr);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\tret = spi_nor_read_id(nor, 0, 0, buf, SNOR_PROTO_1_1_1);\n\tif (ret) {\n\t\tdev_dbg(nor->dev, \"error %d reading JEDEC ID after disabling 8D-8D-8D mode\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (memcmp(buf, nor->info->id, nor->info->id_len))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int cypress_nor_quad_enable_volatile_reg(struct spi_nor *nor, u64 addr)\n{\n\tstruct spi_mem_op op;\n\tu8 addr_mode_nbytes = nor->params->addr_mode_nbytes;\n\tu8 cfr1v_written;\n\tint ret;\n\n\top = (struct spi_mem_op)\n\t\tCYPRESS_NOR_RD_ANY_REG_OP(addr_mode_nbytes, addr, 0,\n\t\t\t\t\t  nor->bouncebuf);\n\n\tret = spi_nor_read_any_reg(nor, &op, nor->reg_proto);\n\tif (ret)\n\t\treturn ret;\n\n\tif (nor->bouncebuf[0] & SPINOR_REG_CYPRESS_CFR1_QUAD_EN)\n\t\treturn 0;\n\n\t \n\tnor->bouncebuf[0] |= SPINOR_REG_CYPRESS_CFR1_QUAD_EN;\n\top = (struct spi_mem_op)\n\t\tCYPRESS_NOR_WR_ANY_REG_OP(addr_mode_nbytes, addr, 1,\n\t\t\t\t\t  nor->bouncebuf);\n\tret = spi_nor_write_any_volatile_reg(nor, &op, nor->reg_proto);\n\tif (ret)\n\t\treturn ret;\n\n\tcfr1v_written = nor->bouncebuf[0];\n\n\t \n\top = (struct spi_mem_op)\n\t\tCYPRESS_NOR_RD_ANY_REG_OP(addr_mode_nbytes, addr, 0,\n\t\t\t\t\t  nor->bouncebuf);\n\tret = spi_nor_read_any_reg(nor, &op, nor->reg_proto);\n\tif (ret)\n\t\treturn ret;\n\n\tif (nor->bouncebuf[0] != cfr1v_written) {\n\t\tdev_err(nor->dev, \"CFR1: Read back test failed\\n\");\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int cypress_nor_quad_enable_volatile(struct spi_nor *nor)\n{\n\tstruct spi_nor_flash_parameter *params = nor->params;\n\tu64 addr;\n\tu8 i;\n\tint ret;\n\n\tfor (i = 0; i < params->n_dice; i++) {\n\t\taddr = params->vreg_offset[i] + SPINOR_REG_CYPRESS_CFR1;\n\t\tret = cypress_nor_quad_enable_volatile_reg(nor, addr);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int cypress_nor_determine_addr_mode_by_sr1(struct spi_nor *nor,\n\t\t\t\t\t\t  u8 *addr_mode)\n{\n\tstruct spi_mem_op op =\n\t\tCYPRESS_NOR_RD_ANY_REG_OP(3, SPINOR_REG_CYPRESS_STR1V, 0,\n\t\t\t\t\t  nor->bouncebuf);\n\tbool is3byte, is4byte;\n\tint ret;\n\n\tret = spi_nor_read_sr(nor, &nor->bouncebuf[1]);\n\tif (ret)\n\t\treturn ret;\n\n\tret = spi_nor_read_any_reg(nor, &op, nor->reg_proto);\n\tif (ret)\n\t\treturn ret;\n\n\tis3byte = (nor->bouncebuf[0] == nor->bouncebuf[1]);\n\n\top = (struct spi_mem_op)\n\t\tCYPRESS_NOR_RD_ANY_REG_OP(4, SPINOR_REG_CYPRESS_STR1V, 0,\n\t\t\t\t\t  nor->bouncebuf);\n\tret = spi_nor_read_any_reg(nor, &op, nor->reg_proto);\n\tif (ret)\n\t\treturn ret;\n\n\tis4byte = (nor->bouncebuf[0] == nor->bouncebuf[1]);\n\n\tif (is3byte == is4byte)\n\t\treturn -EIO;\n\tif (is3byte)\n\t\t*addr_mode = 3;\n\telse\n\t\t*addr_mode = 4;\n\n\treturn 0;\n}\n\n \nstatic int cypress_nor_set_addr_mode_nbytes(struct spi_nor *nor)\n{\n\tstruct spi_mem_op op;\n\tu8 addr_mode;\n\tint ret;\n\n\t \n\tret = spi_nor_write_enable(nor);\n\tif (ret)\n\t\treturn ret;\n\tret = cypress_nor_determine_addr_mode_by_sr1(nor, &addr_mode);\n\tif (ret) {\n\t\tret = spi_nor_set_4byte_addr_mode(nor, true);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\treturn spi_nor_write_disable(nor);\n\t}\n\tret = spi_nor_write_disable(nor);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\top = (struct spi_mem_op)\n\t\tCYPRESS_NOR_RD_ANY_REG_OP(addr_mode, SPINOR_REG_CYPRESS_CFR2V,\n\t\t\t\t\t  0, nor->bouncebuf);\n\tret = spi_nor_read_any_reg(nor, &op, nor->reg_proto);\n\tif (ret)\n\t\treturn ret;\n\n\tif (nor->bouncebuf[0] & SPINOR_REG_CYPRESS_CFR2_ADRBYT) {\n\t\tif (addr_mode != 4)\n\t\t\treturn spi_nor_set_4byte_addr_mode(nor, true);\n\t} else {\n\t\tif (addr_mode != 3)\n\t\t\treturn spi_nor_set_4byte_addr_mode(nor, true);\n\t}\n\n\tnor->params->addr_nbytes = addr_mode;\n\tnor->params->addr_mode_nbytes = addr_mode;\n\n\treturn 0;\n}\n\n \nstatic int cypress_nor_get_page_size(struct spi_nor *nor)\n{\n\tstruct spi_mem_op op =\n\t\tCYPRESS_NOR_RD_ANY_REG_OP(nor->params->addr_mode_nbytes,\n\t\t\t\t\t  0, 0, nor->bouncebuf);\n\tstruct spi_nor_flash_parameter *params = nor->params;\n\tint ret;\n\tu8 i;\n\n\t \n\tparams->page_size = 256;\n\tfor (i = 0; i < params->n_dice; i++) {\n\t\top.addr.val = params->vreg_offset[i] + SPINOR_REG_CYPRESS_CFR3;\n\n\t\tret = spi_nor_read_any_reg(nor, &op, nor->reg_proto);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (!(nor->bouncebuf[0] & SPINOR_REG_CYPRESS_CFR3_PGSZ))\n\t\t\treturn 0;\n\t}\n\n\tparams->page_size = 512;\n\n\treturn 0;\n}\n\nstatic void cypress_nor_ecc_init(struct spi_nor *nor)\n{\n\t \n\tnor->params->writesize = 16;\n\tnor->flags |= SNOR_F_ECC;\n}\n\nstatic int\ns25fs256t_post_bfpt_fixup(struct spi_nor *nor,\n\t\t\t  const struct sfdp_parameter_header *bfpt_header,\n\t\t\t  const struct sfdp_bfpt *bfpt)\n{\n\tstruct spi_mem_op op;\n\tint ret;\n\n\tret = cypress_nor_set_addr_mode_nbytes(nor);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\top = (struct spi_mem_op)\n\t\tCYPRESS_NOR_RD_ANY_REG_OP(nor->params->addr_mode_nbytes,\n\t\t\t\t\t  SPINOR_REG_CYPRESS_ARCFN, 1,\n\t\t\t\t\t  nor->bouncebuf);\n\tret = spi_nor_read_any_reg(nor, &op, nor->reg_proto);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (nor->bouncebuf[0])\n\t\treturn -ENODEV;\n\n\treturn 0;\n}\n\nstatic int s25fs256t_post_sfdp_fixup(struct spi_nor *nor)\n{\n\tstruct spi_nor_flash_parameter *params = nor->params;\n\n\t \n\tparams->vreg_offset = devm_kmalloc(nor->dev, sizeof(u32), GFP_KERNEL);\n\tif (!params->vreg_offset)\n\t\treturn -ENOMEM;\n\n\tparams->vreg_offset[0] = SPINOR_REG_CYPRESS_VREG;\n\tparams->n_dice = 1;\n\n\t \n\tparams->hwcaps.mask |= SNOR_HWCAPS_PP_1_1_4;\n\tspi_nor_set_pp_settings(&params->page_programs[SNOR_CMD_PP_1_1_4],\n\t\t\t\tSPINOR_OP_PP_1_1_4_4B,\n\t\t\t\tSNOR_PROTO_1_1_4);\n\n\treturn cypress_nor_get_page_size(nor);\n}\n\nstatic int s25fs256t_late_init(struct spi_nor *nor)\n{\n\tcypress_nor_ecc_init(nor);\n\n\treturn 0;\n}\n\nstatic struct spi_nor_fixups s25fs256t_fixups = {\n\t.post_bfpt = s25fs256t_post_bfpt_fixup,\n\t.post_sfdp = s25fs256t_post_sfdp_fixup,\n\t.late_init = s25fs256t_late_init,\n};\n\nstatic int\ns25hx_t_post_bfpt_fixup(struct spi_nor *nor,\n\t\t\tconst struct sfdp_parameter_header *bfpt_header,\n\t\t\tconst struct sfdp_bfpt *bfpt)\n{\n\tint ret;\n\n\tret = cypress_nor_set_addr_mode_nbytes(nor);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tnor->params->quad_enable = cypress_nor_quad_enable_volatile;\n\n\treturn 0;\n}\n\nstatic int s25hx_t_post_sfdp_fixup(struct spi_nor *nor)\n{\n\tstruct spi_nor_flash_parameter *params = nor->params;\n\tstruct spi_nor_erase_type *erase_type = params->erase_map.erase_type;\n\tunsigned int i;\n\n\tif (!params->n_dice || !params->vreg_offset) {\n\t\tdev_err(nor->dev, \"%s failed. The volatile register offset could not be retrieved from SFDP.\\n\",\n\t\t\t__func__);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\t \n\tif (params->size == SZ_256M)\n\t\tparams->n_dice = 2;\n\n\t \n\tfor (i = 0; i < SNOR_ERASE_TYPE_MAX; i++) {\n\t\tswitch (erase_type[i].opcode) {\n\t\tcase SPINOR_OP_SE:\n\t\t\terase_type[i].opcode = SPINOR_OP_SE_4B;\n\t\t\tbreak;\n\t\tcase SPINOR_OP_BE_4K:\n\t\t\terase_type[i].opcode = SPINOR_OP_BE_4K_4B;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn cypress_nor_get_page_size(nor);\n}\n\nstatic int s25hx_t_late_init(struct spi_nor *nor)\n{\n\tstruct spi_nor_flash_parameter *params = nor->params;\n\n\t \n\tparams->reads[SNOR_CMD_READ_FAST].num_mode_clocks = 8;\n\tparams->ready = cypress_nor_sr_ready_and_clear;\n\tcypress_nor_ecc_init(nor);\n\n\treturn 0;\n}\n\nstatic struct spi_nor_fixups s25hx_t_fixups = {\n\t.post_bfpt = s25hx_t_post_bfpt_fixup,\n\t.post_sfdp = s25hx_t_post_sfdp_fixup,\n\t.late_init = s25hx_t_late_init,\n};\n\n \nstatic int cypress_nor_set_octal_dtr(struct spi_nor *nor, bool enable)\n{\n\treturn enable ? cypress_nor_octal_dtr_en(nor) :\n\t\t\tcypress_nor_octal_dtr_dis(nor);\n}\n\nstatic int s28hx_t_post_sfdp_fixup(struct spi_nor *nor)\n{\n\tstruct spi_nor_flash_parameter *params = nor->params;\n\n\tif (!params->n_dice || !params->vreg_offset) {\n\t\tdev_err(nor->dev, \"%s failed. The volatile register offset could not be retrieved from SFDP.\\n\",\n\t\t\t__func__);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\t \n\tif (params->size == SZ_256M)\n\t\tparams->n_dice = 2;\n\n\t \n\tif (params->reads[SNOR_CMD_READ_8_8_8_DTR].opcode == 0)\n\t\tparams->reads[SNOR_CMD_READ_8_8_8_DTR].opcode =\n\t\t\tSPINOR_OP_CYPRESS_RD_FAST;\n\n\t \n\tspi_nor_set_pp_settings(&params->page_programs[SNOR_CMD_PP],\n\t\t\t\tSPINOR_OP_PP_4B, SNOR_PROTO_1_1_1);\n\t \n\tspi_nor_set_pp_settings(&params->page_programs[SNOR_CMD_PP_8_8_8_DTR],\n\t\t\t\tSPINOR_OP_PP_4B, SNOR_PROTO_8_8_8_DTR);\n\n\t \n\tparams->rdsr_addr_nbytes = 4;\n\n\treturn cypress_nor_get_page_size(nor);\n}\n\nstatic int s28hx_t_post_bfpt_fixup(struct spi_nor *nor,\n\t\t\t\t   const struct sfdp_parameter_header *bfpt_header,\n\t\t\t\t   const struct sfdp_bfpt *bfpt)\n{\n\treturn cypress_nor_set_addr_mode_nbytes(nor);\n}\n\nstatic int s28hx_t_late_init(struct spi_nor *nor)\n{\n\tstruct spi_nor_flash_parameter *params = nor->params;\n\n\tparams->set_octal_dtr = cypress_nor_set_octal_dtr;\n\tparams->ready = cypress_nor_sr_ready_and_clear;\n\tcypress_nor_ecc_init(nor);\n\n\treturn 0;\n}\n\nstatic const struct spi_nor_fixups s28hx_t_fixups = {\n\t.post_sfdp = s28hx_t_post_sfdp_fixup,\n\t.post_bfpt = s28hx_t_post_bfpt_fixup,\n\t.late_init = s28hx_t_late_init,\n};\n\nstatic int\ns25fs_s_nor_post_bfpt_fixups(struct spi_nor *nor,\n\t\t\t     const struct sfdp_parameter_header *bfpt_header,\n\t\t\t     const struct sfdp_bfpt *bfpt)\n{\n\t \n\tnor->params->page_size = 256;\n\n\treturn 0;\n}\n\nstatic const struct spi_nor_fixups s25fs_s_nor_fixups = {\n\t.post_bfpt = s25fs_s_nor_post_bfpt_fixups,\n};\n\nstatic const struct flash_info spansion_nor_parts[] = {\n\t \n\t{ \"s25sl032p\",  INFO(0x010215, 0x4d00,  64 * 1024,  64)\n\t\tNO_SFDP_FLAGS(SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ) },\n\t{ \"s25sl064p\",  INFO(0x010216, 0x4d00,  64 * 1024, 128)\n\t\tNO_SFDP_FLAGS(SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ) },\n\t{ \"s25fl128s0\", INFO6(0x012018, 0x4d0080, 256 * 1024, 64)\n\t\tNO_SFDP_FLAGS(SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ)\n\t\tMFR_FLAGS(USE_CLSR)\n\t},\n\t{ \"s25fl128s1\", INFO6(0x012018, 0x4d0180, 64 * 1024, 256)\n\t\tNO_SFDP_FLAGS(SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ)\n\t\tMFR_FLAGS(USE_CLSR)\n\t},\n\t{ \"s25fl256s0\", INFO6(0x010219, 0x4d0080, 256 * 1024, 128)\n\t\tNO_SFDP_FLAGS(SPI_NOR_SKIP_SFDP | SPI_NOR_DUAL_READ |\n\t\t\t      SPI_NOR_QUAD_READ)\n\t\tMFR_FLAGS(USE_CLSR)\n\t},\n\t{ \"s25fl256s1\", INFO6(0x010219, 0x4d0180, 64 * 1024, 512)\n\t\tNO_SFDP_FLAGS(SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ)\n\t\tMFR_FLAGS(USE_CLSR)\n\t},\n\t{ \"s25fl512s\",  INFO6(0x010220, 0x4d0080, 256 * 1024, 256)\n\t\tFLAGS(SPI_NOR_HAS_LOCK)\n\t\tNO_SFDP_FLAGS(SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ)\n\t\tMFR_FLAGS(USE_CLSR)\n\t},\n\t{ \"s25fs128s1\", INFO6(0x012018, 0x4d0181, 64 * 1024, 256)\n\t\tNO_SFDP_FLAGS(SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ)\n\t\tMFR_FLAGS(USE_CLSR)\n\t\t.fixups = &s25fs_s_nor_fixups, },\n\t{ \"s25fs256s0\", INFO6(0x010219, 0x4d0081, 256 * 1024, 128)\n\t\tNO_SFDP_FLAGS(SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ)\n\t\tMFR_FLAGS(USE_CLSR)\n\t},\n\t{ \"s25fs256s1\", INFO6(0x010219, 0x4d0181, 64 * 1024, 512)\n\t\tNO_SFDP_FLAGS(SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ)\n\t\tMFR_FLAGS(USE_CLSR)\n\t},\n\t{ \"s25fs512s\",  INFO6(0x010220, 0x4d0081, 256 * 1024, 256)\n\t\tNO_SFDP_FLAGS(SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ)\n\t\tMFR_FLAGS(USE_CLSR)\n\t\t.fixups = &s25fs_s_nor_fixups, },\n\t{ \"s25sl12800\", INFO(0x012018, 0x0300, 256 * 1024,  64) },\n\t{ \"s25sl12801\", INFO(0x012018, 0x0301,  64 * 1024, 256) },\n\t{ \"s25fl129p0\", INFO(0x012018, 0x4d00, 256 * 1024,  64)\n\t\tNO_SFDP_FLAGS(SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ)\n\t\tMFR_FLAGS(USE_CLSR)\n\t},\n\t{ \"s25fl129p1\", INFO(0x012018, 0x4d01,  64 * 1024, 256)\n\t\tNO_SFDP_FLAGS(SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ)\n\t\tMFR_FLAGS(USE_CLSR)\n\t},\n\t{ \"s25sl004a\",  INFO(0x010212,      0,  64 * 1024,   8) },\n\t{ \"s25sl008a\",  INFO(0x010213,      0,  64 * 1024,  16) },\n\t{ \"s25sl016a\",  INFO(0x010214,      0,  64 * 1024,  32) },\n\t{ \"s25sl032a\",  INFO(0x010215,      0,  64 * 1024,  64) },\n\t{ \"s25sl064a\",  INFO(0x010216,      0,  64 * 1024, 128) },\n\t{ \"s25fl004k\",  INFO(0xef4013,      0,  64 * 1024,   8)\n\t\tNO_SFDP_FLAGS(SECT_4K | SPI_NOR_DUAL_READ |\n\t\t\t      SPI_NOR_QUAD_READ) },\n\t{ \"s25fl008k\",  INFO(0xef4014,      0,  64 * 1024,  16)\n\t\tNO_SFDP_FLAGS(SECT_4K | SPI_NOR_DUAL_READ |\n\t\t\t      SPI_NOR_QUAD_READ) },\n\t{ \"s25fl016k\",  INFO(0xef4015,      0,  64 * 1024,  32)\n\t\tNO_SFDP_FLAGS(SECT_4K | SPI_NOR_DUAL_READ |\n\t\t\t      SPI_NOR_QUAD_READ) },\n\t{ \"s25fl064k\",  INFO(0xef4017,      0,  64 * 1024, 128)\n\t\tNO_SFDP_FLAGS(SECT_4K | SPI_NOR_DUAL_READ |\n\t\t\t      SPI_NOR_QUAD_READ) },\n\t{ \"s25fl116k\",  INFO(0x014015,      0,  64 * 1024,  32)\n\t\tNO_SFDP_FLAGS(SECT_4K | SPI_NOR_DUAL_READ |\n\t\t\t      SPI_NOR_QUAD_READ) },\n\t{ \"s25fl132k\",  INFO(0x014016,      0,  64 * 1024,  64)\n\t\tNO_SFDP_FLAGS(SECT_4K) },\n\t{ \"s25fl164k\",  INFO(0x014017,      0,  64 * 1024, 128)\n\t\tNO_SFDP_FLAGS(SECT_4K) },\n\t{ \"s25fl204k\",  INFO(0x014013,      0,  64 * 1024,   8)\n\t\tNO_SFDP_FLAGS(SECT_4K | SPI_NOR_DUAL_READ) },\n\t{ \"s25fl208k\",  INFO(0x014014,      0,  64 * 1024,  16)\n\t\tNO_SFDP_FLAGS(SECT_4K | SPI_NOR_DUAL_READ) },\n\t{ \"s25fl064l\",  INFO(0x016017,      0,  64 * 1024, 128)\n\t\tNO_SFDP_FLAGS(SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ)\n\t\tFIXUP_FLAGS(SPI_NOR_4B_OPCODES) },\n\t{ \"s25fl128l\",  INFO(0x016018,      0,  64 * 1024, 256)\n\t\tNO_SFDP_FLAGS(SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ)\n\t\tFIXUP_FLAGS(SPI_NOR_4B_OPCODES) },\n\t{ \"s25fl256l\",  INFO(0x016019,      0,  64 * 1024, 512)\n\t\tNO_SFDP_FLAGS(SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ)\n\t\tFIXUP_FLAGS(SPI_NOR_4B_OPCODES) },\n\t{ \"s25fs256t\",  INFO6(0x342b19, 0x0f0890, 0, 0)\n\t\tPARSE_SFDP\n\t\tMFR_FLAGS(USE_CLPEF)\n\t\t.fixups = &s25fs256t_fixups },\n\t{ \"s25hl512t\",  INFO6(0x342a1a, 0x0f0390, 0, 0)\n\t\tPARSE_SFDP\n\t\tMFR_FLAGS(USE_CLPEF)\n\t\t.fixups = &s25hx_t_fixups },\n\t{ \"s25hl01gt\",  INFO6(0x342a1b, 0x0f0390, 0, 0)\n\t\tPARSE_SFDP\n\t\tMFR_FLAGS(USE_CLPEF)\n\t\t.fixups = &s25hx_t_fixups },\n\t{ \"s25hl02gt\",  INFO6(0x342a1c, 0x0f0090, 0, 0)\n\t\tPARSE_SFDP\n\t\tMFR_FLAGS(USE_CLPEF)\n\t\tFLAGS(NO_CHIP_ERASE)\n\t\t.fixups = &s25hx_t_fixups },\n\t{ \"s25hs512t\",  INFO6(0x342b1a, 0x0f0390, 0, 0)\n\t\tPARSE_SFDP\n\t\tMFR_FLAGS(USE_CLPEF)\n\t\t.fixups = &s25hx_t_fixups },\n\t{ \"s25hs01gt\",  INFO6(0x342b1b, 0x0f0390, 0, 0)\n\t\tPARSE_SFDP\n\t\tMFR_FLAGS(USE_CLPEF)\n\t\t.fixups = &s25hx_t_fixups },\n\t{ \"s25hs02gt\",  INFO6(0x342b1c, 0x0f0090, 0, 0)\n\t\tPARSE_SFDP\n\t\tMFR_FLAGS(USE_CLPEF)\n\t\tFLAGS(NO_CHIP_ERASE)\n\t\t.fixups = &s25hx_t_fixups },\n\t{ \"cy15x104q\",  INFO6(0x042cc2, 0x7f7f7f, 512 * 1024, 1)\n\t\tFLAGS(SPI_NOR_NO_ERASE) },\n\t{ \"s28hl512t\",   INFO(0x345a1a,      0, 0, 0)\n\t\tPARSE_SFDP\n\t\tMFR_FLAGS(USE_CLPEF)\n\t\t.fixups = &s28hx_t_fixups,\n\t},\n\t{ \"s28hl01gt\",   INFO(0x345a1b,      0, 0, 0)\n\t\tPARSE_SFDP\n\t\tMFR_FLAGS(USE_CLPEF)\n\t\t.fixups = &s28hx_t_fixups,\n\t},\n\t{ \"s28hs512t\",   INFO(0x345b1a,      0, 0, 0)\n\t\tPARSE_SFDP\n\t\tMFR_FLAGS(USE_CLPEF)\n\t\t.fixups = &s28hx_t_fixups,\n\t},\n\t{ \"s28hs01gt\",   INFO(0x345b1b,      0, 0, 0)\n\t\tPARSE_SFDP\n\t\tMFR_FLAGS(USE_CLPEF)\n\t\t.fixups = &s28hx_t_fixups,\n\t},\n\t{ \"s28hs02gt\",   INFO(0x345b1c,      0, 0, 0)\n\t\tPARSE_SFDP\n\t\tMFR_FLAGS(USE_CLPEF)\n\t\t.fixups = &s28hx_t_fixups,\n\t},\n};\n\n \nstatic int spansion_nor_sr_ready_and_clear(struct spi_nor *nor)\n{\n\tint ret;\n\n\tret = spi_nor_read_sr(nor, nor->bouncebuf);\n\tif (ret)\n\t\treturn ret;\n\n\tif (nor->bouncebuf[0] & (SR_E_ERR | SR_P_ERR)) {\n\t\tif (nor->bouncebuf[0] & SR_E_ERR)\n\t\t\tdev_err(nor->dev, \"Erase Error occurred\\n\");\n\t\telse\n\t\t\tdev_err(nor->dev, \"Programming Error occurred\\n\");\n\n\t\tspansion_nor_clear_sr(nor);\n\n\t\t \n\t\tret = spi_nor_write_disable(nor);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\treturn -EIO;\n\t}\n\n\treturn !(nor->bouncebuf[0] & SR_WIP);\n}\n\nstatic int spansion_nor_late_init(struct spi_nor *nor)\n{\n\tstruct spi_nor_flash_parameter *params = nor->params;\n\tstruct spansion_nor_params *priv_params;\n\tu8 mfr_flags = nor->info->mfr_flags;\n\n\tif (params->size > SZ_16M) {\n\t\tnor->flags |= SNOR_F_4B_OPCODES;\n\t\t \n\t\tnor->erase_opcode = SPINOR_OP_SE;\n\t\tnor->mtd.erasesize = nor->info->sector_size;\n\t}\n\n\tif (mfr_flags & (USE_CLSR | USE_CLPEF)) {\n\t\tpriv_params = devm_kmalloc(nor->dev, sizeof(*priv_params),\n\t\t\t\t\t   GFP_KERNEL);\n\t\tif (!priv_params)\n\t\t\treturn -ENOMEM;\n\n\t\tif (mfr_flags & USE_CLSR)\n\t\t\tpriv_params->clsr = SPINOR_OP_CLSR;\n\t\telse if (mfr_flags & USE_CLPEF)\n\t\t\tpriv_params->clsr = SPINOR_OP_CLPEF;\n\n\t\tparams->priv = priv_params;\n\t\tparams->ready = spansion_nor_sr_ready_and_clear;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct spi_nor_fixups spansion_nor_fixups = {\n\t.late_init = spansion_nor_late_init,\n};\n\nconst struct spi_nor_manufacturer spi_nor_spansion = {\n\t.name = \"spansion\",\n\t.parts = spansion_nor_parts,\n\t.nparts = ARRAY_SIZE(spansion_nor_parts),\n\t.fixups = &spansion_nor_fixups,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}