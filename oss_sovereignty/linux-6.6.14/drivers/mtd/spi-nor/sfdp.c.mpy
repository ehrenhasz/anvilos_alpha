{
  "module_name": "sfdp.c",
  "hash_id": "8fd06a612564f388dea6279de87e126be123725da94240b717fac172a7672b2f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/spi-nor/sfdp.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/mtd/spi-nor.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n\n#include \"core.h\"\n\n#define SFDP_PARAM_HEADER_ID(p)\t(((p)->id_msb << 8) | (p)->id_lsb)\n#define SFDP_PARAM_HEADER_PTP(p) \\\n\t(((p)->parameter_table_pointer[2] << 16) | \\\n\t ((p)->parameter_table_pointer[1] <<  8) | \\\n\t ((p)->parameter_table_pointer[0] <<  0))\n#define SFDP_PARAM_HEADER_PARAM_LEN(p) ((p)->length * 4)\n\n#define SFDP_BFPT_ID\t\t0xff00\t \n#define SFDP_SECTOR_MAP_ID\t0xff81\t \n#define SFDP_4BAIT_ID\t\t0xff84   \n#define SFDP_PROFILE1_ID\t0xff05\t \n#define SFDP_SCCR_MAP_ID\t0xff87\t \n#define SFDP_SCCR_MAP_MC_ID\t0xff88\t \n\n#define SFDP_SIGNATURE\t\t0x50444653U\n\nstruct sfdp_header {\n\tu32\t\tsignature;  \n\tu8\t\tminor;\n\tu8\t\tmajor;\n\tu8\t\tnph;  \n\tu8\t\tunused;\n\n\t \n\tstruct sfdp_parameter_header\tbfpt_header;\n};\n\n \nstruct sfdp_bfpt_read {\n\t \n\tu32\t\t\thwcaps;\n\n\t \n\tu32\t\t\tsupported_dword;\n\tu32\t\t\tsupported_bit;\n\n\t \n\tu32\t\t\tsettings_dword;\n\tu32\t\t\tsettings_shift;\n\n\t \n\tenum spi_nor_protocol\tproto;\n};\n\nstruct sfdp_bfpt_erase {\n\t \n\tu32\t\t\tdword;\n\tu32\t\t\tshift;\n};\n\n#define SMPT_CMD_ADDRESS_LEN_MASK\t\tGENMASK(23, 22)\n#define SMPT_CMD_ADDRESS_LEN_0\t\t\t(0x0UL << 22)\n#define SMPT_CMD_ADDRESS_LEN_3\t\t\t(0x1UL << 22)\n#define SMPT_CMD_ADDRESS_LEN_4\t\t\t(0x2UL << 22)\n#define SMPT_CMD_ADDRESS_LEN_USE_CURRENT\t(0x3UL << 22)\n\n#define SMPT_CMD_READ_DUMMY_MASK\t\tGENMASK(19, 16)\n#define SMPT_CMD_READ_DUMMY_SHIFT\t\t16\n#define SMPT_CMD_READ_DUMMY(_cmd) \\\n\t(((_cmd) & SMPT_CMD_READ_DUMMY_MASK) >> SMPT_CMD_READ_DUMMY_SHIFT)\n#define SMPT_CMD_READ_DUMMY_IS_VARIABLE\t\t0xfUL\n\n#define SMPT_CMD_READ_DATA_MASK\t\t\tGENMASK(31, 24)\n#define SMPT_CMD_READ_DATA_SHIFT\t\t24\n#define SMPT_CMD_READ_DATA(_cmd) \\\n\t(((_cmd) & SMPT_CMD_READ_DATA_MASK) >> SMPT_CMD_READ_DATA_SHIFT)\n\n#define SMPT_CMD_OPCODE_MASK\t\t\tGENMASK(15, 8)\n#define SMPT_CMD_OPCODE_SHIFT\t\t\t8\n#define SMPT_CMD_OPCODE(_cmd) \\\n\t(((_cmd) & SMPT_CMD_OPCODE_MASK) >> SMPT_CMD_OPCODE_SHIFT)\n\n#define SMPT_MAP_REGION_COUNT_MASK\t\tGENMASK(23, 16)\n#define SMPT_MAP_REGION_COUNT_SHIFT\t\t16\n#define SMPT_MAP_REGION_COUNT(_header) \\\n\t((((_header) & SMPT_MAP_REGION_COUNT_MASK) >> \\\n\t  SMPT_MAP_REGION_COUNT_SHIFT) + 1)\n\n#define SMPT_MAP_ID_MASK\t\t\tGENMASK(15, 8)\n#define SMPT_MAP_ID_SHIFT\t\t\t8\n#define SMPT_MAP_ID(_header) \\\n\t(((_header) & SMPT_MAP_ID_MASK) >> SMPT_MAP_ID_SHIFT)\n\n#define SMPT_MAP_REGION_SIZE_MASK\t\tGENMASK(31, 8)\n#define SMPT_MAP_REGION_SIZE_SHIFT\t\t8\n#define SMPT_MAP_REGION_SIZE(_region) \\\n\t(((((_region) & SMPT_MAP_REGION_SIZE_MASK) >> \\\n\t   SMPT_MAP_REGION_SIZE_SHIFT) + 1) * 256)\n\n#define SMPT_MAP_REGION_ERASE_TYPE_MASK\t\tGENMASK(3, 0)\n#define SMPT_MAP_REGION_ERASE_TYPE(_region) \\\n\t((_region) & SMPT_MAP_REGION_ERASE_TYPE_MASK)\n\n#define SMPT_DESC_TYPE_MAP\t\t\tBIT(1)\n#define SMPT_DESC_END\t\t\t\tBIT(0)\n\n#define SFDP_4BAIT_DWORD_MAX\t2\n\nstruct sfdp_4bait {\n\t \n\tu32\t\thwcaps;\n\n\t \n\tu32\t\tsupported_bit;\n};\n\n \nstatic int spi_nor_read_raw(struct spi_nor *nor, u32 addr, size_t len, u8 *buf)\n{\n\tssize_t ret;\n\n\twhile (len) {\n\t\tret = spi_nor_read_data(nor, addr, len, buf);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tif (!ret || ret > len)\n\t\t\treturn -EIO;\n\n\t\tbuf += ret;\n\t\taddr += ret;\n\t\tlen -= ret;\n\t}\n\treturn 0;\n}\n\n \nstatic int spi_nor_read_sfdp(struct spi_nor *nor, u32 addr,\n\t\t\t     size_t len, void *buf)\n{\n\tu8 addr_nbytes, read_opcode, read_dummy;\n\tint ret;\n\n\tread_opcode = nor->read_opcode;\n\taddr_nbytes = nor->addr_nbytes;\n\tread_dummy = nor->read_dummy;\n\n\tnor->read_opcode = SPINOR_OP_RDSFDP;\n\tnor->addr_nbytes = 3;\n\tnor->read_dummy = 8;\n\n\tret = spi_nor_read_raw(nor, addr, len, buf);\n\n\tnor->read_opcode = read_opcode;\n\tnor->addr_nbytes = addr_nbytes;\n\tnor->read_dummy = read_dummy;\n\n\treturn ret;\n}\n\n \nstatic int spi_nor_read_sfdp_dma_unsafe(struct spi_nor *nor, u32 addr,\n\t\t\t\t\tsize_t len, void *buf)\n{\n\tvoid *dma_safe_buf;\n\tint ret;\n\n\tdma_safe_buf = kmalloc(len, GFP_KERNEL);\n\tif (!dma_safe_buf)\n\t\treturn -ENOMEM;\n\n\tret = spi_nor_read_sfdp(nor, addr, len, dma_safe_buf);\n\tmemcpy(buf, dma_safe_buf, len);\n\tkfree(dma_safe_buf);\n\n\treturn ret;\n}\n\nstatic void\nspi_nor_set_read_settings_from_bfpt(struct spi_nor_read_command *read,\n\t\t\t\t    u16 half,\n\t\t\t\t    enum spi_nor_protocol proto)\n{\n\tread->num_mode_clocks = (half >> 5) & 0x07;\n\tread->num_wait_states = (half >> 0) & 0x1f;\n\tread->opcode = (half >> 8) & 0xff;\n\tread->proto = proto;\n}\n\nstatic const struct sfdp_bfpt_read sfdp_bfpt_reads[] = {\n\t \n\t{\n\t\tSNOR_HWCAPS_READ_1_1_2,\n\t\tSFDP_DWORD(1), BIT(16),\t \n\t\tSFDP_DWORD(4), 0,\t \n\t\tSNOR_PROTO_1_1_2,\n\t},\n\n\t \n\t{\n\t\tSNOR_HWCAPS_READ_1_2_2,\n\t\tSFDP_DWORD(1), BIT(20),\t \n\t\tSFDP_DWORD(4), 16,\t \n\t\tSNOR_PROTO_1_2_2,\n\t},\n\n\t \n\t{\n\t\tSNOR_HWCAPS_READ_2_2_2,\n\t\tSFDP_DWORD(5),  BIT(0),\t \n\t\tSFDP_DWORD(6), 16,\t \n\t\tSNOR_PROTO_2_2_2,\n\t},\n\n\t \n\t{\n\t\tSNOR_HWCAPS_READ_1_1_4,\n\t\tSFDP_DWORD(1), BIT(22),\t \n\t\tSFDP_DWORD(3), 16,\t \n\t\tSNOR_PROTO_1_1_4,\n\t},\n\n\t \n\t{\n\t\tSNOR_HWCAPS_READ_1_4_4,\n\t\tSFDP_DWORD(1), BIT(21),\t \n\t\tSFDP_DWORD(3), 0,\t \n\t\tSNOR_PROTO_1_4_4,\n\t},\n\n\t \n\t{\n\t\tSNOR_HWCAPS_READ_4_4_4,\n\t\tSFDP_DWORD(5), BIT(4),\t \n\t\tSFDP_DWORD(7), 16,\t \n\t\tSNOR_PROTO_4_4_4,\n\t},\n};\n\nstatic const struct sfdp_bfpt_erase sfdp_bfpt_erases[] = {\n\t \n\t{SFDP_DWORD(8), 0},\n\n\t \n\t{SFDP_DWORD(8), 16},\n\n\t \n\t{SFDP_DWORD(9), 0},\n\n\t \n\t{SFDP_DWORD(9), 16},\n};\n\n \nstatic void\nspi_nor_set_erase_settings_from_bfpt(struct spi_nor_erase_type *erase,\n\t\t\t\t     u32 size, u8 opcode, u8 i)\n{\n\terase->idx = i;\n\tspi_nor_set_erase_type(erase, size, opcode);\n}\n\n \nstatic int spi_nor_map_cmp_erase_type(const void *l, const void *r)\n{\n\tconst struct spi_nor_erase_type *left = l, *right = r;\n\n\treturn left->size - right->size;\n}\n\n \nstatic u8 spi_nor_sort_erase_mask(struct spi_nor_erase_map *map, u8 erase_mask)\n{\n\tstruct spi_nor_erase_type *erase_type = map->erase_type;\n\tint i;\n\tu8 sorted_erase_mask = 0;\n\n\tif (!erase_mask)\n\t\treturn 0;\n\n\t \n\tfor (i = 0; i < SNOR_ERASE_TYPE_MAX; i++)\n\t\tif (erase_type[i].size && erase_mask & BIT(erase_type[i].idx))\n\t\t\tsorted_erase_mask |= BIT(i);\n\n\treturn sorted_erase_mask;\n}\n\n \nstatic void spi_nor_regions_sort_erase_types(struct spi_nor_erase_map *map)\n{\n\tstruct spi_nor_erase_region *region = map->regions;\n\tu8 region_erase_mask, sorted_erase_mask;\n\n\twhile (region) {\n\t\tregion_erase_mask = region->offset & SNOR_ERASE_TYPE_MASK;\n\n\t\tsorted_erase_mask = spi_nor_sort_erase_mask(map,\n\t\t\t\t\t\t\t    region_erase_mask);\n\n\t\t \n\t\tregion->offset = (region->offset & ~SNOR_ERASE_TYPE_MASK) |\n\t\t\t\t sorted_erase_mask;\n\n\t\tregion = spi_nor_region_next(region);\n\t}\n}\n\n \nstatic int spi_nor_parse_bfpt(struct spi_nor *nor,\n\t\t\t      const struct sfdp_parameter_header *bfpt_header)\n{\n\tstruct spi_nor_flash_parameter *params = nor->params;\n\tstruct spi_nor_erase_map *map = &params->erase_map;\n\tstruct spi_nor_erase_type *erase_type = map->erase_type;\n\tstruct sfdp_bfpt bfpt;\n\tsize_t len;\n\tint i, cmd, err;\n\tu32 addr, val;\n\tu32 dword;\n\tu16 half;\n\tu8 erase_mask;\n\n\t \n\tif (bfpt_header->length < BFPT_DWORD_MAX_JESD216)\n\t\treturn -EINVAL;\n\n\t \n\tlen = min_t(size_t, sizeof(bfpt),\n\t\t    bfpt_header->length * sizeof(u32));\n\taddr = SFDP_PARAM_HEADER_PTP(bfpt_header);\n\tmemset(&bfpt, 0, sizeof(bfpt));\n\terr = spi_nor_read_sfdp_dma_unsafe(nor,  addr, len, &bfpt);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\tle32_to_cpu_array(bfpt.dwords, BFPT_DWORD_MAX);\n\n\t \n\tswitch (bfpt.dwords[SFDP_DWORD(1)] & BFPT_DWORD1_ADDRESS_BYTES_MASK) {\n\tcase BFPT_DWORD1_ADDRESS_BYTES_3_ONLY:\n\tcase BFPT_DWORD1_ADDRESS_BYTES_3_OR_4:\n\t\tparams->addr_nbytes = 3;\n\t\tparams->addr_mode_nbytes = 3;\n\t\tbreak;\n\n\tcase BFPT_DWORD1_ADDRESS_BYTES_4_ONLY:\n\t\tparams->addr_nbytes = 4;\n\t\tparams->addr_mode_nbytes = 4;\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\t \n\tval = bfpt.dwords[SFDP_DWORD(2)];\n\tif (val & BIT(31)) {\n\t\tval &= ~BIT(31);\n\n\t\t \n\t\tif (val > 63)\n\t\t\treturn -EINVAL;\n\n\t\tparams->size = 1ULL << val;\n\t} else {\n\t\tparams->size = val + 1;\n\t}\n\tparams->size >>= 3;  \n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(sfdp_bfpt_reads); i++) {\n\t\tconst struct sfdp_bfpt_read *rd = &sfdp_bfpt_reads[i];\n\t\tstruct spi_nor_read_command *read;\n\n\t\tif (!(bfpt.dwords[rd->supported_dword] & rd->supported_bit)) {\n\t\t\tparams->hwcaps.mask &= ~rd->hwcaps;\n\t\t\tcontinue;\n\t\t}\n\n\t\tparams->hwcaps.mask |= rd->hwcaps;\n\t\tcmd = spi_nor_hwcaps_read2cmd(rd->hwcaps);\n\t\tread = &params->reads[cmd];\n\t\thalf = bfpt.dwords[rd->settings_dword] >> rd->settings_shift;\n\t\tspi_nor_set_read_settings_from_bfpt(read, half, rd->proto);\n\t}\n\n\t \n\terase_mask = 0;\n\tmemset(&params->erase_map, 0, sizeof(params->erase_map));\n\tfor (i = 0; i < ARRAY_SIZE(sfdp_bfpt_erases); i++) {\n\t\tconst struct sfdp_bfpt_erase *er = &sfdp_bfpt_erases[i];\n\t\tu32 erasesize;\n\t\tu8 opcode;\n\n\t\thalf = bfpt.dwords[er->dword] >> er->shift;\n\t\terasesize = half & 0xff;\n\n\t\t \n\t\tif (!erasesize)\n\t\t\tcontinue;\n\n\t\terasesize = 1U << erasesize;\n\t\topcode = (half >> 8) & 0xff;\n\t\terase_mask |= BIT(i);\n\t\tspi_nor_set_erase_settings_from_bfpt(&erase_type[i], erasesize,\n\t\t\t\t\t\t     opcode, i);\n\t}\n\tspi_nor_init_uniform_erase_map(map, erase_mask, params->size);\n\t \n\tsort(erase_type, SNOR_ERASE_TYPE_MAX, sizeof(erase_type[0]),\n\t     spi_nor_map_cmp_erase_type, NULL);\n\t \n\tspi_nor_regions_sort_erase_types(map);\n\tmap->uniform_erase_type = map->uniform_region.offset &\n\t\t\t\t  SNOR_ERASE_TYPE_MASK;\n\n\t \n\tif (bfpt_header->length == BFPT_DWORD_MAX_JESD216)\n\t\treturn spi_nor_post_bfpt_fixups(nor, bfpt_header, &bfpt);\n\n\t \n\tval = bfpt.dwords[SFDP_DWORD(11)];\n\tval &= BFPT_DWORD11_PAGE_SIZE_MASK;\n\tval >>= BFPT_DWORD11_PAGE_SIZE_SHIFT;\n\tparams->page_size = 1U << val;\n\n\t \n\tswitch (bfpt.dwords[SFDP_DWORD(15)] & BFPT_DWORD15_QER_MASK) {\n\tcase BFPT_DWORD15_QER_NONE:\n\t\tparams->quad_enable = NULL;\n\t\tbreak;\n\n\tcase BFPT_DWORD15_QER_SR2_BIT1_BUGGY:\n\t\t \n\tcase BFPT_DWORD15_QER_SR2_BIT1_NO_RD:\n\t\t \n\t\tnor->flags |= SNOR_F_HAS_16BIT_SR | SNOR_F_NO_READ_CR;\n\t\tparams->quad_enable = spi_nor_sr2_bit1_quad_enable;\n\t\tbreak;\n\n\tcase BFPT_DWORD15_QER_SR1_BIT6:\n\t\tnor->flags &= ~SNOR_F_HAS_16BIT_SR;\n\t\tparams->quad_enable = spi_nor_sr1_bit6_quad_enable;\n\t\tbreak;\n\n\tcase BFPT_DWORD15_QER_SR2_BIT7:\n\t\tnor->flags &= ~SNOR_F_HAS_16BIT_SR;\n\t\tparams->quad_enable = spi_nor_sr2_bit7_quad_enable;\n\t\tbreak;\n\n\tcase BFPT_DWORD15_QER_SR2_BIT1:\n\t\t \n\t\tnor->flags |= SNOR_F_HAS_16BIT_SR;\n\n\t\tparams->quad_enable = spi_nor_sr2_bit1_quad_enable;\n\t\tbreak;\n\n\tdefault:\n\t\tdev_dbg(nor->dev, \"BFPT QER reserved value used\\n\");\n\t\tbreak;\n\t}\n\n\tdword = bfpt.dwords[SFDP_DWORD(16)] & BFPT_DWORD16_4B_ADDR_MODE_MASK;\n\tif (SFDP_MASK_CHECK(dword, BFPT_DWORD16_4B_ADDR_MODE_BRWR))\n\t\tparams->set_4byte_addr_mode = spi_nor_set_4byte_addr_mode_brwr;\n\telse if (SFDP_MASK_CHECK(dword, BFPT_DWORD16_4B_ADDR_MODE_WREN_EN4B_EX4B))\n\t\tparams->set_4byte_addr_mode = spi_nor_set_4byte_addr_mode_wren_en4b_ex4b;\n\telse if (SFDP_MASK_CHECK(dword, BFPT_DWORD16_4B_ADDR_MODE_EN4B_EX4B))\n\t\tparams->set_4byte_addr_mode = spi_nor_set_4byte_addr_mode_en4b_ex4b;\n\telse\n\t\tdev_dbg(nor->dev, \"BFPT: 4-Byte Address Mode method is not recognized or not implemented\\n\");\n\n\t \n\tif (bfpt.dwords[SFDP_DWORD(16)] & BFPT_DWORD16_SWRST_EN_RST)\n\t\tnor->flags |= SNOR_F_SOFT_RESET;\n\n\t \n\tif (bfpt_header->length == BFPT_DWORD_MAX_JESD216B)\n\t\treturn spi_nor_post_bfpt_fixups(nor, bfpt_header, &bfpt);\n\n\t \n\tswitch (bfpt.dwords[SFDP_DWORD(18)] & BFPT_DWORD18_CMD_EXT_MASK) {\n\tcase BFPT_DWORD18_CMD_EXT_REP:\n\t\tnor->cmd_ext_type = SPI_NOR_EXT_REPEAT;\n\t\tbreak;\n\n\tcase BFPT_DWORD18_CMD_EXT_INV:\n\t\tnor->cmd_ext_type = SPI_NOR_EXT_INVERT;\n\t\tbreak;\n\n\tcase BFPT_DWORD18_CMD_EXT_RES:\n\t\tdev_dbg(nor->dev, \"Reserved command extension used\\n\");\n\t\tbreak;\n\n\tcase BFPT_DWORD18_CMD_EXT_16B:\n\t\tdev_dbg(nor->dev, \"16-bit opcodes not supported\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn spi_nor_post_bfpt_fixups(nor, bfpt_header, &bfpt);\n}\n\n \nstatic u8 spi_nor_smpt_addr_nbytes(const struct spi_nor *nor, const u32 settings)\n{\n\tswitch (settings & SMPT_CMD_ADDRESS_LEN_MASK) {\n\tcase SMPT_CMD_ADDRESS_LEN_0:\n\t\treturn 0;\n\tcase SMPT_CMD_ADDRESS_LEN_3:\n\t\treturn 3;\n\tcase SMPT_CMD_ADDRESS_LEN_4:\n\t\treturn 4;\n\tcase SMPT_CMD_ADDRESS_LEN_USE_CURRENT:\n\tdefault:\n\t\treturn nor->params->addr_mode_nbytes;\n\t}\n}\n\n \nstatic u8 spi_nor_smpt_read_dummy(const struct spi_nor *nor, const u32 settings)\n{\n\tu8 read_dummy = SMPT_CMD_READ_DUMMY(settings);\n\n\tif (read_dummy == SMPT_CMD_READ_DUMMY_IS_VARIABLE)\n\t\treturn nor->read_dummy;\n\treturn read_dummy;\n}\n\n \nstatic const u32 *spi_nor_get_map_in_use(struct spi_nor *nor, const u32 *smpt,\n\t\t\t\t\t u8 smpt_len)\n{\n\tconst u32 *ret;\n\tu8 *buf;\n\tu32 addr;\n\tint err;\n\tu8 i;\n\tu8 addr_nbytes, read_opcode, read_dummy;\n\tu8 read_data_mask, map_id;\n\n\t \n\tbuf = kmalloc(sizeof(*buf), GFP_KERNEL);\n\tif (!buf)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\taddr_nbytes = nor->addr_nbytes;\n\tread_dummy = nor->read_dummy;\n\tread_opcode = nor->read_opcode;\n\n\tmap_id = 0;\n\t \n\tfor (i = 0; i < smpt_len; i += 2) {\n\t\tif (smpt[i] & SMPT_DESC_TYPE_MAP)\n\t\t\tbreak;\n\n\t\tread_data_mask = SMPT_CMD_READ_DATA(smpt[i]);\n\t\tnor->addr_nbytes = spi_nor_smpt_addr_nbytes(nor, smpt[i]);\n\t\tnor->read_dummy = spi_nor_smpt_read_dummy(nor, smpt[i]);\n\t\tnor->read_opcode = SMPT_CMD_OPCODE(smpt[i]);\n\t\taddr = smpt[i + 1];\n\n\t\terr = spi_nor_read_raw(nor, addr, 1, buf);\n\t\tif (err) {\n\t\t\tret = ERR_PTR(err);\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\tmap_id = map_id << 1 | !!(*buf & read_data_mask);\n\t}\n\n\t \n\tret = ERR_PTR(-EINVAL);\n\twhile (i < smpt_len) {\n\t\tif (SMPT_MAP_ID(smpt[i]) == map_id) {\n\t\t\tret = smpt + i;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (smpt[i] & SMPT_DESC_END)\n\t\t\tbreak;\n\n\t\t \n\t\ti += SMPT_MAP_REGION_COUNT(smpt[i]) + 1;\n\t}\n\n\t \nout:\n\tkfree(buf);\n\tnor->addr_nbytes = addr_nbytes;\n\tnor->read_dummy = read_dummy;\n\tnor->read_opcode = read_opcode;\n\treturn ret;\n}\n\nstatic void spi_nor_region_mark_end(struct spi_nor_erase_region *region)\n{\n\tregion->offset |= SNOR_LAST_REGION;\n}\n\nstatic void spi_nor_region_mark_overlay(struct spi_nor_erase_region *region)\n{\n\tregion->offset |= SNOR_OVERLAID_REGION;\n}\n\n \nstatic void\nspi_nor_region_check_overlay(struct spi_nor_erase_region *region,\n\t\t\t     const struct spi_nor_erase_type *erase,\n\t\t\t     const u8 erase_type)\n{\n\tint i;\n\n\tfor (i = 0; i < SNOR_ERASE_TYPE_MAX; i++) {\n\t\tif (!(erase[i].size && erase_type & BIT(erase[i].idx)))\n\t\t\tcontinue;\n\t\tif (region->size & erase[i].size_mask) {\n\t\t\tspi_nor_region_mark_overlay(region);\n\t\t\treturn;\n\t\t}\n\t}\n}\n\n \nstatic int spi_nor_init_non_uniform_erase_map(struct spi_nor *nor,\n\t\t\t\t\t      const u32 *smpt)\n{\n\tstruct spi_nor_erase_map *map = &nor->params->erase_map;\n\tstruct spi_nor_erase_type *erase = map->erase_type;\n\tstruct spi_nor_erase_region *region;\n\tu64 offset;\n\tu32 region_count;\n\tint i, j;\n\tu8 uniform_erase_type, save_uniform_erase_type;\n\tu8 erase_type, regions_erase_type;\n\n\tregion_count = SMPT_MAP_REGION_COUNT(*smpt);\n\t \n\tregion = devm_kcalloc(nor->dev, region_count, sizeof(*region),\n\t\t\t      GFP_KERNEL);\n\tif (!region)\n\t\treturn -ENOMEM;\n\tmap->regions = region;\n\n\tuniform_erase_type = 0xff;\n\tregions_erase_type = 0;\n\toffset = 0;\n\t \n\tfor (i = 0; i < region_count; i++) {\n\t\tj = i + 1;  \n\t\tregion[i].size = SMPT_MAP_REGION_SIZE(smpt[j]);\n\t\terase_type = SMPT_MAP_REGION_ERASE_TYPE(smpt[j]);\n\t\tregion[i].offset = offset | erase_type;\n\n\t\tspi_nor_region_check_overlay(&region[i], erase, erase_type);\n\n\t\t \n\t\tuniform_erase_type &= erase_type;\n\n\t\t \n\t\tregions_erase_type |= erase_type;\n\n\t\toffset = (region[i].offset & ~SNOR_ERASE_FLAGS_MASK) +\n\t\t\t region[i].size;\n\t}\n\tspi_nor_region_mark_end(&region[i - 1]);\n\n\tsave_uniform_erase_type = map->uniform_erase_type;\n\tmap->uniform_erase_type = spi_nor_sort_erase_mask(map,\n\t\t\t\t\t\t\t  uniform_erase_type);\n\n\tif (!regions_erase_type) {\n\t\t \n\t\tmap->uniform_erase_type = save_uniform_erase_type;\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tfor (i = 0; i < SNOR_ERASE_TYPE_MAX; i++)\n\t\tif (!(regions_erase_type & BIT(erase[i].idx)))\n\t\t\tspi_nor_mask_erase_type(&erase[i]);\n\n\treturn 0;\n}\n\n \nstatic int spi_nor_parse_smpt(struct spi_nor *nor,\n\t\t\t      const struct sfdp_parameter_header *smpt_header)\n{\n\tconst u32 *sector_map;\n\tu32 *smpt;\n\tsize_t len;\n\tu32 addr;\n\tint ret;\n\n\t \n\tlen = smpt_header->length * sizeof(*smpt);\n\tsmpt = kmalloc(len, GFP_KERNEL);\n\tif (!smpt)\n\t\treturn -ENOMEM;\n\n\taddr = SFDP_PARAM_HEADER_PTP(smpt_header);\n\tret = spi_nor_read_sfdp(nor, addr, len, smpt);\n\tif (ret)\n\t\tgoto out;\n\n\t \n\tle32_to_cpu_array(smpt, smpt_header->length);\n\n\tsector_map = spi_nor_get_map_in_use(nor, smpt, smpt_header->length);\n\tif (IS_ERR(sector_map)) {\n\t\tret = PTR_ERR(sector_map);\n\t\tgoto out;\n\t}\n\n\tret = spi_nor_init_non_uniform_erase_map(nor, sector_map);\n\tif (ret)\n\t\tgoto out;\n\n\tspi_nor_regions_sort_erase_types(&nor->params->erase_map);\n\t \nout:\n\tkfree(smpt);\n\treturn ret;\n}\n\n \nstatic int spi_nor_parse_4bait(struct spi_nor *nor,\n\t\t\t       const struct sfdp_parameter_header *param_header)\n{\n\tstatic const struct sfdp_4bait reads[] = {\n\t\t{ SNOR_HWCAPS_READ,\t\tBIT(0) },\n\t\t{ SNOR_HWCAPS_READ_FAST,\tBIT(1) },\n\t\t{ SNOR_HWCAPS_READ_1_1_2,\tBIT(2) },\n\t\t{ SNOR_HWCAPS_READ_1_2_2,\tBIT(3) },\n\t\t{ SNOR_HWCAPS_READ_1_1_4,\tBIT(4) },\n\t\t{ SNOR_HWCAPS_READ_1_4_4,\tBIT(5) },\n\t\t{ SNOR_HWCAPS_READ_1_1_1_DTR,\tBIT(13) },\n\t\t{ SNOR_HWCAPS_READ_1_2_2_DTR,\tBIT(14) },\n\t\t{ SNOR_HWCAPS_READ_1_4_4_DTR,\tBIT(15) },\n\t};\n\tstatic const struct sfdp_4bait programs[] = {\n\t\t{ SNOR_HWCAPS_PP,\t\tBIT(6) },\n\t\t{ SNOR_HWCAPS_PP_1_1_4,\t\tBIT(7) },\n\t\t{ SNOR_HWCAPS_PP_1_4_4,\t\tBIT(8) },\n\t};\n\tstatic const struct sfdp_4bait erases[SNOR_ERASE_TYPE_MAX] = {\n\t\t{ 0u  ,\t\tBIT(9) },\n\t\t{ 0u  ,\t\tBIT(10) },\n\t\t{ 0u  ,\t\tBIT(11) },\n\t\t{ 0u  ,\t\tBIT(12) },\n\t};\n\tstruct spi_nor_flash_parameter *params = nor->params;\n\tstruct spi_nor_pp_command *params_pp = params->page_programs;\n\tstruct spi_nor_erase_map *map = &params->erase_map;\n\tstruct spi_nor_erase_type *erase_type = map->erase_type;\n\tu32 *dwords;\n\tsize_t len;\n\tu32 addr, discard_hwcaps, read_hwcaps, pp_hwcaps, erase_mask;\n\tint i, ret;\n\n\tif (param_header->major != SFDP_JESD216_MAJOR ||\n\t    param_header->length < SFDP_4BAIT_DWORD_MAX)\n\t\treturn -EINVAL;\n\n\t \n\tlen = sizeof(*dwords) * SFDP_4BAIT_DWORD_MAX;\n\n\t \n\tdwords = kmalloc(len, GFP_KERNEL);\n\tif (!dwords)\n\t\treturn -ENOMEM;\n\n\taddr = SFDP_PARAM_HEADER_PTP(param_header);\n\tret = spi_nor_read_sfdp(nor, addr, len, dwords);\n\tif (ret)\n\t\tgoto out;\n\n\t \n\tle32_to_cpu_array(dwords, SFDP_4BAIT_DWORD_MAX);\n\n\t \n\tdiscard_hwcaps = 0;\n\tread_hwcaps = 0;\n\tfor (i = 0; i < ARRAY_SIZE(reads); i++) {\n\t\tconst struct sfdp_4bait *read = &reads[i];\n\n\t\tdiscard_hwcaps |= read->hwcaps;\n\t\tif ((params->hwcaps.mask & read->hwcaps) &&\n\t\t    (dwords[SFDP_DWORD(1)] & read->supported_bit))\n\t\t\tread_hwcaps |= read->hwcaps;\n\t}\n\n\t \n\tpp_hwcaps = 0;\n\tfor (i = 0; i < ARRAY_SIZE(programs); i++) {\n\t\tconst struct sfdp_4bait *program = &programs[i];\n\n\t\t \n\t\tdiscard_hwcaps |= program->hwcaps;\n\t\tif (dwords[SFDP_DWORD(1)] & program->supported_bit)\n\t\t\tpp_hwcaps |= program->hwcaps;\n\t}\n\n\t \n\terase_mask = 0;\n\tfor (i = 0; i < SNOR_ERASE_TYPE_MAX; i++) {\n\t\tconst struct sfdp_4bait *erase = &erases[i];\n\n\t\tif (dwords[SFDP_DWORD(1)] & erase->supported_bit)\n\t\t\terase_mask |= BIT(i);\n\t}\n\n\t \n\terase_mask = spi_nor_sort_erase_mask(map, erase_mask);\n\n\t \n\tif (!read_hwcaps || !pp_hwcaps || !erase_mask)\n\t\tgoto out;\n\n\t \n\tparams->hwcaps.mask &= ~discard_hwcaps;\n\tparams->hwcaps.mask |= (read_hwcaps | pp_hwcaps);\n\n\t \n\tfor (i = 0; i < SNOR_CMD_READ_MAX; i++) {\n\t\tstruct spi_nor_read_command *read_cmd = &params->reads[i];\n\n\t\tread_cmd->opcode = spi_nor_convert_3to4_read(read_cmd->opcode);\n\t}\n\n\t \n\tif (pp_hwcaps & SNOR_HWCAPS_PP) {\n\t\tspi_nor_set_pp_settings(&params_pp[SNOR_CMD_PP],\n\t\t\t\t\tSPINOR_OP_PP_4B, SNOR_PROTO_1_1_1);\n\t\t \n\t\tspi_nor_set_pp_settings(&params_pp[SNOR_CMD_PP_8_8_8_DTR],\n\t\t\t\t\tSPINOR_OP_PP_4B, SNOR_PROTO_8_8_8_DTR);\n\t}\n\tif (pp_hwcaps & SNOR_HWCAPS_PP_1_1_4)\n\t\tspi_nor_set_pp_settings(&params_pp[SNOR_CMD_PP_1_1_4],\n\t\t\t\t\tSPINOR_OP_PP_1_1_4_4B,\n\t\t\t\t\tSNOR_PROTO_1_1_4);\n\tif (pp_hwcaps & SNOR_HWCAPS_PP_1_4_4)\n\t\tspi_nor_set_pp_settings(&params_pp[SNOR_CMD_PP_1_4_4],\n\t\t\t\t\tSPINOR_OP_PP_1_4_4_4B,\n\t\t\t\t\tSNOR_PROTO_1_4_4);\n\n\tfor (i = 0; i < SNOR_ERASE_TYPE_MAX; i++) {\n\t\tif (erase_mask & BIT(i))\n\t\t\terase_type[i].opcode = (dwords[SFDP_DWORD(2)] >>\n\t\t\t\t\t\terase_type[i].idx * 8) & 0xFF;\n\t\telse\n\t\t\tspi_nor_mask_erase_type(&erase_type[i]);\n\t}\n\n\t \n\tparams->addr_nbytes = 4;\n\tnor->flags |= SNOR_F_4B_OPCODES | SNOR_F_HAS_4BAIT;\n\n\t \nout:\n\tkfree(dwords);\n\treturn ret;\n}\n\n#define PROFILE1_DWORD1_RDSR_ADDR_BYTES\t\tBIT(29)\n#define PROFILE1_DWORD1_RDSR_DUMMY\t\tBIT(28)\n#define PROFILE1_DWORD1_RD_FAST_CMD\t\tGENMASK(15, 8)\n#define PROFILE1_DWORD4_DUMMY_200MHZ\t\tGENMASK(11, 7)\n#define PROFILE1_DWORD5_DUMMY_166MHZ\t\tGENMASK(31, 27)\n#define PROFILE1_DWORD5_DUMMY_133MHZ\t\tGENMASK(21, 17)\n#define PROFILE1_DWORD5_DUMMY_100MHZ\t\tGENMASK(11, 7)\n\n \nstatic int spi_nor_parse_profile1(struct spi_nor *nor,\n\t\t\t\t  const struct sfdp_parameter_header *profile1_header)\n{\n\tu32 *dwords, addr;\n\tsize_t len;\n\tint ret;\n\tu8 dummy, opcode;\n\n\tlen = profile1_header->length * sizeof(*dwords);\n\tdwords = kmalloc(len, GFP_KERNEL);\n\tif (!dwords)\n\t\treturn -ENOMEM;\n\n\taddr = SFDP_PARAM_HEADER_PTP(profile1_header);\n\tret = spi_nor_read_sfdp(nor, addr, len, dwords);\n\tif (ret)\n\t\tgoto out;\n\n\tle32_to_cpu_array(dwords, profile1_header->length);\n\n\t \n\topcode = FIELD_GET(PROFILE1_DWORD1_RD_FAST_CMD, dwords[SFDP_DWORD(1)]);\n\n\t  \n\tif (dwords[SFDP_DWORD(1)] & PROFILE1_DWORD1_RDSR_DUMMY)\n\t\tnor->params->rdsr_dummy = 8;\n\telse\n\t\tnor->params->rdsr_dummy = 4;\n\n\tif (dwords[SFDP_DWORD(1)] & PROFILE1_DWORD1_RDSR_ADDR_BYTES)\n\t\tnor->params->rdsr_addr_nbytes = 4;\n\telse\n\t\tnor->params->rdsr_addr_nbytes = 0;\n\n\t \n\tdummy = FIELD_GET(PROFILE1_DWORD4_DUMMY_200MHZ, dwords[SFDP_DWORD(4)]);\n\tif (!dummy)\n\t\tdummy = FIELD_GET(PROFILE1_DWORD5_DUMMY_166MHZ,\n\t\t\t\t  dwords[SFDP_DWORD(5)]);\n\tif (!dummy)\n\t\tdummy = FIELD_GET(PROFILE1_DWORD5_DUMMY_133MHZ,\n\t\t\t\t  dwords[SFDP_DWORD(5)]);\n\tif (!dummy)\n\t\tdummy = FIELD_GET(PROFILE1_DWORD5_DUMMY_100MHZ,\n\t\t\t\t  dwords[SFDP_DWORD(5)]);\n\tif (!dummy)\n\t\tdev_dbg(nor->dev,\n\t\t\t\"Can't find dummy cycles from Profile 1.0 table\\n\");\n\n\t \n\tdummy = round_up(dummy, 2);\n\n\t \n\tnor->params->hwcaps.mask |= SNOR_HWCAPS_READ_8_8_8_DTR;\n\tspi_nor_set_read_settings(&nor->params->reads[SNOR_CMD_READ_8_8_8_DTR],\n\t\t\t\t  0, dummy, opcode,\n\t\t\t\t  SNOR_PROTO_8_8_8_DTR);\n\n\t \n\tnor->params->hwcaps.mask |= SNOR_HWCAPS_PP_8_8_8_DTR;\n\nout:\n\tkfree(dwords);\n\treturn ret;\n}\n\n#define SCCR_DWORD22_OCTAL_DTR_EN_VOLATILE\t\tBIT(31)\n\n \nstatic int spi_nor_parse_sccr(struct spi_nor *nor,\n\t\t\t      const struct sfdp_parameter_header *sccr_header)\n{\n\tstruct spi_nor_flash_parameter *params = nor->params;\n\tu32 *dwords, addr;\n\tsize_t len;\n\tint ret;\n\n\tlen = sccr_header->length * sizeof(*dwords);\n\tdwords = kmalloc(len, GFP_KERNEL);\n\tif (!dwords)\n\t\treturn -ENOMEM;\n\n\taddr = SFDP_PARAM_HEADER_PTP(sccr_header);\n\tret = spi_nor_read_sfdp(nor, addr, len, dwords);\n\tif (ret)\n\t\tgoto out;\n\n\tle32_to_cpu_array(dwords, sccr_header->length);\n\n\t \n\tif (!params->vreg_offset) {\n\t\tparams->vreg_offset = devm_kmalloc(nor->dev, sizeof(*dwords),\n\t\t\t\t\t\t   GFP_KERNEL);\n\t\tif (!params->vreg_offset) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tparams->vreg_offset[0] = dwords[SFDP_DWORD(1)];\n\tparams->n_dice = 1;\n\n\tif (FIELD_GET(SCCR_DWORD22_OCTAL_DTR_EN_VOLATILE,\n\t\t      dwords[SFDP_DWORD(22)]))\n\t\tnor->flags |= SNOR_F_IO_MODE_EN_VOLATILE;\n\nout:\n\tkfree(dwords);\n\treturn ret;\n}\n\n \nstatic int spi_nor_parse_sccr_mc(struct spi_nor *nor,\n\t\t\t\t const struct sfdp_parameter_header *sccr_mc_header)\n{\n\tstruct spi_nor_flash_parameter *params = nor->params;\n\tu32 *dwords, addr;\n\tu8 i, n_dice;\n\tsize_t len;\n\tint ret;\n\n\tlen = sccr_mc_header->length * sizeof(*dwords);\n\tdwords = kmalloc(len, GFP_KERNEL);\n\tif (!dwords)\n\t\treturn -ENOMEM;\n\n\taddr = SFDP_PARAM_HEADER_PTP(sccr_mc_header);\n\tret = spi_nor_read_sfdp(nor, addr, len, dwords);\n\tif (ret)\n\t\tgoto out;\n\n\tle32_to_cpu_array(dwords, sccr_mc_header->length);\n\n\t \n\tn_dice = 1 + sccr_mc_header->length / 2;\n\n\t \n\tparams->vreg_offset =\n\t\t\tdevm_krealloc(nor->dev, params->vreg_offset,\n\t\t\t\t      n_dice * sizeof(*dwords),\n\t\t\t\t      GFP_KERNEL);\n\tif (!params->vreg_offset) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tfor (i = 1; i < n_dice; i++)\n\t\tparams->vreg_offset[i] = dwords[SFDP_DWORD(i) * 2];\n\n\tparams->n_dice = n_dice;\n\nout:\n\tkfree(dwords);\n\treturn ret;\n}\n\n \nstatic int spi_nor_post_sfdp_fixups(struct spi_nor *nor)\n{\n\tint ret;\n\n\tif (nor->manufacturer && nor->manufacturer->fixups &&\n\t    nor->manufacturer->fixups->post_sfdp) {\n\t\tret = nor->manufacturer->fixups->post_sfdp(nor);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (nor->info->fixups && nor->info->fixups->post_sfdp)\n\t\treturn nor->info->fixups->post_sfdp(nor);\n\n\treturn 0;\n}\n\n \nint spi_nor_check_sfdp_signature(struct spi_nor *nor)\n{\n\tu32 signature;\n\tint err;\n\n\t \n\terr = spi_nor_read_sfdp_dma_unsafe(nor, 0, sizeof(signature),\n\t\t\t\t\t   &signature);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\tif (le32_to_cpu(signature) != SFDP_SIGNATURE)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\n \nint spi_nor_parse_sfdp(struct spi_nor *nor)\n{\n\tconst struct sfdp_parameter_header *param_header, *bfpt_header;\n\tstruct sfdp_parameter_header *param_headers = NULL;\n\tstruct sfdp_header header;\n\tstruct device *dev = nor->dev;\n\tstruct sfdp *sfdp;\n\tsize_t sfdp_size;\n\tsize_t psize;\n\tint i, err;\n\n\t \n\terr = spi_nor_read_sfdp_dma_unsafe(nor, 0, sizeof(header), &header);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\tif (le32_to_cpu(header.signature) != SFDP_SIGNATURE ||\n\t    header.major != SFDP_JESD216_MAJOR)\n\t\treturn -EINVAL;\n\n\t \n\tbfpt_header = &header.bfpt_header;\n\tif (SFDP_PARAM_HEADER_ID(bfpt_header) != SFDP_BFPT_ID ||\n\t    bfpt_header->major != SFDP_JESD216_MAJOR)\n\t\treturn -EINVAL;\n\n\tsfdp_size = SFDP_PARAM_HEADER_PTP(bfpt_header) +\n\t\t    SFDP_PARAM_HEADER_PARAM_LEN(bfpt_header);\n\n\t \n\tif (header.nph) {\n\t\tpsize = header.nph * sizeof(*param_headers);\n\n\t\tparam_headers = kmalloc(psize, GFP_KERNEL);\n\t\tif (!param_headers)\n\t\t\treturn -ENOMEM;\n\n\t\terr = spi_nor_read_sfdp(nor, sizeof(header),\n\t\t\t\t\tpsize, param_headers);\n\t\tif (err < 0) {\n\t\t\tdev_dbg(dev, \"failed to read SFDP parameter headers\\n\");\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < header.nph; i++) {\n\t\tparam_header = &param_headers[i];\n\t\tsfdp_size = max_t(size_t, sfdp_size,\n\t\t\t\t  SFDP_PARAM_HEADER_PTP(param_header) +\n\t\t\t\t  SFDP_PARAM_HEADER_PARAM_LEN(param_header));\n\t}\n\n\t \n\tif (sfdp_size > PAGE_SIZE) {\n\t\tdev_dbg(dev, \"SFDP data (%zu) too big, truncating\\n\",\n\t\t\tsfdp_size);\n\t\tsfdp_size = PAGE_SIZE;\n\t}\n\n\tsfdp = devm_kzalloc(dev, sizeof(*sfdp), GFP_KERNEL);\n\tif (!sfdp) {\n\t\terr = -ENOMEM;\n\t\tgoto exit;\n\t}\n\n\t \n\tsfdp->num_dwords = DIV_ROUND_UP(sfdp_size, sizeof(*sfdp->dwords));\n\tsfdp->dwords = devm_kcalloc(dev, sfdp->num_dwords,\n\t\t\t\t    sizeof(*sfdp->dwords), GFP_KERNEL);\n\tif (!sfdp->dwords) {\n\t\terr = -ENOMEM;\n\t\tdevm_kfree(dev, sfdp);\n\t\tgoto exit;\n\t}\n\n\terr = spi_nor_read_sfdp(nor, 0, sfdp_size, sfdp->dwords);\n\tif (err < 0) {\n\t\tdev_dbg(dev, \"failed to read SFDP data\\n\");\n\t\tdevm_kfree(dev, sfdp->dwords);\n\t\tdevm_kfree(dev, sfdp);\n\t\tgoto exit;\n\t}\n\n\tnor->sfdp = sfdp;\n\n\t \n\tfor (i = 0; i < header.nph; i++) {\n\t\tparam_header = &param_headers[i];\n\n\t\tif (SFDP_PARAM_HEADER_ID(param_header) == SFDP_BFPT_ID &&\n\t\t    param_header->major == SFDP_JESD216_MAJOR &&\n\t\t    (param_header->minor > bfpt_header->minor ||\n\t\t     (param_header->minor == bfpt_header->minor &&\n\t\t      param_header->length > bfpt_header->length)))\n\t\t\tbfpt_header = param_header;\n\t}\n\n\terr = spi_nor_parse_bfpt(nor, bfpt_header);\n\tif (err)\n\t\tgoto exit;\n\n\t \n\tfor (i = 0; i < header.nph; i++) {\n\t\tparam_header = &param_headers[i];\n\n\t\tswitch (SFDP_PARAM_HEADER_ID(param_header)) {\n\t\tcase SFDP_SECTOR_MAP_ID:\n\t\t\terr = spi_nor_parse_smpt(nor, param_header);\n\t\t\tbreak;\n\n\t\tcase SFDP_4BAIT_ID:\n\t\t\terr = spi_nor_parse_4bait(nor, param_header);\n\t\t\tbreak;\n\n\t\tcase SFDP_PROFILE1_ID:\n\t\t\terr = spi_nor_parse_profile1(nor, param_header);\n\t\t\tbreak;\n\n\t\tcase SFDP_SCCR_MAP_ID:\n\t\t\terr = spi_nor_parse_sccr(nor, param_header);\n\t\t\tbreak;\n\n\t\tcase SFDP_SCCR_MAP_MC_ID:\n\t\t\terr = spi_nor_parse_sccr_mc(nor, param_header);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tif (err) {\n\t\t\tdev_warn(dev, \"Failed to parse optional parameter table: %04x\\n\",\n\t\t\t\t SFDP_PARAM_HEADER_ID(param_header));\n\t\t\t \n\t\t\terr = 0;\n\t\t}\n\t}\n\n\terr = spi_nor_post_sfdp_fixups(nor);\nexit:\n\tkfree(param_headers);\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}