{
  "module_name": "atmel.c",
  "hash_id": "a01901fd94958f38c76beb76dc90dea8c7f29a6ffc3c1910d08734452d70bff0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/spi-nor/atmel.c",
  "human_readable_source": "\n \n\n#include <linux/mtd/spi-nor.h>\n\n#include \"core.h\"\n\n#define ATMEL_SR_GLOBAL_PROTECT_MASK GENMASK(5, 2)\n\n \nstatic int at25fs_nor_lock(struct spi_nor *nor, loff_t ofs, uint64_t len)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic int at25fs_nor_unlock(struct spi_nor *nor, loff_t ofs, uint64_t len)\n{\n\tint ret;\n\n\t \n\tif (ofs || len != nor->params->size)\n\t\treturn -EINVAL;\n\n\t \n\tret = spi_nor_write_sr_and_check(nor, 0);\n\tif (ret)\n\t\tdev_dbg(nor->dev, \"unable to clear BP bits, WP# asserted?\\n\");\n\n\treturn ret;\n}\n\nstatic int at25fs_nor_is_locked(struct spi_nor *nor, loff_t ofs, uint64_t len)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic const struct spi_nor_locking_ops at25fs_nor_locking_ops = {\n\t.lock = at25fs_nor_lock,\n\t.unlock = at25fs_nor_unlock,\n\t.is_locked = at25fs_nor_is_locked,\n};\n\nstatic int at25fs_nor_late_init(struct spi_nor *nor)\n{\n\tnor->params->locking_ops = &at25fs_nor_locking_ops;\n\n\treturn 0;\n}\n\nstatic const struct spi_nor_fixups at25fs_nor_fixups = {\n\t.late_init = at25fs_nor_late_init,\n};\n\n \nstatic int atmel_nor_set_global_protection(struct spi_nor *nor, loff_t ofs,\n\t\t\t\t\t   uint64_t len, bool is_protect)\n{\n\tint ret;\n\tu8 sr;\n\n\t \n\tif (ofs || len != nor->params->size)\n\t\treturn -EINVAL;\n\n\tret = spi_nor_read_sr(nor, nor->bouncebuf);\n\tif (ret)\n\t\treturn ret;\n\n\tsr = nor->bouncebuf[0];\n\n\t \n\tif (sr & SR_SRWD) {\n\t\tsr &= ~SR_SRWD;\n\t\tret = spi_nor_write_sr_and_check(nor, sr);\n\t\tif (ret) {\n\t\t\tdev_dbg(nor->dev, \"unable to clear SRWD bit, WP# asserted?\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (is_protect) {\n\t\tsr |= ATMEL_SR_GLOBAL_PROTECT_MASK;\n\t\t \n\t\tsr |= SR_SRWD;\n\t} else {\n\t\tsr &= ~ATMEL_SR_GLOBAL_PROTECT_MASK;\n\t}\n\n\tnor->bouncebuf[0] = sr;\n\n\t \n\treturn spi_nor_write_sr(nor, nor->bouncebuf, 1);\n}\n\nstatic int atmel_nor_global_protect(struct spi_nor *nor, loff_t ofs,\n\t\t\t\t    uint64_t len)\n{\n\treturn atmel_nor_set_global_protection(nor, ofs, len, true);\n}\n\nstatic int atmel_nor_global_unprotect(struct spi_nor *nor, loff_t ofs,\n\t\t\t\t      uint64_t len)\n{\n\treturn atmel_nor_set_global_protection(nor, ofs, len, false);\n}\n\nstatic int atmel_nor_is_global_protected(struct spi_nor *nor, loff_t ofs,\n\t\t\t\t\t uint64_t len)\n{\n\tint ret;\n\n\tif (ofs >= nor->params->size || (ofs + len) > nor->params->size)\n\t\treturn -EINVAL;\n\n\tret = spi_nor_read_sr(nor, nor->bouncebuf);\n\tif (ret)\n\t\treturn ret;\n\n\treturn ((nor->bouncebuf[0] & ATMEL_SR_GLOBAL_PROTECT_MASK) == ATMEL_SR_GLOBAL_PROTECT_MASK);\n}\n\nstatic const struct spi_nor_locking_ops atmel_nor_global_protection_ops = {\n\t.lock = atmel_nor_global_protect,\n\t.unlock = atmel_nor_global_unprotect,\n\t.is_locked = atmel_nor_is_global_protected,\n};\n\nstatic int atmel_nor_global_protection_late_init(struct spi_nor *nor)\n{\n\tnor->params->locking_ops = &atmel_nor_global_protection_ops;\n\n\treturn 0;\n}\n\nstatic const struct spi_nor_fixups atmel_nor_global_protection_fixups = {\n\t.late_init = atmel_nor_global_protection_late_init,\n};\n\nstatic const struct flash_info atmel_nor_parts[] = {\n\t \n\t{ \"at25fs010\",  INFO(0x1f6601, 0, 32 * 1024,   4)\n\t\tFLAGS(SPI_NOR_HAS_LOCK)\n\t\tNO_SFDP_FLAGS(SECT_4K)\n\t\t.fixups = &at25fs_nor_fixups },\n\t{ \"at25fs040\",  INFO(0x1f6604, 0, 64 * 1024,   8)\n\t\tFLAGS(SPI_NOR_HAS_LOCK)\n\t\tNO_SFDP_FLAGS(SECT_4K)\n\t\t.fixups = &at25fs_nor_fixups },\n\t{ \"at25df041a\", INFO(0x1f4401, 0, 64 * 1024,   8)\n\t\tFLAGS(SPI_NOR_HAS_LOCK | SPI_NOR_SWP_IS_VOLATILE)\n\t\tNO_SFDP_FLAGS(SECT_4K)\n\t\t.fixups = &atmel_nor_global_protection_fixups },\n\t{ \"at25df321\",  INFO(0x1f4700, 0, 64 * 1024,  64)\n\t\tFLAGS(SPI_NOR_HAS_LOCK | SPI_NOR_SWP_IS_VOLATILE)\n\t\tNO_SFDP_FLAGS(SECT_4K)\n\t\t.fixups = &atmel_nor_global_protection_fixups },\n\t{ \"at25df321a\", INFO(0x1f4701, 0, 64 * 1024,  64)\n\t\tFLAGS(SPI_NOR_HAS_LOCK | SPI_NOR_SWP_IS_VOLATILE)\n\t\tNO_SFDP_FLAGS(SECT_4K)\n\t\t.fixups = &atmel_nor_global_protection_fixups },\n\t{ \"at25df641\",  INFO(0x1f4800, 0, 64 * 1024, 128)\n\t\tFLAGS(SPI_NOR_HAS_LOCK | SPI_NOR_SWP_IS_VOLATILE)\n\t\tNO_SFDP_FLAGS(SECT_4K)\n\t\t.fixups = &atmel_nor_global_protection_fixups },\n\t{ \"at25sl321\",\tINFO(0x1f4216, 0, 64 * 1024, 64)\n\t\tNO_SFDP_FLAGS(SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ) },\n\t{ \"at26f004\",   INFO(0x1f0400, 0, 64 * 1024,  8)\n\t\tNO_SFDP_FLAGS(SECT_4K) },\n\t{ \"at26df081a\", INFO(0x1f4501, 0, 64 * 1024, 16)\n\t\tFLAGS(SPI_NOR_HAS_LOCK | SPI_NOR_SWP_IS_VOLATILE)\n\t\tNO_SFDP_FLAGS(SECT_4K)\n\t\t.fixups = &atmel_nor_global_protection_fixups },\n\t{ \"at26df161a\", INFO(0x1f4601, 0, 64 * 1024, 32)\n\t\tFLAGS(SPI_NOR_HAS_LOCK | SPI_NOR_SWP_IS_VOLATILE)\n\t\tNO_SFDP_FLAGS(SECT_4K)\n\t\t.fixups = &atmel_nor_global_protection_fixups },\n\t{ \"at26df321\",  INFO(0x1f4700, 0, 64 * 1024, 64)\n\t\tFLAGS(SPI_NOR_HAS_LOCK | SPI_NOR_SWP_IS_VOLATILE)\n\t\tNO_SFDP_FLAGS(SECT_4K)\n\t\t.fixups = &atmel_nor_global_protection_fixups },\n\t{ \"at45db081d\", INFO(0x1f2500, 0, 64 * 1024, 16)\n\t\tNO_SFDP_FLAGS(SECT_4K) },\n};\n\nconst struct spi_nor_manufacturer spi_nor_atmel = {\n\t.name = \"atmel\",\n\t.parts = atmel_nor_parts,\n\t.nparts = ARRAY_SIZE(atmel_nor_parts),\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}