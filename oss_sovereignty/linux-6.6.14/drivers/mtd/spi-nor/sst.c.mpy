{
  "module_name": "sst.c",
  "hash_id": "462bfa01c63fe34e6fae892d84b346fbada96791990e8af635eb02f1ede4ac95",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/spi-nor/sst.c",
  "human_readable_source": "\n \n\n#include <linux/mtd/spi-nor.h>\n\n#include \"core.h\"\n\n \n#define SST_WRITE\t\tBIT(0)\n\n#define SST26VF_CR_BPNV\t\tBIT(3)\n\nstatic int sst26vf_nor_lock(struct spi_nor *nor, loff_t ofs, uint64_t len)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic int sst26vf_nor_unlock(struct spi_nor *nor, loff_t ofs, uint64_t len)\n{\n\tint ret;\n\n\t \n\tif (ofs != 0 || len != nor->params->size)\n\t\treturn -EINVAL;\n\n\tret = spi_nor_read_cr(nor, nor->bouncebuf);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!(nor->bouncebuf[0] & SST26VF_CR_BPNV)) {\n\t\tdev_dbg(nor->dev, \"Any block has been permanently locked\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn spi_nor_global_block_unlock(nor);\n}\n\nstatic int sst26vf_nor_is_locked(struct spi_nor *nor, loff_t ofs, uint64_t len)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic const struct spi_nor_locking_ops sst26vf_nor_locking_ops = {\n\t.lock = sst26vf_nor_lock,\n\t.unlock = sst26vf_nor_unlock,\n\t.is_locked = sst26vf_nor_is_locked,\n};\n\nstatic int sst26vf_nor_late_init(struct spi_nor *nor)\n{\n\tnor->params->locking_ops = &sst26vf_nor_locking_ops;\n\n\treturn 0;\n}\n\nstatic const struct spi_nor_fixups sst26vf_nor_fixups = {\n\t.late_init = sst26vf_nor_late_init,\n};\n\nstatic const struct flash_info sst_nor_parts[] = {\n\t \n\t{ \"sst25vf040b\", INFO(0xbf258d, 0, 64 * 1024,  8)\n\t\tFLAGS(SPI_NOR_HAS_LOCK | SPI_NOR_SWP_IS_VOLATILE)\n\t\tNO_SFDP_FLAGS(SECT_4K)\n\t\tMFR_FLAGS(SST_WRITE) },\n\t{ \"sst25vf080b\", INFO(0xbf258e, 0, 64 * 1024, 16)\n\t\tFLAGS(SPI_NOR_HAS_LOCK | SPI_NOR_SWP_IS_VOLATILE)\n\t\tNO_SFDP_FLAGS(SECT_4K)\n\t\tMFR_FLAGS(SST_WRITE) },\n\t{ \"sst25vf016b\", INFO(0xbf2541, 0, 64 * 1024, 32)\n\t\tFLAGS(SPI_NOR_HAS_LOCK | SPI_NOR_SWP_IS_VOLATILE)\n\t\tNO_SFDP_FLAGS(SECT_4K)\n\t\tMFR_FLAGS(SST_WRITE) },\n\t{ \"sst25vf032b\", INFO(0xbf254a, 0, 64 * 1024, 64)\n\t\tFLAGS(SPI_NOR_HAS_LOCK | SPI_NOR_SWP_IS_VOLATILE)\n\t\tNO_SFDP_FLAGS(SECT_4K)\n\t\tMFR_FLAGS(SST_WRITE) },\n\t{ \"sst25vf064c\", INFO(0xbf254b, 0, 64 * 1024, 128)\n\t\tFLAGS(SPI_NOR_HAS_LOCK | SPI_NOR_4BIT_BP |\n\t\t      SPI_NOR_SWP_IS_VOLATILE)\n\t\tNO_SFDP_FLAGS(SECT_4K) },\n\t{ \"sst25wf512\",  INFO(0xbf2501, 0, 64 * 1024,  1)\n\t\tFLAGS(SPI_NOR_HAS_LOCK | SPI_NOR_SWP_IS_VOLATILE)\n\t\tNO_SFDP_FLAGS(SECT_4K)\n\t\tMFR_FLAGS(SST_WRITE) },\n\t{ \"sst25wf010\",  INFO(0xbf2502, 0, 64 * 1024,  2)\n\t\tFLAGS(SPI_NOR_HAS_LOCK | SPI_NOR_SWP_IS_VOLATILE)\n\t\tNO_SFDP_FLAGS(SECT_4K)\n\t\tMFR_FLAGS(SST_WRITE) },\n\t{ \"sst25wf020\",  INFO(0xbf2503, 0, 64 * 1024,  4)\n\t\tFLAGS(SPI_NOR_HAS_LOCK | SPI_NOR_SWP_IS_VOLATILE)\n\t\tNO_SFDP_FLAGS(SECT_4K)\n\t\tMFR_FLAGS(SST_WRITE) },\n\t{ \"sst25wf020a\", INFO(0x621612, 0, 64 * 1024,  4)\n\t\tFLAGS(SPI_NOR_HAS_LOCK)\n\t\tNO_SFDP_FLAGS(SECT_4K) },\n\t{ \"sst25wf040b\", INFO(0x621613, 0, 64 * 1024,  8)\n\t\tFLAGS(SPI_NOR_HAS_LOCK)\n\t\tNO_SFDP_FLAGS(SECT_4K) },\n\t{ \"sst25wf040\",  INFO(0xbf2504, 0, 64 * 1024,  8)\n\t\tFLAGS(SPI_NOR_HAS_LOCK | SPI_NOR_SWP_IS_VOLATILE)\n\t\tNO_SFDP_FLAGS(SECT_4K)\n\t\tMFR_FLAGS(SST_WRITE) },\n\t{ \"sst25wf080\",  INFO(0xbf2505, 0, 64 * 1024, 16)\n\t\tFLAGS(SPI_NOR_HAS_LOCK | SPI_NOR_SWP_IS_VOLATILE)\n\t\tNO_SFDP_FLAGS(SECT_4K)\n\t\tMFR_FLAGS(SST_WRITE) },\n\t{ \"sst26wf016b\", INFO(0xbf2651, 0, 64 * 1024, 32)\n\t\tNO_SFDP_FLAGS(SECT_4K | SPI_NOR_DUAL_READ |\n\t\t\t      SPI_NOR_QUAD_READ) },\n\t{ \"sst26vf016b\", INFO(0xbf2641, 0, 64 * 1024, 32)\n\t\tNO_SFDP_FLAGS(SECT_4K | SPI_NOR_DUAL_READ) },\n\t{ \"sst26vf032b\", INFO(0xbf2642, 0, 0, 0)\n\t\tFLAGS(SPI_NOR_HAS_LOCK | SPI_NOR_SWP_IS_VOLATILE)\n\t\tPARSE_SFDP\n\t\t.fixups = &sst26vf_nor_fixups },\n\t{ \"sst26vf064b\", INFO(0xbf2643, 0, 64 * 1024, 128)\n\t\tFLAGS(SPI_NOR_HAS_LOCK | SPI_NOR_SWP_IS_VOLATILE)\n\t\tNO_SFDP_FLAGS(SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ)\n\t\t.fixups = &sst26vf_nor_fixups },\n};\n\nstatic int sst_nor_write(struct mtd_info *mtd, loff_t to, size_t len,\n\t\t\t size_t *retlen, const u_char *buf)\n{\n\tstruct spi_nor *nor = mtd_to_spi_nor(mtd);\n\tsize_t actual = 0;\n\tint ret;\n\n\tdev_dbg(nor->dev, \"to 0x%08x, len %zd\\n\", (u32)to, len);\n\n\tret = spi_nor_prep_and_lock(nor);\n\tif (ret)\n\t\treturn ret;\n\n\tret = spi_nor_write_enable(nor);\n\tif (ret)\n\t\tgoto out;\n\n\tnor->sst_write_second = false;\n\n\t \n\tif (to % 2) {\n\t\tnor->program_opcode = SPINOR_OP_BP;\n\n\t\t \n\t\tret = spi_nor_write_data(nor, to, 1, buf);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tWARN(ret != 1, \"While writing 1 byte written %i bytes\\n\", ret);\n\t\tret = spi_nor_wait_till_ready(nor);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\tto++;\n\t\tactual++;\n\t}\n\n\t \n\tfor (; actual < len - 1; actual += 2) {\n\t\tnor->program_opcode = SPINOR_OP_AAI_WP;\n\n\t\t \n\t\tret = spi_nor_write_data(nor, to, 2, buf + actual);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tWARN(ret != 2, \"While writing 2 bytes written %i bytes\\n\", ret);\n\t\tret = spi_nor_wait_till_ready(nor);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tto += 2;\n\t\tnor->sst_write_second = true;\n\t}\n\tnor->sst_write_second = false;\n\n\tret = spi_nor_write_disable(nor);\n\tif (ret)\n\t\tgoto out;\n\n\tret = spi_nor_wait_till_ready(nor);\n\tif (ret)\n\t\tgoto out;\n\n\t \n\tif (actual != len) {\n\t\tret = spi_nor_write_enable(nor);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\tnor->program_opcode = SPINOR_OP_BP;\n\t\tret = spi_nor_write_data(nor, to, 1, buf + actual);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tWARN(ret != 1, \"While writing 1 byte written %i bytes\\n\", ret);\n\t\tret = spi_nor_wait_till_ready(nor);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\tactual += 1;\n\n\t\tret = spi_nor_write_disable(nor);\n\t}\nout:\n\t*retlen += actual;\n\tspi_nor_unlock_and_unprep(nor);\n\treturn ret;\n}\n\nstatic int sst_nor_late_init(struct spi_nor *nor)\n{\n\tif (nor->info->mfr_flags & SST_WRITE)\n\t\tnor->mtd._write = sst_nor_write;\n\n\treturn 0;\n}\n\nstatic const struct spi_nor_fixups sst_nor_fixups = {\n\t.late_init = sst_nor_late_init,\n};\n\nconst struct spi_nor_manufacturer spi_nor_sst = {\n\t.name = \"sst\",\n\t.parts = sst_nor_parts,\n\t.nparts = ARRAY_SIZE(sst_nor_parts),\n\t.fixups = &sst_nor_fixups,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}