{
  "module_name": "nxp-spifi.c",
  "hash_id": "47f5152878bfdd157826515e4b0c609a1746293edb11926e188b3751a26e8147",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/spi-nor/controllers/nxp-spifi.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/module.h>\n#include <linux/mtd/mtd.h>\n#include <linux/mtd/partitions.h>\n#include <linux/mtd/spi-nor.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/spi/spi.h>\n\n \n#define SPIFI_CTRL\t\t\t\t0x000\n#define  SPIFI_CTRL_TIMEOUT(timeout)\t\t(timeout)\n#define  SPIFI_CTRL_CSHIGH(cshigh)\t\t((cshigh) << 16)\n#define  SPIFI_CTRL_MODE3\t\t\tBIT(23)\n#define  SPIFI_CTRL_DUAL\t\t\tBIT(28)\n#define  SPIFI_CTRL_FBCLK\t\t\tBIT(30)\n#define SPIFI_CMD\t\t\t\t0x004\n#define  SPIFI_CMD_DATALEN(dlen)\t\t((dlen) & 0x3fff)\n#define  SPIFI_CMD_DOUT\t\t\t\tBIT(15)\n#define  SPIFI_CMD_INTLEN(ilen)\t\t\t((ilen) << 16)\n#define  SPIFI_CMD_FIELDFORM(field)\t\t((field) << 19)\n#define  SPIFI_CMD_FIELDFORM_ALL_SERIAL\t\tSPIFI_CMD_FIELDFORM(0x0)\n#define  SPIFI_CMD_FIELDFORM_QUAD_DUAL_DATA\tSPIFI_CMD_FIELDFORM(0x1)\n#define  SPIFI_CMD_FRAMEFORM(frame)\t\t((frame) << 21)\n#define  SPIFI_CMD_FRAMEFORM_OPCODE_ONLY\tSPIFI_CMD_FRAMEFORM(0x1)\n#define  SPIFI_CMD_OPCODE(op)\t\t\t((op) << 24)\n#define SPIFI_ADDR\t\t\t\t0x008\n#define SPIFI_IDATA\t\t\t\t0x00c\n#define SPIFI_CLIMIT\t\t\t\t0x010\n#define SPIFI_DATA\t\t\t\t0x014\n#define SPIFI_MCMD\t\t\t\t0x018\n#define SPIFI_STAT\t\t\t\t0x01c\n#define  SPIFI_STAT_MCINIT\t\t\tBIT(0)\n#define  SPIFI_STAT_CMD\t\t\t\tBIT(1)\n#define  SPIFI_STAT_RESET\t\t\tBIT(4)\n\n#define SPI_NOR_MAX_ID_LEN\t6\n\nstruct nxp_spifi {\n\tstruct device *dev;\n\tstruct clk *clk_spifi;\n\tstruct clk *clk_reg;\n\tvoid __iomem *io_base;\n\tvoid __iomem *flash_base;\n\tstruct spi_nor nor;\n\tbool memory_mode;\n\tu32 mcmd;\n};\n\nstatic int nxp_spifi_wait_for_cmd(struct nxp_spifi *spifi)\n{\n\tu8 stat;\n\tint ret;\n\n\tret = readb_poll_timeout(spifi->io_base + SPIFI_STAT, stat,\n\t\t\t\t !(stat & SPIFI_STAT_CMD), 10, 30);\n\tif (ret)\n\t\tdev_warn(spifi->dev, \"command timed out\\n\");\n\n\treturn ret;\n}\n\nstatic int nxp_spifi_reset(struct nxp_spifi *spifi)\n{\n\tu8 stat;\n\tint ret;\n\n\twritel(SPIFI_STAT_RESET, spifi->io_base + SPIFI_STAT);\n\tret = readb_poll_timeout(spifi->io_base + SPIFI_STAT, stat,\n\t\t\t\t !(stat & SPIFI_STAT_RESET), 10, 30);\n\tif (ret)\n\t\tdev_warn(spifi->dev, \"state reset timed out\\n\");\n\n\treturn ret;\n}\n\nstatic int nxp_spifi_set_memory_mode_off(struct nxp_spifi *spifi)\n{\n\tint ret;\n\n\tif (!spifi->memory_mode)\n\t\treturn 0;\n\n\tret = nxp_spifi_reset(spifi);\n\tif (ret)\n\t\tdev_err(spifi->dev, \"unable to enter command mode\\n\");\n\telse\n\t\tspifi->memory_mode = false;\n\n\treturn ret;\n}\n\nstatic int nxp_spifi_set_memory_mode_on(struct nxp_spifi *spifi)\n{\n\tu8 stat;\n\tint ret;\n\n\tif (spifi->memory_mode)\n\t\treturn 0;\n\n\twritel(spifi->mcmd, spifi->io_base + SPIFI_MCMD);\n\tret = readb_poll_timeout(spifi->io_base + SPIFI_STAT, stat,\n\t\t\t\t stat & SPIFI_STAT_MCINIT, 10, 30);\n\tif (ret)\n\t\tdev_err(spifi->dev, \"unable to enter memory mode\\n\");\n\telse\n\t\tspifi->memory_mode = true;\n\n\treturn ret;\n}\n\nstatic int nxp_spifi_read_reg(struct spi_nor *nor, u8 opcode, u8 *buf,\n\t\t\t      size_t len)\n{\n\tstruct nxp_spifi *spifi = nor->priv;\n\tu32 cmd;\n\tint ret;\n\n\tret = nxp_spifi_set_memory_mode_off(spifi);\n\tif (ret)\n\t\treturn ret;\n\n\tcmd = SPIFI_CMD_DATALEN(len) |\n\t      SPIFI_CMD_OPCODE(opcode) |\n\t      SPIFI_CMD_FIELDFORM_ALL_SERIAL |\n\t      SPIFI_CMD_FRAMEFORM_OPCODE_ONLY;\n\twritel(cmd, spifi->io_base + SPIFI_CMD);\n\n\twhile (len--)\n\t\t*buf++ = readb(spifi->io_base + SPIFI_DATA);\n\n\treturn nxp_spifi_wait_for_cmd(spifi);\n}\n\nstatic int nxp_spifi_write_reg(struct spi_nor *nor, u8 opcode, const u8 *buf,\n\t\t\t       size_t len)\n{\n\tstruct nxp_spifi *spifi = nor->priv;\n\tu32 cmd;\n\tint ret;\n\n\tret = nxp_spifi_set_memory_mode_off(spifi);\n\tif (ret)\n\t\treturn ret;\n\n\tcmd = SPIFI_CMD_DOUT |\n\t      SPIFI_CMD_DATALEN(len) |\n\t      SPIFI_CMD_OPCODE(opcode) |\n\t      SPIFI_CMD_FIELDFORM_ALL_SERIAL |\n\t      SPIFI_CMD_FRAMEFORM_OPCODE_ONLY;\n\twritel(cmd, spifi->io_base + SPIFI_CMD);\n\n\twhile (len--)\n\t\twriteb(*buf++, spifi->io_base + SPIFI_DATA);\n\n\treturn nxp_spifi_wait_for_cmd(spifi);\n}\n\nstatic ssize_t nxp_spifi_read(struct spi_nor *nor, loff_t from, size_t len,\n\t\t\t      u_char *buf)\n{\n\tstruct nxp_spifi *spifi = nor->priv;\n\tint ret;\n\n\tret = nxp_spifi_set_memory_mode_on(spifi);\n\tif (ret)\n\t\treturn ret;\n\n\tmemcpy_fromio(buf, spifi->flash_base + from, len);\n\n\treturn len;\n}\n\nstatic ssize_t nxp_spifi_write(struct spi_nor *nor, loff_t to, size_t len,\n\t\t\t       const u_char *buf)\n{\n\tstruct nxp_spifi *spifi = nor->priv;\n\tu32 cmd;\n\tint ret;\n\tsize_t i;\n\n\tret = nxp_spifi_set_memory_mode_off(spifi);\n\tif (ret)\n\t\treturn ret;\n\n\twritel(to, spifi->io_base + SPIFI_ADDR);\n\n\tcmd = SPIFI_CMD_DOUT |\n\t      SPIFI_CMD_DATALEN(len) |\n\t      SPIFI_CMD_FIELDFORM_ALL_SERIAL |\n\t      SPIFI_CMD_OPCODE(nor->program_opcode) |\n\t      SPIFI_CMD_FRAMEFORM(spifi->nor.addr_nbytes + 1);\n\twritel(cmd, spifi->io_base + SPIFI_CMD);\n\n\tfor (i = 0; i < len; i++)\n\t\twriteb(buf[i], spifi->io_base + SPIFI_DATA);\n\n\tret = nxp_spifi_wait_for_cmd(spifi);\n\tif (ret)\n\t\treturn ret;\n\n\treturn len;\n}\n\nstatic int nxp_spifi_erase(struct spi_nor *nor, loff_t offs)\n{\n\tstruct nxp_spifi *spifi = nor->priv;\n\tu32 cmd;\n\tint ret;\n\n\tret = nxp_spifi_set_memory_mode_off(spifi);\n\tif (ret)\n\t\treturn ret;\n\n\twritel(offs, spifi->io_base + SPIFI_ADDR);\n\n\tcmd = SPIFI_CMD_FIELDFORM_ALL_SERIAL |\n\t      SPIFI_CMD_OPCODE(nor->erase_opcode) |\n\t      SPIFI_CMD_FRAMEFORM(spifi->nor.addr_nbytes + 1);\n\twritel(cmd, spifi->io_base + SPIFI_CMD);\n\n\treturn nxp_spifi_wait_for_cmd(spifi);\n}\n\nstatic int nxp_spifi_setup_memory_cmd(struct nxp_spifi *spifi)\n{\n\tswitch (spifi->nor.read_proto) {\n\tcase SNOR_PROTO_1_1_1:\n\t\tspifi->mcmd = SPIFI_CMD_FIELDFORM_ALL_SERIAL;\n\t\tbreak;\n\tcase SNOR_PROTO_1_1_2:\n\tcase SNOR_PROTO_1_1_4:\n\t\tspifi->mcmd = SPIFI_CMD_FIELDFORM_QUAD_DUAL_DATA;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(spifi->dev, \"unsupported SPI read mode\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (spifi->nor.addr_nbytes < 1 || spifi->nor.addr_nbytes > 4)\n\t\treturn -EINVAL;\n\n\tspifi->mcmd |= SPIFI_CMD_OPCODE(spifi->nor.read_opcode) |\n\t\t       SPIFI_CMD_INTLEN(spifi->nor.read_dummy / 8) |\n\t\t       SPIFI_CMD_FRAMEFORM(spifi->nor.addr_nbytes + 1);\n\n\treturn 0;\n}\n\nstatic void nxp_spifi_dummy_id_read(struct spi_nor *nor)\n{\n\tu8 id[SPI_NOR_MAX_ID_LEN];\n\tnor->controller_ops->read_reg(nor, SPINOR_OP_RDID, id,\n\t\t\t\t      SPI_NOR_MAX_ID_LEN);\n}\n\nstatic const struct spi_nor_controller_ops nxp_spifi_controller_ops = {\n\t.read_reg  = nxp_spifi_read_reg,\n\t.write_reg = nxp_spifi_write_reg,\n\t.read  = nxp_spifi_read,\n\t.write = nxp_spifi_write,\n\t.erase = nxp_spifi_erase,\n};\n\nstatic int nxp_spifi_setup_flash(struct nxp_spifi *spifi,\n\t\t\t\t struct device_node *np)\n{\n\tstruct spi_nor_hwcaps hwcaps = {\n\t\t.mask = SNOR_HWCAPS_READ |\n\t\t\tSNOR_HWCAPS_READ_FAST |\n\t\t\tSNOR_HWCAPS_PP,\n\t};\n\tu32 ctrl, property;\n\tu16 mode = 0;\n\tint ret;\n\n\tif (!of_property_read_u32(np, \"spi-rx-bus-width\", &property)) {\n\t\tswitch (property) {\n\t\tcase 1:\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tmode |= SPI_RX_DUAL;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tmode |= SPI_RX_QUAD;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(spifi->dev, \"unsupported rx-bus-width\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (of_property_read_bool(np, \"spi-cpha\"))\n\t\tmode |= SPI_CPHA;\n\n\tif (of_property_read_bool(np, \"spi-cpol\"))\n\t\tmode |= SPI_CPOL;\n\n\t \n\tctrl = SPIFI_CTRL_TIMEOUT(1000) |\n\t       SPIFI_CTRL_CSHIGH(15) |\n\t       SPIFI_CTRL_FBCLK;\n\n\tif (mode & SPI_RX_DUAL) {\n\t\tctrl |= SPIFI_CTRL_DUAL;\n\t\thwcaps.mask |= SNOR_HWCAPS_READ_1_1_2;\n\t} else if (mode & SPI_RX_QUAD) {\n\t\tctrl &= ~SPIFI_CTRL_DUAL;\n\t\thwcaps.mask |= SNOR_HWCAPS_READ_1_1_4;\n\t} else {\n\t\tctrl |= SPIFI_CTRL_DUAL;\n\t}\n\n\tswitch (mode & SPI_MODE_X_MASK) {\n\tcase SPI_MODE_0:\n\t\tctrl &= ~SPIFI_CTRL_MODE3;\n\t\tbreak;\n\tcase SPI_MODE_3:\n\t\tctrl |= SPIFI_CTRL_MODE3;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(spifi->dev, \"only mode 0 and 3 supported\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\twritel(ctrl, spifi->io_base + SPIFI_CTRL);\n\n\tspifi->nor.dev   = spifi->dev;\n\tspi_nor_set_flash_node(&spifi->nor, np);\n\tspifi->nor.priv  = spifi;\n\tspifi->nor.controller_ops = &nxp_spifi_controller_ops;\n\n\t \n\tnxp_spifi_dummy_id_read(&spifi->nor);\n\n\tret = spi_nor_scan(&spifi->nor, NULL, &hwcaps);\n\tif (ret) {\n\t\tdev_err(spifi->dev, \"device scan failed\\n\");\n\t\treturn ret;\n\t}\n\n\tret = nxp_spifi_setup_memory_cmd(spifi);\n\tif (ret) {\n\t\tdev_err(spifi->dev, \"memory command setup failed\\n\");\n\t\treturn ret;\n\t}\n\n\tret = mtd_device_register(&spifi->nor.mtd, NULL, 0);\n\tif (ret) {\n\t\tdev_err(spifi->dev, \"mtd device parse failed\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int nxp_spifi_probe(struct platform_device *pdev)\n{\n\tstruct device_node *flash_np;\n\tstruct nxp_spifi *spifi;\n\tint ret;\n\n\tspifi = devm_kzalloc(&pdev->dev, sizeof(*spifi), GFP_KERNEL);\n\tif (!spifi)\n\t\treturn -ENOMEM;\n\n\tspifi->io_base = devm_platform_ioremap_resource_byname(pdev, \"spifi\");\n\tif (IS_ERR(spifi->io_base))\n\t\treturn PTR_ERR(spifi->io_base);\n\n\tspifi->flash_base = devm_platform_ioremap_resource_byname(pdev, \"flash\");\n\tif (IS_ERR(spifi->flash_base))\n\t\treturn PTR_ERR(spifi->flash_base);\n\n\tspifi->clk_spifi = devm_clk_get_enabled(&pdev->dev, \"spifi\");\n\tif (IS_ERR(spifi->clk_spifi)) {\n\t\tdev_err(&pdev->dev, \"spifi clock not found or unable to enable\\n\");\n\t\treturn PTR_ERR(spifi->clk_spifi);\n\t}\n\n\tspifi->clk_reg = devm_clk_get_enabled(&pdev->dev, \"reg\");\n\tif (IS_ERR(spifi->clk_reg)) {\n\t\tdev_err(&pdev->dev, \"reg clock not found or unable to enable\\n\");\n\t\treturn PTR_ERR(spifi->clk_reg);\n\t}\n\n\tspifi->dev = &pdev->dev;\n\tplatform_set_drvdata(pdev, spifi);\n\n\t \n\tnxp_spifi_reset(spifi);\n\twritel(0, spifi->io_base + SPIFI_IDATA);\n\twritel(0, spifi->io_base + SPIFI_MCMD);\n\tnxp_spifi_reset(spifi);\n\n\tflash_np = of_get_next_available_child(pdev->dev.of_node, NULL);\n\tif (!flash_np) {\n\t\tdev_err(&pdev->dev, \"no SPI flash device to configure\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tret = nxp_spifi_setup_flash(spifi, flash_np);\n\tof_node_put(flash_np);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"unable to setup flash chip\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int nxp_spifi_remove(struct platform_device *pdev)\n{\n\tstruct nxp_spifi *spifi = platform_get_drvdata(pdev);\n\n\tmtd_device_unregister(&spifi->nor.mtd);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id nxp_spifi_match[] = {\n\t{.compatible = \"nxp,lpc1773-spifi\"},\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, nxp_spifi_match);\n\nstatic struct platform_driver nxp_spifi_driver = {\n\t.probe\t= nxp_spifi_probe,\n\t.remove\t= nxp_spifi_remove,\n\t.driver\t= {\n\t\t.name = \"nxp-spifi\",\n\t\t.of_match_table = nxp_spifi_match,\n\t},\n};\nmodule_platform_driver(nxp_spifi_driver);\n\nMODULE_DESCRIPTION(\"NXP SPI Flash Interface driver\");\nMODULE_AUTHOR(\"Joachim Eastwood <manabian@gmail.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}