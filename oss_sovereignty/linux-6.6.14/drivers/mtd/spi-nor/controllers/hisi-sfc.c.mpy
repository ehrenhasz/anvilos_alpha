{
  "module_name": "hisi-sfc.c",
  "hash_id": "1d4a87d1b02de8ac09ed7030c093bc5c59287bba2e0f1cecc70eed4b54fa7e6b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/spi-nor/controllers/hisi-sfc.c",
  "human_readable_source": "\n \n#include <linux/bitops.h>\n#include <linux/clk.h>\n#include <linux/dma-mapping.h>\n#include <linux/iopoll.h>\n#include <linux/module.h>\n#include <linux/mtd/mtd.h>\n#include <linux/mtd/spi-nor.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n\n \n#define FMC_CFG\t\t\t\t0x00\n#define FMC_CFG_OP_MODE_MASK\t\tBIT_MASK(0)\n#define FMC_CFG_OP_MODE_BOOT\t\t0\n#define FMC_CFG_OP_MODE_NORMAL\t\t1\n#define FMC_CFG_FLASH_SEL(type)\t\t(((type) & 0x3) << 1)\n#define FMC_CFG_FLASH_SEL_MASK\t\t0x6\n#define FMC_ECC_TYPE(type)\t\t(((type) & 0x7) << 5)\n#define FMC_ECC_TYPE_MASK\t\tGENMASK(7, 5)\n#define SPI_NOR_ADDR_MODE_MASK\t\tBIT_MASK(10)\n#define SPI_NOR_ADDR_MODE_3BYTES\t(0x0 << 10)\n#define SPI_NOR_ADDR_MODE_4BYTES\t(0x1 << 10)\n#define FMC_GLOBAL_CFG\t\t\t0x04\n#define FMC_GLOBAL_CFG_WP_ENABLE\tBIT(6)\n#define FMC_SPI_TIMING_CFG\t\t0x08\n#define TIMING_CFG_TCSH(nr)\t\t(((nr) & 0xf) << 8)\n#define TIMING_CFG_TCSS(nr)\t\t(((nr) & 0xf) << 4)\n#define TIMING_CFG_TSHSL(nr)\t\t((nr) & 0xf)\n#define CS_HOLD_TIME\t\t\t0x6\n#define CS_SETUP_TIME\t\t\t0x6\n#define CS_DESELECT_TIME\t\t0xf\n#define FMC_INT\t\t\t\t0x18\n#define FMC_INT_OP_DONE\t\t\tBIT(0)\n#define FMC_INT_CLR\t\t\t0x20\n#define FMC_CMD\t\t\t\t0x24\n#define FMC_CMD_CMD1(cmd)\t\t((cmd) & 0xff)\n#define FMC_ADDRL\t\t\t0x2c\n#define FMC_OP_CFG\t\t\t0x30\n#define OP_CFG_FM_CS(cs)\t\t((cs) << 11)\n#define OP_CFG_MEM_IF_TYPE(type)\t(((type) & 0x7) << 7)\n#define OP_CFG_ADDR_NUM(addr)\t\t(((addr) & 0x7) << 4)\n#define OP_CFG_DUMMY_NUM(dummy)\t\t((dummy) & 0xf)\n#define FMC_DATA_NUM\t\t\t0x38\n#define FMC_DATA_NUM_CNT(cnt)\t\t((cnt) & GENMASK(13, 0))\n#define FMC_OP\t\t\t\t0x3c\n#define FMC_OP_DUMMY_EN\t\t\tBIT(8)\n#define FMC_OP_CMD1_EN\t\t\tBIT(7)\n#define FMC_OP_ADDR_EN\t\t\tBIT(6)\n#define FMC_OP_WRITE_DATA_EN\t\tBIT(5)\n#define FMC_OP_READ_DATA_EN\t\tBIT(2)\n#define FMC_OP_READ_STATUS_EN\t\tBIT(1)\n#define FMC_OP_REG_OP_START\t\tBIT(0)\n#define FMC_DMA_LEN\t\t\t0x40\n#define FMC_DMA_LEN_SET(len)\t\t((len) & GENMASK(27, 0))\n#define FMC_DMA_SADDR_D0\t\t0x4c\n#define HIFMC_DMA_MAX_LEN\t\t(4096)\n#define HIFMC_DMA_MASK\t\t\t(HIFMC_DMA_MAX_LEN - 1)\n#define FMC_OP_DMA\t\t\t0x68\n#define OP_CTRL_RD_OPCODE(code)\t\t(((code) & 0xff) << 16)\n#define OP_CTRL_WR_OPCODE(code)\t\t(((code) & 0xff) << 8)\n#define OP_CTRL_RW_OP(op)\t\t((op) << 1)\n#define OP_CTRL_DMA_OP_READY\t\tBIT(0)\n#define FMC_OP_READ\t\t\t0x0\n#define FMC_OP_WRITE\t\t\t0x1\n#define FMC_WAIT_TIMEOUT\t\t1000000\n\nenum hifmc_iftype {\n\tIF_TYPE_STD,\n\tIF_TYPE_DUAL,\n\tIF_TYPE_DIO,\n\tIF_TYPE_QUAD,\n\tIF_TYPE_QIO,\n};\n\nstruct hifmc_priv {\n\tu32 chipselect;\n\tu32 clkrate;\n\tstruct hifmc_host *host;\n};\n\n#define HIFMC_MAX_CHIP_NUM\t\t2\nstruct hifmc_host {\n\tstruct device *dev;\n\tstruct mutex lock;\n\n\tvoid __iomem *regbase;\n\tvoid __iomem *iobase;\n\tstruct clk *clk;\n\tvoid *buffer;\n\tdma_addr_t dma_buffer;\n\n\tstruct spi_nor\t*nor[HIFMC_MAX_CHIP_NUM];\n\tu32 num_chip;\n};\n\nstatic inline int hisi_spi_nor_wait_op_finish(struct hifmc_host *host)\n{\n\tu32 reg;\n\n\treturn readl_poll_timeout(host->regbase + FMC_INT, reg,\n\t\t(reg & FMC_INT_OP_DONE), 0, FMC_WAIT_TIMEOUT);\n}\n\nstatic int hisi_spi_nor_get_if_type(enum spi_nor_protocol proto)\n{\n\tenum hifmc_iftype if_type;\n\n\tswitch (proto) {\n\tcase SNOR_PROTO_1_1_2:\n\t\tif_type = IF_TYPE_DUAL;\n\t\tbreak;\n\tcase SNOR_PROTO_1_2_2:\n\t\tif_type = IF_TYPE_DIO;\n\t\tbreak;\n\tcase SNOR_PROTO_1_1_4:\n\t\tif_type = IF_TYPE_QUAD;\n\t\tbreak;\n\tcase SNOR_PROTO_1_4_4:\n\t\tif_type = IF_TYPE_QIO;\n\t\tbreak;\n\tcase SNOR_PROTO_1_1_1:\n\tdefault:\n\t\tif_type = IF_TYPE_STD;\n\t\tbreak;\n\t}\n\n\treturn if_type;\n}\n\nstatic void hisi_spi_nor_init(struct hifmc_host *host)\n{\n\tu32 reg;\n\n\treg = TIMING_CFG_TCSH(CS_HOLD_TIME)\n\t\t| TIMING_CFG_TCSS(CS_SETUP_TIME)\n\t\t| TIMING_CFG_TSHSL(CS_DESELECT_TIME);\n\twritel(reg, host->regbase + FMC_SPI_TIMING_CFG);\n}\n\nstatic int hisi_spi_nor_prep(struct spi_nor *nor)\n{\n\tstruct hifmc_priv *priv = nor->priv;\n\tstruct hifmc_host *host = priv->host;\n\tint ret;\n\n\tmutex_lock(&host->lock);\n\n\tret = clk_set_rate(host->clk, priv->clkrate);\n\tif (ret)\n\t\tgoto out;\n\n\tret = clk_prepare_enable(host->clk);\n\tif (ret)\n\t\tgoto out;\n\n\treturn 0;\n\nout:\n\tmutex_unlock(&host->lock);\n\treturn ret;\n}\n\nstatic void hisi_spi_nor_unprep(struct spi_nor *nor)\n{\n\tstruct hifmc_priv *priv = nor->priv;\n\tstruct hifmc_host *host = priv->host;\n\n\tclk_disable_unprepare(host->clk);\n\tmutex_unlock(&host->lock);\n}\n\nstatic int hisi_spi_nor_op_reg(struct spi_nor *nor,\n\t\t\t\tu8 opcode, size_t len, u8 optype)\n{\n\tstruct hifmc_priv *priv = nor->priv;\n\tstruct hifmc_host *host = priv->host;\n\tu32 reg;\n\n\treg = FMC_CMD_CMD1(opcode);\n\twritel(reg, host->regbase + FMC_CMD);\n\n\treg = FMC_DATA_NUM_CNT(len);\n\twritel(reg, host->regbase + FMC_DATA_NUM);\n\n\treg = OP_CFG_FM_CS(priv->chipselect);\n\twritel(reg, host->regbase + FMC_OP_CFG);\n\n\twritel(0xff, host->regbase + FMC_INT_CLR);\n\treg = FMC_OP_CMD1_EN | FMC_OP_REG_OP_START | optype;\n\twritel(reg, host->regbase + FMC_OP);\n\n\treturn hisi_spi_nor_wait_op_finish(host);\n}\n\nstatic int hisi_spi_nor_read_reg(struct spi_nor *nor, u8 opcode, u8 *buf,\n\t\t\t\t size_t len)\n{\n\tstruct hifmc_priv *priv = nor->priv;\n\tstruct hifmc_host *host = priv->host;\n\tint ret;\n\n\tret = hisi_spi_nor_op_reg(nor, opcode, len, FMC_OP_READ_DATA_EN);\n\tif (ret)\n\t\treturn ret;\n\n\tmemcpy_fromio(buf, host->iobase, len);\n\treturn 0;\n}\n\nstatic int hisi_spi_nor_write_reg(struct spi_nor *nor, u8 opcode,\n\t\t\t\t  const u8 *buf, size_t len)\n{\n\tstruct hifmc_priv *priv = nor->priv;\n\tstruct hifmc_host *host = priv->host;\n\n\tif (len)\n\t\tmemcpy_toio(host->iobase, buf, len);\n\n\treturn hisi_spi_nor_op_reg(nor, opcode, len, FMC_OP_WRITE_DATA_EN);\n}\n\nstatic int hisi_spi_nor_dma_transfer(struct spi_nor *nor, loff_t start_off,\n\t\tdma_addr_t dma_buf, size_t len, u8 op_type)\n{\n\tstruct hifmc_priv *priv = nor->priv;\n\tstruct hifmc_host *host = priv->host;\n\tu8 if_type = 0;\n\tu32 reg;\n\n\treg = readl(host->regbase + FMC_CFG);\n\treg &= ~(FMC_CFG_OP_MODE_MASK | SPI_NOR_ADDR_MODE_MASK);\n\treg |= FMC_CFG_OP_MODE_NORMAL;\n\treg |= (nor->addr_nbytes == 4) ? SPI_NOR_ADDR_MODE_4BYTES\n\t\t: SPI_NOR_ADDR_MODE_3BYTES;\n\twritel(reg, host->regbase + FMC_CFG);\n\n\twritel(start_off, host->regbase + FMC_ADDRL);\n\twritel(dma_buf, host->regbase + FMC_DMA_SADDR_D0);\n\twritel(FMC_DMA_LEN_SET(len), host->regbase + FMC_DMA_LEN);\n\n\treg = OP_CFG_FM_CS(priv->chipselect);\n\tif (op_type == FMC_OP_READ)\n\t\tif_type = hisi_spi_nor_get_if_type(nor->read_proto);\n\telse\n\t\tif_type = hisi_spi_nor_get_if_type(nor->write_proto);\n\treg |= OP_CFG_MEM_IF_TYPE(if_type);\n\tif (op_type == FMC_OP_READ)\n\t\treg |= OP_CFG_DUMMY_NUM(nor->read_dummy >> 3);\n\twritel(reg, host->regbase + FMC_OP_CFG);\n\n\twritel(0xff, host->regbase + FMC_INT_CLR);\n\treg = OP_CTRL_RW_OP(op_type) | OP_CTRL_DMA_OP_READY;\n\treg |= (op_type == FMC_OP_READ)\n\t\t? OP_CTRL_RD_OPCODE(nor->read_opcode)\n\t\t: OP_CTRL_WR_OPCODE(nor->program_opcode);\n\twritel(reg, host->regbase + FMC_OP_DMA);\n\n\treturn hisi_spi_nor_wait_op_finish(host);\n}\n\nstatic ssize_t hisi_spi_nor_read(struct spi_nor *nor, loff_t from, size_t len,\n\t\tu_char *read_buf)\n{\n\tstruct hifmc_priv *priv = nor->priv;\n\tstruct hifmc_host *host = priv->host;\n\tsize_t offset;\n\tint ret;\n\n\tfor (offset = 0; offset < len; offset += HIFMC_DMA_MAX_LEN) {\n\t\tsize_t trans = min_t(size_t, HIFMC_DMA_MAX_LEN, len - offset);\n\n\t\tret = hisi_spi_nor_dma_transfer(nor,\n\t\t\tfrom + offset, host->dma_buffer, trans, FMC_OP_READ);\n\t\tif (ret) {\n\t\t\tdev_warn(nor->dev, \"DMA read timeout\\n\");\n\t\t\treturn ret;\n\t\t}\n\t\tmemcpy(read_buf + offset, host->buffer, trans);\n\t}\n\n\treturn len;\n}\n\nstatic ssize_t hisi_spi_nor_write(struct spi_nor *nor, loff_t to,\n\t\t\tsize_t len, const u_char *write_buf)\n{\n\tstruct hifmc_priv *priv = nor->priv;\n\tstruct hifmc_host *host = priv->host;\n\tsize_t offset;\n\tint ret;\n\n\tfor (offset = 0; offset < len; offset += HIFMC_DMA_MAX_LEN) {\n\t\tsize_t trans = min_t(size_t, HIFMC_DMA_MAX_LEN, len - offset);\n\n\t\tmemcpy(host->buffer, write_buf + offset, trans);\n\t\tret = hisi_spi_nor_dma_transfer(nor,\n\t\t\tto + offset, host->dma_buffer, trans, FMC_OP_WRITE);\n\t\tif (ret) {\n\t\t\tdev_warn(nor->dev, \"DMA write timeout\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn len;\n}\n\nstatic const struct spi_nor_controller_ops hisi_controller_ops = {\n\t.prepare = hisi_spi_nor_prep,\n\t.unprepare = hisi_spi_nor_unprep,\n\t.read_reg = hisi_spi_nor_read_reg,\n\t.write_reg = hisi_spi_nor_write_reg,\n\t.read = hisi_spi_nor_read,\n\t.write = hisi_spi_nor_write,\n};\n\n \nstatic int hisi_spi_nor_register(struct device_node *np,\n\t\t\t\tstruct hifmc_host *host)\n{\n\tconst struct spi_nor_hwcaps hwcaps = {\n\t\t.mask = SNOR_HWCAPS_READ |\n\t\t\tSNOR_HWCAPS_READ_FAST |\n\t\t\tSNOR_HWCAPS_READ_1_1_2 |\n\t\t\tSNOR_HWCAPS_READ_1_1_4 |\n\t\t\tSNOR_HWCAPS_PP,\n\t};\n\tstruct device *dev = host->dev;\n\tstruct spi_nor *nor;\n\tstruct hifmc_priv *priv;\n\tstruct mtd_info *mtd;\n\tint ret;\n\n\tnor = devm_kzalloc(dev, sizeof(*nor), GFP_KERNEL);\n\tif (!nor)\n\t\treturn -ENOMEM;\n\n\tnor->dev = dev;\n\tspi_nor_set_flash_node(nor, np);\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tret = of_property_read_u32(np, \"reg\", &priv->chipselect);\n\tif (ret) {\n\t\tdev_err(dev, \"There's no reg property for %pOF\\n\",\n\t\t\tnp);\n\t\treturn ret;\n\t}\n\n\tret = of_property_read_u32(np, \"spi-max-frequency\",\n\t\t\t&priv->clkrate);\n\tif (ret) {\n\t\tdev_err(dev, \"There's no spi-max-frequency property for %pOF\\n\",\n\t\t\tnp);\n\t\treturn ret;\n\t}\n\tpriv->host = host;\n\tnor->priv = priv;\n\tnor->controller_ops = &hisi_controller_ops;\n\n\tret = spi_nor_scan(nor, NULL, &hwcaps);\n\tif (ret)\n\t\treturn ret;\n\n\tmtd = &nor->mtd;\n\tmtd->name = np->name;\n\tret = mtd_device_register(mtd, NULL, 0);\n\tif (ret)\n\t\treturn ret;\n\n\thost->nor[host->num_chip] = nor;\n\thost->num_chip++;\n\treturn 0;\n}\n\nstatic void hisi_spi_nor_unregister_all(struct hifmc_host *host)\n{\n\tint i;\n\n\tfor (i = 0; i < host->num_chip; i++)\n\t\tmtd_device_unregister(&host->nor[i]->mtd);\n}\n\nstatic int hisi_spi_nor_register_all(struct hifmc_host *host)\n{\n\tstruct device *dev = host->dev;\n\tstruct device_node *np;\n\tint ret;\n\n\tfor_each_available_child_of_node(dev->of_node, np) {\n\t\tret = hisi_spi_nor_register(np, host);\n\t\tif (ret) {\n\t\t\tof_node_put(np);\n\t\t\tgoto fail;\n\t\t}\n\n\t\tif (host->num_chip == HIFMC_MAX_CHIP_NUM) {\n\t\t\tdev_warn(dev, \"Flash device number exceeds the maximum chipselect number\\n\");\n\t\t\tof_node_put(np);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n\nfail:\n\thisi_spi_nor_unregister_all(host);\n\treturn ret;\n}\n\nstatic int hisi_spi_nor_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct hifmc_host *host;\n\tint ret;\n\n\thost = devm_kzalloc(dev, sizeof(*host), GFP_KERNEL);\n\tif (!host)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, host);\n\thost->dev = dev;\n\n\thost->regbase = devm_platform_ioremap_resource_byname(pdev, \"control\");\n\tif (IS_ERR(host->regbase))\n\t\treturn PTR_ERR(host->regbase);\n\n\thost->iobase = devm_platform_ioremap_resource_byname(pdev, \"memory\");\n\tif (IS_ERR(host->iobase))\n\t\treturn PTR_ERR(host->iobase);\n\n\thost->clk = devm_clk_get(dev, NULL);\n\tif (IS_ERR(host->clk))\n\t\treturn PTR_ERR(host->clk);\n\n\tret = dma_set_mask_and_coherent(dev, DMA_BIT_MASK(32));\n\tif (ret) {\n\t\tdev_warn(dev, \"Unable to set dma mask\\n\");\n\t\treturn ret;\n\t}\n\n\thost->buffer = dmam_alloc_coherent(dev, HIFMC_DMA_MAX_LEN,\n\t\t\t&host->dma_buffer, GFP_KERNEL);\n\tif (!host->buffer)\n\t\treturn -ENOMEM;\n\n\tret = clk_prepare_enable(host->clk);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_init(&host->lock);\n\thisi_spi_nor_init(host);\n\tret = hisi_spi_nor_register_all(host);\n\tif (ret)\n\t\tmutex_destroy(&host->lock);\n\n\tclk_disable_unprepare(host->clk);\n\treturn ret;\n}\n\nstatic int hisi_spi_nor_remove(struct platform_device *pdev)\n{\n\tstruct hifmc_host *host = platform_get_drvdata(pdev);\n\n\thisi_spi_nor_unregister_all(host);\n\tmutex_destroy(&host->lock);\n\treturn 0;\n}\n\nstatic const struct of_device_id hisi_spi_nor_dt_ids[] = {\n\t{ .compatible = \"hisilicon,fmc-spi-nor\"},\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, hisi_spi_nor_dt_ids);\n\nstatic struct platform_driver hisi_spi_nor_driver = {\n\t.driver = {\n\t\t.name\t= \"hisi-sfc\",\n\t\t.of_match_table = hisi_spi_nor_dt_ids,\n\t},\n\t.probe\t= hisi_spi_nor_probe,\n\t.remove\t= hisi_spi_nor_remove,\n};\nmodule_platform_driver(hisi_spi_nor_driver);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"HiSilicon SPI Nor Flash Controller Driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}