{
  "module_name": "otp.c",
  "hash_id": "c1560ad8c7059cb84cecee18bc2826ac9697e7a75379281b88f8f87269a6ae56",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/spi-nor/otp.c",
  "human_readable_source": "\n \n\n#include <linux/log2.h>\n#include <linux/mtd/mtd.h>\n#include <linux/mtd/spi-nor.h>\n\n#include \"core.h\"\n\n#define spi_nor_otp_region_len(nor) ((nor)->params->otp.org->len)\n#define spi_nor_otp_n_regions(nor) ((nor)->params->otp.org->n_regions)\n\n \nint spi_nor_otp_read_secr(struct spi_nor *nor, loff_t addr, size_t len, u8 *buf)\n{\n\tu8 addr_nbytes, read_opcode, read_dummy;\n\tstruct spi_mem_dirmap_desc *rdesc;\n\tenum spi_nor_protocol read_proto;\n\tint ret;\n\n\tread_opcode = nor->read_opcode;\n\taddr_nbytes = nor->addr_nbytes;\n\tread_dummy = nor->read_dummy;\n\tread_proto = nor->read_proto;\n\trdesc = nor->dirmap.rdesc;\n\n\tnor->read_opcode = SPINOR_OP_RSECR;\n\tnor->read_dummy = 8;\n\tnor->read_proto = SNOR_PROTO_1_1_1;\n\tnor->dirmap.rdesc = NULL;\n\n\tret = spi_nor_read_data(nor, addr, len, buf);\n\n\tnor->read_opcode = read_opcode;\n\tnor->addr_nbytes = addr_nbytes;\n\tnor->read_dummy = read_dummy;\n\tnor->read_proto = read_proto;\n\tnor->dirmap.rdesc = rdesc;\n\n\treturn ret;\n}\n\n \nint spi_nor_otp_write_secr(struct spi_nor *nor, loff_t addr, size_t len,\n\t\t\t   const u8 *buf)\n{\n\tenum spi_nor_protocol write_proto;\n\tstruct spi_mem_dirmap_desc *wdesc;\n\tu8 addr_nbytes, program_opcode;\n\tint ret, written;\n\n\tprogram_opcode = nor->program_opcode;\n\taddr_nbytes = nor->addr_nbytes;\n\twrite_proto = nor->write_proto;\n\twdesc = nor->dirmap.wdesc;\n\n\tnor->program_opcode = SPINOR_OP_PSECR;\n\tnor->write_proto = SNOR_PROTO_1_1_1;\n\tnor->dirmap.wdesc = NULL;\n\n\t \n\tret = spi_nor_write_enable(nor);\n\tif (ret)\n\t\tgoto out;\n\n\twritten = spi_nor_write_data(nor, addr, len, buf);\n\tif (written < 0)\n\t\tgoto out;\n\n\tret = spi_nor_wait_till_ready(nor);\n\nout:\n\tnor->program_opcode = program_opcode;\n\tnor->addr_nbytes = addr_nbytes;\n\tnor->write_proto = write_proto;\n\tnor->dirmap.wdesc = wdesc;\n\n\treturn ret ?: written;\n}\n\n \nint spi_nor_otp_erase_secr(struct spi_nor *nor, loff_t addr)\n{\n\tu8 erase_opcode = nor->erase_opcode;\n\tint ret;\n\n\tret = spi_nor_write_enable(nor);\n\tif (ret)\n\t\treturn ret;\n\n\tnor->erase_opcode = SPINOR_OP_ESECR;\n\tret = spi_nor_erase_sector(nor, addr);\n\tnor->erase_opcode = erase_opcode;\n\tif (ret)\n\t\treturn ret;\n\n\treturn spi_nor_wait_till_ready(nor);\n}\n\nstatic int spi_nor_otp_lock_bit_cr(unsigned int region)\n{\n\tstatic const int lock_bits[] = { SR2_LB1, SR2_LB2, SR2_LB3 };\n\n\tif (region >= ARRAY_SIZE(lock_bits))\n\t\treturn -EINVAL;\n\n\treturn lock_bits[region];\n}\n\n \nint spi_nor_otp_lock_sr2(struct spi_nor *nor, unsigned int region)\n{\n\tu8 *cr = nor->bouncebuf;\n\tint ret, lock_bit;\n\n\tlock_bit = spi_nor_otp_lock_bit_cr(region);\n\tif (lock_bit < 0)\n\t\treturn lock_bit;\n\n\tret = spi_nor_read_cr(nor, cr);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (cr[0] & lock_bit)\n\t\treturn 0;\n\n\tcr[0] |= lock_bit;\n\n\treturn spi_nor_write_16bit_cr_and_check(nor, cr[0]);\n}\n\n \nint spi_nor_otp_is_locked_sr2(struct spi_nor *nor, unsigned int region)\n{\n\tu8 *cr = nor->bouncebuf;\n\tint ret, lock_bit;\n\n\tlock_bit = spi_nor_otp_lock_bit_cr(region);\n\tif (lock_bit < 0)\n\t\treturn lock_bit;\n\n\tret = spi_nor_read_cr(nor, cr);\n\tif (ret)\n\t\treturn ret;\n\n\treturn cr[0] & lock_bit;\n}\n\nstatic loff_t spi_nor_otp_region_start(const struct spi_nor *nor, unsigned int region)\n{\n\tconst struct spi_nor_otp_organization *org = nor->params->otp.org;\n\n\treturn org->base + region * org->offset;\n}\n\nstatic size_t spi_nor_otp_size(struct spi_nor *nor)\n{\n\treturn spi_nor_otp_n_regions(nor) * spi_nor_otp_region_len(nor);\n}\n\n \nstatic loff_t spi_nor_otp_region_to_offset(struct spi_nor *nor, unsigned int region)\n{\n\treturn region * spi_nor_otp_region_len(nor);\n}\n\nstatic unsigned int spi_nor_otp_offset_to_region(struct spi_nor *nor, loff_t ofs)\n{\n\treturn div64_u64(ofs, spi_nor_otp_region_len(nor));\n}\n\nstatic int spi_nor_mtd_otp_info(struct mtd_info *mtd, size_t len,\n\t\t\t\tsize_t *retlen, struct otp_info *buf)\n{\n\tstruct spi_nor *nor = mtd_to_spi_nor(mtd);\n\tconst struct spi_nor_otp_ops *ops = nor->params->otp.ops;\n\tunsigned int n_regions = spi_nor_otp_n_regions(nor);\n\tunsigned int i;\n\tint ret, locked;\n\n\tif (len < n_regions * sizeof(*buf))\n\t\treturn -ENOSPC;\n\n\tret = spi_nor_prep_and_lock(nor);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < n_regions; i++) {\n\t\tbuf->start = spi_nor_otp_region_to_offset(nor, i);\n\t\tbuf->length = spi_nor_otp_region_len(nor);\n\n\t\tlocked = ops->is_locked(nor, i);\n\t\tif (locked < 0) {\n\t\t\tret = locked;\n\t\t\tgoto out;\n\t\t}\n\n\t\tbuf->locked = !!locked;\n\t\tbuf++;\n\t}\n\n\t*retlen = n_regions * sizeof(*buf);\n\nout:\n\tspi_nor_unlock_and_unprep(nor);\n\n\treturn ret;\n}\n\nstatic int spi_nor_mtd_otp_range_is_locked(struct spi_nor *nor, loff_t ofs,\n\t\t\t\t\t   size_t len)\n{\n\tconst struct spi_nor_otp_ops *ops = nor->params->otp.ops;\n\tunsigned int region;\n\tint locked;\n\n\t \n\tfor (region = spi_nor_otp_offset_to_region(nor, ofs);\n\t     region <= spi_nor_otp_offset_to_region(nor, ofs + len - 1);\n\t     region++) {\n\t\tlocked = ops->is_locked(nor, region);\n\t\t \n\t\tif (locked)\n\t\t\treturn locked;\n\t}\n\n\treturn 0;\n}\n\nstatic int spi_nor_mtd_otp_read_write(struct mtd_info *mtd, loff_t ofs,\n\t\t\t\t      size_t total_len, size_t *retlen,\n\t\t\t\t      const u8 *buf, bool is_write)\n{\n\tstruct spi_nor *nor = mtd_to_spi_nor(mtd);\n\tconst struct spi_nor_otp_ops *ops = nor->params->otp.ops;\n\tconst size_t rlen = spi_nor_otp_region_len(nor);\n\tloff_t rstart, rofs;\n\tunsigned int region;\n\tsize_t len;\n\tint ret;\n\n\tif (ofs < 0 || ofs >= spi_nor_otp_size(nor))\n\t\treturn 0;\n\n\t \n\ttotal_len = min_t(size_t, total_len, spi_nor_otp_size(nor) - ofs);\n\n\tif (!total_len)\n\t\treturn 0;\n\n\tret = spi_nor_prep_and_lock(nor);\n\tif (ret)\n\t\treturn ret;\n\n\tif (is_write) {\n\t\tret = spi_nor_mtd_otp_range_is_locked(nor, ofs, total_len);\n\t\tif (ret < 0) {\n\t\t\tgoto out;\n\t\t} else if (ret) {\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\twhile (total_len) {\n\t\t \n\t\tregion = spi_nor_otp_offset_to_region(nor, ofs);\n\t\trstart = spi_nor_otp_region_start(nor, region);\n\n\t\t \n\t\trofs = ofs & (rlen - 1);\n\n\t\t \n\t\tlen = min_t(size_t, total_len, rlen - rofs);\n\n\t\tif (is_write)\n\t\t\tret = ops->write(nor, rstart + rofs, len, buf);\n\t\telse\n\t\t\tret = ops->read(nor, rstart + rofs, len, (u8 *)buf);\n\t\tif (ret == 0)\n\t\t\tret = -EIO;\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\t*retlen += ret;\n\t\tofs += ret;\n\t\tbuf += ret;\n\t\ttotal_len -= ret;\n\t}\n\tret = 0;\n\nout:\n\tspi_nor_unlock_and_unprep(nor);\n\treturn ret;\n}\n\nstatic int spi_nor_mtd_otp_read(struct mtd_info *mtd, loff_t from, size_t len,\n\t\t\t\tsize_t *retlen, u8 *buf)\n{\n\treturn spi_nor_mtd_otp_read_write(mtd, from, len, retlen, buf, false);\n}\n\nstatic int spi_nor_mtd_otp_write(struct mtd_info *mtd, loff_t to, size_t len,\n\t\t\t\t size_t *retlen, const u8 *buf)\n{\n\treturn spi_nor_mtd_otp_read_write(mtd, to, len, retlen, buf, true);\n}\n\nstatic int spi_nor_mtd_otp_erase(struct mtd_info *mtd, loff_t from, size_t len)\n{\n\tstruct spi_nor *nor = mtd_to_spi_nor(mtd);\n\tconst struct spi_nor_otp_ops *ops = nor->params->otp.ops;\n\tconst size_t rlen = spi_nor_otp_region_len(nor);\n\tunsigned int region;\n\tloff_t rstart;\n\tint ret;\n\n\t \n\tif (!ops->erase)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!len)\n\t\treturn 0;\n\n\tif (from < 0 || (from + len) > spi_nor_otp_size(nor))\n\t\treturn -EINVAL;\n\n\t \n\tif (!IS_ALIGNED(len, rlen) || !IS_ALIGNED(from, rlen))\n\t\treturn -EINVAL;\n\n\tret = spi_nor_prep_and_lock(nor);\n\tif (ret)\n\t\treturn ret;\n\n\tret = spi_nor_mtd_otp_range_is_locked(nor, from, len);\n\tif (ret < 0) {\n\t\tgoto out;\n\t} else if (ret) {\n\t\tret = -EROFS;\n\t\tgoto out;\n\t}\n\n\twhile (len) {\n\t\tregion = spi_nor_otp_offset_to_region(nor, from);\n\t\trstart = spi_nor_otp_region_start(nor, region);\n\n\t\tret = ops->erase(nor, rstart);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\tlen -= rlen;\n\t\tfrom += rlen;\n\t}\n\nout:\n\tspi_nor_unlock_and_unprep(nor);\n\n\treturn ret;\n}\n\nstatic int spi_nor_mtd_otp_lock(struct mtd_info *mtd, loff_t from, size_t len)\n{\n\tstruct spi_nor *nor = mtd_to_spi_nor(mtd);\n\tconst struct spi_nor_otp_ops *ops = nor->params->otp.ops;\n\tconst size_t rlen = spi_nor_otp_region_len(nor);\n\tunsigned int region;\n\tint ret;\n\n\tif (from < 0 || (from + len) > spi_nor_otp_size(nor))\n\t\treturn -EINVAL;\n\n\t \n\tif (!IS_ALIGNED(len, rlen) || !IS_ALIGNED(from, rlen))\n\t\treturn -EINVAL;\n\n\tret = spi_nor_prep_and_lock(nor);\n\tif (ret)\n\t\treturn ret;\n\n\twhile (len) {\n\t\tregion = spi_nor_otp_offset_to_region(nor, from);\n\t\tret = ops->lock(nor, region);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\tlen -= rlen;\n\t\tfrom += rlen;\n\t}\n\nout:\n\tspi_nor_unlock_and_unprep(nor);\n\n\treturn ret;\n}\n\nvoid spi_nor_set_mtd_otp_ops(struct spi_nor *nor)\n{\n\tstruct mtd_info *mtd = &nor->mtd;\n\n\tif (!nor->params->otp.ops)\n\t\treturn;\n\n\tif (WARN_ON(!is_power_of_2(spi_nor_otp_region_len(nor))))\n\t\treturn;\n\n\t \n\tmtd->_get_user_prot_info = spi_nor_mtd_otp_info;\n\tmtd->_read_user_prot_reg = spi_nor_mtd_otp_read;\n\tmtd->_write_user_prot_reg = spi_nor_mtd_otp_write;\n\tmtd->_lock_user_prot_reg = spi_nor_mtd_otp_lock;\n\tmtd->_erase_user_prot_reg = spi_nor_mtd_otp_erase;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}