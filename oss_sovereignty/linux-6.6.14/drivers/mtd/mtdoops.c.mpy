{
  "module_name": "mtdoops.c",
  "hash_id": "8f354815f06ef7ac593b97a6ac6b46797650fe8a66d3b58bc2710302a4e50150",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/mtdoops.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/console.h>\n#include <linux/vmalloc.h>\n#include <linux/workqueue.h>\n#include <linux/sched.h>\n#include <linux/wait.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/timekeeping.h>\n#include <linux/mtd/mtd.h>\n#include <linux/kmsg_dump.h>\n\n \n#define MTDOOPS_MAX_MTD_SIZE (8 * 1024 * 1024)\n\nstatic unsigned long record_size = 4096;\nmodule_param(record_size, ulong, 0400);\nMODULE_PARM_DESC(record_size,\n\t\t\"record size for MTD OOPS pages in bytes (default 4096)\");\n\nstatic char mtddev[80];\nmodule_param_string(mtddev, mtddev, 80, 0400);\nMODULE_PARM_DESC(mtddev,\n\t\t\"name or index number of the MTD device to use\");\n\nstatic int dump_oops = 1;\nmodule_param(dump_oops, int, 0600);\nMODULE_PARM_DESC(dump_oops,\n\t\t\"set to 1 to dump oopses, 0 to only dump panics (default 1)\");\n\n#define MTDOOPS_KERNMSG_MAGIC_v1 0x5d005d00   \n#define MTDOOPS_KERNMSG_MAGIC_v2 0x5d005e00   \n\nstruct mtdoops_hdr {\n\tu32 seq;\n\tu32 magic;\n\tktime_t timestamp;\n} __packed;\n\nstatic struct mtdoops_context {\n\tstruct kmsg_dumper dump;\n\n\tint mtd_index;\n\tstruct work_struct work_erase;\n\tstruct work_struct work_write;\n\tstruct mtd_info *mtd;\n\tint oops_pages;\n\tint nextpage;\n\tint nextcount;\n\tunsigned long *oops_page_used;\n\n\tunsigned long oops_buf_busy;\n\tvoid *oops_buf;\n} oops_cxt;\n\nstatic void mark_page_used(struct mtdoops_context *cxt, int page)\n{\n\tset_bit(page, cxt->oops_page_used);\n}\n\nstatic void mark_page_unused(struct mtdoops_context *cxt, int page)\n{\n\tclear_bit(page, cxt->oops_page_used);\n}\n\nstatic int page_is_used(struct mtdoops_context *cxt, int page)\n{\n\treturn test_bit(page, cxt->oops_page_used);\n}\n\nstatic int mtdoops_erase_block(struct mtdoops_context *cxt, int offset)\n{\n\tstruct mtd_info *mtd = cxt->mtd;\n\tu32 start_page_offset = mtd_div_by_eb(offset, mtd) * mtd->erasesize;\n\tu32 start_page = start_page_offset / record_size;\n\tu32 erase_pages = mtd->erasesize / record_size;\n\tstruct erase_info erase;\n\tint ret;\n\tint page;\n\n\terase.addr = offset;\n\terase.len = mtd->erasesize;\n\n\tret = mtd_erase(mtd, &erase);\n\tif (ret) {\n\t\tpr_warn(\"erase of region [0x%llx, 0x%llx] on \\\"%s\\\" failed\\n\",\n\t\t\t(unsigned long long)erase.addr,\n\t\t\t(unsigned long long)erase.len, mtddev);\n\t\treturn ret;\n\t}\n\n\t \n\tfor (page = start_page; page < start_page + erase_pages; page++)\n\t\tmark_page_unused(cxt, page);\n\n\treturn 0;\n}\n\nstatic void mtdoops_erase(struct mtdoops_context *cxt)\n{\n\tstruct mtd_info *mtd = cxt->mtd;\n\tint i = 0, j, ret, mod;\n\n\t \n\tif (!mtd)\n\t\treturn;\n\n\tmod = (cxt->nextpage * record_size) % mtd->erasesize;\n\tif (mod != 0) {\n\t\tcxt->nextpage = cxt->nextpage + ((mtd->erasesize - mod) / record_size);\n\t\tif (cxt->nextpage >= cxt->oops_pages)\n\t\t\tcxt->nextpage = 0;\n\t}\n\n\twhile ((ret = mtd_block_isbad(mtd, cxt->nextpage * record_size)) > 0) {\nbadblock:\n\t\tpr_warn(\"bad block at %08lx\\n\",\n\t\t\tcxt->nextpage * record_size);\n\t\ti++;\n\t\tcxt->nextpage = cxt->nextpage + (mtd->erasesize / record_size);\n\t\tif (cxt->nextpage >= cxt->oops_pages)\n\t\t\tcxt->nextpage = 0;\n\t\tif (i == cxt->oops_pages / (mtd->erasesize / record_size)) {\n\t\t\tpr_err(\"all blocks bad!\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (ret < 0) {\n\t\tpr_err(\"mtd_block_isbad failed, aborting\\n\");\n\t\treturn;\n\t}\n\n\tfor (j = 0, ret = -1; (j < 3) && (ret < 0); j++)\n\t\tret = mtdoops_erase_block(cxt, cxt->nextpage * record_size);\n\n\tif (ret >= 0) {\n\t\tpr_debug(\"ready %d, %d\\n\",\n\t\t\t cxt->nextpage, cxt->nextcount);\n\t\treturn;\n\t}\n\n\tif (ret == -EIO) {\n\t\tret = mtd_block_markbad(mtd, cxt->nextpage * record_size);\n\t\tif (ret < 0 && ret != -EOPNOTSUPP) {\n\t\t\tpr_err(\"block_markbad failed, aborting\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\tgoto badblock;\n}\n\n \nstatic void mtdoops_workfunc_erase(struct work_struct *work)\n{\n\tstruct mtdoops_context *cxt =\n\t\t\tcontainer_of(work, struct mtdoops_context, work_erase);\n\tmtdoops_erase(cxt);\n}\n\nstatic void mtdoops_inc_counter(struct mtdoops_context *cxt, int panic)\n{\n\tcxt->nextpage++;\n\tif (cxt->nextpage >= cxt->oops_pages)\n\t\tcxt->nextpage = 0;\n\tcxt->nextcount++;\n\tif (cxt->nextcount == 0xffffffff)\n\t\tcxt->nextcount = 0;\n\n\tif (page_is_used(cxt, cxt->nextpage)) {\n\t\tpr_debug(\"not ready %d, %d (erase %s)\\n\",\n\t\t\t cxt->nextpage, cxt->nextcount,\n\t\t\t panic ? \"immediately\" : \"scheduled\");\n\t\tif (panic) {\n\t\t\t \n\t\t\tmtdoops_erase(cxt);\n\t\t} else {\n\t\t\t \n\t\t\tschedule_work(&cxt->work_erase);\n\t\t}\n\t} else {\n\t\tpr_debug(\"ready %d, %d (no erase)\\n\",\n\t\t\t cxt->nextpage, cxt->nextcount);\n\t}\n}\n\nstatic void mtdoops_write(struct mtdoops_context *cxt, int panic)\n{\n\tstruct mtd_info *mtd = cxt->mtd;\n\tsize_t retlen;\n\tstruct mtdoops_hdr *hdr;\n\tint ret;\n\n\tif (test_and_set_bit(0, &cxt->oops_buf_busy))\n\t\treturn;\n\n\t \n\thdr = (struct mtdoops_hdr *)cxt->oops_buf;\n\thdr->seq = cxt->nextcount;\n\thdr->magic = MTDOOPS_KERNMSG_MAGIC_v2;\n\thdr->timestamp = ktime_get_real();\n\n\tif (panic) {\n\t\tret = mtd_panic_write(mtd, cxt->nextpage * record_size,\n\t\t\t\t      record_size, &retlen, cxt->oops_buf);\n\t\tif (ret == -EOPNOTSUPP) {\n\t\t\tpr_err(\"Cannot write from panic without panic_write\\n\");\n\t\t\tgoto out;\n\t\t}\n\t} else\n\t\tret = mtd_write(mtd, cxt->nextpage * record_size,\n\t\t\t\trecord_size, &retlen, cxt->oops_buf);\n\n\tif (retlen != record_size || ret < 0)\n\t\tpr_err(\"write failure at %ld (%td of %ld written), error %d\\n\",\n\t\t       cxt->nextpage * record_size, retlen, record_size, ret);\n\tmark_page_used(cxt, cxt->nextpage);\n\tmemset(cxt->oops_buf, 0xff, record_size);\n\n\tmtdoops_inc_counter(cxt, panic);\nout:\n\tclear_bit(0, &cxt->oops_buf_busy);\n}\n\nstatic void mtdoops_workfunc_write(struct work_struct *work)\n{\n\tstruct mtdoops_context *cxt =\n\t\t\tcontainer_of(work, struct mtdoops_context, work_write);\n\n\tmtdoops_write(cxt, 0);\n}\n\nstatic void find_next_position(struct mtdoops_context *cxt)\n{\n\tstruct mtd_info *mtd = cxt->mtd;\n\tstruct mtdoops_hdr hdr;\n\tint ret, page, maxpos = 0;\n\tu32 maxcount = 0xffffffff;\n\tsize_t retlen;\n\n\tfor (page = 0; page < cxt->oops_pages; page++) {\n\t\tif (mtd_block_isbad(mtd, page * record_size))\n\t\t\tcontinue;\n\t\t \n\t\tmark_page_used(cxt, page);\n\t\tret = mtd_read(mtd, page * record_size, sizeof(hdr),\n\t\t\t       &retlen, (u_char *)&hdr);\n\t\tif (retlen != sizeof(hdr) ||\n\t\t\t\t(ret < 0 && !mtd_is_bitflip(ret))) {\n\t\t\tpr_err(\"read failure at %ld (%zu of %zu read), err %d\\n\",\n\t\t\t       page * record_size, retlen, sizeof(hdr), ret);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (hdr.seq == 0xffffffff && hdr.magic == 0xffffffff)\n\t\t\tmark_page_unused(cxt, page);\n\t\tif (hdr.seq == 0xffffffff ||\n\t\t    (hdr.magic != MTDOOPS_KERNMSG_MAGIC_v1 &&\n\t\t     hdr.magic != MTDOOPS_KERNMSG_MAGIC_v2))\n\t\t\tcontinue;\n\t\tif (maxcount == 0xffffffff) {\n\t\t\tmaxcount = hdr.seq;\n\t\t\tmaxpos = page;\n\t\t} else if (hdr.seq < 0x40000000 && maxcount > 0xc0000000) {\n\t\t\tmaxcount = hdr.seq;\n\t\t\tmaxpos = page;\n\t\t} else if (hdr.seq > maxcount && hdr.seq < 0xc0000000) {\n\t\t\tmaxcount = hdr.seq;\n\t\t\tmaxpos = page;\n\t\t} else if (hdr.seq > maxcount && hdr.seq > 0xc0000000\n\t\t\t\t\t&& maxcount > 0x80000000) {\n\t\t\tmaxcount = hdr.seq;\n\t\t\tmaxpos = page;\n\t\t}\n\t}\n\tif (maxcount == 0xffffffff) {\n\t\tcxt->nextpage = cxt->oops_pages - 1;\n\t\tcxt->nextcount = 0;\n\t}\n\telse {\n\t\tcxt->nextpage = maxpos;\n\t\tcxt->nextcount = maxcount;\n\t}\n\n\tmtdoops_inc_counter(cxt, 0);\n}\n\nstatic void mtdoops_do_dump(struct kmsg_dumper *dumper,\n\t\t\t    enum kmsg_dump_reason reason)\n{\n\tstruct mtdoops_context *cxt = container_of(dumper,\n\t\t\tstruct mtdoops_context, dump);\n\tstruct kmsg_dump_iter iter;\n\n\t \n\tif (reason == KMSG_DUMP_OOPS && !dump_oops)\n\t\treturn;\n\n\tkmsg_dump_rewind(&iter);\n\n\tif (test_and_set_bit(0, &cxt->oops_buf_busy))\n\t\treturn;\n\tkmsg_dump_get_buffer(&iter, true,\n\t\t\t     cxt->oops_buf + sizeof(struct mtdoops_hdr),\n\t\t\t     record_size - sizeof(struct mtdoops_hdr), NULL);\n\tclear_bit(0, &cxt->oops_buf_busy);\n\n\tif (reason != KMSG_DUMP_OOPS) {\n\t\t \n\t\tmtdoops_write(cxt, 1);\n\t} else {\n\t\t \n\t\tschedule_work(&cxt->work_write);\n\t}\n}\n\nstatic void mtdoops_notify_add(struct mtd_info *mtd)\n{\n\tstruct mtdoops_context *cxt = &oops_cxt;\n\tu64 mtdoops_pages = div_u64(mtd->size, record_size);\n\tint err;\n\n\tif (!strcmp(mtd->name, mtddev))\n\t\tcxt->mtd_index = mtd->index;\n\n\tif (mtd->index != cxt->mtd_index || cxt->mtd_index < 0)\n\t\treturn;\n\n\tif (mtd->size < mtd->erasesize * 2) {\n\t\tpr_err(\"MTD partition %d not big enough for mtdoops\\n\",\n\t\t       mtd->index);\n\t\treturn;\n\t}\n\tif (mtd->erasesize < record_size) {\n\t\tpr_err(\"eraseblock size of MTD partition %d too small\\n\",\n\t\t       mtd->index);\n\t\treturn;\n\t}\n\tif (mtd->size > MTDOOPS_MAX_MTD_SIZE) {\n\t\tpr_err(\"mtd%d is too large (limit is %d MiB)\\n\",\n\t\t       mtd->index, MTDOOPS_MAX_MTD_SIZE / 1024 / 1024);\n\t\treturn;\n\t}\n\n\t \n\tcxt->oops_page_used =\n\t\tvmalloc(array_size(sizeof(unsigned long),\n\t\t\t\t   DIV_ROUND_UP(mtdoops_pages,\n\t\t\t\t\t\tBITS_PER_LONG)));\n\tif (!cxt->oops_page_used) {\n\t\tpr_err(\"could not allocate page array\\n\");\n\t\treturn;\n\t}\n\n\tcxt->dump.max_reason = KMSG_DUMP_OOPS;\n\tcxt->dump.dump = mtdoops_do_dump;\n\terr = kmsg_dump_register(&cxt->dump);\n\tif (err) {\n\t\tpr_err(\"registering kmsg dumper failed, error %d\\n\", err);\n\t\tvfree(cxt->oops_page_used);\n\t\tcxt->oops_page_used = NULL;\n\t\treturn;\n\t}\n\n\tcxt->mtd = mtd;\n\tcxt->oops_pages = (int)mtd->size / record_size;\n\tfind_next_position(cxt);\n\tpr_info(\"Attached to MTD device %d\\n\", mtd->index);\n}\n\nstatic void mtdoops_notify_remove(struct mtd_info *mtd)\n{\n\tstruct mtdoops_context *cxt = &oops_cxt;\n\n\tif (mtd->index != cxt->mtd_index || cxt->mtd_index < 0)\n\t\treturn;\n\n\tif (kmsg_dump_unregister(&cxt->dump) < 0)\n\t\tpr_warn(\"could not unregister kmsg_dumper\\n\");\n\n\tcxt->mtd = NULL;\n\tflush_work(&cxt->work_erase);\n\tflush_work(&cxt->work_write);\n}\n\n\nstatic struct mtd_notifier mtdoops_notifier = {\n\t.add\t= mtdoops_notify_add,\n\t.remove\t= mtdoops_notify_remove,\n};\n\nstatic int __init mtdoops_init(void)\n{\n\tstruct mtdoops_context *cxt = &oops_cxt;\n\tint mtd_index;\n\tchar *endp;\n\n\tif (strlen(mtddev) == 0) {\n\t\tpr_err(\"mtd device (mtddev=name/number) must be supplied\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif ((record_size & 4095) != 0) {\n\t\tpr_err(\"record_size must be a multiple of 4096\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (record_size < 4096) {\n\t\tpr_err(\"record_size must be over 4096 bytes\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tcxt->mtd_index = -1;\n\tmtd_index = simple_strtoul(mtddev, &endp, 0);\n\tif (*endp == '\\0')\n\t\tcxt->mtd_index = mtd_index;\n\n\tcxt->oops_buf = vmalloc(record_size);\n\tif (!cxt->oops_buf)\n\t\treturn -ENOMEM;\n\tmemset(cxt->oops_buf, 0xff, record_size);\n\tcxt->oops_buf_busy = 0;\n\n\tINIT_WORK(&cxt->work_erase, mtdoops_workfunc_erase);\n\tINIT_WORK(&cxt->work_write, mtdoops_workfunc_write);\n\n\tregister_mtd_user(&mtdoops_notifier);\n\treturn 0;\n}\n\nstatic void __exit mtdoops_exit(void)\n{\n\tstruct mtdoops_context *cxt = &oops_cxt;\n\n\tunregister_mtd_user(&mtdoops_notifier);\n\tvfree(cxt->oops_buf);\n\tvfree(cxt->oops_page_used);\n}\n\n\nmodule_init(mtdoops_init);\nmodule_exit(mtdoops_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Richard Purdie <rpurdie@openedhand.com>\");\nMODULE_DESCRIPTION(\"MTD Oops/Panic console logger/driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}