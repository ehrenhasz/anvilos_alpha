{
  "module_name": "mtdblock.c",
  "hash_id": "0a57ab8db2377a3be654c4f22aa127f435365434080b320fbbedfea971d51998",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/mtdblock.c",
  "human_readable_source": "\n \n\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/vmalloc.h>\n\n#include <linux/mtd/mtd.h>\n#include <linux/mtd/blktrans.h>\n#include <linux/mutex.h>\n#include <linux/major.h>\n\n\nstruct mtdblk_dev {\n\tstruct mtd_blktrans_dev mbd;\n\tint count;\n\tstruct mutex cache_mutex;\n\tunsigned char *cache_data;\n\tunsigned long cache_offset;\n\tunsigned int cache_size;\n\tenum { STATE_EMPTY, STATE_CLEAN, STATE_DIRTY } cache_state;\n};\n\n \n\nstatic int erase_write (struct mtd_info *mtd, unsigned long pos,\n\t\t\tunsigned int len, const char *buf)\n{\n\tstruct erase_info erase;\n\tsize_t retlen;\n\tint ret;\n\n\t \n\terase.addr = pos;\n\terase.len = len;\n\n\tret = mtd_erase(mtd, &erase);\n\tif (ret) {\n\t\tprintk (KERN_WARNING \"mtdblock: erase of region [0x%lx, 0x%x] \"\n\t\t\t\t     \"on \\\"%s\\\" failed\\n\",\n\t\t\tpos, len, mtd->name);\n\t\treturn ret;\n\t}\n\n\t \n\n\tret = mtd_write(mtd, pos, len, &retlen, buf);\n\tif (ret)\n\t\treturn ret;\n\tif (retlen != len)\n\t\treturn -EIO;\n\treturn 0;\n}\n\n\nstatic int write_cached_data (struct mtdblk_dev *mtdblk)\n{\n\tstruct mtd_info *mtd = mtdblk->mbd.mtd;\n\tint ret;\n\n\tif (mtdblk->cache_state != STATE_DIRTY)\n\t\treturn 0;\n\n\tpr_debug(\"mtdblock: writing cached data for \\\"%s\\\" \"\n\t\t\t\"at 0x%lx, size 0x%x\\n\", mtd->name,\n\t\t\tmtdblk->cache_offset, mtdblk->cache_size);\n\n\tret = erase_write (mtd, mtdblk->cache_offset,\n\t\t\t   mtdblk->cache_size, mtdblk->cache_data);\n\n\t \n\tif (ret == 0 || ret == -EIO)\n\t\tmtdblk->cache_state = STATE_EMPTY;\n\treturn ret;\n}\n\n\nstatic int do_cached_write (struct mtdblk_dev *mtdblk, unsigned long pos,\n\t\t\t    int len, const char *buf)\n{\n\tstruct mtd_info *mtd = mtdblk->mbd.mtd;\n\tunsigned int sect_size = mtdblk->cache_size;\n\tsize_t retlen;\n\tint ret;\n\n\tpr_debug(\"mtdblock: write on \\\"%s\\\" at 0x%lx, size 0x%x\\n\",\n\t\tmtd->name, pos, len);\n\n\tif (!sect_size)\n\t\treturn mtd_write(mtd, pos, len, &retlen, buf);\n\n\twhile (len > 0) {\n\t\tunsigned long sect_start = (pos/sect_size)*sect_size;\n\t\tunsigned int offset = pos - sect_start;\n\t\tunsigned int size = sect_size - offset;\n\t\tif( size > len )\n\t\t\tsize = len;\n\n\t\tif (size == sect_size) {\n\t\t\t \n\t\t\tret = erase_write (mtd, pos, size, buf);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t} else {\n\t\t\t \n\n\t\t\tif (mtdblk->cache_state == STATE_DIRTY &&\n\t\t\t    mtdblk->cache_offset != sect_start) {\n\t\t\t\tret = write_cached_data(mtdblk);\n\t\t\t\tif (ret)\n\t\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\tif (mtdblk->cache_state == STATE_EMPTY ||\n\t\t\t    mtdblk->cache_offset != sect_start) {\n\t\t\t\t \n\t\t\t\tmtdblk->cache_state = STATE_EMPTY;\n\t\t\t\tret = mtd_read(mtd, sect_start, sect_size,\n\t\t\t\t\t       &retlen, mtdblk->cache_data);\n\t\t\t\tif (ret && !mtd_is_bitflip(ret))\n\t\t\t\t\treturn ret;\n\t\t\t\tif (retlen != sect_size)\n\t\t\t\t\treturn -EIO;\n\n\t\t\t\tmtdblk->cache_offset = sect_start;\n\t\t\t\tmtdblk->cache_size = sect_size;\n\t\t\t\tmtdblk->cache_state = STATE_CLEAN;\n\t\t\t}\n\n\t\t\t \n\t\t\tmemcpy (mtdblk->cache_data + offset, buf, size);\n\t\t\tmtdblk->cache_state = STATE_DIRTY;\n\t\t}\n\n\t\tbuf += size;\n\t\tpos += size;\n\t\tlen -= size;\n\t}\n\n\treturn 0;\n}\n\n\nstatic int do_cached_read (struct mtdblk_dev *mtdblk, unsigned long pos,\n\t\t\t   int len, char *buf)\n{\n\tstruct mtd_info *mtd = mtdblk->mbd.mtd;\n\tunsigned int sect_size = mtdblk->cache_size;\n\tsize_t retlen;\n\tint ret;\n\n\tpr_debug(\"mtdblock: read on \\\"%s\\\" at 0x%lx, size 0x%x\\n\",\n\t\t\tmtd->name, pos, len);\n\n\tif (!sect_size) {\n\t\tret = mtd_read(mtd, pos, len, &retlen, buf);\n\t\tif (ret && !mtd_is_bitflip(ret))\n\t\t\treturn ret;\n\t\treturn 0;\n\t}\n\n\twhile (len > 0) {\n\t\tunsigned long sect_start = (pos/sect_size)*sect_size;\n\t\tunsigned int offset = pos - sect_start;\n\t\tunsigned int size = sect_size - offset;\n\t\tif (size > len)\n\t\t\tsize = len;\n\n\t\t \n\t\tif (mtdblk->cache_state != STATE_EMPTY &&\n\t\t    mtdblk->cache_offset == sect_start) {\n\t\t\tmemcpy (buf, mtdblk->cache_data + offset, size);\n\t\t} else {\n\t\t\tret = mtd_read(mtd, pos, size, &retlen, buf);\n\t\t\tif (ret && !mtd_is_bitflip(ret))\n\t\t\t\treturn ret;\n\t\t\tif (retlen != size)\n\t\t\t\treturn -EIO;\n\t\t}\n\n\t\tbuf += size;\n\t\tpos += size;\n\t\tlen -= size;\n\t}\n\n\treturn 0;\n}\n\nstatic int mtdblock_readsect(struct mtd_blktrans_dev *dev,\n\t\t\t      unsigned long block, char *buf)\n{\n\tstruct mtdblk_dev *mtdblk = container_of(dev, struct mtdblk_dev, mbd);\n\treturn do_cached_read(mtdblk, block<<9, 512, buf);\n}\n\nstatic int mtdblock_writesect(struct mtd_blktrans_dev *dev,\n\t\t\t      unsigned long block, char *buf)\n{\n\tstruct mtdblk_dev *mtdblk = container_of(dev, struct mtdblk_dev, mbd);\n\tif (unlikely(!mtdblk->cache_data && mtdblk->cache_size)) {\n\t\tmtdblk->cache_data = vmalloc(mtdblk->mbd.mtd->erasesize);\n\t\tif (!mtdblk->cache_data)\n\t\t\treturn -EINTR;\n\t\t \n\t}\n\treturn do_cached_write(mtdblk, block<<9, 512, buf);\n}\n\nstatic int mtdblock_open(struct mtd_blktrans_dev *mbd)\n{\n\tstruct mtdblk_dev *mtdblk = container_of(mbd, struct mtdblk_dev, mbd);\n\n\tpr_debug(\"mtdblock_open\\n\");\n\n\tif (mtdblk->count) {\n\t\tmtdblk->count++;\n\t\treturn 0;\n\t}\n\n\tif (mtd_type_is_nand(mbd->mtd))\n\t\tpr_warn_ratelimited(\"%s: MTD device '%s' is NAND, please consider using UBI block devices instead.\\n\",\n\t\t\tmbd->tr->name, mbd->mtd->name);\n\n\t \n\tmtdblk->count = 1;\n\tmutex_init(&mtdblk->cache_mutex);\n\tmtdblk->cache_state = STATE_EMPTY;\n\tif (!(mbd->mtd->flags & MTD_NO_ERASE) && mbd->mtd->erasesize) {\n\t\tmtdblk->cache_size = mbd->mtd->erasesize;\n\t\tmtdblk->cache_data = NULL;\n\t}\n\n\tpr_debug(\"ok\\n\");\n\n\treturn 0;\n}\n\nstatic void mtdblock_release(struct mtd_blktrans_dev *mbd)\n{\n\tstruct mtdblk_dev *mtdblk = container_of(mbd, struct mtdblk_dev, mbd);\n\n\tpr_debug(\"mtdblock_release\\n\");\n\n\tmutex_lock(&mtdblk->cache_mutex);\n\twrite_cached_data(mtdblk);\n\tmutex_unlock(&mtdblk->cache_mutex);\n\n\tif (!--mtdblk->count) {\n\t\t \n\t\tif (mbd->writable)\n\t\t\tmtd_sync(mbd->mtd);\n\t\tvfree(mtdblk->cache_data);\n\t}\n\n\tpr_debug(\"ok\\n\");\n}\n\nstatic int mtdblock_flush(struct mtd_blktrans_dev *dev)\n{\n\tstruct mtdblk_dev *mtdblk = container_of(dev, struct mtdblk_dev, mbd);\n\tint ret;\n\n\tmutex_lock(&mtdblk->cache_mutex);\n\tret = write_cached_data(mtdblk);\n\tmutex_unlock(&mtdblk->cache_mutex);\n\tmtd_sync(dev->mtd);\n\treturn ret;\n}\n\nstatic void mtdblock_add_mtd(struct mtd_blktrans_ops *tr, struct mtd_info *mtd)\n{\n\tstruct mtdblk_dev *dev = kzalloc(sizeof(*dev), GFP_KERNEL);\n\n\tif (!dev)\n\t\treturn;\n\n\tdev->mbd.mtd = mtd;\n\tdev->mbd.devnum = mtd->index;\n\n\tdev->mbd.size = mtd->size >> 9;\n\tdev->mbd.tr = tr;\n\n\tif (!(mtd->flags & MTD_WRITEABLE))\n\t\tdev->mbd.readonly = 1;\n\n\tif (add_mtd_blktrans_dev(&dev->mbd))\n\t\tkfree(dev);\n}\n\nstatic void mtdblock_remove_dev(struct mtd_blktrans_dev *dev)\n{\n\tdel_mtd_blktrans_dev(dev);\n}\n\nstatic struct mtd_blktrans_ops mtdblock_tr = {\n\t.name\t\t= \"mtdblock\",\n\t.major\t\t= MTD_BLOCK_MAJOR,\n\t.part_bits\t= 0,\n\t.blksize \t= 512,\n\t.open\t\t= mtdblock_open,\n\t.flush\t\t= mtdblock_flush,\n\t.release\t= mtdblock_release,\n\t.readsect\t= mtdblock_readsect,\n\t.writesect\t= mtdblock_writesect,\n\t.add_mtd\t= mtdblock_add_mtd,\n\t.remove_dev\t= mtdblock_remove_dev,\n\t.owner\t\t= THIS_MODULE,\n};\n\nmodule_mtd_blktrans(mtdblock_tr);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Nicolas Pitre <nico@fluxnic.net> et al.\");\nMODULE_DESCRIPTION(\"Caching read/erase/writeback block device emulation access to MTD devices\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}