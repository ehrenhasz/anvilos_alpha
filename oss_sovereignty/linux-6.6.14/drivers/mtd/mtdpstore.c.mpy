{
  "module_name": "mtdpstore.c",
  "hash_id": "8e9d80bd52e326f47892c829fb09f12de71fe29bdf9ca3e54e8d8d273b485049",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/mtdpstore.c",
  "human_readable_source": "\n\n#define dev_fmt(fmt) \"mtdoops-pstore: \" fmt\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/pstore_blk.h>\n#include <linux/mtd/mtd.h>\n#include <linux/bitops.h>\n#include <linux/slab.h>\n\nstatic struct mtdpstore_context {\n\tint index;\n\tstruct pstore_blk_config info;\n\tstruct pstore_device_info dev;\n\tstruct mtd_info *mtd;\n\tunsigned long *rmmap;\t\t \n\tunsigned long *usedmap;\t\t \n\t \n\tunsigned long *badmap;\t\t \n} oops_cxt;\n\nstatic int mtdpstore_block_isbad(struct mtdpstore_context *cxt, loff_t off)\n{\n\tint ret;\n\tstruct mtd_info *mtd = cxt->mtd;\n\tu64 blknum;\n\n\toff = ALIGN_DOWN(off, mtd->erasesize);\n\tblknum = div_u64(off, mtd->erasesize);\n\n\tif (test_bit(blknum, cxt->badmap))\n\t\treturn true;\n\tret = mtd_block_isbad(mtd, off);\n\tif (ret < 0) {\n\t\tdev_err(&mtd->dev, \"mtd_block_isbad failed, aborting\\n\");\n\t\treturn ret;\n\t} else if (ret > 0) {\n\t\tset_bit(blknum, cxt->badmap);\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic inline int mtdpstore_panic_block_isbad(struct mtdpstore_context *cxt,\n\t\tloff_t off)\n{\n\tstruct mtd_info *mtd = cxt->mtd;\n\tu64 blknum;\n\n\toff = ALIGN_DOWN(off, mtd->erasesize);\n\tblknum = div_u64(off, mtd->erasesize);\n\treturn test_bit(blknum, cxt->badmap);\n}\n\nstatic inline void mtdpstore_mark_used(struct mtdpstore_context *cxt,\n\t\tloff_t off)\n{\n\tstruct mtd_info *mtd = cxt->mtd;\n\tu64 zonenum = div_u64(off, cxt->info.kmsg_size);\n\n\tdev_dbg(&mtd->dev, \"mark zone %llu used\\n\", zonenum);\n\tset_bit(zonenum, cxt->usedmap);\n}\n\nstatic inline void mtdpstore_mark_unused(struct mtdpstore_context *cxt,\n\t\tloff_t off)\n{\n\tstruct mtd_info *mtd = cxt->mtd;\n\tu64 zonenum = div_u64(off, cxt->info.kmsg_size);\n\n\tdev_dbg(&mtd->dev, \"mark zone %llu unused\\n\", zonenum);\n\tclear_bit(zonenum, cxt->usedmap);\n}\n\nstatic inline void mtdpstore_block_mark_unused(struct mtdpstore_context *cxt,\n\t\tloff_t off)\n{\n\tstruct mtd_info *mtd = cxt->mtd;\n\tu32 zonecnt = mtd->erasesize / cxt->info.kmsg_size;\n\tu64 zonenum;\n\n\toff = ALIGN_DOWN(off, mtd->erasesize);\n\tzonenum = div_u64(off, cxt->info.kmsg_size);\n\twhile (zonecnt > 0) {\n\t\tdev_dbg(&mtd->dev, \"mark zone %llu unused\\n\", zonenum);\n\t\tclear_bit(zonenum, cxt->usedmap);\n\t\tzonenum++;\n\t\tzonecnt--;\n\t}\n}\n\nstatic inline int mtdpstore_is_used(struct mtdpstore_context *cxt, loff_t off)\n{\n\tu64 zonenum = div_u64(off, cxt->info.kmsg_size);\n\tu64 blknum = div_u64(off, cxt->mtd->erasesize);\n\n\tif (test_bit(blknum, cxt->badmap))\n\t\treturn true;\n\treturn test_bit(zonenum, cxt->usedmap);\n}\n\nstatic int mtdpstore_block_is_used(struct mtdpstore_context *cxt,\n\t\tloff_t off)\n{\n\tstruct mtd_info *mtd = cxt->mtd;\n\tu32 zonecnt = mtd->erasesize / cxt->info.kmsg_size;\n\tu64 zonenum;\n\n\toff = ALIGN_DOWN(off, mtd->erasesize);\n\tzonenum = div_u64(off, cxt->info.kmsg_size);\n\twhile (zonecnt > 0) {\n\t\tif (test_bit(zonenum, cxt->usedmap))\n\t\t\treturn true;\n\t\tzonenum++;\n\t\tzonecnt--;\n\t}\n\treturn false;\n}\n\nstatic int mtdpstore_is_empty(struct mtdpstore_context *cxt, char *buf,\n\t\tsize_t size)\n{\n\tstruct mtd_info *mtd = cxt->mtd;\n\tsize_t sz;\n\tint i;\n\n\tsz = min_t(uint32_t, size, mtd->writesize / 4);\n\tfor (i = 0; i < sz; i++) {\n\t\tif (buf[i] != (char)0xFF)\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n\nstatic void mtdpstore_mark_removed(struct mtdpstore_context *cxt, loff_t off)\n{\n\tstruct mtd_info *mtd = cxt->mtd;\n\tu64 zonenum = div_u64(off, cxt->info.kmsg_size);\n\n\tdev_dbg(&mtd->dev, \"mark zone %llu removed\\n\", zonenum);\n\tset_bit(zonenum, cxt->rmmap);\n}\n\nstatic void mtdpstore_block_clear_removed(struct mtdpstore_context *cxt,\n\t\tloff_t off)\n{\n\tstruct mtd_info *mtd = cxt->mtd;\n\tu32 zonecnt = mtd->erasesize / cxt->info.kmsg_size;\n\tu64 zonenum;\n\n\toff = ALIGN_DOWN(off, mtd->erasesize);\n\tzonenum = div_u64(off, cxt->info.kmsg_size);\n\twhile (zonecnt > 0) {\n\t\tclear_bit(zonenum, cxt->rmmap);\n\t\tzonenum++;\n\t\tzonecnt--;\n\t}\n}\n\nstatic int mtdpstore_block_is_removed(struct mtdpstore_context *cxt,\n\t\tloff_t off)\n{\n\tstruct mtd_info *mtd = cxt->mtd;\n\tu32 zonecnt = mtd->erasesize / cxt->info.kmsg_size;\n\tu64 zonenum;\n\n\toff = ALIGN_DOWN(off, mtd->erasesize);\n\tzonenum = div_u64(off, cxt->info.kmsg_size);\n\twhile (zonecnt > 0) {\n\t\tif (test_bit(zonenum, cxt->rmmap))\n\t\t\treturn true;\n\t\tzonenum++;\n\t\tzonecnt--;\n\t}\n\treturn false;\n}\n\nstatic int mtdpstore_erase_do(struct mtdpstore_context *cxt, loff_t off)\n{\n\tstruct mtd_info *mtd = cxt->mtd;\n\tstruct erase_info erase;\n\tint ret;\n\n\toff = ALIGN_DOWN(off, cxt->mtd->erasesize);\n\tdev_dbg(&mtd->dev, \"try to erase off 0x%llx\\n\", off);\n\terase.len = cxt->mtd->erasesize;\n\terase.addr = off;\n\tret = mtd_erase(cxt->mtd, &erase);\n\tif (!ret)\n\t\tmtdpstore_block_clear_removed(cxt, off);\n\telse\n\t\tdev_err(&mtd->dev, \"erase of region [0x%llx, 0x%llx] on \\\"%s\\\" failed\\n\",\n\t\t       (unsigned long long)erase.addr,\n\t\t       (unsigned long long)erase.len, cxt->info.device);\n\treturn ret;\n}\n\n \nstatic ssize_t mtdpstore_erase(size_t size, loff_t off)\n{\n\tstruct mtdpstore_context *cxt = &oops_cxt;\n\n\tif (mtdpstore_block_isbad(cxt, off))\n\t\treturn -EIO;\n\n\tmtdpstore_mark_unused(cxt, off);\n\n\t \n\tif (likely(mtdpstore_block_is_used(cxt, off))) {\n\t\tmtdpstore_mark_removed(cxt, off);\n\t\treturn 0;\n\t}\n\n\t \n\treturn mtdpstore_erase_do(cxt, off);\n}\n\n \nstatic int mtdpstore_security(struct mtdpstore_context *cxt, loff_t off)\n{\n\tint ret = 0, i;\n\tstruct mtd_info *mtd = cxt->mtd;\n\tu32 zonenum = (u32)div_u64(off, cxt->info.kmsg_size);\n\tu32 zonecnt = (u32)div_u64(cxt->mtd->size, cxt->info.kmsg_size);\n\tu32 blkcnt = (u32)div_u64(cxt->mtd->size, cxt->mtd->erasesize);\n\tu32 erasesize = cxt->mtd->erasesize;\n\n\tfor (i = 0; i < zonecnt; i++) {\n\t\tu32 num = (zonenum + i) % zonecnt;\n\n\t\t \n\t\tif (!test_bit(num, cxt->usedmap))\n\t\t\treturn 0;\n\t}\n\n\t \n\twhile (blkcnt--) {\n\t\tdiv64_u64_rem(off + erasesize, cxt->mtd->size, (u64 *)&off);\n\n\t\tif (mtdpstore_block_isbad(cxt, off))\n\t\t\tcontinue;\n\n\t\tret = mtdpstore_erase_do(cxt, off);\n\t\tif (!ret) {\n\t\t\tmtdpstore_block_mark_unused(cxt, off);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (ret)\n\t\tdev_err(&mtd->dev, \"all blocks bad!\\n\");\n\tdev_dbg(&mtd->dev, \"end security\\n\");\n\treturn ret;\n}\n\nstatic ssize_t mtdpstore_write(const char *buf, size_t size, loff_t off)\n{\n\tstruct mtdpstore_context *cxt = &oops_cxt;\n\tstruct mtd_info *mtd = cxt->mtd;\n\tsize_t retlen;\n\tint ret;\n\n\tif (mtdpstore_block_isbad(cxt, off))\n\t\treturn -ENOMSG;\n\n\t \n\tif (mtdpstore_is_used(cxt, off))\n\t\treturn -ENOMSG;\n\n\tdev_dbg(&mtd->dev, \"try to write off 0x%llx size %zu\\n\", off, size);\n\tret = mtd_write(cxt->mtd, off, size, &retlen, (u_char *)buf);\n\tif (ret < 0 || retlen != size) {\n\t\tdev_err(&mtd->dev, \"write failure at %lld (%zu of %zu written), err %d\\n\",\n\t\t\t\toff, retlen, size, ret);\n\t\treturn -EIO;\n\t}\n\tmtdpstore_mark_used(cxt, off);\n\n\tmtdpstore_security(cxt, off);\n\treturn retlen;\n}\n\nstatic inline bool mtdpstore_is_io_error(int ret)\n{\n\treturn ret < 0 && !mtd_is_bitflip(ret) && !mtd_is_eccerr(ret);\n}\n\n \nstatic ssize_t mtdpstore_read(char *buf, size_t size, loff_t off)\n{\n\tstruct mtdpstore_context *cxt = &oops_cxt;\n\tstruct mtd_info *mtd = cxt->mtd;\n\tsize_t retlen, done;\n\tint ret;\n\n\tif (mtdpstore_block_isbad(cxt, off))\n\t\treturn -ENOMSG;\n\n\tdev_dbg(&mtd->dev, \"try to read off 0x%llx size %zu\\n\", off, size);\n\tfor (done = 0, retlen = 0; done < size; done += retlen) {\n\t\tretlen = 0;\n\n\t\tret = mtd_read(cxt->mtd, off + done, size - done, &retlen,\n\t\t\t\t(u_char *)buf + done);\n\t\tif (mtdpstore_is_io_error(ret)) {\n\t\t\tdev_err(&mtd->dev, \"read failure at %lld (%zu of %zu read), err %d\\n\",\n\t\t\t\t\toff + done, retlen, size - done, ret);\n\t\t\t \n\t\t\treturn -ENOMSG;\n\t\t}\n\n\t\t \n\t\tif (mtd_is_eccerr(ret)) {\n\t\t\tdev_err(&mtd->dev, \"ecc error at %lld (%zu of %zu read), err %d\\n\",\n\t\t\t\t\toff + done, retlen, size - done, ret);\n\t\t\t \n\t\t\tretlen = retlen == 0 ? size - done : retlen;\n\t\t}\n\t}\n\n\tif (mtdpstore_is_empty(cxt, buf, size))\n\t\tmtdpstore_mark_unused(cxt, off);\n\telse\n\t\tmtdpstore_mark_used(cxt, off);\n\n\tmtdpstore_security(cxt, off);\n\treturn retlen;\n}\n\nstatic ssize_t mtdpstore_panic_write(const char *buf, size_t size, loff_t off)\n{\n\tstruct mtdpstore_context *cxt = &oops_cxt;\n\tstruct mtd_info *mtd = cxt->mtd;\n\tsize_t retlen;\n\tint ret;\n\n\tif (mtdpstore_panic_block_isbad(cxt, off))\n\t\treturn -ENOMSG;\n\n\t \n\tif (mtdpstore_is_used(cxt, off))\n\t\treturn -ENOMSG;\n\n\tret = mtd_panic_write(cxt->mtd, off, size, &retlen, (u_char *)buf);\n\tif (ret < 0 || size != retlen) {\n\t\tdev_err(&mtd->dev, \"panic write failure at %lld (%zu of %zu read), err %d\\n\",\n\t\t\t\toff, retlen, size, ret);\n\t\treturn -EIO;\n\t}\n\tmtdpstore_mark_used(cxt, off);\n\n\treturn retlen;\n}\n\nstatic void mtdpstore_notify_add(struct mtd_info *mtd)\n{\n\tint ret;\n\tstruct mtdpstore_context *cxt = &oops_cxt;\n\tstruct pstore_blk_config *info = &cxt->info;\n\tunsigned long longcnt;\n\n\tif (!strcmp(mtd->name, info->device))\n\t\tcxt->index = mtd->index;\n\n\tif (mtd->index != cxt->index || cxt->index < 0)\n\t\treturn;\n\n\tdev_dbg(&mtd->dev, \"found matching MTD device %s\\n\", mtd->name);\n\n\tif (mtd->size < info->kmsg_size * 2) {\n\t\tdev_err(&mtd->dev, \"MTD partition %d not big enough\\n\",\n\t\t\t\tmtd->index);\n\t\treturn;\n\t}\n\t \n\tif (mtd->erasesize < info->kmsg_size) {\n\t\tdev_err(&mtd->dev, \"eraseblock size of MTD partition %d too small\\n\",\n\t\t\t\tmtd->index);\n\t\treturn;\n\t}\n\tif (unlikely(info->kmsg_size % mtd->writesize)) {\n\t\tdev_err(&mtd->dev, \"record size %lu KB must align to write size %d KB\\n\",\n\t\t\t\tinfo->kmsg_size / 1024,\n\t\t\t\tmtd->writesize / 1024);\n\t\treturn;\n\t}\n\n\tlongcnt = BITS_TO_LONGS(div_u64(mtd->size, info->kmsg_size));\n\tcxt->rmmap = kcalloc(longcnt, sizeof(long), GFP_KERNEL);\n\tcxt->usedmap = kcalloc(longcnt, sizeof(long), GFP_KERNEL);\n\n\tlongcnt = BITS_TO_LONGS(div_u64(mtd->size, mtd->erasesize));\n\tcxt->badmap = kcalloc(longcnt, sizeof(long), GFP_KERNEL);\n\n\t \n\tcxt->dev.flags = PSTORE_FLAGS_DMESG;\n\tcxt->dev.zone.read = mtdpstore_read;\n\tcxt->dev.zone.write = mtdpstore_write;\n\tcxt->dev.zone.erase = mtdpstore_erase;\n\tcxt->dev.zone.panic_write = mtdpstore_panic_write;\n\tcxt->dev.zone.total_size = mtd->size;\n\n\tret = register_pstore_device(&cxt->dev);\n\tif (ret) {\n\t\tdev_err(&mtd->dev, \"mtd%d register to psblk failed\\n\",\n\t\t\t\tmtd->index);\n\t\treturn;\n\t}\n\tcxt->mtd = mtd;\n\tdev_info(&mtd->dev, \"Attached to MTD device %d\\n\", mtd->index);\n}\n\nstatic int mtdpstore_flush_removed_do(struct mtdpstore_context *cxt,\n\t\tloff_t off, size_t size)\n{\n\tstruct mtd_info *mtd = cxt->mtd;\n\tu_char *buf;\n\tint ret;\n\tsize_t retlen;\n\tstruct erase_info erase;\n\n\tbuf = kmalloc(mtd->erasesize, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\t \n\tret = mtd_read(mtd, off, mtd->erasesize, &retlen, buf);\n\tif (mtdpstore_is_io_error(ret))\n\t\tgoto free;\n\n\t \n\terase.len = mtd->erasesize;\n\terase.addr = off;\n\tret = mtd_erase(mtd, &erase);\n\tif (ret)\n\t\tgoto free;\n\n\t \n\twhile (size) {\n\t\tunsigned int zonesize = cxt->info.kmsg_size;\n\n\t\t \n\t\tif (mtdpstore_is_used(cxt, off)) {\n\t\t\tret = mtd_write(mtd, off, zonesize, &retlen, buf);\n\t\t\tif (ret)\n\t\t\t\tdev_err(&mtd->dev, \"write failure at %lld (%zu of %u written), err %d\\n\",\n\t\t\t\t\t\toff, retlen, zonesize, ret);\n\t\t}\n\n\t\toff += zonesize;\n\t\tsize -= min_t(unsigned int, zonesize, size);\n\t}\n\nfree:\n\tkfree(buf);\n\treturn ret;\n}\n\n \nstatic int mtdpstore_flush_removed(struct mtdpstore_context *cxt)\n{\n\tstruct mtd_info *mtd = cxt->mtd;\n\tint ret;\n\tloff_t off;\n\tu32 blkcnt = (u32)div_u64(mtd->size, mtd->erasesize);\n\n\tfor (off = 0; blkcnt > 0; blkcnt--, off += mtd->erasesize) {\n\t\tret = mtdpstore_block_isbad(cxt, off);\n\t\tif (ret)\n\t\t\tcontinue;\n\n\t\tret = mtdpstore_block_is_removed(cxt, off);\n\t\tif (!ret)\n\t\t\tcontinue;\n\n\t\tret = mtdpstore_flush_removed_do(cxt, off, mtd->erasesize);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nstatic void mtdpstore_notify_remove(struct mtd_info *mtd)\n{\n\tstruct mtdpstore_context *cxt = &oops_cxt;\n\n\tif (mtd->index != cxt->index || cxt->index < 0)\n\t\treturn;\n\n\tmtdpstore_flush_removed(cxt);\n\n\tunregister_pstore_device(&cxt->dev);\n\tkfree(cxt->badmap);\n\tkfree(cxt->usedmap);\n\tkfree(cxt->rmmap);\n\tcxt->mtd = NULL;\n\tcxt->index = -1;\n}\n\nstatic struct mtd_notifier mtdpstore_notifier = {\n\t.add\t= mtdpstore_notify_add,\n\t.remove\t= mtdpstore_notify_remove,\n};\n\nstatic int __init mtdpstore_init(void)\n{\n\tint ret;\n\tstruct mtdpstore_context *cxt = &oops_cxt;\n\tstruct pstore_blk_config *info = &cxt->info;\n\n\tret = pstore_blk_get_config(info);\n\tif (unlikely(ret))\n\t\treturn ret;\n\n\tif (strlen(info->device) == 0) {\n\t\tpr_err(\"mtd device must be supplied (device name is empty)\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (!info->kmsg_size) {\n\t\tpr_err(\"no backend enabled (kmsg_size is 0)\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tret = kstrtoint((char *)info->device, 0, &cxt->index);\n\tif (ret)\n\t\tcxt->index = -1;\n\n\tregister_mtd_user(&mtdpstore_notifier);\n\treturn 0;\n}\nmodule_init(mtdpstore_init);\n\nstatic void __exit mtdpstore_exit(void)\n{\n\tunregister_mtd_user(&mtdpstore_notifier);\n}\nmodule_exit(mtdpstore_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"WeiXiong Liao <liaoweixiong@allwinnertech.com>\");\nMODULE_DESCRIPTION(\"MTD backend for pstore/blk\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}