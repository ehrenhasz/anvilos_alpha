{
  "module_name": "mtdconcat.c",
  "hash_id": "f9522ca38b5cb5f486304f012ff88a55ad47323fac7a4716597ab67cbbd4c6e8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/mtdconcat.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/backing-dev.h>\n\n#include <linux/mtd/mtd.h>\n#include <linux/mtd/concat.h>\n\n#include <asm/div64.h>\n\n \nstruct mtd_concat {\n\tstruct mtd_info mtd;\n\tint num_subdev;\n\tstruct mtd_info **subdev;\n};\n\n \n#define SIZEOF_STRUCT_MTD_CONCAT(num_subdev)\t\\\n\t((sizeof(struct mtd_concat) + (num_subdev) * sizeof(struct mtd_info *)))\n\n \n#define CONCAT(x)  ((struct mtd_concat *)(x))\n\n \n\nstatic int\nconcat_read(struct mtd_info *mtd, loff_t from, size_t len,\n\t    size_t * retlen, u_char * buf)\n{\n\tstruct mtd_concat *concat = CONCAT(mtd);\n\tint ret = 0, err;\n\tint i;\n\n\tfor (i = 0; i < concat->num_subdev; i++) {\n\t\tstruct mtd_info *subdev = concat->subdev[i];\n\t\tsize_t size, retsize;\n\n\t\tif (from >= subdev->size) {\n\t\t\t \n\t\t\tsize = 0;\n\t\t\tfrom -= subdev->size;\n\t\t\tcontinue;\n\t\t}\n\t\tif (from + len > subdev->size)\n\t\t\t \n\t\t\tsize = subdev->size - from;\n\t\telse\n\t\t\t \n\t\t\tsize = len;\n\n\t\terr = mtd_read(subdev, from, size, &retsize, buf);\n\n\t\t \n\t\tif (unlikely(err)) {\n\t\t\tif (mtd_is_eccerr(err)) {\n\t\t\t\tmtd->ecc_stats.failed++;\n\t\t\t\tret = err;\n\t\t\t} else if (mtd_is_bitflip(err)) {\n\t\t\t\tmtd->ecc_stats.corrected++;\n\t\t\t\t \n\t\t\t\tif (!ret)\n\t\t\t\t\tret = err;\n\t\t\t} else\n\t\t\t\treturn err;\n\t\t}\n\n\t\t*retlen += retsize;\n\t\tlen -= size;\n\t\tif (len == 0)\n\t\t\treturn ret;\n\n\t\tbuf += size;\n\t\tfrom = 0;\n\t}\n\treturn -EINVAL;\n}\n\nstatic int\nconcat_panic_write(struct mtd_info *mtd, loff_t to, size_t len,\n\t     size_t * retlen, const u_char * buf)\n{\n\tstruct mtd_concat *concat = CONCAT(mtd);\n\tint err = -EINVAL;\n\tint i;\n\tfor (i = 0; i < concat->num_subdev; i++) {\n\t\tstruct mtd_info *subdev = concat->subdev[i];\n\t\tsize_t size, retsize;\n\n\t\tif (to >= subdev->size) {\n\t\t\tto -= subdev->size;\n\t\t\tcontinue;\n\t\t}\n\t\tif (to + len > subdev->size)\n\t\t\tsize = subdev->size - to;\n\t\telse\n\t\t\tsize = len;\n\n\t\terr = mtd_panic_write(subdev, to, size, &retsize, buf);\n\t\tif (err == -EOPNOTSUPP) {\n\t\t\tprintk(KERN_ERR \"mtdconcat: Cannot write from panic without panic_write\\n\");\n\t\t\treturn err;\n\t\t}\n\t\tif (err)\n\t\t\tbreak;\n\n\t\t*retlen += retsize;\n\t\tlen -= size;\n\t\tif (len == 0)\n\t\t\tbreak;\n\n\t\terr = -EINVAL;\n\t\tbuf += size;\n\t\tto = 0;\n\t}\n\treturn err;\n}\n\n\nstatic int\nconcat_write(struct mtd_info *mtd, loff_t to, size_t len,\n\t     size_t * retlen, const u_char * buf)\n{\n\tstruct mtd_concat *concat = CONCAT(mtd);\n\tint err = -EINVAL;\n\tint i;\n\n\tfor (i = 0; i < concat->num_subdev; i++) {\n\t\tstruct mtd_info *subdev = concat->subdev[i];\n\t\tsize_t size, retsize;\n\n\t\tif (to >= subdev->size) {\n\t\t\tsize = 0;\n\t\t\tto -= subdev->size;\n\t\t\tcontinue;\n\t\t}\n\t\tif (to + len > subdev->size)\n\t\t\tsize = subdev->size - to;\n\t\telse\n\t\t\tsize = len;\n\n\t\terr = mtd_write(subdev, to, size, &retsize, buf);\n\t\tif (err)\n\t\t\tbreak;\n\n\t\t*retlen += retsize;\n\t\tlen -= size;\n\t\tif (len == 0)\n\t\t\tbreak;\n\n\t\terr = -EINVAL;\n\t\tbuf += size;\n\t\tto = 0;\n\t}\n\treturn err;\n}\n\nstatic int\nconcat_writev(struct mtd_info *mtd, const struct kvec *vecs,\n\t\tunsigned long count, loff_t to, size_t * retlen)\n{\n\tstruct mtd_concat *concat = CONCAT(mtd);\n\tstruct kvec *vecs_copy;\n\tunsigned long entry_low, entry_high;\n\tsize_t total_len = 0;\n\tint i;\n\tint err = -EINVAL;\n\n\t \n\tfor (i = 0; i < count; i++)\n\t\ttotal_len += vecs[i].iov_len;\n\n\t \n\tif (mtd->writesize > 1) {\n\t\tuint64_t __to = to;\n\t\tif (do_div(__to, mtd->writesize) || (total_len % mtd->writesize))\n\t\t\treturn -EINVAL;\n\t}\n\n\t \n\tvecs_copy = kmemdup(vecs, sizeof(struct kvec) * count, GFP_KERNEL);\n\tif (!vecs_copy)\n\t\treturn -ENOMEM;\n\n\tentry_low = 0;\n\tfor (i = 0; i < concat->num_subdev; i++) {\n\t\tstruct mtd_info *subdev = concat->subdev[i];\n\t\tsize_t size, wsize, retsize, old_iov_len;\n\n\t\tif (to >= subdev->size) {\n\t\t\tto -= subdev->size;\n\t\t\tcontinue;\n\t\t}\n\n\t\tsize = min_t(uint64_t, total_len, subdev->size - to);\n\t\twsize = size;  \n\n\t\tentry_high = entry_low;\n\t\twhile (entry_high < count) {\n\t\t\tif (size <= vecs_copy[entry_high].iov_len)\n\t\t\t\tbreak;\n\t\t\tsize -= vecs_copy[entry_high++].iov_len;\n\t\t}\n\n\t\told_iov_len = vecs_copy[entry_high].iov_len;\n\t\tvecs_copy[entry_high].iov_len = size;\n\n\t\terr = mtd_writev(subdev, &vecs_copy[entry_low],\n\t\t\t\t entry_high - entry_low + 1, to, &retsize);\n\n\t\tvecs_copy[entry_high].iov_len = old_iov_len - size;\n\t\tvecs_copy[entry_high].iov_base += size;\n\n\t\tentry_low = entry_high;\n\n\t\tif (err)\n\t\t\tbreak;\n\n\t\t*retlen += retsize;\n\t\ttotal_len -= wsize;\n\n\t\tif (total_len == 0)\n\t\t\tbreak;\n\n\t\terr = -EINVAL;\n\t\tto = 0;\n\t}\n\n\tkfree(vecs_copy);\n\treturn err;\n}\n\nstatic int\nconcat_read_oob(struct mtd_info *mtd, loff_t from, struct mtd_oob_ops *ops)\n{\n\tstruct mtd_concat *concat = CONCAT(mtd);\n\tstruct mtd_oob_ops devops = *ops;\n\tint i, err, ret = 0;\n\n\tops->retlen = ops->oobretlen = 0;\n\n\tfor (i = 0; i < concat->num_subdev; i++) {\n\t\tstruct mtd_info *subdev = concat->subdev[i];\n\n\t\tif (from >= subdev->size) {\n\t\t\tfrom -= subdev->size;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (from + devops.len > subdev->size)\n\t\t\tdevops.len = subdev->size - from;\n\n\t\terr = mtd_read_oob(subdev, from, &devops);\n\t\tops->retlen += devops.retlen;\n\t\tops->oobretlen += devops.oobretlen;\n\n\t\t \n\t\tif (unlikely(err)) {\n\t\t\tif (mtd_is_eccerr(err)) {\n\t\t\t\tmtd->ecc_stats.failed++;\n\t\t\t\tret = err;\n\t\t\t} else if (mtd_is_bitflip(err)) {\n\t\t\t\tmtd->ecc_stats.corrected++;\n\t\t\t\t \n\t\t\t\tif (!ret)\n\t\t\t\t\tret = err;\n\t\t\t} else\n\t\t\t\treturn err;\n\t\t}\n\n\t\tif (devops.datbuf) {\n\t\t\tdevops.len = ops->len - ops->retlen;\n\t\t\tif (!devops.len)\n\t\t\t\treturn ret;\n\t\t\tdevops.datbuf += devops.retlen;\n\t\t}\n\t\tif (devops.oobbuf) {\n\t\t\tdevops.ooblen = ops->ooblen - ops->oobretlen;\n\t\t\tif (!devops.ooblen)\n\t\t\t\treturn ret;\n\t\t\tdevops.oobbuf += ops->oobretlen;\n\t\t}\n\n\t\tfrom = 0;\n\t}\n\treturn -EINVAL;\n}\n\nstatic int\nconcat_write_oob(struct mtd_info *mtd, loff_t to, struct mtd_oob_ops *ops)\n{\n\tstruct mtd_concat *concat = CONCAT(mtd);\n\tstruct mtd_oob_ops devops = *ops;\n\tint i, err;\n\n\tif (!(mtd->flags & MTD_WRITEABLE))\n\t\treturn -EROFS;\n\n\tops->retlen = ops->oobretlen = 0;\n\n\tfor (i = 0; i < concat->num_subdev; i++) {\n\t\tstruct mtd_info *subdev = concat->subdev[i];\n\n\t\tif (to >= subdev->size) {\n\t\t\tto -= subdev->size;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (to + devops.len > subdev->size)\n\t\t\tdevops.len = subdev->size - to;\n\n\t\terr = mtd_write_oob(subdev, to, &devops);\n\t\tops->retlen += devops.retlen;\n\t\tops->oobretlen += devops.oobretlen;\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (devops.datbuf) {\n\t\t\tdevops.len = ops->len - ops->retlen;\n\t\t\tif (!devops.len)\n\t\t\t\treturn 0;\n\t\t\tdevops.datbuf += devops.retlen;\n\t\t}\n\t\tif (devops.oobbuf) {\n\t\t\tdevops.ooblen = ops->ooblen - ops->oobretlen;\n\t\t\tif (!devops.ooblen)\n\t\t\t\treturn 0;\n\t\t\tdevops.oobbuf += devops.oobretlen;\n\t\t}\n\t\tto = 0;\n\t}\n\treturn -EINVAL;\n}\n\nstatic int concat_erase(struct mtd_info *mtd, struct erase_info *instr)\n{\n\tstruct mtd_concat *concat = CONCAT(mtd);\n\tstruct mtd_info *subdev;\n\tint i, err;\n\tuint64_t length, offset = 0;\n\tstruct erase_info *erase;\n\n\t \n\tif (!concat->mtd.numeraseregions) {\n\t\t \n\t\tif (instr->addr & (concat->mtd.erasesize - 1))\n\t\t\treturn -EINVAL;\n\t\tif (instr->len & (concat->mtd.erasesize - 1))\n\t\t\treturn -EINVAL;\n\t} else {\n\t\t \n\t\tstruct mtd_erase_region_info *erase_regions =\n\t\t    concat->mtd.eraseregions;\n\n\t\t \n\t\tfor (i = 0; i < concat->mtd.numeraseregions &&\n\t\t     instr->addr >= erase_regions[i].offset; i++) ;\n\t\t--i;\n\n\t\t \n\t\tif (i < 0 || instr->addr & (erase_regions[i].erasesize - 1))\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\tfor (; i < concat->mtd.numeraseregions &&\n\t\t     (instr->addr + instr->len) >= erase_regions[i].offset;\n\t\t     ++i) ;\n\t\t--i;\n\t\t \n\t\tif (i < 0 || ((instr->addr + instr->len) &\n\t\t\t\t\t(erase_regions[i].erasesize - 1)))\n\t\t\treturn -EINVAL;\n\t}\n\n\t \n\terase = kmalloc(sizeof (struct erase_info), GFP_KERNEL);\n\n\tif (!erase)\n\t\treturn -ENOMEM;\n\n\t*erase = *instr;\n\tlength = instr->len;\n\n\t \n\tfor (i = 0; i < concat->num_subdev; i++) {\n\t\tsubdev = concat->subdev[i];\n\t\tif (subdev->size <= erase->addr) {\n\t\t\terase->addr -= subdev->size;\n\t\t\toffset += subdev->size;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tBUG_ON(i >= concat->num_subdev);\n\n\t \n\terr = 0;\n\tfor (; length > 0; i++) {\n\t\t \n\t\tsubdev = concat->subdev[i];\t \n\n\t\t \n\t\tif (erase->addr + length > subdev->size)\n\t\t\terase->len = subdev->size - erase->addr;\n\t\telse\n\t\t\terase->len = length;\n\n\t\tlength -= erase->len;\n\t\tif ((err = mtd_erase(subdev, erase))) {\n\t\t\t \n\t\t\tBUG_ON(err == -EINVAL);\n\t\t\tif (erase->fail_addr != MTD_FAIL_ADDR_UNKNOWN)\n\t\t\t\tinstr->fail_addr = erase->fail_addr + offset;\n\t\t\tbreak;\n\t\t}\n\t\t \n\t\terase->addr = 0;\n\t\toffset += subdev->size;\n\t}\n\tkfree(erase);\n\n\treturn err;\n}\n\nstatic int concat_xxlock(struct mtd_info *mtd, loff_t ofs, uint64_t len,\n\t\t\t bool is_lock)\n{\n\tstruct mtd_concat *concat = CONCAT(mtd);\n\tint i, err = -EINVAL;\n\n\tfor (i = 0; i < concat->num_subdev; i++) {\n\t\tstruct mtd_info *subdev = concat->subdev[i];\n\t\tuint64_t size;\n\n\t\tif (ofs >= subdev->size) {\n\t\t\tsize = 0;\n\t\t\tofs -= subdev->size;\n\t\t\tcontinue;\n\t\t}\n\t\tif (ofs + len > subdev->size)\n\t\t\tsize = subdev->size - ofs;\n\t\telse\n\t\t\tsize = len;\n\n\t\tif (is_lock)\n\t\t\terr = mtd_lock(subdev, ofs, size);\n\t\telse\n\t\t\terr = mtd_unlock(subdev, ofs, size);\n\t\tif (err)\n\t\t\tbreak;\n\n\t\tlen -= size;\n\t\tif (len == 0)\n\t\t\tbreak;\n\n\t\terr = -EINVAL;\n\t\tofs = 0;\n\t}\n\n\treturn err;\n}\n\nstatic int concat_lock(struct mtd_info *mtd, loff_t ofs, uint64_t len)\n{\n\treturn concat_xxlock(mtd, ofs, len, true);\n}\n\nstatic int concat_unlock(struct mtd_info *mtd, loff_t ofs, uint64_t len)\n{\n\treturn concat_xxlock(mtd, ofs, len, false);\n}\n\nstatic int concat_is_locked(struct mtd_info *mtd, loff_t ofs, uint64_t len)\n{\n\tstruct mtd_concat *concat = CONCAT(mtd);\n\tint i, err = -EINVAL;\n\n\tfor (i = 0; i < concat->num_subdev; i++) {\n\t\tstruct mtd_info *subdev = concat->subdev[i];\n\n\t\tif (ofs >= subdev->size) {\n\t\t\tofs -= subdev->size;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (ofs + len > subdev->size)\n\t\t\tbreak;\n\n\t\treturn mtd_is_locked(subdev, ofs, len);\n\t}\n\n\treturn err;\n}\n\nstatic void concat_sync(struct mtd_info *mtd)\n{\n\tstruct mtd_concat *concat = CONCAT(mtd);\n\tint i;\n\n\tfor (i = 0; i < concat->num_subdev; i++) {\n\t\tstruct mtd_info *subdev = concat->subdev[i];\n\t\tmtd_sync(subdev);\n\t}\n}\n\nstatic int concat_suspend(struct mtd_info *mtd)\n{\n\tstruct mtd_concat *concat = CONCAT(mtd);\n\tint i, rc = 0;\n\n\tfor (i = 0; i < concat->num_subdev; i++) {\n\t\tstruct mtd_info *subdev = concat->subdev[i];\n\t\tif ((rc = mtd_suspend(subdev)) < 0)\n\t\t\treturn rc;\n\t}\n\treturn rc;\n}\n\nstatic void concat_resume(struct mtd_info *mtd)\n{\n\tstruct mtd_concat *concat = CONCAT(mtd);\n\tint i;\n\n\tfor (i = 0; i < concat->num_subdev; i++) {\n\t\tstruct mtd_info *subdev = concat->subdev[i];\n\t\tmtd_resume(subdev);\n\t}\n}\n\nstatic int concat_block_isbad(struct mtd_info *mtd, loff_t ofs)\n{\n\tstruct mtd_concat *concat = CONCAT(mtd);\n\tint i, res = 0;\n\n\tif (!mtd_can_have_bb(concat->subdev[0]))\n\t\treturn res;\n\n\tfor (i = 0; i < concat->num_subdev; i++) {\n\t\tstruct mtd_info *subdev = concat->subdev[i];\n\n\t\tif (ofs >= subdev->size) {\n\t\t\tofs -= subdev->size;\n\t\t\tcontinue;\n\t\t}\n\n\t\tres = mtd_block_isbad(subdev, ofs);\n\t\tbreak;\n\t}\n\n\treturn res;\n}\n\nstatic int concat_block_markbad(struct mtd_info *mtd, loff_t ofs)\n{\n\tstruct mtd_concat *concat = CONCAT(mtd);\n\tint i, err = -EINVAL;\n\n\tfor (i = 0; i < concat->num_subdev; i++) {\n\t\tstruct mtd_info *subdev = concat->subdev[i];\n\n\t\tif (ofs >= subdev->size) {\n\t\t\tofs -= subdev->size;\n\t\t\tcontinue;\n\t\t}\n\n\t\terr = mtd_block_markbad(subdev, ofs);\n\t\tif (!err)\n\t\t\tmtd->ecc_stats.badblocks++;\n\t\tbreak;\n\t}\n\n\treturn err;\n}\n\n \nstruct mtd_info *mtd_concat_create(struct mtd_info *subdev[],\t \n\t\t\t\t   int num_devs,\t \n\t\t\t\t   const char *name)\n{\t\t\t\t \n\tint i;\n\tsize_t size;\n\tstruct mtd_concat *concat;\n\tstruct mtd_info *subdev_master = NULL;\n\tuint32_t max_erasesize, curr_erasesize;\n\tint num_erase_region;\n\tint max_writebufsize = 0;\n\n\tprintk(KERN_NOTICE \"Concatenating MTD devices:\\n\");\n\tfor (i = 0; i < num_devs; i++)\n\t\tprintk(KERN_NOTICE \"(%d): \\\"%s\\\"\\n\", i, subdev[i]->name);\n\tprintk(KERN_NOTICE \"into device \\\"%s\\\"\\n\", name);\n\n\t \n\tsize = SIZEOF_STRUCT_MTD_CONCAT(num_devs);\n\tconcat = kzalloc(size, GFP_KERNEL);\n\tif (!concat) {\n\t\tprintk\n\t\t    (\"memory allocation error while creating concatenated device \\\"%s\\\"\\n\",\n\t\t     name);\n\t\treturn NULL;\n\t}\n\tconcat->subdev = (struct mtd_info **) (concat + 1);\n\n\t \n\tconcat->mtd.type = subdev[0]->type;\n\tconcat->mtd.flags = subdev[0]->flags;\n\tconcat->mtd.size = subdev[0]->size;\n\tconcat->mtd.erasesize = subdev[0]->erasesize;\n\tconcat->mtd.writesize = subdev[0]->writesize;\n\n\tfor (i = 0; i < num_devs; i++)\n\t\tif (max_writebufsize < subdev[i]->writebufsize)\n\t\t\tmax_writebufsize = subdev[i]->writebufsize;\n\tconcat->mtd.writebufsize = max_writebufsize;\n\n\tconcat->mtd.subpage_sft = subdev[0]->subpage_sft;\n\tconcat->mtd.oobsize = subdev[0]->oobsize;\n\tconcat->mtd.oobavail = subdev[0]->oobavail;\n\n\tsubdev_master = mtd_get_master(subdev[0]);\n\tif (subdev_master->_writev)\n\t\tconcat->mtd._writev = concat_writev;\n\tif (subdev_master->_read_oob)\n\t\tconcat->mtd._read_oob = concat_read_oob;\n\tif (subdev_master->_write_oob)\n\t\tconcat->mtd._write_oob = concat_write_oob;\n\tif (subdev_master->_block_isbad)\n\t\tconcat->mtd._block_isbad = concat_block_isbad;\n\tif (subdev_master->_block_markbad)\n\t\tconcat->mtd._block_markbad = concat_block_markbad;\n\tif (subdev_master->_panic_write)\n\t\tconcat->mtd._panic_write = concat_panic_write;\n\tif (subdev_master->_read)\n\t\tconcat->mtd._read = concat_read;\n\tif (subdev_master->_write)\n\t\tconcat->mtd._write = concat_write;\n\n\tconcat->mtd.ecc_stats.badblocks = subdev[0]->ecc_stats.badblocks;\n\n\tconcat->subdev[0] = subdev[0];\n\n\tfor (i = 1; i < num_devs; i++) {\n\t\tif (concat->mtd.type != subdev[i]->type) {\n\t\t\tkfree(concat);\n\t\t\tprintk(\"Incompatible device type on \\\"%s\\\"\\n\",\n\t\t\t       subdev[i]->name);\n\t\t\treturn NULL;\n\t\t}\n\t\tif (concat->mtd.flags != subdev[i]->flags) {\n\t\t\t \n\t\t\tif ((concat->mtd.flags ^ subdev[i]->\n\t\t\t     flags) & ~MTD_WRITEABLE) {\n\t\t\t\tkfree(concat);\n\t\t\t\tprintk(\"Incompatible device flags on \\\"%s\\\"\\n\",\n\t\t\t\t       subdev[i]->name);\n\t\t\t\treturn NULL;\n\t\t\t} else\n\t\t\t\t \n\t\t\t\tconcat->mtd.flags |=\n\t\t\t\t    subdev[i]->flags & MTD_WRITEABLE;\n\t\t}\n\n\t\tsubdev_master = mtd_get_master(subdev[i]);\n\t\tconcat->mtd.size += subdev[i]->size;\n\t\tconcat->mtd.ecc_stats.badblocks +=\n\t\t\tsubdev[i]->ecc_stats.badblocks;\n\t\tif (concat->mtd.writesize   !=  subdev[i]->writesize ||\n\t\t    concat->mtd.subpage_sft != subdev[i]->subpage_sft ||\n\t\t    concat->mtd.oobsize    !=  subdev[i]->oobsize ||\n\t\t    !concat->mtd._read_oob  != !subdev_master->_read_oob ||\n\t\t    !concat->mtd._write_oob != !subdev_master->_write_oob) {\n\t\t\t \n\t\t\tkfree(concat);\n\t\t\tprintk(\"Incompatible OOB or ECC data on \\\"%s\\\"\\n\",\n\t\t\t       subdev[i]->name);\n\t\t\treturn NULL;\n\t\t}\n\t\tconcat->subdev[i] = subdev[i];\n\n\t}\n\n\tmtd_set_ooblayout(&concat->mtd, subdev[0]->ooblayout);\n\n\tconcat->num_subdev = num_devs;\n\tconcat->mtd.name = name;\n\n\tconcat->mtd._erase = concat_erase;\n\tconcat->mtd._sync = concat_sync;\n\tconcat->mtd._lock = concat_lock;\n\tconcat->mtd._unlock = concat_unlock;\n\tconcat->mtd._is_locked = concat_is_locked;\n\tconcat->mtd._suspend = concat_suspend;\n\tconcat->mtd._resume = concat_resume;\n\n\t \n\tmax_erasesize = curr_erasesize = subdev[0]->erasesize;\n\tnum_erase_region = 1;\n\tfor (i = 0; i < num_devs; i++) {\n\t\tif (subdev[i]->numeraseregions == 0) {\n\t\t\t \n\t\t\tif (subdev[i]->erasesize != curr_erasesize) {\n\t\t\t\t \n\t\t\t\t++num_erase_region;\n\t\t\t\tcurr_erasesize = subdev[i]->erasesize;\n\t\t\t\tif (curr_erasesize > max_erasesize)\n\t\t\t\t\tmax_erasesize = curr_erasesize;\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tint j;\n\t\t\tfor (j = 0; j < subdev[i]->numeraseregions; j++) {\n\n\t\t\t\t \n\t\t\t\tif (subdev[i]->eraseregions[j].erasesize !=\n\t\t\t\t    curr_erasesize) {\n\t\t\t\t\t++num_erase_region;\n\t\t\t\t\tcurr_erasesize =\n\t\t\t\t\t    subdev[i]->eraseregions[j].\n\t\t\t\t\t    erasesize;\n\t\t\t\t\tif (curr_erasesize > max_erasesize)\n\t\t\t\t\t\tmax_erasesize = curr_erasesize;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (num_erase_region == 1) {\n\t\t \n\t\tconcat->mtd.erasesize = curr_erasesize;\n\t\tconcat->mtd.numeraseregions = 0;\n\t} else {\n\t\tuint64_t tmp64;\n\n\t\t \n\t\tstruct mtd_erase_region_info *erase_region_p;\n\t\tuint64_t begin, position;\n\n\t\tconcat->mtd.erasesize = max_erasesize;\n\t\tconcat->mtd.numeraseregions = num_erase_region;\n\t\tconcat->mtd.eraseregions = erase_region_p =\n\t\t    kmalloc_array(num_erase_region,\n\t\t\t\t  sizeof(struct mtd_erase_region_info),\n\t\t\t\t  GFP_KERNEL);\n\t\tif (!erase_region_p) {\n\t\t\tkfree(concat);\n\t\t\tprintk\n\t\t\t    (\"memory allocation error while creating erase region list\"\n\t\t\t     \" for device \\\"%s\\\"\\n\", name);\n\t\t\treturn NULL;\n\t\t}\n\n\t\t \n\t\tcurr_erasesize = subdev[0]->erasesize;\n\t\tbegin = position = 0;\n\t\tfor (i = 0; i < num_devs; i++) {\n\t\t\tif (subdev[i]->numeraseregions == 0) {\n\t\t\t\t \n\t\t\t\tif (subdev[i]->erasesize != curr_erasesize) {\n\t\t\t\t\t \n\t\t\t\t\terase_region_p->offset = begin;\n\t\t\t\t\terase_region_p->erasesize =\n\t\t\t\t\t    curr_erasesize;\n\t\t\t\t\ttmp64 = position - begin;\n\t\t\t\t\tdo_div(tmp64, curr_erasesize);\n\t\t\t\t\terase_region_p->numblocks = tmp64;\n\t\t\t\t\tbegin = position;\n\n\t\t\t\t\tcurr_erasesize = subdev[i]->erasesize;\n\t\t\t\t\t++erase_region_p;\n\t\t\t\t}\n\t\t\t\tposition += subdev[i]->size;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tint j;\n\t\t\t\tfor (j = 0; j < subdev[i]->numeraseregions; j++) {\n\t\t\t\t\t \n\t\t\t\t\tif (subdev[i]->eraseregions[j].\n\t\t\t\t\t    erasesize != curr_erasesize) {\n\t\t\t\t\t\terase_region_p->offset = begin;\n\t\t\t\t\t\terase_region_p->erasesize =\n\t\t\t\t\t\t    curr_erasesize;\n\t\t\t\t\t\ttmp64 = position - begin;\n\t\t\t\t\t\tdo_div(tmp64, curr_erasesize);\n\t\t\t\t\t\terase_region_p->numblocks = tmp64;\n\t\t\t\t\t\tbegin = position;\n\n\t\t\t\t\t\tcurr_erasesize =\n\t\t\t\t\t\t    subdev[i]->eraseregions[j].\n\t\t\t\t\t\t    erasesize;\n\t\t\t\t\t\t++erase_region_p;\n\t\t\t\t\t}\n\t\t\t\t\tposition +=\n\t\t\t\t\t    subdev[i]->eraseregions[j].\n\t\t\t\t\t    numblocks * (uint64_t)curr_erasesize;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t \n\t\terase_region_p->offset = begin;\n\t\terase_region_p->erasesize = curr_erasesize;\n\t\ttmp64 = position - begin;\n\t\tdo_div(tmp64, curr_erasesize);\n\t\terase_region_p->numblocks = tmp64;\n\t}\n\n\treturn &concat->mtd;\n}\n\n \nvoid mtd_concat_destroy(struct mtd_info *mtd)\n{\n\tstruct mtd_concat *concat = CONCAT(mtd);\n\tif (concat->mtd.numeraseregions)\n\t\tkfree(concat->mtd.eraseregions);\n\tkfree(concat);\n}\n\nEXPORT_SYMBOL(mtd_concat_create);\nEXPORT_SYMBOL(mtd_concat_destroy);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Robert Kaiser <rkaiser@sysgo.de>\");\nMODULE_DESCRIPTION(\"Generic support for concatenating of MTD devices\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}