{
  "module_name": "inftlmount.c",
  "hash_id": "1a6d447d4ec4e80b13ef7636319d2db094ed2510488ce06849318d64a79aa2dc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/inftlmount.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <asm/errno.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/mtd/mtd.h>\n#include <linux/mtd/nftl.h>\n#include <linux/mtd/inftl.h>\n\n \nstatic int find_boot_record(struct INFTLrecord *inftl)\n{\n\tstruct inftl_unittail h1;\n\t\n\tunsigned int i, block;\n\tu8 buf[SECTORSIZE];\n\tstruct INFTLMediaHeader *mh = &inftl->MediaHdr;\n\tstruct mtd_info *mtd = inftl->mbd.mtd;\n\tstruct INFTLPartition *ip;\n\tsize_t retlen;\n\n\tpr_debug(\"INFTL: find_boot_record(inftl=%p)\\n\", inftl);\n\n         \n\tinftl->EraseSize = inftl->mbd.mtd->erasesize;\n        inftl->nb_blocks = (u32)inftl->mbd.mtd->size / inftl->EraseSize;\n\n\tinftl->MediaUnit = BLOCK_NIL;\n\n\t \n\tfor (block = 0; block < inftl->nb_blocks; block++) {\n\t\tint ret;\n\n\t\t \n\t\tret = mtd_read(mtd, block * inftl->EraseSize, SECTORSIZE,\n\t\t\t       &retlen, buf);\n\t\t \n\t\tif (retlen != SECTORSIZE) {\n\t\t\tstatic int warncount = 5;\n\n\t\t\tif (warncount) {\n\t\t\t\tprintk(KERN_WARNING \"INFTL: block read at 0x%x \"\n\t\t\t\t\t\"of mtd%d failed: %d\\n\",\n\t\t\t\t\tblock * inftl->EraseSize,\n\t\t\t\t\tinftl->mbd.mtd->index, ret);\n\t\t\t\tif (!--warncount)\n\t\t\t\t\tprintk(KERN_WARNING \"INFTL: further \"\n\t\t\t\t\t\t\"failures for this block will \"\n\t\t\t\t\t\t\"not be printed\\n\");\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (retlen < 6 || memcmp(buf, \"BNAND\", 6)) {\n\t\t\t \n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tret = inftl_read_oob(mtd,\n\t\t\t\t     block * inftl->EraseSize + SECTORSIZE + 8,\n\t\t\t\t     8, &retlen,(char *)&h1);\n\t\tif (ret < 0) {\n\t\t\tprintk(KERN_WARNING \"INFTL: ANAND header found at \"\n\t\t\t\t\"0x%x in mtd%d, but OOB data read failed \"\n\t\t\t\t\"(err %d)\\n\", block * inftl->EraseSize,\n\t\t\t\tinftl->mbd.mtd->index, ret);\n\t\t\tcontinue;\n\t\t}\n\n\n\t\t \n\t\tmemcpy(mh, buf, sizeof(struct INFTLMediaHeader));\n\n\t\t \n\t\tmtd_read(mtd, block * inftl->EraseSize + 4096, SECTORSIZE,\n\t\t\t &retlen, buf);\n\t\tif (retlen != SECTORSIZE) {\n\t\t\tprintk(KERN_WARNING \"INFTL: Unable to read spare \"\n\t\t\t       \"Media Header\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\t \n\t\tif (memcmp(mh, buf, sizeof(struct INFTLMediaHeader))) {\n\t\t\tprintk(KERN_WARNING \"INFTL: Primary and spare Media \"\n\t\t\t       \"Headers disagree.\\n\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tmh->NoOfBootImageBlocks = le32_to_cpu(mh->NoOfBootImageBlocks);\n\t\tmh->NoOfBinaryPartitions = le32_to_cpu(mh->NoOfBinaryPartitions);\n\t\tmh->NoOfBDTLPartitions = le32_to_cpu(mh->NoOfBDTLPartitions);\n\t\tmh->BlockMultiplierBits = le32_to_cpu(mh->BlockMultiplierBits);\n\t\tmh->FormatFlags = le32_to_cpu(mh->FormatFlags);\n\t\tmh->PercentUsed = le32_to_cpu(mh->PercentUsed);\n\n\t\tpr_debug(\"INFTL: Media Header ->\\n\"\n\t\t\t \"    bootRecordID          = %s\\n\"\n\t\t\t \"    NoOfBootImageBlocks   = %d\\n\"\n\t\t\t \"    NoOfBinaryPartitions  = %d\\n\"\n\t\t\t \"    NoOfBDTLPartitions    = %d\\n\"\n\t\t\t \"    BlockMultiplierBits   = %d\\n\"\n\t\t\t \"    FormatFlgs            = %d\\n\"\n\t\t\t \"    OsakVersion           = 0x%x\\n\"\n\t\t\t \"    PercentUsed           = %d\\n\",\n\t\t\t mh->bootRecordID, mh->NoOfBootImageBlocks,\n\t\t\t mh->NoOfBinaryPartitions,\n\t\t\t mh->NoOfBDTLPartitions,\n\t\t\t mh->BlockMultiplierBits, mh->FormatFlags,\n\t\t\t mh->OsakVersion, mh->PercentUsed);\n\n\t\tif (mh->NoOfBDTLPartitions == 0) {\n\t\t\tprintk(KERN_WARNING \"INFTL: Media Header sanity check \"\n\t\t\t\t\"failed: NoOfBDTLPartitions (%d) == 0, \"\n\t\t\t\t\"must be at least 1\\n\", mh->NoOfBDTLPartitions);\n\t\t\treturn -1;\n\t\t}\n\n\t\tif ((mh->NoOfBDTLPartitions + mh->NoOfBinaryPartitions) > 4) {\n\t\t\tprintk(KERN_WARNING \"INFTL: Media Header sanity check \"\n\t\t\t\t\"failed: Total Partitions (%d) > 4, \"\n\t\t\t\t\"BDTL=%d Binary=%d\\n\", mh->NoOfBDTLPartitions +\n\t\t\t\tmh->NoOfBinaryPartitions,\n\t\t\t\tmh->NoOfBDTLPartitions,\n\t\t\t\tmh->NoOfBinaryPartitions);\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (mh->BlockMultiplierBits > 1) {\n\t\t\tprintk(KERN_WARNING \"INFTL: sorry, we don't support \"\n\t\t\t\t\"UnitSizeFactor 0x%02x\\n\",\n\t\t\t\tmh->BlockMultiplierBits);\n\t\t\treturn -1;\n\t\t} else if (mh->BlockMultiplierBits == 1) {\n\t\t\tprintk(KERN_WARNING \"INFTL: support for INFTL with \"\n\t\t\t\t\"UnitSizeFactor 0x%02x is experimental\\n\",\n\t\t\t\tmh->BlockMultiplierBits);\n\t\t\tinftl->EraseSize = inftl->mbd.mtd->erasesize <<\n\t\t\t\tmh->BlockMultiplierBits;\n\t\t\tinftl->nb_blocks = (u32)inftl->mbd.mtd->size / inftl->EraseSize;\n\t\t\tblock >>= mh->BlockMultiplierBits;\n\t\t}\n\n\t\t \n\t\tfor (i = 0; (i < 4); i++) {\n\t\t\tip = &mh->Partitions[i];\n\t\t\tip->virtualUnits = le32_to_cpu(ip->virtualUnits);\n\t\t\tip->firstUnit = le32_to_cpu(ip->firstUnit);\n\t\t\tip->lastUnit = le32_to_cpu(ip->lastUnit);\n\t\t\tip->flags = le32_to_cpu(ip->flags);\n\t\t\tip->spareUnits = le32_to_cpu(ip->spareUnits);\n\t\t\tip->Reserved0 = le32_to_cpu(ip->Reserved0);\n\n\t\t\tpr_debug(\"    PARTITION[%d] ->\\n\"\n\t\t\t\t \"        virtualUnits    = %d\\n\"\n\t\t\t\t \"        firstUnit       = %d\\n\"\n\t\t\t\t \"        lastUnit        = %d\\n\"\n\t\t\t\t \"        flags           = 0x%x\\n\"\n\t\t\t\t \"        spareUnits      = %d\\n\",\n\t\t\t\t i, ip->virtualUnits, ip->firstUnit,\n\t\t\t\t ip->lastUnit, ip->flags,\n\t\t\t\t ip->spareUnits);\n\n\t\t\tif (ip->Reserved0 != ip->firstUnit) {\n\t\t\t\tstruct erase_info *instr = &inftl->instr;\n\n\t\t\t\t \n\t\t\t\tinstr->addr = ip->Reserved0 * inftl->EraseSize;\n\t\t\t\tinstr->len = inftl->EraseSize;\n\t\t\t\tmtd_erase(mtd, instr);\n\t\t\t}\n\t\t\tif ((ip->lastUnit - ip->firstUnit + 1) < ip->virtualUnits) {\n\t\t\t\tprintk(KERN_WARNING \"INFTL: Media Header \"\n\t\t\t\t\t\"Partition %d sanity check failed\\n\"\n\t\t\t\t\t\"    firstUnit %d : lastUnit %d  >  \"\n\t\t\t\t\t\"virtualUnits %d\\n\", i, ip->lastUnit,\n\t\t\t\t\tip->firstUnit, ip->Reserved0);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (ip->Reserved1 != 0) {\n\t\t\t\tprintk(KERN_WARNING \"INFTL: Media Header \"\n\t\t\t\t\t\"Partition %d sanity check failed: \"\n\t\t\t\t\t\"Reserved1 %d != 0\\n\",\n\t\t\t\t\ti, ip->Reserved1);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tif (ip->flags & INFTL_BDTL)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (i >= 4) {\n\t\t\tprintk(KERN_WARNING \"INFTL: Media Header Partition \"\n\t\t\t\t\"sanity check failed:\\n       No partition \"\n\t\t\t\t\"marked as Disk Partition\\n\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tinftl->nb_boot_blocks = ip->firstUnit;\n\t\tinftl->numvunits = ip->virtualUnits;\n\t\tif (inftl->numvunits > (inftl->nb_blocks -\n\t\t    inftl->nb_boot_blocks - 2)) {\n\t\t\tprintk(KERN_WARNING \"INFTL: Media Header sanity check \"\n\t\t\t\t\"failed:\\n        numvunits (%d) > nb_blocks \"\n\t\t\t\t\"(%d) - nb_boot_blocks(%d) - 2\\n\",\n\t\t\t\tinftl->numvunits, inftl->nb_blocks,\n\t\t\t\tinftl->nb_boot_blocks);\n\t\t\treturn -1;\n\t\t}\n\n\t\tinftl->mbd.size  = inftl->numvunits *\n\t\t\t(inftl->EraseSize / SECTORSIZE);\n\n\t\t \n\t\tinftl->firstEUN = ip->firstUnit;\n\t\tinftl->lastEUN = ip->lastUnit;\n\t\tinftl->nb_blocks = ip->lastUnit + 1;\n\n\t\t \n\t\tinftl->PUtable = kmalloc_array(inftl->nb_blocks, sizeof(u16),\n\t\t\t\t\t       GFP_KERNEL);\n\t\tif (!inftl->PUtable)\n\t\t\treturn -ENOMEM;\n\n\t\tinftl->VUtable = kmalloc_array(inftl->nb_blocks, sizeof(u16),\n\t\t\t\t\t       GFP_KERNEL);\n\t\tif (!inftl->VUtable) {\n\t\t\tkfree(inftl->PUtable);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\t \n\t\tfor (i = 0; i < inftl->nb_boot_blocks; i++)\n\t\t\tinftl->PUtable[i] = BLOCK_RESERVED;\n\t\t \n\t\tfor (; i < inftl->nb_blocks; i++)\n\t\t\tinftl->PUtable[i] = BLOCK_NOTEXPLORED;\n\n\t\t \n\t\tinftl->PUtable[block] = BLOCK_RESERVED;\n\n\t\t \n\t\tfor (i = 0; i < inftl->nb_blocks; i++) {\n\t\t\tint physblock;\n\t\t\t \n\t\t\tfor (physblock = 0; physblock < inftl->EraseSize; physblock += inftl->mbd.mtd->erasesize) {\n\t\t\t\tif (mtd_block_isbad(inftl->mbd.mtd,\n\t\t\t\t\t\t    i * inftl->EraseSize + physblock))\n\t\t\t\t\tinftl->PUtable[i] = BLOCK_RESERVED;\n\t\t\t}\n\t\t}\n\n\t\tinftl->MediaUnit = block;\n\t\treturn 0;\n\t}\n\n\t \n\treturn -1;\n}\n\nstatic int memcmpb(void *a, int c, int n)\n{\n\tint i;\n\tfor (i = 0; i < n; i++) {\n\t\tif (c != ((unsigned char *)a)[i])\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n \nstatic int check_free_sectors(struct INFTLrecord *inftl, unsigned int address,\n\tint len, int check_oob)\n{\n\tstruct mtd_info *mtd = inftl->mbd.mtd;\n\tsize_t retlen;\n\tint i, ret;\n\tu8 *buf;\n\n\tbuf = kmalloc(SECTORSIZE + mtd->oobsize, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tret = -1;\n\tfor (i = 0; i < len; i += SECTORSIZE) {\n\t\tif (mtd_read(mtd, address, SECTORSIZE, &retlen, buf))\n\t\t\tgoto out;\n\t\tif (memcmpb(buf, 0xff, SECTORSIZE) != 0)\n\t\t\tgoto out;\n\n\t\tif (check_oob) {\n\t\t\tif(inftl_read_oob(mtd, address, mtd->oobsize,\n\t\t\t\t\t  &retlen, &buf[SECTORSIZE]) < 0)\n\t\t\t\tgoto out;\n\t\t\tif (memcmpb(buf + SECTORSIZE, 0xff, mtd->oobsize) != 0)\n\t\t\t\tgoto out;\n\t\t}\n\t\taddress += SECTORSIZE;\n\t}\n\n\tret = 0;\n\nout:\n\tkfree(buf);\n\treturn ret;\n}\n\n \nint INFTL_formatblock(struct INFTLrecord *inftl, int block)\n{\n\tsize_t retlen;\n\tstruct inftl_unittail uci;\n\tstruct erase_info *instr = &inftl->instr;\n\tstruct mtd_info *mtd = inftl->mbd.mtd;\n\tint physblock;\n\n\tpr_debug(\"INFTL: INFTL_formatblock(inftl=%p,block=%d)\\n\", inftl, block);\n\n\tmemset(instr, 0, sizeof(struct erase_info));\n\n\t \n\n\t \n\tinstr->addr = block * inftl->EraseSize;\n\tinstr->len = inftl->mbd.mtd->erasesize;\n\t \n\tfor (physblock = 0; physblock < inftl->EraseSize;\n\t     physblock += instr->len, instr->addr += instr->len) {\n\t\tint ret;\n\n\t\tret = mtd_erase(inftl->mbd.mtd, instr);\n\t\tif (ret) {\n\t\t\tprintk(KERN_WARNING \"INFTL: error while formatting block %d\\n\",\n\t\t\t\tblock);\n\t\t\tgoto fail;\n\t\t}\n\n\t\t \n\t\tif (check_free_sectors(inftl, instr->addr, instr->len, 1) != 0)\n\t\t\tgoto fail;\n\t}\n\n\tuci.EraseMark = cpu_to_le16(ERASE_MARK);\n\tuci.EraseMark1 = cpu_to_le16(ERASE_MARK);\n\tuci.Reserved[0] = 0;\n\tuci.Reserved[1] = 0;\n\tuci.Reserved[2] = 0;\n\tuci.Reserved[3] = 0;\n\tinstr->addr = block * inftl->EraseSize + SECTORSIZE * 2;\n\tif (inftl_write_oob(mtd, instr->addr + 8, 8, &retlen, (char *)&uci) < 0)\n\t\tgoto fail;\n\treturn 0;\nfail:\n\t \n\tmtd_block_markbad(inftl->mbd.mtd, instr->addr);\n\treturn -1;\n}\n\n \nstatic void format_chain(struct INFTLrecord *inftl, unsigned int first_block)\n{\n\tunsigned int block = first_block, block1;\n\n\tprintk(KERN_WARNING \"INFTL: formatting chain at block %d\\n\",\n\t\tfirst_block);\n\n\tfor (;;) {\n\t\tblock1 = inftl->PUtable[block];\n\n\t\tprintk(KERN_WARNING \"INFTL: formatting block %d\\n\", block);\n\t\tif (INFTL_formatblock(inftl, block) < 0) {\n\t\t\t \n\t\t\tinftl->PUtable[block] = BLOCK_RESERVED;\n\t\t} else {\n\t\t\tinftl->PUtable[block] = BLOCK_FREE;\n\t\t}\n\n\t\t \n\t\tblock = block1;\n\n\t\tif (block == BLOCK_NIL || block >= inftl->lastEUN)\n\t\t\tbreak;\n\t}\n}\n\nvoid INFTL_dumptables(struct INFTLrecord *s)\n{\n\tint i;\n\n\tpr_debug(\"-------------------------------------------\"\n\t\t\"----------------------------------\\n\");\n\n\tpr_debug(\"VUtable[%d] ->\", s->nb_blocks);\n\tfor (i = 0; i < s->nb_blocks; i++) {\n\t\tif ((i % 8) == 0)\n\t\t\tpr_debug(\"\\n%04x: \", i);\n\t\tpr_debug(\"%04x \", s->VUtable[i]);\n\t}\n\n\tpr_debug(\"\\n-------------------------------------------\"\n\t\t\"----------------------------------\\n\");\n\n\tpr_debug(\"PUtable[%d-%d=%d] ->\", s->firstEUN, s->lastEUN, s->nb_blocks);\n\tfor (i = 0; i <= s->lastEUN; i++) {\n\t\tif ((i % 8) == 0)\n\t\t\tpr_debug(\"\\n%04x: \", i);\n\t\tpr_debug(\"%04x \", s->PUtable[i]);\n\t}\n\n\tpr_debug(\"\\n-------------------------------------------\"\n\t\t\"----------------------------------\\n\");\n\n\tpr_debug(\"INFTL ->\\n\"\n\t\t\"  EraseSize       = %d\\n\"\n\t\t\"  h/s/c           = %d/%d/%d\\n\"\n\t\t\"  numvunits       = %d\\n\"\n\t\t\"  firstEUN        = %d\\n\"\n\t\t\"  lastEUN         = %d\\n\"\n\t\t\"  numfreeEUNs     = %d\\n\"\n\t\t\"  LastFreeEUN     = %d\\n\"\n\t\t\"  nb_blocks       = %d\\n\"\n\t\t\"  nb_boot_blocks  = %d\",\n\t\ts->EraseSize, s->heads, s->sectors, s->cylinders,\n\t\ts->numvunits, s->firstEUN, s->lastEUN, s->numfreeEUNs,\n\t\ts->LastFreeEUN, s->nb_blocks, s->nb_boot_blocks);\n\n\tpr_debug(\"\\n-------------------------------------------\"\n\t\t\"----------------------------------\\n\");\n}\n\nvoid INFTL_dumpVUchains(struct INFTLrecord *s)\n{\n\tint logical, block, i;\n\n\tpr_debug(\"-------------------------------------------\"\n\t\t\"----------------------------------\\n\");\n\n\tpr_debug(\"INFTL Virtual Unit Chains:\\n\");\n\tfor (logical = 0; logical < s->nb_blocks; logical++) {\n\t\tblock = s->VUtable[logical];\n\t\tif (block >= s->nb_blocks)\n\t\t\tcontinue;\n\t\tpr_debug(\"  LOGICAL %d --> %d \", logical, block);\n\t\tfor (i = 0; i < s->nb_blocks; i++) {\n\t\t\tif (s->PUtable[block] == BLOCK_NIL)\n\t\t\t\tbreak;\n\t\t\tblock = s->PUtable[block];\n\t\t\tpr_debug(\"%d \", block);\n\t\t}\n\t\tpr_debug(\"\\n\");\n\t}\n\n\tpr_debug(\"-------------------------------------------\"\n\t\t\"----------------------------------\\n\");\n}\n\nint INFTL_mount(struct INFTLrecord *s)\n{\n\tstruct mtd_info *mtd = s->mbd.mtd;\n\tunsigned int block, first_block, prev_block, last_block;\n\tunsigned int first_logical_block, logical_block, erase_mark;\n\tint chain_length, do_format_chain;\n\tstruct inftl_unithead1 h0;\n\tstruct inftl_unittail h1;\n\tsize_t retlen;\n\tint i;\n\tu8 *ANACtable, ANAC;\n\n\tpr_debug(\"INFTL: INFTL_mount(inftl=%p)\\n\", s);\n\n\t \n\tif (find_boot_record(s) < 0) {\n\t\tprintk(KERN_WARNING \"INFTL: could not find valid boot record?\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\t \n\tfor (i = 0; i < s->nb_blocks; i++)\n\t\ts->VUtable[i] = BLOCK_NIL;\n\n\tlogical_block = block = BLOCK_NIL;\n\n\t \n\tANACtable = kcalloc(s->nb_blocks, sizeof(u8), GFP_KERNEL);\n\tif (!ANACtable)\n\t\treturn -ENOMEM;\n\n\t \n\tpr_debug(\"INFTL: pass 1, explore each unit\\n\");\n\tfor (first_block = s->firstEUN; first_block <= s->lastEUN; first_block++) {\n\t\tif (s->PUtable[first_block] != BLOCK_NOTEXPLORED)\n\t\t\tcontinue;\n\n\t\tdo_format_chain = 0;\n\t\tfirst_logical_block = BLOCK_NIL;\n\t\tlast_block = BLOCK_NIL;\n\t\tblock = first_block;\n\n\t\tfor (chain_length = 0; ; chain_length++) {\n\n\t\t\tif ((chain_length == 0) &&\n\t\t\t    (s->PUtable[block] != BLOCK_NOTEXPLORED)) {\n\t\t\t\t \n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (inftl_read_oob(mtd, block * s->EraseSize + 8,\n\t\t\t\t\t   8, &retlen, (char *)&h0) < 0 ||\n\t\t\t    inftl_read_oob(mtd, block * s->EraseSize +\n\t\t\t\t\t   2 * SECTORSIZE + 8, 8, &retlen,\n\t\t\t\t\t   (char *)&h1) < 0) {\n\t\t\t\t \n\t\t\t\tdo_format_chain++;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tlogical_block = le16_to_cpu(h0.virtualUnitNo);\n\t\t\tprev_block = le16_to_cpu(h0.prevUnitNo);\n\t\t\terase_mark = le16_to_cpu((h1.EraseMark | h1.EraseMark1));\n\t\t\tANACtable[block] = h0.ANAC;\n\n\t\t\t \n\t\t\tif (prev_block < s->nb_blocks)\n\t\t\t\tprev_block += s->firstEUN;\n\n\t\t\t \n\t\t\tif (s->PUtable[block] != BLOCK_NOTEXPLORED) {\n\t\t\t\t \n\t\t\t\tif (logical_block == first_logical_block) {\n\t\t\t\t\tif (last_block != BLOCK_NIL)\n\t\t\t\t\t\ts->PUtable[last_block] = block;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (erase_mark != ERASE_MARK) {\n\t\t\t\tprintk(KERN_WARNING \"INFTL: corrupt block %d \"\n\t\t\t\t\t\"in chain %d, chain length %d, erase \"\n\t\t\t\t\t\"mark 0x%x?\\n\", block, first_block,\n\t\t\t\t\tchain_length, erase_mark);\n\t\t\t\t \n\t\t\t\tif (chain_length == 0)\n\t\t\t\t\tdo_format_chain++;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t \n\t\t\tif ((logical_block == BLOCK_FREE) ||\n\t\t\t    (logical_block == BLOCK_NIL)) {\n\t\t\t\ts->PUtable[block] = BLOCK_FREE;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t \n\t\t\tif ((logical_block >= s->nb_blocks) ||\n\t\t\t    ((prev_block >= s->nb_blocks) &&\n\t\t\t     (prev_block != BLOCK_NIL))) {\n\t\t\t\tif (chain_length > 0) {\n\t\t\t\t\tprintk(KERN_WARNING \"INFTL: corrupt \"\n\t\t\t\t\t\t\"block %d in chain %d?\\n\",\n\t\t\t\t\t\tblock, first_block);\n\t\t\t\t\tdo_format_chain++;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (first_logical_block == BLOCK_NIL) {\n\t\t\t\tfirst_logical_block = logical_block;\n\t\t\t} else {\n\t\t\t\tif (first_logical_block != logical_block) {\n\t\t\t\t\t \n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t \n\t\t\ts->PUtable[block] = BLOCK_NIL;\n\t\t\tif (last_block != BLOCK_NIL)\n\t\t\t\ts->PUtable[last_block] = block;\n\t\t\tlast_block = block;\n\t\t\tblock = prev_block;\n\n\t\t\t \n\t\t\tif (block == BLOCK_NIL)\n\t\t\t\tbreak;\n\n\t\t\t \n\t\t\tif (block > s->lastEUN) {\n\t\t\t\tprintk(KERN_WARNING \"INFTL: invalid previous \"\n\t\t\t\t\t\"block %d in chain %d?\\n\", block,\n\t\t\t\t\tfirst_block);\n\t\t\t\tdo_format_chain++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (do_format_chain) {\n\t\t\tformat_chain(s, first_block);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\ts->VUtable[first_logical_block] = first_block;\n\t\tlogical_block = BLOCK_NIL;\n\t}\n\n\tINFTL_dumptables(s);\n\n\t \n\tpr_debug(\"INFTL: pass 2, validate virtual chains\\n\");\n\tfor (logical_block = 0; logical_block < s->numvunits; logical_block++) {\n\t\tblock = s->VUtable[logical_block];\n\t\tlast_block = BLOCK_NIL;\n\n\t\t \n\t\tif (block >= BLOCK_RESERVED)\n\t\t\tcontinue;\n\n\t\tANAC = ANACtable[block];\n\t\tfor (i = 0; i < s->numvunits; i++) {\n\t\t\tif (s->PUtable[block] == BLOCK_NIL)\n\t\t\t\tbreak;\n\t\t\tif (s->PUtable[block] > s->lastEUN) {\n\t\t\t\tprintk(KERN_WARNING \"INFTL: invalid prev %d, \"\n\t\t\t\t\t\"in virtual chain %d\\n\",\n\t\t\t\t\ts->PUtable[block], logical_block);\n\t\t\t\ts->PUtable[block] = BLOCK_NIL;\n\n\t\t\t}\n\t\t\tif (ANACtable[block] != ANAC) {\n\t\t\t\t \n\t\t\t\ts->VUtable[logical_block] = block;\n\t\t\t\ts->PUtable[last_block] = BLOCK_NIL;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tANAC--;\n\t\t\tlast_block = block;\n\t\t\tblock = s->PUtable[block];\n\t\t}\n\n\t\tif (i >= s->nb_blocks) {\n\t\t\t \n\t\t\tformat_chain(s, first_block);\n\t\t}\n\t}\n\n\tINFTL_dumptables(s);\n\tINFTL_dumpVUchains(s);\n\n\t \n\ts->numfreeEUNs = 0;\n\ts->LastFreeEUN = BLOCK_NIL;\n\n\tpr_debug(\"INFTL: pass 3, format unused blocks\\n\");\n\tfor (block = s->firstEUN; block <= s->lastEUN; block++) {\n\t\tif (s->PUtable[block] == BLOCK_NOTEXPLORED) {\n\t\t\tprintk(\"INFTL: unreferenced block %d, formatting it\\n\",\n\t\t\t\tblock);\n\t\t\tif (INFTL_formatblock(s, block) < 0)\n\t\t\t\ts->PUtable[block] = BLOCK_RESERVED;\n\t\t\telse\n\t\t\t\ts->PUtable[block] = BLOCK_FREE;\n\t\t}\n\t\tif (s->PUtable[block] == BLOCK_FREE) {\n\t\t\ts->numfreeEUNs++;\n\t\t\tif (s->LastFreeEUN == BLOCK_NIL)\n\t\t\t\ts->LastFreeEUN = block;\n\t\t}\n\t}\n\n\tkfree(ANACtable);\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}