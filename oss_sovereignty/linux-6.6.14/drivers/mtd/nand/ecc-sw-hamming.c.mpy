{
  "module_name": "ecc-sw-hamming.c",
  "hash_id": "98545c9b9c7d10f1be5cb1475214c912caa1054ed05b3ad64c95fb9e4b7f235c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/nand/ecc-sw-hamming.c",
  "human_readable_source": "\n \n\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/mtd/nand.h>\n#include <linux/mtd/nand-ecc-sw-hamming.h>\n#include <linux/slab.h>\n#include <asm/byteorder.h>\n\n \nstatic const char invparity[256] = {\n\t1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1,\n\t0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0,\n\t0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0,\n\t1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1,\n\t0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0,\n\t1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1,\n\t1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1,\n\t0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0,\n\t0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0,\n\t1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1,\n\t1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1,\n\t0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0,\n\t1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1,\n\t0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0,\n\t0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0,\n\t1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1\n};\n\n \nstatic const char bitsperbyte[256] = {\n\t0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4,\n\t1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,\n\t1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,\n\t2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,\n\t1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,\n\t2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,\n\t2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,\n\t3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,\n\t1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,\n\t2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,\n\t2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,\n\t3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,\n\t2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,\n\t3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,\n\t3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,\n\t4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8,\n};\n\n \nstatic const char addressbits[256] = {\n\t0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x01, 0x01,\n\t0x02, 0x02, 0x03, 0x03, 0x02, 0x02, 0x03, 0x03,\n\t0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x01, 0x01,\n\t0x02, 0x02, 0x03, 0x03, 0x02, 0x02, 0x03, 0x03,\n\t0x04, 0x04, 0x05, 0x05, 0x04, 0x04, 0x05, 0x05,\n\t0x06, 0x06, 0x07, 0x07, 0x06, 0x06, 0x07, 0x07,\n\t0x04, 0x04, 0x05, 0x05, 0x04, 0x04, 0x05, 0x05,\n\t0x06, 0x06, 0x07, 0x07, 0x06, 0x06, 0x07, 0x07,\n\t0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x01, 0x01,\n\t0x02, 0x02, 0x03, 0x03, 0x02, 0x02, 0x03, 0x03,\n\t0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x01, 0x01,\n\t0x02, 0x02, 0x03, 0x03, 0x02, 0x02, 0x03, 0x03,\n\t0x04, 0x04, 0x05, 0x05, 0x04, 0x04, 0x05, 0x05,\n\t0x06, 0x06, 0x07, 0x07, 0x06, 0x06, 0x07, 0x07,\n\t0x04, 0x04, 0x05, 0x05, 0x04, 0x04, 0x05, 0x05,\n\t0x06, 0x06, 0x07, 0x07, 0x06, 0x06, 0x07, 0x07,\n\t0x08, 0x08, 0x09, 0x09, 0x08, 0x08, 0x09, 0x09,\n\t0x0a, 0x0a, 0x0b, 0x0b, 0x0a, 0x0a, 0x0b, 0x0b,\n\t0x08, 0x08, 0x09, 0x09, 0x08, 0x08, 0x09, 0x09,\n\t0x0a, 0x0a, 0x0b, 0x0b, 0x0a, 0x0a, 0x0b, 0x0b,\n\t0x0c, 0x0c, 0x0d, 0x0d, 0x0c, 0x0c, 0x0d, 0x0d,\n\t0x0e, 0x0e, 0x0f, 0x0f, 0x0e, 0x0e, 0x0f, 0x0f,\n\t0x0c, 0x0c, 0x0d, 0x0d, 0x0c, 0x0c, 0x0d, 0x0d,\n\t0x0e, 0x0e, 0x0f, 0x0f, 0x0e, 0x0e, 0x0f, 0x0f,\n\t0x08, 0x08, 0x09, 0x09, 0x08, 0x08, 0x09, 0x09,\n\t0x0a, 0x0a, 0x0b, 0x0b, 0x0a, 0x0a, 0x0b, 0x0b,\n\t0x08, 0x08, 0x09, 0x09, 0x08, 0x08, 0x09, 0x09,\n\t0x0a, 0x0a, 0x0b, 0x0b, 0x0a, 0x0a, 0x0b, 0x0b,\n\t0x0c, 0x0c, 0x0d, 0x0d, 0x0c, 0x0c, 0x0d, 0x0d,\n\t0x0e, 0x0e, 0x0f, 0x0f, 0x0e, 0x0e, 0x0f, 0x0f,\n\t0x0c, 0x0c, 0x0d, 0x0d, 0x0c, 0x0c, 0x0d, 0x0d,\n\t0x0e, 0x0e, 0x0f, 0x0f, 0x0e, 0x0e, 0x0f, 0x0f\n};\n\nint ecc_sw_hamming_calculate(const unsigned char *buf, unsigned int step_size,\n\t\t\t     unsigned char *code, bool sm_order)\n{\n\tconst u32 *bp = (uint32_t *)buf;\n\tconst u32 eccsize_mult = (step_size == 256) ? 1 : 2;\n\t \n\tu32 cur;\n\t \n\tu32 rp0, rp1, rp2, rp3, rp4, rp5, rp6, rp7, rp8, rp9, rp10, rp11, rp12,\n\t\trp13, rp14, rp15, rp16, rp17;\n\t \n\tu32 par;\n\t \n\tu32 tmppar;\n\tint i;\n\n\tpar = 0;\n\trp4 = 0;\n\trp6 = 0;\n\trp8 = 0;\n\trp10 = 0;\n\trp12 = 0;\n\trp14 = 0;\n\trp16 = 0;\n\trp17 = 0;\n\n\t \n\tfor (i = 0; i < eccsize_mult << 2; i++) {\n\t\tcur = *bp++;\n\t\ttmppar = cur;\n\t\trp4 ^= cur;\n\t\tcur = *bp++;\n\t\ttmppar ^= cur;\n\t\trp6 ^= tmppar;\n\t\tcur = *bp++;\n\t\ttmppar ^= cur;\n\t\trp4 ^= cur;\n\t\tcur = *bp++;\n\t\ttmppar ^= cur;\n\t\trp8 ^= tmppar;\n\n\t\tcur = *bp++;\n\t\ttmppar ^= cur;\n\t\trp4 ^= cur;\n\t\trp6 ^= cur;\n\t\tcur = *bp++;\n\t\ttmppar ^= cur;\n\t\trp6 ^= cur;\n\t\tcur = *bp++;\n\t\ttmppar ^= cur;\n\t\trp4 ^= cur;\n\t\tcur = *bp++;\n\t\ttmppar ^= cur;\n\t\trp10 ^= tmppar;\n\n\t\tcur = *bp++;\n\t\ttmppar ^= cur;\n\t\trp4 ^= cur;\n\t\trp6 ^= cur;\n\t\trp8 ^= cur;\n\t\tcur = *bp++;\n\t\ttmppar ^= cur;\n\t\trp6 ^= cur;\n\t\trp8 ^= cur;\n\t\tcur = *bp++;\n\t\ttmppar ^= cur;\n\t\trp4 ^= cur;\n\t\trp8 ^= cur;\n\t\tcur = *bp++;\n\t\ttmppar ^= cur;\n\t\trp8 ^= cur;\n\n\t\tcur = *bp++;\n\t\ttmppar ^= cur;\n\t\trp4 ^= cur;\n\t\trp6 ^= cur;\n\t\tcur = *bp++;\n\t\ttmppar ^= cur;\n\t\trp6 ^= cur;\n\t\tcur = *bp++;\n\t\ttmppar ^= cur;\n\t\trp4 ^= cur;\n\t\tcur = *bp++;\n\t\ttmppar ^= cur;\n\n\t\tpar ^= tmppar;\n\t\tif ((i & 0x1) == 0)\n\t\t\trp12 ^= tmppar;\n\t\tif ((i & 0x2) == 0)\n\t\t\trp14 ^= tmppar;\n\t\tif (eccsize_mult == 2 && (i & 0x4) == 0)\n\t\t\trp16 ^= tmppar;\n\t}\n\n\t \n\trp4 ^= (rp4 >> 16);\n\trp4 ^= (rp4 >> 8);\n\trp4 &= 0xff;\n\trp6 ^= (rp6 >> 16);\n\trp6 ^= (rp6 >> 8);\n\trp6 &= 0xff;\n\trp8 ^= (rp8 >> 16);\n\trp8 ^= (rp8 >> 8);\n\trp8 &= 0xff;\n\trp10 ^= (rp10 >> 16);\n\trp10 ^= (rp10 >> 8);\n\trp10 &= 0xff;\n\trp12 ^= (rp12 >> 16);\n\trp12 ^= (rp12 >> 8);\n\trp12 &= 0xff;\n\trp14 ^= (rp14 >> 16);\n\trp14 ^= (rp14 >> 8);\n\trp14 &= 0xff;\n\tif (eccsize_mult == 2) {\n\t\trp16 ^= (rp16 >> 16);\n\t\trp16 ^= (rp16 >> 8);\n\t\trp16 &= 0xff;\n\t}\n\n\t \n#ifdef __BIG_ENDIAN\n\trp2 = (par >> 16);\n\trp2 ^= (rp2 >> 8);\n\trp2 &= 0xff;\n\trp3 = par & 0xffff;\n\trp3 ^= (rp3 >> 8);\n\trp3 &= 0xff;\n#else\n\trp3 = (par >> 16);\n\trp3 ^= (rp3 >> 8);\n\trp3 &= 0xff;\n\trp2 = par & 0xffff;\n\trp2 ^= (rp2 >> 8);\n\trp2 &= 0xff;\n#endif\n\n\t \n\tpar ^= (par >> 16);\n#ifdef __BIG_ENDIAN\n\trp0 = (par >> 8) & 0xff;\n\trp1 = (par & 0xff);\n#else\n\trp1 = (par >> 8) & 0xff;\n\trp0 = (par & 0xff);\n#endif\n\n\t \n\tpar ^= (par >> 8);\n\tpar &= 0xff;\n\n\t \n\trp5 = (par ^ rp4) & 0xff;\n\trp7 = (par ^ rp6) & 0xff;\n\trp9 = (par ^ rp8) & 0xff;\n\trp11 = (par ^ rp10) & 0xff;\n\trp13 = (par ^ rp12) & 0xff;\n\trp15 = (par ^ rp14) & 0xff;\n\tif (eccsize_mult == 2)\n\t\trp17 = (par ^ rp16) & 0xff;\n\n\t \n\tif (sm_order) {\n\t\tcode[0] = (invparity[rp7] << 7) | (invparity[rp6] << 6) |\n\t\t\t  (invparity[rp5] << 5) | (invparity[rp4] << 4) |\n\t\t\t  (invparity[rp3] << 3) | (invparity[rp2] << 2) |\n\t\t\t  (invparity[rp1] << 1) | (invparity[rp0]);\n\t\tcode[1] = (invparity[rp15] << 7) | (invparity[rp14] << 6) |\n\t\t\t  (invparity[rp13] << 5) | (invparity[rp12] << 4) |\n\t\t\t  (invparity[rp11] << 3) | (invparity[rp10] << 2) |\n\t\t\t  (invparity[rp9] << 1) | (invparity[rp8]);\n\t} else {\n\t\tcode[1] = (invparity[rp7] << 7) | (invparity[rp6] << 6) |\n\t\t\t  (invparity[rp5] << 5) | (invparity[rp4] << 4) |\n\t\t\t  (invparity[rp3] << 3) | (invparity[rp2] << 2) |\n\t\t\t  (invparity[rp1] << 1) | (invparity[rp0]);\n\t\tcode[0] = (invparity[rp15] << 7) | (invparity[rp14] << 6) |\n\t\t\t  (invparity[rp13] << 5) | (invparity[rp12] << 4) |\n\t\t\t  (invparity[rp11] << 3) | (invparity[rp10] << 2) |\n\t\t\t  (invparity[rp9] << 1) | (invparity[rp8]);\n\t}\n\n\tif (eccsize_mult == 1)\n\t\tcode[2] =\n\t\t    (invparity[par & 0xf0] << 7) |\n\t\t    (invparity[par & 0x0f] << 6) |\n\t\t    (invparity[par & 0xcc] << 5) |\n\t\t    (invparity[par & 0x33] << 4) |\n\t\t    (invparity[par & 0xaa] << 3) |\n\t\t    (invparity[par & 0x55] << 2) |\n\t\t    3;\n\telse\n\t\tcode[2] =\n\t\t    (invparity[par & 0xf0] << 7) |\n\t\t    (invparity[par & 0x0f] << 6) |\n\t\t    (invparity[par & 0xcc] << 5) |\n\t\t    (invparity[par & 0x33] << 4) |\n\t\t    (invparity[par & 0xaa] << 3) |\n\t\t    (invparity[par & 0x55] << 2) |\n\t\t    (invparity[rp17] << 1) |\n\t\t    (invparity[rp16] << 0);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(ecc_sw_hamming_calculate);\n\n \nint nand_ecc_sw_hamming_calculate(struct nand_device *nand,\n\t\t\t\t  const unsigned char *buf, unsigned char *code)\n{\n\tstruct nand_ecc_sw_hamming_conf *engine_conf = nand->ecc.ctx.priv;\n\tunsigned int step_size = nand->ecc.ctx.conf.step_size;\n\tbool sm_order = engine_conf ? engine_conf->sm_order : false;\n\n\treturn ecc_sw_hamming_calculate(buf, step_size, code, sm_order);\n}\nEXPORT_SYMBOL(nand_ecc_sw_hamming_calculate);\n\nint ecc_sw_hamming_correct(unsigned char *buf, unsigned char *read_ecc,\n\t\t\t   unsigned char *calc_ecc, unsigned int step_size,\n\t\t\t   bool sm_order)\n{\n\tconst u32 eccsize_mult = step_size >> 8;\n\tunsigned char b0, b1, b2, bit_addr;\n\tunsigned int byte_addr;\n\n\t \n\tif (sm_order) {\n\t\tb0 = read_ecc[0] ^ calc_ecc[0];\n\t\tb1 = read_ecc[1] ^ calc_ecc[1];\n\t} else {\n\t\tb0 = read_ecc[1] ^ calc_ecc[1];\n\t\tb1 = read_ecc[0] ^ calc_ecc[0];\n\t}\n\n\tb2 = read_ecc[2] ^ calc_ecc[2];\n\n\t \n\n\t \n\t \n\n\tif ((b0 | b1 | b2) == 0)\n\t\treturn 0;\t \n\n\tif ((((b0 ^ (b0 >> 1)) & 0x55) == 0x55) &&\n\t    (((b1 ^ (b1 >> 1)) & 0x55) == 0x55) &&\n\t    ((eccsize_mult == 1 && ((b2 ^ (b2 >> 1)) & 0x54) == 0x54) ||\n\t     (eccsize_mult == 2 && ((b2 ^ (b2 >> 1)) & 0x55) == 0x55))) {\n\t \n\t\t \n\t\tif (eccsize_mult == 1)\n\t\t\tbyte_addr = (addressbits[b1] << 4) + addressbits[b0];\n\t\telse\n\t\t\tbyte_addr = (addressbits[b2 & 0x3] << 8) +\n\t\t\t\t    (addressbits[b1] << 4) + addressbits[b0];\n\t\tbit_addr = addressbits[b2 >> 2];\n\t\t \n\t\tbuf[byte_addr] ^= (1 << bit_addr);\n\t\treturn 1;\n\n\t}\n\t \n\tif ((bitsperbyte[b0] + bitsperbyte[b1] + bitsperbyte[b2]) == 1)\n\t\treturn 1;\t \n\n\tpr_err(\"%s: uncorrectable ECC error\\n\", __func__);\n\treturn -EBADMSG;\n}\nEXPORT_SYMBOL(ecc_sw_hamming_correct);\n\n \nint nand_ecc_sw_hamming_correct(struct nand_device *nand, unsigned char *buf,\n\t\t\t\tunsigned char *read_ecc,\n\t\t\t\tunsigned char *calc_ecc)\n{\n\tstruct nand_ecc_sw_hamming_conf *engine_conf = nand->ecc.ctx.priv;\n\tunsigned int step_size = nand->ecc.ctx.conf.step_size;\n\tbool sm_order = engine_conf ? engine_conf->sm_order : false;\n\n\treturn ecc_sw_hamming_correct(buf, read_ecc, calc_ecc, step_size,\n\t\t\t\t      sm_order);\n}\nEXPORT_SYMBOL(nand_ecc_sw_hamming_correct);\n\nint nand_ecc_sw_hamming_init_ctx(struct nand_device *nand)\n{\n\tstruct nand_ecc_props *conf = &nand->ecc.ctx.conf;\n\tstruct nand_ecc_sw_hamming_conf *engine_conf;\n\tstruct mtd_info *mtd = nanddev_to_mtd(nand);\n\tint ret;\n\n\tif (!mtd->ooblayout) {\n\t\tswitch (mtd->oobsize) {\n\t\tcase 8:\n\t\tcase 16:\n\t\t\tmtd_set_ooblayout(mtd, nand_get_small_page_ooblayout());\n\t\t\tbreak;\n\t\tcase 64:\n\t\tcase 128:\n\t\t\tmtd_set_ooblayout(mtd,\n\t\t\t\t\t  nand_get_large_page_hamming_ooblayout());\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -ENOTSUPP;\n\t\t}\n\t}\n\n\tconf->engine_type = NAND_ECC_ENGINE_TYPE_SOFT;\n\tconf->algo = NAND_ECC_ALGO_HAMMING;\n\tconf->step_size = nand->ecc.user_conf.step_size;\n\tconf->strength = 1;\n\n\t \n\tif (conf->step_size != 256 && conf->step_size != 512)\n\t\tconf->step_size = 256;\n\n\tengine_conf = kzalloc(sizeof(*engine_conf), GFP_KERNEL);\n\tif (!engine_conf)\n\t\treturn -ENOMEM;\n\n\tret = nand_ecc_init_req_tweaking(&engine_conf->req_ctx, nand);\n\tif (ret)\n\t\tgoto free_engine_conf;\n\n\tengine_conf->code_size = 3;\n\tengine_conf->calc_buf = kzalloc(mtd->oobsize, GFP_KERNEL);\n\tengine_conf->code_buf = kzalloc(mtd->oobsize, GFP_KERNEL);\n\tif (!engine_conf->calc_buf || !engine_conf->code_buf) {\n\t\tret = -ENOMEM;\n\t\tgoto free_bufs;\n\t}\n\n\tnand->ecc.ctx.priv = engine_conf;\n\tnand->ecc.ctx.nsteps = mtd->writesize / conf->step_size;\n\tnand->ecc.ctx.total = nand->ecc.ctx.nsteps * engine_conf->code_size;\n\n\treturn 0;\n\nfree_bufs:\n\tnand_ecc_cleanup_req_tweaking(&engine_conf->req_ctx);\n\tkfree(engine_conf->calc_buf);\n\tkfree(engine_conf->code_buf);\nfree_engine_conf:\n\tkfree(engine_conf);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(nand_ecc_sw_hamming_init_ctx);\n\nvoid nand_ecc_sw_hamming_cleanup_ctx(struct nand_device *nand)\n{\n\tstruct nand_ecc_sw_hamming_conf *engine_conf = nand->ecc.ctx.priv;\n\n\tif (engine_conf) {\n\t\tnand_ecc_cleanup_req_tweaking(&engine_conf->req_ctx);\n\t\tkfree(engine_conf->calc_buf);\n\t\tkfree(engine_conf->code_buf);\n\t\tkfree(engine_conf);\n\t}\n}\nEXPORT_SYMBOL(nand_ecc_sw_hamming_cleanup_ctx);\n\nstatic int nand_ecc_sw_hamming_prepare_io_req(struct nand_device *nand,\n\t\t\t\t\t      struct nand_page_io_req *req)\n{\n\tstruct nand_ecc_sw_hamming_conf *engine_conf = nand->ecc.ctx.priv;\n\tstruct mtd_info *mtd = nanddev_to_mtd(nand);\n\tint eccsize = nand->ecc.ctx.conf.step_size;\n\tint eccbytes = engine_conf->code_size;\n\tint eccsteps = nand->ecc.ctx.nsteps;\n\tint total = nand->ecc.ctx.total;\n\tu8 *ecccalc = engine_conf->calc_buf;\n\tconst u8 *data;\n\tint i;\n\n\t \n\tif (req->mode == MTD_OPS_RAW)\n\t\treturn 0;\n\n\t \n\tif (!req->datalen)\n\t\treturn 0;\n\n\tnand_ecc_tweak_req(&engine_conf->req_ctx, req);\n\n\t \n\tif (req->type == NAND_PAGE_READ)\n\t\treturn 0;\n\n\t \n\tfor (i = 0, data = req->databuf.out;\n\t     eccsteps;\n\t     eccsteps--, i += eccbytes, data += eccsize)\n\t\tnand_ecc_sw_hamming_calculate(nand, data, &ecccalc[i]);\n\n\treturn mtd_ooblayout_set_eccbytes(mtd, ecccalc, (void *)req->oobbuf.out,\n\t\t\t\t\t  0, total);\n}\n\nstatic int nand_ecc_sw_hamming_finish_io_req(struct nand_device *nand,\n\t\t\t\t\t     struct nand_page_io_req *req)\n{\n\tstruct nand_ecc_sw_hamming_conf *engine_conf = nand->ecc.ctx.priv;\n\tstruct mtd_info *mtd = nanddev_to_mtd(nand);\n\tint eccsize = nand->ecc.ctx.conf.step_size;\n\tint total = nand->ecc.ctx.total;\n\tint eccbytes = engine_conf->code_size;\n\tint eccsteps = nand->ecc.ctx.nsteps;\n\tu8 *ecccalc = engine_conf->calc_buf;\n\tu8 *ecccode = engine_conf->code_buf;\n\tunsigned int max_bitflips = 0;\n\tu8 *data = req->databuf.in;\n\tint i, ret;\n\n\t \n\tif (req->mode == MTD_OPS_RAW)\n\t\treturn 0;\n\n\t \n\tif (!req->datalen)\n\t\treturn 0;\n\n\t \n\tif (req->type == NAND_PAGE_WRITE) {\n\t\tnand_ecc_restore_req(&engine_conf->req_ctx, req);\n\t\treturn 0;\n\t}\n\n\t \n\tret = mtd_ooblayout_get_eccbytes(mtd, ecccode, req->oobbuf.in, 0,\n\t\t\t\t\t total);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tfor (i = 0; eccsteps; eccsteps--, i += eccbytes, data += eccsize)\n\t\tnand_ecc_sw_hamming_calculate(nand, data, &ecccalc[i]);\n\n\t \n\tfor (eccsteps = nand->ecc.ctx.nsteps, i = 0, data = req->databuf.in;\n\t     eccsteps;\n\t     eccsteps--, i += eccbytes, data += eccsize) {\n\t\tint stat =  nand_ecc_sw_hamming_correct(nand, data,\n\t\t\t\t\t\t\t&ecccode[i],\n\t\t\t\t\t\t\t&ecccalc[i]);\n\t\tif (stat < 0) {\n\t\t\tmtd->ecc_stats.failed++;\n\t\t} else {\n\t\t\tmtd->ecc_stats.corrected += stat;\n\t\t\tmax_bitflips = max_t(unsigned int, max_bitflips, stat);\n\t\t}\n\t}\n\n\tnand_ecc_restore_req(&engine_conf->req_ctx, req);\n\n\treturn max_bitflips;\n}\n\nstatic struct nand_ecc_engine_ops nand_ecc_sw_hamming_engine_ops = {\n\t.init_ctx = nand_ecc_sw_hamming_init_ctx,\n\t.cleanup_ctx = nand_ecc_sw_hamming_cleanup_ctx,\n\t.prepare_io_req = nand_ecc_sw_hamming_prepare_io_req,\n\t.finish_io_req = nand_ecc_sw_hamming_finish_io_req,\n};\n\nstatic struct nand_ecc_engine nand_ecc_sw_hamming_engine = {\n\t.ops = &nand_ecc_sw_hamming_engine_ops,\n};\n\nstruct nand_ecc_engine *nand_ecc_sw_hamming_get_engine(void)\n{\n\treturn &nand_ecc_sw_hamming_engine;\n}\nEXPORT_SYMBOL(nand_ecc_sw_hamming_get_engine);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Frans Meulenbroeks <fransmeulenbroeks@gmail.com>\");\nMODULE_DESCRIPTION(\"NAND software Hamming ECC support\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}