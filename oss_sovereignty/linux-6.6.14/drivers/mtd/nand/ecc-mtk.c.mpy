{
  "module_name": "ecc-mtk.c",
  "hash_id": "c52b815f73041db97bcfb8a9ae2dbba9c7ac2b2c8d24bb5c992aa6f63c031554",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/nand/ecc-mtk.c",
  "human_readable_source": "\n \n\n#include <linux/platform_device.h>\n#include <linux/dma-mapping.h>\n#include <linux/interrupt.h>\n#include <linux/clk.h>\n#include <linux/module.h>\n#include <linux/iopoll.h>\n#include <linux/of.h>\n#include <linux/of_platform.h>\n#include <linux/mutex.h>\n#include <linux/mtd/nand-ecc-mtk.h>\n\n#define ECC_IDLE_MASK\t\tBIT(0)\n#define ECC_IRQ_EN\t\tBIT(0)\n#define ECC_PG_IRQ_SEL\t\tBIT(1)\n#define ECC_OP_ENABLE\t\t(1)\n#define ECC_OP_DISABLE\t\t(0)\n\n#define ECC_ENCCON\t\t(0x00)\n#define ECC_ENCCNFG\t\t(0x04)\n#define\t\tECC_MS_SHIFT\t\t(16)\n#define ECC_ENCDIADDR\t\t(0x08)\n#define ECC_ENCIDLE\t\t(0x0C)\n#define ECC_DECCON\t\t(0x100)\n#define ECC_DECCNFG\t\t(0x104)\n#define\t\tDEC_EMPTY_EN\t\tBIT(31)\n#define\t\tDEC_CNFG_CORRECT\t(0x3 << 12)\n#define ECC_DECIDLE\t\t(0x10C)\n#define ECC_DECENUM0\t\t(0x114)\n\n#define ECC_TIMEOUT\t\t(500000)\n\n#define ECC_IDLE_REG(op)\t((op) == ECC_ENCODE ? ECC_ENCIDLE : ECC_DECIDLE)\n#define ECC_CTL_REG(op)\t\t((op) == ECC_ENCODE ? ECC_ENCCON : ECC_DECCON)\n\n#define ECC_ERRMASK_MT7622\tGENMASK(4, 0)\n#define ECC_ERRMASK_MT2701\tGENMASK(5, 0)\n#define ECC_ERRMASK_MT2712\tGENMASK(6, 0)\n\nstruct mtk_ecc_caps {\n\tu32 err_mask;\n\tu32 err_shift;\n\tconst u8 *ecc_strength;\n\tconst u32 *ecc_regs;\n\tu8 num_ecc_strength;\n\tu8 ecc_mode_shift;\n\tu32 parity_bits;\n\tint pg_irq_sel;\n};\n\nstruct mtk_ecc {\n\tstruct device *dev;\n\tconst struct mtk_ecc_caps *caps;\n\tvoid __iomem *regs;\n\tstruct clk *clk;\n\n\tstruct completion done;\n\tstruct mutex lock;\n\tu32 sectors;\n\n\tu8 *eccdata;\n};\n\n \nstatic const u8 ecc_strength_mt2701[] = {\n\t4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 28, 32, 36,\n\t40, 44, 48, 52, 56, 60\n};\n\nstatic const u8 ecc_strength_mt2712[] = {\n\t4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 28, 32, 36,\n\t40, 44, 48, 52, 56, 60, 68, 72, 80\n};\n\nstatic const u8 ecc_strength_mt7622[] = {\n\t4, 6, 8, 10, 12\n};\n\nstatic const u8 ecc_strength_mt7986[] = {\n\t4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24\n};\n\nenum mtk_ecc_regs {\n\tECC_ENCPAR00,\n\tECC_ENCIRQ_EN,\n\tECC_ENCIRQ_STA,\n\tECC_DECDONE,\n\tECC_DECIRQ_EN,\n\tECC_DECIRQ_STA,\n};\n\nstatic int mt2701_ecc_regs[] = {\n\t[ECC_ENCPAR00] =        0x10,\n\t[ECC_ENCIRQ_EN] =       0x80,\n\t[ECC_ENCIRQ_STA] =      0x84,\n\t[ECC_DECDONE] =         0x124,\n\t[ECC_DECIRQ_EN] =       0x200,\n\t[ECC_DECIRQ_STA] =      0x204,\n};\n\nstatic int mt2712_ecc_regs[] = {\n\t[ECC_ENCPAR00] =        0x300,\n\t[ECC_ENCIRQ_EN] =       0x80,\n\t[ECC_ENCIRQ_STA] =      0x84,\n\t[ECC_DECDONE] =         0x124,\n\t[ECC_DECIRQ_EN] =       0x200,\n\t[ECC_DECIRQ_STA] =      0x204,\n};\n\nstatic int mt7622_ecc_regs[] = {\n\t[ECC_ENCPAR00] =        0x10,\n\t[ECC_ENCIRQ_EN] =       0x30,\n\t[ECC_ENCIRQ_STA] =      0x34,\n\t[ECC_DECDONE] =         0x11c,\n\t[ECC_DECIRQ_EN] =       0x140,\n\t[ECC_DECIRQ_STA] =      0x144,\n};\n\nstatic inline void mtk_ecc_wait_idle(struct mtk_ecc *ecc,\n\t\t\t\t     enum mtk_ecc_operation op)\n{\n\tstruct device *dev = ecc->dev;\n\tu32 val;\n\tint ret;\n\n\tret = readl_poll_timeout_atomic(ecc->regs + ECC_IDLE_REG(op), val,\n\t\t\t\t\tval & ECC_IDLE_MASK,\n\t\t\t\t\t10, ECC_TIMEOUT);\n\tif (ret)\n\t\tdev_warn(dev, \"%s NOT idle\\n\",\n\t\t\t op == ECC_ENCODE ? \"encoder\" : \"decoder\");\n}\n\nstatic irqreturn_t mtk_ecc_irq(int irq, void *id)\n{\n\tstruct mtk_ecc *ecc = id;\n\tu32 dec, enc;\n\n\tdec = readw(ecc->regs + ecc->caps->ecc_regs[ECC_DECIRQ_STA])\n\t\t    & ECC_IRQ_EN;\n\tif (dec) {\n\t\tdec = readw(ecc->regs + ecc->caps->ecc_regs[ECC_DECDONE]);\n\t\tif (dec & ecc->sectors) {\n\t\t\t \n\t\t\treadw(ecc->regs + ecc->caps->ecc_regs[ECC_DECIRQ_STA]);\n\t\t\tecc->sectors = 0;\n\t\t\tcomplete(&ecc->done);\n\t\t} else {\n\t\t\treturn IRQ_HANDLED;\n\t\t}\n\t} else {\n\t\tenc = readl(ecc->regs + ecc->caps->ecc_regs[ECC_ENCIRQ_STA])\n\t\t      & ECC_IRQ_EN;\n\t\tif (enc)\n\t\t\tcomplete(&ecc->done);\n\t\telse\n\t\t\treturn IRQ_NONE;\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int mtk_ecc_config(struct mtk_ecc *ecc, struct mtk_ecc_config *config)\n{\n\tu32 ecc_bit, dec_sz, enc_sz;\n\tu32 reg, i;\n\n\tfor (i = 0; i < ecc->caps->num_ecc_strength; i++) {\n\t\tif (ecc->caps->ecc_strength[i] == config->strength)\n\t\t\tbreak;\n\t}\n\n\tif (i == ecc->caps->num_ecc_strength) {\n\t\tdev_err(ecc->dev, \"invalid ecc strength %d\\n\",\n\t\t\tconfig->strength);\n\t\treturn -EINVAL;\n\t}\n\n\tecc_bit = i;\n\n\tif (config->op == ECC_ENCODE) {\n\t\t \n\t\tenc_sz = config->len << 3;\n\n\t\treg = ecc_bit | (config->mode << ecc->caps->ecc_mode_shift);\n\t\treg |= (enc_sz << ECC_MS_SHIFT);\n\t\twritel(reg, ecc->regs + ECC_ENCCNFG);\n\n\t\tif (config->mode != ECC_NFI_MODE)\n\t\t\twritel(lower_32_bits(config->addr),\n\t\t\t       ecc->regs + ECC_ENCDIADDR);\n\n\t} else {\n\t\t \n\t\tdec_sz = (config->len << 3) +\n\t\t\t config->strength * ecc->caps->parity_bits;\n\n\t\treg = ecc_bit | (config->mode << ecc->caps->ecc_mode_shift);\n\t\treg |= (dec_sz << ECC_MS_SHIFT) | DEC_CNFG_CORRECT;\n\t\treg |= DEC_EMPTY_EN;\n\t\twritel(reg, ecc->regs + ECC_DECCNFG);\n\n\t\tif (config->sectors)\n\t\t\tecc->sectors = 1 << (config->sectors - 1);\n\t}\n\n\treturn 0;\n}\n\nvoid mtk_ecc_get_stats(struct mtk_ecc *ecc, struct mtk_ecc_stats *stats,\n\t\t       int sectors)\n{\n\tu32 offset, i, err;\n\tu32 bitflips = 0;\n\n\tstats->corrected = 0;\n\tstats->failed = 0;\n\n\tfor (i = 0; i < sectors; i++) {\n\t\toffset = (i >> 2) << 2;\n\t\terr = readl(ecc->regs + ECC_DECENUM0 + offset);\n\t\terr = err >> ((i % 4) * ecc->caps->err_shift);\n\t\terr &= ecc->caps->err_mask;\n\t\tif (err == ecc->caps->err_mask) {\n\t\t\t \n\t\t\tstats->failed++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tstats->corrected += err;\n\t\tbitflips = max_t(u32, bitflips, err);\n\t}\n\n\tstats->bitflips = bitflips;\n}\nEXPORT_SYMBOL(mtk_ecc_get_stats);\n\nvoid mtk_ecc_release(struct mtk_ecc *ecc)\n{\n\tclk_disable_unprepare(ecc->clk);\n\tput_device(ecc->dev);\n}\nEXPORT_SYMBOL(mtk_ecc_release);\n\nstatic void mtk_ecc_hw_init(struct mtk_ecc *ecc)\n{\n\tmtk_ecc_wait_idle(ecc, ECC_ENCODE);\n\twritew(ECC_OP_DISABLE, ecc->regs + ECC_ENCCON);\n\n\tmtk_ecc_wait_idle(ecc, ECC_DECODE);\n\twritel(ECC_OP_DISABLE, ecc->regs + ECC_DECCON);\n}\n\nstatic struct mtk_ecc *mtk_ecc_get(struct device_node *np)\n{\n\tstruct platform_device *pdev;\n\tstruct mtk_ecc *ecc;\n\n\tpdev = of_find_device_by_node(np);\n\tif (!pdev)\n\t\treturn ERR_PTR(-EPROBE_DEFER);\n\n\tecc = platform_get_drvdata(pdev);\n\tif (!ecc) {\n\t\tput_device(&pdev->dev);\n\t\treturn ERR_PTR(-EPROBE_DEFER);\n\t}\n\n\tclk_prepare_enable(ecc->clk);\n\tmtk_ecc_hw_init(ecc);\n\n\treturn ecc;\n}\n\nstruct mtk_ecc *of_mtk_ecc_get(struct device_node *of_node)\n{\n\tstruct mtk_ecc *ecc = NULL;\n\tstruct device_node *np;\n\n\tnp = of_parse_phandle(of_node, \"nand-ecc-engine\", 0);\n\t \n\tif (!np)\n\t\tnp = of_parse_phandle(of_node, \"ecc-engine\", 0);\n\tif (np) {\n\t\tecc = mtk_ecc_get(np);\n\t\tof_node_put(np);\n\t}\n\n\treturn ecc;\n}\nEXPORT_SYMBOL(of_mtk_ecc_get);\n\nint mtk_ecc_enable(struct mtk_ecc *ecc, struct mtk_ecc_config *config)\n{\n\tenum mtk_ecc_operation op = config->op;\n\tu16 reg_val;\n\tint ret;\n\n\tret = mutex_lock_interruptible(&ecc->lock);\n\tif (ret) {\n\t\tdev_err(ecc->dev, \"interrupted when attempting to lock\\n\");\n\t\treturn ret;\n\t}\n\n\tmtk_ecc_wait_idle(ecc, op);\n\n\tret = mtk_ecc_config(ecc, config);\n\tif (ret) {\n\t\tmutex_unlock(&ecc->lock);\n\t\treturn ret;\n\t}\n\n\tif (config->mode != ECC_NFI_MODE || op != ECC_ENCODE) {\n\t\tinit_completion(&ecc->done);\n\t\treg_val = ECC_IRQ_EN;\n\t\t \n\t\tif (ecc->caps->pg_irq_sel && config->mode == ECC_NFI_MODE)\n\t\t\treg_val |= ECC_PG_IRQ_SEL;\n\t\tif (op == ECC_ENCODE)\n\t\t\twritew(reg_val, ecc->regs +\n\t\t\t       ecc->caps->ecc_regs[ECC_ENCIRQ_EN]);\n\t\telse\n\t\t\twritew(reg_val, ecc->regs +\n\t\t\t       ecc->caps->ecc_regs[ECC_DECIRQ_EN]);\n\t}\n\n\twritew(ECC_OP_ENABLE, ecc->regs + ECC_CTL_REG(op));\n\n\treturn 0;\n}\nEXPORT_SYMBOL(mtk_ecc_enable);\n\nvoid mtk_ecc_disable(struct mtk_ecc *ecc)\n{\n\tenum mtk_ecc_operation op = ECC_ENCODE;\n\n\t \n\tif (readw(ecc->regs + ECC_CTL_REG(op)) != ECC_OP_ENABLE)\n\t\top = ECC_DECODE;\n\n\t \n\tmtk_ecc_wait_idle(ecc, op);\n\tif (op == ECC_DECODE) {\n\t\t \n\t\treadw(ecc->regs + ecc->caps->ecc_regs[ECC_DECDONE]);\n\t\twritew(0, ecc->regs + ecc->caps->ecc_regs[ECC_DECIRQ_EN]);\n\t} else {\n\t\twritew(0, ecc->regs + ecc->caps->ecc_regs[ECC_ENCIRQ_EN]);\n\t}\n\n\twritew(ECC_OP_DISABLE, ecc->regs + ECC_CTL_REG(op));\n\n\tmutex_unlock(&ecc->lock);\n}\nEXPORT_SYMBOL(mtk_ecc_disable);\n\nint mtk_ecc_wait_done(struct mtk_ecc *ecc, enum mtk_ecc_operation op)\n{\n\tint ret;\n\n\tret = wait_for_completion_timeout(&ecc->done, msecs_to_jiffies(500));\n\tif (!ret) {\n\t\tdev_err(ecc->dev, \"%s timeout - interrupt did not arrive)\\n\",\n\t\t\t(op == ECC_ENCODE) ? \"encoder\" : \"decoder\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(mtk_ecc_wait_done);\n\nint mtk_ecc_encode(struct mtk_ecc *ecc, struct mtk_ecc_config *config,\n\t\t   u8 *data, u32 bytes)\n{\n\tdma_addr_t addr;\n\tu32 len;\n\tint ret;\n\n\taddr = dma_map_single(ecc->dev, data, bytes, DMA_TO_DEVICE);\n\tret = dma_mapping_error(ecc->dev, addr);\n\tif (ret) {\n\t\tdev_err(ecc->dev, \"dma mapping error\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tconfig->op = ECC_ENCODE;\n\tconfig->addr = addr;\n\tret = mtk_ecc_enable(ecc, config);\n\tif (ret) {\n\t\tdma_unmap_single(ecc->dev, addr, bytes, DMA_TO_DEVICE);\n\t\treturn ret;\n\t}\n\n\tret = mtk_ecc_wait_done(ecc, ECC_ENCODE);\n\tif (ret)\n\t\tgoto timeout;\n\n\tmtk_ecc_wait_idle(ecc, ECC_ENCODE);\n\n\t \n\tlen = (config->strength * ecc->caps->parity_bits + 7) >> 3;\n\n\t \n\t__ioread32_copy(ecc->eccdata,\n\t\t\tecc->regs + ecc->caps->ecc_regs[ECC_ENCPAR00],\n\t\t\tround_up(len, 4));\n\n\t \n\tmemcpy(data + bytes, ecc->eccdata, len);\ntimeout:\n\n\tdma_unmap_single(ecc->dev, addr, bytes, DMA_TO_DEVICE);\n\tmtk_ecc_disable(ecc);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(mtk_ecc_encode);\n\nvoid mtk_ecc_adjust_strength(struct mtk_ecc *ecc, u32 *p)\n{\n\tconst u8 *ecc_strength = ecc->caps->ecc_strength;\n\tint i;\n\n\tfor (i = 0; i < ecc->caps->num_ecc_strength; i++) {\n\t\tif (*p <= ecc_strength[i]) {\n\t\t\tif (!i)\n\t\t\t\t*p = ecc_strength[i];\n\t\t\telse if (*p != ecc_strength[i])\n\t\t\t\t*p = ecc_strength[i - 1];\n\t\t\treturn;\n\t\t}\n\t}\n\n\t*p = ecc_strength[ecc->caps->num_ecc_strength - 1];\n}\nEXPORT_SYMBOL(mtk_ecc_adjust_strength);\n\nunsigned int mtk_ecc_get_parity_bits(struct mtk_ecc *ecc)\n{\n\treturn ecc->caps->parity_bits;\n}\nEXPORT_SYMBOL(mtk_ecc_get_parity_bits);\n\nstatic const struct mtk_ecc_caps mtk_ecc_caps_mt2701 = {\n\t.err_mask = ECC_ERRMASK_MT2701,\n\t.err_shift = 8,\n\t.ecc_strength = ecc_strength_mt2701,\n\t.ecc_regs = mt2701_ecc_regs,\n\t.num_ecc_strength = 20,\n\t.ecc_mode_shift = 5,\n\t.parity_bits = 14,\n\t.pg_irq_sel = 0,\n};\n\nstatic const struct mtk_ecc_caps mtk_ecc_caps_mt2712 = {\n\t.err_mask = ECC_ERRMASK_MT2712,\n\t.err_shift = 8,\n\t.ecc_strength = ecc_strength_mt2712,\n\t.ecc_regs = mt2712_ecc_regs,\n\t.num_ecc_strength = 23,\n\t.ecc_mode_shift = 5,\n\t.parity_bits = 14,\n\t.pg_irq_sel = 1,\n};\n\nstatic const struct mtk_ecc_caps mtk_ecc_caps_mt7622 = {\n\t.err_mask = ECC_ERRMASK_MT7622,\n\t.err_shift = 5,\n\t.ecc_strength = ecc_strength_mt7622,\n\t.ecc_regs = mt7622_ecc_regs,\n\t.num_ecc_strength = 5,\n\t.ecc_mode_shift = 4,\n\t.parity_bits = 13,\n\t.pg_irq_sel = 0,\n};\n\nstatic const struct mtk_ecc_caps mtk_ecc_caps_mt7986 = {\n\t.err_mask = ECC_ERRMASK_MT7622,\n\t.err_shift = 8,\n\t.ecc_strength = ecc_strength_mt7986,\n\t.ecc_regs = mt2712_ecc_regs,\n\t.num_ecc_strength = 11,\n\t.ecc_mode_shift = 5,\n\t.parity_bits = 14,\n\t.pg_irq_sel = 1,\n};\n\nstatic const struct of_device_id mtk_ecc_dt_match[] = {\n\t{\n\t\t.compatible = \"mediatek,mt2701-ecc\",\n\t\t.data = &mtk_ecc_caps_mt2701,\n\t}, {\n\t\t.compatible = \"mediatek,mt2712-ecc\",\n\t\t.data = &mtk_ecc_caps_mt2712,\n\t}, {\n\t\t.compatible = \"mediatek,mt7622-ecc\",\n\t\t.data = &mtk_ecc_caps_mt7622,\n\t}, {\n\t\t.compatible = \"mediatek,mt7986-ecc\",\n\t\t.data = &mtk_ecc_caps_mt7986,\n\t},\n\t{},\n};\n\nstatic int mtk_ecc_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct mtk_ecc *ecc;\n\tu32 max_eccdata_size;\n\tint irq, ret;\n\n\tecc = devm_kzalloc(dev, sizeof(*ecc), GFP_KERNEL);\n\tif (!ecc)\n\t\treturn -ENOMEM;\n\n\tecc->caps = of_device_get_match_data(dev);\n\n\tmax_eccdata_size = ecc->caps->num_ecc_strength - 1;\n\tmax_eccdata_size = ecc->caps->ecc_strength[max_eccdata_size];\n\tmax_eccdata_size = (max_eccdata_size * ecc->caps->parity_bits + 7) >> 3;\n\tmax_eccdata_size = round_up(max_eccdata_size, 4);\n\tecc->eccdata = devm_kzalloc(dev, max_eccdata_size, GFP_KERNEL);\n\tif (!ecc->eccdata)\n\t\treturn -ENOMEM;\n\n\tecc->regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(ecc->regs))\n\t\treturn PTR_ERR(ecc->regs);\n\n\tecc->clk = devm_clk_get(dev, NULL);\n\tif (IS_ERR(ecc->clk)) {\n\t\tdev_err(dev, \"failed to get clock: %ld\\n\", PTR_ERR(ecc->clk));\n\t\treturn PTR_ERR(ecc->clk);\n\t}\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tret = dma_set_mask(dev, DMA_BIT_MASK(32));\n\tif (ret) {\n\t\tdev_err(dev, \"failed to set DMA mask\\n\");\n\t\treturn ret;\n\t}\n\n\tret = devm_request_irq(dev, irq, mtk_ecc_irq, 0x0, \"mtk-ecc\", ecc);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to request irq\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tecc->dev = dev;\n\tmutex_init(&ecc->lock);\n\tplatform_set_drvdata(pdev, ecc);\n\tdev_info(dev, \"probed\\n\");\n\n\treturn 0;\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int mtk_ecc_suspend(struct device *dev)\n{\n\tstruct mtk_ecc *ecc = dev_get_drvdata(dev);\n\n\tclk_disable_unprepare(ecc->clk);\n\n\treturn 0;\n}\n\nstatic int mtk_ecc_resume(struct device *dev)\n{\n\tstruct mtk_ecc *ecc = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = clk_prepare_enable(ecc->clk);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to enable clk\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic SIMPLE_DEV_PM_OPS(mtk_ecc_pm_ops, mtk_ecc_suspend, mtk_ecc_resume);\n#endif\n\nMODULE_DEVICE_TABLE(of, mtk_ecc_dt_match);\n\nstatic struct platform_driver mtk_ecc_driver = {\n\t.probe  = mtk_ecc_probe,\n\t.driver = {\n\t\t.name  = \"mtk-ecc\",\n\t\t.of_match_table = mtk_ecc_dt_match,\n#ifdef CONFIG_PM_SLEEP\n\t\t.pm = &mtk_ecc_pm_ops,\n#endif\n\t},\n};\n\nmodule_platform_driver(mtk_ecc_driver);\n\nMODULE_AUTHOR(\"Xiaolei Li <xiaolei.li@mediatek.com>\");\nMODULE_DESCRIPTION(\"MTK Nand ECC Driver\");\nMODULE_LICENSE(\"Dual MIT/GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}