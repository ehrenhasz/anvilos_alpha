{
  "module_name": "core.c",
  "hash_id": "67f3d9b9add43c63b1107a1dfe308ecf6e6393e410b62bca463554120e13081d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/nand/core.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt)\t\"nand: \" fmt\n\n#include <linux/module.h>\n#include <linux/mtd/nand.h>\n\n \nbool nanddev_isbad(struct nand_device *nand, const struct nand_pos *pos)\n{\n\tif (mtd_check_expert_analysis_mode())\n\t\treturn false;\n\n\tif (nanddev_bbt_is_initialized(nand)) {\n\t\tunsigned int entry;\n\t\tint status;\n\n\t\tentry = nanddev_bbt_pos_to_entry(nand, pos);\n\t\tstatus = nanddev_bbt_get_block_status(nand, entry);\n\t\t \n\t\tif (status == NAND_BBT_BLOCK_STATUS_UNKNOWN) {\n\t\t\tif (nand->ops->isbad(nand, pos))\n\t\t\t\tstatus = NAND_BBT_BLOCK_FACTORY_BAD;\n\t\t\telse\n\t\t\t\tstatus = NAND_BBT_BLOCK_GOOD;\n\n\t\t\tnanddev_bbt_set_block_status(nand, entry, status);\n\t\t}\n\n\t\tif (status == NAND_BBT_BLOCK_WORN ||\n\t\t    status == NAND_BBT_BLOCK_FACTORY_BAD)\n\t\t\treturn true;\n\n\t\treturn false;\n\t}\n\n\treturn nand->ops->isbad(nand, pos);\n}\nEXPORT_SYMBOL_GPL(nanddev_isbad);\n\n \nint nanddev_markbad(struct nand_device *nand, const struct nand_pos *pos)\n{\n\tstruct mtd_info *mtd = nanddev_to_mtd(nand);\n\tunsigned int entry;\n\tint ret = 0;\n\n\tif (nanddev_isbad(nand, pos))\n\t\treturn 0;\n\n\tret = nand->ops->markbad(nand, pos);\n\tif (ret)\n\t\tpr_warn(\"failed to write BBM to block @%llx (err = %d)\\n\",\n\t\t\tnanddev_pos_to_offs(nand, pos), ret);\n\n\tif (!nanddev_bbt_is_initialized(nand))\n\t\tgoto out;\n\n\tentry = nanddev_bbt_pos_to_entry(nand, pos);\n\tret = nanddev_bbt_set_block_status(nand, entry, NAND_BBT_BLOCK_WORN);\n\tif (ret)\n\t\tgoto out;\n\n\tret = nanddev_bbt_update(nand);\n\nout:\n\tif (!ret)\n\t\tmtd->ecc_stats.badblocks++;\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(nanddev_markbad);\n\n \nbool nanddev_isreserved(struct nand_device *nand, const struct nand_pos *pos)\n{\n\tunsigned int entry;\n\tint status;\n\n\tif (!nanddev_bbt_is_initialized(nand))\n\t\treturn false;\n\n\t \n\tentry = nanddev_bbt_pos_to_entry(nand, pos);\n\tstatus = nanddev_bbt_get_block_status(nand, entry);\n\treturn status == NAND_BBT_BLOCK_RESERVED;\n}\nEXPORT_SYMBOL_GPL(nanddev_isreserved);\n\n \nstatic int nanddev_erase(struct nand_device *nand, const struct nand_pos *pos)\n{\n\tif (nanddev_isbad(nand, pos) || nanddev_isreserved(nand, pos)) {\n\t\tpr_warn(\"attempt to erase a bad/reserved block @%llx\\n\",\n\t\t\tnanddev_pos_to_offs(nand, pos));\n\t\treturn -EIO;\n\t}\n\n\treturn nand->ops->erase(nand, pos);\n}\n\n \nint nanddev_mtd_erase(struct mtd_info *mtd, struct erase_info *einfo)\n{\n\tstruct nand_device *nand = mtd_to_nanddev(mtd);\n\tstruct nand_pos pos, last;\n\tint ret;\n\n\tnanddev_offs_to_pos(nand, einfo->addr, &pos);\n\tnanddev_offs_to_pos(nand, einfo->addr + einfo->len - 1, &last);\n\twhile (nanddev_pos_cmp(&pos, &last) <= 0) {\n\t\tret = nanddev_erase(nand, &pos);\n\t\tif (ret) {\n\t\t\teinfo->fail_addr = nanddev_pos_to_offs(nand, &pos);\n\n\t\t\treturn ret;\n\t\t}\n\n\t\tnanddev_pos_next_eraseblock(nand, &pos);\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(nanddev_mtd_erase);\n\n \nint nanddev_mtd_max_bad_blocks(struct mtd_info *mtd, loff_t offs, size_t len)\n{\n\tstruct nand_device *nand = mtd_to_nanddev(mtd);\n\tstruct nand_pos pos, end;\n\tunsigned int max_bb = 0;\n\n\tif (!nand->memorg.max_bad_eraseblocks_per_lun)\n\t\treturn -ENOTSUPP;\n\n\tnanddev_offs_to_pos(nand, offs, &pos);\n\tnanddev_offs_to_pos(nand, offs + len, &end);\n\n\tfor (nanddev_offs_to_pos(nand, offs, &pos);\n\t     nanddev_pos_cmp(&pos, &end) < 0;\n\t     nanddev_pos_next_lun(nand, &pos))\n\t\tmax_bb += nand->memorg.max_bad_eraseblocks_per_lun;\n\n\treturn max_bb;\n}\nEXPORT_SYMBOL_GPL(nanddev_mtd_max_bad_blocks);\n\n \nstatic int nanddev_get_ecc_engine(struct nand_device *nand)\n{\n\tint engine_type;\n\n\t \n\tof_get_nand_ecc_user_config(nand);\n\n\tengine_type = nand->ecc.user_conf.engine_type;\n\tif (engine_type == NAND_ECC_ENGINE_TYPE_INVALID)\n\t\tengine_type = nand->ecc.defaults.engine_type;\n\n\tswitch (engine_type) {\n\tcase NAND_ECC_ENGINE_TYPE_NONE:\n\t\treturn 0;\n\tcase NAND_ECC_ENGINE_TYPE_SOFT:\n\t\tnand->ecc.engine = nand_ecc_get_sw_engine(nand);\n\t\tbreak;\n\tcase NAND_ECC_ENGINE_TYPE_ON_DIE:\n\t\tnand->ecc.engine = nand_ecc_get_on_die_hw_engine(nand);\n\t\tbreak;\n\tcase NAND_ECC_ENGINE_TYPE_ON_HOST:\n\t\tnand->ecc.engine = nand_ecc_get_on_host_hw_engine(nand);\n\t\tif (PTR_ERR(nand->ecc.engine) == -EPROBE_DEFER)\n\t\t\treturn -EPROBE_DEFER;\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"Missing ECC engine type\\n\");\n\t}\n\n\tif (!nand->ecc.engine)\n\t\treturn  -EINVAL;\n\n\treturn 0;\n}\n\n \nstatic int nanddev_put_ecc_engine(struct nand_device *nand)\n{\n\tswitch (nand->ecc.ctx.conf.engine_type) {\n\tcase NAND_ECC_ENGINE_TYPE_ON_HOST:\n\t\tnand_ecc_put_on_host_hw_engine(nand);\n\t\tbreak;\n\tcase NAND_ECC_ENGINE_TYPE_NONE:\n\tcase NAND_ECC_ENGINE_TYPE_SOFT:\n\tcase NAND_ECC_ENGINE_TYPE_ON_DIE:\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int nanddev_find_ecc_configuration(struct nand_device *nand)\n{\n\tint ret;\n\n\tif (!nand->ecc.engine)\n\t\treturn -ENOTSUPP;\n\n\tret = nand_ecc_init_ctx(nand);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!nand_ecc_is_strong_enough(nand))\n\t\tpr_warn(\"WARNING: %s: the ECC used on your system is too weak compared to the one required by the NAND chip\\n\",\n\t\t\tnand->mtd.name);\n\n\treturn 0;\n}\n\n \nint nanddev_ecc_engine_init(struct nand_device *nand)\n{\n\tint ret;\n\n\t \n\tret = nanddev_get_ecc_engine(nand);\n\tif (ret) {\n\t\tif (ret != -EPROBE_DEFER)\n\t\t\tpr_err(\"No ECC engine found\\n\");\n\n\t\treturn ret;\n\t}\n\n\t \n\tif (!nand->ecc.engine)\n\t\treturn 0;\n\n\t \n\tret = nanddev_find_ecc_configuration(nand);\n\tif (ret) {\n\t\tpr_err(\"No suitable ECC configuration\\n\");\n\t\tnanddev_put_ecc_engine(nand);\n\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(nanddev_ecc_engine_init);\n\n \nvoid nanddev_ecc_engine_cleanup(struct nand_device *nand)\n{\n\tif (nand->ecc.engine)\n\t\tnand_ecc_cleanup_ctx(nand);\n\n\tnanddev_put_ecc_engine(nand);\n}\nEXPORT_SYMBOL_GPL(nanddev_ecc_engine_cleanup);\n\n \nint nanddev_init(struct nand_device *nand, const struct nand_ops *ops,\n\t\t struct module *owner)\n{\n\tstruct mtd_info *mtd = nanddev_to_mtd(nand);\n\tstruct nand_memory_organization *memorg = nanddev_get_memorg(nand);\n\n\tif (!nand || !ops)\n\t\treturn -EINVAL;\n\n\tif (!ops->erase || !ops->markbad || !ops->isbad)\n\t\treturn -EINVAL;\n\n\tif (!memorg->bits_per_cell || !memorg->pagesize ||\n\t    !memorg->pages_per_eraseblock || !memorg->eraseblocks_per_lun ||\n\t    !memorg->planes_per_lun || !memorg->luns_per_target ||\n\t    !memorg->ntargets)\n\t\treturn -EINVAL;\n\n\tnand->rowconv.eraseblock_addr_shift =\n\t\t\t\t\tfls(memorg->pages_per_eraseblock - 1);\n\tnand->rowconv.lun_addr_shift = fls(memorg->eraseblocks_per_lun - 1) +\n\t\t\t\t       nand->rowconv.eraseblock_addr_shift;\n\n\tnand->ops = ops;\n\n\tmtd->type = memorg->bits_per_cell == 1 ?\n\t\t    MTD_NANDFLASH : MTD_MLCNANDFLASH;\n\tmtd->flags = MTD_CAP_NANDFLASH;\n\tmtd->erasesize = memorg->pagesize * memorg->pages_per_eraseblock;\n\tmtd->writesize = memorg->pagesize;\n\tmtd->writebufsize = memorg->pagesize;\n\tmtd->oobsize = memorg->oobsize;\n\tmtd->size = nanddev_size(nand);\n\tmtd->owner = owner;\n\n\treturn nanddev_bbt_init(nand);\n}\nEXPORT_SYMBOL_GPL(nanddev_init);\n\n \nvoid nanddev_cleanup(struct nand_device *nand)\n{\n\tif (nanddev_bbt_is_initialized(nand))\n\t\tnanddev_bbt_cleanup(nand);\n}\nEXPORT_SYMBOL_GPL(nanddev_cleanup);\n\nMODULE_DESCRIPTION(\"Generic NAND framework\");\nMODULE_AUTHOR(\"Boris Brezillon <boris.brezillon@free-electrons.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}