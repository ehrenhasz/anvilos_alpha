{
  "module_name": "nand_micron.c",
  "hash_id": "592833d78f7833456f610587fba970ce29992d8ac0c695629975692d9c04837c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/nand/raw/nand_micron.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n\n#include \"internals.h\"\n\n \n#define NAND_ECC_STATUS_WRITE_RECOMMENDED\tBIT(3)\n\n \n#define NAND_ECC_STATUS_MASK\t\t(BIT(4) | BIT(3) | BIT(0))\n#define NAND_ECC_STATUS_UNCORRECTABLE\tBIT(0)\n#define NAND_ECC_STATUS_4_6_CORRECTED\tBIT(3)\n#define NAND_ECC_STATUS_1_3_CORRECTED\tBIT(4)\n#define NAND_ECC_STATUS_7_8_CORRECTED\t(BIT(4) | BIT(3))\n\nstruct nand_onfi_vendor_micron {\n\tu8 two_plane_read;\n\tu8 read_cache;\n\tu8 read_unique_id;\n\tu8 dq_imped;\n\tu8 dq_imped_num_settings;\n\tu8 dq_imped_feat_addr;\n\tu8 rb_pulldown_strength;\n\tu8 rb_pulldown_strength_feat_addr;\n\tu8 rb_pulldown_strength_num_settings;\n\tu8 otp_mode;\n\tu8 otp_page_start;\n\tu8 otp_data_prot_addr;\n\tu8 otp_num_pages;\n\tu8 otp_feat_addr;\n\tu8 read_retry_options;\n\tu8 reserved[72];\n\tu8 param_revision;\n} __packed;\n\nstruct micron_on_die_ecc {\n\tbool forced;\n\tbool enabled;\n\tvoid *rawbuf;\n};\n\nstruct micron_nand {\n\tstruct micron_on_die_ecc ecc;\n};\n\nstatic int micron_nand_setup_read_retry(struct nand_chip *chip, int retry_mode)\n{\n\tu8 feature[ONFI_SUBFEATURE_PARAM_LEN] = {retry_mode};\n\n\treturn nand_set_features(chip, ONFI_FEATURE_ADDR_READ_RETRY, feature);\n}\n\n \nstatic int micron_nand_onfi_init(struct nand_chip *chip)\n{\n\tstruct nand_parameters *p = &chip->parameters;\n\n\tif (p->onfi) {\n\t\tstruct nand_onfi_vendor_micron *micron = (void *)p->onfi->vendor;\n\n\t\tchip->read_retries = micron->read_retry_options;\n\t\tchip->ops.setup_read_retry = micron_nand_setup_read_retry;\n\t}\n\n\tif (p->supports_set_get_features) {\n\t\tset_bit(ONFI_FEATURE_ADDR_READ_RETRY, p->set_feature_list);\n\t\tset_bit(ONFI_FEATURE_ON_DIE_ECC, p->set_feature_list);\n\t\tset_bit(ONFI_FEATURE_ADDR_READ_RETRY, p->get_feature_list);\n\t\tset_bit(ONFI_FEATURE_ON_DIE_ECC, p->get_feature_list);\n\t}\n\n\treturn 0;\n}\n\nstatic int micron_nand_on_die_4_ooblayout_ecc(struct mtd_info *mtd,\n\t\t\t\t\t      int section,\n\t\t\t\t\t      struct mtd_oob_region *oobregion)\n{\n\tif (section >= 4)\n\t\treturn -ERANGE;\n\n\toobregion->offset = (section * 16) + 8;\n\toobregion->length = 8;\n\n\treturn 0;\n}\n\nstatic int micron_nand_on_die_4_ooblayout_free(struct mtd_info *mtd,\n\t\t\t\t\t       int section,\n\t\t\t\t\t       struct mtd_oob_region *oobregion)\n{\n\tif (section >= 4)\n\t\treturn -ERANGE;\n\n\toobregion->offset = (section * 16) + 2;\n\toobregion->length = 6;\n\n\treturn 0;\n}\n\nstatic const struct mtd_ooblayout_ops micron_nand_on_die_4_ooblayout_ops = {\n\t.ecc = micron_nand_on_die_4_ooblayout_ecc,\n\t.free = micron_nand_on_die_4_ooblayout_free,\n};\n\nstatic int micron_nand_on_die_8_ooblayout_ecc(struct mtd_info *mtd,\n\t\t\t\t\t      int section,\n\t\t\t\t\t      struct mtd_oob_region *oobregion)\n{\n\tstruct nand_chip *chip = mtd_to_nand(mtd);\n\n\tif (section)\n\t\treturn -ERANGE;\n\n\toobregion->offset = mtd->oobsize - chip->ecc.total;\n\toobregion->length = chip->ecc.total;\n\n\treturn 0;\n}\n\nstatic int micron_nand_on_die_8_ooblayout_free(struct mtd_info *mtd,\n\t\t\t\t\t       int section,\n\t\t\t\t\t       struct mtd_oob_region *oobregion)\n{\n\tstruct nand_chip *chip = mtd_to_nand(mtd);\n\n\tif (section)\n\t\treturn -ERANGE;\n\n\toobregion->offset = 2;\n\toobregion->length = mtd->oobsize - chip->ecc.total - 2;\n\n\treturn 0;\n}\n\nstatic const struct mtd_ooblayout_ops micron_nand_on_die_8_ooblayout_ops = {\n\t.ecc = micron_nand_on_die_8_ooblayout_ecc,\n\t.free = micron_nand_on_die_8_ooblayout_free,\n};\n\nstatic int micron_nand_on_die_ecc_setup(struct nand_chip *chip, bool enable)\n{\n\tstruct micron_nand *micron = nand_get_manufacturer_data(chip);\n\tu8 feature[ONFI_SUBFEATURE_PARAM_LEN] = { 0, };\n\tint ret;\n\n\tif (micron->ecc.forced)\n\t\treturn 0;\n\n\tif (micron->ecc.enabled == enable)\n\t\treturn 0;\n\n\tif (enable)\n\t\tfeature[0] |= ONFI_FEATURE_ON_DIE_ECC_EN;\n\n\tret = nand_set_features(chip, ONFI_FEATURE_ON_DIE_ECC, feature);\n\tif (!ret)\n\t\tmicron->ecc.enabled = enable;\n\n\treturn ret;\n}\n\nstatic int micron_nand_on_die_ecc_status_4(struct nand_chip *chip, u8 status,\n\t\t\t\t\t   void *buf, int page,\n\t\t\t\t\t   int oob_required)\n{\n\tstruct micron_nand *micron = nand_get_manufacturer_data(chip);\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tunsigned int step, max_bitflips = 0;\n\tbool use_datain = false;\n\tint ret;\n\n\tif (!(status & NAND_ECC_STATUS_WRITE_RECOMMENDED)) {\n\t\tif (status & NAND_STATUS_FAIL)\n\t\t\tmtd->ecc_stats.failed++;\n\n\t\treturn 0;\n\t}\n\n\t \n\tif (!oob_required) {\n\t\t \n\t\tif (!nand_has_exec_op(chip) ||\n\t\t    !nand_read_data_op(chip, chip->oob_poi, mtd->oobsize, false,\n\t\t\t\t       true))\n\t\t\tuse_datain = true;\n\n\t\tif (use_datain)\n\t\t\tret = nand_read_data_op(chip, chip->oob_poi,\n\t\t\t\t\t\tmtd->oobsize, false, false);\n\t\telse\n\t\t\tret = nand_change_read_column_op(chip, mtd->writesize,\n\t\t\t\t\t\t\t chip->oob_poi,\n\t\t\t\t\t\t\t mtd->oobsize, false);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tmicron_nand_on_die_ecc_setup(chip, false);\n\n\tret = nand_read_page_op(chip, page, 0, micron->ecc.rawbuf,\n\t\t\t\tmtd->writesize + mtd->oobsize);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (step = 0; step < chip->ecc.steps; step++) {\n\t\tunsigned int offs, i, nbitflips = 0;\n\t\tu8 *rawbuf, *corrbuf;\n\n\t\toffs = step * chip->ecc.size;\n\t\trawbuf = micron->ecc.rawbuf + offs;\n\t\tcorrbuf = buf + offs;\n\n\t\tfor (i = 0; i < chip->ecc.size; i++)\n\t\t\tnbitflips += hweight8(corrbuf[i] ^ rawbuf[i]);\n\n\t\toffs = (step * 16) + 4;\n\t\trawbuf = micron->ecc.rawbuf + mtd->writesize + offs;\n\t\tcorrbuf = chip->oob_poi + offs;\n\n\t\tfor (i = 0; i < chip->ecc.bytes + 4; i++)\n\t\t\tnbitflips += hweight8(corrbuf[i] ^ rawbuf[i]);\n\n\t\tif (WARN_ON(nbitflips > chip->ecc.strength))\n\t\t\treturn -EINVAL;\n\n\t\tmax_bitflips = max(nbitflips, max_bitflips);\n\t\tmtd->ecc_stats.corrected += nbitflips;\n\t}\n\n\treturn max_bitflips;\n}\n\nstatic int micron_nand_on_die_ecc_status_8(struct nand_chip *chip, u8 status)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\n\t \n\tswitch (status & NAND_ECC_STATUS_MASK) {\n\tcase NAND_ECC_STATUS_UNCORRECTABLE:\n\t\tmtd->ecc_stats.failed++;\n\t\treturn 0;\n\tcase NAND_ECC_STATUS_1_3_CORRECTED:\n\t\tmtd->ecc_stats.corrected += 3;\n\t\treturn 3;\n\tcase NAND_ECC_STATUS_4_6_CORRECTED:\n\t\tmtd->ecc_stats.corrected += 6;\n\t\t \n\t\treturn 6;\n\tcase NAND_ECC_STATUS_7_8_CORRECTED:\n\t\tmtd->ecc_stats.corrected += 8;\n\t\t \n\t\treturn 8;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic int\nmicron_nand_read_page_on_die_ecc(struct nand_chip *chip, uint8_t *buf,\n\t\t\t\t int oob_required, int page)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tbool use_datain = false;\n\tu8 status;\n\tint ret, max_bitflips = 0;\n\n\tret = micron_nand_on_die_ecc_setup(chip, true);\n\tif (ret)\n\t\treturn ret;\n\n\tret = nand_read_page_op(chip, page, 0, NULL, 0);\n\tif (ret)\n\t\tgoto out;\n\n\tret = nand_status_op(chip, &status);\n\tif (ret)\n\t\tgoto out;\n\n\t \n\tif (!nand_has_exec_op(chip) ||\n\t    !nand_read_data_op(chip, buf, mtd->writesize, false, true))\n\t\tuse_datain = true;\n\n\tif (use_datain) {\n\t\tret = nand_exit_status_op(chip);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\tret = nand_read_data_op(chip, buf, mtd->writesize, false,\n\t\t\t\t\tfalse);\n\t\tif (!ret && oob_required)\n\t\t\tret = nand_read_data_op(chip, chip->oob_poi,\n\t\t\t\t\t\tmtd->oobsize, false, false);\n\t} else {\n\t\tret = nand_change_read_column_op(chip, 0, buf, mtd->writesize,\n\t\t\t\t\t\t false);\n\t\tif (!ret && oob_required)\n\t\t\tret = nand_change_read_column_op(chip, mtd->writesize,\n\t\t\t\t\t\t\t chip->oob_poi,\n\t\t\t\t\t\t\t mtd->oobsize, false);\n\t}\n\n\tif (chip->ecc.strength == 4)\n\t\tmax_bitflips = micron_nand_on_die_ecc_status_4(chip, status,\n\t\t\t\t\t\t\t       buf, page,\n\t\t\t\t\t\t\t       oob_required);\n\telse\n\t\tmax_bitflips = micron_nand_on_die_ecc_status_8(chip, status);\n\nout:\n\tmicron_nand_on_die_ecc_setup(chip, false);\n\n\treturn ret ? ret : max_bitflips;\n}\n\nstatic int\nmicron_nand_write_page_on_die_ecc(struct nand_chip *chip, const uint8_t *buf,\n\t\t\t\t  int oob_required, int page)\n{\n\tint ret;\n\n\tret = micron_nand_on_die_ecc_setup(chip, true);\n\tif (ret)\n\t\treturn ret;\n\n\tret = nand_write_page_raw(chip, buf, oob_required, page);\n\tmicron_nand_on_die_ecc_setup(chip, false);\n\n\treturn ret;\n}\n\nenum {\n\t \n\tMICRON_ON_DIE_UNSUPPORTED,\n\n\t \n\tMICRON_ON_DIE_SUPPORTED,\n\n\t \n\tMICRON_ON_DIE_MANDATORY,\n};\n\n#define MICRON_ID_INTERNAL_ECC_MASK\tGENMASK(1, 0)\n#define MICRON_ID_ECC_ENABLED\t\tBIT(7)\n\n \nstatic int micron_supports_on_die_ecc(struct nand_chip *chip)\n{\n\tconst struct nand_ecc_props *requirements =\n\t\tnanddev_get_ecc_requirements(&chip->base);\n\tu8 id[5];\n\tint ret;\n\n\tif (!chip->parameters.onfi)\n\t\treturn MICRON_ON_DIE_UNSUPPORTED;\n\n\tif (nanddev_bits_per_cell(&chip->base) != 1)\n\t\treturn MICRON_ON_DIE_UNSUPPORTED;\n\n\t \n\tif  (requirements->strength != 4 && requirements->strength != 8)\n\t\treturn MICRON_ON_DIE_UNSUPPORTED;\n\n\t \n\tif (chip->id.len != 5 ||\n\t    (chip->id.data[4] & MICRON_ID_INTERNAL_ECC_MASK) != 0x2)\n\t\treturn MICRON_ON_DIE_UNSUPPORTED;\n\n\t \n\tret = micron_nand_on_die_ecc_setup(chip, true);\n\tif (ret)\n\t\treturn MICRON_ON_DIE_UNSUPPORTED;\n\n\tret = nand_readid_op(chip, 0, id, sizeof(id));\n\tif (ret)\n\t\treturn MICRON_ON_DIE_UNSUPPORTED;\n\n\tret = micron_nand_on_die_ecc_setup(chip, false);\n\tif (ret)\n\t\treturn MICRON_ON_DIE_UNSUPPORTED;\n\n\tif (!(id[4] & MICRON_ID_ECC_ENABLED))\n\t\treturn MICRON_ON_DIE_UNSUPPORTED;\n\n\tret = nand_readid_op(chip, 0, id, sizeof(id));\n\tif (ret)\n\t\treturn MICRON_ON_DIE_UNSUPPORTED;\n\n\tif (id[4] & MICRON_ID_ECC_ENABLED)\n\t\treturn MICRON_ON_DIE_MANDATORY;\n\n\t \n\tif  (requirements->strength != 4 && requirements->strength != 8)\n\t\treturn MICRON_ON_DIE_UNSUPPORTED;\n\n\treturn MICRON_ON_DIE_SUPPORTED;\n}\n\nstatic int micron_nand_init(struct nand_chip *chip)\n{\n\tstruct nand_device *base = &chip->base;\n\tconst struct nand_ecc_props *requirements =\n\t\tnanddev_get_ecc_requirements(base);\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tstruct micron_nand *micron;\n\tint ondie;\n\tint ret;\n\n\tmicron = kzalloc(sizeof(*micron), GFP_KERNEL);\n\tif (!micron)\n\t\treturn -ENOMEM;\n\n\tnand_set_manufacturer_data(chip, micron);\n\n\tret = micron_nand_onfi_init(chip);\n\tif (ret)\n\t\tgoto err_free_manuf_data;\n\n\tchip->options |= NAND_BBM_FIRSTPAGE;\n\n\tif (mtd->writesize == 2048)\n\t\tchip->options |= NAND_BBM_SECONDPAGE;\n\n\tondie = micron_supports_on_die_ecc(chip);\n\n\tif (ondie == MICRON_ON_DIE_MANDATORY &&\n\t    chip->ecc.engine_type != NAND_ECC_ENGINE_TYPE_ON_DIE) {\n\t\tpr_err(\"On-die ECC forcefully enabled, not supported\\n\");\n\t\tret = -EINVAL;\n\t\tgoto err_free_manuf_data;\n\t}\n\n\tif (chip->ecc.engine_type == NAND_ECC_ENGINE_TYPE_ON_DIE) {\n\t\tif (ondie == MICRON_ON_DIE_UNSUPPORTED) {\n\t\t\tpr_err(\"On-die ECC selected but not supported\\n\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto err_free_manuf_data;\n\t\t}\n\n\t\tif (ondie == MICRON_ON_DIE_MANDATORY) {\n\t\t\tmicron->ecc.forced = true;\n\t\t\tmicron->ecc.enabled = true;\n\t\t}\n\n\t\t \n\t\tif (requirements->strength == 4) {\n\t\t\tmicron->ecc.rawbuf = kmalloc(mtd->writesize +\n\t\t\t\t\t\t     mtd->oobsize,\n\t\t\t\t\t\t     GFP_KERNEL);\n\t\t\tif (!micron->ecc.rawbuf) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto err_free_manuf_data;\n\t\t\t}\n\t\t}\n\n\t\tif (requirements->strength == 4)\n\t\t\tmtd_set_ooblayout(mtd,\n\t\t\t\t\t  &micron_nand_on_die_4_ooblayout_ops);\n\t\telse\n\t\t\tmtd_set_ooblayout(mtd,\n\t\t\t\t\t  &micron_nand_on_die_8_ooblayout_ops);\n\n\t\tchip->ecc.bytes = requirements->strength * 2;\n\t\tchip->ecc.size = 512;\n\t\tchip->ecc.strength = requirements->strength;\n\t\tchip->ecc.algo = NAND_ECC_ALGO_BCH;\n\t\tchip->ecc.read_page = micron_nand_read_page_on_die_ecc;\n\t\tchip->ecc.write_page = micron_nand_write_page_on_die_ecc;\n\n\t\tif (ondie == MICRON_ON_DIE_MANDATORY) {\n\t\t\tchip->ecc.read_page_raw = nand_read_page_raw_notsupp;\n\t\t\tchip->ecc.write_page_raw = nand_write_page_raw_notsupp;\n\t\t} else {\n\t\t\tif (!chip->ecc.read_page_raw)\n\t\t\t\tchip->ecc.read_page_raw = nand_read_page_raw;\n\t\t\tif (!chip->ecc.write_page_raw)\n\t\t\t\tchip->ecc.write_page_raw = nand_write_page_raw;\n\t\t}\n\t}\n\n\treturn 0;\n\nerr_free_manuf_data:\n\tkfree(micron->ecc.rawbuf);\n\tkfree(micron);\n\n\treturn ret;\n}\n\nstatic void micron_nand_cleanup(struct nand_chip *chip)\n{\n\tstruct micron_nand *micron = nand_get_manufacturer_data(chip);\n\n\tkfree(micron->ecc.rawbuf);\n\tkfree(micron);\n}\n\nstatic void micron_fixup_onfi_param_page(struct nand_chip *chip,\n\t\t\t\t\t struct nand_onfi_params *p)\n{\n\t \n\tif (le16_to_cpu(p->revision) == 0)\n\t\tp->revision = cpu_to_le16(ONFI_VERSION_1_0);\n}\n\nconst struct nand_manufacturer_ops micron_nand_manuf_ops = {\n\t.init = micron_nand_init,\n\t.cleanup = micron_nand_cleanup,\n\t.fixup_onfi_param_page = micron_fixup_onfi_param_page,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}