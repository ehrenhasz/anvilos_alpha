{
  "module_name": "nand_legacy.c",
  "hash_id": "fe59b3565f9e8196e936a32c4e875eed8e19c248a67a2fce14944de4848fe587",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/nand/raw/nand_legacy.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/io.h>\n#include <linux/nmi.h>\n\n#include \"internals.h\"\n\n \nstatic uint8_t nand_read_byte(struct nand_chip *chip)\n{\n\treturn readb(chip->legacy.IO_ADDR_R);\n}\n\n \nstatic uint8_t nand_read_byte16(struct nand_chip *chip)\n{\n\treturn (uint8_t) cpu_to_le16(readw(chip->legacy.IO_ADDR_R));\n}\n\n \nstatic void nand_select_chip(struct nand_chip *chip, int chipnr)\n{\n\tswitch (chipnr) {\n\tcase -1:\n\t\tchip->legacy.cmd_ctrl(chip, NAND_CMD_NONE,\n\t\t\t\t      0 | NAND_CTRL_CHANGE);\n\t\tbreak;\n\tcase 0:\n\t\tbreak;\n\n\tdefault:\n\t\tBUG();\n\t}\n}\n\n \nstatic void nand_write_byte(struct nand_chip *chip, uint8_t byte)\n{\n\tchip->legacy.write_buf(chip, &byte, 1);\n}\n\n \nstatic void nand_write_byte16(struct nand_chip *chip, uint8_t byte)\n{\n\tuint16_t word = byte;\n\n\t \n\tchip->legacy.write_buf(chip, (uint8_t *)&word, 2);\n}\n\n \nstatic void nand_write_buf(struct nand_chip *chip, const uint8_t *buf, int len)\n{\n\tiowrite8_rep(chip->legacy.IO_ADDR_W, buf, len);\n}\n\n \nstatic void nand_read_buf(struct nand_chip *chip, uint8_t *buf, int len)\n{\n\tioread8_rep(chip->legacy.IO_ADDR_R, buf, len);\n}\n\n \nstatic void nand_write_buf16(struct nand_chip *chip, const uint8_t *buf,\n\t\t\t     int len)\n{\n\tu16 *p = (u16 *) buf;\n\n\tiowrite16_rep(chip->legacy.IO_ADDR_W, p, len >> 1);\n}\n\n \nstatic void nand_read_buf16(struct nand_chip *chip, uint8_t *buf, int len)\n{\n\tu16 *p = (u16 *) buf;\n\n\tioread16_rep(chip->legacy.IO_ADDR_R, p, len >> 1);\n}\n\n \nstatic void panic_nand_wait_ready(struct nand_chip *chip, unsigned long timeo)\n{\n\tint i;\n\n\t \n\tfor (i = 0; i < timeo; i++) {\n\t\tif (chip->legacy.dev_ready(chip))\n\t\t\tbreak;\n\t\ttouch_softlockup_watchdog();\n\t\tmdelay(1);\n\t}\n}\n\n \nvoid nand_wait_ready(struct nand_chip *chip)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tunsigned long timeo = 400;\n\n\tif (mtd->oops_panic_write)\n\t\treturn panic_nand_wait_ready(chip, timeo);\n\n\t \n\ttimeo = jiffies + msecs_to_jiffies(timeo);\n\tdo {\n\t\tif (chip->legacy.dev_ready(chip))\n\t\t\treturn;\n\t\tcond_resched();\n\t} while (time_before(jiffies, timeo));\n\n\tif (!chip->legacy.dev_ready(chip))\n\t\tpr_warn_ratelimited(\"timeout while waiting for chip to become ready\\n\");\n}\nEXPORT_SYMBOL_GPL(nand_wait_ready);\n\n \nstatic void nand_wait_status_ready(struct nand_chip *chip, unsigned long timeo)\n{\n\tint ret;\n\n\ttimeo = jiffies + msecs_to_jiffies(timeo);\n\tdo {\n\t\tu8 status;\n\n\t\tret = nand_read_data_op(chip, &status, sizeof(status), true,\n\t\t\t\t\tfalse);\n\t\tif (ret)\n\t\t\treturn;\n\n\t\tif (status & NAND_STATUS_READY)\n\t\t\tbreak;\n\t\ttouch_softlockup_watchdog();\n\t} while (time_before(jiffies, timeo));\n};\n\n \nstatic void nand_command(struct nand_chip *chip, unsigned int command,\n\t\t\t int column, int page_addr)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tint ctrl = NAND_CTRL_CLE | NAND_CTRL_CHANGE;\n\n\t \n\tif (command == NAND_CMD_SEQIN) {\n\t\tint readcmd;\n\n\t\tif (column >= mtd->writesize) {\n\t\t\t \n\t\t\tcolumn -= mtd->writesize;\n\t\t\treadcmd = NAND_CMD_READOOB;\n\t\t} else if (column < 256) {\n\t\t\t \n\t\t\treadcmd = NAND_CMD_READ0;\n\t\t} else {\n\t\t\tcolumn -= 256;\n\t\t\treadcmd = NAND_CMD_READ1;\n\t\t}\n\t\tchip->legacy.cmd_ctrl(chip, readcmd, ctrl);\n\t\tctrl &= ~NAND_CTRL_CHANGE;\n\t}\n\tif (command != NAND_CMD_NONE)\n\t\tchip->legacy.cmd_ctrl(chip, command, ctrl);\n\n\t \n\tctrl = NAND_CTRL_ALE | NAND_CTRL_CHANGE;\n\t \n\tif (column != -1) {\n\t\t \n\t\tif (chip->options & NAND_BUSWIDTH_16 &&\n\t\t\t\t!nand_opcode_8bits(command))\n\t\t\tcolumn >>= 1;\n\t\tchip->legacy.cmd_ctrl(chip, column, ctrl);\n\t\tctrl &= ~NAND_CTRL_CHANGE;\n\t}\n\tif (page_addr != -1) {\n\t\tchip->legacy.cmd_ctrl(chip, page_addr, ctrl);\n\t\tctrl &= ~NAND_CTRL_CHANGE;\n\t\tchip->legacy.cmd_ctrl(chip, page_addr >> 8, ctrl);\n\t\tif (chip->options & NAND_ROW_ADDR_3)\n\t\t\tchip->legacy.cmd_ctrl(chip, page_addr >> 16, ctrl);\n\t}\n\tchip->legacy.cmd_ctrl(chip, NAND_CMD_NONE,\n\t\t\t      NAND_NCE | NAND_CTRL_CHANGE);\n\n\t \n\tswitch (command) {\n\n\tcase NAND_CMD_NONE:\n\tcase NAND_CMD_PAGEPROG:\n\tcase NAND_CMD_ERASE1:\n\tcase NAND_CMD_ERASE2:\n\tcase NAND_CMD_SEQIN:\n\tcase NAND_CMD_STATUS:\n\tcase NAND_CMD_READID:\n\tcase NAND_CMD_SET_FEATURES:\n\t\treturn;\n\n\tcase NAND_CMD_RESET:\n\t\tif (chip->legacy.dev_ready)\n\t\t\tbreak;\n\t\tudelay(chip->legacy.chip_delay);\n\t\tchip->legacy.cmd_ctrl(chip, NAND_CMD_STATUS,\n\t\t\t\t      NAND_CTRL_CLE | NAND_CTRL_CHANGE);\n\t\tchip->legacy.cmd_ctrl(chip, NAND_CMD_NONE,\n\t\t\t\t      NAND_NCE | NAND_CTRL_CHANGE);\n\t\t \n\t\tnand_wait_status_ready(chip, 250);\n\t\treturn;\n\n\t\t \n\tcase NAND_CMD_READ0:\n\t\t \n\t\tif (column == -1 && page_addr == -1)\n\t\t\treturn;\n\t\tfallthrough;\n\tdefault:\n\t\t \n\t\tif (!chip->legacy.dev_ready) {\n\t\t\tudelay(chip->legacy.chip_delay);\n\t\t\treturn;\n\t\t}\n\t}\n\t \n\tndelay(100);\n\n\tnand_wait_ready(chip);\n}\n\nstatic void nand_ccs_delay(struct nand_chip *chip)\n{\n\tconst struct nand_sdr_timings *sdr =\n\t\tnand_get_sdr_timings(nand_get_interface_config(chip));\n\n\t \n\tif (!(chip->options & NAND_WAIT_TCCS))\n\t\treturn;\n\n\t \n\tif (!IS_ERR(sdr) && nand_controller_can_setup_interface(chip))\n\t\tndelay(sdr->tCCS_min / 1000);\n\telse\n\t\tndelay(500);\n}\n\n \nstatic void nand_command_lp(struct nand_chip *chip, unsigned int command,\n\t\t\t    int column, int page_addr)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\n\t \n\tif (command == NAND_CMD_READOOB) {\n\t\tcolumn += mtd->writesize;\n\t\tcommand = NAND_CMD_READ0;\n\t}\n\n\t \n\tif (command != NAND_CMD_NONE)\n\t\tchip->legacy.cmd_ctrl(chip, command,\n\t\t\t\t      NAND_NCE | NAND_CLE | NAND_CTRL_CHANGE);\n\n\tif (column != -1 || page_addr != -1) {\n\t\tint ctrl = NAND_CTRL_CHANGE | NAND_NCE | NAND_ALE;\n\n\t\t \n\t\tif (column != -1) {\n\t\t\t \n\t\t\tif (chip->options & NAND_BUSWIDTH_16 &&\n\t\t\t\t\t!nand_opcode_8bits(command))\n\t\t\t\tcolumn >>= 1;\n\t\t\tchip->legacy.cmd_ctrl(chip, column, ctrl);\n\t\t\tctrl &= ~NAND_CTRL_CHANGE;\n\n\t\t\t \n\t\t\tif (!nand_opcode_8bits(command))\n\t\t\t\tchip->legacy.cmd_ctrl(chip, column >> 8, ctrl);\n\t\t}\n\t\tif (page_addr != -1) {\n\t\t\tchip->legacy.cmd_ctrl(chip, page_addr, ctrl);\n\t\t\tchip->legacy.cmd_ctrl(chip, page_addr >> 8,\n\t\t\t\t\t     NAND_NCE | NAND_ALE);\n\t\t\tif (chip->options & NAND_ROW_ADDR_3)\n\t\t\t\tchip->legacy.cmd_ctrl(chip, page_addr >> 16,\n\t\t\t\t\t\t      NAND_NCE | NAND_ALE);\n\t\t}\n\t}\n\tchip->legacy.cmd_ctrl(chip, NAND_CMD_NONE,\n\t\t\t      NAND_NCE | NAND_CTRL_CHANGE);\n\n\t \n\tswitch (command) {\n\n\tcase NAND_CMD_NONE:\n\tcase NAND_CMD_CACHEDPROG:\n\tcase NAND_CMD_PAGEPROG:\n\tcase NAND_CMD_ERASE1:\n\tcase NAND_CMD_ERASE2:\n\tcase NAND_CMD_SEQIN:\n\tcase NAND_CMD_STATUS:\n\tcase NAND_CMD_READID:\n\tcase NAND_CMD_SET_FEATURES:\n\t\treturn;\n\n\tcase NAND_CMD_RNDIN:\n\t\tnand_ccs_delay(chip);\n\t\treturn;\n\n\tcase NAND_CMD_RESET:\n\t\tif (chip->legacy.dev_ready)\n\t\t\tbreak;\n\t\tudelay(chip->legacy.chip_delay);\n\t\tchip->legacy.cmd_ctrl(chip, NAND_CMD_STATUS,\n\t\t\t\t      NAND_NCE | NAND_CLE | NAND_CTRL_CHANGE);\n\t\tchip->legacy.cmd_ctrl(chip, NAND_CMD_NONE,\n\t\t\t\t      NAND_NCE | NAND_CTRL_CHANGE);\n\t\t \n\t\tnand_wait_status_ready(chip, 250);\n\t\treturn;\n\n\tcase NAND_CMD_RNDOUT:\n\t\t \n\t\tchip->legacy.cmd_ctrl(chip, NAND_CMD_RNDOUTSTART,\n\t\t\t\t      NAND_NCE | NAND_CLE | NAND_CTRL_CHANGE);\n\t\tchip->legacy.cmd_ctrl(chip, NAND_CMD_NONE,\n\t\t\t\t      NAND_NCE | NAND_CTRL_CHANGE);\n\n\t\tnand_ccs_delay(chip);\n\t\treturn;\n\n\tcase NAND_CMD_READ0:\n\t\t \n\t\tif (column == -1 && page_addr == -1)\n\t\t\treturn;\n\n\t\tchip->legacy.cmd_ctrl(chip, NAND_CMD_READSTART,\n\t\t\t\t      NAND_NCE | NAND_CLE | NAND_CTRL_CHANGE);\n\t\tchip->legacy.cmd_ctrl(chip, NAND_CMD_NONE,\n\t\t\t\t      NAND_NCE | NAND_CTRL_CHANGE);\n\t\tfallthrough;\t \n\tdefault:\n\t\t \n\t\tif (!chip->legacy.dev_ready) {\n\t\t\tudelay(chip->legacy.chip_delay);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t \n\tndelay(100);\n\n\tnand_wait_ready(chip);\n}\n\n \nint nand_get_set_features_notsupp(struct nand_chip *chip, int addr,\n\t\t\t\t  u8 *subfeature_param)\n{\n\treturn -ENOTSUPP;\n}\nEXPORT_SYMBOL(nand_get_set_features_notsupp);\n\n \nstatic int nand_wait(struct nand_chip *chip)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tunsigned long timeo = 400;\n\tu8 status;\n\tint ret;\n\n\t \n\tndelay(100);\n\n\tret = nand_status_op(chip, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\tif (mtd->oops_panic_write) {\n\t\tpanic_nand_wait(chip, timeo);\n\t} else {\n\t\ttimeo = jiffies + msecs_to_jiffies(timeo);\n\t\tdo {\n\t\t\tif (chip->legacy.dev_ready) {\n\t\t\t\tif (chip->legacy.dev_ready(chip))\n\t\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tret = nand_read_data_op(chip, &status,\n\t\t\t\t\t\t\tsizeof(status), true,\n\t\t\t\t\t\t\tfalse);\n\t\t\t\tif (ret)\n\t\t\t\t\treturn ret;\n\n\t\t\t\tif (status & NAND_STATUS_READY)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcond_resched();\n\t\t} while (time_before(jiffies, timeo));\n\t}\n\n\tret = nand_read_data_op(chip, &status, sizeof(status), true, false);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tWARN_ON(!(status & NAND_STATUS_READY));\n\treturn status;\n}\n\nvoid nand_legacy_set_defaults(struct nand_chip *chip)\n{\n\tunsigned int busw = chip->options & NAND_BUSWIDTH_16;\n\n\tif (nand_has_exec_op(chip))\n\t\treturn;\n\n\t \n\tif (!chip->legacy.chip_delay)\n\t\tchip->legacy.chip_delay = 20;\n\n\t \n\tif (!chip->legacy.cmdfunc)\n\t\tchip->legacy.cmdfunc = nand_command;\n\n\t \n\tif (chip->legacy.waitfunc == NULL)\n\t\tchip->legacy.waitfunc = nand_wait;\n\n\tif (!chip->legacy.select_chip)\n\t\tchip->legacy.select_chip = nand_select_chip;\n\n\t \n\tif (!chip->legacy.read_byte || chip->legacy.read_byte == nand_read_byte)\n\t\tchip->legacy.read_byte = busw ? nand_read_byte16 : nand_read_byte;\n\tif (!chip->legacy.write_buf || chip->legacy.write_buf == nand_write_buf)\n\t\tchip->legacy.write_buf = busw ? nand_write_buf16 : nand_write_buf;\n\tif (!chip->legacy.write_byte || chip->legacy.write_byte == nand_write_byte)\n\t\tchip->legacy.write_byte = busw ? nand_write_byte16 : nand_write_byte;\n\tif (!chip->legacy.read_buf || chip->legacy.read_buf == nand_read_buf)\n\t\tchip->legacy.read_buf = busw ? nand_read_buf16 : nand_read_buf;\n}\n\nvoid nand_legacy_adjust_cmdfunc(struct nand_chip *chip)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\n\t \n\tif (mtd->writesize > 512 && chip->legacy.cmdfunc == nand_command)\n\t\tchip->legacy.cmdfunc = nand_command_lp;\n}\n\nint nand_legacy_check_hooks(struct nand_chip *chip)\n{\n\t \n\tif (nand_has_exec_op(chip))\n\t\treturn 0;\n\n\t \n\tif ((!chip->legacy.cmdfunc || !chip->legacy.select_chip) &&\n\t    !chip->legacy.cmd_ctrl) {\n\t\tpr_err(\"->legacy.cmd_ctrl() should be provided\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}