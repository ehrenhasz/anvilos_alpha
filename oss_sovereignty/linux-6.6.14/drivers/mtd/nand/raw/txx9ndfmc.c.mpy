{
  "module_name": "txx9ndfmc.c",
  "hash_id": "3c92dc2c66d270b5a1fe82287bdfc41d165fd8a4d033d261ed9743c7c46674ea",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/nand/raw/txx9ndfmc.c",
  "human_readable_source": "\n \n#include <linux/err.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/delay.h>\n#include <linux/mtd/mtd.h>\n#include <linux/mtd/rawnand.h>\n#include <linux/mtd/partitions.h>\n#include <linux/io.h>\n#include <linux/platform_data/txx9/ndfmc.h>\n\n \n#define TXX9_NDFDTR\t0x00\n#define TXX9_NDFMCR\t0x04\n#define TXX9_NDFSR\t0x08\n#define TXX9_NDFISR\t0x0c\n#define TXX9_NDFIMR\t0x10\n#define TXX9_NDFSPR\t0x14\n#define TXX9_NDFRSTR\t0x18\t \n\n \n#define TXX9_NDFMCR_WE\t0x80\n#define TXX9_NDFMCR_ECC_ALL\t0x60\n#define TXX9_NDFMCR_ECC_RESET\t0x60\n#define TXX9_NDFMCR_ECC_READ\t0x40\n#define TXX9_NDFMCR_ECC_ON\t0x20\n#define TXX9_NDFMCR_ECC_OFF\t0x00\n#define TXX9_NDFMCR_CE\t0x10\n#define TXX9_NDFMCR_BSPRT\t0x04\t \n#define TXX9_NDFMCR_ALE\t0x02\n#define TXX9_NDFMCR_CLE\t0x01\n \n#define TXX9_NDFMCR_X16\t0x0400\n#define TXX9_NDFMCR_DMAREQ_MASK\t0x0300\n#define TXX9_NDFMCR_DMAREQ_NODMA\t0x0000\n#define TXX9_NDFMCR_DMAREQ_128\t0x0100\n#define TXX9_NDFMCR_DMAREQ_256\t0x0200\n#define TXX9_NDFMCR_DMAREQ_512\t0x0300\n#define TXX9_NDFMCR_CS_MASK\t0x0c\n#define TXX9_NDFMCR_CS(ch)\t((ch) << 2)\n\n \n#define TXX9_NDFSR_BUSY\t0x80\n \n#define TXX9_NDFSR_DMARUN\t0x40\n\n \n#define TXX9_NDFRSTR_RST\t0x01\n\nstruct txx9ndfmc_priv {\n\tstruct platform_device *dev;\n\tstruct nand_chip chip;\n\tint cs;\n\tconst char *mtdname;\n};\n\n#define MAX_TXX9NDFMC_DEV\t4\nstruct txx9ndfmc_drvdata {\n\tstruct mtd_info *mtds[MAX_TXX9NDFMC_DEV];\n\tvoid __iomem *base;\n\tunsigned char hold;\t \n\tunsigned char spw;\t \n\tstruct nand_controller controller;\n};\n\nstatic struct platform_device *mtd_to_platdev(struct mtd_info *mtd)\n{\n\tstruct nand_chip *chip = mtd_to_nand(mtd);\n\tstruct txx9ndfmc_priv *txx9_priv = nand_get_controller_data(chip);\n\treturn txx9_priv->dev;\n}\n\nstatic void __iomem *ndregaddr(struct platform_device *dev, unsigned int reg)\n{\n\tstruct txx9ndfmc_drvdata *drvdata = platform_get_drvdata(dev);\n\tstruct txx9ndfmc_platform_data *plat = dev_get_platdata(&dev->dev);\n\n\treturn drvdata->base + (reg << plat->shift);\n}\n\nstatic u32 txx9ndfmc_read(struct platform_device *dev, unsigned int reg)\n{\n\treturn __raw_readl(ndregaddr(dev, reg));\n}\n\nstatic void txx9ndfmc_write(struct platform_device *dev,\n\t\t\t    u32 val, unsigned int reg)\n{\n\t__raw_writel(val, ndregaddr(dev, reg));\n}\n\nstatic uint8_t txx9ndfmc_read_byte(struct nand_chip *chip)\n{\n\tstruct platform_device *dev = mtd_to_platdev(nand_to_mtd(chip));\n\n\treturn txx9ndfmc_read(dev, TXX9_NDFDTR);\n}\n\nstatic void txx9ndfmc_write_buf(struct nand_chip *chip, const uint8_t *buf,\n\t\t\t\tint len)\n{\n\tstruct platform_device *dev = mtd_to_platdev(nand_to_mtd(chip));\n\tvoid __iomem *ndfdtr = ndregaddr(dev, TXX9_NDFDTR);\n\tu32 mcr = txx9ndfmc_read(dev, TXX9_NDFMCR);\n\n\ttxx9ndfmc_write(dev, mcr | TXX9_NDFMCR_WE, TXX9_NDFMCR);\n\twhile (len--)\n\t\t__raw_writel(*buf++, ndfdtr);\n\ttxx9ndfmc_write(dev, mcr, TXX9_NDFMCR);\n}\n\nstatic void txx9ndfmc_read_buf(struct nand_chip *chip, uint8_t *buf, int len)\n{\n\tstruct platform_device *dev = mtd_to_platdev(nand_to_mtd(chip));\n\tvoid __iomem *ndfdtr = ndregaddr(dev, TXX9_NDFDTR);\n\n\twhile (len--)\n\t\t*buf++ = __raw_readl(ndfdtr);\n}\n\nstatic void txx9ndfmc_cmd_ctrl(struct nand_chip *chip, int cmd,\n\t\t\t       unsigned int ctrl)\n{\n\tstruct txx9ndfmc_priv *txx9_priv = nand_get_controller_data(chip);\n\tstruct platform_device *dev = txx9_priv->dev;\n\tstruct txx9ndfmc_platform_data *plat = dev_get_platdata(&dev->dev);\n\n\tif (ctrl & NAND_CTRL_CHANGE) {\n\t\tu32 mcr = txx9ndfmc_read(dev, TXX9_NDFMCR);\n\n\t\tmcr &= ~(TXX9_NDFMCR_CLE | TXX9_NDFMCR_ALE | TXX9_NDFMCR_CE);\n\t\tmcr |= ctrl & NAND_CLE ? TXX9_NDFMCR_CLE : 0;\n\t\tmcr |= ctrl & NAND_ALE ? TXX9_NDFMCR_ALE : 0;\n\t\t \n\t\tmcr |= ctrl & NAND_NCE ? TXX9_NDFMCR_CE : 0;\n\t\tif (txx9_priv->cs >= 0 && (ctrl & NAND_NCE)) {\n\t\t\tmcr &= ~TXX9_NDFMCR_CS_MASK;\n\t\t\tmcr |= TXX9_NDFMCR_CS(txx9_priv->cs);\n\t\t}\n\t\ttxx9ndfmc_write(dev, mcr, TXX9_NDFMCR);\n\t}\n\tif (cmd != NAND_CMD_NONE)\n\t\ttxx9ndfmc_write(dev, cmd & 0xff, TXX9_NDFDTR);\n\tif (plat->flags & NDFMC_PLAT_FLAG_DUMMYWRITE) {\n\t\t \n\t\tif ((ctrl & NAND_CTRL_CHANGE) && cmd == NAND_CMD_NONE)\n\t\t\ttxx9ndfmc_write(dev, 0, TXX9_NDFDTR);\n\t}\n}\n\nstatic int txx9ndfmc_dev_ready(struct nand_chip *chip)\n{\n\tstruct platform_device *dev = mtd_to_platdev(nand_to_mtd(chip));\n\n\treturn !(txx9ndfmc_read(dev, TXX9_NDFSR) & TXX9_NDFSR_BUSY);\n}\n\nstatic int txx9ndfmc_calculate_ecc(struct nand_chip *chip, const uint8_t *dat,\n\t\t\t\t   uint8_t *ecc_code)\n{\n\tstruct platform_device *dev = mtd_to_platdev(nand_to_mtd(chip));\n\tint eccbytes;\n\tu32 mcr = txx9ndfmc_read(dev, TXX9_NDFMCR);\n\n\tmcr &= ~TXX9_NDFMCR_ECC_ALL;\n\ttxx9ndfmc_write(dev, mcr | TXX9_NDFMCR_ECC_OFF, TXX9_NDFMCR);\n\ttxx9ndfmc_write(dev, mcr | TXX9_NDFMCR_ECC_READ, TXX9_NDFMCR);\n\tfor (eccbytes = chip->ecc.bytes; eccbytes > 0; eccbytes -= 3) {\n\t\tecc_code[1] = txx9ndfmc_read(dev, TXX9_NDFDTR);\n\t\tecc_code[0] = txx9ndfmc_read(dev, TXX9_NDFDTR);\n\t\tecc_code[2] = txx9ndfmc_read(dev, TXX9_NDFDTR);\n\t\tecc_code += 3;\n\t}\n\ttxx9ndfmc_write(dev, mcr | TXX9_NDFMCR_ECC_OFF, TXX9_NDFMCR);\n\treturn 0;\n}\n\nstatic int txx9ndfmc_correct_data(struct nand_chip *chip, unsigned char *buf,\n\t\t\t\t  unsigned char *read_ecc,\n\t\t\t\t  unsigned char *calc_ecc)\n{\n\tint eccsize;\n\tint corrected = 0;\n\tint stat;\n\n\tfor (eccsize = chip->ecc.size; eccsize > 0; eccsize -= 256) {\n\t\tstat = rawnand_sw_hamming_correct(chip, buf, read_ecc,\n\t\t\t\t\t\t  calc_ecc);\n\t\tif (stat < 0)\n\t\t\treturn stat;\n\t\tcorrected += stat;\n\t\tbuf += 256;\n\t\tread_ecc += 3;\n\t\tcalc_ecc += 3;\n\t}\n\treturn corrected;\n}\n\nstatic void txx9ndfmc_enable_hwecc(struct nand_chip *chip, int mode)\n{\n\tstruct platform_device *dev = mtd_to_platdev(nand_to_mtd(chip));\n\tu32 mcr = txx9ndfmc_read(dev, TXX9_NDFMCR);\n\n\tmcr &= ~TXX9_NDFMCR_ECC_ALL;\n\ttxx9ndfmc_write(dev, mcr | TXX9_NDFMCR_ECC_RESET, TXX9_NDFMCR);\n\ttxx9ndfmc_write(dev, mcr | TXX9_NDFMCR_ECC_OFF, TXX9_NDFMCR);\n\ttxx9ndfmc_write(dev, mcr | TXX9_NDFMCR_ECC_ON, TXX9_NDFMCR);\n}\n\nstatic void txx9ndfmc_initialize(struct platform_device *dev)\n{\n\tstruct txx9ndfmc_platform_data *plat = dev_get_platdata(&dev->dev);\n\tstruct txx9ndfmc_drvdata *drvdata = platform_get_drvdata(dev);\n\tint tmout = 100;\n\n\tif (plat->flags & NDFMC_PLAT_FLAG_NO_RSTR)\n\t\t;  \n\telse {\n\t\t \n\t\ttxx9ndfmc_write(dev,\n\t\t\t\ttxx9ndfmc_read(dev, TXX9_NDFRSTR) |\n\t\t\t\tTXX9_NDFRSTR_RST,\n\t\t\t\tTXX9_NDFRSTR);\n\t\twhile (txx9ndfmc_read(dev, TXX9_NDFRSTR) & TXX9_NDFRSTR_RST) {\n\t\t\tif (--tmout == 0) {\n\t\t\t\tdev_err(&dev->dev, \"reset failed.\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tudelay(1);\n\t\t}\n\t}\n\t \n\ttxx9ndfmc_write(dev, (drvdata->hold << 4) | drvdata->spw, TXX9_NDFSPR);\n\ttxx9ndfmc_write(dev,\n\t\t\t(plat->flags & NDFMC_PLAT_FLAG_USE_BSPRT) ?\n\t\t\tTXX9_NDFMCR_BSPRT : 0, TXX9_NDFMCR);\n}\n\n#define TXX9NDFMC_NS_TO_CYC(gbusclk, ns) \\\n\tDIV_ROUND_UP((ns) * DIV_ROUND_UP(gbusclk, 1000), 1000000)\n\nstatic int txx9ndfmc_attach_chip(struct nand_chip *chip)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\n\tif (chip->ecc.engine_type != NAND_ECC_ENGINE_TYPE_ON_HOST)\n\t\treturn 0;\n\n\tchip->ecc.strength = 1;\n\n\tif (mtd->writesize >= 512) {\n\t\tchip->ecc.size = 512;\n\t\tchip->ecc.bytes = 6;\n\t} else {\n\t\tchip->ecc.size = 256;\n\t\tchip->ecc.bytes = 3;\n\t}\n\n\tchip->ecc.calculate = txx9ndfmc_calculate_ecc;\n\tchip->ecc.correct = txx9ndfmc_correct_data;\n\tchip->ecc.hwctl = txx9ndfmc_enable_hwecc;\n\n\treturn 0;\n}\n\nstatic const struct nand_controller_ops txx9ndfmc_controller_ops = {\n\t.attach_chip = txx9ndfmc_attach_chip,\n};\n\nstatic int __init txx9ndfmc_probe(struct platform_device *dev)\n{\n\tstruct txx9ndfmc_platform_data *plat = dev_get_platdata(&dev->dev);\n\tint hold, spw;\n\tint i;\n\tstruct txx9ndfmc_drvdata *drvdata;\n\tunsigned long gbusclk = plat->gbus_clock;\n\n\tdrvdata = devm_kzalloc(&dev->dev, sizeof(*drvdata), GFP_KERNEL);\n\tif (!drvdata)\n\t\treturn -ENOMEM;\n\tdrvdata->base = devm_platform_ioremap_resource(dev, 0);\n\tif (IS_ERR(drvdata->base))\n\t\treturn PTR_ERR(drvdata->base);\n\n\thold = plat->hold ?: 20;  \n\tspw = plat->spw ?: 90;  \n\n\thold = TXX9NDFMC_NS_TO_CYC(gbusclk, hold);\n\tspw = TXX9NDFMC_NS_TO_CYC(gbusclk, spw);\n\tif (plat->flags & NDFMC_PLAT_FLAG_HOLDADD)\n\t\thold -= 2;\t \n\tspw -= 1;\t \n\thold = clamp(hold, 1, 15);\n\tdrvdata->hold = hold;\n\tspw = clamp(spw, 1, 15);\n\tdrvdata->spw = spw;\n\tdev_info(&dev->dev, \"CLK:%ldMHz HOLD:%d SPW:%d\\n\",\n\t\t (gbusclk + 500000) / 1000000, hold, spw);\n\n\tnand_controller_init(&drvdata->controller);\n\tdrvdata->controller.ops = &txx9ndfmc_controller_ops;\n\n\tplatform_set_drvdata(dev, drvdata);\n\ttxx9ndfmc_initialize(dev);\n\n\tfor (i = 0; i < MAX_TXX9NDFMC_DEV; i++) {\n\t\tstruct txx9ndfmc_priv *txx9_priv;\n\t\tstruct nand_chip *chip;\n\t\tstruct mtd_info *mtd;\n\n\t\tif (!(plat->ch_mask & (1 << i)))\n\t\t\tcontinue;\n\t\ttxx9_priv = kzalloc(sizeof(struct txx9ndfmc_priv),\n\t\t\t\t    GFP_KERNEL);\n\t\tif (!txx9_priv)\n\t\t\tcontinue;\n\t\tchip = &txx9_priv->chip;\n\t\tmtd = nand_to_mtd(chip);\n\t\tmtd->dev.parent = &dev->dev;\n\n\t\tchip->legacy.read_byte = txx9ndfmc_read_byte;\n\t\tchip->legacy.read_buf = txx9ndfmc_read_buf;\n\t\tchip->legacy.write_buf = txx9ndfmc_write_buf;\n\t\tchip->legacy.cmd_ctrl = txx9ndfmc_cmd_ctrl;\n\t\tchip->legacy.dev_ready = txx9ndfmc_dev_ready;\n\t\tchip->legacy.chip_delay = 100;\n\t\tchip->controller = &drvdata->controller;\n\n\t\tnand_set_controller_data(chip, txx9_priv);\n\t\ttxx9_priv->dev = dev;\n\n\t\tif (plat->ch_mask != 1) {\n\t\t\ttxx9_priv->cs = i;\n\t\t\ttxx9_priv->mtdname = kasprintf(GFP_KERNEL, \"%s.%u\",\n\t\t\t\t\t\t       dev_name(&dev->dev), i);\n\t\t} else {\n\t\t\ttxx9_priv->cs = -1;\n\t\t\ttxx9_priv->mtdname = kstrdup(dev_name(&dev->dev),\n\t\t\t\t\t\t     GFP_KERNEL);\n\t\t}\n\t\tif (!txx9_priv->mtdname) {\n\t\t\tkfree(txx9_priv);\n\t\t\tdev_err(&dev->dev, \"Unable to allocate MTD name.\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tif (plat->wide_mask & (1 << i))\n\t\t\tchip->options |= NAND_BUSWIDTH_16;\n\n\t\tif (nand_scan(chip, 1)) {\n\t\t\tkfree(txx9_priv->mtdname);\n\t\t\tkfree(txx9_priv);\n\t\t\tcontinue;\n\t\t}\n\t\tmtd->name = txx9_priv->mtdname;\n\n\t\tmtd_device_register(mtd, NULL, 0);\n\t\tdrvdata->mtds[i] = mtd;\n\t}\n\n\treturn 0;\n}\n\nstatic int __exit txx9ndfmc_remove(struct platform_device *dev)\n{\n\tstruct txx9ndfmc_drvdata *drvdata = platform_get_drvdata(dev);\n\tint ret, i;\n\n\tif (!drvdata)\n\t\treturn 0;\n\tfor (i = 0; i < MAX_TXX9NDFMC_DEV; i++) {\n\t\tstruct mtd_info *mtd = drvdata->mtds[i];\n\t\tstruct nand_chip *chip;\n\t\tstruct txx9ndfmc_priv *txx9_priv;\n\n\t\tif (!mtd)\n\t\t\tcontinue;\n\t\tchip = mtd_to_nand(mtd);\n\t\ttxx9_priv = nand_get_controller_data(chip);\n\n\t\tret = mtd_device_unregister(nand_to_mtd(chip));\n\t\tWARN_ON(ret);\n\t\tnand_cleanup(chip);\n\t\tkfree(txx9_priv->mtdname);\n\t\tkfree(txx9_priv);\n\t}\n\treturn 0;\n}\n\n#ifdef CONFIG_PM\nstatic int txx9ndfmc_resume(struct platform_device *dev)\n{\n\tif (platform_get_drvdata(dev))\n\t\ttxx9ndfmc_initialize(dev);\n\treturn 0;\n}\n#else\n#define txx9ndfmc_resume NULL\n#endif\n\nstatic struct platform_driver txx9ndfmc_driver = {\n\t.remove\t\t= __exit_p(txx9ndfmc_remove),\n\t.resume\t\t= txx9ndfmc_resume,\n\t.driver\t\t= {\n\t\t.name\t= \"txx9ndfmc\",\n\t},\n};\n\nmodule_platform_driver_probe(txx9ndfmc_driver, txx9ndfmc_probe);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"TXx9 SoC NAND flash controller driver\");\nMODULE_ALIAS(\"platform:txx9ndfmc\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}