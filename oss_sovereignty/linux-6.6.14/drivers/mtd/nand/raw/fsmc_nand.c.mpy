{
  "module_name": "fsmc_nand.c",
  "hash_id": "1ed31adcb0cd262787af25e7f5b60311faeb8318daf5f11eb792d08e041dd994",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/nand/raw/fsmc_nand.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/dmaengine.h>\n#include <linux/dma-direction.h>\n#include <linux/dma-mapping.h>\n#include <linux/err.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/mtd/mtd.h>\n#include <linux/mtd/nand-ecc-sw-hamming.h>\n#include <linux/mtd/rawnand.h>\n#include <linux/platform_device.h>\n#include <linux/of.h>\n#include <linux/mtd/partitions.h>\n#include <linux/io.h>\n#include <linux/slab.h>\n#include <linux/amba/bus.h>\n#include <mtd/mtd-abi.h>\n\n \n#define CTRL\t\t\t0x0\n\t \n\t#define BANK_ENABLE\t\tBIT(0)\n\t#define MUXED\t\t\tBIT(1)\n\t#define NOR_DEV\t\t\t(2 << 2)\n\t#define WIDTH_16\t\tBIT(4)\n\t#define RSTPWRDWN\t\tBIT(6)\n\t#define WPROT\t\t\tBIT(7)\n\t#define WRT_ENABLE\t\tBIT(12)\n\t#define WAIT_ENB\t\tBIT(13)\n\n#define CTRL_TIM\t\t0x4\n\t \n\n#define FSMC_NOR_BANK_SZ\t0x8\n#define FSMC_NOR_REG_SIZE\t0x40\n\n#define FSMC_NOR_REG(base, bank, reg)\t((base) +\t\t\t\\\n\t\t\t\t\t (FSMC_NOR_BANK_SZ * (bank)) +\t\\\n\t\t\t\t\t (reg))\n\n \n#define FSMC_PC\t\t\t0x00\n\t \n\t#define FSMC_RESET\t\tBIT(0)\n\t#define FSMC_WAITON\t\tBIT(1)\n\t#define FSMC_ENABLE\t\tBIT(2)\n\t#define FSMC_DEVTYPE_NAND\tBIT(3)\n\t#define FSMC_DEVWID_16\t\tBIT(4)\n\t#define FSMC_ECCEN\t\tBIT(6)\n\t#define FSMC_ECCPLEN_256\tBIT(7)\n\t#define FSMC_TCLR_SHIFT\t\t(9)\n\t#define FSMC_TCLR_MASK\t\t(0xF)\n\t#define FSMC_TAR_SHIFT\t\t(13)\n\t#define FSMC_TAR_MASK\t\t(0xF)\n#define STS\t\t\t0x04\n\t \n\t#define FSMC_CODE_RDY\t\tBIT(15)\n#define COMM\t\t\t0x08\n\t \n\t#define FSMC_TSET_SHIFT\t\t0\n\t#define FSMC_TSET_MASK\t\t0xFF\n\t#define FSMC_TWAIT_SHIFT\t8\n\t#define FSMC_TWAIT_MASK\t\t0xFF\n\t#define FSMC_THOLD_SHIFT\t16\n\t#define FSMC_THOLD_MASK\t\t0xFF\n\t#define FSMC_THIZ_SHIFT\t\t24\n\t#define FSMC_THIZ_MASK\t\t0xFF\n#define ATTRIB\t\t\t0x0C\n#define IOATA\t\t\t0x10\n#define ECC1\t\t\t0x14\n#define ECC2\t\t\t0x18\n#define ECC3\t\t\t0x1C\n#define FSMC_NAND_BANK_SZ\t0x20\n\n#define FSMC_BUSY_WAIT_TIMEOUT\t(1 * HZ)\n\n \n#define TOUTDEL\t7000\n#define TINDEL\t5000\n\nstruct fsmc_nand_timings {\n\tu8 tclr;\n\tu8 tar;\n\tu8 thiz;\n\tu8 thold;\n\tu8 twait;\n\tu8 tset;\n};\n\nenum access_mode {\n\tUSE_DMA_ACCESS = 1,\n\tUSE_WORD_ACCESS,\n};\n\n \nstruct fsmc_nand_data {\n\tstruct nand_controller\tbase;\n\tu32\t\t\tpid;\n\tstruct nand_chip\tnand;\n\n\tunsigned int\t\tbank;\n\tstruct device\t\t*dev;\n\tenum access_mode\tmode;\n\tstruct clk\t\t*clk;\n\n\t \n\tstruct dma_chan\t\t*read_dma_chan;\n\tstruct dma_chan\t\t*write_dma_chan;\n\tstruct completion\tdma_access_complete;\n\n\tstruct fsmc_nand_timings *dev_timings;\n\n\tdma_addr_t\t\tdata_pa;\n\tvoid __iomem\t\t*data_va;\n\tvoid __iomem\t\t*cmd_va;\n\tvoid __iomem\t\t*addr_va;\n\tvoid __iomem\t\t*regs_va;\n};\n\nstatic int fsmc_ecc1_ooblayout_ecc(struct mtd_info *mtd, int section,\n\t\t\t\t   struct mtd_oob_region *oobregion)\n{\n\tstruct nand_chip *chip = mtd_to_nand(mtd);\n\n\tif (section >= chip->ecc.steps)\n\t\treturn -ERANGE;\n\n\toobregion->offset = (section * 16) + 2;\n\toobregion->length = 3;\n\n\treturn 0;\n}\n\nstatic int fsmc_ecc1_ooblayout_free(struct mtd_info *mtd, int section,\n\t\t\t\t    struct mtd_oob_region *oobregion)\n{\n\tstruct nand_chip *chip = mtd_to_nand(mtd);\n\n\tif (section >= chip->ecc.steps)\n\t\treturn -ERANGE;\n\n\toobregion->offset = (section * 16) + 8;\n\n\tif (section < chip->ecc.steps - 1)\n\t\toobregion->length = 8;\n\telse\n\t\toobregion->length = mtd->oobsize - oobregion->offset;\n\n\treturn 0;\n}\n\nstatic const struct mtd_ooblayout_ops fsmc_ecc1_ooblayout_ops = {\n\t.ecc = fsmc_ecc1_ooblayout_ecc,\n\t.free = fsmc_ecc1_ooblayout_free,\n};\n\n \nstatic int fsmc_ecc4_ooblayout_ecc(struct mtd_info *mtd, int section,\n\t\t\t\t   struct mtd_oob_region *oobregion)\n{\n\tstruct nand_chip *chip = mtd_to_nand(mtd);\n\n\tif (section >= chip->ecc.steps)\n\t\treturn -ERANGE;\n\n\toobregion->length = chip->ecc.bytes;\n\n\tif (!section && mtd->writesize <= 512)\n\t\toobregion->offset = 0;\n\telse\n\t\toobregion->offset = (section * 16) + 2;\n\n\treturn 0;\n}\n\nstatic int fsmc_ecc4_ooblayout_free(struct mtd_info *mtd, int section,\n\t\t\t\t    struct mtd_oob_region *oobregion)\n{\n\tstruct nand_chip *chip = mtd_to_nand(mtd);\n\n\tif (section >= chip->ecc.steps)\n\t\treturn -ERANGE;\n\n\toobregion->offset = (section * 16) + 15;\n\n\tif (section < chip->ecc.steps - 1)\n\t\toobregion->length = 3;\n\telse\n\t\toobregion->length = mtd->oobsize - oobregion->offset;\n\n\treturn 0;\n}\n\nstatic const struct mtd_ooblayout_ops fsmc_ecc4_ooblayout_ops = {\n\t.ecc = fsmc_ecc4_ooblayout_ecc,\n\t.free = fsmc_ecc4_ooblayout_free,\n};\n\nstatic inline struct fsmc_nand_data *nand_to_fsmc(struct nand_chip *chip)\n{\n\treturn container_of(chip, struct fsmc_nand_data, nand);\n}\n\n \nstatic void fsmc_nand_setup(struct fsmc_nand_data *host,\n\t\t\t    struct fsmc_nand_timings *tims)\n{\n\tu32 value = FSMC_DEVTYPE_NAND | FSMC_ENABLE | FSMC_WAITON;\n\tu32 tclr, tar, thiz, thold, twait, tset;\n\n\ttclr = (tims->tclr & FSMC_TCLR_MASK) << FSMC_TCLR_SHIFT;\n\ttar = (tims->tar & FSMC_TAR_MASK) << FSMC_TAR_SHIFT;\n\tthiz = (tims->thiz & FSMC_THIZ_MASK) << FSMC_THIZ_SHIFT;\n\tthold = (tims->thold & FSMC_THOLD_MASK) << FSMC_THOLD_SHIFT;\n\ttwait = (tims->twait & FSMC_TWAIT_MASK) << FSMC_TWAIT_SHIFT;\n\ttset = (tims->tset & FSMC_TSET_MASK) << FSMC_TSET_SHIFT;\n\n\tif (host->nand.options & NAND_BUSWIDTH_16)\n\t\tvalue |= FSMC_DEVWID_16;\n\n\twritel_relaxed(value | tclr | tar, host->regs_va + FSMC_PC);\n\twritel_relaxed(thiz | thold | twait | tset, host->regs_va + COMM);\n\twritel_relaxed(thiz | thold | twait | tset, host->regs_va + ATTRIB);\n}\n\nstatic int fsmc_calc_timings(struct fsmc_nand_data *host,\n\t\t\t     const struct nand_sdr_timings *sdrt,\n\t\t\t     struct fsmc_nand_timings *tims)\n{\n\tunsigned long hclk = clk_get_rate(host->clk);\n\tunsigned long hclkn = NSEC_PER_SEC / hclk;\n\tu32 thiz, thold, twait, tset, twait_min;\n\n\tif (sdrt->tRC_min < 30000)\n\t\treturn -EOPNOTSUPP;\n\n\ttims->tar = DIV_ROUND_UP(sdrt->tAR_min / 1000, hclkn) - 1;\n\tif (tims->tar > FSMC_TAR_MASK)\n\t\ttims->tar = FSMC_TAR_MASK;\n\ttims->tclr = DIV_ROUND_UP(sdrt->tCLR_min / 1000, hclkn) - 1;\n\tif (tims->tclr > FSMC_TCLR_MASK)\n\t\ttims->tclr = FSMC_TCLR_MASK;\n\n\tthiz = sdrt->tCS_min - sdrt->tWP_min;\n\ttims->thiz = DIV_ROUND_UP(thiz / 1000, hclkn);\n\n\tthold = sdrt->tDH_min;\n\tif (thold < sdrt->tCH_min)\n\t\tthold = sdrt->tCH_min;\n\tif (thold < sdrt->tCLH_min)\n\t\tthold = sdrt->tCLH_min;\n\tif (thold < sdrt->tWH_min)\n\t\tthold = sdrt->tWH_min;\n\tif (thold < sdrt->tALH_min)\n\t\tthold = sdrt->tALH_min;\n\tif (thold < sdrt->tREH_min)\n\t\tthold = sdrt->tREH_min;\n\ttims->thold = DIV_ROUND_UP(thold / 1000, hclkn);\n\tif (tims->thold == 0)\n\t\ttims->thold = 1;\n\telse if (tims->thold > FSMC_THOLD_MASK)\n\t\ttims->thold = FSMC_THOLD_MASK;\n\n\ttset = max(sdrt->tCS_min - sdrt->tWP_min,\n\t\t   sdrt->tCEA_max - sdrt->tREA_max);\n\ttims->tset = DIV_ROUND_UP(tset / 1000, hclkn) - 1;\n\tif (tims->tset == 0)\n\t\ttims->tset = 1;\n\telse if (tims->tset > FSMC_TSET_MASK)\n\t\ttims->tset = FSMC_TSET_MASK;\n\n\t \n\ttwait_min = sdrt->tCEA_max - ((tims->tset + 1) * hclkn * 1000)\n\t\t    + TOUTDEL + TINDEL;\n\ttwait = max3(sdrt->tRP_min, sdrt->tWP_min, twait_min);\n\n\ttims->twait = DIV_ROUND_UP(twait / 1000, hclkn) - 1;\n\tif (tims->twait == 0)\n\t\ttims->twait = 1;\n\telse if (tims->twait > FSMC_TWAIT_MASK)\n\t\ttims->twait = FSMC_TWAIT_MASK;\n\n\treturn 0;\n}\n\nstatic int fsmc_setup_interface(struct nand_chip *nand, int csline,\n\t\t\t\tconst struct nand_interface_config *conf)\n{\n\tstruct fsmc_nand_data *host = nand_to_fsmc(nand);\n\tstruct fsmc_nand_timings tims;\n\tconst struct nand_sdr_timings *sdrt;\n\tint ret;\n\n\tsdrt = nand_get_sdr_timings(conf);\n\tif (IS_ERR(sdrt))\n\t\treturn PTR_ERR(sdrt);\n\n\tret = fsmc_calc_timings(host, sdrt, &tims);\n\tif (ret)\n\t\treturn ret;\n\n\tif (csline == NAND_DATA_IFACE_CHECK_ONLY)\n\t\treturn 0;\n\n\tfsmc_nand_setup(host, &tims);\n\n\treturn 0;\n}\n\n \nstatic void fsmc_enable_hwecc(struct nand_chip *chip, int mode)\n{\n\tstruct fsmc_nand_data *host = nand_to_fsmc(chip);\n\n\twritel_relaxed(readl(host->regs_va + FSMC_PC) & ~FSMC_ECCPLEN_256,\n\t\t       host->regs_va + FSMC_PC);\n\twritel_relaxed(readl(host->regs_va + FSMC_PC) & ~FSMC_ECCEN,\n\t\t       host->regs_va + FSMC_PC);\n\twritel_relaxed(readl(host->regs_va + FSMC_PC) | FSMC_ECCEN,\n\t\t       host->regs_va + FSMC_PC);\n}\n\n \nstatic int fsmc_read_hwecc_ecc4(struct nand_chip *chip, const u8 *data,\n\t\t\t\tu8 *ecc)\n{\n\tstruct fsmc_nand_data *host = nand_to_fsmc(chip);\n\tu32 ecc_tmp;\n\tunsigned long deadline = jiffies + FSMC_BUSY_WAIT_TIMEOUT;\n\n\tdo {\n\t\tif (readl_relaxed(host->regs_va + STS) & FSMC_CODE_RDY)\n\t\t\tbreak;\n\n\t\tcond_resched();\n\t} while (!time_after_eq(jiffies, deadline));\n\n\tif (time_after_eq(jiffies, deadline)) {\n\t\tdev_err(host->dev, \"calculate ecc timed out\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\tecc_tmp = readl_relaxed(host->regs_va + ECC1);\n\tecc[0] = ecc_tmp;\n\tecc[1] = ecc_tmp >> 8;\n\tecc[2] = ecc_tmp >> 16;\n\tecc[3] = ecc_tmp >> 24;\n\n\tecc_tmp = readl_relaxed(host->regs_va + ECC2);\n\tecc[4] = ecc_tmp;\n\tecc[5] = ecc_tmp >> 8;\n\tecc[6] = ecc_tmp >> 16;\n\tecc[7] = ecc_tmp >> 24;\n\n\tecc_tmp = readl_relaxed(host->regs_va + ECC3);\n\tecc[8] = ecc_tmp;\n\tecc[9] = ecc_tmp >> 8;\n\tecc[10] = ecc_tmp >> 16;\n\tecc[11] = ecc_tmp >> 24;\n\n\tecc_tmp = readl_relaxed(host->regs_va + STS);\n\tecc[12] = ecc_tmp >> 16;\n\n\treturn 0;\n}\n\n \nstatic int fsmc_read_hwecc_ecc1(struct nand_chip *chip, const u8 *data,\n\t\t\t\tu8 *ecc)\n{\n\tstruct fsmc_nand_data *host = nand_to_fsmc(chip);\n\tu32 ecc_tmp;\n\n\tecc_tmp = readl_relaxed(host->regs_va + ECC1);\n\tecc[0] = ecc_tmp;\n\tecc[1] = ecc_tmp >> 8;\n\tecc[2] = ecc_tmp >> 16;\n\n\treturn 0;\n}\n\nstatic int fsmc_correct_ecc1(struct nand_chip *chip,\n\t\t\t     unsigned char *buf,\n\t\t\t     unsigned char *read_ecc,\n\t\t\t     unsigned char *calc_ecc)\n{\n\tbool sm_order = chip->ecc.options & NAND_ECC_SOFT_HAMMING_SM_ORDER;\n\n\treturn ecc_sw_hamming_correct(buf, read_ecc, calc_ecc,\n\t\t\t\t      chip->ecc.size, sm_order);\n}\n\n \nstatic int count_written_bits(u8 *buff, int size, int max_bits)\n{\n\tint k, written_bits = 0;\n\n\tfor (k = 0; k < size; k++) {\n\t\twritten_bits += hweight8(~buff[k]);\n\t\tif (written_bits > max_bits)\n\t\t\tbreak;\n\t}\n\n\treturn written_bits;\n}\n\nstatic void dma_complete(void *param)\n{\n\tstruct fsmc_nand_data *host = param;\n\n\tcomplete(&host->dma_access_complete);\n}\n\nstatic int dma_xfer(struct fsmc_nand_data *host, void *buffer, int len,\n\t\t    enum dma_data_direction direction)\n{\n\tstruct dma_chan *chan;\n\tstruct dma_device *dma_dev;\n\tstruct dma_async_tx_descriptor *tx;\n\tdma_addr_t dma_dst, dma_src, dma_addr;\n\tdma_cookie_t cookie;\n\tunsigned long flags = DMA_CTRL_ACK | DMA_PREP_INTERRUPT;\n\tint ret;\n\tunsigned long time_left;\n\n\tif (direction == DMA_TO_DEVICE)\n\t\tchan = host->write_dma_chan;\n\telse if (direction == DMA_FROM_DEVICE)\n\t\tchan = host->read_dma_chan;\n\telse\n\t\treturn -EINVAL;\n\n\tdma_dev = chan->device;\n\tdma_addr = dma_map_single(dma_dev->dev, buffer, len, direction);\n\n\tif (direction == DMA_TO_DEVICE) {\n\t\tdma_src = dma_addr;\n\t\tdma_dst = host->data_pa;\n\t} else {\n\t\tdma_src = host->data_pa;\n\t\tdma_dst = dma_addr;\n\t}\n\n\ttx = dma_dev->device_prep_dma_memcpy(chan, dma_dst, dma_src,\n\t\t\tlen, flags);\n\tif (!tx) {\n\t\tdev_err(host->dev, \"device_prep_dma_memcpy error\\n\");\n\t\tret = -EIO;\n\t\tgoto unmap_dma;\n\t}\n\n\ttx->callback = dma_complete;\n\ttx->callback_param = host;\n\tcookie = tx->tx_submit(tx);\n\n\tret = dma_submit_error(cookie);\n\tif (ret) {\n\t\tdev_err(host->dev, \"dma_submit_error %d\\n\", cookie);\n\t\tgoto unmap_dma;\n\t}\n\n\tdma_async_issue_pending(chan);\n\n\ttime_left =\n\twait_for_completion_timeout(&host->dma_access_complete,\n\t\t\t\t    msecs_to_jiffies(3000));\n\tif (time_left == 0) {\n\t\tdmaengine_terminate_all(chan);\n\t\tdev_err(host->dev, \"wait_for_completion_timeout\\n\");\n\t\tret = -ETIMEDOUT;\n\t\tgoto unmap_dma;\n\t}\n\n\tret = 0;\n\nunmap_dma:\n\tdma_unmap_single(dma_dev->dev, dma_addr, len, direction);\n\n\treturn ret;\n}\n\n \nstatic void fsmc_write_buf(struct fsmc_nand_data *host, const u8 *buf,\n\t\t\t   int len)\n{\n\tint i;\n\n\tif (IS_ALIGNED((uintptr_t)buf, sizeof(u32)) &&\n\t    IS_ALIGNED(len, sizeof(u32))) {\n\t\tu32 *p = (u32 *)buf;\n\n\t\tlen = len >> 2;\n\t\tfor (i = 0; i < len; i++)\n\t\t\twritel_relaxed(p[i], host->data_va);\n\t} else {\n\t\tfor (i = 0; i < len; i++)\n\t\t\twriteb_relaxed(buf[i], host->data_va);\n\t}\n}\n\n \nstatic void fsmc_read_buf(struct fsmc_nand_data *host, u8 *buf, int len)\n{\n\tint i;\n\n\tif (IS_ALIGNED((uintptr_t)buf, sizeof(u32)) &&\n\t    IS_ALIGNED(len, sizeof(u32))) {\n\t\tu32 *p = (u32 *)buf;\n\n\t\tlen = len >> 2;\n\t\tfor (i = 0; i < len; i++)\n\t\t\tp[i] = readl_relaxed(host->data_va);\n\t} else {\n\t\tfor (i = 0; i < len; i++)\n\t\t\tbuf[i] = readb_relaxed(host->data_va);\n\t}\n}\n\n \nstatic void fsmc_read_buf_dma(struct fsmc_nand_data *host, u8 *buf,\n\t\t\t      int len)\n{\n\tdma_xfer(host, buf, len, DMA_FROM_DEVICE);\n}\n\n \nstatic void fsmc_write_buf_dma(struct fsmc_nand_data *host, const u8 *buf,\n\t\t\t       int len)\n{\n\tdma_xfer(host, (void *)buf, len, DMA_TO_DEVICE);\n}\n\n \nstatic int fsmc_exec_op(struct nand_chip *chip, const struct nand_operation *op,\n\t\t\tbool check_only)\n{\n\tstruct fsmc_nand_data *host = nand_to_fsmc(chip);\n\tconst struct nand_op_instr *instr = NULL;\n\tint ret = 0;\n\tunsigned int op_id;\n\tint i;\n\n\tif (check_only)\n\t\treturn 0;\n\n\tpr_debug(\"Executing operation [%d instructions]:\\n\", op->ninstrs);\n\n\tfor (op_id = 0; op_id < op->ninstrs; op_id++) {\n\t\tinstr = &op->instrs[op_id];\n\n\t\tnand_op_trace(\"  \", instr);\n\n\t\tswitch (instr->type) {\n\t\tcase NAND_OP_CMD_INSTR:\n\t\t\twriteb_relaxed(instr->ctx.cmd.opcode, host->cmd_va);\n\t\t\tbreak;\n\n\t\tcase NAND_OP_ADDR_INSTR:\n\t\t\tfor (i = 0; i < instr->ctx.addr.naddrs; i++)\n\t\t\t\twriteb_relaxed(instr->ctx.addr.addrs[i],\n\t\t\t\t\t       host->addr_va);\n\t\t\tbreak;\n\n\t\tcase NAND_OP_DATA_IN_INSTR:\n\t\t\tif (host->mode == USE_DMA_ACCESS)\n\t\t\t\tfsmc_read_buf_dma(host, instr->ctx.data.buf.in,\n\t\t\t\t\t\t  instr->ctx.data.len);\n\t\t\telse\n\t\t\t\tfsmc_read_buf(host, instr->ctx.data.buf.in,\n\t\t\t\t\t      instr->ctx.data.len);\n\t\t\tbreak;\n\n\t\tcase NAND_OP_DATA_OUT_INSTR:\n\t\t\tif (host->mode == USE_DMA_ACCESS)\n\t\t\t\tfsmc_write_buf_dma(host,\n\t\t\t\t\t\t   instr->ctx.data.buf.out,\n\t\t\t\t\t\t   instr->ctx.data.len);\n\t\t\telse\n\t\t\t\tfsmc_write_buf(host, instr->ctx.data.buf.out,\n\t\t\t\t\t       instr->ctx.data.len);\n\t\t\tbreak;\n\n\t\tcase NAND_OP_WAITRDY_INSTR:\n\t\t\tret = nand_soft_waitrdy(chip,\n\t\t\t\t\t\tinstr->ctx.waitrdy.timeout_ms);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (instr->delay_ns)\n\t\t\tndelay(instr->delay_ns);\n\t}\n\n\treturn ret;\n}\n\n \nstatic int fsmc_read_page_hwecc(struct nand_chip *chip, u8 *buf,\n\t\t\t\tint oob_required, int page)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tint i, j, s, stat, eccsize = chip->ecc.size;\n\tint eccbytes = chip->ecc.bytes;\n\tint eccsteps = chip->ecc.steps;\n\tu8 *p = buf;\n\tu8 *ecc_calc = chip->ecc.calc_buf;\n\tu8 *ecc_code = chip->ecc.code_buf;\n\tint off, len, ret, group = 0;\n\t \n\tu16 ecc_oob[7];\n\tu8 *oob = (u8 *)&ecc_oob[0];\n\tunsigned int max_bitflips = 0;\n\n\tfor (i = 0, s = 0; s < eccsteps; s++, i += eccbytes, p += eccsize) {\n\t\tnand_read_page_op(chip, page, s * eccsize, NULL, 0);\n\t\tchip->ecc.hwctl(chip, NAND_ECC_READ);\n\t\tret = nand_read_data_op(chip, p, eccsize, false, false);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tfor (j = 0; j < eccbytes;) {\n\t\t\tstruct mtd_oob_region oobregion;\n\n\t\t\tret = mtd_ooblayout_ecc(mtd, group++, &oobregion);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\toff = oobregion.offset;\n\t\t\tlen = oobregion.length;\n\n\t\t\t \n\t\t\tif (chip->options & NAND_BUSWIDTH_16)\n\t\t\t\tlen = roundup(len, 2);\n\n\t\t\tnand_read_oob_op(chip, page, off, oob + j, len);\n\t\t\tj += len;\n\t\t}\n\n\t\tmemcpy(&ecc_code[i], oob, chip->ecc.bytes);\n\t\tchip->ecc.calculate(chip, p, &ecc_calc[i]);\n\n\t\tstat = chip->ecc.correct(chip, p, &ecc_code[i], &ecc_calc[i]);\n\t\tif (stat < 0) {\n\t\t\tmtd->ecc_stats.failed++;\n\t\t} else {\n\t\t\tmtd->ecc_stats.corrected += stat;\n\t\t\tmax_bitflips = max_t(unsigned int, max_bitflips, stat);\n\t\t}\n\t}\n\n\treturn max_bitflips;\n}\n\n \nstatic int fsmc_bch8_correct_data(struct nand_chip *chip, u8 *dat,\n\t\t\t\t  u8 *read_ecc, u8 *calc_ecc)\n{\n\tstruct fsmc_nand_data *host = nand_to_fsmc(chip);\n\tu32 err_idx[8];\n\tu32 num_err, i;\n\tu32 ecc1, ecc2, ecc3, ecc4;\n\n\tnum_err = (readl_relaxed(host->regs_va + STS) >> 10) & 0xF;\n\n\t \n\tif (likely(num_err == 0))\n\t\treturn 0;\n\n\t \n\tif (unlikely(num_err > 8)) {\n\t\t \n\n\t\tint bits_ecc = count_written_bits(read_ecc, chip->ecc.bytes, 8);\n\t\tint bits_data = count_written_bits(dat, chip->ecc.size, 8);\n\n\t\tif ((bits_ecc + bits_data) <= 8) {\n\t\t\tif (bits_data)\n\t\t\t\tmemset(dat, 0xff, chip->ecc.size);\n\t\t\treturn bits_data;\n\t\t}\n\n\t\treturn -EBADMSG;\n\t}\n\n\t \n\tecc1 = readl_relaxed(host->regs_va + ECC1);\n\tecc2 = readl_relaxed(host->regs_va + ECC2);\n\tecc3 = readl_relaxed(host->regs_va + ECC3);\n\tecc4 = readl_relaxed(host->regs_va + STS);\n\n\terr_idx[0] = (ecc1 >> 0) & 0x1FFF;\n\terr_idx[1] = (ecc1 >> 13) & 0x1FFF;\n\terr_idx[2] = (((ecc2 >> 0) & 0x7F) << 6) | ((ecc1 >> 26) & 0x3F);\n\terr_idx[3] = (ecc2 >> 7) & 0x1FFF;\n\terr_idx[4] = (((ecc3 >> 0) & 0x1) << 12) | ((ecc2 >> 20) & 0xFFF);\n\terr_idx[5] = (ecc3 >> 1) & 0x1FFF;\n\terr_idx[6] = (ecc3 >> 14) & 0x1FFF;\n\terr_idx[7] = (((ecc4 >> 16) & 0xFF) << 5) | ((ecc3 >> 27) & 0x1F);\n\n\ti = 0;\n\twhile (num_err--) {\n\t\terr_idx[i] ^= 3;\n\n\t\tif (err_idx[i] < chip->ecc.size * 8) {\n\t\t\tint err = err_idx[i];\n\n\t\t\tdat[err >> 3] ^= BIT(err & 7);\n\t\t\ti++;\n\t\t}\n\t}\n\treturn i;\n}\n\nstatic bool filter(struct dma_chan *chan, void *slave)\n{\n\tchan->private = slave;\n\treturn true;\n}\n\nstatic int fsmc_nand_probe_config_dt(struct platform_device *pdev,\n\t\t\t\t     struct fsmc_nand_data *host,\n\t\t\t\t     struct nand_chip *nand)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tu32 val;\n\tint ret;\n\n\tnand->options = 0;\n\n\tif (!of_property_read_u32(np, \"bank-width\", &val)) {\n\t\tif (val == 2) {\n\t\t\tnand->options |= NAND_BUSWIDTH_16;\n\t\t} else if (val != 1) {\n\t\t\tdev_err(&pdev->dev, \"invalid bank-width %u\\n\", val);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (of_property_read_bool(np, \"nand-skip-bbtscan\"))\n\t\tnand->options |= NAND_SKIP_BBTSCAN;\n\n\thost->dev_timings = devm_kzalloc(&pdev->dev,\n\t\t\t\t\t sizeof(*host->dev_timings),\n\t\t\t\t\t GFP_KERNEL);\n\tif (!host->dev_timings)\n\t\treturn -ENOMEM;\n\n\tret = of_property_read_u8_array(np, \"timings\", (u8 *)host->dev_timings,\n\t\t\t\t\tsizeof(*host->dev_timings));\n\tif (ret)\n\t\thost->dev_timings = NULL;\n\n\t \n\thost->bank = 0;\n\tif (!of_property_read_u32(np, \"bank\", &val)) {\n\t\tif (val > 3) {\n\t\t\tdev_err(&pdev->dev, \"invalid bank %u\\n\", val);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\thost->bank = val;\n\t}\n\treturn 0;\n}\n\nstatic int fsmc_nand_attach_chip(struct nand_chip *nand)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(nand);\n\tstruct fsmc_nand_data *host = nand_to_fsmc(nand);\n\n\tif (nand->ecc.engine_type == NAND_ECC_ENGINE_TYPE_INVALID)\n\t\tnand->ecc.engine_type = NAND_ECC_ENGINE_TYPE_ON_HOST;\n\n\tif (!nand->ecc.size)\n\t\tnand->ecc.size = 512;\n\n\tif (AMBA_REV_BITS(host->pid) >= 8) {\n\t\tnand->ecc.read_page = fsmc_read_page_hwecc;\n\t\tnand->ecc.calculate = fsmc_read_hwecc_ecc4;\n\t\tnand->ecc.correct = fsmc_bch8_correct_data;\n\t\tnand->ecc.bytes = 13;\n\t\tnand->ecc.strength = 8;\n\t}\n\n\tif (AMBA_REV_BITS(host->pid) >= 8) {\n\t\tswitch (mtd->oobsize) {\n\t\tcase 16:\n\t\tcase 64:\n\t\tcase 128:\n\t\tcase 224:\n\t\tcase 256:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_warn(host->dev,\n\t\t\t\t \"No oob scheme defined for oobsize %d\\n\",\n\t\t\t\t mtd->oobsize);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tmtd_set_ooblayout(mtd, &fsmc_ecc4_ooblayout_ops);\n\n\t\treturn 0;\n\t}\n\n\tswitch (nand->ecc.engine_type) {\n\tcase NAND_ECC_ENGINE_TYPE_ON_HOST:\n\t\tdev_info(host->dev, \"Using 1-bit HW ECC scheme\\n\");\n\t\tnand->ecc.calculate = fsmc_read_hwecc_ecc1;\n\t\tnand->ecc.correct = fsmc_correct_ecc1;\n\t\tnand->ecc.hwctl = fsmc_enable_hwecc;\n\t\tnand->ecc.bytes = 3;\n\t\tnand->ecc.strength = 1;\n\t\tnand->ecc.options |= NAND_ECC_SOFT_HAMMING_SM_ORDER;\n\t\tbreak;\n\n\tcase NAND_ECC_ENGINE_TYPE_SOFT:\n\t\tif (nand->ecc.algo == NAND_ECC_ALGO_BCH) {\n\t\t\tdev_info(host->dev,\n\t\t\t\t \"Using 4-bit SW BCH ECC scheme\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase NAND_ECC_ENGINE_TYPE_ON_DIE:\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(host->dev, \"Unsupported ECC mode!\\n\");\n\t\treturn -ENOTSUPP;\n\t}\n\n\t \n\tif (nand->ecc.engine_type == NAND_ECC_ENGINE_TYPE_ON_HOST) {\n\t\tswitch (mtd->oobsize) {\n\t\tcase 16:\n\t\tcase 64:\n\t\tcase 128:\n\t\t\tmtd_set_ooblayout(mtd,\n\t\t\t\t\t  &fsmc_ecc1_ooblayout_ops);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_warn(host->dev,\n\t\t\t\t \"No oob scheme defined for oobsize %d\\n\",\n\t\t\t\t mtd->oobsize);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic const struct nand_controller_ops fsmc_nand_controller_ops = {\n\t.attach_chip = fsmc_nand_attach_chip,\n\t.exec_op = fsmc_exec_op,\n\t.setup_interface = fsmc_setup_interface,\n};\n\n \nstatic void fsmc_nand_disable(struct fsmc_nand_data *host)\n{\n\tu32 val;\n\n\tval = readl(host->regs_va + FSMC_PC);\n\tval &= ~FSMC_ENABLE;\n\twritel(val, host->regs_va + FSMC_PC);\n}\n\n \nstatic int __init fsmc_nand_probe(struct platform_device *pdev)\n{\n\tstruct fsmc_nand_data *host;\n\tstruct mtd_info *mtd;\n\tstruct nand_chip *nand;\n\tstruct resource *res;\n\tvoid __iomem *base;\n\tdma_cap_mask_t mask;\n\tint ret = 0;\n\tu32 pid;\n\tint i;\n\n\t \n\thost = devm_kzalloc(&pdev->dev, sizeof(*host), GFP_KERNEL);\n\tif (!host)\n\t\treturn -ENOMEM;\n\n\tnand = &host->nand;\n\n\tret = fsmc_nand_probe_config_dt(pdev, host, nand);\n\tif (ret)\n\t\treturn ret;\n\n\tres = platform_get_resource_byname(pdev, IORESOURCE_MEM, \"nand_data\");\n\thost->data_va = devm_ioremap_resource(&pdev->dev, res);\n\tif (IS_ERR(host->data_va))\n\t\treturn PTR_ERR(host->data_va);\n\n\thost->data_pa = (dma_addr_t)res->start;\n\n\tres = platform_get_resource_byname(pdev, IORESOURCE_MEM, \"nand_addr\");\n\thost->addr_va = devm_ioremap_resource(&pdev->dev, res);\n\tif (IS_ERR(host->addr_va))\n\t\treturn PTR_ERR(host->addr_va);\n\n\tres = platform_get_resource_byname(pdev, IORESOURCE_MEM, \"nand_cmd\");\n\thost->cmd_va = devm_ioremap_resource(&pdev->dev, res);\n\tif (IS_ERR(host->cmd_va))\n\t\treturn PTR_ERR(host->cmd_va);\n\n\tres = platform_get_resource_byname(pdev, IORESOURCE_MEM, \"fsmc_regs\");\n\tbase = devm_ioremap_resource(&pdev->dev, res);\n\tif (IS_ERR(base))\n\t\treturn PTR_ERR(base);\n\n\thost->regs_va = base + FSMC_NOR_REG_SIZE +\n\t\t(host->bank * FSMC_NAND_BANK_SZ);\n\n\thost->clk = devm_clk_get_enabled(&pdev->dev, NULL);\n\tif (IS_ERR(host->clk)) {\n\t\tdev_err(&pdev->dev, \"failed to fetch block clock\\n\");\n\t\treturn PTR_ERR(host->clk);\n\t}\n\n\t \n\tfor (pid = 0, i = 0; i < 4; i++)\n\t\tpid |= (readl(base + resource_size(res) - 0x20 + 4 * i) &\n\t\t\t255) << (i * 8);\n\n\thost->pid = pid;\n\n\tdev_info(&pdev->dev,\n\t\t \"FSMC device partno %03x, manufacturer %02x, revision %02x, config %02x\\n\",\n\t\t AMBA_PART_BITS(pid), AMBA_MANF_BITS(pid),\n\t\t AMBA_REV_BITS(pid), AMBA_CONFIG_BITS(pid));\n\n\thost->dev = &pdev->dev;\n\n\tif (host->mode == USE_DMA_ACCESS)\n\t\tinit_completion(&host->dma_access_complete);\n\n\t \n\tmtd = nand_to_mtd(&host->nand);\n\tnand_set_flash_node(nand, pdev->dev.of_node);\n\n\tmtd->dev.parent = &pdev->dev;\n\n\tnand->badblockbits = 7;\n\n\tif (host->mode == USE_DMA_ACCESS) {\n\t\tdma_cap_zero(mask);\n\t\tdma_cap_set(DMA_MEMCPY, mask);\n\t\thost->read_dma_chan = dma_request_channel(mask, filter, NULL);\n\t\tif (!host->read_dma_chan) {\n\t\t\tdev_err(&pdev->dev, \"Unable to get read dma channel\\n\");\n\t\t\tret = -ENODEV;\n\t\t\tgoto disable_fsmc;\n\t\t}\n\t\thost->write_dma_chan = dma_request_channel(mask, filter, NULL);\n\t\tif (!host->write_dma_chan) {\n\t\t\tdev_err(&pdev->dev, \"Unable to get write dma channel\\n\");\n\t\t\tret = -ENODEV;\n\t\t\tgoto release_dma_read_chan;\n\t\t}\n\t}\n\n\tif (host->dev_timings) {\n\t\tfsmc_nand_setup(host, host->dev_timings);\n\t\tnand->options |= NAND_KEEP_TIMINGS;\n\t}\n\n\tnand_controller_init(&host->base);\n\thost->base.ops = &fsmc_nand_controller_ops;\n\tnand->controller = &host->base;\n\n\t \n\tret = nand_scan(nand, 1);\n\tif (ret)\n\t\tgoto release_dma_write_chan;\n\n\tmtd->name = \"nand\";\n\tret = mtd_device_register(mtd, NULL, 0);\n\tif (ret)\n\t\tgoto cleanup_nand;\n\n\tplatform_set_drvdata(pdev, host);\n\tdev_info(&pdev->dev, \"FSMC NAND driver registration successful\\n\");\n\n\treturn 0;\n\ncleanup_nand:\n\tnand_cleanup(nand);\nrelease_dma_write_chan:\n\tif (host->mode == USE_DMA_ACCESS)\n\t\tdma_release_channel(host->write_dma_chan);\nrelease_dma_read_chan:\n\tif (host->mode == USE_DMA_ACCESS)\n\t\tdma_release_channel(host->read_dma_chan);\ndisable_fsmc:\n\tfsmc_nand_disable(host);\n\n\treturn ret;\n}\n\n \nstatic void fsmc_nand_remove(struct platform_device *pdev)\n{\n\tstruct fsmc_nand_data *host = platform_get_drvdata(pdev);\n\n\tif (host) {\n\t\tstruct nand_chip *chip = &host->nand;\n\t\tint ret;\n\n\t\tret = mtd_device_unregister(nand_to_mtd(chip));\n\t\tWARN_ON(ret);\n\t\tnand_cleanup(chip);\n\t\tfsmc_nand_disable(host);\n\n\t\tif (host->mode == USE_DMA_ACCESS) {\n\t\t\tdma_release_channel(host->write_dma_chan);\n\t\t\tdma_release_channel(host->read_dma_chan);\n\t\t}\n\t}\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int fsmc_nand_suspend(struct device *dev)\n{\n\tstruct fsmc_nand_data *host = dev_get_drvdata(dev);\n\n\tif (host)\n\t\tclk_disable_unprepare(host->clk);\n\n\treturn 0;\n}\n\nstatic int fsmc_nand_resume(struct device *dev)\n{\n\tstruct fsmc_nand_data *host = dev_get_drvdata(dev);\n\tint ret;\n\n\tif (host) {\n\t\tret = clk_prepare_enable(host->clk);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"failed to enable clk\\n\");\n\t\t\treturn ret;\n\t\t}\n\t\tif (host->dev_timings)\n\t\t\tfsmc_nand_setup(host, host->dev_timings);\n\t\tnand_reset(&host->nand, 0);\n\t}\n\n\treturn 0;\n}\n#endif\n\nstatic SIMPLE_DEV_PM_OPS(fsmc_nand_pm_ops, fsmc_nand_suspend, fsmc_nand_resume);\n\nstatic const struct of_device_id fsmc_nand_id_table[] = {\n\t{ .compatible = \"st,spear600-fsmc-nand\" },\n\t{ .compatible = \"stericsson,fsmc-nand\" },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, fsmc_nand_id_table);\n\nstatic struct platform_driver fsmc_nand_driver = {\n\t.remove_new = fsmc_nand_remove,\n\t.driver = {\n\t\t.name = \"fsmc-nand\",\n\t\t.of_match_table = fsmc_nand_id_table,\n\t\t.pm = &fsmc_nand_pm_ops,\n\t},\n};\n\nmodule_platform_driver_probe(fsmc_nand_driver, fsmc_nand_probe);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Vipin Kumar <vipin.kumar@st.com>, Ashish Priyadarshi\");\nMODULE_DESCRIPTION(\"NAND driver for SPEAr Platforms\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}