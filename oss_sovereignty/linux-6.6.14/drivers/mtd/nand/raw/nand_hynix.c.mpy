{
  "module_name": "nand_hynix.c",
  "hash_id": "44936f4607ae348db0e49c543bf3869416bcd993bb3e2f39202891e18699966e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/nand/raw/nand_hynix.c",
  "human_readable_source": "\n \n\n#include <linux/sizes.h>\n#include <linux/slab.h>\n\n#include \"internals.h\"\n\n#define NAND_HYNIX_CMD_SET_PARAMS\t0x36\n#define NAND_HYNIX_CMD_APPLY_PARAMS\t0x16\n\n#define NAND_HYNIX_1XNM_RR_REPEAT\t8\n\n \nstruct hynix_read_retry {\n\tint nregs;\n\tconst u8 *regs;\n\tu8 values[];\n};\n\n \nstruct hynix_nand {\n\tconst struct hynix_read_retry *read_retry;\n};\n\n \nstruct hynix_read_retry_otp {\n\tint nregs;\n\tconst u8 *regs;\n\tconst u8 *values;\n\tint page;\n\tint size;\n};\n\nstatic bool hynix_nand_has_valid_jedecid(struct nand_chip *chip)\n{\n\tu8 jedecid[5] = { };\n\tint ret;\n\n\tret = nand_readid_op(chip, 0x40, jedecid, sizeof(jedecid));\n\tif (ret)\n\t\treturn false;\n\n\treturn !strncmp(\"JEDEC\", jedecid, sizeof(jedecid));\n}\n\nstatic int hynix_nand_cmd_op(struct nand_chip *chip, u8 cmd)\n{\n\tif (nand_has_exec_op(chip)) {\n\t\tstruct nand_op_instr instrs[] = {\n\t\t\tNAND_OP_CMD(cmd, 0),\n\t\t};\n\t\tstruct nand_operation op = NAND_OPERATION(chip->cur_cs, instrs);\n\n\t\treturn nand_exec_op(chip, &op);\n\t}\n\n\tchip->legacy.cmdfunc(chip, cmd, -1, -1);\n\n\treturn 0;\n}\n\nstatic int hynix_nand_reg_write_op(struct nand_chip *chip, u8 addr, u8 val)\n{\n\tu16 column = ((u16)addr << 8) | addr;\n\n\tif (nand_has_exec_op(chip)) {\n\t\tstruct nand_op_instr instrs[] = {\n\t\t\tNAND_OP_ADDR(1, &addr, 0),\n\t\t\tNAND_OP_8BIT_DATA_OUT(1, &val, 0),\n\t\t};\n\t\tstruct nand_operation op = NAND_OPERATION(chip->cur_cs, instrs);\n\n\t\treturn nand_exec_op(chip, &op);\n\t}\n\n\tchip->legacy.cmdfunc(chip, NAND_CMD_NONE, column, -1);\n\tchip->legacy.write_byte(chip, val);\n\n\treturn 0;\n}\n\nstatic int hynix_nand_setup_read_retry(struct nand_chip *chip, int retry_mode)\n{\n\tstruct hynix_nand *hynix = nand_get_manufacturer_data(chip);\n\tconst u8 *values;\n\tint i, ret;\n\n\tvalues = hynix->read_retry->values +\n\t\t (retry_mode * hynix->read_retry->nregs);\n\n\t \n\tret = hynix_nand_cmd_op(chip, NAND_HYNIX_CMD_SET_PARAMS);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tfor (i = 0; i < hynix->read_retry->nregs; i++) {\n\t\tret = hynix_nand_reg_write_op(chip, hynix->read_retry->regs[i],\n\t\t\t\t\t      values[i]);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\treturn hynix_nand_cmd_op(chip, NAND_HYNIX_CMD_APPLY_PARAMS);\n}\n\n \nstatic int hynix_get_majority(const u8 *in, int repeat, u8 *out)\n{\n\tint i, j, half = repeat / 2;\n\n\t \n\tfor (i = 0; i < half; i++) {\n\t\tint cnt = 0;\n\t\tu8 val = in[i];\n\n\t\t \n\t\tfor (j = i + 1; j < repeat; j++) {\n\t\t\tif (in[j] == val)\n\t\t\t\tcnt++;\n\t\t}\n\n\t\t \n\t\tif (cnt > half) {\n\t\t\t*out = val;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -EIO;\n}\n\nstatic int hynix_read_rr_otp(struct nand_chip *chip,\n\t\t\t     const struct hynix_read_retry_otp *info,\n\t\t\t     void *buf)\n{\n\tint i, ret;\n\n\tret = nand_reset_op(chip);\n\tif (ret)\n\t\treturn ret;\n\n\tret = hynix_nand_cmd_op(chip, NAND_HYNIX_CMD_SET_PARAMS);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < info->nregs; i++) {\n\t\tret = hynix_nand_reg_write_op(chip, info->regs[i],\n\t\t\t\t\t      info->values[i]);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = hynix_nand_cmd_op(chip, NAND_HYNIX_CMD_APPLY_PARAMS);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = hynix_nand_cmd_op(chip, 0x17);\n\tif (ret)\n\t\treturn ret;\n\n\tret = hynix_nand_cmd_op(chip, 0x4);\n\tif (ret)\n\t\treturn ret;\n\n\tret = hynix_nand_cmd_op(chip, 0x19);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = nand_read_page_op(chip, info->page, 0, buf, info->size);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = nand_reset_op(chip);\n\tif (ret)\n\t\treturn ret;\n\n\tret = hynix_nand_cmd_op(chip, NAND_HYNIX_CMD_SET_PARAMS);\n\tif (ret)\n\t\treturn ret;\n\n\tret = hynix_nand_reg_write_op(chip, 0x38, 0);\n\tif (ret)\n\t\treturn ret;\n\n\tret = hynix_nand_cmd_op(chip, NAND_HYNIX_CMD_APPLY_PARAMS);\n\tif (ret)\n\t\treturn ret;\n\n\treturn nand_read_page_op(chip, 0, 0, NULL, 0);\n}\n\n#define NAND_HYNIX_1XNM_RR_COUNT_OFFS\t\t\t\t0\n#define NAND_HYNIX_1XNM_RR_REG_COUNT_OFFS\t\t\t8\n#define NAND_HYNIX_1XNM_RR_SET_OFFS(x, setsize, inv)\t\t\\\n\t(16 + ((((x) * 2) + ((inv) ? 1 : 0)) * (setsize)))\n\nstatic int hynix_mlc_1xnm_rr_value(const u8 *buf, int nmodes, int nregs,\n\t\t\t\t   int mode, int reg, bool inv, u8 *val)\n{\n\tu8 tmp[NAND_HYNIX_1XNM_RR_REPEAT];\n\tint val_offs = (mode * nregs) + reg;\n\tint set_size = nmodes * nregs;\n\tint i, ret;\n\n\tfor (i = 0; i < NAND_HYNIX_1XNM_RR_REPEAT; i++) {\n\t\tint set_offs = NAND_HYNIX_1XNM_RR_SET_OFFS(i, set_size, inv);\n\n\t\ttmp[i] = buf[val_offs + set_offs];\n\t}\n\n\tret = hynix_get_majority(tmp, NAND_HYNIX_1XNM_RR_REPEAT, val);\n\tif (ret)\n\t\treturn ret;\n\n\tif (inv)\n\t\t*val = ~*val;\n\n\treturn 0;\n}\n\nstatic u8 hynix_1xnm_mlc_read_retry_regs[] = {\n\t0xcc, 0xbf, 0xaa, 0xab, 0xcd, 0xad, 0xae, 0xaf\n};\n\nstatic int hynix_mlc_1xnm_rr_init(struct nand_chip *chip,\n\t\t\t\t  const struct hynix_read_retry_otp *info)\n{\n\tstruct hynix_nand *hynix = nand_get_manufacturer_data(chip);\n\tstruct hynix_read_retry *rr = NULL;\n\tint ret, i, j;\n\tu8 nregs, nmodes;\n\tu8 *buf;\n\n\tbuf = kmalloc(info->size, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tret = hynix_read_rr_otp(chip, info, buf);\n\tif (ret)\n\t\tgoto out;\n\n\tret = hynix_get_majority(buf, NAND_HYNIX_1XNM_RR_REPEAT,\n\t\t\t\t &nmodes);\n\tif (ret)\n\t\tgoto out;\n\n\tret = hynix_get_majority(buf + NAND_HYNIX_1XNM_RR_REPEAT,\n\t\t\t\t NAND_HYNIX_1XNM_RR_REPEAT,\n\t\t\t\t &nregs);\n\tif (ret)\n\t\tgoto out;\n\n\trr = kzalloc(sizeof(*rr) + (nregs * nmodes), GFP_KERNEL);\n\tif (!rr) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < nmodes; i++) {\n\t\tfor (j = 0; j < nregs; j++) {\n\t\t\tu8 *val = rr->values + (i * nregs);\n\n\t\t\tret = hynix_mlc_1xnm_rr_value(buf, nmodes, nregs, i, j,\n\t\t\t\t\t\t      false, val);\n\t\t\tif (!ret)\n\t\t\t\tcontinue;\n\n\t\t\tret = hynix_mlc_1xnm_rr_value(buf, nmodes, nregs, i, j,\n\t\t\t\t\t\t      true, val);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\n\trr->nregs = nregs;\n\trr->regs = hynix_1xnm_mlc_read_retry_regs;\n\thynix->read_retry = rr;\n\tchip->ops.setup_read_retry = hynix_nand_setup_read_retry;\n\tchip->read_retries = nmodes;\n\nout:\n\tkfree(buf);\n\n\tif (ret)\n\t\tkfree(rr);\n\n\treturn ret;\n}\n\nstatic const u8 hynix_mlc_1xnm_rr_otp_regs[] = { 0x38 };\nstatic const u8 hynix_mlc_1xnm_rr_otp_values[] = { 0x52 };\n\nstatic const struct hynix_read_retry_otp hynix_mlc_1xnm_rr_otps[] = {\n\t{\n\t\t.nregs = ARRAY_SIZE(hynix_mlc_1xnm_rr_otp_regs),\n\t\t.regs = hynix_mlc_1xnm_rr_otp_regs,\n\t\t.values = hynix_mlc_1xnm_rr_otp_values,\n\t\t.page = 0x21f,\n\t\t.size = 784\n\t},\n\t{\n\t\t.nregs = ARRAY_SIZE(hynix_mlc_1xnm_rr_otp_regs),\n\t\t.regs = hynix_mlc_1xnm_rr_otp_regs,\n\t\t.values = hynix_mlc_1xnm_rr_otp_values,\n\t\t.page = 0x200,\n\t\t.size = 528,\n\t},\n};\n\nstatic int hynix_nand_rr_init(struct nand_chip *chip)\n{\n\tint i, ret = 0;\n\tbool valid_jedecid;\n\n\tvalid_jedecid = hynix_nand_has_valid_jedecid(chip);\n\n\t \n\tif (valid_jedecid) {\n\t\tu8 nand_tech = chip->id.data[5] >> 4;\n\n\t\t \n\t\tif (nand_tech == 4) {\n\t\t\tfor (i = 0; i < ARRAY_SIZE(hynix_mlc_1xnm_rr_otps);\n\t\t\t     i++) {\n\t\t\t\t \n\t\t\t\tret = hynix_mlc_1xnm_rr_init(chip,\n\t\t\t\t\t\thynix_mlc_1xnm_rr_otps);\n\t\t\t\tif (!ret)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (ret)\n\t\tpr_warn(\"failed to initialize read-retry infrastructure\");\n\n\treturn 0;\n}\n\nstatic void hynix_nand_extract_oobsize(struct nand_chip *chip,\n\t\t\t\t       bool valid_jedecid)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tstruct nand_memory_organization *memorg;\n\tu8 oobsize;\n\n\tmemorg = nanddev_get_memorg(&chip->base);\n\n\toobsize = ((chip->id.data[3] >> 2) & 0x3) |\n\t\t  ((chip->id.data[3] >> 4) & 0x4);\n\n\tif (valid_jedecid) {\n\t\tswitch (oobsize) {\n\t\tcase 0:\n\t\t\tmemorg->oobsize = 2048;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tmemorg->oobsize = 1664;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tmemorg->oobsize = 1024;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tmemorg->oobsize = 640;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t \n\t\t\tWARN(1, \"Invalid OOB size\");\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tswitch (oobsize) {\n\t\tcase 0:\n\t\t\tmemorg->oobsize = 128;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tmemorg->oobsize = 224;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tmemorg->oobsize = 448;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tmemorg->oobsize = 64;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tmemorg->oobsize = 32;\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\tmemorg->oobsize = 16;\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\tmemorg->oobsize = 640;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t \n\t\t\tWARN(1, \"Invalid OOB size\");\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (chip->id.data[1] == 0xde)\n\t\t\tmemorg->oobsize *= memorg->pagesize / SZ_8K;\n\t}\n\n\tmtd->oobsize = memorg->oobsize;\n}\n\nstatic void hynix_nand_extract_ecc_requirements(struct nand_chip *chip,\n\t\t\t\t\t\tbool valid_jedecid)\n{\n\tstruct nand_device *base = &chip->base;\n\tstruct nand_ecc_props requirements = {};\n\tu8 ecc_level = (chip->id.data[4] >> 4) & 0x7;\n\n\tif (valid_jedecid) {\n\t\t \n\t\trequirements.step_size = 1024;\n\n\t\tswitch (ecc_level) {\n\t\tcase 0:\n\t\t\trequirements.step_size = 0;\n\t\t\trequirements.strength = 0;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\trequirements.strength = 4;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\trequirements.strength = 24;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\trequirements.strength = 32;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\trequirements.strength = 40;\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\trequirements.strength = 50;\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\trequirements.strength = 60;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t \n\t\t\tWARN(1, \"Invalid ECC requirements\");\n\t\t}\n\t} else {\n\t\t \n\t\tu8 nand_tech = chip->id.data[5] & 0x7;\n\n\t\tif (nand_tech < 3) {\n\t\t\t \n\t\t\tif (ecc_level < 5) {\n\t\t\t\trequirements.step_size = 512;\n\t\t\t\trequirements.strength = 1 << ecc_level;\n\t\t\t} else if (ecc_level < 7) {\n\t\t\t\tif (ecc_level == 5)\n\t\t\t\t\trequirements.step_size = 2048;\n\t\t\t\telse\n\t\t\t\t\trequirements.step_size = 1024;\n\t\t\t\trequirements.strength = 24;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tWARN(1, \"Invalid ECC requirements\");\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tif (!ecc_level) {\n\t\t\t\trequirements.step_size = 0;\n\t\t\t\trequirements.strength = 0;\n\t\t\t} else if (ecc_level < 5) {\n\t\t\t\trequirements.step_size = 512;\n\t\t\t\trequirements.strength = 1 << (ecc_level - 1);\n\t\t\t} else {\n\t\t\t\trequirements.step_size = 1024;\n\t\t\t\trequirements.strength = 24 +\n\t\t\t\t\t\t\t(8 * (ecc_level - 5));\n\t\t\t}\n\t\t}\n\t}\n\n\tnanddev_set_ecc_requirements(base, &requirements);\n}\n\nstatic void hynix_nand_extract_scrambling_requirements(struct nand_chip *chip,\n\t\t\t\t\t\t       bool valid_jedecid)\n{\n\tu8 nand_tech;\n\n\t \n\tif (nanddev_bits_per_cell(&chip->base) > 2)\n\t\tchip->options |= NAND_NEED_SCRAMBLING;\n\n\t \n\tif (valid_jedecid) {\n\t\tnand_tech = chip->id.data[5] >> 4;\n\n\t\t \n\t\tif (nand_tech > 0)\n\t\t\tchip->options |= NAND_NEED_SCRAMBLING;\n\t} else {\n\t\tnand_tech = chip->id.data[5] & 0x7;\n\n\t\t \n\t\tif (nand_tech > 2)\n\t\t\tchip->options |= NAND_NEED_SCRAMBLING;\n\t}\n}\n\nstatic void hynix_nand_decode_id(struct nand_chip *chip)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tstruct nand_memory_organization *memorg;\n\tbool valid_jedecid;\n\tu8 tmp;\n\n\tmemorg = nanddev_get_memorg(&chip->base);\n\n\t \n\tif (chip->id.len < 6 || nand_is_slc(chip)) {\n\t\tnand_decode_ext_id(chip);\n\t\treturn;\n\t}\n\n\t \n\tmemorg->pagesize = 2048 << (chip->id.data[3] & 0x03);\n\tmtd->writesize = memorg->pagesize;\n\n\ttmp = (chip->id.data[3] >> 4) & 0x3;\n\t \n\tif (chip->id.data[3] & 0x80) {\n\t\tmemorg->pages_per_eraseblock = (SZ_1M << tmp) /\n\t\t\t\t\t       memorg->pagesize;\n\t\tmtd->erasesize = SZ_1M << tmp;\n\t} else if (tmp == 3) {\n\t\tmemorg->pages_per_eraseblock = (SZ_512K + SZ_256K) /\n\t\t\t\t\t       memorg->pagesize;\n\t\tmtd->erasesize = SZ_512K + SZ_256K;\n\t} else {\n\t\tmemorg->pages_per_eraseblock = (SZ_128K << tmp) /\n\t\t\t\t\t       memorg->pagesize;\n\t\tmtd->erasesize = SZ_128K << tmp;\n\t}\n\n\t \n\tvalid_jedecid = hynix_nand_has_valid_jedecid(chip);\n\n\thynix_nand_extract_oobsize(chip, valid_jedecid);\n\thynix_nand_extract_ecc_requirements(chip, valid_jedecid);\n\thynix_nand_extract_scrambling_requirements(chip, valid_jedecid);\n}\n\nstatic void hynix_nand_cleanup(struct nand_chip *chip)\n{\n\tstruct hynix_nand *hynix = nand_get_manufacturer_data(chip);\n\n\tif (!hynix)\n\t\treturn;\n\n\tkfree(hynix->read_retry);\n\tkfree(hynix);\n\tnand_set_manufacturer_data(chip, NULL);\n}\n\nstatic int\nh27ucg8t2atrbc_choose_interface_config(struct nand_chip *chip,\n\t\t\t\t       struct nand_interface_config *iface)\n{\n\tonfi_fill_interface_config(chip, iface, NAND_SDR_IFACE, 4);\n\n\treturn nand_choose_best_sdr_timings(chip, iface, NULL);\n}\n\nstatic int h27ucg8t2etrbc_init(struct nand_chip *chip)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\n\tchip->options |= NAND_NEED_SCRAMBLING;\n\tmtd_set_pairing_scheme(mtd, &dist3_pairing_scheme);\n\n\treturn 0;\n}\n\nstatic int hynix_nand_init(struct nand_chip *chip)\n{\n\tstruct hynix_nand *hynix;\n\tint ret;\n\n\tif (!nand_is_slc(chip))\n\t\tchip->options |= NAND_BBM_LASTPAGE;\n\telse\n\t\tchip->options |= NAND_BBM_FIRSTPAGE | NAND_BBM_SECONDPAGE;\n\n\thynix = kzalloc(sizeof(*hynix), GFP_KERNEL);\n\tif (!hynix)\n\t\treturn -ENOMEM;\n\n\tnand_set_manufacturer_data(chip, hynix);\n\n\tif (!strncmp(\"H27UCG8T2ATR-BC\", chip->parameters.model,\n\t\t     sizeof(\"H27UCG8T2ATR-BC\") - 1))\n\t\tchip->ops.choose_interface_config =\n\t\t\th27ucg8t2atrbc_choose_interface_config;\n\n\tif (!strncmp(\"H27UCG8T2ETR-BC\", chip->parameters.model,\n\t\t     sizeof(\"H27UCG8T2ETR-BC\") - 1))\n\t\th27ucg8t2etrbc_init(chip);\n\n\tret = hynix_nand_rr_init(chip);\n\tif (ret)\n\t\thynix_nand_cleanup(chip);\n\n\treturn ret;\n}\n\nstatic void hynix_fixup_onfi_param_page(struct nand_chip *chip,\n\t\t\t\t\tstruct nand_onfi_params *p)\n{\n\t \n\tp->sdr_timing_modes |= cpu_to_le16(BIT(0));\n}\n\nconst struct nand_manufacturer_ops hynix_nand_manuf_ops = {\n\t.detect = hynix_nand_decode_id,\n\t.init = hynix_nand_init,\n\t.cleanup = hynix_nand_cleanup,\n\t.fixup_onfi_param_page = hynix_fixup_onfi_param_page,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}