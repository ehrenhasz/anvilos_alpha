{
  "module_name": "s3c2410.c",
  "hash_id": "49f64dbfc7ae1274d23b5b14ad06684ec908dff756c4f2a5de87f415fa123982",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/nand/raw/s3c2410.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"nand-s3c2410: \" fmt\n\n#ifdef CONFIG_MTD_NAND_S3C2410_DEBUG\n#define DEBUG\n#endif\n\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/io.h>\n#include <linux/ioport.h>\n#include <linux/platform_device.h>\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/clk.h>\n#include <linux/cpufreq.h>\n#include <linux/of.h>\n\n#include <linux/mtd/mtd.h>\n#include <linux/mtd/rawnand.h>\n#include <linux/mtd/partitions.h>\n\n#include <linux/platform_data/mtd-nand-s3c2410.h>\n\n#define S3C2410_NFREG(x) (x)\n\n#define S3C2410_NFCONF\t\tS3C2410_NFREG(0x00)\n#define S3C2410_NFCMD\t\tS3C2410_NFREG(0x04)\n#define S3C2410_NFADDR\t\tS3C2410_NFREG(0x08)\n#define S3C2410_NFDATA\t\tS3C2410_NFREG(0x0C)\n#define S3C2410_NFSTAT\t\tS3C2410_NFREG(0x10)\n#define S3C2410_NFECC\t\tS3C2410_NFREG(0x14)\n#define S3C2440_NFCONT\t\tS3C2410_NFREG(0x04)\n#define S3C2440_NFCMD\t\tS3C2410_NFREG(0x08)\n#define S3C2440_NFADDR\t\tS3C2410_NFREG(0x0C)\n#define S3C2440_NFDATA\t\tS3C2410_NFREG(0x10)\n#define S3C2440_NFSTAT\t\tS3C2410_NFREG(0x20)\n#define S3C2440_NFMECC0\t\tS3C2410_NFREG(0x2C)\n#define S3C2412_NFSTAT\t\tS3C2410_NFREG(0x28)\n#define S3C2412_NFMECC0\t\tS3C2410_NFREG(0x34)\n#define S3C2410_NFCONF_EN\t\t(1<<15)\n#define S3C2410_NFCONF_INITECC\t\t(1<<12)\n#define S3C2410_NFCONF_nFCE\t\t(1<<11)\n#define S3C2410_NFCONF_TACLS(x)\t\t((x)<<8)\n#define S3C2410_NFCONF_TWRPH0(x)\t((x)<<4)\n#define S3C2410_NFCONF_TWRPH1(x)\t((x)<<0)\n#define S3C2410_NFSTAT_BUSY\t\t(1<<0)\n#define S3C2440_NFCONF_TACLS(x)\t\t((x)<<12)\n#define S3C2440_NFCONF_TWRPH0(x)\t((x)<<8)\n#define S3C2440_NFCONF_TWRPH1(x)\t((x)<<4)\n#define S3C2440_NFCONT_INITECC\t\t(1<<4)\n#define S3C2440_NFCONT_nFCE\t\t(1<<1)\n#define S3C2440_NFCONT_ENABLE\t\t(1<<0)\n#define S3C2440_NFSTAT_READY\t\t(1<<0)\n#define S3C2412_NFCONF_NANDBOOT\t\t(1<<31)\n#define S3C2412_NFCONT_INIT_MAIN_ECC\t(1<<5)\n#define S3C2412_NFCONT_nFCE0\t\t(1<<1)\n#define S3C2412_NFSTAT_READY\t\t(1<<0)\n\n \nstatic int s3c2410_ooblayout_ecc(struct mtd_info *mtd, int section,\n\t\t\t\t struct mtd_oob_region *oobregion)\n{\n\tif (section)\n\t\treturn -ERANGE;\n\n\toobregion->offset = 0;\n\toobregion->length = 3;\n\n\treturn 0;\n}\n\nstatic int s3c2410_ooblayout_free(struct mtd_info *mtd, int section,\n\t\t\t\t  struct mtd_oob_region *oobregion)\n{\n\tif (section)\n\t\treturn -ERANGE;\n\n\toobregion->offset = 8;\n\toobregion->length = 8;\n\n\treturn 0;\n}\n\nstatic const struct mtd_ooblayout_ops s3c2410_ooblayout_ops = {\n\t.ecc = s3c2410_ooblayout_ecc,\n\t.free = s3c2410_ooblayout_free,\n};\n\n \n\nstruct s3c2410_nand_info;\n\n \nstruct s3c2410_nand_mtd {\n\tstruct nand_chip\t\tchip;\n\tstruct s3c2410_nand_set\t\t*set;\n\tstruct s3c2410_nand_info\t*info;\n};\n\nenum s3c_cpu_type {\n\tTYPE_S3C2410,\n\tTYPE_S3C2412,\n\tTYPE_S3C2440,\n};\n\nenum s3c_nand_clk_state {\n\tCLOCK_DISABLE\t= 0,\n\tCLOCK_ENABLE,\n\tCLOCK_SUSPEND,\n};\n\n \n\n \nstruct s3c2410_nand_info {\n\t \n\tstruct nand_controller\t\tcontroller;\n\tstruct s3c2410_nand_mtd\t\t*mtds;\n\tstruct s3c2410_platform_nand\t*platform;\n\n\t \n\tstruct device\t\t\t*device;\n\tstruct clk\t\t\t*clk;\n\tvoid __iomem\t\t\t*regs;\n\tvoid __iomem\t\t\t*sel_reg;\n\tint\t\t\t\tsel_bit;\n\tint\t\t\t\tmtd_count;\n\tunsigned long\t\t\tsave_sel;\n\tunsigned long\t\t\tclk_rate;\n\tenum s3c_nand_clk_state\t\tclk_state;\n\n\tenum s3c_cpu_type\t\tcpu_type;\n};\n\nstruct s3c24XX_nand_devtype_data {\n\tenum s3c_cpu_type type;\n};\n\nstatic const struct s3c24XX_nand_devtype_data s3c2410_nand_devtype_data = {\n\t.type = TYPE_S3C2410,\n};\n\nstatic const struct s3c24XX_nand_devtype_data s3c2412_nand_devtype_data = {\n\t.type = TYPE_S3C2412,\n};\n\nstatic const struct s3c24XX_nand_devtype_data s3c2440_nand_devtype_data = {\n\t.type = TYPE_S3C2440,\n};\n\n \n\nstatic struct s3c2410_nand_mtd *s3c2410_nand_mtd_toours(struct mtd_info *mtd)\n{\n\treturn container_of(mtd_to_nand(mtd), struct s3c2410_nand_mtd,\n\t\t\t    chip);\n}\n\nstatic struct s3c2410_nand_info *s3c2410_nand_mtd_toinfo(struct mtd_info *mtd)\n{\n\treturn s3c2410_nand_mtd_toours(mtd)->info;\n}\n\nstatic struct s3c2410_nand_info *to_nand_info(struct platform_device *dev)\n{\n\treturn platform_get_drvdata(dev);\n}\n\nstatic struct s3c2410_platform_nand *to_nand_plat(struct platform_device *dev)\n{\n\treturn dev_get_platdata(&dev->dev);\n}\n\nstatic inline int allow_clk_suspend(struct s3c2410_nand_info *info)\n{\n#ifdef CONFIG_MTD_NAND_S3C2410_CLKSTOP\n\treturn 1;\n#else\n\treturn 0;\n#endif\n}\n\n \nstatic void s3c2410_nand_clk_set_state(struct s3c2410_nand_info *info,\n\t\tenum s3c_nand_clk_state new_state)\n{\n\tif (!allow_clk_suspend(info) && new_state == CLOCK_SUSPEND)\n\t\treturn;\n\n\tif (info->clk_state == CLOCK_ENABLE) {\n\t\tif (new_state != CLOCK_ENABLE)\n\t\t\tclk_disable_unprepare(info->clk);\n\t} else {\n\t\tif (new_state == CLOCK_ENABLE)\n\t\t\tclk_prepare_enable(info->clk);\n\t}\n\n\tinfo->clk_state = new_state;\n}\n\n \n\n#define NS_IN_KHZ 1000000\n\n \nstatic int s3c_nand_calc_rate(int wanted, unsigned long clk, int max)\n{\n\tint result;\n\n\tresult = DIV_ROUND_UP((wanted * clk), NS_IN_KHZ);\n\n\tpr_debug(\"result %d from %ld, %d\\n\", result, clk, wanted);\n\n\tif (result > max) {\n\t\tpr_err(\"%d ns is too big for current clock rate %ld\\n\",\n\t\t\twanted, clk);\n\t\treturn -1;\n\t}\n\n\tif (result < 1)\n\t\tresult = 1;\n\n\treturn result;\n}\n\n#define to_ns(ticks, clk) (((ticks) * NS_IN_KHZ) / (unsigned int)(clk))\n\n \n\n \nstatic int s3c2410_nand_setrate(struct s3c2410_nand_info *info)\n{\n\tstruct s3c2410_platform_nand *plat = info->platform;\n\tint tacls_max = (info->cpu_type == TYPE_S3C2412) ? 8 : 4;\n\tint tacls, twrph0, twrph1;\n\tunsigned long clkrate = clk_get_rate(info->clk);\n\tunsigned long set, cfg, mask;\n\tunsigned long flags;\n\n\t \n\n\tinfo->clk_rate = clkrate;\n\tclkrate /= 1000;\t \n\n\tif (plat != NULL) {\n\t\ttacls = s3c_nand_calc_rate(plat->tacls, clkrate, tacls_max);\n\t\ttwrph0 = s3c_nand_calc_rate(plat->twrph0, clkrate, 8);\n\t\ttwrph1 = s3c_nand_calc_rate(plat->twrph1, clkrate, 8);\n\t} else {\n\t\t \n\t\ttacls = tacls_max;\n\t\ttwrph0 = 8;\n\t\ttwrph1 = 8;\n\t}\n\n\tif (tacls < 0 || twrph0 < 0 || twrph1 < 0) {\n\t\tdev_err(info->device, \"cannot get suitable timings\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdev_info(info->device, \"Tacls=%d, %dns Twrph0=%d %dns, Twrph1=%d %dns\\n\",\n\t\ttacls, to_ns(tacls, clkrate), twrph0, to_ns(twrph0, clkrate),\n\t\t\t\t\t\ttwrph1, to_ns(twrph1, clkrate));\n\n\tswitch (info->cpu_type) {\n\tcase TYPE_S3C2410:\n\t\tmask = (S3C2410_NFCONF_TACLS(3) |\n\t\t\tS3C2410_NFCONF_TWRPH0(7) |\n\t\t\tS3C2410_NFCONF_TWRPH1(7));\n\t\tset = S3C2410_NFCONF_EN;\n\t\tset |= S3C2410_NFCONF_TACLS(tacls - 1);\n\t\tset |= S3C2410_NFCONF_TWRPH0(twrph0 - 1);\n\t\tset |= S3C2410_NFCONF_TWRPH1(twrph1 - 1);\n\t\tbreak;\n\n\tcase TYPE_S3C2440:\n\tcase TYPE_S3C2412:\n\t\tmask = (S3C2440_NFCONF_TACLS(tacls_max - 1) |\n\t\t\tS3C2440_NFCONF_TWRPH0(7) |\n\t\t\tS3C2440_NFCONF_TWRPH1(7));\n\n\t\tset = S3C2440_NFCONF_TACLS(tacls - 1);\n\t\tset |= S3C2440_NFCONF_TWRPH0(twrph0 - 1);\n\t\tset |= S3C2440_NFCONF_TWRPH1(twrph1 - 1);\n\t\tbreak;\n\n\tdefault:\n\t\tBUG();\n\t}\n\n\tlocal_irq_save(flags);\n\n\tcfg = readl(info->regs + S3C2410_NFCONF);\n\tcfg &= ~mask;\n\tcfg |= set;\n\twritel(cfg, info->regs + S3C2410_NFCONF);\n\n\tlocal_irq_restore(flags);\n\n\tdev_dbg(info->device, \"NF_CONF is 0x%lx\\n\", cfg);\n\n\treturn 0;\n}\n\n \nstatic int s3c2410_nand_inithw(struct s3c2410_nand_info *info)\n{\n\tint ret;\n\n\tret = s3c2410_nand_setrate(info);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tswitch (info->cpu_type) {\n\tcase TYPE_S3C2410:\n\tdefault:\n\t\tbreak;\n\n\tcase TYPE_S3C2440:\n\tcase TYPE_S3C2412:\n\t\t \n\n\t\twritel(S3C2440_NFCONT_ENABLE, info->regs + S3C2440_NFCONT);\n\t}\n\n\treturn 0;\n}\n\n \nstatic void s3c2410_nand_select_chip(struct nand_chip *this, int chip)\n{\n\tstruct s3c2410_nand_info *info;\n\tstruct s3c2410_nand_mtd *nmtd;\n\tunsigned long cur;\n\n\tnmtd = nand_get_controller_data(this);\n\tinfo = nmtd->info;\n\n\tif (chip != -1)\n\t\ts3c2410_nand_clk_set_state(info, CLOCK_ENABLE);\n\n\tcur = readl(info->sel_reg);\n\n\tif (chip == -1) {\n\t\tcur |= info->sel_bit;\n\t} else {\n\t\tif (nmtd->set != NULL && chip > nmtd->set->nr_chips) {\n\t\t\tdev_err(info->device, \"invalid chip %d\\n\", chip);\n\t\t\treturn;\n\t\t}\n\n\t\tif (info->platform != NULL) {\n\t\t\tif (info->platform->select_chip != NULL)\n\t\t\t\t(info->platform->select_chip) (nmtd->set, chip);\n\t\t}\n\n\t\tcur &= ~info->sel_bit;\n\t}\n\n\twritel(cur, info->sel_reg);\n\n\tif (chip == -1)\n\t\ts3c2410_nand_clk_set_state(info, CLOCK_SUSPEND);\n}\n\n \n\nstatic void s3c2410_nand_hwcontrol(struct nand_chip *chip, int cmd,\n\t\t\t\t   unsigned int ctrl)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tstruct s3c2410_nand_info *info = s3c2410_nand_mtd_toinfo(mtd);\n\n\tif (cmd == NAND_CMD_NONE)\n\t\treturn;\n\n\tif (ctrl & NAND_CLE)\n\t\twriteb(cmd, info->regs + S3C2410_NFCMD);\n\telse\n\t\twriteb(cmd, info->regs + S3C2410_NFADDR);\n}\n\n \n\nstatic void s3c2440_nand_hwcontrol(struct nand_chip *chip, int cmd,\n\t\t\t\t   unsigned int ctrl)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tstruct s3c2410_nand_info *info = s3c2410_nand_mtd_toinfo(mtd);\n\n\tif (cmd == NAND_CMD_NONE)\n\t\treturn;\n\n\tif (ctrl & NAND_CLE)\n\t\twriteb(cmd, info->regs + S3C2440_NFCMD);\n\telse\n\t\twriteb(cmd, info->regs + S3C2440_NFADDR);\n}\n\n \n\nstatic int s3c2410_nand_devready(struct nand_chip *chip)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tstruct s3c2410_nand_info *info = s3c2410_nand_mtd_toinfo(mtd);\n\treturn readb(info->regs + S3C2410_NFSTAT) & S3C2410_NFSTAT_BUSY;\n}\n\nstatic int s3c2440_nand_devready(struct nand_chip *chip)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tstruct s3c2410_nand_info *info = s3c2410_nand_mtd_toinfo(mtd);\n\treturn readb(info->regs + S3C2440_NFSTAT) & S3C2440_NFSTAT_READY;\n}\n\nstatic int s3c2412_nand_devready(struct nand_chip *chip)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tstruct s3c2410_nand_info *info = s3c2410_nand_mtd_toinfo(mtd);\n\treturn readb(info->regs + S3C2412_NFSTAT) & S3C2412_NFSTAT_READY;\n}\n\n \n\nstatic int s3c2410_nand_correct_data(struct nand_chip *chip, u_char *dat,\n\t\t\t\t     u_char *read_ecc, u_char *calc_ecc)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tstruct s3c2410_nand_info *info = s3c2410_nand_mtd_toinfo(mtd);\n\tunsigned int diff0, diff1, diff2;\n\tunsigned int bit, byte;\n\n\tpr_debug(\"%s(%p,%p,%p,%p)\\n\", __func__, mtd, dat, read_ecc, calc_ecc);\n\n\tdiff0 = read_ecc[0] ^ calc_ecc[0];\n\tdiff1 = read_ecc[1] ^ calc_ecc[1];\n\tdiff2 = read_ecc[2] ^ calc_ecc[2];\n\n\tpr_debug(\"%s: rd %*phN calc %*phN diff %02x%02x%02x\\n\",\n\t\t __func__, 3, read_ecc, 3, calc_ecc,\n\t\t diff0, diff1, diff2);\n\n\tif (diff0 == 0 && diff1 == 0 && diff2 == 0)\n\t\treturn 0;\t\t \n\n\t \n\tif (read_ecc[0] == 0xff && read_ecc[1] == 0xff && read_ecc[2] == 0xff\n\t    && info->platform->ignore_unset_ecc)\n\t\treturn 0;\n\n\t \n\n\tif (((diff0 ^ (diff0 >> 1)) & 0x55) == 0x55 &&\n\t    ((diff1 ^ (diff1 >> 1)) & 0x55) == 0x55 &&\n\t    ((diff2 ^ (diff2 >> 1)) & 0x55) == 0x55) {\n\t\t \n\n\t\tbit  = ((diff2 >> 3) & 1) |\n\t\t       ((diff2 >> 4) & 2) |\n\t\t       ((diff2 >> 5) & 4);\n\n\t\t \n\n\t\tbyte = ((diff2 << 7) & 0x100) |\n\t\t       ((diff1 << 0) & 0x80)  |\n\t\t       ((diff1 << 1) & 0x40)  |\n\t\t       ((diff1 << 2) & 0x20)  |\n\t\t       ((diff1 << 3) & 0x10)  |\n\t\t       ((diff0 >> 4) & 0x08)  |\n\t\t       ((diff0 >> 3) & 0x04)  |\n\t\t       ((diff0 >> 2) & 0x02)  |\n\t\t       ((diff0 >> 1) & 0x01);\n\n\t\tdev_dbg(info->device, \"correcting error bit %d, byte %d\\n\",\n\t\t\tbit, byte);\n\n\t\tdat[byte] ^= (1 << bit);\n\t\treturn 1;\n\t}\n\n\t \n\n\tdiff0 |= (diff1 << 8);\n\tdiff0 |= (diff2 << 16);\n\n\t \n\tif ((diff0 & (diff0 - 1)) == 0)\n\t\treturn 1;\n\n\treturn -1;\n}\n\n \n\nstatic void s3c2410_nand_enable_hwecc(struct nand_chip *chip, int mode)\n{\n\tstruct s3c2410_nand_info *info;\n\tunsigned long ctrl;\n\n\tinfo = s3c2410_nand_mtd_toinfo(nand_to_mtd(chip));\n\tctrl = readl(info->regs + S3C2410_NFCONF);\n\tctrl |= S3C2410_NFCONF_INITECC;\n\twritel(ctrl, info->regs + S3C2410_NFCONF);\n}\n\nstatic void s3c2412_nand_enable_hwecc(struct nand_chip *chip, int mode)\n{\n\tstruct s3c2410_nand_info *info;\n\tunsigned long ctrl;\n\n\tinfo = s3c2410_nand_mtd_toinfo(nand_to_mtd(chip));\n\tctrl = readl(info->regs + S3C2440_NFCONT);\n\twritel(ctrl | S3C2412_NFCONT_INIT_MAIN_ECC,\n\t       info->regs + S3C2440_NFCONT);\n}\n\nstatic void s3c2440_nand_enable_hwecc(struct nand_chip *chip, int mode)\n{\n\tstruct s3c2410_nand_info *info;\n\tunsigned long ctrl;\n\n\tinfo = s3c2410_nand_mtd_toinfo(nand_to_mtd(chip));\n\tctrl = readl(info->regs + S3C2440_NFCONT);\n\twritel(ctrl | S3C2440_NFCONT_INITECC, info->regs + S3C2440_NFCONT);\n}\n\nstatic int s3c2410_nand_calculate_ecc(struct nand_chip *chip,\n\t\t\t\t      const u_char *dat, u_char *ecc_code)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tstruct s3c2410_nand_info *info = s3c2410_nand_mtd_toinfo(mtd);\n\n\tecc_code[0] = readb(info->regs + S3C2410_NFECC + 0);\n\tecc_code[1] = readb(info->regs + S3C2410_NFECC + 1);\n\tecc_code[2] = readb(info->regs + S3C2410_NFECC + 2);\n\n\tpr_debug(\"%s: returning ecc %*phN\\n\", __func__, 3, ecc_code);\n\n\treturn 0;\n}\n\nstatic int s3c2412_nand_calculate_ecc(struct nand_chip *chip,\n\t\t\t\t      const u_char *dat, u_char *ecc_code)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tstruct s3c2410_nand_info *info = s3c2410_nand_mtd_toinfo(mtd);\n\tunsigned long ecc = readl(info->regs + S3C2412_NFMECC0);\n\n\tecc_code[0] = ecc;\n\tecc_code[1] = ecc >> 8;\n\tecc_code[2] = ecc >> 16;\n\n\tpr_debug(\"%s: returning ecc %*phN\\n\", __func__, 3, ecc_code);\n\n\treturn 0;\n}\n\nstatic int s3c2440_nand_calculate_ecc(struct nand_chip *chip,\n\t\t\t\t      const u_char *dat, u_char *ecc_code)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tstruct s3c2410_nand_info *info = s3c2410_nand_mtd_toinfo(mtd);\n\tunsigned long ecc = readl(info->regs + S3C2440_NFMECC0);\n\n\tecc_code[0] = ecc;\n\tecc_code[1] = ecc >> 8;\n\tecc_code[2] = ecc >> 16;\n\n\tpr_debug(\"%s: returning ecc %06lx\\n\", __func__, ecc & 0xffffff);\n\n\treturn 0;\n}\n\n \n\nstatic void s3c2410_nand_read_buf(struct nand_chip *this, u_char *buf, int len)\n{\n\treadsb(this->legacy.IO_ADDR_R, buf, len);\n}\n\nstatic void s3c2440_nand_read_buf(struct nand_chip *this, u_char *buf, int len)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(this);\n\tstruct s3c2410_nand_info *info = s3c2410_nand_mtd_toinfo(mtd);\n\n\treadsl(info->regs + S3C2440_NFDATA, buf, len >> 2);\n\n\t \n\tif (len & 3) {\n\t\tbuf += len & ~3;\n\n\t\tfor (; len & 3; len--)\n\t\t\t*buf++ = readb(info->regs + S3C2440_NFDATA);\n\t}\n}\n\nstatic void s3c2410_nand_write_buf(struct nand_chip *this, const u_char *buf,\n\t\t\t\t   int len)\n{\n\twritesb(this->legacy.IO_ADDR_W, buf, len);\n}\n\nstatic void s3c2440_nand_write_buf(struct nand_chip *this, const u_char *buf,\n\t\t\t\t   int len)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(this);\n\tstruct s3c2410_nand_info *info = s3c2410_nand_mtd_toinfo(mtd);\n\n\twritesl(info->regs + S3C2440_NFDATA, buf, len >> 2);\n\n\t \n\tif (len & 3) {\n\t\tbuf += len & ~3;\n\n\t\tfor (; len & 3; len--, buf++)\n\t\t\twriteb(*buf, info->regs + S3C2440_NFDATA);\n\t}\n}\n\n \n\nstatic void s3c24xx_nand_remove(struct platform_device *pdev)\n{\n\tstruct s3c2410_nand_info *info = to_nand_info(pdev);\n\n\tif (info == NULL)\n\t\treturn;\n\n\t \n\n\tif (info->mtds != NULL) {\n\t\tstruct s3c2410_nand_mtd *ptr = info->mtds;\n\t\tint mtdno;\n\n\t\tfor (mtdno = 0; mtdno < info->mtd_count; mtdno++, ptr++) {\n\t\t\tpr_debug(\"releasing mtd %d (%p)\\n\", mtdno, ptr);\n\t\t\tWARN_ON(mtd_device_unregister(nand_to_mtd(&ptr->chip)));\n\t\t\tnand_cleanup(&ptr->chip);\n\t\t}\n\t}\n\n\t \n\n\tif (!IS_ERR(info->clk))\n\t\ts3c2410_nand_clk_set_state(info, CLOCK_DISABLE);\n}\n\nstatic int s3c2410_nand_add_partition(struct s3c2410_nand_info *info,\n\t\t\t\t      struct s3c2410_nand_mtd *mtd,\n\t\t\t\t      struct s3c2410_nand_set *set)\n{\n\tif (set) {\n\t\tstruct mtd_info *mtdinfo = nand_to_mtd(&mtd->chip);\n\n\t\tmtdinfo->name = set->name;\n\n\t\treturn mtd_device_register(mtdinfo, set->partitions,\n\t\t\t\t\t   set->nr_partitions);\n\t}\n\n\treturn -ENODEV;\n}\n\nstatic int s3c2410_nand_setup_interface(struct nand_chip *chip, int csline,\n\t\t\t\t\tconst struct nand_interface_config *conf)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tstruct s3c2410_nand_info *info = s3c2410_nand_mtd_toinfo(mtd);\n\tstruct s3c2410_platform_nand *pdata = info->platform;\n\tconst struct nand_sdr_timings *timings;\n\tint tacls;\n\n\ttimings = nand_get_sdr_timings(conf);\n\tif (IS_ERR(timings))\n\t\treturn -ENOTSUPP;\n\n\ttacls = timings->tCLS_min - timings->tWP_min;\n\tif (tacls < 0)\n\t\ttacls = 0;\n\n\tpdata->tacls  = DIV_ROUND_UP(tacls, 1000);\n\tpdata->twrph0 = DIV_ROUND_UP(timings->tWP_min, 1000);\n\tpdata->twrph1 = DIV_ROUND_UP(timings->tCLH_min, 1000);\n\n\treturn s3c2410_nand_setrate(info);\n}\n\n \nstatic void s3c2410_nand_init_chip(struct s3c2410_nand_info *info,\n\t\t\t\t   struct s3c2410_nand_mtd *nmtd,\n\t\t\t\t   struct s3c2410_nand_set *set)\n{\n\tstruct device_node *np = info->device->of_node;\n\tstruct nand_chip *chip = &nmtd->chip;\n\tvoid __iomem *regs = info->regs;\n\n\tnand_set_flash_node(chip, set->of_node);\n\n\tchip->legacy.write_buf    = s3c2410_nand_write_buf;\n\tchip->legacy.read_buf     = s3c2410_nand_read_buf;\n\tchip->legacy.select_chip  = s3c2410_nand_select_chip;\n\tchip->legacy.chip_delay   = 50;\n\tnand_set_controller_data(chip, nmtd);\n\tchip->options\t   = set->options;\n\tchip->controller   = &info->controller;\n\n\t \n\tif (!np)\n\t\tchip->options |= NAND_KEEP_TIMINGS;\n\n\tswitch (info->cpu_type) {\n\tcase TYPE_S3C2410:\n\t\tchip->legacy.IO_ADDR_W = regs + S3C2410_NFDATA;\n\t\tinfo->sel_reg   = regs + S3C2410_NFCONF;\n\t\tinfo->sel_bit\t= S3C2410_NFCONF_nFCE;\n\t\tchip->legacy.cmd_ctrl  = s3c2410_nand_hwcontrol;\n\t\tchip->legacy.dev_ready = s3c2410_nand_devready;\n\t\tbreak;\n\n\tcase TYPE_S3C2440:\n\t\tchip->legacy.IO_ADDR_W = regs + S3C2440_NFDATA;\n\t\tinfo->sel_reg   = regs + S3C2440_NFCONT;\n\t\tinfo->sel_bit\t= S3C2440_NFCONT_nFCE;\n\t\tchip->legacy.cmd_ctrl  = s3c2440_nand_hwcontrol;\n\t\tchip->legacy.dev_ready = s3c2440_nand_devready;\n\t\tchip->legacy.read_buf  = s3c2440_nand_read_buf;\n\t\tchip->legacy.write_buf\t= s3c2440_nand_write_buf;\n\t\tbreak;\n\n\tcase TYPE_S3C2412:\n\t\tchip->legacy.IO_ADDR_W = regs + S3C2440_NFDATA;\n\t\tinfo->sel_reg   = regs + S3C2440_NFCONT;\n\t\tinfo->sel_bit\t= S3C2412_NFCONT_nFCE0;\n\t\tchip->legacy.cmd_ctrl  = s3c2440_nand_hwcontrol;\n\t\tchip->legacy.dev_ready = s3c2412_nand_devready;\n\n\t\tif (readl(regs + S3C2410_NFCONF) & S3C2412_NFCONF_NANDBOOT)\n\t\t\tdev_info(info->device, \"System booted from NAND\\n\");\n\n\t\tbreak;\n\t}\n\n\tchip->legacy.IO_ADDR_R = chip->legacy.IO_ADDR_W;\n\n\tnmtd->info\t   = info;\n\tnmtd->set\t   = set;\n\n\tchip->ecc.engine_type = info->platform->engine_type;\n\n\t \n\tif (set->flash_bbt)\n\t\tchip->bbt_options |= NAND_BBT_USE_FLASH;\n}\n\n \nstatic int s3c2410_nand_attach_chip(struct nand_chip *chip)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tstruct s3c2410_nand_info *info = s3c2410_nand_mtd_toinfo(mtd);\n\n\tswitch (chip->ecc.engine_type) {\n\n\tcase NAND_ECC_ENGINE_TYPE_NONE:\n\t\tdev_info(info->device, \"ECC disabled\\n\");\n\t\tbreak;\n\n\tcase NAND_ECC_ENGINE_TYPE_SOFT:\n\t\t \n\t\tchip->ecc.algo = NAND_ECC_ALGO_HAMMING;\n\t\tdev_info(info->device, \"soft ECC\\n\");\n\t\tbreak;\n\n\tcase NAND_ECC_ENGINE_TYPE_ON_HOST:\n\t\tchip->ecc.calculate = s3c2410_nand_calculate_ecc;\n\t\tchip->ecc.correct   = s3c2410_nand_correct_data;\n\t\tchip->ecc.strength  = 1;\n\n\t\tswitch (info->cpu_type) {\n\t\tcase TYPE_S3C2410:\n\t\t\tchip->ecc.hwctl\t    = s3c2410_nand_enable_hwecc;\n\t\t\tchip->ecc.calculate = s3c2410_nand_calculate_ecc;\n\t\t\tbreak;\n\n\t\tcase TYPE_S3C2412:\n\t\t\tchip->ecc.hwctl     = s3c2412_nand_enable_hwecc;\n\t\t\tchip->ecc.calculate = s3c2412_nand_calculate_ecc;\n\t\t\tbreak;\n\n\t\tcase TYPE_S3C2440:\n\t\t\tchip->ecc.hwctl     = s3c2440_nand_enable_hwecc;\n\t\t\tchip->ecc.calculate = s3c2440_nand_calculate_ecc;\n\t\t\tbreak;\n\t\t}\n\n\t\tdev_dbg(info->device, \"chip %p => page shift %d\\n\",\n\t\t\tchip, chip->page_shift);\n\n\t\t \n\t\tif (chip->page_shift > 10) {\n\t\t\tchip->ecc.size\t    = 256;\n\t\t\tchip->ecc.bytes\t    = 3;\n\t\t} else {\n\t\t\tchip->ecc.size\t    = 512;\n\t\t\tchip->ecc.bytes\t    = 3;\n\t\t\tmtd_set_ooblayout(nand_to_mtd(chip),\n\t\t\t\t\t  &s3c2410_ooblayout_ops);\n\t\t}\n\n\t\tdev_info(info->device, \"hardware ECC\\n\");\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(info->device, \"invalid ECC mode!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (chip->bbt_options & NAND_BBT_USE_FLASH)\n\t\tchip->options |= NAND_SKIP_BBTSCAN;\n\n\treturn 0;\n}\n\nstatic const struct nand_controller_ops s3c24xx_nand_controller_ops = {\n\t.attach_chip = s3c2410_nand_attach_chip,\n\t.setup_interface = s3c2410_nand_setup_interface,\n};\n\nstatic const struct of_device_id s3c24xx_nand_dt_ids[] = {\n\t{\n\t\t.compatible = \"samsung,s3c2410-nand\",\n\t\t.data = &s3c2410_nand_devtype_data,\n\t}, {\n\t\t \n\t\t.compatible = \"samsung,s3c2412-nand\",\n\t\t.data = &s3c2412_nand_devtype_data,\n\t}, {\n\t\t.compatible = \"samsung,s3c2440-nand\",\n\t\t.data = &s3c2440_nand_devtype_data,\n\t},\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, s3c24xx_nand_dt_ids);\n\nstatic int s3c24xx_nand_probe_dt(struct platform_device *pdev)\n{\n\tconst struct s3c24XX_nand_devtype_data *devtype_data;\n\tstruct s3c2410_platform_nand *pdata;\n\tstruct s3c2410_nand_info *info = platform_get_drvdata(pdev);\n\tstruct device_node *np = pdev->dev.of_node, *child;\n\tstruct s3c2410_nand_set *sets;\n\n\tdevtype_data = of_device_get_match_data(&pdev->dev);\n\tif (!devtype_data)\n\t\treturn -ENODEV;\n\n\tinfo->cpu_type = devtype_data->type;\n\n\tpdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);\n\tif (!pdata)\n\t\treturn -ENOMEM;\n\n\tpdev->dev.platform_data = pdata;\n\n\tpdata->nr_sets = of_get_child_count(np);\n\tif (!pdata->nr_sets)\n\t\treturn 0;\n\n\tsets = devm_kcalloc(&pdev->dev, pdata->nr_sets, sizeof(*sets),\n\t\t\t    GFP_KERNEL);\n\tif (!sets)\n\t\treturn -ENOMEM;\n\n\tpdata->sets = sets;\n\n\tfor_each_available_child_of_node(np, child) {\n\t\tsets->name = (char *)child->name;\n\t\tsets->of_node = child;\n\t\tsets->nr_chips = 1;\n\n\t\tof_node_get(child);\n\n\t\tsets++;\n\t}\n\n\treturn 0;\n}\n\nstatic int s3c24xx_nand_probe_pdata(struct platform_device *pdev)\n{\n\tstruct s3c2410_nand_info *info = platform_get_drvdata(pdev);\n\n\tinfo->cpu_type = platform_get_device_id(pdev)->driver_data;\n\n\treturn 0;\n}\n\n \nstatic int s3c24xx_nand_probe(struct platform_device *pdev)\n{\n\tstruct s3c2410_platform_nand *plat;\n\tstruct s3c2410_nand_info *info;\n\tstruct s3c2410_nand_mtd *nmtd;\n\tstruct s3c2410_nand_set *sets;\n\tstruct resource *res;\n\tint err = 0;\n\tint size;\n\tint nr_sets;\n\tint setno;\n\n\tinfo = devm_kzalloc(&pdev->dev, sizeof(*info), GFP_KERNEL);\n\tif (info == NULL) {\n\t\terr = -ENOMEM;\n\t\tgoto exit_error;\n\t}\n\n\tplatform_set_drvdata(pdev, info);\n\n\tnand_controller_init(&info->controller);\n\tinfo->controller.ops = &s3c24xx_nand_controller_ops;\n\n\t \n\n\tinfo->clk = devm_clk_get(&pdev->dev, \"nand\");\n\tif (IS_ERR(info->clk)) {\n\t\tdev_err(&pdev->dev, \"failed to get clock\\n\");\n\t\terr = -ENOENT;\n\t\tgoto exit_error;\n\t}\n\n\ts3c2410_nand_clk_set_state(info, CLOCK_ENABLE);\n\n\tif (pdev->dev.of_node)\n\t\terr = s3c24xx_nand_probe_dt(pdev);\n\telse\n\t\terr = s3c24xx_nand_probe_pdata(pdev);\n\n\tif (err)\n\t\tgoto exit_error;\n\n\tplat = to_nand_plat(pdev);\n\n\t \n\n\t \n\tres = pdev->resource;\n\tsize = resource_size(res);\n\n\tinfo->device\t= &pdev->dev;\n\tinfo->platform\t= plat;\n\n\tinfo->regs = devm_ioremap_resource(&pdev->dev, res);\n\tif (IS_ERR(info->regs)) {\n\t\terr = PTR_ERR(info->regs);\n\t\tgoto exit_error;\n\t}\n\n\tdev_dbg(&pdev->dev, \"mapped registers at %p\\n\", info->regs);\n\n\tif (!plat->sets || plat->nr_sets < 1) {\n\t\terr = -EINVAL;\n\t\tgoto exit_error;\n\t}\n\n\tsets = plat->sets;\n\tnr_sets = plat->nr_sets;\n\n\tinfo->mtd_count = nr_sets;\n\n\t \n\n\tsize = nr_sets * sizeof(*info->mtds);\n\tinfo->mtds = devm_kzalloc(&pdev->dev, size, GFP_KERNEL);\n\tif (info->mtds == NULL) {\n\t\terr = -ENOMEM;\n\t\tgoto exit_error;\n\t}\n\n\t \n\n\tnmtd = info->mtds;\n\n\tfor (setno = 0; setno < nr_sets; setno++, nmtd++, sets++) {\n\t\tstruct mtd_info *mtd = nand_to_mtd(&nmtd->chip);\n\n\t\tpr_debug(\"initialising set %d (%p, info %p)\\n\",\n\t\t\t setno, nmtd, info);\n\n\t\tmtd->dev.parent = &pdev->dev;\n\t\ts3c2410_nand_init_chip(info, nmtd, sets);\n\n\t\terr = nand_scan(&nmtd->chip, sets ? sets->nr_chips : 1);\n\t\tif (err)\n\t\t\tgoto exit_error;\n\n\t\ts3c2410_nand_add_partition(info, nmtd, sets);\n\t}\n\n\t \n\terr = s3c2410_nand_inithw(info);\n\tif (err != 0)\n\t\tgoto exit_error;\n\n\tif (allow_clk_suspend(info)) {\n\t\tdev_info(&pdev->dev, \"clock idle support enabled\\n\");\n\t\ts3c2410_nand_clk_set_state(info, CLOCK_SUSPEND);\n\t}\n\n\treturn 0;\n\n exit_error:\n\ts3c24xx_nand_remove(pdev);\n\n\tif (err == 0)\n\t\terr = -EINVAL;\n\treturn err;\n}\n\n \n#ifdef CONFIG_PM\n\nstatic int s3c24xx_nand_suspend(struct platform_device *dev, pm_message_t pm)\n{\n\tstruct s3c2410_nand_info *info = platform_get_drvdata(dev);\n\n\tif (info) {\n\t\tinfo->save_sel = readl(info->sel_reg);\n\n\t\t \n\n\t\twritel(info->save_sel | info->sel_bit, info->sel_reg);\n\n\t\ts3c2410_nand_clk_set_state(info, CLOCK_DISABLE);\n\t}\n\n\treturn 0;\n}\n\nstatic int s3c24xx_nand_resume(struct platform_device *dev)\n{\n\tstruct s3c2410_nand_info *info = platform_get_drvdata(dev);\n\tunsigned long sel;\n\n\tif (info) {\n\t\ts3c2410_nand_clk_set_state(info, CLOCK_ENABLE);\n\t\ts3c2410_nand_inithw(info);\n\n\t\t \n\n\t\tsel = readl(info->sel_reg);\n\t\tsel &= ~info->sel_bit;\n\t\tsel |= info->save_sel & info->sel_bit;\n\t\twritel(sel, info->sel_reg);\n\n\t\ts3c2410_nand_clk_set_state(info, CLOCK_SUSPEND);\n\t}\n\n\treturn 0;\n}\n\n#else\n#define s3c24xx_nand_suspend NULL\n#define s3c24xx_nand_resume NULL\n#endif\n\n \n\nstatic const struct platform_device_id s3c24xx_driver_ids[] = {\n\t{\n\t\t.name\t\t= \"s3c2410-nand\",\n\t\t.driver_data\t= TYPE_S3C2410,\n\t}, {\n\t\t.name\t\t= \"s3c2440-nand\",\n\t\t.driver_data\t= TYPE_S3C2440,\n\t}, {\n\t\t.name\t\t= \"s3c2412-nand\",\n\t\t.driver_data\t= TYPE_S3C2412,\n\t}, {\n\t\t.name\t\t= \"s3c6400-nand\",\n\t\t.driver_data\t= TYPE_S3C2412,  \n\t},\n\t{ }\n};\n\nMODULE_DEVICE_TABLE(platform, s3c24xx_driver_ids);\n\nstatic struct platform_driver s3c24xx_nand_driver = {\n\t.probe\t\t= s3c24xx_nand_probe,\n\t.remove_new\t= s3c24xx_nand_remove,\n\t.suspend\t= s3c24xx_nand_suspend,\n\t.resume\t\t= s3c24xx_nand_resume,\n\t.id_table\t= s3c24xx_driver_ids,\n\t.driver\t\t= {\n\t\t.name\t= \"s3c24xx-nand\",\n\t\t.of_match_table = s3c24xx_nand_dt_ids,\n\t},\n};\n\nmodule_platform_driver(s3c24xx_nand_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Ben Dooks <ben@simtec.co.uk>\");\nMODULE_DESCRIPTION(\"S3C24XX MTD NAND driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}