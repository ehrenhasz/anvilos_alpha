{
  "module_name": "gpio.c",
  "hash_id": "389e8325345439cd48a40a540eef31b693a85733d65298feeeb9004548735ea4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/nand/raw/gpio.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/gpio/consumer.h>\n#include <linux/io.h>\n#include <linux/mtd/mtd.h>\n#include <linux/mtd/rawnand.h>\n#include <linux/mtd/partitions.h>\n#include <linux/mtd/nand-gpio.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/delay.h>\n\nstruct gpiomtd {\n\tstruct nand_controller\tbase;\n\tvoid __iomem\t\t*io;\n\tvoid __iomem\t\t*io_sync;\n\tstruct nand_chip\tnand_chip;\n\tstruct gpio_nand_platdata plat;\n\tstruct gpio_desc *nce;  \n\tstruct gpio_desc *cle;\n\tstruct gpio_desc *ale;\n\tstruct gpio_desc *rdy;\n\tstruct gpio_desc *nwp;  \n};\n\nstatic inline struct gpiomtd *gpio_nand_getpriv(struct mtd_info *mtd)\n{\n\treturn container_of(mtd_to_nand(mtd), struct gpiomtd, nand_chip);\n}\n\n\n#ifdef CONFIG_ARM\n \nstatic void gpio_nand_dosync(struct gpiomtd *gpiomtd)\n{\n\tunsigned long tmp;\n\n\tif (gpiomtd->io_sync) {\n\t\t \n\t\ttmp = readl(gpiomtd->io_sync);\n\t\tasm volatile(\"mov %1, %0\\n\" : \"=r\" (tmp) : \"r\" (tmp));\n\t}\n}\n#else\nstatic inline void gpio_nand_dosync(struct gpiomtd *gpiomtd) {}\n#endif\n\nstatic int gpio_nand_exec_instr(struct nand_chip *chip,\n\t\t\t\tconst struct nand_op_instr *instr)\n{\n\tstruct gpiomtd *gpiomtd = gpio_nand_getpriv(nand_to_mtd(chip));\n\tunsigned int i;\n\n\tswitch (instr->type) {\n\tcase NAND_OP_CMD_INSTR:\n\t\tgpio_nand_dosync(gpiomtd);\n\t\tgpiod_set_value(gpiomtd->cle, 1);\n\t\tgpio_nand_dosync(gpiomtd);\n\t\twriteb(instr->ctx.cmd.opcode, gpiomtd->io);\n\t\tgpio_nand_dosync(gpiomtd);\n\t\tgpiod_set_value(gpiomtd->cle, 0);\n\t\treturn 0;\n\n\tcase NAND_OP_ADDR_INSTR:\n\t\tgpio_nand_dosync(gpiomtd);\n\t\tgpiod_set_value(gpiomtd->ale, 1);\n\t\tgpio_nand_dosync(gpiomtd);\n\t\tfor (i = 0; i < instr->ctx.addr.naddrs; i++)\n\t\t\twriteb(instr->ctx.addr.addrs[i], gpiomtd->io);\n\t\tgpio_nand_dosync(gpiomtd);\n\t\tgpiod_set_value(gpiomtd->ale, 0);\n\t\treturn 0;\n\n\tcase NAND_OP_DATA_IN_INSTR:\n\t\tgpio_nand_dosync(gpiomtd);\n\t\tif ((chip->options & NAND_BUSWIDTH_16) &&\n\t\t    !instr->ctx.data.force_8bit)\n\t\t\tioread16_rep(gpiomtd->io, instr->ctx.data.buf.in,\n\t\t\t\t     instr->ctx.data.len / 2);\n\t\telse\n\t\t\tioread8_rep(gpiomtd->io, instr->ctx.data.buf.in,\n\t\t\t\t    instr->ctx.data.len);\n\t\treturn 0;\n\n\tcase NAND_OP_DATA_OUT_INSTR:\n\t\tgpio_nand_dosync(gpiomtd);\n\t\tif ((chip->options & NAND_BUSWIDTH_16) &&\n\t\t    !instr->ctx.data.force_8bit)\n\t\t\tiowrite16_rep(gpiomtd->io, instr->ctx.data.buf.out,\n\t\t\t\t      instr->ctx.data.len / 2);\n\t\telse\n\t\t\tiowrite8_rep(gpiomtd->io, instr->ctx.data.buf.out,\n\t\t\t\t     instr->ctx.data.len);\n\t\treturn 0;\n\n\tcase NAND_OP_WAITRDY_INSTR:\n\t\tif (!gpiomtd->rdy)\n\t\t\treturn nand_soft_waitrdy(chip, instr->ctx.waitrdy.timeout_ms);\n\n\t\treturn nand_gpio_waitrdy(chip, gpiomtd->rdy,\n\t\t\t\t\t instr->ctx.waitrdy.timeout_ms);\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int gpio_nand_exec_op(struct nand_chip *chip,\n\t\t\t     const struct nand_operation *op,\n\t\t\t     bool check_only)\n{\n\tstruct gpiomtd *gpiomtd = gpio_nand_getpriv(nand_to_mtd(chip));\n\tunsigned int i;\n\tint ret = 0;\n\n\tif (check_only)\n\t\treturn 0;\n\n\tgpio_nand_dosync(gpiomtd);\n\tgpiod_set_value(gpiomtd->nce, 0);\n\tfor (i = 0; i < op->ninstrs; i++) {\n\t\tret = gpio_nand_exec_instr(chip, &op->instrs[i]);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tif (op->instrs[i].delay_ns)\n\t\t\tndelay(op->instrs[i].delay_ns);\n\t}\n\tgpio_nand_dosync(gpiomtd);\n\tgpiod_set_value(gpiomtd->nce, 1);\n\n\treturn ret;\n}\n\nstatic int gpio_nand_attach_chip(struct nand_chip *chip)\n{\n\tif (chip->ecc.engine_type == NAND_ECC_ENGINE_TYPE_SOFT &&\n\t    chip->ecc.algo == NAND_ECC_ALGO_UNKNOWN)\n\t\tchip->ecc.algo = NAND_ECC_ALGO_HAMMING;\n\n\treturn 0;\n}\n\nstatic const struct nand_controller_ops gpio_nand_ops = {\n\t.exec_op = gpio_nand_exec_op,\n\t.attach_chip = gpio_nand_attach_chip,\n};\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id gpio_nand_id_table[] = {\n\t{ .compatible = \"gpio-control-nand\" },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, gpio_nand_id_table);\n\nstatic int gpio_nand_get_config_of(const struct device *dev,\n\t\t\t\t   struct gpio_nand_platdata *plat)\n{\n\tu32 val;\n\n\tif (!dev->of_node)\n\t\treturn -ENODEV;\n\n\tif (!of_property_read_u32(dev->of_node, \"bank-width\", &val)) {\n\t\tif (val == 2) {\n\t\t\tplat->options |= NAND_BUSWIDTH_16;\n\t\t} else if (val != 1) {\n\t\t\tdev_err(dev, \"invalid bank-width %u\\n\", val);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (!of_property_read_u32(dev->of_node, \"chip-delay\", &val))\n\t\tplat->chip_delay = val;\n\n\treturn 0;\n}\n\nstatic struct resource *gpio_nand_get_io_sync_of(struct platform_device *pdev)\n{\n\tstruct resource *r;\n\tu64 addr;\n\n\tif (of_property_read_u64(pdev->dev.of_node,\n\t\t\t\t       \"gpio-control-nand,io-sync-reg\", &addr))\n\t\treturn NULL;\n\n\tr = devm_kzalloc(&pdev->dev, sizeof(*r), GFP_KERNEL);\n\tif (!r)\n\t\treturn NULL;\n\n\tr->start = addr;\n\tr->end = r->start + 0x3;\n\tr->flags = IORESOURCE_MEM;\n\n\treturn r;\n}\n#else  \nstatic inline int gpio_nand_get_config_of(const struct device *dev,\n\t\t\t\t\t  struct gpio_nand_platdata *plat)\n{\n\treturn -ENOSYS;\n}\n\nstatic inline struct resource *\ngpio_nand_get_io_sync_of(struct platform_device *pdev)\n{\n\treturn NULL;\n}\n#endif  \n\nstatic inline int gpio_nand_get_config(const struct device *dev,\n\t\t\t\t       struct gpio_nand_platdata *plat)\n{\n\tint ret = gpio_nand_get_config_of(dev, plat);\n\n\tif (!ret)\n\t\treturn ret;\n\n\tif (dev_get_platdata(dev)) {\n\t\tmemcpy(plat, dev_get_platdata(dev), sizeof(*plat));\n\t\treturn 0;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic inline struct resource *\ngpio_nand_get_io_sync(struct platform_device *pdev)\n{\n\tstruct resource *r = gpio_nand_get_io_sync_of(pdev);\n\n\tif (r)\n\t\treturn r;\n\n\treturn platform_get_resource(pdev, IORESOURCE_MEM, 1);\n}\n\nstatic void gpio_nand_remove(struct platform_device *pdev)\n{\n\tstruct gpiomtd *gpiomtd = platform_get_drvdata(pdev);\n\tstruct nand_chip *chip = &gpiomtd->nand_chip;\n\tint ret;\n\n\tret = mtd_device_unregister(nand_to_mtd(chip));\n\tWARN_ON(ret);\n\tnand_cleanup(chip);\n\n\t \n\tif (gpiomtd->nwp && !IS_ERR(gpiomtd->nwp))\n\t\tgpiod_set_value(gpiomtd->nwp, 0);\n\tif (gpiomtd->nce && !IS_ERR(gpiomtd->nce))\n\t\tgpiod_set_value(gpiomtd->nce, 0);\n}\n\nstatic int gpio_nand_probe(struct platform_device *pdev)\n{\n\tstruct gpiomtd *gpiomtd;\n\tstruct nand_chip *chip;\n\tstruct mtd_info *mtd;\n\tstruct resource *res;\n\tstruct device *dev = &pdev->dev;\n\tint ret = 0;\n\n\tif (!dev->of_node && !dev_get_platdata(dev))\n\t\treturn -EINVAL;\n\n\tgpiomtd = devm_kzalloc(dev, sizeof(*gpiomtd), GFP_KERNEL);\n\tif (!gpiomtd)\n\t\treturn -ENOMEM;\n\n\tchip = &gpiomtd->nand_chip;\n\n\tgpiomtd->io = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(gpiomtd->io))\n\t\treturn PTR_ERR(gpiomtd->io);\n\n\tres = gpio_nand_get_io_sync(pdev);\n\tif (res) {\n\t\tgpiomtd->io_sync = devm_ioremap_resource(dev, res);\n\t\tif (IS_ERR(gpiomtd->io_sync))\n\t\t\treturn PTR_ERR(gpiomtd->io_sync);\n\t}\n\n\tret = gpio_nand_get_config(dev, &gpiomtd->plat);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tgpiomtd->nce = devm_gpiod_get_optional(dev, \"nce\", GPIOD_OUT_HIGH);\n\tif (IS_ERR(gpiomtd->nce))\n\t\treturn PTR_ERR(gpiomtd->nce);\n\n\t \n\tgpiomtd->nwp = devm_gpiod_get_optional(dev, \"nwp\", GPIOD_OUT_LOW);\n\tif (IS_ERR(gpiomtd->nwp)) {\n\t\tret = PTR_ERR(gpiomtd->nwp);\n\t\tgoto out_ce;\n\t}\n\n\tgpiomtd->ale = devm_gpiod_get(dev, \"ale\", GPIOD_OUT_LOW);\n\tif (IS_ERR(gpiomtd->ale)) {\n\t\tret = PTR_ERR(gpiomtd->ale);\n\t\tgoto out_ce;\n\t}\n\n\tgpiomtd->cle = devm_gpiod_get(dev, \"cle\", GPIOD_OUT_LOW);\n\tif (IS_ERR(gpiomtd->cle)) {\n\t\tret = PTR_ERR(gpiomtd->cle);\n\t\tgoto out_ce;\n\t}\n\n\tgpiomtd->rdy = devm_gpiod_get_optional(dev, \"rdy\", GPIOD_IN);\n\tif (IS_ERR(gpiomtd->rdy)) {\n\t\tret = PTR_ERR(gpiomtd->rdy);\n\t\tgoto out_ce;\n\t}\n\n\tnand_controller_init(&gpiomtd->base);\n\tgpiomtd->base.ops = &gpio_nand_ops;\n\n\tnand_set_flash_node(chip, pdev->dev.of_node);\n\tchip->options\t\t= gpiomtd->plat.options;\n\tchip->controller\t= &gpiomtd->base;\n\n\tmtd\t\t\t= nand_to_mtd(chip);\n\tmtd->dev.parent\t\t= dev;\n\n\tplatform_set_drvdata(pdev, gpiomtd);\n\n\t \n\tif (gpiomtd->nwp && !IS_ERR(gpiomtd->nwp))\n\t\tgpiod_direction_output(gpiomtd->nwp, 1);\n\n\t \n\tchip->ecc.engine_type = NAND_ECC_ENGINE_TYPE_SOFT;\n\n\tret = nand_scan(chip, 1);\n\tif (ret)\n\t\tgoto err_wp;\n\n\tif (gpiomtd->plat.adjust_parts)\n\t\tgpiomtd->plat.adjust_parts(&gpiomtd->plat, mtd->size);\n\n\tret = mtd_device_register(mtd, gpiomtd->plat.parts,\n\t\t\t\t  gpiomtd->plat.num_parts);\n\tif (!ret)\n\t\treturn 0;\n\nerr_wp:\n\tif (gpiomtd->nwp && !IS_ERR(gpiomtd->nwp))\n\t\tgpiod_set_value(gpiomtd->nwp, 0);\nout_ce:\n\tif (gpiomtd->nce && !IS_ERR(gpiomtd->nce))\n\t\tgpiod_set_value(gpiomtd->nce, 0);\n\n\treturn ret;\n}\n\nstatic struct platform_driver gpio_nand_driver = {\n\t.probe\t\t= gpio_nand_probe,\n\t.remove_new\t= gpio_nand_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"gpio-nand\",\n\t\t.of_match_table = of_match_ptr(gpio_nand_id_table),\n\t},\n};\n\nmodule_platform_driver(gpio_nand_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Ben Dooks <ben@simtec.co.uk>\");\nMODULE_DESCRIPTION(\"GPIO NAND Driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}