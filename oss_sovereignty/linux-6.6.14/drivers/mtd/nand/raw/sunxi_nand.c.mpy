{
  "module_name": "sunxi_nand.c",
  "hash_id": "32e6c6b546e24cf97886a892bad97f6c19c8bfb3a6f669657392814f72b8df31",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/nand/raw/sunxi_nand.c",
  "human_readable_source": "\n \n\n#include <linux/dma-mapping.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/platform_device.h>\n#include <linux/of.h>\n#include <linux/mtd/mtd.h>\n#include <linux/mtd/rawnand.h>\n#include <linux/mtd/partitions.h>\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/dmaengine.h>\n#include <linux/interrupt.h>\n#include <linux/iopoll.h>\n#include <linux/reset.h>\n\n#define NFC_REG_CTL\t\t0x0000\n#define NFC_REG_ST\t\t0x0004\n#define NFC_REG_INT\t\t0x0008\n#define NFC_REG_TIMING_CTL\t0x000C\n#define NFC_REG_TIMING_CFG\t0x0010\n#define NFC_REG_ADDR_LOW\t0x0014\n#define NFC_REG_ADDR_HIGH\t0x0018\n#define NFC_REG_SECTOR_NUM\t0x001C\n#define NFC_REG_CNT\t\t0x0020\n#define NFC_REG_CMD\t\t0x0024\n#define NFC_REG_RCMD_SET\t0x0028\n#define NFC_REG_WCMD_SET\t0x002C\n#define NFC_REG_A10_IO_DATA\t0x0030\n#define NFC_REG_A23_IO_DATA\t0x0300\n#define NFC_REG_ECC_CTL\t\t0x0034\n#define NFC_REG_ECC_ST\t\t0x0038\n#define NFC_REG_DEBUG\t\t0x003C\n#define NFC_REG_ECC_ERR_CNT(x)\t((0x0040 + (x)) & ~0x3)\n#define NFC_REG_USER_DATA(x)\t(0x0050 + ((x) * 4))\n#define NFC_REG_SPARE_AREA\t0x00A0\n#define NFC_REG_PAT_ID\t\t0x00A4\n#define NFC_REG_MDMA_ADDR\t0x00C0\n#define NFC_REG_MDMA_CNT\t0x00C4\n#define NFC_RAM0_BASE\t\t0x0400\n#define NFC_RAM1_BASE\t\t0x0800\n\n \n#define NFC_EN\t\t\tBIT(0)\n#define NFC_RESET\t\tBIT(1)\n#define NFC_BUS_WIDTH_MSK\tBIT(2)\n#define NFC_BUS_WIDTH_8\t\t(0 << 2)\n#define NFC_BUS_WIDTH_16\t(1 << 2)\n#define NFC_RB_SEL_MSK\t\tBIT(3)\n#define NFC_RB_SEL(x)\t\t((x) << 3)\n#define NFC_CE_SEL_MSK\t\tGENMASK(26, 24)\n#define NFC_CE_SEL(x)\t\t((x) << 24)\n#define NFC_CE_CTL\t\tBIT(6)\n#define NFC_PAGE_SHIFT_MSK\tGENMASK(11, 8)\n#define NFC_PAGE_SHIFT(x)\t(((x) < 10 ? 0 : (x) - 10) << 8)\n#define NFC_SAM\t\t\tBIT(12)\n#define NFC_RAM_METHOD\t\tBIT(14)\n#define NFC_DMA_TYPE_NORMAL\tBIT(15)\n#define NFC_DEBUG_CTL\t\tBIT(31)\n\n \n#define NFC_RB_B2R\t\tBIT(0)\n#define NFC_CMD_INT_FLAG\tBIT(1)\n#define NFC_DMA_INT_FLAG\tBIT(2)\n#define NFC_CMD_FIFO_STATUS\tBIT(3)\n#define NFC_STA\t\t\tBIT(4)\n#define NFC_NATCH_INT_FLAG\tBIT(5)\n#define NFC_RB_STATE(x)\t\tBIT(x + 8)\n\n \n#define NFC_B2R_INT_ENABLE\tBIT(0)\n#define NFC_CMD_INT_ENABLE\tBIT(1)\n#define NFC_DMA_INT_ENABLE\tBIT(2)\n#define NFC_INT_MASK\t\t(NFC_B2R_INT_ENABLE | \\\n\t\t\t\t NFC_CMD_INT_ENABLE | \\\n\t\t\t\t NFC_DMA_INT_ENABLE)\n\n \n#define NFC_TIMING_CTL_EDO\tBIT(8)\n\n \n#define NFC_TIMING_CFG(tWB, tADL, tWHR, tRHW, tCAD)\t\t\\\n\t(((tWB) & 0x3) | (((tADL) & 0x3) << 2) |\t\t\\\n\t(((tWHR) & 0x3) << 4) | (((tRHW) & 0x3) << 6) |\t\t\\\n\t(((tCAD) & 0x7) << 8))\n\n \n#define NFC_CMD_LOW_BYTE_MSK\tGENMASK(7, 0)\n#define NFC_CMD_HIGH_BYTE_MSK\tGENMASK(15, 8)\n#define NFC_CMD(x)\t\t(x)\n#define NFC_ADR_NUM_MSK\t\tGENMASK(18, 16)\n#define NFC_ADR_NUM(x)\t\t(((x) - 1) << 16)\n#define NFC_SEND_ADR\t\tBIT(19)\n#define NFC_ACCESS_DIR\t\tBIT(20)\n#define NFC_DATA_TRANS\t\tBIT(21)\n#define NFC_SEND_CMD1\t\tBIT(22)\n#define NFC_WAIT_FLAG\t\tBIT(23)\n#define NFC_SEND_CMD2\t\tBIT(24)\n#define NFC_SEQ\t\t\tBIT(25)\n#define NFC_DATA_SWAP_METHOD\tBIT(26)\n#define NFC_ROW_AUTO_INC\tBIT(27)\n#define NFC_SEND_CMD3\t\tBIT(28)\n#define NFC_SEND_CMD4\t\tBIT(29)\n#define NFC_CMD_TYPE_MSK\tGENMASK(31, 30)\n#define NFC_NORMAL_OP\t\t(0 << 30)\n#define NFC_ECC_OP\t\t(1 << 30)\n#define NFC_PAGE_OP\t\t(2U << 30)\n\n \n#define NFC_READ_CMD_MSK\tGENMASK(7, 0)\n#define NFC_RND_READ_CMD0_MSK\tGENMASK(15, 8)\n#define NFC_RND_READ_CMD1_MSK\tGENMASK(23, 16)\n\n \n#define NFC_PROGRAM_CMD_MSK\tGENMASK(7, 0)\n#define NFC_RND_WRITE_CMD_MSK\tGENMASK(15, 8)\n#define NFC_READ_CMD0_MSK\tGENMASK(23, 16)\n#define NFC_READ_CMD1_MSK\tGENMASK(31, 24)\n\n \n#define NFC_ECC_EN\t\tBIT(0)\n#define NFC_ECC_PIPELINE\tBIT(3)\n#define NFC_ECC_EXCEPTION\tBIT(4)\n#define NFC_ECC_BLOCK_SIZE_MSK\tBIT(5)\n#define NFC_ECC_BLOCK_512\tBIT(5)\n#define NFC_RANDOM_EN\t\tBIT(9)\n#define NFC_RANDOM_DIRECTION\tBIT(10)\n#define NFC_ECC_MODE_MSK\tGENMASK(15, 12)\n#define NFC_ECC_MODE(x)\t\t((x) << 12)\n#define NFC_RANDOM_SEED_MSK\tGENMASK(30, 16)\n#define NFC_RANDOM_SEED(x)\t((x) << 16)\n\n \n#define NFC_ECC_ERR(x)\t\tBIT(x)\n#define NFC_ECC_ERR_MSK\t\tGENMASK(15, 0)\n#define NFC_ECC_PAT_FOUND(x)\tBIT(x + 16)\n#define NFC_ECC_ERR_CNT(b, x)\t(((x) >> (((b) % 4) * 8)) & 0xff)\n\n#define NFC_DEFAULT_TIMEOUT_MS\t1000\n\n#define NFC_SRAM_SIZE\t\t1024\n\n#define NFC_MAX_CS\t\t7\n\n \nstruct sunxi_nand_chip_sel {\n\tu8 cs;\n\ts8 rb;\n};\n\n \nstruct sunxi_nand_hw_ecc {\n\tu32 ecc_ctl;\n};\n\n \nstruct sunxi_nand_chip {\n\tstruct list_head node;\n\tstruct nand_chip nand;\n\tstruct sunxi_nand_hw_ecc ecc;\n\tunsigned long clk_rate;\n\tu32 timing_cfg;\n\tu32 timing_ctl;\n\tint nsels;\n\tstruct sunxi_nand_chip_sel sels[];\n};\n\nstatic inline struct sunxi_nand_chip *to_sunxi_nand(struct nand_chip *nand)\n{\n\treturn container_of(nand, struct sunxi_nand_chip, nand);\n}\n\n \nstruct sunxi_nfc_caps {\n\tbool has_mdma;\n\tunsigned int reg_io_data;\n\tunsigned int dma_maxburst;\n};\n\n \nstruct sunxi_nfc {\n\tstruct nand_controller controller;\n\tstruct device *dev;\n\tvoid __iomem *regs;\n\tstruct clk *ahb_clk;\n\tstruct clk *mod_clk;\n\tstruct reset_control *reset;\n\tunsigned long assigned_cs;\n\tunsigned long clk_rate;\n\tstruct list_head chips;\n\tstruct completion complete;\n\tstruct dma_chan *dmac;\n\tconst struct sunxi_nfc_caps *caps;\n};\n\nstatic inline struct sunxi_nfc *to_sunxi_nfc(struct nand_controller *ctrl)\n{\n\treturn container_of(ctrl, struct sunxi_nfc, controller);\n}\n\nstatic irqreturn_t sunxi_nfc_interrupt(int irq, void *dev_id)\n{\n\tstruct sunxi_nfc *nfc = dev_id;\n\tu32 st = readl(nfc->regs + NFC_REG_ST);\n\tu32 ien = readl(nfc->regs + NFC_REG_INT);\n\n\tif (!(ien & st))\n\t\treturn IRQ_NONE;\n\n\tif ((ien & st) == ien)\n\t\tcomplete(&nfc->complete);\n\n\twritel(st & NFC_INT_MASK, nfc->regs + NFC_REG_ST);\n\twritel(~st & ien & NFC_INT_MASK, nfc->regs + NFC_REG_INT);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int sunxi_nfc_wait_events(struct sunxi_nfc *nfc, u32 events,\n\t\t\t\t bool use_polling, unsigned int timeout_ms)\n{\n\tint ret;\n\n\tif (events & ~NFC_INT_MASK)\n\t\treturn -EINVAL;\n\n\tif (!timeout_ms)\n\t\ttimeout_ms = NFC_DEFAULT_TIMEOUT_MS;\n\n\tif (!use_polling) {\n\t\tinit_completion(&nfc->complete);\n\n\t\twritel(events, nfc->regs + NFC_REG_INT);\n\n\t\tret = wait_for_completion_timeout(&nfc->complete,\n\t\t\t\t\t\tmsecs_to_jiffies(timeout_ms));\n\t\tif (!ret)\n\t\t\tret = -ETIMEDOUT;\n\t\telse\n\t\t\tret = 0;\n\n\t\twritel(0, nfc->regs + NFC_REG_INT);\n\t} else {\n\t\tu32 status;\n\n\t\tret = readl_poll_timeout(nfc->regs + NFC_REG_ST, status,\n\t\t\t\t\t (status & events) == events, 1,\n\t\t\t\t\t timeout_ms * 1000);\n\t}\n\n\twritel(events & NFC_INT_MASK, nfc->regs + NFC_REG_ST);\n\n\tif (ret)\n\t\tdev_err(nfc->dev, \"wait interrupt timedout\\n\");\n\n\treturn ret;\n}\n\nstatic int sunxi_nfc_wait_cmd_fifo_empty(struct sunxi_nfc *nfc)\n{\n\tu32 status;\n\tint ret;\n\n\tret = readl_poll_timeout(nfc->regs + NFC_REG_ST, status,\n\t\t\t\t !(status & NFC_CMD_FIFO_STATUS), 1,\n\t\t\t\t NFC_DEFAULT_TIMEOUT_MS * 1000);\n\tif (ret)\n\t\tdev_err(nfc->dev, \"wait for empty cmd FIFO timedout\\n\");\n\n\treturn ret;\n}\n\nstatic int sunxi_nfc_rst(struct sunxi_nfc *nfc)\n{\n\tu32 ctl;\n\tint ret;\n\n\twritel(0, nfc->regs + NFC_REG_ECC_CTL);\n\twritel(NFC_RESET, nfc->regs + NFC_REG_CTL);\n\n\tret = readl_poll_timeout(nfc->regs + NFC_REG_CTL, ctl,\n\t\t\t\t !(ctl & NFC_RESET), 1,\n\t\t\t\t NFC_DEFAULT_TIMEOUT_MS * 1000);\n\tif (ret)\n\t\tdev_err(nfc->dev, \"wait for NAND controller reset timedout\\n\");\n\n\treturn ret;\n}\n\nstatic int sunxi_nfc_dma_op_prepare(struct sunxi_nfc *nfc, const void *buf,\n\t\t\t\t    int chunksize, int nchunks,\n\t\t\t\t    enum dma_data_direction ddir,\n\t\t\t\t    struct scatterlist *sg)\n{\n\tstruct dma_async_tx_descriptor *dmad;\n\tenum dma_transfer_direction tdir;\n\tdma_cookie_t dmat;\n\tint ret;\n\n\tif (ddir == DMA_FROM_DEVICE)\n\t\ttdir = DMA_DEV_TO_MEM;\n\telse\n\t\ttdir = DMA_MEM_TO_DEV;\n\n\tsg_init_one(sg, buf, nchunks * chunksize);\n\tret = dma_map_sg(nfc->dev, sg, 1, ddir);\n\tif (!ret)\n\t\treturn -ENOMEM;\n\n\tif (!nfc->caps->has_mdma) {\n\t\tdmad = dmaengine_prep_slave_sg(nfc->dmac, sg, 1, tdir, DMA_CTRL_ACK);\n\t\tif (!dmad) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto err_unmap_buf;\n\t\t}\n\t}\n\n\twritel(readl(nfc->regs + NFC_REG_CTL) | NFC_RAM_METHOD,\n\t       nfc->regs + NFC_REG_CTL);\n\twritel(nchunks, nfc->regs + NFC_REG_SECTOR_NUM);\n\twritel(chunksize, nfc->regs + NFC_REG_CNT);\n\n\tif (nfc->caps->has_mdma) {\n\t\twritel(readl(nfc->regs + NFC_REG_CTL) & ~NFC_DMA_TYPE_NORMAL,\n\t\t       nfc->regs + NFC_REG_CTL);\n\t\twritel(chunksize * nchunks, nfc->regs + NFC_REG_MDMA_CNT);\n\t\twritel(sg_dma_address(sg), nfc->regs + NFC_REG_MDMA_ADDR);\n\t} else {\n\t\tdmat = dmaengine_submit(dmad);\n\n\t\tret = dma_submit_error(dmat);\n\t\tif (ret)\n\t\t\tgoto err_clr_dma_flag;\n\t}\n\n\treturn 0;\n\nerr_clr_dma_flag:\n\twritel(readl(nfc->regs + NFC_REG_CTL) & ~NFC_RAM_METHOD,\n\t       nfc->regs + NFC_REG_CTL);\n\nerr_unmap_buf:\n\tdma_unmap_sg(nfc->dev, sg, 1, ddir);\n\treturn ret;\n}\n\nstatic void sunxi_nfc_dma_op_cleanup(struct sunxi_nfc *nfc,\n\t\t\t\t     enum dma_data_direction ddir,\n\t\t\t\t     struct scatterlist *sg)\n{\n\tdma_unmap_sg(nfc->dev, sg, 1, ddir);\n\twritel(readl(nfc->regs + NFC_REG_CTL) & ~NFC_RAM_METHOD,\n\t       nfc->regs + NFC_REG_CTL);\n}\n\nstatic void sunxi_nfc_select_chip(struct nand_chip *nand, unsigned int cs)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(nand);\n\tstruct sunxi_nand_chip *sunxi_nand = to_sunxi_nand(nand);\n\tstruct sunxi_nfc *nfc = to_sunxi_nfc(sunxi_nand->nand.controller);\n\tstruct sunxi_nand_chip_sel *sel;\n\tu32 ctl;\n\n\tif (cs >= sunxi_nand->nsels)\n\t\treturn;\n\n\tctl = readl(nfc->regs + NFC_REG_CTL) &\n\t      ~(NFC_PAGE_SHIFT_MSK | NFC_CE_SEL_MSK | NFC_RB_SEL_MSK | NFC_EN);\n\n\tsel = &sunxi_nand->sels[cs];\n\tctl |= NFC_CE_SEL(sel->cs) | NFC_EN | NFC_PAGE_SHIFT(nand->page_shift);\n\tif (sel->rb >= 0)\n\t\tctl |= NFC_RB_SEL(sel->rb);\n\n\twritel(mtd->writesize, nfc->regs + NFC_REG_SPARE_AREA);\n\n\tif (nfc->clk_rate != sunxi_nand->clk_rate) {\n\t\tclk_set_rate(nfc->mod_clk, sunxi_nand->clk_rate);\n\t\tnfc->clk_rate = sunxi_nand->clk_rate;\n\t}\n\n\twritel(sunxi_nand->timing_ctl, nfc->regs + NFC_REG_TIMING_CTL);\n\twritel(sunxi_nand->timing_cfg, nfc->regs + NFC_REG_TIMING_CFG);\n\twritel(ctl, nfc->regs + NFC_REG_CTL);\n}\n\nstatic void sunxi_nfc_read_buf(struct nand_chip *nand, uint8_t *buf, int len)\n{\n\tstruct sunxi_nand_chip *sunxi_nand = to_sunxi_nand(nand);\n\tstruct sunxi_nfc *nfc = to_sunxi_nfc(sunxi_nand->nand.controller);\n\tint ret;\n\tint cnt;\n\tint offs = 0;\n\tu32 tmp;\n\n\twhile (len > offs) {\n\t\tbool poll = false;\n\n\t\tcnt = min(len - offs, NFC_SRAM_SIZE);\n\n\t\tret = sunxi_nfc_wait_cmd_fifo_empty(nfc);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\twritel(cnt, nfc->regs + NFC_REG_CNT);\n\t\ttmp = NFC_DATA_TRANS | NFC_DATA_SWAP_METHOD;\n\t\twritel(tmp, nfc->regs + NFC_REG_CMD);\n\n\t\t \n\t\tif (cnt < 64)\n\t\t\tpoll = true;\n\n\t\tret = sunxi_nfc_wait_events(nfc, NFC_CMD_INT_FLAG, poll, 0);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tif (buf)\n\t\t\tmemcpy_fromio(buf + offs, nfc->regs + NFC_RAM0_BASE,\n\t\t\t\t      cnt);\n\t\toffs += cnt;\n\t}\n}\n\nstatic void sunxi_nfc_write_buf(struct nand_chip *nand, const uint8_t *buf,\n\t\t\t\tint len)\n{\n\tstruct sunxi_nand_chip *sunxi_nand = to_sunxi_nand(nand);\n\tstruct sunxi_nfc *nfc = to_sunxi_nfc(sunxi_nand->nand.controller);\n\tint ret;\n\tint cnt;\n\tint offs = 0;\n\tu32 tmp;\n\n\twhile (len > offs) {\n\t\tbool poll = false;\n\n\t\tcnt = min(len - offs, NFC_SRAM_SIZE);\n\n\t\tret = sunxi_nfc_wait_cmd_fifo_empty(nfc);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\twritel(cnt, nfc->regs + NFC_REG_CNT);\n\t\tmemcpy_toio(nfc->regs + NFC_RAM0_BASE, buf + offs, cnt);\n\t\ttmp = NFC_DATA_TRANS | NFC_DATA_SWAP_METHOD |\n\t\t      NFC_ACCESS_DIR;\n\t\twritel(tmp, nfc->regs + NFC_REG_CMD);\n\n\t\t \n\t\tif (cnt < 64)\n\t\t\tpoll = true;\n\n\t\tret = sunxi_nfc_wait_events(nfc, NFC_CMD_INT_FLAG, poll, 0);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\toffs += cnt;\n\t}\n}\n\n \nstatic const u16 sunxi_nfc_randomizer_page_seeds[] = {\n\t0x2b75, 0x0bd0, 0x5ca3, 0x62d1, 0x1c93, 0x07e9, 0x2162, 0x3a72,\n\t0x0d67, 0x67f9, 0x1be7, 0x077d, 0x032f, 0x0dac, 0x2716, 0x2436,\n\t0x7922, 0x1510, 0x3860, 0x5287, 0x480f, 0x4252, 0x1789, 0x5a2d,\n\t0x2a49, 0x5e10, 0x437f, 0x4b4e, 0x2f45, 0x216e, 0x5cb7, 0x7130,\n\t0x2a3f, 0x60e4, 0x4dc9, 0x0ef0, 0x0f52, 0x1bb9, 0x6211, 0x7a56,\n\t0x226d, 0x4ea7, 0x6f36, 0x3692, 0x38bf, 0x0c62, 0x05eb, 0x4c55,\n\t0x60f4, 0x728c, 0x3b6f, 0x2037, 0x7f69, 0x0936, 0x651a, 0x4ceb,\n\t0x6218, 0x79f3, 0x383f, 0x18d9, 0x4f05, 0x5c82, 0x2912, 0x6f17,\n\t0x6856, 0x5938, 0x1007, 0x61ab, 0x3e7f, 0x57c2, 0x542f, 0x4f62,\n\t0x7454, 0x2eac, 0x7739, 0x42d4, 0x2f90, 0x435a, 0x2e52, 0x2064,\n\t0x637c, 0x66ad, 0x2c90, 0x0bad, 0x759c, 0x0029, 0x0986, 0x7126,\n\t0x1ca7, 0x1605, 0x386a, 0x27f5, 0x1380, 0x6d75, 0x24c3, 0x0f8e,\n\t0x2b7a, 0x1418, 0x1fd1, 0x7dc1, 0x2d8e, 0x43af, 0x2267, 0x7da3,\n\t0x4e3d, 0x1338, 0x50db, 0x454d, 0x764d, 0x40a3, 0x42e6, 0x262b,\n\t0x2d2e, 0x1aea, 0x2e17, 0x173d, 0x3a6e, 0x71bf, 0x25f9, 0x0a5d,\n\t0x7c57, 0x0fbe, 0x46ce, 0x4939, 0x6b17, 0x37bb, 0x3e91, 0x76db,\n};\n\n \nstatic const u16 sunxi_nfc_randomizer_ecc512_seeds[] = {\n\t0x3346, 0x367f, 0x1f18, 0x769a, 0x4f64, 0x068c, 0x2ef1, 0x6b64,\n\t0x28a9, 0x15d7, 0x30f8, 0x3659, 0x53db, 0x7c5f, 0x71d4, 0x4409,\n\t0x26eb, 0x03cc, 0x655d, 0x47d4, 0x4daa, 0x0877, 0x712d, 0x3617,\n\t0x3264, 0x49aa, 0x7f9e, 0x588e, 0x4fbc, 0x7176, 0x7f91, 0x6c6d,\n\t0x4b95, 0x5fb7, 0x3844, 0x4037, 0x0184, 0x081b, 0x0ee8, 0x5b91,\n\t0x293d, 0x1f71, 0x0e6f, 0x402b, 0x5122, 0x1e52, 0x22be, 0x3d2d,\n\t0x75bc, 0x7c60, 0x6291, 0x1a2f, 0x61d4, 0x74aa, 0x4140, 0x29ab,\n\t0x472d, 0x2852, 0x017e, 0x15e8, 0x5ec2, 0x17cf, 0x7d0f, 0x06b8,\n\t0x117a, 0x6b94, 0x789b, 0x3126, 0x6ac5, 0x5be7, 0x150f, 0x51f8,\n\t0x7889, 0x0aa5, 0x663d, 0x77e8, 0x0b87, 0x3dcb, 0x360d, 0x218b,\n\t0x512f, 0x7dc9, 0x6a4d, 0x630a, 0x3547, 0x1dd2, 0x5aea, 0x69a5,\n\t0x7bfa, 0x5e4f, 0x1519, 0x6430, 0x3a0e, 0x5eb3, 0x5425, 0x0c7a,\n\t0x5540, 0x3670, 0x63c1, 0x31e9, 0x5a39, 0x2de7, 0x5979, 0x2891,\n\t0x1562, 0x014b, 0x5b05, 0x2756, 0x5a34, 0x13aa, 0x6cb5, 0x2c36,\n\t0x5e72, 0x1306, 0x0861, 0x15ef, 0x1ee8, 0x5a37, 0x7ac4, 0x45dd,\n\t0x44c4, 0x7266, 0x2f41, 0x3ccc, 0x045e, 0x7d40, 0x7c66, 0x0fa0,\n};\n\nstatic const u16 sunxi_nfc_randomizer_ecc1024_seeds[] = {\n\t0x2cf5, 0x35f1, 0x63a4, 0x5274, 0x2bd2, 0x778b, 0x7285, 0x32b6,\n\t0x6a5c, 0x70d6, 0x757d, 0x6769, 0x5375, 0x1e81, 0x0cf3, 0x3982,\n\t0x6787, 0x042a, 0x6c49, 0x1925, 0x56a8, 0x40a9, 0x063e, 0x7bd9,\n\t0x4dbf, 0x55ec, 0x672e, 0x7334, 0x5185, 0x4d00, 0x232a, 0x7e07,\n\t0x445d, 0x6b92, 0x528f, 0x4255, 0x53ba, 0x7d82, 0x2a2e, 0x3a4e,\n\t0x75eb, 0x450c, 0x6844, 0x1b5d, 0x581a, 0x4cc6, 0x0379, 0x37b2,\n\t0x419f, 0x0e92, 0x6b27, 0x5624, 0x01e3, 0x07c1, 0x44a5, 0x130c,\n\t0x13e8, 0x5910, 0x0876, 0x60c5, 0x54e3, 0x5b7f, 0x2269, 0x509f,\n\t0x7665, 0x36fd, 0x3e9a, 0x0579, 0x6295, 0x14ef, 0x0a81, 0x1bcc,\n\t0x4b16, 0x64db, 0x0514, 0x4f07, 0x0591, 0x3576, 0x6853, 0x0d9e,\n\t0x259f, 0x38b7, 0x64fb, 0x3094, 0x4693, 0x6ddd, 0x29bb, 0x0bc8,\n\t0x3f47, 0x490e, 0x0c0e, 0x7933, 0x3c9e, 0x5840, 0x398d, 0x3e68,\n\t0x4af1, 0x71f5, 0x57cf, 0x1121, 0x64eb, 0x3579, 0x15ac, 0x584d,\n\t0x5f2a, 0x47e2, 0x6528, 0x6eac, 0x196e, 0x6b96, 0x0450, 0x0179,\n\t0x609c, 0x06e1, 0x4626, 0x42c7, 0x273e, 0x486f, 0x0705, 0x1601,\n\t0x145b, 0x407e, 0x062b, 0x57a5, 0x53f9, 0x5659, 0x4410, 0x3ccd,\n};\n\nstatic u16 sunxi_nfc_randomizer_step(u16 state, int count)\n{\n\tstate &= 0x7fff;\n\n\t \n\twhile (count--)\n\t\tstate = ((state >> 1) |\n\t\t\t (((state ^ (state >> 1)) & 1) << 14)) & 0x7fff;\n\n\treturn state;\n}\n\nstatic u16 sunxi_nfc_randomizer_state(struct nand_chip *nand, int page,\n\t\t\t\t      bool ecc)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(nand);\n\tconst u16 *seeds = sunxi_nfc_randomizer_page_seeds;\n\tint mod = mtd_div_by_ws(mtd->erasesize, mtd);\n\n\tif (mod > ARRAY_SIZE(sunxi_nfc_randomizer_page_seeds))\n\t\tmod = ARRAY_SIZE(sunxi_nfc_randomizer_page_seeds);\n\n\tif (ecc) {\n\t\tif (mtd->ecc_step_size == 512)\n\t\t\tseeds = sunxi_nfc_randomizer_ecc512_seeds;\n\t\telse\n\t\t\tseeds = sunxi_nfc_randomizer_ecc1024_seeds;\n\t}\n\n\treturn seeds[page % mod];\n}\n\nstatic void sunxi_nfc_randomizer_config(struct nand_chip *nand, int page,\n\t\t\t\t\tbool ecc)\n{\n\tstruct sunxi_nfc *nfc = to_sunxi_nfc(nand->controller);\n\tu32 ecc_ctl = readl(nfc->regs + NFC_REG_ECC_CTL);\n\tu16 state;\n\n\tif (!(nand->options & NAND_NEED_SCRAMBLING))\n\t\treturn;\n\n\tecc_ctl = readl(nfc->regs + NFC_REG_ECC_CTL);\n\tstate = sunxi_nfc_randomizer_state(nand, page, ecc);\n\tecc_ctl = readl(nfc->regs + NFC_REG_ECC_CTL) & ~NFC_RANDOM_SEED_MSK;\n\twritel(ecc_ctl | NFC_RANDOM_SEED(state), nfc->regs + NFC_REG_ECC_CTL);\n}\n\nstatic void sunxi_nfc_randomizer_enable(struct nand_chip *nand)\n{\n\tstruct sunxi_nfc *nfc = to_sunxi_nfc(nand->controller);\n\n\tif (!(nand->options & NAND_NEED_SCRAMBLING))\n\t\treturn;\n\n\twritel(readl(nfc->regs + NFC_REG_ECC_CTL) | NFC_RANDOM_EN,\n\t       nfc->regs + NFC_REG_ECC_CTL);\n}\n\nstatic void sunxi_nfc_randomizer_disable(struct nand_chip *nand)\n{\n\tstruct sunxi_nfc *nfc = to_sunxi_nfc(nand->controller);\n\n\tif (!(nand->options & NAND_NEED_SCRAMBLING))\n\t\treturn;\n\n\twritel(readl(nfc->regs + NFC_REG_ECC_CTL) & ~NFC_RANDOM_EN,\n\t       nfc->regs + NFC_REG_ECC_CTL);\n}\n\nstatic void sunxi_nfc_randomize_bbm(struct nand_chip *nand, int page, u8 *bbm)\n{\n\tu16 state = sunxi_nfc_randomizer_state(nand, page, true);\n\n\tbbm[0] ^= state;\n\tbbm[1] ^= sunxi_nfc_randomizer_step(state, 8);\n}\n\nstatic void sunxi_nfc_randomizer_write_buf(struct nand_chip *nand,\n\t\t\t\t\t   const uint8_t *buf, int len,\n\t\t\t\t\t   bool ecc, int page)\n{\n\tsunxi_nfc_randomizer_config(nand, page, ecc);\n\tsunxi_nfc_randomizer_enable(nand);\n\tsunxi_nfc_write_buf(nand, buf, len);\n\tsunxi_nfc_randomizer_disable(nand);\n}\n\nstatic void sunxi_nfc_randomizer_read_buf(struct nand_chip *nand, uint8_t *buf,\n\t\t\t\t\t  int len, bool ecc, int page)\n{\n\tsunxi_nfc_randomizer_config(nand, page, ecc);\n\tsunxi_nfc_randomizer_enable(nand);\n\tsunxi_nfc_read_buf(nand, buf, len);\n\tsunxi_nfc_randomizer_disable(nand);\n}\n\nstatic void sunxi_nfc_hw_ecc_enable(struct nand_chip *nand)\n{\n\tstruct sunxi_nand_chip *sunxi_nand = to_sunxi_nand(nand);\n\tstruct sunxi_nfc *nfc = to_sunxi_nfc(nand->controller);\n\n\twritel(sunxi_nand->ecc.ecc_ctl, nfc->regs + NFC_REG_ECC_CTL);\n}\n\nstatic void sunxi_nfc_hw_ecc_disable(struct nand_chip *nand)\n{\n\tstruct sunxi_nfc *nfc = to_sunxi_nfc(nand->controller);\n\n\twritel(0, nfc->regs + NFC_REG_ECC_CTL);\n}\n\nstatic inline void sunxi_nfc_user_data_to_buf(u32 user_data, u8 *buf)\n{\n\tbuf[0] = user_data;\n\tbuf[1] = user_data >> 8;\n\tbuf[2] = user_data >> 16;\n\tbuf[3] = user_data >> 24;\n}\n\nstatic inline u32 sunxi_nfc_buf_to_user_data(const u8 *buf)\n{\n\treturn buf[0] | (buf[1] << 8) | (buf[2] << 16) | (buf[3] << 24);\n}\n\nstatic void sunxi_nfc_hw_ecc_get_prot_oob_bytes(struct nand_chip *nand, u8 *oob,\n\t\t\t\t\t\tint step, bool bbm, int page)\n{\n\tstruct sunxi_nfc *nfc = to_sunxi_nfc(nand->controller);\n\n\tsunxi_nfc_user_data_to_buf(readl(nfc->regs + NFC_REG_USER_DATA(step)),\n\t\t\t\t   oob);\n\n\t \n\tif (bbm && (nand->options & NAND_NEED_SCRAMBLING))\n\t\tsunxi_nfc_randomize_bbm(nand, page, oob);\n}\n\nstatic void sunxi_nfc_hw_ecc_set_prot_oob_bytes(struct nand_chip *nand,\n\t\t\t\t\t\tconst u8 *oob, int step,\n\t\t\t\t\t\tbool bbm, int page)\n{\n\tstruct sunxi_nfc *nfc = to_sunxi_nfc(nand->controller);\n\tu8 user_data[4];\n\n\t \n\tif (bbm && (nand->options & NAND_NEED_SCRAMBLING)) {\n\t\tmemcpy(user_data, oob, sizeof(user_data));\n\t\tsunxi_nfc_randomize_bbm(nand, page, user_data);\n\t\toob = user_data;\n\t}\n\n\twritel(sunxi_nfc_buf_to_user_data(oob),\n\t       nfc->regs + NFC_REG_USER_DATA(step));\n}\n\nstatic void sunxi_nfc_hw_ecc_update_stats(struct nand_chip *nand,\n\t\t\t\t\t  unsigned int *max_bitflips, int ret)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(nand);\n\n\tif (ret < 0) {\n\t\tmtd->ecc_stats.failed++;\n\t} else {\n\t\tmtd->ecc_stats.corrected += ret;\n\t\t*max_bitflips = max_t(unsigned int, *max_bitflips, ret);\n\t}\n}\n\nstatic int sunxi_nfc_hw_ecc_correct(struct nand_chip *nand, u8 *data, u8 *oob,\n\t\t\t\t    int step, u32 status, bool *erased)\n{\n\tstruct sunxi_nfc *nfc = to_sunxi_nfc(nand->controller);\n\tstruct nand_ecc_ctrl *ecc = &nand->ecc;\n\tu32 tmp;\n\n\t*erased = false;\n\n\tif (status & NFC_ECC_ERR(step))\n\t\treturn -EBADMSG;\n\n\tif (status & NFC_ECC_PAT_FOUND(step)) {\n\t\tu8 pattern;\n\n\t\tif (unlikely(!(readl(nfc->regs + NFC_REG_PAT_ID) & 0x1))) {\n\t\t\tpattern = 0x0;\n\t\t} else {\n\t\t\tpattern = 0xff;\n\t\t\t*erased = true;\n\t\t}\n\n\t\tif (data)\n\t\t\tmemset(data, pattern, ecc->size);\n\n\t\tif (oob)\n\t\t\tmemset(oob, pattern, ecc->bytes + 4);\n\n\t\treturn 0;\n\t}\n\n\ttmp = readl(nfc->regs + NFC_REG_ECC_ERR_CNT(step));\n\n\treturn NFC_ECC_ERR_CNT(step, tmp);\n}\n\nstatic int sunxi_nfc_hw_ecc_read_chunk(struct nand_chip *nand,\n\t\t\t\t       u8 *data, int data_off,\n\t\t\t\t       u8 *oob, int oob_off,\n\t\t\t\t       int *cur_off,\n\t\t\t\t       unsigned int *max_bitflips,\n\t\t\t\t       bool bbm, bool oob_required, int page)\n{\n\tstruct sunxi_nfc *nfc = to_sunxi_nfc(nand->controller);\n\tstruct nand_ecc_ctrl *ecc = &nand->ecc;\n\tint raw_mode = 0;\n\tbool erased;\n\tint ret;\n\n\tif (*cur_off != data_off)\n\t\tnand_change_read_column_op(nand, data_off, NULL, 0, false);\n\n\tsunxi_nfc_randomizer_read_buf(nand, NULL, ecc->size, false, page);\n\n\tif (data_off + ecc->size != oob_off)\n\t\tnand_change_read_column_op(nand, oob_off, NULL, 0, false);\n\n\tret = sunxi_nfc_wait_cmd_fifo_empty(nfc);\n\tif (ret)\n\t\treturn ret;\n\n\tsunxi_nfc_randomizer_enable(nand);\n\twritel(NFC_DATA_TRANS | NFC_DATA_SWAP_METHOD | NFC_ECC_OP,\n\t       nfc->regs + NFC_REG_CMD);\n\n\tret = sunxi_nfc_wait_events(nfc, NFC_CMD_INT_FLAG, false, 0);\n\tsunxi_nfc_randomizer_disable(nand);\n\tif (ret)\n\t\treturn ret;\n\n\t*cur_off = oob_off + ecc->bytes + 4;\n\n\tret = sunxi_nfc_hw_ecc_correct(nand, data, oob_required ? oob : NULL, 0,\n\t\t\t\t       readl(nfc->regs + NFC_REG_ECC_ST),\n\t\t\t\t       &erased);\n\tif (erased)\n\t\treturn 1;\n\n\tif (ret < 0) {\n\t\t \n\t\tif (nand->options & NAND_NEED_SCRAMBLING)\n\t\t\tnand_change_read_column_op(nand, data_off, data,\n\t\t\t\t\t\t   ecc->size, false);\n\t\telse\n\t\t\tmemcpy_fromio(data, nfc->regs + NFC_RAM0_BASE,\n\t\t\t\t      ecc->size);\n\n\t\tnand_change_read_column_op(nand, oob_off, oob, ecc->bytes + 4,\n\t\t\t\t\t   false);\n\n\t\tret = nand_check_erased_ecc_chunk(data,\tecc->size,\n\t\t\t\t\t\t  oob, ecc->bytes + 4,\n\t\t\t\t\t\t  NULL, 0, ecc->strength);\n\t\tif (ret >= 0)\n\t\t\traw_mode = 1;\n\t} else {\n\t\tmemcpy_fromio(data, nfc->regs + NFC_RAM0_BASE, ecc->size);\n\n\t\tif (oob_required) {\n\t\t\tnand_change_read_column_op(nand, oob_off, NULL, 0,\n\t\t\t\t\t\t   false);\n\t\t\tsunxi_nfc_randomizer_read_buf(nand, oob, ecc->bytes + 4,\n\t\t\t\t\t\t      true, page);\n\n\t\t\tsunxi_nfc_hw_ecc_get_prot_oob_bytes(nand, oob, 0,\n\t\t\t\t\t\t\t    bbm, page);\n\t\t}\n\t}\n\n\tsunxi_nfc_hw_ecc_update_stats(nand, max_bitflips, ret);\n\n\treturn raw_mode;\n}\n\nstatic void sunxi_nfc_hw_ecc_read_extra_oob(struct nand_chip *nand,\n\t\t\t\t\t    u8 *oob, int *cur_off,\n\t\t\t\t\t    bool randomize, int page)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(nand);\n\tstruct nand_ecc_ctrl *ecc = &nand->ecc;\n\tint offset = ((ecc->bytes + 4) * ecc->steps);\n\tint len = mtd->oobsize - offset;\n\n\tif (len <= 0)\n\t\treturn;\n\n\tif (!cur_off || *cur_off != offset)\n\t\tnand_change_read_column_op(nand, mtd->writesize, NULL, 0,\n\t\t\t\t\t   false);\n\n\tif (!randomize)\n\t\tsunxi_nfc_read_buf(nand, oob + offset, len);\n\telse\n\t\tsunxi_nfc_randomizer_read_buf(nand, oob + offset, len,\n\t\t\t\t\t      false, page);\n\n\tif (cur_off)\n\t\t*cur_off = mtd->oobsize + mtd->writesize;\n}\n\nstatic int sunxi_nfc_hw_ecc_read_chunks_dma(struct nand_chip *nand, uint8_t *buf,\n\t\t\t\t\t    int oob_required, int page,\n\t\t\t\t\t    int nchunks)\n{\n\tbool randomized = nand->options & NAND_NEED_SCRAMBLING;\n\tstruct sunxi_nfc *nfc = to_sunxi_nfc(nand->controller);\n\tstruct mtd_info *mtd = nand_to_mtd(nand);\n\tstruct nand_ecc_ctrl *ecc = &nand->ecc;\n\tunsigned int max_bitflips = 0;\n\tint ret, i, raw_mode = 0;\n\tstruct scatterlist sg;\n\tu32 status, wait;\n\n\tret = sunxi_nfc_wait_cmd_fifo_empty(nfc);\n\tif (ret)\n\t\treturn ret;\n\n\tret = sunxi_nfc_dma_op_prepare(nfc, buf, ecc->size, nchunks,\n\t\t\t\t       DMA_FROM_DEVICE, &sg);\n\tif (ret)\n\t\treturn ret;\n\n\tsunxi_nfc_hw_ecc_enable(nand);\n\tsunxi_nfc_randomizer_config(nand, page, false);\n\tsunxi_nfc_randomizer_enable(nand);\n\n\twritel((NAND_CMD_RNDOUTSTART << 16) | (NAND_CMD_RNDOUT << 8) |\n\t       NAND_CMD_READSTART, nfc->regs + NFC_REG_RCMD_SET);\n\n\twait = NFC_CMD_INT_FLAG;\n\n\tif (nfc->caps->has_mdma)\n\t\twait |= NFC_DMA_INT_FLAG;\n\telse\n\t\tdma_async_issue_pending(nfc->dmac);\n\n\twritel(NFC_PAGE_OP | NFC_DATA_SWAP_METHOD | NFC_DATA_TRANS,\n\t       nfc->regs + NFC_REG_CMD);\n\n\tret = sunxi_nfc_wait_events(nfc, wait, false, 0);\n\tif (ret && !nfc->caps->has_mdma)\n\t\tdmaengine_terminate_all(nfc->dmac);\n\n\tsunxi_nfc_randomizer_disable(nand);\n\tsunxi_nfc_hw_ecc_disable(nand);\n\n\tsunxi_nfc_dma_op_cleanup(nfc, DMA_FROM_DEVICE, &sg);\n\n\tif (ret)\n\t\treturn ret;\n\n\tstatus = readl(nfc->regs + NFC_REG_ECC_ST);\n\n\tfor (i = 0; i < nchunks; i++) {\n\t\tint data_off = i * ecc->size;\n\t\tint oob_off = i * (ecc->bytes + 4);\n\t\tu8 *data = buf + data_off;\n\t\tu8 *oob = nand->oob_poi + oob_off;\n\t\tbool erased;\n\n\t\tret = sunxi_nfc_hw_ecc_correct(nand, randomized ? data : NULL,\n\t\t\t\t\t       oob_required ? oob : NULL,\n\t\t\t\t\t       i, status, &erased);\n\n\t\t \n\t\tif (ret < 0)\n\t\t\tcontinue;\n\n\t\tif (oob_required && !erased) {\n\t\t\t \n\t\t\tnand_change_read_column_op(nand,\n\t\t\t\t\t\t   mtd->writesize + oob_off,\n\t\t\t\t\t\t   oob, ecc->bytes + 4, false);\n\n\t\t\tsunxi_nfc_hw_ecc_get_prot_oob_bytes(nand, oob, i,\n\t\t\t\t\t\t\t    !i, page);\n\t\t}\n\n\t\tif (erased)\n\t\t\traw_mode = 1;\n\n\t\tsunxi_nfc_hw_ecc_update_stats(nand, &max_bitflips, ret);\n\t}\n\n\tif (status & NFC_ECC_ERR_MSK) {\n\t\tfor (i = 0; i < nchunks; i++) {\n\t\t\tint data_off = i * ecc->size;\n\t\t\tint oob_off = i * (ecc->bytes + 4);\n\t\t\tu8 *data = buf + data_off;\n\t\t\tu8 *oob = nand->oob_poi + oob_off;\n\n\t\t\tif (!(status & NFC_ECC_ERR(i)))\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tif (randomized)\n\t\t\t\tnand_change_read_column_op(nand, data_off,\n\t\t\t\t\t\t\t   data, ecc->size,\n\t\t\t\t\t\t\t   false);\n\n\t\t\t \n\t\t\tnand_change_read_column_op(nand,\n\t\t\t\t\t\t   mtd->writesize + oob_off,\n\t\t\t\t\t\t   oob, ecc->bytes + 4, false);\n\n\t\t\tret = nand_check_erased_ecc_chunk(data,\tecc->size,\n\t\t\t\t\t\t\t  oob, ecc->bytes + 4,\n\t\t\t\t\t\t\t  NULL, 0,\n\t\t\t\t\t\t\t  ecc->strength);\n\t\t\tif (ret >= 0)\n\t\t\t\traw_mode = 1;\n\n\t\t\tsunxi_nfc_hw_ecc_update_stats(nand, &max_bitflips, ret);\n\t\t}\n\t}\n\n\tif (oob_required)\n\t\tsunxi_nfc_hw_ecc_read_extra_oob(nand, nand->oob_poi,\n\t\t\t\t\t\tNULL, !raw_mode,\n\t\t\t\t\t\tpage);\n\n\treturn max_bitflips;\n}\n\nstatic int sunxi_nfc_hw_ecc_write_chunk(struct nand_chip *nand,\n\t\t\t\t\tconst u8 *data, int data_off,\n\t\t\t\t\tconst u8 *oob, int oob_off,\n\t\t\t\t\tint *cur_off, bool bbm,\n\t\t\t\t\tint page)\n{\n\tstruct sunxi_nfc *nfc = to_sunxi_nfc(nand->controller);\n\tstruct nand_ecc_ctrl *ecc = &nand->ecc;\n\tint ret;\n\n\tif (data_off != *cur_off)\n\t\tnand_change_write_column_op(nand, data_off, NULL, 0, false);\n\n\tsunxi_nfc_randomizer_write_buf(nand, data, ecc->size, false, page);\n\n\tif (data_off + ecc->size != oob_off)\n\t\tnand_change_write_column_op(nand, oob_off, NULL, 0, false);\n\n\tret = sunxi_nfc_wait_cmd_fifo_empty(nfc);\n\tif (ret)\n\t\treturn ret;\n\n\tsunxi_nfc_randomizer_enable(nand);\n\tsunxi_nfc_hw_ecc_set_prot_oob_bytes(nand, oob, 0, bbm, page);\n\n\twritel(NFC_DATA_TRANS | NFC_DATA_SWAP_METHOD |\n\t       NFC_ACCESS_DIR | NFC_ECC_OP,\n\t       nfc->regs + NFC_REG_CMD);\n\n\tret = sunxi_nfc_wait_events(nfc, NFC_CMD_INT_FLAG, false, 0);\n\tsunxi_nfc_randomizer_disable(nand);\n\tif (ret)\n\t\treturn ret;\n\n\t*cur_off = oob_off + ecc->bytes + 4;\n\n\treturn 0;\n}\n\nstatic void sunxi_nfc_hw_ecc_write_extra_oob(struct nand_chip *nand,\n\t\t\t\t\t     u8 *oob, int *cur_off,\n\t\t\t\t\t     int page)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(nand);\n\tstruct nand_ecc_ctrl *ecc = &nand->ecc;\n\tint offset = ((ecc->bytes + 4) * ecc->steps);\n\tint len = mtd->oobsize - offset;\n\n\tif (len <= 0)\n\t\treturn;\n\n\tif (!cur_off || *cur_off != offset)\n\t\tnand_change_write_column_op(nand, offset + mtd->writesize,\n\t\t\t\t\t    NULL, 0, false);\n\n\tsunxi_nfc_randomizer_write_buf(nand, oob + offset, len, false, page);\n\n\tif (cur_off)\n\t\t*cur_off = mtd->oobsize + mtd->writesize;\n}\n\nstatic int sunxi_nfc_hw_ecc_read_page(struct nand_chip *nand, uint8_t *buf,\n\t\t\t\t      int oob_required, int page)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(nand);\n\tstruct nand_ecc_ctrl *ecc = &nand->ecc;\n\tunsigned int max_bitflips = 0;\n\tint ret, i, cur_off = 0;\n\tbool raw_mode = false;\n\n\tsunxi_nfc_select_chip(nand, nand->cur_cs);\n\n\tnand_read_page_op(nand, page, 0, NULL, 0);\n\n\tsunxi_nfc_hw_ecc_enable(nand);\n\n\tfor (i = 0; i < ecc->steps; i++) {\n\t\tint data_off = i * ecc->size;\n\t\tint oob_off = i * (ecc->bytes + 4);\n\t\tu8 *data = buf + data_off;\n\t\tu8 *oob = nand->oob_poi + oob_off;\n\n\t\tret = sunxi_nfc_hw_ecc_read_chunk(nand, data, data_off, oob,\n\t\t\t\t\t\t  oob_off + mtd->writesize,\n\t\t\t\t\t\t  &cur_off, &max_bitflips,\n\t\t\t\t\t\t  !i, oob_required, page);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\telse if (ret)\n\t\t\traw_mode = true;\n\t}\n\n\tif (oob_required)\n\t\tsunxi_nfc_hw_ecc_read_extra_oob(nand, nand->oob_poi, &cur_off,\n\t\t\t\t\t\t!raw_mode, page);\n\n\tsunxi_nfc_hw_ecc_disable(nand);\n\n\treturn max_bitflips;\n}\n\nstatic int sunxi_nfc_hw_ecc_read_page_dma(struct nand_chip *nand, u8 *buf,\n\t\t\t\t\t  int oob_required, int page)\n{\n\tint ret;\n\n\tsunxi_nfc_select_chip(nand, nand->cur_cs);\n\n\tnand_read_page_op(nand, page, 0, NULL, 0);\n\n\tret = sunxi_nfc_hw_ecc_read_chunks_dma(nand, buf, oob_required, page,\n\t\t\t\t\t       nand->ecc.steps);\n\tif (ret >= 0)\n\t\treturn ret;\n\n\t \n\treturn sunxi_nfc_hw_ecc_read_page(nand, buf, oob_required, page);\n}\n\nstatic int sunxi_nfc_hw_ecc_read_subpage(struct nand_chip *nand,\n\t\t\t\t\t u32 data_offs, u32 readlen,\n\t\t\t\t\t u8 *bufpoi, int page)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(nand);\n\tstruct nand_ecc_ctrl *ecc = &nand->ecc;\n\tint ret, i, cur_off = 0;\n\tunsigned int max_bitflips = 0;\n\n\tsunxi_nfc_select_chip(nand, nand->cur_cs);\n\n\tnand_read_page_op(nand, page, 0, NULL, 0);\n\n\tsunxi_nfc_hw_ecc_enable(nand);\n\n\tfor (i = data_offs / ecc->size;\n\t     i < DIV_ROUND_UP(data_offs + readlen, ecc->size); i++) {\n\t\tint data_off = i * ecc->size;\n\t\tint oob_off = i * (ecc->bytes + 4);\n\t\tu8 *data = bufpoi + data_off;\n\t\tu8 *oob = nand->oob_poi + oob_off;\n\n\t\tret = sunxi_nfc_hw_ecc_read_chunk(nand, data, data_off,\n\t\t\t\t\t\t  oob,\n\t\t\t\t\t\t  oob_off + mtd->writesize,\n\t\t\t\t\t\t  &cur_off, &max_bitflips, !i,\n\t\t\t\t\t\t  false, page);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tsunxi_nfc_hw_ecc_disable(nand);\n\n\treturn max_bitflips;\n}\n\nstatic int sunxi_nfc_hw_ecc_read_subpage_dma(struct nand_chip *nand,\n\t\t\t\t\t     u32 data_offs, u32 readlen,\n\t\t\t\t\t     u8 *buf, int page)\n{\n\tint nchunks = DIV_ROUND_UP(data_offs + readlen, nand->ecc.size);\n\tint ret;\n\n\tsunxi_nfc_select_chip(nand, nand->cur_cs);\n\n\tnand_read_page_op(nand, page, 0, NULL, 0);\n\n\tret = sunxi_nfc_hw_ecc_read_chunks_dma(nand, buf, false, page, nchunks);\n\tif (ret >= 0)\n\t\treturn ret;\n\n\t \n\treturn sunxi_nfc_hw_ecc_read_subpage(nand, data_offs, readlen,\n\t\t\t\t\t     buf, page);\n}\n\nstatic int sunxi_nfc_hw_ecc_write_page(struct nand_chip *nand,\n\t\t\t\t       const uint8_t *buf, int oob_required,\n\t\t\t\t       int page)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(nand);\n\tstruct nand_ecc_ctrl *ecc = &nand->ecc;\n\tint ret, i, cur_off = 0;\n\n\tsunxi_nfc_select_chip(nand, nand->cur_cs);\n\n\tnand_prog_page_begin_op(nand, page, 0, NULL, 0);\n\n\tsunxi_nfc_hw_ecc_enable(nand);\n\n\tfor (i = 0; i < ecc->steps; i++) {\n\t\tint data_off = i * ecc->size;\n\t\tint oob_off = i * (ecc->bytes + 4);\n\t\tconst u8 *data = buf + data_off;\n\t\tconst u8 *oob = nand->oob_poi + oob_off;\n\n\t\tret = sunxi_nfc_hw_ecc_write_chunk(nand, data, data_off, oob,\n\t\t\t\t\t\t   oob_off + mtd->writesize,\n\t\t\t\t\t\t   &cur_off, !i, page);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (oob_required || (nand->options & NAND_NEED_SCRAMBLING))\n\t\tsunxi_nfc_hw_ecc_write_extra_oob(nand, nand->oob_poi,\n\t\t\t\t\t\t &cur_off, page);\n\n\tsunxi_nfc_hw_ecc_disable(nand);\n\n\treturn nand_prog_page_end_op(nand);\n}\n\nstatic int sunxi_nfc_hw_ecc_write_subpage(struct nand_chip *nand,\n\t\t\t\t\t  u32 data_offs, u32 data_len,\n\t\t\t\t\t  const u8 *buf, int oob_required,\n\t\t\t\t\t  int page)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(nand);\n\tstruct nand_ecc_ctrl *ecc = &nand->ecc;\n\tint ret, i, cur_off = 0;\n\n\tsunxi_nfc_select_chip(nand, nand->cur_cs);\n\n\tnand_prog_page_begin_op(nand, page, 0, NULL, 0);\n\n\tsunxi_nfc_hw_ecc_enable(nand);\n\n\tfor (i = data_offs / ecc->size;\n\t     i < DIV_ROUND_UP(data_offs + data_len, ecc->size); i++) {\n\t\tint data_off = i * ecc->size;\n\t\tint oob_off = i * (ecc->bytes + 4);\n\t\tconst u8 *data = buf + data_off;\n\t\tconst u8 *oob = nand->oob_poi + oob_off;\n\n\t\tret = sunxi_nfc_hw_ecc_write_chunk(nand, data, data_off, oob,\n\t\t\t\t\t\t   oob_off + mtd->writesize,\n\t\t\t\t\t\t   &cur_off, !i, page);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tsunxi_nfc_hw_ecc_disable(nand);\n\n\treturn nand_prog_page_end_op(nand);\n}\n\nstatic int sunxi_nfc_hw_ecc_write_page_dma(struct nand_chip *nand,\n\t\t\t\t\t   const u8 *buf,\n\t\t\t\t\t   int oob_required,\n\t\t\t\t\t   int page)\n{\n\tstruct sunxi_nfc *nfc = to_sunxi_nfc(nand->controller);\n\tstruct nand_ecc_ctrl *ecc = &nand->ecc;\n\tstruct scatterlist sg;\n\tu32 wait;\n\tint ret, i;\n\n\tsunxi_nfc_select_chip(nand, nand->cur_cs);\n\n\tret = sunxi_nfc_wait_cmd_fifo_empty(nfc);\n\tif (ret)\n\t\treturn ret;\n\n\tret = sunxi_nfc_dma_op_prepare(nfc, buf, ecc->size, ecc->steps,\n\t\t\t\t       DMA_TO_DEVICE, &sg);\n\tif (ret)\n\t\tgoto pio_fallback;\n\n\tfor (i = 0; i < ecc->steps; i++) {\n\t\tconst u8 *oob = nand->oob_poi + (i * (ecc->bytes + 4));\n\n\t\tsunxi_nfc_hw_ecc_set_prot_oob_bytes(nand, oob, i, !i, page);\n\t}\n\n\tnand_prog_page_begin_op(nand, page, 0, NULL, 0);\n\n\tsunxi_nfc_hw_ecc_enable(nand);\n\tsunxi_nfc_randomizer_config(nand, page, false);\n\tsunxi_nfc_randomizer_enable(nand);\n\n\twritel((NAND_CMD_RNDIN << 8) | NAND_CMD_PAGEPROG,\n\t       nfc->regs + NFC_REG_WCMD_SET);\n\n\twait = NFC_CMD_INT_FLAG;\n\n\tif (nfc->caps->has_mdma)\n\t\twait |= NFC_DMA_INT_FLAG;\n\telse\n\t\tdma_async_issue_pending(nfc->dmac);\n\n\twritel(NFC_PAGE_OP | NFC_DATA_SWAP_METHOD |\n\t       NFC_DATA_TRANS | NFC_ACCESS_DIR,\n\t       nfc->regs + NFC_REG_CMD);\n\n\tret = sunxi_nfc_wait_events(nfc, wait, false, 0);\n\tif (ret && !nfc->caps->has_mdma)\n\t\tdmaengine_terminate_all(nfc->dmac);\n\n\tsunxi_nfc_randomizer_disable(nand);\n\tsunxi_nfc_hw_ecc_disable(nand);\n\n\tsunxi_nfc_dma_op_cleanup(nfc, DMA_TO_DEVICE, &sg);\n\n\tif (ret)\n\t\treturn ret;\n\n\tif (oob_required || (nand->options & NAND_NEED_SCRAMBLING))\n\t\t \n\t\tsunxi_nfc_hw_ecc_write_extra_oob(nand, nand->oob_poi,\n\t\t\t\t\t\t NULL, page);\n\n\treturn nand_prog_page_end_op(nand);\n\npio_fallback:\n\treturn sunxi_nfc_hw_ecc_write_page(nand, buf, oob_required, page);\n}\n\nstatic int sunxi_nfc_hw_ecc_read_oob(struct nand_chip *nand, int page)\n{\n\tu8 *buf = nand_get_data_buf(nand);\n\n\treturn nand->ecc.read_page(nand, buf, 1, page);\n}\n\nstatic int sunxi_nfc_hw_ecc_write_oob(struct nand_chip *nand, int page)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(nand);\n\tu8 *buf = nand_get_data_buf(nand);\n\tint ret;\n\n\tmemset(buf, 0xff, mtd->writesize);\n\tret = nand->ecc.write_page(nand, buf, 1, page);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\treturn nand_prog_page_end_op(nand);\n}\n\nstatic const s32 tWB_lut[] = {6, 12, 16, 20};\nstatic const s32 tRHW_lut[] = {4, 8, 12, 20};\n\nstatic int _sunxi_nand_lookup_timing(const s32 *lut, int lut_size, u32 duration,\n\t\tu32 clk_period)\n{\n\tu32 clk_cycles = DIV_ROUND_UP(duration, clk_period);\n\tint i;\n\n\tfor (i = 0; i < lut_size; i++) {\n\t\tif (clk_cycles <= lut[i])\n\t\t\treturn i;\n\t}\n\n\t \n\treturn -EINVAL;\n}\n\n#define sunxi_nand_lookup_timing(l, p, c) \\\n\t\t\t_sunxi_nand_lookup_timing(l, ARRAY_SIZE(l), p, c)\n\nstatic int sunxi_nfc_setup_interface(struct nand_chip *nand, int csline,\n\t\t\t\t     const struct nand_interface_config *conf)\n{\n\tstruct sunxi_nand_chip *sunxi_nand = to_sunxi_nand(nand);\n\tstruct sunxi_nfc *nfc = to_sunxi_nfc(sunxi_nand->nand.controller);\n\tconst struct nand_sdr_timings *timings;\n\tu32 min_clk_period = 0;\n\ts32 tWB, tADL, tWHR, tRHW, tCAD;\n\tlong real_clk_rate;\n\n\ttimings = nand_get_sdr_timings(conf);\n\tif (IS_ERR(timings))\n\t\treturn -ENOTSUPP;\n\n\t \n\tif (timings->tCLS_min > min_clk_period)\n\t\tmin_clk_period = timings->tCLS_min;\n\n\t \n\tif (timings->tCLH_min > min_clk_period)\n\t\tmin_clk_period = timings->tCLH_min;\n\n\t \n\tif (timings->tCS_min > min_clk_period)\n\t\tmin_clk_period = timings->tCS_min;\n\n\t \n\tif (timings->tCH_min > min_clk_period)\n\t\tmin_clk_period = timings->tCH_min;\n\n\t \n\tif (timings->tWP_min > min_clk_period)\n\t\tmin_clk_period = timings->tWP_min;\n\n\t \n\tif (timings->tWH_min > min_clk_period)\n\t\tmin_clk_period = timings->tWH_min;\n\n\t \n\tif (timings->tALS_min > min_clk_period)\n\t\tmin_clk_period = timings->tALS_min;\n\n\t \n\tif (timings->tDS_min > min_clk_period)\n\t\tmin_clk_period = timings->tDS_min;\n\n\t \n\tif (timings->tDH_min > min_clk_period)\n\t\tmin_clk_period = timings->tDH_min;\n\n\t \n\tif (timings->tRR_min > (min_clk_period * 3))\n\t\tmin_clk_period = DIV_ROUND_UP(timings->tRR_min, 3);\n\n\t \n\tif (timings->tALH_min > min_clk_period)\n\t\tmin_clk_period = timings->tALH_min;\n\n\t \n\tif (timings->tRP_min > min_clk_period)\n\t\tmin_clk_period = timings->tRP_min;\n\n\t \n\tif (timings->tREH_min > min_clk_period)\n\t\tmin_clk_period = timings->tREH_min;\n\n\t \n\tif (timings->tRC_min > (min_clk_period * 2))\n\t\tmin_clk_period = DIV_ROUND_UP(timings->tRC_min, 2);\n\n\t \n\tif (timings->tWC_min > (min_clk_period * 2))\n\t\tmin_clk_period = DIV_ROUND_UP(timings->tWC_min, 2);\n\n\t \n\tif (timings->tWB_max > (min_clk_period * 20))\n\t\tmin_clk_period = DIV_ROUND_UP(timings->tWB_max, 20);\n\n\tif (timings->tADL_min > (min_clk_period * 32))\n\t\tmin_clk_period = DIV_ROUND_UP(timings->tADL_min, 32);\n\n\tif (timings->tWHR_min > (min_clk_period * 32))\n\t\tmin_clk_period = DIV_ROUND_UP(timings->tWHR_min, 32);\n\n\tif (timings->tRHW_min > (min_clk_period * 20))\n\t\tmin_clk_period = DIV_ROUND_UP(timings->tRHW_min, 20);\n\n\t \n\tif (timings->tREA_max > min_clk_period && !timings->tRLOH_min)\n\t\tmin_clk_period = timings->tREA_max;\n\n\ttWB  = sunxi_nand_lookup_timing(tWB_lut, timings->tWB_max,\n\t\t\t\t\tmin_clk_period);\n\tif (tWB < 0) {\n\t\tdev_err(nfc->dev, \"unsupported tWB\\n\");\n\t\treturn tWB;\n\t}\n\n\ttADL = DIV_ROUND_UP(timings->tADL_min, min_clk_period) >> 3;\n\tif (tADL > 3) {\n\t\tdev_err(nfc->dev, \"unsupported tADL\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\ttWHR = DIV_ROUND_UP(timings->tWHR_min, min_clk_period) >> 3;\n\tif (tWHR > 3) {\n\t\tdev_err(nfc->dev, \"unsupported tWHR\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\ttRHW = sunxi_nand_lookup_timing(tRHW_lut, timings->tRHW_min,\n\t\t\t\t\tmin_clk_period);\n\tif (tRHW < 0) {\n\t\tdev_err(nfc->dev, \"unsupported tRHW\\n\");\n\t\treturn tRHW;\n\t}\n\n\tif (csline == NAND_DATA_IFACE_CHECK_ONLY)\n\t\treturn 0;\n\n\t \n\ttCAD = 0x7;\n\n\t \n\tsunxi_nand->timing_cfg = NFC_TIMING_CFG(tWB, tADL, tWHR, tRHW, tCAD);\n\n\t \n\tmin_clk_period = DIV_ROUND_UP(min_clk_period, 1000);\n\n\t \n\tsunxi_nand->clk_rate = NSEC_PER_SEC / min_clk_period;\n\treal_clk_rate = clk_round_rate(nfc->mod_clk, sunxi_nand->clk_rate);\n\tif (real_clk_rate <= 0) {\n\t\tdev_err(nfc->dev, \"Unable to round clk %lu\\n\",\n\t\t\tsunxi_nand->clk_rate);\n\t\treturn -EINVAL;\n\t}\n\n\tsunxi_nand->timing_ctl = 0;\n\n\t \n\tmin_clk_period = NSEC_PER_SEC / real_clk_rate;\n\tif (min_clk_period * 2 < 30 || min_clk_period * 1000 < timings->tREA_max)\n\t\tsunxi_nand->timing_ctl = NFC_TIMING_CTL_EDO;\n\n\treturn 0;\n}\n\nstatic int sunxi_nand_ooblayout_ecc(struct mtd_info *mtd, int section,\n\t\t\t\t    struct mtd_oob_region *oobregion)\n{\n\tstruct nand_chip *nand = mtd_to_nand(mtd);\n\tstruct nand_ecc_ctrl *ecc = &nand->ecc;\n\n\tif (section >= ecc->steps)\n\t\treturn -ERANGE;\n\n\toobregion->offset = section * (ecc->bytes + 4) + 4;\n\toobregion->length = ecc->bytes;\n\n\treturn 0;\n}\n\nstatic int sunxi_nand_ooblayout_free(struct mtd_info *mtd, int section,\n\t\t\t\t     struct mtd_oob_region *oobregion)\n{\n\tstruct nand_chip *nand = mtd_to_nand(mtd);\n\tstruct nand_ecc_ctrl *ecc = &nand->ecc;\n\n\tif (section > ecc->steps)\n\t\treturn -ERANGE;\n\n\t \n\tif (!section && ecc->engine_type == NAND_ECC_ENGINE_TYPE_ON_HOST) {\n\t\toobregion->offset = 2;\n\t\toobregion->length = 2;\n\n\t\treturn 0;\n\t}\n\n\t \n\tif (section == ecc->steps && ecc->engine_type == NAND_ECC_ENGINE_TYPE_ON_HOST)\n\t\treturn -ERANGE;\n\n\toobregion->offset = section * (ecc->bytes + 4);\n\n\tif (section < ecc->steps)\n\t\toobregion->length = 4;\n\telse\n\t\toobregion->length = mtd->oobsize - oobregion->offset;\n\n\treturn 0;\n}\n\nstatic const struct mtd_ooblayout_ops sunxi_nand_ooblayout_ops = {\n\t.ecc = sunxi_nand_ooblayout_ecc,\n\t.free = sunxi_nand_ooblayout_free,\n};\n\nstatic int sunxi_nand_hw_ecc_ctrl_init(struct nand_chip *nand,\n\t\t\t\t       struct nand_ecc_ctrl *ecc,\n\t\t\t\t       struct device_node *np)\n{\n\tstatic const u8 strengths[] = { 16, 24, 28, 32, 40, 48, 56, 60, 64 };\n\tstruct sunxi_nand_chip *sunxi_nand = to_sunxi_nand(nand);\n\tstruct sunxi_nfc *nfc = to_sunxi_nfc(nand->controller);\n\tstruct mtd_info *mtd = nand_to_mtd(nand);\n\tstruct nand_device *nanddev = mtd_to_nanddev(mtd);\n\tint nsectors;\n\tint i;\n\n\tif (nanddev->ecc.user_conf.flags & NAND_ECC_MAXIMIZE_STRENGTH) {\n\t\tint bytes;\n\n\t\tecc->size = 1024;\n\t\tnsectors = mtd->writesize / ecc->size;\n\n\t\t \n\t\tbytes = (mtd->oobsize - 2) / nsectors;\n\n\t\t \n\t\tbytes -= 4;\n\n\t\t \n\t\tif (bytes % 2)\n\t\t\tbytes--;\n\n\t\tecc->strength = bytes * 8 / fls(8 * ecc->size);\n\n\t\tfor (i = 0; i < ARRAY_SIZE(strengths); i++) {\n\t\t\tif (strengths[i] > ecc->strength)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (!i)\n\t\t\tecc->strength = 0;\n\t\telse\n\t\t\tecc->strength = strengths[i - 1];\n\t}\n\n\tif (ecc->size != 512 && ecc->size != 1024)\n\t\treturn -EINVAL;\n\n\t \n\tif (ecc->size == 512 && mtd->writesize > 512) {\n\t\tecc->size = 1024;\n\t\tecc->strength *= 2;\n\t}\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(strengths); i++) {\n\t\tif (ecc->strength <= strengths[i]) {\n\t\t\t \n\t\t\tecc->strength = strengths[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (i >= ARRAY_SIZE(strengths)) {\n\t\tdev_err(nfc->dev, \"unsupported strength\\n\");\n\t\treturn -ENOTSUPP;\n\t}\n\n\t \n\tecc->bytes = DIV_ROUND_UP(ecc->strength * fls(8 * 1024), 8);\n\n\t \n\tecc->bytes = ALIGN(ecc->bytes, 2);\n\n\tnsectors = mtd->writesize / ecc->size;\n\n\tif (mtd->oobsize < ((ecc->bytes + 4) * nsectors))\n\t\treturn -EINVAL;\n\n\tecc->read_oob = sunxi_nfc_hw_ecc_read_oob;\n\tecc->write_oob = sunxi_nfc_hw_ecc_write_oob;\n\tmtd_set_ooblayout(mtd, &sunxi_nand_ooblayout_ops);\n\n\tif (nfc->dmac || nfc->caps->has_mdma) {\n\t\tecc->read_page = sunxi_nfc_hw_ecc_read_page_dma;\n\t\tecc->read_subpage = sunxi_nfc_hw_ecc_read_subpage_dma;\n\t\tecc->write_page = sunxi_nfc_hw_ecc_write_page_dma;\n\t\tnand->options |= NAND_USES_DMA;\n\t} else {\n\t\tecc->read_page = sunxi_nfc_hw_ecc_read_page;\n\t\tecc->read_subpage = sunxi_nfc_hw_ecc_read_subpage;\n\t\tecc->write_page = sunxi_nfc_hw_ecc_write_page;\n\t}\n\n\t \n\tecc->write_subpage = sunxi_nfc_hw_ecc_write_subpage;\n\tecc->read_oob_raw = nand_read_oob_std;\n\tecc->write_oob_raw = nand_write_oob_std;\n\n\tsunxi_nand->ecc.ecc_ctl = NFC_ECC_MODE(i) | NFC_ECC_EXCEPTION |\n\t\t\t\t  NFC_ECC_PIPELINE | NFC_ECC_EN;\n\n\tif (ecc->size == 512)\n\t\tsunxi_nand->ecc.ecc_ctl |= NFC_ECC_BLOCK_512;\n\n\treturn 0;\n}\n\nstatic int sunxi_nand_attach_chip(struct nand_chip *nand)\n{\n\tconst struct nand_ecc_props *requirements =\n\t\tnanddev_get_ecc_requirements(&nand->base);\n\tstruct nand_ecc_ctrl *ecc = &nand->ecc;\n\tstruct device_node *np = nand_get_flash_node(nand);\n\tint ret;\n\n\tif (nand->bbt_options & NAND_BBT_USE_FLASH)\n\t\tnand->bbt_options |= NAND_BBT_NO_OOB;\n\n\tif (nand->options & NAND_NEED_SCRAMBLING)\n\t\tnand->options |= NAND_NO_SUBPAGE_WRITE;\n\n\tnand->options |= NAND_SUBPAGE_READ;\n\n\tif (!ecc->size) {\n\t\tecc->size = requirements->step_size;\n\t\tecc->strength = requirements->strength;\n\t}\n\n\tif (!ecc->size || !ecc->strength)\n\t\treturn -EINVAL;\n\n\tswitch (ecc->engine_type) {\n\tcase NAND_ECC_ENGINE_TYPE_ON_HOST:\n\t\tret = sunxi_nand_hw_ecc_ctrl_init(nand, ecc, np);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tbreak;\n\tcase NAND_ECC_ENGINE_TYPE_NONE:\n\tcase NAND_ECC_ENGINE_TYPE_SOFT:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int sunxi_nfc_exec_subop(struct nand_chip *nand,\n\t\t\t\tconst struct nand_subop *subop)\n{\n\tstruct sunxi_nfc *nfc = to_sunxi_nfc(nand->controller);\n\tu32 cmd = 0, extcmd = 0, cnt = 0, addrs[2] = { };\n\tunsigned int i, j, remaining, start;\n\tvoid *inbuf = NULL;\n\tint ret;\n\n\tfor (i = 0; i < subop->ninstrs; i++) {\n\t\tconst struct nand_op_instr *instr = &subop->instrs[i];\n\n\t\tswitch (instr->type) {\n\t\tcase NAND_OP_CMD_INSTR:\n\t\t\tif (cmd & NFC_SEND_CMD1) {\n\t\t\t\tif (WARN_ON(cmd & NFC_SEND_CMD2))\n\t\t\t\t\treturn -EINVAL;\n\n\t\t\t\tcmd |= NFC_SEND_CMD2;\n\t\t\t\textcmd |= instr->ctx.cmd.opcode;\n\t\t\t} else {\n\t\t\t\tcmd |= NFC_SEND_CMD1 |\n\t\t\t\t       NFC_CMD(instr->ctx.cmd.opcode);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase NAND_OP_ADDR_INSTR:\n\t\t\tremaining = nand_subop_get_num_addr_cyc(subop, i);\n\t\t\tstart = nand_subop_get_addr_start_off(subop, i);\n\t\t\tfor (j = 0; j < 8 && j + start < remaining; j++) {\n\t\t\t\tu32 addr = instr->ctx.addr.addrs[j + start];\n\n\t\t\t\taddrs[j / 4] |= addr << (j % 4) * 8;\n\t\t\t}\n\n\t\t\tif (j)\n\t\t\t\tcmd |= NFC_SEND_ADR | NFC_ADR_NUM(j);\n\n\t\t\tbreak;\n\n\t\tcase NAND_OP_DATA_IN_INSTR:\n\t\tcase NAND_OP_DATA_OUT_INSTR:\n\t\t\tstart = nand_subop_get_data_start_off(subop, i);\n\t\t\tremaining = nand_subop_get_data_len(subop, i);\n\t\t\tcnt = min_t(u32, remaining, NFC_SRAM_SIZE);\n\t\t\tcmd |= NFC_DATA_TRANS | NFC_DATA_SWAP_METHOD;\n\n\t\t\tif (instr->type == NAND_OP_DATA_OUT_INSTR) {\n\t\t\t\tcmd |= NFC_ACCESS_DIR;\n\t\t\t\tmemcpy_toio(nfc->regs + NFC_RAM0_BASE,\n\t\t\t\t\t    instr->ctx.data.buf.out + start,\n\t\t\t\t\t    cnt);\n\t\t\t} else {\n\t\t\t\tinbuf = instr->ctx.data.buf.in + start;\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase NAND_OP_WAITRDY_INSTR:\n\t\t\tcmd |= NFC_WAIT_FLAG;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tret = sunxi_nfc_wait_cmd_fifo_empty(nfc);\n\tif (ret)\n\t\treturn ret;\n\n\tif (cmd & NFC_SEND_ADR) {\n\t\twritel(addrs[0], nfc->regs + NFC_REG_ADDR_LOW);\n\t\twritel(addrs[1], nfc->regs + NFC_REG_ADDR_HIGH);\n\t}\n\n\tif (cmd & NFC_SEND_CMD2)\n\t\twritel(extcmd,\n\t\t       nfc->regs +\n\t\t       (cmd & NFC_ACCESS_DIR ?\n\t\t\tNFC_REG_WCMD_SET : NFC_REG_RCMD_SET));\n\n\tif (cmd & NFC_DATA_TRANS)\n\t\twritel(cnt, nfc->regs + NFC_REG_CNT);\n\n\twritel(cmd, nfc->regs + NFC_REG_CMD);\n\n\tret = sunxi_nfc_wait_events(nfc, NFC_CMD_INT_FLAG,\n\t\t\t\t    !(cmd & NFC_WAIT_FLAG) && cnt < 64,\n\t\t\t\t    0);\n\tif (ret)\n\t\treturn ret;\n\n\tif (inbuf)\n\t\tmemcpy_fromio(inbuf, nfc->regs + NFC_RAM0_BASE, cnt);\n\n\treturn 0;\n}\n\nstatic int sunxi_nfc_soft_waitrdy(struct nand_chip *nand,\n\t\t\t\t  const struct nand_subop *subop)\n{\n\treturn nand_soft_waitrdy(nand,\n\t\t\t\t subop->instrs[0].ctx.waitrdy.timeout_ms);\n}\n\nstatic const struct nand_op_parser sunxi_nfc_op_parser = NAND_OP_PARSER(\n\tNAND_OP_PARSER_PATTERN(sunxi_nfc_exec_subop,\n\t\t\t       NAND_OP_PARSER_PAT_CMD_ELEM(true),\n\t\t\t       NAND_OP_PARSER_PAT_ADDR_ELEM(true, 8),\n\t\t\t       NAND_OP_PARSER_PAT_CMD_ELEM(true),\n\t\t\t       NAND_OP_PARSER_PAT_WAITRDY_ELEM(true),\n\t\t\t       NAND_OP_PARSER_PAT_DATA_IN_ELEM(true, 1024)),\n\tNAND_OP_PARSER_PATTERN(sunxi_nfc_exec_subop,\n\t\t\t       NAND_OP_PARSER_PAT_CMD_ELEM(true),\n\t\t\t       NAND_OP_PARSER_PAT_ADDR_ELEM(true, 8),\n\t\t\t       NAND_OP_PARSER_PAT_DATA_OUT_ELEM(true, 1024),\n\t\t\t       NAND_OP_PARSER_PAT_CMD_ELEM(true),\n\t\t\t       NAND_OP_PARSER_PAT_WAITRDY_ELEM(true)),\n);\n\nstatic const struct nand_op_parser sunxi_nfc_norb_op_parser = NAND_OP_PARSER(\n\tNAND_OP_PARSER_PATTERN(sunxi_nfc_exec_subop,\n\t\t\t       NAND_OP_PARSER_PAT_CMD_ELEM(true),\n\t\t\t       NAND_OP_PARSER_PAT_ADDR_ELEM(true, 8),\n\t\t\t       NAND_OP_PARSER_PAT_CMD_ELEM(true),\n\t\t\t       NAND_OP_PARSER_PAT_DATA_IN_ELEM(true, 1024)),\n\tNAND_OP_PARSER_PATTERN(sunxi_nfc_exec_subop,\n\t\t\t       NAND_OP_PARSER_PAT_CMD_ELEM(true),\n\t\t\t       NAND_OP_PARSER_PAT_ADDR_ELEM(true, 8),\n\t\t\t       NAND_OP_PARSER_PAT_DATA_OUT_ELEM(true, 1024),\n\t\t\t       NAND_OP_PARSER_PAT_CMD_ELEM(true)),\n\tNAND_OP_PARSER_PATTERN(sunxi_nfc_soft_waitrdy,\n\t\t\t       NAND_OP_PARSER_PAT_WAITRDY_ELEM(false)),\n);\n\nstatic int sunxi_nfc_exec_op(struct nand_chip *nand,\n\t\t\t     const struct nand_operation *op, bool check_only)\n{\n\tstruct sunxi_nand_chip *sunxi_nand = to_sunxi_nand(nand);\n\tconst struct nand_op_parser *parser;\n\n\tif (!check_only)\n\t\tsunxi_nfc_select_chip(nand, op->cs);\n\n\tif (sunxi_nand->sels[op->cs].rb >= 0)\n\t\tparser = &sunxi_nfc_op_parser;\n\telse\n\t\tparser = &sunxi_nfc_norb_op_parser;\n\n\treturn nand_op_parser_exec_op(nand, parser, op, check_only);\n}\n\nstatic const struct nand_controller_ops sunxi_nand_controller_ops = {\n\t.attach_chip = sunxi_nand_attach_chip,\n\t.setup_interface = sunxi_nfc_setup_interface,\n\t.exec_op = sunxi_nfc_exec_op,\n};\n\nstatic void sunxi_nand_chips_cleanup(struct sunxi_nfc *nfc)\n{\n\tstruct sunxi_nand_chip *sunxi_nand;\n\tstruct nand_chip *chip;\n\tint ret;\n\n\twhile (!list_empty(&nfc->chips)) {\n\t\tsunxi_nand = list_first_entry(&nfc->chips,\n\t\t\t\t\t      struct sunxi_nand_chip,\n\t\t\t\t\t      node);\n\t\tchip = &sunxi_nand->nand;\n\t\tret = mtd_device_unregister(nand_to_mtd(chip));\n\t\tWARN_ON(ret);\n\t\tnand_cleanup(chip);\n\t\tlist_del(&sunxi_nand->node);\n\t}\n}\n\nstatic int sunxi_nand_chip_init(struct device *dev, struct sunxi_nfc *nfc,\n\t\t\t\tstruct device_node *np)\n{\n\tstruct sunxi_nand_chip *sunxi_nand;\n\tstruct mtd_info *mtd;\n\tstruct nand_chip *nand;\n\tint nsels;\n\tint ret;\n\tint i;\n\tu32 tmp;\n\n\tif (!of_get_property(np, \"reg\", &nsels))\n\t\treturn -EINVAL;\n\n\tnsels /= sizeof(u32);\n\tif (!nsels) {\n\t\tdev_err(dev, \"invalid reg property size\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tsunxi_nand = devm_kzalloc(dev, struct_size(sunxi_nand, sels, nsels),\n\t\t\t\t  GFP_KERNEL);\n\tif (!sunxi_nand)\n\t\treturn -ENOMEM;\n\n\tsunxi_nand->nsels = nsels;\n\n\tfor (i = 0; i < nsels; i++) {\n\t\tret = of_property_read_u32_index(np, \"reg\", i, &tmp);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"could not retrieve reg property: %d\\n\",\n\t\t\t\tret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (tmp > NFC_MAX_CS) {\n\t\t\tdev_err(dev,\n\t\t\t\t\"invalid reg value: %u (max CS = 7)\\n\",\n\t\t\t\ttmp);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (test_and_set_bit(tmp, &nfc->assigned_cs)) {\n\t\t\tdev_err(dev, \"CS %d already assigned\\n\", tmp);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tsunxi_nand->sels[i].cs = tmp;\n\n\t\tif (!of_property_read_u32_index(np, \"allwinner,rb\", i, &tmp) &&\n\t\t    tmp < 2)\n\t\t\tsunxi_nand->sels[i].rb = tmp;\n\t\telse\n\t\t\tsunxi_nand->sels[i].rb = -1;\n\t}\n\n\tnand = &sunxi_nand->nand;\n\t \n\tnand->controller = &nfc->controller;\n\tnand->controller->ops = &sunxi_nand_controller_ops;\n\n\t \n\tnand->ecc.engine_type = NAND_ECC_ENGINE_TYPE_ON_HOST;\n\tnand_set_flash_node(nand, np);\n\n\tmtd = nand_to_mtd(nand);\n\tmtd->dev.parent = dev;\n\n\tret = nand_scan(nand, nsels);\n\tif (ret)\n\t\treturn ret;\n\n\tret = mtd_device_register(mtd, NULL, 0);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to register mtd device: %d\\n\", ret);\n\t\tnand_cleanup(nand);\n\t\treturn ret;\n\t}\n\n\tlist_add_tail(&sunxi_nand->node, &nfc->chips);\n\n\treturn 0;\n}\n\nstatic int sunxi_nand_chips_init(struct device *dev, struct sunxi_nfc *nfc)\n{\n\tstruct device_node *np = dev->of_node;\n\tstruct device_node *nand_np;\n\tint ret;\n\n\tfor_each_child_of_node(np, nand_np) {\n\t\tret = sunxi_nand_chip_init(dev, nfc, nand_np);\n\t\tif (ret) {\n\t\t\tof_node_put(nand_np);\n\t\t\tsunxi_nand_chips_cleanup(nfc);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int sunxi_nfc_dma_init(struct sunxi_nfc *nfc, struct resource *r)\n{\n\tint ret;\n\n\tif (nfc->caps->has_mdma)\n\t\treturn 0;\n\n\tnfc->dmac = dma_request_chan(nfc->dev, \"rxtx\");\n\tif (IS_ERR(nfc->dmac)) {\n\t\tret = PTR_ERR(nfc->dmac);\n\t\tif (ret == -EPROBE_DEFER)\n\t\t\treturn ret;\n\n\t\t \n\t\tdev_warn(nfc->dev, \"failed to request rxtx DMA channel: %d\\n\", ret);\n\t\tnfc->dmac = NULL;\n\t} else {\n\t\tstruct dma_slave_config dmac_cfg = { };\n\n\t\tdmac_cfg.src_addr = r->start + nfc->caps->reg_io_data;\n\t\tdmac_cfg.dst_addr = dmac_cfg.src_addr;\n\t\tdmac_cfg.src_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;\n\t\tdmac_cfg.dst_addr_width = dmac_cfg.src_addr_width;\n\t\tdmac_cfg.src_maxburst = nfc->caps->dma_maxburst;\n\t\tdmac_cfg.dst_maxburst = nfc->caps->dma_maxburst;\n\t\tdmaengine_slave_config(nfc->dmac, &dmac_cfg);\n\t}\n\treturn 0;\n}\n\nstatic int sunxi_nfc_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct resource *r;\n\tstruct sunxi_nfc *nfc;\n\tint irq;\n\tint ret;\n\n\tnfc = devm_kzalloc(dev, sizeof(*nfc), GFP_KERNEL);\n\tif (!nfc)\n\t\treturn -ENOMEM;\n\n\tnfc->dev = dev;\n\tnand_controller_init(&nfc->controller);\n\tINIT_LIST_HEAD(&nfc->chips);\n\n\tnfc->regs = devm_platform_get_and_ioremap_resource(pdev, 0, &r);\n\tif (IS_ERR(nfc->regs))\n\t\treturn PTR_ERR(nfc->regs);\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tnfc->ahb_clk = devm_clk_get_enabled(dev, \"ahb\");\n\tif (IS_ERR(nfc->ahb_clk)) {\n\t\tdev_err(dev, \"failed to retrieve ahb clk\\n\");\n\t\treturn PTR_ERR(nfc->ahb_clk);\n\t}\n\n\tnfc->mod_clk = devm_clk_get_enabled(dev, \"mod\");\n\tif (IS_ERR(nfc->mod_clk)) {\n\t\tdev_err(dev, \"failed to retrieve mod clk\\n\");\n\t\treturn PTR_ERR(nfc->mod_clk);\n\t}\n\n\tnfc->reset = devm_reset_control_get_optional_exclusive(dev, \"ahb\");\n\tif (IS_ERR(nfc->reset))\n\t\treturn PTR_ERR(nfc->reset);\n\n\tret = reset_control_deassert(nfc->reset);\n\tif (ret) {\n\t\tdev_err(dev, \"reset err %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tnfc->caps = of_device_get_match_data(&pdev->dev);\n\tif (!nfc->caps) {\n\t\tret = -EINVAL;\n\t\tgoto out_ahb_reset_reassert;\n\t}\n\n\tret = sunxi_nfc_rst(nfc);\n\tif (ret)\n\t\tgoto out_ahb_reset_reassert;\n\n\twritel(0, nfc->regs + NFC_REG_INT);\n\tret = devm_request_irq(dev, irq, sunxi_nfc_interrupt,\n\t\t\t       0, \"sunxi-nand\", nfc);\n\tif (ret)\n\t\tgoto out_ahb_reset_reassert;\n\n\tret = sunxi_nfc_dma_init(nfc, r);\n\n\tif (ret)\n\t\tgoto out_ahb_reset_reassert;\n\n\tplatform_set_drvdata(pdev, nfc);\n\n\tret = sunxi_nand_chips_init(dev, nfc);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to init nand chips\\n\");\n\t\tgoto out_release_dmac;\n\t}\n\n\treturn 0;\n\nout_release_dmac:\n\tif (nfc->dmac)\n\t\tdma_release_channel(nfc->dmac);\nout_ahb_reset_reassert:\n\treset_control_assert(nfc->reset);\n\n\treturn ret;\n}\n\nstatic void sunxi_nfc_remove(struct platform_device *pdev)\n{\n\tstruct sunxi_nfc *nfc = platform_get_drvdata(pdev);\n\n\tsunxi_nand_chips_cleanup(nfc);\n\n\treset_control_assert(nfc->reset);\n\n\tif (nfc->dmac)\n\t\tdma_release_channel(nfc->dmac);\n}\n\nstatic const struct sunxi_nfc_caps sunxi_nfc_a10_caps = {\n\t.reg_io_data = NFC_REG_A10_IO_DATA,\n\t.dma_maxburst = 4,\n};\n\nstatic const struct sunxi_nfc_caps sunxi_nfc_a23_caps = {\n\t.has_mdma = true,\n\t.reg_io_data = NFC_REG_A23_IO_DATA,\n\t.dma_maxburst = 8,\n};\n\nstatic const struct of_device_id sunxi_nfc_ids[] = {\n\t{\n\t\t.compatible = \"allwinner,sun4i-a10-nand\",\n\t\t.data = &sunxi_nfc_a10_caps,\n\t},\n\t{\n\t\t.compatible = \"allwinner,sun8i-a23-nand-controller\",\n\t\t.data = &sunxi_nfc_a23_caps,\n\t},\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, sunxi_nfc_ids);\n\nstatic struct platform_driver sunxi_nfc_driver = {\n\t.driver = {\n\t\t.name = \"sunxi_nand\",\n\t\t.of_match_table = sunxi_nfc_ids,\n\t},\n\t.probe = sunxi_nfc_probe,\n\t.remove_new = sunxi_nfc_remove,\n};\nmodule_platform_driver(sunxi_nfc_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Boris BREZILLON\");\nMODULE_DESCRIPTION(\"Allwinner NAND Flash Controller driver\");\nMODULE_ALIAS(\"platform:sunxi_nand\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}