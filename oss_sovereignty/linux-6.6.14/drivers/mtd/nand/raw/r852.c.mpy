{
  "module_name": "r852.c",
  "hash_id": "7ec64adddd30dbed986ad00fae8d4fc9e001c2fec3fff29af1bbcb37c68e0ff0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/nand/raw/r852.c",
  "human_readable_source": "\n \n\n#define DRV_NAME \"r852\"\n#define pr_fmt(fmt)  DRV_NAME \": \" fmt\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/jiffies.h>\n#include <linux/workqueue.h>\n#include <linux/interrupt.h>\n#include <linux/pci.h>\n#include <linux/pci_ids.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <asm/byteorder.h>\n#include <linux/sched.h>\n#include \"sm_common.h\"\n#include \"r852.h\"\n\n\nstatic bool r852_enable_dma = 1;\nmodule_param(r852_enable_dma, bool, S_IRUGO);\nMODULE_PARM_DESC(r852_enable_dma, \"Enable usage of the DMA (default)\");\n\nstatic int debug;\nmodule_param(debug, int, S_IRUGO | S_IWUSR);\nMODULE_PARM_DESC(debug, \"Debug level (0-2)\");\n\n \nstatic inline uint8_t r852_read_reg(struct r852_device *dev, int address)\n{\n\tuint8_t reg = readb(dev->mmio + address);\n\treturn reg;\n}\n\n \nstatic inline void r852_write_reg(struct r852_device *dev,\n\t\t\t\t\t\tint address, uint8_t value)\n{\n\twriteb(value, dev->mmio + address);\n}\n\n\n \nstatic inline uint32_t r852_read_reg_dword(struct r852_device *dev, int address)\n{\n\tuint32_t reg = le32_to_cpu(readl(dev->mmio + address));\n\treturn reg;\n}\n\n \nstatic inline void r852_write_reg_dword(struct r852_device *dev,\n\t\t\t\t\t\t\tint address, uint32_t value)\n{\n\twritel(cpu_to_le32(value), dev->mmio + address);\n}\n\n \nstatic inline struct r852_device *r852_get_dev(struct mtd_info *mtd)\n{\n\tstruct nand_chip *chip = mtd_to_nand(mtd);\n\treturn nand_get_controller_data(chip);\n}\n\n\n \nstatic void r852_dma_test(struct r852_device *dev)\n{\n\tdev->dma_usable = (r852_read_reg(dev, R852_DMA_CAP) &\n\t\t(R852_DMA1 | R852_DMA2)) == (R852_DMA1 | R852_DMA2);\n\n\tif (!dev->dma_usable)\n\t\tmessage(\"Non dma capable device detected, dma disabled\");\n\n\tif (!r852_enable_dma) {\n\t\tmessage(\"disabling dma on user request\");\n\t\tdev->dma_usable = 0;\n\t}\n}\n\n \nstatic void r852_dma_enable(struct r852_device *dev)\n{\n\tuint8_t dma_reg, dma_irq_reg;\n\n\t \n\tdma_reg = r852_read_reg_dword(dev, R852_DMA_SETTINGS);\n\tdma_reg &= ~(R852_DMA_READ | R852_DMA_INTERNAL | R852_DMA_MEMORY);\n\n\tif (dev->dma_dir)\n\t\tdma_reg |= R852_DMA_READ;\n\n\tif (dev->dma_state == DMA_INTERNAL) {\n\t\tdma_reg |= R852_DMA_INTERNAL;\n\t\t \n\t\t\t \n\t\tr852_write_reg_dword(dev, R852_DMA_ADDR,\n\t\t\tcpu_to_le32(dev->phys_bounce_buffer));\n\t} else {\n\t\tdma_reg |= R852_DMA_MEMORY;\n\t\tr852_write_reg_dword(dev, R852_DMA_ADDR,\n\t\t\tcpu_to_le32(dev->phys_dma_addr));\n\t}\n\n\t \n\tr852_read_reg_dword(dev, R852_DMA_ADDR);\n\n\tr852_write_reg_dword(dev, R852_DMA_SETTINGS, dma_reg);\n\n\t \n\tdma_irq_reg = r852_read_reg_dword(dev, R852_DMA_IRQ_ENABLE);\n\tr852_write_reg_dword(dev, R852_DMA_IRQ_ENABLE,\n\t\tdma_irq_reg |\n\t\tR852_DMA_IRQ_INTERNAL |\n\t\tR852_DMA_IRQ_ERROR |\n\t\tR852_DMA_IRQ_MEMORY);\n}\n\n \nstatic void r852_dma_done(struct r852_device *dev, int error)\n{\n\tWARN_ON(dev->dma_stage == 0);\n\n\tr852_write_reg_dword(dev, R852_DMA_IRQ_STA,\n\t\t\tr852_read_reg_dword(dev, R852_DMA_IRQ_STA));\n\n\tr852_write_reg_dword(dev, R852_DMA_SETTINGS, 0);\n\tr852_write_reg_dword(dev, R852_DMA_IRQ_ENABLE, 0);\n\n\t \n\tr852_write_reg_dword(dev, R852_DMA_ADDR,\n\t\tcpu_to_le32(dev->phys_bounce_buffer));\n\tr852_read_reg_dword(dev, R852_DMA_ADDR);\n\n\tdev->dma_error = error;\n\tdev->dma_stage = 0;\n\n\tif (dev->phys_dma_addr && dev->phys_dma_addr != dev->phys_bounce_buffer)\n\t\tdma_unmap_single(&dev->pci_dev->dev, dev->phys_dma_addr,\n\t\t\tR852_DMA_LEN,\n\t\t\tdev->dma_dir ? DMA_FROM_DEVICE : DMA_TO_DEVICE);\n}\n\n \nstatic int r852_dma_wait(struct r852_device *dev)\n{\n\tlong timeout = wait_for_completion_timeout(&dev->dma_done,\n\t\t\t\tmsecs_to_jiffies(1000));\n\tif (!timeout) {\n\t\tdbg(\"timeout waiting for DMA interrupt\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\treturn 0;\n}\n\n \nstatic void r852_do_dma(struct r852_device *dev, uint8_t *buf, int do_read)\n{\n\tint bounce = 0;\n\tunsigned long flags;\n\tint error;\n\n\tdev->dma_error = 0;\n\n\t \n\tdev->dma_dir = do_read;\n\tdev->dma_stage = 1;\n\treinit_completion(&dev->dma_done);\n\n\tdbg_verbose(\"doing dma %s \", do_read ? \"read\" : \"write\");\n\n\t \n\tdev->dma_state = do_read ? DMA_INTERNAL : DMA_MEMORY;\n\n\t \n\tif ((unsigned long)buf & (R852_DMA_LEN-1))\n\t\tbounce = 1;\n\n\tif (!bounce) {\n\t\tdev->phys_dma_addr = dma_map_single(&dev->pci_dev->dev, buf,\n\t\t\tR852_DMA_LEN,\n\t\t\tdo_read ? DMA_FROM_DEVICE : DMA_TO_DEVICE);\n\t\tif (dma_mapping_error(&dev->pci_dev->dev, dev->phys_dma_addr))\n\t\t\tbounce = 1;\n\t}\n\n\tif (bounce) {\n\t\tdbg_verbose(\"dma: using bounce buffer\");\n\t\tdev->phys_dma_addr = dev->phys_bounce_buffer;\n\t\tif (!do_read)\n\t\t\tmemcpy(dev->bounce_buffer, buf, R852_DMA_LEN);\n\t}\n\n\t \n\tspin_lock_irqsave(&dev->irqlock, flags);\n\tr852_dma_enable(dev);\n\tspin_unlock_irqrestore(&dev->irqlock, flags);\n\n\t \n\terror = r852_dma_wait(dev);\n\n\tif (error) {\n\t\tr852_dma_done(dev, error);\n\t\treturn;\n\t}\n\n\tif (do_read && bounce)\n\t\tmemcpy((void *)buf, dev->bounce_buffer, R852_DMA_LEN);\n}\n\n \nstatic void r852_write_buf(struct nand_chip *chip, const uint8_t *buf, int len)\n{\n\tstruct r852_device *dev = r852_get_dev(nand_to_mtd(chip));\n\tuint32_t reg;\n\n\t \n\tif (dev->card_unstable)\n\t\treturn;\n\n\t \n\tif (len == R852_DMA_LEN && dev->dma_usable) {\n\t\tr852_do_dma(dev, (uint8_t *)buf, 0);\n\t\treturn;\n\t}\n\n\t \n\twhile (len >= 4) {\n\t\treg = buf[0] | buf[1] << 8 | buf[2] << 16 | buf[3] << 24;\n\t\tr852_write_reg_dword(dev, R852_DATALINE, reg);\n\t\tbuf += 4;\n\t\tlen -= 4;\n\n\t}\n\n\t \n\twhile (len > 0) {\n\t\tr852_write_reg(dev, R852_DATALINE, *buf++);\n\t\tlen--;\n\t}\n}\n\n \nstatic void r852_read_buf(struct nand_chip *chip, uint8_t *buf, int len)\n{\n\tstruct r852_device *dev = r852_get_dev(nand_to_mtd(chip));\n\tuint32_t reg;\n\n\tif (dev->card_unstable) {\n\t\t \n\t\tmemset(buf, 0, len);\n\t\treturn;\n\t}\n\n\t \n\tif (len == R852_DMA_LEN && dev->dma_usable) {\n\t\tr852_do_dma(dev, buf, 1);\n\t\treturn;\n\t}\n\n\t \n\twhile (len >= 4) {\n\n\t\treg = r852_read_reg_dword(dev, R852_DATALINE);\n\t\t*buf++ = reg & 0xFF;\n\t\t*buf++ = (reg >> 8) & 0xFF;\n\t\t*buf++ = (reg >> 16) & 0xFF;\n\t\t*buf++ = (reg >> 24) & 0xFF;\n\t\tlen -= 4;\n\t}\n\n\t \n\twhile (len--)\n\t\t*buf++ = r852_read_reg(dev, R852_DATALINE);\n}\n\n \nstatic uint8_t r852_read_byte(struct nand_chip *chip)\n{\n\tstruct r852_device *dev = r852_get_dev(nand_to_mtd(chip));\n\n\t \n\tif (dev->card_unstable)\n\t\treturn 0;\n\n\treturn r852_read_reg(dev, R852_DATALINE);\n}\n\n \nstatic void r852_cmdctl(struct nand_chip *chip, int dat, unsigned int ctrl)\n{\n\tstruct r852_device *dev = r852_get_dev(nand_to_mtd(chip));\n\n\tif (dev->card_unstable)\n\t\treturn;\n\n\tif (ctrl & NAND_CTRL_CHANGE) {\n\n\t\tdev->ctlreg &= ~(R852_CTL_DATA | R852_CTL_COMMAND |\n\t\t\t\t R852_CTL_ON | R852_CTL_CARDENABLE);\n\n\t\tif (ctrl & NAND_ALE)\n\t\t\tdev->ctlreg |= R852_CTL_DATA;\n\n\t\tif (ctrl & NAND_CLE)\n\t\t\tdev->ctlreg |= R852_CTL_COMMAND;\n\n\t\tif (ctrl & NAND_NCE)\n\t\t\tdev->ctlreg |= (R852_CTL_CARDENABLE | R852_CTL_ON);\n\t\telse\n\t\t\tdev->ctlreg &= ~R852_CTL_WRITE;\n\n\t\t \n\t\tif (dat == NAND_CMD_ERASE1)\n\t\t\tdev->ctlreg |= R852_CTL_WRITE;\n\n\t\tr852_write_reg(dev, R852_CTL, dev->ctlreg);\n\t}\n\n\t  \n\tif (dat == NAND_CMD_SEQIN && (dev->ctlreg & R852_CTL_COMMAND)) {\n\t\tdev->ctlreg |= R852_CTL_WRITE;\n\t\tr852_write_reg(dev, R852_CTL, dev->ctlreg);\n\t}\n\n\tif (dat != NAND_CMD_NONE)\n\t\tr852_write_reg(dev, R852_DATALINE, dat);\n}\n\n \nstatic int r852_wait(struct nand_chip *chip)\n{\n\tstruct r852_device *dev = nand_get_controller_data(chip);\n\n\tunsigned long timeout;\n\tu8 status;\n\n\ttimeout = jiffies + msecs_to_jiffies(400);\n\n\twhile (time_before(jiffies, timeout))\n\t\tif (chip->legacy.dev_ready(chip))\n\t\t\tbreak;\n\n\tnand_status_op(chip, &status);\n\n\t \n\tif (dev->dma_error) {\n\t\tstatus |= NAND_STATUS_FAIL;\n\t\tdev->dma_error = 0;\n\t}\n\treturn status;\n}\n\n \n\nstatic int r852_ready(struct nand_chip *chip)\n{\n\tstruct r852_device *dev = r852_get_dev(nand_to_mtd(chip));\n\treturn !(r852_read_reg(dev, R852_CARD_STA) & R852_CARD_STA_BUSY);\n}\n\n\n \n\nstatic void r852_ecc_hwctl(struct nand_chip *chip, int mode)\n{\n\tstruct r852_device *dev = r852_get_dev(nand_to_mtd(chip));\n\n\tif (dev->card_unstable)\n\t\treturn;\n\n\tswitch (mode) {\n\tcase NAND_ECC_READ:\n\tcase NAND_ECC_WRITE:\n\t\t \n\t\tdev->ctlreg |= R852_CTL_ECC_ENABLE;\n\n\t\t \n\t\tr852_write_reg(dev, R852_CTL,\n\t\t\tdev->ctlreg | R852_CTL_ECC_ACCESS);\n\n\t\tr852_read_reg_dword(dev, R852_DATALINE);\n\t\tr852_write_reg(dev, R852_CTL, dev->ctlreg);\n\t\treturn;\n\n\tcase NAND_ECC_READSYN:\n\t\t \n\t\tdev->ctlreg &= ~R852_CTL_ECC_ENABLE;\n\t\tr852_write_reg(dev, R852_CTL, dev->ctlreg);\n\t}\n}\n\n \n\nstatic int r852_ecc_calculate(struct nand_chip *chip, const uint8_t *dat,\n\t\t\t      uint8_t *ecc_code)\n{\n\tstruct r852_device *dev = r852_get_dev(nand_to_mtd(chip));\n\tstruct sm_oob *oob = (struct sm_oob *)ecc_code;\n\tuint32_t ecc1, ecc2;\n\n\tif (dev->card_unstable)\n\t\treturn 0;\n\n\tdev->ctlreg &= ~R852_CTL_ECC_ENABLE;\n\tr852_write_reg(dev, R852_CTL, dev->ctlreg | R852_CTL_ECC_ACCESS);\n\n\tecc1 = r852_read_reg_dword(dev, R852_DATALINE);\n\tecc2 = r852_read_reg_dword(dev, R852_DATALINE);\n\n\toob->ecc1[0] = (ecc1) & 0xFF;\n\toob->ecc1[1] = (ecc1 >> 8) & 0xFF;\n\toob->ecc1[2] = (ecc1 >> 16) & 0xFF;\n\n\toob->ecc2[0] = (ecc2) & 0xFF;\n\toob->ecc2[1] = (ecc2 >> 8) & 0xFF;\n\toob->ecc2[2] = (ecc2 >> 16) & 0xFF;\n\n\tr852_write_reg(dev, R852_CTL, dev->ctlreg);\n\treturn 0;\n}\n\n \n\nstatic int r852_ecc_correct(struct nand_chip *chip, uint8_t *dat,\n\t\t\t    uint8_t *read_ecc, uint8_t *calc_ecc)\n{\n\tuint32_t ecc_reg;\n\tuint8_t ecc_status, err_byte;\n\tint i, error = 0;\n\n\tstruct r852_device *dev = r852_get_dev(nand_to_mtd(chip));\n\n\tif (dev->card_unstable)\n\t\treturn 0;\n\n\tif (dev->dma_error) {\n\t\tdev->dma_error = 0;\n\t\treturn -EIO;\n\t}\n\n\tr852_write_reg(dev, R852_CTL, dev->ctlreg | R852_CTL_ECC_ACCESS);\n\tecc_reg = r852_read_reg_dword(dev, R852_DATALINE);\n\tr852_write_reg(dev, R852_CTL, dev->ctlreg);\n\n\tfor (i = 0 ; i <= 1 ; i++) {\n\n\t\tecc_status = (ecc_reg >> 8) & 0xFF;\n\n\t\t \n\t\tif (ecc_status & R852_ECC_FAIL) {\n\t\t\tdbg(\"ecc: unrecoverable error, in half %d\", i);\n\t\t\terror = -EBADMSG;\n\t\t\tgoto exit;\n\t\t}\n\n\t\t \n\t\tif (ecc_status & R852_ECC_CORRECTABLE) {\n\n\t\t\terr_byte = ecc_reg & 0xFF;\n\t\t\tdbg(\"ecc: recoverable error, \"\n\t\t\t\t\"in half %d, byte %d, bit %d\", i,\n\t\t\t\terr_byte, ecc_status & R852_ECC_ERR_BIT_MSK);\n\n\t\t\tdat[err_byte] ^=\n\t\t\t\t1 << (ecc_status & R852_ECC_ERR_BIT_MSK);\n\t\t\terror++;\n\t\t}\n\n\t\tdat += 256;\n\t\tecc_reg >>= 16;\n\t}\nexit:\n\treturn error;\n}\n\n \nstatic int r852_read_oob(struct nand_chip *chip, int page)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\n\treturn nand_read_oob_op(chip, page, 0, chip->oob_poi, mtd->oobsize);\n}\n\n \n\nstatic void r852_engine_enable(struct r852_device *dev)\n{\n\tif (r852_read_reg_dword(dev, R852_HW) & R852_HW_UNKNOWN) {\n\t\tr852_write_reg(dev, R852_CTL, R852_CTL_RESET | R852_CTL_ON);\n\t\tr852_write_reg_dword(dev, R852_HW, R852_HW_ENABLED);\n\t} else {\n\t\tr852_write_reg_dword(dev, R852_HW, R852_HW_ENABLED);\n\t\tr852_write_reg(dev, R852_CTL, R852_CTL_RESET | R852_CTL_ON);\n\t}\n\tmsleep(300);\n\tr852_write_reg(dev, R852_CTL, 0);\n}\n\n\n \n\nstatic void r852_engine_disable(struct r852_device *dev)\n{\n\tr852_write_reg_dword(dev, R852_HW, 0);\n\tr852_write_reg(dev, R852_CTL, R852_CTL_RESET);\n}\n\n \n\nstatic void r852_card_update_present(struct r852_device *dev)\n{\n\tunsigned long flags;\n\tuint8_t reg;\n\n\tspin_lock_irqsave(&dev->irqlock, flags);\n\treg = r852_read_reg(dev, R852_CARD_STA);\n\tdev->card_detected = !!(reg & R852_CARD_STA_PRESENT);\n\tspin_unlock_irqrestore(&dev->irqlock, flags);\n}\n\n \nstatic void r852_update_card_detect(struct r852_device *dev)\n{\n\tint card_detect_reg = r852_read_reg(dev, R852_CARD_IRQ_ENABLE);\n\tdev->card_unstable = 0;\n\n\tcard_detect_reg &= ~(R852_CARD_IRQ_REMOVE | R852_CARD_IRQ_INSERT);\n\tcard_detect_reg |= R852_CARD_IRQ_GENABLE;\n\n\tcard_detect_reg |= dev->card_detected ?\n\t\tR852_CARD_IRQ_REMOVE : R852_CARD_IRQ_INSERT;\n\n\tr852_write_reg(dev, R852_CARD_IRQ_ENABLE, card_detect_reg);\n}\n\nstatic ssize_t media_type_show(struct device *sys_dev,\n\t\t\t       struct device_attribute *attr, char *buf)\n{\n\tstruct mtd_info *mtd = container_of(sys_dev, struct mtd_info, dev);\n\tstruct r852_device *dev = r852_get_dev(mtd);\n\tchar *data = dev->sm ? \"smartmedia\" : \"xd\";\n\n\tstrcpy(buf, data);\n\treturn strlen(data);\n}\nstatic DEVICE_ATTR_RO(media_type);\n\n\n \nstatic void r852_update_media_status(struct r852_device *dev)\n{\n\tuint8_t reg;\n\tunsigned long flags;\n\tint readonly;\n\n\tspin_lock_irqsave(&dev->irqlock, flags);\n\tif (!dev->card_detected) {\n\t\tmessage(\"card removed\");\n\t\tspin_unlock_irqrestore(&dev->irqlock, flags);\n\t\treturn ;\n\t}\n\n\treadonly  = r852_read_reg(dev, R852_CARD_STA) & R852_CARD_STA_RO;\n\treg = r852_read_reg(dev, R852_DMA_CAP);\n\tdev->sm = (reg & (R852_DMA1 | R852_DMA2)) && (reg & R852_SMBIT);\n\n\tmessage(\"detected %s %s card in slot\",\n\t\tdev->sm ? \"SmartMedia\" : \"xD\",\n\t\treadonly ? \"readonly\" : \"writeable\");\n\n\tdev->readonly = readonly;\n\tspin_unlock_irqrestore(&dev->irqlock, flags);\n}\n\n \nstatic int r852_register_nand_device(struct r852_device *dev)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(dev->chip);\n\n\tWARN_ON(dev->card_registered);\n\n\tmtd->dev.parent = &dev->pci_dev->dev;\n\n\tif (dev->readonly)\n\t\tdev->chip->options |= NAND_ROM;\n\n\tr852_engine_enable(dev);\n\n\tif (sm_register_device(mtd, dev->sm))\n\t\tgoto error1;\n\n\tif (device_create_file(&mtd->dev, &dev_attr_media_type)) {\n\t\tmessage(\"can't create media type sysfs attribute\");\n\t\tgoto error3;\n\t}\n\n\tdev->card_registered = 1;\n\treturn 0;\nerror3:\n\tWARN_ON(mtd_device_unregister(nand_to_mtd(dev->chip)));\n\tnand_cleanup(dev->chip);\nerror1:\n\t \n\tdev->card_detected = 0;\n\treturn -1;\n}\n\n \n\nstatic void r852_unregister_nand_device(struct r852_device *dev)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(dev->chip);\n\n\tif (!dev->card_registered)\n\t\treturn;\n\n\tdevice_remove_file(&mtd->dev, &dev_attr_media_type);\n\tWARN_ON(mtd_device_unregister(mtd));\n\tnand_cleanup(dev->chip);\n\tr852_engine_disable(dev);\n\tdev->card_registered = 0;\n}\n\n \nstatic void r852_card_detect_work(struct work_struct *work)\n{\n\tstruct r852_device *dev =\n\t\tcontainer_of(work, struct r852_device, card_detect_work.work);\n\n\tr852_card_update_present(dev);\n\tr852_update_card_detect(dev);\n\tdev->card_unstable = 0;\n\n\t \n\tif (dev->card_detected == dev->card_registered)\n\t\tgoto exit;\n\n\t \n\tr852_update_media_status(dev);\n\n\t \n\tif (dev->card_detected)\n\t\tr852_register_nand_device(dev);\n\telse\n\t\tr852_unregister_nand_device(dev);\nexit:\n\tr852_update_card_detect(dev);\n}\n\n \nstatic void r852_disable_irqs(struct r852_device *dev)\n{\n\tuint8_t reg;\n\treg = r852_read_reg(dev, R852_CARD_IRQ_ENABLE);\n\tr852_write_reg(dev, R852_CARD_IRQ_ENABLE, reg & ~R852_CARD_IRQ_MASK);\n\n\treg = r852_read_reg_dword(dev, R852_DMA_IRQ_ENABLE);\n\tr852_write_reg_dword(dev, R852_DMA_IRQ_ENABLE,\n\t\t\t\t\treg & ~R852_DMA_IRQ_MASK);\n\n\tr852_write_reg(dev, R852_CARD_IRQ_STA, R852_CARD_IRQ_MASK);\n\tr852_write_reg_dword(dev, R852_DMA_IRQ_STA, R852_DMA_IRQ_MASK);\n}\n\n \nstatic irqreturn_t r852_irq(int irq, void *data)\n{\n\tstruct r852_device *dev = (struct r852_device *)data;\n\n\tuint8_t card_status, dma_status;\n\tirqreturn_t ret = IRQ_NONE;\n\n\tspin_lock(&dev->irqlock);\n\n\t \n\tcard_status = r852_read_reg(dev, R852_CARD_IRQ_STA);\n\tr852_write_reg(dev, R852_CARD_IRQ_STA, card_status);\n\n\tif (card_status & (R852_CARD_IRQ_INSERT|R852_CARD_IRQ_REMOVE)) {\n\n\t\tret = IRQ_HANDLED;\n\t\tdev->card_detected = !!(card_status & R852_CARD_IRQ_INSERT);\n\n\t\t \n\t\tWARN_ON(dev->card_unstable);\n\n\t\t \n\t\t \n\t\tr852_disable_irqs(dev);\n\n\t\tif (dev->card_unstable)\n\t\t\tgoto out;\n\n\t\t \n\t\tdev->card_unstable = 1;\n\t\tqueue_delayed_work(dev->card_workqueue,\n\t\t\t&dev->card_detect_work, msecs_to_jiffies(100));\n\t\tgoto out;\n\t}\n\n\n\t \n\tdma_status = r852_read_reg_dword(dev, R852_DMA_IRQ_STA);\n\tr852_write_reg_dword(dev, R852_DMA_IRQ_STA, dma_status);\n\n\tif (dma_status & R852_DMA_IRQ_MASK) {\n\n\t\tret = IRQ_HANDLED;\n\n\t\tif (dma_status & R852_DMA_IRQ_ERROR) {\n\t\t\tdbg(\"received dma error IRQ\");\n\t\t\tr852_dma_done(dev, -EIO);\n\t\t\tcomplete(&dev->dma_done);\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\tWARN_ON_ONCE(dev->dma_stage == 0);\n\n\t\tif (dev->dma_stage == 0)\n\t\t\tgoto out;\n\n\t\t \n\t\tif (dev->dma_state == DMA_INTERNAL &&\n\t\t\t\t(dma_status & R852_DMA_IRQ_INTERNAL)) {\n\n\t\t\tdev->dma_state = DMA_MEMORY;\n\t\t\tdev->dma_stage++;\n\t\t}\n\n\t\t \n\t\tif (dev->dma_state == DMA_MEMORY &&\n\t\t\t\t(dma_status & R852_DMA_IRQ_MEMORY)) {\n\t\t\tdev->dma_state = DMA_INTERNAL;\n\t\t\tdev->dma_stage++;\n\t\t}\n\n\t\t \n\t\tif (dev->dma_stage == 2)\n\t\t\tr852_dma_enable(dev);\n\n\t\t \n\t\tif (dev->dma_stage == 3) {\n\t\t\tr852_dma_done(dev, 0);\n\t\t\tcomplete(&dev->dma_done);\n\t\t}\n\t\tgoto out;\n\t}\n\n\t \n\tif (dma_status)\n\t\tdbg(\"bad dma IRQ status = %x\", dma_status);\n\n\tif (card_status & ~R852_CARD_STA_CD)\n\t\tdbg(\"strange card status = %x\", card_status);\n\nout:\n\tspin_unlock(&dev->irqlock);\n\treturn ret;\n}\n\nstatic int r852_attach_chip(struct nand_chip *chip)\n{\n\tif (chip->ecc.engine_type != NAND_ECC_ENGINE_TYPE_ON_HOST)\n\t\treturn 0;\n\n\tchip->ecc.placement = NAND_ECC_PLACEMENT_INTERLEAVED;\n\tchip->ecc.size = R852_DMA_LEN;\n\tchip->ecc.bytes = SM_OOB_SIZE;\n\tchip->ecc.strength = 2;\n\tchip->ecc.hwctl = r852_ecc_hwctl;\n\tchip->ecc.calculate = r852_ecc_calculate;\n\tchip->ecc.correct = r852_ecc_correct;\n\n\t \n\tchip->ecc.read_oob = r852_read_oob;\n\n\treturn 0;\n}\n\nstatic const struct nand_controller_ops r852_ops = {\n\t.attach_chip = r852_attach_chip,\n};\n\nstatic int  r852_probe(struct pci_dev *pci_dev, const struct pci_device_id *id)\n{\n\tint error;\n\tstruct nand_chip *chip;\n\tstruct r852_device *dev;\n\n\t \n\terror = pci_enable_device(pci_dev);\n\n\tif (error)\n\t\tgoto error1;\n\n\tpci_set_master(pci_dev);\n\n\terror = dma_set_mask(&pci_dev->dev, DMA_BIT_MASK(32));\n\tif (error)\n\t\tgoto error2;\n\n\terror = pci_request_regions(pci_dev, DRV_NAME);\n\n\tif (error)\n\t\tgoto error3;\n\n\terror = -ENOMEM;\n\n\t \n\tchip = kzalloc(sizeof(struct nand_chip), GFP_KERNEL);\n\n\tif (!chip)\n\t\tgoto error4;\n\n\t \n\tchip->legacy.cmd_ctrl = r852_cmdctl;\n\tchip->legacy.waitfunc = r852_wait;\n\tchip->legacy.dev_ready = r852_ready;\n\n\t \n\tchip->legacy.read_byte = r852_read_byte;\n\tchip->legacy.read_buf = r852_read_buf;\n\tchip->legacy.write_buf = r852_write_buf;\n\n\t \n\tdev = kzalloc(sizeof(struct r852_device), GFP_KERNEL);\n\n\tif (!dev)\n\t\tgoto error5;\n\n\tnand_set_controller_data(chip, dev);\n\tdev->chip = chip;\n\tdev->pci_dev = pci_dev;\n\tpci_set_drvdata(pci_dev, dev);\n\n\tnand_controller_init(&dev->controller);\n\tdev->controller.ops = &r852_ops;\n\tchip->controller = &dev->controller;\n\n\tdev->bounce_buffer = dma_alloc_coherent(&pci_dev->dev, R852_DMA_LEN,\n\t\t&dev->phys_bounce_buffer, GFP_KERNEL);\n\n\tif (!dev->bounce_buffer)\n\t\tgoto error6;\n\n\n\terror = -ENODEV;\n\tdev->mmio = pci_ioremap_bar(pci_dev, 0);\n\n\tif (!dev->mmio)\n\t\tgoto error7;\n\n\terror = -ENOMEM;\n\tdev->tmp_buffer = kzalloc(SM_SECTOR_SIZE, GFP_KERNEL);\n\n\tif (!dev->tmp_buffer)\n\t\tgoto error8;\n\n\tinit_completion(&dev->dma_done);\n\n\tdev->card_workqueue = create_freezable_workqueue(DRV_NAME);\n\n\tif (!dev->card_workqueue)\n\t\tgoto error9;\n\n\tINIT_DELAYED_WORK(&dev->card_detect_work, r852_card_detect_work);\n\n\t \n\tr852_engine_disable(dev);\n\tr852_disable_irqs(dev);\n\n\tr852_dma_test(dev);\n\n\tdev->irq = pci_dev->irq;\n\tspin_lock_init(&dev->irqlock);\n\n\tdev->card_detected = 0;\n\tr852_card_update_present(dev);\n\n\t \n\terror = -ENODEV;\n\tif (request_irq(pci_dev->irq, &r852_irq, IRQF_SHARED,\n\t\t\t  DRV_NAME, dev))\n\t\tgoto error10;\n\n\t \n\tqueue_delayed_work(dev->card_workqueue,\n\t\t&dev->card_detect_work, 0);\n\n\n\tpr_notice(\"driver loaded successfully\\n\");\n\treturn 0;\n\nerror10:\n\tdestroy_workqueue(dev->card_workqueue);\nerror9:\n\tkfree(dev->tmp_buffer);\nerror8:\n\tpci_iounmap(pci_dev, dev->mmio);\nerror7:\n\tdma_free_coherent(&pci_dev->dev, R852_DMA_LEN, dev->bounce_buffer,\n\t\t\t  dev->phys_bounce_buffer);\nerror6:\n\tkfree(dev);\nerror5:\n\tkfree(chip);\nerror4:\n\tpci_release_regions(pci_dev);\nerror3:\nerror2:\n\tpci_disable_device(pci_dev);\nerror1:\n\treturn error;\n}\n\nstatic void r852_remove(struct pci_dev *pci_dev)\n{\n\tstruct r852_device *dev = pci_get_drvdata(pci_dev);\n\n\t \n\tcancel_delayed_work_sync(&dev->card_detect_work);\n\tdestroy_workqueue(dev->card_workqueue);\n\n\t \n\tr852_unregister_nand_device(dev);\n\n\t \n\tr852_disable_irqs(dev);\n\tfree_irq(dev->irq, dev);\n\n\t \n\tkfree(dev->tmp_buffer);\n\tpci_iounmap(pci_dev, dev->mmio);\n\tdma_free_coherent(&pci_dev->dev, R852_DMA_LEN, dev->bounce_buffer,\n\t\t\t  dev->phys_bounce_buffer);\n\n\tkfree(dev->chip);\n\tkfree(dev);\n\n\t \n\tpci_release_regions(pci_dev);\n\tpci_disable_device(pci_dev);\n}\n\nstatic void r852_shutdown(struct pci_dev *pci_dev)\n{\n\tstruct r852_device *dev = pci_get_drvdata(pci_dev);\n\n\tcancel_delayed_work_sync(&dev->card_detect_work);\n\tr852_disable_irqs(dev);\n\tsynchronize_irq(dev->irq);\n\tpci_disable_device(pci_dev);\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int r852_suspend(struct device *device)\n{\n\tstruct r852_device *dev = dev_get_drvdata(device);\n\n\tif (dev->ctlreg & R852_CTL_CARDENABLE)\n\t\treturn -EBUSY;\n\n\t \n\tcancel_delayed_work_sync(&dev->card_detect_work);\n\n\t \n\tr852_disable_irqs(dev);\n\tr852_engine_disable(dev);\n\n\t \n\tdev->card_unstable = 0;\n\treturn 0;\n}\n\nstatic int r852_resume(struct device *device)\n{\n\tstruct r852_device *dev = dev_get_drvdata(device);\n\n\tr852_disable_irqs(dev);\n\tr852_card_update_present(dev);\n\tr852_engine_disable(dev);\n\n\n\t \n\tif (dev->card_detected != dev->card_registered) {\n\t\tdbg(\"card was %s during low power state\",\n\t\t\tdev->card_detected ? \"added\" : \"removed\");\n\n\t\tqueue_delayed_work(dev->card_workqueue,\n\t\t&dev->card_detect_work, msecs_to_jiffies(1000));\n\t\treturn 0;\n\t}\n\n\t \n\tif (dev->card_registered) {\n\t\tr852_engine_enable(dev);\n\t\tnand_select_target(dev->chip, 0);\n\t\tnand_reset_op(dev->chip);\n\t\tnand_deselect_target(dev->chip);\n\t}\n\n\t \n\tr852_update_card_detect(dev);\n\treturn 0;\n}\n#endif\n\nstatic const struct pci_device_id r852_pci_id_tbl[] = {\n\n\t{ PCI_VDEVICE(RICOH, 0x0852), },\n\t{ },\n};\n\nMODULE_DEVICE_TABLE(pci, r852_pci_id_tbl);\n\nstatic SIMPLE_DEV_PM_OPS(r852_pm_ops, r852_suspend, r852_resume);\n\nstatic struct pci_driver r852_pci_driver = {\n\t.name\t\t= DRV_NAME,\n\t.id_table\t= r852_pci_id_tbl,\n\t.probe\t\t= r852_probe,\n\t.remove\t\t= r852_remove,\n\t.shutdown\t= r852_shutdown,\n\t.driver.pm\t= &r852_pm_ops,\n};\n\nmodule_pci_driver(r852_pci_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Maxim Levitsky <maximlevitsky@gmail.com>\");\nMODULE_DESCRIPTION(\"Ricoh 85xx xD/smartmedia card reader driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}