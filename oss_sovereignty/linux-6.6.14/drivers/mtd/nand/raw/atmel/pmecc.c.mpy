{
  "module_name": "pmecc.c",
  "hash_id": "45a17f66d3db218254081a8edd9e48629513235010eba9a4666670ee026b8c14",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/nand/raw/atmel/pmecc.c",
  "human_readable_source": "\n \n\n#include <linux/genalloc.h>\n#include <linux/iopoll.h>\n#include <linux/module.h>\n#include <linux/mtd/rawnand.h>\n#include <linux/of_irq.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n\n#include \"pmecc.h\"\n\n \n#define PMECC_GF_DIMENSION_13\t\t\t13\n#define PMECC_GF_DIMENSION_14\t\t\t14\n\n \n#define PMECC_GF_13_PRIMITIVE_POLY\t\t0x201b\n#define PMECC_GF_14_PRIMITIVE_POLY\t\t0x4443\n\n#define PMECC_LOOKUP_TABLE_SIZE_512\t\t0x2000\n#define PMECC_LOOKUP_TABLE_SIZE_1024\t\t0x4000\n\n \n#define PMECC_MAX_TIMEOUT_MS\t\t\t100\n\n \n#define ATMEL_PMECC_CFG\t\t\t\t0x0\n#define PMECC_CFG_BCH_STRENGTH(x)\t\t(x)\n#define PMECC_CFG_BCH_STRENGTH_MASK\t\tGENMASK(2, 0)\n#define PMECC_CFG_SECTOR512\t\t\t(0 << 4)\n#define PMECC_CFG_SECTOR1024\t\t\t(1 << 4)\n#define PMECC_CFG_NSECTORS(x)\t\t\t((fls(x) - 1) << 8)\n#define PMECC_CFG_READ_OP\t\t\t(0 << 12)\n#define PMECC_CFG_WRITE_OP\t\t\t(1 << 12)\n#define PMECC_CFG_SPARE_ENABLE\t\t\tBIT(16)\n#define PMECC_CFG_AUTO_ENABLE\t\t\tBIT(20)\n\n#define ATMEL_PMECC_SAREA\t\t\t0x4\n#define ATMEL_PMECC_SADDR\t\t\t0x8\n#define ATMEL_PMECC_EADDR\t\t\t0xc\n\n#define ATMEL_PMECC_CLK\t\t\t\t0x10\n#define PMECC_CLK_133MHZ\t\t\t(2 << 0)\n\n#define ATMEL_PMECC_CTRL\t\t\t0x14\n#define PMECC_CTRL_RST\t\t\t\tBIT(0)\n#define PMECC_CTRL_DATA\t\t\t\tBIT(1)\n#define PMECC_CTRL_USER\t\t\t\tBIT(2)\n#define PMECC_CTRL_ENABLE\t\t\tBIT(4)\n#define PMECC_CTRL_DISABLE\t\t\tBIT(5)\n\n#define ATMEL_PMECC_SR\t\t\t\t0x18\n#define PMECC_SR_BUSY\t\t\t\tBIT(0)\n#define PMECC_SR_ENABLE\t\t\t\tBIT(4)\n\n#define ATMEL_PMECC_IER\t\t\t\t0x1c\n#define ATMEL_PMECC_IDR\t\t\t\t0x20\n#define ATMEL_PMECC_IMR\t\t\t\t0x24\n#define ATMEL_PMECC_ISR\t\t\t\t0x28\n#define PMECC_ERROR_INT\t\t\t\tBIT(0)\n\n#define ATMEL_PMECC_ECC(sector, n)\t\t\\\n\t((((sector) + 1) * 0x40) + (n))\n\n#define ATMEL_PMECC_REM(sector, n)\t\t\\\n\t((((sector) + 1) * 0x40) + ((n) * 4) + 0x200)\n\n \n#define ATMEL_PMERRLOC_ELCFG\t\t\t0x0\n#define PMERRLOC_ELCFG_SECTOR_512\t\t(0 << 0)\n#define PMERRLOC_ELCFG_SECTOR_1024\t\t(1 << 0)\n#define PMERRLOC_ELCFG_NUM_ERRORS(n)\t\t((n) << 16)\n\n#define ATMEL_PMERRLOC_ELPRIM\t\t\t0x4\n#define ATMEL_PMERRLOC_ELEN\t\t\t0x8\n#define ATMEL_PMERRLOC_ELDIS\t\t\t0xc\n#define PMERRLOC_DISABLE\t\t\tBIT(0)\n\n#define ATMEL_PMERRLOC_ELSR\t\t\t0x10\n#define PMERRLOC_ELSR_BUSY\t\t\tBIT(0)\n\n#define ATMEL_PMERRLOC_ELIER\t\t\t0x14\n#define ATMEL_PMERRLOC_ELIDR\t\t\t0x18\n#define ATMEL_PMERRLOC_ELIMR\t\t\t0x1c\n#define ATMEL_PMERRLOC_ELISR\t\t\t0x20\n#define PMERRLOC_ERR_NUM_MASK\t\t\tGENMASK(12, 8)\n#define PMERRLOC_CALC_DONE\t\t\tBIT(0)\n\n#define ATMEL_PMERRLOC_SIGMA(x)\t\t\t(((x) * 0x4) + 0x28)\n\n#define ATMEL_PMERRLOC_EL(offs, x)\t\t(((x) * 0x4) + (offs))\n\nstruct atmel_pmecc_gf_tables {\n\tu16 *alpha_to;\n\tu16 *index_of;\n};\n\nstruct atmel_pmecc_caps {\n\tconst int *strengths;\n\tint nstrengths;\n\tint el_offset;\n\tbool correct_erased_chunks;\n};\n\nstruct atmel_pmecc {\n\tstruct device *dev;\n\tconst struct atmel_pmecc_caps *caps;\n\n\tstruct {\n\t\tvoid __iomem *base;\n\t\tvoid __iomem *errloc;\n\t} regs;\n\n\tstruct mutex lock;\n};\n\nstruct atmel_pmecc_user_conf_cache {\n\tu32 cfg;\n\tu32 sarea;\n\tu32 saddr;\n\tu32 eaddr;\n};\n\nstruct atmel_pmecc_user {\n\tstruct atmel_pmecc_user_conf_cache cache;\n\tstruct atmel_pmecc *pmecc;\n\tconst struct atmel_pmecc_gf_tables *gf_tables;\n\tint eccbytes;\n\ts16 *partial_syn;\n\ts16 *si;\n\ts16 *lmu;\n\ts16 *smu;\n\ts32 *mu;\n\ts32 *dmu;\n\ts32 *delta;\n\tu32 isr;\n};\n\nstatic DEFINE_MUTEX(pmecc_gf_tables_lock);\nstatic const struct atmel_pmecc_gf_tables *pmecc_gf_tables_512;\nstatic const struct atmel_pmecc_gf_tables *pmecc_gf_tables_1024;\n\nstatic inline int deg(unsigned int poly)\n{\n\t \n\treturn fls(poly) - 1;\n}\n\nstatic int atmel_pmecc_build_gf_tables(int mm, unsigned int poly,\n\t\t\t\t       struct atmel_pmecc_gf_tables *gf_tables)\n{\n\tunsigned int i, x = 1;\n\tconst unsigned int k = BIT(deg(poly));\n\tunsigned int nn = BIT(mm) - 1;\n\n\t \n\tif (k != (1u << mm))\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < nn; i++) {\n\t\tgf_tables->alpha_to[i] = x;\n\t\tgf_tables->index_of[x] = i;\n\t\tif (i && (x == 1))\n\t\t\t \n\t\t\treturn -EINVAL;\n\t\tx <<= 1;\n\t\tif (x & k)\n\t\t\tx ^= poly;\n\t}\n\tgf_tables->alpha_to[nn] = 1;\n\tgf_tables->index_of[0] = 0;\n\n\treturn 0;\n}\n\nstatic const struct atmel_pmecc_gf_tables *\natmel_pmecc_create_gf_tables(const struct atmel_pmecc_user_req *req)\n{\n\tstruct atmel_pmecc_gf_tables *gf_tables;\n\tunsigned int poly, degree, table_size;\n\tint ret;\n\n\tif (req->ecc.sectorsize == 512) {\n\t\tdegree = PMECC_GF_DIMENSION_13;\n\t\tpoly = PMECC_GF_13_PRIMITIVE_POLY;\n\t\ttable_size = PMECC_LOOKUP_TABLE_SIZE_512;\n\t} else {\n\t\tdegree = PMECC_GF_DIMENSION_14;\n\t\tpoly = PMECC_GF_14_PRIMITIVE_POLY;\n\t\ttable_size = PMECC_LOOKUP_TABLE_SIZE_1024;\n\t}\n\n\tgf_tables = kzalloc(sizeof(*gf_tables) +\n\t\t\t    (2 * table_size * sizeof(u16)),\n\t\t\t    GFP_KERNEL);\n\tif (!gf_tables)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tgf_tables->alpha_to = (void *)(gf_tables + 1);\n\tgf_tables->index_of = gf_tables->alpha_to + table_size;\n\n\tret = atmel_pmecc_build_gf_tables(degree, poly, gf_tables);\n\tif (ret) {\n\t\tkfree(gf_tables);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\treturn gf_tables;\n}\n\nstatic const struct atmel_pmecc_gf_tables *\natmel_pmecc_get_gf_tables(const struct atmel_pmecc_user_req *req)\n{\n\tconst struct atmel_pmecc_gf_tables **gf_tables, *ret;\n\n\tmutex_lock(&pmecc_gf_tables_lock);\n\tif (req->ecc.sectorsize == 512)\n\t\tgf_tables = &pmecc_gf_tables_512;\n\telse\n\t\tgf_tables = &pmecc_gf_tables_1024;\n\n\tret = *gf_tables;\n\n\tif (!ret) {\n\t\tret = atmel_pmecc_create_gf_tables(req);\n\t\tif (!IS_ERR(ret))\n\t\t\t*gf_tables = ret;\n\t}\n\tmutex_unlock(&pmecc_gf_tables_lock);\n\n\treturn ret;\n}\n\nstatic int atmel_pmecc_prepare_user_req(struct atmel_pmecc *pmecc,\n\t\t\t\t\tstruct atmel_pmecc_user_req *req)\n{\n\tint i, max_eccbytes, eccbytes = 0, eccstrength = 0;\n\n\tif (req->pagesize <= 0 || req->oobsize <= 0 || req->ecc.bytes <= 0)\n\t\treturn -EINVAL;\n\n\tif (req->ecc.ooboffset >= 0 &&\n\t    req->ecc.ooboffset + req->ecc.bytes > req->oobsize)\n\t\treturn -EINVAL;\n\n\tif (req->ecc.sectorsize == ATMEL_PMECC_SECTOR_SIZE_AUTO) {\n\t\tif (req->ecc.strength != ATMEL_PMECC_MAXIMIZE_ECC_STRENGTH)\n\t\t\treturn -EINVAL;\n\n\t\tif (req->pagesize > 512)\n\t\t\treq->ecc.sectorsize = 1024;\n\t\telse\n\t\t\treq->ecc.sectorsize = 512;\n\t}\n\n\tif (req->ecc.sectorsize != 512 && req->ecc.sectorsize != 1024)\n\t\treturn -EINVAL;\n\n\tif (req->pagesize % req->ecc.sectorsize)\n\t\treturn -EINVAL;\n\n\treq->ecc.nsectors = req->pagesize / req->ecc.sectorsize;\n\n\tmax_eccbytes = req->ecc.bytes;\n\n\tfor (i = 0; i < pmecc->caps->nstrengths; i++) {\n\t\tint nbytes, strength = pmecc->caps->strengths[i];\n\n\t\tif (req->ecc.strength != ATMEL_PMECC_MAXIMIZE_ECC_STRENGTH &&\n\t\t    strength < req->ecc.strength)\n\t\t\tcontinue;\n\n\t\tnbytes = DIV_ROUND_UP(strength * fls(8 * req->ecc.sectorsize),\n\t\t\t\t      8);\n\t\tnbytes *= req->ecc.nsectors;\n\n\t\tif (nbytes > max_eccbytes)\n\t\t\tbreak;\n\n\t\teccstrength = strength;\n\t\teccbytes = nbytes;\n\n\t\tif (req->ecc.strength != ATMEL_PMECC_MAXIMIZE_ECC_STRENGTH)\n\t\t\tbreak;\n\t}\n\n\tif (!eccstrength)\n\t\treturn -EINVAL;\n\n\treq->ecc.bytes = eccbytes;\n\treq->ecc.strength = eccstrength;\n\n\tif (req->ecc.ooboffset < 0)\n\t\treq->ecc.ooboffset = req->oobsize - eccbytes;\n\n\treturn 0;\n}\n\nstruct atmel_pmecc_user *\natmel_pmecc_create_user(struct atmel_pmecc *pmecc,\n\t\t\tstruct atmel_pmecc_user_req *req)\n{\n\tstruct atmel_pmecc_user *user;\n\tconst struct atmel_pmecc_gf_tables *gf_tables;\n\tint strength, size, ret;\n\n\tret = atmel_pmecc_prepare_user_req(pmecc, req);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tsize = sizeof(*user);\n\tsize = ALIGN(size, sizeof(u16));\n\t \n\tsize += ((2 * req->ecc.strength) + 1) * sizeof(u16) *\n\t\t(2 + req->ecc.strength + 2);\n\t \n\tsize += (req->ecc.strength + 1) * sizeof(u16);\n\t \n\tsize = ALIGN(size, sizeof(s32));\n\tsize += (req->ecc.strength + 1) * sizeof(s32) * 3;\n\n\tuser = kzalloc(size, GFP_KERNEL);\n\tif (!user)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tuser->pmecc = pmecc;\n\n\tuser->partial_syn = (s16 *)PTR_ALIGN(user + 1, sizeof(u16));\n\tuser->si = user->partial_syn + ((2 * req->ecc.strength) + 1);\n\tuser->lmu = user->si + ((2 * req->ecc.strength) + 1);\n\tuser->smu = user->lmu + (req->ecc.strength + 1);\n\tuser->mu = (s32 *)PTR_ALIGN(user->smu +\n\t\t\t\t    (((2 * req->ecc.strength) + 1) *\n\t\t\t\t     (req->ecc.strength + 2)),\n\t\t\t\t    sizeof(s32));\n\tuser->dmu = user->mu + req->ecc.strength + 1;\n\tuser->delta = user->dmu + req->ecc.strength + 1;\n\n\tgf_tables = atmel_pmecc_get_gf_tables(req);\n\tif (IS_ERR(gf_tables)) {\n\t\tkfree(user);\n\t\treturn ERR_CAST(gf_tables);\n\t}\n\n\tuser->gf_tables = gf_tables;\n\n\tuser->eccbytes = req->ecc.bytes / req->ecc.nsectors;\n\n\tfor (strength = 0; strength < pmecc->caps->nstrengths; strength++) {\n\t\tif (pmecc->caps->strengths[strength] == req->ecc.strength)\n\t\t\tbreak;\n\t}\n\n\tuser->cache.cfg = PMECC_CFG_BCH_STRENGTH(strength) |\n\t\t\t  PMECC_CFG_NSECTORS(req->ecc.nsectors);\n\n\tif (req->ecc.sectorsize == 1024)\n\t\tuser->cache.cfg |= PMECC_CFG_SECTOR1024;\n\n\tuser->cache.sarea = req->oobsize - 1;\n\tuser->cache.saddr = req->ecc.ooboffset;\n\tuser->cache.eaddr = req->ecc.ooboffset + req->ecc.bytes - 1;\n\n\treturn user;\n}\nEXPORT_SYMBOL_GPL(atmel_pmecc_create_user);\n\nvoid atmel_pmecc_destroy_user(struct atmel_pmecc_user *user)\n{\n\tkfree(user);\n}\nEXPORT_SYMBOL_GPL(atmel_pmecc_destroy_user);\n\nstatic int get_strength(struct atmel_pmecc_user *user)\n{\n\tconst int *strengths = user->pmecc->caps->strengths;\n\n\treturn strengths[user->cache.cfg & PMECC_CFG_BCH_STRENGTH_MASK];\n}\n\nstatic int get_sectorsize(struct atmel_pmecc_user *user)\n{\n\treturn user->cache.cfg & PMECC_CFG_SECTOR1024 ? 1024 : 512;\n}\n\nstatic void atmel_pmecc_gen_syndrome(struct atmel_pmecc_user *user, int sector)\n{\n\tint strength = get_strength(user);\n\tu32 value;\n\tint i;\n\n\t \n\tfor (i = 0; i < strength; i++) {\n\t\tvalue = readl_relaxed(user->pmecc->regs.base +\n\t\t\t\t      ATMEL_PMECC_REM(sector, i / 2));\n\t\tif (i & 1)\n\t\t\tvalue >>= 16;\n\n\t\tuser->partial_syn[(2 * i) + 1] = value;\n\t}\n}\n\nstatic void atmel_pmecc_substitute(struct atmel_pmecc_user *user)\n{\n\tint degree = get_sectorsize(user) == 512 ? 13 : 14;\n\tint cw_len = BIT(degree) - 1;\n\tint strength = get_strength(user);\n\ts16 *alpha_to = user->gf_tables->alpha_to;\n\ts16 *index_of = user->gf_tables->index_of;\n\ts16 *partial_syn = user->partial_syn;\n\ts16 *si;\n\tint i, j;\n\n\t \n\tsi = user->si;\n\n\tmemset(&si[1], 0, sizeof(s16) * ((2 * strength) - 1));\n\n\t \n\t \n\tfor (i = 1; i < 2 * strength; i += 2) {\n\t\tfor (j = 0; j < degree; j++) {\n\t\t\tif (partial_syn[i] & BIT(j))\n\t\t\t\tsi[i] = alpha_to[i * j] ^ si[i];\n\t\t}\n\t}\n\t \n\tfor (i = 2, j = 1; j <= strength; i = ++j << 1) {\n\t\tif (si[j] == 0) {\n\t\t\tsi[i] = 0;\n\t\t} else {\n\t\t\ts16 tmp;\n\n\t\t\ttmp = index_of[si[j]];\n\t\t\ttmp = (tmp * 2) % cw_len;\n\t\t\tsi[i] = alpha_to[tmp];\n\t\t}\n\t}\n}\n\nstatic void atmel_pmecc_get_sigma(struct atmel_pmecc_user *user)\n{\n\ts16 *lmu = user->lmu;\n\ts16 *si = user->si;\n\ts32 *mu = user->mu;\n\ts32 *dmu = user->dmu;\n\ts32 *delta = user->delta;\n\tint degree = get_sectorsize(user) == 512 ? 13 : 14;\n\tint cw_len = BIT(degree) - 1;\n\tint strength = get_strength(user);\n\tint num = 2 * strength + 1;\n\ts16 *index_of = user->gf_tables->index_of;\n\ts16 *alpha_to = user->gf_tables->alpha_to;\n\tint i, j, k;\n\tu32 dmu_0_count, tmp;\n\ts16 *smu = user->smu;\n\n\t \n\tint ro;\n\tint largest;\n\tint diff;\n\n\tdmu_0_count = 0;\n\n\t \n\n\t \n\tmu[0] = -1;\n\n\tmemset(smu, 0, sizeof(s16) * num);\n\tsmu[0] = 1;\n\n\t \n\tdmu[0] = 1;\n\t \n\tlmu[0] = 0;\n\tdelta[0] = (mu[0] * 2 - lmu[0]) >> 1;\n\n\t \n\n\t \n\tmu[1] = 0;\n\t \n\tmemset(&smu[num], 0, sizeof(s16) * num);\n\tsmu[num] = 1;\n\n\t \n\tdmu[1] = si[1];\n\n\t \n\tlmu[1] = 0;\n\n\tdelta[1] = (mu[1] * 2 - lmu[1]) >> 1;\n\n\t \n\tmemset(&smu[(strength + 1) * num], 0, sizeof(s16) * num);\n\n\tfor (i = 1; i <= strength; i++) {\n\t\tmu[i + 1] = i << 1;\n\t\t \n\t\t \n\t\tif (dmu[i] == 0) {\n\t\t\tdmu_0_count++;\n\n\t\t\ttmp = ((strength - (lmu[i] >> 1) - 1) / 2);\n\t\t\tif ((strength - (lmu[i] >> 1) - 1) & 0x1)\n\t\t\t\ttmp += 2;\n\t\t\telse\n\t\t\t\ttmp += 1;\n\n\t\t\tif (dmu_0_count == tmp) {\n\t\t\t\tfor (j = 0; j <= (lmu[i] >> 1) + 1; j++)\n\t\t\t\t\tsmu[(strength + 1) * num + j] =\n\t\t\t\t\t\t\tsmu[i * num + j];\n\n\t\t\t\tlmu[strength + 1] = lmu[i];\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t \n\t\t\tfor (j = 0; j <= lmu[i] >> 1; j++)\n\t\t\t\tsmu[(i + 1) * num + j] = smu[i * num + j];\n\n\t\t\t \n\t\t\tlmu[i + 1] = lmu[i];\n\t\t} else {\n\t\t\tro = 0;\n\t\t\tlargest = -1;\n\t\t\t \n\t\t\tfor (j = 0; j < i; j++) {\n\t\t\t\tif ((dmu[j]) && (delta[j] > largest)) {\n\t\t\t\t\tlargest = delta[j];\n\t\t\t\t\tro = j;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t \n\t\t\tdiff = (mu[i] - mu[ro]);\n\n\t\t\t \n\t\t\tif ((lmu[i] >> 1) > ((lmu[ro] >> 1) + diff))\n\t\t\t\tlmu[i + 1] = lmu[i];\n\t\t\telse\n\t\t\t\tlmu[i + 1] = ((lmu[ro] >> 1) + diff) * 2;\n\n\t\t\t \n\t\t\tfor (k = 0; k < num; k++)\n\t\t\t\tsmu[(i + 1) * num + k] = 0;\n\n\t\t\t \n\t\t\tfor (k = 0; k <= lmu[ro] >> 1; k++) {\n\t\t\t\ts16 a, b, c;\n\n\t\t\t\tif (!(smu[ro * num + k] && dmu[i]))\n\t\t\t\t\tcontinue;\n\n\t\t\t\ta = index_of[dmu[i]];\n\t\t\t\tb = index_of[dmu[ro]];\n\t\t\t\tc = index_of[smu[ro * num + k]];\n\t\t\t\ttmp = a + (cw_len - b) + c;\n\t\t\t\ta = alpha_to[tmp % cw_len];\n\t\t\t\tsmu[(i + 1) * num + (k + diff)] = a;\n\t\t\t}\n\n\t\t\tfor (k = 0; k <= lmu[i] >> 1; k++)\n\t\t\t\tsmu[(i + 1) * num + k] ^= smu[i * num + k];\n\t\t}\n\n\t\t \n\t\t \n\t\tdelta[i + 1] = (mu[i + 1] * 2 - lmu[i + 1]) >> 1;\n\n\t\t \n\t\tif (i >= strength)\n\t\t\tcontinue;\n\n\t\tfor (k = 0; k <= (lmu[i + 1] >> 1); k++) {\n\t\t\ttmp = 2 * (i - 1);\n\t\t\tif (k == 0) {\n\t\t\t\tdmu[i + 1] = si[tmp + 3];\n\t\t\t} else if (smu[(i + 1) * num + k] && si[tmp + 3 - k]) {\n\t\t\t\ts16 a, b, c;\n\n\t\t\t\ta = index_of[smu[(i + 1) * num + k]];\n\t\t\t\tb = si[2 * (i - 1) + 3 - k];\n\t\t\t\tc = index_of[b];\n\t\t\t\ttmp = a + c;\n\t\t\t\ttmp %= cw_len;\n\t\t\t\tdmu[i + 1] = alpha_to[tmp] ^ dmu[i + 1];\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic int atmel_pmecc_err_location(struct atmel_pmecc_user *user)\n{\n\tint sector_size = get_sectorsize(user);\n\tint degree = sector_size == 512 ? 13 : 14;\n\tstruct atmel_pmecc *pmecc = user->pmecc;\n\tint strength = get_strength(user);\n\tint ret, roots_nbr, i, err_nbr = 0;\n\tint num = (2 * strength) + 1;\n\ts16 *smu = user->smu;\n\tu32 val;\n\n\twritel(PMERRLOC_DISABLE, pmecc->regs.errloc + ATMEL_PMERRLOC_ELDIS);\n\n\tfor (i = 0; i <= user->lmu[strength + 1] >> 1; i++) {\n\t\twritel_relaxed(smu[(strength + 1) * num + i],\n\t\t\t       pmecc->regs.errloc + ATMEL_PMERRLOC_SIGMA(i));\n\t\terr_nbr++;\n\t}\n\n\tval = (err_nbr - 1) << 16;\n\tif (sector_size == 1024)\n\t\tval |= 1;\n\n\twritel(val, pmecc->regs.errloc + ATMEL_PMERRLOC_ELCFG);\n\twritel((sector_size * 8) + (degree * strength),\n\t       pmecc->regs.errloc + ATMEL_PMERRLOC_ELEN);\n\n\tret = readl_relaxed_poll_timeout(pmecc->regs.errloc +\n\t\t\t\t\t ATMEL_PMERRLOC_ELISR,\n\t\t\t\t\t val, val & PMERRLOC_CALC_DONE, 0,\n\t\t\t\t\t PMECC_MAX_TIMEOUT_MS * 1000);\n\tif (ret) {\n\t\tdev_err(pmecc->dev,\n\t\t\t\"PMECC: Timeout to calculate error location.\\n\");\n\t\treturn ret;\n\t}\n\n\troots_nbr = (val & PMERRLOC_ERR_NUM_MASK) >> 8;\n\t \n\tif (roots_nbr == user->lmu[strength + 1] >> 1)\n\t\treturn err_nbr - 1;\n\n\t \n\treturn -EBADMSG;\n}\n\nint atmel_pmecc_correct_sector(struct atmel_pmecc_user *user, int sector,\n\t\t\t       void *data, void *ecc)\n{\n\tstruct atmel_pmecc *pmecc = user->pmecc;\n\tint sectorsize = get_sectorsize(user);\n\tint eccbytes = user->eccbytes;\n\tint i, nerrors;\n\n\tif (!(user->isr & BIT(sector)))\n\t\treturn 0;\n\n\tatmel_pmecc_gen_syndrome(user, sector);\n\tatmel_pmecc_substitute(user);\n\tatmel_pmecc_get_sigma(user);\n\n\tnerrors = atmel_pmecc_err_location(user);\n\tif (nerrors < 0)\n\t\treturn nerrors;\n\n\tfor (i = 0; i < nerrors; i++) {\n\t\tconst char *area;\n\t\tint byte, bit;\n\t\tu32 errpos;\n\t\tu8 *ptr;\n\n\t\terrpos = readl_relaxed(pmecc->regs.errloc +\n\t\t\t\tATMEL_PMERRLOC_EL(pmecc->caps->el_offset, i));\n\t\terrpos--;\n\n\t\tbyte = errpos / 8;\n\t\tbit = errpos % 8;\n\n\t\tif (byte < sectorsize) {\n\t\t\tptr = data + byte;\n\t\t\tarea = \"data\";\n\t\t} else if (byte < sectorsize + eccbytes) {\n\t\t\tptr = ecc + byte - sectorsize;\n\t\t\tarea = \"ECC\";\n\t\t} else {\n\t\t\tdev_dbg(pmecc->dev,\n\t\t\t\t\"Invalid errpos value (%d, max is %d)\\n\",\n\t\t\t\terrpos, (sectorsize + eccbytes) * 8);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tdev_dbg(pmecc->dev,\n\t\t\t\"Bit flip in %s area, byte %d: 0x%02x -> 0x%02x\\n\",\n\t\t\tarea, byte, *ptr, (unsigned int)(*ptr ^ BIT(bit)));\n\n\t\t*ptr ^= BIT(bit);\n\t}\n\n\treturn nerrors;\n}\nEXPORT_SYMBOL_GPL(atmel_pmecc_correct_sector);\n\nbool atmel_pmecc_correct_erased_chunks(struct atmel_pmecc_user *user)\n{\n\treturn user->pmecc->caps->correct_erased_chunks;\n}\nEXPORT_SYMBOL_GPL(atmel_pmecc_correct_erased_chunks);\n\nvoid atmel_pmecc_get_generated_eccbytes(struct atmel_pmecc_user *user,\n\t\t\t\t\tint sector, void *ecc)\n{\n\tstruct atmel_pmecc *pmecc = user->pmecc;\n\tu8 *ptr = ecc;\n\tint i;\n\n\tfor (i = 0; i < user->eccbytes; i++)\n\t\tptr[i] = readb_relaxed(pmecc->regs.base +\n\t\t\t\t       ATMEL_PMECC_ECC(sector, i));\n}\nEXPORT_SYMBOL_GPL(atmel_pmecc_get_generated_eccbytes);\n\nvoid atmel_pmecc_reset(struct atmel_pmecc *pmecc)\n{\n\twritel(PMECC_CTRL_RST, pmecc->regs.base + ATMEL_PMECC_CTRL);\n\twritel(PMECC_CTRL_DISABLE, pmecc->regs.base + ATMEL_PMECC_CTRL);\n}\nEXPORT_SYMBOL_GPL(atmel_pmecc_reset);\n\nint atmel_pmecc_enable(struct atmel_pmecc_user *user, int op)\n{\n\tstruct atmel_pmecc *pmecc = user->pmecc;\n\tu32 cfg;\n\n\tif (op != NAND_ECC_READ && op != NAND_ECC_WRITE) {\n\t\tdev_err(pmecc->dev, \"Bad ECC operation!\");\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&user->pmecc->lock);\n\n\tcfg = user->cache.cfg;\n\tif (op == NAND_ECC_WRITE)\n\t\tcfg |= PMECC_CFG_WRITE_OP;\n\telse\n\t\tcfg |= PMECC_CFG_AUTO_ENABLE;\n\n\twritel(cfg, pmecc->regs.base + ATMEL_PMECC_CFG);\n\twritel(user->cache.sarea, pmecc->regs.base + ATMEL_PMECC_SAREA);\n\twritel(user->cache.saddr, pmecc->regs.base + ATMEL_PMECC_SADDR);\n\twritel(user->cache.eaddr, pmecc->regs.base + ATMEL_PMECC_EADDR);\n\n\twritel(PMECC_CTRL_ENABLE, pmecc->regs.base + ATMEL_PMECC_CTRL);\n\twritel(PMECC_CTRL_DATA, pmecc->regs.base + ATMEL_PMECC_CTRL);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(atmel_pmecc_enable);\n\nvoid atmel_pmecc_disable(struct atmel_pmecc_user *user)\n{\n\tatmel_pmecc_reset(user->pmecc);\n\tmutex_unlock(&user->pmecc->lock);\n}\nEXPORT_SYMBOL_GPL(atmel_pmecc_disable);\n\nint atmel_pmecc_wait_rdy(struct atmel_pmecc_user *user)\n{\n\tstruct atmel_pmecc *pmecc = user->pmecc;\n\tu32 status;\n\tint ret;\n\n\tret = readl_relaxed_poll_timeout(pmecc->regs.base +\n\t\t\t\t\t ATMEL_PMECC_SR,\n\t\t\t\t\t status, !(status & PMECC_SR_BUSY), 0,\n\t\t\t\t\t PMECC_MAX_TIMEOUT_MS * 1000);\n\tif (ret) {\n\t\tdev_err(pmecc->dev,\n\t\t\t\"Timeout while waiting for PMECC ready.\\n\");\n\t\treturn ret;\n\t}\n\n\tuser->isr = readl_relaxed(pmecc->regs.base + ATMEL_PMECC_ISR);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(atmel_pmecc_wait_rdy);\n\nstatic struct atmel_pmecc *atmel_pmecc_create(struct platform_device *pdev,\n\t\t\t\t\tconst struct atmel_pmecc_caps *caps,\n\t\t\t\t\tint pmecc_res_idx, int errloc_res_idx)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct atmel_pmecc *pmecc;\n\n\tpmecc = devm_kzalloc(dev, sizeof(*pmecc), GFP_KERNEL);\n\tif (!pmecc)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tpmecc->caps = caps;\n\tpmecc->dev = dev;\n\tmutex_init(&pmecc->lock);\n\n\tpmecc->regs.base = devm_platform_ioremap_resource(pdev, pmecc_res_idx);\n\tif (IS_ERR(pmecc->regs.base))\n\t\treturn ERR_CAST(pmecc->regs.base);\n\n\tpmecc->regs.errloc = devm_platform_ioremap_resource(pdev, errloc_res_idx);\n\tif (IS_ERR(pmecc->regs.errloc))\n\t\treturn ERR_CAST(pmecc->regs.errloc);\n\n\t \n\twritel(0xffffffff, pmecc->regs.base + ATMEL_PMECC_IDR);\n\tatmel_pmecc_reset(pmecc);\n\n\treturn pmecc;\n}\n\nstatic void devm_atmel_pmecc_put(struct device *dev, void *res)\n{\n\tstruct atmel_pmecc **pmecc = res;\n\n\tput_device((*pmecc)->dev);\n}\n\nstatic struct atmel_pmecc *atmel_pmecc_get_by_node(struct device *userdev,\n\t\t\t\t\t\t   struct device_node *np)\n{\n\tstruct platform_device *pdev;\n\tstruct atmel_pmecc *pmecc, **ptr;\n\tint ret;\n\n\tpdev = of_find_device_by_node(np);\n\tif (!pdev)\n\t\treturn ERR_PTR(-EPROBE_DEFER);\n\tpmecc = platform_get_drvdata(pdev);\n\tif (!pmecc) {\n\t\tret = -EPROBE_DEFER;\n\t\tgoto err_put_device;\n\t}\n\n\tptr = devres_alloc(devm_atmel_pmecc_put, sizeof(*ptr), GFP_KERNEL);\n\tif (!ptr) {\n\t\tret = -ENOMEM;\n\t\tgoto err_put_device;\n\t}\n\n\t*ptr = pmecc;\n\n\tdevres_add(userdev, ptr);\n\n\treturn pmecc;\n\nerr_put_device:\n\tput_device(&pdev->dev);\n\treturn ERR_PTR(ret);\n}\n\nstatic const int atmel_pmecc_strengths[] = { 2, 4, 8, 12, 24, 32 };\n\nstatic struct atmel_pmecc_caps at91sam9g45_caps = {\n\t.strengths = atmel_pmecc_strengths,\n\t.nstrengths = 5,\n\t.el_offset = 0x8c,\n};\n\nstatic struct atmel_pmecc_caps sama5d4_caps = {\n\t.strengths = atmel_pmecc_strengths,\n\t.nstrengths = 5,\n\t.el_offset = 0x8c,\n\t.correct_erased_chunks = true,\n};\n\nstatic struct atmel_pmecc_caps sama5d2_caps = {\n\t.strengths = atmel_pmecc_strengths,\n\t.nstrengths = 6,\n\t.el_offset = 0xac,\n\t.correct_erased_chunks = true,\n};\n\nstatic const struct of_device_id __maybe_unused atmel_pmecc_legacy_match[] = {\n\t{ .compatible = \"atmel,sama5d4-nand\", &sama5d4_caps },\n\t{ .compatible = \"atmel,sama5d2-nand\", &sama5d2_caps },\n\t{   }\n};\n\nstruct atmel_pmecc *devm_atmel_pmecc_get(struct device *userdev)\n{\n\tstruct atmel_pmecc *pmecc;\n\tstruct device_node *np;\n\n\tif (!userdev)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (!userdev->of_node)\n\t\treturn NULL;\n\n\tnp = of_parse_phandle(userdev->of_node, \"ecc-engine\", 0);\n\tif (np) {\n\t\tpmecc = atmel_pmecc_get_by_node(userdev, np);\n\t\tof_node_put(np);\n\t} else {\n\t\t \n\t\tstruct platform_device *pdev = to_platform_device(userdev);\n\t\tconst struct atmel_pmecc_caps *caps;\n\t\tconst struct of_device_id *match;\n\n\t\t \n\t\tif (!of_property_read_bool(userdev->of_node,\n\t\t\t\t\t   \"atmel,has-pmecc\"))\n\t\t\treturn NULL;\n\n\t\tcaps = &at91sam9g45_caps;\n\n\t\t \n\t\tmatch = of_match_node(atmel_pmecc_legacy_match,\n\t\t\t\t      userdev->of_node);\n\t\tif (match && match->data)\n\t\t\tcaps = match->data;\n\n\t\tpmecc = atmel_pmecc_create(pdev, caps, 1, 2);\n\t}\n\n\treturn pmecc;\n}\nEXPORT_SYMBOL(devm_atmel_pmecc_get);\n\nstatic const struct of_device_id atmel_pmecc_match[] = {\n\t{ .compatible = \"atmel,at91sam9g45-pmecc\", &at91sam9g45_caps },\n\t{ .compatible = \"atmel,sama5d4-pmecc\", &sama5d4_caps },\n\t{ .compatible = \"atmel,sama5d2-pmecc\", &sama5d2_caps },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, atmel_pmecc_match);\n\nstatic int atmel_pmecc_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tconst struct atmel_pmecc_caps *caps;\n\tstruct atmel_pmecc *pmecc;\n\n\tcaps = of_device_get_match_data(&pdev->dev);\n\tif (!caps) {\n\t\tdev_err(dev, \"Invalid caps\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tpmecc = atmel_pmecc_create(pdev, caps, 0, 1);\n\tif (IS_ERR(pmecc))\n\t\treturn PTR_ERR(pmecc);\n\n\tplatform_set_drvdata(pdev, pmecc);\n\n\treturn 0;\n}\n\nstatic struct platform_driver atmel_pmecc_driver = {\n\t.driver = {\n\t\t.name = \"atmel-pmecc\",\n\t\t.of_match_table = atmel_pmecc_match,\n\t},\n\t.probe = atmel_pmecc_probe,\n};\nmodule_platform_driver(atmel_pmecc_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Boris Brezillon <boris.brezillon@free-electrons.com>\");\nMODULE_DESCRIPTION(\"PMECC engine driver\");\nMODULE_ALIAS(\"platform:atmel_pmecc\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}