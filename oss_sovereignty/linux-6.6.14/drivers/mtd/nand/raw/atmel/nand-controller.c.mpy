{
  "module_name": "nand-controller.c",
  "hash_id": "fa3e519f73cfd516b7ea398b75a6fc43d9b7f10a5e0a9bfd1e8c879a295714ce",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/nand/raw/atmel/nand-controller.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/dma-mapping.h>\n#include <linux/dmaengine.h>\n#include <linux/genalloc.h>\n#include <linux/gpio/consumer.h>\n#include <linux/interrupt.h>\n#include <linux/mfd/syscon.h>\n#include <linux/mfd/syscon/atmel-matrix.h>\n#include <linux/mfd/syscon/atmel-smc.h>\n#include <linux/module.h>\n#include <linux/mtd/rawnand.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n#include <linux/of_platform.h>\n#include <linux/iopoll.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <soc/at91/atmel-sfr.h>\n\n#include \"pmecc.h\"\n\n#define ATMEL_HSMC_NFC_CFG\t\t\t0x0\n#define ATMEL_HSMC_NFC_CFG_SPARESIZE(x)\t\t(((x) / 4) << 24)\n#define ATMEL_HSMC_NFC_CFG_SPARESIZE_MASK\tGENMASK(30, 24)\n#define ATMEL_HSMC_NFC_CFG_DTO(cyc, mul)\t(((cyc) << 16) | ((mul) << 20))\n#define ATMEL_HSMC_NFC_CFG_DTO_MAX\t\tGENMASK(22, 16)\n#define ATMEL_HSMC_NFC_CFG_RBEDGE\t\tBIT(13)\n#define ATMEL_HSMC_NFC_CFG_FALLING_EDGE\t\tBIT(12)\n#define ATMEL_HSMC_NFC_CFG_RSPARE\t\tBIT(9)\n#define ATMEL_HSMC_NFC_CFG_WSPARE\t\tBIT(8)\n#define ATMEL_HSMC_NFC_CFG_PAGESIZE_MASK\tGENMASK(2, 0)\n#define ATMEL_HSMC_NFC_CFG_PAGESIZE(x)\t\t(fls((x) / 512) - 1)\n\n#define ATMEL_HSMC_NFC_CTRL\t\t\t0x4\n#define ATMEL_HSMC_NFC_CTRL_EN\t\t\tBIT(0)\n#define ATMEL_HSMC_NFC_CTRL_DIS\t\t\tBIT(1)\n\n#define ATMEL_HSMC_NFC_SR\t\t\t0x8\n#define ATMEL_HSMC_NFC_IER\t\t\t0xc\n#define ATMEL_HSMC_NFC_IDR\t\t\t0x10\n#define ATMEL_HSMC_NFC_IMR\t\t\t0x14\n#define ATMEL_HSMC_NFC_SR_ENABLED\t\tBIT(1)\n#define ATMEL_HSMC_NFC_SR_RB_RISE\t\tBIT(4)\n#define ATMEL_HSMC_NFC_SR_RB_FALL\t\tBIT(5)\n#define ATMEL_HSMC_NFC_SR_BUSY\t\t\tBIT(8)\n#define ATMEL_HSMC_NFC_SR_WR\t\t\tBIT(11)\n#define ATMEL_HSMC_NFC_SR_CSID\t\t\tGENMASK(14, 12)\n#define ATMEL_HSMC_NFC_SR_XFRDONE\t\tBIT(16)\n#define ATMEL_HSMC_NFC_SR_CMDDONE\t\tBIT(17)\n#define ATMEL_HSMC_NFC_SR_DTOE\t\t\tBIT(20)\n#define ATMEL_HSMC_NFC_SR_UNDEF\t\t\tBIT(21)\n#define ATMEL_HSMC_NFC_SR_AWB\t\t\tBIT(22)\n#define ATMEL_HSMC_NFC_SR_NFCASE\t\tBIT(23)\n#define ATMEL_HSMC_NFC_SR_ERRORS\t\t(ATMEL_HSMC_NFC_SR_DTOE | \\\n\t\t\t\t\t\t ATMEL_HSMC_NFC_SR_UNDEF | \\\n\t\t\t\t\t\t ATMEL_HSMC_NFC_SR_AWB | \\\n\t\t\t\t\t\t ATMEL_HSMC_NFC_SR_NFCASE)\n#define ATMEL_HSMC_NFC_SR_RBEDGE(x)\t\tBIT((x) + 24)\n\n#define ATMEL_HSMC_NFC_ADDR\t\t\t0x18\n#define ATMEL_HSMC_NFC_BANK\t\t\t0x1c\n\n#define ATMEL_NFC_MAX_RB_ID\t\t\t7\n\n#define ATMEL_NFC_SRAM_SIZE\t\t\t0x2400\n\n#define ATMEL_NFC_CMD(pos, cmd)\t\t\t((cmd) << (((pos) * 8) + 2))\n#define ATMEL_NFC_VCMD2\t\t\t\tBIT(18)\n#define ATMEL_NFC_ACYCLE(naddrs)\t\t((naddrs) << 19)\n#define ATMEL_NFC_CSID(cs)\t\t\t((cs) << 22)\n#define ATMEL_NFC_DATAEN\t\t\tBIT(25)\n#define ATMEL_NFC_NFCWR\t\t\t\tBIT(26)\n\n#define ATMEL_NFC_MAX_ADDR_CYCLES\t\t5\n\n#define ATMEL_NAND_ALE_OFFSET\t\t\tBIT(21)\n#define ATMEL_NAND_CLE_OFFSET\t\t\tBIT(22)\n\n#define DEFAULT_TIMEOUT_MS\t\t\t1000\n#define MIN_DMA_LEN\t\t\t\t128\n\nstatic bool atmel_nand_avoid_dma __read_mostly;\n\nMODULE_PARM_DESC(avoiddma, \"Avoid using DMA\");\nmodule_param_named(avoiddma, atmel_nand_avoid_dma, bool, 0400);\n\nenum atmel_nand_rb_type {\n\tATMEL_NAND_NO_RB,\n\tATMEL_NAND_NATIVE_RB,\n\tATMEL_NAND_GPIO_RB,\n};\n\nstruct atmel_nand_rb {\n\tenum atmel_nand_rb_type type;\n\tunion {\n\t\tstruct gpio_desc *gpio;\n\t\tint id;\n\t};\n};\n\nstruct atmel_nand_cs {\n\tint id;\n\tstruct atmel_nand_rb rb;\n\tstruct gpio_desc *csgpio;\n\tstruct {\n\t\tvoid __iomem *virt;\n\t\tdma_addr_t dma;\n\t} io;\n\n\tstruct atmel_smc_cs_conf smcconf;\n};\n\nstruct atmel_nand {\n\tstruct list_head node;\n\tstruct device *dev;\n\tstruct nand_chip base;\n\tstruct atmel_nand_cs *activecs;\n\tstruct atmel_pmecc_user *pmecc;\n\tstruct gpio_desc *cdgpio;\n\tint numcs;\n\tstruct atmel_nand_cs cs[];\n};\n\nstatic inline struct atmel_nand *to_atmel_nand(struct nand_chip *chip)\n{\n\treturn container_of(chip, struct atmel_nand, base);\n}\n\nenum atmel_nfc_data_xfer {\n\tATMEL_NFC_NO_DATA,\n\tATMEL_NFC_READ_DATA,\n\tATMEL_NFC_WRITE_DATA,\n};\n\nstruct atmel_nfc_op {\n\tu8 cs;\n\tu8 ncmds;\n\tu8 cmds[2];\n\tu8 naddrs;\n\tu8 addrs[5];\n\tenum atmel_nfc_data_xfer data;\n\tu32 wait;\n\tu32 errors;\n};\n\nstruct atmel_nand_controller;\nstruct atmel_nand_controller_caps;\n\nstruct atmel_nand_controller_ops {\n\tint (*probe)(struct platform_device *pdev,\n\t\t     const struct atmel_nand_controller_caps *caps);\n\tint (*remove)(struct atmel_nand_controller *nc);\n\tvoid (*nand_init)(struct atmel_nand_controller *nc,\n\t\t\t  struct atmel_nand *nand);\n\tint (*ecc_init)(struct nand_chip *chip);\n\tint (*setup_interface)(struct atmel_nand *nand, int csline,\n\t\t\t       const struct nand_interface_config *conf);\n\tint (*exec_op)(struct atmel_nand *nand,\n\t\t       const struct nand_operation *op, bool check_only);\n};\n\nstruct atmel_nand_controller_caps {\n\tbool has_dma;\n\tbool legacy_of_bindings;\n\tu32 ale_offs;\n\tu32 cle_offs;\n\tconst char *ebi_csa_regmap_name;\n\tconst struct atmel_nand_controller_ops *ops;\n};\n\nstruct atmel_nand_controller {\n\tstruct nand_controller base;\n\tconst struct atmel_nand_controller_caps *caps;\n\tstruct device *dev;\n\tstruct regmap *smc;\n\tstruct dma_chan *dmac;\n\tstruct atmel_pmecc *pmecc;\n\tstruct list_head chips;\n\tstruct clk *mck;\n};\n\nstatic inline struct atmel_nand_controller *\nto_nand_controller(struct nand_controller *ctl)\n{\n\treturn container_of(ctl, struct atmel_nand_controller, base);\n}\n\nstruct atmel_smc_nand_ebi_csa_cfg {\n\tu32 offs;\n\tu32 nfd0_on_d16;\n};\n\nstruct atmel_smc_nand_controller {\n\tstruct atmel_nand_controller base;\n\tstruct regmap *ebi_csa_regmap;\n\tstruct atmel_smc_nand_ebi_csa_cfg *ebi_csa;\n};\n\nstatic inline struct atmel_smc_nand_controller *\nto_smc_nand_controller(struct nand_controller *ctl)\n{\n\treturn container_of(to_nand_controller(ctl),\n\t\t\t    struct atmel_smc_nand_controller, base);\n}\n\nstruct atmel_hsmc_nand_controller {\n\tstruct atmel_nand_controller base;\n\tstruct {\n\t\tstruct gen_pool *pool;\n\t\tvoid __iomem *virt;\n\t\tdma_addr_t dma;\n\t} sram;\n\tconst struct atmel_hsmc_reg_layout *hsmc_layout;\n\tstruct regmap *io;\n\tstruct atmel_nfc_op op;\n\tstruct completion complete;\n\tu32 cfg;\n\tint irq;\n\n\t \n\tstruct clk *clk;\n};\n\nstatic inline struct atmel_hsmc_nand_controller *\nto_hsmc_nand_controller(struct nand_controller *ctl)\n{\n\treturn container_of(to_nand_controller(ctl),\n\t\t\t    struct atmel_hsmc_nand_controller, base);\n}\n\nstatic bool atmel_nfc_op_done(struct atmel_nfc_op *op, u32 status)\n{\n\top->errors |= status & ATMEL_HSMC_NFC_SR_ERRORS;\n\top->wait ^= status & op->wait;\n\n\treturn !op->wait || op->errors;\n}\n\nstatic irqreturn_t atmel_nfc_interrupt(int irq, void *data)\n{\n\tstruct atmel_hsmc_nand_controller *nc = data;\n\tu32 sr, rcvd;\n\tbool done;\n\n\tregmap_read(nc->base.smc, ATMEL_HSMC_NFC_SR, &sr);\n\n\trcvd = sr & (nc->op.wait | ATMEL_HSMC_NFC_SR_ERRORS);\n\tdone = atmel_nfc_op_done(&nc->op, sr);\n\n\tif (rcvd)\n\t\tregmap_write(nc->base.smc, ATMEL_HSMC_NFC_IDR, rcvd);\n\n\tif (done)\n\t\tcomplete(&nc->complete);\n\n\treturn rcvd ? IRQ_HANDLED : IRQ_NONE;\n}\n\nstatic int atmel_nfc_wait(struct atmel_hsmc_nand_controller *nc, bool poll,\n\t\t\t  unsigned int timeout_ms)\n{\n\tint ret;\n\n\tif (!timeout_ms)\n\t\ttimeout_ms = DEFAULT_TIMEOUT_MS;\n\n\tif (poll) {\n\t\tu32 status;\n\n\t\tret = regmap_read_poll_timeout(nc->base.smc,\n\t\t\t\t\t       ATMEL_HSMC_NFC_SR, status,\n\t\t\t\t\t       atmel_nfc_op_done(&nc->op,\n\t\t\t\t\t\t\t\t status),\n\t\t\t\t\t       0, timeout_ms * 1000);\n\t} else {\n\t\tinit_completion(&nc->complete);\n\t\tregmap_write(nc->base.smc, ATMEL_HSMC_NFC_IER,\n\t\t\t     nc->op.wait | ATMEL_HSMC_NFC_SR_ERRORS);\n\t\tret = wait_for_completion_timeout(&nc->complete,\n\t\t\t\t\t\tmsecs_to_jiffies(timeout_ms));\n\t\tif (!ret)\n\t\t\tret = -ETIMEDOUT;\n\t\telse\n\t\t\tret = 0;\n\n\t\tregmap_write(nc->base.smc, ATMEL_HSMC_NFC_IDR, 0xffffffff);\n\t}\n\n\tif (nc->op.errors & ATMEL_HSMC_NFC_SR_DTOE) {\n\t\tdev_err(nc->base.dev, \"Waiting NAND R/B Timeout\\n\");\n\t\tret = -ETIMEDOUT;\n\t}\n\n\tif (nc->op.errors & ATMEL_HSMC_NFC_SR_UNDEF) {\n\t\tdev_err(nc->base.dev, \"Access to an undefined area\\n\");\n\t\tret = -EIO;\n\t}\n\n\tif (nc->op.errors & ATMEL_HSMC_NFC_SR_AWB) {\n\t\tdev_err(nc->base.dev, \"Access while busy\\n\");\n\t\tret = -EIO;\n\t}\n\n\tif (nc->op.errors & ATMEL_HSMC_NFC_SR_NFCASE) {\n\t\tdev_err(nc->base.dev, \"Wrong access size\\n\");\n\t\tret = -EIO;\n\t}\n\n\treturn ret;\n}\n\nstatic void atmel_nand_dma_transfer_finished(void *data)\n{\n\tstruct completion *finished = data;\n\n\tcomplete(finished);\n}\n\nstatic int atmel_nand_dma_transfer(struct atmel_nand_controller *nc,\n\t\t\t\t   void *buf, dma_addr_t dev_dma, size_t len,\n\t\t\t\t   enum dma_data_direction dir)\n{\n\tDECLARE_COMPLETION_ONSTACK(finished);\n\tdma_addr_t src_dma, dst_dma, buf_dma;\n\tstruct dma_async_tx_descriptor *tx;\n\tdma_cookie_t cookie;\n\n\tbuf_dma = dma_map_single(nc->dev, buf, len, dir);\n\tif (dma_mapping_error(nc->dev, dev_dma)) {\n\t\tdev_err(nc->dev,\n\t\t\t\"Failed to prepare a buffer for DMA access\\n\");\n\t\tgoto err;\n\t}\n\n\tif (dir == DMA_FROM_DEVICE) {\n\t\tsrc_dma = dev_dma;\n\t\tdst_dma = buf_dma;\n\t} else {\n\t\tsrc_dma = buf_dma;\n\t\tdst_dma = dev_dma;\n\t}\n\n\ttx = dmaengine_prep_dma_memcpy(nc->dmac, dst_dma, src_dma, len,\n\t\t\t\t       DMA_CTRL_ACK | DMA_PREP_INTERRUPT);\n\tif (!tx) {\n\t\tdev_err(nc->dev, \"Failed to prepare DMA memcpy\\n\");\n\t\tgoto err_unmap;\n\t}\n\n\ttx->callback = atmel_nand_dma_transfer_finished;\n\ttx->callback_param = &finished;\n\n\tcookie = dmaengine_submit(tx);\n\tif (dma_submit_error(cookie)) {\n\t\tdev_err(nc->dev, \"Failed to do DMA tx_submit\\n\");\n\t\tgoto err_unmap;\n\t}\n\n\tdma_async_issue_pending(nc->dmac);\n\twait_for_completion(&finished);\n\tdma_unmap_single(nc->dev, buf_dma, len, dir);\n\n\treturn 0;\n\nerr_unmap:\n\tdma_unmap_single(nc->dev, buf_dma, len, dir);\n\nerr:\n\tdev_dbg(nc->dev, \"Fall back to CPU I/O\\n\");\n\n\treturn -EIO;\n}\n\nstatic int atmel_nfc_exec_op(struct atmel_hsmc_nand_controller *nc, bool poll)\n{\n\tu8 *addrs = nc->op.addrs;\n\tunsigned int op = 0;\n\tu32 addr, val;\n\tint i, ret;\n\n\tnc->op.wait = ATMEL_HSMC_NFC_SR_CMDDONE;\n\n\tfor (i = 0; i < nc->op.ncmds; i++)\n\t\top |= ATMEL_NFC_CMD(i, nc->op.cmds[i]);\n\n\tif (nc->op.naddrs == ATMEL_NFC_MAX_ADDR_CYCLES)\n\t\tregmap_write(nc->base.smc, ATMEL_HSMC_NFC_ADDR, *addrs++);\n\n\top |= ATMEL_NFC_CSID(nc->op.cs) |\n\t      ATMEL_NFC_ACYCLE(nc->op.naddrs);\n\n\tif (nc->op.ncmds > 1)\n\t\top |= ATMEL_NFC_VCMD2;\n\n\taddr = addrs[0] | (addrs[1] << 8) | (addrs[2] << 16) |\n\t       (addrs[3] << 24);\n\n\tif (nc->op.data != ATMEL_NFC_NO_DATA) {\n\t\top |= ATMEL_NFC_DATAEN;\n\t\tnc->op.wait |= ATMEL_HSMC_NFC_SR_XFRDONE;\n\n\t\tif (nc->op.data == ATMEL_NFC_WRITE_DATA)\n\t\t\top |= ATMEL_NFC_NFCWR;\n\t}\n\n\t \n\tregmap_read(nc->base.smc, ATMEL_HSMC_NFC_SR, &val);\n\n\t \n\tregmap_write(nc->io, op, addr);\n\n\tret = atmel_nfc_wait(nc, poll, 0);\n\tif (ret)\n\t\tdev_err(nc->base.dev,\n\t\t\t\"Failed to send NAND command (err = %d)!\",\n\t\t\tret);\n\n\t \n\tmemset(&nc->op, 0, sizeof(nc->op));\n\n\treturn ret;\n}\n\nstatic void atmel_nand_data_in(struct atmel_nand *nand, void *buf,\n\t\t\t       unsigned int len, bool force_8bit)\n{\n\tstruct atmel_nand_controller *nc;\n\n\tnc = to_nand_controller(nand->base.controller);\n\n\t \n\tif (nc->dmac && virt_addr_valid(buf) &&\n\t    len >= MIN_DMA_LEN && !force_8bit &&\n\t    !atmel_nand_dma_transfer(nc, buf, nand->activecs->io.dma, len,\n\t\t\t\t     DMA_FROM_DEVICE))\n\t\treturn;\n\n\tif ((nand->base.options & NAND_BUSWIDTH_16) && !force_8bit)\n\t\tioread16_rep(nand->activecs->io.virt, buf, len / 2);\n\telse\n\t\tioread8_rep(nand->activecs->io.virt, buf, len);\n}\n\nstatic void atmel_nand_data_out(struct atmel_nand *nand, const void *buf,\n\t\t\t\tunsigned int len, bool force_8bit)\n{\n\tstruct atmel_nand_controller *nc;\n\n\tnc = to_nand_controller(nand->base.controller);\n\n\t \n\tif (nc->dmac && virt_addr_valid(buf) &&\n\t    len >= MIN_DMA_LEN && !force_8bit &&\n\t    !atmel_nand_dma_transfer(nc, (void *)buf, nand->activecs->io.dma,\n\t\t\t\t     len, DMA_TO_DEVICE))\n\t\treturn;\n\n\tif ((nand->base.options & NAND_BUSWIDTH_16) && !force_8bit)\n\t\tiowrite16_rep(nand->activecs->io.virt, buf, len / 2);\n\telse\n\t\tiowrite8_rep(nand->activecs->io.virt, buf, len);\n}\n\nstatic int atmel_nand_waitrdy(struct atmel_nand *nand, unsigned int timeout_ms)\n{\n\tif (nand->activecs->rb.type == ATMEL_NAND_NO_RB)\n\t\treturn nand_soft_waitrdy(&nand->base, timeout_ms);\n\n\treturn nand_gpio_waitrdy(&nand->base, nand->activecs->rb.gpio,\n\t\t\t\t timeout_ms);\n}\n\nstatic int atmel_hsmc_nand_waitrdy(struct atmel_nand *nand,\n\t\t\t\t   unsigned int timeout_ms)\n{\n\tstruct atmel_hsmc_nand_controller *nc;\n\tu32 status, mask;\n\n\tif (nand->activecs->rb.type != ATMEL_NAND_NATIVE_RB)\n\t\treturn atmel_nand_waitrdy(nand, timeout_ms);\n\n\tnc = to_hsmc_nand_controller(nand->base.controller);\n\tmask = ATMEL_HSMC_NFC_SR_RBEDGE(nand->activecs->rb.id);\n\treturn regmap_read_poll_timeout_atomic(nc->base.smc, ATMEL_HSMC_NFC_SR,\n\t\t\t\t\t       status, status & mask,\n\t\t\t\t\t       10, timeout_ms * 1000);\n}\n\nstatic void atmel_nand_select_target(struct atmel_nand *nand,\n\t\t\t\t     unsigned int cs)\n{\n\tnand->activecs = &nand->cs[cs];\n}\n\nstatic void atmel_hsmc_nand_select_target(struct atmel_nand *nand,\n\t\t\t\t\t  unsigned int cs)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(&nand->base);\n\tstruct atmel_hsmc_nand_controller *nc;\n\tu32 cfg = ATMEL_HSMC_NFC_CFG_PAGESIZE(mtd->writesize) |\n\t\t  ATMEL_HSMC_NFC_CFG_SPARESIZE(mtd->oobsize) |\n\t\t  ATMEL_HSMC_NFC_CFG_RSPARE;\n\n\tnand->activecs = &nand->cs[cs];\n\tnc = to_hsmc_nand_controller(nand->base.controller);\n\tif (nc->cfg == cfg)\n\t\treturn;\n\n\tregmap_update_bits(nc->base.smc, ATMEL_HSMC_NFC_CFG,\n\t\t\t   ATMEL_HSMC_NFC_CFG_PAGESIZE_MASK |\n\t\t\t   ATMEL_HSMC_NFC_CFG_SPARESIZE_MASK |\n\t\t\t   ATMEL_HSMC_NFC_CFG_RSPARE |\n\t\t\t   ATMEL_HSMC_NFC_CFG_WSPARE,\n\t\t\t   cfg);\n\tnc->cfg = cfg;\n}\n\nstatic int atmel_smc_nand_exec_instr(struct atmel_nand *nand,\n\t\t\t\t     const struct nand_op_instr *instr)\n{\n\tstruct atmel_nand_controller *nc;\n\tunsigned int i;\n\n\tnc = to_nand_controller(nand->base.controller);\n\tswitch (instr->type) {\n\tcase NAND_OP_CMD_INSTR:\n\t\twriteb(instr->ctx.cmd.opcode,\n\t\t       nand->activecs->io.virt + nc->caps->cle_offs);\n\t\treturn 0;\n\tcase NAND_OP_ADDR_INSTR:\n\t\tfor (i = 0; i < instr->ctx.addr.naddrs; i++)\n\t\t\twriteb(instr->ctx.addr.addrs[i],\n\t\t\t       nand->activecs->io.virt + nc->caps->ale_offs);\n\t\treturn 0;\n\tcase NAND_OP_DATA_IN_INSTR:\n\t\tatmel_nand_data_in(nand, instr->ctx.data.buf.in,\n\t\t\t\t   instr->ctx.data.len,\n\t\t\t\t   instr->ctx.data.force_8bit);\n\t\treturn 0;\n\tcase NAND_OP_DATA_OUT_INSTR:\n\t\tatmel_nand_data_out(nand, instr->ctx.data.buf.out,\n\t\t\t\t    instr->ctx.data.len,\n\t\t\t\t    instr->ctx.data.force_8bit);\n\t\treturn 0;\n\tcase NAND_OP_WAITRDY_INSTR:\n\t\treturn atmel_nand_waitrdy(nand,\n\t\t\t\t\t  instr->ctx.waitrdy.timeout_ms);\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int atmel_smc_nand_exec_op(struct atmel_nand *nand,\n\t\t\t\t  const struct nand_operation *op,\n\t\t\t\t  bool check_only)\n{\n\tunsigned int i;\n\tint ret = 0;\n\n\tif (check_only)\n\t\treturn 0;\n\n\tatmel_nand_select_target(nand, op->cs);\n\tgpiod_set_value(nand->activecs->csgpio, 0);\n\tfor (i = 0; i < op->ninstrs; i++) {\n\t\tret = atmel_smc_nand_exec_instr(nand, &op->instrs[i]);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\tgpiod_set_value(nand->activecs->csgpio, 1);\n\n\treturn ret;\n}\n\nstatic int atmel_hsmc_exec_cmd_addr(struct nand_chip *chip,\n\t\t\t\t    const struct nand_subop *subop)\n{\n\tstruct atmel_nand *nand = to_atmel_nand(chip);\n\tstruct atmel_hsmc_nand_controller *nc;\n\tunsigned int i, j;\n\n\tnc = to_hsmc_nand_controller(chip->controller);\n\n\tnc->op.cs = nand->activecs->id;\n\tfor (i = 0; i < subop->ninstrs; i++) {\n\t\tconst struct nand_op_instr *instr = &subop->instrs[i];\n\n\t\tif (instr->type == NAND_OP_CMD_INSTR) {\n\t\t\tnc->op.cmds[nc->op.ncmds++] = instr->ctx.cmd.opcode;\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor (j = nand_subop_get_addr_start_off(subop, i);\n\t\t     j < nand_subop_get_num_addr_cyc(subop, i); j++) {\n\t\t\tnc->op.addrs[nc->op.naddrs] = instr->ctx.addr.addrs[j];\n\t\t\tnc->op.naddrs++;\n\t\t}\n\t}\n\n\treturn atmel_nfc_exec_op(nc, true);\n}\n\nstatic int atmel_hsmc_exec_rw(struct nand_chip *chip,\n\t\t\t      const struct nand_subop *subop)\n{\n\tconst struct nand_op_instr *instr = subop->instrs;\n\tstruct atmel_nand *nand = to_atmel_nand(chip);\n\n\tif (instr->type == NAND_OP_DATA_IN_INSTR)\n\t\tatmel_nand_data_in(nand, instr->ctx.data.buf.in,\n\t\t\t\t   instr->ctx.data.len,\n\t\t\t\t   instr->ctx.data.force_8bit);\n\telse\n\t\tatmel_nand_data_out(nand, instr->ctx.data.buf.out,\n\t\t\t\t    instr->ctx.data.len,\n\t\t\t\t    instr->ctx.data.force_8bit);\n\n\treturn 0;\n}\n\nstatic int atmel_hsmc_exec_waitrdy(struct nand_chip *chip,\n\t\t\t\t   const struct nand_subop *subop)\n{\n\tconst struct nand_op_instr *instr = subop->instrs;\n\tstruct atmel_nand *nand = to_atmel_nand(chip);\n\n\treturn atmel_hsmc_nand_waitrdy(nand, instr->ctx.waitrdy.timeout_ms);\n}\n\nstatic const struct nand_op_parser atmel_hsmc_op_parser = NAND_OP_PARSER(\n\tNAND_OP_PARSER_PATTERN(atmel_hsmc_exec_cmd_addr,\n\t\tNAND_OP_PARSER_PAT_CMD_ELEM(true),\n\t\tNAND_OP_PARSER_PAT_ADDR_ELEM(true, 5),\n\t\tNAND_OP_PARSER_PAT_CMD_ELEM(true)),\n\tNAND_OP_PARSER_PATTERN(atmel_hsmc_exec_rw,\n\t\tNAND_OP_PARSER_PAT_DATA_IN_ELEM(false, 0)),\n\tNAND_OP_PARSER_PATTERN(atmel_hsmc_exec_rw,\n\t\tNAND_OP_PARSER_PAT_DATA_OUT_ELEM(false, 0)),\n\tNAND_OP_PARSER_PATTERN(atmel_hsmc_exec_waitrdy,\n\t\tNAND_OP_PARSER_PAT_WAITRDY_ELEM(false)),\n);\n\nstatic int atmel_hsmc_nand_exec_op(struct atmel_nand *nand,\n\t\t\t\t   const struct nand_operation *op,\n\t\t\t\t   bool check_only)\n{\n\tint ret;\n\n\tif (check_only)\n\t\treturn nand_op_parser_exec_op(&nand->base,\n\t\t\t\t\t      &atmel_hsmc_op_parser, op, true);\n\n\tatmel_hsmc_nand_select_target(nand, op->cs);\n\tret = nand_op_parser_exec_op(&nand->base, &atmel_hsmc_op_parser, op,\n\t\t\t\t     false);\n\n\treturn ret;\n}\n\nstatic void atmel_nfc_copy_to_sram(struct nand_chip *chip, const u8 *buf,\n\t\t\t\t   bool oob_required)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tstruct atmel_hsmc_nand_controller *nc;\n\tint ret = -EIO;\n\n\tnc = to_hsmc_nand_controller(chip->controller);\n\n\tif (nc->base.dmac)\n\t\tret = atmel_nand_dma_transfer(&nc->base, (void *)buf,\n\t\t\t\t\t      nc->sram.dma, mtd->writesize,\n\t\t\t\t\t      DMA_TO_DEVICE);\n\n\t \n\tif (ret)\n\t\tmemcpy_toio(nc->sram.virt, buf, mtd->writesize);\n\n\tif (oob_required)\n\t\tmemcpy_toio(nc->sram.virt + mtd->writesize, chip->oob_poi,\n\t\t\t    mtd->oobsize);\n}\n\nstatic void atmel_nfc_copy_from_sram(struct nand_chip *chip, u8 *buf,\n\t\t\t\t     bool oob_required)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tstruct atmel_hsmc_nand_controller *nc;\n\tint ret = -EIO;\n\n\tnc = to_hsmc_nand_controller(chip->controller);\n\n\tif (nc->base.dmac)\n\t\tret = atmel_nand_dma_transfer(&nc->base, buf, nc->sram.dma,\n\t\t\t\t\t      mtd->writesize, DMA_FROM_DEVICE);\n\n\t \n\tif (ret)\n\t\tmemcpy_fromio(buf, nc->sram.virt, mtd->writesize);\n\n\tif (oob_required)\n\t\tmemcpy_fromio(chip->oob_poi, nc->sram.virt + mtd->writesize,\n\t\t\t      mtd->oobsize);\n}\n\nstatic void atmel_nfc_set_op_addr(struct nand_chip *chip, int page, int column)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tstruct atmel_hsmc_nand_controller *nc;\n\n\tnc = to_hsmc_nand_controller(chip->controller);\n\n\tif (column >= 0) {\n\t\tnc->op.addrs[nc->op.naddrs++] = column;\n\n\t\t \n\t\tif (mtd->writesize > 512)\n\t\t\tnc->op.addrs[nc->op.naddrs++] = column >> 8;\n\t}\n\n\tif (page >= 0) {\n\t\tnc->op.addrs[nc->op.naddrs++] = page;\n\t\tnc->op.addrs[nc->op.naddrs++] = page >> 8;\n\n\t\tif (chip->options & NAND_ROW_ADDR_3)\n\t\t\tnc->op.addrs[nc->op.naddrs++] = page >> 16;\n\t}\n}\n\nstatic int atmel_nand_pmecc_enable(struct nand_chip *chip, int op, bool raw)\n{\n\tstruct atmel_nand *nand = to_atmel_nand(chip);\n\tstruct atmel_nand_controller *nc;\n\tint ret;\n\n\tnc = to_nand_controller(chip->controller);\n\n\tif (raw)\n\t\treturn 0;\n\n\tret = atmel_pmecc_enable(nand->pmecc, op);\n\tif (ret)\n\t\tdev_err(nc->dev,\n\t\t\t\"Failed to enable ECC engine (err = %d)\\n\", ret);\n\n\treturn ret;\n}\n\nstatic void atmel_nand_pmecc_disable(struct nand_chip *chip, bool raw)\n{\n\tstruct atmel_nand *nand = to_atmel_nand(chip);\n\n\tif (!raw)\n\t\tatmel_pmecc_disable(nand->pmecc);\n}\n\nstatic int atmel_nand_pmecc_generate_eccbytes(struct nand_chip *chip, bool raw)\n{\n\tstruct atmel_nand *nand = to_atmel_nand(chip);\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tstruct atmel_nand_controller *nc;\n\tstruct mtd_oob_region oobregion;\n\tvoid *eccbuf;\n\tint ret, i;\n\n\tnc = to_nand_controller(chip->controller);\n\n\tif (raw)\n\t\treturn 0;\n\n\tret = atmel_pmecc_wait_rdy(nand->pmecc);\n\tif (ret) {\n\t\tdev_err(nc->dev,\n\t\t\t\"Failed to transfer NAND page data (err = %d)\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\tmtd_ooblayout_ecc(mtd, 0, &oobregion);\n\teccbuf = chip->oob_poi + oobregion.offset;\n\n\tfor (i = 0; i < chip->ecc.steps; i++) {\n\t\tatmel_pmecc_get_generated_eccbytes(nand->pmecc, i,\n\t\t\t\t\t\t   eccbuf);\n\t\teccbuf += chip->ecc.bytes;\n\t}\n\n\treturn 0;\n}\n\nstatic int atmel_nand_pmecc_correct_data(struct nand_chip *chip, void *buf,\n\t\t\t\t\t bool raw)\n{\n\tstruct atmel_nand *nand = to_atmel_nand(chip);\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tstruct atmel_nand_controller *nc;\n\tstruct mtd_oob_region oobregion;\n\tint ret, i, max_bitflips = 0;\n\tvoid *databuf, *eccbuf;\n\n\tnc = to_nand_controller(chip->controller);\n\n\tif (raw)\n\t\treturn 0;\n\n\tret = atmel_pmecc_wait_rdy(nand->pmecc);\n\tif (ret) {\n\t\tdev_err(nc->dev,\n\t\t\t\"Failed to read NAND page data (err = %d)\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\tmtd_ooblayout_ecc(mtd, 0, &oobregion);\n\teccbuf = chip->oob_poi + oobregion.offset;\n\tdatabuf = buf;\n\n\tfor (i = 0; i < chip->ecc.steps; i++) {\n\t\tret = atmel_pmecc_correct_sector(nand->pmecc, i, databuf,\n\t\t\t\t\t\t eccbuf);\n\t\tif (ret < 0 && !atmel_pmecc_correct_erased_chunks(nand->pmecc))\n\t\t\tret = nand_check_erased_ecc_chunk(databuf,\n\t\t\t\t\t\t\t  chip->ecc.size,\n\t\t\t\t\t\t\t  eccbuf,\n\t\t\t\t\t\t\t  chip->ecc.bytes,\n\t\t\t\t\t\t\t  NULL, 0,\n\t\t\t\t\t\t\t  chip->ecc.strength);\n\n\t\tif (ret >= 0) {\n\t\t\tmtd->ecc_stats.corrected += ret;\n\t\t\tmax_bitflips = max(ret, max_bitflips);\n\t\t} else {\n\t\t\tmtd->ecc_stats.failed++;\n\t\t}\n\n\t\tdatabuf += chip->ecc.size;\n\t\teccbuf += chip->ecc.bytes;\n\t}\n\n\treturn max_bitflips;\n}\n\nstatic int atmel_nand_pmecc_write_pg(struct nand_chip *chip, const u8 *buf,\n\t\t\t\t     bool oob_required, int page, bool raw)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tstruct atmel_nand *nand = to_atmel_nand(chip);\n\tint ret;\n\n\tnand_prog_page_begin_op(chip, page, 0, NULL, 0);\n\n\tret = atmel_nand_pmecc_enable(chip, NAND_ECC_WRITE, raw);\n\tif (ret)\n\t\treturn ret;\n\n\tnand_write_data_op(chip, buf, mtd->writesize, false);\n\n\tret = atmel_nand_pmecc_generate_eccbytes(chip, raw);\n\tif (ret) {\n\t\tatmel_pmecc_disable(nand->pmecc);\n\t\treturn ret;\n\t}\n\n\tatmel_nand_pmecc_disable(chip, raw);\n\n\tnand_write_data_op(chip, chip->oob_poi, mtd->oobsize, false);\n\n\treturn nand_prog_page_end_op(chip);\n}\n\nstatic int atmel_nand_pmecc_write_page(struct nand_chip *chip, const u8 *buf,\n\t\t\t\t       int oob_required, int page)\n{\n\treturn atmel_nand_pmecc_write_pg(chip, buf, oob_required, page, false);\n}\n\nstatic int atmel_nand_pmecc_write_page_raw(struct nand_chip *chip,\n\t\t\t\t\t   const u8 *buf, int oob_required,\n\t\t\t\t\t   int page)\n{\n\treturn atmel_nand_pmecc_write_pg(chip, buf, oob_required, page, true);\n}\n\nstatic int atmel_nand_pmecc_read_pg(struct nand_chip *chip, u8 *buf,\n\t\t\t\t    bool oob_required, int page, bool raw)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tint ret;\n\n\tnand_read_page_op(chip, page, 0, NULL, 0);\n\n\tret = atmel_nand_pmecc_enable(chip, NAND_ECC_READ, raw);\n\tif (ret)\n\t\treturn ret;\n\n\tret = nand_read_data_op(chip, buf, mtd->writesize, false, false);\n\tif (ret)\n\t\tgoto out_disable;\n\n\tret = nand_read_data_op(chip, chip->oob_poi, mtd->oobsize, false, false);\n\tif (ret)\n\t\tgoto out_disable;\n\n\tret = atmel_nand_pmecc_correct_data(chip, buf, raw);\n\nout_disable:\n\tatmel_nand_pmecc_disable(chip, raw);\n\n\treturn ret;\n}\n\nstatic int atmel_nand_pmecc_read_page(struct nand_chip *chip, u8 *buf,\n\t\t\t\t      int oob_required, int page)\n{\n\treturn atmel_nand_pmecc_read_pg(chip, buf, oob_required, page, false);\n}\n\nstatic int atmel_nand_pmecc_read_page_raw(struct nand_chip *chip, u8 *buf,\n\t\t\t\t\t  int oob_required, int page)\n{\n\treturn atmel_nand_pmecc_read_pg(chip, buf, oob_required, page, true);\n}\n\nstatic int atmel_hsmc_nand_pmecc_write_pg(struct nand_chip *chip,\n\t\t\t\t\t  const u8 *buf, bool oob_required,\n\t\t\t\t\t  int page, bool raw)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tstruct atmel_nand *nand = to_atmel_nand(chip);\n\tstruct atmel_hsmc_nand_controller *nc;\n\tint ret;\n\n\tatmel_hsmc_nand_select_target(nand, chip->cur_cs);\n\tnc = to_hsmc_nand_controller(chip->controller);\n\n\tatmel_nfc_copy_to_sram(chip, buf, false);\n\n\tnc->op.cmds[0] = NAND_CMD_SEQIN;\n\tnc->op.ncmds = 1;\n\tatmel_nfc_set_op_addr(chip, page, 0x0);\n\tnc->op.cs = nand->activecs->id;\n\tnc->op.data = ATMEL_NFC_WRITE_DATA;\n\n\tret = atmel_nand_pmecc_enable(chip, NAND_ECC_WRITE, raw);\n\tif (ret)\n\t\treturn ret;\n\n\tret = atmel_nfc_exec_op(nc, false);\n\tif (ret) {\n\t\tatmel_nand_pmecc_disable(chip, raw);\n\t\tdev_err(nc->base.dev,\n\t\t\t\"Failed to transfer NAND page data (err = %d)\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\tret = atmel_nand_pmecc_generate_eccbytes(chip, raw);\n\n\tatmel_nand_pmecc_disable(chip, raw);\n\n\tif (ret)\n\t\treturn ret;\n\n\tnand_write_data_op(chip, chip->oob_poi, mtd->oobsize, false);\n\n\treturn nand_prog_page_end_op(chip);\n}\n\nstatic int atmel_hsmc_nand_pmecc_write_page(struct nand_chip *chip,\n\t\t\t\t\t    const u8 *buf, int oob_required,\n\t\t\t\t\t    int page)\n{\n\treturn atmel_hsmc_nand_pmecc_write_pg(chip, buf, oob_required, page,\n\t\t\t\t\t      false);\n}\n\nstatic int atmel_hsmc_nand_pmecc_write_page_raw(struct nand_chip *chip,\n\t\t\t\t\t\tconst u8 *buf,\n\t\t\t\t\t\tint oob_required, int page)\n{\n\treturn atmel_hsmc_nand_pmecc_write_pg(chip, buf, oob_required, page,\n\t\t\t\t\t      true);\n}\n\nstatic int atmel_hsmc_nand_pmecc_read_pg(struct nand_chip *chip, u8 *buf,\n\t\t\t\t\t bool oob_required, int page,\n\t\t\t\t\t bool raw)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tstruct atmel_nand *nand = to_atmel_nand(chip);\n\tstruct atmel_hsmc_nand_controller *nc;\n\tint ret;\n\n\tatmel_hsmc_nand_select_target(nand, chip->cur_cs);\n\tnc = to_hsmc_nand_controller(chip->controller);\n\n\t \n\tif (nand->activecs->rb.type != ATMEL_NAND_NATIVE_RB)\n\t\treturn atmel_nand_pmecc_read_pg(chip, buf, oob_required, page,\n\t\t\t\t\t\traw);\n\n\tnc->op.cmds[nc->op.ncmds++] = NAND_CMD_READ0;\n\n\tif (mtd->writesize > 512)\n\t\tnc->op.cmds[nc->op.ncmds++] = NAND_CMD_READSTART;\n\n\tatmel_nfc_set_op_addr(chip, page, 0x0);\n\tnc->op.cs = nand->activecs->id;\n\tnc->op.data = ATMEL_NFC_READ_DATA;\n\n\tret = atmel_nand_pmecc_enable(chip, NAND_ECC_READ, raw);\n\tif (ret)\n\t\treturn ret;\n\n\tret = atmel_nfc_exec_op(nc, false);\n\tif (ret) {\n\t\tatmel_nand_pmecc_disable(chip, raw);\n\t\tdev_err(nc->base.dev,\n\t\t\t\"Failed to load NAND page data (err = %d)\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\tatmel_nfc_copy_from_sram(chip, buf, true);\n\n\tret = atmel_nand_pmecc_correct_data(chip, buf, raw);\n\n\tatmel_nand_pmecc_disable(chip, raw);\n\n\treturn ret;\n}\n\nstatic int atmel_hsmc_nand_pmecc_read_page(struct nand_chip *chip, u8 *buf,\n\t\t\t\t\t   int oob_required, int page)\n{\n\treturn atmel_hsmc_nand_pmecc_read_pg(chip, buf, oob_required, page,\n\t\t\t\t\t     false);\n}\n\nstatic int atmel_hsmc_nand_pmecc_read_page_raw(struct nand_chip *chip,\n\t\t\t\t\t       u8 *buf, int oob_required,\n\t\t\t\t\t       int page)\n{\n\treturn atmel_hsmc_nand_pmecc_read_pg(chip, buf, oob_required, page,\n\t\t\t\t\t     true);\n}\n\nstatic int atmel_nand_pmecc_init(struct nand_chip *chip)\n{\n\tconst struct nand_ecc_props *requirements =\n\t\tnanddev_get_ecc_requirements(&chip->base);\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tstruct nand_device *nanddev = mtd_to_nanddev(mtd);\n\tstruct atmel_nand *nand = to_atmel_nand(chip);\n\tstruct atmel_nand_controller *nc;\n\tstruct atmel_pmecc_user_req req;\n\n\tnc = to_nand_controller(chip->controller);\n\n\tif (!nc->pmecc) {\n\t\tdev_err(nc->dev, \"HW ECC not supported\\n\");\n\t\treturn -ENOTSUPP;\n\t}\n\n\tif (nc->caps->legacy_of_bindings) {\n\t\tu32 val;\n\n\t\tif (!of_property_read_u32(nc->dev->of_node, \"atmel,pmecc-cap\",\n\t\t\t\t\t  &val))\n\t\t\tchip->ecc.strength = val;\n\n\t\tif (!of_property_read_u32(nc->dev->of_node,\n\t\t\t\t\t  \"atmel,pmecc-sector-size\",\n\t\t\t\t\t  &val))\n\t\t\tchip->ecc.size = val;\n\t}\n\n\tif (nanddev->ecc.user_conf.flags & NAND_ECC_MAXIMIZE_STRENGTH)\n\t\treq.ecc.strength = ATMEL_PMECC_MAXIMIZE_ECC_STRENGTH;\n\telse if (chip->ecc.strength)\n\t\treq.ecc.strength = chip->ecc.strength;\n\telse if (requirements->strength)\n\t\treq.ecc.strength = requirements->strength;\n\telse\n\t\treq.ecc.strength = ATMEL_PMECC_MAXIMIZE_ECC_STRENGTH;\n\n\tif (chip->ecc.size)\n\t\treq.ecc.sectorsize = chip->ecc.size;\n\telse if (requirements->step_size)\n\t\treq.ecc.sectorsize = requirements->step_size;\n\telse\n\t\treq.ecc.sectorsize = ATMEL_PMECC_SECTOR_SIZE_AUTO;\n\n\treq.pagesize = mtd->writesize;\n\treq.oobsize = mtd->oobsize;\n\n\tif (mtd->writesize <= 512) {\n\t\treq.ecc.bytes = 4;\n\t\treq.ecc.ooboffset = 0;\n\t} else {\n\t\treq.ecc.bytes = mtd->oobsize - 2;\n\t\treq.ecc.ooboffset = ATMEL_PMECC_OOBOFFSET_AUTO;\n\t}\n\n\tnand->pmecc = atmel_pmecc_create_user(nc->pmecc, &req);\n\tif (IS_ERR(nand->pmecc))\n\t\treturn PTR_ERR(nand->pmecc);\n\n\tchip->ecc.algo = NAND_ECC_ALGO_BCH;\n\tchip->ecc.size = req.ecc.sectorsize;\n\tchip->ecc.bytes = req.ecc.bytes / req.ecc.nsectors;\n\tchip->ecc.strength = req.ecc.strength;\n\n\tchip->options |= NAND_NO_SUBPAGE_WRITE;\n\n\tmtd_set_ooblayout(mtd, nand_get_large_page_ooblayout());\n\n\treturn 0;\n}\n\nstatic int atmel_nand_ecc_init(struct nand_chip *chip)\n{\n\tstruct atmel_nand_controller *nc;\n\tint ret;\n\n\tnc = to_nand_controller(chip->controller);\n\n\tswitch (chip->ecc.engine_type) {\n\tcase NAND_ECC_ENGINE_TYPE_NONE:\n\tcase NAND_ECC_ENGINE_TYPE_SOFT:\n\t\t \n\t\tbreak;\n\n\tcase NAND_ECC_ENGINE_TYPE_ON_HOST:\n\t\tret = atmel_nand_pmecc_init(chip);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tchip->ecc.read_page = atmel_nand_pmecc_read_page;\n\t\tchip->ecc.write_page = atmel_nand_pmecc_write_page;\n\t\tchip->ecc.read_page_raw = atmel_nand_pmecc_read_page_raw;\n\t\tchip->ecc.write_page_raw = atmel_nand_pmecc_write_page_raw;\n\t\tbreak;\n\n\tdefault:\n\t\t \n\t\tdev_err(nc->dev, \"Unsupported ECC mode: %d\\n\",\n\t\t\tchip->ecc.engine_type);\n\t\treturn -ENOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic int atmel_hsmc_nand_ecc_init(struct nand_chip *chip)\n{\n\tint ret;\n\n\tret = atmel_nand_ecc_init(chip);\n\tif (ret)\n\t\treturn ret;\n\n\tif (chip->ecc.engine_type != NAND_ECC_ENGINE_TYPE_ON_HOST)\n\t\treturn 0;\n\n\t \n\tchip->ecc.read_page = atmel_hsmc_nand_pmecc_read_page;\n\tchip->ecc.write_page = atmel_hsmc_nand_pmecc_write_page;\n\tchip->ecc.read_page_raw = atmel_hsmc_nand_pmecc_read_page_raw;\n\tchip->ecc.write_page_raw = atmel_hsmc_nand_pmecc_write_page_raw;\n\n\treturn 0;\n}\n\nstatic int atmel_smc_nand_prepare_smcconf(struct atmel_nand *nand,\n\t\t\t\t\tconst struct nand_interface_config *conf,\n\t\t\t\t\tstruct atmel_smc_cs_conf *smcconf)\n{\n\tu32 ncycles, totalcycles, timeps, mckperiodps;\n\tstruct atmel_nand_controller *nc;\n\tint ret;\n\n\tnc = to_nand_controller(nand->base.controller);\n\n\t \n\tif (!nand_interface_is_sdr(conf))\n\t\treturn -ENOTSUPP;\n\n\t \n\tif (conf->timings.sdr.tRC_min < 30000)\n\t\treturn -ENOTSUPP;\n\n\tatmel_smc_cs_conf_init(smcconf);\n\n\tmckperiodps = NSEC_PER_SEC / clk_get_rate(nc->mck);\n\tmckperiodps *= 1000;\n\n\t \n\tncycles = DIV_ROUND_UP(conf->timings.sdr.tWP_min, mckperiodps);\n\ttotalcycles = ncycles;\n\tret = atmel_smc_cs_conf_set_pulse(smcconf, ATMEL_SMC_NWE_SHIFT,\n\t\t\t\t\t  ncycles);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\ttimeps = max3(conf->timings.sdr.tCLS_min, conf->timings.sdr.tCS_min,\n\t\t      conf->timings.sdr.tALS_min);\n\ttimeps = max(timeps, conf->timings.sdr.tDS_min);\n\tncycles = DIV_ROUND_UP(timeps, mckperiodps);\n\tncycles = ncycles > totalcycles ? ncycles - totalcycles : 0;\n\ttotalcycles += ncycles;\n\tret = atmel_smc_cs_conf_set_setup(smcconf, ATMEL_SMC_NWE_SHIFT,\n\t\t\t\t\t  ncycles);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\ttimeps = max3(conf->timings.sdr.tCLH_min, conf->timings.sdr.tCH_min,\n\t\t      conf->timings.sdr.tALH_min);\n\ttimeps = max3(timeps, conf->timings.sdr.tDH_min,\n\t\t      conf->timings.sdr.tWH_min);\n\tncycles = DIV_ROUND_UP(timeps, mckperiodps);\n\ttotalcycles += ncycles;\n\n\t \n\tncycles = DIV_ROUND_UP(conf->timings.sdr.tWC_min, mckperiodps);\n\tncycles = max(totalcycles, ncycles);\n\tret = atmel_smc_cs_conf_set_cycle(smcconf, ATMEL_SMC_NWE_SHIFT,\n\t\t\t\t\t  ncycles);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = atmel_smc_cs_conf_set_pulse(smcconf, ATMEL_SMC_NCS_WR_SHIFT,\n\t\t\t\t\t  ncycles);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\ttimeps = max(conf->timings.sdr.tREH_min, conf->timings.sdr.tRHOH_min);\n\tncycles = DIV_ROUND_UP(timeps, mckperiodps);\n\ttotalcycles = ncycles;\n\n\t \n\tncycles = DIV_ROUND_UP(conf->timings.sdr.tRHZ_max, mckperiodps);\n\tncycles -= totalcycles;\n\n\t \n\tif (ncycles > ATMEL_SMC_MODE_TDF_MAX)\n\t\tncycles = ATMEL_SMC_MODE_TDF_MAX;\n\telse if (ncycles < ATMEL_SMC_MODE_TDF_MIN)\n\t\tncycles = ATMEL_SMC_MODE_TDF_MIN;\n\n\tsmcconf->mode |= ATMEL_SMC_MODE_TDF(ncycles) |\n\t\t\t ATMEL_SMC_MODE_TDFMODE_OPTIMIZED;\n\n\t \n\tncycles = DIV_ROUND_UP(conf->timings.sdr.tRP_min, mckperiodps);\n\ttotalcycles += ncycles;\n\tret = atmel_smc_cs_conf_set_pulse(smcconf, ATMEL_SMC_NRD_SHIFT,\n\t\t\t\t\t  ncycles);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tncycles = DIV_ROUND_UP(conf->timings.sdr.tRC_min, mckperiodps);\n\tncycles = max(totalcycles, ncycles);\n\tret = atmel_smc_cs_conf_set_cycle(smcconf, ATMEL_SMC_NRD_SHIFT,\n\t\t\t\t\t  ncycles);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = atmel_smc_cs_conf_set_pulse(smcconf, ATMEL_SMC_NCS_RD_SHIFT,\n\t\t\t\t\t  ncycles);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tncycles = DIV_ROUND_UP(conf->timings.sdr.tCLR_min, mckperiodps);\n\tret = atmel_smc_cs_conf_set_timing(smcconf,\n\t\t\t\t\t   ATMEL_HSMC_TIMINGS_TCLR_SHIFT,\n\t\t\t\t\t   ncycles);\n\tif (ret)\n\t\treturn ret;\n\n\tncycles = DIV_ROUND_UP(conf->timings.sdr.tADL_min, mckperiodps);\n\tret = atmel_smc_cs_conf_set_timing(smcconf,\n\t\t\t\t\t   ATMEL_HSMC_TIMINGS_TADL_SHIFT,\n\t\t\t\t\t   ncycles);\n\t \n\tif (ret && ret != -ERANGE)\n\t\treturn ret;\n\n\tncycles = DIV_ROUND_UP(conf->timings.sdr.tAR_min, mckperiodps);\n\tret = atmel_smc_cs_conf_set_timing(smcconf,\n\t\t\t\t\t   ATMEL_HSMC_TIMINGS_TAR_SHIFT,\n\t\t\t\t\t   ncycles);\n\tif (ret)\n\t\treturn ret;\n\n\tncycles = DIV_ROUND_UP(conf->timings.sdr.tRR_min, mckperiodps);\n\tret = atmel_smc_cs_conf_set_timing(smcconf,\n\t\t\t\t\t   ATMEL_HSMC_TIMINGS_TRR_SHIFT,\n\t\t\t\t\t   ncycles);\n\tif (ret)\n\t\treturn ret;\n\n\tncycles = DIV_ROUND_UP(conf->timings.sdr.tWB_max, mckperiodps);\n\tret = atmel_smc_cs_conf_set_timing(smcconf,\n\t\t\t\t\t   ATMEL_HSMC_TIMINGS_TWB_SHIFT,\n\t\t\t\t\t   ncycles);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tsmcconf->timings |= ATMEL_HSMC_TIMINGS_NFSEL;\n\n\t \n\tif (nand->base.options & NAND_BUSWIDTH_16)\n\t\tsmcconf->mode |= ATMEL_SMC_MODE_DBW_16;\n\n\t \n\tsmcconf->mode |= ATMEL_SMC_MODE_READMODE_NRD |\n\t\t\t ATMEL_SMC_MODE_WRITEMODE_NWE;\n\n\treturn 0;\n}\n\nstatic int atmel_smc_nand_setup_interface(struct atmel_nand *nand,\n\t\t\t\t\tint csline,\n\t\t\t\t\tconst struct nand_interface_config *conf)\n{\n\tstruct atmel_nand_controller *nc;\n\tstruct atmel_smc_cs_conf smcconf;\n\tstruct atmel_nand_cs *cs;\n\tint ret;\n\n\tnc = to_nand_controller(nand->base.controller);\n\n\tret = atmel_smc_nand_prepare_smcconf(nand, conf, &smcconf);\n\tif (ret)\n\t\treturn ret;\n\n\tif (csline == NAND_DATA_IFACE_CHECK_ONLY)\n\t\treturn 0;\n\n\tcs = &nand->cs[csline];\n\tcs->smcconf = smcconf;\n\tatmel_smc_cs_conf_apply(nc->smc, cs->id, &cs->smcconf);\n\n\treturn 0;\n}\n\nstatic int atmel_hsmc_nand_setup_interface(struct atmel_nand *nand,\n\t\t\t\t\tint csline,\n\t\t\t\t\tconst struct nand_interface_config *conf)\n{\n\tstruct atmel_hsmc_nand_controller *nc;\n\tstruct atmel_smc_cs_conf smcconf;\n\tstruct atmel_nand_cs *cs;\n\tint ret;\n\n\tnc = to_hsmc_nand_controller(nand->base.controller);\n\n\tret = atmel_smc_nand_prepare_smcconf(nand, conf, &smcconf);\n\tif (ret)\n\t\treturn ret;\n\n\tif (csline == NAND_DATA_IFACE_CHECK_ONLY)\n\t\treturn 0;\n\n\tcs = &nand->cs[csline];\n\tcs->smcconf = smcconf;\n\n\tif (cs->rb.type == ATMEL_NAND_NATIVE_RB)\n\t\tcs->smcconf.timings |= ATMEL_HSMC_TIMINGS_RBNSEL(cs->rb.id);\n\n\tatmel_hsmc_cs_conf_apply(nc->base.smc, nc->hsmc_layout, cs->id,\n\t\t\t\t &cs->smcconf);\n\n\treturn 0;\n}\n\nstatic int atmel_nand_setup_interface(struct nand_chip *chip, int csline,\n\t\t\t\t      const struct nand_interface_config *conf)\n{\n\tstruct atmel_nand *nand = to_atmel_nand(chip);\n\tconst struct nand_sdr_timings *sdr;\n\tstruct atmel_nand_controller *nc;\n\n\tsdr = nand_get_sdr_timings(conf);\n\tif (IS_ERR(sdr))\n\t\treturn PTR_ERR(sdr);\n\n\tnc = to_nand_controller(nand->base.controller);\n\n\tif (csline >= nand->numcs ||\n\t    (csline < 0 && csline != NAND_DATA_IFACE_CHECK_ONLY))\n\t\treturn -EINVAL;\n\n\treturn nc->caps->ops->setup_interface(nand, csline, conf);\n}\n\nstatic int atmel_nand_exec_op(struct nand_chip *chip,\n\t\t\t      const struct nand_operation *op,\n\t\t\t      bool check_only)\n{\n\tstruct atmel_nand *nand = to_atmel_nand(chip);\n\tstruct atmel_nand_controller *nc;\n\n\tnc = to_nand_controller(nand->base.controller);\n\n\treturn nc->caps->ops->exec_op(nand, op, check_only);\n}\n\nstatic void atmel_nand_init(struct atmel_nand_controller *nc,\n\t\t\t    struct atmel_nand *nand)\n{\n\tstruct nand_chip *chip = &nand->base;\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\n\tmtd->dev.parent = nc->dev;\n\tnand->base.controller = &nc->base;\n\n\tif (!nc->mck || !nc->caps->ops->setup_interface)\n\t\tchip->options |= NAND_KEEP_TIMINGS;\n\n\t \n\tif (nc->dmac)\n\t\tchip->options |= NAND_USES_DMA;\n\n\t \n\tif (nc->pmecc)\n\t\tchip->ecc.engine_type = NAND_ECC_ENGINE_TYPE_ON_HOST;\n}\n\nstatic void atmel_smc_nand_init(struct atmel_nand_controller *nc,\n\t\t\t\tstruct atmel_nand *nand)\n{\n\tstruct nand_chip *chip = &nand->base;\n\tstruct atmel_smc_nand_controller *smc_nc;\n\tint i;\n\n\tatmel_nand_init(nc, nand);\n\n\tsmc_nc = to_smc_nand_controller(chip->controller);\n\tif (!smc_nc->ebi_csa_regmap)\n\t\treturn;\n\n\t \n\tfor (i = 0; i < nand->numcs; i++)\n\t\tregmap_update_bits(smc_nc->ebi_csa_regmap,\n\t\t\t\t   smc_nc->ebi_csa->offs,\n\t\t\t\t   BIT(nand->cs[i].id), BIT(nand->cs[i].id));\n\n\tif (smc_nc->ebi_csa->nfd0_on_d16)\n\t\tregmap_update_bits(smc_nc->ebi_csa_regmap,\n\t\t\t\t   smc_nc->ebi_csa->offs,\n\t\t\t\t   smc_nc->ebi_csa->nfd0_on_d16,\n\t\t\t\t   smc_nc->ebi_csa->nfd0_on_d16);\n}\n\nstatic int atmel_nand_controller_remove_nand(struct atmel_nand *nand)\n{\n\tstruct nand_chip *chip = &nand->base;\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tint ret;\n\n\tret = mtd_device_unregister(mtd);\n\tif (ret)\n\t\treturn ret;\n\n\tnand_cleanup(chip);\n\tlist_del(&nand->node);\n\n\treturn 0;\n}\n\nstatic struct atmel_nand *atmel_nand_create(struct atmel_nand_controller *nc,\n\t\t\t\t\t    struct device_node *np,\n\t\t\t\t\t    int reg_cells)\n{\n\tstruct atmel_nand *nand;\n\tstruct gpio_desc *gpio;\n\tint numcs, ret, i;\n\n\tnumcs = of_property_count_elems_of_size(np, \"reg\",\n\t\t\t\t\t\treg_cells * sizeof(u32));\n\tif (numcs < 1) {\n\t\tdev_err(nc->dev, \"Missing or invalid reg property\\n\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tnand = devm_kzalloc(nc->dev, struct_size(nand, cs, numcs), GFP_KERNEL);\n\tif (!nand)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tnand->numcs = numcs;\n\n\tgpio = devm_fwnode_gpiod_get(nc->dev, of_fwnode_handle(np),\n\t\t\t\t     \"det\", GPIOD_IN, \"nand-det\");\n\tif (IS_ERR(gpio) && PTR_ERR(gpio) != -ENOENT) {\n\t\tdev_err(nc->dev,\n\t\t\t\"Failed to get detect gpio (err = %ld)\\n\",\n\t\t\tPTR_ERR(gpio));\n\t\treturn ERR_CAST(gpio);\n\t}\n\n\tif (!IS_ERR(gpio))\n\t\tnand->cdgpio = gpio;\n\n\tfor (i = 0; i < numcs; i++) {\n\t\tstruct resource res;\n\t\tu32 val;\n\n\t\tret = of_address_to_resource(np, 0, &res);\n\t\tif (ret) {\n\t\t\tdev_err(nc->dev, \"Invalid reg property (err = %d)\\n\",\n\t\t\t\tret);\n\t\t\treturn ERR_PTR(ret);\n\t\t}\n\n\t\tret = of_property_read_u32_index(np, \"reg\", i * reg_cells,\n\t\t\t\t\t\t &val);\n\t\tif (ret) {\n\t\t\tdev_err(nc->dev, \"Invalid reg property (err = %d)\\n\",\n\t\t\t\tret);\n\t\t\treturn ERR_PTR(ret);\n\t\t}\n\n\t\tnand->cs[i].id = val;\n\n\t\tnand->cs[i].io.dma = res.start;\n\t\tnand->cs[i].io.virt = devm_ioremap_resource(nc->dev, &res);\n\t\tif (IS_ERR(nand->cs[i].io.virt))\n\t\t\treturn ERR_CAST(nand->cs[i].io.virt);\n\n\t\tif (!of_property_read_u32(np, \"atmel,rb\", &val)) {\n\t\t\tif (val > ATMEL_NFC_MAX_RB_ID)\n\t\t\t\treturn ERR_PTR(-EINVAL);\n\n\t\t\tnand->cs[i].rb.type = ATMEL_NAND_NATIVE_RB;\n\t\t\tnand->cs[i].rb.id = val;\n\t\t} else {\n\t\t\tgpio = devm_fwnode_gpiod_get_index(nc->dev,\n\t\t\t\t\t\t\t   of_fwnode_handle(np),\n\t\t\t\t\t\t\t   \"rb\", i, GPIOD_IN,\n\t\t\t\t\t\t\t   \"nand-rb\");\n\t\t\tif (IS_ERR(gpio) && PTR_ERR(gpio) != -ENOENT) {\n\t\t\t\tdev_err(nc->dev,\n\t\t\t\t\t\"Failed to get R/B gpio (err = %ld)\\n\",\n\t\t\t\t\tPTR_ERR(gpio));\n\t\t\t\treturn ERR_CAST(gpio);\n\t\t\t}\n\n\t\t\tif (!IS_ERR(gpio)) {\n\t\t\t\tnand->cs[i].rb.type = ATMEL_NAND_GPIO_RB;\n\t\t\t\tnand->cs[i].rb.gpio = gpio;\n\t\t\t}\n\t\t}\n\n\t\tgpio = devm_fwnode_gpiod_get_index(nc->dev,\n\t\t\t\t\t\t   of_fwnode_handle(np),\n\t\t\t\t\t\t   \"cs\", i, GPIOD_OUT_HIGH,\n\t\t\t\t\t\t   \"nand-cs\");\n\t\tif (IS_ERR(gpio) && PTR_ERR(gpio) != -ENOENT) {\n\t\t\tdev_err(nc->dev,\n\t\t\t\t\"Failed to get CS gpio (err = %ld)\\n\",\n\t\t\t\tPTR_ERR(gpio));\n\t\t\treturn ERR_CAST(gpio);\n\t\t}\n\n\t\tif (!IS_ERR(gpio))\n\t\t\tnand->cs[i].csgpio = gpio;\n\t}\n\n\tnand_set_flash_node(&nand->base, np);\n\n\treturn nand;\n}\n\nstatic int\natmel_nand_controller_add_nand(struct atmel_nand_controller *nc,\n\t\t\t       struct atmel_nand *nand)\n{\n\tstruct nand_chip *chip = &nand->base;\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tint ret;\n\n\t \n\tif (nand->cdgpio && gpiod_get_value(nand->cdgpio)) {\n\t\tdev_info(nc->dev, \"No SmartMedia card inserted.\\n\");\n\t\treturn 0;\n\t}\n\n\tnc->caps->ops->nand_init(nc, nand);\n\n\tret = nand_scan(chip, nand->numcs);\n\tif (ret) {\n\t\tdev_err(nc->dev, \"NAND scan failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = mtd_device_register(mtd, NULL, 0);\n\tif (ret) {\n\t\tdev_err(nc->dev, \"Failed to register mtd device: %d\\n\", ret);\n\t\tnand_cleanup(chip);\n\t\treturn ret;\n\t}\n\n\tlist_add_tail(&nand->node, &nc->chips);\n\n\treturn 0;\n}\n\nstatic int\natmel_nand_controller_remove_nands(struct atmel_nand_controller *nc)\n{\n\tstruct atmel_nand *nand, *tmp;\n\tint ret;\n\n\tlist_for_each_entry_safe(nand, tmp, &nc->chips, node) {\n\t\tret = atmel_nand_controller_remove_nand(nand);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int\natmel_nand_controller_legacy_add_nands(struct atmel_nand_controller *nc)\n{\n\tstruct device *dev = nc->dev;\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tstruct atmel_nand *nand;\n\tstruct gpio_desc *gpio;\n\tstruct resource *res;\n\n\t \n\tnand = devm_kzalloc(nc->dev, sizeof(*nand) + sizeof(*nand->cs),\n\t\t\t    GFP_KERNEL);\n\tif (!nand)\n\t\treturn -ENOMEM;\n\n\tnand->numcs = 1;\n\n\tnand->cs[0].io.virt = devm_platform_get_and_ioremap_resource(pdev, 0, &res);\n\tif (IS_ERR(nand->cs[0].io.virt))\n\t\treturn PTR_ERR(nand->cs[0].io.virt);\n\n\tnand->cs[0].io.dma = res->start;\n\n\t \n\tnand->cs[0].id = 3;\n\n\t \n\tgpio = devm_gpiod_get_index_optional(dev, NULL, 0,  GPIOD_IN);\n\tif (IS_ERR(gpio)) {\n\t\tdev_err(dev, \"Failed to get R/B gpio (err = %ld)\\n\",\n\t\t\tPTR_ERR(gpio));\n\t\treturn PTR_ERR(gpio);\n\t}\n\n\tif (gpio) {\n\t\tnand->cs[0].rb.type = ATMEL_NAND_GPIO_RB;\n\t\tnand->cs[0].rb.gpio = gpio;\n\t}\n\n\t \n\tgpio = devm_gpiod_get_index_optional(dev, NULL, 1, GPIOD_OUT_HIGH);\n\tif (IS_ERR(gpio)) {\n\t\tdev_err(dev, \"Failed to get CS gpio (err = %ld)\\n\",\n\t\t\tPTR_ERR(gpio));\n\t\treturn PTR_ERR(gpio);\n\t}\n\n\tnand->cs[0].csgpio = gpio;\n\n\t \n\tgpio = devm_gpiod_get_index_optional(nc->dev, NULL, 2, GPIOD_IN);\n\tif (IS_ERR(gpio)) {\n\t\tdev_err(dev,\n\t\t\t\"Failed to get detect gpio (err = %ld)\\n\",\n\t\t\tPTR_ERR(gpio));\n\t\treturn PTR_ERR(gpio);\n\t}\n\n\tnand->cdgpio = gpio;\n\n\tnand_set_flash_node(&nand->base, nc->dev->of_node);\n\n\treturn atmel_nand_controller_add_nand(nc, nand);\n}\n\nstatic int atmel_nand_controller_add_nands(struct atmel_nand_controller *nc)\n{\n\tstruct device_node *np, *nand_np;\n\tstruct device *dev = nc->dev;\n\tint ret, reg_cells;\n\tu32 val;\n\n\t \n\tif (nc->caps->legacy_of_bindings)\n\t\treturn atmel_nand_controller_legacy_add_nands(nc);\n\n\tnp = dev->of_node;\n\n\tret = of_property_read_u32(np, \"#address-cells\", &val);\n\tif (ret) {\n\t\tdev_err(dev, \"missing #address-cells property\\n\");\n\t\treturn ret;\n\t}\n\n\treg_cells = val;\n\n\tret = of_property_read_u32(np, \"#size-cells\", &val);\n\tif (ret) {\n\t\tdev_err(dev, \"missing #size-cells property\\n\");\n\t\treturn ret;\n\t}\n\n\treg_cells += val;\n\n\tfor_each_child_of_node(np, nand_np) {\n\t\tstruct atmel_nand *nand;\n\n\t\tnand = atmel_nand_create(nc, nand_np, reg_cells);\n\t\tif (IS_ERR(nand)) {\n\t\t\tret = PTR_ERR(nand);\n\t\t\tgoto err;\n\t\t}\n\n\t\tret = atmel_nand_controller_add_nand(nc, nand);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\treturn 0;\n\nerr:\n\tatmel_nand_controller_remove_nands(nc);\n\n\treturn ret;\n}\n\nstatic void atmel_nand_controller_cleanup(struct atmel_nand_controller *nc)\n{\n\tif (nc->dmac)\n\t\tdma_release_channel(nc->dmac);\n\n\tclk_put(nc->mck);\n}\n\nstatic const struct atmel_smc_nand_ebi_csa_cfg at91sam9260_ebi_csa = {\n\t.offs = AT91SAM9260_MATRIX_EBICSA,\n};\n\nstatic const struct atmel_smc_nand_ebi_csa_cfg at91sam9261_ebi_csa = {\n\t.offs = AT91SAM9261_MATRIX_EBICSA,\n};\n\nstatic const struct atmel_smc_nand_ebi_csa_cfg at91sam9263_ebi_csa = {\n\t.offs = AT91SAM9263_MATRIX_EBI0CSA,\n};\n\nstatic const struct atmel_smc_nand_ebi_csa_cfg at91sam9rl_ebi_csa = {\n\t.offs = AT91SAM9RL_MATRIX_EBICSA,\n};\n\nstatic const struct atmel_smc_nand_ebi_csa_cfg at91sam9g45_ebi_csa = {\n\t.offs = AT91SAM9G45_MATRIX_EBICSA,\n};\n\nstatic const struct atmel_smc_nand_ebi_csa_cfg at91sam9n12_ebi_csa = {\n\t.offs = AT91SAM9N12_MATRIX_EBICSA,\n};\n\nstatic const struct atmel_smc_nand_ebi_csa_cfg at91sam9x5_ebi_csa = {\n\t.offs = AT91SAM9X5_MATRIX_EBICSA,\n};\n\nstatic const struct atmel_smc_nand_ebi_csa_cfg sam9x60_ebi_csa = {\n\t.offs = AT91_SFR_CCFG_EBICSA,\n\t.nfd0_on_d16 = AT91_SFR_CCFG_NFD0_ON_D16,\n};\n\nstatic const struct of_device_id __maybe_unused atmel_ebi_csa_regmap_of_ids[] = {\n\t{\n\t\t.compatible = \"atmel,at91sam9260-matrix\",\n\t\t.data = &at91sam9260_ebi_csa,\n\t},\n\t{\n\t\t.compatible = \"atmel,at91sam9261-matrix\",\n\t\t.data = &at91sam9261_ebi_csa,\n\t},\n\t{\n\t\t.compatible = \"atmel,at91sam9263-matrix\",\n\t\t.data = &at91sam9263_ebi_csa,\n\t},\n\t{\n\t\t.compatible = \"atmel,at91sam9rl-matrix\",\n\t\t.data = &at91sam9rl_ebi_csa,\n\t},\n\t{\n\t\t.compatible = \"atmel,at91sam9g45-matrix\",\n\t\t.data = &at91sam9g45_ebi_csa,\n\t},\n\t{\n\t\t.compatible = \"atmel,at91sam9n12-matrix\",\n\t\t.data = &at91sam9n12_ebi_csa,\n\t},\n\t{\n\t\t.compatible = \"atmel,at91sam9x5-matrix\",\n\t\t.data = &at91sam9x5_ebi_csa,\n\t},\n\t{\n\t\t.compatible = \"microchip,sam9x60-sfr\",\n\t\t.data = &sam9x60_ebi_csa,\n\t},\n\t{   },\n};\n\nstatic int atmel_nand_attach_chip(struct nand_chip *chip)\n{\n\tstruct atmel_nand_controller *nc = to_nand_controller(chip->controller);\n\tstruct atmel_nand *nand = to_atmel_nand(chip);\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tint ret;\n\n\tret = nc->caps->ops->ecc_init(chip);\n\tif (ret)\n\t\treturn ret;\n\n\tif (nc->caps->legacy_of_bindings || !nc->dev->of_node) {\n\t\t \n\t\tmtd->name = \"atmel_nand\";\n\t} else if (!mtd->name) {\n\t\t \n\t\tmtd->name = devm_kasprintf(nc->dev, GFP_KERNEL,\n\t\t\t\t\t   \"%s:nand.%d\", dev_name(nc->dev),\n\t\t\t\t\t   nand->cs[0].id);\n\t\tif (!mtd->name) {\n\t\t\tdev_err(nc->dev, \"Failed to allocate mtd->name\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic const struct nand_controller_ops atmel_nand_controller_ops = {\n\t.attach_chip = atmel_nand_attach_chip,\n\t.setup_interface = atmel_nand_setup_interface,\n\t.exec_op = atmel_nand_exec_op,\n};\n\nstatic int atmel_nand_controller_init(struct atmel_nand_controller *nc,\n\t\t\t\tstruct platform_device *pdev,\n\t\t\t\tconst struct atmel_nand_controller_caps *caps)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np = dev->of_node;\n\tint ret;\n\n\tnand_controller_init(&nc->base);\n\tnc->base.ops = &atmel_nand_controller_ops;\n\tINIT_LIST_HEAD(&nc->chips);\n\tnc->dev = dev;\n\tnc->caps = caps;\n\n\tplatform_set_drvdata(pdev, nc);\n\n\tnc->pmecc = devm_atmel_pmecc_get(dev);\n\tif (IS_ERR(nc->pmecc))\n\t\treturn dev_err_probe(dev, PTR_ERR(nc->pmecc),\n\t\t\t\t     \"Could not get PMECC object\\n\");\n\n\tif (nc->caps->has_dma && !atmel_nand_avoid_dma) {\n\t\tdma_cap_mask_t mask;\n\n\t\tdma_cap_zero(mask);\n\t\tdma_cap_set(DMA_MEMCPY, mask);\n\n\t\tnc->dmac = dma_request_channel(mask, NULL, NULL);\n\t\tif (!nc->dmac)\n\t\t\tdev_err(nc->dev, \"Failed to request DMA channel\\n\");\n\t}\n\n\t \n\tif (nc->caps->legacy_of_bindings)\n\t\treturn 0;\n\n\tnc->mck = of_clk_get(dev->parent->of_node, 0);\n\tif (IS_ERR(nc->mck)) {\n\t\tdev_err(dev, \"Failed to retrieve MCK clk\\n\");\n\t\tret = PTR_ERR(nc->mck);\n\t\tgoto out_release_dma;\n\t}\n\n\tnp = of_parse_phandle(dev->parent->of_node, \"atmel,smc\", 0);\n\tif (!np) {\n\t\tdev_err(dev, \"Missing or invalid atmel,smc property\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out_release_dma;\n\t}\n\n\tnc->smc = syscon_node_to_regmap(np);\n\tof_node_put(np);\n\tif (IS_ERR(nc->smc)) {\n\t\tret = PTR_ERR(nc->smc);\n\t\tdev_err(dev, \"Could not get SMC regmap (err = %d)\\n\", ret);\n\t\tgoto out_release_dma;\n\t}\n\n\treturn 0;\n\nout_release_dma:\n\tif (nc->dmac)\n\t\tdma_release_channel(nc->dmac);\n\n\treturn ret;\n}\n\nstatic int\natmel_smc_nand_controller_init(struct atmel_smc_nand_controller *nc)\n{\n\tstruct device *dev = nc->base.dev;\n\tconst struct of_device_id *match;\n\tstruct device_node *np;\n\tint ret;\n\n\t \n\tif (nc->base.caps->legacy_of_bindings)\n\t\treturn 0;\n\n\tnp = of_parse_phandle(dev->parent->of_node,\n\t\t\t      nc->base.caps->ebi_csa_regmap_name, 0);\n\tif (!np)\n\t\treturn 0;\n\n\tmatch = of_match_node(atmel_ebi_csa_regmap_of_ids, np);\n\tif (!match) {\n\t\tof_node_put(np);\n\t\treturn 0;\n\t}\n\n\tnc->ebi_csa_regmap = syscon_node_to_regmap(np);\n\tof_node_put(np);\n\tif (IS_ERR(nc->ebi_csa_regmap)) {\n\t\tret = PTR_ERR(nc->ebi_csa_regmap);\n\t\tdev_err(dev, \"Could not get EBICSA regmap (err = %d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tnc->ebi_csa = (struct atmel_smc_nand_ebi_csa_cfg *)match->data;\n\n\t \n\tif (of_device_is_compatible(dev->parent->of_node,\n\t\t\t\t    \"atmel,at91sam9263-ebi1\"))\n\t\tnc->ebi_csa->offs += 4;\n\n\treturn 0;\n}\n\nstatic int\natmel_hsmc_nand_controller_legacy_init(struct atmel_hsmc_nand_controller *nc)\n{\n\tstruct regmap_config regmap_conf = {\n\t\t.reg_bits = 32,\n\t\t.val_bits = 32,\n\t\t.reg_stride = 4,\n\t};\n\n\tstruct device *dev = nc->base.dev;\n\tstruct device_node *nand_np, *nfc_np;\n\tvoid __iomem *iomem;\n\tstruct resource res;\n\tint ret;\n\n\tnand_np = dev->of_node;\n\tnfc_np = of_get_compatible_child(dev->of_node, \"atmel,sama5d3-nfc\");\n\tif (!nfc_np) {\n\t\tdev_err(dev, \"Could not find device node for sama5d3-nfc\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tnc->clk = of_clk_get(nfc_np, 0);\n\tif (IS_ERR(nc->clk)) {\n\t\tret = PTR_ERR(nc->clk);\n\t\tdev_err(dev, \"Failed to retrieve HSMC clock (err = %d)\\n\",\n\t\t\tret);\n\t\tgoto out;\n\t}\n\n\tret = clk_prepare_enable(nc->clk);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to enable the HSMC clock (err = %d)\\n\",\n\t\t\tret);\n\t\tgoto out;\n\t}\n\n\tnc->irq = of_irq_get(nand_np, 0);\n\tif (nc->irq <= 0) {\n\t\tret = nc->irq ?: -ENXIO;\n\t\tif (ret != -EPROBE_DEFER)\n\t\t\tdev_err(dev, \"Failed to get IRQ number (err = %d)\\n\",\n\t\t\t\tret);\n\t\tgoto out;\n\t}\n\n\tret = of_address_to_resource(nfc_np, 0, &res);\n\tif (ret) {\n\t\tdev_err(dev, \"Invalid or missing NFC IO resource (err = %d)\\n\",\n\t\t\tret);\n\t\tgoto out;\n\t}\n\n\tiomem = devm_ioremap_resource(dev, &res);\n\tif (IS_ERR(iomem)) {\n\t\tret = PTR_ERR(iomem);\n\t\tgoto out;\n\t}\n\n\tregmap_conf.name = \"nfc-io\";\n\tregmap_conf.max_register = resource_size(&res) - 4;\n\tnc->io = devm_regmap_init_mmio(dev, iomem, &regmap_conf);\n\tif (IS_ERR(nc->io)) {\n\t\tret = PTR_ERR(nc->io);\n\t\tdev_err(dev, \"Could not create NFC IO regmap (err = %d)\\n\",\n\t\t\tret);\n\t\tgoto out;\n\t}\n\n\tret = of_address_to_resource(nfc_np, 1, &res);\n\tif (ret) {\n\t\tdev_err(dev, \"Invalid or missing HSMC resource (err = %d)\\n\",\n\t\t\tret);\n\t\tgoto out;\n\t}\n\n\tiomem = devm_ioremap_resource(dev, &res);\n\tif (IS_ERR(iomem)) {\n\t\tret = PTR_ERR(iomem);\n\t\tgoto out;\n\t}\n\n\tregmap_conf.name = \"smc\";\n\tregmap_conf.max_register = resource_size(&res) - 4;\n\tnc->base.smc = devm_regmap_init_mmio(dev, iomem, &regmap_conf);\n\tif (IS_ERR(nc->base.smc)) {\n\t\tret = PTR_ERR(nc->base.smc);\n\t\tdev_err(dev, \"Could not create NFC IO regmap (err = %d)\\n\",\n\t\t\tret);\n\t\tgoto out;\n\t}\n\n\tret = of_address_to_resource(nfc_np, 2, &res);\n\tif (ret) {\n\t\tdev_err(dev, \"Invalid or missing SRAM resource (err = %d)\\n\",\n\t\t\tret);\n\t\tgoto out;\n\t}\n\n\tnc->sram.virt = devm_ioremap_resource(dev, &res);\n\tif (IS_ERR(nc->sram.virt)) {\n\t\tret = PTR_ERR(nc->sram.virt);\n\t\tgoto out;\n\t}\n\n\tnc->sram.dma = res.start;\n\nout:\n\tof_node_put(nfc_np);\n\n\treturn ret;\n}\n\nstatic int\natmel_hsmc_nand_controller_init(struct atmel_hsmc_nand_controller *nc)\n{\n\tstruct device *dev = nc->base.dev;\n\tstruct device_node *np;\n\tint ret;\n\n\tnp = of_parse_phandle(dev->parent->of_node, \"atmel,smc\", 0);\n\tif (!np) {\n\t\tdev_err(dev, \"Missing or invalid atmel,smc property\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tnc->hsmc_layout = atmel_hsmc_get_reg_layout(np);\n\n\tnc->irq = of_irq_get(np, 0);\n\tof_node_put(np);\n\tif (nc->irq <= 0) {\n\t\tret = nc->irq ?: -ENXIO;\n\t\tif (ret != -EPROBE_DEFER)\n\t\t\tdev_err(dev, \"Failed to get IRQ number (err = %d)\\n\",\n\t\t\t\tret);\n\t\treturn ret;\n\t}\n\n\tnp = of_parse_phandle(dev->of_node, \"atmel,nfc-io\", 0);\n\tif (!np) {\n\t\tdev_err(dev, \"Missing or invalid atmel,nfc-io property\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tnc->io = syscon_node_to_regmap(np);\n\tof_node_put(np);\n\tif (IS_ERR(nc->io)) {\n\t\tret = PTR_ERR(nc->io);\n\t\tdev_err(dev, \"Could not get NFC IO regmap (err = %d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tnc->sram.pool = of_gen_pool_get(nc->base.dev->of_node,\n\t\t\t\t\t \"atmel,nfc-sram\", 0);\n\tif (!nc->sram.pool) {\n\t\tdev_err(nc->base.dev, \"Missing SRAM\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tnc->sram.virt = (void __iomem *)gen_pool_dma_alloc(nc->sram.pool,\n\t\t\t\t\t\t\t   ATMEL_NFC_SRAM_SIZE,\n\t\t\t\t\t\t\t   &nc->sram.dma);\n\tif (!nc->sram.virt) {\n\t\tdev_err(nc->base.dev,\n\t\t\t\"Could not allocate memory from the NFC SRAM pool\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\nstatic int\natmel_hsmc_nand_controller_remove(struct atmel_nand_controller *nc)\n{\n\tstruct atmel_hsmc_nand_controller *hsmc_nc;\n\tint ret;\n\n\tret = atmel_nand_controller_remove_nands(nc);\n\tif (ret)\n\t\treturn ret;\n\n\thsmc_nc = container_of(nc, struct atmel_hsmc_nand_controller, base);\n\tregmap_write(hsmc_nc->base.smc, ATMEL_HSMC_NFC_CTRL,\n\t\t     ATMEL_HSMC_NFC_CTRL_DIS);\n\n\tif (hsmc_nc->sram.pool)\n\t\tgen_pool_free(hsmc_nc->sram.pool,\n\t\t\t      (unsigned long)hsmc_nc->sram.virt,\n\t\t\t      ATMEL_NFC_SRAM_SIZE);\n\n\tif (hsmc_nc->clk) {\n\t\tclk_disable_unprepare(hsmc_nc->clk);\n\t\tclk_put(hsmc_nc->clk);\n\t}\n\n\tatmel_nand_controller_cleanup(nc);\n\n\treturn 0;\n}\n\nstatic int atmel_hsmc_nand_controller_probe(struct platform_device *pdev,\n\t\t\t\tconst struct atmel_nand_controller_caps *caps)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct atmel_hsmc_nand_controller *nc;\n\tint ret;\n\n\tnc = devm_kzalloc(dev, sizeof(*nc), GFP_KERNEL);\n\tif (!nc)\n\t\treturn -ENOMEM;\n\n\tret = atmel_nand_controller_init(&nc->base, pdev, caps);\n\tif (ret)\n\t\treturn ret;\n\n\tif (caps->legacy_of_bindings)\n\t\tret = atmel_hsmc_nand_controller_legacy_init(nc);\n\telse\n\t\tret = atmel_hsmc_nand_controller_init(nc);\n\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tregmap_write(nc->base.smc, ATMEL_HSMC_NFC_IDR, 0xffffffff);\n\tret = devm_request_irq(dev, nc->irq, atmel_nfc_interrupt,\n\t\t\t       IRQF_SHARED, \"nfc\", nc);\n\tif (ret) {\n\t\tdev_err(dev,\n\t\t\t\"Could not get register NFC interrupt handler (err = %d)\\n\",\n\t\t\tret);\n\t\tgoto err;\n\t}\n\n\t \n\tregmap_write(nc->base.smc, ATMEL_HSMC_NFC_CFG,\n\t\t     ATMEL_HSMC_NFC_CFG_DTO_MAX);\n\tregmap_write(nc->base.smc, ATMEL_HSMC_NFC_CTRL,\n\t\t     ATMEL_HSMC_NFC_CTRL_EN);\n\n\tret = atmel_nand_controller_add_nands(&nc->base);\n\tif (ret)\n\t\tgoto err;\n\n\treturn 0;\n\nerr:\n\tatmel_hsmc_nand_controller_remove(&nc->base);\n\n\treturn ret;\n}\n\nstatic const struct atmel_nand_controller_ops atmel_hsmc_nc_ops = {\n\t.probe = atmel_hsmc_nand_controller_probe,\n\t.remove = atmel_hsmc_nand_controller_remove,\n\t.ecc_init = atmel_hsmc_nand_ecc_init,\n\t.nand_init = atmel_nand_init,\n\t.setup_interface = atmel_hsmc_nand_setup_interface,\n\t.exec_op = atmel_hsmc_nand_exec_op,\n};\n\nstatic const struct atmel_nand_controller_caps atmel_sama5_nc_caps = {\n\t.has_dma = true,\n\t.ale_offs = BIT(21),\n\t.cle_offs = BIT(22),\n\t.ops = &atmel_hsmc_nc_ops,\n};\n\n \nstatic const struct atmel_nand_controller_caps atmel_sama5_nand_caps = {\n\t.has_dma = true,\n\t.ale_offs = BIT(21),\n\t.cle_offs = BIT(22),\n\t.ops = &atmel_hsmc_nc_ops,\n\t.legacy_of_bindings = true,\n};\n\nstatic int atmel_smc_nand_controller_probe(struct platform_device *pdev,\n\t\t\t\tconst struct atmel_nand_controller_caps *caps)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct atmel_smc_nand_controller *nc;\n\tint ret;\n\n\tnc = devm_kzalloc(dev, sizeof(*nc), GFP_KERNEL);\n\tif (!nc)\n\t\treturn -ENOMEM;\n\n\tret = atmel_nand_controller_init(&nc->base, pdev, caps);\n\tif (ret)\n\t\treturn ret;\n\n\tret = atmel_smc_nand_controller_init(nc);\n\tif (ret)\n\t\treturn ret;\n\n\treturn atmel_nand_controller_add_nands(&nc->base);\n}\n\nstatic int\natmel_smc_nand_controller_remove(struct atmel_nand_controller *nc)\n{\n\tint ret;\n\n\tret = atmel_nand_controller_remove_nands(nc);\n\tif (ret)\n\t\treturn ret;\n\n\tatmel_nand_controller_cleanup(nc);\n\n\treturn 0;\n}\n\n \nstatic const struct atmel_nand_controller_ops at91rm9200_nc_ops = {\n\t.probe = atmel_smc_nand_controller_probe,\n\t.remove = atmel_smc_nand_controller_remove,\n\t.ecc_init = atmel_nand_ecc_init,\n\t.nand_init = atmel_smc_nand_init,\n\t.exec_op = atmel_smc_nand_exec_op,\n};\n\nstatic const struct atmel_nand_controller_caps atmel_rm9200_nc_caps = {\n\t.ale_offs = BIT(21),\n\t.cle_offs = BIT(22),\n\t.ebi_csa_regmap_name = \"atmel,matrix\",\n\t.ops = &at91rm9200_nc_ops,\n};\n\nstatic const struct atmel_nand_controller_ops atmel_smc_nc_ops = {\n\t.probe = atmel_smc_nand_controller_probe,\n\t.remove = atmel_smc_nand_controller_remove,\n\t.ecc_init = atmel_nand_ecc_init,\n\t.nand_init = atmel_smc_nand_init,\n\t.setup_interface = atmel_smc_nand_setup_interface,\n\t.exec_op = atmel_smc_nand_exec_op,\n};\n\nstatic const struct atmel_nand_controller_caps atmel_sam9260_nc_caps = {\n\t.ale_offs = BIT(21),\n\t.cle_offs = BIT(22),\n\t.ebi_csa_regmap_name = \"atmel,matrix\",\n\t.ops = &atmel_smc_nc_ops,\n};\n\nstatic const struct atmel_nand_controller_caps atmel_sam9261_nc_caps = {\n\t.ale_offs = BIT(22),\n\t.cle_offs = BIT(21),\n\t.ebi_csa_regmap_name = \"atmel,matrix\",\n\t.ops = &atmel_smc_nc_ops,\n};\n\nstatic const struct atmel_nand_controller_caps atmel_sam9g45_nc_caps = {\n\t.has_dma = true,\n\t.ale_offs = BIT(21),\n\t.cle_offs = BIT(22),\n\t.ebi_csa_regmap_name = \"atmel,matrix\",\n\t.ops = &atmel_smc_nc_ops,\n};\n\nstatic const struct atmel_nand_controller_caps microchip_sam9x60_nc_caps = {\n\t.has_dma = true,\n\t.ale_offs = BIT(21),\n\t.cle_offs = BIT(22),\n\t.ebi_csa_regmap_name = \"microchip,sfr\",\n\t.ops = &atmel_smc_nc_ops,\n};\n\n \nstatic const struct atmel_nand_controller_caps atmel_rm9200_nand_caps = {\n\t.ale_offs = BIT(21),\n\t.cle_offs = BIT(22),\n\t.ops = &atmel_smc_nc_ops,\n\t.legacy_of_bindings = true,\n};\n\nstatic const struct atmel_nand_controller_caps atmel_sam9261_nand_caps = {\n\t.ale_offs = BIT(22),\n\t.cle_offs = BIT(21),\n\t.ops = &atmel_smc_nc_ops,\n\t.legacy_of_bindings = true,\n};\n\nstatic const struct atmel_nand_controller_caps atmel_sam9g45_nand_caps = {\n\t.has_dma = true,\n\t.ale_offs = BIT(21),\n\t.cle_offs = BIT(22),\n\t.ops = &atmel_smc_nc_ops,\n\t.legacy_of_bindings = true,\n};\n\nstatic const struct of_device_id atmel_nand_controller_of_ids[] = {\n\t{\n\t\t.compatible = \"atmel,at91rm9200-nand-controller\",\n\t\t.data = &atmel_rm9200_nc_caps,\n\t},\n\t{\n\t\t.compatible = \"atmel,at91sam9260-nand-controller\",\n\t\t.data = &atmel_sam9260_nc_caps,\n\t},\n\t{\n\t\t.compatible = \"atmel,at91sam9261-nand-controller\",\n\t\t.data = &atmel_sam9261_nc_caps,\n\t},\n\t{\n\t\t.compatible = \"atmel,at91sam9g45-nand-controller\",\n\t\t.data = &atmel_sam9g45_nc_caps,\n\t},\n\t{\n\t\t.compatible = \"atmel,sama5d3-nand-controller\",\n\t\t.data = &atmel_sama5_nc_caps,\n\t},\n\t{\n\t\t.compatible = \"microchip,sam9x60-nand-controller\",\n\t\t.data = &microchip_sam9x60_nc_caps,\n\t},\n\t \n\t{\n\t\t.compatible = \"atmel,at91rm9200-nand\",\n\t\t.data = &atmel_rm9200_nand_caps,\n\t},\n\t{\n\t\t.compatible = \"atmel,sama5d4-nand\",\n\t\t.data = &atmel_rm9200_nand_caps,\n\t},\n\t{\n\t\t.compatible = \"atmel,sama5d2-nand\",\n\t\t.data = &atmel_rm9200_nand_caps,\n\t},\n\t{   },\n};\nMODULE_DEVICE_TABLE(of, atmel_nand_controller_of_ids);\n\nstatic int atmel_nand_controller_probe(struct platform_device *pdev)\n{\n\tconst struct atmel_nand_controller_caps *caps;\n\n\tif (pdev->id_entry)\n\t\tcaps = (void *)pdev->id_entry->driver_data;\n\telse\n\t\tcaps = of_device_get_match_data(&pdev->dev);\n\n\tif (!caps) {\n\t\tdev_err(&pdev->dev, \"Could not retrieve NFC caps\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (caps->legacy_of_bindings) {\n\t\tstruct device_node *nfc_node;\n\t\tu32 ale_offs = 21;\n\n\t\t \n\t\tnfc_node = of_get_compatible_child(pdev->dev.of_node,\n\t\t\t\t\t\t   \"atmel,sama5d3-nfc\");\n\t\tif (nfc_node) {\n\t\t\tcaps = &atmel_sama5_nand_caps;\n\t\t\tof_node_put(nfc_node);\n\t\t}\n\n\t\t \n\t\tif (!caps->has_dma &&\n\t\t    of_property_read_bool(pdev->dev.of_node,\n\t\t\t\t\t  \"atmel,nand-has-dma\"))\n\t\t\tcaps = &atmel_sam9g45_nand_caps;\n\n\t\t \n\t\tof_property_read_u32(pdev->dev.of_node,\n\t\t\t\t     \"atmel,nand-addr-offset\", &ale_offs);\n\t\tif (ale_offs != 21)\n\t\t\tcaps = &atmel_sam9261_nand_caps;\n\t}\n\n\treturn caps->ops->probe(pdev, caps);\n}\n\nstatic void atmel_nand_controller_remove(struct platform_device *pdev)\n{\n\tstruct atmel_nand_controller *nc = platform_get_drvdata(pdev);\n\n\tWARN_ON(nc->caps->ops->remove(nc));\n}\n\nstatic __maybe_unused int atmel_nand_controller_resume(struct device *dev)\n{\n\tstruct atmel_nand_controller *nc = dev_get_drvdata(dev);\n\tstruct atmel_nand *nand;\n\n\tif (nc->pmecc)\n\t\tatmel_pmecc_reset(nc->pmecc);\n\n\tlist_for_each_entry(nand, &nc->chips, node) {\n\t\tint i;\n\n\t\tfor (i = 0; i < nand->numcs; i++)\n\t\t\tnand_reset(&nand->base, i);\n\t}\n\n\treturn 0;\n}\n\nstatic SIMPLE_DEV_PM_OPS(atmel_nand_controller_pm_ops, NULL,\n\t\t\t atmel_nand_controller_resume);\n\nstatic struct platform_driver atmel_nand_controller_driver = {\n\t.driver = {\n\t\t.name = \"atmel-nand-controller\",\n\t\t.of_match_table = atmel_nand_controller_of_ids,\n\t\t.pm = &atmel_nand_controller_pm_ops,\n\t},\n\t.probe = atmel_nand_controller_probe,\n\t.remove_new = atmel_nand_controller_remove,\n};\nmodule_platform_driver(atmel_nand_controller_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Boris Brezillon <boris.brezillon@free-electrons.com>\");\nMODULE_DESCRIPTION(\"NAND Flash Controller driver for Atmel SoCs\");\nMODULE_ALIAS(\"platform:atmel-nand-controller\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}