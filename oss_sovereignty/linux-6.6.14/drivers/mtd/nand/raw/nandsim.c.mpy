{
  "module_name": "nandsim.c",
  "hash_id": "10f889b1542b5b8c4cb9319611d3b499539c8969df7b9ca8bcee5c57527e1df7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/nand/raw/nandsim.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt)  \"[nandsim]\" fmt\n\n#include <linux/init.h>\n#include <linux/types.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/vmalloc.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/mtd/mtd.h>\n#include <linux/mtd/rawnand.h>\n#include <linux/mtd/partitions.h>\n#include <linux/delay.h>\n#include <linux/list.h>\n#include <linux/random.h>\n#include <linux/sched.h>\n#include <linux/sched/mm.h>\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n\n \n#if !defined(CONFIG_NANDSIM_FIRST_ID_BYTE)  || \\\n    !defined(CONFIG_NANDSIM_SECOND_ID_BYTE) || \\\n    !defined(CONFIG_NANDSIM_THIRD_ID_BYTE)  || \\\n    !defined(CONFIG_NANDSIM_FOURTH_ID_BYTE)\n#define CONFIG_NANDSIM_FIRST_ID_BYTE  0x98\n#define CONFIG_NANDSIM_SECOND_ID_BYTE 0x39\n#define CONFIG_NANDSIM_THIRD_ID_BYTE  0xFF  \n#define CONFIG_NANDSIM_FOURTH_ID_BYTE 0xFF  \n#endif\n\n#ifndef CONFIG_NANDSIM_ACCESS_DELAY\n#define CONFIG_NANDSIM_ACCESS_DELAY 25\n#endif\n#ifndef CONFIG_NANDSIM_PROGRAMM_DELAY\n#define CONFIG_NANDSIM_PROGRAMM_DELAY 200\n#endif\n#ifndef CONFIG_NANDSIM_ERASE_DELAY\n#define CONFIG_NANDSIM_ERASE_DELAY 2\n#endif\n#ifndef CONFIG_NANDSIM_OUTPUT_CYCLE\n#define CONFIG_NANDSIM_OUTPUT_CYCLE 40\n#endif\n#ifndef CONFIG_NANDSIM_INPUT_CYCLE\n#define CONFIG_NANDSIM_INPUT_CYCLE  50\n#endif\n#ifndef CONFIG_NANDSIM_BUS_WIDTH\n#define CONFIG_NANDSIM_BUS_WIDTH  8\n#endif\n#ifndef CONFIG_NANDSIM_DO_DELAYS\n#define CONFIG_NANDSIM_DO_DELAYS  0\n#endif\n#ifndef CONFIG_NANDSIM_LOG\n#define CONFIG_NANDSIM_LOG        0\n#endif\n#ifndef CONFIG_NANDSIM_DBG\n#define CONFIG_NANDSIM_DBG        0\n#endif\n#ifndef CONFIG_NANDSIM_MAX_PARTS\n#define CONFIG_NANDSIM_MAX_PARTS  32\n#endif\n\nstatic uint access_delay   = CONFIG_NANDSIM_ACCESS_DELAY;\nstatic uint programm_delay = CONFIG_NANDSIM_PROGRAMM_DELAY;\nstatic uint erase_delay    = CONFIG_NANDSIM_ERASE_DELAY;\nstatic uint output_cycle   = CONFIG_NANDSIM_OUTPUT_CYCLE;\nstatic uint input_cycle    = CONFIG_NANDSIM_INPUT_CYCLE;\nstatic uint bus_width      = CONFIG_NANDSIM_BUS_WIDTH;\nstatic uint do_delays      = CONFIG_NANDSIM_DO_DELAYS;\nstatic uint log            = CONFIG_NANDSIM_LOG;\nstatic uint dbg            = CONFIG_NANDSIM_DBG;\nstatic unsigned long parts[CONFIG_NANDSIM_MAX_PARTS];\nstatic unsigned int parts_num;\nstatic char *badblocks = NULL;\nstatic char *weakblocks = NULL;\nstatic char *weakpages = NULL;\nstatic unsigned int bitflips = 0;\nstatic char *gravepages = NULL;\nstatic unsigned int overridesize = 0;\nstatic char *cache_file = NULL;\nstatic unsigned int bbt;\nstatic unsigned int bch;\nstatic u_char id_bytes[8] = {\n\t[0] = CONFIG_NANDSIM_FIRST_ID_BYTE,\n\t[1] = CONFIG_NANDSIM_SECOND_ID_BYTE,\n\t[2] = CONFIG_NANDSIM_THIRD_ID_BYTE,\n\t[3] = CONFIG_NANDSIM_FOURTH_ID_BYTE,\n\t[4 ... 7] = 0xFF,\n};\n\nmodule_param_array(id_bytes, byte, NULL, 0400);\nmodule_param_named(first_id_byte, id_bytes[0], byte, 0400);\nmodule_param_named(second_id_byte, id_bytes[1], byte, 0400);\nmodule_param_named(third_id_byte, id_bytes[2], byte, 0400);\nmodule_param_named(fourth_id_byte, id_bytes[3], byte, 0400);\nmodule_param(access_delay,   uint, 0400);\nmodule_param(programm_delay, uint, 0400);\nmodule_param(erase_delay,    uint, 0400);\nmodule_param(output_cycle,   uint, 0400);\nmodule_param(input_cycle,    uint, 0400);\nmodule_param(bus_width,      uint, 0400);\nmodule_param(do_delays,      uint, 0400);\nmodule_param(log,            uint, 0400);\nmodule_param(dbg,            uint, 0400);\nmodule_param_array(parts, ulong, &parts_num, 0400);\nmodule_param(badblocks,      charp, 0400);\nmodule_param(weakblocks,     charp, 0400);\nmodule_param(weakpages,      charp, 0400);\nmodule_param(bitflips,       uint, 0400);\nmodule_param(gravepages,     charp, 0400);\nmodule_param(overridesize,   uint, 0400);\nmodule_param(cache_file,     charp, 0400);\nmodule_param(bbt,\t     uint, 0400);\nmodule_param(bch,\t     uint, 0400);\n\nMODULE_PARM_DESC(id_bytes,       \"The ID bytes returned by NAND Flash 'read ID' command\");\nMODULE_PARM_DESC(first_id_byte,  \"The first byte returned by NAND Flash 'read ID' command (manufacturer ID) (obsolete)\");\nMODULE_PARM_DESC(second_id_byte, \"The second byte returned by NAND Flash 'read ID' command (chip ID) (obsolete)\");\nMODULE_PARM_DESC(third_id_byte,  \"The third byte returned by NAND Flash 'read ID' command (obsolete)\");\nMODULE_PARM_DESC(fourth_id_byte, \"The fourth byte returned by NAND Flash 'read ID' command (obsolete)\");\nMODULE_PARM_DESC(access_delay,   \"Initial page access delay (microseconds)\");\nMODULE_PARM_DESC(programm_delay, \"Page programm delay (microseconds\");\nMODULE_PARM_DESC(erase_delay,    \"Sector erase delay (milliseconds)\");\nMODULE_PARM_DESC(output_cycle,   \"Word output (from flash) time (nanoseconds)\");\nMODULE_PARM_DESC(input_cycle,    \"Word input (to flash) time (nanoseconds)\");\nMODULE_PARM_DESC(bus_width,      \"Chip's bus width (8- or 16-bit)\");\nMODULE_PARM_DESC(do_delays,      \"Simulate NAND delays using busy-waits if not zero\");\nMODULE_PARM_DESC(log,            \"Perform logging if not zero\");\nMODULE_PARM_DESC(dbg,            \"Output debug information if not zero\");\nMODULE_PARM_DESC(parts,          \"Partition sizes (in erase blocks) separated by commas\");\n \nMODULE_PARM_DESC(badblocks,      \"Erase blocks that are initially marked bad, separated by commas\");\nMODULE_PARM_DESC(weakblocks,     \"Weak erase blocks [: remaining erase cycles (defaults to 3)]\"\n\t\t\t\t \" separated by commas e.g. 113:2 means eb 113\"\n\t\t\t\t \" can be erased only twice before failing\");\nMODULE_PARM_DESC(weakpages,      \"Weak pages [: maximum writes (defaults to 3)]\"\n\t\t\t\t \" separated by commas e.g. 1401:2 means page 1401\"\n\t\t\t\t \" can be written only twice before failing\");\nMODULE_PARM_DESC(bitflips,       \"Maximum number of random bit flips per page (zero by default)\");\nMODULE_PARM_DESC(gravepages,     \"Pages that lose data [: maximum reads (defaults to 3)]\"\n\t\t\t\t \" separated by commas e.g. 1401:2 means page 1401\"\n\t\t\t\t \" can be read only twice before failing\");\nMODULE_PARM_DESC(overridesize,   \"Specifies the NAND Flash size overriding the ID bytes. \"\n\t\t\t\t \"The size is specified in erase blocks and as the exponent of a power of two\"\n\t\t\t\t \" e.g. 5 means a size of 32 erase blocks\");\nMODULE_PARM_DESC(cache_file,     \"File to use to cache nand pages instead of memory\");\nMODULE_PARM_DESC(bbt,\t\t \"0 OOB, 1 BBT with marker in OOB, 2 BBT with marker in data area\");\nMODULE_PARM_DESC(bch,\t\t \"Enable BCH ecc and set how many bits should \"\n\t\t\t\t \"be correctable in 512-byte blocks\");\n\n \n#define NS_LARGEST_PAGE_SIZE\t4096\n\n \n#define NS_LOG(args...) \\\n\tdo { if (log) pr_debug(\" log: \" args); } while(0)\n#define NS_DBG(args...) \\\n\tdo { if (dbg) pr_debug(\" debug: \" args); } while(0)\n#define NS_WARN(args...) \\\n\tdo { pr_warn(\" warning: \" args); } while(0)\n#define NS_ERR(args...) \\\n\tdo { pr_err(\" error: \" args); } while(0)\n#define NS_INFO(args...) \\\n\tdo { pr_info(\" \" args); } while(0)\n\n \n#define NS_UDELAY(us) \\\n        do { if (do_delays) udelay(us); } while(0)\n#define NS_MDELAY(us) \\\n        do { if (do_delays) mdelay(us); } while(0)\n\n \n#define NS_IS_INITIALIZED(ns) ((ns)->geom.totsz != 0)\n\n \n#define NS_STATUS_OK(ns) (NAND_STATUS_READY | (NAND_STATUS_WP * ((ns)->lines.wp == 0)))\n\n \n#define NS_STATUS_FAILED(ns) (NAND_STATUS_FAIL | NS_STATUS_OK(ns))\n\n \n#define NS_RAW_OFFSET(ns) \\\n\t(((ns)->regs.row * (ns)->geom.pgszoob) + (ns)->regs.column)\n\n \n#define NS_RAW_OFFSET_OOB(ns) (NS_RAW_OFFSET(ns) + ns->geom.pgsz)\n\n \n#define NS_PAGE_BYTE_SHIFT(ns) ((ns)->regs.column + (ns)->regs.off)\n\n \n#define STATE_CMD_READ0        0x00000001  \n#define STATE_CMD_READ1        0x00000002  \n#define STATE_CMD_READSTART    0x00000003  \n#define STATE_CMD_PAGEPROG     0x00000004  \n#define STATE_CMD_READOOB      0x00000005  \n#define STATE_CMD_ERASE1       0x00000006  \n#define STATE_CMD_STATUS       0x00000007  \n#define STATE_CMD_SEQIN        0x00000009  \n#define STATE_CMD_READID       0x0000000A  \n#define STATE_CMD_ERASE2       0x0000000B  \n#define STATE_CMD_RESET        0x0000000C  \n#define STATE_CMD_RNDOUT       0x0000000D  \n#define STATE_CMD_RNDOUTSTART  0x0000000E  \n#define STATE_CMD_MASK         0x0000000F  \n\n \n#define STATE_ADDR_PAGE        0x00000010  \n#define STATE_ADDR_SEC         0x00000020  \n#define STATE_ADDR_COLUMN      0x00000030  \n#define STATE_ADDR_ZERO        0x00000040  \n#define STATE_ADDR_MASK        0x00000070  \n\n \n#define STATE_DATAIN           0x00000100  \n#define STATE_DATAIN_MASK      0x00000100  \n\n#define STATE_DATAOUT          0x00001000  \n#define STATE_DATAOUT_ID       0x00002000  \n#define STATE_DATAOUT_STATUS   0x00003000  \n#define STATE_DATAOUT_MASK     0x00007000  \n\n \n#define STATE_READY            0x00000000\n\n \n#define STATE_UNKNOWN          0x10000000\n\n \n#define ACTION_CPY       0x00100000  \n#define ACTION_PRGPAGE   0x00200000  \n#define ACTION_SECERASE  0x00300000  \n#define ACTION_ZEROOFF   0x00400000  \n#define ACTION_HALFOFF   0x00500000  \n#define ACTION_OOBOFF    0x00600000  \n#define ACTION_MASK      0x00700000  \n\n#define NS_OPER_NUM      13  \n#define NS_OPER_STATES   6   \n\n#define OPT_ANY          0xFFFFFFFF  \n#define OPT_PAGE512      0x00000002  \n#define OPT_PAGE2048     0x00000008  \n#define OPT_PAGE512_8BIT 0x00000040  \n#define OPT_PAGE4096     0x00000080  \n#define OPT_LARGEPAGE    (OPT_PAGE2048 | OPT_PAGE4096)  \n#define OPT_SMALLPAGE    (OPT_PAGE512)  \n\n \n#define NS_STATE(x) ((x) & ~ACTION_MASK)\n\n \n#define NS_MAX_PREVSTATES 1\n\n \n#define NS_MAX_HELD_PAGES 16\n\n \nunion ns_mem {\n\tu_char *byte;     \n\tuint16_t *word;   \n};\n\n \nstruct nandsim {\n\tstruct nand_chip chip;\n\tstruct nand_controller base;\n\tstruct mtd_partition partitions[CONFIG_NANDSIM_MAX_PARTS];\n\tunsigned int nbparts;\n\n\tuint busw;               \n\tu_char ids[8];           \n\tuint32_t options;        \n\tuint32_t state;          \n\tuint32_t nxstate;        \n\n\tuint32_t *op;            \n\tuint32_t pstates[NS_MAX_PREVSTATES];  \n\tuint16_t npstates;       \n\tuint16_t stateidx;       \n\n\t \n\tunion ns_mem *pages;\n\n\t \n\tstruct kmem_cache *nand_pages_slab;\n\n\t \n\tunion ns_mem buf;\n\n\t \n\tstruct {\n\t\tuint64_t totsz;      \n\t\tuint32_t secsz;      \n\t\tuint pgsz;           \n\t\tuint oobsz;          \n\t\tuint64_t totszoob;   \n\t\tuint pgszoob;        \n\t\tuint secszoob;       \n\t\tuint pgnum;          \n\t\tuint pgsec;          \n\t\tuint secshift;       \n\t\tuint pgshift;        \n\t\tuint pgaddrbytes;    \n\t\tuint secaddrbytes;   \n\t\tuint idbytes;        \n\t} geom;\n\n\t \n\tstruct {\n\t\tunsigned command;  \n\t\tu_char   status;   \n\t\tuint     row;      \n\t\tuint     column;   \n\t\tuint     count;    \n\t\tuint     num;      \n\t\tuint     off;      \n\t} regs;\n\n\t \n        struct {\n                int ce;   \n                int cle;  \n                int ale;  \n                int wp;   \n        } lines;\n\n\t \n\tstruct file *cfile;  \n\tunsigned long *pages_written;  \n\tvoid *file_buf;\n\tstruct page *held_pages[NS_MAX_HELD_PAGES];\n\tint held_cnt;\n\n\t \n\tstruct dentry *dent;\n};\n\n \nstatic struct nandsim_operations {\n\tuint32_t reqopts;   \n\tuint32_t states[NS_OPER_STATES];  \n} ops[NS_OPER_NUM] = {\n\t \n\t{OPT_SMALLPAGE, {STATE_CMD_READ0 | ACTION_ZEROOFF, STATE_ADDR_PAGE | ACTION_CPY,\n\t\t\tSTATE_DATAOUT, STATE_READY}},\n\t \n\t{OPT_PAGE512_8BIT, {STATE_CMD_READ1 | ACTION_HALFOFF, STATE_ADDR_PAGE | ACTION_CPY,\n\t\t\tSTATE_DATAOUT, STATE_READY}},\n\t \n\t{OPT_SMALLPAGE, {STATE_CMD_READOOB | ACTION_OOBOFF, STATE_ADDR_PAGE | ACTION_CPY,\n\t\t\tSTATE_DATAOUT, STATE_READY}},\n\t \n\t{OPT_ANY, {STATE_CMD_SEQIN, STATE_ADDR_PAGE, STATE_DATAIN,\n\t\t\tSTATE_CMD_PAGEPROG | ACTION_PRGPAGE, STATE_READY}},\n\t \n\t{OPT_SMALLPAGE, {STATE_CMD_READ0, STATE_CMD_SEQIN | ACTION_ZEROOFF, STATE_ADDR_PAGE,\n\t\t\t      STATE_DATAIN, STATE_CMD_PAGEPROG | ACTION_PRGPAGE, STATE_READY}},\n\t \n\t{OPT_PAGE512, {STATE_CMD_READ1, STATE_CMD_SEQIN | ACTION_HALFOFF, STATE_ADDR_PAGE,\n\t\t\t      STATE_DATAIN, STATE_CMD_PAGEPROG | ACTION_PRGPAGE, STATE_READY}},\n\t \n\t{OPT_SMALLPAGE, {STATE_CMD_READOOB, STATE_CMD_SEQIN | ACTION_OOBOFF, STATE_ADDR_PAGE,\n\t\t\t      STATE_DATAIN, STATE_CMD_PAGEPROG | ACTION_PRGPAGE, STATE_READY}},\n\t \n\t{OPT_ANY, {STATE_CMD_ERASE1, STATE_ADDR_SEC, STATE_CMD_ERASE2 | ACTION_SECERASE, STATE_READY}},\n\t \n\t{OPT_ANY, {STATE_CMD_STATUS, STATE_DATAOUT_STATUS, STATE_READY}},\n\t \n\t{OPT_ANY, {STATE_CMD_READID, STATE_ADDR_ZERO, STATE_DATAOUT_ID, STATE_READY}},\n\t \n\t{OPT_LARGEPAGE, {STATE_CMD_READ0, STATE_ADDR_PAGE, STATE_CMD_READSTART | ACTION_CPY,\n\t\t\t       STATE_DATAOUT, STATE_READY}},\n\t \n\t{OPT_LARGEPAGE, {STATE_CMD_RNDOUT, STATE_ADDR_COLUMN, STATE_CMD_RNDOUTSTART | ACTION_CPY,\n\t\t\t       STATE_DATAOUT, STATE_READY}},\n};\n\nstruct weak_block {\n\tstruct list_head list;\n\tunsigned int erase_block_no;\n\tunsigned int max_erases;\n\tunsigned int erases_done;\n};\n\nstatic LIST_HEAD(weak_blocks);\n\nstruct weak_page {\n\tstruct list_head list;\n\tunsigned int page_no;\n\tunsigned int max_writes;\n\tunsigned int writes_done;\n};\n\nstatic LIST_HEAD(weak_pages);\n\nstruct grave_page {\n\tstruct list_head list;\n\tunsigned int page_no;\n\tunsigned int max_reads;\n\tunsigned int reads_done;\n};\n\nstatic LIST_HEAD(grave_pages);\n\nstatic unsigned long *erase_block_wear = NULL;\nstatic unsigned int wear_eb_count = 0;\nstatic unsigned long total_wear = 0;\n\n \nstatic struct mtd_info *nsmtd;\n\nstatic int ns_show(struct seq_file *m, void *private)\n{\n\tunsigned long wmin = -1, wmax = 0, avg;\n\tunsigned long deciles[10], decile_max[10], tot = 0;\n\tunsigned int i;\n\n\t \n\tfor (i = 0; i < wear_eb_count; ++i) {\n\t\tunsigned long wear = erase_block_wear[i];\n\t\tif (wear < wmin)\n\t\t\twmin = wear;\n\t\tif (wear > wmax)\n\t\t\twmax = wear;\n\t\ttot += wear;\n\t}\n\n\tfor (i = 0; i < 9; ++i) {\n\t\tdeciles[i] = 0;\n\t\tdecile_max[i] = (wmax * (i + 1) + 5) / 10;\n\t}\n\tdeciles[9] = 0;\n\tdecile_max[9] = wmax;\n\tfor (i = 0; i < wear_eb_count; ++i) {\n\t\tint d;\n\t\tunsigned long wear = erase_block_wear[i];\n\t\tfor (d = 0; d < 10; ++d)\n\t\t\tif (wear <= decile_max[d]) {\n\t\t\t\tdeciles[d] += 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n\tavg = tot / wear_eb_count;\n\n\t \n\tseq_printf(m, \"Total numbers of erases:  %lu\\n\", tot);\n\tseq_printf(m, \"Number of erase blocks:   %u\\n\", wear_eb_count);\n\tseq_printf(m, \"Average number of erases: %lu\\n\", avg);\n\tseq_printf(m, \"Maximum number of erases: %lu\\n\", wmax);\n\tseq_printf(m, \"Minimum number of erases: %lu\\n\", wmin);\n\tfor (i = 0; i < 10; ++i) {\n\t\tunsigned long from = (i ? decile_max[i - 1] + 1 : 0);\n\t\tif (from > decile_max[i])\n\t\t\tcontinue;\n\t\tseq_printf(m, \"Number of ebs with erase counts from %lu to %lu : %lu\\n\",\n\t\t\tfrom,\n\t\t\tdecile_max[i],\n\t\t\tdeciles[i]);\n\t}\n\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(ns);\n\n \nstatic int ns_debugfs_create(struct nandsim *ns)\n{\n\tstruct dentry *root = nsmtd->dbg.dfs_dir;\n\n\t \n\tif (IS_ERR_OR_NULL(root)) {\n\t\tif (IS_ENABLED(CONFIG_DEBUG_FS) &&\n\t\t    !IS_ENABLED(CONFIG_MTD_PARTITIONED_MASTER))\n\t\t\tNS_WARN(\"CONFIG_MTD_PARTITIONED_MASTER must be enabled to expose debugfs stuff\\n\");\n\t\treturn 0;\n\t}\n\n\tns->dent = debugfs_create_file(\"nandsim_wear_report\", 0400, root, ns,\n\t\t\t\t       &ns_fops);\n\tif (IS_ERR_OR_NULL(ns->dent)) {\n\t\tNS_ERR(\"cannot create \\\"nandsim_wear_report\\\" debugfs entry\\n\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic void ns_debugfs_remove(struct nandsim *ns)\n{\n\tdebugfs_remove_recursive(ns->dent);\n}\n\n \nstatic int __init ns_alloc_device(struct nandsim *ns)\n{\n\tstruct file *cfile;\n\tint i, err;\n\n\tif (cache_file) {\n\t\tcfile = filp_open(cache_file, O_CREAT | O_RDWR | O_LARGEFILE, 0600);\n\t\tif (IS_ERR(cfile))\n\t\t\treturn PTR_ERR(cfile);\n\t\tif (!(cfile->f_mode & FMODE_CAN_READ)) {\n\t\t\tNS_ERR(\"alloc_device: cache file not readable\\n\");\n\t\t\terr = -EINVAL;\n\t\t\tgoto err_close_filp;\n\t\t}\n\t\tif (!(cfile->f_mode & FMODE_CAN_WRITE)) {\n\t\t\tNS_ERR(\"alloc_device: cache file not writeable\\n\");\n\t\t\terr = -EINVAL;\n\t\t\tgoto err_close_filp;\n\t\t}\n\t\tns->pages_written =\n\t\t\tvzalloc(array_size(sizeof(unsigned long),\n\t\t\t\t\t   BITS_TO_LONGS(ns->geom.pgnum)));\n\t\tif (!ns->pages_written) {\n\t\t\tNS_ERR(\"alloc_device: unable to allocate pages written array\\n\");\n\t\t\terr = -ENOMEM;\n\t\t\tgoto err_close_filp;\n\t\t}\n\t\tns->file_buf = kmalloc(ns->geom.pgszoob, GFP_KERNEL);\n\t\tif (!ns->file_buf) {\n\t\t\tNS_ERR(\"alloc_device: unable to allocate file buf\\n\");\n\t\t\terr = -ENOMEM;\n\t\t\tgoto err_free_pw;\n\t\t}\n\t\tns->cfile = cfile;\n\n\t\treturn 0;\n\nerr_free_pw:\n\t\tvfree(ns->pages_written);\nerr_close_filp:\n\t\tfilp_close(cfile, NULL);\n\n\t\treturn err;\n\t}\n\n\tns->pages = vmalloc(array_size(sizeof(union ns_mem), ns->geom.pgnum));\n\tif (!ns->pages) {\n\t\tNS_ERR(\"alloc_device: unable to allocate page array\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tfor (i = 0; i < ns->geom.pgnum; i++) {\n\t\tns->pages[i].byte = NULL;\n\t}\n\tns->nand_pages_slab = kmem_cache_create(\"nandsim\",\n\t\t\t\t\t\tns->geom.pgszoob, 0, 0, NULL);\n\tif (!ns->nand_pages_slab) {\n\t\tNS_ERR(\"cache_create: unable to create kmem_cache\\n\");\n\t\terr = -ENOMEM;\n\t\tgoto err_free_pg;\n\t}\n\n\treturn 0;\n\nerr_free_pg:\n\tvfree(ns->pages);\n\n\treturn err;\n}\n\n \nstatic void ns_free_device(struct nandsim *ns)\n{\n\tint i;\n\n\tif (ns->cfile) {\n\t\tkfree(ns->file_buf);\n\t\tvfree(ns->pages_written);\n\t\tfilp_close(ns->cfile, NULL);\n\t\treturn;\n\t}\n\n\tif (ns->pages) {\n\t\tfor (i = 0; i < ns->geom.pgnum; i++) {\n\t\t\tif (ns->pages[i].byte)\n\t\t\t\tkmem_cache_free(ns->nand_pages_slab,\n\t\t\t\t\t\tns->pages[i].byte);\n\t\t}\n\t\tkmem_cache_destroy(ns->nand_pages_slab);\n\t\tvfree(ns->pages);\n\t}\n}\n\nstatic char __init *ns_get_partition_name(int i)\n{\n\treturn kasprintf(GFP_KERNEL, \"NAND simulator partition %d\", i);\n}\n\n \nstatic int __init ns_init(struct mtd_info *mtd)\n{\n\tstruct nand_chip *chip = mtd_to_nand(mtd);\n\tstruct nandsim   *ns   = nand_get_controller_data(chip);\n\tint i, ret = 0;\n\tuint64_t remains;\n\tuint64_t next_offset;\n\n\tif (NS_IS_INITIALIZED(ns)) {\n\t\tNS_ERR(\"init_nandsim: nandsim is already initialized\\n\");\n\t\treturn -EIO;\n\t}\n\n\t \n\tns->busw = chip->options & NAND_BUSWIDTH_16 ? 16 : 8;\n\tns->geom.totsz    = mtd->size;\n\tns->geom.pgsz     = mtd->writesize;\n\tns->geom.oobsz    = mtd->oobsize;\n\tns->geom.secsz    = mtd->erasesize;\n\tns->geom.pgszoob  = ns->geom.pgsz + ns->geom.oobsz;\n\tns->geom.pgnum    = div_u64(ns->geom.totsz, ns->geom.pgsz);\n\tns->geom.totszoob = ns->geom.totsz + (uint64_t)ns->geom.pgnum * ns->geom.oobsz;\n\tns->geom.secshift = ffs(ns->geom.secsz) - 1;\n\tns->geom.pgshift  = chip->page_shift;\n\tns->geom.pgsec    = ns->geom.secsz / ns->geom.pgsz;\n\tns->geom.secszoob = ns->geom.secsz + ns->geom.oobsz * ns->geom.pgsec;\n\tns->options = 0;\n\n\tif (ns->geom.pgsz == 512) {\n\t\tns->options |= OPT_PAGE512;\n\t\tif (ns->busw == 8)\n\t\t\tns->options |= OPT_PAGE512_8BIT;\n\t} else if (ns->geom.pgsz == 2048) {\n\t\tns->options |= OPT_PAGE2048;\n\t} else if (ns->geom.pgsz == 4096) {\n\t\tns->options |= OPT_PAGE4096;\n\t} else {\n\t\tNS_ERR(\"init_nandsim: unknown page size %u\\n\", ns->geom.pgsz);\n\t\treturn -EIO;\n\t}\n\n\tif (ns->options & OPT_SMALLPAGE) {\n\t\tif (ns->geom.totsz <= (32 << 20)) {\n\t\t\tns->geom.pgaddrbytes  = 3;\n\t\t\tns->geom.secaddrbytes = 2;\n\t\t} else {\n\t\t\tns->geom.pgaddrbytes  = 4;\n\t\t\tns->geom.secaddrbytes = 3;\n\t\t}\n\t} else {\n\t\tif (ns->geom.totsz <= (128 << 20)) {\n\t\t\tns->geom.pgaddrbytes  = 4;\n\t\t\tns->geom.secaddrbytes = 2;\n\t\t} else {\n\t\t\tns->geom.pgaddrbytes  = 5;\n\t\t\tns->geom.secaddrbytes = 3;\n\t\t}\n\t}\n\n\t \n\tif (parts_num > ARRAY_SIZE(ns->partitions)) {\n\t\tNS_ERR(\"too many partitions.\\n\");\n\t\treturn -EINVAL;\n\t}\n\tremains = ns->geom.totsz;\n\tnext_offset = 0;\n\tfor (i = 0; i < parts_num; ++i) {\n\t\tuint64_t part_sz = (uint64_t)parts[i] * ns->geom.secsz;\n\n\t\tif (!part_sz || part_sz > remains) {\n\t\t\tNS_ERR(\"bad partition size.\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tns->partitions[i].name = ns_get_partition_name(i);\n\t\tif (!ns->partitions[i].name) {\n\t\t\tNS_ERR(\"unable to allocate memory.\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tns->partitions[i].offset = next_offset;\n\t\tns->partitions[i].size   = part_sz;\n\t\tnext_offset += ns->partitions[i].size;\n\t\tremains -= ns->partitions[i].size;\n\t}\n\tns->nbparts = parts_num;\n\tif (remains) {\n\t\tif (parts_num + 1 > ARRAY_SIZE(ns->partitions)) {\n\t\t\tNS_ERR(\"too many partitions.\\n\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto free_partition_names;\n\t\t}\n\t\tns->partitions[i].name = ns_get_partition_name(i);\n\t\tif (!ns->partitions[i].name) {\n\t\t\tNS_ERR(\"unable to allocate memory.\\n\");\n\t\t\tret = -ENOMEM;\n\t\t\tgoto free_partition_names;\n\t\t}\n\t\tns->partitions[i].offset = next_offset;\n\t\tns->partitions[i].size   = remains;\n\t\tns->nbparts += 1;\n\t}\n\n\tif (ns->busw == 16)\n\t\tNS_WARN(\"16-bit flashes support wasn't tested\\n\");\n\n\tprintk(\"flash size: %llu MiB\\n\",\n\t\t\t(unsigned long long)ns->geom.totsz >> 20);\n\tprintk(\"page size: %u bytes\\n\",         ns->geom.pgsz);\n\tprintk(\"OOB area size: %u bytes\\n\",     ns->geom.oobsz);\n\tprintk(\"sector size: %u KiB\\n\",         ns->geom.secsz >> 10);\n\tprintk(\"pages number: %u\\n\",            ns->geom.pgnum);\n\tprintk(\"pages per sector: %u\\n\",        ns->geom.pgsec);\n\tprintk(\"bus width: %u\\n\",               ns->busw);\n\tprintk(\"bits in sector size: %u\\n\",     ns->geom.secshift);\n\tprintk(\"bits in page size: %u\\n\",       ns->geom.pgshift);\n\tprintk(\"bits in OOB size: %u\\n\",\tffs(ns->geom.oobsz) - 1);\n\tprintk(\"flash size with OOB: %llu KiB\\n\",\n\t\t\t(unsigned long long)ns->geom.totszoob >> 10);\n\tprintk(\"page address bytes: %u\\n\",      ns->geom.pgaddrbytes);\n\tprintk(\"sector address bytes: %u\\n\",    ns->geom.secaddrbytes);\n\tprintk(\"options: %#x\\n\",                ns->options);\n\n\tret = ns_alloc_device(ns);\n\tif (ret)\n\t\tgoto free_partition_names;\n\n\t \n\tns->buf.byte = kmalloc(ns->geom.pgszoob, GFP_KERNEL);\n\tif (!ns->buf.byte) {\n\t\tNS_ERR(\"init_nandsim: unable to allocate %u bytes for the internal buffer\\n\",\n\t\t\tns->geom.pgszoob);\n\t\tret = -ENOMEM;\n\t\tgoto free_device;\n\t}\n\tmemset(ns->buf.byte, 0xFF, ns->geom.pgszoob);\n\n\treturn 0;\n\nfree_device:\n\tns_free_device(ns);\nfree_partition_names:\n\tfor (i = 0; i < ARRAY_SIZE(ns->partitions); ++i)\n\t\tkfree(ns->partitions[i].name);\n\n\treturn ret;\n}\n\n \nstatic void ns_free(struct nandsim *ns)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(ns->partitions); ++i)\n\t\tkfree(ns->partitions[i].name);\n\n\tkfree(ns->buf.byte);\n\tns_free_device(ns);\n\n\treturn;\n}\n\nstatic int ns_parse_badblocks(struct nandsim *ns, struct mtd_info *mtd)\n{\n\tchar *w;\n\tint zero_ok;\n\tunsigned int erase_block_no;\n\tloff_t offset;\n\n\tif (!badblocks)\n\t\treturn 0;\n\tw = badblocks;\n\tdo {\n\t\tzero_ok = (*w == '0' ? 1 : 0);\n\t\terase_block_no = simple_strtoul(w, &w, 0);\n\t\tif (!zero_ok && !erase_block_no) {\n\t\t\tNS_ERR(\"invalid badblocks.\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\toffset = (loff_t)erase_block_no * ns->geom.secsz;\n\t\tif (mtd_block_markbad(mtd, offset)) {\n\t\t\tNS_ERR(\"invalid badblocks.\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (*w == ',')\n\t\t\tw += 1;\n\t} while (*w);\n\treturn 0;\n}\n\nstatic int ns_parse_weakblocks(void)\n{\n\tchar *w;\n\tint zero_ok;\n\tunsigned int erase_block_no;\n\tunsigned int max_erases;\n\tstruct weak_block *wb;\n\n\tif (!weakblocks)\n\t\treturn 0;\n\tw = weakblocks;\n\tdo {\n\t\tzero_ok = (*w == '0' ? 1 : 0);\n\t\terase_block_no = simple_strtoul(w, &w, 0);\n\t\tif (!zero_ok && !erase_block_no) {\n\t\t\tNS_ERR(\"invalid weakblocks.\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmax_erases = 3;\n\t\tif (*w == ':') {\n\t\t\tw += 1;\n\t\t\tmax_erases = simple_strtoul(w, &w, 0);\n\t\t}\n\t\tif (*w == ',')\n\t\t\tw += 1;\n\t\twb = kzalloc(sizeof(*wb), GFP_KERNEL);\n\t\tif (!wb) {\n\t\t\tNS_ERR(\"unable to allocate memory.\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\twb->erase_block_no = erase_block_no;\n\t\twb->max_erases = max_erases;\n\t\tlist_add(&wb->list, &weak_blocks);\n\t} while (*w);\n\treturn 0;\n}\n\nstatic int ns_erase_error(unsigned int erase_block_no)\n{\n\tstruct weak_block *wb;\n\n\tlist_for_each_entry(wb, &weak_blocks, list)\n\t\tif (wb->erase_block_no == erase_block_no) {\n\t\t\tif (wb->erases_done >= wb->max_erases)\n\t\t\t\treturn 1;\n\t\t\twb->erases_done += 1;\n\t\t\treturn 0;\n\t\t}\n\treturn 0;\n}\n\nstatic int ns_parse_weakpages(void)\n{\n\tchar *w;\n\tint zero_ok;\n\tunsigned int page_no;\n\tunsigned int max_writes;\n\tstruct weak_page *wp;\n\n\tif (!weakpages)\n\t\treturn 0;\n\tw = weakpages;\n\tdo {\n\t\tzero_ok = (*w == '0' ? 1 : 0);\n\t\tpage_no = simple_strtoul(w, &w, 0);\n\t\tif (!zero_ok && !page_no) {\n\t\t\tNS_ERR(\"invalid weakpages.\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmax_writes = 3;\n\t\tif (*w == ':') {\n\t\t\tw += 1;\n\t\t\tmax_writes = simple_strtoul(w, &w, 0);\n\t\t}\n\t\tif (*w == ',')\n\t\t\tw += 1;\n\t\twp = kzalloc(sizeof(*wp), GFP_KERNEL);\n\t\tif (!wp) {\n\t\t\tNS_ERR(\"unable to allocate memory.\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\twp->page_no = page_no;\n\t\twp->max_writes = max_writes;\n\t\tlist_add(&wp->list, &weak_pages);\n\t} while (*w);\n\treturn 0;\n}\n\nstatic int ns_write_error(unsigned int page_no)\n{\n\tstruct weak_page *wp;\n\n\tlist_for_each_entry(wp, &weak_pages, list)\n\t\tif (wp->page_no == page_no) {\n\t\t\tif (wp->writes_done >= wp->max_writes)\n\t\t\t\treturn 1;\n\t\t\twp->writes_done += 1;\n\t\t\treturn 0;\n\t\t}\n\treturn 0;\n}\n\nstatic int ns_parse_gravepages(void)\n{\n\tchar *g;\n\tint zero_ok;\n\tunsigned int page_no;\n\tunsigned int max_reads;\n\tstruct grave_page *gp;\n\n\tif (!gravepages)\n\t\treturn 0;\n\tg = gravepages;\n\tdo {\n\t\tzero_ok = (*g == '0' ? 1 : 0);\n\t\tpage_no = simple_strtoul(g, &g, 0);\n\t\tif (!zero_ok && !page_no) {\n\t\t\tNS_ERR(\"invalid gravepagess.\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmax_reads = 3;\n\t\tif (*g == ':') {\n\t\t\tg += 1;\n\t\t\tmax_reads = simple_strtoul(g, &g, 0);\n\t\t}\n\t\tif (*g == ',')\n\t\t\tg += 1;\n\t\tgp = kzalloc(sizeof(*gp), GFP_KERNEL);\n\t\tif (!gp) {\n\t\t\tNS_ERR(\"unable to allocate memory.\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tgp->page_no = page_no;\n\t\tgp->max_reads = max_reads;\n\t\tlist_add(&gp->list, &grave_pages);\n\t} while (*g);\n\treturn 0;\n}\n\nstatic int ns_read_error(unsigned int page_no)\n{\n\tstruct grave_page *gp;\n\n\tlist_for_each_entry(gp, &grave_pages, list)\n\t\tif (gp->page_no == page_no) {\n\t\t\tif (gp->reads_done >= gp->max_reads)\n\t\t\t\treturn 1;\n\t\t\tgp->reads_done += 1;\n\t\t\treturn 0;\n\t\t}\n\treturn 0;\n}\n\nstatic int ns_setup_wear_reporting(struct mtd_info *mtd)\n{\n\twear_eb_count = div_u64(mtd->size, mtd->erasesize);\n\terase_block_wear = kcalloc(wear_eb_count, sizeof(unsigned long), GFP_KERNEL);\n\tif (!erase_block_wear) {\n\t\tNS_ERR(\"Too many erase blocks for wear reporting\\n\");\n\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}\n\nstatic void ns_update_wear(unsigned int erase_block_no)\n{\n\tif (!erase_block_wear)\n\t\treturn;\n\ttotal_wear += 1;\n\t \n\tif (total_wear == 0)\n\t\tNS_ERR(\"Erase counter total overflow\\n\");\n\terase_block_wear[erase_block_no] += 1;\n\tif (erase_block_wear[erase_block_no] == 0)\n\t\tNS_ERR(\"Erase counter overflow for erase block %u\\n\", erase_block_no);\n}\n\n \nstatic char *ns_get_state_name(uint32_t state)\n{\n\tswitch (NS_STATE(state)) {\n\t\tcase STATE_CMD_READ0:\n\t\t\treturn \"STATE_CMD_READ0\";\n\t\tcase STATE_CMD_READ1:\n\t\t\treturn \"STATE_CMD_READ1\";\n\t\tcase STATE_CMD_PAGEPROG:\n\t\t\treturn \"STATE_CMD_PAGEPROG\";\n\t\tcase STATE_CMD_READOOB:\n\t\t\treturn \"STATE_CMD_READOOB\";\n\t\tcase STATE_CMD_READSTART:\n\t\t\treturn \"STATE_CMD_READSTART\";\n\t\tcase STATE_CMD_ERASE1:\n\t\t\treturn \"STATE_CMD_ERASE1\";\n\t\tcase STATE_CMD_STATUS:\n\t\t\treturn \"STATE_CMD_STATUS\";\n\t\tcase STATE_CMD_SEQIN:\n\t\t\treturn \"STATE_CMD_SEQIN\";\n\t\tcase STATE_CMD_READID:\n\t\t\treturn \"STATE_CMD_READID\";\n\t\tcase STATE_CMD_ERASE2:\n\t\t\treturn \"STATE_CMD_ERASE2\";\n\t\tcase STATE_CMD_RESET:\n\t\t\treturn \"STATE_CMD_RESET\";\n\t\tcase STATE_CMD_RNDOUT:\n\t\t\treturn \"STATE_CMD_RNDOUT\";\n\t\tcase STATE_CMD_RNDOUTSTART:\n\t\t\treturn \"STATE_CMD_RNDOUTSTART\";\n\t\tcase STATE_ADDR_PAGE:\n\t\t\treturn \"STATE_ADDR_PAGE\";\n\t\tcase STATE_ADDR_SEC:\n\t\t\treturn \"STATE_ADDR_SEC\";\n\t\tcase STATE_ADDR_ZERO:\n\t\t\treturn \"STATE_ADDR_ZERO\";\n\t\tcase STATE_ADDR_COLUMN:\n\t\t\treturn \"STATE_ADDR_COLUMN\";\n\t\tcase STATE_DATAIN:\n\t\t\treturn \"STATE_DATAIN\";\n\t\tcase STATE_DATAOUT:\n\t\t\treturn \"STATE_DATAOUT\";\n\t\tcase STATE_DATAOUT_ID:\n\t\t\treturn \"STATE_DATAOUT_ID\";\n\t\tcase STATE_DATAOUT_STATUS:\n\t\t\treturn \"STATE_DATAOUT_STATUS\";\n\t\tcase STATE_READY:\n\t\t\treturn \"STATE_READY\";\n\t\tcase STATE_UNKNOWN:\n\t\t\treturn \"STATE_UNKNOWN\";\n\t}\n\n\tNS_ERR(\"get_state_name: unknown state, BUG\\n\");\n\treturn NULL;\n}\n\n \nstatic int ns_check_command(int cmd)\n{\n\tswitch (cmd) {\n\n\tcase NAND_CMD_READ0:\n\tcase NAND_CMD_READ1:\n\tcase NAND_CMD_READSTART:\n\tcase NAND_CMD_PAGEPROG:\n\tcase NAND_CMD_READOOB:\n\tcase NAND_CMD_ERASE1:\n\tcase NAND_CMD_STATUS:\n\tcase NAND_CMD_SEQIN:\n\tcase NAND_CMD_READID:\n\tcase NAND_CMD_ERASE2:\n\tcase NAND_CMD_RESET:\n\tcase NAND_CMD_RNDOUT:\n\tcase NAND_CMD_RNDOUTSTART:\n\t\treturn 0;\n\n\tdefault:\n\t\treturn 1;\n\t}\n}\n\n \nstatic uint32_t ns_get_state_by_command(unsigned command)\n{\n\tswitch (command) {\n\t\tcase NAND_CMD_READ0:\n\t\t\treturn STATE_CMD_READ0;\n\t\tcase NAND_CMD_READ1:\n\t\t\treturn STATE_CMD_READ1;\n\t\tcase NAND_CMD_PAGEPROG:\n\t\t\treturn STATE_CMD_PAGEPROG;\n\t\tcase NAND_CMD_READSTART:\n\t\t\treturn STATE_CMD_READSTART;\n\t\tcase NAND_CMD_READOOB:\n\t\t\treturn STATE_CMD_READOOB;\n\t\tcase NAND_CMD_ERASE1:\n\t\t\treturn STATE_CMD_ERASE1;\n\t\tcase NAND_CMD_STATUS:\n\t\t\treturn STATE_CMD_STATUS;\n\t\tcase NAND_CMD_SEQIN:\n\t\t\treturn STATE_CMD_SEQIN;\n\t\tcase NAND_CMD_READID:\n\t\t\treturn STATE_CMD_READID;\n\t\tcase NAND_CMD_ERASE2:\n\t\t\treturn STATE_CMD_ERASE2;\n\t\tcase NAND_CMD_RESET:\n\t\t\treturn STATE_CMD_RESET;\n\t\tcase NAND_CMD_RNDOUT:\n\t\t\treturn STATE_CMD_RNDOUT;\n\t\tcase NAND_CMD_RNDOUTSTART:\n\t\t\treturn STATE_CMD_RNDOUTSTART;\n\t}\n\n\tNS_ERR(\"get_state_by_command: unknown command, BUG\\n\");\n\treturn 0;\n}\n\n \nstatic inline void ns_accept_addr_byte(struct nandsim *ns, u_char bt)\n{\n\tuint byte = (uint)bt;\n\n\tif (ns->regs.count < (ns->geom.pgaddrbytes - ns->geom.secaddrbytes))\n\t\tns->regs.column |= (byte << 8 * ns->regs.count);\n\telse {\n\t\tns->regs.row |= (byte << 8 * (ns->regs.count -\n\t\t\t\t\t\tns->geom.pgaddrbytes +\n\t\t\t\t\t\tns->geom.secaddrbytes));\n\t}\n\n\treturn;\n}\n\n \nstatic inline void ns_switch_to_ready_state(struct nandsim *ns, u_char status)\n{\n\tNS_DBG(\"switch_to_ready_state: switch to %s state\\n\",\n\t       ns_get_state_name(STATE_READY));\n\n\tns->state       = STATE_READY;\n\tns->nxstate     = STATE_UNKNOWN;\n\tns->op          = NULL;\n\tns->npstates    = 0;\n\tns->stateidx    = 0;\n\tns->regs.num    = 0;\n\tns->regs.count  = 0;\n\tns->regs.off    = 0;\n\tns->regs.row    = 0;\n\tns->regs.column = 0;\n\tns->regs.status = status;\n}\n\n \nstatic int ns_find_operation(struct nandsim *ns, uint32_t flag)\n{\n\tint opsfound = 0;\n\tint i, j, idx = 0;\n\n\tfor (i = 0; i < NS_OPER_NUM; i++) {\n\n\t\tint found = 1;\n\n\t\tif (!(ns->options & ops[i].reqopts))\n\t\t\t \n\t\t\tcontinue;\n\n\t\tif (flag) {\n\t\t\tif (!(ops[i].states[ns->npstates] & STATE_ADDR_MASK))\n\t\t\t\tcontinue;\n\t\t} else {\n\t\t\tif (NS_STATE(ns->state) != NS_STATE(ops[i].states[ns->npstates]))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tfor (j = 0; j < ns->npstates; j++)\n\t\t\tif (NS_STATE(ops[i].states[j]) != NS_STATE(ns->pstates[j])\n\t\t\t\t&& (ns->options & ops[idx].reqopts)) {\n\t\t\t\tfound = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\tif (found) {\n\t\t\tidx = i;\n\t\t\topsfound += 1;\n\t\t}\n\t}\n\n\tif (opsfound == 1) {\n\t\t \n\t\tns->op = &ops[idx].states[0];\n\t\tif (flag) {\n\t\t\t \n\t\t\tns->stateidx = ns->npstates - 1;\n\t\t} else {\n\t\t\tns->stateidx = ns->npstates;\n\t\t}\n\t\tns->npstates = 0;\n\t\tns->state = ns->op[ns->stateidx];\n\t\tns->nxstate = ns->op[ns->stateidx + 1];\n\t\tNS_DBG(\"find_operation: operation found, index: %d, state: %s, nxstate %s\\n\",\n\t\t       idx, ns_get_state_name(ns->state),\n\t\t       ns_get_state_name(ns->nxstate));\n\t\treturn 0;\n\t}\n\n\tif (opsfound == 0) {\n\t\t \n\t\tif (ns->npstates != 0) {\n\t\t\tNS_DBG(\"find_operation: no operation found, try again with state %s\\n\",\n\t\t\t       ns_get_state_name(ns->state));\n\t\t\tns->npstates = 0;\n\t\t\treturn ns_find_operation(ns, 0);\n\n\t\t}\n\t\tNS_DBG(\"find_operation: no operations found\\n\");\n\t\tns_switch_to_ready_state(ns, NS_STATUS_FAILED(ns));\n\t\treturn -2;\n\t}\n\n\tif (flag) {\n\t\t \n\t\tNS_DBG(\"find_operation: BUG, operation must be known if address is input\\n\");\n\t\treturn -2;\n\t}\n\n\tNS_DBG(\"find_operation: there is still ambiguity\\n\");\n\n\tns->pstates[ns->npstates++] = ns->state;\n\n\treturn -1;\n}\n\nstatic void ns_put_pages(struct nandsim *ns)\n{\n\tint i;\n\n\tfor (i = 0; i < ns->held_cnt; i++)\n\t\tput_page(ns->held_pages[i]);\n}\n\n \nstatic int ns_get_pages(struct nandsim *ns, struct file *file, size_t count,\n\t\t\tloff_t pos)\n{\n\tpgoff_t index, start_index, end_index;\n\tstruct page *page;\n\tstruct address_space *mapping = file->f_mapping;\n\n\tstart_index = pos >> PAGE_SHIFT;\n\tend_index = (pos + count - 1) >> PAGE_SHIFT;\n\tif (end_index - start_index + 1 > NS_MAX_HELD_PAGES)\n\t\treturn -EINVAL;\n\tns->held_cnt = 0;\n\tfor (index = start_index; index <= end_index; index++) {\n\t\tpage = find_get_page(mapping, index);\n\t\tif (page == NULL) {\n\t\t\tpage = find_or_create_page(mapping, index, GFP_NOFS);\n\t\t\tif (page == NULL) {\n\t\t\t\twrite_inode_now(mapping->host, 1);\n\t\t\t\tpage = find_or_create_page(mapping, index, GFP_NOFS);\n\t\t\t}\n\t\t\tif (page == NULL) {\n\t\t\t\tns_put_pages(ns);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t\tunlock_page(page);\n\t\t}\n\t\tns->held_pages[ns->held_cnt++] = page;\n\t}\n\treturn 0;\n}\n\nstatic ssize_t ns_read_file(struct nandsim *ns, struct file *file, void *buf,\n\t\t\t    size_t count, loff_t pos)\n{\n\tssize_t tx;\n\tint err;\n\tunsigned int noreclaim_flag;\n\n\terr = ns_get_pages(ns, file, count, pos);\n\tif (err)\n\t\treturn err;\n\tnoreclaim_flag = memalloc_noreclaim_save();\n\ttx = kernel_read(file, buf, count, &pos);\n\tmemalloc_noreclaim_restore(noreclaim_flag);\n\tns_put_pages(ns);\n\treturn tx;\n}\n\nstatic ssize_t ns_write_file(struct nandsim *ns, struct file *file, void *buf,\n\t\t\t     size_t count, loff_t pos)\n{\n\tssize_t tx;\n\tint err;\n\tunsigned int noreclaim_flag;\n\n\terr = ns_get_pages(ns, file, count, pos);\n\tif (err)\n\t\treturn err;\n\tnoreclaim_flag = memalloc_noreclaim_save();\n\ttx = kernel_write(file, buf, count, &pos);\n\tmemalloc_noreclaim_restore(noreclaim_flag);\n\tns_put_pages(ns);\n\treturn tx;\n}\n\n \nstatic inline union ns_mem *NS_GET_PAGE(struct nandsim *ns)\n{\n\treturn &(ns->pages[ns->regs.row]);\n}\n\n \nstatic inline u_char *NS_PAGE_BYTE_OFF(struct nandsim *ns)\n{\n\treturn NS_GET_PAGE(ns)->byte + NS_PAGE_BYTE_SHIFT(ns);\n}\n\nstatic int ns_do_read_error(struct nandsim *ns, int num)\n{\n\tunsigned int page_no = ns->regs.row;\n\n\tif (ns_read_error(page_no)) {\n\t\tget_random_bytes(ns->buf.byte, num);\n\t\tNS_WARN(\"simulating read error in page %u\\n\", page_no);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic void ns_do_bit_flips(struct nandsim *ns, int num)\n{\n\tif (bitflips && get_random_u16() < (1 << 6)) {\n\t\tint flips = 1;\n\t\tif (bitflips > 1)\n\t\t\tflips = get_random_u32_inclusive(1, bitflips);\n\t\twhile (flips--) {\n\t\t\tint pos = get_random_u32_below(num * 8);\n\t\t\tns->buf.byte[pos / 8] ^= (1 << (pos % 8));\n\t\t\tNS_WARN(\"read_page: flipping bit %d in page %d \"\n\t\t\t\t\"reading from %d ecc: corrected=%u failed=%u\\n\",\n\t\t\t\tpos, ns->regs.row, NS_PAGE_BYTE_SHIFT(ns),\n\t\t\t\tnsmtd->ecc_stats.corrected, nsmtd->ecc_stats.failed);\n\t\t}\n\t}\n}\n\n \nstatic void ns_read_page(struct nandsim *ns, int num)\n{\n\tunion ns_mem *mypage;\n\n\tif (ns->cfile) {\n\t\tif (!test_bit(ns->regs.row, ns->pages_written)) {\n\t\t\tNS_DBG(\"read_page: page %d not written\\n\", ns->regs.row);\n\t\t\tmemset(ns->buf.byte, 0xFF, num);\n\t\t} else {\n\t\t\tloff_t pos;\n\t\t\tssize_t tx;\n\n\t\t\tNS_DBG(\"read_page: page %d written, reading from %d\\n\",\n\t\t\t\tns->regs.row, NS_PAGE_BYTE_SHIFT(ns));\n\t\t\tif (ns_do_read_error(ns, num))\n\t\t\t\treturn;\n\t\t\tpos = (loff_t)NS_RAW_OFFSET(ns) + ns->regs.off;\n\t\t\ttx = ns_read_file(ns, ns->cfile, ns->buf.byte, num,\n\t\t\t\t\t  pos);\n\t\t\tif (tx != num) {\n\t\t\t\tNS_ERR(\"read_page: read error for page %d ret %ld\\n\", ns->regs.row, (long)tx);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tns_do_bit_flips(ns, num);\n\t\t}\n\t\treturn;\n\t}\n\n\tmypage = NS_GET_PAGE(ns);\n\tif (mypage->byte == NULL) {\n\t\tNS_DBG(\"read_page: page %d not allocated\\n\", ns->regs.row);\n\t\tmemset(ns->buf.byte, 0xFF, num);\n\t} else {\n\t\tNS_DBG(\"read_page: page %d allocated, reading from %d\\n\",\n\t\t\tns->regs.row, NS_PAGE_BYTE_SHIFT(ns));\n\t\tif (ns_do_read_error(ns, num))\n\t\t\treturn;\n\t\tmemcpy(ns->buf.byte, NS_PAGE_BYTE_OFF(ns), num);\n\t\tns_do_bit_flips(ns, num);\n\t}\n}\n\n \nstatic void ns_erase_sector(struct nandsim *ns)\n{\n\tunion ns_mem *mypage;\n\tint i;\n\n\tif (ns->cfile) {\n\t\tfor (i = 0; i < ns->geom.pgsec; i++)\n\t\t\tif (__test_and_clear_bit(ns->regs.row + i,\n\t\t\t\t\t\t ns->pages_written)) {\n\t\t\t\tNS_DBG(\"erase_sector: freeing page %d\\n\", ns->regs.row + i);\n\t\t\t}\n\t\treturn;\n\t}\n\n\tmypage = NS_GET_PAGE(ns);\n\tfor (i = 0; i < ns->geom.pgsec; i++) {\n\t\tif (mypage->byte != NULL) {\n\t\t\tNS_DBG(\"erase_sector: freeing page %d\\n\", ns->regs.row+i);\n\t\t\tkmem_cache_free(ns->nand_pages_slab, mypage->byte);\n\t\t\tmypage->byte = NULL;\n\t\t}\n\t\tmypage++;\n\t}\n}\n\n \nstatic int ns_prog_page(struct nandsim *ns, int num)\n{\n\tint i;\n\tunion ns_mem *mypage;\n\tu_char *pg_off;\n\n\tif (ns->cfile) {\n\t\tloff_t off;\n\t\tssize_t tx;\n\t\tint all;\n\n\t\tNS_DBG(\"prog_page: writing page %d\\n\", ns->regs.row);\n\t\tpg_off = ns->file_buf + NS_PAGE_BYTE_SHIFT(ns);\n\t\toff = (loff_t)NS_RAW_OFFSET(ns) + ns->regs.off;\n\t\tif (!test_bit(ns->regs.row, ns->pages_written)) {\n\t\t\tall = 1;\n\t\t\tmemset(ns->file_buf, 0xff, ns->geom.pgszoob);\n\t\t} else {\n\t\t\tall = 0;\n\t\t\ttx = ns_read_file(ns, ns->cfile, pg_off, num, off);\n\t\t\tif (tx != num) {\n\t\t\t\tNS_ERR(\"prog_page: read error for page %d ret %ld\\n\", ns->regs.row, (long)tx);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tfor (i = 0; i < num; i++)\n\t\t\tpg_off[i] &= ns->buf.byte[i];\n\t\tif (all) {\n\t\t\tloff_t pos = (loff_t)ns->regs.row * ns->geom.pgszoob;\n\t\t\ttx = ns_write_file(ns, ns->cfile, ns->file_buf,\n\t\t\t\t\t   ns->geom.pgszoob, pos);\n\t\t\tif (tx != ns->geom.pgszoob) {\n\t\t\t\tNS_ERR(\"prog_page: write error for page %d ret %ld\\n\", ns->regs.row, (long)tx);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\t__set_bit(ns->regs.row, ns->pages_written);\n\t\t} else {\n\t\t\ttx = ns_write_file(ns, ns->cfile, pg_off, num, off);\n\t\t\tif (tx != num) {\n\t\t\t\tNS_ERR(\"prog_page: write error for page %d ret %ld\\n\", ns->regs.row, (long)tx);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\n\tmypage = NS_GET_PAGE(ns);\n\tif (mypage->byte == NULL) {\n\t\tNS_DBG(\"prog_page: allocating page %d\\n\", ns->regs.row);\n\t\t \n\t\tmypage->byte = kmem_cache_alloc(ns->nand_pages_slab, GFP_NOFS);\n\t\tif (mypage->byte == NULL) {\n\t\t\tNS_ERR(\"prog_page: error allocating memory for page %d\\n\", ns->regs.row);\n\t\t\treturn -1;\n\t\t}\n\t\tmemset(mypage->byte, 0xFF, ns->geom.pgszoob);\n\t}\n\n\tpg_off = NS_PAGE_BYTE_OFF(ns);\n\tfor (i = 0; i < num; i++)\n\t\tpg_off[i] &= ns->buf.byte[i];\n\n\treturn 0;\n}\n\n \nstatic int ns_do_state_action(struct nandsim *ns, uint32_t action)\n{\n\tint num;\n\tint busdiv = ns->busw == 8 ? 1 : 2;\n\tunsigned int erase_block_no, page_no;\n\n\taction &= ACTION_MASK;\n\n\t \n\tif (action != ACTION_SECERASE && ns->regs.row >= ns->geom.pgnum) {\n\t\tNS_WARN(\"do_state_action: wrong page number (%#x)\\n\", ns->regs.row);\n\t\treturn -1;\n\t}\n\n\tswitch (action) {\n\n\tcase ACTION_CPY:\n\t\t \n\n\t\t \n\t\tif (ns->regs.column >= (ns->geom.pgszoob - ns->regs.off)) {\n\t\t\tNS_ERR(\"do_state_action: column number is too large\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tnum = ns->geom.pgszoob - NS_PAGE_BYTE_SHIFT(ns);\n\t\tns_read_page(ns, num);\n\n\t\tNS_DBG(\"do_state_action: (ACTION_CPY:) copy %d bytes to int buf, raw offset %d\\n\",\n\t\t\tnum, NS_RAW_OFFSET(ns) + ns->regs.off);\n\n\t\tif (ns->regs.off == 0)\n\t\t\tNS_LOG(\"read page %d\\n\", ns->regs.row);\n\t\telse if (ns->regs.off < ns->geom.pgsz)\n\t\t\tNS_LOG(\"read page %d (second half)\\n\", ns->regs.row);\n\t\telse\n\t\t\tNS_LOG(\"read OOB of page %d\\n\", ns->regs.row);\n\n\t\tNS_UDELAY(access_delay);\n\t\tNS_UDELAY(input_cycle * ns->geom.pgsz / 1000 / busdiv);\n\n\t\tbreak;\n\n\tcase ACTION_SECERASE:\n\t\t \n\n\t\tif (ns->lines.wp) {\n\t\t\tNS_ERR(\"do_state_action: device is write-protected, ignore sector erase\\n\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (ns->regs.row >= ns->geom.pgnum - ns->geom.pgsec\n\t\t\t|| (ns->regs.row & ~(ns->geom.secsz - 1))) {\n\t\t\tNS_ERR(\"do_state_action: wrong sector address (%#x)\\n\", ns->regs.row);\n\t\t\treturn -1;\n\t\t}\n\n\t\tns->regs.row = (ns->regs.row <<\n\t\t\t\t8 * (ns->geom.pgaddrbytes - ns->geom.secaddrbytes)) | ns->regs.column;\n\t\tns->regs.column = 0;\n\n\t\terase_block_no = ns->regs.row >> (ns->geom.secshift - ns->geom.pgshift);\n\n\t\tNS_DBG(\"do_state_action: erase sector at address %#x, off = %d\\n\",\n\t\t\t\tns->regs.row, NS_RAW_OFFSET(ns));\n\t\tNS_LOG(\"erase sector %u\\n\", erase_block_no);\n\n\t\tns_erase_sector(ns);\n\n\t\tNS_MDELAY(erase_delay);\n\n\t\tif (erase_block_wear)\n\t\t\tns_update_wear(erase_block_no);\n\n\t\tif (ns_erase_error(erase_block_no)) {\n\t\t\tNS_WARN(\"simulating erase failure in erase block %u\\n\", erase_block_no);\n\t\t\treturn -1;\n\t\t}\n\n\t\tbreak;\n\n\tcase ACTION_PRGPAGE:\n\t\t \n\n\t\tif (ns->lines.wp) {\n\t\t\tNS_WARN(\"do_state_action: device is write-protected, programm\\n\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tnum = ns->geom.pgszoob - NS_PAGE_BYTE_SHIFT(ns);\n\t\tif (num != ns->regs.count) {\n\t\t\tNS_ERR(\"do_state_action: too few bytes were input (%d instead of %d)\\n\",\n\t\t\t\t\tns->regs.count, num);\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (ns_prog_page(ns, num) == -1)\n\t\t\treturn -1;\n\n\t\tpage_no = ns->regs.row;\n\n\t\tNS_DBG(\"do_state_action: copy %d bytes from int buf to (%#x, %#x), raw off = %d\\n\",\n\t\t\tnum, ns->regs.row, ns->regs.column, NS_RAW_OFFSET(ns) + ns->regs.off);\n\t\tNS_LOG(\"programm page %d\\n\", ns->regs.row);\n\n\t\tNS_UDELAY(programm_delay);\n\t\tNS_UDELAY(output_cycle * ns->geom.pgsz / 1000 / busdiv);\n\n\t\tif (ns_write_error(page_no)) {\n\t\t\tNS_WARN(\"simulating write failure in page %u\\n\", page_no);\n\t\t\treturn -1;\n\t\t}\n\n\t\tbreak;\n\n\tcase ACTION_ZEROOFF:\n\t\tNS_DBG(\"do_state_action: set internal offset to 0\\n\");\n\t\tns->regs.off = 0;\n\t\tbreak;\n\n\tcase ACTION_HALFOFF:\n\t\tif (!(ns->options & OPT_PAGE512_8BIT)) {\n\t\t\tNS_ERR(\"do_state_action: BUG! can't skip half of page for non-512\"\n\t\t\t\t\"byte page size 8x chips\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\tNS_DBG(\"do_state_action: set internal offset to %d\\n\", ns->geom.pgsz/2);\n\t\tns->regs.off = ns->geom.pgsz/2;\n\t\tbreak;\n\n\tcase ACTION_OOBOFF:\n\t\tNS_DBG(\"do_state_action: set internal offset to %d\\n\", ns->geom.pgsz);\n\t\tns->regs.off = ns->geom.pgsz;\n\t\tbreak;\n\n\tdefault:\n\t\tNS_DBG(\"do_state_action: BUG! unknown action\\n\");\n\t}\n\n\treturn 0;\n}\n\n \nstatic void ns_switch_state(struct nandsim *ns)\n{\n\tif (ns->op) {\n\t\t \n\n\t\tns->stateidx += 1;\n\t\tns->state = ns->nxstate;\n\t\tns->nxstate = ns->op[ns->stateidx + 1];\n\n\t\tNS_DBG(\"switch_state: operation is known, switch to the next state, \"\n\t\t\t\"state: %s, nxstate: %s\\n\",\n\t\t       ns_get_state_name(ns->state),\n\t\t       ns_get_state_name(ns->nxstate));\n\t} else {\n\t\t \n\n\t\t \n\t\tns->state = ns_get_state_by_command(ns->regs.command);\n\n\t\tNS_DBG(\"switch_state: operation is unknown, try to find it\\n\");\n\n\t\tif (ns_find_operation(ns, 0))\n\t\t\treturn;\n\t}\n\n\t \n\tif ((ns->state & ACTION_MASK) &&\n\t    ns_do_state_action(ns, ns->state) < 0) {\n\t\tns_switch_to_ready_state(ns, NS_STATUS_FAILED(ns));\n\t\treturn;\n\t}\n\n\t \n\tif ((ns->nxstate & STATE_ADDR_MASK) && ns->busw == 16) {\n\t\tNS_DBG(\"switch_state: double the column number for 16x device\\n\");\n\t\tns->regs.column <<= 1;\n\t}\n\n\tif (NS_STATE(ns->nxstate) == STATE_READY) {\n\t\t \n\n\t\tu_char status = NS_STATUS_OK(ns);\n\n\t\t \n\t\tif ((ns->state & (STATE_DATAIN_MASK | STATE_DATAOUT_MASK))\n\t\t\t&& ns->regs.count != ns->regs.num) {\n\t\t\tNS_WARN(\"switch_state: not all bytes were processed, %d left\\n\",\n\t\t\t\t\tns->regs.num - ns->regs.count);\n\t\t\tstatus = NS_STATUS_FAILED(ns);\n\t\t}\n\n\t\tNS_DBG(\"switch_state: operation complete, switch to STATE_READY state\\n\");\n\n\t\tns_switch_to_ready_state(ns, status);\n\n\t\treturn;\n\t} else if (ns->nxstate & (STATE_DATAIN_MASK | STATE_DATAOUT_MASK)) {\n\t\t \n\n\t\tns->state      = ns->nxstate;\n\t\tns->nxstate    = ns->op[++ns->stateidx + 1];\n\t\tns->regs.num   = ns->regs.count = 0;\n\n\t\tNS_DBG(\"switch_state: the next state is data I/O, switch, \"\n\t\t\t\"state: %s, nxstate: %s\\n\",\n\t\t       ns_get_state_name(ns->state),\n\t\t       ns_get_state_name(ns->nxstate));\n\n\t\t \n\t\tswitch (NS_STATE(ns->state)) {\n\t\t\tcase STATE_DATAIN:\n\t\t\tcase STATE_DATAOUT:\n\t\t\t\tns->regs.num = ns->geom.pgszoob - NS_PAGE_BYTE_SHIFT(ns);\n\t\t\t\tbreak;\n\n\t\t\tcase STATE_DATAOUT_ID:\n\t\t\t\tns->regs.num = ns->geom.idbytes;\n\t\t\t\tbreak;\n\n\t\t\tcase STATE_DATAOUT_STATUS:\n\t\t\t\tns->regs.count = ns->regs.num = 0;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tNS_ERR(\"switch_state: BUG! unknown data state\\n\");\n\t\t}\n\n\t} else if (ns->nxstate & STATE_ADDR_MASK) {\n\t\t \n\n\t\tns->regs.count = 0;\n\n\t\tswitch (NS_STATE(ns->nxstate)) {\n\t\t\tcase STATE_ADDR_PAGE:\n\t\t\t\tns->regs.num = ns->geom.pgaddrbytes;\n\n\t\t\t\tbreak;\n\t\t\tcase STATE_ADDR_SEC:\n\t\t\t\tns->regs.num = ns->geom.secaddrbytes;\n\t\t\t\tbreak;\n\n\t\t\tcase STATE_ADDR_ZERO:\n\t\t\t\tns->regs.num = 1;\n\t\t\t\tbreak;\n\n\t\t\tcase STATE_ADDR_COLUMN:\n\t\t\t\t \n\t\t\t\tns->regs.num = ns->geom.pgaddrbytes - ns->geom.secaddrbytes;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tNS_ERR(\"switch_state: BUG! unknown address state\\n\");\n\t\t}\n\t} else {\n\t\t \n\n\t\tns->regs.num = 0;\n\t\tns->regs.count = 0;\n\t}\n}\n\nstatic u_char ns_nand_read_byte(struct nand_chip *chip)\n{\n\tstruct nandsim *ns = nand_get_controller_data(chip);\n\tu_char outb = 0x00;\n\n\t \n\tif (!ns->lines.ce) {\n\t\tNS_ERR(\"read_byte: chip is disabled, return %#x\\n\", (uint)outb);\n\t\treturn outb;\n\t}\n\tif (ns->lines.ale || ns->lines.cle) {\n\t\tNS_ERR(\"read_byte: ALE or CLE pin is high, return %#x\\n\", (uint)outb);\n\t\treturn outb;\n\t}\n\tif (!(ns->state & STATE_DATAOUT_MASK)) {\n\t\tNS_WARN(\"read_byte: unexpected data output cycle, state is %s return %#x\\n\",\n\t\t\tns_get_state_name(ns->state), (uint)outb);\n\t\treturn outb;\n\t}\n\n\t \n\tif (NS_STATE(ns->state) == STATE_DATAOUT_STATUS) {\n\t\tNS_DBG(\"read_byte: return %#x status\\n\", ns->regs.status);\n\t\treturn ns->regs.status;\n\t}\n\n\t \n\tif (ns->regs.count == ns->regs.num) {\n\t\tNS_WARN(\"read_byte: no more data to output, return %#x\\n\", (uint)outb);\n\t\treturn outb;\n\t}\n\n\tswitch (NS_STATE(ns->state)) {\n\t\tcase STATE_DATAOUT:\n\t\t\tif (ns->busw == 8) {\n\t\t\t\toutb = ns->buf.byte[ns->regs.count];\n\t\t\t\tns->regs.count += 1;\n\t\t\t} else {\n\t\t\t\toutb = (u_char)cpu_to_le16(ns->buf.word[ns->regs.count >> 1]);\n\t\t\t\tns->regs.count += 2;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase STATE_DATAOUT_ID:\n\t\t\tNS_DBG(\"read_byte: read ID byte %d, total = %d\\n\", ns->regs.count, ns->regs.num);\n\t\t\toutb = ns->ids[ns->regs.count];\n\t\t\tns->regs.count += 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tBUG();\n\t}\n\n\tif (ns->regs.count == ns->regs.num) {\n\t\tNS_DBG(\"read_byte: all bytes were read\\n\");\n\n\t\tif (NS_STATE(ns->nxstate) == STATE_READY)\n\t\t\tns_switch_state(ns);\n\t}\n\n\treturn outb;\n}\n\nstatic void ns_nand_write_byte(struct nand_chip *chip, u_char byte)\n{\n\tstruct nandsim *ns = nand_get_controller_data(chip);\n\n\t \n\tif (!ns->lines.ce) {\n\t\tNS_ERR(\"write_byte: chip is disabled, ignore write\\n\");\n\t\treturn;\n\t}\n\tif (ns->lines.ale && ns->lines.cle) {\n\t\tNS_ERR(\"write_byte: ALE and CLE pins are high simultaneously, ignore write\\n\");\n\t\treturn;\n\t}\n\n\tif (ns->lines.cle == 1) {\n\t\t \n\n\t\tif (byte == NAND_CMD_RESET) {\n\t\t\tNS_LOG(\"reset chip\\n\");\n\t\t\tns_switch_to_ready_state(ns, NS_STATUS_OK(ns));\n\t\t\treturn;\n\t\t}\n\n\t\t \n\t\tif (ns_check_command(byte)) {\n\t\t\tNS_ERR(\"write_byte: unknown command %#x\\n\", (uint)byte);\n\t\t\treturn;\n\t\t}\n\n\t\tif (NS_STATE(ns->state) == STATE_DATAOUT_STATUS\n\t\t\t|| NS_STATE(ns->state) == STATE_DATAOUT) {\n\t\t\tint row = ns->regs.row;\n\n\t\t\tns_switch_state(ns);\n\t\t\tif (byte == NAND_CMD_RNDOUT)\n\t\t\t\tns->regs.row = row;\n\t\t}\n\n\t\t \n\t\tif (NS_STATE(ns->nxstate) != STATE_UNKNOWN && !(ns->nxstate & STATE_CMD_MASK)) {\n\t\t\t \n\t\t\tif (!(ns->regs.command == NAND_CMD_READID &&\n\t\t\t    NS_STATE(ns->state) == STATE_DATAOUT_ID && ns->regs.count == 2)) {\n\t\t\t\t \n\t\t\t\tNS_WARN(\"write_byte: command (%#x) wasn't expected, expected state is %s, ignore previous states\\n\",\n\t\t\t\t\t(uint)byte,\n\t\t\t\t\tns_get_state_name(ns->nxstate));\n\t\t\t}\n\t\t\tns_switch_to_ready_state(ns, NS_STATUS_FAILED(ns));\n\t\t}\n\n\t\tNS_DBG(\"command byte corresponding to %s state accepted\\n\",\n\t\t\tns_get_state_name(ns_get_state_by_command(byte)));\n\t\tns->regs.command = byte;\n\t\tns_switch_state(ns);\n\n\t} else if (ns->lines.ale == 1) {\n\t\t \n\n\t\tif (NS_STATE(ns->nxstate) == STATE_UNKNOWN) {\n\n\t\t\tNS_DBG(\"write_byte: operation isn't known yet, identify it\\n\");\n\n\t\t\tif (ns_find_operation(ns, 1) < 0)\n\t\t\t\treturn;\n\n\t\t\tif ((ns->state & ACTION_MASK) &&\n\t\t\t    ns_do_state_action(ns, ns->state) < 0) {\n\t\t\t\tns_switch_to_ready_state(ns,\n\t\t\t\t\t\t\t NS_STATUS_FAILED(ns));\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tns->regs.count = 0;\n\t\t\tswitch (NS_STATE(ns->nxstate)) {\n\t\t\t\tcase STATE_ADDR_PAGE:\n\t\t\t\t\tns->regs.num = ns->geom.pgaddrbytes;\n\t\t\t\t\tbreak;\n\t\t\t\tcase STATE_ADDR_SEC:\n\t\t\t\t\tns->regs.num = ns->geom.secaddrbytes;\n\t\t\t\t\tbreak;\n\t\t\t\tcase STATE_ADDR_ZERO:\n\t\t\t\t\tns->regs.num = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tBUG();\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (!(ns->nxstate & STATE_ADDR_MASK)) {\n\t\t\tNS_ERR(\"write_byte: address (%#x) isn't expected, expected state is %s, switch to STATE_READY\\n\",\n\t\t\t       (uint)byte, ns_get_state_name(ns->nxstate));\n\t\t\tns_switch_to_ready_state(ns, NS_STATUS_FAILED(ns));\n\t\t\treturn;\n\t\t}\n\n\t\t \n\t\tif (ns->regs.count == ns->regs.num) {\n\t\t\tNS_ERR(\"write_byte: no more address bytes expected\\n\");\n\t\t\tns_switch_to_ready_state(ns, NS_STATUS_FAILED(ns));\n\t\t\treturn;\n\t\t}\n\n\t\tns_accept_addr_byte(ns, byte);\n\n\t\tns->regs.count += 1;\n\n\t\tNS_DBG(\"write_byte: address byte %#x was accepted (%d bytes input, %d expected)\\n\",\n\t\t\t\t(uint)byte, ns->regs.count, ns->regs.num);\n\n\t\tif (ns->regs.count == ns->regs.num) {\n\t\t\tNS_DBG(\"address (%#x, %#x) is accepted\\n\", ns->regs.row, ns->regs.column);\n\t\t\tns_switch_state(ns);\n\t\t}\n\n\t} else {\n\t\t \n\n\t\t \n\t\tif (!(ns->state & STATE_DATAIN_MASK)) {\n\t\t\tNS_ERR(\"write_byte: data input (%#x) isn't expected, state is %s, switch to %s\\n\",\n\t\t\t       (uint)byte, ns_get_state_name(ns->state),\n\t\t\t       ns_get_state_name(STATE_READY));\n\t\t\tns_switch_to_ready_state(ns, NS_STATUS_FAILED(ns));\n\t\t\treturn;\n\t\t}\n\n\t\t \n\t\tif (ns->regs.count == ns->regs.num) {\n\t\t\tNS_WARN(\"write_byte: %u input bytes has already been accepted, ignore write\\n\",\n\t\t\t\t\tns->regs.num);\n\t\t\treturn;\n\t\t}\n\n\t\tif (ns->busw == 8) {\n\t\t\tns->buf.byte[ns->regs.count] = byte;\n\t\t\tns->regs.count += 1;\n\t\t} else {\n\t\t\tns->buf.word[ns->regs.count >> 1] = cpu_to_le16((uint16_t)byte);\n\t\t\tns->regs.count += 2;\n\t\t}\n\t}\n\n\treturn;\n}\n\nstatic void ns_nand_write_buf(struct nand_chip *chip, const u_char *buf,\n\t\t\t      int len)\n{\n\tstruct nandsim *ns = nand_get_controller_data(chip);\n\n\t \n\tif (!(ns->state & STATE_DATAIN_MASK)) {\n\t\tNS_ERR(\"write_buf: data input isn't expected, state is %s, switch to STATE_READY\\n\",\n\t\t       ns_get_state_name(ns->state));\n\t\tns_switch_to_ready_state(ns, NS_STATUS_FAILED(ns));\n\t\treturn;\n\t}\n\n\t \n\tif (ns->regs.count + len > ns->regs.num) {\n\t\tNS_ERR(\"write_buf: too many input bytes\\n\");\n\t\tns_switch_to_ready_state(ns, NS_STATUS_FAILED(ns));\n\t\treturn;\n\t}\n\n\tmemcpy(ns->buf.byte + ns->regs.count, buf, len);\n\tns->regs.count += len;\n\n\tif (ns->regs.count == ns->regs.num) {\n\t\tNS_DBG(\"write_buf: %d bytes were written\\n\", ns->regs.count);\n\t}\n}\n\nstatic void ns_nand_read_buf(struct nand_chip *chip, u_char *buf, int len)\n{\n\tstruct nandsim *ns = nand_get_controller_data(chip);\n\n\t \n\tif (!ns->lines.ce) {\n\t\tNS_ERR(\"read_buf: chip is disabled\\n\");\n\t\treturn;\n\t}\n\tif (ns->lines.ale || ns->lines.cle) {\n\t\tNS_ERR(\"read_buf: ALE or CLE pin is high\\n\");\n\t\treturn;\n\t}\n\tif (!(ns->state & STATE_DATAOUT_MASK)) {\n\t\tNS_WARN(\"read_buf: unexpected data output cycle, current state is %s\\n\",\n\t\t\tns_get_state_name(ns->state));\n\t\treturn;\n\t}\n\n\tif (NS_STATE(ns->state) != STATE_DATAOUT) {\n\t\tint i;\n\n\t\tfor (i = 0; i < len; i++)\n\t\t\tbuf[i] = ns_nand_read_byte(chip);\n\n\t\treturn;\n\t}\n\n\t \n\tif (ns->regs.count + len > ns->regs.num) {\n\t\tNS_ERR(\"read_buf: too many bytes to read\\n\");\n\t\tns_switch_to_ready_state(ns, NS_STATUS_FAILED(ns));\n\t\treturn;\n\t}\n\n\tmemcpy(buf, ns->buf.byte + ns->regs.count, len);\n\tns->regs.count += len;\n\n\tif (ns->regs.count == ns->regs.num) {\n\t\tif (NS_STATE(ns->nxstate) == STATE_READY)\n\t\t\tns_switch_state(ns);\n\t}\n\n\treturn;\n}\n\nstatic int ns_exec_op(struct nand_chip *chip, const struct nand_operation *op,\n\t\t      bool check_only)\n{\n\tint i;\n\tunsigned int op_id;\n\tconst struct nand_op_instr *instr = NULL;\n\tstruct nandsim *ns = nand_get_controller_data(chip);\n\n\tif (check_only) {\n\t\t \n\t\tfor (op_id = 0; op_id < op->ninstrs; op_id++) {\n\t\t\tinstr = &op->instrs[op_id];\n\t\t\tif (instr->type == NAND_OP_CMD_INSTR &&\n\t\t\t    (instr->ctx.cmd.opcode == NAND_CMD_READCACHEEND ||\n\t\t\t     instr->ctx.cmd.opcode == NAND_CMD_READCACHESEQ))\n\t\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tns->lines.ce = 1;\n\n\tfor (op_id = 0; op_id < op->ninstrs; op_id++) {\n\t\tinstr = &op->instrs[op_id];\n\t\tns->lines.cle = 0;\n\t\tns->lines.ale = 0;\n\n\t\tswitch (instr->type) {\n\t\tcase NAND_OP_CMD_INSTR:\n\t\t\tns->lines.cle = 1;\n\t\t\tns_nand_write_byte(chip, instr->ctx.cmd.opcode);\n\t\t\tbreak;\n\t\tcase NAND_OP_ADDR_INSTR:\n\t\t\tns->lines.ale = 1;\n\t\t\tfor (i = 0; i < instr->ctx.addr.naddrs; i++)\n\t\t\t\tns_nand_write_byte(chip, instr->ctx.addr.addrs[i]);\n\t\t\tbreak;\n\t\tcase NAND_OP_DATA_IN_INSTR:\n\t\t\tns_nand_read_buf(chip, instr->ctx.data.buf.in, instr->ctx.data.len);\n\t\t\tbreak;\n\t\tcase NAND_OP_DATA_OUT_INSTR:\n\t\t\tns_nand_write_buf(chip, instr->ctx.data.buf.out, instr->ctx.data.len);\n\t\t\tbreak;\n\t\tcase NAND_OP_WAITRDY_INSTR:\n\t\t\t \n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int ns_attach_chip(struct nand_chip *chip)\n{\n\tunsigned int eccsteps, eccbytes;\n\n\tchip->ecc.engine_type = NAND_ECC_ENGINE_TYPE_SOFT;\n\tchip->ecc.algo = bch ? NAND_ECC_ALGO_BCH : NAND_ECC_ALGO_HAMMING;\n\n\tif (!bch)\n\t\treturn 0;\n\n\tif (!IS_ENABLED(CONFIG_MTD_NAND_ECC_SW_BCH)) {\n\t\tNS_ERR(\"BCH ECC support is disabled\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\teccsteps = nsmtd->writesize / 512;\n\teccbytes = ((bch * 13) + 7) / 8;\n\n\t \n\tif (nsmtd->oobsize < 64 || !eccsteps) {\n\t\tNS_ERR(\"BCH not available on small page devices\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (((eccbytes * eccsteps) + 2) > nsmtd->oobsize) {\n\t\tNS_ERR(\"Invalid BCH value %u\\n\", bch);\n\t\treturn -EINVAL;\n\t}\n\n\tchip->ecc.size = 512;\n\tchip->ecc.strength = bch;\n\tchip->ecc.bytes = eccbytes;\n\n\tNS_INFO(\"Using %u-bit/%u bytes BCH ECC\\n\", bch, chip->ecc.size);\n\n\treturn 0;\n}\n\nstatic const struct nand_controller_ops ns_controller_ops = {\n\t.attach_chip = ns_attach_chip,\n\t.exec_op = ns_exec_op,\n};\n\n \nstatic int __init ns_init_module(void)\n{\n\tstruct list_head *pos, *n;\n\tstruct nand_chip *chip;\n\tstruct nandsim *ns;\n\tint ret;\n\n\tif (bus_width != 8 && bus_width != 16) {\n\t\tNS_ERR(\"wrong bus width (%d), use only 8 or 16\\n\", bus_width);\n\t\treturn -EINVAL;\n\t}\n\n\tns = kzalloc(sizeof(struct nandsim), GFP_KERNEL);\n\tif (!ns) {\n\t\tNS_ERR(\"unable to allocate core structures.\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tchip\t    = &ns->chip;\n\tnsmtd       = nand_to_mtd(chip);\n\tnand_set_controller_data(chip, (void *)ns);\n\n\t \n\t \n\tchip->options   |= NAND_SKIP_BBTSCAN;\n\n\tswitch (bbt) {\n\tcase 2:\n\t\tchip->bbt_options |= NAND_BBT_NO_OOB;\n\t\tfallthrough;\n\tcase 1:\n\t\tchip->bbt_options |= NAND_BBT_USE_FLASH;\n\t\tfallthrough;\n\tcase 0:\n\t\tbreak;\n\tdefault:\n\t\tNS_ERR(\"bbt has to be 0..2\\n\");\n\t\tret = -EINVAL;\n\t\tgoto free_ns_struct;\n\t}\n\t \n\tif (id_bytes[6] != 0xFF || id_bytes[7] != 0xFF)\n\t\tns->geom.idbytes = 8;\n\telse if (id_bytes[4] != 0xFF || id_bytes[5] != 0xFF)\n\t\tns->geom.idbytes = 6;\n\telse if (id_bytes[2] != 0xFF || id_bytes[3] != 0xFF)\n\t\tns->geom.idbytes = 4;\n\telse\n\t\tns->geom.idbytes = 2;\n\tns->regs.status = NS_STATUS_OK(ns);\n\tns->nxstate = STATE_UNKNOWN;\n\tns->options |= OPT_PAGE512;  \n\tmemcpy(ns->ids, id_bytes, sizeof(ns->ids));\n\tif (bus_width == 16) {\n\t\tns->busw = 16;\n\t\tchip->options |= NAND_BUSWIDTH_16;\n\t}\n\n\tnsmtd->owner = THIS_MODULE;\n\n\tret = ns_parse_weakblocks();\n\tif (ret)\n\t\tgoto free_ns_struct;\n\n\tret = ns_parse_weakpages();\n\tif (ret)\n\t\tgoto free_wb_list;\n\n\tret = ns_parse_gravepages();\n\tif (ret)\n\t\tgoto free_wp_list;\n\n\tnand_controller_init(&ns->base);\n\tns->base.ops = &ns_controller_ops;\n\tchip->controller = &ns->base;\n\n\tret = nand_scan(chip, 1);\n\tif (ret) {\n\t\tNS_ERR(\"Could not scan NAND Simulator device\\n\");\n\t\tgoto free_gp_list;\n\t}\n\n\tif (overridesize) {\n\t\tuint64_t new_size = (uint64_t)nsmtd->erasesize << overridesize;\n\t\tstruct nand_memory_organization *memorg;\n\t\tu64 targetsize;\n\n\t\tmemorg = nanddev_get_memorg(&chip->base);\n\n\t\tif (new_size >> overridesize != nsmtd->erasesize) {\n\t\t\tNS_ERR(\"overridesize is too big\\n\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto cleanup_nand;\n\t\t}\n\n\t\t \n\t\tnsmtd->size = new_size;\n\t\tmemorg->eraseblocks_per_lun = 1 << overridesize;\n\t\ttargetsize = nanddev_target_size(&chip->base);\n\t\tchip->chip_shift = ffs(nsmtd->erasesize) + overridesize - 1;\n\t\tchip->pagemask = (targetsize >> chip->page_shift) - 1;\n\t}\n\n\tret = ns_setup_wear_reporting(nsmtd);\n\tif (ret)\n\t\tgoto cleanup_nand;\n\n\tret = ns_init(nsmtd);\n\tif (ret)\n\t\tgoto free_ebw;\n\n\tret = nand_create_bbt(chip);\n\tif (ret)\n\t\tgoto free_ns_object;\n\n\tret = ns_parse_badblocks(ns, nsmtd);\n\tif (ret)\n\t\tgoto free_ns_object;\n\n\t \n\tret = mtd_device_register(nsmtd, &ns->partitions[0], ns->nbparts);\n\tif (ret)\n\t\tgoto free_ns_object;\n\n\tret = ns_debugfs_create(ns);\n\tif (ret)\n\t\tgoto unregister_mtd;\n\n        return 0;\n\nunregister_mtd:\n\tWARN_ON(mtd_device_unregister(nsmtd));\nfree_ns_object:\n\tns_free(ns);\nfree_ebw:\n\tkfree(erase_block_wear);\ncleanup_nand:\n\tnand_cleanup(chip);\nfree_gp_list:\n\tlist_for_each_safe(pos, n, &grave_pages) {\n\t\tlist_del(pos);\n\t\tkfree(list_entry(pos, struct grave_page, list));\n\t}\nfree_wp_list:\n\tlist_for_each_safe(pos, n, &weak_pages) {\n\t\tlist_del(pos);\n\t\tkfree(list_entry(pos, struct weak_page, list));\n\t}\nfree_wb_list:\n\tlist_for_each_safe(pos, n, &weak_blocks) {\n\t\tlist_del(pos);\n\t\tkfree(list_entry(pos, struct weak_block, list));\n\t}\nfree_ns_struct:\n\tkfree(ns);\n\n\treturn ret;\n}\n\nmodule_init(ns_init_module);\n\n \nstatic void __exit ns_cleanup_module(void)\n{\n\tstruct nand_chip *chip = mtd_to_nand(nsmtd);\n\tstruct nandsim *ns = nand_get_controller_data(chip);\n\tstruct list_head *pos, *n;\n\n\tns_debugfs_remove(ns);\n\tWARN_ON(mtd_device_unregister(nsmtd));\n\tns_free(ns);\n\tkfree(erase_block_wear);\n\tnand_cleanup(chip);\n\n\tlist_for_each_safe(pos, n, &grave_pages) {\n\t\tlist_del(pos);\n\t\tkfree(list_entry(pos, struct grave_page, list));\n\t}\n\n\tlist_for_each_safe(pos, n, &weak_pages) {\n\t\tlist_del(pos);\n\t\tkfree(list_entry(pos, struct weak_page, list));\n\t}\n\n\tlist_for_each_safe(pos, n, &weak_blocks) {\n\t\tlist_del(pos);\n\t\tkfree(list_entry(pos, struct weak_block, list));\n\t}\n\n\tkfree(ns);\n}\n\nmodule_exit(ns_cleanup_module);\n\nMODULE_LICENSE (\"GPL\");\nMODULE_AUTHOR (\"Artem B. Bityuckiy\");\nMODULE_DESCRIPTION (\"The NAND flash simulator\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}