{
  "module_name": "tegra_nand.c",
  "hash_id": "c4c67acf1120a95d1e8542e3fc90943853324fcbc3d4a9737d570f93e23630c9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/nand/raw/tegra_nand.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/completion.h>\n#include <linux/dma-mapping.h>\n#include <linux/err.h>\n#include <linux/gpio/consumer.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/mtd/partitions.h>\n#include <linux/mtd/rawnand.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/reset.h>\n\n#include <soc/tegra/common.h>\n\n#define COMMAND\t\t\t\t\t0x00\n#define   COMMAND_GO\t\t\t\tBIT(31)\n#define   COMMAND_CLE\t\t\t\tBIT(30)\n#define   COMMAND_ALE\t\t\t\tBIT(29)\n#define   COMMAND_PIO\t\t\t\tBIT(28)\n#define   COMMAND_TX\t\t\t\tBIT(27)\n#define   COMMAND_RX\t\t\t\tBIT(26)\n#define   COMMAND_SEC_CMD\t\t\tBIT(25)\n#define   COMMAND_AFT_DAT\t\t\tBIT(24)\n#define   COMMAND_TRANS_SIZE(size)\t\t((((size) - 1) & 0xf) << 20)\n#define   COMMAND_A_VALID\t\t\tBIT(19)\n#define   COMMAND_B_VALID\t\t\tBIT(18)\n#define   COMMAND_RD_STATUS_CHK\t\t\tBIT(17)\n#define   COMMAND_RBSY_CHK\t\t\tBIT(16)\n#define   COMMAND_CE(x)\t\t\t\tBIT(8 + ((x) & 0x7))\n#define   COMMAND_CLE_SIZE(size)\t\t((((size) - 1) & 0x3) << 4)\n#define   COMMAND_ALE_SIZE(size)\t\t((((size) - 1) & 0xf) << 0)\n\n#define STATUS\t\t\t\t\t0x04\n\n#define ISR\t\t\t\t\t0x08\n#define   ISR_CORRFAIL_ERR\t\t\tBIT(24)\n#define   ISR_UND\t\t\t\tBIT(7)\n#define   ISR_OVR\t\t\t\tBIT(6)\n#define   ISR_CMD_DONE\t\t\t\tBIT(5)\n#define   ISR_ECC_ERR\t\t\t\tBIT(4)\n\n#define IER\t\t\t\t\t0x0c\n#define   IER_ERR_TRIG_VAL(x)\t\t\t(((x) & 0xf) << 16)\n#define   IER_UND\t\t\t\tBIT(7)\n#define   IER_OVR\t\t\t\tBIT(6)\n#define   IER_CMD_DONE\t\t\t\tBIT(5)\n#define   IER_ECC_ERR\t\t\t\tBIT(4)\n#define   IER_GIE\t\t\t\tBIT(0)\n\n#define CONFIG\t\t\t\t\t0x10\n#define   CONFIG_HW_ECC\t\t\t\tBIT(31)\n#define   CONFIG_ECC_SEL\t\t\tBIT(30)\n#define   CONFIG_ERR_COR\t\t\tBIT(29)\n#define   CONFIG_PIPE_EN\t\t\tBIT(28)\n#define   CONFIG_TVAL_4\t\t\t\t(0 << 24)\n#define   CONFIG_TVAL_6\t\t\t\t(1 << 24)\n#define   CONFIG_TVAL_8\t\t\t\t(2 << 24)\n#define   CONFIG_SKIP_SPARE\t\t\tBIT(23)\n#define   CONFIG_BUS_WIDTH_16\t\t\tBIT(21)\n#define   CONFIG_COM_BSY\t\t\tBIT(20)\n#define   CONFIG_PS_256\t\t\t\t(0 << 16)\n#define   CONFIG_PS_512\t\t\t\t(1 << 16)\n#define   CONFIG_PS_1024\t\t\t(2 << 16)\n#define   CONFIG_PS_2048\t\t\t(3 << 16)\n#define   CONFIG_PS_4096\t\t\t(4 << 16)\n#define   CONFIG_SKIP_SPARE_SIZE_4\t\t(0 << 14)\n#define   CONFIG_SKIP_SPARE_SIZE_8\t\t(1 << 14)\n#define   CONFIG_SKIP_SPARE_SIZE_12\t\t(2 << 14)\n#define   CONFIG_SKIP_SPARE_SIZE_16\t\t(3 << 14)\n#define   CONFIG_TAG_BYTE_SIZE(x)\t\t\t((x) & 0xff)\n\n#define TIMING_1\t\t\t\t0x14\n#define   TIMING_TRP_RESP(x)\t\t\t(((x) & 0xf) << 28)\n#define   TIMING_TWB(x)\t\t\t\t(((x) & 0xf) << 24)\n#define   TIMING_TCR_TAR_TRR(x)\t\t\t(((x) & 0xf) << 20)\n#define   TIMING_TWHR(x)\t\t\t(((x) & 0xf) << 16)\n#define   TIMING_TCS(x)\t\t\t\t(((x) & 0x3) << 14)\n#define   TIMING_TWH(x)\t\t\t\t(((x) & 0x3) << 12)\n#define   TIMING_TWP(x)\t\t\t\t(((x) & 0xf) <<  8)\n#define   TIMING_TRH(x)\t\t\t\t(((x) & 0x3) <<  4)\n#define   TIMING_TRP(x)\t\t\t\t(((x) & 0xf) <<  0)\n\n#define RESP\t\t\t\t\t0x18\n\n#define TIMING_2\t\t\t\t0x1c\n#define   TIMING_TADL(x)\t\t\t((x) & 0xf)\n\n#define CMD_REG1\t\t\t\t0x20\n#define CMD_REG2\t\t\t\t0x24\n#define ADDR_REG1\t\t\t\t0x28\n#define ADDR_REG2\t\t\t\t0x2c\n\n#define DMA_MST_CTRL\t\t\t\t0x30\n#define   DMA_MST_CTRL_GO\t\t\tBIT(31)\n#define   DMA_MST_CTRL_IN\t\t\t(0 << 30)\n#define   DMA_MST_CTRL_OUT\t\t\tBIT(30)\n#define   DMA_MST_CTRL_PERF_EN\t\t\tBIT(29)\n#define   DMA_MST_CTRL_IE_DONE\t\t\tBIT(28)\n#define   DMA_MST_CTRL_REUSE\t\t\tBIT(27)\n#define   DMA_MST_CTRL_BURST_1\t\t\t(2 << 24)\n#define   DMA_MST_CTRL_BURST_4\t\t\t(3 << 24)\n#define   DMA_MST_CTRL_BURST_8\t\t\t(4 << 24)\n#define   DMA_MST_CTRL_BURST_16\t\t\t(5 << 24)\n#define   DMA_MST_CTRL_IS_DONE\t\t\tBIT(20)\n#define   DMA_MST_CTRL_EN_A\t\t\tBIT(2)\n#define   DMA_MST_CTRL_EN_B\t\t\tBIT(1)\n\n#define DMA_CFG_A\t\t\t\t0x34\n#define DMA_CFG_B\t\t\t\t0x38\n\n#define FIFO_CTRL\t\t\t\t0x3c\n#define   FIFO_CTRL_CLR_ALL\t\t\tBIT(3)\n\n#define DATA_PTR\t\t\t\t0x40\n#define TAG_PTR\t\t\t\t\t0x44\n#define ECC_PTR\t\t\t\t\t0x48\n\n#define DEC_STATUS\t\t\t\t0x4c\n#define   DEC_STATUS_A_ECC_FAIL\t\t\tBIT(1)\n#define   DEC_STATUS_ERR_COUNT_MASK\t\t0x00ff0000\n#define   DEC_STATUS_ERR_COUNT_SHIFT\t\t16\n\n#define HWSTATUS_CMD\t\t\t\t0x50\n#define HWSTATUS_MASK\t\t\t\t0x54\n#define   HWSTATUS_RDSTATUS_MASK(x)\t\t(((x) & 0xff) << 24)\n#define   HWSTATUS_RDSTATUS_VALUE(x)\t\t(((x) & 0xff) << 16)\n#define   HWSTATUS_RBSY_MASK(x)\t\t\t(((x) & 0xff) << 8)\n#define   HWSTATUS_RBSY_VALUE(x)\t\t(((x) & 0xff) << 0)\n\n#define BCH_CONFIG\t\t\t\t0xcc\n#define   BCH_ENABLE\t\t\t\tBIT(0)\n#define   BCH_TVAL_4\t\t\t\t(0 << 4)\n#define   BCH_TVAL_8\t\t\t\t(1 << 4)\n#define   BCH_TVAL_14\t\t\t\t(2 << 4)\n#define   BCH_TVAL_16\t\t\t\t(3 << 4)\n\n#define DEC_STAT_RESULT\t\t\t\t0xd0\n#define DEC_STAT_BUF\t\t\t\t0xd4\n#define   DEC_STAT_BUF_FAIL_SEC_FLAG_MASK\t0xff000000\n#define   DEC_STAT_BUF_FAIL_SEC_FLAG_SHIFT\t24\n#define   DEC_STAT_BUF_CORR_SEC_FLAG_MASK\t0x00ff0000\n#define   DEC_STAT_BUF_CORR_SEC_FLAG_SHIFT\t16\n#define   DEC_STAT_BUF_MAX_CORR_CNT_MASK\t0x00001f00\n#define   DEC_STAT_BUF_MAX_CORR_CNT_SHIFT\t8\n\n#define OFFSET(val, off)\t((val) < (off) ? 0 : (val) - (off))\n\n#define SKIP_SPARE_BYTES\t4\n#define BITS_PER_STEP_RS\t18\n#define BITS_PER_STEP_BCH\t13\n\n#define INT_MASK\t\t(IER_UND | IER_OVR | IER_CMD_DONE | IER_GIE)\n#define HWSTATUS_CMD_DEFAULT\tNAND_STATUS_READY\n#define HWSTATUS_MASK_DEFAULT\t(HWSTATUS_RDSTATUS_MASK(1) | \\\n\t\t\t\tHWSTATUS_RDSTATUS_VALUE(0) | \\\n\t\t\t\tHWSTATUS_RBSY_MASK(NAND_STATUS_READY) | \\\n\t\t\t\tHWSTATUS_RBSY_VALUE(NAND_STATUS_READY))\n\nstruct tegra_nand_controller {\n\tstruct nand_controller controller;\n\tstruct device *dev;\n\tvoid __iomem *regs;\n\tint irq;\n\tstruct clk *clk;\n\tstruct completion command_complete;\n\tstruct completion dma_complete;\n\tbool last_read_error;\n\tint cur_cs;\n\tstruct nand_chip *chip;\n};\n\nstruct tegra_nand_chip {\n\tstruct nand_chip chip;\n\tstruct gpio_desc *wp_gpio;\n\tstruct mtd_oob_region ecc;\n\tu32 config;\n\tu32 config_ecc;\n\tu32 bch_config;\n\tint cs[1];\n};\n\nstatic inline struct tegra_nand_controller *\n\t\t\tto_tegra_ctrl(struct nand_controller *hw_ctrl)\n{\n\treturn container_of(hw_ctrl, struct tegra_nand_controller, controller);\n}\n\nstatic inline struct tegra_nand_chip *to_tegra_chip(struct nand_chip *chip)\n{\n\treturn container_of(chip, struct tegra_nand_chip, chip);\n}\n\nstatic int tegra_nand_ooblayout_rs_ecc(struct mtd_info *mtd, int section,\n\t\t\t\t       struct mtd_oob_region *oobregion)\n{\n\tstruct nand_chip *chip = mtd_to_nand(mtd);\n\tint bytes_per_step = DIV_ROUND_UP(BITS_PER_STEP_RS * chip->ecc.strength,\n\t\t\t\t\t  BITS_PER_BYTE);\n\n\tif (section > 0)\n\t\treturn -ERANGE;\n\n\toobregion->offset = SKIP_SPARE_BYTES;\n\toobregion->length = round_up(bytes_per_step * chip->ecc.steps, 4);\n\n\treturn 0;\n}\n\nstatic int tegra_nand_ooblayout_no_free(struct mtd_info *mtd, int section,\n\t\t\t\t\tstruct mtd_oob_region *oobregion)\n{\n\treturn -ERANGE;\n}\n\nstatic const struct mtd_ooblayout_ops tegra_nand_oob_rs_ops = {\n\t.ecc = tegra_nand_ooblayout_rs_ecc,\n\t.free = tegra_nand_ooblayout_no_free,\n};\n\nstatic int tegra_nand_ooblayout_bch_ecc(struct mtd_info *mtd, int section,\n\t\t\t\t\tstruct mtd_oob_region *oobregion)\n{\n\tstruct nand_chip *chip = mtd_to_nand(mtd);\n\tint bytes_per_step = DIV_ROUND_UP(BITS_PER_STEP_BCH * chip->ecc.strength,\n\t\t\t\t\t  BITS_PER_BYTE);\n\n\tif (section > 0)\n\t\treturn -ERANGE;\n\n\toobregion->offset = SKIP_SPARE_BYTES;\n\toobregion->length = round_up(bytes_per_step * chip->ecc.steps, 4);\n\n\treturn 0;\n}\n\nstatic const struct mtd_ooblayout_ops tegra_nand_oob_bch_ops = {\n\t.ecc = tegra_nand_ooblayout_bch_ecc,\n\t.free = tegra_nand_ooblayout_no_free,\n};\n\nstatic irqreturn_t tegra_nand_irq(int irq, void *data)\n{\n\tstruct tegra_nand_controller *ctrl = data;\n\tu32 isr, dma;\n\n\tisr = readl_relaxed(ctrl->regs + ISR);\n\tdma = readl_relaxed(ctrl->regs + DMA_MST_CTRL);\n\tdev_dbg(ctrl->dev, \"isr %08x\\n\", isr);\n\n\tif (!isr && !(dma & DMA_MST_CTRL_IS_DONE))\n\t\treturn IRQ_NONE;\n\n\t \n\tif (isr & ISR_CORRFAIL_ERR)\n\t\tctrl->last_read_error = true;\n\n\tif (isr & ISR_CMD_DONE)\n\t\tcomplete(&ctrl->command_complete);\n\n\tif (isr & ISR_UND)\n\t\tdev_err(ctrl->dev, \"FIFO underrun\\n\");\n\n\tif (isr & ISR_OVR)\n\t\tdev_err(ctrl->dev, \"FIFO overrun\\n\");\n\n\t \n\tif (dma & DMA_MST_CTRL_IS_DONE) {\n\t\twritel_relaxed(dma, ctrl->regs + DMA_MST_CTRL);\n\t\tcomplete(&ctrl->dma_complete);\n\t}\n\n\t \n\twritel_relaxed(isr, ctrl->regs + ISR);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic const char * const tegra_nand_reg_names[] = {\n\t\"COMMAND\",\n\t\"STATUS\",\n\t\"ISR\",\n\t\"IER\",\n\t\"CONFIG\",\n\t\"TIMING\",\n\tNULL,\n\t\"TIMING2\",\n\t\"CMD_REG1\",\n\t\"CMD_REG2\",\n\t\"ADDR_REG1\",\n\t\"ADDR_REG2\",\n\t\"DMA_MST_CTRL\",\n\t\"DMA_CFG_A\",\n\t\"DMA_CFG_B\",\n\t\"FIFO_CTRL\",\n};\n\nstatic void tegra_nand_dump_reg(struct tegra_nand_controller *ctrl)\n{\n\tu32 reg;\n\tint i;\n\n\tdev_err(ctrl->dev, \"Tegra NAND controller register dump\\n\");\n\tfor (i = 0; i < ARRAY_SIZE(tegra_nand_reg_names); i++) {\n\t\tconst char *reg_name = tegra_nand_reg_names[i];\n\n\t\tif (!reg_name)\n\t\t\tcontinue;\n\n\t\treg = readl_relaxed(ctrl->regs + (i * 4));\n\t\tdev_err(ctrl->dev, \"%s: 0x%08x\\n\", reg_name, reg);\n\t}\n}\n\nstatic void tegra_nand_controller_abort(struct tegra_nand_controller *ctrl)\n{\n\tu32 isr, dma;\n\n\tdisable_irq(ctrl->irq);\n\n\t \n\twritel_relaxed(0, ctrl->regs + DMA_MST_CTRL);\n\twritel_relaxed(0, ctrl->regs + COMMAND);\n\n\t \n\tisr = readl_relaxed(ctrl->regs + ISR);\n\twritel_relaxed(isr, ctrl->regs + ISR);\n\tdma = readl_relaxed(ctrl->regs + DMA_MST_CTRL);\n\twritel_relaxed(dma, ctrl->regs + DMA_MST_CTRL);\n\n\treinit_completion(&ctrl->command_complete);\n\treinit_completion(&ctrl->dma_complete);\n\n\tenable_irq(ctrl->irq);\n}\n\nstatic int tegra_nand_cmd(struct nand_chip *chip,\n\t\t\t  const struct nand_subop *subop)\n{\n\tconst struct nand_op_instr *instr;\n\tconst struct nand_op_instr *instr_data_in = NULL;\n\tstruct tegra_nand_controller *ctrl = to_tegra_ctrl(chip->controller);\n\tunsigned int op_id, size = 0, offset = 0;\n\tbool first_cmd = true;\n\tu32 reg, cmd = 0;\n\tint ret;\n\n\tfor (op_id = 0; op_id < subop->ninstrs; op_id++) {\n\t\tunsigned int naddrs, i;\n\t\tconst u8 *addrs;\n\t\tu32 addr1 = 0, addr2 = 0;\n\n\t\tinstr = &subop->instrs[op_id];\n\n\t\tswitch (instr->type) {\n\t\tcase NAND_OP_CMD_INSTR:\n\t\t\tif (first_cmd) {\n\t\t\t\tcmd |= COMMAND_CLE;\n\t\t\t\twritel_relaxed(instr->ctx.cmd.opcode,\n\t\t\t\t\t       ctrl->regs + CMD_REG1);\n\t\t\t} else {\n\t\t\t\tcmd |= COMMAND_SEC_CMD;\n\t\t\t\twritel_relaxed(instr->ctx.cmd.opcode,\n\t\t\t\t\t       ctrl->regs + CMD_REG2);\n\t\t\t}\n\t\t\tfirst_cmd = false;\n\t\t\tbreak;\n\n\t\tcase NAND_OP_ADDR_INSTR:\n\t\t\toffset = nand_subop_get_addr_start_off(subop, op_id);\n\t\t\tnaddrs = nand_subop_get_num_addr_cyc(subop, op_id);\n\t\t\taddrs = &instr->ctx.addr.addrs[offset];\n\n\t\t\tcmd |= COMMAND_ALE | COMMAND_ALE_SIZE(naddrs);\n\t\t\tfor (i = 0; i < min_t(unsigned int, 4, naddrs); i++)\n\t\t\t\taddr1 |= *addrs++ << (BITS_PER_BYTE * i);\n\t\t\tnaddrs -= i;\n\t\t\tfor (i = 0; i < min_t(unsigned int, 4, naddrs); i++)\n\t\t\t\taddr2 |= *addrs++ << (BITS_PER_BYTE * i);\n\n\t\t\twritel_relaxed(addr1, ctrl->regs + ADDR_REG1);\n\t\t\twritel_relaxed(addr2, ctrl->regs + ADDR_REG2);\n\t\t\tbreak;\n\n\t\tcase NAND_OP_DATA_IN_INSTR:\n\t\t\tsize = nand_subop_get_data_len(subop, op_id);\n\t\t\toffset = nand_subop_get_data_start_off(subop, op_id);\n\n\t\t\tcmd |= COMMAND_TRANS_SIZE(size) | COMMAND_PIO |\n\t\t\t\tCOMMAND_RX | COMMAND_A_VALID;\n\n\t\t\tinstr_data_in = instr;\n\t\t\tbreak;\n\n\t\tcase NAND_OP_DATA_OUT_INSTR:\n\t\t\tsize = nand_subop_get_data_len(subop, op_id);\n\t\t\toffset = nand_subop_get_data_start_off(subop, op_id);\n\n\t\t\tcmd |= COMMAND_TRANS_SIZE(size) | COMMAND_PIO |\n\t\t\t\tCOMMAND_TX | COMMAND_A_VALID;\n\t\t\tmemcpy(&reg, instr->ctx.data.buf.out + offset, size);\n\n\t\t\twritel_relaxed(reg, ctrl->regs + RESP);\n\t\t\tbreak;\n\n\t\tcase NAND_OP_WAITRDY_INSTR:\n\t\t\tcmd |= COMMAND_RBSY_CHK;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tcmd |= COMMAND_GO | COMMAND_CE(ctrl->cur_cs);\n\twritel_relaxed(cmd, ctrl->regs + COMMAND);\n\tret = wait_for_completion_timeout(&ctrl->command_complete,\n\t\t\t\t\t  msecs_to_jiffies(500));\n\tif (!ret) {\n\t\tdev_err(ctrl->dev, \"COMMAND timeout\\n\");\n\t\ttegra_nand_dump_reg(ctrl);\n\t\ttegra_nand_controller_abort(ctrl);\n\t\treturn -ETIMEDOUT;\n\t}\n\n\tif (instr_data_in) {\n\t\treg = readl_relaxed(ctrl->regs + RESP);\n\t\tmemcpy(instr_data_in->ctx.data.buf.in + offset, &reg, size);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct nand_op_parser tegra_nand_op_parser = NAND_OP_PARSER(\n\tNAND_OP_PARSER_PATTERN(tegra_nand_cmd,\n\t\tNAND_OP_PARSER_PAT_CMD_ELEM(true),\n\t\tNAND_OP_PARSER_PAT_ADDR_ELEM(true, 8),\n\t\tNAND_OP_PARSER_PAT_CMD_ELEM(true),\n\t\tNAND_OP_PARSER_PAT_WAITRDY_ELEM(true)),\n\tNAND_OP_PARSER_PATTERN(tegra_nand_cmd,\n\t\tNAND_OP_PARSER_PAT_DATA_OUT_ELEM(false, 4)),\n\tNAND_OP_PARSER_PATTERN(tegra_nand_cmd,\n\t\tNAND_OP_PARSER_PAT_CMD_ELEM(true),\n\t\tNAND_OP_PARSER_PAT_ADDR_ELEM(true, 8),\n\t\tNAND_OP_PARSER_PAT_CMD_ELEM(true),\n\t\tNAND_OP_PARSER_PAT_WAITRDY_ELEM(true),\n\t\tNAND_OP_PARSER_PAT_DATA_IN_ELEM(true, 4)),\n\t);\n\nstatic void tegra_nand_select_target(struct nand_chip *chip,\n\t\t\t\t     unsigned int die_nr)\n{\n\tstruct tegra_nand_chip *nand = to_tegra_chip(chip);\n\tstruct tegra_nand_controller *ctrl = to_tegra_ctrl(chip->controller);\n\n\tctrl->cur_cs = nand->cs[die_nr];\n}\n\nstatic int tegra_nand_exec_op(struct nand_chip *chip,\n\t\t\t      const struct nand_operation *op,\n\t\t\t      bool check_only)\n{\n\tif (!check_only)\n\t\ttegra_nand_select_target(chip, op->cs);\n\n\treturn nand_op_parser_exec_op(chip, &tegra_nand_op_parser, op,\n\t\t\t\t      check_only);\n}\n\nstatic void tegra_nand_hw_ecc(struct tegra_nand_controller *ctrl,\n\t\t\t      struct nand_chip *chip, bool enable)\n{\n\tstruct tegra_nand_chip *nand = to_tegra_chip(chip);\n\n\tif (chip->ecc.algo == NAND_ECC_ALGO_BCH && enable)\n\t\twritel_relaxed(nand->bch_config, ctrl->regs + BCH_CONFIG);\n\telse\n\t\twritel_relaxed(0, ctrl->regs + BCH_CONFIG);\n\n\tif (enable)\n\t\twritel_relaxed(nand->config_ecc, ctrl->regs + CONFIG);\n\telse\n\t\twritel_relaxed(nand->config, ctrl->regs + CONFIG);\n}\n\nstatic int tegra_nand_page_xfer(struct mtd_info *mtd, struct nand_chip *chip,\n\t\t\t\tvoid *buf, void *oob_buf, int oob_len, int page,\n\t\t\t\tbool read)\n{\n\tstruct tegra_nand_controller *ctrl = to_tegra_ctrl(chip->controller);\n\tenum dma_data_direction dir = read ? DMA_FROM_DEVICE : DMA_TO_DEVICE;\n\tdma_addr_t dma_addr = 0, dma_addr_oob = 0;\n\tu32 addr1, cmd, dma_ctrl;\n\tint ret;\n\n\ttegra_nand_select_target(chip, chip->cur_cs);\n\n\tif (read) {\n\t\twritel_relaxed(NAND_CMD_READ0, ctrl->regs + CMD_REG1);\n\t\twritel_relaxed(NAND_CMD_READSTART, ctrl->regs + CMD_REG2);\n\t} else {\n\t\twritel_relaxed(NAND_CMD_SEQIN, ctrl->regs + CMD_REG1);\n\t\twritel_relaxed(NAND_CMD_PAGEPROG, ctrl->regs + CMD_REG2);\n\t}\n\tcmd = COMMAND_CLE | COMMAND_SEC_CMD;\n\n\t \n\taddr1 = page << 16;\n\n\tif (!buf)\n\t\taddr1 |= mtd->writesize;\n\twritel_relaxed(addr1, ctrl->regs + ADDR_REG1);\n\n\tif (chip->options & NAND_ROW_ADDR_3) {\n\t\twritel_relaxed(page >> 16, ctrl->regs + ADDR_REG2);\n\t\tcmd |= COMMAND_ALE | COMMAND_ALE_SIZE(5);\n\t} else {\n\t\tcmd |= COMMAND_ALE | COMMAND_ALE_SIZE(4);\n\t}\n\n\tif (buf) {\n\t\tdma_addr = dma_map_single(ctrl->dev, buf, mtd->writesize, dir);\n\t\tret = dma_mapping_error(ctrl->dev, dma_addr);\n\t\tif (ret) {\n\t\t\tdev_err(ctrl->dev, \"dma mapping error\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\twritel_relaxed(mtd->writesize - 1, ctrl->regs + DMA_CFG_A);\n\t\twritel_relaxed(dma_addr, ctrl->regs + DATA_PTR);\n\t}\n\n\tif (oob_buf) {\n\t\tdma_addr_oob = dma_map_single(ctrl->dev, oob_buf, mtd->oobsize,\n\t\t\t\t\t      dir);\n\t\tret = dma_mapping_error(ctrl->dev, dma_addr_oob);\n\t\tif (ret) {\n\t\t\tdev_err(ctrl->dev, \"dma mapping error\\n\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto err_unmap_dma_page;\n\t\t}\n\n\t\twritel_relaxed(oob_len - 1, ctrl->regs + DMA_CFG_B);\n\t\twritel_relaxed(dma_addr_oob, ctrl->regs + TAG_PTR);\n\t}\n\n\tdma_ctrl = DMA_MST_CTRL_GO | DMA_MST_CTRL_PERF_EN |\n\t\t   DMA_MST_CTRL_IE_DONE | DMA_MST_CTRL_IS_DONE |\n\t\t   DMA_MST_CTRL_BURST_16;\n\n\tif (buf)\n\t\tdma_ctrl |= DMA_MST_CTRL_EN_A;\n\tif (oob_buf)\n\t\tdma_ctrl |= DMA_MST_CTRL_EN_B;\n\n\tif (read)\n\t\tdma_ctrl |= DMA_MST_CTRL_IN | DMA_MST_CTRL_REUSE;\n\telse\n\t\tdma_ctrl |= DMA_MST_CTRL_OUT;\n\n\twritel_relaxed(dma_ctrl, ctrl->regs + DMA_MST_CTRL);\n\n\tcmd |= COMMAND_GO | COMMAND_RBSY_CHK | COMMAND_TRANS_SIZE(9) |\n\t       COMMAND_CE(ctrl->cur_cs);\n\n\tif (buf)\n\t\tcmd |= COMMAND_A_VALID;\n\tif (oob_buf)\n\t\tcmd |= COMMAND_B_VALID;\n\n\tif (read)\n\t\tcmd |= COMMAND_RX;\n\telse\n\t\tcmd |= COMMAND_TX | COMMAND_AFT_DAT;\n\n\twritel_relaxed(cmd, ctrl->regs + COMMAND);\n\n\tret = wait_for_completion_timeout(&ctrl->command_complete,\n\t\t\t\t\t  msecs_to_jiffies(500));\n\tif (!ret) {\n\t\tdev_err(ctrl->dev, \"COMMAND timeout\\n\");\n\t\ttegra_nand_dump_reg(ctrl);\n\t\ttegra_nand_controller_abort(ctrl);\n\t\tret = -ETIMEDOUT;\n\t\tgoto err_unmap_dma;\n\t}\n\n\tret = wait_for_completion_timeout(&ctrl->dma_complete,\n\t\t\t\t\t  msecs_to_jiffies(500));\n\tif (!ret) {\n\t\tdev_err(ctrl->dev, \"DMA timeout\\n\");\n\t\ttegra_nand_dump_reg(ctrl);\n\t\ttegra_nand_controller_abort(ctrl);\n\t\tret = -ETIMEDOUT;\n\t\tgoto err_unmap_dma;\n\t}\n\tret = 0;\n\nerr_unmap_dma:\n\tif (oob_buf)\n\t\tdma_unmap_single(ctrl->dev, dma_addr_oob, mtd->oobsize, dir);\nerr_unmap_dma_page:\n\tif (buf)\n\t\tdma_unmap_single(ctrl->dev, dma_addr, mtd->writesize, dir);\n\n\treturn ret;\n}\n\nstatic int tegra_nand_read_page_raw(struct nand_chip *chip, u8 *buf,\n\t\t\t\t    int oob_required, int page)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tvoid *oob_buf = oob_required ? chip->oob_poi : NULL;\n\n\treturn tegra_nand_page_xfer(mtd, chip, buf, oob_buf,\n\t\t\t\t    mtd->oobsize, page, true);\n}\n\nstatic int tegra_nand_write_page_raw(struct nand_chip *chip, const u8 *buf,\n\t\t\t\t     int oob_required, int page)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tvoid *oob_buf = oob_required ? chip->oob_poi : NULL;\n\n\treturn tegra_nand_page_xfer(mtd, chip, (void *)buf, oob_buf,\n\t\t\t\t     mtd->oobsize, page, false);\n}\n\nstatic int tegra_nand_read_oob(struct nand_chip *chip, int page)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\n\treturn tegra_nand_page_xfer(mtd, chip, NULL, chip->oob_poi,\n\t\t\t\t    mtd->oobsize, page, true);\n}\n\nstatic int tegra_nand_write_oob(struct nand_chip *chip, int page)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\n\treturn tegra_nand_page_xfer(mtd, chip, NULL, chip->oob_poi,\n\t\t\t\t    mtd->oobsize, page, false);\n}\n\nstatic int tegra_nand_read_page_hwecc(struct nand_chip *chip, u8 *buf,\n\t\t\t\t      int oob_required, int page)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tstruct tegra_nand_controller *ctrl = to_tegra_ctrl(chip->controller);\n\tstruct tegra_nand_chip *nand = to_tegra_chip(chip);\n\tvoid *oob_buf = oob_required ? chip->oob_poi : NULL;\n\tu32 dec_stat, max_corr_cnt;\n\tunsigned long fail_sec_flag;\n\tint ret;\n\n\ttegra_nand_hw_ecc(ctrl, chip, true);\n\tret = tegra_nand_page_xfer(mtd, chip, buf, oob_buf, 0, page, true);\n\ttegra_nand_hw_ecc(ctrl, chip, false);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (!ctrl->last_read_error)\n\t\treturn 0;\n\n\t \n\tctrl->last_read_error = false;\n\tdec_stat = readl_relaxed(ctrl->regs + DEC_STAT_BUF);\n\n\tfail_sec_flag = (dec_stat & DEC_STAT_BUF_FAIL_SEC_FLAG_MASK) >>\n\t\t\tDEC_STAT_BUF_FAIL_SEC_FLAG_SHIFT;\n\n\tmax_corr_cnt = (dec_stat & DEC_STAT_BUF_MAX_CORR_CNT_MASK) >>\n\t\t       DEC_STAT_BUF_MAX_CORR_CNT_SHIFT;\n\n\tif (fail_sec_flag) {\n\t\tint bit, max_bitflips = 0;\n\n\t\t \n\t\tif (fail_sec_flag ^ GENMASK(chip->ecc.steps - 1, 0)) {\n\t\t\tmtd->ecc_stats.failed += hweight8(fail_sec_flag);\n\t\t\treturn max_corr_cnt;\n\t\t}\n\n\t\t \n\t\tret = tegra_nand_read_oob(chip, page);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tfor_each_set_bit(bit, &fail_sec_flag, chip->ecc.steps) {\n\t\t\tu8 *data = buf + (chip->ecc.size * bit);\n\t\t\tu8 *oob = chip->oob_poi + nand->ecc.offset +\n\t\t\t\t  (chip->ecc.bytes * bit);\n\n\t\t\tret = nand_check_erased_ecc_chunk(data, chip->ecc.size,\n\t\t\t\t\t\t\t  oob, chip->ecc.bytes,\n\t\t\t\t\t\t\t  NULL, 0,\n\t\t\t\t\t\t\t  chip->ecc.strength);\n\t\t\tif (ret < 0) {\n\t\t\t\tmtd->ecc_stats.failed++;\n\t\t\t} else {\n\t\t\t\tmtd->ecc_stats.corrected += ret;\n\t\t\t\tmax_bitflips = max(ret, max_bitflips);\n\t\t\t}\n\t\t}\n\n\t\treturn max_t(unsigned int, max_corr_cnt, max_bitflips);\n\t} else {\n\t\tint corr_sec_flag;\n\n\t\tcorr_sec_flag = (dec_stat & DEC_STAT_BUF_CORR_SEC_FLAG_MASK) >>\n\t\t\t\tDEC_STAT_BUF_CORR_SEC_FLAG_SHIFT;\n\n\t\t \n\t\tmtd->ecc_stats.corrected += max_corr_cnt * hweight8(corr_sec_flag);\n\n\t\treturn max_corr_cnt;\n\t}\n}\n\nstatic int tegra_nand_write_page_hwecc(struct nand_chip *chip, const u8 *buf,\n\t\t\t\t       int oob_required, int page)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tstruct tegra_nand_controller *ctrl = to_tegra_ctrl(chip->controller);\n\tvoid *oob_buf = oob_required ? chip->oob_poi : NULL;\n\tint ret;\n\n\ttegra_nand_hw_ecc(ctrl, chip, true);\n\tret = tegra_nand_page_xfer(mtd, chip, (void *)buf, oob_buf,\n\t\t\t\t   0, page, false);\n\ttegra_nand_hw_ecc(ctrl, chip, false);\n\n\treturn ret;\n}\n\nstatic void tegra_nand_setup_timing(struct tegra_nand_controller *ctrl,\n\t\t\t\t    const struct nand_sdr_timings *timings)\n{\n\t \n\tunsigned int rate = clk_get_rate(ctrl->clk) / 1000000;\n\tunsigned int period = DIV_ROUND_UP(1000000, rate);\n\tu32 val, reg = 0;\n\n\tval = DIV_ROUND_UP(max3(timings->tAR_min, timings->tRR_min,\n\t\t\t\ttimings->tRC_min), period);\n\treg |= TIMING_TCR_TAR_TRR(OFFSET(val, 3));\n\n\tval = DIV_ROUND_UP(max(max(timings->tCS_min, timings->tCH_min),\n\t\t\t       max(timings->tALS_min, timings->tALH_min)),\n\t\t\t   period);\n\treg |= TIMING_TCS(OFFSET(val, 2));\n\n\tval = DIV_ROUND_UP(max(timings->tRP_min, timings->tREA_max) + 6000,\n\t\t\t   period);\n\treg |= TIMING_TRP(OFFSET(val, 1)) | TIMING_TRP_RESP(OFFSET(val, 1));\n\n\treg |= TIMING_TWB(OFFSET(DIV_ROUND_UP(timings->tWB_max, period), 1));\n\treg |= TIMING_TWHR(OFFSET(DIV_ROUND_UP(timings->tWHR_min, period), 1));\n\treg |= TIMING_TWH(OFFSET(DIV_ROUND_UP(timings->tWH_min, period), 1));\n\treg |= TIMING_TWP(OFFSET(DIV_ROUND_UP(timings->tWP_min, period), 1));\n\treg |= TIMING_TRH(OFFSET(DIV_ROUND_UP(timings->tREH_min, period), 1));\n\n\twritel_relaxed(reg, ctrl->regs + TIMING_1);\n\n\tval = DIV_ROUND_UP(timings->tADL_min, period);\n\treg = TIMING_TADL(OFFSET(val, 3));\n\n\twritel_relaxed(reg, ctrl->regs + TIMING_2);\n}\n\nstatic int tegra_nand_setup_interface(struct nand_chip *chip, int csline,\n\t\t\t\t      const struct nand_interface_config *conf)\n{\n\tstruct tegra_nand_controller *ctrl = to_tegra_ctrl(chip->controller);\n\tconst struct nand_sdr_timings *timings;\n\n\ttimings = nand_get_sdr_timings(conf);\n\tif (IS_ERR(timings))\n\t\treturn PTR_ERR(timings);\n\n\tif (csline == NAND_DATA_IFACE_CHECK_ONLY)\n\t\treturn 0;\n\n\ttegra_nand_setup_timing(ctrl, timings);\n\n\treturn 0;\n}\n\nstatic const int rs_strength_bootable[] = { 4 };\nstatic const int rs_strength[] = { 4, 6, 8 };\nstatic const int bch_strength_bootable[] = { 8, 16 };\nstatic const int bch_strength[] = { 4, 8, 14, 16 };\n\nstatic int tegra_nand_get_strength(struct nand_chip *chip, const int *strength,\n\t\t\t\t   int strength_len, int bits_per_step,\n\t\t\t\t   int oobsize)\n{\n\tstruct nand_device *base = mtd_to_nanddev(nand_to_mtd(chip));\n\tconst struct nand_ecc_props *requirements =\n\t\tnanddev_get_ecc_requirements(base);\n\tbool maximize = base->ecc.user_conf.flags & NAND_ECC_MAXIMIZE_STRENGTH;\n\tint i;\n\n\t \n\tfor (i = 0; i < strength_len; i++) {\n\t\tint strength_sel, bytes_per_step, bytes_per_page;\n\n\t\tif (maximize) {\n\t\t\tstrength_sel = strength[strength_len - i - 1];\n\t\t} else {\n\t\t\tstrength_sel = strength[i];\n\n\t\t\tif (strength_sel < requirements->strength)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tbytes_per_step = DIV_ROUND_UP(bits_per_step * strength_sel,\n\t\t\t\t\t      BITS_PER_BYTE);\n\t\tbytes_per_page = round_up(bytes_per_step * chip->ecc.steps, 4);\n\n\t\t \n\t\tif (bytes_per_page < (oobsize - SKIP_SPARE_BYTES))\n\t\t\treturn strength_sel;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int tegra_nand_select_strength(struct nand_chip *chip, int oobsize)\n{\n\tconst int *strength;\n\tint strength_len, bits_per_step;\n\n\tswitch (chip->ecc.algo) {\n\tcase NAND_ECC_ALGO_RS:\n\t\tbits_per_step = BITS_PER_STEP_RS;\n\t\tif (chip->options & NAND_IS_BOOT_MEDIUM) {\n\t\t\tstrength = rs_strength_bootable;\n\t\t\tstrength_len = ARRAY_SIZE(rs_strength_bootable);\n\t\t} else {\n\t\t\tstrength = rs_strength;\n\t\t\tstrength_len = ARRAY_SIZE(rs_strength);\n\t\t}\n\t\tbreak;\n\tcase NAND_ECC_ALGO_BCH:\n\t\tbits_per_step = BITS_PER_STEP_BCH;\n\t\tif (chip->options & NAND_IS_BOOT_MEDIUM) {\n\t\t\tstrength = bch_strength_bootable;\n\t\t\tstrength_len = ARRAY_SIZE(bch_strength_bootable);\n\t\t} else {\n\t\t\tstrength = bch_strength;\n\t\t\tstrength_len = ARRAY_SIZE(bch_strength);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn tegra_nand_get_strength(chip, strength, strength_len,\n\t\t\t\t       bits_per_step, oobsize);\n}\n\nstatic int tegra_nand_attach_chip(struct nand_chip *chip)\n{\n\tstruct tegra_nand_controller *ctrl = to_tegra_ctrl(chip->controller);\n\tconst struct nand_ecc_props *requirements =\n\t\tnanddev_get_ecc_requirements(&chip->base);\n\tstruct tegra_nand_chip *nand = to_tegra_chip(chip);\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tint bits_per_step;\n\tint ret;\n\n\tif (chip->bbt_options & NAND_BBT_USE_FLASH)\n\t\tchip->bbt_options |= NAND_BBT_NO_OOB;\n\n\tchip->ecc.engine_type = NAND_ECC_ENGINE_TYPE_ON_HOST;\n\tchip->ecc.size = 512;\n\tchip->ecc.steps = mtd->writesize / chip->ecc.size;\n\tif (requirements->step_size != 512) {\n\t\tdev_err(ctrl->dev, \"Unsupported step size %d\\n\",\n\t\t\trequirements->step_size);\n\t\treturn -EINVAL;\n\t}\n\n\tchip->ecc.read_page = tegra_nand_read_page_hwecc;\n\tchip->ecc.write_page = tegra_nand_write_page_hwecc;\n\tchip->ecc.read_page_raw = tegra_nand_read_page_raw;\n\tchip->ecc.write_page_raw = tegra_nand_write_page_raw;\n\tchip->ecc.read_oob = tegra_nand_read_oob;\n\tchip->ecc.write_oob = tegra_nand_write_oob;\n\n\tif (chip->options & NAND_BUSWIDTH_16)\n\t\tnand->config |= CONFIG_BUS_WIDTH_16;\n\n\tif (chip->ecc.algo == NAND_ECC_ALGO_UNKNOWN) {\n\t\tif (mtd->writesize < 2048)\n\t\t\tchip->ecc.algo = NAND_ECC_ALGO_RS;\n\t\telse\n\t\t\tchip->ecc.algo = NAND_ECC_ALGO_BCH;\n\t}\n\n\tif (chip->ecc.algo == NAND_ECC_ALGO_BCH && mtd->writesize < 2048) {\n\t\tdev_err(ctrl->dev, \"BCH supports 2K or 4K page size only\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!chip->ecc.strength) {\n\t\tret = tegra_nand_select_strength(chip, mtd->oobsize);\n\t\tif (ret < 0) {\n\t\t\tdev_err(ctrl->dev,\n\t\t\t\t\"No valid strength found, minimum %d\\n\",\n\t\t\t\trequirements->strength);\n\t\t\treturn ret;\n\t\t}\n\n\t\tchip->ecc.strength = ret;\n\t}\n\n\tnand->config_ecc = CONFIG_PIPE_EN | CONFIG_SKIP_SPARE |\n\t\t\t   CONFIG_SKIP_SPARE_SIZE_4;\n\n\tswitch (chip->ecc.algo) {\n\tcase NAND_ECC_ALGO_RS:\n\t\tbits_per_step = BITS_PER_STEP_RS * chip->ecc.strength;\n\t\tmtd_set_ooblayout(mtd, &tegra_nand_oob_rs_ops);\n\t\tnand->config_ecc |= CONFIG_HW_ECC | CONFIG_ECC_SEL |\n\t\t\t\t    CONFIG_ERR_COR;\n\t\tswitch (chip->ecc.strength) {\n\t\tcase 4:\n\t\t\tnand->config_ecc |= CONFIG_TVAL_4;\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\tnand->config_ecc |= CONFIG_TVAL_6;\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tnand->config_ecc |= CONFIG_TVAL_8;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(ctrl->dev, \"ECC strength %d not supported\\n\",\n\t\t\t\tchip->ecc.strength);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase NAND_ECC_ALGO_BCH:\n\t\tbits_per_step = BITS_PER_STEP_BCH * chip->ecc.strength;\n\t\tmtd_set_ooblayout(mtd, &tegra_nand_oob_bch_ops);\n\t\tnand->bch_config = BCH_ENABLE;\n\t\tswitch (chip->ecc.strength) {\n\t\tcase 4:\n\t\t\tnand->bch_config |= BCH_TVAL_4;\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tnand->bch_config |= BCH_TVAL_8;\n\t\t\tbreak;\n\t\tcase 14:\n\t\t\tnand->bch_config |= BCH_TVAL_14;\n\t\t\tbreak;\n\t\tcase 16:\n\t\t\tnand->bch_config |= BCH_TVAL_16;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(ctrl->dev, \"ECC strength %d not supported\\n\",\n\t\t\t\tchip->ecc.strength);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tdev_err(ctrl->dev, \"ECC algorithm not supported\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdev_info(ctrl->dev, \"Using %s with strength %d per 512 byte step\\n\",\n\t\t chip->ecc.algo == NAND_ECC_ALGO_BCH ? \"BCH\" : \"RS\",\n\t\t chip->ecc.strength);\n\n\tchip->ecc.bytes = DIV_ROUND_UP(bits_per_step, BITS_PER_BYTE);\n\n\tswitch (mtd->writesize) {\n\tcase 256:\n\t\tnand->config |= CONFIG_PS_256;\n\t\tbreak;\n\tcase 512:\n\t\tnand->config |= CONFIG_PS_512;\n\t\tbreak;\n\tcase 1024:\n\t\tnand->config |= CONFIG_PS_1024;\n\t\tbreak;\n\tcase 2048:\n\t\tnand->config |= CONFIG_PS_2048;\n\t\tbreak;\n\tcase 4096:\n\t\tnand->config |= CONFIG_PS_4096;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(ctrl->dev, \"Unsupported writesize %d\\n\",\n\t\t\tmtd->writesize);\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tnand->config_ecc |= nand->config;\n\n\t \n\tnand->config |= CONFIG_TAG_BYTE_SIZE(mtd->oobsize - 1);\n\twritel_relaxed(nand->config, ctrl->regs + CONFIG);\n\n\treturn 0;\n}\n\nstatic const struct nand_controller_ops tegra_nand_controller_ops = {\n\t.attach_chip = &tegra_nand_attach_chip,\n\t.exec_op = tegra_nand_exec_op,\n\t.setup_interface = tegra_nand_setup_interface,\n};\n\nstatic int tegra_nand_chips_init(struct device *dev,\n\t\t\t\t struct tegra_nand_controller *ctrl)\n{\n\tstruct device_node *np = dev->of_node;\n\tstruct device_node *np_nand;\n\tint nsels, nchips = of_get_child_count(np);\n\tstruct tegra_nand_chip *nand;\n\tstruct mtd_info *mtd;\n\tstruct nand_chip *chip;\n\tint ret;\n\tu32 cs;\n\n\tif (nchips != 1) {\n\t\tdev_err(dev, \"Currently only one NAND chip supported\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tnp_nand = of_get_next_child(np, NULL);\n\n\tnsels = of_property_count_elems_of_size(np_nand, \"reg\", sizeof(u32));\n\tif (nsels != 1) {\n\t\tdev_err(dev, \"Missing/invalid reg property\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tret = of_property_read_u32(np_nand, \"reg\", &cs);\n\tif (ret) {\n\t\tdev_err(dev, \"could not retrieve reg property: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tnand = devm_kzalloc(dev, sizeof(*nand), GFP_KERNEL);\n\tif (!nand)\n\t\treturn -ENOMEM;\n\n\tnand->cs[0] = cs;\n\n\tnand->wp_gpio = devm_gpiod_get_optional(dev, \"wp\", GPIOD_OUT_LOW);\n\n\tif (IS_ERR(nand->wp_gpio)) {\n\t\tret = PTR_ERR(nand->wp_gpio);\n\t\tdev_err(dev, \"Failed to request WP GPIO: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tchip = &nand->chip;\n\tchip->controller = &ctrl->controller;\n\n\tmtd = nand_to_mtd(chip);\n\n\tmtd->dev.parent = dev;\n\tmtd->owner = THIS_MODULE;\n\n\tnand_set_flash_node(chip, np_nand);\n\n\tif (!mtd->name)\n\t\tmtd->name = \"tegra_nand\";\n\n\tchip->options = NAND_NO_SUBPAGE_WRITE | NAND_USES_DMA;\n\n\tret = nand_scan(chip, 1);\n\tif (ret)\n\t\treturn ret;\n\n\tmtd_ooblayout_ecc(mtd, 0, &nand->ecc);\n\n\tret = mtd_device_register(mtd, NULL, 0);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to register mtd device: %d\\n\", ret);\n\t\tnand_cleanup(chip);\n\t\treturn ret;\n\t}\n\n\tctrl->chip = chip;\n\n\treturn 0;\n}\n\nstatic int tegra_nand_probe(struct platform_device *pdev)\n{\n\tstruct reset_control *rst;\n\tstruct tegra_nand_controller *ctrl;\n\tint err = 0;\n\n\tctrl = devm_kzalloc(&pdev->dev, sizeof(*ctrl), GFP_KERNEL);\n\tif (!ctrl)\n\t\treturn -ENOMEM;\n\n\tctrl->dev = &pdev->dev;\n\tplatform_set_drvdata(pdev, ctrl);\n\tnand_controller_init(&ctrl->controller);\n\tctrl->controller.ops = &tegra_nand_controller_ops;\n\n\tctrl->regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(ctrl->regs))\n\t\treturn PTR_ERR(ctrl->regs);\n\n\trst = devm_reset_control_get(&pdev->dev, \"nand\");\n\tif (IS_ERR(rst))\n\t\treturn PTR_ERR(rst);\n\n\tctrl->clk = devm_clk_get(&pdev->dev, \"nand\");\n\tif (IS_ERR(ctrl->clk))\n\t\treturn PTR_ERR(ctrl->clk);\n\n\terr = devm_tegra_core_dev_init_opp_table_common(&pdev->dev);\n\tif (err)\n\t\treturn err;\n\n\t \n\tpm_runtime_enable(&pdev->dev);\n\terr = pm_runtime_resume_and_get(&pdev->dev);\n\tif (err)\n\t\tgoto err_dis_pm;\n\n\terr = reset_control_reset(rst);\n\tif (err) {\n\t\tdev_err(ctrl->dev, \"Failed to reset HW: %d\\n\", err);\n\t\tgoto err_put_pm;\n\t}\n\n\twritel_relaxed(HWSTATUS_CMD_DEFAULT, ctrl->regs + HWSTATUS_CMD);\n\twritel_relaxed(HWSTATUS_MASK_DEFAULT, ctrl->regs + HWSTATUS_MASK);\n\twritel_relaxed(INT_MASK, ctrl->regs + IER);\n\n\tinit_completion(&ctrl->command_complete);\n\tinit_completion(&ctrl->dma_complete);\n\n\tctrl->irq = platform_get_irq(pdev, 0);\n\tif (ctrl->irq < 0) {\n\t\terr = ctrl->irq;\n\t\tgoto err_put_pm;\n\t}\n\terr = devm_request_irq(&pdev->dev, ctrl->irq, tegra_nand_irq, 0,\n\t\t\t       dev_name(&pdev->dev), ctrl);\n\tif (err) {\n\t\tdev_err(ctrl->dev, \"Failed to get IRQ: %d\\n\", err);\n\t\tgoto err_put_pm;\n\t}\n\n\twritel_relaxed(DMA_MST_CTRL_IS_DONE, ctrl->regs + DMA_MST_CTRL);\n\n\terr = tegra_nand_chips_init(ctrl->dev, ctrl);\n\tif (err)\n\t\tgoto err_put_pm;\n\n\treturn 0;\n\nerr_put_pm:\n\tpm_runtime_put_sync_suspend(ctrl->dev);\n\tpm_runtime_force_suspend(ctrl->dev);\nerr_dis_pm:\n\tpm_runtime_disable(&pdev->dev);\n\treturn err;\n}\n\nstatic void tegra_nand_remove(struct platform_device *pdev)\n{\n\tstruct tegra_nand_controller *ctrl = platform_get_drvdata(pdev);\n\tstruct nand_chip *chip = ctrl->chip;\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\n\tWARN_ON(mtd_device_unregister(mtd));\n\n\tnand_cleanup(chip);\n\n\tpm_runtime_put_sync_suspend(ctrl->dev);\n\tpm_runtime_force_suspend(ctrl->dev);\n}\n\nstatic int __maybe_unused tegra_nand_runtime_resume(struct device *dev)\n{\n\tstruct tegra_nand_controller *ctrl = dev_get_drvdata(dev);\n\tint err;\n\n\terr = clk_prepare_enable(ctrl->clk);\n\tif (err) {\n\t\tdev_err(dev, \"Failed to enable clock: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int __maybe_unused tegra_nand_runtime_suspend(struct device *dev)\n{\n\tstruct tegra_nand_controller *ctrl = dev_get_drvdata(dev);\n\n\tclk_disable_unprepare(ctrl->clk);\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops tegra_nand_pm = {\n\tSET_RUNTIME_PM_OPS(tegra_nand_runtime_suspend, tegra_nand_runtime_resume,\n\t\t\t   NULL)\n};\n\nstatic const struct of_device_id tegra_nand_of_match[] = {\n\t{ .compatible = \"nvidia,tegra20-nand\" },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, tegra_nand_of_match);\n\nstatic struct platform_driver tegra_nand_driver = {\n\t.driver = {\n\t\t.name = \"tegra-nand\",\n\t\t.of_match_table = tegra_nand_of_match,\n\t\t.pm = &tegra_nand_pm,\n\t},\n\t.probe = tegra_nand_probe,\n\t.remove_new = tegra_nand_remove,\n};\nmodule_platform_driver(tegra_nand_driver);\n\nMODULE_DESCRIPTION(\"NVIDIA Tegra NAND driver\");\nMODULE_AUTHOR(\"Thierry Reding <thierry.reding@nvidia.com>\");\nMODULE_AUTHOR(\"Lucas Stach <dev@lynxeye.de>\");\nMODULE_AUTHOR(\"Stefan Agner <stefan@agner.ch>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}