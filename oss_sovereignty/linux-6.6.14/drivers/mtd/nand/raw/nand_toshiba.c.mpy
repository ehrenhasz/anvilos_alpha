{
  "module_name": "nand_toshiba.c",
  "hash_id": "ab2cac5e83647c0bc8db767f4a08fe0fc77ee6e77a43528ff8d7589d6c8fd2f3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/nand/raw/nand_toshiba.c",
  "human_readable_source": "\n \n\n#include \"internals.h\"\n\n \n#define TOSHIBA_NAND_ID4_IS_BENAND\t\tBIT(7)\n\n \n#define TOSHIBA_NAND_STATUS_REWRITE_RECOMMENDED\tBIT(3)\n\n \n#define TOSHIBA_NAND_CMD_ECC_STATUS_READ\t0x7A\n\n \n#define TOSHIBA_NAND_ECC_STATUS_MASK\t\t0x0F\n\n \n#define TOSHIBA_NAND_ECC_STATUS_UNCORR\t\t0x0F\n\n \n#define TOSHIBA_NAND_MAX_ECC_STEPS\t\t8\n\nstatic int toshiba_nand_benand_read_eccstatus_op(struct nand_chip *chip,\n\t\t\t\t\t\t u8 *buf)\n{\n\tu8 *ecc_status = buf;\n\n\tif (nand_has_exec_op(chip)) {\n\t\tconst struct nand_sdr_timings *sdr =\n\t\t\tnand_get_sdr_timings(nand_get_interface_config(chip));\n\t\tstruct nand_op_instr instrs[] = {\n\t\t\tNAND_OP_CMD(TOSHIBA_NAND_CMD_ECC_STATUS_READ,\n\t\t\t\t    PSEC_TO_NSEC(sdr->tADL_min)),\n\t\t\tNAND_OP_8BIT_DATA_IN(chip->ecc.steps, ecc_status, 0),\n\t\t};\n\t\tstruct nand_operation op = NAND_OPERATION(chip->cur_cs, instrs);\n\n\t\treturn nand_exec_op(chip, &op);\n\t}\n\n\treturn -ENOTSUPP;\n}\n\nstatic int toshiba_nand_benand_eccstatus(struct nand_chip *chip)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tint ret;\n\tunsigned int max_bitflips = 0;\n\tu8 status, ecc_status[TOSHIBA_NAND_MAX_ECC_STEPS];\n\n\t \n\tret = toshiba_nand_benand_read_eccstatus_op(chip, ecc_status);\n\tif (!ret) {\n\t\tunsigned int i, bitflips = 0;\n\n\t\tfor (i = 0; i < chip->ecc.steps; i++) {\n\t\t\tbitflips = ecc_status[i] & TOSHIBA_NAND_ECC_STATUS_MASK;\n\t\t\tif (bitflips == TOSHIBA_NAND_ECC_STATUS_UNCORR) {\n\t\t\t\tmtd->ecc_stats.failed++;\n\t\t\t} else {\n\t\t\t\tmtd->ecc_stats.corrected += bitflips;\n\t\t\t\tmax_bitflips = max(max_bitflips, bitflips);\n\t\t\t}\n\t\t}\n\n\t\treturn max_bitflips;\n\t}\n\n\t \n\tret = nand_status_op(chip, &status);\n\tif (ret)\n\t\treturn ret;\n\n\tif (status & NAND_STATUS_FAIL) {\n\t\t \n\t\tmtd->ecc_stats.failed++;\n\t} else if (status & TOSHIBA_NAND_STATUS_REWRITE_RECOMMENDED) {\n\t\t \n\t\tmax_bitflips = mtd->bitflip_threshold;\n\t\tmtd->ecc_stats.corrected += max_bitflips;\n\t}\n\n\treturn max_bitflips;\n}\n\nstatic int\ntoshiba_nand_read_page_benand(struct nand_chip *chip, uint8_t *buf,\n\t\t\t      int oob_required, int page)\n{\n\tint ret;\n\n\tret = nand_read_page_raw(chip, buf, oob_required, page);\n\tif (ret)\n\t\treturn ret;\n\n\treturn toshiba_nand_benand_eccstatus(chip);\n}\n\nstatic int\ntoshiba_nand_read_subpage_benand(struct nand_chip *chip, uint32_t data_offs,\n\t\t\t\t uint32_t readlen, uint8_t *bufpoi, int page)\n{\n\tint ret;\n\n\tret = nand_read_page_op(chip, page, data_offs,\n\t\t\t\tbufpoi + data_offs, readlen);\n\tif (ret)\n\t\treturn ret;\n\n\treturn toshiba_nand_benand_eccstatus(chip);\n}\n\nstatic void toshiba_nand_benand_init(struct nand_chip *chip)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\n\t \n\tchip->ecc.bytes = 0;\n\tchip->ecc.size = 512;\n\tchip->ecc.strength = 8;\n\tchip->ecc.read_page = toshiba_nand_read_page_benand;\n\tchip->ecc.read_subpage = toshiba_nand_read_subpage_benand;\n\tchip->ecc.write_page = nand_write_page_raw;\n\tchip->ecc.read_page_raw = nand_read_page_raw_notsupp;\n\tchip->ecc.write_page_raw = nand_write_page_raw_notsupp;\n\n\tchip->options |= NAND_SUBPAGE_READ;\n\n\tmtd_set_ooblayout(mtd, nand_get_large_page_ooblayout());\n}\n\nstatic void toshiba_nand_decode_id(struct nand_chip *chip)\n{\n\tstruct nand_device *base = &chip->base;\n\tstruct nand_ecc_props requirements = {};\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tstruct nand_memory_organization *memorg;\n\n\tmemorg = nanddev_get_memorg(&chip->base);\n\n\tnand_decode_ext_id(chip);\n\n\t \n\tif (chip->id.len >= 6 && nand_is_slc(chip) &&\n\t    (chip->id.data[5] & 0x7) == 0x6   &&\n\t    !(chip->id.data[4] & TOSHIBA_NAND_ID4_IS_BENAND)  ) {\n\t\tmemorg->oobsize = 32 * memorg->pagesize >> 9;\n\t\tmtd->oobsize = memorg->oobsize;\n\t}\n\n\t \n\tif (chip->id.len >= 6 && nand_is_slc(chip)) {\n\t\trequirements.step_size = 512;\n\t\tswitch (chip->id.data[5] & 0x7) {\n\t\tcase 0x4:\n\t\t\trequirements.strength = 1;\n\t\t\tbreak;\n\t\tcase 0x5:\n\t\t\trequirements.strength = 4;\n\t\t\tbreak;\n\t\tcase 0x6:\n\t\t\trequirements.strength = 8;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tWARN(1, \"Could not get ECC info\");\n\t\t\trequirements.step_size = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tnanddev_set_ecc_requirements(base, &requirements);\n}\n\nstatic int\ntc58teg5dclta00_choose_interface_config(struct nand_chip *chip,\n\t\t\t\t\tstruct nand_interface_config *iface)\n{\n\tonfi_fill_interface_config(chip, iface, NAND_SDR_IFACE, 5);\n\n\treturn nand_choose_best_sdr_timings(chip, iface, NULL);\n}\n\nstatic int\ntc58nvg0s3e_choose_interface_config(struct nand_chip *chip,\n\t\t\t\t    struct nand_interface_config *iface)\n{\n\tonfi_fill_interface_config(chip, iface, NAND_SDR_IFACE, 2);\n\n\treturn nand_choose_best_sdr_timings(chip, iface, NULL);\n}\n\nstatic int\nth58nvg2s3hbai4_choose_interface_config(struct nand_chip *chip,\n\t\t\t\t\tstruct nand_interface_config *iface)\n{\n\tstruct nand_sdr_timings *sdr = &iface->timings.sdr;\n\n\t \n\tonfi_fill_interface_config(chip, iface, NAND_SDR_IFACE, 4);\n\n\t \n\tsdr->tALS_min = 12000;\n\tsdr->tCHZ_max = 20000;\n\tsdr->tCLS_min = 12000;\n\tsdr->tCOH_min = 0;\n\tsdr->tDS_min = 12000;\n\tsdr->tRHOH_min = 25000;\n\tsdr->tRHW_min = 30000;\n\tsdr->tRHZ_max = 60000;\n\tsdr->tWHR_min = 60000;\n\n\t \n\tsdr->tPROG_max = 700000000;\n\tsdr->tBERS_max = 5000000000;\n\n\treturn nand_choose_best_sdr_timings(chip, iface, sdr);\n}\n\nstatic int tc58teg5dclta00_init(struct nand_chip *chip)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\n\tchip->ops.choose_interface_config =\n\t\t&tc58teg5dclta00_choose_interface_config;\n\tchip->options |= NAND_NEED_SCRAMBLING;\n\tmtd_set_pairing_scheme(mtd, &dist3_pairing_scheme);\n\n\treturn 0;\n}\n\nstatic int tc58nvg0s3e_init(struct nand_chip *chip)\n{\n\tchip->ops.choose_interface_config =\n\t\t&tc58nvg0s3e_choose_interface_config;\n\n\treturn 0;\n}\n\nstatic int th58nvg2s3hbai4_init(struct nand_chip *chip)\n{\n\tchip->ops.choose_interface_config =\n\t\t&th58nvg2s3hbai4_choose_interface_config;\n\n\treturn 0;\n}\n\nstatic int toshiba_nand_init(struct nand_chip *chip)\n{\n\tif (nand_is_slc(chip))\n\t\tchip->options |= NAND_BBM_FIRSTPAGE | NAND_BBM_SECONDPAGE;\n\n\t \n\tif (nand_is_slc(chip) &&\n\t    chip->ecc.engine_type == NAND_ECC_ENGINE_TYPE_ON_DIE &&\n\t    chip->id.data[4] & TOSHIBA_NAND_ID4_IS_BENAND)\n\t\ttoshiba_nand_benand_init(chip);\n\n\tif (!strcmp(\"TC58TEG5DCLTA00\", chip->parameters.model))\n\t\ttc58teg5dclta00_init(chip);\n\tif (!strncmp(\"TC58NVG0S3E\", chip->parameters.model,\n\t\t     sizeof(\"TC58NVG0S3E\") - 1))\n\t\ttc58nvg0s3e_init(chip);\n\tif ((!strncmp(\"TH58NVG2S3HBAI4\", chip->parameters.model,\n\t\t     sizeof(\"TH58NVG2S3HBAI4\") - 1)) ||\n\t    (!strncmp(\"TH58NVG3S0HBAI4\", chip->parameters.model,\n\t\t     sizeof(\"TH58NVG3S0HBAI4\") - 1)))\n\t\tth58nvg2s3hbai4_init(chip);\n\n\treturn 0;\n}\n\nconst struct nand_manufacturer_ops toshiba_nand_manuf_ops = {\n\t.detect = toshiba_nand_decode_id,\n\t.init = toshiba_nand_init,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}