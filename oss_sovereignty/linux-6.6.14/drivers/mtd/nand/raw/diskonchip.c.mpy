{
  "module_name": "diskonchip.c",
  "hash_id": "592c3981955d6f8dbc301fda864287d2ada3c2aebcfd5f84b3aefa19ee276cdb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/nand/raw/diskonchip.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/rslib.h>\n#include <linux/moduleparam.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n\n#include <linux/mtd/mtd.h>\n#include <linux/mtd/rawnand.h>\n#include <linux/mtd/doc2000.h>\n#include <linux/mtd/partitions.h>\n#include <linux/mtd/inftl.h>\n#include <linux/module.h>\n\n \n#ifndef CONFIG_MTD_NAND_DISKONCHIP_PROBE_ADDRESS\n#define CONFIG_MTD_NAND_DISKONCHIP_PROBE_ADDRESS 0\n#endif\n\nstatic unsigned long doc_locations[] __initdata = {\n#if defined (__alpha__) || defined(__i386__) || defined(__x86_64__)\n#ifdef CONFIG_MTD_NAND_DISKONCHIP_PROBE_HIGH\n\t0xfffc8000, 0xfffca000, 0xfffcc000, 0xfffce000,\n\t0xfffd0000, 0xfffd2000, 0xfffd4000, 0xfffd6000,\n\t0xfffd8000, 0xfffda000, 0xfffdc000, 0xfffde000,\n\t0xfffe0000, 0xfffe2000, 0xfffe4000, 0xfffe6000,\n\t0xfffe8000, 0xfffea000, 0xfffec000, 0xfffee000,\n#else\n\t0xc8000, 0xca000, 0xcc000, 0xce000,\n\t0xd0000, 0xd2000, 0xd4000, 0xd6000,\n\t0xd8000, 0xda000, 0xdc000, 0xde000,\n\t0xe0000, 0xe2000, 0xe4000, 0xe6000,\n\t0xe8000, 0xea000, 0xec000, 0xee000,\n#endif\n#endif\n\t0xffffffff };\n\nstatic struct mtd_info *doclist = NULL;\n\nstruct doc_priv {\n\tstruct nand_controller base;\n\tvoid __iomem *virtadr;\n\tunsigned long physadr;\n\tu_char ChipID;\n\tu_char CDSNControl;\n\tint chips_per_floor;\t \n\tint curfloor;\n\tint curchip;\n\tint mh0_page;\n\tint mh1_page;\n\tstruct rs_control *rs_decoder;\n\tstruct mtd_info *nextdoc;\n\tbool supports_32b_reads;\n\n\t \n\tint (*late_init)(struct mtd_info *mtd);\n};\n\n \nstatic u_char empty_write_ecc[6] = { 0x4b, 0x00, 0xe2, 0x0e, 0x93, 0xf7 };\n\n#define INFTL_BBT_RESERVED_BLOCKS 4\n\n#define DoC_is_MillenniumPlus(doc) ((doc)->ChipID == DOC_ChipID_DocMilPlus16 || (doc)->ChipID == DOC_ChipID_DocMilPlus32)\n#define DoC_is_Millennium(doc) ((doc)->ChipID == DOC_ChipID_DocMil)\n#define DoC_is_2000(doc) ((doc)->ChipID == DOC_ChipID_Doc2k)\n\nstatic int debug = 0;\nmodule_param(debug, int, 0);\n\nstatic int try_dword = 1;\nmodule_param(try_dword, int, 0);\n\nstatic int no_ecc_failures = 0;\nmodule_param(no_ecc_failures, int, 0);\n\nstatic int no_autopart = 0;\nmodule_param(no_autopart, int, 0);\n\nstatic int show_firmware_partition = 0;\nmodule_param(show_firmware_partition, int, 0);\n\n#ifdef CONFIG_MTD_NAND_DISKONCHIP_BBTWRITE\nstatic int inftl_bbt_write = 1;\n#else\nstatic int inftl_bbt_write = 0;\n#endif\nmodule_param(inftl_bbt_write, int, 0);\n\nstatic unsigned long doc_config_location = CONFIG_MTD_NAND_DISKONCHIP_PROBE_ADDRESS;\nmodule_param(doc_config_location, ulong, 0);\nMODULE_PARM_DESC(doc_config_location, \"Physical memory address at which to probe for DiskOnChip\");\n\n \n#define SECTOR_SIZE 512\n \n#define NB_DATA (((SECTOR_SIZE + 1) * 8 + 6) / 10)\n \n#define NROOTS 4\n \n#define FCR 510\n \n#define NN 1023\n\n \nstatic int doc_ecc_decode(struct rs_control *rs, uint8_t *data, uint8_t *ecc)\n{\n\tint i, j, nerr, errpos[8];\n\tuint8_t parity;\n\tuint16_t ds[4], s[5], tmp, errval[8], syn[4];\n\tstruct rs_codec *cd = rs->codec;\n\n\tmemset(syn, 0, sizeof(syn));\n\t \n\tds[0] = ((ecc[4] & 0xff) >> 0) | ((ecc[5] & 0x03) << 8);\n\tds[1] = ((ecc[5] & 0xfc) >> 2) | ((ecc[2] & 0x0f) << 6);\n\tds[2] = ((ecc[2] & 0xf0) >> 4) | ((ecc[3] & 0x3f) << 4);\n\tds[3] = ((ecc[3] & 0xc0) >> 6) | ((ecc[0] & 0xff) << 2);\n\tparity = ecc[1];\n\n\t \n\tfor (i = 0; i < NROOTS; i++)\n\t\ts[i] = ds[0];\n\t \n\tfor (j = 1; j < NROOTS; j++) {\n\t\tif (ds[j] == 0)\n\t\t\tcontinue;\n\t\ttmp = cd->index_of[ds[j]];\n\t\tfor (i = 0; i < NROOTS; i++)\n\t\t\ts[i] ^= cd->alpha_to[rs_modnn(cd, tmp + (FCR + i) * j)];\n\t}\n\n\t \n\tfor (i = 0; i < NROOTS; i++) {\n\t\tif (s[i])\n\t\t\tsyn[i] = rs_modnn(cd, cd->index_of[s[i]] + (NN - FCR - i));\n\t}\n\t \n\tnerr = decode_rs16(rs, NULL, NULL, 1019, syn, 0, errpos, 0, errval);\n\n\t \n\tif (nerr < 0)\n\t\treturn nerr;\n\n\t \n\tfor (i = 0; i < nerr; i++) {\n\t\tint index, bitpos, pos = 1015 - errpos[i];\n\t\tuint8_t val;\n\t\tif (pos >= NB_DATA && pos < 1019)\n\t\t\tcontinue;\n\t\tif (pos < NB_DATA) {\n\t\t\t \n\t\t\tpos = 10 * (NB_DATA - 1 - pos) - 6;\n\t\t\t \n\t\t\tindex = (pos >> 3) ^ 1;\n\t\t\tbitpos = pos & 7;\n\t\t\tif ((index >= 0 && index < SECTOR_SIZE) || index == (SECTOR_SIZE + 1)) {\n\t\t\t\tval = (uint8_t) (errval[i] >> (2 + bitpos));\n\t\t\t\tparity ^= val;\n\t\t\t\tif (index < SECTOR_SIZE)\n\t\t\t\t\tdata[index] ^= val;\n\t\t\t}\n\t\t\tindex = ((pos >> 3) + 1) ^ 1;\n\t\t\tbitpos = (bitpos + 10) & 7;\n\t\t\tif (bitpos == 0)\n\t\t\t\tbitpos = 8;\n\t\t\tif ((index >= 0 && index < SECTOR_SIZE) || index == (SECTOR_SIZE + 1)) {\n\t\t\t\tval = (uint8_t) (errval[i] << (8 - bitpos));\n\t\t\t\tparity ^= val;\n\t\t\t\tif (index < SECTOR_SIZE)\n\t\t\t\t\tdata[index] ^= val;\n\t\t\t}\n\t\t}\n\t}\n\t \n\treturn parity ? -EBADMSG : nerr;\n}\n\nstatic void DoC_Delay(struct doc_priv *doc, unsigned short cycles)\n{\n\tvolatile char __always_unused dummy;\n\tint i;\n\n\tfor (i = 0; i < cycles; i++) {\n\t\tif (DoC_is_Millennium(doc))\n\t\t\tdummy = ReadDOC(doc->virtadr, NOP);\n\t\telse if (DoC_is_MillenniumPlus(doc))\n\t\t\tdummy = ReadDOC(doc->virtadr, Mplus_NOP);\n\t\telse\n\t\t\tdummy = ReadDOC(doc->virtadr, DOCStatus);\n\t}\n\n}\n\n#define CDSN_CTRL_FR_B_MASK\t(CDSN_CTRL_FR_B0 | CDSN_CTRL_FR_B1)\n\n \nstatic int _DoC_WaitReady(struct doc_priv *doc)\n{\n\tvoid __iomem *docptr = doc->virtadr;\n\tunsigned long timeo = jiffies + (HZ * 10);\n\n\tif (debug)\n\t\tprintk(\"_DoC_WaitReady...\\n\");\n\t \n\tif (DoC_is_MillenniumPlus(doc)) {\n\t\twhile ((ReadDOC(docptr, Mplus_FlashControl) & CDSN_CTRL_FR_B_MASK) != CDSN_CTRL_FR_B_MASK) {\n\t\t\tif (time_after(jiffies, timeo)) {\n\t\t\t\tprintk(\"_DoC_WaitReady timed out.\\n\");\n\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t\tudelay(1);\n\t\t\tcond_resched();\n\t\t}\n\t} else {\n\t\twhile (!(ReadDOC(docptr, CDSNControl) & CDSN_CTRL_FR_B)) {\n\t\t\tif (time_after(jiffies, timeo)) {\n\t\t\t\tprintk(\"_DoC_WaitReady timed out.\\n\");\n\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t\tudelay(1);\n\t\t\tcond_resched();\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic inline int DoC_WaitReady(struct doc_priv *doc)\n{\n\tvoid __iomem *docptr = doc->virtadr;\n\tint ret = 0;\n\n\tif (DoC_is_MillenniumPlus(doc)) {\n\t\tDoC_Delay(doc, 4);\n\n\t\tif ((ReadDOC(docptr, Mplus_FlashControl) & CDSN_CTRL_FR_B_MASK) != CDSN_CTRL_FR_B_MASK)\n\t\t\t \n\t\t\tret = _DoC_WaitReady(doc);\n\t} else {\n\t\tDoC_Delay(doc, 4);\n\n\t\tif (!(ReadDOC(docptr, CDSNControl) & CDSN_CTRL_FR_B))\n\t\t\t \n\t\t\tret = _DoC_WaitReady(doc);\n\t\tDoC_Delay(doc, 2);\n\t}\n\n\tif (debug)\n\t\tprintk(\"DoC_WaitReady OK\\n\");\n\treturn ret;\n}\n\nstatic void doc2000_write_byte(struct nand_chip *this, u_char datum)\n{\n\tstruct doc_priv *doc = nand_get_controller_data(this);\n\tvoid __iomem *docptr = doc->virtadr;\n\n\tif (debug)\n\t\tprintk(\"write_byte %02x\\n\", datum);\n\tWriteDOC(datum, docptr, CDSNSlowIO);\n\tWriteDOC(datum, docptr, 2k_CDSN_IO);\n}\n\nstatic void doc2000_writebuf(struct nand_chip *this, const u_char *buf,\n\t\t\t     int len)\n{\n\tstruct doc_priv *doc = nand_get_controller_data(this);\n\tvoid __iomem *docptr = doc->virtadr;\n\tint i;\n\tif (debug)\n\t\tprintk(\"writebuf of %d bytes: \", len);\n\tfor (i = 0; i < len; i++) {\n\t\tWriteDOC_(buf[i], docptr, DoC_2k_CDSN_IO + i);\n\t\tif (debug && i < 16)\n\t\t\tprintk(\"%02x \", buf[i]);\n\t}\n\tif (debug)\n\t\tprintk(\"\\n\");\n}\n\nstatic void doc2000_readbuf(struct nand_chip *this, u_char *buf, int len)\n{\n\tstruct doc_priv *doc = nand_get_controller_data(this);\n\tvoid __iomem *docptr = doc->virtadr;\n\tu32 *buf32 = (u32 *)buf;\n\tint i;\n\n\tif (debug)\n\t\tprintk(\"readbuf of %d bytes: \", len);\n\n\tif (!doc->supports_32b_reads ||\n\t    ((((unsigned long)buf) | len) & 3)) {\n\t\tfor (i = 0; i < len; i++)\n\t\t\tbuf[i] = ReadDOC(docptr, 2k_CDSN_IO + i);\n\t} else {\n\t\tfor (i = 0; i < len / 4; i++)\n\t\t\tbuf32[i] = readl(docptr + DoC_2k_CDSN_IO + i);\n\t}\n}\n\n \nstatic void doc200x_readid(struct nand_chip *this, unsigned int cs, u8 *id)\n{\n\tu8 addr = 0;\n\tstruct nand_op_instr instrs[] = {\n\t\tNAND_OP_CMD(NAND_CMD_READID, 0),\n\t\tNAND_OP_ADDR(1, &addr, 50),\n\t\tNAND_OP_8BIT_DATA_IN(2, id, 0),\n\t};\n\n\tstruct nand_operation op = NAND_OPERATION(cs, instrs);\n\n\tif (!id)\n\t\top.ninstrs--;\n\n\tthis->controller->ops->exec_op(this, &op, false);\n}\n\nstatic uint16_t __init doc200x_ident_chip(struct mtd_info *mtd, int nr)\n{\n\tstruct nand_chip *this = mtd_to_nand(mtd);\n\tstruct doc_priv *doc = nand_get_controller_data(this);\n\tuint16_t ret;\n\tu8 id[2];\n\n\tdoc200x_readid(this, nr, id);\n\n\tret = ((u16)id[0] << 8) | id[1];\n\n\tif (doc->ChipID == DOC_ChipID_Doc2k && try_dword && !nr) {\n\t\t \n\t\tunion {\n\t\t\tuint32_t dword;\n\t\t\tuint8_t byte[4];\n\t\t} ident;\n\t\tvoid __iomem *docptr = doc->virtadr;\n\n\t\tdoc200x_readid(this, nr, NULL);\n\n\t\tident.dword = readl(docptr + DoC_2k_CDSN_IO);\n\t\tif (((ident.byte[0] << 8) | ident.byte[1]) == ret) {\n\t\t\tpr_info(\"DiskOnChip 2000 responds to DWORD access\\n\");\n\t\t\tdoc->supports_32b_reads = true;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic void __init doc2000_count_chips(struct mtd_info *mtd)\n{\n\tstruct nand_chip *this = mtd_to_nand(mtd);\n\tstruct doc_priv *doc = nand_get_controller_data(this);\n\tuint16_t mfrid;\n\tint i;\n\n\t \n\tdoc->chips_per_floor = 4;\n\n\t \n\tmfrid = doc200x_ident_chip(mtd, 0);\n\n\t \n\tfor (i = 1; i < 4; i++) {\n\t\tif (doc200x_ident_chip(mtd, i) != mfrid)\n\t\t\tbreak;\n\t}\n\tdoc->chips_per_floor = i;\n\tpr_debug(\"Detected %d chips per floor.\\n\", i);\n}\n\nstatic void doc2001_write_byte(struct nand_chip *this, u_char datum)\n{\n\tstruct doc_priv *doc = nand_get_controller_data(this);\n\tvoid __iomem *docptr = doc->virtadr;\n\n\tWriteDOC(datum, docptr, CDSNSlowIO);\n\tWriteDOC(datum, docptr, Mil_CDSN_IO);\n\tWriteDOC(datum, docptr, WritePipeTerm);\n}\n\nstatic void doc2001_writebuf(struct nand_chip *this, const u_char *buf, int len)\n{\n\tstruct doc_priv *doc = nand_get_controller_data(this);\n\tvoid __iomem *docptr = doc->virtadr;\n\tint i;\n\n\tfor (i = 0; i < len; i++)\n\t\tWriteDOC_(buf[i], docptr, DoC_Mil_CDSN_IO + i);\n\t \n\tWriteDOC(0x00, docptr, WritePipeTerm);\n}\n\nstatic void doc2001_readbuf(struct nand_chip *this, u_char *buf, int len)\n{\n\tstruct doc_priv *doc = nand_get_controller_data(this);\n\tvoid __iomem *docptr = doc->virtadr;\n\tint i;\n\n\t \n\tReadDOC(docptr, ReadPipeInit);\n\n\tfor (i = 0; i < len - 1; i++)\n\t\tbuf[i] = ReadDOC(docptr, Mil_CDSN_IO + (i & 0xff));\n\n\t \n\tbuf[i] = ReadDOC(docptr, LastDataRead);\n}\n\nstatic void doc2001plus_writebuf(struct nand_chip *this, const u_char *buf, int len)\n{\n\tstruct doc_priv *doc = nand_get_controller_data(this);\n\tvoid __iomem *docptr = doc->virtadr;\n\tint i;\n\n\tif (debug)\n\t\tprintk(\"writebuf of %d bytes: \", len);\n\tfor (i = 0; i < len; i++) {\n\t\tWriteDOC_(buf[i], docptr, DoC_Mil_CDSN_IO + i);\n\t\tif (debug && i < 16)\n\t\t\tprintk(\"%02x \", buf[i]);\n\t}\n\tif (debug)\n\t\tprintk(\"\\n\");\n}\n\nstatic void doc2001plus_readbuf(struct nand_chip *this, u_char *buf, int len)\n{\n\tstruct doc_priv *doc = nand_get_controller_data(this);\n\tvoid __iomem *docptr = doc->virtadr;\n\tint i;\n\n\tif (debug)\n\t\tprintk(\"readbuf of %d bytes: \", len);\n\n\t \n\tReadDOC(docptr, Mplus_ReadPipeInit);\n\tReadDOC(docptr, Mplus_ReadPipeInit);\n\n\tfor (i = 0; i < len - 2; i++) {\n\t\tbuf[i] = ReadDOC(docptr, Mil_CDSN_IO);\n\t\tif (debug && i < 16)\n\t\t\tprintk(\"%02x \", buf[i]);\n\t}\n\n\t \n\tif (len >= 2) {\n\t\tbuf[len - 2] = ReadDOC(docptr, Mplus_LastDataRead);\n\t\tif (debug && i < 16)\n\t\t\tprintk(\"%02x \", buf[len - 2]);\n\t}\n\n\tbuf[len - 1] = ReadDOC(docptr, Mplus_LastDataRead);\n\tif (debug && i < 16)\n\t\tprintk(\"%02x \", buf[len - 1]);\n\tif (debug)\n\t\tprintk(\"\\n\");\n}\n\nstatic void doc200x_write_control(struct doc_priv *doc, u8 value)\n{\n\tWriteDOC(value, doc->virtadr, CDSNControl);\n\t \n\tDoC_Delay(doc, 4);\n}\n\nstatic void doc200x_exec_instr(struct nand_chip *this,\n\t\t\t       const struct nand_op_instr *instr)\n{\n\tstruct doc_priv *doc = nand_get_controller_data(this);\n\tunsigned int i;\n\n\tswitch (instr->type) {\n\tcase NAND_OP_CMD_INSTR:\n\t\tdoc200x_write_control(doc, CDSN_CTRL_CE | CDSN_CTRL_CLE);\n\t\tdoc2000_write_byte(this, instr->ctx.cmd.opcode);\n\t\tbreak;\n\n\tcase NAND_OP_ADDR_INSTR:\n\t\tdoc200x_write_control(doc, CDSN_CTRL_CE | CDSN_CTRL_ALE);\n\t\tfor (i = 0; i < instr->ctx.addr.naddrs; i++) {\n\t\t\tu8 addr = instr->ctx.addr.addrs[i];\n\n\t\t\tif (DoC_is_2000(doc))\n\t\t\t\tdoc2000_write_byte(this, addr);\n\t\t\telse\n\t\t\t\tdoc2001_write_byte(this, addr);\n\t\t}\n\t\tbreak;\n\n\tcase NAND_OP_DATA_IN_INSTR:\n\t\tdoc200x_write_control(doc, CDSN_CTRL_CE);\n\t\tif (DoC_is_2000(doc))\n\t\t\tdoc2000_readbuf(this, instr->ctx.data.buf.in,\n\t\t\t\t\tinstr->ctx.data.len);\n\t\telse\n\t\t\tdoc2001_readbuf(this, instr->ctx.data.buf.in,\n\t\t\t\t\tinstr->ctx.data.len);\n\t\tbreak;\n\n\tcase NAND_OP_DATA_OUT_INSTR:\n\t\tdoc200x_write_control(doc, CDSN_CTRL_CE);\n\t\tif (DoC_is_2000(doc))\n\t\t\tdoc2000_writebuf(this, instr->ctx.data.buf.out,\n\t\t\t\t\t instr->ctx.data.len);\n\t\telse\n\t\t\tdoc2001_writebuf(this, instr->ctx.data.buf.out,\n\t\t\t\t\t instr->ctx.data.len);\n\t\tbreak;\n\n\tcase NAND_OP_WAITRDY_INSTR:\n\t\tDoC_WaitReady(doc);\n\t\tbreak;\n\t}\n\n\tif (instr->delay_ns)\n\t\tndelay(instr->delay_ns);\n}\n\nstatic int doc200x_exec_op(struct nand_chip *this,\n\t\t\t   const struct nand_operation *op,\n\t\t\t   bool check_only)\n{\n\tstruct doc_priv *doc = nand_get_controller_data(this);\n\tunsigned int i;\n\n\tif (check_only)\n\t\treturn true;\n\n\tdoc->curchip = op->cs % doc->chips_per_floor;\n\tdoc->curfloor = op->cs / doc->chips_per_floor;\n\n\tWriteDOC(doc->curfloor, doc->virtadr, FloorSelect);\n\tWriteDOC(doc->curchip, doc->virtadr, CDSNDeviceSelect);\n\n\t \n\tdoc200x_write_control(doc, CDSN_CTRL_CE);\n\n\tfor (i = 0; i < op->ninstrs; i++)\n\t\tdoc200x_exec_instr(this, &op->instrs[i]);\n\n\t \n\tdoc200x_write_control(doc, 0);\n\n\treturn 0;\n}\n\nstatic void doc2001plus_write_pipe_term(struct doc_priv *doc)\n{\n\tWriteDOC(0x00, doc->virtadr, Mplus_WritePipeTerm);\n\tWriteDOC(0x00, doc->virtadr, Mplus_WritePipeTerm);\n}\n\nstatic void doc2001plus_exec_instr(struct nand_chip *this,\n\t\t\t\t   const struct nand_op_instr *instr)\n{\n\tstruct doc_priv *doc = nand_get_controller_data(this);\n\tunsigned int i;\n\n\tswitch (instr->type) {\n\tcase NAND_OP_CMD_INSTR:\n\t\tWriteDOC(instr->ctx.cmd.opcode, doc->virtadr, Mplus_FlashCmd);\n\t\tdoc2001plus_write_pipe_term(doc);\n\t\tbreak;\n\n\tcase NAND_OP_ADDR_INSTR:\n\t\tfor (i = 0; i < instr->ctx.addr.naddrs; i++) {\n\t\t\tu8 addr = instr->ctx.addr.addrs[i];\n\n\t\t\tWriteDOC(addr, doc->virtadr, Mplus_FlashAddress);\n\t\t}\n\t\tdoc2001plus_write_pipe_term(doc);\n\t\t \n\t\tWriteDOC(0, doc->virtadr, Mplus_FlashControl);\n\t\tbreak;\n\n\tcase NAND_OP_DATA_IN_INSTR:\n\t\tdoc2001plus_readbuf(this, instr->ctx.data.buf.in,\n\t\t\t\t    instr->ctx.data.len);\n\t\tbreak;\n\tcase NAND_OP_DATA_OUT_INSTR:\n\t\tdoc2001plus_writebuf(this, instr->ctx.data.buf.out,\n\t\t\t\t     instr->ctx.data.len);\n\t\tdoc2001plus_write_pipe_term(doc);\n\t\tbreak;\n\tcase NAND_OP_WAITRDY_INSTR:\n\t\tDoC_WaitReady(doc);\n\t\tbreak;\n\t}\n\n\tif (instr->delay_ns)\n\t\tndelay(instr->delay_ns);\n}\n\nstatic int doc2001plus_exec_op(struct nand_chip *this,\n\t\t\t       const struct nand_operation *op,\n\t\t\t       bool check_only)\n{\n\tstruct doc_priv *doc = nand_get_controller_data(this);\n\tunsigned int i;\n\n\tif (check_only)\n\t\treturn true;\n\n\tdoc->curchip = op->cs % doc->chips_per_floor;\n\tdoc->curfloor = op->cs / doc->chips_per_floor;\n\n\t \n\tWriteDOC(DOC_FLASH_CE, doc->virtadr, Mplus_FlashSelect);\n\n\tfor (i = 0; i < op->ninstrs; i++)\n\t\tdoc2001plus_exec_instr(this, &op->instrs[i]);\n\n\t \n\tWriteDOC(0, doc->virtadr, Mplus_FlashSelect);\n\n\treturn 0;\n}\n\nstatic void doc200x_enable_hwecc(struct nand_chip *this, int mode)\n{\n\tstruct doc_priv *doc = nand_get_controller_data(this);\n\tvoid __iomem *docptr = doc->virtadr;\n\n\t \n\tswitch (mode) {\n\tcase NAND_ECC_READ:\n\t\tWriteDOC(DOC_ECC_RESET, docptr, ECCConf);\n\t\tWriteDOC(DOC_ECC_EN, docptr, ECCConf);\n\t\tbreak;\n\tcase NAND_ECC_WRITE:\n\t\tWriteDOC(DOC_ECC_RESET, docptr, ECCConf);\n\t\tWriteDOC(DOC_ECC_EN | DOC_ECC_RW, docptr, ECCConf);\n\t\tbreak;\n\t}\n}\n\nstatic void doc2001plus_enable_hwecc(struct nand_chip *this, int mode)\n{\n\tstruct doc_priv *doc = nand_get_controller_data(this);\n\tvoid __iomem *docptr = doc->virtadr;\n\n\t \n\tswitch (mode) {\n\tcase NAND_ECC_READ:\n\t\tWriteDOC(DOC_ECC_RESET, docptr, Mplus_ECCConf);\n\t\tWriteDOC(DOC_ECC_EN, docptr, Mplus_ECCConf);\n\t\tbreak;\n\tcase NAND_ECC_WRITE:\n\t\tWriteDOC(DOC_ECC_RESET, docptr, Mplus_ECCConf);\n\t\tWriteDOC(DOC_ECC_EN | DOC_ECC_RW, docptr, Mplus_ECCConf);\n\t\tbreak;\n\t}\n}\n\n \nstatic int doc200x_calculate_ecc(struct nand_chip *this, const u_char *dat,\n\t\t\t\t unsigned char *ecc_code)\n{\n\tstruct doc_priv *doc = nand_get_controller_data(this);\n\tvoid __iomem *docptr = doc->virtadr;\n\tint i;\n\tint __always_unused emptymatch = 1;\n\n\t \n\tif (DoC_is_2000(doc)) {\n\t\tWriteDOC(doc->CDSNControl & ~CDSN_CTRL_FLASH_IO, docptr, CDSNControl);\n\t\tWriteDOC(0, docptr, 2k_CDSN_IO);\n\t\tWriteDOC(0, docptr, 2k_CDSN_IO);\n\t\tWriteDOC(0, docptr, 2k_CDSN_IO);\n\t\tWriteDOC(doc->CDSNControl, docptr, CDSNControl);\n\t} else if (DoC_is_MillenniumPlus(doc)) {\n\t\tWriteDOC(0, docptr, Mplus_NOP);\n\t\tWriteDOC(0, docptr, Mplus_NOP);\n\t\tWriteDOC(0, docptr, Mplus_NOP);\n\t} else {\n\t\tWriteDOC(0, docptr, NOP);\n\t\tWriteDOC(0, docptr, NOP);\n\t\tWriteDOC(0, docptr, NOP);\n\t}\n\n\tfor (i = 0; i < 6; i++) {\n\t\tif (DoC_is_MillenniumPlus(doc))\n\t\t\tecc_code[i] = ReadDOC_(docptr, DoC_Mplus_ECCSyndrome0 + i);\n\t\telse\n\t\t\tecc_code[i] = ReadDOC_(docptr, DoC_ECCSyndrome0 + i);\n\t\tif (ecc_code[i] != empty_write_ecc[i])\n\t\t\temptymatch = 0;\n\t}\n\tif (DoC_is_MillenniumPlus(doc))\n\t\tWriteDOC(DOC_ECC_DIS, docptr, Mplus_ECCConf);\n\telse\n\t\tWriteDOC(DOC_ECC_DIS, docptr, ECCConf);\n#if 0\n\t \n\tif (emptymatch) {\n\t\t \n\t\tfor (i = 0; i < 512; i++) {\n\t\t\tif (dat[i] == 0xff)\n\t\t\t\tcontinue;\n\t\t\temptymatch = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\t \n\tif (emptymatch)\n\t\tmemset(ecc_code, 0xff, 6);\n#endif\n\treturn 0;\n}\n\nstatic int doc200x_correct_data(struct nand_chip *this, u_char *dat,\n\t\t\t\tu_char *read_ecc, u_char *isnull)\n{\n\tint i, ret = 0;\n\tstruct doc_priv *doc = nand_get_controller_data(this);\n\tvoid __iomem *docptr = doc->virtadr;\n\tuint8_t calc_ecc[6];\n\tvolatile u_char dummy;\n\n\t \n\tif (DoC_is_2000(doc)) {\n\t\tdummy = ReadDOC(docptr, 2k_ECCStatus);\n\t\tdummy = ReadDOC(docptr, 2k_ECCStatus);\n\t\tdummy = ReadDOC(docptr, 2k_ECCStatus);\n\t} else if (DoC_is_MillenniumPlus(doc)) {\n\t\tdummy = ReadDOC(docptr, Mplus_ECCConf);\n\t\tdummy = ReadDOC(docptr, Mplus_ECCConf);\n\t\tdummy = ReadDOC(docptr, Mplus_ECCConf);\n\t} else {\n\t\tdummy = ReadDOC(docptr, ECCConf);\n\t\tdummy = ReadDOC(docptr, ECCConf);\n\t\tdummy = ReadDOC(docptr, ECCConf);\n\t}\n\n\t \n\tif (dummy & 0x80) {\n\t\tfor (i = 0; i < 6; i++) {\n\t\t\tif (DoC_is_MillenniumPlus(doc))\n\t\t\t\tcalc_ecc[i] = ReadDOC_(docptr, DoC_Mplus_ECCSyndrome0 + i);\n\t\t\telse\n\t\t\t\tcalc_ecc[i] = ReadDOC_(docptr, DoC_ECCSyndrome0 + i);\n\t\t}\n\n\t\tret = doc_ecc_decode(doc->rs_decoder, dat, calc_ecc);\n\t\tif (ret > 0)\n\t\t\tpr_err(\"doc200x_correct_data corrected %d errors\\n\",\n\t\t\t       ret);\n\t}\n\tif (DoC_is_MillenniumPlus(doc))\n\t\tWriteDOC(DOC_ECC_DIS, docptr, Mplus_ECCConf);\n\telse\n\t\tWriteDOC(DOC_ECC_DIS, docptr, ECCConf);\n\tif (no_ecc_failures && mtd_is_eccerr(ret)) {\n\t\tpr_err(\"suppressing ECC failure\\n\");\n\t\tret = 0;\n\t}\n\treturn ret;\n}\n\n\n\nstatic int doc200x_ooblayout_ecc(struct mtd_info *mtd, int section,\n\t\t\t\t struct mtd_oob_region *oobregion)\n{\n\tif (section)\n\t\treturn -ERANGE;\n\n\toobregion->offset = 0;\n\toobregion->length = 6;\n\n\treturn 0;\n}\n\nstatic int doc200x_ooblayout_free(struct mtd_info *mtd, int section,\n\t\t\t\t  struct mtd_oob_region *oobregion)\n{\n\tif (section > 1)\n\t\treturn -ERANGE;\n\n\t \n\tif (!section) {\n\t\toobregion->offset = 8;\n\t\toobregion->length = 8;\n\t} else {\n\t\toobregion->offset = 6;\n\t\toobregion->length = 2;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct mtd_ooblayout_ops doc200x_ooblayout_ops = {\n\t.ecc = doc200x_ooblayout_ecc,\n\t.free = doc200x_ooblayout_free,\n};\n\n \nstatic int __init find_media_headers(struct mtd_info *mtd, u_char *buf, const char *id, int findmirror)\n{\n\tstruct nand_chip *this = mtd_to_nand(mtd);\n\tstruct doc_priv *doc = nand_get_controller_data(this);\n\tunsigned offs;\n\tint ret;\n\tsize_t retlen;\n\n\tfor (offs = 0; offs < mtd->size; offs += mtd->erasesize) {\n\t\tret = mtd_read(mtd, offs, mtd->writesize, &retlen, buf);\n\t\tif (retlen != mtd->writesize)\n\t\t\tcontinue;\n\t\tif (ret) {\n\t\t\tpr_warn(\"ECC error scanning DOC at 0x%x\\n\", offs);\n\t\t}\n\t\tif (memcmp(buf, id, 6))\n\t\t\tcontinue;\n\t\tpr_info(\"Found DiskOnChip %s Media Header at 0x%x\\n\", id, offs);\n\t\tif (doc->mh0_page == -1) {\n\t\t\tdoc->mh0_page = offs >> this->page_shift;\n\t\t\tif (!findmirror)\n\t\t\t\treturn 1;\n\t\t\tcontinue;\n\t\t}\n\t\tdoc->mh1_page = offs >> this->page_shift;\n\t\treturn 2;\n\t}\n\tif (doc->mh0_page == -1) {\n\t\tpr_warn(\"DiskOnChip %s Media Header not found.\\n\", id);\n\t\treturn 0;\n\t}\n\t \n\toffs = doc->mh0_page << this->page_shift;\n\tret = mtd_read(mtd, offs, mtd->writesize, &retlen, buf);\n\tif (retlen != mtd->writesize) {\n\t\t \n\t\tpr_err(\"Read DiskOnChip Media Header once, but can't reread it???\\n\");\n\t\treturn 0;\n\t}\n\treturn 1;\n}\n\nstatic inline int __init nftl_partscan(struct mtd_info *mtd, struct mtd_partition *parts)\n{\n\tstruct nand_chip *this = mtd_to_nand(mtd);\n\tstruct doc_priv *doc = nand_get_controller_data(this);\n\tstruct nand_memory_organization *memorg;\n\tint ret = 0;\n\tu_char *buf;\n\tstruct NFTLMediaHeader *mh;\n\tconst unsigned psize = 1 << this->page_shift;\n\tint numparts = 0;\n\tunsigned blocks, maxblocks;\n\tint offs, numheaders;\n\n\tmemorg = nanddev_get_memorg(&this->base);\n\n\tbuf = kmalloc(mtd->writesize, GFP_KERNEL);\n\tif (!buf) {\n\t\treturn 0;\n\t}\n\tif (!(numheaders = find_media_headers(mtd, buf, \"ANAND\", 1)))\n\t\tgoto out;\n\tmh = (struct NFTLMediaHeader *)buf;\n\n\tle16_to_cpus(&mh->NumEraseUnits);\n\tle16_to_cpus(&mh->FirstPhysicalEUN);\n\tle32_to_cpus(&mh->FormattedSize);\n\n\tpr_info(\"    DataOrgID        = %s\\n\"\n\t\t\"    NumEraseUnits    = %d\\n\"\n\t\t\"    FirstPhysicalEUN = %d\\n\"\n\t\t\"    FormattedSize    = %d\\n\"\n\t\t\"    UnitSizeFactor   = %d\\n\",\n\t\tmh->DataOrgID, mh->NumEraseUnits,\n\t\tmh->FirstPhysicalEUN, mh->FormattedSize,\n\t\tmh->UnitSizeFactor);\n\n\tblocks = mtd->size >> this->phys_erase_shift;\n\tmaxblocks = min(32768U, mtd->erasesize - psize);\n\n\tif (mh->UnitSizeFactor == 0x00) {\n\t\t \n\t\tmh->UnitSizeFactor = 0xff;\n\t\twhile (blocks > maxblocks) {\n\t\t\tblocks >>= 1;\n\t\t\tmaxblocks = min(32768U, (maxblocks << 1) + psize);\n\t\t\tmh->UnitSizeFactor--;\n\t\t}\n\t\tpr_warn(\"UnitSizeFactor=0x00 detected.  Correct value is assumed to be 0x%02x.\\n\", mh->UnitSizeFactor);\n\t}\n\n\t \n\tif (mh->UnitSizeFactor != 0xff) {\n\t\tthis->bbt_erase_shift += (0xff - mh->UnitSizeFactor);\n\t\tmemorg->pages_per_eraseblock <<= (0xff - mh->UnitSizeFactor);\n\t\tmtd->erasesize <<= (0xff - mh->UnitSizeFactor);\n\t\tpr_info(\"Setting virtual erase size to %d\\n\", mtd->erasesize);\n\t\tblocks = mtd->size >> this->bbt_erase_shift;\n\t\tmaxblocks = min(32768U, mtd->erasesize - psize);\n\t}\n\n\tif (blocks > maxblocks) {\n\t\tpr_err(\"UnitSizeFactor of 0x%02x is inconsistent with device size.  Aborting.\\n\", mh->UnitSizeFactor);\n\t\tgoto out;\n\t}\n\n\t \n\toffs = max(doc->mh0_page, doc->mh1_page);\n\toffs <<= this->page_shift;\n\toffs += mtd->erasesize;\n\n\tif (show_firmware_partition == 1) {\n\t\tparts[0].name = \" DiskOnChip Firmware / Media Header partition\";\n\t\tparts[0].offset = 0;\n\t\tparts[0].size = offs;\n\t\tnumparts = 1;\n\t}\n\n\tparts[numparts].name = \" DiskOnChip BDTL partition\";\n\tparts[numparts].offset = offs;\n\tparts[numparts].size = (mh->NumEraseUnits - numheaders) << this->bbt_erase_shift;\n\n\toffs += parts[numparts].size;\n\tnumparts++;\n\n\tif (offs < mtd->size) {\n\t\tparts[numparts].name = \" DiskOnChip Remainder partition\";\n\t\tparts[numparts].offset = offs;\n\t\tparts[numparts].size = mtd->size - offs;\n\t\tnumparts++;\n\t}\n\n\tret = numparts;\n out:\n\tkfree(buf);\n\treturn ret;\n}\n\n \nstatic inline int __init inftl_partscan(struct mtd_info *mtd, struct mtd_partition *parts)\n{\n\tstruct nand_chip *this = mtd_to_nand(mtd);\n\tstruct doc_priv *doc = nand_get_controller_data(this);\n\tint ret = 0;\n\tu_char *buf;\n\tstruct INFTLMediaHeader *mh;\n\tstruct INFTLPartition *ip;\n\tint numparts = 0;\n\tint blocks;\n\tint vshift, lastvunit = 0;\n\tint i;\n\tint end = mtd->size;\n\n\tif (inftl_bbt_write)\n\t\tend -= (INFTL_BBT_RESERVED_BLOCKS << this->phys_erase_shift);\n\n\tbuf = kmalloc(mtd->writesize, GFP_KERNEL);\n\tif (!buf) {\n\t\treturn 0;\n\t}\n\n\tif (!find_media_headers(mtd, buf, \"BNAND\", 0))\n\t\tgoto out;\n\tdoc->mh1_page = doc->mh0_page + (4096 >> this->page_shift);\n\tmh = (struct INFTLMediaHeader *)buf;\n\n\tle32_to_cpus(&mh->NoOfBootImageBlocks);\n\tle32_to_cpus(&mh->NoOfBinaryPartitions);\n\tle32_to_cpus(&mh->NoOfBDTLPartitions);\n\tle32_to_cpus(&mh->BlockMultiplierBits);\n\tle32_to_cpus(&mh->FormatFlags);\n\tle32_to_cpus(&mh->PercentUsed);\n\n\tpr_info(\"    bootRecordID          = %s\\n\"\n\t\t\"    NoOfBootImageBlocks   = %d\\n\"\n\t\t\"    NoOfBinaryPartitions  = %d\\n\"\n\t\t\"    NoOfBDTLPartitions    = %d\\n\"\n\t\t\"    BlockMultiplierBits   = %d\\n\"\n\t\t\"    FormatFlgs            = %d\\n\"\n\t\t\"    OsakVersion           = %d.%d.%d.%d\\n\"\n\t\t\"    PercentUsed           = %d\\n\",\n\t\tmh->bootRecordID, mh->NoOfBootImageBlocks,\n\t\tmh->NoOfBinaryPartitions,\n\t\tmh->NoOfBDTLPartitions,\n\t\tmh->BlockMultiplierBits, mh->FormatFlags,\n\t\t((unsigned char *) &mh->OsakVersion)[0] & 0xf,\n\t\t((unsigned char *) &mh->OsakVersion)[1] & 0xf,\n\t\t((unsigned char *) &mh->OsakVersion)[2] & 0xf,\n\t\t((unsigned char *) &mh->OsakVersion)[3] & 0xf,\n\t\tmh->PercentUsed);\n\n\tvshift = this->phys_erase_shift + mh->BlockMultiplierBits;\n\n\tblocks = mtd->size >> vshift;\n\tif (blocks > 32768) {\n\t\tpr_err(\"BlockMultiplierBits=%d is inconsistent with device size.  Aborting.\\n\", mh->BlockMultiplierBits);\n\t\tgoto out;\n\t}\n\n\tblocks = doc->chips_per_floor << (this->chip_shift - this->phys_erase_shift);\n\tif (inftl_bbt_write && (blocks > mtd->erasesize)) {\n\t\tpr_err(\"Writeable BBTs spanning more than one erase block are not yet supported.  FIX ME!\\n\");\n\t\tgoto out;\n\t}\n\n\t \n\tfor (i = 0; (i < 4); i++) {\n\t\tip = &(mh->Partitions[i]);\n\t\tle32_to_cpus(&ip->virtualUnits);\n\t\tle32_to_cpus(&ip->firstUnit);\n\t\tle32_to_cpus(&ip->lastUnit);\n\t\tle32_to_cpus(&ip->flags);\n\t\tle32_to_cpus(&ip->spareUnits);\n\t\tle32_to_cpus(&ip->Reserved0);\n\n\t\tpr_info(\"    PARTITION[%d] ->\\n\"\n\t\t\t\"        virtualUnits    = %d\\n\"\n\t\t\t\"        firstUnit       = %d\\n\"\n\t\t\t\"        lastUnit        = %d\\n\"\n\t\t\t\"        flags           = 0x%x\\n\"\n\t\t\t\"        spareUnits      = %d\\n\",\n\t\t\ti, ip->virtualUnits, ip->firstUnit,\n\t\t\tip->lastUnit, ip->flags,\n\t\t\tip->spareUnits);\n\n\t\tif ((show_firmware_partition == 1) &&\n\t\t    (i == 0) && (ip->firstUnit > 0)) {\n\t\t\tparts[0].name = \" DiskOnChip IPL / Media Header partition\";\n\t\t\tparts[0].offset = 0;\n\t\t\tparts[0].size = mtd->erasesize * ip->firstUnit;\n\t\t\tnumparts = 1;\n\t\t}\n\n\t\tif (ip->flags & INFTL_BINARY)\n\t\t\tparts[numparts].name = \" DiskOnChip BDK partition\";\n\t\telse\n\t\t\tparts[numparts].name = \" DiskOnChip BDTL partition\";\n\t\tparts[numparts].offset = ip->firstUnit << vshift;\n\t\tparts[numparts].size = (1 + ip->lastUnit - ip->firstUnit) << vshift;\n\t\tnumparts++;\n\t\tif (ip->lastUnit > lastvunit)\n\t\t\tlastvunit = ip->lastUnit;\n\t\tif (ip->flags & INFTL_LAST)\n\t\t\tbreak;\n\t}\n\tlastvunit++;\n\tif ((lastvunit << vshift) < end) {\n\t\tparts[numparts].name = \" DiskOnChip Remainder partition\";\n\t\tparts[numparts].offset = lastvunit << vshift;\n\t\tparts[numparts].size = end - parts[numparts].offset;\n\t\tnumparts++;\n\t}\n\tret = numparts;\n out:\n\tkfree(buf);\n\treturn ret;\n}\n\nstatic int __init nftl_scan_bbt(struct mtd_info *mtd)\n{\n\tint ret, numparts;\n\tstruct nand_chip *this = mtd_to_nand(mtd);\n\tstruct doc_priv *doc = nand_get_controller_data(this);\n\tstruct mtd_partition parts[2];\n\n\tmemset((char *)parts, 0, sizeof(parts));\n\t \n\tnumparts = nftl_partscan(mtd, parts);\n\tif (!numparts)\n\t\treturn -EIO;\n\tthis->bbt_td->options = NAND_BBT_ABSPAGE | NAND_BBT_8BIT |\n\t\t\t\tNAND_BBT_SAVECONTENT | NAND_BBT_WRITE |\n\t\t\t\tNAND_BBT_VERSION;\n\tthis->bbt_td->veroffs = 7;\n\tthis->bbt_td->pages[0] = doc->mh0_page + 1;\n\tif (doc->mh1_page != -1) {\n\t\tthis->bbt_md->options = NAND_BBT_ABSPAGE | NAND_BBT_8BIT |\n\t\t\t\t\tNAND_BBT_SAVECONTENT | NAND_BBT_WRITE |\n\t\t\t\t\tNAND_BBT_VERSION;\n\t\tthis->bbt_md->veroffs = 7;\n\t\tthis->bbt_md->pages[0] = doc->mh1_page + 1;\n\t} else {\n\t\tthis->bbt_md = NULL;\n\t}\n\n\tret = nand_create_bbt(this);\n\tif (ret)\n\t\treturn ret;\n\n\treturn mtd_device_register(mtd, parts, no_autopart ? 0 : numparts);\n}\n\nstatic int __init inftl_scan_bbt(struct mtd_info *mtd)\n{\n\tint ret, numparts;\n\tstruct nand_chip *this = mtd_to_nand(mtd);\n\tstruct doc_priv *doc = nand_get_controller_data(this);\n\tstruct mtd_partition parts[5];\n\n\tif (nanddev_ntargets(&this->base) > doc->chips_per_floor) {\n\t\tpr_err(\"Multi-floor INFTL devices not yet supported.\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (DoC_is_MillenniumPlus(doc)) {\n\t\tthis->bbt_td->options = NAND_BBT_2BIT | NAND_BBT_ABSPAGE;\n\t\tif (inftl_bbt_write)\n\t\t\tthis->bbt_td->options |= NAND_BBT_WRITE;\n\t\tthis->bbt_td->pages[0] = 2;\n\t\tthis->bbt_md = NULL;\n\t} else {\n\t\tthis->bbt_td->options = NAND_BBT_LASTBLOCK | NAND_BBT_8BIT | NAND_BBT_VERSION;\n\t\tif (inftl_bbt_write)\n\t\t\tthis->bbt_td->options |= NAND_BBT_WRITE;\n\t\tthis->bbt_td->offs = 8;\n\t\tthis->bbt_td->len = 8;\n\t\tthis->bbt_td->veroffs = 7;\n\t\tthis->bbt_td->maxblocks = INFTL_BBT_RESERVED_BLOCKS;\n\t\tthis->bbt_td->reserved_block_code = 0x01;\n\t\tthis->bbt_td->pattern = \"MSYS_BBT\";\n\n\t\tthis->bbt_md->options = NAND_BBT_LASTBLOCK | NAND_BBT_8BIT | NAND_BBT_VERSION;\n\t\tif (inftl_bbt_write)\n\t\t\tthis->bbt_md->options |= NAND_BBT_WRITE;\n\t\tthis->bbt_md->offs = 8;\n\t\tthis->bbt_md->len = 8;\n\t\tthis->bbt_md->veroffs = 7;\n\t\tthis->bbt_md->maxblocks = INFTL_BBT_RESERVED_BLOCKS;\n\t\tthis->bbt_md->reserved_block_code = 0x01;\n\t\tthis->bbt_md->pattern = \"TBB_SYSM\";\n\t}\n\n\tret = nand_create_bbt(this);\n\tif (ret)\n\t\treturn ret;\n\n\tmemset((char *)parts, 0, sizeof(parts));\n\tnumparts = inftl_partscan(mtd, parts);\n\t \n\tif (!numparts)\n\t\treturn -EIO;\n\treturn mtd_device_register(mtd, parts, no_autopart ? 0 : numparts);\n}\n\nstatic inline int __init doc2000_init(struct mtd_info *mtd)\n{\n\tstruct nand_chip *this = mtd_to_nand(mtd);\n\tstruct doc_priv *doc = nand_get_controller_data(this);\n\n\tdoc->late_init = nftl_scan_bbt;\n\n\tdoc->CDSNControl = CDSN_CTRL_FLASH_IO | CDSN_CTRL_ECC_IO;\n\tdoc2000_count_chips(mtd);\n\tmtd->name = \"DiskOnChip 2000 (NFTL Model)\";\n\treturn (4 * doc->chips_per_floor);\n}\n\nstatic inline int __init doc2001_init(struct mtd_info *mtd)\n{\n\tstruct nand_chip *this = mtd_to_nand(mtd);\n\tstruct doc_priv *doc = nand_get_controller_data(this);\n\n\tReadDOC(doc->virtadr, ChipID);\n\tReadDOC(doc->virtadr, ChipID);\n\tReadDOC(doc->virtadr, ChipID);\n\tif (ReadDOC(doc->virtadr, ChipID) != DOC_ChipID_DocMil) {\n\t\t \n\t\tdoc2000_count_chips(mtd);\n\t\tmtd->name = \"DiskOnChip 2000 (INFTL Model)\";\n\t\tdoc->late_init = inftl_scan_bbt;\n\t\treturn (4 * doc->chips_per_floor);\n\t} else {\n\t\t \n\t\tdoc->chips_per_floor = 1;\n\t\tmtd->name = \"DiskOnChip Millennium\";\n\t\tdoc->late_init = nftl_scan_bbt;\n\t\treturn 1;\n\t}\n}\n\nstatic inline int __init doc2001plus_init(struct mtd_info *mtd)\n{\n\tstruct nand_chip *this = mtd_to_nand(mtd);\n\tstruct doc_priv *doc = nand_get_controller_data(this);\n\n\tdoc->late_init = inftl_scan_bbt;\n\tthis->ecc.hwctl = doc2001plus_enable_hwecc;\n\n\tdoc->chips_per_floor = 1;\n\tmtd->name = \"DiskOnChip Millennium Plus\";\n\n\treturn 1;\n}\n\nstatic int doc200x_attach_chip(struct nand_chip *chip)\n{\n\tif (chip->ecc.engine_type != NAND_ECC_ENGINE_TYPE_ON_HOST)\n\t\treturn 0;\n\n\tchip->ecc.placement = NAND_ECC_PLACEMENT_INTERLEAVED;\n\tchip->ecc.size = 512;\n\tchip->ecc.bytes = 6;\n\tchip->ecc.strength = 2;\n\tchip->ecc.options = NAND_ECC_GENERIC_ERASED_CHECK;\n\tchip->ecc.hwctl = doc200x_enable_hwecc;\n\tchip->ecc.calculate = doc200x_calculate_ecc;\n\tchip->ecc.correct = doc200x_correct_data;\n\n\treturn 0;\n}\n\nstatic const struct nand_controller_ops doc200x_ops = {\n\t.exec_op = doc200x_exec_op,\n\t.attach_chip = doc200x_attach_chip,\n};\n\nstatic const struct nand_controller_ops doc2001plus_ops = {\n\t.exec_op = doc2001plus_exec_op,\n\t.attach_chip = doc200x_attach_chip,\n};\n\nstatic int __init doc_probe(unsigned long physadr)\n{\n\tstruct nand_chip *nand = NULL;\n\tstruct doc_priv *doc = NULL;\n\tunsigned char ChipID;\n\tstruct mtd_info *mtd;\n\tvoid __iomem *virtadr;\n\tunsigned char save_control;\n\tunsigned char tmp, tmpb, tmpc;\n\tint reg, len, numchips;\n\tint ret = 0;\n\n\tif (!request_mem_region(physadr, DOC_IOREMAP_LEN, \"DiskOnChip\"))\n\t\treturn -EBUSY;\n\tvirtadr = ioremap(physadr, DOC_IOREMAP_LEN);\n\tif (!virtadr) {\n\t\tpr_err(\"Diskonchip ioremap failed: 0x%x bytes at 0x%lx\\n\",\n\t\t       DOC_IOREMAP_LEN, physadr);\n\t\tret = -EIO;\n\t\tgoto error_ioremap;\n\t}\n\n\t \n\tsave_control = ReadDOC(virtadr, DOCControl);\n\n\t \n\tWriteDOC(DOC_MODE_CLR_ERR | DOC_MODE_MDWREN | DOC_MODE_RESET, virtadr, DOCControl);\n\tWriteDOC(DOC_MODE_CLR_ERR | DOC_MODE_MDWREN | DOC_MODE_RESET, virtadr, DOCControl);\n\n\t \n\tWriteDOC(DOC_MODE_CLR_ERR | DOC_MODE_MDWREN | DOC_MODE_NORMAL, virtadr, DOCControl);\n\tWriteDOC(DOC_MODE_CLR_ERR | DOC_MODE_MDWREN | DOC_MODE_NORMAL, virtadr, DOCControl);\n\n\tChipID = ReadDOC(virtadr, ChipID);\n\n\tswitch (ChipID) {\n\tcase DOC_ChipID_Doc2k:\n\t\treg = DoC_2k_ECCStatus;\n\t\tbreak;\n\tcase DOC_ChipID_DocMil:\n\t\treg = DoC_ECCConf;\n\t\tbreak;\n\tcase DOC_ChipID_DocMilPlus16:\n\tcase DOC_ChipID_DocMilPlus32:\n\tcase 0:\n\t\t \n\t\t \n\t\tfor (tmp = 0; (tmp < 4); tmp++)\n\t\t\tReadDOC(virtadr, Mplus_Power);\n\n\t\t \n\t\ttmp = DOC_MODE_RESET | DOC_MODE_MDWREN | DOC_MODE_RST_LAT | DOC_MODE_BDECT;\n\t\tWriteDOC(tmp, virtadr, Mplus_DOCControl);\n\t\tWriteDOC(~tmp, virtadr, Mplus_CtrlConfirm);\n\n\t\tusleep_range(1000, 2000);\n\t\t \n\t\ttmp = DOC_MODE_NORMAL | DOC_MODE_MDWREN | DOC_MODE_RST_LAT | DOC_MODE_BDECT;\n\t\tWriteDOC(tmp, virtadr, Mplus_DOCControl);\n\t\tWriteDOC(~tmp, virtadr, Mplus_CtrlConfirm);\n\t\tusleep_range(1000, 2000);\n\n\t\tChipID = ReadDOC(virtadr, ChipID);\n\n\t\tswitch (ChipID) {\n\t\tcase DOC_ChipID_DocMilPlus16:\n\t\t\treg = DoC_Mplus_Toggle;\n\t\t\tbreak;\n\t\tcase DOC_ChipID_DocMilPlus32:\n\t\t\tpr_err(\"DiskOnChip Millennium Plus 32MB is not supported, ignoring.\\n\");\n\t\t\tfallthrough;\n\t\tdefault:\n\t\t\tret = -ENODEV;\n\t\t\tgoto notfound;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tret = -ENODEV;\n\t\tgoto notfound;\n\t}\n\t \n\ttmp = ReadDOC_(virtadr, reg) & DOC_TOGGLE_BIT;\n\ttmpb = ReadDOC_(virtadr, reg) & DOC_TOGGLE_BIT;\n\ttmpc = ReadDOC_(virtadr, reg) & DOC_TOGGLE_BIT;\n\tif ((tmp == tmpb) || (tmp != tmpc)) {\n\t\tpr_warn(\"Possible DiskOnChip at 0x%lx failed TOGGLE test, dropping.\\n\", physadr);\n\t\tret = -ENODEV;\n\t\tgoto notfound;\n\t}\n\n\tfor (mtd = doclist; mtd; mtd = doc->nextdoc) {\n\t\tunsigned char oldval;\n\t\tunsigned char newval;\n\t\tnand = mtd_to_nand(mtd);\n\t\tdoc = nand_get_controller_data(nand);\n\t\t \n\t\tif (ChipID == DOC_ChipID_DocMilPlus16) {\n\t\t\toldval = ReadDOC(doc->virtadr, Mplus_AliasResolution);\n\t\t\tnewval = ReadDOC(virtadr, Mplus_AliasResolution);\n\t\t} else {\n\t\t\toldval = ReadDOC(doc->virtadr, AliasResolution);\n\t\t\tnewval = ReadDOC(virtadr, AliasResolution);\n\t\t}\n\t\tif (oldval != newval)\n\t\t\tcontinue;\n\t\tif (ChipID == DOC_ChipID_DocMilPlus16) {\n\t\t\tWriteDOC(~newval, virtadr, Mplus_AliasResolution);\n\t\t\toldval = ReadDOC(doc->virtadr, Mplus_AliasResolution);\n\t\t\tWriteDOC(newval, virtadr, Mplus_AliasResolution);\t \n\t\t} else {\n\t\t\tWriteDOC(~newval, virtadr, AliasResolution);\n\t\t\toldval = ReadDOC(doc->virtadr, AliasResolution);\n\t\t\tWriteDOC(newval, virtadr, AliasResolution);\t \n\t\t}\n\t\tnewval = ~newval;\n\t\tif (oldval == newval) {\n\t\t\tpr_debug(\"Found alias of DOC at 0x%lx to 0x%lx\\n\",\n\t\t\t\t doc->physadr, physadr);\n\t\t\tgoto notfound;\n\t\t}\n\t}\n\n\tpr_notice(\"DiskOnChip found at 0x%lx\\n\", physadr);\n\n\tlen = sizeof(struct nand_chip) + sizeof(struct doc_priv) +\n\t      (2 * sizeof(struct nand_bbt_descr));\n\tnand = kzalloc(len, GFP_KERNEL);\n\tif (!nand) {\n\t\tret = -ENOMEM;\n\t\tgoto fail;\n\t}\n\n\t \n\tdoc = (struct doc_priv *) (nand + 1);\n\tdoc->rs_decoder = init_rs(10, 0x409, FCR, 1, NROOTS);\n\tif (!doc->rs_decoder) {\n\t\tpr_err(\"DiskOnChip: Could not create a RS codec\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto fail;\n\t}\n\n\tnand_controller_init(&doc->base);\n\tif (ChipID == DOC_ChipID_DocMilPlus16)\n\t\tdoc->base.ops = &doc2001plus_ops;\n\telse\n\t\tdoc->base.ops = &doc200x_ops;\n\n\tmtd\t\t\t= nand_to_mtd(nand);\n\tnand->bbt_td\t\t= (struct nand_bbt_descr *) (doc + 1);\n\tnand->bbt_md\t\t= nand->bbt_td + 1;\n\n\tmtd->owner\t\t= THIS_MODULE;\n\tmtd_set_ooblayout(mtd, &doc200x_ooblayout_ops);\n\n\tnand->controller\t= &doc->base;\n\tnand_set_controller_data(nand, doc);\n\tnand->bbt_options\t= NAND_BBT_USE_FLASH;\n\t \n\tnand->options\t\t|= NAND_SKIP_BBTSCAN | NAND_NO_BBM_QUIRK;\n\n\tdoc->physadr\t\t= physadr;\n\tdoc->virtadr\t\t= virtadr;\n\tdoc->ChipID\t\t= ChipID;\n\tdoc->curfloor\t\t= -1;\n\tdoc->curchip\t\t= -1;\n\tdoc->mh0_page\t\t= -1;\n\tdoc->mh1_page\t\t= -1;\n\tdoc->nextdoc\t\t= doclist;\n\n\tif (ChipID == DOC_ChipID_Doc2k)\n\t\tnumchips = doc2000_init(mtd);\n\telse if (ChipID == DOC_ChipID_DocMilPlus16)\n\t\tnumchips = doc2001plus_init(mtd);\n\telse\n\t\tnumchips = doc2001_init(mtd);\n\n\tif ((ret = nand_scan(nand, numchips)) || (ret = doc->late_init(mtd))) {\n\t\t \n\t\tnand_cleanup(nand);\n\t\tgoto fail;\n\t}\n\n\t \n\tdoclist = mtd;\n\treturn 0;\n\n notfound:\n\t \n\tWriteDOC(save_control, virtadr, DOCControl);\n fail:\n\tif (doc)\n\t\tfree_rs(doc->rs_decoder);\n\tkfree(nand);\n\tiounmap(virtadr);\n\nerror_ioremap:\n\trelease_mem_region(physadr, DOC_IOREMAP_LEN);\n\n\treturn ret;\n}\n\nstatic void release_nanddoc(void)\n{\n\tstruct mtd_info *mtd, *nextmtd;\n\tstruct nand_chip *nand;\n\tstruct doc_priv *doc;\n\tint ret;\n\n\tfor (mtd = doclist; mtd; mtd = nextmtd) {\n\t\tnand = mtd_to_nand(mtd);\n\t\tdoc = nand_get_controller_data(nand);\n\n\t\tnextmtd = doc->nextdoc;\n\t\tret = mtd_device_unregister(mtd);\n\t\tWARN_ON(ret);\n\t\tnand_cleanup(nand);\n\t\tiounmap(doc->virtadr);\n\t\trelease_mem_region(doc->physadr, DOC_IOREMAP_LEN);\n\t\tfree_rs(doc->rs_decoder);\n\t\tkfree(nand);\n\t}\n}\n\nstatic int __init init_nanddoc(void)\n{\n\tint i, ret = 0;\n\n\tif (doc_config_location) {\n\t\tpr_info(\"Using configured DiskOnChip probe address 0x%lx\\n\",\n\t\t\tdoc_config_location);\n\t\tret = doc_probe(doc_config_location);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t} else {\n\t\tfor (i = 0; (doc_locations[i] != 0xffffffff); i++) {\n\t\t\tdoc_probe(doc_locations[i]);\n\t\t}\n\t}\n\t \n\tif (!doclist) {\n\t\tpr_info(\"No valid DiskOnChip devices found\\n\");\n\t\tret = -ENODEV;\n\t}\n\treturn ret;\n}\n\nstatic void __exit cleanup_nanddoc(void)\n{\n\t \n\trelease_nanddoc();\n}\n\nmodule_init(init_nanddoc);\nmodule_exit(cleanup_nanddoc);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"David Woodhouse <dwmw2@infradead.org>\");\nMODULE_DESCRIPTION(\"M-Systems DiskOnChip 2000, Millennium and Millennium Plus device driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}