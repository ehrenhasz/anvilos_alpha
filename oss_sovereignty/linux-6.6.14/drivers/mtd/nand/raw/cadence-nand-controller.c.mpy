{
  "module_name": "cadence-nand-controller.c",
  "hash_id": "50b9d2d84ce4a73cfa20b22d350a2c2a553a08e61762d0dd6a566de8695895a1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/nand/raw/cadence-nand-controller.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/clk.h>\n#include <linux/dma-mapping.h>\n#include <linux/dmaengine.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/mtd/mtd.h>\n#include <linux/mtd/rawnand.h>\n#include <linux/of_device.h>\n#include <linux/iopoll.h>\n#include <linux/slab.h>\n\n \n\n#define MAX_ADDRESS_CYC\t\t6\n#define MAX_ERASE_ADDRESS_CYC\t3\n#define MAX_DATA_SIZE\t\t0xFFFC\n#define DMA_DATA_SIZE_ALIGN\t8\n\n \n \n#define CMD_REG0\t\t\t0x0000\n \n#define\t\tCMD_REG0_CT\t\tGENMASK(31, 30)\n \n#define\t\tCMD_REG0_CT_CDMA\t0uL\n \n#define\t\tCMD_REG0_CT_GEN\t\t3uL\n \n#define\t\tCMD_REG0_TN\t\tGENMASK(27, 24)\n\n \n#define CMD_REG2\t\t\t0x0008\n \n#define CMD_REG3\t\t\t0x000C\n \n#define CMD_STATUS_PTR\t\t\t0x0010\n \n#define CMD_STATUS\t\t\t0x0014\n\n \n#define INTR_STATUS\t\t\t0x0110\n#define\t\tINTR_STATUS_SDMA_ERR\tBIT(22)\n#define\t\tINTR_STATUS_SDMA_TRIGG\tBIT(21)\n#define\t\tINTR_STATUS_UNSUPP_CMD\tBIT(19)\n#define\t\tINTR_STATUS_DDMA_TERR\tBIT(18)\n#define\t\tINTR_STATUS_CDMA_TERR\tBIT(17)\n#define\t\tINTR_STATUS_CDMA_IDL\tBIT(16)\n\n \n#define INTR_ENABLE\t\t\t\t0x0114\n#define\t\tINTR_ENABLE_INTR_EN\t\tBIT(31)\n#define\t\tINTR_ENABLE_SDMA_ERR_EN\t\tBIT(22)\n#define\t\tINTR_ENABLE_SDMA_TRIGG_EN\tBIT(21)\n#define\t\tINTR_ENABLE_UNSUPP_CMD_EN\tBIT(19)\n#define\t\tINTR_ENABLE_DDMA_TERR_EN\tBIT(18)\n#define\t\tINTR_ENABLE_CDMA_TERR_EN\tBIT(17)\n#define\t\tINTR_ENABLE_CDMA_IDLE_EN\tBIT(16)\n\n \n#define CTRL_STATUS\t\t\t\t0x0118\n#define\t\tCTRL_STATUS_INIT_COMP\t\tBIT(9)\n#define\t\tCTRL_STATUS_CTRL_BUSY\t\tBIT(8)\n\n \n#define TRD_STATUS\t\t\t\t0x0120\n\n \n#define TRD_ERR_INT_STATUS\t\t\t0x0128\n \n#define TRD_ERR_INT_STATUS_EN\t\t\t0x0130\n \n#define TRD_COMP_INT_STATUS\t\t\t0x0138\n\n \n#define TRAN_CFG_0\t\t\t\t0x0400\n \n#define\t\tTRAN_CFG_0_OFFSET\t\tGENMASK(31, 16)\n \n#define\t\tTRAN_CFG_0_SEC_CNT\t\tGENMASK(7, 0)\n\n \n#define TRAN_CFG_1\t\t\t\t0x0404\n \n#define\t\tTRAN_CFG_1_LAST_SEC_SIZE\tGENMASK(31, 16)\n \n#define\t\tTRAN_CFG_1_SECTOR_SIZE\t\tGENMASK(15, 0)\n\n \n#define ECC_CONFIG_0\t\t\t\t0x0428\n \n#define\t\tECC_CONFIG_0_CORR_STR\t\tGENMASK(10, 8)\n \n#define\t\tECC_CONFIG_0_ERASE_DET_EN\tBIT(1)\n \n#define\t\tECC_CONFIG_0_ECC_EN\t\tBIT(0)\n\n \n#define ECC_CONFIG_1\t\t\t\t0x042C\n\n \n#define MULTIPLANE_CFG\t\t\t\t0x0434\n \n#define CACHE_CFG\t\t\t\t0x0438\n\n \n#define DMA_SETINGS\t\t\t\t0x043C\n \n#define\t\tDMA_SETINGS_SDMA_ERR_RSP\tBIT(17)\n\n \n#define SDMA_SIZE\t\t\t\t0x0440\n\n \n#define SDMA_TRD_NUM\t\t\t\t0x0444\n \n#define\t\tSDMA_TRD_NUM_SDMA_TRD\t\tGENMASK(2, 0)\n\n#define CONTROL_DATA_CTRL\t\t\t0x0494\n \n#define\t\tCONTROL_DATA_CTRL_SIZE\t\tGENMASK(15, 0)\n\n#define CTRL_VERSION\t\t\t\t0x800\n#define\t\tCTRL_VERSION_REV\t\tGENMASK(7, 0)\n\n \n#define CTRL_FEATURES\t\t\t\t0x804\n \n#define\t\tCTRL_FEATURES_NVDDR_2_3\t\tBIT(28)\n \n#define\t\tCTRL_FEATURES_NVDDR\t\tBIT(27)\n \n#define\t\tCTRL_FEATURES_ASYNC\t\tBIT(26)\n \n#define\t\tCTRL_FEATURES_N_BANKS\t\tGENMASK(25, 24)\n \n#define\t\tCTRL_FEATURES_DMA_DWITH64\tBIT(21)\n \n#define\t\tCTRL_FEATURES_CONTROL_DATA\tBIT(10)\n\n \n#define BCH_CFG_0\t\t\t\t0x838\n#define\t\tBCH_CFG_0_CORR_CAP_0\t\tGENMASK(7, 0)\n#define\t\tBCH_CFG_0_CORR_CAP_1\t\tGENMASK(15, 8)\n#define\t\tBCH_CFG_0_CORR_CAP_2\t\tGENMASK(23, 16)\n#define\t\tBCH_CFG_0_CORR_CAP_3\t\tGENMASK(31, 24)\n\n \n#define BCH_CFG_1\t\t\t\t0x83C\n#define\t\tBCH_CFG_1_CORR_CAP_4\t\tGENMASK(7, 0)\n#define\t\tBCH_CFG_1_CORR_CAP_5\t\tGENMASK(15, 8)\n#define\t\tBCH_CFG_1_CORR_CAP_6\t\tGENMASK(23, 16)\n#define\t\tBCH_CFG_1_CORR_CAP_7\t\tGENMASK(31, 24)\n\n \n#define BCH_CFG_2\t\t\t\t0x840\n#define\t\tBCH_CFG_2_SECT_0\t\tGENMASK(15, 0)\n#define\t\tBCH_CFG_2_SECT_1\t\tGENMASK(31, 16)\n\n \n#define BCH_CFG_3\t\t\t\t0x844\n#define\t\tBCH_CFG_3_METADATA_SIZE\t\tGENMASK(23, 16)\n\n \n#define RBN_SETINGS\t\t\t\t0x1004\n\n \n#define COMMON_SET\t\t\t\t0x1008\n \n#define\t\tCOMMON_SET_DEVICE_16BIT\t\tBIT(8)\n\n \n#define SKIP_BYTES_CONF\t\t\t\t0x100C\n#define\t\tSKIP_BYTES_MARKER_VALUE\t\tGENMASK(31, 16)\n#define\t\tSKIP_BYTES_NUM_OF_BYTES\t\tGENMASK(7, 0)\n\n#define SKIP_BYTES_OFFSET\t\t\t0x1010\n#define\t\t SKIP_BYTES_OFFSET_VALUE\tGENMASK(23, 0)\n\n \n#define ASYNC_TOGGLE_TIMINGS\t\t\t0x101c\n#define\t\tASYNC_TOGGLE_TIMINGS_TRH\tGENMASK(28, 24)\n#define\t\tASYNC_TOGGLE_TIMINGS_TRP\tGENMASK(20, 16)\n#define\t\tASYNC_TOGGLE_TIMINGS_TWH\tGENMASK(12, 8)\n#define\t\tASYNC_TOGGLE_TIMINGS_TWP\tGENMASK(4, 0)\n\n#define\tTIMINGS0\t\t\t\t0x1024\n#define\t\tTIMINGS0_TADL\t\t\tGENMASK(31, 24)\n#define\t\tTIMINGS0_TCCS\t\t\tGENMASK(23, 16)\n#define\t\tTIMINGS0_TWHR\t\t\tGENMASK(15, 8)\n#define\t\tTIMINGS0_TRHW\t\t\tGENMASK(7, 0)\n\n#define\tTIMINGS1\t\t\t\t0x1028\n#define\t\tTIMINGS1_TRHZ\t\t\tGENMASK(31, 24)\n#define\t\tTIMINGS1_TWB\t\t\tGENMASK(23, 16)\n#define\t\tTIMINGS1_TVDLY\t\t\tGENMASK(7, 0)\n\n#define\tTIMINGS2\t\t\t\t0x102c\n#define\t\tTIMINGS2_TFEAT\t\t\tGENMASK(25, 16)\n#define\t\tTIMINGS2_CS_HOLD_TIME\t\tGENMASK(13, 8)\n#define\t\tTIMINGS2_CS_SETUP_TIME\t\tGENMASK(5, 0)\n\n \n#define DLL_PHY_CTRL\t\t\t\t0x1034\n#define\t\tDLL_PHY_CTRL_DLL_RST_N\t\tBIT(24)\n#define\t\tDLL_PHY_CTRL_EXTENDED_WR_MODE\tBIT(17)\n#define\t\tDLL_PHY_CTRL_EXTENDED_RD_MODE\tBIT(16)\n#define\t\tDLL_PHY_CTRL_RS_HIGH_WAIT_CNT\tGENMASK(11, 8)\n#define\t\tDLL_PHY_CTRL_RS_IDLE_CNT\tGENMASK(7, 0)\n\n \n#define PHY_DQ_TIMING\t\t\t\t0x2000\n \n#define PHY_DQS_TIMING\t\t\t\t0x2004\n#define\t\tPHY_DQS_TIMING_DQS_SEL_OE_END\tGENMASK(3, 0)\n#define\t\tPHY_DQS_TIMING_PHONY_DQS_SEL\tBIT(16)\n#define\t\tPHY_DQS_TIMING_USE_PHONY_DQS\tBIT(20)\n\n \n#define PHY_GATE_LPBK_CTRL\t\t\t0x2008\n#define\t\tPHY_GATE_LPBK_CTRL_RDS\t\tGENMASK(24, 19)\n\n \n#define PHY_DLL_MASTER_CTRL\t\t\t0x200C\n#define\t\tPHY_DLL_MASTER_CTRL_BYPASS_MODE\tBIT(23)\n\n \n#define PHY_DLL_SLAVE_CTRL\t\t\t0x2010\n\n \n#define PHY_CTRL\t\t\t\t0x2080\n#define\t\tPHY_CTRL_SDR_DQS\t\tBIT(14)\n#define\t\tPHY_CTRL_PHONY_DQS\t\tGENMASK(9, 4)\n\n \n#define PHY_TSEL\t\t\t\t0x2084\n\n \n#define GCMD_LAY_CS\t\t\tGENMASK_ULL(11, 8)\n \n#define GCMD_LAY_TWB\t\t\tBIT_ULL(6)\n \n#define GCMD_LAY_INSTR\t\t\tGENMASK_ULL(5, 0)\n\n \n#define\t\tGCMD_LAY_INSTR_CMD\t0\n \n#define\t\tGCMD_LAY_INSTR_ADDR\t1\n \n#define\t\tGCMD_LAY_INSTR_DATA\t2\n\n \n#define GCMD_LAY_INPUT_CMD\t\tGENMASK_ULL(23, 16)\n\n \n#define GCMD_LAY_INPUT_ADDR\t\tGENMASK_ULL(63, 16)\n \n#define GCMD_LAY_INPUT_ADDR_SIZE\tGENMASK_ULL(13, 11)\n\n \n#define GCMD_DIR\t\t\tBIT_ULL(11)\n \n#define\t\tGCMD_DIR_READ\t\t0\n \n#define\t\tGCMD_DIR_WRITE\t\t1\n\n \n#define GCMD_ECC_EN\t\t\tBIT_ULL(12)\n \n#define GCMD_SECT_SIZE\t\t\tGENMASK_ULL(31, 16)\n \n#define GCMD_SECT_CNT\t\t\tGENMASK_ULL(39, 32)\n \n#define GCMD_LAST_SIZE\t\t\tGENMASK_ULL(55, 40)\n\n \n \n#define CDMA_CT_ERASE\t\t0x1000\n \n#define CDMA_CT_WR\t\t0x2100\n \n#define CDMA_CT_RD\t\t0x2200\n\n \n#define CDMA_CFPTR_MEM_SHIFT\t24\n \n#define CDMA_CFPTR_MEM\t\tGENMASK(26, 24)\n\n \n#define CDMA_CF_INT\t\tBIT(8)\n \n#define CDMA_CF_CONT\t\tBIT(9)\n \n#define CDMA_CF_DMA_MASTER\tBIT(10)\n\n \n#define CDMA_CS_COMP\t\tBIT(15)\n \n \n#define CDMA_CS_FAIL\t\tBIT(14)\n \n#define CDMA_CS_ERP\t\tBIT(11)\n \n#define CDMA_CS_TOUT\t\tBIT(10)\n \n#define CDMA_CS_MAXERR\t\tGENMASK(9, 2)\n \n#define CDMA_CS_UNCE\t\tBIT(1)\n \n#define CDMA_CS_ERR\t\tBIT(0)\n\n \n#define STAT_OK\t\t\t0\n \n#define STAT_FAIL\t\t2\n \n#define STAT_ECC_UNCORR\t\t3\n \n#define STAT_ERASED\t\t5\n \n#define STAT_ECC_CORR\t\t6\n \n#define STAT_UNKNOWN\t\t7\n \n#define STAT_BUSY\t\t0xFF\n\n#define BCH_MAX_NUM_CORR_CAPS\t\t8\n#define BCH_MAX_NUM_SECTOR_SIZES\t2\n\nstruct cadence_nand_timings {\n\tu32 async_toggle_timings;\n\tu32 timings0;\n\tu32 timings1;\n\tu32 timings2;\n\tu32 dll_phy_ctrl;\n\tu32 phy_ctrl;\n\tu32 phy_dqs_timing;\n\tu32 phy_gate_lpbk_ctrl;\n};\n\n \nstruct cadence_nand_cdma_desc {\n\t \n\tu64 next_pointer;\n\n\t \n\tu32 flash_pointer;\n\t \n\tu16 bank;\n\tu16 rsvd0;\n\n\t \n\tu16 command_type;\n\tu16 rsvd1;\n\t \n\tu16 command_flags;\n\tu16 rsvd2;\n\n\t \n\tu64 memory_pointer;\n\n\t \n\tu32 status;\n\tu32 rsvd3;\n\n\t \n\tu64 sync_flag_pointer;\n\n\t \n\tu32 sync_arguments;\n\tu32 rsvd4;\n\n\t \n\tu64 ctrl_data_ptr;\n};\n\n \nstruct cadence_nand_irq_status {\n\t \n\tu32 trd_status;\n\t \n\tu32 trd_error;\n\t \n\tu32 status;\n};\n\n \nstruct cadence_nand_dt_devdata {\n\t \n\tu32 if_skew;\n\t \n\tunsigned int has_dma:1;\n};\n\n \nstruct cdns_nand_caps {\n\t \n\tu8 max_banks;\n\t \n\tu8 data_dma_width;\n\t \n\tbool data_control_supp;\n\t \n\tbool is_phy_type_dll;\n};\n\nstruct cdns_nand_ctrl {\n\tstruct device *dev;\n\tstruct nand_controller controller;\n\tstruct cadence_nand_cdma_desc *cdma_desc;\n\t \n\tconst struct cadence_nand_dt_devdata *caps1;\n\tstruct cdns_nand_caps caps2;\n\tu8 ctrl_rev;\n\tdma_addr_t dma_cdma_desc;\n\tu8 *buf;\n\tu32 buf_size;\n\tu8 curr_corr_str_idx;\n\n\t \n\tvoid __iomem *reg;\n\n\tstruct {\n\t\tvoid __iomem *virt;\n\t\tdma_addr_t dma;\n\t} io;\n\n\tint irq;\n\t \n\tstruct cadence_nand_irq_status irq_status;\n\t \n\tstruct cadence_nand_irq_status irq_mask;\n\tstruct completion complete;\n\t \n\tspinlock_t irq_lock;\n\n\tint ecc_strengths[BCH_MAX_NUM_CORR_CAPS];\n\tstruct nand_ecc_step_info ecc_stepinfos[BCH_MAX_NUM_SECTOR_SIZES];\n\tstruct nand_ecc_caps ecc_caps;\n\n\tint curr_trans_type;\n\n\tstruct dma_chan *dmac;\n\n\tu32 nf_clk_rate;\n\t \n\tu32 board_delay;\n\n\tstruct nand_chip *selected_chip;\n\n\tunsigned long assigned_cs;\n\tstruct list_head chips;\n\tu8 bch_metadata_size;\n};\n\nstruct cdns_nand_chip {\n\tstruct cadence_nand_timings timings;\n\tstruct nand_chip chip;\n\tu8 nsels;\n\tstruct list_head node;\n\n\t \n\tu32 avail_oob_size;\n\n\t \n\tu32 sector_size;\n\tu32 sector_count;\n\n\t \n\tu8 bbm_offs;\n\t \n\tu8 bbm_len;\n\t \n\tu8 corr_str_idx;\n\n\tu8 cs[];\n};\n\nstruct ecc_info {\n\tint (*calc_ecc_bytes)(int step_size, int strength);\n\tint max_step_size;\n};\n\nstatic inline struct\ncdns_nand_chip *to_cdns_nand_chip(struct nand_chip *chip)\n{\n\treturn container_of(chip, struct cdns_nand_chip, chip);\n}\n\nstatic inline struct\ncdns_nand_ctrl *to_cdns_nand_ctrl(struct nand_controller *controller)\n{\n\treturn container_of(controller, struct cdns_nand_ctrl, controller);\n}\n\nstatic bool\ncadence_nand_dma_buf_ok(struct cdns_nand_ctrl *cdns_ctrl, const void *buf,\n\t\t\tu32 buf_len)\n{\n\tu8 data_dma_width = cdns_ctrl->caps2.data_dma_width;\n\n\treturn buf && virt_addr_valid(buf) &&\n\t\tlikely(IS_ALIGNED((uintptr_t)buf, data_dma_width)) &&\n\t\tlikely(IS_ALIGNED(buf_len, DMA_DATA_SIZE_ALIGN));\n}\n\nstatic int cadence_nand_wait_for_value(struct cdns_nand_ctrl *cdns_ctrl,\n\t\t\t\t       u32 reg_offset, u32 timeout_us,\n\t\t\t\t       u32 mask, bool is_clear)\n{\n\tu32 val;\n\tint ret;\n\n\tret = readl_relaxed_poll_timeout(cdns_ctrl->reg + reg_offset,\n\t\t\t\t\t val, !(val & mask) == is_clear,\n\t\t\t\t\t 10, timeout_us);\n\n\tif (ret < 0) {\n\t\tdev_err(cdns_ctrl->dev,\n\t\t\t\"Timeout while waiting for reg %x with mask %x is clear %d\\n\",\n\t\t\treg_offset, mask, is_clear);\n\t}\n\n\treturn ret;\n}\n\nstatic int cadence_nand_set_ecc_enable(struct cdns_nand_ctrl *cdns_ctrl,\n\t\t\t\t       bool enable)\n{\n\tu32 reg;\n\n\tif (cadence_nand_wait_for_value(cdns_ctrl, CTRL_STATUS,\n\t\t\t\t\t1000000,\n\t\t\t\t\tCTRL_STATUS_CTRL_BUSY, true))\n\t\treturn -ETIMEDOUT;\n\n\treg = readl_relaxed(cdns_ctrl->reg + ECC_CONFIG_0);\n\n\tif (enable)\n\t\treg |= ECC_CONFIG_0_ECC_EN;\n\telse\n\t\treg &= ~ECC_CONFIG_0_ECC_EN;\n\n\twritel_relaxed(reg, cdns_ctrl->reg + ECC_CONFIG_0);\n\n\treturn 0;\n}\n\nstatic void cadence_nand_set_ecc_strength(struct cdns_nand_ctrl *cdns_ctrl,\n\t\t\t\t\t  u8 corr_str_idx)\n{\n\tu32 reg;\n\n\tif (cdns_ctrl->curr_corr_str_idx == corr_str_idx)\n\t\treturn;\n\n\treg = readl_relaxed(cdns_ctrl->reg + ECC_CONFIG_0);\n\treg &= ~ECC_CONFIG_0_CORR_STR;\n\treg |= FIELD_PREP(ECC_CONFIG_0_CORR_STR, corr_str_idx);\n\twritel_relaxed(reg, cdns_ctrl->reg + ECC_CONFIG_0);\n\n\tcdns_ctrl->curr_corr_str_idx = corr_str_idx;\n}\n\nstatic int cadence_nand_get_ecc_strength_idx(struct cdns_nand_ctrl *cdns_ctrl,\n\t\t\t\t\t     u8 strength)\n{\n\tint i, corr_str_idx = -1;\n\n\tfor (i = 0; i < BCH_MAX_NUM_CORR_CAPS; i++) {\n\t\tif (cdns_ctrl->ecc_strengths[i] == strength) {\n\t\t\tcorr_str_idx = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn corr_str_idx;\n}\n\nstatic int cadence_nand_set_skip_marker_val(struct cdns_nand_ctrl *cdns_ctrl,\n\t\t\t\t\t    u16 marker_value)\n{\n\tu32 reg;\n\n\tif (cadence_nand_wait_for_value(cdns_ctrl, CTRL_STATUS,\n\t\t\t\t\t1000000,\n\t\t\t\t\tCTRL_STATUS_CTRL_BUSY, true))\n\t\treturn -ETIMEDOUT;\n\n\treg = readl_relaxed(cdns_ctrl->reg + SKIP_BYTES_CONF);\n\treg &= ~SKIP_BYTES_MARKER_VALUE;\n\treg |= FIELD_PREP(SKIP_BYTES_MARKER_VALUE,\n\t\t\t  marker_value);\n\n\twritel_relaxed(reg, cdns_ctrl->reg + SKIP_BYTES_CONF);\n\n\treturn 0;\n}\n\nstatic int cadence_nand_set_skip_bytes_conf(struct cdns_nand_ctrl *cdns_ctrl,\n\t\t\t\t\t    u8 num_of_bytes,\n\t\t\t\t\t    u32 offset_value,\n\t\t\t\t\t    int enable)\n{\n\tu32 reg, skip_bytes_offset;\n\n\tif (cadence_nand_wait_for_value(cdns_ctrl, CTRL_STATUS,\n\t\t\t\t\t1000000,\n\t\t\t\t\tCTRL_STATUS_CTRL_BUSY, true))\n\t\treturn -ETIMEDOUT;\n\n\tif (!enable) {\n\t\tnum_of_bytes = 0;\n\t\toffset_value = 0;\n\t}\n\n\treg = readl_relaxed(cdns_ctrl->reg + SKIP_BYTES_CONF);\n\treg &= ~SKIP_BYTES_NUM_OF_BYTES;\n\treg |= FIELD_PREP(SKIP_BYTES_NUM_OF_BYTES,\n\t\t\t  num_of_bytes);\n\tskip_bytes_offset = FIELD_PREP(SKIP_BYTES_OFFSET_VALUE,\n\t\t\t\t       offset_value);\n\n\twritel_relaxed(reg, cdns_ctrl->reg + SKIP_BYTES_CONF);\n\twritel_relaxed(skip_bytes_offset, cdns_ctrl->reg + SKIP_BYTES_OFFSET);\n\n\treturn 0;\n}\n\n \nstatic void cadence_nand_set_erase_detection(struct cdns_nand_ctrl *cdns_ctrl,\n\t\t\t\t\t     bool enable,\n\t\t\t\t\t     u8 bitflips_threshold)\n{\n\tu32 reg;\n\n\treg = readl_relaxed(cdns_ctrl->reg + ECC_CONFIG_0);\n\n\tif (enable)\n\t\treg |= ECC_CONFIG_0_ERASE_DET_EN;\n\telse\n\t\treg &= ~ECC_CONFIG_0_ERASE_DET_EN;\n\n\twritel_relaxed(reg, cdns_ctrl->reg + ECC_CONFIG_0);\n\twritel_relaxed(bitflips_threshold, cdns_ctrl->reg + ECC_CONFIG_1);\n}\n\nstatic int cadence_nand_set_access_width16(struct cdns_nand_ctrl *cdns_ctrl,\n\t\t\t\t\t   bool bit_bus16)\n{\n\tu32 reg;\n\n\tif (cadence_nand_wait_for_value(cdns_ctrl, CTRL_STATUS,\n\t\t\t\t\t1000000,\n\t\t\t\t\tCTRL_STATUS_CTRL_BUSY, true))\n\t\treturn -ETIMEDOUT;\n\n\treg = readl_relaxed(cdns_ctrl->reg + COMMON_SET);\n\n\tif (!bit_bus16)\n\t\treg &= ~COMMON_SET_DEVICE_16BIT;\n\telse\n\t\treg |= COMMON_SET_DEVICE_16BIT;\n\twritel_relaxed(reg, cdns_ctrl->reg + COMMON_SET);\n\n\treturn 0;\n}\n\nstatic void\ncadence_nand_clear_interrupt(struct cdns_nand_ctrl *cdns_ctrl,\n\t\t\t     struct cadence_nand_irq_status *irq_status)\n{\n\twritel_relaxed(irq_status->status, cdns_ctrl->reg + INTR_STATUS);\n\twritel_relaxed(irq_status->trd_status,\n\t\t       cdns_ctrl->reg + TRD_COMP_INT_STATUS);\n\twritel_relaxed(irq_status->trd_error,\n\t\t       cdns_ctrl->reg + TRD_ERR_INT_STATUS);\n}\n\nstatic void\ncadence_nand_read_int_status(struct cdns_nand_ctrl *cdns_ctrl,\n\t\t\t     struct cadence_nand_irq_status *irq_status)\n{\n\tirq_status->status = readl_relaxed(cdns_ctrl->reg + INTR_STATUS);\n\tirq_status->trd_status = readl_relaxed(cdns_ctrl->reg\n\t\t\t\t\t       + TRD_COMP_INT_STATUS);\n\tirq_status->trd_error = readl_relaxed(cdns_ctrl->reg\n\t\t\t\t\t      + TRD_ERR_INT_STATUS);\n}\n\nstatic u32 irq_detected(struct cdns_nand_ctrl *cdns_ctrl,\n\t\t\tstruct cadence_nand_irq_status *irq_status)\n{\n\tcadence_nand_read_int_status(cdns_ctrl, irq_status);\n\n\treturn irq_status->status || irq_status->trd_status ||\n\t\tirq_status->trd_error;\n}\n\nstatic void cadence_nand_reset_irq(struct cdns_nand_ctrl *cdns_ctrl)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&cdns_ctrl->irq_lock, flags);\n\tmemset(&cdns_ctrl->irq_status, 0, sizeof(cdns_ctrl->irq_status));\n\tmemset(&cdns_ctrl->irq_mask, 0, sizeof(cdns_ctrl->irq_mask));\n\tspin_unlock_irqrestore(&cdns_ctrl->irq_lock, flags);\n}\n\n \nstatic irqreturn_t cadence_nand_isr(int irq, void *dev_id)\n{\n\tstruct cdns_nand_ctrl *cdns_ctrl = dev_id;\n\tstruct cadence_nand_irq_status irq_status;\n\tirqreturn_t result = IRQ_NONE;\n\n\tspin_lock(&cdns_ctrl->irq_lock);\n\n\tif (irq_detected(cdns_ctrl, &irq_status)) {\n\t\t \n\t\t \n\t\tcadence_nand_clear_interrupt(cdns_ctrl, &irq_status);\n\t\t \n\t\tcdns_ctrl->irq_status.status |= irq_status.status;\n\t\tcdns_ctrl->irq_status.trd_status |= irq_status.trd_status;\n\t\tcdns_ctrl->irq_status.trd_error |= irq_status.trd_error;\n\t\t \n\t\tcomplete(&cdns_ctrl->complete);\n\t\t \n\t\tresult = IRQ_HANDLED;\n\t}\n\tspin_unlock(&cdns_ctrl->irq_lock);\n\n\treturn result;\n}\n\nstatic void cadence_nand_set_irq_mask(struct cdns_nand_ctrl *cdns_ctrl,\n\t\t\t\t      struct cadence_nand_irq_status *irq_mask)\n{\n\twritel_relaxed(INTR_ENABLE_INTR_EN | irq_mask->status,\n\t\t       cdns_ctrl->reg + INTR_ENABLE);\n\n\twritel_relaxed(irq_mask->trd_error,\n\t\t       cdns_ctrl->reg + TRD_ERR_INT_STATUS_EN);\n}\n\nstatic void\ncadence_nand_wait_for_irq(struct cdns_nand_ctrl *cdns_ctrl,\n\t\t\t  struct cadence_nand_irq_status *irq_mask,\n\t\t\t  struct cadence_nand_irq_status *irq_status)\n{\n\tunsigned long timeout = msecs_to_jiffies(10000);\n\tunsigned long time_left;\n\n\ttime_left = wait_for_completion_timeout(&cdns_ctrl->complete,\n\t\t\t\t\t\ttimeout);\n\n\t*irq_status = cdns_ctrl->irq_status;\n\tif (time_left == 0) {\n\t\t \n\t\tdev_err(cdns_ctrl->dev, \"timeout occurred:\\n\");\n\t\tdev_err(cdns_ctrl->dev, \"\\tstatus = 0x%x, mask = 0x%x\\n\",\n\t\t\tirq_status->status, irq_mask->status);\n\t\tdev_err(cdns_ctrl->dev,\n\t\t\t\"\\ttrd_status = 0x%x, trd_status mask = 0x%x\\n\",\n\t\t\tirq_status->trd_status, irq_mask->trd_status);\n\t\tdev_err(cdns_ctrl->dev,\n\t\t\t\"\\t trd_error = 0x%x, trd_error mask = 0x%x\\n\",\n\t\t\tirq_status->trd_error, irq_mask->trd_error);\n\t}\n}\n\n \nstatic int cadence_nand_generic_cmd_send(struct cdns_nand_ctrl *cdns_ctrl,\n\t\t\t\t\t u8 chip_nr,\n\t\t\t\t\t u64 mini_ctrl_cmd)\n{\n\tu32 mini_ctrl_cmd_l, mini_ctrl_cmd_h, reg;\n\n\tmini_ctrl_cmd |= FIELD_PREP(GCMD_LAY_CS, chip_nr);\n\tmini_ctrl_cmd_l = mini_ctrl_cmd & 0xFFFFFFFF;\n\tmini_ctrl_cmd_h = mini_ctrl_cmd >> 32;\n\n\tif (cadence_nand_wait_for_value(cdns_ctrl, CTRL_STATUS,\n\t\t\t\t\t1000000,\n\t\t\t\t\tCTRL_STATUS_CTRL_BUSY, true))\n\t\treturn -ETIMEDOUT;\n\n\tcadence_nand_reset_irq(cdns_ctrl);\n\n\twritel_relaxed(mini_ctrl_cmd_l, cdns_ctrl->reg + CMD_REG2);\n\twritel_relaxed(mini_ctrl_cmd_h, cdns_ctrl->reg + CMD_REG3);\n\n\t \n\treg = FIELD_PREP(CMD_REG0_CT, CMD_REG0_CT_GEN);\n\t \n\treg |= FIELD_PREP(CMD_REG0_TN, 0);\n\n\t \n\twritel_relaxed(reg, cdns_ctrl->reg + CMD_REG0);\n\n\treturn 0;\n}\n\n \nstatic int cadence_nand_wait_on_sdma(struct cdns_nand_ctrl *cdns_ctrl,\n\t\t\t\t     u8 *out_sdma_trd,\n\t\t\t\t     u32 *out_sdma_size)\n{\n\tstruct cadence_nand_irq_status irq_mask, irq_status;\n\n\tirq_mask.trd_status = 0;\n\tirq_mask.trd_error = 0;\n\tirq_mask.status = INTR_STATUS_SDMA_TRIGG\n\t\t| INTR_STATUS_SDMA_ERR\n\t\t| INTR_STATUS_UNSUPP_CMD;\n\n\tcadence_nand_set_irq_mask(cdns_ctrl, &irq_mask);\n\tcadence_nand_wait_for_irq(cdns_ctrl, &irq_mask, &irq_status);\n\tif (irq_status.status == 0) {\n\t\tdev_err(cdns_ctrl->dev, \"Timeout while waiting for SDMA\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\tif (irq_status.status & INTR_STATUS_SDMA_TRIGG) {\n\t\t*out_sdma_size = readl_relaxed(cdns_ctrl->reg + SDMA_SIZE);\n\t\t*out_sdma_trd  = readl_relaxed(cdns_ctrl->reg + SDMA_TRD_NUM);\n\t\t*out_sdma_trd =\n\t\t\tFIELD_GET(SDMA_TRD_NUM_SDMA_TRD, *out_sdma_trd);\n\t} else {\n\t\tdev_err(cdns_ctrl->dev, \"SDMA error - irq_status %x\\n\",\n\t\t\tirq_status.status);\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic void cadence_nand_get_caps(struct cdns_nand_ctrl *cdns_ctrl)\n{\n\tu32  reg;\n\n\treg = readl_relaxed(cdns_ctrl->reg + CTRL_FEATURES);\n\n\tcdns_ctrl->caps2.max_banks = 1 << FIELD_GET(CTRL_FEATURES_N_BANKS, reg);\n\n\tif (FIELD_GET(CTRL_FEATURES_DMA_DWITH64, reg))\n\t\tcdns_ctrl->caps2.data_dma_width = 8;\n\telse\n\t\tcdns_ctrl->caps2.data_dma_width = 4;\n\n\tif (reg & CTRL_FEATURES_CONTROL_DATA)\n\t\tcdns_ctrl->caps2.data_control_supp = true;\n\n\tif (reg & (CTRL_FEATURES_NVDDR_2_3\n\t\t   | CTRL_FEATURES_NVDDR))\n\t\tcdns_ctrl->caps2.is_phy_type_dll = true;\n}\n\n \nstatic void\ncadence_nand_cdma_desc_prepare(struct cdns_nand_ctrl *cdns_ctrl,\n\t\t\t       char nf_mem, u32 flash_ptr, dma_addr_t mem_ptr,\n\t\t\t\t   dma_addr_t ctrl_data_ptr, u16 ctype)\n{\n\tstruct cadence_nand_cdma_desc *cdma_desc = cdns_ctrl->cdma_desc;\n\n\tmemset(cdma_desc, 0, sizeof(struct cadence_nand_cdma_desc));\n\n\t \n\tcdma_desc->flash_pointer = flash_ptr;\n\tif (cdns_ctrl->ctrl_rev >= 13)\n\t\tcdma_desc->bank = nf_mem;\n\telse\n\t\tcdma_desc->flash_pointer |= (nf_mem << CDMA_CFPTR_MEM_SHIFT);\n\n\tcdma_desc->command_flags |= CDMA_CF_DMA_MASTER;\n\tcdma_desc->command_flags  |= CDMA_CF_INT;\n\n\tcdma_desc->memory_pointer = mem_ptr;\n\tcdma_desc->status = 0;\n\tcdma_desc->sync_flag_pointer = 0;\n\tcdma_desc->sync_arguments = 0;\n\n\tcdma_desc->command_type = ctype;\n\tcdma_desc->ctrl_data_ptr = ctrl_data_ptr;\n}\n\nstatic u8 cadence_nand_check_desc_error(struct cdns_nand_ctrl *cdns_ctrl,\n\t\t\t\t\tu32 desc_status)\n{\n\tif (desc_status & CDMA_CS_ERP)\n\t\treturn STAT_ERASED;\n\n\tif (desc_status & CDMA_CS_UNCE)\n\t\treturn STAT_ECC_UNCORR;\n\n\tif (desc_status & CDMA_CS_ERR) {\n\t\tdev_err(cdns_ctrl->dev, \":CDMA desc error flag detected.\\n\");\n\t\treturn STAT_FAIL;\n\t}\n\n\tif (FIELD_GET(CDMA_CS_MAXERR, desc_status))\n\t\treturn STAT_ECC_CORR;\n\n\treturn STAT_FAIL;\n}\n\nstatic int cadence_nand_cdma_finish(struct cdns_nand_ctrl *cdns_ctrl)\n{\n\tstruct cadence_nand_cdma_desc *desc_ptr = cdns_ctrl->cdma_desc;\n\tu8 status = STAT_BUSY;\n\n\tif (desc_ptr->status & CDMA_CS_FAIL) {\n\t\tstatus = cadence_nand_check_desc_error(cdns_ctrl,\n\t\t\t\t\t\t       desc_ptr->status);\n\t\tdev_err(cdns_ctrl->dev, \":CDMA error %x\\n\", desc_ptr->status);\n\t} else if (desc_ptr->status & CDMA_CS_COMP) {\n\t\t \n\t\tif (desc_ptr->command_flags & CDMA_CF_CONT) {\n\t\t\tdev_info(cdns_ctrl->dev, \"DMA unsupported flag is set\");\n\t\t\tstatus = STAT_UNKNOWN;\n\t\t} else {\n\t\t\t \n\t\t\tstatus = STAT_OK;\n\t\t}\n\t}\n\n\treturn status;\n}\n\nstatic int cadence_nand_cdma_send(struct cdns_nand_ctrl *cdns_ctrl,\n\t\t\t\t  u8 thread)\n{\n\tu32 reg;\n\tint status;\n\n\t \n\tstatus = cadence_nand_wait_for_value(cdns_ctrl, TRD_STATUS,\n\t\t\t\t\t     1000000,\n\t\t\t\t\t     BIT(thread), true);\n\tif (status)\n\t\treturn status;\n\n\tcadence_nand_reset_irq(cdns_ctrl);\n\treinit_completion(&cdns_ctrl->complete);\n\n\twritel_relaxed((u32)cdns_ctrl->dma_cdma_desc,\n\t\t       cdns_ctrl->reg + CMD_REG2);\n\twritel_relaxed(0, cdns_ctrl->reg + CMD_REG3);\n\n\t \n\treg = FIELD_PREP(CMD_REG0_CT, CMD_REG0_CT_CDMA);\n\t \n\treg |= FIELD_PREP(CMD_REG0_TN, thread);\n\t \n\twritel_relaxed(reg, cdns_ctrl->reg + CMD_REG0);\n\n\treturn 0;\n}\n\n \nstatic u32\ncadence_nand_cdma_send_and_wait(struct cdns_nand_ctrl *cdns_ctrl,\n\t\t\t\tu8 thread)\n{\n\tstruct cadence_nand_irq_status irq_mask, irq_status = {0};\n\tint status;\n\n\tirq_mask.trd_status = BIT(thread);\n\tirq_mask.trd_error = BIT(thread);\n\tirq_mask.status = INTR_STATUS_CDMA_TERR;\n\n\tcadence_nand_set_irq_mask(cdns_ctrl, &irq_mask);\n\n\tstatus = cadence_nand_cdma_send(cdns_ctrl, thread);\n\tif (status)\n\t\treturn status;\n\n\tcadence_nand_wait_for_irq(cdns_ctrl, &irq_mask, &irq_status);\n\n\tif (irq_status.status == 0 && irq_status.trd_status == 0 &&\n\t    irq_status.trd_error == 0) {\n\t\tdev_err(cdns_ctrl->dev, \"CDMA command timeout\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\tif (irq_status.status & irq_mask.status) {\n\t\tdev_err(cdns_ctrl->dev, \"CDMA command failed\\n\");\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int cadence_nand_calc_ecc_bytes(int max_step_size, int strength)\n{\n\tint nbytes = DIV_ROUND_UP(fls(8 * max_step_size) * strength, 8);\n\n\treturn ALIGN(nbytes, 2);\n}\n\n#define CADENCE_NAND_CALC_ECC_BYTES(max_step_size) \\\n\tstatic int \\\n\tcadence_nand_calc_ecc_bytes_##max_step_size(int step_size, \\\n\t\t\t\t\t\t    int strength)\\\n\t{\\\n\t\treturn cadence_nand_calc_ecc_bytes(max_step_size, strength);\\\n\t}\n\nCADENCE_NAND_CALC_ECC_BYTES(256)\nCADENCE_NAND_CALC_ECC_BYTES(512)\nCADENCE_NAND_CALC_ECC_BYTES(1024)\nCADENCE_NAND_CALC_ECC_BYTES(2048)\nCADENCE_NAND_CALC_ECC_BYTES(4096)\n\n \nstatic int cadence_nand_read_bch_caps(struct cdns_nand_ctrl *cdns_ctrl)\n{\n\tstruct nand_ecc_caps *ecc_caps = &cdns_ctrl->ecc_caps;\n\tint max_step_size = 0, nstrengths, i;\n\tu32 reg;\n\n\treg = readl_relaxed(cdns_ctrl->reg + BCH_CFG_3);\n\tcdns_ctrl->bch_metadata_size = FIELD_GET(BCH_CFG_3_METADATA_SIZE, reg);\n\tif (cdns_ctrl->bch_metadata_size < 4) {\n\t\tdev_err(cdns_ctrl->dev,\n\t\t\t\"Driver needs at least 4 bytes of BCH meta data\\n\");\n\t\treturn -EIO;\n\t}\n\n\treg = readl_relaxed(cdns_ctrl->reg + BCH_CFG_0);\n\tcdns_ctrl->ecc_strengths[0] = FIELD_GET(BCH_CFG_0_CORR_CAP_0, reg);\n\tcdns_ctrl->ecc_strengths[1] = FIELD_GET(BCH_CFG_0_CORR_CAP_1, reg);\n\tcdns_ctrl->ecc_strengths[2] = FIELD_GET(BCH_CFG_0_CORR_CAP_2, reg);\n\tcdns_ctrl->ecc_strengths[3] = FIELD_GET(BCH_CFG_0_CORR_CAP_3, reg);\n\n\treg = readl_relaxed(cdns_ctrl->reg + BCH_CFG_1);\n\tcdns_ctrl->ecc_strengths[4] = FIELD_GET(BCH_CFG_1_CORR_CAP_4, reg);\n\tcdns_ctrl->ecc_strengths[5] = FIELD_GET(BCH_CFG_1_CORR_CAP_5, reg);\n\tcdns_ctrl->ecc_strengths[6] = FIELD_GET(BCH_CFG_1_CORR_CAP_6, reg);\n\tcdns_ctrl->ecc_strengths[7] = FIELD_GET(BCH_CFG_1_CORR_CAP_7, reg);\n\n\treg = readl_relaxed(cdns_ctrl->reg + BCH_CFG_2);\n\tcdns_ctrl->ecc_stepinfos[0].stepsize =\n\t\tFIELD_GET(BCH_CFG_2_SECT_0, reg);\n\n\tcdns_ctrl->ecc_stepinfos[1].stepsize =\n\t\tFIELD_GET(BCH_CFG_2_SECT_1, reg);\n\n\tnstrengths = 0;\n\tfor (i = 0; i < BCH_MAX_NUM_CORR_CAPS; i++) {\n\t\tif (cdns_ctrl->ecc_strengths[i] != 0)\n\t\t\tnstrengths++;\n\t}\n\n\tecc_caps->nstepinfos = 0;\n\tfor (i = 0; i < BCH_MAX_NUM_SECTOR_SIZES; i++) {\n\t\t \n\t\tcdns_ctrl->ecc_stepinfos[i].nstrengths = nstrengths;\n\t\tcdns_ctrl->ecc_stepinfos[i].strengths =\n\t\t\tcdns_ctrl->ecc_strengths;\n\n\t\tif (cdns_ctrl->ecc_stepinfos[i].stepsize != 0)\n\t\t\tecc_caps->nstepinfos++;\n\n\t\tif (cdns_ctrl->ecc_stepinfos[i].stepsize > max_step_size)\n\t\t\tmax_step_size = cdns_ctrl->ecc_stepinfos[i].stepsize;\n\t}\n\tecc_caps->stepinfos = &cdns_ctrl->ecc_stepinfos[0];\n\n\tswitch (max_step_size) {\n\tcase 256:\n\t\tecc_caps->calc_ecc_bytes = &cadence_nand_calc_ecc_bytes_256;\n\t\tbreak;\n\tcase 512:\n\t\tecc_caps->calc_ecc_bytes = &cadence_nand_calc_ecc_bytes_512;\n\t\tbreak;\n\tcase 1024:\n\t\tecc_caps->calc_ecc_bytes = &cadence_nand_calc_ecc_bytes_1024;\n\t\tbreak;\n\tcase 2048:\n\t\tecc_caps->calc_ecc_bytes = &cadence_nand_calc_ecc_bytes_2048;\n\t\tbreak;\n\tcase 4096:\n\t\tecc_caps->calc_ecc_bytes = &cadence_nand_calc_ecc_bytes_4096;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(cdns_ctrl->dev,\n\t\t\t\"Unsupported sector size(ecc step size) %d\\n\",\n\t\t\tmax_step_size);\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int cadence_nand_hw_init(struct cdns_nand_ctrl *cdns_ctrl)\n{\n\tint status;\n\tu32 reg;\n\n\tstatus = cadence_nand_wait_for_value(cdns_ctrl, CTRL_STATUS,\n\t\t\t\t\t     1000000,\n\t\t\t\t\t     CTRL_STATUS_INIT_COMP, false);\n\tif (status)\n\t\treturn status;\n\n\treg = readl_relaxed(cdns_ctrl->reg + CTRL_VERSION);\n\tcdns_ctrl->ctrl_rev = FIELD_GET(CTRL_VERSION_REV, reg);\n\n\tdev_info(cdns_ctrl->dev,\n\t\t \"%s: cadence nand controller version reg %x\\n\",\n\t\t __func__, reg);\n\n\t \n\twritel_relaxed(0, cdns_ctrl->reg + MULTIPLANE_CFG);\n\twritel_relaxed(0, cdns_ctrl->reg + CACHE_CFG);\n\n\t \n\twritel_relaxed(0xFFFFFFFF, cdns_ctrl->reg + INTR_STATUS);\n\n\tcadence_nand_get_caps(cdns_ctrl);\n\tif (cadence_nand_read_bch_caps(cdns_ctrl))\n\t\treturn -EIO;\n\n#ifndef CONFIG_64BIT\n\tif (cdns_ctrl->caps2.data_dma_width == 8) {\n\t\tdev_err(cdns_ctrl->dev,\n\t\t\t\"cannot access 64-bit dma on !64-bit architectures\");\n\t\treturn -EIO;\n\t}\n#endif\n\n\t \n\tstatus = cadence_nand_set_access_width16(cdns_ctrl, false);\n\n\treturn status;\n}\n\n#define TT_MAIN_OOB_AREAS\t2\n#define TT_RAW_PAGE\t\t3\n#define TT_BBM\t\t\t4\n#define TT_MAIN_OOB_AREA_EXT\t5\n\n \nstatic void\ncadence_nand_prepare_data_size(struct nand_chip *chip,\n\t\t\t       int transfer_type)\n{\n\tstruct cdns_nand_ctrl *cdns_ctrl = to_cdns_nand_ctrl(chip->controller);\n\tstruct cdns_nand_chip *cdns_chip = to_cdns_nand_chip(chip);\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tu32 sec_size = 0, offset = 0, sec_cnt = 1;\n\tu32 last_sec_size = cdns_chip->sector_size;\n\tu32 data_ctrl_size = 0;\n\tu32 reg = 0;\n\n\tif (cdns_ctrl->curr_trans_type == transfer_type)\n\t\treturn;\n\n\tswitch (transfer_type) {\n\tcase TT_MAIN_OOB_AREA_EXT:\n\t\tsec_cnt = cdns_chip->sector_count;\n\t\tsec_size = cdns_chip->sector_size;\n\t\tdata_ctrl_size = cdns_chip->avail_oob_size;\n\t\tbreak;\n\tcase TT_MAIN_OOB_AREAS:\n\t\tsec_cnt = cdns_chip->sector_count;\n\t\tlast_sec_size = cdns_chip->sector_size\n\t\t\t+ cdns_chip->avail_oob_size;\n\t\tsec_size = cdns_chip->sector_size;\n\t\tbreak;\n\tcase TT_RAW_PAGE:\n\t\tlast_sec_size = mtd->writesize + mtd->oobsize;\n\t\tbreak;\n\tcase TT_BBM:\n\t\toffset = mtd->writesize + cdns_chip->bbm_offs;\n\t\tlast_sec_size = 8;\n\t\tbreak;\n\t}\n\n\treg = 0;\n\treg |= FIELD_PREP(TRAN_CFG_0_OFFSET, offset);\n\treg |= FIELD_PREP(TRAN_CFG_0_SEC_CNT, sec_cnt);\n\twritel_relaxed(reg, cdns_ctrl->reg + TRAN_CFG_0);\n\n\treg = 0;\n\treg |= FIELD_PREP(TRAN_CFG_1_LAST_SEC_SIZE, last_sec_size);\n\treg |= FIELD_PREP(TRAN_CFG_1_SECTOR_SIZE, sec_size);\n\twritel_relaxed(reg, cdns_ctrl->reg + TRAN_CFG_1);\n\n\tif (cdns_ctrl->caps2.data_control_supp) {\n\t\treg = readl_relaxed(cdns_ctrl->reg + CONTROL_DATA_CTRL);\n\t\treg &= ~CONTROL_DATA_CTRL_SIZE;\n\t\treg |= FIELD_PREP(CONTROL_DATA_CTRL_SIZE, data_ctrl_size);\n\t\twritel_relaxed(reg, cdns_ctrl->reg + CONTROL_DATA_CTRL);\n\t}\n\n\tcdns_ctrl->curr_trans_type = transfer_type;\n}\n\nstatic int\ncadence_nand_cdma_transfer(struct cdns_nand_ctrl *cdns_ctrl, u8 chip_nr,\n\t\t\t   int page, void *buf, void *ctrl_dat, u32 buf_size,\n\t\t\t   u32 ctrl_dat_size, enum dma_data_direction dir,\n\t\t\t   bool with_ecc)\n{\n\tdma_addr_t dma_buf, dma_ctrl_dat = 0;\n\tu8 thread_nr = chip_nr;\n\tint status;\n\tu16 ctype;\n\n\tif (dir == DMA_FROM_DEVICE)\n\t\tctype = CDMA_CT_RD;\n\telse\n\t\tctype = CDMA_CT_WR;\n\n\tcadence_nand_set_ecc_enable(cdns_ctrl, with_ecc);\n\n\tdma_buf = dma_map_single(cdns_ctrl->dev, buf, buf_size, dir);\n\tif (dma_mapping_error(cdns_ctrl->dev, dma_buf)) {\n\t\tdev_err(cdns_ctrl->dev, \"Failed to map DMA buffer\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (ctrl_dat && ctrl_dat_size) {\n\t\tdma_ctrl_dat = dma_map_single(cdns_ctrl->dev, ctrl_dat,\n\t\t\t\t\t      ctrl_dat_size, dir);\n\t\tif (dma_mapping_error(cdns_ctrl->dev, dma_ctrl_dat)) {\n\t\t\tdma_unmap_single(cdns_ctrl->dev, dma_buf,\n\t\t\t\t\t buf_size, dir);\n\t\t\tdev_err(cdns_ctrl->dev, \"Failed to map DMA buffer\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\tcadence_nand_cdma_desc_prepare(cdns_ctrl, chip_nr, page,\n\t\t\t\t       dma_buf, dma_ctrl_dat, ctype);\n\n\tstatus = cadence_nand_cdma_send_and_wait(cdns_ctrl, thread_nr);\n\n\tdma_unmap_single(cdns_ctrl->dev, dma_buf,\n\t\t\t buf_size, dir);\n\n\tif (ctrl_dat && ctrl_dat_size)\n\t\tdma_unmap_single(cdns_ctrl->dev, dma_ctrl_dat,\n\t\t\t\t ctrl_dat_size, dir);\n\tif (status)\n\t\treturn status;\n\n\treturn cadence_nand_cdma_finish(cdns_ctrl);\n}\n\nstatic void cadence_nand_set_timings(struct cdns_nand_ctrl *cdns_ctrl,\n\t\t\t\t     struct cadence_nand_timings *t)\n{\n\twritel_relaxed(t->async_toggle_timings,\n\t\t       cdns_ctrl->reg + ASYNC_TOGGLE_TIMINGS);\n\twritel_relaxed(t->timings0, cdns_ctrl->reg + TIMINGS0);\n\twritel_relaxed(t->timings1, cdns_ctrl->reg + TIMINGS1);\n\twritel_relaxed(t->timings2, cdns_ctrl->reg + TIMINGS2);\n\n\tif (cdns_ctrl->caps2.is_phy_type_dll)\n\t\twritel_relaxed(t->dll_phy_ctrl, cdns_ctrl->reg + DLL_PHY_CTRL);\n\n\twritel_relaxed(t->phy_ctrl, cdns_ctrl->reg + PHY_CTRL);\n\n\tif (cdns_ctrl->caps2.is_phy_type_dll) {\n\t\twritel_relaxed(0, cdns_ctrl->reg + PHY_TSEL);\n\t\twritel_relaxed(2, cdns_ctrl->reg + PHY_DQ_TIMING);\n\t\twritel_relaxed(t->phy_dqs_timing,\n\t\t\t       cdns_ctrl->reg + PHY_DQS_TIMING);\n\t\twritel_relaxed(t->phy_gate_lpbk_ctrl,\n\t\t\t       cdns_ctrl->reg + PHY_GATE_LPBK_CTRL);\n\t\twritel_relaxed(PHY_DLL_MASTER_CTRL_BYPASS_MODE,\n\t\t\t       cdns_ctrl->reg + PHY_DLL_MASTER_CTRL);\n\t\twritel_relaxed(0, cdns_ctrl->reg + PHY_DLL_SLAVE_CTRL);\n\t}\n}\n\nstatic int cadence_nand_select_target(struct nand_chip *chip)\n{\n\tstruct cdns_nand_ctrl *cdns_ctrl = to_cdns_nand_ctrl(chip->controller);\n\tstruct cdns_nand_chip *cdns_chip = to_cdns_nand_chip(chip);\n\n\tif (chip == cdns_ctrl->selected_chip)\n\t\treturn 0;\n\n\tif (cadence_nand_wait_for_value(cdns_ctrl, CTRL_STATUS,\n\t\t\t\t\t1000000,\n\t\t\t\t\tCTRL_STATUS_CTRL_BUSY, true))\n\t\treturn -ETIMEDOUT;\n\n\tcadence_nand_set_timings(cdns_ctrl, &cdns_chip->timings);\n\n\tcadence_nand_set_ecc_strength(cdns_ctrl,\n\t\t\t\t      cdns_chip->corr_str_idx);\n\n\tcadence_nand_set_erase_detection(cdns_ctrl, true,\n\t\t\t\t\t chip->ecc.strength);\n\n\tcdns_ctrl->curr_trans_type = -1;\n\tcdns_ctrl->selected_chip = chip;\n\n\treturn 0;\n}\n\nstatic int cadence_nand_erase(struct nand_chip *chip, u32 page)\n{\n\tstruct cdns_nand_ctrl *cdns_ctrl = to_cdns_nand_ctrl(chip->controller);\n\tstruct cdns_nand_chip *cdns_chip = to_cdns_nand_chip(chip);\n\tint status;\n\tu8 thread_nr = cdns_chip->cs[chip->cur_cs];\n\n\tcadence_nand_cdma_desc_prepare(cdns_ctrl,\n\t\t\t\t       cdns_chip->cs[chip->cur_cs],\n\t\t\t\t       page, 0, 0,\n\t\t\t\t       CDMA_CT_ERASE);\n\tstatus = cadence_nand_cdma_send_and_wait(cdns_ctrl, thread_nr);\n\tif (status) {\n\t\tdev_err(cdns_ctrl->dev, \"erase operation failed\\n\");\n\t\treturn -EIO;\n\t}\n\n\tstatus = cadence_nand_cdma_finish(cdns_ctrl);\n\tif (status)\n\t\treturn status;\n\n\treturn 0;\n}\n\nstatic int cadence_nand_read_bbm(struct nand_chip *chip, int page, u8 *buf)\n{\n\tint status;\n\tstruct cdns_nand_ctrl *cdns_ctrl = to_cdns_nand_ctrl(chip->controller);\n\tstruct cdns_nand_chip *cdns_chip = to_cdns_nand_chip(chip);\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\n\tcadence_nand_prepare_data_size(chip, TT_BBM);\n\n\tcadence_nand_set_skip_bytes_conf(cdns_ctrl, 0, 0, 0);\n\n\t \n\tstatus = cadence_nand_cdma_transfer(cdns_ctrl,\n\t\t\t\t\t    cdns_chip->cs[chip->cur_cs],\n\t\t\t\t\t    page, cdns_ctrl->buf, NULL,\n\t\t\t\t\t    mtd->oobsize,\n\t\t\t\t\t    0, DMA_FROM_DEVICE, false);\n\tif (status) {\n\t\tdev_err(cdns_ctrl->dev, \"read BBM failed\\n\");\n\t\treturn -EIO;\n\t}\n\n\tmemcpy(buf + cdns_chip->bbm_offs, cdns_ctrl->buf, cdns_chip->bbm_len);\n\n\treturn 0;\n}\n\nstatic int cadence_nand_write_page(struct nand_chip *chip,\n\t\t\t\t   const u8 *buf, int oob_required,\n\t\t\t\t   int page)\n{\n\tstruct cdns_nand_ctrl *cdns_ctrl = to_cdns_nand_ctrl(chip->controller);\n\tstruct cdns_nand_chip *cdns_chip = to_cdns_nand_chip(chip);\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tint status;\n\tu16 marker_val = 0xFFFF;\n\n\tstatus = cadence_nand_select_target(chip);\n\tif (status)\n\t\treturn status;\n\n\tcadence_nand_set_skip_bytes_conf(cdns_ctrl, cdns_chip->bbm_len,\n\t\t\t\t\t mtd->writesize\n\t\t\t\t\t + cdns_chip->bbm_offs,\n\t\t\t\t\t 1);\n\n\tif (oob_required) {\n\t\tmarker_val = *(u16 *)(chip->oob_poi\n\t\t\t\t      + cdns_chip->bbm_offs);\n\t} else {\n\t\t \n\t\tmemset(cdns_ctrl->buf + mtd->writesize, 0xFF,\n\t\t       cdns_chip->avail_oob_size);\n\t}\n\n\tcadence_nand_set_skip_marker_val(cdns_ctrl, marker_val);\n\n\tcadence_nand_prepare_data_size(chip, TT_MAIN_OOB_AREA_EXT);\n\n\tif (cadence_nand_dma_buf_ok(cdns_ctrl, buf, mtd->writesize) &&\n\t    cdns_ctrl->caps2.data_control_supp) {\n\t\tu8 *oob;\n\n\t\tif (oob_required)\n\t\t\toob = chip->oob_poi;\n\t\telse\n\t\t\toob = cdns_ctrl->buf + mtd->writesize;\n\n\t\tstatus = cadence_nand_cdma_transfer(cdns_ctrl,\n\t\t\t\t\t\t    cdns_chip->cs[chip->cur_cs],\n\t\t\t\t\t\t    page, (void *)buf, oob,\n\t\t\t\t\t\t    mtd->writesize,\n\t\t\t\t\t\t    cdns_chip->avail_oob_size,\n\t\t\t\t\t\t    DMA_TO_DEVICE, true);\n\t\tif (status) {\n\t\t\tdev_err(cdns_ctrl->dev, \"write page failed\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tif (oob_required) {\n\t\t \n\t\tmemcpy(cdns_ctrl->buf + mtd->writesize, chip->oob_poi,\n\t\t       cdns_chip->avail_oob_size);\n\t}\n\n\tmemcpy(cdns_ctrl->buf, buf, mtd->writesize);\n\n\tcadence_nand_prepare_data_size(chip, TT_MAIN_OOB_AREAS);\n\n\treturn cadence_nand_cdma_transfer(cdns_ctrl,\n\t\t\t\t\t  cdns_chip->cs[chip->cur_cs],\n\t\t\t\t\t  page, cdns_ctrl->buf, NULL,\n\t\t\t\t\t  mtd->writesize\n\t\t\t\t\t  + cdns_chip->avail_oob_size,\n\t\t\t\t\t  0, DMA_TO_DEVICE, true);\n}\n\nstatic int cadence_nand_write_oob(struct nand_chip *chip, int page)\n{\n\tstruct cdns_nand_ctrl *cdns_ctrl = to_cdns_nand_ctrl(chip->controller);\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\n\tmemset(cdns_ctrl->buf, 0xFF, mtd->writesize);\n\n\treturn cadence_nand_write_page(chip, cdns_ctrl->buf, 1, page);\n}\n\nstatic int cadence_nand_write_page_raw(struct nand_chip *chip,\n\t\t\t\t       const u8 *buf, int oob_required,\n\t\t\t\t       int page)\n{\n\tstruct cdns_nand_ctrl *cdns_ctrl = to_cdns_nand_ctrl(chip->controller);\n\tstruct cdns_nand_chip *cdns_chip = to_cdns_nand_chip(chip);\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tint writesize = mtd->writesize;\n\tint oobsize = mtd->oobsize;\n\tint ecc_steps = chip->ecc.steps;\n\tint ecc_size = chip->ecc.size;\n\tint ecc_bytes = chip->ecc.bytes;\n\tvoid *tmp_buf = cdns_ctrl->buf;\n\tint oob_skip = cdns_chip->bbm_len;\n\tsize_t size = writesize + oobsize;\n\tint i, pos, len;\n\tint status = 0;\n\n\tstatus = cadence_nand_select_target(chip);\n\tif (status)\n\t\treturn status;\n\n\t \n\tif (!buf || !oob_required)\n\t\tmemset(tmp_buf, 0xff, size);\n\n\tcadence_nand_set_skip_bytes_conf(cdns_ctrl, 0, 0, 0);\n\n\t \n\tif (buf) {\n\t\tfor (i = 0; i < ecc_steps; i++) {\n\t\t\tpos = i * (ecc_size + ecc_bytes);\n\t\t\tlen = ecc_size;\n\n\t\t\tif (pos >= writesize)\n\t\t\t\tpos += oob_skip;\n\t\t\telse if (pos + len > writesize)\n\t\t\t\tlen = writesize - pos;\n\n\t\t\tmemcpy(tmp_buf + pos, buf, len);\n\t\t\tbuf += len;\n\t\t\tif (len < ecc_size) {\n\t\t\t\tlen = ecc_size - len;\n\t\t\t\tmemcpy(tmp_buf + writesize + oob_skip, buf,\n\t\t\t\t       len);\n\t\t\t\tbuf += len;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (oob_required) {\n\t\tconst u8 *oob = chip->oob_poi;\n\t\tu32 oob_data_offset = (cdns_chip->sector_count - 1) *\n\t\t\t(cdns_chip->sector_size + chip->ecc.bytes)\n\t\t\t+ cdns_chip->sector_size + oob_skip;\n\n\t\t \n\t\tmemcpy(tmp_buf + writesize, oob, oob_skip);\n\n\t\t \n\t\tmemcpy(tmp_buf + oob_data_offset, oob,\n\t\t       cdns_chip->avail_oob_size);\n\t\toob += cdns_chip->avail_oob_size;\n\n\t\t \n\t\tfor (i = 0; i < ecc_steps; i++) {\n\t\t\tpos = ecc_size + i * (ecc_size + ecc_bytes);\n\t\t\tif (i == (ecc_steps - 1))\n\t\t\t\tpos += cdns_chip->avail_oob_size;\n\n\t\t\tlen = ecc_bytes;\n\n\t\t\tif (pos >= writesize)\n\t\t\t\tpos += oob_skip;\n\t\t\telse if (pos + len > writesize)\n\t\t\t\tlen = writesize - pos;\n\n\t\t\tmemcpy(tmp_buf + pos, oob, len);\n\t\t\toob += len;\n\t\t\tif (len < ecc_bytes) {\n\t\t\t\tlen = ecc_bytes - len;\n\t\t\t\tmemcpy(tmp_buf + writesize + oob_skip, oob,\n\t\t\t\t       len);\n\t\t\t\toob += len;\n\t\t\t}\n\t\t}\n\t}\n\n\tcadence_nand_prepare_data_size(chip, TT_RAW_PAGE);\n\n\treturn cadence_nand_cdma_transfer(cdns_ctrl,\n\t\t\t\t\t  cdns_chip->cs[chip->cur_cs],\n\t\t\t\t\t  page, cdns_ctrl->buf, NULL,\n\t\t\t\t\t  mtd->writesize +\n\t\t\t\t\t  mtd->oobsize,\n\t\t\t\t\t  0, DMA_TO_DEVICE, false);\n}\n\nstatic int cadence_nand_write_oob_raw(struct nand_chip *chip,\n\t\t\t\t      int page)\n{\n\treturn cadence_nand_write_page_raw(chip, NULL, true, page);\n}\n\nstatic int cadence_nand_read_page(struct nand_chip *chip,\n\t\t\t\t  u8 *buf, int oob_required, int page)\n{\n\tstruct cdns_nand_ctrl *cdns_ctrl = to_cdns_nand_ctrl(chip->controller);\n\tstruct cdns_nand_chip *cdns_chip = to_cdns_nand_chip(chip);\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tint status = 0;\n\tint ecc_err_count = 0;\n\n\tstatus = cadence_nand_select_target(chip);\n\tif (status)\n\t\treturn status;\n\n\tcadence_nand_set_skip_bytes_conf(cdns_ctrl, cdns_chip->bbm_len,\n\t\t\t\t\t mtd->writesize\n\t\t\t\t\t + cdns_chip->bbm_offs, 1);\n\n\t \n\tif (cadence_nand_dma_buf_ok(cdns_ctrl, buf, mtd->writesize) &&\n\t    cdns_ctrl->caps2.data_control_supp) {\n\t\tu8 *oob;\n\n\t\tif (oob_required)\n\t\t\toob = chip->oob_poi;\n\t\telse\n\t\t\toob = cdns_ctrl->buf + mtd->writesize;\n\n\t\tcadence_nand_prepare_data_size(chip, TT_MAIN_OOB_AREA_EXT);\n\t\tstatus = cadence_nand_cdma_transfer(cdns_ctrl,\n\t\t\t\t\t\t    cdns_chip->cs[chip->cur_cs],\n\t\t\t\t\t\t    page, buf, oob,\n\t\t\t\t\t\t    mtd->writesize,\n\t\t\t\t\t\t    cdns_chip->avail_oob_size,\n\t\t\t\t\t\t    DMA_FROM_DEVICE, true);\n\t \n\t} else {\n\t\tcadence_nand_prepare_data_size(chip, TT_MAIN_OOB_AREAS);\n\t\tstatus = cadence_nand_cdma_transfer(cdns_ctrl,\n\t\t\t\t\t\t    cdns_chip->cs[chip->cur_cs],\n\t\t\t\t\t\t    page, cdns_ctrl->buf,\n\t\t\t\t\t\t    NULL, mtd->writesize\n\t\t\t\t\t\t    + cdns_chip->avail_oob_size,\n\t\t\t\t\t\t    0, DMA_FROM_DEVICE, true);\n\n\t\tmemcpy(buf, cdns_ctrl->buf, mtd->writesize);\n\t\tif (oob_required)\n\t\t\tmemcpy(chip->oob_poi,\n\t\t\t       cdns_ctrl->buf + mtd->writesize,\n\t\t\t       mtd->oobsize);\n\t}\n\n\tswitch (status) {\n\tcase STAT_ECC_UNCORR:\n\t\tmtd->ecc_stats.failed++;\n\t\tecc_err_count++;\n\t\tbreak;\n\tcase STAT_ECC_CORR:\n\t\tecc_err_count = FIELD_GET(CDMA_CS_MAXERR,\n\t\t\t\t\t  cdns_ctrl->cdma_desc->status);\n\t\tmtd->ecc_stats.corrected += ecc_err_count;\n\t\tbreak;\n\tcase STAT_ERASED:\n\tcase STAT_OK:\n\t\tbreak;\n\tdefault:\n\t\tdev_err(cdns_ctrl->dev, \"read page failed\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (oob_required)\n\t\tif (cadence_nand_read_bbm(chip, page, chip->oob_poi))\n\t\t\treturn -EIO;\n\n\treturn ecc_err_count;\n}\n\n \nstatic int cadence_nand_read_oob(struct nand_chip *chip, int page)\n{\n\tstruct cdns_nand_ctrl *cdns_ctrl = to_cdns_nand_ctrl(chip->controller);\n\n\treturn cadence_nand_read_page(chip, cdns_ctrl->buf, 1, page);\n}\n\nstatic int cadence_nand_read_page_raw(struct nand_chip *chip,\n\t\t\t\t      u8 *buf, int oob_required, int page)\n{\n\tstruct cdns_nand_ctrl *cdns_ctrl = to_cdns_nand_ctrl(chip->controller);\n\tstruct cdns_nand_chip *cdns_chip = to_cdns_nand_chip(chip);\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tint oob_skip = cdns_chip->bbm_len;\n\tint writesize = mtd->writesize;\n\tint ecc_steps = chip->ecc.steps;\n\tint ecc_size = chip->ecc.size;\n\tint ecc_bytes = chip->ecc.bytes;\n\tvoid *tmp_buf = cdns_ctrl->buf;\n\tint i, pos, len;\n\tint status = 0;\n\n\tstatus = cadence_nand_select_target(chip);\n\tif (status)\n\t\treturn status;\n\n\tcadence_nand_set_skip_bytes_conf(cdns_ctrl, 0, 0, 0);\n\n\tcadence_nand_prepare_data_size(chip, TT_RAW_PAGE);\n\tstatus = cadence_nand_cdma_transfer(cdns_ctrl,\n\t\t\t\t\t    cdns_chip->cs[chip->cur_cs],\n\t\t\t\t\t    page, cdns_ctrl->buf, NULL,\n\t\t\t\t\t    mtd->writesize\n\t\t\t\t\t    + mtd->oobsize,\n\t\t\t\t\t    0, DMA_FROM_DEVICE, false);\n\n\tswitch (status) {\n\tcase STAT_ERASED:\n\tcase STAT_OK:\n\t\tbreak;\n\tdefault:\n\t\tdev_err(cdns_ctrl->dev, \"read raw page failed\\n\");\n\t\treturn -EIO;\n\t}\n\n\t \n\tif (buf) {\n\t\tfor (i = 0; i < ecc_steps; i++) {\n\t\t\tpos = i * (ecc_size + ecc_bytes);\n\t\t\tlen = ecc_size;\n\n\t\t\tif (pos >= writesize)\n\t\t\t\tpos += oob_skip;\n\t\t\telse if (pos + len > writesize)\n\t\t\t\tlen = writesize - pos;\n\n\t\t\tmemcpy(buf, tmp_buf + pos, len);\n\t\t\tbuf += len;\n\t\t\tif (len < ecc_size) {\n\t\t\t\tlen = ecc_size - len;\n\t\t\t\tmemcpy(buf, tmp_buf + writesize + oob_skip,\n\t\t\t\t       len);\n\t\t\t\tbuf += len;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (oob_required) {\n\t\tu8 *oob = chip->oob_poi;\n\t\tu32 oob_data_offset = (cdns_chip->sector_count - 1) *\n\t\t\t(cdns_chip->sector_size + chip->ecc.bytes)\n\t\t\t+ cdns_chip->sector_size + oob_skip;\n\n\t\t \n\t\tmemcpy(oob, tmp_buf + oob_data_offset,\n\t\t       cdns_chip->avail_oob_size);\n\n\t\t \n\t\tmemcpy(oob, tmp_buf + writesize, oob_skip);\n\n\t\toob += cdns_chip->avail_oob_size;\n\n\t\t \n\t\tfor (i = 0; i < ecc_steps; i++) {\n\t\t\tpos = ecc_size + i * (ecc_size + ecc_bytes);\n\t\t\tlen = ecc_bytes;\n\n\t\t\tif (i == (ecc_steps - 1))\n\t\t\t\tpos += cdns_chip->avail_oob_size;\n\n\t\t\tif (pos >= writesize)\n\t\t\t\tpos += oob_skip;\n\t\t\telse if (pos + len > writesize)\n\t\t\t\tlen = writesize - pos;\n\n\t\t\tmemcpy(oob, tmp_buf + pos, len);\n\t\t\toob += len;\n\t\t\tif (len < ecc_bytes) {\n\t\t\t\tlen = ecc_bytes - len;\n\t\t\t\tmemcpy(oob, tmp_buf + writesize + oob_skip,\n\t\t\t\t       len);\n\t\t\t\toob += len;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int cadence_nand_read_oob_raw(struct nand_chip *chip,\n\t\t\t\t     int page)\n{\n\treturn cadence_nand_read_page_raw(chip, NULL, true, page);\n}\n\nstatic void cadence_nand_slave_dma_transfer_finished(void *data)\n{\n\tstruct completion *finished = data;\n\n\tcomplete(finished);\n}\n\nstatic int cadence_nand_slave_dma_transfer(struct cdns_nand_ctrl *cdns_ctrl,\n\t\t\t\t\t   void *buf,\n\t\t\t\t\t   dma_addr_t dev_dma, size_t len,\n\t\t\t\t\t   enum dma_data_direction dir)\n{\n\tDECLARE_COMPLETION_ONSTACK(finished);\n\tstruct dma_chan *chan;\n\tstruct dma_device *dma_dev;\n\tdma_addr_t src_dma, dst_dma, buf_dma;\n\tstruct dma_async_tx_descriptor *tx;\n\tdma_cookie_t cookie;\n\n\tchan = cdns_ctrl->dmac;\n\tdma_dev = chan->device;\n\n\tbuf_dma = dma_map_single(dma_dev->dev, buf, len, dir);\n\tif (dma_mapping_error(dma_dev->dev, buf_dma)) {\n\t\tdev_err(cdns_ctrl->dev, \"Failed to map DMA buffer\\n\");\n\t\tgoto err;\n\t}\n\n\tif (dir == DMA_FROM_DEVICE) {\n\t\tsrc_dma = cdns_ctrl->io.dma;\n\t\tdst_dma = buf_dma;\n\t} else {\n\t\tsrc_dma = buf_dma;\n\t\tdst_dma = cdns_ctrl->io.dma;\n\t}\n\n\ttx = dmaengine_prep_dma_memcpy(cdns_ctrl->dmac, dst_dma, src_dma, len,\n\t\t\t\t       DMA_CTRL_ACK | DMA_PREP_INTERRUPT);\n\tif (!tx) {\n\t\tdev_err(cdns_ctrl->dev, \"Failed to prepare DMA memcpy\\n\");\n\t\tgoto err_unmap;\n\t}\n\n\ttx->callback = cadence_nand_slave_dma_transfer_finished;\n\ttx->callback_param = &finished;\n\n\tcookie = dmaengine_submit(tx);\n\tif (dma_submit_error(cookie)) {\n\t\tdev_err(cdns_ctrl->dev, \"Failed to do DMA tx_submit\\n\");\n\t\tgoto err_unmap;\n\t}\n\n\tdma_async_issue_pending(cdns_ctrl->dmac);\n\twait_for_completion(&finished);\n\n\tdma_unmap_single(cdns_ctrl->dev, buf_dma, len, dir);\n\n\treturn 0;\n\nerr_unmap:\n\tdma_unmap_single(cdns_ctrl->dev, buf_dma, len, dir);\n\nerr:\n\tdev_dbg(cdns_ctrl->dev, \"Fall back to CPU I/O\\n\");\n\n\treturn -EIO;\n}\n\nstatic int cadence_nand_read_buf(struct cdns_nand_ctrl *cdns_ctrl,\n\t\t\t\t u8 *buf, int len)\n{\n\tu8 thread_nr = 0;\n\tu32 sdma_size;\n\tint status;\n\n\t \n\tstatus = cadence_nand_wait_on_sdma(cdns_ctrl, &thread_nr, &sdma_size);\n\tif (status)\n\t\treturn status;\n\n\tif (!cdns_ctrl->caps1->has_dma) {\n\t\tu8 data_dma_width = cdns_ctrl->caps2.data_dma_width;\n\n\t\tint len_in_words = (data_dma_width == 4) ? len >> 2 : len >> 3;\n\n\t\t \n\t\tif (data_dma_width == 4)\n\t\t\tioread32_rep(cdns_ctrl->io.virt, buf, len_in_words);\n#ifdef CONFIG_64BIT\n\t\telse\n\t\t\treadsq(cdns_ctrl->io.virt, buf, len_in_words);\n#endif\n\n\t\tif (sdma_size > len) {\n\t\t\tint read_bytes = (data_dma_width == 4) ?\n\t\t\t\tlen_in_words << 2 : len_in_words << 3;\n\n\t\t\t \n\t\t\tif (data_dma_width == 4)\n\t\t\t\tioread32_rep(cdns_ctrl->io.virt,\n\t\t\t\t\t     cdns_ctrl->buf,\n\t\t\t\t\t     sdma_size / 4 - len_in_words);\n#ifdef CONFIG_64BIT\n\t\t\telse\n\t\t\t\treadsq(cdns_ctrl->io.virt, cdns_ctrl->buf,\n\t\t\t\t       sdma_size / 8 - len_in_words);\n#endif\n\n\t\t\t \n\t\t\tmemcpy(buf + read_bytes, cdns_ctrl->buf,\n\t\t\t       len - read_bytes);\n\t\t}\n\t\treturn 0;\n\t}\n\n\tif (cadence_nand_dma_buf_ok(cdns_ctrl, buf, len)) {\n\t\tstatus = cadence_nand_slave_dma_transfer(cdns_ctrl, buf,\n\t\t\t\t\t\t\t cdns_ctrl->io.dma,\n\t\t\t\t\t\t\t len, DMA_FROM_DEVICE);\n\t\tif (status == 0)\n\t\t\treturn 0;\n\n\t\tdev_warn(cdns_ctrl->dev,\n\t\t\t \"Slave DMA transfer failed. Try again using bounce buffer.\");\n\t}\n\n\t \n\tstatus = cadence_nand_slave_dma_transfer(cdns_ctrl, cdns_ctrl->buf,\n\t\t\t\t\t\t cdns_ctrl->io.dma,\n\t\t\t\t\t\t sdma_size, DMA_FROM_DEVICE);\n\n\tif (status) {\n\t\tdev_err(cdns_ctrl->dev, \"Slave DMA transfer failed\");\n\t\treturn status;\n\t}\n\n\tmemcpy(buf, cdns_ctrl->buf, len);\n\n\treturn 0;\n}\n\nstatic int cadence_nand_write_buf(struct cdns_nand_ctrl *cdns_ctrl,\n\t\t\t\t  const u8 *buf, int len)\n{\n\tu8 thread_nr = 0;\n\tu32 sdma_size;\n\tint status;\n\n\t \n\tstatus = cadence_nand_wait_on_sdma(cdns_ctrl, &thread_nr, &sdma_size);\n\tif (status)\n\t\treturn status;\n\n\tif (!cdns_ctrl->caps1->has_dma) {\n\t\tu8 data_dma_width = cdns_ctrl->caps2.data_dma_width;\n\n\t\tint len_in_words = (data_dma_width == 4) ? len >> 2 : len >> 3;\n\n\t\tif (data_dma_width == 4)\n\t\t\tiowrite32_rep(cdns_ctrl->io.virt, buf, len_in_words);\n#ifdef CONFIG_64BIT\n\t\telse\n\t\t\twritesq(cdns_ctrl->io.virt, buf, len_in_words);\n#endif\n\n\t\tif (sdma_size > len) {\n\t\t\tint written_bytes = (data_dma_width == 4) ?\n\t\t\t\tlen_in_words << 2 : len_in_words << 3;\n\n\t\t\t \n\t\t\tmemcpy(cdns_ctrl->buf, buf + written_bytes,\n\t\t\t       len - written_bytes);\n\n\t\t\t \n\t\t\tif (data_dma_width == 4)\n\t\t\t\tiowrite32_rep(cdns_ctrl->io.virt,\n\t\t\t\t\t      cdns_ctrl->buf,\n\t\t\t\t\t      sdma_size / 4 - len_in_words);\n#ifdef CONFIG_64BIT\n\t\t\telse\n\t\t\t\twritesq(cdns_ctrl->io.virt, cdns_ctrl->buf,\n\t\t\t\t\tsdma_size / 8 - len_in_words);\n#endif\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tif (cadence_nand_dma_buf_ok(cdns_ctrl, buf, len)) {\n\t\tstatus = cadence_nand_slave_dma_transfer(cdns_ctrl, (void *)buf,\n\t\t\t\t\t\t\t cdns_ctrl->io.dma,\n\t\t\t\t\t\t\t len, DMA_TO_DEVICE);\n\t\tif (status == 0)\n\t\t\treturn 0;\n\n\t\tdev_warn(cdns_ctrl->dev,\n\t\t\t \"Slave DMA transfer failed. Try again using bounce buffer.\");\n\t}\n\n\t \n\tmemcpy(cdns_ctrl->buf, buf, len);\n\n\tstatus = cadence_nand_slave_dma_transfer(cdns_ctrl, cdns_ctrl->buf,\n\t\t\t\t\t\t cdns_ctrl->io.dma,\n\t\t\t\t\t\t sdma_size, DMA_TO_DEVICE);\n\n\tif (status)\n\t\tdev_err(cdns_ctrl->dev, \"Slave DMA transfer failed\");\n\n\treturn status;\n}\n\nstatic int cadence_nand_force_byte_access(struct nand_chip *chip,\n\t\t\t\t\t  bool force_8bit)\n{\n\tstruct cdns_nand_ctrl *cdns_ctrl = to_cdns_nand_ctrl(chip->controller);\n\n\t \n\tif (!(chip->options & NAND_BUSWIDTH_16))\n\t\treturn 0;\n\n\treturn cadence_nand_set_access_width16(cdns_ctrl, !force_8bit);\n}\n\nstatic int cadence_nand_cmd_opcode(struct nand_chip *chip,\n\t\t\t\t   const struct nand_subop *subop)\n{\n\tstruct cdns_nand_ctrl *cdns_ctrl = to_cdns_nand_ctrl(chip->controller);\n\tstruct cdns_nand_chip *cdns_chip = to_cdns_nand_chip(chip);\n\tconst struct nand_op_instr *instr;\n\tunsigned int op_id = 0;\n\tu64 mini_ctrl_cmd = 0;\n\tint ret;\n\n\tinstr = &subop->instrs[op_id];\n\n\tif (instr->delay_ns > 0)\n\t\tmini_ctrl_cmd |= GCMD_LAY_TWB;\n\n\tmini_ctrl_cmd |= FIELD_PREP(GCMD_LAY_INSTR,\n\t\t\t\t    GCMD_LAY_INSTR_CMD);\n\tmini_ctrl_cmd |= FIELD_PREP(GCMD_LAY_INPUT_CMD,\n\t\t\t\t    instr->ctx.cmd.opcode);\n\n\tret = cadence_nand_generic_cmd_send(cdns_ctrl,\n\t\t\t\t\t    cdns_chip->cs[chip->cur_cs],\n\t\t\t\t\t    mini_ctrl_cmd);\n\tif (ret)\n\t\tdev_err(cdns_ctrl->dev, \"send cmd %x failed\\n\",\n\t\t\tinstr->ctx.cmd.opcode);\n\n\treturn ret;\n}\n\nstatic int cadence_nand_cmd_address(struct nand_chip *chip,\n\t\t\t\t    const struct nand_subop *subop)\n{\n\tstruct cdns_nand_ctrl *cdns_ctrl = to_cdns_nand_ctrl(chip->controller);\n\tstruct cdns_nand_chip *cdns_chip = to_cdns_nand_chip(chip);\n\tconst struct nand_op_instr *instr;\n\tunsigned int op_id = 0;\n\tu64 mini_ctrl_cmd = 0;\n\tunsigned int offset, naddrs;\n\tu64 address = 0;\n\tconst u8 *addrs;\n\tint ret;\n\tint i;\n\n\tinstr = &subop->instrs[op_id];\n\n\tif (instr->delay_ns > 0)\n\t\tmini_ctrl_cmd |= GCMD_LAY_TWB;\n\n\tmini_ctrl_cmd |= FIELD_PREP(GCMD_LAY_INSTR,\n\t\t\t\t    GCMD_LAY_INSTR_ADDR);\n\n\toffset = nand_subop_get_addr_start_off(subop, op_id);\n\tnaddrs = nand_subop_get_num_addr_cyc(subop, op_id);\n\taddrs = &instr->ctx.addr.addrs[offset];\n\n\tfor (i = 0; i < naddrs; i++)\n\t\taddress |= (u64)addrs[i] << (8 * i);\n\n\tmini_ctrl_cmd |= FIELD_PREP(GCMD_LAY_INPUT_ADDR,\n\t\t\t\t    address);\n\tmini_ctrl_cmd |= FIELD_PREP(GCMD_LAY_INPUT_ADDR_SIZE,\n\t\t\t\t    naddrs - 1);\n\n\tret = cadence_nand_generic_cmd_send(cdns_ctrl,\n\t\t\t\t\t    cdns_chip->cs[chip->cur_cs],\n\t\t\t\t\t    mini_ctrl_cmd);\n\tif (ret)\n\t\tdev_err(cdns_ctrl->dev, \"send address %llx failed\\n\", address);\n\n\treturn ret;\n}\n\nstatic int cadence_nand_cmd_erase(struct nand_chip *chip,\n\t\t\t\t  const struct nand_subop *subop)\n{\n\tunsigned int op_id;\n\n\tif (subop->instrs[0].ctx.cmd.opcode == NAND_CMD_ERASE1) {\n\t\tint i;\n\t\tconst struct nand_op_instr *instr = NULL;\n\t\tunsigned int offset, naddrs;\n\t\tconst u8 *addrs;\n\t\tu32 page = 0;\n\n\t\tinstr = &subop->instrs[1];\n\t\toffset = nand_subop_get_addr_start_off(subop, 1);\n\t\tnaddrs = nand_subop_get_num_addr_cyc(subop, 1);\n\t\taddrs = &instr->ctx.addr.addrs[offset];\n\n\t\tfor (i = 0; i < naddrs; i++)\n\t\t\tpage |= (u32)addrs[i] << (8 * i);\n\n\t\treturn cadence_nand_erase(chip, page);\n\t}\n\n\t \n\tfor (op_id = 0; op_id < subop->ninstrs; op_id++) {\n\t\tint ret;\n\t\tconst struct nand_operation nand_op = {\n\t\t\t.cs = chip->cur_cs,\n\t\t\t.instrs =  &subop->instrs[op_id],\n\t\t\t.ninstrs = 1};\n\t\tret = chip->controller->ops->exec_op(chip, &nand_op, false);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int cadence_nand_cmd_data(struct nand_chip *chip,\n\t\t\t\t const struct nand_subop *subop)\n{\n\tstruct cdns_nand_ctrl *cdns_ctrl = to_cdns_nand_ctrl(chip->controller);\n\tstruct cdns_nand_chip *cdns_chip = to_cdns_nand_chip(chip);\n\tconst struct nand_op_instr *instr;\n\tunsigned int offset, op_id = 0;\n\tu64 mini_ctrl_cmd = 0;\n\tint len = 0;\n\tint ret;\n\n\tinstr = &subop->instrs[op_id];\n\n\tif (instr->delay_ns > 0)\n\t\tmini_ctrl_cmd |= GCMD_LAY_TWB;\n\n\tmini_ctrl_cmd |= FIELD_PREP(GCMD_LAY_INSTR,\n\t\t\t\t    GCMD_LAY_INSTR_DATA);\n\n\tif (instr->type == NAND_OP_DATA_OUT_INSTR)\n\t\tmini_ctrl_cmd |= FIELD_PREP(GCMD_DIR,\n\t\t\t\t\t    GCMD_DIR_WRITE);\n\n\tlen = nand_subop_get_data_len(subop, op_id);\n\toffset = nand_subop_get_data_start_off(subop, op_id);\n\tmini_ctrl_cmd |= FIELD_PREP(GCMD_SECT_CNT, 1);\n\tmini_ctrl_cmd |= FIELD_PREP(GCMD_LAST_SIZE, len);\n\tif (instr->ctx.data.force_8bit) {\n\t\tret = cadence_nand_force_byte_access(chip, true);\n\t\tif (ret) {\n\t\t\tdev_err(cdns_ctrl->dev,\n\t\t\t\t\"cannot change byte access generic data cmd failed\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tret = cadence_nand_generic_cmd_send(cdns_ctrl,\n\t\t\t\t\t    cdns_chip->cs[chip->cur_cs],\n\t\t\t\t\t    mini_ctrl_cmd);\n\tif (ret) {\n\t\tdev_err(cdns_ctrl->dev, \"send generic data cmd failed\\n\");\n\t\treturn ret;\n\t}\n\n\tif (instr->type == NAND_OP_DATA_IN_INSTR) {\n\t\tvoid *buf = instr->ctx.data.buf.in + offset;\n\n\t\tret = cadence_nand_read_buf(cdns_ctrl, buf, len);\n\t} else {\n\t\tconst void *buf = instr->ctx.data.buf.out + offset;\n\n\t\tret = cadence_nand_write_buf(cdns_ctrl, buf, len);\n\t}\n\n\tif (ret) {\n\t\tdev_err(cdns_ctrl->dev, \"data transfer failed for generic command\\n\");\n\t\treturn ret;\n\t}\n\n\tif (instr->ctx.data.force_8bit) {\n\t\tret = cadence_nand_force_byte_access(chip, false);\n\t\tif (ret) {\n\t\t\tdev_err(cdns_ctrl->dev,\n\t\t\t\t\"cannot change byte access generic data cmd failed\\n\");\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic int cadence_nand_cmd_waitrdy(struct nand_chip *chip,\n\t\t\t\t    const struct nand_subop *subop)\n{\n\tint status;\n\tunsigned int op_id = 0;\n\tstruct cdns_nand_ctrl *cdns_ctrl = to_cdns_nand_ctrl(chip->controller);\n\tstruct cdns_nand_chip *cdns_chip = to_cdns_nand_chip(chip);\n\tconst struct nand_op_instr *instr = &subop->instrs[op_id];\n\tu32 timeout_us = instr->ctx.waitrdy.timeout_ms * 1000;\n\n\tstatus = cadence_nand_wait_for_value(cdns_ctrl, RBN_SETINGS,\n\t\t\t\t\t     timeout_us,\n\t\t\t\t\t     BIT(cdns_chip->cs[chip->cur_cs]),\n\t\t\t\t\t     false);\n\treturn status;\n}\n\nstatic const struct nand_op_parser cadence_nand_op_parser = NAND_OP_PARSER(\n\tNAND_OP_PARSER_PATTERN(\n\t\tcadence_nand_cmd_erase,\n\t\tNAND_OP_PARSER_PAT_CMD_ELEM(false),\n\t\tNAND_OP_PARSER_PAT_ADDR_ELEM(false, MAX_ERASE_ADDRESS_CYC),\n\t\tNAND_OP_PARSER_PAT_CMD_ELEM(false),\n\t\tNAND_OP_PARSER_PAT_WAITRDY_ELEM(false)),\n\tNAND_OP_PARSER_PATTERN(\n\t\tcadence_nand_cmd_opcode,\n\t\tNAND_OP_PARSER_PAT_CMD_ELEM(false)),\n\tNAND_OP_PARSER_PATTERN(\n\t\tcadence_nand_cmd_address,\n\t\tNAND_OP_PARSER_PAT_ADDR_ELEM(false, MAX_ADDRESS_CYC)),\n\tNAND_OP_PARSER_PATTERN(\n\t\tcadence_nand_cmd_data,\n\t\tNAND_OP_PARSER_PAT_DATA_IN_ELEM(false, MAX_DATA_SIZE)),\n\tNAND_OP_PARSER_PATTERN(\n\t\tcadence_nand_cmd_data,\n\t\tNAND_OP_PARSER_PAT_DATA_OUT_ELEM(false, MAX_DATA_SIZE)),\n\tNAND_OP_PARSER_PATTERN(\n\t\tcadence_nand_cmd_waitrdy,\n\t\tNAND_OP_PARSER_PAT_WAITRDY_ELEM(false))\n\t);\n\nstatic int cadence_nand_exec_op(struct nand_chip *chip,\n\t\t\t\tconst struct nand_operation *op,\n\t\t\t\tbool check_only)\n{\n\tif (!check_only) {\n\t\tint status = cadence_nand_select_target(chip);\n\n\t\tif (status)\n\t\t\treturn status;\n\t}\n\n\treturn nand_op_parser_exec_op(chip, &cadence_nand_op_parser, op,\n\t\t\t\t      check_only);\n}\n\nstatic int cadence_nand_ooblayout_free(struct mtd_info *mtd, int section,\n\t\t\t\t       struct mtd_oob_region *oobregion)\n{\n\tstruct nand_chip *chip = mtd_to_nand(mtd);\n\tstruct cdns_nand_chip *cdns_chip = to_cdns_nand_chip(chip);\n\n\tif (section)\n\t\treturn -ERANGE;\n\n\toobregion->offset = cdns_chip->bbm_len;\n\toobregion->length = cdns_chip->avail_oob_size\n\t\t- cdns_chip->bbm_len;\n\n\treturn 0;\n}\n\nstatic int cadence_nand_ooblayout_ecc(struct mtd_info *mtd, int section,\n\t\t\t\t      struct mtd_oob_region *oobregion)\n{\n\tstruct nand_chip *chip = mtd_to_nand(mtd);\n\tstruct cdns_nand_chip *cdns_chip = to_cdns_nand_chip(chip);\n\n\tif (section)\n\t\treturn -ERANGE;\n\n\toobregion->offset = cdns_chip->avail_oob_size;\n\toobregion->length = chip->ecc.total;\n\n\treturn 0;\n}\n\nstatic const struct mtd_ooblayout_ops cadence_nand_ooblayout_ops = {\n\t.free = cadence_nand_ooblayout_free,\n\t.ecc = cadence_nand_ooblayout_ecc,\n};\n\nstatic int calc_cycl(u32 timing, u32 clock)\n{\n\tif (timing == 0 || clock == 0)\n\t\treturn 0;\n\n\tif ((timing % clock) > 0)\n\t\treturn timing / clock;\n\telse\n\t\treturn timing / clock - 1;\n}\n\n \nstatic inline u32 calc_tdvw_max(u32 trp_cnt, u32 clk_period, u32 trhoh_min,\n\t\t\t\tu32 board_delay_skew_min, u32 ext_mode)\n{\n\tif (ext_mode == 0)\n\t\tclk_period /= 2;\n\n\treturn (trp_cnt + 1) * clk_period + trhoh_min +\n\t\tboard_delay_skew_min;\n}\n\n \nstatic inline u32 calc_tdvw(u32 trp_cnt, u32 clk_period, u32 trhoh_min,\n\t\t\t    u32 trea_max, u32 ext_mode)\n{\n\tif (ext_mode == 0)\n\t\tclk_period /= 2;\n\n\treturn (trp_cnt + 1) * clk_period + trhoh_min - trea_max;\n}\n\nstatic int\ncadence_nand_setup_interface(struct nand_chip *chip, int chipnr,\n\t\t\t     const struct nand_interface_config *conf)\n{\n\tconst struct nand_sdr_timings *sdr;\n\tstruct cdns_nand_ctrl *cdns_ctrl = to_cdns_nand_ctrl(chip->controller);\n\tstruct cdns_nand_chip *cdns_chip = to_cdns_nand_chip(chip);\n\tstruct cadence_nand_timings *t = &cdns_chip->timings;\n\tu32 reg;\n\tu32 board_delay = cdns_ctrl->board_delay;\n\tu32 clk_period = DIV_ROUND_DOWN_ULL(1000000000000ULL,\n\t\t\t\t\t    cdns_ctrl->nf_clk_rate);\n\tu32 tceh_cnt, tcs_cnt, tadl_cnt, tccs_cnt;\n\tu32 tfeat_cnt, trhz_cnt, tvdly_cnt;\n\tu32 trhw_cnt, twb_cnt, twh_cnt = 0, twhr_cnt;\n\tu32 twp_cnt = 0, trp_cnt = 0, trh_cnt = 0;\n\tu32 if_skew = cdns_ctrl->caps1->if_skew;\n\tu32 board_delay_skew_min = board_delay - if_skew;\n\tu32 board_delay_skew_max = board_delay + if_skew;\n\tu32 dqs_sampl_res, phony_dqs_mod;\n\tu32 tdvw, tdvw_min, tdvw_max;\n\tu32 ext_rd_mode, ext_wr_mode;\n\tu32 dll_phy_dqs_timing = 0, phony_dqs_timing = 0, rd_del_sel = 0;\n\tu32 sampling_point;\n\n\tsdr = nand_get_sdr_timings(conf);\n\tif (IS_ERR(sdr))\n\t\treturn PTR_ERR(sdr);\n\n\tmemset(t, 0, sizeof(*t));\n\t \n\n\tif (cdns_ctrl->caps2.is_phy_type_dll)\n\t\tphony_dqs_mod = 2;\n\telse\n\t\tphony_dqs_mod = 1;\n\n\tdqs_sampl_res = clk_period / phony_dqs_mod;\n\n\ttdvw_min = sdr->tREA_max + board_delay_skew_max;\n\t \n\tif (sdr->tRC_min <= clk_period &&\n\t    sdr->tRP_min <= (clk_period / 2) &&\n\t    sdr->tREH_min <= (clk_period / 2)) {\n\t\t \n\t\text_rd_mode = 0;\n\t\ttdvw = calc_tdvw(trp_cnt, clk_period, sdr->tRHOH_min,\n\t\t\t\t sdr->tREA_max, ext_rd_mode);\n\t\ttdvw_max = calc_tdvw_max(trp_cnt, clk_period, sdr->tRHOH_min,\n\t\t\t\t\t board_delay_skew_min,\n\t\t\t\t\t ext_rd_mode);\n\t\t \n\t\tif (tdvw > 0) {\n\t\t\tif (tdvw_max <= tdvw_min ||\n\t\t\t    (tdvw_max % dqs_sampl_res) == 0) {\n\t\t\t\t \n\t\t\t\text_rd_mode = 1;\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\ttrp_cnt = (sdr->tREA_max + board_delay_skew_max\n\t\t\t\t   + dqs_sampl_res) / clk_period;\n\t\t\text_rd_mode = 1;\n\t\t}\n\n\t} else {\n\t\t \n\t\tu32 trh;\n\n\t\text_rd_mode = 1;\n\t\ttrp_cnt = calc_cycl(sdr->tRP_min, clk_period);\n\t\ttrh = sdr->tRC_min - ((trp_cnt + 1) * clk_period);\n\t\tif (sdr->tREH_min >= trh)\n\t\t\ttrh_cnt = calc_cycl(sdr->tREH_min, clk_period);\n\t\telse\n\t\t\ttrh_cnt = calc_cycl(trh, clk_period);\n\n\t\ttdvw = calc_tdvw(trp_cnt, clk_period, sdr->tRHOH_min,\n\t\t\t\t sdr->tREA_max, ext_rd_mode);\n\t\t \n\t\tif (tdvw > 0) {\n\t\t\ttdvw_max = calc_tdvw_max(trp_cnt, clk_period,\n\t\t\t\t\t\t sdr->tRHOH_min,\n\t\t\t\t\t\t board_delay_skew_min,\n\t\t\t\t\t\t ext_rd_mode);\n\n\t\t\tif ((((tdvw_max / dqs_sampl_res)\n\t\t\t      * dqs_sampl_res) <= tdvw_min) ||\n\t\t\t    (((tdvw_max % dqs_sampl_res) == 0) &&\n\t\t\t     (((tdvw_max / dqs_sampl_res - 1)\n\t\t\t       * dqs_sampl_res) <= tdvw_min))) {\n\t\t\t\t \n\t\t\t\ttrp_cnt = trp_cnt + 1;\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\ttrp_cnt = (sdr->tREA_max + board_delay_skew_max\n\t\t\t\t   + dqs_sampl_res) / clk_period;\n\t\t}\n\t}\n\n\ttdvw_max = calc_tdvw_max(trp_cnt, clk_period,\n\t\t\t\t sdr->tRHOH_min,\n\t\t\t\t board_delay_skew_min, ext_rd_mode);\n\n\tif (sdr->tWC_min <= clk_period &&\n\t    (sdr->tWP_min + if_skew) <= (clk_period / 2) &&\n\t    (sdr->tWH_min + if_skew) <= (clk_period / 2)) {\n\t\text_wr_mode = 0;\n\t} else {\n\t\tu32 twh;\n\n\t\text_wr_mode = 1;\n\t\ttwp_cnt = calc_cycl(sdr->tWP_min + if_skew, clk_period);\n\t\tif ((twp_cnt + 1) * clk_period < (sdr->tALS_min + if_skew))\n\t\t\ttwp_cnt = calc_cycl(sdr->tALS_min + if_skew,\n\t\t\t\t\t    clk_period);\n\n\t\ttwh = (sdr->tWC_min - (twp_cnt + 1) * clk_period);\n\t\tif (sdr->tWH_min >= twh)\n\t\t\ttwh = sdr->tWH_min;\n\n\t\ttwh_cnt = calc_cycl(twh + if_skew, clk_period);\n\t}\n\n\treg = FIELD_PREP(ASYNC_TOGGLE_TIMINGS_TRH, trh_cnt);\n\treg |= FIELD_PREP(ASYNC_TOGGLE_TIMINGS_TRP, trp_cnt);\n\treg |= FIELD_PREP(ASYNC_TOGGLE_TIMINGS_TWH, twh_cnt);\n\treg |= FIELD_PREP(ASYNC_TOGGLE_TIMINGS_TWP, twp_cnt);\n\tt->async_toggle_timings = reg;\n\tdev_dbg(cdns_ctrl->dev, \"ASYNC_TOGGLE_TIMINGS_SDR\\t%x\\n\", reg);\n\n\ttadl_cnt = calc_cycl((sdr->tADL_min + if_skew), clk_period);\n\ttccs_cnt = calc_cycl((sdr->tCCS_min + if_skew), clk_period);\n\ttwhr_cnt = calc_cycl((sdr->tWHR_min + if_skew), clk_period);\n\ttrhw_cnt = calc_cycl((sdr->tRHW_min + if_skew), clk_period);\n\treg = FIELD_PREP(TIMINGS0_TADL, tadl_cnt);\n\n\t \n\tif (FIELD_FIT(TIMINGS0_TCCS, tccs_cnt))\n\t\treg |= FIELD_PREP(TIMINGS0_TCCS, tccs_cnt);\n\telse\n\t\treg |= TIMINGS0_TCCS;\n\n\treg |= FIELD_PREP(TIMINGS0_TWHR, twhr_cnt);\n\treg |= FIELD_PREP(TIMINGS0_TRHW, trhw_cnt);\n\tt->timings0 = reg;\n\tdev_dbg(cdns_ctrl->dev, \"TIMINGS0_SDR\\t%x\\n\", reg);\n\n\t \n\ttrhz_cnt = calc_cycl(sdr->tRHZ_max, clk_period);\n\ttrhz_cnt = trhz_cnt + 1;\n\ttwb_cnt = calc_cycl((sdr->tWB_max + board_delay), clk_period);\n\t \n\ttwb_cnt = twb_cnt + 3 + 5;\n\t \n\ttvdly_cnt = calc_cycl(500000 + if_skew, clk_period);\n\treg = FIELD_PREP(TIMINGS1_TRHZ, trhz_cnt);\n\treg |= FIELD_PREP(TIMINGS1_TWB, twb_cnt);\n\treg |= FIELD_PREP(TIMINGS1_TVDLY, tvdly_cnt);\n\tt->timings1 = reg;\n\tdev_dbg(cdns_ctrl->dev, \"TIMINGS1_SDR\\t%x\\n\", reg);\n\n\ttfeat_cnt = calc_cycl(sdr->tFEAT_max, clk_period);\n\tif (tfeat_cnt < twb_cnt)\n\t\ttfeat_cnt = twb_cnt;\n\n\ttceh_cnt = calc_cycl(sdr->tCEH_min, clk_period);\n\ttcs_cnt = calc_cycl((sdr->tCS_min + if_skew), clk_period);\n\n\treg = FIELD_PREP(TIMINGS2_TFEAT, tfeat_cnt);\n\treg |= FIELD_PREP(TIMINGS2_CS_HOLD_TIME, tceh_cnt);\n\treg |= FIELD_PREP(TIMINGS2_CS_SETUP_TIME, tcs_cnt);\n\tt->timings2 = reg;\n\tdev_dbg(cdns_ctrl->dev, \"TIMINGS2_SDR\\t%x\\n\", reg);\n\n\tif (cdns_ctrl->caps2.is_phy_type_dll) {\n\t\treg = DLL_PHY_CTRL_DLL_RST_N;\n\t\tif (ext_wr_mode)\n\t\t\treg |= DLL_PHY_CTRL_EXTENDED_WR_MODE;\n\t\tif (ext_rd_mode)\n\t\t\treg |= DLL_PHY_CTRL_EXTENDED_RD_MODE;\n\n\t\treg |= FIELD_PREP(DLL_PHY_CTRL_RS_HIGH_WAIT_CNT, 7);\n\t\treg |= FIELD_PREP(DLL_PHY_CTRL_RS_IDLE_CNT, 7);\n\t\tt->dll_phy_ctrl = reg;\n\t\tdev_dbg(cdns_ctrl->dev, \"DLL_PHY_CTRL_SDR\\t%x\\n\", reg);\n\t}\n\n\t \n\tif ((tdvw_max % dqs_sampl_res) > 0)\n\t\tsampling_point = tdvw_max / dqs_sampl_res;\n\telse\n\t\tsampling_point = (tdvw_max / dqs_sampl_res - 1);\n\n\tif (sampling_point * dqs_sampl_res > tdvw_min) {\n\t\tdll_phy_dqs_timing =\n\t\t\tFIELD_PREP(PHY_DQS_TIMING_DQS_SEL_OE_END, 4);\n\t\tdll_phy_dqs_timing |= PHY_DQS_TIMING_USE_PHONY_DQS;\n\t\tphony_dqs_timing = sampling_point / phony_dqs_mod;\n\n\t\tif ((sampling_point % 2) > 0) {\n\t\t\tdll_phy_dqs_timing |= PHY_DQS_TIMING_PHONY_DQS_SEL;\n\t\t\tif ((tdvw_max % dqs_sampl_res) == 0)\n\t\t\t\t \n\t\t\t\tphony_dqs_timing = (tdvw_max / dqs_sampl_res)\n\t\t\t\t\t/ phony_dqs_mod - 1;\n\n\t\t\tif (!cdns_ctrl->caps2.is_phy_type_dll)\n\t\t\t\tphony_dqs_timing--;\n\n\t\t} else {\n\t\t\tphony_dqs_timing--;\n\t\t}\n\t\trd_del_sel = phony_dqs_timing + 3;\n\t} else {\n\t\tdev_warn(cdns_ctrl->dev,\n\t\t\t \"ERROR : cannot find valid sampling point\\n\");\n\t}\n\n\treg = FIELD_PREP(PHY_CTRL_PHONY_DQS, phony_dqs_timing);\n\tif (cdns_ctrl->caps2.is_phy_type_dll)\n\t\treg  |= PHY_CTRL_SDR_DQS;\n\tt->phy_ctrl = reg;\n\tdev_dbg(cdns_ctrl->dev, \"PHY_CTRL_REG_SDR\\t%x\\n\", reg);\n\n\tif (cdns_ctrl->caps2.is_phy_type_dll) {\n\t\tdev_dbg(cdns_ctrl->dev, \"PHY_TSEL_REG_SDR\\t%x\\n\", 0);\n\t\tdev_dbg(cdns_ctrl->dev, \"PHY_DQ_TIMING_REG_SDR\\t%x\\n\", 2);\n\t\tdev_dbg(cdns_ctrl->dev, \"PHY_DQS_TIMING_REG_SDR\\t%x\\n\",\n\t\t\tdll_phy_dqs_timing);\n\t\tt->phy_dqs_timing = dll_phy_dqs_timing;\n\n\t\treg = FIELD_PREP(PHY_GATE_LPBK_CTRL_RDS, rd_del_sel);\n\t\tdev_dbg(cdns_ctrl->dev, \"PHY_GATE_LPBK_CTRL_REG_SDR\\t%x\\n\",\n\t\t\treg);\n\t\tt->phy_gate_lpbk_ctrl = reg;\n\n\t\tdev_dbg(cdns_ctrl->dev, \"PHY_DLL_MASTER_CTRL_REG_SDR\\t%lx\\n\",\n\t\t\tPHY_DLL_MASTER_CTRL_BYPASS_MODE);\n\t\tdev_dbg(cdns_ctrl->dev, \"PHY_DLL_SLAVE_CTRL_REG_SDR\\t%x\\n\", 0);\n\t}\n\n\treturn 0;\n}\n\nstatic int cadence_nand_attach_chip(struct nand_chip *chip)\n{\n\tstruct cdns_nand_ctrl *cdns_ctrl = to_cdns_nand_ctrl(chip->controller);\n\tstruct cdns_nand_chip *cdns_chip = to_cdns_nand_chip(chip);\n\tu32 ecc_size;\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tint ret;\n\n\tif (chip->options & NAND_BUSWIDTH_16) {\n\t\tret = cadence_nand_set_access_width16(cdns_ctrl, true);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tchip->bbt_options |= NAND_BBT_USE_FLASH;\n\tchip->bbt_options |= NAND_BBT_NO_OOB;\n\tchip->ecc.engine_type = NAND_ECC_ENGINE_TYPE_ON_HOST;\n\n\tchip->options |= NAND_NO_SUBPAGE_WRITE;\n\n\tcdns_chip->bbm_offs = chip->badblockpos;\n\tcdns_chip->bbm_offs &= ~0x01;\n\t \n\tcdns_chip->bbm_len = 2;\n\n\tret = nand_ecc_choose_conf(chip,\n\t\t\t\t   &cdns_ctrl->ecc_caps,\n\t\t\t\t   mtd->oobsize - cdns_chip->bbm_len);\n\tif (ret) {\n\t\tdev_err(cdns_ctrl->dev, \"ECC configuration failed\\n\");\n\t\treturn ret;\n\t}\n\n\tdev_dbg(cdns_ctrl->dev,\n\t\t\"chosen ECC settings: step=%d, strength=%d, bytes=%d\\n\",\n\t\tchip->ecc.size, chip->ecc.strength, chip->ecc.bytes);\n\n\t \n\tcdns_chip->sector_size = chip->ecc.size;\n\tcdns_chip->sector_count = mtd->writesize / cdns_chip->sector_size;\n\tecc_size = cdns_chip->sector_count * chip->ecc.bytes;\n\n\tcdns_chip->avail_oob_size = mtd->oobsize - ecc_size;\n\n\tif (cdns_chip->avail_oob_size > cdns_ctrl->bch_metadata_size)\n\t\tcdns_chip->avail_oob_size = cdns_ctrl->bch_metadata_size;\n\n\tif ((cdns_chip->avail_oob_size + cdns_chip->bbm_len + ecc_size)\n\t    > mtd->oobsize)\n\t\tcdns_chip->avail_oob_size -= 4;\n\n\tret = cadence_nand_get_ecc_strength_idx(cdns_ctrl, chip->ecc.strength);\n\tif (ret < 0)\n\t\treturn -EINVAL;\n\n\tcdns_chip->corr_str_idx = (u8)ret;\n\n\tif (cadence_nand_wait_for_value(cdns_ctrl, CTRL_STATUS,\n\t\t\t\t\t1000000,\n\t\t\t\t\tCTRL_STATUS_CTRL_BUSY, true))\n\t\treturn -ETIMEDOUT;\n\n\tcadence_nand_set_ecc_strength(cdns_ctrl,\n\t\t\t\t      cdns_chip->corr_str_idx);\n\n\tcadence_nand_set_erase_detection(cdns_ctrl, true,\n\t\t\t\t\t chip->ecc.strength);\n\n\t \n\tchip->ecc.read_page = cadence_nand_read_page;\n\tchip->ecc.read_page_raw = cadence_nand_read_page_raw;\n\tchip->ecc.write_page = cadence_nand_write_page;\n\tchip->ecc.write_page_raw = cadence_nand_write_page_raw;\n\tchip->ecc.read_oob = cadence_nand_read_oob;\n\tchip->ecc.write_oob = cadence_nand_write_oob;\n\tchip->ecc.read_oob_raw = cadence_nand_read_oob_raw;\n\tchip->ecc.write_oob_raw = cadence_nand_write_oob_raw;\n\n\tif ((mtd->writesize + mtd->oobsize) > cdns_ctrl->buf_size)\n\t\tcdns_ctrl->buf_size = mtd->writesize + mtd->oobsize;\n\n\t \n\tret = dma_set_mask(cdns_ctrl->dev, DMA_BIT_MASK(32));\n\tif (ret) {\n\t\tdev_err(cdns_ctrl->dev, \"no usable DMA configuration\\n\");\n\t\treturn ret;\n\t}\n\n\tmtd_set_ooblayout(mtd, &cadence_nand_ooblayout_ops);\n\n\treturn 0;\n}\n\nstatic const struct nand_controller_ops cadence_nand_controller_ops = {\n\t.attach_chip = cadence_nand_attach_chip,\n\t.exec_op = cadence_nand_exec_op,\n\t.setup_interface = cadence_nand_setup_interface,\n};\n\nstatic int cadence_nand_chip_init(struct cdns_nand_ctrl *cdns_ctrl,\n\t\t\t\t  struct device_node *np)\n{\n\tstruct cdns_nand_chip *cdns_chip;\n\tstruct mtd_info *mtd;\n\tstruct nand_chip *chip;\n\tint nsels, ret, i;\n\tu32 cs;\n\n\tnsels = of_property_count_elems_of_size(np, \"reg\", sizeof(u32));\n\tif (nsels <= 0) {\n\t\tdev_err(cdns_ctrl->dev, \"missing/invalid reg property\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tcdns_chip = devm_kzalloc(cdns_ctrl->dev, sizeof(*cdns_chip) +\n\t\t\t\t (nsels * sizeof(u8)),\n\t\t\t\t GFP_KERNEL);\n\tif (!cdns_chip) {\n\t\tdev_err(cdns_ctrl->dev, \"could not allocate chip structure\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tcdns_chip->nsels = nsels;\n\n\tfor (i = 0; i < nsels; i++) {\n\t\t \n\t\tret = of_property_read_u32_index(np, \"reg\", i, &cs);\n\t\tif (ret) {\n\t\t\tdev_err(cdns_ctrl->dev,\n\t\t\t\t\"could not retrieve reg property: %d\\n\",\n\t\t\t\tret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (cs >= cdns_ctrl->caps2.max_banks) {\n\t\t\tdev_err(cdns_ctrl->dev,\n\t\t\t\t\"invalid reg value: %u (max CS = %d)\\n\",\n\t\t\t\tcs, cdns_ctrl->caps2.max_banks);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (test_and_set_bit(cs, &cdns_ctrl->assigned_cs)) {\n\t\t\tdev_err(cdns_ctrl->dev,\n\t\t\t\t\"CS %d already assigned\\n\", cs);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tcdns_chip->cs[i] = cs;\n\t}\n\n\tchip = &cdns_chip->chip;\n\tchip->controller = &cdns_ctrl->controller;\n\tnand_set_flash_node(chip, np);\n\n\tmtd = nand_to_mtd(chip);\n\tmtd->dev.parent = cdns_ctrl->dev;\n\n\t \n\tchip->ecc.engine_type = NAND_ECC_ENGINE_TYPE_ON_HOST;\n\n\tret = nand_scan(chip, cdns_chip->nsels);\n\tif (ret) {\n\t\tdev_err(cdns_ctrl->dev, \"could not scan the nand chip\\n\");\n\t\treturn ret;\n\t}\n\n\tret = mtd_device_register(mtd, NULL, 0);\n\tif (ret) {\n\t\tdev_err(cdns_ctrl->dev,\n\t\t\t\"failed to register mtd device: %d\\n\", ret);\n\t\tnand_cleanup(chip);\n\t\treturn ret;\n\t}\n\n\tlist_add_tail(&cdns_chip->node, &cdns_ctrl->chips);\n\n\treturn 0;\n}\n\nstatic void cadence_nand_chips_cleanup(struct cdns_nand_ctrl *cdns_ctrl)\n{\n\tstruct cdns_nand_chip *entry, *temp;\n\tstruct nand_chip *chip;\n\tint ret;\n\n\tlist_for_each_entry_safe(entry, temp, &cdns_ctrl->chips, node) {\n\t\tchip = &entry->chip;\n\t\tret = mtd_device_unregister(nand_to_mtd(chip));\n\t\tWARN_ON(ret);\n\t\tnand_cleanup(chip);\n\t\tlist_del(&entry->node);\n\t}\n}\n\nstatic int cadence_nand_chips_init(struct cdns_nand_ctrl *cdns_ctrl)\n{\n\tstruct device_node *np = cdns_ctrl->dev->of_node;\n\tstruct device_node *nand_np;\n\tint max_cs = cdns_ctrl->caps2.max_banks;\n\tint nchips, ret;\n\n\tnchips = of_get_child_count(np);\n\n\tif (nchips > max_cs) {\n\t\tdev_err(cdns_ctrl->dev,\n\t\t\t\"too many NAND chips: %d (max = %d CS)\\n\",\n\t\t\tnchips, max_cs);\n\t\treturn -EINVAL;\n\t}\n\n\tfor_each_child_of_node(np, nand_np) {\n\t\tret = cadence_nand_chip_init(cdns_ctrl, nand_np);\n\t\tif (ret) {\n\t\t\tof_node_put(nand_np);\n\t\t\tcadence_nand_chips_cleanup(cdns_ctrl);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void\ncadence_nand_irq_cleanup(int irqnum, struct cdns_nand_ctrl *cdns_ctrl)\n{\n\t \n\twritel_relaxed(INTR_ENABLE_INTR_EN, cdns_ctrl->reg + INTR_ENABLE);\n}\n\nstatic int cadence_nand_init(struct cdns_nand_ctrl *cdns_ctrl)\n{\n\tdma_cap_mask_t mask;\n\tint ret;\n\n\tcdns_ctrl->cdma_desc = dma_alloc_coherent(cdns_ctrl->dev,\n\t\t\t\t\t\t  sizeof(*cdns_ctrl->cdma_desc),\n\t\t\t\t\t\t  &cdns_ctrl->dma_cdma_desc,\n\t\t\t\t\t\t  GFP_KERNEL);\n\tif (!cdns_ctrl->dma_cdma_desc)\n\t\treturn -ENOMEM;\n\n\tcdns_ctrl->buf_size = SZ_16K;\n\tcdns_ctrl->buf = kmalloc(cdns_ctrl->buf_size, GFP_KERNEL);\n\tif (!cdns_ctrl->buf) {\n\t\tret = -ENOMEM;\n\t\tgoto free_buf_desc;\n\t}\n\n\tif (devm_request_irq(cdns_ctrl->dev, cdns_ctrl->irq, cadence_nand_isr,\n\t\t\t     IRQF_SHARED, \"cadence-nand-controller\",\n\t\t\t     cdns_ctrl)) {\n\t\tdev_err(cdns_ctrl->dev, \"Unable to allocate IRQ\\n\");\n\t\tret = -ENODEV;\n\t\tgoto free_buf;\n\t}\n\n\tspin_lock_init(&cdns_ctrl->irq_lock);\n\tinit_completion(&cdns_ctrl->complete);\n\n\tret = cadence_nand_hw_init(cdns_ctrl);\n\tif (ret)\n\t\tgoto disable_irq;\n\n\tdma_cap_zero(mask);\n\tdma_cap_set(DMA_MEMCPY, mask);\n\n\tif (cdns_ctrl->caps1->has_dma) {\n\t\tcdns_ctrl->dmac = dma_request_channel(mask, NULL, NULL);\n\t\tif (!cdns_ctrl->dmac) {\n\t\t\tdev_err(cdns_ctrl->dev,\n\t\t\t\t\"Unable to get a DMA channel\\n\");\n\t\t\tret = -EBUSY;\n\t\t\tgoto disable_irq;\n\t\t}\n\t}\n\n\tnand_controller_init(&cdns_ctrl->controller);\n\tINIT_LIST_HEAD(&cdns_ctrl->chips);\n\n\tcdns_ctrl->controller.ops = &cadence_nand_controller_ops;\n\tcdns_ctrl->curr_corr_str_idx = 0xFF;\n\n\tret = cadence_nand_chips_init(cdns_ctrl);\n\tif (ret) {\n\t\tdev_err(cdns_ctrl->dev, \"Failed to register MTD: %d\\n\",\n\t\t\tret);\n\t\tgoto dma_release_chnl;\n\t}\n\n\tkfree(cdns_ctrl->buf);\n\tcdns_ctrl->buf = kzalloc(cdns_ctrl->buf_size, GFP_KERNEL);\n\tif (!cdns_ctrl->buf) {\n\t\tret = -ENOMEM;\n\t\tgoto dma_release_chnl;\n\t}\n\n\treturn 0;\n\ndma_release_chnl:\n\tif (cdns_ctrl->dmac)\n\t\tdma_release_channel(cdns_ctrl->dmac);\n\ndisable_irq:\n\tcadence_nand_irq_cleanup(cdns_ctrl->irq, cdns_ctrl);\n\nfree_buf:\n\tkfree(cdns_ctrl->buf);\n\nfree_buf_desc:\n\tdma_free_coherent(cdns_ctrl->dev, sizeof(struct cadence_nand_cdma_desc),\n\t\t\t  cdns_ctrl->cdma_desc, cdns_ctrl->dma_cdma_desc);\n\n\treturn ret;\n}\n\n \nstatic void cadence_nand_remove(struct cdns_nand_ctrl *cdns_ctrl)\n{\n\tcadence_nand_chips_cleanup(cdns_ctrl);\n\tcadence_nand_irq_cleanup(cdns_ctrl->irq, cdns_ctrl);\n\tkfree(cdns_ctrl->buf);\n\tdma_free_coherent(cdns_ctrl->dev, sizeof(struct cadence_nand_cdma_desc),\n\t\t\t  cdns_ctrl->cdma_desc, cdns_ctrl->dma_cdma_desc);\n\n\tif (cdns_ctrl->dmac)\n\t\tdma_release_channel(cdns_ctrl->dmac);\n}\n\nstruct cadence_nand_dt {\n\tstruct cdns_nand_ctrl cdns_ctrl;\n\tstruct clk *clk;\n};\n\nstatic const struct cadence_nand_dt_devdata cadence_nand_default = {\n\t.if_skew = 0,\n\t.has_dma = 1,\n};\n\nstatic const struct of_device_id cadence_nand_dt_ids[] = {\n\t{\n\t\t.compatible = \"cdns,hp-nfc\",\n\t\t.data = &cadence_nand_default\n\t}, {}\n};\n\nMODULE_DEVICE_TABLE(of, cadence_nand_dt_ids);\n\nstatic int cadence_nand_dt_probe(struct platform_device *ofdev)\n{\n\tstruct resource *res;\n\tstruct cadence_nand_dt *dt;\n\tstruct cdns_nand_ctrl *cdns_ctrl;\n\tint ret;\n\tconst struct of_device_id *of_id;\n\tconst struct cadence_nand_dt_devdata *devdata;\n\tu32 val;\n\n\tof_id = of_match_device(cadence_nand_dt_ids, &ofdev->dev);\n\tif (of_id) {\n\t\tofdev->id_entry = of_id->data;\n\t\tdevdata = of_id->data;\n\t} else {\n\t\tpr_err(\"Failed to find the right device id.\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tdt = devm_kzalloc(&ofdev->dev, sizeof(*dt), GFP_KERNEL);\n\tif (!dt)\n\t\treturn -ENOMEM;\n\n\tcdns_ctrl = &dt->cdns_ctrl;\n\tcdns_ctrl->caps1 = devdata;\n\n\tcdns_ctrl->dev = &ofdev->dev;\n\tcdns_ctrl->irq = platform_get_irq(ofdev, 0);\n\tif (cdns_ctrl->irq < 0)\n\t\treturn cdns_ctrl->irq;\n\n\tdev_info(cdns_ctrl->dev, \"IRQ: nr %d\\n\", cdns_ctrl->irq);\n\n\tcdns_ctrl->reg = devm_platform_ioremap_resource(ofdev, 0);\n\tif (IS_ERR(cdns_ctrl->reg))\n\t\treturn PTR_ERR(cdns_ctrl->reg);\n\n\tcdns_ctrl->io.virt = devm_platform_get_and_ioremap_resource(ofdev, 1, &res);\n\tif (IS_ERR(cdns_ctrl->io.virt))\n\t\treturn PTR_ERR(cdns_ctrl->io.virt);\n\tcdns_ctrl->io.dma = res->start;\n\n\tdt->clk = devm_clk_get(cdns_ctrl->dev, \"nf_clk\");\n\tif (IS_ERR(dt->clk))\n\t\treturn PTR_ERR(dt->clk);\n\n\tcdns_ctrl->nf_clk_rate = clk_get_rate(dt->clk);\n\n\tret = of_property_read_u32(ofdev->dev.of_node,\n\t\t\t\t   \"cdns,board-delay-ps\", &val);\n\tif (ret) {\n\t\tval = 4830;\n\t\tdev_info(cdns_ctrl->dev,\n\t\t\t \"missing cdns,board-delay-ps property, %d was set\\n\",\n\t\t\t val);\n\t}\n\tcdns_ctrl->board_delay = val;\n\n\tret = cadence_nand_init(cdns_ctrl);\n\tif (ret)\n\t\treturn ret;\n\n\tplatform_set_drvdata(ofdev, dt);\n\treturn 0;\n}\n\nstatic void cadence_nand_dt_remove(struct platform_device *ofdev)\n{\n\tstruct cadence_nand_dt *dt = platform_get_drvdata(ofdev);\n\n\tcadence_nand_remove(&dt->cdns_ctrl);\n}\n\nstatic struct platform_driver cadence_nand_dt_driver = {\n\t.probe\t\t= cadence_nand_dt_probe,\n\t.remove_new\t= cadence_nand_dt_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"cadence-nand-controller\",\n\t\t.of_match_table = cadence_nand_dt_ids,\n\t},\n};\n\nmodule_platform_driver(cadence_nand_dt_driver);\n\nMODULE_AUTHOR(\"Piotr Sroka <piotrs@cadence.com>\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"Driver for Cadence NAND flash controller\");\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}