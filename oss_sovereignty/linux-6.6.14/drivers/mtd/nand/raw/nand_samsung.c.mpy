{
  "module_name": "nand_samsung.c",
  "hash_id": "8873a0c3a0b0c85b74942ae877c98e73bd5efb59cef36778cff9c53d6d45c2d6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/nand/raw/nand_samsung.c",
  "human_readable_source": "\n \n\n#include \"internals.h\"\n\nstatic void samsung_nand_decode_id(struct nand_chip *chip)\n{\n\tstruct nand_device *base = &chip->base;\n\tstruct nand_ecc_props requirements = {};\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tstruct nand_memory_organization *memorg;\n\n\tmemorg = nanddev_get_memorg(&chip->base);\n\n\t \n\tif (chip->id.len == 6 && !nand_is_slc(chip) &&\n\t    chip->id.data[5] != 0x00) {\n\t\tu8 extid = chip->id.data[3];\n\n\t\t \n\t\tmemorg->pagesize = 2048 << (extid & 0x03);\n\t\tmtd->writesize = memorg->pagesize;\n\n\t\textid >>= 2;\n\n\t\t \n\t\tswitch (((extid >> 2) & 0x4) | (extid & 0x3)) {\n\t\tcase 1:\n\t\t\tmemorg->oobsize = 128;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tmemorg->oobsize = 218;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tmemorg->oobsize = 400;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tmemorg->oobsize = 436;\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\tmemorg->oobsize = 512;\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\tmemorg->oobsize = 640;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t \n\t\t\tWARN(1, \"Invalid OOB size value\");\n\t\t\tbreak;\n\t\t}\n\n\t\tmtd->oobsize = memorg->oobsize;\n\n\t\t \n\t\textid >>= 2;\n\t\tmemorg->pages_per_eraseblock = (128 * 1024) <<\n\t\t\t\t\t       (((extid >> 1) & 0x04) |\n\t\t\t\t\t\t(extid & 0x03)) /\n\t\t\t\t\t       memorg->pagesize;\n\t\tmtd->erasesize = (128 * 1024) <<\n\t\t\t\t (((extid >> 1) & 0x04) | (extid & 0x03));\n\n\t\t \n\t\textid = (chip->id.data[4] >> 4) & 0x07;\n\t\tif (extid < 5) {\n\t\t\trequirements.step_size = 512;\n\t\t\trequirements.strength = 1 << extid;\n\t\t} else {\n\t\t\trequirements.step_size = 1024;\n\t\t\tswitch (extid) {\n\t\t\tcase 5:\n\t\t\t\trequirements.strength = 24;\n\t\t\t\tbreak;\n\t\t\tcase 6:\n\t\t\t\trequirements.strength = 40;\n\t\t\t\tbreak;\n\t\t\tcase 7:\n\t\t\t\trequirements.strength = 60;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tWARN(1, \"Could not decode ECC info\");\n\t\t\t\trequirements.step_size = 0;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tnand_decode_ext_id(chip);\n\n\t\tif (nand_is_slc(chip)) {\n\t\t\tswitch (chip->id.data[1]) {\n\t\t\t \n\t\t\tcase 0xDC:\n\t\t\t\trequirements.step_size = 512;\n\t\t\t\trequirements.strength = 1;\n\t\t\t\tbreak;\n\n\t\t\t \n\t\t\tcase 0xF1:\n\t\t\t\tif (chip->id.len > 4 &&\n\t\t\t\t    (chip->id.data[4] & GENMASK(1, 0)) == 0x1)\n\t\t\t\t\tchip->options |= NAND_NO_SUBPAGE_WRITE;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tnanddev_set_ecc_requirements(base, &requirements);\n}\n\nstatic int samsung_nand_init(struct nand_chip *chip)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\n\tif (mtd->writesize > 512)\n\t\tchip->options |= NAND_SAMSUNG_LP_OPTIONS;\n\n\tif (!nand_is_slc(chip))\n\t\tchip->options |= NAND_BBM_LASTPAGE;\n\telse\n\t\tchip->options |= NAND_BBM_FIRSTPAGE | NAND_BBM_SECONDPAGE;\n\n\treturn 0;\n}\n\nconst struct nand_manufacturer_ops samsung_nand_manuf_ops = {\n\t.detect = samsung_nand_decode_id,\n\t.init = samsung_nand_init,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}