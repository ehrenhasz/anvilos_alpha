{
  "module_name": "jz4740_ecc.c",
  "hash_id": "b65983cc4e67bb7ba9ce25e6ef70871cb3879ae4daf181264c9d9a9fe9115293",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/nand/raw/ingenic/jz4740_ecc.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/device.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n\n#include \"ingenic_ecc.h\"\n\n#define JZ_REG_NAND_ECC_CTRL\t0x00\n#define JZ_REG_NAND_DATA\t0x04\n#define JZ_REG_NAND_PAR0\t0x08\n#define JZ_REG_NAND_PAR1\t0x0C\n#define JZ_REG_NAND_PAR2\t0x10\n#define JZ_REG_NAND_IRQ_STAT\t0x14\n#define JZ_REG_NAND_IRQ_CTRL\t0x18\n#define JZ_REG_NAND_ERR(x)\t(0x1C + ((x) << 2))\n\n#define JZ_NAND_ECC_CTRL_PAR_READY\tBIT(4)\n#define JZ_NAND_ECC_CTRL_ENCODING\tBIT(3)\n#define JZ_NAND_ECC_CTRL_RS\t\tBIT(2)\n#define JZ_NAND_ECC_CTRL_RESET\t\tBIT(1)\n#define JZ_NAND_ECC_CTRL_ENABLE\t\tBIT(0)\n\n#define JZ_NAND_STATUS_ERR_COUNT\t(BIT(31) | BIT(30) | BIT(29))\n#define JZ_NAND_STATUS_PAD_FINISH\tBIT(4)\n#define JZ_NAND_STATUS_DEC_FINISH\tBIT(3)\n#define JZ_NAND_STATUS_ENC_FINISH\tBIT(2)\n#define JZ_NAND_STATUS_UNCOR_ERROR\tBIT(1)\n#define JZ_NAND_STATUS_ERROR\t\tBIT(0)\n\nstatic const uint8_t empty_block_ecc[] = {\n\t0xcd, 0x9d, 0x90, 0x58, 0xf4, 0x8b, 0xff, 0xb7, 0x6f\n};\n\nstatic void jz4740_ecc_reset(struct ingenic_ecc *ecc, bool calc_ecc)\n{\n\tuint32_t reg;\n\n\t \n\twritel(0, ecc->base + JZ_REG_NAND_IRQ_STAT);\n\n\t \n\treg = readl(ecc->base + JZ_REG_NAND_ECC_CTRL);\n\treg |= JZ_NAND_ECC_CTRL_RESET;\n\treg |= JZ_NAND_ECC_CTRL_ENABLE;\n\treg |= JZ_NAND_ECC_CTRL_RS;\n\tif (calc_ecc)  \n\t\treg |= JZ_NAND_ECC_CTRL_ENCODING;\n\telse  \n\t\treg &= ~JZ_NAND_ECC_CTRL_ENCODING;\n\n\twritel(reg, ecc->base + JZ_REG_NAND_ECC_CTRL);\n}\n\nstatic int jz4740_ecc_calculate(struct ingenic_ecc *ecc,\n\t\t\t\tstruct ingenic_ecc_params *params,\n\t\t\t\tconst u8 *buf, u8 *ecc_code)\n{\n\tuint32_t reg, status;\n\tunsigned int timeout = 1000;\n\tint i;\n\n\tjz4740_ecc_reset(ecc, true);\n\n\tdo {\n\t\tstatus = readl(ecc->base + JZ_REG_NAND_IRQ_STAT);\n\t} while (!(status & JZ_NAND_STATUS_ENC_FINISH) && --timeout);\n\n\tif (timeout == 0)\n\t\treturn -ETIMEDOUT;\n\n\treg = readl(ecc->base + JZ_REG_NAND_ECC_CTRL);\n\treg &= ~JZ_NAND_ECC_CTRL_ENABLE;\n\twritel(reg, ecc->base + JZ_REG_NAND_ECC_CTRL);\n\n\tfor (i = 0; i < params->bytes; ++i)\n\t\tecc_code[i] = readb(ecc->base + JZ_REG_NAND_PAR0 + i);\n\n\t \n\tif (memcmp(ecc_code, empty_block_ecc, sizeof(empty_block_ecc)) == 0)\n\t\tmemset(ecc_code, 0xff, sizeof(empty_block_ecc));\n\n\treturn 0;\n}\n\nstatic void jz_nand_correct_data(uint8_t *buf, int index, int mask)\n{\n\tint offset = index & 0x7;\n\tuint16_t data;\n\n\tindex += (index >> 3);\n\n\tdata = buf[index];\n\tdata |= buf[index + 1] << 8;\n\n\tmask ^= (data >> offset) & 0x1ff;\n\tdata &= ~(0x1ff << offset);\n\tdata |= (mask << offset);\n\n\tbuf[index] = data & 0xff;\n\tbuf[index + 1] = (data >> 8) & 0xff;\n}\n\nstatic int jz4740_ecc_correct(struct ingenic_ecc *ecc,\n\t\t\t      struct ingenic_ecc_params *params,\n\t\t\t      u8 *buf, u8 *ecc_code)\n{\n\tint i, error_count, index;\n\tuint32_t reg, status, error;\n\tunsigned int timeout = 1000;\n\n\tjz4740_ecc_reset(ecc, false);\n\n\tfor (i = 0; i < params->bytes; ++i)\n\t\twriteb(ecc_code[i], ecc->base + JZ_REG_NAND_PAR0 + i);\n\n\treg = readl(ecc->base + JZ_REG_NAND_ECC_CTRL);\n\treg |= JZ_NAND_ECC_CTRL_PAR_READY;\n\twritel(reg, ecc->base + JZ_REG_NAND_ECC_CTRL);\n\n\tdo {\n\t\tstatus = readl(ecc->base + JZ_REG_NAND_IRQ_STAT);\n\t} while (!(status & JZ_NAND_STATUS_DEC_FINISH) && --timeout);\n\n\tif (timeout == 0)\n\t\treturn -ETIMEDOUT;\n\n\treg = readl(ecc->base + JZ_REG_NAND_ECC_CTRL);\n\treg &= ~JZ_NAND_ECC_CTRL_ENABLE;\n\twritel(reg, ecc->base + JZ_REG_NAND_ECC_CTRL);\n\n\tif (status & JZ_NAND_STATUS_ERROR) {\n\t\tif (status & JZ_NAND_STATUS_UNCOR_ERROR)\n\t\t\treturn -EBADMSG;\n\n\t\terror_count = (status & JZ_NAND_STATUS_ERR_COUNT) >> 29;\n\n\t\tfor (i = 0; i < error_count; ++i) {\n\t\t\terror = readl(ecc->base + JZ_REG_NAND_ERR(i));\n\t\t\tindex = ((error >> 16) & 0x1ff) - 1;\n\t\t\tif (index >= 0 && index < params->size)\n\t\t\t\tjz_nand_correct_data(buf, index, error & 0x1ff);\n\t\t}\n\n\t\treturn error_count;\n\t}\n\n\treturn 0;\n}\n\nstatic void jz4740_ecc_disable(struct ingenic_ecc *ecc)\n{\n\tu32 reg;\n\n\twritel(0, ecc->base + JZ_REG_NAND_IRQ_STAT);\n\treg = readl(ecc->base + JZ_REG_NAND_ECC_CTRL);\n\treg &= ~JZ_NAND_ECC_CTRL_ENABLE;\n\twritel(reg, ecc->base + JZ_REG_NAND_ECC_CTRL);\n}\n\nstatic const struct ingenic_ecc_ops jz4740_ecc_ops = {\n\t.disable = jz4740_ecc_disable,\n\t.calculate = jz4740_ecc_calculate,\n\t.correct = jz4740_ecc_correct,\n};\n\nstatic const struct of_device_id jz4740_ecc_dt_match[] = {\n\t{ .compatible = \"ingenic,jz4740-ecc\", .data = &jz4740_ecc_ops },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, jz4740_ecc_dt_match);\n\nstatic struct platform_driver jz4740_ecc_driver = {\n\t.probe\t\t= ingenic_ecc_probe,\n\t.driver\t= {\n\t\t.name\t= \"jz4740-ecc\",\n\t\t.of_match_table = jz4740_ecc_dt_match,\n\t},\n};\nmodule_platform_driver(jz4740_ecc_driver);\n\nMODULE_AUTHOR(\"Paul Cercueil <paul@crapouillou.net>\");\nMODULE_DESCRIPTION(\"Ingenic JZ4740 ECC controller driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}