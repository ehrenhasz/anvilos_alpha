{
  "module_name": "jz4725b_bch.c",
  "hash_id": "03bc1cf10410d41cf023f01175b23e888ae9ff3303c6cdaedb16f9977455c76d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/nand/raw/ingenic/jz4725b_bch.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/device.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n\n#include \"ingenic_ecc.h\"\n\n#define BCH_BHCR\t\t\t0x0\n#define BCH_BHCSR\t\t\t0x4\n#define BCH_BHCCR\t\t\t0x8\n#define BCH_BHCNT\t\t\t0xc\n#define BCH_BHDR\t\t\t0x10\n#define BCH_BHPAR0\t\t\t0x14\n#define BCH_BHERR0\t\t\t0x28\n#define BCH_BHINT\t\t\t0x24\n#define BCH_BHINTES\t\t\t0x3c\n#define BCH_BHINTEC\t\t\t0x40\n#define BCH_BHINTE\t\t\t0x38\n\n#define BCH_BHCR_ENCE\t\t\tBIT(3)\n#define BCH_BHCR_BSEL\t\t\tBIT(2)\n#define BCH_BHCR_INIT\t\t\tBIT(1)\n#define BCH_BHCR_BCHE\t\t\tBIT(0)\n\n#define BCH_BHCNT_DEC_COUNT_SHIFT\t16\n#define BCH_BHCNT_DEC_COUNT_MASK\t(0x3ff << BCH_BHCNT_DEC_COUNT_SHIFT)\n#define BCH_BHCNT_ENC_COUNT_SHIFT\t0\n#define BCH_BHCNT_ENC_COUNT_MASK\t(0x3ff << BCH_BHCNT_ENC_COUNT_SHIFT)\n\n#define BCH_BHERR_INDEX0_SHIFT\t\t0\n#define BCH_BHERR_INDEX0_MASK\t\t(0x1fff << BCH_BHERR_INDEX0_SHIFT)\n#define BCH_BHERR_INDEX1_SHIFT\t\t16\n#define BCH_BHERR_INDEX1_MASK\t\t(0x1fff << BCH_BHERR_INDEX1_SHIFT)\n\n#define BCH_BHINT_ERRC_SHIFT\t\t28\n#define BCH_BHINT_ERRC_MASK\t\t(0xf << BCH_BHINT_ERRC_SHIFT)\n#define BCH_BHINT_TERRC_SHIFT\t\t16\n#define BCH_BHINT_TERRC_MASK\t\t(0x7f << BCH_BHINT_TERRC_SHIFT)\n#define BCH_BHINT_ALL_0\t\t\tBIT(5)\n#define BCH_BHINT_ALL_F\t\t\tBIT(4)\n#define BCH_BHINT_DECF\t\t\tBIT(3)\n#define BCH_BHINT_ENCF\t\t\tBIT(2)\n#define BCH_BHINT_UNCOR\t\t\tBIT(1)\n#define BCH_BHINT_ERR\t\t\tBIT(0)\n\n \n#define BCH_TIMEOUT_US\t\t\t100000\n\nstatic inline void jz4725b_bch_config_set(struct ingenic_ecc *bch, u32 cfg)\n{\n\twritel(cfg, bch->base + BCH_BHCSR);\n}\n\nstatic inline void jz4725b_bch_config_clear(struct ingenic_ecc *bch, u32 cfg)\n{\n\twritel(cfg, bch->base + BCH_BHCCR);\n}\n\nstatic int jz4725b_bch_reset(struct ingenic_ecc *bch,\n\t\t\t     struct ingenic_ecc_params *params, bool calc_ecc)\n{\n\tu32 reg, max_value;\n\n\t \n\twritel(readl(bch->base + BCH_BHINT), bch->base + BCH_BHINT);\n\n\t \n\tjz4725b_bch_config_clear(bch, 0x1f);\n\tjz4725b_bch_config_set(bch, BCH_BHCR_BCHE);\n\n\tif (params->strength == 8)\n\t\tjz4725b_bch_config_set(bch, BCH_BHCR_BSEL);\n\telse\n\t\tjz4725b_bch_config_clear(bch, BCH_BHCR_BSEL);\n\n\tif (calc_ecc)  \n\t\tjz4725b_bch_config_set(bch, BCH_BHCR_ENCE);\n\telse  \n\t\tjz4725b_bch_config_clear(bch, BCH_BHCR_ENCE);\n\n\tjz4725b_bch_config_set(bch, BCH_BHCR_INIT);\n\n\tmax_value = BCH_BHCNT_ENC_COUNT_MASK >> BCH_BHCNT_ENC_COUNT_SHIFT;\n\tif (params->size > max_value)\n\t\treturn -EINVAL;\n\n\tmax_value = BCH_BHCNT_DEC_COUNT_MASK >> BCH_BHCNT_DEC_COUNT_SHIFT;\n\tif (params->size + params->bytes > max_value)\n\t\treturn -EINVAL;\n\n\t \n\treg = params->size << BCH_BHCNT_ENC_COUNT_SHIFT;\n\treg |= (params->size + params->bytes) << BCH_BHCNT_DEC_COUNT_SHIFT;\n\twritel(reg, bch->base + BCH_BHCNT);\n\n\treturn 0;\n}\n\nstatic void jz4725b_bch_disable(struct ingenic_ecc *bch)\n{\n\t \n\twritel(readl(bch->base + BCH_BHINT), bch->base + BCH_BHINT);\n\n\t \n\tjz4725b_bch_config_clear(bch, BCH_BHCR_BCHE);\n}\n\nstatic void jz4725b_bch_write_data(struct ingenic_ecc *bch, const u8 *buf,\n\t\t\t\t   size_t size)\n{\n\twhile (size--)\n\t\twriteb(*buf++, bch->base + BCH_BHDR);\n}\n\nstatic void jz4725b_bch_read_parity(struct ingenic_ecc *bch, u8 *buf,\n\t\t\t\t    size_t size)\n{\n\tsize_t size32 = size / sizeof(u32);\n\tsize_t size8 = size % sizeof(u32);\n\tu32 *dest32;\n\tu8 *dest8;\n\tu32 val, offset = 0;\n\n\tdest32 = (u32 *)buf;\n\twhile (size32--) {\n\t\t*dest32++ = readl_relaxed(bch->base + BCH_BHPAR0 + offset);\n\t\toffset += sizeof(u32);\n\t}\n\n\tdest8 = (u8 *)dest32;\n\tval = readl_relaxed(bch->base + BCH_BHPAR0 + offset);\n\tswitch (size8) {\n\tcase 3:\n\t\tdest8[2] = (val >> 16) & 0xff;\n\t\tfallthrough;\n\tcase 2:\n\t\tdest8[1] = (val >> 8) & 0xff;\n\t\tfallthrough;\n\tcase 1:\n\t\tdest8[0] = val & 0xff;\n\t\tbreak;\n\t}\n}\n\nstatic int jz4725b_bch_wait_complete(struct ingenic_ecc *bch, unsigned int irq,\n\t\t\t\t     u32 *status)\n{\n\tu32 reg;\n\tint ret;\n\n\t \n\tret = readl_relaxed_poll_timeout(bch->base + BCH_BHINT, reg,\n\t\t\t\t\t reg & irq, 0, BCH_TIMEOUT_US);\n\tif (ret)\n\t\treturn ret;\n\n\tif (status)\n\t\t*status = reg;\n\n\twritel(reg, bch->base + BCH_BHINT);\n\n\treturn 0;\n}\n\nstatic int jz4725b_calculate(struct ingenic_ecc *bch,\n\t\t\t     struct ingenic_ecc_params *params,\n\t\t\t     const u8 *buf, u8 *ecc_code)\n{\n\tint ret;\n\n\tmutex_lock(&bch->lock);\n\n\tret = jz4725b_bch_reset(bch, params, true);\n\tif (ret) {\n\t\tdev_err(bch->dev, \"Unable to init BCH with given parameters\\n\");\n\t\tgoto out_disable;\n\t}\n\n\tjz4725b_bch_write_data(bch, buf, params->size);\n\n\tret = jz4725b_bch_wait_complete(bch, BCH_BHINT_ENCF, NULL);\n\tif (ret) {\n\t\tdev_err(bch->dev, \"timed out while calculating ECC\\n\");\n\t\tgoto out_disable;\n\t}\n\n\tjz4725b_bch_read_parity(bch, ecc_code, params->bytes);\n\nout_disable:\n\tjz4725b_bch_disable(bch);\n\tmutex_unlock(&bch->lock);\n\n\treturn ret;\n}\n\nstatic int jz4725b_correct(struct ingenic_ecc *bch,\n\t\t\t   struct ingenic_ecc_params *params,\n\t\t\t   u8 *buf, u8 *ecc_code)\n{\n\tu32 reg, errors, bit;\n\tunsigned int i;\n\tint ret;\n\n\tmutex_lock(&bch->lock);\n\n\tret = jz4725b_bch_reset(bch, params, false);\n\tif (ret) {\n\t\tdev_err(bch->dev, \"Unable to init BCH with given parameters\\n\");\n\t\tgoto out;\n\t}\n\n\tjz4725b_bch_write_data(bch, buf, params->size);\n\tjz4725b_bch_write_data(bch, ecc_code, params->bytes);\n\n\tret = jz4725b_bch_wait_complete(bch, BCH_BHINT_DECF, &reg);\n\tif (ret) {\n\t\tdev_err(bch->dev, \"timed out while correcting data\\n\");\n\t\tgoto out;\n\t}\n\n\tif (reg & (BCH_BHINT_ALL_F | BCH_BHINT_ALL_0)) {\n\t\t \n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tif (reg & BCH_BHINT_UNCOR) {\n\t\t \n\t\tret = -EBADMSG;\n\t\tgoto out;\n\t}\n\n\terrors = (reg & BCH_BHINT_ERRC_MASK) >> BCH_BHINT_ERRC_SHIFT;\n\n\t \n\tfor (i = 0; i < errors; i++) {\n\t\tif (i & 1) {\n\t\t\tbit = (reg & BCH_BHERR_INDEX1_MASK) >> BCH_BHERR_INDEX1_SHIFT;\n\t\t} else {\n\t\t\treg = readl(bch->base + BCH_BHERR0 + (i * 4));\n\t\t\tbit = (reg & BCH_BHERR_INDEX0_MASK) >> BCH_BHERR_INDEX0_SHIFT;\n\t\t}\n\n\t\tbuf[(bit >> 3)] ^= BIT(bit & 0x7);\n\t}\n\nout:\n\tjz4725b_bch_disable(bch);\n\tmutex_unlock(&bch->lock);\n\n\treturn ret;\n}\n\nstatic const struct ingenic_ecc_ops jz4725b_bch_ops = {\n\t.disable = jz4725b_bch_disable,\n\t.calculate = jz4725b_calculate,\n\t.correct = jz4725b_correct,\n};\n\nstatic const struct of_device_id jz4725b_bch_dt_match[] = {\n\t{ .compatible = \"ingenic,jz4725b-bch\", .data = &jz4725b_bch_ops },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, jz4725b_bch_dt_match);\n\nstatic struct platform_driver jz4725b_bch_driver = {\n\t.probe\t\t= ingenic_ecc_probe,\n\t.driver\t= {\n\t\t.name\t= \"jz4725b-bch\",\n\t\t.of_match_table = jz4725b_bch_dt_match,\n\t},\n};\nmodule_platform_driver(jz4725b_bch_driver);\n\nMODULE_AUTHOR(\"Paul Cercueil <paul@crapouillou.net>\");\nMODULE_DESCRIPTION(\"Ingenic JZ4725B BCH controller driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}