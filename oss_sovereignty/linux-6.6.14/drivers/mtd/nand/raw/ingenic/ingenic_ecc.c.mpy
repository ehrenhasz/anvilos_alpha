{
  "module_name": "ingenic_ecc.c",
  "hash_id": "689c4fb49c67359294efafc18ddefb0046c0b84ae214c081752e2143a93be73e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/nand/raw/ingenic/ingenic_ecc.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n\n#include \"ingenic_ecc.h\"\n\n \nint ingenic_ecc_calculate(struct ingenic_ecc *ecc,\n\t\t\t  struct ingenic_ecc_params *params,\n\t\t\t  const u8 *buf, u8 *ecc_code)\n{\n\treturn ecc->ops->calculate(ecc, params, buf, ecc_code);\n}\n\n \nint ingenic_ecc_correct(struct ingenic_ecc *ecc,\n\t\t\tstruct ingenic_ecc_params *params,\n\t\t\tu8 *buf, u8 *ecc_code)\n{\n\treturn ecc->ops->correct(ecc, params, buf, ecc_code);\n}\n\n \nstatic struct ingenic_ecc *ingenic_ecc_get(struct device_node *np)\n{\n\tstruct platform_device *pdev;\n\tstruct ingenic_ecc *ecc;\n\n\tpdev = of_find_device_by_node(np);\n\tif (!pdev)\n\t\treturn ERR_PTR(-EPROBE_DEFER);\n\n\tif (!platform_get_drvdata(pdev)) {\n\t\tput_device(&pdev->dev);\n\t\treturn ERR_PTR(-EPROBE_DEFER);\n\t}\n\n\tecc = platform_get_drvdata(pdev);\n\tclk_prepare_enable(ecc->clk);\n\n\treturn ecc;\n}\n\n \nstruct ingenic_ecc *of_ingenic_ecc_get(struct device_node *of_node)\n{\n\tstruct ingenic_ecc *ecc = NULL;\n\tstruct device_node *np;\n\n\tnp = of_parse_phandle(of_node, \"ecc-engine\", 0);\n\n\t \n\tif (!np)\n\t\tnp = of_parse_phandle(of_node, \"ingenic,bch-controller\", 0);\n\n\tif (np) {\n\t\tecc = ingenic_ecc_get(np);\n\t\tof_node_put(np);\n\t}\n\treturn ecc;\n}\n\n \nvoid ingenic_ecc_release(struct ingenic_ecc *ecc)\n{\n\tclk_disable_unprepare(ecc->clk);\n\tput_device(ecc->dev);\n}\n\nint ingenic_ecc_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct ingenic_ecc *ecc;\n\n\tecc = devm_kzalloc(dev, sizeof(*ecc), GFP_KERNEL);\n\tif (!ecc)\n\t\treturn -ENOMEM;\n\n\tecc->ops = device_get_match_data(dev);\n\tif (!ecc->ops)\n\t\treturn -EINVAL;\n\n\tecc->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(ecc->base))\n\t\treturn PTR_ERR(ecc->base);\n\n\tecc->ops->disable(ecc);\n\n\tecc->clk = devm_clk_get(dev, NULL);\n\tif (IS_ERR(ecc->clk)) {\n\t\tdev_err(dev, \"failed to get clock: %ld\\n\", PTR_ERR(ecc->clk));\n\t\treturn PTR_ERR(ecc->clk);\n\t}\n\n\tmutex_init(&ecc->lock);\n\n\tecc->dev = dev;\n\tplatform_set_drvdata(pdev, ecc);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(ingenic_ecc_probe);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}