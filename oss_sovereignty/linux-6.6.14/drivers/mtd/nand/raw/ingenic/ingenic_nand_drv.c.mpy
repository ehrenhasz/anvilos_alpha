{
  "module_name": "ingenic_nand_drv.c",
  "hash_id": "cd3cfc559e18baa12a7de2350ebd0dc6719c6239027fff5ce3d78034d9b2b1e9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/nand/raw/ingenic/ingenic_nand_drv.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/gpio/consumer.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/mtd/mtd.h>\n#include <linux/mtd/rawnand.h>\n#include <linux/mtd/partitions.h>\n\n#include <linux/jz4780-nemc.h>\n\n#include \"ingenic_ecc.h\"\n\n#define DRV_NAME\t\"ingenic-nand\"\n\nstruct jz_soc_info {\n\tunsigned long data_offset;\n\tunsigned long addr_offset;\n\tunsigned long cmd_offset;\n\tconst struct mtd_ooblayout_ops *oob_layout;\n\tbool oob_first;\n};\n\nstruct ingenic_nand_cs {\n\tunsigned int bank;\n\tvoid __iomem *base;\n};\n\nstruct ingenic_nfc {\n\tstruct device *dev;\n\tstruct ingenic_ecc *ecc;\n\tconst struct jz_soc_info *soc_info;\n\tstruct nand_controller controller;\n\tunsigned int num_banks;\n\tstruct list_head chips;\n\tstruct ingenic_nand_cs cs[];\n};\n\nstruct ingenic_nand {\n\tstruct nand_chip chip;\n\tstruct list_head chip_list;\n\n\tstruct gpio_desc *busy_gpio;\n\tstruct gpio_desc *wp_gpio;\n\tunsigned int reading: 1;\n};\n\nstatic inline struct ingenic_nand *to_ingenic_nand(struct mtd_info *mtd)\n{\n\treturn container_of(mtd_to_nand(mtd), struct ingenic_nand, chip);\n}\n\nstatic inline struct ingenic_nfc *to_ingenic_nfc(struct nand_controller *ctrl)\n{\n\treturn container_of(ctrl, struct ingenic_nfc, controller);\n}\n\nstatic int qi_lb60_ooblayout_ecc(struct mtd_info *mtd, int section,\n\t\t\t\t struct mtd_oob_region *oobregion)\n{\n\tstruct nand_chip *chip = mtd_to_nand(mtd);\n\tstruct nand_ecc_ctrl *ecc = &chip->ecc;\n\n\tif (section || !ecc->total)\n\t\treturn -ERANGE;\n\n\toobregion->length = ecc->total;\n\toobregion->offset = 12;\n\n\treturn 0;\n}\n\nstatic int qi_lb60_ooblayout_free(struct mtd_info *mtd, int section,\n\t\t\t\t  struct mtd_oob_region *oobregion)\n{\n\tstruct nand_chip *chip = mtd_to_nand(mtd);\n\tstruct nand_ecc_ctrl *ecc = &chip->ecc;\n\n\tif (section)\n\t\treturn -ERANGE;\n\n\toobregion->length = mtd->oobsize - ecc->total - 12;\n\toobregion->offset = 12 + ecc->total;\n\n\treturn 0;\n}\n\nstatic const struct mtd_ooblayout_ops qi_lb60_ooblayout_ops = {\n\t.ecc = qi_lb60_ooblayout_ecc,\n\t.free = qi_lb60_ooblayout_free,\n};\n\nstatic int jz4725b_ooblayout_ecc(struct mtd_info *mtd, int section,\n\t\t\t\t struct mtd_oob_region *oobregion)\n{\n\tstruct nand_chip *chip = mtd_to_nand(mtd);\n\tstruct nand_ecc_ctrl *ecc = &chip->ecc;\n\n\tif (section || !ecc->total)\n\t\treturn -ERANGE;\n\n\toobregion->length = ecc->total;\n\toobregion->offset = 3;\n\n\treturn 0;\n}\n\nstatic int jz4725b_ooblayout_free(struct mtd_info *mtd, int section,\n\t\t\t\t  struct mtd_oob_region *oobregion)\n{\n\tstruct nand_chip *chip = mtd_to_nand(mtd);\n\tstruct nand_ecc_ctrl *ecc = &chip->ecc;\n\n\tif (section)\n\t\treturn -ERANGE;\n\n\toobregion->length = mtd->oobsize - ecc->total - 3;\n\toobregion->offset = 3 + ecc->total;\n\n\treturn 0;\n}\n\nstatic const struct mtd_ooblayout_ops jz4725b_ooblayout_ops = {\n\t.ecc = jz4725b_ooblayout_ecc,\n\t.free = jz4725b_ooblayout_free,\n};\n\nstatic void ingenic_nand_ecc_hwctl(struct nand_chip *chip, int mode)\n{\n\tstruct ingenic_nand *nand = to_ingenic_nand(nand_to_mtd(chip));\n\n\tnand->reading = (mode == NAND_ECC_READ);\n}\n\nstatic int ingenic_nand_ecc_calculate(struct nand_chip *chip, const u8 *dat,\n\t\t\t\t      u8 *ecc_code)\n{\n\tstruct ingenic_nand *nand = to_ingenic_nand(nand_to_mtd(chip));\n\tstruct ingenic_nfc *nfc = to_ingenic_nfc(nand->chip.controller);\n\tstruct ingenic_ecc_params params;\n\n\t \n\tif (nand->reading)\n\t\treturn 0;\n\n\tparams.size = nand->chip.ecc.size;\n\tparams.bytes = nand->chip.ecc.bytes;\n\tparams.strength = nand->chip.ecc.strength;\n\n\treturn ingenic_ecc_calculate(nfc->ecc, &params, dat, ecc_code);\n}\n\nstatic int ingenic_nand_ecc_correct(struct nand_chip *chip, u8 *dat,\n\t\t\t\t    u8 *read_ecc, u8 *calc_ecc)\n{\n\tstruct ingenic_nand *nand = to_ingenic_nand(nand_to_mtd(chip));\n\tstruct ingenic_nfc *nfc = to_ingenic_nfc(nand->chip.controller);\n\tstruct ingenic_ecc_params params;\n\n\tparams.size = nand->chip.ecc.size;\n\tparams.bytes = nand->chip.ecc.bytes;\n\tparams.strength = nand->chip.ecc.strength;\n\n\treturn ingenic_ecc_correct(nfc->ecc, &params, dat, read_ecc);\n}\n\nstatic int ingenic_nand_attach_chip(struct nand_chip *chip)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tstruct ingenic_nfc *nfc = to_ingenic_nfc(chip->controller);\n\tint eccbytes;\n\n\tif (chip->ecc.strength == 4) {\n\t\t \n\t\tchip->ecc.bytes = 9;\n\t} else {\n\t\tchip->ecc.bytes = fls((1 + 8) * chip->ecc.size)\t*\n\t\t\t\t  (chip->ecc.strength / 8);\n\t}\n\n\tswitch (chip->ecc.engine_type) {\n\tcase NAND_ECC_ENGINE_TYPE_ON_HOST:\n\t\tif (!nfc->ecc) {\n\t\t\tdev_err(nfc->dev, \"HW ECC selected, but ECC controller not found\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\n\t\tchip->ecc.hwctl = ingenic_nand_ecc_hwctl;\n\t\tchip->ecc.calculate = ingenic_nand_ecc_calculate;\n\t\tchip->ecc.correct = ingenic_nand_ecc_correct;\n\t\tfallthrough;\n\tcase NAND_ECC_ENGINE_TYPE_SOFT:\n\t\tdev_info(nfc->dev, \"using %s (strength %d, size %d, bytes %d)\\n\",\n\t\t\t (nfc->ecc) ? \"hardware ECC\" : \"software ECC\",\n\t\t\t chip->ecc.strength, chip->ecc.size, chip->ecc.bytes);\n\t\tbreak;\n\tcase NAND_ECC_ENGINE_TYPE_NONE:\n\t\tdev_info(nfc->dev, \"not using ECC\\n\");\n\t\tbreak;\n\tdefault:\n\t\tdev_err(nfc->dev, \"ECC mode %d not supported\\n\",\n\t\t\tchip->ecc.engine_type);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (chip->ecc.engine_type != NAND_ECC_ENGINE_TYPE_ON_HOST)\n\t\treturn 0;\n\n\t \n\teccbytes = mtd->writesize / chip->ecc.size * chip->ecc.bytes;\n\n\tif (eccbytes > mtd->oobsize - 2) {\n\t\tdev_err(nfc->dev,\n\t\t\t\"invalid ECC config: required %d ECC bytes, but only %d are available\",\n\t\t\teccbytes, mtd->oobsize - 2);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (chip->bbt_options & NAND_BBT_USE_FLASH)\n\t\tchip->bbt_options |= NAND_BBT_NO_OOB;\n\n\tif (nfc->soc_info->oob_first)\n\t\tchip->ecc.read_page = nand_read_page_hwecc_oob_first;\n\n\t \n\tif (of_machine_is_compatible(\"qi,lb60\"))\n\t\tmtd_set_ooblayout(mtd, &qi_lb60_ooblayout_ops);\n\telse if (nfc->soc_info->oob_layout)\n\t\tmtd_set_ooblayout(mtd, nfc->soc_info->oob_layout);\n\telse\n\t\tmtd_set_ooblayout(mtd, nand_get_large_page_ooblayout());\n\n\treturn 0;\n}\n\nstatic int ingenic_nand_exec_instr(struct nand_chip *chip,\n\t\t\t\t   struct ingenic_nand_cs *cs,\n\t\t\t\t   const struct nand_op_instr *instr)\n{\n\tstruct ingenic_nand *nand = to_ingenic_nand(nand_to_mtd(chip));\n\tstruct ingenic_nfc *nfc = to_ingenic_nfc(chip->controller);\n\tunsigned int i;\n\n\tswitch (instr->type) {\n\tcase NAND_OP_CMD_INSTR:\n\t\twriteb(instr->ctx.cmd.opcode,\n\t\t       cs->base + nfc->soc_info->cmd_offset);\n\t\treturn 0;\n\tcase NAND_OP_ADDR_INSTR:\n\t\tfor (i = 0; i < instr->ctx.addr.naddrs; i++)\n\t\t\twriteb(instr->ctx.addr.addrs[i],\n\t\t\t       cs->base + nfc->soc_info->addr_offset);\n\t\treturn 0;\n\tcase NAND_OP_DATA_IN_INSTR:\n\t\tif (instr->ctx.data.force_8bit ||\n\t\t    !(chip->options & NAND_BUSWIDTH_16))\n\t\t\tioread8_rep(cs->base + nfc->soc_info->data_offset,\n\t\t\t\t    instr->ctx.data.buf.in,\n\t\t\t\t    instr->ctx.data.len);\n\t\telse\n\t\t\tioread16_rep(cs->base + nfc->soc_info->data_offset,\n\t\t\t\t     instr->ctx.data.buf.in,\n\t\t\t\t     instr->ctx.data.len);\n\t\treturn 0;\n\tcase NAND_OP_DATA_OUT_INSTR:\n\t\tif (instr->ctx.data.force_8bit ||\n\t\t    !(chip->options & NAND_BUSWIDTH_16))\n\t\t\tiowrite8_rep(cs->base + nfc->soc_info->data_offset,\n\t\t\t\t     instr->ctx.data.buf.out,\n\t\t\t\t     instr->ctx.data.len);\n\t\telse\n\t\t\tiowrite16_rep(cs->base + nfc->soc_info->data_offset,\n\t\t\t\t      instr->ctx.data.buf.out,\n\t\t\t\t      instr->ctx.data.len);\n\t\treturn 0;\n\tcase NAND_OP_WAITRDY_INSTR:\n\t\tif (!nand->busy_gpio)\n\t\t\treturn nand_soft_waitrdy(chip,\n\t\t\t\t\t\t instr->ctx.waitrdy.timeout_ms);\n\n\t\treturn nand_gpio_waitrdy(chip, nand->busy_gpio,\n\t\t\t\t\t instr->ctx.waitrdy.timeout_ms);\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int ingenic_nand_exec_op(struct nand_chip *chip,\n\t\t\t\tconst struct nand_operation *op,\n\t\t\t\tbool check_only)\n{\n\tstruct ingenic_nand *nand = to_ingenic_nand(nand_to_mtd(chip));\n\tstruct ingenic_nfc *nfc = to_ingenic_nfc(nand->chip.controller);\n\tstruct ingenic_nand_cs *cs;\n\tunsigned int i;\n\tint ret = 0;\n\n\tif (check_only)\n\t\treturn 0;\n\n\tcs = &nfc->cs[op->cs];\n\tjz4780_nemc_assert(nfc->dev, cs->bank, true);\n\tfor (i = 0; i < op->ninstrs; i++) {\n\t\tret = ingenic_nand_exec_instr(chip, cs, &op->instrs[i]);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tif (op->instrs[i].delay_ns)\n\t\t\tndelay(op->instrs[i].delay_ns);\n\t}\n\tjz4780_nemc_assert(nfc->dev, cs->bank, false);\n\n\treturn ret;\n}\n\nstatic const struct nand_controller_ops ingenic_nand_controller_ops = {\n\t.attach_chip = ingenic_nand_attach_chip,\n\t.exec_op = ingenic_nand_exec_op,\n};\n\nstatic int ingenic_nand_init_chip(struct platform_device *pdev,\n\t\t\t\t  struct ingenic_nfc *nfc,\n\t\t\t\t  struct device_node *np,\n\t\t\t\t  unsigned int chipnr)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct ingenic_nand *nand;\n\tstruct ingenic_nand_cs *cs;\n\tstruct nand_chip *chip;\n\tstruct mtd_info *mtd;\n\tconst __be32 *reg;\n\tint ret = 0;\n\n\tcs = &nfc->cs[chipnr];\n\n\treg = of_get_property(np, \"reg\", NULL);\n\tif (!reg)\n\t\treturn -EINVAL;\n\n\tcs->bank = be32_to_cpu(*reg);\n\n\tjz4780_nemc_set_type(nfc->dev, cs->bank, JZ4780_NEMC_BANK_NAND);\n\n\tcs->base = devm_platform_ioremap_resource(pdev, chipnr);\n\tif (IS_ERR(cs->base))\n\t\treturn PTR_ERR(cs->base);\n\n\tnand = devm_kzalloc(dev, sizeof(*nand), GFP_KERNEL);\n\tif (!nand)\n\t\treturn -ENOMEM;\n\n\tnand->busy_gpio = devm_gpiod_get_optional(dev, \"rb\", GPIOD_IN);\n\n\tif (IS_ERR(nand->busy_gpio)) {\n\t\tret = PTR_ERR(nand->busy_gpio);\n\t\tdev_err(dev, \"failed to request busy GPIO: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tif (of_machine_is_compatible(\"qi,lb60\") &&\n\t    gpiod_is_active_low(nand->busy_gpio))\n\t\tgpiod_toggle_active_low(nand->busy_gpio);\n\n\tnand->wp_gpio = devm_gpiod_get_optional(dev, \"wp\", GPIOD_OUT_LOW);\n\n\tif (IS_ERR(nand->wp_gpio)) {\n\t\tret = PTR_ERR(nand->wp_gpio);\n\t\tdev_err(dev, \"failed to request WP GPIO: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tchip = &nand->chip;\n\tmtd = nand_to_mtd(chip);\n\tmtd->name = devm_kasprintf(dev, GFP_KERNEL, \"%s.%d\", dev_name(dev),\n\t\t\t\t   cs->bank);\n\tif (!mtd->name)\n\t\treturn -ENOMEM;\n\tmtd->dev.parent = dev;\n\n\tchip->options = NAND_NO_SUBPAGE_WRITE;\n\tchip->ecc.engine_type = NAND_ECC_ENGINE_TYPE_ON_HOST;\n\tchip->controller = &nfc->controller;\n\tnand_set_flash_node(chip, np);\n\n\tchip->controller->ops = &ingenic_nand_controller_ops;\n\tret = nand_scan(chip, 1);\n\tif (ret)\n\t\treturn ret;\n\n\tret = mtd_device_register(mtd, NULL, 0);\n\tif (ret) {\n\t\tnand_cleanup(chip);\n\t\treturn ret;\n\t}\n\n\tlist_add_tail(&nand->chip_list, &nfc->chips);\n\n\treturn 0;\n}\n\nstatic void ingenic_nand_cleanup_chips(struct ingenic_nfc *nfc)\n{\n\tstruct ingenic_nand *ingenic_chip;\n\tstruct nand_chip *chip;\n\tint ret;\n\n\twhile (!list_empty(&nfc->chips)) {\n\t\tingenic_chip = list_first_entry(&nfc->chips,\n\t\t\t\t\t\tstruct ingenic_nand, chip_list);\n\t\tchip = &ingenic_chip->chip;\n\t\tret = mtd_device_unregister(nand_to_mtd(chip));\n\t\tWARN_ON(ret);\n\t\tnand_cleanup(chip);\n\t\tlist_del(&ingenic_chip->chip_list);\n\t}\n}\n\nstatic int ingenic_nand_init_chips(struct ingenic_nfc *nfc,\n\t\t\t\t   struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np;\n\tint i = 0;\n\tint ret;\n\tint num_chips = of_get_child_count(dev->of_node);\n\n\tif (num_chips > nfc->num_banks) {\n\t\tdev_err(dev, \"found %d chips but only %d banks\\n\",\n\t\t\tnum_chips, nfc->num_banks);\n\t\treturn -EINVAL;\n\t}\n\n\tfor_each_child_of_node(dev->of_node, np) {\n\t\tret = ingenic_nand_init_chip(pdev, nfc, np, i);\n\t\tif (ret) {\n\t\t\tingenic_nand_cleanup_chips(nfc);\n\t\t\tof_node_put(np);\n\t\t\treturn ret;\n\t\t}\n\n\t\ti++;\n\t}\n\n\treturn 0;\n}\n\nstatic int ingenic_nand_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tunsigned int num_banks;\n\tstruct ingenic_nfc *nfc;\n\tint ret;\n\n\tnum_banks = jz4780_nemc_num_banks(dev);\n\tif (num_banks == 0) {\n\t\tdev_err(dev, \"no banks found\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tnfc = devm_kzalloc(dev, struct_size(nfc, cs, num_banks), GFP_KERNEL);\n\tif (!nfc)\n\t\treturn -ENOMEM;\n\n\tnfc->soc_info = device_get_match_data(dev);\n\tif (!nfc->soc_info)\n\t\treturn -EINVAL;\n\n\t \n\tnfc->ecc = of_ingenic_ecc_get(dev->of_node);\n\tif (IS_ERR(nfc->ecc))\n\t\treturn PTR_ERR(nfc->ecc);\n\n\tnfc->dev = dev;\n\tnfc->num_banks = num_banks;\n\n\tnand_controller_init(&nfc->controller);\n\tINIT_LIST_HEAD(&nfc->chips);\n\n\tret = ingenic_nand_init_chips(nfc, pdev);\n\tif (ret) {\n\t\tif (nfc->ecc)\n\t\t\tingenic_ecc_release(nfc->ecc);\n\t\treturn ret;\n\t}\n\n\tplatform_set_drvdata(pdev, nfc);\n\treturn 0;\n}\n\nstatic void ingenic_nand_remove(struct platform_device *pdev)\n{\n\tstruct ingenic_nfc *nfc = platform_get_drvdata(pdev);\n\n\tif (nfc->ecc)\n\t\tingenic_ecc_release(nfc->ecc);\n\n\tingenic_nand_cleanup_chips(nfc);\n}\n\nstatic const struct jz_soc_info jz4740_soc_info = {\n\t.data_offset = 0x00000000,\n\t.cmd_offset = 0x00008000,\n\t.addr_offset = 0x00010000,\n\t.oob_first = true,\n};\n\nstatic const struct jz_soc_info jz4725b_soc_info = {\n\t.data_offset = 0x00000000,\n\t.cmd_offset = 0x00008000,\n\t.addr_offset = 0x00010000,\n\t.oob_layout = &jz4725b_ooblayout_ops,\n};\n\nstatic const struct jz_soc_info jz4780_soc_info = {\n\t.data_offset = 0x00000000,\n\t.cmd_offset = 0x00400000,\n\t.addr_offset = 0x00800000,\n};\n\nstatic const struct of_device_id ingenic_nand_dt_match[] = {\n\t{ .compatible = \"ingenic,jz4740-nand\", .data = &jz4740_soc_info },\n\t{ .compatible = \"ingenic,jz4725b-nand\", .data = &jz4725b_soc_info },\n\t{ .compatible = \"ingenic,jz4780-nand\", .data = &jz4780_soc_info },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, ingenic_nand_dt_match);\n\nstatic struct platform_driver ingenic_nand_driver = {\n\t.probe\t\t= ingenic_nand_probe,\n\t.remove_new\t= ingenic_nand_remove,\n\t.driver\t= {\n\t\t.name\t= DRV_NAME,\n\t\t.of_match_table = ingenic_nand_dt_match,\n\t},\n};\nmodule_platform_driver(ingenic_nand_driver);\n\nMODULE_AUTHOR(\"Alex Smith <alex@alex-smith.me.uk>\");\nMODULE_AUTHOR(\"Harvey Hunt <harveyhuntnexus@gmail.com>\");\nMODULE_DESCRIPTION(\"Ingenic JZ47xx NAND driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}