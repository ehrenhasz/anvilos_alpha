{
  "module_name": "jz4780_bch.c",
  "hash_id": "50818c57b2e67c2634d85ea931e03d9a65e90d69e3f3c8d65d2ef135e218cabe",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/nand/raw/ingenic/jz4780_bch.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/clk.h>\n#include <linux/device.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n\n#include \"ingenic_ecc.h\"\n\n#define BCH_BHCR\t\t\t0x0\n#define BCH_BHCCR\t\t\t0x8\n#define BCH_BHCNT\t\t\t0xc\n#define BCH_BHDR\t\t\t0x10\n#define BCH_BHPAR0\t\t\t0x14\n#define BCH_BHERR0\t\t\t0x84\n#define BCH_BHINT\t\t\t0x184\n#define BCH_BHINTES\t\t\t0x188\n#define BCH_BHINTEC\t\t\t0x18c\n#define BCH_BHINTE\t\t\t0x190\n\n#define BCH_BHCR_BSEL_SHIFT\t\t4\n#define BCH_BHCR_BSEL_MASK\t\t(0x7f << BCH_BHCR_BSEL_SHIFT)\n#define BCH_BHCR_ENCE\t\t\tBIT(2)\n#define BCH_BHCR_INIT\t\t\tBIT(1)\n#define BCH_BHCR_BCHE\t\t\tBIT(0)\n\n#define BCH_BHCNT_PARITYSIZE_SHIFT\t16\n#define BCH_BHCNT_PARITYSIZE_MASK\t(0x7f << BCH_BHCNT_PARITYSIZE_SHIFT)\n#define BCH_BHCNT_BLOCKSIZE_SHIFT\t0\n#define BCH_BHCNT_BLOCKSIZE_MASK\t(0x7ff << BCH_BHCNT_BLOCKSIZE_SHIFT)\n\n#define BCH_BHERR_MASK_SHIFT\t\t16\n#define BCH_BHERR_MASK_MASK\t\t(0xffff << BCH_BHERR_MASK_SHIFT)\n#define BCH_BHERR_INDEX_SHIFT\t\t0\n#define BCH_BHERR_INDEX_MASK\t\t(0x7ff << BCH_BHERR_INDEX_SHIFT)\n\n#define BCH_BHINT_ERRC_SHIFT\t\t24\n#define BCH_BHINT_ERRC_MASK\t\t(0x7f << BCH_BHINT_ERRC_SHIFT)\n#define BCH_BHINT_TERRC_SHIFT\t\t16\n#define BCH_BHINT_TERRC_MASK\t\t(0x7f << BCH_BHINT_TERRC_SHIFT)\n#define BCH_BHINT_DECF\t\t\tBIT(3)\n#define BCH_BHINT_ENCF\t\t\tBIT(2)\n#define BCH_BHINT_UNCOR\t\t\tBIT(1)\n#define BCH_BHINT_ERR\t\t\tBIT(0)\n\n#define BCH_CLK_RATE\t\t\t(200 * 1000 * 1000)\n\n \n#define BCH_TIMEOUT_US\t\t\t100000\n\nstatic void jz4780_bch_reset(struct ingenic_ecc *bch,\n\t\t\t     struct ingenic_ecc_params *params, bool encode)\n{\n\tu32 reg;\n\n\t \n\twritel(readl(bch->base + BCH_BHINT), bch->base + BCH_BHINT);\n\n\t \n\treg = params->size << BCH_BHCNT_BLOCKSIZE_SHIFT;\n\treg |= params->bytes << BCH_BHCNT_PARITYSIZE_SHIFT;\n\twritel(reg, bch->base + BCH_BHCNT);\n\n\t \n\treg = BCH_BHCR_BCHE | BCH_BHCR_INIT;\n\treg |= params->strength << BCH_BHCR_BSEL_SHIFT;\n\tif (encode)\n\t\treg |= BCH_BHCR_ENCE;\n\twritel(reg, bch->base + BCH_BHCR);\n}\n\nstatic void jz4780_bch_disable(struct ingenic_ecc *bch)\n{\n\twritel(readl(bch->base + BCH_BHINT), bch->base + BCH_BHINT);\n\twritel(BCH_BHCR_BCHE, bch->base + BCH_BHCCR);\n}\n\nstatic void jz4780_bch_write_data(struct ingenic_ecc *bch, const void *buf,\n\t\t\t\t  size_t size)\n{\n\tsize_t size32 = size / sizeof(u32);\n\tsize_t size8 = size % sizeof(u32);\n\tconst u32 *src32;\n\tconst u8 *src8;\n\n\tsrc32 = (const u32 *)buf;\n\twhile (size32--)\n\t\twritel(*src32++, bch->base + BCH_BHDR);\n\n\tsrc8 = (const u8 *)src32;\n\twhile (size8--)\n\t\twriteb(*src8++, bch->base + BCH_BHDR);\n}\n\nstatic void jz4780_bch_read_parity(struct ingenic_ecc *bch, void *buf,\n\t\t\t\t   size_t size)\n{\n\tsize_t size32 = size / sizeof(u32);\n\tsize_t size8 = size % sizeof(u32);\n\tu32 *dest32;\n\tu8 *dest8;\n\tu32 val, offset = 0;\n\n\tdest32 = (u32 *)buf;\n\twhile (size32--) {\n\t\t*dest32++ = readl(bch->base + BCH_BHPAR0 + offset);\n\t\toffset += sizeof(u32);\n\t}\n\n\tdest8 = (u8 *)dest32;\n\tval = readl(bch->base + BCH_BHPAR0 + offset);\n\tswitch (size8) {\n\tcase 3:\n\t\tdest8[2] = (val >> 16) & 0xff;\n\t\tfallthrough;\n\tcase 2:\n\t\tdest8[1] = (val >> 8) & 0xff;\n\t\tfallthrough;\n\tcase 1:\n\t\tdest8[0] = val & 0xff;\n\t\tbreak;\n\t}\n}\n\nstatic bool jz4780_bch_wait_complete(struct ingenic_ecc *bch, unsigned int irq,\n\t\t\t\t     u32 *status)\n{\n\tu32 reg;\n\tint ret;\n\n\t \n\tret = readl_poll_timeout(bch->base + BCH_BHINT, reg,\n\t\t\t\t (reg & irq) == irq, 0, BCH_TIMEOUT_US);\n\tif (ret)\n\t\treturn false;\n\n\tif (status)\n\t\t*status = reg;\n\n\twritel(reg, bch->base + BCH_BHINT);\n\treturn true;\n}\n\nstatic int jz4780_calculate(struct ingenic_ecc *bch,\n\t\t\t    struct ingenic_ecc_params *params,\n\t\t\t    const u8 *buf, u8 *ecc_code)\n{\n\tint ret = 0;\n\n\tmutex_lock(&bch->lock);\n\n\tjz4780_bch_reset(bch, params, true);\n\tjz4780_bch_write_data(bch, buf, params->size);\n\n\tif (jz4780_bch_wait_complete(bch, BCH_BHINT_ENCF, NULL)) {\n\t\tjz4780_bch_read_parity(bch, ecc_code, params->bytes);\n\t} else {\n\t\tdev_err(bch->dev, \"timed out while calculating ECC\\n\");\n\t\tret = -ETIMEDOUT;\n\t}\n\n\tjz4780_bch_disable(bch);\n\tmutex_unlock(&bch->lock);\n\treturn ret;\n}\n\nstatic int jz4780_correct(struct ingenic_ecc *bch,\n\t\t\t  struct ingenic_ecc_params *params,\n\t\t\t  u8 *buf, u8 *ecc_code)\n{\n\tu32 reg, mask, index;\n\tint i, ret, count;\n\n\tmutex_lock(&bch->lock);\n\n\tjz4780_bch_reset(bch, params, false);\n\tjz4780_bch_write_data(bch, buf, params->size);\n\tjz4780_bch_write_data(bch, ecc_code, params->bytes);\n\n\tif (!jz4780_bch_wait_complete(bch, BCH_BHINT_DECF, &reg)) {\n\t\tdev_err(bch->dev, \"timed out while correcting data\\n\");\n\t\tret = -ETIMEDOUT;\n\t\tgoto out;\n\t}\n\n\tif (reg & BCH_BHINT_UNCOR) {\n\t\tdev_warn(bch->dev, \"uncorrectable ECC error\\n\");\n\t\tret = -EBADMSG;\n\t\tgoto out;\n\t}\n\n\t \n\tif (reg & BCH_BHINT_ERR) {\n\t\tcount = (reg & BCH_BHINT_ERRC_MASK) >> BCH_BHINT_ERRC_SHIFT;\n\t\tret = (reg & BCH_BHINT_TERRC_MASK) >> BCH_BHINT_TERRC_SHIFT;\n\n\t\tfor (i = 0; i < count; i++) {\n\t\t\treg = readl(bch->base + BCH_BHERR0 + (i * 4));\n\t\t\tmask = (reg & BCH_BHERR_MASK_MASK) >>\n\t\t\t\t\t\tBCH_BHERR_MASK_SHIFT;\n\t\t\tindex = (reg & BCH_BHERR_INDEX_MASK) >>\n\t\t\t\t\t\tBCH_BHERR_INDEX_SHIFT;\n\t\t\tbuf[(index * 2) + 0] ^= mask;\n\t\t\tbuf[(index * 2) + 1] ^= mask >> 8;\n\t\t}\n\t} else {\n\t\tret = 0;\n\t}\n\nout:\n\tjz4780_bch_disable(bch);\n\tmutex_unlock(&bch->lock);\n\treturn ret;\n}\n\nstatic int jz4780_bch_probe(struct platform_device *pdev)\n{\n\tstruct ingenic_ecc *bch;\n\tint ret;\n\n\tret = ingenic_ecc_probe(pdev);\n\tif (ret)\n\t\treturn ret;\n\n\tbch = platform_get_drvdata(pdev);\n\tclk_set_rate(bch->clk, BCH_CLK_RATE);\n\n\treturn 0;\n}\n\nstatic const struct ingenic_ecc_ops jz4780_bch_ops = {\n\t.disable = jz4780_bch_disable,\n\t.calculate = jz4780_calculate,\n\t.correct = jz4780_correct,\n};\n\nstatic const struct of_device_id jz4780_bch_dt_match[] = {\n\t{ .compatible = \"ingenic,jz4780-bch\", .data = &jz4780_bch_ops },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, jz4780_bch_dt_match);\n\nstatic struct platform_driver jz4780_bch_driver = {\n\t.probe\t\t= jz4780_bch_probe,\n\t.driver\t= {\n\t\t.name\t= \"jz4780-bch\",\n\t\t.of_match_table = jz4780_bch_dt_match,\n\t},\n};\nmodule_platform_driver(jz4780_bch_driver);\n\nMODULE_AUTHOR(\"Alex Smith <alex@alex-smith.me.uk>\");\nMODULE_AUTHOR(\"Harvey Hunt <harveyhuntnexus@gmail.com>\");\nMODULE_DESCRIPTION(\"Ingenic JZ4780 BCH error correction driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}