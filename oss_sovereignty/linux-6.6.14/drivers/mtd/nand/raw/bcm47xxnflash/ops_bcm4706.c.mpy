{
  "module_name": "ops_bcm4706.c",
  "hash_id": "ea15c65ea9124750f4a5a341b6395a5820146fab9d7c72fa5a7f36d03c5877ea",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/nand/raw/bcm47xxnflash/ops_bcm4706.c",
  "human_readable_source": "\n \n\n#include \"bcm47xxnflash.h\"\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/bcma/bcma.h>\n\n \n#define NFLASH_READY_RETRIES\t\t10000\n\n#define NFLASH_SECTOR_SIZE\t\t512\n\n#define NCTL_CMD0\t\t\t0x00010000\n#define NCTL_COL\t\t\t0x00020000\t \n#define NCTL_ROW\t\t\t0x00040000\t \n#define NCTL_CMD1W\t\t\t0x00080000\n#define NCTL_READ\t\t\t0x00100000\n#define NCTL_WRITE\t\t\t0x00200000\n#define NCTL_SPECADDR\t\t\t0x01000000\n#define NCTL_READY\t\t\t0x04000000\n#define NCTL_ERR\t\t\t0x08000000\n#define NCTL_CSA\t\t\t0x40000000\n#define NCTL_START\t\t\t0x80000000\n\n \n\nstatic inline u8 bcm47xxnflash_ops_bcm4706_ns_to_cycle(u16 ns, u16 clock)\n{\n\treturn ((ns * 1000 * clock) / 1000000) + 1;\n}\n\nstatic int bcm47xxnflash_ops_bcm4706_ctl_cmd(struct bcma_drv_cc *cc, u32 code)\n{\n\tint i = 0;\n\n\tbcma_cc_write32(cc, BCMA_CC_NFLASH_CTL, NCTL_START | code);\n\tfor (i = 0; i < NFLASH_READY_RETRIES; i++) {\n\t\tif (!(bcma_cc_read32(cc, BCMA_CC_NFLASH_CTL) & NCTL_START)) {\n\t\t\ti = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (i) {\n\t\tpr_err(\"NFLASH control command not ready!\\n\");\n\t\treturn -EBUSY;\n\t}\n\treturn 0;\n}\n\nstatic int bcm47xxnflash_ops_bcm4706_poll(struct bcma_drv_cc *cc)\n{\n\tint i;\n\n\tfor (i = 0; i < NFLASH_READY_RETRIES; i++) {\n\t\tif (bcma_cc_read32(cc, BCMA_CC_NFLASH_CTL) & NCTL_READY) {\n\t\t\tif (bcma_cc_read32(cc, BCMA_CC_NFLASH_CTL) &\n\t\t\t    BCMA_CC_NFLASH_CTL_ERR) {\n\t\t\t\tpr_err(\"Error on polling\\n\");\n\t\t\t\treturn -EBUSY;\n\t\t\t} else {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tpr_err(\"Polling timeout!\\n\");\n\treturn -EBUSY;\n}\n\n \n\nstatic void bcm47xxnflash_ops_bcm4706_read(struct mtd_info *mtd, uint8_t *buf,\n\t\t\t\t\t   int len)\n{\n\tstruct nand_chip *nand_chip = mtd_to_nand(mtd);\n\tstruct bcm47xxnflash *b47n = nand_get_controller_data(nand_chip);\n\n\tu32 ctlcode;\n\tu32 *dest = (u32 *)buf;\n\tint i;\n\tint toread;\n\n\tBUG_ON(b47n->curr_page_addr & ~nand_chip->pagemask);\n\t \n\n\twhile (len) {\n\t\t \n\t\ttoread = min(len, 0x200);\n\n\t\t \n\t\tbcma_cc_write32(b47n->cc, BCMA_CC_NFLASH_COL_ADDR,\n\t\t\t\tb47n->curr_column);\n\t\tbcma_cc_write32(b47n->cc, BCMA_CC_NFLASH_ROW_ADDR,\n\t\t\t\tb47n->curr_page_addr);\n\n\t\t \n\t\tctlcode = NCTL_CSA | NCTL_CMD1W | NCTL_ROW | NCTL_COL |\n\t\t\t  NCTL_CMD0;\n\t\tctlcode |= NAND_CMD_READSTART << 8;\n\t\tif (bcm47xxnflash_ops_bcm4706_ctl_cmd(b47n->cc, ctlcode))\n\t\t\treturn;\n\t\tif (bcm47xxnflash_ops_bcm4706_poll(b47n->cc))\n\t\t\treturn;\n\n\t\t \n\t\tfor (i = 0; i < toread; i += 4, dest++) {\n\t\t\tctlcode = NCTL_CSA | 0x30000000 | NCTL_READ;\n\t\t\tif (i == toread - 4)  \n\t\t\t\tctlcode &= ~NCTL_CSA;\n\t\t\tif (bcm47xxnflash_ops_bcm4706_ctl_cmd(b47n->cc,\n\t\t\t\t\t\t\t      ctlcode))\n\t\t\t\treturn;\n\t\t\t*dest = bcma_cc_read32(b47n->cc, BCMA_CC_NFLASH_DATA);\n\t\t}\n\n\t\tb47n->curr_column += toread;\n\t\tlen -= toread;\n\t}\n}\n\nstatic void bcm47xxnflash_ops_bcm4706_write(struct mtd_info *mtd,\n\t\t\t\t\t    const uint8_t *buf, int len)\n{\n\tstruct nand_chip *nand_chip = mtd_to_nand(mtd);\n\tstruct bcm47xxnflash *b47n = nand_get_controller_data(nand_chip);\n\tstruct bcma_drv_cc *cc = b47n->cc;\n\n\tu32 ctlcode;\n\tconst u32 *data = (u32 *)buf;\n\tint i;\n\n\tBUG_ON(b47n->curr_page_addr & ~nand_chip->pagemask);\n\t \n\n\tfor (i = 0; i < len; i += 4, data++) {\n\t\tbcma_cc_write32(cc, BCMA_CC_NFLASH_DATA, *data);\n\n\t\tctlcode = NCTL_CSA | 0x30000000 | NCTL_WRITE;\n\t\tif (i == len - 4)  \n\t\t\tctlcode &= ~NCTL_CSA;\n\t\tif (bcm47xxnflash_ops_bcm4706_ctl_cmd(cc, ctlcode)) {\n\t\t\tpr_err(\"%s ctl_cmd didn't work!\\n\", __func__);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tb47n->curr_column += len;\n}\n\n \n\nstatic void bcm47xxnflash_ops_bcm4706_cmd_ctrl(struct nand_chip *nand_chip,\n\t\t\t\t\t       int cmd, unsigned int ctrl)\n{\n\tstruct bcm47xxnflash *b47n = nand_get_controller_data(nand_chip);\n\tu32 code = 0;\n\n\tif (cmd == NAND_CMD_NONE)\n\t\treturn;\n\n\tif (cmd & NAND_CTRL_CLE)\n\t\tcode = cmd | NCTL_CMD0;\n\n\t \n\tif (cmd != NAND_CMD_RESET)\n\t\tcode |= NCTL_CSA;\n\n\tbcm47xxnflash_ops_bcm4706_ctl_cmd(b47n->cc, code);\n}\n\n \nstatic void bcm47xxnflash_ops_bcm4706_select_chip(struct nand_chip *chip,\n\t\t\t\t\t\t  int cs)\n{\n\treturn;\n}\n\nstatic int bcm47xxnflash_ops_bcm4706_dev_ready(struct nand_chip *nand_chip)\n{\n\tstruct bcm47xxnflash *b47n = nand_get_controller_data(nand_chip);\n\n\treturn !!(bcma_cc_read32(b47n->cc, BCMA_CC_NFLASH_CTL) & NCTL_READY);\n}\n\n \nstatic void bcm47xxnflash_ops_bcm4706_cmdfunc(struct nand_chip *nand_chip,\n\t\t\t\t\t      unsigned command, int column,\n\t\t\t\t\t      int page_addr)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(nand_chip);\n\tstruct bcm47xxnflash *b47n = nand_get_controller_data(nand_chip);\n\tstruct bcma_drv_cc *cc = b47n->cc;\n\tu32 ctlcode;\n\tint i;\n\n\tif (column != -1)\n\t\tb47n->curr_column = column;\n\tif (page_addr != -1)\n\t\tb47n->curr_page_addr = page_addr;\n\n\tswitch (command) {\n\tcase NAND_CMD_RESET:\n\t\tnand_chip->legacy.cmd_ctrl(nand_chip, command, NAND_CTRL_CLE);\n\n\t\tndelay(100);\n\t\tnand_wait_ready(nand_chip);\n\t\tbreak;\n\tcase NAND_CMD_READID:\n\t\tctlcode = NCTL_CSA | 0x01000000 | NCTL_CMD1W | NCTL_CMD0;\n\t\tctlcode |= NAND_CMD_READID;\n\t\tif (bcm47xxnflash_ops_bcm4706_ctl_cmd(b47n->cc, ctlcode)) {\n\t\t\tpr_err(\"READID error\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tfor (i = 0; i < ARRAY_SIZE(b47n->id_data); i++) {\n\t\t\tctlcode = NCTL_CSA | NCTL_READ;\n\t\t\tif (i == ARRAY_SIZE(b47n->id_data) - 1)\n\t\t\t\tctlcode &= ~NCTL_CSA;\n\t\t\tif (bcm47xxnflash_ops_bcm4706_ctl_cmd(b47n->cc,\n\t\t\t\t\t\t\t      ctlcode)) {\n\t\t\t\tpr_err(\"READID error\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tb47n->id_data[i] =\n\t\t\t\tbcma_cc_read32(b47n->cc, BCMA_CC_NFLASH_DATA)\n\t\t\t\t& 0xFF;\n\t\t}\n\n\t\tbreak;\n\tcase NAND_CMD_STATUS:\n\t\tctlcode = NCTL_CSA | NCTL_CMD0 | NAND_CMD_STATUS;\n\t\tif (bcm47xxnflash_ops_bcm4706_ctl_cmd(cc, ctlcode))\n\t\t\tpr_err(\"STATUS command error\\n\");\n\t\tbreak;\n\tcase NAND_CMD_READ0:\n\t\tbreak;\n\tcase NAND_CMD_READOOB:\n\t\tif (page_addr != -1)\n\t\t\tb47n->curr_column += mtd->writesize;\n\t\tbreak;\n\tcase NAND_CMD_ERASE1:\n\t\tbcma_cc_write32(cc, BCMA_CC_NFLASH_ROW_ADDR,\n\t\t\t\tb47n->curr_page_addr);\n\t\tctlcode = NCTL_ROW | NCTL_CMD1W | NCTL_CMD0 |\n\t\t\t  NAND_CMD_ERASE1 | (NAND_CMD_ERASE2 << 8);\n\t\tif (bcm47xxnflash_ops_bcm4706_ctl_cmd(cc, ctlcode))\n\t\t\tpr_err(\"ERASE1 failed\\n\");\n\t\tbreak;\n\tcase NAND_CMD_ERASE2:\n\t\tbreak;\n\tcase NAND_CMD_SEQIN:\n\t\t \n\t\tbcma_cc_write32(cc, BCMA_CC_NFLASH_COL_ADDR,\n\t\t\t\tb47n->curr_column);\n\t\tbcma_cc_write32(cc, BCMA_CC_NFLASH_ROW_ADDR,\n\t\t\t\tb47n->curr_page_addr);\n\n\t\t \n\t\tctlcode = 0x40000000 | NCTL_ROW | NCTL_COL | NCTL_CMD0;\n\t\tctlcode |= NAND_CMD_SEQIN;\n\t\tif (bcm47xxnflash_ops_bcm4706_ctl_cmd(cc, ctlcode))\n\t\t\tpr_err(\"SEQIN failed\\n\");\n\t\tbreak;\n\tcase NAND_CMD_PAGEPROG:\n\t\tif (bcm47xxnflash_ops_bcm4706_ctl_cmd(cc, NCTL_CMD0 |\n\t\t\t\t\t\t\t  NAND_CMD_PAGEPROG))\n\t\t\tpr_err(\"PAGEPROG failed\\n\");\n\t\tif (bcm47xxnflash_ops_bcm4706_poll(cc))\n\t\t\tpr_err(\"PAGEPROG not ready\\n\");\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"Command 0x%X unsupported\\n\", command);\n\t\tbreak;\n\t}\n\tb47n->curr_command = command;\n}\n\nstatic u8 bcm47xxnflash_ops_bcm4706_read_byte(struct nand_chip *nand_chip)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(nand_chip);\n\tstruct bcm47xxnflash *b47n = nand_get_controller_data(nand_chip);\n\tstruct bcma_drv_cc *cc = b47n->cc;\n\tu32 tmp = 0;\n\n\tswitch (b47n->curr_command) {\n\tcase NAND_CMD_READID:\n\t\tif (b47n->curr_column >= ARRAY_SIZE(b47n->id_data)) {\n\t\t\tpr_err(\"Requested invalid id_data: %d\\n\",\n\t\t\t       b47n->curr_column);\n\t\t\treturn 0;\n\t\t}\n\t\treturn b47n->id_data[b47n->curr_column++];\n\tcase NAND_CMD_STATUS:\n\t\tif (bcm47xxnflash_ops_bcm4706_ctl_cmd(cc, NCTL_READ))\n\t\t\treturn 0;\n\t\treturn bcma_cc_read32(cc, BCMA_CC_NFLASH_DATA) & 0xff;\n\tcase NAND_CMD_READOOB:\n\t\tbcm47xxnflash_ops_bcm4706_read(mtd, (u8 *)&tmp, 4);\n\t\treturn tmp & 0xFF;\n\t}\n\n\tpr_err(\"Invalid command for byte read: 0x%X\\n\", b47n->curr_command);\n\treturn 0;\n}\n\nstatic void bcm47xxnflash_ops_bcm4706_read_buf(struct nand_chip *nand_chip,\n\t\t\t\t\t       uint8_t *buf, int len)\n{\n\tstruct bcm47xxnflash *b47n = nand_get_controller_data(nand_chip);\n\n\tswitch (b47n->curr_command) {\n\tcase NAND_CMD_READ0:\n\tcase NAND_CMD_READOOB:\n\t\tbcm47xxnflash_ops_bcm4706_read(nand_to_mtd(nand_chip), buf,\n\t\t\t\t\t       len);\n\t\treturn;\n\t}\n\n\tpr_err(\"Invalid command for buf read: 0x%X\\n\", b47n->curr_command);\n}\n\nstatic void bcm47xxnflash_ops_bcm4706_write_buf(struct nand_chip *nand_chip,\n\t\t\t\t\t\tconst uint8_t *buf, int len)\n{\n\tstruct bcm47xxnflash *b47n = nand_get_controller_data(nand_chip);\n\n\tswitch (b47n->curr_command) {\n\tcase NAND_CMD_SEQIN:\n\t\tbcm47xxnflash_ops_bcm4706_write(nand_to_mtd(nand_chip), buf,\n\t\t\t\t\t\tlen);\n\t\treturn;\n\t}\n\n\tpr_err(\"Invalid command for buf write: 0x%X\\n\", b47n->curr_command);\n}\n\n \n\nint bcm47xxnflash_ops_bcm4706_init(struct bcm47xxnflash *b47n)\n{\n\tstruct nand_chip *nand_chip = (struct nand_chip *)&b47n->nand_chip;\n\tint err;\n\tu32 freq;\n\tu16 clock;\n\tu8 w0, w1, w2, w3, w4;\n\n\tunsigned long chipsize;  \n\tu8 tbits, col_bits, col_size, row_bits, row_bsize;\n\tu32 val;\n\n\tnand_chip->legacy.select_chip = bcm47xxnflash_ops_bcm4706_select_chip;\n\tnand_chip->legacy.cmd_ctrl = bcm47xxnflash_ops_bcm4706_cmd_ctrl;\n\tnand_chip->legacy.dev_ready = bcm47xxnflash_ops_bcm4706_dev_ready;\n\tb47n->nand_chip.legacy.cmdfunc = bcm47xxnflash_ops_bcm4706_cmdfunc;\n\tb47n->nand_chip.legacy.read_byte = bcm47xxnflash_ops_bcm4706_read_byte;\n\tb47n->nand_chip.legacy.read_buf = bcm47xxnflash_ops_bcm4706_read_buf;\n\tb47n->nand_chip.legacy.write_buf = bcm47xxnflash_ops_bcm4706_write_buf;\n\tb47n->nand_chip.legacy.set_features = nand_get_set_features_notsupp;\n\tb47n->nand_chip.legacy.get_features = nand_get_set_features_notsupp;\n\n\tnand_chip->legacy.chip_delay = 50;\n\tb47n->nand_chip.bbt_options = NAND_BBT_USE_FLASH;\n\t \n\tb47n->nand_chip.ecc.engine_type = NAND_ECC_ENGINE_TYPE_NONE;\n\n\t \n\tbcma_cc_set32(b47n->cc, BCMA_CC_4706_FLASHSCFG,\n\t\t      BCMA_CC_4706_FLASHSCFG_NF1);\n\n\t \n\tif (b47n->cc->status & BCMA_CC_CHIPST_4706_PKG_OPTION) {\n\t\t \n\t\tfreq = 400000000 / 4;\n\t} else {\n\t\tfreq = bcma_chipco_pll_read(b47n->cc, 4);\n\t\tfreq = (freq & 0xFFF) >> 3;\n\t\t \n\t\tfreq = (freq * 25000000 / 2) / 4;\n\t}\n\tclock = freq / 1000000;\n\tw0 = bcm47xxnflash_ops_bcm4706_ns_to_cycle(15, clock);\n\tw1 = bcm47xxnflash_ops_bcm4706_ns_to_cycle(20, clock);\n\tw2 = bcm47xxnflash_ops_bcm4706_ns_to_cycle(10, clock);\n\tw3 = bcm47xxnflash_ops_bcm4706_ns_to_cycle(10, clock);\n\tw4 = bcm47xxnflash_ops_bcm4706_ns_to_cycle(100, clock);\n\tbcma_cc_write32(b47n->cc, BCMA_CC_NFLASH_WAITCNT0,\n\t\t\t(w4 << 24 | w3 << 18 | w2 << 12 | w1 << 6 | w0));\n\n\t \n\terr = nand_scan(&b47n->nand_chip, 1);\n\tif (err) {\n\t\tpr_err(\"Could not scan NAND flash: %d\\n\", err);\n\t\tgoto exit;\n\t}\n\n\t \n\tchipsize = nanddev_target_size(&b47n->nand_chip.base) >> 20;\n\ttbits = ffs(chipsize);  \n\tif (!tbits || tbits != fls(chipsize)) {\n\t\tpr_err(\"Invalid flash size: 0x%lX\\n\", chipsize);\n\t\terr = -ENOTSUPP;\n\t\tgoto exit;\n\t}\n\ttbits += 19;  \n\n\tcol_bits = b47n->nand_chip.page_shift + 1;\n\tcol_size = (col_bits + 7) / 8;\n\n\trow_bits = tbits - col_bits + 1;\n\trow_bsize = (row_bits + 7) / 8;\n\n\tval = ((row_bsize - 1) << 6) | ((col_size - 1) << 4) | 2;\n\tbcma_cc_write32(b47n->cc, BCMA_CC_NFLASH_CONF, val);\n\nexit:\n\tif (err)\n\t\tbcma_cc_mask32(b47n->cc, BCMA_CC_4706_FLASHSCFG,\n\t\t\t       ~BCMA_CC_4706_FLASHSCFG_NF1);\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}