{
  "module_name": "omap2.c",
  "hash_id": "fc2e4cd269bd3087e825ebca7f534db9f5cae8ff69827b714ff1ca1bec9d4b2f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/nand/raw/omap2.c",
  "human_readable_source": "\n \n\n#include <linux/platform_device.h>\n#include <linux/dmaengine.h>\n#include <linux/dma-mapping.h>\n#include <linux/delay.h>\n#include <linux/gpio/consumer.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/jiffies.h>\n#include <linux/sched.h>\n#include <linux/mtd/mtd.h>\n#include <linux/mtd/nand-ecc-sw-bch.h>\n#include <linux/mtd/rawnand.h>\n#include <linux/mtd/partitions.h>\n#include <linux/omap-dma.h>\n#include <linux/iopoll.h>\n#include <linux/slab.h>\n#include <linux/of.h>\n#include <linux/of_platform.h>\n\n#include <linux/platform_data/elm.h>\n\n#include <linux/omap-gpmc.h>\n#include <linux/platform_data/mtd-nand-omap2.h>\n\n#define\tDRIVER_NAME\t\"omap2-nand\"\n#define\tOMAP_NAND_TIMEOUT_MS\t5000\n\n#define NAND_Ecc_P1e\t\t(1 << 0)\n#define NAND_Ecc_P2e\t\t(1 << 1)\n#define NAND_Ecc_P4e\t\t(1 << 2)\n#define NAND_Ecc_P8e\t\t(1 << 3)\n#define NAND_Ecc_P16e\t\t(1 << 4)\n#define NAND_Ecc_P32e\t\t(1 << 5)\n#define NAND_Ecc_P64e\t\t(1 << 6)\n#define NAND_Ecc_P128e\t\t(1 << 7)\n#define NAND_Ecc_P256e\t\t(1 << 8)\n#define NAND_Ecc_P512e\t\t(1 << 9)\n#define NAND_Ecc_P1024e\t\t(1 << 10)\n#define NAND_Ecc_P2048e\t\t(1 << 11)\n\n#define NAND_Ecc_P1o\t\t(1 << 16)\n#define NAND_Ecc_P2o\t\t(1 << 17)\n#define NAND_Ecc_P4o\t\t(1 << 18)\n#define NAND_Ecc_P8o\t\t(1 << 19)\n#define NAND_Ecc_P16o\t\t(1 << 20)\n#define NAND_Ecc_P32o\t\t(1 << 21)\n#define NAND_Ecc_P64o\t\t(1 << 22)\n#define NAND_Ecc_P128o\t\t(1 << 23)\n#define NAND_Ecc_P256o\t\t(1 << 24)\n#define NAND_Ecc_P512o\t\t(1 << 25)\n#define NAND_Ecc_P1024o\t\t(1 << 26)\n#define NAND_Ecc_P2048o\t\t(1 << 27)\n\n#define TF(value)\t(value ? 1 : 0)\n\n#define P2048e(a)\t(TF(a & NAND_Ecc_P2048e)\t<< 0)\n#define P2048o(a)\t(TF(a & NAND_Ecc_P2048o)\t<< 1)\n#define P1e(a)\t\t(TF(a & NAND_Ecc_P1e)\t\t<< 2)\n#define P1o(a)\t\t(TF(a & NAND_Ecc_P1o)\t\t<< 3)\n#define P2e(a)\t\t(TF(a & NAND_Ecc_P2e)\t\t<< 4)\n#define P2o(a)\t\t(TF(a & NAND_Ecc_P2o)\t\t<< 5)\n#define P4e(a)\t\t(TF(a & NAND_Ecc_P4e)\t\t<< 6)\n#define P4o(a)\t\t(TF(a & NAND_Ecc_P4o)\t\t<< 7)\n\n#define P8e(a)\t\t(TF(a & NAND_Ecc_P8e)\t\t<< 0)\n#define P8o(a)\t\t(TF(a & NAND_Ecc_P8o)\t\t<< 1)\n#define P16e(a)\t\t(TF(a & NAND_Ecc_P16e)\t\t<< 2)\n#define P16o(a)\t\t(TF(a & NAND_Ecc_P16o)\t\t<< 3)\n#define P32e(a)\t\t(TF(a & NAND_Ecc_P32e)\t\t<< 4)\n#define P32o(a)\t\t(TF(a & NAND_Ecc_P32o)\t\t<< 5)\n#define P64e(a)\t\t(TF(a & NAND_Ecc_P64e)\t\t<< 6)\n#define P64o(a)\t\t(TF(a & NAND_Ecc_P64o)\t\t<< 7)\n\n#define P128e(a)\t(TF(a & NAND_Ecc_P128e)\t\t<< 0)\n#define P128o(a)\t(TF(a & NAND_Ecc_P128o)\t\t<< 1)\n#define P256e(a)\t(TF(a & NAND_Ecc_P256e)\t\t<< 2)\n#define P256o(a)\t(TF(a & NAND_Ecc_P256o)\t\t<< 3)\n#define P512e(a)\t(TF(a & NAND_Ecc_P512e)\t\t<< 4)\n#define P512o(a)\t(TF(a & NAND_Ecc_P512o)\t\t<< 5)\n#define P1024e(a)\t(TF(a & NAND_Ecc_P1024e)\t<< 6)\n#define P1024o(a)\t(TF(a & NAND_Ecc_P1024o)\t<< 7)\n\n#define P8e_s(a)\t(TF(a & NAND_Ecc_P8e)\t\t<< 0)\n#define P8o_s(a)\t(TF(a & NAND_Ecc_P8o)\t\t<< 1)\n#define P16e_s(a)\t(TF(a & NAND_Ecc_P16e)\t\t<< 2)\n#define P16o_s(a)\t(TF(a & NAND_Ecc_P16o)\t\t<< 3)\n#define P1e_s(a)\t(TF(a & NAND_Ecc_P1e)\t\t<< 4)\n#define P1o_s(a)\t(TF(a & NAND_Ecc_P1o)\t\t<< 5)\n#define P2e_s(a)\t(TF(a & NAND_Ecc_P2e)\t\t<< 6)\n#define P2o_s(a)\t(TF(a & NAND_Ecc_P2o)\t\t<< 7)\n\n#define P4e_s(a)\t(TF(a & NAND_Ecc_P4e)\t\t<< 0)\n#define P4o_s(a)\t(TF(a & NAND_Ecc_P4o)\t\t<< 1)\n\n#define\tPREFETCH_CONFIG1_CS_SHIFT\t24\n#define\tECC_CONFIG_CS_SHIFT\t\t1\n#define\tCS_MASK\t\t\t\t0x7\n#define\tENABLE_PREFETCH\t\t\t(0x1 << 7)\n#define\tDMA_MPU_MODE_SHIFT\t\t2\n#define\tECCSIZE0_SHIFT\t\t\t12\n#define\tECCSIZE1_SHIFT\t\t\t22\n#define\tECC1RESULTSIZE\t\t\t0x1\n#define\tECCCLEAR\t\t\t0x100\n#define\tECC1\t\t\t\t0x1\n#define\tPREFETCH_FIFOTHRESHOLD_MAX\t0x40\n#define\tPREFETCH_FIFOTHRESHOLD(val)\t((val) << 8)\n#define\tPREFETCH_STATUS_COUNT(val)\t(val & 0x00003fff)\n#define\tPREFETCH_STATUS_FIFO_CNT(val)\t((val >> 24) & 0x7F)\n#define\tSTATUS_BUFF_EMPTY\t\t0x00000001\n\n#define SECTOR_BYTES\t\t512\n \n#define BCH4_BIT_PAD\t\t4\n\n \n#define BCH_WRAPMODE_1\t\t1\t \n#define BCH8R_ECC_SIZE0\t\t0x1a\t \n#define BCH8R_ECC_SIZE1\t\t0x2\t \n#define BCH4R_ECC_SIZE0\t\t0xd\t \n#define BCH4R_ECC_SIZE1\t\t0x3\t \n\n \n#define BCH_WRAPMODE_6\t\t6\t \n#define BCH_ECC_SIZE0\t\t0x0\t \n#define BCH_ECC_SIZE1\t\t0x20\t \n\n#define BBM_LEN\t\t\t2\n\nstatic u_char bch16_vector[] = {0xf5, 0x24, 0x1c, 0xd0, 0x61, 0xb3, 0xf1, 0x55,\n\t\t\t\t0x2e, 0x2c, 0x86, 0xa3, 0xed, 0x36, 0x1b, 0x78,\n\t\t\t\t0x48, 0x76, 0xa9, 0x3b, 0x97, 0xd1, 0x7a, 0x93,\n\t\t\t\t0x07, 0x0e};\nstatic u_char bch8_vector[] = {0xf3, 0xdb, 0x14, 0x16, 0x8b, 0xd2, 0xbe, 0xcc,\n\t0xac, 0x6b, 0xff, 0x99, 0x7b};\nstatic u_char bch4_vector[] = {0x00, 0x6b, 0x31, 0xdd, 0x41, 0xbc, 0x10};\n\nstruct omap_nand_info {\n\tstruct nand_chip\t\tnand;\n\tstruct platform_device\t\t*pdev;\n\n\tint\t\t\t\tgpmc_cs;\n\tbool\t\t\t\tdev_ready;\n\tenum nand_io\t\t\txfer_type;\n\tenum omap_ecc\t\t\tecc_opt;\n\tstruct device_node\t\t*elm_of_node;\n\n\tunsigned long\t\t\tphys_base;\n\tstruct completion\t\tcomp;\n\tstruct dma_chan\t\t\t*dma;\n\tint\t\t\t\tgpmc_irq_fifo;\n\tint\t\t\t\tgpmc_irq_count;\n\tenum {\n\t\tOMAP_NAND_IO_READ = 0,\t \n\t\tOMAP_NAND_IO_WRITE,\t \n\t} iomode;\n\tu_char\t\t\t\t*buf;\n\tint\t\t\t\t\tbuf_len;\n\t \n\tvoid __iomem\t\t\t*fifo;\n\tstruct gpmc_nand_regs\t\treg;\n\tstruct gpmc_nand_ops\t\t*ops;\n\tbool\t\t\t\tflash_bbt;\n\t \n\tstruct device\t\t\t*elm_dev;\n\t \n\tstruct gpio_desc\t\t*ready_gpiod;\n\tunsigned int\t\t\tneccpg;\n\tunsigned int\t\t\tnsteps_per_eccpg;\n\tunsigned int\t\t\teccpg_size;\n\tunsigned int\t\t\teccpg_bytes;\n\tvoid (*data_in)(struct nand_chip *chip, void *buf,\n\t\t\tunsigned int len, bool force_8bit);\n\tvoid (*data_out)(struct nand_chip *chip,\n\t\t\t const void *buf, unsigned int len,\n\t\t\t bool force_8bit);\n};\n\nstatic inline struct omap_nand_info *mtd_to_omap(struct mtd_info *mtd)\n{\n\treturn container_of(mtd_to_nand(mtd), struct omap_nand_info, nand);\n}\n\nstatic void omap_nand_data_in(struct nand_chip *chip, void *buf,\n\t\t\t      unsigned int len, bool force_8bit);\n\nstatic void omap_nand_data_out(struct nand_chip *chip,\n\t\t\t       const void *buf, unsigned int len,\n\t\t\t       bool force_8bit);\n\n \nstatic int omap_prefetch_enable(int cs, int fifo_th, int dma_mode,\n\tunsigned int u32_count, int is_write, struct omap_nand_info *info)\n{\n\tu32 val;\n\n\tif (fifo_th > PREFETCH_FIFOTHRESHOLD_MAX)\n\t\treturn -1;\n\n\tif (readl(info->reg.gpmc_prefetch_control))\n\t\treturn -EBUSY;\n\n\t \n\twritel(u32_count, info->reg.gpmc_prefetch_config2);\n\n\t \n\tval = ((cs << PREFETCH_CONFIG1_CS_SHIFT) |\n\t\tPREFETCH_FIFOTHRESHOLD(fifo_th) | ENABLE_PREFETCH |\n\t\t(dma_mode << DMA_MPU_MODE_SHIFT) | (is_write & 0x1));\n\twritel(val, info->reg.gpmc_prefetch_config1);\n\n\t \n\twritel(0x1, info->reg.gpmc_prefetch_control);\n\n\treturn 0;\n}\n\n \nstatic int omap_prefetch_reset(int cs, struct omap_nand_info *info)\n{\n\tu32 config1;\n\n\t \n\tconfig1 = readl(info->reg.gpmc_prefetch_config1);\n\tif (((config1 >> PREFETCH_CONFIG1_CS_SHIFT) & CS_MASK) != cs)\n\t\treturn -EINVAL;\n\n\t \n\twritel(0x0, info->reg.gpmc_prefetch_control);\n\n\t \n\twritel(0x0, info->reg.gpmc_prefetch_config1);\n\n\treturn 0;\n}\n\n \nstatic void omap_nand_data_in_pref(struct nand_chip *chip, void *buf,\n\t\t\t\t   unsigned int len, bool force_8bit)\n{\n\tstruct omap_nand_info *info = mtd_to_omap(nand_to_mtd(chip));\n\tuint32_t r_count = 0;\n\tint ret = 0;\n\tu32 *p = (u32 *)buf;\n\tunsigned int pref_len;\n\n\tif (force_8bit) {\n\t\tomap_nand_data_in(chip, buf, len, force_8bit);\n\t\treturn;\n\t}\n\n\t \n\n\t \n\tpref_len = len - (len & 3);\n\tret = omap_prefetch_enable(info->gpmc_cs,\n\t\t\tPREFETCH_FIFOTHRESHOLD_MAX, 0x0, pref_len, 0x0, info);\n\tif (ret) {\n\t\t \n\t\tomap_nand_data_in(chip, buf, len, false);\n\t} else {\n\t\tdo {\n\t\t\tr_count = readl(info->reg.gpmc_prefetch_status);\n\t\t\tr_count = PREFETCH_STATUS_FIFO_CNT(r_count);\n\t\t\tr_count = r_count >> 2;\n\t\t\tioread32_rep(info->fifo, p, r_count);\n\t\t\tp += r_count;\n\t\t\tpref_len -= r_count << 2;\n\t\t} while (pref_len);\n\t\t \n\t\tomap_prefetch_reset(info->gpmc_cs, info);\n\t\t \n\t\tif (len & 3)\n\t\t\tomap_nand_data_in(chip, p, len & 3, false);\n\t}\n}\n\n \nstatic void omap_nand_data_out_pref(struct nand_chip *chip,\n\t\t\t\t    const void *buf, unsigned int len,\n\t\t\t\t    bool force_8bit)\n{\n\tstruct omap_nand_info *info = mtd_to_omap(nand_to_mtd(chip));\n\tuint32_t w_count = 0;\n\tint i = 0, ret = 0;\n\tu16 *p = (u16 *)buf;\n\tunsigned long tim, limit;\n\tu32 val;\n\n\tif (force_8bit) {\n\t\tomap_nand_data_out(chip, buf, len, force_8bit);\n\t\treturn;\n\t}\n\n\t \n\tif (len % 2 != 0) {\n\t\twriteb(*(u8 *)buf, info->fifo);\n\t\tp = (u16 *)(buf + 1);\n\t\tlen--;\n\t}\n\n\t \n\tret = omap_prefetch_enable(info->gpmc_cs,\n\t\t\tPREFETCH_FIFOTHRESHOLD_MAX, 0x0, len, 0x1, info);\n\tif (ret) {\n\t\t \n\t\tomap_nand_data_out(chip, buf, len, false);\n\t} else {\n\t\twhile (len) {\n\t\t\tw_count = readl(info->reg.gpmc_prefetch_status);\n\t\t\tw_count = PREFETCH_STATUS_FIFO_CNT(w_count);\n\t\t\tw_count = w_count >> 1;\n\t\t\tfor (i = 0; (i < w_count) && len; i++, len -= 2)\n\t\t\t\tiowrite16(*p++, info->fifo);\n\t\t}\n\t\t \n\t\ttim = 0;\n\t\tlimit = (loops_per_jiffy *\n\t\t\t\t\tmsecs_to_jiffies(OMAP_NAND_TIMEOUT_MS));\n\t\tdo {\n\t\t\tcpu_relax();\n\t\t\tval = readl(info->reg.gpmc_prefetch_status);\n\t\t\tval = PREFETCH_STATUS_COUNT(val);\n\t\t} while (val && (tim++ < limit));\n\n\t\t \n\t\tomap_prefetch_reset(info->gpmc_cs, info);\n\t}\n}\n\n \nstatic void omap_nand_dma_callback(void *data)\n{\n\tcomplete((struct completion *) data);\n}\n\n \nstatic inline int omap_nand_dma_transfer(struct nand_chip *chip,\n\t\t\t\t\t const void *addr, unsigned int len,\n\t\t\t\t\t int is_write)\n{\n\tstruct omap_nand_info *info = mtd_to_omap(nand_to_mtd(chip));\n\tstruct dma_async_tx_descriptor *tx;\n\tenum dma_data_direction dir = is_write ? DMA_TO_DEVICE :\n\t\t\t\t\t\t\tDMA_FROM_DEVICE;\n\tstruct scatterlist sg;\n\tunsigned long tim, limit;\n\tunsigned n;\n\tint ret;\n\tu32 val;\n\n\tif (!virt_addr_valid(addr))\n\t\tgoto out_copy;\n\n\tsg_init_one(&sg, addr, len);\n\tn = dma_map_sg(info->dma->device->dev, &sg, 1, dir);\n\tif (n == 0) {\n\t\tdev_err(&info->pdev->dev,\n\t\t\t\"Couldn't DMA map a %d byte buffer\\n\", len);\n\t\tgoto out_copy;\n\t}\n\n\ttx = dmaengine_prep_slave_sg(info->dma, &sg, n,\n\t\tis_write ? DMA_MEM_TO_DEV : DMA_DEV_TO_MEM,\n\t\tDMA_PREP_INTERRUPT | DMA_CTRL_ACK);\n\tif (!tx)\n\t\tgoto out_copy_unmap;\n\n\ttx->callback = omap_nand_dma_callback;\n\ttx->callback_param = &info->comp;\n\tdmaengine_submit(tx);\n\n\tinit_completion(&info->comp);\n\n\t \n\tdma_async_issue_pending(info->dma);\n\n\t \n\tret = omap_prefetch_enable(info->gpmc_cs,\n\t\tPREFETCH_FIFOTHRESHOLD_MAX, 0x1, len, is_write, info);\n\tif (ret)\n\t\t \n\t\tgoto out_copy_unmap;\n\n\twait_for_completion(&info->comp);\n\ttim = 0;\n\tlimit = (loops_per_jiffy * msecs_to_jiffies(OMAP_NAND_TIMEOUT_MS));\n\n\tdo {\n\t\tcpu_relax();\n\t\tval = readl(info->reg.gpmc_prefetch_status);\n\t\tval = PREFETCH_STATUS_COUNT(val);\n\t} while (val && (tim++ < limit));\n\n\t \n\tomap_prefetch_reset(info->gpmc_cs, info);\n\n\tdma_unmap_sg(info->dma->device->dev, &sg, 1, dir);\n\treturn 0;\n\nout_copy_unmap:\n\tdma_unmap_sg(info->dma->device->dev, &sg, 1, dir);\nout_copy:\n\tis_write == 0 ? omap_nand_data_in(chip, (void *)addr, len, false)\n\t\t      : omap_nand_data_out(chip, addr, len, false);\n\n\treturn 0;\n}\n\n \nstatic void omap_nand_data_in_dma_pref(struct nand_chip *chip, void *buf,\n\t\t\t\t       unsigned int len, bool force_8bit)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\n\tif (force_8bit) {\n\t\tomap_nand_data_in(chip, buf, len, force_8bit);\n\t\treturn;\n\t}\n\n\tif (len <= mtd->oobsize)\n\t\tomap_nand_data_in_pref(chip, buf, len, false);\n\telse\n\t\t \n\t\tomap_nand_dma_transfer(chip, buf, len, 0x0);\n}\n\n \nstatic void omap_nand_data_out_dma_pref(struct nand_chip *chip,\n\t\t\t\t\tconst void *buf, unsigned int len,\n\t\t\t\t\tbool force_8bit)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\n\tif (force_8bit) {\n\t\tomap_nand_data_out(chip, buf, len, force_8bit);\n\t\treturn;\n\t}\n\n\tif (len <= mtd->oobsize)\n\t\tomap_nand_data_out_pref(chip, buf, len, false);\n\telse\n\t\t \n\t\tomap_nand_dma_transfer(chip, buf, len, 0x1);\n}\n\n \nstatic irqreturn_t omap_nand_irq(int this_irq, void *dev)\n{\n\tstruct omap_nand_info *info = (struct omap_nand_info *) dev;\n\tu32 bytes;\n\n\tbytes = readl(info->reg.gpmc_prefetch_status);\n\tbytes = PREFETCH_STATUS_FIFO_CNT(bytes);\n\tbytes = bytes  & 0xFFFC;  \n\tif (info->iomode == OMAP_NAND_IO_WRITE) {  \n\t\tif (this_irq == info->gpmc_irq_count)\n\t\t\tgoto done;\n\n\t\tif (info->buf_len && (info->buf_len < bytes))\n\t\t\tbytes = info->buf_len;\n\t\telse if (!info->buf_len)\n\t\t\tbytes = 0;\n\t\tiowrite32_rep(info->fifo, (u32 *)info->buf,\n\t\t\t      bytes >> 2);\n\t\tinfo->buf = info->buf + bytes;\n\t\tinfo->buf_len -= bytes;\n\n\t} else {\n\t\tioread32_rep(info->fifo, (u32 *)info->buf,\n\t\t\t     bytes >> 2);\n\t\tinfo->buf = info->buf + bytes;\n\n\t\tif (this_irq == info->gpmc_irq_count)\n\t\t\tgoto done;\n\t}\n\n\treturn IRQ_HANDLED;\n\ndone:\n\tcomplete(&info->comp);\n\n\tdisable_irq_nosync(info->gpmc_irq_fifo);\n\tdisable_irq_nosync(info->gpmc_irq_count);\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic void omap_nand_data_in_irq_pref(struct nand_chip *chip, void *buf,\n\t\t\t\t       unsigned int len, bool force_8bit)\n{\n\tstruct omap_nand_info *info = mtd_to_omap(nand_to_mtd(chip));\n\tstruct mtd_info *mtd = nand_to_mtd(&info->nand);\n\tint ret = 0;\n\n\tif (len <= mtd->oobsize || force_8bit) {\n\t\tomap_nand_data_in(chip, buf, len, force_8bit);\n\t\treturn;\n\t}\n\n\tinfo->iomode = OMAP_NAND_IO_READ;\n\tinfo->buf = buf;\n\tinit_completion(&info->comp);\n\n\t \n\tret = omap_prefetch_enable(info->gpmc_cs,\n\t\t\tPREFETCH_FIFOTHRESHOLD_MAX/2, 0x0, len, 0x0, info);\n\tif (ret) {\n\t\t \n\t\tomap_nand_data_in(chip, buf, len, false);\n\t\treturn;\n\t}\n\n\tinfo->buf_len = len;\n\n\tenable_irq(info->gpmc_irq_count);\n\tenable_irq(info->gpmc_irq_fifo);\n\n\t \n\twait_for_completion(&info->comp);\n\n\t \n\tomap_prefetch_reset(info->gpmc_cs, info);\n\treturn;\n}\n\n \nstatic void omap_nand_data_out_irq_pref(struct nand_chip *chip,\n\t\t\t\t\tconst void *buf, unsigned int len,\n\t\t\t\t\tbool force_8bit)\n{\n\tstruct omap_nand_info *info = mtd_to_omap(nand_to_mtd(chip));\n\tstruct mtd_info *mtd = nand_to_mtd(&info->nand);\n\tint ret = 0;\n\tunsigned long tim, limit;\n\tu32 val;\n\n\tif (len <= mtd->oobsize || force_8bit) {\n\t\tomap_nand_data_out(chip, buf, len, force_8bit);\n\t\treturn;\n\t}\n\n\tinfo->iomode = OMAP_NAND_IO_WRITE;\n\tinfo->buf = (u_char *) buf;\n\tinit_completion(&info->comp);\n\n\t \n\tret = omap_prefetch_enable(info->gpmc_cs,\n\t\t(PREFETCH_FIFOTHRESHOLD_MAX * 3) / 8, 0x0, len, 0x1, info);\n\tif (ret) {\n\t\t \n\t\tomap_nand_data_out(chip, buf, len, false);\n\t\treturn;\n\t}\n\n\tinfo->buf_len = len;\n\n\tenable_irq(info->gpmc_irq_count);\n\tenable_irq(info->gpmc_irq_fifo);\n\n\t \n\twait_for_completion(&info->comp);\n\n\t \n\ttim = 0;\n\tlimit = (loops_per_jiffy *  msecs_to_jiffies(OMAP_NAND_TIMEOUT_MS));\n\tdo {\n\t\tval = readl(info->reg.gpmc_prefetch_status);\n\t\tval = PREFETCH_STATUS_COUNT(val);\n\t\tcpu_relax();\n\t} while (val && (tim++ < limit));\n\n\t \n\tomap_prefetch_reset(info->gpmc_cs, info);\n\treturn;\n}\n\n \nstatic void gen_true_ecc(u8 *ecc_buf)\n{\n\tu32 tmp = ecc_buf[0] | (ecc_buf[1] << 16) |\n\t\t((ecc_buf[2] & 0xF0) << 20) | ((ecc_buf[2] & 0x0F) << 8);\n\n\tecc_buf[0] = ~(P64o(tmp) | P64e(tmp) | P32o(tmp) | P32e(tmp) |\n\t\t\tP16o(tmp) | P16e(tmp) | P8o(tmp) | P8e(tmp));\n\tecc_buf[1] = ~(P1024o(tmp) | P1024e(tmp) | P512o(tmp) | P512e(tmp) |\n\t\t\tP256o(tmp) | P256e(tmp) | P128o(tmp) | P128e(tmp));\n\tecc_buf[2] = ~(P4o(tmp) | P4e(tmp) | P2o(tmp) | P2e(tmp) | P1o(tmp) |\n\t\t\tP1e(tmp) | P2048o(tmp) | P2048e(tmp));\n}\n\n \nstatic int omap_compare_ecc(u8 *ecc_data1,\t \n\t\t\t    u8 *ecc_data2,\t \n\t\t\t    u8 *page_data)\n{\n\tuint\ti;\n\tu8\ttmp0_bit[8], tmp1_bit[8], tmp2_bit[8];\n\tu8\tcomp0_bit[8], comp1_bit[8], comp2_bit[8];\n\tu8\tecc_bit[24];\n\tu8\tecc_sum = 0;\n\tu8\tfind_bit = 0;\n\tuint\tfind_byte = 0;\n\tint\tisEccFF;\n\n\tisEccFF = ((*(u32 *)ecc_data1 & 0xFFFFFF) == 0xFFFFFF);\n\n\tgen_true_ecc(ecc_data1);\n\tgen_true_ecc(ecc_data2);\n\n\tfor (i = 0; i <= 2; i++) {\n\t\t*(ecc_data1 + i) = ~(*(ecc_data1 + i));\n\t\t*(ecc_data2 + i) = ~(*(ecc_data2 + i));\n\t}\n\n\tfor (i = 0; i < 8; i++) {\n\t\ttmp0_bit[i]     = *ecc_data1 % 2;\n\t\t*ecc_data1\t= *ecc_data1 / 2;\n\t}\n\n\tfor (i = 0; i < 8; i++) {\n\t\ttmp1_bit[i]\t = *(ecc_data1 + 1) % 2;\n\t\t*(ecc_data1 + 1) = *(ecc_data1 + 1) / 2;\n\t}\n\n\tfor (i = 0; i < 8; i++) {\n\t\ttmp2_bit[i]\t = *(ecc_data1 + 2) % 2;\n\t\t*(ecc_data1 + 2) = *(ecc_data1 + 2) / 2;\n\t}\n\n\tfor (i = 0; i < 8; i++) {\n\t\tcomp0_bit[i]     = *ecc_data2 % 2;\n\t\t*ecc_data2       = *ecc_data2 / 2;\n\t}\n\n\tfor (i = 0; i < 8; i++) {\n\t\tcomp1_bit[i]     = *(ecc_data2 + 1) % 2;\n\t\t*(ecc_data2 + 1) = *(ecc_data2 + 1) / 2;\n\t}\n\n\tfor (i = 0; i < 8; i++) {\n\t\tcomp2_bit[i]     = *(ecc_data2 + 2) % 2;\n\t\t*(ecc_data2 + 2) = *(ecc_data2 + 2) / 2;\n\t}\n\n\tfor (i = 0; i < 6; i++)\n\t\tecc_bit[i] = tmp2_bit[i + 2] ^ comp2_bit[i + 2];\n\n\tfor (i = 0; i < 8; i++)\n\t\tecc_bit[i + 6] = tmp0_bit[i] ^ comp0_bit[i];\n\n\tfor (i = 0; i < 8; i++)\n\t\tecc_bit[i + 14] = tmp1_bit[i] ^ comp1_bit[i];\n\n\tecc_bit[22] = tmp2_bit[0] ^ comp2_bit[0];\n\tecc_bit[23] = tmp2_bit[1] ^ comp2_bit[1];\n\n\tfor (i = 0; i < 24; i++)\n\t\tecc_sum += ecc_bit[i];\n\n\tswitch (ecc_sum) {\n\tcase 0:\n\t\t \n\t\treturn 0;\n\n\tcase 1:\n\t\t \n\t\tpr_debug(\"ECC UNCORRECTED_ERROR 1\\n\");\n\t\treturn -EBADMSG;\n\n\tcase 11:\n\t\t \n\t\tpr_debug(\"ECC UNCORRECTED_ERROR B\\n\");\n\t\treturn -EBADMSG;\n\n\tcase 12:\n\t\t \n\t\tfind_byte = (ecc_bit[23] << 8) +\n\t\t\t    (ecc_bit[21] << 7) +\n\t\t\t    (ecc_bit[19] << 6) +\n\t\t\t    (ecc_bit[17] << 5) +\n\t\t\t    (ecc_bit[15] << 4) +\n\t\t\t    (ecc_bit[13] << 3) +\n\t\t\t    (ecc_bit[11] << 2) +\n\t\t\t    (ecc_bit[9]  << 1) +\n\t\t\t    ecc_bit[7];\n\n\t\tfind_bit = (ecc_bit[5] << 2) + (ecc_bit[3] << 1) + ecc_bit[1];\n\n\t\tpr_debug(\"Correcting single bit ECC error at offset: \"\n\t\t\t\t\"%d, bit: %d\\n\", find_byte, find_bit);\n\n\t\tpage_data[find_byte] ^= (1 << find_bit);\n\n\t\treturn 1;\n\tdefault:\n\t\tif (isEccFF) {\n\t\t\tif (ecc_data2[0] == 0 &&\n\t\t\t    ecc_data2[1] == 0 &&\n\t\t\t    ecc_data2[2] == 0)\n\t\t\t\treturn 0;\n\t\t}\n\t\tpr_debug(\"UNCORRECTED_ERROR default\\n\");\n\t\treturn -EBADMSG;\n\t}\n}\n\n \nstatic int omap_correct_data(struct nand_chip *chip, u_char *dat,\n\t\t\t     u_char *read_ecc, u_char *calc_ecc)\n{\n\tstruct omap_nand_info *info = mtd_to_omap(nand_to_mtd(chip));\n\tint blockCnt = 0, i = 0, ret = 0;\n\tint stat = 0;\n\n\t \n\tif (info->nand.ecc.engine_type == NAND_ECC_ENGINE_TYPE_ON_HOST &&\n\t    info->nand.ecc.size == 2048)\n\t\tblockCnt = 4;\n\telse\n\t\tblockCnt = 1;\n\n\tfor (i = 0; i < blockCnt; i++) {\n\t\tif (memcmp(read_ecc, calc_ecc, 3) != 0) {\n\t\t\tret = omap_compare_ecc(read_ecc, calc_ecc, dat);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\t \n\t\t\tstat += ret;\n\t\t}\n\t\tread_ecc += 3;\n\t\tcalc_ecc += 3;\n\t\tdat      += 512;\n\t}\n\treturn stat;\n}\n\n \nstatic int omap_calculate_ecc(struct nand_chip *chip, const u_char *dat,\n\t\t\t      u_char *ecc_code)\n{\n\tstruct omap_nand_info *info = mtd_to_omap(nand_to_mtd(chip));\n\tu32 val;\n\n\tval = readl(info->reg.gpmc_ecc_config);\n\tif (((val >> ECC_CONFIG_CS_SHIFT) & CS_MASK) != info->gpmc_cs)\n\t\treturn -EINVAL;\n\n\t \n\tval = readl(info->reg.gpmc_ecc1_result);\n\t*ecc_code++ = val;           \n\t*ecc_code++ = val >> 16;     \n\t \n\t*ecc_code++ = ((val >> 8) & 0x0f) | ((val >> 20) & 0xf0);\n\n\treturn 0;\n}\n\n \nstatic void omap_enable_hwecc(struct nand_chip *chip, int mode)\n{\n\tstruct omap_nand_info *info = mtd_to_omap(nand_to_mtd(chip));\n\tunsigned int dev_width = (chip->options & NAND_BUSWIDTH_16) ? 1 : 0;\n\tu32 val;\n\n\t \n\tval = ECCCLEAR | ECC1;\n\twritel(val, info->reg.gpmc_ecc_control);\n\n\t \n\tval = ((((info->nand.ecc.size >> 1) - 1) << ECCSIZE1_SHIFT) |\n\t\t\t ECC1RESULTSIZE);\n\twritel(val, info->reg.gpmc_ecc_size_config);\n\n\tswitch (mode) {\n\tcase NAND_ECC_READ:\n\tcase NAND_ECC_WRITE:\n\t\twritel(ECCCLEAR | ECC1, info->reg.gpmc_ecc_control);\n\t\tbreak;\n\tcase NAND_ECC_READSYN:\n\t\twritel(ECCCLEAR, info->reg.gpmc_ecc_control);\n\t\tbreak;\n\tdefault:\n\t\tdev_info(&info->pdev->dev,\n\t\t\t\"error: unrecognized Mode[%d]!\\n\", mode);\n\t\tbreak;\n\t}\n\n\t \n\tval = (dev_width << 7) | (info->gpmc_cs << 1) | (0x1);\n\twritel(val, info->reg.gpmc_ecc_config);\n}\n\n \nstatic void __maybe_unused omap_enable_hwecc_bch(struct nand_chip *chip,\n\t\t\t\t\t\t int mode)\n{\n\tunsigned int bch_type;\n\tunsigned int dev_width, nsectors;\n\tstruct omap_nand_info *info = mtd_to_omap(nand_to_mtd(chip));\n\tenum omap_ecc ecc_opt = info->ecc_opt;\n\tu32 val, wr_mode;\n\tunsigned int ecc_size1, ecc_size0;\n\n\t \n\tswitch (ecc_opt) {\n\tcase OMAP_ECC_BCH4_CODE_HW_DETECTION_SW:\n\t\tbch_type = 0;\n\t\tnsectors = 1;\n\t\twr_mode\t  = BCH_WRAPMODE_6;\n\t\tecc_size0 = BCH_ECC_SIZE0;\n\t\tecc_size1 = BCH_ECC_SIZE1;\n\t\tbreak;\n\tcase OMAP_ECC_BCH4_CODE_HW:\n\t\tbch_type = 0;\n\t\tnsectors = chip->ecc.steps;\n\t\tif (mode == NAND_ECC_READ) {\n\t\t\twr_mode\t  = BCH_WRAPMODE_1;\n\t\t\tecc_size0 = BCH4R_ECC_SIZE0;\n\t\t\tecc_size1 = BCH4R_ECC_SIZE1;\n\t\t} else {\n\t\t\twr_mode   = BCH_WRAPMODE_6;\n\t\t\tecc_size0 = BCH_ECC_SIZE0;\n\t\t\tecc_size1 = BCH_ECC_SIZE1;\n\t\t}\n\t\tbreak;\n\tcase OMAP_ECC_BCH8_CODE_HW_DETECTION_SW:\n\t\tbch_type = 1;\n\t\tnsectors = 1;\n\t\twr_mode\t  = BCH_WRAPMODE_6;\n\t\tecc_size0 = BCH_ECC_SIZE0;\n\t\tecc_size1 = BCH_ECC_SIZE1;\n\t\tbreak;\n\tcase OMAP_ECC_BCH8_CODE_HW:\n\t\tbch_type = 1;\n\t\tnsectors = chip->ecc.steps;\n\t\tif (mode == NAND_ECC_READ) {\n\t\t\twr_mode\t  = BCH_WRAPMODE_1;\n\t\t\tecc_size0 = BCH8R_ECC_SIZE0;\n\t\t\tecc_size1 = BCH8R_ECC_SIZE1;\n\t\t} else {\n\t\t\twr_mode   = BCH_WRAPMODE_6;\n\t\t\tecc_size0 = BCH_ECC_SIZE0;\n\t\t\tecc_size1 = BCH_ECC_SIZE1;\n\t\t}\n\t\tbreak;\n\tcase OMAP_ECC_BCH16_CODE_HW:\n\t\tbch_type = 0x2;\n\t\tnsectors = chip->ecc.steps;\n\t\tif (mode == NAND_ECC_READ) {\n\t\t\twr_mode\t  = 0x01;\n\t\t\tecc_size0 = 52;  \n\t\t\tecc_size1 = 0;   \n\t\t} else {\n\t\t\twr_mode\t  = 0x01;\n\t\t\tecc_size0 = 0;   \n\t\t\tecc_size1 = 52;  \n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\twritel(ECC1, info->reg.gpmc_ecc_control);\n\n\t \n\tval = (ecc_size1 << ECCSIZE1_SHIFT) | (ecc_size0 << ECCSIZE0_SHIFT);\n\twritel(val, info->reg.gpmc_ecc_size_config);\n\n\tdev_width = (chip->options & NAND_BUSWIDTH_16) ? 1 : 0;\n\n\t \n\tval = ((1                        << 16) |  \n\t       (bch_type\t\t << 12) |  \n\t       (wr_mode                  <<  8) |  \n\t       (dev_width                <<  7) |  \n\t       (((nsectors-1) & 0x7)     <<  4) |  \n\t       (info->gpmc_cs            <<  1) |  \n\t       (0x1));                             \n\n\twritel(val, info->reg.gpmc_ecc_config);\n\n\t \n\twritel(ECCCLEAR | ECC1, info->reg.gpmc_ecc_control);\n}\n\nstatic u8  bch4_polynomial[] = {0x28, 0x13, 0xcc, 0x39, 0x96, 0xac, 0x7f};\nstatic u8  bch8_polynomial[] = {0xef, 0x51, 0x2e, 0x09, 0xed, 0x93, 0x9a, 0xc2,\n\t\t\t\t0x97, 0x79, 0xe5, 0x24, 0xb5};\n\n \nstatic int _omap_calculate_ecc_bch(struct mtd_info *mtd,\n\t\t\t\t   const u_char *dat, u_char *ecc_calc, int i)\n{\n\tstruct omap_nand_info *info = mtd_to_omap(mtd);\n\tint eccbytes\t= info->nand.ecc.bytes;\n\tstruct gpmc_nand_regs\t*gpmc_regs = &info->reg;\n\tu8 *ecc_code;\n\tunsigned long bch_val1, bch_val2, bch_val3, bch_val4;\n\tu32 val;\n\tint j;\n\n\tecc_code = ecc_calc;\n\tswitch (info->ecc_opt) {\n\tcase OMAP_ECC_BCH8_CODE_HW_DETECTION_SW:\n\tcase OMAP_ECC_BCH8_CODE_HW:\n\t\tbch_val1 = readl(gpmc_regs->gpmc_bch_result0[i]);\n\t\tbch_val2 = readl(gpmc_regs->gpmc_bch_result1[i]);\n\t\tbch_val3 = readl(gpmc_regs->gpmc_bch_result2[i]);\n\t\tbch_val4 = readl(gpmc_regs->gpmc_bch_result3[i]);\n\t\t*ecc_code++ = (bch_val4 & 0xFF);\n\t\t*ecc_code++ = ((bch_val3 >> 24) & 0xFF);\n\t\t*ecc_code++ = ((bch_val3 >> 16) & 0xFF);\n\t\t*ecc_code++ = ((bch_val3 >> 8) & 0xFF);\n\t\t*ecc_code++ = (bch_val3 & 0xFF);\n\t\t*ecc_code++ = ((bch_val2 >> 24) & 0xFF);\n\t\t*ecc_code++ = ((bch_val2 >> 16) & 0xFF);\n\t\t*ecc_code++ = ((bch_val2 >> 8) & 0xFF);\n\t\t*ecc_code++ = (bch_val2 & 0xFF);\n\t\t*ecc_code++ = ((bch_val1 >> 24) & 0xFF);\n\t\t*ecc_code++ = ((bch_val1 >> 16) & 0xFF);\n\t\t*ecc_code++ = ((bch_val1 >> 8) & 0xFF);\n\t\t*ecc_code++ = (bch_val1 & 0xFF);\n\t\tbreak;\n\tcase OMAP_ECC_BCH4_CODE_HW_DETECTION_SW:\n\tcase OMAP_ECC_BCH4_CODE_HW:\n\t\tbch_val1 = readl(gpmc_regs->gpmc_bch_result0[i]);\n\t\tbch_val2 = readl(gpmc_regs->gpmc_bch_result1[i]);\n\t\t*ecc_code++ = ((bch_val2 >> 12) & 0xFF);\n\t\t*ecc_code++ = ((bch_val2 >> 4) & 0xFF);\n\t\t*ecc_code++ = ((bch_val2 & 0xF) << 4) |\n\t\t\t((bch_val1 >> 28) & 0xF);\n\t\t*ecc_code++ = ((bch_val1 >> 20) & 0xFF);\n\t\t*ecc_code++ = ((bch_val1 >> 12) & 0xFF);\n\t\t*ecc_code++ = ((bch_val1 >> 4) & 0xFF);\n\t\t*ecc_code++ = ((bch_val1 & 0xF) << 4);\n\t\tbreak;\n\tcase OMAP_ECC_BCH16_CODE_HW:\n\t\tval = readl(gpmc_regs->gpmc_bch_result6[i]);\n\t\tecc_code[0]  = ((val >>  8) & 0xFF);\n\t\tecc_code[1]  = ((val >>  0) & 0xFF);\n\t\tval = readl(gpmc_regs->gpmc_bch_result5[i]);\n\t\tecc_code[2]  = ((val >> 24) & 0xFF);\n\t\tecc_code[3]  = ((val >> 16) & 0xFF);\n\t\tecc_code[4]  = ((val >>  8) & 0xFF);\n\t\tecc_code[5]  = ((val >>  0) & 0xFF);\n\t\tval = readl(gpmc_regs->gpmc_bch_result4[i]);\n\t\tecc_code[6]  = ((val >> 24) & 0xFF);\n\t\tecc_code[7]  = ((val >> 16) & 0xFF);\n\t\tecc_code[8]  = ((val >>  8) & 0xFF);\n\t\tecc_code[9]  = ((val >>  0) & 0xFF);\n\t\tval = readl(gpmc_regs->gpmc_bch_result3[i]);\n\t\tecc_code[10] = ((val >> 24) & 0xFF);\n\t\tecc_code[11] = ((val >> 16) & 0xFF);\n\t\tecc_code[12] = ((val >>  8) & 0xFF);\n\t\tecc_code[13] = ((val >>  0) & 0xFF);\n\t\tval = readl(gpmc_regs->gpmc_bch_result2[i]);\n\t\tecc_code[14] = ((val >> 24) & 0xFF);\n\t\tecc_code[15] = ((val >> 16) & 0xFF);\n\t\tecc_code[16] = ((val >>  8) & 0xFF);\n\t\tecc_code[17] = ((val >>  0) & 0xFF);\n\t\tval = readl(gpmc_regs->gpmc_bch_result1[i]);\n\t\tecc_code[18] = ((val >> 24) & 0xFF);\n\t\tecc_code[19] = ((val >> 16) & 0xFF);\n\t\tecc_code[20] = ((val >>  8) & 0xFF);\n\t\tecc_code[21] = ((val >>  0) & 0xFF);\n\t\tval = readl(gpmc_regs->gpmc_bch_result0[i]);\n\t\tecc_code[22] = ((val >> 24) & 0xFF);\n\t\tecc_code[23] = ((val >> 16) & 0xFF);\n\t\tecc_code[24] = ((val >>  8) & 0xFF);\n\t\tecc_code[25] = ((val >>  0) & 0xFF);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tswitch (info->ecc_opt) {\n\tcase OMAP_ECC_BCH4_CODE_HW_DETECTION_SW:\n\t\t \n\t\tfor (j = 0; j < eccbytes; j++)\n\t\t\tecc_calc[j] ^= bch4_polynomial[j];\n\t\tbreak;\n\tcase OMAP_ECC_BCH4_CODE_HW:\n\t\t \n\t\tecc_calc[eccbytes - 1] = 0x0;\n\t\tbreak;\n\tcase OMAP_ECC_BCH8_CODE_HW_DETECTION_SW:\n\t\t \n\t\tfor (j = 0; j < eccbytes; j++)\n\t\t\tecc_calc[j] ^= bch8_polynomial[j];\n\t\tbreak;\n\tcase OMAP_ECC_BCH8_CODE_HW:\n\t\t \n\t\tecc_calc[eccbytes - 1] = 0x0;\n\t\tbreak;\n\tcase OMAP_ECC_BCH16_CODE_HW:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int omap_calculate_ecc_bch_sw(struct nand_chip *chip,\n\t\t\t\t     const u_char *dat, u_char *ecc_calc)\n{\n\treturn _omap_calculate_ecc_bch(nand_to_mtd(chip), dat, ecc_calc, 0);\n}\n\n \nstatic int omap_calculate_ecc_bch_multi(struct mtd_info *mtd,\n\t\t\t\t\tconst u_char *dat, u_char *ecc_calc)\n{\n\tstruct omap_nand_info *info = mtd_to_omap(mtd);\n\tint eccbytes = info->nand.ecc.bytes;\n\tunsigned long nsectors;\n\tint i, ret;\n\n\tnsectors = ((readl(info->reg.gpmc_ecc_config) >> 4) & 0x7) + 1;\n\tfor (i = 0; i < nsectors; i++) {\n\t\tret = _omap_calculate_ecc_bch(mtd, dat, ecc_calc, i);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tecc_calc += eccbytes;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int erased_sector_bitflips(u_char *data, u_char *oob,\n\t\tstruct omap_nand_info *info)\n{\n\tint flip_bits = 0, i;\n\n\tfor (i = 0; i < info->nand.ecc.size; i++) {\n\t\tflip_bits += hweight8(~data[i]);\n\t\tif (flip_bits > info->nand.ecc.strength)\n\t\t\treturn 0;\n\t}\n\n\tfor (i = 0; i < info->nand.ecc.bytes - 1; i++) {\n\t\tflip_bits += hweight8(~oob[i]);\n\t\tif (flip_bits > info->nand.ecc.strength)\n\t\t\treturn 0;\n\t}\n\n\t \n\tif (flip_bits) {\n\t\tmemset(data, 0xFF, info->nand.ecc.size);\n\t\tmemset(oob, 0xFF, info->nand.ecc.bytes);\n\t}\n\n\treturn flip_bits;\n}\n\n \nstatic int omap_elm_correct_data(struct nand_chip *chip, u_char *data,\n\t\t\t\t u_char *read_ecc, u_char *calc_ecc)\n{\n\tstruct omap_nand_info *info = mtd_to_omap(nand_to_mtd(chip));\n\tstruct nand_ecc_ctrl *ecc = &info->nand.ecc;\n\tint eccsteps = info->nsteps_per_eccpg;\n\tint i , j, stat = 0;\n\tint eccflag, actual_eccbytes;\n\tstruct elm_errorvec err_vec[ERROR_VECTOR_MAX];\n\tu_char *ecc_vec = calc_ecc;\n\tu_char *spare_ecc = read_ecc;\n\tu_char *erased_ecc_vec;\n\tu_char *buf;\n\tint bitflip_count;\n\tbool is_error_reported = false;\n\tu32 bit_pos, byte_pos, error_max, pos;\n\tint err;\n\n\tswitch (info->ecc_opt) {\n\tcase OMAP_ECC_BCH4_CODE_HW:\n\t\t \n\t\tactual_eccbytes = ecc->bytes - 1;\n\t\terased_ecc_vec = bch4_vector;\n\t\tbreak;\n\tcase OMAP_ECC_BCH8_CODE_HW:\n\t\t \n\t\tactual_eccbytes = ecc->bytes - 1;\n\t\terased_ecc_vec = bch8_vector;\n\t\tbreak;\n\tcase OMAP_ECC_BCH16_CODE_HW:\n\t\tactual_eccbytes = ecc->bytes;\n\t\terased_ecc_vec = bch16_vector;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&info->pdev->dev, \"invalid driver configuration\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tmemset(err_vec, 0, sizeof(err_vec));\n\n\tfor (i = 0; i < eccsteps ; i++) {\n\t\teccflag = 0;\t \n\n\t\t \n\t\tfor (j = 0; j < actual_eccbytes; j++) {\n\t\t\tif (calc_ecc[j] != 0) {\n\t\t\t\teccflag = 1;  \n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (eccflag == 1) {\n\t\t\tif (memcmp(calc_ecc, erased_ecc_vec,\n\t\t\t\t\t\tactual_eccbytes) == 0) {\n\t\t\t\t \n\t\t\t} else {\n\t\t\t\tbuf = &data[info->nand.ecc.size * i];\n\t\t\t\t \n\t\t\t\tbitflip_count = erased_sector_bitflips(\n\t\t\t\t\t\tbuf, read_ecc, info);\n\t\t\t\tif (bitflip_count) {\n\t\t\t\t\t \n\t\t\t\t\tstat += bitflip_count;\n\t\t\t\t} else {\n\t\t\t\t\t \n\t\t\t\t\terr_vec[i].error_reported = true;\n\t\t\t\t\tis_error_reported = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tcalc_ecc += ecc->bytes;\n\t\tread_ecc += ecc->bytes;\n\t}\n\n\t \n\tif (!is_error_reported)\n\t\treturn stat;\n\n\t \n\telm_decode_bch_error_page(info->elm_dev, ecc_vec, err_vec);\n\n\terr = 0;\n\tfor (i = 0; i < eccsteps; i++) {\n\t\tif (err_vec[i].error_uncorrectable) {\n\t\t\tdev_err(&info->pdev->dev,\n\t\t\t\t\"uncorrectable bit-flips found\\n\");\n\t\t\terr = -EBADMSG;\n\t\t} else if (err_vec[i].error_reported) {\n\t\t\tfor (j = 0; j < err_vec[i].error_count; j++) {\n\t\t\t\tswitch (info->ecc_opt) {\n\t\t\t\tcase OMAP_ECC_BCH4_CODE_HW:\n\t\t\t\t\t \n\t\t\t\t\tpos = err_vec[i].error_loc[j] +\n\t\t\t\t\t\tBCH4_BIT_PAD;\n\t\t\t\t\tbreak;\n\t\t\t\tcase OMAP_ECC_BCH8_CODE_HW:\n\t\t\t\tcase OMAP_ECC_BCH16_CODE_HW:\n\t\t\t\t\tpos = err_vec[i].error_loc[j];\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\t\t\t\terror_max = (ecc->size + actual_eccbytes) * 8;\n\t\t\t\t \n\t\t\t\tbit_pos = pos % 8;\n\n\t\t\t\t \n\t\t\t\tbyte_pos = (error_max - pos - 1) / 8;\n\n\t\t\t\tif (pos < error_max) {\n\t\t\t\t\tif (byte_pos < 512) {\n\t\t\t\t\t\tpr_debug(\"bitflip@dat[%d]=%x\\n\",\n\t\t\t\t\t\t     byte_pos, data[byte_pos]);\n\t\t\t\t\t\tdata[byte_pos] ^= 1 << bit_pos;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpr_debug(\"bitflip@oob[%d]=%x\\n\",\n\t\t\t\t\t\t\t(byte_pos - 512),\n\t\t\t\t\t\t     spare_ecc[byte_pos - 512]);\n\t\t\t\t\t\tspare_ecc[byte_pos - 512] ^=\n\t\t\t\t\t\t\t1 << bit_pos;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tdev_err(&info->pdev->dev,\n\t\t\t\t\t\t\"invalid bit-flip @ %d:%d\\n\",\n\t\t\t\t\t\tbyte_pos, bit_pos);\n\t\t\t\t\terr = -EBADMSG;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tstat = max_t(unsigned int, stat, err_vec[i].error_count);\n\n\t\t \n\t\tdata += ecc->size;\n\t\tspare_ecc += ecc->bytes;\n\t}\n\n\treturn (err) ? err : stat;\n}\n\n \nstatic int omap_write_page_bch(struct nand_chip *chip, const uint8_t *buf,\n\t\t\t       int oob_required, int page)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tstruct omap_nand_info *info = mtd_to_omap(mtd);\n\tuint8_t *ecc_calc = chip->ecc.calc_buf;\n\tunsigned int eccpg;\n\tint ret;\n\n\tret = nand_prog_page_begin_op(chip, page, 0, NULL, 0);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (eccpg = 0; eccpg < info->neccpg; eccpg++) {\n\t\t \n\t\tchip->ecc.hwctl(chip, NAND_ECC_WRITE);\n\n\t\t \n\t\tinfo->data_out(chip, buf + (eccpg * info->eccpg_size),\n\t\t\t       info->eccpg_size, false);\n\n\t\t \n\t\tret = omap_calculate_ecc_bch_multi(mtd,\n\t\t\t\t\t\t   buf + (eccpg * info->eccpg_size),\n\t\t\t\t\t\t   ecc_calc);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = mtd_ooblayout_set_eccbytes(mtd, ecc_calc,\n\t\t\t\t\t\t chip->oob_poi,\n\t\t\t\t\t\t eccpg * info->eccpg_bytes,\n\t\t\t\t\t\t info->eccpg_bytes);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\tinfo->data_out(chip, chip->oob_poi, mtd->oobsize, false);\n\n\treturn nand_prog_page_end_op(chip);\n}\n\n \nstatic int omap_write_subpage_bch(struct nand_chip *chip, u32 offset,\n\t\t\t\t  u32 data_len, const u8 *buf,\n\t\t\t\t  int oob_required, int page)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tstruct omap_nand_info *info = mtd_to_omap(mtd);\n\tu8 *ecc_calc = chip->ecc.calc_buf;\n\tint ecc_size      = chip->ecc.size;\n\tint ecc_bytes     = chip->ecc.bytes;\n\tu32 start_step = offset / ecc_size;\n\tu32 end_step   = (offset + data_len - 1) / ecc_size;\n\tunsigned int eccpg;\n\tint step, ret = 0;\n\n\t \n\tret = nand_prog_page_begin_op(chip, page, 0, NULL, 0);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (eccpg = 0; eccpg < info->neccpg; eccpg++) {\n\t\t \n\t\tchip->ecc.hwctl(chip, NAND_ECC_WRITE);\n\n\t\t \n\t\tinfo->data_out(chip, buf + (eccpg * info->eccpg_size),\n\t\t\t       info->eccpg_size, false);\n\n\t\tfor (step = 0; step < info->nsteps_per_eccpg; step++) {\n\t\t\tunsigned int base_step = eccpg * info->nsteps_per_eccpg;\n\t\t\tconst u8 *bufoffs = buf + (eccpg * info->eccpg_size);\n\n\t\t\t \n\t\t\tif ((step + base_step) < start_step ||\n\t\t\t    (step + base_step) > end_step)\n\t\t\t\tmemset(ecc_calc + (step * ecc_bytes), 0xff,\n\t\t\t\t       ecc_bytes);\n\t\t\telse\n\t\t\t\tret = _omap_calculate_ecc_bch(mtd,\n\t\t\t\t\t\t\t      bufoffs + (step * ecc_size),\n\t\t\t\t\t\t\t      ecc_calc + (step * ecc_bytes),\n\t\t\t\t\t\t\t      step);\n\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\n\t\t \n\t\tret = mtd_ooblayout_set_eccbytes(mtd, ecc_calc, chip->oob_poi,\n\t\t\t\t\t\t eccpg * info->eccpg_bytes,\n\t\t\t\t\t\t info->eccpg_bytes);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\tinfo->data_out(chip, chip->oob_poi, mtd->oobsize, false);\n\n\treturn nand_prog_page_end_op(chip);\n}\n\n \nstatic int omap_read_page_bch(struct nand_chip *chip, uint8_t *buf,\n\t\t\t      int oob_required, int page)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tstruct omap_nand_info *info = mtd_to_omap(mtd);\n\tuint8_t *ecc_calc = chip->ecc.calc_buf;\n\tuint8_t *ecc_code = chip->ecc.code_buf;\n\tunsigned int max_bitflips = 0, eccpg;\n\tint stat, ret;\n\n\tret = nand_read_page_op(chip, page, 0, NULL, 0);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (eccpg = 0; eccpg < info->neccpg; eccpg++) {\n\t\t \n\t\tchip->ecc.hwctl(chip, NAND_ECC_READ);\n\n\t\t \n\t\tret = nand_change_read_column_op(chip, eccpg * info->eccpg_size,\n\t\t\t\t\t\t buf + (eccpg * info->eccpg_size),\n\t\t\t\t\t\t info->eccpg_size, false);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t \n\t\tret = nand_change_read_column_op(chip,\n\t\t\t\t\t\t mtd->writesize + BBM_LEN +\n\t\t\t\t\t\t (eccpg * info->eccpg_bytes),\n\t\t\t\t\t\t chip->oob_poi + BBM_LEN +\n\t\t\t\t\t\t (eccpg * info->eccpg_bytes),\n\t\t\t\t\t\t info->eccpg_bytes, false);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t \n\t\tret = omap_calculate_ecc_bch_multi(mtd,\n\t\t\t\t\t\t   buf + (eccpg * info->eccpg_size),\n\t\t\t\t\t\t   ecc_calc);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = mtd_ooblayout_get_eccbytes(mtd, ecc_code,\n\t\t\t\t\t\t chip->oob_poi,\n\t\t\t\t\t\t eccpg * info->eccpg_bytes,\n\t\t\t\t\t\t info->eccpg_bytes);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tstat = chip->ecc.correct(chip,\n\t\t\t\t\t buf + (eccpg * info->eccpg_size),\n\t\t\t\t\t ecc_code, ecc_calc);\n\t\tif (stat < 0) {\n\t\t\tmtd->ecc_stats.failed++;\n\t\t} else {\n\t\t\tmtd->ecc_stats.corrected += stat;\n\t\t\tmax_bitflips = max_t(unsigned int, max_bitflips, stat);\n\t\t}\n\t}\n\n\treturn max_bitflips;\n}\n\n \nstatic bool is_elm_present(struct omap_nand_info *info,\n\t\t\t   struct device_node *elm_node)\n{\n\tstruct platform_device *pdev;\n\n\t \n\tif (!elm_node) {\n\t\tdev_err(&info->pdev->dev, \"ELM devicetree node not found\\n\");\n\t\treturn false;\n\t}\n\tpdev = of_find_device_by_node(elm_node);\n\t \n\tif (!pdev) {\n\t\tdev_err(&info->pdev->dev, \"ELM device not found\\n\");\n\t\treturn false;\n\t}\n\t \n\tinfo->elm_dev = &pdev->dev;\n\treturn true;\n}\n\nstatic bool omap2_nand_ecc_check(struct omap_nand_info *info)\n{\n\tbool ecc_needs_bch, ecc_needs_omap_bch, ecc_needs_elm;\n\n\tswitch (info->ecc_opt) {\n\tcase OMAP_ECC_BCH4_CODE_HW_DETECTION_SW:\n\tcase OMAP_ECC_BCH8_CODE_HW_DETECTION_SW:\n\t\tecc_needs_omap_bch = false;\n\t\tecc_needs_bch = true;\n\t\tecc_needs_elm = false;\n\t\tbreak;\n\tcase OMAP_ECC_BCH4_CODE_HW:\n\tcase OMAP_ECC_BCH8_CODE_HW:\n\tcase OMAP_ECC_BCH16_CODE_HW:\n\t\tecc_needs_omap_bch = true;\n\t\tecc_needs_bch = false;\n\t\tecc_needs_elm = true;\n\t\tbreak;\n\tdefault:\n\t\tecc_needs_omap_bch = false;\n\t\tecc_needs_bch = false;\n\t\tecc_needs_elm = false;\n\t\tbreak;\n\t}\n\n\tif (ecc_needs_bch && !IS_ENABLED(CONFIG_MTD_NAND_ECC_SW_BCH)) {\n\t\tdev_err(&info->pdev->dev,\n\t\t\t\"CONFIG_MTD_NAND_ECC_SW_BCH not enabled\\n\");\n\t\treturn false;\n\t}\n\tif (ecc_needs_omap_bch && !IS_ENABLED(CONFIG_MTD_NAND_OMAP_BCH)) {\n\t\tdev_err(&info->pdev->dev,\n\t\t\t\"CONFIG_MTD_NAND_OMAP_BCH not enabled\\n\");\n\t\treturn false;\n\t}\n\tif (ecc_needs_elm && !is_elm_present(info, info->elm_of_node)) {\n\t\tdev_err(&info->pdev->dev, \"ELM not available\\n\");\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic const char * const nand_xfer_types[] = {\n\t[NAND_OMAP_PREFETCH_POLLED] = \"prefetch-polled\",\n\t[NAND_OMAP_POLLED] = \"polled\",\n\t[NAND_OMAP_PREFETCH_DMA] = \"prefetch-dma\",\n\t[NAND_OMAP_PREFETCH_IRQ] = \"prefetch-irq\",\n};\n\nstatic int omap_get_dt_info(struct device *dev, struct omap_nand_info *info)\n{\n\tstruct device_node *child = dev->of_node;\n\tint i;\n\tconst char *s;\n\tu32 cs;\n\n\tif (of_property_read_u32(child, \"reg\", &cs) < 0) {\n\t\tdev_err(dev, \"reg not found in DT\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tinfo->gpmc_cs = cs;\n\n\t \n\tinfo->elm_of_node = of_parse_phandle(child, \"ti,elm-id\", 0);\n\tif (!info->elm_of_node) {\n\t\tinfo->elm_of_node = of_parse_phandle(child, \"elm_id\", 0);\n\t\tif (!info->elm_of_node)\n\t\t\tdev_dbg(dev, \"ti,elm-id not in DT\\n\");\n\t}\n\n\t \n\tif (of_property_read_string(child, \"ti,nand-ecc-opt\", &s)) {\n\t\tdev_err(dev, \"ti,nand-ecc-opt not found\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!strcmp(s, \"sw\")) {\n\t\tinfo->ecc_opt = OMAP_ECC_HAM1_CODE_SW;\n\t} else if (!strcmp(s, \"ham1\") ||\n\t\t   !strcmp(s, \"hw\") || !strcmp(s, \"hw-romcode\")) {\n\t\tinfo->ecc_opt =\tOMAP_ECC_HAM1_CODE_HW;\n\t} else if (!strcmp(s, \"bch4\")) {\n\t\tif (info->elm_of_node)\n\t\t\tinfo->ecc_opt = OMAP_ECC_BCH4_CODE_HW;\n\t\telse\n\t\t\tinfo->ecc_opt = OMAP_ECC_BCH4_CODE_HW_DETECTION_SW;\n\t} else if (!strcmp(s, \"bch8\")) {\n\t\tif (info->elm_of_node)\n\t\t\tinfo->ecc_opt = OMAP_ECC_BCH8_CODE_HW;\n\t\telse\n\t\t\tinfo->ecc_opt = OMAP_ECC_BCH8_CODE_HW_DETECTION_SW;\n\t} else if (!strcmp(s, \"bch16\")) {\n\t\tinfo->ecc_opt =\tOMAP_ECC_BCH16_CODE_HW;\n\t} else {\n\t\tdev_err(dev, \"unrecognized value for ti,nand-ecc-opt\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (!of_property_read_string(child, \"ti,nand-xfer-type\", &s)) {\n\t\tfor (i = 0; i < ARRAY_SIZE(nand_xfer_types); i++) {\n\t\t\tif (!strcasecmp(s, nand_xfer_types[i])) {\n\t\t\t\tinfo->xfer_type = i;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\n\t\tdev_err(dev, \"unrecognized value for ti,nand-xfer-type\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int omap_ooblayout_ecc(struct mtd_info *mtd, int section,\n\t\t\t      struct mtd_oob_region *oobregion)\n{\n\tstruct omap_nand_info *info = mtd_to_omap(mtd);\n\tstruct nand_chip *chip = &info->nand;\n\tint off = BBM_LEN;\n\n\tif (info->ecc_opt == OMAP_ECC_HAM1_CODE_HW &&\n\t    !(chip->options & NAND_BUSWIDTH_16))\n\t\toff = 1;\n\n\tif (section)\n\t\treturn -ERANGE;\n\n\toobregion->offset = off;\n\toobregion->length = chip->ecc.total;\n\n\treturn 0;\n}\n\nstatic int omap_ooblayout_free(struct mtd_info *mtd, int section,\n\t\t\t       struct mtd_oob_region *oobregion)\n{\n\tstruct omap_nand_info *info = mtd_to_omap(mtd);\n\tstruct nand_chip *chip = &info->nand;\n\tint off = BBM_LEN;\n\n\tif (info->ecc_opt == OMAP_ECC_HAM1_CODE_HW &&\n\t    !(chip->options & NAND_BUSWIDTH_16))\n\t\toff = 1;\n\n\tif (section)\n\t\treturn -ERANGE;\n\n\toff += chip->ecc.total;\n\tif (off >= mtd->oobsize)\n\t\treturn -ERANGE;\n\n\toobregion->offset = off;\n\toobregion->length = mtd->oobsize - off;\n\n\treturn 0;\n}\n\nstatic const struct mtd_ooblayout_ops omap_ooblayout_ops = {\n\t.ecc = omap_ooblayout_ecc,\n\t.free = omap_ooblayout_free,\n};\n\nstatic int omap_sw_ooblayout_ecc(struct mtd_info *mtd, int section,\n\t\t\t\t struct mtd_oob_region *oobregion)\n{\n\tstruct nand_device *nand = mtd_to_nanddev(mtd);\n\tunsigned int nsteps = nanddev_get_ecc_nsteps(nand);\n\tunsigned int ecc_bytes = nanddev_get_ecc_bytes_per_step(nand);\n\tint off = BBM_LEN;\n\n\tif (section >= nsteps)\n\t\treturn -ERANGE;\n\n\t \n\toobregion->offset = off + (section * (ecc_bytes + 1));\n\toobregion->length = ecc_bytes;\n\n\treturn 0;\n}\n\nstatic int omap_sw_ooblayout_free(struct mtd_info *mtd, int section,\n\t\t\t\t  struct mtd_oob_region *oobregion)\n{\n\tstruct nand_device *nand = mtd_to_nanddev(mtd);\n\tunsigned int nsteps = nanddev_get_ecc_nsteps(nand);\n\tunsigned int ecc_bytes = nanddev_get_ecc_bytes_per_step(nand);\n\tint off = BBM_LEN;\n\n\tif (section)\n\t\treturn -ERANGE;\n\n\t \n\toff += ((ecc_bytes + 1) * nsteps);\n\tif (off >= mtd->oobsize)\n\t\treturn -ERANGE;\n\n\toobregion->offset = off;\n\toobregion->length = mtd->oobsize - off;\n\n\treturn 0;\n}\n\nstatic const struct mtd_ooblayout_ops omap_sw_ooblayout_ops = {\n\t.ecc = omap_sw_ooblayout_ecc,\n\t.free = omap_sw_ooblayout_free,\n};\n\nstatic int omap_nand_attach_chip(struct nand_chip *chip)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tstruct omap_nand_info *info = mtd_to_omap(mtd);\n\tstruct device *dev = &info->pdev->dev;\n\tint min_oobbytes = BBM_LEN;\n\tint elm_bch_strength = -1;\n\tint oobbytes_per_step;\n\tdma_cap_mask_t mask;\n\tint err;\n\n\tif (chip->bbt_options & NAND_BBT_USE_FLASH)\n\t\tchip->bbt_options |= NAND_BBT_NO_OOB;\n\telse\n\t\tchip->options |= NAND_SKIP_BBTSCAN;\n\n\t \n\tswitch (info->xfer_type) {\n\tcase NAND_OMAP_PREFETCH_POLLED:\n\t\tinfo->data_in = omap_nand_data_in_pref;\n\t\tinfo->data_out = omap_nand_data_out_pref;\n\t\tbreak;\n\n\tcase NAND_OMAP_POLLED:\n\t\t \n\t\tbreak;\n\n\tcase NAND_OMAP_PREFETCH_DMA:\n\t\tdma_cap_zero(mask);\n\t\tdma_cap_set(DMA_SLAVE, mask);\n\t\tinfo->dma = dma_request_chan(dev->parent, \"rxtx\");\n\n\t\tif (IS_ERR(info->dma)) {\n\t\t\tdev_err(dev, \"DMA engine request failed\\n\");\n\t\t\treturn PTR_ERR(info->dma);\n\t\t} else {\n\t\t\tstruct dma_slave_config cfg;\n\n\t\t\tmemset(&cfg, 0, sizeof(cfg));\n\t\t\tcfg.src_addr = info->phys_base;\n\t\t\tcfg.dst_addr = info->phys_base;\n\t\t\tcfg.src_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;\n\t\t\tcfg.dst_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;\n\t\t\tcfg.src_maxburst = 16;\n\t\t\tcfg.dst_maxburst = 16;\n\t\t\terr = dmaengine_slave_config(info->dma, &cfg);\n\t\t\tif (err) {\n\t\t\t\tdev_err(dev,\n\t\t\t\t\t\"DMA engine slave config failed: %d\\n\",\n\t\t\t\t\terr);\n\t\t\t\treturn err;\n\t\t\t}\n\n\t\t\tinfo->data_in = omap_nand_data_in_dma_pref;\n\t\t\tinfo->data_out = omap_nand_data_out_dma_pref;\n\t\t}\n\t\tbreak;\n\n\tcase NAND_OMAP_PREFETCH_IRQ:\n\t\tinfo->gpmc_irq_fifo = platform_get_irq(info->pdev, 0);\n\t\tif (info->gpmc_irq_fifo <= 0)\n\t\t\treturn -ENODEV;\n\t\terr = devm_request_irq(dev, info->gpmc_irq_fifo,\n\t\t\t\t       omap_nand_irq, IRQF_SHARED,\n\t\t\t\t       \"gpmc-nand-fifo\", info);\n\t\tif (err) {\n\t\t\tdev_err(dev, \"Requesting IRQ %d, error %d\\n\",\n\t\t\t\tinfo->gpmc_irq_fifo, err);\n\t\t\tinfo->gpmc_irq_fifo = 0;\n\t\t\treturn err;\n\t\t}\n\n\t\tinfo->gpmc_irq_count = platform_get_irq(info->pdev, 1);\n\t\tif (info->gpmc_irq_count <= 0)\n\t\t\treturn -ENODEV;\n\t\terr = devm_request_irq(dev, info->gpmc_irq_count,\n\t\t\t\t       omap_nand_irq, IRQF_SHARED,\n\t\t\t\t       \"gpmc-nand-count\", info);\n\t\tif (err) {\n\t\t\tdev_err(dev, \"Requesting IRQ %d, error %d\\n\",\n\t\t\t\tinfo->gpmc_irq_count, err);\n\t\t\tinfo->gpmc_irq_count = 0;\n\t\t\treturn err;\n\t\t}\n\n\t\tinfo->data_in = omap_nand_data_in_irq_pref;\n\t\tinfo->data_out = omap_nand_data_out_irq_pref;\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(dev, \"xfer_type %d not supported!\\n\", info->xfer_type);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!omap2_nand_ecc_check(info))\n\t\treturn -EINVAL;\n\n\t \n\tif (info->ecc_opt == OMAP_ECC_HAM1_CODE_SW) {\n\t\tchip->ecc.engine_type = NAND_ECC_ENGINE_TYPE_SOFT;\n\t\tchip->ecc.algo = NAND_ECC_ALGO_HAMMING;\n\t\treturn 0;\n\t}\n\n\t \n\tswitch (info->ecc_opt) {\n\tcase OMAP_ECC_HAM1_CODE_HW:\n\t\tdev_info(dev, \"nand: using OMAP_ECC_HAM1_CODE_HW\\n\");\n\t\tchip->ecc.engine_type\t= NAND_ECC_ENGINE_TYPE_ON_HOST;\n\t\tchip->ecc.bytes\t\t= 3;\n\t\tchip->ecc.size\t\t= 512;\n\t\tchip->ecc.strength\t= 1;\n\t\tchip->ecc.calculate\t= omap_calculate_ecc;\n\t\tchip->ecc.hwctl\t\t= omap_enable_hwecc;\n\t\tchip->ecc.correct\t= omap_correct_data;\n\t\tmtd_set_ooblayout(mtd, &omap_ooblayout_ops);\n\t\toobbytes_per_step\t= chip->ecc.bytes;\n\n\t\tif (!(chip->options & NAND_BUSWIDTH_16))\n\t\t\tmin_oobbytes\t= 1;\n\n\t\tbreak;\n\n\tcase OMAP_ECC_BCH4_CODE_HW_DETECTION_SW:\n\t\tpr_info(\"nand: using OMAP_ECC_BCH4_CODE_HW_DETECTION_SW\\n\");\n\t\tchip->ecc.engine_type\t= NAND_ECC_ENGINE_TYPE_ON_HOST;\n\t\tchip->ecc.size\t\t= 512;\n\t\tchip->ecc.bytes\t\t= 7;\n\t\tchip->ecc.strength\t= 4;\n\t\tchip->ecc.hwctl\t\t= omap_enable_hwecc_bch;\n\t\tchip->ecc.correct\t= rawnand_sw_bch_correct;\n\t\tchip->ecc.calculate\t= omap_calculate_ecc_bch_sw;\n\t\tmtd_set_ooblayout(mtd, &omap_sw_ooblayout_ops);\n\t\t \n\t\toobbytes_per_step\t= chip->ecc.bytes + 1;\n\t\t \n\t\terr = rawnand_sw_bch_init(chip);\n\t\tif (err) {\n\t\t\tdev_err(dev, \"Unable to use BCH library\\n\");\n\t\t\treturn err;\n\t\t}\n\t\tbreak;\n\n\tcase OMAP_ECC_BCH4_CODE_HW:\n\t\tpr_info(\"nand: using OMAP_ECC_BCH4_CODE_HW ECC scheme\\n\");\n\t\tchip->ecc.engine_type\t= NAND_ECC_ENGINE_TYPE_ON_HOST;\n\t\tchip->ecc.size\t\t= 512;\n\t\t \n\t\tchip->ecc.bytes\t\t= 7 + 1;\n\t\tchip->ecc.strength\t= 4;\n\t\tchip->ecc.hwctl\t\t= omap_enable_hwecc_bch;\n\t\tchip->ecc.correct\t= omap_elm_correct_data;\n\t\tchip->ecc.read_page\t= omap_read_page_bch;\n\t\tchip->ecc.write_page\t= omap_write_page_bch;\n\t\tchip->ecc.write_subpage\t= omap_write_subpage_bch;\n\t\tmtd_set_ooblayout(mtd, &omap_ooblayout_ops);\n\t\toobbytes_per_step\t= chip->ecc.bytes;\n\t\telm_bch_strength = BCH4_ECC;\n\t\tbreak;\n\n\tcase OMAP_ECC_BCH8_CODE_HW_DETECTION_SW:\n\t\tpr_info(\"nand: using OMAP_ECC_BCH8_CODE_HW_DETECTION_SW\\n\");\n\t\tchip->ecc.engine_type\t= NAND_ECC_ENGINE_TYPE_ON_HOST;\n\t\tchip->ecc.size\t\t= 512;\n\t\tchip->ecc.bytes\t\t= 13;\n\t\tchip->ecc.strength\t= 8;\n\t\tchip->ecc.hwctl\t\t= omap_enable_hwecc_bch;\n\t\tchip->ecc.correct\t= rawnand_sw_bch_correct;\n\t\tchip->ecc.calculate\t= omap_calculate_ecc_bch_sw;\n\t\tmtd_set_ooblayout(mtd, &omap_sw_ooblayout_ops);\n\t\t \n\t\toobbytes_per_step\t= chip->ecc.bytes + 1;\n\t\t \n\t\terr = rawnand_sw_bch_init(chip);\n\t\tif (err) {\n\t\t\tdev_err(dev, \"unable to use BCH library\\n\");\n\t\t\treturn err;\n\t\t}\n\t\tbreak;\n\n\tcase OMAP_ECC_BCH8_CODE_HW:\n\t\tpr_info(\"nand: using OMAP_ECC_BCH8_CODE_HW ECC scheme\\n\");\n\t\tchip->ecc.engine_type\t= NAND_ECC_ENGINE_TYPE_ON_HOST;\n\t\tchip->ecc.size\t\t= 512;\n\t\t \n\t\tchip->ecc.bytes\t\t= 13 + 1;\n\t\tchip->ecc.strength\t= 8;\n\t\tchip->ecc.hwctl\t\t= omap_enable_hwecc_bch;\n\t\tchip->ecc.correct\t= omap_elm_correct_data;\n\t\tchip->ecc.read_page\t= omap_read_page_bch;\n\t\tchip->ecc.write_page\t= omap_write_page_bch;\n\t\tchip->ecc.write_subpage\t= omap_write_subpage_bch;\n\t\tmtd_set_ooblayout(mtd, &omap_ooblayout_ops);\n\t\toobbytes_per_step\t= chip->ecc.bytes;\n\t\telm_bch_strength = BCH8_ECC;\n\t\tbreak;\n\n\tcase OMAP_ECC_BCH16_CODE_HW:\n\t\tpr_info(\"Using OMAP_ECC_BCH16_CODE_HW ECC scheme\\n\");\n\t\tchip->ecc.engine_type\t= NAND_ECC_ENGINE_TYPE_ON_HOST;\n\t\tchip->ecc.size\t\t= 512;\n\t\tchip->ecc.bytes\t\t= 26;\n\t\tchip->ecc.strength\t= 16;\n\t\tchip->ecc.hwctl\t\t= omap_enable_hwecc_bch;\n\t\tchip->ecc.correct\t= omap_elm_correct_data;\n\t\tchip->ecc.read_page\t= omap_read_page_bch;\n\t\tchip->ecc.write_page\t= omap_write_page_bch;\n\t\tchip->ecc.write_subpage\t= omap_write_subpage_bch;\n\t\tmtd_set_ooblayout(mtd, &omap_ooblayout_ops);\n\t\toobbytes_per_step\t= chip->ecc.bytes;\n\t\telm_bch_strength = BCH16_ECC;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev, \"Invalid or unsupported ECC scheme\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (elm_bch_strength >= 0) {\n\t\tchip->ecc.steps = mtd->writesize / chip->ecc.size;\n\t\tinfo->neccpg = chip->ecc.steps / ERROR_VECTOR_MAX;\n\t\tif (info->neccpg) {\n\t\t\tinfo->nsteps_per_eccpg = ERROR_VECTOR_MAX;\n\t\t} else {\n\t\t\tinfo->neccpg = 1;\n\t\t\tinfo->nsteps_per_eccpg = chip->ecc.steps;\n\t\t}\n\t\tinfo->eccpg_size = info->nsteps_per_eccpg * chip->ecc.size;\n\t\tinfo->eccpg_bytes = info->nsteps_per_eccpg * chip->ecc.bytes;\n\n\t\terr = elm_config(info->elm_dev, elm_bch_strength,\n\t\t\t\t info->nsteps_per_eccpg, chip->ecc.size,\n\t\t\t\t chip->ecc.bytes);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\t \n\tmin_oobbytes += (oobbytes_per_step *\n\t\t\t (mtd->writesize / chip->ecc.size));\n\tif (mtd->oobsize < min_oobbytes) {\n\t\tdev_err(dev,\n\t\t\t\"Not enough OOB bytes: required = %d, available=%d\\n\",\n\t\t\tmin_oobbytes, mtd->oobsize);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic void omap_nand_data_in(struct nand_chip *chip, void *buf,\n\t\t\t      unsigned int len, bool force_8bit)\n{\n\tstruct omap_nand_info *info = mtd_to_omap(nand_to_mtd(chip));\n\tu32 alignment = ((uintptr_t)buf | len) & 3;\n\n\tif (force_8bit || (alignment & 1))\n\t\tioread8_rep(info->fifo, buf, len);\n\telse if (alignment & 3)\n\t\tioread16_rep(info->fifo, buf, len >> 1);\n\telse\n\t\tioread32_rep(info->fifo, buf, len >> 2);\n}\n\nstatic void omap_nand_data_out(struct nand_chip *chip,\n\t\t\t       const void *buf, unsigned int len,\n\t\t\t       bool force_8bit)\n{\n\tstruct omap_nand_info *info = mtd_to_omap(nand_to_mtd(chip));\n\tu32 alignment = ((uintptr_t)buf | len) & 3;\n\n\tif (force_8bit || (alignment & 1))\n\t\tiowrite8_rep(info->fifo, buf, len);\n\telse if (alignment & 3)\n\t\tiowrite16_rep(info->fifo, buf, len >> 1);\n\telse\n\t\tiowrite32_rep(info->fifo, buf, len >> 2);\n}\n\nstatic int omap_nand_exec_instr(struct nand_chip *chip,\n\t\t\t\tconst struct nand_op_instr *instr)\n{\n\tstruct omap_nand_info *info = mtd_to_omap(nand_to_mtd(chip));\n\tunsigned int i;\n\tint ret;\n\n\tswitch (instr->type) {\n\tcase NAND_OP_CMD_INSTR:\n\t\tiowrite8(instr->ctx.cmd.opcode,\n\t\t\t info->reg.gpmc_nand_command);\n\t\tbreak;\n\n\tcase NAND_OP_ADDR_INSTR:\n\t\tfor (i = 0; i < instr->ctx.addr.naddrs; i++) {\n\t\t\tiowrite8(instr->ctx.addr.addrs[i],\n\t\t\t\t info->reg.gpmc_nand_address);\n\t\t}\n\t\tbreak;\n\n\tcase NAND_OP_DATA_IN_INSTR:\n\t\tinfo->data_in(chip, instr->ctx.data.buf.in,\n\t\t\t      instr->ctx.data.len,\n\t\t\t      instr->ctx.data.force_8bit);\n\t\tbreak;\n\n\tcase NAND_OP_DATA_OUT_INSTR:\n\t\tinfo->data_out(chip, instr->ctx.data.buf.out,\n\t\t\t       instr->ctx.data.len,\n\t\t\t       instr->ctx.data.force_8bit);\n\t\tbreak;\n\n\tcase NAND_OP_WAITRDY_INSTR:\n\t\tret = info->ready_gpiod ?\n\t\t\tnand_gpio_waitrdy(chip, info->ready_gpiod, instr->ctx.waitrdy.timeout_ms) :\n\t\t\tnand_soft_waitrdy(chip, instr->ctx.waitrdy.timeout_ms);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tbreak;\n\t}\n\n\tif (instr->delay_ns)\n\t\tndelay(instr->delay_ns);\n\n\treturn 0;\n}\n\nstatic int omap_nand_exec_op(struct nand_chip *chip,\n\t\t\t     const struct nand_operation *op,\n\t\t\t     bool check_only)\n{\n\tunsigned int i;\n\n\tif (check_only)\n\t\treturn 0;\n\n\tfor (i = 0; i < op->ninstrs; i++) {\n\t\tint ret;\n\n\t\tret = omap_nand_exec_instr(chip, &op->instrs[i]);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct nand_controller_ops omap_nand_controller_ops = {\n\t.attach_chip = omap_nand_attach_chip,\n\t.exec_op = omap_nand_exec_op,\n};\n\n \nstatic struct nand_controller omap_gpmc_controller;\nstatic bool omap_gpmc_controller_initialized;\n\nstatic int omap_nand_probe(struct platform_device *pdev)\n{\n\tstruct omap_nand_info\t\t*info;\n\tstruct mtd_info\t\t\t*mtd;\n\tstruct nand_chip\t\t*nand_chip;\n\tint\t\t\t\terr;\n\tstruct resource\t\t\t*res;\n\tstruct device\t\t\t*dev = &pdev->dev;\n\tvoid __iomem *vaddr;\n\n\tinfo = devm_kzalloc(&pdev->dev, sizeof(struct omap_nand_info),\n\t\t\t\tGFP_KERNEL);\n\tif (!info)\n\t\treturn -ENOMEM;\n\n\tinfo->pdev = pdev;\n\n\terr = omap_get_dt_info(dev, info);\n\tif (err)\n\t\treturn err;\n\n\tinfo->ops = gpmc_omap_get_nand_ops(&info->reg, info->gpmc_cs);\n\tif (!info->ops) {\n\t\tdev_err(&pdev->dev, \"Failed to get GPMC->NAND interface\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tnand_chip\t\t= &info->nand;\n\tmtd\t\t\t= nand_to_mtd(nand_chip);\n\tmtd->dev.parent\t\t= &pdev->dev;\n\tnand_set_flash_node(nand_chip, dev->of_node);\n\n\tif (!mtd->name) {\n\t\tmtd->name = devm_kasprintf(&pdev->dev, GFP_KERNEL,\n\t\t\t\t\t   \"omap2-nand.%d\", info->gpmc_cs);\n\t\tif (!mtd->name) {\n\t\t\tdev_err(&pdev->dev, \"Failed to set MTD name\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\tvaddr = devm_platform_get_and_ioremap_resource(pdev, 0, &res);\n\tif (IS_ERR(vaddr))\n\t\treturn PTR_ERR(vaddr);\n\n\tinfo->fifo = vaddr;\n\tinfo->phys_base = res->start;\n\n\tif (!omap_gpmc_controller_initialized) {\n\t\tomap_gpmc_controller.ops = &omap_nand_controller_ops;\n\t\tnand_controller_init(&omap_gpmc_controller);\n\t\tomap_gpmc_controller_initialized = true;\n\t}\n\n\tnand_chip->controller = &omap_gpmc_controller;\n\n\tinfo->ready_gpiod = devm_gpiod_get_optional(&pdev->dev, \"rb\",\n\t\t\t\t\t\t    GPIOD_IN);\n\tif (IS_ERR(info->ready_gpiod)) {\n\t\tdev_err(dev, \"failed to get ready gpio\\n\");\n\t\treturn PTR_ERR(info->ready_gpiod);\n\t}\n\n\tif (info->flash_bbt)\n\t\tnand_chip->bbt_options |= NAND_BBT_USE_FLASH;\n\n\t \n\tinfo->data_in = omap_nand_data_in;\n\tinfo->data_out = omap_nand_data_out;\n\n\terr = nand_scan(nand_chip, 1);\n\tif (err)\n\t\tgoto return_error;\n\n\terr = mtd_device_register(mtd, NULL, 0);\n\tif (err)\n\t\tgoto cleanup_nand;\n\n\tplatform_set_drvdata(pdev, mtd);\n\n\treturn 0;\n\ncleanup_nand:\n\tnand_cleanup(nand_chip);\n\nreturn_error:\n\tif (!IS_ERR_OR_NULL(info->dma))\n\t\tdma_release_channel(info->dma);\n\n\trawnand_sw_bch_cleanup(nand_chip);\n\n\treturn err;\n}\n\nstatic void omap_nand_remove(struct platform_device *pdev)\n{\n\tstruct mtd_info *mtd = platform_get_drvdata(pdev);\n\tstruct nand_chip *nand_chip = mtd_to_nand(mtd);\n\tstruct omap_nand_info *info = mtd_to_omap(mtd);\n\n\trawnand_sw_bch_cleanup(nand_chip);\n\n\tif (info->dma)\n\t\tdma_release_channel(info->dma);\n\tWARN_ON(mtd_device_unregister(mtd));\n\tnand_cleanup(nand_chip);\n}\n\n \nMODULE_DEVICE_TABLE(of, omap_nand_ids);\n\nstatic struct platform_driver omap_nand_driver = {\n\t.probe\t\t= omap_nand_probe,\n\t.remove_new\t= omap_nand_remove,\n\t.driver\t\t= {\n\t\t.name\t= DRIVER_NAME,\n\t\t.of_match_table = omap_nand_ids,\n\t},\n};\n\nmodule_platform_driver(omap_nand_driver);\n\nMODULE_ALIAS(\"platform:\" DRIVER_NAME);\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"Glue layer for NAND flash on TI OMAP boards\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}