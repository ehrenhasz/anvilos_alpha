{
  "module_name": "sh_flctl.c",
  "hash_id": "2fc3d5db5f3bbd5d58198c3e45c8267b01262135926693834f6bd7604efb304e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/nand/raw/sh_flctl.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/dmaengine.h>\n#include <linux/dma-mapping.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/sh_dma.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\n#include <linux/mtd/mtd.h>\n#include <linux/mtd/rawnand.h>\n#include <linux/mtd/partitions.h>\n#include <linux/mtd/sh_flctl.h>\n\nstatic int flctl_4secc_ooblayout_sp_ecc(struct mtd_info *mtd, int section,\n\t\t\t\t\tstruct mtd_oob_region *oobregion)\n{\n\tstruct nand_chip *chip = mtd_to_nand(mtd);\n\n\tif (section)\n\t\treturn -ERANGE;\n\n\toobregion->offset = 0;\n\toobregion->length = chip->ecc.bytes;\n\n\treturn 0;\n}\n\nstatic int flctl_4secc_ooblayout_sp_free(struct mtd_info *mtd, int section,\n\t\t\t\t\t struct mtd_oob_region *oobregion)\n{\n\tif (section)\n\t\treturn -ERANGE;\n\n\toobregion->offset = 12;\n\toobregion->length = 4;\n\n\treturn 0;\n}\n\nstatic const struct mtd_ooblayout_ops flctl_4secc_oob_smallpage_ops = {\n\t.ecc = flctl_4secc_ooblayout_sp_ecc,\n\t.free = flctl_4secc_ooblayout_sp_free,\n};\n\nstatic int flctl_4secc_ooblayout_lp_ecc(struct mtd_info *mtd, int section,\n\t\t\t\t\tstruct mtd_oob_region *oobregion)\n{\n\tstruct nand_chip *chip = mtd_to_nand(mtd);\n\n\tif (section >= chip->ecc.steps)\n\t\treturn -ERANGE;\n\n\toobregion->offset = (section * 16) + 6;\n\toobregion->length = chip->ecc.bytes;\n\n\treturn 0;\n}\n\nstatic int flctl_4secc_ooblayout_lp_free(struct mtd_info *mtd, int section,\n\t\t\t\t\t struct mtd_oob_region *oobregion)\n{\n\tstruct nand_chip *chip = mtd_to_nand(mtd);\n\n\tif (section >= chip->ecc.steps)\n\t\treturn -ERANGE;\n\n\toobregion->offset = section * 16;\n\toobregion->length = 6;\n\n\tif (!section) {\n\t\toobregion->offset += 2;\n\t\toobregion->length -= 2;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct mtd_ooblayout_ops flctl_4secc_oob_largepage_ops = {\n\t.ecc = flctl_4secc_ooblayout_lp_ecc,\n\t.free = flctl_4secc_ooblayout_lp_free,\n};\n\nstatic uint8_t scan_ff_pattern[] = { 0xff, 0xff };\n\nstatic struct nand_bbt_descr flctl_4secc_smallpage = {\n\t.offs = 11,\n\t.len = 1,\n\t.pattern = scan_ff_pattern,\n};\n\nstatic struct nand_bbt_descr flctl_4secc_largepage = {\n\t.offs = 0,\n\t.len = 2,\n\t.pattern = scan_ff_pattern,\n};\n\nstatic void empty_fifo(struct sh_flctl *flctl)\n{\n\twritel(flctl->flintdmacr_base | AC1CLR | AC0CLR, FLINTDMACR(flctl));\n\twritel(flctl->flintdmacr_base, FLINTDMACR(flctl));\n}\n\nstatic void start_translation(struct sh_flctl *flctl)\n{\n\twriteb(TRSTRT, FLTRCR(flctl));\n}\n\nstatic void timeout_error(struct sh_flctl *flctl, const char *str)\n{\n\tdev_err(&flctl->pdev->dev, \"Timeout occurred in %s\\n\", str);\n}\n\nstatic void wait_completion(struct sh_flctl *flctl)\n{\n\tuint32_t timeout = LOOP_TIMEOUT_MAX;\n\n\twhile (timeout--) {\n\t\tif (readb(FLTRCR(flctl)) & TREND) {\n\t\t\twriteb(0x0, FLTRCR(flctl));\n\t\t\treturn;\n\t\t}\n\t\tudelay(1);\n\t}\n\n\ttimeout_error(flctl, __func__);\n\twriteb(0x0, FLTRCR(flctl));\n}\n\nstatic void flctl_dma_complete(void *param)\n{\n\tstruct sh_flctl *flctl = param;\n\n\tcomplete(&flctl->dma_complete);\n}\n\nstatic void flctl_release_dma(struct sh_flctl *flctl)\n{\n\tif (flctl->chan_fifo0_rx) {\n\t\tdma_release_channel(flctl->chan_fifo0_rx);\n\t\tflctl->chan_fifo0_rx = NULL;\n\t}\n\tif (flctl->chan_fifo0_tx) {\n\t\tdma_release_channel(flctl->chan_fifo0_tx);\n\t\tflctl->chan_fifo0_tx = NULL;\n\t}\n}\n\nstatic void flctl_setup_dma(struct sh_flctl *flctl)\n{\n\tdma_cap_mask_t mask;\n\tstruct dma_slave_config cfg;\n\tstruct platform_device *pdev = flctl->pdev;\n\tstruct sh_flctl_platform_data *pdata = dev_get_platdata(&pdev->dev);\n\tint ret;\n\n\tif (!pdata)\n\t\treturn;\n\n\tif (pdata->slave_id_fifo0_tx <= 0 || pdata->slave_id_fifo0_rx <= 0)\n\t\treturn;\n\n\t \n\tdma_cap_zero(mask);\n\tdma_cap_set(DMA_SLAVE, mask);\n\n\tflctl->chan_fifo0_tx = dma_request_channel(mask, shdma_chan_filter,\n\t\t\t\t(void *)(uintptr_t)pdata->slave_id_fifo0_tx);\n\tdev_dbg(&pdev->dev, \"%s: TX: got channel %p\\n\", __func__,\n\t\tflctl->chan_fifo0_tx);\n\n\tif (!flctl->chan_fifo0_tx)\n\t\treturn;\n\n\tmemset(&cfg, 0, sizeof(cfg));\n\tcfg.direction = DMA_MEM_TO_DEV;\n\tcfg.dst_addr = flctl->fifo;\n\tcfg.src_addr = 0;\n\tret = dmaengine_slave_config(flctl->chan_fifo0_tx, &cfg);\n\tif (ret < 0)\n\t\tgoto err;\n\n\tflctl->chan_fifo0_rx = dma_request_channel(mask, shdma_chan_filter,\n\t\t\t\t(void *)(uintptr_t)pdata->slave_id_fifo0_rx);\n\tdev_dbg(&pdev->dev, \"%s: RX: got channel %p\\n\", __func__,\n\t\tflctl->chan_fifo0_rx);\n\n\tif (!flctl->chan_fifo0_rx)\n\t\tgoto err;\n\n\tcfg.direction = DMA_DEV_TO_MEM;\n\tcfg.dst_addr = 0;\n\tcfg.src_addr = flctl->fifo;\n\tret = dmaengine_slave_config(flctl->chan_fifo0_rx, &cfg);\n\tif (ret < 0)\n\t\tgoto err;\n\n\tinit_completion(&flctl->dma_complete);\n\n\treturn;\n\nerr:\n\tflctl_release_dma(flctl);\n}\n\nstatic void set_addr(struct mtd_info *mtd, int column, int page_addr)\n{\n\tstruct sh_flctl *flctl = mtd_to_flctl(mtd);\n\tuint32_t addr = 0;\n\n\tif (column == -1) {\n\t\taddr = page_addr;\t \n\t} else if (page_addr != -1) {\n\t\t \n\t\tif (flctl->chip.options & NAND_BUSWIDTH_16)\n\t\t\tcolumn >>= 1;\n\t\tif (flctl->page_size) {\n\t\t\taddr = column & 0x0FFF;\n\t\t\taddr |= (page_addr & 0xff) << 16;\n\t\t\taddr |= ((page_addr >> 8) & 0xff) << 24;\n\t\t\t \n\t\t\tif (flctl->rw_ADRCNT == ADRCNT2_E) {\n\t\t\t\tuint32_t \taddr2;\n\t\t\t\taddr2 = (page_addr >> 16) & 0xff;\n\t\t\t\twritel(addr2, FLADR2(flctl));\n\t\t\t}\n\t\t} else {\n\t\t\taddr = column;\n\t\t\taddr |= (page_addr & 0xff) << 8;\n\t\t\taddr |= ((page_addr >> 8) & 0xff) << 16;\n\t\t\taddr |= ((page_addr >> 16) & 0xff) << 24;\n\t\t}\n\t}\n\twritel(addr, FLADR(flctl));\n}\n\nstatic void wait_rfifo_ready(struct sh_flctl *flctl)\n{\n\tuint32_t timeout = LOOP_TIMEOUT_MAX;\n\n\twhile (timeout--) {\n\t\tuint32_t val;\n\t\t \n\t\tval = readl(FLDTCNTR(flctl)) >> 16;\n\t\tif (val & 0xFF)\n\t\t\treturn;\n\t\tudelay(1);\n\t}\n\ttimeout_error(flctl, __func__);\n}\n\nstatic void wait_wfifo_ready(struct sh_flctl *flctl)\n{\n\tuint32_t len, timeout = LOOP_TIMEOUT_MAX;\n\n\twhile (timeout--) {\n\t\t \n\t\tlen = (readl(FLDTCNTR(flctl)) >> 16) & 0xFF;\n\t\tif (len >= 4)\n\t\t\treturn;\n\t\tudelay(1);\n\t}\n\ttimeout_error(flctl, __func__);\n}\n\nstatic enum flctl_ecc_res_t wait_recfifo_ready\n\t\t(struct sh_flctl *flctl, int sector_number)\n{\n\tuint32_t timeout = LOOP_TIMEOUT_MAX;\n\tvoid __iomem *ecc_reg[4];\n\tint i;\n\tint state = FL_SUCCESS;\n\tuint32_t data, size;\n\n\t \n\twhile (timeout--) {\n\t\t \n\t\tsize = readl(FLDTCNTR(flctl)) >> 24;\n\t\tif ((size & 0xFF) == 4)\n\t\t\treturn state;\n\n\t\t \n\t\tif (!(readl(FL4ECCCR(flctl)) & _4ECCEND)) {\n\t\t\t \n\t\t\tudelay(1);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (readl(FL4ECCCR(flctl)) & _4ECCFA) {\n\t\t\t \n\t\t\tfor (i = 0; i < 512; i++) {\n\t\t\t\tif (flctl->done_buff[i] != 0xff) {\n\t\t\t\t\tstate = FL_ERROR;  \n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (state == FL_SUCCESS)\n\t\t\t\tdev_dbg(&flctl->pdev->dev,\n\t\t\t\t\"reading empty sector %d, ecc error ignored\\n\",\n\t\t\t\tsector_number);\n\n\t\t\twritel(0, FL4ECCCR(flctl));\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tecc_reg[0] = FL4ECCRESULT0(flctl);\n\t\tecc_reg[1] = FL4ECCRESULT1(flctl);\n\t\tecc_reg[2] = FL4ECCRESULT2(flctl);\n\t\tecc_reg[3] = FL4ECCRESULT3(flctl);\n\n\t\tfor (i = 0; i < 3; i++) {\n\t\t\tuint8_t org;\n\t\t\tunsigned int index;\n\n\t\t\tdata = readl(ecc_reg[i]);\n\n\t\t\tif (flctl->page_size)\n\t\t\t\tindex = (512 * sector_number) +\n\t\t\t\t\t(data >> 16);\n\t\t\telse\n\t\t\t\tindex = data >> 16;\n\n\t\t\torg = flctl->done_buff[index];\n\t\t\tflctl->done_buff[index] = org ^ (data & 0xFF);\n\t\t}\n\t\tstate = FL_REPAIRABLE;\n\t\twritel(0, FL4ECCCR(flctl));\n\t}\n\n\ttimeout_error(flctl, __func__);\n\treturn FL_TIMEOUT;\t \n}\n\nstatic void wait_wecfifo_ready(struct sh_flctl *flctl)\n{\n\tuint32_t timeout = LOOP_TIMEOUT_MAX;\n\tuint32_t len;\n\n\twhile (timeout--) {\n\t\t \n\t\tlen = (readl(FLDTCNTR(flctl)) >> 24) & 0xFF;\n\t\tif (len >= 4)\n\t\t\treturn;\n\t\tudelay(1);\n\t}\n\ttimeout_error(flctl, __func__);\n}\n\nstatic int flctl_dma_fifo0_transfer(struct sh_flctl *flctl, unsigned long *buf,\n\t\t\t\t\tint len, enum dma_data_direction dir)\n{\n\tstruct dma_async_tx_descriptor *desc = NULL;\n\tstruct dma_chan *chan;\n\tenum dma_transfer_direction tr_dir;\n\tdma_addr_t dma_addr;\n\tdma_cookie_t cookie;\n\tuint32_t reg;\n\tint ret = 0;\n\tunsigned long time_left;\n\n\tif (dir == DMA_FROM_DEVICE) {\n\t\tchan = flctl->chan_fifo0_rx;\n\t\ttr_dir = DMA_DEV_TO_MEM;\n\t} else {\n\t\tchan = flctl->chan_fifo0_tx;\n\t\ttr_dir = DMA_MEM_TO_DEV;\n\t}\n\n\tdma_addr = dma_map_single(chan->device->dev, buf, len, dir);\n\n\tif (!dma_mapping_error(chan->device->dev, dma_addr))\n\t\tdesc = dmaengine_prep_slave_single(chan, dma_addr, len,\n\t\t\ttr_dir, DMA_PREP_INTERRUPT | DMA_CTRL_ACK);\n\n\tif (desc) {\n\t\treg = readl(FLINTDMACR(flctl));\n\t\treg |= DREQ0EN;\n\t\twritel(reg, FLINTDMACR(flctl));\n\n\t\tdesc->callback = flctl_dma_complete;\n\t\tdesc->callback_param = flctl;\n\t\tcookie = dmaengine_submit(desc);\n\t\tif (dma_submit_error(cookie)) {\n\t\t\tret = dma_submit_error(cookie);\n\t\t\tdev_warn(&flctl->pdev->dev,\n\t\t\t\t \"DMA submit failed, falling back to PIO\\n\");\n\t\t\tgoto out;\n\t\t}\n\n\t\tdma_async_issue_pending(chan);\n\t} else {\n\t\t \n\t\tflctl_release_dma(flctl);\n\t\tdev_warn(&flctl->pdev->dev,\n\t\t\t \"DMA failed, falling back to PIO\\n\");\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n\ttime_left =\n\twait_for_completion_timeout(&flctl->dma_complete,\n\t\t\t\tmsecs_to_jiffies(3000));\n\n\tif (time_left == 0) {\n\t\tdmaengine_terminate_all(chan);\n\t\tdev_err(&flctl->pdev->dev, \"wait_for_completion_timeout\\n\");\n\t\tret = -ETIMEDOUT;\n\t}\n\nout:\n\treg = readl(FLINTDMACR(flctl));\n\treg &= ~DREQ0EN;\n\twritel(reg, FLINTDMACR(flctl));\n\n\tdma_unmap_single(chan->device->dev, dma_addr, len, dir);\n\n\t \n\treturn ret;\n}\n\nstatic void read_datareg(struct sh_flctl *flctl, int offset)\n{\n\tunsigned long data;\n\tunsigned long *buf = (unsigned long *)&flctl->done_buff[offset];\n\n\twait_completion(flctl);\n\n\tdata = readl(FLDATAR(flctl));\n\t*buf = le32_to_cpu(data);\n}\n\nstatic void read_fiforeg(struct sh_flctl *flctl, int rlen, int offset)\n{\n\tint i, len_4align;\n\tunsigned long *buf = (unsigned long *)&flctl->done_buff[offset];\n\n\tlen_4align = (rlen + 3) / 4;\n\n\t \n\tif (flctl->chan_fifo0_rx && rlen >= 32 &&\n\t\t!flctl_dma_fifo0_transfer(flctl, buf, rlen, DMA_FROM_DEVICE))\n\t\t\tgoto convert;\t \n\n\t \n\tfor (i = 0; i < len_4align; i++) {\n\t\twait_rfifo_ready(flctl);\n\t\tbuf[i] = readl(FLDTFIFO(flctl));\n\t}\n\nconvert:\n\tfor (i = 0; i < len_4align; i++)\n\t\tbuf[i] = be32_to_cpu(buf[i]);\n}\n\nstatic enum flctl_ecc_res_t read_ecfiforeg\n\t\t(struct sh_flctl *flctl, uint8_t *buff, int sector)\n{\n\tint i;\n\tenum flctl_ecc_res_t res;\n\tunsigned long *ecc_buf = (unsigned long *)buff;\n\n\tres = wait_recfifo_ready(flctl , sector);\n\n\tif (res != FL_ERROR) {\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tecc_buf[i] = readl(FLECFIFO(flctl));\n\t\t\tecc_buf[i] = be32_to_cpu(ecc_buf[i]);\n\t\t}\n\t}\n\n\treturn res;\n}\n\nstatic void write_fiforeg(struct sh_flctl *flctl, int rlen,\n\t\t\t\t\t\tunsigned int offset)\n{\n\tint i, len_4align;\n\tunsigned long *buf = (unsigned long *)&flctl->done_buff[offset];\n\n\tlen_4align = (rlen + 3) / 4;\n\tfor (i = 0; i < len_4align; i++) {\n\t\twait_wfifo_ready(flctl);\n\t\twritel(cpu_to_be32(buf[i]), FLDTFIFO(flctl));\n\t}\n}\n\nstatic void write_ec_fiforeg(struct sh_flctl *flctl, int rlen,\n\t\t\t\t\t\tunsigned int offset)\n{\n\tint i, len_4align;\n\tunsigned long *buf = (unsigned long *)&flctl->done_buff[offset];\n\n\tlen_4align = (rlen + 3) / 4;\n\n\tfor (i = 0; i < len_4align; i++)\n\t\tbuf[i] = cpu_to_be32(buf[i]);\n\n\t \n\tif (flctl->chan_fifo0_tx && rlen >= 32 &&\n\t\t!flctl_dma_fifo0_transfer(flctl, buf, rlen, DMA_TO_DEVICE))\n\t\t\treturn;\t \n\n\t \n\tfor (i = 0; i < len_4align; i++) {\n\t\twait_wecfifo_ready(flctl);\n\t\twritel(buf[i], FLECFIFO(flctl));\n\t}\n}\n\nstatic void set_cmd_regs(struct mtd_info *mtd, uint32_t cmd, uint32_t flcmcdr_val)\n{\n\tstruct sh_flctl *flctl = mtd_to_flctl(mtd);\n\tuint32_t flcmncr_val = flctl->flcmncr_base & ~SEL_16BIT;\n\tuint32_t flcmdcr_val, addr_len_bytes = 0;\n\n\t \n\tif (flctl->page_size)\n\t\tflcmncr_val |= SNAND_E;\n\telse\n\t\tflcmncr_val &= ~SNAND_E;\n\n\t \n\tflcmdcr_val = DOCMD1_E | DOADR_E;\n\n\t \n\tswitch (cmd) {\n\tcase NAND_CMD_ERASE1:\n\t\taddr_len_bytes = flctl->erase_ADRCNT;\n\t\tflcmdcr_val |= DOCMD2_E;\n\t\tbreak;\n\tcase NAND_CMD_READ0:\n\tcase NAND_CMD_READOOB:\n\tcase NAND_CMD_RNDOUT:\n\t\taddr_len_bytes = flctl->rw_ADRCNT;\n\t\tflcmdcr_val |= CDSRC_E;\n\t\tif (flctl->chip.options & NAND_BUSWIDTH_16)\n\t\t\tflcmncr_val |= SEL_16BIT;\n\t\tbreak;\n\tcase NAND_CMD_SEQIN:\n\t\t \n\t\tflcmdcr_val &= ~DOADR_E;\t \n\t\tbreak;\n\tcase NAND_CMD_PAGEPROG:\n\t\taddr_len_bytes = flctl->rw_ADRCNT;\n\t\tflcmdcr_val |= DOCMD2_E | CDSRC_E | SELRW;\n\t\tif (flctl->chip.options & NAND_BUSWIDTH_16)\n\t\t\tflcmncr_val |= SEL_16BIT;\n\t\tbreak;\n\tcase NAND_CMD_READID:\n\t\tflcmncr_val &= ~SNAND_E;\n\t\tflcmdcr_val |= CDSRC_E;\n\t\taddr_len_bytes = ADRCNT_1;\n\t\tbreak;\n\tcase NAND_CMD_STATUS:\n\tcase NAND_CMD_RESET:\n\t\tflcmncr_val &= ~SNAND_E;\n\t\tflcmdcr_val &= ~(DOADR_E | DOSR_E);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t \n\tflcmdcr_val |= addr_len_bytes;\n\n\t \n\twritel(flcmncr_val, FLCMNCR(flctl));\n\twritel(flcmdcr_val, FLCMDCR(flctl));\n\twritel(flcmcdr_val, FLCMCDR(flctl));\n}\n\nstatic int flctl_read_page_hwecc(struct nand_chip *chip, uint8_t *buf,\n\t\t\t\t int oob_required, int page)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\n\tnand_read_page_op(chip, page, 0, buf, mtd->writesize);\n\tif (oob_required)\n\t\tchip->legacy.read_buf(chip, chip->oob_poi, mtd->oobsize);\n\treturn 0;\n}\n\nstatic int flctl_write_page_hwecc(struct nand_chip *chip, const uint8_t *buf,\n\t\t\t\t  int oob_required, int page)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\n\tnand_prog_page_begin_op(chip, page, 0, buf, mtd->writesize);\n\tchip->legacy.write_buf(chip, chip->oob_poi, mtd->oobsize);\n\treturn nand_prog_page_end_op(chip);\n}\n\nstatic void execmd_read_page_sector(struct mtd_info *mtd, int page_addr)\n{\n\tstruct sh_flctl *flctl = mtd_to_flctl(mtd);\n\tint sector, page_sectors;\n\tenum flctl_ecc_res_t ecc_result;\n\n\tpage_sectors = flctl->page_size ? 4 : 1;\n\n\tset_cmd_regs(mtd, NAND_CMD_READ0,\n\t\t(NAND_CMD_READSTART << 8) | NAND_CMD_READ0);\n\n\twritel(readl(FLCMNCR(flctl)) | ACM_SACCES_MODE | _4ECCCORRECT,\n\t\t FLCMNCR(flctl));\n\twritel(readl(FLCMDCR(flctl)) | page_sectors, FLCMDCR(flctl));\n\twritel(page_addr << 2, FLADR(flctl));\n\n\tempty_fifo(flctl);\n\tstart_translation(flctl);\n\n\tfor (sector = 0; sector < page_sectors; sector++) {\n\t\tread_fiforeg(flctl, 512, 512 * sector);\n\n\t\tecc_result = read_ecfiforeg(flctl,\n\t\t\t&flctl->done_buff[mtd->writesize + 16 * sector],\n\t\t\tsector);\n\n\t\tswitch (ecc_result) {\n\t\tcase FL_REPAIRABLE:\n\t\t\tdev_info(&flctl->pdev->dev,\n\t\t\t\t\"applied ecc on page 0x%x\", page_addr);\n\t\t\tmtd->ecc_stats.corrected++;\n\t\t\tbreak;\n\t\tcase FL_ERROR:\n\t\t\tdev_warn(&flctl->pdev->dev,\n\t\t\t\t\"page 0x%x contains corrupted data\\n\",\n\t\t\t\tpage_addr);\n\t\t\tmtd->ecc_stats.failed++;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t;\n\t\t}\n\t}\n\n\twait_completion(flctl);\n\n\twritel(readl(FLCMNCR(flctl)) & ~(ACM_SACCES_MODE | _4ECCCORRECT),\n\t\t\tFLCMNCR(flctl));\n}\n\nstatic void execmd_read_oob(struct mtd_info *mtd, int page_addr)\n{\n\tstruct sh_flctl *flctl = mtd_to_flctl(mtd);\n\tint page_sectors = flctl->page_size ? 4 : 1;\n\tint i;\n\n\tset_cmd_regs(mtd, NAND_CMD_READ0,\n\t\t(NAND_CMD_READSTART << 8) | NAND_CMD_READ0);\n\n\tempty_fifo(flctl);\n\n\tfor (i = 0; i < page_sectors; i++) {\n\t\tset_addr(mtd, (512 + 16) * i + 512 , page_addr);\n\t\twritel(16, FLDTCNTR(flctl));\n\n\t\tstart_translation(flctl);\n\t\tread_fiforeg(flctl, 16, 16 * i);\n\t\twait_completion(flctl);\n\t}\n}\n\nstatic void execmd_write_page_sector(struct mtd_info *mtd)\n{\n\tstruct sh_flctl *flctl = mtd_to_flctl(mtd);\n\tint page_addr = flctl->seqin_page_addr;\n\tint sector, page_sectors;\n\n\tpage_sectors = flctl->page_size ? 4 : 1;\n\n\tset_cmd_regs(mtd, NAND_CMD_PAGEPROG,\n\t\t\t(NAND_CMD_PAGEPROG << 8) | NAND_CMD_SEQIN);\n\n\tempty_fifo(flctl);\n\twritel(readl(FLCMNCR(flctl)) | ACM_SACCES_MODE, FLCMNCR(flctl));\n\twritel(readl(FLCMDCR(flctl)) | page_sectors, FLCMDCR(flctl));\n\twritel(page_addr << 2, FLADR(flctl));\n\tstart_translation(flctl);\n\n\tfor (sector = 0; sector < page_sectors; sector++) {\n\t\twrite_fiforeg(flctl, 512, 512 * sector);\n\t\twrite_ec_fiforeg(flctl, 16, mtd->writesize + 16 * sector);\n\t}\n\n\twait_completion(flctl);\n\twritel(readl(FLCMNCR(flctl)) & ~ACM_SACCES_MODE, FLCMNCR(flctl));\n}\n\nstatic void execmd_write_oob(struct mtd_info *mtd)\n{\n\tstruct sh_flctl *flctl = mtd_to_flctl(mtd);\n\tint page_addr = flctl->seqin_page_addr;\n\tint sector, page_sectors;\n\n\tpage_sectors = flctl->page_size ? 4 : 1;\n\n\tset_cmd_regs(mtd, NAND_CMD_PAGEPROG,\n\t\t\t(NAND_CMD_PAGEPROG << 8) | NAND_CMD_SEQIN);\n\n\tfor (sector = 0; sector < page_sectors; sector++) {\n\t\tempty_fifo(flctl);\n\t\tset_addr(mtd, sector * 528 + 512, page_addr);\n\t\twritel(16, FLDTCNTR(flctl));\t \n\n\t\tstart_translation(flctl);\n\t\twrite_fiforeg(flctl, 16, 16 * sector);\n\t\twait_completion(flctl);\n\t}\n}\n\nstatic void flctl_cmdfunc(struct nand_chip *chip, unsigned int command,\n\t\t\tint column, int page_addr)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tstruct sh_flctl *flctl = mtd_to_flctl(mtd);\n\tuint32_t read_cmd = 0;\n\n\tpm_runtime_get_sync(&flctl->pdev->dev);\n\n\tflctl->read_bytes = 0;\n\tif (command != NAND_CMD_PAGEPROG)\n\t\tflctl->index = 0;\n\n\tswitch (command) {\n\tcase NAND_CMD_READ1:\n\tcase NAND_CMD_READ0:\n\t\tif (flctl->hwecc) {\n\t\t\t \n\t\t\texecmd_read_page_sector(mtd, page_addr);\n\t\t\tbreak;\n\t\t}\n\t\tif (flctl->page_size)\n\t\t\tset_cmd_regs(mtd, command, (NAND_CMD_READSTART << 8)\n\t\t\t\t| command);\n\t\telse\n\t\t\tset_cmd_regs(mtd, command, command);\n\n\t\tset_addr(mtd, 0, page_addr);\n\n\t\tflctl->read_bytes = mtd->writesize + mtd->oobsize;\n\t\tif (flctl->chip.options & NAND_BUSWIDTH_16)\n\t\t\tcolumn >>= 1;\n\t\tflctl->index += column;\n\t\tgoto read_normal_exit;\n\n\tcase NAND_CMD_READOOB:\n\t\tif (flctl->hwecc) {\n\t\t\t \n\t\t\texecmd_read_oob(mtd, page_addr);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (flctl->page_size) {\n\t\t\tset_cmd_regs(mtd, command, (NAND_CMD_READSTART << 8)\n\t\t\t\t| NAND_CMD_READ0);\n\t\t\tset_addr(mtd, mtd->writesize, page_addr);\n\t\t} else {\n\t\t\tset_cmd_regs(mtd, command, command);\n\t\t\tset_addr(mtd, 0, page_addr);\n\t\t}\n\t\tflctl->read_bytes = mtd->oobsize;\n\t\tgoto read_normal_exit;\n\n\tcase NAND_CMD_RNDOUT:\n\t\tif (flctl->hwecc)\n\t\t\tbreak;\n\n\t\tif (flctl->page_size)\n\t\t\tset_cmd_regs(mtd, command, (NAND_CMD_RNDOUTSTART << 8)\n\t\t\t\t| command);\n\t\telse\n\t\t\tset_cmd_regs(mtd, command, command);\n\n\t\tset_addr(mtd, column, 0);\n\n\t\tflctl->read_bytes = mtd->writesize + mtd->oobsize - column;\n\t\tgoto read_normal_exit;\n\n\tcase NAND_CMD_READID:\n\t\tset_cmd_regs(mtd, command, command);\n\n\t\t \n\t\tif (flctl->chip.options & NAND_BUSWIDTH_16)\n\t\t\tcolumn <<= 1;\n\t\tset_addr(mtd, column, 0);\n\n\t\tflctl->read_bytes = 8;\n\t\twritel(flctl->read_bytes, FLDTCNTR(flctl));  \n\t\tempty_fifo(flctl);\n\t\tstart_translation(flctl);\n\t\tread_fiforeg(flctl, flctl->read_bytes, 0);\n\t\twait_completion(flctl);\n\t\tbreak;\n\n\tcase NAND_CMD_ERASE1:\n\t\tflctl->erase1_page_addr = page_addr;\n\t\tbreak;\n\n\tcase NAND_CMD_ERASE2:\n\t\tset_cmd_regs(mtd, NAND_CMD_ERASE1,\n\t\t\t(command << 8) | NAND_CMD_ERASE1);\n\t\tset_addr(mtd, -1, flctl->erase1_page_addr);\n\t\tstart_translation(flctl);\n\t\twait_completion(flctl);\n\t\tbreak;\n\n\tcase NAND_CMD_SEQIN:\n\t\tif (!flctl->page_size) {\n\t\t\t \n\t\t\tif (column >= mtd->writesize) {\n\t\t\t\tcolumn -= mtd->writesize;\n\t\t\t\tread_cmd = NAND_CMD_READOOB;\n\t\t\t} else if (column < 256) {\n\t\t\t\tread_cmd = NAND_CMD_READ0;\n\t\t\t} else {\n\t\t\t\tcolumn -= 256;\n\t\t\t\tread_cmd = NAND_CMD_READ1;\n\t\t\t}\n\t\t}\n\t\tflctl->seqin_column = column;\n\t\tflctl->seqin_page_addr = page_addr;\n\t\tflctl->seqin_read_cmd = read_cmd;\n\t\tbreak;\n\n\tcase NAND_CMD_PAGEPROG:\n\t\tempty_fifo(flctl);\n\t\tif (!flctl->page_size) {\n\t\t\tset_cmd_regs(mtd, NAND_CMD_SEQIN,\n\t\t\t\t\tflctl->seqin_read_cmd);\n\t\t\tset_addr(mtd, -1, -1);\n\t\t\twritel(0, FLDTCNTR(flctl));\t \n\t\t\tstart_translation(flctl);\n\t\t\twait_completion(flctl);\n\t\t}\n\t\tif (flctl->hwecc) {\n\t\t\t \n\t\t\tif (flctl->seqin_column == mtd->writesize)\n\t\t\t\texecmd_write_oob(mtd);\n\t\t\telse if (!flctl->seqin_column)\n\t\t\t\texecmd_write_page_sector(mtd);\n\t\t\telse\n\t\t\t\tpr_err(\"Invalid address !?\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tset_cmd_regs(mtd, command, (command << 8) | NAND_CMD_SEQIN);\n\t\tset_addr(mtd, flctl->seqin_column, flctl->seqin_page_addr);\n\t\twritel(flctl->index, FLDTCNTR(flctl));\t \n\t\tstart_translation(flctl);\n\t\twrite_fiforeg(flctl, flctl->index, 0);\n\t\twait_completion(flctl);\n\t\tbreak;\n\n\tcase NAND_CMD_STATUS:\n\t\tset_cmd_regs(mtd, command, command);\n\t\tset_addr(mtd, -1, -1);\n\n\t\tflctl->read_bytes = 1;\n\t\twritel(flctl->read_bytes, FLDTCNTR(flctl));  \n\t\tstart_translation(flctl);\n\t\tread_datareg(flctl, 0);  \n\t\tbreak;\n\n\tcase NAND_CMD_RESET:\n\t\tset_cmd_regs(mtd, command, command);\n\t\tset_addr(mtd, -1, -1);\n\n\t\twritel(0, FLDTCNTR(flctl));\t \n\t\tstart_translation(flctl);\n\t\twait_completion(flctl);\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\tgoto runtime_exit;\n\nread_normal_exit:\n\twritel(flctl->read_bytes, FLDTCNTR(flctl));\t \n\tempty_fifo(flctl);\n\tstart_translation(flctl);\n\tread_fiforeg(flctl, flctl->read_bytes, 0);\n\twait_completion(flctl);\nruntime_exit:\n\tpm_runtime_put_sync(&flctl->pdev->dev);\n\treturn;\n}\n\nstatic void flctl_select_chip(struct nand_chip *chip, int chipnr)\n{\n\tstruct sh_flctl *flctl = mtd_to_flctl(nand_to_mtd(chip));\n\tint ret;\n\n\tswitch (chipnr) {\n\tcase -1:\n\t\tflctl->flcmncr_base &= ~CE0_ENABLE;\n\n\t\tpm_runtime_get_sync(&flctl->pdev->dev);\n\t\twritel(flctl->flcmncr_base, FLCMNCR(flctl));\n\n\t\tif (flctl->qos_request) {\n\t\t\tdev_pm_qos_remove_request(&flctl->pm_qos);\n\t\t\tflctl->qos_request = 0;\n\t\t}\n\n\t\tpm_runtime_put_sync(&flctl->pdev->dev);\n\t\tbreak;\n\tcase 0:\n\t\tflctl->flcmncr_base |= CE0_ENABLE;\n\n\t\tif (!flctl->qos_request) {\n\t\t\tret = dev_pm_qos_add_request(&flctl->pdev->dev,\n\t\t\t\t\t\t\t&flctl->pm_qos,\n\t\t\t\t\t\t\tDEV_PM_QOS_RESUME_LATENCY,\n\t\t\t\t\t\t\t100);\n\t\t\tif (ret < 0)\n\t\t\t\tdev_err(&flctl->pdev->dev,\n\t\t\t\t\t\"PM QoS request failed: %d\\n\", ret);\n\t\t\tflctl->qos_request = 1;\n\t\t}\n\n\t\tif (flctl->holden) {\n\t\t\tpm_runtime_get_sync(&flctl->pdev->dev);\n\t\t\twritel(HOLDEN, FLHOLDCR(flctl));\n\t\t\tpm_runtime_put_sync(&flctl->pdev->dev);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}\n\nstatic void flctl_write_buf(struct nand_chip *chip, const uint8_t *buf, int len)\n{\n\tstruct sh_flctl *flctl = mtd_to_flctl(nand_to_mtd(chip));\n\n\tmemcpy(&flctl->done_buff[flctl->index], buf, len);\n\tflctl->index += len;\n}\n\nstatic uint8_t flctl_read_byte(struct nand_chip *chip)\n{\n\tstruct sh_flctl *flctl = mtd_to_flctl(nand_to_mtd(chip));\n\tuint8_t data;\n\n\tdata = flctl->done_buff[flctl->index];\n\tflctl->index++;\n\treturn data;\n}\n\nstatic void flctl_read_buf(struct nand_chip *chip, uint8_t *buf, int len)\n{\n\tstruct sh_flctl *flctl = mtd_to_flctl(nand_to_mtd(chip));\n\n\tmemcpy(buf, &flctl->done_buff[flctl->index], len);\n\tflctl->index += len;\n}\n\nstatic int flctl_chip_attach_chip(struct nand_chip *chip)\n{\n\tu64 targetsize = nanddev_target_size(&chip->base);\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tstruct sh_flctl *flctl = mtd_to_flctl(mtd);\n\n\t \n\tif (chip->options & NAND_BUSWIDTH_16)\n\t\tflctl->flcmncr_base |= SEL_16BIT;\n\n\tif (mtd->writesize == 512) {\n\t\tflctl->page_size = 0;\n\t\tif (targetsize > (32 << 20)) {\n\t\t\t \n\t\t\tflctl->rw_ADRCNT = ADRCNT_4;\n\t\t\tflctl->erase_ADRCNT = ADRCNT_3;\n\t\t} else if (targetsize > (2 << 16)) {\n\t\t\t \n\t\t\tflctl->rw_ADRCNT = ADRCNT_3;\n\t\t\tflctl->erase_ADRCNT = ADRCNT_2;\n\t\t} else {\n\t\t\tflctl->rw_ADRCNT = ADRCNT_2;\n\t\t\tflctl->erase_ADRCNT = ADRCNT_1;\n\t\t}\n\t} else {\n\t\tflctl->page_size = 1;\n\t\tif (targetsize > (128 << 20)) {\n\t\t\t \n\t\t\tflctl->rw_ADRCNT = ADRCNT2_E;\n\t\t\tflctl->erase_ADRCNT = ADRCNT_3;\n\t\t} else if (targetsize > (8 << 16)) {\n\t\t\t \n\t\t\tflctl->rw_ADRCNT = ADRCNT_4;\n\t\t\tflctl->erase_ADRCNT = ADRCNT_2;\n\t\t} else {\n\t\t\tflctl->rw_ADRCNT = ADRCNT_3;\n\t\t\tflctl->erase_ADRCNT = ADRCNT_1;\n\t\t}\n\t}\n\n\tif (flctl->hwecc) {\n\t\tif (mtd->writesize == 512) {\n\t\t\tmtd_set_ooblayout(mtd, &flctl_4secc_oob_smallpage_ops);\n\t\t\tchip->badblock_pattern = &flctl_4secc_smallpage;\n\t\t} else {\n\t\t\tmtd_set_ooblayout(mtd, &flctl_4secc_oob_largepage_ops);\n\t\t\tchip->badblock_pattern = &flctl_4secc_largepage;\n\t\t}\n\n\t\tchip->ecc.size = 512;\n\t\tchip->ecc.bytes = 10;\n\t\tchip->ecc.strength = 4;\n\t\tchip->ecc.read_page = flctl_read_page_hwecc;\n\t\tchip->ecc.write_page = flctl_write_page_hwecc;\n\t\tchip->ecc.engine_type = NAND_ECC_ENGINE_TYPE_ON_HOST;\n\n\t\t \n\t\tflctl->flcmncr_base |= _4ECCEN;\n\t} else {\n\t\tchip->ecc.engine_type = NAND_ECC_ENGINE_TYPE_SOFT;\n\t\tchip->ecc.algo = NAND_ECC_ALGO_HAMMING;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct nand_controller_ops flctl_nand_controller_ops = {\n\t.attach_chip = flctl_chip_attach_chip,\n};\n\nstatic irqreturn_t flctl_handle_flste(int irq, void *dev_id)\n{\n\tstruct sh_flctl *flctl = dev_id;\n\n\tdev_err(&flctl->pdev->dev, \"flste irq: %x\\n\", readl(FLINTDMACR(flctl)));\n\twritel(flctl->flintdmacr_base, FLINTDMACR(flctl));\n\n\treturn IRQ_HANDLED;\n}\n\nstruct flctl_soc_config {\n\tunsigned long flcmncr_val;\n\tunsigned has_hwecc:1;\n\tunsigned use_holden:1;\n};\n\nstatic struct flctl_soc_config flctl_sh7372_config = {\n\t.flcmncr_val = CLK_16B_12L_4H | TYPESEL_SET | SHBUSSEL,\n\t.has_hwecc = 1,\n\t.use_holden = 1,\n};\n\nstatic const struct of_device_id of_flctl_match[] = {\n\t{ .compatible = \"renesas,shmobile-flctl-sh7372\",\n\t\t\t\t.data = &flctl_sh7372_config },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, of_flctl_match);\n\nstatic struct sh_flctl_platform_data *flctl_parse_dt(struct device *dev)\n{\n\tconst struct flctl_soc_config *config;\n\tstruct sh_flctl_platform_data *pdata;\n\n\tconfig = of_device_get_match_data(dev);\n\tif (!config) {\n\t\tdev_err(dev, \"%s: no OF configuration attached\\n\", __func__);\n\t\treturn NULL;\n\t}\n\n\tpdata = devm_kzalloc(dev, sizeof(struct sh_flctl_platform_data),\n\t\t\t\t\t\t\t\tGFP_KERNEL);\n\tif (!pdata)\n\t\treturn NULL;\n\n\t \n\tpdata->flcmncr_val = config->flcmncr_val;\n\tpdata->has_hwecc = config->has_hwecc;\n\tpdata->use_holden = config->use_holden;\n\n\treturn pdata;\n}\n\nstatic int flctl_probe(struct platform_device *pdev)\n{\n\tstruct resource *res;\n\tstruct sh_flctl *flctl;\n\tstruct mtd_info *flctl_mtd;\n\tstruct nand_chip *nand;\n\tstruct sh_flctl_platform_data *pdata;\n\tint ret;\n\tint irq;\n\n\tflctl = devm_kzalloc(&pdev->dev, sizeof(struct sh_flctl), GFP_KERNEL);\n\tif (!flctl)\n\t\treturn -ENOMEM;\n\n\tflctl->reg = devm_platform_get_and_ioremap_resource(pdev, 0, &res);\n\tif (IS_ERR(flctl->reg))\n\t\treturn PTR_ERR(flctl->reg);\n\tflctl->fifo = res->start + 0x24;  \n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tret = devm_request_irq(&pdev->dev, irq, flctl_handle_flste, IRQF_SHARED,\n\t\t\t       \"flste\", flctl);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"request interrupt failed.\\n\");\n\t\treturn ret;\n\t}\n\n\tif (pdev->dev.of_node)\n\t\tpdata = flctl_parse_dt(&pdev->dev);\n\telse\n\t\tpdata = dev_get_platdata(&pdev->dev);\n\n\tif (!pdata) {\n\t\tdev_err(&pdev->dev, \"no setup data defined\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tplatform_set_drvdata(pdev, flctl);\n\tnand = &flctl->chip;\n\tflctl_mtd = nand_to_mtd(nand);\n\tnand_set_flash_node(nand, pdev->dev.of_node);\n\tflctl_mtd->dev.parent = &pdev->dev;\n\tflctl->pdev = pdev;\n\tflctl->hwecc = pdata->has_hwecc;\n\tflctl->holden = pdata->use_holden;\n\tflctl->flcmncr_base = pdata->flcmncr_val;\n\tflctl->flintdmacr_base = flctl->hwecc ? (STERINTE | ECERB) : STERINTE;\n\n\t \n\t \n\tnand->legacy.chip_delay = 20;\n\n\tnand->legacy.read_byte = flctl_read_byte;\n\tnand->legacy.write_buf = flctl_write_buf;\n\tnand->legacy.read_buf = flctl_read_buf;\n\tnand->legacy.select_chip = flctl_select_chip;\n\tnand->legacy.cmdfunc = flctl_cmdfunc;\n\tnand->legacy.set_features = nand_get_set_features_notsupp;\n\tnand->legacy.get_features = nand_get_set_features_notsupp;\n\n\tif (pdata->flcmncr_val & SEL_16BIT)\n\t\tnand->options |= NAND_BUSWIDTH_16;\n\n\tnand->options |= NAND_BBM_FIRSTPAGE | NAND_BBM_SECONDPAGE;\n\n\tpm_runtime_enable(&pdev->dev);\n\tpm_runtime_resume(&pdev->dev);\n\n\tflctl_setup_dma(flctl);\n\n\tnand->legacy.dummy_controller.ops = &flctl_nand_controller_ops;\n\tret = nand_scan(nand, 1);\n\tif (ret)\n\t\tgoto err_chip;\n\n\tret = mtd_device_register(flctl_mtd, pdata->parts, pdata->nr_parts);\n\tif (ret)\n\t\tgoto cleanup_nand;\n\n\treturn 0;\n\ncleanup_nand:\n\tnand_cleanup(nand);\nerr_chip:\n\tflctl_release_dma(flctl);\n\tpm_runtime_disable(&pdev->dev);\n\treturn ret;\n}\n\nstatic void flctl_remove(struct platform_device *pdev)\n{\n\tstruct sh_flctl *flctl = platform_get_drvdata(pdev);\n\tstruct nand_chip *chip = &flctl->chip;\n\tint ret;\n\n\tflctl_release_dma(flctl);\n\tret = mtd_device_unregister(nand_to_mtd(chip));\n\tWARN_ON(ret);\n\tnand_cleanup(chip);\n\tpm_runtime_disable(&pdev->dev);\n}\n\nstatic struct platform_driver flctl_driver = {\n\t.remove_new\t= flctl_remove,\n\t.driver = {\n\t\t.name\t= \"sh_flctl\",\n\t\t.of_match_table = of_flctl_match,\n\t},\n};\n\nmodule_platform_driver_probe(flctl_driver, flctl_probe);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Yoshihiro Shimoda\");\nMODULE_DESCRIPTION(\"SuperH FLCTL driver\");\nMODULE_ALIAS(\"platform:sh_flctl\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}