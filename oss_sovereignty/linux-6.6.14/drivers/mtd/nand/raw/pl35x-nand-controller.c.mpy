{
  "module_name": "pl35x-nand-controller.c",
  "hash_id": "e0db5f3372c67a35ce29f36fba8904580cae8e7fa9cd3cb4bc77c5ac83055d14",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/nand/raw/pl35x-nand-controller.c",
  "human_readable_source": "\n \n\n#include <linux/amba/bus.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/ioport.h>\n#include <linux/iopoll.h>\n#include <linux/irq.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/mtd/mtd.h>\n#include <linux/mtd/rawnand.h>\n#include <linux/mtd/partitions.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/clk.h>\n\n#define PL35X_NANDC_DRIVER_NAME \"pl35x-nand-controller\"\n\n \n#define PL35X_SMC_MEMC_STATUS 0x0\n#define   PL35X_SMC_MEMC_STATUS_RAW_INT_STATUS1\tBIT(6)\n \n#define PL35X_SMC_MEMC_CFG_CLR 0xC\n#define   PL35X_SMC_MEMC_CFG_CLR_INT_DIS_1\tBIT(1)\n#define   PL35X_SMC_MEMC_CFG_CLR_INT_CLR_1\tBIT(4)\n#define   PL35X_SMC_MEMC_CFG_CLR_ECC_INT_DIS_1\tBIT(6)\n \n#define PL35X_SMC_DIRECT_CMD 0x10\n#define   PL35X_SMC_DIRECT_CMD_NAND_CS (0x4 << 23)\n#define   PL35X_SMC_DIRECT_CMD_UPD_REGS (0x2 << 21)\n \n#define PL35X_SMC_CYCLES 0x14\n#define   PL35X_SMC_NAND_TRC_CYCLES(x) ((x) << 0)\n#define   PL35X_SMC_NAND_TWC_CYCLES(x) ((x) << 4)\n#define   PL35X_SMC_NAND_TREA_CYCLES(x) ((x) << 8)\n#define   PL35X_SMC_NAND_TWP_CYCLES(x) ((x) << 11)\n#define   PL35X_SMC_NAND_TCLR_CYCLES(x) ((x) << 14)\n#define   PL35X_SMC_NAND_TAR_CYCLES(x) ((x) << 17)\n#define   PL35X_SMC_NAND_TRR_CYCLES(x) ((x) << 20)\n \n#define PL35X_SMC_OPMODE 0x18\n#define   PL35X_SMC_OPMODE_BW_8 0\n#define   PL35X_SMC_OPMODE_BW_16 1\n \n#define PL35X_SMC_ECC_STATUS 0x400\n#define   PL35X_SMC_ECC_STATUS_ECC_BUSY BIT(6)\n \n#define PL35X_SMC_ECC_CFG 0x404\n#define   PL35X_SMC_ECC_CFG_MODE_MASK 0xC\n#define   PL35X_SMC_ECC_CFG_MODE_BYPASS 0\n#define   PL35X_SMC_ECC_CFG_MODE_APB BIT(2)\n#define   PL35X_SMC_ECC_CFG_MODE_MEM BIT(3)\n#define   PL35X_SMC_ECC_CFG_PGSIZE_MASK\t0x3\n \n#define PL35X_SMC_ECC_CMD1 0x408\n#define   PL35X_SMC_ECC_CMD1_WRITE(x) ((x) << 0)\n#define   PL35X_SMC_ECC_CMD1_READ(x) ((x) << 8)\n#define   PL35X_SMC_ECC_CMD1_READ_END(x) ((x) << 16)\n#define   PL35X_SMC_ECC_CMD1_READ_END_VALID(x) ((x) << 24)\n \n#define PL35X_SMC_ECC_CMD2 0x40C\n#define   PL35X_SMC_ECC_CMD2_WRITE_COL_CHG(x) ((x) << 0)\n#define   PL35X_SMC_ECC_CMD2_READ_COL_CHG(x) ((x) << 8)\n#define   PL35X_SMC_ECC_CMD2_READ_COL_CHG_END(x) ((x) << 16)\n#define   PL35X_SMC_ECC_CMD2_READ_COL_CHG_END_VALID(x) ((x) << 24)\n \n#define PL35X_SMC_ECC_VALUE(x) (0x418 + (4 * (x)))\n#define   PL35X_SMC_ECC_VALUE_IS_CORRECTABLE(x) ((x) & BIT(27))\n#define   PL35X_SMC_ECC_VALUE_HAS_FAILED(x) ((x) & BIT(28))\n#define   PL35X_SMC_ECC_VALUE_IS_VALID(x) ((x) & BIT(30))\n\n \n#define PL35X_SMC_CMD_PHASE 0\n#define PL35X_SMC_CMD_PHASE_CMD0(x) ((x) << 3)\n#define PL35X_SMC_CMD_PHASE_CMD1(x) ((x) << 11)\n#define PL35X_SMC_CMD_PHASE_CMD1_VALID BIT(20)\n#define PL35X_SMC_CMD_PHASE_ADDR(pos, x) ((x) << (8 * (pos)))\n#define PL35X_SMC_CMD_PHASE_NADDRS(x) ((x) << 21)\n#define PL35X_SMC_DATA_PHASE BIT(19)\n#define PL35X_SMC_DATA_PHASE_ECC_LAST BIT(10)\n#define PL35X_SMC_DATA_PHASE_CLEAR_CS BIT(21)\n\n#define PL35X_NAND_MAX_CS 1\n#define PL35X_NAND_LAST_XFER_SZ 4\n#define TO_CYCLES(ps, period_ns) (DIV_ROUND_UP((ps) / 1000, period_ns))\n\n#define PL35X_NAND_ECC_BITS_MASK 0xFFF\n#define PL35X_NAND_ECC_BYTE_OFF_MASK 0x1FF\n#define PL35X_NAND_ECC_BIT_OFF_MASK 0x7\n\nstruct pl35x_nand_timings {\n\tunsigned int t_rc:4;\n\tunsigned int t_wc:4;\n\tunsigned int t_rea:3;\n\tunsigned int t_wp:3;\n\tunsigned int t_clr:3;\n\tunsigned int t_ar:3;\n\tunsigned int t_rr:4;\n\tunsigned int rsvd:8;\n};\n\nstruct pl35x_nand {\n\tstruct list_head node;\n\tstruct nand_chip chip;\n\tunsigned int cs;\n\tunsigned int addr_cycles;\n\tu32 ecc_cfg;\n\tu32 timings;\n};\n\n \nstruct pl35x_nandc {\n\tstruct device *dev;\n\tvoid __iomem *conf_regs;\n\tvoid __iomem *io_regs;\n\tstruct nand_controller controller;\n\tstruct list_head chips;\n\tstruct nand_chip *selected_chip;\n\tunsigned long assigned_cs;\n\tu8 *ecc_buf;\n};\n\nstatic inline struct pl35x_nandc *to_pl35x_nandc(struct nand_controller *ctrl)\n{\n\treturn container_of(ctrl, struct pl35x_nandc, controller);\n}\n\nstatic inline struct pl35x_nand *to_pl35x_nand(struct nand_chip *chip)\n{\n\treturn container_of(chip, struct pl35x_nand, chip);\n}\n\nstatic int pl35x_ecc_ooblayout16_ecc(struct mtd_info *mtd, int section,\n\t\t\t\t     struct mtd_oob_region *oobregion)\n{\n\tstruct nand_chip *chip = mtd_to_nand(mtd);\n\n\tif (section >= chip->ecc.steps)\n\t\treturn -ERANGE;\n\n\toobregion->offset = (section * chip->ecc.bytes);\n\toobregion->length = chip->ecc.bytes;\n\n\treturn 0;\n}\n\nstatic int pl35x_ecc_ooblayout16_free(struct mtd_info *mtd, int section,\n\t\t\t\t      struct mtd_oob_region *oobregion)\n{\n\tstruct nand_chip *chip = mtd_to_nand(mtd);\n\n\tif (section >= chip->ecc.steps)\n\t\treturn -ERANGE;\n\n\toobregion->offset = (section * chip->ecc.bytes) + 8;\n\toobregion->length = 8;\n\n\treturn 0;\n}\n\nstatic const struct mtd_ooblayout_ops pl35x_ecc_ooblayout16_ops = {\n\t.ecc = pl35x_ecc_ooblayout16_ecc,\n\t.free = pl35x_ecc_ooblayout16_free,\n};\n\n \nstatic u8 bbt_pattern[] = { 'B', 'b', 't', '0' };\nstatic u8 mirror_pattern[] = { '1', 't', 'b', 'B' };\n\nstatic struct nand_bbt_descr bbt_main_descr = {\n\t.options = NAND_BBT_LASTBLOCK | NAND_BBT_CREATE | NAND_BBT_WRITE\n\t\t| NAND_BBT_2BIT | NAND_BBT_VERSION | NAND_BBT_PERCHIP,\n\t.offs = 4,\n\t.len = 4,\n\t.veroffs = 20,\n\t.maxblocks = 4,\n\t.pattern = bbt_pattern\n};\n\nstatic struct nand_bbt_descr bbt_mirror_descr = {\n\t.options = NAND_BBT_LASTBLOCK | NAND_BBT_CREATE | NAND_BBT_WRITE\n\t\t| NAND_BBT_2BIT | NAND_BBT_VERSION | NAND_BBT_PERCHIP,\n\t.offs = 4,\n\t.len = 4,\n\t.veroffs = 20,\n\t.maxblocks = 4,\n\t.pattern = mirror_pattern\n};\n\nstatic void pl35x_smc_update_regs(struct pl35x_nandc *nfc)\n{\n\twritel(PL35X_SMC_DIRECT_CMD_NAND_CS |\n\t       PL35X_SMC_DIRECT_CMD_UPD_REGS,\n\t       nfc->conf_regs + PL35X_SMC_DIRECT_CMD);\n}\n\nstatic int pl35x_smc_set_buswidth(struct pl35x_nandc *nfc, unsigned int bw)\n{\n\tif (bw != PL35X_SMC_OPMODE_BW_8 && bw != PL35X_SMC_OPMODE_BW_16)\n\t\treturn -EINVAL;\n\n\twritel(bw, nfc->conf_regs + PL35X_SMC_OPMODE);\n\tpl35x_smc_update_regs(nfc);\n\n\treturn 0;\n}\n\nstatic void pl35x_smc_clear_irq(struct pl35x_nandc *nfc)\n{\n\twritel(PL35X_SMC_MEMC_CFG_CLR_INT_CLR_1,\n\t       nfc->conf_regs + PL35X_SMC_MEMC_CFG_CLR);\n}\n\nstatic int pl35x_smc_wait_for_irq(struct pl35x_nandc *nfc)\n{\n\tu32 reg;\n\tint ret;\n\n\tret = readl_poll_timeout(nfc->conf_regs + PL35X_SMC_MEMC_STATUS, reg,\n\t\t\t\t reg & PL35X_SMC_MEMC_STATUS_RAW_INT_STATUS1,\n\t\t\t\t 10, 1000000);\n\tif (ret)\n\t\tdev_err(nfc->dev,\n\t\t\t\"Timeout polling on NAND controller interrupt (0x%x)\\n\",\n\t\t\treg);\n\n\tpl35x_smc_clear_irq(nfc);\n\n\treturn ret;\n}\n\nstatic int pl35x_smc_wait_for_ecc_done(struct pl35x_nandc *nfc)\n{\n\tu32 reg;\n\tint ret;\n\n\tret = readl_poll_timeout(nfc->conf_regs + PL35X_SMC_ECC_STATUS, reg,\n\t\t\t\t !(reg & PL35X_SMC_ECC_STATUS_ECC_BUSY),\n\t\t\t\t 10, 1000000);\n\tif (ret)\n\t\tdev_err(nfc->dev,\n\t\t\t\"Timeout polling on ECC controller interrupt\\n\");\n\n\treturn ret;\n}\n\nstatic int pl35x_smc_set_ecc_mode(struct pl35x_nandc *nfc,\n\t\t\t\t  struct nand_chip *chip,\n\t\t\t\t  unsigned int mode)\n{\n\tstruct pl35x_nand *plnand;\n\tu32 ecc_cfg;\n\n\tecc_cfg = readl(nfc->conf_regs + PL35X_SMC_ECC_CFG);\n\tecc_cfg &= ~PL35X_SMC_ECC_CFG_MODE_MASK;\n\tecc_cfg |= mode;\n\twritel(ecc_cfg, nfc->conf_regs + PL35X_SMC_ECC_CFG);\n\n\tif (chip) {\n\t\tplnand = to_pl35x_nand(chip);\n\t\tplnand->ecc_cfg = ecc_cfg;\n\t}\n\n\tif (mode != PL35X_SMC_ECC_CFG_MODE_BYPASS)\n\t\treturn pl35x_smc_wait_for_ecc_done(nfc);\n\n\treturn 0;\n}\n\nstatic void pl35x_smc_force_byte_access(struct nand_chip *chip,\n\t\t\t\t\tbool force_8bit)\n{\n\tstruct pl35x_nandc *nfc = to_pl35x_nandc(chip->controller);\n\tint ret;\n\n\tif (!(chip->options & NAND_BUSWIDTH_16))\n\t\treturn;\n\n\tif (force_8bit)\n\t\tret = pl35x_smc_set_buswidth(nfc, PL35X_SMC_OPMODE_BW_8);\n\telse\n\t\tret = pl35x_smc_set_buswidth(nfc, PL35X_SMC_OPMODE_BW_16);\n\n\tif (ret)\n\t\tdev_err(nfc->dev, \"Error in Buswidth\\n\");\n}\n\nstatic void pl35x_nand_select_target(struct nand_chip *chip,\n\t\t\t\t     unsigned int die_nr)\n{\n\tstruct pl35x_nandc *nfc = to_pl35x_nandc(chip->controller);\n\tstruct pl35x_nand *plnand = to_pl35x_nand(chip);\n\n\tif (chip == nfc->selected_chip)\n\t\treturn;\n\n\t \n\twritel(plnand->timings, nfc->conf_regs + PL35X_SMC_CYCLES);\n\tpl35x_smc_update_regs(nfc);\n\n\t \n\twritel(plnand->ecc_cfg, nfc->conf_regs + PL35X_SMC_ECC_CFG);\n\n\tnfc->selected_chip = chip;\n}\n\nstatic void pl35x_nand_read_data_op(struct nand_chip *chip, u8 *in,\n\t\t\t\t    unsigned int len, bool force_8bit,\n\t\t\t\t    unsigned int flags, unsigned int last_flags)\n{\n\tstruct pl35x_nandc *nfc = to_pl35x_nandc(chip->controller);\n\tunsigned int buf_end = len / 4;\n\tunsigned int in_start = round_down(len, 4);\n\tunsigned int data_phase_addr;\n\tu32 *buf32 = (u32 *)in;\n\tu8 *buf8 = (u8 *)in;\n\tint i;\n\n\tif (force_8bit)\n\t\tpl35x_smc_force_byte_access(chip, true);\n\n\tfor (i = 0; i < buf_end; i++) {\n\t\tdata_phase_addr = PL35X_SMC_DATA_PHASE + flags;\n\t\tif (i + 1 == buf_end)\n\t\t\tdata_phase_addr = PL35X_SMC_DATA_PHASE + last_flags;\n\n\t\tbuf32[i] = readl(nfc->io_regs + data_phase_addr);\n\t}\n\n\t \n\tfor (i = in_start; i < len; i++)\n\t\tbuf8[i] = readb(nfc->io_regs + PL35X_SMC_DATA_PHASE);\n\n\tif (force_8bit)\n\t\tpl35x_smc_force_byte_access(chip, false);\n}\n\nstatic void pl35x_nand_write_data_op(struct nand_chip *chip, const u8 *out,\n\t\t\t\t     int len, bool force_8bit,\n\t\t\t\t     unsigned int flags,\n\t\t\t\t     unsigned int last_flags)\n{\n\tstruct pl35x_nandc *nfc = to_pl35x_nandc(chip->controller);\n\tunsigned int buf_end = len / 4;\n\tunsigned int in_start = round_down(len, 4);\n\tconst u32 *buf32 = (const u32 *)out;\n\tconst u8 *buf8 = (const u8 *)out;\n\tunsigned int data_phase_addr;\n\tint i;\n\n\tif (force_8bit)\n\t\tpl35x_smc_force_byte_access(chip, true);\n\n\tfor (i = 0; i < buf_end; i++) {\n\t\tdata_phase_addr = PL35X_SMC_DATA_PHASE + flags;\n\t\tif (i + 1 == buf_end)\n\t\t\tdata_phase_addr = PL35X_SMC_DATA_PHASE + last_flags;\n\n\t\twritel(buf32[i], nfc->io_regs + data_phase_addr);\n\t}\n\n\t \n\tfor (i = in_start; i < len; i++)\n\t\twriteb(buf8[i], nfc->io_regs + PL35X_SMC_DATA_PHASE);\n\n\tif (force_8bit)\n\t\tpl35x_smc_force_byte_access(chip, false);\n}\n\nstatic int pl35x_nand_correct_data(struct pl35x_nandc *nfc, unsigned char *buf,\n\t\t\t\t   unsigned char *read_ecc,\n\t\t\t\t   unsigned char *calc_ecc)\n{\n\tunsigned short ecc_odd, ecc_even, read_ecc_lower, read_ecc_upper;\n\tunsigned short calc_ecc_lower, calc_ecc_upper;\n\tunsigned short byte_addr, bit_addr;\n\n\tread_ecc_lower = (read_ecc[0] | (read_ecc[1] << 8)) &\n\t\t\t PL35X_NAND_ECC_BITS_MASK;\n\tread_ecc_upper = ((read_ecc[1] >> 4) | (read_ecc[2] << 4)) &\n\t\t\t PL35X_NAND_ECC_BITS_MASK;\n\n\tcalc_ecc_lower = (calc_ecc[0] | (calc_ecc[1] << 8)) &\n\t\t\t PL35X_NAND_ECC_BITS_MASK;\n\tcalc_ecc_upper = ((calc_ecc[1] >> 4) | (calc_ecc[2] << 4)) &\n\t\t\t PL35X_NAND_ECC_BITS_MASK;\n\n\tecc_odd = read_ecc_lower ^ calc_ecc_lower;\n\tecc_even = read_ecc_upper ^ calc_ecc_upper;\n\n\t \n\tif (likely(!ecc_odd && !ecc_even))\n\t\treturn 0;\n\n\t \n\tif (ecc_odd == (~ecc_even & PL35X_NAND_ECC_BITS_MASK)) {\n\t\t \n\t\tbyte_addr = (ecc_odd >> 3) & PL35X_NAND_ECC_BYTE_OFF_MASK;\n\t\t \n\t\tbit_addr = ecc_odd & PL35X_NAND_ECC_BIT_OFF_MASK;\n\t\t \n\t\tbuf[byte_addr] ^= (BIT(bit_addr));\n\n\t\treturn 1;\n\t}\n\n\t \n\tif (hweight32(ecc_odd | ecc_even) == 1)\n\t\treturn 1;\n\n\treturn -EBADMSG;\n}\n\nstatic void pl35x_nand_ecc_reg_to_array(struct nand_chip *chip, u32 ecc_reg,\n\t\t\t\t\tu8 *ecc_array)\n{\n\tu32 ecc_value = ~ecc_reg;\n\tunsigned int ecc_byte;\n\n\tfor (ecc_byte = 0; ecc_byte < chip->ecc.bytes; ecc_byte++)\n\t\tecc_array[ecc_byte] = ecc_value >> (8 * ecc_byte);\n}\n\nstatic int pl35x_nand_read_eccbytes(struct pl35x_nandc *nfc,\n\t\t\t\t    struct nand_chip *chip, u8 *read_ecc)\n{\n\tu32 ecc_value;\n\tint chunk;\n\n\tfor (chunk = 0; chunk < chip->ecc.steps;\n\t     chunk++, read_ecc += chip->ecc.bytes) {\n\t\tecc_value = readl(nfc->conf_regs + PL35X_SMC_ECC_VALUE(chunk));\n\t\tif (!PL35X_SMC_ECC_VALUE_IS_VALID(ecc_value))\n\t\t\treturn -EINVAL;\n\n\t\tpl35x_nand_ecc_reg_to_array(chip, ecc_value, read_ecc);\n\t}\n\n\treturn 0;\n}\n\nstatic int pl35x_nand_recover_data_hwecc(struct pl35x_nandc *nfc,\n\t\t\t\t\t struct nand_chip *chip, u8 *data,\n\t\t\t\t\t u8 *read_ecc)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tunsigned int max_bitflips = 0, chunk;\n\tu8 calc_ecc[3];\n\tu32 ecc_value;\n\tint stats;\n\n\tfor (chunk = 0; chunk < chip->ecc.steps;\n\t     chunk++, data += chip->ecc.size, read_ecc += chip->ecc.bytes) {\n\t\t \n\t\tecc_value = readl(nfc->conf_regs + PL35X_SMC_ECC_VALUE(chunk));\n\n\t\tif (!PL35X_SMC_ECC_VALUE_IS_VALID(ecc_value))\n\t\t\treturn -EINVAL;\n\n\t\tif (PL35X_SMC_ECC_VALUE_HAS_FAILED(ecc_value)) {\n\t\t\tmtd->ecc_stats.failed++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tpl35x_nand_ecc_reg_to_array(chip, ecc_value, calc_ecc);\n\t\tstats = pl35x_nand_correct_data(nfc, data, read_ecc, calc_ecc);\n\t\tif (stats < 0) {\n\t\t\tmtd->ecc_stats.failed++;\n\t\t} else {\n\t\t\tmtd->ecc_stats.corrected += stats;\n\t\t\tmax_bitflips = max_t(unsigned int, max_bitflips, stats);\n\t\t}\n\t}\n\n\treturn max_bitflips;\n}\n\nstatic int pl35x_nand_write_page_hwecc(struct nand_chip *chip,\n\t\t\t\t       const u8 *buf, int oob_required,\n\t\t\t\t       int page)\n{\n\tstruct pl35x_nandc *nfc = to_pl35x_nandc(chip->controller);\n\tstruct pl35x_nand *plnand = to_pl35x_nand(chip);\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tunsigned int first_row = (mtd->writesize <= 512) ? 1 : 2;\n\tunsigned int nrows = plnand->addr_cycles;\n\tu32 addr1 = 0, addr2 = 0, row;\n\tu32 cmd_addr;\n\tint i, ret;\n\tu8 status;\n\n\tret = pl35x_smc_set_ecc_mode(nfc, chip, PL35X_SMC_ECC_CFG_MODE_APB);\n\tif (ret)\n\t\treturn ret;\n\n\tcmd_addr = PL35X_SMC_CMD_PHASE |\n\t\t   PL35X_SMC_CMD_PHASE_NADDRS(plnand->addr_cycles) |\n\t\t   PL35X_SMC_CMD_PHASE_CMD0(NAND_CMD_SEQIN);\n\n\tfor (i = 0, row = first_row; row < nrows; i++, row++) {\n\t\tu8 addr = page >> ((i * 8) & 0xFF);\n\n\t\tif (row < 4)\n\t\t\taddr1 |= PL35X_SMC_CMD_PHASE_ADDR(row, addr);\n\t\telse\n\t\t\taddr2 |= PL35X_SMC_CMD_PHASE_ADDR(row - 4, addr);\n\t}\n\n\t \n\twritel(addr1, nfc->io_regs + cmd_addr);\n\tif (plnand->addr_cycles > 4)\n\t\twritel(addr2, nfc->io_regs + cmd_addr);\n\n\t \n\tpl35x_nand_write_data_op(chip, buf, mtd->writesize, false,\n\t\t\t\t 0, PL35X_SMC_DATA_PHASE_ECC_LAST);\n\tret = pl35x_smc_wait_for_ecc_done(nfc);\n\tif (ret)\n\t\tgoto disable_ecc_engine;\n\n\t \n\tret = pl35x_nand_read_eccbytes(nfc, chip, nfc->ecc_buf);\n\tif (ret)\n\t\tgoto disable_ecc_engine;\n\n\tif (!oob_required)\n\t\tmemset(chip->oob_poi, 0xFF, mtd->oobsize);\n\n\tret = mtd_ooblayout_set_eccbytes(mtd, nfc->ecc_buf, chip->oob_poi,\n\t\t\t\t\t 0, chip->ecc.total);\n\tif (ret)\n\t\tgoto disable_ecc_engine;\n\n\t \n\tpl35x_nand_write_data_op(chip, chip->oob_poi, mtd->oobsize, false, 0,\n\t\t\t\t PL35X_SMC_CMD_PHASE_CMD1(NAND_CMD_PAGEPROG) |\n\t\t\t\t PL35X_SMC_CMD_PHASE_CMD1_VALID |\n\t\t\t\t PL35X_SMC_DATA_PHASE_CLEAR_CS);\n\tret = pl35x_smc_wait_for_irq(nfc);\n\tif (ret)\n\t\tgoto disable_ecc_engine;\n\n\t \n\tret = nand_status_op(chip, &status);\n\tif (ret)\n\t\tgoto disable_ecc_engine;\n\n\tif (status & NAND_STATUS_FAIL)\n\t\tret = -EIO;\n\ndisable_ecc_engine:\n\tpl35x_smc_set_ecc_mode(nfc, chip, PL35X_SMC_ECC_CFG_MODE_BYPASS);\n\n\treturn ret;\n}\n\n \nstatic int pl35x_nand_read_page_hwecc(struct nand_chip *chip,\n\t\t\t\t      u8 *buf, int oob_required, int page)\n{\n\tconst struct nand_sdr_timings *sdr =\n\t\tnand_get_sdr_timings(nand_get_interface_config(chip));\n\tstruct pl35x_nandc *nfc = to_pl35x_nandc(chip->controller);\n\tstruct pl35x_nand *plnand = to_pl35x_nand(chip);\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tunsigned int first_row = (mtd->writesize <= 512) ? 1 : 2;\n\tunsigned int nrows = plnand->addr_cycles;\n\tunsigned int addr1 = 0, addr2 = 0, row;\n\tu32 cmd_addr;\n\tint i, ret;\n\n\tret = pl35x_smc_set_ecc_mode(nfc, chip, PL35X_SMC_ECC_CFG_MODE_APB);\n\tif (ret)\n\t\treturn ret;\n\n\tcmd_addr = PL35X_SMC_CMD_PHASE |\n\t\t   PL35X_SMC_CMD_PHASE_NADDRS(plnand->addr_cycles) |\n\t\t   PL35X_SMC_CMD_PHASE_CMD0(NAND_CMD_READ0) |\n\t\t   PL35X_SMC_CMD_PHASE_CMD1(NAND_CMD_READSTART) |\n\t\t   PL35X_SMC_CMD_PHASE_CMD1_VALID;\n\n\tfor (i = 0, row = first_row; row < nrows; i++, row++) {\n\t\tu8 addr = page >> ((i * 8) & 0xFF);\n\n\t\tif (row < 4)\n\t\t\taddr1 |= PL35X_SMC_CMD_PHASE_ADDR(row, addr);\n\t\telse\n\t\t\taddr2 |= PL35X_SMC_CMD_PHASE_ADDR(row - 4, addr);\n\t}\n\n\t \n\twritel(addr1, nfc->io_regs + cmd_addr);\n\tif (plnand->addr_cycles > 4)\n\t\twritel(addr2, nfc->io_regs + cmd_addr);\n\n\t \n\tndelay(PSEC_TO_NSEC(sdr->tRR_min));\n\tret = pl35x_smc_wait_for_irq(nfc);\n\tif (ret)\n\t\tgoto disable_ecc_engine;\n\n\t \n\tpl35x_nand_read_data_op(chip, buf, mtd->writesize, false,\n\t\t\t\t0, PL35X_SMC_DATA_PHASE_ECC_LAST);\n\tret = pl35x_smc_wait_for_ecc_done(nfc);\n\tif (ret)\n\t\tgoto disable_ecc_engine;\n\n\t \n\tpl35x_nand_read_data_op(chip, chip->oob_poi, mtd->oobsize, false,\n\t\t\t\t0, PL35X_SMC_DATA_PHASE_CLEAR_CS);\n\tret = mtd_ooblayout_get_eccbytes(mtd, nfc->ecc_buf, chip->oob_poi, 0,\n\t\t\t\t\t chip->ecc.total);\n\tif (ret)\n\t\tgoto disable_ecc_engine;\n\n\tpl35x_smc_set_ecc_mode(nfc, chip, PL35X_SMC_ECC_CFG_MODE_BYPASS);\n\n\t \n\treturn pl35x_nand_recover_data_hwecc(nfc, chip, buf, nfc->ecc_buf);\n\ndisable_ecc_engine:\n\tpl35x_smc_set_ecc_mode(nfc, chip, PL35X_SMC_ECC_CFG_MODE_BYPASS);\n\n\treturn ret;\n}\n\nstatic int pl35x_nand_exec_op(struct nand_chip *chip,\n\t\t\t      const struct nand_subop *subop)\n{\n\tstruct pl35x_nandc *nfc = to_pl35x_nandc(chip->controller);\n\tconst struct nand_op_instr *instr, *data_instr = NULL;\n\tunsigned int rdy_tim_ms = 0, naddrs = 0, cmds = 0, last_flags = 0;\n\tu32 addr1 = 0, addr2 = 0, cmd0 = 0, cmd1 = 0, cmd_addr = 0;\n\tunsigned int op_id, len, offset, rdy_del_ns;\n\tint last_instr_type = -1;\n\tbool cmd1_valid = false;\n\tconst u8 *addrs;\n\tint i, ret;\n\n\tfor (op_id = 0; op_id < subop->ninstrs; op_id++) {\n\t\tinstr = &subop->instrs[op_id];\n\n\t\tswitch (instr->type) {\n\t\tcase NAND_OP_CMD_INSTR:\n\t\t\tif (!cmds) {\n\t\t\t\tcmd0 = PL35X_SMC_CMD_PHASE_CMD0(instr->ctx.cmd.opcode);\n\t\t\t} else {\n\t\t\t\tcmd1 = PL35X_SMC_CMD_PHASE_CMD1(instr->ctx.cmd.opcode);\n\t\t\t\tif (last_instr_type != NAND_OP_DATA_OUT_INSTR)\n\t\t\t\t\tcmd1_valid = true;\n\t\t\t}\n\t\t\tcmds++;\n\t\t\tbreak;\n\n\t\tcase NAND_OP_ADDR_INSTR:\n\t\t\toffset = nand_subop_get_addr_start_off(subop, op_id);\n\t\t\tnaddrs = nand_subop_get_num_addr_cyc(subop, op_id);\n\t\t\taddrs = &instr->ctx.addr.addrs[offset];\n\t\t\tcmd_addr |= PL35X_SMC_CMD_PHASE_NADDRS(naddrs);\n\n\t\t\tfor (i = offset; i < naddrs; i++) {\n\t\t\t\tif (i < 4)\n\t\t\t\t\taddr1 |= PL35X_SMC_CMD_PHASE_ADDR(i, addrs[i]);\n\t\t\t\telse\n\t\t\t\t\taddr2 |= PL35X_SMC_CMD_PHASE_ADDR(i - 4, addrs[i]);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase NAND_OP_DATA_IN_INSTR:\n\t\tcase NAND_OP_DATA_OUT_INSTR:\n\t\t\tdata_instr = instr;\n\t\t\tlen = nand_subop_get_data_len(subop, op_id);\n\t\t\tbreak;\n\n\t\tcase NAND_OP_WAITRDY_INSTR:\n\t\t\trdy_tim_ms = instr->ctx.waitrdy.timeout_ms;\n\t\t\trdy_del_ns = instr->delay_ns;\n\t\t\tbreak;\n\t\t}\n\n\t\tlast_instr_type = instr->type;\n\t}\n\n\t \n\tcmd_addr |= PL35X_SMC_CMD_PHASE | cmd0 | cmd1 |\n\t\t    (cmd1_valid ? PL35X_SMC_CMD_PHASE_CMD1_VALID : 0);\n\twritel(addr1, nfc->io_regs + cmd_addr);\n\tif (naddrs > 4)\n\t\twritel(addr2, nfc->io_regs + cmd_addr);\n\n\t \n\tif (data_instr && data_instr->type == NAND_OP_DATA_OUT_INSTR) {\n\t\tlast_flags = PL35X_SMC_DATA_PHASE_CLEAR_CS;\n\t\tif (cmds == 2)\n\t\t\tlast_flags |= cmd1 | PL35X_SMC_CMD_PHASE_CMD1_VALID;\n\n\t\tpl35x_nand_write_data_op(chip, data_instr->ctx.data.buf.out,\n\t\t\t\t\t len, data_instr->ctx.data.force_8bit,\n\t\t\t\t\t 0, last_flags);\n\t}\n\n\tif (rdy_tim_ms) {\n\t\tndelay(rdy_del_ns);\n\t\tret = pl35x_smc_wait_for_irq(nfc);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (data_instr && data_instr->type == NAND_OP_DATA_IN_INSTR)\n\t\tpl35x_nand_read_data_op(chip, data_instr->ctx.data.buf.in,\n\t\t\t\t\tlen, data_instr->ctx.data.force_8bit,\n\t\t\t\t\t0, PL35X_SMC_DATA_PHASE_CLEAR_CS);\n\n\treturn 0;\n}\n\nstatic const struct nand_op_parser pl35x_nandc_op_parser = NAND_OP_PARSER(\n\tNAND_OP_PARSER_PATTERN(pl35x_nand_exec_op,\n\t\t\t       NAND_OP_PARSER_PAT_CMD_ELEM(true),\n\t\t\t       NAND_OP_PARSER_PAT_ADDR_ELEM(true, 7),\n\t\t\t       NAND_OP_PARSER_PAT_CMD_ELEM(true),\n\t\t\t       NAND_OP_PARSER_PAT_WAITRDY_ELEM(true),\n\t\t\t       NAND_OP_PARSER_PAT_DATA_IN_ELEM(true, 2112)),\n\tNAND_OP_PARSER_PATTERN(pl35x_nand_exec_op,\n\t\t\t       NAND_OP_PARSER_PAT_CMD_ELEM(false),\n\t\t\t       NAND_OP_PARSER_PAT_ADDR_ELEM(false, 7),\n\t\t\t       NAND_OP_PARSER_PAT_DATA_OUT_ELEM(false, 2112),\n\t\t\t       NAND_OP_PARSER_PAT_CMD_ELEM(false),\n\t\t\t       NAND_OP_PARSER_PAT_WAITRDY_ELEM(true)),\n\tNAND_OP_PARSER_PATTERN(pl35x_nand_exec_op,\n\t\t\t       NAND_OP_PARSER_PAT_CMD_ELEM(false),\n\t\t\t       NAND_OP_PARSER_PAT_ADDR_ELEM(false, 7),\n\t\t\t       NAND_OP_PARSER_PAT_DATA_OUT_ELEM(false, 2112),\n\t\t\t       NAND_OP_PARSER_PAT_CMD_ELEM(true),\n\t\t\t       NAND_OP_PARSER_PAT_WAITRDY_ELEM(true)),\n\t);\n\nstatic int pl35x_nfc_exec_op(struct nand_chip *chip,\n\t\t\t     const struct nand_operation *op,\n\t\t\t     bool check_only)\n{\n\tif (!check_only)\n\t\tpl35x_nand_select_target(chip, op->cs);\n\n\treturn nand_op_parser_exec_op(chip, &pl35x_nandc_op_parser,\n\t\t\t\t      op, check_only);\n}\n\nstatic int pl35x_nfc_setup_interface(struct nand_chip *chip, int cs,\n\t\t\t\t     const struct nand_interface_config *conf)\n{\n\tstruct pl35x_nandc *nfc = to_pl35x_nandc(chip->controller);\n\tstruct pl35x_nand *plnand = to_pl35x_nand(chip);\n\tstruct pl35x_nand_timings tmgs = {};\n\tconst struct nand_sdr_timings *sdr;\n\tunsigned int period_ns, val;\n\tstruct clk *mclk;\n\n\tsdr = nand_get_sdr_timings(conf);\n\tif (IS_ERR(sdr))\n\t\treturn PTR_ERR(sdr);\n\n\tmclk = of_clk_get_by_name(nfc->dev->parent->of_node, \"memclk\");\n\tif (IS_ERR(mclk)) {\n\t\tdev_err(nfc->dev, \"Failed to retrieve SMC memclk\\n\");\n\t\treturn PTR_ERR(mclk);\n\t}\n\n\t \n\tperiod_ns = NSEC_PER_SEC / clk_get_rate(mclk);\n\n\t \n\tval = TO_CYCLES(sdr->tRC_min, period_ns);\n\tif (sdr->tRC_min <= 20000)\n\t\tval++;\n\n\ttmgs.t_rc = val;\n\tif (tmgs.t_rc != val || tmgs.t_rc < 2)\n\t\treturn -EINVAL;\n\n\tval = TO_CYCLES(sdr->tWC_min, period_ns);\n\ttmgs.t_wc = val;\n\tif (tmgs.t_wc != val || tmgs.t_wc < 2)\n\t\treturn -EINVAL;\n\n\t \n\ttmgs.t_rea = 1;\n\n\tval = TO_CYCLES(sdr->tWP_min, period_ns);\n\ttmgs.t_wp = val;\n\tif (tmgs.t_wp != val || tmgs.t_wp < 1)\n\t\treturn -EINVAL;\n\n\tval = TO_CYCLES(sdr->tCLR_min, period_ns);\n\ttmgs.t_clr = val;\n\tif (tmgs.t_clr != val)\n\t\treturn -EINVAL;\n\n\tval = TO_CYCLES(sdr->tAR_min, period_ns);\n\ttmgs.t_ar = val;\n\tif (tmgs.t_ar != val)\n\t\treturn -EINVAL;\n\n\tval = TO_CYCLES(sdr->tRR_min, period_ns);\n\ttmgs.t_rr = val;\n\tif (tmgs.t_rr != val)\n\t\treturn -EINVAL;\n\n\tif (cs == NAND_DATA_IFACE_CHECK_ONLY)\n\t\treturn 0;\n\n\tplnand->timings = PL35X_SMC_NAND_TRC_CYCLES(tmgs.t_rc) |\n\t\t\t  PL35X_SMC_NAND_TWC_CYCLES(tmgs.t_wc) |\n\t\t\t  PL35X_SMC_NAND_TREA_CYCLES(tmgs.t_rea) |\n\t\t\t  PL35X_SMC_NAND_TWP_CYCLES(tmgs.t_wp) |\n\t\t\t  PL35X_SMC_NAND_TCLR_CYCLES(tmgs.t_clr) |\n\t\t\t  PL35X_SMC_NAND_TAR_CYCLES(tmgs.t_ar) |\n\t\t\t  PL35X_SMC_NAND_TRR_CYCLES(tmgs.t_rr);\n\n\treturn 0;\n}\n\nstatic void pl35x_smc_set_ecc_pg_size(struct pl35x_nandc *nfc,\n\t\t\t\t      struct nand_chip *chip,\n\t\t\t\t      unsigned int pg_sz)\n{\n\tstruct pl35x_nand *plnand = to_pl35x_nand(chip);\n\tu32 sz;\n\n\tswitch (pg_sz) {\n\tcase SZ_512:\n\t\tsz = 1;\n\t\tbreak;\n\tcase SZ_1K:\n\t\tsz = 2;\n\t\tbreak;\n\tcase SZ_2K:\n\t\tsz = 3;\n\t\tbreak;\n\tdefault:\n\t\tsz = 0;\n\t\tbreak;\n\t}\n\n\tplnand->ecc_cfg = readl(nfc->conf_regs + PL35X_SMC_ECC_CFG);\n\tplnand->ecc_cfg &= ~PL35X_SMC_ECC_CFG_PGSIZE_MASK;\n\tplnand->ecc_cfg |= sz;\n\twritel(plnand->ecc_cfg, nfc->conf_regs + PL35X_SMC_ECC_CFG);\n}\n\nstatic int pl35x_nand_init_hw_ecc_controller(struct pl35x_nandc *nfc,\n\t\t\t\t\t     struct nand_chip *chip)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tint ret = 0;\n\n\tif (mtd->writesize < SZ_512 || mtd->writesize > SZ_2K) {\n\t\tdev_err(nfc->dev,\n\t\t\t\"The hardware ECC engine is limited to pages up to 2kiB\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tchip->ecc.strength = 1;\n\tchip->ecc.bytes = 3;\n\tchip->ecc.size = SZ_512;\n\tchip->ecc.steps = mtd->writesize / chip->ecc.size;\n\tchip->ecc.read_page = pl35x_nand_read_page_hwecc;\n\tchip->ecc.write_page = pl35x_nand_write_page_hwecc;\n\tchip->ecc.write_page_raw = nand_monolithic_write_page_raw;\n\tpl35x_smc_set_ecc_pg_size(nfc, chip, mtd->writesize);\n\n\tnfc->ecc_buf = devm_kmalloc(nfc->dev, chip->ecc.bytes * chip->ecc.steps,\n\t\t\t\t    GFP_KERNEL);\n\tif (!nfc->ecc_buf)\n\t\treturn -ENOMEM;\n\n\tswitch (mtd->oobsize) {\n\tcase 16:\n\t\t \n\t\tmtd_set_ooblayout(mtd, &pl35x_ecc_ooblayout16_ops);\n\t\tchip->bbt_options |= NAND_BBT_NO_OOB_BBM;\n\t\tbreak;\n\tcase 64:\n\t\tmtd_set_ooblayout(mtd, nand_get_large_page_ooblayout());\n\t\tbreak;\n\tdefault:\n\t\tdev_err(nfc->dev, \"Unsupported OOB size\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn ret;\n}\n\nstatic int pl35x_nand_attach_chip(struct nand_chip *chip)\n{\n\tconst struct nand_ecc_props *requirements =\n\t\tnanddev_get_ecc_requirements(&chip->base);\n\tstruct pl35x_nandc *nfc = to_pl35x_nandc(chip->controller);\n\tstruct pl35x_nand *plnand = to_pl35x_nand(chip);\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tint ret;\n\n\tif (chip->ecc.engine_type != NAND_ECC_ENGINE_TYPE_NONE &&\n\t    (!chip->ecc.size || !chip->ecc.strength)) {\n\t\tif (requirements->step_size && requirements->strength) {\n\t\t\tchip->ecc.size = requirements->step_size;\n\t\t\tchip->ecc.strength = requirements->strength;\n\t\t} else {\n\t\t\tdev_info(nfc->dev,\n\t\t\t\t \"No minimum ECC strength, using 1b/512B\\n\");\n\t\t\tchip->ecc.size = 512;\n\t\t\tchip->ecc.strength = 1;\n\t\t}\n\t}\n\n\tif (mtd->writesize <= SZ_512)\n\t\tplnand->addr_cycles = 1;\n\telse\n\t\tplnand->addr_cycles = 2;\n\n\tif (chip->options & NAND_ROW_ADDR_3)\n\t\tplnand->addr_cycles += 3;\n\telse\n\t\tplnand->addr_cycles += 2;\n\n\tswitch (chip->ecc.engine_type) {\n\tcase NAND_ECC_ENGINE_TYPE_ON_DIE:\n\t\t \n\t\tchip->bbt_td = &bbt_main_descr;\n\t\tchip->bbt_md = &bbt_mirror_descr;\n\t\tfallthrough;\n\tcase NAND_ECC_ENGINE_TYPE_NONE:\n\tcase NAND_ECC_ENGINE_TYPE_SOFT:\n\t\tbreak;\n\tcase NAND_ECC_ENGINE_TYPE_ON_HOST:\n\t\tret = pl35x_nand_init_hw_ecc_controller(nfc, chip);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(nfc->dev, \"Unsupported ECC mode: %d\\n\",\n\t\t\tchip->ecc.engine_type);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct nand_controller_ops pl35x_nandc_ops = {\n\t.attach_chip = pl35x_nand_attach_chip,\n\t.exec_op = pl35x_nfc_exec_op,\n\t.setup_interface = pl35x_nfc_setup_interface,\n};\n\nstatic int pl35x_nand_reset_state(struct pl35x_nandc *nfc)\n{\n\tint ret;\n\n\t \n\twritel(PL35X_SMC_MEMC_CFG_CLR_INT_CLR_1 |\n\t       PL35X_SMC_MEMC_CFG_CLR_ECC_INT_DIS_1 |\n\t       PL35X_SMC_MEMC_CFG_CLR_INT_DIS_1,\n\t       nfc->conf_regs + PL35X_SMC_MEMC_CFG_CLR);\n\n\t \n\tret = pl35x_smc_set_buswidth(nfc, PL35X_SMC_OPMODE_BW_8);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = pl35x_smc_set_ecc_mode(nfc, NULL, PL35X_SMC_ECC_CFG_MODE_BYPASS);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\twritel(PL35X_SMC_ECC_CMD1_WRITE(NAND_CMD_SEQIN) |\n\t       PL35X_SMC_ECC_CMD1_READ(NAND_CMD_READ0) |\n\t       PL35X_SMC_ECC_CMD1_READ_END(NAND_CMD_READSTART) |\n\t       PL35X_SMC_ECC_CMD1_READ_END_VALID(NAND_CMD_READ1),\n\t       nfc->conf_regs + PL35X_SMC_ECC_CMD1);\n\twritel(PL35X_SMC_ECC_CMD2_WRITE_COL_CHG(NAND_CMD_RNDIN) |\n\t       PL35X_SMC_ECC_CMD2_READ_COL_CHG(NAND_CMD_RNDOUT) |\n\t       PL35X_SMC_ECC_CMD2_READ_COL_CHG_END(NAND_CMD_RNDOUTSTART) |\n\t       PL35X_SMC_ECC_CMD2_READ_COL_CHG_END_VALID(NAND_CMD_READ1),\n\t       nfc->conf_regs + PL35X_SMC_ECC_CMD2);\n\n\treturn 0;\n}\n\nstatic int pl35x_nand_chip_init(struct pl35x_nandc *nfc,\n\t\t\t\tstruct device_node *np)\n{\n\tstruct pl35x_nand *plnand;\n\tstruct nand_chip *chip;\n\tstruct mtd_info *mtd;\n\tint cs, ret;\n\n\tplnand = devm_kzalloc(nfc->dev, sizeof(*plnand), GFP_KERNEL);\n\tif (!plnand)\n\t\treturn -ENOMEM;\n\n\tret = of_property_read_u32(np, \"reg\", &cs);\n\tif (ret)\n\t\treturn ret;\n\n\tif (cs >= PL35X_NAND_MAX_CS) {\n\t\tdev_err(nfc->dev, \"Wrong CS %d\\n\", cs);\n\t\treturn -EINVAL;\n\t}\n\n\tif (test_and_set_bit(cs, &nfc->assigned_cs)) {\n\t\tdev_err(nfc->dev, \"Already assigned CS %d\\n\", cs);\n\t\treturn -EINVAL;\n\t}\n\n\tplnand->cs = cs;\n\n\tchip = &plnand->chip;\n\tchip->options = NAND_BUSWIDTH_AUTO | NAND_USES_DMA | NAND_NO_SUBPAGE_WRITE;\n\tchip->bbt_options = NAND_BBT_USE_FLASH;\n\tchip->controller = &nfc->controller;\n\tmtd = nand_to_mtd(chip);\n\tmtd->dev.parent = nfc->dev;\n\tnand_set_flash_node(chip, np);\n\tif (!mtd->name) {\n\t\tmtd->name = devm_kasprintf(nfc->dev, GFP_KERNEL,\n\t\t\t\t\t   \"%s\", PL35X_NANDC_DRIVER_NAME);\n\t\tif (!mtd->name) {\n\t\t\tdev_err(nfc->dev, \"Failed to allocate mtd->name\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\tret = nand_scan(chip, 1);\n\tif (ret)\n\t\treturn ret;\n\n\tret = mtd_device_register(mtd, NULL, 0);\n\tif (ret) {\n\t\tnand_cleanup(chip);\n\t\treturn ret;\n\t}\n\n\tlist_add_tail(&plnand->node, &nfc->chips);\n\n\treturn ret;\n}\n\nstatic void pl35x_nand_chips_cleanup(struct pl35x_nandc *nfc)\n{\n\tstruct pl35x_nand *plnand, *tmp;\n\tstruct nand_chip *chip;\n\tint ret;\n\n\tlist_for_each_entry_safe(plnand, tmp, &nfc->chips, node) {\n\t\tchip = &plnand->chip;\n\t\tret = mtd_device_unregister(nand_to_mtd(chip));\n\t\tWARN_ON(ret);\n\t\tnand_cleanup(chip);\n\t\tlist_del(&plnand->node);\n\t}\n}\n\nstatic int pl35x_nand_chips_init(struct pl35x_nandc *nfc)\n{\n\tstruct device_node *np = nfc->dev->of_node, *nand_np;\n\tint nchips = of_get_child_count(np);\n\tint ret;\n\n\tif (!nchips || nchips > PL35X_NAND_MAX_CS) {\n\t\tdev_err(nfc->dev, \"Incorrect number of NAND chips (%d)\\n\",\n\t\t\tnchips);\n\t\treturn -EINVAL;\n\t}\n\n\tfor_each_child_of_node(np, nand_np) {\n\t\tret = pl35x_nand_chip_init(nfc, nand_np);\n\t\tif (ret) {\n\t\t\tof_node_put(nand_np);\n\t\t\tpl35x_nand_chips_cleanup(nfc);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic int pl35x_nand_probe(struct platform_device *pdev)\n{\n\tstruct device *smc_dev = pdev->dev.parent;\n\tstruct amba_device *smc_amba = to_amba_device(smc_dev);\n\tstruct pl35x_nandc *nfc;\n\tu32 ret;\n\n\tnfc = devm_kzalloc(&pdev->dev, sizeof(*nfc), GFP_KERNEL);\n\tif (!nfc)\n\t\treturn -ENOMEM;\n\n\tnfc->dev = &pdev->dev;\n\tnand_controller_init(&nfc->controller);\n\tnfc->controller.ops = &pl35x_nandc_ops;\n\tINIT_LIST_HEAD(&nfc->chips);\n\n\tnfc->conf_regs = devm_ioremap_resource(&smc_amba->dev, &smc_amba->res);\n\tif (IS_ERR(nfc->conf_regs))\n\t\treturn PTR_ERR(nfc->conf_regs);\n\n\tnfc->io_regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(nfc->io_regs))\n\t\treturn PTR_ERR(nfc->io_regs);\n\n\tret = pl35x_nand_reset_state(nfc);\n\tif (ret)\n\t\treturn ret;\n\n\tret = pl35x_nand_chips_init(nfc);\n\tif (ret)\n\t\treturn ret;\n\n\tplatform_set_drvdata(pdev, nfc);\n\n\treturn 0;\n}\n\nstatic void pl35x_nand_remove(struct platform_device *pdev)\n{\n\tstruct pl35x_nandc *nfc = platform_get_drvdata(pdev);\n\n\tpl35x_nand_chips_cleanup(nfc);\n}\n\nstatic const struct of_device_id pl35x_nand_of_match[] = {\n\t{ .compatible = \"arm,pl353-nand-r2p1\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, pl35x_nand_of_match);\n\nstatic struct platform_driver pl35x_nandc_driver = {\n\t.probe = pl35x_nand_probe,\n\t.remove_new = pl35x_nand_remove,\n\t.driver = {\n\t\t.name = PL35X_NANDC_DRIVER_NAME,\n\t\t.of_match_table = pl35x_nand_of_match,\n\t},\n};\nmodule_platform_driver(pl35x_nandc_driver);\n\nMODULE_AUTHOR(\"Xilinx, Inc.\");\nMODULE_ALIAS(\"platform:\" PL35X_NANDC_DRIVER_NAME);\nMODULE_DESCRIPTION(\"ARM PL35X NAND controller driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}