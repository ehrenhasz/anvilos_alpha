{
  "module_name": "meson_nand.c",
  "hash_id": "06d2050dd903bbe5e44b03a2c340214f4d54cc4fd1fe68842ed86e37c8b05cbd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/nand/raw/meson_nand.c",
  "human_readable_source": "\n \n\n#include <linux/platform_device.h>\n#include <linux/dma-mapping.h>\n#include <linux/interrupt.h>\n#include <linux/clk.h>\n#include <linux/clk-provider.h>\n#include <linux/mtd/rawnand.h>\n#include <linux/mtd/mtd.h>\n#include <linux/mfd/syscon.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/iopoll.h>\n#include <linux/of.h>\n#include <linux/sched/task_stack.h>\n\n#define NFC_REG_CMD\t\t0x00\n#define NFC_CMD_IDLE\t\t(0xc << 14)\n#define NFC_CMD_CLE\t\t(0x5 << 14)\n#define NFC_CMD_ALE\t\t(0x6 << 14)\n#define NFC_CMD_ADL\t\t((0 << 16) | (3 << 20))\n#define NFC_CMD_ADH\t\t((1 << 16) | (3 << 20))\n#define NFC_CMD_AIL\t\t((2 << 16) | (3 << 20))\n#define NFC_CMD_AIH\t\t((3 << 16) | (3 << 20))\n#define NFC_CMD_SEED\t\t((8 << 16) | (3 << 20))\n#define NFC_CMD_M2N\t\t((0 << 17) | (2 << 20))\n#define NFC_CMD_N2M\t\t((1 << 17) | (2 << 20))\n#define NFC_CMD_RB\t\tBIT(20)\n#define NFC_CMD_SCRAMBLER_ENABLE\tBIT(19)\n#define NFC_CMD_SCRAMBLER_DISABLE\t0\n#define NFC_CMD_SHORTMODE_DISABLE\t0\n#define NFC_CMD_RB_INT\t\tBIT(14)\n#define NFC_CMD_RB_INT_NO_PIN\t((0xb << 10) | BIT(18) | BIT(16))\n\n#define NFC_CMD_GET_SIZE(x)\t(((x) >> 22) & GENMASK(4, 0))\n\n#define NFC_REG_CFG\t\t0x04\n#define NFC_REG_DADR\t\t0x08\n#define NFC_REG_IADR\t\t0x0c\n#define NFC_REG_BUF\t\t0x10\n#define NFC_REG_INFO\t\t0x14\n#define NFC_REG_DC\t\t0x18\n#define NFC_REG_ADR\t\t0x1c\n#define NFC_REG_DL\t\t0x20\n#define NFC_REG_DH\t\t0x24\n#define NFC_REG_CADR\t\t0x28\n#define NFC_REG_SADR\t\t0x2c\n#define NFC_REG_PINS\t\t0x30\n#define NFC_REG_VER\t\t0x38\n\n#define NFC_RB_IRQ_EN\t\tBIT(21)\n\n#define CLK_DIV_SHIFT\t\t0\n#define CLK_DIV_WIDTH\t\t6\n\n#define CMDRWGEN(cmd_dir, ran, bch, short_mode, page_size, pages)\t\\\n\t(\t\t\t\t\t\t\t\t\\\n\t\t(cmd_dir)\t\t\t|\t\t\t\\\n\t\t((ran) << 19)\t\t\t|\t\t\t\\\n\t\t((bch) << 14)\t\t\t|\t\t\t\\\n\t\t((short_mode) << 13)\t\t|\t\t\t\\\n\t\t(((page_size) & 0x7f) << 6)\t|\t\t\t\\\n\t\t((pages) & 0x3f)\t\t\t\t\t\\\n\t)\n\n#define GENCMDDADDRL(adl, addr)\t\t((adl) | ((addr) & 0xffff))\n#define GENCMDDADDRH(adh, addr)\t\t((adh) | (((addr) >> 16) & 0xffff))\n#define GENCMDIADDRL(ail, addr)\t\t((ail) | ((addr) & 0xffff))\n#define GENCMDIADDRH(aih, addr)\t\t((aih) | (((addr) >> 16) & 0xffff))\n\n#define DMA_DIR(dir)\t\t((dir) ? NFC_CMD_N2M : NFC_CMD_M2N)\n#define DMA_ADDR_ALIGN\t\t8\n\n#define ECC_CHECK_RETURN_FF\t(-1)\n\n#define NAND_CE0\t\t(0xe << 10)\n#define NAND_CE1\t\t(0xd << 10)\n\n#define DMA_BUSY_TIMEOUT\t0x100000\n#define CMD_FIFO_EMPTY_TIMEOUT\t1000\n\n#define MAX_CE_NUM\t\t2\n\n \n#define CLK_SELECT_NAND\t\tBIT(31)\n\n#define NFC_CLK_CYCLE\t\t6\n\n \n#define NFC_DEFAULT_DELAY\t3000\n\n#define ROW_ADDER(page, index)\t(((page) >> (8 * (index))) & 0xff)\n#define MAX_CYCLE_ADDRS\t\t5\n#define DIRREAD\t\t\t1\n#define DIRWRITE\t\t0\n\n#define ECC_PARITY_BCH8_512B\t14\n#define ECC_COMPLETE            BIT(31)\n#define ECC_ERR_CNT(x)\t\t(((x) >> 24) & GENMASK(5, 0))\n#define ECC_ZERO_CNT(x)\t\t(((x) >> 16) & GENMASK(5, 0))\n#define ECC_UNCORRECTABLE\t0x3f\n\n#define PER_INFO_BYTE\t\t8\n\n#define NFC_CMD_RAW_LEN\tGENMASK(13, 0)\n\n#define NFC_COLUMN_ADDR_0\t0\n#define NFC_COLUMN_ADDR_1\t0\n\nstruct meson_nfc_nand_chip {\n\tstruct list_head node;\n\tstruct nand_chip nand;\n\tunsigned long clk_rate;\n\tunsigned long level1_divider;\n\tu32 bus_timing;\n\tu32 twb;\n\tu32 tadl;\n\tu32 tbers_max;\n\n\tu32 bch_mode;\n\tu8 *data_buf;\n\t__le64 *info_buf;\n\tu32 nsels;\n\tu8 sels[];\n};\n\nstruct meson_nand_ecc {\n\tu32 bch;\n\tu32 strength;\n\tu32 size;\n};\n\nstruct meson_nfc_data {\n\tconst struct nand_ecc_caps *ecc_caps;\n};\n\nstruct meson_nfc_param {\n\tu32 chip_select;\n\tu32 rb_select;\n};\n\nstruct nand_rw_cmd {\n\tu32 cmd0;\n\tu32 addrs[MAX_CYCLE_ADDRS];\n\tu32 cmd1;\n};\n\nstruct nand_timing {\n\tu32 twb;\n\tu32 tadl;\n\tu32 tbers_max;\n};\n\nstruct meson_nfc {\n\tstruct nand_controller controller;\n\tstruct clk *core_clk;\n\tstruct clk *device_clk;\n\tstruct clk *nand_clk;\n\tstruct clk_divider nand_divider;\n\n\tunsigned long clk_rate;\n\tu32 bus_timing;\n\n\tstruct device *dev;\n\tvoid __iomem *reg_base;\n\tvoid __iomem *reg_clk;\n\tstruct completion completion;\n\tstruct list_head chips;\n\tconst struct meson_nfc_data *data;\n\tstruct meson_nfc_param param;\n\tstruct nand_timing timing;\n\tunion {\n\t\tint cmd[32];\n\t\tstruct nand_rw_cmd rw;\n\t} cmdfifo;\n\n\tdma_addr_t daddr;\n\tdma_addr_t iaddr;\n\tu32 info_bytes;\n\n\tunsigned long assigned_cs;\n\tbool no_rb_pin;\n};\n\nenum {\n\tNFC_ECC_BCH8_512\t= 1,\n\tNFC_ECC_BCH8_1K,\n\tNFC_ECC_BCH24_1K,\n\tNFC_ECC_BCH30_1K,\n\tNFC_ECC_BCH40_1K,\n\tNFC_ECC_BCH50_1K,\n\tNFC_ECC_BCH60_1K,\n};\n\n#define MESON_ECC_DATA(b, s, sz)\t{ .bch = (b), .strength = (s), .size = (sz) }\n\nstatic struct meson_nand_ecc meson_ecc[] = {\n\tMESON_ECC_DATA(NFC_ECC_BCH8_512, 8,  512),\n\tMESON_ECC_DATA(NFC_ECC_BCH8_1K,  8,  1024),\n\tMESON_ECC_DATA(NFC_ECC_BCH24_1K, 24, 1024),\n\tMESON_ECC_DATA(NFC_ECC_BCH30_1K, 30, 1024),\n\tMESON_ECC_DATA(NFC_ECC_BCH40_1K, 40, 1024),\n\tMESON_ECC_DATA(NFC_ECC_BCH50_1K, 50, 1024),\n\tMESON_ECC_DATA(NFC_ECC_BCH60_1K, 60, 1024),\n};\n\nstatic int meson_nand_calc_ecc_bytes(int step_size, int strength)\n{\n\tint ecc_bytes;\n\n\tif (step_size == 512 && strength == 8)\n\t\treturn ECC_PARITY_BCH8_512B;\n\n\tecc_bytes = DIV_ROUND_UP(strength * fls(step_size * 8), 8);\n\tecc_bytes = ALIGN(ecc_bytes, 2);\n\n\treturn ecc_bytes;\n}\n\nNAND_ECC_CAPS_SINGLE(meson_gxl_ecc_caps,\n\t\t     meson_nand_calc_ecc_bytes, 1024, 8, 24, 30, 40, 50, 60);\n\nstatic const int axg_stepinfo_strengths[] = { 8 };\n\nstatic const struct nand_ecc_step_info axg_stepinfo[] = {\n\t{\n\t\t.stepsize = 1024,\n\t\t.strengths = axg_stepinfo_strengths,\n\t\t.nstrengths = ARRAY_SIZE(axg_stepinfo_strengths)\n\t},\n\t{\n\t\t.stepsize = 512,\n\t\t.strengths = axg_stepinfo_strengths,\n\t\t.nstrengths = ARRAY_SIZE(axg_stepinfo_strengths)\n\t},\n};\n\nstatic const struct nand_ecc_caps meson_axg_ecc_caps = {\n\t.stepinfos = axg_stepinfo,\n\t.nstepinfos = ARRAY_SIZE(axg_stepinfo),\n\t.calc_ecc_bytes = meson_nand_calc_ecc_bytes,\n};\n\nstatic struct meson_nfc_nand_chip *to_meson_nand(struct nand_chip *nand)\n{\n\treturn container_of(nand, struct meson_nfc_nand_chip, nand);\n}\n\nstatic void meson_nfc_select_chip(struct nand_chip *nand, int chip)\n{\n\tstruct meson_nfc_nand_chip *meson_chip = to_meson_nand(nand);\n\tstruct meson_nfc *nfc = nand_get_controller_data(nand);\n\tint ret, value;\n\n\tif (chip < 0 || WARN_ON_ONCE(chip >= meson_chip->nsels))\n\t\treturn;\n\n\tnfc->param.chip_select = meson_chip->sels[chip] ? NAND_CE1 : NAND_CE0;\n\tnfc->param.rb_select = nfc->param.chip_select;\n\tnfc->timing.twb = meson_chip->twb;\n\tnfc->timing.tadl = meson_chip->tadl;\n\tnfc->timing.tbers_max = meson_chip->tbers_max;\n\n\tif (nfc->clk_rate != meson_chip->clk_rate) {\n\t\tret = clk_set_rate(nfc->nand_clk, meson_chip->clk_rate);\n\t\tif (ret) {\n\t\t\tdev_err(nfc->dev, \"failed to set clock rate\\n\");\n\t\t\treturn;\n\t\t}\n\t\tnfc->clk_rate = meson_chip->clk_rate;\n\t}\n\tif (nfc->bus_timing != meson_chip->bus_timing) {\n\t\tvalue = (NFC_CLK_CYCLE - 1) | (meson_chip->bus_timing << 5);\n\t\twritel(value, nfc->reg_base + NFC_REG_CFG);\n\t\twritel((1 << 31), nfc->reg_base + NFC_REG_CMD);\n\t\tnfc->bus_timing =  meson_chip->bus_timing;\n\t}\n}\n\nstatic void meson_nfc_cmd_idle(struct meson_nfc *nfc, u32 time)\n{\n\twritel(nfc->param.chip_select | NFC_CMD_IDLE | (time & 0x3ff),\n\t       nfc->reg_base + NFC_REG_CMD);\n}\n\nstatic void meson_nfc_cmd_seed(struct meson_nfc *nfc, u32 seed)\n{\n\twritel(NFC_CMD_SEED | (0xc2 + (seed & 0x7fff)),\n\t       nfc->reg_base + NFC_REG_CMD);\n}\n\nstatic void meson_nfc_cmd_access(struct nand_chip *nand, int raw, bool dir,\n\t\t\t\t int scrambler)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(nand);\n\tstruct meson_nfc *nfc = nand_get_controller_data(mtd_to_nand(mtd));\n\tstruct meson_nfc_nand_chip *meson_chip = to_meson_nand(nand);\n\tu32 bch = meson_chip->bch_mode, cmd;\n\tint len = mtd->writesize, pagesize, pages;\n\n\tpagesize = nand->ecc.size;\n\n\tif (raw) {\n\t\tlen = mtd->writesize + mtd->oobsize;\n\t\tcmd = len | scrambler | DMA_DIR(dir);\n\t\twritel(cmd, nfc->reg_base + NFC_REG_CMD);\n\t\treturn;\n\t}\n\n\tpages = len / nand->ecc.size;\n\n\tcmd = CMDRWGEN(DMA_DIR(dir), scrambler, bch,\n\t\t       NFC_CMD_SHORTMODE_DISABLE, pagesize, pages);\n\n\twritel(cmd, nfc->reg_base + NFC_REG_CMD);\n}\n\nstatic void meson_nfc_drain_cmd(struct meson_nfc *nfc)\n{\n\t \n\tmeson_nfc_cmd_idle(nfc, 0);\n\tmeson_nfc_cmd_idle(nfc, 0);\n}\n\nstatic int meson_nfc_wait_cmd_finish(struct meson_nfc *nfc,\n\t\t\t\t     unsigned int timeout_ms)\n{\n\tu32 cmd_size = 0;\n\tint ret;\n\n\t \n\tret = readl_relaxed_poll_timeout(nfc->reg_base + NFC_REG_CMD, cmd_size,\n\t\t\t\t\t !NFC_CMD_GET_SIZE(cmd_size),\n\t\t\t\t\t 10, timeout_ms * 1000);\n\tif (ret)\n\t\tdev_err(nfc->dev, \"wait for empty CMD FIFO time out\\n\");\n\n\treturn ret;\n}\n\nstatic int meson_nfc_wait_dma_finish(struct meson_nfc *nfc)\n{\n\tmeson_nfc_drain_cmd(nfc);\n\n\treturn meson_nfc_wait_cmd_finish(nfc, DMA_BUSY_TIMEOUT);\n}\n\nstatic u8 *meson_nfc_oob_ptr(struct nand_chip *nand, int i)\n{\n\tstruct meson_nfc_nand_chip *meson_chip = to_meson_nand(nand);\n\tint len;\n\n\tlen = nand->ecc.size * (i + 1) + (nand->ecc.bytes + 2) * i;\n\n\treturn meson_chip->data_buf + len;\n}\n\nstatic u8 *meson_nfc_data_ptr(struct nand_chip *nand, int i)\n{\n\tstruct meson_nfc_nand_chip *meson_chip = to_meson_nand(nand);\n\tint len, temp;\n\n\ttemp = nand->ecc.size + nand->ecc.bytes;\n\tlen = (temp + 2) * i;\n\n\treturn meson_chip->data_buf + len;\n}\n\nstatic void meson_nfc_get_data_oob(struct nand_chip *nand,\n\t\t\t\t   u8 *buf, u8 *oobbuf)\n{\n\tint i, oob_len = 0;\n\tu8 *dsrc, *osrc;\n\n\toob_len = nand->ecc.bytes + 2;\n\tfor (i = 0; i < nand->ecc.steps; i++) {\n\t\tif (buf) {\n\t\t\tdsrc = meson_nfc_data_ptr(nand, i);\n\t\t\tmemcpy(buf, dsrc, nand->ecc.size);\n\t\t\tbuf += nand->ecc.size;\n\t\t}\n\t\tosrc = meson_nfc_oob_ptr(nand, i);\n\t\tmemcpy(oobbuf, osrc, oob_len);\n\t\toobbuf += oob_len;\n\t}\n}\n\nstatic void meson_nfc_set_data_oob(struct nand_chip *nand,\n\t\t\t\t   const u8 *buf, u8 *oobbuf)\n{\n\tint i, oob_len = 0;\n\tu8 *dsrc, *osrc;\n\n\toob_len = nand->ecc.bytes + 2;\n\tfor (i = 0; i < nand->ecc.steps; i++) {\n\t\tif (buf) {\n\t\t\tdsrc = meson_nfc_data_ptr(nand, i);\n\t\t\tmemcpy(dsrc, buf, nand->ecc.size);\n\t\t\tbuf += nand->ecc.size;\n\t\t}\n\t\tosrc = meson_nfc_oob_ptr(nand, i);\n\t\tmemcpy(osrc, oobbuf, oob_len);\n\t\toobbuf += oob_len;\n\t}\n}\n\nstatic int meson_nfc_wait_no_rb_pin(struct nand_chip *nand, int timeout_ms,\n\t\t\t\t    bool need_cmd_read0)\n{\n\tstruct meson_nfc *nfc = nand_get_controller_data(nand);\n\tu32 cmd, cfg;\n\n\tmeson_nfc_cmd_idle(nfc, nfc->timing.twb);\n\tmeson_nfc_drain_cmd(nfc);\n\tmeson_nfc_wait_cmd_finish(nfc, CMD_FIFO_EMPTY_TIMEOUT);\n\n\tcfg = readl(nfc->reg_base + NFC_REG_CFG);\n\tcfg |= NFC_RB_IRQ_EN;\n\twritel(cfg, nfc->reg_base + NFC_REG_CFG);\n\n\treinit_completion(&nfc->completion);\n\tnand_status_op(nand, NULL);\n\n\t \n\tcmd = NFC_CMD_RB | NFC_CMD_RB_INT_NO_PIN | nfc->timing.tbers_max;\n\twritel(cmd, nfc->reg_base + NFC_REG_CMD);\n\n\tif (!wait_for_completion_timeout(&nfc->completion,\n\t\t\t\t\t msecs_to_jiffies(timeout_ms)))\n\t\treturn -ETIMEDOUT;\n\n\tif (need_cmd_read0)\n\t\tnand_exit_status_op(nand);\n\n\treturn 0;\n}\n\nstatic int meson_nfc_wait_rb_pin(struct meson_nfc *nfc, int timeout_ms)\n{\n\tu32 cmd, cfg;\n\tint ret = 0;\n\n\tmeson_nfc_cmd_idle(nfc, nfc->timing.twb);\n\tmeson_nfc_drain_cmd(nfc);\n\tmeson_nfc_wait_cmd_finish(nfc, CMD_FIFO_EMPTY_TIMEOUT);\n\n\tcfg = readl(nfc->reg_base + NFC_REG_CFG);\n\tcfg |= NFC_RB_IRQ_EN;\n\twritel(cfg, nfc->reg_base + NFC_REG_CFG);\n\n\treinit_completion(&nfc->completion);\n\n\t \n\tcmd = NFC_CMD_RB | NFC_CMD_RB_INT\n\t\t| nfc->param.chip_select | nfc->timing.tbers_max;\n\twritel(cmd, nfc->reg_base + NFC_REG_CMD);\n\n\tret = wait_for_completion_timeout(&nfc->completion,\n\t\t\t\t\t  msecs_to_jiffies(timeout_ms));\n\tif (ret == 0)\n\t\tret = -1;\n\n\treturn ret;\n}\n\nstatic int meson_nfc_queue_rb(struct nand_chip *nand, int timeout_ms,\n\t\t\t      bool need_cmd_read0)\n{\n\tstruct meson_nfc *nfc = nand_get_controller_data(nand);\n\n\tif (nfc->no_rb_pin) {\n\t\t \n\t\treturn meson_nfc_wait_no_rb_pin(nand, timeout_ms,\n\t\t\t\t\t\tneed_cmd_read0);\n\t} else {\n\t\treturn meson_nfc_wait_rb_pin(nfc, timeout_ms);\n\t}\n}\n\nstatic void meson_nfc_set_user_byte(struct nand_chip *nand, u8 *oob_buf)\n{\n\tstruct meson_nfc_nand_chip *meson_chip = to_meson_nand(nand);\n\t__le64 *info;\n\tint i, count;\n\n\tfor (i = 0, count = 0; i < nand->ecc.steps; i++, count += 2) {\n\t\tinfo = &meson_chip->info_buf[i];\n\t\t*info |= oob_buf[count];\n\t\t*info |= oob_buf[count + 1] << 8;\n\t}\n}\n\nstatic void meson_nfc_get_user_byte(struct nand_chip *nand, u8 *oob_buf)\n{\n\tstruct meson_nfc_nand_chip *meson_chip = to_meson_nand(nand);\n\t__le64 *info;\n\tint i, count;\n\n\tfor (i = 0, count = 0; i < nand->ecc.steps; i++, count += 2) {\n\t\tinfo = &meson_chip->info_buf[i];\n\t\toob_buf[count] = *info;\n\t\toob_buf[count + 1] = *info >> 8;\n\t}\n}\n\nstatic int meson_nfc_ecc_correct(struct nand_chip *nand, u32 *bitflips,\n\t\t\t\t u64 *correct_bitmap)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(nand);\n\tstruct meson_nfc_nand_chip *meson_chip = to_meson_nand(nand);\n\t__le64 *info;\n\tint ret = 0, i;\n\n\tfor (i = 0; i < nand->ecc.steps; i++) {\n\t\tinfo = &meson_chip->info_buf[i];\n\t\tif (ECC_ERR_CNT(*info) != ECC_UNCORRECTABLE) {\n\t\t\tmtd->ecc_stats.corrected += ECC_ERR_CNT(*info);\n\t\t\t*bitflips = max_t(u32, *bitflips, ECC_ERR_CNT(*info));\n\t\t\t*correct_bitmap |= BIT_ULL(i);\n\t\t\tcontinue;\n\t\t}\n\t\tif ((nand->options & NAND_NEED_SCRAMBLING) &&\n\t\t    ECC_ZERO_CNT(*info) < nand->ecc.strength) {\n\t\t\tmtd->ecc_stats.corrected += ECC_ZERO_CNT(*info);\n\t\t\t*bitflips = max_t(u32, *bitflips,\n\t\t\t\t\t  ECC_ZERO_CNT(*info));\n\t\t\tret = ECC_CHECK_RETURN_FF;\n\t\t} else {\n\t\t\tret = -EBADMSG;\n\t\t}\n\t}\n\treturn ret;\n}\n\nstatic int meson_nfc_dma_buffer_setup(struct nand_chip *nand, void *databuf,\n\t\t\t\t      int datalen, void *infobuf, int infolen,\n\t\t\t\t      enum dma_data_direction dir)\n{\n\tstruct meson_nfc *nfc = nand_get_controller_data(nand);\n\tu32 cmd;\n\tint ret = 0;\n\n\tnfc->daddr = dma_map_single(nfc->dev, databuf, datalen, dir);\n\tret = dma_mapping_error(nfc->dev, nfc->daddr);\n\tif (ret) {\n\t\tdev_err(nfc->dev, \"DMA mapping error\\n\");\n\t\treturn ret;\n\t}\n\tcmd = GENCMDDADDRL(NFC_CMD_ADL, nfc->daddr);\n\twritel(cmd, nfc->reg_base + NFC_REG_CMD);\n\n\tcmd = GENCMDDADDRH(NFC_CMD_ADH, nfc->daddr);\n\twritel(cmd, nfc->reg_base + NFC_REG_CMD);\n\n\tif (infobuf) {\n\t\tnfc->iaddr = dma_map_single(nfc->dev, infobuf, infolen, dir);\n\t\tret = dma_mapping_error(nfc->dev, nfc->iaddr);\n\t\tif (ret) {\n\t\t\tdev_err(nfc->dev, \"DMA mapping error\\n\");\n\t\t\tdma_unmap_single(nfc->dev,\n\t\t\t\t\t nfc->daddr, datalen, dir);\n\t\t\treturn ret;\n\t\t}\n\t\tnfc->info_bytes = infolen;\n\t\tcmd = GENCMDIADDRL(NFC_CMD_AIL, nfc->iaddr);\n\t\twritel(cmd, nfc->reg_base + NFC_REG_CMD);\n\n\t\tcmd = GENCMDIADDRH(NFC_CMD_AIH, nfc->iaddr);\n\t\twritel(cmd, nfc->reg_base + NFC_REG_CMD);\n\t}\n\n\treturn ret;\n}\n\nstatic void meson_nfc_dma_buffer_release(struct nand_chip *nand,\n\t\t\t\t\t int datalen, int infolen,\n\t\t\t\t\t enum dma_data_direction dir)\n{\n\tstruct meson_nfc *nfc = nand_get_controller_data(nand);\n\n\tdma_unmap_single(nfc->dev, nfc->daddr, datalen, dir);\n\tif (infolen) {\n\t\tdma_unmap_single(nfc->dev, nfc->iaddr, infolen, dir);\n\t\tnfc->info_bytes = 0;\n\t}\n}\n\nstatic int meson_nfc_read_buf(struct nand_chip *nand, u8 *buf, int len)\n{\n\tstruct meson_nfc *nfc = nand_get_controller_data(nand);\n\tint ret = 0;\n\tu32 cmd;\n\tu8 *info;\n\n\tinfo = kzalloc(PER_INFO_BYTE, GFP_KERNEL);\n\tif (!info)\n\t\treturn -ENOMEM;\n\n\tret = meson_nfc_dma_buffer_setup(nand, buf, len, info,\n\t\t\t\t\t PER_INFO_BYTE, DMA_FROM_DEVICE);\n\tif (ret)\n\t\tgoto out;\n\n\tcmd = NFC_CMD_N2M | len;\n\twritel(cmd, nfc->reg_base + NFC_REG_CMD);\n\n\tmeson_nfc_drain_cmd(nfc);\n\tmeson_nfc_wait_cmd_finish(nfc, 1000);\n\tmeson_nfc_dma_buffer_release(nand, len, PER_INFO_BYTE, DMA_FROM_DEVICE);\n\nout:\n\tkfree(info);\n\n\treturn ret;\n}\n\nstatic int meson_nfc_write_buf(struct nand_chip *nand, u8 *buf, int len)\n{\n\tstruct meson_nfc *nfc = nand_get_controller_data(nand);\n\tint ret = 0;\n\tu32 cmd;\n\n\tret = meson_nfc_dma_buffer_setup(nand, buf, len, NULL,\n\t\t\t\t\t 0, DMA_TO_DEVICE);\n\tif (ret)\n\t\treturn ret;\n\n\tcmd = NFC_CMD_M2N | len;\n\twritel(cmd, nfc->reg_base + NFC_REG_CMD);\n\n\tmeson_nfc_drain_cmd(nfc);\n\tmeson_nfc_wait_cmd_finish(nfc, 1000);\n\tmeson_nfc_dma_buffer_release(nand, len, 0, DMA_TO_DEVICE);\n\n\treturn ret;\n}\n\nstatic int meson_nfc_rw_cmd_prepare_and_execute(struct nand_chip *nand,\n\t\t\t\t\t\tint page, bool in)\n{\n\tconst struct nand_sdr_timings *sdr =\n\t\tnand_get_sdr_timings(nand_get_interface_config(nand));\n\tstruct mtd_info *mtd = nand_to_mtd(nand);\n\tstruct meson_nfc *nfc = nand_get_controller_data(nand);\n\tu32 *addrs = nfc->cmdfifo.rw.addrs;\n\tu32 cs = nfc->param.chip_select;\n\tu32 cmd0, cmd_num, row_start;\n\tint i;\n\n\tcmd_num = sizeof(struct nand_rw_cmd) / sizeof(int);\n\n\tcmd0 = in ? NAND_CMD_READ0 : NAND_CMD_SEQIN;\n\tnfc->cmdfifo.rw.cmd0 = cs | NFC_CMD_CLE | cmd0;\n\n\taddrs[0] = cs | NFC_CMD_ALE | NFC_COLUMN_ADDR_0;\n\tif (mtd->writesize <= 512) {\n\t\tcmd_num--;\n\t\trow_start = 1;\n\t} else {\n\t\taddrs[1] = cs | NFC_CMD_ALE | NFC_COLUMN_ADDR_1;\n\t\trow_start = 2;\n\t}\n\n\taddrs[row_start] = cs | NFC_CMD_ALE | ROW_ADDER(page, 0);\n\taddrs[row_start + 1] = cs | NFC_CMD_ALE | ROW_ADDER(page, 1);\n\n\tif (nand->options & NAND_ROW_ADDR_3)\n\t\taddrs[row_start + 2] =\n\t\t\tcs | NFC_CMD_ALE | ROW_ADDER(page, 2);\n\telse\n\t\tcmd_num--;\n\n\t \n\tcmd_num--;\n\n\tfor (i = 0; i < cmd_num; i++)\n\t\twritel_relaxed(nfc->cmdfifo.cmd[i],\n\t\t\t       nfc->reg_base + NFC_REG_CMD);\n\n\tif (in) {\n\t\tnfc->cmdfifo.rw.cmd1 = cs | NFC_CMD_CLE | NAND_CMD_READSTART;\n\t\twritel(nfc->cmdfifo.rw.cmd1, nfc->reg_base + NFC_REG_CMD);\n\t\tmeson_nfc_queue_rb(nand, PSEC_TO_MSEC(sdr->tR_max), true);\n\t} else {\n\t\tmeson_nfc_cmd_idle(nfc, nfc->timing.tadl);\n\t}\n\n\treturn 0;\n}\n\nstatic int meson_nfc_write_page_sub(struct nand_chip *nand,\n\t\t\t\t    int page, int raw)\n{\n\tconst struct nand_sdr_timings *sdr =\n\t\tnand_get_sdr_timings(nand_get_interface_config(nand));\n\tstruct mtd_info *mtd = nand_to_mtd(nand);\n\tstruct meson_nfc_nand_chip *meson_chip = to_meson_nand(nand);\n\tstruct meson_nfc *nfc = nand_get_controller_data(nand);\n\tint data_len, info_len;\n\tu32 cmd;\n\tint ret;\n\n\tmeson_nfc_select_chip(nand, nand->cur_cs);\n\n\tdata_len =  mtd->writesize + mtd->oobsize;\n\tinfo_len = nand->ecc.steps * PER_INFO_BYTE;\n\n\tret = meson_nfc_rw_cmd_prepare_and_execute(nand, page, DIRWRITE);\n\tif (ret)\n\t\treturn ret;\n\n\tret = meson_nfc_dma_buffer_setup(nand, meson_chip->data_buf,\n\t\t\t\t\t data_len, meson_chip->info_buf,\n\t\t\t\t\t info_len, DMA_TO_DEVICE);\n\tif (ret)\n\t\treturn ret;\n\n\tif (nand->options & NAND_NEED_SCRAMBLING) {\n\t\tmeson_nfc_cmd_seed(nfc, page);\n\t\tmeson_nfc_cmd_access(nand, raw, DIRWRITE,\n\t\t\t\t     NFC_CMD_SCRAMBLER_ENABLE);\n\t} else {\n\t\tmeson_nfc_cmd_access(nand, raw, DIRWRITE,\n\t\t\t\t     NFC_CMD_SCRAMBLER_DISABLE);\n\t}\n\n\tcmd = nfc->param.chip_select | NFC_CMD_CLE | NAND_CMD_PAGEPROG;\n\twritel(cmd, nfc->reg_base + NFC_REG_CMD);\n\tmeson_nfc_queue_rb(nand, PSEC_TO_MSEC(sdr->tPROG_max), false);\n\n\tmeson_nfc_dma_buffer_release(nand, data_len, info_len, DMA_TO_DEVICE);\n\n\treturn ret;\n}\n\nstatic int meson_nfc_write_page_raw(struct nand_chip *nand, const u8 *buf,\n\t\t\t\t    int oob_required, int page)\n{\n\tu8 *oob_buf = nand->oob_poi;\n\n\tmeson_nfc_set_data_oob(nand, buf, oob_buf);\n\n\treturn meson_nfc_write_page_sub(nand, page, 1);\n}\n\nstatic int meson_nfc_write_page_hwecc(struct nand_chip *nand,\n\t\t\t\t      const u8 *buf, int oob_required, int page)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(nand);\n\tstruct meson_nfc_nand_chip *meson_chip = to_meson_nand(nand);\n\tu8 *oob_buf = nand->oob_poi;\n\n\tmemcpy(meson_chip->data_buf, buf, mtd->writesize);\n\tmemset(meson_chip->info_buf, 0, nand->ecc.steps * PER_INFO_BYTE);\n\tmeson_nfc_set_user_byte(nand, oob_buf);\n\n\treturn meson_nfc_write_page_sub(nand, page, 0);\n}\n\nstatic void meson_nfc_check_ecc_pages_valid(struct meson_nfc *nfc,\n\t\t\t\t\t    struct nand_chip *nand, int raw)\n{\n\tstruct meson_nfc_nand_chip *meson_chip = to_meson_nand(nand);\n\t__le64 *info;\n\tu32 neccpages;\n\tint ret;\n\n\tneccpages = raw ? 1 : nand->ecc.steps;\n\tinfo = &meson_chip->info_buf[neccpages - 1];\n\tdo {\n\t\tusleep_range(10, 15);\n\t\t \n\t\tsmp_rmb();\n\t\tdma_sync_single_for_cpu(nfc->dev, nfc->iaddr, nfc->info_bytes,\n\t\t\t\t\tDMA_FROM_DEVICE);\n\t\tret = *info & ECC_COMPLETE;\n\t} while (!ret);\n}\n\nstatic int meson_nfc_read_page_sub(struct nand_chip *nand,\n\t\t\t\t   int page, int raw)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(nand);\n\tstruct meson_nfc *nfc = nand_get_controller_data(nand);\n\tstruct meson_nfc_nand_chip *meson_chip = to_meson_nand(nand);\n\tint data_len, info_len;\n\tint ret;\n\n\tmeson_nfc_select_chip(nand, nand->cur_cs);\n\n\tdata_len =  mtd->writesize + mtd->oobsize;\n\tinfo_len = nand->ecc.steps * PER_INFO_BYTE;\n\n\tret = meson_nfc_rw_cmd_prepare_and_execute(nand, page, DIRREAD);\n\tif (ret)\n\t\treturn ret;\n\n\tret = meson_nfc_dma_buffer_setup(nand, meson_chip->data_buf,\n\t\t\t\t\t data_len, meson_chip->info_buf,\n\t\t\t\t\t info_len, DMA_FROM_DEVICE);\n\tif (ret)\n\t\treturn ret;\n\n\tif (nand->options & NAND_NEED_SCRAMBLING) {\n\t\tmeson_nfc_cmd_seed(nfc, page);\n\t\tmeson_nfc_cmd_access(nand, raw, DIRREAD,\n\t\t\t\t     NFC_CMD_SCRAMBLER_ENABLE);\n\t} else {\n\t\tmeson_nfc_cmd_access(nand, raw, DIRREAD,\n\t\t\t\t     NFC_CMD_SCRAMBLER_DISABLE);\n\t}\n\n\tret = meson_nfc_wait_dma_finish(nfc);\n\tmeson_nfc_check_ecc_pages_valid(nfc, nand, raw);\n\n\tmeson_nfc_dma_buffer_release(nand, data_len, info_len, DMA_FROM_DEVICE);\n\n\treturn ret;\n}\n\nstatic int meson_nfc_read_page_raw(struct nand_chip *nand, u8 *buf,\n\t\t\t\t   int oob_required, int page)\n{\n\tu8 *oob_buf = nand->oob_poi;\n\tint ret;\n\n\tret = meson_nfc_read_page_sub(nand, page, 1);\n\tif (ret)\n\t\treturn ret;\n\n\tmeson_nfc_get_data_oob(nand, buf, oob_buf);\n\n\treturn 0;\n}\n\nstatic int meson_nfc_read_page_hwecc(struct nand_chip *nand, u8 *buf,\n\t\t\t\t     int oob_required, int page)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(nand);\n\tstruct meson_nfc_nand_chip *meson_chip = to_meson_nand(nand);\n\tstruct nand_ecc_ctrl *ecc = &nand->ecc;\n\tu64 correct_bitmap = 0;\n\tu32 bitflips = 0;\n\tu8 *oob_buf = nand->oob_poi;\n\tint ret, i;\n\n\tret = meson_nfc_read_page_sub(nand, page, 0);\n\tif (ret)\n\t\treturn ret;\n\n\tmeson_nfc_get_user_byte(nand, oob_buf);\n\tret = meson_nfc_ecc_correct(nand, &bitflips, &correct_bitmap);\n\tif (ret == ECC_CHECK_RETURN_FF) {\n\t\tif (buf)\n\t\t\tmemset(buf, 0xff, mtd->writesize);\n\t\tmemset(oob_buf, 0xff, mtd->oobsize);\n\t} else if (ret < 0) {\n\t\tif ((nand->options & NAND_NEED_SCRAMBLING) || !buf) {\n\t\t\tmtd->ecc_stats.failed++;\n\t\t\treturn bitflips;\n\t\t}\n\t\tret  = meson_nfc_read_page_raw(nand, buf, 0, page);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tfor (i = 0; i < nand->ecc.steps ; i++) {\n\t\t\tu8 *data = buf + i * ecc->size;\n\t\t\tu8 *oob = nand->oob_poi + i * (ecc->bytes + 2);\n\n\t\t\tif (correct_bitmap & BIT_ULL(i))\n\t\t\t\tcontinue;\n\t\t\tret = nand_check_erased_ecc_chunk(data,\tecc->size,\n\t\t\t\t\t\t\t  oob, ecc->bytes + 2,\n\t\t\t\t\t\t\t  NULL, 0,\n\t\t\t\t\t\t\t  ecc->strength);\n\t\t\tif (ret < 0) {\n\t\t\t\tmtd->ecc_stats.failed++;\n\t\t\t} else {\n\t\t\t\tmtd->ecc_stats.corrected += ret;\n\t\t\t\tbitflips =  max_t(u32, bitflips, ret);\n\t\t\t}\n\t\t}\n\t} else if (buf && buf != meson_chip->data_buf) {\n\t\tmemcpy(buf, meson_chip->data_buf, mtd->writesize);\n\t}\n\n\treturn bitflips;\n}\n\nstatic int meson_nfc_read_oob_raw(struct nand_chip *nand, int page)\n{\n\treturn meson_nfc_read_page_raw(nand, NULL, 1, page);\n}\n\nstatic int meson_nfc_read_oob(struct nand_chip *nand, int page)\n{\n\treturn meson_nfc_read_page_hwecc(nand, NULL, 1, page);\n}\n\nstatic bool meson_nfc_is_buffer_dma_safe(const void *buffer)\n{\n\tif ((uintptr_t)buffer % DMA_ADDR_ALIGN)\n\t\treturn false;\n\n\tif (virt_addr_valid(buffer) && (!object_is_on_stack(buffer)))\n\t\treturn true;\n\treturn false;\n}\n\nstatic void *\nmeson_nand_op_get_dma_safe_input_buf(const struct nand_op_instr *instr)\n{\n\tif (WARN_ON(instr->type != NAND_OP_DATA_IN_INSTR))\n\t\treturn NULL;\n\n\tif (meson_nfc_is_buffer_dma_safe(instr->ctx.data.buf.in))\n\t\treturn instr->ctx.data.buf.in;\n\n\treturn kzalloc(instr->ctx.data.len, GFP_KERNEL);\n}\n\nstatic void\nmeson_nand_op_put_dma_safe_input_buf(const struct nand_op_instr *instr,\n\t\t\t\t     void *buf)\n{\n\tif (WARN_ON(instr->type != NAND_OP_DATA_IN_INSTR) ||\n\t    WARN_ON(!buf))\n\t\treturn;\n\n\tif (buf == instr->ctx.data.buf.in)\n\t\treturn;\n\n\tmemcpy(instr->ctx.data.buf.in, buf, instr->ctx.data.len);\n\tkfree(buf);\n}\n\nstatic void *\nmeson_nand_op_get_dma_safe_output_buf(const struct nand_op_instr *instr)\n{\n\tif (WARN_ON(instr->type != NAND_OP_DATA_OUT_INSTR))\n\t\treturn NULL;\n\n\tif (meson_nfc_is_buffer_dma_safe(instr->ctx.data.buf.out))\n\t\treturn (void *)instr->ctx.data.buf.out;\n\n\treturn kmemdup(instr->ctx.data.buf.out,\n\t\t       instr->ctx.data.len, GFP_KERNEL);\n}\n\nstatic void\nmeson_nand_op_put_dma_safe_output_buf(const struct nand_op_instr *instr,\n\t\t\t\t      const void *buf)\n{\n\tif (WARN_ON(instr->type != NAND_OP_DATA_OUT_INSTR) ||\n\t    WARN_ON(!buf))\n\t\treturn;\n\n\tif (buf != instr->ctx.data.buf.out)\n\t\tkfree(buf);\n}\n\nstatic int meson_nfc_check_op(struct nand_chip *chip,\n\t\t\t      const struct nand_operation *op)\n{\n\tint op_id;\n\n\tfor (op_id = 0; op_id < op->ninstrs; op_id++) {\n\t\tconst struct nand_op_instr *instr;\n\n\t\tinstr = &op->instrs[op_id];\n\n\t\tswitch (instr->type) {\n\t\tcase NAND_OP_DATA_IN_INSTR:\n\t\tcase NAND_OP_DATA_OUT_INSTR:\n\t\t\tif (instr->ctx.data.len > NFC_CMD_RAW_LEN)\n\t\t\t\treturn -ENOTSUPP;\n\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int meson_nfc_exec_op(struct nand_chip *nand,\n\t\t\t     const struct nand_operation *op, bool check_only)\n{\n\tstruct meson_nfc_nand_chip *meson_chip = to_meson_nand(nand);\n\tstruct meson_nfc *nfc = nand_get_controller_data(nand);\n\tconst struct nand_op_instr *instr = NULL;\n\tvoid *buf;\n\tu32 op_id, delay_idle, cmd;\n\tint err;\n\tint i;\n\n\terr = meson_nfc_check_op(nand, op);\n\tif (err)\n\t\treturn err;\n\n\tif (check_only)\n\t\treturn 0;\n\n\tmeson_nfc_select_chip(nand, op->cs);\n\tfor (op_id = 0; op_id < op->ninstrs; op_id++) {\n\t\tinstr = &op->instrs[op_id];\n\t\tdelay_idle = DIV_ROUND_UP(PSEC_TO_NSEC(instr->delay_ns),\n\t\t\t\t\t  meson_chip->level1_divider *\n\t\t\t\t\t  NFC_CLK_CYCLE);\n\t\tswitch (instr->type) {\n\t\tcase NAND_OP_CMD_INSTR:\n\t\t\tcmd = nfc->param.chip_select | NFC_CMD_CLE;\n\t\t\tcmd |= instr->ctx.cmd.opcode & 0xff;\n\t\t\twritel(cmd, nfc->reg_base + NFC_REG_CMD);\n\t\t\tmeson_nfc_cmd_idle(nfc, delay_idle);\n\t\t\tbreak;\n\n\t\tcase NAND_OP_ADDR_INSTR:\n\t\t\tfor (i = 0; i < instr->ctx.addr.naddrs; i++) {\n\t\t\t\tcmd = nfc->param.chip_select | NFC_CMD_ALE;\n\t\t\t\tcmd |= instr->ctx.addr.addrs[i] & 0xff;\n\t\t\t\twritel(cmd, nfc->reg_base + NFC_REG_CMD);\n\t\t\t}\n\t\t\tmeson_nfc_cmd_idle(nfc, delay_idle);\n\t\t\tbreak;\n\n\t\tcase NAND_OP_DATA_IN_INSTR:\n\t\t\tbuf = meson_nand_op_get_dma_safe_input_buf(instr);\n\t\t\tif (!buf)\n\t\t\t\treturn -ENOMEM;\n\t\t\tmeson_nfc_read_buf(nand, buf, instr->ctx.data.len);\n\t\t\tmeson_nand_op_put_dma_safe_input_buf(instr, buf);\n\t\t\tbreak;\n\n\t\tcase NAND_OP_DATA_OUT_INSTR:\n\t\t\tbuf = meson_nand_op_get_dma_safe_output_buf(instr);\n\t\t\tif (!buf)\n\t\t\t\treturn -ENOMEM;\n\t\t\tmeson_nfc_write_buf(nand, buf, instr->ctx.data.len);\n\t\t\tmeson_nand_op_put_dma_safe_output_buf(instr, buf);\n\t\t\tbreak;\n\n\t\tcase NAND_OP_WAITRDY_INSTR:\n\t\t\tmeson_nfc_queue_rb(nand, instr->ctx.waitrdy.timeout_ms,\n\t\t\t\t\t   true);\n\t\t\tif (instr->delay_ns)\n\t\t\t\tmeson_nfc_cmd_idle(nfc, delay_idle);\n\t\t\tbreak;\n\t\t}\n\t}\n\tmeson_nfc_wait_cmd_finish(nfc, 1000);\n\treturn 0;\n}\n\nstatic int meson_ooblayout_ecc(struct mtd_info *mtd, int section,\n\t\t\t       struct mtd_oob_region *oobregion)\n{\n\tstruct nand_chip *nand = mtd_to_nand(mtd);\n\n\tif (section >= nand->ecc.steps)\n\t\treturn -ERANGE;\n\n\toobregion->offset =  2 + (section * (2 + nand->ecc.bytes));\n\toobregion->length = nand->ecc.bytes;\n\n\treturn 0;\n}\n\nstatic int meson_ooblayout_free(struct mtd_info *mtd, int section,\n\t\t\t\tstruct mtd_oob_region *oobregion)\n{\n\tstruct nand_chip *nand = mtd_to_nand(mtd);\n\n\tif (section >= nand->ecc.steps)\n\t\treturn -ERANGE;\n\n\toobregion->offset = section * (2 + nand->ecc.bytes);\n\toobregion->length = 2;\n\n\treturn 0;\n}\n\nstatic const struct mtd_ooblayout_ops meson_ooblayout_ops = {\n\t.ecc = meson_ooblayout_ecc,\n\t.free = meson_ooblayout_free,\n};\n\nstatic int meson_nfc_clk_init(struct meson_nfc *nfc)\n{\n\tstruct clk_parent_data nfc_divider_parent_data[1] = {0};\n\tstruct clk_init_data init = {0};\n\tint ret;\n\n\t \n\tnfc->core_clk = devm_clk_get(nfc->dev, \"core\");\n\tif (IS_ERR(nfc->core_clk)) {\n\t\tdev_err(nfc->dev, \"failed to get core clock\\n\");\n\t\treturn PTR_ERR(nfc->core_clk);\n\t}\n\n\tnfc->device_clk = devm_clk_get(nfc->dev, \"device\");\n\tif (IS_ERR(nfc->device_clk)) {\n\t\tdev_err(nfc->dev, \"failed to get device clock\\n\");\n\t\treturn PTR_ERR(nfc->device_clk);\n\t}\n\n\tinit.name = devm_kasprintf(nfc->dev,\n\t\t\t\t   GFP_KERNEL, \"%s#div\",\n\t\t\t\t   dev_name(nfc->dev));\n\tif (!init.name)\n\t\treturn -ENOMEM;\n\n\tinit.ops = &clk_divider_ops;\n\tnfc_divider_parent_data[0].fw_name = \"device\";\n\tinit.parent_data = nfc_divider_parent_data;\n\tinit.num_parents = 1;\n\tnfc->nand_divider.reg = nfc->reg_clk;\n\tnfc->nand_divider.shift = CLK_DIV_SHIFT;\n\tnfc->nand_divider.width = CLK_DIV_WIDTH;\n\tnfc->nand_divider.hw.init = &init;\n\tnfc->nand_divider.flags = CLK_DIVIDER_ONE_BASED |\n\t\t\t\t  CLK_DIVIDER_ROUND_CLOSEST |\n\t\t\t\t  CLK_DIVIDER_ALLOW_ZERO;\n\n\tnfc->nand_clk = devm_clk_register(nfc->dev, &nfc->nand_divider.hw);\n\tif (IS_ERR(nfc->nand_clk))\n\t\treturn PTR_ERR(nfc->nand_clk);\n\n\t \n\twritel(CLK_SELECT_NAND | readl(nfc->reg_clk),\n\t       nfc->reg_clk);\n\n\tret = clk_prepare_enable(nfc->core_clk);\n\tif (ret) {\n\t\tdev_err(nfc->dev, \"failed to enable core clock\\n\");\n\t\treturn ret;\n\t}\n\n\tret = clk_prepare_enable(nfc->device_clk);\n\tif (ret) {\n\t\tdev_err(nfc->dev, \"failed to enable device clock\\n\");\n\t\tgoto err_device_clk;\n\t}\n\n\tret = clk_prepare_enable(nfc->nand_clk);\n\tif (ret) {\n\t\tdev_err(nfc->dev, \"pre enable NFC divider fail\\n\");\n\t\tgoto err_nand_clk;\n\t}\n\n\tret = clk_set_rate(nfc->nand_clk, 24000000);\n\tif (ret)\n\t\tgoto err_disable_clk;\n\n\treturn 0;\n\nerr_disable_clk:\n\tclk_disable_unprepare(nfc->nand_clk);\nerr_nand_clk:\n\tclk_disable_unprepare(nfc->device_clk);\nerr_device_clk:\n\tclk_disable_unprepare(nfc->core_clk);\n\treturn ret;\n}\n\nstatic void meson_nfc_disable_clk(struct meson_nfc *nfc)\n{\n\tclk_disable_unprepare(nfc->nand_clk);\n\tclk_disable_unprepare(nfc->device_clk);\n\tclk_disable_unprepare(nfc->core_clk);\n}\n\nstatic void meson_nfc_free_buffer(struct nand_chip *nand)\n{\n\tstruct meson_nfc_nand_chip *meson_chip = to_meson_nand(nand);\n\n\tkfree(meson_chip->info_buf);\n\tkfree(meson_chip->data_buf);\n}\n\nstatic int meson_chip_buffer_init(struct nand_chip *nand)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(nand);\n\tstruct meson_nfc_nand_chip *meson_chip = to_meson_nand(nand);\n\tu32 page_bytes, info_bytes, nsectors;\n\n\tnsectors = mtd->writesize / nand->ecc.size;\n\n\tpage_bytes =  mtd->writesize + mtd->oobsize;\n\tinfo_bytes = nsectors * PER_INFO_BYTE;\n\n\tmeson_chip->data_buf = kmalloc(page_bytes, GFP_KERNEL);\n\tif (!meson_chip->data_buf)\n\t\treturn -ENOMEM;\n\n\tmeson_chip->info_buf = kmalloc(info_bytes, GFP_KERNEL);\n\tif (!meson_chip->info_buf) {\n\t\tkfree(meson_chip->data_buf);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\nstatic\nint meson_nfc_setup_interface(struct nand_chip *nand, int csline,\n\t\t\t      const struct nand_interface_config *conf)\n{\n\tstruct meson_nfc_nand_chip *meson_chip = to_meson_nand(nand);\n\tconst struct nand_sdr_timings *timings;\n\tu32 div, bt_min, bt_max, tbers_clocks;\n\n\ttimings = nand_get_sdr_timings(conf);\n\tif (IS_ERR(timings))\n\t\treturn -ENOTSUPP;\n\n\tif (csline == NAND_DATA_IFACE_CHECK_ONLY)\n\t\treturn 0;\n\n\tdiv = DIV_ROUND_UP((timings->tRC_min / 1000), NFC_CLK_CYCLE);\n\tbt_min = (timings->tREA_max + NFC_DEFAULT_DELAY) / div;\n\tbt_max = (NFC_DEFAULT_DELAY + timings->tRHOH_min +\n\t\t  timings->tRC_min / 2) / div;\n\n\tmeson_chip->twb = DIV_ROUND_UP(PSEC_TO_NSEC(timings->tWB_max),\n\t\t\t\t       div * NFC_CLK_CYCLE);\n\tmeson_chip->tadl = DIV_ROUND_UP(PSEC_TO_NSEC(timings->tADL_min),\n\t\t\t\t\tdiv * NFC_CLK_CYCLE);\n\ttbers_clocks = DIV_ROUND_UP_ULL(PSEC_TO_NSEC(timings->tBERS_max),\n\t\t\t\t\tdiv * NFC_CLK_CYCLE);\n\tmeson_chip->tbers_max = ilog2(tbers_clocks);\n\tif (!is_power_of_2(tbers_clocks))\n\t\tmeson_chip->tbers_max++;\n\n\tbt_min = DIV_ROUND_UP(bt_min, 1000);\n\tbt_max = DIV_ROUND_UP(bt_max, 1000);\n\n\tif (bt_max < bt_min)\n\t\treturn -EINVAL;\n\n\tmeson_chip->level1_divider = div;\n\tmeson_chip->clk_rate = 1000000000 / meson_chip->level1_divider;\n\tmeson_chip->bus_timing = (bt_min + bt_max) / 2 + 1;\n\n\treturn 0;\n}\n\nstatic int meson_nand_bch_mode(struct nand_chip *nand)\n{\n\tstruct meson_nfc_nand_chip *meson_chip = to_meson_nand(nand);\n\tint i;\n\n\tif (nand->ecc.strength > 60 || nand->ecc.strength < 8)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < ARRAY_SIZE(meson_ecc); i++) {\n\t\tif (meson_ecc[i].strength == nand->ecc.strength &&\n\t\t    meson_ecc[i].size == nand->ecc.size) {\n\t\t\tmeson_chip->bch_mode = meson_ecc[i].bch;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic void meson_nand_detach_chip(struct nand_chip *nand)\n{\n\tmeson_nfc_free_buffer(nand);\n}\n\nstatic int meson_nand_attach_chip(struct nand_chip *nand)\n{\n\tstruct meson_nfc *nfc = nand_get_controller_data(nand);\n\tstruct meson_nfc_nand_chip *meson_chip = to_meson_nand(nand);\n\tstruct mtd_info *mtd = nand_to_mtd(nand);\n\tint raw_writesize;\n\tint ret;\n\n\tif (!mtd->name) {\n\t\tmtd->name = devm_kasprintf(nfc->dev, GFP_KERNEL,\n\t\t\t\t\t   \"%s:nand%d\",\n\t\t\t\t\t   dev_name(nfc->dev),\n\t\t\t\t\t   meson_chip->sels[0]);\n\t\tif (!mtd->name)\n\t\t\treturn -ENOMEM;\n\t}\n\n\traw_writesize = mtd->writesize + mtd->oobsize;\n\tif (raw_writesize > NFC_CMD_RAW_LEN) {\n\t\tdev_err(nfc->dev, \"too big write size in raw mode: %d > %ld\\n\",\n\t\t\traw_writesize, NFC_CMD_RAW_LEN);\n\t\treturn -EINVAL;\n\t}\n\n\tif (nand->bbt_options & NAND_BBT_USE_FLASH)\n\t\tnand->bbt_options |= NAND_BBT_NO_OOB;\n\n\tnand->options |= NAND_NO_SUBPAGE_WRITE;\n\n\tret = nand_ecc_choose_conf(nand, nfc->data->ecc_caps,\n\t\t\t\t   mtd->oobsize - 2);\n\tif (ret) {\n\t\tdev_err(nfc->dev, \"failed to ECC init\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tmtd_set_ooblayout(mtd, &meson_ooblayout_ops);\n\n\tret = meson_nand_bch_mode(nand);\n\tif (ret)\n\t\treturn -EINVAL;\n\n\tnand->ecc.engine_type = NAND_ECC_ENGINE_TYPE_ON_HOST;\n\tnand->ecc.write_page_raw = meson_nfc_write_page_raw;\n\tnand->ecc.write_page = meson_nfc_write_page_hwecc;\n\tnand->ecc.write_oob_raw = nand_write_oob_std;\n\tnand->ecc.write_oob = nand_write_oob_std;\n\n\tnand->ecc.read_page_raw = meson_nfc_read_page_raw;\n\tnand->ecc.read_page = meson_nfc_read_page_hwecc;\n\tnand->ecc.read_oob_raw = meson_nfc_read_oob_raw;\n\tnand->ecc.read_oob = meson_nfc_read_oob;\n\n\tif (nand->options & NAND_BUSWIDTH_16) {\n\t\tdev_err(nfc->dev, \"16bits bus width not supported\");\n\t\treturn -EINVAL;\n\t}\n\tret = meson_chip_buffer_init(nand);\n\tif (ret)\n\t\treturn -ENOMEM;\n\n\treturn ret;\n}\n\nstatic const struct nand_controller_ops meson_nand_controller_ops = {\n\t.attach_chip = meson_nand_attach_chip,\n\t.detach_chip = meson_nand_detach_chip,\n\t.setup_interface = meson_nfc_setup_interface,\n\t.exec_op = meson_nfc_exec_op,\n};\n\nstatic int\nmeson_nfc_nand_chip_init(struct device *dev,\n\t\t\t struct meson_nfc *nfc, struct device_node *np)\n{\n\tstruct meson_nfc_nand_chip *meson_chip;\n\tstruct nand_chip *nand;\n\tstruct mtd_info *mtd;\n\tint ret, i;\n\tu32 tmp, nsels;\n\tu32 nand_rb_val = 0;\n\n\tnsels = of_property_count_elems_of_size(np, \"reg\", sizeof(u32));\n\tif (!nsels || nsels > MAX_CE_NUM) {\n\t\tdev_err(dev, \"invalid register property size\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tmeson_chip = devm_kzalloc(dev, struct_size(meson_chip, sels, nsels),\n\t\t\t\t  GFP_KERNEL);\n\tif (!meson_chip)\n\t\treturn -ENOMEM;\n\n\tmeson_chip->nsels = nsels;\n\n\tfor (i = 0; i < nsels; i++) {\n\t\tret = of_property_read_u32_index(np, \"reg\", i, &tmp);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"could not retrieve register property: %d\\n\",\n\t\t\t\tret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (test_and_set_bit(tmp, &nfc->assigned_cs)) {\n\t\t\tdev_err(dev, \"CS %d already assigned\\n\", tmp);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tnand = &meson_chip->nand;\n\tnand->controller = &nfc->controller;\n\tnand->controller->ops = &meson_nand_controller_ops;\n\tnand_set_flash_node(nand, np);\n\tnand_set_controller_data(nand, nfc);\n\n\tnand->options |= NAND_USES_DMA;\n\tmtd = nand_to_mtd(nand);\n\tmtd->owner = THIS_MODULE;\n\tmtd->dev.parent = dev;\n\n\tret = of_property_read_u32(np, \"nand-rb\", &nand_rb_val);\n\tif (ret == -EINVAL)\n\t\tnfc->no_rb_pin = true;\n\telse if (ret)\n\t\treturn ret;\n\n\tif (nand_rb_val)\n\t\treturn -EINVAL;\n\n\tret = nand_scan(nand, nsels);\n\tif (ret)\n\t\treturn ret;\n\n\tret = mtd_device_register(mtd, NULL, 0);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to register MTD device: %d\\n\", ret);\n\t\tnand_cleanup(nand);\n\t\treturn ret;\n\t}\n\n\tlist_add_tail(&meson_chip->node, &nfc->chips);\n\n\treturn 0;\n}\n\nstatic void meson_nfc_nand_chip_cleanup(struct meson_nfc *nfc)\n{\n\tstruct meson_nfc_nand_chip *meson_chip;\n\tstruct mtd_info *mtd;\n\n\twhile (!list_empty(&nfc->chips)) {\n\t\tmeson_chip = list_first_entry(&nfc->chips,\n\t\t\t\t\t      struct meson_nfc_nand_chip, node);\n\t\tmtd = nand_to_mtd(&meson_chip->nand);\n\t\tWARN_ON(mtd_device_unregister(mtd));\n\n\t\tnand_cleanup(&meson_chip->nand);\n\t\tlist_del(&meson_chip->node);\n\t}\n}\n\nstatic int meson_nfc_nand_chips_init(struct device *dev,\n\t\t\t\t     struct meson_nfc *nfc)\n{\n\tstruct device_node *np = dev->of_node;\n\tstruct device_node *nand_np;\n\tint ret;\n\n\tfor_each_child_of_node(np, nand_np) {\n\t\tret = meson_nfc_nand_chip_init(dev, nfc, nand_np);\n\t\tif (ret) {\n\t\t\tmeson_nfc_nand_chip_cleanup(nfc);\n\t\t\tof_node_put(nand_np);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic irqreturn_t meson_nfc_irq(int irq, void *id)\n{\n\tstruct meson_nfc *nfc = id;\n\tu32 cfg;\n\n\tcfg = readl(nfc->reg_base + NFC_REG_CFG);\n\tif (!(cfg & NFC_RB_IRQ_EN))\n\t\treturn IRQ_NONE;\n\n\tcfg &= ~(NFC_RB_IRQ_EN);\n\twritel(cfg, nfc->reg_base + NFC_REG_CFG);\n\n\tcomplete(&nfc->completion);\n\treturn IRQ_HANDLED;\n}\n\nstatic const struct meson_nfc_data meson_gxl_data = {\n\t.ecc_caps = &meson_gxl_ecc_caps,\n};\n\nstatic const struct meson_nfc_data meson_axg_data = {\n\t.ecc_caps = &meson_axg_ecc_caps,\n};\n\nstatic const struct of_device_id meson_nfc_id_table[] = {\n\t{\n\t\t.compatible = \"amlogic,meson-gxl-nfc\",\n\t\t.data = &meson_gxl_data,\n\t}, {\n\t\t.compatible = \"amlogic,meson-axg-nfc\",\n\t\t.data = &meson_axg_data,\n\t},\n\t{}\n};\nMODULE_DEVICE_TABLE(of, meson_nfc_id_table);\n\nstatic int meson_nfc_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct meson_nfc *nfc;\n\tint ret, irq;\n\n\tnfc = devm_kzalloc(dev, sizeof(*nfc), GFP_KERNEL);\n\tif (!nfc)\n\t\treturn -ENOMEM;\n\n\tnfc->data = of_device_get_match_data(&pdev->dev);\n\tif (!nfc->data)\n\t\treturn -ENODEV;\n\n\tnand_controller_init(&nfc->controller);\n\tINIT_LIST_HEAD(&nfc->chips);\n\tinit_completion(&nfc->completion);\n\n\tnfc->dev = dev;\n\n\tnfc->reg_base = devm_platform_ioremap_resource_byname(pdev, \"nfc\");\n\tif (IS_ERR(nfc->reg_base))\n\t\treturn PTR_ERR(nfc->reg_base);\n\n\tnfc->reg_clk = devm_platform_ioremap_resource_byname(pdev, \"emmc\");\n\tif (IS_ERR(nfc->reg_clk))\n\t\treturn PTR_ERR(nfc->reg_clk);\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn -EINVAL;\n\n\tret = meson_nfc_clk_init(nfc);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to initialize NAND clock\\n\");\n\t\treturn ret;\n\t}\n\n\twritel(0, nfc->reg_base + NFC_REG_CFG);\n\tret = devm_request_irq(dev, irq, meson_nfc_irq, 0, dev_name(dev), nfc);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to request NFC IRQ\\n\");\n\t\tret = -EINVAL;\n\t\tgoto err_clk;\n\t}\n\n\tret = dma_set_mask(dev, DMA_BIT_MASK(32));\n\tif (ret) {\n\t\tdev_err(dev, \"failed to set DMA mask\\n\");\n\t\tgoto err_clk;\n\t}\n\n\tplatform_set_drvdata(pdev, nfc);\n\n\tret = meson_nfc_nand_chips_init(dev, nfc);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to init NAND chips\\n\");\n\t\tgoto err_clk;\n\t}\n\n\treturn 0;\nerr_clk:\n\tmeson_nfc_disable_clk(nfc);\n\treturn ret;\n}\n\nstatic void meson_nfc_remove(struct platform_device *pdev)\n{\n\tstruct meson_nfc *nfc = platform_get_drvdata(pdev);\n\n\tmeson_nfc_nand_chip_cleanup(nfc);\n\n\tmeson_nfc_disable_clk(nfc);\n}\n\nstatic struct platform_driver meson_nfc_driver = {\n\t.probe  = meson_nfc_probe,\n\t.remove_new = meson_nfc_remove,\n\t.driver = {\n\t\t.name  = \"meson-nand\",\n\t\t.of_match_table = meson_nfc_id_table,\n\t},\n};\nmodule_platform_driver(meson_nfc_driver);\n\nMODULE_LICENSE(\"Dual MIT/GPL\");\nMODULE_AUTHOR(\"Liang Yang <liang.yang@amlogic.com>\");\nMODULE_DESCRIPTION(\"Amlogic's Meson NAND Flash Controller driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}