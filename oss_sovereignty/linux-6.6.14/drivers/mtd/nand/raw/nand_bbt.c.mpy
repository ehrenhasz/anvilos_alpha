{
  "module_name": "nand_bbt.c",
  "hash_id": "c51d48356e14cea229461757e320b69a05115b94241c7e7807615bcf47a5ac3e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/nand/raw/nand_bbt.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/mtd/mtd.h>\n#include <linux/mtd/bbm.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <linux/string.h>\n\n#include \"internals.h\"\n\n#define BBT_BLOCK_GOOD\t\t0x00\n#define BBT_BLOCK_WORN\t\t0x01\n#define BBT_BLOCK_RESERVED\t0x02\n#define BBT_BLOCK_FACTORY_BAD\t0x03\n\n#define BBT_ENTRY_MASK\t\t0x03\n#define BBT_ENTRY_SHIFT\t\t2\n\nstatic inline uint8_t bbt_get_entry(struct nand_chip *chip, int block)\n{\n\tuint8_t entry = chip->bbt[block >> BBT_ENTRY_SHIFT];\n\tentry >>= (block & BBT_ENTRY_MASK) * 2;\n\treturn entry & BBT_ENTRY_MASK;\n}\n\nstatic inline void bbt_mark_entry(struct nand_chip *chip, int block,\n\t\tuint8_t mark)\n{\n\tuint8_t msk = (mark & BBT_ENTRY_MASK) << ((block & BBT_ENTRY_MASK) * 2);\n\tchip->bbt[block >> BBT_ENTRY_SHIFT] |= msk;\n}\n\nstatic int check_pattern_no_oob(uint8_t *buf, struct nand_bbt_descr *td)\n{\n\tif (memcmp(buf, td->pattern, td->len))\n\t\treturn -1;\n\treturn 0;\n}\n\n \nstatic int check_pattern(uint8_t *buf, int len, int paglen, struct nand_bbt_descr *td)\n{\n\tif (td->options & NAND_BBT_NO_OOB)\n\t\treturn check_pattern_no_oob(buf, td);\n\n\t \n\tif (memcmp(buf + paglen + td->offs, td->pattern, td->len))\n\t\treturn -1;\n\n\treturn 0;\n}\n\n \nstatic int check_short_pattern(uint8_t *buf, struct nand_bbt_descr *td)\n{\n\t \n\tif (memcmp(buf + td->offs, td->pattern, td->len))\n\t\treturn -1;\n\treturn 0;\n}\n\n \nstatic u32 add_marker_len(struct nand_bbt_descr *td)\n{\n\tu32 len;\n\n\tif (!(td->options & NAND_BBT_NO_OOB))\n\t\treturn 0;\n\n\tlen = td->len;\n\tif (td->options & NAND_BBT_VERSION)\n\t\tlen++;\n\treturn len;\n}\n\n \nstatic int read_bbt(struct nand_chip *this, uint8_t *buf, int page, int num,\n\t\t    struct nand_bbt_descr *td, int offs)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(this);\n\tint res, ret = 0, i, j, act = 0;\n\tsize_t retlen, len, totlen;\n\tloff_t from;\n\tint bits = td->options & NAND_BBT_NRBITS_MSK;\n\tuint8_t msk = (uint8_t)((1 << bits) - 1);\n\tu32 marker_len;\n\tint reserved_block_code = td->reserved_block_code;\n\n\ttotlen = (num * bits) >> 3;\n\tmarker_len = add_marker_len(td);\n\tfrom = ((loff_t)page) << this->page_shift;\n\n\twhile (totlen) {\n\t\tlen = min(totlen, (size_t)(1 << this->bbt_erase_shift));\n\t\tif (marker_len) {\n\t\t\t \n\t\t\tlen -= marker_len;\n\t\t\tfrom += marker_len;\n\t\t\tmarker_len = 0;\n\t\t}\n\t\tres = mtd_read(mtd, from, len, &retlen, buf);\n\t\tif (res < 0) {\n\t\t\tif (mtd_is_eccerr(res)) {\n\t\t\t\tpr_info(\"nand_bbt: ECC error in BBT at 0x%012llx\\n\",\n\t\t\t\t\tfrom & ~mtd->writesize);\n\t\t\t\treturn res;\n\t\t\t} else if (mtd_is_bitflip(res)) {\n\t\t\t\tpr_info(\"nand_bbt: corrected error in BBT at 0x%012llx\\n\",\n\t\t\t\t\tfrom & ~mtd->writesize);\n\t\t\t\tret = res;\n\t\t\t} else {\n\t\t\t\tpr_info(\"nand_bbt: error reading BBT\\n\");\n\t\t\t\treturn res;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tfor (i = 0; i < len; i++) {\n\t\t\tuint8_t dat = buf[i];\n\t\t\tfor (j = 0; j < 8; j += bits, act++) {\n\t\t\t\tuint8_t tmp = (dat >> j) & msk;\n\t\t\t\tif (tmp == msk)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (reserved_block_code && (tmp == reserved_block_code)) {\n\t\t\t\t\tpr_info(\"nand_read_bbt: reserved block at 0x%012llx\\n\",\n\t\t\t\t\t\t (loff_t)(offs + act) <<\n\t\t\t\t\t\t this->bbt_erase_shift);\n\t\t\t\t\tbbt_mark_entry(this, offs + act,\n\t\t\t\t\t\t\tBBT_BLOCK_RESERVED);\n\t\t\t\t\tmtd->ecc_stats.bbtblocks++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t \n\t\t\t\tpr_info(\"nand_read_bbt: bad block at 0x%012llx\\n\",\n\t\t\t\t\t (loff_t)(offs + act) <<\n\t\t\t\t\t this->bbt_erase_shift);\n\t\t\t\t \n\t\t\t\tif (tmp == 0)\n\t\t\t\t\tbbt_mark_entry(this, offs + act,\n\t\t\t\t\t\t\tBBT_BLOCK_FACTORY_BAD);\n\t\t\t\telse\n\t\t\t\t\tbbt_mark_entry(this, offs + act,\n\t\t\t\t\t\t\tBBT_BLOCK_WORN);\n\t\t\t\tmtd->ecc_stats.badblocks++;\n\t\t\t}\n\t\t}\n\t\ttotlen -= len;\n\t\tfrom += len;\n\t}\n\treturn ret;\n}\n\n \nstatic int read_abs_bbt(struct nand_chip *this, uint8_t *buf,\n\t\t\tstruct nand_bbt_descr *td, int chip)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(this);\n\tu64 targetsize = nanddev_target_size(&this->base);\n\tint res = 0, i;\n\n\tif (td->options & NAND_BBT_PERCHIP) {\n\t\tint offs = 0;\n\t\tfor (i = 0; i < nanddev_ntargets(&this->base); i++) {\n\t\t\tif (chip == -1 || chip == i)\n\t\t\t\tres = read_bbt(this, buf, td->pages[i],\n\t\t\t\t\ttargetsize >> this->bbt_erase_shift,\n\t\t\t\t\ttd, offs);\n\t\t\tif (res)\n\t\t\t\treturn res;\n\t\t\toffs += targetsize >> this->bbt_erase_shift;\n\t\t}\n\t} else {\n\t\tres = read_bbt(this, buf, td->pages[0],\n\t\t\t\tmtd->size >> this->bbt_erase_shift, td, 0);\n\t\tif (res)\n\t\t\treturn res;\n\t}\n\treturn 0;\n}\n\n \nstatic int scan_read_data(struct nand_chip *this, uint8_t *buf, loff_t offs,\n\t\t\t  struct nand_bbt_descr *td)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(this);\n\tsize_t retlen;\n\tsize_t len;\n\n\tlen = td->len;\n\tif (td->options & NAND_BBT_VERSION)\n\t\tlen++;\n\n\treturn mtd_read(mtd, offs, len, &retlen, buf);\n}\n\n \nstatic int scan_read_oob(struct nand_chip *this, uint8_t *buf, loff_t offs,\n\t\t\t size_t len)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(this);\n\tstruct mtd_oob_ops ops = { };\n\tint res, ret = 0;\n\n\tops.mode = MTD_OPS_PLACE_OOB;\n\tops.ooboffs = 0;\n\tops.ooblen = mtd->oobsize;\n\n\twhile (len > 0) {\n\t\tops.datbuf = buf;\n\t\tops.len = min(len, (size_t)mtd->writesize);\n\t\tops.oobbuf = buf + ops.len;\n\n\t\tres = mtd_read_oob(mtd, offs, &ops);\n\t\tif (res) {\n\t\t\tif (!mtd_is_bitflip_or_eccerr(res))\n\t\t\t\treturn res;\n\t\t\telse if (mtd_is_eccerr(res) || !ret)\n\t\t\t\tret = res;\n\t\t}\n\n\t\tbuf += mtd->oobsize + mtd->writesize;\n\t\tlen -= mtd->writesize;\n\t\toffs += mtd->writesize;\n\t}\n\treturn ret;\n}\n\nstatic int scan_read(struct nand_chip *this, uint8_t *buf, loff_t offs,\n\t\t     size_t len, struct nand_bbt_descr *td)\n{\n\tif (td->options & NAND_BBT_NO_OOB)\n\t\treturn scan_read_data(this, buf, offs, td);\n\telse\n\t\treturn scan_read_oob(this, buf, offs, len);\n}\n\n \nstatic int scan_write_bbt(struct nand_chip *this, loff_t offs, size_t len,\n\t\t\t  uint8_t *buf, uint8_t *oob)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(this);\n\tstruct mtd_oob_ops ops = { };\n\n\tops.mode = MTD_OPS_PLACE_OOB;\n\tops.ooboffs = 0;\n\tops.ooblen = mtd->oobsize;\n\tops.datbuf = buf;\n\tops.oobbuf = oob;\n\tops.len = len;\n\n\treturn mtd_write_oob(mtd, offs, &ops);\n}\n\nstatic u32 bbt_get_ver_offs(struct nand_chip *this, struct nand_bbt_descr *td)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(this);\n\tu32 ver_offs = td->veroffs;\n\n\tif (!(td->options & NAND_BBT_NO_OOB))\n\t\tver_offs += mtd->writesize;\n\treturn ver_offs;\n}\n\n \nstatic void read_abs_bbts(struct nand_chip *this, uint8_t *buf,\n\t\t\t  struct nand_bbt_descr *td, struct nand_bbt_descr *md)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(this);\n\n\t \n\tif (td->options & NAND_BBT_VERSION) {\n\t\tscan_read(this, buf, (loff_t)td->pages[0] << this->page_shift,\n\t\t\t  mtd->writesize, td);\n\t\ttd->version[0] = buf[bbt_get_ver_offs(this, td)];\n\t\tpr_info(\"Bad block table at page %d, version 0x%02X\\n\",\n\t\t\t td->pages[0], td->version[0]);\n\t}\n\n\t \n\tif (md && (md->options & NAND_BBT_VERSION)) {\n\t\tscan_read(this, buf, (loff_t)md->pages[0] << this->page_shift,\n\t\t\t  mtd->writesize, md);\n\t\tmd->version[0] = buf[bbt_get_ver_offs(this, md)];\n\t\tpr_info(\"Bad block table at page %d, version 0x%02X\\n\",\n\t\t\t md->pages[0], md->version[0]);\n\t}\n}\n\n \nstatic int scan_block_fast(struct nand_chip *this, struct nand_bbt_descr *bd,\n\t\t\t   loff_t offs, uint8_t *buf)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(this);\n\n\tstruct mtd_oob_ops ops = { };\n\tint ret, page_offset;\n\n\tops.ooblen = mtd->oobsize;\n\tops.oobbuf = buf;\n\tops.ooboffs = 0;\n\tops.datbuf = NULL;\n\tops.mode = MTD_OPS_PLACE_OOB;\n\n\tpage_offset = nand_bbm_get_next_page(this, 0);\n\n\twhile (page_offset >= 0) {\n\t\t \n\t\tret = mtd_read_oob(mtd, offs + (page_offset * mtd->writesize),\n\t\t\t\t   &ops);\n\t\t \n\t\tif (ret && !mtd_is_bitflip_or_eccerr(ret))\n\t\t\treturn ret;\n\n\t\tif (check_short_pattern(buf, bd))\n\t\t\treturn 1;\n\n\t\tpage_offset = nand_bbm_get_next_page(this, page_offset + 1);\n\t}\n\n\treturn 0;\n}\n\n \nstatic int bbt_block_checkbad(struct nand_chip *this, struct nand_bbt_descr *td,\n\t\t\t      loff_t offs, uint8_t *buf)\n{\n\tstruct nand_bbt_descr *bd = this->badblock_pattern;\n\n\t \n\tif (!(td->options & NAND_BBT_NO_OOB) &&\n\t    td->offs >= bd->offs && td->offs < bd->offs + bd->len)\n\t\treturn 0;\n\n\t \n\tif (this->bbt_options & NAND_BBT_NO_OOB_BBM ||\n\t    this->options & NAND_NO_BBM_QUIRK)\n\t\treturn 0;\n\n\tif (scan_block_fast(this, bd, offs, buf) > 0)\n\t\treturn 1;\n\n\treturn 0;\n}\n\n \nstatic int create_bbt(struct nand_chip *this, uint8_t *buf,\n\t\t      struct nand_bbt_descr *bd, int chip)\n{\n\tu64 targetsize = nanddev_target_size(&this->base);\n\tstruct mtd_info *mtd = nand_to_mtd(this);\n\tint i, numblocks, startblock;\n\tloff_t from;\n\n\tpr_info(\"Scanning device for bad blocks\\n\");\n\n\tif (chip == -1) {\n\t\tnumblocks = mtd->size >> this->bbt_erase_shift;\n\t\tstartblock = 0;\n\t\tfrom = 0;\n\t} else {\n\t\tif (chip >= nanddev_ntargets(&this->base)) {\n\t\t\tpr_warn(\"create_bbt(): chipnr (%d) > available chips (%d)\\n\",\n\t\t\t        chip + 1, nanddev_ntargets(&this->base));\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tnumblocks = targetsize >> this->bbt_erase_shift;\n\t\tstartblock = chip * numblocks;\n\t\tnumblocks += startblock;\n\t\tfrom = (loff_t)startblock << this->bbt_erase_shift;\n\t}\n\n\tfor (i = startblock; i < numblocks; i++) {\n\t\tint ret;\n\n\t\tBUG_ON(bd->options & NAND_BBT_NO_OOB);\n\n\t\tret = scan_block_fast(this, bd, from, buf);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tif (ret) {\n\t\t\tbbt_mark_entry(this, i, BBT_BLOCK_FACTORY_BAD);\n\t\t\tpr_warn(\"Bad eraseblock %d at 0x%012llx\\n\",\n\t\t\t\ti, (unsigned long long)from);\n\t\t\tmtd->ecc_stats.badblocks++;\n\t\t}\n\n\t\tfrom += (1 << this->bbt_erase_shift);\n\t}\n\treturn 0;\n}\n\n \nstatic int search_bbt(struct nand_chip *this, uint8_t *buf,\n\t\t      struct nand_bbt_descr *td)\n{\n\tu64 targetsize = nanddev_target_size(&this->base);\n\tstruct mtd_info *mtd = nand_to_mtd(this);\n\tint i, chips;\n\tint startblock, block, dir;\n\tint scanlen = mtd->writesize + mtd->oobsize;\n\tint bbtblocks;\n\tint blocktopage = this->bbt_erase_shift - this->page_shift;\n\n\t \n\tif (td->options & NAND_BBT_LASTBLOCK) {\n\t\tstartblock = (mtd->size >> this->bbt_erase_shift) - 1;\n\t\tdir = -1;\n\t} else {\n\t\tstartblock = 0;\n\t\tdir = 1;\n\t}\n\n\t \n\tif (td->options & NAND_BBT_PERCHIP) {\n\t\tchips = nanddev_ntargets(&this->base);\n\t\tbbtblocks = targetsize >> this->bbt_erase_shift;\n\t\tstartblock &= bbtblocks - 1;\n\t} else {\n\t\tchips = 1;\n\t\tbbtblocks = mtd->size >> this->bbt_erase_shift;\n\t}\n\n\tfor (i = 0; i < chips; i++) {\n\t\t \n\t\ttd->version[i] = 0;\n\t\ttd->pages[i] = -1;\n\t\t \n\t\tfor (block = 0; block < td->maxblocks; block++) {\n\n\t\t\tint actblock = startblock + dir * block;\n\t\t\tloff_t offs = (loff_t)actblock << this->bbt_erase_shift;\n\n\t\t\t \n\t\t\tif (bbt_block_checkbad(this, td, offs, buf))\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tscan_read(this, buf, offs, mtd->writesize, td);\n\t\t\tif (!check_pattern(buf, scanlen, mtd->writesize, td)) {\n\t\t\t\ttd->pages[i] = actblock << blocktopage;\n\t\t\t\tif (td->options & NAND_BBT_VERSION) {\n\t\t\t\t\toffs = bbt_get_ver_offs(this, td);\n\t\t\t\t\ttd->version[i] = buf[offs];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tstartblock += targetsize >> this->bbt_erase_shift;\n\t}\n\t \n\tfor (i = 0; i < chips; i++) {\n\t\tif (td->pages[i] == -1)\n\t\t\tpr_warn(\"Bad block table not found for chip %d\\n\", i);\n\t\telse\n\t\t\tpr_info(\"Bad block table found at page %d, version 0x%02X\\n\",\n\t\t\t\ttd->pages[i], td->version[i]);\n\t}\n\treturn 0;\n}\n\n \nstatic void search_read_bbts(struct nand_chip *this, uint8_t *buf,\n\t\t\t     struct nand_bbt_descr *td,\n\t\t\t     struct nand_bbt_descr *md)\n{\n\t \n\tsearch_bbt(this, buf, td);\n\n\t \n\tif (md)\n\t\tsearch_bbt(this, buf, md);\n}\n\n \nstatic int get_bbt_block(struct nand_chip *this, struct nand_bbt_descr *td,\n\t\t\t struct nand_bbt_descr *md, int chip)\n{\n\tu64 targetsize = nanddev_target_size(&this->base);\n\tint startblock, dir, page, numblocks, i;\n\n\t \n\tif (td->pages[chip] != -1)\n\t\treturn td->pages[chip] >>\n\t\t\t\t(this->bbt_erase_shift - this->page_shift);\n\n\tnumblocks = (int)(targetsize >> this->bbt_erase_shift);\n\tif (!(td->options & NAND_BBT_PERCHIP))\n\t\tnumblocks *= nanddev_ntargets(&this->base);\n\n\t \n\tif (td->options & NAND_BBT_LASTBLOCK) {\n\t\tstartblock = numblocks * (chip + 1) - 1;\n\t\tdir = -1;\n\t} else {\n\t\tstartblock = chip * numblocks;\n\t\tdir = 1;\n\t}\n\n\tfor (i = 0; i < td->maxblocks; i++) {\n\t\tint block = startblock + dir * i;\n\n\t\t \n\t\tswitch (bbt_get_entry(this, block)) {\n\t\tcase BBT_BLOCK_WORN:\n\t\tcase BBT_BLOCK_FACTORY_BAD:\n\t\t\tcontinue;\n\t\t}\n\n\t\tpage = block << (this->bbt_erase_shift - this->page_shift);\n\n\t\t \n\t\tif (!md || md->pages[chip] != page)\n\t\t\treturn block;\n\t}\n\n\treturn -ENOSPC;\n}\n\n \nstatic void mark_bbt_block_bad(struct nand_chip *this,\n\t\t\t       struct nand_bbt_descr *td,\n\t\t\t       int chip, int block)\n{\n\tloff_t to;\n\tint res;\n\n\tbbt_mark_entry(this, block, BBT_BLOCK_WORN);\n\n\tto = (loff_t)block << this->bbt_erase_shift;\n\tres = nand_markbad_bbm(this, to);\n\tif (res)\n\t\tpr_warn(\"nand_bbt: error %d while marking block %d bad\\n\",\n\t\t\tres, block);\n\n\ttd->pages[chip] = -1;\n}\n\n \nstatic int write_bbt(struct nand_chip *this, uint8_t *buf,\n\t\t     struct nand_bbt_descr *td, struct nand_bbt_descr *md,\n\t\t     int chipsel)\n{\n\tu64 targetsize = nanddev_target_size(&this->base);\n\tstruct mtd_info *mtd = nand_to_mtd(this);\n\tstruct erase_info einfo;\n\tint i, res, chip = 0;\n\tint bits, page, offs, numblocks, sft, sftmsk;\n\tint nrchips, pageoffs, ooboffs;\n\tuint8_t msk[4];\n\tuint8_t rcode = td->reserved_block_code;\n\tsize_t retlen, len = 0;\n\tloff_t to;\n\tstruct mtd_oob_ops ops = { };\n\n\tops.ooblen = mtd->oobsize;\n\tops.ooboffs = 0;\n\tops.datbuf = NULL;\n\tops.mode = MTD_OPS_PLACE_OOB;\n\n\tif (!rcode)\n\t\trcode = 0xff;\n\t \n\tif (td->options & NAND_BBT_PERCHIP) {\n\t\tnumblocks = (int)(targetsize >> this->bbt_erase_shift);\n\t\t \n\t\tif (chipsel == -1) {\n\t\t\tnrchips = nanddev_ntargets(&this->base);\n\t\t} else {\n\t\t\tnrchips = chipsel + 1;\n\t\t\tchip = chipsel;\n\t\t}\n\t} else {\n\t\tnumblocks = (int)(mtd->size >> this->bbt_erase_shift);\n\t\tnrchips = 1;\n\t}\n\n\t \n\twhile (chip < nrchips) {\n\t\tint block;\n\n\t\tblock = get_bbt_block(this, td, md, chip);\n\t\tif (block < 0) {\n\t\t\tpr_err(\"No space left to write bad block table\\n\");\n\t\t\tres = block;\n\t\t\tgoto outerr;\n\t\t}\n\n\t\t \n\t\tpage = block << (this->bbt_erase_shift - this->page_shift);\n\n\t\t \n\t\tbits = td->options & NAND_BBT_NRBITS_MSK;\n\t\tmsk[2] = ~rcode;\n\t\tswitch (bits) {\n\t\tcase 1: sft = 3; sftmsk = 0x07; msk[0] = 0x00; msk[1] = 0x01;\n\t\t\tmsk[3] = 0x01;\n\t\t\tbreak;\n\t\tcase 2: sft = 2; sftmsk = 0x06; msk[0] = 0x00; msk[1] = 0x01;\n\t\t\tmsk[3] = 0x03;\n\t\t\tbreak;\n\t\tcase 4: sft = 1; sftmsk = 0x04; msk[0] = 0x00; msk[1] = 0x0C;\n\t\t\tmsk[3] = 0x0f;\n\t\t\tbreak;\n\t\tcase 8: sft = 0; sftmsk = 0x00; msk[0] = 0x00; msk[1] = 0x0F;\n\t\t\tmsk[3] = 0xff;\n\t\t\tbreak;\n\t\tdefault: return -EINVAL;\n\t\t}\n\n\t\tto = ((loff_t)page) << this->page_shift;\n\n\t\t \n\t\tif (td->options & NAND_BBT_SAVECONTENT) {\n\t\t\t \n\t\t\tto &= ~(((loff_t)1 << this->bbt_erase_shift) - 1);\n\t\t\tlen = 1 << this->bbt_erase_shift;\n\t\t\tres = mtd_read(mtd, to, len, &retlen, buf);\n\t\t\tif (res < 0) {\n\t\t\t\tif (retlen != len) {\n\t\t\t\t\tpr_info(\"nand_bbt: error reading block for writing the bad block table\\n\");\n\t\t\t\t\treturn res;\n\t\t\t\t}\n\t\t\t\tpr_warn(\"nand_bbt: ECC error while reading block for writing bad block table\\n\");\n\t\t\t}\n\t\t\t \n\t\t\tops.ooblen = (len >> this->page_shift) * mtd->oobsize;\n\t\t\tops.oobbuf = &buf[len];\n\t\t\tres = mtd_read_oob(mtd, to + mtd->writesize, &ops);\n\t\t\tif (res < 0 || ops.oobretlen != ops.ooblen)\n\t\t\t\tgoto outerr;\n\n\t\t\t \n\t\t\tpageoffs = page - (int)(to >> this->page_shift);\n\t\t\toffs = pageoffs << this->page_shift;\n\t\t\t \n\t\t\tmemset(&buf[offs], 0xff, (size_t)(numblocks >> sft));\n\t\t\tooboffs = len + (pageoffs * mtd->oobsize);\n\n\t\t} else if (td->options & NAND_BBT_NO_OOB) {\n\t\t\tooboffs = 0;\n\t\t\toffs = td->len;\n\t\t\t \n\t\t\tif (td->options & NAND_BBT_VERSION)\n\t\t\t\toffs++;\n\t\t\t \n\t\t\tlen = (size_t)(numblocks >> sft);\n\t\t\tlen += offs;\n\t\t\t \n\t\t\tlen = ALIGN(len, mtd->writesize);\n\t\t\t \n\t\t\tmemset(buf, 0xff, len);\n\t\t\t \n\t\t\tmemcpy(buf, td->pattern, td->len);\n\t\t} else {\n\t\t\t \n\t\t\tlen = (size_t)(numblocks >> sft);\n\t\t\t \n\t\t\tlen = ALIGN(len, mtd->writesize);\n\t\t\t \n\t\t\tmemset(buf, 0xff, len +\n\t\t\t       (len >> this->page_shift)* mtd->oobsize);\n\t\t\toffs = 0;\n\t\t\tooboffs = len;\n\t\t\t \n\t\t\tmemcpy(&buf[ooboffs + td->offs], td->pattern, td->len);\n\t\t}\n\n\t\tif (td->options & NAND_BBT_VERSION)\n\t\t\tbuf[ooboffs + td->veroffs] = td->version[chip];\n\n\t\t \n\t\tfor (i = 0; i < numblocks; i++) {\n\t\t\tuint8_t dat;\n\t\t\tint sftcnt = (i << (3 - sft)) & sftmsk;\n\t\t\tdat = bbt_get_entry(this, chip * numblocks + i);\n\t\t\t \n\t\t\tbuf[offs + (i >> sft)] &= ~(msk[dat] << sftcnt);\n\t\t}\n\n\t\tmemset(&einfo, 0, sizeof(einfo));\n\t\teinfo.addr = to;\n\t\teinfo.len = 1 << this->bbt_erase_shift;\n\t\tres = nand_erase_nand(this, &einfo, 1);\n\t\tif (res < 0) {\n\t\t\tpr_warn(\"nand_bbt: error while erasing BBT block %d\\n\",\n\t\t\t\tres);\n\t\t\tmark_bbt_block_bad(this, td, chip, block);\n\t\t\tcontinue;\n\t\t}\n\n\t\tres = scan_write_bbt(this, to, len, buf,\n\t\t\t\t     td->options & NAND_BBT_NO_OOB ?\n\t\t\t\t     NULL : &buf[len]);\n\t\tif (res < 0) {\n\t\t\tpr_warn(\"nand_bbt: error while writing BBT block %d\\n\",\n\t\t\t\tres);\n\t\t\tmark_bbt_block_bad(this, td, chip, block);\n\t\t\tcontinue;\n\t\t}\n\n\t\tpr_info(\"Bad block table written to 0x%012llx, version 0x%02X\\n\",\n\t\t\t (unsigned long long)to, td->version[chip]);\n\n\t\t \n\t\ttd->pages[chip++] = page;\n\t}\n\treturn 0;\n\n outerr:\n\tpr_warn(\"nand_bbt: error while writing bad block table %d\\n\", res);\n\treturn res;\n}\n\n \nstatic inline int nand_memory_bbt(struct nand_chip *this,\n\t\t\t\t  struct nand_bbt_descr *bd)\n{\n\tu8 *pagebuf = nand_get_data_buf(this);\n\n\treturn create_bbt(this, pagebuf, bd, -1);\n}\n\n \nstatic int check_create(struct nand_chip *this, uint8_t *buf,\n\t\t\tstruct nand_bbt_descr *bd)\n{\n\tint i, chips, writeops, create, chipsel, res, res2;\n\tstruct nand_bbt_descr *td = this->bbt_td;\n\tstruct nand_bbt_descr *md = this->bbt_md;\n\tstruct nand_bbt_descr *rd, *rd2;\n\n\t \n\tif (td->options & NAND_BBT_PERCHIP)\n\t\tchips = nanddev_ntargets(&this->base);\n\telse\n\t\tchips = 1;\n\n\tfor (i = 0; i < chips; i++) {\n\t\twriteops = 0;\n\t\tcreate = 0;\n\t\trd = NULL;\n\t\trd2 = NULL;\n\t\tres = res2 = 0;\n\t\t \n\t\tchipsel = (td->options & NAND_BBT_PERCHIP) ? i : -1;\n\t\t \n\t\tif (md) {\n\t\t\tif (td->pages[i] == -1 && md->pages[i] == -1) {\n\t\t\t\tcreate = 1;\n\t\t\t\twriteops = 0x03;\n\t\t\t} else if (td->pages[i] == -1) {\n\t\t\t\trd = md;\n\t\t\t\twriteops = 0x01;\n\t\t\t} else if (md->pages[i] == -1) {\n\t\t\t\trd = td;\n\t\t\t\twriteops = 0x02;\n\t\t\t} else if (td->version[i] == md->version[i]) {\n\t\t\t\trd = td;\n\t\t\t\tif (!(td->options & NAND_BBT_VERSION))\n\t\t\t\t\trd2 = md;\n\t\t\t} else if (((int8_t)(td->version[i] - md->version[i])) > 0) {\n\t\t\t\trd = td;\n\t\t\t\twriteops = 0x02;\n\t\t\t} else {\n\t\t\t\trd = md;\n\t\t\t\twriteops = 0x01;\n\t\t\t}\n\t\t} else {\n\t\t\tif (td->pages[i] == -1) {\n\t\t\t\tcreate = 1;\n\t\t\t\twriteops = 0x01;\n\t\t\t} else {\n\t\t\t\trd = td;\n\t\t\t}\n\t\t}\n\n\t\tif (create) {\n\t\t\t \n\t\t\tif (!(td->options & NAND_BBT_CREATE))\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tif (!(this->bbt_options & NAND_BBT_CREATE_EMPTY))\n\t\t\t\tcreate_bbt(this, buf, bd, chipsel);\n\n\t\t\ttd->version[i] = 1;\n\t\t\tif (md)\n\t\t\t\tmd->version[i] = 1;\n\t\t}\n\n\t\t \n\t\tif (rd) {\n\t\t\tres = read_abs_bbt(this, buf, rd, chipsel);\n\t\t\tif (mtd_is_eccerr(res)) {\n\t\t\t\t \n\t\t\t\trd->pages[i] = -1;\n\t\t\t\trd->version[i] = 0;\n\t\t\t\ti--;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\t \n\t\tif (rd2) {\n\t\t\tres2 = read_abs_bbt(this, buf, rd2, chipsel);\n\t\t\tif (mtd_is_eccerr(res2)) {\n\t\t\t\t \n\t\t\t\trd2->pages[i] = -1;\n\t\t\t\trd2->version[i] = 0;\n\t\t\t\ti--;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (mtd_is_bitflip(res) || mtd_is_bitflip(res2))\n\t\t\twriteops = 0x03;\n\n\t\t \n\t\tif (md) {\n\t\t\ttd->version[i] = max(td->version[i], md->version[i]);\n\t\t\tmd->version[i] = td->version[i];\n\t\t}\n\n\t\t \n\t\tif ((writeops & 0x01) && (td->options & NAND_BBT_WRITE)) {\n\t\t\tres = write_bbt(this, buf, td, md, chipsel);\n\t\t\tif (res < 0)\n\t\t\t\treturn res;\n\t\t}\n\n\t\t \n\t\tif ((writeops & 0x02) && md && (md->options & NAND_BBT_WRITE)) {\n\t\t\tres = write_bbt(this, buf, md, td, chipsel);\n\t\t\tif (res < 0)\n\t\t\t\treturn res;\n\t\t}\n\t}\n\treturn 0;\n}\n\n \nstatic int nand_update_bbt(struct nand_chip *this, loff_t offs)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(this);\n\tint len, res = 0;\n\tint chip, chipsel;\n\tuint8_t *buf;\n\tstruct nand_bbt_descr *td = this->bbt_td;\n\tstruct nand_bbt_descr *md = this->bbt_md;\n\n\tif (!this->bbt || !td)\n\t\treturn -EINVAL;\n\n\t \n\tlen = (1 << this->bbt_erase_shift);\n\tlen += (len >> this->page_shift) * mtd->oobsize;\n\tbuf = kmalloc(len, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\t \n\tif (td->options & NAND_BBT_PERCHIP) {\n\t\tchip = (int)(offs >> this->chip_shift);\n\t\tchipsel = chip;\n\t} else {\n\t\tchip = 0;\n\t\tchipsel = -1;\n\t}\n\n\ttd->version[chip]++;\n\tif (md)\n\t\tmd->version[chip]++;\n\n\t \n\tif (td->options & NAND_BBT_WRITE) {\n\t\tres = write_bbt(this, buf, td, md, chipsel);\n\t\tif (res < 0)\n\t\t\tgoto out;\n\t}\n\t \n\tif (md && (md->options & NAND_BBT_WRITE)) {\n\t\tres = write_bbt(this, buf, md, td, chipsel);\n\t}\n\n out:\n\tkfree(buf);\n\treturn res;\n}\n\n \nstatic void mark_bbt_region(struct nand_chip *this, struct nand_bbt_descr *td)\n{\n\tu64 targetsize = nanddev_target_size(&this->base);\n\tstruct mtd_info *mtd = nand_to_mtd(this);\n\tint i, j, chips, block, nrblocks, update;\n\tuint8_t oldval;\n\n\t \n\tif (td->options & NAND_BBT_PERCHIP) {\n\t\tchips = nanddev_ntargets(&this->base);\n\t\tnrblocks = (int)(targetsize >> this->bbt_erase_shift);\n\t} else {\n\t\tchips = 1;\n\t\tnrblocks = (int)(mtd->size >> this->bbt_erase_shift);\n\t}\n\n\tfor (i = 0; i < chips; i++) {\n\t\tif ((td->options & NAND_BBT_ABSPAGE) ||\n\t\t    !(td->options & NAND_BBT_WRITE)) {\n\t\t\tif (td->pages[i] == -1)\n\t\t\t\tcontinue;\n\t\t\tblock = td->pages[i] >> (this->bbt_erase_shift - this->page_shift);\n\t\t\toldval = bbt_get_entry(this, block);\n\t\t\tbbt_mark_entry(this, block, BBT_BLOCK_RESERVED);\n\t\t\tif ((oldval != BBT_BLOCK_RESERVED) &&\n\t\t\t\t\ttd->reserved_block_code)\n\t\t\t\tnand_update_bbt(this, (loff_t)block <<\n\t\t\t\t\t\tthis->bbt_erase_shift);\n\t\t\tcontinue;\n\t\t}\n\t\tupdate = 0;\n\t\tif (td->options & NAND_BBT_LASTBLOCK)\n\t\t\tblock = ((i + 1) * nrblocks) - td->maxblocks;\n\t\telse\n\t\t\tblock = i * nrblocks;\n\t\tfor (j = 0; j < td->maxblocks; j++) {\n\t\t\toldval = bbt_get_entry(this, block);\n\t\t\tbbt_mark_entry(this, block, BBT_BLOCK_RESERVED);\n\t\t\tif (oldval != BBT_BLOCK_RESERVED)\n\t\t\t\tupdate = 1;\n\t\t\tblock++;\n\t\t}\n\t\t \n\t\tif (update && td->reserved_block_code)\n\t\t\tnand_update_bbt(this, (loff_t)(block - 1) <<\n\t\t\t\t\tthis->bbt_erase_shift);\n\t}\n}\n\n \nstatic void verify_bbt_descr(struct nand_chip *this, struct nand_bbt_descr *bd)\n{\n\tu64 targetsize = nanddev_target_size(&this->base);\n\tstruct mtd_info *mtd = nand_to_mtd(this);\n\tu32 pattern_len;\n\tu32 bits;\n\tu32 table_size;\n\n\tif (!bd)\n\t\treturn;\n\n\tpattern_len = bd->len;\n\tbits = bd->options & NAND_BBT_NRBITS_MSK;\n\n\tBUG_ON((this->bbt_options & NAND_BBT_NO_OOB) &&\n\t\t\t!(this->bbt_options & NAND_BBT_USE_FLASH));\n\tBUG_ON(!bits);\n\n\tif (bd->options & NAND_BBT_VERSION)\n\t\tpattern_len++;\n\n\tif (bd->options & NAND_BBT_NO_OOB) {\n\t\tBUG_ON(!(this->bbt_options & NAND_BBT_USE_FLASH));\n\t\tBUG_ON(!(this->bbt_options & NAND_BBT_NO_OOB));\n\t\tBUG_ON(bd->offs);\n\t\tif (bd->options & NAND_BBT_VERSION)\n\t\t\tBUG_ON(bd->veroffs != bd->len);\n\t\tBUG_ON(bd->options & NAND_BBT_SAVECONTENT);\n\t}\n\n\tif (bd->options & NAND_BBT_PERCHIP)\n\t\ttable_size = targetsize >> this->bbt_erase_shift;\n\telse\n\t\ttable_size = mtd->size >> this->bbt_erase_shift;\n\ttable_size >>= 3;\n\ttable_size *= bits;\n\tif (bd->options & NAND_BBT_NO_OOB)\n\t\ttable_size += pattern_len;\n\tBUG_ON(table_size > (1 << this->bbt_erase_shift));\n}\n\n \nstatic int nand_scan_bbt(struct nand_chip *this, struct nand_bbt_descr *bd)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(this);\n\tint len, res;\n\tuint8_t *buf;\n\tstruct nand_bbt_descr *td = this->bbt_td;\n\tstruct nand_bbt_descr *md = this->bbt_md;\n\n\tlen = (mtd->size >> (this->bbt_erase_shift + 2)) ? : 1;\n\t \n\tthis->bbt = kzalloc(len, GFP_KERNEL);\n\tif (!this->bbt)\n\t\treturn -ENOMEM;\n\n\t \n\tif (!td) {\n\t\tif ((res = nand_memory_bbt(this, bd))) {\n\t\t\tpr_err(\"nand_bbt: can't scan flash and build the RAM-based BBT\\n\");\n\t\t\tgoto err_free_bbt;\n\t\t}\n\t\treturn 0;\n\t}\n\tverify_bbt_descr(this, td);\n\tverify_bbt_descr(this, md);\n\n\t \n\tlen = (1 << this->bbt_erase_shift);\n\tlen += (len >> this->page_shift) * mtd->oobsize;\n\tbuf = vmalloc(len);\n\tif (!buf) {\n\t\tres = -ENOMEM;\n\t\tgoto err_free_bbt;\n\t}\n\n\t \n\tif (td->options & NAND_BBT_ABSPAGE) {\n\t\tread_abs_bbts(this, buf, td, md);\n\t} else {\n\t\t \n\t\tsearch_read_bbts(this, buf, td, md);\n\t}\n\n\tres = check_create(this, buf, bd);\n\tif (res)\n\t\tgoto err_free_buf;\n\n\t \n\tmark_bbt_region(this, td);\n\tif (md)\n\t\tmark_bbt_region(this, md);\n\n\tvfree(buf);\n\treturn 0;\n\nerr_free_buf:\n\tvfree(buf);\nerr_free_bbt:\n\tkfree(this->bbt);\n\tthis->bbt = NULL;\n\treturn res;\n}\n\n \nstatic uint8_t scan_ff_pattern[] = { 0xff, 0xff };\n\n \nstatic uint8_t bbt_pattern[] = {'B', 'b', 't', '0' };\nstatic uint8_t mirror_pattern[] = {'1', 't', 'b', 'B' };\n\nstatic struct nand_bbt_descr bbt_main_descr = {\n\t.options = NAND_BBT_LASTBLOCK | NAND_BBT_CREATE | NAND_BBT_WRITE\n\t\t| NAND_BBT_2BIT | NAND_BBT_VERSION | NAND_BBT_PERCHIP,\n\t.offs =\t8,\n\t.len = 4,\n\t.veroffs = 12,\n\t.maxblocks = NAND_BBT_SCAN_MAXBLOCKS,\n\t.pattern = bbt_pattern\n};\n\nstatic struct nand_bbt_descr bbt_mirror_descr = {\n\t.options = NAND_BBT_LASTBLOCK | NAND_BBT_CREATE | NAND_BBT_WRITE\n\t\t| NAND_BBT_2BIT | NAND_BBT_VERSION | NAND_BBT_PERCHIP,\n\t.offs =\t8,\n\t.len = 4,\n\t.veroffs = 12,\n\t.maxblocks = NAND_BBT_SCAN_MAXBLOCKS,\n\t.pattern = mirror_pattern\n};\n\nstatic struct nand_bbt_descr bbt_main_no_oob_descr = {\n\t.options = NAND_BBT_LASTBLOCK | NAND_BBT_CREATE | NAND_BBT_WRITE\n\t\t| NAND_BBT_2BIT | NAND_BBT_VERSION | NAND_BBT_PERCHIP\n\t\t| NAND_BBT_NO_OOB,\n\t.len = 4,\n\t.veroffs = 4,\n\t.maxblocks = NAND_BBT_SCAN_MAXBLOCKS,\n\t.pattern = bbt_pattern\n};\n\nstatic struct nand_bbt_descr bbt_mirror_no_oob_descr = {\n\t.options = NAND_BBT_LASTBLOCK | NAND_BBT_CREATE | NAND_BBT_WRITE\n\t\t| NAND_BBT_2BIT | NAND_BBT_VERSION | NAND_BBT_PERCHIP\n\t\t| NAND_BBT_NO_OOB,\n\t.len = 4,\n\t.veroffs = 4,\n\t.maxblocks = NAND_BBT_SCAN_MAXBLOCKS,\n\t.pattern = mirror_pattern\n};\n\n#define BADBLOCK_SCAN_MASK (~NAND_BBT_NO_OOB)\n \nstatic int nand_create_badblock_pattern(struct nand_chip *this)\n{\n\tstruct nand_bbt_descr *bd;\n\tif (this->badblock_pattern) {\n\t\tpr_warn(\"Bad block pattern already allocated; not replacing\\n\");\n\t\treturn -EINVAL;\n\t}\n\tbd = kzalloc(sizeof(*bd), GFP_KERNEL);\n\tif (!bd)\n\t\treturn -ENOMEM;\n\tbd->options = this->bbt_options & BADBLOCK_SCAN_MASK;\n\tbd->offs = this->badblockpos;\n\tbd->len = (this->options & NAND_BUSWIDTH_16) ? 2 : 1;\n\tbd->pattern = scan_ff_pattern;\n\tbd->options |= NAND_BBT_DYNAMICSTRUCT;\n\tthis->badblock_pattern = bd;\n\treturn 0;\n}\n\n \nint nand_create_bbt(struct nand_chip *this)\n{\n\tint ret;\n\n\t \n\tif (this->bbt_options & NAND_BBT_USE_FLASH) {\n\t\t \n\t\tif (!this->bbt_td) {\n\t\t\tif (this->bbt_options & NAND_BBT_NO_OOB) {\n\t\t\t\tthis->bbt_td = &bbt_main_no_oob_descr;\n\t\t\t\tthis->bbt_md = &bbt_mirror_no_oob_descr;\n\t\t\t} else {\n\t\t\t\tthis->bbt_td = &bbt_main_descr;\n\t\t\t\tthis->bbt_md = &bbt_mirror_descr;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tthis->bbt_td = NULL;\n\t\tthis->bbt_md = NULL;\n\t}\n\n\tif (!this->badblock_pattern) {\n\t\tret = nand_create_badblock_pattern(this);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn nand_scan_bbt(this, this->badblock_pattern);\n}\nEXPORT_SYMBOL(nand_create_bbt);\n\n \nint nand_isreserved_bbt(struct nand_chip *this, loff_t offs)\n{\n\tint block;\n\n\tblock = (int)(offs >> this->bbt_erase_shift);\n\treturn bbt_get_entry(this, block) == BBT_BLOCK_RESERVED;\n}\n\n \nint nand_isbad_bbt(struct nand_chip *this, loff_t offs, int allowbbt)\n{\n\tint block, res;\n\n\tblock = (int)(offs >> this->bbt_erase_shift);\n\tres = bbt_get_entry(this, block);\n\n\tpr_debug(\"nand_isbad_bbt(): bbt info for offs 0x%08x: (block %d) 0x%02x\\n\",\n\t\t (unsigned int)offs, block, res);\n\n\tif (mtd_check_expert_analysis_mode())\n\t\treturn 0;\n\n\tswitch (res) {\n\tcase BBT_BLOCK_GOOD:\n\t\treturn 0;\n\tcase BBT_BLOCK_WORN:\n\t\treturn 1;\n\tcase BBT_BLOCK_RESERVED:\n\t\treturn allowbbt ? 0 : 1;\n\t}\n\treturn 1;\n}\n\n \nint nand_markbad_bbt(struct nand_chip *this, loff_t offs)\n{\n\tint block, ret = 0;\n\n\tblock = (int)(offs >> this->bbt_erase_shift);\n\n\t \n\tbbt_mark_entry(this, block, BBT_BLOCK_WORN);\n\n\t \n\tif (this->bbt_options & NAND_BBT_USE_FLASH)\n\t\tret = nand_update_bbt(this, offs);\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}