{
  "module_name": "au1550nd.c",
  "hash_id": "7b41ecd06279e840181f40d14433795e846a00d8cd507884dab3b06d7c3573e9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/nand/raw/au1550nd.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/mtd/mtd.h>\n#include <linux/mtd/rawnand.h>\n#include <linux/mtd/partitions.h>\n#include <linux/platform_device.h>\n#include <asm/io.h>\n#include <asm/mach-au1x00/au1000.h>\n#include <asm/mach-au1x00/au1550nd.h>\n\n\nstruct au1550nd_ctx {\n\tstruct nand_controller controller;\n\tstruct nand_chip chip;\n\n\tint cs;\n\tvoid __iomem *base;\n};\n\nstatic struct au1550nd_ctx *chip_to_au_ctx(struct nand_chip *this)\n{\n\treturn container_of(this, struct au1550nd_ctx, chip);\n}\n\n \nstatic void au_write_buf(struct nand_chip *this, const void *buf,\n\t\t\t unsigned int len)\n{\n\tstruct au1550nd_ctx *ctx = chip_to_au_ctx(this);\n\tconst u8 *p = buf;\n\tint i;\n\n\tfor (i = 0; i < len; i++) {\n\t\twriteb(p[i], ctx->base + MEM_STNAND_DATA);\n\t\twmb();  \n\t}\n}\n\n \nstatic void au_read_buf(struct nand_chip *this, void *buf,\n\t\t\tunsigned int len)\n{\n\tstruct au1550nd_ctx *ctx = chip_to_au_ctx(this);\n\tu8 *p = buf;\n\tint i;\n\n\tfor (i = 0; i < len; i++) {\n\t\tp[i] = readb(ctx->base + MEM_STNAND_DATA);\n\t\twmb();  \n\t}\n}\n\n \nstatic void au_write_buf16(struct nand_chip *this, const void *buf,\n\t\t\t   unsigned int len)\n{\n\tstruct au1550nd_ctx *ctx = chip_to_au_ctx(this);\n\tconst u16 *p = buf;\n\tunsigned int i;\n\n\tlen >>= 1;\n\tfor (i = 0; i < len; i++) {\n\t\twritew(p[i], ctx->base + MEM_STNAND_DATA);\n\t\twmb();  \n\t}\n}\n\n \nstatic void au_read_buf16(struct nand_chip *this, void *buf, unsigned int len)\n{\n\tstruct au1550nd_ctx *ctx = chip_to_au_ctx(this);\n\tunsigned int i;\n\tu16 *p = buf;\n\n\tlen >>= 1;\n\tfor (i = 0; i < len; i++) {\n\t\tp[i] = readw(ctx->base + MEM_STNAND_DATA);\n\t\twmb();  \n\t}\n}\n\nstatic int find_nand_cs(unsigned long nand_base)\n{\n\tvoid __iomem *base =\n\t\t\t(void __iomem *)KSEG1ADDR(AU1000_STATIC_MEM_PHYS_ADDR);\n\tunsigned long addr, staddr, start, mask, end;\n\tint i;\n\n\tfor (i = 0; i < 4; i++) {\n\t\taddr = 0x1000 + (i * 0x10);\t\t\t \n\t\tstaddr = __raw_readl(base + addr + 0x08);\t \n\t\t \n\t\tstart = (staddr << 4) & 0xfffc0000;\n\t\tmask = (staddr << 18) & 0xfffc0000;\n\t\tend = (start | (start - 1)) & ~(start ^ mask);\n\t\tif ((nand_base >= start) && (nand_base < end))\n\t\t\treturn i;\n\t}\n\n\treturn -ENODEV;\n}\n\nstatic int au1550nd_waitrdy(struct nand_chip *this, unsigned int timeout_ms)\n{\n\tunsigned long timeout_jiffies = jiffies;\n\n\ttimeout_jiffies += msecs_to_jiffies(timeout_ms) + 1;\n\tdo {\n\t\tif (alchemy_rdsmem(AU1000_MEM_STSTAT) & 0x1)\n\t\t\treturn 0;\n\n\t\tusleep_range(10, 100);\n\t} while (time_before(jiffies, timeout_jiffies));\n\n\treturn -ETIMEDOUT;\n}\n\nstatic int au1550nd_exec_instr(struct nand_chip *this,\n\t\t\t       const struct nand_op_instr *instr)\n{\n\tstruct au1550nd_ctx *ctx = chip_to_au_ctx(this);\n\tunsigned int i;\n\tint ret = 0;\n\n\tswitch (instr->type) {\n\tcase NAND_OP_CMD_INSTR:\n\t\twriteb(instr->ctx.cmd.opcode,\n\t\t       ctx->base + MEM_STNAND_CMD);\n\t\t \n\t\twmb();\n\t\tbreak;\n\n\tcase NAND_OP_ADDR_INSTR:\n\t\tfor (i = 0; i < instr->ctx.addr.naddrs; i++) {\n\t\t\twriteb(instr->ctx.addr.addrs[i],\n\t\t\t       ctx->base + MEM_STNAND_ADDR);\n\t\t\t \n\t\t\twmb();\n\t\t}\n\t\tbreak;\n\n\tcase NAND_OP_DATA_IN_INSTR:\n\t\tif ((this->options & NAND_BUSWIDTH_16) &&\n\t\t    !instr->ctx.data.force_8bit)\n\t\t\tau_read_buf16(this, instr->ctx.data.buf.in,\n\t\t\t\t      instr->ctx.data.len);\n\t\telse\n\t\t\tau_read_buf(this, instr->ctx.data.buf.in,\n\t\t\t\t    instr->ctx.data.len);\n\t\tbreak;\n\n\tcase NAND_OP_DATA_OUT_INSTR:\n\t\tif ((this->options & NAND_BUSWIDTH_16) &&\n\t\t    !instr->ctx.data.force_8bit)\n\t\t\tau_write_buf16(this, instr->ctx.data.buf.out,\n\t\t\t\t       instr->ctx.data.len);\n\t\telse\n\t\t\tau_write_buf(this, instr->ctx.data.buf.out,\n\t\t\t\t     instr->ctx.data.len);\n\t\tbreak;\n\n\tcase NAND_OP_WAITRDY_INSTR:\n\t\tret = au1550nd_waitrdy(this, instr->ctx.waitrdy.timeout_ms);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (instr->delay_ns)\n\t\tndelay(instr->delay_ns);\n\n\treturn ret;\n}\n\nstatic int au1550nd_exec_op(struct nand_chip *this,\n\t\t\t    const struct nand_operation *op,\n\t\t\t    bool check_only)\n{\n\tstruct au1550nd_ctx *ctx = chip_to_au_ctx(this);\n\tunsigned int i;\n\tint ret;\n\n\tif (check_only)\n\t\treturn 0;\n\n\t \n\talchemy_wrsmem((1 << (4 + ctx->cs)), AU1000_MEM_STNDCTL);\n\t \n\twmb();\n\n\tfor (i = 0; i < op->ninstrs; i++) {\n\t\tret = au1550nd_exec_instr(this, &op->instrs[i]);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\t \n\talchemy_wrsmem(0, AU1000_MEM_STNDCTL);\n\t \n\twmb();\n\n\treturn ret;\n}\n\nstatic int au1550nd_attach_chip(struct nand_chip *chip)\n{\n\tif (chip->ecc.engine_type == NAND_ECC_ENGINE_TYPE_SOFT &&\n\t    chip->ecc.algo == NAND_ECC_ALGO_UNKNOWN)\n\t\tchip->ecc.algo = NAND_ECC_ALGO_HAMMING;\n\n\treturn 0;\n}\n\nstatic const struct nand_controller_ops au1550nd_ops = {\n\t.exec_op = au1550nd_exec_op,\n\t.attach_chip = au1550nd_attach_chip,\n};\n\nstatic int au1550nd_probe(struct platform_device *pdev)\n{\n\tstruct au1550nd_platdata *pd;\n\tstruct au1550nd_ctx *ctx;\n\tstruct nand_chip *this;\n\tstruct mtd_info *mtd;\n\tstruct resource *r;\n\tint ret, cs;\n\n\tpd = dev_get_platdata(&pdev->dev);\n\tif (!pd) {\n\t\tdev_err(&pdev->dev, \"missing platform data\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tctx = kzalloc(sizeof(*ctx), GFP_KERNEL);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\tr = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!r) {\n\t\tdev_err(&pdev->dev, \"no NAND memory resource\\n\");\n\t\tret = -ENODEV;\n\t\tgoto out1;\n\t}\n\tif (request_mem_region(r->start, resource_size(r), \"au1550-nand\")) {\n\t\tdev_err(&pdev->dev, \"cannot claim NAND memory area\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto out1;\n\t}\n\n\tctx->base = ioremap(r->start, 0x1000);\n\tif (!ctx->base) {\n\t\tdev_err(&pdev->dev, \"cannot remap NAND memory area\\n\");\n\t\tret = -ENODEV;\n\t\tgoto out2;\n\t}\n\n\tthis = &ctx->chip;\n\tmtd = nand_to_mtd(this);\n\tmtd->dev.parent = &pdev->dev;\n\n\t \n\tcs = find_nand_cs(r->start);\n\tif (cs < 0) {\n\t\tdev_err(&pdev->dev, \"cannot detect NAND chipselect\\n\");\n\t\tret = -ENODEV;\n\t\tgoto out3;\n\t}\n\tctx->cs = cs;\n\n\tnand_controller_init(&ctx->controller);\n\tctx->controller.ops = &au1550nd_ops;\n\tthis->controller = &ctx->controller;\n\n\tif (pd->devwidth)\n\t\tthis->options |= NAND_BUSWIDTH_16;\n\n\t \n\tthis->ecc.engine_type = NAND_ECC_ENGINE_TYPE_SOFT;\n\n\tret = nand_scan(this, 1);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"NAND scan failed with %d\\n\", ret);\n\t\tgoto out3;\n\t}\n\n\tmtd_device_register(mtd, pd->parts, pd->num_parts);\n\n\tplatform_set_drvdata(pdev, ctx);\n\n\treturn 0;\n\nout3:\n\tiounmap(ctx->base);\nout2:\n\trelease_mem_region(r->start, resource_size(r));\nout1:\n\tkfree(ctx);\n\treturn ret;\n}\n\nstatic void au1550nd_remove(struct platform_device *pdev)\n{\n\tstruct au1550nd_ctx *ctx = platform_get_drvdata(pdev);\n\tstruct resource *r = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tstruct nand_chip *chip = &ctx->chip;\n\tint ret;\n\n\tret = mtd_device_unregister(nand_to_mtd(chip));\n\tWARN_ON(ret);\n\tnand_cleanup(chip);\n\tiounmap(ctx->base);\n\trelease_mem_region(r->start, 0x1000);\n\tkfree(ctx);\n}\n\nstatic struct platform_driver au1550nd_driver = {\n\t.driver = {\n\t\t.name\t= \"au1550-nand\",\n\t},\n\t.probe\t\t= au1550nd_probe,\n\t.remove_new\t= au1550nd_remove,\n};\n\nmodule_platform_driver(au1550nd_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Embedded Edge, LLC\");\nMODULE_DESCRIPTION(\"Board-specific glue layer for NAND flash on Pb1550 board\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}