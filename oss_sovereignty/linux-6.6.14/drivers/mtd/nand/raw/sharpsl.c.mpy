{
  "module_name": "sharpsl.c",
  "hash_id": "d27a924c3af120d2f90c7578faf297cff42bde20ba2726850344dc92086471b3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/nand/raw/sharpsl.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/mtd/mtd.h>\n#include <linux/mtd/rawnand.h>\n#include <linux/mtd/partitions.h>\n#include <linux/mtd/sharpsl.h>\n#include <linux/interrupt.h>\n#include <linux/platform_device.h>\n#include <linux/io.h>\n\nstruct sharpsl_nand {\n\tstruct nand_controller\tcontroller;\n\tstruct nand_chip\tchip;\n\n\tvoid __iomem\t\t*io;\n};\n\nstatic inline struct sharpsl_nand *mtd_to_sharpsl(struct mtd_info *mtd)\n{\n\treturn container_of(mtd_to_nand(mtd), struct sharpsl_nand, chip);\n}\n\n \n#define ECCLPLB\t\t0x00\t \n#define ECCLPUB\t\t0x04\t \n#define ECCCP\t\t0x08\t \n#define ECCCNTR\t\t0x0C\t \n#define ECCCLRR\t\t0x10\t \n#define FLASHIO\t\t0x14\t \n#define FLASHCTL\t0x18\t \n\n \n#define FLRYBY\t\t(1 << 5)\n#define FLCE1\t\t(1 << 4)\n#define FLWP\t\t(1 << 3)\n#define FLALE\t\t(1 << 2)\n#define FLCLE\t\t(1 << 1)\n#define FLCE0\t\t(1 << 0)\n\n \nstatic void sharpsl_nand_hwcontrol(struct nand_chip *chip, int cmd,\n\t\t\t\t   unsigned int ctrl)\n{\n\tstruct sharpsl_nand *sharpsl = mtd_to_sharpsl(nand_to_mtd(chip));\n\n\tif (ctrl & NAND_CTRL_CHANGE) {\n\t\tunsigned char bits = ctrl & 0x07;\n\n\t\tbits |= (ctrl & 0x01) << 4;\n\n\t\tbits ^= 0x11;\n\n\t\twriteb((readb(sharpsl->io + FLASHCTL) & ~0x17) | bits, sharpsl->io + FLASHCTL);\n\t}\n\n\tif (cmd != NAND_CMD_NONE)\n\t\twriteb(cmd, chip->legacy.IO_ADDR_W);\n}\n\nstatic int sharpsl_nand_dev_ready(struct nand_chip *chip)\n{\n\tstruct sharpsl_nand *sharpsl = mtd_to_sharpsl(nand_to_mtd(chip));\n\treturn !((readb(sharpsl->io + FLASHCTL) & FLRYBY) == 0);\n}\n\nstatic void sharpsl_nand_enable_hwecc(struct nand_chip *chip, int mode)\n{\n\tstruct sharpsl_nand *sharpsl = mtd_to_sharpsl(nand_to_mtd(chip));\n\twriteb(0, sharpsl->io + ECCCLRR);\n}\n\nstatic int sharpsl_nand_calculate_ecc(struct nand_chip *chip,\n\t\t\t\t      const u_char * dat, u_char * ecc_code)\n{\n\tstruct sharpsl_nand *sharpsl = mtd_to_sharpsl(nand_to_mtd(chip));\n\tecc_code[0] = ~readb(sharpsl->io + ECCLPUB);\n\tecc_code[1] = ~readb(sharpsl->io + ECCLPLB);\n\tecc_code[2] = (~readb(sharpsl->io + ECCCP) << 2) | 0x03;\n\treturn readb(sharpsl->io + ECCCNTR) != 0;\n}\n\nstatic int sharpsl_attach_chip(struct nand_chip *chip)\n{\n\tif (chip->ecc.engine_type != NAND_ECC_ENGINE_TYPE_ON_HOST)\n\t\treturn 0;\n\n\tchip->ecc.size = 256;\n\tchip->ecc.bytes = 3;\n\tchip->ecc.strength = 1;\n\tchip->ecc.hwctl = sharpsl_nand_enable_hwecc;\n\tchip->ecc.calculate = sharpsl_nand_calculate_ecc;\n\tchip->ecc.correct = rawnand_sw_hamming_correct;\n\n\treturn 0;\n}\n\nstatic const struct nand_controller_ops sharpsl_ops = {\n\t.attach_chip = sharpsl_attach_chip,\n};\n\n \nstatic int sharpsl_nand_probe(struct platform_device *pdev)\n{\n\tstruct nand_chip *this;\n\tstruct mtd_info *mtd;\n\tstruct resource *r;\n\tint err = 0;\n\tstruct sharpsl_nand *sharpsl;\n\tstruct sharpsl_nand_platform_data *data = dev_get_platdata(&pdev->dev);\n\n\tif (!data) {\n\t\tdev_err(&pdev->dev, \"no platform data!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tsharpsl = kzalloc(sizeof(struct sharpsl_nand), GFP_KERNEL);\n\tif (!sharpsl)\n\t\treturn -ENOMEM;\n\n\tr = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!r) {\n\t\tdev_err(&pdev->dev, \"no io memory resource defined!\\n\");\n\t\terr = -ENODEV;\n\t\tgoto err_get_res;\n\t}\n\n\t \n\tsharpsl->io = ioremap(r->start, resource_size(r));\n\tif (!sharpsl->io) {\n\t\tdev_err(&pdev->dev, \"ioremap to access Sharp SL NAND chip failed\\n\");\n\t\terr = -EIO;\n\t\tgoto err_ioremap;\n\t}\n\n\t \n\tthis = (struct nand_chip *)(&sharpsl->chip);\n\n\tnand_controller_init(&sharpsl->controller);\n\tsharpsl->controller.ops = &sharpsl_ops;\n\tthis->controller = &sharpsl->controller;\n\n\t \n\tmtd = nand_to_mtd(this);\n\tmtd->dev.parent = &pdev->dev;\n\tmtd_set_ooblayout(mtd, data->ecc_layout);\n\n\tplatform_set_drvdata(pdev, sharpsl);\n\n\t \n\twriteb(readb(sharpsl->io + FLASHCTL) | FLWP, sharpsl->io + FLASHCTL);\n\n\t \n\tthis->legacy.IO_ADDR_R = sharpsl->io + FLASHIO;\n\tthis->legacy.IO_ADDR_W = sharpsl->io + FLASHIO;\n\t \n\tthis->legacy.cmd_ctrl = sharpsl_nand_hwcontrol;\n\tthis->legacy.dev_ready = sharpsl_nand_dev_ready;\n\t \n\tthis->legacy.chip_delay = 15;\n\tthis->badblock_pattern = data->badblock_pattern;\n\n\t \n\terr = nand_scan(this, 1);\n\tif (err)\n\t\tgoto err_scan;\n\n\t \n\tmtd->name = \"sharpsl-nand\";\n\n\terr = mtd_device_parse_register(mtd, data->part_parsers, NULL,\n\t\t\t\t\tdata->partitions, data->nr_partitions);\n\tif (err)\n\t\tgoto err_add;\n\n\t \n\treturn 0;\n\nerr_add:\n\tnand_cleanup(this);\n\nerr_scan:\n\tiounmap(sharpsl->io);\nerr_ioremap:\nerr_get_res:\n\tkfree(sharpsl);\n\treturn err;\n}\n\n \nstatic void sharpsl_nand_remove(struct platform_device *pdev)\n{\n\tstruct sharpsl_nand *sharpsl = platform_get_drvdata(pdev);\n\tstruct nand_chip *chip = &sharpsl->chip;\n\tint ret;\n\n\t \n\tret = mtd_device_unregister(nand_to_mtd(chip));\n\tWARN_ON(ret);\n\n\t \n\tnand_cleanup(chip);\n\n\tiounmap(sharpsl->io);\n\n\t \n\tkfree(sharpsl);\n}\n\nstatic struct platform_driver sharpsl_nand_driver = {\n\t.driver = {\n\t\t.name\t= \"sharpsl-nand\",\n\t},\n\t.probe\t\t= sharpsl_nand_probe,\n\t.remove_new\t= sharpsl_nand_remove,\n};\n\nmodule_platform_driver(sharpsl_nand_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Richard Purdie <rpurdie@rpsys.net>\");\nMODULE_DESCRIPTION(\"Device specific logic for NAND flash on Sharp SL-C7xx Series\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}