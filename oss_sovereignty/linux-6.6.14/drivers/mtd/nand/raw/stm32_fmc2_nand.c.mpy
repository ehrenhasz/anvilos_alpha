{
  "module_name": "stm32_fmc2_nand.c",
  "hash_id": "147367fa01777dd7a01b8978a639e1bf7eed07abdf5a9413c47145b487bbf9b8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/nand/raw/stm32_fmc2_nand.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/clk.h>\n#include <linux/dmaengine.h>\n#include <linux/dma-mapping.h>\n#include <linux/errno.h>\n#include <linux/gpio/consumer.h>\n#include <linux/interrupt.h>\n#include <linux/iopoll.h>\n#include <linux/mfd/syscon.h>\n#include <linux/module.h>\n#include <linux/mtd/rawnand.h>\n#include <linux/of_address.h>\n#include <linux/pinctrl/consumer.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/reset.h>\n\n \n#define FMC2_BBM_LEN\t\t\t2\n\n \n#define FMC2_ECC_STEP_SIZE\t\t512\n\n \n#define FMC2_BCHDSRS_LEN\t\t20\n\n \n#define FMC2_HECCR_LEN\t\t\t4\n\n \n#define FMC2_MAX_SG\t\t\t16\n\n \n#define FMC2_MAX_CE\t\t\t2\n\n \n#define FMC2_MAX_ECC_BUF_LEN\t\t(FMC2_BCHDSRS_LEN * FMC2_MAX_SG)\n\n#define FMC2_TIMEOUT_MS\t\t\t5000\n\n \n#define FMC2_THIZ\t\t\t1\n#define FMC2_TIO\t\t\t8000\n#define FMC2_TSYNC\t\t\t3000\n#define FMC2_PCR_TIMING_MASK\t\t0xf\n#define FMC2_PMEM_PATT_TIMING_MASK\t0xff\n\n \n#define FMC2_BCR1\t\t\t0x0\n#define FMC2_PCR\t\t\t0x80\n#define FMC2_SR\t\t\t\t0x84\n#define FMC2_PMEM\t\t\t0x88\n#define FMC2_PATT\t\t\t0x8c\n#define FMC2_HECCR\t\t\t0x94\n#define FMC2_ISR\t\t\t0x184\n#define FMC2_ICR\t\t\t0x188\n#define FMC2_CSQCR\t\t\t0x200\n#define FMC2_CSQCFGR1\t\t\t0x204\n#define FMC2_CSQCFGR2\t\t\t0x208\n#define FMC2_CSQCFGR3\t\t\t0x20c\n#define FMC2_CSQAR1\t\t\t0x210\n#define FMC2_CSQAR2\t\t\t0x214\n#define FMC2_CSQIER\t\t\t0x220\n#define FMC2_CSQISR\t\t\t0x224\n#define FMC2_CSQICR\t\t\t0x228\n#define FMC2_CSQEMSR\t\t\t0x230\n#define FMC2_BCHIER\t\t\t0x250\n#define FMC2_BCHISR\t\t\t0x254\n#define FMC2_BCHICR\t\t\t0x258\n#define FMC2_BCHPBR1\t\t\t0x260\n#define FMC2_BCHPBR2\t\t\t0x264\n#define FMC2_BCHPBR3\t\t\t0x268\n#define FMC2_BCHPBR4\t\t\t0x26c\n#define FMC2_BCHDSR0\t\t\t0x27c\n#define FMC2_BCHDSR1\t\t\t0x280\n#define FMC2_BCHDSR2\t\t\t0x284\n#define FMC2_BCHDSR3\t\t\t0x288\n#define FMC2_BCHDSR4\t\t\t0x28c\n\n \n#define FMC2_BCR1_FMC2EN\t\tBIT(31)\n\n \n#define FMC2_PCR_PWAITEN\t\tBIT(1)\n#define FMC2_PCR_PBKEN\t\t\tBIT(2)\n#define FMC2_PCR_PWID\t\t\tGENMASK(5, 4)\n#define FMC2_PCR_PWID_BUSWIDTH_8\t0\n#define FMC2_PCR_PWID_BUSWIDTH_16\t1\n#define FMC2_PCR_ECCEN\t\t\tBIT(6)\n#define FMC2_PCR_ECCALG\t\t\tBIT(8)\n#define FMC2_PCR_TCLR\t\t\tGENMASK(12, 9)\n#define FMC2_PCR_TCLR_DEFAULT\t\t0xf\n#define FMC2_PCR_TAR\t\t\tGENMASK(16, 13)\n#define FMC2_PCR_TAR_DEFAULT\t\t0xf\n#define FMC2_PCR_ECCSS\t\t\tGENMASK(19, 17)\n#define FMC2_PCR_ECCSS_512\t\t1\n#define FMC2_PCR_ECCSS_2048\t\t3\n#define FMC2_PCR_BCHECC\t\t\tBIT(24)\n#define FMC2_PCR_WEN\t\t\tBIT(25)\n\n \n#define FMC2_SR_NWRF\t\t\tBIT(6)\n\n \n#define FMC2_PMEM_MEMSET\t\tGENMASK(7, 0)\n#define FMC2_PMEM_MEMWAIT\t\tGENMASK(15, 8)\n#define FMC2_PMEM_MEMHOLD\t\tGENMASK(23, 16)\n#define FMC2_PMEM_MEMHIZ\t\tGENMASK(31, 24)\n#define FMC2_PMEM_DEFAULT\t\t0x0a0a0a0a\n\n \n#define FMC2_PATT_ATTSET\t\tGENMASK(7, 0)\n#define FMC2_PATT_ATTWAIT\t\tGENMASK(15, 8)\n#define FMC2_PATT_ATTHOLD\t\tGENMASK(23, 16)\n#define FMC2_PATT_ATTHIZ\t\tGENMASK(31, 24)\n#define FMC2_PATT_DEFAULT\t\t0x0a0a0a0a\n\n \n#define FMC2_ISR_IHLF\t\t\tBIT(1)\n\n \n#define FMC2_ICR_CIHLF\t\t\tBIT(1)\n\n \n#define FMC2_CSQCR_CSQSTART\t\tBIT(0)\n\n \n#define FMC2_CSQCFGR1_CMD2EN\t\tBIT(1)\n#define FMC2_CSQCFGR1_DMADEN\t\tBIT(2)\n#define FMC2_CSQCFGR1_ACYNBR\t\tGENMASK(6, 4)\n#define FMC2_CSQCFGR1_CMD1\t\tGENMASK(15, 8)\n#define FMC2_CSQCFGR1_CMD2\t\tGENMASK(23, 16)\n#define FMC2_CSQCFGR1_CMD1T\t\tBIT(24)\n#define FMC2_CSQCFGR1_CMD2T\t\tBIT(25)\n\n \n#define FMC2_CSQCFGR2_SQSDTEN\t\tBIT(0)\n#define FMC2_CSQCFGR2_RCMD2EN\t\tBIT(1)\n#define FMC2_CSQCFGR2_DMASEN\t\tBIT(2)\n#define FMC2_CSQCFGR2_RCMD1\t\tGENMASK(15, 8)\n#define FMC2_CSQCFGR2_RCMD2\t\tGENMASK(23, 16)\n#define FMC2_CSQCFGR2_RCMD1T\t\tBIT(24)\n#define FMC2_CSQCFGR2_RCMD2T\t\tBIT(25)\n\n \n#define FMC2_CSQCFGR3_SNBR\t\tGENMASK(13, 8)\n#define FMC2_CSQCFGR3_AC1T\t\tBIT(16)\n#define FMC2_CSQCFGR3_AC2T\t\tBIT(17)\n#define FMC2_CSQCFGR3_AC3T\t\tBIT(18)\n#define FMC2_CSQCFGR3_AC4T\t\tBIT(19)\n#define FMC2_CSQCFGR3_AC5T\t\tBIT(20)\n#define FMC2_CSQCFGR3_SDT\t\tBIT(21)\n#define FMC2_CSQCFGR3_RAC1T\t\tBIT(22)\n#define FMC2_CSQCFGR3_RAC2T\t\tBIT(23)\n\n \n#define FMC2_CSQCAR1_ADDC1\t\tGENMASK(7, 0)\n#define FMC2_CSQCAR1_ADDC2\t\tGENMASK(15, 8)\n#define FMC2_CSQCAR1_ADDC3\t\tGENMASK(23, 16)\n#define FMC2_CSQCAR1_ADDC4\t\tGENMASK(31, 24)\n\n \n#define FMC2_CSQCAR2_ADDC5\t\tGENMASK(7, 0)\n#define FMC2_CSQCAR2_NANDCEN\t\tGENMASK(11, 10)\n#define FMC2_CSQCAR2_SAO\t\tGENMASK(31, 16)\n\n \n#define FMC2_CSQIER_TCIE\t\tBIT(0)\n\n \n#define FMC2_CSQICR_CLEAR_IRQ\t\tGENMASK(4, 0)\n\n \n#define FMC2_CSQEMSR_SEM\t\tGENMASK(15, 0)\n\n \n#define FMC2_BCHIER_DERIE\t\tBIT(1)\n#define FMC2_BCHIER_EPBRIE\t\tBIT(4)\n\n \n#define FMC2_BCHICR_CLEAR_IRQ\t\tGENMASK(4, 0)\n\n \n#define FMC2_BCHDSR0_DUE\t\tBIT(0)\n#define FMC2_BCHDSR0_DEF\t\tBIT(1)\n#define FMC2_BCHDSR0_DEN\t\tGENMASK(7, 4)\n\n \n#define FMC2_BCHDSR1_EBP1\t\tGENMASK(12, 0)\n#define FMC2_BCHDSR1_EBP2\t\tGENMASK(28, 16)\n\n \n#define FMC2_BCHDSR2_EBP3\t\tGENMASK(12, 0)\n#define FMC2_BCHDSR2_EBP4\t\tGENMASK(28, 16)\n\n \n#define FMC2_BCHDSR3_EBP5\t\tGENMASK(12, 0)\n#define FMC2_BCHDSR3_EBP6\t\tGENMASK(28, 16)\n\n \n#define FMC2_BCHDSR4_EBP7\t\tGENMASK(12, 0)\n#define FMC2_BCHDSR4_EBP8\t\tGENMASK(28, 16)\n\nenum stm32_fmc2_ecc {\n\tFMC2_ECC_HAM = 1,\n\tFMC2_ECC_BCH4 = 4,\n\tFMC2_ECC_BCH8 = 8\n};\n\nenum stm32_fmc2_irq_state {\n\tFMC2_IRQ_UNKNOWN = 0,\n\tFMC2_IRQ_BCH,\n\tFMC2_IRQ_SEQ\n};\n\nstruct stm32_fmc2_timings {\n\tu8 tclr;\n\tu8 tar;\n\tu8 thiz;\n\tu8 twait;\n\tu8 thold_mem;\n\tu8 tset_mem;\n\tu8 thold_att;\n\tu8 tset_att;\n};\n\nstruct stm32_fmc2_nand {\n\tstruct nand_chip chip;\n\tstruct gpio_desc *wp_gpio;\n\tstruct stm32_fmc2_timings timings;\n\tint ncs;\n\tint cs_used[FMC2_MAX_CE];\n};\n\nstatic inline struct stm32_fmc2_nand *to_fmc2_nand(struct nand_chip *chip)\n{\n\treturn container_of(chip, struct stm32_fmc2_nand, chip);\n}\n\nstruct stm32_fmc2_nfc {\n\tstruct nand_controller base;\n\tstruct stm32_fmc2_nand nand;\n\tstruct device *dev;\n\tstruct device *cdev;\n\tstruct regmap *regmap;\n\tvoid __iomem *data_base[FMC2_MAX_CE];\n\tvoid __iomem *cmd_base[FMC2_MAX_CE];\n\tvoid __iomem *addr_base[FMC2_MAX_CE];\n\tphys_addr_t io_phys_addr;\n\tphys_addr_t data_phys_addr[FMC2_MAX_CE];\n\tstruct clk *clk;\n\tu8 irq_state;\n\n\tstruct dma_chan *dma_tx_ch;\n\tstruct dma_chan *dma_rx_ch;\n\tstruct dma_chan *dma_ecc_ch;\n\tstruct sg_table dma_data_sg;\n\tstruct sg_table dma_ecc_sg;\n\tu8 *ecc_buf;\n\tint dma_ecc_len;\n\n\tstruct completion complete;\n\tstruct completion dma_data_complete;\n\tstruct completion dma_ecc_complete;\n\n\tu8 cs_assigned;\n\tint cs_sel;\n};\n\nstatic inline struct stm32_fmc2_nfc *to_stm32_nfc(struct nand_controller *base)\n{\n\treturn container_of(base, struct stm32_fmc2_nfc, base);\n}\n\nstatic void stm32_fmc2_nfc_timings_init(struct nand_chip *chip)\n{\n\tstruct stm32_fmc2_nfc *nfc = to_stm32_nfc(chip->controller);\n\tstruct stm32_fmc2_nand *nand = to_fmc2_nand(chip);\n\tstruct stm32_fmc2_timings *timings = &nand->timings;\n\tu32 pmem, patt;\n\n\t \n\tregmap_update_bits(nfc->regmap, FMC2_PCR,\n\t\t\t   FMC2_PCR_TCLR | FMC2_PCR_TAR,\n\t\t\t   FIELD_PREP(FMC2_PCR_TCLR, timings->tclr) |\n\t\t\t   FIELD_PREP(FMC2_PCR_TAR, timings->tar));\n\n\t \n\tpmem = FIELD_PREP(FMC2_PMEM_MEMSET, timings->tset_mem);\n\tpmem |= FIELD_PREP(FMC2_PMEM_MEMWAIT, timings->twait);\n\tpmem |= FIELD_PREP(FMC2_PMEM_MEMHOLD, timings->thold_mem);\n\tpmem |= FIELD_PREP(FMC2_PMEM_MEMHIZ, timings->thiz);\n\tregmap_write(nfc->regmap, FMC2_PMEM, pmem);\n\n\t \n\tpatt = FIELD_PREP(FMC2_PATT_ATTSET, timings->tset_att);\n\tpatt |= FIELD_PREP(FMC2_PATT_ATTWAIT, timings->twait);\n\tpatt |= FIELD_PREP(FMC2_PATT_ATTHOLD, timings->thold_att);\n\tpatt |= FIELD_PREP(FMC2_PATT_ATTHIZ, timings->thiz);\n\tregmap_write(nfc->regmap, FMC2_PATT, patt);\n}\n\nstatic void stm32_fmc2_nfc_setup(struct nand_chip *chip)\n{\n\tstruct stm32_fmc2_nfc *nfc = to_stm32_nfc(chip->controller);\n\tu32 pcr = 0, pcr_mask;\n\n\t \n\tpcr_mask = FMC2_PCR_ECCALG;\n\tpcr_mask |= FMC2_PCR_BCHECC;\n\tif (chip->ecc.strength == FMC2_ECC_BCH8) {\n\t\tpcr |= FMC2_PCR_ECCALG;\n\t\tpcr |= FMC2_PCR_BCHECC;\n\t} else if (chip->ecc.strength == FMC2_ECC_BCH4) {\n\t\tpcr |= FMC2_PCR_ECCALG;\n\t}\n\n\t \n\tpcr_mask |= FMC2_PCR_PWID;\n\tif (chip->options & NAND_BUSWIDTH_16)\n\t\tpcr |= FIELD_PREP(FMC2_PCR_PWID, FMC2_PCR_PWID_BUSWIDTH_16);\n\n\t \n\tpcr_mask |= FMC2_PCR_ECCSS;\n\tpcr |= FIELD_PREP(FMC2_PCR_ECCSS, FMC2_PCR_ECCSS_512);\n\n\tregmap_update_bits(nfc->regmap, FMC2_PCR, pcr_mask, pcr);\n}\n\nstatic int stm32_fmc2_nfc_select_chip(struct nand_chip *chip, int chipnr)\n{\n\tstruct stm32_fmc2_nfc *nfc = to_stm32_nfc(chip->controller);\n\tstruct stm32_fmc2_nand *nand = to_fmc2_nand(chip);\n\tstruct dma_slave_config dma_cfg;\n\tint ret;\n\n\tif (nand->cs_used[chipnr] == nfc->cs_sel)\n\t\treturn 0;\n\n\tnfc->cs_sel = nand->cs_used[chipnr];\n\tstm32_fmc2_nfc_setup(chip);\n\tstm32_fmc2_nfc_timings_init(chip);\n\n\tif (nfc->dma_tx_ch && nfc->dma_rx_ch) {\n\t\tmemset(&dma_cfg, 0, sizeof(dma_cfg));\n\t\tdma_cfg.src_addr = nfc->data_phys_addr[nfc->cs_sel];\n\t\tdma_cfg.dst_addr = nfc->data_phys_addr[nfc->cs_sel];\n\t\tdma_cfg.src_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;\n\t\tdma_cfg.dst_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;\n\t\tdma_cfg.src_maxburst = 32;\n\t\tdma_cfg.dst_maxburst = 32;\n\n\t\tret = dmaengine_slave_config(nfc->dma_tx_ch, &dma_cfg);\n\t\tif (ret) {\n\t\t\tdev_err(nfc->dev, \"tx DMA engine slave config failed\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = dmaengine_slave_config(nfc->dma_rx_ch, &dma_cfg);\n\t\tif (ret) {\n\t\t\tdev_err(nfc->dev, \"rx DMA engine slave config failed\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (nfc->dma_ecc_ch) {\n\t\t \n\t\tmemset(&dma_cfg, 0, sizeof(dma_cfg));\n\t\tdma_cfg.src_addr = nfc->io_phys_addr;\n\t\tdma_cfg.src_addr += chip->ecc.strength == FMC2_ECC_HAM ?\n\t\t\t\t    FMC2_HECCR : FMC2_BCHDSR0;\n\t\tdma_cfg.src_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;\n\n\t\tret = dmaengine_slave_config(nfc->dma_ecc_ch, &dma_cfg);\n\t\tif (ret) {\n\t\t\tdev_err(nfc->dev, \"ECC DMA engine slave config failed\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\t \n\t\tnfc->dma_ecc_len = chip->ecc.strength == FMC2_ECC_HAM ?\n\t\t\t\t   FMC2_HECCR_LEN : FMC2_BCHDSRS_LEN;\n\t}\n\n\treturn 0;\n}\n\nstatic void stm32_fmc2_nfc_set_buswidth_16(struct stm32_fmc2_nfc *nfc, bool set)\n{\n\tu32 pcr;\n\n\tpcr = set ? FIELD_PREP(FMC2_PCR_PWID, FMC2_PCR_PWID_BUSWIDTH_16) :\n\t\t    FIELD_PREP(FMC2_PCR_PWID, FMC2_PCR_PWID_BUSWIDTH_8);\n\n\tregmap_update_bits(nfc->regmap, FMC2_PCR, FMC2_PCR_PWID, pcr);\n}\n\nstatic void stm32_fmc2_nfc_set_ecc(struct stm32_fmc2_nfc *nfc, bool enable)\n{\n\tregmap_update_bits(nfc->regmap, FMC2_PCR, FMC2_PCR_ECCEN,\n\t\t\t   enable ? FMC2_PCR_ECCEN : 0);\n}\n\nstatic void stm32_fmc2_nfc_enable_seq_irq(struct stm32_fmc2_nfc *nfc)\n{\n\tnfc->irq_state = FMC2_IRQ_SEQ;\n\n\tregmap_update_bits(nfc->regmap, FMC2_CSQIER,\n\t\t\t   FMC2_CSQIER_TCIE, FMC2_CSQIER_TCIE);\n}\n\nstatic void stm32_fmc2_nfc_disable_seq_irq(struct stm32_fmc2_nfc *nfc)\n{\n\tregmap_update_bits(nfc->regmap, FMC2_CSQIER, FMC2_CSQIER_TCIE, 0);\n\n\tnfc->irq_state = FMC2_IRQ_UNKNOWN;\n}\n\nstatic void stm32_fmc2_nfc_clear_seq_irq(struct stm32_fmc2_nfc *nfc)\n{\n\tregmap_write(nfc->regmap, FMC2_CSQICR, FMC2_CSQICR_CLEAR_IRQ);\n}\n\nstatic void stm32_fmc2_nfc_enable_bch_irq(struct stm32_fmc2_nfc *nfc, int mode)\n{\n\tnfc->irq_state = FMC2_IRQ_BCH;\n\n\tif (mode == NAND_ECC_WRITE)\n\t\tregmap_update_bits(nfc->regmap, FMC2_BCHIER,\n\t\t\t\t   FMC2_BCHIER_EPBRIE, FMC2_BCHIER_EPBRIE);\n\telse\n\t\tregmap_update_bits(nfc->regmap, FMC2_BCHIER,\n\t\t\t\t   FMC2_BCHIER_DERIE, FMC2_BCHIER_DERIE);\n}\n\nstatic void stm32_fmc2_nfc_disable_bch_irq(struct stm32_fmc2_nfc *nfc)\n{\n\tregmap_update_bits(nfc->regmap, FMC2_BCHIER,\n\t\t\t   FMC2_BCHIER_DERIE | FMC2_BCHIER_EPBRIE, 0);\n\n\tnfc->irq_state = FMC2_IRQ_UNKNOWN;\n}\n\nstatic void stm32_fmc2_nfc_clear_bch_irq(struct stm32_fmc2_nfc *nfc)\n{\n\tregmap_write(nfc->regmap, FMC2_BCHICR, FMC2_BCHICR_CLEAR_IRQ);\n}\n\n \nstatic void stm32_fmc2_nfc_hwctl(struct nand_chip *chip, int mode)\n{\n\tstruct stm32_fmc2_nfc *nfc = to_stm32_nfc(chip->controller);\n\n\tstm32_fmc2_nfc_set_ecc(nfc, false);\n\n\tif (chip->ecc.strength != FMC2_ECC_HAM) {\n\t\tregmap_update_bits(nfc->regmap, FMC2_PCR, FMC2_PCR_WEN,\n\t\t\t\t   mode == NAND_ECC_WRITE ? FMC2_PCR_WEN : 0);\n\n\t\treinit_completion(&nfc->complete);\n\t\tstm32_fmc2_nfc_clear_bch_irq(nfc);\n\t\tstm32_fmc2_nfc_enable_bch_irq(nfc, mode);\n\t}\n\n\tstm32_fmc2_nfc_set_ecc(nfc, true);\n}\n\n \nstatic void stm32_fmc2_nfc_ham_set_ecc(const u32 ecc_sta, u8 *ecc)\n{\n\tecc[0] = ecc_sta;\n\tecc[1] = ecc_sta >> 8;\n\tecc[2] = ecc_sta >> 16;\n}\n\nstatic int stm32_fmc2_nfc_ham_calculate(struct nand_chip *chip, const u8 *data,\n\t\t\t\t\tu8 *ecc)\n{\n\tstruct stm32_fmc2_nfc *nfc = to_stm32_nfc(chip->controller);\n\tu32 sr, heccr;\n\tint ret;\n\n\tret = regmap_read_poll_timeout(nfc->regmap, FMC2_SR, sr,\n\t\t\t\t       sr & FMC2_SR_NWRF, 1,\n\t\t\t\t       1000 * FMC2_TIMEOUT_MS);\n\tif (ret) {\n\t\tdev_err(nfc->dev, \"ham timeout\\n\");\n\t\treturn ret;\n\t}\n\n\tregmap_read(nfc->regmap, FMC2_HECCR, &heccr);\n\tstm32_fmc2_nfc_ham_set_ecc(heccr, ecc);\n\tstm32_fmc2_nfc_set_ecc(nfc, false);\n\n\treturn 0;\n}\n\nstatic int stm32_fmc2_nfc_ham_correct(struct nand_chip *chip, u8 *dat,\n\t\t\t\t      u8 *read_ecc, u8 *calc_ecc)\n{\n\tu8 bit_position = 0, b0, b1, b2;\n\tu32 byte_addr = 0, b;\n\tu32 i, shifting = 1;\n\n\t \n\tb0 = read_ecc[0] ^ calc_ecc[0];\n\tb1 = read_ecc[1] ^ calc_ecc[1];\n\tb2 = read_ecc[2] ^ calc_ecc[2];\n\tb = b0 | (b1 << 8) | (b2 << 16);\n\n\t \n\tif (likely(!b))\n\t\treturn 0;\n\n\t \n\tfor (i = 0; i < 3; i++) {\n\t\tswitch (b % 4) {\n\t\tcase 2:\n\t\t\tbit_position += shifting;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EBADMSG;\n\t\t}\n\t\tshifting <<= 1;\n\t\tb >>= 2;\n\t}\n\n\t \n\tshifting = 1;\n\tfor (i = 0; i < 9; i++) {\n\t\tswitch (b % 4) {\n\t\tcase 2:\n\t\t\tbyte_addr += shifting;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EBADMSG;\n\t\t}\n\t\tshifting <<= 1;\n\t\tb >>= 2;\n\t}\n\n\t \n\tdat[byte_addr] ^= (1 << bit_position);\n\n\treturn 1;\n}\n\n \nstatic int stm32_fmc2_nfc_bch_calculate(struct nand_chip *chip, const u8 *data,\n\t\t\t\t\tu8 *ecc)\n{\n\tstruct stm32_fmc2_nfc *nfc = to_stm32_nfc(chip->controller);\n\tu32 bchpbr;\n\n\t \n\tif (!wait_for_completion_timeout(&nfc->complete,\n\t\t\t\t\t msecs_to_jiffies(FMC2_TIMEOUT_MS))) {\n\t\tdev_err(nfc->dev, \"bch timeout\\n\");\n\t\tstm32_fmc2_nfc_disable_bch_irq(nfc);\n\t\treturn -ETIMEDOUT;\n\t}\n\n\t \n\tregmap_read(nfc->regmap, FMC2_BCHPBR1, &bchpbr);\n\tecc[0] = bchpbr;\n\tecc[1] = bchpbr >> 8;\n\tecc[2] = bchpbr >> 16;\n\tecc[3] = bchpbr >> 24;\n\n\tregmap_read(nfc->regmap, FMC2_BCHPBR2, &bchpbr);\n\tecc[4] = bchpbr;\n\tecc[5] = bchpbr >> 8;\n\tecc[6] = bchpbr >> 16;\n\n\tif (chip->ecc.strength == FMC2_ECC_BCH8) {\n\t\tecc[7] = bchpbr >> 24;\n\n\t\tregmap_read(nfc->regmap, FMC2_BCHPBR3, &bchpbr);\n\t\tecc[8] = bchpbr;\n\t\tecc[9] = bchpbr >> 8;\n\t\tecc[10] = bchpbr >> 16;\n\t\tecc[11] = bchpbr >> 24;\n\n\t\tregmap_read(nfc->regmap, FMC2_BCHPBR4, &bchpbr);\n\t\tecc[12] = bchpbr;\n\t}\n\n\tstm32_fmc2_nfc_set_ecc(nfc, false);\n\n\treturn 0;\n}\n\nstatic int stm32_fmc2_nfc_bch_decode(int eccsize, u8 *dat, u32 *ecc_sta)\n{\n\tu32 bchdsr0 = ecc_sta[0];\n\tu32 bchdsr1 = ecc_sta[1];\n\tu32 bchdsr2 = ecc_sta[2];\n\tu32 bchdsr3 = ecc_sta[3];\n\tu32 bchdsr4 = ecc_sta[4];\n\tu16 pos[8];\n\tint i, den;\n\tunsigned int nb_errs = 0;\n\n\t \n\tif (likely(!(bchdsr0 & FMC2_BCHDSR0_DEF)))\n\t\treturn 0;\n\n\t \n\tif (unlikely(bchdsr0 & FMC2_BCHDSR0_DUE))\n\t\treturn -EBADMSG;\n\n\tpos[0] = FIELD_GET(FMC2_BCHDSR1_EBP1, bchdsr1);\n\tpos[1] = FIELD_GET(FMC2_BCHDSR1_EBP2, bchdsr1);\n\tpos[2] = FIELD_GET(FMC2_BCHDSR2_EBP3, bchdsr2);\n\tpos[3] = FIELD_GET(FMC2_BCHDSR2_EBP4, bchdsr2);\n\tpos[4] = FIELD_GET(FMC2_BCHDSR3_EBP5, bchdsr3);\n\tpos[5] = FIELD_GET(FMC2_BCHDSR3_EBP6, bchdsr3);\n\tpos[6] = FIELD_GET(FMC2_BCHDSR4_EBP7, bchdsr4);\n\tpos[7] = FIELD_GET(FMC2_BCHDSR4_EBP8, bchdsr4);\n\n\tden = FIELD_GET(FMC2_BCHDSR0_DEN, bchdsr0);\n\tfor (i = 0; i < den; i++) {\n\t\tif (pos[i] < eccsize * 8) {\n\t\t\tchange_bit(pos[i], (unsigned long *)dat);\n\t\t\tnb_errs++;\n\t\t}\n\t}\n\n\treturn nb_errs;\n}\n\nstatic int stm32_fmc2_nfc_bch_correct(struct nand_chip *chip, u8 *dat,\n\t\t\t\t      u8 *read_ecc, u8 *calc_ecc)\n{\n\tstruct stm32_fmc2_nfc *nfc = to_stm32_nfc(chip->controller);\n\tu32 ecc_sta[5];\n\n\t \n\tif (!wait_for_completion_timeout(&nfc->complete,\n\t\t\t\t\t msecs_to_jiffies(FMC2_TIMEOUT_MS))) {\n\t\tdev_err(nfc->dev, \"bch timeout\\n\");\n\t\tstm32_fmc2_nfc_disable_bch_irq(nfc);\n\t\treturn -ETIMEDOUT;\n\t}\n\n\tregmap_bulk_read(nfc->regmap, FMC2_BCHDSR0, ecc_sta, 5);\n\n\tstm32_fmc2_nfc_set_ecc(nfc, false);\n\n\treturn stm32_fmc2_nfc_bch_decode(chip->ecc.size, dat, ecc_sta);\n}\n\nstatic int stm32_fmc2_nfc_read_page(struct nand_chip *chip, u8 *buf,\n\t\t\t\t    int oob_required, int page)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tint ret, i, s, stat, eccsize = chip->ecc.size;\n\tint eccbytes = chip->ecc.bytes;\n\tint eccsteps = chip->ecc.steps;\n\tint eccstrength = chip->ecc.strength;\n\tu8 *p = buf;\n\tu8 *ecc_calc = chip->ecc.calc_buf;\n\tu8 *ecc_code = chip->ecc.code_buf;\n\tunsigned int max_bitflips = 0;\n\n\tret = nand_read_page_op(chip, page, 0, NULL, 0);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = mtd->writesize + FMC2_BBM_LEN, s = 0; s < eccsteps;\n\t     s++, i += eccbytes, p += eccsize) {\n\t\tchip->ecc.hwctl(chip, NAND_ECC_READ);\n\n\t\t \n\t\tret = nand_change_read_column_op(chip, s * eccsize, p,\n\t\t\t\t\t\t eccsize, false);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t \n\t\tret = nand_change_read_column_op(chip, i, ecc_code,\n\t\t\t\t\t\t eccbytes, false);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t \n\t\tstat = chip->ecc.correct(chip, p, ecc_code, ecc_calc);\n\t\tif (stat == -EBADMSG)\n\t\t\t \n\t\t\tstat = nand_check_erased_ecc_chunk(p, eccsize,\n\t\t\t\t\t\t\t   ecc_code, eccbytes,\n\t\t\t\t\t\t\t   NULL, 0,\n\t\t\t\t\t\t\t   eccstrength);\n\n\t\tif (stat < 0) {\n\t\t\tmtd->ecc_stats.failed++;\n\t\t} else {\n\t\t\tmtd->ecc_stats.corrected += stat;\n\t\t\tmax_bitflips = max_t(unsigned int, max_bitflips, stat);\n\t\t}\n\t}\n\n\t \n\tif (oob_required) {\n\t\tret = nand_change_read_column_op(chip, mtd->writesize,\n\t\t\t\t\t\t chip->oob_poi, mtd->oobsize,\n\t\t\t\t\t\t false);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn max_bitflips;\n}\n\n \nstatic void stm32_fmc2_nfc_rw_page_init(struct nand_chip *chip, int page,\n\t\t\t\t\tint raw, bool write_data)\n{\n\tstruct stm32_fmc2_nfc *nfc = to_stm32_nfc(chip->controller);\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tu32 ecc_offset = mtd->writesize + FMC2_BBM_LEN;\n\t \n\tu32 cfg[5];\n\n\tregmap_update_bits(nfc->regmap, FMC2_PCR, FMC2_PCR_WEN,\n\t\t\t   write_data ? FMC2_PCR_WEN : 0);\n\n\t \n\tcfg[0] = FMC2_CSQCFGR1_DMADEN | FMC2_CSQCFGR1_CMD1T;\n\tif (write_data)\n\t\tcfg[0] |= FIELD_PREP(FMC2_CSQCFGR1_CMD1, NAND_CMD_SEQIN);\n\telse\n\t\tcfg[0] |= FIELD_PREP(FMC2_CSQCFGR1_CMD1, NAND_CMD_READ0) |\n\t\t\t  FMC2_CSQCFGR1_CMD2EN |\n\t\t\t  FIELD_PREP(FMC2_CSQCFGR1_CMD2, NAND_CMD_READSTART) |\n\t\t\t  FMC2_CSQCFGR1_CMD2T;\n\n\t \n\tif (write_data)\n\t\tcfg[1] = FIELD_PREP(FMC2_CSQCFGR2_RCMD1, NAND_CMD_RNDIN);\n\telse\n\t\tcfg[1] = FIELD_PREP(FMC2_CSQCFGR2_RCMD1, NAND_CMD_RNDOUT) |\n\t\t\t FMC2_CSQCFGR2_RCMD2EN |\n\t\t\t FIELD_PREP(FMC2_CSQCFGR2_RCMD2, NAND_CMD_RNDOUTSTART) |\n\t\t\t FMC2_CSQCFGR2_RCMD1T |\n\t\t\t FMC2_CSQCFGR2_RCMD2T;\n\tif (!raw) {\n\t\tcfg[1] |= write_data ? 0 : FMC2_CSQCFGR2_DMASEN;\n\t\tcfg[1] |= FMC2_CSQCFGR2_SQSDTEN;\n\t}\n\n\t \n\tcfg[2] = FIELD_PREP(FMC2_CSQCFGR3_SNBR, chip->ecc.steps - 1);\n\tif (write_data) {\n\t\tcfg[2] |= FMC2_CSQCFGR3_RAC2T;\n\t\tif (chip->options & NAND_ROW_ADDR_3)\n\t\t\tcfg[2] |= FMC2_CSQCFGR3_AC5T;\n\t\telse\n\t\t\tcfg[2] |= FMC2_CSQCFGR3_AC4T;\n\t}\n\n\t \n\tcfg[3] = FIELD_PREP(FMC2_CSQCAR1_ADDC3, page);\n\tcfg[3] |= FIELD_PREP(FMC2_CSQCAR1_ADDC4, page >> 8);\n\n\t \n\tcfg[4] = FIELD_PREP(FMC2_CSQCAR2_NANDCEN, nfc->cs_sel);\n\tif (chip->options & NAND_BUSWIDTH_16)\n\t\tcfg[4] |= FIELD_PREP(FMC2_CSQCAR2_SAO, ecc_offset >> 1);\n\telse\n\t\tcfg[4] |= FIELD_PREP(FMC2_CSQCAR2_SAO, ecc_offset);\n\tif (chip->options & NAND_ROW_ADDR_3) {\n\t\tcfg[0] |= FIELD_PREP(FMC2_CSQCFGR1_ACYNBR, 5);\n\t\tcfg[4] |= FIELD_PREP(FMC2_CSQCAR2_ADDC5, page >> 16);\n\t} else {\n\t\tcfg[0] |= FIELD_PREP(FMC2_CSQCFGR1_ACYNBR, 4);\n\t}\n\n\tregmap_bulk_write(nfc->regmap, FMC2_CSQCFGR1, cfg, 5);\n}\n\nstatic void stm32_fmc2_nfc_dma_callback(void *arg)\n{\n\tcomplete((struct completion *)arg);\n}\n\n \nstatic int stm32_fmc2_nfc_xfer(struct nand_chip *chip, const u8 *buf,\n\t\t\t       int raw, bool write_data)\n{\n\tstruct stm32_fmc2_nfc *nfc = to_stm32_nfc(chip->controller);\n\tstruct dma_async_tx_descriptor *desc_data, *desc_ecc;\n\tstruct scatterlist *sg;\n\tstruct dma_chan *dma_ch = nfc->dma_rx_ch;\n\tenum dma_data_direction dma_data_dir = DMA_FROM_DEVICE;\n\tenum dma_transfer_direction dma_transfer_dir = DMA_DEV_TO_MEM;\n\tint eccsteps = chip->ecc.steps;\n\tint eccsize = chip->ecc.size;\n\tunsigned long timeout = msecs_to_jiffies(FMC2_TIMEOUT_MS);\n\tconst u8 *p = buf;\n\tint s, ret;\n\n\t \n\tif (write_data) {\n\t\tdma_data_dir = DMA_TO_DEVICE;\n\t\tdma_transfer_dir = DMA_MEM_TO_DEV;\n\t\tdma_ch = nfc->dma_tx_ch;\n\t}\n\n\tfor_each_sg(nfc->dma_data_sg.sgl, sg, eccsteps, s) {\n\t\tsg_set_buf(sg, p, eccsize);\n\t\tp += eccsize;\n\t}\n\n\tret = dma_map_sg(nfc->dev, nfc->dma_data_sg.sgl,\n\t\t\t eccsteps, dma_data_dir);\n\tif (!ret)\n\t\treturn -EIO;\n\n\tdesc_data = dmaengine_prep_slave_sg(dma_ch, nfc->dma_data_sg.sgl,\n\t\t\t\t\t    eccsteps, dma_transfer_dir,\n\t\t\t\t\t    DMA_PREP_INTERRUPT);\n\tif (!desc_data) {\n\t\tret = -ENOMEM;\n\t\tgoto err_unmap_data;\n\t}\n\n\treinit_completion(&nfc->dma_data_complete);\n\treinit_completion(&nfc->complete);\n\tdesc_data->callback = stm32_fmc2_nfc_dma_callback;\n\tdesc_data->callback_param = &nfc->dma_data_complete;\n\tret = dma_submit_error(dmaengine_submit(desc_data));\n\tif (ret)\n\t\tgoto err_unmap_data;\n\n\tdma_async_issue_pending(dma_ch);\n\n\tif (!write_data && !raw) {\n\t\t \n\t\tp = nfc->ecc_buf;\n\t\tfor_each_sg(nfc->dma_ecc_sg.sgl, sg, eccsteps, s) {\n\t\t\tsg_set_buf(sg, p, nfc->dma_ecc_len);\n\t\t\tp += nfc->dma_ecc_len;\n\t\t}\n\n\t\tret = dma_map_sg(nfc->dev, nfc->dma_ecc_sg.sgl,\n\t\t\t\t eccsteps, dma_data_dir);\n\t\tif (!ret) {\n\t\t\tret = -EIO;\n\t\t\tgoto err_unmap_data;\n\t\t}\n\n\t\tdesc_ecc = dmaengine_prep_slave_sg(nfc->dma_ecc_ch,\n\t\t\t\t\t\t   nfc->dma_ecc_sg.sgl,\n\t\t\t\t\t\t   eccsteps, dma_transfer_dir,\n\t\t\t\t\t\t   DMA_PREP_INTERRUPT);\n\t\tif (!desc_ecc) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err_unmap_ecc;\n\t\t}\n\n\t\treinit_completion(&nfc->dma_ecc_complete);\n\t\tdesc_ecc->callback = stm32_fmc2_nfc_dma_callback;\n\t\tdesc_ecc->callback_param = &nfc->dma_ecc_complete;\n\t\tret = dma_submit_error(dmaengine_submit(desc_ecc));\n\t\tif (ret)\n\t\t\tgoto err_unmap_ecc;\n\n\t\tdma_async_issue_pending(nfc->dma_ecc_ch);\n\t}\n\n\tstm32_fmc2_nfc_clear_seq_irq(nfc);\n\tstm32_fmc2_nfc_enable_seq_irq(nfc);\n\n\t \n\tregmap_update_bits(nfc->regmap, FMC2_CSQCR,\n\t\t\t   FMC2_CSQCR_CSQSTART, FMC2_CSQCR_CSQSTART);\n\n\t \n\tif (!wait_for_completion_timeout(&nfc->complete, timeout)) {\n\t\tdev_err(nfc->dev, \"seq timeout\\n\");\n\t\tstm32_fmc2_nfc_disable_seq_irq(nfc);\n\t\tdmaengine_terminate_all(dma_ch);\n\t\tif (!write_data && !raw)\n\t\t\tdmaengine_terminate_all(nfc->dma_ecc_ch);\n\t\tret = -ETIMEDOUT;\n\t\tgoto err_unmap_ecc;\n\t}\n\n\t \n\tif (!wait_for_completion_timeout(&nfc->dma_data_complete, timeout)) {\n\t\tdev_err(nfc->dev, \"data DMA timeout\\n\");\n\t\tdmaengine_terminate_all(dma_ch);\n\t\tret = -ETIMEDOUT;\n\t}\n\n\t \n\tif (!write_data && !raw) {\n\t\tif (!wait_for_completion_timeout(&nfc->dma_ecc_complete,\n\t\t\t\t\t\t timeout)) {\n\t\t\tdev_err(nfc->dev, \"ECC DMA timeout\\n\");\n\t\t\tdmaengine_terminate_all(nfc->dma_ecc_ch);\n\t\t\tret = -ETIMEDOUT;\n\t\t}\n\t}\n\nerr_unmap_ecc:\n\tif (!write_data && !raw)\n\t\tdma_unmap_sg(nfc->dev, nfc->dma_ecc_sg.sgl,\n\t\t\t     eccsteps, dma_data_dir);\n\nerr_unmap_data:\n\tdma_unmap_sg(nfc->dev, nfc->dma_data_sg.sgl, eccsteps, dma_data_dir);\n\n\treturn ret;\n}\n\nstatic int stm32_fmc2_nfc_seq_write(struct nand_chip *chip, const u8 *buf,\n\t\t\t\t    int oob_required, int page, int raw)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tint ret;\n\n\t \n\tstm32_fmc2_nfc_rw_page_init(chip, page, raw, true);\n\n\t \n\tret = stm32_fmc2_nfc_xfer(chip, buf, raw, true);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (oob_required) {\n\t\tret = nand_change_write_column_op(chip, mtd->writesize,\n\t\t\t\t\t\t  chip->oob_poi, mtd->oobsize,\n\t\t\t\t\t\t  false);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn nand_prog_page_end_op(chip);\n}\n\nstatic int stm32_fmc2_nfc_seq_write_page(struct nand_chip *chip, const u8 *buf,\n\t\t\t\t\t int oob_required, int page)\n{\n\tint ret;\n\n\tret = stm32_fmc2_nfc_select_chip(chip, chip->cur_cs);\n\tif (ret)\n\t\treturn ret;\n\n\treturn stm32_fmc2_nfc_seq_write(chip, buf, oob_required, page, false);\n}\n\nstatic int stm32_fmc2_nfc_seq_write_page_raw(struct nand_chip *chip,\n\t\t\t\t\t     const u8 *buf, int oob_required,\n\t\t\t\t\t     int page)\n{\n\tint ret;\n\n\tret = stm32_fmc2_nfc_select_chip(chip, chip->cur_cs);\n\tif (ret)\n\t\treturn ret;\n\n\treturn stm32_fmc2_nfc_seq_write(chip, buf, oob_required, page, true);\n}\n\n \nstatic u16 stm32_fmc2_nfc_get_mapping_status(struct stm32_fmc2_nfc *nfc)\n{\n\tu32 csqemsr;\n\n\tregmap_read(nfc->regmap, FMC2_CSQEMSR, &csqemsr);\n\n\treturn FIELD_GET(FMC2_CSQEMSR_SEM, csqemsr);\n}\n\nstatic int stm32_fmc2_nfc_seq_correct(struct nand_chip *chip, u8 *dat,\n\t\t\t\t      u8 *read_ecc, u8 *calc_ecc)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tstruct stm32_fmc2_nfc *nfc = to_stm32_nfc(chip->controller);\n\tint eccbytes = chip->ecc.bytes;\n\tint eccsteps = chip->ecc.steps;\n\tint eccstrength = chip->ecc.strength;\n\tint i, s, eccsize = chip->ecc.size;\n\tu32 *ecc_sta = (u32 *)nfc->ecc_buf;\n\tu16 sta_map = stm32_fmc2_nfc_get_mapping_status(nfc);\n\tunsigned int max_bitflips = 0;\n\n\tfor (i = 0, s = 0; s < eccsteps; s++, i += eccbytes, dat += eccsize) {\n\t\tint stat = 0;\n\n\t\tif (eccstrength == FMC2_ECC_HAM) {\n\t\t\t \n\t\t\tif (sta_map & BIT(s)) {\n\t\t\t\tstm32_fmc2_nfc_ham_set_ecc(*ecc_sta,\n\t\t\t\t\t\t\t   &calc_ecc[i]);\n\t\t\t\tstat = stm32_fmc2_nfc_ham_correct(chip, dat,\n\t\t\t\t\t\t\t\t  &read_ecc[i],\n\t\t\t\t\t\t\t\t  &calc_ecc[i]);\n\t\t\t}\n\t\t\tecc_sta++;\n\t\t} else {\n\t\t\t \n\t\t\tif (sta_map & BIT(s))\n\t\t\t\tstat = stm32_fmc2_nfc_bch_decode(eccsize, dat,\n\t\t\t\t\t\t\t\t ecc_sta);\n\t\t\tecc_sta += 5;\n\t\t}\n\n\t\tif (stat == -EBADMSG)\n\t\t\t \n\t\t\tstat = nand_check_erased_ecc_chunk(dat, eccsize,\n\t\t\t\t\t\t\t   &read_ecc[i],\n\t\t\t\t\t\t\t   eccbytes,\n\t\t\t\t\t\t\t   NULL, 0,\n\t\t\t\t\t\t\t   eccstrength);\n\n\t\tif (stat < 0) {\n\t\t\tmtd->ecc_stats.failed++;\n\t\t} else {\n\t\t\tmtd->ecc_stats.corrected += stat;\n\t\t\tmax_bitflips = max_t(unsigned int, max_bitflips, stat);\n\t\t}\n\t}\n\n\treturn max_bitflips;\n}\n\nstatic int stm32_fmc2_nfc_seq_read_page(struct nand_chip *chip, u8 *buf,\n\t\t\t\t\tint oob_required, int page)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tstruct stm32_fmc2_nfc *nfc = to_stm32_nfc(chip->controller);\n\tu8 *ecc_calc = chip->ecc.calc_buf;\n\tu8 *ecc_code = chip->ecc.code_buf;\n\tu16 sta_map;\n\tint ret;\n\n\tret = stm32_fmc2_nfc_select_chip(chip, chip->cur_cs);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tstm32_fmc2_nfc_rw_page_init(chip, page, 0, false);\n\n\t \n\tret = stm32_fmc2_nfc_xfer(chip, buf, 0, false);\n\tif (ret)\n\t\treturn ret;\n\n\tsta_map = stm32_fmc2_nfc_get_mapping_status(nfc);\n\n\t \n\tif (likely(!sta_map)) {\n\t\tif (oob_required)\n\t\t\treturn nand_change_read_column_op(chip, mtd->writesize,\n\t\t\t\t\t\t\t  chip->oob_poi,\n\t\t\t\t\t\t\t  mtd->oobsize, false);\n\n\t\treturn 0;\n\t}\n\n\t \n\tret = nand_change_read_column_op(chip, mtd->writesize,\n\t\t\t\t\t chip->oob_poi, mtd->oobsize, false);\n\tif (ret)\n\t\treturn ret;\n\n\tret = mtd_ooblayout_get_eccbytes(mtd, ecc_code, chip->oob_poi, 0,\n\t\t\t\t\t chip->ecc.total);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\treturn chip->ecc.correct(chip, buf, ecc_code, ecc_calc);\n}\n\nstatic int stm32_fmc2_nfc_seq_read_page_raw(struct nand_chip *chip, u8 *buf,\n\t\t\t\t\t    int oob_required, int page)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tint ret;\n\n\tret = stm32_fmc2_nfc_select_chip(chip, chip->cur_cs);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tstm32_fmc2_nfc_rw_page_init(chip, page, 1, false);\n\n\t \n\tret = stm32_fmc2_nfc_xfer(chip, buf, 1, false);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (oob_required)\n\t\treturn nand_change_read_column_op(chip, mtd->writesize,\n\t\t\t\t\t\t  chip->oob_poi, mtd->oobsize,\n\t\t\t\t\t\t  false);\n\n\treturn 0;\n}\n\nstatic irqreturn_t stm32_fmc2_nfc_irq(int irq, void *dev_id)\n{\n\tstruct stm32_fmc2_nfc *nfc = (struct stm32_fmc2_nfc *)dev_id;\n\n\tif (nfc->irq_state == FMC2_IRQ_SEQ)\n\t\t \n\t\tstm32_fmc2_nfc_disable_seq_irq(nfc);\n\telse if (nfc->irq_state == FMC2_IRQ_BCH)\n\t\t \n\t\tstm32_fmc2_nfc_disable_bch_irq(nfc);\n\n\tcomplete(&nfc->complete);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void stm32_fmc2_nfc_read_data(struct nand_chip *chip, void *buf,\n\t\t\t\t     unsigned int len, bool force_8bit)\n{\n\tstruct stm32_fmc2_nfc *nfc = to_stm32_nfc(chip->controller);\n\tvoid __iomem *io_addr_r = nfc->data_base[nfc->cs_sel];\n\n\tif (force_8bit && chip->options & NAND_BUSWIDTH_16)\n\t\t \n\t\tstm32_fmc2_nfc_set_buswidth_16(nfc, false);\n\n\tif (!IS_ALIGNED((uintptr_t)buf, sizeof(u32))) {\n\t\tif (!IS_ALIGNED((uintptr_t)buf, sizeof(u16)) && len) {\n\t\t\t*(u8 *)buf = readb_relaxed(io_addr_r);\n\t\t\tbuf += sizeof(u8);\n\t\t\tlen -= sizeof(u8);\n\t\t}\n\n\t\tif (!IS_ALIGNED((uintptr_t)buf, sizeof(u32)) &&\n\t\t    len >= sizeof(u16)) {\n\t\t\t*(u16 *)buf = readw_relaxed(io_addr_r);\n\t\t\tbuf += sizeof(u16);\n\t\t\tlen -= sizeof(u16);\n\t\t}\n\t}\n\n\t \n\twhile (len >= sizeof(u32)) {\n\t\t*(u32 *)buf = readl_relaxed(io_addr_r);\n\t\tbuf += sizeof(u32);\n\t\tlen -= sizeof(u32);\n\t}\n\n\t \n\tif (len >= sizeof(u16)) {\n\t\t*(u16 *)buf = readw_relaxed(io_addr_r);\n\t\tbuf += sizeof(u16);\n\t\tlen -= sizeof(u16);\n\t}\n\n\tif (len)\n\t\t*(u8 *)buf = readb_relaxed(io_addr_r);\n\n\tif (force_8bit && chip->options & NAND_BUSWIDTH_16)\n\t\t \n\t\tstm32_fmc2_nfc_set_buswidth_16(nfc, true);\n}\n\nstatic void stm32_fmc2_nfc_write_data(struct nand_chip *chip, const void *buf,\n\t\t\t\t      unsigned int len, bool force_8bit)\n{\n\tstruct stm32_fmc2_nfc *nfc = to_stm32_nfc(chip->controller);\n\tvoid __iomem *io_addr_w = nfc->data_base[nfc->cs_sel];\n\n\tif (force_8bit && chip->options & NAND_BUSWIDTH_16)\n\t\t \n\t\tstm32_fmc2_nfc_set_buswidth_16(nfc, false);\n\n\tif (!IS_ALIGNED((uintptr_t)buf, sizeof(u32))) {\n\t\tif (!IS_ALIGNED((uintptr_t)buf, sizeof(u16)) && len) {\n\t\t\twriteb_relaxed(*(u8 *)buf, io_addr_w);\n\t\t\tbuf += sizeof(u8);\n\t\t\tlen -= sizeof(u8);\n\t\t}\n\n\t\tif (!IS_ALIGNED((uintptr_t)buf, sizeof(u32)) &&\n\t\t    len >= sizeof(u16)) {\n\t\t\twritew_relaxed(*(u16 *)buf, io_addr_w);\n\t\t\tbuf += sizeof(u16);\n\t\t\tlen -= sizeof(u16);\n\t\t}\n\t}\n\n\t \n\twhile (len >= sizeof(u32)) {\n\t\twritel_relaxed(*(u32 *)buf, io_addr_w);\n\t\tbuf += sizeof(u32);\n\t\tlen -= sizeof(u32);\n\t}\n\n\t \n\tif (len >= sizeof(u16)) {\n\t\twritew_relaxed(*(u16 *)buf, io_addr_w);\n\t\tbuf += sizeof(u16);\n\t\tlen -= sizeof(u16);\n\t}\n\n\tif (len)\n\t\twriteb_relaxed(*(u8 *)buf, io_addr_w);\n\n\tif (force_8bit && chip->options & NAND_BUSWIDTH_16)\n\t\t \n\t\tstm32_fmc2_nfc_set_buswidth_16(nfc, true);\n}\n\nstatic int stm32_fmc2_nfc_waitrdy(struct nand_chip *chip,\n\t\t\t\t  unsigned long timeout_ms)\n{\n\tstruct stm32_fmc2_nfc *nfc = to_stm32_nfc(chip->controller);\n\tconst struct nand_sdr_timings *timings;\n\tu32 isr, sr;\n\n\t \n\tif (regmap_read_poll_timeout(nfc->regmap, FMC2_SR, sr,\n\t\t\t\t     sr & FMC2_SR_NWRF, 1,\n\t\t\t\t     1000 * FMC2_TIMEOUT_MS))\n\t\tdev_warn(nfc->dev, \"Waitrdy timeout\\n\");\n\n\t \n\ttimings = nand_get_sdr_timings(nand_get_interface_config(chip));\n\tndelay(PSEC_TO_NSEC(timings->tWB_max));\n\n\t \n\tregmap_write(nfc->regmap, FMC2_ICR, FMC2_ICR_CIHLF);\n\n\t \n\treturn regmap_read_poll_timeout(nfc->regmap, FMC2_ISR, isr,\n\t\t\t\t\tisr & FMC2_ISR_IHLF, 5,\n\t\t\t\t\t1000 * FMC2_TIMEOUT_MS);\n}\n\nstatic int stm32_fmc2_nfc_exec_op(struct nand_chip *chip,\n\t\t\t\t  const struct nand_operation *op,\n\t\t\t\t  bool check_only)\n{\n\tstruct stm32_fmc2_nfc *nfc = to_stm32_nfc(chip->controller);\n\tconst struct nand_op_instr *instr = NULL;\n\tunsigned int op_id, i, timeout;\n\tint ret;\n\n\tif (check_only)\n\t\treturn 0;\n\n\tret = stm32_fmc2_nfc_select_chip(chip, op->cs);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (op_id = 0; op_id < op->ninstrs; op_id++) {\n\t\tinstr = &op->instrs[op_id];\n\n\t\tswitch (instr->type) {\n\t\tcase NAND_OP_CMD_INSTR:\n\t\t\twriteb_relaxed(instr->ctx.cmd.opcode,\n\t\t\t\t       nfc->cmd_base[nfc->cs_sel]);\n\t\t\tbreak;\n\n\t\tcase NAND_OP_ADDR_INSTR:\n\t\t\tfor (i = 0; i < instr->ctx.addr.naddrs; i++)\n\t\t\t\twriteb_relaxed(instr->ctx.addr.addrs[i],\n\t\t\t\t\t       nfc->addr_base[nfc->cs_sel]);\n\t\t\tbreak;\n\n\t\tcase NAND_OP_DATA_IN_INSTR:\n\t\t\tstm32_fmc2_nfc_read_data(chip, instr->ctx.data.buf.in,\n\t\t\t\t\t\t instr->ctx.data.len,\n\t\t\t\t\t\t instr->ctx.data.force_8bit);\n\t\t\tbreak;\n\n\t\tcase NAND_OP_DATA_OUT_INSTR:\n\t\t\tstm32_fmc2_nfc_write_data(chip, instr->ctx.data.buf.out,\n\t\t\t\t\t\t  instr->ctx.data.len,\n\t\t\t\t\t\t  instr->ctx.data.force_8bit);\n\t\t\tbreak;\n\n\t\tcase NAND_OP_WAITRDY_INSTR:\n\t\t\ttimeout = instr->ctx.waitrdy.timeout_ms;\n\t\t\tret = stm32_fmc2_nfc_waitrdy(chip, timeout);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic void stm32_fmc2_nfc_init(struct stm32_fmc2_nfc *nfc)\n{\n\tu32 pcr;\n\n\tregmap_read(nfc->regmap, FMC2_PCR, &pcr);\n\n\t \n\tnfc->cs_sel = -1;\n\n\t \n\tpcr |= FMC2_PCR_PWAITEN;\n\tpcr |= FMC2_PCR_PBKEN;\n\n\t \n\tpcr &= ~FMC2_PCR_PWID;\n\n\t \n\tpcr &= ~FMC2_PCR_ECCEN;\n\n\t \n\tpcr &= ~FMC2_PCR_ECCALG;\n\tpcr &= ~FMC2_PCR_BCHECC;\n\tpcr &= ~FMC2_PCR_WEN;\n\n\t \n\tpcr &= ~FMC2_PCR_ECCSS;\n\tpcr |= FIELD_PREP(FMC2_PCR_ECCSS, FMC2_PCR_ECCSS_2048);\n\n\t \n\tpcr &= ~FMC2_PCR_TCLR;\n\tpcr |= FIELD_PREP(FMC2_PCR_TCLR, FMC2_PCR_TCLR_DEFAULT);\n\tpcr &= ~FMC2_PCR_TAR;\n\tpcr |= FIELD_PREP(FMC2_PCR_TAR, FMC2_PCR_TAR_DEFAULT);\n\n\t \n\tif (nfc->dev == nfc->cdev)\n\t\tregmap_update_bits(nfc->regmap, FMC2_BCR1,\n\t\t\t\t   FMC2_BCR1_FMC2EN, FMC2_BCR1_FMC2EN);\n\n\tregmap_write(nfc->regmap, FMC2_PCR, pcr);\n\tregmap_write(nfc->regmap, FMC2_PMEM, FMC2_PMEM_DEFAULT);\n\tregmap_write(nfc->regmap, FMC2_PATT, FMC2_PATT_DEFAULT);\n}\n\nstatic void stm32_fmc2_nfc_calc_timings(struct nand_chip *chip,\n\t\t\t\t\tconst struct nand_sdr_timings *sdrt)\n{\n\tstruct stm32_fmc2_nfc *nfc = to_stm32_nfc(chip->controller);\n\tstruct stm32_fmc2_nand *nand = to_fmc2_nand(chip);\n\tstruct stm32_fmc2_timings *tims = &nand->timings;\n\tunsigned long hclk = clk_get_rate(nfc->clk);\n\tunsigned long hclkp = NSEC_PER_SEC / (hclk / 1000);\n\tunsigned long timing, tar, tclr, thiz, twait;\n\tunsigned long tset_mem, tset_att, thold_mem, thold_att;\n\n\ttar = max_t(unsigned long, hclkp, sdrt->tAR_min);\n\ttiming = DIV_ROUND_UP(tar, hclkp) - 1;\n\ttims->tar = min_t(unsigned long, timing, FMC2_PCR_TIMING_MASK);\n\n\ttclr = max_t(unsigned long, hclkp, sdrt->tCLR_min);\n\ttiming = DIV_ROUND_UP(tclr, hclkp) - 1;\n\ttims->tclr = min_t(unsigned long, timing, FMC2_PCR_TIMING_MASK);\n\n\ttims->thiz = FMC2_THIZ;\n\tthiz = (tims->thiz + 1) * hclkp;\n\n\t \n\ttwait = max_t(unsigned long, hclkp, sdrt->tRP_min);\n\ttwait = max_t(unsigned long, twait, sdrt->tWP_min);\n\ttwait = max_t(unsigned long, twait, sdrt->tREA_max + FMC2_TIO);\n\ttiming = DIV_ROUND_UP(twait, hclkp);\n\ttims->twait = clamp_val(timing, 1, FMC2_PMEM_PATT_TIMING_MASK);\n\n\t \n\ttset_mem = hclkp;\n\tif (sdrt->tCS_min > twait && (tset_mem < sdrt->tCS_min - twait))\n\t\ttset_mem = sdrt->tCS_min - twait;\n\tif (sdrt->tALS_min > twait && (tset_mem < sdrt->tALS_min - twait))\n\t\ttset_mem = sdrt->tALS_min - twait;\n\tif (twait > thiz && (sdrt->tDS_min > twait - thiz) &&\n\t    (tset_mem < sdrt->tDS_min - (twait - thiz)))\n\t\ttset_mem = sdrt->tDS_min - (twait - thiz);\n\ttiming = DIV_ROUND_UP(tset_mem, hclkp);\n\ttims->tset_mem = clamp_val(timing, 1, FMC2_PMEM_PATT_TIMING_MASK);\n\n\t \n\tthold_mem = max_t(unsigned long, hclkp, sdrt->tCH_min);\n\tif (sdrt->tREH_min > tset_mem &&\n\t    (thold_mem < sdrt->tREH_min - tset_mem))\n\t\tthold_mem = sdrt->tREH_min - tset_mem;\n\tif ((sdrt->tRC_min > tset_mem + twait) &&\n\t    (thold_mem < sdrt->tRC_min - (tset_mem + twait)))\n\t\tthold_mem = sdrt->tRC_min - (tset_mem + twait);\n\tif ((sdrt->tWC_min > tset_mem + twait) &&\n\t    (thold_mem < sdrt->tWC_min - (tset_mem + twait)))\n\t\tthold_mem = sdrt->tWC_min - (tset_mem + twait);\n\ttiming = DIV_ROUND_UP(thold_mem, hclkp);\n\ttims->thold_mem = clamp_val(timing, 1, FMC2_PMEM_PATT_TIMING_MASK);\n\n\t \n\ttset_att = hclkp;\n\tif (sdrt->tCS_min > twait && (tset_att < sdrt->tCS_min - twait))\n\t\ttset_att = sdrt->tCS_min - twait;\n\tif (sdrt->tCLS_min > twait && (tset_att < sdrt->tCLS_min - twait))\n\t\ttset_att = sdrt->tCLS_min - twait;\n\tif (sdrt->tALS_min > twait && (tset_att < sdrt->tALS_min - twait))\n\t\ttset_att = sdrt->tALS_min - twait;\n\tif (sdrt->tRHW_min > thold_mem &&\n\t    (tset_att < sdrt->tRHW_min - thold_mem))\n\t\ttset_att = sdrt->tRHW_min - thold_mem;\n\tif (twait > thiz && (sdrt->tDS_min > twait - thiz) &&\n\t    (tset_att < sdrt->tDS_min - (twait - thiz)))\n\t\ttset_att = sdrt->tDS_min - (twait - thiz);\n\ttiming = DIV_ROUND_UP(tset_att, hclkp);\n\ttims->tset_att = clamp_val(timing, 1, FMC2_PMEM_PATT_TIMING_MASK);\n\n\t \n\tthold_att = max_t(unsigned long, hclkp, sdrt->tALH_min);\n\tthold_att = max_t(unsigned long, thold_att, sdrt->tCH_min);\n\tthold_att = max_t(unsigned long, thold_att, sdrt->tCLH_min);\n\tthold_att = max_t(unsigned long, thold_att, sdrt->tCOH_min);\n\tthold_att = max_t(unsigned long, thold_att, sdrt->tDH_min);\n\tif ((sdrt->tWB_max + FMC2_TIO + FMC2_TSYNC > tset_mem) &&\n\t    (thold_att < sdrt->tWB_max + FMC2_TIO + FMC2_TSYNC - tset_mem))\n\t\tthold_att = sdrt->tWB_max + FMC2_TIO + FMC2_TSYNC - tset_mem;\n\tif (sdrt->tADL_min > tset_mem &&\n\t    (thold_att < sdrt->tADL_min - tset_mem))\n\t\tthold_att = sdrt->tADL_min - tset_mem;\n\tif (sdrt->tWH_min > tset_mem &&\n\t    (thold_att < sdrt->tWH_min - tset_mem))\n\t\tthold_att = sdrt->tWH_min - tset_mem;\n\tif (sdrt->tWHR_min > tset_mem &&\n\t    (thold_att < sdrt->tWHR_min - tset_mem))\n\t\tthold_att = sdrt->tWHR_min - tset_mem;\n\tif ((sdrt->tRC_min > tset_att + twait) &&\n\t    (thold_att < sdrt->tRC_min - (tset_att + twait)))\n\t\tthold_att = sdrt->tRC_min - (tset_att + twait);\n\tif ((sdrt->tWC_min > tset_att + twait) &&\n\t    (thold_att < sdrt->tWC_min - (tset_att + twait)))\n\t\tthold_att = sdrt->tWC_min - (tset_att + twait);\n\ttiming = DIV_ROUND_UP(thold_att, hclkp);\n\ttims->thold_att = clamp_val(timing, 1, FMC2_PMEM_PATT_TIMING_MASK);\n}\n\nstatic int stm32_fmc2_nfc_setup_interface(struct nand_chip *chip, int chipnr,\n\t\t\t\t\t  const struct nand_interface_config *conf)\n{\n\tconst struct nand_sdr_timings *sdrt;\n\n\tsdrt = nand_get_sdr_timings(conf);\n\tif (IS_ERR(sdrt))\n\t\treturn PTR_ERR(sdrt);\n\n\tif (conf->timings.mode > 3)\n\t\treturn -EOPNOTSUPP;\n\n\tif (chipnr == NAND_DATA_IFACE_CHECK_ONLY)\n\t\treturn 0;\n\n\tstm32_fmc2_nfc_calc_timings(chip, sdrt);\n\tstm32_fmc2_nfc_timings_init(chip);\n\n\treturn 0;\n}\n\nstatic int stm32_fmc2_nfc_dma_setup(struct stm32_fmc2_nfc *nfc)\n{\n\tint ret = 0;\n\n\tnfc->dma_tx_ch = dma_request_chan(nfc->dev, \"tx\");\n\tif (IS_ERR(nfc->dma_tx_ch)) {\n\t\tret = PTR_ERR(nfc->dma_tx_ch);\n\t\tif (ret != -ENODEV && ret != -EPROBE_DEFER)\n\t\t\tdev_err(nfc->dev,\n\t\t\t\t\"failed to request tx DMA channel: %d\\n\", ret);\n\t\tnfc->dma_tx_ch = NULL;\n\t\tgoto err_dma;\n\t}\n\n\tnfc->dma_rx_ch = dma_request_chan(nfc->dev, \"rx\");\n\tif (IS_ERR(nfc->dma_rx_ch)) {\n\t\tret = PTR_ERR(nfc->dma_rx_ch);\n\t\tif (ret != -ENODEV && ret != -EPROBE_DEFER)\n\t\t\tdev_err(nfc->dev,\n\t\t\t\t\"failed to request rx DMA channel: %d\\n\", ret);\n\t\tnfc->dma_rx_ch = NULL;\n\t\tgoto err_dma;\n\t}\n\n\tnfc->dma_ecc_ch = dma_request_chan(nfc->dev, \"ecc\");\n\tif (IS_ERR(nfc->dma_ecc_ch)) {\n\t\tret = PTR_ERR(nfc->dma_ecc_ch);\n\t\tif (ret != -ENODEV && ret != -EPROBE_DEFER)\n\t\t\tdev_err(nfc->dev,\n\t\t\t\t\"failed to request ecc DMA channel: %d\\n\", ret);\n\t\tnfc->dma_ecc_ch = NULL;\n\t\tgoto err_dma;\n\t}\n\n\tret = sg_alloc_table(&nfc->dma_ecc_sg, FMC2_MAX_SG, GFP_KERNEL);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tnfc->ecc_buf = devm_kzalloc(nfc->dev, FMC2_MAX_ECC_BUF_LEN, GFP_KERNEL);\n\tif (!nfc->ecc_buf)\n\t\treturn -ENOMEM;\n\n\tret = sg_alloc_table(&nfc->dma_data_sg, FMC2_MAX_SG, GFP_KERNEL);\n\tif (ret)\n\t\treturn ret;\n\n\tinit_completion(&nfc->dma_data_complete);\n\tinit_completion(&nfc->dma_ecc_complete);\n\n\treturn 0;\n\nerr_dma:\n\tif (ret == -ENODEV) {\n\t\tdev_warn(nfc->dev,\n\t\t\t \"DMAs not defined in the DT, polling mode is used\\n\");\n\t\tret = 0;\n\t}\n\n\treturn ret;\n}\n\nstatic void stm32_fmc2_nfc_nand_callbacks_setup(struct nand_chip *chip)\n{\n\tstruct stm32_fmc2_nfc *nfc = to_stm32_nfc(chip->controller);\n\n\t \n\tif (nfc->dma_tx_ch && nfc->dma_rx_ch && nfc->dma_ecc_ch) {\n\t\t \n\t\tchip->ecc.correct = stm32_fmc2_nfc_seq_correct;\n\t\tchip->ecc.write_page = stm32_fmc2_nfc_seq_write_page;\n\t\tchip->ecc.read_page = stm32_fmc2_nfc_seq_read_page;\n\t\tchip->ecc.write_page_raw = stm32_fmc2_nfc_seq_write_page_raw;\n\t\tchip->ecc.read_page_raw = stm32_fmc2_nfc_seq_read_page_raw;\n\t} else {\n\t\t \n\t\tchip->ecc.hwctl = stm32_fmc2_nfc_hwctl;\n\t\tif (chip->ecc.strength == FMC2_ECC_HAM) {\n\t\t\t \n\t\t\tchip->ecc.calculate = stm32_fmc2_nfc_ham_calculate;\n\t\t\tchip->ecc.correct = stm32_fmc2_nfc_ham_correct;\n\t\t\tchip->ecc.options |= NAND_ECC_GENERIC_ERASED_CHECK;\n\t\t} else {\n\t\t\t \n\t\t\tchip->ecc.calculate = stm32_fmc2_nfc_bch_calculate;\n\t\t\tchip->ecc.correct = stm32_fmc2_nfc_bch_correct;\n\t\t\tchip->ecc.read_page = stm32_fmc2_nfc_read_page;\n\t\t}\n\t}\n\n\t \n\tif (chip->ecc.strength == FMC2_ECC_HAM)\n\t\tchip->ecc.bytes = chip->options & NAND_BUSWIDTH_16 ? 4 : 3;\n\telse if (chip->ecc.strength == FMC2_ECC_BCH8)\n\t\tchip->ecc.bytes = chip->options & NAND_BUSWIDTH_16 ? 14 : 13;\n\telse\n\t\tchip->ecc.bytes = chip->options & NAND_BUSWIDTH_16 ? 8 : 7;\n}\n\nstatic int stm32_fmc2_nfc_ooblayout_ecc(struct mtd_info *mtd, int section,\n\t\t\t\t\tstruct mtd_oob_region *oobregion)\n{\n\tstruct nand_chip *chip = mtd_to_nand(mtd);\n\tstruct nand_ecc_ctrl *ecc = &chip->ecc;\n\n\tif (section)\n\t\treturn -ERANGE;\n\n\toobregion->length = ecc->total;\n\toobregion->offset = FMC2_BBM_LEN;\n\n\treturn 0;\n}\n\nstatic int stm32_fmc2_nfc_ooblayout_free(struct mtd_info *mtd, int section,\n\t\t\t\t\t struct mtd_oob_region *oobregion)\n{\n\tstruct nand_chip *chip = mtd_to_nand(mtd);\n\tstruct nand_ecc_ctrl *ecc = &chip->ecc;\n\n\tif (section)\n\t\treturn -ERANGE;\n\n\toobregion->length = mtd->oobsize - ecc->total - FMC2_BBM_LEN;\n\toobregion->offset = ecc->total + FMC2_BBM_LEN;\n\n\treturn 0;\n}\n\nstatic const struct mtd_ooblayout_ops stm32_fmc2_nfc_ooblayout_ops = {\n\t.ecc = stm32_fmc2_nfc_ooblayout_ecc,\n\t.free = stm32_fmc2_nfc_ooblayout_free,\n};\n\nstatic int stm32_fmc2_nfc_calc_ecc_bytes(int step_size, int strength)\n{\n\t \n\tif (strength == FMC2_ECC_HAM)\n\t\treturn 4;\n\n\t \n\tif (strength == FMC2_ECC_BCH8)\n\t\treturn 14;\n\n\t \n\treturn 8;\n}\n\nNAND_ECC_CAPS_SINGLE(stm32_fmc2_nfc_ecc_caps, stm32_fmc2_nfc_calc_ecc_bytes,\n\t\t     FMC2_ECC_STEP_SIZE,\n\t\t     FMC2_ECC_HAM, FMC2_ECC_BCH4, FMC2_ECC_BCH8);\n\nstatic int stm32_fmc2_nfc_attach_chip(struct nand_chip *chip)\n{\n\tstruct stm32_fmc2_nfc *nfc = to_stm32_nfc(chip->controller);\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tint ret;\n\n\t \n\tif (chip->ecc.engine_type != NAND_ECC_ENGINE_TYPE_ON_HOST) {\n\t\tdev_err(nfc->dev,\n\t\t\t\"nand_ecc_engine_type is not well defined in the DT\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (!chip->ecc.size)\n\t\tchip->ecc.size = FMC2_ECC_STEP_SIZE;\n\n\tif (!chip->ecc.strength)\n\t\tchip->ecc.strength = FMC2_ECC_BCH8;\n\n\tret = nand_ecc_choose_conf(chip, &stm32_fmc2_nfc_ecc_caps,\n\t\t\t\t   mtd->oobsize - FMC2_BBM_LEN);\n\tif (ret) {\n\t\tdev_err(nfc->dev, \"no valid ECC settings set\\n\");\n\t\treturn ret;\n\t}\n\n\tif (mtd->writesize / chip->ecc.size > FMC2_MAX_SG) {\n\t\tdev_err(nfc->dev, \"nand page size is not supported\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (chip->bbt_options & NAND_BBT_USE_FLASH)\n\t\tchip->bbt_options |= NAND_BBT_NO_OOB;\n\n\tstm32_fmc2_nfc_nand_callbacks_setup(chip);\n\n\tmtd_set_ooblayout(mtd, &stm32_fmc2_nfc_ooblayout_ops);\n\n\tstm32_fmc2_nfc_setup(chip);\n\n\treturn 0;\n}\n\nstatic const struct nand_controller_ops stm32_fmc2_nfc_controller_ops = {\n\t.attach_chip = stm32_fmc2_nfc_attach_chip,\n\t.exec_op = stm32_fmc2_nfc_exec_op,\n\t.setup_interface = stm32_fmc2_nfc_setup_interface,\n};\n\nstatic void stm32_fmc2_nfc_wp_enable(struct stm32_fmc2_nand *nand)\n{\n\tif (nand->wp_gpio)\n\t\tgpiod_set_value(nand->wp_gpio, 1);\n}\n\nstatic void stm32_fmc2_nfc_wp_disable(struct stm32_fmc2_nand *nand)\n{\n\tif (nand->wp_gpio)\n\t\tgpiod_set_value(nand->wp_gpio, 0);\n}\n\nstatic int stm32_fmc2_nfc_parse_child(struct stm32_fmc2_nfc *nfc,\n\t\t\t\t      struct device_node *dn)\n{\n\tstruct stm32_fmc2_nand *nand = &nfc->nand;\n\tu32 cs;\n\tint ret, i;\n\n\tif (!of_get_property(dn, \"reg\", &nand->ncs))\n\t\treturn -EINVAL;\n\n\tnand->ncs /= sizeof(u32);\n\tif (!nand->ncs) {\n\t\tdev_err(nfc->dev, \"invalid reg property size\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < nand->ncs; i++) {\n\t\tret = of_property_read_u32_index(dn, \"reg\", i, &cs);\n\t\tif (ret) {\n\t\t\tdev_err(nfc->dev, \"could not retrieve reg property: %d\\n\",\n\t\t\t\tret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (cs >= FMC2_MAX_CE) {\n\t\t\tdev_err(nfc->dev, \"invalid reg value: %d\\n\", cs);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (nfc->cs_assigned & BIT(cs)) {\n\t\t\tdev_err(nfc->dev, \"cs already assigned: %d\\n\", cs);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tnfc->cs_assigned |= BIT(cs);\n\t\tnand->cs_used[i] = cs;\n\t}\n\n\tnand->wp_gpio = devm_fwnode_gpiod_get(nfc->dev, of_fwnode_handle(dn),\n\t\t\t\t\t      \"wp\", GPIOD_OUT_HIGH, \"wp\");\n\tif (IS_ERR(nand->wp_gpio)) {\n\t\tret = PTR_ERR(nand->wp_gpio);\n\t\tif (ret != -ENOENT)\n\t\t\treturn dev_err_probe(nfc->dev, ret,\n\t\t\t\t\t     \"failed to request WP GPIO\\n\");\n\n\t\tnand->wp_gpio = NULL;\n\t}\n\n\tnand_set_flash_node(&nand->chip, dn);\n\n\treturn 0;\n}\n\nstatic int stm32_fmc2_nfc_parse_dt(struct stm32_fmc2_nfc *nfc)\n{\n\tstruct device_node *dn = nfc->dev->of_node;\n\tstruct device_node *child;\n\tint nchips = of_get_child_count(dn);\n\tint ret = 0;\n\n\tif (!nchips) {\n\t\tdev_err(nfc->dev, \"NAND chip not defined\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (nchips > 1) {\n\t\tdev_err(nfc->dev, \"too many NAND chips defined\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tfor_each_child_of_node(dn, child) {\n\t\tret = stm32_fmc2_nfc_parse_child(nfc, child);\n\t\tif (ret < 0) {\n\t\t\tof_node_put(child);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic int stm32_fmc2_nfc_set_cdev(struct stm32_fmc2_nfc *nfc)\n{\n\tstruct device *dev = nfc->dev;\n\tbool ebi_found = false;\n\n\tif (dev->parent && of_device_is_compatible(dev->parent->of_node,\n\t\t\t\t\t\t   \"st,stm32mp1-fmc2-ebi\"))\n\t\tebi_found = true;\n\n\tif (of_device_is_compatible(dev->of_node, \"st,stm32mp1-fmc2-nfc\")) {\n\t\tif (ebi_found) {\n\t\t\tnfc->cdev = dev->parent;\n\n\t\t\treturn 0;\n\t\t}\n\n\t\treturn -EINVAL;\n\t}\n\n\tif (ebi_found)\n\t\treturn -EINVAL;\n\n\tnfc->cdev = dev;\n\n\treturn 0;\n}\n\nstatic int stm32_fmc2_nfc_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct reset_control *rstc;\n\tstruct stm32_fmc2_nfc *nfc;\n\tstruct stm32_fmc2_nand *nand;\n\tstruct resource *res;\n\tstruct mtd_info *mtd;\n\tstruct nand_chip *chip;\n\tstruct resource cres;\n\tint chip_cs, mem_region, ret, irq;\n\tint start_region = 0;\n\n\tnfc = devm_kzalloc(dev, sizeof(*nfc), GFP_KERNEL);\n\tif (!nfc)\n\t\treturn -ENOMEM;\n\n\tnfc->dev = dev;\n\tnand_controller_init(&nfc->base);\n\tnfc->base.ops = &stm32_fmc2_nfc_controller_ops;\n\n\tret = stm32_fmc2_nfc_set_cdev(nfc);\n\tif (ret)\n\t\treturn ret;\n\n\tret = stm32_fmc2_nfc_parse_dt(nfc);\n\tif (ret)\n\t\treturn ret;\n\n\tret = of_address_to_resource(nfc->cdev->of_node, 0, &cres);\n\tif (ret)\n\t\treturn ret;\n\n\tnfc->io_phys_addr = cres.start;\n\n\tnfc->regmap = device_node_to_regmap(nfc->cdev->of_node);\n\tif (IS_ERR(nfc->regmap))\n\t\treturn PTR_ERR(nfc->regmap);\n\n\tif (nfc->dev == nfc->cdev)\n\t\tstart_region = 1;\n\n\tfor (chip_cs = 0, mem_region = start_region; chip_cs < FMC2_MAX_CE;\n\t     chip_cs++, mem_region += 3) {\n\t\tif (!(nfc->cs_assigned & BIT(chip_cs)))\n\t\t\tcontinue;\n\n\t\tnfc->data_base[chip_cs] = devm_platform_get_and_ioremap_resource(pdev,\n\t\t\t\t\t\tmem_region, &res);\n\t\tif (IS_ERR(nfc->data_base[chip_cs]))\n\t\t\treturn PTR_ERR(nfc->data_base[chip_cs]);\n\n\t\tnfc->data_phys_addr[chip_cs] = res->start;\n\n\t\tnfc->cmd_base[chip_cs] = devm_platform_ioremap_resource(pdev, mem_region + 1);\n\t\tif (IS_ERR(nfc->cmd_base[chip_cs]))\n\t\t\treturn PTR_ERR(nfc->cmd_base[chip_cs]);\n\n\t\tnfc->addr_base[chip_cs] = devm_platform_ioremap_resource(pdev, mem_region + 2);\n\t\tif (IS_ERR(nfc->addr_base[chip_cs]))\n\t\t\treturn PTR_ERR(nfc->addr_base[chip_cs]);\n\t}\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tret = devm_request_irq(dev, irq, stm32_fmc2_nfc_irq, 0,\n\t\t\t       dev_name(dev), nfc);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to request irq\\n\");\n\t\treturn ret;\n\t}\n\n\tinit_completion(&nfc->complete);\n\n\tnfc->clk = devm_clk_get_enabled(nfc->cdev, NULL);\n\tif (IS_ERR(nfc->clk)) {\n\t\tdev_err(dev, \"can not get and enable the clock\\n\");\n\t\treturn PTR_ERR(nfc->clk);\n\t}\n\n\trstc = devm_reset_control_get(dev, NULL);\n\tif (IS_ERR(rstc)) {\n\t\tret = PTR_ERR(rstc);\n\t\tif (ret == -EPROBE_DEFER)\n\t\t\treturn ret;\n\t} else {\n\t\treset_control_assert(rstc);\n\t\treset_control_deassert(rstc);\n\t}\n\n\tret = stm32_fmc2_nfc_dma_setup(nfc);\n\tif (ret)\n\t\tgoto err_release_dma;\n\n\tstm32_fmc2_nfc_init(nfc);\n\n\tnand = &nfc->nand;\n\tchip = &nand->chip;\n\tmtd = nand_to_mtd(chip);\n\tmtd->dev.parent = dev;\n\n\tchip->controller = &nfc->base;\n\tchip->options |= NAND_BUSWIDTH_AUTO | NAND_NO_SUBPAGE_WRITE |\n\t\t\t NAND_USES_DMA;\n\n\tstm32_fmc2_nfc_wp_disable(nand);\n\n\t \n\tret = nand_scan(chip, nand->ncs);\n\tif (ret)\n\t\tgoto err_wp_enable;\n\n\tret = mtd_device_register(mtd, NULL, 0);\n\tif (ret)\n\t\tgoto err_nand_cleanup;\n\n\tplatform_set_drvdata(pdev, nfc);\n\n\treturn 0;\n\nerr_nand_cleanup:\n\tnand_cleanup(chip);\n\nerr_wp_enable:\n\tstm32_fmc2_nfc_wp_enable(nand);\n\nerr_release_dma:\n\tif (nfc->dma_ecc_ch)\n\t\tdma_release_channel(nfc->dma_ecc_ch);\n\tif (nfc->dma_tx_ch)\n\t\tdma_release_channel(nfc->dma_tx_ch);\n\tif (nfc->dma_rx_ch)\n\t\tdma_release_channel(nfc->dma_rx_ch);\n\n\tsg_free_table(&nfc->dma_data_sg);\n\tsg_free_table(&nfc->dma_ecc_sg);\n\n\treturn ret;\n}\n\nstatic void stm32_fmc2_nfc_remove(struct platform_device *pdev)\n{\n\tstruct stm32_fmc2_nfc *nfc = platform_get_drvdata(pdev);\n\tstruct stm32_fmc2_nand *nand = &nfc->nand;\n\tstruct nand_chip *chip = &nand->chip;\n\tint ret;\n\n\tret = mtd_device_unregister(nand_to_mtd(chip));\n\tWARN_ON(ret);\n\tnand_cleanup(chip);\n\n\tif (nfc->dma_ecc_ch)\n\t\tdma_release_channel(nfc->dma_ecc_ch);\n\tif (nfc->dma_tx_ch)\n\t\tdma_release_channel(nfc->dma_tx_ch);\n\tif (nfc->dma_rx_ch)\n\t\tdma_release_channel(nfc->dma_rx_ch);\n\n\tsg_free_table(&nfc->dma_data_sg);\n\tsg_free_table(&nfc->dma_ecc_sg);\n\n\tstm32_fmc2_nfc_wp_enable(nand);\n}\n\nstatic int __maybe_unused stm32_fmc2_nfc_suspend(struct device *dev)\n{\n\tstruct stm32_fmc2_nfc *nfc = dev_get_drvdata(dev);\n\tstruct stm32_fmc2_nand *nand = &nfc->nand;\n\n\tclk_disable_unprepare(nfc->clk);\n\n\tstm32_fmc2_nfc_wp_enable(nand);\n\n\tpinctrl_pm_select_sleep_state(dev);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused stm32_fmc2_nfc_resume(struct device *dev)\n{\n\tstruct stm32_fmc2_nfc *nfc = dev_get_drvdata(dev);\n\tstruct stm32_fmc2_nand *nand = &nfc->nand;\n\tint chip_cs, ret;\n\n\tpinctrl_pm_select_default_state(dev);\n\n\tret = clk_prepare_enable(nfc->clk);\n\tif (ret) {\n\t\tdev_err(dev, \"can not enable the clock\\n\");\n\t\treturn ret;\n\t}\n\n\tstm32_fmc2_nfc_init(nfc);\n\n\tstm32_fmc2_nfc_wp_disable(nand);\n\n\tfor (chip_cs = 0; chip_cs < FMC2_MAX_CE; chip_cs++) {\n\t\tif (!(nfc->cs_assigned & BIT(chip_cs)))\n\t\t\tcontinue;\n\n\t\tnand_reset(&nand->chip, chip_cs);\n\t}\n\n\treturn 0;\n}\n\nstatic SIMPLE_DEV_PM_OPS(stm32_fmc2_nfc_pm_ops, stm32_fmc2_nfc_suspend,\n\t\t\t stm32_fmc2_nfc_resume);\n\nstatic const struct of_device_id stm32_fmc2_nfc_match[] = {\n\t{.compatible = \"st,stm32mp15-fmc2\"},\n\t{.compatible = \"st,stm32mp1-fmc2-nfc\"},\n\t{}\n};\nMODULE_DEVICE_TABLE(of, stm32_fmc2_nfc_match);\n\nstatic struct platform_driver stm32_fmc2_nfc_driver = {\n\t.probe\t= stm32_fmc2_nfc_probe,\n\t.remove_new = stm32_fmc2_nfc_remove,\n\t.driver\t= {\n\t\t.name = \"stm32_fmc2_nfc\",\n\t\t.of_match_table = stm32_fmc2_nfc_match,\n\t\t.pm = &stm32_fmc2_nfc_pm_ops,\n\t},\n};\nmodule_platform_driver(stm32_fmc2_nfc_driver);\n\nMODULE_ALIAS(\"platform:stm32_fmc2_nfc\");\nMODULE_AUTHOR(\"Christophe Kerello <christophe.kerello@st.com>\");\nMODULE_DESCRIPTION(\"STMicroelectronics STM32 FMC2 NFC driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}