{
  "module_name": "gpmi-nand.c",
  "hash_id": "44b901eac7f8a9939467396a4def366593ccdc922c3b625c288771747164dfdf",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/nand/raw/gpmi-nand/gpmi-nand.c",
  "human_readable_source": "\n \n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sched/task_stack.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/mtd/partitions.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/dma/mxs-dma.h>\n#include \"gpmi-nand.h\"\n#include \"gpmi-regs.h\"\n#include \"bch-regs.h\"\n\n \n#define GPMI_NAND_GPMI_REGS_ADDR_RES_NAME  \"gpmi-nand\"\n#define GPMI_NAND_BCH_REGS_ADDR_RES_NAME   \"bch\"\n#define GPMI_NAND_BCH_INTERRUPT_RES_NAME   \"bch\"\n\n \n#define TO_CYCLES(duration, period) DIV_ROUND_UP_ULL(duration, period)\n\n#define MXS_SET_ADDR\t\t0x4\n#define MXS_CLR_ADDR\t\t0x8\n \nstatic int clear_poll_bit(void __iomem *addr, u32 mask)\n{\n\tint timeout = 0x400;\n\n\t \n\twritel(mask, addr + MXS_CLR_ADDR);\n\n\t \n\tudelay(1);\n\n\t \n\twhile ((readl(addr) & mask) && --timeout)\n\t\t ;\n\n\treturn !timeout;\n}\n\n#define MODULE_CLKGATE\t\t(1 << 30)\n#define MODULE_SFTRST\t\t(1 << 31)\n \nstatic int gpmi_reset_block(void __iomem *reset_addr, bool just_enable)\n{\n\tint ret;\n\tint timeout = 0x400;\n\n\t \n\tret = clear_poll_bit(reset_addr, MODULE_SFTRST);\n\tif (unlikely(ret))\n\t\tgoto error;\n\n\t \n\twritel(MODULE_CLKGATE, reset_addr + MXS_CLR_ADDR);\n\n\tif (!just_enable) {\n\t\t \n\t\twritel(MODULE_SFTRST, reset_addr + MXS_SET_ADDR);\n\t\tudelay(1);\n\n\t\t \n\t\twhile ((!(readl(reset_addr) & MODULE_CLKGATE)) && --timeout)\n\t\t\t ;\n\t\tif (unlikely(!timeout))\n\t\t\tgoto error;\n\t}\n\n\t \n\tret = clear_poll_bit(reset_addr, MODULE_SFTRST);\n\tif (unlikely(ret))\n\t\tgoto error;\n\n\t \n\tret = clear_poll_bit(reset_addr, MODULE_CLKGATE);\n\tif (unlikely(ret))\n\t\tgoto error;\n\n\treturn 0;\n\nerror:\n\tpr_err(\"%s(%p): module reset timeout\\n\", __func__, reset_addr);\n\treturn -ETIMEDOUT;\n}\n\nstatic int __gpmi_enable_clk(struct gpmi_nand_data *this, bool v)\n{\n\tstruct clk *clk;\n\tint ret;\n\tint i;\n\n\tfor (i = 0; i < GPMI_CLK_MAX; i++) {\n\t\tclk = this->resources.clock[i];\n\t\tif (!clk)\n\t\t\tbreak;\n\n\t\tif (v) {\n\t\t\tret = clk_prepare_enable(clk);\n\t\t\tif (ret)\n\t\t\t\tgoto err_clk;\n\t\t} else {\n\t\t\tclk_disable_unprepare(clk);\n\t\t}\n\t}\n\treturn 0;\n\nerr_clk:\n\tfor (; i > 0; i--)\n\t\tclk_disable_unprepare(this->resources.clock[i - 1]);\n\treturn ret;\n}\n\nstatic int gpmi_init(struct gpmi_nand_data *this)\n{\n\tstruct resources *r = &this->resources;\n\tint ret;\n\n\tret = pm_runtime_resume_and_get(this->dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = gpmi_reset_block(r->gpmi_regs, false);\n\tif (ret)\n\t\tgoto err_out;\n\n\t \n\tret = gpmi_reset_block(r->bch_regs, GPMI_IS_MXS(this));\n\tif (ret)\n\t\tgoto err_out;\n\n\t \n\twritel(BM_GPMI_CTRL1_GPMI_MODE, r->gpmi_regs + HW_GPMI_CTRL1_CLR);\n\n\t \n\twritel(BM_GPMI_CTRL1_ATA_IRQRDY_POLARITY,\n\t\t\t\tr->gpmi_regs + HW_GPMI_CTRL1_SET);\n\n\t \n\twritel(BM_GPMI_CTRL1_DEV_RESET, r->gpmi_regs + HW_GPMI_CTRL1_SET);\n\n\t \n\twritel(BM_GPMI_CTRL1_BCH_MODE, r->gpmi_regs + HW_GPMI_CTRL1_SET);\n\n\t \n\twritel(BM_GPMI_CTRL1_DECOUPLE_CS | BM_GPMI_CTRL1_GANGED_RDYBUSY,\n\t       r->gpmi_regs + HW_GPMI_CTRL1_SET);\n\nerr_out:\n\tpm_runtime_mark_last_busy(this->dev);\n\tpm_runtime_put_autosuspend(this->dev);\n\treturn ret;\n}\n\n \nstatic void gpmi_dump_info(struct gpmi_nand_data *this)\n{\n\tstruct resources *r = &this->resources;\n\tstruct bch_geometry *geo = &this->bch_geometry;\n\tu32 reg;\n\tint i;\n\n\tdev_err(this->dev, \"Show GPMI registers :\\n\");\n\tfor (i = 0; i <= HW_GPMI_DEBUG / 0x10 + 1; i++) {\n\t\treg = readl(r->gpmi_regs + i * 0x10);\n\t\tdev_err(this->dev, \"offset 0x%.3x : 0x%.8x\\n\", i * 0x10, reg);\n\t}\n\n\t \n\tdev_err(this->dev, \"Show BCH registers :\\n\");\n\tfor (i = 0; i <= HW_BCH_VERSION / 0x10 + 1; i++) {\n\t\treg = readl(r->bch_regs + i * 0x10);\n\t\tdev_err(this->dev, \"offset 0x%.3x : 0x%.8x\\n\", i * 0x10, reg);\n\t}\n\tdev_err(this->dev, \"BCH Geometry :\\n\"\n\t\t\"GF length              : %u\\n\"\n\t\t\"ECC Strength           : %u\\n\"\n\t\t\"Page Size in Bytes     : %u\\n\"\n\t\t\"Metadata Size in Bytes : %u\\n\"\n\t\t\"ECC0 Chunk Size in Bytes: %u\\n\"\n\t\t\"ECCn Chunk Size in Bytes: %u\\n\"\n\t\t\"ECC Chunk Count        : %u\\n\"\n\t\t\"Payload Size in Bytes  : %u\\n\"\n\t\t\"Auxiliary Size in Bytes: %u\\n\"\n\t\t\"Auxiliary Status Offset: %u\\n\"\n\t\t\"Block Mark Byte Offset : %u\\n\"\n\t\t\"Block Mark Bit Offset  : %u\\n\",\n\t\tgeo->gf_len,\n\t\tgeo->ecc_strength,\n\t\tgeo->page_size,\n\t\tgeo->metadata_size,\n\t\tgeo->ecc0_chunk_size,\n\t\tgeo->eccn_chunk_size,\n\t\tgeo->ecc_chunk_count,\n\t\tgeo->payload_size,\n\t\tgeo->auxiliary_size,\n\t\tgeo->auxiliary_status_offset,\n\t\tgeo->block_mark_byte_offset,\n\t\tgeo->block_mark_bit_offset);\n}\n\nstatic bool gpmi_check_ecc(struct gpmi_nand_data *this)\n{\n\tstruct nand_chip *chip = &this->nand;\n\tstruct bch_geometry *geo = &this->bch_geometry;\n\tstruct nand_device *nand = &chip->base;\n\tstruct nand_ecc_props *conf = &nand->ecc.ctx.conf;\n\n\tconf->step_size = geo->eccn_chunk_size;\n\tconf->strength = geo->ecc_strength;\n\n\t \n\tif (GPMI_IS_MXS(this)) {\n\t\t \n\t\tif (geo->gf_len == 14)\n\t\t\treturn false;\n\t}\n\n\tif (geo->ecc_strength > this->devdata->bch_max_ecc_strength)\n\t\treturn false;\n\n\tif (!nand_ecc_is_strong_enough(nand))\n\t\treturn false;\n\n\treturn true;\n}\n\n \nstatic bool bbm_in_data_chunk(struct gpmi_nand_data *this,\n\t\t\tunsigned int *chunk_num)\n{\n\tstruct bch_geometry *geo = &this->bch_geometry;\n\tstruct nand_chip *chip = &this->nand;\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tunsigned int i, j;\n\n\tif (geo->ecc0_chunk_size != geo->eccn_chunk_size) {\n\t\tdev_err(this->dev,\n\t\t\t\"The size of ecc0_chunk must equal to eccn_chunk\\n\");\n\t\treturn false;\n\t}\n\n\ti = (mtd->writesize * 8 - geo->metadata_size * 8) /\n\t\t(geo->gf_len * geo->ecc_strength +\n\t\t\tgeo->eccn_chunk_size * 8);\n\n\tj = (mtd->writesize * 8 - geo->metadata_size * 8) -\n\t\t(geo->gf_len * geo->ecc_strength +\n\t\t\tgeo->eccn_chunk_size * 8) * i;\n\n\tif (j < geo->eccn_chunk_size * 8) {\n\t\t*chunk_num = i+1;\n\t\tdev_dbg(this->dev, \"Set ecc to %d and bbm in chunk %d\\n\",\n\t\t\t\tgeo->ecc_strength, *chunk_num);\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n \nstatic int set_geometry_by_ecc_info(struct gpmi_nand_data *this,\n\t\t\t\t    unsigned int ecc_strength,\n\t\t\t\t    unsigned int ecc_step)\n{\n\tstruct bch_geometry *geo = &this->bch_geometry;\n\tstruct nand_chip *chip = &this->nand;\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tunsigned int block_mark_bit_offset;\n\n\tswitch (ecc_step) {\n\tcase SZ_512:\n\t\tgeo->gf_len = 13;\n\t\tbreak;\n\tcase SZ_1K:\n\t\tgeo->gf_len = 14;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(this->dev,\n\t\t\t\"unsupported nand chip. ecc bits : %d, ecc size : %d\\n\",\n\t\t\tnanddev_get_ecc_requirements(&chip->base)->strength,\n\t\t\tnanddev_get_ecc_requirements(&chip->base)->step_size);\n\t\treturn -EINVAL;\n\t}\n\tgeo->ecc0_chunk_size = ecc_step;\n\tgeo->eccn_chunk_size = ecc_step;\n\tgeo->ecc_strength = round_up(ecc_strength, 2);\n\tif (!gpmi_check_ecc(this))\n\t\treturn -EINVAL;\n\n\t \n\tif (geo->eccn_chunk_size < mtd->oobsize) {\n\t\tdev_err(this->dev,\n\t\t\t\"unsupported nand chip. ecc size: %d, oob size : %d\\n\",\n\t\t\tecc_step, mtd->oobsize);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tgeo->metadata_size = 10;\n\n\tgeo->ecc_chunk_count = mtd->writesize / geo->eccn_chunk_size;\n\n\t \n\tgeo->page_size = mtd->writesize + geo->metadata_size +\n\t\t(geo->gf_len * geo->ecc_strength * geo->ecc_chunk_count) / 8;\n\n\tgeo->payload_size = mtd->writesize;\n\n\tgeo->auxiliary_status_offset = ALIGN(geo->metadata_size, 4);\n\tgeo->auxiliary_size = ALIGN(geo->metadata_size, 4)\n\t\t\t\t+ ALIGN(geo->ecc_chunk_count, 4);\n\n\tif (!this->swap_block_mark)\n\t\treturn 0;\n\n\t \n\tblock_mark_bit_offset = mtd->writesize * 8 -\n\t\t(geo->ecc_strength * geo->gf_len * (geo->ecc_chunk_count - 1)\n\t\t\t\t+ geo->metadata_size * 8);\n\n\tgeo->block_mark_byte_offset = block_mark_bit_offset / 8;\n\tgeo->block_mark_bit_offset  = block_mark_bit_offset % 8;\n\treturn 0;\n}\n\n \nstatic inline int get_ecc_strength(struct gpmi_nand_data *this)\n{\n\tstruct bch_geometry *geo = &this->bch_geometry;\n\tstruct mtd_info\t*mtd = nand_to_mtd(&this->nand);\n\tint ecc_strength;\n\n\tecc_strength = ((mtd->oobsize - geo->metadata_size) * 8)\n\t\t\t/ (geo->gf_len * geo->ecc_chunk_count);\n\n\t \n\treturn round_down(ecc_strength, 2);\n}\n\nstatic int set_geometry_for_large_oob(struct gpmi_nand_data *this)\n{\n\tstruct bch_geometry *geo = &this->bch_geometry;\n\tstruct nand_chip *chip = &this->nand;\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tconst struct nand_ecc_props *requirements =\n\t\tnanddev_get_ecc_requirements(&chip->base);\n\tunsigned int block_mark_bit_offset;\n\tunsigned int max_ecc;\n\tunsigned int bbm_chunk;\n\tunsigned int i;\n\n\t \n\tif (!(requirements->strength > 0 &&\n\t      requirements->step_size > 0))\n\t\treturn -EINVAL;\n\tgeo->ecc_strength = requirements->strength;\n\n\t \n\tif (!gpmi_check_ecc(this)) {\n\t\tdev_err(this->dev,\n\t\t\t\"unsupported NAND chip, minimum ecc required %d\\n\",\n\t\t\tgeo->ecc_strength);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tgeo->metadata_size = 10;\n\tgeo->gf_len = 14;\n\tgeo->ecc0_chunk_size = 1024;\n\tgeo->eccn_chunk_size = 1024;\n\tgeo->ecc_chunk_count = mtd->writesize / geo->eccn_chunk_size;\n\tmax_ecc = min(get_ecc_strength(this),\n\t\t      this->devdata->bch_max_ecc_strength);\n\n\t \n\tgeo->ecc_strength = max_ecc;\n\twhile (!(geo->ecc_strength < requirements->strength)) {\n\t\tif (bbm_in_data_chunk(this, &bbm_chunk))\n\t\t\tgoto geo_setting;\n\t\tgeo->ecc_strength -= 2;\n\t}\n\n\t \n\t \n\tgeo->ecc_strength = requirements->strength;\n\t \n\tgeo->ecc0_chunk_size = 0;\n\tgeo->ecc_chunk_count = (mtd->writesize / geo->eccn_chunk_size) + 1;\n\tgeo->ecc_for_meta = 1;\n\t \n\tif (mtd->oobsize * 8 < geo->metadata_size * 8 +\n\t    geo->gf_len * geo->ecc_strength * geo->ecc_chunk_count) {\n\t\tdev_err(this->dev, \"unsupported NAND chip with new layout\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tbbm_chunk = (mtd->writesize * 8 - geo->metadata_size * 8 -\n\t\t     geo->gf_len * geo->ecc_strength) /\n\t\t     (geo->gf_len * geo->ecc_strength +\n\t\t     geo->eccn_chunk_size * 8) + 1;\n\ngeo_setting:\n\n\tgeo->page_size = mtd->writesize + geo->metadata_size +\n\t\t(geo->gf_len * geo->ecc_strength * geo->ecc_chunk_count) / 8;\n\tgeo->payload_size = mtd->writesize;\n\n\t \n\tgeo->auxiliary_status_offset = ALIGN(geo->metadata_size, 4);\n\tgeo->auxiliary_size = ALIGN(geo->metadata_size, 4)\n\t\t\t\t    + ALIGN(geo->ecc_chunk_count, 4);\n\n\tif (!this->swap_block_mark)\n\t\treturn 0;\n\n\t \n\ti = (mtd->writesize / geo->eccn_chunk_size) - bbm_chunk + 1;\n\n\tblock_mark_bit_offset = mtd->writesize * 8 -\n\t\t(geo->ecc_strength * geo->gf_len * (geo->ecc_chunk_count - i)\n\t\t+ geo->metadata_size * 8);\n\n\tgeo->block_mark_byte_offset = block_mark_bit_offset / 8;\n\tgeo->block_mark_bit_offset  = block_mark_bit_offset % 8;\n\n\tdev_dbg(this->dev, \"BCH Geometry :\\n\"\n\t\t\"GF length              : %u\\n\"\n\t\t\"ECC Strength           : %u\\n\"\n\t\t\"Page Size in Bytes     : %u\\n\"\n\t\t\"Metadata Size in Bytes : %u\\n\"\n\t\t\"ECC0 Chunk Size in Bytes: %u\\n\"\n\t\t\"ECCn Chunk Size in Bytes: %u\\n\"\n\t\t\"ECC Chunk Count        : %u\\n\"\n\t\t\"Payload Size in Bytes  : %u\\n\"\n\t\t\"Auxiliary Size in Bytes: %u\\n\"\n\t\t\"Auxiliary Status Offset: %u\\n\"\n\t\t\"Block Mark Byte Offset : %u\\n\"\n\t\t\"Block Mark Bit Offset  : %u\\n\"\n\t\t\"Block Mark in chunk\t: %u\\n\"\n\t\t\"Ecc for Meta data\t: %u\\n\",\n\t\tgeo->gf_len,\n\t\tgeo->ecc_strength,\n\t\tgeo->page_size,\n\t\tgeo->metadata_size,\n\t\tgeo->ecc0_chunk_size,\n\t\tgeo->eccn_chunk_size,\n\t\tgeo->ecc_chunk_count,\n\t\tgeo->payload_size,\n\t\tgeo->auxiliary_size,\n\t\tgeo->auxiliary_status_offset,\n\t\tgeo->block_mark_byte_offset,\n\t\tgeo->block_mark_bit_offset,\n\t\tbbm_chunk,\n\t\tgeo->ecc_for_meta);\n\n\treturn 0;\n}\n\nstatic int legacy_set_geometry(struct gpmi_nand_data *this)\n{\n\tstruct bch_geometry *geo = &this->bch_geometry;\n\tstruct mtd_info *mtd = nand_to_mtd(&this->nand);\n\tunsigned int metadata_size;\n\tunsigned int status_size;\n\tunsigned int block_mark_bit_offset;\n\n\t \n\tgeo->metadata_size = 10;\n\n\t \n\tgeo->gf_len = 13;\n\n\t \n\tgeo->ecc0_chunk_size = 512;\n\tgeo->eccn_chunk_size = 512;\n\twhile (geo->eccn_chunk_size < mtd->oobsize) {\n\t\tgeo->ecc0_chunk_size *= 2;  \n\t\tgeo->eccn_chunk_size *= 2;  \n\t\tgeo->gf_len = 14;\n\t}\n\n\tgeo->ecc_chunk_count = mtd->writesize / geo->eccn_chunk_size;\n\n\t \n\tgeo->ecc_strength = get_ecc_strength(this);\n\tif (!gpmi_check_ecc(this)) {\n\t\tdev_err(this->dev,\n\t\t\t\"ecc strength: %d cannot be supported by the controller (%d)\\n\"\n\t\t\t\"try to use minimum ecc strength that NAND chip required\\n\",\n\t\t\tgeo->ecc_strength,\n\t\t\tthis->devdata->bch_max_ecc_strength);\n\t\treturn -EINVAL;\n\t}\n\n\tgeo->page_size = mtd->writesize + geo->metadata_size +\n\t\t(geo->gf_len * geo->ecc_strength * geo->ecc_chunk_count) / 8;\n\tgeo->payload_size = mtd->writesize;\n\n\t \n\tmetadata_size = ALIGN(geo->metadata_size, 4);\n\tstatus_size   = ALIGN(geo->ecc_chunk_count, 4);\n\n\tgeo->auxiliary_size = metadata_size + status_size;\n\tgeo->auxiliary_status_offset = metadata_size;\n\n\tif (!this->swap_block_mark)\n\t\treturn 0;\n\n\t \n\tblock_mark_bit_offset = mtd->writesize * 8 -\n\t\t(geo->ecc_strength * geo->gf_len * (geo->ecc_chunk_count - 1)\n\t\t\t\t+ geo->metadata_size * 8);\n\n\tgeo->block_mark_byte_offset = block_mark_bit_offset / 8;\n\tgeo->block_mark_bit_offset  = block_mark_bit_offset % 8;\n\treturn 0;\n}\n\nstatic int common_nfc_set_geometry(struct gpmi_nand_data *this)\n{\n\tstruct nand_chip *chip = &this->nand;\n\tstruct mtd_info *mtd = nand_to_mtd(&this->nand);\n\tconst struct nand_ecc_props *requirements =\n\t\tnanddev_get_ecc_requirements(&chip->base);\n\tbool use_minimun_ecc;\n\tint err;\n\n\tuse_minimun_ecc = of_property_read_bool(this->dev->of_node,\n\t\t\t\t\t\t\"fsl,use-minimum-ecc\");\n\n\t \n\tif ((!use_minimun_ecc && mtd->oobsize < 1024) ||\n\t    !(requirements->strength > 0 && requirements->step_size > 0)) {\n\t\tdev_dbg(this->dev, \"use legacy bch geometry\\n\");\n\t\terr = legacy_set_geometry(this);\n\t\tif (!err)\n\t\t\treturn 0;\n\t}\n\n\t \n\tif (mtd->oobsize > 1024) {\n\t\tdev_dbg(this->dev, \"use large oob bch geometry\\n\");\n\t\terr = set_geometry_for_large_oob(this);\n\t\tif (!err)\n\t\t\treturn 0;\n\t}\n\n\t \n\tdev_dbg(this->dev, \"use minimum ecc bch geometry\\n\");\n\terr = set_geometry_by_ecc_info(this, requirements->strength,\n\t\t\t\t\trequirements->step_size);\n\tif (err)\n\t\tdev_err(this->dev, \"none of the bch geometry setting works\\n\");\n\n\treturn err;\n}\n\n \nstatic int bch_set_geometry(struct gpmi_nand_data *this)\n{\n\tstruct resources *r = &this->resources;\n\tint ret;\n\n\tret = common_nfc_set_geometry(this);\n\tif (ret)\n\t\treturn ret;\n\n\tret = pm_runtime_get_sync(this->dev);\n\tif (ret < 0) {\n\t\tpm_runtime_put_autosuspend(this->dev);\n\t\treturn ret;\n\t}\n\n\t \n\tret = gpmi_reset_block(r->bch_regs, GPMI_IS_MXS(this));\n\tif (ret)\n\t\tgoto err_out;\n\n\t \n\twritel(0, r->bch_regs + HW_BCH_LAYOUTSELECT);\n\n\tret = 0;\nerr_out:\n\tpm_runtime_mark_last_busy(this->dev);\n\tpm_runtime_put_autosuspend(this->dev);\n\n\treturn ret;\n}\n\n \nstatic int gpmi_nfc_compute_timings(struct gpmi_nand_data *this,\n\t\t\t\t    const struct nand_sdr_timings *sdr)\n{\n\tstruct gpmi_nfc_hardware_timing *hw = &this->hw;\n\tstruct resources *r = &this->resources;\n\tunsigned int dll_threshold_ps = this->devdata->max_chain_delay;\n\tunsigned int period_ps, reference_period_ps;\n\tunsigned int data_setup_cycles, data_hold_cycles, addr_setup_cycles;\n\tunsigned int tRP_ps;\n\tbool use_half_period;\n\tint sample_delay_ps, sample_delay_factor;\n\tunsigned int busy_timeout_cycles;\n\tu8 wrn_dly_sel;\n\tunsigned long clk_rate, min_rate;\n\tu64 busy_timeout_ps;\n\n\tif (sdr->tRC_min >= 30000) {\n\t\t \n\t\thw->clk_rate = 22000000;\n\t\tmin_rate = 0;\n\t\twrn_dly_sel = BV_GPMI_CTRL1_WRN_DLY_SEL_4_TO_8NS;\n\t} else if (sdr->tRC_min >= 25000) {\n\t\t \n\t\thw->clk_rate = 80000000;\n\t\tmin_rate = 22000000;\n\t\twrn_dly_sel = BV_GPMI_CTRL1_WRN_DLY_SEL_NO_DELAY;\n\t} else {\n\t\t \n\t\thw->clk_rate = 100000000;\n\t\tmin_rate = 80000000;\n\t\twrn_dly_sel = BV_GPMI_CTRL1_WRN_DLY_SEL_NO_DELAY;\n\t}\n\n\tclk_rate = clk_round_rate(r->clock[0], hw->clk_rate);\n\tif (clk_rate <= min_rate) {\n\t\tdev_err(this->dev, \"clock setting: expected %ld, got %ld\\n\",\n\t\t\thw->clk_rate, clk_rate);\n\t\treturn -ENOTSUPP;\n\t}\n\n\thw->clk_rate = clk_rate;\n\t \n\tperiod_ps = div_u64((u64)NSEC_PER_SEC * 1000, hw->clk_rate);\n\n\taddr_setup_cycles = TO_CYCLES(sdr->tALS_min, period_ps);\n\tdata_setup_cycles = TO_CYCLES(sdr->tDS_min, period_ps);\n\tdata_hold_cycles = TO_CYCLES(sdr->tDH_min, period_ps);\n\tbusy_timeout_ps = max(sdr->tBERS_max, sdr->tPROG_max);\n\tbusy_timeout_cycles = TO_CYCLES(busy_timeout_ps, period_ps);\n\n\thw->timing0 = BF_GPMI_TIMING0_ADDRESS_SETUP(addr_setup_cycles) |\n\t\t      BF_GPMI_TIMING0_DATA_HOLD(data_hold_cycles) |\n\t\t      BF_GPMI_TIMING0_DATA_SETUP(data_setup_cycles);\n\thw->timing1 = BF_GPMI_TIMING1_BUSY_TIMEOUT(DIV_ROUND_UP(busy_timeout_cycles, 4096));\n\n\t \n\tif (period_ps > dll_threshold_ps) {\n\t\tuse_half_period = true;\n\t\treference_period_ps = period_ps / 2;\n\t} else {\n\t\tuse_half_period = false;\n\t\treference_period_ps = period_ps;\n\t}\n\n\ttRP_ps = data_setup_cycles * period_ps;\n\tsample_delay_ps = (sdr->tREA_max + 4000 - tRP_ps) * 8;\n\tif (sample_delay_ps > 0)\n\t\tsample_delay_factor = sample_delay_ps / reference_period_ps;\n\telse\n\t\tsample_delay_factor = 0;\n\n\thw->ctrl1n = BF_GPMI_CTRL1_WRN_DLY_SEL(wrn_dly_sel);\n\tif (sample_delay_factor)\n\t\thw->ctrl1n |= BF_GPMI_CTRL1_RDN_DELAY(sample_delay_factor) |\n\t\t\t      BM_GPMI_CTRL1_DLL_ENABLE |\n\t\t\t      (use_half_period ? BM_GPMI_CTRL1_HALF_PERIOD : 0);\n\treturn 0;\n}\n\nstatic int gpmi_nfc_apply_timings(struct gpmi_nand_data *this)\n{\n\tstruct gpmi_nfc_hardware_timing *hw = &this->hw;\n\tstruct resources *r = &this->resources;\n\tvoid __iomem *gpmi_regs = r->gpmi_regs;\n\tunsigned int dll_wait_time_us;\n\tint ret;\n\n\t \n\tif (GPMI_IS_MX6Q(this) || GPMI_IS_MX6SX(this))\n\t\tclk_disable_unprepare(r->clock[0]);\n\n\tret = clk_set_rate(r->clock[0], hw->clk_rate);\n\tif (ret) {\n\t\tdev_err(this->dev, \"cannot set clock rate to %lu Hz: %d\\n\", hw->clk_rate, ret);\n\t\treturn ret;\n\t}\n\n\tif (GPMI_IS_MX6Q(this) || GPMI_IS_MX6SX(this)) {\n\t\tret = clk_prepare_enable(r->clock[0]);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\twritel(hw->timing0, gpmi_regs + HW_GPMI_TIMING0);\n\twritel(hw->timing1, gpmi_regs + HW_GPMI_TIMING1);\n\n\t \n\twritel(BM_GPMI_CTRL1_CLEAR_MASK, gpmi_regs + HW_GPMI_CTRL1_CLR);\n\twritel(hw->ctrl1n, gpmi_regs + HW_GPMI_CTRL1_SET);\n\n\t \n\tdll_wait_time_us = USEC_PER_SEC / hw->clk_rate * 64;\n\tif (!dll_wait_time_us)\n\t\tdll_wait_time_us = 1;\n\n\t \n\tudelay(dll_wait_time_us);\n\n\treturn 0;\n}\n\nstatic int gpmi_setup_interface(struct nand_chip *chip, int chipnr,\n\t\t\t\tconst struct nand_interface_config *conf)\n{\n\tstruct gpmi_nand_data *this = nand_get_controller_data(chip);\n\tconst struct nand_sdr_timings *sdr;\n\tint ret;\n\n\t \n\tsdr = nand_get_sdr_timings(conf);\n\tif (IS_ERR(sdr))\n\t\treturn PTR_ERR(sdr);\n\n\t \n\tif (sdr->tRC_min <= 25000 && !GPMI_IS_MX28(this) && !GPMI_IS_MX6(this))\n\t\treturn -ENOTSUPP;\n\n\t \n\tif (chipnr < 0)\n\t\treturn 0;\n\n\t \n\tret = gpmi_nfc_compute_timings(this, sdr);\n\tif (ret)\n\t\treturn ret;\n\n\tthis->hw.must_apply_timings = true;\n\n\treturn 0;\n}\n\n \nstatic void gpmi_clear_bch(struct gpmi_nand_data *this)\n{\n\tstruct resources *r = &this->resources;\n\twritel(BM_BCH_CTRL_COMPLETE_IRQ, r->bch_regs + HW_BCH_CTRL_CLR);\n}\n\nstatic struct dma_chan *get_dma_chan(struct gpmi_nand_data *this)\n{\n\t \n\treturn this->dma_chans[0];\n}\n\n \nstatic void dma_irq_callback(void *param)\n{\n\tstruct gpmi_nand_data *this = param;\n\tstruct completion *dma_c = &this->dma_done;\n\n\tcomplete(dma_c);\n}\n\nstatic irqreturn_t bch_irq(int irq, void *cookie)\n{\n\tstruct gpmi_nand_data *this = cookie;\n\n\tgpmi_clear_bch(this);\n\tcomplete(&this->bch_done);\n\treturn IRQ_HANDLED;\n}\n\nstatic int gpmi_raw_len_to_len(struct gpmi_nand_data *this, int raw_len)\n{\n\t \n\tif (this->bch)\n\t\treturn ALIGN_DOWN(raw_len, this->bch_geometry.eccn_chunk_size);\n\telse\n\t\treturn raw_len;\n}\n\n \nstatic bool prepare_data_dma(struct gpmi_nand_data *this, const void *buf,\n\t\t\t     int raw_len, struct scatterlist *sgl,\n\t\t\t     enum dma_data_direction dr)\n{\n\tint ret;\n\tint len = gpmi_raw_len_to_len(this, raw_len);\n\n\t \n\tif (virt_addr_valid(buf) && !object_is_on_stack(buf)) {\n\t\tsg_init_one(sgl, buf, len);\n\t\tret = dma_map_sg(this->dev, sgl, 1, dr);\n\t\tif (ret == 0)\n\t\t\tgoto map_fail;\n\n\t\treturn true;\n\t}\n\nmap_fail:\n\t \n\tsg_init_one(sgl, this->data_buffer_dma, len);\n\n\tif (dr == DMA_TO_DEVICE && buf != this->data_buffer_dma)\n\t\tmemcpy(this->data_buffer_dma, buf, len);\n\n\tdma_map_sg(this->dev, sgl, 1, dr);\n\n\treturn false;\n}\n\n \nstatic uint8_t scan_ff_pattern[] = { 0xff };\nstatic struct nand_bbt_descr gpmi_bbt_descr = {\n\t.options\t= 0,\n\t.offs\t\t= 0,\n\t.len\t\t= 1,\n\t.pattern\t= scan_ff_pattern\n};\n\n \nstatic int gpmi_ooblayout_ecc(struct mtd_info *mtd, int section,\n\t\t\t      struct mtd_oob_region *oobregion)\n{\n\tstruct nand_chip *chip = mtd_to_nand(mtd);\n\tstruct gpmi_nand_data *this = nand_get_controller_data(chip);\n\tstruct bch_geometry *geo = &this->bch_geometry;\n\n\tif (section)\n\t\treturn -ERANGE;\n\n\toobregion->offset = 0;\n\toobregion->length = geo->page_size - mtd->writesize;\n\n\treturn 0;\n}\n\nstatic int gpmi_ooblayout_free(struct mtd_info *mtd, int section,\n\t\t\t       struct mtd_oob_region *oobregion)\n{\n\tstruct nand_chip *chip = mtd_to_nand(mtd);\n\tstruct gpmi_nand_data *this = nand_get_controller_data(chip);\n\tstruct bch_geometry *geo = &this->bch_geometry;\n\n\tif (section)\n\t\treturn -ERANGE;\n\n\t \n\tif (geo->page_size < mtd->writesize + mtd->oobsize) {\n\t\toobregion->offset = geo->page_size - mtd->writesize;\n\t\toobregion->length = mtd->oobsize - oobregion->offset;\n\t}\n\n\treturn 0;\n}\n\nstatic const char * const gpmi_clks_for_mx2x[] = {\n\t\"gpmi_io\",\n};\n\nstatic const struct mtd_ooblayout_ops gpmi_ooblayout_ops = {\n\t.ecc = gpmi_ooblayout_ecc,\n\t.free = gpmi_ooblayout_free,\n};\n\nstatic const struct gpmi_devdata gpmi_devdata_imx23 = {\n\t.type = IS_MX23,\n\t.bch_max_ecc_strength = 20,\n\t.max_chain_delay = 16000,\n\t.clks = gpmi_clks_for_mx2x,\n\t.clks_count = ARRAY_SIZE(gpmi_clks_for_mx2x),\n};\n\nstatic const struct gpmi_devdata gpmi_devdata_imx28 = {\n\t.type = IS_MX28,\n\t.bch_max_ecc_strength = 20,\n\t.max_chain_delay = 16000,\n\t.clks = gpmi_clks_for_mx2x,\n\t.clks_count = ARRAY_SIZE(gpmi_clks_for_mx2x),\n};\n\nstatic const char * const gpmi_clks_for_mx6[] = {\n\t\"gpmi_io\", \"gpmi_apb\", \"gpmi_bch\", \"gpmi_bch_apb\", \"per1_bch\",\n};\n\nstatic const struct gpmi_devdata gpmi_devdata_imx6q = {\n\t.type = IS_MX6Q,\n\t.bch_max_ecc_strength = 40,\n\t.max_chain_delay = 12000,\n\t.clks = gpmi_clks_for_mx6,\n\t.clks_count = ARRAY_SIZE(gpmi_clks_for_mx6),\n};\n\nstatic const struct gpmi_devdata gpmi_devdata_imx6sx = {\n\t.type = IS_MX6SX,\n\t.bch_max_ecc_strength = 62,\n\t.max_chain_delay = 12000,\n\t.clks = gpmi_clks_for_mx6,\n\t.clks_count = ARRAY_SIZE(gpmi_clks_for_mx6),\n};\n\nstatic const char * const gpmi_clks_for_mx7d[] = {\n\t\"gpmi_io\", \"gpmi_bch_apb\",\n};\n\nstatic const struct gpmi_devdata gpmi_devdata_imx7d = {\n\t.type = IS_MX7D,\n\t.bch_max_ecc_strength = 62,\n\t.max_chain_delay = 12000,\n\t.clks = gpmi_clks_for_mx7d,\n\t.clks_count = ARRAY_SIZE(gpmi_clks_for_mx7d),\n};\n\nstatic int acquire_register_block(struct gpmi_nand_data *this,\n\t\t\t\t  const char *res_name)\n{\n\tstruct platform_device *pdev = this->pdev;\n\tstruct resources *res = &this->resources;\n\tvoid __iomem *p;\n\n\tp = devm_platform_ioremap_resource_byname(pdev, res_name);\n\tif (IS_ERR(p))\n\t\treturn PTR_ERR(p);\n\n\tif (!strcmp(res_name, GPMI_NAND_GPMI_REGS_ADDR_RES_NAME))\n\t\tres->gpmi_regs = p;\n\telse if (!strcmp(res_name, GPMI_NAND_BCH_REGS_ADDR_RES_NAME))\n\t\tres->bch_regs = p;\n\telse\n\t\tdev_err(this->dev, \"unknown resource name : %s\\n\", res_name);\n\n\treturn 0;\n}\n\nstatic int acquire_bch_irq(struct gpmi_nand_data *this, irq_handler_t irq_h)\n{\n\tstruct platform_device *pdev = this->pdev;\n\tconst char *res_name = GPMI_NAND_BCH_INTERRUPT_RES_NAME;\n\tint err;\n\n\terr = platform_get_irq_byname(pdev, res_name);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = devm_request_irq(this->dev, err, irq_h, 0, res_name, this);\n\tif (err)\n\t\tdev_err(this->dev, \"error requesting BCH IRQ\\n\");\n\n\treturn err;\n}\n\nstatic void release_dma_channels(struct gpmi_nand_data *this)\n{\n\tunsigned int i;\n\tfor (i = 0; i < DMA_CHANS; i++)\n\t\tif (this->dma_chans[i]) {\n\t\t\tdma_release_channel(this->dma_chans[i]);\n\t\t\tthis->dma_chans[i] = NULL;\n\t\t}\n}\n\nstatic int acquire_dma_channels(struct gpmi_nand_data *this)\n{\n\tstruct platform_device *pdev = this->pdev;\n\tstruct dma_chan *dma_chan;\n\tint ret = 0;\n\n\t \n\tdma_chan = dma_request_chan(&pdev->dev, \"rx-tx\");\n\tif (IS_ERR(dma_chan)) {\n\t\tret = dev_err_probe(this->dev, PTR_ERR(dma_chan),\n\t\t\t\t    \"DMA channel request failed\\n\");\n\t\trelease_dma_channels(this);\n\t} else {\n\t\tthis->dma_chans[0] = dma_chan;\n\t}\n\n\treturn ret;\n}\n\nstatic int gpmi_get_clks(struct gpmi_nand_data *this)\n{\n\tstruct resources *r = &this->resources;\n\tstruct clk *clk;\n\tint err, i;\n\n\tfor (i = 0; i < this->devdata->clks_count; i++) {\n\t\tclk = devm_clk_get(this->dev, this->devdata->clks[i]);\n\t\tif (IS_ERR(clk)) {\n\t\t\terr = PTR_ERR(clk);\n\t\t\tgoto err_clock;\n\t\t}\n\n\t\tr->clock[i] = clk;\n\t}\n\n\treturn 0;\n\nerr_clock:\n\tdev_dbg(this->dev, \"failed in finding the clocks.\\n\");\n\treturn err;\n}\n\nstatic int acquire_resources(struct gpmi_nand_data *this)\n{\n\tint ret;\n\n\tret = acquire_register_block(this, GPMI_NAND_GPMI_REGS_ADDR_RES_NAME);\n\tif (ret)\n\t\tgoto exit_regs;\n\n\tret = acquire_register_block(this, GPMI_NAND_BCH_REGS_ADDR_RES_NAME);\n\tif (ret)\n\t\tgoto exit_regs;\n\n\tret = acquire_bch_irq(this, bch_irq);\n\tif (ret)\n\t\tgoto exit_regs;\n\n\tret = acquire_dma_channels(this);\n\tif (ret)\n\t\tgoto exit_regs;\n\n\tret = gpmi_get_clks(this);\n\tif (ret)\n\t\tgoto exit_clock;\n\treturn 0;\n\nexit_clock:\n\trelease_dma_channels(this);\nexit_regs:\n\treturn ret;\n}\n\nstatic void release_resources(struct gpmi_nand_data *this)\n{\n\trelease_dma_channels(this);\n}\n\nstatic void gpmi_free_dma_buffer(struct gpmi_nand_data *this)\n{\n\tstruct device *dev = this->dev;\n\tstruct bch_geometry *geo = &this->bch_geometry;\n\n\tif (this->auxiliary_virt && virt_addr_valid(this->auxiliary_virt))\n\t\tdma_free_coherent(dev, geo->auxiliary_size,\n\t\t\t\t\tthis->auxiliary_virt,\n\t\t\t\t\tthis->auxiliary_phys);\n\tkfree(this->data_buffer_dma);\n\tkfree(this->raw_buffer);\n\n\tthis->data_buffer_dma\t= NULL;\n\tthis->raw_buffer\t= NULL;\n}\n\n \nstatic int gpmi_alloc_dma_buffer(struct gpmi_nand_data *this)\n{\n\tstruct bch_geometry *geo = &this->bch_geometry;\n\tstruct device *dev = this->dev;\n\tstruct mtd_info *mtd = nand_to_mtd(&this->nand);\n\n\t \n\tthis->data_buffer_dma = kzalloc(mtd->writesize ?: PAGE_SIZE,\n\t\t\t\t\tGFP_DMA | GFP_KERNEL);\n\tif (this->data_buffer_dma == NULL)\n\t\tgoto error_alloc;\n\n\tthis->auxiliary_virt = dma_alloc_coherent(dev, geo->auxiliary_size,\n\t\t\t\t\t&this->auxiliary_phys, GFP_DMA);\n\tif (!this->auxiliary_virt)\n\t\tgoto error_alloc;\n\n\tthis->raw_buffer = kzalloc((mtd->writesize ?: PAGE_SIZE) + mtd->oobsize, GFP_KERNEL);\n\tif (!this->raw_buffer)\n\t\tgoto error_alloc;\n\n\treturn 0;\n\nerror_alloc:\n\tgpmi_free_dma_buffer(this);\n\treturn -ENOMEM;\n}\n\n \nstatic void block_mark_swapping(struct gpmi_nand_data *this,\n\t\t\t\tvoid *payload, void *auxiliary)\n{\n\tstruct bch_geometry *nfc_geo = &this->bch_geometry;\n\tunsigned char *p;\n\tunsigned char *a;\n\tunsigned int  bit;\n\tunsigned char mask;\n\tunsigned char from_data;\n\tunsigned char from_oob;\n\n\tif (!this->swap_block_mark)\n\t\treturn;\n\n\t \n\tbit = nfc_geo->block_mark_bit_offset;\n\tp   = payload + nfc_geo->block_mark_byte_offset;\n\ta   = auxiliary;\n\n\t \n\tfrom_data = (p[0] >> bit) | (p[1] << (8 - bit));\n\n\t \n\tfrom_oob = a[0];\n\n\t \n\ta[0] = from_data;\n\n\tmask = (0x1 << bit) - 1;\n\tp[0] = (p[0] & mask) | (from_oob << bit);\n\n\tmask = ~0 << bit;\n\tp[1] = (p[1] & mask) | (from_oob >> (8 - bit));\n}\n\nstatic int gpmi_count_bitflips(struct nand_chip *chip, void *buf, int first,\n\t\t\t       int last, int meta)\n{\n\tstruct gpmi_nand_data *this = nand_get_controller_data(chip);\n\tstruct bch_geometry *nfc_geo = &this->bch_geometry;\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tint i;\n\tunsigned char *status;\n\tunsigned int max_bitflips = 0;\n\n\t \n\tstatus = this->auxiliary_virt + ALIGN(meta, 4);\n\n\tfor (i = first; i < last; i++, status++) {\n\t\tif ((*status == STATUS_GOOD) || (*status == STATUS_ERASED))\n\t\t\tcontinue;\n\n\t\tif (*status == STATUS_UNCORRECTABLE) {\n\t\t\tint eccbits = nfc_geo->ecc_strength * nfc_geo->gf_len;\n\t\t\tu8 *eccbuf = this->raw_buffer;\n\t\t\tint offset, bitoffset;\n\t\t\tint eccbytes;\n\t\t\tint flips;\n\n\t\t\t \n\t\t\toffset = nfc_geo->metadata_size * 8;\n\t\t\toffset += ((8 * nfc_geo->eccn_chunk_size) + eccbits) * (i + 1);\n\t\t\toffset -= eccbits;\n\t\t\tbitoffset = offset % 8;\n\t\t\teccbytes = DIV_ROUND_UP(offset + eccbits, 8);\n\t\t\toffset /= 8;\n\t\t\teccbytes -= offset;\n\t\t\tnand_change_read_column_op(chip, offset, eccbuf,\n\t\t\t\t\t\t   eccbytes, false);\n\n\t\t\t \n\t\t\tif (bitoffset)\n\t\t\t\teccbuf[0] |= GENMASK(bitoffset - 1, 0);\n\n\t\t\tbitoffset = (bitoffset + eccbits) % 8;\n\t\t\tif (bitoffset)\n\t\t\t\teccbuf[eccbytes - 1] |= GENMASK(7, bitoffset);\n\n\t\t\t \n\t\t\tif (i == 0) {\n\t\t\t\t \n\t\t\t\tflips = nand_check_erased_ecc_chunk(\n\t\t\t\t\t\tbuf + i * nfc_geo->eccn_chunk_size,\n\t\t\t\t\t\tnfc_geo->eccn_chunk_size,\n\t\t\t\t\t\teccbuf, eccbytes,\n\t\t\t\t\t\tthis->auxiliary_virt,\n\t\t\t\t\t\tnfc_geo->metadata_size,\n\t\t\t\t\t\tnfc_geo->ecc_strength);\n\t\t\t} else {\n\t\t\t\tflips = nand_check_erased_ecc_chunk(\n\t\t\t\t\t\tbuf + i * nfc_geo->eccn_chunk_size,\n\t\t\t\t\t\tnfc_geo->eccn_chunk_size,\n\t\t\t\t\t\teccbuf, eccbytes,\n\t\t\t\t\t\tNULL, 0,\n\t\t\t\t\t\tnfc_geo->ecc_strength);\n\t\t\t}\n\n\t\t\tif (flips > 0) {\n\t\t\t\tmax_bitflips = max_t(unsigned int, max_bitflips,\n\t\t\t\t\t\t     flips);\n\t\t\t\tmtd->ecc_stats.corrected += flips;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tmtd->ecc_stats.failed++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tmtd->ecc_stats.corrected += *status;\n\t\tmax_bitflips = max_t(unsigned int, max_bitflips, *status);\n\t}\n\n\treturn max_bitflips;\n}\n\nstatic void gpmi_bch_layout_std(struct gpmi_nand_data *this)\n{\n\tstruct bch_geometry *geo = &this->bch_geometry;\n\tunsigned int ecc_strength = geo->ecc_strength >> 1;\n\tunsigned int gf_len = geo->gf_len;\n\tunsigned int block0_size = geo->ecc0_chunk_size;\n\tunsigned int blockn_size = geo->eccn_chunk_size;\n\n\tthis->bch_flashlayout0 =\n\t\tBF_BCH_FLASH0LAYOUT0_NBLOCKS(geo->ecc_chunk_count - 1) |\n\t\tBF_BCH_FLASH0LAYOUT0_META_SIZE(geo->metadata_size) |\n\t\tBF_BCH_FLASH0LAYOUT0_ECC0(ecc_strength, this) |\n\t\tBF_BCH_FLASH0LAYOUT0_GF(gf_len, this) |\n\t\tBF_BCH_FLASH0LAYOUT0_DATA0_SIZE(block0_size, this);\n\n\tthis->bch_flashlayout1 =\n\t\tBF_BCH_FLASH0LAYOUT1_PAGE_SIZE(geo->page_size) |\n\t\tBF_BCH_FLASH0LAYOUT1_ECCN(ecc_strength, this) |\n\t\tBF_BCH_FLASH0LAYOUT1_GF(gf_len, this) |\n\t\tBF_BCH_FLASH0LAYOUT1_DATAN_SIZE(blockn_size, this);\n}\n\nstatic int gpmi_ecc_read_page(struct nand_chip *chip, uint8_t *buf,\n\t\t\t      int oob_required, int page)\n{\n\tstruct gpmi_nand_data *this = nand_get_controller_data(chip);\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tstruct bch_geometry *geo = &this->bch_geometry;\n\tunsigned int max_bitflips;\n\tint ret;\n\n\tgpmi_bch_layout_std(this);\n\tthis->bch = true;\n\n\tret = nand_read_page_op(chip, page, 0, buf, geo->page_size);\n\tif (ret)\n\t\treturn ret;\n\n\tmax_bitflips = gpmi_count_bitflips(chip, buf, 0,\n\t\t\t\t\t   geo->ecc_chunk_count,\n\t\t\t\t\t   geo->auxiliary_status_offset);\n\n\t \n\tblock_mark_swapping(this, buf, this->auxiliary_virt);\n\n\tif (oob_required) {\n\t\t \n\t\tmemset(chip->oob_poi, ~0, mtd->oobsize);\n\t\tchip->oob_poi[0] = ((uint8_t *)this->auxiliary_virt)[0];\n\t}\n\n\treturn max_bitflips;\n}\n\n \nstatic int gpmi_ecc_read_subpage(struct nand_chip *chip, uint32_t offs,\n\t\t\t\t uint32_t len, uint8_t *buf, int page)\n{\n\tstruct gpmi_nand_data *this = nand_get_controller_data(chip);\n\tstruct bch_geometry *geo = &this->bch_geometry;\n\tint size = chip->ecc.size;  \n\tint meta, n, page_size;\n\tunsigned int max_bitflips;\n\tunsigned int ecc_strength;\n\tint first, last, marker_pos;\n\tint ecc_parity_size;\n\tint col = 0;\n\tint ret;\n\n\t \n\tecc_parity_size = geo->gf_len * geo->ecc_strength / 8;\n\n\t \n\tfirst = offs / size;\n\tlast = (offs + len - 1) / size;\n\n\tif (this->swap_block_mark) {\n\t\t \n\t\tmarker_pos = geo->block_mark_byte_offset / size;\n\t\tif (last >= marker_pos && first <= marker_pos) {\n\t\t\tdev_dbg(this->dev,\n\t\t\t\t\"page:%d, first:%d, last:%d, marker at:%d\\n\",\n\t\t\t\tpage, first, last, marker_pos);\n\t\t\treturn gpmi_ecc_read_page(chip, buf, 0, page);\n\t\t}\n\t}\n\n\t \n\n\tmeta = geo->metadata_size;\n\tif (first) {\n\t\tif (geo->ecc_for_meta)\n\t\t\tcol = meta + ecc_parity_size\n\t\t\t\t+ (size + ecc_parity_size) * first;\n\t\telse\n\t\t\tcol = meta + (size + ecc_parity_size) * first;\n\n\t\tmeta = 0;\n\t\tbuf = buf + first * size;\n\t}\n\n\tecc_parity_size = geo->gf_len * geo->ecc_strength / 8;\n\tn = last - first + 1;\n\n\tif (geo->ecc_for_meta && meta)\n\t\tpage_size = meta + ecc_parity_size\n\t\t\t    + (size + ecc_parity_size) * n;\n\telse\n\t\tpage_size = meta + (size + ecc_parity_size) * n;\n\n\tecc_strength = geo->ecc_strength >> 1;\n\n\tthis->bch_flashlayout0 = BF_BCH_FLASH0LAYOUT0_NBLOCKS(\n\t\t(geo->ecc_for_meta ? n : n - 1)) |\n\t\tBF_BCH_FLASH0LAYOUT0_META_SIZE(meta) |\n\t\tBF_BCH_FLASH0LAYOUT0_ECC0(ecc_strength, this) |\n\t\tBF_BCH_FLASH0LAYOUT0_GF(geo->gf_len, this) |\n\t\tBF_BCH_FLASH0LAYOUT0_DATA0_SIZE((geo->ecc_for_meta ?\n\t\t0 : geo->ecc0_chunk_size), this);\n\n\tthis->bch_flashlayout1 = BF_BCH_FLASH0LAYOUT1_PAGE_SIZE(page_size) |\n\t\tBF_BCH_FLASH0LAYOUT1_ECCN(ecc_strength, this) |\n\t\tBF_BCH_FLASH0LAYOUT1_GF(geo->gf_len, this) |\n\t\tBF_BCH_FLASH0LAYOUT1_DATAN_SIZE(geo->eccn_chunk_size, this);\n\n\tthis->bch = true;\n\n\tret = nand_read_page_op(chip, page, col, buf, page_size);\n\tif (ret)\n\t\treturn ret;\n\n\tdev_dbg(this->dev, \"page:%d(%d:%d)%d, chunk:(%d:%d), BCH PG size:%d\\n\",\n\t\tpage, offs, len, col, first, n, page_size);\n\n\tmax_bitflips = gpmi_count_bitflips(chip, buf, first, last, meta);\n\n\treturn max_bitflips;\n}\n\nstatic int gpmi_ecc_write_page(struct nand_chip *chip, const uint8_t *buf,\n\t\t\t       int oob_required, int page)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tstruct gpmi_nand_data *this = nand_get_controller_data(chip);\n\tstruct bch_geometry *nfc_geo = &this->bch_geometry;\n\n\tdev_dbg(this->dev, \"ecc write page.\\n\");\n\n\tgpmi_bch_layout_std(this);\n\tthis->bch = true;\n\n\tmemcpy(this->auxiliary_virt, chip->oob_poi, nfc_geo->auxiliary_size);\n\n\tif (this->swap_block_mark) {\n\t\t \n\t\tmemcpy(this->data_buffer_dma, buf, mtd->writesize);\n\t\tbuf = this->data_buffer_dma;\n\t\tblock_mark_swapping(this, this->data_buffer_dma,\n\t\t\t\t    this->auxiliary_virt);\n\t}\n\n\treturn nand_prog_page_op(chip, page, 0, buf, nfc_geo->page_size);\n}\n\n \nstatic int gpmi_ecc_read_oob(struct nand_chip *chip, int page)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tstruct gpmi_nand_data *this = nand_get_controller_data(chip);\n\tint ret;\n\n\t \n\tmemset(chip->oob_poi, ~0, mtd->oobsize);\n\n\t \n\tret = nand_read_page_op(chip, page, mtd->writesize, chip->oob_poi,\n\t\t\t\tmtd->oobsize);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (GPMI_IS_MX23(this)) {\n\t\t \n\t\tret = nand_read_page_op(chip, page, 0, chip->oob_poi, 1);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int gpmi_ecc_write_oob(struct nand_chip *chip, int page)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tstruct mtd_oob_region of = { };\n\n\t \n\tmtd_ooblayout_free(mtd, 0, &of);\n\tif (!of.length)\n\t\treturn -EPERM;\n\n\tif (!nand_is_slc(chip))\n\t\treturn -EPERM;\n\n\treturn nand_prog_page_op(chip, page, mtd->writesize + of.offset,\n\t\t\t\t chip->oob_poi + of.offset, of.length);\n}\n\n \nstatic int gpmi_ecc_read_page_raw(struct nand_chip *chip, uint8_t *buf,\n\t\t\t\t  int oob_required, int page)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tstruct gpmi_nand_data *this = nand_get_controller_data(chip);\n\tstruct bch_geometry *nfc_geo = &this->bch_geometry;\n\tint eccsize = nfc_geo->eccn_chunk_size;\n\tint eccbits = nfc_geo->ecc_strength * nfc_geo->gf_len;\n\tu8 *tmp_buf = this->raw_buffer;\n\tsize_t src_bit_off;\n\tsize_t oob_bit_off;\n\tsize_t oob_byte_off;\n\tuint8_t *oob = chip->oob_poi;\n\tint step;\n\tint ret;\n\n\tret = nand_read_page_op(chip, page, 0, tmp_buf,\n\t\t\t\tmtd->writesize + mtd->oobsize);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (this->swap_block_mark)\n\t\tswap(tmp_buf[0], tmp_buf[mtd->writesize]);\n\n\t \n\tif (oob_required)\n\t\tmemcpy(oob, tmp_buf, nfc_geo->metadata_size);\n\n\toob_bit_off = nfc_geo->metadata_size * 8;\n\tsrc_bit_off = oob_bit_off;\n\n\t \n\tfor (step = 0; step < nfc_geo->ecc_chunk_count; step++) {\n\t\tif (buf)\n\t\t\tnand_extract_bits(buf, step * eccsize * 8, tmp_buf,\n\t\t\t\t\t  src_bit_off, eccsize * 8);\n\t\tsrc_bit_off += eccsize * 8;\n\n\t\t \n\t\tif (step == nfc_geo->ecc_chunk_count - 1 &&\n\t\t    (oob_bit_off + eccbits) % 8)\n\t\t\teccbits += 8 - ((oob_bit_off + eccbits) % 8);\n\n\t\tif (oob_required)\n\t\t\tnand_extract_bits(oob, oob_bit_off, tmp_buf,\n\t\t\t\t\t  src_bit_off, eccbits);\n\n\t\tsrc_bit_off += eccbits;\n\t\toob_bit_off += eccbits;\n\t}\n\n\tif (oob_required) {\n\t\toob_byte_off = oob_bit_off / 8;\n\n\t\tif (oob_byte_off < mtd->oobsize)\n\t\t\tmemcpy(oob + oob_byte_off,\n\t\t\t       tmp_buf + mtd->writesize + oob_byte_off,\n\t\t\t       mtd->oobsize - oob_byte_off);\n\t}\n\n\treturn 0;\n}\n\n \nstatic int gpmi_ecc_write_page_raw(struct nand_chip *chip, const uint8_t *buf,\n\t\t\t\t   int oob_required, int page)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tstruct gpmi_nand_data *this = nand_get_controller_data(chip);\n\tstruct bch_geometry *nfc_geo = &this->bch_geometry;\n\tint eccsize = nfc_geo->eccn_chunk_size;\n\tint eccbits = nfc_geo->ecc_strength * nfc_geo->gf_len;\n\tu8 *tmp_buf = this->raw_buffer;\n\tuint8_t *oob = chip->oob_poi;\n\tsize_t dst_bit_off;\n\tsize_t oob_bit_off;\n\tsize_t oob_byte_off;\n\tint step;\n\n\t \n\tif (!buf || !oob_required)\n\t\tmemset(tmp_buf, 0xff, mtd->writesize + mtd->oobsize);\n\n\t \n\tmemcpy(tmp_buf, oob, nfc_geo->metadata_size);\n\toob_bit_off = nfc_geo->metadata_size * 8;\n\tdst_bit_off = oob_bit_off;\n\n\t \n\tfor (step = 0; step < nfc_geo->ecc_chunk_count; step++) {\n\t\tif (buf)\n\t\t\tnand_extract_bits(tmp_buf, dst_bit_off, buf,\n\t\t\t\t\t  step * eccsize * 8, eccsize * 8);\n\t\tdst_bit_off += eccsize * 8;\n\n\t\t \n\t\tif (step == nfc_geo->ecc_chunk_count - 1 &&\n\t\t    (oob_bit_off + eccbits) % 8)\n\t\t\teccbits += 8 - ((oob_bit_off + eccbits) % 8);\n\n\t\tif (oob_required)\n\t\t\tnand_extract_bits(tmp_buf, dst_bit_off, oob,\n\t\t\t\t\t  oob_bit_off, eccbits);\n\n\t\tdst_bit_off += eccbits;\n\t\toob_bit_off += eccbits;\n\t}\n\n\toob_byte_off = oob_bit_off / 8;\n\n\tif (oob_required && oob_byte_off < mtd->oobsize)\n\t\tmemcpy(tmp_buf + mtd->writesize + oob_byte_off,\n\t\t       oob + oob_byte_off, mtd->oobsize - oob_byte_off);\n\n\t \n\tif (this->swap_block_mark)\n\t\tswap(tmp_buf[0], tmp_buf[mtd->writesize]);\n\n\treturn nand_prog_page_op(chip, page, 0, tmp_buf,\n\t\t\t\t mtd->writesize + mtd->oobsize);\n}\n\nstatic int gpmi_ecc_read_oob_raw(struct nand_chip *chip, int page)\n{\n\treturn gpmi_ecc_read_page_raw(chip, NULL, 1, page);\n}\n\nstatic int gpmi_ecc_write_oob_raw(struct nand_chip *chip, int page)\n{\n\treturn gpmi_ecc_write_page_raw(chip, NULL, 1, page);\n}\n\nstatic int gpmi_block_markbad(struct nand_chip *chip, loff_t ofs)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tstruct gpmi_nand_data *this = nand_get_controller_data(chip);\n\tint ret = 0;\n\tuint8_t *block_mark;\n\tint column, page, chipnr;\n\n\tchipnr = (int)(ofs >> chip->chip_shift);\n\tnand_select_target(chip, chipnr);\n\n\tcolumn = !GPMI_IS_MX23(this) ? mtd->writesize : 0;\n\n\t \n\tblock_mark = this->data_buffer_dma;\n\tblock_mark[0] = 0;  \n\n\t \n\tpage = (int)(ofs >> chip->page_shift);\n\n\tret = nand_prog_page_op(chip, page, column, block_mark, 1);\n\n\tnand_deselect_target(chip);\n\n\treturn ret;\n}\n\nstatic int nand_boot_set_geometry(struct gpmi_nand_data *this)\n{\n\tstruct boot_rom_geometry *geometry = &this->rom_geometry;\n\n\t \n\tgeometry->stride_size_in_pages = 64;\n\n\t \n\tgeometry->search_area_stride_exponent = 2;\n\treturn 0;\n}\n\nstatic const char  *fingerprint = \"STMP\";\nstatic int mx23_check_transcription_stamp(struct gpmi_nand_data *this)\n{\n\tstruct boot_rom_geometry *rom_geo = &this->rom_geometry;\n\tstruct device *dev = this->dev;\n\tstruct nand_chip *chip = &this->nand;\n\tunsigned int search_area_size_in_strides;\n\tunsigned int stride;\n\tunsigned int page;\n\tu8 *buffer = nand_get_data_buf(chip);\n\tint found_an_ncb_fingerprint = false;\n\tint ret;\n\n\t \n\tsearch_area_size_in_strides = 1 << rom_geo->search_area_stride_exponent;\n\n\tnand_select_target(chip, 0);\n\n\t \n\tdev_dbg(dev, \"Scanning for an NCB fingerprint...\\n\");\n\n\tfor (stride = 0; stride < search_area_size_in_strides; stride++) {\n\t\t \n\t\tpage = stride * rom_geo->stride_size_in_pages;\n\n\t\tdev_dbg(dev, \"Looking for a fingerprint in page 0x%x\\n\", page);\n\n\t\t \n\t\tret = nand_read_page_op(chip, page, 12, buffer,\n\t\t\t\t\tstrlen(fingerprint));\n\t\tif (ret)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (!memcmp(buffer, fingerprint, strlen(fingerprint))) {\n\t\t\tfound_an_ncb_fingerprint = true;\n\t\t\tbreak;\n\t\t}\n\n\t}\n\n\tnand_deselect_target(chip);\n\n\tif (found_an_ncb_fingerprint)\n\t\tdev_dbg(dev, \"\\tFound a fingerprint\\n\");\n\telse\n\t\tdev_dbg(dev, \"\\tNo fingerprint found\\n\");\n\treturn found_an_ncb_fingerprint;\n}\n\n \nstatic int mx23_write_transcription_stamp(struct gpmi_nand_data *this)\n{\n\tstruct device *dev = this->dev;\n\tstruct boot_rom_geometry *rom_geo = &this->rom_geometry;\n\tstruct nand_chip *chip = &this->nand;\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tunsigned int block_size_in_pages;\n\tunsigned int search_area_size_in_strides;\n\tunsigned int search_area_size_in_pages;\n\tunsigned int search_area_size_in_blocks;\n\tunsigned int block;\n\tunsigned int stride;\n\tunsigned int page;\n\tu8 *buffer = nand_get_data_buf(chip);\n\tint status;\n\n\t \n\tblock_size_in_pages = mtd->erasesize / mtd->writesize;\n\tsearch_area_size_in_strides = 1 << rom_geo->search_area_stride_exponent;\n\tsearch_area_size_in_pages = search_area_size_in_strides *\n\t\t\t\t\trom_geo->stride_size_in_pages;\n\tsearch_area_size_in_blocks =\n\t\t  (search_area_size_in_pages + (block_size_in_pages - 1)) /\n\t\t\t\t    block_size_in_pages;\n\n\tdev_dbg(dev, \"Search Area Geometry :\\n\");\n\tdev_dbg(dev, \"\\tin Blocks : %u\\n\", search_area_size_in_blocks);\n\tdev_dbg(dev, \"\\tin Strides: %u\\n\", search_area_size_in_strides);\n\tdev_dbg(dev, \"\\tin Pages  : %u\\n\", search_area_size_in_pages);\n\n\tnand_select_target(chip, 0);\n\n\t \n\tdev_dbg(dev, \"Erasing the search area...\\n\");\n\n\tfor (block = 0; block < search_area_size_in_blocks; block++) {\n\t\t \n\t\tdev_dbg(dev, \"\\tErasing block 0x%x\\n\", block);\n\t\tstatus = nand_erase_op(chip, block);\n\t\tif (status)\n\t\t\tdev_err(dev, \"[%s] Erase failed.\\n\", __func__);\n\t}\n\n\t \n\tmemset(buffer, ~0, mtd->writesize);\n\tmemcpy(buffer + 12, fingerprint, strlen(fingerprint));\n\n\t \n\tdev_dbg(dev, \"Writing NCB fingerprints...\\n\");\n\tfor (stride = 0; stride < search_area_size_in_strides; stride++) {\n\t\t \n\t\tpage = stride * rom_geo->stride_size_in_pages;\n\n\t\t \n\t\tdev_dbg(dev, \"Writing an NCB fingerprint in page 0x%x\\n\", page);\n\n\t\tstatus = chip->ecc.write_page_raw(chip, buffer, 0, page);\n\t\tif (status)\n\t\t\tdev_err(dev, \"[%s] Write failed.\\n\", __func__);\n\t}\n\n\tnand_deselect_target(chip);\n\n\treturn 0;\n}\n\nstatic int mx23_boot_init(struct gpmi_nand_data  *this)\n{\n\tstruct device *dev = this->dev;\n\tstruct nand_chip *chip = &this->nand;\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tunsigned int block_count;\n\tunsigned int block;\n\tint     chipnr;\n\tint     page;\n\tloff_t  byte;\n\tuint8_t block_mark;\n\tint     ret = 0;\n\n\t \n\tif (mx23_check_transcription_stamp(this))\n\t\treturn 0;\n\n\t \n\tdev_dbg(dev, \"Transcribing bad block marks...\\n\");\n\n\t \n\tblock_count = nanddev_eraseblocks_per_target(&chip->base);\n\n\t \n\tfor (block = 0; block < block_count; block++) {\n\t\t \n\t\tchipnr = block >> (chip->chip_shift - chip->phys_erase_shift);\n\t\tpage = block << (chip->phys_erase_shift - chip->page_shift);\n\t\tbyte = block <<  chip->phys_erase_shift;\n\n\t\t \n\t\tnand_select_target(chip, chipnr);\n\t\tret = nand_read_page_op(chip, page, mtd->writesize, &block_mark,\n\t\t\t\t\t1);\n\t\tnand_deselect_target(chip);\n\n\t\tif (ret)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (block_mark != 0xff) {\n\t\t\tdev_dbg(dev, \"Transcribing mark in block %u\\n\", block);\n\t\t\tret = chip->legacy.block_markbad(chip, byte);\n\t\t\tif (ret)\n\t\t\t\tdev_err(dev,\n\t\t\t\t\t\"Failed to mark block bad with ret %d\\n\",\n\t\t\t\t\tret);\n\t\t}\n\t}\n\n\t \n\tmx23_write_transcription_stamp(this);\n\treturn 0;\n}\n\nstatic int nand_boot_init(struct gpmi_nand_data  *this)\n{\n\tnand_boot_set_geometry(this);\n\n\t \n\tif (GPMI_IS_MX23(this))\n\t\treturn mx23_boot_init(this);\n\treturn 0;\n}\n\nstatic int gpmi_set_geometry(struct gpmi_nand_data *this)\n{\n\tint ret;\n\n\t \n\tgpmi_free_dma_buffer(this);\n\n\t \n\tret = bch_set_geometry(this);\n\tif (ret) {\n\t\tdev_err(this->dev, \"Error setting BCH geometry : %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\treturn gpmi_alloc_dma_buffer(this);\n}\n\nstatic int gpmi_init_last(struct gpmi_nand_data *this)\n{\n\tstruct nand_chip *chip = &this->nand;\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tstruct nand_ecc_ctrl *ecc = &chip->ecc;\n\tstruct bch_geometry *bch_geo = &this->bch_geometry;\n\tint ret;\n\n\t \n\tret = gpmi_set_geometry(this);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tecc->read_page\t= gpmi_ecc_read_page;\n\tecc->write_page\t= gpmi_ecc_write_page;\n\tecc->read_oob\t= gpmi_ecc_read_oob;\n\tecc->write_oob\t= gpmi_ecc_write_oob;\n\tecc->read_page_raw = gpmi_ecc_read_page_raw;\n\tecc->write_page_raw = gpmi_ecc_write_page_raw;\n\tecc->read_oob_raw = gpmi_ecc_read_oob_raw;\n\tecc->write_oob_raw = gpmi_ecc_write_oob_raw;\n\tecc->engine_type = NAND_ECC_ENGINE_TYPE_ON_HOST;\n\tecc->size\t= bch_geo->eccn_chunk_size;\n\tecc->strength\t= bch_geo->ecc_strength;\n\tmtd_set_ooblayout(mtd, &gpmi_ooblayout_ops);\n\n\t \n\tif (GPMI_IS_MX6(this) &&\n\t\t((bch_geo->gf_len * bch_geo->ecc_strength) % 8) == 0) {\n\t\tecc->read_subpage = gpmi_ecc_read_subpage;\n\t\tchip->options |= NAND_SUBPAGE_READ;\n\t}\n\n\treturn 0;\n}\n\nstatic int gpmi_nand_attach_chip(struct nand_chip *chip)\n{\n\tstruct gpmi_nand_data *this = nand_get_controller_data(chip);\n\tint ret;\n\n\tif (chip->bbt_options & NAND_BBT_USE_FLASH) {\n\t\tchip->bbt_options |= NAND_BBT_NO_OOB;\n\n\t\tif (of_property_read_bool(this->dev->of_node,\n\t\t\t\t\t  \"fsl,no-blockmark-swap\"))\n\t\t\tthis->swap_block_mark = false;\n\t}\n\tdev_dbg(this->dev, \"Blockmark swapping %sabled\\n\",\n\t\tthis->swap_block_mark ? \"en\" : \"dis\");\n\n\tret = gpmi_init_last(this);\n\tif (ret)\n\t\treturn ret;\n\n\tchip->options |= NAND_SKIP_BBTSCAN;\n\n\treturn 0;\n}\n\nstatic struct gpmi_transfer *get_next_transfer(struct gpmi_nand_data *this)\n{\n\tstruct gpmi_transfer *transfer = &this->transfers[this->ntransfers];\n\n\tthis->ntransfers++;\n\n\tif (this->ntransfers == GPMI_MAX_TRANSFERS)\n\t\treturn NULL;\n\n\treturn transfer;\n}\n\nstatic struct dma_async_tx_descriptor *gpmi_chain_command(\n\tstruct gpmi_nand_data *this, u8 cmd, const u8 *addr, int naddr)\n{\n\tstruct dma_chan *channel = get_dma_chan(this);\n\tstruct dma_async_tx_descriptor *desc;\n\tstruct gpmi_transfer *transfer;\n\tint chip = this->nand.cur_cs;\n\tu32 pio[3];\n\n\t \n\tpio[0] = BF_GPMI_CTRL0_COMMAND_MODE(BV_GPMI_CTRL0_COMMAND_MODE__WRITE)\n\t\t| BM_GPMI_CTRL0_WORD_LENGTH\n\t\t| BF_GPMI_CTRL0_CS(chip, this)\n\t\t| BF_GPMI_CTRL0_LOCK_CS(LOCK_CS_ENABLE, this)\n\t\t| BF_GPMI_CTRL0_ADDRESS(BV_GPMI_CTRL0_ADDRESS__NAND_CLE)\n\t\t| BM_GPMI_CTRL0_ADDRESS_INCREMENT\n\t\t| BF_GPMI_CTRL0_XFER_COUNT(naddr + 1);\n\tpio[1] = 0;\n\tpio[2] = 0;\n\tdesc = mxs_dmaengine_prep_pio(channel, pio, ARRAY_SIZE(pio),\n\t\t\t\t      DMA_TRANS_NONE, 0);\n\tif (!desc)\n\t\treturn NULL;\n\n\ttransfer = get_next_transfer(this);\n\tif (!transfer)\n\t\treturn NULL;\n\n\ttransfer->cmdbuf[0] = cmd;\n\tif (naddr)\n\t\tmemcpy(&transfer->cmdbuf[1], addr, naddr);\n\n\tsg_init_one(&transfer->sgl, transfer->cmdbuf, naddr + 1);\n\tdma_map_sg(this->dev, &transfer->sgl, 1, DMA_TO_DEVICE);\n\n\ttransfer->direction = DMA_TO_DEVICE;\n\n\tdesc = dmaengine_prep_slave_sg(channel, &transfer->sgl, 1, DMA_MEM_TO_DEV,\n\t\t\t\t       MXS_DMA_CTRL_WAIT4END);\n\treturn desc;\n}\n\nstatic struct dma_async_tx_descriptor *gpmi_chain_wait_ready(\n\tstruct gpmi_nand_data *this)\n{\n\tstruct dma_chan *channel = get_dma_chan(this);\n\tu32 pio[2];\n\n\tpio[0] =  BF_GPMI_CTRL0_COMMAND_MODE(BV_GPMI_CTRL0_COMMAND_MODE__WAIT_FOR_READY)\n\t\t| BM_GPMI_CTRL0_WORD_LENGTH\n\t\t| BF_GPMI_CTRL0_CS(this->nand.cur_cs, this)\n\t\t| BF_GPMI_CTRL0_LOCK_CS(LOCK_CS_ENABLE, this)\n\t\t| BF_GPMI_CTRL0_ADDRESS(BV_GPMI_CTRL0_ADDRESS__NAND_DATA)\n\t\t| BF_GPMI_CTRL0_XFER_COUNT(0);\n\tpio[1] = 0;\n\n\treturn mxs_dmaengine_prep_pio(channel, pio, 2, DMA_TRANS_NONE,\n\t\t\t\tMXS_DMA_CTRL_WAIT4END | MXS_DMA_CTRL_WAIT4RDY);\n}\n\nstatic struct dma_async_tx_descriptor *gpmi_chain_data_read(\n\tstruct gpmi_nand_data *this, void *buf, int raw_len, bool *direct)\n{\n\tstruct dma_async_tx_descriptor *desc;\n\tstruct dma_chan *channel = get_dma_chan(this);\n\tstruct gpmi_transfer *transfer;\n\tu32 pio[6] = {};\n\n\ttransfer = get_next_transfer(this);\n\tif (!transfer)\n\t\treturn NULL;\n\n\ttransfer->direction = DMA_FROM_DEVICE;\n\n\t*direct = prepare_data_dma(this, buf, raw_len, &transfer->sgl,\n\t\t\t\t   DMA_FROM_DEVICE);\n\n\tpio[0] =  BF_GPMI_CTRL0_COMMAND_MODE(BV_GPMI_CTRL0_COMMAND_MODE__READ)\n\t\t| BM_GPMI_CTRL0_WORD_LENGTH\n\t\t| BF_GPMI_CTRL0_CS(this->nand.cur_cs, this)\n\t\t| BF_GPMI_CTRL0_LOCK_CS(LOCK_CS_ENABLE, this)\n\t\t| BF_GPMI_CTRL0_ADDRESS(BV_GPMI_CTRL0_ADDRESS__NAND_DATA)\n\t\t| BF_GPMI_CTRL0_XFER_COUNT(raw_len);\n\n\tif (this->bch) {\n\t\tpio[2] =  BM_GPMI_ECCCTRL_ENABLE_ECC\n\t\t\t| BF_GPMI_ECCCTRL_ECC_CMD(BV_GPMI_ECCCTRL_ECC_CMD__BCH_DECODE)\n\t\t\t| BF_GPMI_ECCCTRL_BUFFER_MASK(BV_GPMI_ECCCTRL_BUFFER_MASK__BCH_PAGE\n\t\t\t\t| BV_GPMI_ECCCTRL_BUFFER_MASK__BCH_AUXONLY);\n\t\tpio[3] = raw_len;\n\t\tpio[4] = transfer->sgl.dma_address;\n\t\tpio[5] = this->auxiliary_phys;\n\t}\n\n\tdesc = mxs_dmaengine_prep_pio(channel, pio, ARRAY_SIZE(pio),\n\t\t\t\t      DMA_TRANS_NONE, 0);\n\tif (!desc)\n\t\treturn NULL;\n\n\tif (!this->bch)\n\t\tdesc = dmaengine_prep_slave_sg(channel, &transfer->sgl, 1,\n\t\t\t\t\t     DMA_DEV_TO_MEM,\n\t\t\t\t\t     MXS_DMA_CTRL_WAIT4END);\n\n\treturn desc;\n}\n\nstatic struct dma_async_tx_descriptor *gpmi_chain_data_write(\n\tstruct gpmi_nand_data *this, const void *buf, int raw_len)\n{\n\tstruct dma_chan *channel = get_dma_chan(this);\n\tstruct dma_async_tx_descriptor *desc;\n\tstruct gpmi_transfer *transfer;\n\tu32 pio[6] = {};\n\n\ttransfer = get_next_transfer(this);\n\tif (!transfer)\n\t\treturn NULL;\n\n\ttransfer->direction = DMA_TO_DEVICE;\n\n\tprepare_data_dma(this, buf, raw_len, &transfer->sgl, DMA_TO_DEVICE);\n\n\tpio[0] = BF_GPMI_CTRL0_COMMAND_MODE(BV_GPMI_CTRL0_COMMAND_MODE__WRITE)\n\t\t| BM_GPMI_CTRL0_WORD_LENGTH\n\t\t| BF_GPMI_CTRL0_CS(this->nand.cur_cs, this)\n\t\t| BF_GPMI_CTRL0_LOCK_CS(LOCK_CS_ENABLE, this)\n\t\t| BF_GPMI_CTRL0_ADDRESS(BV_GPMI_CTRL0_ADDRESS__NAND_DATA)\n\t\t| BF_GPMI_CTRL0_XFER_COUNT(raw_len);\n\n\tif (this->bch) {\n\t\tpio[2] = BM_GPMI_ECCCTRL_ENABLE_ECC\n\t\t\t| BF_GPMI_ECCCTRL_ECC_CMD(BV_GPMI_ECCCTRL_ECC_CMD__BCH_ENCODE)\n\t\t\t| BF_GPMI_ECCCTRL_BUFFER_MASK(BV_GPMI_ECCCTRL_BUFFER_MASK__BCH_PAGE |\n\t\t\t\t\tBV_GPMI_ECCCTRL_BUFFER_MASK__BCH_AUXONLY);\n\t\tpio[3] = raw_len;\n\t\tpio[4] = transfer->sgl.dma_address;\n\t\tpio[5] = this->auxiliary_phys;\n\t}\n\n\tdesc = mxs_dmaengine_prep_pio(channel, pio, ARRAY_SIZE(pio),\n\t\t\t\t      DMA_TRANS_NONE,\n\t\t\t\t      (this->bch ? MXS_DMA_CTRL_WAIT4END : 0));\n\tif (!desc)\n\t\treturn NULL;\n\n\tif (!this->bch)\n\t\tdesc = dmaengine_prep_slave_sg(channel, &transfer->sgl, 1,\n\t\t\t\t\t       DMA_MEM_TO_DEV,\n\t\t\t\t\t       MXS_DMA_CTRL_WAIT4END);\n\n\treturn desc;\n}\n\nstatic int gpmi_nfc_exec_op(struct nand_chip *chip,\n\t\t\t     const struct nand_operation *op,\n\t\t\t     bool check_only)\n{\n\tconst struct nand_op_instr *instr;\n\tstruct gpmi_nand_data *this = nand_get_controller_data(chip);\n\tstruct dma_async_tx_descriptor *desc = NULL;\n\tint i, ret, buf_len = 0, nbufs = 0;\n\tu8 cmd = 0;\n\tvoid *buf_read = NULL;\n\tconst void *buf_write = NULL;\n\tbool direct = false;\n\tstruct completion *dma_completion, *bch_completion;\n\tunsigned long to;\n\n\tif (check_only)\n\t\treturn 0;\n\n\tthis->ntransfers = 0;\n\tfor (i = 0; i < GPMI_MAX_TRANSFERS; i++)\n\t\tthis->transfers[i].direction = DMA_NONE;\n\n\tret = pm_runtime_resume_and_get(this->dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tif (this->hw.must_apply_timings) {\n\t\tthis->hw.must_apply_timings = false;\n\t\tret = gpmi_nfc_apply_timings(this);\n\t\tif (ret)\n\t\t\tgoto out_pm;\n\t}\n\n\tdev_dbg(this->dev, \"%s: %d instructions\\n\", __func__, op->ninstrs);\n\n\tfor (i = 0; i < op->ninstrs; i++) {\n\t\tinstr = &op->instrs[i];\n\n\t\tnand_op_trace(\"  \", instr);\n\n\t\tswitch (instr->type) {\n\t\tcase NAND_OP_WAITRDY_INSTR:\n\t\t\tdesc = gpmi_chain_wait_ready(this);\n\t\t\tbreak;\n\t\tcase NAND_OP_CMD_INSTR:\n\t\t\tcmd = instr->ctx.cmd.opcode;\n\n\t\t\t \n\t\t\tif (i + 1 != op->ninstrs &&\n\t\t\t    op->instrs[i + 1].type == NAND_OP_ADDR_INSTR)\n\t\t\t\tcontinue;\n\n\t\t\tdesc = gpmi_chain_command(this, cmd, NULL, 0);\n\n\t\t\tbreak;\n\t\tcase NAND_OP_ADDR_INSTR:\n\t\t\tdesc = gpmi_chain_command(this, cmd, instr->ctx.addr.addrs,\n\t\t\t\t\t\t  instr->ctx.addr.naddrs);\n\t\t\tbreak;\n\t\tcase NAND_OP_DATA_OUT_INSTR:\n\t\t\tbuf_write = instr->ctx.data.buf.out;\n\t\t\tbuf_len = instr->ctx.data.len;\n\t\t\tnbufs++;\n\n\t\t\tdesc = gpmi_chain_data_write(this, buf_write, buf_len);\n\n\t\t\tbreak;\n\t\tcase NAND_OP_DATA_IN_INSTR:\n\t\t\tif (!instr->ctx.data.len)\n\t\t\t\tbreak;\n\t\t\tbuf_read = instr->ctx.data.buf.in;\n\t\t\tbuf_len = instr->ctx.data.len;\n\t\t\tnbufs++;\n\n\t\t\tdesc = gpmi_chain_data_read(this, buf_read, buf_len,\n\t\t\t\t\t\t   &direct);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!desc) {\n\t\t\tret = -ENXIO;\n\t\t\tgoto unmap;\n\t\t}\n\t}\n\n\tdev_dbg(this->dev, \"%s setup done\\n\", __func__);\n\n\tif (nbufs > 1) {\n\t\tdev_err(this->dev, \"Multiple data instructions not supported\\n\");\n\t\tret = -EINVAL;\n\t\tgoto unmap;\n\t}\n\n\tif (this->bch) {\n\t\twritel(this->bch_flashlayout0,\n\t\t       this->resources.bch_regs + HW_BCH_FLASH0LAYOUT0);\n\t\twritel(this->bch_flashlayout1,\n\t\t       this->resources.bch_regs + HW_BCH_FLASH0LAYOUT1);\n\t}\n\n\tdesc->callback = dma_irq_callback;\n\tdesc->callback_param = this;\n\tdma_completion = &this->dma_done;\n\tbch_completion = NULL;\n\n\tinit_completion(dma_completion);\n\n\tif (this->bch && buf_read) {\n\t\twritel(BM_BCH_CTRL_COMPLETE_IRQ_EN,\n\t\t       this->resources.bch_regs + HW_BCH_CTRL_SET);\n\t\tbch_completion = &this->bch_done;\n\t\tinit_completion(bch_completion);\n\t}\n\n\tdmaengine_submit(desc);\n\tdma_async_issue_pending(get_dma_chan(this));\n\n\tto = wait_for_completion_timeout(dma_completion, msecs_to_jiffies(1000));\n\tif (!to) {\n\t\tdev_err(this->dev, \"DMA timeout, last DMA\\n\");\n\t\tgpmi_dump_info(this);\n\t\tret = -ETIMEDOUT;\n\t\tgoto unmap;\n\t}\n\n\tif (this->bch && buf_read) {\n\t\tto = wait_for_completion_timeout(bch_completion, msecs_to_jiffies(1000));\n\t\tif (!to) {\n\t\t\tdev_err(this->dev, \"BCH timeout, last DMA\\n\");\n\t\t\tgpmi_dump_info(this);\n\t\t\tret = -ETIMEDOUT;\n\t\t\tgoto unmap;\n\t\t}\n\t}\n\n\twritel(BM_BCH_CTRL_COMPLETE_IRQ_EN,\n\t       this->resources.bch_regs + HW_BCH_CTRL_CLR);\n\tgpmi_clear_bch(this);\n\n\tret = 0;\n\nunmap:\n\tfor (i = 0; i < this->ntransfers; i++) {\n\t\tstruct gpmi_transfer *transfer = &this->transfers[i];\n\n\t\tif (transfer->direction != DMA_NONE)\n\t\t\tdma_unmap_sg(this->dev, &transfer->sgl, 1,\n\t\t\t\t     transfer->direction);\n\t}\n\n\tif (!ret && buf_read && !direct)\n\t\tmemcpy(buf_read, this->data_buffer_dma,\n\t\t       gpmi_raw_len_to_len(this, buf_len));\n\n\tthis->bch = false;\n\nout_pm:\n\tpm_runtime_mark_last_busy(this->dev);\n\tpm_runtime_put_autosuspend(this->dev);\n\n\treturn ret;\n}\n\nstatic const struct nand_controller_ops gpmi_nand_controller_ops = {\n\t.attach_chip = gpmi_nand_attach_chip,\n\t.setup_interface = gpmi_setup_interface,\n\t.exec_op = gpmi_nfc_exec_op,\n};\n\nstatic int gpmi_nand_init(struct gpmi_nand_data *this)\n{\n\tstruct nand_chip *chip = &this->nand;\n\tstruct mtd_info  *mtd = nand_to_mtd(chip);\n\tint ret;\n\n\t \n\tmtd->name\t\t= \"gpmi-nand\";\n\tmtd->dev.parent\t\t= this->dev;\n\n\t \n\tnand_set_controller_data(chip, this);\n\tnand_set_flash_node(chip, this->pdev->dev.of_node);\n\tchip->legacy.block_markbad = gpmi_block_markbad;\n\tchip->badblock_pattern\t= &gpmi_bbt_descr;\n\tchip->options\t\t|= NAND_NO_SUBPAGE_WRITE;\n\n\t \n\tthis->swap_block_mark = !GPMI_IS_MX23(this);\n\n\t \n\tthis->bch_geometry.payload_size = 1024;\n\tthis->bch_geometry.auxiliary_size = 128;\n\tret = gpmi_alloc_dma_buffer(this);\n\tif (ret)\n\t\treturn ret;\n\n\tnand_controller_init(&this->base);\n\tthis->base.ops = &gpmi_nand_controller_ops;\n\tchip->controller = &this->base;\n\n\tret = nand_scan(chip, GPMI_IS_MX6(this) ? 2 : 1);\n\tif (ret)\n\t\tgoto err_out;\n\n\tret = nand_boot_init(this);\n\tif (ret)\n\t\tgoto err_nand_cleanup;\n\tret = nand_create_bbt(chip);\n\tif (ret)\n\t\tgoto err_nand_cleanup;\n\n\tret = mtd_device_register(mtd, NULL, 0);\n\tif (ret)\n\t\tgoto err_nand_cleanup;\n\treturn 0;\n\nerr_nand_cleanup:\n\tnand_cleanup(chip);\nerr_out:\n\tgpmi_free_dma_buffer(this);\n\treturn ret;\n}\n\nstatic const struct of_device_id gpmi_nand_id_table[] = {\n\t{ .compatible = \"fsl,imx23-gpmi-nand\", .data = &gpmi_devdata_imx23, },\n\t{ .compatible = \"fsl,imx28-gpmi-nand\", .data = &gpmi_devdata_imx28, },\n\t{ .compatible = \"fsl,imx6q-gpmi-nand\", .data = &gpmi_devdata_imx6q, },\n\t{ .compatible = \"fsl,imx6sx-gpmi-nand\", .data = &gpmi_devdata_imx6sx, },\n\t{ .compatible = \"fsl,imx7d-gpmi-nand\", .data = &gpmi_devdata_imx7d,},\n\t{}\n};\nMODULE_DEVICE_TABLE(of, gpmi_nand_id_table);\n\nstatic int gpmi_nand_probe(struct platform_device *pdev)\n{\n\tstruct gpmi_nand_data *this;\n\tint ret;\n\n\tthis = devm_kzalloc(&pdev->dev, sizeof(*this), GFP_KERNEL);\n\tif (!this)\n\t\treturn -ENOMEM;\n\n\tthis->devdata = of_device_get_match_data(&pdev->dev);\n\tplatform_set_drvdata(pdev, this);\n\tthis->pdev  = pdev;\n\tthis->dev   = &pdev->dev;\n\n\tret = acquire_resources(this);\n\tif (ret)\n\t\tgoto exit_acquire_resources;\n\n\tret = __gpmi_enable_clk(this, true);\n\tif (ret)\n\t\tgoto exit_acquire_resources;\n\n\tpm_runtime_set_autosuspend_delay(&pdev->dev, 500);\n\tpm_runtime_use_autosuspend(&pdev->dev);\n\tpm_runtime_set_active(&pdev->dev);\n\tpm_runtime_enable(&pdev->dev);\n\tpm_runtime_get_sync(&pdev->dev);\n\n\tret = gpmi_init(this);\n\tif (ret)\n\t\tgoto exit_nfc_init;\n\n\tret = gpmi_nand_init(this);\n\tif (ret)\n\t\tgoto exit_nfc_init;\n\n\tpm_runtime_mark_last_busy(&pdev->dev);\n\tpm_runtime_put_autosuspend(&pdev->dev);\n\n\tdev_info(this->dev, \"driver registered.\\n\");\n\n\treturn 0;\n\nexit_nfc_init:\n\tpm_runtime_put(&pdev->dev);\n\tpm_runtime_disable(&pdev->dev);\n\trelease_resources(this);\nexit_acquire_resources:\n\n\treturn ret;\n}\n\nstatic void gpmi_nand_remove(struct platform_device *pdev)\n{\n\tstruct gpmi_nand_data *this = platform_get_drvdata(pdev);\n\tstruct nand_chip *chip = &this->nand;\n\tint ret;\n\n\tpm_runtime_put_sync(&pdev->dev);\n\tpm_runtime_disable(&pdev->dev);\n\n\tret = mtd_device_unregister(nand_to_mtd(chip));\n\tWARN_ON(ret);\n\tnand_cleanup(chip);\n\tgpmi_free_dma_buffer(this);\n\trelease_resources(this);\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int gpmi_pm_suspend(struct device *dev)\n{\n\tstruct gpmi_nand_data *this = dev_get_drvdata(dev);\n\n\trelease_dma_channels(this);\n\treturn 0;\n}\n\nstatic int gpmi_pm_resume(struct device *dev)\n{\n\tstruct gpmi_nand_data *this = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = acquire_dma_channels(this);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = gpmi_init(this);\n\tif (ret) {\n\t\tdev_err(this->dev, \"Error setting GPMI : %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tif (this->hw.clk_rate)\n\t\tthis->hw.must_apply_timings = true;\n\n\t \n\tret = bch_set_geometry(this);\n\tif (ret) {\n\t\tdev_err(this->dev, \"Error setting BCH : %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n#endif  \n\nstatic int __maybe_unused gpmi_runtime_suspend(struct device *dev)\n{\n\tstruct gpmi_nand_data *this = dev_get_drvdata(dev);\n\n\treturn __gpmi_enable_clk(this, false);\n}\n\nstatic int __maybe_unused gpmi_runtime_resume(struct device *dev)\n{\n\tstruct gpmi_nand_data *this = dev_get_drvdata(dev);\n\n\treturn __gpmi_enable_clk(this, true);\n}\n\nstatic const struct dev_pm_ops gpmi_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(gpmi_pm_suspend, gpmi_pm_resume)\n\tSET_RUNTIME_PM_OPS(gpmi_runtime_suspend, gpmi_runtime_resume, NULL)\n};\n\nstatic struct platform_driver gpmi_nand_driver = {\n\t.driver = {\n\t\t.name = \"gpmi-nand\",\n\t\t.pm = &gpmi_pm_ops,\n\t\t.of_match_table = gpmi_nand_id_table,\n\t},\n\t.probe   = gpmi_nand_probe,\n\t.remove_new = gpmi_nand_remove,\n};\nmodule_platform_driver(gpmi_nand_driver);\n\nMODULE_AUTHOR(\"Freescale Semiconductor, Inc.\");\nMODULE_DESCRIPTION(\"i.MX GPMI NAND Flash Controller Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}