{
  "module_name": "nand_base.c",
  "hash_id": "5a2fe9a99c28ee8771d49c1a1b5b37a4636804ef13c1a127d3147d4eb11164e3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/nand/raw/nand_base.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/types.h>\n#include <linux/mtd/mtd.h>\n#include <linux/mtd/nand.h>\n#include <linux/mtd/nand-ecc-sw-hamming.h>\n#include <linux/mtd/nand-ecc-sw-bch.h>\n#include <linux/interrupt.h>\n#include <linux/bitops.h>\n#include <linux/io.h>\n#include <linux/mtd/partitions.h>\n#include <linux/of.h>\n#include <linux/of_gpio.h>\n#include <linux/gpio/consumer.h>\n\n#include \"internals.h\"\n\nstatic int nand_pairing_dist3_get_info(struct mtd_info *mtd, int page,\n\t\t\t\t       struct mtd_pairing_info *info)\n{\n\tint lastpage = (mtd->erasesize / mtd->writesize) - 1;\n\tint dist = 3;\n\n\tif (page == lastpage)\n\t\tdist = 2;\n\n\tif (!page || (page & 1)) {\n\t\tinfo->group = 0;\n\t\tinfo->pair = (page + 1) / 2;\n\t} else {\n\t\tinfo->group = 1;\n\t\tinfo->pair = (page + 1 - dist) / 2;\n\t}\n\n\treturn 0;\n}\n\nstatic int nand_pairing_dist3_get_wunit(struct mtd_info *mtd,\n\t\t\t\t\tconst struct mtd_pairing_info *info)\n{\n\tint lastpair = ((mtd->erasesize / mtd->writesize) - 1) / 2;\n\tint page = info->pair * 2;\n\tint dist = 3;\n\n\tif (!info->group && !info->pair)\n\t\treturn 0;\n\n\tif (info->pair == lastpair && info->group)\n\t\tdist = 2;\n\n\tif (!info->group)\n\t\tpage--;\n\telse if (info->pair)\n\t\tpage += dist - 1;\n\n\tif (page >= mtd->erasesize / mtd->writesize)\n\t\treturn -EINVAL;\n\n\treturn page;\n}\n\nconst struct mtd_pairing_scheme dist3_pairing_scheme = {\n\t.ngroups = 2,\n\t.get_info = nand_pairing_dist3_get_info,\n\t.get_wunit = nand_pairing_dist3_get_wunit,\n};\n\nstatic int check_offs_len(struct nand_chip *chip, loff_t ofs, uint64_t len)\n{\n\tint ret = 0;\n\n\t \n\tif (ofs & ((1ULL << chip->phys_erase_shift) - 1)) {\n\t\tpr_debug(\"%s: unaligned address\\n\", __func__);\n\t\tret = -EINVAL;\n\t}\n\n\t \n\tif (len & ((1ULL << chip->phys_erase_shift) - 1)) {\n\t\tpr_debug(\"%s: length not block aligned\\n\", __func__);\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}\n\n \nvoid nand_extract_bits(u8 *dst, unsigned int dst_off, const u8 *src,\n\t\t       unsigned int src_off, unsigned int nbits)\n{\n\tunsigned int tmp, n;\n\n\tdst += dst_off / 8;\n\tdst_off %= 8;\n\tsrc += src_off / 8;\n\tsrc_off %= 8;\n\n\twhile (nbits) {\n\t\tn = min3(8 - dst_off, 8 - src_off, nbits);\n\n\t\ttmp = (*src >> src_off) & GENMASK(n - 1, 0);\n\t\t*dst &= ~GENMASK(n - 1 + dst_off, dst_off);\n\t\t*dst |= tmp << dst_off;\n\n\t\tdst_off += n;\n\t\tif (dst_off >= 8) {\n\t\t\tdst++;\n\t\t\tdst_off -= 8;\n\t\t}\n\n\t\tsrc_off += n;\n\t\tif (src_off >= 8) {\n\t\t\tsrc++;\n\t\t\tsrc_off -= 8;\n\t\t}\n\n\t\tnbits -= n;\n\t}\n}\nEXPORT_SYMBOL_GPL(nand_extract_bits);\n\n \nvoid nand_select_target(struct nand_chip *chip, unsigned int cs)\n{\n\t \n\tif (WARN_ON(cs > nanddev_ntargets(&chip->base)))\n\t\treturn;\n\n\tchip->cur_cs = cs;\n\n\tif (chip->legacy.select_chip)\n\t\tchip->legacy.select_chip(chip, cs);\n}\nEXPORT_SYMBOL_GPL(nand_select_target);\n\n \nvoid nand_deselect_target(struct nand_chip *chip)\n{\n\tif (chip->legacy.select_chip)\n\t\tchip->legacy.select_chip(chip, -1);\n\n\tchip->cur_cs = -1;\n}\nEXPORT_SYMBOL_GPL(nand_deselect_target);\n\n \nstatic void nand_release_device(struct nand_chip *chip)\n{\n\t \n\tmutex_unlock(&chip->controller->lock);\n\tmutex_unlock(&chip->lock);\n}\n\n \nint nand_bbm_get_next_page(struct nand_chip *chip, int page)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tint last_page = ((mtd->erasesize - mtd->writesize) >>\n\t\t\t chip->page_shift) & chip->pagemask;\n\tunsigned int bbm_flags = NAND_BBM_FIRSTPAGE | NAND_BBM_SECONDPAGE\n\t\t| NAND_BBM_LASTPAGE;\n\n\tif (page == 0 && !(chip->options & bbm_flags))\n\t\treturn 0;\n\tif (page == 0 && chip->options & NAND_BBM_FIRSTPAGE)\n\t\treturn 0;\n\tif (page <= 1 && chip->options & NAND_BBM_SECONDPAGE)\n\t\treturn 1;\n\tif (page <= last_page && chip->options & NAND_BBM_LASTPAGE)\n\t\treturn last_page;\n\n\treturn -EINVAL;\n}\n\n \nstatic int nand_block_bad(struct nand_chip *chip, loff_t ofs)\n{\n\tint first_page, page_offset;\n\tint res;\n\tu8 bad;\n\n\tfirst_page = (int)(ofs >> chip->page_shift) & chip->pagemask;\n\tpage_offset = nand_bbm_get_next_page(chip, 0);\n\n\twhile (page_offset >= 0) {\n\t\tres = chip->ecc.read_oob(chip, first_page + page_offset);\n\t\tif (res < 0)\n\t\t\treturn res;\n\n\t\tbad = chip->oob_poi[chip->badblockpos];\n\n\t\tif (likely(chip->badblockbits == 8))\n\t\t\tres = bad != 0xFF;\n\t\telse\n\t\t\tres = hweight8(bad) < chip->badblockbits;\n\t\tif (res)\n\t\t\treturn res;\n\n\t\tpage_offset = nand_bbm_get_next_page(chip, page_offset + 1);\n\t}\n\n\treturn 0;\n}\n\n \nstatic bool nand_region_is_secured(struct nand_chip *chip, loff_t offset, u64 size)\n{\n\tint i;\n\n\t \n\tfor (i = 0; i < chip->nr_secure_regions; i++) {\n\t\tconst struct nand_secure_region *region = &chip->secure_regions[i];\n\n\t\tif (offset + size <= region->offset ||\n\t\t    offset >= region->offset + region->size)\n\t\t\tcontinue;\n\n\t\tpr_debug(\"%s: Region 0x%llx - 0x%llx is secured!\",\n\t\t\t __func__, offset, offset + size);\n\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic int nand_isbad_bbm(struct nand_chip *chip, loff_t ofs)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\n\tif (chip->options & NAND_NO_BBM_QUIRK)\n\t\treturn 0;\n\n\t \n\tif (nand_region_is_secured(chip, ofs, mtd->erasesize))\n\t\treturn -EIO;\n\n\tif (mtd_check_expert_analysis_mode())\n\t\treturn 0;\n\n\tif (chip->legacy.block_bad)\n\t\treturn chip->legacy.block_bad(chip, ofs);\n\n\treturn nand_block_bad(chip, ofs);\n}\n\n \nstatic void nand_get_device(struct nand_chip *chip)\n{\n\t \n\twhile (1) {\n\t\tmutex_lock(&chip->lock);\n\t\tif (!chip->suspended) {\n\t\t\tmutex_lock(&chip->controller->lock);\n\t\t\treturn;\n\t\t}\n\t\tmutex_unlock(&chip->lock);\n\n\t\twait_event(chip->resume_wq, !chip->suspended);\n\t}\n}\n\n \nstatic int nand_check_wp(struct nand_chip *chip)\n{\n\tu8 status;\n\tint ret;\n\n\t \n\tif (chip->options & NAND_BROKEN_XD)\n\t\treturn 0;\n\n\t \n\tret = nand_status_op(chip, &status);\n\tif (ret)\n\t\treturn ret;\n\n\treturn status & NAND_STATUS_WP ? 0 : 1;\n}\n\n \nstatic uint8_t *nand_fill_oob(struct nand_chip *chip, uint8_t *oob, size_t len,\n\t\t\t      struct mtd_oob_ops *ops)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tint ret;\n\n\t \n\tmemset(chip->oob_poi, 0xff, mtd->oobsize);\n\n\tswitch (ops->mode) {\n\n\tcase MTD_OPS_PLACE_OOB:\n\tcase MTD_OPS_RAW:\n\t\tmemcpy(chip->oob_poi + ops->ooboffs, oob, len);\n\t\treturn oob + len;\n\n\tcase MTD_OPS_AUTO_OOB:\n\t\tret = mtd_ooblayout_set_databytes(mtd, oob, chip->oob_poi,\n\t\t\t\t\t\t  ops->ooboffs, len);\n\t\tBUG_ON(ret);\n\t\treturn oob + len;\n\n\tdefault:\n\t\tBUG();\n\t}\n\treturn NULL;\n}\n\n \nstatic int nand_do_write_oob(struct nand_chip *chip, loff_t to,\n\t\t\t     struct mtd_oob_ops *ops)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tint chipnr, page, status, len, ret;\n\n\tpr_debug(\"%s: to = 0x%08x, len = %i\\n\",\n\t\t\t __func__, (unsigned int)to, (int)ops->ooblen);\n\n\tlen = mtd_oobavail(mtd, ops);\n\n\t \n\tif ((ops->ooboffs + ops->ooblen) > len) {\n\t\tpr_debug(\"%s: attempt to write past end of page\\n\",\n\t\t\t\t__func__);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (nand_region_is_secured(chip, to, ops->ooblen))\n\t\treturn -EIO;\n\n\tchipnr = (int)(to >> chip->chip_shift);\n\n\t \n\tret = nand_reset(chip, chipnr);\n\tif (ret)\n\t\treturn ret;\n\n\tnand_select_target(chip, chipnr);\n\n\t \n\tpage = (int)(to >> chip->page_shift);\n\n\t \n\tif (nand_check_wp(chip)) {\n\t\tnand_deselect_target(chip);\n\t\treturn -EROFS;\n\t}\n\n\t \n\tif (page == chip->pagecache.page)\n\t\tchip->pagecache.page = -1;\n\n\tnand_fill_oob(chip, ops->oobbuf, ops->ooblen, ops);\n\n\tif (ops->mode == MTD_OPS_RAW)\n\t\tstatus = chip->ecc.write_oob_raw(chip, page & chip->pagemask);\n\telse\n\t\tstatus = chip->ecc.write_oob(chip, page & chip->pagemask);\n\n\tnand_deselect_target(chip);\n\n\tif (status)\n\t\treturn status;\n\n\tops->oobretlen = ops->ooblen;\n\n\treturn 0;\n}\n\n \nstatic int nand_default_block_markbad(struct nand_chip *chip, loff_t ofs)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tstruct mtd_oob_ops ops;\n\tuint8_t buf[2] = { 0, 0 };\n\tint ret = 0, res, page_offset;\n\n\tmemset(&ops, 0, sizeof(ops));\n\tops.oobbuf = buf;\n\tops.ooboffs = chip->badblockpos;\n\tif (chip->options & NAND_BUSWIDTH_16) {\n\t\tops.ooboffs &= ~0x01;\n\t\tops.len = ops.ooblen = 2;\n\t} else {\n\t\tops.len = ops.ooblen = 1;\n\t}\n\tops.mode = MTD_OPS_PLACE_OOB;\n\n\tpage_offset = nand_bbm_get_next_page(chip, 0);\n\n\twhile (page_offset >= 0) {\n\t\tres = nand_do_write_oob(chip,\n\t\t\t\t\tofs + (page_offset * mtd->writesize),\n\t\t\t\t\t&ops);\n\n\t\tif (!ret)\n\t\t\tret = res;\n\n\t\tpage_offset = nand_bbm_get_next_page(chip, page_offset + 1);\n\t}\n\n\treturn ret;\n}\n\n \nint nand_markbad_bbm(struct nand_chip *chip, loff_t ofs)\n{\n\tif (chip->legacy.block_markbad)\n\t\treturn chip->legacy.block_markbad(chip, ofs);\n\n\treturn nand_default_block_markbad(chip, ofs);\n}\n\n \nstatic int nand_block_markbad_lowlevel(struct nand_chip *chip, loff_t ofs)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tint res, ret = 0;\n\n\tif (!(chip->bbt_options & NAND_BBT_NO_OOB_BBM)) {\n\t\tstruct erase_info einfo;\n\n\t\t \n\t\tmemset(&einfo, 0, sizeof(einfo));\n\t\teinfo.addr = ofs;\n\t\teinfo.len = 1ULL << chip->phys_erase_shift;\n\t\tnand_erase_nand(chip, &einfo, 0);\n\n\t\t \n\t\tnand_get_device(chip);\n\n\t\tret = nand_markbad_bbm(chip, ofs);\n\t\tnand_release_device(chip);\n\t}\n\n\t \n\tif (chip->bbt) {\n\t\tres = nand_markbad_bbt(chip, ofs);\n\t\tif (!ret)\n\t\t\tret = res;\n\t}\n\n\tif (!ret)\n\t\tmtd->ecc_stats.badblocks++;\n\n\treturn ret;\n}\n\n \nstatic int nand_block_isreserved(struct mtd_info *mtd, loff_t ofs)\n{\n\tstruct nand_chip *chip = mtd_to_nand(mtd);\n\n\tif (!chip->bbt)\n\t\treturn 0;\n\t \n\treturn nand_isreserved_bbt(chip, ofs);\n}\n\n \nstatic int nand_block_checkbad(struct nand_chip *chip, loff_t ofs, int allowbbt)\n{\n\t \n\tif (chip->bbt)\n\t\treturn nand_isbad_bbt(chip, ofs, allowbbt);\n\n\treturn nand_isbad_bbm(chip, ofs);\n}\n\n \nint nand_soft_waitrdy(struct nand_chip *chip, unsigned long timeout_ms)\n{\n\tconst struct nand_interface_config *conf;\n\tu8 status = 0;\n\tint ret;\n\n\tif (!nand_has_exec_op(chip))\n\t\treturn -ENOTSUPP;\n\n\t \n\tconf = nand_get_interface_config(chip);\n\tndelay(NAND_COMMON_TIMING_NS(conf, tWB_max));\n\n\tret = nand_status_op(chip, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\ttimeout_ms = jiffies + msecs_to_jiffies(timeout_ms) + 1;\n\tdo {\n\t\tret = nand_read_data_op(chip, &status, sizeof(status), true,\n\t\t\t\t\tfalse);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tif (status & NAND_STATUS_READY)\n\t\t\tbreak;\n\n\t\t \n\t\tudelay(10);\n\t} while\t(time_before(jiffies, timeout_ms));\n\n\t \n\tnand_exit_status_op(chip);\n\n\tif (ret)\n\t\treturn ret;\n\n\treturn status & NAND_STATUS_READY ? 0 : -ETIMEDOUT;\n};\nEXPORT_SYMBOL_GPL(nand_soft_waitrdy);\n\n \nint nand_gpio_waitrdy(struct nand_chip *chip, struct gpio_desc *gpiod,\n\t\t      unsigned long timeout_ms)\n{\n\n\t \n\ttimeout_ms = jiffies + msecs_to_jiffies(timeout_ms) + 1;\n\tdo {\n\t\tif (gpiod_get_value_cansleep(gpiod))\n\t\t\treturn 0;\n\n\t\tcond_resched();\n\t} while\t(time_before(jiffies, timeout_ms));\n\n\treturn gpiod_get_value_cansleep(gpiod) ? 0 : -ETIMEDOUT;\n};\nEXPORT_SYMBOL_GPL(nand_gpio_waitrdy);\n\n \nvoid panic_nand_wait(struct nand_chip *chip, unsigned long timeo)\n{\n\tint i;\n\tfor (i = 0; i < timeo; i++) {\n\t\tif (chip->legacy.dev_ready) {\n\t\t\tif (chip->legacy.dev_ready(chip))\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tint ret;\n\t\t\tu8 status;\n\n\t\t\tret = nand_read_data_op(chip, &status, sizeof(status),\n\t\t\t\t\t\ttrue, false);\n\t\t\tif (ret)\n\t\t\t\treturn;\n\n\t\t\tif (status & NAND_STATUS_READY)\n\t\t\t\tbreak;\n\t\t}\n\t\tmdelay(1);\n\t}\n}\n\nstatic bool nand_supports_get_features(struct nand_chip *chip, int addr)\n{\n\treturn (chip->parameters.supports_set_get_features &&\n\t\ttest_bit(addr, chip->parameters.get_feature_list));\n}\n\nstatic bool nand_supports_set_features(struct nand_chip *chip, int addr)\n{\n\treturn (chip->parameters.supports_set_get_features &&\n\t\ttest_bit(addr, chip->parameters.set_feature_list));\n}\n\n \nstatic int nand_reset_interface(struct nand_chip *chip, int chipnr)\n{\n\tconst struct nand_controller_ops *ops = chip->controller->ops;\n\tint ret;\n\n\tif (!nand_controller_can_setup_interface(chip))\n\t\treturn 0;\n\n\t \n\n\tchip->current_interface_config = nand_get_reset_interface_config();\n\tret = ops->setup_interface(chip, chipnr,\n\t\t\t\t   chip->current_interface_config);\n\tif (ret)\n\t\tpr_err(\"Failed to configure data interface to SDR timing mode 0\\n\");\n\n\treturn ret;\n}\n\n \nstatic int nand_setup_interface(struct nand_chip *chip, int chipnr)\n{\n\tconst struct nand_controller_ops *ops = chip->controller->ops;\n\tu8 tmode_param[ONFI_SUBFEATURE_PARAM_LEN] = { }, request;\n\tint ret;\n\n\tif (!nand_controller_can_setup_interface(chip))\n\t\treturn 0;\n\n\t \n\tif (!chip->best_interface_config)\n\t\treturn 0;\n\n\trequest = chip->best_interface_config->timings.mode;\n\tif (nand_interface_is_sdr(chip->best_interface_config))\n\t\trequest |= ONFI_DATA_INTERFACE_SDR;\n\telse\n\t\trequest |= ONFI_DATA_INTERFACE_NVDDR;\n\ttmode_param[0] = request;\n\n\t \n\tif (nand_supports_set_features(chip, ONFI_FEATURE_ADDR_TIMING_MODE)) {\n\t\tnand_select_target(chip, chipnr);\n\t\tret = nand_set_features(chip, ONFI_FEATURE_ADDR_TIMING_MODE,\n\t\t\t\t\ttmode_param);\n\t\tnand_deselect_target(chip);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\tret = ops->setup_interface(chip, chipnr, chip->best_interface_config);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (!nand_supports_get_features(chip, ONFI_FEATURE_ADDR_TIMING_MODE))\n\t\tgoto update_interface_config;\n\n\tmemset(tmode_param, 0, ONFI_SUBFEATURE_PARAM_LEN);\n\tnand_select_target(chip, chipnr);\n\tret = nand_get_features(chip, ONFI_FEATURE_ADDR_TIMING_MODE,\n\t\t\t\ttmode_param);\n\tnand_deselect_target(chip);\n\tif (ret)\n\t\tgoto err_reset_chip;\n\n\tif (request != tmode_param[0]) {\n\t\tpr_warn(\"%s timing mode %d not acknowledged by the NAND chip\\n\",\n\t\t\tnand_interface_is_nvddr(chip->best_interface_config) ? \"NV-DDR\" : \"SDR\",\n\t\t\tchip->best_interface_config->timings.mode);\n\t\tpr_debug(\"NAND chip would work in %s timing mode %d\\n\",\n\t\t\t tmode_param[0] & ONFI_DATA_INTERFACE_NVDDR ? \"NV-DDR\" : \"SDR\",\n\t\t\t (unsigned int)ONFI_TIMING_MODE_PARAM(tmode_param[0]));\n\t\tgoto err_reset_chip;\n\t}\n\nupdate_interface_config:\n\tchip->current_interface_config = chip->best_interface_config;\n\n\treturn 0;\n\nerr_reset_chip:\n\t \n\tnand_reset_interface(chip, chipnr);\n\tnand_select_target(chip, chipnr);\n\tnand_reset_op(chip);\n\tnand_deselect_target(chip);\n\n\treturn ret;\n}\n\n \nint nand_choose_best_sdr_timings(struct nand_chip *chip,\n\t\t\t\t struct nand_interface_config *iface,\n\t\t\t\t struct nand_sdr_timings *spec_timings)\n{\n\tconst struct nand_controller_ops *ops = chip->controller->ops;\n\tint best_mode = 0, mode, ret = -EOPNOTSUPP;\n\n\tiface->type = NAND_SDR_IFACE;\n\n\tif (spec_timings) {\n\t\tiface->timings.sdr = *spec_timings;\n\t\tiface->timings.mode = onfi_find_closest_sdr_mode(spec_timings);\n\n\t\t \n\t\tret = ops->setup_interface(chip, NAND_DATA_IFACE_CHECK_ONLY,\n\t\t\t\t\t   iface);\n\t\tif (!ret) {\n\t\t\tchip->best_interface_config = iface;\n\t\t\treturn ret;\n\t\t}\n\n\t\t \n\t\tbest_mode = iface->timings.mode;\n\t} else if (chip->parameters.onfi) {\n\t\tbest_mode = fls(chip->parameters.onfi->sdr_timing_modes) - 1;\n\t}\n\n\tfor (mode = best_mode; mode >= 0; mode--) {\n\t\tonfi_fill_interface_config(chip, iface, NAND_SDR_IFACE, mode);\n\n\t\tret = ops->setup_interface(chip, NAND_DATA_IFACE_CHECK_ONLY,\n\t\t\t\t\t   iface);\n\t\tif (!ret) {\n\t\t\tchip->best_interface_config = iface;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\n \nint nand_choose_best_nvddr_timings(struct nand_chip *chip,\n\t\t\t\t   struct nand_interface_config *iface,\n\t\t\t\t   struct nand_nvddr_timings *spec_timings)\n{\n\tconst struct nand_controller_ops *ops = chip->controller->ops;\n\tint best_mode = 0, mode, ret = -EOPNOTSUPP;\n\n\tiface->type = NAND_NVDDR_IFACE;\n\n\tif (spec_timings) {\n\t\tiface->timings.nvddr = *spec_timings;\n\t\tiface->timings.mode = onfi_find_closest_nvddr_mode(spec_timings);\n\n\t\t \n\t\tret = ops->setup_interface(chip, NAND_DATA_IFACE_CHECK_ONLY,\n\t\t\t\t\t   iface);\n\t\tif (!ret) {\n\t\t\tchip->best_interface_config = iface;\n\t\t\treturn ret;\n\t\t}\n\n\t\t \n\t\tbest_mode = iface->timings.mode;\n\t} else if (chip->parameters.onfi) {\n\t\tbest_mode = fls(chip->parameters.onfi->nvddr_timing_modes) - 1;\n\t}\n\n\tfor (mode = best_mode; mode >= 0; mode--) {\n\t\tonfi_fill_interface_config(chip, iface, NAND_NVDDR_IFACE, mode);\n\n\t\tret = ops->setup_interface(chip, NAND_DATA_IFACE_CHECK_ONLY,\n\t\t\t\t\t   iface);\n\t\tif (!ret) {\n\t\t\tchip->best_interface_config = iface;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\n \nstatic int nand_choose_best_timings(struct nand_chip *chip,\n\t\t\t\t    struct nand_interface_config *iface)\n{\n\tint ret;\n\n\t \n\tret = nand_choose_best_nvddr_timings(chip, iface, NULL);\n\tif (!ret)\n\t\treturn 0;\n\n\t \n\treturn nand_choose_best_sdr_timings(chip, iface, NULL);\n}\n\n \nstatic int nand_choose_interface_config(struct nand_chip *chip)\n{\n\tstruct nand_interface_config *iface;\n\tint ret;\n\n\tif (!nand_controller_can_setup_interface(chip))\n\t\treturn 0;\n\n\tiface = kzalloc(sizeof(*iface), GFP_KERNEL);\n\tif (!iface)\n\t\treturn -ENOMEM;\n\n\tif (chip->ops.choose_interface_config)\n\t\tret = chip->ops.choose_interface_config(chip, iface);\n\telse\n\t\tret = nand_choose_best_timings(chip, iface);\n\n\tif (ret)\n\t\tkfree(iface);\n\n\treturn ret;\n}\n\n \nstatic int nand_fill_column_cycles(struct nand_chip *chip, u8 *addrs,\n\t\t\t\t   unsigned int offset_in_page)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\n\t \n\tif (offset_in_page > mtd->writesize + mtd->oobsize)\n\t\treturn -EINVAL;\n\n\t \n\tif (mtd->writesize <= 512 && offset_in_page >= mtd->writesize)\n\t\toffset_in_page -= mtd->writesize;\n\n\t \n\tif (chip->options & NAND_BUSWIDTH_16) {\n\t\tif (WARN_ON(offset_in_page % 2))\n\t\t\treturn -EINVAL;\n\n\t\toffset_in_page /= 2;\n\t}\n\n\taddrs[0] = offset_in_page;\n\n\t \n\tif (mtd->writesize <= 512)\n\t\treturn 1;\n\n\taddrs[1] = offset_in_page >> 8;\n\n\treturn 2;\n}\n\nstatic int nand_sp_exec_read_page_op(struct nand_chip *chip, unsigned int page,\n\t\t\t\t     unsigned int offset_in_page, void *buf,\n\t\t\t\t     unsigned int len)\n{\n\tconst struct nand_interface_config *conf =\n\t\tnand_get_interface_config(chip);\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tu8 addrs[4];\n\tstruct nand_op_instr instrs[] = {\n\t\tNAND_OP_CMD(NAND_CMD_READ0, 0),\n\t\tNAND_OP_ADDR(3, addrs, NAND_COMMON_TIMING_NS(conf, tWB_max)),\n\t\tNAND_OP_WAIT_RDY(NAND_COMMON_TIMING_MS(conf, tR_max),\n\t\t\t\t NAND_COMMON_TIMING_NS(conf, tRR_min)),\n\t\tNAND_OP_DATA_IN(len, buf, 0),\n\t};\n\tstruct nand_operation op = NAND_OPERATION(chip->cur_cs, instrs);\n\tint ret;\n\n\t \n\tif (!len)\n\t\top.ninstrs--;\n\n\tif (offset_in_page >= mtd->writesize)\n\t\tinstrs[0].ctx.cmd.opcode = NAND_CMD_READOOB;\n\telse if (offset_in_page >= 256 &&\n\t\t !(chip->options & NAND_BUSWIDTH_16))\n\t\tinstrs[0].ctx.cmd.opcode = NAND_CMD_READ1;\n\n\tret = nand_fill_column_cycles(chip, addrs, offset_in_page);\n\tif (ret < 0)\n\t\treturn ret;\n\n\taddrs[1] = page;\n\taddrs[2] = page >> 8;\n\n\tif (chip->options & NAND_ROW_ADDR_3) {\n\t\taddrs[3] = page >> 16;\n\t\tinstrs[1].ctx.addr.naddrs++;\n\t}\n\n\treturn nand_exec_op(chip, &op);\n}\n\nstatic int nand_lp_exec_read_page_op(struct nand_chip *chip, unsigned int page,\n\t\t\t\t     unsigned int offset_in_page, void *buf,\n\t\t\t\t     unsigned int len)\n{\n\tconst struct nand_interface_config *conf =\n\t\tnand_get_interface_config(chip);\n\tu8 addrs[5];\n\tstruct nand_op_instr instrs[] = {\n\t\tNAND_OP_CMD(NAND_CMD_READ0, 0),\n\t\tNAND_OP_ADDR(4, addrs, 0),\n\t\tNAND_OP_CMD(NAND_CMD_READSTART, NAND_COMMON_TIMING_NS(conf, tWB_max)),\n\t\tNAND_OP_WAIT_RDY(NAND_COMMON_TIMING_MS(conf, tR_max),\n\t\t\t\t NAND_COMMON_TIMING_NS(conf, tRR_min)),\n\t\tNAND_OP_DATA_IN(len, buf, 0),\n\t};\n\tstruct nand_operation op = NAND_OPERATION(chip->cur_cs, instrs);\n\tint ret;\n\n\t \n\tif (!len)\n\t\top.ninstrs--;\n\n\tret = nand_fill_column_cycles(chip, addrs, offset_in_page);\n\tif (ret < 0)\n\t\treturn ret;\n\n\taddrs[2] = page;\n\taddrs[3] = page >> 8;\n\n\tif (chip->options & NAND_ROW_ADDR_3) {\n\t\taddrs[4] = page >> 16;\n\t\tinstrs[1].ctx.addr.naddrs++;\n\t}\n\n\treturn nand_exec_op(chip, &op);\n}\n\nstatic int nand_lp_exec_cont_read_page_op(struct nand_chip *chip, unsigned int page,\n\t\t\t\t\t  unsigned int offset_in_page, void *buf,\n\t\t\t\t\t  unsigned int len, bool check_only)\n{\n\tconst struct nand_interface_config *conf =\n\t\tnand_get_interface_config(chip);\n\tu8 addrs[5];\n\tstruct nand_op_instr start_instrs[] = {\n\t\tNAND_OP_CMD(NAND_CMD_READ0, 0),\n\t\tNAND_OP_ADDR(4, addrs, 0),\n\t\tNAND_OP_CMD(NAND_CMD_READSTART, NAND_COMMON_TIMING_NS(conf, tWB_max)),\n\t\tNAND_OP_WAIT_RDY(NAND_COMMON_TIMING_MS(conf, tR_max), 0),\n\t\tNAND_OP_CMD(NAND_CMD_READCACHESEQ, NAND_COMMON_TIMING_NS(conf, tWB_max)),\n\t\tNAND_OP_WAIT_RDY(NAND_COMMON_TIMING_MS(conf, tR_max),\n\t\t\t\t NAND_COMMON_TIMING_NS(conf, tRR_min)),\n\t\tNAND_OP_DATA_IN(len, buf, 0),\n\t};\n\tstruct nand_op_instr cont_instrs[] = {\n\t\tNAND_OP_CMD(page == chip->cont_read.last_page ?\n\t\t\t    NAND_CMD_READCACHEEND : NAND_CMD_READCACHESEQ,\n\t\t\t    NAND_COMMON_TIMING_NS(conf, tWB_max)),\n\t\tNAND_OP_WAIT_RDY(NAND_COMMON_TIMING_MS(conf, tR_max),\n\t\t\t\t NAND_COMMON_TIMING_NS(conf, tRR_min)),\n\t\tNAND_OP_DATA_IN(len, buf, 0),\n\t};\n\tstruct nand_operation start_op = NAND_OPERATION(chip->cur_cs, start_instrs);\n\tstruct nand_operation cont_op = NAND_OPERATION(chip->cur_cs, cont_instrs);\n\tint ret;\n\n\tif (!len) {\n\t\tstart_op.ninstrs--;\n\t\tcont_op.ninstrs--;\n\t}\n\n\tret = nand_fill_column_cycles(chip, addrs, offset_in_page);\n\tif (ret < 0)\n\t\treturn ret;\n\n\taddrs[2] = page;\n\taddrs[3] = page >> 8;\n\n\tif (chip->options & NAND_ROW_ADDR_3) {\n\t\taddrs[4] = page >> 16;\n\t\tstart_instrs[1].ctx.addr.naddrs++;\n\t}\n\n\t \n\tif (check_only) {\n\t\tif (nand_check_op(chip, &start_op) || nand_check_op(chip, &cont_op))\n\t\t\treturn -EOPNOTSUPP;\n\n\t\treturn 0;\n\t}\n\n\tif (page == chip->cont_read.first_page)\n\t\treturn nand_exec_op(chip, &start_op);\n\telse\n\t\treturn nand_exec_op(chip, &cont_op);\n}\n\nstatic bool rawnand_cont_read_ongoing(struct nand_chip *chip, unsigned int page)\n{\n\treturn chip->cont_read.ongoing &&\n\t\tpage >= chip->cont_read.first_page &&\n\t\tpage <= chip->cont_read.last_page;\n}\n\n \nint nand_read_page_op(struct nand_chip *chip, unsigned int page,\n\t\t      unsigned int offset_in_page, void *buf, unsigned int len)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\n\tif (len && !buf)\n\t\treturn -EINVAL;\n\n\tif (offset_in_page + len > mtd->writesize + mtd->oobsize)\n\t\treturn -EINVAL;\n\n\tif (nand_has_exec_op(chip)) {\n\t\tif (mtd->writesize > 512) {\n\t\t\tif (rawnand_cont_read_ongoing(chip, page))\n\t\t\t\treturn nand_lp_exec_cont_read_page_op(chip, page,\n\t\t\t\t\t\t\t\t      offset_in_page,\n\t\t\t\t\t\t\t\t      buf, len, false);\n\t\t\telse\n\t\t\t\treturn nand_lp_exec_read_page_op(chip, page,\n\t\t\t\t\t\t\t\t offset_in_page, buf,\n\t\t\t\t\t\t\t\t len);\n\t\t}\n\n\t\treturn nand_sp_exec_read_page_op(chip, page, offset_in_page,\n\t\t\t\t\t\t buf, len);\n\t}\n\n\tchip->legacy.cmdfunc(chip, NAND_CMD_READ0, offset_in_page, page);\n\tif (len)\n\t\tchip->legacy.read_buf(chip, buf, len);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(nand_read_page_op);\n\n \nint nand_read_param_page_op(struct nand_chip *chip, u8 page, void *buf,\n\t\t\t    unsigned int len)\n{\n\tunsigned int i;\n\tu8 *p = buf;\n\n\tif (len && !buf)\n\t\treturn -EINVAL;\n\n\tif (nand_has_exec_op(chip)) {\n\t\tconst struct nand_interface_config *conf =\n\t\t\tnand_get_interface_config(chip);\n\t\tstruct nand_op_instr instrs[] = {\n\t\t\tNAND_OP_CMD(NAND_CMD_PARAM, 0),\n\t\t\tNAND_OP_ADDR(1, &page,\n\t\t\t\t     NAND_COMMON_TIMING_NS(conf, tWB_max)),\n\t\t\tNAND_OP_WAIT_RDY(NAND_COMMON_TIMING_MS(conf, tR_max),\n\t\t\t\t\t NAND_COMMON_TIMING_NS(conf, tRR_min)),\n\t\t\tNAND_OP_8BIT_DATA_IN(len, buf, 0),\n\t\t};\n\t\tstruct nand_operation op = NAND_OPERATION(chip->cur_cs, instrs);\n\n\t\t \n\t\tif (!len)\n\t\t\top.ninstrs--;\n\n\t\treturn nand_exec_op(chip, &op);\n\t}\n\n\tchip->legacy.cmdfunc(chip, NAND_CMD_PARAM, page, -1);\n\tfor (i = 0; i < len; i++)\n\t\tp[i] = chip->legacy.read_byte(chip);\n\n\treturn 0;\n}\n\n \nint nand_change_read_column_op(struct nand_chip *chip,\n\t\t\t       unsigned int offset_in_page, void *buf,\n\t\t\t       unsigned int len, bool force_8bit)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\n\tif (len && !buf)\n\t\treturn -EINVAL;\n\n\tif (offset_in_page + len > mtd->writesize + mtd->oobsize)\n\t\treturn -EINVAL;\n\n\t \n\tif (mtd->writesize <= 512)\n\t\treturn -ENOTSUPP;\n\n\tif (nand_has_exec_op(chip)) {\n\t\tconst struct nand_interface_config *conf =\n\t\t\tnand_get_interface_config(chip);\n\t\tu8 addrs[2] = {};\n\t\tstruct nand_op_instr instrs[] = {\n\t\t\tNAND_OP_CMD(NAND_CMD_RNDOUT, 0),\n\t\t\tNAND_OP_ADDR(2, addrs, 0),\n\t\t\tNAND_OP_CMD(NAND_CMD_RNDOUTSTART,\n\t\t\t\t    NAND_COMMON_TIMING_NS(conf, tCCS_min)),\n\t\t\tNAND_OP_DATA_IN(len, buf, 0),\n\t\t};\n\t\tstruct nand_operation op = NAND_OPERATION(chip->cur_cs, instrs);\n\t\tint ret;\n\n\t\tret = nand_fill_column_cycles(chip, addrs, offset_in_page);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\t \n\t\tif (!len)\n\t\t\top.ninstrs--;\n\n\t\tinstrs[3].ctx.data.force_8bit = force_8bit;\n\n\t\treturn nand_exec_op(chip, &op);\n\t}\n\n\tchip->legacy.cmdfunc(chip, NAND_CMD_RNDOUT, offset_in_page, -1);\n\tif (len)\n\t\tchip->legacy.read_buf(chip, buf, len);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(nand_change_read_column_op);\n\n \nint nand_read_oob_op(struct nand_chip *chip, unsigned int page,\n\t\t     unsigned int offset_in_oob, void *buf, unsigned int len)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\n\tif (len && !buf)\n\t\treturn -EINVAL;\n\n\tif (offset_in_oob + len > mtd->oobsize)\n\t\treturn -EINVAL;\n\n\tif (nand_has_exec_op(chip))\n\t\treturn nand_read_page_op(chip, page,\n\t\t\t\t\t mtd->writesize + offset_in_oob,\n\t\t\t\t\t buf, len);\n\n\tchip->legacy.cmdfunc(chip, NAND_CMD_READOOB, offset_in_oob, page);\n\tif (len)\n\t\tchip->legacy.read_buf(chip, buf, len);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(nand_read_oob_op);\n\nstatic int nand_exec_prog_page_op(struct nand_chip *chip, unsigned int page,\n\t\t\t\t  unsigned int offset_in_page, const void *buf,\n\t\t\t\t  unsigned int len, bool prog)\n{\n\tconst struct nand_interface_config *conf =\n\t\tnand_get_interface_config(chip);\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tu8 addrs[5] = {};\n\tstruct nand_op_instr instrs[] = {\n\t\t \n\t\tNAND_OP_CMD(NAND_CMD_READ0, 0),\n\t\tNAND_OP_CMD(NAND_CMD_SEQIN, 0),\n\t\tNAND_OP_ADDR(0, addrs, NAND_COMMON_TIMING_NS(conf, tADL_min)),\n\t\tNAND_OP_DATA_OUT(len, buf, 0),\n\t\tNAND_OP_CMD(NAND_CMD_PAGEPROG,\n\t\t\t    NAND_COMMON_TIMING_NS(conf, tWB_max)),\n\t\tNAND_OP_WAIT_RDY(NAND_COMMON_TIMING_MS(conf, tPROG_max), 0),\n\t};\n\tstruct nand_operation op = NAND_OPERATION(chip->cur_cs, instrs);\n\tint naddrs = nand_fill_column_cycles(chip, addrs, offset_in_page);\n\n\tif (naddrs < 0)\n\t\treturn naddrs;\n\n\taddrs[naddrs++] = page;\n\taddrs[naddrs++] = page >> 8;\n\tif (chip->options & NAND_ROW_ADDR_3)\n\t\taddrs[naddrs++] = page >> 16;\n\n\tinstrs[2].ctx.addr.naddrs = naddrs;\n\n\t \n\tif (!prog) {\n\t\top.ninstrs -= 2;\n\t\t \n\t\tif (!len)\n\t\t\top.ninstrs--;\n\t}\n\n\tif (mtd->writesize <= 512) {\n\t\t \n\t\tif (offset_in_page >= mtd->writesize)\n\t\t\tinstrs[0].ctx.cmd.opcode = NAND_CMD_READOOB;\n\t\telse if (offset_in_page >= 256 &&\n\t\t\t !(chip->options & NAND_BUSWIDTH_16))\n\t\t\tinstrs[0].ctx.cmd.opcode = NAND_CMD_READ1;\n\t} else {\n\t\t \n\t\top.instrs++;\n\t\top.ninstrs--;\n\t}\n\n\treturn nand_exec_op(chip, &op);\n}\n\n \nint nand_prog_page_begin_op(struct nand_chip *chip, unsigned int page,\n\t\t\t    unsigned int offset_in_page, const void *buf,\n\t\t\t    unsigned int len)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\n\tif (len && !buf)\n\t\treturn -EINVAL;\n\n\tif (offset_in_page + len > mtd->writesize + mtd->oobsize)\n\t\treturn -EINVAL;\n\n\tif (nand_has_exec_op(chip))\n\t\treturn nand_exec_prog_page_op(chip, page, offset_in_page, buf,\n\t\t\t\t\t      len, false);\n\n\tchip->legacy.cmdfunc(chip, NAND_CMD_SEQIN, offset_in_page, page);\n\n\tif (buf)\n\t\tchip->legacy.write_buf(chip, buf, len);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(nand_prog_page_begin_op);\n\n \nint nand_prog_page_end_op(struct nand_chip *chip)\n{\n\tint ret;\n\tu8 status;\n\n\tif (nand_has_exec_op(chip)) {\n\t\tconst struct nand_interface_config *conf =\n\t\t\tnand_get_interface_config(chip);\n\t\tstruct nand_op_instr instrs[] = {\n\t\t\tNAND_OP_CMD(NAND_CMD_PAGEPROG,\n\t\t\t\t    NAND_COMMON_TIMING_NS(conf, tWB_max)),\n\t\t\tNAND_OP_WAIT_RDY(NAND_COMMON_TIMING_MS(conf, tPROG_max),\n\t\t\t\t\t 0),\n\t\t};\n\t\tstruct nand_operation op = NAND_OPERATION(chip->cur_cs, instrs);\n\n\t\tret = nand_exec_op(chip, &op);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = nand_status_op(chip, &status);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else {\n\t\tchip->legacy.cmdfunc(chip, NAND_CMD_PAGEPROG, -1, -1);\n\t\tret = chip->legacy.waitfunc(chip);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tstatus = ret;\n\t}\n\n\tif (status & NAND_STATUS_FAIL)\n\t\treturn -EIO;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(nand_prog_page_end_op);\n\n \nint nand_prog_page_op(struct nand_chip *chip, unsigned int page,\n\t\t      unsigned int offset_in_page, const void *buf,\n\t\t      unsigned int len)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tu8 status;\n\tint ret;\n\n\tif (!len || !buf)\n\t\treturn -EINVAL;\n\n\tif (offset_in_page + len > mtd->writesize + mtd->oobsize)\n\t\treturn -EINVAL;\n\n\tif (nand_has_exec_op(chip)) {\n\t\tret = nand_exec_prog_page_op(chip, page, offset_in_page, buf,\n\t\t\t\t\t\tlen, true);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = nand_status_op(chip, &status);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else {\n\t\tchip->legacy.cmdfunc(chip, NAND_CMD_SEQIN, offset_in_page,\n\t\t\t\t     page);\n\t\tchip->legacy.write_buf(chip, buf, len);\n\t\tchip->legacy.cmdfunc(chip, NAND_CMD_PAGEPROG, -1, -1);\n\t\tret = chip->legacy.waitfunc(chip);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tstatus = ret;\n\t}\n\n\tif (status & NAND_STATUS_FAIL)\n\t\treturn -EIO;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(nand_prog_page_op);\n\n \nint nand_change_write_column_op(struct nand_chip *chip,\n\t\t\t\tunsigned int offset_in_page,\n\t\t\t\tconst void *buf, unsigned int len,\n\t\t\t\tbool force_8bit)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\n\tif (len && !buf)\n\t\treturn -EINVAL;\n\n\tif (offset_in_page + len > mtd->writesize + mtd->oobsize)\n\t\treturn -EINVAL;\n\n\t \n\tif (mtd->writesize <= 512)\n\t\treturn -ENOTSUPP;\n\n\tif (nand_has_exec_op(chip)) {\n\t\tconst struct nand_interface_config *conf =\n\t\t\tnand_get_interface_config(chip);\n\t\tu8 addrs[2];\n\t\tstruct nand_op_instr instrs[] = {\n\t\t\tNAND_OP_CMD(NAND_CMD_RNDIN, 0),\n\t\t\tNAND_OP_ADDR(2, addrs, NAND_COMMON_TIMING_NS(conf, tCCS_min)),\n\t\t\tNAND_OP_DATA_OUT(len, buf, 0),\n\t\t};\n\t\tstruct nand_operation op = NAND_OPERATION(chip->cur_cs, instrs);\n\t\tint ret;\n\n\t\tret = nand_fill_column_cycles(chip, addrs, offset_in_page);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tinstrs[2].ctx.data.force_8bit = force_8bit;\n\n\t\t \n\t\tif (!len)\n\t\t\top.ninstrs--;\n\n\t\treturn nand_exec_op(chip, &op);\n\t}\n\n\tchip->legacy.cmdfunc(chip, NAND_CMD_RNDIN, offset_in_page, -1);\n\tif (len)\n\t\tchip->legacy.write_buf(chip, buf, len);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(nand_change_write_column_op);\n\n \nint nand_readid_op(struct nand_chip *chip, u8 addr, void *buf,\n\t\t   unsigned int len)\n{\n\tunsigned int i;\n\tu8 *id = buf, *ddrbuf = NULL;\n\n\tif (len && !buf)\n\t\treturn -EINVAL;\n\n\tif (nand_has_exec_op(chip)) {\n\t\tconst struct nand_interface_config *conf =\n\t\t\tnand_get_interface_config(chip);\n\t\tstruct nand_op_instr instrs[] = {\n\t\t\tNAND_OP_CMD(NAND_CMD_READID, 0),\n\t\t\tNAND_OP_ADDR(1, &addr,\n\t\t\t\t     NAND_COMMON_TIMING_NS(conf, tADL_min)),\n\t\t\tNAND_OP_8BIT_DATA_IN(len, buf, 0),\n\t\t};\n\t\tstruct nand_operation op = NAND_OPERATION(chip->cur_cs, instrs);\n\t\tint ret;\n\n\t\t \n\t\tif (len && nand_interface_is_nvddr(conf)) {\n\t\t\tddrbuf = kzalloc(len * 2, GFP_KERNEL);\n\t\t\tif (!ddrbuf)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tinstrs[2].ctx.data.len *= 2;\n\t\t\tinstrs[2].ctx.data.buf.in = ddrbuf;\n\t\t}\n\n\t\t \n\t\tif (!len)\n\t\t\top.ninstrs--;\n\n\t\tret = nand_exec_op(chip, &op);\n\t\tif (!ret && len && nand_interface_is_nvddr(conf)) {\n\t\t\tfor (i = 0; i < len; i++)\n\t\t\t\tid[i] = ddrbuf[i * 2];\n\t\t}\n\n\t\tkfree(ddrbuf);\n\n\t\treturn ret;\n\t}\n\n\tchip->legacy.cmdfunc(chip, NAND_CMD_READID, addr, -1);\n\n\tfor (i = 0; i < len; i++)\n\t\tid[i] = chip->legacy.read_byte(chip);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(nand_readid_op);\n\n \nint nand_status_op(struct nand_chip *chip, u8 *status)\n{\n\tif (nand_has_exec_op(chip)) {\n\t\tconst struct nand_interface_config *conf =\n\t\t\tnand_get_interface_config(chip);\n\t\tu8 ddrstatus[2];\n\t\tstruct nand_op_instr instrs[] = {\n\t\t\tNAND_OP_CMD(NAND_CMD_STATUS,\n\t\t\t\t    NAND_COMMON_TIMING_NS(conf, tADL_min)),\n\t\t\tNAND_OP_8BIT_DATA_IN(1, status, 0),\n\t\t};\n\t\tstruct nand_operation op = NAND_OPERATION(chip->cur_cs, instrs);\n\t\tint ret;\n\n\t\t \n\t\tif (status && nand_interface_is_nvddr(conf)) {\n\t\t\tinstrs[1].ctx.data.len *= 2;\n\t\t\tinstrs[1].ctx.data.buf.in = ddrstatus;\n\t\t}\n\n\t\tif (!status)\n\t\t\top.ninstrs--;\n\n\t\tret = nand_exec_op(chip, &op);\n\t\tif (!ret && status && nand_interface_is_nvddr(conf))\n\t\t\t*status = ddrstatus[0];\n\n\t\treturn ret;\n\t}\n\n\tchip->legacy.cmdfunc(chip, NAND_CMD_STATUS, -1, -1);\n\tif (status)\n\t\t*status = chip->legacy.read_byte(chip);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(nand_status_op);\n\n \nint nand_exit_status_op(struct nand_chip *chip)\n{\n\tif (nand_has_exec_op(chip)) {\n\t\tstruct nand_op_instr instrs[] = {\n\t\t\tNAND_OP_CMD(NAND_CMD_READ0, 0),\n\t\t};\n\t\tstruct nand_operation op = NAND_OPERATION(chip->cur_cs, instrs);\n\n\t\treturn nand_exec_op(chip, &op);\n\t}\n\n\tchip->legacy.cmdfunc(chip, NAND_CMD_READ0, -1, -1);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(nand_exit_status_op);\n\n \nint nand_erase_op(struct nand_chip *chip, unsigned int eraseblock)\n{\n\tunsigned int page = eraseblock <<\n\t\t\t    (chip->phys_erase_shift - chip->page_shift);\n\tint ret;\n\tu8 status;\n\n\tif (nand_has_exec_op(chip)) {\n\t\tconst struct nand_interface_config *conf =\n\t\t\tnand_get_interface_config(chip);\n\t\tu8 addrs[3] = {\tpage, page >> 8, page >> 16 };\n\t\tstruct nand_op_instr instrs[] = {\n\t\t\tNAND_OP_CMD(NAND_CMD_ERASE1, 0),\n\t\t\tNAND_OP_ADDR(2, addrs, 0),\n\t\t\tNAND_OP_CMD(NAND_CMD_ERASE2,\n\t\t\t\t    NAND_COMMON_TIMING_NS(conf, tWB_max)),\n\t\t\tNAND_OP_WAIT_RDY(NAND_COMMON_TIMING_MS(conf, tBERS_max),\n\t\t\t\t\t 0),\n\t\t};\n\t\tstruct nand_operation op = NAND_OPERATION(chip->cur_cs, instrs);\n\n\t\tif (chip->options & NAND_ROW_ADDR_3)\n\t\t\tinstrs[1].ctx.addr.naddrs++;\n\n\t\tret = nand_exec_op(chip, &op);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = nand_status_op(chip, &status);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else {\n\t\tchip->legacy.cmdfunc(chip, NAND_CMD_ERASE1, -1, page);\n\t\tchip->legacy.cmdfunc(chip, NAND_CMD_ERASE2, -1, -1);\n\n\t\tret = chip->legacy.waitfunc(chip);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tstatus = ret;\n\t}\n\n\tif (status & NAND_STATUS_FAIL)\n\t\treturn -EIO;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(nand_erase_op);\n\n \nstatic int nand_set_features_op(struct nand_chip *chip, u8 feature,\n\t\t\t\tconst void *data)\n{\n\tconst u8 *params = data;\n\tint i, ret;\n\n\tif (nand_has_exec_op(chip)) {\n\t\tconst struct nand_interface_config *conf =\n\t\t\tnand_get_interface_config(chip);\n\t\tstruct nand_op_instr instrs[] = {\n\t\t\tNAND_OP_CMD(NAND_CMD_SET_FEATURES, 0),\n\t\t\tNAND_OP_ADDR(1, &feature, NAND_COMMON_TIMING_NS(conf,\n\t\t\t\t\t\t\t\t\ttADL_min)),\n\t\t\tNAND_OP_8BIT_DATA_OUT(ONFI_SUBFEATURE_PARAM_LEN, data,\n\t\t\t\t\t      NAND_COMMON_TIMING_NS(conf,\n\t\t\t\t\t\t\t\t    tWB_max)),\n\t\t\tNAND_OP_WAIT_RDY(NAND_COMMON_TIMING_MS(conf, tFEAT_max),\n\t\t\t\t\t 0),\n\t\t};\n\t\tstruct nand_operation op = NAND_OPERATION(chip->cur_cs, instrs);\n\n\t\treturn nand_exec_op(chip, &op);\n\t}\n\n\tchip->legacy.cmdfunc(chip, NAND_CMD_SET_FEATURES, feature, -1);\n\tfor (i = 0; i < ONFI_SUBFEATURE_PARAM_LEN; ++i)\n\t\tchip->legacy.write_byte(chip, params[i]);\n\n\tret = chip->legacy.waitfunc(chip);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (ret & NAND_STATUS_FAIL)\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\n \nstatic int nand_get_features_op(struct nand_chip *chip, u8 feature,\n\t\t\t\tvoid *data)\n{\n\tu8 *params = data, ddrbuf[ONFI_SUBFEATURE_PARAM_LEN * 2];\n\tint i;\n\n\tif (nand_has_exec_op(chip)) {\n\t\tconst struct nand_interface_config *conf =\n\t\t\tnand_get_interface_config(chip);\n\t\tstruct nand_op_instr instrs[] = {\n\t\t\tNAND_OP_CMD(NAND_CMD_GET_FEATURES, 0),\n\t\t\tNAND_OP_ADDR(1, &feature,\n\t\t\t\t     NAND_COMMON_TIMING_NS(conf, tWB_max)),\n\t\t\tNAND_OP_WAIT_RDY(NAND_COMMON_TIMING_MS(conf, tFEAT_max),\n\t\t\t\t\t NAND_COMMON_TIMING_NS(conf, tRR_min)),\n\t\t\tNAND_OP_8BIT_DATA_IN(ONFI_SUBFEATURE_PARAM_LEN,\n\t\t\t\t\t     data, 0),\n\t\t};\n\t\tstruct nand_operation op = NAND_OPERATION(chip->cur_cs, instrs);\n\t\tint ret;\n\n\t\t \n\t\tif (nand_interface_is_nvddr(conf)) {\n\t\t\tinstrs[3].ctx.data.len *= 2;\n\t\t\tinstrs[3].ctx.data.buf.in = ddrbuf;\n\t\t}\n\n\t\tret = nand_exec_op(chip, &op);\n\t\tif (nand_interface_is_nvddr(conf)) {\n\t\t\tfor (i = 0; i < ONFI_SUBFEATURE_PARAM_LEN; i++)\n\t\t\t\tparams[i] = ddrbuf[i * 2];\n\t\t}\n\n\t\treturn ret;\n\t}\n\n\tchip->legacy.cmdfunc(chip, NAND_CMD_GET_FEATURES, feature, -1);\n\tfor (i = 0; i < ONFI_SUBFEATURE_PARAM_LEN; ++i)\n\t\tparams[i] = chip->legacy.read_byte(chip);\n\n\treturn 0;\n}\n\nstatic int nand_wait_rdy_op(struct nand_chip *chip, unsigned int timeout_ms,\n\t\t\t    unsigned int delay_ns)\n{\n\tif (nand_has_exec_op(chip)) {\n\t\tstruct nand_op_instr instrs[] = {\n\t\t\tNAND_OP_WAIT_RDY(PSEC_TO_MSEC(timeout_ms),\n\t\t\t\t\t PSEC_TO_NSEC(delay_ns)),\n\t\t};\n\t\tstruct nand_operation op = NAND_OPERATION(chip->cur_cs, instrs);\n\n\t\treturn nand_exec_op(chip, &op);\n\t}\n\n\t \n\tif (!chip->legacy.dev_ready)\n\t\tudelay(chip->legacy.chip_delay);\n\telse\n\t\tnand_wait_ready(chip);\n\n\treturn 0;\n}\n\n \nint nand_reset_op(struct nand_chip *chip)\n{\n\tif (nand_has_exec_op(chip)) {\n\t\tconst struct nand_interface_config *conf =\n\t\t\tnand_get_interface_config(chip);\n\t\tstruct nand_op_instr instrs[] = {\n\t\t\tNAND_OP_CMD(NAND_CMD_RESET,\n\t\t\t\t    NAND_COMMON_TIMING_NS(conf, tWB_max)),\n\t\t\tNAND_OP_WAIT_RDY(NAND_COMMON_TIMING_MS(conf, tRST_max),\n\t\t\t\t\t 0),\n\t\t};\n\t\tstruct nand_operation op = NAND_OPERATION(chip->cur_cs, instrs);\n\n\t\treturn nand_exec_op(chip, &op);\n\t}\n\n\tchip->legacy.cmdfunc(chip, NAND_CMD_RESET, -1, -1);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(nand_reset_op);\n\n \nint nand_read_data_op(struct nand_chip *chip, void *buf, unsigned int len,\n\t\t      bool force_8bit, bool check_only)\n{\n\tif (!len || !buf)\n\t\treturn -EINVAL;\n\n\tif (nand_has_exec_op(chip)) {\n\t\tconst struct nand_interface_config *conf =\n\t\t\tnand_get_interface_config(chip);\n\t\tstruct nand_op_instr instrs[] = {\n\t\t\tNAND_OP_DATA_IN(len, buf, 0),\n\t\t};\n\t\tstruct nand_operation op = NAND_OPERATION(chip->cur_cs, instrs);\n\t\tu8 *ddrbuf = NULL;\n\t\tint ret, i;\n\n\t\tinstrs[0].ctx.data.force_8bit = force_8bit;\n\n\t\t \n\t\tif (force_8bit && nand_interface_is_nvddr(conf)) {\n\t\t\tddrbuf = kzalloc(len * 2, GFP_KERNEL);\n\t\t\tif (!ddrbuf)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tinstrs[0].ctx.data.len *= 2;\n\t\t\tinstrs[0].ctx.data.buf.in = ddrbuf;\n\t\t}\n\n\t\tif (check_only) {\n\t\t\tret = nand_check_op(chip, &op);\n\t\t\tkfree(ddrbuf);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = nand_exec_op(chip, &op);\n\t\tif (!ret && force_8bit && nand_interface_is_nvddr(conf)) {\n\t\t\tu8 *dst = buf;\n\n\t\t\tfor (i = 0; i < len; i++)\n\t\t\t\tdst[i] = ddrbuf[i * 2];\n\t\t}\n\n\t\tkfree(ddrbuf);\n\n\t\treturn ret;\n\t}\n\n\tif (check_only)\n\t\treturn 0;\n\n\tif (force_8bit) {\n\t\tu8 *p = buf;\n\t\tunsigned int i;\n\n\t\tfor (i = 0; i < len; i++)\n\t\t\tp[i] = chip->legacy.read_byte(chip);\n\t} else {\n\t\tchip->legacy.read_buf(chip, buf, len);\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(nand_read_data_op);\n\n \nint nand_write_data_op(struct nand_chip *chip, const void *buf,\n\t\t       unsigned int len, bool force_8bit)\n{\n\tif (!len || !buf)\n\t\treturn -EINVAL;\n\n\tif (nand_has_exec_op(chip)) {\n\t\tstruct nand_op_instr instrs[] = {\n\t\t\tNAND_OP_DATA_OUT(len, buf, 0),\n\t\t};\n\t\tstruct nand_operation op = NAND_OPERATION(chip->cur_cs, instrs);\n\n\t\tinstrs[0].ctx.data.force_8bit = force_8bit;\n\n\t\treturn nand_exec_op(chip, &op);\n\t}\n\n\tif (force_8bit) {\n\t\tconst u8 *p = buf;\n\t\tunsigned int i;\n\n\t\tfor (i = 0; i < len; i++)\n\t\t\tchip->legacy.write_byte(chip, p[i]);\n\t} else {\n\t\tchip->legacy.write_buf(chip, buf, len);\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(nand_write_data_op);\n\n \nstruct nand_op_parser_ctx {\n\tconst struct nand_op_instr *instrs;\n\tunsigned int ninstrs;\n\tstruct nand_subop subop;\n};\n\n \nstatic bool\nnand_op_parser_must_split_instr(const struct nand_op_parser_pattern_elem *pat,\n\t\t\t\tconst struct nand_op_instr *instr,\n\t\t\t\tunsigned int *start_offset)\n{\n\tswitch (pat->type) {\n\tcase NAND_OP_ADDR_INSTR:\n\t\tif (!pat->ctx.addr.maxcycles)\n\t\t\tbreak;\n\n\t\tif (instr->ctx.addr.naddrs - *start_offset >\n\t\t    pat->ctx.addr.maxcycles) {\n\t\t\t*start_offset += pat->ctx.addr.maxcycles;\n\t\t\treturn true;\n\t\t}\n\t\tbreak;\n\n\tcase NAND_OP_DATA_IN_INSTR:\n\tcase NAND_OP_DATA_OUT_INSTR:\n\t\tif (!pat->ctx.data.maxlen)\n\t\t\tbreak;\n\n\t\tif (instr->ctx.data.len - *start_offset >\n\t\t    pat->ctx.data.maxlen) {\n\t\t\t*start_offset += pat->ctx.data.maxlen;\n\t\t\treturn true;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn false;\n}\n\n \nstatic bool\nnand_op_parser_match_pat(const struct nand_op_parser_pattern *pat,\n\t\t\t struct nand_op_parser_ctx *ctx)\n{\n\tunsigned int instr_offset = ctx->subop.first_instr_start_off;\n\tconst struct nand_op_instr *end = ctx->instrs + ctx->ninstrs;\n\tconst struct nand_op_instr *instr = ctx->subop.instrs;\n\tunsigned int i, ninstrs;\n\n\tfor (i = 0, ninstrs = 0; i < pat->nelems && instr < end; i++) {\n\t\t \n\t\tif (instr->type != pat->elems[i].type) {\n\t\t\tif (!pat->elems[i].optional)\n\t\t\t\treturn false;\n\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (nand_op_parser_must_split_instr(&pat->elems[i], instr,\n\t\t\t\t\t\t    &instr_offset)) {\n\t\t\tninstrs++;\n\t\t\ti++;\n\t\t\tbreak;\n\t\t}\n\n\t\tinstr++;\n\t\tninstrs++;\n\t\tinstr_offset = 0;\n\t}\n\n\t \n\tif (!ninstrs)\n\t\treturn false;\n\n\t \n\tfor (; i < pat->nelems; i++) {\n\t\tif (!pat->elems[i].optional)\n\t\t\treturn false;\n\t}\n\n\t \n\tctx->subop.ninstrs = ninstrs;\n\tctx->subop.last_instr_end_off = instr_offset;\n\n\treturn true;\n}\n\n#if IS_ENABLED(CONFIG_DYNAMIC_DEBUG) || defined(DEBUG)\nstatic void nand_op_parser_trace(const struct nand_op_parser_ctx *ctx)\n{\n\tconst struct nand_op_instr *instr;\n\tchar *prefix = \"      \";\n\tunsigned int i;\n\n\tpr_debug(\"executing subop (CS%d):\\n\", ctx->subop.cs);\n\n\tfor (i = 0; i < ctx->ninstrs; i++) {\n\t\tinstr = &ctx->instrs[i];\n\n\t\tif (instr == &ctx->subop.instrs[0])\n\t\t\tprefix = \"    ->\";\n\n\t\tnand_op_trace(prefix, instr);\n\n\t\tif (instr == &ctx->subop.instrs[ctx->subop.ninstrs - 1])\n\t\t\tprefix = \"      \";\n\t}\n}\n#else\nstatic void nand_op_parser_trace(const struct nand_op_parser_ctx *ctx)\n{\n\t \n}\n#endif\n\nstatic int nand_op_parser_cmp_ctx(const struct nand_op_parser_ctx *a,\n\t\t\t\t  const struct nand_op_parser_ctx *b)\n{\n\tif (a->subop.ninstrs < b->subop.ninstrs)\n\t\treturn -1;\n\telse if (a->subop.ninstrs > b->subop.ninstrs)\n\t\treturn 1;\n\n\tif (a->subop.last_instr_end_off < b->subop.last_instr_end_off)\n\t\treturn -1;\n\telse if (a->subop.last_instr_end_off > b->subop.last_instr_end_off)\n\t\treturn 1;\n\n\treturn 0;\n}\n\n \nint nand_op_parser_exec_op(struct nand_chip *chip,\n\t\t\t   const struct nand_op_parser *parser,\n\t\t\t   const struct nand_operation *op, bool check_only)\n{\n\tstruct nand_op_parser_ctx ctx = {\n\t\t.subop.cs = op->cs,\n\t\t.subop.instrs = op->instrs,\n\t\t.instrs = op->instrs,\n\t\t.ninstrs = op->ninstrs,\n\t};\n\tunsigned int i;\n\n\twhile (ctx.subop.instrs < op->instrs + op->ninstrs) {\n\t\tconst struct nand_op_parser_pattern *pattern;\n\t\tstruct nand_op_parser_ctx best_ctx;\n\t\tint ret, best_pattern = -1;\n\n\t\tfor (i = 0; i < parser->npatterns; i++) {\n\t\t\tstruct nand_op_parser_ctx test_ctx = ctx;\n\n\t\t\tpattern = &parser->patterns[i];\n\t\t\tif (!nand_op_parser_match_pat(pattern, &test_ctx))\n\t\t\t\tcontinue;\n\n\t\t\tif (best_pattern >= 0 &&\n\t\t\t    nand_op_parser_cmp_ctx(&test_ctx, &best_ctx) <= 0)\n\t\t\t\tcontinue;\n\n\t\t\tbest_pattern = i;\n\t\t\tbest_ctx = test_ctx;\n\t\t}\n\n\t\tif (best_pattern < 0) {\n\t\t\tpr_debug(\"->exec_op() parser: pattern not found!\\n\");\n\t\t\treturn -ENOTSUPP;\n\t\t}\n\n\t\tctx = best_ctx;\n\t\tnand_op_parser_trace(&ctx);\n\n\t\tif (!check_only) {\n\t\t\tpattern = &parser->patterns[best_pattern];\n\t\t\tret = pattern->exec(chip, &ctx.subop);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\n\t\t \n\t\tctx.subop.instrs = ctx.subop.instrs + ctx.subop.ninstrs;\n\t\tif (ctx.subop.last_instr_end_off)\n\t\t\tctx.subop.instrs -= 1;\n\n\t\tctx.subop.first_instr_start_off = ctx.subop.last_instr_end_off;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(nand_op_parser_exec_op);\n\nstatic bool nand_instr_is_data(const struct nand_op_instr *instr)\n{\n\treturn instr && (instr->type == NAND_OP_DATA_IN_INSTR ||\n\t\t\t instr->type == NAND_OP_DATA_OUT_INSTR);\n}\n\nstatic bool nand_subop_instr_is_valid(const struct nand_subop *subop,\n\t\t\t\t      unsigned int instr_idx)\n{\n\treturn subop && instr_idx < subop->ninstrs;\n}\n\nstatic unsigned int nand_subop_get_start_off(const struct nand_subop *subop,\n\t\t\t\t\t     unsigned int instr_idx)\n{\n\tif (instr_idx)\n\t\treturn 0;\n\n\treturn subop->first_instr_start_off;\n}\n\n \nunsigned int nand_subop_get_addr_start_off(const struct nand_subop *subop,\n\t\t\t\t\t   unsigned int instr_idx)\n{\n\tif (WARN_ON(!nand_subop_instr_is_valid(subop, instr_idx) ||\n\t\t    subop->instrs[instr_idx].type != NAND_OP_ADDR_INSTR))\n\t\treturn 0;\n\n\treturn nand_subop_get_start_off(subop, instr_idx);\n}\nEXPORT_SYMBOL_GPL(nand_subop_get_addr_start_off);\n\n \nunsigned int nand_subop_get_num_addr_cyc(const struct nand_subop *subop,\n\t\t\t\t\t unsigned int instr_idx)\n{\n\tint start_off, end_off;\n\n\tif (WARN_ON(!nand_subop_instr_is_valid(subop, instr_idx) ||\n\t\t    subop->instrs[instr_idx].type != NAND_OP_ADDR_INSTR))\n\t\treturn 0;\n\n\tstart_off = nand_subop_get_addr_start_off(subop, instr_idx);\n\n\tif (instr_idx == subop->ninstrs - 1 &&\n\t    subop->last_instr_end_off)\n\t\tend_off = subop->last_instr_end_off;\n\telse\n\t\tend_off = subop->instrs[instr_idx].ctx.addr.naddrs;\n\n\treturn end_off - start_off;\n}\nEXPORT_SYMBOL_GPL(nand_subop_get_num_addr_cyc);\n\n \nunsigned int nand_subop_get_data_start_off(const struct nand_subop *subop,\n\t\t\t\t\t   unsigned int instr_idx)\n{\n\tif (WARN_ON(!nand_subop_instr_is_valid(subop, instr_idx) ||\n\t\t    !nand_instr_is_data(&subop->instrs[instr_idx])))\n\t\treturn 0;\n\n\treturn nand_subop_get_start_off(subop, instr_idx);\n}\nEXPORT_SYMBOL_GPL(nand_subop_get_data_start_off);\n\n \nunsigned int nand_subop_get_data_len(const struct nand_subop *subop,\n\t\t\t\t     unsigned int instr_idx)\n{\n\tint start_off = 0, end_off;\n\n\tif (WARN_ON(!nand_subop_instr_is_valid(subop, instr_idx) ||\n\t\t    !nand_instr_is_data(&subop->instrs[instr_idx])))\n\t\treturn 0;\n\n\tstart_off = nand_subop_get_data_start_off(subop, instr_idx);\n\n\tif (instr_idx == subop->ninstrs - 1 &&\n\t    subop->last_instr_end_off)\n\t\tend_off = subop->last_instr_end_off;\n\telse\n\t\tend_off = subop->instrs[instr_idx].ctx.data.len;\n\n\treturn end_off - start_off;\n}\nEXPORT_SYMBOL_GPL(nand_subop_get_data_len);\n\n \nint nand_reset(struct nand_chip *chip, int chipnr)\n{\n\tint ret;\n\n\tret = nand_reset_interface(chip, chipnr);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tnand_select_target(chip, chipnr);\n\tret = nand_reset_op(chip);\n\tnand_deselect_target(chip);\n\tif (ret)\n\t\treturn ret;\n\n\tret = nand_setup_interface(chip, chipnr);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(nand_reset);\n\n \nint nand_get_features(struct nand_chip *chip, int addr,\n\t\t      u8 *subfeature_param)\n{\n\tif (!nand_supports_get_features(chip, addr))\n\t\treturn -ENOTSUPP;\n\n\tif (chip->legacy.get_features)\n\t\treturn chip->legacy.get_features(chip, addr, subfeature_param);\n\n\treturn nand_get_features_op(chip, addr, subfeature_param);\n}\n\n \nint nand_set_features(struct nand_chip *chip, int addr,\n\t\t      u8 *subfeature_param)\n{\n\tif (!nand_supports_set_features(chip, addr))\n\t\treturn -ENOTSUPP;\n\n\tif (chip->legacy.set_features)\n\t\treturn chip->legacy.set_features(chip, addr, subfeature_param);\n\n\treturn nand_set_features_op(chip, addr, subfeature_param);\n}\n\n \nstatic int nand_check_erased_buf(void *buf, int len, int bitflips_threshold)\n{\n\tconst unsigned char *bitmap = buf;\n\tint bitflips = 0;\n\tint weight;\n\n\tfor (; len && ((uintptr_t)bitmap) % sizeof(long);\n\t     len--, bitmap++) {\n\t\tweight = hweight8(*bitmap);\n\t\tbitflips += BITS_PER_BYTE - weight;\n\t\tif (unlikely(bitflips > bitflips_threshold))\n\t\t\treturn -EBADMSG;\n\t}\n\n\tfor (; len >= sizeof(long);\n\t     len -= sizeof(long), bitmap += sizeof(long)) {\n\t\tunsigned long d = *((unsigned long *)bitmap);\n\t\tif (d == ~0UL)\n\t\t\tcontinue;\n\t\tweight = hweight_long(d);\n\t\tbitflips += BITS_PER_LONG - weight;\n\t\tif (unlikely(bitflips > bitflips_threshold))\n\t\t\treturn -EBADMSG;\n\t}\n\n\tfor (; len > 0; len--, bitmap++) {\n\t\tweight = hweight8(*bitmap);\n\t\tbitflips += BITS_PER_BYTE - weight;\n\t\tif (unlikely(bitflips > bitflips_threshold))\n\t\t\treturn -EBADMSG;\n\t}\n\n\treturn bitflips;\n}\n\n \nint nand_check_erased_ecc_chunk(void *data, int datalen,\n\t\t\t\tvoid *ecc, int ecclen,\n\t\t\t\tvoid *extraoob, int extraooblen,\n\t\t\t\tint bitflips_threshold)\n{\n\tint data_bitflips = 0, ecc_bitflips = 0, extraoob_bitflips = 0;\n\n\tdata_bitflips = nand_check_erased_buf(data, datalen,\n\t\t\t\t\t      bitflips_threshold);\n\tif (data_bitflips < 0)\n\t\treturn data_bitflips;\n\n\tbitflips_threshold -= data_bitflips;\n\n\tecc_bitflips = nand_check_erased_buf(ecc, ecclen, bitflips_threshold);\n\tif (ecc_bitflips < 0)\n\t\treturn ecc_bitflips;\n\n\tbitflips_threshold -= ecc_bitflips;\n\n\textraoob_bitflips = nand_check_erased_buf(extraoob, extraooblen,\n\t\t\t\t\t\t  bitflips_threshold);\n\tif (extraoob_bitflips < 0)\n\t\treturn extraoob_bitflips;\n\n\tif (data_bitflips)\n\t\tmemset(data, 0xff, datalen);\n\n\tif (ecc_bitflips)\n\t\tmemset(ecc, 0xff, ecclen);\n\n\tif (extraoob_bitflips)\n\t\tmemset(extraoob, 0xff, extraooblen);\n\n\treturn data_bitflips + ecc_bitflips + extraoob_bitflips;\n}\nEXPORT_SYMBOL(nand_check_erased_ecc_chunk);\n\n \nint nand_read_page_raw_notsupp(struct nand_chip *chip, u8 *buf,\n\t\t\t       int oob_required, int page)\n{\n\treturn -ENOTSUPP;\n}\n\n \nint nand_read_page_raw(struct nand_chip *chip, uint8_t *buf, int oob_required,\n\t\t       int page)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tint ret;\n\n\tret = nand_read_page_op(chip, page, 0, buf, mtd->writesize);\n\tif (ret)\n\t\treturn ret;\n\n\tif (oob_required) {\n\t\tret = nand_read_data_op(chip, chip->oob_poi, mtd->oobsize,\n\t\t\t\t\tfalse, false);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(nand_read_page_raw);\n\n \nint nand_monolithic_read_page_raw(struct nand_chip *chip, u8 *buf,\n\t\t\t\t  int oob_required, int page)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tunsigned int size = mtd->writesize;\n\tu8 *read_buf = buf;\n\tint ret;\n\n\tif (oob_required) {\n\t\tsize += mtd->oobsize;\n\n\t\tif (buf != chip->data_buf)\n\t\t\tread_buf = nand_get_data_buf(chip);\n\t}\n\n\tret = nand_read_page_op(chip, page, 0, read_buf, size);\n\tif (ret)\n\t\treturn ret;\n\n\tif (buf != chip->data_buf)\n\t\tmemcpy(buf, read_buf, mtd->writesize);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(nand_monolithic_read_page_raw);\n\n \nstatic int nand_read_page_raw_syndrome(struct nand_chip *chip, uint8_t *buf,\n\t\t\t\t       int oob_required, int page)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tint eccsize = chip->ecc.size;\n\tint eccbytes = chip->ecc.bytes;\n\tuint8_t *oob = chip->oob_poi;\n\tint steps, size, ret;\n\n\tret = nand_read_page_op(chip, page, 0, NULL, 0);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (steps = chip->ecc.steps; steps > 0; steps--) {\n\t\tret = nand_read_data_op(chip, buf, eccsize, false, false);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tbuf += eccsize;\n\n\t\tif (chip->ecc.prepad) {\n\t\t\tret = nand_read_data_op(chip, oob, chip->ecc.prepad,\n\t\t\t\t\t\tfalse, false);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\toob += chip->ecc.prepad;\n\t\t}\n\n\t\tret = nand_read_data_op(chip, oob, eccbytes, false, false);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\toob += eccbytes;\n\n\t\tif (chip->ecc.postpad) {\n\t\t\tret = nand_read_data_op(chip, oob, chip->ecc.postpad,\n\t\t\t\t\t\tfalse, false);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\toob += chip->ecc.postpad;\n\t\t}\n\t}\n\n\tsize = mtd->oobsize - (oob - chip->oob_poi);\n\tif (size) {\n\t\tret = nand_read_data_op(chip, oob, size, false, false);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int nand_read_page_swecc(struct nand_chip *chip, uint8_t *buf,\n\t\t\t\tint oob_required, int page)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tint i, eccsize = chip->ecc.size, ret;\n\tint eccbytes = chip->ecc.bytes;\n\tint eccsteps = chip->ecc.steps;\n\tuint8_t *p = buf;\n\tuint8_t *ecc_calc = chip->ecc.calc_buf;\n\tuint8_t *ecc_code = chip->ecc.code_buf;\n\tunsigned int max_bitflips = 0;\n\n\tchip->ecc.read_page_raw(chip, buf, 1, page);\n\n\tfor (i = 0; eccsteps; eccsteps--, i += eccbytes, p += eccsize)\n\t\tchip->ecc.calculate(chip, p, &ecc_calc[i]);\n\n\tret = mtd_ooblayout_get_eccbytes(mtd, ecc_code, chip->oob_poi, 0,\n\t\t\t\t\t chip->ecc.total);\n\tif (ret)\n\t\treturn ret;\n\n\teccsteps = chip->ecc.steps;\n\tp = buf;\n\n\tfor (i = 0 ; eccsteps; eccsteps--, i += eccbytes, p += eccsize) {\n\t\tint stat;\n\n\t\tstat = chip->ecc.correct(chip, p, &ecc_code[i], &ecc_calc[i]);\n\t\tif (stat < 0) {\n\t\t\tmtd->ecc_stats.failed++;\n\t\t} else {\n\t\t\tmtd->ecc_stats.corrected += stat;\n\t\t\tmax_bitflips = max_t(unsigned int, max_bitflips, stat);\n\t\t}\n\t}\n\treturn max_bitflips;\n}\n\n \nstatic int nand_read_subpage(struct nand_chip *chip, uint32_t data_offs,\n\t\t\t     uint32_t readlen, uint8_t *bufpoi, int page)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tint start_step, end_step, num_steps, ret;\n\tuint8_t *p;\n\tint data_col_addr, i, gaps = 0;\n\tint datafrag_len, eccfrag_len, aligned_len, aligned_pos;\n\tint busw = (chip->options & NAND_BUSWIDTH_16) ? 2 : 1;\n\tint index, section = 0;\n\tunsigned int max_bitflips = 0;\n\tstruct mtd_oob_region oobregion = { };\n\n\t \n\tstart_step = data_offs / chip->ecc.size;\n\tend_step = (data_offs + readlen - 1) / chip->ecc.size;\n\tnum_steps = end_step - start_step + 1;\n\tindex = start_step * chip->ecc.bytes;\n\n\t \n\tdatafrag_len = num_steps * chip->ecc.size;\n\teccfrag_len = num_steps * chip->ecc.bytes;\n\n\tdata_col_addr = start_step * chip->ecc.size;\n\t \n\tp = bufpoi + data_col_addr;\n\tret = nand_read_page_op(chip, page, data_col_addr, p, datafrag_len);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tfor (i = 0; i < eccfrag_len ; i += chip->ecc.bytes, p += chip->ecc.size)\n\t\tchip->ecc.calculate(chip, p, &chip->ecc.calc_buf[i]);\n\n\t \n\tret = mtd_ooblayout_find_eccregion(mtd, index, &section, &oobregion);\n\tif (ret)\n\t\treturn ret;\n\n\tif (oobregion.length < eccfrag_len)\n\t\tgaps = 1;\n\n\tif (gaps) {\n\t\tret = nand_change_read_column_op(chip, mtd->writesize,\n\t\t\t\t\t\t chip->oob_poi, mtd->oobsize,\n\t\t\t\t\t\t false);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else {\n\t\t \n\t\taligned_pos = oobregion.offset & ~(busw - 1);\n\t\taligned_len = eccfrag_len;\n\t\tif (oobregion.offset & (busw - 1))\n\t\t\taligned_len++;\n\t\tif ((oobregion.offset + (num_steps * chip->ecc.bytes)) &\n\t\t    (busw - 1))\n\t\t\taligned_len++;\n\n\t\tret = nand_change_read_column_op(chip,\n\t\t\t\t\t\t mtd->writesize + aligned_pos,\n\t\t\t\t\t\t &chip->oob_poi[aligned_pos],\n\t\t\t\t\t\t aligned_len, false);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = mtd_ooblayout_get_eccbytes(mtd, chip->ecc.code_buf,\n\t\t\t\t\t chip->oob_poi, index, eccfrag_len);\n\tif (ret)\n\t\treturn ret;\n\n\tp = bufpoi + data_col_addr;\n\tfor (i = 0; i < eccfrag_len ; i += chip->ecc.bytes, p += chip->ecc.size) {\n\t\tint stat;\n\n\t\tstat = chip->ecc.correct(chip, p, &chip->ecc.code_buf[i],\n\t\t\t\t\t &chip->ecc.calc_buf[i]);\n\t\tif (stat == -EBADMSG &&\n\t\t    (chip->ecc.options & NAND_ECC_GENERIC_ERASED_CHECK)) {\n\t\t\t \n\t\t\tstat = nand_check_erased_ecc_chunk(p, chip->ecc.size,\n\t\t\t\t\t\t&chip->ecc.code_buf[i],\n\t\t\t\t\t\tchip->ecc.bytes,\n\t\t\t\t\t\tNULL, 0,\n\t\t\t\t\t\tchip->ecc.strength);\n\t\t}\n\n\t\tif (stat < 0) {\n\t\t\tmtd->ecc_stats.failed++;\n\t\t} else {\n\t\t\tmtd->ecc_stats.corrected += stat;\n\t\t\tmax_bitflips = max_t(unsigned int, max_bitflips, stat);\n\t\t}\n\t}\n\treturn max_bitflips;\n}\n\n \nstatic int nand_read_page_hwecc(struct nand_chip *chip, uint8_t *buf,\n\t\t\t\tint oob_required, int page)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tint i, eccsize = chip->ecc.size, ret;\n\tint eccbytes = chip->ecc.bytes;\n\tint eccsteps = chip->ecc.steps;\n\tuint8_t *p = buf;\n\tuint8_t *ecc_calc = chip->ecc.calc_buf;\n\tuint8_t *ecc_code = chip->ecc.code_buf;\n\tunsigned int max_bitflips = 0;\n\n\tret = nand_read_page_op(chip, page, 0, NULL, 0);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; eccsteps; eccsteps--, i += eccbytes, p += eccsize) {\n\t\tchip->ecc.hwctl(chip, NAND_ECC_READ);\n\n\t\tret = nand_read_data_op(chip, p, eccsize, false, false);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tchip->ecc.calculate(chip, p, &ecc_calc[i]);\n\t}\n\n\tret = nand_read_data_op(chip, chip->oob_poi, mtd->oobsize, false,\n\t\t\t\tfalse);\n\tif (ret)\n\t\treturn ret;\n\n\tret = mtd_ooblayout_get_eccbytes(mtd, ecc_code, chip->oob_poi, 0,\n\t\t\t\t\t chip->ecc.total);\n\tif (ret)\n\t\treturn ret;\n\n\teccsteps = chip->ecc.steps;\n\tp = buf;\n\n\tfor (i = 0 ; eccsteps; eccsteps--, i += eccbytes, p += eccsize) {\n\t\tint stat;\n\n\t\tstat = chip->ecc.correct(chip, p, &ecc_code[i], &ecc_calc[i]);\n\t\tif (stat == -EBADMSG &&\n\t\t    (chip->ecc.options & NAND_ECC_GENERIC_ERASED_CHECK)) {\n\t\t\t \n\t\t\tstat = nand_check_erased_ecc_chunk(p, eccsize,\n\t\t\t\t\t\t&ecc_code[i], eccbytes,\n\t\t\t\t\t\tNULL, 0,\n\t\t\t\t\t\tchip->ecc.strength);\n\t\t}\n\n\t\tif (stat < 0) {\n\t\t\tmtd->ecc_stats.failed++;\n\t\t} else {\n\t\t\tmtd->ecc_stats.corrected += stat;\n\t\t\tmax_bitflips = max_t(unsigned int, max_bitflips, stat);\n\t\t}\n\t}\n\treturn max_bitflips;\n}\n\n \nint nand_read_page_hwecc_oob_first(struct nand_chip *chip, uint8_t *buf,\n\t\t\t\t   int oob_required, int page)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tint i, eccsize = chip->ecc.size, ret;\n\tint eccbytes = chip->ecc.bytes;\n\tint eccsteps = chip->ecc.steps;\n\tuint8_t *p = buf;\n\tuint8_t *ecc_code = chip->ecc.code_buf;\n\tunsigned int max_bitflips = 0;\n\n\t \n\tret = nand_read_oob_op(chip, page, 0, chip->oob_poi, mtd->oobsize);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = nand_change_read_column_op(chip, 0, NULL, 0, false);\n\tif (ret)\n\t\treturn ret;\n\n\tret = mtd_ooblayout_get_eccbytes(mtd, ecc_code, chip->oob_poi, 0,\n\t\t\t\t\t chip->ecc.total);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; eccsteps; eccsteps--, i += eccbytes, p += eccsize) {\n\t\tint stat;\n\n\t\tchip->ecc.hwctl(chip, NAND_ECC_READ);\n\n\t\tret = nand_read_data_op(chip, p, eccsize, false, false);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tstat = chip->ecc.correct(chip, p, &ecc_code[i], NULL);\n\t\tif (stat == -EBADMSG &&\n\t\t    (chip->ecc.options & NAND_ECC_GENERIC_ERASED_CHECK)) {\n\t\t\t \n\t\t\tstat = nand_check_erased_ecc_chunk(p, eccsize,\n\t\t\t\t\t\t\t   &ecc_code[i],\n\t\t\t\t\t\t\t   eccbytes, NULL, 0,\n\t\t\t\t\t\t\t   chip->ecc.strength);\n\t\t}\n\n\t\tif (stat < 0) {\n\t\t\tmtd->ecc_stats.failed++;\n\t\t} else {\n\t\t\tmtd->ecc_stats.corrected += stat;\n\t\t\tmax_bitflips = max_t(unsigned int, max_bitflips, stat);\n\t\t}\n\t}\n\treturn max_bitflips;\n}\nEXPORT_SYMBOL_GPL(nand_read_page_hwecc_oob_first);\n\n \nstatic int nand_read_page_syndrome(struct nand_chip *chip, uint8_t *buf,\n\t\t\t\t   int oob_required, int page)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tint ret, i, eccsize = chip->ecc.size;\n\tint eccbytes = chip->ecc.bytes;\n\tint eccsteps = chip->ecc.steps;\n\tint eccpadbytes = eccbytes + chip->ecc.prepad + chip->ecc.postpad;\n\tuint8_t *p = buf;\n\tuint8_t *oob = chip->oob_poi;\n\tunsigned int max_bitflips = 0;\n\n\tret = nand_read_page_op(chip, page, 0, NULL, 0);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; eccsteps; eccsteps--, i += eccbytes, p += eccsize) {\n\t\tint stat;\n\n\t\tchip->ecc.hwctl(chip, NAND_ECC_READ);\n\n\t\tret = nand_read_data_op(chip, p, eccsize, false, false);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (chip->ecc.prepad) {\n\t\t\tret = nand_read_data_op(chip, oob, chip->ecc.prepad,\n\t\t\t\t\t\tfalse, false);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\toob += chip->ecc.prepad;\n\t\t}\n\n\t\tchip->ecc.hwctl(chip, NAND_ECC_READSYN);\n\n\t\tret = nand_read_data_op(chip, oob, eccbytes, false, false);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tstat = chip->ecc.correct(chip, p, oob, NULL);\n\n\t\toob += eccbytes;\n\n\t\tif (chip->ecc.postpad) {\n\t\t\tret = nand_read_data_op(chip, oob, chip->ecc.postpad,\n\t\t\t\t\t\tfalse, false);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\toob += chip->ecc.postpad;\n\t\t}\n\n\t\tif (stat == -EBADMSG &&\n\t\t    (chip->ecc.options & NAND_ECC_GENERIC_ERASED_CHECK)) {\n\t\t\t \n\t\t\tstat = nand_check_erased_ecc_chunk(p, chip->ecc.size,\n\t\t\t\t\t\t\t   oob - eccpadbytes,\n\t\t\t\t\t\t\t   eccpadbytes,\n\t\t\t\t\t\t\t   NULL, 0,\n\t\t\t\t\t\t\t   chip->ecc.strength);\n\t\t}\n\n\t\tif (stat < 0) {\n\t\t\tmtd->ecc_stats.failed++;\n\t\t} else {\n\t\t\tmtd->ecc_stats.corrected += stat;\n\t\t\tmax_bitflips = max_t(unsigned int, max_bitflips, stat);\n\t\t}\n\t}\n\n\t \n\ti = mtd->oobsize - (oob - chip->oob_poi);\n\tif (i) {\n\t\tret = nand_read_data_op(chip, oob, i, false, false);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn max_bitflips;\n}\n\n \nstatic uint8_t *nand_transfer_oob(struct nand_chip *chip, uint8_t *oob,\n\t\t\t\t  struct mtd_oob_ops *ops, size_t len)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tint ret;\n\n\tswitch (ops->mode) {\n\n\tcase MTD_OPS_PLACE_OOB:\n\tcase MTD_OPS_RAW:\n\t\tmemcpy(oob, chip->oob_poi + ops->ooboffs, len);\n\t\treturn oob + len;\n\n\tcase MTD_OPS_AUTO_OOB:\n\t\tret = mtd_ooblayout_get_databytes(mtd, oob, chip->oob_poi,\n\t\t\t\t\t\t  ops->ooboffs, len);\n\t\tBUG_ON(ret);\n\t\treturn oob + len;\n\n\tdefault:\n\t\tBUG();\n\t}\n\treturn NULL;\n}\n\nstatic void rawnand_enable_cont_reads(struct nand_chip *chip, unsigned int page,\n\t\t\t\t      u32 readlen, int col)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\n\tif (!chip->controller->supported_op.cont_read)\n\t\treturn;\n\n\tif ((col && col + readlen < (3 * mtd->writesize)) ||\n\t    (!col && readlen < (2 * mtd->writesize))) {\n\t\tchip->cont_read.ongoing = false;\n\t\treturn;\n\t}\n\n\tchip->cont_read.ongoing = true;\n\tchip->cont_read.first_page = page;\n\tif (col)\n\t\tchip->cont_read.first_page++;\n\tchip->cont_read.last_page = page + ((readlen >> chip->page_shift) & chip->pagemask);\n}\n\n \nstatic int nand_setup_read_retry(struct nand_chip *chip, int retry_mode)\n{\n\tpr_debug(\"setting READ RETRY mode %d\\n\", retry_mode);\n\n\tif (retry_mode >= chip->read_retries)\n\t\treturn -EINVAL;\n\n\tif (!chip->ops.setup_read_retry)\n\t\treturn -EOPNOTSUPP;\n\n\treturn chip->ops.setup_read_retry(chip, retry_mode);\n}\n\nstatic void nand_wait_readrdy(struct nand_chip *chip)\n{\n\tconst struct nand_interface_config *conf;\n\n\tif (!(chip->options & NAND_NEED_READRDY))\n\t\treturn;\n\n\tconf = nand_get_interface_config(chip);\n\tWARN_ON(nand_wait_rdy_op(chip, NAND_COMMON_TIMING_MS(conf, tR_max), 0));\n}\n\n \nstatic int nand_do_read_ops(struct nand_chip *chip, loff_t from,\n\t\t\t    struct mtd_oob_ops *ops)\n{\n\tint chipnr, page, realpage, col, bytes, aligned, oob_required;\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tint ret = 0;\n\tuint32_t readlen = ops->len;\n\tuint32_t oobreadlen = ops->ooblen;\n\tuint32_t max_oobsize = mtd_oobavail(mtd, ops);\n\n\tuint8_t *bufpoi, *oob, *buf;\n\tint use_bounce_buf;\n\tunsigned int max_bitflips = 0;\n\tint retry_mode = 0;\n\tbool ecc_fail = false;\n\n\t \n\tif (nand_region_is_secured(chip, from, readlen))\n\t\treturn -EIO;\n\n\tchipnr = (int)(from >> chip->chip_shift);\n\tnand_select_target(chip, chipnr);\n\n\trealpage = (int)(from >> chip->page_shift);\n\tpage = realpage & chip->pagemask;\n\n\tcol = (int)(from & (mtd->writesize - 1));\n\n\tbuf = ops->datbuf;\n\toob = ops->oobbuf;\n\toob_required = oob ? 1 : 0;\n\n\trawnand_enable_cont_reads(chip, page, readlen, col);\n\n\twhile (1) {\n\t\tstruct mtd_ecc_stats ecc_stats = mtd->ecc_stats;\n\n\t\tbytes = min(mtd->writesize - col, readlen);\n\t\taligned = (bytes == mtd->writesize);\n\n\t\tif (!aligned)\n\t\t\tuse_bounce_buf = 1;\n\t\telse if (chip->options & NAND_USES_DMA)\n\t\t\tuse_bounce_buf = !virt_addr_valid(buf) ||\n\t\t\t\t\t !IS_ALIGNED((unsigned long)buf,\n\t\t\t\t\t\t     chip->buf_align);\n\t\telse\n\t\t\tuse_bounce_buf = 0;\n\n\t\t \n\t\tif (realpage != chip->pagecache.page || oob) {\n\t\t\tbufpoi = use_bounce_buf ? chip->data_buf : buf;\n\n\t\t\tif (use_bounce_buf && aligned)\n\t\t\t\tpr_debug(\"%s: using read bounce buffer for buf@%p\\n\",\n\t\t\t\t\t\t __func__, buf);\n\nread_retry:\n\t\t\t \n\t\t\tif (unlikely(ops->mode == MTD_OPS_RAW))\n\t\t\t\tret = chip->ecc.read_page_raw(chip, bufpoi,\n\t\t\t\t\t\t\t      oob_required,\n\t\t\t\t\t\t\t      page);\n\t\t\telse if (!aligned && NAND_HAS_SUBPAGE_READ(chip) &&\n\t\t\t\t !oob)\n\t\t\t\tret = chip->ecc.read_subpage(chip, col, bytes,\n\t\t\t\t\t\t\t     bufpoi, page);\n\t\t\telse\n\t\t\t\tret = chip->ecc.read_page(chip, bufpoi,\n\t\t\t\t\t\t\t  oob_required, page);\n\t\t\tif (ret < 0) {\n\t\t\t\tif (use_bounce_buf)\n\t\t\t\t\t \n\t\t\t\t\tchip->pagecache.page = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (use_bounce_buf) {\n\t\t\t\tif (!NAND_HAS_SUBPAGE_READ(chip) && !oob &&\n\t\t\t\t    !(mtd->ecc_stats.failed - ecc_stats.failed) &&\n\t\t\t\t    (ops->mode != MTD_OPS_RAW)) {\n\t\t\t\t\tchip->pagecache.page = realpage;\n\t\t\t\t\tchip->pagecache.bitflips = ret;\n\t\t\t\t} else {\n\t\t\t\t\t \n\t\t\t\t\tchip->pagecache.page = -1;\n\t\t\t\t}\n\t\t\t\tmemcpy(buf, bufpoi + col, bytes);\n\t\t\t}\n\n\t\t\tif (unlikely(oob)) {\n\t\t\t\tint toread = min(oobreadlen, max_oobsize);\n\n\t\t\t\tif (toread) {\n\t\t\t\t\toob = nand_transfer_oob(chip, oob, ops,\n\t\t\t\t\t\t\t\ttoread);\n\t\t\t\t\toobreadlen -= toread;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tnand_wait_readrdy(chip);\n\n\t\t\tif (mtd->ecc_stats.failed - ecc_stats.failed) {\n\t\t\t\tif (retry_mode + 1 < chip->read_retries) {\n\t\t\t\t\tretry_mode++;\n\t\t\t\t\tret = nand_setup_read_retry(chip,\n\t\t\t\t\t\t\tretry_mode);\n\t\t\t\t\tif (ret < 0)\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t \n\t\t\t\t\tmtd->ecc_stats = ecc_stats;\n\t\t\t\t\tgoto read_retry;\n\t\t\t\t} else {\n\t\t\t\t\t \n\t\t\t\t\tecc_fail = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbuf += bytes;\n\t\t\tmax_bitflips = max_t(unsigned int, max_bitflips, ret);\n\t\t} else {\n\t\t\tmemcpy(buf, chip->data_buf + col, bytes);\n\t\t\tbuf += bytes;\n\t\t\tmax_bitflips = max_t(unsigned int, max_bitflips,\n\t\t\t\t\t     chip->pagecache.bitflips);\n\t\t}\n\n\t\treadlen -= bytes;\n\n\t\t \n\t\tif (retry_mode) {\n\t\t\tret = nand_setup_read_retry(chip, 0);\n\t\t\tif (ret < 0)\n\t\t\t\tbreak;\n\t\t\tretry_mode = 0;\n\t\t}\n\n\t\tif (!readlen)\n\t\t\tbreak;\n\n\t\t \n\t\tcol = 0;\n\t\t \n\t\trealpage++;\n\n\t\tpage = realpage & chip->pagemask;\n\t\t \n\t\tif (!page) {\n\t\t\tchipnr++;\n\t\t\tnand_deselect_target(chip);\n\t\t\tnand_select_target(chip, chipnr);\n\t\t}\n\t}\n\tnand_deselect_target(chip);\n\n\tops->retlen = ops->len - (size_t) readlen;\n\tif (oob)\n\t\tops->oobretlen = ops->ooblen - oobreadlen;\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (ecc_fail)\n\t\treturn -EBADMSG;\n\n\treturn max_bitflips;\n}\n\n \nint nand_read_oob_std(struct nand_chip *chip, int page)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\n\treturn nand_read_oob_op(chip, page, 0, chip->oob_poi, mtd->oobsize);\n}\nEXPORT_SYMBOL(nand_read_oob_std);\n\n \nstatic int nand_read_oob_syndrome(struct nand_chip *chip, int page)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tint length = mtd->oobsize;\n\tint chunk = chip->ecc.bytes + chip->ecc.prepad + chip->ecc.postpad;\n\tint eccsize = chip->ecc.size;\n\tuint8_t *bufpoi = chip->oob_poi;\n\tint i, toread, sndrnd = 0, pos, ret;\n\n\tret = nand_read_page_op(chip, page, chip->ecc.size, NULL, 0);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < chip->ecc.steps; i++) {\n\t\tif (sndrnd) {\n\t\t\tint ret;\n\n\t\t\tpos = eccsize + i * (eccsize + chunk);\n\t\t\tif (mtd->writesize > 512)\n\t\t\t\tret = nand_change_read_column_op(chip, pos,\n\t\t\t\t\t\t\t\t NULL, 0,\n\t\t\t\t\t\t\t\t false);\n\t\t\telse\n\t\t\t\tret = nand_read_page_op(chip, page, pos, NULL,\n\t\t\t\t\t\t\t0);\n\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t} else\n\t\t\tsndrnd = 1;\n\t\ttoread = min_t(int, length, chunk);\n\n\t\tret = nand_read_data_op(chip, bufpoi, toread, false, false);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tbufpoi += toread;\n\t\tlength -= toread;\n\t}\n\tif (length > 0) {\n\t\tret = nand_read_data_op(chip, bufpoi, length, false, false);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n \nint nand_write_oob_std(struct nand_chip *chip, int page)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\n\treturn nand_prog_page_op(chip, page, mtd->writesize, chip->oob_poi,\n\t\t\t\t mtd->oobsize);\n}\nEXPORT_SYMBOL(nand_write_oob_std);\n\n \nstatic int nand_write_oob_syndrome(struct nand_chip *chip, int page)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tint chunk = chip->ecc.bytes + chip->ecc.prepad + chip->ecc.postpad;\n\tint eccsize = chip->ecc.size, length = mtd->oobsize;\n\tint ret, i, len, pos, sndcmd = 0, steps = chip->ecc.steps;\n\tconst uint8_t *bufpoi = chip->oob_poi;\n\n\t \n\tif (!chip->ecc.prepad && !chip->ecc.postpad) {\n\t\tpos = steps * (eccsize + chunk);\n\t\tsteps = 0;\n\t} else\n\t\tpos = eccsize;\n\n\tret = nand_prog_page_begin_op(chip, page, pos, NULL, 0);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < steps; i++) {\n\t\tif (sndcmd) {\n\t\t\tif (mtd->writesize <= 512) {\n\t\t\t\tuint32_t fill = 0xFFFFFFFF;\n\n\t\t\t\tlen = eccsize;\n\t\t\t\twhile (len > 0) {\n\t\t\t\t\tint num = min_t(int, len, 4);\n\n\t\t\t\t\tret = nand_write_data_op(chip, &fill,\n\t\t\t\t\t\t\t\t num, false);\n\t\t\t\t\tif (ret)\n\t\t\t\t\t\treturn ret;\n\n\t\t\t\t\tlen -= num;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tpos = eccsize + i * (eccsize + chunk);\n\t\t\t\tret = nand_change_write_column_op(chip, pos,\n\t\t\t\t\t\t\t\t  NULL, 0,\n\t\t\t\t\t\t\t\t  false);\n\t\t\t\tif (ret)\n\t\t\t\t\treturn ret;\n\t\t\t}\n\t\t} else\n\t\t\tsndcmd = 1;\n\t\tlen = min_t(int, length, chunk);\n\n\t\tret = nand_write_data_op(chip, bufpoi, len, false);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tbufpoi += len;\n\t\tlength -= len;\n\t}\n\tif (length > 0) {\n\t\tret = nand_write_data_op(chip, bufpoi, length, false);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn nand_prog_page_end_op(chip);\n}\n\n \nstatic int nand_do_read_oob(struct nand_chip *chip, loff_t from,\n\t\t\t    struct mtd_oob_ops *ops)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tunsigned int max_bitflips = 0;\n\tint page, realpage, chipnr;\n\tstruct mtd_ecc_stats stats;\n\tint readlen = ops->ooblen;\n\tint len;\n\tuint8_t *buf = ops->oobbuf;\n\tint ret = 0;\n\n\tpr_debug(\"%s: from = 0x%08Lx, len = %i\\n\",\n\t\t\t__func__, (unsigned long long)from, readlen);\n\n\t \n\tif (nand_region_is_secured(chip, from, readlen))\n\t\treturn -EIO;\n\n\tstats = mtd->ecc_stats;\n\n\tlen = mtd_oobavail(mtd, ops);\n\n\tchipnr = (int)(from >> chip->chip_shift);\n\tnand_select_target(chip, chipnr);\n\n\t \n\trealpage = (int)(from >> chip->page_shift);\n\tpage = realpage & chip->pagemask;\n\n\twhile (1) {\n\t\tif (ops->mode == MTD_OPS_RAW)\n\t\t\tret = chip->ecc.read_oob_raw(chip, page);\n\t\telse\n\t\t\tret = chip->ecc.read_oob(chip, page);\n\n\t\tif (ret < 0)\n\t\t\tbreak;\n\n\t\tlen = min(len, readlen);\n\t\tbuf = nand_transfer_oob(chip, buf, ops, len);\n\n\t\tnand_wait_readrdy(chip);\n\n\t\tmax_bitflips = max_t(unsigned int, max_bitflips, ret);\n\n\t\treadlen -= len;\n\t\tif (!readlen)\n\t\t\tbreak;\n\n\t\t \n\t\trealpage++;\n\n\t\tpage = realpage & chip->pagemask;\n\t\t \n\t\tif (!page) {\n\t\t\tchipnr++;\n\t\t\tnand_deselect_target(chip);\n\t\t\tnand_select_target(chip, chipnr);\n\t\t}\n\t}\n\tnand_deselect_target(chip);\n\n\tops->oobretlen = ops->ooblen - readlen;\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (mtd->ecc_stats.failed - stats.failed)\n\t\treturn -EBADMSG;\n\n\treturn max_bitflips;\n}\n\n \nstatic int nand_read_oob(struct mtd_info *mtd, loff_t from,\n\t\t\t struct mtd_oob_ops *ops)\n{\n\tstruct nand_chip *chip = mtd_to_nand(mtd);\n\tstruct mtd_ecc_stats old_stats;\n\tint ret;\n\n\tops->retlen = 0;\n\n\tif (ops->mode != MTD_OPS_PLACE_OOB &&\n\t    ops->mode != MTD_OPS_AUTO_OOB &&\n\t    ops->mode != MTD_OPS_RAW)\n\t\treturn -ENOTSUPP;\n\n\tnand_get_device(chip);\n\n\told_stats = mtd->ecc_stats;\n\n\tif (!ops->datbuf)\n\t\tret = nand_do_read_oob(chip, from, ops);\n\telse\n\t\tret = nand_do_read_ops(chip, from, ops);\n\n\tif (ops->stats) {\n\t\tops->stats->uncorrectable_errors +=\n\t\t\tmtd->ecc_stats.failed - old_stats.failed;\n\t\tops->stats->corrected_bitflips +=\n\t\t\tmtd->ecc_stats.corrected - old_stats.corrected;\n\t}\n\n\tnand_release_device(chip);\n\treturn ret;\n}\n\n \nint nand_write_page_raw_notsupp(struct nand_chip *chip, const u8 *buf,\n\t\t\t\tint oob_required, int page)\n{\n\treturn -ENOTSUPP;\n}\n\n \nint nand_write_page_raw(struct nand_chip *chip, const uint8_t *buf,\n\t\t\tint oob_required, int page)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tint ret;\n\n\tret = nand_prog_page_begin_op(chip, page, 0, buf, mtd->writesize);\n\tif (ret)\n\t\treturn ret;\n\n\tif (oob_required) {\n\t\tret = nand_write_data_op(chip, chip->oob_poi, mtd->oobsize,\n\t\t\t\t\t false);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn nand_prog_page_end_op(chip);\n}\nEXPORT_SYMBOL(nand_write_page_raw);\n\n \nint nand_monolithic_write_page_raw(struct nand_chip *chip, const u8 *buf,\n\t\t\t\t   int oob_required, int page)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tunsigned int size = mtd->writesize;\n\tu8 *write_buf = (u8 *)buf;\n\n\tif (oob_required) {\n\t\tsize += mtd->oobsize;\n\n\t\tif (buf != chip->data_buf) {\n\t\t\twrite_buf = nand_get_data_buf(chip);\n\t\t\tmemcpy(write_buf, buf, mtd->writesize);\n\t\t}\n\t}\n\n\treturn nand_prog_page_op(chip, page, 0, write_buf, size);\n}\nEXPORT_SYMBOL(nand_monolithic_write_page_raw);\n\n \nstatic int nand_write_page_raw_syndrome(struct nand_chip *chip,\n\t\t\t\t\tconst uint8_t *buf, int oob_required,\n\t\t\t\t\tint page)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tint eccsize = chip->ecc.size;\n\tint eccbytes = chip->ecc.bytes;\n\tuint8_t *oob = chip->oob_poi;\n\tint steps, size, ret;\n\n\tret = nand_prog_page_begin_op(chip, page, 0, NULL, 0);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (steps = chip->ecc.steps; steps > 0; steps--) {\n\t\tret = nand_write_data_op(chip, buf, eccsize, false);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tbuf += eccsize;\n\n\t\tif (chip->ecc.prepad) {\n\t\t\tret = nand_write_data_op(chip, oob, chip->ecc.prepad,\n\t\t\t\t\t\t false);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\toob += chip->ecc.prepad;\n\t\t}\n\n\t\tret = nand_write_data_op(chip, oob, eccbytes, false);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\toob += eccbytes;\n\n\t\tif (chip->ecc.postpad) {\n\t\t\tret = nand_write_data_op(chip, oob, chip->ecc.postpad,\n\t\t\t\t\t\t false);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\toob += chip->ecc.postpad;\n\t\t}\n\t}\n\n\tsize = mtd->oobsize - (oob - chip->oob_poi);\n\tif (size) {\n\t\tret = nand_write_data_op(chip, oob, size, false);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn nand_prog_page_end_op(chip);\n}\n \nstatic int nand_write_page_swecc(struct nand_chip *chip, const uint8_t *buf,\n\t\t\t\t int oob_required, int page)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tint i, eccsize = chip->ecc.size, ret;\n\tint eccbytes = chip->ecc.bytes;\n\tint eccsteps = chip->ecc.steps;\n\tuint8_t *ecc_calc = chip->ecc.calc_buf;\n\tconst uint8_t *p = buf;\n\n\t \n\tfor (i = 0; eccsteps; eccsteps--, i += eccbytes, p += eccsize)\n\t\tchip->ecc.calculate(chip, p, &ecc_calc[i]);\n\n\tret = mtd_ooblayout_set_eccbytes(mtd, ecc_calc, chip->oob_poi, 0,\n\t\t\t\t\t chip->ecc.total);\n\tif (ret)\n\t\treturn ret;\n\n\treturn chip->ecc.write_page_raw(chip, buf, 1, page);\n}\n\n \nstatic int nand_write_page_hwecc(struct nand_chip *chip, const uint8_t *buf,\n\t\t\t\t int oob_required, int page)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tint i, eccsize = chip->ecc.size, ret;\n\tint eccbytes = chip->ecc.bytes;\n\tint eccsteps = chip->ecc.steps;\n\tuint8_t *ecc_calc = chip->ecc.calc_buf;\n\tconst uint8_t *p = buf;\n\n\tret = nand_prog_page_begin_op(chip, page, 0, NULL, 0);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; eccsteps; eccsteps--, i += eccbytes, p += eccsize) {\n\t\tchip->ecc.hwctl(chip, NAND_ECC_WRITE);\n\n\t\tret = nand_write_data_op(chip, p, eccsize, false);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tchip->ecc.calculate(chip, p, &ecc_calc[i]);\n\t}\n\n\tret = mtd_ooblayout_set_eccbytes(mtd, ecc_calc, chip->oob_poi, 0,\n\t\t\t\t\t chip->ecc.total);\n\tif (ret)\n\t\treturn ret;\n\n\tret = nand_write_data_op(chip, chip->oob_poi, mtd->oobsize, false);\n\tif (ret)\n\t\treturn ret;\n\n\treturn nand_prog_page_end_op(chip);\n}\n\n\n \nstatic int nand_write_subpage_hwecc(struct nand_chip *chip, uint32_t offset,\n\t\t\t\t    uint32_t data_len, const uint8_t *buf,\n\t\t\t\t    int oob_required, int page)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tuint8_t *oob_buf  = chip->oob_poi;\n\tuint8_t *ecc_calc = chip->ecc.calc_buf;\n\tint ecc_size      = chip->ecc.size;\n\tint ecc_bytes     = chip->ecc.bytes;\n\tint ecc_steps     = chip->ecc.steps;\n\tuint32_t start_step = offset / ecc_size;\n\tuint32_t end_step   = (offset + data_len - 1) / ecc_size;\n\tint oob_bytes       = mtd->oobsize / ecc_steps;\n\tint step, ret;\n\n\tret = nand_prog_page_begin_op(chip, page, 0, NULL, 0);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (step = 0; step < ecc_steps; step++) {\n\t\t \n\t\tchip->ecc.hwctl(chip, NAND_ECC_WRITE);\n\n\t\t \n\t\tret = nand_write_data_op(chip, buf, ecc_size, false);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t \n\t\tif ((step < start_step) || (step > end_step))\n\t\t\tmemset(ecc_calc, 0xff, ecc_bytes);\n\t\telse\n\t\t\tchip->ecc.calculate(chip, buf, ecc_calc);\n\n\t\t \n\t\t \n\t\tif (!oob_required || (step < start_step) || (step > end_step))\n\t\t\tmemset(oob_buf, 0xff, oob_bytes);\n\n\t\tbuf += ecc_size;\n\t\tecc_calc += ecc_bytes;\n\t\toob_buf  += oob_bytes;\n\t}\n\n\t \n\t \n\tecc_calc = chip->ecc.calc_buf;\n\tret = mtd_ooblayout_set_eccbytes(mtd, ecc_calc, chip->oob_poi, 0,\n\t\t\t\t\t chip->ecc.total);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = nand_write_data_op(chip, chip->oob_poi, mtd->oobsize, false);\n\tif (ret)\n\t\treturn ret;\n\n\treturn nand_prog_page_end_op(chip);\n}\n\n\n \nstatic int nand_write_page_syndrome(struct nand_chip *chip, const uint8_t *buf,\n\t\t\t\t    int oob_required, int page)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tint i, eccsize = chip->ecc.size;\n\tint eccbytes = chip->ecc.bytes;\n\tint eccsteps = chip->ecc.steps;\n\tconst uint8_t *p = buf;\n\tuint8_t *oob = chip->oob_poi;\n\tint ret;\n\n\tret = nand_prog_page_begin_op(chip, page, 0, NULL, 0);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; eccsteps; eccsteps--, i += eccbytes, p += eccsize) {\n\t\tchip->ecc.hwctl(chip, NAND_ECC_WRITE);\n\n\t\tret = nand_write_data_op(chip, p, eccsize, false);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (chip->ecc.prepad) {\n\t\t\tret = nand_write_data_op(chip, oob, chip->ecc.prepad,\n\t\t\t\t\t\t false);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\toob += chip->ecc.prepad;\n\t\t}\n\n\t\tchip->ecc.calculate(chip, p, oob);\n\n\t\tret = nand_write_data_op(chip, oob, eccbytes, false);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\toob += eccbytes;\n\n\t\tif (chip->ecc.postpad) {\n\t\t\tret = nand_write_data_op(chip, oob, chip->ecc.postpad,\n\t\t\t\t\t\t false);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\toob += chip->ecc.postpad;\n\t\t}\n\t}\n\n\t \n\ti = mtd->oobsize - (oob - chip->oob_poi);\n\tif (i) {\n\t\tret = nand_write_data_op(chip, oob, i, false);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn nand_prog_page_end_op(chip);\n}\n\n \nstatic int nand_write_page(struct nand_chip *chip, uint32_t offset,\n\t\t\t   int data_len, const uint8_t *buf, int oob_required,\n\t\t\t   int page, int raw)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tint status, subpage;\n\n\tif (!(chip->options & NAND_NO_SUBPAGE_WRITE) &&\n\t\tchip->ecc.write_subpage)\n\t\tsubpage = offset || (data_len < mtd->writesize);\n\telse\n\t\tsubpage = 0;\n\n\tif (unlikely(raw))\n\t\tstatus = chip->ecc.write_page_raw(chip, buf, oob_required,\n\t\t\t\t\t\t  page);\n\telse if (subpage)\n\t\tstatus = chip->ecc.write_subpage(chip, offset, data_len, buf,\n\t\t\t\t\t\t oob_required, page);\n\telse\n\t\tstatus = chip->ecc.write_page(chip, buf, oob_required, page);\n\n\tif (status < 0)\n\t\treturn status;\n\n\treturn 0;\n}\n\n#define NOTALIGNED(x)\t((x & (chip->subpagesize - 1)) != 0)\n\n \nstatic int nand_do_write_ops(struct nand_chip *chip, loff_t to,\n\t\t\t     struct mtd_oob_ops *ops)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tint chipnr, realpage, page, column;\n\tuint32_t writelen = ops->len;\n\n\tuint32_t oobwritelen = ops->ooblen;\n\tuint32_t oobmaxlen = mtd_oobavail(mtd, ops);\n\n\tuint8_t *oob = ops->oobbuf;\n\tuint8_t *buf = ops->datbuf;\n\tint ret;\n\tint oob_required = oob ? 1 : 0;\n\n\tops->retlen = 0;\n\tif (!writelen)\n\t\treturn 0;\n\n\t \n\tif (NOTALIGNED(to) || NOTALIGNED(ops->len)) {\n\t\tpr_notice(\"%s: attempt to write non page aligned data\\n\",\n\t\t\t   __func__);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (nand_region_is_secured(chip, to, writelen))\n\t\treturn -EIO;\n\n\tcolumn = to & (mtd->writesize - 1);\n\n\tchipnr = (int)(to >> chip->chip_shift);\n\tnand_select_target(chip, chipnr);\n\n\t \n\tif (nand_check_wp(chip)) {\n\t\tret = -EIO;\n\t\tgoto err_out;\n\t}\n\n\trealpage = (int)(to >> chip->page_shift);\n\tpage = realpage & chip->pagemask;\n\n\t \n\tif (to <= ((loff_t)chip->pagecache.page << chip->page_shift) &&\n\t    ((loff_t)chip->pagecache.page << chip->page_shift) < (to + ops->len))\n\t\tchip->pagecache.page = -1;\n\n\t \n\tif (oob && ops->ooboffs && (ops->ooboffs + ops->ooblen > oobmaxlen)) {\n\t\tret = -EINVAL;\n\t\tgoto err_out;\n\t}\n\n\twhile (1) {\n\t\tint bytes = mtd->writesize;\n\t\tuint8_t *wbuf = buf;\n\t\tint use_bounce_buf;\n\t\tint part_pagewr = (column || writelen < mtd->writesize);\n\n\t\tif (part_pagewr)\n\t\t\tuse_bounce_buf = 1;\n\t\telse if (chip->options & NAND_USES_DMA)\n\t\t\tuse_bounce_buf = !virt_addr_valid(buf) ||\n\t\t\t\t\t !IS_ALIGNED((unsigned long)buf,\n\t\t\t\t\t\t     chip->buf_align);\n\t\telse\n\t\t\tuse_bounce_buf = 0;\n\n\t\t \n\t\tif (use_bounce_buf) {\n\t\t\tpr_debug(\"%s: using write bounce buffer for buf@%p\\n\",\n\t\t\t\t\t __func__, buf);\n\t\t\tif (part_pagewr)\n\t\t\t\tbytes = min_t(int, bytes - column, writelen);\n\t\t\twbuf = nand_get_data_buf(chip);\n\t\t\tmemset(wbuf, 0xff, mtd->writesize);\n\t\t\tmemcpy(&wbuf[column], buf, bytes);\n\t\t}\n\n\t\tif (unlikely(oob)) {\n\t\t\tsize_t len = min(oobwritelen, oobmaxlen);\n\t\t\toob = nand_fill_oob(chip, oob, len, ops);\n\t\t\toobwritelen -= len;\n\t\t} else {\n\t\t\t \n\t\t\tmemset(chip->oob_poi, 0xff, mtd->oobsize);\n\t\t}\n\n\t\tret = nand_write_page(chip, column, bytes, wbuf,\n\t\t\t\t      oob_required, page,\n\t\t\t\t      (ops->mode == MTD_OPS_RAW));\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\twritelen -= bytes;\n\t\tif (!writelen)\n\t\t\tbreak;\n\n\t\tcolumn = 0;\n\t\tbuf += bytes;\n\t\trealpage++;\n\n\t\tpage = realpage & chip->pagemask;\n\t\t \n\t\tif (!page) {\n\t\t\tchipnr++;\n\t\t\tnand_deselect_target(chip);\n\t\t\tnand_select_target(chip, chipnr);\n\t\t}\n\t}\n\n\tops->retlen = ops->len - writelen;\n\tif (unlikely(oob))\n\t\tops->oobretlen = ops->ooblen;\n\nerr_out:\n\tnand_deselect_target(chip);\n\treturn ret;\n}\n\n \nstatic int panic_nand_write(struct mtd_info *mtd, loff_t to, size_t len,\n\t\t\t    size_t *retlen, const uint8_t *buf)\n{\n\tstruct nand_chip *chip = mtd_to_nand(mtd);\n\tint chipnr = (int)(to >> chip->chip_shift);\n\tstruct mtd_oob_ops ops;\n\tint ret;\n\n\tnand_select_target(chip, chipnr);\n\n\t \n\tpanic_nand_wait(chip, 400);\n\n\tmemset(&ops, 0, sizeof(ops));\n\tops.len = len;\n\tops.datbuf = (uint8_t *)buf;\n\tops.mode = MTD_OPS_PLACE_OOB;\n\n\tret = nand_do_write_ops(chip, to, &ops);\n\n\t*retlen = ops.retlen;\n\treturn ret;\n}\n\n \nstatic int nand_write_oob(struct mtd_info *mtd, loff_t to,\n\t\t\t  struct mtd_oob_ops *ops)\n{\n\tstruct nand_chip *chip = mtd_to_nand(mtd);\n\tint ret = 0;\n\n\tops->retlen = 0;\n\n\tnand_get_device(chip);\n\n\tswitch (ops->mode) {\n\tcase MTD_OPS_PLACE_OOB:\n\tcase MTD_OPS_AUTO_OOB:\n\tcase MTD_OPS_RAW:\n\t\tbreak;\n\n\tdefault:\n\t\tgoto out;\n\t}\n\n\tif (!ops->datbuf)\n\t\tret = nand_do_write_oob(chip, to, ops);\n\telse\n\t\tret = nand_do_write_ops(chip, to, ops);\n\nout:\n\tnand_release_device(chip);\n\treturn ret;\n}\n\n \nstatic int nand_erase(struct mtd_info *mtd, struct erase_info *instr)\n{\n\treturn nand_erase_nand(mtd_to_nand(mtd), instr, 0);\n}\n\n \nint nand_erase_nand(struct nand_chip *chip, struct erase_info *instr,\n\t\t    int allowbbt)\n{\n\tint page, pages_per_block, ret, chipnr;\n\tloff_t len;\n\n\tpr_debug(\"%s: start = 0x%012llx, len = %llu\\n\",\n\t\t\t__func__, (unsigned long long)instr->addr,\n\t\t\t(unsigned long long)instr->len);\n\n\tif (check_offs_len(chip, instr->addr, instr->len))\n\t\treturn -EINVAL;\n\n\t \n\tif (nand_region_is_secured(chip, instr->addr, instr->len))\n\t\treturn -EIO;\n\n\t \n\tnand_get_device(chip);\n\n\t \n\tpage = (int)(instr->addr >> chip->page_shift);\n\tchipnr = (int)(instr->addr >> chip->chip_shift);\n\n\t \n\tpages_per_block = 1 << (chip->phys_erase_shift - chip->page_shift);\n\n\t \n\tnand_select_target(chip, chipnr);\n\n\t \n\tif (nand_check_wp(chip)) {\n\t\tpr_debug(\"%s: device is write protected!\\n\",\n\t\t\t\t__func__);\n\t\tret = -EIO;\n\t\tgoto erase_exit;\n\t}\n\n\t \n\tlen = instr->len;\n\n\twhile (len) {\n\t\tloff_t ofs = (loff_t)page << chip->page_shift;\n\n\t\t \n\t\tif (nand_block_checkbad(chip, ((loff_t) page) <<\n\t\t\t\t\tchip->page_shift, allowbbt)) {\n\t\t\tpr_warn(\"%s: attempt to erase a bad block at 0x%08llx\\n\",\n\t\t\t\t    __func__, (unsigned long long)ofs);\n\t\t\tret = -EIO;\n\t\t\tgoto erase_exit;\n\t\t}\n\n\t\t \n\t\tif (page <= chip->pagecache.page && chip->pagecache.page <\n\t\t    (page + pages_per_block))\n\t\t\tchip->pagecache.page = -1;\n\n\t\tret = nand_erase_op(chip, (page & chip->pagemask) >>\n\t\t\t\t    (chip->phys_erase_shift - chip->page_shift));\n\t\tif (ret) {\n\t\t\tpr_debug(\"%s: failed erase, page 0x%08x\\n\",\n\t\t\t\t\t__func__, page);\n\t\t\tinstr->fail_addr = ofs;\n\t\t\tgoto erase_exit;\n\t\t}\n\n\t\t \n\t\tlen -= (1ULL << chip->phys_erase_shift);\n\t\tpage += pages_per_block;\n\n\t\t \n\t\tif (len && !(page & chip->pagemask)) {\n\t\t\tchipnr++;\n\t\t\tnand_deselect_target(chip);\n\t\t\tnand_select_target(chip, chipnr);\n\t\t}\n\t}\n\n\tret = 0;\nerase_exit:\n\n\t \n\tnand_deselect_target(chip);\n\tnand_release_device(chip);\n\n\t \n\treturn ret;\n}\n\n \nstatic void nand_sync(struct mtd_info *mtd)\n{\n\tstruct nand_chip *chip = mtd_to_nand(mtd);\n\n\tpr_debug(\"%s: called\\n\", __func__);\n\n\t \n\tnand_get_device(chip);\n\t \n\tnand_release_device(chip);\n}\n\n \nstatic int nand_block_isbad(struct mtd_info *mtd, loff_t offs)\n{\n\tstruct nand_chip *chip = mtd_to_nand(mtd);\n\tint chipnr = (int)(offs >> chip->chip_shift);\n\tint ret;\n\n\t \n\tnand_get_device(chip);\n\n\tnand_select_target(chip, chipnr);\n\n\tret = nand_block_checkbad(chip, offs, 0);\n\n\tnand_deselect_target(chip);\n\tnand_release_device(chip);\n\n\treturn ret;\n}\n\n \nstatic int nand_block_markbad(struct mtd_info *mtd, loff_t ofs)\n{\n\tint ret;\n\n\tret = nand_block_isbad(mtd, ofs);\n\tif (ret) {\n\t\t \n\t\tif (ret > 0)\n\t\t\treturn 0;\n\t\treturn ret;\n\t}\n\n\treturn nand_block_markbad_lowlevel(mtd_to_nand(mtd), ofs);\n}\n\n \nstatic int nand_suspend(struct mtd_info *mtd)\n{\n\tstruct nand_chip *chip = mtd_to_nand(mtd);\n\tint ret = 0;\n\n\tmutex_lock(&chip->lock);\n\tif (chip->ops.suspend)\n\t\tret = chip->ops.suspend(chip);\n\tif (!ret)\n\t\tchip->suspended = 1;\n\tmutex_unlock(&chip->lock);\n\n\treturn ret;\n}\n\n \nstatic void nand_resume(struct mtd_info *mtd)\n{\n\tstruct nand_chip *chip = mtd_to_nand(mtd);\n\n\tmutex_lock(&chip->lock);\n\tif (chip->suspended) {\n\t\tif (chip->ops.resume)\n\t\t\tchip->ops.resume(chip);\n\t\tchip->suspended = 0;\n\t} else {\n\t\tpr_err(\"%s called for a chip which is not in suspended state\\n\",\n\t\t\t__func__);\n\t}\n\tmutex_unlock(&chip->lock);\n\n\twake_up_all(&chip->resume_wq);\n}\n\n \nstatic void nand_shutdown(struct mtd_info *mtd)\n{\n\tnand_suspend(mtd);\n}\n\n \nstatic int nand_lock(struct mtd_info *mtd, loff_t ofs, uint64_t len)\n{\n\tstruct nand_chip *chip = mtd_to_nand(mtd);\n\n\tif (!chip->ops.lock_area)\n\t\treturn -ENOTSUPP;\n\n\treturn chip->ops.lock_area(chip, ofs, len);\n}\n\n \nstatic int nand_unlock(struct mtd_info *mtd, loff_t ofs, uint64_t len)\n{\n\tstruct nand_chip *chip = mtd_to_nand(mtd);\n\n\tif (!chip->ops.unlock_area)\n\t\treturn -ENOTSUPP;\n\n\treturn chip->ops.unlock_area(chip, ofs, len);\n}\n\n \nstatic void nand_set_defaults(struct nand_chip *chip)\n{\n\t \n\tif (!chip->controller) {\n\t\tchip->controller = &chip->legacy.dummy_controller;\n\t\tnand_controller_init(chip->controller);\n\t}\n\n\tnand_legacy_set_defaults(chip);\n\n\tif (!chip->buf_align)\n\t\tchip->buf_align = 1;\n}\n\n \nvoid sanitize_string(uint8_t *s, size_t len)\n{\n\tssize_t i;\n\n\t \n\ts[len - 1] = 0;\n\n\t \n\tfor (i = 0; i < len - 1; i++) {\n\t\tif (s[i] < ' ' || s[i] > 127)\n\t\t\ts[i] = '?';\n\t}\n\n\t \n\tstrim(s);\n}\n\n \nstatic int nand_id_has_period(u8 *id_data, int arrlen, int period)\n{\n\tint i, j;\n\tfor (i = 0; i < period; i++)\n\t\tfor (j = i + period; j < arrlen; j += period)\n\t\t\tif (id_data[i] != id_data[j])\n\t\t\t\treturn 0;\n\treturn 1;\n}\n\n \nstatic int nand_id_len(u8 *id_data, int arrlen)\n{\n\tint last_nonzero, period;\n\n\t \n\tfor (last_nonzero = arrlen - 1; last_nonzero >= 0; last_nonzero--)\n\t\tif (id_data[last_nonzero])\n\t\t\tbreak;\n\n\t \n\tif (last_nonzero < 0)\n\t\treturn 0;\n\n\t \n\tfor (period = 1; period < arrlen; period++)\n\t\tif (nand_id_has_period(id_data, arrlen, period))\n\t\t\tbreak;\n\n\t \n\tif (period < arrlen)\n\t\treturn period;\n\n\t \n\tif (last_nonzero < arrlen - 1)\n\t\treturn last_nonzero + 1;\n\n\t \n\treturn arrlen;\n}\n\n \nstatic int nand_get_bits_per_cell(u8 cellinfo)\n{\n\tint bits;\n\n\tbits = cellinfo & NAND_CI_CELLTYPE_MSK;\n\tbits >>= NAND_CI_CELLTYPE_SHIFT;\n\treturn bits + 1;\n}\n\n \nvoid nand_decode_ext_id(struct nand_chip *chip)\n{\n\tstruct nand_memory_organization *memorg;\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tint extid;\n\tu8 *id_data = chip->id.data;\n\n\tmemorg = nanddev_get_memorg(&chip->base);\n\n\t \n\tmemorg->bits_per_cell = nand_get_bits_per_cell(id_data[2]);\n\t \n\textid = id_data[3];\n\n\t \n\tmemorg->pagesize = 1024 << (extid & 0x03);\n\tmtd->writesize = memorg->pagesize;\n\textid >>= 2;\n\t \n\tmemorg->oobsize = (8 << (extid & 0x01)) * (mtd->writesize >> 9);\n\tmtd->oobsize = memorg->oobsize;\n\textid >>= 2;\n\t \n\tmemorg->pages_per_eraseblock = ((64 * 1024) << (extid & 0x03)) /\n\t\t\t\t       memorg->pagesize;\n\tmtd->erasesize = (64 * 1024) << (extid & 0x03);\n\textid >>= 2;\n\t \n\tif (extid & 0x1)\n\t\tchip->options |= NAND_BUSWIDTH_16;\n}\nEXPORT_SYMBOL_GPL(nand_decode_ext_id);\n\n \nstatic void nand_decode_id(struct nand_chip *chip, struct nand_flash_dev *type)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tstruct nand_memory_organization *memorg;\n\n\tmemorg = nanddev_get_memorg(&chip->base);\n\n\tmemorg->pages_per_eraseblock = type->erasesize / type->pagesize;\n\tmtd->erasesize = type->erasesize;\n\tmemorg->pagesize = type->pagesize;\n\tmtd->writesize = memorg->pagesize;\n\tmemorg->oobsize = memorg->pagesize / 32;\n\tmtd->oobsize = memorg->oobsize;\n\n\t \n\tmemorg->bits_per_cell = 1;\n}\n\n \nstatic void nand_decode_bbm_options(struct nand_chip *chip)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\n\t \n\tif (mtd->writesize > 512 || (chip->options & NAND_BUSWIDTH_16))\n\t\tchip->badblockpos = NAND_BBM_POS_LARGE;\n\telse\n\t\tchip->badblockpos = NAND_BBM_POS_SMALL;\n}\n\nstatic inline bool is_full_id_nand(struct nand_flash_dev *type)\n{\n\treturn type->id_len;\n}\n\nstatic bool find_full_id_nand(struct nand_chip *chip,\n\t\t\t      struct nand_flash_dev *type)\n{\n\tstruct nand_device *base = &chip->base;\n\tstruct nand_ecc_props requirements;\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tstruct nand_memory_organization *memorg;\n\tu8 *id_data = chip->id.data;\n\n\tmemorg = nanddev_get_memorg(&chip->base);\n\n\tif (!strncmp(type->id, id_data, type->id_len)) {\n\t\tmemorg->pagesize = type->pagesize;\n\t\tmtd->writesize = memorg->pagesize;\n\t\tmemorg->pages_per_eraseblock = type->erasesize /\n\t\t\t\t\t       type->pagesize;\n\t\tmtd->erasesize = type->erasesize;\n\t\tmemorg->oobsize = type->oobsize;\n\t\tmtd->oobsize = memorg->oobsize;\n\n\t\tmemorg->bits_per_cell = nand_get_bits_per_cell(id_data[2]);\n\t\tmemorg->eraseblocks_per_lun =\n\t\t\tDIV_ROUND_DOWN_ULL((u64)type->chipsize << 20,\n\t\t\t\t\t   memorg->pagesize *\n\t\t\t\t\t   memorg->pages_per_eraseblock);\n\t\tchip->options |= type->options;\n\t\trequirements.strength = NAND_ECC_STRENGTH(type);\n\t\trequirements.step_size = NAND_ECC_STEP(type);\n\t\tnanddev_set_ecc_requirements(base, &requirements);\n\n\t\tchip->parameters.model = kstrdup(type->name, GFP_KERNEL);\n\t\tif (!chip->parameters.model)\n\t\t\treturn false;\n\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n \nstatic void nand_manufacturer_detect(struct nand_chip *chip)\n{\n\t \n\tif (chip->manufacturer.desc && chip->manufacturer.desc->ops &&\n\t    chip->manufacturer.desc->ops->detect) {\n\t\tstruct nand_memory_organization *memorg;\n\n\t\tmemorg = nanddev_get_memorg(&chip->base);\n\n\t\t \n\t\tmemorg->bits_per_cell = nand_get_bits_per_cell(chip->id.data[2]);\n\t\tchip->manufacturer.desc->ops->detect(chip);\n\t} else {\n\t\tnand_decode_ext_id(chip);\n\t}\n}\n\n \nstatic int nand_manufacturer_init(struct nand_chip *chip)\n{\n\tif (!chip->manufacturer.desc || !chip->manufacturer.desc->ops ||\n\t    !chip->manufacturer.desc->ops->init)\n\t\treturn 0;\n\n\treturn chip->manufacturer.desc->ops->init(chip);\n}\n\n \nstatic void nand_manufacturer_cleanup(struct nand_chip *chip)\n{\n\t \n\tif (chip->manufacturer.desc && chip->manufacturer.desc->ops &&\n\t    chip->manufacturer.desc->ops->cleanup)\n\t\tchip->manufacturer.desc->ops->cleanup(chip);\n}\n\nstatic const char *\nnand_manufacturer_name(const struct nand_manufacturer_desc *manufacturer_desc)\n{\n\treturn manufacturer_desc ? manufacturer_desc->name : \"Unknown\";\n}\n\nstatic void rawnand_check_data_only_read_support(struct nand_chip *chip)\n{\n\t \n\tif (!nand_read_data_op(chip, NULL, SZ_512, true, true))\n\t\tchip->controller->supported_op.data_only_read = 1;\n}\n\nstatic void rawnand_early_check_supported_ops(struct nand_chip *chip)\n{\n\t \n\tWARN_ON_ONCE(chip->controller->supported_op.data_only_read);\n\n\tif (!nand_has_exec_op(chip))\n\t\treturn;\n\n\trawnand_check_data_only_read_support(chip);\n}\n\nstatic void rawnand_check_cont_read_support(struct nand_chip *chip)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\n\tif (!chip->parameters.supports_read_cache)\n\t\treturn;\n\n\tif (chip->read_retries)\n\t\treturn;\n\n\tif (!nand_lp_exec_cont_read_page_op(chip, 0, 0, NULL,\n\t\t\t\t\t    mtd->writesize, true))\n\t\tchip->controller->supported_op.cont_read = 1;\n}\n\nstatic void rawnand_late_check_supported_ops(struct nand_chip *chip)\n{\n\t \n\tWARN_ON_ONCE(chip->controller->supported_op.cont_read);\n\n\tif (!nand_has_exec_op(chip))\n\t\treturn;\n\n\trawnand_check_cont_read_support(chip);\n}\n\n \nstatic int nand_detect(struct nand_chip *chip, struct nand_flash_dev *type)\n{\n\tconst struct nand_manufacturer_desc *manufacturer_desc;\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tstruct nand_memory_organization *memorg;\n\tint busw, ret;\n\tu8 *id_data = chip->id.data;\n\tu8 maf_id, dev_id;\n\tu64 targetsize;\n\n\t \n\tmemorg = nanddev_get_memorg(&chip->base);\n\tmemorg->planes_per_lun = 1;\n\tmemorg->luns_per_target = 1;\n\n\t \n\tret = nand_reset(chip, 0);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tnand_select_target(chip, 0);\n\n\trawnand_early_check_supported_ops(chip);\n\n\t \n\tret = nand_readid_op(chip, 0, id_data, 2);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tmaf_id = id_data[0];\n\tdev_id = id_data[1];\n\n\t \n\n\t \n\tret = nand_readid_op(chip, 0, id_data, sizeof(chip->id.data));\n\tif (ret)\n\t\treturn ret;\n\n\tif (id_data[0] != maf_id || id_data[1] != dev_id) {\n\t\tpr_info(\"second ID read did not match %02x,%02x against %02x,%02x\\n\",\n\t\t\tmaf_id, dev_id, id_data[0], id_data[1]);\n\t\treturn -ENODEV;\n\t}\n\n\tchip->id.len = nand_id_len(id_data, ARRAY_SIZE(chip->id.data));\n\n\t \n\tmanufacturer_desc = nand_get_manufacturer_desc(maf_id);\n\tchip->manufacturer.desc = manufacturer_desc;\n\n\tif (!type)\n\t\ttype = nand_flash_ids;\n\n\t \n\tbusw = chip->options & NAND_BUSWIDTH_16;\n\n\t \n\tchip->options &= ~NAND_BUSWIDTH_16;\n\n\tfor (; type->name != NULL; type++) {\n\t\tif (is_full_id_nand(type)) {\n\t\t\tif (find_full_id_nand(chip, type))\n\t\t\t\tgoto ident_done;\n\t\t} else if (dev_id == type->dev_id) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!type->name || !type->pagesize) {\n\t\t \n\t\tret = nand_onfi_detect(chip);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\telse if (ret)\n\t\t\tgoto ident_done;\n\n\t\t \n\t\tret = nand_jedec_detect(chip);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\telse if (ret)\n\t\t\tgoto ident_done;\n\t}\n\n\tif (!type->name)\n\t\treturn -ENODEV;\n\n\tchip->parameters.model = kstrdup(type->name, GFP_KERNEL);\n\tif (!chip->parameters.model)\n\t\treturn -ENOMEM;\n\n\tif (!type->pagesize)\n\t\tnand_manufacturer_detect(chip);\n\telse\n\t\tnand_decode_id(chip, type);\n\n\t \n\tchip->options |= type->options;\n\n\tmemorg->eraseblocks_per_lun =\n\t\t\tDIV_ROUND_DOWN_ULL((u64)type->chipsize << 20,\n\t\t\t\t\t   memorg->pagesize *\n\t\t\t\t\t   memorg->pages_per_eraseblock);\n\nident_done:\n\tif (!mtd->name)\n\t\tmtd->name = chip->parameters.model;\n\n\tif (chip->options & NAND_BUSWIDTH_AUTO) {\n\t\tWARN_ON(busw & NAND_BUSWIDTH_16);\n\t\tnand_set_defaults(chip);\n\t} else if (busw != (chip->options & NAND_BUSWIDTH_16)) {\n\t\t \n\t\tpr_info(\"device found, Manufacturer ID: 0x%02x, Chip ID: 0x%02x\\n\",\n\t\t\tmaf_id, dev_id);\n\t\tpr_info(\"%s %s\\n\", nand_manufacturer_name(manufacturer_desc),\n\t\t\tmtd->name);\n\t\tpr_warn(\"bus width %d instead of %d bits\\n\", busw ? 16 : 8,\n\t\t\t(chip->options & NAND_BUSWIDTH_16) ? 16 : 8);\n\t\tret = -EINVAL;\n\n\t\tgoto free_detect_allocation;\n\t}\n\n\tnand_decode_bbm_options(chip);\n\n\t \n\tchip->page_shift = ffs(mtd->writesize) - 1;\n\t \n\ttargetsize = nanddev_target_size(&chip->base);\n\tchip->pagemask = (targetsize >> chip->page_shift) - 1;\n\n\tchip->bbt_erase_shift = chip->phys_erase_shift =\n\t\tffs(mtd->erasesize) - 1;\n\tif (targetsize & 0xffffffff)\n\t\tchip->chip_shift = ffs((unsigned)targetsize) - 1;\n\telse {\n\t\tchip->chip_shift = ffs((unsigned)(targetsize >> 32));\n\t\tchip->chip_shift += 32 - 1;\n\t}\n\n\tif (chip->chip_shift - chip->page_shift > 16)\n\t\tchip->options |= NAND_ROW_ADDR_3;\n\n\tchip->badblockbits = 8;\n\n\tnand_legacy_adjust_cmdfunc(chip);\n\n\tpr_info(\"device found, Manufacturer ID: 0x%02x, Chip ID: 0x%02x\\n\",\n\t\tmaf_id, dev_id);\n\tpr_info(\"%s %s\\n\", nand_manufacturer_name(manufacturer_desc),\n\t\tchip->parameters.model);\n\tpr_info(\"%d MiB, %s, erase size: %d KiB, page size: %d, OOB size: %d\\n\",\n\t\t(int)(targetsize >> 20), nand_is_slc(chip) ? \"SLC\" : \"MLC\",\n\t\tmtd->erasesize >> 10, mtd->writesize, mtd->oobsize);\n\treturn 0;\n\nfree_detect_allocation:\n\tkfree(chip->parameters.model);\n\n\treturn ret;\n}\n\nstatic enum nand_ecc_engine_type\nof_get_rawnand_ecc_engine_type_legacy(struct device_node *np)\n{\n\tenum nand_ecc_legacy_mode {\n\t\tNAND_ECC_INVALID,\n\t\tNAND_ECC_NONE,\n\t\tNAND_ECC_SOFT,\n\t\tNAND_ECC_SOFT_BCH,\n\t\tNAND_ECC_HW,\n\t\tNAND_ECC_HW_SYNDROME,\n\t\tNAND_ECC_ON_DIE,\n\t};\n\tconst char * const nand_ecc_legacy_modes[] = {\n\t\t[NAND_ECC_NONE]\t\t= \"none\",\n\t\t[NAND_ECC_SOFT]\t\t= \"soft\",\n\t\t[NAND_ECC_SOFT_BCH]\t= \"soft_bch\",\n\t\t[NAND_ECC_HW]\t\t= \"hw\",\n\t\t[NAND_ECC_HW_SYNDROME]\t= \"hw_syndrome\",\n\t\t[NAND_ECC_ON_DIE]\t= \"on-die\",\n\t};\n\tenum nand_ecc_legacy_mode eng_type;\n\tconst char *pm;\n\tint err;\n\n\terr = of_property_read_string(np, \"nand-ecc-mode\", &pm);\n\tif (err)\n\t\treturn NAND_ECC_ENGINE_TYPE_INVALID;\n\n\tfor (eng_type = NAND_ECC_NONE;\n\t     eng_type < ARRAY_SIZE(nand_ecc_legacy_modes); eng_type++) {\n\t\tif (!strcasecmp(pm, nand_ecc_legacy_modes[eng_type])) {\n\t\t\tswitch (eng_type) {\n\t\t\tcase NAND_ECC_NONE:\n\t\t\t\treturn NAND_ECC_ENGINE_TYPE_NONE;\n\t\t\tcase NAND_ECC_SOFT:\n\t\t\tcase NAND_ECC_SOFT_BCH:\n\t\t\t\treturn NAND_ECC_ENGINE_TYPE_SOFT;\n\t\t\tcase NAND_ECC_HW:\n\t\t\tcase NAND_ECC_HW_SYNDROME:\n\t\t\t\treturn NAND_ECC_ENGINE_TYPE_ON_HOST;\n\t\t\tcase NAND_ECC_ON_DIE:\n\t\t\t\treturn NAND_ECC_ENGINE_TYPE_ON_DIE;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn NAND_ECC_ENGINE_TYPE_INVALID;\n}\n\nstatic enum nand_ecc_placement\nof_get_rawnand_ecc_placement_legacy(struct device_node *np)\n{\n\tconst char *pm;\n\tint err;\n\n\terr = of_property_read_string(np, \"nand-ecc-mode\", &pm);\n\tif (!err) {\n\t\tif (!strcasecmp(pm, \"hw_syndrome\"))\n\t\t\treturn NAND_ECC_PLACEMENT_INTERLEAVED;\n\t}\n\n\treturn NAND_ECC_PLACEMENT_UNKNOWN;\n}\n\nstatic enum nand_ecc_algo of_get_rawnand_ecc_algo_legacy(struct device_node *np)\n{\n\tconst char *pm;\n\tint err;\n\n\terr = of_property_read_string(np, \"nand-ecc-mode\", &pm);\n\tif (!err) {\n\t\tif (!strcasecmp(pm, \"soft\"))\n\t\t\treturn NAND_ECC_ALGO_HAMMING;\n\t\telse if (!strcasecmp(pm, \"soft_bch\"))\n\t\t\treturn NAND_ECC_ALGO_BCH;\n\t}\n\n\treturn NAND_ECC_ALGO_UNKNOWN;\n}\n\nstatic void of_get_nand_ecc_legacy_user_config(struct nand_chip *chip)\n{\n\tstruct device_node *dn = nand_get_flash_node(chip);\n\tstruct nand_ecc_props *user_conf = &chip->base.ecc.user_conf;\n\n\tif (user_conf->engine_type == NAND_ECC_ENGINE_TYPE_INVALID)\n\t\tuser_conf->engine_type = of_get_rawnand_ecc_engine_type_legacy(dn);\n\n\tif (user_conf->algo == NAND_ECC_ALGO_UNKNOWN)\n\t\tuser_conf->algo = of_get_rawnand_ecc_algo_legacy(dn);\n\n\tif (user_conf->placement == NAND_ECC_PLACEMENT_UNKNOWN)\n\t\tuser_conf->placement = of_get_rawnand_ecc_placement_legacy(dn);\n}\n\nstatic int of_get_nand_bus_width(struct nand_chip *chip)\n{\n\tstruct device_node *dn = nand_get_flash_node(chip);\n\tu32 val;\n\tint ret;\n\n\tret = of_property_read_u32(dn, \"nand-bus-width\", &val);\n\tif (ret == -EINVAL)\n\t\t \n\t\treturn 0;\n\telse if (ret)\n\t\treturn ret;\n\n\tif (val == 16)\n\t\tchip->options |= NAND_BUSWIDTH_16;\n\telse if (val != 8)\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\nstatic int of_get_nand_secure_regions(struct nand_chip *chip)\n{\n\tstruct device_node *dn = nand_get_flash_node(chip);\n\tstruct property *prop;\n\tint nr_elem, i, j;\n\n\t \n\tprop = of_find_property(dn, \"secure-regions\", NULL);\n\tif (!prop)\n\t\treturn 0;\n\n\tnr_elem = of_property_count_elems_of_size(dn, \"secure-regions\", sizeof(u64));\n\tif (nr_elem <= 0)\n\t\treturn nr_elem;\n\n\tchip->nr_secure_regions = nr_elem / 2;\n\tchip->secure_regions = kcalloc(chip->nr_secure_regions, sizeof(*chip->secure_regions),\n\t\t\t\t       GFP_KERNEL);\n\tif (!chip->secure_regions)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0, j = 0; i < chip->nr_secure_regions; i++, j += 2) {\n\t\tof_property_read_u64_index(dn, \"secure-regions\", j,\n\t\t\t\t\t   &chip->secure_regions[i].offset);\n\t\tof_property_read_u64_index(dn, \"secure-regions\", j + 1,\n\t\t\t\t\t   &chip->secure_regions[i].size);\n\t}\n\n\treturn 0;\n}\n\n \nint rawnand_dt_parse_gpio_cs(struct device *dev, struct gpio_desc ***cs_array,\n\t\t\t     unsigned int *ncs_array)\n{\n\tstruct gpio_desc **descs;\n\tint ndescs, i;\n\n\tndescs = gpiod_count(dev, \"cs\");\n\tif (ndescs < 0) {\n\t\tdev_dbg(dev, \"No valid cs-gpios property\\n\");\n\t\treturn 0;\n\t}\n\n\tdescs = devm_kcalloc(dev, ndescs, sizeof(*descs), GFP_KERNEL);\n\tif (!descs)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < ndescs; i++) {\n\t\tdescs[i] = gpiod_get_index_optional(dev, \"cs\", i,\n\t\t\t\t\t\t    GPIOD_OUT_HIGH);\n\t\tif (IS_ERR(descs[i]))\n\t\t\treturn PTR_ERR(descs[i]);\n\t}\n\n\t*ncs_array = ndescs;\n\t*cs_array = descs;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(rawnand_dt_parse_gpio_cs);\n\nstatic int rawnand_dt_init(struct nand_chip *chip)\n{\n\tstruct nand_device *nand = mtd_to_nanddev(nand_to_mtd(chip));\n\tstruct device_node *dn = nand_get_flash_node(chip);\n\tint ret;\n\n\tif (!dn)\n\t\treturn 0;\n\n\tret = of_get_nand_bus_width(chip);\n\tif (ret)\n\t\treturn ret;\n\n\tif (of_property_read_bool(dn, \"nand-is-boot-medium\"))\n\t\tchip->options |= NAND_IS_BOOT_MEDIUM;\n\n\tif (of_property_read_bool(dn, \"nand-on-flash-bbt\"))\n\t\tchip->bbt_options |= NAND_BBT_USE_FLASH;\n\n\tof_get_nand_ecc_user_config(nand);\n\tof_get_nand_ecc_legacy_user_config(chip);\n\n\t \n\tnand->ecc.defaults.engine_type = NAND_ECC_ENGINE_TYPE_ON_HOST;\n\n\t \n\tif (nand->ecc.user_conf.engine_type != NAND_ECC_ENGINE_TYPE_INVALID)\n\t\tchip->ecc.engine_type = nand->ecc.user_conf.engine_type;\n\tif (chip->ecc.engine_type == NAND_ECC_ENGINE_TYPE_INVALID)\n\t\tchip->ecc.engine_type = nand->ecc.defaults.engine_type;\n\n\tchip->ecc.placement = nand->ecc.user_conf.placement;\n\tchip->ecc.algo = nand->ecc.user_conf.algo;\n\tchip->ecc.strength = nand->ecc.user_conf.strength;\n\tchip->ecc.size = nand->ecc.user_conf.step_size;\n\n\treturn 0;\n}\n\n \nstatic int nand_scan_ident(struct nand_chip *chip, unsigned int maxchips,\n\t\t\t   struct nand_flash_dev *table)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tstruct nand_memory_organization *memorg;\n\tint nand_maf_id, nand_dev_id;\n\tunsigned int i;\n\tint ret;\n\n\tmemorg = nanddev_get_memorg(&chip->base);\n\n\t \n\tchip->cur_cs = -1;\n\n\tmutex_init(&chip->lock);\n\tinit_waitqueue_head(&chip->resume_wq);\n\n\t \n\tchip->current_interface_config = nand_get_reset_interface_config();\n\n\tret = rawnand_dt_init(chip);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!mtd->name && mtd->dev.parent)\n\t\tmtd->name = dev_name(mtd->dev.parent);\n\n\t \n\tnand_set_defaults(chip);\n\n\tret = nand_legacy_check_hooks(chip);\n\tif (ret)\n\t\treturn ret;\n\n\tmemorg->ntargets = maxchips;\n\n\t \n\tret = nand_detect(chip, table);\n\tif (ret) {\n\t\tif (!(chip->options & NAND_SCAN_SILENT_NODEV))\n\t\t\tpr_warn(\"No NAND device found\\n\");\n\t\tnand_deselect_target(chip);\n\t\treturn ret;\n\t}\n\n\tnand_maf_id = chip->id.data[0];\n\tnand_dev_id = chip->id.data[1];\n\n\tnand_deselect_target(chip);\n\n\t \n\tfor (i = 1; i < maxchips; i++) {\n\t\tu8 id[2];\n\n\t\t \n\t\tret = nand_reset(chip, i);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tnand_select_target(chip, i);\n\t\t \n\t\tret = nand_readid_op(chip, 0, id, sizeof(id));\n\t\tif (ret)\n\t\t\tbreak;\n\t\t \n\t\tif (nand_maf_id != id[0] || nand_dev_id != id[1]) {\n\t\t\tnand_deselect_target(chip);\n\t\t\tbreak;\n\t\t}\n\t\tnand_deselect_target(chip);\n\t}\n\tif (i > 1)\n\t\tpr_info(\"%d chips detected\\n\", i);\n\n\t \n\tmemorg->ntargets = i;\n\tmtd->size = i * nanddev_target_size(&chip->base);\n\n\treturn 0;\n}\n\nstatic void nand_scan_ident_cleanup(struct nand_chip *chip)\n{\n\tkfree(chip->parameters.model);\n\tkfree(chip->parameters.onfi);\n}\n\nint rawnand_sw_hamming_init(struct nand_chip *chip)\n{\n\tstruct nand_ecc_sw_hamming_conf *engine_conf;\n\tstruct nand_device *base = &chip->base;\n\tint ret;\n\n\tbase->ecc.user_conf.engine_type = NAND_ECC_ENGINE_TYPE_SOFT;\n\tbase->ecc.user_conf.algo = NAND_ECC_ALGO_HAMMING;\n\tbase->ecc.user_conf.strength = chip->ecc.strength;\n\tbase->ecc.user_conf.step_size = chip->ecc.size;\n\n\tret = nand_ecc_sw_hamming_init_ctx(base);\n\tif (ret)\n\t\treturn ret;\n\n\tengine_conf = base->ecc.ctx.priv;\n\n\tif (chip->ecc.options & NAND_ECC_SOFT_HAMMING_SM_ORDER)\n\t\tengine_conf->sm_order = true;\n\n\tchip->ecc.size = base->ecc.ctx.conf.step_size;\n\tchip->ecc.strength = base->ecc.ctx.conf.strength;\n\tchip->ecc.total = base->ecc.ctx.total;\n\tchip->ecc.steps = nanddev_get_ecc_nsteps(base);\n\tchip->ecc.bytes = base->ecc.ctx.total / nanddev_get_ecc_nsteps(base);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(rawnand_sw_hamming_init);\n\nint rawnand_sw_hamming_calculate(struct nand_chip *chip,\n\t\t\t\t const unsigned char *buf,\n\t\t\t\t unsigned char *code)\n{\n\tstruct nand_device *base = &chip->base;\n\n\treturn nand_ecc_sw_hamming_calculate(base, buf, code);\n}\nEXPORT_SYMBOL(rawnand_sw_hamming_calculate);\n\nint rawnand_sw_hamming_correct(struct nand_chip *chip,\n\t\t\t       unsigned char *buf,\n\t\t\t       unsigned char *read_ecc,\n\t\t\t       unsigned char *calc_ecc)\n{\n\tstruct nand_device *base = &chip->base;\n\n\treturn nand_ecc_sw_hamming_correct(base, buf, read_ecc, calc_ecc);\n}\nEXPORT_SYMBOL(rawnand_sw_hamming_correct);\n\nvoid rawnand_sw_hamming_cleanup(struct nand_chip *chip)\n{\n\tstruct nand_device *base = &chip->base;\n\n\tnand_ecc_sw_hamming_cleanup_ctx(base);\n}\nEXPORT_SYMBOL(rawnand_sw_hamming_cleanup);\n\nint rawnand_sw_bch_init(struct nand_chip *chip)\n{\n\tstruct nand_device *base = &chip->base;\n\tconst struct nand_ecc_props *ecc_conf = nanddev_get_ecc_conf(base);\n\tint ret;\n\n\tbase->ecc.user_conf.engine_type = NAND_ECC_ENGINE_TYPE_SOFT;\n\tbase->ecc.user_conf.algo = NAND_ECC_ALGO_BCH;\n\tbase->ecc.user_conf.step_size = chip->ecc.size;\n\tbase->ecc.user_conf.strength = chip->ecc.strength;\n\n\tret = nand_ecc_sw_bch_init_ctx(base);\n\tif (ret)\n\t\treturn ret;\n\n\tchip->ecc.size = ecc_conf->step_size;\n\tchip->ecc.strength = ecc_conf->strength;\n\tchip->ecc.total = base->ecc.ctx.total;\n\tchip->ecc.steps = nanddev_get_ecc_nsteps(base);\n\tchip->ecc.bytes = base->ecc.ctx.total / nanddev_get_ecc_nsteps(base);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(rawnand_sw_bch_init);\n\nstatic int rawnand_sw_bch_calculate(struct nand_chip *chip,\n\t\t\t\t    const unsigned char *buf,\n\t\t\t\t    unsigned char *code)\n{\n\tstruct nand_device *base = &chip->base;\n\n\treturn nand_ecc_sw_bch_calculate(base, buf, code);\n}\n\nint rawnand_sw_bch_correct(struct nand_chip *chip, unsigned char *buf,\n\t\t\t   unsigned char *read_ecc, unsigned char *calc_ecc)\n{\n\tstruct nand_device *base = &chip->base;\n\n\treturn nand_ecc_sw_bch_correct(base, buf, read_ecc, calc_ecc);\n}\nEXPORT_SYMBOL(rawnand_sw_bch_correct);\n\nvoid rawnand_sw_bch_cleanup(struct nand_chip *chip)\n{\n\tstruct nand_device *base = &chip->base;\n\n\tnand_ecc_sw_bch_cleanup_ctx(base);\n}\nEXPORT_SYMBOL(rawnand_sw_bch_cleanup);\n\nstatic int nand_set_ecc_on_host_ops(struct nand_chip *chip)\n{\n\tstruct nand_ecc_ctrl *ecc = &chip->ecc;\n\n\tswitch (ecc->placement) {\n\tcase NAND_ECC_PLACEMENT_UNKNOWN:\n\tcase NAND_ECC_PLACEMENT_OOB:\n\t\t \n\t\tif (!ecc->read_page)\n\t\t\tecc->read_page = nand_read_page_hwecc;\n\t\tif (!ecc->write_page)\n\t\t\tecc->write_page = nand_write_page_hwecc;\n\t\tif (!ecc->read_page_raw)\n\t\t\tecc->read_page_raw = nand_read_page_raw;\n\t\tif (!ecc->write_page_raw)\n\t\t\tecc->write_page_raw = nand_write_page_raw;\n\t\tif (!ecc->read_oob)\n\t\t\tecc->read_oob = nand_read_oob_std;\n\t\tif (!ecc->write_oob)\n\t\t\tecc->write_oob = nand_write_oob_std;\n\t\tif (!ecc->read_subpage)\n\t\t\tecc->read_subpage = nand_read_subpage;\n\t\tif (!ecc->write_subpage && ecc->hwctl && ecc->calculate)\n\t\t\tecc->write_subpage = nand_write_subpage_hwecc;\n\t\tfallthrough;\n\n\tcase NAND_ECC_PLACEMENT_INTERLEAVED:\n\t\tif ((!ecc->calculate || !ecc->correct || !ecc->hwctl) &&\n\t\t    (!ecc->read_page ||\n\t\t     ecc->read_page == nand_read_page_hwecc ||\n\t\t     !ecc->write_page ||\n\t\t     ecc->write_page == nand_write_page_hwecc)) {\n\t\t\tWARN(1, \"No ECC functions supplied; hardware ECC not possible\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t \n\t\tif (!ecc->read_page)\n\t\t\tecc->read_page = nand_read_page_syndrome;\n\t\tif (!ecc->write_page)\n\t\t\tecc->write_page = nand_write_page_syndrome;\n\t\tif (!ecc->read_page_raw)\n\t\t\tecc->read_page_raw = nand_read_page_raw_syndrome;\n\t\tif (!ecc->write_page_raw)\n\t\t\tecc->write_page_raw = nand_write_page_raw_syndrome;\n\t\tif (!ecc->read_oob)\n\t\t\tecc->read_oob = nand_read_oob_syndrome;\n\t\tif (!ecc->write_oob)\n\t\t\tecc->write_oob = nand_write_oob_syndrome;\n\t\tbreak;\n\n\tdefault:\n\t\tpr_warn(\"Invalid NAND_ECC_PLACEMENT %d\\n\",\n\t\t\tecc->placement);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int nand_set_ecc_soft_ops(struct nand_chip *chip)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tstruct nand_device *nanddev = mtd_to_nanddev(mtd);\n\tstruct nand_ecc_ctrl *ecc = &chip->ecc;\n\tint ret;\n\n\tif (WARN_ON(ecc->engine_type != NAND_ECC_ENGINE_TYPE_SOFT))\n\t\treturn -EINVAL;\n\n\tswitch (ecc->algo) {\n\tcase NAND_ECC_ALGO_HAMMING:\n\t\tecc->calculate = rawnand_sw_hamming_calculate;\n\t\tecc->correct = rawnand_sw_hamming_correct;\n\t\tecc->read_page = nand_read_page_swecc;\n\t\tecc->read_subpage = nand_read_subpage;\n\t\tecc->write_page = nand_write_page_swecc;\n\t\tif (!ecc->read_page_raw)\n\t\t\tecc->read_page_raw = nand_read_page_raw;\n\t\tif (!ecc->write_page_raw)\n\t\t\tecc->write_page_raw = nand_write_page_raw;\n\t\tecc->read_oob = nand_read_oob_std;\n\t\tecc->write_oob = nand_write_oob_std;\n\t\tif (!ecc->size)\n\t\t\tecc->size = 256;\n\t\tecc->bytes = 3;\n\t\tecc->strength = 1;\n\n\t\tif (IS_ENABLED(CONFIG_MTD_NAND_ECC_SW_HAMMING_SMC))\n\t\t\tecc->options |= NAND_ECC_SOFT_HAMMING_SM_ORDER;\n\n\t\tret = rawnand_sw_hamming_init(chip);\n\t\tif (ret) {\n\t\t\tWARN(1, \"Hamming ECC initialization failed!\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\treturn 0;\n\tcase NAND_ECC_ALGO_BCH:\n\t\tif (!IS_ENABLED(CONFIG_MTD_NAND_ECC_SW_BCH)) {\n\t\t\tWARN(1, \"CONFIG_MTD_NAND_ECC_SW_BCH not enabled\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tecc->calculate = rawnand_sw_bch_calculate;\n\t\tecc->correct = rawnand_sw_bch_correct;\n\t\tecc->read_page = nand_read_page_swecc;\n\t\tecc->read_subpage = nand_read_subpage;\n\t\tecc->write_page = nand_write_page_swecc;\n\t\tif (!ecc->read_page_raw)\n\t\t\tecc->read_page_raw = nand_read_page_raw;\n\t\tif (!ecc->write_page_raw)\n\t\t\tecc->write_page_raw = nand_write_page_raw;\n\t\tecc->read_oob = nand_read_oob_std;\n\t\tecc->write_oob = nand_write_oob_std;\n\n\t\t \n\t\tif (nanddev->ecc.user_conf.flags & NAND_ECC_MAXIMIZE_STRENGTH &&\n\t\t    mtd->ooblayout != nand_get_large_page_ooblayout())\n\t\t\tnanddev->ecc.user_conf.flags &= ~NAND_ECC_MAXIMIZE_STRENGTH;\n\n\t\tret = rawnand_sw_bch_init(chip);\n\t\tif (ret) {\n\t\t\tWARN(1, \"BCH ECC initialization failed!\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\treturn 0;\n\tdefault:\n\t\tWARN(1, \"Unsupported ECC algorithm!\\n\");\n\t\treturn -EINVAL;\n\t}\n}\n\n \nstatic int\nnand_check_ecc_caps(struct nand_chip *chip,\n\t\t    const struct nand_ecc_caps *caps, int oobavail)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tconst struct nand_ecc_step_info *stepinfo;\n\tint preset_step = chip->ecc.size;\n\tint preset_strength = chip->ecc.strength;\n\tint ecc_bytes, nsteps = mtd->writesize / preset_step;\n\tint i, j;\n\n\tfor (i = 0; i < caps->nstepinfos; i++) {\n\t\tstepinfo = &caps->stepinfos[i];\n\n\t\tif (stepinfo->stepsize != preset_step)\n\t\t\tcontinue;\n\n\t\tfor (j = 0; j < stepinfo->nstrengths; j++) {\n\t\t\tif (stepinfo->strengths[j] != preset_strength)\n\t\t\t\tcontinue;\n\n\t\t\tecc_bytes = caps->calc_ecc_bytes(preset_step,\n\t\t\t\t\t\t\t preset_strength);\n\t\t\tif (WARN_ON_ONCE(ecc_bytes < 0))\n\t\t\t\treturn ecc_bytes;\n\n\t\t\tif (ecc_bytes * nsteps > oobavail) {\n\t\t\t\tpr_err(\"ECC (step, strength) = (%d, %d) does not fit in OOB\",\n\t\t\t\t       preset_step, preset_strength);\n\t\t\t\treturn -ENOSPC;\n\t\t\t}\n\n\t\t\tchip->ecc.bytes = ecc_bytes;\n\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tpr_err(\"ECC (step, strength) = (%d, %d) not supported on this controller\",\n\t       preset_step, preset_strength);\n\n\treturn -ENOTSUPP;\n}\n\n \nstatic int\nnand_match_ecc_req(struct nand_chip *chip,\n\t\t   const struct nand_ecc_caps *caps, int oobavail)\n{\n\tconst struct nand_ecc_props *requirements =\n\t\tnanddev_get_ecc_requirements(&chip->base);\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tconst struct nand_ecc_step_info *stepinfo;\n\tint req_step = requirements->step_size;\n\tint req_strength = requirements->strength;\n\tint req_corr, step_size, strength, nsteps, ecc_bytes, ecc_bytes_total;\n\tint best_step = 0, best_strength = 0, best_ecc_bytes = 0;\n\tint best_ecc_bytes_total = INT_MAX;\n\tint i, j;\n\n\t \n\tif (!req_step || !req_strength)\n\t\treturn -ENOTSUPP;\n\n\t \n\treq_corr = mtd->writesize / req_step * req_strength;\n\n\tfor (i = 0; i < caps->nstepinfos; i++) {\n\t\tstepinfo = &caps->stepinfos[i];\n\t\tstep_size = stepinfo->stepsize;\n\n\t\tfor (j = 0; j < stepinfo->nstrengths; j++) {\n\t\t\tstrength = stepinfo->strengths[j];\n\n\t\t\t \n\t\t\tif (step_size < req_step && strength < req_strength)\n\t\t\t\tcontinue;\n\n\t\t\tif (mtd->writesize % step_size)\n\t\t\t\tcontinue;\n\n\t\t\tnsteps = mtd->writesize / step_size;\n\n\t\t\tecc_bytes = caps->calc_ecc_bytes(step_size, strength);\n\t\t\tif (WARN_ON_ONCE(ecc_bytes < 0))\n\t\t\t\tcontinue;\n\t\t\tecc_bytes_total = ecc_bytes * nsteps;\n\n\t\t\tif (ecc_bytes_total > oobavail ||\n\t\t\t    strength * nsteps < req_corr)\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tif (ecc_bytes_total < best_ecc_bytes_total) {\n\t\t\t\tbest_ecc_bytes_total = ecc_bytes_total;\n\t\t\t\tbest_step = step_size;\n\t\t\t\tbest_strength = strength;\n\t\t\t\tbest_ecc_bytes = ecc_bytes;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (best_ecc_bytes_total == INT_MAX)\n\t\treturn -ENOTSUPP;\n\n\tchip->ecc.size = best_step;\n\tchip->ecc.strength = best_strength;\n\tchip->ecc.bytes = best_ecc_bytes;\n\n\treturn 0;\n}\n\n \nstatic int\nnand_maximize_ecc(struct nand_chip *chip,\n\t\t  const struct nand_ecc_caps *caps, int oobavail)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tconst struct nand_ecc_step_info *stepinfo;\n\tint step_size, strength, nsteps, ecc_bytes, corr;\n\tint best_corr = 0;\n\tint best_step = 0;\n\tint best_strength = 0, best_ecc_bytes = 0;\n\tint i, j;\n\n\tfor (i = 0; i < caps->nstepinfos; i++) {\n\t\tstepinfo = &caps->stepinfos[i];\n\t\tstep_size = stepinfo->stepsize;\n\n\t\t \n\t\tif (chip->ecc.size && step_size != chip->ecc.size)\n\t\t\tcontinue;\n\n\t\tfor (j = 0; j < stepinfo->nstrengths; j++) {\n\t\t\tstrength = stepinfo->strengths[j];\n\n\t\t\tif (mtd->writesize % step_size)\n\t\t\t\tcontinue;\n\n\t\t\tnsteps = mtd->writesize / step_size;\n\n\t\t\tecc_bytes = caps->calc_ecc_bytes(step_size, strength);\n\t\t\tif (WARN_ON_ONCE(ecc_bytes < 0))\n\t\t\t\tcontinue;\n\n\t\t\tif (ecc_bytes * nsteps > oobavail)\n\t\t\t\tcontinue;\n\n\t\t\tcorr = strength * nsteps;\n\n\t\t\t \n\t\t\tif (corr > best_corr ||\n\t\t\t    (corr == best_corr && step_size > best_step)) {\n\t\t\t\tbest_corr = corr;\n\t\t\t\tbest_step = step_size;\n\t\t\t\tbest_strength = strength;\n\t\t\t\tbest_ecc_bytes = ecc_bytes;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!best_corr)\n\t\treturn -ENOTSUPP;\n\n\tchip->ecc.size = best_step;\n\tchip->ecc.strength = best_strength;\n\tchip->ecc.bytes = best_ecc_bytes;\n\n\treturn 0;\n}\n\n \nint nand_ecc_choose_conf(struct nand_chip *chip,\n\t\t\t const struct nand_ecc_caps *caps, int oobavail)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tstruct nand_device *nanddev = mtd_to_nanddev(mtd);\n\n\tif (WARN_ON(oobavail < 0 || oobavail > mtd->oobsize))\n\t\treturn -EINVAL;\n\n\tif (chip->ecc.size && chip->ecc.strength)\n\t\treturn nand_check_ecc_caps(chip, caps, oobavail);\n\n\tif (nanddev->ecc.user_conf.flags & NAND_ECC_MAXIMIZE_STRENGTH)\n\t\treturn nand_maximize_ecc(chip, caps, oobavail);\n\n\tif (!nand_match_ecc_req(chip, caps, oobavail))\n\t\treturn 0;\n\n\treturn nand_maximize_ecc(chip, caps, oobavail);\n}\nEXPORT_SYMBOL_GPL(nand_ecc_choose_conf);\n\nstatic int rawnand_erase(struct nand_device *nand, const struct nand_pos *pos)\n{\n\tstruct nand_chip *chip = container_of(nand, struct nand_chip,\n\t\t\t\t\t      base);\n\tunsigned int eb = nanddev_pos_to_row(nand, pos);\n\tint ret;\n\n\teb >>= nand->rowconv.eraseblock_addr_shift;\n\n\tnand_select_target(chip, pos->target);\n\tret = nand_erase_op(chip, eb);\n\tnand_deselect_target(chip);\n\n\treturn ret;\n}\n\nstatic int rawnand_markbad(struct nand_device *nand,\n\t\t\t   const struct nand_pos *pos)\n{\n\tstruct nand_chip *chip = container_of(nand, struct nand_chip,\n\t\t\t\t\t      base);\n\n\treturn nand_markbad_bbm(chip, nanddev_pos_to_offs(nand, pos));\n}\n\nstatic bool rawnand_isbad(struct nand_device *nand, const struct nand_pos *pos)\n{\n\tstruct nand_chip *chip = container_of(nand, struct nand_chip,\n\t\t\t\t\t      base);\n\tint ret;\n\n\tnand_select_target(chip, pos->target);\n\tret = nand_isbad_bbm(chip, nanddev_pos_to_offs(nand, pos));\n\tnand_deselect_target(chip);\n\n\treturn ret;\n}\n\nstatic const struct nand_ops rawnand_ops = {\n\t.erase = rawnand_erase,\n\t.markbad = rawnand_markbad,\n\t.isbad = rawnand_isbad,\n};\n\n \nstatic int nand_scan_tail(struct nand_chip *chip)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tstruct nand_ecc_ctrl *ecc = &chip->ecc;\n\tint ret, i;\n\n\t \n\tif (WARN_ON((chip->bbt_options & NAND_BBT_NO_OOB_BBM) &&\n\t\t   !(chip->bbt_options & NAND_BBT_USE_FLASH))) {\n\t\treturn -EINVAL;\n\t}\n\n\tchip->data_buf = kmalloc(mtd->writesize + mtd->oobsize, GFP_KERNEL);\n\tif (!chip->data_buf)\n\t\treturn -ENOMEM;\n\n\t \n\tnand_select_target(chip, 0);\n\tret = nand_manufacturer_init(chip);\n\tnand_deselect_target(chip);\n\tif (ret)\n\t\tgoto err_free_buf;\n\n\t \n\tchip->oob_poi = chip->data_buf + mtd->writesize;\n\n\t \n\tif (!mtd->ooblayout &&\n\t    !(ecc->engine_type == NAND_ECC_ENGINE_TYPE_SOFT &&\n\t      ecc->algo == NAND_ECC_ALGO_BCH) &&\n\t    !(ecc->engine_type == NAND_ECC_ENGINE_TYPE_SOFT &&\n\t      ecc->algo == NAND_ECC_ALGO_HAMMING)) {\n\t\tswitch (mtd->oobsize) {\n\t\tcase 8:\n\t\tcase 16:\n\t\t\tmtd_set_ooblayout(mtd, nand_get_small_page_ooblayout());\n\t\t\tbreak;\n\t\tcase 64:\n\t\tcase 128:\n\t\t\tmtd_set_ooblayout(mtd,\n\t\t\t\t\t  nand_get_large_page_hamming_ooblayout());\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t \n\t\t\tif (ecc->engine_type == NAND_ECC_ENGINE_TYPE_NONE) {\n\t\t\t\tmtd_set_ooblayout(mtd,\n\t\t\t\t\t\t  nand_get_large_page_ooblayout());\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tWARN(1, \"No oob scheme defined for oobsize %d\\n\",\n\t\t\t\tmtd->oobsize);\n\t\t\tret = -EINVAL;\n\t\t\tgoto err_nand_manuf_cleanup;\n\t\t}\n\t}\n\n\t \n\n\tswitch (ecc->engine_type) {\n\tcase NAND_ECC_ENGINE_TYPE_ON_HOST:\n\t\tret = nand_set_ecc_on_host_ops(chip);\n\t\tif (ret)\n\t\t\tgoto err_nand_manuf_cleanup;\n\n\t\tif (mtd->writesize >= ecc->size) {\n\t\t\tif (!ecc->strength) {\n\t\t\t\tWARN(1, \"Driver must set ecc.strength when using hardware ECC\\n\");\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto err_nand_manuf_cleanup;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tpr_warn(\"%d byte HW ECC not possible on %d byte page size, fallback to SW ECC\\n\",\n\t\t\tecc->size, mtd->writesize);\n\t\tecc->engine_type = NAND_ECC_ENGINE_TYPE_SOFT;\n\t\tecc->algo = NAND_ECC_ALGO_HAMMING;\n\t\tfallthrough;\n\n\tcase NAND_ECC_ENGINE_TYPE_SOFT:\n\t\tret = nand_set_ecc_soft_ops(chip);\n\t\tif (ret)\n\t\t\tgoto err_nand_manuf_cleanup;\n\t\tbreak;\n\n\tcase NAND_ECC_ENGINE_TYPE_ON_DIE:\n\t\tif (!ecc->read_page || !ecc->write_page) {\n\t\t\tWARN(1, \"No ECC functions supplied; on-die ECC not possible\\n\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto err_nand_manuf_cleanup;\n\t\t}\n\t\tif (!ecc->read_oob)\n\t\t\tecc->read_oob = nand_read_oob_std;\n\t\tif (!ecc->write_oob)\n\t\t\tecc->write_oob = nand_write_oob_std;\n\t\tbreak;\n\n\tcase NAND_ECC_ENGINE_TYPE_NONE:\n\t\tpr_warn(\"NAND_ECC_ENGINE_TYPE_NONE selected by board driver. This is not recommended!\\n\");\n\t\tecc->read_page = nand_read_page_raw;\n\t\tecc->write_page = nand_write_page_raw;\n\t\tecc->read_oob = nand_read_oob_std;\n\t\tecc->read_page_raw = nand_read_page_raw;\n\t\tecc->write_page_raw = nand_write_page_raw;\n\t\tecc->write_oob = nand_write_oob_std;\n\t\tecc->size = mtd->writesize;\n\t\tecc->bytes = 0;\n\t\tecc->strength = 0;\n\t\tbreak;\n\n\tdefault:\n\t\tWARN(1, \"Invalid NAND_ECC_MODE %d\\n\", ecc->engine_type);\n\t\tret = -EINVAL;\n\t\tgoto err_nand_manuf_cleanup;\n\t}\n\n\tif (ecc->correct || ecc->calculate) {\n\t\tecc->calc_buf = kmalloc(mtd->oobsize, GFP_KERNEL);\n\t\tecc->code_buf = kmalloc(mtd->oobsize, GFP_KERNEL);\n\t\tif (!ecc->calc_buf || !ecc->code_buf) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err_nand_manuf_cleanup;\n\t\t}\n\t}\n\n\t \n\tif (!ecc->read_oob_raw)\n\t\tecc->read_oob_raw = ecc->read_oob;\n\tif (!ecc->write_oob_raw)\n\t\tecc->write_oob_raw = ecc->write_oob;\n\n\t \n\tmtd->ecc_strength = ecc->strength;\n\tmtd->ecc_step_size = ecc->size;\n\n\t \n\tif (!ecc->steps)\n\t\tecc->steps = mtd->writesize / ecc->size;\n\tif (ecc->steps * ecc->size != mtd->writesize) {\n\t\tWARN(1, \"Invalid ECC parameters\\n\");\n\t\tret = -EINVAL;\n\t\tgoto err_nand_manuf_cleanup;\n\t}\n\n\tif (!ecc->total) {\n\t\tecc->total = ecc->steps * ecc->bytes;\n\t\tchip->base.ecc.ctx.total = ecc->total;\n\t}\n\n\tif (ecc->total > mtd->oobsize) {\n\t\tWARN(1, \"Total number of ECC bytes exceeded oobsize\\n\");\n\t\tret = -EINVAL;\n\t\tgoto err_nand_manuf_cleanup;\n\t}\n\n\t \n\tret = mtd_ooblayout_count_freebytes(mtd);\n\tif (ret < 0)\n\t\tret = 0;\n\n\tmtd->oobavail = ret;\n\n\t \n\tif (!nand_ecc_is_strong_enough(&chip->base))\n\t\tpr_warn(\"WARNING: %s: the ECC used on your system (%db/%dB) is too weak compared to the one required by the NAND chip (%db/%dB)\\n\",\n\t\t\tmtd->name, chip->ecc.strength, chip->ecc.size,\n\t\t\tnanddev_get_ecc_requirements(&chip->base)->strength,\n\t\t\tnanddev_get_ecc_requirements(&chip->base)->step_size);\n\n\t \n\tif (!(chip->options & NAND_NO_SUBPAGE_WRITE) && nand_is_slc(chip)) {\n\t\tswitch (ecc->steps) {\n\t\tcase 2:\n\t\t\tmtd->subpage_sft = 1;\n\t\t\tbreak;\n\t\tcase 4:\n\t\tcase 8:\n\t\tcase 16:\n\t\t\tmtd->subpage_sft = 2;\n\t\t\tbreak;\n\t\t}\n\t}\n\tchip->subpagesize = mtd->writesize >> mtd->subpage_sft;\n\n\t \n\tchip->pagecache.page = -1;\n\n\t \n\tswitch (ecc->engine_type) {\n\tcase NAND_ECC_ENGINE_TYPE_SOFT:\n\t\tif (chip->page_shift > 9)\n\t\t\tchip->options |= NAND_SUBPAGE_READ;\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\tret = nanddev_init(&chip->base, &rawnand_ops, mtd->owner);\n\tif (ret)\n\t\tgoto err_nand_manuf_cleanup;\n\n\t \n\tif (chip->options & NAND_ROM)\n\t\tmtd->flags = MTD_CAP_ROM;\n\n\t \n\tmtd->_erase = nand_erase;\n\tmtd->_point = NULL;\n\tmtd->_unpoint = NULL;\n\tmtd->_panic_write = panic_nand_write;\n\tmtd->_read_oob = nand_read_oob;\n\tmtd->_write_oob = nand_write_oob;\n\tmtd->_sync = nand_sync;\n\tmtd->_lock = nand_lock;\n\tmtd->_unlock = nand_unlock;\n\tmtd->_suspend = nand_suspend;\n\tmtd->_resume = nand_resume;\n\tmtd->_reboot = nand_shutdown;\n\tmtd->_block_isreserved = nand_block_isreserved;\n\tmtd->_block_isbad = nand_block_isbad;\n\tmtd->_block_markbad = nand_block_markbad;\n\tmtd->_max_bad_blocks = nanddev_mtd_max_bad_blocks;\n\n\t \n\tif (!mtd->bitflip_threshold)\n\t\tmtd->bitflip_threshold = DIV_ROUND_UP(mtd->ecc_strength * 3, 4);\n\n\t \n\tret = nand_choose_interface_config(chip);\n\tif (ret)\n\t\tgoto err_nanddev_cleanup;\n\n\t \n\tfor (i = 0; i < nanddev_ntargets(&chip->base); i++) {\n\t\tret = nand_setup_interface(chip, i);\n\t\tif (ret)\n\t\t\tgoto err_free_interface_config;\n\t}\n\n\trawnand_late_check_supported_ops(chip);\n\n\t \n\tret = of_get_nand_secure_regions(chip);\n\tif (ret)\n\t\tgoto err_free_interface_config;\n\n\t \n\tif (chip->options & NAND_SKIP_BBTSCAN)\n\t\treturn 0;\n\n\t \n\tret = nand_create_bbt(chip);\n\tif (ret)\n\t\tgoto err_free_secure_regions;\n\n\treturn 0;\n\nerr_free_secure_regions:\n\tkfree(chip->secure_regions);\n\nerr_free_interface_config:\n\tkfree(chip->best_interface_config);\n\nerr_nanddev_cleanup:\n\tnanddev_cleanup(&chip->base);\n\nerr_nand_manuf_cleanup:\n\tnand_manufacturer_cleanup(chip);\n\nerr_free_buf:\n\tkfree(chip->data_buf);\n\tkfree(ecc->code_buf);\n\tkfree(ecc->calc_buf);\n\n\treturn ret;\n}\n\nstatic int nand_attach(struct nand_chip *chip)\n{\n\tif (chip->controller->ops && chip->controller->ops->attach_chip)\n\t\treturn chip->controller->ops->attach_chip(chip);\n\n\treturn 0;\n}\n\nstatic void nand_detach(struct nand_chip *chip)\n{\n\tif (chip->controller->ops && chip->controller->ops->detach_chip)\n\t\tchip->controller->ops->detach_chip(chip);\n}\n\n \nint nand_scan_with_ids(struct nand_chip *chip, unsigned int maxchips,\n\t\t       struct nand_flash_dev *ids)\n{\n\tint ret;\n\n\tif (!maxchips)\n\t\treturn -EINVAL;\n\n\tret = nand_scan_ident(chip, maxchips, ids);\n\tif (ret)\n\t\treturn ret;\n\n\tret = nand_attach(chip);\n\tif (ret)\n\t\tgoto cleanup_ident;\n\n\tret = nand_scan_tail(chip);\n\tif (ret)\n\t\tgoto detach_chip;\n\n\treturn 0;\n\ndetach_chip:\n\tnand_detach(chip);\ncleanup_ident:\n\tnand_scan_ident_cleanup(chip);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(nand_scan_with_ids);\n\n \nvoid nand_cleanup(struct nand_chip *chip)\n{\n\tif (chip->ecc.engine_type == NAND_ECC_ENGINE_TYPE_SOFT) {\n\t\tif (chip->ecc.algo == NAND_ECC_ALGO_HAMMING)\n\t\t\trawnand_sw_hamming_cleanup(chip);\n\t\telse if (chip->ecc.algo == NAND_ECC_ALGO_BCH)\n\t\t\trawnand_sw_bch_cleanup(chip);\n\t}\n\n\tnanddev_cleanup(&chip->base);\n\n\t \n\tkfree(chip->secure_regions);\n\n\t \n\tkfree(chip->bbt);\n\tkfree(chip->data_buf);\n\tkfree(chip->ecc.code_buf);\n\tkfree(chip->ecc.calc_buf);\n\n\t \n\tif (chip->badblock_pattern && chip->badblock_pattern->options\n\t\t\t& NAND_BBT_DYNAMICSTRUCT)\n\t\tkfree(chip->badblock_pattern);\n\n\t \n\tkfree(chip->best_interface_config);\n\n\t \n\tnand_manufacturer_cleanup(chip);\n\n\t \n\tnand_detach(chip);\n\n\t \n\tnand_scan_ident_cleanup(chip);\n}\n\nEXPORT_SYMBOL_GPL(nand_cleanup);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Steven J. Hill <sjhill@realitydiluted.com>\");\nMODULE_AUTHOR(\"Thomas Gleixner <tglx@linutronix.de>\");\nMODULE_DESCRIPTION(\"Generic NAND flash driver code\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}