{
  "module_name": "davinci_nand.c",
  "hash_id": "954ce156cc6f0f087d11f17b2dc91deaf000c67832020dd1f0360bf8d6813e51",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/nand/raw/davinci_nand.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/err.h>\n#include <linux/iopoll.h>\n#include <linux/mtd/rawnand.h>\n#include <linux/mtd/partitions.h>\n#include <linux/slab.h>\n#include <linux/of.h>\n\n#include <linux/platform_data/mtd-davinci.h>\n#include <linux/platform_data/mtd-davinci-aemif.h>\n\n \nstruct davinci_nand_info {\n\tstruct nand_controller\tcontroller;\n\tstruct nand_chip\tchip;\n\n\tstruct platform_device\t*pdev;\n\n\tbool\t\t\tis_readmode;\n\n\tvoid __iomem\t\t*base;\n\tvoid __iomem\t\t*vaddr;\n\n\tvoid __iomem\t\t*current_cs;\n\n\tuint32_t\t\tmask_chipsel;\n\tuint32_t\t\tmask_ale;\n\tuint32_t\t\tmask_cle;\n\n\tuint32_t\t\tcore_chipsel;\n\n\tstruct davinci_aemif_timing\t*timing;\n};\n\nstatic DEFINE_SPINLOCK(davinci_nand_lock);\nstatic bool ecc4_busy;\n\nstatic inline struct davinci_nand_info *to_davinci_nand(struct mtd_info *mtd)\n{\n\treturn container_of(mtd_to_nand(mtd), struct davinci_nand_info, chip);\n}\n\nstatic inline unsigned int davinci_nand_readl(struct davinci_nand_info *info,\n\t\tint offset)\n{\n\treturn __raw_readl(info->base + offset);\n}\n\nstatic inline void davinci_nand_writel(struct davinci_nand_info *info,\n\t\tint offset, unsigned long value)\n{\n\t__raw_writel(value, info->base + offset);\n}\n\n \n\n \n\nstatic inline uint32_t nand_davinci_readecc_1bit(struct mtd_info *mtd)\n{\n\tstruct davinci_nand_info *info = to_davinci_nand(mtd);\n\n\treturn davinci_nand_readl(info, NANDF1ECC_OFFSET\n\t\t\t+ 4 * info->core_chipsel);\n}\n\nstatic void nand_davinci_hwctl_1bit(struct nand_chip *chip, int mode)\n{\n\tstruct davinci_nand_info *info;\n\tuint32_t nandcfr;\n\tunsigned long flags;\n\n\tinfo = to_davinci_nand(nand_to_mtd(chip));\n\n\t \n\tnand_davinci_readecc_1bit(nand_to_mtd(chip));\n\n\tspin_lock_irqsave(&davinci_nand_lock, flags);\n\n\t \n\tnandcfr = davinci_nand_readl(info, NANDFCR_OFFSET);\n\tnandcfr |= BIT(8 + info->core_chipsel);\n\tdavinci_nand_writel(info, NANDFCR_OFFSET, nandcfr);\n\n\tspin_unlock_irqrestore(&davinci_nand_lock, flags);\n}\n\n \nstatic int nand_davinci_calculate_1bit(struct nand_chip *chip,\n\t\t\t\t       const u_char *dat, u_char *ecc_code)\n{\n\tunsigned int ecc_val = nand_davinci_readecc_1bit(nand_to_mtd(chip));\n\tunsigned int ecc24 = (ecc_val & 0x0fff) | ((ecc_val & 0x0fff0000) >> 4);\n\n\t \n\tecc24 = ~ecc24;\n\tecc_code[0] = (u_char)(ecc24);\n\tecc_code[1] = (u_char)(ecc24 >> 8);\n\tecc_code[2] = (u_char)(ecc24 >> 16);\n\n\treturn 0;\n}\n\nstatic int nand_davinci_correct_1bit(struct nand_chip *chip, u_char *dat,\n\t\t\t\t     u_char *read_ecc, u_char *calc_ecc)\n{\n\tuint32_t eccNand = read_ecc[0] | (read_ecc[1] << 8) |\n\t\t\t\t\t  (read_ecc[2] << 16);\n\tuint32_t eccCalc = calc_ecc[0] | (calc_ecc[1] << 8) |\n\t\t\t\t\t  (calc_ecc[2] << 16);\n\tuint32_t diff = eccCalc ^ eccNand;\n\n\tif (diff) {\n\t\tif ((((diff >> 12) ^ diff) & 0xfff) == 0xfff) {\n\t\t\t \n\t\t\tif ((diff >> (12 + 3)) < chip->ecc.size) {\n\t\t\t\tdat[diff >> (12 + 3)] ^= BIT((diff >> 12) & 7);\n\t\t\t\treturn 1;\n\t\t\t} else {\n\t\t\t\treturn -EBADMSG;\n\t\t\t}\n\t\t} else if (!(diff & (diff - 1))) {\n\t\t\t \n\t\t\treturn 1;\n\t\t} else {\n\t\t\t \n\t\t\treturn -EBADMSG;\n\t\t}\n\n\t}\n\treturn 0;\n}\n\n \n\n \n\nstatic void nand_davinci_hwctl_4bit(struct nand_chip *chip, int mode)\n{\n\tstruct davinci_nand_info *info = to_davinci_nand(nand_to_mtd(chip));\n\tunsigned long flags;\n\tu32 val;\n\n\t \n\tdavinci_nand_readl(info, NAND_4BIT_ECC1_OFFSET);\n\n\tspin_lock_irqsave(&davinci_nand_lock, flags);\n\n\t \n\tval = davinci_nand_readl(info, NANDFCR_OFFSET);\n\tval &= ~(0x03 << 4);\n\tval |= (info->core_chipsel << 4) | BIT(12);\n\tdavinci_nand_writel(info, NANDFCR_OFFSET, val);\n\n\tinfo->is_readmode = (mode == NAND_ECC_READ);\n\n\tspin_unlock_irqrestore(&davinci_nand_lock, flags);\n}\n\n \nstatic void\nnand_davinci_readecc_4bit(struct davinci_nand_info *info, u32 code[4])\n{\n\tconst u32 mask = 0x03ff03ff;\n\n\tcode[0] = davinci_nand_readl(info, NAND_4BIT_ECC1_OFFSET) & mask;\n\tcode[1] = davinci_nand_readl(info, NAND_4BIT_ECC2_OFFSET) & mask;\n\tcode[2] = davinci_nand_readl(info, NAND_4BIT_ECC3_OFFSET) & mask;\n\tcode[3] = davinci_nand_readl(info, NAND_4BIT_ECC4_OFFSET) & mask;\n}\n\n \nstatic int nand_davinci_calculate_4bit(struct nand_chip *chip,\n\t\t\t\t       const u_char *dat, u_char *ecc_code)\n{\n\tstruct davinci_nand_info *info = to_davinci_nand(nand_to_mtd(chip));\n\tu32 raw_ecc[4], *p;\n\tunsigned i;\n\n\t \n\tif (info->is_readmode) {\n\t\tdavinci_nand_readl(info, NAND_4BIT_ECC1_OFFSET);\n\t\treturn 0;\n\t}\n\n\t \n\tnand_davinci_readecc_4bit(info, raw_ecc);\n\tfor (i = 0, p = raw_ecc; i < 2; i++, p += 2) {\n\t\t*ecc_code++ =   p[0]        & 0xff;\n\t\t*ecc_code++ = ((p[0] >>  8) & 0x03) | ((p[0] >> 14) & 0xfc);\n\t\t*ecc_code++ = ((p[0] >> 22) & 0x0f) | ((p[1] <<  4) & 0xf0);\n\t\t*ecc_code++ = ((p[1] >>  4) & 0x3f) | ((p[1] >> 10) & 0xc0);\n\t\t*ecc_code++ =  (p[1] >> 18) & 0xff;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int nand_davinci_correct_4bit(struct nand_chip *chip, u_char *data,\n\t\t\t\t     u_char *ecc_code, u_char *null)\n{\n\tint i;\n\tstruct davinci_nand_info *info = to_davinci_nand(nand_to_mtd(chip));\n\tunsigned short ecc10[8];\n\tunsigned short *ecc16;\n\tu32 syndrome[4];\n\tu32 ecc_state;\n\tunsigned num_errors, corrected;\n\tunsigned long timeo;\n\n\t \n\tif (WARN_ON(0x01 & (uintptr_t)ecc_code))\n\t\treturn -EINVAL;\n\tecc16 = (unsigned short *)ecc_code;\n\n\tecc10[0] =  (ecc16[0] >>  0) & 0x3ff;\n\tecc10[1] = ((ecc16[0] >> 10) & 0x3f) | ((ecc16[1] << 6) & 0x3c0);\n\tecc10[2] =  (ecc16[1] >>  4) & 0x3ff;\n\tecc10[3] = ((ecc16[1] >> 14) & 0x3)  | ((ecc16[2] << 2) & 0x3fc);\n\tecc10[4] =  (ecc16[2] >>  8)         | ((ecc16[3] << 8) & 0x300);\n\tecc10[5] =  (ecc16[3] >>  2) & 0x3ff;\n\tecc10[6] = ((ecc16[3] >> 12) & 0xf)  | ((ecc16[4] << 4) & 0x3f0);\n\tecc10[7] =  (ecc16[4] >>  6) & 0x3ff;\n\n\t \n\tfor (i = 7; i >= 0; i--)\n\t\tdavinci_nand_writel(info, NAND_4BIT_ECC_LOAD_OFFSET, ecc10[i]);\n\n\t \n\tdavinci_nand_readl(info, NANDFSR_OFFSET);\n\tnand_davinci_readecc_4bit(info, syndrome);\n\tif (!(syndrome[0] | syndrome[1] | syndrome[2] | syndrome[3]))\n\t\treturn 0;\n\n\t \n\tdavinci_nand_readl(info, NAND_ERR_ADD1_OFFSET);\n\n\t \n\tdavinci_nand_writel(info, NANDFCR_OFFSET,\n\t\t\tdavinci_nand_readl(info, NANDFCR_OFFSET) | BIT(13));\n\n\t \n\ttimeo = jiffies + usecs_to_jiffies(100);\n\tdo {\n\t\tecc_state = (davinci_nand_readl(info,\n\t\t\t\tNANDFSR_OFFSET) >> 8) & 0x0f;\n\t\tcpu_relax();\n\t} while ((ecc_state < 4) && time_before(jiffies, timeo));\n\n\tfor (;;) {\n\t\tu32\tfsr = davinci_nand_readl(info, NANDFSR_OFFSET);\n\n\t\tswitch ((fsr >> 8) & 0x0f) {\n\t\tcase 0:\t\t \n\t\t\tdavinci_nand_readl(info, NAND_ERR_ERRVAL1_OFFSET);\n\t\t\treturn 0;\n\t\tcase 1:\t\t \n\t\t\tdavinci_nand_readl(info, NAND_ERR_ERRVAL1_OFFSET);\n\t\t\treturn -EBADMSG;\n\t\tcase 2:\t\t \n\t\tcase 3:\n\t\t\tnum_errors = 1 + ((fsr >> 16) & 0x03);\n\t\t\tgoto correct;\n\t\tdefault:\t \n\t\t\tcpu_relax();\n\t\t\tcontinue;\n\t\t}\n\t}\n\ncorrect:\n\t \n\tfor (i = 0, corrected = 0; i < num_errors; i++) {\n\t\tint error_address, error_value;\n\n\t\tif (i > 1) {\n\t\t\terror_address = davinci_nand_readl(info,\n\t\t\t\t\t\tNAND_ERR_ADD2_OFFSET);\n\t\t\terror_value = davinci_nand_readl(info,\n\t\t\t\t\t\tNAND_ERR_ERRVAL2_OFFSET);\n\t\t} else {\n\t\t\terror_address = davinci_nand_readl(info,\n\t\t\t\t\t\tNAND_ERR_ADD1_OFFSET);\n\t\t\terror_value = davinci_nand_readl(info,\n\t\t\t\t\t\tNAND_ERR_ERRVAL1_OFFSET);\n\t\t}\n\n\t\tif (i & 1) {\n\t\t\terror_address >>= 16;\n\t\t\terror_value >>= 16;\n\t\t}\n\t\terror_address &= 0x3ff;\n\t\terror_address = (512 + 7) - error_address;\n\n\t\tif (error_address < 512) {\n\t\t\tdata[error_address] ^= error_value;\n\t\t\tcorrected++;\n\t\t}\n\t}\n\n\treturn corrected;\n}\n\n \n\n \nstatic int hwecc4_ooblayout_small_ecc(struct mtd_info *mtd, int section,\n\t\t\t\t      struct mtd_oob_region *oobregion)\n{\n\tif (section > 2)\n\t\treturn -ERANGE;\n\n\tif (!section) {\n\t\toobregion->offset = 0;\n\t\toobregion->length = 5;\n\t} else if (section == 1) {\n\t\toobregion->offset = 6;\n\t\toobregion->length = 2;\n\t} else {\n\t\toobregion->offset = 13;\n\t\toobregion->length = 3;\n\t}\n\n\treturn 0;\n}\n\nstatic int hwecc4_ooblayout_small_free(struct mtd_info *mtd, int section,\n\t\t\t\t       struct mtd_oob_region *oobregion)\n{\n\tif (section > 1)\n\t\treturn -ERANGE;\n\n\tif (!section) {\n\t\toobregion->offset = 8;\n\t\toobregion->length = 5;\n\t} else {\n\t\toobregion->offset = 16;\n\t\toobregion->length = mtd->oobsize - 16;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct mtd_ooblayout_ops hwecc4_small_ooblayout_ops = {\n\t.ecc = hwecc4_ooblayout_small_ecc,\n\t.free = hwecc4_ooblayout_small_free,\n};\n\n#if defined(CONFIG_OF)\nstatic const struct of_device_id davinci_nand_of_match[] = {\n\t{.compatible = \"ti,davinci-nand\", },\n\t{.compatible = \"ti,keystone-nand\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, davinci_nand_of_match);\n\nstatic struct davinci_nand_pdata\n\t*nand_davinci_get_pdata(struct platform_device *pdev)\n{\n\tif (!dev_get_platdata(&pdev->dev) && pdev->dev.of_node) {\n\t\tstruct davinci_nand_pdata *pdata;\n\t\tconst char *mode;\n\t\tu32 prop;\n\n\t\tpdata =  devm_kzalloc(&pdev->dev,\n\t\t\t\tsizeof(struct davinci_nand_pdata),\n\t\t\t\tGFP_KERNEL);\n\t\tpdev->dev.platform_data = pdata;\n\t\tif (!pdata)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\tif (!of_property_read_u32(pdev->dev.of_node,\n\t\t\t\"ti,davinci-chipselect\", &prop))\n\t\t\tpdata->core_chipsel = prop;\n\t\telse\n\t\t\treturn ERR_PTR(-EINVAL);\n\n\t\tif (!of_property_read_u32(pdev->dev.of_node,\n\t\t\t\"ti,davinci-mask-ale\", &prop))\n\t\t\tpdata->mask_ale = prop;\n\t\tif (!of_property_read_u32(pdev->dev.of_node,\n\t\t\t\"ti,davinci-mask-cle\", &prop))\n\t\t\tpdata->mask_cle = prop;\n\t\tif (!of_property_read_u32(pdev->dev.of_node,\n\t\t\t\"ti,davinci-mask-chipsel\", &prop))\n\t\t\tpdata->mask_chipsel = prop;\n\t\tif (!of_property_read_string(pdev->dev.of_node,\n\t\t\t\"ti,davinci-ecc-mode\", &mode)) {\n\t\t\tif (!strncmp(\"none\", mode, 4))\n\t\t\t\tpdata->engine_type = NAND_ECC_ENGINE_TYPE_NONE;\n\t\t\tif (!strncmp(\"soft\", mode, 4))\n\t\t\t\tpdata->engine_type = NAND_ECC_ENGINE_TYPE_SOFT;\n\t\t\tif (!strncmp(\"hw\", mode, 2))\n\t\t\t\tpdata->engine_type = NAND_ECC_ENGINE_TYPE_ON_HOST;\n\t\t}\n\t\tif (!of_property_read_u32(pdev->dev.of_node,\n\t\t\t\"ti,davinci-ecc-bits\", &prop))\n\t\t\tpdata->ecc_bits = prop;\n\n\t\tif (!of_property_read_u32(pdev->dev.of_node,\n\t\t\t\"ti,davinci-nand-buswidth\", &prop) && prop == 16)\n\t\t\tpdata->options |= NAND_BUSWIDTH_16;\n\n\t\tif (of_property_read_bool(pdev->dev.of_node,\n\t\t\t\"ti,davinci-nand-use-bbt\"))\n\t\t\tpdata->bbt_options = NAND_BBT_USE_FLASH;\n\n\t\t \n\t\tif (of_device_is_compatible(pdev->dev.of_node,\n\t\t\t\t\t    \"ti,keystone-nand\")) {\n\t\t\tpdata->options |= NAND_NO_SUBPAGE_WRITE;\n\t\t}\n\t}\n\n\treturn dev_get_platdata(&pdev->dev);\n}\n#else\nstatic struct davinci_nand_pdata\n\t*nand_davinci_get_pdata(struct platform_device *pdev)\n{\n\treturn dev_get_platdata(&pdev->dev);\n}\n#endif\n\nstatic int davinci_nand_attach_chip(struct nand_chip *chip)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tstruct davinci_nand_info *info = to_davinci_nand(mtd);\n\tstruct davinci_nand_pdata *pdata = nand_davinci_get_pdata(info->pdev);\n\tint ret = 0;\n\n\tif (IS_ERR(pdata))\n\t\treturn PTR_ERR(pdata);\n\n\t \n\tchip->ecc.engine_type = pdata->engine_type;\n\tchip->ecc.placement = pdata->ecc_placement;\n\n\tswitch (chip->ecc.engine_type) {\n\tcase NAND_ECC_ENGINE_TYPE_NONE:\n\t\tpdata->ecc_bits = 0;\n\t\tbreak;\n\tcase NAND_ECC_ENGINE_TYPE_SOFT:\n\t\tpdata->ecc_bits = 0;\n\t\t \n\t\tchip->ecc.algo = NAND_ECC_ALGO_HAMMING;\n\t\tbreak;\n\tcase NAND_ECC_ENGINE_TYPE_ON_HOST:\n\t\tif (pdata->ecc_bits == 4) {\n\t\t\tint chunks = mtd->writesize / 512;\n\n\t\t\tif (!chunks || mtd->oobsize < 16) {\n\t\t\t\tdev_dbg(&info->pdev->dev, \"too small\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\t \n\n\t\t\t \n\t\t\tspin_lock_irq(&davinci_nand_lock);\n\t\t\tif (ecc4_busy)\n\t\t\t\tret = -EBUSY;\n\t\t\telse\n\t\t\t\tecc4_busy = true;\n\t\t\tspin_unlock_irq(&davinci_nand_lock);\n\n\t\t\tif (ret == -EBUSY)\n\t\t\t\treturn ret;\n\n\t\t\tchip->ecc.calculate = nand_davinci_calculate_4bit;\n\t\t\tchip->ecc.correct = nand_davinci_correct_4bit;\n\t\t\tchip->ecc.hwctl = nand_davinci_hwctl_4bit;\n\t\t\tchip->ecc.bytes = 10;\n\t\t\tchip->ecc.options = NAND_ECC_GENERIC_ERASED_CHECK;\n\t\t\tchip->ecc.algo = NAND_ECC_ALGO_BCH;\n\n\t\t\t \n\t\t\tif (chunks == 1) {\n\t\t\t\tmtd_set_ooblayout(mtd,\n\t\t\t\t\t\t  &hwecc4_small_ooblayout_ops);\n\t\t\t} else if (chunks == 4 || chunks == 8) {\n\t\t\t\tmtd_set_ooblayout(mtd,\n\t\t\t\t\t\t  nand_get_large_page_ooblayout());\n\t\t\t\tchip->ecc.read_page = nand_read_page_hwecc_oob_first;\n\t\t\t} else {\n\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tchip->ecc.calculate = nand_davinci_calculate_1bit;\n\t\t\tchip->ecc.correct = nand_davinci_correct_1bit;\n\t\t\tchip->ecc.hwctl = nand_davinci_hwctl_1bit;\n\t\t\tchip->ecc.bytes = 3;\n\t\t\tchip->ecc.algo = NAND_ECC_ALGO_HAMMING;\n\t\t}\n\t\tchip->ecc.size = 512;\n\t\tchip->ecc.strength = pdata->ecc_bits;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn ret;\n}\n\nstatic void nand_davinci_data_in(struct davinci_nand_info *info, void *buf,\n\t\t\t\t unsigned int len, bool force_8bit)\n{\n\tu32 alignment = ((uintptr_t)buf | len) & 3;\n\n\tif (force_8bit || (alignment & 1))\n\t\tioread8_rep(info->current_cs, buf, len);\n\telse if (alignment & 3)\n\t\tioread16_rep(info->current_cs, buf, len >> 1);\n\telse\n\t\tioread32_rep(info->current_cs, buf, len >> 2);\n}\n\nstatic void nand_davinci_data_out(struct davinci_nand_info *info,\n\t\t\t\t  const void *buf, unsigned int len,\n\t\t\t\t  bool force_8bit)\n{\n\tu32 alignment = ((uintptr_t)buf | len) & 3;\n\n\tif (force_8bit || (alignment & 1))\n\t\tiowrite8_rep(info->current_cs, buf, len);\n\telse if (alignment & 3)\n\t\tiowrite16_rep(info->current_cs, buf, len >> 1);\n\telse\n\t\tiowrite32_rep(info->current_cs, buf, len >> 2);\n}\n\nstatic int davinci_nand_exec_instr(struct davinci_nand_info *info,\n\t\t\t\t   const struct nand_op_instr *instr)\n{\n\tunsigned int i, timeout_us;\n\tu32 status;\n\tint ret;\n\n\tswitch (instr->type) {\n\tcase NAND_OP_CMD_INSTR:\n\t\tiowrite8(instr->ctx.cmd.opcode,\n\t\t\t info->current_cs + info->mask_cle);\n\t\tbreak;\n\n\tcase NAND_OP_ADDR_INSTR:\n\t\tfor (i = 0; i < instr->ctx.addr.naddrs; i++) {\n\t\t\tiowrite8(instr->ctx.addr.addrs[i],\n\t\t\t\t info->current_cs + info->mask_ale);\n\t\t}\n\t\tbreak;\n\n\tcase NAND_OP_DATA_IN_INSTR:\n\t\tnand_davinci_data_in(info, instr->ctx.data.buf.in,\n\t\t\t\t     instr->ctx.data.len,\n\t\t\t\t     instr->ctx.data.force_8bit);\n\t\tbreak;\n\n\tcase NAND_OP_DATA_OUT_INSTR:\n\t\tnand_davinci_data_out(info, instr->ctx.data.buf.out,\n\t\t\t\t      instr->ctx.data.len,\n\t\t\t\t      instr->ctx.data.force_8bit);\n\t\tbreak;\n\n\tcase NAND_OP_WAITRDY_INSTR:\n\t\ttimeout_us = instr->ctx.waitrdy.timeout_ms * 1000;\n\t\tret = readl_relaxed_poll_timeout(info->base + NANDFSR_OFFSET,\n\t\t\t\t\t\t status, status & BIT(0), 100,\n\t\t\t\t\t\t timeout_us);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tbreak;\n\t}\n\n\tif (instr->delay_ns)\n\t\tndelay(instr->delay_ns);\n\n\treturn 0;\n}\n\nstatic int davinci_nand_exec_op(struct nand_chip *chip,\n\t\t\t\tconst struct nand_operation *op,\n\t\t\t\tbool check_only)\n{\n\tstruct davinci_nand_info *info = to_davinci_nand(nand_to_mtd(chip));\n\tunsigned int i;\n\n\tif (check_only)\n\t\treturn 0;\n\n\tinfo->current_cs = info->vaddr + (op->cs * info->mask_chipsel);\n\n\tfor (i = 0; i < op->ninstrs; i++) {\n\t\tint ret;\n\n\t\tret = davinci_nand_exec_instr(info, &op->instrs[i]);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct nand_controller_ops davinci_nand_controller_ops = {\n\t.attach_chip = davinci_nand_attach_chip,\n\t.exec_op = davinci_nand_exec_op,\n};\n\nstatic int nand_davinci_probe(struct platform_device *pdev)\n{\n\tstruct davinci_nand_pdata\t*pdata;\n\tstruct davinci_nand_info\t*info;\n\tstruct resource\t\t\t*res1;\n\tstruct resource\t\t\t*res2;\n\tvoid __iomem\t\t\t*vaddr;\n\tvoid __iomem\t\t\t*base;\n\tint\t\t\t\tret;\n\tuint32_t\t\t\tval;\n\tstruct mtd_info\t\t\t*mtd;\n\n\tpdata = nand_davinci_get_pdata(pdev);\n\tif (IS_ERR(pdata))\n\t\treturn PTR_ERR(pdata);\n\n\t \n\tif (!pdata)\n\t\treturn -ENODEV;\n\n\t \n\tif (pdata->core_chipsel > 3)\n\t\treturn -ENODEV;\n\n\tinfo = devm_kzalloc(&pdev->dev, sizeof(*info), GFP_KERNEL);\n\tif (!info)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, info);\n\n\tres1 = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tres2 = platform_get_resource(pdev, IORESOURCE_MEM, 1);\n\tif (!res1 || !res2) {\n\t\tdev_err(&pdev->dev, \"resource missing\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tvaddr = devm_ioremap_resource(&pdev->dev, res1);\n\tif (IS_ERR(vaddr))\n\t\treturn PTR_ERR(vaddr);\n\n\t \n\tbase = devm_ioremap(&pdev->dev, res2->start, resource_size(res2));\n\tif (!base) {\n\t\tdev_err(&pdev->dev, \"ioremap failed for resource %pR\\n\", res2);\n\t\treturn -EADDRNOTAVAIL;\n\t}\n\n\tinfo->pdev\t\t= pdev;\n\tinfo->base\t\t= base;\n\tinfo->vaddr\t\t= vaddr;\n\n\tmtd\t\t\t= nand_to_mtd(&info->chip);\n\tmtd->dev.parent\t\t= &pdev->dev;\n\tnand_set_flash_node(&info->chip, pdev->dev.of_node);\n\n\t \n\tinfo->chip.bbt_options\t= pdata->bbt_options;\n\t \n\tinfo->chip.options\t= pdata->options;\n\tinfo->chip.bbt_td\t= pdata->bbt_td;\n\tinfo->chip.bbt_md\t= pdata->bbt_md;\n\tinfo->timing\t\t= pdata->timing;\n\n\tinfo->current_cs\t= info->vaddr;\n\tinfo->core_chipsel\t= pdata->core_chipsel;\n\tinfo->mask_chipsel\t= pdata->mask_chipsel;\n\n\t \n\tinfo->mask_ale\t\t= pdata->mask_ale ? : MASK_ALE;\n\tinfo->mask_cle\t\t= pdata->mask_cle ? : MASK_CLE;\n\n\tspin_lock_irq(&davinci_nand_lock);\n\n\t \n\tval = davinci_nand_readl(info, NANDFCR_OFFSET);\n\tval |= BIT(info->core_chipsel);\n\tdavinci_nand_writel(info, NANDFCR_OFFSET, val);\n\n\tspin_unlock_irq(&davinci_nand_lock);\n\n\t \n\tnand_controller_init(&info->controller);\n\tinfo->controller.ops = &davinci_nand_controller_ops;\n\tinfo->chip.controller = &info->controller;\n\tret = nand_scan(&info->chip, pdata->mask_chipsel ? 2 : 1);\n\tif (ret < 0) {\n\t\tdev_dbg(&pdev->dev, \"no NAND chip(s) found\\n\");\n\t\treturn ret;\n\t}\n\n\tif (pdata->parts)\n\t\tret = mtd_device_register(mtd, pdata->parts, pdata->nr_parts);\n\telse\n\t\tret = mtd_device_register(mtd, NULL, 0);\n\tif (ret < 0)\n\t\tgoto err_cleanup_nand;\n\n\tval = davinci_nand_readl(info, NRCSR_OFFSET);\n\tdev_info(&pdev->dev, \"controller rev. %d.%d\\n\",\n\t       (val >> 8) & 0xff, val & 0xff);\n\n\treturn 0;\n\nerr_cleanup_nand:\n\tnand_cleanup(&info->chip);\n\n\treturn ret;\n}\n\nstatic void nand_davinci_remove(struct platform_device *pdev)\n{\n\tstruct davinci_nand_info *info = platform_get_drvdata(pdev);\n\tstruct nand_chip *chip = &info->chip;\n\tint ret;\n\n\tspin_lock_irq(&davinci_nand_lock);\n\tif (chip->ecc.placement == NAND_ECC_PLACEMENT_INTERLEAVED)\n\t\tecc4_busy = false;\n\tspin_unlock_irq(&davinci_nand_lock);\n\n\tret = mtd_device_unregister(nand_to_mtd(chip));\n\tWARN_ON(ret);\n\tnand_cleanup(chip);\n}\n\nstatic struct platform_driver nand_davinci_driver = {\n\t.probe\t\t= nand_davinci_probe,\n\t.remove_new\t= nand_davinci_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"davinci_nand\",\n\t\t.of_match_table = of_match_ptr(davinci_nand_of_match),\n\t},\n};\nMODULE_ALIAS(\"platform:davinci_nand\");\n\nmodule_platform_driver(nand_davinci_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Texas Instruments\");\nMODULE_DESCRIPTION(\"Davinci NAND flash driver\");\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}