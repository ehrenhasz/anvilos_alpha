{
  "module_name": "fsl_ifc_nand.c",
  "hash_id": "924780d0cd7abe2ef4dcc01c72483f6d8b9c3f11671163586a0063e1b28d4999",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/nand/raw/fsl_ifc_nand.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/of_address.h>\n#include <linux/slab.h>\n#include <linux/mtd/mtd.h>\n#include <linux/mtd/rawnand.h>\n#include <linux/mtd/partitions.h>\n#include <linux/fsl_ifc.h>\n#include <linux/iopoll.h>\n\n#define ERR_BYTE\t\t0xFF  \n#define IFC_TIMEOUT_MSECS\t1000  \n\nstruct fsl_ifc_ctrl;\n\n \nstruct fsl_ifc_mtd {\n\tstruct nand_chip chip;\n\tstruct fsl_ifc_ctrl *ctrl;\n\n\tstruct device *dev;\n\tint bank;\t\t \n\tunsigned int bufnum_mask;  \n\tu8 __iomem *vbase;       \n};\n\n \nstruct fsl_ifc_nand_ctrl {\n\tstruct nand_controller controller;\n\tstruct fsl_ifc_mtd *chips[FSL_IFC_BANK_COUNT];\n\n\tvoid __iomem *addr;\t \n\tunsigned int page;\t \n\tunsigned int read_bytes; \n\tunsigned int column;\t \n\tunsigned int index;\t \n\tunsigned int oob;\t \n\tunsigned int eccread;\t \n\tunsigned int counter;\t \n\tunsigned int max_bitflips;   \n};\n\nstatic struct fsl_ifc_nand_ctrl *ifc_nand_ctrl;\n\n \nstatic u8 bbt_pattern[] = {'B', 'b', 't', '0' };\nstatic u8 mirror_pattern[] = {'1', 't', 'b', 'B' };\n\nstatic struct nand_bbt_descr bbt_main_descr = {\n\t.options = NAND_BBT_LASTBLOCK | NAND_BBT_CREATE | NAND_BBT_WRITE |\n\t\t   NAND_BBT_2BIT | NAND_BBT_VERSION,\n\t.offs =\t2,  \n\t.len = 4,\n\t.veroffs = 6,\n\t.maxblocks = 4,\n\t.pattern = bbt_pattern,\n};\n\nstatic struct nand_bbt_descr bbt_mirror_descr = {\n\t.options = NAND_BBT_LASTBLOCK | NAND_BBT_CREATE | NAND_BBT_WRITE |\n\t\t   NAND_BBT_2BIT | NAND_BBT_VERSION,\n\t.offs =\t2,  \n\t.len = 4,\n\t.veroffs = 6,\n\t.maxblocks = 4,\n\t.pattern = mirror_pattern,\n};\n\nstatic int fsl_ifc_ooblayout_ecc(struct mtd_info *mtd, int section,\n\t\t\t\t struct mtd_oob_region *oobregion)\n{\n\tstruct nand_chip *chip = mtd_to_nand(mtd);\n\n\tif (section)\n\t\treturn -ERANGE;\n\n\toobregion->offset = 8;\n\toobregion->length = chip->ecc.total;\n\n\treturn 0;\n}\n\nstatic int fsl_ifc_ooblayout_free(struct mtd_info *mtd, int section,\n\t\t\t\t  struct mtd_oob_region *oobregion)\n{\n\tstruct nand_chip *chip = mtd_to_nand(mtd);\n\n\tif (section > 1)\n\t\treturn -ERANGE;\n\n\tif (mtd->writesize == 512 &&\n\t    !(chip->options & NAND_BUSWIDTH_16)) {\n\t\tif (!section) {\n\t\t\toobregion->offset = 0;\n\t\t\toobregion->length = 5;\n\t\t} else {\n\t\t\toobregion->offset = 6;\n\t\t\toobregion->length = 2;\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tif (!section) {\n\t\toobregion->offset = 2;\n\t\toobregion->length = 6;\n\t} else {\n\t\toobregion->offset = chip->ecc.total + 8;\n\t\toobregion->length = mtd->oobsize - oobregion->offset;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct mtd_ooblayout_ops fsl_ifc_ooblayout_ops = {\n\t.ecc = fsl_ifc_ooblayout_ecc,\n\t.free = fsl_ifc_ooblayout_free,\n};\n\n \nstatic void set_addr(struct mtd_info *mtd, int column, int page_addr, int oob)\n{\n\tstruct nand_chip *chip = mtd_to_nand(mtd);\n\tstruct fsl_ifc_mtd *priv = nand_get_controller_data(chip);\n\tstruct fsl_ifc_ctrl *ctrl = priv->ctrl;\n\tstruct fsl_ifc_runtime __iomem *ifc = ctrl->rregs;\n\tint buf_num;\n\n\tifc_nand_ctrl->page = page_addr;\n\t \n\tifc_out32(page_addr, &ifc->ifc_nand.row0);\n\tifc_out32((oob ? IFC_NAND_COL_MS : 0) | column, &ifc->ifc_nand.col0);\n\n\tbuf_num = page_addr & priv->bufnum_mask;\n\n\tifc_nand_ctrl->addr = priv->vbase + buf_num * (mtd->writesize * 2);\n\tifc_nand_ctrl->index = column;\n\n\t \n\tif (oob)\n\t\tifc_nand_ctrl->index += mtd->writesize;\n}\n\n \nstatic int check_read_ecc(struct mtd_info *mtd, struct fsl_ifc_ctrl *ctrl,\n\t\t\t  u32 eccstat, unsigned int bufnum)\n{\n\treturn  (eccstat >> ((3 - bufnum % 4) * 8)) & 15;\n}\n\n \nstatic void fsl_ifc_run_command(struct mtd_info *mtd)\n{\n\tstruct nand_chip *chip = mtd_to_nand(mtd);\n\tstruct fsl_ifc_mtd *priv = nand_get_controller_data(chip);\n\tstruct fsl_ifc_ctrl *ctrl = priv->ctrl;\n\tstruct fsl_ifc_nand_ctrl *nctrl = ifc_nand_ctrl;\n\tstruct fsl_ifc_runtime __iomem *ifc = ctrl->rregs;\n\tu32 eccstat;\n\tint i;\n\n\t \n\tifc_out32(priv->bank << IFC_NAND_CSEL_SHIFT,\n\t\t  &ifc->ifc_nand.nand_csel);\n\n\tdev_vdbg(priv->dev,\n\t\t\t\"%s: fir0=%08x fcr0=%08x\\n\",\n\t\t\t__func__,\n\t\t\tifc_in32(&ifc->ifc_nand.nand_fir0),\n\t\t\tifc_in32(&ifc->ifc_nand.nand_fcr0));\n\n\tctrl->nand_stat = 0;\n\n\t \n\tifc_out32(IFC_NAND_SEQ_STRT_FIR_STRT, &ifc->ifc_nand.nandseq_strt);\n\n\t \n\twait_event_timeout(ctrl->nand_wait, ctrl->nand_stat,\n\t\t\t   msecs_to_jiffies(IFC_TIMEOUT_MSECS));\n\n\t \n\tif (!ctrl->nand_stat)\n\t\tdev_err(priv->dev, \"Controller is not responding\\n\");\n\tif (ctrl->nand_stat & IFC_NAND_EVTER_STAT_FTOER)\n\t\tdev_err(priv->dev, \"NAND Flash Timeout Error\\n\");\n\tif (ctrl->nand_stat & IFC_NAND_EVTER_STAT_WPER)\n\t\tdev_err(priv->dev, \"NAND Flash Write Protect Error\\n\");\n\n\tnctrl->max_bitflips = 0;\n\n\tif (nctrl->eccread) {\n\t\tint errors;\n\t\tint bufnum = nctrl->page & priv->bufnum_mask;\n\t\tint sector_start = bufnum * chip->ecc.steps;\n\t\tint sector_end = sector_start + chip->ecc.steps - 1;\n\t\t__be32 __iomem *eccstat_regs;\n\n\t\teccstat_regs = ifc->ifc_nand.nand_eccstat;\n\t\teccstat = ifc_in32(&eccstat_regs[sector_start / 4]);\n\n\t\tfor (i = sector_start; i <= sector_end; i++) {\n\t\t\tif (i != sector_start && !(i % 4))\n\t\t\t\teccstat = ifc_in32(&eccstat_regs[i / 4]);\n\n\t\t\terrors = check_read_ecc(mtd, ctrl, eccstat, i);\n\n\t\t\tif (errors == 15) {\n\t\t\t\t \n\t\t\t\tctrl->nand_stat |= IFC_NAND_EVTER_STAT_ECCER;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tmtd->ecc_stats.corrected += errors;\n\t\t\tnctrl->max_bitflips = max_t(unsigned int,\n\t\t\t\t\t\t    nctrl->max_bitflips,\n\t\t\t\t\t\t    errors);\n\t\t}\n\n\t\tnctrl->eccread = 0;\n\t}\n}\n\nstatic void fsl_ifc_do_read(struct nand_chip *chip,\n\t\t\t    int oob,\n\t\t\t    struct mtd_info *mtd)\n{\n\tstruct fsl_ifc_mtd *priv = nand_get_controller_data(chip);\n\tstruct fsl_ifc_ctrl *ctrl = priv->ctrl;\n\tstruct fsl_ifc_runtime __iomem *ifc = ctrl->rregs;\n\n\t \n\tif (mtd->writesize > 512) {\n\t\tifc_out32((IFC_FIR_OP_CW0 << IFC_NAND_FIR0_OP0_SHIFT) |\n\t\t\t  (IFC_FIR_OP_CA0 << IFC_NAND_FIR0_OP1_SHIFT) |\n\t\t\t  (IFC_FIR_OP_RA0 << IFC_NAND_FIR0_OP2_SHIFT) |\n\t\t\t  (IFC_FIR_OP_CMD1 << IFC_NAND_FIR0_OP3_SHIFT) |\n\t\t\t  (IFC_FIR_OP_RBCD << IFC_NAND_FIR0_OP4_SHIFT),\n\t\t\t  &ifc->ifc_nand.nand_fir0);\n\t\tifc_out32(0x0, &ifc->ifc_nand.nand_fir1);\n\n\t\tifc_out32((NAND_CMD_READ0 << IFC_NAND_FCR0_CMD0_SHIFT) |\n\t\t\t  (NAND_CMD_READSTART << IFC_NAND_FCR0_CMD1_SHIFT),\n\t\t\t  &ifc->ifc_nand.nand_fcr0);\n\t} else {\n\t\tifc_out32((IFC_FIR_OP_CW0 << IFC_NAND_FIR0_OP0_SHIFT) |\n\t\t\t  (IFC_FIR_OP_CA0 << IFC_NAND_FIR0_OP1_SHIFT) |\n\t\t\t  (IFC_FIR_OP_RA0  << IFC_NAND_FIR0_OP2_SHIFT) |\n\t\t\t  (IFC_FIR_OP_RBCD << IFC_NAND_FIR0_OP3_SHIFT),\n\t\t\t  &ifc->ifc_nand.nand_fir0);\n\t\tifc_out32(0x0, &ifc->ifc_nand.nand_fir1);\n\n\t\tif (oob)\n\t\t\tifc_out32(NAND_CMD_READOOB <<\n\t\t\t\t  IFC_NAND_FCR0_CMD0_SHIFT,\n\t\t\t\t  &ifc->ifc_nand.nand_fcr0);\n\t\telse\n\t\t\tifc_out32(NAND_CMD_READ0 <<\n\t\t\t\t  IFC_NAND_FCR0_CMD0_SHIFT,\n\t\t\t\t  &ifc->ifc_nand.nand_fcr0);\n\t}\n}\n\n \nstatic void fsl_ifc_cmdfunc(struct nand_chip *chip, unsigned int command,\n\t\t\t    int column, int page_addr) {\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tstruct fsl_ifc_mtd *priv = nand_get_controller_data(chip);\n\tstruct fsl_ifc_ctrl *ctrl = priv->ctrl;\n\tstruct fsl_ifc_runtime __iomem *ifc = ctrl->rregs;\n\n\t \n\tifc_nand_ctrl->read_bytes = 0;\n\tif (command != NAND_CMD_PAGEPROG)\n\t\tifc_nand_ctrl->index = 0;\n\n\tswitch (command) {\n\t \n\tcase NAND_CMD_READ0:\n\t\tifc_out32(0, &ifc->ifc_nand.nand_fbcr);\n\t\tset_addr(mtd, 0, page_addr, 0);\n\n\t\tifc_nand_ctrl->read_bytes = mtd->writesize + mtd->oobsize;\n\t\tifc_nand_ctrl->index += column;\n\n\t\tif (chip->ecc.engine_type == NAND_ECC_ENGINE_TYPE_ON_HOST)\n\t\t\tifc_nand_ctrl->eccread = 1;\n\n\t\tfsl_ifc_do_read(chip, 0, mtd);\n\t\tfsl_ifc_run_command(mtd);\n\t\treturn;\n\n\t \n\tcase NAND_CMD_READOOB:\n\t\tifc_out32(mtd->oobsize - column, &ifc->ifc_nand.nand_fbcr);\n\t\tset_addr(mtd, column, page_addr, 1);\n\n\t\tifc_nand_ctrl->read_bytes = mtd->writesize + mtd->oobsize;\n\n\t\tfsl_ifc_do_read(chip, 1, mtd);\n\t\tfsl_ifc_run_command(mtd);\n\n\t\treturn;\n\n\tcase NAND_CMD_READID:\n\tcase NAND_CMD_PARAM: {\n\t\t \n\t\tint len = 8;\n\t\tint timing = IFC_FIR_OP_RB;\n\t\tif (command == NAND_CMD_PARAM) {\n\t\t\ttiming = IFC_FIR_OP_RBCD;\n\t\t\tlen = 256 * 3;\n\t\t}\n\n\t\tifc_out32((IFC_FIR_OP_CW0 << IFC_NAND_FIR0_OP0_SHIFT) |\n\t\t\t  (IFC_FIR_OP_UA  << IFC_NAND_FIR0_OP1_SHIFT) |\n\t\t\t  (timing << IFC_NAND_FIR0_OP2_SHIFT),\n\t\t\t  &ifc->ifc_nand.nand_fir0);\n\t\tifc_out32(command << IFC_NAND_FCR0_CMD0_SHIFT,\n\t\t\t  &ifc->ifc_nand.nand_fcr0);\n\t\tifc_out32(column, &ifc->ifc_nand.row3);\n\n\t\tifc_out32(len, &ifc->ifc_nand.nand_fbcr);\n\t\tifc_nand_ctrl->read_bytes = len;\n\n\t\tset_addr(mtd, 0, 0, 0);\n\t\tfsl_ifc_run_command(mtd);\n\t\treturn;\n\t}\n\n\t \n\tcase NAND_CMD_ERASE1:\n\t\tset_addr(mtd, 0, page_addr, 0);\n\t\treturn;\n\n\t \n\tcase NAND_CMD_ERASE2:\n\t\tifc_out32((IFC_FIR_OP_CW0 << IFC_NAND_FIR0_OP0_SHIFT) |\n\t\t\t  (IFC_FIR_OP_RA0 << IFC_NAND_FIR0_OP1_SHIFT) |\n\t\t\t  (IFC_FIR_OP_CMD1 << IFC_NAND_FIR0_OP2_SHIFT),\n\t\t\t  &ifc->ifc_nand.nand_fir0);\n\n\t\tifc_out32((NAND_CMD_ERASE1 << IFC_NAND_FCR0_CMD0_SHIFT) |\n\t\t\t  (NAND_CMD_ERASE2 << IFC_NAND_FCR0_CMD1_SHIFT),\n\t\t\t  &ifc->ifc_nand.nand_fcr0);\n\n\t\tifc_out32(0, &ifc->ifc_nand.nand_fbcr);\n\t\tifc_nand_ctrl->read_bytes = 0;\n\t\tfsl_ifc_run_command(mtd);\n\t\treturn;\n\n\t \n\tcase NAND_CMD_SEQIN: {\n\t\tu32 nand_fcr0;\n\t\tifc_nand_ctrl->column = column;\n\t\tifc_nand_ctrl->oob = 0;\n\n\t\tif (mtd->writesize > 512) {\n\t\t\tnand_fcr0 =\n\t\t\t\t(NAND_CMD_SEQIN << IFC_NAND_FCR0_CMD0_SHIFT) |\n\t\t\t\t(NAND_CMD_STATUS << IFC_NAND_FCR0_CMD1_SHIFT) |\n\t\t\t\t(NAND_CMD_PAGEPROG << IFC_NAND_FCR0_CMD2_SHIFT);\n\n\t\t\tifc_out32(\n\t\t\t\t(IFC_FIR_OP_CW0 << IFC_NAND_FIR0_OP0_SHIFT) |\n\t\t\t\t(IFC_FIR_OP_CA0 << IFC_NAND_FIR0_OP1_SHIFT) |\n\t\t\t\t(IFC_FIR_OP_RA0 << IFC_NAND_FIR0_OP2_SHIFT) |\n\t\t\t\t(IFC_FIR_OP_WBCD << IFC_NAND_FIR0_OP3_SHIFT) |\n\t\t\t\t(IFC_FIR_OP_CMD2 << IFC_NAND_FIR0_OP4_SHIFT),\n\t\t\t\t&ifc->ifc_nand.nand_fir0);\n\t\t\tifc_out32(\n\t\t\t\t(IFC_FIR_OP_CW1 << IFC_NAND_FIR1_OP5_SHIFT) |\n\t\t\t\t(IFC_FIR_OP_RDSTAT << IFC_NAND_FIR1_OP6_SHIFT) |\n\t\t\t\t(IFC_FIR_OP_NOP << IFC_NAND_FIR1_OP7_SHIFT),\n\t\t\t\t&ifc->ifc_nand.nand_fir1);\n\t\t} else {\n\t\t\tnand_fcr0 = ((NAND_CMD_PAGEPROG <<\n\t\t\t\t\tIFC_NAND_FCR0_CMD1_SHIFT) |\n\t\t\t\t    (NAND_CMD_SEQIN <<\n\t\t\t\t\tIFC_NAND_FCR0_CMD2_SHIFT) |\n\t\t\t\t    (NAND_CMD_STATUS <<\n\t\t\t\t\tIFC_NAND_FCR0_CMD3_SHIFT));\n\n\t\t\tifc_out32(\n\t\t\t\t(IFC_FIR_OP_CW0 << IFC_NAND_FIR0_OP0_SHIFT) |\n\t\t\t\t(IFC_FIR_OP_CMD2 << IFC_NAND_FIR0_OP1_SHIFT) |\n\t\t\t\t(IFC_FIR_OP_CA0 << IFC_NAND_FIR0_OP2_SHIFT) |\n\t\t\t\t(IFC_FIR_OP_RA0 << IFC_NAND_FIR0_OP3_SHIFT) |\n\t\t\t\t(IFC_FIR_OP_WBCD << IFC_NAND_FIR0_OP4_SHIFT),\n\t\t\t\t&ifc->ifc_nand.nand_fir0);\n\t\t\tifc_out32(\n\t\t\t\t(IFC_FIR_OP_CMD1 << IFC_NAND_FIR1_OP5_SHIFT) |\n\t\t\t\t(IFC_FIR_OP_CW3 << IFC_NAND_FIR1_OP6_SHIFT) |\n\t\t\t\t(IFC_FIR_OP_RDSTAT << IFC_NAND_FIR1_OP7_SHIFT) |\n\t\t\t\t(IFC_FIR_OP_NOP << IFC_NAND_FIR1_OP8_SHIFT),\n\t\t\t\t&ifc->ifc_nand.nand_fir1);\n\n\t\t\tif (column >= mtd->writesize)\n\t\t\t\tnand_fcr0 |=\n\t\t\t\tNAND_CMD_READOOB << IFC_NAND_FCR0_CMD0_SHIFT;\n\t\t\telse\n\t\t\t\tnand_fcr0 |=\n\t\t\t\tNAND_CMD_READ0 << IFC_NAND_FCR0_CMD0_SHIFT;\n\t\t}\n\n\t\tif (column >= mtd->writesize) {\n\t\t\t \n\t\t\tcolumn -= mtd->writesize;\n\t\t\tifc_nand_ctrl->oob = 1;\n\t\t}\n\t\tifc_out32(nand_fcr0, &ifc->ifc_nand.nand_fcr0);\n\t\tset_addr(mtd, column, page_addr, ifc_nand_ctrl->oob);\n\t\treturn;\n\t}\n\n\t \n\tcase NAND_CMD_PAGEPROG: {\n\t\tif (ifc_nand_ctrl->oob) {\n\t\t\tifc_out32(ifc_nand_ctrl->index -\n\t\t\t\t  ifc_nand_ctrl->column,\n\t\t\t\t  &ifc->ifc_nand.nand_fbcr);\n\t\t} else {\n\t\t\tifc_out32(0, &ifc->ifc_nand.nand_fbcr);\n\t\t}\n\n\t\tfsl_ifc_run_command(mtd);\n\t\treturn;\n\t}\n\n\tcase NAND_CMD_STATUS: {\n\t\tvoid __iomem *addr;\n\n\t\tifc_out32((IFC_FIR_OP_CW0 << IFC_NAND_FIR0_OP0_SHIFT) |\n\t\t\t  (IFC_FIR_OP_RB << IFC_NAND_FIR0_OP1_SHIFT),\n\t\t\t  &ifc->ifc_nand.nand_fir0);\n\t\tifc_out32(NAND_CMD_STATUS << IFC_NAND_FCR0_CMD0_SHIFT,\n\t\t\t  &ifc->ifc_nand.nand_fcr0);\n\t\tifc_out32(1, &ifc->ifc_nand.nand_fbcr);\n\t\tset_addr(mtd, 0, 0, 0);\n\t\tifc_nand_ctrl->read_bytes = 1;\n\n\t\tfsl_ifc_run_command(mtd);\n\n\t\t \n\t\taddr = ifc_nand_ctrl->addr;\n\t\tif (chip->options & NAND_BUSWIDTH_16)\n\t\t\tifc_out16(ifc_in16(addr) | (NAND_STATUS_WP), addr);\n\t\telse\n\t\t\tifc_out8(ifc_in8(addr) | (NAND_STATUS_WP), addr);\n\t\treturn;\n\t}\n\n\tcase NAND_CMD_RESET:\n\t\tifc_out32(IFC_FIR_OP_CW0 << IFC_NAND_FIR0_OP0_SHIFT,\n\t\t\t  &ifc->ifc_nand.nand_fir0);\n\t\tifc_out32(NAND_CMD_RESET << IFC_NAND_FCR0_CMD0_SHIFT,\n\t\t\t  &ifc->ifc_nand.nand_fcr0);\n\t\tfsl_ifc_run_command(mtd);\n\t\treturn;\n\n\tdefault:\n\t\tdev_err(priv->dev, \"%s: error, unsupported command 0x%x.\\n\",\n\t\t\t\t\t__func__, command);\n\t}\n}\n\nstatic void fsl_ifc_select_chip(struct nand_chip *chip, int cs)\n{\n\t \n}\n\n \nstatic void fsl_ifc_write_buf(struct nand_chip *chip, const u8 *buf, int len)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tstruct fsl_ifc_mtd *priv = nand_get_controller_data(chip);\n\tunsigned int bufsize = mtd->writesize + mtd->oobsize;\n\n\tif (len <= 0) {\n\t\tdev_err(priv->dev, \"%s: len %d bytes\", __func__, len);\n\t\treturn;\n\t}\n\n\tif ((unsigned int)len > bufsize - ifc_nand_ctrl->index) {\n\t\tdev_err(priv->dev,\n\t\t\t\"%s: beyond end of buffer (%d requested, %u available)\\n\",\n\t\t\t__func__, len, bufsize - ifc_nand_ctrl->index);\n\t\tlen = bufsize - ifc_nand_ctrl->index;\n\t}\n\n\tmemcpy_toio(ifc_nand_ctrl->addr + ifc_nand_ctrl->index, buf, len);\n\tifc_nand_ctrl->index += len;\n}\n\n \nstatic uint8_t fsl_ifc_read_byte(struct nand_chip *chip)\n{\n\tstruct fsl_ifc_mtd *priv = nand_get_controller_data(chip);\n\tunsigned int offset;\n\n\t \n\tif (ifc_nand_ctrl->index < ifc_nand_ctrl->read_bytes) {\n\t\toffset = ifc_nand_ctrl->index++;\n\t\treturn ifc_in8(ifc_nand_ctrl->addr + offset);\n\t}\n\n\tdev_err(priv->dev, \"%s: beyond end of buffer\\n\", __func__);\n\treturn ERR_BYTE;\n}\n\n \nstatic uint8_t fsl_ifc_read_byte16(struct nand_chip *chip)\n{\n\tstruct fsl_ifc_mtd *priv = nand_get_controller_data(chip);\n\tuint16_t data;\n\n\t \n\tif (ifc_nand_ctrl->index < ifc_nand_ctrl->read_bytes) {\n\t\tdata = ifc_in16(ifc_nand_ctrl->addr + ifc_nand_ctrl->index);\n\t\tifc_nand_ctrl->index += 2;\n\t\treturn (uint8_t) data;\n\t}\n\n\tdev_err(priv->dev, \"%s: beyond end of buffer\\n\", __func__);\n\treturn ERR_BYTE;\n}\n\n \nstatic void fsl_ifc_read_buf(struct nand_chip *chip, u8 *buf, int len)\n{\n\tstruct fsl_ifc_mtd *priv = nand_get_controller_data(chip);\n\tint avail;\n\n\tif (len < 0) {\n\t\tdev_err(priv->dev, \"%s: len %d bytes\", __func__, len);\n\t\treturn;\n\t}\n\n\tavail = min((unsigned int)len,\n\t\t\tifc_nand_ctrl->read_bytes - ifc_nand_ctrl->index);\n\tmemcpy_fromio(buf, ifc_nand_ctrl->addr + ifc_nand_ctrl->index, avail);\n\tifc_nand_ctrl->index += avail;\n\n\tif (len > avail)\n\t\tdev_err(priv->dev,\n\t\t\t\"%s: beyond end of buffer (%d requested, %d available)\\n\",\n\t\t\t__func__, len, avail);\n}\n\n \nstatic int fsl_ifc_wait(struct nand_chip *chip)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tstruct fsl_ifc_mtd *priv = nand_get_controller_data(chip);\n\tstruct fsl_ifc_ctrl *ctrl = priv->ctrl;\n\tstruct fsl_ifc_runtime __iomem *ifc = ctrl->rregs;\n\tu32 nand_fsr;\n\tint status;\n\n\t \n\tifc_out32((IFC_FIR_OP_CW0 << IFC_NAND_FIR0_OP0_SHIFT) |\n\t\t  (IFC_FIR_OP_RDSTAT << IFC_NAND_FIR0_OP1_SHIFT),\n\t\t  &ifc->ifc_nand.nand_fir0);\n\tifc_out32(NAND_CMD_STATUS << IFC_NAND_FCR0_CMD0_SHIFT,\n\t\t  &ifc->ifc_nand.nand_fcr0);\n\tifc_out32(1, &ifc->ifc_nand.nand_fbcr);\n\tset_addr(mtd, 0, 0, 0);\n\tifc_nand_ctrl->read_bytes = 1;\n\n\tfsl_ifc_run_command(mtd);\n\n\tnand_fsr = ifc_in32(&ifc->ifc_nand.nand_fsr);\n\tstatus = nand_fsr >> 24;\n\t \n\treturn status | NAND_STATUS_WP;\n}\n\n \nstatic int check_erased_page(struct nand_chip *chip, u8 *buf)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tu8 *ecc = chip->oob_poi;\n\tconst int ecc_size = chip->ecc.bytes;\n\tconst int pkt_size = chip->ecc.size;\n\tint i, res, bitflips = 0;\n\tstruct mtd_oob_region oobregion = { };\n\n\tmtd_ooblayout_ecc(mtd, 0, &oobregion);\n\tecc += oobregion.offset;\n\n\tfor (i = 0; i < chip->ecc.steps; ++i) {\n\t\tres = nand_check_erased_ecc_chunk(buf, pkt_size, ecc, ecc_size,\n\t\t\t\t\t\t  NULL, 0,\n\t\t\t\t\t\t  chip->ecc.strength);\n\t\tif (res < 0)\n\t\t\tmtd->ecc_stats.failed++;\n\t\telse\n\t\t\tmtd->ecc_stats.corrected += res;\n\n\t\tbitflips = max(res, bitflips);\n\t\tbuf += pkt_size;\n\t\tecc += ecc_size;\n\t}\n\n\treturn bitflips;\n}\n\nstatic int fsl_ifc_read_page(struct nand_chip *chip, uint8_t *buf,\n\t\t\t     int oob_required, int page)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tstruct fsl_ifc_mtd *priv = nand_get_controller_data(chip);\n\tstruct fsl_ifc_ctrl *ctrl = priv->ctrl;\n\tstruct fsl_ifc_nand_ctrl *nctrl = ifc_nand_ctrl;\n\n\tnand_read_page_op(chip, page, 0, buf, mtd->writesize);\n\tif (oob_required)\n\t\tfsl_ifc_read_buf(chip, chip->oob_poi, mtd->oobsize);\n\n\tif (ctrl->nand_stat & IFC_NAND_EVTER_STAT_ECCER) {\n\t\tif (!oob_required)\n\t\t\tfsl_ifc_read_buf(chip, chip->oob_poi, mtd->oobsize);\n\n\t\treturn check_erased_page(chip, buf);\n\t}\n\n\tif (ctrl->nand_stat != IFC_NAND_EVTER_STAT_OPC)\n\t\tmtd->ecc_stats.failed++;\n\n\treturn nctrl->max_bitflips;\n}\n\n \nstatic int fsl_ifc_write_page(struct nand_chip *chip, const uint8_t *buf,\n\t\t\t      int oob_required, int page)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\n\tnand_prog_page_begin_op(chip, page, 0, buf, mtd->writesize);\n\tfsl_ifc_write_buf(chip, chip->oob_poi, mtd->oobsize);\n\n\treturn nand_prog_page_end_op(chip);\n}\n\nstatic int fsl_ifc_attach_chip(struct nand_chip *chip)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tstruct fsl_ifc_mtd *priv = nand_get_controller_data(chip);\n\tstruct fsl_ifc_ctrl *ctrl = priv->ctrl;\n\tstruct fsl_ifc_global __iomem *ifc_global = ctrl->gregs;\n\tu32 csor;\n\n\tcsor = ifc_in32(&ifc_global->csor_cs[priv->bank].csor);\n\n\t \n\tif (csor & CSOR_NAND_ECC_DEC_EN) {\n\t\tchip->ecc.engine_type = NAND_ECC_ENGINE_TYPE_ON_HOST;\n\t\tmtd_set_ooblayout(mtd, &fsl_ifc_ooblayout_ops);\n\n\t\t \n\t\tchip->ecc.size = 512;\n\t\tif ((csor & CSOR_NAND_ECC_MODE_MASK) == CSOR_NAND_ECC_MODE_4) {\n\t\t\tchip->ecc.bytes = 8;\n\t\t\tchip->ecc.strength = 4;\n\t\t} else {\n\t\t\tchip->ecc.bytes = 16;\n\t\t\tchip->ecc.strength = 8;\n\t\t}\n\t} else {\n\t\tchip->ecc.engine_type = NAND_ECC_ENGINE_TYPE_SOFT;\n\t\tchip->ecc.algo = NAND_ECC_ALGO_HAMMING;\n\t}\n\n\tdev_dbg(priv->dev, \"%s: nand->numchips = %d\\n\", __func__,\n\t\tnanddev_ntargets(&chip->base));\n\tdev_dbg(priv->dev, \"%s: nand->chipsize = %lld\\n\", __func__,\n\t        nanddev_target_size(&chip->base));\n\tdev_dbg(priv->dev, \"%s: nand->pagemask = %8x\\n\", __func__,\n\t\t\t\t\t\t\tchip->pagemask);\n\tdev_dbg(priv->dev, \"%s: nand->legacy.chip_delay = %d\\n\", __func__,\n\t\tchip->legacy.chip_delay);\n\tdev_dbg(priv->dev, \"%s: nand->badblockpos = %d\\n\", __func__,\n\t\t\t\t\t\t\tchip->badblockpos);\n\tdev_dbg(priv->dev, \"%s: nand->chip_shift = %d\\n\", __func__,\n\t\t\t\t\t\t\tchip->chip_shift);\n\tdev_dbg(priv->dev, \"%s: nand->page_shift = %d\\n\", __func__,\n\t\t\t\t\t\t\tchip->page_shift);\n\tdev_dbg(priv->dev, \"%s: nand->phys_erase_shift = %d\\n\", __func__,\n\t\t\t\t\t\t\tchip->phys_erase_shift);\n\tdev_dbg(priv->dev, \"%s: nand->ecc.engine_type = %d\\n\", __func__,\n\t\t\t\t\t\t\tchip->ecc.engine_type);\n\tdev_dbg(priv->dev, \"%s: nand->ecc.steps = %d\\n\", __func__,\n\t\t\t\t\t\t\tchip->ecc.steps);\n\tdev_dbg(priv->dev, \"%s: nand->ecc.bytes = %d\\n\", __func__,\n\t\t\t\t\t\t\tchip->ecc.bytes);\n\tdev_dbg(priv->dev, \"%s: nand->ecc.total = %d\\n\", __func__,\n\t\t\t\t\t\t\tchip->ecc.total);\n\tdev_dbg(priv->dev, \"%s: mtd->ooblayout = %p\\n\", __func__,\n\t\t\t\t\t\t\tmtd->ooblayout);\n\tdev_dbg(priv->dev, \"%s: mtd->flags = %08x\\n\", __func__, mtd->flags);\n\tdev_dbg(priv->dev, \"%s: mtd->size = %lld\\n\", __func__, mtd->size);\n\tdev_dbg(priv->dev, \"%s: mtd->erasesize = %d\\n\", __func__,\n\t\t\t\t\t\t\tmtd->erasesize);\n\tdev_dbg(priv->dev, \"%s: mtd->writesize = %d\\n\", __func__,\n\t\t\t\t\t\t\tmtd->writesize);\n\tdev_dbg(priv->dev, \"%s: mtd->oobsize = %d\\n\", __func__,\n\t\t\t\t\t\t\tmtd->oobsize);\n\n\treturn 0;\n}\n\nstatic const struct nand_controller_ops fsl_ifc_controller_ops = {\n\t.attach_chip = fsl_ifc_attach_chip,\n};\n\nstatic int fsl_ifc_sram_init(struct fsl_ifc_mtd *priv)\n{\n\tstruct fsl_ifc_ctrl *ctrl = priv->ctrl;\n\tstruct fsl_ifc_runtime __iomem *ifc_runtime = ctrl->rregs;\n\tstruct fsl_ifc_global __iomem *ifc_global = ctrl->gregs;\n\tuint32_t csor = 0, csor_8k = 0, csor_ext = 0;\n\tuint32_t cs = priv->bank;\n\n\tif (ctrl->version < FSL_IFC_VERSION_1_1_0)\n\t\treturn 0;\n\n\tif (ctrl->version > FSL_IFC_VERSION_1_1_0) {\n\t\tu32 ncfgr, status;\n\t\tint ret;\n\n\t\t \n\t\tncfgr = ifc_in32(&ifc_runtime->ifc_nand.ncfgr);\n\t\tifc_out32(ncfgr | IFC_NAND_NCFGR_SRAM_INIT_EN, &ifc_runtime->ifc_nand.ncfgr);\n\n\t\t \n\t\tret = readx_poll_timeout(ifc_in32, &ifc_runtime->ifc_nand.ncfgr,\n\t\t\t\t\t status, !(status & IFC_NAND_NCFGR_SRAM_INIT_EN),\n\t\t\t\t\t 10, IFC_TIMEOUT_MSECS * 1000);\n\t\tif (ret)\n\t\t\tdev_err(priv->dev, \"Failed to initialize SRAM!\\n\");\n\n\t\treturn ret;\n\t}\n\n\t \n\tcsor = ifc_in32(&ifc_global->csor_cs[cs].csor);\n\tcsor_ext = ifc_in32(&ifc_global->csor_cs[cs].csor_ext);\n\n\t \n\tcsor_8k = (csor & ~(CSOR_NAND_PGS_MASK)) | 0x0018C000;\n\tifc_out32(csor_8k, &ifc_global->csor_cs[cs].csor);\n\tifc_out32(0x0000400, &ifc_global->csor_cs[cs].csor_ext);\n\n\t \n\tifc_out32((IFC_FIR_OP_CW0 << IFC_NAND_FIR0_OP0_SHIFT) |\n\t\t    (IFC_FIR_OP_UA  << IFC_NAND_FIR0_OP1_SHIFT) |\n\t\t    (IFC_FIR_OP_RB << IFC_NAND_FIR0_OP2_SHIFT),\n\t\t    &ifc_runtime->ifc_nand.nand_fir0);\n\tifc_out32(NAND_CMD_READID << IFC_NAND_FCR0_CMD0_SHIFT,\n\t\t    &ifc_runtime->ifc_nand.nand_fcr0);\n\tifc_out32(0x0, &ifc_runtime->ifc_nand.row3);\n\n\tifc_out32(0x0, &ifc_runtime->ifc_nand.nand_fbcr);\n\n\t \n\tifc_out32(0x0, &ifc_runtime->ifc_nand.row0);\n\tifc_out32(0x0, &ifc_runtime->ifc_nand.col0);\n\n\t \n\tifc_out32(cs << IFC_NAND_CSEL_SHIFT,\n\t\t&ifc_runtime->ifc_nand.nand_csel);\n\n\t \n\tifc_out32(IFC_NAND_SEQ_STRT_FIR_STRT,\n\t\t&ifc_runtime->ifc_nand.nandseq_strt);\n\n\t \n\twait_event_timeout(ctrl->nand_wait, ctrl->nand_stat,\n\t\t\t   msecs_to_jiffies(IFC_TIMEOUT_MSECS));\n\n\tif (ctrl->nand_stat != IFC_NAND_EVTER_STAT_OPC) {\n\t\tpr_err(\"fsl-ifc: Failed to Initialise SRAM\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\t \n\tifc_out32(csor, &ifc_global->csor_cs[cs].csor);\n\tifc_out32(csor_ext, &ifc_global->csor_cs[cs].csor_ext);\n\n\treturn 0;\n}\n\nstatic int fsl_ifc_chip_init(struct fsl_ifc_mtd *priv)\n{\n\tstruct fsl_ifc_ctrl *ctrl = priv->ctrl;\n\tstruct fsl_ifc_global __iomem *ifc_global = ctrl->gregs;\n\tstruct fsl_ifc_runtime __iomem *ifc_runtime = ctrl->rregs;\n\tstruct nand_chip *chip = &priv->chip;\n\tstruct mtd_info *mtd = nand_to_mtd(&priv->chip);\n\tu32 csor;\n\tint ret;\n\n\t \n\tmtd->dev.parent = priv->dev;\n\tnand_set_flash_node(chip, priv->dev->of_node);\n\n\t \n\t \n\tif ((ifc_in32(&ifc_global->cspr_cs[priv->bank].cspr))\n\t\t& CSPR_PORT_SIZE_16)\n\t\tchip->legacy.read_byte = fsl_ifc_read_byte16;\n\telse\n\t\tchip->legacy.read_byte = fsl_ifc_read_byte;\n\n\tchip->legacy.write_buf = fsl_ifc_write_buf;\n\tchip->legacy.read_buf = fsl_ifc_read_buf;\n\tchip->legacy.select_chip = fsl_ifc_select_chip;\n\tchip->legacy.cmdfunc = fsl_ifc_cmdfunc;\n\tchip->legacy.waitfunc = fsl_ifc_wait;\n\tchip->legacy.set_features = nand_get_set_features_notsupp;\n\tchip->legacy.get_features = nand_get_set_features_notsupp;\n\n\tchip->bbt_td = &bbt_main_descr;\n\tchip->bbt_md = &bbt_mirror_descr;\n\n\tifc_out32(0x0, &ifc_runtime->ifc_nand.ncfgr);\n\n\t \n\tchip->bbt_options = NAND_BBT_USE_FLASH;\n\tchip->options = NAND_NO_SUBPAGE_WRITE;\n\n\tif (ifc_in32(&ifc_global->cspr_cs[priv->bank].cspr)\n\t\t& CSPR_PORT_SIZE_16) {\n\t\tchip->legacy.read_byte = fsl_ifc_read_byte16;\n\t\tchip->options |= NAND_BUSWIDTH_16;\n\t} else {\n\t\tchip->legacy.read_byte = fsl_ifc_read_byte;\n\t}\n\n\tchip->controller = &ifc_nand_ctrl->controller;\n\tnand_set_controller_data(chip, priv);\n\n\tchip->ecc.read_page = fsl_ifc_read_page;\n\tchip->ecc.write_page = fsl_ifc_write_page;\n\n\tcsor = ifc_in32(&ifc_global->csor_cs[priv->bank].csor);\n\n\tswitch (csor & CSOR_NAND_PGS_MASK) {\n\tcase CSOR_NAND_PGS_512:\n\t\tif (!(chip->options & NAND_BUSWIDTH_16)) {\n\t\t\t \n\t\t\tbbt_main_descr.offs = 0;\n\t\t\tbbt_mirror_descr.offs = 0;\n\t\t}\n\n\t\tpriv->bufnum_mask = 15;\n\t\tbreak;\n\n\tcase CSOR_NAND_PGS_2K:\n\t\tpriv->bufnum_mask = 3;\n\t\tbreak;\n\n\tcase CSOR_NAND_PGS_4K:\n\t\tpriv->bufnum_mask = 1;\n\t\tbreak;\n\n\tcase CSOR_NAND_PGS_8K:\n\t\tpriv->bufnum_mask = 0;\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(priv->dev, \"bad csor %#x: bad page size\\n\", csor);\n\t\treturn -ENODEV;\n\t}\n\n\tret = fsl_ifc_sram_init(priv);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (ctrl->version >= FSL_IFC_VERSION_2_0_0)\n\t\tpriv->bufnum_mask = (priv->bufnum_mask * 2) + 1;\n\n\treturn 0;\n}\n\nstatic int fsl_ifc_chip_remove(struct fsl_ifc_mtd *priv)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(&priv->chip);\n\n\tkfree(mtd->name);\n\n\tif (priv->vbase)\n\t\tiounmap(priv->vbase);\n\n\tifc_nand_ctrl->chips[priv->bank] = NULL;\n\n\treturn 0;\n}\n\nstatic int match_bank(struct fsl_ifc_global __iomem *ifc_global, int bank,\n\t\t      phys_addr_t addr)\n{\n\tu32 cspr = ifc_in32(&ifc_global->cspr_cs[bank].cspr);\n\n\tif (!(cspr & CSPR_V))\n\t\treturn 0;\n\tif ((cspr & CSPR_MSEL) != CSPR_MSEL_NAND)\n\t\treturn 0;\n\n\treturn (cspr & CSPR_BA) == convert_ifc_address(addr);\n}\n\nstatic DEFINE_MUTEX(fsl_ifc_nand_mutex);\n\nstatic int fsl_ifc_nand_probe(struct platform_device *dev)\n{\n\tstruct fsl_ifc_runtime __iomem *ifc;\n\tstruct fsl_ifc_mtd *priv;\n\tstruct resource res;\n\tstatic const char *part_probe_types[]\n\t\t= { \"cmdlinepart\", \"RedBoot\", \"ofpart\", NULL };\n\tint ret;\n\tint bank;\n\tstruct device_node *node = dev->dev.of_node;\n\tstruct mtd_info *mtd;\n\n\tif (!fsl_ifc_ctrl_dev || !fsl_ifc_ctrl_dev->rregs)\n\t\treturn -ENODEV;\n\tifc = fsl_ifc_ctrl_dev->rregs;\n\n\t \n\tret = of_address_to_resource(node, 0, &res);\n\tif (ret) {\n\t\tdev_err(&dev->dev, \"%s: failed to get resource\\n\", __func__);\n\t\treturn ret;\n\t}\n\n\t \n\tfor (bank = 0; bank < fsl_ifc_ctrl_dev->banks; bank++) {\n\t\tif (match_bank(fsl_ifc_ctrl_dev->gregs, bank, res.start))\n\t\t\tbreak;\n\t}\n\n\tif (bank >= fsl_ifc_ctrl_dev->banks) {\n\t\tdev_err(&dev->dev, \"%s: address did not match any chip selects\\n\",\n\t\t\t__func__);\n\t\treturn -ENODEV;\n\t}\n\n\tpriv = devm_kzalloc(&dev->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tmutex_lock(&fsl_ifc_nand_mutex);\n\tif (!fsl_ifc_ctrl_dev->nand) {\n\t\tifc_nand_ctrl = kzalloc(sizeof(*ifc_nand_ctrl), GFP_KERNEL);\n\t\tif (!ifc_nand_ctrl) {\n\t\t\tmutex_unlock(&fsl_ifc_nand_mutex);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tifc_nand_ctrl->read_bytes = 0;\n\t\tifc_nand_ctrl->index = 0;\n\t\tifc_nand_ctrl->addr = NULL;\n\t\tfsl_ifc_ctrl_dev->nand = ifc_nand_ctrl;\n\n\t\tnand_controller_init(&ifc_nand_ctrl->controller);\n\t} else {\n\t\tifc_nand_ctrl = fsl_ifc_ctrl_dev->nand;\n\t}\n\tmutex_unlock(&fsl_ifc_nand_mutex);\n\n\tifc_nand_ctrl->chips[bank] = priv;\n\tpriv->bank = bank;\n\tpriv->ctrl = fsl_ifc_ctrl_dev;\n\tpriv->dev = &dev->dev;\n\n\tpriv->vbase = ioremap(res.start, resource_size(&res));\n\tif (!priv->vbase) {\n\t\tdev_err(priv->dev, \"%s: failed to map chip region\\n\", __func__);\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tdev_set_drvdata(priv->dev, priv);\n\n\tifc_out32(IFC_NAND_EVTER_EN_OPC_EN |\n\t\t  IFC_NAND_EVTER_EN_FTOER_EN |\n\t\t  IFC_NAND_EVTER_EN_WPER_EN,\n\t\t  &ifc->ifc_nand.nand_evter_en);\n\n\t \n\tifc_out32(IFC_NAND_EVTER_INTR_OPCIR_EN |\n\t\t  IFC_NAND_EVTER_INTR_FTOERIR_EN |\n\t\t  IFC_NAND_EVTER_INTR_WPERIR_EN,\n\t\t  &ifc->ifc_nand.nand_evter_intr_en);\n\n\tmtd = nand_to_mtd(&priv->chip);\n\tmtd->name = kasprintf(GFP_KERNEL, \"%llx.flash\", (u64)res.start);\n\tif (!mtd->name) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tret = fsl_ifc_chip_init(priv);\n\tif (ret)\n\t\tgoto err;\n\n\tpriv->chip.controller->ops = &fsl_ifc_controller_ops;\n\tret = nand_scan(&priv->chip, 1);\n\tif (ret)\n\t\tgoto err;\n\n\t \n\tret = mtd_device_parse_register(mtd, part_probe_types, NULL, NULL, 0);\n\tif (ret)\n\t\tgoto cleanup_nand;\n\n\tdev_info(priv->dev, \"IFC NAND device at 0x%llx, bank %d\\n\",\n\t\t (unsigned long long)res.start, priv->bank);\n\n\treturn 0;\n\ncleanup_nand:\n\tnand_cleanup(&priv->chip);\nerr:\n\tfsl_ifc_chip_remove(priv);\n\n\treturn ret;\n}\n\nstatic void fsl_ifc_nand_remove(struct platform_device *dev)\n{\n\tstruct fsl_ifc_mtd *priv = dev_get_drvdata(&dev->dev);\n\tstruct nand_chip *chip = &priv->chip;\n\tint ret;\n\n\tret = mtd_device_unregister(nand_to_mtd(chip));\n\tWARN_ON(ret);\n\tnand_cleanup(chip);\n\n\tfsl_ifc_chip_remove(priv);\n\n\tmutex_lock(&fsl_ifc_nand_mutex);\n\tifc_nand_ctrl->counter--;\n\tif (!ifc_nand_ctrl->counter) {\n\t\tfsl_ifc_ctrl_dev->nand = NULL;\n\t\tkfree(ifc_nand_ctrl);\n\t}\n\tmutex_unlock(&fsl_ifc_nand_mutex);\n}\n\nstatic const struct of_device_id fsl_ifc_nand_match[] = {\n\t{\n\t\t.compatible = \"fsl,ifc-nand\",\n\t},\n\t{}\n};\nMODULE_DEVICE_TABLE(of, fsl_ifc_nand_match);\n\nstatic struct platform_driver fsl_ifc_nand_driver = {\n\t.driver = {\n\t\t.name\t= \"fsl,ifc-nand\",\n\t\t.of_match_table = fsl_ifc_nand_match,\n\t},\n\t.probe       = fsl_ifc_nand_probe,\n\t.remove_new  = fsl_ifc_nand_remove,\n};\n\nmodule_platform_driver(fsl_ifc_nand_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Freescale\");\nMODULE_DESCRIPTION(\"Freescale Integrated Flash Controller MTD NAND driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}