{
  "module_name": "mxc_nand.c",
  "hash_id": "ff03292ac47a7314467a223da515a39647df48db7f5a1fd17e1b6d11226533fd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/nand/raw/mxc_nand.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/mtd/mtd.h>\n#include <linux/mtd/rawnand.h>\n#include <linux/mtd/partitions.h>\n#include <linux/interrupt.h>\n#include <linux/device.h>\n#include <linux/platform_device.h>\n#include <linux/clk.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/irq.h>\n#include <linux/completion.h>\n#include <linux/of.h>\n\n#define DRIVER_NAME \"mxc_nand\"\n\n \n#define NFC_V1_V2_BUF_SIZE\t\t(host->regs + 0x00)\n#define NFC_V1_V2_BUF_ADDR\t\t(host->regs + 0x04)\n#define NFC_V1_V2_FLASH_ADDR\t\t(host->regs + 0x06)\n#define NFC_V1_V2_FLASH_CMD\t\t(host->regs + 0x08)\n#define NFC_V1_V2_CONFIG\t\t(host->regs + 0x0a)\n#define NFC_V1_V2_ECC_STATUS_RESULT\t(host->regs + 0x0c)\n#define NFC_V1_V2_RSLTMAIN_AREA\t\t(host->regs + 0x0e)\n#define NFC_V21_RSLTSPARE_AREA\t\t(host->regs + 0x10)\n#define NFC_V1_V2_WRPROT\t\t(host->regs + 0x12)\n#define NFC_V1_UNLOCKSTART_BLKADDR\t(host->regs + 0x14)\n#define NFC_V1_UNLOCKEND_BLKADDR\t(host->regs + 0x16)\n#define NFC_V21_UNLOCKSTART_BLKADDR0\t(host->regs + 0x20)\n#define NFC_V21_UNLOCKSTART_BLKADDR1\t(host->regs + 0x24)\n#define NFC_V21_UNLOCKSTART_BLKADDR2\t(host->regs + 0x28)\n#define NFC_V21_UNLOCKSTART_BLKADDR3\t(host->regs + 0x2c)\n#define NFC_V21_UNLOCKEND_BLKADDR0\t(host->regs + 0x22)\n#define NFC_V21_UNLOCKEND_BLKADDR1\t(host->regs + 0x26)\n#define NFC_V21_UNLOCKEND_BLKADDR2\t(host->regs + 0x2a)\n#define NFC_V21_UNLOCKEND_BLKADDR3\t(host->regs + 0x2e)\n#define NFC_V1_V2_NF_WRPRST\t\t(host->regs + 0x18)\n#define NFC_V1_V2_CONFIG1\t\t(host->regs + 0x1a)\n#define NFC_V1_V2_CONFIG2\t\t(host->regs + 0x1c)\n\n#define NFC_V2_CONFIG1_ECC_MODE_4\t(1 << 0)\n#define NFC_V1_V2_CONFIG1_SP_EN\t\t(1 << 2)\n#define NFC_V1_V2_CONFIG1_ECC_EN\t(1 << 3)\n#define NFC_V1_V2_CONFIG1_INT_MSK\t(1 << 4)\n#define NFC_V1_V2_CONFIG1_BIG\t\t(1 << 5)\n#define NFC_V1_V2_CONFIG1_RST\t\t(1 << 6)\n#define NFC_V1_V2_CONFIG1_CE\t\t(1 << 7)\n#define NFC_V2_CONFIG1_ONE_CYCLE\t(1 << 8)\n#define NFC_V2_CONFIG1_PPB(x)\t\t(((x) & 0x3) << 9)\n#define NFC_V2_CONFIG1_FP_INT\t\t(1 << 11)\n\n#define NFC_V1_V2_CONFIG2_INT\t\t(1 << 15)\n\n \n#define NFC_CMD\t\t\t\t(1 << 0)\n#define NFC_ADDR\t\t\t(1 << 1)\n#define NFC_INPUT\t\t\t(1 << 2)\n#define NFC_OUTPUT\t\t\t(1 << 3)\n#define NFC_ID\t\t\t\t(1 << 4)\n#define NFC_STATUS\t\t\t(1 << 5)\n\n#define NFC_V3_FLASH_CMD\t\t(host->regs_axi + 0x00)\n#define NFC_V3_FLASH_ADDR0\t\t(host->regs_axi + 0x04)\n\n#define NFC_V3_CONFIG1\t\t\t(host->regs_axi + 0x34)\n#define NFC_V3_CONFIG1_SP_EN\t\t(1 << 0)\n#define NFC_V3_CONFIG1_RBA(x)\t\t(((x) & 0x7 ) << 4)\n\n#define NFC_V3_ECC_STATUS_RESULT\t(host->regs_axi + 0x38)\n\n#define NFC_V3_LAUNCH\t\t\t(host->regs_axi + 0x40)\n\n#define NFC_V3_WRPROT\t\t\t(host->regs_ip + 0x0)\n#define NFC_V3_WRPROT_LOCK_TIGHT\t(1 << 0)\n#define NFC_V3_WRPROT_LOCK\t\t(1 << 1)\n#define NFC_V3_WRPROT_UNLOCK\t\t(1 << 2)\n#define NFC_V3_WRPROT_BLS_UNLOCK\t(2 << 6)\n\n#define NFC_V3_WRPROT_UNLOCK_BLK_ADD0   (host->regs_ip + 0x04)\n\n#define NFC_V3_CONFIG2\t\t\t(host->regs_ip + 0x24)\n#define NFC_V3_CONFIG2_PS_512\t\t\t(0 << 0)\n#define NFC_V3_CONFIG2_PS_2048\t\t\t(1 << 0)\n#define NFC_V3_CONFIG2_PS_4096\t\t\t(2 << 0)\n#define NFC_V3_CONFIG2_ONE_CYCLE\t\t(1 << 2)\n#define NFC_V3_CONFIG2_ECC_EN\t\t\t(1 << 3)\n#define NFC_V3_CONFIG2_2CMD_PHASES\t\t(1 << 4)\n#define NFC_V3_CONFIG2_NUM_ADDR_PHASE0\t\t(1 << 5)\n#define NFC_V3_CONFIG2_ECC_MODE_8\t\t(1 << 6)\n#define NFC_V3_CONFIG2_PPB(x, shift)\t\t(((x) & 0x3) << shift)\n#define NFC_V3_CONFIG2_NUM_ADDR_PHASE1(x)\t(((x) & 0x3) << 12)\n#define NFC_V3_CONFIG2_INT_MSK\t\t\t(1 << 15)\n#define NFC_V3_CONFIG2_ST_CMD(x)\t\t(((x) & 0xff) << 24)\n#define NFC_V3_CONFIG2_SPAS(x)\t\t\t(((x) & 0xff) << 16)\n\n#define NFC_V3_CONFIG3\t\t\t\t(host->regs_ip + 0x28)\n#define NFC_V3_CONFIG3_ADD_OP(x)\t\t(((x) & 0x3) << 0)\n#define NFC_V3_CONFIG3_FW8\t\t\t(1 << 3)\n#define NFC_V3_CONFIG3_SBB(x)\t\t\t(((x) & 0x7) << 8)\n#define NFC_V3_CONFIG3_NUM_OF_DEVICES(x)\t(((x) & 0x7) << 12)\n#define NFC_V3_CONFIG3_RBB_MODE\t\t\t(1 << 15)\n#define NFC_V3_CONFIG3_NO_SDMA\t\t\t(1 << 20)\n\n#define NFC_V3_IPC\t\t\t(host->regs_ip + 0x2C)\n#define NFC_V3_IPC_CREQ\t\t\t(1 << 0)\n#define NFC_V3_IPC_INT\t\t\t(1 << 31)\n\n#define NFC_V3_DELAY_LINE\t\t(host->regs_ip + 0x34)\n\nstruct mxc_nand_host;\n\nstruct mxc_nand_devtype_data {\n\tvoid (*preset)(struct mtd_info *);\n\tint (*read_page)(struct nand_chip *chip, void *buf, void *oob, bool ecc,\n\t\t\t int page);\n\tvoid (*send_cmd)(struct mxc_nand_host *, uint16_t, int);\n\tvoid (*send_addr)(struct mxc_nand_host *, uint16_t, int);\n\tvoid (*send_page)(struct mtd_info *, unsigned int);\n\tvoid (*send_read_id)(struct mxc_nand_host *);\n\tuint16_t (*get_dev_status)(struct mxc_nand_host *);\n\tint (*check_int)(struct mxc_nand_host *);\n\tvoid (*irq_control)(struct mxc_nand_host *, int);\n\tu32 (*get_ecc_status)(struct mxc_nand_host *);\n\tconst struct mtd_ooblayout_ops *ooblayout;\n\tvoid (*select_chip)(struct nand_chip *chip, int cs);\n\tint (*setup_interface)(struct nand_chip *chip, int csline,\n\t\t\t       const struct nand_interface_config *conf);\n\tvoid (*enable_hwecc)(struct nand_chip *chip, bool enable);\n\n\t \n\tint irqpending_quirk;\n\tint needs_ip;\n\n\tsize_t regs_offset;\n\tsize_t spare0_offset;\n\tsize_t axi_offset;\n\n\tint spare_len;\n\tint eccbytes;\n\tint eccsize;\n\tint ppb_shift;\n};\n\nstruct mxc_nand_host {\n\tstruct nand_chip\tnand;\n\tstruct device\t\t*dev;\n\n\tvoid __iomem\t\t*spare0;\n\tvoid __iomem\t\t*main_area0;\n\n\tvoid __iomem\t\t*base;\n\tvoid __iomem\t\t*regs;\n\tvoid __iomem\t\t*regs_axi;\n\tvoid __iomem\t\t*regs_ip;\n\tint\t\t\tstatus_request;\n\tstruct clk\t\t*clk;\n\tint\t\t\tclk_act;\n\tint\t\t\tirq;\n\tint\t\t\teccsize;\n\tint\t\t\tused_oobsize;\n\tint\t\t\tactive_cs;\n\n\tstruct completion\top_completion;\n\n\tuint8_t\t\t\t*data_buf;\n\tunsigned int\t\tbuf_start;\n\n\tconst struct mxc_nand_devtype_data *devtype_data;\n};\n\nstatic const char * const part_probes[] = {\n\t\"cmdlinepart\", \"RedBoot\", \"ofpart\", NULL };\n\nstatic void memcpy32_fromio(void *trg, const void __iomem  *src, size_t size)\n{\n\tint i;\n\tu32 *t = trg;\n\tconst __iomem u32 *s = src;\n\n\tfor (i = 0; i < (size >> 2); i++)\n\t\t*t++ = __raw_readl(s++);\n}\n\nstatic void memcpy16_fromio(void *trg, const void __iomem  *src, size_t size)\n{\n\tint i;\n\tu16 *t = trg;\n\tconst __iomem u16 *s = src;\n\n\t \n\tif (PTR_ALIGN(trg, 4) == trg && IS_ALIGNED(size, 4)) {\n\t\tmemcpy32_fromio(trg, src, size);\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < (size >> 1); i++)\n\t\t*t++ = __raw_readw(s++);\n}\n\nstatic inline void memcpy32_toio(void __iomem *trg, const void *src, int size)\n{\n\t \n\t__iowrite32_copy(trg, src, size / 4);\n}\n\nstatic void memcpy16_toio(void __iomem *trg, const void *src, int size)\n{\n\tint i;\n\t__iomem u16 *t = trg;\n\tconst u16 *s = src;\n\n\t \n\tif (PTR_ALIGN(src, 4) == src && IS_ALIGNED(size, 4)) {\n\t\tmemcpy32_toio(trg, src, size);\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < (size >> 1); i++)\n\t\t__raw_writew(*s++, t++);\n}\n\n \nstatic void copy_spare(struct mtd_info *mtd, bool bfrom, void *buf)\n{\n\tstruct nand_chip *this = mtd_to_nand(mtd);\n\tstruct mxc_nand_host *host = nand_get_controller_data(this);\n\tu16 i, oob_chunk_size;\n\tu16 num_chunks = mtd->writesize / 512;\n\n\tu8 *d = buf;\n\tu8 __iomem *s = host->spare0;\n\tu16 sparebuf_size = host->devtype_data->spare_len;\n\n\t \n\toob_chunk_size = (host->used_oobsize / num_chunks) & ~1;\n\n\tif (bfrom) {\n\t\tfor (i = 0; i < num_chunks - 1; i++)\n\t\t\tmemcpy16_fromio(d + i * oob_chunk_size,\n\t\t\t\t\ts + i * sparebuf_size,\n\t\t\t\t\toob_chunk_size);\n\n\t\t \n\t\tmemcpy16_fromio(d + i * oob_chunk_size,\n\t\t\t\ts + i * sparebuf_size,\n\t\t\t\thost->used_oobsize - i * oob_chunk_size);\n\t} else {\n\t\tfor (i = 0; i < num_chunks - 1; i++)\n\t\t\tmemcpy16_toio(&s[i * sparebuf_size],\n\t\t\t\t      &d[i * oob_chunk_size],\n\t\t\t\t      oob_chunk_size);\n\n\t\t \n\t\tmemcpy16_toio(&s[i * sparebuf_size],\n\t\t\t      &d[i * oob_chunk_size],\n\t\t\t      host->used_oobsize - i * oob_chunk_size);\n\t}\n}\n\n \nstatic void mxc_do_addr_cycle(struct mtd_info *mtd, int column, int page_addr)\n{\n\tstruct nand_chip *nand_chip = mtd_to_nand(mtd);\n\tstruct mxc_nand_host *host = nand_get_controller_data(nand_chip);\n\n\t \n\tif (column != -1) {\n\t\thost->devtype_data->send_addr(host, column & 0xff,\n\t\t\t\t\t      page_addr == -1);\n\t\tif (mtd->writesize > 512)\n\t\t\t \n\t\t\thost->devtype_data->send_addr(host,\n\t\t\t\t\t\t      (column >> 8) & 0xff,\n\t\t\t\t\t\t      false);\n\t}\n\n\t \n\tif (page_addr != -1) {\n\t\t \n\t\thost->devtype_data->send_addr(host, (page_addr & 0xff), false);\n\n\t\tif (mtd->writesize > 512) {\n\t\t\tif (mtd->size >= 0x10000000) {\n\t\t\t\t \n\t\t\t\thost->devtype_data->send_addr(host,\n\t\t\t\t\t\t(page_addr >> 8) & 0xff,\n\t\t\t\t\t\tfalse);\n\t\t\t\thost->devtype_data->send_addr(host,\n\t\t\t\t\t\t(page_addr >> 16) & 0xff,\n\t\t\t\t\t\ttrue);\n\t\t\t} else\n\t\t\t\t \n\t\t\t\thost->devtype_data->send_addr(host,\n\t\t\t\t\t\t(page_addr >> 8) & 0xff, true);\n\t\t} else {\n\t\t\tif (nand_chip->options & NAND_ROW_ADDR_3) {\n\t\t\t\t \n\t\t\t\thost->devtype_data->send_addr(host,\n\t\t\t\t\t\t(page_addr >> 8) & 0xff,\n\t\t\t\t\t\tfalse);\n\t\t\t\thost->devtype_data->send_addr(host,\n\t\t\t\t\t\t(page_addr >> 16) & 0xff,\n\t\t\t\t\t\ttrue);\n\t\t\t} else\n\t\t\t\t \n\t\t\t\thost->devtype_data->send_addr(host,\n\t\t\t\t\t\t(page_addr >> 8) & 0xff, true);\n\t\t}\n\t}\n}\n\nstatic int check_int_v3(struct mxc_nand_host *host)\n{\n\tuint32_t tmp;\n\n\ttmp = readl(NFC_V3_IPC);\n\tif (!(tmp & NFC_V3_IPC_INT))\n\t\treturn 0;\n\n\ttmp &= ~NFC_V3_IPC_INT;\n\twritel(tmp, NFC_V3_IPC);\n\n\treturn 1;\n}\n\nstatic int check_int_v1_v2(struct mxc_nand_host *host)\n{\n\tuint32_t tmp;\n\n\ttmp = readw(NFC_V1_V2_CONFIG2);\n\tif (!(tmp & NFC_V1_V2_CONFIG2_INT))\n\t\treturn 0;\n\n\tif (!host->devtype_data->irqpending_quirk)\n\t\twritew(tmp & ~NFC_V1_V2_CONFIG2_INT, NFC_V1_V2_CONFIG2);\n\n\treturn 1;\n}\n\nstatic void irq_control_v1_v2(struct mxc_nand_host *host, int activate)\n{\n\tuint16_t tmp;\n\n\ttmp = readw(NFC_V1_V2_CONFIG1);\n\n\tif (activate)\n\t\ttmp &= ~NFC_V1_V2_CONFIG1_INT_MSK;\n\telse\n\t\ttmp |= NFC_V1_V2_CONFIG1_INT_MSK;\n\n\twritew(tmp, NFC_V1_V2_CONFIG1);\n}\n\nstatic void irq_control_v3(struct mxc_nand_host *host, int activate)\n{\n\tuint32_t tmp;\n\n\ttmp = readl(NFC_V3_CONFIG2);\n\n\tif (activate)\n\t\ttmp &= ~NFC_V3_CONFIG2_INT_MSK;\n\telse\n\t\ttmp |= NFC_V3_CONFIG2_INT_MSK;\n\n\twritel(tmp, NFC_V3_CONFIG2);\n}\n\nstatic void irq_control(struct mxc_nand_host *host, int activate)\n{\n\tif (host->devtype_data->irqpending_quirk) {\n\t\tif (activate)\n\t\t\tenable_irq(host->irq);\n\t\telse\n\t\t\tdisable_irq_nosync(host->irq);\n\t} else {\n\t\thost->devtype_data->irq_control(host, activate);\n\t}\n}\n\nstatic u32 get_ecc_status_v1(struct mxc_nand_host *host)\n{\n\treturn readw(NFC_V1_V2_ECC_STATUS_RESULT);\n}\n\nstatic u32 get_ecc_status_v2(struct mxc_nand_host *host)\n{\n\treturn readl(NFC_V1_V2_ECC_STATUS_RESULT);\n}\n\nstatic u32 get_ecc_status_v3(struct mxc_nand_host *host)\n{\n\treturn readl(NFC_V3_ECC_STATUS_RESULT);\n}\n\nstatic irqreturn_t mxc_nfc_irq(int irq, void *dev_id)\n{\n\tstruct mxc_nand_host *host = dev_id;\n\n\tif (!host->devtype_data->check_int(host))\n\t\treturn IRQ_NONE;\n\n\tirq_control(host, 0);\n\n\tcomplete(&host->op_completion);\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic int wait_op_done(struct mxc_nand_host *host, int useirq)\n{\n\tint ret = 0;\n\n\t \n\tif (host->devtype_data->check_int(host))\n\t\treturn 0;\n\n\tif (useirq) {\n\t\tunsigned long timeout;\n\n\t\treinit_completion(&host->op_completion);\n\n\t\tirq_control(host, 1);\n\n\t\ttimeout = wait_for_completion_timeout(&host->op_completion, HZ);\n\t\tif (!timeout && !host->devtype_data->check_int(host)) {\n\t\t\tdev_dbg(host->dev, \"timeout waiting for irq\\n\");\n\t\t\tret = -ETIMEDOUT;\n\t\t}\n\t} else {\n\t\tint max_retries = 8000;\n\t\tint done;\n\n\t\tdo {\n\t\t\tudelay(1);\n\n\t\t\tdone = host->devtype_data->check_int(host);\n\t\t\tif (done)\n\t\t\t\tbreak;\n\n\t\t} while (--max_retries);\n\n\t\tif (!done) {\n\t\t\tdev_dbg(host->dev, \"timeout polling for completion\\n\");\n\t\t\tret = -ETIMEDOUT;\n\t\t}\n\t}\n\n\tWARN_ONCE(ret < 0, \"timeout! useirq=%d\\n\", useirq);\n\n\treturn ret;\n}\n\nstatic void send_cmd_v3(struct mxc_nand_host *host, uint16_t cmd, int useirq)\n{\n\t \n\twritel(cmd, NFC_V3_FLASH_CMD);\n\n\t \n\twritel(NFC_CMD, NFC_V3_LAUNCH);\n\n\t \n\twait_op_done(host, useirq);\n}\n\n \nstatic void send_cmd_v1_v2(struct mxc_nand_host *host, uint16_t cmd, int useirq)\n{\n\tdev_dbg(host->dev, \"send_cmd(host, 0x%x, %d)\\n\", cmd, useirq);\n\n\twritew(cmd, NFC_V1_V2_FLASH_CMD);\n\twritew(NFC_CMD, NFC_V1_V2_CONFIG2);\n\n\tif (host->devtype_data->irqpending_quirk && (cmd == NAND_CMD_RESET)) {\n\t\tint max_retries = 100;\n\t\t \n\t\t \n\t\twhile (max_retries-- > 0) {\n\t\t\tif (readw(NFC_V1_V2_CONFIG2) == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tudelay(1);\n\t\t}\n\t\tif (max_retries < 0)\n\t\t\tdev_dbg(host->dev, \"%s: RESET failed\\n\", __func__);\n\t} else {\n\t\t \n\t\twait_op_done(host, useirq);\n\t}\n}\n\nstatic void send_addr_v3(struct mxc_nand_host *host, uint16_t addr, int islast)\n{\n\t \n\twritel(addr, NFC_V3_FLASH_ADDR0);\n\n\t \n\twritel(NFC_ADDR, NFC_V3_LAUNCH);\n\n\twait_op_done(host, 0);\n}\n\n \nstatic void send_addr_v1_v2(struct mxc_nand_host *host, uint16_t addr, int islast)\n{\n\tdev_dbg(host->dev, \"send_addr(host, 0x%x %d)\\n\", addr, islast);\n\n\twritew(addr, NFC_V1_V2_FLASH_ADDR);\n\twritew(NFC_ADDR, NFC_V1_V2_CONFIG2);\n\n\t \n\twait_op_done(host, islast);\n}\n\nstatic void send_page_v3(struct mtd_info *mtd, unsigned int ops)\n{\n\tstruct nand_chip *nand_chip = mtd_to_nand(mtd);\n\tstruct mxc_nand_host *host = nand_get_controller_data(nand_chip);\n\tuint32_t tmp;\n\n\ttmp = readl(NFC_V3_CONFIG1);\n\ttmp &= ~(7 << 4);\n\twritel(tmp, NFC_V3_CONFIG1);\n\n\t \n\twritel(ops, NFC_V3_LAUNCH);\n\n\twait_op_done(host, false);\n}\n\nstatic void send_page_v2(struct mtd_info *mtd, unsigned int ops)\n{\n\tstruct nand_chip *nand_chip = mtd_to_nand(mtd);\n\tstruct mxc_nand_host *host = nand_get_controller_data(nand_chip);\n\n\t \n\twritew(host->active_cs << 4, NFC_V1_V2_BUF_ADDR);\n\n\twritew(ops, NFC_V1_V2_CONFIG2);\n\n\t \n\twait_op_done(host, true);\n}\n\nstatic void send_page_v1(struct mtd_info *mtd, unsigned int ops)\n{\n\tstruct nand_chip *nand_chip = mtd_to_nand(mtd);\n\tstruct mxc_nand_host *host = nand_get_controller_data(nand_chip);\n\tint bufs, i;\n\n\tif (mtd->writesize > 512)\n\t\tbufs = 4;\n\telse\n\t\tbufs = 1;\n\n\tfor (i = 0; i < bufs; i++) {\n\n\t\t \n\t\twritew((host->active_cs << 4) | i, NFC_V1_V2_BUF_ADDR);\n\n\t\twritew(ops, NFC_V1_V2_CONFIG2);\n\n\t\t \n\t\twait_op_done(host, true);\n\t}\n}\n\nstatic void send_read_id_v3(struct mxc_nand_host *host)\n{\n\t \n\twritel(NFC_ID, NFC_V3_LAUNCH);\n\n\twait_op_done(host, true);\n\n\tmemcpy32_fromio(host->data_buf, host->main_area0, 16);\n}\n\n \nstatic void send_read_id_v1_v2(struct mxc_nand_host *host)\n{\n\t \n\twritew(host->active_cs << 4, NFC_V1_V2_BUF_ADDR);\n\n\twritew(NFC_ID, NFC_V1_V2_CONFIG2);\n\n\t \n\twait_op_done(host, true);\n\n\tmemcpy32_fromio(host->data_buf, host->main_area0, 16);\n}\n\nstatic uint16_t get_dev_status_v3(struct mxc_nand_host *host)\n{\n\twritew(NFC_STATUS, NFC_V3_LAUNCH);\n\twait_op_done(host, true);\n\n\treturn readl(NFC_V3_CONFIG1) >> 16;\n}\n\n \nstatic uint16_t get_dev_status_v1_v2(struct mxc_nand_host *host)\n{\n\tvoid __iomem *main_buf = host->main_area0;\n\tuint32_t store;\n\tuint16_t ret;\n\n\twritew(host->active_cs << 4, NFC_V1_V2_BUF_ADDR);\n\n\t \n\tstore = readl(main_buf);\n\n\twritew(NFC_STATUS, NFC_V1_V2_CONFIG2);\n\twait_op_done(host, true);\n\n\tret = readw(main_buf);\n\n\twritel(store, main_buf);\n\n\treturn ret;\n}\n\nstatic void mxc_nand_enable_hwecc_v1_v2(struct nand_chip *chip, bool enable)\n{\n\tstruct mxc_nand_host *host = nand_get_controller_data(chip);\n\tuint16_t config1;\n\n\tif (chip->ecc.engine_type != NAND_ECC_ENGINE_TYPE_ON_HOST)\n\t\treturn;\n\n\tconfig1 = readw(NFC_V1_V2_CONFIG1);\n\n\tif (enable)\n\t\tconfig1 |= NFC_V1_V2_CONFIG1_ECC_EN;\n\telse\n\t\tconfig1 &= ~NFC_V1_V2_CONFIG1_ECC_EN;\n\n\twritew(config1, NFC_V1_V2_CONFIG1);\n}\n\nstatic void mxc_nand_enable_hwecc_v3(struct nand_chip *chip, bool enable)\n{\n\tstruct mxc_nand_host *host = nand_get_controller_data(chip);\n\tuint32_t config2;\n\n\tif (chip->ecc.engine_type != NAND_ECC_ENGINE_TYPE_ON_HOST)\n\t\treturn;\n\n\tconfig2 = readl(NFC_V3_CONFIG2);\n\n\tif (enable)\n\t\tconfig2 |= NFC_V3_CONFIG2_ECC_EN;\n\telse\n\t\tconfig2 &= ~NFC_V3_CONFIG2_ECC_EN;\n\n\twritel(config2, NFC_V3_CONFIG2);\n}\n\n \nstatic int mxc_nand_dev_ready(struct nand_chip *chip)\n{\n\t \n\treturn 1;\n}\n\nstatic int mxc_nand_read_page_v1(struct nand_chip *chip, void *buf, void *oob,\n\t\t\t\t bool ecc, int page)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tstruct mxc_nand_host *host = nand_get_controller_data(chip);\n\tunsigned int bitflips_corrected = 0;\n\tint no_subpages;\n\tint i;\n\n\thost->devtype_data->enable_hwecc(chip, ecc);\n\n\thost->devtype_data->send_cmd(host, NAND_CMD_READ0, false);\n\tmxc_do_addr_cycle(mtd, 0, page);\n\n\tif (mtd->writesize > 512)\n\t\thost->devtype_data->send_cmd(host, NAND_CMD_READSTART, true);\n\n\tno_subpages = mtd->writesize >> 9;\n\n\tfor (i = 0; i < no_subpages; i++) {\n\t\tuint16_t ecc_stats;\n\n\t\t \n\t\twritew((host->active_cs << 4) | i, NFC_V1_V2_BUF_ADDR);\n\n\t\twritew(NFC_OUTPUT, NFC_V1_V2_CONFIG2);\n\n\t\t \n\t\twait_op_done(host, true);\n\n\t\tecc_stats = get_ecc_status_v1(host);\n\n\t\tecc_stats >>= 2;\n\n\t\tif (buf && ecc) {\n\t\t\tswitch (ecc_stats & 0x3) {\n\t\t\tcase 0:\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tmtd->ecc_stats.corrected++;\n\t\t\t\tbitflips_corrected = 1;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tmtd->ecc_stats.failed++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (buf)\n\t\tmemcpy32_fromio(buf, host->main_area0, mtd->writesize);\n\tif (oob)\n\t\tcopy_spare(mtd, true, oob);\n\n\treturn bitflips_corrected;\n}\n\nstatic int mxc_nand_read_page_v2_v3(struct nand_chip *chip, void *buf,\n\t\t\t\t    void *oob, bool ecc, int page)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tstruct mxc_nand_host *host = nand_get_controller_data(chip);\n\tunsigned int max_bitflips = 0;\n\tu32 ecc_stat, err;\n\tint no_subpages;\n\tu8 ecc_bit_mask, err_limit;\n\n\thost->devtype_data->enable_hwecc(chip, ecc);\n\n\thost->devtype_data->send_cmd(host, NAND_CMD_READ0, false);\n\tmxc_do_addr_cycle(mtd, 0, page);\n\n\tif (mtd->writesize > 512)\n\t\thost->devtype_data->send_cmd(host,\n\t\t\t\tNAND_CMD_READSTART, true);\n\n\thost->devtype_data->send_page(mtd, NFC_OUTPUT);\n\n\tif (buf)\n\t\tmemcpy32_fromio(buf, host->main_area0, mtd->writesize);\n\tif (oob)\n\t\tcopy_spare(mtd, true, oob);\n\n\tecc_bit_mask = (host->eccsize == 4) ? 0x7 : 0xf;\n\terr_limit = (host->eccsize == 4) ? 0x4 : 0x8;\n\n\tno_subpages = mtd->writesize >> 9;\n\n\tecc_stat = host->devtype_data->get_ecc_status(host);\n\n\tdo {\n\t\terr = ecc_stat & ecc_bit_mask;\n\t\tif (err > err_limit) {\n\t\t\tmtd->ecc_stats.failed++;\n\t\t} else {\n\t\t\tmtd->ecc_stats.corrected += err;\n\t\t\tmax_bitflips = max_t(unsigned int, max_bitflips, err);\n\t\t}\n\n\t\tecc_stat >>= 4;\n\t} while (--no_subpages);\n\n\treturn max_bitflips;\n}\n\nstatic int mxc_nand_read_page(struct nand_chip *chip, uint8_t *buf,\n\t\t\t      int oob_required, int page)\n{\n\tstruct mxc_nand_host *host = nand_get_controller_data(chip);\n\tvoid *oob_buf;\n\n\tif (oob_required)\n\t\toob_buf = chip->oob_poi;\n\telse\n\t\toob_buf = NULL;\n\n\treturn host->devtype_data->read_page(chip, buf, oob_buf, 1, page);\n}\n\nstatic int mxc_nand_read_page_raw(struct nand_chip *chip, uint8_t *buf,\n\t\t\t\t  int oob_required, int page)\n{\n\tstruct mxc_nand_host *host = nand_get_controller_data(chip);\n\tvoid *oob_buf;\n\n\tif (oob_required)\n\t\toob_buf = chip->oob_poi;\n\telse\n\t\toob_buf = NULL;\n\n\treturn host->devtype_data->read_page(chip, buf, oob_buf, 0, page);\n}\n\nstatic int mxc_nand_read_oob(struct nand_chip *chip, int page)\n{\n\tstruct mxc_nand_host *host = nand_get_controller_data(chip);\n\n\treturn host->devtype_data->read_page(chip, NULL, chip->oob_poi, 0,\n\t\t\t\t\t     page);\n}\n\nstatic int mxc_nand_write_page(struct nand_chip *chip, const uint8_t *buf,\n\t\t\t       bool ecc, int page)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tstruct mxc_nand_host *host = nand_get_controller_data(chip);\n\n\thost->devtype_data->enable_hwecc(chip, ecc);\n\n\thost->devtype_data->send_cmd(host, NAND_CMD_SEQIN, false);\n\tmxc_do_addr_cycle(mtd, 0, page);\n\n\tmemcpy32_toio(host->main_area0, buf, mtd->writesize);\n\tcopy_spare(mtd, false, chip->oob_poi);\n\n\thost->devtype_data->send_page(mtd, NFC_INPUT);\n\thost->devtype_data->send_cmd(host, NAND_CMD_PAGEPROG, true);\n\tmxc_do_addr_cycle(mtd, 0, page);\n\n\treturn 0;\n}\n\nstatic int mxc_nand_write_page_ecc(struct nand_chip *chip, const uint8_t *buf,\n\t\t\t\t   int oob_required, int page)\n{\n\treturn mxc_nand_write_page(chip, buf, true, page);\n}\n\nstatic int mxc_nand_write_page_raw(struct nand_chip *chip, const uint8_t *buf,\n\t\t\t\t   int oob_required, int page)\n{\n\treturn mxc_nand_write_page(chip, buf, false, page);\n}\n\nstatic int mxc_nand_write_oob(struct nand_chip *chip, int page)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tstruct mxc_nand_host *host = nand_get_controller_data(chip);\n\n\tmemset(host->data_buf, 0xff, mtd->writesize);\n\n\treturn mxc_nand_write_page(chip, host->data_buf, false, page);\n}\n\nstatic u_char mxc_nand_read_byte(struct nand_chip *nand_chip)\n{\n\tstruct mxc_nand_host *host = nand_get_controller_data(nand_chip);\n\tuint8_t ret;\n\n\t \n\tif (host->status_request)\n\t\treturn host->devtype_data->get_dev_status(host) & 0xFF;\n\n\tif (nand_chip->options & NAND_BUSWIDTH_16) {\n\t\t \n\t\tret = *(uint16_t *)(host->data_buf + host->buf_start);\n\n\t\thost->buf_start += 2;\n\t} else {\n\t\tret = *(uint8_t *)(host->data_buf + host->buf_start);\n\t\thost->buf_start++;\n\t}\n\n\tdev_dbg(host->dev, \"%s: ret=0x%hhx (start=%u)\\n\", __func__, ret, host->buf_start);\n\treturn ret;\n}\n\n \nstatic void mxc_nand_write_buf(struct nand_chip *nand_chip, const u_char *buf,\n\t\t\t       int len)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(nand_chip);\n\tstruct mxc_nand_host *host = nand_get_controller_data(nand_chip);\n\tu16 col = host->buf_start;\n\tint n = mtd->oobsize + mtd->writesize - col;\n\n\tn = min(n, len);\n\n\tmemcpy(host->data_buf + col, buf, n);\n\n\thost->buf_start += n;\n}\n\n \nstatic void mxc_nand_read_buf(struct nand_chip *nand_chip, u_char *buf,\n\t\t\t      int len)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(nand_chip);\n\tstruct mxc_nand_host *host = nand_get_controller_data(nand_chip);\n\tu16 col = host->buf_start;\n\tint n = mtd->oobsize + mtd->writesize - col;\n\n\tn = min(n, len);\n\n\tmemcpy(buf, host->data_buf + col, n);\n\n\thost->buf_start += n;\n}\n\n \nstatic void mxc_nand_select_chip_v1_v3(struct nand_chip *nand_chip, int chip)\n{\n\tstruct mxc_nand_host *host = nand_get_controller_data(nand_chip);\n\n\tif (chip == -1) {\n\t\t \n\t\tif (host->clk_act) {\n\t\t\tclk_disable_unprepare(host->clk);\n\t\t\thost->clk_act = 0;\n\t\t}\n\t\treturn;\n\t}\n\n\tif (!host->clk_act) {\n\t\t \n\t\tclk_prepare_enable(host->clk);\n\t\thost->clk_act = 1;\n\t}\n}\n\nstatic void mxc_nand_select_chip_v2(struct nand_chip *nand_chip, int chip)\n{\n\tstruct mxc_nand_host *host = nand_get_controller_data(nand_chip);\n\n\tif (chip == -1) {\n\t\t \n\t\tif (host->clk_act) {\n\t\t\tclk_disable_unprepare(host->clk);\n\t\t\thost->clk_act = 0;\n\t\t}\n\t\treturn;\n\t}\n\n\tif (!host->clk_act) {\n\t\t \n\t\tclk_prepare_enable(host->clk);\n\t\thost->clk_act = 1;\n\t}\n\n\thost->active_cs = chip;\n\twritew(host->active_cs << 4, NFC_V1_V2_BUF_ADDR);\n}\n\n#define MXC_V1_ECCBYTES\t\t5\n\nstatic int mxc_v1_ooblayout_ecc(struct mtd_info *mtd, int section,\n\t\t\t\tstruct mtd_oob_region *oobregion)\n{\n\tstruct nand_chip *nand_chip = mtd_to_nand(mtd);\n\n\tif (section >= nand_chip->ecc.steps)\n\t\treturn -ERANGE;\n\n\toobregion->offset = (section * 16) + 6;\n\toobregion->length = MXC_V1_ECCBYTES;\n\n\treturn 0;\n}\n\nstatic int mxc_v1_ooblayout_free(struct mtd_info *mtd, int section,\n\t\t\t\t struct mtd_oob_region *oobregion)\n{\n\tstruct nand_chip *nand_chip = mtd_to_nand(mtd);\n\n\tif (section > nand_chip->ecc.steps)\n\t\treturn -ERANGE;\n\n\tif (!section) {\n\t\tif (mtd->writesize <= 512) {\n\t\t\toobregion->offset = 0;\n\t\t\toobregion->length = 5;\n\t\t} else {\n\t\t\toobregion->offset = 2;\n\t\t\toobregion->length = 4;\n\t\t}\n\t} else {\n\t\toobregion->offset = ((section - 1) * 16) + MXC_V1_ECCBYTES + 6;\n\t\tif (section < nand_chip->ecc.steps)\n\t\t\toobregion->length = (section * 16) + 6 -\n\t\t\t\t\t    oobregion->offset;\n\t\telse\n\t\t\toobregion->length = mtd->oobsize - oobregion->offset;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct mtd_ooblayout_ops mxc_v1_ooblayout_ops = {\n\t.ecc = mxc_v1_ooblayout_ecc,\n\t.free = mxc_v1_ooblayout_free,\n};\n\nstatic int mxc_v2_ooblayout_ecc(struct mtd_info *mtd, int section,\n\t\t\t\tstruct mtd_oob_region *oobregion)\n{\n\tstruct nand_chip *nand_chip = mtd_to_nand(mtd);\n\tint stepsize = nand_chip->ecc.bytes == 9 ? 16 : 26;\n\n\tif (section >= nand_chip->ecc.steps)\n\t\treturn -ERANGE;\n\n\toobregion->offset = (section * stepsize) + 7;\n\toobregion->length = nand_chip->ecc.bytes;\n\n\treturn 0;\n}\n\nstatic int mxc_v2_ooblayout_free(struct mtd_info *mtd, int section,\n\t\t\t\t struct mtd_oob_region *oobregion)\n{\n\tstruct nand_chip *nand_chip = mtd_to_nand(mtd);\n\tint stepsize = nand_chip->ecc.bytes == 9 ? 16 : 26;\n\n\tif (section >= nand_chip->ecc.steps)\n\t\treturn -ERANGE;\n\n\tif (!section) {\n\t\tif (mtd->writesize <= 512) {\n\t\t\toobregion->offset = 0;\n\t\t\toobregion->length = 5;\n\t\t} else {\n\t\t\toobregion->offset = 2;\n\t\t\toobregion->length = 4;\n\t\t}\n\t} else {\n\t\toobregion->offset = section * stepsize;\n\t\toobregion->length = 7;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct mtd_ooblayout_ops mxc_v2_ooblayout_ops = {\n\t.ecc = mxc_v2_ooblayout_ecc,\n\t.free = mxc_v2_ooblayout_free,\n};\n\n \nstatic int get_eccsize(struct mtd_info *mtd)\n{\n\tint oobbytes_per_512 = 0;\n\n\toobbytes_per_512 = mtd->oobsize * 512 / mtd->writesize;\n\n\tif (oobbytes_per_512 < 26)\n\t\treturn 4;\n\telse\n\t\treturn 8;\n}\n\nstatic void preset_v1(struct mtd_info *mtd)\n{\n\tstruct nand_chip *nand_chip = mtd_to_nand(mtd);\n\tstruct mxc_nand_host *host = nand_get_controller_data(nand_chip);\n\tuint16_t config1 = 0;\n\n\tif (nand_chip->ecc.engine_type == NAND_ECC_ENGINE_TYPE_ON_HOST &&\n\t    mtd->writesize)\n\t\tconfig1 |= NFC_V1_V2_CONFIG1_ECC_EN;\n\n\tif (!host->devtype_data->irqpending_quirk)\n\t\tconfig1 |= NFC_V1_V2_CONFIG1_INT_MSK;\n\n\thost->eccsize = 1;\n\n\twritew(config1, NFC_V1_V2_CONFIG1);\n\t \n\n\t \n\twritew(0x2, NFC_V1_V2_CONFIG);\n\n\t \n\twritew(0x0, NFC_V1_UNLOCKSTART_BLKADDR);\n\twritew(0xffff, NFC_V1_UNLOCKEND_BLKADDR);\n\n\t \n\twritew(0x4, NFC_V1_V2_WRPROT);\n}\n\nstatic int mxc_nand_v2_setup_interface(struct nand_chip *chip, int csline,\n\t\t\t\t       const struct nand_interface_config *conf)\n{\n\tstruct mxc_nand_host *host = nand_get_controller_data(chip);\n\tint tRC_min_ns, tRC_ps, ret;\n\tunsigned long rate, rate_round;\n\tconst struct nand_sdr_timings *timings;\n\tu16 config1;\n\n\ttimings = nand_get_sdr_timings(conf);\n\tif (IS_ERR(timings))\n\t\treturn -ENOTSUPP;\n\n\tconfig1 = readw(NFC_V1_V2_CONFIG1);\n\n\ttRC_min_ns = timings->tRC_min / 1000;\n\trate = 1000000000 / tRC_min_ns;\n\n\t \n\tif (tRC_min_ns < 30) {\n\t\trate_round = clk_round_rate(host->clk, rate);\n\t\tconfig1 |= NFC_V2_CONFIG1_ONE_CYCLE;\n\t\ttRC_ps = 1000000000 / (rate_round / 1000);\n\t} else {\n\t\trate *= 2;\n\t\trate_round = clk_round_rate(host->clk, rate);\n\t\tconfig1 &= ~NFC_V2_CONFIG1_ONE_CYCLE;\n\t\ttRC_ps = 1000000000 / (rate_round / 1000 / 2);\n\t}\n\n\t \n\tif (timings->tCLS_min > tRC_ps - 1000 ||\n\t    timings->tCLH_min > tRC_ps - 2000 ||\n\t    timings->tCS_min > tRC_ps - 1000 ||\n\t    timings->tCH_min > tRC_ps - 2000 ||\n\t    timings->tWP_min > tRC_ps - 1500 ||\n\t    timings->tALS_min > tRC_ps ||\n\t    timings->tALH_min > tRC_ps - 3000 ||\n\t    timings->tDS_min > tRC_ps ||\n\t    timings->tDH_min > tRC_ps - 5000 ||\n\t    timings->tWC_min > 2 * tRC_ps ||\n\t    timings->tWH_min > tRC_ps - 2500 ||\n\t    timings->tRR_min > 6 * tRC_ps ||\n\t    timings->tRP_min > 3 * tRC_ps / 2 ||\n\t    timings->tRC_min > 2 * tRC_ps ||\n\t    timings->tREH_min > (tRC_ps / 2) - 2500) {\n\t\tdev_dbg(host->dev, \"Timing out of bounds\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (csline == NAND_DATA_IFACE_CHECK_ONLY)\n\t\treturn 0;\n\n\tret = clk_set_rate(host->clk, rate);\n\tif (ret)\n\t\treturn ret;\n\n\twritew(config1, NFC_V1_V2_CONFIG1);\n\n\tdev_dbg(host->dev, \"Setting rate to %ldHz, %s mode\\n\", rate_round,\n\t\tconfig1 & NFC_V2_CONFIG1_ONE_CYCLE ? \"One cycle (EDO)\" :\n\t\t\"normal\");\n\n\treturn 0;\n}\n\nstatic void preset_v2(struct mtd_info *mtd)\n{\n\tstruct nand_chip *nand_chip = mtd_to_nand(mtd);\n\tstruct mxc_nand_host *host = nand_get_controller_data(nand_chip);\n\tuint16_t config1 = 0;\n\n\tconfig1 |= NFC_V2_CONFIG1_FP_INT;\n\n\tif (!host->devtype_data->irqpending_quirk)\n\t\tconfig1 |= NFC_V1_V2_CONFIG1_INT_MSK;\n\n\tif (mtd->writesize) {\n\t\tuint16_t pages_per_block = mtd->erasesize / mtd->writesize;\n\n\t\tif (nand_chip->ecc.engine_type == NAND_ECC_ENGINE_TYPE_ON_HOST)\n\t\t\tconfig1 |= NFC_V1_V2_CONFIG1_ECC_EN;\n\n\t\thost->eccsize = get_eccsize(mtd);\n\t\tif (host->eccsize == 4)\n\t\t\tconfig1 |= NFC_V2_CONFIG1_ECC_MODE_4;\n\n\t\tconfig1 |= NFC_V2_CONFIG1_PPB(ffs(pages_per_block) - 6);\n\t} else {\n\t\thost->eccsize = 1;\n\t}\n\n\twritew(config1, NFC_V1_V2_CONFIG1);\n\t \n\n\t \n\twritew(mtd->oobsize / 2, NFC_V21_RSLTSPARE_AREA);\n\n\t \n\twritew(0x2, NFC_V1_V2_CONFIG);\n\n\t \n\twritew(0x0, NFC_V21_UNLOCKSTART_BLKADDR0);\n\twritew(0x0, NFC_V21_UNLOCKSTART_BLKADDR1);\n\twritew(0x0, NFC_V21_UNLOCKSTART_BLKADDR2);\n\twritew(0x0, NFC_V21_UNLOCKSTART_BLKADDR3);\n\twritew(0xffff, NFC_V21_UNLOCKEND_BLKADDR0);\n\twritew(0xffff, NFC_V21_UNLOCKEND_BLKADDR1);\n\twritew(0xffff, NFC_V21_UNLOCKEND_BLKADDR2);\n\twritew(0xffff, NFC_V21_UNLOCKEND_BLKADDR3);\n\n\t \n\twritew(0x4, NFC_V1_V2_WRPROT);\n}\n\nstatic void preset_v3(struct mtd_info *mtd)\n{\n\tstruct nand_chip *chip = mtd_to_nand(mtd);\n\tstruct mxc_nand_host *host = nand_get_controller_data(chip);\n\tuint32_t config2, config3;\n\tint i, addr_phases;\n\n\twritel(NFC_V3_CONFIG1_RBA(0), NFC_V3_CONFIG1);\n\twritel(NFC_V3_IPC_CREQ, NFC_V3_IPC);\n\n\t \n\twritel(NFC_V3_WRPROT_BLS_UNLOCK | NFC_V3_WRPROT_UNLOCK,\n\t\t\tNFC_V3_WRPROT);\n\n\t \n\tfor (i = 0; i < NAND_MAX_CHIPS; i++)\n\t\twritel(0xffff << 16, NFC_V3_WRPROT_UNLOCK_BLK_ADD0 + (i << 2));\n\n\twritel(0, NFC_V3_IPC);\n\n\tconfig2 = NFC_V3_CONFIG2_ONE_CYCLE |\n\t\tNFC_V3_CONFIG2_2CMD_PHASES |\n\t\tNFC_V3_CONFIG2_SPAS(mtd->oobsize >> 1) |\n\t\tNFC_V3_CONFIG2_ST_CMD(0x70) |\n\t\tNFC_V3_CONFIG2_INT_MSK |\n\t\tNFC_V3_CONFIG2_NUM_ADDR_PHASE0;\n\n\taddr_phases = fls(chip->pagemask) >> 3;\n\n\tif (mtd->writesize == 2048) {\n\t\tconfig2 |= NFC_V3_CONFIG2_PS_2048;\n\t\tconfig2 |= NFC_V3_CONFIG2_NUM_ADDR_PHASE1(addr_phases);\n\t} else if (mtd->writesize == 4096) {\n\t\tconfig2 |= NFC_V3_CONFIG2_PS_4096;\n\t\tconfig2 |= NFC_V3_CONFIG2_NUM_ADDR_PHASE1(addr_phases);\n\t} else {\n\t\tconfig2 |= NFC_V3_CONFIG2_PS_512;\n\t\tconfig2 |= NFC_V3_CONFIG2_NUM_ADDR_PHASE1(addr_phases - 1);\n\t}\n\n\tif (mtd->writesize) {\n\t\tif (chip->ecc.engine_type == NAND_ECC_ENGINE_TYPE_ON_HOST)\n\t\t\tconfig2 |= NFC_V3_CONFIG2_ECC_EN;\n\n\t\tconfig2 |= NFC_V3_CONFIG2_PPB(\n\t\t\t\tffs(mtd->erasesize / mtd->writesize) - 6,\n\t\t\t\thost->devtype_data->ppb_shift);\n\t\thost->eccsize = get_eccsize(mtd);\n\t\tif (host->eccsize == 8)\n\t\t\tconfig2 |= NFC_V3_CONFIG2_ECC_MODE_8;\n\t}\n\n\twritel(config2, NFC_V3_CONFIG2);\n\n\tconfig3 = NFC_V3_CONFIG3_NUM_OF_DEVICES(0) |\n\t\t\tNFC_V3_CONFIG3_NO_SDMA |\n\t\t\tNFC_V3_CONFIG3_RBB_MODE |\n\t\t\tNFC_V3_CONFIG3_SBB(6) |  \n\t\t\tNFC_V3_CONFIG3_ADD_OP(0);\n\n\tif (!(chip->options & NAND_BUSWIDTH_16))\n\t\tconfig3 |= NFC_V3_CONFIG3_FW8;\n\n\twritel(config3, NFC_V3_CONFIG3);\n\n\twritel(0, NFC_V3_DELAY_LINE);\n}\n\n \nstatic void mxc_nand_command(struct nand_chip *nand_chip, unsigned command,\n\t\t\t     int column, int page_addr)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(nand_chip);\n\tstruct mxc_nand_host *host = nand_get_controller_data(nand_chip);\n\n\tdev_dbg(host->dev, \"mxc_nand_command (cmd = 0x%x, col = 0x%x, page = 0x%x)\\n\",\n\t      command, column, page_addr);\n\n\t \n\thost->status_request = false;\n\n\t \n\tswitch (command) {\n\tcase NAND_CMD_RESET:\n\t\thost->devtype_data->preset(mtd);\n\t\thost->devtype_data->send_cmd(host, command, false);\n\t\tbreak;\n\n\tcase NAND_CMD_STATUS:\n\t\thost->buf_start = 0;\n\t\thost->status_request = true;\n\n\t\thost->devtype_data->send_cmd(host, command, true);\n\t\tWARN_ONCE(column != -1 || page_addr != -1,\n\t\t\t  \"Unexpected column/row value (cmd=%u, col=%d, row=%d)\\n\",\n\t\t\t  command, column, page_addr);\n\t\tmxc_do_addr_cycle(mtd, column, page_addr);\n\t\tbreak;\n\n\tcase NAND_CMD_READID:\n\t\thost->devtype_data->send_cmd(host, command, true);\n\t\tmxc_do_addr_cycle(mtd, column, page_addr);\n\t\thost->devtype_data->send_read_id(host);\n\t\thost->buf_start = 0;\n\t\tbreak;\n\n\tcase NAND_CMD_ERASE1:\n\tcase NAND_CMD_ERASE2:\n\t\thost->devtype_data->send_cmd(host, command, false);\n\t\tWARN_ONCE(column != -1,\n\t\t\t  \"Unexpected column value (cmd=%u, col=%d)\\n\",\n\t\t\t  command, column);\n\t\tmxc_do_addr_cycle(mtd, column, page_addr);\n\n\t\tbreak;\n\tcase NAND_CMD_PARAM:\n\t\thost->devtype_data->send_cmd(host, command, false);\n\t\tmxc_do_addr_cycle(mtd, column, page_addr);\n\t\thost->devtype_data->send_page(mtd, NFC_OUTPUT);\n\t\tmemcpy32_fromio(host->data_buf, host->main_area0, 512);\n\t\thost->buf_start = 0;\n\t\tbreak;\n\tdefault:\n\t\tWARN_ONCE(1, \"Unimplemented command (cmd=%u)\\n\",\n\t\t\t  command);\n\t\tbreak;\n\t}\n}\n\nstatic int mxc_nand_set_features(struct nand_chip *chip, int addr,\n\t\t\t\t u8 *subfeature_param)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tstruct mxc_nand_host *host = nand_get_controller_data(chip);\n\tint i;\n\n\thost->buf_start = 0;\n\n\tfor (i = 0; i < ONFI_SUBFEATURE_PARAM_LEN; ++i)\n\t\tchip->legacy.write_byte(chip, subfeature_param[i]);\n\n\tmemcpy32_toio(host->main_area0, host->data_buf, mtd->writesize);\n\thost->devtype_data->send_cmd(host, NAND_CMD_SET_FEATURES, false);\n\tmxc_do_addr_cycle(mtd, addr, -1);\n\thost->devtype_data->send_page(mtd, NFC_INPUT);\n\n\treturn 0;\n}\n\nstatic int mxc_nand_get_features(struct nand_chip *chip, int addr,\n\t\t\t\t u8 *subfeature_param)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tstruct mxc_nand_host *host = nand_get_controller_data(chip);\n\tint i;\n\n\thost->devtype_data->send_cmd(host, NAND_CMD_GET_FEATURES, false);\n\tmxc_do_addr_cycle(mtd, addr, -1);\n\thost->devtype_data->send_page(mtd, NFC_OUTPUT);\n\tmemcpy32_fromio(host->data_buf, host->main_area0, 512);\n\thost->buf_start = 0;\n\n\tfor (i = 0; i < ONFI_SUBFEATURE_PARAM_LEN; ++i)\n\t\t*subfeature_param++ = chip->legacy.read_byte(chip);\n\n\treturn 0;\n}\n\n \nstatic uint8_t bbt_pattern[] = { 'B', 'b', 't', '0' };\nstatic uint8_t mirror_pattern[] = { '1', 't', 'b', 'B' };\n\nstatic struct nand_bbt_descr bbt_main_descr = {\n\t.options = NAND_BBT_LASTBLOCK | NAND_BBT_CREATE | NAND_BBT_WRITE\n\t    | NAND_BBT_2BIT | NAND_BBT_VERSION | NAND_BBT_PERCHIP,\n\t.offs = 0,\n\t.len = 4,\n\t.veroffs = 4,\n\t.maxblocks = 4,\n\t.pattern = bbt_pattern,\n};\n\nstatic struct nand_bbt_descr bbt_mirror_descr = {\n\t.options = NAND_BBT_LASTBLOCK | NAND_BBT_CREATE | NAND_BBT_WRITE\n\t    | NAND_BBT_2BIT | NAND_BBT_VERSION | NAND_BBT_PERCHIP,\n\t.offs = 0,\n\t.len = 4,\n\t.veroffs = 4,\n\t.maxblocks = 4,\n\t.pattern = mirror_pattern,\n};\n\n \nstatic const struct mxc_nand_devtype_data imx21_nand_devtype_data = {\n\t.preset = preset_v1,\n\t.read_page = mxc_nand_read_page_v1,\n\t.send_cmd = send_cmd_v1_v2,\n\t.send_addr = send_addr_v1_v2,\n\t.send_page = send_page_v1,\n\t.send_read_id = send_read_id_v1_v2,\n\t.get_dev_status = get_dev_status_v1_v2,\n\t.check_int = check_int_v1_v2,\n\t.irq_control = irq_control_v1_v2,\n\t.get_ecc_status = get_ecc_status_v1,\n\t.ooblayout = &mxc_v1_ooblayout_ops,\n\t.select_chip = mxc_nand_select_chip_v1_v3,\n\t.enable_hwecc = mxc_nand_enable_hwecc_v1_v2,\n\t.irqpending_quirk = 1,\n\t.needs_ip = 0,\n\t.regs_offset = 0xe00,\n\t.spare0_offset = 0x800,\n\t.spare_len = 16,\n\t.eccbytes = 3,\n\t.eccsize = 1,\n};\n\n \nstatic const struct mxc_nand_devtype_data imx27_nand_devtype_data = {\n\t.preset = preset_v1,\n\t.read_page = mxc_nand_read_page_v1,\n\t.send_cmd = send_cmd_v1_v2,\n\t.send_addr = send_addr_v1_v2,\n\t.send_page = send_page_v1,\n\t.send_read_id = send_read_id_v1_v2,\n\t.get_dev_status = get_dev_status_v1_v2,\n\t.check_int = check_int_v1_v2,\n\t.irq_control = irq_control_v1_v2,\n\t.get_ecc_status = get_ecc_status_v1,\n\t.ooblayout = &mxc_v1_ooblayout_ops,\n\t.select_chip = mxc_nand_select_chip_v1_v3,\n\t.enable_hwecc = mxc_nand_enable_hwecc_v1_v2,\n\t.irqpending_quirk = 0,\n\t.needs_ip = 0,\n\t.regs_offset = 0xe00,\n\t.spare0_offset = 0x800,\n\t.axi_offset = 0,\n\t.spare_len = 16,\n\t.eccbytes = 3,\n\t.eccsize = 1,\n};\n\n \nstatic const struct mxc_nand_devtype_data imx25_nand_devtype_data = {\n\t.preset = preset_v2,\n\t.read_page = mxc_nand_read_page_v2_v3,\n\t.send_cmd = send_cmd_v1_v2,\n\t.send_addr = send_addr_v1_v2,\n\t.send_page = send_page_v2,\n\t.send_read_id = send_read_id_v1_v2,\n\t.get_dev_status = get_dev_status_v1_v2,\n\t.check_int = check_int_v1_v2,\n\t.irq_control = irq_control_v1_v2,\n\t.get_ecc_status = get_ecc_status_v2,\n\t.ooblayout = &mxc_v2_ooblayout_ops,\n\t.select_chip = mxc_nand_select_chip_v2,\n\t.setup_interface = mxc_nand_v2_setup_interface,\n\t.enable_hwecc = mxc_nand_enable_hwecc_v1_v2,\n\t.irqpending_quirk = 0,\n\t.needs_ip = 0,\n\t.regs_offset = 0x1e00,\n\t.spare0_offset = 0x1000,\n\t.axi_offset = 0,\n\t.spare_len = 64,\n\t.eccbytes = 9,\n\t.eccsize = 0,\n};\n\n \nstatic const struct mxc_nand_devtype_data imx51_nand_devtype_data = {\n\t.preset = preset_v3,\n\t.read_page = mxc_nand_read_page_v2_v3,\n\t.send_cmd = send_cmd_v3,\n\t.send_addr = send_addr_v3,\n\t.send_page = send_page_v3,\n\t.send_read_id = send_read_id_v3,\n\t.get_dev_status = get_dev_status_v3,\n\t.check_int = check_int_v3,\n\t.irq_control = irq_control_v3,\n\t.get_ecc_status = get_ecc_status_v3,\n\t.ooblayout = &mxc_v2_ooblayout_ops,\n\t.select_chip = mxc_nand_select_chip_v1_v3,\n\t.enable_hwecc = mxc_nand_enable_hwecc_v3,\n\t.irqpending_quirk = 0,\n\t.needs_ip = 1,\n\t.regs_offset = 0,\n\t.spare0_offset = 0x1000,\n\t.axi_offset = 0x1e00,\n\t.spare_len = 64,\n\t.eccbytes = 0,\n\t.eccsize = 0,\n\t.ppb_shift = 7,\n};\n\n \nstatic const struct mxc_nand_devtype_data imx53_nand_devtype_data = {\n\t.preset = preset_v3,\n\t.read_page = mxc_nand_read_page_v2_v3,\n\t.send_cmd = send_cmd_v3,\n\t.send_addr = send_addr_v3,\n\t.send_page = send_page_v3,\n\t.send_read_id = send_read_id_v3,\n\t.get_dev_status = get_dev_status_v3,\n\t.check_int = check_int_v3,\n\t.irq_control = irq_control_v3,\n\t.get_ecc_status = get_ecc_status_v3,\n\t.ooblayout = &mxc_v2_ooblayout_ops,\n\t.select_chip = mxc_nand_select_chip_v1_v3,\n\t.enable_hwecc = mxc_nand_enable_hwecc_v3,\n\t.irqpending_quirk = 0,\n\t.needs_ip = 1,\n\t.regs_offset = 0,\n\t.spare0_offset = 0x1000,\n\t.axi_offset = 0x1e00,\n\t.spare_len = 64,\n\t.eccbytes = 0,\n\t.eccsize = 0,\n\t.ppb_shift = 8,\n};\n\nstatic inline int is_imx21_nfc(struct mxc_nand_host *host)\n{\n\treturn host->devtype_data == &imx21_nand_devtype_data;\n}\n\nstatic inline int is_imx27_nfc(struct mxc_nand_host *host)\n{\n\treturn host->devtype_data == &imx27_nand_devtype_data;\n}\n\nstatic inline int is_imx25_nfc(struct mxc_nand_host *host)\n{\n\treturn host->devtype_data == &imx25_nand_devtype_data;\n}\n\nstatic const struct of_device_id mxcnd_dt_ids[] = {\n\t{ .compatible = \"fsl,imx21-nand\", .data = &imx21_nand_devtype_data, },\n\t{ .compatible = \"fsl,imx27-nand\", .data = &imx27_nand_devtype_data, },\n\t{ .compatible = \"fsl,imx25-nand\", .data = &imx25_nand_devtype_data, },\n\t{ .compatible = \"fsl,imx51-nand\", .data = &imx51_nand_devtype_data, },\n\t{ .compatible = \"fsl,imx53-nand\", .data = &imx53_nand_devtype_data, },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, mxcnd_dt_ids);\n\nstatic int mxcnd_attach_chip(struct nand_chip *chip)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tstruct mxc_nand_host *host = nand_get_controller_data(chip);\n\tstruct device *dev = mtd->dev.parent;\n\n\tchip->ecc.bytes = host->devtype_data->eccbytes;\n\thost->eccsize = host->devtype_data->eccsize;\n\tchip->ecc.size = 512;\n\tmtd_set_ooblayout(mtd, host->devtype_data->ooblayout);\n\n\tswitch (chip->ecc.engine_type) {\n\tcase NAND_ECC_ENGINE_TYPE_ON_HOST:\n\t\tchip->ecc.read_page = mxc_nand_read_page;\n\t\tchip->ecc.read_page_raw = mxc_nand_read_page_raw;\n\t\tchip->ecc.read_oob = mxc_nand_read_oob;\n\t\tchip->ecc.write_page = mxc_nand_write_page_ecc;\n\t\tchip->ecc.write_page_raw = mxc_nand_write_page_raw;\n\t\tchip->ecc.write_oob = mxc_nand_write_oob;\n\t\tbreak;\n\n\tcase NAND_ECC_ENGINE_TYPE_SOFT:\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (chip->bbt_options & NAND_BBT_USE_FLASH) {\n\t\tchip->bbt_td = &bbt_main_descr;\n\t\tchip->bbt_md = &bbt_mirror_descr;\n\t}\n\n\t \n\tdevm_kfree(dev, (void *)host->data_buf);\n\thost->data_buf = devm_kzalloc(dev, mtd->writesize + mtd->oobsize,\n\t\t\t\t      GFP_KERNEL);\n\tif (!host->data_buf)\n\t\treturn -ENOMEM;\n\n\t \n\thost->devtype_data->preset(mtd);\n\n\tif (!chip->ecc.bytes) {\n\t\tif (host->eccsize == 8)\n\t\t\tchip->ecc.bytes = 18;\n\t\telse if (host->eccsize == 4)\n\t\t\tchip->ecc.bytes = 9;\n\t}\n\n\t \n\thost->used_oobsize = min(mtd->oobsize, 218U);\n\n\tif (chip->ecc.engine_type == NAND_ECC_ENGINE_TYPE_ON_HOST) {\n\t\tif (is_imx21_nfc(host) || is_imx27_nfc(host))\n\t\t\tchip->ecc.strength = 1;\n\t\telse\n\t\t\tchip->ecc.strength = (host->eccsize == 4) ? 4 : 8;\n\t}\n\n\treturn 0;\n}\n\nstatic int mxcnd_setup_interface(struct nand_chip *chip, int chipnr,\n\t\t\t\t const struct nand_interface_config *conf)\n{\n\tstruct mxc_nand_host *host = nand_get_controller_data(chip);\n\n\treturn host->devtype_data->setup_interface(chip, chipnr, conf);\n}\n\nstatic const struct nand_controller_ops mxcnd_controller_ops = {\n\t.attach_chip = mxcnd_attach_chip,\n\t.setup_interface = mxcnd_setup_interface,\n};\n\nstatic int mxcnd_probe(struct platform_device *pdev)\n{\n\tstruct nand_chip *this;\n\tstruct mtd_info *mtd;\n\tstruct mxc_nand_host *host;\n\tint err = 0;\n\n\t \n\thost = devm_kzalloc(&pdev->dev, sizeof(struct mxc_nand_host),\n\t\t\tGFP_KERNEL);\n\tif (!host)\n\t\treturn -ENOMEM;\n\n\t \n\thost->data_buf = devm_kzalloc(&pdev->dev, PAGE_SIZE, GFP_KERNEL);\n\tif (!host->data_buf)\n\t\treturn -ENOMEM;\n\n\thost->dev = &pdev->dev;\n\t \n\tthis = &host->nand;\n\tmtd = nand_to_mtd(this);\n\tmtd->dev.parent = &pdev->dev;\n\tmtd->name = DRIVER_NAME;\n\n\t \n\tthis->legacy.chip_delay = 5;\n\n\tnand_set_controller_data(this, host);\n\tnand_set_flash_node(this, pdev->dev.of_node);\n\tthis->legacy.dev_ready = mxc_nand_dev_ready;\n\tthis->legacy.cmdfunc = mxc_nand_command;\n\tthis->legacy.read_byte = mxc_nand_read_byte;\n\tthis->legacy.write_buf = mxc_nand_write_buf;\n\tthis->legacy.read_buf = mxc_nand_read_buf;\n\tthis->legacy.set_features = mxc_nand_set_features;\n\tthis->legacy.get_features = mxc_nand_get_features;\n\n\thost->clk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(host->clk))\n\t\treturn PTR_ERR(host->clk);\n\n\thost->devtype_data = device_get_match_data(&pdev->dev);\n\n\tif (!host->devtype_data->setup_interface)\n\t\tthis->options |= NAND_KEEP_TIMINGS;\n\n\tif (host->devtype_data->needs_ip) {\n\t\thost->regs_ip = devm_platform_ioremap_resource(pdev, 0);\n\t\tif (IS_ERR(host->regs_ip))\n\t\t\treturn PTR_ERR(host->regs_ip);\n\n\t\thost->base = devm_platform_ioremap_resource(pdev, 1);\n\t} else {\n\t\thost->base = devm_platform_ioremap_resource(pdev, 0);\n\t}\n\n\tif (IS_ERR(host->base))\n\t\treturn PTR_ERR(host->base);\n\n\thost->main_area0 = host->base;\n\n\tif (host->devtype_data->regs_offset)\n\t\thost->regs = host->base + host->devtype_data->regs_offset;\n\thost->spare0 = host->base + host->devtype_data->spare0_offset;\n\tif (host->devtype_data->axi_offset)\n\t\thost->regs_axi = host->base + host->devtype_data->axi_offset;\n\n\tthis->legacy.select_chip = host->devtype_data->select_chip;\n\n\tinit_completion(&host->op_completion);\n\n\thost->irq = platform_get_irq(pdev, 0);\n\tif (host->irq < 0)\n\t\treturn host->irq;\n\n\t \n\thost->devtype_data->irq_control(host, 0);\n\n\terr = devm_request_irq(&pdev->dev, host->irq, mxc_nfc_irq,\n\t\t\t0, DRIVER_NAME, host);\n\tif (err)\n\t\treturn err;\n\n\terr = clk_prepare_enable(host->clk);\n\tif (err)\n\t\treturn err;\n\thost->clk_act = 1;\n\n\t \n\tif (host->devtype_data->irqpending_quirk) {\n\t\tdisable_irq_nosync(host->irq);\n\t\thost->devtype_data->irq_control(host, 1);\n\t}\n\n\t \n\tthis->legacy.dummy_controller.ops = &mxcnd_controller_ops;\n\terr = nand_scan(this, is_imx25_nfc(host) ? 4 : 1);\n\tif (err)\n\t\tgoto escan;\n\n\t \n\terr = mtd_device_parse_register(mtd, part_probes, NULL, NULL, 0);\n\tif (err)\n\t\tgoto cleanup_nand;\n\n\tplatform_set_drvdata(pdev, host);\n\n\treturn 0;\n\ncleanup_nand:\n\tnand_cleanup(this);\nescan:\n\tif (host->clk_act)\n\t\tclk_disable_unprepare(host->clk);\n\n\treturn err;\n}\n\nstatic void mxcnd_remove(struct platform_device *pdev)\n{\n\tstruct mxc_nand_host *host = platform_get_drvdata(pdev);\n\tstruct nand_chip *chip = &host->nand;\n\tint ret;\n\n\tret = mtd_device_unregister(nand_to_mtd(chip));\n\tWARN_ON(ret);\n\tnand_cleanup(chip);\n\tif (host->clk_act)\n\t\tclk_disable_unprepare(host->clk);\n}\n\nstatic struct platform_driver mxcnd_driver = {\n\t.driver = {\n\t\t   .name = DRIVER_NAME,\n\t\t   .of_match_table = mxcnd_dt_ids,\n\t},\n\t.probe = mxcnd_probe,\n\t.remove_new = mxcnd_remove,\n};\nmodule_platform_driver(mxcnd_driver);\n\nMODULE_AUTHOR(\"Freescale Semiconductor, Inc.\");\nMODULE_DESCRIPTION(\"MXC NAND MTD driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}