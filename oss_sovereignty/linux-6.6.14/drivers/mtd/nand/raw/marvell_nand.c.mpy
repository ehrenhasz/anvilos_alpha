{
  "module_name": "marvell_nand.c",
  "hash_id": "ddc26e5b956c1e8937e37962c491b89bb7db739cf3ad7c842808526461645fe8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/nand/raw/marvell_nand.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/clk.h>\n#include <linux/mtd/rawnand.h>\n#include <linux/of.h>\n#include <linux/iopoll.h>\n#include <linux/interrupt.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/mfd/syscon.h>\n#include <linux/regmap.h>\n#include <asm/unaligned.h>\n\n#include <linux/dmaengine.h>\n#include <linux/dma-mapping.h>\n#include <linux/dma/pxa-dma.h>\n#include <linux/platform_data/mtd-nand-pxa3xx.h>\n\n \n#define FIFO_DEPTH\t\t8\n#define FIFO_REP(x)\t\t(x / sizeof(u32))\n#define BCH_SEQ_READS\t\t(32 / FIFO_DEPTH)\n \n#define MAX_CHUNK_SIZE\t\t2112\n \n#define NFCV1_READID_LEN\t7\n \n#define POLL_PERIOD\t\t0\n#define POLL_TIMEOUT\t\t100000\n \n#define IRQ_TIMEOUT\t\t1000\n \n#define MIN_RD_DEL_CNT\t\t3\n \n#define MAX_ADDRESS_CYC_NFCV1\t5\n#define MAX_ADDRESS_CYC_NFCV2\t7\n \n#define GENCONF_SOC_DEVICE_MUX\t0x208\n#define GENCONF_SOC_DEVICE_MUX_NFC_EN BIT(0)\n#define GENCONF_SOC_DEVICE_MUX_ECC_CLK_RST BIT(20)\n#define GENCONF_SOC_DEVICE_MUX_ECC_CORE_RST BIT(21)\n#define GENCONF_SOC_DEVICE_MUX_NFC_INT_EN BIT(25)\n#define GENCONF_SOC_DEVICE_MUX_NFC_DEVBUS_ARB_EN BIT(27)\n#define GENCONF_CLK_GATING_CTRL\t0x220\n#define GENCONF_CLK_GATING_CTRL_ND_GATE BIT(2)\n#define GENCONF_ND_CLK_CTRL\t0x700\n#define GENCONF_ND_CLK_CTRL_EN\tBIT(0)\n\n \n#define NDCR\t\t\t0x00\n#define NDCR_ALL_INT\t\tGENMASK(11, 0)\n#define NDCR_CS1_CMDDM\t\tBIT(7)\n#define NDCR_CS0_CMDDM\t\tBIT(8)\n#define NDCR_RDYM\t\tBIT(11)\n#define NDCR_ND_ARB_EN\t\tBIT(12)\n#define NDCR_RA_START\t\tBIT(15)\n#define NDCR_RD_ID_CNT(x)\t(min_t(unsigned int, x, 0x7) << 16)\n#define NDCR_PAGE_SZ(x)\t\t(x >= 2048 ? BIT(24) : 0)\n#define NDCR_DWIDTH_M\t\tBIT(26)\n#define NDCR_DWIDTH_C\t\tBIT(27)\n#define NDCR_ND_RUN\t\tBIT(28)\n#define NDCR_DMA_EN\t\tBIT(29)\n#define NDCR_ECC_EN\t\tBIT(30)\n#define NDCR_SPARE_EN\t\tBIT(31)\n#define NDCR_GENERIC_FIELDS_MASK (~(NDCR_RA_START | NDCR_PAGE_SZ(2048) | \\\n\t\t\t\t    NDCR_DWIDTH_M | NDCR_DWIDTH_C))\n\n \n#define NDTR0\t\t\t0x04\n#define NDTR0_TRP(x)\t\t((min_t(unsigned int, x, 0xF) & 0x7) << 0)\n#define NDTR0_TRH(x)\t\t(min_t(unsigned int, x, 0x7) << 3)\n#define NDTR0_ETRP(x)\t\t((min_t(unsigned int, x, 0xF) & 0x8) << 3)\n#define NDTR0_SEL_NRE_EDGE\tBIT(7)\n#define NDTR0_TWP(x)\t\t(min_t(unsigned int, x, 0x7) << 8)\n#define NDTR0_TWH(x)\t\t(min_t(unsigned int, x, 0x7) << 11)\n#define NDTR0_TCS(x)\t\t(min_t(unsigned int, x, 0x7) << 16)\n#define NDTR0_TCH(x)\t\t(min_t(unsigned int, x, 0x7) << 19)\n#define NDTR0_RD_CNT_DEL(x)\t(min_t(unsigned int, x, 0xF) << 22)\n#define NDTR0_SELCNTR\t\tBIT(26)\n#define NDTR0_TADL(x)\t\t(min_t(unsigned int, x, 0x1F) << 27)\n\n \n#define NDTR1\t\t\t0x0C\n#define NDTR1_TAR(x)\t\t(min_t(unsigned int, x, 0xF) << 0)\n#define NDTR1_TWHR(x)\t\t(min_t(unsigned int, x, 0xF) << 4)\n#define NDTR1_TRHW(x)\t\t(min_t(unsigned int, x / 16, 0x3) << 8)\n#define NDTR1_PRESCALE\t\tBIT(14)\n#define NDTR1_WAIT_MODE\t\tBIT(15)\n#define NDTR1_TR(x)\t\t(min_t(unsigned int, x, 0xFFFF) << 16)\n\n \n#define NDSR\t\t\t0x14\n#define NDSR_WRCMDREQ\t\tBIT(0)\n#define NDSR_RDDREQ\t\tBIT(1)\n#define NDSR_WRDREQ\t\tBIT(2)\n#define NDSR_CORERR\t\tBIT(3)\n#define NDSR_UNCERR\t\tBIT(4)\n#define NDSR_CMDD(cs)\t\tBIT(8 - cs)\n#define NDSR_RDY(rb)\t\tBIT(11 + rb)\n#define NDSR_ERRCNT(x)\t\t((x >> 16) & 0x1F)\n\n \n#define NDECCCTRL\t\t0x28\n#define NDECCCTRL_BCH_EN\tBIT(0)\n\n \n#define NDDB\t\t\t0x40\n\n \n#define NDCB0\t\t\t0x48\n#define NDCB0_CMD1(x)\t\t((x & 0xFF) << 0)\n#define NDCB0_CMD2(x)\t\t((x & 0xFF) << 8)\n#define NDCB0_ADDR_CYC(x)\t((x & 0x7) << 16)\n#define NDCB0_ADDR_GET_NUM_CYC(x) (((x) >> 16) & 0x7)\n#define NDCB0_DBC\t\tBIT(19)\n#define NDCB0_CMD_TYPE(x)\t((x & 0x7) << 21)\n#define NDCB0_CSEL\t\tBIT(24)\n#define NDCB0_RDY_BYP\t\tBIT(27)\n#define NDCB0_LEN_OVRD\t\tBIT(28)\n#define NDCB0_CMD_XTYPE(x)\t((x & 0x7) << 29)\n\n \n#define NDCB1\t\t\t0x4C\n#define NDCB1_COLS(x)\t\t((x & 0xFFFF) << 0)\n#define NDCB1_ADDRS_PAGE(x)\t(x << 16)\n\n \n#define NDCB2\t\t\t0x50\n#define NDCB2_ADDR5_PAGE(x)\t(((x >> 16) & 0xFF) << 0)\n#define NDCB2_ADDR5_CYC(x)\t((x & 0xFF) << 0)\n\n \n#define NDCB3\t\t\t0x54\n#define NDCB3_ADDR6_CYC(x)\t((x & 0xFF) << 16)\n#define NDCB3_ADDR7_CYC(x)\t((x & 0xFF) << 24)\n\n \n#define TYPE_READ\t\t0\n#define TYPE_WRITE\t\t1\n#define TYPE_ERASE\t\t2\n#define TYPE_READ_ID\t\t3\n#define TYPE_STATUS\t\t4\n#define TYPE_RESET\t\t5\n#define TYPE_NAKED_CMD\t\t6\n#define TYPE_NAKED_ADDR\t\t7\n#define TYPE_MASK\t\t7\n#define XTYPE_MONOLITHIC_RW\t0\n#define XTYPE_LAST_NAKED_RW\t1\n#define XTYPE_FINAL_COMMAND\t3\n#define XTYPE_READ\t\t4\n#define XTYPE_WRITE_DISPATCH\t4\n#define XTYPE_NAKED_RW\t\t5\n#define XTYPE_COMMAND_DISPATCH\t6\n#define XTYPE_MASK\t\t7\n\n \nstruct marvell_hw_ecc_layout {\n\t \n\tint writesize;\n\tint chunk;\n\tint strength;\n\t \n\tint nchunks;\n\tint full_chunk_cnt;\n\tint data_bytes;\n\tint spare_bytes;\n\tint ecc_bytes;\n\tint last_data_bytes;\n\tint last_spare_bytes;\n\tint last_ecc_bytes;\n};\n\n#define MARVELL_LAYOUT(ws, dc, ds, nc, fcc, db, sb, eb, ldb, lsb, leb)\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\t.writesize = ws,\t\t\t\t\t\\\n\t\t.chunk = dc,\t\t\t\t\t\t\\\n\t\t.strength = ds,\t\t\t\t\t\t\\\n\t\t.nchunks = nc,\t\t\t\t\t\t\\\n\t\t.full_chunk_cnt = fcc,\t\t\t\t\t\\\n\t\t.data_bytes = db,\t\t\t\t\t\\\n\t\t.spare_bytes = sb,\t\t\t\t\t\\\n\t\t.ecc_bytes = eb,\t\t\t\t\t\\\n\t\t.last_data_bytes = ldb,\t\t\t\t\t\\\n\t\t.last_spare_bytes = lsb,\t\t\t\t\\\n\t\t.last_ecc_bytes = leb,\t\t\t\t\t\\\n\t}\n\n \nstatic const struct marvell_hw_ecc_layout marvell_nfc_layouts[] = {\n\tMARVELL_LAYOUT(  512,   512,  1,  1,  1,  512,  8,  8,  0,  0,  0),\n\tMARVELL_LAYOUT( 2048,   512,  1,  1,  1, 2048, 40, 24,  0,  0,  0),\n\tMARVELL_LAYOUT( 2048,   512,  4,  1,  1, 2048, 32, 30,  0,  0,  0),\n\tMARVELL_LAYOUT( 2048,   512,  8,  2,  1, 1024,  0, 30,1024,32, 30),\n\tMARVELL_LAYOUT( 2048,   512,  8,  2,  1, 1024,  0, 30,1024,64, 30),\n\tMARVELL_LAYOUT( 2048,   512,  12, 3,  2, 704,   0, 30,640,  0, 30),\n\tMARVELL_LAYOUT( 2048,   512,  16, 5,  4, 512,   0, 30,  0, 32, 30),\n\tMARVELL_LAYOUT( 4096,   512,  4,  2,  2, 2048, 32, 30,  0,  0,  0),\n\tMARVELL_LAYOUT( 4096,   512,  8,  5,  4, 1024,  0, 30,  0, 64, 30),\n\tMARVELL_LAYOUT( 4096,   512,  12, 6,  5, 704,   0, 30,576, 32, 30),\n\tMARVELL_LAYOUT( 4096,   512,  16, 9,  8, 512,   0, 30,  0, 32, 30),\n\tMARVELL_LAYOUT( 8192,   512,  4,  4,  4, 2048,  0, 30,  0,  0,  0),\n\tMARVELL_LAYOUT( 8192,   512,  8,  9,  8, 1024,  0, 30,  0, 160, 30),\n\tMARVELL_LAYOUT( 8192,   512,  12, 12, 11, 704,  0, 30,448,  64, 30),\n\tMARVELL_LAYOUT( 8192,   512,  16, 17, 16, 512,  0, 30,  0,  32, 30),\n};\n\n \nstruct marvell_nand_chip_sel {\n\tunsigned int cs;\n\tu32 ndcb0_csel;\n\tunsigned int rb;\n};\n\n \nstruct marvell_nand_chip {\n\tstruct nand_chip chip;\n\tstruct list_head node;\n\tconst struct marvell_hw_ecc_layout *layout;\n\tu32 ndcr;\n\tu32 ndtr0;\n\tu32 ndtr1;\n\tint addr_cyc;\n\tint selected_die;\n\tunsigned int nsels;\n\tstruct marvell_nand_chip_sel sels[];\n};\n\nstatic inline struct marvell_nand_chip *to_marvell_nand(struct nand_chip *chip)\n{\n\treturn container_of(chip, struct marvell_nand_chip, chip);\n}\n\nstatic inline struct marvell_nand_chip_sel *to_nand_sel(struct marvell_nand_chip\n\t\t\t\t\t\t\t*nand)\n{\n\treturn &nand->sels[nand->selected_die];\n}\n\n \nstruct marvell_nfc_caps {\n\tunsigned int max_cs_nb;\n\tunsigned int max_rb_nb;\n\tbool need_system_controller;\n\tbool legacy_of_bindings;\n\tbool is_nfcv2;\n\tbool use_dma;\n\tunsigned int max_mode_number;\n};\n\n \nstruct marvell_nfc {\n\tstruct nand_controller controller;\n\tstruct device *dev;\n\tvoid __iomem *regs;\n\tstruct clk *core_clk;\n\tstruct clk *reg_clk;\n\tstruct completion complete;\n\tunsigned long assigned_cs;\n\tstruct list_head chips;\n\tstruct nand_chip *selected_chip;\n\tconst struct marvell_nfc_caps *caps;\n\n\t \n\tbool use_dma;\n\tstruct dma_chan *dma_chan;\n\tu8 *dma_buf;\n};\n\nstatic inline struct marvell_nfc *to_marvell_nfc(struct nand_controller *ctrl)\n{\n\treturn container_of(ctrl, struct marvell_nfc, controller);\n}\n\n \nstruct marvell_nfc_timings {\n\t \n\tunsigned int tRP;\n\tunsigned int tRH;\n\tunsigned int tWP;\n\tunsigned int tWH;\n\tunsigned int tCS;\n\tunsigned int tCH;\n\tunsigned int tADL;\n\t \n\tunsigned int tAR;\n\tunsigned int tWHR;\n\tunsigned int tRHW;\n\tunsigned int tR;\n};\n\n \n#define TO_CYCLES(ps, period_ns) (DIV_ROUND_UP(ps / 1000, period_ns))\n#define TO_CYCLES64(ps, period_ns) (DIV_ROUND_UP_ULL(div_u64(ps, 1000), \\\n\t\t\t\t\t\t     period_ns))\n\n \nstruct marvell_nfc_op {\n\tu32 ndcb[4];\n\tunsigned int cle_ale_delay_ns;\n\tunsigned int rdy_timeout_ms;\n\tunsigned int rdy_delay_ns;\n\tunsigned int data_delay_ns;\n\tunsigned int data_instr_idx;\n\tconst struct nand_op_instr *data_instr;\n};\n\n \nstatic void cond_delay(unsigned int ns)\n{\n\tif (!ns)\n\t\treturn;\n\n\tif (ns < 10000)\n\t\tndelay(ns);\n\telse\n\t\tudelay(DIV_ROUND_UP(ns, 1000));\n}\n\n \nstatic void marvell_nfc_disable_int(struct marvell_nfc *nfc, u32 int_mask)\n{\n\tu32 reg;\n\n\t \n\treg = readl_relaxed(nfc->regs + NDCR);\n\twritel_relaxed(reg | int_mask, nfc->regs + NDCR);\n}\n\nstatic void marvell_nfc_enable_int(struct marvell_nfc *nfc, u32 int_mask)\n{\n\tu32 reg;\n\n\t \n\treg = readl_relaxed(nfc->regs + NDCR);\n\twritel_relaxed(reg & ~int_mask, nfc->regs + NDCR);\n}\n\nstatic u32 marvell_nfc_clear_int(struct marvell_nfc *nfc, u32 int_mask)\n{\n\tu32 reg;\n\n\treg = readl_relaxed(nfc->regs + NDSR);\n\twritel_relaxed(int_mask, nfc->regs + NDSR);\n\n\treturn reg & int_mask;\n}\n\nstatic void marvell_nfc_force_byte_access(struct nand_chip *chip,\n\t\t\t\t\t  bool force_8bit)\n{\n\tstruct marvell_nfc *nfc = to_marvell_nfc(chip->controller);\n\tu32 ndcr;\n\n\t \n\tif (!(chip->options & NAND_BUSWIDTH_16))\n\t\treturn;\n\n\tndcr = readl_relaxed(nfc->regs + NDCR);\n\n\tif (force_8bit)\n\t\tndcr &= ~(NDCR_DWIDTH_M | NDCR_DWIDTH_C);\n\telse\n\t\tndcr |= NDCR_DWIDTH_M | NDCR_DWIDTH_C;\n\n\twritel_relaxed(ndcr, nfc->regs + NDCR);\n}\n\nstatic int marvell_nfc_wait_ndrun(struct nand_chip *chip)\n{\n\tstruct marvell_nfc *nfc = to_marvell_nfc(chip->controller);\n\tu32 val;\n\tint ret;\n\n\t \n\tret = readl_relaxed_poll_timeout(nfc->regs + NDCR, val,\n\t\t\t\t\t (val & NDCR_ND_RUN) == 0,\n\t\t\t\t\t POLL_PERIOD, POLL_TIMEOUT);\n\tif (ret) {\n\t\tdev_err(nfc->dev, \"Timeout on NAND controller run mode\\n\");\n\t\twritel_relaxed(readl(nfc->regs + NDCR) & ~NDCR_ND_RUN,\n\t\t\t       nfc->regs + NDCR);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int marvell_nfc_prepare_cmd(struct nand_chip *chip)\n{\n\tstruct marvell_nfc *nfc = to_marvell_nfc(chip->controller);\n\tu32 ndcr, val;\n\tint ret;\n\n\t \n\tret = marvell_nfc_wait_ndrun(chip);\n\tif (ret) {\n\t\tdev_err(nfc->dev, \"Last operation did not succeed\\n\");\n\t\treturn ret;\n\t}\n\n\tndcr = readl_relaxed(nfc->regs + NDCR);\n\twritel_relaxed(readl(nfc->regs + NDSR), nfc->regs + NDSR);\n\n\t \n\twritel_relaxed(ndcr | NDCR_ND_RUN, nfc->regs + NDCR);\n\tret = readl_relaxed_poll_timeout(nfc->regs + NDSR, val,\n\t\t\t\t\t val & NDSR_WRCMDREQ,\n\t\t\t\t\t POLL_PERIOD, POLL_TIMEOUT);\n\tif (ret) {\n\t\tdev_err(nfc->dev, \"Timeout on WRCMDRE\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\t \n\twritel_relaxed(NDSR_WRCMDREQ, nfc->regs + NDSR);\n\n\treturn 0;\n}\n\nstatic void marvell_nfc_send_cmd(struct nand_chip *chip,\n\t\t\t\t struct marvell_nfc_op *nfc_op)\n{\n\tstruct marvell_nand_chip *marvell_nand = to_marvell_nand(chip);\n\tstruct marvell_nfc *nfc = to_marvell_nfc(chip->controller);\n\n\tdev_dbg(nfc->dev, \"\\nNDCR:  0x%08x\\n\"\n\t\t\"NDCB0: 0x%08x\\nNDCB1: 0x%08x\\nNDCB2: 0x%08x\\nNDCB3: 0x%08x\\n\",\n\t\t(u32)readl_relaxed(nfc->regs + NDCR), nfc_op->ndcb[0],\n\t\tnfc_op->ndcb[1], nfc_op->ndcb[2], nfc_op->ndcb[3]);\n\n\twritel_relaxed(to_nand_sel(marvell_nand)->ndcb0_csel | nfc_op->ndcb[0],\n\t\t       nfc->regs + NDCB0);\n\twritel_relaxed(nfc_op->ndcb[1], nfc->regs + NDCB0);\n\twritel(nfc_op->ndcb[2], nfc->regs + NDCB0);\n\n\t \n\tif (nfc_op->ndcb[0] & NDCB0_LEN_OVRD ||\n\t    NDCB0_ADDR_GET_NUM_CYC(nfc_op->ndcb[0]) >= 6) {\n\t\tif (!WARN_ON_ONCE(!nfc->caps->is_nfcv2))\n\t\t\twritel(nfc_op->ndcb[3], nfc->regs + NDCB0);\n\t}\n}\n\nstatic int marvell_nfc_end_cmd(struct nand_chip *chip, int flag,\n\t\t\t       const char *label)\n{\n\tstruct marvell_nfc *nfc = to_marvell_nfc(chip->controller);\n\tu32 val;\n\tint ret;\n\n\tret = readl_relaxed_poll_timeout(nfc->regs + NDSR, val,\n\t\t\t\t\t val & flag,\n\t\t\t\t\t POLL_PERIOD, POLL_TIMEOUT);\n\n\tif (ret) {\n\t\tdev_err(nfc->dev, \"Timeout on %s (NDSR: 0x%08x)\\n\",\n\t\t\tlabel, val);\n\t\tif (nfc->dma_chan)\n\t\t\tdmaengine_terminate_all(nfc->dma_chan);\n\t\treturn ret;\n\t}\n\n\t \n\tif (nfc->use_dma && (readl_relaxed(nfc->regs + NDCR) & NDCR_DMA_EN))\n\t\treturn 0;\n\n\twritel_relaxed(flag, nfc->regs + NDSR);\n\n\treturn 0;\n}\n\nstatic int marvell_nfc_wait_cmdd(struct nand_chip *chip)\n{\n\tstruct marvell_nand_chip *marvell_nand = to_marvell_nand(chip);\n\tint cs_flag = NDSR_CMDD(to_nand_sel(marvell_nand)->ndcb0_csel);\n\n\treturn marvell_nfc_end_cmd(chip, cs_flag, \"CMDD\");\n}\n\nstatic int marvell_nfc_poll_status(struct marvell_nfc *nfc, u32 mask,\n\t\t\t\t   u32 expected_val, unsigned long timeout_ms)\n{\n\tunsigned long limit;\n\tu32 st;\n\n\tlimit = jiffies + msecs_to_jiffies(timeout_ms);\n\tdo {\n\t\tst = readl_relaxed(nfc->regs + NDSR);\n\t\tif (st & NDSR_RDY(1))\n\t\t\tst |= NDSR_RDY(0);\n\n\t\tif ((st & mask) == expected_val)\n\t\t\treturn 0;\n\n\t\tcpu_relax();\n\t} while (time_after(limit, jiffies));\n\n\treturn -ETIMEDOUT;\n}\n\nstatic int marvell_nfc_wait_op(struct nand_chip *chip, unsigned int timeout_ms)\n{\n\tstruct marvell_nfc *nfc = to_marvell_nfc(chip->controller);\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tu32 pending;\n\tint ret;\n\n\t \n\tif (!timeout_ms)\n\t\ttimeout_ms = IRQ_TIMEOUT;\n\n\tif (mtd->oops_panic_write) {\n\t\tret = marvell_nfc_poll_status(nfc, NDSR_RDY(0),\n\t\t\t\t\t      NDSR_RDY(0),\n\t\t\t\t\t      timeout_ms);\n\t} else {\n\t\tinit_completion(&nfc->complete);\n\n\t\tmarvell_nfc_enable_int(nfc, NDCR_RDYM);\n\t\tret = wait_for_completion_timeout(&nfc->complete,\n\t\t\t\t\t\t  msecs_to_jiffies(timeout_ms));\n\t\tmarvell_nfc_disable_int(nfc, NDCR_RDYM);\n\t}\n\tpending = marvell_nfc_clear_int(nfc, NDSR_RDY(0) | NDSR_RDY(1));\n\n\t \n\tif (!ret && !pending) {\n\t\tdev_err(nfc->dev, \"Timeout waiting for RB signal\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\treturn 0;\n}\n\nstatic void marvell_nfc_select_target(struct nand_chip *chip,\n\t\t\t\t      unsigned int die_nr)\n{\n\tstruct marvell_nand_chip *marvell_nand = to_marvell_nand(chip);\n\tstruct marvell_nfc *nfc = to_marvell_nfc(chip->controller);\n\tu32 ndcr_generic;\n\n\t \n\tndcr_generic = readl_relaxed(nfc->regs + NDCR) &\n\t\t       NDCR_GENERIC_FIELDS_MASK & ~NDCR_ND_RUN;\n\twritel_relaxed(ndcr_generic | marvell_nand->ndcr, nfc->regs + NDCR);\n\n\t \n\tmarvell_nfc_clear_int(nfc, NDCR_ALL_INT);\n\n\tif (chip == nfc->selected_chip && die_nr == marvell_nand->selected_die)\n\t\treturn;\n\n\twritel_relaxed(marvell_nand->ndtr0, nfc->regs + NDTR0);\n\twritel_relaxed(marvell_nand->ndtr1, nfc->regs + NDTR1);\n\n\tnfc->selected_chip = chip;\n\tmarvell_nand->selected_die = die_nr;\n}\n\nstatic irqreturn_t marvell_nfc_isr(int irq, void *dev_id)\n{\n\tstruct marvell_nfc *nfc = dev_id;\n\tu32 st = readl_relaxed(nfc->regs + NDSR);\n\tu32 ien = (~readl_relaxed(nfc->regs + NDCR)) & NDCR_ALL_INT;\n\n\t \n\tif (st & NDSR_RDY(1))\n\t\tst |= NDSR_RDY(0);\n\n\tif (!(st & ien))\n\t\treturn IRQ_NONE;\n\n\tmarvell_nfc_disable_int(nfc, st & NDCR_ALL_INT);\n\n\tif (st & (NDSR_RDY(0) | NDSR_RDY(1)))\n\t\tcomplete(&nfc->complete);\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic void marvell_nfc_enable_hw_ecc(struct nand_chip *chip)\n{\n\tstruct marvell_nfc *nfc = to_marvell_nfc(chip->controller);\n\tu32 ndcr = readl_relaxed(nfc->regs + NDCR);\n\n\tif (!(ndcr & NDCR_ECC_EN)) {\n\t\twritel_relaxed(ndcr | NDCR_ECC_EN, nfc->regs + NDCR);\n\n\t\t \n\t\tif (chip->ecc.algo == NAND_ECC_ALGO_BCH)\n\t\t\twritel_relaxed(NDECCCTRL_BCH_EN, nfc->regs + NDECCCTRL);\n\t}\n}\n\nstatic void marvell_nfc_disable_hw_ecc(struct nand_chip *chip)\n{\n\tstruct marvell_nfc *nfc = to_marvell_nfc(chip->controller);\n\tu32 ndcr = readl_relaxed(nfc->regs + NDCR);\n\n\tif (ndcr & NDCR_ECC_EN) {\n\t\twritel_relaxed(ndcr & ~NDCR_ECC_EN, nfc->regs + NDCR);\n\t\tif (chip->ecc.algo == NAND_ECC_ALGO_BCH)\n\t\t\twritel_relaxed(0, nfc->regs + NDECCCTRL);\n\t}\n}\n\n \nstatic void marvell_nfc_enable_dma(struct marvell_nfc *nfc)\n{\n\tu32 reg;\n\n\treg = readl_relaxed(nfc->regs + NDCR);\n\twritel_relaxed(reg | NDCR_DMA_EN, nfc->regs + NDCR);\n}\n\nstatic void marvell_nfc_disable_dma(struct marvell_nfc *nfc)\n{\n\tu32 reg;\n\n\treg = readl_relaxed(nfc->regs + NDCR);\n\twritel_relaxed(reg & ~NDCR_DMA_EN, nfc->regs + NDCR);\n}\n\n \nstatic int marvell_nfc_xfer_data_dma(struct marvell_nfc *nfc,\n\t\t\t\t     enum dma_data_direction direction,\n\t\t\t\t     unsigned int len)\n{\n\tunsigned int dma_len = min_t(int, ALIGN(len, 32), MAX_CHUNK_SIZE);\n\tstruct dma_async_tx_descriptor *tx;\n\tstruct scatterlist sg;\n\tdma_cookie_t cookie;\n\tint ret;\n\n\tmarvell_nfc_enable_dma(nfc);\n\t \n\tsg_init_one(&sg, nfc->dma_buf, dma_len);\n\tret = dma_map_sg(nfc->dma_chan->device->dev, &sg, 1, direction);\n\tif (!ret) {\n\t\tdev_err(nfc->dev, \"Could not map DMA S/G list\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\ttx = dmaengine_prep_slave_sg(nfc->dma_chan, &sg, 1,\n\t\t\t\t     direction == DMA_FROM_DEVICE ?\n\t\t\t\t     DMA_DEV_TO_MEM : DMA_MEM_TO_DEV,\n\t\t\t\t     DMA_PREP_INTERRUPT);\n\tif (!tx) {\n\t\tdev_err(nfc->dev, \"Could not prepare DMA S/G list\\n\");\n\t\tdma_unmap_sg(nfc->dma_chan->device->dev, &sg, 1, direction);\n\t\treturn -ENXIO;\n\t}\n\n\t \n\tcookie = dmaengine_submit(tx);\n\tret = dma_submit_error(cookie);\n\tif (ret)\n\t\treturn -EIO;\n\n\tdma_async_issue_pending(nfc->dma_chan);\n\tret = marvell_nfc_wait_cmdd(nfc->selected_chip);\n\tdma_unmap_sg(nfc->dma_chan->device->dev, &sg, 1, direction);\n\tmarvell_nfc_disable_dma(nfc);\n\tif (ret) {\n\t\tdev_err(nfc->dev, \"Timeout waiting for DMA (status: %d)\\n\",\n\t\t\tdmaengine_tx_status(nfc->dma_chan, cookie, NULL));\n\t\tdmaengine_terminate_all(nfc->dma_chan);\n\t\treturn -ETIMEDOUT;\n\t}\n\n\treturn 0;\n}\n\nstatic int marvell_nfc_xfer_data_in_pio(struct marvell_nfc *nfc, u8 *in,\n\t\t\t\t\tunsigned int len)\n{\n\tunsigned int last_len = len % FIFO_DEPTH;\n\tunsigned int last_full_offset = round_down(len, FIFO_DEPTH);\n\tint i;\n\n\tfor (i = 0; i < last_full_offset; i += FIFO_DEPTH)\n\t\tioread32_rep(nfc->regs + NDDB, in + i, FIFO_REP(FIFO_DEPTH));\n\n\tif (last_len) {\n\t\tu8 tmp_buf[FIFO_DEPTH];\n\n\t\tioread32_rep(nfc->regs + NDDB, tmp_buf, FIFO_REP(FIFO_DEPTH));\n\t\tmemcpy(in + last_full_offset, tmp_buf, last_len);\n\t}\n\n\treturn 0;\n}\n\nstatic int marvell_nfc_xfer_data_out_pio(struct marvell_nfc *nfc, const u8 *out,\n\t\t\t\t\t unsigned int len)\n{\n\tunsigned int last_len = len % FIFO_DEPTH;\n\tunsigned int last_full_offset = round_down(len, FIFO_DEPTH);\n\tint i;\n\n\tfor (i = 0; i < last_full_offset; i += FIFO_DEPTH)\n\t\tiowrite32_rep(nfc->regs + NDDB, out + i, FIFO_REP(FIFO_DEPTH));\n\n\tif (last_len) {\n\t\tu8 tmp_buf[FIFO_DEPTH];\n\n\t\tmemcpy(tmp_buf, out + last_full_offset, last_len);\n\t\tiowrite32_rep(nfc->regs + NDDB, tmp_buf, FIFO_REP(FIFO_DEPTH));\n\t}\n\n\treturn 0;\n}\n\nstatic void marvell_nfc_check_empty_chunk(struct nand_chip *chip,\n\t\t\t\t\t  u8 *data, int data_len,\n\t\t\t\t\t  u8 *spare, int spare_len,\n\t\t\t\t\t  u8 *ecc, int ecc_len,\n\t\t\t\t\t  unsigned int *max_bitflips)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tint bf;\n\n\t \n\tif (!data)\n\t\tdata_len = 0;\n\tif (!spare)\n\t\tspare_len = 0;\n\tif (!ecc)\n\t\tecc_len = 0;\n\n\tbf = nand_check_erased_ecc_chunk(data, data_len, ecc, ecc_len,\n\t\t\t\t\t spare, spare_len, chip->ecc.strength);\n\tif (bf < 0) {\n\t\tmtd->ecc_stats.failed++;\n\t\treturn;\n\t}\n\n\t \n\tmtd->ecc_stats.corrected += bf;\n\t*max_bitflips = max_t(unsigned int, *max_bitflips, bf);\n}\n\n \nstatic int marvell_nfc_hw_ecc_check_bitflips(struct nand_chip *chip,\n\t\t\t\t\t     unsigned int *max_bitflips)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tstruct marvell_nfc *nfc = to_marvell_nfc(chip->controller);\n\tint bf = 0;\n\tu32 ndsr;\n\n\tndsr = readl_relaxed(nfc->regs + NDSR);\n\n\t \n\tif (ndsr & NDSR_UNCERR) {\n\t\twritel_relaxed(ndsr, nfc->regs + NDSR);\n\n\t\t \n\t\treturn -EBADMSG;\n\t}\n\n\t \n\tif (ndsr & NDSR_CORERR) {\n\t\twritel_relaxed(ndsr, nfc->regs + NDSR);\n\n\t\tif (chip->ecc.algo == NAND_ECC_ALGO_BCH)\n\t\t\tbf = NDSR_ERRCNT(ndsr);\n\t\telse\n\t\t\tbf = 1;\n\t}\n\n\t \n\tmtd->ecc_stats.corrected += bf;\n\t*max_bitflips = max_t(unsigned int, *max_bitflips, bf);\n\n\treturn 0;\n}\n\n \nstatic int marvell_nfc_hw_ecc_hmg_do_read_page(struct nand_chip *chip,\n\t\t\t\t\t       u8 *data_buf, u8 *oob_buf,\n\t\t\t\t\t       bool raw, int page)\n{\n\tstruct marvell_nand_chip *marvell_nand = to_marvell_nand(chip);\n\tstruct marvell_nfc *nfc = to_marvell_nfc(chip->controller);\n\tconst struct marvell_hw_ecc_layout *lt = to_marvell_nand(chip)->layout;\n\tstruct marvell_nfc_op nfc_op = {\n\t\t.ndcb[0] = NDCB0_CMD_TYPE(TYPE_READ) |\n\t\t\t   NDCB0_ADDR_CYC(marvell_nand->addr_cyc) |\n\t\t\t   NDCB0_DBC |\n\t\t\t   NDCB0_CMD1(NAND_CMD_READ0) |\n\t\t\t   NDCB0_CMD2(NAND_CMD_READSTART),\n\t\t.ndcb[1] = NDCB1_ADDRS_PAGE(page),\n\t\t.ndcb[2] = NDCB2_ADDR5_PAGE(page),\n\t};\n\tunsigned int oob_bytes = lt->spare_bytes + (raw ? lt->ecc_bytes : 0);\n\tint ret;\n\n\t \n\tif (nfc->caps->is_nfcv2)\n\t\tnfc_op.ndcb[0] |= NDCB0_CMD_XTYPE(XTYPE_MONOLITHIC_RW);\n\n\tret = marvell_nfc_prepare_cmd(chip);\n\tif (ret)\n\t\treturn ret;\n\n\tmarvell_nfc_send_cmd(chip, &nfc_op);\n\tret = marvell_nfc_end_cmd(chip, NDSR_RDDREQ,\n\t\t\t\t  \"RDDREQ while draining FIFO (data/oob)\");\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (nfc->use_dma) {\n\t\tmarvell_nfc_xfer_data_dma(nfc, DMA_FROM_DEVICE,\n\t\t\t\t\t  lt->data_bytes + oob_bytes);\n\t\tmemcpy(data_buf, nfc->dma_buf, lt->data_bytes);\n\t\tmemcpy(oob_buf, nfc->dma_buf + lt->data_bytes, oob_bytes);\n\t} else {\n\t\tmarvell_nfc_xfer_data_in_pio(nfc, data_buf, lt->data_bytes);\n\t\tmarvell_nfc_xfer_data_in_pio(nfc, oob_buf, oob_bytes);\n\t}\n\n\tret = marvell_nfc_wait_cmdd(chip);\n\treturn ret;\n}\n\nstatic int marvell_nfc_hw_ecc_hmg_read_page_raw(struct nand_chip *chip, u8 *buf,\n\t\t\t\t\t\tint oob_required, int page)\n{\n\tmarvell_nfc_select_target(chip, chip->cur_cs);\n\treturn marvell_nfc_hw_ecc_hmg_do_read_page(chip, buf, chip->oob_poi,\n\t\t\t\t\t\t   true, page);\n}\n\nstatic int marvell_nfc_hw_ecc_hmg_read_page(struct nand_chip *chip, u8 *buf,\n\t\t\t\t\t    int oob_required, int page)\n{\n\tconst struct marvell_hw_ecc_layout *lt = to_marvell_nand(chip)->layout;\n\tunsigned int full_sz = lt->data_bytes + lt->spare_bytes + lt->ecc_bytes;\n\tint max_bitflips = 0, ret;\n\tu8 *raw_buf;\n\n\tmarvell_nfc_select_target(chip, chip->cur_cs);\n\tmarvell_nfc_enable_hw_ecc(chip);\n\tmarvell_nfc_hw_ecc_hmg_do_read_page(chip, buf, chip->oob_poi, false,\n\t\t\t\t\t    page);\n\tret = marvell_nfc_hw_ecc_check_bitflips(chip, &max_bitflips);\n\tmarvell_nfc_disable_hw_ecc(chip);\n\n\tif (!ret)\n\t\treturn max_bitflips;\n\n\t \n\traw_buf = kmalloc(full_sz, GFP_KERNEL);\n\tif (!raw_buf)\n\t\treturn -ENOMEM;\n\n\tmarvell_nfc_hw_ecc_hmg_do_read_page(chip, raw_buf, raw_buf +\n\t\t\t\t\t    lt->data_bytes, true, page);\n\tmarvell_nfc_check_empty_chunk(chip, raw_buf, full_sz, NULL, 0, NULL, 0,\n\t\t\t\t      &max_bitflips);\n\tkfree(raw_buf);\n\n\treturn max_bitflips;\n}\n\n \nstatic int marvell_nfc_hw_ecc_hmg_read_oob_raw(struct nand_chip *chip, int page)\n{\n\tu8 *buf = nand_get_data_buf(chip);\n\n\tmarvell_nfc_select_target(chip, chip->cur_cs);\n\treturn marvell_nfc_hw_ecc_hmg_do_read_page(chip, buf, chip->oob_poi,\n\t\t\t\t\t\t   true, page);\n}\n\n \nstatic int marvell_nfc_hw_ecc_hmg_do_write_page(struct nand_chip *chip,\n\t\t\t\t\t\tconst u8 *data_buf,\n\t\t\t\t\t\tconst u8 *oob_buf, bool raw,\n\t\t\t\t\t\tint page)\n{\n\tconst struct nand_sdr_timings *sdr =\n\t\tnand_get_sdr_timings(nand_get_interface_config(chip));\n\tstruct marvell_nand_chip *marvell_nand = to_marvell_nand(chip);\n\tstruct marvell_nfc *nfc = to_marvell_nfc(chip->controller);\n\tconst struct marvell_hw_ecc_layout *lt = to_marvell_nand(chip)->layout;\n\tstruct marvell_nfc_op nfc_op = {\n\t\t.ndcb[0] = NDCB0_CMD_TYPE(TYPE_WRITE) |\n\t\t\t   NDCB0_ADDR_CYC(marvell_nand->addr_cyc) |\n\t\t\t   NDCB0_CMD1(NAND_CMD_SEQIN) |\n\t\t\t   NDCB0_CMD2(NAND_CMD_PAGEPROG) |\n\t\t\t   NDCB0_DBC,\n\t\t.ndcb[1] = NDCB1_ADDRS_PAGE(page),\n\t\t.ndcb[2] = NDCB2_ADDR5_PAGE(page),\n\t};\n\tunsigned int oob_bytes = lt->spare_bytes + (raw ? lt->ecc_bytes : 0);\n\tu8 status;\n\tint ret;\n\n\t \n\tif (nfc->caps->is_nfcv2)\n\t\tnfc_op.ndcb[0] |= NDCB0_CMD_XTYPE(XTYPE_MONOLITHIC_RW);\n\n\tret = marvell_nfc_prepare_cmd(chip);\n\tif (ret)\n\t\treturn ret;\n\n\tmarvell_nfc_send_cmd(chip, &nfc_op);\n\tret = marvell_nfc_end_cmd(chip, NDSR_WRDREQ,\n\t\t\t\t  \"WRDREQ while loading FIFO (data)\");\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (nfc->use_dma) {\n\t\tmemcpy(nfc->dma_buf, data_buf, lt->data_bytes);\n\t\tmemcpy(nfc->dma_buf + lt->data_bytes, oob_buf, oob_bytes);\n\t\tmarvell_nfc_xfer_data_dma(nfc, DMA_TO_DEVICE, lt->data_bytes +\n\t\t\t\t\t  lt->ecc_bytes + lt->spare_bytes);\n\t} else {\n\t\tmarvell_nfc_xfer_data_out_pio(nfc, data_buf, lt->data_bytes);\n\t\tmarvell_nfc_xfer_data_out_pio(nfc, oob_buf, oob_bytes);\n\t}\n\n\tret = marvell_nfc_wait_cmdd(chip);\n\tif (ret)\n\t\treturn ret;\n\n\tret = marvell_nfc_wait_op(chip,\n\t\t\t\t  PSEC_TO_MSEC(sdr->tPROG_max));\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = nand_status_op(chip, &status);\n\tif (ret)\n\t\treturn ret;\n\n\tif (status & NAND_STATUS_FAIL)\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nstatic int marvell_nfc_hw_ecc_hmg_write_page_raw(struct nand_chip *chip,\n\t\t\t\t\t\t const u8 *buf,\n\t\t\t\t\t\t int oob_required, int page)\n{\n\tmarvell_nfc_select_target(chip, chip->cur_cs);\n\treturn marvell_nfc_hw_ecc_hmg_do_write_page(chip, buf, chip->oob_poi,\n\t\t\t\t\t\t    true, page);\n}\n\nstatic int marvell_nfc_hw_ecc_hmg_write_page(struct nand_chip *chip,\n\t\t\t\t\t     const u8 *buf,\n\t\t\t\t\t     int oob_required, int page)\n{\n\tint ret;\n\n\tmarvell_nfc_select_target(chip, chip->cur_cs);\n\tmarvell_nfc_enable_hw_ecc(chip);\n\tret = marvell_nfc_hw_ecc_hmg_do_write_page(chip, buf, chip->oob_poi,\n\t\t\t\t\t\t   false, page);\n\tmarvell_nfc_disable_hw_ecc(chip);\n\n\treturn ret;\n}\n\n \nstatic int marvell_nfc_hw_ecc_hmg_write_oob_raw(struct nand_chip *chip,\n\t\t\t\t\t\tint page)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tu8 *buf = nand_get_data_buf(chip);\n\n\tmemset(buf, 0xFF, mtd->writesize);\n\n\tmarvell_nfc_select_target(chip, chip->cur_cs);\n\treturn marvell_nfc_hw_ecc_hmg_do_write_page(chip, buf, chip->oob_poi,\n\t\t\t\t\t\t    true, page);\n}\n\n \nstatic int marvell_nfc_hw_ecc_bch_read_page_raw(struct nand_chip *chip, u8 *buf,\n\t\t\t\t\t\tint oob_required, int page)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tconst struct marvell_hw_ecc_layout *lt = to_marvell_nand(chip)->layout;\n\tu8 *oob = chip->oob_poi;\n\tint chunk_size = lt->data_bytes + lt->spare_bytes + lt->ecc_bytes;\n\tint ecc_offset = (lt->full_chunk_cnt * lt->spare_bytes) +\n\t\tlt->last_spare_bytes;\n\tint data_len = lt->data_bytes;\n\tint spare_len = lt->spare_bytes;\n\tint ecc_len = lt->ecc_bytes;\n\tint chunk;\n\n\tmarvell_nfc_select_target(chip, chip->cur_cs);\n\n\tif (oob_required)\n\t\tmemset(chip->oob_poi, 0xFF, mtd->oobsize);\n\n\tnand_read_page_op(chip, page, 0, NULL, 0);\n\n\tfor (chunk = 0; chunk < lt->nchunks; chunk++) {\n\t\t \n\t\tif (chunk >= lt->full_chunk_cnt) {\n\t\t\tdata_len = lt->last_data_bytes;\n\t\t\tspare_len = lt->last_spare_bytes;\n\t\t\tecc_len = lt->last_ecc_bytes;\n\t\t}\n\n\t\t \n\t\tnand_change_read_column_op(chip, chunk * chunk_size,\n\t\t\t\t\t   buf + (lt->data_bytes * chunk),\n\t\t\t\t\t   data_len, false);\n\n\t\t \n\t\tnand_read_data_op(chip, oob + (lt->spare_bytes * chunk),\n\t\t\t\t  spare_len, false, false);\n\n\t\t \n\t\tnand_read_data_op(chip, oob + ecc_offset +\n\t\t\t\t  (ALIGN(lt->ecc_bytes, 32) * chunk),\n\t\t\t\t  ecc_len, false, false);\n\t}\n\n\treturn 0;\n}\n\nstatic void marvell_nfc_hw_ecc_bch_read_chunk(struct nand_chip *chip, int chunk,\n\t\t\t\t\t      u8 *data, unsigned int data_len,\n\t\t\t\t\t      u8 *spare, unsigned int spare_len,\n\t\t\t\t\t      int page)\n{\n\tstruct marvell_nand_chip *marvell_nand = to_marvell_nand(chip);\n\tstruct marvell_nfc *nfc = to_marvell_nfc(chip->controller);\n\tconst struct marvell_hw_ecc_layout *lt = to_marvell_nand(chip)->layout;\n\tint i, ret;\n\tstruct marvell_nfc_op nfc_op = {\n\t\t.ndcb[0] = NDCB0_CMD_TYPE(TYPE_READ) |\n\t\t\t   NDCB0_ADDR_CYC(marvell_nand->addr_cyc) |\n\t\t\t   NDCB0_LEN_OVRD,\n\t\t.ndcb[1] = NDCB1_ADDRS_PAGE(page),\n\t\t.ndcb[2] = NDCB2_ADDR5_PAGE(page),\n\t\t.ndcb[3] = data_len + spare_len,\n\t};\n\n\tret = marvell_nfc_prepare_cmd(chip);\n\tif (ret)\n\t\treturn;\n\n\tif (chunk == 0)\n\t\tnfc_op.ndcb[0] |= NDCB0_DBC |\n\t\t\t\t  NDCB0_CMD1(NAND_CMD_READ0) |\n\t\t\t\t  NDCB0_CMD2(NAND_CMD_READSTART);\n\n\t \n\tif (chunk == 0)\n\t\tnfc_op.ndcb[0] |= NDCB0_CMD_XTYPE(XTYPE_MONOLITHIC_RW);\n\telse if (chunk < lt->nchunks - 1)\n\t\tnfc_op.ndcb[0] |= NDCB0_CMD_XTYPE(XTYPE_NAKED_RW);\n\telse\n\t\tnfc_op.ndcb[0] |= NDCB0_CMD_XTYPE(XTYPE_LAST_NAKED_RW);\n\n\tmarvell_nfc_send_cmd(chip, &nfc_op);\n\n\t \n\tfor (i = 0; i < data_len; i += FIFO_DEPTH * BCH_SEQ_READS) {\n\t\tmarvell_nfc_end_cmd(chip, NDSR_RDDREQ,\n\t\t\t\t    \"RDDREQ while draining FIFO (data)\");\n\t\tmarvell_nfc_xfer_data_in_pio(nfc, data,\n\t\t\t\t\t     FIFO_DEPTH * BCH_SEQ_READS);\n\t\tdata += FIFO_DEPTH * BCH_SEQ_READS;\n\t}\n\n\tfor (i = 0; i < spare_len; i += FIFO_DEPTH * BCH_SEQ_READS) {\n\t\tmarvell_nfc_end_cmd(chip, NDSR_RDDREQ,\n\t\t\t\t    \"RDDREQ while draining FIFO (OOB)\");\n\t\tmarvell_nfc_xfer_data_in_pio(nfc, spare,\n\t\t\t\t\t     FIFO_DEPTH * BCH_SEQ_READS);\n\t\tspare += FIFO_DEPTH * BCH_SEQ_READS;\n\t}\n}\n\nstatic int marvell_nfc_hw_ecc_bch_read_page(struct nand_chip *chip,\n\t\t\t\t\t    u8 *buf, int oob_required,\n\t\t\t\t\t    int page)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tconst struct marvell_hw_ecc_layout *lt = to_marvell_nand(chip)->layout;\n\tint data_len = lt->data_bytes, spare_len = lt->spare_bytes;\n\tu8 *data = buf, *spare = chip->oob_poi;\n\tint max_bitflips = 0;\n\tu32 failure_mask = 0;\n\tint chunk, ret;\n\n\tmarvell_nfc_select_target(chip, chip->cur_cs);\n\n\t \n\tif (oob_required)\n\t\tmemset(chip->oob_poi, 0xFF, mtd->oobsize);\n\n\tmarvell_nfc_enable_hw_ecc(chip);\n\n\tfor (chunk = 0; chunk < lt->nchunks; chunk++) {\n\t\t \n\t\tif (chunk >= lt->full_chunk_cnt) {\n\t\t\tdata_len = lt->last_data_bytes;\n\t\t\tspare_len = lt->last_spare_bytes;\n\t\t}\n\n\t\t \n\t\tmarvell_nfc_hw_ecc_bch_read_chunk(chip, chunk, data, data_len,\n\t\t\t\t\t\t  spare, spare_len, page);\n\t\tret = marvell_nfc_hw_ecc_check_bitflips(chip, &max_bitflips);\n\t\tif (ret)\n\t\t\tfailure_mask |= BIT(chunk);\n\n\t\tdata += data_len;\n\t\tspare += spare_len;\n\t}\n\n\tmarvell_nfc_disable_hw_ecc(chip);\n\n\tif (!failure_mask)\n\t\treturn max_bitflips;\n\n\t \n\n\t \n\tfor (chunk = 0; chunk < lt->nchunks; chunk++) {\n\t\tint data_off_in_page, spare_off_in_page, ecc_off_in_page;\n\t\tint data_off, spare_off, ecc_off;\n\t\tint data_len, spare_len, ecc_len;\n\n\t\t \n\t\tif (!(failure_mask & BIT(chunk)))\n\t\t\tcontinue;\n\n\t\tdata_off_in_page = chunk * (lt->data_bytes + lt->spare_bytes +\n\t\t\t\t\t    lt->ecc_bytes);\n\t\tspare_off_in_page = data_off_in_page +\n\t\t\t(chunk < lt->full_chunk_cnt ? lt->data_bytes :\n\t\t\t\t\t\t      lt->last_data_bytes);\n\t\tecc_off_in_page = spare_off_in_page +\n\t\t\t(chunk < lt->full_chunk_cnt ? lt->spare_bytes :\n\t\t\t\t\t\t      lt->last_spare_bytes);\n\n\t\tdata_off = chunk * lt->data_bytes;\n\t\tspare_off = chunk * lt->spare_bytes;\n\t\tecc_off = (lt->full_chunk_cnt * lt->spare_bytes) +\n\t\t\t  lt->last_spare_bytes +\n\t\t\t  (chunk * (lt->ecc_bytes + 2));\n\n\t\tdata_len = chunk < lt->full_chunk_cnt ? lt->data_bytes :\n\t\t\t\t\t\t\tlt->last_data_bytes;\n\t\tspare_len = chunk < lt->full_chunk_cnt ? lt->spare_bytes :\n\t\t\t\t\t\t\t lt->last_spare_bytes;\n\t\tecc_len = chunk < lt->full_chunk_cnt ? lt->ecc_bytes :\n\t\t\t\t\t\t       lt->last_ecc_bytes;\n\n\t\t \n\t\tif (lt->writesize == 2048 && lt->strength == 8) {\n\t\t\tnand_change_read_column_op(chip, data_off_in_page,\n\t\t\t\t\t\t   buf + data_off, data_len,\n\t\t\t\t\t\t   false);\n\t\t\tnand_change_read_column_op(chip, spare_off_in_page,\n\t\t\t\t\t\t   chip->oob_poi + spare_off, spare_len,\n\t\t\t\t\t\t   false);\n\t\t}\n\n\t\tnand_change_read_column_op(chip, ecc_off_in_page,\n\t\t\t\t\t   chip->oob_poi + ecc_off, ecc_len,\n\t\t\t\t\t   false);\n\n\t\t \n\t\tmarvell_nfc_check_empty_chunk(chip, buf + data_off, data_len,\n\t\t\t\t\t      chip->oob_poi + spare_off, spare_len,\n\t\t\t\t\t      chip->oob_poi + ecc_off, ecc_len,\n\t\t\t\t\t      &max_bitflips);\n\t}\n\n\treturn max_bitflips;\n}\n\nstatic int marvell_nfc_hw_ecc_bch_read_oob_raw(struct nand_chip *chip, int page)\n{\n\tu8 *buf = nand_get_data_buf(chip);\n\n\treturn chip->ecc.read_page_raw(chip, buf, true, page);\n}\n\nstatic int marvell_nfc_hw_ecc_bch_read_oob(struct nand_chip *chip, int page)\n{\n\tu8 *buf = nand_get_data_buf(chip);\n\n\treturn chip->ecc.read_page(chip, buf, true, page);\n}\n\n \nstatic int marvell_nfc_hw_ecc_bch_write_page_raw(struct nand_chip *chip,\n\t\t\t\t\t\t const u8 *buf,\n\t\t\t\t\t\t int oob_required, int page)\n{\n\tconst struct marvell_hw_ecc_layout *lt = to_marvell_nand(chip)->layout;\n\tint full_chunk_size = lt->data_bytes + lt->spare_bytes + lt->ecc_bytes;\n\tint data_len = lt->data_bytes;\n\tint spare_len = lt->spare_bytes;\n\tint ecc_len = lt->ecc_bytes;\n\tint spare_offset = 0;\n\tint ecc_offset = (lt->full_chunk_cnt * lt->spare_bytes) +\n\t\tlt->last_spare_bytes;\n\tint chunk;\n\n\tmarvell_nfc_select_target(chip, chip->cur_cs);\n\n\tnand_prog_page_begin_op(chip, page, 0, NULL, 0);\n\n\tfor (chunk = 0; chunk < lt->nchunks; chunk++) {\n\t\tif (chunk >= lt->full_chunk_cnt) {\n\t\t\tdata_len = lt->last_data_bytes;\n\t\t\tspare_len = lt->last_spare_bytes;\n\t\t\tecc_len = lt->last_ecc_bytes;\n\t\t}\n\n\t\t \n\t\tnand_change_write_column_op(chip, chunk * full_chunk_size,\n\t\t\t\t\t    NULL, 0, false);\n\n\t\t \n\t\tnand_write_data_op(chip, buf + (chunk * lt->data_bytes),\n\t\t\t\t   data_len, false);\n\n\t\tif (!oob_required)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (spare_len)\n\t\t\tnand_write_data_op(chip, chip->oob_poi + spare_offset,\n\t\t\t\t\t   spare_len, false);\n\n\t\t \n\t\tif (ecc_len)\n\t\t\tnand_write_data_op(chip, chip->oob_poi + ecc_offset,\n\t\t\t\t\t   ecc_len, false);\n\n\t\tspare_offset += spare_len;\n\t\tecc_offset += ALIGN(ecc_len, 32);\n\t}\n\n\treturn nand_prog_page_end_op(chip);\n}\n\nstatic int\nmarvell_nfc_hw_ecc_bch_write_chunk(struct nand_chip *chip, int chunk,\n\t\t\t\t   const u8 *data, unsigned int data_len,\n\t\t\t\t   const u8 *spare, unsigned int spare_len,\n\t\t\t\t   int page)\n{\n\tstruct marvell_nand_chip *marvell_nand = to_marvell_nand(chip);\n\tstruct marvell_nfc *nfc = to_marvell_nfc(chip->controller);\n\tconst struct marvell_hw_ecc_layout *lt = to_marvell_nand(chip)->layout;\n\tu32 xtype;\n\tint ret;\n\tstruct marvell_nfc_op nfc_op = {\n\t\t.ndcb[0] = NDCB0_CMD_TYPE(TYPE_WRITE) | NDCB0_LEN_OVRD,\n\t\t.ndcb[3] = data_len + spare_len,\n\t};\n\n\t \n\tif (chunk == 0) {\n\t\tif (lt->nchunks == 1)\n\t\t\txtype = XTYPE_MONOLITHIC_RW;\n\t\telse\n\t\t\txtype = XTYPE_WRITE_DISPATCH;\n\n\t\tnfc_op.ndcb[0] |= NDCB0_CMD_XTYPE(xtype) |\n\t\t\t\t  NDCB0_ADDR_CYC(marvell_nand->addr_cyc) |\n\t\t\t\t  NDCB0_CMD1(NAND_CMD_SEQIN);\n\t\tnfc_op.ndcb[1] |= NDCB1_ADDRS_PAGE(page);\n\t\tnfc_op.ndcb[2] |= NDCB2_ADDR5_PAGE(page);\n\t} else if (chunk < lt->nchunks - 1) {\n\t\tnfc_op.ndcb[0] |= NDCB0_CMD_XTYPE(XTYPE_NAKED_RW);\n\t} else {\n\t\tnfc_op.ndcb[0] |= NDCB0_CMD_XTYPE(XTYPE_LAST_NAKED_RW);\n\t}\n\n\t \n\tif (chunk == lt->nchunks - 1)\n\t\tnfc_op.ndcb[0] |= NDCB0_CMD2(NAND_CMD_PAGEPROG) | NDCB0_DBC;\n\n\tret = marvell_nfc_prepare_cmd(chip);\n\tif (ret)\n\t\treturn ret;\n\n\tmarvell_nfc_send_cmd(chip, &nfc_op);\n\tret = marvell_nfc_end_cmd(chip, NDSR_WRDREQ,\n\t\t\t\t  \"WRDREQ while loading FIFO (data)\");\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tiowrite32_rep(nfc->regs + NDDB, data, FIFO_REP(data_len));\n\tiowrite32_rep(nfc->regs + NDDB, spare, FIFO_REP(spare_len));\n\n\treturn 0;\n}\n\nstatic int marvell_nfc_hw_ecc_bch_write_page(struct nand_chip *chip,\n\t\t\t\t\t     const u8 *buf,\n\t\t\t\t\t     int oob_required, int page)\n{\n\tconst struct nand_sdr_timings *sdr =\n\t\tnand_get_sdr_timings(nand_get_interface_config(chip));\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tconst struct marvell_hw_ecc_layout *lt = to_marvell_nand(chip)->layout;\n\tconst u8 *data = buf;\n\tconst u8 *spare = chip->oob_poi;\n\tint data_len = lt->data_bytes;\n\tint spare_len = lt->spare_bytes;\n\tint chunk, ret;\n\tu8 status;\n\n\tmarvell_nfc_select_target(chip, chip->cur_cs);\n\n\t \n\tif (!oob_required)\n\t\tmemset(chip->oob_poi, 0xFF, mtd->oobsize);\n\n\tmarvell_nfc_enable_hw_ecc(chip);\n\n\tfor (chunk = 0; chunk < lt->nchunks; chunk++) {\n\t\tif (chunk >= lt->full_chunk_cnt) {\n\t\t\tdata_len = lt->last_data_bytes;\n\t\t\tspare_len = lt->last_spare_bytes;\n\t\t}\n\n\t\tmarvell_nfc_hw_ecc_bch_write_chunk(chip, chunk, data, data_len,\n\t\t\t\t\t\t   spare, spare_len, page);\n\t\tdata += data_len;\n\t\tspare += spare_len;\n\n\t\t \n\t\tmarvell_nfc_wait_ndrun(chip);\n\t}\n\n\tret = marvell_nfc_wait_op(chip, PSEC_TO_MSEC(sdr->tPROG_max));\n\n\tmarvell_nfc_disable_hw_ecc(chip);\n\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = nand_status_op(chip, &status);\n\tif (ret)\n\t\treturn ret;\n\n\tif (status & NAND_STATUS_FAIL)\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nstatic int marvell_nfc_hw_ecc_bch_write_oob_raw(struct nand_chip *chip,\n\t\t\t\t\t\tint page)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tu8 *buf = nand_get_data_buf(chip);\n\n\tmemset(buf, 0xFF, mtd->writesize);\n\n\treturn chip->ecc.write_page_raw(chip, buf, true, page);\n}\n\nstatic int marvell_nfc_hw_ecc_bch_write_oob(struct nand_chip *chip, int page)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tu8 *buf = nand_get_data_buf(chip);\n\n\tmemset(buf, 0xFF, mtd->writesize);\n\n\treturn chip->ecc.write_page(chip, buf, true, page);\n}\n\n \nstatic void marvell_nfc_parse_instructions(struct nand_chip *chip,\n\t\t\t\t\t   const struct nand_subop *subop,\n\t\t\t\t\t   struct marvell_nfc_op *nfc_op)\n{\n\tconst struct nand_op_instr *instr = NULL;\n\tstruct marvell_nfc *nfc = to_marvell_nfc(chip->controller);\n\tbool first_cmd = true;\n\tunsigned int op_id;\n\tint i;\n\n\t \n\tmemset(nfc_op, 0, sizeof(struct marvell_nfc_op));\n\n\tfor (op_id = 0; op_id < subop->ninstrs; op_id++) {\n\t\tunsigned int offset, naddrs;\n\t\tconst u8 *addrs;\n\t\tint len;\n\n\t\tinstr = &subop->instrs[op_id];\n\n\t\tswitch (instr->type) {\n\t\tcase NAND_OP_CMD_INSTR:\n\t\t\tif (first_cmd)\n\t\t\t\tnfc_op->ndcb[0] |=\n\t\t\t\t\tNDCB0_CMD1(instr->ctx.cmd.opcode);\n\t\t\telse\n\t\t\t\tnfc_op->ndcb[0] |=\n\t\t\t\t\tNDCB0_CMD2(instr->ctx.cmd.opcode) |\n\t\t\t\t\tNDCB0_DBC;\n\n\t\t\tnfc_op->cle_ale_delay_ns = instr->delay_ns;\n\t\t\tfirst_cmd = false;\n\t\t\tbreak;\n\n\t\tcase NAND_OP_ADDR_INSTR:\n\t\t\toffset = nand_subop_get_addr_start_off(subop, op_id);\n\t\t\tnaddrs = nand_subop_get_num_addr_cyc(subop, op_id);\n\t\t\taddrs = &instr->ctx.addr.addrs[offset];\n\n\t\t\tnfc_op->ndcb[0] |= NDCB0_ADDR_CYC(naddrs);\n\n\t\t\tfor (i = 0; i < min_t(unsigned int, 4, naddrs); i++)\n\t\t\t\tnfc_op->ndcb[1] |= addrs[i] << (8 * i);\n\n\t\t\tif (naddrs >= 5)\n\t\t\t\tnfc_op->ndcb[2] |= NDCB2_ADDR5_CYC(addrs[4]);\n\t\t\tif (naddrs >= 6)\n\t\t\t\tnfc_op->ndcb[3] |= NDCB3_ADDR6_CYC(addrs[5]);\n\t\t\tif (naddrs == 7)\n\t\t\t\tnfc_op->ndcb[3] |= NDCB3_ADDR7_CYC(addrs[6]);\n\n\t\t\tnfc_op->cle_ale_delay_ns = instr->delay_ns;\n\t\t\tbreak;\n\n\t\tcase NAND_OP_DATA_IN_INSTR:\n\t\t\tnfc_op->data_instr = instr;\n\t\t\tnfc_op->data_instr_idx = op_id;\n\t\t\tnfc_op->ndcb[0] |= NDCB0_CMD_TYPE(TYPE_READ);\n\t\t\tif (nfc->caps->is_nfcv2) {\n\t\t\t\tnfc_op->ndcb[0] |=\n\t\t\t\t\tNDCB0_CMD_XTYPE(XTYPE_MONOLITHIC_RW) |\n\t\t\t\t\tNDCB0_LEN_OVRD;\n\t\t\t\tlen = nand_subop_get_data_len(subop, op_id);\n\t\t\t\tnfc_op->ndcb[3] |= round_up(len, FIFO_DEPTH);\n\t\t\t}\n\t\t\tnfc_op->data_delay_ns = instr->delay_ns;\n\t\t\tbreak;\n\n\t\tcase NAND_OP_DATA_OUT_INSTR:\n\t\t\tnfc_op->data_instr = instr;\n\t\t\tnfc_op->data_instr_idx = op_id;\n\t\t\tnfc_op->ndcb[0] |= NDCB0_CMD_TYPE(TYPE_WRITE);\n\t\t\tif (nfc->caps->is_nfcv2) {\n\t\t\t\tnfc_op->ndcb[0] |=\n\t\t\t\t\tNDCB0_CMD_XTYPE(XTYPE_MONOLITHIC_RW) |\n\t\t\t\t\tNDCB0_LEN_OVRD;\n\t\t\t\tlen = nand_subop_get_data_len(subop, op_id);\n\t\t\t\tnfc_op->ndcb[3] |= round_up(len, FIFO_DEPTH);\n\t\t\t}\n\t\t\tnfc_op->data_delay_ns = instr->delay_ns;\n\t\t\tbreak;\n\n\t\tcase NAND_OP_WAITRDY_INSTR:\n\t\t\tnfc_op->rdy_timeout_ms = instr->ctx.waitrdy.timeout_ms;\n\t\t\tnfc_op->rdy_delay_ns = instr->delay_ns;\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic int marvell_nfc_xfer_data_pio(struct nand_chip *chip,\n\t\t\t\t     const struct nand_subop *subop,\n\t\t\t\t     struct marvell_nfc_op *nfc_op)\n{\n\tstruct marvell_nfc *nfc = to_marvell_nfc(chip->controller);\n\tconst struct nand_op_instr *instr = nfc_op->data_instr;\n\tunsigned int op_id = nfc_op->data_instr_idx;\n\tunsigned int len = nand_subop_get_data_len(subop, op_id);\n\tunsigned int offset = nand_subop_get_data_start_off(subop, op_id);\n\tbool reading = (instr->type == NAND_OP_DATA_IN_INSTR);\n\tint ret;\n\n\tif (instr->ctx.data.force_8bit)\n\t\tmarvell_nfc_force_byte_access(chip, true);\n\n\tif (reading) {\n\t\tu8 *in = instr->ctx.data.buf.in + offset;\n\n\t\tret = marvell_nfc_xfer_data_in_pio(nfc, in, len);\n\t} else {\n\t\tconst u8 *out = instr->ctx.data.buf.out + offset;\n\n\t\tret = marvell_nfc_xfer_data_out_pio(nfc, out, len);\n\t}\n\n\tif (instr->ctx.data.force_8bit)\n\t\tmarvell_nfc_force_byte_access(chip, false);\n\n\treturn ret;\n}\n\nstatic int marvell_nfc_monolithic_access_exec(struct nand_chip *chip,\n\t\t\t\t\t      const struct nand_subop *subop)\n{\n\tstruct marvell_nfc_op nfc_op;\n\tbool reading;\n\tint ret;\n\n\tmarvell_nfc_parse_instructions(chip, subop, &nfc_op);\n\treading = (nfc_op.data_instr->type == NAND_OP_DATA_IN_INSTR);\n\n\tret = marvell_nfc_prepare_cmd(chip);\n\tif (ret)\n\t\treturn ret;\n\n\tmarvell_nfc_send_cmd(chip, &nfc_op);\n\tret = marvell_nfc_end_cmd(chip, NDSR_RDDREQ | NDSR_WRDREQ,\n\t\t\t\t  \"RDDREQ/WRDREQ while draining raw data\");\n\tif (ret)\n\t\treturn ret;\n\n\tcond_delay(nfc_op.cle_ale_delay_ns);\n\n\tif (reading) {\n\t\tif (nfc_op.rdy_timeout_ms) {\n\t\t\tret = marvell_nfc_wait_op(chip, nfc_op.rdy_timeout_ms);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\n\t\tcond_delay(nfc_op.rdy_delay_ns);\n\t}\n\n\tmarvell_nfc_xfer_data_pio(chip, subop, &nfc_op);\n\tret = marvell_nfc_wait_cmdd(chip);\n\tif (ret)\n\t\treturn ret;\n\n\tcond_delay(nfc_op.data_delay_ns);\n\n\tif (!reading) {\n\t\tif (nfc_op.rdy_timeout_ms) {\n\t\t\tret = marvell_nfc_wait_op(chip, nfc_op.rdy_timeout_ms);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\n\t\tcond_delay(nfc_op.rdy_delay_ns);\n\t}\n\n\t \n\tif (!reading) {\n\t\tstruct marvell_nfc *nfc = to_marvell_nfc(chip->controller);\n\n\t\twritel_relaxed(readl(nfc->regs + NDCR) & ~NDCR_ND_RUN,\n\t\t\t       nfc->regs + NDCR);\n\t}\n\n\treturn 0;\n}\n\nstatic int marvell_nfc_naked_access_exec(struct nand_chip *chip,\n\t\t\t\t\t const struct nand_subop *subop)\n{\n\tstruct marvell_nfc_op nfc_op;\n\tint ret;\n\n\tmarvell_nfc_parse_instructions(chip, subop, &nfc_op);\n\n\t \n\tnfc_op.ndcb[0] &= ~(NDCB0_CMD_TYPE(TYPE_MASK) |\n\t\t\t    NDCB0_CMD_XTYPE(XTYPE_MASK));\n\tswitch (subop->instrs[0].type) {\n\tcase NAND_OP_CMD_INSTR:\n\t\tnfc_op.ndcb[0] |= NDCB0_CMD_TYPE(TYPE_NAKED_CMD);\n\t\tbreak;\n\tcase NAND_OP_ADDR_INSTR:\n\t\tnfc_op.ndcb[0] |= NDCB0_CMD_TYPE(TYPE_NAKED_ADDR);\n\t\tbreak;\n\tcase NAND_OP_DATA_IN_INSTR:\n\t\tnfc_op.ndcb[0] |= NDCB0_CMD_TYPE(TYPE_READ) |\n\t\t\t\t  NDCB0_CMD_XTYPE(XTYPE_LAST_NAKED_RW);\n\t\tbreak;\n\tcase NAND_OP_DATA_OUT_INSTR:\n\t\tnfc_op.ndcb[0] |= NDCB0_CMD_TYPE(TYPE_WRITE) |\n\t\t\t\t  NDCB0_CMD_XTYPE(XTYPE_LAST_NAKED_RW);\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tbreak;\n\t}\n\n\tret = marvell_nfc_prepare_cmd(chip);\n\tif (ret)\n\t\treturn ret;\n\n\tmarvell_nfc_send_cmd(chip, &nfc_op);\n\n\tif (!nfc_op.data_instr) {\n\t\tret = marvell_nfc_wait_cmdd(chip);\n\t\tcond_delay(nfc_op.cle_ale_delay_ns);\n\t\treturn ret;\n\t}\n\n\tret = marvell_nfc_end_cmd(chip, NDSR_RDDREQ | NDSR_WRDREQ,\n\t\t\t\t  \"RDDREQ/WRDREQ while draining raw data\");\n\tif (ret)\n\t\treturn ret;\n\n\tmarvell_nfc_xfer_data_pio(chip, subop, &nfc_op);\n\tret = marvell_nfc_wait_cmdd(chip);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (subop->instrs[0].type == NAND_OP_DATA_OUT_INSTR) {\n\t\tstruct marvell_nfc *nfc = to_marvell_nfc(chip->controller);\n\n\t\twritel_relaxed(readl(nfc->regs + NDCR) & ~NDCR_ND_RUN,\n\t\t\t       nfc->regs + NDCR);\n\t}\n\n\treturn 0;\n}\n\nstatic int marvell_nfc_naked_waitrdy_exec(struct nand_chip *chip,\n\t\t\t\t\t  const struct nand_subop *subop)\n{\n\tstruct marvell_nfc_op nfc_op;\n\tint ret;\n\n\tmarvell_nfc_parse_instructions(chip, subop, &nfc_op);\n\n\tret = marvell_nfc_wait_op(chip, nfc_op.rdy_timeout_ms);\n\tcond_delay(nfc_op.rdy_delay_ns);\n\n\treturn ret;\n}\n\nstatic int marvell_nfc_read_id_type_exec(struct nand_chip *chip,\n\t\t\t\t\t const struct nand_subop *subop)\n{\n\tstruct marvell_nfc_op nfc_op;\n\tint ret;\n\n\tmarvell_nfc_parse_instructions(chip, subop, &nfc_op);\n\tnfc_op.ndcb[0] &= ~NDCB0_CMD_TYPE(TYPE_READ);\n\tnfc_op.ndcb[0] |= NDCB0_CMD_TYPE(TYPE_READ_ID);\n\n\tret = marvell_nfc_prepare_cmd(chip);\n\tif (ret)\n\t\treturn ret;\n\n\tmarvell_nfc_send_cmd(chip, &nfc_op);\n\tret = marvell_nfc_end_cmd(chip, NDSR_RDDREQ,\n\t\t\t\t  \"RDDREQ while reading ID\");\n\tif (ret)\n\t\treturn ret;\n\n\tcond_delay(nfc_op.cle_ale_delay_ns);\n\n\tif (nfc_op.rdy_timeout_ms) {\n\t\tret = marvell_nfc_wait_op(chip, nfc_op.rdy_timeout_ms);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tcond_delay(nfc_op.rdy_delay_ns);\n\n\tmarvell_nfc_xfer_data_pio(chip, subop, &nfc_op);\n\tret = marvell_nfc_wait_cmdd(chip);\n\tif (ret)\n\t\treturn ret;\n\n\tcond_delay(nfc_op.data_delay_ns);\n\n\treturn 0;\n}\n\nstatic int marvell_nfc_read_status_exec(struct nand_chip *chip,\n\t\t\t\t\tconst struct nand_subop *subop)\n{\n\tstruct marvell_nfc_op nfc_op;\n\tint ret;\n\n\tmarvell_nfc_parse_instructions(chip, subop, &nfc_op);\n\tnfc_op.ndcb[0] &= ~NDCB0_CMD_TYPE(TYPE_READ);\n\tnfc_op.ndcb[0] |= NDCB0_CMD_TYPE(TYPE_STATUS);\n\n\tret = marvell_nfc_prepare_cmd(chip);\n\tif (ret)\n\t\treturn ret;\n\n\tmarvell_nfc_send_cmd(chip, &nfc_op);\n\tret = marvell_nfc_end_cmd(chip, NDSR_RDDREQ,\n\t\t\t\t  \"RDDREQ while reading status\");\n\tif (ret)\n\t\treturn ret;\n\n\tcond_delay(nfc_op.cle_ale_delay_ns);\n\n\tif (nfc_op.rdy_timeout_ms) {\n\t\tret = marvell_nfc_wait_op(chip, nfc_op.rdy_timeout_ms);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tcond_delay(nfc_op.rdy_delay_ns);\n\n\tmarvell_nfc_xfer_data_pio(chip, subop, &nfc_op);\n\tret = marvell_nfc_wait_cmdd(chip);\n\tif (ret)\n\t\treturn ret;\n\n\tcond_delay(nfc_op.data_delay_ns);\n\n\treturn 0;\n}\n\nstatic int marvell_nfc_reset_cmd_type_exec(struct nand_chip *chip,\n\t\t\t\t\t   const struct nand_subop *subop)\n{\n\tstruct marvell_nfc_op nfc_op;\n\tint ret;\n\n\tmarvell_nfc_parse_instructions(chip, subop, &nfc_op);\n\tnfc_op.ndcb[0] |= NDCB0_CMD_TYPE(TYPE_RESET);\n\n\tret = marvell_nfc_prepare_cmd(chip);\n\tif (ret)\n\t\treturn ret;\n\n\tmarvell_nfc_send_cmd(chip, &nfc_op);\n\tret = marvell_nfc_wait_cmdd(chip);\n\tif (ret)\n\t\treturn ret;\n\n\tcond_delay(nfc_op.cle_ale_delay_ns);\n\n\tret = marvell_nfc_wait_op(chip, nfc_op.rdy_timeout_ms);\n\tif (ret)\n\t\treturn ret;\n\n\tcond_delay(nfc_op.rdy_delay_ns);\n\n\treturn 0;\n}\n\nstatic int marvell_nfc_erase_cmd_type_exec(struct nand_chip *chip,\n\t\t\t\t\t   const struct nand_subop *subop)\n{\n\tstruct marvell_nfc_op nfc_op;\n\tint ret;\n\n\tmarvell_nfc_parse_instructions(chip, subop, &nfc_op);\n\tnfc_op.ndcb[0] |= NDCB0_CMD_TYPE(TYPE_ERASE);\n\n\tret = marvell_nfc_prepare_cmd(chip);\n\tif (ret)\n\t\treturn ret;\n\n\tmarvell_nfc_send_cmd(chip, &nfc_op);\n\tret = marvell_nfc_wait_cmdd(chip);\n\tif (ret)\n\t\treturn ret;\n\n\tcond_delay(nfc_op.cle_ale_delay_ns);\n\n\tret = marvell_nfc_wait_op(chip, nfc_op.rdy_timeout_ms);\n\tif (ret)\n\t\treturn ret;\n\n\tcond_delay(nfc_op.rdy_delay_ns);\n\n\treturn 0;\n}\n\nstatic const struct nand_op_parser marvell_nfcv2_op_parser = NAND_OP_PARSER(\n\t \n\tNAND_OP_PARSER_PATTERN(\n\t\tmarvell_nfc_monolithic_access_exec,\n\t\tNAND_OP_PARSER_PAT_CMD_ELEM(false),\n\t\tNAND_OP_PARSER_PAT_ADDR_ELEM(true, MAX_ADDRESS_CYC_NFCV2),\n\t\tNAND_OP_PARSER_PAT_CMD_ELEM(true),\n\t\tNAND_OP_PARSER_PAT_WAITRDY_ELEM(true),\n\t\tNAND_OP_PARSER_PAT_DATA_IN_ELEM(false, MAX_CHUNK_SIZE)),\n\tNAND_OP_PARSER_PATTERN(\n\t\tmarvell_nfc_monolithic_access_exec,\n\t\tNAND_OP_PARSER_PAT_CMD_ELEM(false),\n\t\tNAND_OP_PARSER_PAT_ADDR_ELEM(false, MAX_ADDRESS_CYC_NFCV2),\n\t\tNAND_OP_PARSER_PAT_DATA_OUT_ELEM(false, MAX_CHUNK_SIZE),\n\t\tNAND_OP_PARSER_PAT_CMD_ELEM(true),\n\t\tNAND_OP_PARSER_PAT_WAITRDY_ELEM(true)),\n\t \n\tNAND_OP_PARSER_PATTERN(\n\t\tmarvell_nfc_naked_access_exec,\n\t\tNAND_OP_PARSER_PAT_CMD_ELEM(false)),\n\tNAND_OP_PARSER_PATTERN(\n\t\tmarvell_nfc_naked_access_exec,\n\t\tNAND_OP_PARSER_PAT_ADDR_ELEM(false, MAX_ADDRESS_CYC_NFCV2)),\n\tNAND_OP_PARSER_PATTERN(\n\t\tmarvell_nfc_naked_access_exec,\n\t\tNAND_OP_PARSER_PAT_DATA_IN_ELEM(false, MAX_CHUNK_SIZE)),\n\tNAND_OP_PARSER_PATTERN(\n\t\tmarvell_nfc_naked_access_exec,\n\t\tNAND_OP_PARSER_PAT_DATA_OUT_ELEM(false, MAX_CHUNK_SIZE)),\n\tNAND_OP_PARSER_PATTERN(\n\t\tmarvell_nfc_naked_waitrdy_exec,\n\t\tNAND_OP_PARSER_PAT_WAITRDY_ELEM(false)),\n\t);\n\nstatic const struct nand_op_parser marvell_nfcv1_op_parser = NAND_OP_PARSER(\n\t \n\tNAND_OP_PARSER_PATTERN(\n\t\tmarvell_nfc_read_id_type_exec,\n\t\tNAND_OP_PARSER_PAT_CMD_ELEM(false),\n\t\tNAND_OP_PARSER_PAT_ADDR_ELEM(false, MAX_ADDRESS_CYC_NFCV1),\n\t\tNAND_OP_PARSER_PAT_DATA_IN_ELEM(false, 8)),\n\tNAND_OP_PARSER_PATTERN(\n\t\tmarvell_nfc_erase_cmd_type_exec,\n\t\tNAND_OP_PARSER_PAT_CMD_ELEM(false),\n\t\tNAND_OP_PARSER_PAT_ADDR_ELEM(false, MAX_ADDRESS_CYC_NFCV1),\n\t\tNAND_OP_PARSER_PAT_CMD_ELEM(false),\n\t\tNAND_OP_PARSER_PAT_WAITRDY_ELEM(false)),\n\tNAND_OP_PARSER_PATTERN(\n\t\tmarvell_nfc_read_status_exec,\n\t\tNAND_OP_PARSER_PAT_CMD_ELEM(false),\n\t\tNAND_OP_PARSER_PAT_DATA_IN_ELEM(false, 1)),\n\tNAND_OP_PARSER_PATTERN(\n\t\tmarvell_nfc_reset_cmd_type_exec,\n\t\tNAND_OP_PARSER_PAT_CMD_ELEM(false),\n\t\tNAND_OP_PARSER_PAT_WAITRDY_ELEM(false)),\n\tNAND_OP_PARSER_PATTERN(\n\t\tmarvell_nfc_naked_waitrdy_exec,\n\t\tNAND_OP_PARSER_PAT_WAITRDY_ELEM(false)),\n\t);\n\nstatic int marvell_nfc_exec_op(struct nand_chip *chip,\n\t\t\t       const struct nand_operation *op,\n\t\t\t       bool check_only)\n{\n\tstruct marvell_nfc *nfc = to_marvell_nfc(chip->controller);\n\n\tif (!check_only)\n\t\tmarvell_nfc_select_target(chip, op->cs);\n\n\tif (nfc->caps->is_nfcv2)\n\t\treturn nand_op_parser_exec_op(chip, &marvell_nfcv2_op_parser,\n\t\t\t\t\t      op, check_only);\n\telse\n\t\treturn nand_op_parser_exec_op(chip, &marvell_nfcv1_op_parser,\n\t\t\t\t\t      op, check_only);\n}\n\n \nstatic int marvell_nand_ooblayout_ecc(struct mtd_info *mtd, int section,\n\t\t\t\t      struct mtd_oob_region *oobregion)\n{\n\tstruct nand_chip *chip = mtd_to_nand(mtd);\n\tconst struct marvell_hw_ecc_layout *lt = to_marvell_nand(chip)->layout;\n\n\tif (section)\n\t\treturn -ERANGE;\n\n\toobregion->length = (lt->full_chunk_cnt * lt->ecc_bytes) +\n\t\t\t    lt->last_ecc_bytes;\n\toobregion->offset = mtd->oobsize - oobregion->length;\n\n\treturn 0;\n}\n\nstatic int marvell_nand_ooblayout_free(struct mtd_info *mtd, int section,\n\t\t\t\t       struct mtd_oob_region *oobregion)\n{\n\tstruct nand_chip *chip = mtd_to_nand(mtd);\n\tconst struct marvell_hw_ecc_layout *lt = to_marvell_nand(chip)->layout;\n\n\tif (section)\n\t\treturn -ERANGE;\n\n\t \n\tif (mtd->writesize == SZ_4K && lt->data_bytes == SZ_2K)\n\t\toobregion->offset = 6;\n\telse\n\t\toobregion->offset = 2;\n\n\toobregion->length = (lt->full_chunk_cnt * lt->spare_bytes) +\n\t\t\t    lt->last_spare_bytes - oobregion->offset;\n\n\treturn 0;\n}\n\nstatic const struct mtd_ooblayout_ops marvell_nand_ooblayout_ops = {\n\t.ecc = marvell_nand_ooblayout_ecc,\n\t.free = marvell_nand_ooblayout_free,\n};\n\nstatic int marvell_nand_hw_ecc_controller_init(struct mtd_info *mtd,\n\t\t\t\t\t       struct nand_ecc_ctrl *ecc)\n{\n\tstruct nand_chip *chip = mtd_to_nand(mtd);\n\tstruct marvell_nfc *nfc = to_marvell_nfc(chip->controller);\n\tconst struct marvell_hw_ecc_layout *l;\n\tint i;\n\n\tif (!nfc->caps->is_nfcv2 &&\n\t    (mtd->writesize + mtd->oobsize > MAX_CHUNK_SIZE)) {\n\t\tdev_err(nfc->dev,\n\t\t\t\"NFCv1: writesize (%d) cannot be bigger than a chunk (%d)\\n\",\n\t\t\tmtd->writesize, MAX_CHUNK_SIZE - mtd->oobsize);\n\t\treturn -ENOTSUPP;\n\t}\n\n\tto_marvell_nand(chip)->layout = NULL;\n\tfor (i = 0; i < ARRAY_SIZE(marvell_nfc_layouts); i++) {\n\t\tl = &marvell_nfc_layouts[i];\n\t\tif (mtd->writesize == l->writesize &&\n\t\t    ecc->size == l->chunk && ecc->strength == l->strength) {\n\t\t\tto_marvell_nand(chip)->layout = l;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!to_marvell_nand(chip)->layout ||\n\t    (!nfc->caps->is_nfcv2 && ecc->strength > 1)) {\n\t\tdev_err(nfc->dev,\n\t\t\t\"ECC strength %d at page size %d is not supported\\n\",\n\t\t\tecc->strength, mtd->writesize);\n\t\treturn -ENOTSUPP;\n\t}\n\n\t \n\tif (l->writesize == 2048 && l->strength == 8) {\n\t\tif (mtd->oobsize < 128) {\n\t\t\tdev_err(nfc->dev, \"Requested layout needs at least 128 OOB bytes\\n\");\n\t\t\treturn -ENOTSUPP;\n\t\t} else {\n\t\t\tchip->bbt_options |= NAND_BBT_NO_OOB_BBM;\n\t\t}\n\t}\n\n\tmtd_set_ooblayout(mtd, &marvell_nand_ooblayout_ops);\n\tecc->steps = l->nchunks;\n\tecc->size = l->data_bytes;\n\n\tif (ecc->strength == 1) {\n\t\tchip->ecc.algo = NAND_ECC_ALGO_HAMMING;\n\t\tecc->read_page_raw = marvell_nfc_hw_ecc_hmg_read_page_raw;\n\t\tecc->read_page = marvell_nfc_hw_ecc_hmg_read_page;\n\t\tecc->read_oob_raw = marvell_nfc_hw_ecc_hmg_read_oob_raw;\n\t\tecc->read_oob = ecc->read_oob_raw;\n\t\tecc->write_page_raw = marvell_nfc_hw_ecc_hmg_write_page_raw;\n\t\tecc->write_page = marvell_nfc_hw_ecc_hmg_write_page;\n\t\tecc->write_oob_raw = marvell_nfc_hw_ecc_hmg_write_oob_raw;\n\t\tecc->write_oob = ecc->write_oob_raw;\n\t} else {\n\t\tchip->ecc.algo = NAND_ECC_ALGO_BCH;\n\t\tecc->strength = 16;\n\t\tecc->read_page_raw = marvell_nfc_hw_ecc_bch_read_page_raw;\n\t\tecc->read_page = marvell_nfc_hw_ecc_bch_read_page;\n\t\tecc->read_oob_raw = marvell_nfc_hw_ecc_bch_read_oob_raw;\n\t\tecc->read_oob = marvell_nfc_hw_ecc_bch_read_oob;\n\t\tecc->write_page_raw = marvell_nfc_hw_ecc_bch_write_page_raw;\n\t\tecc->write_page = marvell_nfc_hw_ecc_bch_write_page;\n\t\tecc->write_oob_raw = marvell_nfc_hw_ecc_bch_write_oob_raw;\n\t\tecc->write_oob = marvell_nfc_hw_ecc_bch_write_oob;\n\t}\n\n\treturn 0;\n}\n\nstatic int marvell_nand_ecc_init(struct mtd_info *mtd,\n\t\t\t\t struct nand_ecc_ctrl *ecc)\n{\n\tstruct nand_chip *chip = mtd_to_nand(mtd);\n\tconst struct nand_ecc_props *requirements =\n\t\tnanddev_get_ecc_requirements(&chip->base);\n\tstruct marvell_nfc *nfc = to_marvell_nfc(chip->controller);\n\tint ret;\n\n\tif (ecc->engine_type != NAND_ECC_ENGINE_TYPE_NONE &&\n\t    (!ecc->size || !ecc->strength)) {\n\t\tif (requirements->step_size && requirements->strength) {\n\t\t\tecc->size = requirements->step_size;\n\t\t\tecc->strength = requirements->strength;\n\t\t} else {\n\t\t\tdev_info(nfc->dev,\n\t\t\t\t \"No minimum ECC strength, using 1b/512B\\n\");\n\t\t\tecc->size = 512;\n\t\t\tecc->strength = 1;\n\t\t}\n\t}\n\n\tswitch (ecc->engine_type) {\n\tcase NAND_ECC_ENGINE_TYPE_ON_HOST:\n\t\tret = marvell_nand_hw_ecc_controller_init(mtd, ecc);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tbreak;\n\tcase NAND_ECC_ENGINE_TYPE_NONE:\n\tcase NAND_ECC_ENGINE_TYPE_SOFT:\n\tcase NAND_ECC_ENGINE_TYPE_ON_DIE:\n\t\tif (!nfc->caps->is_nfcv2 && mtd->writesize != SZ_512 &&\n\t\t    mtd->writesize != SZ_2K) {\n\t\t\tdev_err(nfc->dev, \"NFCv1 cannot write %d bytes pages\\n\",\n\t\t\t\tmtd->writesize);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic u8 bbt_pattern[] = {'M', 'V', 'B', 'b', 't', '0' };\nstatic u8 bbt_mirror_pattern[] = {'1', 't', 'b', 'B', 'V', 'M' };\n\nstatic struct nand_bbt_descr bbt_main_descr = {\n\t.options = NAND_BBT_LASTBLOCK | NAND_BBT_CREATE | NAND_BBT_WRITE |\n\t\t   NAND_BBT_2BIT | NAND_BBT_VERSION,\n\t.offs =\t8,\n\t.len = 6,\n\t.veroffs = 14,\n\t.maxblocks = 8,\t \n\t.pattern = bbt_pattern\n};\n\nstatic struct nand_bbt_descr bbt_mirror_descr = {\n\t.options = NAND_BBT_LASTBLOCK | NAND_BBT_CREATE | NAND_BBT_WRITE |\n\t\t   NAND_BBT_2BIT | NAND_BBT_VERSION,\n\t.offs =\t8,\n\t.len = 6,\n\t.veroffs = 14,\n\t.maxblocks = 8,\t \n\t.pattern = bbt_mirror_pattern\n};\n\nstatic int marvell_nfc_setup_interface(struct nand_chip *chip, int chipnr,\n\t\t\t\t       const struct nand_interface_config *conf)\n{\n\tstruct marvell_nand_chip *marvell_nand = to_marvell_nand(chip);\n\tstruct marvell_nfc *nfc = to_marvell_nfc(chip->controller);\n\tunsigned int period_ns = 1000000000 / clk_get_rate(nfc->core_clk) * 2;\n\tconst struct nand_sdr_timings *sdr;\n\tstruct marvell_nfc_timings nfc_tmg;\n\tint read_delay;\n\n\tsdr = nand_get_sdr_timings(conf);\n\tif (IS_ERR(sdr))\n\t\treturn PTR_ERR(sdr);\n\n\tif (nfc->caps->max_mode_number && nfc->caps->max_mode_number < conf->timings.mode)\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tnfc_tmg.tRP = TO_CYCLES(DIV_ROUND_UP(sdr->tRC_min, 2), period_ns) - 1;\n\tnfc_tmg.tRH = nfc_tmg.tRP;\n\tnfc_tmg.tWP = TO_CYCLES(DIV_ROUND_UP(sdr->tWC_min, 2), period_ns) - 1;\n\tnfc_tmg.tWH = nfc_tmg.tWP;\n\tnfc_tmg.tCS = TO_CYCLES(sdr->tCS_min, period_ns);\n\tnfc_tmg.tCH = TO_CYCLES(sdr->tCH_min, period_ns) - 1;\n\tnfc_tmg.tADL = TO_CYCLES(sdr->tADL_min, period_ns);\n\t \n\tread_delay = sdr->tRC_min >= 30000 ?\n\t\tMIN_RD_DEL_CNT : MIN_RD_DEL_CNT + nfc_tmg.tRH;\n\n\tnfc_tmg.tAR = TO_CYCLES(sdr->tAR_min, period_ns);\n\t \n\tnfc_tmg.tWHR = TO_CYCLES(max_t(int, sdr->tWHR_min, sdr->tCCS_min),\n\t\t\t\t period_ns) - 2;\n\tnfc_tmg.tRHW = TO_CYCLES(max_t(int, sdr->tRHW_min, sdr->tCCS_min),\n\t\t\t\t period_ns);\n\n\t \n\tif (nfc->caps->is_nfcv2) {\n\t\tnfc_tmg.tR = TO_CYCLES(sdr->tWB_max, period_ns);\n\t} else {\n\t\tnfc_tmg.tR = TO_CYCLES64(sdr->tWB_max + sdr->tR_max,\n\t\t\t\t\t period_ns);\n\t\tif (nfc_tmg.tR + 3 > nfc_tmg.tCH)\n\t\t\tnfc_tmg.tR = nfc_tmg.tCH - 3;\n\t\telse\n\t\t\tnfc_tmg.tR = 0;\n\t}\n\n\tif (chipnr < 0)\n\t\treturn 0;\n\n\tmarvell_nand->ndtr0 =\n\t\tNDTR0_TRP(nfc_tmg.tRP) |\n\t\tNDTR0_TRH(nfc_tmg.tRH) |\n\t\tNDTR0_ETRP(nfc_tmg.tRP) |\n\t\tNDTR0_TWP(nfc_tmg.tWP) |\n\t\tNDTR0_TWH(nfc_tmg.tWH) |\n\t\tNDTR0_TCS(nfc_tmg.tCS) |\n\t\tNDTR0_TCH(nfc_tmg.tCH);\n\n\tmarvell_nand->ndtr1 =\n\t\tNDTR1_TAR(nfc_tmg.tAR) |\n\t\tNDTR1_TWHR(nfc_tmg.tWHR) |\n\t\tNDTR1_TR(nfc_tmg.tR);\n\n\tif (nfc->caps->is_nfcv2) {\n\t\tmarvell_nand->ndtr0 |=\n\t\t\tNDTR0_RD_CNT_DEL(read_delay) |\n\t\t\tNDTR0_SELCNTR |\n\t\t\tNDTR0_TADL(nfc_tmg.tADL);\n\n\t\tmarvell_nand->ndtr1 |=\n\t\t\tNDTR1_TRHW(nfc_tmg.tRHW) |\n\t\t\tNDTR1_WAIT_MODE;\n\t}\n\n\t \n\tnfc->selected_chip = NULL;\n\n\treturn 0;\n}\n\nstatic int marvell_nand_attach_chip(struct nand_chip *chip)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tstruct marvell_nand_chip *marvell_nand = to_marvell_nand(chip);\n\tstruct marvell_nfc *nfc = to_marvell_nfc(chip->controller);\n\tstruct pxa3xx_nand_platform_data *pdata = dev_get_platdata(nfc->dev);\n\tint ret;\n\n\tif (pdata && pdata->flash_bbt)\n\t\tchip->bbt_options |= NAND_BBT_USE_FLASH;\n\n\tif (chip->bbt_options & NAND_BBT_USE_FLASH) {\n\t\t \n\t\tchip->bbt_options |= NAND_BBT_NO_OOB_BBM;\n\t\tchip->bbt_td = &bbt_main_descr;\n\t\tchip->bbt_md = &bbt_mirror_descr;\n\t}\n\n\t \n\tmarvell_nand->ndcr = NDCR_PAGE_SZ(mtd->writesize);\n\tif (chip->options & NAND_BUSWIDTH_16)\n\t\tmarvell_nand->ndcr |= NDCR_DWIDTH_M | NDCR_DWIDTH_C;\n\n\t \n\tif (mtd->writesize <= 512) {\n\t\tmarvell_nand->addr_cyc = 1;\n\t} else {\n\t\tmarvell_nand->addr_cyc = 2;\n\t\tmarvell_nand->ndcr |= NDCR_RA_START;\n\t}\n\n\t \n\tif (chip->options & NAND_ROW_ADDR_3)\n\t\tmarvell_nand->addr_cyc += 3;\n\telse\n\t\tmarvell_nand->addr_cyc += 2;\n\n\tif (pdata) {\n\t\tchip->ecc.size = pdata->ecc_step_size;\n\t\tchip->ecc.strength = pdata->ecc_strength;\n\t}\n\n\tret = marvell_nand_ecc_init(mtd, &chip->ecc);\n\tif (ret) {\n\t\tdev_err(nfc->dev, \"ECC init failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (chip->ecc.engine_type == NAND_ECC_ENGINE_TYPE_ON_HOST) {\n\t\t \n\t\tchip->options |= NAND_NO_SUBPAGE_WRITE;\n\t}\n\n\tif (pdata || nfc->caps->legacy_of_bindings) {\n\t\t \n\t\tmtd->name = \"pxa3xx_nand-0\";\n\t} else if (!mtd->name) {\n\t\t \n\t\tmtd->name = devm_kasprintf(nfc->dev, GFP_KERNEL,\n\t\t\t\t\t   \"%s:nand.%d\", dev_name(nfc->dev),\n\t\t\t\t\t   marvell_nand->sels[0].cs);\n\t\tif (!mtd->name) {\n\t\t\tdev_err(nfc->dev, \"Failed to allocate mtd->name\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic const struct nand_controller_ops marvell_nand_controller_ops = {\n\t.attach_chip = marvell_nand_attach_chip,\n\t.exec_op = marvell_nfc_exec_op,\n\t.setup_interface = marvell_nfc_setup_interface,\n};\n\nstatic int marvell_nand_chip_init(struct device *dev, struct marvell_nfc *nfc,\n\t\t\t\t  struct device_node *np)\n{\n\tstruct pxa3xx_nand_platform_data *pdata = dev_get_platdata(dev);\n\tstruct marvell_nand_chip *marvell_nand;\n\tstruct mtd_info *mtd;\n\tstruct nand_chip *chip;\n\tint nsels, ret, i;\n\tu32 cs, rb;\n\n\t \n\tif (pdata || nfc->caps->legacy_of_bindings) {\n\t\tnsels = 1;\n\t} else {\n\t\tnsels = of_property_count_elems_of_size(np, \"reg\", sizeof(u32));\n\t\tif (nsels <= 0) {\n\t\t\tdev_err(dev, \"missing/invalid reg property\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t \n\tmarvell_nand = devm_kzalloc(dev,\n\t\t\t\t    struct_size(marvell_nand, sels, nsels),\n\t\t\t\t    GFP_KERNEL);\n\tif (!marvell_nand) {\n\t\tdev_err(dev, \"could not allocate chip structure\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tmarvell_nand->nsels = nsels;\n\tmarvell_nand->selected_die = -1;\n\n\tfor (i = 0; i < nsels; i++) {\n\t\tif (pdata || nfc->caps->legacy_of_bindings) {\n\t\t\t \n\t\t\tcs = i;\n\t\t} else {\n\t\t\t \n\t\t\tret = of_property_read_u32_index(np, \"reg\", i, &cs);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(dev, \"could not retrieve reg property: %d\\n\",\n\t\t\t\t\tret);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\n\t\tif (cs >= nfc->caps->max_cs_nb) {\n\t\t\tdev_err(dev, \"invalid reg value: %u (max CS = %d)\\n\",\n\t\t\t\tcs, nfc->caps->max_cs_nb);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (test_and_set_bit(cs, &nfc->assigned_cs)) {\n\t\t\tdev_err(dev, \"CS %d already assigned\\n\", cs);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\tmarvell_nand->sels[i].cs = cs;\n\t\tswitch (cs) {\n\t\tcase 0:\n\t\tcase 2:\n\t\t\tmarvell_nand->sels[i].ndcb0_csel = 0;\n\t\t\tbreak;\n\t\tcase 1:\n\t\tcase 3:\n\t\t\tmarvell_nand->sels[i].ndcb0_csel = NDCB0_CSEL;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\tif (pdata || nfc->caps->legacy_of_bindings) {\n\t\t\t \n\t\t\trb = 0;\n\t\t} else {\n\t\t\tret = of_property_read_u32_index(np, \"nand-rb\", i,\n\t\t\t\t\t\t\t &rb);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(dev,\n\t\t\t\t\t\"could not retrieve RB property: %d\\n\",\n\t\t\t\t\tret);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\n\t\tif (rb >= nfc->caps->max_rb_nb) {\n\t\t\tdev_err(dev, \"invalid reg value: %u (max RB = %d)\\n\",\n\t\t\t\trb, nfc->caps->max_rb_nb);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tmarvell_nand->sels[i].rb = rb;\n\t}\n\n\tchip = &marvell_nand->chip;\n\tchip->controller = &nfc->controller;\n\tnand_set_flash_node(chip, np);\n\n\tif (of_property_read_bool(np, \"marvell,nand-keep-config\"))\n\t\tchip->options |= NAND_KEEP_TIMINGS;\n\n\tmtd = nand_to_mtd(chip);\n\tmtd->dev.parent = dev;\n\n\t \n\tmarvell_nand->ndtr0 = readl_relaxed(nfc->regs + NDTR0);\n\tmarvell_nand->ndtr1 = readl_relaxed(nfc->regs + NDTR1);\n\n\tchip->options |= NAND_BUSWIDTH_AUTO;\n\n\tret = nand_scan(chip, marvell_nand->nsels);\n\tif (ret) {\n\t\tdev_err(dev, \"could not scan the nand chip\\n\");\n\t\treturn ret;\n\t}\n\n\tif (pdata)\n\t\t \n\t\tret = mtd_device_register(mtd, pdata->parts, pdata->nr_parts);\n\telse\n\t\tret = mtd_device_register(mtd, NULL, 0);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to register mtd device: %d\\n\", ret);\n\t\tnand_cleanup(chip);\n\t\treturn ret;\n\t}\n\n\tlist_add_tail(&marvell_nand->node, &nfc->chips);\n\n\treturn 0;\n}\n\nstatic void marvell_nand_chips_cleanup(struct marvell_nfc *nfc)\n{\n\tstruct marvell_nand_chip *entry, *temp;\n\tstruct nand_chip *chip;\n\tint ret;\n\n\tlist_for_each_entry_safe(entry, temp, &nfc->chips, node) {\n\t\tchip = &entry->chip;\n\t\tret = mtd_device_unregister(nand_to_mtd(chip));\n\t\tWARN_ON(ret);\n\t\tnand_cleanup(chip);\n\t\tlist_del(&entry->node);\n\t}\n}\n\nstatic int marvell_nand_chips_init(struct device *dev, struct marvell_nfc *nfc)\n{\n\tstruct device_node *np = dev->of_node;\n\tstruct device_node *nand_np;\n\tint max_cs = nfc->caps->max_cs_nb;\n\tint nchips;\n\tint ret;\n\n\tif (!np)\n\t\tnchips = 1;\n\telse\n\t\tnchips = of_get_child_count(np);\n\n\tif (nchips > max_cs) {\n\t\tdev_err(dev, \"too many NAND chips: %d (max = %d CS)\\n\", nchips,\n\t\t\tmax_cs);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (nfc->caps->legacy_of_bindings) {\n\t\tret = marvell_nand_chip_init(dev, nfc, np);\n\t\treturn ret;\n\t}\n\n\tfor_each_child_of_node(np, nand_np) {\n\t\tret = marvell_nand_chip_init(dev, nfc, nand_np);\n\t\tif (ret) {\n\t\t\tof_node_put(nand_np);\n\t\t\tgoto cleanup_chips;\n\t\t}\n\t}\n\n\treturn 0;\n\ncleanup_chips:\n\tmarvell_nand_chips_cleanup(nfc);\n\n\treturn ret;\n}\n\nstatic int marvell_nfc_init_dma(struct marvell_nfc *nfc)\n{\n\tstruct platform_device *pdev = container_of(nfc->dev,\n\t\t\t\t\t\t    struct platform_device,\n\t\t\t\t\t\t    dev);\n\tstruct dma_slave_config config = {};\n\tstruct resource *r;\n\tint ret;\n\n\tif (!IS_ENABLED(CONFIG_PXA_DMA)) {\n\t\tdev_warn(nfc->dev,\n\t\t\t \"DMA not enabled in configuration\\n\");\n\t\treturn -ENOTSUPP;\n\t}\n\n\tret = dma_set_mask_and_coherent(nfc->dev, DMA_BIT_MASK(32));\n\tif (ret)\n\t\treturn ret;\n\n\tnfc->dma_chan =\tdma_request_chan(nfc->dev, \"data\");\n\tif (IS_ERR(nfc->dma_chan)) {\n\t\tret = PTR_ERR(nfc->dma_chan);\n\t\tnfc->dma_chan = NULL;\n\t\treturn dev_err_probe(nfc->dev, ret, \"DMA channel request failed\\n\");\n\t}\n\n\tr = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!r) {\n\t\tret = -ENXIO;\n\t\tgoto release_channel;\n\t}\n\n\tconfig.src_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;\n\tconfig.dst_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;\n\tconfig.src_addr = r->start + NDDB;\n\tconfig.dst_addr = r->start + NDDB;\n\tconfig.src_maxburst = 32;\n\tconfig.dst_maxburst = 32;\n\tret = dmaengine_slave_config(nfc->dma_chan, &config);\n\tif (ret < 0) {\n\t\tdev_err(nfc->dev, \"Failed to configure DMA channel\\n\");\n\t\tgoto release_channel;\n\t}\n\n\t \n\tnfc->dma_buf = kmalloc(MAX_CHUNK_SIZE, GFP_KERNEL | GFP_DMA);\n\tif (!nfc->dma_buf) {\n\t\tret = -ENOMEM;\n\t\tgoto release_channel;\n\t}\n\n\tnfc->use_dma = true;\n\n\treturn 0;\n\nrelease_channel:\n\tdma_release_channel(nfc->dma_chan);\n\tnfc->dma_chan = NULL;\n\n\treturn ret;\n}\n\nstatic void marvell_nfc_reset(struct marvell_nfc *nfc)\n{\n\t \n\twritel_relaxed(NDCR_ALL_INT | NDCR_ND_ARB_EN | NDCR_SPARE_EN |\n\t\t       NDCR_RD_ID_CNT(NFCV1_READID_LEN), nfc->regs + NDCR);\n\twritel_relaxed(0xFFFFFFFF, nfc->regs + NDSR);\n\twritel_relaxed(0, nfc->regs + NDECCCTRL);\n}\n\nstatic int marvell_nfc_init(struct marvell_nfc *nfc)\n{\n\tstruct device_node *np = nfc->dev->of_node;\n\n\t \n\tif (nfc->caps->need_system_controller) {\n\t\tstruct regmap *sysctrl_base =\n\t\t\tsyscon_regmap_lookup_by_phandle(np,\n\t\t\t\t\t\t\t\"marvell,system-controller\");\n\n\t\tif (IS_ERR(sysctrl_base))\n\t\t\treturn PTR_ERR(sysctrl_base);\n\n\t\tregmap_write(sysctrl_base, GENCONF_SOC_DEVICE_MUX,\n\t\t\t     GENCONF_SOC_DEVICE_MUX_NFC_EN |\n\t\t\t     GENCONF_SOC_DEVICE_MUX_ECC_CLK_RST |\n\t\t\t     GENCONF_SOC_DEVICE_MUX_ECC_CORE_RST |\n\t\t\t     GENCONF_SOC_DEVICE_MUX_NFC_INT_EN |\n\t\t\t     GENCONF_SOC_DEVICE_MUX_NFC_DEVBUS_ARB_EN);\n\n\t\tregmap_update_bits(sysctrl_base, GENCONF_CLK_GATING_CTRL,\n\t\t\t\t   GENCONF_CLK_GATING_CTRL_ND_GATE,\n\t\t\t\t   GENCONF_CLK_GATING_CTRL_ND_GATE);\n\t}\n\n\t \n\tif (!nfc->caps->is_nfcv2)\n\t\tmarvell_nfc_init_dma(nfc);\n\n\tmarvell_nfc_reset(nfc);\n\n\treturn 0;\n}\n\nstatic int marvell_nfc_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct marvell_nfc *nfc;\n\tint ret;\n\tint irq;\n\n\tnfc = devm_kzalloc(&pdev->dev, sizeof(struct marvell_nfc),\n\t\t\t   GFP_KERNEL);\n\tif (!nfc)\n\t\treturn -ENOMEM;\n\n\tnfc->dev = dev;\n\tnand_controller_init(&nfc->controller);\n\tnfc->controller.ops = &marvell_nand_controller_ops;\n\tINIT_LIST_HEAD(&nfc->chips);\n\n\tnfc->regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(nfc->regs))\n\t\treturn PTR_ERR(nfc->regs);\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tnfc->core_clk = devm_clk_get(&pdev->dev, \"core\");\n\n\t \n\tif (nfc->core_clk == ERR_PTR(-ENOENT))\n\t\tnfc->core_clk = devm_clk_get(&pdev->dev, NULL);\n\n\tif (IS_ERR(nfc->core_clk))\n\t\treturn PTR_ERR(nfc->core_clk);\n\n\tret = clk_prepare_enable(nfc->core_clk);\n\tif (ret)\n\t\treturn ret;\n\n\tnfc->reg_clk = devm_clk_get(&pdev->dev, \"reg\");\n\tif (IS_ERR(nfc->reg_clk)) {\n\t\tif (PTR_ERR(nfc->reg_clk) != -ENOENT) {\n\t\t\tret = PTR_ERR(nfc->reg_clk);\n\t\t\tgoto unprepare_core_clk;\n\t\t}\n\n\t\tnfc->reg_clk = NULL;\n\t}\n\n\tret = clk_prepare_enable(nfc->reg_clk);\n\tif (ret)\n\t\tgoto unprepare_core_clk;\n\n\tmarvell_nfc_disable_int(nfc, NDCR_ALL_INT);\n\tmarvell_nfc_clear_int(nfc, NDCR_ALL_INT);\n\tret = devm_request_irq(dev, irq, marvell_nfc_isr,\n\t\t\t       0, \"marvell-nfc\", nfc);\n\tif (ret)\n\t\tgoto unprepare_reg_clk;\n\n\t \n\tif (pdev->id_entry)\n\t\tnfc->caps = (void *)pdev->id_entry->driver_data;\n\telse\n\t\tnfc->caps = of_device_get_match_data(&pdev->dev);\n\n\tif (!nfc->caps) {\n\t\tdev_err(dev, \"Could not retrieve NFC caps\\n\");\n\t\tret = -EINVAL;\n\t\tgoto unprepare_reg_clk;\n\t}\n\n\t \n\tret = marvell_nfc_init(nfc);\n\tif (ret)\n\t\tgoto unprepare_reg_clk;\n\n\tplatform_set_drvdata(pdev, nfc);\n\n\tret = marvell_nand_chips_init(dev, nfc);\n\tif (ret)\n\t\tgoto release_dma;\n\n\treturn 0;\n\nrelease_dma:\n\tif (nfc->use_dma)\n\t\tdma_release_channel(nfc->dma_chan);\nunprepare_reg_clk:\n\tclk_disable_unprepare(nfc->reg_clk);\nunprepare_core_clk:\n\tclk_disable_unprepare(nfc->core_clk);\n\n\treturn ret;\n}\n\nstatic void marvell_nfc_remove(struct platform_device *pdev)\n{\n\tstruct marvell_nfc *nfc = platform_get_drvdata(pdev);\n\n\tmarvell_nand_chips_cleanup(nfc);\n\n\tif (nfc->use_dma) {\n\t\tdmaengine_terminate_all(nfc->dma_chan);\n\t\tdma_release_channel(nfc->dma_chan);\n\t}\n\n\tclk_disable_unprepare(nfc->reg_clk);\n\tclk_disable_unprepare(nfc->core_clk);\n}\n\nstatic int __maybe_unused marvell_nfc_suspend(struct device *dev)\n{\n\tstruct marvell_nfc *nfc = dev_get_drvdata(dev);\n\tstruct marvell_nand_chip *chip;\n\n\tlist_for_each_entry(chip, &nfc->chips, node)\n\t\tmarvell_nfc_wait_ndrun(&chip->chip);\n\n\tclk_disable_unprepare(nfc->reg_clk);\n\tclk_disable_unprepare(nfc->core_clk);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused marvell_nfc_resume(struct device *dev)\n{\n\tstruct marvell_nfc *nfc = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = clk_prepare_enable(nfc->core_clk);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = clk_prepare_enable(nfc->reg_clk);\n\tif (ret < 0) {\n\t\tclk_disable_unprepare(nfc->core_clk);\n\t\treturn ret;\n\t}\n\n\t \n\tnfc->selected_chip = NULL;\n\n\t \n\tmarvell_nfc_reset(nfc);\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops marvell_nfc_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(marvell_nfc_suspend, marvell_nfc_resume)\n};\n\nstatic const struct marvell_nfc_caps marvell_armada_8k_nfc_caps = {\n\t.max_cs_nb = 4,\n\t.max_rb_nb = 2,\n\t.need_system_controller = true,\n\t.is_nfcv2 = true,\n};\n\nstatic const struct marvell_nfc_caps marvell_ac5_caps = {\n\t.max_cs_nb = 2,\n\t.max_rb_nb = 1,\n\t.is_nfcv2 = true,\n\t.max_mode_number = 3,\n};\n\nstatic const struct marvell_nfc_caps marvell_armada370_nfc_caps = {\n\t.max_cs_nb = 4,\n\t.max_rb_nb = 2,\n\t.is_nfcv2 = true,\n};\n\nstatic const struct marvell_nfc_caps marvell_pxa3xx_nfc_caps = {\n\t.max_cs_nb = 2,\n\t.max_rb_nb = 1,\n\t.use_dma = true,\n};\n\nstatic const struct marvell_nfc_caps marvell_armada_8k_nfc_legacy_caps = {\n\t.max_cs_nb = 4,\n\t.max_rb_nb = 2,\n\t.need_system_controller = true,\n\t.legacy_of_bindings = true,\n\t.is_nfcv2 = true,\n};\n\nstatic const struct marvell_nfc_caps marvell_armada370_nfc_legacy_caps = {\n\t.max_cs_nb = 4,\n\t.max_rb_nb = 2,\n\t.legacy_of_bindings = true,\n\t.is_nfcv2 = true,\n};\n\nstatic const struct marvell_nfc_caps marvell_pxa3xx_nfc_legacy_caps = {\n\t.max_cs_nb = 2,\n\t.max_rb_nb = 1,\n\t.legacy_of_bindings = true,\n\t.use_dma = true,\n};\n\nstatic const struct platform_device_id marvell_nfc_platform_ids[] = {\n\t{\n\t\t.name = \"pxa3xx-nand\",\n\t\t.driver_data = (kernel_ulong_t)&marvell_pxa3xx_nfc_legacy_caps,\n\t},\n\t{   },\n};\nMODULE_DEVICE_TABLE(platform, marvell_nfc_platform_ids);\n\nstatic const struct of_device_id marvell_nfc_of_ids[] = {\n\t{\n\t\t.compatible = \"marvell,armada-8k-nand-controller\",\n\t\t.data = &marvell_armada_8k_nfc_caps,\n\t},\n\t{\n\t\t.compatible = \"marvell,ac5-nand-controller\",\n\t\t.data = &marvell_ac5_caps,\n\t},\n\t{\n\t\t.compatible = \"marvell,armada370-nand-controller\",\n\t\t.data = &marvell_armada370_nfc_caps,\n\t},\n\t{\n\t\t.compatible = \"marvell,pxa3xx-nand-controller\",\n\t\t.data = &marvell_pxa3xx_nfc_caps,\n\t},\n\t \n\t{\n\t\t.compatible = \"marvell,armada-8k-nand\",\n\t\t.data = &marvell_armada_8k_nfc_legacy_caps,\n\t},\n\t{\n\t\t.compatible = \"marvell,armada370-nand\",\n\t\t.data = &marvell_armada370_nfc_legacy_caps,\n\t},\n\t{\n\t\t.compatible = \"marvell,pxa3xx-nand\",\n\t\t.data = &marvell_pxa3xx_nfc_legacy_caps,\n\t},\n\t{   },\n};\nMODULE_DEVICE_TABLE(of, marvell_nfc_of_ids);\n\nstatic struct platform_driver marvell_nfc_driver = {\n\t.driver\t= {\n\t\t.name\t\t= \"marvell-nfc\",\n\t\t.of_match_table = marvell_nfc_of_ids,\n\t\t.pm\t\t= &marvell_nfc_pm_ops,\n\t},\n\t.id_table = marvell_nfc_platform_ids,\n\t.probe = marvell_nfc_probe,\n\t.remove_new = marvell_nfc_remove,\n};\nmodule_platform_driver(marvell_nfc_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"Marvell NAND controller driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}