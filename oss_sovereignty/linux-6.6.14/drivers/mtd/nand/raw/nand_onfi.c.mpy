{
  "module_name": "nand_onfi.c",
  "hash_id": "d81e98d7699344e7aa64dd6834b0e0b70ede85084a02aa0fca19b369da3c0a88",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/nand/raw/nand_onfi.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n\n#include \"internals.h\"\n\n#define ONFI_PARAM_PAGES 3\n\nu16 onfi_crc16(u16 crc, u8 const *p, size_t len)\n{\n\tint i;\n\twhile (len--) {\n\t\tcrc ^= *p++ << 8;\n\t\tfor (i = 0; i < 8; i++)\n\t\t\tcrc = (crc << 1) ^ ((crc & 0x8000) ? 0x8005 : 0);\n\t}\n\n\treturn crc;\n}\n\n \nstatic int nand_flash_detect_ext_param_page(struct nand_chip *chip,\n\t\t\t\t\t    struct nand_onfi_params *p)\n{\n\tstruct nand_device *base = &chip->base;\n\tstruct nand_ecc_props requirements;\n\tstruct onfi_ext_param_page *ep;\n\tstruct onfi_ext_section *s;\n\tstruct onfi_ext_ecc_info *ecc;\n\tuint8_t *cursor;\n\tint ret;\n\tint len;\n\tint i;\n\n\tlen = le16_to_cpu(p->ext_param_page_length) * 16;\n\tep = kmalloc(len, GFP_KERNEL);\n\tif (!ep)\n\t\treturn -ENOMEM;\n\n\t \n\tret = nand_change_read_column_op(chip,\n\t\t\t\t\t sizeof(*p) * p->num_of_param_pages,\n\t\t\t\t\t ep, len, true);\n\tif (ret)\n\t\tgoto ext_out;\n\n\tret = -EINVAL;\n\tif ((onfi_crc16(ONFI_CRC_BASE, ((uint8_t *)ep) + 2, len - 2)\n\t\t!= le16_to_cpu(ep->crc))) {\n\t\tpr_debug(\"fail in the CRC.\\n\");\n\t\tgoto ext_out;\n\t}\n\n\t \n\tif (strncmp(ep->sig, \"EPPS\", 4)) {\n\t\tpr_debug(\"The signature is invalid.\\n\");\n\t\tgoto ext_out;\n\t}\n\n\t \n\tcursor = (uint8_t *)(ep + 1);\n\tfor (i = 0; i < ONFI_EXT_SECTION_MAX; i++) {\n\t\ts = ep->sections + i;\n\t\tif (s->type == ONFI_SECTION_TYPE_2)\n\t\t\tbreak;\n\t\tcursor += s->length * 16;\n\t}\n\tif (i == ONFI_EXT_SECTION_MAX) {\n\t\tpr_debug(\"We can not find the ECC section.\\n\");\n\t\tgoto ext_out;\n\t}\n\n\t \n\tecc = (struct onfi_ext_ecc_info *)cursor;\n\n\tif (!ecc->codeword_size) {\n\t\tpr_debug(\"Invalid codeword size\\n\");\n\t\tgoto ext_out;\n\t}\n\n\trequirements.strength = ecc->ecc_bits;\n\trequirements.step_size = 1 << ecc->codeword_size;\n\tnanddev_set_ecc_requirements(base, &requirements);\n\n\tret = 0;\n\next_out:\n\tkfree(ep);\n\treturn ret;\n}\n\n \nstatic void nand_bit_wise_majority(const void **srcbufs,\n\t\t\t\t   unsigned int nsrcbufs,\n\t\t\t\t   void *dstbuf,\n\t\t\t\t   unsigned int bufsize)\n{\n\tint i, j, k;\n\n\tfor (i = 0; i < bufsize; i++) {\n\t\tu8 val = 0;\n\n\t\tfor (j = 0; j < 8; j++) {\n\t\t\tunsigned int cnt = 0;\n\n\t\t\tfor (k = 0; k < nsrcbufs; k++) {\n\t\t\t\tconst u8 *srcbuf = srcbufs[k];\n\n\t\t\t\tif (srcbuf[i] & BIT(j))\n\t\t\t\t\tcnt++;\n\t\t\t}\n\n\t\t\tif (cnt > nsrcbufs / 2)\n\t\t\t\tval |= BIT(j);\n\t\t}\n\n\t\t((u8 *)dstbuf)[i] = val;\n\t}\n}\n\n \nint nand_onfi_detect(struct nand_chip *chip)\n{\n\tstruct nand_device *base = &chip->base;\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tstruct nand_memory_organization *memorg;\n\tstruct nand_onfi_params *p = NULL, *pbuf;\n\tstruct onfi_params *onfi;\n\tbool use_datain = false;\n\tint onfi_version = 0;\n\tchar id[4];\n\tint i, ret, val;\n\tu16 crc;\n\n\tmemorg = nanddev_get_memorg(&chip->base);\n\n\t \n\tret = nand_readid_op(chip, 0x20, id, sizeof(id));\n\tif (ret || strncmp(id, \"ONFI\", 4))\n\t\treturn 0;\n\n\t \n\tpbuf = kzalloc((sizeof(*pbuf) * ONFI_PARAM_PAGES), GFP_KERNEL);\n\tif (!pbuf)\n\t\treturn -ENOMEM;\n\n\tif (!nand_has_exec_op(chip) || chip->controller->supported_op.data_only_read)\n\t\tuse_datain = true;\n\n\tfor (i = 0; i < ONFI_PARAM_PAGES; i++) {\n\t\tif (!i)\n\t\t\tret = nand_read_param_page_op(chip, 0, &pbuf[i],\n\t\t\t\t\t\t      sizeof(*pbuf));\n\t\telse if (use_datain)\n\t\t\tret = nand_read_data_op(chip, &pbuf[i], sizeof(*pbuf),\n\t\t\t\t\t\ttrue, false);\n\t\telse\n\t\t\tret = nand_change_read_column_op(chip, sizeof(*pbuf) * i,\n\t\t\t\t\t\t\t &pbuf[i], sizeof(*pbuf),\n\t\t\t\t\t\t\t true);\n\t\tif (ret) {\n\t\t\tret = 0;\n\t\t\tgoto free_onfi_param_page;\n\t\t}\n\n\t\tcrc = onfi_crc16(ONFI_CRC_BASE, (u8 *)&pbuf[i], 254);\n\t\tif (crc == le16_to_cpu(pbuf[i].crc)) {\n\t\t\tp = &pbuf[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (i == ONFI_PARAM_PAGES) {\n\t\tconst void *srcbufs[ONFI_PARAM_PAGES];\n\t\tunsigned int j;\n\n\t\tfor (j = 0; j < ONFI_PARAM_PAGES; j++)\n\t\t\tsrcbufs[j] = pbuf + j;\n\n\t\tpr_warn(\"Could not find a valid ONFI parameter page, trying bit-wise majority to recover it\\n\");\n\t\tnand_bit_wise_majority(srcbufs, ONFI_PARAM_PAGES, pbuf,\n\t\t\t\t       sizeof(*pbuf));\n\n\t\tcrc = onfi_crc16(ONFI_CRC_BASE, (u8 *)pbuf, 254);\n\t\tif (crc != le16_to_cpu(pbuf->crc)) {\n\t\t\tpr_err(\"ONFI parameter recovery failed, aborting\\n\");\n\t\t\tgoto free_onfi_param_page;\n\t\t}\n\t\tp = pbuf;\n\t}\n\n\tif (chip->manufacturer.desc && chip->manufacturer.desc->ops &&\n\t    chip->manufacturer.desc->ops->fixup_onfi_param_page)\n\t\tchip->manufacturer.desc->ops->fixup_onfi_param_page(chip, p);\n\n\t \n\tval = le16_to_cpu(p->revision);\n\tif (val & ONFI_VERSION_2_3)\n\t\tonfi_version = 23;\n\telse if (val & ONFI_VERSION_2_2)\n\t\tonfi_version = 22;\n\telse if (val & ONFI_VERSION_2_1)\n\t\tonfi_version = 21;\n\telse if (val & ONFI_VERSION_2_0)\n\t\tonfi_version = 20;\n\telse if (val & ONFI_VERSION_1_0)\n\t\tonfi_version = 10;\n\n\tif (!onfi_version) {\n\t\tpr_info(\"unsupported ONFI version: %d\\n\", val);\n\t\tgoto free_onfi_param_page;\n\t}\n\n\tsanitize_string(p->manufacturer, sizeof(p->manufacturer));\n\tsanitize_string(p->model, sizeof(p->model));\n\tchip->parameters.model = kstrdup(p->model, GFP_KERNEL);\n\tif (!chip->parameters.model) {\n\t\tret = -ENOMEM;\n\t\tgoto free_onfi_param_page;\n\t}\n\n\tmemorg->pagesize = le32_to_cpu(p->byte_per_page);\n\tmtd->writesize = memorg->pagesize;\n\n\t \n\tmemorg->pages_per_eraseblock =\n\t\t\t1 << (fls(le32_to_cpu(p->pages_per_block)) - 1);\n\tmtd->erasesize = memorg->pages_per_eraseblock * memorg->pagesize;\n\n\tmemorg->oobsize = le16_to_cpu(p->spare_bytes_per_page);\n\tmtd->oobsize = memorg->oobsize;\n\n\tmemorg->luns_per_target = p->lun_count;\n\tmemorg->planes_per_lun = 1 << p->interleaved_bits;\n\n\t \n\tmemorg->eraseblocks_per_lun =\n\t\t1 << (fls(le32_to_cpu(p->blocks_per_lun)) - 1);\n\tmemorg->max_bad_eraseblocks_per_lun = le32_to_cpu(p->blocks_per_lun);\n\tmemorg->bits_per_cell = p->bits_per_cell;\n\n\tif (le16_to_cpu(p->features) & ONFI_FEATURE_16_BIT_BUS)\n\t\tchip->options |= NAND_BUSWIDTH_16;\n\n\tif (p->ecc_bits != 0xff) {\n\t\tstruct nand_ecc_props requirements = {\n\t\t\t.strength = p->ecc_bits,\n\t\t\t.step_size = 512,\n\t\t};\n\n\t\tnanddev_set_ecc_requirements(base, &requirements);\n\t} else if (onfi_version >= 21 &&\n\t\t(le16_to_cpu(p->features) & ONFI_FEATURE_EXT_PARAM_PAGE)) {\n\n\t\t \n\t\tnand_legacy_adjust_cmdfunc(chip);\n\n\t\t \n\t\tif (nand_flash_detect_ext_param_page(chip, p))\n\t\t\tpr_warn(\"Failed to detect ONFI extended param page\\n\");\n\t} else {\n\t\tpr_warn(\"Could not retrieve ONFI ECC requirements\\n\");\n\t}\n\n\t \n\tif (le16_to_cpu(p->opt_cmd) & ONFI_OPT_CMD_SET_GET_FEATURES) {\n\t\tchip->parameters.supports_set_get_features = true;\n\t\tbitmap_set(chip->parameters.get_feature_list,\n\t\t\t   ONFI_FEATURE_ADDR_TIMING_MODE, 1);\n\t\tbitmap_set(chip->parameters.set_feature_list,\n\t\t\t   ONFI_FEATURE_ADDR_TIMING_MODE, 1);\n\t}\n\n\tif (le16_to_cpu(p->opt_cmd) & ONFI_OPT_CMD_READ_CACHE)\n\t\tchip->parameters.supports_read_cache = true;\n\n\tonfi = kzalloc(sizeof(*onfi), GFP_KERNEL);\n\tif (!onfi) {\n\t\tret = -ENOMEM;\n\t\tgoto free_model;\n\t}\n\n\tonfi->version = onfi_version;\n\tonfi->tPROG = le16_to_cpu(p->t_prog);\n\tonfi->tBERS = le16_to_cpu(p->t_bers);\n\tonfi->tR = le16_to_cpu(p->t_r);\n\tonfi->tCCS = le16_to_cpu(p->t_ccs);\n\tonfi->fast_tCAD = le16_to_cpu(p->nvddr_nvddr2_features) & BIT(0);\n\tonfi->sdr_timing_modes = le16_to_cpu(p->sdr_timing_modes);\n\tif (le16_to_cpu(p->features) & ONFI_FEATURE_NV_DDR)\n\t\tonfi->nvddr_timing_modes = le16_to_cpu(p->nvddr_timing_modes);\n\tonfi->vendor_revision = le16_to_cpu(p->vendor_revision);\n\tmemcpy(onfi->vendor, p->vendor, sizeof(p->vendor));\n\tchip->parameters.onfi = onfi;\n\n\t \n\tkfree(pbuf);\n\n\treturn 1;\n\nfree_model:\n\tkfree(chip->parameters.model);\nfree_onfi_param_page:\n\tkfree(pbuf);\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}