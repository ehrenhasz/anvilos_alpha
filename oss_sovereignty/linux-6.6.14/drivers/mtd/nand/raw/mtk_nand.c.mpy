{
  "module_name": "mtk_nand.c",
  "hash_id": "37b1efdf244700de5983d6a9003c25503871d47c95384c9f50cea70858abc1f1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/nand/raw/mtk_nand.c",
  "human_readable_source": "\n \n\n#include <linux/platform_device.h>\n#include <linux/dma-mapping.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n#include <linux/clk.h>\n#include <linux/mtd/rawnand.h>\n#include <linux/mtd/mtd.h>\n#include <linux/module.h>\n#include <linux/iopoll.h>\n#include <linux/of.h>\n#include <linux/mtd/nand-ecc-mtk.h>\n\n \n#define NFI_CNFG\t\t(0x00)\n#define\t\tCNFG_AHB\t\tBIT(0)\n#define\t\tCNFG_READ_EN\t\tBIT(1)\n#define\t\tCNFG_DMA_BURST_EN\tBIT(2)\n#define\t\tCNFG_BYTE_RW\t\tBIT(6)\n#define\t\tCNFG_HW_ECC_EN\t\tBIT(8)\n#define\t\tCNFG_AUTO_FMT_EN\tBIT(9)\n#define\t\tCNFG_OP_CUST\t\t(6 << 12)\n#define NFI_PAGEFMT\t\t(0x04)\n#define\t\tPAGEFMT_FDM_ECC_SHIFT\t(12)\n#define\t\tPAGEFMT_FDM_SHIFT\t(8)\n#define\t\tPAGEFMT_SEC_SEL_512\tBIT(2)\n#define\t\tPAGEFMT_512_2K\t\t(0)\n#define\t\tPAGEFMT_2K_4K\t\t(1)\n#define\t\tPAGEFMT_4K_8K\t\t(2)\n#define\t\tPAGEFMT_8K_16K\t\t(3)\n \n#define NFI_CON\t\t\t(0x08)\n#define\t\tCON_FIFO_FLUSH\t\tBIT(0)\n#define\t\tCON_NFI_RST\t\tBIT(1)\n#define\t\tCON_BRD\t\t\tBIT(8)   \n#define\t\tCON_BWR\t\t\tBIT(9)\t \n#define\t\tCON_SEC_SHIFT\t\t(12)\n \n#define NFI_ACCCON\t\t(0x0C)\n#define NFI_INTR_EN\t\t(0x10)\n#define\t\tINTR_AHB_DONE_EN\tBIT(6)\n#define NFI_INTR_STA\t\t(0x14)\n#define NFI_CMD\t\t\t(0x20)\n#define NFI_ADDRNOB\t\t(0x30)\n#define NFI_COLADDR\t\t(0x34)\n#define NFI_ROWADDR\t\t(0x38)\n#define NFI_STRDATA\t\t(0x40)\n#define\t\tSTAR_EN\t\t\t(1)\n#define\t\tSTAR_DE\t\t\t(0)\n#define NFI_CNRNB\t\t(0x44)\n#define NFI_DATAW\t\t(0x50)\n#define NFI_DATAR\t\t(0x54)\n#define NFI_PIO_DIRDY\t\t(0x58)\n#define\t\tPIO_DI_RDY\t\t(0x01)\n#define NFI_STA\t\t\t(0x60)\n#define\t\tSTA_CMD\t\t\tBIT(0)\n#define\t\tSTA_ADDR\t\tBIT(1)\n#define\t\tSTA_BUSY\t\tBIT(8)\n#define\t\tSTA_EMP_PAGE\t\tBIT(12)\n#define\t\tNFI_FSM_CUSTDATA\t(0xe << 16)\n#define\t\tNFI_FSM_MASK\t\t(0xf << 16)\n#define NFI_ADDRCNTR\t\t(0x70)\n#define\t\tCNTR_MASK\t\tGENMASK(16, 12)\n#define\t\tADDRCNTR_SEC_SHIFT\t(12)\n#define\t\tADDRCNTR_SEC(val) \\\n\t\t(((val) & CNTR_MASK) >> ADDRCNTR_SEC_SHIFT)\n#define NFI_STRADDR\t\t(0x80)\n#define NFI_BYTELEN\t\t(0x84)\n#define NFI_CSEL\t\t(0x90)\n#define NFI_FDML(x)\t\t(0xA0 + (x) * sizeof(u32) * 2)\n#define NFI_FDMM(x)\t\t(0xA4 + (x) * sizeof(u32) * 2)\n#define NFI_FDM_MAX_SIZE\t(8)\n#define NFI_FDM_MIN_SIZE\t(1)\n#define NFI_DEBUG_CON1\t\t(0x220)\n#define\t\tSTROBE_MASK\t\tGENMASK(4, 3)\n#define\t\tSTROBE_SHIFT\t\t(3)\n#define\t\tMAX_STROBE_DLY\t\t(3)\n#define NFI_MASTER_STA\t\t(0x224)\n#define\t\tMASTER_STA_MASK\t\t(0x0FFF)\n#define NFI_EMPTY_THRESH\t(0x23C)\n\n#define MTK_NAME\t\t\"mtk-nand\"\n#define KB(x)\t\t\t((x) * 1024UL)\n#define MB(x)\t\t\t(KB(x) * 1024UL)\n\n#define MTK_TIMEOUT\t\t(500000)\n#define MTK_RESET_TIMEOUT\t(1000000)\n#define MTK_NAND_MAX_NSELS\t(2)\n#define MTK_NFC_MIN_SPARE\t(16)\n#define ACCTIMING(tpoecs, tprecs, tc2r, tw2r, twh, twst, trlt) \\\n\t((tpoecs) << 28 | (tprecs) << 22 | (tc2r) << 16 | \\\n\t(tw2r) << 12 | (twh) << 8 | (twst) << 4 | (trlt))\n\nstruct mtk_nfc_caps {\n\tconst u8 *spare_size;\n\tu8 num_spare_size;\n\tu8 pageformat_spare_shift;\n\tu8 nfi_clk_div;\n\tu8 max_sector;\n\tu32 max_sector_size;\n};\n\nstruct mtk_nfc_bad_mark_ctl {\n\tvoid (*bm_swap)(struct mtd_info *, u8 *buf, int raw);\n\tu32 sec;\n\tu32 pos;\n};\n\n \nstruct mtk_nfc_fdm {\n\tu32 reg_size;\n\tu32 ecc_size;\n};\n\nstruct mtk_nfc_nand_chip {\n\tstruct list_head node;\n\tstruct nand_chip nand;\n\n\tstruct mtk_nfc_bad_mark_ctl bad_mark;\n\tstruct mtk_nfc_fdm fdm;\n\tu32 spare_per_sector;\n\n\tint nsels;\n\tu8 sels[];\n\t \n};\n\nstruct mtk_nfc_clk {\n\tstruct clk *nfi_clk;\n\tstruct clk *pad_clk;\n};\n\nstruct mtk_nfc {\n\tstruct nand_controller controller;\n\tstruct mtk_ecc_config ecc_cfg;\n\tstruct mtk_nfc_clk clk;\n\tstruct mtk_ecc *ecc;\n\n\tstruct device *dev;\n\tconst struct mtk_nfc_caps *caps;\n\tvoid __iomem *regs;\n\n\tstruct completion done;\n\tstruct list_head chips;\n\n\tu8 *buffer;\n\n\tunsigned long assigned_cs;\n};\n\n \nstatic const u8 spare_size_mt2701[] = {\n\t16, 26, 27, 28, 32, 36, 40, 44,\t48, 49, 50, 51, 52, 62, 63, 64\n};\n\nstatic const u8 spare_size_mt2712[] = {\n\t16, 26, 27, 28, 32, 36, 40, 44, 48, 49, 50, 51, 52, 62, 61, 63, 64, 67,\n\t74\n};\n\nstatic const u8 spare_size_mt7622[] = {\n\t16, 26, 27, 28\n};\n\nstatic inline struct mtk_nfc_nand_chip *to_mtk_nand(struct nand_chip *nand)\n{\n\treturn container_of(nand, struct mtk_nfc_nand_chip, nand);\n}\n\nstatic inline u8 *data_ptr(struct nand_chip *chip, const u8 *p, int i)\n{\n\treturn (u8 *)p + i * chip->ecc.size;\n}\n\nstatic inline u8 *oob_ptr(struct nand_chip *chip, int i)\n{\n\tstruct mtk_nfc_nand_chip *mtk_nand = to_mtk_nand(chip);\n\tu8 *poi;\n\n\t \n\n\tif (i < mtk_nand->bad_mark.sec)\n\t\tpoi = chip->oob_poi + (i + 1) * mtk_nand->fdm.reg_size;\n\telse if (i == mtk_nand->bad_mark.sec)\n\t\tpoi = chip->oob_poi;\n\telse\n\t\tpoi = chip->oob_poi + i * mtk_nand->fdm.reg_size;\n\n\treturn poi;\n}\n\nstatic inline int mtk_data_len(struct nand_chip *chip)\n{\n\tstruct mtk_nfc_nand_chip *mtk_nand = to_mtk_nand(chip);\n\n\treturn chip->ecc.size + mtk_nand->spare_per_sector;\n}\n\nstatic inline u8 *mtk_data_ptr(struct nand_chip *chip,  int i)\n{\n\tstruct mtk_nfc *nfc = nand_get_controller_data(chip);\n\n\treturn nfc->buffer + i * mtk_data_len(chip);\n}\n\nstatic inline u8 *mtk_oob_ptr(struct nand_chip *chip, int i)\n{\n\tstruct mtk_nfc *nfc = nand_get_controller_data(chip);\n\n\treturn nfc->buffer + i * mtk_data_len(chip) + chip->ecc.size;\n}\n\nstatic inline void nfi_writel(struct mtk_nfc *nfc, u32 val, u32 reg)\n{\n\twritel(val, nfc->regs + reg);\n}\n\nstatic inline void nfi_writew(struct mtk_nfc *nfc, u16 val, u32 reg)\n{\n\twritew(val, nfc->regs + reg);\n}\n\nstatic inline void nfi_writeb(struct mtk_nfc *nfc, u8 val, u32 reg)\n{\n\twriteb(val, nfc->regs + reg);\n}\n\nstatic inline u32 nfi_readl(struct mtk_nfc *nfc, u32 reg)\n{\n\treturn readl_relaxed(nfc->regs + reg);\n}\n\nstatic inline u16 nfi_readw(struct mtk_nfc *nfc, u32 reg)\n{\n\treturn readw_relaxed(nfc->regs + reg);\n}\n\nstatic inline u8 nfi_readb(struct mtk_nfc *nfc, u32 reg)\n{\n\treturn readb_relaxed(nfc->regs + reg);\n}\n\nstatic void mtk_nfc_hw_reset(struct mtk_nfc *nfc)\n{\n\tstruct device *dev = nfc->dev;\n\tu32 val;\n\tint ret;\n\n\t \n\tnfi_writel(nfc, CON_FIFO_FLUSH | CON_NFI_RST, NFI_CON);\n\n\t \n\tret = readl_poll_timeout(nfc->regs + NFI_MASTER_STA, val,\n\t\t\t\t !(val & MASTER_STA_MASK), 50,\n\t\t\t\t MTK_RESET_TIMEOUT);\n\tif (ret)\n\t\tdev_warn(dev, \"master active in reset [0x%x] = 0x%x\\n\",\n\t\t\t NFI_MASTER_STA, val);\n\n\t \n\tnfi_writel(nfc, CON_FIFO_FLUSH | CON_NFI_RST, NFI_CON);\n\tnfi_writew(nfc, STAR_DE, NFI_STRDATA);\n}\n\nstatic int mtk_nfc_send_command(struct mtk_nfc *nfc, u8 command)\n{\n\tstruct device *dev = nfc->dev;\n\tu32 val;\n\tint ret;\n\n\tnfi_writel(nfc, command, NFI_CMD);\n\n\tret = readl_poll_timeout_atomic(nfc->regs + NFI_STA, val,\n\t\t\t\t\t!(val & STA_CMD), 10,  MTK_TIMEOUT);\n\tif (ret) {\n\t\tdev_warn(dev, \"nfi core timed out entering command mode\\n\");\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic int mtk_nfc_send_address(struct mtk_nfc *nfc, int addr)\n{\n\tstruct device *dev = nfc->dev;\n\tu32 val;\n\tint ret;\n\n\tnfi_writel(nfc, addr, NFI_COLADDR);\n\tnfi_writel(nfc, 0, NFI_ROWADDR);\n\tnfi_writew(nfc, 1, NFI_ADDRNOB);\n\n\tret = readl_poll_timeout_atomic(nfc->regs + NFI_STA, val,\n\t\t\t\t\t!(val & STA_ADDR), 10, MTK_TIMEOUT);\n\tif (ret) {\n\t\tdev_warn(dev, \"nfi core timed out entering address mode\\n\");\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic int mtk_nfc_hw_runtime_config(struct mtd_info *mtd)\n{\n\tstruct nand_chip *chip = mtd_to_nand(mtd);\n\tstruct mtk_nfc_nand_chip *mtk_nand = to_mtk_nand(chip);\n\tstruct mtk_nfc *nfc = nand_get_controller_data(chip);\n\tu32 fmt, spare, i;\n\n\tif (!mtd->writesize)\n\t\treturn 0;\n\n\tspare = mtk_nand->spare_per_sector;\n\n\tswitch (mtd->writesize) {\n\tcase 512:\n\t\tfmt = PAGEFMT_512_2K | PAGEFMT_SEC_SEL_512;\n\t\tbreak;\n\tcase KB(2):\n\t\tif (chip->ecc.size == 512)\n\t\t\tfmt = PAGEFMT_2K_4K | PAGEFMT_SEC_SEL_512;\n\t\telse\n\t\t\tfmt = PAGEFMT_512_2K;\n\t\tbreak;\n\tcase KB(4):\n\t\tif (chip->ecc.size == 512)\n\t\t\tfmt = PAGEFMT_4K_8K | PAGEFMT_SEC_SEL_512;\n\t\telse\n\t\t\tfmt = PAGEFMT_2K_4K;\n\t\tbreak;\n\tcase KB(8):\n\t\tif (chip->ecc.size == 512)\n\t\t\tfmt = PAGEFMT_8K_16K | PAGEFMT_SEC_SEL_512;\n\t\telse\n\t\t\tfmt = PAGEFMT_4K_8K;\n\t\tbreak;\n\tcase KB(16):\n\t\tfmt = PAGEFMT_8K_16K;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(nfc->dev, \"invalid page len: %d\\n\", mtd->writesize);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (chip->ecc.size == 1024)\n\t\tspare >>= 1;\n\n\tfor (i = 0; i < nfc->caps->num_spare_size; i++) {\n\t\tif (nfc->caps->spare_size[i] == spare)\n\t\t\tbreak;\n\t}\n\n\tif (i == nfc->caps->num_spare_size) {\n\t\tdev_err(nfc->dev, \"invalid spare size %d\\n\", spare);\n\t\treturn -EINVAL;\n\t}\n\n\tfmt |= i << nfc->caps->pageformat_spare_shift;\n\n\tfmt |= mtk_nand->fdm.reg_size << PAGEFMT_FDM_SHIFT;\n\tfmt |= mtk_nand->fdm.ecc_size << PAGEFMT_FDM_ECC_SHIFT;\n\tnfi_writel(nfc, fmt, NFI_PAGEFMT);\n\n\tnfc->ecc_cfg.strength = chip->ecc.strength;\n\tnfc->ecc_cfg.len = chip->ecc.size + mtk_nand->fdm.ecc_size;\n\n\treturn 0;\n}\n\nstatic inline void mtk_nfc_wait_ioready(struct mtk_nfc *nfc)\n{\n\tint rc;\n\tu8 val;\n\n\trc = readb_poll_timeout_atomic(nfc->regs + NFI_PIO_DIRDY, val,\n\t\t\t\t       val & PIO_DI_RDY, 10, MTK_TIMEOUT);\n\tif (rc < 0)\n\t\tdev_err(nfc->dev, \"data not ready\\n\");\n}\n\nstatic inline u8 mtk_nfc_read_byte(struct nand_chip *chip)\n{\n\tstruct mtk_nfc *nfc = nand_get_controller_data(chip);\n\tu32 reg;\n\n\t \n\treg = nfi_readl(nfc, NFI_STA) & NFI_FSM_MASK;\n\tif (reg != NFI_FSM_CUSTDATA) {\n\t\treg = nfi_readw(nfc, NFI_CNFG);\n\t\treg |= CNFG_BYTE_RW | CNFG_READ_EN;\n\t\tnfi_writew(nfc, reg, NFI_CNFG);\n\n\t\t \n\t\treg = (nfc->caps->max_sector << CON_SEC_SHIFT) | CON_BRD;\n\t\tnfi_writel(nfc, reg, NFI_CON);\n\n\t\t \n\t\tnfi_writew(nfc, STAR_EN, NFI_STRDATA);\n\t}\n\n\tmtk_nfc_wait_ioready(nfc);\n\n\treturn nfi_readb(nfc, NFI_DATAR);\n}\n\nstatic void mtk_nfc_read_buf(struct nand_chip *chip, u8 *buf, int len)\n{\n\tint i;\n\n\tfor (i = 0; i < len; i++)\n\t\tbuf[i] = mtk_nfc_read_byte(chip);\n}\n\nstatic void mtk_nfc_write_byte(struct nand_chip *chip, u8 byte)\n{\n\tstruct mtk_nfc *nfc = nand_get_controller_data(chip);\n\tu32 reg;\n\n\treg = nfi_readl(nfc, NFI_STA) & NFI_FSM_MASK;\n\n\tif (reg != NFI_FSM_CUSTDATA) {\n\t\treg = nfi_readw(nfc, NFI_CNFG) | CNFG_BYTE_RW;\n\t\tnfi_writew(nfc, reg, NFI_CNFG);\n\n\t\treg = nfc->caps->max_sector << CON_SEC_SHIFT | CON_BWR;\n\t\tnfi_writel(nfc, reg, NFI_CON);\n\n\t\tnfi_writew(nfc, STAR_EN, NFI_STRDATA);\n\t}\n\n\tmtk_nfc_wait_ioready(nfc);\n\tnfi_writeb(nfc, byte, NFI_DATAW);\n}\n\nstatic void mtk_nfc_write_buf(struct nand_chip *chip, const u8 *buf, int len)\n{\n\tint i;\n\n\tfor (i = 0; i < len; i++)\n\t\tmtk_nfc_write_byte(chip, buf[i]);\n}\n\nstatic int mtk_nfc_exec_instr(struct nand_chip *chip,\n\t\t\t      const struct nand_op_instr *instr)\n{\n\tstruct mtk_nfc *nfc = nand_get_controller_data(chip);\n\tunsigned int i;\n\tu32 status;\n\n\tswitch (instr->type) {\n\tcase NAND_OP_CMD_INSTR:\n\t\tmtk_nfc_send_command(nfc, instr->ctx.cmd.opcode);\n\t\treturn 0;\n\tcase NAND_OP_ADDR_INSTR:\n\t\tfor (i = 0; i < instr->ctx.addr.naddrs; i++)\n\t\t\tmtk_nfc_send_address(nfc, instr->ctx.addr.addrs[i]);\n\t\treturn 0;\n\tcase NAND_OP_DATA_IN_INSTR:\n\t\tmtk_nfc_read_buf(chip, instr->ctx.data.buf.in,\n\t\t\t\t instr->ctx.data.len);\n\t\treturn 0;\n\tcase NAND_OP_DATA_OUT_INSTR:\n\t\tmtk_nfc_write_buf(chip, instr->ctx.data.buf.out,\n\t\t\t\t  instr->ctx.data.len);\n\t\treturn 0;\n\tcase NAND_OP_WAITRDY_INSTR:\n\t\treturn readl_poll_timeout(nfc->regs + NFI_STA, status,\n\t\t\t\t\t  !(status & STA_BUSY), 20,\n\t\t\t\t\t  instr->ctx.waitrdy.timeout_ms * 1000);\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic void mtk_nfc_select_target(struct nand_chip *nand, unsigned int cs)\n{\n\tstruct mtk_nfc *nfc = nand_get_controller_data(nand);\n\tstruct mtk_nfc_nand_chip *mtk_nand = to_mtk_nand(nand);\n\n\tmtk_nfc_hw_runtime_config(nand_to_mtd(nand));\n\n\tnfi_writel(nfc, mtk_nand->sels[cs], NFI_CSEL);\n}\n\nstatic int mtk_nfc_exec_op(struct nand_chip *chip,\n\t\t\t   const struct nand_operation *op,\n\t\t\t   bool check_only)\n{\n\tstruct mtk_nfc *nfc = nand_get_controller_data(chip);\n\tunsigned int i;\n\tint ret = 0;\n\n\tif (check_only)\n\t\treturn 0;\n\n\tmtk_nfc_hw_reset(nfc);\n\tnfi_writew(nfc, CNFG_OP_CUST, NFI_CNFG);\n\tmtk_nfc_select_target(chip, op->cs);\n\n\tfor (i = 0; i < op->ninstrs; i++) {\n\t\tret = mtk_nfc_exec_instr(chip, &op->instrs[i]);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int mtk_nfc_setup_interface(struct nand_chip *chip, int csline,\n\t\t\t\t   const struct nand_interface_config *conf)\n{\n\tstruct mtk_nfc *nfc = nand_get_controller_data(chip);\n\tconst struct nand_sdr_timings *timings;\n\tu32 rate, tpoecs, tprecs, tc2r, tw2r, twh, twst = 0, trlt = 0;\n\tu32 temp, tsel = 0;\n\n\ttimings = nand_get_sdr_timings(conf);\n\tif (IS_ERR(timings))\n\t\treturn -ENOTSUPP;\n\n\tif (csline == NAND_DATA_IFACE_CHECK_ONLY)\n\t\treturn 0;\n\n\trate = clk_get_rate(nfc->clk.nfi_clk);\n\t \n\trate /= nfc->caps->nfi_clk_div;\n\n\t \n\trate /= 1000;\n\n\ttpoecs = max(timings->tALH_min, timings->tCLH_min) / 1000;\n\ttpoecs = DIV_ROUND_UP(tpoecs * rate, 1000000);\n\ttpoecs &= 0xf;\n\n\ttprecs = max(timings->tCLS_min, timings->tALS_min) / 1000;\n\ttprecs = DIV_ROUND_UP(tprecs * rate, 1000000);\n\ttprecs &= 0x3f;\n\n\t \n\ttc2r = 0;\n\n\ttw2r = timings->tWHR_min / 1000;\n\ttw2r = DIV_ROUND_UP(tw2r * rate, 1000000);\n\ttw2r = DIV_ROUND_UP(tw2r - 1, 2);\n\ttw2r &= 0xf;\n\n\ttwh = max(timings->tREH_min, timings->tWH_min) / 1000;\n\ttwh = DIV_ROUND_UP(twh * rate, 1000000) - 1;\n\ttwh &= 0xf;\n\n\t \n\ttemp = (twh + 1) * 1000000 / rate;\n\t \n\ttemp *= 1000;\n\n\t \n\tif (temp < timings->tWC_min)\n\t\ttwst = timings->tWC_min - temp;\n\ttwst = max(timings->tWP_min, twst) / 1000;\n\ttwst = DIV_ROUND_UP(twst * rate, 1000000) - 1;\n\ttwst &= 0xf;\n\n\t \n\tif (temp < timings->tRC_min)\n\t\ttrlt = timings->tRC_min - temp;\n\ttrlt = max(trlt, timings->tRP_min) / 1000;\n\ttrlt = DIV_ROUND_UP(trlt * rate, 1000000) - 1;\n\ttrlt &= 0xf;\n\n\t \n\ttemp = (trlt + 1) * 1000000 / rate;\n\t \n\ttemp *= 1000;\n\t \n\tif (temp < timings->tREA_max) {\n\t\ttsel = timings->tREA_max / 1000;\n\t\ttsel = DIV_ROUND_UP(tsel * rate, 1000000);\n\t\ttsel -= (trlt + 1);\n\t\tif (tsel > MAX_STROBE_DLY) {\n\t\t\ttrlt += tsel - MAX_STROBE_DLY;\n\t\t\ttsel = MAX_STROBE_DLY;\n\t\t}\n\t}\n\ttemp = nfi_readl(nfc, NFI_DEBUG_CON1);\n\ttemp &= ~STROBE_MASK;\n\ttemp |= tsel << STROBE_SHIFT;\n\tnfi_writel(nfc, temp, NFI_DEBUG_CON1);\n\n\t \n\ttrlt = ACCTIMING(tpoecs, tprecs, tc2r, tw2r, twh, twst, trlt);\n\tnfi_writel(nfc, trlt, NFI_ACCCON);\n\n\treturn 0;\n}\n\nstatic int mtk_nfc_sector_encode(struct nand_chip *chip, u8 *data)\n{\n\tstruct mtk_nfc *nfc = nand_get_controller_data(chip);\n\tstruct mtk_nfc_nand_chip *mtk_nand = to_mtk_nand(chip);\n\tint size = chip->ecc.size + mtk_nand->fdm.reg_size;\n\n\tnfc->ecc_cfg.mode = ECC_DMA_MODE;\n\tnfc->ecc_cfg.op = ECC_ENCODE;\n\n\treturn mtk_ecc_encode(nfc->ecc, &nfc->ecc_cfg, data, size);\n}\n\nstatic void mtk_nfc_no_bad_mark_swap(struct mtd_info *a, u8 *b, int c)\n{\n\t \n}\n\nstatic void mtk_nfc_bad_mark_swap(struct mtd_info *mtd, u8 *buf, int raw)\n{\n\tstruct nand_chip *chip = mtd_to_nand(mtd);\n\tstruct mtk_nfc_nand_chip *nand = to_mtk_nand(chip);\n\tu32 bad_pos = nand->bad_mark.pos;\n\n\tif (raw)\n\t\tbad_pos += nand->bad_mark.sec * mtk_data_len(chip);\n\telse\n\t\tbad_pos += nand->bad_mark.sec * chip->ecc.size;\n\n\tswap(chip->oob_poi[0], buf[bad_pos]);\n}\n\nstatic int mtk_nfc_format_subpage(struct mtd_info *mtd, u32 offset,\n\t\t\t\t  u32 len, const u8 *buf)\n{\n\tstruct nand_chip *chip = mtd_to_nand(mtd);\n\tstruct mtk_nfc_nand_chip *mtk_nand = to_mtk_nand(chip);\n\tstruct mtk_nfc *nfc = nand_get_controller_data(chip);\n\tstruct mtk_nfc_fdm *fdm = &mtk_nand->fdm;\n\tu32 start, end;\n\tint i, ret;\n\n\tstart = offset / chip->ecc.size;\n\tend = DIV_ROUND_UP(offset + len, chip->ecc.size);\n\n\tmemset(nfc->buffer, 0xff, mtd->writesize + mtd->oobsize);\n\tfor (i = 0; i < chip->ecc.steps; i++) {\n\t\tmemcpy(mtk_data_ptr(chip, i), data_ptr(chip, buf, i),\n\t\t       chip->ecc.size);\n\n\t\tif (start > i || i >= end)\n\t\t\tcontinue;\n\n\t\tif (i == mtk_nand->bad_mark.sec)\n\t\t\tmtk_nand->bad_mark.bm_swap(mtd, nfc->buffer, 1);\n\n\t\tmemcpy(mtk_oob_ptr(chip, i), oob_ptr(chip, i), fdm->reg_size);\n\n\t\t \n\t\tret = mtk_nfc_sector_encode(chip, mtk_data_ptr(chip, i));\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void mtk_nfc_format_page(struct mtd_info *mtd, const u8 *buf)\n{\n\tstruct nand_chip *chip = mtd_to_nand(mtd);\n\tstruct mtk_nfc_nand_chip *mtk_nand = to_mtk_nand(chip);\n\tstruct mtk_nfc *nfc = nand_get_controller_data(chip);\n\tstruct mtk_nfc_fdm *fdm = &mtk_nand->fdm;\n\tu32 i;\n\n\tmemset(nfc->buffer, 0xff, mtd->writesize + mtd->oobsize);\n\tfor (i = 0; i < chip->ecc.steps; i++) {\n\t\tif (buf)\n\t\t\tmemcpy(mtk_data_ptr(chip, i), data_ptr(chip, buf, i),\n\t\t\t       chip->ecc.size);\n\n\t\tif (i == mtk_nand->bad_mark.sec)\n\t\t\tmtk_nand->bad_mark.bm_swap(mtd, nfc->buffer, 1);\n\n\t\tmemcpy(mtk_oob_ptr(chip, i), oob_ptr(chip, i), fdm->reg_size);\n\t}\n}\n\nstatic inline void mtk_nfc_read_fdm(struct nand_chip *chip, u32 start,\n\t\t\t\t    u32 sectors)\n{\n\tstruct mtk_nfc *nfc = nand_get_controller_data(chip);\n\tstruct mtk_nfc_nand_chip *mtk_nand = to_mtk_nand(chip);\n\tstruct mtk_nfc_fdm *fdm = &mtk_nand->fdm;\n\tu32 vall, valm;\n\tu8 *oobptr;\n\tint i, j;\n\n\tfor (i = 0; i < sectors; i++) {\n\t\toobptr = oob_ptr(chip, start + i);\n\t\tvall = nfi_readl(nfc, NFI_FDML(i));\n\t\tvalm = nfi_readl(nfc, NFI_FDMM(i));\n\n\t\tfor (j = 0; j < fdm->reg_size; j++)\n\t\t\toobptr[j] = (j >= 4 ? valm : vall) >> ((j % 4) * 8);\n\t}\n}\n\nstatic inline void mtk_nfc_write_fdm(struct nand_chip *chip)\n{\n\tstruct mtk_nfc *nfc = nand_get_controller_data(chip);\n\tstruct mtk_nfc_nand_chip *mtk_nand = to_mtk_nand(chip);\n\tstruct mtk_nfc_fdm *fdm = &mtk_nand->fdm;\n\tu32 vall, valm;\n\tu8 *oobptr;\n\tint i, j;\n\n\tfor (i = 0; i < chip->ecc.steps; i++) {\n\t\toobptr = oob_ptr(chip, i);\n\t\tvall = 0;\n\t\tvalm = 0;\n\t\tfor (j = 0; j < 8; j++) {\n\t\t\tif (j < 4)\n\t\t\t\tvall |= (j < fdm->reg_size ? oobptr[j] : 0xff)\n\t\t\t\t\t\t<< (j * 8);\n\t\t\telse\n\t\t\t\tvalm |= (j < fdm->reg_size ? oobptr[j] : 0xff)\n\t\t\t\t\t\t<< ((j - 4) * 8);\n\t\t}\n\t\tnfi_writel(nfc, vall, NFI_FDML(i));\n\t\tnfi_writel(nfc, valm, NFI_FDMM(i));\n\t}\n}\n\nstatic int mtk_nfc_do_write_page(struct mtd_info *mtd, struct nand_chip *chip,\n\t\t\t\t const u8 *buf, int page, int len)\n{\n\tstruct mtk_nfc *nfc = nand_get_controller_data(chip);\n\tstruct device *dev = nfc->dev;\n\tdma_addr_t addr;\n\tu32 reg;\n\tint ret;\n\n\taddr = dma_map_single(dev, (void *)buf, len, DMA_TO_DEVICE);\n\tret = dma_mapping_error(nfc->dev, addr);\n\tif (ret) {\n\t\tdev_err(nfc->dev, \"dma mapping error\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treg = nfi_readw(nfc, NFI_CNFG) | CNFG_AHB | CNFG_DMA_BURST_EN;\n\tnfi_writew(nfc, reg, NFI_CNFG);\n\n\tnfi_writel(nfc, chip->ecc.steps << CON_SEC_SHIFT, NFI_CON);\n\tnfi_writel(nfc, lower_32_bits(addr), NFI_STRADDR);\n\tnfi_writew(nfc, INTR_AHB_DONE_EN, NFI_INTR_EN);\n\n\tinit_completion(&nfc->done);\n\n\treg = nfi_readl(nfc, NFI_CON) | CON_BWR;\n\tnfi_writel(nfc, reg, NFI_CON);\n\tnfi_writew(nfc, STAR_EN, NFI_STRDATA);\n\n\tret = wait_for_completion_timeout(&nfc->done, msecs_to_jiffies(500));\n\tif (!ret) {\n\t\tdev_err(dev, \"program ahb done timeout\\n\");\n\t\tnfi_writew(nfc, 0, NFI_INTR_EN);\n\t\tret = -ETIMEDOUT;\n\t\tgoto timeout;\n\t}\n\n\tret = readl_poll_timeout_atomic(nfc->regs + NFI_ADDRCNTR, reg,\n\t\t\t\t\tADDRCNTR_SEC(reg) >= chip->ecc.steps,\n\t\t\t\t\t10, MTK_TIMEOUT);\n\tif (ret)\n\t\tdev_err(dev, \"hwecc write timeout\\n\");\n\ntimeout:\n\n\tdma_unmap_single(nfc->dev, addr, len, DMA_TO_DEVICE);\n\tnfi_writel(nfc, 0, NFI_CON);\n\n\treturn ret;\n}\n\nstatic int mtk_nfc_write_page(struct mtd_info *mtd, struct nand_chip *chip,\n\t\t\t      const u8 *buf, int page, int raw)\n{\n\tstruct mtk_nfc *nfc = nand_get_controller_data(chip);\n\tstruct mtk_nfc_nand_chip *mtk_nand = to_mtk_nand(chip);\n\tsize_t len;\n\tconst u8 *bufpoi;\n\tu32 reg;\n\tint ret;\n\n\tmtk_nfc_select_target(chip, chip->cur_cs);\n\tnand_prog_page_begin_op(chip, page, 0, NULL, 0);\n\n\tif (!raw) {\n\t\t \n\t\treg = nfi_readw(nfc, NFI_CNFG) | CNFG_AUTO_FMT_EN;\n\t\tnfi_writew(nfc, reg | CNFG_HW_ECC_EN, NFI_CNFG);\n\n\t\tnfc->ecc_cfg.op = ECC_ENCODE;\n\t\tnfc->ecc_cfg.mode = ECC_NFI_MODE;\n\t\tret = mtk_ecc_enable(nfc->ecc, &nfc->ecc_cfg);\n\t\tif (ret) {\n\t\t\t \n\t\t\treg = nfi_readw(nfc, NFI_CNFG);\n\t\t\treg &= ~(CNFG_AUTO_FMT_EN | CNFG_HW_ECC_EN);\n\t\t\tnfi_writew(nfc, reg, NFI_CNFG);\n\n\t\t\treturn ret;\n\t\t}\n\n\t\tmemcpy(nfc->buffer, buf, mtd->writesize);\n\t\tmtk_nand->bad_mark.bm_swap(mtd, nfc->buffer, raw);\n\t\tbufpoi = nfc->buffer;\n\n\t\t \n\t\tmtk_nfc_write_fdm(chip);\n\t} else {\n\t\tbufpoi = buf;\n\t}\n\n\tlen = mtd->writesize + (raw ? mtd->oobsize : 0);\n\tret = mtk_nfc_do_write_page(mtd, chip, bufpoi, page, len);\n\n\tif (!raw)\n\t\tmtk_ecc_disable(nfc->ecc);\n\n\tif (ret)\n\t\treturn ret;\n\n\treturn nand_prog_page_end_op(chip);\n}\n\nstatic int mtk_nfc_write_page_hwecc(struct nand_chip *chip, const u8 *buf,\n\t\t\t\t    int oob_on, int page)\n{\n\treturn mtk_nfc_write_page(nand_to_mtd(chip), chip, buf, page, 0);\n}\n\nstatic int mtk_nfc_write_page_raw(struct nand_chip *chip, const u8 *buf,\n\t\t\t\t  int oob_on, int pg)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tstruct mtk_nfc *nfc = nand_get_controller_data(chip);\n\n\tmtk_nfc_format_page(mtd, buf);\n\treturn mtk_nfc_write_page(mtd, chip, nfc->buffer, pg, 1);\n}\n\nstatic int mtk_nfc_write_subpage_hwecc(struct nand_chip *chip, u32 offset,\n\t\t\t\t       u32 data_len, const u8 *buf,\n\t\t\t\t       int oob_on, int page)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tstruct mtk_nfc *nfc = nand_get_controller_data(chip);\n\tint ret;\n\n\tret = mtk_nfc_format_subpage(mtd, offset, data_len, buf);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\treturn mtk_nfc_write_page(mtd, chip, nfc->buffer, page, 1);\n}\n\nstatic int mtk_nfc_write_oob_std(struct nand_chip *chip, int page)\n{\n\treturn mtk_nfc_write_page_raw(chip, NULL, 1, page);\n}\n\nstatic int mtk_nfc_update_ecc_stats(struct mtd_info *mtd, u8 *buf, u32 start,\n\t\t\t\t    u32 sectors)\n{\n\tstruct nand_chip *chip = mtd_to_nand(mtd);\n\tstruct mtk_nfc *nfc = nand_get_controller_data(chip);\n\tstruct mtk_nfc_nand_chip *mtk_nand = to_mtk_nand(chip);\n\tstruct mtk_ecc_stats stats;\n\tu32 reg_size = mtk_nand->fdm.reg_size;\n\tint rc, i;\n\n\trc = nfi_readl(nfc, NFI_STA) & STA_EMP_PAGE;\n\tif (rc) {\n\t\tmemset(buf, 0xff, sectors * chip->ecc.size);\n\t\tfor (i = 0; i < sectors; i++)\n\t\t\tmemset(oob_ptr(chip, start + i), 0xff, reg_size);\n\t\treturn 0;\n\t}\n\n\tmtk_ecc_get_stats(nfc->ecc, &stats, sectors);\n\tmtd->ecc_stats.corrected += stats.corrected;\n\tmtd->ecc_stats.failed += stats.failed;\n\n\treturn stats.bitflips;\n}\n\nstatic int mtk_nfc_read_subpage(struct mtd_info *mtd, struct nand_chip *chip,\n\t\t\t\tu32 data_offs, u32 readlen,\n\t\t\t\tu8 *bufpoi, int page, int raw)\n{\n\tstruct mtk_nfc *nfc = nand_get_controller_data(chip);\n\tstruct mtk_nfc_nand_chip *mtk_nand = to_mtk_nand(chip);\n\tu32 spare = mtk_nand->spare_per_sector;\n\tu32 column, sectors, start, end, reg;\n\tdma_addr_t addr;\n\tint bitflips = 0;\n\tsize_t len;\n\tu8 *buf;\n\tint rc;\n\n\tmtk_nfc_select_target(chip, chip->cur_cs);\n\tstart = data_offs / chip->ecc.size;\n\tend = DIV_ROUND_UP(data_offs + readlen, chip->ecc.size);\n\n\tsectors = end - start;\n\tcolumn = start * (chip->ecc.size + spare);\n\n\tlen = sectors * chip->ecc.size + (raw ? sectors * spare : 0);\n\tbuf = bufpoi + start * chip->ecc.size;\n\n\tnand_read_page_op(chip, page, column, NULL, 0);\n\n\taddr = dma_map_single(nfc->dev, buf, len, DMA_FROM_DEVICE);\n\trc = dma_mapping_error(nfc->dev, addr);\n\tif (rc) {\n\t\tdev_err(nfc->dev, \"dma mapping error\\n\");\n\n\t\treturn -EINVAL;\n\t}\n\n\treg = nfi_readw(nfc, NFI_CNFG);\n\treg |= CNFG_READ_EN | CNFG_DMA_BURST_EN | CNFG_AHB;\n\tif (!raw) {\n\t\treg |= CNFG_AUTO_FMT_EN | CNFG_HW_ECC_EN;\n\t\tnfi_writew(nfc, reg, NFI_CNFG);\n\n\t\tnfc->ecc_cfg.mode = ECC_NFI_MODE;\n\t\tnfc->ecc_cfg.sectors = sectors;\n\t\tnfc->ecc_cfg.op = ECC_DECODE;\n\t\trc = mtk_ecc_enable(nfc->ecc, &nfc->ecc_cfg);\n\t\tif (rc) {\n\t\t\tdev_err(nfc->dev, \"ecc enable\\n\");\n\t\t\t \n\t\t\treg &= ~(CNFG_DMA_BURST_EN | CNFG_AHB | CNFG_READ_EN |\n\t\t\t\tCNFG_AUTO_FMT_EN | CNFG_HW_ECC_EN);\n\t\t\tnfi_writew(nfc, reg, NFI_CNFG);\n\t\t\tdma_unmap_single(nfc->dev, addr, len, DMA_FROM_DEVICE);\n\n\t\t\treturn rc;\n\t\t}\n\t} else {\n\t\tnfi_writew(nfc, reg, NFI_CNFG);\n\t}\n\n\tnfi_writel(nfc, sectors << CON_SEC_SHIFT, NFI_CON);\n\tnfi_writew(nfc, INTR_AHB_DONE_EN, NFI_INTR_EN);\n\tnfi_writel(nfc, lower_32_bits(addr), NFI_STRADDR);\n\n\tinit_completion(&nfc->done);\n\treg = nfi_readl(nfc, NFI_CON) | CON_BRD;\n\tnfi_writel(nfc, reg, NFI_CON);\n\tnfi_writew(nfc, STAR_EN, NFI_STRDATA);\n\n\trc = wait_for_completion_timeout(&nfc->done, msecs_to_jiffies(500));\n\tif (!rc)\n\t\tdev_warn(nfc->dev, \"read ahb/dma done timeout\\n\");\n\n\trc = readl_poll_timeout_atomic(nfc->regs + NFI_BYTELEN, reg,\n\t\t\t\t       ADDRCNTR_SEC(reg) >= sectors, 10,\n\t\t\t\t       MTK_TIMEOUT);\n\tif (rc < 0) {\n\t\tdev_err(nfc->dev, \"subpage done timeout\\n\");\n\t\tbitflips = -EIO;\n\t} else if (!raw) {\n\t\trc = mtk_ecc_wait_done(nfc->ecc, ECC_DECODE);\n\t\tbitflips = rc < 0 ? -ETIMEDOUT :\n\t\t\tmtk_nfc_update_ecc_stats(mtd, buf, start, sectors);\n\t\tmtk_nfc_read_fdm(chip, start, sectors);\n\t}\n\n\tdma_unmap_single(nfc->dev, addr, len, DMA_FROM_DEVICE);\n\n\tif (raw)\n\t\tgoto done;\n\n\tmtk_ecc_disable(nfc->ecc);\n\n\tif (clamp(mtk_nand->bad_mark.sec, start, end) == mtk_nand->bad_mark.sec)\n\t\tmtk_nand->bad_mark.bm_swap(mtd, bufpoi, raw);\ndone:\n\tnfi_writel(nfc, 0, NFI_CON);\n\n\treturn bitflips;\n}\n\nstatic int mtk_nfc_read_subpage_hwecc(struct nand_chip *chip, u32 off,\n\t\t\t\t      u32 len, u8 *p, int pg)\n{\n\treturn mtk_nfc_read_subpage(nand_to_mtd(chip), chip, off, len, p, pg,\n\t\t\t\t    0);\n}\n\nstatic int mtk_nfc_read_page_hwecc(struct nand_chip *chip, u8 *p, int oob_on,\n\t\t\t\t   int pg)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\n\treturn mtk_nfc_read_subpage(mtd, chip, 0, mtd->writesize, p, pg, 0);\n}\n\nstatic int mtk_nfc_read_page_raw(struct nand_chip *chip, u8 *buf, int oob_on,\n\t\t\t\t int page)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tstruct mtk_nfc_nand_chip *mtk_nand = to_mtk_nand(chip);\n\tstruct mtk_nfc *nfc = nand_get_controller_data(chip);\n\tstruct mtk_nfc_fdm *fdm = &mtk_nand->fdm;\n\tint i, ret;\n\n\tmemset(nfc->buffer, 0xff, mtd->writesize + mtd->oobsize);\n\tret = mtk_nfc_read_subpage(mtd, chip, 0, mtd->writesize, nfc->buffer,\n\t\t\t\t   page, 1);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tfor (i = 0; i < chip->ecc.steps; i++) {\n\t\tmemcpy(oob_ptr(chip, i), mtk_oob_ptr(chip, i), fdm->reg_size);\n\n\t\tif (i == mtk_nand->bad_mark.sec)\n\t\t\tmtk_nand->bad_mark.bm_swap(mtd, nfc->buffer, 1);\n\n\t\tif (buf)\n\t\t\tmemcpy(data_ptr(chip, buf, i), mtk_data_ptr(chip, i),\n\t\t\t       chip->ecc.size);\n\t}\n\n\treturn ret;\n}\n\nstatic int mtk_nfc_read_oob_std(struct nand_chip *chip, int page)\n{\n\treturn mtk_nfc_read_page_raw(chip, NULL, 1, page);\n}\n\nstatic inline void mtk_nfc_hw_init(struct mtk_nfc *nfc)\n{\n\t \n\tnfi_writew(nfc, 0xf1, NFI_CNRNB);\n\tnfi_writel(nfc, PAGEFMT_8K_16K, NFI_PAGEFMT);\n\n\tmtk_nfc_hw_reset(nfc);\n\n\tnfi_readl(nfc, NFI_INTR_STA);\n\tnfi_writel(nfc, 0, NFI_INTR_EN);\n}\n\nstatic irqreturn_t mtk_nfc_irq(int irq, void *id)\n{\n\tstruct mtk_nfc *nfc = id;\n\tu16 sta, ien;\n\n\tsta = nfi_readw(nfc, NFI_INTR_STA);\n\tien = nfi_readw(nfc, NFI_INTR_EN);\n\n\tif (!(sta & ien))\n\t\treturn IRQ_NONE;\n\n\tnfi_writew(nfc, ~sta & ien, NFI_INTR_EN);\n\tcomplete(&nfc->done);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int mtk_nfc_ooblayout_free(struct mtd_info *mtd, int section,\n\t\t\t\t  struct mtd_oob_region *oob_region)\n{\n\tstruct nand_chip *chip = mtd_to_nand(mtd);\n\tstruct mtk_nfc_nand_chip *mtk_nand = to_mtk_nand(chip);\n\tstruct mtk_nfc_fdm *fdm = &mtk_nand->fdm;\n\tu32 eccsteps;\n\n\teccsteps = mtd->writesize / chip->ecc.size;\n\n\tif (section >= eccsteps)\n\t\treturn -ERANGE;\n\n\toob_region->length = fdm->reg_size - fdm->ecc_size;\n\toob_region->offset = section * fdm->reg_size + fdm->ecc_size;\n\n\treturn 0;\n}\n\nstatic int mtk_nfc_ooblayout_ecc(struct mtd_info *mtd, int section,\n\t\t\t\t struct mtd_oob_region *oob_region)\n{\n\tstruct nand_chip *chip = mtd_to_nand(mtd);\n\tstruct mtk_nfc_nand_chip *mtk_nand = to_mtk_nand(chip);\n\tu32 eccsteps;\n\n\tif (section)\n\t\treturn -ERANGE;\n\n\teccsteps = mtd->writesize / chip->ecc.size;\n\toob_region->offset = mtk_nand->fdm.reg_size * eccsteps;\n\toob_region->length = mtd->oobsize - oob_region->offset;\n\n\treturn 0;\n}\n\nstatic const struct mtd_ooblayout_ops mtk_nfc_ooblayout_ops = {\n\t.free = mtk_nfc_ooblayout_free,\n\t.ecc = mtk_nfc_ooblayout_ecc,\n};\n\nstatic void mtk_nfc_set_fdm(struct mtk_nfc_fdm *fdm, struct mtd_info *mtd)\n{\n\tstruct nand_chip *nand = mtd_to_nand(mtd);\n\tstruct mtk_nfc_nand_chip *chip = to_mtk_nand(nand);\n\tstruct mtk_nfc *nfc = nand_get_controller_data(nand);\n\tu32 ecc_bytes;\n\n\tecc_bytes = DIV_ROUND_UP(nand->ecc.strength *\n\t\t\t\t mtk_ecc_get_parity_bits(nfc->ecc), 8);\n\n\tfdm->reg_size = chip->spare_per_sector - ecc_bytes;\n\tif (fdm->reg_size > NFI_FDM_MAX_SIZE)\n\t\tfdm->reg_size = NFI_FDM_MAX_SIZE;\n\n\t \n\tfdm->ecc_size = 1;\n}\n\nstatic void mtk_nfc_set_bad_mark_ctl(struct mtk_nfc_bad_mark_ctl *bm_ctl,\n\t\t\t\t     struct mtd_info *mtd)\n{\n\tstruct nand_chip *nand = mtd_to_nand(mtd);\n\n\tif (mtd->writesize == 512) {\n\t\tbm_ctl->bm_swap = mtk_nfc_no_bad_mark_swap;\n\t} else {\n\t\tbm_ctl->bm_swap = mtk_nfc_bad_mark_swap;\n\t\tbm_ctl->sec = mtd->writesize / mtk_data_len(nand);\n\t\tbm_ctl->pos = mtd->writesize % mtk_data_len(nand);\n\t}\n}\n\nstatic int mtk_nfc_set_spare_per_sector(u32 *sps, struct mtd_info *mtd)\n{\n\tstruct nand_chip *nand = mtd_to_nand(mtd);\n\tstruct mtk_nfc *nfc = nand_get_controller_data(nand);\n\tconst u8 *spare = nfc->caps->spare_size;\n\tu32 eccsteps, i, closest_spare = 0;\n\n\teccsteps = mtd->writesize / nand->ecc.size;\n\t*sps = mtd->oobsize / eccsteps;\n\n\tif (nand->ecc.size == 1024)\n\t\t*sps >>= 1;\n\n\tif (*sps < MTK_NFC_MIN_SPARE)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < nfc->caps->num_spare_size; i++) {\n\t\tif (*sps >= spare[i] && spare[i] >= spare[closest_spare]) {\n\t\t\tclosest_spare = i;\n\t\t\tif (*sps == spare[i])\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t*sps = spare[closest_spare];\n\n\tif (nand->ecc.size == 1024)\n\t\t*sps <<= 1;\n\n\treturn 0;\n}\n\nstatic int mtk_nfc_ecc_init(struct device *dev, struct mtd_info *mtd)\n{\n\tstruct nand_chip *nand = mtd_to_nand(mtd);\n\tconst struct nand_ecc_props *requirements =\n\t\tnanddev_get_ecc_requirements(&nand->base);\n\tstruct mtk_nfc *nfc = nand_get_controller_data(nand);\n\tu32 spare;\n\tint free, ret;\n\n\t \n\tif (nand->ecc.engine_type != NAND_ECC_ENGINE_TYPE_ON_HOST) {\n\t\tdev_err(dev, \"ecc.engine_type not supported\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (!nand->ecc.size || !nand->ecc.strength) {\n\t\t \n\t\tnand->ecc.strength = requirements->strength;\n\t\tnand->ecc.size = requirements->step_size;\n\n\t\t \n\t\tif (nand->ecc.size < 1024) {\n\t\t\tif (mtd->writesize > 512 &&\n\t\t\t    nfc->caps->max_sector_size > 512) {\n\t\t\t\tnand->ecc.size = 1024;\n\t\t\t\tnand->ecc.strength <<= 1;\n\t\t\t} else {\n\t\t\t\tnand->ecc.size = 512;\n\t\t\t}\n\t\t} else {\n\t\t\tnand->ecc.size = 1024;\n\t\t}\n\n\t\tret = mtk_nfc_set_spare_per_sector(&spare, mtd);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t \n\t\tfree = (nand->ecc.strength * mtk_ecc_get_parity_bits(nfc->ecc)\n\t\t\t+ 7) >> 3;\n\t\tfree = spare - free;\n\n\t\t \n\t\tif (free > NFI_FDM_MAX_SIZE) {\n\t\t\tspare -= NFI_FDM_MAX_SIZE;\n\t\t\tnand->ecc.strength = (spare << 3) /\n\t\t\t\t\t     mtk_ecc_get_parity_bits(nfc->ecc);\n\t\t} else if (free < 0) {\n\t\t\tspare -= NFI_FDM_MIN_SIZE;\n\t\t\tnand->ecc.strength = (spare << 3) /\n\t\t\t\t\t     mtk_ecc_get_parity_bits(nfc->ecc);\n\t\t}\n\t}\n\n\tmtk_ecc_adjust_strength(nfc->ecc, &nand->ecc.strength);\n\n\tdev_info(dev, \"eccsize %d eccstrength %d\\n\",\n\t\t nand->ecc.size, nand->ecc.strength);\n\n\treturn 0;\n}\n\nstatic int mtk_nfc_attach_chip(struct nand_chip *chip)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tstruct device *dev = mtd->dev.parent;\n\tstruct mtk_nfc *nfc = nand_get_controller_data(chip);\n\tstruct mtk_nfc_nand_chip *mtk_nand = to_mtk_nand(chip);\n\tint len;\n\tint ret;\n\n\tif (chip->options & NAND_BUSWIDTH_16) {\n\t\tdev_err(dev, \"16bits buswidth not supported\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (chip->bbt_options & NAND_BBT_USE_FLASH)\n\t\tchip->bbt_options |= NAND_BBT_NO_OOB;\n\n\tret = mtk_nfc_ecc_init(dev, mtd);\n\tif (ret)\n\t\treturn ret;\n\n\tret = mtk_nfc_set_spare_per_sector(&mtk_nand->spare_per_sector, mtd);\n\tif (ret)\n\t\treturn ret;\n\n\tmtk_nfc_set_fdm(&mtk_nand->fdm, mtd);\n\tmtk_nfc_set_bad_mark_ctl(&mtk_nand->bad_mark, mtd);\n\n\tlen = mtd->writesize + mtd->oobsize;\n\tnfc->buffer = devm_kzalloc(dev, len, GFP_KERNEL);\n\tif (!nfc->buffer)\n\t\treturn  -ENOMEM;\n\n\treturn 0;\n}\n\nstatic const struct nand_controller_ops mtk_nfc_controller_ops = {\n\t.attach_chip = mtk_nfc_attach_chip,\n\t.setup_interface = mtk_nfc_setup_interface,\n\t.exec_op = mtk_nfc_exec_op,\n};\n\nstatic int mtk_nfc_nand_chip_init(struct device *dev, struct mtk_nfc *nfc,\n\t\t\t\t  struct device_node *np)\n{\n\tstruct mtk_nfc_nand_chip *chip;\n\tstruct nand_chip *nand;\n\tstruct mtd_info *mtd;\n\tint nsels;\n\tu32 tmp;\n\tint ret;\n\tint i;\n\n\tif (!of_get_property(np, \"reg\", &nsels))\n\t\treturn -ENODEV;\n\n\tnsels /= sizeof(u32);\n\tif (!nsels || nsels > MTK_NAND_MAX_NSELS) {\n\t\tdev_err(dev, \"invalid reg property size %d\\n\", nsels);\n\t\treturn -EINVAL;\n\t}\n\n\tchip = devm_kzalloc(dev, sizeof(*chip) + nsels * sizeof(u8),\n\t\t\t    GFP_KERNEL);\n\tif (!chip)\n\t\treturn -ENOMEM;\n\n\tchip->nsels = nsels;\n\tfor (i = 0; i < nsels; i++) {\n\t\tret = of_property_read_u32_index(np, \"reg\", i, &tmp);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"reg property failure : %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (tmp >= MTK_NAND_MAX_NSELS) {\n\t\t\tdev_err(dev, \"invalid CS: %u\\n\", tmp);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (test_and_set_bit(tmp, &nfc->assigned_cs)) {\n\t\t\tdev_err(dev, \"CS %u already assigned\\n\", tmp);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tchip->sels[i] = tmp;\n\t}\n\n\tnand = &chip->nand;\n\tnand->controller = &nfc->controller;\n\n\tnand_set_flash_node(nand, np);\n\tnand_set_controller_data(nand, nfc);\n\n\tnand->options |= NAND_USES_DMA | NAND_SUBPAGE_READ;\n\n\t \n\tnand->ecc.engine_type = NAND_ECC_ENGINE_TYPE_ON_HOST;\n\n\tnand->ecc.write_subpage = mtk_nfc_write_subpage_hwecc;\n\tnand->ecc.write_page_raw = mtk_nfc_write_page_raw;\n\tnand->ecc.write_page = mtk_nfc_write_page_hwecc;\n\tnand->ecc.write_oob_raw = mtk_nfc_write_oob_std;\n\tnand->ecc.write_oob = mtk_nfc_write_oob_std;\n\n\tnand->ecc.read_subpage = mtk_nfc_read_subpage_hwecc;\n\tnand->ecc.read_page_raw = mtk_nfc_read_page_raw;\n\tnand->ecc.read_page = mtk_nfc_read_page_hwecc;\n\tnand->ecc.read_oob_raw = mtk_nfc_read_oob_std;\n\tnand->ecc.read_oob = mtk_nfc_read_oob_std;\n\n\tmtd = nand_to_mtd(nand);\n\tmtd->owner = THIS_MODULE;\n\tmtd->dev.parent = dev;\n\tmtd->name = MTK_NAME;\n\tmtd_set_ooblayout(mtd, &mtk_nfc_ooblayout_ops);\n\n\tmtk_nfc_hw_init(nfc);\n\n\tret = nand_scan(nand, nsels);\n\tif (ret)\n\t\treturn ret;\n\n\tret = mtd_device_register(mtd, NULL, 0);\n\tif (ret) {\n\t\tdev_err(dev, \"mtd parse partition error\\n\");\n\t\tnand_cleanup(nand);\n\t\treturn ret;\n\t}\n\n\tlist_add_tail(&chip->node, &nfc->chips);\n\n\treturn 0;\n}\n\nstatic int mtk_nfc_nand_chips_init(struct device *dev, struct mtk_nfc *nfc)\n{\n\tstruct device_node *np = dev->of_node;\n\tstruct device_node *nand_np;\n\tint ret;\n\n\tfor_each_child_of_node(np, nand_np) {\n\t\tret = mtk_nfc_nand_chip_init(dev, nfc, nand_np);\n\t\tif (ret) {\n\t\t\tof_node_put(nand_np);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic const struct mtk_nfc_caps mtk_nfc_caps_mt2701 = {\n\t.spare_size = spare_size_mt2701,\n\t.num_spare_size = 16,\n\t.pageformat_spare_shift = 4,\n\t.nfi_clk_div = 1,\n\t.max_sector = 16,\n\t.max_sector_size = 1024,\n};\n\nstatic const struct mtk_nfc_caps mtk_nfc_caps_mt2712 = {\n\t.spare_size = spare_size_mt2712,\n\t.num_spare_size = 19,\n\t.pageformat_spare_shift = 16,\n\t.nfi_clk_div = 2,\n\t.max_sector = 16,\n\t.max_sector_size = 1024,\n};\n\nstatic const struct mtk_nfc_caps mtk_nfc_caps_mt7622 = {\n\t.spare_size = spare_size_mt7622,\n\t.num_spare_size = 4,\n\t.pageformat_spare_shift = 4,\n\t.nfi_clk_div = 1,\n\t.max_sector = 8,\n\t.max_sector_size = 512,\n};\n\nstatic const struct of_device_id mtk_nfc_id_table[] = {\n\t{\n\t\t.compatible = \"mediatek,mt2701-nfc\",\n\t\t.data = &mtk_nfc_caps_mt2701,\n\t}, {\n\t\t.compatible = \"mediatek,mt2712-nfc\",\n\t\t.data = &mtk_nfc_caps_mt2712,\n\t}, {\n\t\t.compatible = \"mediatek,mt7622-nfc\",\n\t\t.data = &mtk_nfc_caps_mt7622,\n\t},\n\t{}\n};\nMODULE_DEVICE_TABLE(of, mtk_nfc_id_table);\n\nstatic int mtk_nfc_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np = dev->of_node;\n\tstruct mtk_nfc *nfc;\n\tint ret, irq;\n\n\tnfc = devm_kzalloc(dev, sizeof(*nfc), GFP_KERNEL);\n\tif (!nfc)\n\t\treturn -ENOMEM;\n\n\tnand_controller_init(&nfc->controller);\n\tINIT_LIST_HEAD(&nfc->chips);\n\tnfc->controller.ops = &mtk_nfc_controller_ops;\n\n\t \n\tnfc->ecc = of_mtk_ecc_get(np);\n\tif (IS_ERR(nfc->ecc))\n\t\treturn PTR_ERR(nfc->ecc);\n\telse if (!nfc->ecc)\n\t\treturn -ENODEV;\n\n\tnfc->caps = of_device_get_match_data(dev);\n\tnfc->dev = dev;\n\n\tnfc->regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(nfc->regs)) {\n\t\tret = PTR_ERR(nfc->regs);\n\t\tgoto release_ecc;\n\t}\n\n\tnfc->clk.nfi_clk = devm_clk_get_enabled(dev, \"nfi_clk\");\n\tif (IS_ERR(nfc->clk.nfi_clk)) {\n\t\tdev_err(dev, \"no clk\\n\");\n\t\tret = PTR_ERR(nfc->clk.nfi_clk);\n\t\tgoto release_ecc;\n\t}\n\n\tnfc->clk.pad_clk = devm_clk_get_enabled(dev, \"pad_clk\");\n\tif (IS_ERR(nfc->clk.pad_clk)) {\n\t\tdev_err(dev, \"no pad clk\\n\");\n\t\tret = PTR_ERR(nfc->clk.pad_clk);\n\t\tgoto release_ecc;\n\t}\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0) {\n\t\tret = -EINVAL;\n\t\tgoto release_ecc;\n\t}\n\n\tret = devm_request_irq(dev, irq, mtk_nfc_irq, 0x0, \"mtk-nand\", nfc);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to request nfi irq\\n\");\n\t\tgoto release_ecc;\n\t}\n\n\tret = dma_set_mask(dev, DMA_BIT_MASK(32));\n\tif (ret) {\n\t\tdev_err(dev, \"failed to set dma mask\\n\");\n\t\tgoto release_ecc;\n\t}\n\n\tplatform_set_drvdata(pdev, nfc);\n\n\tret = mtk_nfc_nand_chips_init(dev, nfc);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to init nand chips\\n\");\n\t\tgoto release_ecc;\n\t}\n\n\treturn 0;\n\nrelease_ecc:\n\tmtk_ecc_release(nfc->ecc);\n\n\treturn ret;\n}\n\nstatic void mtk_nfc_remove(struct platform_device *pdev)\n{\n\tstruct mtk_nfc *nfc = platform_get_drvdata(pdev);\n\tstruct mtk_nfc_nand_chip *mtk_chip;\n\tstruct nand_chip *chip;\n\tint ret;\n\n\twhile (!list_empty(&nfc->chips)) {\n\t\tmtk_chip = list_first_entry(&nfc->chips,\n\t\t\t\t\t    struct mtk_nfc_nand_chip, node);\n\t\tchip = &mtk_chip->nand;\n\t\tret = mtd_device_unregister(nand_to_mtd(chip));\n\t\tWARN_ON(ret);\n\t\tnand_cleanup(chip);\n\t\tlist_del(&mtk_chip->node);\n\t}\n\n\tmtk_ecc_release(nfc->ecc);\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int mtk_nfc_suspend(struct device *dev)\n{\n\tstruct mtk_nfc *nfc = dev_get_drvdata(dev);\n\n\tclk_disable_unprepare(nfc->clk.nfi_clk);\n\tclk_disable_unprepare(nfc->clk.pad_clk);\n\n\treturn 0;\n}\n\nstatic int mtk_nfc_resume(struct device *dev)\n{\n\tstruct mtk_nfc *nfc = dev_get_drvdata(dev);\n\tstruct mtk_nfc_nand_chip *chip;\n\tstruct nand_chip *nand;\n\tint ret;\n\tu32 i;\n\n\tudelay(200);\n\n\tret = clk_prepare_enable(nfc->clk.nfi_clk);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to enable nfi clk\\n\");\n\t\treturn ret;\n\t}\n\n\tret = clk_prepare_enable(nfc->clk.pad_clk);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to enable pad clk\\n\");\n\t\tclk_disable_unprepare(nfc->clk.nfi_clk);\n\t\treturn ret;\n\t}\n\n\t \n\tlist_for_each_entry(chip, &nfc->chips, node) {\n\t\tnand = &chip->nand;\n\t\tfor (i = 0; i < chip->nsels; i++)\n\t\t\tnand_reset(nand, i);\n\t}\n\n\treturn 0;\n}\n\nstatic SIMPLE_DEV_PM_OPS(mtk_nfc_pm_ops, mtk_nfc_suspend, mtk_nfc_resume);\n#endif\n\nstatic struct platform_driver mtk_nfc_driver = {\n\t.probe  = mtk_nfc_probe,\n\t.remove_new = mtk_nfc_remove,\n\t.driver = {\n\t\t.name  = MTK_NAME,\n\t\t.of_match_table = mtk_nfc_id_table,\n#ifdef CONFIG_PM_SLEEP\n\t\t.pm = &mtk_nfc_pm_ops,\n#endif\n\t},\n};\n\nmodule_platform_driver(mtk_nfc_driver);\n\nMODULE_LICENSE(\"Dual MIT/GPL\");\nMODULE_AUTHOR(\"Xiaolei Li <xiaolei.li@mediatek.com>\");\nMODULE_DESCRIPTION(\"MTK Nand Flash Controller Driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}