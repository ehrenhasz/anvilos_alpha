{
  "module_name": "fsl_elbc_nand.c",
  "hash_id": "9e421d43e7e8ff3b1dd21437cf13349dfe5aa9bf0457097c6b42cf5aed1901b7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/nand/raw/fsl_elbc_nand.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/ioport.h>\n#include <linux/of_address.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n\n#include <linux/mtd/mtd.h>\n#include <linux/mtd/rawnand.h>\n#include <linux/mtd/partitions.h>\n\n#include <asm/io.h>\n#include <asm/fsl_lbc.h>\n\n#define MAX_BANKS 8\n#define ERR_BYTE 0xFF  \n#define FCM_TIMEOUT_MSECS 500  \n\n \n\nstruct fsl_elbc_mtd {\n\tstruct nand_chip chip;\n\tstruct fsl_lbc_ctrl *ctrl;\n\n\tstruct device *dev;\n\tint bank;                \n\tu8 __iomem *vbase;       \n\tint page_size;           \n\tunsigned int fmr;        \n};\n\n \n\nstruct fsl_elbc_fcm_ctrl {\n\tstruct nand_controller controller;\n\tstruct fsl_elbc_mtd *chips[MAX_BANKS];\n\n\tu8 __iomem *addr;         \n\tunsigned int page;        \n\tunsigned int read_bytes;  \n\tunsigned int column;      \n\tunsigned int index;       \n\tunsigned int status;      \n\tunsigned int mdr;         \n\tunsigned int use_mdr;     \n\tunsigned int oob;         \n\tunsigned int counter;\t  \n\tunsigned int max_bitflips;   \n};\n\n \n\nstatic int fsl_elbc_ooblayout_ecc(struct mtd_info *mtd, int section,\n\t\t\t\t  struct mtd_oob_region *oobregion)\n{\n\tstruct nand_chip *chip = mtd_to_nand(mtd);\n\tstruct fsl_elbc_mtd *priv = nand_get_controller_data(chip);\n\n\tif (section >= chip->ecc.steps)\n\t\treturn -ERANGE;\n\n\toobregion->offset = (16 * section) + 6;\n\tif (priv->fmr & FMR_ECCM)\n\t\toobregion->offset += 2;\n\n\toobregion->length = chip->ecc.bytes;\n\n\treturn 0;\n}\n\nstatic int fsl_elbc_ooblayout_free(struct mtd_info *mtd, int section,\n\t\t\t\t   struct mtd_oob_region *oobregion)\n{\n\tstruct nand_chip *chip = mtd_to_nand(mtd);\n\tstruct fsl_elbc_mtd *priv = nand_get_controller_data(chip);\n\n\tif (section > chip->ecc.steps)\n\t\treturn -ERANGE;\n\n\tif (!section) {\n\t\toobregion->offset = 0;\n\t\tif (mtd->writesize > 512)\n\t\t\toobregion->offset++;\n\t\toobregion->length = (priv->fmr & FMR_ECCM) ? 7 : 5;\n\t} else {\n\t\toobregion->offset = (16 * section) -\n\t\t\t\t    ((priv->fmr & FMR_ECCM) ? 5 : 7);\n\t\tif (section < chip->ecc.steps)\n\t\t\toobregion->length = 13;\n\t\telse\n\t\t\toobregion->length = mtd->oobsize - oobregion->offset;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct mtd_ooblayout_ops fsl_elbc_ooblayout_ops = {\n\t.ecc = fsl_elbc_ooblayout_ecc,\n\t.free = fsl_elbc_ooblayout_free,\n};\n\n \nstatic u8 bbt_pattern[] = {'B', 'b', 't', '0' };\nstatic u8 mirror_pattern[] = {'1', 't', 'b', 'B' };\n\nstatic struct nand_bbt_descr bbt_main_descr = {\n\t.options = NAND_BBT_LASTBLOCK | NAND_BBT_CREATE | NAND_BBT_WRITE |\n\t\t   NAND_BBT_2BIT | NAND_BBT_VERSION,\n\t.offs =\t11,\n\t.len = 4,\n\t.veroffs = 15,\n\t.maxblocks = 4,\n\t.pattern = bbt_pattern,\n};\n\nstatic struct nand_bbt_descr bbt_mirror_descr = {\n\t.options = NAND_BBT_LASTBLOCK | NAND_BBT_CREATE | NAND_BBT_WRITE |\n\t\t   NAND_BBT_2BIT | NAND_BBT_VERSION,\n\t.offs =\t11,\n\t.len = 4,\n\t.veroffs = 15,\n\t.maxblocks = 4,\n\t.pattern = mirror_pattern,\n};\n\n \n\n \nstatic void set_addr(struct mtd_info *mtd, int column, int page_addr, int oob)\n{\n\tstruct nand_chip *chip = mtd_to_nand(mtd);\n\tstruct fsl_elbc_mtd *priv = nand_get_controller_data(chip);\n\tstruct fsl_lbc_ctrl *ctrl = priv->ctrl;\n\tstruct fsl_lbc_regs __iomem *lbc = ctrl->regs;\n\tstruct fsl_elbc_fcm_ctrl *elbc_fcm_ctrl = ctrl->nand;\n\tint buf_num;\n\n\telbc_fcm_ctrl->page = page_addr;\n\n\tif (priv->page_size) {\n\t\t \n\t\tout_be32(&lbc->fbar, page_addr >> 6);\n\t\tout_be32(&lbc->fpar,\n\t\t         ((page_addr << FPAR_LP_PI_SHIFT) & FPAR_LP_PI) |\n\t\t         (oob ? FPAR_LP_MS : 0) | column);\n\t\tbuf_num = (page_addr & 1) << 2;\n\t} else {\n\t\t \n\t\tout_be32(&lbc->fbar, page_addr >> 5);\n\t\tout_be32(&lbc->fpar,\n\t\t         ((page_addr << FPAR_SP_PI_SHIFT) & FPAR_SP_PI) |\n\t\t         (oob ? FPAR_SP_MS : 0) | column);\n\t\tbuf_num = page_addr & 7;\n\t}\n\n\telbc_fcm_ctrl->addr = priv->vbase + buf_num * 1024;\n\telbc_fcm_ctrl->index = column;\n\n\t \n\tif (oob)\n\t\telbc_fcm_ctrl->index += priv->page_size ? 2048 : 512;\n\n\tdev_vdbg(priv->dev, \"set_addr: bank=%d, \"\n\t\t\t    \"elbc_fcm_ctrl->addr=0x%p (0x%p), \"\n\t                    \"index %x, pes %d ps %d\\n\",\n\t\t buf_num, elbc_fcm_ctrl->addr, priv->vbase,\n\t\t elbc_fcm_ctrl->index,\n\t         chip->phys_erase_shift, chip->page_shift);\n}\n\n \nstatic int fsl_elbc_run_command(struct mtd_info *mtd)\n{\n\tstruct nand_chip *chip = mtd_to_nand(mtd);\n\tstruct fsl_elbc_mtd *priv = nand_get_controller_data(chip);\n\tstruct fsl_lbc_ctrl *ctrl = priv->ctrl;\n\tstruct fsl_elbc_fcm_ctrl *elbc_fcm_ctrl = ctrl->nand;\n\tstruct fsl_lbc_regs __iomem *lbc = ctrl->regs;\n\n\t \n\tout_be32(&lbc->fmr, priv->fmr | 3);\n\tif (elbc_fcm_ctrl->use_mdr)\n\t\tout_be32(&lbc->mdr, elbc_fcm_ctrl->mdr);\n\n\tdev_vdbg(priv->dev,\n\t         \"fsl_elbc_run_command: fmr=%08x fir=%08x fcr=%08x\\n\",\n\t         in_be32(&lbc->fmr), in_be32(&lbc->fir), in_be32(&lbc->fcr));\n\tdev_vdbg(priv->dev,\n\t         \"fsl_elbc_run_command: fbar=%08x fpar=%08x \"\n\t         \"fbcr=%08x bank=%d\\n\",\n\t         in_be32(&lbc->fbar), in_be32(&lbc->fpar),\n\t         in_be32(&lbc->fbcr), priv->bank);\n\n\tctrl->irq_status = 0;\n\t \n\tout_be32(&lbc->lsor, priv->bank);\n\n\t \n\twait_event_timeout(ctrl->irq_wait, ctrl->irq_status,\n\t                   FCM_TIMEOUT_MSECS * HZ/1000);\n\telbc_fcm_ctrl->status = ctrl->irq_status;\n\t \n\tif (elbc_fcm_ctrl->use_mdr)\n\t\telbc_fcm_ctrl->mdr = in_be32(&lbc->mdr);\n\n\telbc_fcm_ctrl->use_mdr = 0;\n\n\tif (elbc_fcm_ctrl->status != LTESR_CC) {\n\t\tdev_info(priv->dev,\n\t\t         \"command failed: fir %x fcr %x status %x mdr %x\\n\",\n\t\t         in_be32(&lbc->fir), in_be32(&lbc->fcr),\n\t\t\t elbc_fcm_ctrl->status, elbc_fcm_ctrl->mdr);\n\t\treturn -EIO;\n\t}\n\n\tif (chip->ecc.engine_type != NAND_ECC_ENGINE_TYPE_ON_HOST)\n\t\treturn 0;\n\n\telbc_fcm_ctrl->max_bitflips = 0;\n\n\tif (elbc_fcm_ctrl->read_bytes == mtd->writesize + mtd->oobsize) {\n\t\tuint32_t lteccr = in_be32(&lbc->lteccr);\n\t\t \n\t\tif (lteccr & 0x000F000F)\n\t\t\tout_be32(&lbc->lteccr, 0x000F000F);  \n\t\tif (lteccr & 0x000F0000) {\n\t\t\tmtd->ecc_stats.corrected++;\n\t\t\telbc_fcm_ctrl->max_bitflips = 1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void fsl_elbc_do_read(struct nand_chip *chip, int oob)\n{\n\tstruct fsl_elbc_mtd *priv = nand_get_controller_data(chip);\n\tstruct fsl_lbc_ctrl *ctrl = priv->ctrl;\n\tstruct fsl_lbc_regs __iomem *lbc = ctrl->regs;\n\n\tif (priv->page_size) {\n\t\tout_be32(&lbc->fir,\n\t\t         (FIR_OP_CM0 << FIR_OP0_SHIFT) |\n\t\t         (FIR_OP_CA  << FIR_OP1_SHIFT) |\n\t\t         (FIR_OP_PA  << FIR_OP2_SHIFT) |\n\t\t         (FIR_OP_CM1 << FIR_OP3_SHIFT) |\n\t\t         (FIR_OP_RBW << FIR_OP4_SHIFT));\n\n\t\tout_be32(&lbc->fcr, (NAND_CMD_READ0 << FCR_CMD0_SHIFT) |\n\t\t                    (NAND_CMD_READSTART << FCR_CMD1_SHIFT));\n\t} else {\n\t\tout_be32(&lbc->fir,\n\t\t         (FIR_OP_CM0 << FIR_OP0_SHIFT) |\n\t\t         (FIR_OP_CA  << FIR_OP1_SHIFT) |\n\t\t         (FIR_OP_PA  << FIR_OP2_SHIFT) |\n\t\t         (FIR_OP_RBW << FIR_OP3_SHIFT));\n\n\t\tif (oob)\n\t\t\tout_be32(&lbc->fcr, NAND_CMD_READOOB << FCR_CMD0_SHIFT);\n\t\telse\n\t\t\tout_be32(&lbc->fcr, NAND_CMD_READ0 << FCR_CMD0_SHIFT);\n\t}\n}\n\n \nstatic void fsl_elbc_cmdfunc(struct nand_chip *chip, unsigned int command,\n                             int column, int page_addr)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tstruct fsl_elbc_mtd *priv = nand_get_controller_data(chip);\n\tstruct fsl_lbc_ctrl *ctrl = priv->ctrl;\n\tstruct fsl_elbc_fcm_ctrl *elbc_fcm_ctrl = ctrl->nand;\n\tstruct fsl_lbc_regs __iomem *lbc = ctrl->regs;\n\n\telbc_fcm_ctrl->use_mdr = 0;\n\n\t \n\telbc_fcm_ctrl->read_bytes = 0;\n\tif (command != NAND_CMD_PAGEPROG)\n\t\telbc_fcm_ctrl->index = 0;\n\n\tswitch (command) {\n\t \n\tcase NAND_CMD_READ1:\n\t\tcolumn += 256;\n\t\tfallthrough;\n\tcase NAND_CMD_READ0:\n\t\tdev_dbg(priv->dev,\n\t\t        \"fsl_elbc_cmdfunc: NAND_CMD_READ0, page_addr:\"\n\t\t        \" 0x%x, column: 0x%x.\\n\", page_addr, column);\n\n\n\t\tout_be32(&lbc->fbcr, 0);  \n\t\tset_addr(mtd, 0, page_addr, 0);\n\n\t\telbc_fcm_ctrl->read_bytes = mtd->writesize + mtd->oobsize;\n\t\telbc_fcm_ctrl->index += column;\n\n\t\tfsl_elbc_do_read(chip, 0);\n\t\tfsl_elbc_run_command(mtd);\n\t\treturn;\n\n\t \n\tcase NAND_CMD_RNDOUT:\n\t\tdev_dbg(priv->dev,\n\t\t\t\"fsl_elbc_cmdfunc: NAND_CMD_RNDOUT, column: 0x%x.\\n\",\n\t\t\tcolumn);\n\n\t\telbc_fcm_ctrl->index = column;\n\t\treturn;\n\n\t \n\tcase NAND_CMD_READOOB:\n\t\tdev_vdbg(priv->dev,\n\t\t         \"fsl_elbc_cmdfunc: NAND_CMD_READOOB, page_addr:\"\n\t\t\t \" 0x%x, column: 0x%x.\\n\", page_addr, column);\n\n\t\tout_be32(&lbc->fbcr, mtd->oobsize - column);\n\t\tset_addr(mtd, column, page_addr, 1);\n\n\t\telbc_fcm_ctrl->read_bytes = mtd->writesize + mtd->oobsize;\n\n\t\tfsl_elbc_do_read(chip, 1);\n\t\tfsl_elbc_run_command(mtd);\n\t\treturn;\n\n\tcase NAND_CMD_READID:\n\tcase NAND_CMD_PARAM:\n\t\tdev_vdbg(priv->dev, \"fsl_elbc_cmdfunc: NAND_CMD %x\\n\", command);\n\n\t\tout_be32(&lbc->fir, (FIR_OP_CM0 << FIR_OP0_SHIFT) |\n\t\t                    (FIR_OP_UA  << FIR_OP1_SHIFT) |\n\t\t                    (FIR_OP_RBW << FIR_OP2_SHIFT));\n\t\tout_be32(&lbc->fcr, command << FCR_CMD0_SHIFT);\n\t\t \n\t\tout_be32(&lbc->fbcr, 256);\n\t\telbc_fcm_ctrl->read_bytes = 256;\n\t\telbc_fcm_ctrl->use_mdr = 1;\n\t\telbc_fcm_ctrl->mdr = column;\n\t\tset_addr(mtd, 0, 0, 0);\n\t\tfsl_elbc_run_command(mtd);\n\t\treturn;\n\n\t \n\tcase NAND_CMD_ERASE1:\n\t\tdev_vdbg(priv->dev,\n\t\t         \"fsl_elbc_cmdfunc: NAND_CMD_ERASE1, \"\n\t\t         \"page_addr: 0x%x.\\n\", page_addr);\n\t\tset_addr(mtd, 0, page_addr, 0);\n\t\treturn;\n\n\t \n\tcase NAND_CMD_ERASE2:\n\t\tdev_vdbg(priv->dev, \"fsl_elbc_cmdfunc: NAND_CMD_ERASE2.\\n\");\n\n\t\tout_be32(&lbc->fir,\n\t\t         (FIR_OP_CM0 << FIR_OP0_SHIFT) |\n\t\t         (FIR_OP_PA  << FIR_OP1_SHIFT) |\n\t\t         (FIR_OP_CM2 << FIR_OP2_SHIFT) |\n\t\t         (FIR_OP_CW1 << FIR_OP3_SHIFT) |\n\t\t         (FIR_OP_RS  << FIR_OP4_SHIFT));\n\n\t\tout_be32(&lbc->fcr,\n\t\t         (NAND_CMD_ERASE1 << FCR_CMD0_SHIFT) |\n\t\t         (NAND_CMD_STATUS << FCR_CMD1_SHIFT) |\n\t\t         (NAND_CMD_ERASE2 << FCR_CMD2_SHIFT));\n\n\t\tout_be32(&lbc->fbcr, 0);\n\t\telbc_fcm_ctrl->read_bytes = 0;\n\t\telbc_fcm_ctrl->use_mdr = 1;\n\n\t\tfsl_elbc_run_command(mtd);\n\t\treturn;\n\n\t \n\tcase NAND_CMD_SEQIN: {\n\t\t__be32 fcr;\n\t\tdev_vdbg(priv->dev,\n\t\t\t \"fsl_elbc_cmdfunc: NAND_CMD_SEQIN/PAGE_PROG, \"\n\t\t         \"page_addr: 0x%x, column: 0x%x.\\n\",\n\t\t         page_addr, column);\n\n\t\telbc_fcm_ctrl->column = column;\n\t\telbc_fcm_ctrl->use_mdr = 1;\n\n\t\tif (column >= mtd->writesize) {\n\t\t\t \n\t\t\tcolumn -= mtd->writesize;\n\t\t\telbc_fcm_ctrl->oob = 1;\n\t\t} else {\n\t\t\tWARN_ON(column != 0);\n\t\t\telbc_fcm_ctrl->oob = 0;\n\t\t}\n\n\t\tfcr = (NAND_CMD_STATUS   << FCR_CMD1_SHIFT) |\n\t\t      (NAND_CMD_SEQIN    << FCR_CMD2_SHIFT) |\n\t\t      (NAND_CMD_PAGEPROG << FCR_CMD3_SHIFT);\n\n\t\tif (priv->page_size) {\n\t\t\tout_be32(&lbc->fir,\n\t\t\t         (FIR_OP_CM2 << FIR_OP0_SHIFT) |\n\t\t\t         (FIR_OP_CA  << FIR_OP1_SHIFT) |\n\t\t\t         (FIR_OP_PA  << FIR_OP2_SHIFT) |\n\t\t\t         (FIR_OP_WB  << FIR_OP3_SHIFT) |\n\t\t\t         (FIR_OP_CM3 << FIR_OP4_SHIFT) |\n\t\t\t         (FIR_OP_CW1 << FIR_OP5_SHIFT) |\n\t\t\t         (FIR_OP_RS  << FIR_OP6_SHIFT));\n\t\t} else {\n\t\t\tout_be32(&lbc->fir,\n\t\t\t         (FIR_OP_CM0 << FIR_OP0_SHIFT) |\n\t\t\t         (FIR_OP_CM2 << FIR_OP1_SHIFT) |\n\t\t\t         (FIR_OP_CA  << FIR_OP2_SHIFT) |\n\t\t\t         (FIR_OP_PA  << FIR_OP3_SHIFT) |\n\t\t\t         (FIR_OP_WB  << FIR_OP4_SHIFT) |\n\t\t\t         (FIR_OP_CM3 << FIR_OP5_SHIFT) |\n\t\t\t         (FIR_OP_CW1 << FIR_OP6_SHIFT) |\n\t\t\t         (FIR_OP_RS  << FIR_OP7_SHIFT));\n\n\t\t\tif (elbc_fcm_ctrl->oob)\n\t\t\t\t \n\t\t\t\tfcr |= NAND_CMD_READOOB << FCR_CMD0_SHIFT;\n\t\t\telse\n\t\t\t\t \n\t\t\t\tfcr |= NAND_CMD_READ0 << FCR_CMD0_SHIFT;\n\t\t}\n\n\t\tout_be32(&lbc->fcr, fcr);\n\t\tset_addr(mtd, column, page_addr, elbc_fcm_ctrl->oob);\n\t\treturn;\n\t}\n\n\t \n\tcase NAND_CMD_PAGEPROG: {\n\t\tdev_vdbg(priv->dev,\n\t\t         \"fsl_elbc_cmdfunc: NAND_CMD_PAGEPROG \"\n\t\t\t \"writing %d bytes.\\n\", elbc_fcm_ctrl->index);\n\n\t\t \n\t\tif (elbc_fcm_ctrl->oob || elbc_fcm_ctrl->column != 0 ||\n\t\t    elbc_fcm_ctrl->index != mtd->writesize + mtd->oobsize)\n\t\t\tout_be32(&lbc->fbcr,\n\t\t\t\telbc_fcm_ctrl->index - elbc_fcm_ctrl->column);\n\t\telse\n\t\t\tout_be32(&lbc->fbcr, 0);\n\n\t\tfsl_elbc_run_command(mtd);\n\t\treturn;\n\t}\n\n\t \n\t \n\tcase NAND_CMD_STATUS:\n\t\tout_be32(&lbc->fir,\n\t\t         (FIR_OP_CM0 << FIR_OP0_SHIFT) |\n\t\t         (FIR_OP_RBW << FIR_OP1_SHIFT));\n\t\tout_be32(&lbc->fcr, NAND_CMD_STATUS << FCR_CMD0_SHIFT);\n\t\tout_be32(&lbc->fbcr, 1);\n\t\tset_addr(mtd, 0, 0, 0);\n\t\telbc_fcm_ctrl->read_bytes = 1;\n\n\t\tfsl_elbc_run_command(mtd);\n\n\t\t \n\t\tsetbits8(elbc_fcm_ctrl->addr, NAND_STATUS_WP);\n\t\treturn;\n\n\t \n\tcase NAND_CMD_RESET:\n\t\tdev_dbg(priv->dev, \"fsl_elbc_cmdfunc: NAND_CMD_RESET.\\n\");\n\t\tout_be32(&lbc->fir, FIR_OP_CM0 << FIR_OP0_SHIFT);\n\t\tout_be32(&lbc->fcr, NAND_CMD_RESET << FCR_CMD0_SHIFT);\n\t\tfsl_elbc_run_command(mtd);\n\t\treturn;\n\n\tdefault:\n\t\tdev_err(priv->dev,\n\t\t        \"fsl_elbc_cmdfunc: error, unsupported command 0x%x.\\n\",\n\t\t        command);\n\t}\n}\n\nstatic void fsl_elbc_select_chip(struct nand_chip *chip, int cs)\n{\n\t \n}\n\n \nstatic void fsl_elbc_write_buf(struct nand_chip *chip, const u8 *buf, int len)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tstruct fsl_elbc_mtd *priv = nand_get_controller_data(chip);\n\tstruct fsl_elbc_fcm_ctrl *elbc_fcm_ctrl = priv->ctrl->nand;\n\tunsigned int bufsize = mtd->writesize + mtd->oobsize;\n\n\tif (len <= 0) {\n\t\tdev_err(priv->dev, \"write_buf of %d bytes\", len);\n\t\telbc_fcm_ctrl->status = 0;\n\t\treturn;\n\t}\n\n\tif ((unsigned int)len > bufsize - elbc_fcm_ctrl->index) {\n\t\tdev_err(priv->dev,\n\t\t        \"write_buf beyond end of buffer \"\n\t\t        \"(%d requested, %u available)\\n\",\n\t\t\tlen, bufsize - elbc_fcm_ctrl->index);\n\t\tlen = bufsize - elbc_fcm_ctrl->index;\n\t}\n\n\tmemcpy_toio(&elbc_fcm_ctrl->addr[elbc_fcm_ctrl->index], buf, len);\n\t \n\tin_8(&elbc_fcm_ctrl->addr[elbc_fcm_ctrl->index] + len - 1);\n\n\telbc_fcm_ctrl->index += len;\n}\n\n \nstatic u8 fsl_elbc_read_byte(struct nand_chip *chip)\n{\n\tstruct fsl_elbc_mtd *priv = nand_get_controller_data(chip);\n\tstruct fsl_elbc_fcm_ctrl *elbc_fcm_ctrl = priv->ctrl->nand;\n\n\t \n\tif (elbc_fcm_ctrl->index < elbc_fcm_ctrl->read_bytes)\n\t\treturn in_8(&elbc_fcm_ctrl->addr[elbc_fcm_ctrl->index++]);\n\n\tdev_err(priv->dev, \"read_byte beyond end of buffer\\n\");\n\treturn ERR_BYTE;\n}\n\n \nstatic void fsl_elbc_read_buf(struct nand_chip *chip, u8 *buf, int len)\n{\n\tstruct fsl_elbc_mtd *priv = nand_get_controller_data(chip);\n\tstruct fsl_elbc_fcm_ctrl *elbc_fcm_ctrl = priv->ctrl->nand;\n\tint avail;\n\n\tif (len < 0)\n\t\treturn;\n\n\tavail = min((unsigned int)len,\n\t\t\telbc_fcm_ctrl->read_bytes - elbc_fcm_ctrl->index);\n\tmemcpy_fromio(buf, &elbc_fcm_ctrl->addr[elbc_fcm_ctrl->index], avail);\n\telbc_fcm_ctrl->index += avail;\n\n\tif (len > avail)\n\t\tdev_err(priv->dev,\n\t\t        \"read_buf beyond end of buffer \"\n\t\t        \"(%d requested, %d available)\\n\",\n\t\t        len, avail);\n}\n\n \nstatic int fsl_elbc_wait(struct nand_chip *chip)\n{\n\tstruct fsl_elbc_mtd *priv = nand_get_controller_data(chip);\n\tstruct fsl_elbc_fcm_ctrl *elbc_fcm_ctrl = priv->ctrl->nand;\n\n\tif (elbc_fcm_ctrl->status != LTESR_CC)\n\t\treturn NAND_STATUS_FAIL;\n\n\t \n\treturn (elbc_fcm_ctrl->mdr & 0xff) | NAND_STATUS_WP;\n}\n\nstatic int fsl_elbc_read_page(struct nand_chip *chip, uint8_t *buf,\n\t\t\t      int oob_required, int page)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tstruct fsl_elbc_mtd *priv = nand_get_controller_data(chip);\n\tstruct fsl_lbc_ctrl *ctrl = priv->ctrl;\n\tstruct fsl_elbc_fcm_ctrl *elbc_fcm_ctrl = ctrl->nand;\n\n\tnand_read_page_op(chip, page, 0, buf, mtd->writesize);\n\tif (oob_required)\n\t\tfsl_elbc_read_buf(chip, chip->oob_poi, mtd->oobsize);\n\n\tif (fsl_elbc_wait(chip) & NAND_STATUS_FAIL)\n\t\tmtd->ecc_stats.failed++;\n\n\treturn elbc_fcm_ctrl->max_bitflips;\n}\n\n \nstatic int fsl_elbc_write_page(struct nand_chip *chip, const uint8_t *buf,\n\t\t\t       int oob_required, int page)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\n\tnand_prog_page_begin_op(chip, page, 0, buf, mtd->writesize);\n\tfsl_elbc_write_buf(chip, chip->oob_poi, mtd->oobsize);\n\n\treturn nand_prog_page_end_op(chip);\n}\n\n \nstatic int fsl_elbc_write_subpage(struct nand_chip *chip, uint32_t offset,\n\t\t\t\t  uint32_t data_len, const uint8_t *buf,\n\t\t\t\t  int oob_required, int page)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\n\tnand_prog_page_begin_op(chip, page, 0, NULL, 0);\n\tfsl_elbc_write_buf(chip, buf, mtd->writesize);\n\tfsl_elbc_write_buf(chip, chip->oob_poi, mtd->oobsize);\n\treturn nand_prog_page_end_op(chip);\n}\n\nstatic int fsl_elbc_chip_init(struct fsl_elbc_mtd *priv)\n{\n\tstruct fsl_lbc_ctrl *ctrl = priv->ctrl;\n\tstruct fsl_lbc_regs __iomem *lbc = ctrl->regs;\n\tstruct fsl_elbc_fcm_ctrl *elbc_fcm_ctrl = ctrl->nand;\n\tstruct nand_chip *chip = &priv->chip;\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\n\tdev_dbg(priv->dev, \"eLBC Set Information for bank %d\\n\", priv->bank);\n\n\t \n\tmtd->dev.parent = priv->dev;\n\tnand_set_flash_node(chip, priv->dev->of_node);\n\n\t \n\tpriv->fmr = 15 << FMR_CWTO_SHIFT;\n\tif (in_be32(&lbc->bank[priv->bank].or) & OR_FCM_PGS)\n\t\tpriv->fmr |= FMR_ECCM;\n\n\t \n\t \n\tchip->legacy.read_byte = fsl_elbc_read_byte;\n\tchip->legacy.write_buf = fsl_elbc_write_buf;\n\tchip->legacy.read_buf = fsl_elbc_read_buf;\n\tchip->legacy.select_chip = fsl_elbc_select_chip;\n\tchip->legacy.cmdfunc = fsl_elbc_cmdfunc;\n\tchip->legacy.waitfunc = fsl_elbc_wait;\n\tchip->legacy.set_features = nand_get_set_features_notsupp;\n\tchip->legacy.get_features = nand_get_set_features_notsupp;\n\n\tchip->bbt_td = &bbt_main_descr;\n\tchip->bbt_md = &bbt_mirror_descr;\n\n\t \n\tchip->bbt_options = NAND_BBT_USE_FLASH;\n\n\tchip->controller = &elbc_fcm_ctrl->controller;\n\tnand_set_controller_data(chip, priv);\n\n\treturn 0;\n}\n\nstatic int fsl_elbc_attach_chip(struct nand_chip *chip)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tstruct fsl_elbc_mtd *priv = nand_get_controller_data(chip);\n\tstruct fsl_lbc_ctrl *ctrl = priv->ctrl;\n\tstruct fsl_lbc_regs __iomem *lbc = ctrl->regs;\n\tunsigned int al;\n\tu32 br;\n\n\t \n\tif (chip->ecc.engine_type == NAND_ECC_ENGINE_TYPE_INVALID) {\n\t\t \n\t\tif ((in_be32(&lbc->bank[priv->bank].br) & BR_DECC) ==\n\t\t    BR_DECC_CHK_GEN) {\n\t\t\tchip->ecc.engine_type = NAND_ECC_ENGINE_TYPE_ON_HOST;\n\t\t} else {\n\t\t\t \n\t\t\tchip->ecc.engine_type = NAND_ECC_ENGINE_TYPE_SOFT;\n\t\t\tchip->ecc.algo = NAND_ECC_ALGO_HAMMING;\n\t\t}\n\t}\n\n\tswitch (chip->ecc.engine_type) {\n\t \n\tcase NAND_ECC_ENGINE_TYPE_ON_HOST:\n\t\tchip->ecc.read_page = fsl_elbc_read_page;\n\t\tchip->ecc.write_page = fsl_elbc_write_page;\n\t\tchip->ecc.write_subpage = fsl_elbc_write_subpage;\n\t\tmtd_set_ooblayout(mtd, &fsl_elbc_ooblayout_ops);\n\t\tchip->ecc.size = 512;\n\t\tchip->ecc.bytes = 3;\n\t\tchip->ecc.strength = 1;\n\t\tbreak;\n\n\t \n\tcase NAND_ECC_ENGINE_TYPE_NONE:\n\tcase NAND_ECC_ENGINE_TYPE_SOFT:\n\tcase NAND_ECC_ENGINE_TYPE_ON_DIE:\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tbr = in_be32(&lbc->bank[priv->bank].br) & ~BR_DECC;\n\tif (chip->ecc.engine_type == NAND_ECC_ENGINE_TYPE_ON_HOST)\n\t\tout_be32(&lbc->bank[priv->bank].br, br | BR_DECC_CHK_GEN);\n\telse\n\t\tout_be32(&lbc->bank[priv->bank].br, br | BR_DECC_OFF);\n\n\t \n\tal = 0;\n\tif (chip->pagemask & 0xffff0000)\n\t\tal++;\n\tif (chip->pagemask & 0xff000000)\n\t\tal++;\n\n\tpriv->fmr |= al << FMR_AL_SHIFT;\n\n\tdev_dbg(priv->dev, \"fsl_elbc_init: nand->numchips = %d\\n\",\n\t        nanddev_ntargets(&chip->base));\n\tdev_dbg(priv->dev, \"fsl_elbc_init: nand->chipsize = %lld\\n\",\n\t        nanddev_target_size(&chip->base));\n\tdev_dbg(priv->dev, \"fsl_elbc_init: nand->pagemask = %8x\\n\",\n\t        chip->pagemask);\n\tdev_dbg(priv->dev, \"fsl_elbc_init: nand->legacy.chip_delay = %d\\n\",\n\t        chip->legacy.chip_delay);\n\tdev_dbg(priv->dev, \"fsl_elbc_init: nand->badblockpos = %d\\n\",\n\t        chip->badblockpos);\n\tdev_dbg(priv->dev, \"fsl_elbc_init: nand->chip_shift = %d\\n\",\n\t        chip->chip_shift);\n\tdev_dbg(priv->dev, \"fsl_elbc_init: nand->page_shift = %d\\n\",\n\t        chip->page_shift);\n\tdev_dbg(priv->dev, \"fsl_elbc_init: nand->phys_erase_shift = %d\\n\",\n\t        chip->phys_erase_shift);\n\tdev_dbg(priv->dev, \"fsl_elbc_init: nand->ecc.engine_type = %d\\n\",\n\t\tchip->ecc.engine_type);\n\tdev_dbg(priv->dev, \"fsl_elbc_init: nand->ecc.steps = %d\\n\",\n\t        chip->ecc.steps);\n\tdev_dbg(priv->dev, \"fsl_elbc_init: nand->ecc.bytes = %d\\n\",\n\t        chip->ecc.bytes);\n\tdev_dbg(priv->dev, \"fsl_elbc_init: nand->ecc.total = %d\\n\",\n\t        chip->ecc.total);\n\tdev_dbg(priv->dev, \"fsl_elbc_init: mtd->ooblayout = %p\\n\",\n\t\tmtd->ooblayout);\n\tdev_dbg(priv->dev, \"fsl_elbc_init: mtd->flags = %08x\\n\", mtd->flags);\n\tdev_dbg(priv->dev, \"fsl_elbc_init: mtd->size = %lld\\n\", mtd->size);\n\tdev_dbg(priv->dev, \"fsl_elbc_init: mtd->erasesize = %d\\n\",\n\t        mtd->erasesize);\n\tdev_dbg(priv->dev, \"fsl_elbc_init: mtd->writesize = %d\\n\",\n\t        mtd->writesize);\n\tdev_dbg(priv->dev, \"fsl_elbc_init: mtd->oobsize = %d\\n\",\n\t        mtd->oobsize);\n\n\t \n\tif (mtd->writesize == 512) {\n\t\tpriv->page_size = 0;\n\t\tclrbits32(&lbc->bank[priv->bank].or, OR_FCM_PGS);\n\t} else if (mtd->writesize == 2048) {\n\t\tpriv->page_size = 1;\n\t\tsetbits32(&lbc->bank[priv->bank].or, OR_FCM_PGS);\n\t} else {\n\t\tdev_err(priv->dev,\n\t\t        \"fsl_elbc_init: page size %d is not supported\\n\",\n\t\t        mtd->writesize);\n\t\treturn -ENOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct nand_controller_ops fsl_elbc_controller_ops = {\n\t.attach_chip = fsl_elbc_attach_chip,\n};\n\nstatic int fsl_elbc_chip_remove(struct fsl_elbc_mtd *priv)\n{\n\tstruct fsl_elbc_fcm_ctrl *elbc_fcm_ctrl = priv->ctrl->nand;\n\tstruct mtd_info *mtd = nand_to_mtd(&priv->chip);\n\n\tkfree(mtd->name);\n\n\tif (priv->vbase)\n\t\tiounmap(priv->vbase);\n\n\telbc_fcm_ctrl->chips[priv->bank] = NULL;\n\tkfree(priv);\n\treturn 0;\n}\n\nstatic DEFINE_MUTEX(fsl_elbc_nand_mutex);\n\nstatic int fsl_elbc_nand_probe(struct platform_device *pdev)\n{\n\tstruct fsl_lbc_regs __iomem *lbc;\n\tstruct fsl_elbc_mtd *priv;\n\tstruct resource res;\n\tstruct fsl_elbc_fcm_ctrl *elbc_fcm_ctrl;\n\tstatic const char *part_probe_types[]\n\t\t= { \"cmdlinepart\", \"RedBoot\", \"ofpart\", NULL };\n\tint ret;\n\tint bank;\n\tstruct device *dev;\n\tstruct device_node *node = pdev->dev.of_node;\n\tstruct mtd_info *mtd;\n\n\tif (!fsl_lbc_ctrl_dev || !fsl_lbc_ctrl_dev->regs)\n\t\treturn -ENODEV;\n\tlbc = fsl_lbc_ctrl_dev->regs;\n\tdev = fsl_lbc_ctrl_dev->dev;\n\n\t \n\tret = of_address_to_resource(node, 0, &res);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to get resource\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tfor (bank = 0; bank < MAX_BANKS; bank++)\n\t\tif ((in_be32(&lbc->bank[bank].br) & BR_V) &&\n\t\t    (in_be32(&lbc->bank[bank].br) & BR_MSEL) == BR_MS_FCM &&\n\t\t    (in_be32(&lbc->bank[bank].br) &\n\t\t     in_be32(&lbc->bank[bank].or) & BR_BA)\n\t\t     == fsl_lbc_addr(res.start))\n\t\t\tbreak;\n\n\tif (bank >= MAX_BANKS) {\n\t\tdev_err(dev, \"address did not match any chip selects\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tpriv = kzalloc(sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tmutex_lock(&fsl_elbc_nand_mutex);\n\tif (!fsl_lbc_ctrl_dev->nand) {\n\t\telbc_fcm_ctrl = kzalloc(sizeof(*elbc_fcm_ctrl), GFP_KERNEL);\n\t\tif (!elbc_fcm_ctrl) {\n\t\t\tmutex_unlock(&fsl_elbc_nand_mutex);\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err;\n\t\t}\n\t\telbc_fcm_ctrl->counter++;\n\n\t\tnand_controller_init(&elbc_fcm_ctrl->controller);\n\t\tfsl_lbc_ctrl_dev->nand = elbc_fcm_ctrl;\n\t} else {\n\t\telbc_fcm_ctrl = fsl_lbc_ctrl_dev->nand;\n\t}\n\tmutex_unlock(&fsl_elbc_nand_mutex);\n\n\telbc_fcm_ctrl->chips[bank] = priv;\n\tpriv->bank = bank;\n\tpriv->ctrl = fsl_lbc_ctrl_dev;\n\tpriv->dev = &pdev->dev;\n\tdev_set_drvdata(priv->dev, priv);\n\n\tpriv->vbase = ioremap(res.start, resource_size(&res));\n\tif (!priv->vbase) {\n\t\tdev_err(dev, \"failed to map chip region\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tmtd = nand_to_mtd(&priv->chip);\n\tmtd->name = kasprintf(GFP_KERNEL, \"%llx.flash\", (u64)res.start);\n\tif (!nand_to_mtd(&priv->chip)->name) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tret = fsl_elbc_chip_init(priv);\n\tif (ret)\n\t\tgoto err;\n\n\tpriv->chip.controller->ops = &fsl_elbc_controller_ops;\n\tret = nand_scan(&priv->chip, 1);\n\tif (ret)\n\t\tgoto err;\n\n\t \n\tret = mtd_device_parse_register(mtd, part_probe_types, NULL, NULL, 0);\n\tif (ret)\n\t\tgoto cleanup_nand;\n\n\tpr_info(\"eLBC NAND device at 0x%llx, bank %d\\n\",\n\t\t(unsigned long long)res.start, priv->bank);\n\n\treturn 0;\n\ncleanup_nand:\n\tnand_cleanup(&priv->chip);\nerr:\n\tfsl_elbc_chip_remove(priv);\n\n\treturn ret;\n}\n\nstatic void fsl_elbc_nand_remove(struct platform_device *pdev)\n{\n\tstruct fsl_elbc_fcm_ctrl *elbc_fcm_ctrl = fsl_lbc_ctrl_dev->nand;\n\tstruct fsl_elbc_mtd *priv = dev_get_drvdata(&pdev->dev);\n\tstruct nand_chip *chip = &priv->chip;\n\tint ret;\n\n\tret = mtd_device_unregister(nand_to_mtd(chip));\n\tWARN_ON(ret);\n\tnand_cleanup(chip);\n\n\tfsl_elbc_chip_remove(priv);\n\n\tmutex_lock(&fsl_elbc_nand_mutex);\n\telbc_fcm_ctrl->counter--;\n\tif (!elbc_fcm_ctrl->counter) {\n\t\tfsl_lbc_ctrl_dev->nand = NULL;\n\t\tkfree(elbc_fcm_ctrl);\n\t}\n\tmutex_unlock(&fsl_elbc_nand_mutex);\n\n}\n\nstatic const struct of_device_id fsl_elbc_nand_match[] = {\n\t{ .compatible = \"fsl,elbc-fcm-nand\", },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, fsl_elbc_nand_match);\n\nstatic struct platform_driver fsl_elbc_nand_driver = {\n\t.driver = {\n\t\t.name = \"fsl,elbc-fcm-nand\",\n\t\t.of_match_table = fsl_elbc_nand_match,\n\t},\n\t.probe = fsl_elbc_nand_probe,\n\t.remove_new = fsl_elbc_nand_remove,\n};\n\nmodule_platform_driver(fsl_elbc_nand_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Freescale\");\nMODULE_DESCRIPTION(\"Freescale Enhanced Local Bus Controller MTD NAND driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}