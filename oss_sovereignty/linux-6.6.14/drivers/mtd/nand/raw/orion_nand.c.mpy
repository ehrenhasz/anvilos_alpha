{
  "module_name": "orion_nand.c",
  "hash_id": "fa336375519b82c7d2b03075121c4d1ee09913ea6bda9fd56cff3af521cfe21c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/nand/raw/orion_nand.c",
  "human_readable_source": " \n\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/of.h>\n#include <linux/mtd/mtd.h>\n#include <linux/mtd/rawnand.h>\n#include <linux/mtd/partitions.h>\n#include <linux/clk.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/sizes.h>\n#include <linux/platform_data/mtd-orion_nand.h>\n\nstruct orion_nand_info {\n\tstruct nand_controller controller;\n\tstruct nand_chip chip;\n\tstruct clk *clk;\n};\n\nstatic void orion_nand_cmd_ctrl(struct nand_chip *nc, int cmd,\n\t\t\t\tunsigned int ctrl)\n{\n\tstruct orion_nand_data *board = nand_get_controller_data(nc);\n\tu32 offs;\n\n\tif (cmd == NAND_CMD_NONE)\n\t\treturn;\n\n\tif (ctrl & NAND_CLE)\n\t\toffs = (1 << board->cle);\n\telse if (ctrl & NAND_ALE)\n\t\toffs = (1 << board->ale);\n\telse\n\t\treturn;\n\n\tif (nc->options & NAND_BUSWIDTH_16)\n\t\toffs <<= 1;\n\n\twriteb(cmd, nc->legacy.IO_ADDR_W + offs);\n}\n\nstatic void orion_nand_read_buf(struct nand_chip *chip, uint8_t *buf, int len)\n{\n\tvoid __iomem *io_base = chip->legacy.IO_ADDR_R;\n#if defined(__LINUX_ARM_ARCH__) && __LINUX_ARM_ARCH__ >= 5\n\tuint64_t *buf64;\n#endif\n\tint i = 0;\n\n\twhile (len && (unsigned long)buf & 7) {\n\t\t*buf++ = readb(io_base);\n\t\tlen--;\n\t}\n#if defined(__LINUX_ARM_ARCH__) && __LINUX_ARM_ARCH__ >= 5\n\tbuf64 = (uint64_t *)buf;\n\twhile (i < len/8) {\n\t\t \n\t\tregister uint64_t x asm (\"r2\");\n\n\t\tasm volatile (\"ldrd\\t%0, [%1]\" : \"=&r\" (x) : \"r\" (io_base));\n\t\tbuf64[i++] = x;\n\t}\n\ti *= 8;\n#else\n\treadsl(io_base, buf, len/4);\n\ti = len / 4 * 4;\n#endif\n\twhile (i < len)\n\t\tbuf[i++] = readb(io_base);\n}\n\nstatic int orion_nand_attach_chip(struct nand_chip *chip)\n{\n\tif (chip->ecc.engine_type == NAND_ECC_ENGINE_TYPE_SOFT &&\n\t    chip->ecc.algo == NAND_ECC_ALGO_UNKNOWN)\n\t\tchip->ecc.algo = NAND_ECC_ALGO_HAMMING;\n\n\treturn 0;\n}\n\nstatic const struct nand_controller_ops orion_nand_ops = {\n\t.attach_chip = orion_nand_attach_chip,\n};\n\nstatic int __init orion_nand_probe(struct platform_device *pdev)\n{\n\tstruct orion_nand_info *info;\n\tstruct mtd_info *mtd;\n\tstruct nand_chip *nc;\n\tstruct orion_nand_data *board;\n\tvoid __iomem *io_base;\n\tint ret = 0;\n\tu32 val = 0;\n\n\tinfo = devm_kzalloc(&pdev->dev,\n\t\t\tsizeof(struct orion_nand_info),\n\t\t\tGFP_KERNEL);\n\tif (!info)\n\t\treturn -ENOMEM;\n\tnc = &info->chip;\n\tmtd = nand_to_mtd(nc);\n\n\tnand_controller_init(&info->controller);\n\tinfo->controller.ops = &orion_nand_ops;\n\tnc->controller = &info->controller;\n\n\tio_base = devm_platform_ioremap_resource(pdev, 0);\n\n\tif (IS_ERR(io_base))\n\t\treturn PTR_ERR(io_base);\n\n\tif (pdev->dev.of_node) {\n\t\tboard = devm_kzalloc(&pdev->dev, sizeof(struct orion_nand_data),\n\t\t\t\t\tGFP_KERNEL);\n\t\tif (!board)\n\t\t\treturn -ENOMEM;\n\t\tif (!of_property_read_u32(pdev->dev.of_node, \"cle\", &val))\n\t\t\tboard->cle = (u8)val;\n\t\telse\n\t\t\tboard->cle = 0;\n\t\tif (!of_property_read_u32(pdev->dev.of_node, \"ale\", &val))\n\t\t\tboard->ale = (u8)val;\n\t\telse\n\t\t\tboard->ale = 1;\n\t\tif (!of_property_read_u32(pdev->dev.of_node,\n\t\t\t\t\t\t\"bank-width\", &val))\n\t\t\tboard->width = (u8)val * 8;\n\t\telse\n\t\t\tboard->width = 8;\n\t\tif (!of_property_read_u32(pdev->dev.of_node,\n\t\t\t\t\t\t\"chip-delay\", &val))\n\t\t\tboard->chip_delay = (u8)val;\n\t} else {\n\t\tboard = dev_get_platdata(&pdev->dev);\n\t}\n\n\tmtd->dev.parent = &pdev->dev;\n\n\tnand_set_controller_data(nc, board);\n\tnand_set_flash_node(nc, pdev->dev.of_node);\n\tnc->legacy.IO_ADDR_R = nc->legacy.IO_ADDR_W = io_base;\n\tnc->legacy.cmd_ctrl = orion_nand_cmd_ctrl;\n\tnc->legacy.read_buf = orion_nand_read_buf;\n\n\tif (board->chip_delay)\n\t\tnc->legacy.chip_delay = board->chip_delay;\n\n\tWARN(board->width > 16,\n\t\t\"%d bit bus width out of range\",\n\t\tboard->width);\n\n\tif (board->width == 16)\n\t\tnc->options |= NAND_BUSWIDTH_16;\n\n\tplatform_set_drvdata(pdev, info);\n\n\t \n\tinfo->clk = devm_clk_get_optional_enabled(&pdev->dev, NULL);\n\tif (IS_ERR(info->clk))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(info->clk),\n\t\t\t\t     \"failed to get and enable clock!\\n\");\n\n\t \n\tnc->ecc.engine_type = NAND_ECC_ENGINE_TYPE_SOFT;\n\n\tret = nand_scan(nc, 1);\n\tif (ret)\n\t\treturn ret;\n\n\tmtd->name = \"orion_nand\";\n\tret = mtd_device_register(mtd, board->parts, board->nr_parts);\n\tif (ret)\n\t\tnand_cleanup(nc);\n\n\treturn ret;\n}\n\nstatic void orion_nand_remove(struct platform_device *pdev)\n{\n\tstruct orion_nand_info *info = platform_get_drvdata(pdev);\n\tstruct nand_chip *chip = &info->chip;\n\tint ret;\n\n\tret = mtd_device_unregister(nand_to_mtd(chip));\n\tWARN_ON(ret);\n\n\tnand_cleanup(chip);\n}\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id orion_nand_of_match_table[] = {\n\t{ .compatible = \"marvell,orion-nand\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, orion_nand_of_match_table);\n#endif\n\nstatic struct platform_driver orion_nand_driver = {\n\t.remove_new\t= orion_nand_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"orion_nand\",\n\t\t.of_match_table = of_match_ptr(orion_nand_of_match_table),\n\t},\n};\n\nmodule_platform_driver_probe(orion_nand_driver, orion_nand_probe);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Tzachi Perelstein\");\nMODULE_DESCRIPTION(\"NAND glue for Orion platforms\");\nMODULE_ALIAS(\"platform:orion_nand\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}