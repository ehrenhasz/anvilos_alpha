{
  "module_name": "xway_nand.c",
  "hash_id": "021946bb07a20cd2957c8c0e2a6e0fa7326180972827a16b2f561c6c09c83efb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/nand/raw/xway_nand.c",
  "human_readable_source": "\n \n\n#include <linux/mtd/rawnand.h>\n#include <linux/of_gpio.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n\n#include <lantiq_soc.h>\n\n \n#define EBU_ADDSEL1\t\t0x24\n#define EBU_NAND_CON\t\t0xB0\n#define EBU_NAND_WAIT\t\t0xB4\n#define  NAND_WAIT_RD\t\tBIT(0)  \n#define  NAND_WAIT_WR_C\t\tBIT(3)  \n#define EBU_NAND_ECC0\t\t0xB8\n#define EBU_NAND_ECC_AC\t\t0xBC\n\n \n#define NAND_CMD_ALE\t\tBIT(2)  \n#define NAND_CMD_CLE\t\tBIT(3)  \n#define NAND_CMD_CS\t\tBIT(4)  \n#define NAND_CMD_SE\t\tBIT(5)  \n#define NAND_CMD_WP\t\tBIT(6)  \n#define NAND_WRITE_CMD\t\t(NAND_CMD_CS | NAND_CMD_CLE)\n#define NAND_WRITE_ADDR\t\t(NAND_CMD_CS | NAND_CMD_ALE)\n#define NAND_WRITE_DATA\t\t(NAND_CMD_CS)\n#define NAND_READ_DATA\t\t(NAND_CMD_CS)\n\n \n#define ADDSEL1_MASK(x)\t\t(x << 4)\n#define ADDSEL1_REGEN\t\t1\n\n \n#define BUSCON1_SETUP\t\t(1 << 22)\n#define BUSCON1_BCGEN_RES\t(0x3 << 12)\n#define BUSCON1_WAITWRC2\t(2 << 8)\n#define BUSCON1_WAITRDC2\t(2 << 6)\n#define BUSCON1_HOLDC1\t\t(1 << 4)\n#define BUSCON1_RECOVC1\t\t(1 << 2)\n#define BUSCON1_CMULT4\t\t1\n\n#define NAND_CON_CE\t\t(1 << 20)\n#define NAND_CON_OUT_CS1\t(1 << 10)\n#define NAND_CON_IN_CS1\t\t(1 << 8)\n#define NAND_CON_PRE_P\t\t(1 << 7)\n#define NAND_CON_WP_P\t\t(1 << 6)\n#define NAND_CON_SE_P\t\t(1 << 5)\n#define NAND_CON_CS_P\t\t(1 << 4)\n#define NAND_CON_CSMUX\t\t(1 << 1)\n#define NAND_CON_NANDM\t\t1\n\nstruct xway_nand_data {\n\tstruct nand_controller\tcontroller;\n\tstruct nand_chip\tchip;\n\tunsigned long\t\tcsflags;\n\tvoid __iomem\t\t*nandaddr;\n};\n\nstatic u8 xway_readb(struct mtd_info *mtd, int op)\n{\n\tstruct nand_chip *chip = mtd_to_nand(mtd);\n\tstruct xway_nand_data *data = nand_get_controller_data(chip);\n\n\treturn readb(data->nandaddr + op);\n}\n\nstatic void xway_writeb(struct mtd_info *mtd, int op, u8 value)\n{\n\tstruct nand_chip *chip = mtd_to_nand(mtd);\n\tstruct xway_nand_data *data = nand_get_controller_data(chip);\n\n\twriteb(value, data->nandaddr + op);\n}\n\nstatic void xway_select_chip(struct nand_chip *chip, int select)\n{\n\tstruct xway_nand_data *data = nand_get_controller_data(chip);\n\n\tswitch (select) {\n\tcase -1:\n\t\tltq_ebu_w32_mask(NAND_CON_CE, 0, EBU_NAND_CON);\n\t\tltq_ebu_w32_mask(NAND_CON_NANDM, 0, EBU_NAND_CON);\n\t\tspin_unlock_irqrestore(&ebu_lock, data->csflags);\n\t\tbreak;\n\tcase 0:\n\t\tspin_lock_irqsave(&ebu_lock, data->csflags);\n\t\tltq_ebu_w32_mask(0, NAND_CON_NANDM, EBU_NAND_CON);\n\t\tltq_ebu_w32_mask(0, NAND_CON_CE, EBU_NAND_CON);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}\n\nstatic void xway_cmd_ctrl(struct nand_chip *chip, int cmd, unsigned int ctrl)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\n\tif (cmd == NAND_CMD_NONE)\n\t\treturn;\n\n\tif (ctrl & NAND_CLE)\n\t\txway_writeb(mtd, NAND_WRITE_CMD, cmd);\n\telse if (ctrl & NAND_ALE)\n\t\txway_writeb(mtd, NAND_WRITE_ADDR, cmd);\n\n\twhile ((ltq_ebu_r32(EBU_NAND_WAIT) & NAND_WAIT_WR_C) == 0)\n\t\t;\n}\n\nstatic int xway_dev_ready(struct nand_chip *chip)\n{\n\treturn ltq_ebu_r32(EBU_NAND_WAIT) & NAND_WAIT_RD;\n}\n\nstatic unsigned char xway_read_byte(struct nand_chip *chip)\n{\n\treturn xway_readb(nand_to_mtd(chip), NAND_READ_DATA);\n}\n\nstatic void xway_read_buf(struct nand_chip *chip, u_char *buf, int len)\n{\n\tint i;\n\n\tfor (i = 0; i < len; i++)\n\t\tbuf[i] = xway_readb(nand_to_mtd(chip), NAND_WRITE_DATA);\n}\n\nstatic void xway_write_buf(struct nand_chip *chip, const u_char *buf, int len)\n{\n\tint i;\n\n\tfor (i = 0; i < len; i++)\n\t\txway_writeb(nand_to_mtd(chip), NAND_WRITE_DATA, buf[i]);\n}\n\nstatic int xway_attach_chip(struct nand_chip *chip)\n{\n\tif (chip->ecc.engine_type == NAND_ECC_ENGINE_TYPE_SOFT &&\n\t    chip->ecc.algo == NAND_ECC_ALGO_UNKNOWN)\n\t\tchip->ecc.algo = NAND_ECC_ALGO_HAMMING;\n\n\treturn 0;\n}\n\nstatic const struct nand_controller_ops xway_nand_ops = {\n\t.attach_chip = xway_attach_chip,\n};\n\n \nstatic int xway_nand_probe(struct platform_device *pdev)\n{\n\tstruct xway_nand_data *data;\n\tstruct mtd_info *mtd;\n\tint err;\n\tu32 cs;\n\tu32 cs_flag = 0;\n\n\t \n\tdata = devm_kzalloc(&pdev->dev, sizeof(struct xway_nand_data),\n\t\t\t    GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tdata->nandaddr = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(data->nandaddr))\n\t\treturn PTR_ERR(data->nandaddr);\n\n\tnand_set_flash_node(&data->chip, pdev->dev.of_node);\n\tmtd = nand_to_mtd(&data->chip);\n\tmtd->dev.parent = &pdev->dev;\n\n\tdata->chip.legacy.cmd_ctrl = xway_cmd_ctrl;\n\tdata->chip.legacy.dev_ready = xway_dev_ready;\n\tdata->chip.legacy.select_chip = xway_select_chip;\n\tdata->chip.legacy.write_buf = xway_write_buf;\n\tdata->chip.legacy.read_buf = xway_read_buf;\n\tdata->chip.legacy.read_byte = xway_read_byte;\n\tdata->chip.legacy.chip_delay = 30;\n\n\tnand_controller_init(&data->controller);\n\tdata->controller.ops = &xway_nand_ops;\n\tdata->chip.controller = &data->controller;\n\n\tplatform_set_drvdata(pdev, data);\n\tnand_set_controller_data(&data->chip, data);\n\n\t \n\terr = of_property_read_u32(pdev->dev.of_node, \"lantiq,cs\", &cs);\n\tif (!err && cs == 1)\n\t\tcs_flag = NAND_CON_IN_CS1 | NAND_CON_OUT_CS1;\n\n\t \n\tltq_ebu_w32(CPHYSADDR(data->nandaddr)\n\t\t    | ADDSEL1_MASK(3) | ADDSEL1_REGEN, EBU_ADDSEL1);\n\n\tltq_ebu_w32(BUSCON1_SETUP | BUSCON1_BCGEN_RES | BUSCON1_WAITWRC2\n\t\t    | BUSCON1_WAITRDC2 | BUSCON1_HOLDC1 | BUSCON1_RECOVC1\n\t\t    | BUSCON1_CMULT4, LTQ_EBU_BUSCON1);\n\n\tltq_ebu_w32(NAND_CON_NANDM | NAND_CON_CSMUX | NAND_CON_CS_P\n\t\t    | NAND_CON_SE_P | NAND_CON_WP_P | NAND_CON_PRE_P\n\t\t    | cs_flag, EBU_NAND_CON);\n\n\t \n\tdata->chip.ecc.engine_type = NAND_ECC_ENGINE_TYPE_SOFT;\n\n\t \n\terr = nand_scan(&data->chip, 1);\n\tif (err)\n\t\treturn err;\n\n\terr = mtd_device_register(mtd, NULL, 0);\n\tif (err)\n\t\tnand_cleanup(&data->chip);\n\n\treturn err;\n}\n\n \nstatic void xway_nand_remove(struct platform_device *pdev)\n{\n\tstruct xway_nand_data *data = platform_get_drvdata(pdev);\n\tstruct nand_chip *chip = &data->chip;\n\tint ret;\n\n\tret = mtd_device_unregister(nand_to_mtd(chip));\n\tWARN_ON(ret);\n\tnand_cleanup(chip);\n}\n\nstatic const struct of_device_id xway_nand_match[] = {\n\t{ .compatible = \"lantiq,nand-xway\" },\n\t{},\n};\n\nstatic struct platform_driver xway_nand_driver = {\n\t.probe\t= xway_nand_probe,\n\t.remove_new = xway_nand_remove,\n\t.driver\t= {\n\t\t.name\t\t= \"lantiq,nand-xway\",\n\t\t.of_match_table = xway_nand_match,\n\t},\n};\n\nbuiltin_platform_driver(xway_nand_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}