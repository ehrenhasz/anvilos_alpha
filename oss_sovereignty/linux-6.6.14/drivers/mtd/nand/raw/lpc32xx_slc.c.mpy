{
  "module_name": "lpc32xx_slc.c",
  "hash_id": "d506bc11aae14767ccbde5c7c77cfb189a9a73d03a62263f40dc9dc85ec55647",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/nand/raw/lpc32xx_slc.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/mtd/mtd.h>\n#include <linux/mtd/rawnand.h>\n#include <linux/mtd/partitions.h>\n#include <linux/clk.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/io.h>\n#include <linux/mm.h>\n#include <linux/dma-mapping.h>\n#include <linux/dmaengine.h>\n#include <linux/gpio/consumer.h>\n#include <linux/of.h>\n#include <linux/mtd/lpc32xx_slc.h>\n\n#define LPC32XX_MODNAME\t\t\"lpc32xx-nand\"\n\n \n\n#define SLC_DATA(x)\t\t(x + 0x000)\n#define SLC_ADDR(x)\t\t(x + 0x004)\n#define SLC_CMD(x)\t\t(x + 0x008)\n#define SLC_STOP(x)\t\t(x + 0x00C)\n#define SLC_CTRL(x)\t\t(x + 0x010)\n#define SLC_CFG(x)\t\t(x + 0x014)\n#define SLC_STAT(x)\t\t(x + 0x018)\n#define SLC_INT_STAT(x)\t\t(x + 0x01C)\n#define SLC_IEN(x)\t\t(x + 0x020)\n#define SLC_ISR(x)\t\t(x + 0x024)\n#define SLC_ICR(x)\t\t(x + 0x028)\n#define SLC_TAC(x)\t\t(x + 0x02C)\n#define SLC_TC(x)\t\t(x + 0x030)\n#define SLC_ECC(x)\t\t(x + 0x034)\n#define SLC_DMA_DATA(x)\t\t(x + 0x038)\n\n \n#define SLCCTRL_SW_RESET\t(1 << 2)  \n#define SLCCTRL_ECC_CLEAR\t(1 << 1)  \n#define SLCCTRL_DMA_START\t(1 << 0)  \n\n \n#define SLCCFG_CE_LOW\t\t(1 << 5)  \n#define SLCCFG_DMA_ECC\t\t(1 << 4)  \n#define SLCCFG_ECC_EN\t\t(1 << 3)  \n#define SLCCFG_DMA_BURST\t(1 << 2)  \n#define SLCCFG_DMA_DIR\t\t(1 << 1)  \n#define SLCCFG_WIDTH\t\t(1 << 0)  \n\n \n#define SLCSTAT_DMA_FIFO\t(1 << 2)  \n#define SLCSTAT_SLC_FIFO\t(1 << 1)  \n#define SLCSTAT_NAND_READY\t(1 << 0)  \n\n \n#define SLCSTAT_INT_TC\t\t(1 << 1)  \n#define SLCSTAT_INT_RDY_EN\t(1 << 0)  \n\n \n \n#define SLCTAC_CLOCKS(c, n, s)\t(min_t(u32, DIV_ROUND_UP(c, n) - 1, 0xF) << s)\n\n \n#define SLCTAC_WDR(n)\t\t(((n) & 0xF) << 28)\n \n#define SLCTAC_WWIDTH(c, n)\t(SLCTAC_CLOCKS(c, n, 24))\n \n#define SLCTAC_WHOLD(c, n)\t(SLCTAC_CLOCKS(c, n, 20))\n \n#define SLCTAC_WSETUP(c, n)\t(SLCTAC_CLOCKS(c, n, 16))\n \n#define SLCTAC_RDR(n)\t\t(((n) & 0xF) << 12)\n \n#define SLCTAC_RWIDTH(c, n)\t(SLCTAC_CLOCKS(c, n, 8))\n \n#define SLCTAC_RHOLD(c, n)\t(SLCTAC_CLOCKS(c, n, 4))\n \n#define SLCTAC_RSETUP(c, n)\t(SLCTAC_CLOCKS(c, n, 0))\n\n \n \n#define SLCECC_TO_LINEPAR(n)\t(((n) >> 6) & 0x7FFF)\n#define SLCECC_TO_COLPAR(n)\t((n) & 0x3F)\n\n \n#define LPC32XX_DMA_DATA_SIZE\t\t4096\n#define LPC32XX_ECC_SAVE_SIZE\t\t((4096 / 256) * 4)\n\n \n#define LPC32XX_SLC_DEV_ECC_BYTES\t3\n\n \n#define LPC32XX_DEF_BUS_RATE\t\t133250000\n\n \n#define LPC32XX_DMA_TIMEOUT\t\t100\n\n \nstatic int lpc32xx_ooblayout_ecc(struct mtd_info *mtd, int section,\n\t\t\t\t struct mtd_oob_region *oobregion)\n{\n\tif (section)\n\t\treturn -ERANGE;\n\n\toobregion->length = 6;\n\toobregion->offset = 10;\n\n\treturn 0;\n}\n\nstatic int lpc32xx_ooblayout_free(struct mtd_info *mtd, int section,\n\t\t\t\t  struct mtd_oob_region *oobregion)\n{\n\tif (section > 1)\n\t\treturn -ERANGE;\n\n\tif (!section) {\n\t\toobregion->offset = 0;\n\t\toobregion->length = 4;\n\t} else {\n\t\toobregion->offset = 6;\n\t\toobregion->length = 4;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct mtd_ooblayout_ops lpc32xx_ooblayout_ops = {\n\t.ecc = lpc32xx_ooblayout_ecc,\n\t.free = lpc32xx_ooblayout_free,\n};\n\nstatic u8 bbt_pattern[] = {'B', 'b', 't', '0' };\nstatic u8 mirror_pattern[] = {'1', 't', 'b', 'B' };\n\n \nstatic struct nand_bbt_descr bbt_smallpage_main_descr = {\n\t.options = NAND_BBT_LASTBLOCK | NAND_BBT_CREATE | NAND_BBT_WRITE\n\t\t| NAND_BBT_2BIT | NAND_BBT_VERSION | NAND_BBT_PERCHIP,\n\t.offs =\t0,\n\t.len = 4,\n\t.veroffs = 6,\n\t.maxblocks = 4,\n\t.pattern = bbt_pattern\n};\n\nstatic struct nand_bbt_descr bbt_smallpage_mirror_descr = {\n\t.options = NAND_BBT_LASTBLOCK | NAND_BBT_CREATE | NAND_BBT_WRITE\n\t\t| NAND_BBT_2BIT | NAND_BBT_VERSION | NAND_BBT_PERCHIP,\n\t.offs =\t0,\n\t.len = 4,\n\t.veroffs = 6,\n\t.maxblocks = 4,\n\t.pattern = mirror_pattern\n};\n\n \nstruct lpc32xx_nand_cfg_slc {\n\tuint32_t wdr_clks;\n\tuint32_t wwidth;\n\tuint32_t whold;\n\tuint32_t wsetup;\n\tuint32_t rdr_clks;\n\tuint32_t rwidth;\n\tuint32_t rhold;\n\tuint32_t rsetup;\n\tstruct mtd_partition *parts;\n\tunsigned num_parts;\n};\n\nstruct lpc32xx_nand_host {\n\tstruct nand_chip\tnand_chip;\n\tstruct lpc32xx_slc_platform_data *pdata;\n\tstruct clk\t\t*clk;\n\tstruct gpio_desc\t*wp_gpio;\n\tvoid __iomem\t\t*io_base;\n\tstruct lpc32xx_nand_cfg_slc *ncfg;\n\n\tstruct completion\tcomp;\n\tstruct dma_chan\t\t*dma_chan;\n\tuint32_t\t\tdma_buf_len;\n\tstruct dma_slave_config\tdma_slave_config;\n\tstruct scatterlist\tsgl;\n\n\t \n\tuint32_t\t\t*ecc_buf;\n\tuint8_t\t\t\t*data_buf;\n\tdma_addr_t\t\tio_base_dma;\n};\n\nstatic void lpc32xx_nand_setup(struct lpc32xx_nand_host *host)\n{\n\tuint32_t clkrate, tmp;\n\n\t \n\twritel(SLCCTRL_SW_RESET, SLC_CTRL(host->io_base));\n\tudelay(1000);\n\n\t \n\twritel(0, SLC_CFG(host->io_base));\n\twritel(0, SLC_IEN(host->io_base));\n\twritel((SLCSTAT_INT_TC | SLCSTAT_INT_RDY_EN),\n\t\tSLC_ICR(host->io_base));\n\n\t \n\tclkrate = clk_get_rate(host->clk);\n\tif (clkrate == 0)\n\t\tclkrate = LPC32XX_DEF_BUS_RATE;\n\n\t \n\ttmp = SLCTAC_WDR(host->ncfg->wdr_clks) |\n\t\tSLCTAC_WWIDTH(clkrate, host->ncfg->wwidth) |\n\t\tSLCTAC_WHOLD(clkrate, host->ncfg->whold) |\n\t\tSLCTAC_WSETUP(clkrate, host->ncfg->wsetup) |\n\t\tSLCTAC_RDR(host->ncfg->rdr_clks) |\n\t\tSLCTAC_RWIDTH(clkrate, host->ncfg->rwidth) |\n\t\tSLCTAC_RHOLD(clkrate, host->ncfg->rhold) |\n\t\tSLCTAC_RSETUP(clkrate, host->ncfg->rsetup);\n\twritel(tmp, SLC_TAC(host->io_base));\n}\n\n \nstatic void lpc32xx_nand_cmd_ctrl(struct nand_chip *chip, int cmd,\n\t\t\t\t  unsigned int ctrl)\n{\n\tuint32_t tmp;\n\tstruct lpc32xx_nand_host *host = nand_get_controller_data(chip);\n\n\t \n\ttmp = readl(SLC_CFG(host->io_base));\n\tif (ctrl & NAND_NCE)\n\t\ttmp |= SLCCFG_CE_LOW;\n\telse\n\t\ttmp &= ~SLCCFG_CE_LOW;\n\twritel(tmp, SLC_CFG(host->io_base));\n\n\tif (cmd != NAND_CMD_NONE) {\n\t\tif (ctrl & NAND_CLE)\n\t\t\twritel(cmd, SLC_CMD(host->io_base));\n\t\telse\n\t\t\twritel(cmd, SLC_ADDR(host->io_base));\n\t}\n}\n\n \nstatic int lpc32xx_nand_device_ready(struct nand_chip *chip)\n{\n\tstruct lpc32xx_nand_host *host = nand_get_controller_data(chip);\n\tint rdy = 0;\n\n\tif ((readl(SLC_STAT(host->io_base)) & SLCSTAT_NAND_READY) != 0)\n\t\trdy = 1;\n\n\treturn rdy;\n}\n\n \nstatic void lpc32xx_wp_enable(struct lpc32xx_nand_host *host)\n{\n\tif (host->wp_gpio)\n\t\tgpiod_set_value_cansleep(host->wp_gpio, 1);\n}\n\n \nstatic void lpc32xx_wp_disable(struct lpc32xx_nand_host *host)\n{\n\tif (host->wp_gpio)\n\t\tgpiod_set_value_cansleep(host->wp_gpio, 0);\n}\n\n \nstatic void lpc32xx_nand_ecc_enable(struct nand_chip *chip, int mode)\n{\n\t \n}\n\n \nstatic int lpc32xx_nand_ecc_calculate(struct nand_chip *chip,\n\t\t\t\t      const unsigned char *buf,\n\t\t\t\t      unsigned char *code)\n{\n\t \n\treturn 0;\n}\n\n \nstatic uint8_t lpc32xx_nand_read_byte(struct nand_chip *chip)\n{\n\tstruct lpc32xx_nand_host *host = nand_get_controller_data(chip);\n\n\treturn (uint8_t)readl(SLC_DATA(host->io_base));\n}\n\n \nstatic void lpc32xx_nand_read_buf(struct nand_chip *chip, u_char *buf, int len)\n{\n\tstruct lpc32xx_nand_host *host = nand_get_controller_data(chip);\n\n\t \n\twhile (len-- > 0)\n\t\t*buf++ = (uint8_t)readl(SLC_DATA(host->io_base));\n}\n\n \nstatic void lpc32xx_nand_write_buf(struct nand_chip *chip, const uint8_t *buf,\n\t\t\t\t   int len)\n{\n\tstruct lpc32xx_nand_host *host = nand_get_controller_data(chip);\n\n\t \n\twhile (len-- > 0)\n\t\twritel((uint32_t)*buf++, SLC_DATA(host->io_base));\n}\n\n \nstatic int lpc32xx_nand_read_oob_syndrome(struct nand_chip *chip, int page)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\n\treturn nand_read_oob_op(chip, page, 0, chip->oob_poi, mtd->oobsize);\n}\n\n \nstatic int lpc32xx_nand_write_oob_syndrome(struct nand_chip *chip, int page)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\n\treturn nand_prog_page_op(chip, page, mtd->writesize, chip->oob_poi,\n\t\t\t\t mtd->oobsize);\n}\n\n \nstatic void lpc32xx_slc_ecc_copy(uint8_t *spare, const uint32_t *ecc, int count)\n{\n\tint i;\n\n\tfor (i = 0; i < (count * 3); i += 3) {\n\t\tuint32_t ce = ecc[i / 3];\n\t\tce = ~(ce << 2) & 0xFFFFFF;\n\t\tspare[i + 2] = (uint8_t)(ce & 0xFF);\n\t\tce >>= 8;\n\t\tspare[i + 1] = (uint8_t)(ce & 0xFF);\n\t\tce >>= 8;\n\t\tspare[i] = (uint8_t)(ce & 0xFF);\n\t}\n}\n\nstatic void lpc32xx_dma_complete_func(void *completion)\n{\n\tcomplete(completion);\n}\n\nstatic int lpc32xx_xmit_dma(struct mtd_info *mtd, dma_addr_t dma,\n\t\t\t    void *mem, int len, enum dma_transfer_direction dir)\n{\n\tstruct nand_chip *chip = mtd_to_nand(mtd);\n\tstruct lpc32xx_nand_host *host = nand_get_controller_data(chip);\n\tstruct dma_async_tx_descriptor *desc;\n\tint flags = DMA_CTRL_ACK | DMA_PREP_INTERRUPT;\n\tint res;\n\n\thost->dma_slave_config.direction = dir;\n\thost->dma_slave_config.src_addr = dma;\n\thost->dma_slave_config.dst_addr = dma;\n\thost->dma_slave_config.src_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;\n\thost->dma_slave_config.dst_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;\n\thost->dma_slave_config.src_maxburst = 4;\n\thost->dma_slave_config.dst_maxburst = 4;\n\t \n\thost->dma_slave_config.device_fc = false;\n\tif (dmaengine_slave_config(host->dma_chan, &host->dma_slave_config)) {\n\t\tdev_err(mtd->dev.parent, \"Failed to setup DMA slave\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\tsg_init_one(&host->sgl, mem, len);\n\n\tres = dma_map_sg(host->dma_chan->device->dev, &host->sgl, 1,\n\t\t\t DMA_BIDIRECTIONAL);\n\tif (res != 1) {\n\t\tdev_err(mtd->dev.parent, \"Failed to map sg list\\n\");\n\t\treturn -ENXIO;\n\t}\n\tdesc = dmaengine_prep_slave_sg(host->dma_chan, &host->sgl, 1, dir,\n\t\t\t\t       flags);\n\tif (!desc) {\n\t\tdev_err(mtd->dev.parent, \"Failed to prepare slave sg\\n\");\n\t\tgoto out1;\n\t}\n\n\tinit_completion(&host->comp);\n\tdesc->callback = lpc32xx_dma_complete_func;\n\tdesc->callback_param = &host->comp;\n\n\tdmaengine_submit(desc);\n\tdma_async_issue_pending(host->dma_chan);\n\n\twait_for_completion_timeout(&host->comp, msecs_to_jiffies(1000));\n\n\tdma_unmap_sg(host->dma_chan->device->dev, &host->sgl, 1,\n\t\t     DMA_BIDIRECTIONAL);\n\n\treturn 0;\nout1:\n\tdma_unmap_sg(host->dma_chan->device->dev, &host->sgl, 1,\n\t\t     DMA_BIDIRECTIONAL);\n\treturn -ENXIO;\n}\n\n \nstatic int lpc32xx_xfer(struct mtd_info *mtd, uint8_t *buf, int eccsubpages,\n\t\t\tint read)\n{\n\tstruct nand_chip *chip = mtd_to_nand(mtd);\n\tstruct lpc32xx_nand_host *host = nand_get_controller_data(chip);\n\tint i, status = 0;\n\tunsigned long timeout;\n\tint res;\n\tenum dma_transfer_direction dir =\n\t\tread ? DMA_DEV_TO_MEM : DMA_MEM_TO_DEV;\n\tuint8_t *dma_buf;\n\tbool dma_mapped;\n\n\tif ((void *)buf <= high_memory) {\n\t\tdma_buf = buf;\n\t\tdma_mapped = true;\n\t} else {\n\t\tdma_buf = host->data_buf;\n\t\tdma_mapped = false;\n\t\tif (!read)\n\t\t\tmemcpy(host->data_buf, buf, mtd->writesize);\n\t}\n\n\tif (read) {\n\t\twritel(readl(SLC_CFG(host->io_base)) |\n\t\t       SLCCFG_DMA_DIR | SLCCFG_ECC_EN | SLCCFG_DMA_ECC |\n\t\t       SLCCFG_DMA_BURST, SLC_CFG(host->io_base));\n\t} else {\n\t\twritel((readl(SLC_CFG(host->io_base)) |\n\t\t\tSLCCFG_ECC_EN | SLCCFG_DMA_ECC | SLCCFG_DMA_BURST) &\n\t\t       ~SLCCFG_DMA_DIR,\n\t\t\tSLC_CFG(host->io_base));\n\t}\n\n\t \n\twritel(SLCCTRL_ECC_CLEAR, SLC_CTRL(host->io_base));\n\n\t \n\twritel(mtd->writesize, SLC_TC(host->io_base));\n\n\t \n\twritel(readl(SLC_CTRL(host->io_base)) | SLCCTRL_DMA_START,\n\t       SLC_CTRL(host->io_base));\n\n\tfor (i = 0; i < chip->ecc.steps; i++) {\n\t\t \n\t\tres = lpc32xx_xmit_dma(mtd, SLC_DMA_DATA(host->io_base_dma),\n\t\t\t\t       dma_buf + i * chip->ecc.size,\n\t\t\t\t       mtd->writesize / chip->ecc.steps, dir);\n\t\tif (res)\n\t\t\treturn res;\n\n\t\t \n\t\tif (i == chip->ecc.steps - 1)\n\t\t\tbreak;\n\t\tif (!read)  \n\t\t\tudelay(10);\n\t\tres = lpc32xx_xmit_dma(mtd, SLC_ECC(host->io_base_dma),\n\t\t\t\t       &host->ecc_buf[i], 4, DMA_DEV_TO_MEM);\n\t\tif (res)\n\t\t\treturn res;\n\t}\n\n\t \n\tif (readl(SLC_STAT(host->io_base)) & SLCSTAT_DMA_FIFO) {\n\t\tdev_warn(mtd->dev.parent, \"FIFO not empty!\\n\");\n\t\ttimeout = jiffies + msecs_to_jiffies(LPC32XX_DMA_TIMEOUT);\n\t\twhile ((readl(SLC_STAT(host->io_base)) & SLCSTAT_DMA_FIFO) &&\n\t\t       time_before(jiffies, timeout))\n\t\t\tcpu_relax();\n\t\tif (!time_before(jiffies, timeout)) {\n\t\t\tdev_err(mtd->dev.parent, \"FIFO held data too long\\n\");\n\t\t\tstatus = -EIO;\n\t\t}\n\t}\n\n\t \n\tif (!read)\n\t\tudelay(10);\n\thost->ecc_buf[chip->ecc.steps - 1] =\n\t\treadl(SLC_ECC(host->io_base));\n\n\t \n\tdmaengine_terminate_all(host->dma_chan);\n\n\tif (readl(SLC_STAT(host->io_base)) & SLCSTAT_DMA_FIFO ||\n\t    readl(SLC_TC(host->io_base))) {\n\t\t \n\t\tdev_err(mtd->dev.parent, \"DMA FIFO failure\\n\");\n\t\tstatus = -EIO;\n\t}\n\n\t \n\twritel(readl(SLC_CTRL(host->io_base)) & ~SLCCTRL_DMA_START,\n\t       SLC_CTRL(host->io_base));\n\twritel(readl(SLC_CFG(host->io_base)) &\n\t       ~(SLCCFG_DMA_DIR | SLCCFG_ECC_EN | SLCCFG_DMA_ECC |\n\t\t SLCCFG_DMA_BURST), SLC_CFG(host->io_base));\n\n\tif (!dma_mapped && read)\n\t\tmemcpy(buf, host->data_buf, mtd->writesize);\n\n\treturn status;\n}\n\n \nstatic int lpc32xx_nand_read_page_syndrome(struct nand_chip *chip, uint8_t *buf,\n\t\t\t\t\t   int oob_required, int page)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tstruct lpc32xx_nand_host *host = nand_get_controller_data(chip);\n\tstruct mtd_oob_region oobregion = { };\n\tint stat, i, status, error;\n\tuint8_t *oobecc, tmpecc[LPC32XX_ECC_SAVE_SIZE];\n\n\t \n\tnand_read_page_op(chip, page, 0, NULL, 0);\n\n\t \n\tstatus = lpc32xx_xfer(mtd, buf, chip->ecc.steps, 1);\n\n\t \n\tchip->legacy.read_buf(chip, chip->oob_poi, mtd->oobsize);\n\n\t \n\tlpc32xx_slc_ecc_copy(tmpecc, (uint32_t *) host->ecc_buf, chip->ecc.steps);\n\n\t \n\terror = mtd_ooblayout_ecc(mtd, 0, &oobregion);\n\tif (error)\n\t\treturn error;\n\n\toobecc = chip->oob_poi + oobregion.offset;\n\n\tfor (i = 0; i < chip->ecc.steps; i++) {\n\t\tstat = chip->ecc.correct(chip, buf, oobecc,\n\t\t\t\t\t &tmpecc[i * chip->ecc.bytes]);\n\t\tif (stat < 0)\n\t\t\tmtd->ecc_stats.failed++;\n\t\telse\n\t\t\tmtd->ecc_stats.corrected += stat;\n\n\t\tbuf += chip->ecc.size;\n\t\toobecc += chip->ecc.bytes;\n\t}\n\n\treturn status;\n}\n\n \nstatic int lpc32xx_nand_read_page_raw_syndrome(struct nand_chip *chip,\n\t\t\t\t\t       uint8_t *buf, int oob_required,\n\t\t\t\t\t       int page)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\n\t \n\tnand_read_page_op(chip, page, 0, NULL, 0);\n\n\t \n\tchip->legacy.read_buf(chip, buf, chip->ecc.size * chip->ecc.steps);\n\tchip->legacy.read_buf(chip, chip->oob_poi, mtd->oobsize);\n\n\treturn 0;\n}\n\n \nstatic int lpc32xx_nand_write_page_syndrome(struct nand_chip *chip,\n\t\t\t\t\t    const uint8_t *buf,\n\t\t\t\t\t    int oob_required, int page)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tstruct lpc32xx_nand_host *host = nand_get_controller_data(chip);\n\tstruct mtd_oob_region oobregion = { };\n\tuint8_t *pb;\n\tint error;\n\n\tnand_prog_page_begin_op(chip, page, 0, NULL, 0);\n\n\t \n\terror = lpc32xx_xfer(mtd, (uint8_t *)buf, chip->ecc.steps, 0);\n\tif (error)\n\t\treturn error;\n\n\t \n\terror = mtd_ooblayout_ecc(mtd, 0, &oobregion);\n\tif (error)\n\t\treturn error;\n\n\tpb = chip->oob_poi + oobregion.offset;\n\tlpc32xx_slc_ecc_copy(pb, (uint32_t *)host->ecc_buf, chip->ecc.steps);\n\n\t \n\tchip->legacy.write_buf(chip, chip->oob_poi, mtd->oobsize);\n\n\treturn nand_prog_page_end_op(chip);\n}\n\n \nstatic int lpc32xx_nand_write_page_raw_syndrome(struct nand_chip *chip,\n\t\t\t\t\t\tconst uint8_t *buf,\n\t\t\t\t\t\tint oob_required, int page)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\n\t \n\tnand_prog_page_begin_op(chip, page, 0, buf,\n\t\t\t\tchip->ecc.size * chip->ecc.steps);\n\tchip->legacy.write_buf(chip, chip->oob_poi, mtd->oobsize);\n\n\treturn nand_prog_page_end_op(chip);\n}\n\nstatic int lpc32xx_nand_dma_setup(struct lpc32xx_nand_host *host)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(&host->nand_chip);\n\tdma_cap_mask_t mask;\n\n\tif (!host->pdata || !host->pdata->dma_filter) {\n\t\tdev_err(mtd->dev.parent, \"no DMA platform data\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\tdma_cap_zero(mask);\n\tdma_cap_set(DMA_SLAVE, mask);\n\thost->dma_chan = dma_request_channel(mask, host->pdata->dma_filter,\n\t\t\t\t\t     \"nand-slc\");\n\tif (!host->dma_chan) {\n\t\tdev_err(mtd->dev.parent, \"Failed to request DMA channel\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\treturn 0;\n}\n\nstatic struct lpc32xx_nand_cfg_slc *lpc32xx_parse_dt(struct device *dev)\n{\n\tstruct lpc32xx_nand_cfg_slc *ncfg;\n\tstruct device_node *np = dev->of_node;\n\n\tncfg = devm_kzalloc(dev, sizeof(*ncfg), GFP_KERNEL);\n\tif (!ncfg)\n\t\treturn NULL;\n\n\tof_property_read_u32(np, \"nxp,wdr-clks\", &ncfg->wdr_clks);\n\tof_property_read_u32(np, \"nxp,wwidth\", &ncfg->wwidth);\n\tof_property_read_u32(np, \"nxp,whold\", &ncfg->whold);\n\tof_property_read_u32(np, \"nxp,wsetup\", &ncfg->wsetup);\n\tof_property_read_u32(np, \"nxp,rdr-clks\", &ncfg->rdr_clks);\n\tof_property_read_u32(np, \"nxp,rwidth\", &ncfg->rwidth);\n\tof_property_read_u32(np, \"nxp,rhold\", &ncfg->rhold);\n\tof_property_read_u32(np, \"nxp,rsetup\", &ncfg->rsetup);\n\n\tif (!ncfg->wdr_clks || !ncfg->wwidth || !ncfg->whold ||\n\t    !ncfg->wsetup || !ncfg->rdr_clks || !ncfg->rwidth ||\n\t    !ncfg->rhold || !ncfg->rsetup) {\n\t\tdev_err(dev, \"chip parameters not specified correctly\\n\");\n\t\treturn NULL;\n\t}\n\n\treturn ncfg;\n}\n\nstatic int lpc32xx_nand_attach_chip(struct nand_chip *chip)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tstruct lpc32xx_nand_host *host = nand_get_controller_data(chip);\n\n\tif (chip->ecc.engine_type != NAND_ECC_ENGINE_TYPE_ON_HOST)\n\t\treturn 0;\n\n\t \n\thost->ecc_buf = (uint32_t *)(host->data_buf + LPC32XX_DMA_DATA_SIZE);\n\n\t \n\tif (mtd->writesize <= 512)\n\t\tmtd_set_ooblayout(mtd, &lpc32xx_ooblayout_ops);\n\n\tchip->ecc.placement = NAND_ECC_PLACEMENT_INTERLEAVED;\n\t \n\tchip->ecc.size = 256;\n\tchip->ecc.strength = 1;\n\tchip->ecc.bytes = LPC32XX_SLC_DEV_ECC_BYTES;\n\tchip->ecc.prepad = 0;\n\tchip->ecc.postpad = 0;\n\tchip->ecc.read_page_raw = lpc32xx_nand_read_page_raw_syndrome;\n\tchip->ecc.read_page = lpc32xx_nand_read_page_syndrome;\n\tchip->ecc.write_page_raw = lpc32xx_nand_write_page_raw_syndrome;\n\tchip->ecc.write_page = lpc32xx_nand_write_page_syndrome;\n\tchip->ecc.write_oob = lpc32xx_nand_write_oob_syndrome;\n\tchip->ecc.read_oob = lpc32xx_nand_read_oob_syndrome;\n\tchip->ecc.calculate = lpc32xx_nand_ecc_calculate;\n\tchip->ecc.correct = rawnand_sw_hamming_correct;\n\tchip->ecc.hwctl = lpc32xx_nand_ecc_enable;\n\n\t \n\tif ((chip->bbt_options & NAND_BBT_USE_FLASH) &&\n\t    mtd->writesize <= 512) {\n\t\tchip->bbt_td = &bbt_smallpage_main_descr;\n\t\tchip->bbt_md = &bbt_smallpage_mirror_descr;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct nand_controller_ops lpc32xx_nand_controller_ops = {\n\t.attach_chip = lpc32xx_nand_attach_chip,\n};\n\n \nstatic int lpc32xx_nand_probe(struct platform_device *pdev)\n{\n\tstruct lpc32xx_nand_host *host;\n\tstruct mtd_info *mtd;\n\tstruct nand_chip *chip;\n\tstruct resource *rc;\n\tint res;\n\n\t \n\thost = devm_kzalloc(&pdev->dev, sizeof(*host), GFP_KERNEL);\n\tif (!host)\n\t\treturn -ENOMEM;\n\n\thost->io_base = devm_platform_get_and_ioremap_resource(pdev, 0, &rc);\n\tif (IS_ERR(host->io_base))\n\t\treturn PTR_ERR(host->io_base);\n\n\thost->io_base_dma = rc->start;\n\tif (pdev->dev.of_node)\n\t\thost->ncfg = lpc32xx_parse_dt(&pdev->dev);\n\tif (!host->ncfg) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Missing or bad NAND config from device tree\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\t \n\thost->wp_gpio = gpiod_get_optional(&pdev->dev, NULL, GPIOD_OUT_LOW);\n\tres = PTR_ERR_OR_ZERO(host->wp_gpio);\n\tif (res) {\n\t\tif (res != -EPROBE_DEFER)\n\t\t\tdev_err(&pdev->dev, \"WP GPIO is not available: %d\\n\",\n\t\t\t\tres);\n\t\treturn res;\n\t}\n\n\tgpiod_set_consumer_name(host->wp_gpio, \"NAND WP\");\n\n\thost->pdata = dev_get_platdata(&pdev->dev);\n\n\tchip = &host->nand_chip;\n\tmtd = nand_to_mtd(chip);\n\tnand_set_controller_data(chip, host);\n\tnand_set_flash_node(chip, pdev->dev.of_node);\n\tmtd->owner = THIS_MODULE;\n\tmtd->dev.parent = &pdev->dev;\n\n\t \n\thost->clk = devm_clk_get_enabled(&pdev->dev, NULL);\n\tif (IS_ERR(host->clk)) {\n\t\tdev_err(&pdev->dev, \"Clock failure\\n\");\n\t\tres = -ENOENT;\n\t\tgoto enable_wp;\n\t}\n\n\t \n\tchip->legacy.IO_ADDR_R = SLC_DATA(host->io_base);\n\tchip->legacy.IO_ADDR_W = SLC_DATA(host->io_base);\n\tchip->legacy.cmd_ctrl = lpc32xx_nand_cmd_ctrl;\n\tchip->legacy.dev_ready = lpc32xx_nand_device_ready;\n\tchip->legacy.chip_delay = 20;  \n\n\t \n\tlpc32xx_nand_setup(host);\n\n\tplatform_set_drvdata(pdev, host);\n\n\t \n\tchip->legacy.read_byte = lpc32xx_nand_read_byte;\n\tchip->legacy.read_buf = lpc32xx_nand_read_buf;\n\tchip->legacy.write_buf = lpc32xx_nand_write_buf;\n\n\t \n\thost->dma_buf_len = LPC32XX_DMA_DATA_SIZE + LPC32XX_ECC_SAVE_SIZE;\n\thost->data_buf = devm_kzalloc(&pdev->dev, host->dma_buf_len,\n\t\t\t\t      GFP_KERNEL);\n\tif (host->data_buf == NULL) {\n\t\tres = -ENOMEM;\n\t\tgoto enable_wp;\n\t}\n\n\tres = lpc32xx_nand_dma_setup(host);\n\tif (res) {\n\t\tres = -EIO;\n\t\tgoto enable_wp;\n\t}\n\n\t \n\tchip->legacy.dummy_controller.ops = &lpc32xx_nand_controller_ops;\n\tres = nand_scan(chip, 1);\n\tif (res)\n\t\tgoto release_dma;\n\n\tmtd->name = \"nxp_lpc3220_slc\";\n\tres = mtd_device_register(mtd, host->ncfg->parts,\n\t\t\t\t  host->ncfg->num_parts);\n\tif (res)\n\t\tgoto cleanup_nand;\n\n\treturn 0;\n\ncleanup_nand:\n\tnand_cleanup(chip);\nrelease_dma:\n\tdma_release_channel(host->dma_chan);\nenable_wp:\n\tlpc32xx_wp_enable(host);\n\n\treturn res;\n}\n\n \nstatic void lpc32xx_nand_remove(struct platform_device *pdev)\n{\n\tuint32_t tmp;\n\tstruct lpc32xx_nand_host *host = platform_get_drvdata(pdev);\n\tstruct nand_chip *chip = &host->nand_chip;\n\tint ret;\n\n\tret = mtd_device_unregister(nand_to_mtd(chip));\n\tWARN_ON(ret);\n\tnand_cleanup(chip);\n\tdma_release_channel(host->dma_chan);\n\n\t \n\ttmp = readl(SLC_CTRL(host->io_base));\n\ttmp &= ~SLCCFG_CE_LOW;\n\twritel(tmp, SLC_CTRL(host->io_base));\n\n\tlpc32xx_wp_enable(host);\n}\n\nstatic int lpc32xx_nand_resume(struct platform_device *pdev)\n{\n\tstruct lpc32xx_nand_host *host = platform_get_drvdata(pdev);\n\tint ret;\n\n\t \n\tret = clk_prepare_enable(host->clk);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tlpc32xx_nand_setup(host);\n\n\t \n\tlpc32xx_wp_disable(host);\n\n\treturn 0;\n}\n\nstatic int lpc32xx_nand_suspend(struct platform_device *pdev, pm_message_t pm)\n{\n\tuint32_t tmp;\n\tstruct lpc32xx_nand_host *host = platform_get_drvdata(pdev);\n\n\t \n\ttmp = readl(SLC_CTRL(host->io_base));\n\ttmp &= ~SLCCFG_CE_LOW;\n\twritel(tmp, SLC_CTRL(host->io_base));\n\n\t \n\tlpc32xx_wp_enable(host);\n\n\t \n\tclk_disable_unprepare(host->clk);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id lpc32xx_nand_match[] = {\n\t{ .compatible = \"nxp,lpc3220-slc\" },\n\t{   },\n};\nMODULE_DEVICE_TABLE(of, lpc32xx_nand_match);\n\nstatic struct platform_driver lpc32xx_nand_driver = {\n\t.probe\t\t= lpc32xx_nand_probe,\n\t.remove_new\t= lpc32xx_nand_remove,\n\t.resume\t\t= pm_ptr(lpc32xx_nand_resume),\n\t.suspend\t= pm_ptr(lpc32xx_nand_suspend),\n\t.driver\t\t= {\n\t\t.name\t= LPC32XX_MODNAME,\n\t\t.of_match_table = lpc32xx_nand_match,\n\t},\n};\n\nmodule_platform_driver(lpc32xx_nand_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Kevin Wells <kevin.wells@nxp.com>\");\nMODULE_AUTHOR(\"Roland Stigge <stigge@antcom.de>\");\nMODULE_DESCRIPTION(\"NAND driver for the NXP LPC32XX SLC controller\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}