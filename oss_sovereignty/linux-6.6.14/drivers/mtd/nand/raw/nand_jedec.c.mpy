{
  "module_name": "nand_jedec.c",
  "hash_id": "ca74b6f7ff88ded60c5dde7a40b9c7850fcf8537d66fe22089ba5e3a14bcf9fe",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/nand/raw/nand_jedec.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n\n#include \"internals.h\"\n\n#define JEDEC_PARAM_PAGES 3\n\n \nint nand_jedec_detect(struct nand_chip *chip)\n{\n\tstruct nand_device *base = &chip->base;\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tstruct nand_memory_organization *memorg;\n\tstruct nand_jedec_params *p;\n\tstruct jedec_ecc_info *ecc;\n\tbool use_datain = false;\n\tint jedec_version = 0;\n\tchar id[5];\n\tint i, val, ret;\n\tu16 crc;\n\n\tmemorg = nanddev_get_memorg(&chip->base);\n\n\t \n\tret = nand_readid_op(chip, 0x40, id, sizeof(id));\n\tif (ret || strncmp(id, \"JEDEC\", sizeof(id)))\n\t\treturn 0;\n\n\t \n\tp = kzalloc(sizeof(*p), GFP_KERNEL);\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tif (!nand_has_exec_op(chip) || chip->controller->supported_op.data_only_read)\n\t\tuse_datain = true;\n\n\tfor (i = 0; i < JEDEC_PARAM_PAGES; i++) {\n\t\tif (!i)\n\t\t\tret = nand_read_param_page_op(chip, 0x40, p,\n\t\t\t\t\t\t      sizeof(*p));\n\t\telse if (use_datain)\n\t\t\tret = nand_read_data_op(chip, p, sizeof(*p), true,\n\t\t\t\t\t\tfalse);\n\t\telse\n\t\t\tret = nand_change_read_column_op(chip, sizeof(*p) * i,\n\t\t\t\t\t\t\t p, sizeof(*p), true);\n\t\tif (ret) {\n\t\t\tret = 0;\n\t\t\tgoto free_jedec_param_page;\n\t\t}\n\n\t\tcrc = onfi_crc16(ONFI_CRC_BASE, (u8 *)p, 510);\n\t\tif (crc == le16_to_cpu(p->crc))\n\t\t\tbreak;\n\t}\n\n\tif (i == JEDEC_PARAM_PAGES) {\n\t\tpr_err(\"Could not find valid JEDEC parameter page; aborting\\n\");\n\t\tgoto free_jedec_param_page;\n\t}\n\n\t \n\tval = le16_to_cpu(p->revision);\n\tif (val & (1 << 2))\n\t\tjedec_version = 10;\n\telse if (val & (1 << 1))\n\t\tjedec_version = 1;  \n\n\tif (!jedec_version) {\n\t\tpr_info(\"unsupported JEDEC version: %d\\n\", val);\n\t\tgoto free_jedec_param_page;\n\t}\n\n\tsanitize_string(p->manufacturer, sizeof(p->manufacturer));\n\tsanitize_string(p->model, sizeof(p->model));\n\tchip->parameters.model = kstrdup(p->model, GFP_KERNEL);\n\tif (!chip->parameters.model) {\n\t\tret = -ENOMEM;\n\t\tgoto free_jedec_param_page;\n\t}\n\n\tif (p->opt_cmd[0] & JEDEC_OPT_CMD_READ_CACHE)\n\t\tchip->parameters.supports_read_cache = true;\n\n\tmemorg->pagesize = le32_to_cpu(p->byte_per_page);\n\tmtd->writesize = memorg->pagesize;\n\n\t \n\tmemorg->pages_per_eraseblock =\n\t\t\t1 << (fls(le32_to_cpu(p->pages_per_block)) - 1);\n\tmtd->erasesize = memorg->pages_per_eraseblock * memorg->pagesize;\n\n\tmemorg->oobsize = le16_to_cpu(p->spare_bytes_per_page);\n\tmtd->oobsize = memorg->oobsize;\n\n\tmemorg->luns_per_target = p->lun_count;\n\tmemorg->planes_per_lun = 1 << p->multi_plane_addr;\n\n\t \n\tmemorg->eraseblocks_per_lun =\n\t\t1 << (fls(le32_to_cpu(p->blocks_per_lun)) - 1);\n\tmemorg->bits_per_cell = p->bits_per_cell;\n\n\tif (le16_to_cpu(p->features) & JEDEC_FEATURE_16_BIT_BUS)\n\t\tchip->options |= NAND_BUSWIDTH_16;\n\n\t \n\tecc = &p->ecc_info[0];\n\n\tif (ecc->codeword_size >= 9) {\n\t\tstruct nand_ecc_props requirements = {\n\t\t\t.strength = ecc->ecc_bits,\n\t\t\t.step_size = 1 << ecc->codeword_size,\n\t\t};\n\n\t\tnanddev_set_ecc_requirements(base, &requirements);\n\t} else {\n\t\tpr_warn(\"Invalid codeword size\\n\");\n\t}\n\n\tret = 1;\n\nfree_jedec_param_page:\n\tkfree(p);\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}