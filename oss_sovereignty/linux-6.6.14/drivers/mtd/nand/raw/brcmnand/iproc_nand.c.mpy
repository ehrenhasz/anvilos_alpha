{
  "module_name": "iproc_nand.c",
  "hash_id": "ce7c40f996cb3361cca1658733774eed24a54795a25aeb8649cf1cabe453b1b0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/nand/raw/brcmnand/iproc_nand.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/io.h>\n#include <linux/ioport.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n\n#include \"brcmnand.h\"\n\nstruct iproc_nand_soc {\n\tstruct brcmnand_soc soc;\n\n\tvoid __iomem *idm_base;\n\tvoid __iomem *ext_base;\n\tspinlock_t idm_lock;\n};\n\n#define IPROC_NAND_CTLR_READY_OFFSET       0x10\n#define IPROC_NAND_CTLR_READY              BIT(0)\n\n#define IPROC_NAND_IO_CTRL_OFFSET          0x00\n#define IPROC_NAND_APB_LE_MODE             BIT(24)\n#define IPROC_NAND_INT_CTRL_READ_ENABLE    BIT(6)\n\nstatic bool iproc_nand_intc_ack(struct brcmnand_soc *soc)\n{\n\tstruct iproc_nand_soc *priv =\n\t\t\tcontainer_of(soc, struct iproc_nand_soc, soc);\n\tvoid __iomem *mmio = priv->ext_base + IPROC_NAND_CTLR_READY_OFFSET;\n\tu32 val = brcmnand_readl(mmio);\n\n\tif (val & IPROC_NAND_CTLR_READY) {\n\t\tbrcmnand_writel(IPROC_NAND_CTLR_READY, mmio);\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic void iproc_nand_intc_set(struct brcmnand_soc *soc, bool en)\n{\n\tstruct iproc_nand_soc *priv =\n\t\t\tcontainer_of(soc, struct iproc_nand_soc, soc);\n\tvoid __iomem *mmio = priv->idm_base + IPROC_NAND_IO_CTRL_OFFSET;\n\tu32 val;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&priv->idm_lock, flags);\n\n\tval = brcmnand_readl(mmio);\n\n\tif (en)\n\t\tval |= IPROC_NAND_INT_CTRL_READ_ENABLE;\n\telse\n\t\tval &= ~IPROC_NAND_INT_CTRL_READ_ENABLE;\n\n\tbrcmnand_writel(val, mmio);\n\n\tspin_unlock_irqrestore(&priv->idm_lock, flags);\n}\n\nstatic void iproc_nand_apb_access(struct brcmnand_soc *soc, bool prepare,\n\t\t\t\t  bool is_param)\n{\n\tstruct iproc_nand_soc *priv =\n\t\t\tcontainer_of(soc, struct iproc_nand_soc, soc);\n\tvoid __iomem *mmio = priv->idm_base + IPROC_NAND_IO_CTRL_OFFSET;\n\tu32 val;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&priv->idm_lock, flags);\n\n\tval = brcmnand_readl(mmio);\n\n\t \n\tif (IS_ENABLED(CONFIG_CPU_BIG_ENDIAN) || !is_param) {\n\t\tif (prepare)\n\t\t\tval |= IPROC_NAND_APB_LE_MODE;\n\t\telse\n\t\t\tval &= ~IPROC_NAND_APB_LE_MODE;\n\t} else {  \n\t\tval &= ~IPROC_NAND_APB_LE_MODE;\n\t}\n\n\tbrcmnand_writel(val, mmio);\n\n\tspin_unlock_irqrestore(&priv->idm_lock, flags);\n}\n\nstatic int iproc_nand_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct iproc_nand_soc *priv;\n\tstruct brcmnand_soc *soc;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\tsoc = &priv->soc;\n\n\tspin_lock_init(&priv->idm_lock);\n\n\tpriv->idm_base = devm_platform_ioremap_resource_byname(pdev, \"iproc-idm\");\n\tif (IS_ERR(priv->idm_base))\n\t\treturn PTR_ERR(priv->idm_base);\n\n\tpriv->ext_base = devm_platform_ioremap_resource_byname(pdev, \"iproc-ext\");\n\tif (IS_ERR(priv->ext_base))\n\t\treturn PTR_ERR(priv->ext_base);\n\n\tsoc->ctlrdy_ack = iproc_nand_intc_ack;\n\tsoc->ctlrdy_set_enabled = iproc_nand_intc_set;\n\tsoc->prepare_data_bus = iproc_nand_apb_access;\n\n\treturn brcmnand_probe(pdev, soc);\n}\n\nstatic const struct of_device_id iproc_nand_of_match[] = {\n\t{ .compatible = \"brcm,nand-iproc\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, iproc_nand_of_match);\n\nstatic struct platform_driver iproc_nand_driver = {\n\t.probe\t\t\t= iproc_nand_probe,\n\t.remove\t\t\t= brcmnand_remove,\n\t.driver = {\n\t\t.name\t\t= \"iproc_nand\",\n\t\t.pm\t\t= &brcmnand_pm_ops,\n\t\t.of_match_table\t= iproc_nand_of_match,\n\t}\n};\nmodule_platform_driver(iproc_nand_driver);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Brian Norris\");\nMODULE_AUTHOR(\"Ray Jui\");\nMODULE_DESCRIPTION(\"NAND driver for Broadcom IPROC-based SoCs\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}