{
  "module_name": "bcma_nand.c",
  "hash_id": "691802a54a3eded49ef1cea00dc3f6114436d02749a4c1f527ab4b4f86a7f938",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/nand/raw/brcmnand/bcma_nand.c",
  "human_readable_source": "\n \n#include <linux/bcma/bcma.h>\n#include <linux/bcma/bcma_driver_chipcommon.h>\n#include <linux/device.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n\n#include \"brcmnand.h\"\n\nstruct brcmnand_bcma_soc {\n\tstruct brcmnand_soc soc;\n\tstruct bcma_drv_cc *cc;\n};\n\nstatic inline bool brcmnand_bcma_needs_swapping(u32 offset)\n{\n\tswitch (offset) {\n\tcase BCMA_CC_NAND_SPARE_RD0:\n\tcase BCMA_CC_NAND_SPARE_RD4:\n\tcase BCMA_CC_NAND_SPARE_RD8:\n\tcase BCMA_CC_NAND_SPARE_RD12:\n\tcase BCMA_CC_NAND_SPARE_WR0:\n\tcase BCMA_CC_NAND_SPARE_WR4:\n\tcase BCMA_CC_NAND_SPARE_WR8:\n\tcase BCMA_CC_NAND_SPARE_WR12:\n\tcase BCMA_CC_NAND_DEVID:\n\tcase BCMA_CC_NAND_DEVID_X:\n\tcase BCMA_CC_NAND_SPARE_RD16:\n\tcase BCMA_CC_NAND_SPARE_RD20:\n\tcase BCMA_CC_NAND_SPARE_RD24:\n\tcase BCMA_CC_NAND_SPARE_RD28:\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic inline struct brcmnand_bcma_soc *to_bcma_soc(struct brcmnand_soc *soc)\n{\n\treturn container_of(soc, struct brcmnand_bcma_soc, soc);\n}\n\nstatic u32 brcmnand_bcma_read_reg(struct brcmnand_soc *soc, u32 offset)\n{\n\tstruct brcmnand_bcma_soc *sc = to_bcma_soc(soc);\n\tu32 val;\n\n\t \n\tif (offset == BRCMNAND_NON_MMIO_FC_ADDR)\n\t\toffset = BCMA_CC_NAND_CACHE_DATA;\n\telse\n\t\toffset += BCMA_CC_NAND_REVISION;\n\n\tval = bcma_cc_read32(sc->cc, offset);\n\n\t \n\tif (brcmnand_bcma_needs_swapping(offset))\n\t\tval = be32_to_cpu((__force __be32)val);\n\treturn val;\n}\n\nstatic void brcmnand_bcma_write_reg(struct brcmnand_soc *soc, u32 val,\n\t\t\t\t    u32 offset)\n{\n\tstruct brcmnand_bcma_soc *sc = to_bcma_soc(soc);\n\n\t \n\tif (offset == BRCMNAND_NON_MMIO_FC_ADDR)\n\t\toffset = BCMA_CC_NAND_CACHE_DATA;\n\telse\n\t\toffset += BCMA_CC_NAND_REVISION;\n\n\t \n\tif (brcmnand_bcma_needs_swapping(offset))\n\t\tval = (__force u32)cpu_to_be32(val);\n\n\tbcma_cc_write32(sc->cc, offset, val);\n}\n\nstatic struct brcmnand_io_ops brcmnand_bcma_io_ops = {\n\t.read_reg\t= brcmnand_bcma_read_reg,\n\t.write_reg\t= brcmnand_bcma_write_reg,\n};\n\nstatic void brcmnand_bcma_prepare_data_bus(struct brcmnand_soc *soc, bool prepare,\n\t\t\t\t\t   bool is_param)\n{\n\tstruct brcmnand_bcma_soc *sc = to_bcma_soc(soc);\n\n\t \n\tbcma_cc_write32(sc->cc, BCMA_CC_NAND_CACHE_ADDR, 0);\n}\n\nstatic int brcmnand_bcma_nand_probe(struct platform_device *pdev)\n{\n\tstruct bcma_nflash *nflash = dev_get_platdata(&pdev->dev);\n\tstruct brcmnand_bcma_soc *soc;\n\n\tsoc = devm_kzalloc(&pdev->dev, sizeof(*soc), GFP_KERNEL);\n\tif (!soc)\n\t\treturn -ENOMEM;\n\n\tsoc->cc = container_of(nflash, struct bcma_drv_cc, nflash);\n\tsoc->soc.prepare_data_bus = brcmnand_bcma_prepare_data_bus;\n\tsoc->soc.ops = &brcmnand_bcma_io_ops;\n\n\tif (soc->cc->core->bus->chipinfo.id == BCMA_CHIP_ID_BCM4706) {\n\t\tdev_err(&pdev->dev, \"Use bcm47xxnflash for 4706!\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn brcmnand_probe(pdev, &soc->soc);\n}\n\nstatic struct platform_driver brcmnand_bcma_nand_driver = {\n\t.probe\t\t\t= brcmnand_bcma_nand_probe,\n\t.remove\t\t\t= brcmnand_remove,\n\t.driver = {\n\t\t.name\t\t= \"bcma_brcmnand\",\n\t\t.pm\t\t= &brcmnand_pm_ops,\n\t}\n};\nmodule_platform_driver(brcmnand_bcma_nand_driver);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Broadcom\");\nMODULE_DESCRIPTION(\"NAND controller driver glue for BCMA chips\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}