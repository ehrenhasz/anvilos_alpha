{
  "module_name": "bcm6368_nand.c",
  "hash_id": "73de45f2ed817406106361212e7f31507146eb4250ba43b80d9f1e86df4dda4c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/nand/raw/brcmnand/bcm6368_nand.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/io.h>\n#include <linux/ioport.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n\n#include \"brcmnand.h\"\n\nstruct bcm6368_nand_soc {\n\tstruct brcmnand_soc soc;\n\tvoid __iomem *base;\n};\n\n#define BCM6368_NAND_INT\t\t0x00\n#define  BCM6368_NAND_STATUS_SHIFT\t0\n#define  BCM6368_NAND_STATUS_MASK\t(0xfff << BCM6368_NAND_STATUS_SHIFT)\n#define  BCM6368_NAND_ENABLE_SHIFT\t16\n#define  BCM6368_NAND_ENABLE_MASK\t(0xffff << BCM6368_NAND_ENABLE_SHIFT)\n#define BCM6368_NAND_BASE_ADDR0\t0x04\n#define BCM6368_NAND_BASE_ADDR1\t0x0c\n\nenum {\n\tBCM6368_NP_READ\t\t= BIT(0),\n\tBCM6368_BLOCK_ERASE\t= BIT(1),\n\tBCM6368_COPY_BACK\t= BIT(2),\n\tBCM6368_PAGE_PGM\t= BIT(3),\n\tBCM6368_CTRL_READY\t= BIT(4),\n\tBCM6368_DEV_RBPIN\t= BIT(5),\n\tBCM6368_ECC_ERR_UNC\t= BIT(6),\n\tBCM6368_ECC_ERR_CORR\t= BIT(7),\n};\n\nstatic bool bcm6368_nand_intc_ack(struct brcmnand_soc *soc)\n{\n\tstruct bcm6368_nand_soc *priv =\n\t\t\tcontainer_of(soc, struct bcm6368_nand_soc, soc);\n\tvoid __iomem *mmio = priv->base + BCM6368_NAND_INT;\n\tu32 val = brcmnand_readl(mmio);\n\n\tif (val & (BCM6368_CTRL_READY << BCM6368_NAND_STATUS_SHIFT)) {\n\t\t \n\t\tval &= ~BCM6368_NAND_STATUS_MASK;\n\t\tval |= BCM6368_CTRL_READY << BCM6368_NAND_STATUS_SHIFT;\n\t\tbrcmnand_writel(val, mmio);\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic void bcm6368_nand_intc_set(struct brcmnand_soc *soc, bool en)\n{\n\tstruct bcm6368_nand_soc *priv =\n\t\t\tcontainer_of(soc, struct bcm6368_nand_soc, soc);\n\tvoid __iomem *mmio = priv->base + BCM6368_NAND_INT;\n\tu32 val = brcmnand_readl(mmio);\n\n\t \n\tval &= ~BCM6368_NAND_STATUS_MASK;\n\n\tif (en)\n\t\tval |= BCM6368_CTRL_READY << BCM6368_NAND_ENABLE_SHIFT;\n\telse\n\t\tval &= ~(BCM6368_CTRL_READY << BCM6368_NAND_ENABLE_SHIFT);\n\n\tbrcmnand_writel(val, mmio);\n}\n\nstatic int bcm6368_nand_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct bcm6368_nand_soc *priv;\n\tstruct brcmnand_soc *soc;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\tsoc = &priv->soc;\n\n\tpriv->base = devm_platform_ioremap_resource_byname(pdev, \"nand-int-base\");\n\tif (IS_ERR(priv->base))\n\t\treturn PTR_ERR(priv->base);\n\n\tsoc->ctlrdy_ack = bcm6368_nand_intc_ack;\n\tsoc->ctlrdy_set_enabled = bcm6368_nand_intc_set;\n\n\t \n\tbrcmnand_writel(0, priv->base + BCM6368_NAND_INT);\n\tbrcmnand_writel(BCM6368_NAND_STATUS_MASK,\n\t\t\tpriv->base + BCM6368_NAND_INT);\n\n\treturn brcmnand_probe(pdev, soc);\n}\n\nstatic const struct of_device_id bcm6368_nand_of_match[] = {\n\t{ .compatible = \"brcm,nand-bcm6368\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, bcm6368_nand_of_match);\n\nstatic struct platform_driver bcm6368_nand_driver = {\n\t.probe\t\t\t= bcm6368_nand_probe,\n\t.remove\t\t\t= brcmnand_remove,\n\t.driver = {\n\t\t.name\t\t= \"bcm6368_nand\",\n\t\t.pm\t\t= &brcmnand_pm_ops,\n\t\t.of_match_table\t= bcm6368_nand_of_match,\n\t}\n};\nmodule_platform_driver(bcm6368_nand_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Simon Arlott\");\nMODULE_DESCRIPTION(\"NAND driver for BCM6368\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}