{
  "module_name": "brcmnand.c",
  "hash_id": "efd0755e7651ea13b75751c0d8f40c792878340b5331609e878574668ed4b7be",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/nand/raw/brcmnand/brcmnand.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/platform_device.h>\n#include <linux/platform_data/brcmnand.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/dma-mapping.h>\n#include <linux/ioport.h>\n#include <linux/bug.h>\n#include <linux/kernel.h>\n#include <linux/bitops.h>\n#include <linux/mm.h>\n#include <linux/mtd/mtd.h>\n#include <linux/mtd/rawnand.h>\n#include <linux/mtd/partitions.h>\n#include <linux/of.h>\n#include <linux/of_platform.h>\n#include <linux/slab.h>\n#include <linux/static_key.h>\n#include <linux/list.h>\n#include <linux/log2.h>\n\n#include \"brcmnand.h\"\n\n \nstatic int wp_on = 1;\nmodule_param(wp_on, int, 0444);\n\n \n\n#define DRV_NAME\t\t\t\"brcmnand\"\n\n#define CMD_NULL\t\t\t0x00\n#define CMD_PAGE_READ\t\t\t0x01\n#define CMD_SPARE_AREA_READ\t\t0x02\n#define CMD_STATUS_READ\t\t\t0x03\n#define CMD_PROGRAM_PAGE\t\t0x04\n#define CMD_PROGRAM_SPARE_AREA\t\t0x05\n#define CMD_COPY_BACK\t\t\t0x06\n#define CMD_DEVICE_ID_READ\t\t0x07\n#define CMD_BLOCK_ERASE\t\t\t0x08\n#define CMD_FLASH_RESET\t\t\t0x09\n#define CMD_BLOCKS_LOCK\t\t\t0x0a\n#define CMD_BLOCKS_LOCK_DOWN\t\t0x0b\n#define CMD_BLOCKS_UNLOCK\t\t0x0c\n#define CMD_READ_BLOCKS_LOCK_STATUS\t0x0d\n#define CMD_PARAMETER_READ\t\t0x0e\n#define CMD_PARAMETER_CHANGE_COL\t0x0f\n#define CMD_LOW_LEVEL_OP\t\t0x10\n\nstruct brcm_nand_dma_desc {\n\tu32 next_desc;\n\tu32 next_desc_ext;\n\tu32 cmd_irq;\n\tu32 dram_addr;\n\tu32 dram_addr_ext;\n\tu32 tfr_len;\n\tu32 total_len;\n\tu32 flash_addr;\n\tu32 flash_addr_ext;\n\tu32 cs;\n\tu32 pad2[5];\n\tu32 status_valid;\n} __packed;\n\n \n#define FLASH_DMA_ECC_ERROR\t(1 << 8)\n#define FLASH_DMA_CORR_ERROR\t(1 << 9)\n\n \n#define FLASH_DMA_MODE_STOP_ON_ERROR\tBIT(1)  \n#define FLASH_DMA_MODE_MODE\t\tBIT(0)  \n#define FLASH_DMA_MODE_MASK\t\t(FLASH_DMA_MODE_STOP_ON_ERROR |\t\\\n\t\t\t\t\t\tFLASH_DMA_MODE_MODE)\n\n \n#define FC_SHIFT\t\t9U\n#define FC_BYTES\t\t512U\n#define FC_WORDS\t\t(FC_BYTES >> 2)\n\n#define BRCMNAND_MIN_PAGESIZE\t512\n#define BRCMNAND_MIN_BLOCKSIZE\t(8 * 1024)\n#define BRCMNAND_MIN_DEVSIZE\t(4ULL * 1024 * 1024)\n\n#define NAND_CTRL_RDY\t\t\t(INTFC_CTLR_READY | INTFC_FLASH_READY)\n#define NAND_POLL_STATUS_TIMEOUT_MS\t100\n\n#define EDU_CMD_WRITE          0x00\n#define EDU_CMD_READ           0x01\n#define EDU_STATUS_ACTIVE      BIT(0)\n#define EDU_ERR_STATUS_ERRACK  BIT(0)\n#define EDU_DONE_MASK\t\tGENMASK(1, 0)\n\n#define EDU_CONFIG_MODE_NAND   BIT(0)\n#define EDU_CONFIG_SWAP_BYTE   BIT(1)\n#ifdef CONFIG_CPU_BIG_ENDIAN\n#define EDU_CONFIG_SWAP_CFG     EDU_CONFIG_SWAP_BYTE\n#else\n#define EDU_CONFIG_SWAP_CFG     0\n#endif\n\n \nenum edu_reg {\n\tEDU_CONFIG = 0,\n\tEDU_DRAM_ADDR,\n\tEDU_EXT_ADDR,\n\tEDU_LENGTH,\n\tEDU_CMD,\n\tEDU_STOP,\n\tEDU_STATUS,\n\tEDU_DONE,\n\tEDU_ERR_STATUS,\n};\n\nstatic const u16  edu_regs[] = {\n\t[EDU_CONFIG] = 0x00,\n\t[EDU_DRAM_ADDR] = 0x04,\n\t[EDU_EXT_ADDR] = 0x08,\n\t[EDU_LENGTH] = 0x0c,\n\t[EDU_CMD] = 0x10,\n\t[EDU_STOP] = 0x14,\n\t[EDU_STATUS] = 0x18,\n\t[EDU_DONE] = 0x1c,\n\t[EDU_ERR_STATUS] = 0x20,\n};\n\n \nenum flash_dma_reg {\n\tFLASH_DMA_REVISION = 0,\n\tFLASH_DMA_FIRST_DESC,\n\tFLASH_DMA_FIRST_DESC_EXT,\n\tFLASH_DMA_CTRL,\n\tFLASH_DMA_MODE,\n\tFLASH_DMA_STATUS,\n\tFLASH_DMA_INTERRUPT_DESC,\n\tFLASH_DMA_INTERRUPT_DESC_EXT,\n\tFLASH_DMA_ERROR_STATUS,\n\tFLASH_DMA_CURRENT_DESC,\n\tFLASH_DMA_CURRENT_DESC_EXT,\n};\n\n \nstatic const u16 flash_dma_regs_v0[] = {\n\t[FLASH_DMA_REVISION]\t\t= 0x00,\n\t[FLASH_DMA_FIRST_DESC]\t\t= 0x04,\n\t[FLASH_DMA_CTRL]\t\t= 0x08,\n\t[FLASH_DMA_MODE]\t\t= 0x0c,\n\t[FLASH_DMA_STATUS]\t\t= 0x10,\n\t[FLASH_DMA_INTERRUPT_DESC]\t= 0x14,\n\t[FLASH_DMA_ERROR_STATUS]\t= 0x18,\n\t[FLASH_DMA_CURRENT_DESC]\t= 0x1c,\n};\n\n \nstatic const u16 flash_dma_regs_v1[] = {\n\t[FLASH_DMA_REVISION]\t\t= 0x00,\n\t[FLASH_DMA_FIRST_DESC]\t\t= 0x04,\n\t[FLASH_DMA_FIRST_DESC_EXT]\t= 0x08,\n\t[FLASH_DMA_CTRL]\t\t= 0x0c,\n\t[FLASH_DMA_MODE]\t\t= 0x10,\n\t[FLASH_DMA_STATUS]\t\t= 0x14,\n\t[FLASH_DMA_INTERRUPT_DESC]\t= 0x18,\n\t[FLASH_DMA_INTERRUPT_DESC_EXT]\t= 0x1c,\n\t[FLASH_DMA_ERROR_STATUS]\t= 0x20,\n\t[FLASH_DMA_CURRENT_DESC]\t= 0x24,\n\t[FLASH_DMA_CURRENT_DESC_EXT]\t= 0x28,\n};\n\n \nstatic const u16 flash_dma_regs_v4[] = {\n\t[FLASH_DMA_REVISION]\t\t= 0x00,\n\t[FLASH_DMA_FIRST_DESC]\t\t= 0x08,\n\t[FLASH_DMA_FIRST_DESC_EXT]\t= 0x0c,\n\t[FLASH_DMA_CTRL]\t\t= 0x10,\n\t[FLASH_DMA_MODE]\t\t= 0x14,\n\t[FLASH_DMA_STATUS]\t\t= 0x18,\n\t[FLASH_DMA_INTERRUPT_DESC]\t= 0x20,\n\t[FLASH_DMA_INTERRUPT_DESC_EXT]\t= 0x24,\n\t[FLASH_DMA_ERROR_STATUS]\t= 0x28,\n\t[FLASH_DMA_CURRENT_DESC]\t= 0x30,\n\t[FLASH_DMA_CURRENT_DESC_EXT]\t= 0x34,\n};\n\n \nenum {\n\tBRCMNAND_HAS_1K_SECTORS\t\t\t= BIT(0),\n\tBRCMNAND_HAS_PREFETCH\t\t\t= BIT(1),\n\tBRCMNAND_HAS_CACHE_MODE\t\t\t= BIT(2),\n\tBRCMNAND_HAS_WP\t\t\t\t= BIT(3),\n};\n\nstruct brcmnand_host;\n\nstatic DEFINE_STATIC_KEY_FALSE(brcmnand_soc_has_ops_key);\n\nstruct brcmnand_controller {\n\tstruct device\t\t*dev;\n\tstruct nand_controller\tcontroller;\n\tvoid __iomem\t\t*nand_base;\n\tvoid __iomem\t\t*nand_fc;  \n\tvoid __iomem\t\t*flash_dma_base;\n\tint\t\t\tirq;\n\tunsigned int\t\tdma_irq;\n\tint\t\t\tnand_version;\n\n\t \n\tstruct brcmnand_soc\t*soc;\n\n\t \n\tstruct clk\t\t*clk;\n\n\tint\t\t\tcmd_pending;\n\tbool\t\t\tdma_pending;\n\tbool                    edu_pending;\n\tstruct completion\tdone;\n\tstruct completion\tdma_done;\n\tstruct completion       edu_done;\n\n\t \n\tstruct list_head host_list;\n\n\t \n\tconst u16               *edu_offsets;\n\tvoid __iomem            *edu_base;\n\tint\t\t\tedu_irq;\n\tint                     edu_count;\n\tu64                     edu_dram_addr;\n\tu32                     edu_ext_addr;\n\tu32                     edu_cmd;\n\tu32                     edu_config;\n\tint\t\t\tsas;  \n\tint\t\t\tsector_size_1k;\n\tu8\t\t\t*oob;\n\n\t \n\tconst u16\t\t*flash_dma_offsets;\n\tstruct brcm_nand_dma_desc *dma_desc;\n\tdma_addr_t\t\tdma_pa;\n\n\tint (*dma_trans)(struct brcmnand_host *host, u64 addr, u32 *buf,\n\t\t\t u8 *oob, u32 len, u8 dma_cmd);\n\n\t \n\tu8\t\t\tflash_cache[FC_BYTES];\n\n\t \n\tconst u16\t\t*reg_offsets;\n\tunsigned int\t\treg_spacing;  \n\tconst u8\t\t*cs_offsets;  \n\tconst u8\t\t*cs0_offsets;  \n\tunsigned int\t\tmax_block_size;\n\tconst unsigned int\t*block_sizes;\n\tunsigned int\t\tmax_page_size;\n\tconst unsigned int\t*page_sizes;\n\tunsigned int\t\tpage_size_shift;\n\tunsigned int\t\tmax_oob;\n\tu32\t\t\tecc_level_shift;\n\tu32\t\t\tfeatures;\n\n\t \n\tu32\t\t\tnand_cs_nand_select;\n\tu32\t\t\tnand_cs_nand_xor;\n\tu32\t\t\tcorr_stat_threshold;\n\tu32\t\t\tflash_dma_mode;\n\tu32                     flash_edu_mode;\n\tbool\t\t\tpio_poll_mode;\n};\n\nstruct brcmnand_cfg {\n\tu64\t\t\tdevice_size;\n\tunsigned int\t\tblock_size;\n\tunsigned int\t\tpage_size;\n\tunsigned int\t\tspare_area_size;\n\tunsigned int\t\tdevice_width;\n\tunsigned int\t\tcol_adr_bytes;\n\tunsigned int\t\tblk_adr_bytes;\n\tunsigned int\t\tful_adr_bytes;\n\tunsigned int\t\tsector_size_1k;\n\tunsigned int\t\tecc_level;\n\t \n\tu32\t\t\tacc_control;\n\tu32\t\t\tconfig;\n\tu32\t\t\tconfig_ext;\n\tu32\t\t\ttiming_1;\n\tu32\t\t\ttiming_2;\n};\n\nstruct brcmnand_host {\n\tstruct list_head\tnode;\n\n\tstruct nand_chip\tchip;\n\tstruct platform_device\t*pdev;\n\tint\t\t\tcs;\n\n\tunsigned int\t\tlast_cmd;\n\tunsigned int\t\tlast_byte;\n\tu64\t\t\tlast_addr;\n\tstruct brcmnand_cfg\thwcfg;\n\tstruct brcmnand_controller *ctrl;\n};\n\nenum brcmnand_reg {\n\tBRCMNAND_CMD_START = 0,\n\tBRCMNAND_CMD_EXT_ADDRESS,\n\tBRCMNAND_CMD_ADDRESS,\n\tBRCMNAND_INTFC_STATUS,\n\tBRCMNAND_CS_SELECT,\n\tBRCMNAND_CS_XOR,\n\tBRCMNAND_LL_OP,\n\tBRCMNAND_CS0_BASE,\n\tBRCMNAND_CS1_BASE,\t\t \n\tBRCMNAND_CORR_THRESHOLD,\n\tBRCMNAND_CORR_THRESHOLD_EXT,\n\tBRCMNAND_UNCORR_COUNT,\n\tBRCMNAND_CORR_COUNT,\n\tBRCMNAND_CORR_EXT_ADDR,\n\tBRCMNAND_CORR_ADDR,\n\tBRCMNAND_UNCORR_EXT_ADDR,\n\tBRCMNAND_UNCORR_ADDR,\n\tBRCMNAND_SEMAPHORE,\n\tBRCMNAND_ID,\n\tBRCMNAND_ID_EXT,\n\tBRCMNAND_LL_RDATA,\n\tBRCMNAND_OOB_READ_BASE,\n\tBRCMNAND_OOB_READ_10_BASE,\t \n\tBRCMNAND_OOB_WRITE_BASE,\n\tBRCMNAND_OOB_WRITE_10_BASE,\t \n\tBRCMNAND_FC_BASE,\n};\n\n \nstatic const u16 brcmnand_regs_v21[] = {\n\t[BRCMNAND_CMD_START]\t\t=  0x04,\n\t[BRCMNAND_CMD_EXT_ADDRESS]\t=  0x08,\n\t[BRCMNAND_CMD_ADDRESS]\t\t=  0x0c,\n\t[BRCMNAND_INTFC_STATUS]\t\t=  0x5c,\n\t[BRCMNAND_CS_SELECT]\t\t=  0x14,\n\t[BRCMNAND_CS_XOR]\t\t=  0x18,\n\t[BRCMNAND_LL_OP]\t\t=     0,\n\t[BRCMNAND_CS0_BASE]\t\t=  0x40,\n\t[BRCMNAND_CS1_BASE]\t\t=     0,\n\t[BRCMNAND_CORR_THRESHOLD]\t=     0,\n\t[BRCMNAND_CORR_THRESHOLD_EXT]\t=     0,\n\t[BRCMNAND_UNCORR_COUNT]\t\t=     0,\n\t[BRCMNAND_CORR_COUNT]\t\t=     0,\n\t[BRCMNAND_CORR_EXT_ADDR]\t=  0x60,\n\t[BRCMNAND_CORR_ADDR]\t\t=  0x64,\n\t[BRCMNAND_UNCORR_EXT_ADDR]\t=  0x68,\n\t[BRCMNAND_UNCORR_ADDR]\t\t=  0x6c,\n\t[BRCMNAND_SEMAPHORE]\t\t=  0x50,\n\t[BRCMNAND_ID]\t\t\t=  0x54,\n\t[BRCMNAND_ID_EXT]\t\t=     0,\n\t[BRCMNAND_LL_RDATA]\t\t=     0,\n\t[BRCMNAND_OOB_READ_BASE]\t=  0x20,\n\t[BRCMNAND_OOB_READ_10_BASE]\t=     0,\n\t[BRCMNAND_OOB_WRITE_BASE]\t=  0x30,\n\t[BRCMNAND_OOB_WRITE_10_BASE]\t=     0,\n\t[BRCMNAND_FC_BASE]\t\t= 0x200,\n};\n\n \nstatic const u16 brcmnand_regs_v33[] = {\n\t[BRCMNAND_CMD_START]\t\t=  0x04,\n\t[BRCMNAND_CMD_EXT_ADDRESS]\t=  0x08,\n\t[BRCMNAND_CMD_ADDRESS]\t\t=  0x0c,\n\t[BRCMNAND_INTFC_STATUS]\t\t=  0x6c,\n\t[BRCMNAND_CS_SELECT]\t\t=  0x14,\n\t[BRCMNAND_CS_XOR]\t\t=  0x18,\n\t[BRCMNAND_LL_OP]\t\t= 0x178,\n\t[BRCMNAND_CS0_BASE]\t\t=  0x40,\n\t[BRCMNAND_CS1_BASE]\t\t=  0xd0,\n\t[BRCMNAND_CORR_THRESHOLD]\t=  0x84,\n\t[BRCMNAND_CORR_THRESHOLD_EXT]\t=     0,\n\t[BRCMNAND_UNCORR_COUNT]\t\t=     0,\n\t[BRCMNAND_CORR_COUNT]\t\t=     0,\n\t[BRCMNAND_CORR_EXT_ADDR]\t=  0x70,\n\t[BRCMNAND_CORR_ADDR]\t\t=  0x74,\n\t[BRCMNAND_UNCORR_EXT_ADDR]\t=  0x78,\n\t[BRCMNAND_UNCORR_ADDR]\t\t=  0x7c,\n\t[BRCMNAND_SEMAPHORE]\t\t=  0x58,\n\t[BRCMNAND_ID]\t\t\t=  0x60,\n\t[BRCMNAND_ID_EXT]\t\t=  0x64,\n\t[BRCMNAND_LL_RDATA]\t\t= 0x17c,\n\t[BRCMNAND_OOB_READ_BASE]\t=  0x20,\n\t[BRCMNAND_OOB_READ_10_BASE]\t= 0x130,\n\t[BRCMNAND_OOB_WRITE_BASE]\t=  0x30,\n\t[BRCMNAND_OOB_WRITE_10_BASE]\t=     0,\n\t[BRCMNAND_FC_BASE]\t\t= 0x200,\n};\n\n \nstatic const u16 brcmnand_regs_v50[] = {\n\t[BRCMNAND_CMD_START]\t\t=  0x04,\n\t[BRCMNAND_CMD_EXT_ADDRESS]\t=  0x08,\n\t[BRCMNAND_CMD_ADDRESS]\t\t=  0x0c,\n\t[BRCMNAND_INTFC_STATUS]\t\t=  0x6c,\n\t[BRCMNAND_CS_SELECT]\t\t=  0x14,\n\t[BRCMNAND_CS_XOR]\t\t=  0x18,\n\t[BRCMNAND_LL_OP]\t\t= 0x178,\n\t[BRCMNAND_CS0_BASE]\t\t=  0x40,\n\t[BRCMNAND_CS1_BASE]\t\t=  0xd0,\n\t[BRCMNAND_CORR_THRESHOLD]\t=  0x84,\n\t[BRCMNAND_CORR_THRESHOLD_EXT]\t=     0,\n\t[BRCMNAND_UNCORR_COUNT]\t\t=     0,\n\t[BRCMNAND_CORR_COUNT]\t\t=     0,\n\t[BRCMNAND_CORR_EXT_ADDR]\t=  0x70,\n\t[BRCMNAND_CORR_ADDR]\t\t=  0x74,\n\t[BRCMNAND_UNCORR_EXT_ADDR]\t=  0x78,\n\t[BRCMNAND_UNCORR_ADDR]\t\t=  0x7c,\n\t[BRCMNAND_SEMAPHORE]\t\t=  0x58,\n\t[BRCMNAND_ID]\t\t\t=  0x60,\n\t[BRCMNAND_ID_EXT]\t\t=  0x64,\n\t[BRCMNAND_LL_RDATA]\t\t= 0x17c,\n\t[BRCMNAND_OOB_READ_BASE]\t=  0x20,\n\t[BRCMNAND_OOB_READ_10_BASE]\t= 0x130,\n\t[BRCMNAND_OOB_WRITE_BASE]\t=  0x30,\n\t[BRCMNAND_OOB_WRITE_10_BASE]\t= 0x140,\n\t[BRCMNAND_FC_BASE]\t\t= 0x200,\n};\n\n \nstatic const u16 brcmnand_regs_v60[] = {\n\t[BRCMNAND_CMD_START]\t\t=  0x04,\n\t[BRCMNAND_CMD_EXT_ADDRESS]\t=  0x08,\n\t[BRCMNAND_CMD_ADDRESS]\t\t=  0x0c,\n\t[BRCMNAND_INTFC_STATUS]\t\t=  0x14,\n\t[BRCMNAND_CS_SELECT]\t\t=  0x18,\n\t[BRCMNAND_CS_XOR]\t\t=  0x1c,\n\t[BRCMNAND_LL_OP]\t\t=  0x20,\n\t[BRCMNAND_CS0_BASE]\t\t=  0x50,\n\t[BRCMNAND_CS1_BASE]\t\t=     0,\n\t[BRCMNAND_CORR_THRESHOLD]\t=  0xc0,\n\t[BRCMNAND_CORR_THRESHOLD_EXT]\t=  0xc4,\n\t[BRCMNAND_UNCORR_COUNT]\t\t=  0xfc,\n\t[BRCMNAND_CORR_COUNT]\t\t= 0x100,\n\t[BRCMNAND_CORR_EXT_ADDR]\t= 0x10c,\n\t[BRCMNAND_CORR_ADDR]\t\t= 0x110,\n\t[BRCMNAND_UNCORR_EXT_ADDR]\t= 0x114,\n\t[BRCMNAND_UNCORR_ADDR]\t\t= 0x118,\n\t[BRCMNAND_SEMAPHORE]\t\t= 0x150,\n\t[BRCMNAND_ID]\t\t\t= 0x194,\n\t[BRCMNAND_ID_EXT]\t\t= 0x198,\n\t[BRCMNAND_LL_RDATA]\t\t= 0x19c,\n\t[BRCMNAND_OOB_READ_BASE]\t= 0x200,\n\t[BRCMNAND_OOB_READ_10_BASE]\t=     0,\n\t[BRCMNAND_OOB_WRITE_BASE]\t= 0x280,\n\t[BRCMNAND_OOB_WRITE_10_BASE]\t=     0,\n\t[BRCMNAND_FC_BASE]\t\t= 0x400,\n};\n\n \nstatic const u16 brcmnand_regs_v71[] = {\n\t[BRCMNAND_CMD_START]\t\t=  0x04,\n\t[BRCMNAND_CMD_EXT_ADDRESS]\t=  0x08,\n\t[BRCMNAND_CMD_ADDRESS]\t\t=  0x0c,\n\t[BRCMNAND_INTFC_STATUS]\t\t=  0x14,\n\t[BRCMNAND_CS_SELECT]\t\t=  0x18,\n\t[BRCMNAND_CS_XOR]\t\t=  0x1c,\n\t[BRCMNAND_LL_OP]\t\t=  0x20,\n\t[BRCMNAND_CS0_BASE]\t\t=  0x50,\n\t[BRCMNAND_CS1_BASE]\t\t=     0,\n\t[BRCMNAND_CORR_THRESHOLD]\t=  0xdc,\n\t[BRCMNAND_CORR_THRESHOLD_EXT]\t=  0xe0,\n\t[BRCMNAND_UNCORR_COUNT]\t\t=  0xfc,\n\t[BRCMNAND_CORR_COUNT]\t\t= 0x100,\n\t[BRCMNAND_CORR_EXT_ADDR]\t= 0x10c,\n\t[BRCMNAND_CORR_ADDR]\t\t= 0x110,\n\t[BRCMNAND_UNCORR_EXT_ADDR]\t= 0x114,\n\t[BRCMNAND_UNCORR_ADDR]\t\t= 0x118,\n\t[BRCMNAND_SEMAPHORE]\t\t= 0x150,\n\t[BRCMNAND_ID]\t\t\t= 0x194,\n\t[BRCMNAND_ID_EXT]\t\t= 0x198,\n\t[BRCMNAND_LL_RDATA]\t\t= 0x19c,\n\t[BRCMNAND_OOB_READ_BASE]\t= 0x200,\n\t[BRCMNAND_OOB_READ_10_BASE]\t=     0,\n\t[BRCMNAND_OOB_WRITE_BASE]\t= 0x280,\n\t[BRCMNAND_OOB_WRITE_10_BASE]\t=     0,\n\t[BRCMNAND_FC_BASE]\t\t= 0x400,\n};\n\n \nstatic const u16 brcmnand_regs_v72[] = {\n\t[BRCMNAND_CMD_START]\t\t=  0x04,\n\t[BRCMNAND_CMD_EXT_ADDRESS]\t=  0x08,\n\t[BRCMNAND_CMD_ADDRESS]\t\t=  0x0c,\n\t[BRCMNAND_INTFC_STATUS]\t\t=  0x14,\n\t[BRCMNAND_CS_SELECT]\t\t=  0x18,\n\t[BRCMNAND_CS_XOR]\t\t=  0x1c,\n\t[BRCMNAND_LL_OP]\t\t=  0x20,\n\t[BRCMNAND_CS0_BASE]\t\t=  0x50,\n\t[BRCMNAND_CS1_BASE]\t\t=     0,\n\t[BRCMNAND_CORR_THRESHOLD]\t=  0xdc,\n\t[BRCMNAND_CORR_THRESHOLD_EXT]\t=  0xe0,\n\t[BRCMNAND_UNCORR_COUNT]\t\t=  0xfc,\n\t[BRCMNAND_CORR_COUNT]\t\t= 0x100,\n\t[BRCMNAND_CORR_EXT_ADDR]\t= 0x10c,\n\t[BRCMNAND_CORR_ADDR]\t\t= 0x110,\n\t[BRCMNAND_UNCORR_EXT_ADDR]\t= 0x114,\n\t[BRCMNAND_UNCORR_ADDR]\t\t= 0x118,\n\t[BRCMNAND_SEMAPHORE]\t\t= 0x150,\n\t[BRCMNAND_ID]\t\t\t= 0x194,\n\t[BRCMNAND_ID_EXT]\t\t= 0x198,\n\t[BRCMNAND_LL_RDATA]\t\t= 0x19c,\n\t[BRCMNAND_OOB_READ_BASE]\t= 0x200,\n\t[BRCMNAND_OOB_READ_10_BASE]\t=     0,\n\t[BRCMNAND_OOB_WRITE_BASE]\t= 0x400,\n\t[BRCMNAND_OOB_WRITE_10_BASE]\t=     0,\n\t[BRCMNAND_FC_BASE]\t\t= 0x600,\n};\n\nenum brcmnand_cs_reg {\n\tBRCMNAND_CS_CFG_EXT = 0,\n\tBRCMNAND_CS_CFG,\n\tBRCMNAND_CS_ACC_CONTROL,\n\tBRCMNAND_CS_TIMING1,\n\tBRCMNAND_CS_TIMING2,\n};\n\n \nstatic const u8 brcmnand_cs_offsets_v71[] = {\n\t[BRCMNAND_CS_ACC_CONTROL]\t= 0x00,\n\t[BRCMNAND_CS_CFG_EXT]\t\t= 0x04,\n\t[BRCMNAND_CS_CFG]\t\t= 0x08,\n\t[BRCMNAND_CS_TIMING1]\t\t= 0x0c,\n\t[BRCMNAND_CS_TIMING2]\t\t= 0x10,\n};\n\n \nstatic const u8 brcmnand_cs_offsets[] = {\n\t[BRCMNAND_CS_ACC_CONTROL]\t= 0x00,\n\t[BRCMNAND_CS_CFG_EXT]\t\t= 0x04,\n\t[BRCMNAND_CS_CFG]\t\t= 0x04,\n\t[BRCMNAND_CS_TIMING1]\t\t= 0x08,\n\t[BRCMNAND_CS_TIMING2]\t\t= 0x0c,\n};\n\n \nstatic const u8 brcmnand_cs_offsets_cs0[] = {\n\t[BRCMNAND_CS_ACC_CONTROL]\t= 0x00,\n\t[BRCMNAND_CS_CFG_EXT]\t\t= 0x08,\n\t[BRCMNAND_CS_CFG]\t\t= 0x08,\n\t[BRCMNAND_CS_TIMING1]\t\t= 0x10,\n\t[BRCMNAND_CS_TIMING2]\t\t= 0x14,\n};\n\n \nenum {\n\tCFG_BLK_ADR_BYTES_SHIFT\t\t= 8,\n\tCFG_COL_ADR_BYTES_SHIFT\t\t= 12,\n\tCFG_FUL_ADR_BYTES_SHIFT\t\t= 16,\n\tCFG_BUS_WIDTH_SHIFT\t\t= 23,\n\tCFG_BUS_WIDTH\t\t\t= BIT(CFG_BUS_WIDTH_SHIFT),\n\tCFG_DEVICE_SIZE_SHIFT\t\t= 24,\n\n\t \n\tCFG_PAGE_SIZE_SHIFT_v2_1\t= 30,\n\n\t \n\tCFG_PAGE_SIZE_SHIFT\t\t= 20,\n\tCFG_BLK_SIZE_SHIFT\t\t= 28,\n\n\t \n\tCFG_EXT_PAGE_SIZE_SHIFT\t\t= 0,\n\tCFG_EXT_BLK_SIZE_SHIFT\t\t= 4,\n};\n\n \nenum {\n\tINTFC_FLASH_STATUS\t\t= GENMASK(7, 0),\n\n\tINTFC_ERASED\t\t\t= BIT(27),\n\tINTFC_OOB_VALID\t\t\t= BIT(28),\n\tINTFC_CACHE_VALID\t\t= BIT(29),\n\tINTFC_FLASH_READY\t\t= BIT(30),\n\tINTFC_CTLR_READY\t\t= BIT(31),\n};\n\n \n\n \nenum {\n\t \n\tACC_CONTROL_CACHE_MODE\t\t\t\t= BIT(22),\n\n\t \n\tACC_CONTROL_PREFETCH\t\t\t\t= BIT(23),\n\n\tACC_CONTROL_PAGE_HIT\t\t\t\t= BIT(24),\n\tACC_CONTROL_WR_PREEMPT\t\t\t\t= BIT(25),\n\tACC_CONTROL_PARTIAL_PAGE\t\t\t= BIT(26),\n\tACC_CONTROL_RD_ERASED\t\t\t\t= BIT(27),\n\tACC_CONTROL_FAST_PGM_RDIN\t\t\t= BIT(28),\n\tACC_CONTROL_WR_ECC\t\t\t\t= BIT(30),\n\tACC_CONTROL_RD_ECC\t\t\t\t= BIT(31),\n};\n\n#define\tACC_CONTROL_ECC_SHIFT\t\t\t16\n \n#define\tACC_CONTROL_ECC_EXT_SHIFT\t\t13\n\nstatic inline bool brcmnand_non_mmio_ops(struct brcmnand_controller *ctrl)\n{\n#if IS_ENABLED(CONFIG_MTD_NAND_BRCMNAND_BCMA)\n\treturn static_branch_unlikely(&brcmnand_soc_has_ops_key);\n#else\n\treturn false;\n#endif\n}\n\nstatic inline u32 nand_readreg(struct brcmnand_controller *ctrl, u32 offs)\n{\n\tif (brcmnand_non_mmio_ops(ctrl))\n\t\treturn brcmnand_soc_read(ctrl->soc, offs);\n\treturn brcmnand_readl(ctrl->nand_base + offs);\n}\n\nstatic inline void nand_writereg(struct brcmnand_controller *ctrl, u32 offs,\n\t\t\t\t u32 val)\n{\n\tif (brcmnand_non_mmio_ops(ctrl))\n\t\tbrcmnand_soc_write(ctrl->soc, val, offs);\n\telse\n\t\tbrcmnand_writel(val, ctrl->nand_base + offs);\n}\n\nstatic int brcmnand_revision_init(struct brcmnand_controller *ctrl)\n{\n\tstatic const unsigned int block_sizes_v6[] = { 8, 16, 128, 256, 512, 1024, 2048, 0 };\n\tstatic const unsigned int block_sizes_v4[] = { 16, 128, 8, 512, 256, 1024, 2048, 0 };\n\tstatic const unsigned int block_sizes_v2_2[] = { 16, 128, 8, 512, 256, 0 };\n\tstatic const unsigned int block_sizes_v2_1[] = { 16, 128, 8, 512, 0 };\n\tstatic const unsigned int page_sizes_v3_4[] = { 512, 2048, 4096, 8192, 0 };\n\tstatic const unsigned int page_sizes_v2_2[] = { 512, 2048, 4096, 0 };\n\tstatic const unsigned int page_sizes_v2_1[] = { 512, 2048, 0 };\n\n\tctrl->nand_version = nand_readreg(ctrl, 0) & 0xffff;\n\n\t \n\tif (ctrl->nand_version < 0x0201) {\n\t\tdev_err(ctrl->dev, \"version %#x not supported\\n\",\n\t\t\tctrl->nand_version);\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tif (ctrl->nand_version >= 0x0702)\n\t\tctrl->reg_offsets = brcmnand_regs_v72;\n\telse if (ctrl->nand_version == 0x0701)\n\t\tctrl->reg_offsets = brcmnand_regs_v71;\n\telse if (ctrl->nand_version >= 0x0600)\n\t\tctrl->reg_offsets = brcmnand_regs_v60;\n\telse if (ctrl->nand_version >= 0x0500)\n\t\tctrl->reg_offsets = brcmnand_regs_v50;\n\telse if (ctrl->nand_version >= 0x0303)\n\t\tctrl->reg_offsets = brcmnand_regs_v33;\n\telse if (ctrl->nand_version >= 0x0201)\n\t\tctrl->reg_offsets = brcmnand_regs_v21;\n\n\t \n\tif (ctrl->nand_version >= 0x0701)\n\t\tctrl->reg_spacing = 0x14;\n\telse\n\t\tctrl->reg_spacing = 0x10;\n\n\t \n\tif (ctrl->nand_version >= 0x0701) {\n\t\tctrl->cs_offsets = brcmnand_cs_offsets_v71;\n\t} else {\n\t\tctrl->cs_offsets = brcmnand_cs_offsets;\n\n\t\t \n\t\tif (ctrl->nand_version >= 0x0303 &&\n\t\t    ctrl->nand_version <= 0x0500)\n\t\t\tctrl->cs0_offsets = brcmnand_cs_offsets_cs0;\n\t}\n\n\t \n\tif (ctrl->nand_version >= 0x0701) {\n\t\t \n\t\tctrl->max_page_size = 16 * 1024;\n\t\tctrl->max_block_size = 2 * 1024 * 1024;\n\t} else {\n\t\tif (ctrl->nand_version >= 0x0304)\n\t\t\tctrl->page_sizes = page_sizes_v3_4;\n\t\telse if (ctrl->nand_version >= 0x0202)\n\t\t\tctrl->page_sizes = page_sizes_v2_2;\n\t\telse\n\t\t\tctrl->page_sizes = page_sizes_v2_1;\n\n\t\tif (ctrl->nand_version >= 0x0202)\n\t\t\tctrl->page_size_shift = CFG_PAGE_SIZE_SHIFT;\n\t\telse\n\t\t\tctrl->page_size_shift = CFG_PAGE_SIZE_SHIFT_v2_1;\n\n\t\tif (ctrl->nand_version >= 0x0600)\n\t\t\tctrl->block_sizes = block_sizes_v6;\n\t\telse if (ctrl->nand_version >= 0x0400)\n\t\t\tctrl->block_sizes = block_sizes_v4;\n\t\telse if (ctrl->nand_version >= 0x0202)\n\t\t\tctrl->block_sizes = block_sizes_v2_2;\n\t\telse\n\t\t\tctrl->block_sizes = block_sizes_v2_1;\n\n\t\tif (ctrl->nand_version < 0x0400) {\n\t\t\tif (ctrl->nand_version < 0x0202)\n\t\t\t\tctrl->max_page_size = 2048;\n\t\t\telse\n\t\t\t\tctrl->max_page_size = 4096;\n\t\t\tctrl->max_block_size = 512 * 1024;\n\t\t}\n\t}\n\n\t \n\tif (ctrl->nand_version == 0x0702)\n\t\tctrl->max_oob = 128;\n\telse if (ctrl->nand_version >= 0x0600)\n\t\tctrl->max_oob = 64;\n\telse if (ctrl->nand_version >= 0x0500)\n\t\tctrl->max_oob = 32;\n\telse\n\t\tctrl->max_oob = 16;\n\n\t \n\tif (ctrl->nand_version >= 0x0600 && ctrl->nand_version != 0x0601)\n\t\tctrl->features |= BRCMNAND_HAS_PREFETCH;\n\n\t \n\tif (ctrl->nand_version >= 0x0700)\n\t\tctrl->features |= BRCMNAND_HAS_CACHE_MODE;\n\n\tif (ctrl->nand_version >= 0x0500)\n\t\tctrl->features |= BRCMNAND_HAS_1K_SECTORS;\n\n\tif (ctrl->nand_version >= 0x0700)\n\t\tctrl->features |= BRCMNAND_HAS_WP;\n\telse if (of_property_read_bool(ctrl->dev->of_node, \"brcm,nand-has-wp\"))\n\t\tctrl->features |= BRCMNAND_HAS_WP;\n\n\t \n\tif (ctrl->nand_version == 0x0702)\n\t\tctrl->ecc_level_shift = ACC_CONTROL_ECC_EXT_SHIFT;\n\telse\n\t\tctrl->ecc_level_shift = ACC_CONTROL_ECC_SHIFT;\n\n\treturn 0;\n}\n\nstatic void brcmnand_flash_dma_revision_init(struct brcmnand_controller *ctrl)\n{\n\t \n\tif (ctrl->nand_version >= 0x0703)\n\t\tctrl->flash_dma_offsets = flash_dma_regs_v4;\n\telse if (ctrl->nand_version == 0x0602)\n\t\tctrl->flash_dma_offsets = flash_dma_regs_v0;\n\telse\n\t\tctrl->flash_dma_offsets = flash_dma_regs_v1;\n}\n\nstatic inline u32 brcmnand_read_reg(struct brcmnand_controller *ctrl,\n\t\tenum brcmnand_reg reg)\n{\n\tu16 offs = ctrl->reg_offsets[reg];\n\n\tif (offs)\n\t\treturn nand_readreg(ctrl, offs);\n\telse\n\t\treturn 0;\n}\n\nstatic inline void brcmnand_write_reg(struct brcmnand_controller *ctrl,\n\t\t\t\t      enum brcmnand_reg reg, u32 val)\n{\n\tu16 offs = ctrl->reg_offsets[reg];\n\n\tif (offs)\n\t\tnand_writereg(ctrl, offs, val);\n}\n\nstatic inline void brcmnand_rmw_reg(struct brcmnand_controller *ctrl,\n\t\t\t\t    enum brcmnand_reg reg, u32 mask, unsigned\n\t\t\t\t    int shift, u32 val)\n{\n\tu32 tmp = brcmnand_read_reg(ctrl, reg);\n\n\ttmp &= ~mask;\n\ttmp |= val << shift;\n\tbrcmnand_write_reg(ctrl, reg, tmp);\n}\n\nstatic inline u32 brcmnand_read_fc(struct brcmnand_controller *ctrl, int word)\n{\n\tif (brcmnand_non_mmio_ops(ctrl))\n\t\treturn brcmnand_soc_read(ctrl->soc, BRCMNAND_NON_MMIO_FC_ADDR);\n\treturn __raw_readl(ctrl->nand_fc + word * 4);\n}\n\nstatic inline void brcmnand_write_fc(struct brcmnand_controller *ctrl,\n\t\t\t\t     int word, u32 val)\n{\n\tif (brcmnand_non_mmio_ops(ctrl))\n\t\tbrcmnand_soc_write(ctrl->soc, val, BRCMNAND_NON_MMIO_FC_ADDR);\n\telse\n\t\t__raw_writel(val, ctrl->nand_fc + word * 4);\n}\n\nstatic inline void edu_writel(struct brcmnand_controller *ctrl,\n\t\t\t      enum edu_reg reg, u32 val)\n{\n\tu16 offs = ctrl->edu_offsets[reg];\n\n\tbrcmnand_writel(val, ctrl->edu_base + offs);\n}\n\nstatic inline u32 edu_readl(struct brcmnand_controller *ctrl,\n\t\t\t    enum edu_reg reg)\n{\n\tu16 offs = ctrl->edu_offsets[reg];\n\n\treturn brcmnand_readl(ctrl->edu_base + offs);\n}\n\nstatic void brcmnand_clear_ecc_addr(struct brcmnand_controller *ctrl)\n{\n\n\t \n\tbrcmnand_write_reg(ctrl, BRCMNAND_UNCORR_ADDR, 0);\n\tbrcmnand_write_reg(ctrl, BRCMNAND_CORR_ADDR, 0);\n\tbrcmnand_write_reg(ctrl, BRCMNAND_UNCORR_EXT_ADDR, 0);\n\tbrcmnand_write_reg(ctrl, BRCMNAND_CORR_EXT_ADDR, 0);\n}\n\nstatic u64 brcmnand_get_uncorrecc_addr(struct brcmnand_controller *ctrl)\n{\n\tu64 err_addr;\n\n\terr_addr = brcmnand_read_reg(ctrl, BRCMNAND_UNCORR_ADDR);\n\terr_addr |= ((u64)(brcmnand_read_reg(ctrl,\n\t\t\t\t\t     BRCMNAND_UNCORR_EXT_ADDR)\n\t\t\t\t\t     & 0xffff) << 32);\n\n\treturn err_addr;\n}\n\nstatic u64 brcmnand_get_correcc_addr(struct brcmnand_controller *ctrl)\n{\n\tu64 err_addr;\n\n\terr_addr = brcmnand_read_reg(ctrl, BRCMNAND_CORR_ADDR);\n\terr_addr |= ((u64)(brcmnand_read_reg(ctrl,\n\t\t\t\t\t     BRCMNAND_CORR_EXT_ADDR)\n\t\t\t\t\t     & 0xffff) << 32);\n\n\treturn err_addr;\n}\n\nstatic void brcmnand_set_cmd_addr(struct mtd_info *mtd, u64 addr)\n{\n\tstruct nand_chip *chip =  mtd_to_nand(mtd);\n\tstruct brcmnand_host *host = nand_get_controller_data(chip);\n\tstruct brcmnand_controller *ctrl = host->ctrl;\n\n\tbrcmnand_write_reg(ctrl, BRCMNAND_CMD_EXT_ADDRESS,\n\t\t\t   (host->cs << 16) | ((addr >> 32) & 0xffff));\n\t(void)brcmnand_read_reg(ctrl, BRCMNAND_CMD_EXT_ADDRESS);\n\tbrcmnand_write_reg(ctrl, BRCMNAND_CMD_ADDRESS,\n\t\t\t   lower_32_bits(addr));\n\t(void)brcmnand_read_reg(ctrl, BRCMNAND_CMD_ADDRESS);\n}\n\nstatic inline u16 brcmnand_cs_offset(struct brcmnand_controller *ctrl, int cs,\n\t\t\t\t     enum brcmnand_cs_reg reg)\n{\n\tu16 offs_cs0 = ctrl->reg_offsets[BRCMNAND_CS0_BASE];\n\tu16 offs_cs1 = ctrl->reg_offsets[BRCMNAND_CS1_BASE];\n\tu8 cs_offs;\n\n\tif (cs == 0 && ctrl->cs0_offsets)\n\t\tcs_offs = ctrl->cs0_offsets[reg];\n\telse\n\t\tcs_offs = ctrl->cs_offsets[reg];\n\n\tif (cs && offs_cs1)\n\t\treturn offs_cs1 + (cs - 1) * ctrl->reg_spacing + cs_offs;\n\n\treturn offs_cs0 + cs * ctrl->reg_spacing + cs_offs;\n}\n\nstatic inline u32 brcmnand_count_corrected(struct brcmnand_controller *ctrl)\n{\n\tif (ctrl->nand_version < 0x0600)\n\t\treturn 1;\n\treturn brcmnand_read_reg(ctrl, BRCMNAND_CORR_COUNT);\n}\n\nstatic void brcmnand_wr_corr_thresh(struct brcmnand_host *host, u8 val)\n{\n\tstruct brcmnand_controller *ctrl = host->ctrl;\n\tunsigned int shift = 0, bits;\n\tenum brcmnand_reg reg = BRCMNAND_CORR_THRESHOLD;\n\tint cs = host->cs;\n\n\tif (!ctrl->reg_offsets[reg])\n\t\treturn;\n\n\tif (ctrl->nand_version == 0x0702)\n\t\tbits = 7;\n\telse if (ctrl->nand_version >= 0x0600)\n\t\tbits = 6;\n\telse if (ctrl->nand_version >= 0x0500)\n\t\tbits = 5;\n\telse\n\t\tbits = 4;\n\n\tif (ctrl->nand_version >= 0x0702) {\n\t\tif (cs >= 4)\n\t\t\treg = BRCMNAND_CORR_THRESHOLD_EXT;\n\t\tshift = (cs % 4) * bits;\n\t} else if (ctrl->nand_version >= 0x0600) {\n\t\tif (cs >= 5)\n\t\t\treg = BRCMNAND_CORR_THRESHOLD_EXT;\n\t\tshift = (cs % 5) * bits;\n\t}\n\tbrcmnand_rmw_reg(ctrl, reg, (bits - 1) << shift, shift, val);\n}\n\nstatic inline int brcmnand_cmd_shift(struct brcmnand_controller *ctrl)\n{\n\t \n\tif (ctrl->nand_version == 0x0304 && brcmnand_non_mmio_ops(ctrl))\n\t\treturn 0;\n\n\tif (ctrl->nand_version < 0x0602)\n\t\treturn 24;\n\treturn 0;\n}\n\nstatic inline u32 brcmnand_spare_area_mask(struct brcmnand_controller *ctrl)\n{\n\tif (ctrl->nand_version == 0x0702)\n\t\treturn GENMASK(7, 0);\n\telse if (ctrl->nand_version >= 0x0600)\n\t\treturn GENMASK(6, 0);\n\telse if (ctrl->nand_version >= 0x0303)\n\t\treturn GENMASK(5, 0);\n\telse\n\t\treturn GENMASK(4, 0);\n}\n\nstatic inline u32 brcmnand_ecc_level_mask(struct brcmnand_controller *ctrl)\n{\n\tu32 mask = (ctrl->nand_version >= 0x0600) ? 0x1f : 0x0f;\n\n\tmask <<= ACC_CONTROL_ECC_SHIFT;\n\n\t \n\tif (ctrl->nand_version == 0x0702)\n\t\tmask |= 0x7 << ACC_CONTROL_ECC_EXT_SHIFT;\n\n\treturn mask;\n}\n\nstatic void brcmnand_set_ecc_enabled(struct brcmnand_host *host, int en)\n{\n\tstruct brcmnand_controller *ctrl = host->ctrl;\n\tu16 offs = brcmnand_cs_offset(ctrl, host->cs, BRCMNAND_CS_ACC_CONTROL);\n\tu32 acc_control = nand_readreg(ctrl, offs);\n\tu32 ecc_flags = ACC_CONTROL_WR_ECC | ACC_CONTROL_RD_ECC;\n\n\tif (en) {\n\t\tacc_control |= ecc_flags;  \n\t\tacc_control &= ~brcmnand_ecc_level_mask(ctrl);\n\t\tacc_control |= host->hwcfg.ecc_level << ctrl->ecc_level_shift;\n\t} else {\n\t\tacc_control &= ~ecc_flags;  \n\t\tacc_control &= ~brcmnand_ecc_level_mask(ctrl);\n\t}\n\n\tnand_writereg(ctrl, offs, acc_control);\n}\n\nstatic inline int brcmnand_sector_1k_shift(struct brcmnand_controller *ctrl)\n{\n\tif (ctrl->nand_version >= 0x0702)\n\t\treturn 9;\n\telse if (ctrl->nand_version >= 0x0600)\n\t\treturn 7;\n\telse if (ctrl->nand_version >= 0x0500)\n\t\treturn 6;\n\telse\n\t\treturn -1;\n}\n\nstatic int brcmnand_get_sector_size_1k(struct brcmnand_host *host)\n{\n\tstruct brcmnand_controller *ctrl = host->ctrl;\n\tint shift = brcmnand_sector_1k_shift(ctrl);\n\tu16 acc_control_offs = brcmnand_cs_offset(ctrl, host->cs,\n\t\t\t\t\t\t  BRCMNAND_CS_ACC_CONTROL);\n\n\tif (shift < 0)\n\t\treturn 0;\n\n\treturn (nand_readreg(ctrl, acc_control_offs) >> shift) & 0x1;\n}\n\nstatic void brcmnand_set_sector_size_1k(struct brcmnand_host *host, int val)\n{\n\tstruct brcmnand_controller *ctrl = host->ctrl;\n\tint shift = brcmnand_sector_1k_shift(ctrl);\n\tu16 acc_control_offs = brcmnand_cs_offset(ctrl, host->cs,\n\t\t\t\t\t\t  BRCMNAND_CS_ACC_CONTROL);\n\tu32 tmp;\n\n\tif (shift < 0)\n\t\treturn;\n\n\ttmp = nand_readreg(ctrl, acc_control_offs);\n\ttmp &= ~(1 << shift);\n\ttmp |= (!!val) << shift;\n\tnand_writereg(ctrl, acc_control_offs, tmp);\n}\n\n \n\nenum {\n\tCS_SELECT_NAND_WP\t\t\t= BIT(29),\n\tCS_SELECT_AUTO_DEVICE_ID_CFG\t\t= BIT(30),\n};\n\nstatic int bcmnand_ctrl_poll_status(struct brcmnand_controller *ctrl,\n\t\t\t\t    u32 mask, u32 expected_val,\n\t\t\t\t    unsigned long timeout_ms)\n{\n\tunsigned long limit;\n\tu32 val;\n\n\tif (!timeout_ms)\n\t\ttimeout_ms = NAND_POLL_STATUS_TIMEOUT_MS;\n\n\tlimit = jiffies + msecs_to_jiffies(timeout_ms);\n\tdo {\n\t\tval = brcmnand_read_reg(ctrl, BRCMNAND_INTFC_STATUS);\n\t\tif ((val & mask) == expected_val)\n\t\t\treturn 0;\n\n\t\tcpu_relax();\n\t} while (time_after(limit, jiffies));\n\n\t \n\tval = brcmnand_read_reg(ctrl, BRCMNAND_INTFC_STATUS);\n\tif ((val & mask) == expected_val)\n\t\treturn 0;\n\n\tdev_warn(ctrl->dev, \"timeout on status poll (expected %x got %x)\\n\",\n\t\t expected_val, val & mask);\n\n\treturn -ETIMEDOUT;\n}\n\nstatic inline void brcmnand_set_wp(struct brcmnand_controller *ctrl, bool en)\n{\n\tu32 val = en ? CS_SELECT_NAND_WP : 0;\n\n\tbrcmnand_rmw_reg(ctrl, BRCMNAND_CS_SELECT, CS_SELECT_NAND_WP, 0, val);\n}\n\n \n\nstatic inline bool has_flash_dma(struct brcmnand_controller *ctrl)\n{\n\treturn ctrl->flash_dma_base;\n}\n\nstatic inline bool has_edu(struct brcmnand_controller *ctrl)\n{\n\treturn ctrl->edu_base;\n}\n\nstatic inline bool use_dma(struct brcmnand_controller *ctrl)\n{\n\treturn has_flash_dma(ctrl) || has_edu(ctrl);\n}\n\nstatic inline void disable_ctrl_irqs(struct brcmnand_controller *ctrl)\n{\n\tif (ctrl->pio_poll_mode)\n\t\treturn;\n\n\tif (has_flash_dma(ctrl)) {\n\t\tctrl->flash_dma_base = NULL;\n\t\tdisable_irq(ctrl->dma_irq);\n\t}\n\n\tdisable_irq(ctrl->irq);\n\tctrl->pio_poll_mode = true;\n}\n\nstatic inline bool flash_dma_buf_ok(const void *buf)\n{\n\treturn buf && !is_vmalloc_addr(buf) &&\n\t\tlikely(IS_ALIGNED((uintptr_t)buf, 4));\n}\n\nstatic inline void flash_dma_writel(struct brcmnand_controller *ctrl,\n\t\t\t\t    enum flash_dma_reg dma_reg, u32 val)\n{\n\tu16 offs = ctrl->flash_dma_offsets[dma_reg];\n\n\tbrcmnand_writel(val, ctrl->flash_dma_base + offs);\n}\n\nstatic inline u32 flash_dma_readl(struct brcmnand_controller *ctrl,\n\t\t\t\t  enum flash_dma_reg dma_reg)\n{\n\tu16 offs = ctrl->flash_dma_offsets[dma_reg];\n\n\treturn brcmnand_readl(ctrl->flash_dma_base + offs);\n}\n\n \nenum brcmnand_llop_type {\n\tLL_OP_CMD,\n\tLL_OP_ADDR,\n\tLL_OP_WR,\n\tLL_OP_RD,\n};\n\n \n\nstatic inline bool is_hamming_ecc(struct brcmnand_controller *ctrl,\n\t\t\t\t  struct brcmnand_cfg *cfg)\n{\n\tif (ctrl->nand_version <= 0x0701)\n\t\treturn cfg->sector_size_1k == 0 && cfg->spare_area_size == 16 &&\n\t\t\tcfg->ecc_level == 15;\n\telse\n\t\treturn cfg->sector_size_1k == 0 && ((cfg->spare_area_size == 16 &&\n\t\t\tcfg->ecc_level == 15) ||\n\t\t\t(cfg->spare_area_size == 28 && cfg->ecc_level == 16));\n}\n\n \nstatic int brcmnand_hamming_ooblayout_ecc(struct mtd_info *mtd, int section,\n\t\t\t\t\t  struct mtd_oob_region *oobregion)\n{\n\tstruct nand_chip *chip = mtd_to_nand(mtd);\n\tstruct brcmnand_host *host = nand_get_controller_data(chip);\n\tstruct brcmnand_cfg *cfg = &host->hwcfg;\n\tint sas = cfg->spare_area_size << cfg->sector_size_1k;\n\tint sectors = cfg->page_size / (512 << cfg->sector_size_1k);\n\n\tif (section >= sectors)\n\t\treturn -ERANGE;\n\n\toobregion->offset = (section * sas) + 6;\n\toobregion->length = 3;\n\n\treturn 0;\n}\n\nstatic int brcmnand_hamming_ooblayout_free(struct mtd_info *mtd, int section,\n\t\t\t\t\t   struct mtd_oob_region *oobregion)\n{\n\tstruct nand_chip *chip = mtd_to_nand(mtd);\n\tstruct brcmnand_host *host = nand_get_controller_data(chip);\n\tstruct brcmnand_cfg *cfg = &host->hwcfg;\n\tint sas = cfg->spare_area_size << cfg->sector_size_1k;\n\tint sectors = cfg->page_size / (512 << cfg->sector_size_1k);\n\tu32 next;\n\n\tif (section > sectors)\n\t\treturn -ERANGE;\n\n\tnext = (section * sas);\n\tif (section < sectors)\n\t\tnext += 6;\n\n\tif (section) {\n\t\toobregion->offset = ((section - 1) * sas) + 9;\n\t} else {\n\t\tif (cfg->page_size > 512) {\n\t\t\t \n\t\t\toobregion->offset = 2;\n\t\t} else {\n\t\t\t \n\t\t\toobregion->offset = 0;\n\t\t\tnext--;\n\t\t}\n\t}\n\n\toobregion->length = next - oobregion->offset;\n\n\treturn 0;\n}\n\nstatic const struct mtd_ooblayout_ops brcmnand_hamming_ooblayout_ops = {\n\t.ecc = brcmnand_hamming_ooblayout_ecc,\n\t.free = brcmnand_hamming_ooblayout_free,\n};\n\nstatic int brcmnand_bch_ooblayout_ecc(struct mtd_info *mtd, int section,\n\t\t\t\t      struct mtd_oob_region *oobregion)\n{\n\tstruct nand_chip *chip = mtd_to_nand(mtd);\n\tstruct brcmnand_host *host = nand_get_controller_data(chip);\n\tstruct brcmnand_cfg *cfg = &host->hwcfg;\n\tint sas = cfg->spare_area_size << cfg->sector_size_1k;\n\tint sectors = cfg->page_size / (512 << cfg->sector_size_1k);\n\n\tif (section >= sectors)\n\t\treturn -ERANGE;\n\n\toobregion->offset = ((section + 1) * sas) - chip->ecc.bytes;\n\toobregion->length = chip->ecc.bytes;\n\n\treturn 0;\n}\n\nstatic int brcmnand_bch_ooblayout_free_lp(struct mtd_info *mtd, int section,\n\t\t\t\t\t  struct mtd_oob_region *oobregion)\n{\n\tstruct nand_chip *chip = mtd_to_nand(mtd);\n\tstruct brcmnand_host *host = nand_get_controller_data(chip);\n\tstruct brcmnand_cfg *cfg = &host->hwcfg;\n\tint sas = cfg->spare_area_size << cfg->sector_size_1k;\n\tint sectors = cfg->page_size / (512 << cfg->sector_size_1k);\n\n\tif (section >= sectors)\n\t\treturn -ERANGE;\n\n\tif (sas <= chip->ecc.bytes)\n\t\treturn 0;\n\n\toobregion->offset = section * sas;\n\toobregion->length = sas - chip->ecc.bytes;\n\n\tif (!section) {\n\t\toobregion->offset++;\n\t\toobregion->length--;\n\t}\n\n\treturn 0;\n}\n\nstatic int brcmnand_bch_ooblayout_free_sp(struct mtd_info *mtd, int section,\n\t\t\t\t\t  struct mtd_oob_region *oobregion)\n{\n\tstruct nand_chip *chip = mtd_to_nand(mtd);\n\tstruct brcmnand_host *host = nand_get_controller_data(chip);\n\tstruct brcmnand_cfg *cfg = &host->hwcfg;\n\tint sas = cfg->spare_area_size << cfg->sector_size_1k;\n\n\tif (section > 1 || sas - chip->ecc.bytes < 6 ||\n\t    (section && sas - chip->ecc.bytes == 6))\n\t\treturn -ERANGE;\n\n\tif (!section) {\n\t\toobregion->offset = 0;\n\t\toobregion->length = 5;\n\t} else {\n\t\toobregion->offset = 6;\n\t\toobregion->length = sas - chip->ecc.bytes - 6;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct mtd_ooblayout_ops brcmnand_bch_lp_ooblayout_ops = {\n\t.ecc = brcmnand_bch_ooblayout_ecc,\n\t.free = brcmnand_bch_ooblayout_free_lp,\n};\n\nstatic const struct mtd_ooblayout_ops brcmnand_bch_sp_ooblayout_ops = {\n\t.ecc = brcmnand_bch_ooblayout_ecc,\n\t.free = brcmnand_bch_ooblayout_free_sp,\n};\n\nstatic int brcmstb_choose_ecc_layout(struct brcmnand_host *host)\n{\n\tstruct brcmnand_cfg *p = &host->hwcfg;\n\tstruct mtd_info *mtd = nand_to_mtd(&host->chip);\n\tstruct nand_ecc_ctrl *ecc = &host->chip.ecc;\n\tunsigned int ecc_level = p->ecc_level;\n\tint sas = p->spare_area_size << p->sector_size_1k;\n\tint sectors = p->page_size / (512 << p->sector_size_1k);\n\n\tif (p->sector_size_1k)\n\t\tecc_level <<= 1;\n\n\tif (is_hamming_ecc(host->ctrl, p)) {\n\t\tecc->bytes = 3 * sectors;\n\t\tmtd_set_ooblayout(mtd, &brcmnand_hamming_ooblayout_ops);\n\t\treturn 0;\n\t}\n\n\t \n\tecc->bytes = DIV_ROUND_UP(ecc_level * 14, 8);\n\tif (p->page_size == 512)\n\t\tmtd_set_ooblayout(mtd, &brcmnand_bch_sp_ooblayout_ops);\n\telse\n\t\tmtd_set_ooblayout(mtd, &brcmnand_bch_lp_ooblayout_ops);\n\n\tif (ecc->bytes >= sas) {\n\t\tdev_err(&host->pdev->dev,\n\t\t\t\"error: ECC too large for OOB (ECC bytes %d, spare sector %d)\\n\",\n\t\t\tecc->bytes, sas);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic void brcmnand_wp(struct mtd_info *mtd, int wp)\n{\n\tstruct nand_chip *chip = mtd_to_nand(mtd);\n\tstruct brcmnand_host *host = nand_get_controller_data(chip);\n\tstruct brcmnand_controller *ctrl = host->ctrl;\n\n\tif ((ctrl->features & BRCMNAND_HAS_WP) && wp_on == 1) {\n\t\tstatic int old_wp = -1;\n\t\tint ret;\n\n\t\tif (old_wp != wp) {\n\t\t\tdev_dbg(ctrl->dev, \"WP %s\\n\", wp ? \"on\" : \"off\");\n\t\t\told_wp = wp;\n\t\t}\n\n\t\t \n\t\tret = bcmnand_ctrl_poll_status(ctrl, NAND_CTRL_RDY |\n\t\t\t\t\t       NAND_STATUS_READY,\n\t\t\t\t\t       NAND_CTRL_RDY |\n\t\t\t\t\t       NAND_STATUS_READY, 0);\n\t\tif (ret)\n\t\t\treturn;\n\n\t\tbrcmnand_set_wp(ctrl, wp);\n\t\tnand_status_op(chip, NULL);\n\t\t \n\t\tret = bcmnand_ctrl_poll_status(ctrl,\n\t\t\t\t\t       NAND_CTRL_RDY |\n\t\t\t\t\t       NAND_STATUS_READY |\n\t\t\t\t\t       NAND_STATUS_WP,\n\t\t\t\t\t       NAND_CTRL_RDY |\n\t\t\t\t\t       NAND_STATUS_READY |\n\t\t\t\t\t       (wp ? 0 : NAND_STATUS_WP), 0);\n\n\t\tif (ret)\n\t\t\tdev_err_ratelimited(&host->pdev->dev,\n\t\t\t\t\t    \"nand #WP expected %s\\n\",\n\t\t\t\t\t    wp ? \"on\" : \"off\");\n\t}\n}\n\n \nstatic inline u8 oob_reg_read(struct brcmnand_controller *ctrl, u32 offs)\n{\n\tu16 offset0, offset10, reg_offs;\n\n\toffset0 = ctrl->reg_offsets[BRCMNAND_OOB_READ_BASE];\n\toffset10 = ctrl->reg_offsets[BRCMNAND_OOB_READ_10_BASE];\n\n\tif (offs >= ctrl->max_oob)\n\t\treturn 0x77;\n\n\tif (offs >= 16 && offset10)\n\t\treg_offs = offset10 + ((offs - 0x10) & ~0x03);\n\telse\n\t\treg_offs = offset0 + (offs & ~0x03);\n\n\treturn nand_readreg(ctrl, reg_offs) >> (24 - ((offs & 0x03) << 3));\n}\n\nstatic inline void oob_reg_write(struct brcmnand_controller *ctrl, u32 offs,\n\t\t\t\t u32 data)\n{\n\tu16 offset0, offset10, reg_offs;\n\n\toffset0 = ctrl->reg_offsets[BRCMNAND_OOB_WRITE_BASE];\n\toffset10 = ctrl->reg_offsets[BRCMNAND_OOB_WRITE_10_BASE];\n\n\tif (offs >= ctrl->max_oob)\n\t\treturn;\n\n\tif (offs >= 16 && offset10)\n\t\treg_offs = offset10 + ((offs - 0x10) & ~0x03);\n\telse\n\t\treg_offs = offset0 + (offs & ~0x03);\n\n\tnand_writereg(ctrl, reg_offs, data);\n}\n\n \nstatic int read_oob_from_regs(struct brcmnand_controller *ctrl, int i, u8 *oob,\n\t\t\t      int sas, int sector_1k)\n{\n\tint tbytes = sas << sector_1k;\n\tint j;\n\n\t \n\tif (sector_1k && (i & 0x01))\n\t\ttbytes = max(0, tbytes - (int)ctrl->max_oob);\n\ttbytes = min_t(int, tbytes, ctrl->max_oob);\n\n\tfor (j = 0; j < tbytes; j++)\n\t\toob[j] = oob_reg_read(ctrl, j);\n\treturn tbytes;\n}\n\n \nstatic int write_oob_to_regs(struct brcmnand_controller *ctrl, int i,\n\t\t\t     const u8 *oob, int sas, int sector_1k)\n{\n\tint tbytes = sas << sector_1k;\n\tint j, k = 0;\n\tu32 last = 0xffffffff;\n\tu8 *plast = (u8 *)&last;\n\n\t \n\tif (sector_1k && (i & 0x01))\n\t\ttbytes = max(0, tbytes - (int)ctrl->max_oob);\n\ttbytes = min_t(int, tbytes, ctrl->max_oob);\n\n\t \n\tfor (j = 0; (j + 3) < tbytes; j += 4)\n\t\toob_reg_write(ctrl, j,\n\t\t\t\t(oob[j + 0] << 24) |\n\t\t\t\t(oob[j + 1] << 16) |\n\t\t\t\t(oob[j + 2] <<  8) |\n\t\t\t\t(oob[j + 3] <<  0));\n\n\t \n\twhile (j < tbytes)\n\t\tplast[k++] = oob[j++];\n\n\tif (tbytes & 0x3)\n\t\toob_reg_write(ctrl, (tbytes & ~0x3), (__force u32)cpu_to_be32(last));\n\n\treturn tbytes;\n}\n\nstatic void brcmnand_edu_init(struct brcmnand_controller *ctrl)\n{\n\t \n\tedu_writel(ctrl, EDU_ERR_STATUS, 0);\n\tedu_readl(ctrl, EDU_ERR_STATUS);\n\tedu_writel(ctrl, EDU_DONE, 0);\n\tedu_writel(ctrl, EDU_DONE, 0);\n\tedu_writel(ctrl, EDU_DONE, 0);\n\tedu_writel(ctrl, EDU_DONE, 0);\n\tedu_readl(ctrl, EDU_DONE);\n}\n\n \nstatic irqreturn_t brcmnand_edu_irq(int irq, void *data)\n{\n\tstruct brcmnand_controller *ctrl = data;\n\n\tif (ctrl->edu_count) {\n\t\tctrl->edu_count--;\n\t\twhile (!(edu_readl(ctrl, EDU_DONE) & EDU_DONE_MASK))\n\t\t\tudelay(1);\n\t\tedu_writel(ctrl, EDU_DONE, 0);\n\t\tedu_readl(ctrl, EDU_DONE);\n\t}\n\n\tif (ctrl->edu_count) {\n\t\tctrl->edu_dram_addr += FC_BYTES;\n\t\tctrl->edu_ext_addr += FC_BYTES;\n\n\t\tedu_writel(ctrl, EDU_DRAM_ADDR, (u32)ctrl->edu_dram_addr);\n\t\tedu_readl(ctrl, EDU_DRAM_ADDR);\n\t\tedu_writel(ctrl, EDU_EXT_ADDR, ctrl->edu_ext_addr);\n\t\tedu_readl(ctrl, EDU_EXT_ADDR);\n\n\t\tif (ctrl->oob) {\n\t\t\tif (ctrl->edu_cmd == EDU_CMD_READ) {\n\t\t\t\tctrl->oob += read_oob_from_regs(ctrl,\n\t\t\t\t\t\t\tctrl->edu_count + 1,\n\t\t\t\t\t\t\tctrl->oob, ctrl->sas,\n\t\t\t\t\t\t\tctrl->sector_size_1k);\n\t\t\t} else {\n\t\t\t\tbrcmnand_write_reg(ctrl, BRCMNAND_CMD_ADDRESS,\n\t\t\t\t\t\t   ctrl->edu_ext_addr);\n\t\t\t\tbrcmnand_read_reg(ctrl, BRCMNAND_CMD_ADDRESS);\n\t\t\t\tctrl->oob += write_oob_to_regs(ctrl,\n\t\t\t\t\t\t\t       ctrl->edu_count,\n\t\t\t\t\t\t\t       ctrl->oob, ctrl->sas,\n\t\t\t\t\t\t\t       ctrl->sector_size_1k);\n\t\t\t}\n\t\t}\n\n\t\tmb();  \n\t\tedu_writel(ctrl, EDU_CMD, ctrl->edu_cmd);\n\t\tedu_readl(ctrl, EDU_CMD);\n\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tcomplete(&ctrl->edu_done);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t brcmnand_ctlrdy_irq(int irq, void *data)\n{\n\tstruct brcmnand_controller *ctrl = data;\n\n\t \n\tif (ctrl->dma_pending)\n\t\treturn IRQ_HANDLED;\n\n\t \n\tif (ctrl->edu_pending) {\n\t\tif (irq == ctrl->irq && ((int)ctrl->edu_irq >= 0))\n\t \n\t\t\treturn IRQ_HANDLED;\n\n\t \n\t\treturn brcmnand_edu_irq(irq, data);\n\t}\n\n\tcomplete(&ctrl->done);\n\treturn IRQ_HANDLED;\n}\n\n \nstatic irqreturn_t brcmnand_irq(int irq, void *data)\n{\n\tstruct brcmnand_controller *ctrl = data;\n\n\tif (ctrl->soc->ctlrdy_ack(ctrl->soc))\n\t\treturn brcmnand_ctlrdy_irq(irq, data);\n\n\treturn IRQ_NONE;\n}\n\nstatic irqreturn_t brcmnand_dma_irq(int irq, void *data)\n{\n\tstruct brcmnand_controller *ctrl = data;\n\n\tcomplete(&ctrl->dma_done);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void brcmnand_send_cmd(struct brcmnand_host *host, int cmd)\n{\n\tstruct brcmnand_controller *ctrl = host->ctrl;\n\tint ret;\n\tu64 cmd_addr;\n\n\tcmd_addr = brcmnand_read_reg(ctrl, BRCMNAND_CMD_ADDRESS);\n\n\tdev_dbg(ctrl->dev, \"send native cmd %d addr 0x%llx\\n\", cmd, cmd_addr);\n\n\t \n\tif (oops_in_progress) {\n\t\tif (ctrl->cmd_pending &&\n\t\t\tbcmnand_ctrl_poll_status(ctrl, NAND_CTRL_RDY, NAND_CTRL_RDY, 0))\n\t\t\treturn;\n\t} else\n\t\tBUG_ON(ctrl->cmd_pending != 0);\n\tctrl->cmd_pending = cmd;\n\n\tret = bcmnand_ctrl_poll_status(ctrl, NAND_CTRL_RDY, NAND_CTRL_RDY, 0);\n\tWARN_ON(ret);\n\n\tmb();  \n\tbrcmnand_write_reg(ctrl, BRCMNAND_CMD_START,\n\t\t\t   cmd << brcmnand_cmd_shift(ctrl));\n}\n\n \n\nstatic void brcmnand_cmd_ctrl(struct nand_chip *chip, int dat,\n\t\t\t      unsigned int ctrl)\n{\n\t \n}\n\nstatic bool brcmstb_nand_wait_for_completion(struct nand_chip *chip)\n{\n\tstruct brcmnand_host *host = nand_get_controller_data(chip);\n\tstruct brcmnand_controller *ctrl = host->ctrl;\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tbool err = false;\n\tint sts;\n\n\tif (mtd->oops_panic_write || ctrl->irq < 0) {\n\t\t \n\t\tdisable_ctrl_irqs(ctrl);\n\t\tsts = bcmnand_ctrl_poll_status(ctrl, NAND_CTRL_RDY,\n\t\t\t\t\t       NAND_CTRL_RDY, 0);\n\t\terr = sts < 0;\n\t} else {\n\t\tunsigned long timeo = msecs_to_jiffies(\n\t\t\t\t\t\tNAND_POLL_STATUS_TIMEOUT_MS);\n\t\t \n\t\tsts = wait_for_completion_timeout(&ctrl->done, timeo);\n\t\terr = !sts;\n\t}\n\n\treturn err;\n}\n\nstatic int brcmnand_waitfunc(struct nand_chip *chip)\n{\n\tstruct brcmnand_host *host = nand_get_controller_data(chip);\n\tstruct brcmnand_controller *ctrl = host->ctrl;\n\tbool err = false;\n\n\tdev_dbg(ctrl->dev, \"wait on native cmd %d\\n\", ctrl->cmd_pending);\n\tif (ctrl->cmd_pending)\n\t\terr = brcmstb_nand_wait_for_completion(chip);\n\n\tctrl->cmd_pending = 0;\n\tif (err) {\n\t\tu32 cmd = brcmnand_read_reg(ctrl, BRCMNAND_CMD_START)\n\t\t\t\t\t>> brcmnand_cmd_shift(ctrl);\n\n\t\tdev_err_ratelimited(ctrl->dev,\n\t\t\t\"timeout waiting for command %#02x\\n\", cmd);\n\t\tdev_err_ratelimited(ctrl->dev, \"intfc status %08x\\n\",\n\t\t\tbrcmnand_read_reg(ctrl, BRCMNAND_INTFC_STATUS));\n\t\treturn -ETIMEDOUT;\n\t}\n\treturn brcmnand_read_reg(ctrl, BRCMNAND_INTFC_STATUS) &\n\t\t\t\t INTFC_FLASH_STATUS;\n}\n\nenum {\n\tLLOP_RE\t\t\t\t= BIT(16),\n\tLLOP_WE\t\t\t\t= BIT(17),\n\tLLOP_ALE\t\t\t= BIT(18),\n\tLLOP_CLE\t\t\t= BIT(19),\n\tLLOP_RETURN_IDLE\t\t= BIT(31),\n\n\tLLOP_DATA_MASK\t\t\t= GENMASK(15, 0),\n};\n\nstatic int brcmnand_low_level_op(struct brcmnand_host *host,\n\t\t\t\t enum brcmnand_llop_type type, u32 data,\n\t\t\t\t bool last_op)\n{\n\tstruct nand_chip *chip = &host->chip;\n\tstruct brcmnand_controller *ctrl = host->ctrl;\n\tu32 tmp;\n\n\ttmp = data & LLOP_DATA_MASK;\n\tswitch (type) {\n\tcase LL_OP_CMD:\n\t\ttmp |= LLOP_WE | LLOP_CLE;\n\t\tbreak;\n\tcase LL_OP_ADDR:\n\t\t \n\t\ttmp |= LLOP_WE | LLOP_ALE;\n\t\tbreak;\n\tcase LL_OP_WR:\n\t\t \n\t\ttmp |= LLOP_WE;\n\t\tbreak;\n\tcase LL_OP_RD:\n\t\t \n\t\ttmp |= LLOP_RE;\n\t\tbreak;\n\t}\n\tif (last_op)\n\t\t \n\t\ttmp |= LLOP_RETURN_IDLE;\n\n\tdev_dbg(ctrl->dev, \"ll_op cmd %#x\\n\", tmp);\n\n\tbrcmnand_write_reg(ctrl, BRCMNAND_LL_OP, tmp);\n\t(void)brcmnand_read_reg(ctrl, BRCMNAND_LL_OP);\n\n\tbrcmnand_send_cmd(host, CMD_LOW_LEVEL_OP);\n\treturn brcmnand_waitfunc(chip);\n}\n\nstatic void brcmnand_cmdfunc(struct nand_chip *chip, unsigned command,\n\t\t\t     int column, int page_addr)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tstruct brcmnand_host *host = nand_get_controller_data(chip);\n\tstruct brcmnand_controller *ctrl = host->ctrl;\n\tu64 addr = (u64)page_addr << chip->page_shift;\n\tint native_cmd = 0;\n\n\tif (command == NAND_CMD_READID || command == NAND_CMD_PARAM ||\n\t\t\tcommand == NAND_CMD_RNDOUT)\n\t\taddr = (u64)column;\n\t \n\telse if (page_addr < 0)\n\t\taddr = 0;\n\n\tdev_dbg(ctrl->dev, \"cmd 0x%x addr 0x%llx\\n\", command,\n\t\t(unsigned long long)addr);\n\n\thost->last_cmd = command;\n\thost->last_byte = 0;\n\thost->last_addr = addr;\n\n\tswitch (command) {\n\tcase NAND_CMD_RESET:\n\t\tnative_cmd = CMD_FLASH_RESET;\n\t\tbreak;\n\tcase NAND_CMD_STATUS:\n\t\tnative_cmd = CMD_STATUS_READ;\n\t\tbreak;\n\tcase NAND_CMD_READID:\n\t\tnative_cmd = CMD_DEVICE_ID_READ;\n\t\tbreak;\n\tcase NAND_CMD_READOOB:\n\t\tnative_cmd = CMD_SPARE_AREA_READ;\n\t\tbreak;\n\tcase NAND_CMD_ERASE1:\n\t\tnative_cmd = CMD_BLOCK_ERASE;\n\t\tbrcmnand_wp(mtd, 0);\n\t\tbreak;\n\tcase NAND_CMD_PARAM:\n\t\tnative_cmd = CMD_PARAMETER_READ;\n\t\tbreak;\n\tcase NAND_CMD_SET_FEATURES:\n\tcase NAND_CMD_GET_FEATURES:\n\t\tbrcmnand_low_level_op(host, LL_OP_CMD, command, false);\n\t\tbrcmnand_low_level_op(host, LL_OP_ADDR, column, false);\n\t\tbreak;\n\tcase NAND_CMD_RNDOUT:\n\t\tnative_cmd = CMD_PARAMETER_CHANGE_COL;\n\t\taddr &= ~((u64)(FC_BYTES - 1));\n\t\t \n\t\tif (brcmnand_get_sector_size_1k(host)) {\n\t\t\thost->hwcfg.sector_size_1k =\n\t\t\t\tbrcmnand_get_sector_size_1k(host);\n\t\t\tbrcmnand_set_sector_size_1k(host, 0);\n\t\t}\n\t\tbreak;\n\t}\n\n\tif (!native_cmd)\n\t\treturn;\n\n\tbrcmnand_set_cmd_addr(mtd, addr);\n\tbrcmnand_send_cmd(host, native_cmd);\n\tbrcmnand_waitfunc(chip);\n\n\tif (native_cmd == CMD_PARAMETER_READ ||\n\t\t\tnative_cmd == CMD_PARAMETER_CHANGE_COL) {\n\t\t \n\t\tu32 *flash_cache = (u32 *)ctrl->flash_cache;\n\t\tint i;\n\n\t\tbrcmnand_soc_data_bus_prepare(ctrl->soc, true);\n\n\t\t \n\t\tfor (i = 0; i < FC_WORDS; i++)\n\t\t\t \n\t\t\tflash_cache[i] = be32_to_cpu(brcmnand_read_fc(ctrl, i));\n\n\t\tbrcmnand_soc_data_bus_unprepare(ctrl->soc, true);\n\n\t\t \n\t\tif (host->hwcfg.sector_size_1k)\n\t\t\tbrcmnand_set_sector_size_1k(host,\n\t\t\t\t\t\t    host->hwcfg.sector_size_1k);\n\t}\n\n\t \n\tif (command == NAND_CMD_ERASE1)\n\t\tbrcmnand_wp(mtd, 1);\n}\n\nstatic uint8_t brcmnand_read_byte(struct nand_chip *chip)\n{\n\tstruct brcmnand_host *host = nand_get_controller_data(chip);\n\tstruct brcmnand_controller *ctrl = host->ctrl;\n\tuint8_t ret = 0;\n\tint addr, offs;\n\n\tswitch (host->last_cmd) {\n\tcase NAND_CMD_READID:\n\t\tif (host->last_byte < 4)\n\t\t\tret = brcmnand_read_reg(ctrl, BRCMNAND_ID) >>\n\t\t\t\t(24 - (host->last_byte << 3));\n\t\telse if (host->last_byte < 8)\n\t\t\tret = brcmnand_read_reg(ctrl, BRCMNAND_ID_EXT) >>\n\t\t\t\t(56 - (host->last_byte << 3));\n\t\tbreak;\n\n\tcase NAND_CMD_READOOB:\n\t\tret = oob_reg_read(ctrl, host->last_byte);\n\t\tbreak;\n\n\tcase NAND_CMD_STATUS:\n\t\tret = brcmnand_read_reg(ctrl, BRCMNAND_INTFC_STATUS) &\n\t\t\t\t\tINTFC_FLASH_STATUS;\n\t\tif (wp_on)  \n\t\t\tret |= NAND_STATUS_WP;\n\t\tbreak;\n\n\tcase NAND_CMD_PARAM:\n\tcase NAND_CMD_RNDOUT:\n\t\taddr = host->last_addr + host->last_byte;\n\t\toffs = addr & (FC_BYTES - 1);\n\n\t\t \n\t\tif (host->last_byte > 0 && offs == 0)\n\t\t\tnand_change_read_column_op(chip, addr, NULL, 0, false);\n\n\t\tret = ctrl->flash_cache[offs];\n\t\tbreak;\n\tcase NAND_CMD_GET_FEATURES:\n\t\tif (host->last_byte >= ONFI_SUBFEATURE_PARAM_LEN) {\n\t\t\tret = 0;\n\t\t} else {\n\t\t\tbool last = host->last_byte ==\n\t\t\t\tONFI_SUBFEATURE_PARAM_LEN - 1;\n\t\t\tbrcmnand_low_level_op(host, LL_OP_RD, 0, last);\n\t\t\tret = brcmnand_read_reg(ctrl, BRCMNAND_LL_RDATA) & 0xff;\n\t\t}\n\t}\n\n\tdev_dbg(ctrl->dev, \"read byte = 0x%02x\\n\", ret);\n\thost->last_byte++;\n\n\treturn ret;\n}\n\nstatic void brcmnand_read_buf(struct nand_chip *chip, uint8_t *buf, int len)\n{\n\tint i;\n\n\tfor (i = 0; i < len; i++, buf++)\n\t\t*buf = brcmnand_read_byte(chip);\n}\n\nstatic void brcmnand_write_buf(struct nand_chip *chip, const uint8_t *buf,\n\t\t\t       int len)\n{\n\tint i;\n\tstruct brcmnand_host *host = nand_get_controller_data(chip);\n\n\tswitch (host->last_cmd) {\n\tcase NAND_CMD_SET_FEATURES:\n\t\tfor (i = 0; i < len; i++)\n\t\t\tbrcmnand_low_level_op(host, LL_OP_WR, buf[i],\n\t\t\t\t\t\t  (i + 1) == len);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t\tbreak;\n\t}\n}\n\n \nstatic int brcmnand_edu_trans(struct brcmnand_host *host, u64 addr, u32 *buf,\n\t\t\t      u8 *oob, u32 len, u8 cmd)\n{\n\tstruct brcmnand_controller *ctrl = host->ctrl;\n\tstruct brcmnand_cfg *cfg = &host->hwcfg;\n\tunsigned long timeo = msecs_to_jiffies(200);\n\tint ret = 0;\n\tint dir = (cmd == CMD_PAGE_READ ? DMA_FROM_DEVICE : DMA_TO_DEVICE);\n\tu8 edu_cmd = (cmd == CMD_PAGE_READ ? EDU_CMD_READ : EDU_CMD_WRITE);\n\tunsigned int trans = len >> FC_SHIFT;\n\tdma_addr_t pa;\n\n\tdev_dbg(ctrl->dev, \"EDU %s %p:%p\\n\", ((edu_cmd == EDU_CMD_READ) ?\n\t\t\t\t\t      \"read\" : \"write\"), buf, oob);\n\n\tpa = dma_map_single(ctrl->dev, buf, len, dir);\n\tif (dma_mapping_error(ctrl->dev, pa)) {\n\t\tdev_err(ctrl->dev, \"unable to map buffer for EDU DMA\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tctrl->edu_pending = true;\n\tctrl->edu_dram_addr = pa;\n\tctrl->edu_ext_addr = addr;\n\tctrl->edu_cmd = edu_cmd;\n\tctrl->edu_count = trans;\n\tctrl->sas = cfg->spare_area_size;\n\tctrl->oob = oob;\n\n\tedu_writel(ctrl, EDU_DRAM_ADDR, (u32)ctrl->edu_dram_addr);\n\tedu_readl(ctrl,  EDU_DRAM_ADDR);\n\tedu_writel(ctrl, EDU_EXT_ADDR, ctrl->edu_ext_addr);\n\tedu_readl(ctrl, EDU_EXT_ADDR);\n\tedu_writel(ctrl, EDU_LENGTH, FC_BYTES);\n\tedu_readl(ctrl, EDU_LENGTH);\n\n\tif (ctrl->oob && (ctrl->edu_cmd == EDU_CMD_WRITE)) {\n\t\tbrcmnand_write_reg(ctrl, BRCMNAND_CMD_ADDRESS,\n\t\t\t\t   ctrl->edu_ext_addr);\n\t\tbrcmnand_read_reg(ctrl, BRCMNAND_CMD_ADDRESS);\n\t\tctrl->oob += write_oob_to_regs(ctrl,\n\t\t\t\t\t       1,\n\t\t\t\t\t       ctrl->oob, ctrl->sas,\n\t\t\t\t\t       ctrl->sector_size_1k);\n\t}\n\n\t \n\tmb();  \n\tedu_writel(ctrl, EDU_CMD, ctrl->edu_cmd);\n\tedu_readl(ctrl, EDU_CMD);\n\n\tif (wait_for_completion_timeout(&ctrl->edu_done, timeo) <= 0) {\n\t\tdev_err(ctrl->dev,\n\t\t\t\"timeout waiting for EDU; status %#x, error status %#x\\n\",\n\t\t\tedu_readl(ctrl, EDU_STATUS),\n\t\t\tedu_readl(ctrl, EDU_ERR_STATUS));\n\t}\n\n\tdma_unmap_single(ctrl->dev, pa, len, dir);\n\n\t \n\tif (ctrl->oob && (ctrl->edu_cmd == EDU_CMD_READ)) {\n\t\tctrl->oob += read_oob_from_regs(ctrl,\n\t\t\t\t\t\t1,\n\t\t\t\t\t\tctrl->oob, ctrl->sas,\n\t\t\t\t\t\tctrl->sector_size_1k);\n\t}\n\n\t \n\tif (((brcmnand_read_reg(ctrl, BRCMNAND_INTFC_STATUS) &\n\t      INTFC_FLASH_STATUS) & NAND_STATUS_FAIL) &&\n\t    edu_cmd == EDU_CMD_WRITE) {\n\t\tdev_info(ctrl->dev, \"program failed at %llx\\n\",\n\t\t\t (unsigned long long)addr);\n\t\tret = -EIO;\n\t}\n\n\t \n\tif (edu_readl(ctrl, EDU_STATUS) & EDU_STATUS_ACTIVE)\n\t\tdev_warn(ctrl->dev, \"EDU still active: %#x\\n\",\n\t\t\t edu_readl(ctrl, EDU_STATUS));\n\n\tif (unlikely(edu_readl(ctrl, EDU_ERR_STATUS) & EDU_ERR_STATUS_ERRACK)) {\n\t\tdev_warn(ctrl->dev, \"EDU RBUS error at addr %llx\\n\",\n\t\t\t (unsigned long long)addr);\n\t\tret = -EIO;\n\t}\n\n\tctrl->edu_pending = false;\n\tbrcmnand_edu_init(ctrl);\n\tedu_writel(ctrl, EDU_STOP, 0);  \n\tedu_readl(ctrl, EDU_STOP);\n\n\tif (!ret && edu_cmd == EDU_CMD_READ) {\n\t\tu64 err_addr = 0;\n\n\t\t \n\t\terr_addr = brcmnand_get_uncorrecc_addr(ctrl);\n\t\tif (!err_addr) {\n\t\t\terr_addr = brcmnand_get_correcc_addr(ctrl);\n\t\t\tif (err_addr)\n\t\t\t\tret = -EUCLEAN;\n\t\t} else\n\t\t\tret = -EBADMSG;\n\t}\n\n\treturn ret;\n}\n\n \nstatic int brcmnand_fill_dma_desc(struct brcmnand_host *host,\n\t\t\t\t  struct brcm_nand_dma_desc *desc, u64 addr,\n\t\t\t\t  dma_addr_t buf, u32 len, u8 dma_cmd,\n\t\t\t\t  bool begin, bool end,\n\t\t\t\t  dma_addr_t next_desc)\n{\n\tmemset(desc, 0, sizeof(*desc));\n\t \n\tdesc->next_desc = lower_32_bits(next_desc);\n\tdesc->next_desc_ext = upper_32_bits(next_desc);\n\tdesc->cmd_irq = (dma_cmd << 24) |\n\t\t(end ? (0x03 << 8) : 0) |  \n\t\t(!!begin) | ((!!end) << 1);  \n#ifdef CONFIG_CPU_BIG_ENDIAN\n\tdesc->cmd_irq |= 0x01 << 12;\n#endif\n\tdesc->dram_addr = lower_32_bits(buf);\n\tdesc->dram_addr_ext = upper_32_bits(buf);\n\tdesc->tfr_len = len;\n\tdesc->total_len = len;\n\tdesc->flash_addr = lower_32_bits(addr);\n\tdesc->flash_addr_ext = upper_32_bits(addr);\n\tdesc->cs = host->cs;\n\tdesc->status_valid = 0x01;\n\treturn 0;\n}\n\n \nstatic void brcmnand_dma_run(struct brcmnand_host *host, dma_addr_t desc)\n{\n\tstruct brcmnand_controller *ctrl = host->ctrl;\n\tunsigned long timeo = msecs_to_jiffies(100);\n\n\tflash_dma_writel(ctrl, FLASH_DMA_FIRST_DESC, lower_32_bits(desc));\n\t(void)flash_dma_readl(ctrl, FLASH_DMA_FIRST_DESC);\n\tif (ctrl->nand_version > 0x0602) {\n\t\tflash_dma_writel(ctrl, FLASH_DMA_FIRST_DESC_EXT,\n\t\t\t\t upper_32_bits(desc));\n\t\t(void)flash_dma_readl(ctrl, FLASH_DMA_FIRST_DESC_EXT);\n\t}\n\n\t \n\tctrl->dma_pending = true;\n\tmb();  \n\tflash_dma_writel(ctrl, FLASH_DMA_CTRL, 0x03);  \n\n\tif (wait_for_completion_timeout(&ctrl->dma_done, timeo) <= 0) {\n\t\tdev_err(ctrl->dev,\n\t\t\t\t\"timeout waiting for DMA; status %#x, error status %#x\\n\",\n\t\t\t\tflash_dma_readl(ctrl, FLASH_DMA_STATUS),\n\t\t\t\tflash_dma_readl(ctrl, FLASH_DMA_ERROR_STATUS));\n\t}\n\tctrl->dma_pending = false;\n\tflash_dma_writel(ctrl, FLASH_DMA_CTRL, 0);  \n}\n\nstatic int brcmnand_dma_trans(struct brcmnand_host *host, u64 addr, u32 *buf,\n\t\t\t      u8 *oob, u32 len, u8 dma_cmd)\n{\n\tstruct brcmnand_controller *ctrl = host->ctrl;\n\tdma_addr_t buf_pa;\n\tint dir = dma_cmd == CMD_PAGE_READ ? DMA_FROM_DEVICE : DMA_TO_DEVICE;\n\n\tbuf_pa = dma_map_single(ctrl->dev, buf, len, dir);\n\tif (dma_mapping_error(ctrl->dev, buf_pa)) {\n\t\tdev_err(ctrl->dev, \"unable to map buffer for DMA\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tbrcmnand_fill_dma_desc(host, ctrl->dma_desc, addr, buf_pa, len,\n\t\t\t\t   dma_cmd, true, true, 0);\n\n\tbrcmnand_dma_run(host, ctrl->dma_pa);\n\n\tdma_unmap_single(ctrl->dev, buf_pa, len, dir);\n\n\tif (ctrl->dma_desc->status_valid & FLASH_DMA_ECC_ERROR)\n\t\treturn -EBADMSG;\n\telse if (ctrl->dma_desc->status_valid & FLASH_DMA_CORR_ERROR)\n\t\treturn -EUCLEAN;\n\n\treturn 0;\n}\n\n \nstatic int brcmnand_read_by_pio(struct mtd_info *mtd, struct nand_chip *chip,\n\t\t\t\tu64 addr, unsigned int trans, u32 *buf,\n\t\t\t\tu8 *oob, u64 *err_addr)\n{\n\tstruct brcmnand_host *host = nand_get_controller_data(chip);\n\tstruct brcmnand_controller *ctrl = host->ctrl;\n\tint i, j, ret = 0;\n\n\tbrcmnand_clear_ecc_addr(ctrl);\n\n\tfor (i = 0; i < trans; i++, addr += FC_BYTES) {\n\t\tbrcmnand_set_cmd_addr(mtd, addr);\n\t\t \n\t\tbrcmnand_send_cmd(host, CMD_PAGE_READ);\n\t\tbrcmnand_waitfunc(chip);\n\n\t\tif (likely(buf)) {\n\t\t\tbrcmnand_soc_data_bus_prepare(ctrl->soc, false);\n\n\t\t\tfor (j = 0; j < FC_WORDS; j++, buf++)\n\t\t\t\t*buf = brcmnand_read_fc(ctrl, j);\n\n\t\t\tbrcmnand_soc_data_bus_unprepare(ctrl->soc, false);\n\t\t}\n\n\t\tif (oob)\n\t\t\toob += read_oob_from_regs(ctrl, i, oob,\n\t\t\t\t\tmtd->oobsize / trans,\n\t\t\t\t\thost->hwcfg.sector_size_1k);\n\n\t\tif (ret != -EBADMSG) {\n\t\t\t*err_addr = brcmnand_get_uncorrecc_addr(ctrl);\n\n\t\t\tif (*err_addr)\n\t\t\t\tret = -EBADMSG;\n\t\t}\n\n\t\tif (!ret) {\n\t\t\t*err_addr = brcmnand_get_correcc_addr(ctrl);\n\n\t\t\tif (*err_addr)\n\t\t\t\tret = -EUCLEAN;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\n \nstatic int brcmstb_nand_verify_erased_page(struct mtd_info *mtd,\n\t\t  struct nand_chip *chip, void *buf, u64 addr)\n{\n\tstruct mtd_oob_region ecc;\n\tint i;\n\tint bitflips = 0;\n\tint page = addr >> chip->page_shift;\n\tint ret;\n\tvoid *ecc_bytes;\n\tvoid *ecc_chunk;\n\n\tif (!buf)\n\t\tbuf = nand_get_data_buf(chip);\n\n\t \n\tret = chip->ecc.read_page_raw(chip, buf, true, page);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < chip->ecc.steps; i++) {\n\t\tecc_chunk = buf + chip->ecc.size * i;\n\n\t\tmtd_ooblayout_ecc(mtd, i, &ecc);\n\t\tecc_bytes = chip->oob_poi + ecc.offset;\n\n\t\tret = nand_check_erased_ecc_chunk(ecc_chunk, chip->ecc.size,\n\t\t\t\t\t\t  ecc_bytes, ecc.length,\n\t\t\t\t\t\t  NULL, 0,\n\t\t\t\t\t\t  chip->ecc.strength);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tbitflips = max(bitflips, ret);\n\t}\n\n\treturn bitflips;\n}\n\nstatic int brcmnand_read(struct mtd_info *mtd, struct nand_chip *chip,\n\t\t\t u64 addr, unsigned int trans, u32 *buf, u8 *oob)\n{\n\tstruct brcmnand_host *host = nand_get_controller_data(chip);\n\tstruct brcmnand_controller *ctrl = host->ctrl;\n\tu64 err_addr = 0;\n\tint err;\n\tbool retry = true;\n\tbool edu_err = false;\n\n\tdev_dbg(ctrl->dev, \"read %llx -> %p\\n\", (unsigned long long)addr, buf);\n\ntry_dmaread:\n\tbrcmnand_clear_ecc_addr(ctrl);\n\n\tif (ctrl->dma_trans && (has_edu(ctrl) || !oob) &&\n\t    flash_dma_buf_ok(buf)) {\n\t\terr = ctrl->dma_trans(host, addr, buf, oob,\n\t\t\t\t      trans * FC_BYTES,\n\t\t\t\t      CMD_PAGE_READ);\n\n\t\tif (err) {\n\t\t\tif (mtd_is_bitflip_or_eccerr(err))\n\t\t\t\terr_addr = addr;\n\t\t\telse\n\t\t\t\treturn -EIO;\n\t\t}\n\n\t\tif (has_edu(ctrl) && err_addr)\n\t\t\tedu_err = true;\n\n\t} else {\n\t\tif (oob)\n\t\t\tmemset(oob, 0x99, mtd->oobsize);\n\n\t\terr = brcmnand_read_by_pio(mtd, chip, addr, trans, buf,\n\t\t\t\t\t       oob, &err_addr);\n\t}\n\n\tif (mtd_is_eccerr(err)) {\n\t\t \n\t\tif ((ctrl->nand_version == 0x0700) ||\n\t\t    (ctrl->nand_version == 0x0701)) {\n\t\t\tif (retry) {\n\t\t\t\tretry = false;\n\t\t\t\tgoto try_dmaread;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (ctrl->nand_version < 0x0702) {\n\t\t\terr = brcmstb_nand_verify_erased_page(mtd, chip, buf,\n\t\t\t\t\t\t\t      addr);\n\t\t\t \n\t\t\tif (err >= 0)\n\t\t\t\treturn err;\n\t\t}\n\n\t\tdev_dbg(ctrl->dev, \"uncorrectable error at 0x%llx\\n\",\n\t\t\t(unsigned long long)err_addr);\n\t\tmtd->ecc_stats.failed++;\n\t\t \n\t\treturn 0;\n\t}\n\n\tif (mtd_is_bitflip(err)) {\n\t\tunsigned int corrected = brcmnand_count_corrected(ctrl);\n\n\t\t \n\t\tif (edu_err)\n\t\t\terr = brcmnand_read_by_pio(mtd, chip, addr, trans, buf,\n\t\t\t\t\t\t   oob, &err_addr);\n\n\t\tdev_dbg(ctrl->dev, \"corrected error at 0x%llx\\n\",\n\t\t\t(unsigned long long)err_addr);\n\t\tmtd->ecc_stats.corrected += corrected;\n\t\t \n\t\treturn max(mtd->bitflip_threshold, corrected);\n\t}\n\n\treturn 0;\n}\n\nstatic int brcmnand_read_page(struct nand_chip *chip, uint8_t *buf,\n\t\t\t      int oob_required, int page)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tstruct brcmnand_host *host = nand_get_controller_data(chip);\n\tu8 *oob = oob_required ? (u8 *)chip->oob_poi : NULL;\n\n\tnand_read_page_op(chip, page, 0, NULL, 0);\n\n\treturn brcmnand_read(mtd, chip, host->last_addr,\n\t\t\tmtd->writesize >> FC_SHIFT, (u32 *)buf, oob);\n}\n\nstatic int brcmnand_read_page_raw(struct nand_chip *chip, uint8_t *buf,\n\t\t\t\t  int oob_required, int page)\n{\n\tstruct brcmnand_host *host = nand_get_controller_data(chip);\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tu8 *oob = oob_required ? (u8 *)chip->oob_poi : NULL;\n\tint ret;\n\n\tnand_read_page_op(chip, page, 0, NULL, 0);\n\n\tbrcmnand_set_ecc_enabled(host, 0);\n\tret = brcmnand_read(mtd, chip, host->last_addr,\n\t\t\tmtd->writesize >> FC_SHIFT, (u32 *)buf, oob);\n\tbrcmnand_set_ecc_enabled(host, 1);\n\treturn ret;\n}\n\nstatic int brcmnand_read_oob(struct nand_chip *chip, int page)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\n\treturn brcmnand_read(mtd, chip, (u64)page << chip->page_shift,\n\t\t\tmtd->writesize >> FC_SHIFT,\n\t\t\tNULL, (u8 *)chip->oob_poi);\n}\n\nstatic int brcmnand_read_oob_raw(struct nand_chip *chip, int page)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tstruct brcmnand_host *host = nand_get_controller_data(chip);\n\n\tbrcmnand_set_ecc_enabled(host, 0);\n\tbrcmnand_read(mtd, chip, (u64)page << chip->page_shift,\n\t\tmtd->writesize >> FC_SHIFT,\n\t\tNULL, (u8 *)chip->oob_poi);\n\tbrcmnand_set_ecc_enabled(host, 1);\n\treturn 0;\n}\n\nstatic int brcmnand_write(struct mtd_info *mtd, struct nand_chip *chip,\n\t\t\t  u64 addr, const u32 *buf, u8 *oob)\n{\n\tstruct brcmnand_host *host = nand_get_controller_data(chip);\n\tstruct brcmnand_controller *ctrl = host->ctrl;\n\tunsigned int i, j, trans = mtd->writesize >> FC_SHIFT;\n\tint status, ret = 0;\n\n\tdev_dbg(ctrl->dev, \"write %llx <- %p\\n\", (unsigned long long)addr, buf);\n\n\tif (unlikely((unsigned long)buf & 0x03)) {\n\t\tdev_warn(ctrl->dev, \"unaligned buffer: %p\\n\", buf);\n\t\tbuf = (u32 *)((unsigned long)buf & ~0x03);\n\t}\n\n\tbrcmnand_wp(mtd, 0);\n\n\tfor (i = 0; i < ctrl->max_oob; i += 4)\n\t\toob_reg_write(ctrl, i, 0xffffffff);\n\n\tif (mtd->oops_panic_write)\n\t\t \n\t\tdisable_ctrl_irqs(ctrl);\n\n\tif (use_dma(ctrl) && (has_edu(ctrl) || !oob) && flash_dma_buf_ok(buf)) {\n\t\tif (ctrl->dma_trans(host, addr, (u32 *)buf, oob, mtd->writesize,\n\t\t\t\t    CMD_PROGRAM_PAGE))\n\n\t\t\tret = -EIO;\n\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < trans; i++, addr += FC_BYTES) {\n\t\t \n\t\tbrcmnand_set_cmd_addr(mtd, addr);\n\n\t\tif (buf) {\n\t\t\tbrcmnand_soc_data_bus_prepare(ctrl->soc, false);\n\n\t\t\tfor (j = 0; j < FC_WORDS; j++, buf++)\n\t\t\t\tbrcmnand_write_fc(ctrl, j, *buf);\n\n\t\t\tbrcmnand_soc_data_bus_unprepare(ctrl->soc, false);\n\t\t} else if (oob) {\n\t\t\tfor (j = 0; j < FC_WORDS; j++)\n\t\t\t\tbrcmnand_write_fc(ctrl, j, 0xffffffff);\n\t\t}\n\n\t\tif (oob) {\n\t\t\toob += write_oob_to_regs(ctrl, i, oob,\n\t\t\t\t\tmtd->oobsize / trans,\n\t\t\t\t\thost->hwcfg.sector_size_1k);\n\t\t}\n\n\t\t \n\t\tbrcmnand_send_cmd(host, CMD_PROGRAM_PAGE);\n\t\tstatus = brcmnand_waitfunc(chip);\n\n\t\tif (status & NAND_STATUS_FAIL) {\n\t\t\tdev_info(ctrl->dev, \"program failed at %llx\\n\",\n\t\t\t\t(unsigned long long)addr);\n\t\t\tret = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t}\nout:\n\tbrcmnand_wp(mtd, 1);\n\treturn ret;\n}\n\nstatic int brcmnand_write_page(struct nand_chip *chip, const uint8_t *buf,\n\t\t\t       int oob_required, int page)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tstruct brcmnand_host *host = nand_get_controller_data(chip);\n\tvoid *oob = oob_required ? chip->oob_poi : NULL;\n\n\tnand_prog_page_begin_op(chip, page, 0, NULL, 0);\n\tbrcmnand_write(mtd, chip, host->last_addr, (const u32 *)buf, oob);\n\n\treturn nand_prog_page_end_op(chip);\n}\n\nstatic int brcmnand_write_page_raw(struct nand_chip *chip, const uint8_t *buf,\n\t\t\t\t   int oob_required, int page)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tstruct brcmnand_host *host = nand_get_controller_data(chip);\n\tvoid *oob = oob_required ? chip->oob_poi : NULL;\n\n\tnand_prog_page_begin_op(chip, page, 0, NULL, 0);\n\tbrcmnand_set_ecc_enabled(host, 0);\n\tbrcmnand_write(mtd, chip, host->last_addr, (const u32 *)buf, oob);\n\tbrcmnand_set_ecc_enabled(host, 1);\n\n\treturn nand_prog_page_end_op(chip);\n}\n\nstatic int brcmnand_write_oob(struct nand_chip *chip, int page)\n{\n\treturn brcmnand_write(nand_to_mtd(chip), chip,\n\t\t\t      (u64)page << chip->page_shift, NULL,\n\t\t\t      chip->oob_poi);\n}\n\nstatic int brcmnand_write_oob_raw(struct nand_chip *chip, int page)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tstruct brcmnand_host *host = nand_get_controller_data(chip);\n\tint ret;\n\n\tbrcmnand_set_ecc_enabled(host, 0);\n\tret = brcmnand_write(mtd, chip, (u64)page << chip->page_shift, NULL,\n\t\t\t\t (u8 *)chip->oob_poi);\n\tbrcmnand_set_ecc_enabled(host, 1);\n\n\treturn ret;\n}\n\n \n\nstatic int brcmnand_set_cfg(struct brcmnand_host *host,\n\t\t\t    struct brcmnand_cfg *cfg)\n{\n\tstruct brcmnand_controller *ctrl = host->ctrl;\n\tstruct nand_chip *chip = &host->chip;\n\tu16 cfg_offs = brcmnand_cs_offset(ctrl, host->cs, BRCMNAND_CS_CFG);\n\tu16 cfg_ext_offs = brcmnand_cs_offset(ctrl, host->cs,\n\t\t\tBRCMNAND_CS_CFG_EXT);\n\tu16 acc_control_offs = brcmnand_cs_offset(ctrl, host->cs,\n\t\t\tBRCMNAND_CS_ACC_CONTROL);\n\tu8 block_size = 0, page_size = 0, device_size = 0;\n\tu32 tmp;\n\n\tif (ctrl->block_sizes) {\n\t\tint i, found;\n\n\t\tfor (i = 0, found = 0; ctrl->block_sizes[i]; i++)\n\t\t\tif (ctrl->block_sizes[i] * 1024 == cfg->block_size) {\n\t\t\t\tblock_size = i;\n\t\t\t\tfound = 1;\n\t\t\t}\n\t\tif (!found) {\n\t\t\tdev_warn(ctrl->dev, \"invalid block size %u\\n\",\n\t\t\t\t\tcfg->block_size);\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else {\n\t\tblock_size = ffs(cfg->block_size) - ffs(BRCMNAND_MIN_BLOCKSIZE);\n\t}\n\n\tif (cfg->block_size < BRCMNAND_MIN_BLOCKSIZE || (ctrl->max_block_size &&\n\t\t\t\tcfg->block_size > ctrl->max_block_size)) {\n\t\tdev_warn(ctrl->dev, \"invalid block size %u\\n\",\n\t\t\t\tcfg->block_size);\n\t\tblock_size = 0;\n\t}\n\n\tif (ctrl->page_sizes) {\n\t\tint i, found;\n\n\t\tfor (i = 0, found = 0; ctrl->page_sizes[i]; i++)\n\t\t\tif (ctrl->page_sizes[i] == cfg->page_size) {\n\t\t\t\tpage_size = i;\n\t\t\t\tfound = 1;\n\t\t\t}\n\t\tif (!found) {\n\t\t\tdev_warn(ctrl->dev, \"invalid page size %u\\n\",\n\t\t\t\t\tcfg->page_size);\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else {\n\t\tpage_size = ffs(cfg->page_size) - ffs(BRCMNAND_MIN_PAGESIZE);\n\t}\n\n\tif (cfg->page_size < BRCMNAND_MIN_PAGESIZE || (ctrl->max_page_size &&\n\t\t\t\tcfg->page_size > ctrl->max_page_size)) {\n\t\tdev_warn(ctrl->dev, \"invalid page size %u\\n\", cfg->page_size);\n\t\treturn -EINVAL;\n\t}\n\n\tif (fls64(cfg->device_size) < fls64(BRCMNAND_MIN_DEVSIZE)) {\n\t\tdev_warn(ctrl->dev, \"invalid device size 0x%llx\\n\",\n\t\t\t(unsigned long long)cfg->device_size);\n\t\treturn -EINVAL;\n\t}\n\tdevice_size = fls64(cfg->device_size) - fls64(BRCMNAND_MIN_DEVSIZE);\n\n\ttmp = (cfg->blk_adr_bytes << CFG_BLK_ADR_BYTES_SHIFT) |\n\t\t(cfg->col_adr_bytes << CFG_COL_ADR_BYTES_SHIFT) |\n\t\t(cfg->ful_adr_bytes << CFG_FUL_ADR_BYTES_SHIFT) |\n\t\t(!!(cfg->device_width == 16) << CFG_BUS_WIDTH_SHIFT) |\n\t\t(device_size << CFG_DEVICE_SIZE_SHIFT);\n\tif (cfg_offs == cfg_ext_offs) {\n\t\ttmp |= (page_size << ctrl->page_size_shift) |\n\t\t       (block_size << CFG_BLK_SIZE_SHIFT);\n\t\tnand_writereg(ctrl, cfg_offs, tmp);\n\t} else {\n\t\tnand_writereg(ctrl, cfg_offs, tmp);\n\t\ttmp = (page_size << CFG_EXT_PAGE_SIZE_SHIFT) |\n\t\t      (block_size << CFG_EXT_BLK_SIZE_SHIFT);\n\t\tnand_writereg(ctrl, cfg_ext_offs, tmp);\n\t}\n\n\ttmp = nand_readreg(ctrl, acc_control_offs);\n\ttmp &= ~brcmnand_ecc_level_mask(ctrl);\n\ttmp &= ~brcmnand_spare_area_mask(ctrl);\n\tif (ctrl->nand_version >= 0x0302) {\n\t\ttmp |= cfg->ecc_level << ctrl->ecc_level_shift;\n\t\ttmp |= cfg->spare_area_size;\n\t}\n\tnand_writereg(ctrl, acc_control_offs, tmp);\n\n\tbrcmnand_set_sector_size_1k(host, cfg->sector_size_1k);\n\n\t \n\tbrcmnand_wr_corr_thresh(host, DIV_ROUND_UP(chip->ecc.strength * 3, 4));\n\n\treturn 0;\n}\n\nstatic void brcmnand_print_cfg(struct brcmnand_host *host,\n\t\t\t       char *buf, struct brcmnand_cfg *cfg)\n{\n\tbuf += sprintf(buf,\n\t\t\"%lluMiB total, %uKiB blocks, %u%s pages, %uB OOB, %u-bit\",\n\t\t(unsigned long long)cfg->device_size >> 20,\n\t\tcfg->block_size >> 10,\n\t\tcfg->page_size >= 1024 ? cfg->page_size >> 10 : cfg->page_size,\n\t\tcfg->page_size >= 1024 ? \"KiB\" : \"B\",\n\t\tcfg->spare_area_size, cfg->device_width);\n\n\t \n\tif (is_hamming_ecc(host->ctrl, cfg))\n\t\tsprintf(buf, \", Hamming ECC\");\n\telse if (cfg->sector_size_1k)\n\t\tsprintf(buf, \", BCH-%u (1KiB sector)\", cfg->ecc_level << 1);\n\telse\n\t\tsprintf(buf, \", BCH-%u\", cfg->ecc_level);\n}\n\n \nstatic inline int get_blk_adr_bytes(u64 size, u32 writesize)\n{\n\treturn ALIGN(ilog2(size) - ilog2(writesize), 8) >> 3;\n}\n\nstatic int brcmnand_setup_dev(struct brcmnand_host *host)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(&host->chip);\n\tstruct nand_chip *chip = &host->chip;\n\tconst struct nand_ecc_props *requirements =\n\t\tnanddev_get_ecc_requirements(&chip->base);\n\tstruct nand_memory_organization *memorg =\n\t\tnanddev_get_memorg(&chip->base);\n\tstruct brcmnand_controller *ctrl = host->ctrl;\n\tstruct brcmnand_cfg *cfg = &host->hwcfg;\n\tchar msg[128];\n\tu32 offs, tmp, oob_sector;\n\tint ret;\n\n\tmemset(cfg, 0, sizeof(*cfg));\n\n\tret = of_property_read_u32(nand_get_flash_node(chip),\n\t\t\t\t   \"brcm,nand-oob-sector-size\",\n\t\t\t\t   &oob_sector);\n\tif (ret) {\n\t\t \n\t\tcfg->spare_area_size = mtd->oobsize /\n\t\t\t\t\t(mtd->writesize >> FC_SHIFT);\n\t} else {\n\t\tcfg->spare_area_size = oob_sector;\n\t}\n\tif (cfg->spare_area_size > ctrl->max_oob)\n\t\tcfg->spare_area_size = ctrl->max_oob;\n\t \n\tmtd->oobsize = cfg->spare_area_size * (mtd->writesize >> FC_SHIFT);\n\tmemorg->oobsize = mtd->oobsize;\n\n\tcfg->device_size = mtd->size;\n\tcfg->block_size = mtd->erasesize;\n\tcfg->page_size = mtd->writesize;\n\tcfg->device_width = (chip->options & NAND_BUSWIDTH_16) ? 16 : 8;\n\tcfg->col_adr_bytes = 2;\n\tcfg->blk_adr_bytes = get_blk_adr_bytes(mtd->size, mtd->writesize);\n\n\tif (chip->ecc.engine_type != NAND_ECC_ENGINE_TYPE_ON_HOST) {\n\t\tdev_err(ctrl->dev, \"only HW ECC supported; selected: %d\\n\",\n\t\t\tchip->ecc.engine_type);\n\t\treturn -EINVAL;\n\t}\n\n\tif (chip->ecc.algo == NAND_ECC_ALGO_UNKNOWN) {\n\t\tif (chip->ecc.strength == 1 && chip->ecc.size == 512)\n\t\t\t \n\t\t\tchip->ecc.algo = NAND_ECC_ALGO_HAMMING;\n\t\telse\n\t\t\t \n\t\t\tchip->ecc.algo = NAND_ECC_ALGO_BCH;\n\t}\n\n\tif (chip->ecc.algo == NAND_ECC_ALGO_HAMMING &&\n\t    (chip->ecc.strength != 1 || chip->ecc.size != 512)) {\n\t\tdev_err(ctrl->dev, \"invalid Hamming params: %d bits per %d bytes\\n\",\n\t\t\tchip->ecc.strength, chip->ecc.size);\n\t\treturn -EINVAL;\n\t}\n\n\tif (chip->ecc.engine_type != NAND_ECC_ENGINE_TYPE_NONE &&\n\t    (!chip->ecc.size || !chip->ecc.strength)) {\n\t\tif (requirements->step_size && requirements->strength) {\n\t\t\t \n\t\t\tchip->ecc.size = requirements->step_size;\n\t\t\tchip->ecc.strength = requirements->strength;\n\t\t\tdev_info(ctrl->dev, \"Using ECC step-size %d, strength %d\\n\",\n\t\t\t\tchip->ecc.size, chip->ecc.strength);\n\t\t}\n\t}\n\n\tswitch (chip->ecc.size) {\n\tcase 512:\n\t\tif (chip->ecc.algo == NAND_ECC_ALGO_HAMMING)\n\t\t\tcfg->ecc_level = 15;\n\t\telse\n\t\t\tcfg->ecc_level = chip->ecc.strength;\n\t\tcfg->sector_size_1k = 0;\n\t\tbreak;\n\tcase 1024:\n\t\tif (!(ctrl->features & BRCMNAND_HAS_1K_SECTORS)) {\n\t\t\tdev_err(ctrl->dev, \"1KB sectors not supported\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (chip->ecc.strength & 0x1) {\n\t\t\tdev_err(ctrl->dev,\n\t\t\t\t\"odd ECC not supported with 1KB sectors\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tcfg->ecc_level = chip->ecc.strength >> 1;\n\t\tcfg->sector_size_1k = 1;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(ctrl->dev, \"unsupported ECC size: %d\\n\",\n\t\t\tchip->ecc.size);\n\t\treturn -EINVAL;\n\t}\n\n\tcfg->ful_adr_bytes = cfg->blk_adr_bytes;\n\tif (mtd->writesize > 512)\n\t\tcfg->ful_adr_bytes += cfg->col_adr_bytes;\n\telse\n\t\tcfg->ful_adr_bytes += 1;\n\n\tret = brcmnand_set_cfg(host, cfg);\n\tif (ret)\n\t\treturn ret;\n\n\tbrcmnand_set_ecc_enabled(host, 1);\n\n\tbrcmnand_print_cfg(host, msg, cfg);\n\tdev_info(ctrl->dev, \"detected %s\\n\", msg);\n\n\t \n\toffs = brcmnand_cs_offset(ctrl, host->cs, BRCMNAND_CS_ACC_CONTROL);\n\ttmp = nand_readreg(ctrl, offs);\n\ttmp &= ~ACC_CONTROL_PARTIAL_PAGE;\n\ttmp &= ~ACC_CONTROL_RD_ERASED;\n\n\t \n\tif (ctrl->nand_version >= 0x0702)\n\t\ttmp |= ACC_CONTROL_RD_ERASED;\n\ttmp &= ~ACC_CONTROL_FAST_PGM_RDIN;\n\tif (ctrl->features & BRCMNAND_HAS_PREFETCH)\n\t\ttmp &= ~ACC_CONTROL_PREFETCH;\n\n\tnand_writereg(ctrl, offs, tmp);\n\n\treturn 0;\n}\n\nstatic int brcmnand_attach_chip(struct nand_chip *chip)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tstruct brcmnand_host *host = nand_get_controller_data(chip);\n\tint ret;\n\n\tchip->options |= NAND_NO_SUBPAGE_WRITE;\n\t \n\tchip->options |= NAND_USES_DMA;\n\n\tif (chip->bbt_options & NAND_BBT_USE_FLASH)\n\t\tchip->bbt_options |= NAND_BBT_NO_OOB;\n\n\tif (brcmnand_setup_dev(host))\n\t\treturn -ENXIO;\n\n\tchip->ecc.size = host->hwcfg.sector_size_1k ? 1024 : 512;\n\n\t \n\tmtd->bitflip_threshold = 1;\n\n\tret = brcmstb_choose_ecc_layout(host);\n\n\t \n\tif (is_hamming_ecc(host->ctrl, &host->hwcfg)) {\n\t\tchip->ecc.write_oob = brcmnand_write_oob_raw;\n\t\tchip->ecc.read_oob = brcmnand_read_oob_raw;\n\t}\n\n\treturn ret;\n}\n\nstatic const struct nand_controller_ops brcmnand_controller_ops = {\n\t.attach_chip = brcmnand_attach_chip,\n};\n\nstatic int brcmnand_init_cs(struct brcmnand_host *host,\n\t\t\t    const char * const *part_probe_types)\n{\n\tstruct brcmnand_controller *ctrl = host->ctrl;\n\tstruct device *dev = ctrl->dev;\n\tstruct mtd_info *mtd;\n\tstruct nand_chip *chip;\n\tint ret;\n\tu16 cfg_offs;\n\n\tmtd = nand_to_mtd(&host->chip);\n\tchip = &host->chip;\n\n\tnand_set_controller_data(chip, host);\n\tmtd->name = devm_kasprintf(dev, GFP_KERNEL, \"brcmnand.%d\",\n\t\t\t\t   host->cs);\n\tif (!mtd->name)\n\t\treturn -ENOMEM;\n\n\tmtd->owner = THIS_MODULE;\n\tmtd->dev.parent = dev;\n\n\tchip->legacy.cmd_ctrl = brcmnand_cmd_ctrl;\n\tchip->legacy.cmdfunc = brcmnand_cmdfunc;\n\tchip->legacy.waitfunc = brcmnand_waitfunc;\n\tchip->legacy.read_byte = brcmnand_read_byte;\n\tchip->legacy.read_buf = brcmnand_read_buf;\n\tchip->legacy.write_buf = brcmnand_write_buf;\n\n\tchip->ecc.engine_type = NAND_ECC_ENGINE_TYPE_ON_HOST;\n\tchip->ecc.read_page = brcmnand_read_page;\n\tchip->ecc.write_page = brcmnand_write_page;\n\tchip->ecc.read_page_raw = brcmnand_read_page_raw;\n\tchip->ecc.write_page_raw = brcmnand_write_page_raw;\n\tchip->ecc.write_oob_raw = brcmnand_write_oob_raw;\n\tchip->ecc.read_oob_raw = brcmnand_read_oob_raw;\n\tchip->ecc.read_oob = brcmnand_read_oob;\n\tchip->ecc.write_oob = brcmnand_write_oob;\n\n\tchip->controller = &ctrl->controller;\n\n\t \n\tcfg_offs = brcmnand_cs_offset(ctrl, host->cs, BRCMNAND_CS_CFG);\n\tnand_writereg(ctrl, cfg_offs,\n\t\t      nand_readreg(ctrl, cfg_offs) & ~CFG_BUS_WIDTH);\n\n\tret = nand_scan(chip, 1);\n\tif (ret)\n\t\treturn ret;\n\n\tret = mtd_device_parse_register(mtd, part_probe_types, NULL, NULL, 0);\n\tif (ret)\n\t\tnand_cleanup(chip);\n\n\treturn ret;\n}\n\nstatic void brcmnand_save_restore_cs_config(struct brcmnand_host *host,\n\t\t\t\t\t    int restore)\n{\n\tstruct brcmnand_controller *ctrl = host->ctrl;\n\tu16 cfg_offs = brcmnand_cs_offset(ctrl, host->cs, BRCMNAND_CS_CFG);\n\tu16 cfg_ext_offs = brcmnand_cs_offset(ctrl, host->cs,\n\t\t\tBRCMNAND_CS_CFG_EXT);\n\tu16 acc_control_offs = brcmnand_cs_offset(ctrl, host->cs,\n\t\t\tBRCMNAND_CS_ACC_CONTROL);\n\tu16 t1_offs = brcmnand_cs_offset(ctrl, host->cs, BRCMNAND_CS_TIMING1);\n\tu16 t2_offs = brcmnand_cs_offset(ctrl, host->cs, BRCMNAND_CS_TIMING2);\n\n\tif (restore) {\n\t\tnand_writereg(ctrl, cfg_offs, host->hwcfg.config);\n\t\tif (cfg_offs != cfg_ext_offs)\n\t\t\tnand_writereg(ctrl, cfg_ext_offs,\n\t\t\t\t      host->hwcfg.config_ext);\n\t\tnand_writereg(ctrl, acc_control_offs, host->hwcfg.acc_control);\n\t\tnand_writereg(ctrl, t1_offs, host->hwcfg.timing_1);\n\t\tnand_writereg(ctrl, t2_offs, host->hwcfg.timing_2);\n\t} else {\n\t\thost->hwcfg.config = nand_readreg(ctrl, cfg_offs);\n\t\tif (cfg_offs != cfg_ext_offs)\n\t\t\thost->hwcfg.config_ext =\n\t\t\t\tnand_readreg(ctrl, cfg_ext_offs);\n\t\thost->hwcfg.acc_control = nand_readreg(ctrl, acc_control_offs);\n\t\thost->hwcfg.timing_1 = nand_readreg(ctrl, t1_offs);\n\t\thost->hwcfg.timing_2 = nand_readreg(ctrl, t2_offs);\n\t}\n}\n\nstatic int brcmnand_suspend(struct device *dev)\n{\n\tstruct brcmnand_controller *ctrl = dev_get_drvdata(dev);\n\tstruct brcmnand_host *host;\n\n\tlist_for_each_entry(host, &ctrl->host_list, node)\n\t\tbrcmnand_save_restore_cs_config(host, 0);\n\n\tctrl->nand_cs_nand_select = brcmnand_read_reg(ctrl, BRCMNAND_CS_SELECT);\n\tctrl->nand_cs_nand_xor = brcmnand_read_reg(ctrl, BRCMNAND_CS_XOR);\n\tctrl->corr_stat_threshold =\n\t\tbrcmnand_read_reg(ctrl, BRCMNAND_CORR_THRESHOLD);\n\n\tif (has_flash_dma(ctrl))\n\t\tctrl->flash_dma_mode = flash_dma_readl(ctrl, FLASH_DMA_MODE);\n\telse if (has_edu(ctrl))\n\t\tctrl->edu_config = edu_readl(ctrl, EDU_CONFIG);\n\n\treturn 0;\n}\n\nstatic int brcmnand_resume(struct device *dev)\n{\n\tstruct brcmnand_controller *ctrl = dev_get_drvdata(dev);\n\tstruct brcmnand_host *host;\n\n\tif (has_flash_dma(ctrl)) {\n\t\tflash_dma_writel(ctrl, FLASH_DMA_MODE, ctrl->flash_dma_mode);\n\t\tflash_dma_writel(ctrl, FLASH_DMA_ERROR_STATUS, 0);\n\t}\n\n\tif (has_edu(ctrl)) {\n\t\tctrl->edu_config = edu_readl(ctrl, EDU_CONFIG);\n\t\tedu_writel(ctrl, EDU_CONFIG, ctrl->edu_config);\n\t\tedu_readl(ctrl, EDU_CONFIG);\n\t\tbrcmnand_edu_init(ctrl);\n\t}\n\n\tbrcmnand_write_reg(ctrl, BRCMNAND_CS_SELECT, ctrl->nand_cs_nand_select);\n\tbrcmnand_write_reg(ctrl, BRCMNAND_CS_XOR, ctrl->nand_cs_nand_xor);\n\tbrcmnand_write_reg(ctrl, BRCMNAND_CORR_THRESHOLD,\n\t\t\tctrl->corr_stat_threshold);\n\tif (ctrl->soc) {\n\t\t \n\t\tctrl->soc->ctlrdy_ack(ctrl->soc);\n\t\tctrl->soc->ctlrdy_set_enabled(ctrl->soc, true);\n\t}\n\n\tlist_for_each_entry(host, &ctrl->host_list, node) {\n\t\tstruct nand_chip *chip = &host->chip;\n\n\t\tbrcmnand_save_restore_cs_config(host, 1);\n\n\t\t \n\t\tnand_reset_op(chip);\n\t}\n\n\treturn 0;\n}\n\nconst struct dev_pm_ops brcmnand_pm_ops = {\n\t.suspend\t\t= brcmnand_suspend,\n\t.resume\t\t\t= brcmnand_resume,\n};\nEXPORT_SYMBOL_GPL(brcmnand_pm_ops);\n\nstatic const struct of_device_id __maybe_unused brcmnand_of_match[] = {\n\t{ .compatible = \"brcm,brcmnand-v2.1\" },\n\t{ .compatible = \"brcm,brcmnand-v2.2\" },\n\t{ .compatible = \"brcm,brcmnand-v4.0\" },\n\t{ .compatible = \"brcm,brcmnand-v5.0\" },\n\t{ .compatible = \"brcm,brcmnand-v6.0\" },\n\t{ .compatible = \"brcm,brcmnand-v6.1\" },\n\t{ .compatible = \"brcm,brcmnand-v6.2\" },\n\t{ .compatible = \"brcm,brcmnand-v7.0\" },\n\t{ .compatible = \"brcm,brcmnand-v7.1\" },\n\t{ .compatible = \"brcm,brcmnand-v7.2\" },\n\t{ .compatible = \"brcm,brcmnand-v7.3\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, brcmnand_of_match);\n\n \nstatic int brcmnand_edu_setup(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct brcmnand_controller *ctrl = dev_get_drvdata(&pdev->dev);\n\tstruct resource *res;\n\tint ret;\n\n\tres = platform_get_resource_byname(pdev, IORESOURCE_MEM, \"flash-edu\");\n\tif (res) {\n\t\tctrl->edu_base = devm_ioremap_resource(dev, res);\n\t\tif (IS_ERR(ctrl->edu_base))\n\t\t\treturn PTR_ERR(ctrl->edu_base);\n\n\t\tctrl->edu_offsets = edu_regs;\n\n\t\tedu_writel(ctrl, EDU_CONFIG, EDU_CONFIG_MODE_NAND |\n\t\t\t   EDU_CONFIG_SWAP_CFG);\n\t\tedu_readl(ctrl, EDU_CONFIG);\n\n\t\t \n\t\tbrcmnand_edu_init(ctrl);\n\n\t\tctrl->edu_irq = platform_get_irq_optional(pdev, 1);\n\t\tif (ctrl->edu_irq < 0) {\n\t\t\tdev_warn(dev,\n\t\t\t\t \"FLASH EDU enabled, using ctlrdy irq\\n\");\n\t\t} else {\n\t\t\tret = devm_request_irq(dev, ctrl->edu_irq,\n\t\t\t\t\t       brcmnand_edu_irq, 0,\n\t\t\t\t\t       \"brcmnand-edu\", ctrl);\n\t\t\tif (ret < 0) {\n\t\t\t\tdev_err(ctrl->dev, \"can't allocate IRQ %d: error %d\\n\",\n\t\t\t\t\tctrl->edu_irq, ret);\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\tdev_info(dev, \"FLASH EDU enabled using irq %u\\n\",\n\t\t\t\t ctrl->edu_irq);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint brcmnand_probe(struct platform_device *pdev, struct brcmnand_soc *soc)\n{\n\tstruct brcmnand_platform_data *pd = dev_get_platdata(&pdev->dev);\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *dn = dev->of_node, *child;\n\tstruct brcmnand_controller *ctrl;\n\tstruct brcmnand_host *host;\n\tstruct resource *res;\n\tint ret;\n\n\tif (dn && !of_match_node(brcmnand_of_match, dn))\n\t\treturn -ENODEV;\n\n\tctrl = devm_kzalloc(dev, sizeof(*ctrl), GFP_KERNEL);\n\tif (!ctrl)\n\t\treturn -ENOMEM;\n\n\tdev_set_drvdata(dev, ctrl);\n\tctrl->dev = dev;\n\tctrl->soc = soc;\n\n\t \n\tif (brcmnand_soc_has_ops(ctrl->soc))\n\t\tstatic_branch_enable(&brcmnand_soc_has_ops_key);\n\n\tinit_completion(&ctrl->done);\n\tinit_completion(&ctrl->dma_done);\n\tinit_completion(&ctrl->edu_done);\n\tnand_controller_init(&ctrl->controller);\n\tctrl->controller.ops = &brcmnand_controller_ops;\n\tINIT_LIST_HEAD(&ctrl->host_list);\n\n\t \n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tctrl->nand_base = devm_ioremap_resource(dev, res);\n\tif (IS_ERR(ctrl->nand_base) && !brcmnand_soc_has_ops(soc))\n\t\treturn PTR_ERR(ctrl->nand_base);\n\n\t \n\tctrl->clk = devm_clk_get(dev, \"nand\");\n\tif (!IS_ERR(ctrl->clk)) {\n\t\tret = clk_prepare_enable(ctrl->clk);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else {\n\t\tret = PTR_ERR(ctrl->clk);\n\t\tif (ret == -EPROBE_DEFER)\n\t\t\treturn ret;\n\n\t\tctrl->clk = NULL;\n\t}\n\n\t \n\tret = brcmnand_revision_init(ctrl);\n\tif (ret)\n\t\tgoto err;\n\n\t \n\tres = platform_get_resource_byname(pdev, IORESOURCE_MEM, \"nand-cache\");\n\tif (res) {\n\t\tctrl->nand_fc = devm_ioremap_resource(dev, res);\n\t\tif (IS_ERR(ctrl->nand_fc)) {\n\t\t\tret = PTR_ERR(ctrl->nand_fc);\n\t\t\tgoto err;\n\t\t}\n\t} else {\n\t\tctrl->nand_fc = ctrl->nand_base +\n\t\t\t\tctrl->reg_offsets[BRCMNAND_FC_BASE];\n\t}\n\n\t \n\tres = platform_get_resource_byname(pdev, IORESOURCE_MEM, \"flash-dma\");\n\tif (res) {\n\t\tctrl->flash_dma_base = devm_ioremap_resource(dev, res);\n\t\tif (IS_ERR(ctrl->flash_dma_base)) {\n\t\t\tret = PTR_ERR(ctrl->flash_dma_base);\n\t\t\tgoto err;\n\t\t}\n\n\t\t \n\t\tbrcmnand_flash_dma_revision_init(ctrl);\n\n\t\tret = -EIO;\n\t\tif (ctrl->nand_version >= 0x0700)\n\t\t\tret = dma_set_mask_and_coherent(&pdev->dev,\n\t\t\t\t\t\t\tDMA_BIT_MASK(40));\n\t\tif (ret)\n\t\t\tret = dma_set_mask_and_coherent(&pdev->dev,\n\t\t\t\t\t\t\tDMA_BIT_MASK(32));\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\t \n\t\tflash_dma_writel(ctrl, FLASH_DMA_MODE, FLASH_DMA_MODE_MASK);\n\t\tflash_dma_writel(ctrl, FLASH_DMA_ERROR_STATUS, 0);\n\n\t\t \n\t\tctrl->dma_desc = dmam_alloc_coherent(dev,\n\t\t\t\t\t\t     sizeof(*ctrl->dma_desc),\n\t\t\t\t\t\t     &ctrl->dma_pa, GFP_KERNEL);\n\t\tif (!ctrl->dma_desc) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err;\n\t\t}\n\n\t\tctrl->dma_irq = platform_get_irq(pdev, 1);\n\t\tif ((int)ctrl->dma_irq < 0) {\n\t\t\tdev_err(dev, \"missing FLASH_DMA IRQ\\n\");\n\t\t\tret = -ENODEV;\n\t\t\tgoto err;\n\t\t}\n\n\t\tret = devm_request_irq(dev, ctrl->dma_irq,\n\t\t\t\tbrcmnand_dma_irq, 0, DRV_NAME,\n\t\t\t\tctrl);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev, \"can't allocate IRQ %d: error %d\\n\",\n\t\t\t\t\tctrl->dma_irq, ret);\n\t\t\tgoto err;\n\t\t}\n\n\t\tdev_info(dev, \"enabling FLASH_DMA\\n\");\n\t\t \n\t\tctrl->dma_trans = brcmnand_dma_trans;\n\t} else\t{\n\t\tret = brcmnand_edu_setup(pdev);\n\t\tif (ret < 0)\n\t\t\tgoto err;\n\n\t\tif (has_edu(ctrl))\n\t\t\t \n\t\t\tctrl->dma_trans = brcmnand_edu_trans;\n\t}\n\n\t \n\tbrcmnand_rmw_reg(ctrl, BRCMNAND_CS_SELECT,\n\t\t\t CS_SELECT_AUTO_DEVICE_ID_CFG | 0xff, 0, 0);\n\t \n\tbrcmnand_rmw_reg(ctrl, BRCMNAND_CS_XOR, 0xff, 0, 0);\n\n\tif (ctrl->features & BRCMNAND_HAS_WP) {\n\t\t \n\t\tif (wp_on == 2)\n\t\t\tbrcmnand_set_wp(ctrl, false);\n\t} else {\n\t\twp_on = 0;\n\t}\n\n\t \n\tctrl->irq = platform_get_irq_optional(pdev, 0);\n\tif (ctrl->irq > 0) {\n\t\t \n\t\tif (soc) {\n\t\t\tret = devm_request_irq(dev, ctrl->irq, brcmnand_irq, 0,\n\t\t\t\t\t       DRV_NAME, ctrl);\n\n\t\t\t \n\t\t\tctrl->soc->ctlrdy_ack(ctrl->soc);\n\t\t\tctrl->soc->ctlrdy_set_enabled(ctrl->soc, true);\n\t\t} else {\n\t\t\t \n\t\t\tret = devm_request_irq(dev, ctrl->irq, brcmnand_ctlrdy_irq, 0,\n\t\t\t\t\t       DRV_NAME, ctrl);\n\t\t}\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev, \"can't allocate IRQ %d: error %d\\n\",\n\t\t\t\tctrl->irq, ret);\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\tfor_each_available_child_of_node(dn, child) {\n\t\tif (of_device_is_compatible(child, \"brcm,nandcs\")) {\n\n\t\t\thost = devm_kzalloc(dev, sizeof(*host), GFP_KERNEL);\n\t\t\tif (!host) {\n\t\t\t\tof_node_put(child);\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\thost->pdev = pdev;\n\t\t\thost->ctrl = ctrl;\n\n\t\t\tret = of_property_read_u32(child, \"reg\", &host->cs);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(dev, \"can't get chip-select\\n\");\n\t\t\t\tdevm_kfree(dev, host);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tnand_set_flash_node(&host->chip, child);\n\n\t\t\tret = brcmnand_init_cs(host, NULL);\n\t\t\tif (ret) {\n\t\t\t\tif (ret == -EPROBE_DEFER) {\n\t\t\t\t\tof_node_put(child);\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t\tdevm_kfree(dev, host);\n\t\t\t\tcontinue;  \n\t\t\t}\n\n\t\t\tlist_add_tail(&host->node, &ctrl->host_list);\n\t\t}\n\t}\n\n\tif (!list_empty(&ctrl->host_list))\n\t\treturn 0;\n\n\tif (!pd) {\n\t\tret = -ENODEV;\n\t\tgoto err;\n\t}\n\n\t \n\thost = devm_kzalloc(dev, sizeof(*host), GFP_KERNEL);\n\tif (!host) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\thost->pdev = pdev;\n\thost->ctrl = ctrl;\n\thost->cs = pd->chip_select;\n\thost->chip.ecc.size = pd->ecc_stepsize;\n\thost->chip.ecc.strength = pd->ecc_strength;\n\n\tret = brcmnand_init_cs(host, pd->part_probe_types);\n\tif (ret)\n\t\tgoto err;\n\n\tlist_add_tail(&host->node, &ctrl->host_list);\n\n\t \n\tif (list_empty(&ctrl->host_list)) {\n\t\tret = -ENODEV;\n\t\tgoto err;\n\t}\n\n\treturn 0;\n\nerr:\n\tclk_disable_unprepare(ctrl->clk);\n\treturn ret;\n\n}\nEXPORT_SYMBOL_GPL(brcmnand_probe);\n\nint brcmnand_remove(struct platform_device *pdev)\n{\n\tstruct brcmnand_controller *ctrl = dev_get_drvdata(&pdev->dev);\n\tstruct brcmnand_host *host;\n\tstruct nand_chip *chip;\n\tint ret;\n\n\tlist_for_each_entry(host, &ctrl->host_list, node) {\n\t\tchip = &host->chip;\n\t\tret = mtd_device_unregister(nand_to_mtd(chip));\n\t\tWARN_ON(ret);\n\t\tnand_cleanup(chip);\n\t}\n\n\tclk_disable_unprepare(ctrl->clk);\n\n\tdev_set_drvdata(&pdev->dev, NULL);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(brcmnand_remove);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Kevin Cernekee\");\nMODULE_AUTHOR(\"Brian Norris\");\nMODULE_DESCRIPTION(\"NAND driver for Broadcom chips\");\nMODULE_ALIAS(\"platform:brcmnand\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}