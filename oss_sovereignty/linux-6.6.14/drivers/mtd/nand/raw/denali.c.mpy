{
  "module_name": "denali.c",
  "hash_id": "67769cacca87728f3a84c5d680886e01662ba460ceeff27feac8d4c52c1bd373",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/nand/raw/denali.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/completion.h>\n#include <linux/dma-mapping.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/mtd/mtd.h>\n#include <linux/mtd/rawnand.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n\n#include \"denali.h\"\n\n#define DENALI_NAND_NAME    \"denali-nand\"\n\n \n#define DENALI_INDEXED_CTRL\t0x00\n#define DENALI_INDEXED_DATA\t0x10\n\n#define DENALI_MAP00\t\t(0 << 26)\t \n#define DENALI_MAP01\t\t(1 << 26)\t \n#define DENALI_MAP10\t\t(2 << 26)\t \n#define DENALI_MAP11\t\t(3 << 26)\t \n\n \n#define DENALI_MAP11_CMD\t((DENALI_MAP11) | 0)\t \n#define DENALI_MAP11_ADDR\t((DENALI_MAP11) | 1)\t \n#define DENALI_MAP11_DATA\t((DENALI_MAP11) | 2)\t \n\n#define DENALI_BANK(denali)\t((denali)->active_bank << 24)\n\n#define DENALI_INVALID_BANK\t-1\n\nstatic struct denali_chip *to_denali_chip(struct nand_chip *chip)\n{\n\treturn container_of(chip, struct denali_chip, chip);\n}\n\nstatic struct denali_controller *to_denali_controller(struct nand_chip *chip)\n{\n\treturn container_of(chip->controller, struct denali_controller,\n\t\t\t    controller);\n}\n\n \nstatic u32 denali_direct_read(struct denali_controller *denali, u32 addr)\n{\n\treturn ioread32(denali->host + addr);\n}\n\nstatic void denali_direct_write(struct denali_controller *denali, u32 addr,\n\t\t\t\tu32 data)\n{\n\tiowrite32(data, denali->host + addr);\n}\n\n \nstatic u32 denali_indexed_read(struct denali_controller *denali, u32 addr)\n{\n\tiowrite32(addr, denali->host + DENALI_INDEXED_CTRL);\n\treturn ioread32(denali->host + DENALI_INDEXED_DATA);\n}\n\nstatic void denali_indexed_write(struct denali_controller *denali, u32 addr,\n\t\t\t\t u32 data)\n{\n\tiowrite32(addr, denali->host + DENALI_INDEXED_CTRL);\n\tiowrite32(data, denali->host + DENALI_INDEXED_DATA);\n}\n\nstatic void denali_enable_irq(struct denali_controller *denali)\n{\n\tint i;\n\n\tfor (i = 0; i < denali->nbanks; i++)\n\t\tiowrite32(U32_MAX, denali->reg + INTR_EN(i));\n\tiowrite32(GLOBAL_INT_EN_FLAG, denali->reg + GLOBAL_INT_ENABLE);\n}\n\nstatic void denali_disable_irq(struct denali_controller *denali)\n{\n\tint i;\n\n\tfor (i = 0; i < denali->nbanks; i++)\n\t\tiowrite32(0, denali->reg + INTR_EN(i));\n\tiowrite32(0, denali->reg + GLOBAL_INT_ENABLE);\n}\n\nstatic void denali_clear_irq(struct denali_controller *denali,\n\t\t\t     int bank, u32 irq_status)\n{\n\t \n\tiowrite32(irq_status, denali->reg + INTR_STATUS(bank));\n}\n\nstatic void denali_clear_irq_all(struct denali_controller *denali)\n{\n\tint i;\n\n\tfor (i = 0; i < denali->nbanks; i++)\n\t\tdenali_clear_irq(denali, i, U32_MAX);\n}\n\nstatic irqreturn_t denali_isr(int irq, void *dev_id)\n{\n\tstruct denali_controller *denali = dev_id;\n\tirqreturn_t ret = IRQ_NONE;\n\tu32 irq_status;\n\tint i;\n\n\tspin_lock(&denali->irq_lock);\n\n\tfor (i = 0; i < denali->nbanks; i++) {\n\t\tirq_status = ioread32(denali->reg + INTR_STATUS(i));\n\t\tif (irq_status)\n\t\t\tret = IRQ_HANDLED;\n\n\t\tdenali_clear_irq(denali, i, irq_status);\n\n\t\tif (i != denali->active_bank)\n\t\t\tcontinue;\n\n\t\tdenali->irq_status |= irq_status;\n\n\t\tif (denali->irq_status & denali->irq_mask)\n\t\t\tcomplete(&denali->complete);\n\t}\n\n\tspin_unlock(&denali->irq_lock);\n\n\treturn ret;\n}\n\nstatic void denali_reset_irq(struct denali_controller *denali)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&denali->irq_lock, flags);\n\tdenali->irq_status = 0;\n\tdenali->irq_mask = 0;\n\tspin_unlock_irqrestore(&denali->irq_lock, flags);\n}\n\nstatic u32 denali_wait_for_irq(struct denali_controller *denali, u32 irq_mask)\n{\n\tunsigned long time_left, flags;\n\tu32 irq_status;\n\n\tspin_lock_irqsave(&denali->irq_lock, flags);\n\n\tirq_status = denali->irq_status;\n\n\tif (irq_mask & irq_status) {\n\t\t \n\t\tspin_unlock_irqrestore(&denali->irq_lock, flags);\n\t\treturn irq_status;\n\t}\n\n\tdenali->irq_mask = irq_mask;\n\treinit_completion(&denali->complete);\n\tspin_unlock_irqrestore(&denali->irq_lock, flags);\n\n\ttime_left = wait_for_completion_timeout(&denali->complete,\n\t\t\t\t\t\tmsecs_to_jiffies(1000));\n\tif (!time_left) {\n\t\tdev_err(denali->dev, \"timeout while waiting for irq 0x%x\\n\",\n\t\t\tirq_mask);\n\t\treturn 0;\n\t}\n\n\treturn denali->irq_status;\n}\n\nstatic void denali_select_target(struct nand_chip *chip, int cs)\n{\n\tstruct denali_controller *denali = to_denali_controller(chip);\n\tstruct denali_chip_sel *sel = &to_denali_chip(chip)->sels[cs];\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\n\tdenali->active_bank = sel->bank;\n\n\tiowrite32(1 << (chip->phys_erase_shift - chip->page_shift),\n\t\t  denali->reg + PAGES_PER_BLOCK);\n\tiowrite32(chip->options & NAND_BUSWIDTH_16 ? 1 : 0,\n\t\t  denali->reg + DEVICE_WIDTH);\n\tiowrite32(mtd->writesize, denali->reg + DEVICE_MAIN_AREA_SIZE);\n\tiowrite32(mtd->oobsize, denali->reg + DEVICE_SPARE_AREA_SIZE);\n\tiowrite32(chip->options & NAND_ROW_ADDR_3 ?\n\t\t  0 : TWO_ROW_ADDR_CYCLES__FLAG,\n\t\t  denali->reg + TWO_ROW_ADDR_CYCLES);\n\tiowrite32(FIELD_PREP(ECC_CORRECTION__ERASE_THRESHOLD, 1) |\n\t\t  FIELD_PREP(ECC_CORRECTION__VALUE, chip->ecc.strength),\n\t\t  denali->reg + ECC_CORRECTION);\n\tiowrite32(chip->ecc.size, denali->reg + CFG_DATA_BLOCK_SIZE);\n\tiowrite32(chip->ecc.size, denali->reg + CFG_LAST_DATA_BLOCK_SIZE);\n\tiowrite32(chip->ecc.steps, denali->reg + CFG_NUM_DATA_BLOCKS);\n\n\tif (chip->options & NAND_KEEP_TIMINGS)\n\t\treturn;\n\n\t \n\tiowrite32(sel->hwhr2_and_we_2_re, denali->reg + TWHR2_AND_WE_2_RE);\n\tiowrite32(sel->tcwaw_and_addr_2_data,\n\t\t  denali->reg + TCWAW_AND_ADDR_2_DATA);\n\tiowrite32(sel->re_2_we, denali->reg + RE_2_WE);\n\tiowrite32(sel->acc_clks, denali->reg + ACC_CLKS);\n\tiowrite32(sel->rdwr_en_lo_cnt, denali->reg + RDWR_EN_LO_CNT);\n\tiowrite32(sel->rdwr_en_hi_cnt, denali->reg + RDWR_EN_HI_CNT);\n\tiowrite32(sel->cs_setup_cnt, denali->reg + CS_SETUP_CNT);\n\tiowrite32(sel->re_2_re, denali->reg + RE_2_RE);\n}\n\nstatic int denali_change_column(struct nand_chip *chip, unsigned int offset,\n\t\t\t\tvoid *buf, unsigned int len, bool write)\n{\n\tif (write)\n\t\treturn nand_change_write_column_op(chip, offset, buf, len,\n\t\t\t\t\t\t   false);\n\telse\n\t\treturn nand_change_read_column_op(chip, offset, buf, len,\n\t\t\t\t\t\t  false);\n}\n\nstatic int denali_payload_xfer(struct nand_chip *chip, void *buf, bool write)\n{\n\tstruct denali_controller *denali = to_denali_controller(chip);\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tstruct nand_ecc_ctrl *ecc = &chip->ecc;\n\tint writesize = mtd->writesize;\n\tint oob_skip = denali->oob_skip_bytes;\n\tint ret, i, pos, len;\n\n\tfor (i = 0; i < ecc->steps; i++) {\n\t\tpos = i * (ecc->size + ecc->bytes);\n\t\tlen = ecc->size;\n\n\t\tif (pos >= writesize) {\n\t\t\tpos += oob_skip;\n\t\t} else if (pos + len > writesize) {\n\t\t\t \n\t\t\tret = denali_change_column(chip, pos, buf,\n\t\t\t\t\t\t   writesize - pos, write);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\tbuf += writesize - pos;\n\t\t\tlen -= writesize - pos;\n\t\t\tpos = writesize + oob_skip;\n\t\t}\n\n\t\tret = denali_change_column(chip, pos, buf, len, write);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tbuf += len;\n\t}\n\n\treturn 0;\n}\n\nstatic int denali_oob_xfer(struct nand_chip *chip, void *buf, bool write)\n{\n\tstruct denali_controller *denali = to_denali_controller(chip);\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tstruct nand_ecc_ctrl *ecc = &chip->ecc;\n\tint writesize = mtd->writesize;\n\tint oobsize = mtd->oobsize;\n\tint oob_skip = denali->oob_skip_bytes;\n\tint ret, i, pos, len;\n\n\t \n\tret = denali_change_column(chip, writesize, buf, oob_skip, write);\n\tif (ret)\n\t\treturn ret;\n\n\tbuf += oob_skip;\n\n\tfor (i = 0; i < ecc->steps; i++) {\n\t\tpos = ecc->size + i * (ecc->size + ecc->bytes);\n\n\t\tif (i == ecc->steps - 1)\n\t\t\t \n\t\t\tlen = writesize + oobsize - pos - oob_skip;\n\t\telse\n\t\t\tlen = ecc->bytes;\n\n\t\tif (pos >= writesize) {\n\t\t\tpos += oob_skip;\n\t\t} else if (pos + len > writesize) {\n\t\t\t \n\t\t\tret = denali_change_column(chip, pos, buf,\n\t\t\t\t\t\t   writesize - pos, write);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\tbuf += writesize - pos;\n\t\t\tlen -= writesize - pos;\n\t\t\tpos = writesize + oob_skip;\n\t\t}\n\n\t\tret = denali_change_column(chip, pos, buf, len, write);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tbuf += len;\n\t}\n\n\treturn 0;\n}\n\nstatic int denali_read_raw(struct nand_chip *chip, void *buf, void *oob_buf,\n\t\t\t   int page)\n{\n\tint ret;\n\n\tif (!buf && !oob_buf)\n\t\treturn -EINVAL;\n\n\tret = nand_read_page_op(chip, page, 0, NULL, 0);\n\tif (ret)\n\t\treturn ret;\n\n\tif (buf) {\n\t\tret = denali_payload_xfer(chip, buf, false);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (oob_buf) {\n\t\tret = denali_oob_xfer(chip, oob_buf, false);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int denali_write_raw(struct nand_chip *chip, const void *buf,\n\t\t\t    const void *oob_buf, int page)\n{\n\tint ret;\n\n\tif (!buf && !oob_buf)\n\t\treturn -EINVAL;\n\n\tret = nand_prog_page_begin_op(chip, page, 0, NULL, 0);\n\tif (ret)\n\t\treturn ret;\n\n\tif (buf) {\n\t\tret = denali_payload_xfer(chip, (void *)buf, true);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (oob_buf) {\n\t\tret = denali_oob_xfer(chip, (void *)oob_buf, true);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn nand_prog_page_end_op(chip);\n}\n\nstatic int denali_read_page_raw(struct nand_chip *chip, u8 *buf,\n\t\t\t\tint oob_required, int page)\n{\n\treturn denali_read_raw(chip, buf, oob_required ? chip->oob_poi : NULL,\n\t\t\t       page);\n}\n\nstatic int denali_write_page_raw(struct nand_chip *chip, const u8 *buf,\n\t\t\t\t int oob_required, int page)\n{\n\treturn denali_write_raw(chip, buf, oob_required ? chip->oob_poi : NULL,\n\t\t\t\tpage);\n}\n\nstatic int denali_read_oob(struct nand_chip *chip, int page)\n{\n\treturn denali_read_raw(chip, NULL, chip->oob_poi, page);\n}\n\nstatic int denali_write_oob(struct nand_chip *chip, int page)\n{\n\treturn denali_write_raw(chip, NULL, chip->oob_poi, page);\n}\n\nstatic int denali_check_erased_page(struct nand_chip *chip, u8 *buf,\n\t\t\t\t    unsigned long uncor_ecc_flags,\n\t\t\t\t    unsigned int max_bitflips)\n{\n\tstruct denali_controller *denali = to_denali_controller(chip);\n\tstruct mtd_ecc_stats *ecc_stats = &nand_to_mtd(chip)->ecc_stats;\n\tstruct nand_ecc_ctrl *ecc = &chip->ecc;\n\tu8 *ecc_code = chip->oob_poi + denali->oob_skip_bytes;\n\tint i, stat;\n\n\tfor (i = 0; i < ecc->steps; i++) {\n\t\tif (!(uncor_ecc_flags & BIT(i)))\n\t\t\tcontinue;\n\n\t\tstat = nand_check_erased_ecc_chunk(buf, ecc->size, ecc_code,\n\t\t\t\t\t\t   ecc->bytes, NULL, 0,\n\t\t\t\t\t\t   ecc->strength);\n\t\tif (stat < 0) {\n\t\t\tecc_stats->failed++;\n\t\t} else {\n\t\t\tecc_stats->corrected += stat;\n\t\t\tmax_bitflips = max_t(unsigned int, max_bitflips, stat);\n\t\t}\n\n\t\tbuf += ecc->size;\n\t\tecc_code += ecc->bytes;\n\t}\n\n\treturn max_bitflips;\n}\n\nstatic int denali_hw_ecc_fixup(struct nand_chip *chip,\n\t\t\t       unsigned long *uncor_ecc_flags)\n{\n\tstruct denali_controller *denali = to_denali_controller(chip);\n\tstruct mtd_ecc_stats *ecc_stats = &nand_to_mtd(chip)->ecc_stats;\n\tint bank = denali->active_bank;\n\tu32 ecc_cor;\n\tunsigned int max_bitflips;\n\n\tecc_cor = ioread32(denali->reg + ECC_COR_INFO(bank));\n\tecc_cor >>= ECC_COR_INFO__SHIFT(bank);\n\n\tif (ecc_cor & ECC_COR_INFO__UNCOR_ERR) {\n\t\t \n\t\t*uncor_ecc_flags = GENMASK(chip->ecc.steps - 1, 0);\n\t\treturn 0;\n\t}\n\n\tmax_bitflips = FIELD_GET(ECC_COR_INFO__MAX_ERRORS, ecc_cor);\n\n\t \n\tecc_stats->corrected += max_bitflips;\n\n\treturn max_bitflips;\n}\n\nstatic int denali_sw_ecc_fixup(struct nand_chip *chip,\n\t\t\t       unsigned long *uncor_ecc_flags, u8 *buf)\n{\n\tstruct denali_controller *denali = to_denali_controller(chip);\n\tstruct mtd_ecc_stats *ecc_stats = &nand_to_mtd(chip)->ecc_stats;\n\tunsigned int ecc_size = chip->ecc.size;\n\tunsigned int bitflips = 0;\n\tunsigned int max_bitflips = 0;\n\tu32 err_addr, err_cor_info;\n\tunsigned int err_byte, err_sector, err_device;\n\tu8 err_cor_value;\n\tunsigned int prev_sector = 0;\n\tu32 irq_status;\n\n\tdenali_reset_irq(denali);\n\n\tdo {\n\t\terr_addr = ioread32(denali->reg + ECC_ERROR_ADDRESS);\n\t\terr_sector = FIELD_GET(ECC_ERROR_ADDRESS__SECTOR, err_addr);\n\t\terr_byte = FIELD_GET(ECC_ERROR_ADDRESS__OFFSET, err_addr);\n\n\t\terr_cor_info = ioread32(denali->reg + ERR_CORRECTION_INFO);\n\t\terr_cor_value = FIELD_GET(ERR_CORRECTION_INFO__BYTE,\n\t\t\t\t\t  err_cor_info);\n\t\terr_device = FIELD_GET(ERR_CORRECTION_INFO__DEVICE,\n\t\t\t\t       err_cor_info);\n\n\t\t \n\t\tif (err_sector != prev_sector)\n\t\t\tbitflips = 0;\n\n\t\tif (err_cor_info & ERR_CORRECTION_INFO__UNCOR) {\n\t\t\t \n\t\t\t*uncor_ecc_flags |= BIT(err_sector);\n\t\t} else if (err_byte < ecc_size) {\n\t\t\t \n\t\t\tint offset;\n\t\t\tunsigned int flips_in_byte;\n\n\t\t\toffset = (err_sector * ecc_size + err_byte) *\n\t\t\t\t\tdenali->devs_per_cs + err_device;\n\n\t\t\t \n\t\t\tflips_in_byte = hweight8(buf[offset] ^ err_cor_value);\n\t\t\tbuf[offset] ^= err_cor_value;\n\t\t\tecc_stats->corrected += flips_in_byte;\n\t\t\tbitflips += flips_in_byte;\n\n\t\t\tmax_bitflips = max(max_bitflips, bitflips);\n\t\t}\n\n\t\tprev_sector = err_sector;\n\t} while (!(err_cor_info & ERR_CORRECTION_INFO__LAST_ERR));\n\n\t \n\tirq_status = denali_wait_for_irq(denali, INTR__ECC_TRANSACTION_DONE);\n\tif (!(irq_status & INTR__ECC_TRANSACTION_DONE))\n\t\treturn -EIO;\n\n\treturn max_bitflips;\n}\n\nstatic void denali_setup_dma64(struct denali_controller *denali,\n\t\t\t       dma_addr_t dma_addr, int page, bool write)\n{\n\tu32 mode;\n\tconst int page_count = 1;\n\n\tmode = DENALI_MAP10 | DENALI_BANK(denali) | page;\n\n\t \n\n\t \n\tdenali->host_write(denali, mode,\n\t\t\t   0x01002000 | (64 << 16) |\n\t\t\t   (write ? BIT(8) : 0) | page_count);\n\n\t \n\tdenali->host_write(denali, mode, lower_32_bits(dma_addr));\n\n\t \n\tdenali->host_write(denali, mode, upper_32_bits(dma_addr));\n}\n\nstatic void denali_setup_dma32(struct denali_controller *denali,\n\t\t\t       dma_addr_t dma_addr, int page, bool write)\n{\n\tu32 mode;\n\tconst int page_count = 1;\n\n\tmode = DENALI_MAP10 | DENALI_BANK(denali);\n\n\t \n\n\t \n\tdenali->host_write(denali, mode | page,\n\t\t\t   0x2000 | (write ? BIT(8) : 0) | page_count);\n\n\t \n\tdenali->host_write(denali, mode | ((dma_addr >> 16) << 8), 0x2200);\n\n\t \n\tdenali->host_write(denali, mode | ((dma_addr & 0xffff) << 8), 0x2300);\n\n\t \n\tdenali->host_write(denali, mode | 0x14000, 0x2400);\n}\n\nstatic int denali_pio_read(struct denali_controller *denali, u32 *buf,\n\t\t\t   size_t size, int page)\n{\n\tu32 addr = DENALI_MAP01 | DENALI_BANK(denali) | page;\n\tu32 irq_status, ecc_err_mask;\n\tint i;\n\n\tif (denali->caps & DENALI_CAP_HW_ECC_FIXUP)\n\t\tecc_err_mask = INTR__ECC_UNCOR_ERR;\n\telse\n\t\tecc_err_mask = INTR__ECC_ERR;\n\n\tdenali_reset_irq(denali);\n\n\tfor (i = 0; i < size / 4; i++)\n\t\tbuf[i] = denali->host_read(denali, addr);\n\n\tirq_status = denali_wait_for_irq(denali, INTR__PAGE_XFER_INC);\n\tif (!(irq_status & INTR__PAGE_XFER_INC))\n\t\treturn -EIO;\n\n\tif (irq_status & INTR__ERASED_PAGE)\n\t\tmemset(buf, 0xff, size);\n\n\treturn irq_status & ecc_err_mask ? -EBADMSG : 0;\n}\n\nstatic int denali_pio_write(struct denali_controller *denali, const u32 *buf,\n\t\t\t    size_t size, int page)\n{\n\tu32 addr = DENALI_MAP01 | DENALI_BANK(denali) | page;\n\tu32 irq_status;\n\tint i;\n\n\tdenali_reset_irq(denali);\n\n\tfor (i = 0; i < size / 4; i++)\n\t\tdenali->host_write(denali, addr, buf[i]);\n\n\tirq_status = denali_wait_for_irq(denali,\n\t\t\t\t\t INTR__PROGRAM_COMP |\n\t\t\t\t\t INTR__PROGRAM_FAIL);\n\tif (!(irq_status & INTR__PROGRAM_COMP))\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nstatic int denali_pio_xfer(struct denali_controller *denali, void *buf,\n\t\t\t   size_t size, int page, bool write)\n{\n\tif (write)\n\t\treturn denali_pio_write(denali, buf, size, page);\n\telse\n\t\treturn denali_pio_read(denali, buf, size, page);\n}\n\nstatic int denali_dma_xfer(struct denali_controller *denali, void *buf,\n\t\t\t   size_t size, int page, bool write)\n{\n\tdma_addr_t dma_addr;\n\tu32 irq_mask, irq_status, ecc_err_mask;\n\tenum dma_data_direction dir = write ? DMA_TO_DEVICE : DMA_FROM_DEVICE;\n\tint ret = 0;\n\n\tdma_addr = dma_map_single(denali->dev, buf, size, dir);\n\tif (dma_mapping_error(denali->dev, dma_addr)) {\n\t\tdev_dbg(denali->dev, \"Failed to DMA-map buffer. Trying PIO.\\n\");\n\t\treturn denali_pio_xfer(denali, buf, size, page, write);\n\t}\n\n\tif (write) {\n\t\t \n\t\tirq_mask = INTR__DMA_CMD_COMP | INTR__PROGRAM_FAIL;\n\t\tecc_err_mask = 0;\n\t} else if (denali->caps & DENALI_CAP_HW_ECC_FIXUP) {\n\t\tirq_mask = INTR__DMA_CMD_COMP;\n\t\tecc_err_mask = INTR__ECC_UNCOR_ERR;\n\t} else {\n\t\tirq_mask = INTR__DMA_CMD_COMP;\n\t\tecc_err_mask = INTR__ECC_ERR;\n\t}\n\n\tiowrite32(DMA_ENABLE__FLAG, denali->reg + DMA_ENABLE);\n\t \n\tioread32(denali->reg + DMA_ENABLE);\n\n\tdenali_reset_irq(denali);\n\tdenali->setup_dma(denali, dma_addr, page, write);\n\n\tirq_status = denali_wait_for_irq(denali, irq_mask);\n\tif (!(irq_status & INTR__DMA_CMD_COMP))\n\t\tret = -EIO;\n\telse if (irq_status & ecc_err_mask)\n\t\tret = -EBADMSG;\n\n\tiowrite32(0, denali->reg + DMA_ENABLE);\n\n\tdma_unmap_single(denali->dev, dma_addr, size, dir);\n\n\tif (irq_status & INTR__ERASED_PAGE)\n\t\tmemset(buf, 0xff, size);\n\n\treturn ret;\n}\n\nstatic int denali_page_xfer(struct nand_chip *chip, void *buf, size_t size,\n\t\t\t    int page, bool write)\n{\n\tstruct denali_controller *denali = to_denali_controller(chip);\n\n\tdenali_select_target(chip, chip->cur_cs);\n\n\tif (denali->dma_avail)\n\t\treturn denali_dma_xfer(denali, buf, size, page, write);\n\telse\n\t\treturn denali_pio_xfer(denali, buf, size, page, write);\n}\n\nstatic int denali_read_page(struct nand_chip *chip, u8 *buf,\n\t\t\t    int oob_required, int page)\n{\n\tstruct denali_controller *denali = to_denali_controller(chip);\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tunsigned long uncor_ecc_flags = 0;\n\tint stat = 0;\n\tint ret;\n\n\tret = denali_page_xfer(chip, buf, mtd->writesize, page, false);\n\tif (ret && ret != -EBADMSG)\n\t\treturn ret;\n\n\tif (denali->caps & DENALI_CAP_HW_ECC_FIXUP)\n\t\tstat = denali_hw_ecc_fixup(chip, &uncor_ecc_flags);\n\telse if (ret == -EBADMSG)\n\t\tstat = denali_sw_ecc_fixup(chip, &uncor_ecc_flags, buf);\n\n\tif (stat < 0)\n\t\treturn stat;\n\n\tif (uncor_ecc_flags) {\n\t\tret = denali_read_oob(chip, page);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tstat = denali_check_erased_page(chip, buf,\n\t\t\t\t\t\tuncor_ecc_flags, stat);\n\t}\n\n\treturn stat;\n}\n\nstatic int denali_write_page(struct nand_chip *chip, const u8 *buf,\n\t\t\t     int oob_required, int page)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\n\treturn denali_page_xfer(chip, (void *)buf, mtd->writesize, page, true);\n}\n\nstatic int denali_setup_interface(struct nand_chip *chip, int chipnr,\n\t\t\t\t  const struct nand_interface_config *conf)\n{\n\tstatic const unsigned int data_setup_on_host = 10000;\n\tstruct denali_controller *denali = to_denali_controller(chip);\n\tstruct denali_chip_sel *sel;\n\tconst struct nand_sdr_timings *timings;\n\tunsigned long t_x, mult_x;\n\tint acc_clks, re_2_we, re_2_re, we_2_re, addr_2_data;\n\tint rdwr_en_lo, rdwr_en_hi, rdwr_en_lo_hi, cs_setup;\n\tint addr_2_data_mask;\n\tu32 tmp;\n\n\ttimings = nand_get_sdr_timings(conf);\n\tif (IS_ERR(timings))\n\t\treturn PTR_ERR(timings);\n\n\t \n\tt_x = DIV_ROUND_DOWN_ULL(1000000000000ULL, denali->clk_x_rate);\n\tif (!t_x)\n\t\treturn -EINVAL;\n\n\t \n\tmult_x = DIV_ROUND_CLOSEST_ULL(denali->clk_x_rate, denali->clk_rate);\n\tif (mult_x < 4 || mult_x > 6)\n\t\treturn -EINVAL;\n\n\tif (chipnr == NAND_DATA_IFACE_CHECK_ONLY)\n\t\treturn 0;\n\n\tsel = &to_denali_chip(chip)->sels[chipnr];\n\n\t \n\tre_2_we = DIV_ROUND_UP(timings->tRHW_min, t_x);\n\tre_2_we = min_t(int, re_2_we, RE_2_WE__VALUE);\n\n\ttmp = ioread32(denali->reg + RE_2_WE);\n\ttmp &= ~RE_2_WE__VALUE;\n\ttmp |= FIELD_PREP(RE_2_WE__VALUE, re_2_we);\n\tsel->re_2_we = tmp;\n\n\t \n\tre_2_re = DIV_ROUND_UP(timings->tRHZ_max, t_x);\n\tre_2_re = min_t(int, re_2_re, RE_2_RE__VALUE);\n\n\ttmp = ioread32(denali->reg + RE_2_RE);\n\ttmp &= ~RE_2_RE__VALUE;\n\ttmp |= FIELD_PREP(RE_2_RE__VALUE, re_2_re);\n\tsel->re_2_re = tmp;\n\n\t \n\twe_2_re = DIV_ROUND_UP(max(timings->tCCS_min, timings->tWHR_min), t_x);\n\twe_2_re = min_t(int, we_2_re, TWHR2_AND_WE_2_RE__WE_2_RE);\n\n\ttmp = ioread32(denali->reg + TWHR2_AND_WE_2_RE);\n\ttmp &= ~TWHR2_AND_WE_2_RE__WE_2_RE;\n\ttmp |= FIELD_PREP(TWHR2_AND_WE_2_RE__WE_2_RE, we_2_re);\n\tsel->hwhr2_and_we_2_re = tmp;\n\n\t \n\n\t \n\taddr_2_data_mask = TCWAW_AND_ADDR_2_DATA__ADDR_2_DATA;\n\tif (denali->revision < 0x0501)\n\t\taddr_2_data_mask >>= 1;\n\n\taddr_2_data = DIV_ROUND_UP(timings->tADL_min, t_x);\n\taddr_2_data = min_t(int, addr_2_data, addr_2_data_mask);\n\n\ttmp = ioread32(denali->reg + TCWAW_AND_ADDR_2_DATA);\n\ttmp &= ~TCWAW_AND_ADDR_2_DATA__ADDR_2_DATA;\n\ttmp |= FIELD_PREP(TCWAW_AND_ADDR_2_DATA__ADDR_2_DATA, addr_2_data);\n\tsel->tcwaw_and_addr_2_data = tmp;\n\n\t \n\trdwr_en_hi = DIV_ROUND_UP(max(timings->tREH_min, timings->tWH_min),\n\t\t\t\t  t_x);\n\trdwr_en_hi = min_t(int, rdwr_en_hi, RDWR_EN_HI_CNT__VALUE);\n\n\ttmp = ioread32(denali->reg + RDWR_EN_HI_CNT);\n\ttmp &= ~RDWR_EN_HI_CNT__VALUE;\n\ttmp |= FIELD_PREP(RDWR_EN_HI_CNT__VALUE, rdwr_en_hi);\n\tsel->rdwr_en_hi_cnt = tmp;\n\n\t \n\n\t \n\tacc_clks = DIV_ROUND_UP(timings->tREA_max + data_setup_on_host, t_x);\n\n\t \n\trdwr_en_lo = DIV_ROUND_UP(max(timings->tRP_min, timings->tWP_min), t_x);\n\n\t \n\trdwr_en_lo = max_t(int, rdwr_en_lo,\n\t\t\t   acc_clks - timings->tRHOH_min / t_x);\n\n\t \n\trdwr_en_lo_hi = DIV_ROUND_UP(max(timings->tRC_min, timings->tWC_min),\n\t\t\t\t     t_x);\n\trdwr_en_lo = max(rdwr_en_lo, rdwr_en_lo_hi - rdwr_en_hi);\n\trdwr_en_lo = min_t(int, rdwr_en_lo, RDWR_EN_LO_CNT__VALUE);\n\n\t \n\tacc_clks = (acc_clks + rdwr_en_lo +\n\t\t    DIV_ROUND_UP(timings->tRHOH_min, t_x)) / 2;\n\tacc_clks = min_t(int, acc_clks, ACC_CLKS__VALUE);\n\n\ttmp = ioread32(denali->reg + ACC_CLKS);\n\ttmp &= ~ACC_CLKS__VALUE;\n\ttmp |= FIELD_PREP(ACC_CLKS__VALUE, acc_clks);\n\tsel->acc_clks = tmp;\n\n\ttmp = ioread32(denali->reg + RDWR_EN_LO_CNT);\n\ttmp &= ~RDWR_EN_LO_CNT__VALUE;\n\ttmp |= FIELD_PREP(RDWR_EN_LO_CNT__VALUE, rdwr_en_lo);\n\tsel->rdwr_en_lo_cnt = tmp;\n\n\t \n\tcs_setup = max3((int)DIV_ROUND_UP(timings->tCS_min, t_x) - rdwr_en_lo,\n\t\t\t(int)DIV_ROUND_UP(timings->tCEA_max, t_x) - acc_clks,\n\t\t\t0);\n\tcs_setup = min_t(int, cs_setup, CS_SETUP_CNT__VALUE);\n\n\ttmp = ioread32(denali->reg + CS_SETUP_CNT);\n\ttmp &= ~CS_SETUP_CNT__VALUE;\n\ttmp |= FIELD_PREP(CS_SETUP_CNT__VALUE, cs_setup);\n\tsel->cs_setup_cnt = tmp;\n\n\treturn 0;\n}\n\nint denali_calc_ecc_bytes(int step_size, int strength)\n{\n\t \n\treturn DIV_ROUND_UP(strength * fls(step_size * 8), 16) * 2;\n}\nEXPORT_SYMBOL(denali_calc_ecc_bytes);\n\nstatic int denali_ooblayout_ecc(struct mtd_info *mtd, int section,\n\t\t\t\tstruct mtd_oob_region *oobregion)\n{\n\tstruct nand_chip *chip = mtd_to_nand(mtd);\n\tstruct denali_controller *denali = to_denali_controller(chip);\n\n\tif (section > 0)\n\t\treturn -ERANGE;\n\n\toobregion->offset = denali->oob_skip_bytes;\n\toobregion->length = chip->ecc.total;\n\n\treturn 0;\n}\n\nstatic int denali_ooblayout_free(struct mtd_info *mtd, int section,\n\t\t\t\t struct mtd_oob_region *oobregion)\n{\n\tstruct nand_chip *chip = mtd_to_nand(mtd);\n\tstruct denali_controller *denali = to_denali_controller(chip);\n\n\tif (section > 0)\n\t\treturn -ERANGE;\n\n\toobregion->offset = chip->ecc.total + denali->oob_skip_bytes;\n\toobregion->length = mtd->oobsize - oobregion->offset;\n\n\treturn 0;\n}\n\nstatic const struct mtd_ooblayout_ops denali_ooblayout_ops = {\n\t.ecc = denali_ooblayout_ecc,\n\t.free = denali_ooblayout_free,\n};\n\nstatic int denali_multidev_fixup(struct nand_chip *chip)\n{\n\tstruct denali_controller *denali = to_denali_controller(chip);\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tstruct nand_memory_organization *memorg;\n\n\tmemorg = nanddev_get_memorg(&chip->base);\n\n\t \n\tdenali->devs_per_cs = ioread32(denali->reg + DEVICES_CONNECTED);\n\n\t \n\tif (denali->devs_per_cs == 0) {\n\t\tdenali->devs_per_cs = 1;\n\t\tiowrite32(1, denali->reg + DEVICES_CONNECTED);\n\t}\n\n\tif (denali->devs_per_cs == 1)\n\t\treturn 0;\n\n\tif (denali->devs_per_cs != 2) {\n\t\tdev_err(denali->dev, \"unsupported number of devices %d\\n\",\n\t\t\tdenali->devs_per_cs);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tmemorg->pagesize <<= 1;\n\tmemorg->oobsize <<= 1;\n\tmtd->size <<= 1;\n\tmtd->erasesize <<= 1;\n\tmtd->writesize <<= 1;\n\tmtd->oobsize <<= 1;\n\tchip->page_shift += 1;\n\tchip->phys_erase_shift += 1;\n\tchip->bbt_erase_shift += 1;\n\tchip->chip_shift += 1;\n\tchip->pagemask <<= 1;\n\tchip->ecc.size <<= 1;\n\tchip->ecc.bytes <<= 1;\n\tchip->ecc.strength <<= 1;\n\tdenali->oob_skip_bytes <<= 1;\n\n\treturn 0;\n}\n\nstatic int denali_attach_chip(struct nand_chip *chip)\n{\n\tstruct denali_controller *denali = to_denali_controller(chip);\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tint ret;\n\n\tret = nand_ecc_choose_conf(chip, denali->ecc_caps,\n\t\t\t\t   mtd->oobsize - denali->oob_skip_bytes);\n\tif (ret) {\n\t\tdev_err(denali->dev, \"Failed to setup ECC settings.\\n\");\n\t\treturn ret;\n\t}\n\n\tdev_dbg(denali->dev,\n\t\t\"chosen ECC settings: step=%d, strength=%d, bytes=%d\\n\",\n\t\tchip->ecc.size, chip->ecc.strength, chip->ecc.bytes);\n\n\tret = denali_multidev_fixup(chip);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic void denali_exec_in8(struct denali_controller *denali, u32 type,\n\t\t\t    u8 *buf, unsigned int len)\n{\n\tint i;\n\n\tfor (i = 0; i < len; i++)\n\t\tbuf[i] = denali->host_read(denali, type | DENALI_BANK(denali));\n}\n\nstatic void denali_exec_in16(struct denali_controller *denali, u32 type,\n\t\t\t     u8 *buf, unsigned int len)\n{\n\tu32 data;\n\tint i;\n\n\tfor (i = 0; i < len; i += 2) {\n\t\tdata = denali->host_read(denali, type | DENALI_BANK(denali));\n\t\t \n\t\tbuf[i] = data;\n\t\tbuf[i + 1] = data >> 16;\n\t}\n}\n\nstatic void denali_exec_in(struct denali_controller *denali, u32 type,\n\t\t\t   u8 *buf, unsigned int len, bool width16)\n{\n\tif (width16)\n\t\tdenali_exec_in16(denali, type, buf, len);\n\telse\n\t\tdenali_exec_in8(denali, type, buf, len);\n}\n\nstatic void denali_exec_out8(struct denali_controller *denali, u32 type,\n\t\t\t     const u8 *buf, unsigned int len)\n{\n\tint i;\n\n\tfor (i = 0; i < len; i++)\n\t\tdenali->host_write(denali, type | DENALI_BANK(denali), buf[i]);\n}\n\nstatic void denali_exec_out16(struct denali_controller *denali, u32 type,\n\t\t\t      const u8 *buf, unsigned int len)\n{\n\tint i;\n\n\tfor (i = 0; i < len; i += 2)\n\t\tdenali->host_write(denali, type | DENALI_BANK(denali),\n\t\t\t\t   buf[i + 1] << 16 | buf[i]);\n}\n\nstatic void denali_exec_out(struct denali_controller *denali, u32 type,\n\t\t\t    const u8 *buf, unsigned int len, bool width16)\n{\n\tif (width16)\n\t\tdenali_exec_out16(denali, type, buf, len);\n\telse\n\t\tdenali_exec_out8(denali, type, buf, len);\n}\n\nstatic int denali_exec_waitrdy(struct denali_controller *denali)\n{\n\tu32 irq_stat;\n\n\t \n\tirq_stat = denali_wait_for_irq(denali, INTR__INT_ACT);\n\n\t \n\tdenali_reset_irq(denali);\n\n\treturn irq_stat & INTR__INT_ACT ? 0 : -EIO;\n}\n\nstatic int denali_exec_instr(struct nand_chip *chip,\n\t\t\t     const struct nand_op_instr *instr)\n{\n\tstruct denali_controller *denali = to_denali_controller(chip);\n\n\tswitch (instr->type) {\n\tcase NAND_OP_CMD_INSTR:\n\t\tdenali_exec_out8(denali, DENALI_MAP11_CMD,\n\t\t\t\t &instr->ctx.cmd.opcode, 1);\n\t\treturn 0;\n\tcase NAND_OP_ADDR_INSTR:\n\t\tdenali_exec_out8(denali, DENALI_MAP11_ADDR,\n\t\t\t\t instr->ctx.addr.addrs,\n\t\t\t\t instr->ctx.addr.naddrs);\n\t\treturn 0;\n\tcase NAND_OP_DATA_IN_INSTR:\n\t\tdenali_exec_in(denali, DENALI_MAP11_DATA,\n\t\t\t       instr->ctx.data.buf.in,\n\t\t\t       instr->ctx.data.len,\n\t\t\t       !instr->ctx.data.force_8bit &&\n\t\t\t       chip->options & NAND_BUSWIDTH_16);\n\t\treturn 0;\n\tcase NAND_OP_DATA_OUT_INSTR:\n\t\tdenali_exec_out(denali, DENALI_MAP11_DATA,\n\t\t\t\tinstr->ctx.data.buf.out,\n\t\t\t\tinstr->ctx.data.len,\n\t\t\t\t!instr->ctx.data.force_8bit &&\n\t\t\t\tchip->options & NAND_BUSWIDTH_16);\n\t\treturn 0;\n\tcase NAND_OP_WAITRDY_INSTR:\n\t\treturn denali_exec_waitrdy(denali);\n\tdefault:\n\t\tWARN_ONCE(1, \"unsupported NAND instruction type: %d\\n\",\n\t\t\t  instr->type);\n\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int denali_exec_op(struct nand_chip *chip,\n\t\t\t  const struct nand_operation *op, bool check_only)\n{\n\tint i, ret;\n\n\tif (check_only)\n\t\treturn 0;\n\n\tdenali_select_target(chip, op->cs);\n\n\t \n\tdenali_reset_irq(to_denali_controller(chip));\n\n\tfor (i = 0; i < op->ninstrs; i++) {\n\t\tret = denali_exec_instr(chip, &op->instrs[i]);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct nand_controller_ops denali_controller_ops = {\n\t.attach_chip = denali_attach_chip,\n\t.exec_op = denali_exec_op,\n\t.setup_interface = denali_setup_interface,\n};\n\nint denali_chip_init(struct denali_controller *denali,\n\t\t     struct denali_chip *dchip)\n{\n\tstruct nand_chip *chip = &dchip->chip;\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tstruct denali_chip *dchip2;\n\tint i, j, ret;\n\n\tchip->controller = &denali->controller;\n\n\t \n\tfor (i = 0; i < dchip->nsels; i++) {\n\t\tunsigned int bank = dchip->sels[i].bank;\n\n\t\tif (bank >= denali->nbanks) {\n\t\t\tdev_err(denali->dev, \"unsupported bank %d\\n\", bank);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tfor (j = 0; j < i; j++) {\n\t\t\tif (bank == dchip->sels[j].bank) {\n\t\t\t\tdev_err(denali->dev,\n\t\t\t\t\t\"bank %d is assigned twice in the same chip\\n\",\n\t\t\t\t\tbank);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\n\t\tlist_for_each_entry(dchip2, &denali->chips, node) {\n\t\t\tfor (j = 0; j < dchip2->nsels; j++) {\n\t\t\t\tif (bank == dchip2->sels[j].bank) {\n\t\t\t\t\tdev_err(denali->dev,\n\t\t\t\t\t\t\"bank %d is already used\\n\",\n\t\t\t\t\t\tbank);\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tmtd->dev.parent = denali->dev;\n\n\t \n\tif (!mtd->name && list_empty(&denali->chips))\n\t\tmtd->name = \"denali-nand\";\n\n\tif (denali->dma_avail) {\n\t\tchip->options |= NAND_USES_DMA;\n\t\tchip->buf_align = 16;\n\t}\n\n\t \n\tif (!denali->clk_rate || !denali->clk_x_rate)\n\t\tchip->options |= NAND_KEEP_TIMINGS;\n\n\tchip->bbt_options |= NAND_BBT_USE_FLASH;\n\tchip->bbt_options |= NAND_BBT_NO_OOB;\n\tchip->options |= NAND_NO_SUBPAGE_WRITE;\n\tchip->ecc.engine_type = NAND_ECC_ENGINE_TYPE_ON_HOST;\n\tchip->ecc.placement = NAND_ECC_PLACEMENT_INTERLEAVED;\n\tchip->ecc.read_page = denali_read_page;\n\tchip->ecc.write_page = denali_write_page;\n\tchip->ecc.read_page_raw = denali_read_page_raw;\n\tchip->ecc.write_page_raw = denali_write_page_raw;\n\tchip->ecc.read_oob = denali_read_oob;\n\tchip->ecc.write_oob = denali_write_oob;\n\n\tmtd_set_ooblayout(mtd, &denali_ooblayout_ops);\n\n\tret = nand_scan(chip, dchip->nsels);\n\tif (ret)\n\t\treturn ret;\n\n\tret = mtd_device_register(mtd, NULL, 0);\n\tif (ret) {\n\t\tdev_err(denali->dev, \"Failed to register MTD: %d\\n\", ret);\n\t\tgoto cleanup_nand;\n\t}\n\n\tlist_add_tail(&dchip->node, &denali->chips);\n\n\treturn 0;\n\ncleanup_nand:\n\tnand_cleanup(chip);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(denali_chip_init);\n\nint denali_init(struct denali_controller *denali)\n{\n\tu32 features = ioread32(denali->reg + FEATURES);\n\tint ret;\n\n\tnand_controller_init(&denali->controller);\n\tdenali->controller.ops = &denali_controller_ops;\n\tinit_completion(&denali->complete);\n\tspin_lock_init(&denali->irq_lock);\n\tINIT_LIST_HEAD(&denali->chips);\n\tdenali->active_bank = DENALI_INVALID_BANK;\n\n\t \n\tif (!denali->revision)\n\t\tdenali->revision = swab16(ioread32(denali->reg + REVISION));\n\n\tdenali->nbanks = 1 << FIELD_GET(FEATURES__N_BANKS, features);\n\n\t \n\tif (denali->revision < 0x0501)\n\t\tdenali->nbanks <<= 1;\n\n\tif (features & FEATURES__DMA)\n\t\tdenali->dma_avail = true;\n\n\tif (denali->dma_avail) {\n\t\tint dma_bit = denali->caps & DENALI_CAP_DMA_64BIT ? 64 : 32;\n\n\t\tret = dma_set_mask(denali->dev, DMA_BIT_MASK(dma_bit));\n\t\tif (ret) {\n\t\t\tdev_info(denali->dev,\n\t\t\t\t \"Failed to set DMA mask. Disabling DMA.\\n\");\n\t\t\tdenali->dma_avail = false;\n\t\t}\n\t}\n\n\tif (denali->dma_avail) {\n\t\tif (denali->caps & DENALI_CAP_DMA_64BIT)\n\t\t\tdenali->setup_dma = denali_setup_dma64;\n\t\telse\n\t\t\tdenali->setup_dma = denali_setup_dma32;\n\t}\n\n\tif (features & FEATURES__INDEX_ADDR) {\n\t\tdenali->host_read = denali_indexed_read;\n\t\tdenali->host_write = denali_indexed_write;\n\t} else {\n\t\tdenali->host_read = denali_direct_read;\n\t\tdenali->host_write = denali_direct_write;\n\t}\n\n\t \n\tif (denali->oob_skip_bytes)\n\t\tiowrite32(denali->oob_skip_bytes,\n\t\t\t  denali->reg + SPARE_AREA_SKIP_BYTES);\n\telse\n\t\tdenali->oob_skip_bytes = ioread32(denali->reg +\n\t\t\t\t\t\t  SPARE_AREA_SKIP_BYTES);\n\n\tiowrite32(0, denali->reg + TRANSFER_SPARE_REG);\n\tiowrite32(GENMASK(denali->nbanks - 1, 0), denali->reg + RB_PIN_ENABLED);\n\tiowrite32(CHIP_EN_DONT_CARE__FLAG, denali->reg + CHIP_ENABLE_DONT_CARE);\n\tiowrite32(ECC_ENABLE__FLAG, denali->reg + ECC_ENABLE);\n\tiowrite32(0xffff, denali->reg + SPARE_AREA_MARKER);\n\tiowrite32(WRITE_PROTECT__FLAG, denali->reg + WRITE_PROTECT);\n\n\tdenali_clear_irq_all(denali);\n\n\tret = devm_request_irq(denali->dev, denali->irq, denali_isr,\n\t\t\t       IRQF_SHARED, DENALI_NAND_NAME, denali);\n\tif (ret) {\n\t\tdev_err(denali->dev, \"Unable to request IRQ\\n\");\n\t\treturn ret;\n\t}\n\n\tdenali_enable_irq(denali);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(denali_init);\n\nvoid denali_remove(struct denali_controller *denali)\n{\n\tstruct denali_chip *dchip, *tmp;\n\tstruct nand_chip *chip;\n\tint ret;\n\n\tlist_for_each_entry_safe(dchip, tmp, &denali->chips, node) {\n\t\tchip = &dchip->chip;\n\t\tret = mtd_device_unregister(nand_to_mtd(chip));\n\t\tWARN_ON(ret);\n\t\tnand_cleanup(chip);\n\t\tlist_del(&dchip->node);\n\t}\n\n\tdenali_disable_irq(denali);\n}\nEXPORT_SYMBOL(denali_remove);\n\nMODULE_DESCRIPTION(\"Driver core for Denali NAND controller\");\nMODULE_AUTHOR(\"Intel Corporation and its suppliers\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}