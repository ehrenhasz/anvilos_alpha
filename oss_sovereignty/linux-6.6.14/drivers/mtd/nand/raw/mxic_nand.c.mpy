{
  "module_name": "mxic_nand.c",
  "hash_id": "bea5d1553bdd329ef75c7bd75375093505753a4513faac1e231ec7ae23cb7118",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/nand/raw/mxic_nand.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/mtd/mtd.h>\n#include <linux/mtd/nand-ecc-sw-hamming.h>\n#include <linux/mtd/rawnand.h>\n#include <linux/platform_device.h>\n\n#include \"internals.h\"\n\n#define HC_CFG\t\t\t0x0\n#define HC_CFG_IF_CFG(x)\t((x) << 27)\n#define HC_CFG_DUAL_SLAVE\tBIT(31)\n#define HC_CFG_INDIVIDUAL\tBIT(30)\n#define HC_CFG_NIO(x)\t\t(((x) / 4) << 27)\n#define HC_CFG_TYPE(s, t)\t((t) << (23 + ((s) * 2)))\n#define HC_CFG_TYPE_SPI_NOR\t0\n#define HC_CFG_TYPE_SPI_NAND\t1\n#define HC_CFG_TYPE_SPI_RAM\t2\n#define HC_CFG_TYPE_RAW_NAND\t3\n#define HC_CFG_SLV_ACT(x)\t((x) << 21)\n#define HC_CFG_CLK_PH_EN\tBIT(20)\n#define HC_CFG_CLK_POL_INV\tBIT(19)\n#define HC_CFG_BIG_ENDIAN\tBIT(18)\n#define HC_CFG_DATA_PASS\tBIT(17)\n#define HC_CFG_IDLE_SIO_LVL(x)\t((x) << 16)\n#define HC_CFG_MAN_START_EN\tBIT(3)\n#define HC_CFG_MAN_START\tBIT(2)\n#define HC_CFG_MAN_CS_EN\tBIT(1)\n#define HC_CFG_MAN_CS_ASSERT\tBIT(0)\n\n#define INT_STS\t\t\t0x4\n#define INT_STS_EN\t\t0x8\n#define INT_SIG_EN\t\t0xc\n#define INT_STS_ALL\t\tGENMASK(31, 0)\n#define INT_RDY_PIN\t\tBIT(26)\n#define INT_RDY_SR\t\tBIT(25)\n#define INT_LNR_SUSP\t\tBIT(24)\n#define INT_ECC_ERR\t\tBIT(17)\n#define INT_CRC_ERR\t\tBIT(16)\n#define INT_LWR_DIS\t\tBIT(12)\n#define INT_LRD_DIS\t\tBIT(11)\n#define INT_SDMA_INT\t\tBIT(10)\n#define INT_DMA_FINISH\t\tBIT(9)\n#define INT_RX_NOT_FULL\t\tBIT(3)\n#define INT_RX_NOT_EMPTY\tBIT(2)\n#define INT_TX_NOT_FULL\t\tBIT(1)\n#define INT_TX_EMPTY\t\tBIT(0)\n\n#define HC_EN\t\t\t0x10\n#define HC_EN_BIT\t\tBIT(0)\n\n#define TXD(x)\t\t\t(0x14 + ((x) * 4))\n#define RXD\t\t\t0x24\n\n#define SS_CTRL(s)\t\t(0x30 + ((s) * 4))\n#define LRD_CFG\t\t\t0x44\n#define LWR_CFG\t\t\t0x80\n#define RWW_CFG\t\t\t0x70\n#define OP_READ\t\t\tBIT(23)\n#define OP_DUMMY_CYC(x)\t\t((x) << 17)\n#define OP_ADDR_BYTES(x)\t((x) << 14)\n#define OP_CMD_BYTES(x)\t\t(((x) - 1) << 13)\n#define OP_OCTA_CRC_EN\t\tBIT(12)\n#define OP_DQS_EN\t\tBIT(11)\n#define OP_ENHC_EN\t\tBIT(10)\n#define OP_PREAMBLE_EN\t\tBIT(9)\n#define OP_DATA_DDR\t\tBIT(8)\n#define OP_DATA_BUSW(x)\t\t((x) << 6)\n#define OP_ADDR_DDR\t\tBIT(5)\n#define OP_ADDR_BUSW(x)\t\t((x) << 3)\n#define OP_CMD_DDR\t\tBIT(2)\n#define OP_CMD_BUSW(x)\t\t(x)\n#define OP_BUSW_1\t\t0\n#define OP_BUSW_2\t\t1\n#define OP_BUSW_4\t\t2\n#define OP_BUSW_8\t\t3\n\n#define OCTA_CRC\t\t0x38\n#define OCTA_CRC_IN_EN(s)\tBIT(3 + ((s) * 16))\n#define OCTA_CRC_CHUNK(s, x)\t((fls((x) / 32)) << (1 + ((s) * 16)))\n#define OCTA_CRC_OUT_EN(s)\tBIT(0 + ((s) * 16))\n\n#define ONFI_DIN_CNT(s)\t\t(0x3c + (s))\n\n#define LRD_CTRL\t\t0x48\n#define RWW_CTRL\t\t0x74\n#define LWR_CTRL\t\t0x84\n#define LMODE_EN\t\tBIT(31)\n#define LMODE_SLV_ACT(x)\t((x) << 21)\n#define LMODE_CMD1(x)\t\t((x) << 8)\n#define LMODE_CMD0(x)\t\t(x)\n\n#define LRD_ADDR\t\t0x4c\n#define LWR_ADDR\t\t0x88\n#define LRD_RANGE\t\t0x50\n#define LWR_RANGE\t\t0x8c\n\n#define AXI_SLV_ADDR\t\t0x54\n\n#define DMAC_RD_CFG\t\t0x58\n#define DMAC_WR_CFG\t\t0x94\n#define DMAC_CFG_PERIPH_EN\tBIT(31)\n#define DMAC_CFG_ALLFLUSH_EN\tBIT(30)\n#define DMAC_CFG_LASTFLUSH_EN\tBIT(29)\n#define DMAC_CFG_QE(x)\t\t(((x) + 1) << 16)\n#define DMAC_CFG_BURST_LEN(x)\t(((x) + 1) << 12)\n#define DMAC_CFG_BURST_SZ(x)\t((x) << 8)\n#define DMAC_CFG_DIR_READ\tBIT(1)\n#define DMAC_CFG_START\t\tBIT(0)\n\n#define DMAC_RD_CNT\t\t0x5c\n#define DMAC_WR_CNT\t\t0x98\n\n#define SDMA_ADDR\t\t0x60\n\n#define DMAM_CFG\t\t0x64\n#define DMAM_CFG_START\t\tBIT(31)\n#define DMAM_CFG_CONT\t\tBIT(30)\n#define DMAM_CFG_SDMA_GAP(x)\t(fls((x) / 8192) << 2)\n#define DMAM_CFG_DIR_READ\tBIT(1)\n#define DMAM_CFG_EN\t\tBIT(0)\n\n#define DMAM_CNT\t\t0x68\n\n#define LNR_TIMER_TH\t\t0x6c\n\n#define RDM_CFG0\t\t0x78\n#define RDM_CFG0_POLY(x)\t(x)\n\n#define RDM_CFG1\t\t0x7c\n#define RDM_CFG1_RDM_EN\t\tBIT(31)\n#define RDM_CFG1_SEED(x)\t(x)\n\n#define LWR_SUSP_CTRL\t\t0x90\n#define LWR_SUSP_CTRL_EN\tBIT(31)\n\n#define DMAS_CTRL\t\t0x9c\n#define DMAS_CTRL_EN\t\tBIT(31)\n#define DMAS_CTRL_DIR_READ\tBIT(30)\n\n#define DATA_STROB\t\t0xa0\n#define DATA_STROB_EDO_EN\tBIT(2)\n#define DATA_STROB_INV_POL\tBIT(1)\n#define DATA_STROB_DELAY_2CYC\tBIT(0)\n\n#define IDLY_CODE(x)\t\t(0xa4 + ((x) * 4))\n#define IDLY_CODE_VAL(x, v)\t((v) << (((x) % 4) * 8))\n\n#define GPIO\t\t\t0xc4\n#define GPIO_PT(x)\t\tBIT(3 + ((x) * 16))\n#define GPIO_RESET(x)\t\tBIT(2 + ((x) * 16))\n#define GPIO_HOLDB(x)\t\tBIT(1 + ((x) * 16))\n#define GPIO_WPB(x)\t\tBIT((x) * 16)\n\n#define HC_VER\t\t\t0xd0\n\n#define HW_TEST(x)\t\t(0xe0 + ((x) * 4))\n\n#define MXIC_NFC_MAX_CLK_HZ\t50000000\n#define IRQ_TIMEOUT\t\t1000\n\nstruct mxic_nand_ctlr {\n\tstruct clk *ps_clk;\n\tstruct clk *send_clk;\n\tstruct clk *send_dly_clk;\n\tstruct completion complete;\n\tvoid __iomem *regs;\n\tstruct nand_controller controller;\n\tstruct device *dev;\n\tstruct nand_chip chip;\n};\n\nstatic int mxic_nfc_clk_enable(struct mxic_nand_ctlr *nfc)\n{\n\tint ret;\n\n\tret = clk_prepare_enable(nfc->ps_clk);\n\tif (ret)\n\t\treturn ret;\n\n\tret = clk_prepare_enable(nfc->send_clk);\n\tif (ret)\n\t\tgoto err_ps_clk;\n\n\tret = clk_prepare_enable(nfc->send_dly_clk);\n\tif (ret)\n\t\tgoto err_send_dly_clk;\n\n\treturn ret;\n\nerr_send_dly_clk:\n\tclk_disable_unprepare(nfc->send_clk);\nerr_ps_clk:\n\tclk_disable_unprepare(nfc->ps_clk);\n\n\treturn ret;\n}\n\nstatic void mxic_nfc_clk_disable(struct mxic_nand_ctlr *nfc)\n{\n\tclk_disable_unprepare(nfc->send_clk);\n\tclk_disable_unprepare(nfc->send_dly_clk);\n\tclk_disable_unprepare(nfc->ps_clk);\n}\n\nstatic void mxic_nfc_set_input_delay(struct mxic_nand_ctlr *nfc, u8 idly_code)\n{\n\twritel(IDLY_CODE_VAL(0, idly_code) |\n\t       IDLY_CODE_VAL(1, idly_code) |\n\t       IDLY_CODE_VAL(2, idly_code) |\n\t       IDLY_CODE_VAL(3, idly_code),\n\t       nfc->regs + IDLY_CODE(0));\n\twritel(IDLY_CODE_VAL(4, idly_code) |\n\t       IDLY_CODE_VAL(5, idly_code) |\n\t       IDLY_CODE_VAL(6, idly_code) |\n\t       IDLY_CODE_VAL(7, idly_code),\n\t       nfc->regs + IDLY_CODE(1));\n}\n\nstatic int mxic_nfc_clk_setup(struct mxic_nand_ctlr *nfc, unsigned long freq)\n{\n\tint ret;\n\n\tret = clk_set_rate(nfc->send_clk, freq);\n\tif (ret)\n\t\treturn ret;\n\n\tret = clk_set_rate(nfc->send_dly_clk, freq);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tmxic_nfc_set_input_delay(nfc, 0xf);\n\n\t \n\tret = clk_set_phase(nfc->send_dly_clk, 9 * freq / 25000000);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int mxic_nfc_set_freq(struct mxic_nand_ctlr *nfc, unsigned long freq)\n{\n\tint ret;\n\n\tif (freq > MXIC_NFC_MAX_CLK_HZ)\n\t\tfreq = MXIC_NFC_MAX_CLK_HZ;\n\n\tmxic_nfc_clk_disable(nfc);\n\tret = mxic_nfc_clk_setup(nfc, freq);\n\tif (ret)\n\t\treturn ret;\n\n\tret = mxic_nfc_clk_enable(nfc);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic irqreturn_t mxic_nfc_isr(int irq, void *dev_id)\n{\n\tstruct mxic_nand_ctlr *nfc = dev_id;\n\tu32 sts;\n\n\tsts = readl(nfc->regs + INT_STS);\n\tif (sts & INT_RDY_PIN)\n\t\tcomplete(&nfc->complete);\n\telse\n\t\treturn IRQ_NONE;\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void mxic_nfc_hw_init(struct mxic_nand_ctlr *nfc)\n{\n\twritel(HC_CFG_NIO(8) | HC_CFG_TYPE(1, HC_CFG_TYPE_RAW_NAND) |\n\t       HC_CFG_SLV_ACT(0) | HC_CFG_MAN_CS_EN |\n\t       HC_CFG_IDLE_SIO_LVL(1), nfc->regs + HC_CFG);\n\twritel(INT_STS_ALL, nfc->regs + INT_STS_EN);\n\twritel(INT_RDY_PIN, nfc->regs + INT_SIG_EN);\n\twritel(0x0, nfc->regs + ONFI_DIN_CNT(0));\n\twritel(0, nfc->regs + LRD_CFG);\n\twritel(0, nfc->regs + LRD_CTRL);\n\twritel(0x0, nfc->regs + HC_EN);\n}\n\nstatic void mxic_nfc_cs_enable(struct mxic_nand_ctlr *nfc)\n{\n\twritel(readl(nfc->regs + HC_CFG) | HC_CFG_MAN_CS_EN,\n\t       nfc->regs + HC_CFG);\n\twritel(HC_CFG_MAN_CS_ASSERT | readl(nfc->regs + HC_CFG),\n\t       nfc->regs + HC_CFG);\n}\n\nstatic void mxic_nfc_cs_disable(struct mxic_nand_ctlr *nfc)\n{\n\twritel(~HC_CFG_MAN_CS_ASSERT & readl(nfc->regs + HC_CFG),\n\t       nfc->regs + HC_CFG);\n}\n\nstatic int  mxic_nfc_wait_ready(struct nand_chip *chip)\n{\n\tstruct mxic_nand_ctlr *nfc = nand_get_controller_data(chip);\n\tint ret;\n\n\tret = wait_for_completion_timeout(&nfc->complete,\n\t\t\t\t\t  msecs_to_jiffies(IRQ_TIMEOUT));\n\tif (!ret) {\n\t\tdev_err(nfc->dev, \"nand device timeout\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\treturn 0;\n}\n\nstatic int mxic_nfc_data_xfer(struct mxic_nand_ctlr *nfc, const void *txbuf,\n\t\t\t      void *rxbuf, unsigned int len)\n{\n\tunsigned int pos = 0;\n\n\twhile (pos < len) {\n\t\tunsigned int nbytes = len - pos;\n\t\tu32 data = 0xffffffff;\n\t\tu32 sts;\n\t\tint ret;\n\n\t\tif (nbytes > 4)\n\t\t\tnbytes = 4;\n\n\t\tif (txbuf)\n\t\t\tmemcpy(&data, txbuf + pos, nbytes);\n\n\t\tret = readl_poll_timeout(nfc->regs + INT_STS, sts,\n\t\t\t\t\t sts & INT_TX_EMPTY, 0, USEC_PER_SEC);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\twritel(data, nfc->regs + TXD(nbytes % 4));\n\n\t\tret = readl_poll_timeout(nfc->regs + INT_STS, sts,\n\t\t\t\t\t sts & INT_TX_EMPTY, 0, USEC_PER_SEC);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = readl_poll_timeout(nfc->regs + INT_STS, sts,\n\t\t\t\t\t sts & INT_RX_NOT_EMPTY, 0,\n\t\t\t\t\t USEC_PER_SEC);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tdata = readl(nfc->regs + RXD);\n\t\tif (rxbuf) {\n\t\t\tdata >>= (8 * (4 - nbytes));\n\t\t\tmemcpy(rxbuf + pos, &data, nbytes);\n\t\t}\n\t\tif (readl(nfc->regs + INT_STS) & INT_RX_NOT_EMPTY)\n\t\t\tdev_warn(nfc->dev, \"RX FIFO not empty\\n\");\n\n\t\tpos += nbytes;\n\t}\n\n\treturn 0;\n}\n\nstatic int mxic_nfc_exec_op(struct nand_chip *chip,\n\t\t\t    const struct nand_operation *op, bool check_only)\n{\n\tstruct mxic_nand_ctlr *nfc = nand_get_controller_data(chip);\n\tconst struct nand_op_instr *instr = NULL;\n\tint ret = 0;\n\tunsigned int op_id;\n\n\tif (check_only)\n\t\treturn 0;\n\n\tmxic_nfc_cs_enable(nfc);\n\tinit_completion(&nfc->complete);\n\tfor (op_id = 0; op_id < op->ninstrs; op_id++) {\n\t\tinstr = &op->instrs[op_id];\n\n\t\tswitch (instr->type) {\n\t\tcase NAND_OP_CMD_INSTR:\n\t\t\twritel(0, nfc->regs + HC_EN);\n\t\t\twritel(HC_EN_BIT, nfc->regs + HC_EN);\n\t\t\twritel(OP_CMD_BUSW(OP_BUSW_8) |  OP_DUMMY_CYC(0x3F) |\n\t\t\t       OP_CMD_BYTES(0), nfc->regs + SS_CTRL(0));\n\n\t\t\tret = mxic_nfc_data_xfer(nfc,\n\t\t\t\t\t\t &instr->ctx.cmd.opcode,\n\t\t\t\t\t\t NULL, 1);\n\t\t\tbreak;\n\n\t\tcase NAND_OP_ADDR_INSTR:\n\t\t\twritel(OP_ADDR_BUSW(OP_BUSW_8) | OP_DUMMY_CYC(0x3F) |\n\t\t\t       OP_ADDR_BYTES(instr->ctx.addr.naddrs),\n\t\t\t       nfc->regs + SS_CTRL(0));\n\t\t\tret = mxic_nfc_data_xfer(nfc,\n\t\t\t\t\t\t instr->ctx.addr.addrs, NULL,\n\t\t\t\t\t\t instr->ctx.addr.naddrs);\n\t\t\tbreak;\n\n\t\tcase NAND_OP_DATA_IN_INSTR:\n\t\t\twritel(0x0, nfc->regs + ONFI_DIN_CNT(0));\n\t\t\twritel(OP_DATA_BUSW(OP_BUSW_8) | OP_DUMMY_CYC(0x3F) |\n\t\t\t       OP_READ, nfc->regs + SS_CTRL(0));\n\t\t\tret = mxic_nfc_data_xfer(nfc, NULL,\n\t\t\t\t\t\t instr->ctx.data.buf.in,\n\t\t\t\t\t\t instr->ctx.data.len);\n\t\t\tbreak;\n\n\t\tcase NAND_OP_DATA_OUT_INSTR:\n\t\t\twritel(instr->ctx.data.len,\n\t\t\t       nfc->regs + ONFI_DIN_CNT(0));\n\t\t\twritel(OP_DATA_BUSW(OP_BUSW_8) | OP_DUMMY_CYC(0x3F),\n\t\t\t       nfc->regs + SS_CTRL(0));\n\t\t\tret = mxic_nfc_data_xfer(nfc,\n\t\t\t\t\t\t instr->ctx.data.buf.out, NULL,\n\t\t\t\t\t\t instr->ctx.data.len);\n\t\t\tbreak;\n\n\t\tcase NAND_OP_WAITRDY_INSTR:\n\t\t\tret = mxic_nfc_wait_ready(chip);\n\t\t\tbreak;\n\t\t}\n\t}\n\tmxic_nfc_cs_disable(nfc);\n\n\treturn ret;\n}\n\nstatic int mxic_nfc_setup_interface(struct nand_chip *chip, int chipnr,\n\t\t\t\t    const struct nand_interface_config *conf)\n{\n\tstruct mxic_nand_ctlr *nfc = nand_get_controller_data(chip);\n\tconst struct nand_sdr_timings *sdr;\n\tunsigned long freq;\n\tint ret;\n\n\tsdr = nand_get_sdr_timings(conf);\n\tif (IS_ERR(sdr))\n\t\treturn PTR_ERR(sdr);\n\n\tif (chipnr == NAND_DATA_IFACE_CHECK_ONLY)\n\t\treturn 0;\n\n\tfreq = NSEC_PER_SEC / (sdr->tRC_min / 1000);\n\n\tret =  mxic_nfc_set_freq(nfc, freq);\n\tif (ret)\n\t\tdev_err(nfc->dev, \"set freq:%ld failed\\n\", freq);\n\n\tif (sdr->tRC_min < 30000)\n\t\twritel(DATA_STROB_EDO_EN, nfc->regs + DATA_STROB);\n\n\treturn 0;\n}\n\nstatic const struct nand_controller_ops mxic_nand_controller_ops = {\n\t.exec_op = mxic_nfc_exec_op,\n\t.setup_interface = mxic_nfc_setup_interface,\n};\n\nstatic int mxic_nfc_probe(struct platform_device *pdev)\n{\n\tstruct device_node *nand_np, *np = pdev->dev.of_node;\n\tstruct mtd_info *mtd;\n\tstruct mxic_nand_ctlr *nfc;\n\tstruct nand_chip *nand_chip;\n\tint err;\n\tint irq;\n\n\tnfc = devm_kzalloc(&pdev->dev, sizeof(struct mxic_nand_ctlr),\n\t\t\t   GFP_KERNEL);\n\tif (!nfc)\n\t\treturn -ENOMEM;\n\n\tnfc->ps_clk = devm_clk_get(&pdev->dev, \"ps\");\n\tif (IS_ERR(nfc->ps_clk))\n\t\treturn PTR_ERR(nfc->ps_clk);\n\n\tnfc->send_clk = devm_clk_get(&pdev->dev, \"send\");\n\tif (IS_ERR(nfc->send_clk))\n\t\treturn PTR_ERR(nfc->send_clk);\n\n\tnfc->send_dly_clk = devm_clk_get(&pdev->dev, \"send_dly\");\n\tif (IS_ERR(nfc->send_dly_clk))\n\t\treturn PTR_ERR(nfc->send_dly_clk);\n\n\tnfc->regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(nfc->regs))\n\t\treturn PTR_ERR(nfc->regs);\n\n\tnand_chip = &nfc->chip;\n\tmtd = nand_to_mtd(nand_chip);\n\tmtd->dev.parent = &pdev->dev;\n\n\tfor_each_child_of_node(np, nand_np)\n\t\tnand_set_flash_node(nand_chip, nand_np);\n\n\tnand_chip->priv = nfc;\n\tnfc->dev = &pdev->dev;\n\tnfc->controller.ops = &mxic_nand_controller_ops;\n\tnand_controller_init(&nfc->controller);\n\tnand_chip->controller = &nfc->controller;\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tmxic_nfc_hw_init(nfc);\n\n\terr = devm_request_irq(&pdev->dev, irq, mxic_nfc_isr,\n\t\t\t       0, \"mxic-nfc\", nfc);\n\tif (err)\n\t\tgoto fail;\n\n\terr = nand_scan(nand_chip, 1);\n\tif (err)\n\t\tgoto fail;\n\n\terr = mtd_device_register(mtd, NULL, 0);\n\tif (err)\n\t\tgoto fail;\n\n\tplatform_set_drvdata(pdev, nfc);\n\treturn 0;\n\nfail:\n\tmxic_nfc_clk_disable(nfc);\n\treturn err;\n}\n\nstatic void mxic_nfc_remove(struct platform_device *pdev)\n{\n\tstruct mxic_nand_ctlr *nfc = platform_get_drvdata(pdev);\n\tstruct nand_chip *chip = &nfc->chip;\n\tint ret;\n\n\tret = mtd_device_unregister(nand_to_mtd(chip));\n\tWARN_ON(ret);\n\tnand_cleanup(chip);\n\n\tmxic_nfc_clk_disable(nfc);\n}\n\nstatic const struct of_device_id mxic_nfc_of_ids[] = {\n\t{ .compatible = \"mxic,multi-itfc-v009-nand-controller\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, mxic_nfc_of_ids);\n\nstatic struct platform_driver mxic_nfc_driver = {\n\t.probe = mxic_nfc_probe,\n\t.remove_new = mxic_nfc_remove,\n\t.driver = {\n\t\t.name = \"mxic-nfc\",\n\t\t.of_match_table = mxic_nfc_of_ids,\n\t},\n};\nmodule_platform_driver(mxic_nfc_driver);\n\nMODULE_AUTHOR(\"Mason Yang <masonccyang@mxic.com.tw>\");\nMODULE_DESCRIPTION(\"Macronix raw NAND controller driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}