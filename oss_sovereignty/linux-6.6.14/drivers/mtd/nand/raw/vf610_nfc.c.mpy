{
  "module_name": "vf610_nfc.c",
  "hash_id": "1f0e1bf430324b9ec86001be70d3bd8936649de31ef2886f130cf08655eea0a5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/nand/raw/vf610_nfc.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/bitops.h>\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/mtd/mtd.h>\n#include <linux/mtd/rawnand.h>\n#include <linux/mtd/partitions.h>\n#include <linux/of_device.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/swab.h>\n\n#define\tDRV_NAME\t\t\"vf610_nfc\"\n\n \n#define NFC_FLASH_CMD1\t\t\t0x3F00\n#define NFC_FLASH_CMD2\t\t\t0x3F04\n#define NFC_COL_ADDR\t\t\t0x3F08\n#define NFC_ROW_ADDR\t\t\t0x3F0c\n#define NFC_ROW_ADDR_INC\t\t0x3F14\n#define NFC_FLASH_STATUS1\t\t0x3F18\n#define NFC_FLASH_STATUS2\t\t0x3F1c\n#define NFC_CACHE_SWAP\t\t\t0x3F28\n#define NFC_SECTOR_SIZE\t\t\t0x3F2c\n#define NFC_FLASH_CONFIG\t\t0x3F30\n#define NFC_IRQ_STATUS\t\t\t0x3F38\n\n \n#define NFC_MAIN_AREA(n)\t\t((n) *  0x1000)\n\n#define PAGE_2K\t\t\t\t0x0800\n#define OOB_64\t\t\t\t0x0040\n#define OOB_MAX\t\t\t\t0x0100\n\n \n#define COMMAND_CMD_BYTE1\t\tBIT(14)\n#define COMMAND_CAR_BYTE1\t\tBIT(13)\n#define COMMAND_CAR_BYTE2\t\tBIT(12)\n#define COMMAND_RAR_BYTE1\t\tBIT(11)\n#define COMMAND_RAR_BYTE2\t\tBIT(10)\n#define COMMAND_RAR_BYTE3\t\tBIT(9)\n#define COMMAND_NADDR_BYTES(x)\t\tGENMASK(13, 13 - (x) + 1)\n#define COMMAND_WRITE_DATA\t\tBIT(8)\n#define COMMAND_CMD_BYTE2\t\tBIT(7)\n#define COMMAND_RB_HANDSHAKE\t\tBIT(6)\n#define COMMAND_READ_DATA\t\tBIT(5)\n#define COMMAND_CMD_BYTE3\t\tBIT(4)\n#define COMMAND_READ_STATUS\t\tBIT(3)\n#define COMMAND_READ_ID\t\t\tBIT(2)\n\n \n#define ECC_BYPASS\t\t\t0\n#define ECC_45_BYTE\t\t\t6\n#define ECC_60_BYTE\t\t\t7\n\n \n\n \n#define CMD_BYTE2_MASK\t\t\t\t0xFF000000\n#define CMD_BYTE2_SHIFT\t\t\t\t24\n\n \n#define CMD_BYTE1_MASK\t\t\t\t0xFF000000\n#define CMD_BYTE1_SHIFT\t\t\t\t24\n#define CMD_CODE_MASK\t\t\t\t0x00FFFF00\n#define CMD_CODE_SHIFT\t\t\t\t8\n#define BUFNO_MASK\t\t\t\t0x00000006\n#define BUFNO_SHIFT\t\t\t\t1\n#define START_BIT\t\t\t\tBIT(0)\n\n \n#define COL_ADDR_MASK\t\t\t\t0x0000FFFF\n#define COL_ADDR_SHIFT\t\t\t\t0\n#define COL_ADDR(pos, val)\t\t\t(((val) & 0xFF) << (8 * (pos)))\n\n \n#define ROW_ADDR_MASK\t\t\t\t0x00FFFFFF\n#define ROW_ADDR_SHIFT\t\t\t\t0\n#define ROW_ADDR(pos, val)\t\t\t(((val) & 0xFF) << (8 * (pos)))\n\n#define ROW_ADDR_CHIP_SEL_RB_MASK\t\t0xF0000000\n#define ROW_ADDR_CHIP_SEL_RB_SHIFT\t\t28\n#define ROW_ADDR_CHIP_SEL_MASK\t\t\t0x0F000000\n#define ROW_ADDR_CHIP_SEL_SHIFT\t\t\t24\n\n \n#define STATUS_BYTE1_MASK\t\t\t0x000000FF\n\n \n#define CONFIG_ECC_SRAM_ADDR_MASK\t\t0x7FC00000\n#define CONFIG_ECC_SRAM_ADDR_SHIFT\t\t22\n#define CONFIG_ECC_SRAM_REQ_BIT\t\t\tBIT(21)\n#define CONFIG_DMA_REQ_BIT\t\t\tBIT(20)\n#define CONFIG_ECC_MODE_MASK\t\t\t0x000E0000\n#define CONFIG_ECC_MODE_SHIFT\t\t\t17\n#define CONFIG_FAST_FLASH_BIT\t\t\tBIT(16)\n#define CONFIG_16BIT\t\t\t\tBIT(7)\n#define CONFIG_BOOT_MODE_BIT\t\t\tBIT(6)\n#define CONFIG_ADDR_AUTO_INCR_BIT\t\tBIT(5)\n#define CONFIG_BUFNO_AUTO_INCR_BIT\t\tBIT(4)\n#define CONFIG_PAGE_CNT_MASK\t\t\t0xF\n#define CONFIG_PAGE_CNT_SHIFT\t\t\t0\n\n \n#define IDLE_IRQ_BIT\t\t\t\tBIT(29)\n#define IDLE_EN_BIT\t\t\t\tBIT(20)\n#define CMD_DONE_CLEAR_BIT\t\t\tBIT(18)\n#define IDLE_CLEAR_BIT\t\t\t\tBIT(17)\n\n \n#define ECC_SRAM_ADDR\t\t(PAGE_2K + OOB_MAX - 8)\n\n#define ECC_STATUS\t\t0x4\n#define ECC_STATUS_MASK\t\t0x80\n#define ECC_STATUS_ERR_COUNT\t0x3F\n\nenum vf610_nfc_variant {\n\tNFC_VFC610 = 1,\n};\n\nstruct vf610_nfc {\n\tstruct nand_controller base;\n\tstruct nand_chip chip;\n\tstruct device *dev;\n\tvoid __iomem *regs;\n\tstruct completion cmd_done;\n\t \n\tenum vf610_nfc_variant variant;\n\tstruct clk *clk;\n\t \n\tbool data_access;\n\tu32 ecc_mode;\n};\n\nstatic inline struct vf610_nfc *chip_to_nfc(struct nand_chip *chip)\n{\n\treturn container_of(chip, struct vf610_nfc, chip);\n}\n\nstatic inline u32 vf610_nfc_read(struct vf610_nfc *nfc, uint reg)\n{\n\treturn readl(nfc->regs + reg);\n}\n\nstatic inline void vf610_nfc_write(struct vf610_nfc *nfc, uint reg, u32 val)\n{\n\twritel(val, nfc->regs + reg);\n}\n\nstatic inline void vf610_nfc_set(struct vf610_nfc *nfc, uint reg, u32 bits)\n{\n\tvf610_nfc_write(nfc, reg, vf610_nfc_read(nfc, reg) | bits);\n}\n\nstatic inline void vf610_nfc_clear(struct vf610_nfc *nfc, uint reg, u32 bits)\n{\n\tvf610_nfc_write(nfc, reg, vf610_nfc_read(nfc, reg) & ~bits);\n}\n\nstatic inline void vf610_nfc_set_field(struct vf610_nfc *nfc, u32 reg,\n\t\t\t\t       u32 mask, u32 shift, u32 val)\n{\n\tvf610_nfc_write(nfc, reg,\n\t\t\t(vf610_nfc_read(nfc, reg) & (~mask)) | val << shift);\n}\n\nstatic inline bool vf610_nfc_kernel_is_little_endian(void)\n{\n#ifdef __LITTLE_ENDIAN\n\treturn true;\n#else\n\treturn false;\n#endif\n}\n\n \nstatic inline void vf610_nfc_rd_from_sram(void *dst, const void __iomem *src,\n\t\t\t\t\t  size_t len, bool fix_endian)\n{\n\tif (vf610_nfc_kernel_is_little_endian() && fix_endian) {\n\t\tunsigned int i;\n\n\t\tfor (i = 0; i < len; i += 4) {\n\t\t\tu32 val = swab32(__raw_readl(src + i));\n\n\t\t\tmemcpy(dst + i, &val, min(sizeof(val), len - i));\n\t\t}\n\t} else {\n\t\tmemcpy_fromio(dst, src, len);\n\t}\n}\n\n \nstatic inline void vf610_nfc_wr_to_sram(void __iomem *dst, const void *src,\n\t\t\t\t\tsize_t len, bool fix_endian)\n{\n\tif (vf610_nfc_kernel_is_little_endian() && fix_endian) {\n\t\tunsigned int i;\n\n\t\tfor (i = 0; i < len; i += 4) {\n\t\t\tu32 val;\n\n\t\t\tmemcpy(&val, src + i, min(sizeof(val), len - i));\n\t\t\t__raw_writel(swab32(val), dst + i);\n\t\t}\n\t} else {\n\t\tmemcpy_toio(dst, src, len);\n\t}\n}\n\n \nstatic inline void vf610_nfc_clear_status(struct vf610_nfc *nfc)\n{\n\tu32 tmp = vf610_nfc_read(nfc, NFC_IRQ_STATUS);\n\n\ttmp |= CMD_DONE_CLEAR_BIT | IDLE_CLEAR_BIT;\n\tvf610_nfc_write(nfc, NFC_IRQ_STATUS, tmp);\n}\n\nstatic void vf610_nfc_done(struct vf610_nfc *nfc)\n{\n\tunsigned long timeout = msecs_to_jiffies(100);\n\n\t \n\tvf610_nfc_set(nfc, NFC_IRQ_STATUS, IDLE_EN_BIT);\n\tvf610_nfc_set(nfc, NFC_FLASH_CMD2, START_BIT);\n\n\tif (!wait_for_completion_timeout(&nfc->cmd_done, timeout))\n\t\tdev_warn(nfc->dev, \"Timeout while waiting for BUSY.\\n\");\n\n\tvf610_nfc_clear_status(nfc);\n}\n\nstatic irqreturn_t vf610_nfc_irq(int irq, void *data)\n{\n\tstruct vf610_nfc *nfc = data;\n\n\tvf610_nfc_clear(nfc, NFC_IRQ_STATUS, IDLE_EN_BIT);\n\tcomplete(&nfc->cmd_done);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic inline void vf610_nfc_ecc_mode(struct vf610_nfc *nfc, int ecc_mode)\n{\n\tvf610_nfc_set_field(nfc, NFC_FLASH_CONFIG,\n\t\t\t    CONFIG_ECC_MODE_MASK,\n\t\t\t    CONFIG_ECC_MODE_SHIFT, ecc_mode);\n}\n\nstatic inline void vf610_nfc_run(struct vf610_nfc *nfc, u32 col, u32 row,\n\t\t\t\t u32 cmd1, u32 cmd2, u32 trfr_sz)\n{\n\tvf610_nfc_set_field(nfc, NFC_COL_ADDR, COL_ADDR_MASK,\n\t\t\t    COL_ADDR_SHIFT, col);\n\n\tvf610_nfc_set_field(nfc, NFC_ROW_ADDR, ROW_ADDR_MASK,\n\t\t\t    ROW_ADDR_SHIFT, row);\n\n\tvf610_nfc_write(nfc, NFC_SECTOR_SIZE, trfr_sz);\n\tvf610_nfc_write(nfc, NFC_FLASH_CMD1, cmd1);\n\tvf610_nfc_write(nfc, NFC_FLASH_CMD2, cmd2);\n\n\tdev_dbg(nfc->dev,\n\t\t\"col 0x%04x, row 0x%08x, cmd1 0x%08x, cmd2 0x%08x, len %d\\n\",\n\t\tcol, row, cmd1, cmd2, trfr_sz);\n\n\tvf610_nfc_done(nfc);\n}\n\nstatic inline const struct nand_op_instr *\nvf610_get_next_instr(const struct nand_subop *subop, int *op_id)\n{\n\tif (*op_id + 1 >= subop->ninstrs)\n\t\treturn NULL;\n\n\t(*op_id)++;\n\n\treturn &subop->instrs[*op_id];\n}\n\nstatic int vf610_nfc_cmd(struct nand_chip *chip,\n\t\t\t const struct nand_subop *subop)\n{\n\tconst struct nand_op_instr *instr;\n\tstruct vf610_nfc *nfc = chip_to_nfc(chip);\n\tint op_id = -1, trfr_sz = 0, offset = 0;\n\tu32 col = 0, row = 0, cmd1 = 0, cmd2 = 0, code = 0;\n\tbool force8bit = false;\n\n\t \n\tinstr = vf610_get_next_instr(subop, &op_id);\n\tif (!instr)\n\t\treturn -EINVAL;\n\n\tif (instr && instr->type == NAND_OP_CMD_INSTR) {\n\t\tcmd2 |= instr->ctx.cmd.opcode << CMD_BYTE1_SHIFT;\n\t\tcode |= COMMAND_CMD_BYTE1;\n\n\t\tinstr = vf610_get_next_instr(subop, &op_id);\n\t}\n\n\tif (instr && instr->type == NAND_OP_ADDR_INSTR) {\n\t\tint naddrs = nand_subop_get_num_addr_cyc(subop, op_id);\n\t\tint i = nand_subop_get_addr_start_off(subop, op_id);\n\n\t\tfor (; i < naddrs; i++) {\n\t\t\tu8 val = instr->ctx.addr.addrs[i];\n\n\t\t\tif (i < 2)\n\t\t\t\tcol |= COL_ADDR(i, val);\n\t\t\telse\n\t\t\t\trow |= ROW_ADDR(i - 2, val);\n\t\t}\n\t\tcode |= COMMAND_NADDR_BYTES(naddrs);\n\n\t\tinstr = vf610_get_next_instr(subop, &op_id);\n\t}\n\n\tif (instr && instr->type == NAND_OP_DATA_OUT_INSTR) {\n\t\ttrfr_sz = nand_subop_get_data_len(subop, op_id);\n\t\toffset = nand_subop_get_data_start_off(subop, op_id);\n\t\tforce8bit = instr->ctx.data.force_8bit;\n\n\t\t \n\t\tvf610_nfc_wr_to_sram(nfc->regs + NFC_MAIN_AREA(0) + offset,\n\t\t\t\t     instr->ctx.data.buf.out + offset,\n\t\t\t\t     trfr_sz, !nfc->data_access);\n\t\tcode |= COMMAND_WRITE_DATA;\n\n\t\tinstr = vf610_get_next_instr(subop, &op_id);\n\t}\n\n\tif (instr && instr->type == NAND_OP_CMD_INSTR) {\n\t\tcmd1 |= instr->ctx.cmd.opcode << CMD_BYTE2_SHIFT;\n\t\tcode |= COMMAND_CMD_BYTE2;\n\n\t\tinstr = vf610_get_next_instr(subop, &op_id);\n\t}\n\n\tif (instr && instr->type == NAND_OP_WAITRDY_INSTR) {\n\t\tcode |= COMMAND_RB_HANDSHAKE;\n\n\t\tinstr = vf610_get_next_instr(subop, &op_id);\n\t}\n\n\tif (instr && instr->type == NAND_OP_DATA_IN_INSTR) {\n\t\ttrfr_sz = nand_subop_get_data_len(subop, op_id);\n\t\toffset = nand_subop_get_data_start_off(subop, op_id);\n\t\tforce8bit = instr->ctx.data.force_8bit;\n\n\t\tcode |= COMMAND_READ_DATA;\n\t}\n\n\tif (force8bit && (chip->options & NAND_BUSWIDTH_16))\n\t\tvf610_nfc_clear(nfc, NFC_FLASH_CONFIG, CONFIG_16BIT);\n\n\tcmd2 |= code << CMD_CODE_SHIFT;\n\n\tvf610_nfc_run(nfc, col, row, cmd1, cmd2, trfr_sz);\n\n\tif (instr && instr->type == NAND_OP_DATA_IN_INSTR) {\n\t\t \n\t\tvf610_nfc_rd_from_sram(instr->ctx.data.buf.in + offset,\n\t\t\t\t       nfc->regs + NFC_MAIN_AREA(0) + offset,\n\t\t\t\t       trfr_sz, !nfc->data_access);\n\t}\n\n\tif (force8bit && (chip->options & NAND_BUSWIDTH_16))\n\t\tvf610_nfc_set(nfc, NFC_FLASH_CONFIG, CONFIG_16BIT);\n\n\treturn 0;\n}\n\nstatic const struct nand_op_parser vf610_nfc_op_parser = NAND_OP_PARSER(\n\tNAND_OP_PARSER_PATTERN(vf610_nfc_cmd,\n\t\tNAND_OP_PARSER_PAT_CMD_ELEM(true),\n\t\tNAND_OP_PARSER_PAT_ADDR_ELEM(true, 5),\n\t\tNAND_OP_PARSER_PAT_DATA_OUT_ELEM(true, PAGE_2K + OOB_MAX),\n\t\tNAND_OP_PARSER_PAT_CMD_ELEM(true),\n\t\tNAND_OP_PARSER_PAT_WAITRDY_ELEM(true)),\n\tNAND_OP_PARSER_PATTERN(vf610_nfc_cmd,\n\t\tNAND_OP_PARSER_PAT_CMD_ELEM(true),\n\t\tNAND_OP_PARSER_PAT_ADDR_ELEM(true, 5),\n\t\tNAND_OP_PARSER_PAT_CMD_ELEM(true),\n\t\tNAND_OP_PARSER_PAT_WAITRDY_ELEM(true),\n\t\tNAND_OP_PARSER_PAT_DATA_IN_ELEM(true, PAGE_2K + OOB_MAX)),\n\t);\n\n \nstatic void vf610_nfc_select_target(struct nand_chip *chip, unsigned int cs)\n{\n\tstruct vf610_nfc *nfc = chip_to_nfc(chip);\n\tu32 tmp;\n\n\t \n\tif (nfc->variant != NFC_VFC610)\n\t\treturn;\n\n\ttmp = vf610_nfc_read(nfc, NFC_ROW_ADDR);\n\ttmp &= ~(ROW_ADDR_CHIP_SEL_RB_MASK | ROW_ADDR_CHIP_SEL_MASK);\n\ttmp |= 1 << ROW_ADDR_CHIP_SEL_RB_SHIFT;\n\ttmp |= BIT(cs) << ROW_ADDR_CHIP_SEL_SHIFT;\n\n\tvf610_nfc_write(nfc, NFC_ROW_ADDR, tmp);\n}\n\nstatic int vf610_nfc_exec_op(struct nand_chip *chip,\n\t\t\t     const struct nand_operation *op,\n\t\t\t     bool check_only)\n{\n\tif (!check_only)\n\t\tvf610_nfc_select_target(chip, op->cs);\n\n\treturn nand_op_parser_exec_op(chip, &vf610_nfc_op_parser, op,\n\t\t\t\t      check_only);\n}\n\nstatic inline int vf610_nfc_correct_data(struct nand_chip *chip, uint8_t *dat,\n\t\t\t\t\t uint8_t *oob, int page)\n{\n\tstruct vf610_nfc *nfc = chip_to_nfc(chip);\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tu32 ecc_status_off = NFC_MAIN_AREA(0) + ECC_SRAM_ADDR + ECC_STATUS;\n\tu8 ecc_status;\n\tu8 ecc_count;\n\tint flips_threshold = nfc->chip.ecc.strength / 2;\n\n\tecc_status = vf610_nfc_read(nfc, ecc_status_off) & 0xff;\n\tecc_count = ecc_status & ECC_STATUS_ERR_COUNT;\n\n\tif (!(ecc_status & ECC_STATUS_MASK))\n\t\treturn ecc_count;\n\n\tnfc->data_access = true;\n\tnand_read_oob_op(&nfc->chip, page, 0, oob, mtd->oobsize);\n\tnfc->data_access = false;\n\n\t \n\treturn nand_check_erased_ecc_chunk(dat, nfc->chip.ecc.size, oob,\n\t\t\t\t\t   mtd->oobsize, NULL, 0,\n\t\t\t\t\t   flips_threshold);\n}\n\nstatic void vf610_nfc_fill_row(struct nand_chip *chip, int page, u32 *code,\n\t\t\t       u32 *row)\n{\n\t*row = ROW_ADDR(0, page & 0xff) | ROW_ADDR(1, page >> 8);\n\t*code |= COMMAND_RAR_BYTE1 | COMMAND_RAR_BYTE2;\n\n\tif (chip->options & NAND_ROW_ADDR_3) {\n\t\t*row |= ROW_ADDR(2, page >> 16);\n\t\t*code |= COMMAND_RAR_BYTE3;\n\t}\n}\n\nstatic int vf610_nfc_read_page(struct nand_chip *chip, uint8_t *buf,\n\t\t\t       int oob_required, int page)\n{\n\tstruct vf610_nfc *nfc = chip_to_nfc(chip);\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tint trfr_sz = mtd->writesize + mtd->oobsize;\n\tu32 row = 0, cmd1 = 0, cmd2 = 0, code = 0;\n\tint stat;\n\n\tvf610_nfc_select_target(chip, chip->cur_cs);\n\n\tcmd2 |= NAND_CMD_READ0 << CMD_BYTE1_SHIFT;\n\tcode |= COMMAND_CMD_BYTE1 | COMMAND_CAR_BYTE1 | COMMAND_CAR_BYTE2;\n\n\tvf610_nfc_fill_row(chip, page, &code, &row);\n\n\tcmd1 |= NAND_CMD_READSTART << CMD_BYTE2_SHIFT;\n\tcode |= COMMAND_CMD_BYTE2 | COMMAND_RB_HANDSHAKE | COMMAND_READ_DATA;\n\n\tcmd2 |= code << CMD_CODE_SHIFT;\n\n\tvf610_nfc_ecc_mode(nfc, nfc->ecc_mode);\n\tvf610_nfc_run(nfc, 0, row, cmd1, cmd2, trfr_sz);\n\tvf610_nfc_ecc_mode(nfc, ECC_BYPASS);\n\n\t \n\tvf610_nfc_rd_from_sram(buf, nfc->regs + NFC_MAIN_AREA(0),\n\t\t\t       mtd->writesize, false);\n\tif (oob_required)\n\t\tvf610_nfc_rd_from_sram(chip->oob_poi,\n\t\t\t\t       nfc->regs + NFC_MAIN_AREA(0) +\n\t\t\t\t\t\t   mtd->writesize,\n\t\t\t\t       mtd->oobsize, false);\n\n\tstat = vf610_nfc_correct_data(chip, buf, chip->oob_poi, page);\n\n\tif (stat < 0) {\n\t\tmtd->ecc_stats.failed++;\n\t\treturn 0;\n\t} else {\n\t\tmtd->ecc_stats.corrected += stat;\n\t\treturn stat;\n\t}\n}\n\nstatic int vf610_nfc_write_page(struct nand_chip *chip, const uint8_t *buf,\n\t\t\t\tint oob_required, int page)\n{\n\tstruct vf610_nfc *nfc = chip_to_nfc(chip);\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tint trfr_sz = mtd->writesize + mtd->oobsize;\n\tu32 row = 0, cmd1 = 0, cmd2 = 0, code = 0;\n\tu8 status;\n\tint ret;\n\n\tvf610_nfc_select_target(chip, chip->cur_cs);\n\n\tcmd2 |= NAND_CMD_SEQIN << CMD_BYTE1_SHIFT;\n\tcode |= COMMAND_CMD_BYTE1 | COMMAND_CAR_BYTE1 | COMMAND_CAR_BYTE2;\n\n\tvf610_nfc_fill_row(chip, page, &code, &row);\n\n\tcmd1 |= NAND_CMD_PAGEPROG << CMD_BYTE2_SHIFT;\n\tcode |= COMMAND_CMD_BYTE2 | COMMAND_WRITE_DATA;\n\n\t \n\tvf610_nfc_wr_to_sram(nfc->regs + NFC_MAIN_AREA(0), buf,\n\t\t\t     mtd->writesize, false);\n\n\tcode |= COMMAND_RB_HANDSHAKE;\n\tcmd2 |= code << CMD_CODE_SHIFT;\n\n\tvf610_nfc_ecc_mode(nfc, nfc->ecc_mode);\n\tvf610_nfc_run(nfc, 0, row, cmd1, cmd2, trfr_sz);\n\tvf610_nfc_ecc_mode(nfc, ECC_BYPASS);\n\n\tret = nand_status_op(chip, &status);\n\tif (ret)\n\t\treturn ret;\n\n\tif (status & NAND_STATUS_FAIL)\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nstatic int vf610_nfc_read_page_raw(struct nand_chip *chip, u8 *buf,\n\t\t\t\t   int oob_required, int page)\n{\n\tstruct vf610_nfc *nfc = chip_to_nfc(chip);\n\tint ret;\n\n\tnfc->data_access = true;\n\tret = nand_read_page_raw(chip, buf, oob_required, page);\n\tnfc->data_access = false;\n\n\treturn ret;\n}\n\nstatic int vf610_nfc_write_page_raw(struct nand_chip *chip, const u8 *buf,\n\t\t\t\t    int oob_required, int page)\n{\n\tstruct vf610_nfc *nfc = chip_to_nfc(chip);\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tint ret;\n\n\tnfc->data_access = true;\n\tret = nand_prog_page_begin_op(chip, page, 0, buf, mtd->writesize);\n\tif (!ret && oob_required)\n\t\tret = nand_write_data_op(chip, chip->oob_poi, mtd->oobsize,\n\t\t\t\t\t false);\n\tnfc->data_access = false;\n\n\tif (ret)\n\t\treturn ret;\n\n\treturn nand_prog_page_end_op(chip);\n}\n\nstatic int vf610_nfc_read_oob(struct nand_chip *chip, int page)\n{\n\tstruct vf610_nfc *nfc = chip_to_nfc(chip);\n\tint ret;\n\n\tnfc->data_access = true;\n\tret = nand_read_oob_std(chip, page);\n\tnfc->data_access = false;\n\n\treturn ret;\n}\n\nstatic int vf610_nfc_write_oob(struct nand_chip *chip, int page)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tstruct vf610_nfc *nfc = chip_to_nfc(chip);\n\tint ret;\n\n\tnfc->data_access = true;\n\tret = nand_prog_page_begin_op(chip, page, mtd->writesize,\n\t\t\t\t      chip->oob_poi, mtd->oobsize);\n\tnfc->data_access = false;\n\n\tif (ret)\n\t\treturn ret;\n\n\treturn nand_prog_page_end_op(chip);\n}\n\nstatic const struct of_device_id vf610_nfc_dt_ids[] = {\n\t{ .compatible = \"fsl,vf610-nfc\", .data = (void *)NFC_VFC610 },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, vf610_nfc_dt_ids);\n\nstatic void vf610_nfc_preinit_controller(struct vf610_nfc *nfc)\n{\n\tvf610_nfc_clear(nfc, NFC_FLASH_CONFIG, CONFIG_16BIT);\n\tvf610_nfc_clear(nfc, NFC_FLASH_CONFIG, CONFIG_ADDR_AUTO_INCR_BIT);\n\tvf610_nfc_clear(nfc, NFC_FLASH_CONFIG, CONFIG_BUFNO_AUTO_INCR_BIT);\n\tvf610_nfc_clear(nfc, NFC_FLASH_CONFIG, CONFIG_BOOT_MODE_BIT);\n\tvf610_nfc_clear(nfc, NFC_FLASH_CONFIG, CONFIG_DMA_REQ_BIT);\n\tvf610_nfc_set(nfc, NFC_FLASH_CONFIG, CONFIG_FAST_FLASH_BIT);\n\tvf610_nfc_ecc_mode(nfc, ECC_BYPASS);\n\n\t \n\tvf610_nfc_set_field(nfc, NFC_FLASH_CONFIG, CONFIG_PAGE_CNT_MASK,\n\t\t\t    CONFIG_PAGE_CNT_SHIFT, 1);\n}\n\nstatic void vf610_nfc_init_controller(struct vf610_nfc *nfc)\n{\n\tif (nfc->chip.options & NAND_BUSWIDTH_16)\n\t\tvf610_nfc_set(nfc, NFC_FLASH_CONFIG, CONFIG_16BIT);\n\telse\n\t\tvf610_nfc_clear(nfc, NFC_FLASH_CONFIG, CONFIG_16BIT);\n\n\tif (nfc->chip.ecc.engine_type == NAND_ECC_ENGINE_TYPE_ON_HOST) {\n\t\t \n\t\tvf610_nfc_set_field(nfc, NFC_FLASH_CONFIG,\n\t\t\t\t    CONFIG_ECC_SRAM_ADDR_MASK,\n\t\t\t\t    CONFIG_ECC_SRAM_ADDR_SHIFT,\n\t\t\t\t    ECC_SRAM_ADDR >> 3);\n\n\t\t \n\t\tvf610_nfc_set(nfc, NFC_FLASH_CONFIG, CONFIG_ECC_SRAM_REQ_BIT);\n\t}\n}\n\nstatic int vf610_nfc_attach_chip(struct nand_chip *chip)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tstruct vf610_nfc *nfc = chip_to_nfc(chip);\n\n\tvf610_nfc_init_controller(nfc);\n\n\t \n\tif (chip->bbt_options & NAND_BBT_USE_FLASH)\n\t\tchip->bbt_options |= NAND_BBT_NO_OOB;\n\n\t \n\tif (mtd->writesize + mtd->oobsize > PAGE_2K + OOB_MAX - 8) {\n\t\tdev_err(nfc->dev, \"Unsupported flash page size\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\tif (chip->ecc.engine_type != NAND_ECC_ENGINE_TYPE_ON_HOST)\n\t\treturn 0;\n\n\tif (mtd->writesize != PAGE_2K && mtd->oobsize < 64) {\n\t\tdev_err(nfc->dev, \"Unsupported flash with hwecc\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\tif (chip->ecc.size != mtd->writesize) {\n\t\tdev_err(nfc->dev, \"Step size needs to be page size\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\t \n\tif (mtd->oobsize > 64)\n\t\tmtd->oobsize = 64;\n\n\t \n\tmtd_set_ooblayout(mtd, nand_get_large_page_ooblayout());\n\tif (chip->ecc.strength == 32) {\n\t\tnfc->ecc_mode = ECC_60_BYTE;\n\t\tchip->ecc.bytes = 60;\n\t} else if (chip->ecc.strength == 24) {\n\t\tnfc->ecc_mode = ECC_45_BYTE;\n\t\tchip->ecc.bytes = 45;\n\t} else {\n\t\tdev_err(nfc->dev, \"Unsupported ECC strength\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\tchip->ecc.read_page = vf610_nfc_read_page;\n\tchip->ecc.write_page = vf610_nfc_write_page;\n\tchip->ecc.read_page_raw = vf610_nfc_read_page_raw;\n\tchip->ecc.write_page_raw = vf610_nfc_write_page_raw;\n\tchip->ecc.read_oob = vf610_nfc_read_oob;\n\tchip->ecc.write_oob = vf610_nfc_write_oob;\n\n\tchip->ecc.size = PAGE_2K;\n\n\treturn 0;\n}\n\nstatic const struct nand_controller_ops vf610_nfc_controller_ops = {\n\t.attach_chip = vf610_nfc_attach_chip,\n\t.exec_op = vf610_nfc_exec_op,\n\n};\n\nstatic int vf610_nfc_probe(struct platform_device *pdev)\n{\n\tstruct vf610_nfc *nfc;\n\tstruct mtd_info *mtd;\n\tstruct nand_chip *chip;\n\tstruct device_node *child;\n\tconst struct of_device_id *of_id;\n\tint err;\n\tint irq;\n\n\tnfc = devm_kzalloc(&pdev->dev, sizeof(*nfc), GFP_KERNEL);\n\tif (!nfc)\n\t\treturn -ENOMEM;\n\n\tnfc->dev = &pdev->dev;\n\tchip = &nfc->chip;\n\tmtd = nand_to_mtd(chip);\n\n\tmtd->owner = THIS_MODULE;\n\tmtd->dev.parent = nfc->dev;\n\tmtd->name = DRV_NAME;\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tnfc->regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(nfc->regs))\n\t\treturn PTR_ERR(nfc->regs);\n\n\tnfc->clk = devm_clk_get_enabled(&pdev->dev, NULL);\n\tif (IS_ERR(nfc->clk)) {\n\t\tdev_err(nfc->dev, \"Unable to get and enable clock!\\n\");\n\t\treturn PTR_ERR(nfc->clk);\n\t}\n\n\tof_id = of_match_device(vf610_nfc_dt_ids, &pdev->dev);\n\tif (!of_id)\n\t\treturn -ENODEV;\n\n\tnfc->variant = (uintptr_t)of_id->data;\n\n\tfor_each_available_child_of_node(nfc->dev->of_node, child) {\n\t\tif (of_device_is_compatible(child, \"fsl,vf610-nfc-nandcs\")) {\n\n\t\t\tif (nand_get_flash_node(chip)) {\n\t\t\t\tdev_err(nfc->dev,\n\t\t\t\t\t\"Only one NAND chip supported!\\n\");\n\t\t\t\tof_node_put(child);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tnand_set_flash_node(chip, child);\n\t\t}\n\t}\n\n\tif (!nand_get_flash_node(chip)) {\n\t\tdev_err(nfc->dev, \"NAND chip sub-node missing!\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tchip->options |= NAND_NO_SUBPAGE_WRITE;\n\n\tinit_completion(&nfc->cmd_done);\n\n\terr = devm_request_irq(nfc->dev, irq, vf610_nfc_irq, 0, DRV_NAME, nfc);\n\tif (err) {\n\t\tdev_err(nfc->dev, \"Error requesting IRQ!\\n\");\n\t\treturn err;\n\t}\n\n\tvf610_nfc_preinit_controller(nfc);\n\n\tnand_controller_init(&nfc->base);\n\tnfc->base.ops = &vf610_nfc_controller_ops;\n\tchip->controller = &nfc->base;\n\n\t \n\terr = nand_scan(chip, 1);\n\tif (err)\n\t\treturn err;\n\n\tplatform_set_drvdata(pdev, nfc);\n\n\t \n\terr = mtd_device_register(mtd, NULL, 0);\n\tif (err)\n\t\tgoto err_cleanup_nand;\n\treturn 0;\n\nerr_cleanup_nand:\n\tnand_cleanup(chip);\n\treturn err;\n}\n\nstatic void vf610_nfc_remove(struct platform_device *pdev)\n{\n\tstruct vf610_nfc *nfc = platform_get_drvdata(pdev);\n\tstruct nand_chip *chip = &nfc->chip;\n\tint ret;\n\n\tret = mtd_device_unregister(nand_to_mtd(chip));\n\tWARN_ON(ret);\n\tnand_cleanup(chip);\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int vf610_nfc_suspend(struct device *dev)\n{\n\tstruct vf610_nfc *nfc = dev_get_drvdata(dev);\n\n\tclk_disable_unprepare(nfc->clk);\n\treturn 0;\n}\n\nstatic int vf610_nfc_resume(struct device *dev)\n{\n\tstruct vf610_nfc *nfc = dev_get_drvdata(dev);\n\tint err;\n\n\terr = clk_prepare_enable(nfc->clk);\n\tif (err)\n\t\treturn err;\n\n\tvf610_nfc_preinit_controller(nfc);\n\tvf610_nfc_init_controller(nfc);\n\treturn 0;\n}\n#endif\n\nstatic SIMPLE_DEV_PM_OPS(vf610_nfc_pm_ops, vf610_nfc_suspend, vf610_nfc_resume);\n\nstatic struct platform_driver vf610_nfc_driver = {\n\t.driver\t\t= {\n\t\t.name\t= DRV_NAME,\n\t\t.of_match_table = vf610_nfc_dt_ids,\n\t\t.pm\t= &vf610_nfc_pm_ops,\n\t},\n\t.probe\t\t= vf610_nfc_probe,\n\t.remove_new\t= vf610_nfc_remove,\n};\n\nmodule_platform_driver(vf610_nfc_driver);\n\nMODULE_AUTHOR(\"Stefan Agner <stefan.agner@toradex.com>\");\nMODULE_DESCRIPTION(\"Freescale VF610/MPC5125 NFC MTD NAND driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}