{
  "module_name": "nand_macronix.c",
  "hash_id": "31a43561bd72776dba425d8cc2d5b9a74ac4e4985e07dd7ee6bed6e4f23cb8ce",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/nand/raw/nand_macronix.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include \"linux/delay.h\"\n#include \"internals.h\"\n\n#define MACRONIX_READ_RETRY_BIT BIT(0)\n#define MACRONIX_NUM_READ_RETRY_MODES 6\n\n#define ONFI_FEATURE_ADDR_MXIC_PROTECTION 0xA0\n#define MXIC_BLOCK_PROTECTION_ALL_LOCK 0x38\n#define MXIC_BLOCK_PROTECTION_ALL_UNLOCK 0x0\n\n#define ONFI_FEATURE_ADDR_MXIC_RANDOMIZER 0xB0\n#define MACRONIX_RANDOMIZER_BIT BIT(1)\n#define MACRONIX_RANDOMIZER_ENPGM BIT(0)\n#define MACRONIX_RANDOMIZER_RANDEN BIT(1)\n#define MACRONIX_RANDOMIZER_RANDOPT BIT(2)\n#define MACRONIX_RANDOMIZER_MODE_ENTER\t\\\n\t(MACRONIX_RANDOMIZER_ENPGM |\t\\\n\t MACRONIX_RANDOMIZER_RANDEN |\t\\\n\t MACRONIX_RANDOMIZER_RANDOPT)\n#define MACRONIX_RANDOMIZER_MODE_EXIT\t\\\n\t(MACRONIX_RANDOMIZER_RANDEN |\t\\\n\t MACRONIX_RANDOMIZER_RANDOPT)\n\n#define MXIC_CMD_POWER_DOWN 0xB9\n\n#define ONFI_FEATURE_ADDR_30LFXG18AC_OTP\t0x90\n#define MACRONIX_30LFXG18AC_OTP_START_PAGE\t2\n#define MACRONIX_30LFXG18AC_OTP_PAGES\t\t30\n#define MACRONIX_30LFXG18AC_OTP_PAGE_SIZE\t2112\n#define MACRONIX_30LFXG18AC_OTP_SIZE_BYTES\t\\\n\t(MACRONIX_30LFXG18AC_OTP_PAGES *\t\\\n\t MACRONIX_30LFXG18AC_OTP_PAGE_SIZE)\n\n#define MACRONIX_30LFXG18AC_OTP_EN\t\tBIT(0)\n\nstruct nand_onfi_vendor_macronix {\n\tu8 reserved;\n\tu8 reliability_func;\n} __packed;\n\nstatic int macronix_nand_setup_read_retry(struct nand_chip *chip, int mode)\n{\n\tu8 feature[ONFI_SUBFEATURE_PARAM_LEN];\n\n\tif (!chip->parameters.supports_set_get_features ||\n\t    !test_bit(ONFI_FEATURE_ADDR_READ_RETRY,\n\t\t      chip->parameters.set_feature_list))\n\t\treturn -ENOTSUPP;\n\n\tfeature[0] = mode;\n\treturn nand_set_features(chip, ONFI_FEATURE_ADDR_READ_RETRY, feature);\n}\n\nstatic int macronix_nand_randomizer_check_enable(struct nand_chip *chip)\n{\n\tu8 feature[ONFI_SUBFEATURE_PARAM_LEN];\n\tint ret;\n\n\tret = nand_get_features(chip, ONFI_FEATURE_ADDR_MXIC_RANDOMIZER,\n\t\t\t\tfeature);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (feature[0])\n\t\treturn feature[0];\n\n\tfeature[0] = MACRONIX_RANDOMIZER_MODE_ENTER;\n\tret = nand_set_features(chip, ONFI_FEATURE_ADDR_MXIC_RANDOMIZER,\n\t\t\t\tfeature);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tfeature[0] = 0x0;\n\tret = nand_prog_page_op(chip, 0, 0, feature, 1);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = nand_get_features(chip, ONFI_FEATURE_ADDR_MXIC_RANDOMIZER,\n\t\t\t\tfeature);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tfeature[0] &= MACRONIX_RANDOMIZER_MODE_EXIT;\n\tret = nand_set_features(chip, ONFI_FEATURE_ADDR_MXIC_RANDOMIZER,\n\t\t\t\tfeature);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic void macronix_nand_onfi_init(struct nand_chip *chip)\n{\n\tstruct nand_parameters *p = &chip->parameters;\n\tstruct nand_onfi_vendor_macronix *mxic;\n\tstruct device_node *dn = nand_get_flash_node(chip);\n\tint rand_otp;\n\tint ret;\n\n\tif (!p->onfi)\n\t\treturn;\n\n\trand_otp = of_property_read_bool(dn, \"mxic,enable-randomizer-otp\");\n\n\tmxic = (struct nand_onfi_vendor_macronix *)p->onfi->vendor;\n\t \n\tif (rand_otp && chip->options & NAND_NO_SUBPAGE_WRITE &&\n\t    mxic->reliability_func & MACRONIX_RANDOMIZER_BIT) {\n\t\tif (p->supports_set_get_features) {\n\t\t\tbitmap_set(p->set_feature_list,\n\t\t\t\t   ONFI_FEATURE_ADDR_MXIC_RANDOMIZER, 1);\n\t\t\tbitmap_set(p->get_feature_list,\n\t\t\t\t   ONFI_FEATURE_ADDR_MXIC_RANDOMIZER, 1);\n\t\t\tret = macronix_nand_randomizer_check_enable(chip);\n\t\t\tif (ret < 0) {\n\t\t\t\tbitmap_clear(p->set_feature_list,\n\t\t\t\t\t     ONFI_FEATURE_ADDR_MXIC_RANDOMIZER,\n\t\t\t\t\t     1);\n\t\t\t\tbitmap_clear(p->get_feature_list,\n\t\t\t\t\t     ONFI_FEATURE_ADDR_MXIC_RANDOMIZER,\n\t\t\t\t\t     1);\n\t\t\t\tpr_info(\"Macronix NAND randomizer failed\\n\");\n\t\t\t} else {\n\t\t\t\tpr_info(\"Macronix NAND randomizer enabled\\n\");\n\t\t\t}\n\t\t}\n\t}\n\n\tif ((mxic->reliability_func & MACRONIX_READ_RETRY_BIT) == 0)\n\t\treturn;\n\n\tchip->read_retries = MACRONIX_NUM_READ_RETRY_MODES;\n\tchip->ops.setup_read_retry = macronix_nand_setup_read_retry;\n\n\tif (p->supports_set_get_features) {\n\t\tbitmap_set(p->set_feature_list,\n\t\t\t   ONFI_FEATURE_ADDR_READ_RETRY, 1);\n\t\tbitmap_set(p->get_feature_list,\n\t\t\t   ONFI_FEATURE_ADDR_READ_RETRY, 1);\n\t}\n}\n\n \nstatic void macronix_nand_fix_broken_get_timings(struct nand_chip *chip)\n{\n\tint i;\n\tstatic const char * const broken_get_timings[] = {\n\t\t\"MX30LF1G18AC\",\n\t\t\"MX30LF1G28AC\",\n\t\t\"MX30LF2G18AC\",\n\t\t\"MX30LF2G28AC\",\n\t\t\"MX30LF4G18AC\",\n\t\t\"MX30LF4G28AC\",\n\t\t\"MX60LF8G18AC\",\n\t\t\"MX30UF1G18AC\",\n\t\t\"MX30UF1G16AC\",\n\t\t\"MX30UF2G18AC\",\n\t\t\"MX30UF2G16AC\",\n\t\t\"MX30UF4G18AC\",\n\t\t\"MX30UF4G16AC\",\n\t\t\"MX30UF4G28AC\",\n\t};\n\n\tif (!chip->parameters.supports_set_get_features)\n\t\treturn;\n\n\ti = match_string(broken_get_timings, ARRAY_SIZE(broken_get_timings),\n\t\t\t chip->parameters.model);\n\tif (i < 0)\n\t\treturn;\n\n\tbitmap_clear(chip->parameters.get_feature_list,\n\t\t     ONFI_FEATURE_ADDR_TIMING_MODE, 1);\n\tbitmap_clear(chip->parameters.set_feature_list,\n\t\t     ONFI_FEATURE_ADDR_TIMING_MODE, 1);\n}\n\n \nstatic int mxic_nand_lock(struct nand_chip *chip, loff_t ofs, uint64_t len)\n{\n\tu8 feature[ONFI_SUBFEATURE_PARAM_LEN];\n\tint ret;\n\n\tfeature[0] = MXIC_BLOCK_PROTECTION_ALL_LOCK;\n\tnand_select_target(chip, 0);\n\tret = nand_set_features(chip, ONFI_FEATURE_ADDR_MXIC_PROTECTION,\n\t\t\t\tfeature);\n\tnand_deselect_target(chip);\n\tif (ret)\n\t\tpr_err(\"%s all blocks failed\\n\", __func__);\n\n\treturn ret;\n}\n\nstatic int mxic_nand_unlock(struct nand_chip *chip, loff_t ofs, uint64_t len)\n{\n\tu8 feature[ONFI_SUBFEATURE_PARAM_LEN];\n\tint ret;\n\n\tfeature[0] = MXIC_BLOCK_PROTECTION_ALL_UNLOCK;\n\tnand_select_target(chip, 0);\n\tret = nand_set_features(chip, ONFI_FEATURE_ADDR_MXIC_PROTECTION,\n\t\t\t\tfeature);\n\tnand_deselect_target(chip);\n\tif (ret)\n\t\tpr_err(\"%s all blocks failed\\n\", __func__);\n\n\treturn ret;\n}\n\nstatic void macronix_nand_block_protection_support(struct nand_chip *chip)\n{\n\tu8 feature[ONFI_SUBFEATURE_PARAM_LEN];\n\tint ret;\n\n\tbitmap_set(chip->parameters.get_feature_list,\n\t\t   ONFI_FEATURE_ADDR_MXIC_PROTECTION, 1);\n\n\tfeature[0] = MXIC_BLOCK_PROTECTION_ALL_UNLOCK;\n\tnand_select_target(chip, 0);\n\tret = nand_get_features(chip, ONFI_FEATURE_ADDR_MXIC_PROTECTION,\n\t\t\t\tfeature);\n\tnand_deselect_target(chip);\n\tif (ret || feature[0] != MXIC_BLOCK_PROTECTION_ALL_LOCK) {\n\t\tif (ret)\n\t\t\tpr_err(\"Block protection check failed\\n\");\n\n\t\tbitmap_clear(chip->parameters.get_feature_list,\n\t\t\t     ONFI_FEATURE_ADDR_MXIC_PROTECTION, 1);\n\t\treturn;\n\t}\n\n\tbitmap_set(chip->parameters.set_feature_list,\n\t\t   ONFI_FEATURE_ADDR_MXIC_PROTECTION, 1);\n\n\tchip->ops.lock_area = mxic_nand_lock;\n\tchip->ops.unlock_area = mxic_nand_unlock;\n}\n\nstatic int nand_power_down_op(struct nand_chip *chip)\n{\n\tint ret;\n\n\tif (nand_has_exec_op(chip)) {\n\t\tstruct nand_op_instr instrs[] = {\n\t\t\tNAND_OP_CMD(MXIC_CMD_POWER_DOWN, 0),\n\t\t};\n\n\t\tstruct nand_operation op = NAND_OPERATION(chip->cur_cs, instrs);\n\n\t\tret = nand_exec_op(chip, &op);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t} else {\n\t\tchip->legacy.cmdfunc(chip, MXIC_CMD_POWER_DOWN, -1, -1);\n\t}\n\n\treturn 0;\n}\n\nstatic int mxic_nand_suspend(struct nand_chip *chip)\n{\n\tint ret;\n\n\tnand_select_target(chip, 0);\n\tret = nand_power_down_op(chip);\n\tif (ret < 0)\n\t\tpr_err(\"Suspending MXIC NAND chip failed (%d)\\n\", ret);\n\tnand_deselect_target(chip);\n\n\treturn ret;\n}\n\nstatic void mxic_nand_resume(struct nand_chip *chip)\n{\n\t \n\tnand_select_target(chip, 0);\n\tnand_power_down_op(chip);\n\t \n\tusleep_range(35, 100);\n\tnand_deselect_target(chip);\n}\n\nstatic void macronix_nand_deep_power_down_support(struct nand_chip *chip)\n{\n\tint i;\n\tstatic const char * const deep_power_down_dev[] = {\n\t\t\"MX30UF1G28AD\",\n\t\t\"MX30UF2G28AD\",\n\t\t\"MX30UF4G28AD\",\n\t};\n\n\ti = match_string(deep_power_down_dev, ARRAY_SIZE(deep_power_down_dev),\n\t\t\t chip->parameters.model);\n\tif (i < 0)\n\t\treturn;\n\n\tchip->ops.suspend = mxic_nand_suspend;\n\tchip->ops.resume = mxic_nand_resume;\n}\n\nstatic int macronix_30lfxg18ac_get_otp_info(struct mtd_info *mtd, size_t len,\n\t\t\t\t\t    size_t *retlen,\n\t\t\t\t\t    struct otp_info *buf)\n{\n\tif (len < sizeof(*buf))\n\t\treturn -EINVAL;\n\n\t \n\tbuf->locked = 0;\n\tbuf->start = 0;\n\tbuf->length = MACRONIX_30LFXG18AC_OTP_SIZE_BYTES;\n\n\t*retlen = sizeof(*buf);\n\n\treturn 0;\n}\n\nstatic int macronix_30lfxg18ac_otp_enable(struct nand_chip *nand)\n{\n\tu8 feature_buf[ONFI_SUBFEATURE_PARAM_LEN] = { 0 };\n\n\tfeature_buf[0] = MACRONIX_30LFXG18AC_OTP_EN;\n\treturn nand_set_features(nand, ONFI_FEATURE_ADDR_30LFXG18AC_OTP,\n\t\t\t\t feature_buf);\n}\n\nstatic int macronix_30lfxg18ac_otp_disable(struct nand_chip *nand)\n{\n\tu8 feature_buf[ONFI_SUBFEATURE_PARAM_LEN] = { 0 };\n\n\treturn nand_set_features(nand, ONFI_FEATURE_ADDR_30LFXG18AC_OTP,\n\t\t\t\t feature_buf);\n}\n\nstatic int __macronix_30lfxg18ac_rw_otp(struct mtd_info *mtd,\n\t\t\t\t\tloff_t offs_in_flash,\n\t\t\t\t\tsize_t len, size_t *retlen,\n\t\t\t\t\tu_char *buf, bool write)\n{\n\tstruct nand_chip *nand;\n\tsize_t bytes_handled;\n\toff_t offs_in_page;\n\tu64 page;\n\tint ret;\n\n\tnand = mtd_to_nand(mtd);\n\tnand_select_target(nand, 0);\n\n\tret = macronix_30lfxg18ac_otp_enable(nand);\n\tif (ret)\n\t\tgoto out_otp;\n\n\tpage = offs_in_flash;\n\t \n\toffs_in_page = do_div(page, MACRONIX_30LFXG18AC_OTP_PAGE_SIZE);\n\tbytes_handled = 0;\n\n\twhile (bytes_handled < len &&\n\t       page < MACRONIX_30LFXG18AC_OTP_PAGES) {\n\t\tsize_t bytes_to_handle;\n\t\tu64 phys_page = page + MACRONIX_30LFXG18AC_OTP_START_PAGE;\n\n\t\tbytes_to_handle = min_t(size_t, len - bytes_handled,\n\t\t\t\t\tMACRONIX_30LFXG18AC_OTP_PAGE_SIZE -\n\t\t\t\t\toffs_in_page);\n\n\t\tif (write)\n\t\t\tret = nand_prog_page_op(nand, phys_page, offs_in_page,\n\t\t\t\t\t\t&buf[bytes_handled], bytes_to_handle);\n\t\telse\n\t\t\tret = nand_read_page_op(nand, phys_page, offs_in_page,\n\t\t\t\t\t\t&buf[bytes_handled], bytes_to_handle);\n\t\tif (ret)\n\t\t\tgoto out_otp;\n\n\t\tbytes_handled += bytes_to_handle;\n\t\toffs_in_page = 0;\n\t\tpage++;\n\t}\n\n\t*retlen = bytes_handled;\n\nout_otp:\n\tif (ret)\n\t\tdev_err(&mtd->dev, \"failed to perform OTP IO: %i\\n\", ret);\n\n\tret = macronix_30lfxg18ac_otp_disable(nand);\n\tif (ret)\n\t\tdev_err(&mtd->dev, \"failed to leave OTP mode after %s\\n\",\n\t\t\twrite ? \"write\" : \"read\");\n\n\tnand_deselect_target(nand);\n\n\treturn ret;\n}\n\nstatic int macronix_30lfxg18ac_write_otp(struct mtd_info *mtd, loff_t to,\n\t\t\t\t\t size_t len, size_t *rlen,\n\t\t\t\t\t const u_char *buf)\n{\n\treturn __macronix_30lfxg18ac_rw_otp(mtd, to, len, rlen, (u_char *)buf,\n\t\t\t\t\t    true);\n}\n\nstatic int macronix_30lfxg18ac_read_otp(struct mtd_info *mtd, loff_t from,\n\t\t\t\t\tsize_t len, size_t *rlen,\n\t\t\t\t\tu_char *buf)\n{\n\treturn __macronix_30lfxg18ac_rw_otp(mtd, from, len, rlen, buf, false);\n}\n\nstatic int macronix_30lfxg18ac_lock_otp(struct mtd_info *mtd, loff_t from,\n\t\t\t\t\tsize_t len)\n{\n\t \n\treturn -EOPNOTSUPP;\n}\n\nstatic void macronix_nand_setup_otp(struct nand_chip *chip)\n{\n\tstatic const char * const supported_otp_models[] = {\n\t\t\"MX30LF1G18AC\",\n\t\t\"MX30LF2G18AC\",\n\t\t\"MX30LF4G18AC\",\n\t};\n\tstruct mtd_info *mtd;\n\n\tif (match_string(supported_otp_models,\n\t\t\t ARRAY_SIZE(supported_otp_models),\n\t\t\t chip->parameters.model) < 0)\n\t\treturn;\n\n\tif (!chip->parameters.supports_set_get_features)\n\t\treturn;\n\n\tbitmap_set(chip->parameters.get_feature_list,\n\t\t   ONFI_FEATURE_ADDR_30LFXG18AC_OTP, 1);\n\tbitmap_set(chip->parameters.set_feature_list,\n\t\t   ONFI_FEATURE_ADDR_30LFXG18AC_OTP, 1);\n\n\tmtd = nand_to_mtd(chip);\n\tmtd->_get_user_prot_info = macronix_30lfxg18ac_get_otp_info;\n\tmtd->_read_user_prot_reg = macronix_30lfxg18ac_read_otp;\n\tmtd->_write_user_prot_reg = macronix_30lfxg18ac_write_otp;\n\tmtd->_lock_user_prot_reg = macronix_30lfxg18ac_lock_otp;\n}\n\nstatic int macronix_nand_init(struct nand_chip *chip)\n{\n\tif (nand_is_slc(chip))\n\t\tchip->options |= NAND_BBM_FIRSTPAGE | NAND_BBM_SECONDPAGE;\n\n\tmacronix_nand_fix_broken_get_timings(chip);\n\tmacronix_nand_onfi_init(chip);\n\tmacronix_nand_block_protection_support(chip);\n\tmacronix_nand_deep_power_down_support(chip);\n\tmacronix_nand_setup_otp(chip);\n\n\treturn 0;\n}\n\nconst struct nand_manufacturer_ops macronix_nand_manuf_ops = {\n\t.init = macronix_nand_init,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}