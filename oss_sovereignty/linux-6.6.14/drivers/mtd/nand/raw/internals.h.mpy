{
  "module_name": "internals.h",
  "hash_id": "ab23500e98edabd4f8bb6471ff672c662202aec253582cc681331ee7840e3c14",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/nand/raw/internals.h",
  "human_readable_source": " \n \n\n#ifndef __LINUX_RAWNAND_INTERNALS\n#define __LINUX_RAWNAND_INTERNALS\n\n#include <linux/mtd/rawnand.h>\n\n \n#define NAND_MFR_AMD\t\t0x01\n#define NAND_MFR_ATO\t\t0x9b\n#define NAND_MFR_EON\t\t0x92\n#define NAND_MFR_ESMT\t\t0xc8\n#define NAND_MFR_FUJITSU\t0x04\n#define NAND_MFR_HYNIX\t\t0xad\n#define NAND_MFR_INTEL\t\t0x89\n#define NAND_MFR_MACRONIX\t0xc2\n#define NAND_MFR_MICRON\t\t0x2c\n#define NAND_MFR_NATIONAL\t0x8f\n#define NAND_MFR_RENESAS\t0x07\n#define NAND_MFR_SAMSUNG\t0xec\n#define NAND_MFR_SANDISK\t0x45\n#define NAND_MFR_STMICRO\t0x20\n \n#define NAND_MFR_TOSHIBA\t0x98\n#define NAND_MFR_WINBOND\t0xef\n\n \nstruct nand_manufacturer_ops {\n\tvoid (*detect)(struct nand_chip *chip);\n\tint (*init)(struct nand_chip *chip);\n\tvoid (*cleanup)(struct nand_chip *chip);\n\tvoid (*fixup_onfi_param_page)(struct nand_chip *chip,\n\t\t\t\t      struct nand_onfi_params *p);\n};\n\n \nstruct nand_manufacturer_desc {\n\tint id;\n\tchar *name;\n\tconst struct nand_manufacturer_ops *ops;\n};\n\n\nextern struct nand_flash_dev nand_flash_ids[];\n\nextern const struct nand_manufacturer_ops amd_nand_manuf_ops;\nextern const struct nand_manufacturer_ops esmt_nand_manuf_ops;\nextern const struct nand_manufacturer_ops hynix_nand_manuf_ops;\nextern const struct nand_manufacturer_ops macronix_nand_manuf_ops;\nextern const struct nand_manufacturer_ops micron_nand_manuf_ops;\nextern const struct nand_manufacturer_ops samsung_nand_manuf_ops;\nextern const struct nand_manufacturer_ops sandisk_nand_manuf_ops;\nextern const struct nand_manufacturer_ops toshiba_nand_manuf_ops;\n\n \nextern const struct mtd_pairing_scheme dist3_pairing_scheme;\n\n \nconst struct nand_manufacturer_desc *nand_get_manufacturer_desc(u8 id);\nint nand_bbm_get_next_page(struct nand_chip *chip, int page);\nint nand_markbad_bbm(struct nand_chip *chip, loff_t ofs);\nint nand_erase_nand(struct nand_chip *chip, struct erase_info *instr,\n\t\t    int allowbbt);\nvoid onfi_fill_interface_config(struct nand_chip *chip,\n\t\t\t\tstruct nand_interface_config *iface,\n\t\t\t\tenum nand_interface_type type,\n\t\t\t\tunsigned int timing_mode);\nunsigned int\nonfi_find_closest_sdr_mode(const struct nand_sdr_timings *spec_timings);\nunsigned int\nonfi_find_closest_nvddr_mode(const struct nand_nvddr_timings *spec_timings);\nint nand_choose_best_sdr_timings(struct nand_chip *chip,\n\t\t\t\t struct nand_interface_config *iface,\n\t\t\t\t struct nand_sdr_timings *spec_timings);\nint nand_choose_best_nvddr_timings(struct nand_chip *chip,\n\t\t\t\t   struct nand_interface_config *iface,\n\t\t\t\t   struct nand_nvddr_timings *spec_timings);\nconst struct nand_interface_config *nand_get_reset_interface_config(void);\nint nand_get_features(struct nand_chip *chip, int addr, u8 *subfeature_param);\nint nand_set_features(struct nand_chip *chip, int addr, u8 *subfeature_param);\nint nand_read_page_raw_notsupp(struct nand_chip *chip, u8 *buf,\n\t\t\t       int oob_required, int page);\nint nand_write_page_raw_notsupp(struct nand_chip *chip, const u8 *buf,\n\t\t\t\tint oob_required, int page);\nint nand_exit_status_op(struct nand_chip *chip);\nint nand_read_param_page_op(struct nand_chip *chip, u8 page, void *buf,\n\t\t\t    unsigned int len);\nvoid nand_decode_ext_id(struct nand_chip *chip);\nvoid panic_nand_wait(struct nand_chip *chip, unsigned long timeo);\nvoid sanitize_string(uint8_t *s, size_t len);\n\nstatic inline bool nand_has_exec_op(struct nand_chip *chip)\n{\n\tif (!chip->controller || !chip->controller->ops ||\n\t    !chip->controller->ops->exec_op)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic inline int nand_check_op(struct nand_chip *chip,\n\t\t\t\tconst struct nand_operation *op)\n{\n\tif (!nand_has_exec_op(chip))\n\t\treturn 0;\n\n\treturn chip->controller->ops->exec_op(chip, op, true);\n}\n\nstatic inline int nand_exec_op(struct nand_chip *chip,\n\t\t\t       const struct nand_operation *op)\n{\n\tif (!nand_has_exec_op(chip))\n\t\treturn -ENOTSUPP;\n\n\tif (WARN_ON(op->cs >= nanddev_ntargets(&chip->base)))\n\t\treturn -EINVAL;\n\n\treturn chip->controller->ops->exec_op(chip, op, false);\n}\n\nstatic inline bool nand_controller_can_setup_interface(struct nand_chip *chip)\n{\n\tif (!chip->controller || !chip->controller->ops ||\n\t    !chip->controller->ops->setup_interface)\n\t\treturn false;\n\n\tif (chip->options & NAND_KEEP_TIMINGS)\n\t\treturn false;\n\n\treturn true;\n}\n\n \nint nand_markbad_bbt(struct nand_chip *chip, loff_t offs);\nint nand_isreserved_bbt(struct nand_chip *chip, loff_t offs);\nint nand_isbad_bbt(struct nand_chip *chip, loff_t offs, int allowbbt);\n\n \nvoid nand_legacy_set_defaults(struct nand_chip *chip);\nvoid nand_legacy_adjust_cmdfunc(struct nand_chip *chip);\nint nand_legacy_check_hooks(struct nand_chip *chip);\n\n \nu16 onfi_crc16(u16 crc, u8 const *p, size_t len);\nint nand_onfi_detect(struct nand_chip *chip);\n\n \nint nand_jedec_detect(struct nand_chip *chip);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}