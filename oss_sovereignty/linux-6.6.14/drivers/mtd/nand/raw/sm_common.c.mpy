{
  "module_name": "sm_common.c",
  "hash_id": "08606f0ddf9ecba05d0187fd875a603a26cfa00b294c10a8add243be0de99c92",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/nand/raw/sm_common.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n#include <linux/mtd/rawnand.h>\n#include <linux/module.h>\n#include <linux/sizes.h>\n#include \"sm_common.h\"\n\nstatic int oob_sm_ooblayout_ecc(struct mtd_info *mtd, int section,\n\t\t\t\tstruct mtd_oob_region *oobregion)\n{\n\tif (section > 1)\n\t\treturn -ERANGE;\n\n\toobregion->length = 3;\n\toobregion->offset = ((section + 1) * 8) - 3;\n\n\treturn 0;\n}\n\nstatic int oob_sm_ooblayout_free(struct mtd_info *mtd, int section,\n\t\t\t\t struct mtd_oob_region *oobregion)\n{\n\tswitch (section) {\n\tcase 0:\n\t\t \n\t\toobregion->offset = 0;\n\t\toobregion->length = 4;\n\t\tbreak;\n\tcase 1:\n\t\t \n\t\toobregion->offset = 6;\n\t\toobregion->length = 2;\n\t\tbreak;\n\tcase 2:\n\t\t \n\t\toobregion->offset = 11;\n\t\toobregion->length = 2;\n\t\tbreak;\n\tdefault:\n\t\treturn -ERANGE;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct mtd_ooblayout_ops oob_sm_ops = {\n\t.ecc = oob_sm_ooblayout_ecc,\n\t.free = oob_sm_ooblayout_free,\n};\n\n \n \n \n \n \n\nstatic int oob_sm_small_ooblayout_ecc(struct mtd_info *mtd, int section,\n\t\t\t\t      struct mtd_oob_region *oobregion)\n{\n\tif (section)\n\t\treturn -ERANGE;\n\n\toobregion->length = 3;\n\toobregion->offset = 0;\n\n\treturn 0;\n}\n\nstatic int oob_sm_small_ooblayout_free(struct mtd_info *mtd, int section,\n\t\t\t\t       struct mtd_oob_region *oobregion)\n{\n\tswitch (section) {\n\tcase 0:\n\t\t \n\t\toobregion->offset = 3;\n\t\toobregion->length = 2;\n\t\tbreak;\n\tcase 1:\n\t\t \n\t\toobregion->offset = 6;\n\t\toobregion->length = 2;\n\t\tbreak;\n\tdefault:\n\t\treturn -ERANGE;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct mtd_ooblayout_ops oob_sm_small_ops = {\n\t.ecc = oob_sm_small_ooblayout_ecc,\n\t.free = oob_sm_small_ooblayout_free,\n};\n\nstatic int sm_block_markbad(struct nand_chip *chip, loff_t ofs)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tstruct mtd_oob_ops ops = { };\n\tstruct sm_oob oob;\n\tint ret;\n\n\tmemset(&oob, -1, SM_OOB_SIZE);\n\toob.block_status = 0x0F;\n\n\t \n\tops.mode = MTD_OPS_PLACE_OOB;\n\tops.ooboffs = 0;\n\tops.ooblen = mtd->oobsize;\n\tops.oobbuf = (void *)&oob;\n\tops.datbuf = NULL;\n\n\n\tret = mtd_write_oob(mtd, ofs, &ops);\n\tif (ret < 0 || ops.oobretlen != SM_OOB_SIZE) {\n\t\tpr_notice(\"sm_common: can't mark sector at %i as bad\\n\",\n\t\t\t  (int)ofs);\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic struct nand_flash_dev nand_smartmedia_flash_ids[] = {\n\tLEGACY_ID_NAND(\"SmartMedia 2MiB 3,3V ROM\",   0x5d, 2,   SZ_8K, NAND_ROM),\n\tLEGACY_ID_NAND(\"SmartMedia 4MiB 3,3V\",       0xe3, 4,   SZ_8K, 0),\n\tLEGACY_ID_NAND(\"SmartMedia 4MiB 3,3/5V\",     0xe5, 4,   SZ_8K, 0),\n\tLEGACY_ID_NAND(\"SmartMedia 4MiB 5V\",         0x6b, 4,   SZ_8K, 0),\n\tLEGACY_ID_NAND(\"SmartMedia 4MiB 3,3V ROM\",   0xd5, 4,   SZ_8K, NAND_ROM),\n\tLEGACY_ID_NAND(\"SmartMedia 8MiB 3,3V\",       0xe6, 8,   SZ_8K, 0),\n\tLEGACY_ID_NAND(\"SmartMedia 8MiB 3,3V ROM\",   0xd6, 8,   SZ_8K, NAND_ROM),\n\tLEGACY_ID_NAND(\"SmartMedia 16MiB 3,3V\",      0x73, 16,  SZ_16K, 0),\n\tLEGACY_ID_NAND(\"SmartMedia 16MiB 3,3V ROM\",  0x57, 16,  SZ_16K, NAND_ROM),\n\tLEGACY_ID_NAND(\"SmartMedia 32MiB 3,3V\",      0x75, 32,  SZ_16K, 0),\n\tLEGACY_ID_NAND(\"SmartMedia 32MiB 3,3V ROM\",  0x58, 32,  SZ_16K, NAND_ROM),\n\tLEGACY_ID_NAND(\"SmartMedia 64MiB 3,3V\",      0x76, 64,  SZ_16K, 0),\n\tLEGACY_ID_NAND(\"SmartMedia 64MiB 3,3V ROM\",  0xd9, 64,  SZ_16K, NAND_ROM),\n\tLEGACY_ID_NAND(\"SmartMedia 128MiB 3,3V\",     0x79, 128, SZ_16K, 0),\n\tLEGACY_ID_NAND(\"SmartMedia 128MiB 3,3V ROM\", 0xda, 128, SZ_16K, NAND_ROM),\n\tLEGACY_ID_NAND(\"SmartMedia 256MiB 3, 3V\",    0x71, 256, SZ_16K, 0),\n\tLEGACY_ID_NAND(\"SmartMedia 256MiB 3,3V ROM\", 0x5b, 256, SZ_16K, NAND_ROM),\n\t{NULL}\n};\n\nstatic struct nand_flash_dev nand_xd_flash_ids[] = {\n\tLEGACY_ID_NAND(\"xD 16MiB 3,3V\",  0x73, 16,   SZ_16K, 0),\n\tLEGACY_ID_NAND(\"xD 32MiB 3,3V\",  0x75, 32,   SZ_16K, 0),\n\tLEGACY_ID_NAND(\"xD 64MiB 3,3V\",  0x76, 64,   SZ_16K, 0),\n\tLEGACY_ID_NAND(\"xD 128MiB 3,3V\", 0x79, 128,  SZ_16K, 0),\n\tLEGACY_ID_NAND(\"xD 256MiB 3,3V\", 0x71, 256,  SZ_16K, NAND_BROKEN_XD),\n\tLEGACY_ID_NAND(\"xD 512MiB 3,3V\", 0xdc, 512,  SZ_16K, NAND_BROKEN_XD),\n\tLEGACY_ID_NAND(\"xD 1GiB 3,3V\",   0xd3, 1024, SZ_16K, NAND_BROKEN_XD),\n\tLEGACY_ID_NAND(\"xD 2GiB 3,3V\",   0xd5, 2048, SZ_16K, NAND_BROKEN_XD),\n\t{NULL}\n};\n\nstatic int sm_attach_chip(struct nand_chip *chip)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\n\t \n\tchip->badblockpos = 0x05;\n\tchip->badblockbits = 7;\n\tchip->legacy.block_markbad = sm_block_markbad;\n\n\t \n\tif (mtd->writesize == SM_SECTOR_SIZE)\n\t\tmtd_set_ooblayout(mtd, &oob_sm_ops);\n\telse if (mtd->writesize == SM_SMALL_PAGE)\n\t\tmtd_set_ooblayout(mtd, &oob_sm_small_ops);\n\telse\n\t\treturn -ENODEV;\n\n\treturn 0;\n}\n\nstatic const struct nand_controller_ops sm_controller_ops = {\n\t.attach_chip = sm_attach_chip,\n};\n\nint sm_register_device(struct mtd_info *mtd, int smartmedia)\n{\n\tstruct nand_chip *chip = mtd_to_nand(mtd);\n\tstruct nand_flash_dev *flash_ids;\n\tint ret;\n\n\tchip->options |= NAND_SKIP_BBTSCAN;\n\n\t \n\tchip->legacy.dummy_controller.ops = &sm_controller_ops;\n\tflash_ids = smartmedia ? nand_smartmedia_flash_ids : nand_xd_flash_ids;\n\tret = nand_scan_with_ids(chip, 1, flash_ids);\n\tif (ret)\n\t\treturn ret;\n\n\tret = mtd_device_register(mtd, NULL, 0);\n\tif (ret)\n\t\tnand_cleanup(chip);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(sm_register_device);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Maxim Levitsky <maximlevitsky@gmail.com>\");\nMODULE_DESCRIPTION(\"Common SmartMedia/xD functions\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}