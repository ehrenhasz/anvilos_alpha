{
  "module_name": "ams-delta.c",
  "hash_id": "096b64da464c30da96d6e9350c9f16af254eec8a118c8357bf9eef9df4d12e05",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/nand/raw/ams-delta.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/gpio/consumer.h>\n#include <linux/mtd/mtd.h>\n#include <linux/mtd/nand-gpio.h>\n#include <linux/mtd/rawnand.h>\n#include <linux/mtd/partitions.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/sizes.h>\n\n \nstruct gpio_nand {\n\tstruct nand_controller\tbase;\n\tstruct nand_chip\tnand_chip;\n\tstruct gpio_desc\t*gpiod_rdy;\n\tstruct gpio_desc\t*gpiod_nce;\n\tstruct gpio_desc\t*gpiod_nre;\n\tstruct gpio_desc\t*gpiod_nwp;\n\tstruct gpio_desc\t*gpiod_nwe;\n\tstruct gpio_desc\t*gpiod_ale;\n\tstruct gpio_desc\t*gpiod_cle;\n\tstruct gpio_descs\t*data_gpiods;\n\tbool\t\t\tdata_in;\n\tunsigned int\t\ttRP;\n\tunsigned int\t\ttWP;\n\tu8\t\t\t(*io_read)(struct gpio_nand *this);\n\tvoid\t\t\t(*io_write)(struct gpio_nand *this, u8 byte);\n};\n\nstatic void gpio_nand_write_commit(struct gpio_nand *priv)\n{\n\tgpiod_set_value(priv->gpiod_nwe, 1);\n\tndelay(priv->tWP);\n\tgpiod_set_value(priv->gpiod_nwe, 0);\n}\n\nstatic void gpio_nand_io_write(struct gpio_nand *priv, u8 byte)\n{\n\tstruct gpio_descs *data_gpiods = priv->data_gpiods;\n\tDECLARE_BITMAP(values, BITS_PER_TYPE(byte)) = { byte, };\n\n\tgpiod_set_raw_array_value(data_gpiods->ndescs, data_gpiods->desc,\n\t\t\t\t  data_gpiods->info, values);\n\n\tgpio_nand_write_commit(priv);\n}\n\nstatic void gpio_nand_dir_output(struct gpio_nand *priv, u8 byte)\n{\n\tstruct gpio_descs *data_gpiods = priv->data_gpiods;\n\tDECLARE_BITMAP(values, BITS_PER_TYPE(byte)) = { byte, };\n\tint i;\n\n\tfor (i = 0; i < data_gpiods->ndescs; i++)\n\t\tgpiod_direction_output_raw(data_gpiods->desc[i],\n\t\t\t\t\t   test_bit(i, values));\n\n\tgpio_nand_write_commit(priv);\n\n\tpriv->data_in = false;\n}\n\nstatic u8 gpio_nand_io_read(struct gpio_nand *priv)\n{\n\tu8 res;\n\tstruct gpio_descs *data_gpiods = priv->data_gpiods;\n\tDECLARE_BITMAP(values, BITS_PER_TYPE(res)) = { 0, };\n\n\tgpiod_set_value(priv->gpiod_nre, 1);\n\tndelay(priv->tRP);\n\n\tgpiod_get_raw_array_value(data_gpiods->ndescs, data_gpiods->desc,\n\t\t\t\t  data_gpiods->info, values);\n\n\tgpiod_set_value(priv->gpiod_nre, 0);\n\n\tres = values[0];\n\treturn res;\n}\n\nstatic void gpio_nand_dir_input(struct gpio_nand *priv)\n{\n\tstruct gpio_descs *data_gpiods = priv->data_gpiods;\n\tint i;\n\n\tfor (i = 0; i < data_gpiods->ndescs; i++)\n\t\tgpiod_direction_input(data_gpiods->desc[i]);\n\n\tpriv->data_in = true;\n}\n\nstatic void gpio_nand_write_buf(struct gpio_nand *priv, const u8 *buf, int len)\n{\n\tint i = 0;\n\n\tif (len > 0 && priv->data_in)\n\t\tgpio_nand_dir_output(priv, buf[i++]);\n\n\twhile (i < len)\n\t\tpriv->io_write(priv, buf[i++]);\n}\n\nstatic void gpio_nand_read_buf(struct gpio_nand *priv, u8 *buf, int len)\n{\n\tint i;\n\n\tif (priv->data_gpiods && !priv->data_in)\n\t\tgpio_nand_dir_input(priv);\n\n\tfor (i = 0; i < len; i++)\n\t\tbuf[i] = priv->io_read(priv);\n}\n\nstatic void gpio_nand_ctrl_cs(struct gpio_nand *priv, bool assert)\n{\n\tgpiod_set_value(priv->gpiod_nce, assert);\n}\n\nstatic int gpio_nand_exec_op(struct nand_chip *this,\n\t\t\t     const struct nand_operation *op, bool check_only)\n{\n\tstruct gpio_nand *priv = nand_get_controller_data(this);\n\tconst struct nand_op_instr *instr;\n\tint ret = 0;\n\n\tif (check_only)\n\t\treturn 0;\n\n\tgpio_nand_ctrl_cs(priv, 1);\n\n\tfor (instr = op->instrs; instr < op->instrs + op->ninstrs; instr++) {\n\t\tswitch (instr->type) {\n\t\tcase NAND_OP_CMD_INSTR:\n\t\t\tgpiod_set_value(priv->gpiod_cle, 1);\n\t\t\tgpio_nand_write_buf(priv, &instr->ctx.cmd.opcode, 1);\n\t\t\tgpiod_set_value(priv->gpiod_cle, 0);\n\t\t\tbreak;\n\n\t\tcase NAND_OP_ADDR_INSTR:\n\t\t\tgpiod_set_value(priv->gpiod_ale, 1);\n\t\t\tgpio_nand_write_buf(priv, instr->ctx.addr.addrs,\n\t\t\t\t\t    instr->ctx.addr.naddrs);\n\t\t\tgpiod_set_value(priv->gpiod_ale, 0);\n\t\t\tbreak;\n\n\t\tcase NAND_OP_DATA_IN_INSTR:\n\t\t\tgpio_nand_read_buf(priv, instr->ctx.data.buf.in,\n\t\t\t\t\t   instr->ctx.data.len);\n\t\t\tbreak;\n\n\t\tcase NAND_OP_DATA_OUT_INSTR:\n\t\t\tgpio_nand_write_buf(priv, instr->ctx.data.buf.out,\n\t\t\t\t\t    instr->ctx.data.len);\n\t\t\tbreak;\n\n\t\tcase NAND_OP_WAITRDY_INSTR:\n\t\t\tret = priv->gpiod_rdy ?\n\t\t\t      nand_gpio_waitrdy(this, priv->gpiod_rdy,\n\t\t\t\t\t\tinstr->ctx.waitrdy.timeout_ms) :\n\t\t\t      nand_soft_waitrdy(this,\n\t\t\t\t\t\tinstr->ctx.waitrdy.timeout_ms);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\tgpio_nand_ctrl_cs(priv, 0);\n\n\treturn ret;\n}\n\nstatic int gpio_nand_setup_interface(struct nand_chip *this, int csline,\n\t\t\t\t     const struct nand_interface_config *cf)\n{\n\tstruct gpio_nand *priv = nand_get_controller_data(this);\n\tconst struct nand_sdr_timings *sdr = nand_get_sdr_timings(cf);\n\tstruct device *dev = &nand_to_mtd(this)->dev;\n\n\tif (IS_ERR(sdr))\n\t\treturn PTR_ERR(sdr);\n\n\tif (csline == NAND_DATA_IFACE_CHECK_ONLY)\n\t\treturn 0;\n\n\tif (priv->gpiod_nre) {\n\t\tpriv->tRP = DIV_ROUND_UP(sdr->tRP_min, 1000);\n\t\tdev_dbg(dev, \"using %u ns read pulse width\\n\", priv->tRP);\n\t}\n\n\tpriv->tWP = DIV_ROUND_UP(sdr->tWP_min, 1000);\n\tdev_dbg(dev, \"using %u ns write pulse width\\n\", priv->tWP);\n\n\treturn 0;\n}\n\nstatic int gpio_nand_attach_chip(struct nand_chip *chip)\n{\n\tif (chip->ecc.engine_type == NAND_ECC_ENGINE_TYPE_SOFT &&\n\t    chip->ecc.algo == NAND_ECC_ALGO_UNKNOWN)\n\t\tchip->ecc.algo = NAND_ECC_ALGO_HAMMING;\n\n\treturn 0;\n}\n\nstatic const struct nand_controller_ops gpio_nand_ops = {\n\t.exec_op = gpio_nand_exec_op,\n\t.attach_chip = gpio_nand_attach_chip,\n\t.setup_interface = gpio_nand_setup_interface,\n};\n\n \nstatic int gpio_nand_probe(struct platform_device *pdev)\n{\n\tstruct gpio_nand_platdata *pdata = dev_get_platdata(&pdev->dev);\n\tconst struct mtd_partition *partitions = NULL;\n\tint num_partitions = 0;\n\tstruct gpio_nand *priv;\n\tstruct nand_chip *this;\n\tstruct mtd_info *mtd;\n\tint (*probe)(struct platform_device *pdev, struct gpio_nand *priv);\n\tint err = 0;\n\n\tif (pdata) {\n\t\tpartitions = pdata->parts;\n\t\tnum_partitions = pdata->num_parts;\n\t}\n\n\t \n\tpriv = devm_kzalloc(&pdev->dev, sizeof(struct gpio_nand),\n\t\t\t    GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tthis = &priv->nand_chip;\n\n\tmtd = nand_to_mtd(this);\n\tmtd->dev.parent = &pdev->dev;\n\n\tnand_set_controller_data(this, priv);\n\tnand_set_flash_node(this, pdev->dev.of_node);\n\n\tpriv->gpiod_rdy = devm_gpiod_get_optional(&pdev->dev, \"rdy\", GPIOD_IN);\n\tif (IS_ERR(priv->gpiod_rdy)) {\n\t\terr = PTR_ERR(priv->gpiod_rdy);\n\t\tdev_warn(&pdev->dev, \"RDY GPIO request failed (%d)\\n\", err);\n\t\treturn err;\n\t}\n\n\tplatform_set_drvdata(pdev, priv);\n\n\t \n\tpriv->gpiod_nwp = devm_gpiod_get_optional(&pdev->dev, \"nwp\",\n\t\t\t\t\t\t  GPIOD_OUT_HIGH);\n\tif (IS_ERR(priv->gpiod_nwp)) {\n\t\terr = PTR_ERR(priv->gpiod_nwp);\n\t\tdev_err(&pdev->dev, \"NWP GPIO request failed (%d)\\n\", err);\n\t\treturn err;\n\t}\n\n\tpriv->gpiod_nce = devm_gpiod_get_optional(&pdev->dev, \"nce\",\n\t\t\t\t\t\t  GPIOD_OUT_LOW);\n\tif (IS_ERR(priv->gpiod_nce)) {\n\t\terr = PTR_ERR(priv->gpiod_nce);\n\t\tdev_err(&pdev->dev, \"NCE GPIO request failed (%d)\\n\", err);\n\t\treturn err;\n\t}\n\n\tpriv->gpiod_nre = devm_gpiod_get_optional(&pdev->dev, \"nre\",\n\t\t\t\t\t\t  GPIOD_OUT_LOW);\n\tif (IS_ERR(priv->gpiod_nre)) {\n\t\terr = PTR_ERR(priv->gpiod_nre);\n\t\tdev_err(&pdev->dev, \"NRE GPIO request failed (%d)\\n\", err);\n\t\treturn err;\n\t}\n\n\tpriv->gpiod_nwe = devm_gpiod_get_optional(&pdev->dev, \"nwe\",\n\t\t\t\t\t\t  GPIOD_OUT_LOW);\n\tif (IS_ERR(priv->gpiod_nwe)) {\n\t\terr = PTR_ERR(priv->gpiod_nwe);\n\t\tdev_err(&pdev->dev, \"NWE GPIO request failed (%d)\\n\", err);\n\t\treturn err;\n\t}\n\n\tpriv->gpiod_ale = devm_gpiod_get(&pdev->dev, \"ale\", GPIOD_OUT_LOW);\n\tif (IS_ERR(priv->gpiod_ale)) {\n\t\terr = PTR_ERR(priv->gpiod_ale);\n\t\tdev_err(&pdev->dev, \"ALE GPIO request failed (%d)\\n\", err);\n\t\treturn err;\n\t}\n\n\tpriv->gpiod_cle = devm_gpiod_get(&pdev->dev, \"cle\", GPIOD_OUT_LOW);\n\tif (IS_ERR(priv->gpiod_cle)) {\n\t\terr = PTR_ERR(priv->gpiod_cle);\n\t\tdev_err(&pdev->dev, \"CLE GPIO request failed (%d)\\n\", err);\n\t\treturn err;\n\t}\n\n\t \n\tpriv->data_gpiods = devm_gpiod_get_array_optional(&pdev->dev, \"data\",\n\t\t\t\t\t\t\t  GPIOD_IN);\n\tif (IS_ERR(priv->data_gpiods)) {\n\t\terr = PTR_ERR(priv->data_gpiods);\n\t\tdev_err(&pdev->dev, \"data GPIO request failed: %d\\n\", err);\n\t\treturn err;\n\t}\n\tif (priv->data_gpiods) {\n\t\tif (!priv->gpiod_nwe) {\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"mandatory NWE pin not provided by platform\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\n\t\tpriv->io_read = gpio_nand_io_read;\n\t\tpriv->io_write = gpio_nand_io_write;\n\t\tpriv->data_in = true;\n\t}\n\n\tif (pdev->id_entry)\n\t\tprobe = (void *) pdev->id_entry->driver_data;\n\telse\n\t\tprobe = of_device_get_match_data(&pdev->dev);\n\tif (probe)\n\t\terr = probe(pdev, priv);\n\tif (err)\n\t\treturn err;\n\n\tif (!priv->io_read || !priv->io_write) {\n\t\tdev_err(&pdev->dev, \"incomplete device configuration\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tpriv->base.ops = &gpio_nand_ops;\n\tnand_controller_init(&priv->base);\n\tthis->controller = &priv->base;\n\n\t \n\t \n\tgpiod_set_value(priv->gpiod_nwp, 0);\n\n\t \n\tthis->ecc.engine_type = NAND_ECC_ENGINE_TYPE_SOFT;\n\n\t \n\terr = nand_scan(this, 1);\n\tif (err)\n\t\treturn err;\n\n\t \n\terr = mtd_device_register(mtd, partitions, num_partitions);\n\tif (err)\n\t\tgoto err_nand_cleanup;\n\n\treturn 0;\n\nerr_nand_cleanup:\n\tnand_cleanup(this);\n\n\treturn err;\n}\n\n \nstatic void gpio_nand_remove(struct platform_device *pdev)\n{\n\tstruct gpio_nand *priv = platform_get_drvdata(pdev);\n\tstruct mtd_info *mtd = nand_to_mtd(&priv->nand_chip);\n\tint ret;\n\n\t \n\tgpiod_set_value(priv->gpiod_nwp, 1);\n\n\t \n\tret = mtd_device_unregister(mtd);\n\tWARN_ON(ret);\n\tnand_cleanup(mtd_to_nand(mtd));\n}\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id gpio_nand_of_id_table[] = {\n\t{\n\t\t \n\t},\n};\nMODULE_DEVICE_TABLE(of, gpio_nand_of_id_table);\n#endif\n\nstatic const struct platform_device_id gpio_nand_plat_id_table[] = {\n\t{\n\t\t.name\t= \"ams-delta-nand\",\n\t}, {\n\t\t \n\t},\n};\nMODULE_DEVICE_TABLE(platform, gpio_nand_plat_id_table);\n\nstatic struct platform_driver gpio_nand_driver = {\n\t.probe\t\t= gpio_nand_probe,\n\t.remove_new\t= gpio_nand_remove,\n\t.id_table\t= gpio_nand_plat_id_table,\n\t.driver\t\t= {\n\t\t.name\t= \"ams-delta-nand\",\n\t\t.of_match_table = of_match_ptr(gpio_nand_of_id_table),\n\t},\n};\n\nmodule_platform_driver(gpio_nand_driver);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Jonathan McDowell <noodles@earth.li>\");\nMODULE_DESCRIPTION(\"Glue layer for NAND flash on Amstrad E3 (Delta)\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}