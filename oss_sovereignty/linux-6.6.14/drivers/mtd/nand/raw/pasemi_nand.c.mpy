{
  "module_name": "pasemi_nand.c",
  "hash_id": "9bcf217ff3c25f48be4cec6103fdb527bb09bd0ebbde1daafa582e2878ac30e3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/nand/raw/pasemi_nand.c",
  "human_readable_source": "\n \n\n#undef DEBUG\n\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mtd/mtd.h>\n#include <linux/mtd/rawnand.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n#include <linux/pci.h>\n\n#include <asm/io.h>\n\n#define LBICTRL_LPCCTL_NR\t\t0x00004000\n#define CLE_PIN_CTL\t\t\t15\n#define ALE_PIN_CTL\t\t\t14\n\nstruct pasemi_ddata {\n\tstruct nand_chip chip;\n\tunsigned int lpcctl;\n\tstruct nand_controller controller;\n};\n\nstatic const char driver_name[] = \"pasemi-nand\";\n\nstatic void pasemi_read_buf(struct nand_chip *chip, u_char *buf, int len)\n{\n\twhile (len > 0x800) {\n\t\tmemcpy_fromio(buf, chip->legacy.IO_ADDR_R, 0x800);\n\t\tbuf += 0x800;\n\t\tlen -= 0x800;\n\t}\n\tmemcpy_fromio(buf, chip->legacy.IO_ADDR_R, len);\n}\n\nstatic void pasemi_write_buf(struct nand_chip *chip, const u_char *buf,\n\t\t\t     int len)\n{\n\twhile (len > 0x800) {\n\t\tmemcpy_toio(chip->legacy.IO_ADDR_R, buf, 0x800);\n\t\tbuf += 0x800;\n\t\tlen -= 0x800;\n\t}\n\tmemcpy_toio(chip->legacy.IO_ADDR_R, buf, len);\n}\n\nstatic void pasemi_hwcontrol(struct nand_chip *chip, int cmd,\n\t\t\t     unsigned int ctrl)\n{\n\tstruct pasemi_ddata *ddata = container_of(chip, struct pasemi_ddata, chip);\n\n\tif (cmd == NAND_CMD_NONE)\n\t\treturn;\n\n\tif (ctrl & NAND_CLE)\n\t\tout_8(chip->legacy.IO_ADDR_W + (1 << CLE_PIN_CTL), cmd);\n\telse\n\t\tout_8(chip->legacy.IO_ADDR_W + (1 << ALE_PIN_CTL), cmd);\n\n\t \n\teieio();\n\tinl(ddata->lpcctl);\n}\n\nstatic int pasemi_device_ready(struct nand_chip *chip)\n{\n\tstruct pasemi_ddata *ddata = container_of(chip, struct pasemi_ddata, chip);\n\n\treturn !!(inl(ddata->lpcctl) & LBICTRL_LPCCTL_NR);\n}\n\nstatic int pasemi_attach_chip(struct nand_chip *chip)\n{\n\tif (chip->ecc.engine_type == NAND_ECC_ENGINE_TYPE_SOFT &&\n\t    chip->ecc.algo == NAND_ECC_ALGO_UNKNOWN)\n\t\tchip->ecc.algo = NAND_ECC_ALGO_HAMMING;\n\n\treturn 0;\n}\n\nstatic const struct nand_controller_ops pasemi_ops = {\n\t.attach_chip = pasemi_attach_chip,\n};\n\nstatic int pasemi_nand_probe(struct platform_device *ofdev)\n{\n\tstruct device *dev = &ofdev->dev;\n\tstruct pci_dev *pdev;\n\tstruct device_node *np = dev->of_node;\n\tstruct resource res;\n\tstruct nand_chip *chip;\n\tstruct nand_controller *controller;\n\tint err = 0;\n\tstruct pasemi_ddata *ddata;\n\tstruct mtd_info *pasemi_nand_mtd;\n\n\terr = of_address_to_resource(np, 0, &res);\n\n\tif (err)\n\t\treturn -EINVAL;\n\n\tdev_dbg(dev, \"pasemi_nand at %pR\\n\", &res);\n\n\t \n\tddata = kzalloc(sizeof(*ddata), GFP_KERNEL);\n\tif (!ddata) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\tplatform_set_drvdata(ofdev, ddata);\n\tchip = &ddata->chip;\n\tcontroller = &ddata->controller;\n\n\tcontroller->ops = &pasemi_ops;\n\tnand_controller_init(controller);\n\tchip->controller = controller;\n\n\tpasemi_nand_mtd = nand_to_mtd(chip);\n\n\t \n\tpasemi_nand_mtd->dev.parent = dev;\n\n\tchip->legacy.IO_ADDR_R = of_iomap(np, 0);\n\tchip->legacy.IO_ADDR_W = chip->legacy.IO_ADDR_R;\n\n\tif (!chip->legacy.IO_ADDR_R) {\n\t\terr = -EIO;\n\t\tgoto out_mtd;\n\t}\n\n\tpdev = pci_get_device(PCI_VENDOR_ID_PASEMI, 0xa008, NULL);\n\tif (!pdev) {\n\t\terr = -ENODEV;\n\t\tgoto out_ior;\n\t}\n\n\tddata->lpcctl = pci_resource_start(pdev, 0);\n\tpci_dev_put(pdev);\n\n\tif (!request_region(ddata->lpcctl, 4, driver_name)) {\n\t\terr = -EBUSY;\n\t\tgoto out_ior;\n\t}\n\n\tchip->legacy.cmd_ctrl = pasemi_hwcontrol;\n\tchip->legacy.dev_ready = pasemi_device_ready;\n\tchip->legacy.read_buf = pasemi_read_buf;\n\tchip->legacy.write_buf = pasemi_write_buf;\n\tchip->legacy.chip_delay = 0;\n\n\t \n\tchip->bbt_options = NAND_BBT_USE_FLASH;\n\n\t \n\tchip->ecc.engine_type = NAND_ECC_ENGINE_TYPE_SOFT;\n\n\t \n\terr = nand_scan(chip, 1);\n\tif (err)\n\t\tgoto out_lpc;\n\n\tif (mtd_device_register(pasemi_nand_mtd, NULL, 0)) {\n\t\tdev_err(dev, \"Unable to register MTD device\\n\");\n\t\terr = -ENODEV;\n\t\tgoto out_cleanup_nand;\n\t}\n\n\tdev_info(dev, \"PA Semi NAND flash at %pR, control at I/O %x\\n\", &res,\n\t\t ddata->lpcctl);\n\n\treturn 0;\n\n out_cleanup_nand:\n\tnand_cleanup(chip);\n out_lpc:\n\trelease_region(ddata->lpcctl, 4);\n out_ior:\n\tiounmap(chip->legacy.IO_ADDR_R);\n out_mtd:\n\tkfree(ddata);\n out:\n\treturn err;\n}\n\nstatic void pasemi_nand_remove(struct platform_device *ofdev)\n{\n\tstruct pasemi_ddata *ddata = platform_get_drvdata(ofdev);\n\tstruct mtd_info *pasemi_nand_mtd;\n\tint ret;\n\tstruct nand_chip *chip;\n\n\tchip = &ddata->chip;\n\tpasemi_nand_mtd = nand_to_mtd(chip);\n\n\t \n\tret = mtd_device_unregister(pasemi_nand_mtd);\n\tWARN_ON(ret);\n\tnand_cleanup(chip);\n\n\trelease_region(ddata->lpcctl, 4);\n\n\tiounmap(chip->legacy.IO_ADDR_R);\n\n\t \n\tkfree(ddata);\n}\n\nstatic const struct of_device_id pasemi_nand_match[] =\n{\n\t{\n\t\t.compatible   = \"pasemi,localbus-nand\",\n\t},\n\t{},\n};\n\nMODULE_DEVICE_TABLE(of, pasemi_nand_match);\n\nstatic struct platform_driver pasemi_nand_driver =\n{\n\t.driver = {\n\t\t.name = driver_name,\n\t\t.of_match_table = pasemi_nand_match,\n\t},\n\t.probe\t\t= pasemi_nand_probe,\n\t.remove_new\t= pasemi_nand_remove,\n};\n\nmodule_platform_driver(pasemi_nand_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Egor Martovetsky <egor@pasemi.com>\");\nMODULE_DESCRIPTION(\"NAND flash interface driver for PA Semi PWRficient\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}