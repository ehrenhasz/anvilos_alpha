{
  "module_name": "cafe_nand.c",
  "hash_id": "0673f591924b5847fa7470b37f02fed089f12b981c09f1117b293972e5a50183",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/nand/raw/cafe_nand.c",
  "human_readable_source": "\n \n\n#define DEBUG\n\n#include <linux/device.h>\n#undef DEBUG\n#include <linux/mtd/mtd.h>\n#include <linux/mtd/rawnand.h>\n#include <linux/mtd/partitions.h>\n#include <linux/rslib.h>\n#include <linux/pci.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/dma-mapping.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <asm/io.h>\n\n#define CAFE_NAND_CTRL1\t\t0x00\n#define CAFE_NAND_CTRL2\t\t0x04\n#define CAFE_NAND_CTRL3\t\t0x08\n#define CAFE_NAND_STATUS\t0x0c\n#define CAFE_NAND_IRQ\t\t0x10\n#define CAFE_NAND_IRQ_MASK\t0x14\n#define CAFE_NAND_DATA_LEN\t0x18\n#define CAFE_NAND_ADDR1\t\t0x1c\n#define CAFE_NAND_ADDR2\t\t0x20\n#define CAFE_NAND_TIMING1\t0x24\n#define CAFE_NAND_TIMING2\t0x28\n#define CAFE_NAND_TIMING3\t0x2c\n#define CAFE_NAND_NONMEM\t0x30\n#define CAFE_NAND_ECC_RESULT\t0x3C\n#define CAFE_NAND_DMA_CTRL\t0x40\n#define CAFE_NAND_DMA_ADDR0\t0x44\n#define CAFE_NAND_DMA_ADDR1\t0x48\n#define CAFE_NAND_ECC_SYN01\t0x50\n#define CAFE_NAND_ECC_SYN23\t0x54\n#define CAFE_NAND_ECC_SYN45\t0x58\n#define CAFE_NAND_ECC_SYN67\t0x5c\n#define CAFE_NAND_READ_DATA\t0x1000\n#define CAFE_NAND_WRITE_DATA\t0x2000\n\n#define CAFE_GLOBAL_CTRL\t0x3004\n#define CAFE_GLOBAL_IRQ\t\t0x3008\n#define CAFE_GLOBAL_IRQ_MASK\t0x300c\n#define CAFE_NAND_RESET\t\t0x3034\n\n \n#define CTRL1_CHIPSELECT\t(1<<19)\n\nstruct cafe_priv {\n\tstruct nand_chip nand;\n\tstruct pci_dev *pdev;\n\tvoid __iomem *mmio;\n\tstruct rs_control *rs;\n\tuint32_t ctl1;\n\tuint32_t ctl2;\n\tint datalen;\n\tint nr_data;\n\tint data_pos;\n\tint page_addr;\n\tbool usedma;\n\tdma_addr_t dmaaddr;\n\tunsigned char *dmabuf;\n};\n\nstatic int usedma = 1;\nmodule_param(usedma, int, 0644);\n\nstatic int skipbbt = 0;\nmodule_param(skipbbt, int, 0644);\n\nstatic int debug = 0;\nmodule_param(debug, int, 0644);\n\nstatic int regdebug = 0;\nmodule_param(regdebug, int, 0644);\n\nstatic int checkecc = 1;\nmodule_param(checkecc, int, 0644);\n\nstatic unsigned int numtimings;\nstatic int timing[3];\nmodule_param_array(timing, int, &numtimings, 0644);\n\nstatic const char *part_probes[] = { \"cmdlinepart\", \"RedBoot\", NULL };\n\n \n#define cafe_dev_dbg(dev, args...) do { if (debug) dev_dbg(dev, ##args); } while(0)\n\n \n#define cafe_readl(cafe, addr)\t\t\treadl((cafe)->mmio + CAFE_##addr)\n#define cafe_writel(cafe, datum, addr)\t\twritel(datum, (cafe)->mmio + CAFE_##addr)\n\nstatic int cafe_device_ready(struct nand_chip *chip)\n{\n\tstruct cafe_priv *cafe = nand_get_controller_data(chip);\n\tint result = !!(cafe_readl(cafe, NAND_STATUS) & 0x40000000);\n\tuint32_t irqs = cafe_readl(cafe, NAND_IRQ);\n\n\tcafe_writel(cafe, irqs, NAND_IRQ);\n\n\tcafe_dev_dbg(&cafe->pdev->dev, \"NAND device is%s ready, IRQ %x (%x) (%x,%x)\\n\",\n\t\tresult?\"\":\" not\", irqs, cafe_readl(cafe, NAND_IRQ),\n\t\tcafe_readl(cafe, GLOBAL_IRQ), cafe_readl(cafe, GLOBAL_IRQ_MASK));\n\n\treturn result;\n}\n\n\nstatic void cafe_write_buf(struct nand_chip *chip, const uint8_t *buf, int len)\n{\n\tstruct cafe_priv *cafe = nand_get_controller_data(chip);\n\n\tif (cafe->usedma)\n\t\tmemcpy(cafe->dmabuf + cafe->datalen, buf, len);\n\telse\n\t\tmemcpy_toio(cafe->mmio + CAFE_NAND_WRITE_DATA + cafe->datalen, buf, len);\n\n\tcafe->datalen += len;\n\n\tcafe_dev_dbg(&cafe->pdev->dev, \"Copy 0x%x bytes to write buffer. datalen 0x%x\\n\",\n\t\tlen, cafe->datalen);\n}\n\nstatic void cafe_read_buf(struct nand_chip *chip, uint8_t *buf, int len)\n{\n\tstruct cafe_priv *cafe = nand_get_controller_data(chip);\n\n\tif (cafe->usedma)\n\t\tmemcpy(buf, cafe->dmabuf + cafe->datalen, len);\n\telse\n\t\tmemcpy_fromio(buf, cafe->mmio + CAFE_NAND_READ_DATA + cafe->datalen, len);\n\n\tcafe_dev_dbg(&cafe->pdev->dev, \"Copy 0x%x bytes from position 0x%x in read buffer.\\n\",\n\t\t  len, cafe->datalen);\n\tcafe->datalen += len;\n}\n\nstatic uint8_t cafe_read_byte(struct nand_chip *chip)\n{\n\tstruct cafe_priv *cafe = nand_get_controller_data(chip);\n\tuint8_t d;\n\n\tcafe_read_buf(chip, &d, 1);\n\tcafe_dev_dbg(&cafe->pdev->dev, \"Read %02x\\n\", d);\n\n\treturn d;\n}\n\nstatic void cafe_nand_cmdfunc(struct nand_chip *chip, unsigned command,\n\t\t\t      int column, int page_addr)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tstruct cafe_priv *cafe = nand_get_controller_data(chip);\n\tint adrbytes = 0;\n\tuint32_t ctl1;\n\tuint32_t doneint = 0x80000000;\n\n\tcafe_dev_dbg(&cafe->pdev->dev, \"cmdfunc %02x, 0x%x, 0x%x\\n\",\n\t\tcommand, column, page_addr);\n\n\tif (command == NAND_CMD_ERASE2 || command == NAND_CMD_PAGEPROG) {\n\t\t \n\t\tcafe_writel(cafe, cafe->ctl2 | 0x100 | command, NAND_CTRL2);\n\t\tctl1 = cafe->ctl1;\n\t\tcafe->ctl2 &= ~(1<<30);\n\t\tcafe_dev_dbg(&cafe->pdev->dev, \"Continue command, ctl1 %08x, #data %d\\n\",\n\t\t\t  cafe->ctl1, cafe->nr_data);\n\t\tgoto do_command;\n\t}\n\t \n\tcafe_writel(cafe, 0, NAND_CTRL2);\n\n\t \n\tif (mtd->writesize > 512 &&\n\t    command == NAND_CMD_READOOB) {\n\t\tcolumn += mtd->writesize;\n\t\tcommand = NAND_CMD_READ0;\n\t}\n\n\t \n\n\tif (column != -1) {\n\t\tcafe_writel(cafe, column, NAND_ADDR1);\n\t\tadrbytes = 2;\n\t\tif (page_addr != -1)\n\t\t\tgoto write_adr2;\n\t} else if (page_addr != -1) {\n\t\tcafe_writel(cafe, page_addr & 0xffff, NAND_ADDR1);\n\t\tpage_addr >>= 16;\n\twrite_adr2:\n\t\tcafe_writel(cafe, page_addr, NAND_ADDR2);\n\t\tadrbytes += 2;\n\t\tif (mtd->size > mtd->writesize << 16)\n\t\t\tadrbytes++;\n\t}\n\n\tcafe->data_pos = cafe->datalen = 0;\n\n\t \n\tctl1 = 0x80000000 | command | (cafe->ctl1 & CTRL1_CHIPSELECT);\n\n\t \n\tif (command == NAND_CMD_READID || command == NAND_CMD_STATUS) {\n\t\tctl1 |= (1<<26);  \n\t\t \n\t\tcafe->datalen = 4;\n\t\t \n\t\tadrbytes = 1;\n\t} else if (command == NAND_CMD_READ0 || command == NAND_CMD_READ1 ||\n\t\t   command == NAND_CMD_READOOB || command == NAND_CMD_RNDOUT) {\n\t\tctl1 |= 1<<26;  \n\t\t \n\t\tcafe->datalen = mtd->writesize + mtd->oobsize - column;\n\t} else if (command == NAND_CMD_SEQIN)\n\t\tctl1 |= 1<<25;  \n\n\t \n\tif (adrbytes)\n\t\tctl1 |= ((adrbytes-1)|8) << 27;\n\n\tif (command == NAND_CMD_SEQIN || command == NAND_CMD_ERASE1) {\n\t\t \n\t\tcafe->ctl1 = ctl1;\n\t\tcafe_dev_dbg(&cafe->pdev->dev, \"Setup for delayed command, ctl1 %08x, dlen %x\\n\",\n\t\t\t  cafe->ctl1, cafe->datalen);\n\t\treturn;\n\t}\n\t \n\tif (command == NAND_CMD_RNDOUT)\n\t\tcafe_writel(cafe, cafe->ctl2 | 0x100 | NAND_CMD_RNDOUTSTART, NAND_CTRL2);\n\telse if (command == NAND_CMD_READ0 && mtd->writesize > 512)\n\t\tcafe_writel(cafe, cafe->ctl2 | 0x100 | NAND_CMD_READSTART, NAND_CTRL2);\n\n do_command:\n\tcafe_dev_dbg(&cafe->pdev->dev, \"dlen %x, ctl1 %x, ctl2 %x\\n\",\n\t\tcafe->datalen, ctl1, cafe_readl(cafe, NAND_CTRL2));\n\n\t \n\tcafe_writel(cafe, cafe->datalen, NAND_DATA_LEN);\n\tcafe_writel(cafe, 0x90000000, NAND_IRQ);\n\tif (cafe->usedma && (ctl1 & (3<<25))) {\n\t\tuint32_t dmactl = 0xc0000000 + cafe->datalen;\n\t\t \n\t\tif (ctl1 & (1<<26)) {\n\t\t\t \n\t\t\tdmactl |= (1<<29);\n\t\t\t \n\t\t\tdoneint = 0x10000000;\n\t\t}\n\t\tcafe_writel(cafe, dmactl, NAND_DMA_CTRL);\n\t}\n\tcafe->datalen = 0;\n\n\tif (unlikely(regdebug)) {\n\t\tint i;\n\t\tprintk(\"About to write command %08x to register 0\\n\", ctl1);\n\t\tfor (i=4; i< 0x5c; i+=4)\n\t\t\tprintk(\"Register %x: %08x\\n\", i, readl(cafe->mmio + i));\n\t}\n\n\tcafe_writel(cafe, ctl1, NAND_CTRL1);\n\t \n\tndelay(100);\n\n\tif (1) {\n\t\tint c;\n\t\tuint32_t irqs;\n\n\t\tfor (c = 500000; c != 0; c--) {\n\t\t\tirqs = cafe_readl(cafe, NAND_IRQ);\n\t\t\tif (irqs & doneint)\n\t\t\t\tbreak;\n\t\t\tudelay(1);\n\t\t\tif (!(c % 100000))\n\t\t\t\tcafe_dev_dbg(&cafe->pdev->dev, \"Wait for ready, IRQ %x\\n\", irqs);\n\t\t\tcpu_relax();\n\t\t}\n\t\tcafe_writel(cafe, doneint, NAND_IRQ);\n\t\tcafe_dev_dbg(&cafe->pdev->dev, \"Command %x completed after %d usec, irqs %x (%x)\\n\",\n\t\t\t     command, 500000-c, irqs, cafe_readl(cafe, NAND_IRQ));\n\t}\n\n\tWARN_ON(cafe->ctl2 & (1<<30));\n\n\tswitch (command) {\n\n\tcase NAND_CMD_CACHEDPROG:\n\tcase NAND_CMD_PAGEPROG:\n\tcase NAND_CMD_ERASE1:\n\tcase NAND_CMD_ERASE2:\n\tcase NAND_CMD_SEQIN:\n\tcase NAND_CMD_RNDIN:\n\tcase NAND_CMD_STATUS:\n\tcase NAND_CMD_RNDOUT:\n\t\tcafe_writel(cafe, cafe->ctl2, NAND_CTRL2);\n\t\treturn;\n\t}\n\tnand_wait_ready(chip);\n\tcafe_writel(cafe, cafe->ctl2, NAND_CTRL2);\n}\n\nstatic void cafe_select_chip(struct nand_chip *chip, int chipnr)\n{\n\tstruct cafe_priv *cafe = nand_get_controller_data(chip);\n\n\tcafe_dev_dbg(&cafe->pdev->dev, \"select_chip %d\\n\", chipnr);\n\n\t \n\tif (chipnr)\n\t\tcafe->ctl1 |= CTRL1_CHIPSELECT;\n\telse\n\t\tcafe->ctl1 &= ~CTRL1_CHIPSELECT;\n}\n\nstatic irqreturn_t cafe_nand_interrupt(int irq, void *id)\n{\n\tstruct mtd_info *mtd = id;\n\tstruct nand_chip *chip = mtd_to_nand(mtd);\n\tstruct cafe_priv *cafe = nand_get_controller_data(chip);\n\tuint32_t irqs = cafe_readl(cafe, NAND_IRQ);\n\tcafe_writel(cafe, irqs & ~0x90000000, NAND_IRQ);\n\tif (!irqs)\n\t\treturn IRQ_NONE;\n\n\tcafe_dev_dbg(&cafe->pdev->dev, \"irq, bits %x (%x)\\n\", irqs, cafe_readl(cafe, NAND_IRQ));\n\treturn IRQ_HANDLED;\n}\n\nstatic int cafe_nand_write_oob(struct nand_chip *chip, int page)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\n\treturn nand_prog_page_op(chip, page, mtd->writesize, chip->oob_poi,\n\t\t\t\t mtd->oobsize);\n}\n\n \nstatic int cafe_nand_read_oob(struct nand_chip *chip, int page)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\n\treturn nand_read_oob_op(chip, page, 0, chip->oob_poi, mtd->oobsize);\n}\n \nstatic int cafe_nand_read_page(struct nand_chip *chip, uint8_t *buf,\n\t\t\t       int oob_required, int page)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tstruct cafe_priv *cafe = nand_get_controller_data(chip);\n\tunsigned int max_bitflips = 0;\n\n\tcafe_dev_dbg(&cafe->pdev->dev, \"ECC result %08x SYN1,2 %08x\\n\",\n\t\t     cafe_readl(cafe, NAND_ECC_RESULT),\n\t\t     cafe_readl(cafe, NAND_ECC_SYN01));\n\n\tnand_read_page_op(chip, page, 0, buf, mtd->writesize);\n\tchip->legacy.read_buf(chip, chip->oob_poi, mtd->oobsize);\n\n\tif (checkecc && cafe_readl(cafe, NAND_ECC_RESULT) & (1<<18)) {\n\t\tunsigned short syn[8], pat[4];\n\t\tint pos[4];\n\t\tu8 *oob = chip->oob_poi;\n\t\tint i, n;\n\n\t\tfor (i=0; i<8; i+=2) {\n\t\t\tuint32_t tmp = cafe_readl(cafe, NAND_ECC_SYN01 + (i*2));\n\n\t\t\tsyn[i] = cafe->rs->codec->index_of[tmp & 0xfff];\n\t\t\tsyn[i+1] = cafe->rs->codec->index_of[(tmp >> 16) & 0xfff];\n\t\t}\n\n\t\tn = decode_rs16(cafe->rs, NULL, NULL, 1367, syn, 0, pos, 0,\n\t\t\t\tpat);\n\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tint p = pos[i];\n\n\t\t\t \n\n\t\t\tif (p > 1374) {\n\t\t\t\t \n\t\t\t\tn = -1374;\n\t\t\t} else if (p == 0) {\n\t\t\t\t \n\t\t\t\tif (pat[i] > 0xff)\n\t\t\t\t\tn = -2048;\n\t\t\t\telse\n\t\t\t\t\tbuf[0] ^= pat[i];\n\t\t\t} else if (p == 1365) {\n\t\t\t\tbuf[2047] ^= pat[i] >> 4;\n\t\t\t\toob[0] ^= pat[i] << 4;\n\t\t\t} else if (p > 1365) {\n\t\t\t\tif ((p & 1) == 1) {\n\t\t\t\t\toob[3*p/2 - 2048] ^= pat[i] >> 4;\n\t\t\t\t\toob[3*p/2 - 2047] ^= pat[i] << 4;\n\t\t\t\t} else {\n\t\t\t\t\toob[3*p/2 - 2049] ^= pat[i] >> 8;\n\t\t\t\t\toob[3*p/2 - 2048] ^= pat[i];\n\t\t\t\t}\n\t\t\t} else if ((p & 1) == 1) {\n\t\t\t\tbuf[3*p/2] ^= pat[i] >> 4;\n\t\t\t\tbuf[3*p/2 + 1] ^= pat[i] << 4;\n\t\t\t} else {\n\t\t\t\tbuf[3*p/2 - 1] ^= pat[i] >> 8;\n\t\t\t\tbuf[3*p/2] ^= pat[i];\n\t\t\t}\n\t\t}\n\n\t\tif (n < 0) {\n\t\t\tdev_dbg(&cafe->pdev->dev, \"Failed to correct ECC at %08x\\n\",\n\t\t\t\tcafe_readl(cafe, NAND_ADDR2) * 2048);\n\t\t\tfor (i = 0; i < 0x5c; i += 4)\n\t\t\t\tprintk(\"Register %x: %08x\\n\", i, readl(cafe->mmio + i));\n\t\t\tmtd->ecc_stats.failed++;\n\t\t} else {\n\t\t\tdev_dbg(&cafe->pdev->dev, \"Corrected %d symbol errors\\n\", n);\n\t\t\tmtd->ecc_stats.corrected += n;\n\t\t\tmax_bitflips = max_t(unsigned int, max_bitflips, n);\n\t\t}\n\t}\n\n\treturn max_bitflips;\n}\n\nstatic int cafe_ooblayout_ecc(struct mtd_info *mtd, int section,\n\t\t\t      struct mtd_oob_region *oobregion)\n{\n\tstruct nand_chip *chip = mtd_to_nand(mtd);\n\n\tif (section)\n\t\treturn -ERANGE;\n\n\toobregion->offset = 0;\n\toobregion->length = chip->ecc.total;\n\n\treturn 0;\n}\n\nstatic int cafe_ooblayout_free(struct mtd_info *mtd, int section,\n\t\t\t       struct mtd_oob_region *oobregion)\n{\n\tstruct nand_chip *chip = mtd_to_nand(mtd);\n\n\tif (section)\n\t\treturn -ERANGE;\n\n\toobregion->offset = chip->ecc.total;\n\toobregion->length = mtd->oobsize - chip->ecc.total;\n\n\treturn 0;\n}\n\nstatic const struct mtd_ooblayout_ops cafe_ooblayout_ops = {\n\t.ecc = cafe_ooblayout_ecc,\n\t.free = cafe_ooblayout_free,\n};\n\n \nstatic uint8_t cafe_bbt_pattern_2048[] = { 'B', 'b', 't', '0' };\nstatic uint8_t cafe_mirror_pattern_2048[] = { '1', 't', 'b', 'B' };\n\nstatic uint8_t cafe_bbt_pattern_512[] = { 0xBB };\nstatic uint8_t cafe_mirror_pattern_512[] = { 0xBC };\n\n\nstatic struct nand_bbt_descr cafe_bbt_main_descr_2048 = {\n\t.options = NAND_BBT_LASTBLOCK | NAND_BBT_CREATE | NAND_BBT_WRITE\n\t\t| NAND_BBT_2BIT | NAND_BBT_VERSION,\n\t.offs =\t14,\n\t.len = 4,\n\t.veroffs = 18,\n\t.maxblocks = 4,\n\t.pattern = cafe_bbt_pattern_2048\n};\n\nstatic struct nand_bbt_descr cafe_bbt_mirror_descr_2048 = {\n\t.options = NAND_BBT_LASTBLOCK | NAND_BBT_CREATE | NAND_BBT_WRITE\n\t\t| NAND_BBT_2BIT | NAND_BBT_VERSION,\n\t.offs =\t14,\n\t.len = 4,\n\t.veroffs = 18,\n\t.maxblocks = 4,\n\t.pattern = cafe_mirror_pattern_2048\n};\n\nstatic struct nand_bbt_descr cafe_bbt_main_descr_512 = {\n\t.options = NAND_BBT_LASTBLOCK | NAND_BBT_CREATE | NAND_BBT_WRITE\n\t\t| NAND_BBT_2BIT | NAND_BBT_VERSION,\n\t.offs =\t14,\n\t.len = 1,\n\t.veroffs = 15,\n\t.maxblocks = 4,\n\t.pattern = cafe_bbt_pattern_512\n};\n\nstatic struct nand_bbt_descr cafe_bbt_mirror_descr_512 = {\n\t.options = NAND_BBT_LASTBLOCK | NAND_BBT_CREATE | NAND_BBT_WRITE\n\t\t| NAND_BBT_2BIT | NAND_BBT_VERSION,\n\t.offs =\t14,\n\t.len = 1,\n\t.veroffs = 15,\n\t.maxblocks = 4,\n\t.pattern = cafe_mirror_pattern_512\n};\n\n\nstatic int cafe_nand_write_page_lowlevel(struct nand_chip *chip,\n\t\t\t\t\t const uint8_t *buf, int oob_required,\n\t\t\t\t\t int page)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tstruct cafe_priv *cafe = nand_get_controller_data(chip);\n\n\tnand_prog_page_begin_op(chip, page, 0, buf, mtd->writesize);\n\tchip->legacy.write_buf(chip, chip->oob_poi, mtd->oobsize);\n\n\t \n\tcafe->ctl2 |= (1<<30);\n\n\treturn nand_prog_page_end_op(chip);\n}\n\n \nstatic unsigned short gf64_mul(u8 a, u8 b)\n{\n\tu8 c;\n\tunsigned int i;\n\n\tc = 0;\n\tfor (i = 0; i < 6; i++) {\n\t\tif (a & 1)\n\t\t\tc ^= b;\n\t\ta >>= 1;\n\t\tb <<= 1;\n\t\tif ((b & 0x40) != 0)\n\t\t\tb ^= 0x43;\n\t}\n\n\treturn c;\n}\n\n \nstatic u16 gf4096_mul(u16 a, u16 b)\n{\n\tu8 ah, al, bh, bl, ch, cl;\n\n\tah = a >> 6;\n\tal = a & 0x3f;\n\tbh = b >> 6;\n\tbl = b & 0x3f;\n\n\tch = gf64_mul(ah ^ al, bh ^ bl) ^ gf64_mul(al, bl);\n\tcl = gf64_mul(gf64_mul(ah, bh), 0x21) ^ gf64_mul(al, bl);\n\n\treturn (ch << 6) ^ cl;\n}\n\nstatic int cafe_mul(int x)\n{\n\tif (x == 0)\n\t\treturn 1;\n\treturn gf4096_mul(x, 0xe01);\n}\n\nstatic int cafe_nand_attach_chip(struct nand_chip *chip)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tstruct cafe_priv *cafe = nand_get_controller_data(chip);\n\tint err = 0;\n\n\tcafe->dmabuf = dma_alloc_coherent(&cafe->pdev->dev, 2112,\n\t\t\t\t\t  &cafe->dmaaddr, GFP_KERNEL);\n\tif (!cafe->dmabuf)\n\t\treturn -ENOMEM;\n\n\t \n\tcafe_writel(cafe, lower_32_bits(cafe->dmaaddr), NAND_DMA_ADDR0);\n\tcafe_writel(cafe, upper_32_bits(cafe->dmaaddr), NAND_DMA_ADDR1);\n\n\tcafe_dev_dbg(&cafe->pdev->dev, \"Set DMA address to %x (virt %p)\\n\",\n\t\t     cafe_readl(cafe, NAND_DMA_ADDR0), cafe->dmabuf);\n\n\t \n\tcafe->usedma = usedma;\n\n\tcafe->ctl2 = BIT(27);  \n\tif (mtd->writesize == 2048)\n\t\tcafe->ctl2 |= BIT(29);  \n\n\t \n\tmtd_set_ooblayout(mtd, &cafe_ooblayout_ops);\n\tif (mtd->writesize == 2048) {\n\t\tcafe->nand.bbt_td = &cafe_bbt_main_descr_2048;\n\t\tcafe->nand.bbt_md = &cafe_bbt_mirror_descr_2048;\n\t} else if (mtd->writesize == 512) {\n\t\tcafe->nand.bbt_td = &cafe_bbt_main_descr_512;\n\t\tcafe->nand.bbt_md = &cafe_bbt_mirror_descr_512;\n\t} else {\n\t\tdev_warn(&cafe->pdev->dev,\n\t\t\t \"Unexpected NAND flash writesize %d. Aborting\\n\",\n\t\t\t mtd->writesize);\n\t\terr = -ENOTSUPP;\n\t\tgoto out_free_dma;\n\t}\n\n\tcafe->nand.ecc.engine_type = NAND_ECC_ENGINE_TYPE_ON_HOST;\n\tcafe->nand.ecc.placement = NAND_ECC_PLACEMENT_INTERLEAVED;\n\tcafe->nand.ecc.size = mtd->writesize;\n\tcafe->nand.ecc.bytes = 14;\n\tcafe->nand.ecc.strength = 4;\n\tcafe->nand.ecc.write_page = cafe_nand_write_page_lowlevel;\n\tcafe->nand.ecc.write_oob = cafe_nand_write_oob;\n\tcafe->nand.ecc.read_page = cafe_nand_read_page;\n\tcafe->nand.ecc.read_oob = cafe_nand_read_oob;\n\n\treturn 0;\n\n out_free_dma:\n\tdma_free_coherent(&cafe->pdev->dev, 2112, cafe->dmabuf, cafe->dmaaddr);\n\n\treturn err;\n}\n\nstatic void cafe_nand_detach_chip(struct nand_chip *chip)\n{\n\tstruct cafe_priv *cafe = nand_get_controller_data(chip);\n\n\tdma_free_coherent(&cafe->pdev->dev, 2112, cafe->dmabuf, cafe->dmaaddr);\n}\n\nstatic const struct nand_controller_ops cafe_nand_controller_ops = {\n\t.attach_chip = cafe_nand_attach_chip,\n\t.detach_chip = cafe_nand_detach_chip,\n};\n\nstatic int cafe_nand_probe(struct pci_dev *pdev,\n\t\t\t\t     const struct pci_device_id *ent)\n{\n\tstruct mtd_info *mtd;\n\tstruct cafe_priv *cafe;\n\tuint32_t ctrl;\n\tint err = 0;\n\n\t \n\tif ((pdev->class >> 8) != PCI_CLASS_MEMORY_FLASH)\n\t\treturn -ENODEV;\n\n\terr = pci_enable_device(pdev);\n\tif (err)\n\t\treturn err;\n\n\tpci_set_master(pdev);\n\n\tcafe = kzalloc(sizeof(*cafe), GFP_KERNEL);\n\tif (!cafe) {\n\t\terr = -ENOMEM;\n\t\tgoto out_disable_device;\n\t}\n\n\tmtd = nand_to_mtd(&cafe->nand);\n\tmtd->dev.parent = &pdev->dev;\n\tnand_set_controller_data(&cafe->nand, cafe);\n\n\tcafe->pdev = pdev;\n\tcafe->mmio = pci_iomap(pdev, 0, 0);\n\tif (!cafe->mmio) {\n\t\tdev_warn(&pdev->dev, \"failed to iomap\\n\");\n\t\terr = -ENOMEM;\n\t\tgoto out_free_mtd;\n\t}\n\n\tcafe->rs = init_rs_non_canonical(12, &cafe_mul, 0, 1, 8);\n\tif (!cafe->rs) {\n\t\terr = -ENOMEM;\n\t\tgoto out_ior;\n\t}\n\n\tcafe->nand.legacy.cmdfunc = cafe_nand_cmdfunc;\n\tcafe->nand.legacy.dev_ready = cafe_device_ready;\n\tcafe->nand.legacy.read_byte = cafe_read_byte;\n\tcafe->nand.legacy.read_buf = cafe_read_buf;\n\tcafe->nand.legacy.write_buf = cafe_write_buf;\n\tcafe->nand.legacy.select_chip = cafe_select_chip;\n\tcafe->nand.legacy.set_features = nand_get_set_features_notsupp;\n\tcafe->nand.legacy.get_features = nand_get_set_features_notsupp;\n\n\tcafe->nand.legacy.chip_delay = 0;\n\n\t \n\tcafe->nand.bbt_options = NAND_BBT_USE_FLASH;\n\n\tif (skipbbt)\n\t\tcafe->nand.options |= NAND_SKIP_BBTSCAN | NAND_NO_BBM_QUIRK;\n\n\tif (numtimings && numtimings != 3) {\n\t\tdev_warn(&cafe->pdev->dev, \"%d timing register values ignored; precisely three are required\\n\", numtimings);\n\t}\n\n\tif (numtimings == 3) {\n\t\tcafe_dev_dbg(&cafe->pdev->dev, \"Using provided timings (%08x %08x %08x)\\n\",\n\t\t\t     timing[0], timing[1], timing[2]);\n\t} else {\n\t\ttiming[0] = cafe_readl(cafe, NAND_TIMING1);\n\t\ttiming[1] = cafe_readl(cafe, NAND_TIMING2);\n\t\ttiming[2] = cafe_readl(cafe, NAND_TIMING3);\n\n\t\tif (timing[0] | timing[1] | timing[2]) {\n\t\t\tcafe_dev_dbg(&cafe->pdev->dev, \"Timing registers already set (%08x %08x %08x)\\n\",\n\t\t\t\t     timing[0], timing[1], timing[2]);\n\t\t} else {\n\t\t\tdev_warn(&cafe->pdev->dev, \"Timing registers unset; using most conservative defaults\\n\");\n\t\t\ttiming[0] = timing[1] = timing[2] = 0xffffffff;\n\t\t}\n\t}\n\n\t \n\tcafe_writel(cafe, 1, NAND_RESET);\n\tcafe_writel(cafe, 0, NAND_RESET);\n\n\tcafe_writel(cafe, timing[0], NAND_TIMING1);\n\tcafe_writel(cafe, timing[1], NAND_TIMING2);\n\tcafe_writel(cafe, timing[2], NAND_TIMING3);\n\n\tcafe_writel(cafe, 0xffffffff, NAND_IRQ_MASK);\n\terr = request_irq(pdev->irq, &cafe_nand_interrupt, IRQF_SHARED,\n\t\t\t  \"CAFE NAND\", mtd);\n\tif (err) {\n\t\tdev_warn(&pdev->dev, \"Could not register IRQ %d\\n\", pdev->irq);\n\t\tgoto out_free_rs;\n\t}\n\n\t \n\tctrl = cafe_readl(cafe, GLOBAL_CTRL);\n\tctrl &= 0xffffeff0;\n\tctrl |= 0x00007000;\n\tcafe_writel(cafe, ctrl | 0x05, GLOBAL_CTRL);\n\tcafe_writel(cafe, ctrl | 0x0a, GLOBAL_CTRL);\n\tcafe_writel(cafe, 0, NAND_DMA_CTRL);\n\n\tcafe_writel(cafe, 0x7006, GLOBAL_CTRL);\n\tcafe_writel(cafe, 0x700a, GLOBAL_CTRL);\n\n\t \n\tcafe_writel(cafe, 0x80000007, GLOBAL_IRQ_MASK);\n\tcafe_dev_dbg(&cafe->pdev->dev, \"Control %x, IRQ mask %x\\n\",\n\t\tcafe_readl(cafe, GLOBAL_CTRL),\n\t\tcafe_readl(cafe, GLOBAL_IRQ_MASK));\n\n\t \n\tcafe->usedma = 0;\n\n\t \n\tcafe->nand.legacy.dummy_controller.ops = &cafe_nand_controller_ops;\n\terr = nand_scan(&cafe->nand, 2);\n\tif (err)\n\t\tgoto out_irq;\n\n\tpci_set_drvdata(pdev, mtd);\n\n\tmtd->name = \"cafe_nand\";\n\terr = mtd_device_parse_register(mtd, part_probes, NULL, NULL, 0);\n\tif (err)\n\t\tgoto out_cleanup_nand;\n\n\tgoto out;\n\n out_cleanup_nand:\n\tnand_cleanup(&cafe->nand);\n out_irq:\n\t \n\tcafe_writel(cafe, ~1 & cafe_readl(cafe, GLOBAL_IRQ_MASK), GLOBAL_IRQ_MASK);\n\tfree_irq(pdev->irq, mtd);\n out_free_rs:\n\tfree_rs(cafe->rs);\n out_ior:\n\tpci_iounmap(pdev, cafe->mmio);\n out_free_mtd:\n\tkfree(cafe);\n out_disable_device:\n\tpci_disable_device(pdev);\n out:\n\treturn err;\n}\n\nstatic void cafe_nand_remove(struct pci_dev *pdev)\n{\n\tstruct mtd_info *mtd = pci_get_drvdata(pdev);\n\tstruct nand_chip *chip = mtd_to_nand(mtd);\n\tstruct cafe_priv *cafe = nand_get_controller_data(chip);\n\tint ret;\n\n\t \n\tcafe_writel(cafe, ~1 & cafe_readl(cafe, GLOBAL_IRQ_MASK), GLOBAL_IRQ_MASK);\n\tfree_irq(pdev->irq, mtd);\n\tret = mtd_device_unregister(mtd);\n\tWARN_ON(ret);\n\tnand_cleanup(chip);\n\tfree_rs(cafe->rs);\n\tpci_iounmap(pdev, cafe->mmio);\n\tdma_free_coherent(&cafe->pdev->dev, 2112, cafe->dmabuf, cafe->dmaaddr);\n\tkfree(cafe);\n\tpci_disable_device(pdev);\n}\n\nstatic const struct pci_device_id cafe_nand_tbl[] = {\n\t{ PCI_VENDOR_ID_MARVELL, PCI_DEVICE_ID_MARVELL_88ALP01_NAND,\n\t  PCI_ANY_ID, PCI_ANY_ID },\n\t{ }\n};\n\nMODULE_DEVICE_TABLE(pci, cafe_nand_tbl);\n\nstatic int cafe_nand_resume(struct pci_dev *pdev)\n{\n\tuint32_t ctrl;\n\tstruct mtd_info *mtd = pci_get_drvdata(pdev);\n\tstruct nand_chip *chip = mtd_to_nand(mtd);\n\tstruct cafe_priv *cafe = nand_get_controller_data(chip);\n\n        \n\tcafe_writel(cafe, 1, NAND_RESET);\n\tcafe_writel(cafe, 0, NAND_RESET);\n\tcafe_writel(cafe, 0xffffffff, NAND_IRQ_MASK);\n\n\t \n\tcafe_writel(cafe, timing[0], NAND_TIMING1);\n\tcafe_writel(cafe, timing[1], NAND_TIMING2);\n\tcafe_writel(cafe, timing[2], NAND_TIMING3);\n\n         \n\tctrl = cafe_readl(cafe, GLOBAL_CTRL);\n\tctrl &= 0xffffeff0;\n\tctrl |= 0x00007000;\n\tcafe_writel(cafe, ctrl | 0x05, GLOBAL_CTRL);\n\tcafe_writel(cafe, ctrl | 0x0a, GLOBAL_CTRL);\n\tcafe_writel(cafe, 0, NAND_DMA_CTRL);\n\tcafe_writel(cafe, 0x7006, GLOBAL_CTRL);\n\tcafe_writel(cafe, 0x700a, GLOBAL_CTRL);\n\n\t \n\tcafe_writel(cafe, cafe->dmaaddr & 0xffffffff, NAND_DMA_ADDR0);\n\tif (sizeof(cafe->dmaaddr) > 4)\n\t \n\t\tcafe_writel(cafe, (cafe->dmaaddr >> 16) >> 16, NAND_DMA_ADDR1);\n\telse\n\t\tcafe_writel(cafe, 0, NAND_DMA_ADDR1);\n\n\t \n\tcafe_writel(cafe, 0x80000007, GLOBAL_IRQ_MASK);\n\treturn 0;\n}\n\nstatic struct pci_driver cafe_nand_pci_driver = {\n\t.name = \"CAF\u00c9 NAND\",\n\t.id_table = cafe_nand_tbl,\n\t.probe = cafe_nand_probe,\n\t.remove = cafe_nand_remove,\n\t.resume = cafe_nand_resume,\n};\n\nmodule_pci_driver(cafe_nand_pci_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"David Woodhouse <dwmw2@infradead.org>\");\nMODULE_DESCRIPTION(\"NAND flash driver for OLPC CAF\u00c9 chip\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}