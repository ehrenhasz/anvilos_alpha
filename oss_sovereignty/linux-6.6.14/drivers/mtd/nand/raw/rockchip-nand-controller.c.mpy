{
  "module_name": "rockchip-nand-controller.c",
  "hash_id": "dbf6fb3a4e9b02a3f62ee055f6552215a9b64a9d33d704f1a5d924af3fc82f60",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/nand/raw/rockchip-nand-controller.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/dma-mapping.h>\n#include <linux/dmaengine.h>\n#include <linux/interrupt.h>\n#include <linux/iopoll.h>\n#include <linux/module.h>\n#include <linux/mtd/mtd.h>\n#include <linux/mtd/rawnand.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n\n \n\n \n#define NFC_READ\t\t\t(0)\n#define NFC_WRITE\t\t\t(1)\n\n#define NFC_FMCTL\t\t\t(0x00)\n#define   FMCTL_CE_SEL_M\t\t0xFF\n#define   FMCTL_CE_SEL(x)\t\t(1 << (x))\n#define   FMCTL_WP\t\t\tBIT(8)\n#define   FMCTL_RDY\t\t\tBIT(9)\n\n#define NFC_FMWAIT\t\t\t(0x04)\n#define   FLCTL_RST\t\t\tBIT(0)\n#define   FLCTL_WR\t\t\t(1)\t \n#define   FLCTL_XFER_ST\t\t\tBIT(2)\n#define   FLCTL_XFER_EN\t\t\tBIT(3)\n#define   FLCTL_ACORRECT\t\tBIT(10)  \n#define   FLCTL_XFER_READY\t\tBIT(20)\n#define   FLCTL_XFER_SECTOR\t\t(22)\n#define   FLCTL_TOG_FIX\t\t\tBIT(29)\n\n#define   BCHCTL_BANK_M\t\t\t(7 << 5)\n#define   BCHCTL_BANK\t\t\t(5)\n\n#define   DMA_ST\t\t\tBIT(0)\n#define   DMA_WR\t\t\t(1)\t \n#define   DMA_EN\t\t\tBIT(2)\n#define   DMA_AHB_SIZE\t\t\t(3)\t \n#define   DMA_BURST_SIZE\t\t(6)\t \n#define   DMA_INC_NUM\t\t\t(9)\t \n\n#define ECC_ERR_CNT(x, e) ((((x) >> (e).low) & (e).low_mask) |\\\n\t  (((x) >> (e).high) & (e).high_mask) << (e).low_bn)\n#define   INT_DMA\t\t\tBIT(0)\n#define NFC_BANK\t\t\t(0x800)\n#define NFC_BANK_STEP\t\t\t(0x100)\n#define   BANK_DATA\t\t\t(0x00)\n#define   BANK_ADDR\t\t\t(0x04)\n#define   BANK_CMD\t\t\t(0x08)\n#define NFC_SRAM0\t\t\t(0x1000)\n#define NFC_SRAM1\t\t\t(0x1400)\n#define NFC_SRAM_SIZE\t\t\t(0x400)\n#define NFC_TIMEOUT\t\t\t(500000)\n#define NFC_MAX_OOB_PER_STEP\t\t128\n#define NFC_MIN_OOB_PER_STEP\t\t64\n#define MAX_DATA_SIZE\t\t\t0xFFFC\n#define MAX_ADDRESS_CYC\t\t\t6\n#define NFC_ECC_MAX_MODES\t\t4\n#define NFC_MAX_NSELS\t\t\t(8)  \n#define NFC_SYS_DATA_SIZE\t\t(4)  \n#define RK_DEFAULT_CLOCK_RATE\t\t(150 * 1000 * 1000)  \n#define ACCTIMING(csrw, rwpw, rwcs)\t((csrw) << 12 | (rwpw) << 5 | (rwcs))\n\nenum nfc_type {\n\tNFC_V6,\n\tNFC_V8,\n\tNFC_V9,\n};\n\n \nstruct ecc_cnt_status {\n\tu8 err_flag_bit;\n\tu8 low;\n\tu8 low_mask;\n\tu8 low_bn;\n\tu8 high;\n\tu8 high_mask;\n};\n\n \nstruct nfc_cfg {\n\tenum nfc_type type;\n\tu8 ecc_strengths[NFC_ECC_MAX_MODES];\n\tu32 ecc_cfgs[NFC_ECC_MAX_MODES];\n\tu32 flctl_off;\n\tu32 bchctl_off;\n\tu32 dma_cfg_off;\n\tu32 dma_data_buf_off;\n\tu32 dma_oob_buf_off;\n\tu32 dma_st_off;\n\tu32 bch_st_off;\n\tu32 randmz_off;\n\tu32 int_en_off;\n\tu32 int_clr_off;\n\tu32 int_st_off;\n\tu32 oob0_off;\n\tu32 oob1_off;\n\tstruct ecc_cnt_status ecc0;\n\tstruct ecc_cnt_status ecc1;\n};\n\nstruct rk_nfc_nand_chip {\n\tstruct list_head node;\n\tstruct nand_chip chip;\n\n\tu16 boot_blks;\n\tu16 metadata_size;\n\tu32 boot_ecc;\n\tu32 timing;\n\n\tu8 nsels;\n\tu8 sels[];\n\t \n};\n\nstruct rk_nfc {\n\tstruct nand_controller controller;\n\tconst struct nfc_cfg *cfg;\n\tstruct device *dev;\n\n\tstruct clk *nfc_clk;\n\tstruct clk *ahb_clk;\n\tvoid __iomem *regs;\n\n\tu32 selected_bank;\n\tu32 band_offset;\n\tu32 cur_ecc;\n\tu32 cur_timing;\n\n\tstruct completion done;\n\tstruct list_head chips;\n\n\tu8 *page_buf;\n\tu32 *oob_buf;\n\tu32 page_buf_size;\n\tu32 oob_buf_size;\n\n\tunsigned long assigned_cs;\n};\n\nstatic inline struct rk_nfc_nand_chip *rk_nfc_to_rknand(struct nand_chip *chip)\n{\n\treturn container_of(chip, struct rk_nfc_nand_chip, chip);\n}\n\nstatic inline u8 *rk_nfc_buf_to_data_ptr(struct nand_chip *chip, const u8 *p, int i)\n{\n\treturn (u8 *)p + i * chip->ecc.size;\n}\n\nstatic inline u8 *rk_nfc_buf_to_oob_ptr(struct nand_chip *chip, int i)\n{\n\tu8 *poi;\n\n\tpoi = chip->oob_poi + i * NFC_SYS_DATA_SIZE;\n\n\treturn poi;\n}\n\nstatic inline u8 *rk_nfc_buf_to_oob_ecc_ptr(struct nand_chip *chip, int i)\n{\n\tstruct rk_nfc_nand_chip *rknand = rk_nfc_to_rknand(chip);\n\tu8 *poi;\n\n\tpoi = chip->oob_poi + rknand->metadata_size + chip->ecc.bytes * i;\n\n\treturn poi;\n}\n\nstatic inline int rk_nfc_data_len(struct nand_chip *chip)\n{\n\treturn chip->ecc.size + chip->ecc.bytes + NFC_SYS_DATA_SIZE;\n}\n\nstatic inline u8 *rk_nfc_data_ptr(struct nand_chip *chip, int i)\n{\n\tstruct rk_nfc *nfc = nand_get_controller_data(chip);\n\n\treturn nfc->page_buf + i * rk_nfc_data_len(chip);\n}\n\nstatic inline u8 *rk_nfc_oob_ptr(struct nand_chip *chip, int i)\n{\n\tstruct rk_nfc *nfc = nand_get_controller_data(chip);\n\n\treturn nfc->page_buf + i * rk_nfc_data_len(chip) + chip->ecc.size;\n}\n\nstatic int rk_nfc_hw_ecc_setup(struct nand_chip *chip, u32 strength)\n{\n\tstruct rk_nfc *nfc = nand_get_controller_data(chip);\n\tu32 reg, i;\n\n\tfor (i = 0; i < NFC_ECC_MAX_MODES; i++) {\n\t\tif (strength == nfc->cfg->ecc_strengths[i]) {\n\t\t\treg = nfc->cfg->ecc_cfgs[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (i >= NFC_ECC_MAX_MODES)\n\t\treturn -EINVAL;\n\n\twritel(reg, nfc->regs + nfc->cfg->bchctl_off);\n\n\t \n\tnfc->cur_ecc = strength;\n\n\treturn 0;\n}\n\nstatic void rk_nfc_select_chip(struct nand_chip *chip, int cs)\n{\n\tstruct rk_nfc *nfc = nand_get_controller_data(chip);\n\tstruct rk_nfc_nand_chip *rknand = rk_nfc_to_rknand(chip);\n\tstruct nand_ecc_ctrl *ecc = &chip->ecc;\n\tu32 val;\n\n\tif (cs < 0) {\n\t\tnfc->selected_bank = -1;\n\t\t \n\t\tval = readl_relaxed(nfc->regs + NFC_FMCTL);\n\t\tval &= ~FMCTL_CE_SEL_M;\n\t\twritel(val, nfc->regs + NFC_FMCTL);\n\t\treturn;\n\t}\n\n\tnfc->selected_bank = rknand->sels[cs];\n\tnfc->band_offset = NFC_BANK + nfc->selected_bank * NFC_BANK_STEP;\n\n\tval = readl_relaxed(nfc->regs + NFC_FMCTL);\n\tval &= ~FMCTL_CE_SEL_M;\n\tval |= FMCTL_CE_SEL(nfc->selected_bank);\n\n\twritel(val, nfc->regs + NFC_FMCTL);\n\n\t \n\tif (nfc->cur_timing != rknand->timing) {\n\t\twritel(rknand->timing, nfc->regs + NFC_FMWAIT);\n\t\tnfc->cur_timing = rknand->timing;\n\t}\n\n\t \n\tif (nfc->cur_ecc != ecc->strength)\n\t\trk_nfc_hw_ecc_setup(chip, ecc->strength);\n}\n\nstatic inline int rk_nfc_wait_ioready(struct rk_nfc *nfc)\n{\n\tint rc;\n\tu32 val;\n\n\trc = readl_relaxed_poll_timeout(nfc->regs + NFC_FMCTL, val,\n\t\t\t\t\tval & FMCTL_RDY, 10, NFC_TIMEOUT);\n\n\treturn rc;\n}\n\nstatic void rk_nfc_read_buf(struct rk_nfc *nfc, u8 *buf, int len)\n{\n\tint i;\n\n\tfor (i = 0; i < len; i++)\n\t\tbuf[i] = readb_relaxed(nfc->regs + nfc->band_offset +\n\t\t\t\t       BANK_DATA);\n}\n\nstatic void rk_nfc_write_buf(struct rk_nfc *nfc, const u8 *buf, int len)\n{\n\tint i;\n\n\tfor (i = 0; i < len; i++)\n\t\twriteb(buf[i], nfc->regs + nfc->band_offset + BANK_DATA);\n}\n\nstatic int rk_nfc_cmd(struct nand_chip *chip,\n\t\t      const struct nand_subop *subop)\n{\n\tstruct rk_nfc *nfc = nand_get_controller_data(chip);\n\tunsigned int i, j, remaining, start;\n\tint reg_offset = nfc->band_offset;\n\tu8 *inbuf = NULL;\n\tconst u8 *outbuf;\n\tu32 cnt = 0;\n\tint ret = 0;\n\n\tfor (i = 0; i < subop->ninstrs; i++) {\n\t\tconst struct nand_op_instr *instr = &subop->instrs[i];\n\n\t\tswitch (instr->type) {\n\t\tcase NAND_OP_CMD_INSTR:\n\t\t\twriteb(instr->ctx.cmd.opcode,\n\t\t\t       nfc->regs + reg_offset + BANK_CMD);\n\t\t\tbreak;\n\n\t\tcase NAND_OP_ADDR_INSTR:\n\t\t\tremaining = nand_subop_get_num_addr_cyc(subop, i);\n\t\t\tstart = nand_subop_get_addr_start_off(subop, i);\n\n\t\t\tfor (j = 0; j < 8 && j + start < remaining; j++)\n\t\t\t\twriteb(instr->ctx.addr.addrs[j + start],\n\t\t\t\t       nfc->regs + reg_offset + BANK_ADDR);\n\t\t\tbreak;\n\n\t\tcase NAND_OP_DATA_IN_INSTR:\n\t\tcase NAND_OP_DATA_OUT_INSTR:\n\t\t\tstart = nand_subop_get_data_start_off(subop, i);\n\t\t\tcnt = nand_subop_get_data_len(subop, i);\n\n\t\t\tif (instr->type == NAND_OP_DATA_OUT_INSTR) {\n\t\t\t\toutbuf = instr->ctx.data.buf.out + start;\n\t\t\t\trk_nfc_write_buf(nfc, outbuf, cnt);\n\t\t\t} else {\n\t\t\t\tinbuf = instr->ctx.data.buf.in + start;\n\t\t\t\trk_nfc_read_buf(nfc, inbuf, cnt);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase NAND_OP_WAITRDY_INSTR:\n\t\t\tif (rk_nfc_wait_ioready(nfc) < 0) {\n\t\t\t\tret = -ETIMEDOUT;\n\t\t\t\tdev_err(nfc->dev, \"IO not ready\\n\");\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic const struct nand_op_parser rk_nfc_op_parser = NAND_OP_PARSER(\n\tNAND_OP_PARSER_PATTERN(\n\t\trk_nfc_cmd,\n\t\tNAND_OP_PARSER_PAT_CMD_ELEM(true),\n\t\tNAND_OP_PARSER_PAT_ADDR_ELEM(true, MAX_ADDRESS_CYC),\n\t\tNAND_OP_PARSER_PAT_CMD_ELEM(true),\n\t\tNAND_OP_PARSER_PAT_WAITRDY_ELEM(true),\n\t\tNAND_OP_PARSER_PAT_DATA_IN_ELEM(true, MAX_DATA_SIZE)),\n\tNAND_OP_PARSER_PATTERN(\n\t\trk_nfc_cmd,\n\t\tNAND_OP_PARSER_PAT_CMD_ELEM(true),\n\t\tNAND_OP_PARSER_PAT_ADDR_ELEM(true, MAX_ADDRESS_CYC),\n\t\tNAND_OP_PARSER_PAT_DATA_OUT_ELEM(true, MAX_DATA_SIZE),\n\t\tNAND_OP_PARSER_PAT_CMD_ELEM(true),\n\t\tNAND_OP_PARSER_PAT_WAITRDY_ELEM(true)),\n);\n\nstatic int rk_nfc_exec_op(struct nand_chip *chip,\n\t\t\t  const struct nand_operation *op,\n\t\t\t  bool check_only)\n{\n\tif (!check_only)\n\t\trk_nfc_select_chip(chip, op->cs);\n\n\treturn nand_op_parser_exec_op(chip, &rk_nfc_op_parser, op,\n\t\t\t\t      check_only);\n}\n\nstatic int rk_nfc_setup_interface(struct nand_chip *chip, int target,\n\t\t\t\t  const struct nand_interface_config *conf)\n{\n\tstruct rk_nfc_nand_chip *rknand = rk_nfc_to_rknand(chip);\n\tstruct rk_nfc *nfc = nand_get_controller_data(chip);\n\tconst struct nand_sdr_timings *timings;\n\tu32 rate, tc2rw, trwpw, trw2c;\n\tu32 temp;\n\n\tif (target < 0)\n\t\treturn 0;\n\n\ttimings = nand_get_sdr_timings(conf);\n\tif (IS_ERR(timings))\n\t\treturn -EOPNOTSUPP;\n\n\tif (IS_ERR(nfc->nfc_clk))\n\t\trate = clk_get_rate(nfc->ahb_clk);\n\telse\n\t\trate = clk_get_rate(nfc->nfc_clk);\n\n\t \n\trate /= 1000;\n\n\ttc2rw = 1;\n\ttrw2c = 1;\n\n\ttrwpw = max(timings->tWC_min, timings->tRC_min) / 1000;\n\ttrwpw = DIV_ROUND_UP(trwpw * rate, 1000000);\n\n\ttemp = timings->tREA_max / 1000;\n\ttemp = DIV_ROUND_UP(temp * rate, 1000000);\n\n\tif (trwpw < temp)\n\t\ttrwpw = temp;\n\n\t \n\n\t \n\trknand->timing = ACCTIMING(tc2rw, trwpw, trw2c);\n\n\treturn 0;\n}\n\nstatic void rk_nfc_xfer_start(struct rk_nfc *nfc, u8 rw, u8 n_KB,\n\t\t\t      dma_addr_t dma_data, dma_addr_t dma_oob)\n{\n\tu32 dma_reg, fl_reg, bch_reg;\n\n\tdma_reg = DMA_ST | ((!rw) << DMA_WR) | DMA_EN | (2 << DMA_AHB_SIZE) |\n\t      (7 << DMA_BURST_SIZE) | (16 << DMA_INC_NUM);\n\n\tfl_reg = (rw << FLCTL_WR) | FLCTL_XFER_EN | FLCTL_ACORRECT |\n\t\t (n_KB << FLCTL_XFER_SECTOR) | FLCTL_TOG_FIX;\n\n\tif (nfc->cfg->type == NFC_V6 || nfc->cfg->type == NFC_V8) {\n\t\tbch_reg = readl_relaxed(nfc->regs + nfc->cfg->bchctl_off);\n\t\tbch_reg = (bch_reg & (~BCHCTL_BANK_M)) |\n\t\t\t  (nfc->selected_bank << BCHCTL_BANK);\n\t\twritel(bch_reg, nfc->regs + nfc->cfg->bchctl_off);\n\t}\n\n\twritel(dma_reg, nfc->regs + nfc->cfg->dma_cfg_off);\n\twritel((u32)dma_data, nfc->regs + nfc->cfg->dma_data_buf_off);\n\twritel((u32)dma_oob, nfc->regs + nfc->cfg->dma_oob_buf_off);\n\twritel(fl_reg, nfc->regs + nfc->cfg->flctl_off);\n\tfl_reg |= FLCTL_XFER_ST;\n\twritel(fl_reg, nfc->regs + nfc->cfg->flctl_off);\n}\n\nstatic int rk_nfc_wait_for_xfer_done(struct rk_nfc *nfc)\n{\n\tvoid __iomem *ptr;\n\tu32 reg;\n\n\tptr = nfc->regs + nfc->cfg->flctl_off;\n\n\treturn readl_relaxed_poll_timeout(ptr, reg,\n\t\t\t\t\t reg & FLCTL_XFER_READY,\n\t\t\t\t\t 10, NFC_TIMEOUT);\n}\n\nstatic int rk_nfc_write_page_raw(struct nand_chip *chip, const u8 *buf,\n\t\t\t\t int oob_on, int page)\n{\n\tstruct rk_nfc_nand_chip *rknand = rk_nfc_to_rknand(chip);\n\tstruct rk_nfc *nfc = nand_get_controller_data(chip);\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tstruct nand_ecc_ctrl *ecc = &chip->ecc;\n\tint i, pages_per_blk;\n\n\tpages_per_blk = mtd->erasesize / mtd->writesize;\n\tif ((chip->options & NAND_IS_BOOT_MEDIUM) &&\n\t    (page < (pages_per_blk * rknand->boot_blks)) &&\n\t    rknand->boot_ecc != ecc->strength) {\n\t\t \n\t\treturn -EIO;\n\t}\n\n\tif (!buf)\n\t\tmemset(nfc->page_buf, 0xff, mtd->writesize + mtd->oobsize);\n\n\tfor (i = 0; i < ecc->steps; i++) {\n\t\t \n\t\tif (buf)\n\t\t\tmemcpy(rk_nfc_data_ptr(chip, i),\n\t\t\t       rk_nfc_buf_to_data_ptr(chip, buf, i),\n\t\t\t       ecc->size);\n\t\t \n\t\tif (!i)\n\t\t\tmemcpy(rk_nfc_oob_ptr(chip, i),\n\t\t\t       rk_nfc_buf_to_oob_ptr(chip, ecc->steps - 1),\n\t\t\t       NFC_SYS_DATA_SIZE);\n\t\telse\n\t\t\tmemcpy(rk_nfc_oob_ptr(chip, i),\n\t\t\t       rk_nfc_buf_to_oob_ptr(chip, i - 1),\n\t\t\t       NFC_SYS_DATA_SIZE);\n\t\t \n\t\tmemcpy(rk_nfc_oob_ptr(chip, i) + NFC_SYS_DATA_SIZE,\n\t\t       rk_nfc_buf_to_oob_ecc_ptr(chip, i),\n\t\t       ecc->bytes);\n\t}\n\n\tnand_prog_page_begin_op(chip, page, 0, NULL, 0);\n\trk_nfc_write_buf(nfc, buf, mtd->writesize + mtd->oobsize);\n\treturn nand_prog_page_end_op(chip);\n}\n\nstatic int rk_nfc_write_page_hwecc(struct nand_chip *chip, const u8 *buf,\n\t\t\t\t   int oob_on, int page)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tstruct rk_nfc *nfc = nand_get_controller_data(chip);\n\tstruct rk_nfc_nand_chip *rknand = rk_nfc_to_rknand(chip);\n\tstruct nand_ecc_ctrl *ecc = &chip->ecc;\n\tint oob_step = (ecc->bytes > 60) ? NFC_MAX_OOB_PER_STEP :\n\t\t\tNFC_MIN_OOB_PER_STEP;\n\tint pages_per_blk = mtd->erasesize / mtd->writesize;\n\tint ret = 0, i, boot_rom_mode = 0;\n\tdma_addr_t dma_data, dma_oob;\n\tu32 tmp;\n\tu8 *oob;\n\n\tnand_prog_page_begin_op(chip, page, 0, NULL, 0);\n\n\tif (buf)\n\t\tmemcpy(nfc->page_buf, buf, mtd->writesize);\n\telse\n\t\tmemset(nfc->page_buf, 0xFF, mtd->writesize);\n\n\t \n\tif ((page < (pages_per_blk * rknand->boot_blks)) &&\n\t    (chip->options & NAND_IS_BOOT_MEDIUM)) {\n\t\tboot_rom_mode = 1;\n\t\tif (rknand->boot_ecc != ecc->strength)\n\t\t\trk_nfc_hw_ecc_setup(chip, rknand->boot_ecc);\n\t}\n\n\tfor (i = 0; i < ecc->steps; i++) {\n\t\tif (!i)\n\t\t\toob = chip->oob_poi + (ecc->steps - 1) * NFC_SYS_DATA_SIZE;\n\t\telse\n\t\t\toob = chip->oob_poi + (i - 1) * NFC_SYS_DATA_SIZE;\n\n\t\ttmp = oob[0] | oob[1] << 8 | oob[2] << 16 | oob[3] << 24;\n\n\t\tif (nfc->cfg->type == NFC_V9)\n\t\t\tnfc->oob_buf[i] = tmp;\n\t\telse\n\t\t\tnfc->oob_buf[i * (oob_step / 4)] = tmp;\n\t}\n\n\tdma_data = dma_map_single(nfc->dev, (void *)nfc->page_buf,\n\t\t\t\t  mtd->writesize, DMA_TO_DEVICE);\n\tdma_oob = dma_map_single(nfc->dev, nfc->oob_buf,\n\t\t\t\t ecc->steps * oob_step,\n\t\t\t\t DMA_TO_DEVICE);\n\n\treinit_completion(&nfc->done);\n\twritel(INT_DMA, nfc->regs + nfc->cfg->int_en_off);\n\n\trk_nfc_xfer_start(nfc, NFC_WRITE, ecc->steps, dma_data,\n\t\t\t  dma_oob);\n\tret = wait_for_completion_timeout(&nfc->done,\n\t\t\t\t\t  msecs_to_jiffies(100));\n\tif (!ret)\n\t\tdev_warn(nfc->dev, \"write: wait dma done timeout.\\n\");\n\t \n\tret = rk_nfc_wait_for_xfer_done(nfc);\n\n\tdma_unmap_single(nfc->dev, dma_data, mtd->writesize,\n\t\t\t DMA_TO_DEVICE);\n\tdma_unmap_single(nfc->dev, dma_oob, ecc->steps * oob_step,\n\t\t\t DMA_TO_DEVICE);\n\n\tif (boot_rom_mode && rknand->boot_ecc != ecc->strength)\n\t\trk_nfc_hw_ecc_setup(chip, ecc->strength);\n\n\tif (ret) {\n\t\tdev_err(nfc->dev, \"write: wait transfer done timeout.\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\treturn nand_prog_page_end_op(chip);\n}\n\nstatic int rk_nfc_write_oob(struct nand_chip *chip, int page)\n{\n\treturn rk_nfc_write_page_hwecc(chip, NULL, 1, page);\n}\n\nstatic int rk_nfc_read_page_raw(struct nand_chip *chip, u8 *buf, int oob_on,\n\t\t\t\tint page)\n{\n\tstruct rk_nfc_nand_chip *rknand = rk_nfc_to_rknand(chip);\n\tstruct rk_nfc *nfc = nand_get_controller_data(chip);\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tstruct nand_ecc_ctrl *ecc = &chip->ecc;\n\tint i, pages_per_blk;\n\n\tpages_per_blk = mtd->erasesize / mtd->writesize;\n\tif ((chip->options & NAND_IS_BOOT_MEDIUM) &&\n\t    (page < (pages_per_blk * rknand->boot_blks)) &&\n\t    rknand->boot_ecc != ecc->strength) {\n\t\t \n\t\treturn -EIO;\n\t}\n\n\tnand_read_page_op(chip, page, 0, NULL, 0);\n\trk_nfc_read_buf(nfc, nfc->page_buf, mtd->writesize + mtd->oobsize);\n\tfor (i = 0; i < ecc->steps; i++) {\n\t\t \n\t\tif (!i)\n\t\t\tmemcpy(rk_nfc_buf_to_oob_ptr(chip, ecc->steps - 1),\n\t\t\t       rk_nfc_oob_ptr(chip, i),\n\t\t\t       NFC_SYS_DATA_SIZE);\n\t\telse\n\t\t\tmemcpy(rk_nfc_buf_to_oob_ptr(chip, i - 1),\n\t\t\t       rk_nfc_oob_ptr(chip, i),\n\t\t\t       NFC_SYS_DATA_SIZE);\n\n\t\t \n\t\tmemcpy(rk_nfc_buf_to_oob_ecc_ptr(chip, i),\n\t\t       rk_nfc_oob_ptr(chip, i) + NFC_SYS_DATA_SIZE,\n\t\t       ecc->bytes);\n\n\t\t \n\t\tif (buf)\n\t\t\tmemcpy(rk_nfc_buf_to_data_ptr(chip, buf, i),\n\t\t\t       rk_nfc_data_ptr(chip, i),\n\t\t\t       ecc->size);\n\t}\n\n\treturn 0;\n}\n\nstatic int rk_nfc_read_page_hwecc(struct nand_chip *chip, u8 *buf, int oob_on,\n\t\t\t\t  int page)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tstruct rk_nfc *nfc = nand_get_controller_data(chip);\n\tstruct rk_nfc_nand_chip *rknand = rk_nfc_to_rknand(chip);\n\tstruct nand_ecc_ctrl *ecc = &chip->ecc;\n\tint oob_step = (ecc->bytes > 60) ? NFC_MAX_OOB_PER_STEP :\n\t\t\tNFC_MIN_OOB_PER_STEP;\n\tint pages_per_blk = mtd->erasesize / mtd->writesize;\n\tdma_addr_t dma_data, dma_oob;\n\tint ret = 0, i, cnt, boot_rom_mode = 0;\n\tint max_bitflips = 0, bch_st, ecc_fail = 0;\n\tu8 *oob;\n\tu32 tmp;\n\n\tnand_read_page_op(chip, page, 0, NULL, 0);\n\n\tdma_data = dma_map_single(nfc->dev, nfc->page_buf,\n\t\t\t\t  mtd->writesize,\n\t\t\t\t  DMA_FROM_DEVICE);\n\tdma_oob = dma_map_single(nfc->dev, nfc->oob_buf,\n\t\t\t\t ecc->steps * oob_step,\n\t\t\t\t DMA_FROM_DEVICE);\n\n\t \n\tif ((page < (pages_per_blk * rknand->boot_blks)) &&\n\t    (chip->options & NAND_IS_BOOT_MEDIUM)) {\n\t\tboot_rom_mode = 1;\n\t\tif (rknand->boot_ecc != ecc->strength)\n\t\t\trk_nfc_hw_ecc_setup(chip, rknand->boot_ecc);\n\t}\n\n\treinit_completion(&nfc->done);\n\twritel(INT_DMA, nfc->regs + nfc->cfg->int_en_off);\n\trk_nfc_xfer_start(nfc, NFC_READ, ecc->steps, dma_data,\n\t\t\t  dma_oob);\n\tret = wait_for_completion_timeout(&nfc->done,\n\t\t\t\t\t  msecs_to_jiffies(100));\n\tif (!ret)\n\t\tdev_warn(nfc->dev, \"read: wait dma done timeout.\\n\");\n\t \n\tret = rk_nfc_wait_for_xfer_done(nfc);\n\n\tdma_unmap_single(nfc->dev, dma_data, mtd->writesize,\n\t\t\t DMA_FROM_DEVICE);\n\tdma_unmap_single(nfc->dev, dma_oob, ecc->steps * oob_step,\n\t\t\t DMA_FROM_DEVICE);\n\n\tif (ret) {\n\t\tret = -ETIMEDOUT;\n\t\tdev_err(nfc->dev, \"read: wait transfer done timeout.\\n\");\n\t\tgoto timeout_err;\n\t}\n\n\tfor (i = 0; i < ecc->steps; i++) {\n\t\tif (!i)\n\t\t\toob = chip->oob_poi + (ecc->steps - 1) * NFC_SYS_DATA_SIZE;\n\t\telse\n\t\t\toob = chip->oob_poi + (i - 1) * NFC_SYS_DATA_SIZE;\n\n\t\tif (nfc->cfg->type == NFC_V9)\n\t\t\ttmp = nfc->oob_buf[i];\n\t\telse\n\t\t\ttmp = nfc->oob_buf[i * (oob_step / 4)];\n\n\t\t*oob++ = (u8)tmp;\n\t\t*oob++ = (u8)(tmp >> 8);\n\t\t*oob++ = (u8)(tmp >> 16);\n\t\t*oob++ = (u8)(tmp >> 24);\n\t}\n\n\tfor (i = 0; i < (ecc->steps / 2); i++) {\n\t\tbch_st = readl_relaxed(nfc->regs +\n\t\t\t\t       nfc->cfg->bch_st_off + i * 4);\n\t\tif (bch_st & BIT(nfc->cfg->ecc0.err_flag_bit) ||\n\t\t    bch_st & BIT(nfc->cfg->ecc1.err_flag_bit)) {\n\t\t\tmtd->ecc_stats.failed++;\n\t\t\tecc_fail = 1;\n\t\t} else {\n\t\t\tcnt = ECC_ERR_CNT(bch_st, nfc->cfg->ecc0);\n\t\t\tmtd->ecc_stats.corrected += cnt;\n\t\t\tmax_bitflips = max_t(u32, max_bitflips, cnt);\n\n\t\t\tcnt = ECC_ERR_CNT(bch_st, nfc->cfg->ecc1);\n\t\t\tmtd->ecc_stats.corrected += cnt;\n\t\t\tmax_bitflips = max_t(u32, max_bitflips, cnt);\n\t\t}\n\t}\n\n\tif (buf)\n\t\tmemcpy(buf, nfc->page_buf, mtd->writesize);\n\ntimeout_err:\n\tif (boot_rom_mode && rknand->boot_ecc != ecc->strength)\n\t\trk_nfc_hw_ecc_setup(chip, ecc->strength);\n\n\tif (ret)\n\t\treturn ret;\n\n\tif (ecc_fail) {\n\t\tdev_err(nfc->dev, \"read page: %x ecc error!\\n\", page);\n\t\treturn 0;\n\t}\n\n\treturn max_bitflips;\n}\n\nstatic int rk_nfc_read_oob(struct nand_chip *chip, int page)\n{\n\treturn rk_nfc_read_page_hwecc(chip, NULL, 1, page);\n}\n\nstatic inline void rk_nfc_hw_init(struct rk_nfc *nfc)\n{\n\t \n\twritel(FMCTL_WP, nfc->regs + NFC_FMCTL);\n\t \n\twritel(0x1081, nfc->regs + NFC_FMWAIT);\n\tnfc->cur_timing = 0x1081;\n\t \n\twritel(0, nfc->regs + nfc->cfg->randmz_off);\n\twritel(0, nfc->regs + nfc->cfg->dma_cfg_off);\n\twritel(FLCTL_RST, nfc->regs + nfc->cfg->flctl_off);\n}\n\nstatic irqreturn_t rk_nfc_irq(int irq, void *id)\n{\n\tstruct rk_nfc *nfc = id;\n\tu32 sta, ien;\n\n\tsta = readl_relaxed(nfc->regs + nfc->cfg->int_st_off);\n\tien = readl_relaxed(nfc->regs + nfc->cfg->int_en_off);\n\n\tif (!(sta & ien))\n\t\treturn IRQ_NONE;\n\n\twritel(sta, nfc->regs + nfc->cfg->int_clr_off);\n\twritel(~sta & ien, nfc->regs + nfc->cfg->int_en_off);\n\n\tcomplete(&nfc->done);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int rk_nfc_enable_clks(struct device *dev, struct rk_nfc *nfc)\n{\n\tint ret;\n\n\tif (!IS_ERR(nfc->nfc_clk)) {\n\t\tret = clk_prepare_enable(nfc->nfc_clk);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"failed to enable NFC clk\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tret = clk_prepare_enable(nfc->ahb_clk);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to enable ahb clk\\n\");\n\t\tclk_disable_unprepare(nfc->nfc_clk);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void rk_nfc_disable_clks(struct rk_nfc *nfc)\n{\n\tclk_disable_unprepare(nfc->nfc_clk);\n\tclk_disable_unprepare(nfc->ahb_clk);\n}\n\nstatic int rk_nfc_ooblayout_free(struct mtd_info *mtd, int section,\n\t\t\t\t struct mtd_oob_region *oob_region)\n{\n\tstruct nand_chip *chip = mtd_to_nand(mtd);\n\tstruct rk_nfc_nand_chip *rknand = rk_nfc_to_rknand(chip);\n\n\tif (section)\n\t\treturn -ERANGE;\n\n\toob_region->length = rknand->metadata_size - NFC_SYS_DATA_SIZE - 2;\n\toob_region->offset = 2;\n\n\treturn 0;\n}\n\nstatic int rk_nfc_ooblayout_ecc(struct mtd_info *mtd, int section,\n\t\t\t\tstruct mtd_oob_region *oob_region)\n{\n\tstruct nand_chip *chip = mtd_to_nand(mtd);\n\tstruct rk_nfc_nand_chip *rknand = rk_nfc_to_rknand(chip);\n\n\tif (section)\n\t\treturn -ERANGE;\n\n\toob_region->length = mtd->oobsize - rknand->metadata_size;\n\toob_region->offset = rknand->metadata_size;\n\n\treturn 0;\n}\n\nstatic const struct mtd_ooblayout_ops rk_nfc_ooblayout_ops = {\n\t.free = rk_nfc_ooblayout_free,\n\t.ecc = rk_nfc_ooblayout_ecc,\n};\n\nstatic int rk_nfc_ecc_init(struct device *dev, struct mtd_info *mtd)\n{\n\tstruct nand_chip *chip = mtd_to_nand(mtd);\n\tstruct rk_nfc *nfc = nand_get_controller_data(chip);\n\tstruct nand_ecc_ctrl *ecc = &chip->ecc;\n\tconst u8 *strengths = nfc->cfg->ecc_strengths;\n\tu8 max_strength, nfc_max_strength;\n\tint i;\n\n\tnfc_max_strength = nfc->cfg->ecc_strengths[0];\n\t \n\tif (!ecc->size || !ecc->strength ||\n\t    ecc->strength > nfc_max_strength) {\n\t\tchip->ecc.size = 1024;\n\t\tecc->steps = mtd->writesize / ecc->size;\n\n\t\t \n\t\tmax_strength = ((mtd->oobsize / ecc->steps) - 4) * 8 /\n\t\t\t\t fls(8 * 1024);\n\t\tif (max_strength > nfc_max_strength)\n\t\t\tmax_strength = nfc_max_strength;\n\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tif (max_strength >= strengths[i])\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (i >= 4) {\n\t\t\tdev_err(nfc->dev, \"unsupported ECC strength\\n\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\n\t\tecc->strength = strengths[i];\n\t}\n\tecc->steps = mtd->writesize / ecc->size;\n\tecc->bytes = DIV_ROUND_UP(ecc->strength * fls(8 * chip->ecc.size), 8);\n\n\treturn 0;\n}\n\nstatic int rk_nfc_attach_chip(struct nand_chip *chip)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tstruct device *dev = mtd->dev.parent;\n\tstruct rk_nfc *nfc = nand_get_controller_data(chip);\n\tstruct rk_nfc_nand_chip *rknand = rk_nfc_to_rknand(chip);\n\tstruct nand_ecc_ctrl *ecc = &chip->ecc;\n\tint new_page_len, new_oob_len;\n\tvoid *buf;\n\tint ret;\n\n\tif (chip->options & NAND_BUSWIDTH_16) {\n\t\tdev_err(dev, \"16 bits bus width not supported\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (ecc->engine_type != NAND_ECC_ENGINE_TYPE_ON_HOST)\n\t\treturn 0;\n\n\tret = rk_nfc_ecc_init(dev, mtd);\n\tif (ret)\n\t\treturn ret;\n\n\trknand->metadata_size = NFC_SYS_DATA_SIZE * ecc->steps;\n\n\tif (rknand->metadata_size < NFC_SYS_DATA_SIZE + 2) {\n\t\tdev_err(dev,\n\t\t\t\"driver needs at least %d bytes of meta data\\n\",\n\t\t\tNFC_SYS_DATA_SIZE + 2);\n\t\treturn -EIO;\n\t}\n\n\t \n\tnew_page_len = mtd->writesize + mtd->oobsize;\n\tif (nfc->page_buf && new_page_len > nfc->page_buf_size) {\n\t\tbuf = krealloc(nfc->page_buf, new_page_len,\n\t\t\t       GFP_KERNEL | GFP_DMA);\n\t\tif (!buf)\n\t\t\treturn -ENOMEM;\n\t\tnfc->page_buf = buf;\n\t\tnfc->page_buf_size = new_page_len;\n\t}\n\n\tnew_oob_len = ecc->steps * NFC_MAX_OOB_PER_STEP;\n\tif (nfc->oob_buf && new_oob_len > nfc->oob_buf_size) {\n\t\tbuf = krealloc(nfc->oob_buf, new_oob_len,\n\t\t\t       GFP_KERNEL | GFP_DMA);\n\t\tif (!buf) {\n\t\t\tkfree(nfc->page_buf);\n\t\t\tnfc->page_buf = NULL;\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tnfc->oob_buf = buf;\n\t\tnfc->oob_buf_size = new_oob_len;\n\t}\n\n\tif (!nfc->page_buf) {\n\t\tnfc->page_buf = kzalloc(new_page_len, GFP_KERNEL | GFP_DMA);\n\t\tif (!nfc->page_buf)\n\t\t\treturn -ENOMEM;\n\t\tnfc->page_buf_size = new_page_len;\n\t}\n\n\tif (!nfc->oob_buf) {\n\t\tnfc->oob_buf = kzalloc(new_oob_len, GFP_KERNEL | GFP_DMA);\n\t\tif (!nfc->oob_buf) {\n\t\t\tkfree(nfc->page_buf);\n\t\t\tnfc->page_buf = NULL;\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tnfc->oob_buf_size = new_oob_len;\n\t}\n\n\tchip->ecc.write_page_raw = rk_nfc_write_page_raw;\n\tchip->ecc.write_page = rk_nfc_write_page_hwecc;\n\tchip->ecc.write_oob = rk_nfc_write_oob;\n\n\tchip->ecc.read_page_raw = rk_nfc_read_page_raw;\n\tchip->ecc.read_page = rk_nfc_read_page_hwecc;\n\tchip->ecc.read_oob = rk_nfc_read_oob;\n\n\treturn 0;\n}\n\nstatic const struct nand_controller_ops rk_nfc_controller_ops = {\n\t.attach_chip = rk_nfc_attach_chip,\n\t.exec_op = rk_nfc_exec_op,\n\t.setup_interface = rk_nfc_setup_interface,\n};\n\nstatic int rk_nfc_nand_chip_init(struct device *dev, struct rk_nfc *nfc,\n\t\t\t\t struct device_node *np)\n{\n\tstruct rk_nfc_nand_chip *rknand;\n\tstruct nand_chip *chip;\n\tstruct mtd_info *mtd;\n\tint nsels;\n\tu32 tmp;\n\tint ret;\n\tint i;\n\n\tif (!of_get_property(np, \"reg\", &nsels))\n\t\treturn -ENODEV;\n\tnsels /= sizeof(u32);\n\tif (!nsels || nsels > NFC_MAX_NSELS) {\n\t\tdev_err(dev, \"invalid reg property size %d\\n\", nsels);\n\t\treturn -EINVAL;\n\t}\n\n\trknand = devm_kzalloc(dev, sizeof(*rknand) + nsels * sizeof(u8),\n\t\t\t      GFP_KERNEL);\n\tif (!rknand)\n\t\treturn -ENOMEM;\n\n\trknand->nsels = nsels;\n\tfor (i = 0; i < nsels; i++) {\n\t\tret = of_property_read_u32_index(np, \"reg\", i, &tmp);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"reg property failure : %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (tmp >= NFC_MAX_NSELS) {\n\t\t\tdev_err(dev, \"invalid CS: %u\\n\", tmp);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (test_and_set_bit(tmp, &nfc->assigned_cs)) {\n\t\t\tdev_err(dev, \"CS %u already assigned\\n\", tmp);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\trknand->sels[i] = tmp;\n\t}\n\n\tchip = &rknand->chip;\n\tchip->controller = &nfc->controller;\n\n\tnand_set_flash_node(chip, np);\n\n\tnand_set_controller_data(chip, nfc);\n\n\tchip->options |= NAND_USES_DMA | NAND_NO_SUBPAGE_WRITE;\n\tchip->bbt_options = NAND_BBT_USE_FLASH | NAND_BBT_NO_OOB;\n\n\t \n\tchip->ecc.engine_type = NAND_ECC_ENGINE_TYPE_ON_HOST;\n\n\tmtd = nand_to_mtd(chip);\n\tmtd->owner = THIS_MODULE;\n\tmtd->dev.parent = dev;\n\n\tif (!mtd->name) {\n\t\tdev_err(nfc->dev, \"NAND label property is mandatory\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tmtd_set_ooblayout(mtd, &rk_nfc_ooblayout_ops);\n\trk_nfc_hw_init(nfc);\n\tret = nand_scan(chip, nsels);\n\tif (ret)\n\t\treturn ret;\n\n\tif (chip->options & NAND_IS_BOOT_MEDIUM) {\n\t\tret = of_property_read_u32(np, \"rockchip,boot-blks\", &tmp);\n\t\trknand->boot_blks = ret ? 0 : tmp;\n\n\t\tret = of_property_read_u32(np, \"rockchip,boot-ecc-strength\",\n\t\t\t\t\t   &tmp);\n\t\trknand->boot_ecc = ret ? chip->ecc.strength : tmp;\n\t}\n\n\tret = mtd_device_register(mtd, NULL, 0);\n\tif (ret) {\n\t\tdev_err(dev, \"MTD parse partition error\\n\");\n\t\tnand_cleanup(chip);\n\t\treturn ret;\n\t}\n\n\tlist_add_tail(&rknand->node, &nfc->chips);\n\n\treturn 0;\n}\n\nstatic void rk_nfc_chips_cleanup(struct rk_nfc *nfc)\n{\n\tstruct rk_nfc_nand_chip *rknand, *tmp;\n\tstruct nand_chip *chip;\n\tint ret;\n\n\tlist_for_each_entry_safe(rknand, tmp, &nfc->chips, node) {\n\t\tchip = &rknand->chip;\n\t\tret = mtd_device_unregister(nand_to_mtd(chip));\n\t\tWARN_ON(ret);\n\t\tnand_cleanup(chip);\n\t\tlist_del(&rknand->node);\n\t}\n}\n\nstatic int rk_nfc_nand_chips_init(struct device *dev, struct rk_nfc *nfc)\n{\n\tstruct device_node *np = dev->of_node, *nand_np;\n\tint nchips = of_get_child_count(np);\n\tint ret;\n\n\tif (!nchips || nchips > NFC_MAX_NSELS) {\n\t\tdev_err(nfc->dev, \"incorrect number of NAND chips (%d)\\n\",\n\t\t\tnchips);\n\t\treturn -EINVAL;\n\t}\n\n\tfor_each_child_of_node(np, nand_np) {\n\t\tret = rk_nfc_nand_chip_init(dev, nfc, nand_np);\n\t\tif (ret) {\n\t\t\tof_node_put(nand_np);\n\t\t\trk_nfc_chips_cleanup(nfc);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic struct nfc_cfg nfc_v6_cfg = {\n\t\t.type\t\t\t= NFC_V6,\n\t\t.ecc_strengths\t\t= {60, 40, 24, 16},\n\t\t.ecc_cfgs\t\t= {\n\t\t\t0x00040011, 0x00040001, 0x00000011, 0x00000001,\n\t\t},\n\t\t.flctl_off\t\t= 0x08,\n\t\t.bchctl_off\t\t= 0x0C,\n\t\t.dma_cfg_off\t\t= 0x10,\n\t\t.dma_data_buf_off\t= 0x14,\n\t\t.dma_oob_buf_off\t= 0x18,\n\t\t.dma_st_off\t\t= 0x1C,\n\t\t.bch_st_off\t\t= 0x20,\n\t\t.randmz_off\t\t= 0x150,\n\t\t.int_en_off\t\t= 0x16C,\n\t\t.int_clr_off\t\t= 0x170,\n\t\t.int_st_off\t\t= 0x174,\n\t\t.oob0_off\t\t= 0x200,\n\t\t.oob1_off\t\t= 0x230,\n\t\t.ecc0\t\t\t= {\n\t\t\t.err_flag_bit\t= 2,\n\t\t\t.low\t\t= 3,\n\t\t\t.low_mask\t= 0x1F,\n\t\t\t.low_bn\t\t= 5,\n\t\t\t.high\t\t= 27,\n\t\t\t.high_mask\t= 0x1,\n\t\t},\n\t\t.ecc1\t\t\t= {\n\t\t\t.err_flag_bit\t= 15,\n\t\t\t.low\t\t= 16,\n\t\t\t.low_mask\t= 0x1F,\n\t\t\t.low_bn\t\t= 5,\n\t\t\t.high\t\t= 29,\n\t\t\t.high_mask\t= 0x1,\n\t\t},\n};\n\nstatic struct nfc_cfg nfc_v8_cfg = {\n\t\t.type\t\t\t= NFC_V8,\n\t\t.ecc_strengths\t\t= {16, 16, 16, 16},\n\t\t.ecc_cfgs\t\t= {\n\t\t\t0x00000001, 0x00000001, 0x00000001, 0x00000001,\n\t\t},\n\t\t.flctl_off\t\t= 0x08,\n\t\t.bchctl_off\t\t= 0x0C,\n\t\t.dma_cfg_off\t\t= 0x10,\n\t\t.dma_data_buf_off\t= 0x14,\n\t\t.dma_oob_buf_off\t= 0x18,\n\t\t.dma_st_off\t\t= 0x1C,\n\t\t.bch_st_off\t\t= 0x20,\n\t\t.randmz_off\t\t= 0x150,\n\t\t.int_en_off\t\t= 0x16C,\n\t\t.int_clr_off\t\t= 0x170,\n\t\t.int_st_off\t\t= 0x174,\n\t\t.oob0_off\t\t= 0x200,\n\t\t.oob1_off\t\t= 0x230,\n\t\t.ecc0\t\t\t= {\n\t\t\t.err_flag_bit\t= 2,\n\t\t\t.low\t\t= 3,\n\t\t\t.low_mask\t= 0x1F,\n\t\t\t.low_bn\t\t= 5,\n\t\t\t.high\t\t= 27,\n\t\t\t.high_mask\t= 0x1,\n\t\t},\n\t\t.ecc1\t\t\t= {\n\t\t\t.err_flag_bit\t= 15,\n\t\t\t.low\t\t= 16,\n\t\t\t.low_mask\t= 0x1F,\n\t\t\t.low_bn\t\t= 5,\n\t\t\t.high\t\t= 29,\n\t\t\t.high_mask\t= 0x1,\n\t\t},\n};\n\nstatic struct nfc_cfg nfc_v9_cfg = {\n\t\t.type\t\t\t= NFC_V9,\n\t\t.ecc_strengths\t\t= {70, 60, 40, 16},\n\t\t.ecc_cfgs\t\t= {\n\t\t\t0x00000001, 0x06000001, 0x04000001, 0x02000001,\n\t\t},\n\t\t.flctl_off\t\t= 0x10,\n\t\t.bchctl_off\t\t= 0x20,\n\t\t.dma_cfg_off\t\t= 0x30,\n\t\t.dma_data_buf_off\t= 0x34,\n\t\t.dma_oob_buf_off\t= 0x38,\n\t\t.dma_st_off\t\t= 0x3C,\n\t\t.bch_st_off\t\t= 0x150,\n\t\t.randmz_off\t\t= 0x208,\n\t\t.int_en_off\t\t= 0x120,\n\t\t.int_clr_off\t\t= 0x124,\n\t\t.int_st_off\t\t= 0x128,\n\t\t.oob0_off\t\t= 0x200,\n\t\t.oob1_off\t\t= 0x204,\n\t\t.ecc0\t\t\t= {\n\t\t\t.err_flag_bit\t= 2,\n\t\t\t.low\t\t= 3,\n\t\t\t.low_mask\t= 0x7F,\n\t\t\t.low_bn\t\t= 7,\n\t\t\t.high\t\t= 0,\n\t\t\t.high_mask\t= 0x0,\n\t\t},\n\t\t.ecc1\t\t\t= {\n\t\t\t.err_flag_bit\t= 18,\n\t\t\t.low\t\t= 19,\n\t\t\t.low_mask\t= 0x7F,\n\t\t\t.low_bn\t\t= 7,\n\t\t\t.high\t\t= 0,\n\t\t\t.high_mask\t= 0x0,\n\t\t},\n};\n\nstatic const struct of_device_id rk_nfc_id_table[] = {\n\t{\n\t\t.compatible = \"rockchip,px30-nfc\",\n\t\t.data = &nfc_v9_cfg\n\t},\n\t{\n\t\t.compatible = \"rockchip,rk2928-nfc\",\n\t\t.data = &nfc_v6_cfg\n\t},\n\t{\n\t\t.compatible = \"rockchip,rv1108-nfc\",\n\t\t.data = &nfc_v8_cfg\n\t},\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, rk_nfc_id_table);\n\nstatic int rk_nfc_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct rk_nfc *nfc;\n\tint ret, irq;\n\n\tnfc = devm_kzalloc(dev, sizeof(*nfc), GFP_KERNEL);\n\tif (!nfc)\n\t\treturn -ENOMEM;\n\n\tnand_controller_init(&nfc->controller);\n\tINIT_LIST_HEAD(&nfc->chips);\n\tnfc->controller.ops = &rk_nfc_controller_ops;\n\n\tnfc->cfg = of_device_get_match_data(dev);\n\tnfc->dev = dev;\n\n\tinit_completion(&nfc->done);\n\n\tnfc->regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(nfc->regs)) {\n\t\tret = PTR_ERR(nfc->regs);\n\t\tgoto release_nfc;\n\t}\n\n\tnfc->nfc_clk = devm_clk_get(dev, \"nfc\");\n\tif (IS_ERR(nfc->nfc_clk)) {\n\t\tdev_dbg(dev, \"no NFC clk\\n\");\n\t\t \n\t}\n\n\tnfc->ahb_clk = devm_clk_get(dev, \"ahb\");\n\tif (IS_ERR(nfc->ahb_clk)) {\n\t\tdev_err(dev, \"no ahb clk\\n\");\n\t\tret = PTR_ERR(nfc->ahb_clk);\n\t\tgoto release_nfc;\n\t}\n\n\tret = rk_nfc_enable_clks(dev, nfc);\n\tif (ret)\n\t\tgoto release_nfc;\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0) {\n\t\tret = -EINVAL;\n\t\tgoto clk_disable;\n\t}\n\n\twritel(0, nfc->regs + nfc->cfg->int_en_off);\n\tret = devm_request_irq(dev, irq, rk_nfc_irq, 0x0, \"rk-nand\", nfc);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to request NFC irq\\n\");\n\t\tgoto clk_disable;\n\t}\n\n\tplatform_set_drvdata(pdev, nfc);\n\n\tret = rk_nfc_nand_chips_init(dev, nfc);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to init NAND chips\\n\");\n\t\tgoto clk_disable;\n\t}\n\treturn 0;\n\nclk_disable:\n\trk_nfc_disable_clks(nfc);\nrelease_nfc:\n\treturn ret;\n}\n\nstatic void rk_nfc_remove(struct platform_device *pdev)\n{\n\tstruct rk_nfc *nfc = platform_get_drvdata(pdev);\n\n\tkfree(nfc->page_buf);\n\tkfree(nfc->oob_buf);\n\trk_nfc_chips_cleanup(nfc);\n\trk_nfc_disable_clks(nfc);\n}\n\nstatic int __maybe_unused rk_nfc_suspend(struct device *dev)\n{\n\tstruct rk_nfc *nfc = dev_get_drvdata(dev);\n\n\trk_nfc_disable_clks(nfc);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused rk_nfc_resume(struct device *dev)\n{\n\tstruct rk_nfc *nfc = dev_get_drvdata(dev);\n\tstruct rk_nfc_nand_chip *rknand;\n\tstruct nand_chip *chip;\n\tint ret;\n\tu32 i;\n\n\tret = rk_nfc_enable_clks(dev, nfc);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tlist_for_each_entry(rknand, &nfc->chips, node) {\n\t\tchip = &rknand->chip;\n\t\tfor (i = 0; i < rknand->nsels; i++)\n\t\t\tnand_reset(chip, i);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops rk_nfc_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(rk_nfc_suspend, rk_nfc_resume)\n};\n\nstatic struct platform_driver rk_nfc_driver = {\n\t.probe = rk_nfc_probe,\n\t.remove_new = rk_nfc_remove,\n\t.driver = {\n\t\t.name = \"rockchip-nfc\",\n\t\t.of_match_table = rk_nfc_id_table,\n\t\t.pm = &rk_nfc_pm_ops,\n\t},\n};\n\nmodule_platform_driver(rk_nfc_driver);\n\nMODULE_LICENSE(\"Dual MIT/GPL\");\nMODULE_AUTHOR(\"Yifeng Zhao <yifeng.zhao@rock-chips.com>\");\nMODULE_DESCRIPTION(\"Rockchip Nand Flash Controller Driver\");\nMODULE_ALIAS(\"platform:rockchip-nand-controller\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}