{
  "module_name": "arasan-nand-controller.c",
  "hash_id": "8651787a549283af2573c157af84770a6ee6ef91f6004cf5409ff088ba18d259",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/nand/raw/arasan-nand-controller.c",
  "human_readable_source": "\n \n\n#include <linux/bch.h>\n#include <linux/bitfield.h>\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/dma-mapping.h>\n#include <linux/gpio/consumer.h>\n#include <linux/interrupt.h>\n#include <linux/iopoll.h>\n#include <linux/module.h>\n#include <linux/mtd/mtd.h>\n#include <linux/mtd/partitions.h>\n#include <linux/mtd/rawnand.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n\n#define PKT_REG\t\t\t\t0x00\n#define   PKT_SIZE(x)\t\t\tFIELD_PREP(GENMASK(10, 0), (x))\n#define   PKT_STEPS(x)\t\t\tFIELD_PREP(GENMASK(23, 12), (x))\n\n#define MEM_ADDR1_REG\t\t\t0x04\n\n#define MEM_ADDR2_REG\t\t\t0x08\n#define   ADDR2_STRENGTH(x)\t\tFIELD_PREP(GENMASK(27, 25), (x))\n#define   ADDR2_CS(x)\t\t\tFIELD_PREP(GENMASK(31, 30), (x))\n\n#define CMD_REG\t\t\t\t0x0C\n#define   CMD_1(x)\t\t\tFIELD_PREP(GENMASK(7, 0), (x))\n#define   CMD_2(x)\t\t\tFIELD_PREP(GENMASK(15, 8), (x))\n#define   CMD_PAGE_SIZE(x)\t\tFIELD_PREP(GENMASK(25, 23), (x))\n#define   CMD_DMA_ENABLE\t\tBIT(27)\n#define   CMD_NADDRS(x)\t\t\tFIELD_PREP(GENMASK(30, 28), (x))\n#define   CMD_ECC_ENABLE\t\tBIT(31)\n\n#define PROG_REG\t\t\t0x10\n#define   PROG_PGRD\t\t\tBIT(0)\n#define   PROG_ERASE\t\t\tBIT(2)\n#define   PROG_STATUS\t\t\tBIT(3)\n#define   PROG_PGPROG\t\t\tBIT(4)\n#define   PROG_RDID\t\t\tBIT(6)\n#define   PROG_RDPARAM\t\t\tBIT(7)\n#define   PROG_RST\t\t\tBIT(8)\n#define   PROG_GET_FEATURE\t\tBIT(9)\n#define   PROG_SET_FEATURE\t\tBIT(10)\n#define   PROG_CHG_RD_COL_ENH\t\tBIT(14)\n\n#define INTR_STS_EN_REG\t\t\t0x14\n#define INTR_SIG_EN_REG\t\t\t0x18\n#define INTR_STS_REG\t\t\t0x1C\n#define   WRITE_READY\t\t\tBIT(0)\n#define   READ_READY\t\t\tBIT(1)\n#define   XFER_COMPLETE\t\t\tBIT(2)\n#define   DMA_BOUNDARY\t\t\tBIT(6)\n#define   EVENT_MASK\t\t\tGENMASK(7, 0)\n\n#define READY_STS_REG\t\t\t0x20\n\n#define DMA_ADDR0_REG\t\t\t0x50\n#define DMA_ADDR1_REG\t\t\t0x24\n\n#define FLASH_STS_REG\t\t\t0x28\n\n#define TIMING_REG\t\t\t0x2C\n#define   TCCS_TIME_500NS\t\t0\n#define   TCCS_TIME_300NS\t\t3\n#define   TCCS_TIME_200NS\t\t2\n#define   TCCS_TIME_100NS\t\t1\n#define   FAST_TCAD\t\t\tBIT(2)\n#define   DQS_BUFF_SEL_IN(x)\t\tFIELD_PREP(GENMASK(6, 3), (x))\n#define   DQS_BUFF_SEL_OUT(x)\t\tFIELD_PREP(GENMASK(18, 15), (x))\n\n#define DATA_PORT_REG\t\t\t0x30\n\n#define ECC_CONF_REG\t\t\t0x34\n#define   ECC_CONF_COL(x)\t\tFIELD_PREP(GENMASK(15, 0), (x))\n#define   ECC_CONF_LEN(x)\t\tFIELD_PREP(GENMASK(26, 16), (x))\n#define   ECC_CONF_BCH_EN\t\tBIT(27)\n\n#define ECC_ERR_CNT_REG\t\t\t0x38\n#define   GET_PKT_ERR_CNT(x)\t\tFIELD_GET(GENMASK(7, 0), (x))\n#define   GET_PAGE_ERR_CNT(x)\t\tFIELD_GET(GENMASK(16, 8), (x))\n\n#define ECC_SP_REG\t\t\t0x3C\n#define   ECC_SP_CMD1(x)\t\tFIELD_PREP(GENMASK(7, 0), (x))\n#define   ECC_SP_CMD2(x)\t\tFIELD_PREP(GENMASK(15, 8), (x))\n#define   ECC_SP_ADDRS(x)\t\tFIELD_PREP(GENMASK(30, 28), (x))\n\n#define ECC_1ERR_CNT_REG\t\t0x40\n#define ECC_2ERR_CNT_REG\t\t0x44\n\n#define DATA_INTERFACE_REG\t\t0x6C\n#define   DIFACE_SDR_MODE(x)\t\tFIELD_PREP(GENMASK(2, 0), (x))\n#define   DIFACE_DDR_MODE(x)\t\tFIELD_PREP(GENMASK(5, 3), (x))\n#define   DIFACE_SDR\t\t\t0\n#define   DIFACE_NVDDR\t\t\tBIT(9)\n\n#define ANFC_MAX_CS\t\t\t2\n#define ANFC_DFLT_TIMEOUT_US\t\t1000000\n#define ANFC_MAX_CHUNK_SIZE\t\tSZ_1M\n#define ANFC_MAX_PARAM_SIZE\t\tSZ_4K\n#define ANFC_MAX_STEPS\t\t\tSZ_2K\n#define ANFC_MAX_PKT_SIZE\t\t(SZ_2K - 1)\n#define ANFC_MAX_ADDR_CYC\t\t5U\n#define ANFC_RSVD_ECC_BYTES\t\t21\n\n#define ANFC_XLNX_SDR_DFLT_CORE_CLK\t100000000\n#define ANFC_XLNX_SDR_HS_CORE_CLK\t80000000\n\nstatic struct gpio_desc *anfc_default_cs_array[2] = {NULL, NULL};\n\n \nstruct anfc_op {\n\tu32 pkt_reg;\n\tu32 addr1_reg;\n\tu32 addr2_reg;\n\tu32 cmd_reg;\n\tu32 prog_reg;\n\tint steps;\n\tunsigned int rdy_timeout_ms;\n\tunsigned int len;\n\tbool read;\n\tu8 *buf;\n};\n\n \nstruct anand {\n\tstruct list_head node;\n\tstruct nand_chip chip;\n\tunsigned int rb;\n\tunsigned int page_sz;\n\tunsigned long clk;\n\tu32 data_iface;\n\tu32 timings;\n\tu32 ecc_conf;\n\tu32 strength;\n\tu16 raddr_cycles;\n\tu16 caddr_cycles;\n\tunsigned int ecc_bits;\n\tunsigned int ecc_total;\n\tunsigned int *errloc;\n\tu8 *hw_ecc;\n\tstruct bch_control *bch;\n\tint *cs_idx;\n\tint ncs_idx;\n};\n\n \nstruct arasan_nfc {\n\tstruct device *dev;\n\tvoid __iomem *base;\n\tstruct clk *controller_clk;\n\tstruct clk *bus_clk;\n\tstruct nand_controller controller;\n\tstruct list_head chips;\n\tunsigned int cur_clk;\n\tstruct gpio_desc **cs_array;\n\tunsigned int ncs;\n\tint cur_cs;\n\tunsigned int native_cs;\n\tunsigned int spare_cs;\n};\n\nstatic struct anand *to_anand(struct nand_chip *nand)\n{\n\treturn container_of(nand, struct anand, chip);\n}\n\nstatic struct arasan_nfc *to_anfc(struct nand_controller *ctrl)\n{\n\treturn container_of(ctrl, struct arasan_nfc, controller);\n}\n\nstatic int anfc_wait_for_event(struct arasan_nfc *nfc, unsigned int event)\n{\n\tu32 val;\n\tint ret;\n\n\tret = readl_relaxed_poll_timeout(nfc->base + INTR_STS_REG, val,\n\t\t\t\t\t val & event, 0,\n\t\t\t\t\t ANFC_DFLT_TIMEOUT_US);\n\tif (ret) {\n\t\tdev_err(nfc->dev, \"Timeout waiting for event 0x%x\\n\", event);\n\t\treturn -ETIMEDOUT;\n\t}\n\n\twritel_relaxed(event, nfc->base + INTR_STS_REG);\n\n\treturn 0;\n}\n\nstatic int anfc_wait_for_rb(struct arasan_nfc *nfc, struct nand_chip *chip,\n\t\t\t    unsigned int timeout_ms)\n{\n\tstruct anand *anand = to_anand(chip);\n\tu32 val;\n\tint ret;\n\n\t \n\tret = readl_relaxed_poll_timeout(nfc->base + READY_STS_REG, val,\n\t\t\t\t\t val & BIT(anand->rb),\n\t\t\t\t\t 1, timeout_ms * 1000);\n\tif (ret) {\n\t\tdev_err(nfc->dev, \"Timeout waiting for R/B 0x%x\\n\",\n\t\t\treadl_relaxed(nfc->base + READY_STS_REG));\n\t\treturn -ETIMEDOUT;\n\t}\n\n\treturn 0;\n}\n\nstatic void anfc_trigger_op(struct arasan_nfc *nfc, struct anfc_op *nfc_op)\n{\n\twritel_relaxed(nfc_op->pkt_reg, nfc->base + PKT_REG);\n\twritel_relaxed(nfc_op->addr1_reg, nfc->base + MEM_ADDR1_REG);\n\twritel_relaxed(nfc_op->addr2_reg, nfc->base + MEM_ADDR2_REG);\n\twritel_relaxed(nfc_op->cmd_reg, nfc->base + CMD_REG);\n\twritel_relaxed(nfc_op->prog_reg, nfc->base + PROG_REG);\n}\n\nstatic int anfc_pkt_len_config(unsigned int len, unsigned int *steps,\n\t\t\t       unsigned int *pktsize)\n{\n\tunsigned int nb, sz;\n\n\tfor (nb = 1; nb < ANFC_MAX_STEPS; nb *= 2) {\n\t\tsz = len / nb;\n\t\tif (sz <= ANFC_MAX_PKT_SIZE)\n\t\t\tbreak;\n\t}\n\n\tif (sz * nb != len)\n\t\treturn -ENOTSUPP;\n\n\tif (steps)\n\t\t*steps = nb;\n\n\tif (pktsize)\n\t\t*pktsize = sz;\n\n\treturn 0;\n}\n\nstatic bool anfc_is_gpio_cs(struct arasan_nfc *nfc, int nfc_cs)\n{\n\treturn nfc_cs >= 0 && nfc->cs_array[nfc_cs];\n}\n\nstatic int anfc_relative_to_absolute_cs(struct anand *anand, int num)\n{\n\treturn anand->cs_idx[num];\n}\n\nstatic void anfc_assert_cs(struct arasan_nfc *nfc, unsigned int nfc_cs_idx)\n{\n\t \n\tif (nfc->cur_cs == nfc_cs_idx)\n\t\treturn;\n\n\t \n\tif (anfc_is_gpio_cs(nfc, nfc->cur_cs))\n\t\tgpiod_set_value_cansleep(nfc->cs_array[nfc->cur_cs], 1);\n\n\t \n\tif (anfc_is_gpio_cs(nfc, nfc_cs_idx)) {\n\t\tnfc->native_cs = nfc->spare_cs;\n\t\tgpiod_set_value_cansleep(nfc->cs_array[nfc_cs_idx], 0);\n\t} else {\n\t\tnfc->native_cs = nfc_cs_idx;\n\t}\n\n\tnfc->cur_cs = nfc_cs_idx;\n}\n\nstatic int anfc_select_target(struct nand_chip *chip, int target)\n{\n\tstruct anand *anand = to_anand(chip);\n\tstruct arasan_nfc *nfc = to_anfc(chip->controller);\n\tunsigned int nfc_cs_idx = anfc_relative_to_absolute_cs(anand, target);\n\tint ret;\n\n\tanfc_assert_cs(nfc, nfc_cs_idx);\n\n\t \n\twritel_relaxed(anand->data_iface, nfc->base + DATA_INTERFACE_REG);\n\twritel_relaxed(anand->timings, nfc->base + TIMING_REG);\n\n\t \n\tif (nfc->cur_clk != anand->clk) {\n\t\tclk_disable_unprepare(nfc->bus_clk);\n\t\tret = clk_set_rate(nfc->bus_clk, anand->clk);\n\t\tif (ret) {\n\t\t\tdev_err(nfc->dev, \"Failed to change clock rate\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = clk_prepare_enable(nfc->bus_clk);\n\t\tif (ret) {\n\t\t\tdev_err(nfc->dev,\n\t\t\t\t\"Failed to re-enable the bus clock\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tnfc->cur_clk = anand->clk;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int anfc_read_page_hw_ecc(struct nand_chip *chip, u8 *buf,\n\t\t\t\t int oob_required, int page)\n{\n\tstruct arasan_nfc *nfc = to_anfc(chip->controller);\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tstruct anand *anand = to_anand(chip);\n\tunsigned int len = mtd->writesize + (oob_required ? mtd->oobsize : 0);\n\tunsigned int max_bitflips = 0;\n\tdma_addr_t dma_addr;\n\tint step, ret;\n\tstruct anfc_op nfc_op = {\n\t\t.pkt_reg =\n\t\t\tPKT_SIZE(chip->ecc.size) |\n\t\t\tPKT_STEPS(chip->ecc.steps),\n\t\t.addr1_reg =\n\t\t\t(page & 0xFF) << (8 * (anand->caddr_cycles)) |\n\t\t\t(((page >> 8) & 0xFF) << (8 * (1 + anand->caddr_cycles))),\n\t\t.addr2_reg =\n\t\t\t((page >> 16) & 0xFF) |\n\t\t\tADDR2_STRENGTH(anand->strength) |\n\t\t\tADDR2_CS(nfc->native_cs),\n\t\t.cmd_reg =\n\t\t\tCMD_1(NAND_CMD_READ0) |\n\t\t\tCMD_2(NAND_CMD_READSTART) |\n\t\t\tCMD_PAGE_SIZE(anand->page_sz) |\n\t\t\tCMD_DMA_ENABLE |\n\t\t\tCMD_NADDRS(anand->caddr_cycles +\n\t\t\t\t   anand->raddr_cycles),\n\t\t.prog_reg = PROG_PGRD,\n\t};\n\n\tdma_addr = dma_map_single(nfc->dev, (void *)buf, len, DMA_FROM_DEVICE);\n\tif (dma_mapping_error(nfc->dev, dma_addr)) {\n\t\tdev_err(nfc->dev, \"Buffer mapping error\");\n\t\treturn -EIO;\n\t}\n\n\twritel_relaxed(lower_32_bits(dma_addr), nfc->base + DMA_ADDR0_REG);\n\twritel_relaxed(upper_32_bits(dma_addr), nfc->base + DMA_ADDR1_REG);\n\n\tanfc_trigger_op(nfc, &nfc_op);\n\n\tret = anfc_wait_for_event(nfc, XFER_COMPLETE);\n\tdma_unmap_single(nfc->dev, dma_addr, len, DMA_FROM_DEVICE);\n\tif (ret) {\n\t\tdev_err(nfc->dev, \"Error reading page %d\\n\", page);\n\t\treturn ret;\n\t}\n\n\t \n\tret = nand_change_read_column_op(chip, mtd->writesize, chip->oob_poi,\n\t\t\t\t\t mtd->oobsize, 0);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tfor (step = 0; step < chip->ecc.steps; step++) {\n\t\tu8 *raw_buf = &buf[step * chip->ecc.size];\n\t\tunsigned int bit, byte;\n\t\tint bf, i;\n\n\t\t \n\t\tmemset(anand->hw_ecc, 0, chip->ecc.bytes);\n\t\tnand_extract_bits(anand->hw_ecc, 0,\n\t\t\t\t  &chip->oob_poi[mtd->oobsize - anand->ecc_total],\n\t\t\t\t  anand->ecc_bits * step, anand->ecc_bits);\n\n\t\tbf = bch_decode(anand->bch, raw_buf, chip->ecc.size,\n\t\t\t\tanand->hw_ecc, NULL, NULL, anand->errloc);\n\t\tif (!bf) {\n\t\t\tcontinue;\n\t\t} else if (bf > 0) {\n\t\t\tfor (i = 0; i < bf; i++) {\n\t\t\t\t \n\t\t\t\tif (anand->errloc[i] < (chip->ecc.size * 8)) {\n\t\t\t\t\tbit = BIT(anand->errloc[i] & 7);\n\t\t\t\t\tbyte = anand->errloc[i] >> 3;\n\t\t\t\t\traw_buf[byte] ^= bit;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tmtd->ecc_stats.corrected += bf;\n\t\t\tmax_bitflips = max_t(unsigned int, max_bitflips, bf);\n\n\t\t\tcontinue;\n\t\t}\n\n\t\tbf = nand_check_erased_ecc_chunk(raw_buf, chip->ecc.size,\n\t\t\t\t\t\t NULL, 0, NULL, 0,\n\t\t\t\t\t\t chip->ecc.strength);\n\t\tif (bf > 0) {\n\t\t\tmtd->ecc_stats.corrected += bf;\n\t\t\tmax_bitflips = max_t(unsigned int, max_bitflips, bf);\n\t\t\tmemset(raw_buf, 0xFF, chip->ecc.size);\n\t\t} else if (bf < 0) {\n\t\t\tmtd->ecc_stats.failed++;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int anfc_sel_read_page_hw_ecc(struct nand_chip *chip, u8 *buf,\n\t\t\t\t     int oob_required, int page)\n{\n\tint ret;\n\n\tret = anfc_select_target(chip, chip->cur_cs);\n\tif (ret)\n\t\treturn ret;\n\n\treturn anfc_read_page_hw_ecc(chip, buf, oob_required, page);\n};\n\nstatic int anfc_write_page_hw_ecc(struct nand_chip *chip, const u8 *buf,\n\t\t\t\t  int oob_required, int page)\n{\n\tstruct anand *anand = to_anand(chip);\n\tstruct arasan_nfc *nfc = to_anfc(chip->controller);\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tunsigned int len = mtd->writesize + (oob_required ? mtd->oobsize : 0);\n\tdma_addr_t dma_addr;\n\tu8 status;\n\tint ret;\n\tstruct anfc_op nfc_op = {\n\t\t.pkt_reg =\n\t\t\tPKT_SIZE(chip->ecc.size) |\n\t\t\tPKT_STEPS(chip->ecc.steps),\n\t\t.addr1_reg =\n\t\t\t(page & 0xFF) << (8 * (anand->caddr_cycles)) |\n\t\t\t(((page >> 8) & 0xFF) << (8 * (1 + anand->caddr_cycles))),\n\t\t.addr2_reg =\n\t\t\t((page >> 16) & 0xFF) |\n\t\t\tADDR2_STRENGTH(anand->strength) |\n\t\t\tADDR2_CS(nfc->native_cs),\n\t\t.cmd_reg =\n\t\t\tCMD_1(NAND_CMD_SEQIN) |\n\t\t\tCMD_2(NAND_CMD_PAGEPROG) |\n\t\t\tCMD_PAGE_SIZE(anand->page_sz) |\n\t\t\tCMD_DMA_ENABLE |\n\t\t\tCMD_NADDRS(anand->caddr_cycles +\n\t\t\t\t   anand->raddr_cycles) |\n\t\t\tCMD_ECC_ENABLE,\n\t\t.prog_reg = PROG_PGPROG,\n\t};\n\n\twritel_relaxed(anand->ecc_conf, nfc->base + ECC_CONF_REG);\n\twritel_relaxed(ECC_SP_CMD1(NAND_CMD_RNDIN) |\n\t\t       ECC_SP_ADDRS(anand->caddr_cycles),\n\t\t       nfc->base + ECC_SP_REG);\n\n\tdma_addr = dma_map_single(nfc->dev, (void *)buf, len, DMA_TO_DEVICE);\n\tif (dma_mapping_error(nfc->dev, dma_addr)) {\n\t\tdev_err(nfc->dev, \"Buffer mapping error\");\n\t\treturn -EIO;\n\t}\n\n\twritel_relaxed(lower_32_bits(dma_addr), nfc->base + DMA_ADDR0_REG);\n\twritel_relaxed(upper_32_bits(dma_addr), nfc->base + DMA_ADDR1_REG);\n\n\tanfc_trigger_op(nfc, &nfc_op);\n\tret = anfc_wait_for_event(nfc, XFER_COMPLETE);\n\tdma_unmap_single(nfc->dev, dma_addr, len, DMA_TO_DEVICE);\n\tif (ret) {\n\t\tdev_err(nfc->dev, \"Error writing page %d\\n\", page);\n\t\treturn ret;\n\t}\n\n\t \n\tif (oob_required) {\n\t\tret = nand_write_oob_std(chip, page);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\tret = nand_status_op(chip, &status);\n\tif (ret)\n\t\treturn ret;\n\n\tif (status & NAND_STATUS_FAIL)\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nstatic int anfc_sel_write_page_hw_ecc(struct nand_chip *chip, const u8 *buf,\n\t\t\t\t      int oob_required, int page)\n{\n\tint ret;\n\n\tret = anfc_select_target(chip, chip->cur_cs);\n\tif (ret)\n\t\treturn ret;\n\n\treturn anfc_write_page_hw_ecc(chip, buf, oob_required, page);\n};\n\n \nstatic int anfc_parse_instructions(struct nand_chip *chip,\n\t\t\t\t   const struct nand_subop *subop,\n\t\t\t\t   struct anfc_op *nfc_op)\n{\n\tstruct arasan_nfc *nfc = to_anfc(chip->controller);\n\tstruct anand *anand = to_anand(chip);\n\tconst struct nand_op_instr *instr = NULL;\n\tbool first_cmd = true;\n\tunsigned int op_id;\n\tint ret, i;\n\n\tmemset(nfc_op, 0, sizeof(*nfc_op));\n\tnfc_op->addr2_reg = ADDR2_CS(nfc->native_cs);\n\tnfc_op->cmd_reg = CMD_PAGE_SIZE(anand->page_sz);\n\n\tfor (op_id = 0; op_id < subop->ninstrs; op_id++) {\n\t\tunsigned int offset, naddrs, pktsize;\n\t\tconst u8 *addrs;\n\t\tu8 *buf;\n\n\t\tinstr = &subop->instrs[op_id];\n\n\t\tswitch (instr->type) {\n\t\tcase NAND_OP_CMD_INSTR:\n\t\t\tif (first_cmd)\n\t\t\t\tnfc_op->cmd_reg |= CMD_1(instr->ctx.cmd.opcode);\n\t\t\telse\n\t\t\t\tnfc_op->cmd_reg |= CMD_2(instr->ctx.cmd.opcode);\n\n\t\t\tfirst_cmd = false;\n\t\t\tbreak;\n\n\t\tcase NAND_OP_ADDR_INSTR:\n\t\t\toffset = nand_subop_get_addr_start_off(subop, op_id);\n\t\t\tnaddrs = nand_subop_get_num_addr_cyc(subop, op_id);\n\t\t\taddrs = &instr->ctx.addr.addrs[offset];\n\t\t\tnfc_op->cmd_reg |= CMD_NADDRS(naddrs);\n\n\t\t\tfor (i = 0; i < min(ANFC_MAX_ADDR_CYC, naddrs); i++) {\n\t\t\t\tif (i < 4)\n\t\t\t\t\tnfc_op->addr1_reg |= (u32)addrs[i] << i * 8;\n\t\t\t\telse\n\t\t\t\t\tnfc_op->addr2_reg |= addrs[i];\n\t\t\t}\n\n\t\t\tbreak;\n\t\tcase NAND_OP_DATA_IN_INSTR:\n\t\t\tnfc_op->read = true;\n\t\t\tfallthrough;\n\t\tcase NAND_OP_DATA_OUT_INSTR:\n\t\t\toffset = nand_subop_get_data_start_off(subop, op_id);\n\t\t\tbuf = instr->ctx.data.buf.in;\n\t\t\tnfc_op->buf = &buf[offset];\n\t\t\tnfc_op->len = nand_subop_get_data_len(subop, op_id);\n\t\t\tret = anfc_pkt_len_config(nfc_op->len, &nfc_op->steps,\n\t\t\t\t\t\t  &pktsize);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\t \n\t\t\tnfc_op->pkt_reg |= PKT_SIZE(round_up(pktsize, 4)) |\n\t\t\t\t\t   PKT_STEPS(nfc_op->steps);\n\t\t\tbreak;\n\t\tcase NAND_OP_WAITRDY_INSTR:\n\t\t\tnfc_op->rdy_timeout_ms = instr->ctx.waitrdy.timeout_ms;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int anfc_rw_pio_op(struct arasan_nfc *nfc, struct anfc_op *nfc_op)\n{\n\tunsigned int dwords = (nfc_op->len / 4) / nfc_op->steps;\n\tunsigned int last_len = nfc_op->len % 4;\n\tunsigned int offset, dir;\n\tu8 *buf = nfc_op->buf;\n\tint ret, i;\n\n\tfor (i = 0; i < nfc_op->steps; i++) {\n\t\tdir = nfc_op->read ? READ_READY : WRITE_READY;\n\t\tret = anfc_wait_for_event(nfc, dir);\n\t\tif (ret) {\n\t\t\tdev_err(nfc->dev, \"PIO %s ready signal not received\\n\",\n\t\t\t\tnfc_op->read ? \"Read\" : \"Write\");\n\t\t\treturn ret;\n\t\t}\n\n\t\toffset = i * (dwords * 4);\n\t\tif (nfc_op->read)\n\t\t\tioread32_rep(nfc->base + DATA_PORT_REG, &buf[offset],\n\t\t\t\t     dwords);\n\t\telse\n\t\t\tiowrite32_rep(nfc->base + DATA_PORT_REG, &buf[offset],\n\t\t\t\t      dwords);\n\t}\n\n\tif (last_len) {\n\t\tu32 remainder;\n\n\t\toffset = nfc_op->len - last_len;\n\n\t\tif (nfc_op->read) {\n\t\t\tremainder = readl_relaxed(nfc->base + DATA_PORT_REG);\n\t\t\tmemcpy(&buf[offset], &remainder, last_len);\n\t\t} else {\n\t\t\tmemcpy(&remainder, &buf[offset], last_len);\n\t\t\twritel_relaxed(remainder, nfc->base + DATA_PORT_REG);\n\t\t}\n\t}\n\n\treturn anfc_wait_for_event(nfc, XFER_COMPLETE);\n}\n\nstatic int anfc_misc_data_type_exec(struct nand_chip *chip,\n\t\t\t\t    const struct nand_subop *subop,\n\t\t\t\t    u32 prog_reg)\n{\n\tstruct arasan_nfc *nfc = to_anfc(chip->controller);\n\tstruct anfc_op nfc_op = {};\n\tint ret;\n\n\tret = anfc_parse_instructions(chip, subop, &nfc_op);\n\tif (ret)\n\t\treturn ret;\n\n\tnfc_op.prog_reg = prog_reg;\n\tanfc_trigger_op(nfc, &nfc_op);\n\n\tif (nfc_op.rdy_timeout_ms) {\n\t\tret = anfc_wait_for_rb(nfc, chip, nfc_op.rdy_timeout_ms);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn anfc_rw_pio_op(nfc, &nfc_op);\n}\n\nstatic int anfc_param_read_type_exec(struct nand_chip *chip,\n\t\t\t\t     const struct nand_subop *subop)\n{\n\treturn anfc_misc_data_type_exec(chip, subop, PROG_RDPARAM);\n}\n\nstatic int anfc_data_read_type_exec(struct nand_chip *chip,\n\t\t\t\t    const struct nand_subop *subop)\n{\n\tu32 prog_reg = PROG_PGRD;\n\n\t \n\tif (subop->instrs[0].ctx.cmd.opcode == NAND_CMD_RNDOUT &&\n\t    subop->instrs[2].ctx.cmd.opcode == NAND_CMD_RNDOUTSTART)\n\t\tprog_reg = PROG_CHG_RD_COL_ENH;\n\n\treturn anfc_misc_data_type_exec(chip, subop, prog_reg);\n}\n\nstatic int anfc_param_write_type_exec(struct nand_chip *chip,\n\t\t\t\t      const struct nand_subop *subop)\n{\n\treturn anfc_misc_data_type_exec(chip, subop, PROG_SET_FEATURE);\n}\n\nstatic int anfc_data_write_type_exec(struct nand_chip *chip,\n\t\t\t\t     const struct nand_subop *subop)\n{\n\treturn anfc_misc_data_type_exec(chip, subop, PROG_PGPROG);\n}\n\nstatic int anfc_misc_zerolen_type_exec(struct nand_chip *chip,\n\t\t\t\t       const struct nand_subop *subop,\n\t\t\t\t       u32 prog_reg)\n{\n\tstruct arasan_nfc *nfc = to_anfc(chip->controller);\n\tstruct anfc_op nfc_op = {};\n\tint ret;\n\n\tret = anfc_parse_instructions(chip, subop, &nfc_op);\n\tif (ret)\n\t\treturn ret;\n\n\tnfc_op.prog_reg = prog_reg;\n\tanfc_trigger_op(nfc, &nfc_op);\n\n\tret = anfc_wait_for_event(nfc, XFER_COMPLETE);\n\tif (ret)\n\t\treturn ret;\n\n\tif (nfc_op.rdy_timeout_ms)\n\t\tret = anfc_wait_for_rb(nfc, chip, nfc_op.rdy_timeout_ms);\n\n\treturn ret;\n}\n\nstatic int anfc_status_type_exec(struct nand_chip *chip,\n\t\t\t\t const struct nand_subop *subop)\n{\n\tstruct arasan_nfc *nfc = to_anfc(chip->controller);\n\tu32 tmp;\n\tint ret;\n\n\t \n\tif (subop->instrs[0].ctx.cmd.opcode != NAND_CMD_STATUS)\n\t\treturn -ENOTSUPP;\n\n\tret = anfc_misc_zerolen_type_exec(chip, subop, PROG_STATUS);\n\tif (ret)\n\t\treturn ret;\n\n\ttmp = readl_relaxed(nfc->base + FLASH_STS_REG);\n\tmemcpy(subop->instrs[1].ctx.data.buf.in, &tmp, 1);\n\n\treturn 0;\n}\n\nstatic int anfc_reset_type_exec(struct nand_chip *chip,\n\t\t\t\tconst struct nand_subop *subop)\n{\n\treturn anfc_misc_zerolen_type_exec(chip, subop, PROG_RST);\n}\n\nstatic int anfc_erase_type_exec(struct nand_chip *chip,\n\t\t\t\tconst struct nand_subop *subop)\n{\n\treturn anfc_misc_zerolen_type_exec(chip, subop, PROG_ERASE);\n}\n\nstatic int anfc_wait_type_exec(struct nand_chip *chip,\n\t\t\t       const struct nand_subop *subop)\n{\n\tstruct arasan_nfc *nfc = to_anfc(chip->controller);\n\tstruct anfc_op nfc_op = {};\n\tint ret;\n\n\tret = anfc_parse_instructions(chip, subop, &nfc_op);\n\tif (ret)\n\t\treturn ret;\n\n\treturn anfc_wait_for_rb(nfc, chip, nfc_op.rdy_timeout_ms);\n}\n\nstatic const struct nand_op_parser anfc_op_parser = NAND_OP_PARSER(\n\tNAND_OP_PARSER_PATTERN(\n\t\tanfc_param_read_type_exec,\n\t\tNAND_OP_PARSER_PAT_CMD_ELEM(false),\n\t\tNAND_OP_PARSER_PAT_ADDR_ELEM(false, ANFC_MAX_ADDR_CYC),\n\t\tNAND_OP_PARSER_PAT_WAITRDY_ELEM(true),\n\t\tNAND_OP_PARSER_PAT_DATA_IN_ELEM(false, ANFC_MAX_CHUNK_SIZE)),\n\tNAND_OP_PARSER_PATTERN(\n\t\tanfc_param_write_type_exec,\n\t\tNAND_OP_PARSER_PAT_CMD_ELEM(false),\n\t\tNAND_OP_PARSER_PAT_ADDR_ELEM(false, ANFC_MAX_ADDR_CYC),\n\t\tNAND_OP_PARSER_PAT_DATA_OUT_ELEM(false, ANFC_MAX_PARAM_SIZE)),\n\tNAND_OP_PARSER_PATTERN(\n\t\tanfc_data_read_type_exec,\n\t\tNAND_OP_PARSER_PAT_CMD_ELEM(false),\n\t\tNAND_OP_PARSER_PAT_ADDR_ELEM(false, ANFC_MAX_ADDR_CYC),\n\t\tNAND_OP_PARSER_PAT_CMD_ELEM(false),\n\t\tNAND_OP_PARSER_PAT_WAITRDY_ELEM(true),\n\t\tNAND_OP_PARSER_PAT_DATA_IN_ELEM(true, ANFC_MAX_CHUNK_SIZE)),\n\tNAND_OP_PARSER_PATTERN(\n\t\tanfc_data_write_type_exec,\n\t\tNAND_OP_PARSER_PAT_CMD_ELEM(false),\n\t\tNAND_OP_PARSER_PAT_ADDR_ELEM(false, ANFC_MAX_ADDR_CYC),\n\t\tNAND_OP_PARSER_PAT_DATA_OUT_ELEM(false, ANFC_MAX_CHUNK_SIZE),\n\t\tNAND_OP_PARSER_PAT_CMD_ELEM(false)),\n\tNAND_OP_PARSER_PATTERN(\n\t\tanfc_reset_type_exec,\n\t\tNAND_OP_PARSER_PAT_CMD_ELEM(false),\n\t\tNAND_OP_PARSER_PAT_WAITRDY_ELEM(false)),\n\tNAND_OP_PARSER_PATTERN(\n\t\tanfc_erase_type_exec,\n\t\tNAND_OP_PARSER_PAT_CMD_ELEM(false),\n\t\tNAND_OP_PARSER_PAT_ADDR_ELEM(false, ANFC_MAX_ADDR_CYC),\n\t\tNAND_OP_PARSER_PAT_CMD_ELEM(false),\n\t\tNAND_OP_PARSER_PAT_WAITRDY_ELEM(false)),\n\tNAND_OP_PARSER_PATTERN(\n\t\tanfc_status_type_exec,\n\t\tNAND_OP_PARSER_PAT_CMD_ELEM(false),\n\t\tNAND_OP_PARSER_PAT_DATA_IN_ELEM(false, ANFC_MAX_CHUNK_SIZE)),\n\tNAND_OP_PARSER_PATTERN(\n\t\tanfc_wait_type_exec,\n\t\tNAND_OP_PARSER_PAT_WAITRDY_ELEM(false)),\n\t);\n\nstatic int anfc_check_op(struct nand_chip *chip,\n\t\t\t const struct nand_operation *op)\n{\n\tconst struct nand_op_instr *instr;\n\tint op_id;\n\n\t \n\tfor (op_id = 0; op_id < op->ninstrs; op_id++) {\n\t\tinstr = &op->instrs[op_id];\n\n\t\tswitch (instr->type) {\n\t\tcase NAND_OP_ADDR_INSTR:\n\t\t\tif (instr->ctx.addr.naddrs > ANFC_MAX_ADDR_CYC)\n\t\t\t\treturn -ENOTSUPP;\n\n\t\t\tbreak;\n\t\tcase NAND_OP_DATA_IN_INSTR:\n\t\tcase NAND_OP_DATA_OUT_INSTR:\n\t\t\tif (instr->ctx.data.len > ANFC_MAX_CHUNK_SIZE)\n\t\t\t\treturn -ENOTSUPP;\n\n\t\t\tif (anfc_pkt_len_config(instr->ctx.data.len, NULL, NULL))\n\t\t\t\treturn -ENOTSUPP;\n\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tif (op->ninstrs == 2 &&\n\t    op->instrs[0].type == NAND_OP_CMD_INSTR &&\n\t    op->instrs[0].ctx.cmd.opcode != NAND_CMD_STATUS &&\n\t    op->instrs[1].type == NAND_OP_DATA_IN_INSTR)\n\t\treturn -ENOTSUPP;\n\n\treturn nand_op_parser_exec_op(chip, &anfc_op_parser, op, true);\n}\n\nstatic int anfc_exec_op(struct nand_chip *chip,\n\t\t\tconst struct nand_operation *op,\n\t\t\tbool check_only)\n{\n\tint ret;\n\n\tif (check_only)\n\t\treturn anfc_check_op(chip, op);\n\n\tret = anfc_select_target(chip, op->cs);\n\tif (ret)\n\t\treturn ret;\n\n\treturn nand_op_parser_exec_op(chip, &anfc_op_parser, op, check_only);\n}\n\nstatic int anfc_setup_interface(struct nand_chip *chip, int target,\n\t\t\t\tconst struct nand_interface_config *conf)\n{\n\tstruct anand *anand = to_anand(chip);\n\tstruct arasan_nfc *nfc = to_anfc(chip->controller);\n\tstruct device_node *np = nfc->dev->of_node;\n\tconst struct nand_sdr_timings *sdr;\n\tconst struct nand_nvddr_timings *nvddr;\n\tunsigned int tccs_min, dqs_mode, fast_tcad;\n\n\tif (nand_interface_is_nvddr(conf)) {\n\t\tnvddr = nand_get_nvddr_timings(conf);\n\t\tif (IS_ERR(nvddr))\n\t\t\treturn PTR_ERR(nvddr);\n\t} else {\n\t\tsdr = nand_get_sdr_timings(conf);\n\t\tif (IS_ERR(sdr))\n\t\t\treturn PTR_ERR(sdr);\n\t}\n\n\tif (target < 0)\n\t\treturn 0;\n\n\tif (nand_interface_is_sdr(conf)) {\n\t\tanand->data_iface = DIFACE_SDR |\n\t\t\t\t    DIFACE_SDR_MODE(conf->timings.mode);\n\t\tanand->timings = 0;\n\t} else {\n\t\tanand->data_iface = DIFACE_NVDDR |\n\t\t\t\t    DIFACE_DDR_MODE(conf->timings.mode);\n\n\t\tif (conf->timings.nvddr.tCCS_min <= 100000)\n\t\t\ttccs_min = TCCS_TIME_100NS;\n\t\telse if (conf->timings.nvddr.tCCS_min <= 200000)\n\t\t\ttccs_min = TCCS_TIME_200NS;\n\t\telse if (conf->timings.nvddr.tCCS_min <= 300000)\n\t\t\ttccs_min = TCCS_TIME_300NS;\n\t\telse\n\t\t\ttccs_min = TCCS_TIME_500NS;\n\n\t\tfast_tcad = 0;\n\t\tif (conf->timings.nvddr.tCAD_min < 45000)\n\t\t\tfast_tcad = FAST_TCAD;\n\n\t\tswitch (conf->timings.mode) {\n\t\tcase 5:\n\t\tcase 4:\n\t\t\tdqs_mode = 2;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tdqs_mode = 3;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tdqs_mode = 4;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tdqs_mode = 5;\n\t\t\tbreak;\n\t\tcase 0:\n\t\tdefault:\n\t\t\tdqs_mode = 6;\n\t\t\tbreak;\n\t\t}\n\n\t\tanand->timings = tccs_min | fast_tcad |\n\t\t\t\t DQS_BUFF_SEL_IN(dqs_mode) |\n\t\t\t\t DQS_BUFF_SEL_OUT(dqs_mode);\n\t}\n\n\tif (nand_interface_is_sdr(conf)) {\n\t\tanand->clk = ANFC_XLNX_SDR_DFLT_CORE_CLK;\n\t} else {\n\t\t \n\t\tanand->clk = div_u64((u64)NSEC_PER_SEC * 1000,\n\t\t\t\t     conf->timings.nvddr.tCK_min);\n\t}\n\n\t \n\tif (of_device_is_compatible(np, \"xlnx,zynqmp-nand-controller\") &&\n\t    nand_interface_is_sdr(conf) && conf->timings.mode >= 2)\n\t\tanand->clk = ANFC_XLNX_SDR_HS_CORE_CLK;\n\n\treturn 0;\n}\n\nstatic int anfc_calc_hw_ecc_bytes(int step_size, int strength)\n{\n\tunsigned int bch_gf_mag, ecc_bits;\n\n\tswitch (step_size) {\n\tcase SZ_512:\n\t\tbch_gf_mag = 13;\n\t\tbreak;\n\tcase SZ_1K:\n\t\tbch_gf_mag = 14;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tecc_bits = bch_gf_mag * strength;\n\n\treturn DIV_ROUND_UP(ecc_bits, 8);\n}\n\nstatic const int anfc_hw_ecc_512_strengths[] = {4, 8, 12};\n\nstatic const int anfc_hw_ecc_1024_strengths[] = {24};\n\nstatic const struct nand_ecc_step_info anfc_hw_ecc_step_infos[] = {\n\t{\n\t\t.stepsize = SZ_512,\n\t\t.strengths = anfc_hw_ecc_512_strengths,\n\t\t.nstrengths = ARRAY_SIZE(anfc_hw_ecc_512_strengths),\n\t},\n\t{\n\t\t.stepsize = SZ_1K,\n\t\t.strengths = anfc_hw_ecc_1024_strengths,\n\t\t.nstrengths = ARRAY_SIZE(anfc_hw_ecc_1024_strengths),\n\t},\n};\n\nstatic const struct nand_ecc_caps anfc_hw_ecc_caps = {\n\t.stepinfos = anfc_hw_ecc_step_infos,\n\t.nstepinfos = ARRAY_SIZE(anfc_hw_ecc_step_infos),\n\t.calc_ecc_bytes = anfc_calc_hw_ecc_bytes,\n};\n\nstatic int anfc_init_hw_ecc_controller(struct arasan_nfc *nfc,\n\t\t\t\t       struct nand_chip *chip)\n{\n\tstruct anand *anand = to_anand(chip);\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tstruct nand_ecc_ctrl *ecc = &chip->ecc;\n\tunsigned int bch_prim_poly = 0, bch_gf_mag = 0, ecc_offset;\n\tint ret;\n\n\tswitch (mtd->writesize) {\n\tcase SZ_512:\n\tcase SZ_2K:\n\tcase SZ_4K:\n\tcase SZ_8K:\n\tcase SZ_16K:\n\t\tbreak;\n\tdefault:\n\t\tdev_err(nfc->dev, \"Unsupported page size %d\\n\", mtd->writesize);\n\t\treturn -EINVAL;\n\t}\n\n\tret = nand_ecc_choose_conf(chip, &anfc_hw_ecc_caps, mtd->oobsize);\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (ecc->strength) {\n\tcase 12:\n\t\tanand->strength = 0x1;\n\t\tbreak;\n\tcase 8:\n\t\tanand->strength = 0x2;\n\t\tbreak;\n\tcase 4:\n\t\tanand->strength = 0x3;\n\t\tbreak;\n\tcase 24:\n\t\tanand->strength = 0x4;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(nfc->dev, \"Unsupported strength %d\\n\", ecc->strength);\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (ecc->size) {\n\tcase SZ_512:\n\t\tbch_gf_mag = 13;\n\t\tbch_prim_poly = 0x201b;\n\t\tbreak;\n\tcase SZ_1K:\n\t\tbch_gf_mag = 14;\n\t\tbch_prim_poly = 0x4443;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(nfc->dev, \"Unsupported step size %d\\n\", ecc->strength);\n\t\treturn -EINVAL;\n\t}\n\n\tmtd_set_ooblayout(mtd, nand_get_large_page_ooblayout());\n\n\tecc->steps = mtd->writesize / ecc->size;\n\tecc->algo = NAND_ECC_ALGO_BCH;\n\tanand->ecc_bits = bch_gf_mag * ecc->strength;\n\tecc->bytes = DIV_ROUND_UP(anand->ecc_bits, 8);\n\tanand->ecc_total = DIV_ROUND_UP(anand->ecc_bits * ecc->steps, 8);\n\tecc_offset = mtd->writesize + mtd->oobsize - anand->ecc_total;\n\tanand->ecc_conf = ECC_CONF_COL(ecc_offset) |\n\t\t\t  ECC_CONF_LEN(anand->ecc_total) |\n\t\t\t  ECC_CONF_BCH_EN;\n\n\tanand->errloc = devm_kmalloc_array(nfc->dev, ecc->strength,\n\t\t\t\t\t   sizeof(*anand->errloc), GFP_KERNEL);\n\tif (!anand->errloc)\n\t\treturn -ENOMEM;\n\n\tanand->hw_ecc = devm_kmalloc(nfc->dev, ecc->bytes, GFP_KERNEL);\n\tif (!anand->hw_ecc)\n\t\treturn -ENOMEM;\n\n\t \n\tanand->bch = bch_init(bch_gf_mag, ecc->strength, bch_prim_poly, true);\n\tif (!anand->bch)\n\t\treturn -EINVAL;\n\n\tecc->read_page = anfc_sel_read_page_hw_ecc;\n\tecc->write_page = anfc_sel_write_page_hw_ecc;\n\n\treturn 0;\n}\n\nstatic int anfc_attach_chip(struct nand_chip *chip)\n{\n\tstruct anand *anand = to_anand(chip);\n\tstruct arasan_nfc *nfc = to_anfc(chip->controller);\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tint ret = 0;\n\n\tif (mtd->writesize <= SZ_512)\n\t\tanand->caddr_cycles = 1;\n\telse\n\t\tanand->caddr_cycles = 2;\n\n\tif (chip->options & NAND_ROW_ADDR_3)\n\t\tanand->raddr_cycles = 3;\n\telse\n\t\tanand->raddr_cycles = 2;\n\n\tswitch (mtd->writesize) {\n\tcase 512:\n\t\tanand->page_sz = 0;\n\t\tbreak;\n\tcase 1024:\n\t\tanand->page_sz = 5;\n\t\tbreak;\n\tcase 2048:\n\t\tanand->page_sz = 1;\n\t\tbreak;\n\tcase 4096:\n\t\tanand->page_sz = 2;\n\t\tbreak;\n\tcase 8192:\n\t\tanand->page_sz = 3;\n\t\tbreak;\n\tcase 16384:\n\t\tanand->page_sz = 4;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tchip->ecc.read_page_raw = nand_monolithic_read_page_raw;\n\tchip->ecc.write_page_raw = nand_monolithic_write_page_raw;\n\n\tswitch (chip->ecc.engine_type) {\n\tcase NAND_ECC_ENGINE_TYPE_NONE:\n\tcase NAND_ECC_ENGINE_TYPE_SOFT:\n\tcase NAND_ECC_ENGINE_TYPE_ON_DIE:\n\t\tbreak;\n\tcase NAND_ECC_ENGINE_TYPE_ON_HOST:\n\t\tret = anfc_init_hw_ecc_controller(nfc, chip);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(nfc->dev, \"Unsupported ECC mode: %d\\n\",\n\t\t\tchip->ecc.engine_type);\n\t\treturn -EINVAL;\n\t}\n\n\treturn ret;\n}\n\nstatic void anfc_detach_chip(struct nand_chip *chip)\n{\n\tstruct anand *anand = to_anand(chip);\n\n\tif (anand->bch)\n\t\tbch_free(anand->bch);\n}\n\nstatic const struct nand_controller_ops anfc_ops = {\n\t.exec_op = anfc_exec_op,\n\t.setup_interface = anfc_setup_interface,\n\t.attach_chip = anfc_attach_chip,\n\t.detach_chip = anfc_detach_chip,\n};\n\nstatic int anfc_chip_init(struct arasan_nfc *nfc, struct device_node *np)\n{\n\tstruct anand *anand;\n\tstruct nand_chip *chip;\n\tstruct mtd_info *mtd;\n\tint rb, ret, i;\n\n\tanand = devm_kzalloc(nfc->dev, sizeof(*anand), GFP_KERNEL);\n\tif (!anand)\n\t\treturn -ENOMEM;\n\n\t \n\tanand->ncs_idx = of_property_count_elems_of_size(np, \"reg\", sizeof(u32));\n\tif (anand->ncs_idx <= 0 || anand->ncs_idx > nfc->ncs) {\n\t\tdev_err(nfc->dev, \"Invalid reg property\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tanand->cs_idx = devm_kcalloc(nfc->dev, anand->ncs_idx,\n\t\t\t\t     sizeof(*anand->cs_idx), GFP_KERNEL);\n\tif (!anand->cs_idx)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < anand->ncs_idx; i++) {\n\t\tret = of_property_read_u32_index(np, \"reg\", i,\n\t\t\t\t\t\t &anand->cs_idx[i]);\n\t\tif (ret) {\n\t\t\tdev_err(nfc->dev, \"invalid CS property: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t \n\tret = of_property_read_u32(np, \"nand-rb\", &rb);\n\tif (ret)\n\t\treturn ret;\n\n\tif (rb >= ANFC_MAX_CS) {\n\t\tdev_err(nfc->dev, \"Wrong RB %d\\n\", rb);\n\t\treturn -EINVAL;\n\t}\n\n\tanand->rb = rb;\n\n\tchip = &anand->chip;\n\tmtd = nand_to_mtd(chip);\n\tmtd->dev.parent = nfc->dev;\n\tchip->controller = &nfc->controller;\n\tchip->options = NAND_BUSWIDTH_AUTO | NAND_NO_SUBPAGE_WRITE |\n\t\t\tNAND_USES_DMA;\n\n\tnand_set_flash_node(chip, np);\n\tif (!mtd->name) {\n\t\tdev_err(nfc->dev, \"NAND label property is mandatory\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = nand_scan(chip, anand->ncs_idx);\n\tif (ret) {\n\t\tdev_err(nfc->dev, \"Scan operation failed\\n\");\n\t\treturn ret;\n\t}\n\n\tret = mtd_device_register(mtd, NULL, 0);\n\tif (ret) {\n\t\tnand_cleanup(chip);\n\t\treturn ret;\n\t}\n\n\tlist_add_tail(&anand->node, &nfc->chips);\n\n\treturn 0;\n}\n\nstatic void anfc_chips_cleanup(struct arasan_nfc *nfc)\n{\n\tstruct anand *anand, *tmp;\n\tstruct nand_chip *chip;\n\tint ret;\n\n\tlist_for_each_entry_safe(anand, tmp, &nfc->chips, node) {\n\t\tchip = &anand->chip;\n\t\tret = mtd_device_unregister(nand_to_mtd(chip));\n\t\tWARN_ON(ret);\n\t\tnand_cleanup(chip);\n\t\tlist_del(&anand->node);\n\t}\n}\n\nstatic int anfc_chips_init(struct arasan_nfc *nfc)\n{\n\tstruct device_node *np = nfc->dev->of_node, *nand_np;\n\tint nchips = of_get_child_count(np);\n\tint ret;\n\n\tif (!nchips) {\n\t\tdev_err(nfc->dev, \"Incorrect number of NAND chips (%d)\\n\",\n\t\t\tnchips);\n\t\treturn -EINVAL;\n\t}\n\n\tfor_each_child_of_node(np, nand_np) {\n\t\tret = anfc_chip_init(nfc, nand_np);\n\t\tif (ret) {\n\t\t\tof_node_put(nand_np);\n\t\t\tanfc_chips_cleanup(nfc);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic void anfc_reset(struct arasan_nfc *nfc)\n{\n\t \n\twritel_relaxed(0, nfc->base + INTR_SIG_EN_REG);\n\n\t \n\twritel_relaxed(EVENT_MASK, nfc->base + INTR_STS_EN_REG);\n\n\tnfc->cur_cs = -1;\n}\n\nstatic int anfc_parse_cs(struct arasan_nfc *nfc)\n{\n\tint ret;\n\n\t \n\tret = rawnand_dt_parse_gpio_cs(nfc->dev, &nfc->cs_array, &nfc->ncs);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (nfc->cs_array && nfc->ncs > 2) {\n\t\tif (!nfc->cs_array[0] && !nfc->cs_array[1]) {\n\t\t\tdev_err(nfc->dev,\n\t\t\t\t\"Assign a single native CS when using GPIOs\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (nfc->cs_array[0])\n\t\t\tnfc->spare_cs = 0;\n\t\telse\n\t\t\tnfc->spare_cs = 1;\n\t}\n\n\tif (!nfc->cs_array) {\n\t\tnfc->cs_array = anfc_default_cs_array;\n\t\tnfc->ncs = ANFC_MAX_CS;\n\t\treturn 0;\n\t}\n\n\treturn 0;\n}\n\nstatic int anfc_probe(struct platform_device *pdev)\n{\n\tstruct arasan_nfc *nfc;\n\tint ret;\n\n\tnfc = devm_kzalloc(&pdev->dev, sizeof(*nfc), GFP_KERNEL);\n\tif (!nfc)\n\t\treturn -ENOMEM;\n\n\tnfc->dev = &pdev->dev;\n\tnand_controller_init(&nfc->controller);\n\tnfc->controller.ops = &anfc_ops;\n\tINIT_LIST_HEAD(&nfc->chips);\n\n\tnfc->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(nfc->base))\n\t\treturn PTR_ERR(nfc->base);\n\n\tanfc_reset(nfc);\n\n\tnfc->controller_clk = devm_clk_get_enabled(&pdev->dev, \"controller\");\n\tif (IS_ERR(nfc->controller_clk))\n\t\treturn PTR_ERR(nfc->controller_clk);\n\n\tnfc->bus_clk = devm_clk_get_enabled(&pdev->dev, \"bus\");\n\tif (IS_ERR(nfc->bus_clk))\n\t\treturn PTR_ERR(nfc->bus_clk);\n\n\tret = dma_set_mask(&pdev->dev, DMA_BIT_MASK(64));\n\tif (ret)\n\t\treturn ret;\n\n\tret = anfc_parse_cs(nfc);\n\tif (ret)\n\t\treturn ret;\n\n\tret = anfc_chips_init(nfc);\n\tif (ret)\n\t\treturn ret;\n\n\tplatform_set_drvdata(pdev, nfc);\n\n\treturn 0;\n}\n\nstatic void anfc_remove(struct platform_device *pdev)\n{\n\tstruct arasan_nfc *nfc = platform_get_drvdata(pdev);\n\n\tanfc_chips_cleanup(nfc);\n}\n\nstatic const struct of_device_id anfc_ids[] = {\n\t{\n\t\t.compatible = \"xlnx,zynqmp-nand-controller\",\n\t},\n\t{\n\t\t.compatible = \"arasan,nfc-v3p10\",\n\t},\n\t{}\n};\nMODULE_DEVICE_TABLE(of, anfc_ids);\n\nstatic struct platform_driver anfc_driver = {\n\t.driver = {\n\t\t.name = \"arasan-nand-controller\",\n\t\t.of_match_table = anfc_ids,\n\t},\n\t.probe = anfc_probe,\n\t.remove_new = anfc_remove,\n};\nmodule_platform_driver(anfc_driver);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Punnaiah Choudary Kalluri <punnaia@xilinx.com>\");\nMODULE_AUTHOR(\"Naga Sureshkumar Relli <nagasure@xilinx.com>\");\nMODULE_AUTHOR(\"Miquel Raynal <miquel.raynal@bootlin.com>\");\nMODULE_DESCRIPTION(\"Arasan NAND Flash Controller Driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}