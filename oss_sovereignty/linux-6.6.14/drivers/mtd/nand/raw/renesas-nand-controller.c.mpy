{
  "module_name": "renesas-nand-controller.c",
  "hash_id": "2785dded0ffcd4165b0f4bd63b66f1628e086fe3ae127ca3545a5eca2ac93b96",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/nand/raw/renesas-nand-controller.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/clk.h>\n#include <linux/dma-mapping.h>\n#include <linux/interrupt.h>\n#include <linux/iopoll.h>\n#include <linux/module.h>\n#include <linux/mtd/mtd.h>\n#include <linux/mtd/rawnand.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/slab.h>\n\n#define COMMAND_REG 0x00\n#define   COMMAND_SEQ(x) FIELD_PREP(GENMASK(5, 0), (x))\n#define     COMMAND_SEQ_10 COMMAND_SEQ(0x2A)\n#define     COMMAND_SEQ_12 COMMAND_SEQ(0x0C)\n#define     COMMAND_SEQ_18 COMMAND_SEQ(0x32)\n#define     COMMAND_SEQ_19 COMMAND_SEQ(0x13)\n#define     COMMAND_SEQ_GEN_IN COMMAND_SEQ_18\n#define     COMMAND_SEQ_GEN_OUT COMMAND_SEQ_19\n#define     COMMAND_SEQ_READ_PAGE COMMAND_SEQ_10\n#define     COMMAND_SEQ_WRITE_PAGE COMMAND_SEQ_12\n#define   COMMAND_INPUT_SEL_AHBS 0\n#define   COMMAND_INPUT_SEL_DMA BIT(6)\n#define   COMMAND_FIFO_SEL 0\n#define   COMMAND_DATA_SEL BIT(7)\n#define   COMMAND_0(x) FIELD_PREP(GENMASK(15, 8), (x))\n#define   COMMAND_1(x) FIELD_PREP(GENMASK(23, 16), (x))\n#define   COMMAND_2(x) FIELD_PREP(GENMASK(31, 24), (x))\n\n#define CONTROL_REG 0x04\n#define   CONTROL_CHECK_RB_LINE 0\n#define   CONTROL_ECC_BLOCK_SIZE(x) FIELD_PREP(GENMASK(2, 1), (x))\n#define     CONTROL_ECC_BLOCK_SIZE_256 CONTROL_ECC_BLOCK_SIZE(0)\n#define     CONTROL_ECC_BLOCK_SIZE_512 CONTROL_ECC_BLOCK_SIZE(1)\n#define     CONTROL_ECC_BLOCK_SIZE_1024 CONTROL_ECC_BLOCK_SIZE(2)\n#define   CONTROL_INT_EN BIT(4)\n#define   CONTROL_ECC_EN BIT(5)\n#define   CONTROL_BLOCK_SIZE(x) FIELD_PREP(GENMASK(7, 6), (x))\n#define     CONTROL_BLOCK_SIZE_32P CONTROL_BLOCK_SIZE(0)\n#define     CONTROL_BLOCK_SIZE_64P CONTROL_BLOCK_SIZE(1)\n#define     CONTROL_BLOCK_SIZE_128P CONTROL_BLOCK_SIZE(2)\n#define     CONTROL_BLOCK_SIZE_256P CONTROL_BLOCK_SIZE(3)\n\n#define STATUS_REG 0x8\n#define   MEM_RDY(cs, reg) (FIELD_GET(GENMASK(3, 0), (reg)) & BIT(cs))\n#define   CTRL_RDY(reg) (FIELD_GET(BIT(8), (reg)) == 0)\n\n#define ECC_CTRL_REG 0x18\n#define   ECC_CTRL_CAP(x) FIELD_PREP(GENMASK(2, 0), (x))\n#define     ECC_CTRL_CAP_2B ECC_CTRL_CAP(0)\n#define     ECC_CTRL_CAP_4B ECC_CTRL_CAP(1)\n#define     ECC_CTRL_CAP_8B ECC_CTRL_CAP(2)\n#define     ECC_CTRL_CAP_16B ECC_CTRL_CAP(3)\n#define     ECC_CTRL_CAP_24B ECC_CTRL_CAP(4)\n#define     ECC_CTRL_CAP_32B ECC_CTRL_CAP(5)\n#define   ECC_CTRL_ERR_THRESHOLD(x) FIELD_PREP(GENMASK(13, 8), (x))\n\n#define INT_MASK_REG 0x10\n#define INT_STATUS_REG 0x14\n#define   INT_CMD_END BIT(1)\n#define   INT_DMA_END BIT(3)\n#define   INT_MEM_RDY(cs) FIELD_PREP(GENMASK(11, 8), BIT(cs))\n#define   INT_DMA_ENDED BIT(3)\n#define   MEM_IS_RDY(cs, reg) (FIELD_GET(GENMASK(11, 8), (reg)) & BIT(cs))\n#define   DMA_HAS_ENDED(reg) FIELD_GET(BIT(3), (reg))\n\n#define ECC_OFFSET_REG 0x1C\n#define   ECC_OFFSET(x) FIELD_PREP(GENMASK(15, 0), (x))\n\n#define ECC_STAT_REG 0x20\n#define   ECC_STAT_CORRECTABLE(cs, reg) (FIELD_GET(GENMASK(3, 0), (reg)) & BIT(cs))\n#define   ECC_STAT_UNCORRECTABLE(cs, reg) (FIELD_GET(GENMASK(11, 8), (reg)) & BIT(cs))\n\n#define ADDR0_COL_REG 0x24\n#define   ADDR0_COL(x) FIELD_PREP(GENMASK(15, 0), (x))\n\n#define ADDR0_ROW_REG 0x28\n#define   ADDR0_ROW(x) FIELD_PREP(GENMASK(23, 0), (x))\n\n#define ADDR1_COL_REG 0x2C\n#define   ADDR1_COL(x) FIELD_PREP(GENMASK(15, 0), (x))\n\n#define ADDR1_ROW_REG 0x30\n#define   ADDR1_ROW(x) FIELD_PREP(GENMASK(23, 0), (x))\n\n#define FIFO_DATA_REG 0x38\n\n#define DATA_REG 0x3C\n\n#define DATA_REG_SIZE_REG 0x40\n\n#define DMA_ADDR_LOW_REG 0x64\n\n#define DMA_ADDR_HIGH_REG 0x68\n\n#define DMA_CNT_REG 0x6C\n\n#define DMA_CTRL_REG 0x70\n#define   DMA_CTRL_INCREMENT_BURST_4 0\n#define   DMA_CTRL_REGISTER_MANAGED_MODE 0\n#define   DMA_CTRL_START BIT(7)\n\n#define MEM_CTRL_REG 0x80\n#define   MEM_CTRL_CS(cs) FIELD_PREP(GENMASK(1, 0), (cs))\n#define   MEM_CTRL_DIS_WP(cs) FIELD_PREP(GENMASK(11, 8), BIT((cs)))\n\n#define DATA_SIZE_REG 0x84\n#define   DATA_SIZE(x) FIELD_PREP(GENMASK(14, 0), (x))\n\n#define TIMINGS_ASYN_REG 0x88\n#define   TIMINGS_ASYN_TRWP(x) FIELD_PREP(GENMASK(3, 0), max((x), 1U) - 1)\n#define   TIMINGS_ASYN_TRWH(x) FIELD_PREP(GENMASK(7, 4), max((x), 1U) - 1)\n\n#define TIM_SEQ0_REG 0x90\n#define   TIM_SEQ0_TCCS(x) FIELD_PREP(GENMASK(5, 0), max((x), 1U) - 1)\n#define   TIM_SEQ0_TADL(x) FIELD_PREP(GENMASK(13, 8), max((x), 1U) - 1)\n#define   TIM_SEQ0_TRHW(x) FIELD_PREP(GENMASK(21, 16), max((x), 1U) - 1)\n#define   TIM_SEQ0_TWHR(x) FIELD_PREP(GENMASK(29, 24), max((x), 1U) - 1)\n\n#define TIM_SEQ1_REG 0x94\n#define   TIM_SEQ1_TWB(x) FIELD_PREP(GENMASK(5, 0), max((x), 1U) - 1)\n#define   TIM_SEQ1_TRR(x) FIELD_PREP(GENMASK(13, 8), max((x), 1U) - 1)\n#define   TIM_SEQ1_TWW(x) FIELD_PREP(GENMASK(21, 16), max((x), 1U) - 1)\n\n#define TIM_GEN_SEQ0_REG 0x98\n#define   TIM_GEN_SEQ0_D0(x) FIELD_PREP(GENMASK(5, 0), max((x), 1U) - 1)\n#define   TIM_GEN_SEQ0_D1(x) FIELD_PREP(GENMASK(13, 8), max((x), 1U) - 1)\n#define   TIM_GEN_SEQ0_D2(x) FIELD_PREP(GENMASK(21, 16), max((x), 1U) - 1)\n#define   TIM_GEN_SEQ0_D3(x) FIELD_PREP(GENMASK(29, 24), max((x), 1U) - 1)\n\n#define TIM_GEN_SEQ1_REG 0x9c\n#define   TIM_GEN_SEQ1_D4(x) FIELD_PREP(GENMASK(5, 0), max((x), 1U) - 1)\n#define   TIM_GEN_SEQ1_D5(x) FIELD_PREP(GENMASK(13, 8), max((x), 1U) - 1)\n#define   TIM_GEN_SEQ1_D6(x) FIELD_PREP(GENMASK(21, 16), max((x), 1U) - 1)\n#define   TIM_GEN_SEQ1_D7(x) FIELD_PREP(GENMASK(29, 24), max((x), 1U) - 1)\n\n#define TIM_GEN_SEQ2_REG 0xA0\n#define   TIM_GEN_SEQ2_D8(x) FIELD_PREP(GENMASK(5, 0), max((x), 1U) - 1)\n#define   TIM_GEN_SEQ2_D9(x) FIELD_PREP(GENMASK(13, 8), max((x), 1U) - 1)\n#define   TIM_GEN_SEQ2_D10(x) FIELD_PREP(GENMASK(21, 16), max((x), 1U) - 1)\n#define   TIM_GEN_SEQ2_D11(x) FIELD_PREP(GENMASK(29, 24), max((x), 1U) - 1)\n\n#define FIFO_INIT_REG 0xB4\n#define   FIFO_INIT BIT(0)\n\n#define FIFO_STATE_REG 0xB4\n#define   FIFO_STATE_R_EMPTY(reg) FIELD_GET(BIT(0), (reg))\n#define   FIFO_STATE_W_FULL(reg) FIELD_GET(BIT(1), (reg))\n#define   FIFO_STATE_C_EMPTY(reg) FIELD_GET(BIT(2), (reg))\n#define   FIFO_STATE_R_FULL(reg) FIELD_GET(BIT(6), (reg))\n#define   FIFO_STATE_W_EMPTY(reg) FIELD_GET(BIT(7), (reg))\n\n#define GEN_SEQ_CTRL_REG 0xB8\n#define   GEN_SEQ_CMD0_EN BIT(0)\n#define   GEN_SEQ_CMD1_EN BIT(1)\n#define   GEN_SEQ_CMD2_EN BIT(2)\n#define   GEN_SEQ_CMD3_EN BIT(3)\n#define   GEN_SEQ_COL_A0(x) FIELD_PREP(GENMASK(5, 4), min((x), 2U))\n#define   GEN_SEQ_COL_A1(x) FIELD_PREP(GENMASK(7, 6), min((x), 2U))\n#define   GEN_SEQ_ROW_A0(x) FIELD_PREP(GENMASK(9, 8), min((x), 3U))\n#define   GEN_SEQ_ROW_A1(x) FIELD_PREP(GENMASK(11, 10), min((x), 3U))\n#define   GEN_SEQ_DATA_EN BIT(12)\n#define   GEN_SEQ_DELAY_EN(x) FIELD_PREP(GENMASK(14, 13), (x))\n#define     GEN_SEQ_DELAY0_EN GEN_SEQ_DELAY_EN(1)\n#define     GEN_SEQ_DELAY1_EN GEN_SEQ_DELAY_EN(2)\n#define   GEN_SEQ_IMD_SEQ BIT(15)\n#define   GEN_SEQ_COMMAND_3(x) FIELD_PREP(GENMASK(26, 16), (x))\n\n#define DMA_TLVL_REG 0x114\n#define   DMA_TLVL(x) FIELD_PREP(GENMASK(7, 0), (x))\n#define   DMA_TLVL_MAX DMA_TLVL(0xFF)\n\n#define TIM_GEN_SEQ3_REG 0x134\n#define   TIM_GEN_SEQ3_D12(x) FIELD_PREP(GENMASK(5, 0), max((x), 1U) - 1)\n\n#define ECC_CNT_REG 0x14C\n#define   ECC_CNT(cs, reg) FIELD_GET(GENMASK(5, 0), (reg) >> ((cs) * 8))\n\n#define RNANDC_CS_NUM 4\n\n#define TO_CYCLES64(ps, period_ns) ((unsigned int)DIV_ROUND_UP_ULL(div_u64(ps, 1000), \\\n\t\t\t\t\t\t\t\t   period_ns))\n\nstruct rnand_chip_sel {\n\tunsigned int cs;\n};\n\nstruct rnand_chip {\n\tstruct nand_chip chip;\n\tstruct list_head node;\n\tint selected_die;\n\tu32 ctrl;\n\tunsigned int nsels;\n\tu32 control;\n\tu32 ecc_ctrl;\n\tu32 timings_asyn;\n\tu32 tim_seq0;\n\tu32 tim_seq1;\n\tu32 tim_gen_seq0;\n\tu32 tim_gen_seq1;\n\tu32 tim_gen_seq2;\n\tu32 tim_gen_seq3;\n\tstruct rnand_chip_sel sels[];\n};\n\nstruct rnandc {\n\tstruct nand_controller controller;\n\tstruct device *dev;\n\tvoid __iomem *regs;\n\tunsigned long ext_clk_rate;\n\tunsigned long assigned_cs;\n\tstruct list_head chips;\n\tstruct nand_chip *selected_chip;\n\tstruct completion complete;\n\tbool use_polling;\n\tu8 *buf;\n\tunsigned int buf_sz;\n};\n\nstruct rnandc_op {\n\tu32 command;\n\tu32 addr0_col;\n\tu32 addr0_row;\n\tu32 addr1_col;\n\tu32 addr1_row;\n\tu32 data_size;\n\tu32 ecc_offset;\n\tu32 gen_seq_ctrl;\n\tu8 *buf;\n\tbool read;\n\tunsigned int len;\n};\n\nstatic inline struct rnandc *to_rnandc(struct nand_controller *ctrl)\n{\n\treturn container_of(ctrl, struct rnandc, controller);\n}\n\nstatic inline struct rnand_chip *to_rnand(struct nand_chip *chip)\n{\n\treturn container_of(chip, struct rnand_chip, chip);\n}\n\nstatic inline unsigned int to_rnandc_cs(struct rnand_chip *nand)\n{\n\treturn nand->sels[nand->selected_die].cs;\n}\n\nstatic void rnandc_dis_correction(struct rnandc *rnandc)\n{\n\tu32 control;\n\n\tcontrol = readl_relaxed(rnandc->regs + CONTROL_REG);\n\tcontrol &= ~CONTROL_ECC_EN;\n\twritel_relaxed(control, rnandc->regs + CONTROL_REG);\n}\n\nstatic void rnandc_en_correction(struct rnandc *rnandc)\n{\n\tu32 control;\n\n\tcontrol = readl_relaxed(rnandc->regs + CONTROL_REG);\n\tcontrol |= CONTROL_ECC_EN;\n\twritel_relaxed(control, rnandc->regs + CONTROL_REG);\n}\n\nstatic void rnandc_clear_status(struct rnandc *rnandc)\n{\n\twritel_relaxed(0, rnandc->regs + INT_STATUS_REG);\n\twritel_relaxed(0, rnandc->regs + ECC_STAT_REG);\n\twritel_relaxed(0, rnandc->regs + ECC_CNT_REG);\n}\n\nstatic void rnandc_dis_interrupts(struct rnandc *rnandc)\n{\n\twritel_relaxed(0, rnandc->regs + INT_MASK_REG);\n}\n\nstatic void rnandc_en_interrupts(struct rnandc *rnandc, u32 val)\n{\n\tif (!rnandc->use_polling)\n\t\twritel_relaxed(val, rnandc->regs + INT_MASK_REG);\n}\n\nstatic void rnandc_clear_fifo(struct rnandc *rnandc)\n{\n\twritel_relaxed(FIFO_INIT, rnandc->regs + FIFO_INIT_REG);\n}\n\nstatic void rnandc_select_target(struct nand_chip *chip, int die_nr)\n{\n\tstruct rnand_chip *rnand = to_rnand(chip);\n\tstruct rnandc *rnandc = to_rnandc(chip->controller);\n\tunsigned int cs = rnand->sels[die_nr].cs;\n\n\tif (chip == rnandc->selected_chip && die_nr == rnand->selected_die)\n\t\treturn;\n\n\trnandc_clear_status(rnandc);\n\twritel_relaxed(MEM_CTRL_CS(cs) | MEM_CTRL_DIS_WP(cs), rnandc->regs + MEM_CTRL_REG);\n\twritel_relaxed(rnand->control, rnandc->regs + CONTROL_REG);\n\twritel_relaxed(rnand->ecc_ctrl, rnandc->regs + ECC_CTRL_REG);\n\twritel_relaxed(rnand->timings_asyn, rnandc->regs + TIMINGS_ASYN_REG);\n\twritel_relaxed(rnand->tim_seq0, rnandc->regs + TIM_SEQ0_REG);\n\twritel_relaxed(rnand->tim_seq1, rnandc->regs + TIM_SEQ1_REG);\n\twritel_relaxed(rnand->tim_gen_seq0, rnandc->regs + TIM_GEN_SEQ0_REG);\n\twritel_relaxed(rnand->tim_gen_seq1, rnandc->regs + TIM_GEN_SEQ1_REG);\n\twritel_relaxed(rnand->tim_gen_seq2, rnandc->regs + TIM_GEN_SEQ2_REG);\n\twritel_relaxed(rnand->tim_gen_seq3, rnandc->regs + TIM_GEN_SEQ3_REG);\n\n\trnandc->selected_chip = chip;\n\trnand->selected_die = die_nr;\n}\n\nstatic void rnandc_trigger_op(struct rnandc *rnandc, struct rnandc_op *rop)\n{\n\twritel_relaxed(rop->addr0_col, rnandc->regs + ADDR0_COL_REG);\n\twritel_relaxed(rop->addr0_row, rnandc->regs + ADDR0_ROW_REG);\n\twritel_relaxed(rop->addr1_col, rnandc->regs + ADDR1_COL_REG);\n\twritel_relaxed(rop->addr1_row, rnandc->regs + ADDR1_ROW_REG);\n\twritel_relaxed(rop->ecc_offset, rnandc->regs + ECC_OFFSET_REG);\n\twritel_relaxed(rop->gen_seq_ctrl, rnandc->regs + GEN_SEQ_CTRL_REG);\n\twritel_relaxed(DATA_SIZE(rop->len), rnandc->regs + DATA_SIZE_REG);\n\twritel_relaxed(rop->command, rnandc->regs + COMMAND_REG);\n}\n\nstatic void rnandc_trigger_dma(struct rnandc *rnandc)\n{\n\twritel_relaxed(DMA_CTRL_INCREMENT_BURST_4 |\n\t\t       DMA_CTRL_REGISTER_MANAGED_MODE |\n\t\t       DMA_CTRL_START, rnandc->regs + DMA_CTRL_REG);\n}\n\nstatic irqreturn_t rnandc_irq_handler(int irq, void *private)\n{\n\tstruct rnandc *rnandc = private;\n\n\trnandc_dis_interrupts(rnandc);\n\tcomplete(&rnandc->complete);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int rnandc_wait_end_of_op(struct rnandc *rnandc,\n\t\t\t\t struct nand_chip *chip)\n{\n\tstruct rnand_chip *rnand = to_rnand(chip);\n\tunsigned int cs = to_rnandc_cs(rnand);\n\tu32 status;\n\tint ret;\n\n\tret = readl_poll_timeout(rnandc->regs + STATUS_REG, status,\n\t\t\t\t MEM_RDY(cs, status) && CTRL_RDY(status),\n\t\t\t\t 1, 100000);\n\tif (ret)\n\t\tdev_err(rnandc->dev, \"Operation timed out, status: 0x%08x\\n\",\n\t\t\tstatus);\n\n\treturn ret;\n}\n\nstatic int rnandc_wait_end_of_io(struct rnandc *rnandc,\n\t\t\t\t struct nand_chip *chip)\n{\n\tint timeout_ms = 1000;\n\tint ret;\n\n\tif (rnandc->use_polling) {\n\t\tstruct rnand_chip *rnand = to_rnand(chip);\n\t\tunsigned int cs = to_rnandc_cs(rnand);\n\t\tu32 status;\n\n\t\tret = readl_poll_timeout(rnandc->regs + INT_STATUS_REG, status,\n\t\t\t\t\t MEM_IS_RDY(cs, status) &\n\t\t\t\t\t DMA_HAS_ENDED(status),\n\t\t\t\t\t 0, timeout_ms * 1000);\n\t} else {\n\t\tret = wait_for_completion_timeout(&rnandc->complete,\n\t\t\t\t\t\t  msecs_to_jiffies(timeout_ms));\n\t\tif (!ret)\n\t\t\tret = -ETIMEDOUT;\n\t\telse\n\t\t\tret = 0;\n\t}\n\n\treturn ret;\n}\n\nstatic int rnandc_read_page_hw_ecc(struct nand_chip *chip, u8 *buf,\n\t\t\t\t   int oob_required, int page)\n{\n\tstruct rnandc *rnandc = to_rnandc(chip->controller);\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tstruct rnand_chip *rnand = to_rnand(chip);\n\tunsigned int cs = to_rnandc_cs(rnand);\n\tstruct rnandc_op rop = {\n\t\t.command = COMMAND_INPUT_SEL_DMA | COMMAND_0(NAND_CMD_READ0) |\n\t\t\t   COMMAND_2(NAND_CMD_READSTART) | COMMAND_FIFO_SEL |\n\t\t\t   COMMAND_SEQ_READ_PAGE,\n\t\t.addr0_row = page,\n\t\t.len = mtd->writesize,\n\t\t.ecc_offset = ECC_OFFSET(mtd->writesize + 2),\n\t};\n\tunsigned int max_bitflips = 0;\n\tdma_addr_t dma_addr;\n\tu32 ecc_stat;\n\tint bf, ret, i;\n\n\t \n\trnandc_select_target(chip, chip->cur_cs);\n\trnandc_clear_status(rnandc);\n\treinit_completion(&rnandc->complete);\n\trnandc_en_interrupts(rnandc, INT_DMA_ENDED);\n\trnandc_en_correction(rnandc);\n\n\t \n\tdma_addr = dma_map_single(rnandc->dev, rnandc->buf, mtd->writesize,\n\t\t\t\t  DMA_FROM_DEVICE);\n\twritel(dma_addr, rnandc->regs + DMA_ADDR_LOW_REG);\n\twritel(mtd->writesize, rnandc->regs + DMA_CNT_REG);\n\twritel(DMA_TLVL_MAX, rnandc->regs + DMA_TLVL_REG);\n\n\trnandc_trigger_op(rnandc, &rop);\n\trnandc_trigger_dma(rnandc);\n\n\tret = rnandc_wait_end_of_io(rnandc, chip);\n\tdma_unmap_single(rnandc->dev, dma_addr, mtd->writesize, DMA_FROM_DEVICE);\n\trnandc_dis_correction(rnandc);\n\tif (ret) {\n\t\tdev_err(rnandc->dev, \"Read page operation never ending\\n\");\n\t\treturn ret;\n\t}\n\n\tecc_stat = readl_relaxed(rnandc->regs + ECC_STAT_REG);\n\n\tif (oob_required || ECC_STAT_UNCORRECTABLE(cs, ecc_stat)) {\n\t\tret = nand_change_read_column_op(chip, mtd->writesize,\n\t\t\t\t\t\t chip->oob_poi, mtd->oobsize,\n\t\t\t\t\t\t false);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (ECC_STAT_UNCORRECTABLE(cs, ecc_stat)) {\n\t\tfor (i = 0; i < chip->ecc.steps; i++) {\n\t\t\tunsigned int off = i * chip->ecc.size;\n\t\t\tunsigned int eccoff = i * chip->ecc.bytes;\n\n\t\t\tbf = nand_check_erased_ecc_chunk(rnandc->buf + off,\n\t\t\t\t\t\t\t chip->ecc.size,\n\t\t\t\t\t\t\t chip->oob_poi + 2 + eccoff,\n\t\t\t\t\t\t\t chip->ecc.bytes,\n\t\t\t\t\t\t\t NULL, 0,\n\t\t\t\t\t\t\t chip->ecc.strength);\n\t\t\tif (bf < 0) {\n\t\t\t\tmtd->ecc_stats.failed++;\n\t\t\t} else {\n\t\t\t\tmtd->ecc_stats.corrected += bf;\n\t\t\t\tmax_bitflips = max_t(unsigned int, max_bitflips, bf);\n\t\t\t}\n\t\t}\n\t} else if (ECC_STAT_CORRECTABLE(cs, ecc_stat)) {\n\t\tbf = ECC_CNT(cs, readl_relaxed(rnandc->regs + ECC_CNT_REG));\n\t\t \n\t\tmtd->ecc_stats.corrected += bf;\n\t}\n\n\tmemcpy(buf, rnandc->buf, mtd->writesize);\n\n\treturn 0;\n}\n\nstatic int rnandc_read_subpage_hw_ecc(struct nand_chip *chip, u32 req_offset,\n\t\t\t\t      u32 req_len, u8 *bufpoi, int page)\n{\n\tstruct rnandc *rnandc = to_rnandc(chip->controller);\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tstruct rnand_chip *rnand = to_rnand(chip);\n\tunsigned int cs = to_rnandc_cs(rnand);\n\tunsigned int page_off = round_down(req_offset, chip->ecc.size);\n\tunsigned int real_len = round_up(req_offset + req_len - page_off,\n\t\t\t\t\t chip->ecc.size);\n\tunsigned int start_chunk = page_off / chip->ecc.size;\n\tunsigned int nchunks = real_len / chip->ecc.size;\n\tunsigned int ecc_off = 2 + (start_chunk * chip->ecc.bytes);\n\tstruct rnandc_op rop = {\n\t\t.command = COMMAND_INPUT_SEL_AHBS | COMMAND_0(NAND_CMD_READ0) |\n\t\t\t   COMMAND_2(NAND_CMD_READSTART) | COMMAND_FIFO_SEL |\n\t\t\t   COMMAND_SEQ_READ_PAGE,\n\t\t.addr0_row = page,\n\t\t.addr0_col = page_off,\n\t\t.len = real_len,\n\t\t.ecc_offset = ECC_OFFSET(mtd->writesize + ecc_off),\n\t};\n\tunsigned int max_bitflips = 0, i;\n\tu32 ecc_stat;\n\tint bf, ret;\n\n\t \n\trnandc_select_target(chip, chip->cur_cs);\n\trnandc_clear_status(rnandc);\n\trnandc_en_correction(rnandc);\n\trnandc_trigger_op(rnandc, &rop);\n\n\twhile (!FIFO_STATE_C_EMPTY(readl(rnandc->regs + FIFO_STATE_REG)))\n\t\tcpu_relax();\n\n\twhile (FIFO_STATE_R_EMPTY(readl(rnandc->regs + FIFO_STATE_REG)))\n\t\tcpu_relax();\n\n\tioread32_rep(rnandc->regs + FIFO_DATA_REG, bufpoi + page_off,\n\t\t     real_len / 4);\n\n\tif (!FIFO_STATE_R_EMPTY(readl(rnandc->regs + FIFO_STATE_REG))) {\n\t\tdev_err(rnandc->dev, \"Clearing residual data in the read FIFO\\n\");\n\t\trnandc_clear_fifo(rnandc);\n\t}\n\n\tret = rnandc_wait_end_of_op(rnandc, chip);\n\trnandc_dis_correction(rnandc);\n\tif (ret) {\n\t\tdev_err(rnandc->dev, \"Read subpage operation never ending\\n\");\n\t\treturn ret;\n\t}\n\n\tecc_stat = readl_relaxed(rnandc->regs + ECC_STAT_REG);\n\n\tif (ECC_STAT_UNCORRECTABLE(cs, ecc_stat)) {\n\t\tret = nand_change_read_column_op(chip, mtd->writesize,\n\t\t\t\t\t\t chip->oob_poi, mtd->oobsize,\n\t\t\t\t\t\t false);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tfor (i = start_chunk; i < nchunks; i++) {\n\t\t\tunsigned int dataoff = i * chip->ecc.size;\n\t\t\tunsigned int eccoff = 2 + (i * chip->ecc.bytes);\n\n\t\t\tbf = nand_check_erased_ecc_chunk(bufpoi + dataoff,\n\t\t\t\t\t\t\t chip->ecc.size,\n\t\t\t\t\t\t\t chip->oob_poi + eccoff,\n\t\t\t\t\t\t\t chip->ecc.bytes,\n\t\t\t\t\t\t\t NULL, 0,\n\t\t\t\t\t\t\t chip->ecc.strength);\n\t\t\tif (bf < 0) {\n\t\t\t\tmtd->ecc_stats.failed++;\n\t\t\t} else {\n\t\t\t\tmtd->ecc_stats.corrected += bf;\n\t\t\t\tmax_bitflips = max_t(unsigned int, max_bitflips, bf);\n\t\t\t}\n\t\t}\n\t} else if (ECC_STAT_CORRECTABLE(cs, ecc_stat)) {\n\t\tbf = ECC_CNT(cs, readl_relaxed(rnandc->regs + ECC_CNT_REG));\n\t\t \n\t\tmtd->ecc_stats.corrected += bf;\n\t}\n\n\treturn 0;\n}\n\nstatic int rnandc_write_page_hw_ecc(struct nand_chip *chip, const u8 *buf,\n\t\t\t\t    int oob_required, int page)\n{\n\tstruct rnandc *rnandc = to_rnandc(chip->controller);\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tstruct rnand_chip *rnand = to_rnand(chip);\n\tunsigned int cs = to_rnandc_cs(rnand);\n\tstruct rnandc_op rop = {\n\t\t.command = COMMAND_INPUT_SEL_DMA | COMMAND_0(NAND_CMD_SEQIN) |\n\t\t\t   COMMAND_1(NAND_CMD_PAGEPROG) | COMMAND_FIFO_SEL |\n\t\t\t   COMMAND_SEQ_WRITE_PAGE,\n\t\t.addr0_row = page,\n\t\t.len = mtd->writesize,\n\t\t.ecc_offset = ECC_OFFSET(mtd->writesize + 2),\n\t};\n\tdma_addr_t dma_addr;\n\tint ret;\n\n\tmemcpy(rnandc->buf, buf, mtd->writesize);\n\n\t \n\trnandc_select_target(chip, chip->cur_cs);\n\trnandc_clear_status(rnandc);\n\treinit_completion(&rnandc->complete);\n\trnandc_en_interrupts(rnandc, INT_MEM_RDY(cs));\n\trnandc_en_correction(rnandc);\n\n\t \n\tdma_addr = dma_map_single(rnandc->dev, (void *)rnandc->buf, mtd->writesize,\n\t\t\t\t  DMA_TO_DEVICE);\n\twritel(dma_addr, rnandc->regs + DMA_ADDR_LOW_REG);\n\twritel(mtd->writesize, rnandc->regs + DMA_CNT_REG);\n\twritel(DMA_TLVL_MAX, rnandc->regs + DMA_TLVL_REG);\n\n\trnandc_trigger_op(rnandc, &rop);\n\trnandc_trigger_dma(rnandc);\n\n\tret = rnandc_wait_end_of_io(rnandc, chip);\n\tdma_unmap_single(rnandc->dev, dma_addr, mtd->writesize, DMA_TO_DEVICE);\n\trnandc_dis_correction(rnandc);\n\tif (ret) {\n\t\tdev_err(rnandc->dev, \"Write page operation never ending\\n\");\n\t\treturn ret;\n\t}\n\n\tif (!oob_required)\n\t\treturn 0;\n\n\treturn nand_change_write_column_op(chip, mtd->writesize, chip->oob_poi,\n\t\t\t\t\t   mtd->oobsize, false);\n}\n\nstatic int rnandc_write_subpage_hw_ecc(struct nand_chip *chip, u32 req_offset,\n\t\t\t\t       u32 req_len, const u8 *bufpoi,\n\t\t\t\t       int oob_required, int page)\n{\n\tstruct rnandc *rnandc = to_rnandc(chip->controller);\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tunsigned int page_off = round_down(req_offset, chip->ecc.size);\n\tunsigned int real_len = round_up(req_offset + req_len - page_off,\n\t\t\t\t\t chip->ecc.size);\n\tunsigned int start_chunk = page_off / chip->ecc.size;\n\tunsigned int ecc_off = 2 + (start_chunk * chip->ecc.bytes);\n\tstruct rnandc_op rop = {\n\t\t.command = COMMAND_INPUT_SEL_AHBS | COMMAND_0(NAND_CMD_SEQIN) |\n\t\t\t   COMMAND_1(NAND_CMD_PAGEPROG) | COMMAND_FIFO_SEL |\n\t\t\t   COMMAND_SEQ_WRITE_PAGE,\n\t\t.addr0_row = page,\n\t\t.addr0_col = page_off,\n\t\t.len = real_len,\n\t\t.ecc_offset = ECC_OFFSET(mtd->writesize + ecc_off),\n\t};\n\tint ret;\n\n\t \n\trnandc_select_target(chip, chip->cur_cs);\n\trnandc_clear_status(rnandc);\n\trnandc_en_correction(rnandc);\n\trnandc_trigger_op(rnandc, &rop);\n\n\twhile (FIFO_STATE_W_FULL(readl(rnandc->regs + FIFO_STATE_REG)))\n\t\tcpu_relax();\n\n\tiowrite32_rep(rnandc->regs + FIFO_DATA_REG, bufpoi + page_off,\n\t\t      real_len / 4);\n\n\twhile (!FIFO_STATE_W_EMPTY(readl(rnandc->regs + FIFO_STATE_REG)))\n\t\tcpu_relax();\n\n\tret = rnandc_wait_end_of_op(rnandc, chip);\n\trnandc_dis_correction(rnandc);\n\tif (ret) {\n\t\tdev_err(rnandc->dev, \"Write subpage operation never ending\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int rnandc_exec_op(struct nand_chip *chip,\n\t\t\t  const struct nand_operation *op, bool check_only)\n{\n\tstruct rnandc *rnandc = to_rnandc(chip->controller);\n\tconst struct nand_op_instr *instr = NULL;\n\tstruct rnandc_op rop = {\n\t\t.command = COMMAND_INPUT_SEL_AHBS,\n\t\t.gen_seq_ctrl = GEN_SEQ_IMD_SEQ,\n\t};\n\tunsigned int cmd_phase = 0, addr_phase = 0, data_phase = 0,\n\t\tdelay_phase = 0, delays = 0;\n\tunsigned int op_id, col_addrs, row_addrs, naddrs, remainder, words, i;\n\tconst u8 *addrs;\n\tu32 last_bytes;\n\tint ret;\n\n\tif (!check_only)\n\t\trnandc_select_target(chip, op->cs);\n\n\tfor (op_id = 0; op_id < op->ninstrs; op_id++) {\n\t\tinstr = &op->instrs[op_id];\n\n\t\tnand_op_trace(\"  \", instr);\n\n\t\tswitch (instr->type) {\n\t\tcase NAND_OP_CMD_INSTR:\n\t\t\tswitch (cmd_phase++) {\n\t\t\tcase 0:\n\t\t\t\trop.command |= COMMAND_0(instr->ctx.cmd.opcode);\n\t\t\t\trop.gen_seq_ctrl |= GEN_SEQ_CMD0_EN;\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\trop.gen_seq_ctrl |= GEN_SEQ_COMMAND_3(instr->ctx.cmd.opcode);\n\t\t\t\trop.gen_seq_ctrl |= GEN_SEQ_CMD3_EN;\n\t\t\t\tif (addr_phase == 0)\n\t\t\t\t\taddr_phase = 1;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\trop.command |= COMMAND_2(instr->ctx.cmd.opcode);\n\t\t\t\trop.gen_seq_ctrl |= GEN_SEQ_CMD2_EN;\n\t\t\t\tif (addr_phase <= 1)\n\t\t\t\t\taddr_phase = 2;\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\trop.command |= COMMAND_1(instr->ctx.cmd.opcode);\n\t\t\t\trop.gen_seq_ctrl |= GEN_SEQ_CMD1_EN;\n\t\t\t\tif (addr_phase <= 1)\n\t\t\t\t\taddr_phase = 2;\n\t\t\t\tif (delay_phase == 0)\n\t\t\t\t\tdelay_phase = 1;\n\t\t\t\tif (data_phase == 0)\n\t\t\t\t\tdata_phase = 1;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn -EOPNOTSUPP;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase NAND_OP_ADDR_INSTR:\n\t\t\taddrs = instr->ctx.addr.addrs;\n\t\t\tnaddrs = instr->ctx.addr.naddrs;\n\t\t\tif (naddrs > 5)\n\t\t\t\treturn -EOPNOTSUPP;\n\n\t\t\tcol_addrs = min(2U, naddrs);\n\t\t\trow_addrs = naddrs > 2 ? naddrs - col_addrs : 0;\n\n\t\t\tswitch (addr_phase++) {\n\t\t\tcase 0:\n\t\t\t\tfor (i = 0; i < col_addrs; i++)\n\t\t\t\t\trop.addr0_col |= addrs[i] << (i * 8);\n\t\t\t\trop.gen_seq_ctrl |= GEN_SEQ_COL_A0(col_addrs);\n\n\t\t\t\tfor (i = 0; i < row_addrs; i++)\n\t\t\t\t\trop.addr0_row |= addrs[2 + i] << (i * 8);\n\t\t\t\trop.gen_seq_ctrl |= GEN_SEQ_ROW_A0(row_addrs);\n\n\t\t\t\tif (cmd_phase == 0)\n\t\t\t\t\tcmd_phase = 1;\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tfor (i = 0; i < col_addrs; i++)\n\t\t\t\t\trop.addr1_col |= addrs[i] << (i * 8);\n\t\t\t\trop.gen_seq_ctrl |= GEN_SEQ_COL_A1(col_addrs);\n\n\t\t\t\tfor (i = 0; i < row_addrs; i++)\n\t\t\t\t\trop.addr1_row |= addrs[2 + i] << (i * 8);\n\t\t\t\trop.gen_seq_ctrl |= GEN_SEQ_ROW_A1(row_addrs);\n\n\t\t\t\tif (cmd_phase <= 1)\n\t\t\t\t\tcmd_phase = 2;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn -EOPNOTSUPP;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase NAND_OP_DATA_IN_INSTR:\n\t\t\trop.read = true;\n\t\t\tfallthrough;\n\t\tcase NAND_OP_DATA_OUT_INSTR:\n\t\t\trop.gen_seq_ctrl |= GEN_SEQ_DATA_EN;\n\t\t\trop.buf = instr->ctx.data.buf.in;\n\t\t\trop.len = instr->ctx.data.len;\n\t\t\trop.command |= COMMAND_FIFO_SEL;\n\n\t\t\tswitch (data_phase++) {\n\t\t\tcase 0:\n\t\t\t\tif (cmd_phase <= 2)\n\t\t\t\t\tcmd_phase = 3;\n\t\t\t\tif (addr_phase <= 1)\n\t\t\t\t\taddr_phase = 2;\n\t\t\t\tif (delay_phase == 0)\n\t\t\t\t\tdelay_phase = 1;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn -EOPNOTSUPP;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase NAND_OP_WAITRDY_INSTR:\n\t\t\tswitch (delay_phase++) {\n\t\t\tcase 0:\n\t\t\t\trop.gen_seq_ctrl |= GEN_SEQ_DELAY0_EN;\n\n\t\t\t\tif (cmd_phase <= 2)\n\t\t\t\t\tcmd_phase = 3;\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\trop.gen_seq_ctrl |= GEN_SEQ_DELAY1_EN;\n\n\t\t\t\tif (cmd_phase <= 3)\n\t\t\t\t\tcmd_phase = 4;\n\t\t\t\tif (data_phase == 0)\n\t\t\t\t\tdata_phase = 1;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn -EOPNOTSUPP;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tif (rop.buf && !rop.read)\n\t\trop.command |= COMMAND_SEQ_GEN_OUT;\n\telse\n\t\trop.command |= COMMAND_SEQ_GEN_IN;\n\n\tif (delays > 1) {\n\t\tdev_err(rnandc->dev, \"Cannot handle more than one wait delay\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (check_only)\n\t\treturn 0;\n\n\trnandc_trigger_op(rnandc, &rop);\n\n\twords = rop.len / sizeof(u32);\n\tremainder = rop.len % sizeof(u32);\n\tif (rop.buf && rop.read) {\n\t\twhile (!FIFO_STATE_C_EMPTY(readl(rnandc->regs + FIFO_STATE_REG)))\n\t\t\tcpu_relax();\n\n\t\twhile (FIFO_STATE_R_EMPTY(readl(rnandc->regs + FIFO_STATE_REG)))\n\t\t\tcpu_relax();\n\n\t\tioread32_rep(rnandc->regs + FIFO_DATA_REG, rop.buf, words);\n\t\tif (remainder) {\n\t\t\tlast_bytes = readl_relaxed(rnandc->regs + FIFO_DATA_REG);\n\t\t\tmemcpy(rop.buf + (words * sizeof(u32)), &last_bytes,\n\t\t\t       remainder);\n\t\t}\n\n\t\tif (!FIFO_STATE_R_EMPTY(readl(rnandc->regs + FIFO_STATE_REG))) {\n\t\t\tdev_warn(rnandc->dev,\n\t\t\t\t \"Clearing residual data in the read FIFO\\n\");\n\t\t\trnandc_clear_fifo(rnandc);\n\t\t}\n\t} else if (rop.len && !rop.read) {\n\t\twhile (FIFO_STATE_W_FULL(readl(rnandc->regs + FIFO_STATE_REG)))\n\t\t\tcpu_relax();\n\n\t\tiowrite32_rep(rnandc->regs + FIFO_DATA_REG, rop.buf,\n\t\t\t      DIV_ROUND_UP(rop.len, 4));\n\n\t\tif (remainder) {\n\t\t\tlast_bytes = 0;\n\t\t\tmemcpy(&last_bytes, rop.buf + (words * sizeof(u32)), remainder);\n\t\t\twritel_relaxed(last_bytes, rnandc->regs + FIFO_DATA_REG);\n\t\t}\n\n\t\twhile (!FIFO_STATE_W_EMPTY(readl(rnandc->regs + FIFO_STATE_REG)))\n\t\t\tcpu_relax();\n\t}\n\n\tret = rnandc_wait_end_of_op(rnandc, chip);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int rnandc_setup_interface(struct nand_chip *chip, int chipnr,\n\t\t\t\t  const struct nand_interface_config *conf)\n{\n\tstruct rnand_chip *rnand = to_rnand(chip);\n\tstruct rnandc *rnandc = to_rnandc(chip->controller);\n\tunsigned int period_ns = 1000000000 / rnandc->ext_clk_rate;\n\tconst struct nand_sdr_timings *sdr;\n\tunsigned int cyc, cle, ale, bef_dly, ca_to_data;\n\n\tsdr = nand_get_sdr_timings(conf);\n\tif (IS_ERR(sdr))\n\t\treturn PTR_ERR(sdr);\n\n\tif (sdr->tRP_min != sdr->tWP_min || sdr->tREH_min != sdr->tWH_min) {\n\t\tdev_err(rnandc->dev, \"Read and write hold times must be identical\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (chipnr < 0)\n\t\treturn 0;\n\n\trnand->timings_asyn =\n\t\tTIMINGS_ASYN_TRWP(TO_CYCLES64(sdr->tRP_min, period_ns)) |\n\t\tTIMINGS_ASYN_TRWH(TO_CYCLES64(sdr->tREH_min, period_ns));\n\trnand->tim_seq0 =\n\t\tTIM_SEQ0_TCCS(TO_CYCLES64(sdr->tCCS_min, period_ns)) |\n\t\tTIM_SEQ0_TADL(TO_CYCLES64(sdr->tADL_min, period_ns)) |\n\t\tTIM_SEQ0_TRHW(TO_CYCLES64(sdr->tRHW_min, period_ns)) |\n\t\tTIM_SEQ0_TWHR(TO_CYCLES64(sdr->tWHR_min, period_ns));\n\trnand->tim_seq1 =\n\t\tTIM_SEQ1_TWB(TO_CYCLES64(sdr->tWB_max, period_ns)) |\n\t\tTIM_SEQ1_TRR(TO_CYCLES64(sdr->tRR_min, period_ns)) |\n\t\tTIM_SEQ1_TWW(TO_CYCLES64(sdr->tWW_min, period_ns));\n\n\tcyc = sdr->tDS_min + sdr->tDH_min;\n\tcle = sdr->tCLH_min + sdr->tCLS_min;\n\tale = sdr->tALH_min + sdr->tALS_min;\n\tbef_dly = sdr->tWB_max - sdr->tDH_min;\n\tca_to_data = sdr->tWHR_min + sdr->tREA_max - sdr->tDH_min;\n\n\t \n\trnand->tim_gen_seq0 =\n\t\tTIM_GEN_SEQ0_D0(TO_CYCLES64(cle - cyc, period_ns)) |\n\t\tTIM_GEN_SEQ0_D1(TO_CYCLES64(cle - cyc, period_ns)) |\n\t\tTIM_GEN_SEQ0_D2(TO_CYCLES64(bef_dly, period_ns)) |\n\t\tTIM_GEN_SEQ0_D3(TO_CYCLES64(ca_to_data, period_ns));\n\n\t \n\trnand->tim_gen_seq1 =\n\t\tTIM_GEN_SEQ1_D4(TO_CYCLES64(ale - cyc, period_ns)) |\n\t\tTIM_GEN_SEQ1_D5(TO_CYCLES64(ale - cyc, period_ns)) |\n\t\tTIM_GEN_SEQ1_D6(TO_CYCLES64(bef_dly, period_ns)) |\n\t\tTIM_GEN_SEQ1_D7(TO_CYCLES64(ca_to_data, period_ns));\n\n\t \n\trnand->tim_gen_seq2 =\n\t\tTIM_GEN_SEQ2_D8(TO_CYCLES64(sdr->tRR_min + sdr->tREA_max, period_ns)) |\n\t\tTIM_GEN_SEQ2_D9(TO_CYCLES64(sdr->tRR_min, period_ns)) |\n\t\tTIM_GEN_SEQ2_D10(TO_CYCLES64(cle - cyc, period_ns)) |\n\t\tTIM_GEN_SEQ2_D11(TO_CYCLES64(bef_dly, period_ns));\n\n\t \n\trnand->tim_gen_seq3 =\n\t\tTIM_GEN_SEQ3_D12(TO_CYCLES64(sdr->tCLH_min - sdr->tDH_min, period_ns));\n\n\treturn 0;\n}\n\nstatic int rnandc_ooblayout_ecc(struct mtd_info *mtd, int section,\n\t\t\t\tstruct mtd_oob_region *oobregion)\n{\n\tstruct nand_chip *chip = mtd_to_nand(mtd);\n\tunsigned int eccbytes = round_up(chip->ecc.bytes, 4) * chip->ecc.steps;\n\n\tif (section)\n\t\treturn -ERANGE;\n\n\toobregion->offset = 2;\n\toobregion->length = eccbytes;\n\n\treturn 0;\n}\n\nstatic int rnandc_ooblayout_free(struct mtd_info *mtd, int section,\n\t\t\t\t struct mtd_oob_region *oobregion)\n{\n\tstruct nand_chip *chip = mtd_to_nand(mtd);\n\tunsigned int eccbytes = round_up(chip->ecc.bytes, 4) * chip->ecc.steps;\n\n\tif (section)\n\t\treturn -ERANGE;\n\n\toobregion->offset = 2 + eccbytes;\n\toobregion->length = mtd->oobsize - oobregion->offset;\n\n\treturn 0;\n}\n\nstatic const struct mtd_ooblayout_ops rnandc_ooblayout_ops = {\n\t.ecc = rnandc_ooblayout_ecc,\n\t.free = rnandc_ooblayout_free,\n};\n\nstatic int rnandc_hw_ecc_controller_init(struct nand_chip *chip)\n{\n\tstruct rnand_chip *rnand = to_rnand(chip);\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tstruct rnandc *rnandc = to_rnandc(chip->controller);\n\n\tif (mtd->writesize > SZ_16K) {\n\t\tdev_err(rnandc->dev, \"Unsupported page size\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (chip->ecc.size) {\n\tcase SZ_256:\n\t\trnand->control |= CONTROL_ECC_BLOCK_SIZE_256;\n\t\tbreak;\n\tcase SZ_512:\n\t\trnand->control |= CONTROL_ECC_BLOCK_SIZE_512;\n\t\tbreak;\n\tcase SZ_1K:\n\t\trnand->control |= CONTROL_ECC_BLOCK_SIZE_1024;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(rnandc->dev, \"Unsupported ECC chunk size\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (chip->ecc.strength) {\n\tcase 2:\n\t\tchip->ecc.bytes = 4;\n\t\trnand->ecc_ctrl |= ECC_CTRL_CAP_2B;\n\t\tbreak;\n\tcase 4:\n\t\tchip->ecc.bytes = 7;\n\t\trnand->ecc_ctrl |= ECC_CTRL_CAP_4B;\n\t\tbreak;\n\tcase 8:\n\t\tchip->ecc.bytes = 14;\n\t\trnand->ecc_ctrl |= ECC_CTRL_CAP_8B;\n\t\tbreak;\n\tcase 16:\n\t\tchip->ecc.bytes = 28;\n\t\trnand->ecc_ctrl |= ECC_CTRL_CAP_16B;\n\t\tbreak;\n\tcase 24:\n\t\tchip->ecc.bytes = 42;\n\t\trnand->ecc_ctrl |= ECC_CTRL_CAP_24B;\n\t\tbreak;\n\tcase 32:\n\t\tchip->ecc.bytes = 56;\n\t\trnand->ecc_ctrl |= ECC_CTRL_CAP_32B;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(rnandc->dev, \"Unsupported ECC strength\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\trnand->ecc_ctrl |= ECC_CTRL_ERR_THRESHOLD(chip->ecc.strength);\n\n\tmtd_set_ooblayout(mtd, &rnandc_ooblayout_ops);\n\tchip->ecc.steps = mtd->writesize / chip->ecc.size;\n\tchip->ecc.read_page = rnandc_read_page_hw_ecc;\n\tchip->ecc.read_subpage = rnandc_read_subpage_hw_ecc;\n\tchip->ecc.write_page = rnandc_write_page_hw_ecc;\n\tchip->ecc.write_subpage = rnandc_write_subpage_hw_ecc;\n\n\treturn 0;\n}\n\nstatic int rnandc_ecc_init(struct nand_chip *chip)\n{\n\tstruct nand_ecc_ctrl *ecc = &chip->ecc;\n\tconst struct nand_ecc_props *requirements =\n\t\tnanddev_get_ecc_requirements(&chip->base);\n\tstruct rnandc *rnandc = to_rnandc(chip->controller);\n\tint ret;\n\n\tif (ecc->engine_type != NAND_ECC_ENGINE_TYPE_NONE &&\n\t    (!ecc->size || !ecc->strength)) {\n\t\tif (requirements->step_size && requirements->strength) {\n\t\t\tecc->size = requirements->step_size;\n\t\t\tecc->strength = requirements->strength;\n\t\t} else {\n\t\t\tdev_err(rnandc->dev, \"No minimum ECC strength\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tswitch (ecc->engine_type) {\n\tcase NAND_ECC_ENGINE_TYPE_ON_HOST:\n\t\tret = rnandc_hw_ecc_controller_init(chip);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tbreak;\n\tcase NAND_ECC_ENGINE_TYPE_NONE:\n\tcase NAND_ECC_ENGINE_TYPE_SOFT:\n\tcase NAND_ECC_ENGINE_TYPE_ON_DIE:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int rnandc_attach_chip(struct nand_chip *chip)\n{\n\tstruct rnand_chip *rnand = to_rnand(chip);\n\tstruct rnandc *rnandc = to_rnandc(chip->controller);\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tstruct nand_memory_organization *memorg = nanddev_get_memorg(&chip->base);\n\tint ret;\n\n\t \n\tif (chip->bbt_options & NAND_BBT_USE_FLASH)\n\t\tchip->bbt_options |= NAND_BBT_NO_OOB;\n\n\tif (mtd->writesize <= 512) {\n\t\tdev_err(rnandc->dev, \"Small page devices not supported\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\trnand->control |= CONTROL_CHECK_RB_LINE | CONTROL_INT_EN;\n\n\tswitch (memorg->pages_per_eraseblock) {\n\tcase 32:\n\t\trnand->control |= CONTROL_BLOCK_SIZE_32P;\n\t\tbreak;\n\tcase 64:\n\t\trnand->control |= CONTROL_BLOCK_SIZE_64P;\n\t\tbreak;\n\tcase 128:\n\t\trnand->control |= CONTROL_BLOCK_SIZE_128P;\n\t\tbreak;\n\tcase 256:\n\t\trnand->control |= CONTROL_BLOCK_SIZE_256P;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(rnandc->dev, \"Unsupported memory organization\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tchip->options |= NAND_SUBPAGE_READ;\n\n\tret = rnandc_ecc_init(chip);\n\tif (ret) {\n\t\tdev_err(rnandc->dev, \"ECC initialization failed (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\trnand->selected_die = -1;\n\n\treturn 0;\n}\n\nstatic const struct nand_controller_ops rnandc_ops = {\n\t.attach_chip = rnandc_attach_chip,\n\t.exec_op = rnandc_exec_op,\n\t.setup_interface = rnandc_setup_interface,\n};\n\nstatic int rnandc_alloc_dma_buf(struct rnandc *rnandc,\n\t\t\t\tstruct mtd_info *new_mtd)\n{\n\tunsigned int max_len = new_mtd->writesize + new_mtd->oobsize;\n\tstruct rnand_chip *entry, *temp;\n\tstruct nand_chip *chip;\n\tstruct mtd_info *mtd;\n\n\tlist_for_each_entry_safe(entry, temp, &rnandc->chips, node) {\n\t\tchip = &entry->chip;\n\t\tmtd = nand_to_mtd(chip);\n\t\tmax_len = max(max_len, mtd->writesize + mtd->oobsize);\n\t}\n\n\tif (rnandc->buf && rnandc->buf_sz < max_len) {\n\t\tdevm_kfree(rnandc->dev, rnandc->buf);\n\t\trnandc->buf = NULL;\n\t}\n\n\tif (!rnandc->buf) {\n\t\trnandc->buf_sz = max_len;\n\t\trnandc->buf = devm_kmalloc(rnandc->dev, max_len,\n\t\t\t\t\t   GFP_KERNEL | GFP_DMA);\n\t\tif (!rnandc->buf)\n\t\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\nstatic int rnandc_chip_init(struct rnandc *rnandc, struct device_node *np)\n{\n\tstruct rnand_chip *rnand;\n\tstruct mtd_info *mtd;\n\tstruct nand_chip *chip;\n\tint nsels, ret, i;\n\tu32 cs;\n\n\tnsels = of_property_count_elems_of_size(np, \"reg\", sizeof(u32));\n\tif (nsels <= 0) {\n\t\tret = (nsels < 0) ? nsels : -EINVAL;\n\t\tdev_err(rnandc->dev, \"Invalid reg property (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\trnand = devm_kzalloc(rnandc->dev, struct_size(rnand, sels, nsels),\n\t\t\t     GFP_KERNEL);\n\tif (!rnand)\n\t\treturn -ENOMEM;\n\n\trnand->nsels = nsels;\n\trnand->selected_die = -1;\n\n\tfor (i = 0; i < nsels; i++) {\n\t\tret = of_property_read_u32_index(np, \"reg\", i, &cs);\n\t\tif (ret) {\n\t\t\tdev_err(rnandc->dev, \"Incomplete reg property (%d)\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (cs >= RNANDC_CS_NUM) {\n\t\t\tdev_err(rnandc->dev, \"Invalid reg property (%d)\\n\", cs);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (test_and_set_bit(cs, &rnandc->assigned_cs)) {\n\t\t\tdev_err(rnandc->dev, \"CS %d already assigned\\n\", cs);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\trnand->sels[i].cs = cs;\n\t}\n\n\tchip = &rnand->chip;\n\tchip->controller = &rnandc->controller;\n\tnand_set_flash_node(chip, np);\n\n\tmtd = nand_to_mtd(chip);\n\tmtd->dev.parent = rnandc->dev;\n\tif (!mtd->name) {\n\t\tdev_err(rnandc->dev, \"Missing MTD label\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = nand_scan(chip, rnand->nsels);\n\tif (ret) {\n\t\tdev_err(rnandc->dev, \"Failed to scan the NAND chip (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = rnandc_alloc_dma_buf(rnandc, mtd);\n\tif (ret)\n\t\tgoto cleanup_nand;\n\n\tret = mtd_device_register(mtd, NULL, 0);\n\tif (ret) {\n\t\tdev_err(rnandc->dev, \"Failed to register MTD device (%d)\\n\", ret);\n\t\tgoto cleanup_nand;\n\t}\n\n\tlist_add_tail(&rnand->node, &rnandc->chips);\n\n\treturn 0;\n\ncleanup_nand:\n\tnand_cleanup(chip);\n\n\treturn ret;\n}\n\nstatic void rnandc_chips_cleanup(struct rnandc *rnandc)\n{\n\tstruct rnand_chip *entry, *temp;\n\tstruct nand_chip *chip;\n\tint ret;\n\n\tlist_for_each_entry_safe(entry, temp, &rnandc->chips, node) {\n\t\tchip = &entry->chip;\n\t\tret = mtd_device_unregister(nand_to_mtd(chip));\n\t\tWARN_ON(ret);\n\t\tnand_cleanup(chip);\n\t\tlist_del(&entry->node);\n\t}\n}\n\nstatic int rnandc_chips_init(struct rnandc *rnandc)\n{\n\tstruct device_node *np;\n\tint ret;\n\n\tfor_each_child_of_node(rnandc->dev->of_node, np) {\n\t\tret = rnandc_chip_init(rnandc, np);\n\t\tif (ret) {\n\t\t\tof_node_put(np);\n\t\t\tgoto cleanup_chips;\n\t\t}\n\t}\n\n\treturn 0;\n\ncleanup_chips:\n\trnandc_chips_cleanup(rnandc);\n\n\treturn ret;\n}\n\nstatic int rnandc_probe(struct platform_device *pdev)\n{\n\tstruct rnandc *rnandc;\n\tstruct clk *eclk;\n\tint irq, ret;\n\n\trnandc = devm_kzalloc(&pdev->dev, sizeof(*rnandc), GFP_KERNEL);\n\tif (!rnandc)\n\t\treturn -ENOMEM;\n\n\trnandc->dev = &pdev->dev;\n\tnand_controller_init(&rnandc->controller);\n\trnandc->controller.ops = &rnandc_ops;\n\tINIT_LIST_HEAD(&rnandc->chips);\n\tinit_completion(&rnandc->complete);\n\n\trnandc->regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(rnandc->regs))\n\t\treturn PTR_ERR(rnandc->regs);\n\n\tdevm_pm_runtime_enable(&pdev->dev);\n\tret = pm_runtime_resume_and_get(&pdev->dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\teclk = clk_get(&pdev->dev, \"eclk\");\n\tif (IS_ERR(eclk)) {\n\t\tret = PTR_ERR(eclk);\n\t\tgoto dis_runtime_pm;\n\t}\n\n\trnandc->ext_clk_rate = clk_get_rate(eclk);\n\tclk_put(eclk);\n\n\trnandc_dis_interrupts(rnandc);\n\tirq = platform_get_irq_optional(pdev, 0);\n\tif (irq == -EPROBE_DEFER) {\n\t\tret = irq;\n\t\tgoto dis_runtime_pm;\n\t} else if (irq < 0) {\n\t\tdev_info(&pdev->dev, \"No IRQ found, fallback to polling\\n\");\n\t\trnandc->use_polling = true;\n\t} else {\n\t\tret = devm_request_irq(&pdev->dev, irq, rnandc_irq_handler, 0,\n\t\t\t\t       \"renesas-nand-controller\", rnandc);\n\t\tif (ret < 0)\n\t\t\tgoto dis_runtime_pm;\n\t}\n\n\tret = dma_set_mask(&pdev->dev, DMA_BIT_MASK(32));\n\tif (ret)\n\t\tgoto dis_runtime_pm;\n\n\trnandc_clear_fifo(rnandc);\n\n\tplatform_set_drvdata(pdev, rnandc);\n\n\tret = rnandc_chips_init(rnandc);\n\tif (ret)\n\t\tgoto dis_runtime_pm;\n\n\treturn 0;\n\ndis_runtime_pm:\n\tpm_runtime_put(&pdev->dev);\n\n\treturn ret;\n}\n\nstatic void rnandc_remove(struct platform_device *pdev)\n{\n\tstruct rnandc *rnandc = platform_get_drvdata(pdev);\n\n\trnandc_chips_cleanup(rnandc);\n\n\tpm_runtime_put(&pdev->dev);\n}\n\nstatic const struct of_device_id rnandc_id_table[] = {\n\t{ .compatible = \"renesas,rcar-gen3-nandc\" },\n\t{ .compatible = \"renesas,rzn1-nandc\" },\n\t{}  \n};\nMODULE_DEVICE_TABLE(of, rnandc_id_table);\n\nstatic struct platform_driver rnandc_driver = {\n\t.driver = {\n\t\t.name = \"renesas-nandc\",\n\t\t.of_match_table = rnandc_id_table,\n\t},\n\t.probe = rnandc_probe,\n\t.remove_new = rnandc_remove,\n};\nmodule_platform_driver(rnandc_driver);\n\nMODULE_AUTHOR(\"Miquel Raynal <miquel.raynal@bootlin.com>\");\nMODULE_DESCRIPTION(\"Renesas R-Car Gen3 & RZ/N1 NAND controller driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}