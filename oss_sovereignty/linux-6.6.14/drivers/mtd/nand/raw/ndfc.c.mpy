{
  "module_name": "ndfc.c",
  "hash_id": "de407ada728a41a6128744782ad4eaf3f8eaf4003d9fb53302e9a2dafa530911",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/nand/raw/ndfc.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n#include <linux/mtd/rawnand.h>\n#include <linux/mtd/partitions.h>\n#include <linux/mtd/ndfc.h>\n#include <linux/slab.h>\n#include <linux/mtd/mtd.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/platform_device.h>\n#include <asm/io.h>\n\n#define NDFC_MAX_CS    4\n\nstruct ndfc_controller {\n\tstruct platform_device *ofdev;\n\tvoid __iomem *ndfcbase;\n\tstruct nand_chip chip;\n\tint chip_select;\n\tstruct nand_controller ndfc_control;\n};\n\nstatic struct ndfc_controller ndfc_ctrl[NDFC_MAX_CS];\n\nstatic void ndfc_select_chip(struct nand_chip *nchip, int chip)\n{\n\tuint32_t ccr;\n\tstruct ndfc_controller *ndfc = nand_get_controller_data(nchip);\n\n\tccr = in_be32(ndfc->ndfcbase + NDFC_CCR);\n\tif (chip >= 0) {\n\t\tccr &= ~NDFC_CCR_BS_MASK;\n\t\tccr |= NDFC_CCR_BS(chip + ndfc->chip_select);\n\t} else\n\t\tccr |= NDFC_CCR_RESET_CE;\n\tout_be32(ndfc->ndfcbase + NDFC_CCR, ccr);\n}\n\nstatic void ndfc_hwcontrol(struct nand_chip *chip, int cmd, unsigned int ctrl)\n{\n\tstruct ndfc_controller *ndfc = nand_get_controller_data(chip);\n\n\tif (cmd == NAND_CMD_NONE)\n\t\treturn;\n\n\tif (ctrl & NAND_CLE)\n\t\twritel(cmd & 0xFF, ndfc->ndfcbase + NDFC_CMD);\n\telse\n\t\twritel(cmd & 0xFF, ndfc->ndfcbase + NDFC_ALE);\n}\n\nstatic int ndfc_ready(struct nand_chip *chip)\n{\n\tstruct ndfc_controller *ndfc = nand_get_controller_data(chip);\n\n\treturn in_be32(ndfc->ndfcbase + NDFC_STAT) & NDFC_STAT_IS_READY;\n}\n\nstatic void ndfc_enable_hwecc(struct nand_chip *chip, int mode)\n{\n\tuint32_t ccr;\n\tstruct ndfc_controller *ndfc = nand_get_controller_data(chip);\n\n\tccr = in_be32(ndfc->ndfcbase + NDFC_CCR);\n\tccr |= NDFC_CCR_RESET_ECC;\n\tout_be32(ndfc->ndfcbase + NDFC_CCR, ccr);\n\twmb();\n}\n\nstatic int ndfc_calculate_ecc(struct nand_chip *chip,\n\t\t\t      const u_char *dat, u_char *ecc_code)\n{\n\tstruct ndfc_controller *ndfc = nand_get_controller_data(chip);\n\tuint32_t ecc;\n\tuint8_t *p = (uint8_t *)&ecc;\n\n\twmb();\n\tecc = in_be32(ndfc->ndfcbase + NDFC_ECC);\n\t \n\tecc_code[0] = p[1];\n\tecc_code[1] = p[2];\n\tecc_code[2] = p[3];\n\n\treturn 0;\n}\n\n \nstatic void ndfc_read_buf(struct nand_chip *chip, uint8_t *buf, int len)\n{\n\tstruct ndfc_controller *ndfc = nand_get_controller_data(chip);\n\tuint32_t *p = (uint32_t *) buf;\n\n\tfor(;len > 0; len -= 4)\n\t\t*p++ = in_be32(ndfc->ndfcbase + NDFC_DATA);\n}\n\nstatic void ndfc_write_buf(struct nand_chip *chip, const uint8_t *buf, int len)\n{\n\tstruct ndfc_controller *ndfc = nand_get_controller_data(chip);\n\tuint32_t *p = (uint32_t *) buf;\n\n\tfor(;len > 0; len -= 4)\n\t\tout_be32(ndfc->ndfcbase + NDFC_DATA, *p++);\n}\n\n \nstatic int ndfc_chip_init(struct ndfc_controller *ndfc,\n\t\t\t  struct device_node *node)\n{\n\tstruct device_node *flash_np;\n\tstruct nand_chip *chip = &ndfc->chip;\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tint ret;\n\n\tchip->legacy.IO_ADDR_R = ndfc->ndfcbase + NDFC_DATA;\n\tchip->legacy.IO_ADDR_W = ndfc->ndfcbase + NDFC_DATA;\n\tchip->legacy.cmd_ctrl = ndfc_hwcontrol;\n\tchip->legacy.dev_ready = ndfc_ready;\n\tchip->legacy.select_chip = ndfc_select_chip;\n\tchip->legacy.chip_delay = 50;\n\tchip->controller = &ndfc->ndfc_control;\n\tchip->legacy.read_buf = ndfc_read_buf;\n\tchip->legacy.write_buf = ndfc_write_buf;\n\tchip->ecc.correct = rawnand_sw_hamming_correct;\n\tchip->ecc.hwctl = ndfc_enable_hwecc;\n\tchip->ecc.calculate = ndfc_calculate_ecc;\n\tchip->ecc.engine_type = NAND_ECC_ENGINE_TYPE_ON_HOST;\n\tchip->ecc.size = 256;\n\tchip->ecc.bytes = 3;\n\tchip->ecc.strength = 1;\n\tnand_set_controller_data(chip, ndfc);\n\n\tmtd->dev.parent = &ndfc->ofdev->dev;\n\n\tflash_np = of_get_next_child(node, NULL);\n\tif (!flash_np)\n\t\treturn -ENODEV;\n\tnand_set_flash_node(chip, flash_np);\n\n\tmtd->name = kasprintf(GFP_KERNEL, \"%s.%pOFn\", dev_name(&ndfc->ofdev->dev),\n\t\t\t      flash_np);\n\tif (!mtd->name) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tret = nand_scan(chip, 1);\n\tif (ret)\n\t\tgoto err;\n\n\tret = mtd_device_register(mtd, NULL, 0);\n\nerr:\n\tof_node_put(flash_np);\n\tif (ret)\n\t\tkfree(mtd->name);\n\treturn ret;\n}\n\nstatic int ndfc_probe(struct platform_device *ofdev)\n{\n\tstruct ndfc_controller *ndfc;\n\tconst __be32 *reg;\n\tu32 ccr;\n\tu32 cs;\n\tint err, len;\n\n\t \n\treg = of_get_property(ofdev->dev.of_node, \"reg\", &len);\n\tif (reg == NULL || len != 12) {\n\t\tdev_err(&ofdev->dev, \"unable read reg property (%d)\\n\", len);\n\t\treturn -ENOENT;\n\t}\n\n\tcs = be32_to_cpu(reg[0]);\n\tif (cs >= NDFC_MAX_CS) {\n\t\tdev_err(&ofdev->dev, \"invalid CS number (%d)\\n\", cs);\n\t\treturn -EINVAL;\n\t}\n\n\tndfc = &ndfc_ctrl[cs];\n\tndfc->chip_select = cs;\n\n\tnand_controller_init(&ndfc->ndfc_control);\n\tndfc->ofdev = ofdev;\n\tdev_set_drvdata(&ofdev->dev, ndfc);\n\n\tndfc->ndfcbase = of_iomap(ofdev->dev.of_node, 0);\n\tif (!ndfc->ndfcbase) {\n\t\tdev_err(&ofdev->dev, \"failed to get memory\\n\");\n\t\treturn -EIO;\n\t}\n\n\tccr = NDFC_CCR_BS(ndfc->chip_select);\n\n\t \n\treg = of_get_property(ofdev->dev.of_node, \"ccr\", NULL);\n\tif (reg)\n\t\tccr |= be32_to_cpup(reg);\n\n\tout_be32(ndfc->ndfcbase + NDFC_CCR, ccr);\n\n\t \n\treg = of_get_property(ofdev->dev.of_node, \"bank-settings\", NULL);\n\tif (reg) {\n\t\tint offset = NDFC_BCFG0 + (ndfc->chip_select << 2);\n\t\tout_be32(ndfc->ndfcbase + offset, be32_to_cpup(reg));\n\t}\n\n\terr = ndfc_chip_init(ndfc, ofdev->dev.of_node);\n\tif (err) {\n\t\tiounmap(ndfc->ndfcbase);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic void ndfc_remove(struct platform_device *ofdev)\n{\n\tstruct ndfc_controller *ndfc = dev_get_drvdata(&ofdev->dev);\n\tstruct nand_chip *chip = &ndfc->chip;\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tint ret;\n\n\tret = mtd_device_unregister(mtd);\n\tWARN_ON(ret);\n\tnand_cleanup(chip);\n\tkfree(mtd->name);\n}\n\nstatic const struct of_device_id ndfc_match[] = {\n\t{ .compatible = \"ibm,ndfc\", },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, ndfc_match);\n\nstatic struct platform_driver ndfc_driver = {\n\t.driver = {\n\t\t.name = \"ndfc\",\n\t\t.of_match_table = ndfc_match,\n\t},\n\t.probe = ndfc_probe,\n\t.remove_new = ndfc_remove,\n};\n\nmodule_platform_driver(ndfc_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Thomas Gleixner <tglx@linutronix.de>\");\nMODULE_DESCRIPTION(\"OF Platform driver for NDFC\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}