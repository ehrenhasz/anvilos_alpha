{
  "module_name": "lpc32xx_mlc.c",
  "hash_id": "ce408f2142eaf352afce4be2c3471850b6a8aeaa02ae44c96d1610431a5f9275",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/nand/raw/lpc32xx_mlc.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/mtd/mtd.h>\n#include <linux/mtd/rawnand.h>\n#include <linux/mtd/partitions.h>\n#include <linux/clk.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/completion.h>\n#include <linux/interrupt.h>\n#include <linux/of.h>\n#include <linux/gpio/consumer.h>\n#include <linux/mtd/lpc32xx_mlc.h>\n#include <linux/io.h>\n#include <linux/mm.h>\n#include <linux/dma-mapping.h>\n#include <linux/dmaengine.h>\n\n#define DRV_NAME \"lpc32xx_mlc\"\n\n \n\n#define MLC_BUFF(x)\t\t\t(x + 0x00000)\n#define MLC_DATA(x)\t\t\t(x + 0x08000)\n#define MLC_CMD(x)\t\t\t(x + 0x10000)\n#define MLC_ADDR(x)\t\t\t(x + 0x10004)\n#define MLC_ECC_ENC_REG(x)\t\t(x + 0x10008)\n#define MLC_ECC_DEC_REG(x)\t\t(x + 0x1000C)\n#define MLC_ECC_AUTO_ENC_REG(x)\t\t(x + 0x10010)\n#define MLC_ECC_AUTO_DEC_REG(x)\t\t(x + 0x10014)\n#define MLC_RPR(x)\t\t\t(x + 0x10018)\n#define MLC_WPR(x)\t\t\t(x + 0x1001C)\n#define MLC_RUBP(x)\t\t\t(x + 0x10020)\n#define MLC_ROBP(x)\t\t\t(x + 0x10024)\n#define MLC_SW_WP_ADD_LOW(x)\t\t(x + 0x10028)\n#define MLC_SW_WP_ADD_HIG(x)\t\t(x + 0x1002C)\n#define MLC_ICR(x)\t\t\t(x + 0x10030)\n#define MLC_TIME_REG(x)\t\t\t(x + 0x10034)\n#define MLC_IRQ_MR(x)\t\t\t(x + 0x10038)\n#define MLC_IRQ_SR(x)\t\t\t(x + 0x1003C)\n#define MLC_LOCK_PR(x)\t\t\t(x + 0x10044)\n#define MLC_ISR(x)\t\t\t(x + 0x10048)\n#define MLC_CEH(x)\t\t\t(x + 0x1004C)\n\n \n#define MLCCMD_RESET\t\t\t0xFF\n\n \n#define MLCICR_WPROT\t\t\t(1 << 3)\n#define MLCICR_LARGEBLOCK\t\t(1 << 2)\n#define MLCICR_LONGADDR\t\t\t(1 << 1)\n#define MLCICR_16BIT\t\t\t(1 << 0)   \n\n \n#define MLCTIMEREG_TCEA_DELAY(n)\t(((n) & 0x03) << 24)\n#define MLCTIMEREG_BUSY_DELAY(n)\t(((n) & 0x1F) << 19)\n#define MLCTIMEREG_NAND_TA(n)\t\t(((n) & 0x07) << 16)\n#define MLCTIMEREG_RD_HIGH(n)\t\t(((n) & 0x0F) << 12)\n#define MLCTIMEREG_RD_LOW(n)\t\t(((n) & 0x0F) << 8)\n#define MLCTIMEREG_WR_HIGH(n)\t\t(((n) & 0x0F) << 4)\n#define MLCTIMEREG_WR_LOW(n)\t\t(((n) & 0x0F) << 0)\n\n \n#define MLCIRQ_NAND_READY\t\t(1 << 5)\n#define MLCIRQ_CONTROLLER_READY\t\t(1 << 4)\n#define MLCIRQ_DECODE_FAILURE\t\t(1 << 3)\n#define MLCIRQ_DECODE_ERROR\t\t(1 << 2)\n#define MLCIRQ_ECC_READY\t\t(1 << 1)\n#define MLCIRQ_WRPROT_FAULT\t\t(1 << 0)\n\n \n#define MLCLOCKPR_MAGIC\t\t\t0xA25E\n\n \n#define MLCISR_DECODER_FAILURE\t\t(1 << 6)\n#define MLCISR_ERRORS\t\t\t((1 << 4) | (1 << 5))\n#define MLCISR_ERRORS_DETECTED\t\t(1 << 3)\n#define MLCISR_ECC_READY\t\t(1 << 2)\n#define MLCISR_CONTROLLER_READY\t\t(1 << 1)\n#define MLCISR_NAND_READY\t\t(1 << 0)\n\n \n#define MLCCEH_NORMAL\t\t\t(1 << 0)\n\nstruct lpc32xx_nand_cfg_mlc {\n\tuint32_t tcea_delay;\n\tuint32_t busy_delay;\n\tuint32_t nand_ta;\n\tuint32_t rd_high;\n\tuint32_t rd_low;\n\tuint32_t wr_high;\n\tuint32_t wr_low;\n\tstruct mtd_partition *parts;\n\tunsigned num_parts;\n};\n\nstatic int lpc32xx_ooblayout_ecc(struct mtd_info *mtd, int section,\n\t\t\t\t struct mtd_oob_region *oobregion)\n{\n\tstruct nand_chip *nand_chip = mtd_to_nand(mtd);\n\n\tif (section >= nand_chip->ecc.steps)\n\t\treturn -ERANGE;\n\n\toobregion->offset = ((section + 1) * 16) - nand_chip->ecc.bytes;\n\toobregion->length = nand_chip->ecc.bytes;\n\n\treturn 0;\n}\n\nstatic int lpc32xx_ooblayout_free(struct mtd_info *mtd, int section,\n\t\t\t\t  struct mtd_oob_region *oobregion)\n{\n\tstruct nand_chip *nand_chip = mtd_to_nand(mtd);\n\n\tif (section >= nand_chip->ecc.steps)\n\t\treturn -ERANGE;\n\n\toobregion->offset = 16 * section;\n\toobregion->length = 16 - nand_chip->ecc.bytes;\n\n\treturn 0;\n}\n\nstatic const struct mtd_ooblayout_ops lpc32xx_ooblayout_ops = {\n\t.ecc = lpc32xx_ooblayout_ecc,\n\t.free = lpc32xx_ooblayout_free,\n};\n\nstatic struct nand_bbt_descr lpc32xx_nand_bbt = {\n\t.options = NAND_BBT_ABSPAGE | NAND_BBT_2BIT | NAND_BBT_NO_OOB |\n\t\t   NAND_BBT_WRITE,\n\t.pages = { 524224, 0, 0, 0, 0, 0, 0, 0 },\n};\n\nstatic struct nand_bbt_descr lpc32xx_nand_bbt_mirror = {\n\t.options = NAND_BBT_ABSPAGE | NAND_BBT_2BIT | NAND_BBT_NO_OOB |\n\t\t   NAND_BBT_WRITE,\n\t.pages = { 524160, 0, 0, 0, 0, 0, 0, 0 },\n};\n\nstruct lpc32xx_nand_host {\n\tstruct platform_device\t*pdev;\n\tstruct nand_chip\tnand_chip;\n\tstruct lpc32xx_mlc_platform_data *pdata;\n\tstruct clk\t\t*clk;\n\tstruct gpio_desc\t*wp_gpio;\n\tvoid __iomem\t\t*io_base;\n\tint\t\t\tirq;\n\tstruct lpc32xx_nand_cfg_mlc\t*ncfg;\n\tstruct completion       comp_nand;\n\tstruct completion       comp_controller;\n\tuint32_t llptr;\n\t \n\tdma_addr_t\t\toob_buf_phy;\n\t \n\tuint8_t\t\t\t*oob_buf;\n\t \n\tdma_addr_t\t\tio_base_phy;\n\n\tstruct completion\tcomp_dma;\n\tstruct dma_chan\t\t*dma_chan;\n\tstruct dma_slave_config\tdma_slave_config;\n\tstruct scatterlist\tsgl;\n\tuint8_t\t\t\t*dma_buf;\n\tuint8_t\t\t\t*dummy_buf;\n\tint\t\t\tmlcsubpages;  \n};\n\n \nstatic int use_dma;\n\nstatic void lpc32xx_nand_setup(struct lpc32xx_nand_host *host)\n{\n\tuint32_t clkrate, tmp;\n\n\t \n\twritel(MLCCMD_RESET, MLC_CMD(host->io_base));\n\tudelay(1000);\n\n\t \n\tclkrate = clk_get_rate(host->clk);\n\tif (clkrate == 0)\n\t\tclkrate = 104000000;\n\n\t \n\twritew(MLCLOCKPR_MAGIC, MLC_LOCK_PR(host->io_base));\n\n\t \n\ttmp = MLCICR_LARGEBLOCK | MLCICR_LONGADDR;\n\twritel(tmp, MLC_ICR(host->io_base));\n\n\t \n\twritew(MLCLOCKPR_MAGIC, MLC_LOCK_PR(host->io_base));\n\n\t \n\ttmp = 0;\n\ttmp |= MLCTIMEREG_TCEA_DELAY(clkrate / host->ncfg->tcea_delay + 1);\n\ttmp |= MLCTIMEREG_BUSY_DELAY(clkrate / host->ncfg->busy_delay + 1);\n\ttmp |= MLCTIMEREG_NAND_TA(clkrate / host->ncfg->nand_ta + 1);\n\ttmp |= MLCTIMEREG_RD_HIGH(clkrate / host->ncfg->rd_high + 1);\n\ttmp |= MLCTIMEREG_RD_LOW(clkrate / host->ncfg->rd_low);\n\ttmp |= MLCTIMEREG_WR_HIGH(clkrate / host->ncfg->wr_high + 1);\n\ttmp |= MLCTIMEREG_WR_LOW(clkrate / host->ncfg->wr_low);\n\twritel(tmp, MLC_TIME_REG(host->io_base));\n\n\t \n\twriteb(MLCIRQ_CONTROLLER_READY | MLCIRQ_NAND_READY,\n\t\t\tMLC_IRQ_MR(host->io_base));\n\n\t \n\twritel(MLCCEH_NORMAL, MLC_CEH(host->io_base));\n}\n\n \nstatic void lpc32xx_nand_cmd_ctrl(struct nand_chip *nand_chip, int cmd,\n\t\t\t\t  unsigned int ctrl)\n{\n\tstruct lpc32xx_nand_host *host = nand_get_controller_data(nand_chip);\n\n\tif (cmd != NAND_CMD_NONE) {\n\t\tif (ctrl & NAND_CLE)\n\t\t\twritel(cmd, MLC_CMD(host->io_base));\n\t\telse\n\t\t\twritel(cmd, MLC_ADDR(host->io_base));\n\t}\n}\n\n \nstatic int lpc32xx_nand_device_ready(struct nand_chip *nand_chip)\n{\n\tstruct lpc32xx_nand_host *host = nand_get_controller_data(nand_chip);\n\n\tif ((readb(MLC_ISR(host->io_base)) &\n\t     (MLCISR_CONTROLLER_READY | MLCISR_NAND_READY)) ==\n\t    (MLCISR_CONTROLLER_READY | MLCISR_NAND_READY))\n\t\treturn  1;\n\n\treturn 0;\n}\n\nstatic irqreturn_t lpc3xxx_nand_irq(int irq, struct lpc32xx_nand_host *host)\n{\n\tuint8_t sr;\n\n\t \n\tsr = readb(MLC_IRQ_SR(host->io_base));\n\tif (sr & MLCIRQ_NAND_READY)\n\t\tcomplete(&host->comp_nand);\n\tif (sr & MLCIRQ_CONTROLLER_READY)\n\t\tcomplete(&host->comp_controller);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int lpc32xx_waitfunc_nand(struct nand_chip *chip)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tstruct lpc32xx_nand_host *host = nand_get_controller_data(chip);\n\n\tif (readb(MLC_ISR(host->io_base)) & MLCISR_NAND_READY)\n\t\tgoto exit;\n\n\twait_for_completion(&host->comp_nand);\n\n\twhile (!(readb(MLC_ISR(host->io_base)) & MLCISR_NAND_READY)) {\n\t\t \n\t\tdev_dbg(&mtd->dev, \"Warning: NAND not ready.\\n\");\n\t\tcpu_relax();\n\t}\n\nexit:\n\treturn NAND_STATUS_READY;\n}\n\nstatic int lpc32xx_waitfunc_controller(struct nand_chip *chip)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tstruct lpc32xx_nand_host *host = nand_get_controller_data(chip);\n\n\tif (readb(MLC_ISR(host->io_base)) & MLCISR_CONTROLLER_READY)\n\t\tgoto exit;\n\n\twait_for_completion(&host->comp_controller);\n\n\twhile (!(readb(MLC_ISR(host->io_base)) &\n\t\t MLCISR_CONTROLLER_READY)) {\n\t\tdev_dbg(&mtd->dev, \"Warning: Controller not ready.\\n\");\n\t\tcpu_relax();\n\t}\n\nexit:\n\treturn NAND_STATUS_READY;\n}\n\nstatic int lpc32xx_waitfunc(struct nand_chip *chip)\n{\n\tlpc32xx_waitfunc_nand(chip);\n\tlpc32xx_waitfunc_controller(chip);\n\n\treturn NAND_STATUS_READY;\n}\n\n \nstatic void lpc32xx_wp_enable(struct lpc32xx_nand_host *host)\n{\n\tif (host->wp_gpio)\n\t\tgpiod_set_value_cansleep(host->wp_gpio, 1);\n}\n\n \nstatic void lpc32xx_wp_disable(struct lpc32xx_nand_host *host)\n{\n\tif (host->wp_gpio)\n\t\tgpiod_set_value_cansleep(host->wp_gpio, 0);\n}\n\nstatic void lpc32xx_dma_complete_func(void *completion)\n{\n\tcomplete(completion);\n}\n\nstatic int lpc32xx_xmit_dma(struct mtd_info *mtd, void *mem, int len,\n\t\t\t    enum dma_transfer_direction dir)\n{\n\tstruct nand_chip *chip = mtd_to_nand(mtd);\n\tstruct lpc32xx_nand_host *host = nand_get_controller_data(chip);\n\tstruct dma_async_tx_descriptor *desc;\n\tint flags = DMA_CTRL_ACK | DMA_PREP_INTERRUPT;\n\tint res;\n\n\tsg_init_one(&host->sgl, mem, len);\n\n\tres = dma_map_sg(host->dma_chan->device->dev, &host->sgl, 1,\n\t\t\t DMA_BIDIRECTIONAL);\n\tif (res != 1) {\n\t\tdev_err(mtd->dev.parent, \"Failed to map sg list\\n\");\n\t\treturn -ENXIO;\n\t}\n\tdesc = dmaengine_prep_slave_sg(host->dma_chan, &host->sgl, 1, dir,\n\t\t\t\t       flags);\n\tif (!desc) {\n\t\tdev_err(mtd->dev.parent, \"Failed to prepare slave sg\\n\");\n\t\tgoto out1;\n\t}\n\n\tinit_completion(&host->comp_dma);\n\tdesc->callback = lpc32xx_dma_complete_func;\n\tdesc->callback_param = &host->comp_dma;\n\n\tdmaengine_submit(desc);\n\tdma_async_issue_pending(host->dma_chan);\n\n\twait_for_completion_timeout(&host->comp_dma, msecs_to_jiffies(1000));\n\n\tdma_unmap_sg(host->dma_chan->device->dev, &host->sgl, 1,\n\t\t     DMA_BIDIRECTIONAL);\n\treturn 0;\nout1:\n\tdma_unmap_sg(host->dma_chan->device->dev, &host->sgl, 1,\n\t\t     DMA_BIDIRECTIONAL);\n\treturn -ENXIO;\n}\n\nstatic int lpc32xx_read_page(struct nand_chip *chip, uint8_t *buf,\n\t\t\t     int oob_required, int page)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tstruct lpc32xx_nand_host *host = nand_get_controller_data(chip);\n\tint i, j;\n\tuint8_t *oobbuf = chip->oob_poi;\n\tuint32_t mlc_isr;\n\tint res;\n\tuint8_t *dma_buf;\n\tbool dma_mapped;\n\n\tif ((void *)buf <= high_memory) {\n\t\tdma_buf = buf;\n\t\tdma_mapped = true;\n\t} else {\n\t\tdma_buf = host->dma_buf;\n\t\tdma_mapped = false;\n\t}\n\n\t \n\tnand_read_page_op(chip, page, 0, NULL, 0);\n\n\t \n\tfor (i = 0; i < host->mlcsubpages; i++) {\n\t\t \n\t\twriteb(0x00, MLC_ECC_AUTO_DEC_REG(host->io_base));\n\n\t\t \n\t\tlpc32xx_waitfunc_controller(chip);\n\n\t\t \n\t\tmlc_isr = readl(MLC_ISR(host->io_base));\n\t\tif (mlc_isr & MLCISR_DECODER_FAILURE) {\n\t\t\tmtd->ecc_stats.failed++;\n\t\t\tdev_warn(&mtd->dev, \"%s: DECODER_FAILURE\\n\", __func__);\n\t\t} else if (mlc_isr & MLCISR_ERRORS_DETECTED) {\n\t\t\tmtd->ecc_stats.corrected += ((mlc_isr >> 4) & 0x3) + 1;\n\t\t}\n\n\t\t \n\t\tif (use_dma) {\n\t\t\tres = lpc32xx_xmit_dma(mtd, dma_buf + i * 512, 512,\n\t\t\t\t\t       DMA_DEV_TO_MEM);\n\t\t\tif (res)\n\t\t\t\treturn res;\n\t\t} else {\n\t\t\tfor (j = 0; j < (512 >> 2); j++) {\n\t\t\t\t*((uint32_t *)(buf)) =\n\t\t\t\t\treadl(MLC_BUFF(host->io_base));\n\t\t\t\tbuf += 4;\n\t\t\t}\n\t\t}\n\t\tfor (j = 0; j < (16 >> 2); j++) {\n\t\t\t*((uint32_t *)(oobbuf)) =\n\t\t\t\treadl(MLC_BUFF(host->io_base));\n\t\t\toobbuf += 4;\n\t\t}\n\t}\n\n\tif (use_dma && !dma_mapped)\n\t\tmemcpy(buf, dma_buf, mtd->writesize);\n\n\treturn 0;\n}\n\nstatic int lpc32xx_write_page_lowlevel(struct nand_chip *chip,\n\t\t\t\t       const uint8_t *buf, int oob_required,\n\t\t\t\t       int page)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tstruct lpc32xx_nand_host *host = nand_get_controller_data(chip);\n\tconst uint8_t *oobbuf = chip->oob_poi;\n\tuint8_t *dma_buf = (uint8_t *)buf;\n\tint res;\n\tint i, j;\n\n\tif (use_dma && (void *)buf >= high_memory) {\n\t\tdma_buf = host->dma_buf;\n\t\tmemcpy(dma_buf, buf, mtd->writesize);\n\t}\n\n\tnand_prog_page_begin_op(chip, page, 0, NULL, 0);\n\n\tfor (i = 0; i < host->mlcsubpages; i++) {\n\t\t \n\t\twriteb(0x00, MLC_ECC_ENC_REG(host->io_base));\n\n\t\t \n\t\tif (use_dma) {\n\t\t\tres = lpc32xx_xmit_dma(mtd, dma_buf + i * 512, 512,\n\t\t\t\t\t       DMA_MEM_TO_DEV);\n\t\t\tif (res)\n\t\t\t\treturn res;\n\t\t} else {\n\t\t\tfor (j = 0; j < (512 >> 2); j++) {\n\t\t\t\twritel(*((uint32_t *)(buf)),\n\t\t\t\t       MLC_BUFF(host->io_base));\n\t\t\t\tbuf += 4;\n\t\t\t}\n\t\t}\n\t\twritel(*((uint32_t *)(oobbuf)), MLC_BUFF(host->io_base));\n\t\toobbuf += 4;\n\t\twritew(*((uint16_t *)(oobbuf)), MLC_BUFF(host->io_base));\n\t\toobbuf += 12;\n\n\t\t \n\t\twriteb(0x00, MLC_ECC_AUTO_ENC_REG(host->io_base));\n\n\t\t \n\t\tlpc32xx_waitfunc_controller(chip);\n\t}\n\n\treturn nand_prog_page_end_op(chip);\n}\n\nstatic int lpc32xx_read_oob(struct nand_chip *chip, int page)\n{\n\tstruct lpc32xx_nand_host *host = nand_get_controller_data(chip);\n\n\t \n\tlpc32xx_read_page(chip, host->dummy_buf, 1, page);\n\n\treturn 0;\n}\n\nstatic int lpc32xx_write_oob(struct nand_chip *chip, int page)\n{\n\t \n\treturn 0;\n}\n\n \nstatic void lpc32xx_ecc_enable(struct nand_chip *chip, int mode)\n{\n\t \n}\n\nstatic int lpc32xx_dma_setup(struct lpc32xx_nand_host *host)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(&host->nand_chip);\n\tdma_cap_mask_t mask;\n\n\tif (!host->pdata || !host->pdata->dma_filter) {\n\t\tdev_err(mtd->dev.parent, \"no DMA platform data\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\tdma_cap_zero(mask);\n\tdma_cap_set(DMA_SLAVE, mask);\n\thost->dma_chan = dma_request_channel(mask, host->pdata->dma_filter,\n\t\t\t\t\t     \"nand-mlc\");\n\tif (!host->dma_chan) {\n\t\tdev_err(mtd->dev.parent, \"Failed to request DMA channel\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\t \n\thost->dma_slave_config.direction = DMA_DEV_TO_MEM;\n\thost->dma_slave_config.src_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;\n\thost->dma_slave_config.dst_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;\n\thost->dma_slave_config.src_maxburst = 128;\n\thost->dma_slave_config.dst_maxburst = 128;\n\t \n\thost->dma_slave_config.device_fc = false;\n\thost->dma_slave_config.src_addr = MLC_BUFF(host->io_base_phy);\n\thost->dma_slave_config.dst_addr = MLC_BUFF(host->io_base_phy);\n\tif (dmaengine_slave_config(host->dma_chan, &host->dma_slave_config)) {\n\t\tdev_err(mtd->dev.parent, \"Failed to setup DMA slave\\n\");\n\t\tgoto out1;\n\t}\n\n\treturn 0;\nout1:\n\tdma_release_channel(host->dma_chan);\n\treturn -ENXIO;\n}\n\nstatic struct lpc32xx_nand_cfg_mlc *lpc32xx_parse_dt(struct device *dev)\n{\n\tstruct lpc32xx_nand_cfg_mlc *ncfg;\n\tstruct device_node *np = dev->of_node;\n\n\tncfg = devm_kzalloc(dev, sizeof(*ncfg), GFP_KERNEL);\n\tif (!ncfg)\n\t\treturn NULL;\n\n\tof_property_read_u32(np, \"nxp,tcea-delay\", &ncfg->tcea_delay);\n\tof_property_read_u32(np, \"nxp,busy-delay\", &ncfg->busy_delay);\n\tof_property_read_u32(np, \"nxp,nand-ta\", &ncfg->nand_ta);\n\tof_property_read_u32(np, \"nxp,rd-high\", &ncfg->rd_high);\n\tof_property_read_u32(np, \"nxp,rd-low\", &ncfg->rd_low);\n\tof_property_read_u32(np, \"nxp,wr-high\", &ncfg->wr_high);\n\tof_property_read_u32(np, \"nxp,wr-low\", &ncfg->wr_low);\n\n\tif (!ncfg->tcea_delay || !ncfg->busy_delay || !ncfg->nand_ta ||\n\t    !ncfg->rd_high || !ncfg->rd_low || !ncfg->wr_high ||\n\t    !ncfg->wr_low) {\n\t\tdev_err(dev, \"chip parameters not specified correctly\\n\");\n\t\treturn NULL;\n\t}\n\n\treturn ncfg;\n}\n\nstatic int lpc32xx_nand_attach_chip(struct nand_chip *chip)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tstruct lpc32xx_nand_host *host = nand_get_controller_data(chip);\n\tstruct device *dev = &host->pdev->dev;\n\n\tif (chip->ecc.engine_type != NAND_ECC_ENGINE_TYPE_ON_HOST)\n\t\treturn 0;\n\n\thost->dma_buf = devm_kzalloc(dev, mtd->writesize, GFP_KERNEL);\n\tif (!host->dma_buf)\n\t\treturn -ENOMEM;\n\n\thost->dummy_buf = devm_kzalloc(dev, mtd->writesize, GFP_KERNEL);\n\tif (!host->dummy_buf)\n\t\treturn -ENOMEM;\n\n\tchip->ecc.size = 512;\n\tchip->ecc.hwctl = lpc32xx_ecc_enable;\n\tchip->ecc.read_page_raw = lpc32xx_read_page;\n\tchip->ecc.read_page = lpc32xx_read_page;\n\tchip->ecc.write_page_raw = lpc32xx_write_page_lowlevel;\n\tchip->ecc.write_page = lpc32xx_write_page_lowlevel;\n\tchip->ecc.write_oob = lpc32xx_write_oob;\n\tchip->ecc.read_oob = lpc32xx_read_oob;\n\tchip->ecc.strength = 4;\n\tchip->ecc.bytes = 10;\n\n\tmtd_set_ooblayout(mtd, &lpc32xx_ooblayout_ops);\n\thost->mlcsubpages = mtd->writesize / 512;\n\n\treturn 0;\n}\n\nstatic const struct nand_controller_ops lpc32xx_nand_controller_ops = {\n\t.attach_chip = lpc32xx_nand_attach_chip,\n};\n\n \nstatic int lpc32xx_nand_probe(struct platform_device *pdev)\n{\n\tstruct lpc32xx_nand_host *host;\n\tstruct mtd_info *mtd;\n\tstruct nand_chip *nand_chip;\n\tstruct resource *rc;\n\tint res;\n\n\t \n\thost = devm_kzalloc(&pdev->dev, sizeof(*host), GFP_KERNEL);\n\tif (!host)\n\t\treturn -ENOMEM;\n\n\thost->pdev = pdev;\n\n\thost->io_base = devm_platform_get_and_ioremap_resource(pdev, 0, &rc);\n\tif (IS_ERR(host->io_base))\n\t\treturn PTR_ERR(host->io_base);\n\n\thost->io_base_phy = rc->start;\n\n\tnand_chip = &host->nand_chip;\n\tmtd = nand_to_mtd(nand_chip);\n\tif (pdev->dev.of_node)\n\t\thost->ncfg = lpc32xx_parse_dt(&pdev->dev);\n\tif (!host->ncfg) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Missing or bad NAND config from device tree\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\t \n\thost->wp_gpio = gpiod_get_optional(&pdev->dev, NULL, GPIOD_OUT_LOW);\n\tres = PTR_ERR_OR_ZERO(host->wp_gpio);\n\tif (res) {\n\t\tif (res != -EPROBE_DEFER)\n\t\t\tdev_err(&pdev->dev, \"WP GPIO is not available: %d\\n\",\n\t\t\t\tres);\n\t\treturn res;\n\t}\n\n\tgpiod_set_consumer_name(host->wp_gpio, \"NAND WP\");\n\n\thost->pdata = dev_get_platdata(&pdev->dev);\n\n\t \n\tnand_set_controller_data(nand_chip, host);\n\tnand_set_flash_node(nand_chip, pdev->dev.of_node);\n\tmtd->dev.parent = &pdev->dev;\n\n\t \n\thost->clk = clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(host->clk)) {\n\t\tdev_err(&pdev->dev, \"Clock initialization failure\\n\");\n\t\tres = -ENOENT;\n\t\tgoto free_gpio;\n\t}\n\tres = clk_prepare_enable(host->clk);\n\tif (res)\n\t\tgoto put_clk;\n\n\tnand_chip->legacy.cmd_ctrl = lpc32xx_nand_cmd_ctrl;\n\tnand_chip->legacy.dev_ready = lpc32xx_nand_device_ready;\n\tnand_chip->legacy.chip_delay = 25;  \n\tnand_chip->legacy.IO_ADDR_R = MLC_DATA(host->io_base);\n\tnand_chip->legacy.IO_ADDR_W = MLC_DATA(host->io_base);\n\n\t \n\tlpc32xx_nand_setup(host);\n\n\tplatform_set_drvdata(pdev, host);\n\n\t \n\tnand_chip->legacy.waitfunc = lpc32xx_waitfunc;\n\n\tnand_chip->options = NAND_NO_SUBPAGE_WRITE;\n\tnand_chip->bbt_options = NAND_BBT_USE_FLASH | NAND_BBT_NO_OOB;\n\tnand_chip->bbt_td = &lpc32xx_nand_bbt;\n\tnand_chip->bbt_md = &lpc32xx_nand_bbt_mirror;\n\n\tif (use_dma) {\n\t\tres = lpc32xx_dma_setup(host);\n\t\tif (res) {\n\t\t\tres = -EIO;\n\t\t\tgoto unprepare_clk;\n\t\t}\n\t}\n\n\t \n\treadb(MLC_IRQ_SR(host->io_base));\n\n\tinit_completion(&host->comp_nand);\n\tinit_completion(&host->comp_controller);\n\n\thost->irq = platform_get_irq(pdev, 0);\n\tif (host->irq < 0) {\n\t\tres = -EINVAL;\n\t\tgoto release_dma_chan;\n\t}\n\n\tif (request_irq(host->irq, (irq_handler_t)&lpc3xxx_nand_irq,\n\t\t\tIRQF_TRIGGER_HIGH, DRV_NAME, host)) {\n\t\tdev_err(&pdev->dev, \"Error requesting NAND IRQ\\n\");\n\t\tres = -ENXIO;\n\t\tgoto release_dma_chan;\n\t}\n\n\t \n\tnand_chip->legacy.dummy_controller.ops = &lpc32xx_nand_controller_ops;\n\tres = nand_scan(nand_chip, 1);\n\tif (res)\n\t\tgoto free_irq;\n\n\tmtd->name = DRV_NAME;\n\n\tres = mtd_device_register(mtd, host->ncfg->parts,\n\t\t\t\t  host->ncfg->num_parts);\n\tif (res)\n\t\tgoto cleanup_nand;\n\n\treturn 0;\n\ncleanup_nand:\n\tnand_cleanup(nand_chip);\nfree_irq:\n\tfree_irq(host->irq, host);\nrelease_dma_chan:\n\tif (use_dma)\n\t\tdma_release_channel(host->dma_chan);\nunprepare_clk:\n\tclk_disable_unprepare(host->clk);\nput_clk:\n\tclk_put(host->clk);\nfree_gpio:\n\tlpc32xx_wp_enable(host);\n\tgpiod_put(host->wp_gpio);\n\n\treturn res;\n}\n\n \nstatic void lpc32xx_nand_remove(struct platform_device *pdev)\n{\n\tstruct lpc32xx_nand_host *host = platform_get_drvdata(pdev);\n\tstruct nand_chip *chip = &host->nand_chip;\n\tint ret;\n\n\tret = mtd_device_unregister(nand_to_mtd(chip));\n\tWARN_ON(ret);\n\tnand_cleanup(chip);\n\n\tfree_irq(host->irq, host);\n\tif (use_dma)\n\t\tdma_release_channel(host->dma_chan);\n\n\tclk_disable_unprepare(host->clk);\n\tclk_put(host->clk);\n\n\tlpc32xx_wp_enable(host);\n\tgpiod_put(host->wp_gpio);\n}\n\nstatic int lpc32xx_nand_resume(struct platform_device *pdev)\n{\n\tstruct lpc32xx_nand_host *host = platform_get_drvdata(pdev);\n\tint ret;\n\n\t \n\tret = clk_prepare_enable(host->clk);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tlpc32xx_nand_setup(host);\n\n\t \n\tlpc32xx_wp_disable(host);\n\n\treturn 0;\n}\n\nstatic int lpc32xx_nand_suspend(struct platform_device *pdev, pm_message_t pm)\n{\n\tstruct lpc32xx_nand_host *host = platform_get_drvdata(pdev);\n\n\t \n\tlpc32xx_wp_enable(host);\n\n\t \n\tclk_disable_unprepare(host->clk);\n\treturn 0;\n}\n\nstatic const struct of_device_id lpc32xx_nand_match[] = {\n\t{ .compatible = \"nxp,lpc3220-mlc\" },\n\t{   },\n};\nMODULE_DEVICE_TABLE(of, lpc32xx_nand_match);\n\nstatic struct platform_driver lpc32xx_nand_driver = {\n\t.probe\t\t= lpc32xx_nand_probe,\n\t.remove_new\t= lpc32xx_nand_remove,\n\t.resume\t\t= pm_ptr(lpc32xx_nand_resume),\n\t.suspend\t= pm_ptr(lpc32xx_nand_suspend),\n\t.driver\t\t= {\n\t\t.name\t= DRV_NAME,\n\t\t.of_match_table = lpc32xx_nand_match,\n\t},\n};\n\nmodule_platform_driver(lpc32xx_nand_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Roland Stigge <stigge@antcom.de>\");\nMODULE_DESCRIPTION(\"NAND driver for the NXP LPC32XX MLC controller\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}