{
  "module_name": "omap_elm.c",
  "hash_id": "123ad39cba76773dd4dd8a48aedd1076f7e2425e1a37693fd2e8814b9357bcdf",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/nand/raw/omap_elm.c",
  "human_readable_source": "\n \n\n#define DRIVER_NAME\t\"omap-elm\"\n\n#include <linux/platform_device.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/of.h>\n#include <linux/sched.h>\n#include <linux/pm_runtime.h>\n#include <linux/platform_data/elm.h>\n\n#define ELM_SYSCONFIG\t\t\t0x010\n#define ELM_IRQSTATUS\t\t\t0x018\n#define ELM_IRQENABLE\t\t\t0x01c\n#define ELM_LOCATION_CONFIG\t\t0x020\n#define ELM_PAGE_CTRL\t\t\t0x080\n#define ELM_SYNDROME_FRAGMENT_0\t\t0x400\n#define ELM_SYNDROME_FRAGMENT_1\t\t0x404\n#define ELM_SYNDROME_FRAGMENT_2\t\t0x408\n#define ELM_SYNDROME_FRAGMENT_3\t\t0x40c\n#define ELM_SYNDROME_FRAGMENT_4\t\t0x410\n#define ELM_SYNDROME_FRAGMENT_5\t\t0x414\n#define ELM_SYNDROME_FRAGMENT_6\t\t0x418\n#define ELM_LOCATION_STATUS\t\t0x800\n#define ELM_ERROR_LOCATION_0\t\t0x880\n\n \n#define INTR_STATUS_PAGE_VALID\t\tBIT(8)\n\n \n#define INTR_EN_PAGE_MASK\t\tBIT(8)\n\n \n#define ECC_BCH_LEVEL_MASK\t\t0x3\n\n \n#define ELM_SYNDROME_VALID\t\tBIT(16)\n\n \n#define ECC_CORRECTABLE_MASK\t\tBIT(8)\n#define ECC_NB_ERRORS_MASK\t\t0x1f\n\n \n#define ECC_ERROR_LOCATION_MASK\t\t0x1fff\n\n#define ELM_ECC_SIZE\t\t\t0x7ff\n\n#define SYNDROME_FRAGMENT_REG_SIZE\t0x40\n#define ERROR_LOCATION_SIZE\t\t0x100\n\nstruct elm_registers {\n\tu32 elm_irqenable;\n\tu32 elm_sysconfig;\n\tu32 elm_location_config;\n\tu32 elm_page_ctrl;\n\tu32 elm_syndrome_fragment_6[ERROR_VECTOR_MAX];\n\tu32 elm_syndrome_fragment_5[ERROR_VECTOR_MAX];\n\tu32 elm_syndrome_fragment_4[ERROR_VECTOR_MAX];\n\tu32 elm_syndrome_fragment_3[ERROR_VECTOR_MAX];\n\tu32 elm_syndrome_fragment_2[ERROR_VECTOR_MAX];\n\tu32 elm_syndrome_fragment_1[ERROR_VECTOR_MAX];\n\tu32 elm_syndrome_fragment_0[ERROR_VECTOR_MAX];\n};\n\nstruct elm_info {\n\tstruct device *dev;\n\tvoid __iomem *elm_base;\n\tstruct completion elm_completion;\n\tstruct list_head list;\n\tenum bch_ecc bch_type;\n\tstruct elm_registers elm_regs;\n\tint ecc_steps;\n\tint ecc_syndrome_size;\n};\n\nstatic LIST_HEAD(elm_devices);\n\nstatic void elm_write_reg(struct elm_info *info, int offset, u32 val)\n{\n\twritel(val, info->elm_base + offset);\n}\n\nstatic u32 elm_read_reg(struct elm_info *info, int offset)\n{\n\treturn readl(info->elm_base + offset);\n}\n\n \nint elm_config(struct device *dev, enum bch_ecc bch_type,\n\tint ecc_steps, int ecc_step_size, int ecc_syndrome_size)\n{\n\tu32 reg_val;\n\tstruct elm_info *info = dev_get_drvdata(dev);\n\n\tif (!info) {\n\t\tdev_err(dev, \"Unable to configure elm - device not probed?\\n\");\n\t\treturn -EPROBE_DEFER;\n\t}\n\t \n\tif (ecc_step_size > ((ELM_ECC_SIZE + 1) / 2)) {\n\t\tdev_err(dev, \"unsupported config ecc-size=%d\\n\", ecc_step_size);\n\t\treturn -EINVAL;\n\t}\n\t \n\tif (ecc_steps > ERROR_VECTOR_MAX && ecc_steps % ERROR_VECTOR_MAX) {\n\t\tdev_err(dev, \"unsupported config ecc-step=%d\\n\", ecc_steps);\n\t\treturn -EINVAL;\n\t}\n\n\treg_val = (bch_type & ECC_BCH_LEVEL_MASK) | (ELM_ECC_SIZE << 16);\n\telm_write_reg(info, ELM_LOCATION_CONFIG, reg_val);\n\tinfo->bch_type\t\t= bch_type;\n\tinfo->ecc_steps\t\t= ecc_steps;\n\tinfo->ecc_syndrome_size\t= ecc_syndrome_size;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(elm_config);\n\n \nstatic void elm_configure_page_mode(struct elm_info *info, int index,\n\t\tbool enable)\n{\n\tu32 reg_val;\n\n\treg_val = elm_read_reg(info, ELM_PAGE_CTRL);\n\tif (enable)\n\t\treg_val |= BIT(index);\t \n\telse\n\t\treg_val &= ~BIT(index);\t \n\n\telm_write_reg(info, ELM_PAGE_CTRL, reg_val);\n}\n\n \nstatic void elm_load_syndrome(struct elm_info *info,\n\t\tstruct elm_errorvec *err_vec, u8 *ecc)\n{\n\tint i, offset;\n\tu32 val;\n\n\tfor (i = 0; i < info->ecc_steps; i++) {\n\n\t\t \n\t\tif (err_vec[i].error_reported) {\n\t\t\telm_configure_page_mode(info, i, true);\n\t\t\toffset = ELM_SYNDROME_FRAGMENT_0 +\n\t\t\t\tSYNDROME_FRAGMENT_REG_SIZE * i;\n\t\t\tswitch (info->bch_type) {\n\t\t\tcase BCH8_ECC:\n\t\t\t\t \n\t\t\t\tval = (__force u32)cpu_to_be32(*(u32 *)&ecc[9]);\n\t\t\t\telm_write_reg(info, offset, val);\n\n\t\t\t\t \n\t\t\t\toffset += 4;\n\t\t\t\tval = (__force u32)cpu_to_be32(*(u32 *)&ecc[5]);\n\t\t\t\telm_write_reg(info, offset, val);\n\n\t\t\t\t \n\t\t\t\toffset += 4;\n\t\t\t\tval = (__force u32)cpu_to_be32(*(u32 *)&ecc[1]);\n\t\t\t\telm_write_reg(info, offset, val);\n\n\t\t\t\t \n\t\t\t\toffset += 4;\n\t\t\t\tval = ecc[0];\n\t\t\t\telm_write_reg(info, offset, val);\n\t\t\t\tbreak;\n\t\t\tcase BCH4_ECC:\n\t\t\t\t \n\t\t\t\tval = ((__force u32)cpu_to_be32(*(u32 *)&ecc[3]) >> 4) |\n\t\t\t\t\t((ecc[2] & 0xf) << 28);\n\t\t\t\telm_write_reg(info, offset, val);\n\n\t\t\t\t \n\t\t\t\toffset += 4;\n\t\t\t\tval = (__force u32)cpu_to_be32(*(u32 *)&ecc[0]) >> 12;\n\t\t\t\telm_write_reg(info, offset, val);\n\t\t\t\tbreak;\n\t\t\tcase BCH16_ECC:\n\t\t\t\tval = (__force u32)cpu_to_be32(*(u32 *)&ecc[22]);\n\t\t\t\telm_write_reg(info, offset, val);\n\t\t\t\toffset += 4;\n\t\t\t\tval = (__force u32)cpu_to_be32(*(u32 *)&ecc[18]);\n\t\t\t\telm_write_reg(info, offset, val);\n\t\t\t\toffset += 4;\n\t\t\t\tval = (__force u32)cpu_to_be32(*(u32 *)&ecc[14]);\n\t\t\t\telm_write_reg(info, offset, val);\n\t\t\t\toffset += 4;\n\t\t\t\tval = (__force u32)cpu_to_be32(*(u32 *)&ecc[10]);\n\t\t\t\telm_write_reg(info, offset, val);\n\t\t\t\toffset += 4;\n\t\t\t\tval = (__force u32)cpu_to_be32(*(u32 *)&ecc[6]);\n\t\t\t\telm_write_reg(info, offset, val);\n\t\t\t\toffset += 4;\n\t\t\t\tval = (__force u32)cpu_to_be32(*(u32 *)&ecc[2]);\n\t\t\t\telm_write_reg(info, offset, val);\n\t\t\t\toffset += 4;\n\t\t\t\tval = (__force u32)cpu_to_be32(*(u32 *)&ecc[0]) >> 16;\n\t\t\t\telm_write_reg(info, offset, val);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tpr_err(\"invalid config bch_type\\n\");\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tecc += info->ecc_syndrome_size;\n\t}\n}\n\n \nstatic void elm_start_processing(struct elm_info *info,\n\t\tstruct elm_errorvec *err_vec)\n{\n\tint i, offset;\n\tu32 reg_val;\n\n\t \n\tfor (i = 0; i < info->ecc_steps; i++) {\n\t\tif (err_vec[i].error_reported) {\n\t\t\toffset = ELM_SYNDROME_FRAGMENT_6 +\n\t\t\t\tSYNDROME_FRAGMENT_REG_SIZE * i;\n\t\t\treg_val = elm_read_reg(info, offset);\n\t\t\treg_val |= ELM_SYNDROME_VALID;\n\t\t\telm_write_reg(info, offset, reg_val);\n\t\t}\n\t}\n}\n\n \nstatic void elm_error_correction(struct elm_info *info,\n\t\tstruct elm_errorvec *err_vec)\n{\n\tint i, j;\n\tint offset;\n\tu32 reg_val;\n\n\tfor (i = 0; i < info->ecc_steps; i++) {\n\n\t\t \n\t\tif (err_vec[i].error_reported) {\n\t\t\toffset = ELM_LOCATION_STATUS + ERROR_LOCATION_SIZE * i;\n\t\t\treg_val = elm_read_reg(info, offset);\n\n\t\t\t \n\t\t\tif (reg_val & ECC_CORRECTABLE_MASK) {\n\t\t\t\toffset = ELM_ERROR_LOCATION_0 +\n\t\t\t\t\tERROR_LOCATION_SIZE * i;\n\n\t\t\t\t \n\t\t\t\terr_vec[i].error_count = reg_val &\n\t\t\t\t\tECC_NB_ERRORS_MASK;\n\n\t\t\t\t \n\t\t\t\tfor (j = 0; j < err_vec[i].error_count; j++) {\n\n\t\t\t\t\treg_val = elm_read_reg(info, offset);\n\t\t\t\t\terr_vec[i].error_loc[j] = reg_val &\n\t\t\t\t\t\tECC_ERROR_LOCATION_MASK;\n\n\t\t\t\t\t \n\t\t\t\t\toffset += 4;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\terr_vec[i].error_uncorrectable = true;\n\t\t\t}\n\n\t\t\t \n\t\t\telm_write_reg(info, ELM_IRQSTATUS, BIT(i));\n\n\t\t\t \n\t\t\telm_configure_page_mode(info, i, false);\n\t\t}\n\t}\n}\n\n \nvoid elm_decode_bch_error_page(struct device *dev, u8 *ecc_calc,\n\t\tstruct elm_errorvec *err_vec)\n{\n\tstruct elm_info *info = dev_get_drvdata(dev);\n\tu32 reg_val;\n\n\t \n\treg_val = elm_read_reg(info, ELM_IRQSTATUS);\n\telm_write_reg(info, ELM_IRQSTATUS, reg_val & INTR_STATUS_PAGE_VALID);\n\telm_write_reg(info, ELM_IRQENABLE, INTR_EN_PAGE_MASK);\n\n\t \n\telm_load_syndrome(info, err_vec, ecc_calc);\n\n\t \n\telm_start_processing(info, err_vec);\n\n\t \n\twait_for_completion(&info->elm_completion);\n\n\t \n\treg_val = elm_read_reg(info, ELM_IRQENABLE);\n\telm_write_reg(info, ELM_IRQENABLE, reg_val & ~INTR_EN_PAGE_MASK);\n\telm_error_correction(info, err_vec);\n}\nEXPORT_SYMBOL(elm_decode_bch_error_page);\n\nstatic irqreturn_t elm_isr(int this_irq, void *dev_id)\n{\n\tu32 reg_val;\n\tstruct elm_info *info = dev_id;\n\n\treg_val = elm_read_reg(info, ELM_IRQSTATUS);\n\n\t \n\tif (reg_val & INTR_STATUS_PAGE_VALID) {\n\t\telm_write_reg(info, ELM_IRQSTATUS,\n\t\t\t\treg_val & INTR_STATUS_PAGE_VALID);\n\t\tcomplete(&info->elm_completion);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\treturn IRQ_NONE;\n}\n\nstatic int elm_probe(struct platform_device *pdev)\n{\n\tint ret = 0;\n\tstruct elm_info *info;\n\tint irq;\n\n\tinfo = devm_kzalloc(&pdev->dev, sizeof(*info), GFP_KERNEL);\n\tif (!info)\n\t\treturn -ENOMEM;\n\n\tinfo->dev = &pdev->dev;\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tinfo->elm_base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(info->elm_base))\n\t\treturn PTR_ERR(info->elm_base);\n\n\tret = devm_request_irq(&pdev->dev, irq, elm_isr, 0,\n\t\t\t       pdev->name, info);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failure requesting %d\\n\", irq);\n\t\treturn ret;\n\t}\n\n\tpm_runtime_enable(&pdev->dev);\n\tif (pm_runtime_get_sync(&pdev->dev) < 0) {\n\t\tret = -EINVAL;\n\t\tpm_runtime_put_sync(&pdev->dev);\n\t\tpm_runtime_disable(&pdev->dev);\n\t\tdev_err(&pdev->dev, \"can't enable clock\\n\");\n\t\treturn ret;\n\t}\n\n\tinit_completion(&info->elm_completion);\n\tINIT_LIST_HEAD(&info->list);\n\tlist_add(&info->list, &elm_devices);\n\tplatform_set_drvdata(pdev, info);\n\treturn ret;\n}\n\nstatic void elm_remove(struct platform_device *pdev)\n{\n\tpm_runtime_put_sync(&pdev->dev);\n\tpm_runtime_disable(&pdev->dev);\n}\n\n#ifdef CONFIG_PM_SLEEP\n \nstatic int elm_context_save(struct elm_info *info)\n{\n\tstruct elm_registers *regs = &info->elm_regs;\n\tenum bch_ecc bch_type = info->bch_type;\n\tu32 offset = 0, i;\n\n\tregs->elm_irqenable       = elm_read_reg(info, ELM_IRQENABLE);\n\tregs->elm_sysconfig       = elm_read_reg(info, ELM_SYSCONFIG);\n\tregs->elm_location_config = elm_read_reg(info, ELM_LOCATION_CONFIG);\n\tregs->elm_page_ctrl       = elm_read_reg(info, ELM_PAGE_CTRL);\n\tfor (i = 0; i < ERROR_VECTOR_MAX; i++) {\n\t\toffset = i * SYNDROME_FRAGMENT_REG_SIZE;\n\t\tswitch (bch_type) {\n\t\tcase BCH16_ECC:\n\t\t\tregs->elm_syndrome_fragment_6[i] = elm_read_reg(info,\n\t\t\t\t\tELM_SYNDROME_FRAGMENT_6 + offset);\n\t\t\tregs->elm_syndrome_fragment_5[i] = elm_read_reg(info,\n\t\t\t\t\tELM_SYNDROME_FRAGMENT_5 + offset);\n\t\t\tregs->elm_syndrome_fragment_4[i] = elm_read_reg(info,\n\t\t\t\t\tELM_SYNDROME_FRAGMENT_4 + offset);\n\t\t\tfallthrough;\n\t\tcase BCH8_ECC:\n\t\t\tregs->elm_syndrome_fragment_3[i] = elm_read_reg(info,\n\t\t\t\t\tELM_SYNDROME_FRAGMENT_3 + offset);\n\t\t\tregs->elm_syndrome_fragment_2[i] = elm_read_reg(info,\n\t\t\t\t\tELM_SYNDROME_FRAGMENT_2 + offset);\n\t\t\tfallthrough;\n\t\tcase BCH4_ECC:\n\t\t\tregs->elm_syndrome_fragment_1[i] = elm_read_reg(info,\n\t\t\t\t\tELM_SYNDROME_FRAGMENT_1 + offset);\n\t\t\tregs->elm_syndrome_fragment_0[i] = elm_read_reg(info,\n\t\t\t\t\tELM_SYNDROME_FRAGMENT_0 + offset);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t \n\t\tregs->elm_syndrome_fragment_6[i] = elm_read_reg(info,\n\t\t\t\t\tELM_SYNDROME_FRAGMENT_6 + offset);\n\t}\n\treturn 0;\n}\n\n \nstatic int elm_context_restore(struct elm_info *info)\n{\n\tstruct elm_registers *regs = &info->elm_regs;\n\tenum bch_ecc bch_type = info->bch_type;\n\tu32 offset = 0, i;\n\n\telm_write_reg(info, ELM_IRQENABLE,\t regs->elm_irqenable);\n\telm_write_reg(info, ELM_SYSCONFIG,\t regs->elm_sysconfig);\n\telm_write_reg(info, ELM_LOCATION_CONFIG, regs->elm_location_config);\n\telm_write_reg(info, ELM_PAGE_CTRL,\t regs->elm_page_ctrl);\n\tfor (i = 0; i < ERROR_VECTOR_MAX; i++) {\n\t\toffset = i * SYNDROME_FRAGMENT_REG_SIZE;\n\t\tswitch (bch_type) {\n\t\tcase BCH16_ECC:\n\t\t\telm_write_reg(info, ELM_SYNDROME_FRAGMENT_6 + offset,\n\t\t\t\t\tregs->elm_syndrome_fragment_6[i]);\n\t\t\telm_write_reg(info, ELM_SYNDROME_FRAGMENT_5 + offset,\n\t\t\t\t\tregs->elm_syndrome_fragment_5[i]);\n\t\t\telm_write_reg(info, ELM_SYNDROME_FRAGMENT_4 + offset,\n\t\t\t\t\tregs->elm_syndrome_fragment_4[i]);\n\t\t\tfallthrough;\n\t\tcase BCH8_ECC:\n\t\t\telm_write_reg(info, ELM_SYNDROME_FRAGMENT_3 + offset,\n\t\t\t\t\tregs->elm_syndrome_fragment_3[i]);\n\t\t\telm_write_reg(info, ELM_SYNDROME_FRAGMENT_2 + offset,\n\t\t\t\t\tregs->elm_syndrome_fragment_2[i]);\n\t\t\tfallthrough;\n\t\tcase BCH4_ECC:\n\t\t\telm_write_reg(info, ELM_SYNDROME_FRAGMENT_1 + offset,\n\t\t\t\t\tregs->elm_syndrome_fragment_1[i]);\n\t\t\telm_write_reg(info, ELM_SYNDROME_FRAGMENT_0 + offset,\n\t\t\t\t\tregs->elm_syndrome_fragment_0[i]);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t \n\t\telm_write_reg(info, ELM_SYNDROME_FRAGMENT_6 + offset,\n\t\t\t\t\tregs->elm_syndrome_fragment_6[i] &\n\t\t\t\t\t\t\t ELM_SYNDROME_VALID);\n\t}\n\treturn 0;\n}\n\nstatic int elm_suspend(struct device *dev)\n{\n\tstruct elm_info *info = dev_get_drvdata(dev);\n\telm_context_save(info);\n\tpm_runtime_put_sync(dev);\n\treturn 0;\n}\n\nstatic int elm_resume(struct device *dev)\n{\n\tstruct elm_info *info = dev_get_drvdata(dev);\n\tpm_runtime_get_sync(dev);\n\telm_context_restore(info);\n\treturn 0;\n}\n#endif\n\nstatic SIMPLE_DEV_PM_OPS(elm_pm_ops, elm_suspend, elm_resume);\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id elm_of_match[] = {\n\t{ .compatible = \"ti,am3352-elm\" },\n\t{ .compatible = \"ti,am64-elm\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, elm_of_match);\n#endif\n\nstatic struct platform_driver elm_driver = {\n\t.driver\t= {\n\t\t.name\t= DRIVER_NAME,\n\t\t.of_match_table = of_match_ptr(elm_of_match),\n\t\t.pm\t= &elm_pm_ops,\n\t},\n\t.probe\t= elm_probe,\n\t.remove_new = elm_remove,\n};\n\nmodule_platform_driver(elm_driver);\n\nMODULE_DESCRIPTION(\"ELM driver for BCH error correction\");\nMODULE_AUTHOR(\"Texas Instruments\");\nMODULE_ALIAS(\"platform:\" DRIVER_NAME);\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}