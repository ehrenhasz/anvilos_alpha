{
  "module_name": "socrates_nand.c",
  "hash_id": "6744b987eb30cc607a44502a8f06ae67aacf59d5f6eb600938be5f5f8ae9701a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/nand/raw/socrates_nand.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mtd/mtd.h>\n#include <linux/mtd/rawnand.h>\n#include <linux/mtd/partitions.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/platform_device.h>\n#include <linux/io.h>\n\n#define FPGA_NAND_CMD_MASK\t\t(0x7 << 28)\n#define FPGA_NAND_CMD_COMMAND\t\t(0x0 << 28)\n#define FPGA_NAND_CMD_ADDR\t\t(0x1 << 28)\n#define FPGA_NAND_CMD_READ\t\t(0x2 << 28)\n#define FPGA_NAND_CMD_WRITE\t\t(0x3 << 28)\n#define FPGA_NAND_BUSY\t\t\t(0x1 << 15)\n#define FPGA_NAND_ENABLE\t\t(0x1 << 31)\n#define FPGA_NAND_DATA_SHIFT\t\t16\n\nstruct socrates_nand_host {\n\tstruct nand_controller\tcontroller;\n\tstruct nand_chip\tnand_chip;\n\tvoid __iomem\t\t*io_base;\n\tstruct device\t\t*dev;\n};\n\n \nstatic void socrates_nand_write_buf(struct nand_chip *this, const uint8_t *buf,\n\t\t\t\t    int len)\n{\n\tint i;\n\tstruct socrates_nand_host *host = nand_get_controller_data(this);\n\n\tfor (i = 0; i < len; i++) {\n\t\tout_be32(host->io_base, FPGA_NAND_ENABLE |\n\t\t\t\tFPGA_NAND_CMD_WRITE |\n\t\t\t\t(buf[i] << FPGA_NAND_DATA_SHIFT));\n\t}\n}\n\n \nstatic void socrates_nand_read_buf(struct nand_chip *this, uint8_t *buf,\n\t\t\t\t   int len)\n{\n\tint i;\n\tstruct socrates_nand_host *host = nand_get_controller_data(this);\n\tuint32_t val;\n\n\tval = FPGA_NAND_ENABLE | FPGA_NAND_CMD_READ;\n\n\tout_be32(host->io_base, val);\n\tfor (i = 0; i < len; i++) {\n\t\tbuf[i] = (in_be32(host->io_base) >>\n\t\t\t\tFPGA_NAND_DATA_SHIFT) & 0xff;\n\t}\n}\n\n \nstatic uint8_t socrates_nand_read_byte(struct nand_chip *this)\n{\n\tuint8_t byte;\n\tsocrates_nand_read_buf(this, &byte, sizeof(byte));\n\treturn byte;\n}\n\n \nstatic void socrates_nand_cmd_ctrl(struct nand_chip *nand_chip, int cmd,\n\t\t\t\t   unsigned int ctrl)\n{\n\tstruct socrates_nand_host *host = nand_get_controller_data(nand_chip);\n\tuint32_t val;\n\n\tif (cmd == NAND_CMD_NONE)\n\t\treturn;\n\n\tif (ctrl & NAND_CLE)\n\t\tval = FPGA_NAND_CMD_COMMAND;\n\telse\n\t\tval = FPGA_NAND_CMD_ADDR;\n\n\tif (ctrl & NAND_NCE)\n\t\tval |= FPGA_NAND_ENABLE;\n\n\tval |= (cmd & 0xff) << FPGA_NAND_DATA_SHIFT;\n\n\tout_be32(host->io_base, val);\n}\n\n \nstatic int socrates_nand_device_ready(struct nand_chip *nand_chip)\n{\n\tstruct socrates_nand_host *host = nand_get_controller_data(nand_chip);\n\n\tif (in_be32(host->io_base) & FPGA_NAND_BUSY)\n\t\treturn 0;  \n\treturn 1;\n}\n\nstatic int socrates_attach_chip(struct nand_chip *chip)\n{\n\tif (chip->ecc.engine_type == NAND_ECC_ENGINE_TYPE_SOFT &&\n\t    chip->ecc.algo == NAND_ECC_ALGO_UNKNOWN)\n\t\tchip->ecc.algo = NAND_ECC_ALGO_HAMMING;\n\n\treturn 0;\n}\n\nstatic const struct nand_controller_ops socrates_ops = {\n\t.attach_chip = socrates_attach_chip,\n};\n\n \nstatic int socrates_nand_probe(struct platform_device *ofdev)\n{\n\tstruct socrates_nand_host *host;\n\tstruct mtd_info *mtd;\n\tstruct nand_chip *nand_chip;\n\tint res;\n\n\t \n\thost = devm_kzalloc(&ofdev->dev, sizeof(*host), GFP_KERNEL);\n\tif (!host)\n\t\treturn -ENOMEM;\n\n\thost->io_base = of_iomap(ofdev->dev.of_node, 0);\n\tif (host->io_base == NULL) {\n\t\tdev_err(&ofdev->dev, \"ioremap failed\\n\");\n\t\treturn -EIO;\n\t}\n\n\tnand_chip = &host->nand_chip;\n\tmtd = nand_to_mtd(nand_chip);\n\thost->dev = &ofdev->dev;\n\n\tnand_controller_init(&host->controller);\n\thost->controller.ops = &socrates_ops;\n\tnand_chip->controller = &host->controller;\n\n\t \n\tnand_set_controller_data(nand_chip, host);\n\tnand_set_flash_node(nand_chip, ofdev->dev.of_node);\n\tmtd->name = \"socrates_nand\";\n\tmtd->dev.parent = &ofdev->dev;\n\n\tnand_chip->legacy.cmd_ctrl = socrates_nand_cmd_ctrl;\n\tnand_chip->legacy.read_byte = socrates_nand_read_byte;\n\tnand_chip->legacy.write_buf = socrates_nand_write_buf;\n\tnand_chip->legacy.read_buf = socrates_nand_read_buf;\n\tnand_chip->legacy.dev_ready = socrates_nand_device_ready;\n\n\t \n\tnand_chip->legacy.chip_delay = 20;\t \n\n\t \n\tnand_chip->ecc.engine_type = NAND_ECC_ENGINE_TYPE_SOFT;\n\n\tdev_set_drvdata(&ofdev->dev, host);\n\n\tres = nand_scan(nand_chip, 1);\n\tif (res)\n\t\tgoto out;\n\n\tres = mtd_device_register(mtd, NULL, 0);\n\tif (!res)\n\t\treturn res;\n\n\tnand_cleanup(nand_chip);\n\nout:\n\tiounmap(host->io_base);\n\treturn res;\n}\n\n \nstatic void socrates_nand_remove(struct platform_device *ofdev)\n{\n\tstruct socrates_nand_host *host = dev_get_drvdata(&ofdev->dev);\n\tstruct nand_chip *chip = &host->nand_chip;\n\tint ret;\n\n\tret = mtd_device_unregister(nand_to_mtd(chip));\n\tWARN_ON(ret);\n\tnand_cleanup(chip);\n\n\tiounmap(host->io_base);\n}\n\nstatic const struct of_device_id socrates_nand_match[] =\n{\n\t{\n\t\t.compatible   = \"abb,socrates-nand\",\n\t},\n\t{},\n};\n\nMODULE_DEVICE_TABLE(of, socrates_nand_match);\n\nstatic struct platform_driver socrates_nand_driver = {\n\t.driver = {\n\t\t.name = \"socrates_nand\",\n\t\t.of_match_table = socrates_nand_match,\n\t},\n\t.probe\t\t= socrates_nand_probe,\n\t.remove_new\t= socrates_nand_remove,\n};\n\nmodule_platform_driver(socrates_nand_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Ilya Yanok\");\nMODULE_DESCRIPTION(\"NAND driver for Socrates board\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}