{
  "module_name": "mpc5121_nfc.c",
  "hash_id": "65376e5b924ba662a5eb8c7152b07357c64bb1f9bc2d9a3371d0480117044470",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/nand/raw/mpc5121_nfc.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/clk.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/mtd/mtd.h>\n#include <linux/mtd/rawnand.h>\n#include <linux/mtd/partitions.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n#include <linux/platform_device.h>\n\n#include <asm/mpc5121.h>\n\n \n#define NFC_MAIN_AREA(n)\t((n) *  0x200)\n\n \n#define NFC_SPARE_BUFFERS\t8\n#define NFC_SPARE_LEN\t\t0x40\n#define NFC_SPARE_AREA(n)\t(0x1000 + ((n) * NFC_SPARE_LEN))\n\n \n#define NFC_BUF_ADDR\t\t0x1E04\n#define NFC_FLASH_ADDR\t\t0x1E06\n#define NFC_FLASH_CMD\t\t0x1E08\n#define NFC_CONFIG\t\t0x1E0A\n#define NFC_ECC_STATUS1\t\t0x1E0C\n#define NFC_ECC_STATUS2\t\t0x1E0E\n#define NFC_SPAS\t\t0x1E10\n#define NFC_WRPROT\t\t0x1E12\n#define NFC_NF_WRPRST\t\t0x1E18\n#define NFC_CONFIG1\t\t0x1E1A\n#define NFC_CONFIG2\t\t0x1E1C\n#define NFC_UNLOCKSTART_BLK0\t0x1E20\n#define NFC_UNLOCKEND_BLK0\t0x1E22\n#define NFC_UNLOCKSTART_BLK1\t0x1E24\n#define NFC_UNLOCKEND_BLK1\t0x1E26\n#define NFC_UNLOCKSTART_BLK2\t0x1E28\n#define NFC_UNLOCKEND_BLK2\t0x1E2A\n#define NFC_UNLOCKSTART_BLK3\t0x1E2C\n#define NFC_UNLOCKEND_BLK3\t0x1E2E\n\n \n#define NFC_RBA_MASK\t\t(7 << 0)\n#define NFC_ACTIVE_CS_SHIFT\t5\n#define NFC_ACTIVE_CS_MASK\t(3 << NFC_ACTIVE_CS_SHIFT)\n\n \n#define NFC_BLS_UNLOCKED\t(1 << 1)\n\n \n#define NFC_ECC_4BIT\t\t(1 << 0)\n#define NFC_FULL_PAGE_DMA\t(1 << 1)\n#define NFC_SPARE_ONLY\t\t(1 << 2)\n#define NFC_ECC_ENABLE\t\t(1 << 3)\n#define NFC_INT_MASK\t\t(1 << 4)\n#define NFC_BIG_ENDIAN\t\t(1 << 5)\n#define NFC_RESET\t\t(1 << 6)\n#define NFC_CE\t\t\t(1 << 7)\n#define NFC_ONE_CYCLE\t\t(1 << 8)\n#define NFC_PPB_32\t\t(0 << 9)\n#define NFC_PPB_64\t\t(1 << 9)\n#define NFC_PPB_128\t\t(2 << 9)\n#define NFC_PPB_256\t\t(3 << 9)\n#define NFC_PPB_MASK\t\t(3 << 9)\n#define NFC_FULL_PAGE_INT\t(1 << 11)\n\n \n#define NFC_COMMAND\t\t(1 << 0)\n#define NFC_ADDRESS\t\t(1 << 1)\n#define NFC_INPUT\t\t(1 << 2)\n#define NFC_OUTPUT\t\t(1 << 3)\n#define NFC_ID\t\t\t(1 << 4)\n#define NFC_STATUS\t\t(1 << 5)\n#define NFC_CMD_FAIL\t\t(1 << 15)\n#define NFC_INT\t\t\t(1 << 15)\n\n \n#define NFC_WPC_LOCK_TIGHT\t(1 << 0)\n#define NFC_WPC_LOCK\t\t(1 << 1)\n#define NFC_WPC_UNLOCK\t\t(1 << 2)\n\n#define\tDRV_NAME\t\t\"mpc5121_nfc\"\n\n \n#define NFC_RESET_TIMEOUT\t1000\t\t \n#define NFC_TIMEOUT\t\t(HZ / 10)\t \n\nstruct mpc5121_nfc_prv {\n\tstruct nand_controller\tcontroller;\n\tstruct nand_chip\tchip;\n\tint\t\t\tirq;\n\tvoid __iomem\t\t*regs;\n\tstruct clk\t\t*clk;\n\twait_queue_head_t\tirq_waitq;\n\tuint\t\t\tcolumn;\n\tint\t\t\tspareonly;\n\tvoid __iomem\t\t*csreg;\n\tstruct device\t\t*dev;\n};\n\nstatic void mpc5121_nfc_done(struct mtd_info *mtd);\n\n \nstatic inline u16 nfc_read(struct mtd_info *mtd, uint reg)\n{\n\tstruct nand_chip *chip = mtd_to_nand(mtd);\n\tstruct mpc5121_nfc_prv *prv = nand_get_controller_data(chip);\n\n\treturn in_be16(prv->regs + reg);\n}\n\n \nstatic inline void nfc_write(struct mtd_info *mtd, uint reg, u16 val)\n{\n\tstruct nand_chip *chip = mtd_to_nand(mtd);\n\tstruct mpc5121_nfc_prv *prv = nand_get_controller_data(chip);\n\n\tout_be16(prv->regs + reg, val);\n}\n\n \nstatic inline void nfc_set(struct mtd_info *mtd, uint reg, u16 bits)\n{\n\tnfc_write(mtd, reg, nfc_read(mtd, reg) | bits);\n}\n\n \nstatic inline void nfc_clear(struct mtd_info *mtd, uint reg, u16 bits)\n{\n\tnfc_write(mtd, reg, nfc_read(mtd, reg) & ~bits);\n}\n\n \nstatic inline void mpc5121_nfc_send_addr(struct mtd_info *mtd, u16 addr)\n{\n\tnfc_write(mtd, NFC_FLASH_ADDR, addr);\n\tnfc_write(mtd, NFC_CONFIG2, NFC_ADDRESS);\n\tmpc5121_nfc_done(mtd);\n}\n\n \nstatic inline void mpc5121_nfc_send_cmd(struct mtd_info *mtd, u16 cmd)\n{\n\tnfc_write(mtd, NFC_FLASH_CMD, cmd);\n\tnfc_write(mtd, NFC_CONFIG2, NFC_COMMAND);\n\tmpc5121_nfc_done(mtd);\n}\n\n \nstatic inline void mpc5121_nfc_send_prog_page(struct mtd_info *mtd)\n{\n\tnfc_clear(mtd, NFC_BUF_ADDR, NFC_RBA_MASK);\n\tnfc_write(mtd, NFC_CONFIG2, NFC_INPUT);\n\tmpc5121_nfc_done(mtd);\n}\n\n \nstatic inline void mpc5121_nfc_send_read_page(struct mtd_info *mtd)\n{\n\tnfc_clear(mtd, NFC_BUF_ADDR, NFC_RBA_MASK);\n\tnfc_write(mtd, NFC_CONFIG2, NFC_OUTPUT);\n\tmpc5121_nfc_done(mtd);\n}\n\n \nstatic inline void mpc5121_nfc_send_read_id(struct mtd_info *mtd)\n{\n\tnfc_clear(mtd, NFC_BUF_ADDR, NFC_RBA_MASK);\n\tnfc_write(mtd, NFC_CONFIG2, NFC_ID);\n\tmpc5121_nfc_done(mtd);\n}\n\n \nstatic inline void mpc5121_nfc_send_read_status(struct mtd_info *mtd)\n{\n\tnfc_clear(mtd, NFC_BUF_ADDR, NFC_RBA_MASK);\n\tnfc_write(mtd, NFC_CONFIG2, NFC_STATUS);\n\tmpc5121_nfc_done(mtd);\n}\n\n \nstatic irqreturn_t mpc5121_nfc_irq(int irq, void *data)\n{\n\tstruct mtd_info *mtd = data;\n\tstruct nand_chip *chip = mtd_to_nand(mtd);\n\tstruct mpc5121_nfc_prv *prv = nand_get_controller_data(chip);\n\n\tnfc_set(mtd, NFC_CONFIG1, NFC_INT_MASK);\n\twake_up(&prv->irq_waitq);\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic void mpc5121_nfc_done(struct mtd_info *mtd)\n{\n\tstruct nand_chip *chip = mtd_to_nand(mtd);\n\tstruct mpc5121_nfc_prv *prv = nand_get_controller_data(chip);\n\tint rv;\n\n\tif ((nfc_read(mtd, NFC_CONFIG2) & NFC_INT) == 0) {\n\t\tnfc_clear(mtd, NFC_CONFIG1, NFC_INT_MASK);\n\t\trv = wait_event_timeout(prv->irq_waitq,\n\t\t\t(nfc_read(mtd, NFC_CONFIG2) & NFC_INT), NFC_TIMEOUT);\n\n\t\tif (!rv)\n\t\t\tdev_warn(prv->dev,\n\t\t\t\t\"Timeout while waiting for interrupt.\\n\");\n\t}\n\n\tnfc_clear(mtd, NFC_CONFIG2, NFC_INT);\n}\n\n \nstatic void mpc5121_nfc_addr_cycle(struct mtd_info *mtd, int column, int page)\n{\n\tstruct nand_chip *chip = mtd_to_nand(mtd);\n\tu32 pagemask = chip->pagemask;\n\n\tif (column != -1) {\n\t\tmpc5121_nfc_send_addr(mtd, column);\n\t\tif (mtd->writesize > 512)\n\t\t\tmpc5121_nfc_send_addr(mtd, column >> 8);\n\t}\n\n\tif (page != -1) {\n\t\tdo {\n\t\t\tmpc5121_nfc_send_addr(mtd, page & 0xFF);\n\t\t\tpage >>= 8;\n\t\t\tpagemask >>= 8;\n\t\t} while (pagemask);\n\t}\n}\n\n \nstatic void mpc5121_nfc_select_chip(struct nand_chip *nand, int chip)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(nand);\n\n\tif (chip < 0) {\n\t\tnfc_clear(mtd, NFC_CONFIG1, NFC_CE);\n\t\treturn;\n\t}\n\n\tnfc_clear(mtd, NFC_BUF_ADDR, NFC_ACTIVE_CS_MASK);\n\tnfc_set(mtd, NFC_BUF_ADDR, (chip << NFC_ACTIVE_CS_SHIFT) &\n\t\t\t\t\t\t\tNFC_ACTIVE_CS_MASK);\n\tnfc_set(mtd, NFC_CONFIG1, NFC_CE);\n}\n\n \nstatic int ads5121_chipselect_init(struct mtd_info *mtd)\n{\n\tstruct nand_chip *chip = mtd_to_nand(mtd);\n\tstruct mpc5121_nfc_prv *prv = nand_get_controller_data(chip);\n\tstruct device_node *dn;\n\n\tdn = of_find_compatible_node(NULL, NULL, \"fsl,mpc5121ads-cpld\");\n\tif (dn) {\n\t\tprv->csreg = of_iomap(dn, 0);\n\t\tof_node_put(dn);\n\t\tif (!prv->csreg)\n\t\t\treturn -ENOMEM;\n\n\t\t \n\t\tprv->csreg += 9;\n\t\treturn 0;\n\t}\n\n\treturn -EINVAL;\n}\n\n \nstatic void ads5121_select_chip(struct nand_chip *nand, int chip)\n{\n\tstruct mpc5121_nfc_prv *prv = nand_get_controller_data(nand);\n\tu8 v;\n\n\tv = in_8(prv->csreg);\n\tv |= 0x0F;\n\n\tif (chip >= 0) {\n\t\tmpc5121_nfc_select_chip(nand, 0);\n\t\tv &= ~(1 << chip);\n\t} else\n\t\tmpc5121_nfc_select_chip(nand, -1);\n\n\tout_8(prv->csreg, v);\n}\n\n \nstatic int mpc5121_nfc_dev_ready(struct nand_chip *nand)\n{\n\t \n\treturn 1;\n}\n\n \nstatic void mpc5121_nfc_command(struct nand_chip *chip, unsigned command,\n\t\t\t\tint column, int page)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tstruct mpc5121_nfc_prv *prv = nand_get_controller_data(chip);\n\n\tprv->column = (column >= 0) ? column : 0;\n\tprv->spareonly = 0;\n\n\tswitch (command) {\n\tcase NAND_CMD_PAGEPROG:\n\t\tmpc5121_nfc_send_prog_page(mtd);\n\t\tbreak;\n\t \n\tcase NAND_CMD_READ0:\n\t\tcolumn = 0;\n\t\tbreak;\n\n\tcase NAND_CMD_READ1:\n\t\tprv->column += 256;\n\t\tcommand = NAND_CMD_READ0;\n\t\tcolumn = 0;\n\t\tbreak;\n\n\tcase NAND_CMD_READOOB:\n\t\tprv->spareonly = 1;\n\t\tcommand = NAND_CMD_READ0;\n\t\tcolumn = 0;\n\t\tbreak;\n\n\tcase NAND_CMD_SEQIN:\n\t\tmpc5121_nfc_command(chip, NAND_CMD_READ0, column, page);\n\t\tcolumn = 0;\n\t\tbreak;\n\n\tcase NAND_CMD_ERASE1:\n\tcase NAND_CMD_ERASE2:\n\tcase NAND_CMD_READID:\n\tcase NAND_CMD_STATUS:\n\t\tbreak;\n\n\tdefault:\n\t\treturn;\n\t}\n\n\tmpc5121_nfc_send_cmd(mtd, command);\n\tmpc5121_nfc_addr_cycle(mtd, column, page);\n\n\tswitch (command) {\n\tcase NAND_CMD_READ0:\n\t\tif (mtd->writesize > 512)\n\t\t\tmpc5121_nfc_send_cmd(mtd, NAND_CMD_READSTART);\n\t\tmpc5121_nfc_send_read_page(mtd);\n\t\tbreak;\n\n\tcase NAND_CMD_READID:\n\t\tmpc5121_nfc_send_read_id(mtd);\n\t\tbreak;\n\n\tcase NAND_CMD_STATUS:\n\t\tmpc5121_nfc_send_read_status(mtd);\n\t\tif (chip->options & NAND_BUSWIDTH_16)\n\t\t\tprv->column = 1;\n\t\telse\n\t\t\tprv->column = 0;\n\t\tbreak;\n\t}\n}\n\n \nstatic void mpc5121_nfc_copy_spare(struct mtd_info *mtd, uint offset,\n\t\t\t\t\t\tu8 *buffer, uint size, int wr)\n{\n\tstruct nand_chip *nand = mtd_to_nand(mtd);\n\tstruct mpc5121_nfc_prv *prv = nand_get_controller_data(nand);\n\tuint o, s, sbsize, blksize;\n\n\t \n\n\t \n\tsbsize = (mtd->oobsize / (mtd->writesize / 512)) & ~1;\n\n\twhile (size) {\n\t\t \n\t\ts = offset / sbsize;\n\t\tif (s > NFC_SPARE_BUFFERS - 1)\n\t\t\ts = NFC_SPARE_BUFFERS - 1;\n\n\t\t \n\t\to = offset - (s * sbsize);\n\t\tblksize = min(sbsize - o, size);\n\n\t\tif (wr)\n\t\t\tmemcpy_toio(prv->regs + NFC_SPARE_AREA(s) + o,\n\t\t\t\t\t\t\tbuffer, blksize);\n\t\telse\n\t\t\tmemcpy_fromio(buffer,\n\t\t\t\tprv->regs + NFC_SPARE_AREA(s) + o, blksize);\n\n\t\tbuffer += blksize;\n\t\toffset += blksize;\n\t\tsize -= blksize;\n\t}\n}\n\n \nstatic void mpc5121_nfc_buf_copy(struct mtd_info *mtd, u_char *buf, int len,\n\t\t\t\t\t\t\t\t\tint wr)\n{\n\tstruct nand_chip *chip = mtd_to_nand(mtd);\n\tstruct mpc5121_nfc_prv *prv = nand_get_controller_data(chip);\n\tuint c = prv->column;\n\tuint l;\n\n\t \n\tif (prv->spareonly || c >= mtd->writesize) {\n\t\t \n\t\tif (c >= mtd->writesize)\n\t\t\tc -= mtd->writesize;\n\n\t\tprv->column += len;\n\t\tmpc5121_nfc_copy_spare(mtd, c, buf, len, wr);\n\t\treturn;\n\t}\n\n\t \n\tl = min((uint)len, mtd->writesize - c);\n\tprv->column += l;\n\n\tif (wr)\n\t\tmemcpy_toio(prv->regs + NFC_MAIN_AREA(0) + c, buf, l);\n\telse\n\t\tmemcpy_fromio(buf, prv->regs + NFC_MAIN_AREA(0) + c, l);\n\n\t \n\tif (l != len) {\n\t\tbuf += l;\n\t\tlen -= l;\n\t\tmpc5121_nfc_buf_copy(mtd, buf, len, wr);\n\t}\n}\n\n \nstatic void mpc5121_nfc_read_buf(struct nand_chip *chip, u_char *buf, int len)\n{\n\tmpc5121_nfc_buf_copy(nand_to_mtd(chip), buf, len, 0);\n}\n\n \nstatic void mpc5121_nfc_write_buf(struct nand_chip *chip, const u_char *buf,\n\t\t\t\t  int len)\n{\n\tmpc5121_nfc_buf_copy(nand_to_mtd(chip), (u_char *)buf, len, 1);\n}\n\n \nstatic u8 mpc5121_nfc_read_byte(struct nand_chip *chip)\n{\n\tu8 tmp;\n\n\tmpc5121_nfc_read_buf(chip, &tmp, sizeof(tmp));\n\n\treturn tmp;\n}\n\n \nstatic int mpc5121_nfc_read_hw_config(struct mtd_info *mtd)\n{\n\tstruct nand_chip *chip = mtd_to_nand(mtd);\n\tstruct mpc5121_nfc_prv *prv = nand_get_controller_data(chip);\n\tstruct mpc512x_reset_module *rm;\n\tstruct device_node *rmnode;\n\tuint rcw_pagesize = 0;\n\tuint rcw_sparesize = 0;\n\tuint rcw_width;\n\tuint rcwh;\n\tuint romloc, ps;\n\tint ret = 0;\n\n\trmnode = of_find_compatible_node(NULL, NULL, \"fsl,mpc5121-reset\");\n\tif (!rmnode) {\n\t\tdev_err(prv->dev, \"Missing 'fsl,mpc5121-reset' \"\n\t\t\t\t\t\"node in device tree!\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\trm = of_iomap(rmnode, 0);\n\tif (!rm) {\n\t\tdev_err(prv->dev, \"Error mapping reset module node!\\n\");\n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n\n\trcwh = in_be32(&rm->rcwhr);\n\n\t \n\trcw_width = ((rcwh >> 6) & 0x1) ? 2 : 1;\n\n\t \n\tps = (rcwh >> 7) & 0x1;\n\n\t \n\tromloc = (rcwh >> 21) & 0x3;\n\n\t \n\tswitch ((ps << 2) | romloc) {\n\tcase 0x00:\n\tcase 0x01:\n\t\trcw_pagesize = 512;\n\t\trcw_sparesize = 16;\n\t\tbreak;\n\tcase 0x02:\n\tcase 0x03:\n\t\trcw_pagesize = 4096;\n\t\trcw_sparesize = 128;\n\t\tbreak;\n\tcase 0x04:\n\tcase 0x05:\n\t\trcw_pagesize = 2048;\n\t\trcw_sparesize = 64;\n\t\tbreak;\n\tcase 0x06:\n\tcase 0x07:\n\t\trcw_pagesize = 4096;\n\t\trcw_sparesize = 218;\n\t\tbreak;\n\t}\n\n\tmtd->writesize = rcw_pagesize;\n\tmtd->oobsize = rcw_sparesize;\n\tif (rcw_width == 2)\n\t\tchip->options |= NAND_BUSWIDTH_16;\n\n\tdev_notice(prv->dev, \"Configured for \"\n\t\t\t\t\"%u-bit NAND, page size %u \"\n\t\t\t\t\"with %u spare.\\n\",\n\t\t\t\trcw_width * 8, rcw_pagesize,\n\t\t\t\trcw_sparesize);\n\tiounmap(rm);\nout:\n\tof_node_put(rmnode);\n\treturn ret;\n}\n\n \nstatic void mpc5121_nfc_free(struct device *dev, struct mtd_info *mtd)\n{\n\tstruct nand_chip *chip = mtd_to_nand(mtd);\n\tstruct mpc5121_nfc_prv *prv = nand_get_controller_data(chip);\n\n\tif (prv->csreg)\n\t\tiounmap(prv->csreg);\n}\n\nstatic int mpc5121_nfc_attach_chip(struct nand_chip *chip)\n{\n\tif (chip->ecc.engine_type == NAND_ECC_ENGINE_TYPE_SOFT &&\n\t    chip->ecc.algo == NAND_ECC_ALGO_UNKNOWN)\n\t\tchip->ecc.algo = NAND_ECC_ALGO_HAMMING;\n\n\treturn 0;\n}\n\nstatic const struct nand_controller_ops mpc5121_nfc_ops = {\n\t.attach_chip = mpc5121_nfc_attach_chip,\n};\n\nstatic int mpc5121_nfc_probe(struct platform_device *op)\n{\n\tstruct device_node *dn = op->dev.of_node;\n\tstruct clk *clk;\n\tstruct device *dev = &op->dev;\n\tstruct mpc5121_nfc_prv *prv;\n\tstruct resource res;\n\tstruct mtd_info *mtd;\n\tstruct nand_chip *chip;\n\tunsigned long regs_paddr, regs_size;\n\tconst __be32 *chips_no;\n\tint resettime = 0;\n\tint retval = 0;\n\tint rev, len;\n\n\t \n\trev = (mfspr(SPRN_SVR) >> 4) & 0xF;\n\tif ((rev != 2) && (rev != 3)) {\n\t\tdev_err(dev, \"SoC revision %u is not supported!\\n\", rev);\n\t\treturn -ENXIO;\n\t}\n\n\tprv = devm_kzalloc(dev, sizeof(*prv), GFP_KERNEL);\n\tif (!prv)\n\t\treturn -ENOMEM;\n\n\tchip = &prv->chip;\n\tmtd = nand_to_mtd(chip);\n\n\tnand_controller_init(&prv->controller);\n\tprv->controller.ops = &mpc5121_nfc_ops;\n\tchip->controller = &prv->controller;\n\n\tmtd->dev.parent = dev;\n\tnand_set_controller_data(chip, prv);\n\tnand_set_flash_node(chip, dn);\n\tprv->dev = dev;\n\n\t \n\tretval = mpc5121_nfc_read_hw_config(mtd);\n\tif (retval) {\n\t\tdev_err(dev, \"Unable to read NFC config!\\n\");\n\t\treturn retval;\n\t}\n\n\tprv->irq = irq_of_parse_and_map(dn, 0);\n\tif (!prv->irq) {\n\t\tdev_err(dev, \"Error mapping IRQ!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tretval = of_address_to_resource(dn, 0, &res);\n\tif (retval) {\n\t\tdev_err(dev, \"Error parsing memory region!\\n\");\n\t\treturn retval;\n\t}\n\n\tchips_no = of_get_property(dn, \"chips\", &len);\n\tif (!chips_no || len != sizeof(*chips_no)) {\n\t\tdev_err(dev, \"Invalid/missing 'chips' property!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tregs_paddr = res.start;\n\tregs_size = resource_size(&res);\n\n\tif (!devm_request_mem_region(dev, regs_paddr, regs_size, DRV_NAME)) {\n\t\tdev_err(dev, \"Error requesting memory region!\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tprv->regs = devm_ioremap(dev, regs_paddr, regs_size);\n\tif (!prv->regs) {\n\t\tdev_err(dev, \"Error mapping memory region!\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tmtd->name = \"MPC5121 NAND\";\n\tchip->legacy.dev_ready = mpc5121_nfc_dev_ready;\n\tchip->legacy.cmdfunc = mpc5121_nfc_command;\n\tchip->legacy.read_byte = mpc5121_nfc_read_byte;\n\tchip->legacy.read_buf = mpc5121_nfc_read_buf;\n\tchip->legacy.write_buf = mpc5121_nfc_write_buf;\n\tchip->legacy.select_chip = mpc5121_nfc_select_chip;\n\tchip->legacy.set_features = nand_get_set_features_notsupp;\n\tchip->legacy.get_features = nand_get_set_features_notsupp;\n\tchip->bbt_options = NAND_BBT_USE_FLASH;\n\n\t \n\tif (of_machine_is_compatible(\"fsl,mpc5121ads\")) {\n\t\tretval = ads5121_chipselect_init(mtd);\n\t\tif (retval) {\n\t\t\tdev_err(dev, \"Chipselect init error!\\n\");\n\t\t\treturn retval;\n\t\t}\n\n\t\tchip->legacy.select_chip = ads5121_select_chip;\n\t}\n\n\t \n\tclk = devm_clk_get_enabled(dev, \"ipg\");\n\tif (IS_ERR(clk)) {\n\t\tdev_err(dev, \"Unable to acquire and enable NFC clock!\\n\");\n\t\tretval = PTR_ERR(clk);\n\t\tgoto error;\n\t}\n\tprv->clk = clk;\n\n\t \n\tnfc_set(mtd, NFC_CONFIG1, NFC_RESET);\n\twhile (nfc_read(mtd, NFC_CONFIG1) & NFC_RESET) {\n\t\tif (resettime++ >= NFC_RESET_TIMEOUT) {\n\t\t\tdev_err(dev, \"Timeout while resetting NFC!\\n\");\n\t\t\tretval = -EINVAL;\n\t\t\tgoto error;\n\t\t}\n\n\t\tudelay(1);\n\t}\n\n\t \n\tnfc_write(mtd, NFC_CONFIG, NFC_BLS_UNLOCKED);\n\n\t \n\tnfc_write(mtd, NFC_UNLOCKSTART_BLK0, 0x0000);\n\tnfc_write(mtd, NFC_UNLOCKEND_BLK0, 0xFFFF);\n\tnfc_write(mtd, NFC_WRPROT, NFC_WPC_UNLOCK);\n\n\t \n\tnfc_write(mtd, NFC_CONFIG1, NFC_BIG_ENDIAN | NFC_INT_MASK |\n\t\t\t\t\t\t\tNFC_FULL_PAGE_INT);\n\n\t \n\tnfc_write(mtd, NFC_SPAS, mtd->oobsize >> 1);\n\n\tinit_waitqueue_head(&prv->irq_waitq);\n\tretval = devm_request_irq(dev, prv->irq, &mpc5121_nfc_irq, 0, DRV_NAME,\n\t\t\t\t\t\t\t\t\tmtd);\n\tif (retval) {\n\t\tdev_err(dev, \"Error requesting IRQ!\\n\");\n\t\tgoto error;\n\t}\n\n\t \n\tchip->ecc.engine_type = NAND_ECC_ENGINE_TYPE_SOFT;\n\n\t \n\tretval = nand_scan(chip, be32_to_cpup(chips_no));\n\tif (retval) {\n\t\tdev_err(dev, \"NAND Flash not found !\\n\");\n\t\tgoto error;\n\t}\n\n\t \n\tswitch (mtd->erasesize / mtd->writesize) {\n\tcase 32:\n\t\tnfc_set(mtd, NFC_CONFIG1, NFC_PPB_32);\n\t\tbreak;\n\n\tcase 64:\n\t\tnfc_set(mtd, NFC_CONFIG1, NFC_PPB_64);\n\t\tbreak;\n\n\tcase 128:\n\t\tnfc_set(mtd, NFC_CONFIG1, NFC_PPB_128);\n\t\tbreak;\n\n\tcase 256:\n\t\tnfc_set(mtd, NFC_CONFIG1, NFC_PPB_256);\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(dev, \"Unsupported NAND flash!\\n\");\n\t\tretval = -ENXIO;\n\t\tgoto error;\n\t}\n\n\tdev_set_drvdata(dev, mtd);\n\n\t \n\tretval = mtd_device_register(mtd, NULL, 0);\n\tif (retval) {\n\t\tdev_err(dev, \"Error adding MTD device!\\n\");\n\t\tgoto error;\n\t}\n\n\treturn 0;\nerror:\n\tmpc5121_nfc_free(dev, mtd);\n\treturn retval;\n}\n\nstatic void mpc5121_nfc_remove(struct platform_device *op)\n{\n\tstruct device *dev = &op->dev;\n\tstruct mtd_info *mtd = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = mtd_device_unregister(mtd);\n\tWARN_ON(ret);\n\tnand_cleanup(mtd_to_nand(mtd));\n\tmpc5121_nfc_free(dev, mtd);\n}\n\nstatic const struct of_device_id mpc5121_nfc_match[] = {\n\t{ .compatible = \"fsl,mpc5121-nfc\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, mpc5121_nfc_match);\n\nstatic struct platform_driver mpc5121_nfc_driver = {\n\t.probe\t\t= mpc5121_nfc_probe,\n\t.remove_new\t= mpc5121_nfc_remove,\n\t.driver\t\t= {\n\t\t.name = DRV_NAME,\n\t\t.of_match_table = mpc5121_nfc_match,\n\t},\n};\n\nmodule_platform_driver(mpc5121_nfc_driver);\n\nMODULE_AUTHOR(\"Freescale Semiconductor, Inc.\");\nMODULE_DESCRIPTION(\"MPC5121 NAND MTD driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}