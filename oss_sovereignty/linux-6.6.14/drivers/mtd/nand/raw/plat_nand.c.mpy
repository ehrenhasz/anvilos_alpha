{
  "module_name": "plat_nand.c",
  "hash_id": "c5580e658370fd1ce7495dcd3d8796d6b37d6b7f6198ed07f48d13256c281de7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/nand/raw/plat_nand.c",
  "human_readable_source": "\n \n\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/mtd/mtd.h>\n#include <linux/mtd/platnand.h>\n\nstruct plat_nand_data {\n\tstruct nand_controller\tcontroller;\n\tstruct nand_chip\tchip;\n\tvoid __iomem\t\t*io_base;\n};\n\nstatic int plat_nand_attach_chip(struct nand_chip *chip)\n{\n\tif (chip->ecc.engine_type == NAND_ECC_ENGINE_TYPE_SOFT &&\n\t    chip->ecc.algo == NAND_ECC_ALGO_UNKNOWN)\n\t\tchip->ecc.algo = NAND_ECC_ALGO_HAMMING;\n\n\treturn 0;\n}\n\nstatic const struct nand_controller_ops plat_nand_ops = {\n\t.attach_chip = plat_nand_attach_chip,\n};\n\n \nstatic int plat_nand_probe(struct platform_device *pdev)\n{\n\tstruct platform_nand_data *pdata = dev_get_platdata(&pdev->dev);\n\tstruct plat_nand_data *data;\n\tstruct mtd_info *mtd;\n\tconst char **part_types;\n\tint err = 0;\n\n\tif (!pdata) {\n\t\tdev_err(&pdev->dev, \"platform_nand_data is missing\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (pdata->chip.nr_chips < 1) {\n\t\tdev_err(&pdev->dev, \"invalid number of chips specified\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tdata = devm_kzalloc(&pdev->dev, sizeof(struct plat_nand_data),\n\t\t\t    GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tdata->controller.ops = &plat_nand_ops;\n\tnand_controller_init(&data->controller);\n\tdata->chip.controller = &data->controller;\n\n\tdata->io_base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(data->io_base))\n\t\treturn PTR_ERR(data->io_base);\n\n\tnand_set_flash_node(&data->chip, pdev->dev.of_node);\n\tmtd = nand_to_mtd(&data->chip);\n\tmtd->dev.parent = &pdev->dev;\n\n\tdata->chip.legacy.IO_ADDR_R = data->io_base;\n\tdata->chip.legacy.IO_ADDR_W = data->io_base;\n\tdata->chip.legacy.cmd_ctrl = pdata->ctrl.cmd_ctrl;\n\tdata->chip.legacy.dev_ready = pdata->ctrl.dev_ready;\n\tdata->chip.legacy.select_chip = pdata->ctrl.select_chip;\n\tdata->chip.legacy.write_buf = pdata->ctrl.write_buf;\n\tdata->chip.legacy.read_buf = pdata->ctrl.read_buf;\n\tdata->chip.legacy.chip_delay = pdata->chip.chip_delay;\n\tdata->chip.options |= pdata->chip.options;\n\tdata->chip.bbt_options |= pdata->chip.bbt_options;\n\n\tplatform_set_drvdata(pdev, data);\n\n\t \n\tif (pdata->ctrl.probe) {\n\t\terr = pdata->ctrl.probe(pdev);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\t \n\tdata->chip.ecc.engine_type = NAND_ECC_ENGINE_TYPE_SOFT;\n\n\t \n\terr = nand_scan(&data->chip, pdata->chip.nr_chips);\n\tif (err)\n\t\tgoto out;\n\n\tpart_types = pdata->chip.part_probe_types;\n\n\terr = mtd_device_parse_register(mtd, part_types, NULL,\n\t\t\t\t\tpdata->chip.partitions,\n\t\t\t\t\tpdata->chip.nr_partitions);\n\n\tif (!err)\n\t\treturn err;\n\n\tnand_cleanup(&data->chip);\nout:\n\tif (pdata->ctrl.remove)\n\t\tpdata->ctrl.remove(pdev);\n\treturn err;\n}\n\n \nstatic void plat_nand_remove(struct platform_device *pdev)\n{\n\tstruct plat_nand_data *data = platform_get_drvdata(pdev);\n\tstruct platform_nand_data *pdata = dev_get_platdata(&pdev->dev);\n\tstruct nand_chip *chip = &data->chip;\n\tint ret;\n\n\tret = mtd_device_unregister(nand_to_mtd(chip));\n\tWARN_ON(ret);\n\tnand_cleanup(chip);\n\tif (pdata->ctrl.remove)\n\t\tpdata->ctrl.remove(pdev);\n}\n\nstatic const struct of_device_id plat_nand_match[] = {\n\t{ .compatible = \"gen_nand\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, plat_nand_match);\n\nstatic struct platform_driver plat_nand_driver = {\n\t.probe\t= plat_nand_probe,\n\t.remove_new = plat_nand_remove,\n\t.driver\t= {\n\t\t.name\t\t= \"gen_nand\",\n\t\t.of_match_table = plat_nand_match,\n\t},\n};\n\nmodule_platform_driver(plat_nand_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Vitaly Wool\");\nMODULE_DESCRIPTION(\"Simple generic NAND driver\");\nMODULE_ALIAS(\"platform:gen_nand\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}