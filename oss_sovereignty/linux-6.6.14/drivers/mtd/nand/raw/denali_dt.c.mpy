{
  "module_name": "denali_dt.c",
  "hash_id": "78d2e443cf025a6a09a1124a873860ab5d3588cdb3e371bfcfb92775c7b5df94",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/nand/raw/denali_dt.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/ioport.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/reset.h>\n\n#include \"denali.h\"\n\nstruct denali_dt {\n\tstruct denali_controller controller;\n\tstruct clk *clk;\t \n\tstruct clk *clk_x;\t \n\tstruct clk *clk_ecc;\t \n\tstruct reset_control *rst;\t \n\tstruct reset_control *rst_reg;\t \n};\n\nstruct denali_dt_data {\n\tunsigned int revision;\n\tunsigned int caps;\n\tunsigned int oob_skip_bytes;\n\tconst struct nand_ecc_caps *ecc_caps;\n};\n\nNAND_ECC_CAPS_SINGLE(denali_socfpga_ecc_caps, denali_calc_ecc_bytes,\n\t\t     512, 8, 15);\nstatic const struct denali_dt_data denali_socfpga_data = {\n\t.caps = DENALI_CAP_HW_ECC_FIXUP,\n\t.oob_skip_bytes = 2,\n\t.ecc_caps = &denali_socfpga_ecc_caps,\n};\n\nNAND_ECC_CAPS_SINGLE(denali_uniphier_v5a_ecc_caps, denali_calc_ecc_bytes,\n\t\t     1024, 8, 16, 24);\nstatic const struct denali_dt_data denali_uniphier_v5a_data = {\n\t.caps = DENALI_CAP_HW_ECC_FIXUP |\n\t\tDENALI_CAP_DMA_64BIT,\n\t.oob_skip_bytes = 8,\n\t.ecc_caps = &denali_uniphier_v5a_ecc_caps,\n};\n\nNAND_ECC_CAPS_SINGLE(denali_uniphier_v5b_ecc_caps, denali_calc_ecc_bytes,\n\t\t     1024, 8, 16);\nstatic const struct denali_dt_data denali_uniphier_v5b_data = {\n\t.revision = 0x0501,\n\t.caps = DENALI_CAP_HW_ECC_FIXUP |\n\t\tDENALI_CAP_DMA_64BIT,\n\t.oob_skip_bytes = 8,\n\t.ecc_caps = &denali_uniphier_v5b_ecc_caps,\n};\n\nstatic const struct of_device_id denali_nand_dt_ids[] = {\n\t{\n\t\t.compatible = \"altr,socfpga-denali-nand\",\n\t\t.data = &denali_socfpga_data,\n\t},\n\t{\n\t\t.compatible = \"socionext,uniphier-denali-nand-v5a\",\n\t\t.data = &denali_uniphier_v5a_data,\n\t},\n\t{\n\t\t.compatible = \"socionext,uniphier-denali-nand-v5b\",\n\t\t.data = &denali_uniphier_v5b_data,\n\t},\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, denali_nand_dt_ids);\n\nstatic int denali_dt_chip_init(struct denali_controller *denali,\n\t\t\t       struct device_node *chip_np)\n{\n\tstruct denali_chip *dchip;\n\tu32 bank;\n\tint nsels, i, ret;\n\n\tnsels = of_property_count_u32_elems(chip_np, \"reg\");\n\tif (nsels < 0)\n\t\treturn nsels;\n\n\tdchip = devm_kzalloc(denali->dev, struct_size(dchip, sels, nsels),\n\t\t\t     GFP_KERNEL);\n\tif (!dchip)\n\t\treturn -ENOMEM;\n\n\tdchip->nsels = nsels;\n\n\tfor (i = 0; i < nsels; i++) {\n\t\tret = of_property_read_u32_index(chip_np, \"reg\", i, &bank);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tdchip->sels[i].bank = bank;\n\n\t\tnand_set_flash_node(&dchip->chip, chip_np);\n\t}\n\n\treturn denali_chip_init(denali, dchip);\n}\n\nstatic int denali_dt_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct denali_dt *dt;\n\tconst struct denali_dt_data *data;\n\tstruct denali_controller *denali;\n\tstruct device_node *np;\n\tint ret;\n\n\tdt = devm_kzalloc(dev, sizeof(*dt), GFP_KERNEL);\n\tif (!dt)\n\t\treturn -ENOMEM;\n\tdenali = &dt->controller;\n\n\tdata = of_device_get_match_data(dev);\n\tif (WARN_ON(!data))\n\t\treturn -EINVAL;\n\n\tdenali->revision = data->revision;\n\tdenali->caps = data->caps;\n\tdenali->oob_skip_bytes = data->oob_skip_bytes;\n\tdenali->ecc_caps = data->ecc_caps;\n\n\tdenali->dev = dev;\n\tdenali->irq = platform_get_irq(pdev, 0);\n\tif (denali->irq < 0)\n\t\treturn denali->irq;\n\n\tdenali->reg = devm_platform_ioremap_resource_byname(pdev, \"denali_reg\");\n\tif (IS_ERR(denali->reg))\n\t\treturn PTR_ERR(denali->reg);\n\n\tdenali->host = devm_platform_ioremap_resource_byname(pdev, \"nand_data\");\n\tif (IS_ERR(denali->host))\n\t\treturn PTR_ERR(denali->host);\n\n\tdt->clk = devm_clk_get(dev, \"nand\");\n\tif (IS_ERR(dt->clk))\n\t\treturn PTR_ERR(dt->clk);\n\n\tdt->clk_x = devm_clk_get(dev, \"nand_x\");\n\tif (IS_ERR(dt->clk_x))\n\t\treturn PTR_ERR(dt->clk_x);\n\n\tdt->clk_ecc = devm_clk_get(dev, \"ecc\");\n\tif (IS_ERR(dt->clk_ecc))\n\t\treturn PTR_ERR(dt->clk_ecc);\n\n\tdt->rst = devm_reset_control_get_optional_shared(dev, \"nand\");\n\tif (IS_ERR(dt->rst))\n\t\treturn PTR_ERR(dt->rst);\n\n\tdt->rst_reg = devm_reset_control_get_optional_shared(dev, \"reg\");\n\tif (IS_ERR(dt->rst_reg))\n\t\treturn PTR_ERR(dt->rst_reg);\n\n\tret = clk_prepare_enable(dt->clk);\n\tif (ret)\n\t\treturn ret;\n\n\tret = clk_prepare_enable(dt->clk_x);\n\tif (ret)\n\t\tgoto out_disable_clk;\n\n\tret = clk_prepare_enable(dt->clk_ecc);\n\tif (ret)\n\t\tgoto out_disable_clk_x;\n\n\tdenali->clk_rate = clk_get_rate(dt->clk);\n\tdenali->clk_x_rate = clk_get_rate(dt->clk_x);\n\n\t \n\tret = reset_control_deassert(dt->rst_reg);\n\tif (ret)\n\t\tgoto out_disable_clk_ecc;\n\n\tret = reset_control_deassert(dt->rst);\n\tif (ret)\n\t\tgoto out_assert_rst_reg;\n\n\t \n\tusleep_range(200, 1000);\n\n\tret = denali_init(denali);\n\tif (ret)\n\t\tgoto out_assert_rst;\n\n\tfor_each_child_of_node(dev->of_node, np) {\n\t\tret = denali_dt_chip_init(denali, np);\n\t\tif (ret) {\n\t\t\tof_node_put(np);\n\t\t\tgoto out_remove_denali;\n\t\t}\n\t}\n\n\tplatform_set_drvdata(pdev, dt);\n\n\treturn 0;\n\nout_remove_denali:\n\tdenali_remove(denali);\nout_assert_rst:\n\treset_control_assert(dt->rst);\nout_assert_rst_reg:\n\treset_control_assert(dt->rst_reg);\nout_disable_clk_ecc:\n\tclk_disable_unprepare(dt->clk_ecc);\nout_disable_clk_x:\n\tclk_disable_unprepare(dt->clk_x);\nout_disable_clk:\n\tclk_disable_unprepare(dt->clk);\n\n\treturn ret;\n}\n\nstatic void denali_dt_remove(struct platform_device *pdev)\n{\n\tstruct denali_dt *dt = platform_get_drvdata(pdev);\n\n\tdenali_remove(&dt->controller);\n\treset_control_assert(dt->rst);\n\treset_control_assert(dt->rst_reg);\n\tclk_disable_unprepare(dt->clk_ecc);\n\tclk_disable_unprepare(dt->clk_x);\n\tclk_disable_unprepare(dt->clk);\n}\n\nstatic struct platform_driver denali_dt_driver = {\n\t.probe\t\t= denali_dt_probe,\n\t.remove_new\t= denali_dt_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"denali-nand-dt\",\n\t\t.of_match_table\t= denali_nand_dt_ids,\n\t},\n};\nmodule_platform_driver(denali_dt_driver);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Jamie Iles\");\nMODULE_DESCRIPTION(\"DT driver for Denali NAND controller\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}