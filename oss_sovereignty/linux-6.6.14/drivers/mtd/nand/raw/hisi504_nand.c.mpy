{
  "module_name": "hisi504_nand.c",
  "hash_id": "a67fec2d270e86fd79f64fb4f798fbeefcfef380a7f8bc479bdd78facd0e5130",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/nand/raw/hisi504_nand.c",
  "human_readable_source": "\n \n#include <linux/of.h>\n#include <linux/mtd/mtd.h>\n#include <linux/sizes.h>\n#include <linux/clk.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/mtd/rawnand.h>\n#include <linux/dma-mapping.h>\n#include <linux/platform_device.h>\n#include <linux/mtd/partitions.h>\n\n#define HINFC504_MAX_CHIP                               (4)\n#define HINFC504_W_LATCH                                (5)\n#define HINFC504_R_LATCH                                (7)\n#define HINFC504_RW_LATCH                               (3)\n\n#define HINFC504_NFC_TIMEOUT\t\t\t\t(2 * HZ)\n#define HINFC504_NFC_PM_TIMEOUT\t\t\t\t(1 * HZ)\n#define HINFC504_NFC_DMA_TIMEOUT\t\t\t(5 * HZ)\n#define HINFC504_CHIP_DELAY\t\t\t\t(25)\n\n#define HINFC504_REG_BASE_ADDRESS_LEN\t\t\t(0x100)\n#define HINFC504_BUFFER_BASE_ADDRESS_LEN\t\t(2048 + 128)\n\n#define HINFC504_ADDR_CYCLE_MASK\t\t\t0x4\n\n#define HINFC504_CON\t\t\t\t\t0x00\n#define HINFC504_CON_OP_MODE_NORMAL\t\t\tBIT(0)\n#define HINFC504_CON_PAGEISZE_SHIFT\t\t\t(1)\n#define HINFC504_CON_PAGESIZE_MASK\t\t\t(0x07)\n#define HINFC504_CON_BUS_WIDTH\t\t\t\tBIT(4)\n#define HINFC504_CON_READY_BUSY_SEL\t\t\tBIT(8)\n#define HINFC504_CON_ECCTYPE_SHIFT\t\t\t(9)\n#define HINFC504_CON_ECCTYPE_MASK\t\t\t(0x07)\n\n#define HINFC504_PWIDTH\t\t\t\t\t0x04\n#define SET_HINFC504_PWIDTH(_w_lcnt, _r_lcnt, _rw_hcnt) \\\n\t((_w_lcnt) | (((_r_lcnt) & 0x0F) << 4) | (((_rw_hcnt) & 0x0F) << 8))\n\n#define HINFC504_CMD\t\t\t\t\t0x0C\n#define HINFC504_ADDRL\t\t\t\t\t0x10\n#define HINFC504_ADDRH\t\t\t\t\t0x14\n#define HINFC504_DATA_NUM\t\t\t\t0x18\n\n#define HINFC504_OP\t\t\t\t\t0x1C\n#define HINFC504_OP_READ_DATA_EN\t\t\tBIT(1)\n#define HINFC504_OP_WAIT_READY_EN\t\t\tBIT(2)\n#define HINFC504_OP_CMD2_EN\t\t\t\tBIT(3)\n#define HINFC504_OP_WRITE_DATA_EN\t\t\tBIT(4)\n#define HINFC504_OP_ADDR_EN\t\t\t\tBIT(5)\n#define HINFC504_OP_CMD1_EN\t\t\t\tBIT(6)\n#define HINFC504_OP_NF_CS_SHIFT                         (7)\n#define HINFC504_OP_NF_CS_MASK\t\t\t\t(3)\n#define HINFC504_OP_ADDR_CYCLE_SHIFT\t\t\t(9)\n#define HINFC504_OP_ADDR_CYCLE_MASK\t\t\t(7)\n\n#define HINFC504_STATUS                                 0x20\n#define HINFC504_READY\t\t\t\t\tBIT(0)\n\n#define HINFC504_INTEN\t\t\t\t\t0x24\n#define HINFC504_INTEN_DMA\t\t\t\tBIT(9)\n#define HINFC504_INTEN_UE\t\t\t\tBIT(6)\n#define HINFC504_INTEN_CE\t\t\t\tBIT(5)\n\n#define HINFC504_INTS\t\t\t\t\t0x28\n#define HINFC504_INTS_DMA\t\t\t\tBIT(9)\n#define HINFC504_INTS_UE\t\t\t\tBIT(6)\n#define HINFC504_INTS_CE\t\t\t\tBIT(5)\n\n#define HINFC504_INTCLR                                 0x2C\n#define HINFC504_INTCLR_DMA\t\t\t\tBIT(9)\n#define HINFC504_INTCLR_UE\t\t\t\tBIT(6)\n#define HINFC504_INTCLR_CE\t\t\t\tBIT(5)\n\n#define HINFC504_ECC_STATUS                             0x5C\n#define HINFC504_ECC_16_BIT_SHIFT                       12\n\n#define HINFC504_DMA_CTRL\t\t\t\t0x60\n#define HINFC504_DMA_CTRL_DMA_START\t\t\tBIT(0)\n#define HINFC504_DMA_CTRL_WE\t\t\t\tBIT(1)\n#define HINFC504_DMA_CTRL_DATA_AREA_EN\t\t\tBIT(2)\n#define HINFC504_DMA_CTRL_OOB_AREA_EN\t\t\tBIT(3)\n#define HINFC504_DMA_CTRL_BURST4_EN\t\t\tBIT(4)\n#define HINFC504_DMA_CTRL_BURST8_EN\t\t\tBIT(5)\n#define HINFC504_DMA_CTRL_BURST16_EN\t\t\tBIT(6)\n#define HINFC504_DMA_CTRL_ADDR_NUM_SHIFT\t\t(7)\n#define HINFC504_DMA_CTRL_ADDR_NUM_MASK                 (1)\n#define HINFC504_DMA_CTRL_CS_SHIFT\t\t\t(8)\n#define HINFC504_DMA_CTRL_CS_MASK\t\t\t(0x03)\n\n#define HINFC504_DMA_ADDR_DATA\t\t\t\t0x64\n#define HINFC504_DMA_ADDR_OOB\t\t\t\t0x68\n\n#define HINFC504_DMA_LEN\t\t\t\t0x6C\n#define HINFC504_DMA_LEN_OOB_SHIFT\t\t\t(16)\n#define HINFC504_DMA_LEN_OOB_MASK\t\t\t(0xFFF)\n\n#define HINFC504_DMA_PARA\t\t\t\t0x70\n#define HINFC504_DMA_PARA_DATA_RW_EN\t\t\tBIT(0)\n#define HINFC504_DMA_PARA_OOB_RW_EN\t\t\tBIT(1)\n#define HINFC504_DMA_PARA_DATA_EDC_EN\t\t\tBIT(2)\n#define HINFC504_DMA_PARA_OOB_EDC_EN\t\t\tBIT(3)\n#define HINFC504_DMA_PARA_DATA_ECC_EN\t\t\tBIT(4)\n#define HINFC504_DMA_PARA_OOB_ECC_EN\t\t\tBIT(5)\n\n#define HINFC_VERSION                                   0x74\n#define HINFC504_LOG_READ_ADDR\t\t\t\t0x7C\n#define HINFC504_LOG_READ_LEN\t\t\t\t0x80\n\n#define HINFC504_NANDINFO_LEN\t\t\t\t0x10\n\nstruct hinfc_host {\n\tstruct nand_chip\tchip;\n\tstruct device\t\t*dev;\n\tvoid __iomem\t\t*iobase;\n\tvoid __iomem\t\t*mmio;\n\tstruct completion       cmd_complete;\n\tunsigned int\t\toffset;\n\tunsigned int\t\tcommand;\n\tint\t\t\tchipselect;\n\tunsigned int\t\taddr_cycle;\n\tu32                     addr_value[2];\n\tu32                     cache_addr_value[2];\n\tchar\t\t\t*buffer;\n\tdma_addr_t\t\tdma_buffer;\n\tdma_addr_t\t\tdma_oob;\n\tint\t\t\tversion;\n\tunsigned int            irq_status;  \n};\n\nstatic inline unsigned int hinfc_read(struct hinfc_host *host, unsigned int reg)\n{\n\treturn readl(host->iobase + reg);\n}\n\nstatic inline void hinfc_write(struct hinfc_host *host, unsigned int value,\n\t\t\t       unsigned int reg)\n{\n\twritel(value, host->iobase + reg);\n}\n\nstatic void wait_controller_finished(struct hinfc_host *host)\n{\n\tunsigned long timeout = jiffies + HINFC504_NFC_TIMEOUT;\n\tint val;\n\n\twhile (time_before(jiffies, timeout)) {\n\t\tval = hinfc_read(host, HINFC504_STATUS);\n\t\tif (host->command == NAND_CMD_ERASE2) {\n\t\t\t \n\t\t\twhile (!(val & HINFC504_READY))\t{\n\t\t\t\tusleep_range(500, 1000);\n\t\t\t\tval = hinfc_read(host, HINFC504_STATUS);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tif (val & HINFC504_READY)\n\t\t\treturn;\n\t}\n\n\t \n\tdev_err(host->dev, \"Wait NAND controller exec cmd timeout.\\n\");\n}\n\nstatic void hisi_nfc_dma_transfer(struct hinfc_host *host, int todev)\n{\n\tstruct nand_chip *chip = &host->chip;\n\tstruct mtd_info\t*mtd = nand_to_mtd(chip);\n\tunsigned long val;\n\tint ret;\n\n\thinfc_write(host, host->dma_buffer, HINFC504_DMA_ADDR_DATA);\n\thinfc_write(host, host->dma_oob, HINFC504_DMA_ADDR_OOB);\n\n\tif (chip->ecc.engine_type == NAND_ECC_ENGINE_TYPE_NONE) {\n\t\thinfc_write(host, ((mtd->oobsize & HINFC504_DMA_LEN_OOB_MASK)\n\t\t\t<< HINFC504_DMA_LEN_OOB_SHIFT), HINFC504_DMA_LEN);\n\n\t\thinfc_write(host, HINFC504_DMA_PARA_DATA_RW_EN\n\t\t\t| HINFC504_DMA_PARA_OOB_RW_EN, HINFC504_DMA_PARA);\n\t} else {\n\t\tif (host->command == NAND_CMD_READOOB)\n\t\t\thinfc_write(host, HINFC504_DMA_PARA_OOB_RW_EN\n\t\t\t| HINFC504_DMA_PARA_OOB_EDC_EN\n\t\t\t| HINFC504_DMA_PARA_OOB_ECC_EN, HINFC504_DMA_PARA);\n\t\telse\n\t\t\thinfc_write(host, HINFC504_DMA_PARA_DATA_RW_EN\n\t\t\t| HINFC504_DMA_PARA_OOB_RW_EN\n\t\t\t| HINFC504_DMA_PARA_DATA_EDC_EN\n\t\t\t| HINFC504_DMA_PARA_OOB_EDC_EN\n\t\t\t| HINFC504_DMA_PARA_DATA_ECC_EN\n\t\t\t| HINFC504_DMA_PARA_OOB_ECC_EN, HINFC504_DMA_PARA);\n\n\t}\n\n\tval = (HINFC504_DMA_CTRL_DMA_START | HINFC504_DMA_CTRL_BURST4_EN\n\t\t| HINFC504_DMA_CTRL_BURST8_EN | HINFC504_DMA_CTRL_BURST16_EN\n\t\t| HINFC504_DMA_CTRL_DATA_AREA_EN | HINFC504_DMA_CTRL_OOB_AREA_EN\n\t\t| ((host->addr_cycle == 4 ? 1 : 0)\n\t\t\t<< HINFC504_DMA_CTRL_ADDR_NUM_SHIFT)\n\t\t| ((host->chipselect & HINFC504_DMA_CTRL_CS_MASK)\n\t\t\t<< HINFC504_DMA_CTRL_CS_SHIFT));\n\n\tif (todev)\n\t\tval |= HINFC504_DMA_CTRL_WE;\n\n\tinit_completion(&host->cmd_complete);\n\n\thinfc_write(host, val, HINFC504_DMA_CTRL);\n\tret = wait_for_completion_timeout(&host->cmd_complete,\n\t\t\tHINFC504_NFC_DMA_TIMEOUT);\n\n\tif (!ret) {\n\t\tdev_err(host->dev, \"DMA operation(irq) timeout!\\n\");\n\t\t \n\t\tval = hinfc_read(host, HINFC504_DMA_CTRL);\n\t\tif (!(val & HINFC504_DMA_CTRL_DMA_START))\n\t\t\tdev_err(host->dev, \"DMA is already done but without irq ACK!\\n\");\n\t\telse\n\t\t\tdev_err(host->dev, \"DMA is really timeout!\\n\");\n\t}\n}\n\nstatic int hisi_nfc_send_cmd_pageprog(struct hinfc_host *host)\n{\n\thost->addr_value[0] &= 0xffff0000;\n\n\thinfc_write(host, host->addr_value[0], HINFC504_ADDRL);\n\thinfc_write(host, host->addr_value[1], HINFC504_ADDRH);\n\thinfc_write(host, NAND_CMD_PAGEPROG << 8 | NAND_CMD_SEQIN,\n\t\t    HINFC504_CMD);\n\n\thisi_nfc_dma_transfer(host, 1);\n\n\treturn 0;\n}\n\nstatic int hisi_nfc_send_cmd_readstart(struct hinfc_host *host)\n{\n\tstruct mtd_info\t*mtd = nand_to_mtd(&host->chip);\n\n\tif ((host->addr_value[0] == host->cache_addr_value[0]) &&\n\t    (host->addr_value[1] == host->cache_addr_value[1]))\n\t\treturn 0;\n\n\thost->addr_value[0] &= 0xffff0000;\n\n\thinfc_write(host, host->addr_value[0], HINFC504_ADDRL);\n\thinfc_write(host, host->addr_value[1], HINFC504_ADDRH);\n\thinfc_write(host, NAND_CMD_READSTART << 8 | NAND_CMD_READ0,\n\t\t    HINFC504_CMD);\n\n\thinfc_write(host, 0, HINFC504_LOG_READ_ADDR);\n\thinfc_write(host, mtd->writesize + mtd->oobsize,\n\t\t    HINFC504_LOG_READ_LEN);\n\n\thisi_nfc_dma_transfer(host, 0);\n\n\thost->cache_addr_value[0] = host->addr_value[0];\n\thost->cache_addr_value[1] = host->addr_value[1];\n\n\treturn 0;\n}\n\nstatic int hisi_nfc_send_cmd_erase(struct hinfc_host *host)\n{\n\thinfc_write(host, host->addr_value[0], HINFC504_ADDRL);\n\thinfc_write(host, (NAND_CMD_ERASE2 << 8) | NAND_CMD_ERASE1,\n\t\t    HINFC504_CMD);\n\n\thinfc_write(host, HINFC504_OP_WAIT_READY_EN\n\t\t| HINFC504_OP_CMD2_EN\n\t\t| HINFC504_OP_CMD1_EN\n\t\t| HINFC504_OP_ADDR_EN\n\t\t| ((host->chipselect & HINFC504_OP_NF_CS_MASK)\n\t\t\t<< HINFC504_OP_NF_CS_SHIFT)\n\t\t| ((host->addr_cycle & HINFC504_OP_ADDR_CYCLE_MASK)\n\t\t\t<< HINFC504_OP_ADDR_CYCLE_SHIFT),\n\t\tHINFC504_OP);\n\n\twait_controller_finished(host);\n\n\treturn 0;\n}\n\nstatic int hisi_nfc_send_cmd_readid(struct hinfc_host *host)\n{\n\thinfc_write(host, HINFC504_NANDINFO_LEN, HINFC504_DATA_NUM);\n\thinfc_write(host, NAND_CMD_READID, HINFC504_CMD);\n\thinfc_write(host, 0, HINFC504_ADDRL);\n\n\thinfc_write(host, HINFC504_OP_CMD1_EN | HINFC504_OP_ADDR_EN\n\t\t| HINFC504_OP_READ_DATA_EN\n\t\t| ((host->chipselect & HINFC504_OP_NF_CS_MASK)\n\t\t\t<< HINFC504_OP_NF_CS_SHIFT)\n\t\t| 1 << HINFC504_OP_ADDR_CYCLE_SHIFT, HINFC504_OP);\n\n\twait_controller_finished(host);\n\n\treturn 0;\n}\n\nstatic int hisi_nfc_send_cmd_status(struct hinfc_host *host)\n{\n\thinfc_write(host, HINFC504_NANDINFO_LEN, HINFC504_DATA_NUM);\n\thinfc_write(host, NAND_CMD_STATUS, HINFC504_CMD);\n\thinfc_write(host, HINFC504_OP_CMD1_EN\n\t\t| HINFC504_OP_READ_DATA_EN\n\t\t| ((host->chipselect & HINFC504_OP_NF_CS_MASK)\n\t\t\t<< HINFC504_OP_NF_CS_SHIFT),\n\t\tHINFC504_OP);\n\n\twait_controller_finished(host);\n\n\treturn 0;\n}\n\nstatic int hisi_nfc_send_cmd_reset(struct hinfc_host *host, int chipselect)\n{\n\thinfc_write(host, NAND_CMD_RESET, HINFC504_CMD);\n\n\thinfc_write(host, HINFC504_OP_CMD1_EN\n\t\t| ((chipselect & HINFC504_OP_NF_CS_MASK)\n\t\t\t<< HINFC504_OP_NF_CS_SHIFT)\n\t\t| HINFC504_OP_WAIT_READY_EN,\n\t\tHINFC504_OP);\n\n\twait_controller_finished(host);\n\n\treturn 0;\n}\n\nstatic void hisi_nfc_select_chip(struct nand_chip *chip, int chipselect)\n{\n\tstruct hinfc_host *host = nand_get_controller_data(chip);\n\n\tif (chipselect < 0)\n\t\treturn;\n\n\thost->chipselect = chipselect;\n}\n\nstatic uint8_t hisi_nfc_read_byte(struct nand_chip *chip)\n{\n\tstruct hinfc_host *host = nand_get_controller_data(chip);\n\n\tif (host->command == NAND_CMD_STATUS)\n\t\treturn *(uint8_t *)(host->mmio);\n\n\thost->offset++;\n\n\tif (host->command == NAND_CMD_READID)\n\t\treturn *(uint8_t *)(host->mmio + host->offset - 1);\n\n\treturn *(uint8_t *)(host->buffer + host->offset - 1);\n}\n\nstatic void\nhisi_nfc_write_buf(struct nand_chip *chip, const uint8_t *buf, int len)\n{\n\tstruct hinfc_host *host = nand_get_controller_data(chip);\n\n\tmemcpy(host->buffer + host->offset, buf, len);\n\thost->offset += len;\n}\n\nstatic void hisi_nfc_read_buf(struct nand_chip *chip, uint8_t *buf, int len)\n{\n\tstruct hinfc_host *host = nand_get_controller_data(chip);\n\n\tmemcpy(buf, host->buffer + host->offset, len);\n\thost->offset += len;\n}\n\nstatic void set_addr(struct mtd_info *mtd, int column, int page_addr)\n{\n\tstruct nand_chip *chip = mtd_to_nand(mtd);\n\tstruct hinfc_host *host = nand_get_controller_data(chip);\n\tunsigned int command = host->command;\n\n\thost->addr_cycle    = 0;\n\thost->addr_value[0] = 0;\n\thost->addr_value[1] = 0;\n\n\t \n\tif (column != -1) {\n\t\t \n\t\tif (chip->options & NAND_BUSWIDTH_16 &&\n\t\t\t\t!nand_opcode_8bits(command))\n\t\t\tcolumn >>= 1;\n\n\t\thost->addr_value[0] = column & 0xffff;\n\t\thost->addr_cycle    = 2;\n\t}\n\tif (page_addr != -1) {\n\t\thost->addr_value[0] |= (page_addr & 0xffff)\n\t\t\t<< (host->addr_cycle * 8);\n\t\thost->addr_cycle    += 2;\n\t\tif (chip->options & NAND_ROW_ADDR_3) {\n\t\t\thost->addr_cycle += 1;\n\t\t\tif (host->command == NAND_CMD_ERASE1)\n\t\t\t\thost->addr_value[0] |= ((page_addr >> 16) & 0xff) << 16;\n\t\t\telse\n\t\t\t\thost->addr_value[1] |= ((page_addr >> 16) & 0xff);\n\t\t}\n\t}\n}\n\nstatic void hisi_nfc_cmdfunc(struct nand_chip *chip, unsigned command,\n\t\t\t     int column, int page_addr)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tstruct hinfc_host *host = nand_get_controller_data(chip);\n\tint is_cache_invalid = 1;\n\tunsigned int flag = 0;\n\n\thost->command =  command;\n\n\tswitch (command) {\n\tcase NAND_CMD_READ0:\n\tcase NAND_CMD_READOOB:\n\t\tif (command == NAND_CMD_READ0)\n\t\t\thost->offset = column;\n\t\telse\n\t\t\thost->offset = column + mtd->writesize;\n\n\t\tis_cache_invalid = 0;\n\t\tset_addr(mtd, column, page_addr);\n\t\thisi_nfc_send_cmd_readstart(host);\n\t\tbreak;\n\n\tcase NAND_CMD_SEQIN:\n\t\thost->offset = column;\n\t\tset_addr(mtd, column, page_addr);\n\t\tbreak;\n\n\tcase NAND_CMD_ERASE1:\n\t\tset_addr(mtd, column, page_addr);\n\t\tbreak;\n\n\tcase NAND_CMD_PAGEPROG:\n\t\thisi_nfc_send_cmd_pageprog(host);\n\t\tbreak;\n\n\tcase NAND_CMD_ERASE2:\n\t\thisi_nfc_send_cmd_erase(host);\n\t\tbreak;\n\n\tcase NAND_CMD_READID:\n\t\thost->offset = column;\n\t\tmemset(host->mmio, 0, 0x10);\n\t\thisi_nfc_send_cmd_readid(host);\n\t\tbreak;\n\n\tcase NAND_CMD_STATUS:\n\t\tflag = hinfc_read(host, HINFC504_CON);\n\t\tif (chip->ecc.engine_type == NAND_ECC_ENGINE_TYPE_ON_HOST)\n\t\t\thinfc_write(host,\n\t\t\t\t    flag & ~(HINFC504_CON_ECCTYPE_MASK <<\n\t\t\t\t    HINFC504_CON_ECCTYPE_SHIFT), HINFC504_CON);\n\n\t\thost->offset = 0;\n\t\tmemset(host->mmio, 0, 0x10);\n\t\thisi_nfc_send_cmd_status(host);\n\t\thinfc_write(host, flag, HINFC504_CON);\n\t\tbreak;\n\n\tcase NAND_CMD_RESET:\n\t\thisi_nfc_send_cmd_reset(host, host->chipselect);\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(host->dev, \"Error: unsupported cmd(cmd=%x, col=%x, page=%x)\\n\",\n\t\t\tcommand, column, page_addr);\n\t}\n\n\tif (is_cache_invalid) {\n\t\thost->cache_addr_value[0] = ~0;\n\t\thost->cache_addr_value[1] = ~0;\n\t}\n}\n\nstatic irqreturn_t hinfc_irq_handle(int irq, void *devid)\n{\n\tstruct hinfc_host *host = devid;\n\tunsigned int flag;\n\n\tflag = hinfc_read(host, HINFC504_INTS);\n\t \n\thost->irq_status |= flag;\n\n\tif (flag & HINFC504_INTS_DMA) {\n\t\thinfc_write(host, HINFC504_INTCLR_DMA, HINFC504_INTCLR);\n\t\tcomplete(&host->cmd_complete);\n\t} else if (flag & HINFC504_INTS_CE) {\n\t\thinfc_write(host, HINFC504_INTCLR_CE, HINFC504_INTCLR);\n\t} else if (flag & HINFC504_INTS_UE) {\n\t\thinfc_write(host, HINFC504_INTCLR_UE, HINFC504_INTCLR);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int hisi_nand_read_page_hwecc(struct nand_chip *chip, uint8_t *buf,\n\t\t\t\t     int oob_required, int page)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tstruct hinfc_host *host = nand_get_controller_data(chip);\n\tint max_bitflips = 0, stat = 0, stat_max = 0, status_ecc;\n\tint stat_1, stat_2;\n\n\tnand_read_page_op(chip, page, 0, buf, mtd->writesize);\n\tchip->legacy.read_buf(chip, chip->oob_poi, mtd->oobsize);\n\n\t \n\tif (host->irq_status & HINFC504_INTS_UE) {\n\t\tmtd->ecc_stats.failed++;\n\t} else if (host->irq_status & HINFC504_INTS_CE) {\n\t\t \n\t\tswitch (chip->ecc.strength) {\n\t\tcase 16:\n\t\t\tstatus_ecc = hinfc_read(host, HINFC504_ECC_STATUS) >>\n\t\t\t\t\tHINFC504_ECC_16_BIT_SHIFT & 0x0fff;\n\t\t\tstat_2 = status_ecc & 0x3f;\n\t\t\tstat_1 = status_ecc >> 6 & 0x3f;\n\t\t\tstat = stat_1 + stat_2;\n\t\t\tstat_max = max_t(int, stat_1, stat_2);\n\t\t}\n\t\tmtd->ecc_stats.corrected += stat;\n\t\tmax_bitflips = max_t(int, max_bitflips, stat_max);\n\t}\n\thost->irq_status = 0;\n\n\treturn max_bitflips;\n}\n\nstatic int hisi_nand_read_oob(struct nand_chip *chip, int page)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tstruct hinfc_host *host = nand_get_controller_data(chip);\n\n\tnand_read_oob_op(chip, page, 0, chip->oob_poi, mtd->oobsize);\n\n\tif (host->irq_status & HINFC504_INTS_UE) {\n\t\thost->irq_status = 0;\n\t\treturn -EBADMSG;\n\t}\n\n\thost->irq_status = 0;\n\treturn 0;\n}\n\nstatic int hisi_nand_write_page_hwecc(struct nand_chip *chip,\n\t\t\t\t      const uint8_t *buf, int oob_required,\n\t\t\t\t      int page)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\n\tnand_prog_page_begin_op(chip, page, 0, buf, mtd->writesize);\n\tif (oob_required)\n\t\tchip->legacy.write_buf(chip, chip->oob_poi, mtd->oobsize);\n\n\treturn nand_prog_page_end_op(chip);\n}\n\nstatic void hisi_nfc_host_init(struct hinfc_host *host)\n{\n\tstruct nand_chip *chip = &host->chip;\n\tunsigned int flag = 0;\n\n\thost->version = hinfc_read(host, HINFC_VERSION);\n\thost->addr_cycle\t\t= 0;\n\thost->addr_value[0]\t\t= 0;\n\thost->addr_value[1]\t\t= 0;\n\thost->cache_addr_value[0]\t= ~0;\n\thost->cache_addr_value[1]\t= ~0;\n\thost->chipselect\t\t= 0;\n\n\t \n\tflag = HINFC504_CON_OP_MODE_NORMAL | HINFC504_CON_READY_BUSY_SEL\n\t\t| ((0x001 & HINFC504_CON_PAGESIZE_MASK)\n\t\t\t<< HINFC504_CON_PAGEISZE_SHIFT)\n\t\t| ((0x0 & HINFC504_CON_ECCTYPE_MASK)\n\t\t\t<< HINFC504_CON_ECCTYPE_SHIFT)\n\t\t| ((chip->options & NAND_BUSWIDTH_16) ?\n\t\t\tHINFC504_CON_BUS_WIDTH : 0);\n\thinfc_write(host, flag, HINFC504_CON);\n\n\tmemset(host->mmio, 0xff, HINFC504_BUFFER_BASE_ADDRESS_LEN);\n\n\thinfc_write(host, SET_HINFC504_PWIDTH(HINFC504_W_LATCH,\n\t\t    HINFC504_R_LATCH, HINFC504_RW_LATCH), HINFC504_PWIDTH);\n\n\t \n\thinfc_write(host, HINFC504_INTEN_DMA, HINFC504_INTEN);\n}\n\nstatic int hisi_ooblayout_ecc(struct mtd_info *mtd, int section,\n\t\t\t      struct mtd_oob_region *oobregion)\n{\n\t \n\treturn -ENOTSUPP;\n}\n\nstatic int hisi_ooblayout_free(struct mtd_info *mtd, int section,\n\t\t\t       struct mtd_oob_region *oobregion)\n{\n\tif (section)\n\t\treturn -ERANGE;\n\n\toobregion->offset = 2;\n\toobregion->length = 6;\n\n\treturn 0;\n}\n\nstatic const struct mtd_ooblayout_ops hisi_ooblayout_ops = {\n\t.ecc = hisi_ooblayout_ecc,\n\t.free = hisi_ooblayout_free,\n};\n\nstatic int hisi_nfc_ecc_probe(struct hinfc_host *host)\n{\n\tunsigned int flag;\n\tint size, strength, ecc_bits;\n\tstruct device *dev = host->dev;\n\tstruct nand_chip *chip = &host->chip;\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\n\tsize = chip->ecc.size;\n\tstrength = chip->ecc.strength;\n\tif (size != 1024) {\n\t\tdev_err(dev, \"error ecc size: %d\\n\", size);\n\t\treturn -EINVAL;\n\t}\n\n\tif ((size == 1024) && ((strength != 8) && (strength != 16) &&\n\t\t\t\t(strength != 24) && (strength != 40))) {\n\t\tdev_err(dev, \"ecc size and strength do not match\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tchip->ecc.size = size;\n\tchip->ecc.strength = strength;\n\n\tchip->ecc.read_page = hisi_nand_read_page_hwecc;\n\tchip->ecc.read_oob = hisi_nand_read_oob;\n\tchip->ecc.write_page = hisi_nand_write_page_hwecc;\n\n\tswitch (chip->ecc.strength) {\n\tcase 16:\n\t\tecc_bits = 6;\n\t\tif (mtd->writesize == 2048)\n\t\t\tmtd_set_ooblayout(mtd, &hisi_ooblayout_ops);\n\n\t\t \n\t\tbreak;\n\n\t \n\tdefault:\n\t\tdev_err(dev, \"not support strength: %d\\n\", chip->ecc.strength);\n\t\treturn -EINVAL;\n\t}\n\n\tflag = hinfc_read(host, HINFC504_CON);\n\t \n\tflag |= ((ecc_bits & HINFC504_CON_ECCTYPE_MASK)\n\t\t\t\t\t\t<< HINFC504_CON_ECCTYPE_SHIFT);\n\thinfc_write(host, flag, HINFC504_CON);\n\n\t \n\tflag = hinfc_read(host, HINFC504_INTEN) & 0xfff;\n\thinfc_write(host, flag | HINFC504_INTEN_UE | HINFC504_INTEN_CE,\n\t\t    HINFC504_INTEN);\n\n\treturn 0;\n}\n\nstatic int hisi_nfc_attach_chip(struct nand_chip *chip)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tstruct hinfc_host *host = nand_get_controller_data(chip);\n\tint flag;\n\n\thost->buffer = dmam_alloc_coherent(host->dev,\n\t\t\t\t\t   mtd->writesize + mtd->oobsize,\n\t\t\t\t\t   &host->dma_buffer, GFP_KERNEL);\n\tif (!host->buffer)\n\t\treturn -ENOMEM;\n\n\thost->dma_oob = host->dma_buffer + mtd->writesize;\n\tmemset(host->buffer, 0xff, mtd->writesize + mtd->oobsize);\n\n\tflag = hinfc_read(host, HINFC504_CON);\n\tflag &= ~(HINFC504_CON_PAGESIZE_MASK << HINFC504_CON_PAGEISZE_SHIFT);\n\tswitch (mtd->writesize) {\n\tcase 2048:\n\t\tflag |= (0x001 << HINFC504_CON_PAGEISZE_SHIFT);\n\t\tbreak;\n\t \n\tdefault:\n\t\tdev_err(host->dev, \"NON-2KB page size nand flash\\n\");\n\t\treturn -EINVAL;\n\t}\n\thinfc_write(host, flag, HINFC504_CON);\n\n\tif (chip->ecc.engine_type == NAND_ECC_ENGINE_TYPE_ON_HOST)\n\t\thisi_nfc_ecc_probe(host);\n\n\treturn 0;\n}\n\nstatic const struct nand_controller_ops hisi_nfc_controller_ops = {\n\t.attach_chip = hisi_nfc_attach_chip,\n};\n\nstatic int hisi_nfc_probe(struct platform_device *pdev)\n{\n\tint ret = 0, irq, max_chips = HINFC504_MAX_CHIP;\n\tstruct device *dev = &pdev->dev;\n\tstruct hinfc_host *host;\n\tstruct nand_chip  *chip;\n\tstruct mtd_info   *mtd;\n\tstruct device_node *np = dev->of_node;\n\n\thost = devm_kzalloc(dev, sizeof(*host), GFP_KERNEL);\n\tif (!host)\n\t\treturn -ENOMEM;\n\thost->dev = dev;\n\n\tplatform_set_drvdata(pdev, host);\n\tchip = &host->chip;\n\tmtd  = nand_to_mtd(chip);\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn -ENXIO;\n\n\thost->iobase = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(host->iobase))\n\t\treturn PTR_ERR(host->iobase);\n\n\thost->mmio = devm_platform_ioremap_resource(pdev, 1);\n\tif (IS_ERR(host->mmio))\n\t\treturn PTR_ERR(host->mmio);\n\n\tmtd->name\t\t= \"hisi_nand\";\n\tmtd->dev.parent         = &pdev->dev;\n\n\tnand_set_controller_data(chip, host);\n\tnand_set_flash_node(chip, np);\n\tchip->legacy.cmdfunc\t= hisi_nfc_cmdfunc;\n\tchip->legacy.select_chip\t= hisi_nfc_select_chip;\n\tchip->legacy.read_byte\t= hisi_nfc_read_byte;\n\tchip->legacy.write_buf\t= hisi_nfc_write_buf;\n\tchip->legacy.read_buf\t= hisi_nfc_read_buf;\n\tchip->legacy.chip_delay\t= HINFC504_CHIP_DELAY;\n\tchip->legacy.set_features\t= nand_get_set_features_notsupp;\n\tchip->legacy.get_features\t= nand_get_set_features_notsupp;\n\n\thisi_nfc_host_init(host);\n\n\tret = devm_request_irq(dev, irq, hinfc_irq_handle, 0x0, \"nandc\", host);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to request IRQ\\n\");\n\t\treturn ret;\n\t}\n\n\tchip->legacy.dummy_controller.ops = &hisi_nfc_controller_ops;\n\tret = nand_scan(chip, max_chips);\n\tif (ret)\n\t\treturn ret;\n\n\tret = mtd_device_register(mtd, NULL, 0);\n\tif (ret) {\n\t\tdev_err(dev, \"Err MTD partition=%d\\n\", ret);\n\t\tnand_cleanup(chip);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void hisi_nfc_remove(struct platform_device *pdev)\n{\n\tstruct hinfc_host *host = platform_get_drvdata(pdev);\n\tstruct nand_chip *chip = &host->chip;\n\tint ret;\n\n\tret = mtd_device_unregister(nand_to_mtd(chip));\n\tWARN_ON(ret);\n\tnand_cleanup(chip);\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int hisi_nfc_suspend(struct device *dev)\n{\n\tstruct hinfc_host *host = dev_get_drvdata(dev);\n\tunsigned long timeout = jiffies + HINFC504_NFC_PM_TIMEOUT;\n\n\twhile (time_before(jiffies, timeout)) {\n\t\tif (((hinfc_read(host, HINFC504_STATUS) & 0x1) == 0x0) &&\n\t\t    (hinfc_read(host, HINFC504_DMA_CTRL) &\n\t\t     HINFC504_DMA_CTRL_DMA_START)) {\n\t\t\tcond_resched();\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tdev_err(host->dev, \"nand controller suspend timeout.\\n\");\n\n\treturn -EAGAIN;\n}\n\nstatic int hisi_nfc_resume(struct device *dev)\n{\n\tint cs;\n\tstruct hinfc_host *host = dev_get_drvdata(dev);\n\tstruct nand_chip *chip = &host->chip;\n\n\tfor (cs = 0; cs < nanddev_ntargets(&chip->base); cs++)\n\t\thisi_nfc_send_cmd_reset(host, cs);\n\thinfc_write(host, SET_HINFC504_PWIDTH(HINFC504_W_LATCH,\n\t\t    HINFC504_R_LATCH, HINFC504_RW_LATCH), HINFC504_PWIDTH);\n\n\treturn 0;\n}\n#endif\nstatic SIMPLE_DEV_PM_OPS(hisi_nfc_pm_ops, hisi_nfc_suspend, hisi_nfc_resume);\n\nstatic const struct of_device_id nfc_id_table[] = {\n\t{ .compatible = \"hisilicon,504-nfc\" },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, nfc_id_table);\n\nstatic struct platform_driver hisi_nfc_driver = {\n\t.driver = {\n\t\t.name  = \"hisi_nand\",\n\t\t.of_match_table = nfc_id_table,\n\t\t.pm = &hisi_nfc_pm_ops,\n\t},\n\t.probe\t\t= hisi_nfc_probe,\n\t.remove_new\t= hisi_nfc_remove,\n};\n\nmodule_platform_driver(hisi_nfc_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Zhou Wang\");\nMODULE_AUTHOR(\"Zhiyong Cai\");\nMODULE_DESCRIPTION(\"Hisilicon Nand Flash Controller Driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}