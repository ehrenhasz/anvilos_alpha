{
  "module_name": "fsl_upm.c",
  "hash_id": "d88c7b452cf663847222fb6c7df4f15d9cd3eef934359d2319e261cb41a280b5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/nand/raw/fsl_upm.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/mtd/rawnand.h>\n#include <linux/mtd/partitions.h>\n#include <linux/mtd/mtd.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/io.h>\n#include <linux/slab.h>\n#include <asm/fsl_lbc.h>\n\nstruct fsl_upm_nand {\n\tstruct nand_controller base;\n\tstruct device *dev;\n\tstruct nand_chip chip;\n\tstruct fsl_upm upm;\n\tuint8_t upm_addr_offset;\n\tuint8_t upm_cmd_offset;\n\tvoid __iomem *io_base;\n\tstruct gpio_desc *rnb_gpio[NAND_MAX_CHIPS];\n\tuint32_t mchip_offsets[NAND_MAX_CHIPS];\n\tuint32_t mchip_count;\n\tuint32_t mchip_number;\n};\n\nstatic inline struct fsl_upm_nand *to_fsl_upm_nand(struct mtd_info *mtdinfo)\n{\n\treturn container_of(mtd_to_nand(mtdinfo), struct fsl_upm_nand,\n\t\t\t    chip);\n}\n\nstatic int fun_chip_init(struct fsl_upm_nand *fun,\n\t\t\t const struct device_node *upm_np,\n\t\t\t const struct resource *io_res)\n{\n\tstruct mtd_info *mtd = nand_to_mtd(&fun->chip);\n\tint ret;\n\tstruct device_node *flash_np;\n\n\tfun->chip.ecc.engine_type = NAND_ECC_ENGINE_TYPE_SOFT;\n\tfun->chip.ecc.algo = NAND_ECC_ALGO_HAMMING;\n\tfun->chip.controller = &fun->base;\n\tmtd->dev.parent = fun->dev;\n\n\tflash_np = of_get_next_child(upm_np, NULL);\n\tif (!flash_np)\n\t\treturn -ENODEV;\n\n\tnand_set_flash_node(&fun->chip, flash_np);\n\tmtd->name = devm_kasprintf(fun->dev, GFP_KERNEL, \"0x%llx.%pOFn\",\n\t\t\t\t   (u64)io_res->start,\n\t\t\t\t   flash_np);\n\tif (!mtd->name) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tret = nand_scan(&fun->chip, fun->mchip_count);\n\tif (ret)\n\t\tgoto err;\n\n\tret = mtd_device_register(mtd, NULL, 0);\nerr:\n\tof_node_put(flash_np);\n\treturn ret;\n}\n\nstatic int func_exec_instr(struct nand_chip *chip,\n\t\t\t   const struct nand_op_instr *instr)\n{\n\tstruct fsl_upm_nand *fun = to_fsl_upm_nand(nand_to_mtd(chip));\n\tu32 mar, reg_offs = fun->mchip_offsets[fun->mchip_number];\n\tunsigned int i;\n\tconst u8 *out;\n\tu8 *in;\n\n\tswitch (instr->type) {\n\tcase NAND_OP_CMD_INSTR:\n\t\tfsl_upm_start_pattern(&fun->upm, fun->upm_cmd_offset);\n\t\tmar = (instr->ctx.cmd.opcode << (32 - fun->upm.width)) |\n\t\t      reg_offs;\n\t\tfsl_upm_run_pattern(&fun->upm, fun->io_base + reg_offs, mar);\n\t\tfsl_upm_end_pattern(&fun->upm);\n\t\treturn 0;\n\n\tcase NAND_OP_ADDR_INSTR:\n\t\tfsl_upm_start_pattern(&fun->upm, fun->upm_addr_offset);\n\t\tfor (i = 0; i < instr->ctx.addr.naddrs; i++) {\n\t\t\tmar = (instr->ctx.addr.addrs[i] << (32 - fun->upm.width)) |\n\t\t\t      reg_offs;\n\t\t\tfsl_upm_run_pattern(&fun->upm, fun->io_base + reg_offs, mar);\n\t\t}\n\t\tfsl_upm_end_pattern(&fun->upm);\n\t\treturn 0;\n\n\tcase NAND_OP_DATA_IN_INSTR:\n\t\tin = instr->ctx.data.buf.in;\n\t\tfor (i = 0; i < instr->ctx.data.len; i++)\n\t\t\tin[i] = in_8(fun->io_base + reg_offs);\n\t\treturn 0;\n\n\tcase NAND_OP_DATA_OUT_INSTR:\n\t\tout = instr->ctx.data.buf.out;\n\t\tfor (i = 0; i < instr->ctx.data.len; i++)\n\t\t\tout_8(fun->io_base + reg_offs, out[i]);\n\t\treturn 0;\n\n\tcase NAND_OP_WAITRDY_INSTR:\n\t\tif (!fun->rnb_gpio[fun->mchip_number])\n\t\t\treturn nand_soft_waitrdy(chip, instr->ctx.waitrdy.timeout_ms);\n\n\t\treturn nand_gpio_waitrdy(chip, fun->rnb_gpio[fun->mchip_number],\n\t\t\t\t\t instr->ctx.waitrdy.timeout_ms);\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int fun_exec_op(struct nand_chip *chip, const struct nand_operation *op,\n\t\t       bool check_only)\n{\n\tstruct fsl_upm_nand *fun = to_fsl_upm_nand(nand_to_mtd(chip));\n\tunsigned int i;\n\tint ret;\n\n\tif (op->cs >= NAND_MAX_CHIPS)\n\t\treturn -EINVAL;\n\n\tif (check_only)\n\t\treturn 0;\n\n\tfun->mchip_number = op->cs;\n\n\tfor (i = 0; i < op->ninstrs; i++) {\n\t\tret = func_exec_instr(chip, &op->instrs[i]);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (op->instrs[i].delay_ns)\n\t\t\tndelay(op->instrs[i].delay_ns);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct nand_controller_ops fun_ops = {\n\t.exec_op = fun_exec_op,\n};\n\nstatic int fun_probe(struct platform_device *ofdev)\n{\n\tstruct fsl_upm_nand *fun;\n\tstruct resource *io_res;\n\tconst __be32 *prop;\n\tint ret;\n\tint size;\n\tint i;\n\n\tfun = devm_kzalloc(&ofdev->dev, sizeof(*fun), GFP_KERNEL);\n\tif (!fun)\n\t\treturn -ENOMEM;\n\n\tfun->io_base = devm_platform_get_and_ioremap_resource(ofdev, 0, &io_res);\n\tif (IS_ERR(fun->io_base))\n\t\treturn PTR_ERR(fun->io_base);\n\n\tret = fsl_upm_find(io_res->start, &fun->upm);\n\tif (ret) {\n\t\tdev_err(&ofdev->dev, \"can't find UPM\\n\");\n\t\treturn ret;\n\t}\n\n\tprop = of_get_property(ofdev->dev.of_node, \"fsl,upm-addr-offset\",\n\t\t\t       &size);\n\tif (!prop || size != sizeof(uint32_t)) {\n\t\tdev_err(&ofdev->dev, \"can't get UPM address offset\\n\");\n\t\treturn -EINVAL;\n\t}\n\tfun->upm_addr_offset = *prop;\n\n\tprop = of_get_property(ofdev->dev.of_node, \"fsl,upm-cmd-offset\", &size);\n\tif (!prop || size != sizeof(uint32_t)) {\n\t\tdev_err(&ofdev->dev, \"can't get UPM command offset\\n\");\n\t\treturn -EINVAL;\n\t}\n\tfun->upm_cmd_offset = *prop;\n\n\tprop = of_get_property(ofdev->dev.of_node,\n\t\t\t       \"fsl,upm-addr-line-cs-offsets\", &size);\n\tif (prop && (size / sizeof(uint32_t)) > 0) {\n\t\tfun->mchip_count = size / sizeof(uint32_t);\n\t\tif (fun->mchip_count >= NAND_MAX_CHIPS) {\n\t\t\tdev_err(&ofdev->dev, \"too much multiple chips\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tfor (i = 0; i < fun->mchip_count; i++)\n\t\t\tfun->mchip_offsets[i] = be32_to_cpu(prop[i]);\n\t} else {\n\t\tfun->mchip_count = 1;\n\t}\n\n\tfor (i = 0; i < fun->mchip_count; i++) {\n\t\tfun->rnb_gpio[i] = devm_gpiod_get_index_optional(&ofdev->dev,\n\t\t\t\t\t\t\t\t NULL, i,\n\t\t\t\t\t\t\t\t GPIOD_IN);\n\t\tif (IS_ERR(fun->rnb_gpio[i])) {\n\t\t\tdev_err(&ofdev->dev, \"RNB gpio #%d is invalid\\n\", i);\n\t\t\treturn PTR_ERR(fun->rnb_gpio[i]);\n\t\t}\n\t}\n\n\tnand_controller_init(&fun->base);\n\tfun->base.ops = &fun_ops;\n\tfun->dev = &ofdev->dev;\n\n\tret = fun_chip_init(fun, ofdev->dev.of_node, io_res);\n\tif (ret)\n\t\treturn ret;\n\n\tdev_set_drvdata(&ofdev->dev, fun);\n\n\treturn 0;\n}\n\nstatic void fun_remove(struct platform_device *ofdev)\n{\n\tstruct fsl_upm_nand *fun = dev_get_drvdata(&ofdev->dev);\n\tstruct nand_chip *chip = &fun->chip;\n\tstruct mtd_info *mtd = nand_to_mtd(chip);\n\tint ret;\n\n\tret = mtd_device_unregister(mtd);\n\tWARN_ON(ret);\n\tnand_cleanup(chip);\n}\n\nstatic const struct of_device_id of_fun_match[] = {\n\t{ .compatible = \"fsl,upm-nand\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, of_fun_match);\n\nstatic struct platform_driver of_fun_driver = {\n\t.driver = {\n\t\t.name = \"fsl,upm-nand\",\n\t\t.of_match_table = of_fun_match,\n\t},\n\t.probe\t\t= fun_probe,\n\t.remove_new\t= fun_remove,\n};\n\nmodule_platform_driver(of_fun_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Anton Vorontsov <avorontsov@ru.mvista.com>\");\nMODULE_DESCRIPTION(\"Driver for NAND chips working through Freescale \"\n\t\t   \"LocalBus User-Programmable Machine\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}