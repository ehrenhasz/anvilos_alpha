{
  "module_name": "cs553x_nand.c",
  "hash_id": "cf763f6386429cf184693ace7d7edcae7976903a5a72c60bd690f978a45eefae",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/nand/raw/cs553x_nand.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/mtd/mtd.h>\n#include <linux/mtd/rawnand.h>\n#include <linux/mtd/partitions.h>\n#include <linux/iopoll.h>\n\n#include <asm/msr.h>\n\n#define NR_CS553X_CONTROLLERS\t4\n\n#define MSR_DIVIL_GLD_CAP\t0x51400000\t \n#define CAP_CS5535\t\t0x2df000ULL\n#define CAP_CS5536\t\t0x5df500ULL\n\n \n#define MSR_NANDF_DATA\t\t0x5140001b\t \n#define MSR_NANDF_CTL\t\t0x5140001c\t \n#define MSR_NANDF_RSVD\t\t0x5140001d\t \n\n \n#define MSR_DIVIL_LBAR_FLSH0\t0x51400010\t \n#define MSR_DIVIL_LBAR_FLSH1\t0x51400011\t \n#define MSR_DIVIL_LBAR_FLSH2\t0x51400012\t \n#define MSR_DIVIL_LBAR_FLSH3\t0x51400013\t \n\t \n#define FLSH_LBAR_EN\t\t(1ULL<<32)\n#define FLSH_NOR_NAND\t\t(1ULL<<33)\t \n#define FLSH_MEM_IO\t\t(1ULL<<34)\t \n\t \n\t \n\n \n#define MSR_DIVIL_BALL_OPTS\t0x51400015\n#define PIN_OPT_IDE\t\t(1<<0)\t \n\n \n#define MM_NAND_DATA\t\t0x00\t \n#define MM_NAND_CTL\t\t0x800\t \n#define MM_NAND_IO\t\t0x801\t \n#define MM_NAND_STS\t\t0x810\n#define MM_NAND_ECC_LSB\t\t0x811\n#define MM_NAND_ECC_MSB\t\t0x812\n#define MM_NAND_ECC_COL\t\t0x813\n#define MM_NAND_LAC\t\t0x814\n#define MM_NAND_ECC_CTL\t\t0x815\n\n \n#define IO_NAND_DATA\t\t0x00\t \n#define IO_NAND_CTL\t\t0x04\n#define IO_NAND_IO\t\t0x05\n#define IO_NAND_STS\t\t0x06\n#define IO_NAND_ECC_CTL\t\t0x08\n#define IO_NAND_ECC_LSB\t\t0x09\n#define IO_NAND_ECC_MSB\t\t0x0a\n#define IO_NAND_ECC_COL\t\t0x0b\n#define IO_NAND_LAC\t\t0x0c\n\n#define CS_NAND_CTL_DIST_EN\t(1<<4)\t \n#define CS_NAND_CTL_RDY_INT_MASK\t(1<<3)\t \n#define CS_NAND_CTL_ALE\t\t(1<<2)\n#define CS_NAND_CTL_CLE\t\t(1<<1)\n#define CS_NAND_CTL_CE\t\t(1<<0)\t \n\n#define CS_NAND_STS_FLASH_RDY\t(1<<3)\n#define CS_NAND_CTLR_BUSY\t(1<<2)\n#define CS_NAND_CMD_COMP\t(1<<1)\n#define CS_NAND_DIST_ST\t\t(1<<0)\n\n#define CS_NAND_ECC_PARITY\t(1<<2)\n#define CS_NAND_ECC_CLRECC\t(1<<1)\n#define CS_NAND_ECC_ENECC\t(1<<0)\n\nstruct cs553x_nand_controller {\n\tstruct nand_controller base;\n\tstruct nand_chip chip;\n\tvoid __iomem *mmio;\n};\n\nstatic struct cs553x_nand_controller *\nto_cs553x(struct nand_controller *controller)\n{\n\treturn container_of(controller, struct cs553x_nand_controller, base);\n}\n\nstatic int cs553x_write_ctrl_byte(struct cs553x_nand_controller *cs553x,\n\t\t\t\t  u32 ctl, u8 data)\n{\n\tu8 status;\n\n\twriteb(ctl, cs553x->mmio + MM_NAND_CTL);\n\twriteb(data, cs553x->mmio + MM_NAND_IO);\n\treturn readb_poll_timeout_atomic(cs553x->mmio + MM_NAND_STS, status,\n\t\t\t\t\t!(status & CS_NAND_CTLR_BUSY), 1,\n\t\t\t\t\t100000);\n}\n\nstatic void cs553x_data_in(struct cs553x_nand_controller *cs553x, void *buf,\n\t\t\t   unsigned int len)\n{\n\twriteb(0, cs553x->mmio + MM_NAND_CTL);\n\twhile (unlikely(len > 0x800)) {\n\t\tmemcpy_fromio(buf, cs553x->mmio, 0x800);\n\t\tbuf += 0x800;\n\t\tlen -= 0x800;\n\t}\n\tmemcpy_fromio(buf, cs553x->mmio, len);\n}\n\nstatic void cs553x_data_out(struct cs553x_nand_controller *cs553x,\n\t\t\t    const void *buf, unsigned int len)\n{\n\twriteb(0, cs553x->mmio + MM_NAND_CTL);\n\twhile (unlikely(len > 0x800)) {\n\t\tmemcpy_toio(cs553x->mmio, buf, 0x800);\n\t\tbuf += 0x800;\n\t\tlen -= 0x800;\n\t}\n\tmemcpy_toio(cs553x->mmio, buf, len);\n}\n\nstatic int cs553x_wait_ready(struct cs553x_nand_controller *cs553x,\n\t\t\t     unsigned int timeout_ms)\n{\n\tu8 mask = CS_NAND_CTLR_BUSY | CS_NAND_STS_FLASH_RDY;\n\tu8 status;\n\n\treturn readb_poll_timeout(cs553x->mmio + MM_NAND_STS, status,\n\t\t\t\t  (status & mask) == CS_NAND_STS_FLASH_RDY, 100,\n\t\t\t\t  timeout_ms * 1000);\n}\n\nstatic int cs553x_exec_instr(struct cs553x_nand_controller *cs553x,\n\t\t\t     const struct nand_op_instr *instr)\n{\n\tunsigned int i;\n\tint ret = 0;\n\n\tswitch (instr->type) {\n\tcase NAND_OP_CMD_INSTR:\n\t\tret = cs553x_write_ctrl_byte(cs553x, CS_NAND_CTL_CLE,\n\t\t\t\t\t     instr->ctx.cmd.opcode);\n\t\tbreak;\n\n\tcase NAND_OP_ADDR_INSTR:\n\t\tfor (i = 0; i < instr->ctx.addr.naddrs; i++) {\n\t\t\tret = cs553x_write_ctrl_byte(cs553x, CS_NAND_CTL_ALE,\n\t\t\t\t\t\t     instr->ctx.addr.addrs[i]);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase NAND_OP_DATA_IN_INSTR:\n\t\tcs553x_data_in(cs553x, instr->ctx.data.buf.in,\n\t\t\t       instr->ctx.data.len);\n\t\tbreak;\n\n\tcase NAND_OP_DATA_OUT_INSTR:\n\t\tcs553x_data_out(cs553x, instr->ctx.data.buf.out,\n\t\t\t\tinstr->ctx.data.len);\n\t\tbreak;\n\n\tcase NAND_OP_WAITRDY_INSTR:\n\t\tret = cs553x_wait_ready(cs553x, instr->ctx.waitrdy.timeout_ms);\n\t\tbreak;\n\t}\n\n\tif (instr->delay_ns)\n\t\tndelay(instr->delay_ns);\n\n\treturn ret;\n}\n\nstatic int cs553x_exec_op(struct nand_chip *this,\n\t\t\t  const struct nand_operation *op,\n\t\t\t  bool check_only)\n{\n\tstruct cs553x_nand_controller *cs553x = to_cs553x(this->controller);\n\tunsigned int i;\n\tint ret;\n\n\tif (check_only)\n\t\treturn true;\n\n\t \n\twriteb(0, cs553x->mmio + MM_NAND_CTL);\n\tfor (i = 0; i < op->ninstrs; i++) {\n\t\tret = cs553x_exec_instr(cs553x, &op->instrs[i]);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\t \n\twriteb(CS_NAND_CTL_CE, cs553x->mmio + MM_NAND_CTL);\n\n\treturn ret;\n}\n\nstatic void cs_enable_hwecc(struct nand_chip *this, int mode)\n{\n\tstruct cs553x_nand_controller *cs553x = to_cs553x(this->controller);\n\n\twriteb(0x07, cs553x->mmio + MM_NAND_ECC_CTL);\n}\n\nstatic int cs_calculate_ecc(struct nand_chip *this, const u_char *dat,\n\t\t\t    u_char *ecc_code)\n{\n\tstruct cs553x_nand_controller *cs553x = to_cs553x(this->controller);\n\tuint32_t ecc;\n\n\tecc = readl(cs553x->mmio + MM_NAND_STS);\n\n\tecc_code[1] = ecc >> 8;\n\tecc_code[0] = ecc >> 16;\n\tecc_code[2] = ecc >> 24;\n\treturn 0;\n}\n\nstatic struct cs553x_nand_controller *controllers[4];\n\nstatic int cs553x_attach_chip(struct nand_chip *chip)\n{\n\tif (chip->ecc.engine_type != NAND_ECC_ENGINE_TYPE_ON_HOST)\n\t\treturn 0;\n\n\tchip->ecc.size = 256;\n\tchip->ecc.bytes = 3;\n\tchip->ecc.hwctl  = cs_enable_hwecc;\n\tchip->ecc.calculate = cs_calculate_ecc;\n\tchip->ecc.correct  = rawnand_sw_hamming_correct;\n\tchip->ecc.strength = 1;\n\n\treturn 0;\n}\n\nstatic const struct nand_controller_ops cs553x_nand_controller_ops = {\n\t.exec_op = cs553x_exec_op,\n\t.attach_chip = cs553x_attach_chip,\n};\n\nstatic int __init cs553x_init_one(int cs, int mmio, unsigned long adr)\n{\n\tstruct cs553x_nand_controller *controller;\n\tint err = 0;\n\tstruct nand_chip *this;\n\tstruct mtd_info *new_mtd;\n\n\tpr_notice(\"Probing CS553x NAND controller CS#%d at %sIO 0x%08lx\\n\",\n\t\t  cs, mmio ? \"MM\" : \"P\", adr);\n\n\tif (!mmio) {\n\t\tpr_notice(\"PIO mode not yet implemented for CS553X NAND controller\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\t \n\tcontroller = kzalloc(sizeof(*controller), GFP_KERNEL);\n\tif (!controller) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tthis = &controller->chip;\n\tnand_controller_init(&controller->base);\n\tcontroller->base.ops = &cs553x_nand_controller_ops;\n\tthis->controller = &controller->base;\n\tnew_mtd = nand_to_mtd(this);\n\n\t \n\tnew_mtd->owner = THIS_MODULE;\n\n\t \n\tcontroller->mmio = ioremap(adr, 4096);\n\tif (!controller->mmio) {\n\t\tpr_warn(\"ioremap cs553x NAND @0x%08lx failed\\n\", adr);\n\t\terr = -EIO;\n\t\tgoto out_mtd;\n\t}\n\n\t \n\tthis->bbt_options = NAND_BBT_USE_FLASH;\n\n\tnew_mtd->name = kasprintf(GFP_KERNEL, \"cs553x_nand_cs%d\", cs);\n\tif (!new_mtd->name) {\n\t\terr = -ENOMEM;\n\t\tgoto out_ior;\n\t}\n\n\t \n\terr = nand_scan(this, 1);\n\tif (err)\n\t\tgoto out_free;\n\n\tcontrollers[cs] = controller;\n\tgoto out;\n\nout_free:\n\tkfree(new_mtd->name);\nout_ior:\n\tiounmap(controller->mmio);\nout_mtd:\n\tkfree(controller);\nout:\n\treturn err;\n}\n\nstatic int is_geode(void)\n{\n\t \n\tif (boot_cpu_data.x86_vendor == X86_VENDOR_AMD &&\n\t    boot_cpu_data.x86 == 5 &&\n\t    boot_cpu_data.x86_model == 10)\n\t\treturn 1;  \n\n\tif ((boot_cpu_data.x86_vendor == X86_VENDOR_NSC ||\n\t     boot_cpu_data.x86_vendor == X86_VENDOR_CYRIX) &&\n\t    boot_cpu_data.x86 == 5 &&\n\t    boot_cpu_data.x86_model == 5)\n\t\treturn 1;  \n\n\treturn 0;\n}\n\nstatic int __init cs553x_init(void)\n{\n\tint err = -ENXIO;\n\tint i;\n\tuint64_t val;\n\n\t \n\tif (!is_geode())\n\t\treturn -ENXIO;\n\n\t \n\trdmsrl(MSR_DIVIL_GLD_CAP, val);\n\tval &= ~0xFFULL;\n\tif (val != CAP_CS5535 && val != CAP_CS5536)\n\t\treturn -ENXIO;\n\n\t \n\trdmsrl(MSR_DIVIL_BALL_OPTS, val);\n\tif (val & PIN_OPT_IDE) {\n\t\tpr_info(\"CS553x NAND controller: Flash I/O not enabled in MSR_DIVIL_BALL_OPTS.\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\tfor (i = 0; i < NR_CS553X_CONTROLLERS; i++) {\n\t\trdmsrl(MSR_DIVIL_LBAR_FLSH0 + i, val);\n\n\t\tif ((val & (FLSH_LBAR_EN|FLSH_NOR_NAND)) == (FLSH_LBAR_EN|FLSH_NOR_NAND))\n\t\t\terr = cs553x_init_one(i, !!(val & FLSH_MEM_IO), val & 0xFFFFFFFF);\n\t}\n\n\t \n\tfor (i = 0; i < NR_CS553X_CONTROLLERS; i++) {\n\t\tif (controllers[i]) {\n\t\t\t \n\t\t\tmtd_device_register(nand_to_mtd(&controllers[i]->chip),\n\t\t\t\t\t    NULL, 0);\n\t\t\terr = 0;\n\t\t}\n\t}\n\n\treturn err;\n}\n\nmodule_init(cs553x_init);\n\nstatic void __exit cs553x_cleanup(void)\n{\n\tint i;\n\n\tfor (i = 0; i < NR_CS553X_CONTROLLERS; i++) {\n\t\tstruct cs553x_nand_controller *controller = controllers[i];\n\t\tstruct nand_chip *this = &controller->chip;\n\t\tstruct mtd_info *mtd = nand_to_mtd(this);\n\t\tint ret;\n\n\t\tif (!mtd)\n\t\t\tcontinue;\n\n\t\t \n\t\tret = mtd_device_unregister(mtd);\n\t\tWARN_ON(ret);\n\t\tnand_cleanup(this);\n\t\tkfree(mtd->name);\n\t\tcontrollers[i] = NULL;\n\n\t\t \n\t\tiounmap(controller->mmio);\n\n\t\t \n\t\tkfree(controller);\n\t}\n}\n\nmodule_exit(cs553x_cleanup);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"David Woodhouse <dwmw2@infradead.org>\");\nMODULE_DESCRIPTION(\"NAND controller driver for AMD CS5535/CS5536 companion chip\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}