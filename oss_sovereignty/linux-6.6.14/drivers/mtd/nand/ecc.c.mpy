{
  "module_name": "ecc.c",
  "hash_id": "e1f7c3473083cf380c68d2ff3b13b6cf97fd94a2114804eb6569a93a8a130dc6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/nand/ecc.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/mtd/nand.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/of.h>\n#include <linux/of_platform.h>\n\nstatic LIST_HEAD(on_host_hw_engines);\nstatic DEFINE_MUTEX(on_host_hw_engines_mutex);\n\n \nint nand_ecc_init_ctx(struct nand_device *nand)\n{\n\tif (!nand->ecc.engine || !nand->ecc.engine->ops->init_ctx)\n\t\treturn 0;\n\n\treturn nand->ecc.engine->ops->init_ctx(nand);\n}\nEXPORT_SYMBOL(nand_ecc_init_ctx);\n\n \nvoid nand_ecc_cleanup_ctx(struct nand_device *nand)\n{\n\tif (nand->ecc.engine && nand->ecc.engine->ops->cleanup_ctx)\n\t\tnand->ecc.engine->ops->cleanup_ctx(nand);\n}\nEXPORT_SYMBOL(nand_ecc_cleanup_ctx);\n\n \nint nand_ecc_prepare_io_req(struct nand_device *nand,\n\t\t\t    struct nand_page_io_req *req)\n{\n\tif (!nand->ecc.engine || !nand->ecc.engine->ops->prepare_io_req)\n\t\treturn 0;\n\n\treturn nand->ecc.engine->ops->prepare_io_req(nand, req);\n}\nEXPORT_SYMBOL(nand_ecc_prepare_io_req);\n\n \nint nand_ecc_finish_io_req(struct nand_device *nand,\n\t\t\t   struct nand_page_io_req *req)\n{\n\tif (!nand->ecc.engine || !nand->ecc.engine->ops->finish_io_req)\n\t\treturn 0;\n\n\treturn nand->ecc.engine->ops->finish_io_req(nand, req);\n}\nEXPORT_SYMBOL(nand_ecc_finish_io_req);\n\n \nstatic int nand_ooblayout_ecc_sp(struct mtd_info *mtd, int section,\n\t\t\t\t struct mtd_oob_region *oobregion)\n{\n\tstruct nand_device *nand = mtd_to_nanddev(mtd);\n\tunsigned int total_ecc_bytes = nand->ecc.ctx.total;\n\n\tif (section > 1)\n\t\treturn -ERANGE;\n\n\tif (!section) {\n\t\toobregion->offset = 0;\n\t\tif (mtd->oobsize == 16)\n\t\t\toobregion->length = 4;\n\t\telse\n\t\t\toobregion->length = 3;\n\t} else {\n\t\tif (mtd->oobsize == 8)\n\t\t\treturn -ERANGE;\n\n\t\toobregion->offset = 6;\n\t\toobregion->length = total_ecc_bytes - 4;\n\t}\n\n\treturn 0;\n}\n\nstatic int nand_ooblayout_free_sp(struct mtd_info *mtd, int section,\n\t\t\t\t  struct mtd_oob_region *oobregion)\n{\n\tif (section > 1)\n\t\treturn -ERANGE;\n\n\tif (mtd->oobsize == 16) {\n\t\tif (section)\n\t\t\treturn -ERANGE;\n\n\t\toobregion->length = 8;\n\t\toobregion->offset = 8;\n\t} else {\n\t\toobregion->length = 2;\n\t\tif (!section)\n\t\t\toobregion->offset = 3;\n\t\telse\n\t\t\toobregion->offset = 6;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct mtd_ooblayout_ops nand_ooblayout_sp_ops = {\n\t.ecc = nand_ooblayout_ecc_sp,\n\t.free = nand_ooblayout_free_sp,\n};\n\nconst struct mtd_ooblayout_ops *nand_get_small_page_ooblayout(void)\n{\n\treturn &nand_ooblayout_sp_ops;\n}\nEXPORT_SYMBOL_GPL(nand_get_small_page_ooblayout);\n\nstatic int nand_ooblayout_ecc_lp(struct mtd_info *mtd, int section,\n\t\t\t\t struct mtd_oob_region *oobregion)\n{\n\tstruct nand_device *nand = mtd_to_nanddev(mtd);\n\tunsigned int total_ecc_bytes = nand->ecc.ctx.total;\n\n\tif (section || !total_ecc_bytes)\n\t\treturn -ERANGE;\n\n\toobregion->length = total_ecc_bytes;\n\toobregion->offset = mtd->oobsize - oobregion->length;\n\n\treturn 0;\n}\n\nstatic int nand_ooblayout_free_lp(struct mtd_info *mtd, int section,\n\t\t\t\t  struct mtd_oob_region *oobregion)\n{\n\tstruct nand_device *nand = mtd_to_nanddev(mtd);\n\tunsigned int total_ecc_bytes = nand->ecc.ctx.total;\n\n\tif (section)\n\t\treturn -ERANGE;\n\n\toobregion->length = mtd->oobsize - total_ecc_bytes - 2;\n\toobregion->offset = 2;\n\n\treturn 0;\n}\n\nstatic const struct mtd_ooblayout_ops nand_ooblayout_lp_ops = {\n\t.ecc = nand_ooblayout_ecc_lp,\n\t.free = nand_ooblayout_free_lp,\n};\n\nconst struct mtd_ooblayout_ops *nand_get_large_page_ooblayout(void)\n{\n\treturn &nand_ooblayout_lp_ops;\n}\nEXPORT_SYMBOL_GPL(nand_get_large_page_ooblayout);\n\n \nstatic int nand_ooblayout_ecc_lp_hamming(struct mtd_info *mtd, int section,\n\t\t\t\t\t struct mtd_oob_region *oobregion)\n{\n\tstruct nand_device *nand = mtd_to_nanddev(mtd);\n\tunsigned int total_ecc_bytes = nand->ecc.ctx.total;\n\n\tif (section)\n\t\treturn -ERANGE;\n\n\tswitch (mtd->oobsize) {\n\tcase 64:\n\t\toobregion->offset = 40;\n\t\tbreak;\n\tcase 128:\n\t\toobregion->offset = 80;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\toobregion->length = total_ecc_bytes;\n\tif (oobregion->offset + oobregion->length > mtd->oobsize)\n\t\treturn -ERANGE;\n\n\treturn 0;\n}\n\nstatic int nand_ooblayout_free_lp_hamming(struct mtd_info *mtd, int section,\n\t\t\t\t\t  struct mtd_oob_region *oobregion)\n{\n\tstruct nand_device *nand = mtd_to_nanddev(mtd);\n\tunsigned int total_ecc_bytes = nand->ecc.ctx.total;\n\tint ecc_offset = 0;\n\n\tif (section < 0 || section > 1)\n\t\treturn -ERANGE;\n\n\tswitch (mtd->oobsize) {\n\tcase 64:\n\t\tecc_offset = 40;\n\t\tbreak;\n\tcase 128:\n\t\tecc_offset = 80;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (section == 0) {\n\t\toobregion->offset = 2;\n\t\toobregion->length = ecc_offset - 2;\n\t} else {\n\t\toobregion->offset = ecc_offset + total_ecc_bytes;\n\t\toobregion->length = mtd->oobsize - oobregion->offset;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct mtd_ooblayout_ops nand_ooblayout_lp_hamming_ops = {\n\t.ecc = nand_ooblayout_ecc_lp_hamming,\n\t.free = nand_ooblayout_free_lp_hamming,\n};\n\nconst struct mtd_ooblayout_ops *nand_get_large_page_hamming_ooblayout(void)\n{\n\treturn &nand_ooblayout_lp_hamming_ops;\n}\nEXPORT_SYMBOL_GPL(nand_get_large_page_hamming_ooblayout);\n\nstatic enum nand_ecc_engine_type\nof_get_nand_ecc_engine_type(struct device_node *np)\n{\n\tstruct device_node *eng_np;\n\n\tif (of_property_read_bool(np, \"nand-no-ecc-engine\"))\n\t\treturn NAND_ECC_ENGINE_TYPE_NONE;\n\n\tif (of_property_read_bool(np, \"nand-use-soft-ecc-engine\"))\n\t\treturn NAND_ECC_ENGINE_TYPE_SOFT;\n\n\teng_np = of_parse_phandle(np, \"nand-ecc-engine\", 0);\n\tof_node_put(eng_np);\n\n\tif (eng_np) {\n\t\tif (eng_np == np)\n\t\t\treturn NAND_ECC_ENGINE_TYPE_ON_DIE;\n\t\telse\n\t\t\treturn NAND_ECC_ENGINE_TYPE_ON_HOST;\n\t}\n\n\treturn NAND_ECC_ENGINE_TYPE_INVALID;\n}\n\nstatic const char * const nand_ecc_placement[] = {\n\t[NAND_ECC_PLACEMENT_OOB] = \"oob\",\n\t[NAND_ECC_PLACEMENT_INTERLEAVED] = \"interleaved\",\n};\n\nstatic enum nand_ecc_placement of_get_nand_ecc_placement(struct device_node *np)\n{\n\tenum nand_ecc_placement placement;\n\tconst char *pm;\n\tint err;\n\n\terr = of_property_read_string(np, \"nand-ecc-placement\", &pm);\n\tif (!err) {\n\t\tfor (placement = NAND_ECC_PLACEMENT_OOB;\n\t\t     placement < ARRAY_SIZE(nand_ecc_placement); placement++) {\n\t\t\tif (!strcasecmp(pm, nand_ecc_placement[placement]))\n\t\t\t\treturn placement;\n\t\t}\n\t}\n\n\treturn NAND_ECC_PLACEMENT_UNKNOWN;\n}\n\nstatic const char * const nand_ecc_algos[] = {\n\t[NAND_ECC_ALGO_HAMMING] = \"hamming\",\n\t[NAND_ECC_ALGO_BCH] = \"bch\",\n\t[NAND_ECC_ALGO_RS] = \"rs\",\n};\n\nstatic enum nand_ecc_algo of_get_nand_ecc_algo(struct device_node *np)\n{\n\tenum nand_ecc_algo ecc_algo;\n\tconst char *pm;\n\tint err;\n\n\terr = of_property_read_string(np, \"nand-ecc-algo\", &pm);\n\tif (!err) {\n\t\tfor (ecc_algo = NAND_ECC_ALGO_HAMMING;\n\t\t     ecc_algo < ARRAY_SIZE(nand_ecc_algos);\n\t\t     ecc_algo++) {\n\t\t\tif (!strcasecmp(pm, nand_ecc_algos[ecc_algo]))\n\t\t\t\treturn ecc_algo;\n\t\t}\n\t}\n\n\treturn NAND_ECC_ALGO_UNKNOWN;\n}\n\nstatic int of_get_nand_ecc_step_size(struct device_node *np)\n{\n\tint ret;\n\tu32 val;\n\n\tret = of_property_read_u32(np, \"nand-ecc-step-size\", &val);\n\treturn ret ? ret : val;\n}\n\nstatic int of_get_nand_ecc_strength(struct device_node *np)\n{\n\tint ret;\n\tu32 val;\n\n\tret = of_property_read_u32(np, \"nand-ecc-strength\", &val);\n\treturn ret ? ret : val;\n}\n\nvoid of_get_nand_ecc_user_config(struct nand_device *nand)\n{\n\tstruct device_node *dn = nanddev_get_of_node(nand);\n\tint strength, size;\n\n\tnand->ecc.user_conf.engine_type = of_get_nand_ecc_engine_type(dn);\n\tnand->ecc.user_conf.algo = of_get_nand_ecc_algo(dn);\n\tnand->ecc.user_conf.placement = of_get_nand_ecc_placement(dn);\n\n\tstrength = of_get_nand_ecc_strength(dn);\n\tif (strength >= 0)\n\t\tnand->ecc.user_conf.strength = strength;\n\n\tsize = of_get_nand_ecc_step_size(dn);\n\tif (size >= 0)\n\t\tnand->ecc.user_conf.step_size = size;\n\n\tif (of_property_read_bool(dn, \"nand-ecc-maximize\"))\n\t\tnand->ecc.user_conf.flags |= NAND_ECC_MAXIMIZE_STRENGTH;\n}\nEXPORT_SYMBOL(of_get_nand_ecc_user_config);\n\n \nbool nand_ecc_is_strong_enough(struct nand_device *nand)\n{\n\tconst struct nand_ecc_props *reqs = nanddev_get_ecc_requirements(nand);\n\tconst struct nand_ecc_props *conf = nanddev_get_ecc_conf(nand);\n\tstruct mtd_info *mtd = nanddev_to_mtd(nand);\n\tint corr, ds_corr;\n\n\tif (conf->step_size == 0 || reqs->step_size == 0)\n\t\t \n\t\treturn true;\n\n\t \n\tcorr = (mtd->writesize * conf->strength) / conf->step_size;\n\tds_corr = (mtd->writesize * reqs->strength) / reqs->step_size;\n\n\treturn corr >= ds_corr && conf->strength >= reqs->strength;\n}\nEXPORT_SYMBOL(nand_ecc_is_strong_enough);\n\n \nint nand_ecc_init_req_tweaking(struct nand_ecc_req_tweak_ctx *ctx,\n\t\t\t       struct nand_device *nand)\n{\n\tunsigned int total_buffer_size;\n\n\tctx->nand = nand;\n\n\t \n\tif (!ctx->page_buffer_size)\n\t\tctx->page_buffer_size = nanddev_page_size(nand);\n\tif (!ctx->oob_buffer_size)\n\t\tctx->oob_buffer_size = nanddev_per_page_oobsize(nand);\n\n\ttotal_buffer_size = ctx->page_buffer_size + ctx->oob_buffer_size;\n\n\tctx->spare_databuf = kzalloc(total_buffer_size, GFP_KERNEL);\n\tif (!ctx->spare_databuf)\n\t\treturn -ENOMEM;\n\n\tctx->spare_oobbuf = ctx->spare_databuf + ctx->page_buffer_size;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(nand_ecc_init_req_tweaking);\n\nvoid nand_ecc_cleanup_req_tweaking(struct nand_ecc_req_tweak_ctx *ctx)\n{\n\tkfree(ctx->spare_databuf);\n}\nEXPORT_SYMBOL_GPL(nand_ecc_cleanup_req_tweaking);\n\n \nvoid nand_ecc_tweak_req(struct nand_ecc_req_tweak_ctx *ctx,\n\t\t\tstruct nand_page_io_req *req)\n{\n\tstruct nand_device *nand = ctx->nand;\n\tstruct nand_page_io_req *orig, *tweak;\n\n\t \n\tctx->orig_req = *req;\n\tctx->bounce_data = false;\n\tctx->bounce_oob = false;\n\torig = &ctx->orig_req;\n\ttweak = req;\n\n\t \n\tif (orig->datalen < nanddev_page_size(nand)) {\n\t\tctx->bounce_data = true;\n\t\ttweak->dataoffs = 0;\n\t\ttweak->datalen = nanddev_page_size(nand);\n\t\ttweak->databuf.in = ctx->spare_databuf;\n\t\tmemset(tweak->databuf.in, 0xFF, ctx->page_buffer_size);\n\t}\n\n\tif (orig->ooblen < nanddev_per_page_oobsize(nand)) {\n\t\tctx->bounce_oob = true;\n\t\ttweak->ooboffs = 0;\n\t\ttweak->ooblen = nanddev_per_page_oobsize(nand);\n\t\ttweak->oobbuf.in = ctx->spare_oobbuf;\n\t\tmemset(tweak->oobbuf.in, 0xFF, ctx->oob_buffer_size);\n\t}\n\n\t \n\tif (orig->type == NAND_PAGE_WRITE) {\n\t\tif (ctx->bounce_data)\n\t\t\tmemcpy((void *)tweak->databuf.out + orig->dataoffs,\n\t\t\t       orig->databuf.out, orig->datalen);\n\n\t\tif (ctx->bounce_oob)\n\t\t\tmemcpy((void *)tweak->oobbuf.out + orig->ooboffs,\n\t\t\t       orig->oobbuf.out, orig->ooblen);\n\t}\n}\nEXPORT_SYMBOL_GPL(nand_ecc_tweak_req);\n\nvoid nand_ecc_restore_req(struct nand_ecc_req_tweak_ctx *ctx,\n\t\t\t  struct nand_page_io_req *req)\n{\n\tstruct nand_page_io_req *orig, *tweak;\n\n\torig = &ctx->orig_req;\n\ttweak = req;\n\n\t \n\tif (orig->type == NAND_PAGE_READ) {\n\t\tif (ctx->bounce_data)\n\t\t\tmemcpy(orig->databuf.in,\n\t\t\t       tweak->databuf.in + orig->dataoffs,\n\t\t\t       orig->datalen);\n\n\t\tif (ctx->bounce_oob)\n\t\t\tmemcpy(orig->oobbuf.in,\n\t\t\t       tweak->oobbuf.in + orig->ooboffs,\n\t\t\t       orig->ooblen);\n\t}\n\n\t \n\t*req = *orig;\n}\nEXPORT_SYMBOL_GPL(nand_ecc_restore_req);\n\nstruct nand_ecc_engine *nand_ecc_get_sw_engine(struct nand_device *nand)\n{\n\tunsigned int algo = nand->ecc.user_conf.algo;\n\n\tif (algo == NAND_ECC_ALGO_UNKNOWN)\n\t\talgo = nand->ecc.defaults.algo;\n\n\tswitch (algo) {\n\tcase NAND_ECC_ALGO_HAMMING:\n\t\treturn nand_ecc_sw_hamming_get_engine();\n\tcase NAND_ECC_ALGO_BCH:\n\t\treturn nand_ecc_sw_bch_get_engine();\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn NULL;\n}\nEXPORT_SYMBOL(nand_ecc_get_sw_engine);\n\nstruct nand_ecc_engine *nand_ecc_get_on_die_hw_engine(struct nand_device *nand)\n{\n\treturn nand->ecc.ondie_engine;\n}\nEXPORT_SYMBOL(nand_ecc_get_on_die_hw_engine);\n\nint nand_ecc_register_on_host_hw_engine(struct nand_ecc_engine *engine)\n{\n\tstruct nand_ecc_engine *item;\n\n\tif (!engine)\n\t\treturn -EINVAL;\n\n\t \n\tlist_for_each_entry(item, &on_host_hw_engines, node)\n\t\tif (item == engine)\n\t\t\treturn 0;\n\n\tmutex_lock(&on_host_hw_engines_mutex);\n\tlist_add_tail(&engine->node, &on_host_hw_engines);\n\tmutex_unlock(&on_host_hw_engines_mutex);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(nand_ecc_register_on_host_hw_engine);\n\nint nand_ecc_unregister_on_host_hw_engine(struct nand_ecc_engine *engine)\n{\n\tif (!engine)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&on_host_hw_engines_mutex);\n\tlist_del(&engine->node);\n\tmutex_unlock(&on_host_hw_engines_mutex);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(nand_ecc_unregister_on_host_hw_engine);\n\nstatic struct nand_ecc_engine *nand_ecc_match_on_host_hw_engine(struct device *dev)\n{\n\tstruct nand_ecc_engine *item;\n\n\tlist_for_each_entry(item, &on_host_hw_engines, node)\n\t\tif (item->dev == dev)\n\t\t\treturn item;\n\n\treturn NULL;\n}\n\nstruct nand_ecc_engine *nand_ecc_get_on_host_hw_engine(struct nand_device *nand)\n{\n\tstruct nand_ecc_engine *engine = NULL;\n\tstruct device *dev = &nand->mtd.dev;\n\tstruct platform_device *pdev;\n\tstruct device_node *np;\n\n\tif (list_empty(&on_host_hw_engines))\n\t\treturn NULL;\n\n\t \n\tnp = of_parse_phandle(dev->of_node, \"nand-ecc-engine\", 0);\n\tif (np) {\n\t\tpdev = of_find_device_by_node(np);\n\t\tif (!pdev)\n\t\t\treturn ERR_PTR(-EPROBE_DEFER);\n\n\t\tengine = nand_ecc_match_on_host_hw_engine(&pdev->dev);\n\t\tplatform_device_put(pdev);\n\t\tof_node_put(np);\n\n\t\tif (!engine)\n\t\t\treturn ERR_PTR(-EPROBE_DEFER);\n\t}\n\n\tif (engine)\n\t\tget_device(engine->dev);\n\n\treturn engine;\n}\nEXPORT_SYMBOL(nand_ecc_get_on_host_hw_engine);\n\nvoid nand_ecc_put_on_host_hw_engine(struct nand_device *nand)\n{\n\tput_device(nand->ecc.engine->dev);\n}\nEXPORT_SYMBOL(nand_ecc_put_on_host_hw_engine);\n\n \nstruct device *nand_ecc_get_engine_dev(struct device *host)\n{\n\tstruct platform_device *ecc_pdev;\n\tstruct device_node *np;\n\n\t \n\tnp = of_parse_phandle(host->of_node, \"nand-ecc-engine\", 0);\n\tif (!np)\n\t\treturn host;\n\n\tecc_pdev = of_find_device_by_node(np);\n\tif (!ecc_pdev) {\n\t\tof_node_put(np);\n\t\treturn NULL;\n\t}\n\n\tplatform_device_put(ecc_pdev);\n\tof_node_put(np);\n\n\treturn &ecc_pdev->dev;\n}\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Miquel Raynal <miquel.raynal@bootlin.com>\");\nMODULE_DESCRIPTION(\"Generic ECC engine\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}