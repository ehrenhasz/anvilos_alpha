{
  "module_name": "onenand_samsung.c",
  "hash_id": "3923b2b9b8dbe5f1bcecda807426babe7f98b2c8839b9b09736899ff1443a442",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/nand/onenand/onenand_samsung.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mtd/mtd.h>\n#include <linux/mtd/onenand.h>\n#include <linux/mtd/partitions.h>\n#include <linux/dma-mapping.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n\n#include \"samsung.h\"\n\nenum soc_type {\n\tTYPE_S3C6400,\n\tTYPE_S3C6410,\n\tTYPE_S5PC110,\n};\n\n#define ONENAND_ERASE_STATUS\t\t0x00\n#define ONENAND_MULTI_ERASE_SET\t\t0x01\n#define ONENAND_ERASE_START\t\t0x03\n#define ONENAND_UNLOCK_START\t\t0x08\n#define ONENAND_UNLOCK_END\t\t0x09\n#define ONENAND_LOCK_START\t\t0x0A\n#define ONENAND_LOCK_END\t\t0x0B\n#define ONENAND_LOCK_TIGHT_START\t0x0C\n#define ONENAND_LOCK_TIGHT_END\t\t0x0D\n#define ONENAND_UNLOCK_ALL\t\t0x0E\n#define ONENAND_OTP_ACCESS\t\t0x12\n#define ONENAND_SPARE_ACCESS_ONLY\t0x13\n#define ONENAND_MAIN_ACCESS_ONLY\t0x14\n#define ONENAND_ERASE_VERIFY\t\t0x15\n#define ONENAND_MAIN_SPARE_ACCESS\t0x16\n#define ONENAND_PIPELINE_READ\t\t0x4000\n\n#define MAP_00\t\t\t\t(0x0)\n#define MAP_01\t\t\t\t(0x1)\n#define MAP_10\t\t\t\t(0x2)\n#define MAP_11\t\t\t\t(0x3)\n\n#define S3C64XX_CMD_MAP_SHIFT\t\t24\n\n#define S3C6400_FBA_SHIFT\t\t10\n#define S3C6400_FPA_SHIFT\t\t4\n#define S3C6400_FSA_SHIFT\t\t2\n\n#define S3C6410_FBA_SHIFT\t\t12\n#define S3C6410_FPA_SHIFT\t\t6\n#define S3C6410_FSA_SHIFT\t\t4\n\n \n#define S5PC110_DMA_SRC_ADDR\t\t0x400\n#define S5PC110_DMA_SRC_CFG\t\t0x404\n#define S5PC110_DMA_DST_ADDR\t\t0x408\n#define S5PC110_DMA_DST_CFG\t\t0x40C\n#define S5PC110_DMA_TRANS_SIZE\t\t0x414\n#define S5PC110_DMA_TRANS_CMD\t\t0x418\n#define S5PC110_DMA_TRANS_STATUS\t0x41C\n#define S5PC110_DMA_TRANS_DIR\t\t0x420\n#define S5PC110_INTC_DMA_CLR\t\t0x1004\n#define S5PC110_INTC_ONENAND_CLR\t0x1008\n#define S5PC110_INTC_DMA_MASK\t\t0x1024\n#define S5PC110_INTC_ONENAND_MASK\t0x1028\n#define S5PC110_INTC_DMA_PEND\t\t0x1044\n#define S5PC110_INTC_ONENAND_PEND\t0x1048\n#define S5PC110_INTC_DMA_STATUS\t\t0x1064\n#define S5PC110_INTC_ONENAND_STATUS\t0x1068\n\n#define S5PC110_INTC_DMA_TD\t\t(1 << 24)\n#define S5PC110_INTC_DMA_TE\t\t(1 << 16)\n\n#define S5PC110_DMA_CFG_SINGLE\t\t(0x0 << 16)\n#define S5PC110_DMA_CFG_4BURST\t\t(0x2 << 16)\n#define S5PC110_DMA_CFG_8BURST\t\t(0x3 << 16)\n#define S5PC110_DMA_CFG_16BURST\t\t(0x4 << 16)\n\n#define S5PC110_DMA_CFG_INC\t\t(0x0 << 8)\n#define S5PC110_DMA_CFG_CNT\t\t(0x1 << 8)\n\n#define S5PC110_DMA_CFG_8BIT\t\t(0x0 << 0)\n#define S5PC110_DMA_CFG_16BIT\t\t(0x1 << 0)\n#define S5PC110_DMA_CFG_32BIT\t\t(0x2 << 0)\n\n#define S5PC110_DMA_SRC_CFG_READ\t(S5PC110_DMA_CFG_16BURST | \\\n\t\t\t\t\tS5PC110_DMA_CFG_INC | \\\n\t\t\t\t\tS5PC110_DMA_CFG_16BIT)\n#define S5PC110_DMA_DST_CFG_READ\t(S5PC110_DMA_CFG_16BURST | \\\n\t\t\t\t\tS5PC110_DMA_CFG_INC | \\\n\t\t\t\t\tS5PC110_DMA_CFG_32BIT)\n#define S5PC110_DMA_SRC_CFG_WRITE\t(S5PC110_DMA_CFG_16BURST | \\\n\t\t\t\t\tS5PC110_DMA_CFG_INC | \\\n\t\t\t\t\tS5PC110_DMA_CFG_32BIT)\n#define S5PC110_DMA_DST_CFG_WRITE\t(S5PC110_DMA_CFG_16BURST | \\\n\t\t\t\t\tS5PC110_DMA_CFG_INC | \\\n\t\t\t\t\tS5PC110_DMA_CFG_16BIT)\n\n#define S5PC110_DMA_TRANS_CMD_TDC\t(0x1 << 18)\n#define S5PC110_DMA_TRANS_CMD_TEC\t(0x1 << 16)\n#define S5PC110_DMA_TRANS_CMD_TR\t(0x1 << 0)\n\n#define S5PC110_DMA_TRANS_STATUS_TD\t(0x1 << 18)\n#define S5PC110_DMA_TRANS_STATUS_TB\t(0x1 << 17)\n#define S5PC110_DMA_TRANS_STATUS_TE\t(0x1 << 16)\n\n#define S5PC110_DMA_DIR_READ\t\t0x0\n#define S5PC110_DMA_DIR_WRITE\t\t0x1\n\nstruct s3c_onenand {\n\tstruct mtd_info\t*mtd;\n\tstruct platform_device\t*pdev;\n\tenum soc_type\ttype;\n\tvoid __iomem\t*base;\n\tvoid __iomem\t*ahb_addr;\n\tint\t\tbootram_command;\n\tvoid\t\t*page_buf;\n\tvoid\t\t*oob_buf;\n\tunsigned int\t(*mem_addr)(int fba, int fpa, int fsa);\n\tunsigned int\t(*cmd_map)(unsigned int type, unsigned int val);\n\tvoid __iomem\t*dma_addr;\n\tunsigned long\tphys_base;\n\tstruct completion\tcomplete;\n};\n\n#define CMD_MAP_00(dev, addr)\t\t(dev->cmd_map(MAP_00, ((addr) << 1)))\n#define CMD_MAP_01(dev, mem_addr)\t(dev->cmd_map(MAP_01, (mem_addr)))\n#define CMD_MAP_10(dev, mem_addr)\t(dev->cmd_map(MAP_10, (mem_addr)))\n#define CMD_MAP_11(dev, addr)\t\t(dev->cmd_map(MAP_11, ((addr) << 2)))\n\nstatic struct s3c_onenand *onenand;\n\nstatic inline int s3c_read_reg(int offset)\n{\n\treturn readl(onenand->base + offset);\n}\n\nstatic inline void s3c_write_reg(int value, int offset)\n{\n\twritel(value, onenand->base + offset);\n}\n\nstatic inline int s3c_read_cmd(unsigned int cmd)\n{\n\treturn readl(onenand->ahb_addr + cmd);\n}\n\nstatic inline void s3c_write_cmd(int value, unsigned int cmd)\n{\n\twritel(value, onenand->ahb_addr + cmd);\n}\n\n#ifdef SAMSUNG_DEBUG\nstatic void s3c_dump_reg(void)\n{\n\tint i;\n\n\tfor (i = 0; i < 0x400; i += 0x40) {\n\t\tprintk(KERN_INFO \"0x%08X: 0x%08x 0x%08x 0x%08x 0x%08x\\n\",\n\t\t\t(unsigned int) onenand->base + i,\n\t\t\ts3c_read_reg(i), s3c_read_reg(i + 0x10),\n\t\t\ts3c_read_reg(i + 0x20), s3c_read_reg(i + 0x30));\n\t}\n}\n#endif\n\nstatic unsigned int s3c64xx_cmd_map(unsigned type, unsigned val)\n{\n\treturn (type << S3C64XX_CMD_MAP_SHIFT) | val;\n}\n\nstatic unsigned int s3c6400_mem_addr(int fba, int fpa, int fsa)\n{\n\treturn (fba << S3C6400_FBA_SHIFT) | (fpa << S3C6400_FPA_SHIFT) |\n\t\t(fsa << S3C6400_FSA_SHIFT);\n}\n\nstatic unsigned int s3c6410_mem_addr(int fba, int fpa, int fsa)\n{\n\treturn (fba << S3C6410_FBA_SHIFT) | (fpa << S3C6410_FPA_SHIFT) |\n\t\t(fsa << S3C6410_FSA_SHIFT);\n}\n\nstatic void s3c_onenand_reset(void)\n{\n\tunsigned long timeout = 0x10000;\n\tint stat;\n\n\ts3c_write_reg(ONENAND_MEM_RESET_COLD, MEM_RESET_OFFSET);\n\twhile (1 && timeout--) {\n\t\tstat = s3c_read_reg(INT_ERR_STAT_OFFSET);\n\t\tif (stat & RST_CMP)\n\t\t\tbreak;\n\t}\n\tstat = s3c_read_reg(INT_ERR_STAT_OFFSET);\n\ts3c_write_reg(stat, INT_ERR_ACK_OFFSET);\n\n\t \n\ts3c_write_reg(0x0, INT_ERR_ACK_OFFSET);\n\t \n\ts3c_write_reg(0x0, ECC_ERR_STAT_OFFSET);\n}\n\nstatic unsigned short s3c_onenand_readw(void __iomem *addr)\n{\n\tstruct onenand_chip *this = onenand->mtd->priv;\n\tstruct device *dev = &onenand->pdev->dev;\n\tint reg = addr - this->base;\n\tint word_addr = reg >> 1;\n\tint value;\n\n\t \n\tswitch (reg) {\n\tcase ONENAND_REG_MANUFACTURER_ID:\n\t\treturn s3c_read_reg(MANUFACT_ID_OFFSET);\n\tcase ONENAND_REG_DEVICE_ID:\n\t\treturn s3c_read_reg(DEVICE_ID_OFFSET);\n\tcase ONENAND_REG_VERSION_ID:\n\t\treturn s3c_read_reg(FLASH_VER_ID_OFFSET);\n\tcase ONENAND_REG_DATA_BUFFER_SIZE:\n\t\treturn s3c_read_reg(DATA_BUF_SIZE_OFFSET);\n\tcase ONENAND_REG_TECHNOLOGY:\n\t\treturn s3c_read_reg(TECH_OFFSET);\n\tcase ONENAND_REG_SYS_CFG1:\n\t\treturn s3c_read_reg(MEM_CFG_OFFSET);\n\n\t \n\tcase ONENAND_REG_CTRL_STATUS:\n\t\treturn 0;\n\n\tcase ONENAND_REG_WP_STATUS:\n\t\treturn ONENAND_WP_US;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\t \n\tif ((unsigned long)addr < ONENAND_DATARAM && onenand->bootram_command) {\n\t\tif (word_addr == 0)\n\t\t\treturn s3c_read_reg(MANUFACT_ID_OFFSET);\n\t\tif (word_addr == 1)\n\t\t\treturn s3c_read_reg(DEVICE_ID_OFFSET);\n\t\tif (word_addr == 2)\n\t\t\treturn s3c_read_reg(FLASH_VER_ID_OFFSET);\n\t}\n\n\tvalue = s3c_read_cmd(CMD_MAP_11(onenand, word_addr)) & 0xffff;\n\tdev_info(dev, \"%s: Illegal access at reg 0x%x, value 0x%x\\n\", __func__,\n\t\t word_addr, value);\n\treturn value;\n}\n\nstatic void s3c_onenand_writew(unsigned short value, void __iomem *addr)\n{\n\tstruct onenand_chip *this = onenand->mtd->priv;\n\tstruct device *dev = &onenand->pdev->dev;\n\tunsigned int reg = addr - this->base;\n\tunsigned int word_addr = reg >> 1;\n\n\t \n\tswitch (reg) {\n\tcase ONENAND_REG_SYS_CFG1:\n\t\ts3c_write_reg(value, MEM_CFG_OFFSET);\n\t\treturn;\n\n\tcase ONENAND_REG_START_ADDRESS1:\n\tcase ONENAND_REG_START_ADDRESS2:\n\t\treturn;\n\n\t \n\tcase ONENAND_REG_START_BLOCK_ADDRESS:\n\t\treturn;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\t \n\tif ((unsigned long)addr < ONENAND_DATARAM) {\n\t\tif (value == ONENAND_CMD_READID) {\n\t\t\tonenand->bootram_command = 1;\n\t\t\treturn;\n\t\t}\n\t\tif (value == ONENAND_CMD_RESET) {\n\t\t\ts3c_write_reg(ONENAND_MEM_RESET_COLD, MEM_RESET_OFFSET);\n\t\t\tonenand->bootram_command = 0;\n\t\t\treturn;\n\t\t}\n\t}\n\n\tdev_info(dev, \"%s: Illegal access at reg 0x%x, value 0x%x\\n\", __func__,\n\t\t word_addr, value);\n\n\ts3c_write_cmd(value, CMD_MAP_11(onenand, word_addr));\n}\n\nstatic int s3c_onenand_wait(struct mtd_info *mtd, int state)\n{\n\tstruct device *dev = &onenand->pdev->dev;\n\tunsigned int flags = INT_ACT;\n\tunsigned int stat, ecc;\n\tunsigned long timeout;\n\n\tswitch (state) {\n\tcase FL_READING:\n\t\tflags |= BLK_RW_CMP | LOAD_CMP;\n\t\tbreak;\n\tcase FL_WRITING:\n\t\tflags |= BLK_RW_CMP | PGM_CMP;\n\t\tbreak;\n\tcase FL_ERASING:\n\t\tflags |= BLK_RW_CMP | ERS_CMP;\n\t\tbreak;\n\tcase FL_LOCKING:\n\t\tflags |= BLK_RW_CMP;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t \n\ttimeout = jiffies + msecs_to_jiffies(20);\n\twhile (time_before(jiffies, timeout)) {\n\t\tstat = s3c_read_reg(INT_ERR_STAT_OFFSET);\n\t\tif (stat & flags)\n\t\t\tbreak;\n\n\t\tif (state != FL_READING)\n\t\t\tcond_resched();\n\t}\n\t \n\tstat = s3c_read_reg(INT_ERR_STAT_OFFSET);\n\ts3c_write_reg(stat, INT_ERR_ACK_OFFSET);\n\n\t \n\tif (stat & LOAD_CMP) {\n\t\tecc = s3c_read_reg(ECC_ERR_STAT_OFFSET);\n\t\tif (ecc & ONENAND_ECC_4BIT_UNCORRECTABLE) {\n\t\t\tdev_info(dev, \"%s: ECC error = 0x%04x\\n\", __func__,\n\t\t\t\t ecc);\n\t\t\tmtd->ecc_stats.failed++;\n\t\t\treturn -EBADMSG;\n\t\t}\n\t}\n\n\tif (stat & (LOCKED_BLK | ERS_FAIL | PGM_FAIL | LD_FAIL_ECC_ERR)) {\n\t\tdev_info(dev, \"%s: controller error = 0x%04x\\n\", __func__,\n\t\t\t stat);\n\t\tif (stat & LOCKED_BLK)\n\t\t\tdev_info(dev, \"%s: it's locked error = 0x%04x\\n\",\n\t\t\t\t __func__, stat);\n\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic int s3c_onenand_command(struct mtd_info *mtd, int cmd, loff_t addr,\n\t\t\t       size_t len)\n{\n\tstruct onenand_chip *this = mtd->priv;\n\tunsigned int *m, *s;\n\tint fba, fpa, fsa = 0;\n\tunsigned int mem_addr, cmd_map_01, cmd_map_10;\n\tint i, mcount, scount;\n\tint index;\n\n\tfba = (int) (addr >> this->erase_shift);\n\tfpa = (int) (addr >> this->page_shift);\n\tfpa &= this->page_mask;\n\n\tmem_addr = onenand->mem_addr(fba, fpa, fsa);\n\tcmd_map_01 = CMD_MAP_01(onenand, mem_addr);\n\tcmd_map_10 = CMD_MAP_10(onenand, mem_addr);\n\n\tswitch (cmd) {\n\tcase ONENAND_CMD_READ:\n\tcase ONENAND_CMD_READOOB:\n\tcase ONENAND_CMD_BUFFERRAM:\n\t\tONENAND_SET_NEXT_BUFFERRAM(this);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tindex = ONENAND_CURRENT_BUFFERRAM(this);\n\n\t \n\tm = onenand->page_buf;\n\ts = onenand->oob_buf;\n\n\tif (index) {\n\t\tm += (this->writesize >> 2);\n\t\ts += (mtd->oobsize >> 2);\n\t}\n\n\tmcount = mtd->writesize >> 2;\n\tscount = mtd->oobsize >> 2;\n\n\tswitch (cmd) {\n\tcase ONENAND_CMD_READ:\n\t\t \n\t\tfor (i = 0; i < mcount; i++)\n\t\t\t*m++ = s3c_read_cmd(cmd_map_01);\n\t\treturn 0;\n\n\tcase ONENAND_CMD_READOOB:\n\t\ts3c_write_reg(TSRF, TRANS_SPARE_OFFSET);\n\t\t \n\t\tfor (i = 0; i < mcount; i++)\n\t\t\t*m++ = s3c_read_cmd(cmd_map_01);\n\n\t\t \n\t\tfor (i = 0; i < scount; i++)\n\t\t\t*s++ = s3c_read_cmd(cmd_map_01);\n\n\t\ts3c_write_reg(0, TRANS_SPARE_OFFSET);\n\t\treturn 0;\n\n\tcase ONENAND_CMD_PROG:\n\t\t \n\t\tfor (i = 0; i < mcount; i++)\n\t\t\ts3c_write_cmd(*m++, cmd_map_01);\n\t\treturn 0;\n\n\tcase ONENAND_CMD_PROGOOB:\n\t\ts3c_write_reg(TSRF, TRANS_SPARE_OFFSET);\n\n\t\t \n\t\tfor (i = 0; i < mcount; i++)\n\t\t\ts3c_write_cmd(0xffffffff, cmd_map_01);\n\n\t\t \n\t\tfor (i = 0; i < scount; i++)\n\t\t\ts3c_write_cmd(*s++, cmd_map_01);\n\n\t\ts3c_write_reg(0, TRANS_SPARE_OFFSET);\n\t\treturn 0;\n\n\tcase ONENAND_CMD_UNLOCK_ALL:\n\t\ts3c_write_cmd(ONENAND_UNLOCK_ALL, cmd_map_10);\n\t\treturn 0;\n\n\tcase ONENAND_CMD_ERASE:\n\t\ts3c_write_cmd(ONENAND_ERASE_START, cmd_map_10);\n\t\treturn 0;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic unsigned char *s3c_get_bufferram(struct mtd_info *mtd, int area)\n{\n\tstruct onenand_chip *this = mtd->priv;\n\tint index = ONENAND_CURRENT_BUFFERRAM(this);\n\tunsigned char *p;\n\n\tif (area == ONENAND_DATARAM) {\n\t\tp = onenand->page_buf;\n\t\tif (index == 1)\n\t\t\tp += this->writesize;\n\t} else {\n\t\tp = onenand->oob_buf;\n\t\tif (index == 1)\n\t\t\tp += mtd->oobsize;\n\t}\n\n\treturn p;\n}\n\nstatic int onenand_read_bufferram(struct mtd_info *mtd, int area,\n\t\t\t\t  unsigned char *buffer, int offset,\n\t\t\t\t  size_t count)\n{\n\tunsigned char *p;\n\n\tp = s3c_get_bufferram(mtd, area);\n\tmemcpy(buffer, p + offset, count);\n\treturn 0;\n}\n\nstatic int onenand_write_bufferram(struct mtd_info *mtd, int area,\n\t\t\t\t   const unsigned char *buffer, int offset,\n\t\t\t\t   size_t count)\n{\n\tunsigned char *p;\n\n\tp = s3c_get_bufferram(mtd, area);\n\tmemcpy(p + offset, buffer, count);\n\treturn 0;\n}\n\nstatic int (*s5pc110_dma_ops)(dma_addr_t dst, dma_addr_t src, size_t count, int direction);\n\nstatic int s5pc110_dma_poll(dma_addr_t dst, dma_addr_t src, size_t count, int direction)\n{\n\tvoid __iomem *base = onenand->dma_addr;\n\tint status;\n\tunsigned long timeout;\n\n\twritel(src, base + S5PC110_DMA_SRC_ADDR);\n\twritel(dst, base + S5PC110_DMA_DST_ADDR);\n\n\tif (direction == S5PC110_DMA_DIR_READ) {\n\t\twritel(S5PC110_DMA_SRC_CFG_READ, base + S5PC110_DMA_SRC_CFG);\n\t\twritel(S5PC110_DMA_DST_CFG_READ, base + S5PC110_DMA_DST_CFG);\n\t} else {\n\t\twritel(S5PC110_DMA_SRC_CFG_WRITE, base + S5PC110_DMA_SRC_CFG);\n\t\twritel(S5PC110_DMA_DST_CFG_WRITE, base + S5PC110_DMA_DST_CFG);\n\t}\n\n\twritel(count, base + S5PC110_DMA_TRANS_SIZE);\n\twritel(direction, base + S5PC110_DMA_TRANS_DIR);\n\n\twritel(S5PC110_DMA_TRANS_CMD_TR, base + S5PC110_DMA_TRANS_CMD);\n\n\t \n\ttimeout = jiffies + msecs_to_jiffies(20);\n\n\tdo {\n\t\tstatus = readl(base + S5PC110_DMA_TRANS_STATUS);\n\t\tif (status & S5PC110_DMA_TRANS_STATUS_TE) {\n\t\t\twritel(S5PC110_DMA_TRANS_CMD_TEC,\n\t\t\t\t\tbase + S5PC110_DMA_TRANS_CMD);\n\t\t\treturn -EIO;\n\t\t}\n\t} while (!(status & S5PC110_DMA_TRANS_STATUS_TD) &&\n\t\ttime_before(jiffies, timeout));\n\n\twritel(S5PC110_DMA_TRANS_CMD_TDC, base + S5PC110_DMA_TRANS_CMD);\n\n\treturn 0;\n}\n\nstatic irqreturn_t s5pc110_onenand_irq(int irq, void *data)\n{\n\tvoid __iomem *base = onenand->dma_addr;\n\tint status, cmd = 0;\n\n\tstatus = readl(base + S5PC110_INTC_DMA_STATUS);\n\n\tif (likely(status & S5PC110_INTC_DMA_TD))\n\t\tcmd = S5PC110_DMA_TRANS_CMD_TDC;\n\n\tif (unlikely(status & S5PC110_INTC_DMA_TE))\n\t\tcmd = S5PC110_DMA_TRANS_CMD_TEC;\n\n\twritel(cmd, base + S5PC110_DMA_TRANS_CMD);\n\twritel(status, base + S5PC110_INTC_DMA_CLR);\n\n\tif (!onenand->complete.done)\n\t\tcomplete(&onenand->complete);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int s5pc110_dma_irq(dma_addr_t dst, dma_addr_t src, size_t count, int direction)\n{\n\tvoid __iomem *base = onenand->dma_addr;\n\tint status;\n\n\tstatus = readl(base + S5PC110_INTC_DMA_MASK);\n\tif (status) {\n\t\tstatus &= ~(S5PC110_INTC_DMA_TD | S5PC110_INTC_DMA_TE);\n\t\twritel(status, base + S5PC110_INTC_DMA_MASK);\n\t}\n\n\twritel(src, base + S5PC110_DMA_SRC_ADDR);\n\twritel(dst, base + S5PC110_DMA_DST_ADDR);\n\n\tif (direction == S5PC110_DMA_DIR_READ) {\n\t\twritel(S5PC110_DMA_SRC_CFG_READ, base + S5PC110_DMA_SRC_CFG);\n\t\twritel(S5PC110_DMA_DST_CFG_READ, base + S5PC110_DMA_DST_CFG);\n\t} else {\n\t\twritel(S5PC110_DMA_SRC_CFG_WRITE, base + S5PC110_DMA_SRC_CFG);\n\t\twritel(S5PC110_DMA_DST_CFG_WRITE, base + S5PC110_DMA_DST_CFG);\n\t}\n\n\twritel(count, base + S5PC110_DMA_TRANS_SIZE);\n\twritel(direction, base + S5PC110_DMA_TRANS_DIR);\n\n\twritel(S5PC110_DMA_TRANS_CMD_TR, base + S5PC110_DMA_TRANS_CMD);\n\n\twait_for_completion_timeout(&onenand->complete, msecs_to_jiffies(20));\n\n\treturn 0;\n}\n\nstatic int s5pc110_read_bufferram(struct mtd_info *mtd, int area,\n\t\tunsigned char *buffer, int offset, size_t count)\n{\n\tstruct onenand_chip *this = mtd->priv;\n\tvoid __iomem *p;\n\tvoid *buf = (void *) buffer;\n\tdma_addr_t dma_src, dma_dst;\n\tint err, ofs, page_dma = 0;\n\tstruct device *dev = &onenand->pdev->dev;\n\n\tp = this->base + area;\n\tif (ONENAND_CURRENT_BUFFERRAM(this)) {\n\t\tif (area == ONENAND_DATARAM)\n\t\t\tp += this->writesize;\n\t\telse\n\t\t\tp += mtd->oobsize;\n\t}\n\n\tif (offset & 3 || (size_t) buf & 3 ||\n\t\t!onenand->dma_addr || count != mtd->writesize)\n\t\tgoto normal;\n\n\t \n\tif (buf >= high_memory) {\n\t\tstruct page *page;\n\n\t\tif (((size_t) buf & PAGE_MASK) !=\n\t\t    ((size_t) (buf + count - 1) & PAGE_MASK))\n\t\t\tgoto normal;\n\t\tpage = vmalloc_to_page(buf);\n\t\tif (!page)\n\t\t\tgoto normal;\n\n\t\t \n\t\tofs = ((size_t) buf & ~PAGE_MASK);\n\t\tpage_dma = 1;\n\n\t\t \n\t\tdma_src = onenand->phys_base + (p - this->base);\n\t\tdma_dst = dma_map_page(dev, page, ofs, count, DMA_FROM_DEVICE);\n\t} else {\n\t\t \n\t\tdma_src = onenand->phys_base + (p - this->base);\n\t\tdma_dst = dma_map_single(dev, buf, count, DMA_FROM_DEVICE);\n\t}\n\tif (dma_mapping_error(dev, dma_dst)) {\n\t\tdev_err(dev, \"Couldn't map a %zu byte buffer for DMA\\n\", count);\n\t\tgoto normal;\n\t}\n\terr = s5pc110_dma_ops(dma_dst, dma_src,\n\t\t\tcount, S5PC110_DMA_DIR_READ);\n\n\tif (page_dma)\n\t\tdma_unmap_page(dev, dma_dst, count, DMA_FROM_DEVICE);\n\telse\n\t\tdma_unmap_single(dev, dma_dst, count, DMA_FROM_DEVICE);\n\n\tif (!err)\n\t\treturn 0;\n\nnormal:\n\tif (count != mtd->writesize) {\n\t\t \n\t\tmemcpy_fromio(this->page_buf, p, mtd->writesize);\n\t\tmemcpy(buffer, this->page_buf + offset, count);\n\t} else {\n\t\tmemcpy_fromio(buffer, p, count);\n\t}\n\n\treturn 0;\n}\n\nstatic int s5pc110_chip_probe(struct mtd_info *mtd)\n{\n\t \n\treturn 0;\n}\n\nstatic int s3c_onenand_bbt_wait(struct mtd_info *mtd, int state)\n{\n\tunsigned int flags = INT_ACT | LOAD_CMP;\n\tunsigned int stat;\n\tunsigned long timeout;\n\n\t \n\ttimeout = jiffies + msecs_to_jiffies(20);\n\twhile (time_before(jiffies, timeout)) {\n\t\tstat = s3c_read_reg(INT_ERR_STAT_OFFSET);\n\t\tif (stat & flags)\n\t\t\tbreak;\n\t}\n\t \n\tstat = s3c_read_reg(INT_ERR_STAT_OFFSET);\n\ts3c_write_reg(stat, INT_ERR_ACK_OFFSET);\n\n\tif (stat & LD_FAIL_ECC_ERR) {\n\t\ts3c_onenand_reset();\n\t\treturn ONENAND_BBT_READ_ERROR;\n\t}\n\n\tif (stat & LOAD_CMP) {\n\t\tint ecc = s3c_read_reg(ECC_ERR_STAT_OFFSET);\n\t\tif (ecc & ONENAND_ECC_4BIT_UNCORRECTABLE) {\n\t\t\ts3c_onenand_reset();\n\t\t\treturn ONENAND_BBT_READ_ERROR;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void s3c_onenand_check_lock_status(struct mtd_info *mtd)\n{\n\tstruct onenand_chip *this = mtd->priv;\n\tstruct device *dev = &onenand->pdev->dev;\n\tunsigned int block, end;\n\n\tend = this->chipsize >> this->erase_shift;\n\n\tfor (block = 0; block < end; block++) {\n\t\tunsigned int mem_addr = onenand->mem_addr(block, 0, 0);\n\t\ts3c_read_cmd(CMD_MAP_01(onenand, mem_addr));\n\n\t\tif (s3c_read_reg(INT_ERR_STAT_OFFSET) & LOCKED_BLK) {\n\t\t\tdev_err(dev, \"block %d is write-protected!\\n\", block);\n\t\t\ts3c_write_reg(LOCKED_BLK, INT_ERR_ACK_OFFSET);\n\t\t}\n\t}\n}\n\nstatic void s3c_onenand_do_lock_cmd(struct mtd_info *mtd, loff_t ofs,\n\t\t\t\t    size_t len, int cmd)\n{\n\tstruct onenand_chip *this = mtd->priv;\n\tint start, end, start_mem_addr, end_mem_addr;\n\n\tstart = ofs >> this->erase_shift;\n\tstart_mem_addr = onenand->mem_addr(start, 0, 0);\n\tend = start + (len >> this->erase_shift) - 1;\n\tend_mem_addr = onenand->mem_addr(end, 0, 0);\n\n\tif (cmd == ONENAND_CMD_LOCK) {\n\t\ts3c_write_cmd(ONENAND_LOCK_START, CMD_MAP_10(onenand,\n\t\t\t\t\t\t\t     start_mem_addr));\n\t\ts3c_write_cmd(ONENAND_LOCK_END, CMD_MAP_10(onenand,\n\t\t\t\t\t\t\t   end_mem_addr));\n\t} else {\n\t\ts3c_write_cmd(ONENAND_UNLOCK_START, CMD_MAP_10(onenand,\n\t\t\t\t\t\t\t       start_mem_addr));\n\t\ts3c_write_cmd(ONENAND_UNLOCK_END, CMD_MAP_10(onenand,\n\t\t\t\t\t\t\t     end_mem_addr));\n\t}\n\n\tthis->wait(mtd, FL_LOCKING);\n}\n\nstatic void s3c_unlock_all(struct mtd_info *mtd)\n{\n\tstruct onenand_chip *this = mtd->priv;\n\tloff_t ofs = 0;\n\tsize_t len = this->chipsize;\n\n\tif (this->options & ONENAND_HAS_UNLOCK_ALL) {\n\t\t \n\t\tthis->command(mtd, ONENAND_CMD_UNLOCK_ALL, 0, 0);\n\n\t\t \n\t\tthis->wait(mtd, FL_LOCKING);\n\n\t\t \n\t\tif (!ONENAND_IS_DDP(this)) {\n\t\t\ts3c_onenand_check_lock_status(mtd);\n\t\t\treturn;\n\t\t}\n\n\t\t \n\t\tofs = this->chipsize >> 1;\n\t\tlen = this->chipsize >> 1;\n\t}\n\n\ts3c_onenand_do_lock_cmd(mtd, ofs, len, ONENAND_CMD_UNLOCK);\n\n\ts3c_onenand_check_lock_status(mtd);\n}\n\nstatic void s3c_onenand_setup(struct mtd_info *mtd)\n{\n\tstruct onenand_chip *this = mtd->priv;\n\n\tonenand->mtd = mtd;\n\n\tif (onenand->type == TYPE_S3C6400) {\n\t\tonenand->mem_addr = s3c6400_mem_addr;\n\t\tonenand->cmd_map = s3c64xx_cmd_map;\n\t} else if (onenand->type == TYPE_S3C6410) {\n\t\tonenand->mem_addr = s3c6410_mem_addr;\n\t\tonenand->cmd_map = s3c64xx_cmd_map;\n\t} else if (onenand->type == TYPE_S5PC110) {\n\t\t \n\t\tthis->read_bufferram = s5pc110_read_bufferram;\n\t\tthis->chip_probe = s5pc110_chip_probe;\n\t\treturn;\n\t} else {\n\t\tBUG();\n\t}\n\n\tthis->read_word = s3c_onenand_readw;\n\tthis->write_word = s3c_onenand_writew;\n\n\tthis->wait = s3c_onenand_wait;\n\tthis->bbt_wait = s3c_onenand_bbt_wait;\n\tthis->unlock_all = s3c_unlock_all;\n\tthis->command = s3c_onenand_command;\n\n\tthis->read_bufferram = onenand_read_bufferram;\n\tthis->write_bufferram = onenand_write_bufferram;\n}\n\nstatic int s3c_onenand_probe(struct platform_device *pdev)\n{\n\tstruct onenand_platform_data *pdata;\n\tstruct onenand_chip *this;\n\tstruct mtd_info *mtd;\n\tstruct resource *r;\n\tint size, err;\n\n\tpdata = dev_get_platdata(&pdev->dev);\n\t \n\n\tsize = sizeof(struct mtd_info) + sizeof(struct onenand_chip);\n\tmtd = devm_kzalloc(&pdev->dev, size, GFP_KERNEL);\n\tif (!mtd)\n\t\treturn -ENOMEM;\n\n\tonenand = devm_kzalloc(&pdev->dev, sizeof(struct s3c_onenand),\n\t\t\t       GFP_KERNEL);\n\tif (!onenand)\n\t\treturn -ENOMEM;\n\n\tthis = (struct onenand_chip *) &mtd[1];\n\tmtd->priv = this;\n\tmtd->dev.parent = &pdev->dev;\n\tonenand->pdev = pdev;\n\tonenand->type = platform_get_device_id(pdev)->driver_data;\n\n\ts3c_onenand_setup(mtd);\n\n\tonenand->base = devm_platform_get_and_ioremap_resource(pdev, 0, &r);\n\tif (IS_ERR(onenand->base))\n\t\treturn PTR_ERR(onenand->base);\n\n\tonenand->phys_base = r->start;\n\n\t \n\tthis->base = onenand->base;\n\n\t \n\tthis->options |= ONENAND_SKIP_UNLOCK_CHECK;\n\n\tif (onenand->type != TYPE_S5PC110) {\n\t\tonenand->ahb_addr = devm_platform_ioremap_resource(pdev, 1);\n\t\tif (IS_ERR(onenand->ahb_addr))\n\t\t\treturn PTR_ERR(onenand->ahb_addr);\n\n\t\t \n\t\tonenand->page_buf = devm_kzalloc(&pdev->dev, SZ_4K,\n\t\t\t\t\t\t GFP_KERNEL);\n\t\tif (!onenand->page_buf)\n\t\t\treturn -ENOMEM;\n\n\t\t \n\t\tonenand->oob_buf = devm_kzalloc(&pdev->dev, 128, GFP_KERNEL);\n\t\tif (!onenand->oob_buf)\n\t\t\treturn -ENOMEM;\n\n\t\t \n\t\tmtd->subpage_sft = 0;\n\t\tthis->subpagesize = mtd->writesize;\n\n\t} else {  \n\t\tonenand->dma_addr = devm_platform_ioremap_resource(pdev, 1);\n\t\tif (IS_ERR(onenand->dma_addr))\n\t\t\treturn PTR_ERR(onenand->dma_addr);\n\n\t\ts5pc110_dma_ops = s5pc110_dma_poll;\n\t\t \n\t\tr = platform_get_resource(pdev, IORESOURCE_IRQ, 0);\n\t\tif (r) {\n\t\t\tinit_completion(&onenand->complete);\n\t\t\ts5pc110_dma_ops = s5pc110_dma_irq;\n\t\t\terr = devm_request_irq(&pdev->dev, r->start,\n\t\t\t\t\t       s5pc110_onenand_irq,\n\t\t\t\t\t       IRQF_SHARED, \"onenand\",\n\t\t\t\t\t       &onenand);\n\t\t\tif (err) {\n\t\t\t\tdev_err(&pdev->dev, \"failed to get irq\\n\");\n\t\t\t\treturn err;\n\t\t\t}\n\t\t}\n\t}\n\n\terr = onenand_scan(mtd, 1);\n\tif (err)\n\t\treturn err;\n\n\tif (onenand->type != TYPE_S5PC110) {\n\t\t \n\t\tmtd->subpage_sft = 0;\n\t\tthis->subpagesize = mtd->writesize;\n\t}\n\n\tif (s3c_read_reg(MEM_CFG_OFFSET) & ONENAND_SYS_CFG1_SYNC_READ)\n\t\tdev_info(&onenand->pdev->dev, \"OneNAND Sync. Burst Read enabled\\n\");\n\n\terr = mtd_device_register(mtd, pdata ? pdata->parts : NULL,\n\t\t\t\t  pdata ? pdata->nr_parts : 0);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"failed to parse partitions and register the MTD device\\n\");\n\t\tonenand_release(mtd);\n\t\treturn err;\n\t}\n\n\tplatform_set_drvdata(pdev, mtd);\n\n\treturn 0;\n}\n\nstatic void s3c_onenand_remove(struct platform_device *pdev)\n{\n\tstruct mtd_info *mtd = platform_get_drvdata(pdev);\n\n\tonenand_release(mtd);\n}\n\nstatic int s3c_pm_ops_suspend(struct device *dev)\n{\n\tstruct mtd_info *mtd = dev_get_drvdata(dev);\n\tstruct onenand_chip *this = mtd->priv;\n\n\tthis->wait(mtd, FL_PM_SUSPENDED);\n\treturn 0;\n}\n\nstatic  int s3c_pm_ops_resume(struct device *dev)\n{\n\tstruct mtd_info *mtd = dev_get_drvdata(dev);\n\tstruct onenand_chip *this = mtd->priv;\n\n\tthis->unlock_all(mtd);\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops s3c_pm_ops = {\n\t.suspend\t= s3c_pm_ops_suspend,\n\t.resume\t\t= s3c_pm_ops_resume,\n};\n\nstatic const struct platform_device_id s3c_onenand_driver_ids[] = {\n\t{\n\t\t.name\t\t= \"s3c6400-onenand\",\n\t\t.driver_data\t= TYPE_S3C6400,\n\t}, {\n\t\t.name\t\t= \"s3c6410-onenand\",\n\t\t.driver_data\t= TYPE_S3C6410,\n\t}, {\n\t\t.name\t\t= \"s5pc110-onenand\",\n\t\t.driver_data\t= TYPE_S5PC110,\n\t}, { },\n};\nMODULE_DEVICE_TABLE(platform, s3c_onenand_driver_ids);\n\nstatic struct platform_driver s3c_onenand_driver = {\n\t.driver         = {\n\t\t.name\t= \"samsung-onenand\",\n\t\t.pm\t= &s3c_pm_ops,\n\t},\n\t.id_table\t= s3c_onenand_driver_ids,\n\t.probe          = s3c_onenand_probe,\n\t.remove_new     = s3c_onenand_remove,\n};\n\nmodule_platform_driver(s3c_onenand_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Kyungmin Park <kyungmin.park@samsung.com>\");\nMODULE_DESCRIPTION(\"Samsung OneNAND controller support\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}