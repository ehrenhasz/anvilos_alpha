{
  "module_name": "onenand_base.c",
  "hash_id": "401ba5d36ccc9e99c260f524ec6d7fb3cee942b8f4ef8d21ccaf19b436bb9855",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/nand/onenand/onenand_base.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/jiffies.h>\n#include <linux/mtd/mtd.h>\n#include <linux/mtd/onenand.h>\n#include <linux/mtd/partitions.h>\n\n#include <asm/io.h>\n\n \n#define MB_ERASE_MIN_BLK_COUNT 2\n#define MB_ERASE_MAX_BLK_COUNT 64\n\n \nstatic int flex_bdry[MAX_DIES * 2] = { -1, 0, -1, 0 };\n\nmodule_param_array(flex_bdry, int, NULL, 0400);\nMODULE_PARM_DESC(flex_bdry,\t\"SLC Boundary information for Flex-OneNAND\"\n\t\t\t\t\"Syntax:flex_bdry=DIE_BDRY,LOCK,...\"\n\t\t\t\t\"DIE_BDRY: SLC boundary of the die\"\n\t\t\t\t\"LOCK: Locking information for SLC boundary\"\n\t\t\t\t\"    : 0->Set boundary in unlocked status\"\n\t\t\t\t\"    : 1->Set boundary in locked status\");\n\n \nstatic int otp;\n\nmodule_param(otp, int, 0400);\nMODULE_PARM_DESC(otp,\t\"Corresponding behaviour of OneNAND in OTP\"\n\t\t\t\"Syntax : otp=LOCK_TYPE\"\n\t\t\t\"LOCK_TYPE : Keys issued, for specific OTP Lock type\"\n\t\t\t\"\t   : 0 -> Default (No Blocks Locked)\"\n\t\t\t\"\t   : 1 -> OTP Block lock\"\n\t\t\t\"\t   : 2 -> 1st Block lock\"\n\t\t\t\"\t   : 3 -> BOTH OTP Block and 1st Block lock\");\n\n \nstatic int flexonenand_ooblayout_ecc(struct mtd_info *mtd, int section,\n\t\t\t\t     struct mtd_oob_region *oobregion)\n{\n\tif (section > 7)\n\t\treturn -ERANGE;\n\n\toobregion->offset = (section * 16) + 6;\n\toobregion->length = 10;\n\n\treturn 0;\n}\n\nstatic int flexonenand_ooblayout_free(struct mtd_info *mtd, int section,\n\t\t\t\t      struct mtd_oob_region *oobregion)\n{\n\tif (section > 7)\n\t\treturn -ERANGE;\n\n\toobregion->offset = (section * 16) + 2;\n\toobregion->length = 4;\n\n\treturn 0;\n}\n\nstatic const struct mtd_ooblayout_ops flexonenand_ooblayout_ops = {\n\t.ecc = flexonenand_ooblayout_ecc,\n\t.free = flexonenand_ooblayout_free,\n};\n\n \nstatic int onenand_ooblayout_128_ecc(struct mtd_info *mtd, int section,\n\t\t\t\t     struct mtd_oob_region *oobregion)\n{\n\tif (section > 7)\n\t\treturn -ERANGE;\n\n\toobregion->offset = (section * 16) + 7;\n\toobregion->length = 9;\n\n\treturn 0;\n}\n\nstatic int onenand_ooblayout_128_free(struct mtd_info *mtd, int section,\n\t\t\t\t      struct mtd_oob_region *oobregion)\n{\n\tif (section >= 8)\n\t\treturn -ERANGE;\n\n\t \n\toobregion->offset = (section * 16) + 2;\n\toobregion->length = 3;\n\n\treturn 0;\n}\n\nstatic const struct mtd_ooblayout_ops onenand_oob_128_ooblayout_ops = {\n\t.ecc = onenand_ooblayout_128_ecc,\n\t.free = onenand_ooblayout_128_free,\n};\n\n \nstatic int onenand_ooblayout_32_64_ecc(struct mtd_info *mtd, int section,\n\t\t\t\t       struct mtd_oob_region *oobregion)\n{\n\tif (section > 3)\n\t\treturn -ERANGE;\n\n\toobregion->offset = (section * 16) + 8;\n\toobregion->length = 5;\n\n\treturn 0;\n}\n\nstatic int onenand_ooblayout_32_64_free(struct mtd_info *mtd, int section,\n\t\t\t\t\tstruct mtd_oob_region *oobregion)\n{\n\tint sections = (mtd->oobsize / 32) * 2;\n\n\tif (section >= sections)\n\t\treturn -ERANGE;\n\n\tif (section & 1) {\n\t\toobregion->offset = ((section - 1) * 16) + 14;\n\t\toobregion->length = 2;\n\t} else  {\n\t\toobregion->offset = (section * 16) + 2;\n\t\toobregion->length = 3;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct mtd_ooblayout_ops onenand_oob_32_64_ooblayout_ops = {\n\t.ecc = onenand_ooblayout_32_64_ecc,\n\t.free = onenand_ooblayout_32_64_free,\n};\n\nstatic const unsigned char ffchars[] = {\n\t0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\t \n\t0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\t \n\t0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\t \n\t0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\t \n\t0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\t \n\t0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\t \n\t0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\t \n\t0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\t \n};\n\n \nstatic unsigned short onenand_readw(void __iomem *addr)\n{\n\treturn readw(addr);\n}\n\n \nstatic void onenand_writew(unsigned short value, void __iomem *addr)\n{\n\twritew(value, addr);\n}\n\n \nstatic int onenand_block_address(struct onenand_chip *this, int block)\n{\n\t \n\tif (block & this->density_mask)\n\t\treturn ONENAND_DDP_CHIP1 | (block ^ this->density_mask);\n\n\treturn block;\n}\n\n \nstatic int onenand_bufferram_address(struct onenand_chip *this, int block)\n{\n\t \n\tif (block & this->density_mask)\n\t\treturn ONENAND_DDP_CHIP1;\n\n\treturn ONENAND_DDP_CHIP0;\n}\n\n \nstatic int onenand_page_address(int page, int sector)\n{\n\t \n\tint fpa, fsa;\n\n\tfpa = page & ONENAND_FPA_MASK;\n\tfsa = sector & ONENAND_FSA_MASK;\n\n\treturn ((fpa << ONENAND_FPA_SHIFT) | fsa);\n}\n\n \nstatic int onenand_buffer_address(int dataram1, int sectors, int count)\n{\n\tint bsa, bsc;\n\n\t \n\tbsa = sectors & ONENAND_BSA_MASK;\n\n\tif (dataram1)\n\t\tbsa |= ONENAND_BSA_DATARAM1;\t \n\telse\n\t\tbsa |= ONENAND_BSA_DATARAM0;\t \n\n\t \n\tbsc = count & ONENAND_BSC_MASK;\n\n\treturn ((bsa << ONENAND_BSA_SHIFT) | bsc);\n}\n\n \nstatic unsigned flexonenand_block(struct onenand_chip *this, loff_t addr)\n{\n\tunsigned boundary, blk, die = 0;\n\n\tif (ONENAND_IS_DDP(this) && addr >= this->diesize[0]) {\n\t\tdie = 1;\n\t\taddr -= this->diesize[0];\n\t}\n\n\tboundary = this->boundary[die];\n\n\tblk = addr >> (this->erase_shift - 1);\n\tif (blk > boundary)\n\t\tblk = (blk + boundary + 1) >> 1;\n\n\tblk += die ? this->density_mask : 0;\n\treturn blk;\n}\n\ninline unsigned onenand_block(struct onenand_chip *this, loff_t addr)\n{\n\tif (!FLEXONENAND(this))\n\t\treturn addr >> this->erase_shift;\n\treturn flexonenand_block(this, addr);\n}\n\n \nstatic loff_t flexonenand_addr(struct onenand_chip *this, int block)\n{\n\tloff_t ofs = 0;\n\tint die = 0, boundary;\n\n\tif (ONENAND_IS_DDP(this) && block >= this->density_mask) {\n\t\tblock -= this->density_mask;\n\t\tdie = 1;\n\t\tofs = this->diesize[0];\n\t}\n\n\tboundary = this->boundary[die];\n\tofs += (loff_t)block << (this->erase_shift - 1);\n\tif (block > (boundary + 1))\n\t\tofs += (loff_t)(block - boundary - 1) << (this->erase_shift - 1);\n\treturn ofs;\n}\n\nloff_t onenand_addr(struct onenand_chip *this, int block)\n{\n\tif (!FLEXONENAND(this))\n\t\treturn (loff_t)block << this->erase_shift;\n\treturn flexonenand_addr(this, block);\n}\nEXPORT_SYMBOL(onenand_addr);\n\n \nstatic inline int onenand_get_density(int dev_id)\n{\n\tint density = dev_id >> ONENAND_DEVICE_DENSITY_SHIFT;\n\treturn (density & ONENAND_DEVICE_DENSITY_MASK);\n}\n\n \nint flexonenand_region(struct mtd_info *mtd, loff_t addr)\n{\n\tint i;\n\n\tfor (i = 0; i < mtd->numeraseregions; i++)\n\t\tif (addr < mtd->eraseregions[i].offset)\n\t\t\tbreak;\n\treturn i - 1;\n}\nEXPORT_SYMBOL(flexonenand_region);\n\n \nstatic int onenand_command(struct mtd_info *mtd, int cmd, loff_t addr, size_t len)\n{\n\tstruct onenand_chip *this = mtd->priv;\n\tint value, block, page;\n\n\t \n\tswitch (cmd) {\n\tcase ONENAND_CMD_UNLOCK:\n\tcase ONENAND_CMD_LOCK:\n\tcase ONENAND_CMD_LOCK_TIGHT:\n\tcase ONENAND_CMD_UNLOCK_ALL:\n\t\tblock = -1;\n\t\tpage = -1;\n\t\tbreak;\n\n\tcase FLEXONENAND_CMD_PI_ACCESS:\n\t\t \n\t\tblock = addr * this->density_mask;\n\t\tpage = -1;\n\t\tbreak;\n\n\tcase ONENAND_CMD_ERASE:\n\tcase ONENAND_CMD_MULTIBLOCK_ERASE:\n\tcase ONENAND_CMD_ERASE_VERIFY:\n\tcase ONENAND_CMD_BUFFERRAM:\n\tcase ONENAND_CMD_OTP_ACCESS:\n\t\tblock = onenand_block(this, addr);\n\t\tpage = -1;\n\t\tbreak;\n\n\tcase FLEXONENAND_CMD_READ_PI:\n\t\tcmd = ONENAND_CMD_READ;\n\t\tblock = addr * this->density_mask;\n\t\tpage = 0;\n\t\tbreak;\n\n\tdefault:\n\t\tblock = onenand_block(this, addr);\n\t\tif (FLEXONENAND(this))\n\t\t\tpage = (int) (addr - onenand_addr(this, block))>>\\\n\t\t\t\tthis->page_shift;\n\t\telse\n\t\t\tpage = (int) (addr >> this->page_shift);\n\t\tif (ONENAND_IS_2PLANE(this)) {\n\t\t\t \n\t\t\tblock &= ~1;\n\t\t\t \n\t\t\tif (addr & this->writesize)\n\t\t\t\tblock++;\n\t\t\tpage >>= 1;\n\t\t}\n\t\tpage &= this->page_mask;\n\t\tbreak;\n\t}\n\n\t \n\tif (cmd == ONENAND_CMD_BUFFERRAM) {\n\t\t \n\t\tvalue = onenand_bufferram_address(this, block);\n\t\tthis->write_word(value, this->base + ONENAND_REG_START_ADDRESS2);\n\n\t\tif (ONENAND_IS_2PLANE(this) || ONENAND_IS_4KB_PAGE(this))\n\t\t\t \n\t\t\tONENAND_SET_BUFFERRAM0(this);\n\t\telse\n\t\t\t \n\t\t\tONENAND_SET_NEXT_BUFFERRAM(this);\n\n\t\treturn 0;\n\t}\n\n\tif (block != -1) {\n\t\t \n\t\tvalue = onenand_block_address(this, block);\n\t\tthis->write_word(value, this->base + ONENAND_REG_START_ADDRESS1);\n\n\t\t \n\t\tvalue = onenand_bufferram_address(this, block);\n\t\tthis->write_word(value, this->base + ONENAND_REG_START_ADDRESS2);\n\t}\n\n\tif (page != -1) {\n\t\t \n\t\tint sectors = 0, count = 0;\n\t\tint dataram;\n\n\t\tswitch (cmd) {\n\t\tcase FLEXONENAND_CMD_RECOVER_LSB:\n\t\tcase ONENAND_CMD_READ:\n\t\tcase ONENAND_CMD_READOOB:\n\t\t\tif (ONENAND_IS_4KB_PAGE(this))\n\t\t\t\t \n\t\t\t\tdataram = ONENAND_SET_BUFFERRAM0(this);\n\t\t\telse\n\t\t\t\tdataram = ONENAND_SET_NEXT_BUFFERRAM(this);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tif (ONENAND_IS_2PLANE(this) && cmd == ONENAND_CMD_PROG)\n\t\t\t\tcmd = ONENAND_CMD_2X_PROG;\n\t\t\tdataram = ONENAND_CURRENT_BUFFERRAM(this);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tvalue = onenand_page_address(page, sectors);\n\t\tthis->write_word(value, this->base + ONENAND_REG_START_ADDRESS8);\n\n\t\t \n\t\tvalue = onenand_buffer_address(dataram, sectors, count);\n\t\tthis->write_word(value, this->base + ONENAND_REG_START_BUFFER);\n\t}\n\n\t \n\tthis->write_word(ONENAND_INT_CLEAR, this->base + ONENAND_REG_INTERRUPT);\n\n\t \n\tthis->write_word(cmd, this->base + ONENAND_REG_COMMAND);\n\n\treturn 0;\n}\n\n \nstatic inline int onenand_read_ecc(struct onenand_chip *this)\n{\n\tint ecc, i, result = 0;\n\n\tif (!FLEXONENAND(this) && !ONENAND_IS_4KB_PAGE(this))\n\t\treturn this->read_word(this->base + ONENAND_REG_ECC_STATUS);\n\n\tfor (i = 0; i < 4; i++) {\n\t\tecc = this->read_word(this->base + ONENAND_REG_ECC_STATUS + i*2);\n\t\tif (likely(!ecc))\n\t\t\tcontinue;\n\t\tif (ecc & FLEXONENAND_UNCORRECTABLE_ERROR)\n\t\t\treturn ONENAND_ECC_2BIT_ALL;\n\t\telse\n\t\t\tresult = ONENAND_ECC_1BIT_ALL;\n\t}\n\n\treturn result;\n}\n\n \nstatic int onenand_wait(struct mtd_info *mtd, int state)\n{\n\tstruct onenand_chip * this = mtd->priv;\n\tunsigned long timeout;\n\tunsigned int flags = ONENAND_INT_MASTER;\n\tunsigned int interrupt = 0;\n\tunsigned int ctrl;\n\n\t \n\ttimeout = jiffies + msecs_to_jiffies(20);\n\twhile (time_before(jiffies, timeout)) {\n\t\tinterrupt = this->read_word(this->base + ONENAND_REG_INTERRUPT);\n\n\t\tif (interrupt & flags)\n\t\t\tbreak;\n\n\t\tif (state != FL_READING && state != FL_PREPARING_ERASE)\n\t\t\tcond_resched();\n\t}\n\t \n\tinterrupt = this->read_word(this->base + ONENAND_REG_INTERRUPT);\n\n\tctrl = this->read_word(this->base + ONENAND_REG_CTRL_STATUS);\n\n\t \n\tif (interrupt & ONENAND_INT_READ) {\n\t\tint ecc = onenand_read_ecc(this);\n\t\tif (ecc) {\n\t\t\tif (ecc & ONENAND_ECC_2BIT_ALL) {\n\t\t\t\tprintk(KERN_ERR \"%s: ECC error = 0x%04x\\n\",\n\t\t\t\t\t__func__, ecc);\n\t\t\t\tmtd->ecc_stats.failed++;\n\t\t\t\treturn -EBADMSG;\n\t\t\t} else if (ecc & ONENAND_ECC_1BIT_ALL) {\n\t\t\t\tprintk(KERN_DEBUG \"%s: correctable ECC error = 0x%04x\\n\",\n\t\t\t\t\t__func__, ecc);\n\t\t\t\tmtd->ecc_stats.corrected++;\n\t\t\t}\n\t\t}\n\t} else if (state == FL_READING) {\n\t\tprintk(KERN_ERR \"%s: read timeout! ctrl=0x%04x intr=0x%04x\\n\",\n\t\t\t__func__, ctrl, interrupt);\n\t\treturn -EIO;\n\t}\n\n\tif (state == FL_PREPARING_ERASE && !(interrupt & ONENAND_INT_ERASE)) {\n\t\tprintk(KERN_ERR \"%s: mb erase timeout! ctrl=0x%04x intr=0x%04x\\n\",\n\t\t       __func__, ctrl, interrupt);\n\t\treturn -EIO;\n\t}\n\n\tif (!(interrupt & ONENAND_INT_MASTER)) {\n\t\tprintk(KERN_ERR \"%s: timeout! ctrl=0x%04x intr=0x%04x\\n\",\n\t\t       __func__, ctrl, interrupt);\n\t\treturn -EIO;\n\t}\n\n\t \n\tif (ctrl & ONENAND_CTRL_ERROR) {\n\t\tprintk(KERN_ERR \"%s: controller error = 0x%04x\\n\",\n\t\t\t__func__, ctrl);\n\t\tif (ctrl & ONENAND_CTRL_LOCK)\n\t\t\tprintk(KERN_ERR \"%s: it's locked error.\\n\", __func__);\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\n \nstatic irqreturn_t onenand_interrupt(int irq, void *data)\n{\n\tstruct onenand_chip *this = data;\n\n\t \n\tif (!this->complete.done)\n\t\tcomplete(&this->complete);\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic int onenand_interrupt_wait(struct mtd_info *mtd, int state)\n{\n\tstruct onenand_chip *this = mtd->priv;\n\n\twait_for_completion(&this->complete);\n\n\treturn onenand_wait(mtd, state);\n}\n\n \nstatic int onenand_try_interrupt_wait(struct mtd_info *mtd, int state)\n{\n\tstruct onenand_chip *this = mtd->priv;\n\tunsigned long remain, timeout;\n\n\t \n\tthis->wait = onenand_interrupt_wait;\n\n\ttimeout = msecs_to_jiffies(100);\n\tremain = wait_for_completion_timeout(&this->complete, timeout);\n\tif (!remain) {\n\t\tprintk(KERN_INFO \"OneNAND: There's no interrupt. \"\n\t\t\t\t\"We use the normal wait\\n\");\n\n\t\t \n\t\tfree_irq(this->irq, this);\n\n\t\tthis->wait = onenand_wait;\n\t}\n\n\treturn onenand_wait(mtd, state);\n}\n\n \nstatic void onenand_setup_wait(struct mtd_info *mtd)\n{\n\tstruct onenand_chip *this = mtd->priv;\n\tint syscfg;\n\n\tinit_completion(&this->complete);\n\n\tif (this->irq <= 0) {\n\t\tthis->wait = onenand_wait;\n\t\treturn;\n\t}\n\n\tif (request_irq(this->irq, &onenand_interrupt,\n\t\t\t\tIRQF_SHARED, \"onenand\", this)) {\n\t\t \n\t\tthis->wait = onenand_wait;\n\t\treturn;\n\t}\n\n\t \n\tsyscfg = this->read_word(this->base + ONENAND_REG_SYS_CFG1);\n\tsyscfg |= ONENAND_SYS_CFG1_IOBE;\n\tthis->write_word(syscfg, this->base + ONENAND_REG_SYS_CFG1);\n\n\tthis->wait = onenand_try_interrupt_wait;\n}\n\n \nstatic inline int onenand_bufferram_offset(struct mtd_info *mtd, int area)\n{\n\tstruct onenand_chip *this = mtd->priv;\n\n\tif (ONENAND_CURRENT_BUFFERRAM(this)) {\n\t\t \n\t\tif (area == ONENAND_DATARAM)\n\t\t\treturn this->writesize;\n\t\tif (area == ONENAND_SPARERAM)\n\t\t\treturn mtd->oobsize;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int onenand_read_bufferram(struct mtd_info *mtd, int area,\n\t\tunsigned char *buffer, int offset, size_t count)\n{\n\tstruct onenand_chip *this = mtd->priv;\n\tvoid __iomem *bufferram;\n\n\tbufferram = this->base + area;\n\n\tbufferram += onenand_bufferram_offset(mtd, area);\n\n\tif (ONENAND_CHECK_BYTE_ACCESS(count)) {\n\t\tunsigned short word;\n\n\t\t \n\t\tcount--;\n\n\t\t \n\t\tword = this->read_word(bufferram + offset + count);\n\t\tbuffer[count] = (word & 0xff);\n\t}\n\n\tmemcpy(buffer, bufferram + offset, count);\n\n\treturn 0;\n}\n\n \nstatic int onenand_sync_read_bufferram(struct mtd_info *mtd, int area,\n\t\tunsigned char *buffer, int offset, size_t count)\n{\n\tstruct onenand_chip *this = mtd->priv;\n\tvoid __iomem *bufferram;\n\n\tbufferram = this->base + area;\n\n\tbufferram += onenand_bufferram_offset(mtd, area);\n\n\tthis->mmcontrol(mtd, ONENAND_SYS_CFG1_SYNC_READ);\n\n\tif (ONENAND_CHECK_BYTE_ACCESS(count)) {\n\t\tunsigned short word;\n\n\t\t \n\t\tcount--;\n\n\t\t \n\t\tword = this->read_word(bufferram + offset + count);\n\t\tbuffer[count] = (word & 0xff);\n\t}\n\n\tmemcpy(buffer, bufferram + offset, count);\n\n\tthis->mmcontrol(mtd, 0);\n\n\treturn 0;\n}\n\n \nstatic int onenand_write_bufferram(struct mtd_info *mtd, int area,\n\t\tconst unsigned char *buffer, int offset, size_t count)\n{\n\tstruct onenand_chip *this = mtd->priv;\n\tvoid __iomem *bufferram;\n\n\tbufferram = this->base + area;\n\n\tbufferram += onenand_bufferram_offset(mtd, area);\n\n\tif (ONENAND_CHECK_BYTE_ACCESS(count)) {\n\t\tunsigned short word;\n\t\tint byte_offset;\n\n\t\t \n\t\tcount--;\n\n\t\t \n\t\tbyte_offset = offset + count;\n\n\t\t \n\t\tword = this->read_word(bufferram + byte_offset);\n\t\tword = (word & ~0xff) | buffer[count];\n\t\tthis->write_word(word, bufferram + byte_offset);\n\t}\n\n\tmemcpy(bufferram + offset, buffer, count);\n\n\treturn 0;\n}\n\n \nstatic int onenand_get_2x_blockpage(struct mtd_info *mtd, loff_t addr)\n{\n\tstruct onenand_chip *this = mtd->priv;\n\tint blockpage, block, page;\n\n\t \n\tblock = (int) (addr >> this->erase_shift) & ~1;\n\t \n\tif (addr & this->writesize)\n\t\tblock++;\n\tpage = (int) (addr >> (this->page_shift + 1)) & this->page_mask;\n\tblockpage = (block << 7) | page;\n\n\treturn blockpage;\n}\n\n \nstatic int onenand_check_bufferram(struct mtd_info *mtd, loff_t addr)\n{\n\tstruct onenand_chip *this = mtd->priv;\n\tint blockpage, found = 0;\n\tunsigned int i;\n\n\tif (ONENAND_IS_2PLANE(this))\n\t\tblockpage = onenand_get_2x_blockpage(mtd, addr);\n\telse\n\t\tblockpage = (int) (addr >> this->page_shift);\n\n\t \n\ti = ONENAND_CURRENT_BUFFERRAM(this);\n\tif (this->bufferram[i].blockpage == blockpage)\n\t\tfound = 1;\n\telse {\n\t\t \n\t\ti = ONENAND_NEXT_BUFFERRAM(this);\n\t\tif (this->bufferram[i].blockpage == blockpage) {\n\t\t\tONENAND_SET_NEXT_BUFFERRAM(this);\n\t\t\tfound = 1;\n\t\t}\n\t}\n\n\tif (found && ONENAND_IS_DDP(this)) {\n\t\t \n\t\tint block = onenand_block(this, addr);\n\t\tint value = onenand_bufferram_address(this, block);\n\t\tthis->write_word(value, this->base + ONENAND_REG_START_ADDRESS2);\n\t}\n\n\treturn found;\n}\n\n \nstatic void onenand_update_bufferram(struct mtd_info *mtd, loff_t addr,\n\t\tint valid)\n{\n\tstruct onenand_chip *this = mtd->priv;\n\tint blockpage;\n\tunsigned int i;\n\n\tif (ONENAND_IS_2PLANE(this))\n\t\tblockpage = onenand_get_2x_blockpage(mtd, addr);\n\telse\n\t\tblockpage = (int) (addr >> this->page_shift);\n\n\t \n\ti = ONENAND_NEXT_BUFFERRAM(this);\n\tif (this->bufferram[i].blockpage == blockpage)\n\t\tthis->bufferram[i].blockpage = -1;\n\n\t \n\ti = ONENAND_CURRENT_BUFFERRAM(this);\n\tif (valid)\n\t\tthis->bufferram[i].blockpage = blockpage;\n\telse\n\t\tthis->bufferram[i].blockpage = -1;\n}\n\n \nstatic void onenand_invalidate_bufferram(struct mtd_info *mtd, loff_t addr,\n\t\tunsigned int len)\n{\n\tstruct onenand_chip *this = mtd->priv;\n\tint i;\n\tloff_t end_addr = addr + len;\n\n\t \n\tfor (i = 0; i < MAX_BUFFERRAM; i++) {\n\t\tloff_t buf_addr = this->bufferram[i].blockpage << this->page_shift;\n\t\tif (buf_addr >= addr && buf_addr < end_addr)\n\t\t\tthis->bufferram[i].blockpage = -1;\n\t}\n}\n\n \nstatic int onenand_get_device(struct mtd_info *mtd, int new_state)\n{\n\tstruct onenand_chip *this = mtd->priv;\n\tDECLARE_WAITQUEUE(wait, current);\n\n\t \n\twhile (1) {\n\t\tspin_lock(&this->chip_lock);\n\t\tif (this->state == FL_READY) {\n\t\t\tthis->state = new_state;\n\t\t\tspin_unlock(&this->chip_lock);\n\t\t\tif (new_state != FL_PM_SUSPENDED && this->enable)\n\t\t\t\tthis->enable(mtd);\n\t\t\tbreak;\n\t\t}\n\t\tif (new_state == FL_PM_SUSPENDED) {\n\t\t\tspin_unlock(&this->chip_lock);\n\t\t\treturn (this->state == FL_PM_SUSPENDED) ? 0 : -EAGAIN;\n\t\t}\n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\tadd_wait_queue(&this->wq, &wait);\n\t\tspin_unlock(&this->chip_lock);\n\t\tschedule();\n\t\tremove_wait_queue(&this->wq, &wait);\n\t}\n\n\treturn 0;\n}\n\n \nstatic void onenand_release_device(struct mtd_info *mtd)\n{\n\tstruct onenand_chip *this = mtd->priv;\n\n\tif (this->state != FL_PM_SUSPENDED && this->disable)\n\t\tthis->disable(mtd);\n\t \n\tspin_lock(&this->chip_lock);\n\tthis->state = FL_READY;\n\twake_up(&this->wq);\n\tspin_unlock(&this->chip_lock);\n}\n\n \nstatic int onenand_transfer_auto_oob(struct mtd_info *mtd, uint8_t *buf, int column,\n\t\t\t\tint thislen)\n{\n\tstruct onenand_chip *this = mtd->priv;\n\n\tthis->read_bufferram(mtd, ONENAND_SPARERAM, this->oob_buf, 0,\n\t\t\t     mtd->oobsize);\n\treturn mtd_ooblayout_get_databytes(mtd, buf, this->oob_buf,\n\t\t\t\t\t   column, thislen);\n}\n\n \nstatic int onenand_recover_lsb(struct mtd_info *mtd, loff_t addr, int status)\n{\n\tstruct onenand_chip *this = mtd->priv;\n\tint i;\n\n\t \n\tif (!FLEXONENAND(this))\n\t\treturn status;\n\n\t \n\tif (!mtd_is_eccerr(status) && status != ONENAND_BBT_READ_ECC_ERROR)\n\t\treturn status;\n\n\t \n\ti = flexonenand_region(mtd, addr);\n\tif (mtd->eraseregions[i].erasesize < (1 << this->erase_shift))\n\t\treturn status;\n\n\t \n\tprintk(KERN_INFO \"%s: Attempting to recover from uncorrectable read\\n\",\n\t\t__func__);\n\tmtd->ecc_stats.failed--;\n\n\t \n\tthis->command(mtd, FLEXONENAND_CMD_RECOVER_LSB, addr, this->writesize);\n\treturn this->wait(mtd, FL_READING);\n}\n\n \nstatic int onenand_mlc_read_ops_nolock(struct mtd_info *mtd, loff_t from,\n\t\t\t\tstruct mtd_oob_ops *ops)\n{\n\tstruct onenand_chip *this = mtd->priv;\n\tstruct mtd_ecc_stats stats;\n\tsize_t len = ops->len;\n\tsize_t ooblen = ops->ooblen;\n\tu_char *buf = ops->datbuf;\n\tu_char *oobbuf = ops->oobbuf;\n\tint read = 0, column, thislen;\n\tint oobread = 0, oobcolumn, thisooblen, oobsize;\n\tint ret = 0;\n\tint writesize = this->writesize;\n\n\tpr_debug(\"%s: from = 0x%08x, len = %i\\n\", __func__, (unsigned int)from,\n\t\t\t(int)len);\n\n\toobsize = mtd_oobavail(mtd, ops);\n\toobcolumn = from & (mtd->oobsize - 1);\n\n\t \n\tif (from + len > mtd->size) {\n\t\tprintk(KERN_ERR \"%s: Attempt read beyond end of device\\n\",\n\t\t\t__func__);\n\t\tops->retlen = 0;\n\t\tops->oobretlen = 0;\n\t\treturn -EINVAL;\n\t}\n\n\tstats = mtd->ecc_stats;\n\n\twhile (read < len) {\n\t\tcond_resched();\n\n\t\tthislen = min_t(int, writesize, len - read);\n\n\t\tcolumn = from & (writesize - 1);\n\t\tif (column + thislen > writesize)\n\t\t\tthislen = writesize - column;\n\n\t\tif (!onenand_check_bufferram(mtd, from)) {\n\t\t\tthis->command(mtd, ONENAND_CMD_READ, from, writesize);\n\n\t\t\tret = this->wait(mtd, FL_READING);\n\t\t\tif (unlikely(ret))\n\t\t\t\tret = onenand_recover_lsb(mtd, from, ret);\n\t\t\tonenand_update_bufferram(mtd, from, !ret);\n\t\t\tif (mtd_is_eccerr(ret))\n\t\t\t\tret = 0;\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tthis->read_bufferram(mtd, ONENAND_DATARAM, buf, column, thislen);\n\t\tif (oobbuf) {\n\t\t\tthisooblen = oobsize - oobcolumn;\n\t\t\tthisooblen = min_t(int, thisooblen, ooblen - oobread);\n\n\t\t\tif (ops->mode == MTD_OPS_AUTO_OOB)\n\t\t\t\tonenand_transfer_auto_oob(mtd, oobbuf, oobcolumn, thisooblen);\n\t\t\telse\n\t\t\t\tthis->read_bufferram(mtd, ONENAND_SPARERAM, oobbuf, oobcolumn, thisooblen);\n\t\t\toobread += thisooblen;\n\t\t\toobbuf += thisooblen;\n\t\t\toobcolumn = 0;\n\t\t}\n\n\t\tread += thislen;\n\t\tif (read == len)\n\t\t\tbreak;\n\n\t\tfrom += thislen;\n\t\tbuf += thislen;\n\t}\n\n\t \n\tops->retlen = read;\n\tops->oobretlen = oobread;\n\n\tif (ret)\n\t\treturn ret;\n\n\tif (mtd->ecc_stats.failed - stats.failed)\n\t\treturn -EBADMSG;\n\n\t \n\treturn mtd->ecc_stats.corrected != stats.corrected ? 1 : 0;\n}\n\n \nstatic int onenand_read_ops_nolock(struct mtd_info *mtd, loff_t from,\n\t\t\t\tstruct mtd_oob_ops *ops)\n{\n\tstruct onenand_chip *this = mtd->priv;\n\tstruct mtd_ecc_stats stats;\n\tsize_t len = ops->len;\n\tsize_t ooblen = ops->ooblen;\n\tu_char *buf = ops->datbuf;\n\tu_char *oobbuf = ops->oobbuf;\n\tint read = 0, column, thislen;\n\tint oobread = 0, oobcolumn, thisooblen, oobsize;\n\tint ret = 0, boundary = 0;\n\tint writesize = this->writesize;\n\n\tpr_debug(\"%s: from = 0x%08x, len = %i\\n\", __func__, (unsigned int)from,\n\t\t\t(int)len);\n\n\toobsize = mtd_oobavail(mtd, ops);\n\toobcolumn = from & (mtd->oobsize - 1);\n\n\t \n\tif ((from + len) > mtd->size) {\n\t\tprintk(KERN_ERR \"%s: Attempt read beyond end of device\\n\",\n\t\t\t__func__);\n\t\tops->retlen = 0;\n\t\tops->oobretlen = 0;\n\t\treturn -EINVAL;\n\t}\n\n\tstats = mtd->ecc_stats;\n\n\t \n\n\t \n\tif (read < len) {\n\t\tif (!onenand_check_bufferram(mtd, from)) {\n\t\t\tthis->command(mtd, ONENAND_CMD_READ, from, writesize);\n\t\t\tret = this->wait(mtd, FL_READING);\n\t\t\tonenand_update_bufferram(mtd, from, !ret);\n\t\t\tif (mtd_is_eccerr(ret))\n\t\t\t\tret = 0;\n\t\t}\n\t}\n\n\tthislen = min_t(int, writesize, len - read);\n\tcolumn = from & (writesize - 1);\n\tif (column + thislen > writesize)\n\t\tthislen = writesize - column;\n\n\twhile (!ret) {\n\t\t \n\t\tfrom += thislen;\n\t\tif (read + thislen < len) {\n\t\t\tthis->command(mtd, ONENAND_CMD_READ, from, writesize);\n\t\t\t \n\t\t\tif (ONENAND_IS_DDP(this) &&\n\t\t\t    unlikely(from == (this->chipsize >> 1))) {\n\t\t\t\tthis->write_word(ONENAND_DDP_CHIP0, this->base + ONENAND_REG_START_ADDRESS2);\n\t\t\t\tboundary = 1;\n\t\t\t} else\n\t\t\t\tboundary = 0;\n\t\t\tONENAND_SET_PREV_BUFFERRAM(this);\n\t\t}\n\t\t \n\t\tthis->read_bufferram(mtd, ONENAND_DATARAM, buf, column, thislen);\n\n\t\t \n\t\tif (oobbuf) {\n\t\t\tthisooblen = oobsize - oobcolumn;\n\t\t\tthisooblen = min_t(int, thisooblen, ooblen - oobread);\n\n\t\t\tif (ops->mode == MTD_OPS_AUTO_OOB)\n\t\t\t\tonenand_transfer_auto_oob(mtd, oobbuf, oobcolumn, thisooblen);\n\t\t\telse\n\t\t\t\tthis->read_bufferram(mtd, ONENAND_SPARERAM, oobbuf, oobcolumn, thisooblen);\n\t\t\toobread += thisooblen;\n\t\t\toobbuf += thisooblen;\n\t\t\toobcolumn = 0;\n\t\t}\n\n\t\t \n\t\tread += thislen;\n\t\tif (read == len)\n\t\t\tbreak;\n\t\t \n\t\tif (unlikely(boundary))\n\t\t\tthis->write_word(ONENAND_DDP_CHIP1, this->base + ONENAND_REG_START_ADDRESS2);\n\t\tONENAND_SET_NEXT_BUFFERRAM(this);\n\t\tbuf += thislen;\n\t\tthislen = min_t(int, writesize, len - read);\n\t\tcolumn = 0;\n\t\tcond_resched();\n\t\t \n\t\tret = this->wait(mtd, FL_READING);\n\t\tonenand_update_bufferram(mtd, from, !ret);\n\t\tif (mtd_is_eccerr(ret))\n\t\t\tret = 0;\n\t}\n\n\t \n\tops->retlen = read;\n\tops->oobretlen = oobread;\n\n\tif (ret)\n\t\treturn ret;\n\n\tif (mtd->ecc_stats.failed - stats.failed)\n\t\treturn -EBADMSG;\n\n\t \n\treturn mtd->ecc_stats.corrected != stats.corrected ? 1 : 0;\n}\n\n \nstatic int onenand_read_oob_nolock(struct mtd_info *mtd, loff_t from,\n\t\t\tstruct mtd_oob_ops *ops)\n{\n\tstruct onenand_chip *this = mtd->priv;\n\tstruct mtd_ecc_stats stats;\n\tint read = 0, thislen, column, oobsize;\n\tsize_t len = ops->ooblen;\n\tunsigned int mode = ops->mode;\n\tu_char *buf = ops->oobbuf;\n\tint ret = 0, readcmd;\n\n\tfrom += ops->ooboffs;\n\n\tpr_debug(\"%s: from = 0x%08x, len = %i\\n\", __func__, (unsigned int)from,\n\t\t\t(int)len);\n\n\t \n\tops->oobretlen = 0;\n\n\tif (mode == MTD_OPS_AUTO_OOB)\n\t\toobsize = mtd->oobavail;\n\telse\n\t\toobsize = mtd->oobsize;\n\n\tcolumn = from & (mtd->oobsize - 1);\n\n\tif (unlikely(column >= oobsize)) {\n\t\tprintk(KERN_ERR \"%s: Attempted to start read outside oob\\n\",\n\t\t\t__func__);\n\t\treturn -EINVAL;\n\t}\n\n\tstats = mtd->ecc_stats;\n\n\treadcmd = ONENAND_IS_4KB_PAGE(this) ? ONENAND_CMD_READ : ONENAND_CMD_READOOB;\n\n\twhile (read < len) {\n\t\tcond_resched();\n\n\t\tthislen = oobsize - column;\n\t\tthislen = min_t(int, thislen, len);\n\n\t\tthis->command(mtd, readcmd, from, mtd->oobsize);\n\n\t\tonenand_update_bufferram(mtd, from, 0);\n\n\t\tret = this->wait(mtd, FL_READING);\n\t\tif (unlikely(ret))\n\t\t\tret = onenand_recover_lsb(mtd, from, ret);\n\n\t\tif (ret && !mtd_is_eccerr(ret)) {\n\t\t\tprintk(KERN_ERR \"%s: read failed = 0x%x\\n\",\n\t\t\t\t__func__, ret);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (mode == MTD_OPS_AUTO_OOB)\n\t\t\tonenand_transfer_auto_oob(mtd, buf, column, thislen);\n\t\telse\n\t\t\tthis->read_bufferram(mtd, ONENAND_SPARERAM, buf, column, thislen);\n\n\t\tread += thislen;\n\n\t\tif (read == len)\n\t\t\tbreak;\n\n\t\tbuf += thislen;\n\n\t\t \n\t\tif (read < len) {\n\t\t\t \n\t\t\tfrom += mtd->writesize;\n\t\t\tcolumn = 0;\n\t\t}\n\t}\n\n\tops->oobretlen = read;\n\n\tif (ret)\n\t\treturn ret;\n\n\tif (mtd->ecc_stats.failed - stats.failed)\n\t\treturn -EBADMSG;\n\n\treturn 0;\n}\n\n \nstatic int onenand_read_oob(struct mtd_info *mtd, loff_t from,\n\t\t\t    struct mtd_oob_ops *ops)\n{\n\tstruct onenand_chip *this = mtd->priv;\n\tstruct mtd_ecc_stats old_stats;\n\tint ret;\n\n\tswitch (ops->mode) {\n\tcase MTD_OPS_PLACE_OOB:\n\tcase MTD_OPS_AUTO_OOB:\n\t\tbreak;\n\tcase MTD_OPS_RAW:\n\t\t \n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tonenand_get_device(mtd, FL_READING);\n\n\told_stats = mtd->ecc_stats;\n\n\tif (ops->datbuf)\n\t\tret = ONENAND_IS_4KB_PAGE(this) ?\n\t\t\tonenand_mlc_read_ops_nolock(mtd, from, ops) :\n\t\t\tonenand_read_ops_nolock(mtd, from, ops);\n\telse\n\t\tret = onenand_read_oob_nolock(mtd, from, ops);\n\n\tif (ops->stats) {\n\t\tops->stats->uncorrectable_errors +=\n\t\t\tmtd->ecc_stats.failed - old_stats.failed;\n\t\tops->stats->corrected_bitflips +=\n\t\t\tmtd->ecc_stats.corrected - old_stats.corrected;\n\t}\n\n\tonenand_release_device(mtd);\n\n\treturn ret;\n}\n\n \nstatic int onenand_bbt_wait(struct mtd_info *mtd, int state)\n{\n\tstruct onenand_chip *this = mtd->priv;\n\tunsigned long timeout;\n\tunsigned int interrupt, ctrl, ecc, addr1, addr8;\n\n\t \n\ttimeout = jiffies + msecs_to_jiffies(20);\n\twhile (time_before(jiffies, timeout)) {\n\t\tinterrupt = this->read_word(this->base + ONENAND_REG_INTERRUPT);\n\t\tif (interrupt & ONENAND_INT_MASTER)\n\t\t\tbreak;\n\t}\n\t \n\tinterrupt = this->read_word(this->base + ONENAND_REG_INTERRUPT);\n\tctrl = this->read_word(this->base + ONENAND_REG_CTRL_STATUS);\n\taddr1 = this->read_word(this->base + ONENAND_REG_START_ADDRESS1);\n\taddr8 = this->read_word(this->base + ONENAND_REG_START_ADDRESS8);\n\n\tif (interrupt & ONENAND_INT_READ) {\n\t\tecc = onenand_read_ecc(this);\n\t\tif (ecc & ONENAND_ECC_2BIT_ALL) {\n\t\t\tprintk(KERN_DEBUG \"%s: ecc 0x%04x ctrl 0x%04x \"\n\t\t\t       \"intr 0x%04x addr1 %#x addr8 %#x\\n\",\n\t\t\t       __func__, ecc, ctrl, interrupt, addr1, addr8);\n\t\t\treturn ONENAND_BBT_READ_ECC_ERROR;\n\t\t}\n\t} else {\n\t\tprintk(KERN_ERR \"%s: read timeout! ctrl 0x%04x \"\n\t\t       \"intr 0x%04x addr1 %#x addr8 %#x\\n\",\n\t\t       __func__, ctrl, interrupt, addr1, addr8);\n\t\treturn ONENAND_BBT_READ_FATAL_ERROR;\n\t}\n\n\t \n\tif (ctrl & ONENAND_CTRL_ERROR) {\n\t\tprintk(KERN_DEBUG \"%s: ctrl 0x%04x intr 0x%04x addr1 %#x \"\n\t\t       \"addr8 %#x\\n\", __func__, ctrl, interrupt, addr1, addr8);\n\t\treturn ONENAND_BBT_READ_ERROR;\n\t}\n\n\treturn 0;\n}\n\n \nint onenand_bbt_read_oob(struct mtd_info *mtd, loff_t from, \n\t\t\t    struct mtd_oob_ops *ops)\n{\n\tstruct onenand_chip *this = mtd->priv;\n\tint read = 0, thislen, column;\n\tint ret = 0, readcmd;\n\tsize_t len = ops->ooblen;\n\tu_char *buf = ops->oobbuf;\n\n\tpr_debug(\"%s: from = 0x%08x, len = %zi\\n\", __func__, (unsigned int)from,\n\t\t\tlen);\n\n\t \n\tops->oobretlen = 0;\n\n\t \n\tif (unlikely((from + len) > mtd->size)) {\n\t\tprintk(KERN_ERR \"%s: Attempt read beyond end of device\\n\",\n\t\t\t__func__);\n\t\treturn ONENAND_BBT_READ_FATAL_ERROR;\n\t}\n\n\t \n\tonenand_get_device(mtd, FL_READING);\n\n\tcolumn = from & (mtd->oobsize - 1);\n\n\treadcmd = ONENAND_IS_4KB_PAGE(this) ? ONENAND_CMD_READ : ONENAND_CMD_READOOB;\n\n\twhile (read < len) {\n\t\tcond_resched();\n\n\t\tthislen = mtd->oobsize - column;\n\t\tthislen = min_t(int, thislen, len);\n\n\t\tthis->command(mtd, readcmd, from, mtd->oobsize);\n\n\t\tonenand_update_bufferram(mtd, from, 0);\n\n\t\tret = this->bbt_wait(mtd, FL_READING);\n\t\tif (unlikely(ret))\n\t\t\tret = onenand_recover_lsb(mtd, from, ret);\n\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tthis->read_bufferram(mtd, ONENAND_SPARERAM, buf, column, thislen);\n\t\tread += thislen;\n\t\tif (read == len)\n\t\t\tbreak;\n\n\t\tbuf += thislen;\n\n\t\t \n\t\tif (read < len) {\n\t\t\t \n\t\t\tfrom += this->writesize;\n\t\t\tcolumn = 0;\n\t\t}\n\t}\n\n\t \n\tonenand_release_device(mtd);\n\n\tops->oobretlen = read;\n\treturn ret;\n}\n\n#ifdef CONFIG_MTD_ONENAND_VERIFY_WRITE\n \nstatic int onenand_verify_oob(struct mtd_info *mtd, const u_char *buf, loff_t to)\n{\n\tstruct onenand_chip *this = mtd->priv;\n\tu_char *oob_buf = this->oob_buf;\n\tint status, i, readcmd;\n\n\treadcmd = ONENAND_IS_4KB_PAGE(this) ? ONENAND_CMD_READ : ONENAND_CMD_READOOB;\n\n\tthis->command(mtd, readcmd, to, mtd->oobsize);\n\tonenand_update_bufferram(mtd, to, 0);\n\tstatus = this->wait(mtd, FL_READING);\n\tif (status)\n\t\treturn status;\n\n\tthis->read_bufferram(mtd, ONENAND_SPARERAM, oob_buf, 0, mtd->oobsize);\n\tfor (i = 0; i < mtd->oobsize; i++)\n\t\tif (buf[i] != 0xFF && buf[i] != oob_buf[i])\n\t\t\treturn -EBADMSG;\n\n\treturn 0;\n}\n\n \nstatic int onenand_verify(struct mtd_info *mtd, const u_char *buf, loff_t addr, size_t len)\n{\n\tstruct onenand_chip *this = mtd->priv;\n\tint ret = 0;\n\tint thislen, column;\n\n\tcolumn = addr & (this->writesize - 1);\n\n\twhile (len != 0) {\n\t\tthislen = min_t(int, this->writesize - column, len);\n\n\t\tthis->command(mtd, ONENAND_CMD_READ, addr, this->writesize);\n\n\t\tonenand_update_bufferram(mtd, addr, 0);\n\n\t\tret = this->wait(mtd, FL_READING);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tonenand_update_bufferram(mtd, addr, 1);\n\n\t\tthis->read_bufferram(mtd, ONENAND_DATARAM, this->verify_buf, 0, mtd->writesize);\n\n\t\tif (memcmp(buf, this->verify_buf + column, thislen))\n\t\t\treturn -EBADMSG;\n\n\t\tlen -= thislen;\n\t\tbuf += thislen;\n\t\taddr += thislen;\n\t\tcolumn = 0;\n\t}\n\n\treturn 0;\n}\n#else\n#define onenand_verify(...)\t\t(0)\n#define onenand_verify_oob(...)\t\t(0)\n#endif\n\n#define NOTALIGNED(x)\t((x & (this->subpagesize - 1)) != 0)\n\nstatic void onenand_panic_wait(struct mtd_info *mtd)\n{\n\tstruct onenand_chip *this = mtd->priv;\n\tunsigned int interrupt;\n\tint i;\n\t\n\tfor (i = 0; i < 2000; i++) {\n\t\tinterrupt = this->read_word(this->base + ONENAND_REG_INTERRUPT);\n\t\tif (interrupt & ONENAND_INT_MASTER)\n\t\t\tbreak;\n\t\tudelay(10);\n\t}\n}\n\n \nstatic int onenand_panic_write(struct mtd_info *mtd, loff_t to, size_t len,\n\t\t\t size_t *retlen, const u_char *buf)\n{\n\tstruct onenand_chip *this = mtd->priv;\n\tint column, subpage;\n\tint written = 0;\n\n\tif (this->state == FL_PM_SUSPENDED)\n\t\treturn -EBUSY;\n\n\t \n\tonenand_panic_wait(mtd);\n\n\tpr_debug(\"%s: to = 0x%08x, len = %i\\n\", __func__, (unsigned int)to,\n\t\t\t(int)len);\n\n\t \n        if (unlikely(NOTALIGNED(to) || NOTALIGNED(len))) {\n\t\tprintk(KERN_ERR \"%s: Attempt to write not page aligned data\\n\",\n\t\t\t__func__);\n                return -EINVAL;\n        }\n\n\tcolumn = to & (mtd->writesize - 1);\n\n\t \n\twhile (written < len) {\n\t\tint thislen = min_t(int, mtd->writesize - column, len - written);\n\t\tu_char *wbuf = (u_char *) buf;\n\n\t\tthis->command(mtd, ONENAND_CMD_BUFFERRAM, to, thislen);\n\n\t\t \n\t\tsubpage = thislen < mtd->writesize;\n\t\tif (subpage) {\n\t\t\tmemset(this->page_buf, 0xff, mtd->writesize);\n\t\t\tmemcpy(this->page_buf + column, buf, thislen);\n\t\t\twbuf = this->page_buf;\n\t\t}\n\n\t\tthis->write_bufferram(mtd, ONENAND_DATARAM, wbuf, 0, mtd->writesize);\n\t\tthis->write_bufferram(mtd, ONENAND_SPARERAM, ffchars, 0, mtd->oobsize);\n\n\t\tthis->command(mtd, ONENAND_CMD_PROG, to, mtd->writesize);\n\n\t\tonenand_panic_wait(mtd);\n\n\t\t \n\t\tonenand_update_bufferram(mtd, to, !subpage);\n\t\tif (ONENAND_IS_2PLANE(this)) {\n\t\t\tONENAND_SET_BUFFERRAM1(this);\n\t\t\tonenand_update_bufferram(mtd, to + this->writesize, !subpage);\n\t\t}\n\n\t\twritten += thislen;\n\n\t\tif (written == len)\n\t\t\tbreak;\n\n\t\tcolumn = 0;\n\t\tto += thislen;\n\t\tbuf += thislen;\n\t}\n\n\t*retlen = written;\n\treturn 0;\n}\n\n \nstatic int onenand_fill_auto_oob(struct mtd_info *mtd, u_char *oob_buf,\n\t\t\t\t  const u_char *buf, int column, int thislen)\n{\n\treturn mtd_ooblayout_set_databytes(mtd, buf, oob_buf, column, thislen);\n}\n\n \nstatic int onenand_write_ops_nolock(struct mtd_info *mtd, loff_t to,\n\t\t\t\tstruct mtd_oob_ops *ops)\n{\n\tstruct onenand_chip *this = mtd->priv;\n\tint written = 0, column, thislen = 0, subpage = 0;\n\tint prev = 0, prevlen = 0, prev_subpage = 0, first = 1;\n\tint oobwritten = 0, oobcolumn, thisooblen, oobsize;\n\tsize_t len = ops->len;\n\tsize_t ooblen = ops->ooblen;\n\tconst u_char *buf = ops->datbuf;\n\tconst u_char *oob = ops->oobbuf;\n\tu_char *oobbuf;\n\tint ret = 0, cmd;\n\n\tpr_debug(\"%s: to = 0x%08x, len = %i\\n\", __func__, (unsigned int)to,\n\t\t\t(int)len);\n\n\t \n\tops->retlen = 0;\n\tops->oobretlen = 0;\n\n\t \n        if (unlikely(NOTALIGNED(to) || NOTALIGNED(len))) {\n\t\tprintk(KERN_ERR \"%s: Attempt to write not page aligned data\\n\",\n\t\t\t__func__);\n                return -EINVAL;\n        }\n\n\t \n\tif (!len)\n\t\treturn 0;\n\toobsize = mtd_oobavail(mtd, ops);\n\toobcolumn = to & (mtd->oobsize - 1);\n\n\tcolumn = to & (mtd->writesize - 1);\n\n\t \n\twhile (1) {\n\t\tif (written < len) {\n\t\t\tu_char *wbuf = (u_char *) buf;\n\n\t\t\tthislen = min_t(int, mtd->writesize - column, len - written);\n\t\t\tthisooblen = min_t(int, oobsize - oobcolumn, ooblen - oobwritten);\n\n\t\t\tcond_resched();\n\n\t\t\tthis->command(mtd, ONENAND_CMD_BUFFERRAM, to, thislen);\n\n\t\t\t \n\t\t\tsubpage = thislen < mtd->writesize;\n\t\t\tif (subpage) {\n\t\t\t\tmemset(this->page_buf, 0xff, mtd->writesize);\n\t\t\t\tmemcpy(this->page_buf + column, buf, thislen);\n\t\t\t\twbuf = this->page_buf;\n\t\t\t}\n\n\t\t\tthis->write_bufferram(mtd, ONENAND_DATARAM, wbuf, 0, mtd->writesize);\n\n\t\t\tif (oob) {\n\t\t\t\toobbuf = this->oob_buf;\n\n\t\t\t\t \n\t\t\t\tmemset(oobbuf, 0xff, mtd->oobsize);\n\t\t\t\tif (ops->mode == MTD_OPS_AUTO_OOB)\n\t\t\t\t\tonenand_fill_auto_oob(mtd, oobbuf, oob, oobcolumn, thisooblen);\n\t\t\t\telse\n\t\t\t\t\tmemcpy(oobbuf + oobcolumn, oob, thisooblen);\n\n\t\t\t\toobwritten += thisooblen;\n\t\t\t\toob += thisooblen;\n\t\t\t\toobcolumn = 0;\n\t\t\t} else\n\t\t\t\toobbuf = (u_char *) ffchars;\n\n\t\t\tthis->write_bufferram(mtd, ONENAND_SPARERAM, oobbuf, 0, mtd->oobsize);\n\t\t} else\n\t\t\tONENAND_SET_NEXT_BUFFERRAM(this);\n\n\t\t \n\t\tif (!ONENAND_IS_2PLANE(this) && !ONENAND_IS_4KB_PAGE(this) && !first) {\n\t\t\tONENAND_SET_PREV_BUFFERRAM(this);\n\n\t\t\tret = this->wait(mtd, FL_WRITING);\n\n\t\t\t \n\t\t\tonenand_update_bufferram(mtd, prev, !ret && !prev_subpage);\n\t\t\tif (ret) {\n\t\t\t\twritten -= prevlen;\n\t\t\t\tprintk(KERN_ERR \"%s: write failed %d\\n\",\n\t\t\t\t\t__func__, ret);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (written == len) {\n\t\t\t\t \n\t\t\t\tret = onenand_verify(mtd, buf - len, to - len, len);\n\t\t\t\tif (ret)\n\t\t\t\t\tprintk(KERN_ERR \"%s: verify failed %d\\n\",\n\t\t\t\t\t\t__func__, ret);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tONENAND_SET_NEXT_BUFFERRAM(this);\n\t\t}\n\n\t\tthis->ongoing = 0;\n\t\tcmd = ONENAND_CMD_PROG;\n\n\t\t \n\t\tif (ONENAND_IS_CACHE_PROGRAM(this) &&\n\t\t    likely(onenand_block(this, to) != 0) &&\n\t\t    ONENAND_IS_4KB_PAGE(this) &&\n\t\t    ((written + thislen) < len)) {\n\t\t\tcmd = ONENAND_CMD_2X_CACHE_PROG;\n\t\t\tthis->ongoing = 1;\n\t\t}\n\n\t\tthis->command(mtd, cmd, to, mtd->writesize);\n\n\t\t \n\t\tif (ONENAND_IS_2PLANE(this) || ONENAND_IS_4KB_PAGE(this)) {\n\t\t\tret = this->wait(mtd, FL_WRITING);\n\n\t\t\t \n\t\t\tonenand_update_bufferram(mtd, to, !ret && !subpage);\n\t\t\tif (ret) {\n\t\t\t\tprintk(KERN_ERR \"%s: write failed %d\\n\",\n\t\t\t\t\t__func__, ret);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t \n\t\t\tret = onenand_verify(mtd, buf, to, thislen);\n\t\t\tif (ret) {\n\t\t\t\tprintk(KERN_ERR \"%s: verify failed %d\\n\",\n\t\t\t\t\t__func__, ret);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\twritten += thislen;\n\n\t\t\tif (written == len)\n\t\t\t\tbreak;\n\n\t\t} else\n\t\t\twritten += thislen;\n\n\t\tcolumn = 0;\n\t\tprev_subpage = subpage;\n\t\tprev = to;\n\t\tprevlen = thislen;\n\t\tto += thislen;\n\t\tbuf += thislen;\n\t\tfirst = 0;\n\t}\n\n\t \n\tif (written != len)\n\t\tonenand_invalidate_bufferram(mtd, 0, -1);\n\n\tops->retlen = written;\n\tops->oobretlen = oobwritten;\n\n\treturn ret;\n}\n\n\n \nstatic int onenand_write_oob_nolock(struct mtd_info *mtd, loff_t to,\n\t\t\t\t    struct mtd_oob_ops *ops)\n{\n\tstruct onenand_chip *this = mtd->priv;\n\tint column, ret = 0, oobsize;\n\tint written = 0, oobcmd;\n\tu_char *oobbuf;\n\tsize_t len = ops->ooblen;\n\tconst u_char *buf = ops->oobbuf;\n\tunsigned int mode = ops->mode;\n\n\tto += ops->ooboffs;\n\n\tpr_debug(\"%s: to = 0x%08x, len = %i\\n\", __func__, (unsigned int)to,\n\t\t\t(int)len);\n\n\t \n\tops->oobretlen = 0;\n\n\tif (mode == MTD_OPS_AUTO_OOB)\n\t\toobsize = mtd->oobavail;\n\telse\n\t\toobsize = mtd->oobsize;\n\n\tcolumn = to & (mtd->oobsize - 1);\n\n\tif (unlikely(column >= oobsize)) {\n\t\tprintk(KERN_ERR \"%s: Attempted to start write outside oob\\n\",\n\t\t\t__func__);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (unlikely(column + len > oobsize)) {\n\t\tprintk(KERN_ERR \"%s: Attempt to write past end of page\\n\",\n\t\t\t__func__);\n\t\treturn -EINVAL;\n\t}\n\n\toobbuf = this->oob_buf;\n\n\toobcmd = ONENAND_IS_4KB_PAGE(this) ? ONENAND_CMD_PROG : ONENAND_CMD_PROGOOB;\n\n\t \n\twhile (written < len) {\n\t\tint thislen = min_t(int, oobsize, len - written);\n\n\t\tcond_resched();\n\n\t\tthis->command(mtd, ONENAND_CMD_BUFFERRAM, to, mtd->oobsize);\n\n\t\t \n\t\tmemset(oobbuf, 0xff, mtd->oobsize);\n\t\tif (mode == MTD_OPS_AUTO_OOB)\n\t\t\tonenand_fill_auto_oob(mtd, oobbuf, buf, column, thislen);\n\t\telse\n\t\t\tmemcpy(oobbuf + column, buf, thislen);\n\t\tthis->write_bufferram(mtd, ONENAND_SPARERAM, oobbuf, 0, mtd->oobsize);\n\n\t\tif (ONENAND_IS_4KB_PAGE(this)) {\n\t\t\t \n\t\t\tmemset(this->page_buf, 0xff, mtd->writesize);\n\t\t\tthis->write_bufferram(mtd, ONENAND_DATARAM,\n\t\t\t\t\t this->page_buf, 0, mtd->writesize);\n\t\t}\n\n\t\tthis->command(mtd, oobcmd, to, mtd->oobsize);\n\n\t\tonenand_update_bufferram(mtd, to, 0);\n\t\tif (ONENAND_IS_2PLANE(this)) {\n\t\t\tONENAND_SET_BUFFERRAM1(this);\n\t\t\tonenand_update_bufferram(mtd, to + this->writesize, 0);\n\t\t}\n\n\t\tret = this->wait(mtd, FL_WRITING);\n\t\tif (ret) {\n\t\t\tprintk(KERN_ERR \"%s: write failed %d\\n\", __func__, ret);\n\t\t\tbreak;\n\t\t}\n\n\t\tret = onenand_verify_oob(mtd, oobbuf, to);\n\t\tif (ret) {\n\t\t\tprintk(KERN_ERR \"%s: verify failed %d\\n\",\n\t\t\t\t__func__, ret);\n\t\t\tbreak;\n\t\t}\n\n\t\twritten += thislen;\n\t\tif (written == len)\n\t\t\tbreak;\n\n\t\tto += mtd->writesize;\n\t\tbuf += thislen;\n\t\tcolumn = 0;\n\t}\n\n\tops->oobretlen = written;\n\n\treturn ret;\n}\n\n \nstatic int onenand_write_oob(struct mtd_info *mtd, loff_t to,\n\t\t\t     struct mtd_oob_ops *ops)\n{\n\tint ret;\n\n\tswitch (ops->mode) {\n\tcase MTD_OPS_PLACE_OOB:\n\tcase MTD_OPS_AUTO_OOB:\n\t\tbreak;\n\tcase MTD_OPS_RAW:\n\t\t \n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tonenand_get_device(mtd, FL_WRITING);\n\tif (ops->datbuf)\n\t\tret = onenand_write_ops_nolock(mtd, to, ops);\n\telse\n\t\tret = onenand_write_oob_nolock(mtd, to, ops);\n\tonenand_release_device(mtd);\n\n\treturn ret;\n}\n\n \nstatic int onenand_block_isbad_nolock(struct mtd_info *mtd, loff_t ofs, int allowbbt)\n{\n\tstruct onenand_chip *this = mtd->priv;\n\tstruct bbm_info *bbm = this->bbm;\n\n\t \n\treturn bbm->isbad_bbt(mtd, ofs, allowbbt);\n}\n\n\nstatic int onenand_multiblock_erase_verify(struct mtd_info *mtd,\n\t\t\t\t\t   struct erase_info *instr)\n{\n\tstruct onenand_chip *this = mtd->priv;\n\tloff_t addr = instr->addr;\n\tint len = instr->len;\n\tunsigned int block_size = (1 << this->erase_shift);\n\tint ret = 0;\n\n\twhile (len) {\n\t\tthis->command(mtd, ONENAND_CMD_ERASE_VERIFY, addr, block_size);\n\t\tret = this->wait(mtd, FL_VERIFYING_ERASE);\n\t\tif (ret) {\n\t\t\tprintk(KERN_ERR \"%s: Failed verify, block %d\\n\",\n\t\t\t       __func__, onenand_block(this, addr));\n\t\t\tinstr->fail_addr = addr;\n\t\t\treturn -1;\n\t\t}\n\t\tlen -= block_size;\n\t\taddr += block_size;\n\t}\n\treturn 0;\n}\n\n \nstatic int onenand_multiblock_erase(struct mtd_info *mtd,\n\t\t\t\t    struct erase_info *instr,\n\t\t\t\t    unsigned int block_size)\n{\n\tstruct onenand_chip *this = mtd->priv;\n\tloff_t addr = instr->addr;\n\tint len = instr->len;\n\tint eb_count = 0;\n\tint ret = 0;\n\tint bdry_block = 0;\n\n\tif (ONENAND_IS_DDP(this)) {\n\t\tloff_t bdry_addr = this->chipsize >> 1;\n\t\tif (addr < bdry_addr && (addr + len) > bdry_addr)\n\t\t\tbdry_block = bdry_addr >> this->erase_shift;\n\t}\n\n\t \n\twhile (len) {\n\t\t \n\t\tif (onenand_block_isbad_nolock(mtd, addr, 0)) {\n\t\t\tprintk(KERN_WARNING \"%s: attempt to erase a bad block \"\n\t\t\t       \"at addr 0x%012llx\\n\",\n\t\t\t       __func__, (unsigned long long) addr);\n\t\t\treturn -EIO;\n\t\t}\n\t\tlen -= block_size;\n\t\taddr += block_size;\n\t}\n\n\tlen = instr->len;\n\taddr = instr->addr;\n\n\t \n\twhile (len) {\n\t\tstruct erase_info verify_instr = *instr;\n\t\tint max_eb_count = MB_ERASE_MAX_BLK_COUNT;\n\n\t\tverify_instr.addr = addr;\n\t\tverify_instr.len = 0;\n\n\t\t \n\t\tif (bdry_block) {\n\t\t\tint this_block = (addr >> this->erase_shift);\n\n\t\t\tif (this_block < bdry_block) {\n\t\t\t\tmax_eb_count = min(max_eb_count,\n\t\t\t\t\t\t   (bdry_block - this_block));\n\t\t\t}\n\t\t}\n\n\t\teb_count = 0;\n\n\t\twhile (len > block_size && eb_count < (max_eb_count - 1)) {\n\t\t\tthis->command(mtd, ONENAND_CMD_MULTIBLOCK_ERASE,\n\t\t\t\t      addr, block_size);\n\t\t\tonenand_invalidate_bufferram(mtd, addr, block_size);\n\n\t\t\tret = this->wait(mtd, FL_PREPARING_ERASE);\n\t\t\tif (ret) {\n\t\t\t\tprintk(KERN_ERR \"%s: Failed multiblock erase, \"\n\t\t\t\t       \"block %d\\n\", __func__,\n\t\t\t\t       onenand_block(this, addr));\n\t\t\t\tinstr->fail_addr = MTD_FAIL_ADDR_UNKNOWN;\n\t\t\t\treturn -EIO;\n\t\t\t}\n\n\t\t\tlen -= block_size;\n\t\t\taddr += block_size;\n\t\t\teb_count++;\n\t\t}\n\n\t\t \n\t\tcond_resched();\n\t\tthis->command(mtd, ONENAND_CMD_ERASE, addr, block_size);\n\t\tonenand_invalidate_bufferram(mtd, addr, block_size);\n\n\t\tret = this->wait(mtd, FL_ERASING);\n\t\t \n\t\tif (ret) {\n\t\t\tprintk(KERN_ERR \"%s: Failed erase, block %d\\n\",\n\t\t\t       __func__, onenand_block(this, addr));\n\t\t\tinstr->fail_addr = MTD_FAIL_ADDR_UNKNOWN;\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tlen -= block_size;\n\t\taddr += block_size;\n\t\teb_count++;\n\n\t\t \n\t\tverify_instr.len = eb_count * block_size;\n\t\tif (onenand_multiblock_erase_verify(mtd, &verify_instr)) {\n\t\t\tinstr->fail_addr = verify_instr.fail_addr;\n\t\t\treturn -EIO;\n\t\t}\n\n\t}\n\treturn 0;\n}\n\n\n \nstatic int onenand_block_by_block_erase(struct mtd_info *mtd,\n\t\t\t\t\tstruct erase_info *instr,\n\t\t\t\t\tstruct mtd_erase_region_info *region,\n\t\t\t\t\tunsigned int block_size)\n{\n\tstruct onenand_chip *this = mtd->priv;\n\tloff_t addr = instr->addr;\n\tint len = instr->len;\n\tloff_t region_end = 0;\n\tint ret = 0;\n\n\tif (region) {\n\t\t \n\t\tregion_end = region->offset + region->erasesize * region->numblocks;\n\t}\n\n\t \n\twhile (len) {\n\t\tcond_resched();\n\n\t\t \n\t\tif (onenand_block_isbad_nolock(mtd, addr, 0)) {\n\t\t\tprintk(KERN_WARNING \"%s: attempt to erase a bad block \"\n\t\t\t\t\t\"at addr 0x%012llx\\n\",\n\t\t\t\t\t__func__, (unsigned long long) addr);\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tthis->command(mtd, ONENAND_CMD_ERASE, addr, block_size);\n\n\t\tonenand_invalidate_bufferram(mtd, addr, block_size);\n\n\t\tret = this->wait(mtd, FL_ERASING);\n\t\t \n\t\tif (ret) {\n\t\t\tprintk(KERN_ERR \"%s: Failed erase, block %d\\n\",\n\t\t\t\t__func__, onenand_block(this, addr));\n\t\t\tinstr->fail_addr = addr;\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tlen -= block_size;\n\t\taddr += block_size;\n\n\t\tif (region && addr == region_end) {\n\t\t\tif (!len)\n\t\t\t\tbreak;\n\t\t\tregion++;\n\n\t\t\tblock_size = region->erasesize;\n\t\t\tregion_end = region->offset + region->erasesize * region->numblocks;\n\n\t\t\tif (len & (block_size - 1)) {\n\t\t\t\t \n\t\t\t\tprintk(KERN_ERR \"%s: Unaligned address\\n\",\n\t\t\t\t\t__func__);\n\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\n \nstatic int onenand_erase(struct mtd_info *mtd, struct erase_info *instr)\n{\n\tstruct onenand_chip *this = mtd->priv;\n\tunsigned int block_size;\n\tloff_t addr = instr->addr;\n\tloff_t len = instr->len;\n\tint ret = 0;\n\tstruct mtd_erase_region_info *region = NULL;\n\tloff_t region_offset = 0;\n\n\tpr_debug(\"%s: start=0x%012llx, len=%llu\\n\", __func__,\n\t\t\t(unsigned long long)instr->addr,\n\t\t\t(unsigned long long)instr->len);\n\n\tif (FLEXONENAND(this)) {\n\t\t \n\t\tint i = flexonenand_region(mtd, addr);\n\n\t\tregion = &mtd->eraseregions[i];\n\t\tblock_size = region->erasesize;\n\n\t\t \n\t\tregion_offset = region->offset;\n\t} else\n\t\tblock_size = 1 << this->erase_shift;\n\n\t \n\tif (unlikely((addr - region_offset) & (block_size - 1))) {\n\t\tprintk(KERN_ERR \"%s: Unaligned address\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (unlikely(len & (block_size - 1))) {\n\t\tprintk(KERN_ERR \"%s: Length not block aligned\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tonenand_get_device(mtd, FL_ERASING);\n\n\tif (ONENAND_IS_4KB_PAGE(this) || region ||\n\t    instr->len < MB_ERASE_MIN_BLK_COUNT * block_size) {\n\t\t \n\t\tret = onenand_block_by_block_erase(mtd, instr,\n\t\t\t\t\t\t   region, block_size);\n\t} else {\n\t\tret = onenand_multiblock_erase(mtd, instr, block_size);\n\t}\n\n\t \n\tonenand_release_device(mtd);\n\n\treturn ret;\n}\n\n \nstatic void onenand_sync(struct mtd_info *mtd)\n{\n\tpr_debug(\"%s: called\\n\", __func__);\n\n\t \n\tonenand_get_device(mtd, FL_SYNCING);\n\n\t \n\tonenand_release_device(mtd);\n}\n\n \nstatic int onenand_block_isbad(struct mtd_info *mtd, loff_t ofs)\n{\n\tint ret;\n\n\tonenand_get_device(mtd, FL_READING);\n\tret = onenand_block_isbad_nolock(mtd, ofs, 0);\n\tonenand_release_device(mtd);\n\treturn ret;\n}\n\n \nstatic int onenand_default_block_markbad(struct mtd_info *mtd, loff_t ofs)\n{\n\tstruct onenand_chip *this = mtd->priv;\n\tstruct bbm_info *bbm = this->bbm;\n\tu_char buf[2] = {0, 0};\n\tstruct mtd_oob_ops ops = {\n\t\t.mode = MTD_OPS_PLACE_OOB,\n\t\t.ooblen = 2,\n\t\t.oobbuf = buf,\n\t\t.ooboffs = 0,\n\t};\n\tint block;\n\n\t \n\tblock = onenand_block(this, ofs);\n        if (bbm->bbt)\n                bbm->bbt[block >> 2] |= 0x01 << ((block & 0x03) << 1);\n\n         \n        ofs += mtd->oobsize + (this->badblockpos & ~0x01);\n\t \n\treturn onenand_write_oob_nolock(mtd, ofs, &ops);\n}\n\n \nstatic int onenand_block_markbad(struct mtd_info *mtd, loff_t ofs)\n{\n\tstruct onenand_chip *this = mtd->priv;\n\tint ret;\n\n\tret = onenand_block_isbad(mtd, ofs);\n\tif (ret) {\n\t\t \n\t\tif (ret > 0)\n\t\t\treturn 0;\n\t\treturn ret;\n\t}\n\n\tonenand_get_device(mtd, FL_WRITING);\n\tret = this->block_markbad(mtd, ofs);\n\tonenand_release_device(mtd);\n\treturn ret;\n}\n\n \nstatic int onenand_do_lock_cmd(struct mtd_info *mtd, loff_t ofs, size_t len, int cmd)\n{\n\tstruct onenand_chip *this = mtd->priv;\n\tint start, end, block, value, status;\n\tint wp_status_mask;\n\n\tstart = onenand_block(this, ofs);\n\tend = onenand_block(this, ofs + len) - 1;\n\n\tif (cmd == ONENAND_CMD_LOCK)\n\t\twp_status_mask = ONENAND_WP_LS;\n\telse\n\t\twp_status_mask = ONENAND_WP_US;\n\n\t \n\tif (this->options & ONENAND_HAS_CONT_LOCK) {\n\t\t \n\t\tthis->write_word(start, this->base + ONENAND_REG_START_BLOCK_ADDRESS);\n\t\t \n\t\tthis->write_word(end, this->base +  ONENAND_REG_END_BLOCK_ADDRESS);\n\t\t \n\t\tthis->command(mtd, cmd, 0, 0);\n\n\t\t \n\t\tthis->wait(mtd, FL_LOCKING);\n\n\t\t \n\t\twhile (this->read_word(this->base + ONENAND_REG_CTRL_STATUS)\n\t\t    & ONENAND_CTRL_ONGO)\n\t\t\tcontinue;\n\n\t\t \n\t\tstatus = this->read_word(this->base + ONENAND_REG_WP_STATUS);\n\t\tif (!(status & wp_status_mask))\n\t\t\tprintk(KERN_ERR \"%s: wp status = 0x%x\\n\",\n\t\t\t\t__func__, status);\n\n\t\treturn 0;\n\t}\n\n\t \n\tfor (block = start; block < end + 1; block++) {\n\t\t \n\t\tvalue = onenand_block_address(this, block);\n\t\tthis->write_word(value, this->base + ONENAND_REG_START_ADDRESS1);\n\t\t \n\t\tvalue = onenand_bufferram_address(this, block);\n\t\tthis->write_word(value, this->base + ONENAND_REG_START_ADDRESS2);\n\t\t \n\t\tthis->write_word(block, this->base + ONENAND_REG_START_BLOCK_ADDRESS);\n\t\t \n\t\tthis->command(mtd, cmd, 0, 0);\n\n\t\t \n\t\tthis->wait(mtd, FL_LOCKING);\n\n\t\t \n\t\twhile (this->read_word(this->base + ONENAND_REG_CTRL_STATUS)\n\t\t    & ONENAND_CTRL_ONGO)\n\t\t\tcontinue;\n\n\t\t \n\t\tstatus = this->read_word(this->base + ONENAND_REG_WP_STATUS);\n\t\tif (!(status & wp_status_mask))\n\t\t\tprintk(KERN_ERR \"%s: block = %d, wp status = 0x%x\\n\",\n\t\t\t\t__func__, block, status);\n\t}\n\n\treturn 0;\n}\n\n \nstatic int onenand_lock(struct mtd_info *mtd, loff_t ofs, uint64_t len)\n{\n\tint ret;\n\n\tonenand_get_device(mtd, FL_LOCKING);\n\tret = onenand_do_lock_cmd(mtd, ofs, len, ONENAND_CMD_LOCK);\n\tonenand_release_device(mtd);\n\treturn ret;\n}\n\n \nstatic int onenand_unlock(struct mtd_info *mtd, loff_t ofs, uint64_t len)\n{\n\tint ret;\n\n\tonenand_get_device(mtd, FL_LOCKING);\n\tret = onenand_do_lock_cmd(mtd, ofs, len, ONENAND_CMD_UNLOCK);\n\tonenand_release_device(mtd);\n\treturn ret;\n}\n\n \nstatic int onenand_check_lock_status(struct onenand_chip *this)\n{\n\tunsigned int value, block, status;\n\tunsigned int end;\n\n\tend = this->chipsize >> this->erase_shift;\n\tfor (block = 0; block < end; block++) {\n\t\t \n\t\tvalue = onenand_block_address(this, block);\n\t\tthis->write_word(value, this->base + ONENAND_REG_START_ADDRESS1);\n\t\t \n\t\tvalue = onenand_bufferram_address(this, block);\n\t\tthis->write_word(value, this->base + ONENAND_REG_START_ADDRESS2);\n\t\t \n\t\tthis->write_word(block, this->base + ONENAND_REG_START_BLOCK_ADDRESS);\n\n\t\t \n\t\tstatus = this->read_word(this->base + ONENAND_REG_WP_STATUS);\n\t\tif (!(status & ONENAND_WP_US)) {\n\t\t\tprintk(KERN_ERR \"%s: block = %d, wp status = 0x%x\\n\",\n\t\t\t\t__func__, block, status);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn 1;\n}\n\n \nstatic void onenand_unlock_all(struct mtd_info *mtd)\n{\n\tstruct onenand_chip *this = mtd->priv;\n\tloff_t ofs = 0;\n\tloff_t len = mtd->size;\n\n\tif (this->options & ONENAND_HAS_UNLOCK_ALL) {\n\t\t \n\t\tthis->write_word(0, this->base + ONENAND_REG_START_BLOCK_ADDRESS);\n\t\t \n\t\tthis->command(mtd, ONENAND_CMD_UNLOCK_ALL, 0, 0);\n\n\t\t \n\t\tthis->wait(mtd, FL_LOCKING);\n\n\t\t \n\t\twhile (this->read_word(this->base + ONENAND_REG_CTRL_STATUS)\n\t\t    & ONENAND_CTRL_ONGO)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (this->options & ONENAND_SKIP_UNLOCK_CHECK)\n\t\t\treturn;\n\n\t\t \n\t\tif (onenand_check_lock_status(this))\n\t\t\treturn;\n\n\t\t \n\t\tif (ONENAND_IS_DDP(this) && !FLEXONENAND(this)) {\n\t\t\t \n\t\t\tofs = this->chipsize >> 1;\n\t\t\tlen = this->chipsize >> 1;\n\t\t}\n\t}\n\n\tonenand_do_lock_cmd(mtd, ofs, len, ONENAND_CMD_UNLOCK);\n}\n\n#ifdef CONFIG_MTD_ONENAND_OTP\n\n \nstatic int onenand_otp_command(struct mtd_info *mtd, int cmd, loff_t addr,\n\t\t\t\tsize_t len)\n{\n\tstruct onenand_chip *this = mtd->priv;\n\tint value, block, page;\n\n\t \n\tswitch (cmd) {\n\tcase ONENAND_CMD_OTP_ACCESS:\n\t\tblock = (int) (addr >> this->erase_shift);\n\t\tpage = -1;\n\t\tbreak;\n\n\tdefault:\n\t\tblock = (int) (addr >> this->erase_shift);\n\t\tpage = (int) (addr >> this->page_shift);\n\n\t\tif (ONENAND_IS_2PLANE(this)) {\n\t\t\t \n\t\t\tblock &= ~1;\n\t\t\t \n\t\t\tif (addr & this->writesize)\n\t\t\t\tblock++;\n\t\t\tpage >>= 1;\n\t\t}\n\t\tpage &= this->page_mask;\n\t\tbreak;\n\t}\n\n\tif (block != -1) {\n\t\t \n\t\tvalue = onenand_block_address(this, block);\n\t\tthis->write_word(value, this->base +\n\t\t\t\tONENAND_REG_START_ADDRESS1);\n\t}\n\n\tif (page != -1) {\n\t\t \n\t\tint sectors = 4, count = 4;\n\t\tint dataram;\n\n\t\tswitch (cmd) {\n\t\tdefault:\n\t\t\tif (ONENAND_IS_2PLANE(this) && cmd == ONENAND_CMD_PROG)\n\t\t\t\tcmd = ONENAND_CMD_2X_PROG;\n\t\t\tdataram = ONENAND_CURRENT_BUFFERRAM(this);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tvalue = onenand_page_address(page, sectors);\n\t\tthis->write_word(value, this->base +\n\t\t\t\tONENAND_REG_START_ADDRESS8);\n\n\t\t \n\t\tvalue = onenand_buffer_address(dataram, sectors, count);\n\t\tthis->write_word(value, this->base + ONENAND_REG_START_BUFFER);\n\t}\n\n\t \n\tthis->write_word(ONENAND_INT_CLEAR, this->base + ONENAND_REG_INTERRUPT);\n\n\t \n\tthis->write_word(cmd, this->base + ONENAND_REG_COMMAND);\n\n\treturn 0;\n}\n\n \nstatic int onenand_otp_write_oob_nolock(struct mtd_info *mtd, loff_t to,\n\t\t\t\t    struct mtd_oob_ops *ops)\n{\n\tstruct onenand_chip *this = mtd->priv;\n\tint column, ret = 0, oobsize;\n\tint written = 0;\n\tu_char *oobbuf;\n\tsize_t len = ops->ooblen;\n\tconst u_char *buf = ops->oobbuf;\n\tint block, value, status;\n\n\tto += ops->ooboffs;\n\n\t \n\tops->oobretlen = 0;\n\n\toobsize = mtd->oobsize;\n\n\tcolumn = to & (mtd->oobsize - 1);\n\n\toobbuf = this->oob_buf;\n\n\t \n\twhile (written < len) {\n\t\tint thislen = min_t(int, oobsize, len - written);\n\n\t\tcond_resched();\n\n\t\tblock = (int) (to >> this->erase_shift);\n\t\t \n\n\t\tvalue = onenand_block_address(this, block);\n\t\tthis->write_word(value, this->base +\n\t\t\t\tONENAND_REG_START_ADDRESS1);\n\n\t\t \n\n\t\tvalue = onenand_bufferram_address(this, block);\n\t\tthis->write_word(value, this->base +\n\t\t\t\tONENAND_REG_START_ADDRESS2);\n\t\tONENAND_SET_NEXT_BUFFERRAM(this);\n\n\t\t \n\t\tthis->command(mtd, ONENAND_CMD_OTP_ACCESS, 0, 0);\n\t\tthis->wait(mtd, FL_OTPING);\n\n\t\t \n\t\tmemcpy(oobbuf + column, buf, thislen);\n\n\t\t \n\t\tthis->write_bufferram(mtd, ONENAND_SPARERAM,\n\t\t\t\t\toobbuf, 0, mtd->oobsize);\n\n\t\tonenand_otp_command(mtd, ONENAND_CMD_PROGOOB, to, mtd->oobsize);\n\t\tonenand_update_bufferram(mtd, to, 0);\n\t\tif (ONENAND_IS_2PLANE(this)) {\n\t\t\tONENAND_SET_BUFFERRAM1(this);\n\t\t\tonenand_update_bufferram(mtd, to + this->writesize, 0);\n\t\t}\n\n\t\tret = this->wait(mtd, FL_WRITING);\n\t\tif (ret) {\n\t\t\tprintk(KERN_ERR \"%s: write failed %d\\n\", __func__, ret);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tthis->command(mtd, ONENAND_CMD_RESET, 0, 0);\n\t\tthis->wait(mtd, FL_RESETTING);\n\n\t\tstatus = this->read_word(this->base + ONENAND_REG_CTRL_STATUS);\n\t\tstatus &= 0x60;\n\n\t\tif (status == 0x60) {\n\t\t\tprintk(KERN_DEBUG \"\\nBLOCK\\tSTATUS\\n\");\n\t\t\tprintk(KERN_DEBUG \"1st Block\\tLOCKED\\n\");\n\t\t\tprintk(KERN_DEBUG \"OTP Block\\tLOCKED\\n\");\n\t\t} else if (status == 0x20) {\n\t\t\tprintk(KERN_DEBUG \"\\nBLOCK\\tSTATUS\\n\");\n\t\t\tprintk(KERN_DEBUG \"1st Block\\tLOCKED\\n\");\n\t\t\tprintk(KERN_DEBUG \"OTP Block\\tUN-LOCKED\\n\");\n\t\t} else if (status == 0x40) {\n\t\t\tprintk(KERN_DEBUG \"\\nBLOCK\\tSTATUS\\n\");\n\t\t\tprintk(KERN_DEBUG \"1st Block\\tUN-LOCKED\\n\");\n\t\t\tprintk(KERN_DEBUG \"OTP Block\\tLOCKED\\n\");\n\t\t} else {\n\t\t\tprintk(KERN_DEBUG \"Reboot to check\\n\");\n\t\t}\n\n\t\twritten += thislen;\n\t\tif (written == len)\n\t\t\tbreak;\n\n\t\tto += mtd->writesize;\n\t\tbuf += thislen;\n\t\tcolumn = 0;\n\t}\n\n\tops->oobretlen = written;\n\n\treturn ret;\n}\n\n \ntypedef int (*otp_op_t)(struct mtd_info *mtd, loff_t form, size_t len,\n\t\tsize_t *retlen, u_char *buf);\n\n \nstatic int do_otp_read(struct mtd_info *mtd, loff_t from, size_t len,\n\t\tsize_t *retlen, u_char *buf)\n{\n\tstruct onenand_chip *this = mtd->priv;\n\tstruct mtd_oob_ops ops = {\n\t\t.len\t= len,\n\t\t.ooblen\t= 0,\n\t\t.datbuf\t= buf,\n\t\t.oobbuf\t= NULL,\n\t};\n\tint ret;\n\n\t \n\tthis->command(mtd, ONENAND_CMD_OTP_ACCESS, 0, 0);\n\tthis->wait(mtd, FL_OTPING);\n\n\tret = ONENAND_IS_4KB_PAGE(this) ?\n\t\tonenand_mlc_read_ops_nolock(mtd, from, &ops) :\n\t\tonenand_read_ops_nolock(mtd, from, &ops);\n\n\t \n\tthis->command(mtd, ONENAND_CMD_RESET, 0, 0);\n\tthis->wait(mtd, FL_RESETTING);\n\n\treturn ret;\n}\n\n \nstatic int do_otp_write(struct mtd_info *mtd, loff_t to, size_t len,\n\t\tsize_t *retlen, u_char *buf)\n{\n\tstruct onenand_chip *this = mtd->priv;\n\tunsigned char *pbuf = buf;\n\tint ret;\n\tstruct mtd_oob_ops ops = { };\n\n\t \n\tif (len < mtd->writesize) {\n\t\tmemcpy(this->page_buf, buf, len);\n\t\tmemset(this->page_buf + len, 0xff, mtd->writesize - len);\n\t\tpbuf = this->page_buf;\n\t\tlen = mtd->writesize;\n\t}\n\n\t \n\tthis->command(mtd, ONENAND_CMD_OTP_ACCESS, 0, 0);\n\tthis->wait(mtd, FL_OTPING);\n\n\tops.len = len;\n\tops.ooblen = 0;\n\tops.datbuf = pbuf;\n\tops.oobbuf = NULL;\n\tret = onenand_write_ops_nolock(mtd, to, &ops);\n\t*retlen = ops.retlen;\n\n\t \n\tthis->command(mtd, ONENAND_CMD_RESET, 0, 0);\n\tthis->wait(mtd, FL_RESETTING);\n\n\treturn ret;\n}\n\n \nstatic int do_otp_lock(struct mtd_info *mtd, loff_t from, size_t len,\n\t\tsize_t *retlen, u_char *buf)\n{\n\tstruct onenand_chip *this = mtd->priv;\n\tstruct mtd_oob_ops ops = { };\n\tint ret;\n\n\tif (FLEXONENAND(this)) {\n\n\t\t \n\t\tthis->command(mtd, ONENAND_CMD_OTP_ACCESS, 0, 0);\n\t\tthis->wait(mtd, FL_OTPING);\n\t\t \n\t\tops.len = mtd->writesize;\n\t\tops.ooblen = 0;\n\t\tops.datbuf = buf;\n\t\tops.oobbuf = NULL;\n\t\tret = onenand_write_ops_nolock(mtd, mtd->writesize * 49, &ops);\n\t\t*retlen = ops.retlen;\n\n\t\t \n\t\tthis->command(mtd, ONENAND_CMD_RESET, 0, 0);\n\t\tthis->wait(mtd, FL_RESETTING);\n\t} else {\n\t\tops.mode = MTD_OPS_PLACE_OOB;\n\t\tops.ooblen = len;\n\t\tops.oobbuf = buf;\n\t\tops.ooboffs = 0;\n\t\tret = onenand_otp_write_oob_nolock(mtd, from, &ops);\n\t\t*retlen = ops.oobretlen;\n\t}\n\n\treturn ret;\n}\n\n \nstatic int onenand_otp_walk(struct mtd_info *mtd, loff_t from, size_t len,\n\t\t\tsize_t *retlen, u_char *buf,\n\t\t\totp_op_t action, int mode)\n{\n\tstruct onenand_chip *this = mtd->priv;\n\tint otp_pages;\n\tint density;\n\tint ret = 0;\n\n\t*retlen = 0;\n\n\tdensity = onenand_get_density(this->device_id);\n\tif (density < ONENAND_DEVICE_DENSITY_512Mb)\n\t\totp_pages = 20;\n\telse\n\t\totp_pages = 50;\n\n\tif (mode == MTD_OTP_FACTORY) {\n\t\tfrom += mtd->writesize * otp_pages;\n\t\totp_pages = ONENAND_PAGES_PER_BLOCK - otp_pages;\n\t}\n\n\t \n\tif (mode == MTD_OTP_USER) {\n\t\tif (mtd->writesize * otp_pages < from + len)\n\t\t\treturn 0;\n\t} else {\n\t\tif (mtd->writesize * otp_pages <  len)\n\t\t\treturn 0;\n\t}\n\n\tonenand_get_device(mtd, FL_OTPING);\n\twhile (len > 0 && otp_pages > 0) {\n\t\tif (!action) {\t \n\t\t\tstruct otp_info *otpinfo;\n\n\t\t\tlen -= sizeof(struct otp_info);\n\t\t\tif (len <= 0) {\n\t\t\t\tret = -ENOSPC;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\totpinfo = (struct otp_info *) buf;\n\t\t\totpinfo->start = from;\n\t\t\totpinfo->length = mtd->writesize;\n\t\t\totpinfo->locked = 0;\n\n\t\t\tfrom += mtd->writesize;\n\t\t\tbuf += sizeof(struct otp_info);\n\t\t\t*retlen += sizeof(struct otp_info);\n\t\t} else {\n\t\t\tsize_t tmp_retlen;\n\n\t\t\tret = action(mtd, from, len, &tmp_retlen, buf);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\n\t\t\tbuf += tmp_retlen;\n\t\t\tlen -= tmp_retlen;\n\t\t\t*retlen += tmp_retlen;\n\n\t\t}\n\t\totp_pages--;\n\t}\n\tonenand_release_device(mtd);\n\n\treturn ret;\n}\n\n \nstatic int onenand_get_fact_prot_info(struct mtd_info *mtd, size_t len,\n\t\t\t\t      size_t *retlen, struct otp_info *buf)\n{\n\treturn onenand_otp_walk(mtd, 0, len, retlen, (u_char *) buf, NULL,\n\t\t\t\tMTD_OTP_FACTORY);\n}\n\n \nstatic int onenand_read_fact_prot_reg(struct mtd_info *mtd, loff_t from,\n\t\t\tsize_t len, size_t *retlen, u_char *buf)\n{\n\treturn onenand_otp_walk(mtd, from, len, retlen, buf, do_otp_read, MTD_OTP_FACTORY);\n}\n\n \nstatic int onenand_get_user_prot_info(struct mtd_info *mtd, size_t len,\n\t\t\t\t      size_t *retlen, struct otp_info *buf)\n{\n\treturn onenand_otp_walk(mtd, 0, len, retlen, (u_char *) buf, NULL,\n\t\t\t\tMTD_OTP_USER);\n}\n\n \nstatic int onenand_read_user_prot_reg(struct mtd_info *mtd, loff_t from,\n\t\t\tsize_t len, size_t *retlen, u_char *buf)\n{\n\treturn onenand_otp_walk(mtd, from, len, retlen, buf, do_otp_read, MTD_OTP_USER);\n}\n\n \nstatic int onenand_write_user_prot_reg(struct mtd_info *mtd, loff_t from,\n\t\t\tsize_t len, size_t *retlen, const u_char *buf)\n{\n\treturn onenand_otp_walk(mtd, from, len, retlen, (u_char *)buf,\n\t\t\t\tdo_otp_write, MTD_OTP_USER);\n}\n\n \nstatic int onenand_lock_user_prot_reg(struct mtd_info *mtd, loff_t from,\n\t\t\tsize_t len)\n{\n\tstruct onenand_chip *this = mtd->priv;\n\tu_char *buf = FLEXONENAND(this) ? this->page_buf : this->oob_buf;\n\tsize_t retlen;\n\tint ret;\n\tunsigned int otp_lock_offset = ONENAND_OTP_LOCK_OFFSET;\n\n\tmemset(buf, 0xff, FLEXONENAND(this) ? this->writesize\n\t\t\t\t\t\t : mtd->oobsize);\n\t \n\n\tfrom = 0;\n\tlen = FLEXONENAND(this) ? mtd->writesize : 16;\n\n\t \n\tif (FLEXONENAND(this))\n\t\totp_lock_offset = FLEXONENAND_OTP_LOCK_OFFSET;\n\n\t \n\tif (otp == 1)\n\t\tbuf[otp_lock_offset] = 0xFC;\n\telse if (otp == 2)\n\t\tbuf[otp_lock_offset] = 0xF3;\n\telse if (otp == 3)\n\t\tbuf[otp_lock_offset] = 0xF0;\n\telse if (otp != 0)\n\t\tprintk(KERN_DEBUG \"[OneNAND] Invalid option selected for OTP\\n\");\n\n\tret = onenand_otp_walk(mtd, from, len, &retlen, buf, do_otp_lock, MTD_OTP_USER);\n\n\treturn ret ? : retlen;\n}\n\n#endif\t \n\n \nstatic void onenand_check_features(struct mtd_info *mtd)\n{\n\tstruct onenand_chip *this = mtd->priv;\n\tunsigned int density, process, numbufs;\n\n\t \n\tdensity = onenand_get_density(this->device_id);\n\tprocess = this->version_id >> ONENAND_VERSION_PROCESS_SHIFT;\n\tnumbufs = this->read_word(this->base + ONENAND_REG_NUM_BUFFERS) >> 8;\n\n\t \n\tswitch (density) {\n\tcase ONENAND_DEVICE_DENSITY_8Gb:\n\t\tthis->options |= ONENAND_HAS_NOP_1;\n\t\tfallthrough;\n\tcase ONENAND_DEVICE_DENSITY_4Gb:\n\t\tif (ONENAND_IS_DDP(this))\n\t\t\tthis->options |= ONENAND_HAS_2PLANE;\n\t\telse if (numbufs == 1) {\n\t\t\tthis->options |= ONENAND_HAS_4KB_PAGE;\n\t\t\tthis->options |= ONENAND_HAS_CACHE_PROGRAM;\n\t\t\t \n\t\t\tif ((this->version_id & 0xf) == 0xe)\n\t\t\t\tthis->options |= ONENAND_HAS_NOP_1;\n\t\t}\n\t\tthis->options |= ONENAND_HAS_UNLOCK_ALL;\n\t\tbreak;\n\n\tcase ONENAND_DEVICE_DENSITY_2Gb:\n\t\t \n\t\tif (!ONENAND_IS_DDP(this))\n\t\t\tthis->options |= ONENAND_HAS_2PLANE;\n\t\tthis->options |= ONENAND_HAS_UNLOCK_ALL;\n\t\tbreak;\n\n\tcase ONENAND_DEVICE_DENSITY_1Gb:\n\t\t \n\t\tif (process)\n\t\t\tthis->options |= ONENAND_HAS_UNLOCK_ALL;\n\t\tbreak;\n\n\tdefault:\n\t\t \n\t\tif (!process)\n\t\t\tthis->options |= ONENAND_HAS_CONT_LOCK;\n\t\tbreak;\n\t}\n\n\t \n\tif (ONENAND_IS_MLC(this))\n\t\tthis->options |= ONENAND_HAS_4KB_PAGE;\n\n\tif (ONENAND_IS_4KB_PAGE(this))\n\t\tthis->options &= ~ONENAND_HAS_2PLANE;\n\n\tif (FLEXONENAND(this)) {\n\t\tthis->options &= ~ONENAND_HAS_CONT_LOCK;\n\t\tthis->options |= ONENAND_HAS_UNLOCK_ALL;\n\t}\n\n\tif (this->options & ONENAND_HAS_CONT_LOCK)\n\t\tprintk(KERN_DEBUG \"Lock scheme is Continuous Lock\\n\");\n\tif (this->options & ONENAND_HAS_UNLOCK_ALL)\n\t\tprintk(KERN_DEBUG \"Chip support all block unlock\\n\");\n\tif (this->options & ONENAND_HAS_2PLANE)\n\t\tprintk(KERN_DEBUG \"Chip has 2 plane\\n\");\n\tif (this->options & ONENAND_HAS_4KB_PAGE)\n\t\tprintk(KERN_DEBUG \"Chip has 4KiB pagesize\\n\");\n\tif (this->options & ONENAND_HAS_CACHE_PROGRAM)\n\t\tprintk(KERN_DEBUG \"Chip has cache program feature\\n\");\n}\n\n \nstatic void onenand_print_device_info(int device, int version)\n{\n\tint vcc, demuxed, ddp, density, flexonenand;\n\n        vcc = device & ONENAND_DEVICE_VCC_MASK;\n        demuxed = device & ONENAND_DEVICE_IS_DEMUX;\n        ddp = device & ONENAND_DEVICE_IS_DDP;\n        density = onenand_get_density(device);\n\tflexonenand = device & DEVICE_IS_FLEXONENAND;\n\tprintk(KERN_INFO \"%s%sOneNAND%s %dMB %sV 16-bit (0x%02x)\\n\",\n\t\tdemuxed ? \"\" : \"Muxed \",\n\t\tflexonenand ? \"Flex-\" : \"\",\n                ddp ? \"(DDP)\" : \"\",\n                (16 << density),\n                vcc ? \"2.65/3.3\" : \"1.8\",\n                device);\n\tprintk(KERN_INFO \"OneNAND version = 0x%04x\\n\", version);\n}\n\nstatic const struct onenand_manufacturers onenand_manuf_ids[] = {\n        {ONENAND_MFR_SAMSUNG, \"Samsung\"},\n\t{ONENAND_MFR_NUMONYX, \"Numonyx\"},\n};\n\n \nstatic int onenand_check_maf(int manuf)\n{\n\tint size = ARRAY_SIZE(onenand_manuf_ids);\n\tchar *name;\n        int i;\n\n\tfor (i = 0; i < size; i++)\n                if (manuf == onenand_manuf_ids[i].id)\n                        break;\n\n\tif (i < size)\n\t\tname = onenand_manuf_ids[i].name;\n\telse\n\t\tname = \"Unknown\";\n\n\tprintk(KERN_DEBUG \"OneNAND Manufacturer: %s (0x%0x)\\n\", name, manuf);\n\n\treturn (i == size);\n}\n\n \nstatic int flexonenand_get_boundary(struct mtd_info *mtd)\n{\n\tstruct onenand_chip *this = mtd->priv;\n\tunsigned die, bdry;\n\tint syscfg, locked;\n\n\t \n\tsyscfg = this->read_word(this->base + ONENAND_REG_SYS_CFG1);\n\tthis->write_word((syscfg | 0x0100), this->base + ONENAND_REG_SYS_CFG1);\n\n\tfor (die = 0; die < this->dies; die++) {\n\t\tthis->command(mtd, FLEXONENAND_CMD_PI_ACCESS, die, 0);\n\t\tthis->wait(mtd, FL_SYNCING);\n\n\t\tthis->command(mtd, FLEXONENAND_CMD_READ_PI, die, 0);\n\t\tthis->wait(mtd, FL_READING);\n\n\t\tbdry = this->read_word(this->base + ONENAND_DATARAM);\n\t\tif ((bdry >> FLEXONENAND_PI_UNLOCK_SHIFT) == 3)\n\t\t\tlocked = 0;\n\t\telse\n\t\t\tlocked = 1;\n\t\tthis->boundary[die] = bdry & FLEXONENAND_PI_MASK;\n\n\t\tthis->command(mtd, ONENAND_CMD_RESET, 0, 0);\n\t\tthis->wait(mtd, FL_RESETTING);\n\n\t\tprintk(KERN_INFO \"Die %d boundary: %d%s\\n\", die,\n\t\t       this->boundary[die], locked ? \"(Locked)\" : \"(Unlocked)\");\n\t}\n\n\t \n\tthis->write_word(syscfg, this->base + ONENAND_REG_SYS_CFG1);\n\treturn 0;\n}\n\n \nstatic void flexonenand_get_size(struct mtd_info *mtd)\n{\n\tstruct onenand_chip *this = mtd->priv;\n\tint die, i, eraseshift, density;\n\tint blksperdie, maxbdry;\n\tloff_t ofs;\n\n\tdensity = onenand_get_density(this->device_id);\n\tblksperdie = ((loff_t)(16 << density) << 20) >> (this->erase_shift);\n\tblksperdie >>= ONENAND_IS_DDP(this) ? 1 : 0;\n\tmaxbdry = blksperdie - 1;\n\teraseshift = this->erase_shift - 1;\n\n\tmtd->numeraseregions = this->dies << 1;\n\n\t \n\tflexonenand_get_boundary(mtd);\n\tdie = ofs = 0;\n\ti = -1;\n\tfor (; die < this->dies; die++) {\n\t\tif (!die || this->boundary[die-1] != maxbdry) {\n\t\t\ti++;\n\t\t\tmtd->eraseregions[i].offset = ofs;\n\t\t\tmtd->eraseregions[i].erasesize = 1 << eraseshift;\n\t\t\tmtd->eraseregions[i].numblocks =\n\t\t\t\t\t\t\tthis->boundary[die] + 1;\n\t\t\tofs += mtd->eraseregions[i].numblocks << eraseshift;\n\t\t\teraseshift++;\n\t\t} else {\n\t\t\tmtd->numeraseregions -= 1;\n\t\t\tmtd->eraseregions[i].numblocks +=\n\t\t\t\t\t\t\tthis->boundary[die] + 1;\n\t\t\tofs += (this->boundary[die] + 1) << (eraseshift - 1);\n\t\t}\n\t\tif (this->boundary[die] != maxbdry) {\n\t\t\ti++;\n\t\t\tmtd->eraseregions[i].offset = ofs;\n\t\t\tmtd->eraseregions[i].erasesize = 1 << eraseshift;\n\t\t\tmtd->eraseregions[i].numblocks = maxbdry ^\n\t\t\t\t\t\t\t this->boundary[die];\n\t\t\tofs += mtd->eraseregions[i].numblocks << eraseshift;\n\t\t\teraseshift--;\n\t\t} else\n\t\t\tmtd->numeraseregions -= 1;\n\t}\n\n\t \n\tmtd->erasesize = 1 << this->erase_shift;\n\tif (mtd->numeraseregions == 1)\n\t\tmtd->erasesize >>= 1;\n\n\tprintk(KERN_INFO \"Device has %d eraseregions\\n\", mtd->numeraseregions);\n\tfor (i = 0; i < mtd->numeraseregions; i++)\n\t\tprintk(KERN_INFO \"[offset: 0x%08x, erasesize: 0x%05x,\"\n\t\t\t\" numblocks: %04u]\\n\",\n\t\t\t(unsigned int) mtd->eraseregions[i].offset,\n\t\t\tmtd->eraseregions[i].erasesize,\n\t\t\tmtd->eraseregions[i].numblocks);\n\n\tfor (die = 0, mtd->size = 0; die < this->dies; die++) {\n\t\tthis->diesize[die] = (loff_t)blksperdie << this->erase_shift;\n\t\tthis->diesize[die] -= (loff_t)(this->boundary[die] + 1)\n\t\t\t\t\t\t << (this->erase_shift - 1);\n\t\tmtd->size += this->diesize[die];\n\t}\n}\n\n \nstatic int flexonenand_check_blocks_erased(struct mtd_info *mtd, int start, int end)\n{\n\tstruct onenand_chip *this = mtd->priv;\n\tint i, ret;\n\tint block;\n\tstruct mtd_oob_ops ops = {\n\t\t.mode = MTD_OPS_PLACE_OOB,\n\t\t.ooboffs = 0,\n\t\t.ooblen\t= mtd->oobsize,\n\t\t.datbuf\t= NULL,\n\t\t.oobbuf\t= this->oob_buf,\n\t};\n\tloff_t addr;\n\n\tprintk(KERN_DEBUG \"Check blocks from %d to %d\\n\", start, end);\n\n\tfor (block = start; block <= end; block++) {\n\t\taddr = flexonenand_addr(this, block);\n\t\tif (onenand_block_isbad_nolock(mtd, addr, 0))\n\t\t\tcontinue;\n\n\t\t \n\t\tret = onenand_read_oob_nolock(mtd, addr, &ops);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tfor (i = 0; i < mtd->oobsize; i++)\n\t\t\tif (this->oob_buf[i] != 0xff)\n\t\t\t\tbreak;\n\n\t\tif (i != mtd->oobsize) {\n\t\t\tprintk(KERN_WARNING \"%s: Block %d not erased.\\n\",\n\t\t\t\t__func__, block);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic int flexonenand_set_boundary(struct mtd_info *mtd, int die,\n\t\t\t\t    int boundary, int lock)\n{\n\tstruct onenand_chip *this = mtd->priv;\n\tint ret, density, blksperdie, old, new, thisboundary;\n\tloff_t addr;\n\n\t \n\tif (die && (!ONENAND_IS_DDP(this)))\n\t\treturn 0;\n\n\t \n\tif (boundary < 0 || boundary == this->boundary[die])\n\t\treturn 0;\n\n\tdensity = onenand_get_density(this->device_id);\n\tblksperdie = ((16 << density) << 20) >> this->erase_shift;\n\tblksperdie >>= ONENAND_IS_DDP(this) ? 1 : 0;\n\n\tif (boundary >= blksperdie) {\n\t\tprintk(KERN_ERR \"%s: Invalid boundary value. \"\n\t\t\t\t\"Boundary not changed.\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\told = this->boundary[die] + (die * this->density_mask);\n\tnew = boundary + (die * this->density_mask);\n\tret = flexonenand_check_blocks_erased(mtd, min(old, new) + 1, max(old, new));\n\tif (ret) {\n\t\tprintk(KERN_ERR \"%s: Please erase blocks \"\n\t\t\t\t\"before boundary change\\n\", __func__);\n\t\treturn ret;\n\t}\n\n\tthis->command(mtd, FLEXONENAND_CMD_PI_ACCESS, die, 0);\n\tthis->wait(mtd, FL_SYNCING);\n\n\t \n\tthis->command(mtd, FLEXONENAND_CMD_READ_PI, die, 0);\n\tthis->wait(mtd, FL_READING);\n\n\tthisboundary = this->read_word(this->base + ONENAND_DATARAM);\n\tif ((thisboundary >> FLEXONENAND_PI_UNLOCK_SHIFT) != 3) {\n\t\tprintk(KERN_ERR \"%s: boundary locked\\n\", __func__);\n\t\tret = 1;\n\t\tgoto out;\n\t}\n\n\tprintk(KERN_INFO \"Changing die %d boundary: %d%s\\n\",\n\t\t\tdie, boundary, lock ? \"(Locked)\" : \"(Unlocked)\");\n\n\taddr = die ? this->diesize[0] : 0;\n\n\tboundary &= FLEXONENAND_PI_MASK;\n\tboundary |= lock ? 0 : (3 << FLEXONENAND_PI_UNLOCK_SHIFT);\n\n\tthis->command(mtd, ONENAND_CMD_ERASE, addr, 0);\n\tret = this->wait(mtd, FL_ERASING);\n\tif (ret) {\n\t\tprintk(KERN_ERR \"%s: Failed PI erase for Die %d\\n\",\n\t\t       __func__, die);\n\t\tgoto out;\n\t}\n\n\tthis->write_word(boundary, this->base + ONENAND_DATARAM);\n\tthis->command(mtd, ONENAND_CMD_PROG, addr, 0);\n\tret = this->wait(mtd, FL_WRITING);\n\tif (ret) {\n\t\tprintk(KERN_ERR \"%s: Failed PI write for Die %d\\n\",\n\t\t\t__func__, die);\n\t\tgoto out;\n\t}\n\n\tthis->command(mtd, FLEXONENAND_CMD_PI_UPDATE, die, 0);\n\tret = this->wait(mtd, FL_WRITING);\nout:\n\tthis->write_word(ONENAND_CMD_RESET, this->base + ONENAND_REG_COMMAND);\n\tthis->wait(mtd, FL_RESETTING);\n\tif (!ret)\n\t\t \n\t\tflexonenand_get_size(mtd);\n\n\treturn ret;\n}\n\n \nstatic int onenand_chip_probe(struct mtd_info *mtd)\n{\n\tstruct onenand_chip *this = mtd->priv;\n\tint bram_maf_id, bram_dev_id, maf_id, dev_id;\n\tint syscfg;\n\n\t \n\tsyscfg = this->read_word(this->base + ONENAND_REG_SYS_CFG1);\n\t \n\tthis->write_word((syscfg & ~ONENAND_SYS_CFG1_SYNC_READ & ~ONENAND_SYS_CFG1_SYNC_WRITE), this->base + ONENAND_REG_SYS_CFG1);\n\n\t \n\tthis->write_word(ONENAND_CMD_READID, this->base + ONENAND_BOOTRAM);\n\n\t \n\tbram_maf_id = this->read_word(this->base + ONENAND_BOOTRAM + 0x0);\n\tbram_dev_id = this->read_word(this->base + ONENAND_BOOTRAM + 0x2);\n\n\t \n\tthis->write_word(ONENAND_CMD_RESET, this->base + ONENAND_BOOTRAM);\n\t \n\tthis->wait(mtd, FL_RESETTING);\n\n\t \n\tthis->write_word(syscfg, this->base + ONENAND_REG_SYS_CFG1);\n\n\t \n\tif (onenand_check_maf(bram_maf_id))\n\t\treturn -ENXIO;\n\n\t \n\tmaf_id = this->read_word(this->base + ONENAND_REG_MANUFACTURER_ID);\n\tdev_id = this->read_word(this->base + ONENAND_REG_DEVICE_ID);\n\n\t \n\tif (maf_id != bram_maf_id || dev_id != bram_dev_id)\n\t\treturn -ENXIO;\n\n\treturn 0;\n}\n\n \nstatic int onenand_probe(struct mtd_info *mtd)\n{\n\tstruct onenand_chip *this = mtd->priv;\n\tint dev_id, ver_id;\n\tint density;\n\tint ret;\n\n\tret = this->chip_probe(mtd);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tdev_id = this->read_word(this->base + ONENAND_REG_DEVICE_ID);\n\tver_id = this->read_word(this->base + ONENAND_REG_VERSION_ID);\n\tthis->technology = this->read_word(this->base + ONENAND_REG_TECHNOLOGY);\n\n\t \n\tonenand_print_device_info(dev_id, ver_id);\n\tthis->device_id = dev_id;\n\tthis->version_id = ver_id;\n\n\t \n\tonenand_check_features(mtd);\n\n\tdensity = onenand_get_density(dev_id);\n\tif (FLEXONENAND(this)) {\n\t\tthis->dies = ONENAND_IS_DDP(this) ? 2 : 1;\n\t\t \n\t\tmtd->numeraseregions = this->dies << 1;\n\t\tmtd->eraseregions =\n\t\t\tkcalloc(this->dies << 1,\n\t\t\t\tsizeof(struct mtd_erase_region_info),\n\t\t\t\tGFP_KERNEL);\n\t\tif (!mtd->eraseregions)\n\t\t\treturn -ENOMEM;\n\t}\n\n\t \n\tthis->chipsize = (16 << density) << 20;\n\n\t \n\t \n\tmtd->writesize = this->read_word(this->base + ONENAND_REG_DATA_BUFFER_SIZE);\n\t \n\tif (ONENAND_IS_4KB_PAGE(this))\n\t\tmtd->writesize <<= 1;\n\n\tmtd->oobsize = mtd->writesize >> 5;\n\t \n\tmtd->erasesize = mtd->writesize << 6;\n\t \n\tif (FLEXONENAND(this))\n\t\tmtd->erasesize <<= 1;\n\n\tthis->erase_shift = ffs(mtd->erasesize) - 1;\n\tthis->page_shift = ffs(mtd->writesize) - 1;\n\tthis->page_mask = (1 << (this->erase_shift - this->page_shift)) - 1;\n\t \n\tif (ONENAND_IS_DDP(this))\n\t\tthis->density_mask = this->chipsize >> (this->erase_shift + 1);\n\t \n\tthis->writesize = mtd->writesize;\n\n\t \n\n\tif (FLEXONENAND(this))\n\t\tflexonenand_get_size(mtd);\n\telse\n\t\tmtd->size = this->chipsize;\n\n\t \n\tif (ONENAND_IS_2PLANE(this)) {\n\t\tmtd->writesize <<= 1;\n\t\tmtd->erasesize <<= 1;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int onenand_suspend(struct mtd_info *mtd)\n{\n\treturn onenand_get_device(mtd, FL_PM_SUSPENDED);\n}\n\n \nstatic void onenand_resume(struct mtd_info *mtd)\n{\n\tstruct onenand_chip *this = mtd->priv;\n\n\tif (this->state == FL_PM_SUSPENDED)\n\t\tonenand_release_device(mtd);\n\telse\n\t\tprintk(KERN_ERR \"%s: resume() called for the chip which is not \"\n\t\t\t\t\"in suspended state\\n\", __func__);\n}\n\n \nint onenand_scan(struct mtd_info *mtd, int maxchips)\n{\n\tint i, ret;\n\tstruct onenand_chip *this = mtd->priv;\n\n\tif (!this->read_word)\n\t\tthis->read_word = onenand_readw;\n\tif (!this->write_word)\n\t\tthis->write_word = onenand_writew;\n\n\tif (!this->command)\n\t\tthis->command = onenand_command;\n\tif (!this->wait)\n\t\tonenand_setup_wait(mtd);\n\tif (!this->bbt_wait)\n\t\tthis->bbt_wait = onenand_bbt_wait;\n\tif (!this->unlock_all)\n\t\tthis->unlock_all = onenand_unlock_all;\n\n\tif (!this->chip_probe)\n\t\tthis->chip_probe = onenand_chip_probe;\n\n\tif (!this->read_bufferram)\n\t\tthis->read_bufferram = onenand_read_bufferram;\n\tif (!this->write_bufferram)\n\t\tthis->write_bufferram = onenand_write_bufferram;\n\n\tif (!this->block_markbad)\n\t\tthis->block_markbad = onenand_default_block_markbad;\n\tif (!this->scan_bbt)\n\t\tthis->scan_bbt = onenand_default_bbt;\n\n\tif (onenand_probe(mtd))\n\t\treturn -ENXIO;\n\n\t \n\tif (this->mmcontrol) {\n\t\tprintk(KERN_INFO \"OneNAND Sync. Burst Read support\\n\");\n\t\tthis->read_bufferram = onenand_sync_read_bufferram;\n\t}\n\n\t \n\tif (!this->page_buf) {\n\t\tthis->page_buf = kzalloc(mtd->writesize, GFP_KERNEL);\n\t\tif (!this->page_buf)\n\t\t\treturn -ENOMEM;\n#ifdef CONFIG_MTD_ONENAND_VERIFY_WRITE\n\t\tthis->verify_buf = kzalloc(mtd->writesize, GFP_KERNEL);\n\t\tif (!this->verify_buf) {\n\t\t\tkfree(this->page_buf);\n\t\t\treturn -ENOMEM;\n\t\t}\n#endif\n\t\tthis->options |= ONENAND_PAGEBUF_ALLOC;\n\t}\n\tif (!this->oob_buf) {\n\t\tthis->oob_buf = kzalloc(mtd->oobsize, GFP_KERNEL);\n\t\tif (!this->oob_buf) {\n\t\t\tif (this->options & ONENAND_PAGEBUF_ALLOC) {\n\t\t\t\tthis->options &= ~ONENAND_PAGEBUF_ALLOC;\n#ifdef CONFIG_MTD_ONENAND_VERIFY_WRITE\n\t\t\t\tkfree(this->verify_buf);\n#endif\n\t\t\t\tkfree(this->page_buf);\n\t\t\t}\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tthis->options |= ONENAND_OOBBUF_ALLOC;\n\t}\n\n\tthis->state = FL_READY;\n\tinit_waitqueue_head(&this->wq);\n\tspin_lock_init(&this->chip_lock);\n\n\t \n\tswitch (mtd->oobsize) {\n\tcase 128:\n\t\tif (FLEXONENAND(this)) {\n\t\t\tmtd_set_ooblayout(mtd, &flexonenand_ooblayout_ops);\n\t\t\tmtd->subpage_sft = 0;\n\t\t} else {\n\t\t\tmtd_set_ooblayout(mtd, &onenand_oob_128_ooblayout_ops);\n\t\t\tmtd->subpage_sft = 2;\n\t\t}\n\t\tif (ONENAND_IS_NOP_1(this))\n\t\t\tmtd->subpage_sft = 0;\n\t\tbreak;\n\tcase 64:\n\t\tmtd_set_ooblayout(mtd, &onenand_oob_32_64_ooblayout_ops);\n\t\tmtd->subpage_sft = 2;\n\t\tbreak;\n\n\tcase 32:\n\t\tmtd_set_ooblayout(mtd, &onenand_oob_32_64_ooblayout_ops);\n\t\tmtd->subpage_sft = 1;\n\t\tbreak;\n\n\tdefault:\n\t\tprintk(KERN_WARNING \"%s: No OOB scheme defined for oobsize %d\\n\",\n\t\t\t__func__, mtd->oobsize);\n\t\tmtd->subpage_sft = 0;\n\t\t \n\t\tmtd_set_ooblayout(mtd, &onenand_oob_32_64_ooblayout_ops);\n\t\tbreak;\n\t}\n\n\tthis->subpagesize = mtd->writesize >> mtd->subpage_sft;\n\n\t \n\tret = mtd_ooblayout_count_freebytes(mtd);\n\tif (ret < 0)\n\t\tret = 0;\n\n\tmtd->oobavail = ret;\n\n\tmtd->ecc_strength = 1;\n\n\t \n\tmtd->type = ONENAND_IS_MLC(this) ? MTD_MLCNANDFLASH : MTD_NANDFLASH;\n\tmtd->flags = MTD_CAP_NANDFLASH;\n\tmtd->_erase = onenand_erase;\n\tmtd->_point = NULL;\n\tmtd->_unpoint = NULL;\n\tmtd->_read_oob = onenand_read_oob;\n\tmtd->_write_oob = onenand_write_oob;\n\tmtd->_panic_write = onenand_panic_write;\n#ifdef CONFIG_MTD_ONENAND_OTP\n\tmtd->_get_fact_prot_info = onenand_get_fact_prot_info;\n\tmtd->_read_fact_prot_reg = onenand_read_fact_prot_reg;\n\tmtd->_get_user_prot_info = onenand_get_user_prot_info;\n\tmtd->_read_user_prot_reg = onenand_read_user_prot_reg;\n\tmtd->_write_user_prot_reg = onenand_write_user_prot_reg;\n\tmtd->_lock_user_prot_reg = onenand_lock_user_prot_reg;\n#endif\n\tmtd->_sync = onenand_sync;\n\tmtd->_lock = onenand_lock;\n\tmtd->_unlock = onenand_unlock;\n\tmtd->_suspend = onenand_suspend;\n\tmtd->_resume = onenand_resume;\n\tmtd->_block_isbad = onenand_block_isbad;\n\tmtd->_block_markbad = onenand_block_markbad;\n\tmtd->owner = THIS_MODULE;\n\tmtd->writebufsize = mtd->writesize;\n\n\t \n\tif (!(this->options & ONENAND_SKIP_INITIAL_UNLOCKING))\n\t\tthis->unlock_all(mtd);\n\n\t \n\tthis->badblockpos = ONENAND_BADBLOCK_POS;\n\n\tret = this->scan_bbt(mtd);\n\tif ((!FLEXONENAND(this)) || ret)\n\t\treturn ret;\n\n\t \n\tfor (i = 0; i < MAX_DIES; i++)\n\t\tflexonenand_set_boundary(mtd, i, flex_bdry[2 * i],\n\t\t\t\t\t\t flex_bdry[(2 * i) + 1]);\n\n\treturn 0;\n}\n\n \nvoid onenand_release(struct mtd_info *mtd)\n{\n\tstruct onenand_chip *this = mtd->priv;\n\n\t \n\tmtd_device_unregister(mtd);\n\n\t \n\tif (this->bbm) {\n\t\tstruct bbm_info *bbm = this->bbm;\n\t\tkfree(bbm->bbt);\n\t\tkfree(this->bbm);\n\t}\n\t \n\tif (this->options & ONENAND_PAGEBUF_ALLOC) {\n\t\tkfree(this->page_buf);\n#ifdef CONFIG_MTD_ONENAND_VERIFY_WRITE\n\t\tkfree(this->verify_buf);\n#endif\n\t}\n\tif (this->options & ONENAND_OOBBUF_ALLOC)\n\t\tkfree(this->oob_buf);\n\tkfree(mtd->eraseregions);\n}\n\nEXPORT_SYMBOL_GPL(onenand_scan);\nEXPORT_SYMBOL_GPL(onenand_release);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Kyungmin Park <kyungmin.park@samsung.com>\");\nMODULE_DESCRIPTION(\"Generic OneNAND flash driver code\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}