{
  "module_name": "onenand_bbt.c",
  "hash_id": "0e5318405ef78947a0f4cfde9abc7b263feff3428742fe230e986e660a4ed4f3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/nand/onenand/onenand_bbt.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <linux/mtd/mtd.h>\n#include <linux/mtd/onenand.h>\n#include <linux/export.h>\n\n \nstatic int check_short_pattern(uint8_t *buf, int len, int paglen, struct nand_bbt_descr *td)\n{\n\tint i;\n\tuint8_t *p = buf;\n\n\t \n\tfor (i = 0; i < td->len; i++) {\n\t\tif (p[i] != td->pattern[i])\n\t\t\treturn -1;\n\t}\n        return 0;\n}\n\n \nstatic int create_bbt(struct mtd_info *mtd, uint8_t *buf, struct nand_bbt_descr *bd, int chip)\n{\n\tstruct onenand_chip *this = mtd->priv;\n\tstruct bbm_info *bbm = this->bbm;\n\tint i, j, numblocks, len, scanlen;\n\tint startblock;\n\tloff_t from;\n\tsize_t readlen;\n\tstruct mtd_oob_ops ops = { };\n\tint rgn;\n\n\tprintk(KERN_INFO \"Scanning device for bad blocks\\n\");\n\n\tlen = 2;\n\n\t \n\tscanlen = 0;\n\treadlen = bd->len;\n\n\t \n\t \n\tnumblocks = this->chipsize >> (bbm->bbt_erase_shift - 1);\n\tstartblock = 0;\n\tfrom = 0;\n\n\tops.mode = MTD_OPS_PLACE_OOB;\n\tops.ooblen = readlen;\n\tops.oobbuf = buf;\n\tops.len = ops.ooboffs = ops.retlen = ops.oobretlen = 0;\n\n\tfor (i = startblock; i < numblocks; ) {\n\t\tint ret;\n\n\t\tfor (j = 0; j < len; j++) {\n\t\t\t \n\t\t\tret = onenand_bbt_read_oob(mtd,\n\t\t\t\tfrom + j * this->writesize + bd->offs, &ops);\n\n\t\t\t \n\t\t\tif (ret == ONENAND_BBT_READ_FATAL_ERROR)\n\t\t\t\treturn -EIO;\n\n\t\t\tif (ret || check_short_pattern(&buf[j * scanlen],\n\t\t\t\t\t       scanlen, this->writesize, bd)) {\n\t\t\t\tbbm->bbt[i >> 3] |= 0x03 << (i & 0x6);\n\t\t\t\tprintk(KERN_INFO \"OneNAND eraseblock %d is an \"\n\t\t\t\t\t\"initial bad block\\n\", i >> 1);\n\t\t\t\tmtd->ecc_stats.badblocks++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\ti += 2;\n\n\t\tif (FLEXONENAND(this)) {\n\t\t\trgn = flexonenand_region(mtd, from);\n\t\t\tfrom += mtd->eraseregions[rgn].erasesize;\n\t\t} else\n\t\t\tfrom += (1 << bbm->bbt_erase_shift);\n\t}\n\n\treturn 0;\n}\n\n\n \nstatic inline int onenand_memory_bbt (struct mtd_info *mtd, struct nand_bbt_descr *bd)\n{\n\tstruct onenand_chip *this = mtd->priv;\n\n\treturn create_bbt(mtd, this->page_buf, bd, -1);\n}\n\n \nstatic int onenand_isbad_bbt(struct mtd_info *mtd, loff_t offs, int allowbbt)\n{\n\tstruct onenand_chip *this = mtd->priv;\n\tstruct bbm_info *bbm = this->bbm;\n\tint block;\n\tuint8_t res;\n\n\t \n\tblock = (int) (onenand_block(this, offs) << 1);\n\tres = (bbm->bbt[block >> 3] >> (block & 0x06)) & 0x03;\n\n\tpr_debug(\"onenand_isbad_bbt: bbt info for offs 0x%08x: (block %d) 0x%02x\\n\",\n\t\t(unsigned int) offs, block >> 1, res);\n\n\tswitch ((int) res) {\n\tcase 0x00:\treturn 0;\n\tcase 0x01:\treturn 1;\n\tcase 0x02:\treturn allowbbt ? 0 : 1;\n\t}\n\n\treturn 1;\n}\n\n \nstatic int onenand_scan_bbt(struct mtd_info *mtd, struct nand_bbt_descr *bd)\n{\n\tstruct onenand_chip *this = mtd->priv;\n\tstruct bbm_info *bbm = this->bbm;\n\tint len, ret = 0;\n\n\tlen = this->chipsize >> (this->erase_shift + 2);\n\t \n\tbbm->bbt = kzalloc(len, GFP_KERNEL);\n\tif (!bbm->bbt)\n\t\treturn -ENOMEM;\n\n\t \n\tbbm->bbt_erase_shift = this->erase_shift;\n\n\tif (!bbm->isbad_bbt)\n\t\tbbm->isbad_bbt = onenand_isbad_bbt;\n\n\t \n\tif ((ret = onenand_memory_bbt(mtd, bd))) {\n\t\tprintk(KERN_ERR \"onenand_scan_bbt: Can't scan flash and build the RAM-based BBT\\n\");\n\t\tkfree(bbm->bbt);\n\t\tbbm->bbt = NULL;\n\t}\n\n\treturn ret;\n}\n\n \nstatic uint8_t scan_ff_pattern[] = { 0xff, 0xff };\n\nstatic struct nand_bbt_descr largepage_memorybased = {\n\t.options = 0,\n\t.offs = 0,\n\t.len = 2,\n\t.pattern = scan_ff_pattern,\n};\n\n \nint onenand_default_bbt(struct mtd_info *mtd)\n{\n\tstruct onenand_chip *this = mtd->priv;\n\tstruct bbm_info *bbm;\n\n\tthis->bbm = kzalloc(sizeof(struct bbm_info), GFP_KERNEL);\n\tif (!this->bbm)\n\t\treturn -ENOMEM;\n\n\tbbm = this->bbm;\n\n\t \n\tif (!bbm->badblock_pattern)\n\t\tbbm->badblock_pattern = &largepage_memorybased;\n\n\treturn onenand_scan_bbt(mtd, bbm->badblock_pattern);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}