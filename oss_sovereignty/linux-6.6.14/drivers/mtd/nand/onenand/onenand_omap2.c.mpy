{
  "module_name": "onenand_omap2.c",
  "hash_id": "e3da37f0df2e67d8541bb6d48fdd5c827f3e0860b8882335413186f263a313a3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/nand/onenand/onenand_omap2.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/module.h>\n#include <linux/mtd/mtd.h>\n#include <linux/mtd/onenand.h>\n#include <linux/mtd/partitions.h>\n#include <linux/of.h>\n#include <linux/omap-gpmc.h>\n#include <linux/platform_device.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n#include <linux/dma-mapping.h>\n#include <linux/dmaengine.h>\n#include <linux/io.h>\n#include <linux/slab.h>\n#include <linux/gpio/consumer.h>\n\n#include <asm/mach/flash.h>\n\n#define DRIVER_NAME \"omap2-onenand\"\n\n#define ONENAND_BUFRAM_SIZE\t(1024 * 5)\n\nstruct omap2_onenand {\n\tstruct platform_device *pdev;\n\tint gpmc_cs;\n\tunsigned long phys_base;\n\tstruct gpio_desc *int_gpiod;\n\tstruct mtd_info mtd;\n\tstruct onenand_chip onenand;\n\tstruct completion irq_done;\n\tstruct completion dma_done;\n\tstruct dma_chan *dma_chan;\n};\n\nstatic void omap2_onenand_dma_complete_func(void *completion)\n{\n\tcomplete(completion);\n}\n\nstatic irqreturn_t omap2_onenand_interrupt(int irq, void *dev_id)\n{\n\tstruct omap2_onenand *c = dev_id;\n\n\tcomplete(&c->irq_done);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic inline unsigned short read_reg(struct omap2_onenand *c, int reg)\n{\n\treturn readw(c->onenand.base + reg);\n}\n\nstatic inline void write_reg(struct omap2_onenand *c, unsigned short value,\n\t\t\t     int reg)\n{\n\twritew(value, c->onenand.base + reg);\n}\n\nstatic int omap2_onenand_set_cfg(struct omap2_onenand *c,\n\t\t\t\t bool sr, bool sw,\n\t\t\t\t int latency, int burst_len)\n{\n\tunsigned short reg = ONENAND_SYS_CFG1_RDY | ONENAND_SYS_CFG1_INT;\n\n\treg |= latency << ONENAND_SYS_CFG1_BRL_SHIFT;\n\n\tswitch (burst_len) {\n\tcase 0:\t\t \n\t\tbreak;\n\tcase 4:\n\t\treg |= ONENAND_SYS_CFG1_BL_4;\n\t\tbreak;\n\tcase 8:\n\t\treg |= ONENAND_SYS_CFG1_BL_8;\n\t\tbreak;\n\tcase 16:\n\t\treg |= ONENAND_SYS_CFG1_BL_16;\n\t\tbreak;\n\tcase 32:\n\t\treg |= ONENAND_SYS_CFG1_BL_32;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (latency > 5)\n\t\treg |= ONENAND_SYS_CFG1_HF;\n\tif (latency > 7)\n\t\treg |= ONENAND_SYS_CFG1_VHF;\n\tif (sr)\n\t\treg |= ONENAND_SYS_CFG1_SYNC_READ;\n\tif (sw)\n\t\treg |= ONENAND_SYS_CFG1_SYNC_WRITE;\n\n\twrite_reg(c, reg, ONENAND_REG_SYS_CFG1);\n\n\treturn 0;\n}\n\nstatic int omap2_onenand_get_freq(int ver)\n{\n\tswitch ((ver >> 4) & 0xf) {\n\tcase 0:\n\t\treturn 40;\n\tcase 1:\n\t\treturn 54;\n\tcase 2:\n\t\treturn 66;\n\tcase 3:\n\t\treturn 83;\n\tcase 4:\n\t\treturn 104;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic void wait_err(char *msg, int state, unsigned int ctrl, unsigned int intr)\n{\n\tprintk(KERN_ERR \"onenand_wait: %s! state %d ctrl 0x%04x intr 0x%04x\\n\",\n\t       msg, state, ctrl, intr);\n}\n\nstatic void wait_warn(char *msg, int state, unsigned int ctrl,\n\t\t      unsigned int intr)\n{\n\tprintk(KERN_WARNING \"onenand_wait: %s! state %d ctrl 0x%04x \"\n\t       \"intr 0x%04x\\n\", msg, state, ctrl, intr);\n}\n\nstatic int omap2_onenand_wait(struct mtd_info *mtd, int state)\n{\n\tstruct omap2_onenand *c = container_of(mtd, struct omap2_onenand, mtd);\n\tstruct onenand_chip *this = mtd->priv;\n\tunsigned int intr = 0;\n\tunsigned int ctrl, ctrl_mask;\n\tunsigned long timeout;\n\tu32 syscfg;\n\n\tif (state == FL_RESETTING || state == FL_PREPARING_ERASE ||\n\t    state == FL_VERIFYING_ERASE) {\n\t\tint i = 21;\n\t\tunsigned int intr_flags = ONENAND_INT_MASTER;\n\n\t\tswitch (state) {\n\t\tcase FL_RESETTING:\n\t\t\tintr_flags |= ONENAND_INT_RESET;\n\t\t\tbreak;\n\t\tcase FL_PREPARING_ERASE:\n\t\t\tintr_flags |= ONENAND_INT_ERASE;\n\t\t\tbreak;\n\t\tcase FL_VERIFYING_ERASE:\n\t\t\ti = 101;\n\t\t\tbreak;\n\t\t}\n\n\t\twhile (--i) {\n\t\t\tudelay(1);\n\t\t\tintr = read_reg(c, ONENAND_REG_INTERRUPT);\n\t\t\tif (intr & ONENAND_INT_MASTER)\n\t\t\t\tbreak;\n\t\t}\n\t\tctrl = read_reg(c, ONENAND_REG_CTRL_STATUS);\n\t\tif (ctrl & ONENAND_CTRL_ERROR) {\n\t\t\twait_err(\"controller error\", state, ctrl, intr);\n\t\t\treturn -EIO;\n\t\t}\n\t\tif ((intr & intr_flags) == intr_flags)\n\t\t\treturn 0;\n\t\t \n\t}\n\n\tif (state != FL_READING) {\n\t\tint result;\n\n\t\t \n\t\tsyscfg = read_reg(c, ONENAND_REG_SYS_CFG1);\n\t\tif (!(syscfg & ONENAND_SYS_CFG1_IOBE)) {\n\t\t\tsyscfg |= ONENAND_SYS_CFG1_IOBE;\n\t\t\twrite_reg(c, syscfg, ONENAND_REG_SYS_CFG1);\n\t\t\t \n\t\t\tsyscfg = read_reg(c, ONENAND_REG_SYS_CFG1);\n\t\t}\n\n\t\treinit_completion(&c->irq_done);\n\t\tresult = gpiod_get_value(c->int_gpiod);\n\t\tif (result < 0) {\n\t\t\tctrl = read_reg(c, ONENAND_REG_CTRL_STATUS);\n\t\t\tintr = read_reg(c, ONENAND_REG_INTERRUPT);\n\t\t\twait_err(\"gpio error\", state, ctrl, intr);\n\t\t\treturn result;\n\t\t} else if (result == 0) {\n\t\t\tint retry_cnt = 0;\nretry:\n\t\t\tif (!wait_for_completion_io_timeout(&c->irq_done,\n\t\t\t\t\t\tmsecs_to_jiffies(20))) {\n\t\t\t\t \n\t\t\t\tctrl = read_reg(c, ONENAND_REG_CTRL_STATUS);\n\t\t\t\tif (ctrl & ONENAND_CTRL_ONGO &&\n\t\t\t\t    !this->ongoing) {\n\t\t\t\t\t \n\t\t\t\t\tretry_cnt += 1;\n\t\t\t\t\tif (retry_cnt < 3)\n\t\t\t\t\t\tgoto retry;\n\t\t\t\t\tintr = read_reg(c,\n\t\t\t\t\t\t\tONENAND_REG_INTERRUPT);\n\t\t\t\t\twait_err(\"timeout\", state, ctrl, intr);\n\t\t\t\t\treturn -EIO;\n\t\t\t\t}\n\t\t\t\tintr = read_reg(c, ONENAND_REG_INTERRUPT);\n\t\t\t\tif ((intr & ONENAND_INT_MASTER) == 0)\n\t\t\t\t\twait_warn(\"timeout\", state, ctrl, intr);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tint retry_cnt = 0;\n\n\t\t \n\t\tsyscfg = read_reg(c, ONENAND_REG_SYS_CFG1);\n\t\tsyscfg &= ~ONENAND_SYS_CFG1_IOBE;\n\t\twrite_reg(c, syscfg, ONENAND_REG_SYS_CFG1);\n\n\t\ttimeout = jiffies + msecs_to_jiffies(20);\n\t\twhile (1) {\n\t\t\tif (time_before(jiffies, timeout)) {\n\t\t\t\tintr = read_reg(c, ONENAND_REG_INTERRUPT);\n\t\t\t\tif (intr & ONENAND_INT_MASTER)\n\t\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tctrl = read_reg(c, ONENAND_REG_CTRL_STATUS);\n\t\t\t\tif (ctrl & ONENAND_CTRL_ONGO) {\n\t\t\t\t\t \n\t\t\t\t\tretry_cnt += 1;\n\t\t\t\t\tif (retry_cnt < 3) {\n\t\t\t\t\t\ttimeout = jiffies +\n\t\t\t\t\t\t\t  msecs_to_jiffies(20);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tintr = read_reg(c, ONENAND_REG_INTERRUPT);\n\tctrl = read_reg(c, ONENAND_REG_CTRL_STATUS);\n\n\tif (intr & ONENAND_INT_READ) {\n\t\tint ecc = read_reg(c, ONENAND_REG_ECC_STATUS);\n\n\t\tif (ecc) {\n\t\t\tunsigned int addr1, addr8;\n\n\t\t\taddr1 = read_reg(c, ONENAND_REG_START_ADDRESS1);\n\t\t\taddr8 = read_reg(c, ONENAND_REG_START_ADDRESS8);\n\t\t\tif (ecc & ONENAND_ECC_2BIT_ALL) {\n\t\t\t\tprintk(KERN_ERR \"onenand_wait: ECC error = \"\n\t\t\t\t       \"0x%04x, addr1 %#x, addr8 %#x\\n\",\n\t\t\t\t       ecc, addr1, addr8);\n\t\t\t\tmtd->ecc_stats.failed++;\n\t\t\t\treturn -EBADMSG;\n\t\t\t} else if (ecc & ONENAND_ECC_1BIT_ALL) {\n\t\t\t\tprintk(KERN_NOTICE \"onenand_wait: correctable \"\n\t\t\t\t       \"ECC error = 0x%04x, addr1 %#x, \"\n\t\t\t\t       \"addr8 %#x\\n\", ecc, addr1, addr8);\n\t\t\t\tmtd->ecc_stats.corrected++;\n\t\t\t}\n\t\t}\n\t} else if (state == FL_READING) {\n\t\twait_err(\"timeout\", state, ctrl, intr);\n\t\treturn -EIO;\n\t}\n\n\tif (ctrl & ONENAND_CTRL_ERROR) {\n\t\twait_err(\"controller error\", state, ctrl, intr);\n\t\tif (ctrl & ONENAND_CTRL_LOCK)\n\t\t\tprintk(KERN_ERR \"onenand_wait: \"\n\t\t\t\t\t\"Device is write protected!!!\\n\");\n\t\treturn -EIO;\n\t}\n\n\tctrl_mask = 0xFE9F;\n\tif (this->ongoing)\n\t\tctrl_mask &= ~0x8000;\n\n\tif (ctrl & ctrl_mask)\n\t\twait_warn(\"unexpected controller status\", state, ctrl, intr);\n\n\treturn 0;\n}\n\nstatic inline int omap2_onenand_bufferram_offset(struct mtd_info *mtd, int area)\n{\n\tstruct onenand_chip *this = mtd->priv;\n\n\tif (ONENAND_CURRENT_BUFFERRAM(this)) {\n\t\tif (area == ONENAND_DATARAM)\n\t\t\treturn this->writesize;\n\t\tif (area == ONENAND_SPARERAM)\n\t\t\treturn mtd->oobsize;\n\t}\n\n\treturn 0;\n}\n\nstatic inline int omap2_onenand_dma_transfer(struct omap2_onenand *c,\n\t\t\t\t\t     dma_addr_t src, dma_addr_t dst,\n\t\t\t\t\t     size_t count)\n{\n\tstruct dma_async_tx_descriptor *tx;\n\tdma_cookie_t cookie;\n\n\ttx = dmaengine_prep_dma_memcpy(c->dma_chan, dst, src, count,\n\t\t\t\t       DMA_CTRL_ACK | DMA_PREP_INTERRUPT);\n\tif (!tx) {\n\t\tdev_err(&c->pdev->dev, \"Failed to prepare DMA memcpy\\n\");\n\t\treturn -EIO;\n\t}\n\n\treinit_completion(&c->dma_done);\n\n\ttx->callback = omap2_onenand_dma_complete_func;\n\ttx->callback_param = &c->dma_done;\n\n\tcookie = tx->tx_submit(tx);\n\tif (dma_submit_error(cookie)) {\n\t\tdev_err(&c->pdev->dev, \"Failed to do DMA tx_submit\\n\");\n\t\treturn -EIO;\n\t}\n\n\tdma_async_issue_pending(c->dma_chan);\n\n\tif (!wait_for_completion_io_timeout(&c->dma_done,\n\t\t\t\t\t    msecs_to_jiffies(20))) {\n\t\tdmaengine_terminate_sync(c->dma_chan);\n\t\treturn -ETIMEDOUT;\n\t}\n\n\treturn 0;\n}\n\nstatic int omap2_onenand_read_bufferram(struct mtd_info *mtd, int area,\n\t\t\t\t\tunsigned char *buffer, int offset,\n\t\t\t\t\tsize_t count)\n{\n\tstruct omap2_onenand *c = container_of(mtd, struct omap2_onenand, mtd);\n\tstruct onenand_chip *this = mtd->priv;\n\tstruct device *dev = &c->pdev->dev;\n\tvoid *buf = (void *)buffer;\n\tdma_addr_t dma_src, dma_dst;\n\tint bram_offset, err;\n\tsize_t xtra;\n\n\tbram_offset = omap2_onenand_bufferram_offset(mtd, area) + area + offset;\n\t \n\tif (!virt_addr_valid(buf) || bram_offset & 3 || (size_t)buf & 3 ||\n\t    count < 384 || mtd->oops_panic_write)\n\t\tgoto out_copy;\n\n\txtra = count & 3;\n\tif (xtra) {\n\t\tcount -= xtra;\n\t\tmemcpy(buf + count, this->base + bram_offset + count, xtra);\n\t}\n\n\tdma_dst = dma_map_single(dev, buf, count, DMA_FROM_DEVICE);\n\tdma_src = c->phys_base + bram_offset;\n\n\tif (dma_mapping_error(dev, dma_dst)) {\n\t\tdev_err(dev, \"Couldn't DMA map a %d byte buffer\\n\", count);\n\t\tgoto out_copy;\n\t}\n\n\terr = omap2_onenand_dma_transfer(c, dma_src, dma_dst, count);\n\tdma_unmap_single(dev, dma_dst, count, DMA_FROM_DEVICE);\n\tif (!err)\n\t\treturn 0;\n\n\tdev_err(dev, \"timeout waiting for DMA\\n\");\n\nout_copy:\n\tmemcpy(buf, this->base + bram_offset, count);\n\treturn 0;\n}\n\nstatic int omap2_onenand_write_bufferram(struct mtd_info *mtd, int area,\n\t\t\t\t\t const unsigned char *buffer,\n\t\t\t\t\t int offset, size_t count)\n{\n\tstruct omap2_onenand *c = container_of(mtd, struct omap2_onenand, mtd);\n\tstruct onenand_chip *this = mtd->priv;\n\tstruct device *dev = &c->pdev->dev;\n\tvoid *buf = (void *)buffer;\n\tdma_addr_t dma_src, dma_dst;\n\tint bram_offset, err;\n\n\tbram_offset = omap2_onenand_bufferram_offset(mtd, area) + area + offset;\n\t \n\tif (!virt_addr_valid(buf) || bram_offset & 3 || (size_t)buf & 3 ||\n\t    count < 384 || mtd->oops_panic_write)\n\t\tgoto out_copy;\n\n\tdma_src = dma_map_single(dev, buf, count, DMA_TO_DEVICE);\n\tdma_dst = c->phys_base + bram_offset;\n\tif (dma_mapping_error(dev, dma_src)) {\n\t\tdev_err(dev, \"Couldn't DMA map a %d byte buffer\\n\", count);\n\t\tgoto out_copy;\n\t}\n\n\terr = omap2_onenand_dma_transfer(c, dma_src, dma_dst, count);\n\tdma_unmap_page(dev, dma_src, count, DMA_TO_DEVICE);\n\tif (!err)\n\t\treturn 0;\n\n\tdev_err(dev, \"timeout waiting for DMA\\n\");\n\nout_copy:\n\tmemcpy(this->base + bram_offset, buf, count);\n\treturn 0;\n}\n\nstatic void omap2_onenand_shutdown(struct platform_device *pdev)\n{\n\tstruct omap2_onenand *c = dev_get_drvdata(&pdev->dev);\n\n\t \n\tmemset((__force void *)c->onenand.base, 0, ONENAND_BUFRAM_SIZE);\n}\n\nstatic int omap2_onenand_probe(struct platform_device *pdev)\n{\n\tu32 val;\n\tdma_cap_mask_t mask;\n\tint freq, latency, r;\n\tstruct resource *res;\n\tstruct omap2_onenand *c;\n\tstruct gpmc_onenand_info info;\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np = dev->of_node;\n\n\tr = of_property_read_u32(np, \"reg\", &val);\n\tif (r) {\n\t\tdev_err(dev, \"reg not found in DT\\n\");\n\t\treturn r;\n\t}\n\n\tc = devm_kzalloc(dev, sizeof(struct omap2_onenand), GFP_KERNEL);\n\tif (!c)\n\t\treturn -ENOMEM;\n\n\tinit_completion(&c->irq_done);\n\tinit_completion(&c->dma_done);\n\tc->gpmc_cs = val;\n\n\tc->onenand.base = devm_platform_get_and_ioremap_resource(pdev, 0, &res);\n\tif (IS_ERR(c->onenand.base))\n\t\treturn PTR_ERR(c->onenand.base);\n\tc->phys_base = res->start;\n\n\tc->int_gpiod = devm_gpiod_get_optional(dev, \"int\", GPIOD_IN);\n\tif (IS_ERR(c->int_gpiod)) {\n\t\t \n\t\treturn dev_err_probe(dev, PTR_ERR(c->int_gpiod), \"error getting gpio\\n\");\n\t}\n\n\tif (c->int_gpiod) {\n\t\tr = devm_request_irq(dev, gpiod_to_irq(c->int_gpiod),\n\t\t\t\t     omap2_onenand_interrupt,\n\t\t\t\t     IRQF_TRIGGER_RISING, \"onenand\", c);\n\t\tif (r)\n\t\t\treturn r;\n\n\t\tc->onenand.wait = omap2_onenand_wait;\n\t}\n\n\tdma_cap_zero(mask);\n\tdma_cap_set(DMA_MEMCPY, mask);\n\n\tc->dma_chan = dma_request_channel(mask, NULL, NULL);\n\tif (c->dma_chan) {\n\t\tc->onenand.read_bufferram = omap2_onenand_read_bufferram;\n\t\tc->onenand.write_bufferram = omap2_onenand_write_bufferram;\n\t}\n\n\tc->pdev = pdev;\n\tc->mtd.priv = &c->onenand;\n\tc->mtd.dev.parent = dev;\n\tmtd_set_of_node(&c->mtd, dev->of_node);\n\n\tdev_info(dev, \"initializing on CS%d (0x%08lx), va %p, %s mode\\n\",\n\t\t c->gpmc_cs, c->phys_base, c->onenand.base,\n\t\t c->dma_chan ? \"DMA\" : \"PIO\");\n\n\tr = onenand_scan(&c->mtd, 1);\n\tif (r < 0)\n\t\tgoto err_release_dma;\n\n\tfreq = omap2_onenand_get_freq(c->onenand.version_id);\n\tif (freq > 0) {\n\t\tswitch (freq) {\n\t\tcase 104:\n\t\t\tlatency = 7;\n\t\t\tbreak;\n\t\tcase 83:\n\t\t\tlatency = 6;\n\t\t\tbreak;\n\t\tcase 66:\n\t\t\tlatency = 5;\n\t\t\tbreak;\n\t\tcase 56:\n\t\t\tlatency = 4;\n\t\t\tbreak;\n\t\tdefault:\t \n\t\t\tlatency = 3;\n\t\t\tbreak;\n\t\t}\n\n\t\tr = gpmc_omap_onenand_set_timings(dev, c->gpmc_cs,\n\t\t\t\t\t\t  freq, latency, &info);\n\t\tif (r)\n\t\t\tgoto err_release_onenand;\n\n\t\tr = omap2_onenand_set_cfg(c, info.sync_read, info.sync_write,\n\t\t\t\t\t  latency, info.burst_len);\n\t\tif (r)\n\t\t\tgoto err_release_onenand;\n\n\t\tif (info.sync_read || info.sync_write)\n\t\t\tdev_info(dev, \"optimized timings for %d MHz\\n\", freq);\n\t}\n\n\tr = mtd_device_register(&c->mtd, NULL, 0);\n\tif (r)\n\t\tgoto err_release_onenand;\n\n\tplatform_set_drvdata(pdev, c);\n\n\treturn 0;\n\nerr_release_onenand:\n\tonenand_release(&c->mtd);\nerr_release_dma:\n\tif (c->dma_chan)\n\t\tdma_release_channel(c->dma_chan);\n\n\treturn r;\n}\n\nstatic void omap2_onenand_remove(struct platform_device *pdev)\n{\n\tstruct omap2_onenand *c = dev_get_drvdata(&pdev->dev);\n\n\tonenand_release(&c->mtd);\n\tif (c->dma_chan)\n\t\tdma_release_channel(c->dma_chan);\n\tomap2_onenand_shutdown(pdev);\n}\n\nstatic const struct of_device_id omap2_onenand_id_table[] = {\n\t{ .compatible = \"ti,omap2-onenand\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, omap2_onenand_id_table);\n\nstatic struct platform_driver omap2_onenand_driver = {\n\t.probe\t\t= omap2_onenand_probe,\n\t.remove_new\t= omap2_onenand_remove,\n\t.shutdown\t= omap2_onenand_shutdown,\n\t.driver\t\t= {\n\t\t.name\t= DRIVER_NAME,\n\t\t.of_match_table = omap2_onenand_id_table,\n\t},\n};\n\nmodule_platform_driver(omap2_onenand_driver);\n\nMODULE_ALIAS(\"platform:\" DRIVER_NAME);\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Jarkko Lavinen <jarkko.lavinen@nokia.com>\");\nMODULE_DESCRIPTION(\"Glue layer for OneNAND flash on OMAP2 / OMAP3\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}