{
  "module_name": "ecc-mxic.c",
  "hash_id": "aadcab9dcd44853c2b148609ac32fffe2b52020b499b9bb88aa21bcd67720c9d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/nand/ecc-mxic.c",
  "human_readable_source": "\n \n\n#include <linux/dma-mapping.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/mtd/mtd.h>\n#include <linux/mtd/nand.h>\n#include <linux/mtd/nand-ecc-mxic.h>\n#include <linux/mutex.h>\n#include <linux/of.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n\n \n#define DP_CONFIG 0x00\n#define   ECC_EN BIT(0)\n#define   ECC_TYP(idx) (((idx) << 3) & GENMASK(6, 3))\n \n#define INTRPT_STS 0x04\n#define   TRANS_CMPLT BIT(0)\n#define   SDMA_MAIN BIT(1)\n#define   SDMA_SPARE BIT(2)\n#define   ECC_ERR BIT(3)\n#define   TO_SPARE BIT(4)\n#define   TO_MAIN BIT(5)\n \n#define INTRPT_STS_EN 0x08\n \n#define INTRPT_SIG_EN 0x0C\n \n#define HC_CONFIG 0x10\n#define   DEV2MEM 0  \n#define   MEM2MEM BIT(4)  \n#define   MAPPING BIT(5)  \n#define   ECC_PACKED 0  \n#define   ECC_INTERLEAVED BIT(2)  \n#define   BURST_TYP_FIXED 0\n#define   BURST_TYP_INCREASING BIT(0)\n \n#define HC_SLV_ADDR 0x14\n \n#define CHUNK_SIZE 0x20\n \n#define MAIN_SIZE 0x24\n \n#define SPARE_SIZE 0x28\n#define   META_SZ(reg) ((reg) & GENMASK(7, 0))\n#define   PARITY_SZ(reg) (((reg) & GENMASK(15, 8)) >> 8)\n#define   RSV_SZ(reg) (((reg) & GENMASK(23, 16)) >> 16)\n#define   SPARE_SZ(reg) ((reg) >> 24)\n \n#define CHUNK_CNT 0x30\n \n#define SDMA_CTRL 0x40\n#define   WRITE_NAND 0\n#define   READ_NAND BIT(1)\n#define   CONT_NAND BIT(29)\n#define   CONT_SYSM BIT(30)  \n#define   SDMA_STRT BIT(31)\n \n#define SDMA_MAIN_ADDR 0x44\n \n#define SDMA_SPARE_ADDR 0x48\n \n#define DP_VER 0xD0\n#define   DP_VER_OFFSET 16\n\n \n#define STAT_BYTES 4\n#define   NO_ERR 0x00\n#define   MAX_CORR_ERR 0x28\n#define   UNCORR_ERR 0xFE\n#define   ERASED_CHUNK 0xFF\n\nstruct mxic_ecc_engine {\n\tstruct device *dev;\n\tvoid __iomem *regs;\n\tint irq;\n\tstruct completion complete;\n\tstruct nand_ecc_engine external_engine;\n\tstruct nand_ecc_engine pipelined_engine;\n\tstruct mutex lock;\n};\n\nstruct mxic_ecc_ctx {\n\t \n\tunsigned int data_step_sz;\n\tunsigned int oob_step_sz;\n\tunsigned int parity_sz;\n\tunsigned int meta_sz;\n\tu8 *status;\n\tint steps;\n\n\t \n\tstruct nand_ecc_req_tweak_ctx req_ctx;\n\tu8 *oobwithstat;\n\tstruct scatterlist sg[2];\n\tstruct nand_page_io_req *req;\n\tunsigned int pageoffs;\n};\n\nstatic struct mxic_ecc_engine *ext_ecc_eng_to_mxic(struct nand_ecc_engine *eng)\n{\n\treturn container_of(eng, struct mxic_ecc_engine, external_engine);\n}\n\nstatic struct mxic_ecc_engine *pip_ecc_eng_to_mxic(struct nand_ecc_engine *eng)\n{\n\treturn container_of(eng, struct mxic_ecc_engine, pipelined_engine);\n}\n\nstatic struct mxic_ecc_engine *nand_to_mxic(struct nand_device *nand)\n{\n\tstruct nand_ecc_engine *eng = nand->ecc.engine;\n\n\tif (eng->integration == NAND_ECC_ENGINE_INTEGRATION_EXTERNAL)\n\t\treturn ext_ecc_eng_to_mxic(eng);\n\telse\n\t\treturn pip_ecc_eng_to_mxic(eng);\n}\n\nstatic int mxic_ecc_ooblayout_ecc(struct mtd_info *mtd, int section,\n\t\t\t\t  struct mtd_oob_region *oobregion)\n{\n\tstruct nand_device *nand = mtd_to_nanddev(mtd);\n\tstruct mxic_ecc_ctx *ctx = nand_to_ecc_ctx(nand);\n\n\tif (section < 0 || section >= ctx->steps)\n\t\treturn -ERANGE;\n\n\toobregion->offset = (section * ctx->oob_step_sz) + ctx->meta_sz;\n\toobregion->length = ctx->parity_sz;\n\n\treturn 0;\n}\n\nstatic int mxic_ecc_ooblayout_free(struct mtd_info *mtd, int section,\n\t\t\t\t   struct mtd_oob_region *oobregion)\n{\n\tstruct nand_device *nand = mtd_to_nanddev(mtd);\n\tstruct mxic_ecc_ctx *ctx = nand_to_ecc_ctx(nand);\n\n\tif (section < 0 || section >= ctx->steps)\n\t\treturn -ERANGE;\n\n\tif (!section) {\n\t\toobregion->offset = 2;\n\t\toobregion->length = ctx->meta_sz - 2;\n\t} else {\n\t\toobregion->offset = section * ctx->oob_step_sz;\n\t\toobregion->length = ctx->meta_sz;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct mtd_ooblayout_ops mxic_ecc_ooblayout_ops = {\n\t.ecc = mxic_ecc_ooblayout_ecc,\n\t.free = mxic_ecc_ooblayout_free,\n};\n\nstatic void mxic_ecc_disable_engine(struct mxic_ecc_engine *mxic)\n{\n\tu32 reg;\n\n\treg = readl(mxic->regs + DP_CONFIG);\n\treg &= ~ECC_EN;\n\twritel(reg, mxic->regs + DP_CONFIG);\n}\n\nstatic void mxic_ecc_enable_engine(struct mxic_ecc_engine *mxic)\n{\n\tu32 reg;\n\n\treg = readl(mxic->regs + DP_CONFIG);\n\treg |= ECC_EN;\n\twritel(reg, mxic->regs + DP_CONFIG);\n}\n\nstatic void mxic_ecc_disable_int(struct mxic_ecc_engine *mxic)\n{\n\twritel(0, mxic->regs + INTRPT_SIG_EN);\n}\n\nstatic void mxic_ecc_enable_int(struct mxic_ecc_engine *mxic)\n{\n\twritel(TRANS_CMPLT, mxic->regs + INTRPT_SIG_EN);\n}\n\nstatic irqreturn_t mxic_ecc_isr(int irq, void *dev_id)\n{\n\tstruct mxic_ecc_engine *mxic = dev_id;\n\tu32 sts;\n\n\tsts = readl(mxic->regs + INTRPT_STS);\n\tif (!sts)\n\t\treturn IRQ_NONE;\n\n\tif (sts & TRANS_CMPLT)\n\t\tcomplete(&mxic->complete);\n\n\twritel(sts, mxic->regs + INTRPT_STS);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int mxic_ecc_init_ctx(struct nand_device *nand, struct device *dev)\n{\n\tstruct mxic_ecc_engine *mxic = nand_to_mxic(nand);\n\tstruct nand_ecc_props *conf = &nand->ecc.ctx.conf;\n\tstruct nand_ecc_props *reqs = &nand->ecc.requirements;\n\tstruct nand_ecc_props *user = &nand->ecc.user_conf;\n\tstruct mtd_info *mtd = nanddev_to_mtd(nand);\n\tint step_size = 0, strength = 0, desired_correction = 0, steps, idx;\n\tstatic const int possible_strength[] = {4, 8, 40, 48};\n\tstatic const int spare_size[] = {32, 32, 96, 96};\n\tstruct mxic_ecc_ctx *ctx;\n\tu32 spare_reg;\n\tint ret;\n\n\tctx = devm_kzalloc(dev, sizeof(*ctx), GFP_KERNEL);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\tnand->ecc.ctx.priv = ctx;\n\n\t \n\tif (mtd->oobsize < 64) {\n\t\tpr_err(\"BCH cannot be used with small page NAND chips\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tmtd_set_ooblayout(mtd, &mxic_ecc_ooblayout_ops);\n\n\t \n\twritel(TRANS_CMPLT | SDMA_MAIN | SDMA_SPARE | ECC_ERR |\n\t       TO_SPARE | TO_MAIN, mxic->regs + INTRPT_STS_EN);\n\n\t \n\tif (user->step_size && user->strength) {\n\t\tstep_size = user->step_size;\n\t\tstrength = user->strength;\n\t} else if (reqs->step_size && reqs->strength) {\n\t\tstep_size = reqs->step_size;\n\t\tstrength = reqs->strength;\n\t}\n\n\tif (step_size && strength) {\n\t\tsteps = mtd->writesize / step_size;\n\t\tdesired_correction = steps * strength;\n\t}\n\n\t \n\tconf->step_size = SZ_1K;\n\tsteps = mtd->writesize / conf->step_size;\n\n\tctx->status = devm_kzalloc(dev, steps * sizeof(u8), GFP_KERNEL);\n\tif (!ctx->status)\n\t\treturn -ENOMEM;\n\n\tif (desired_correction) {\n\t\tstrength = desired_correction / steps;\n\n\t\tfor (idx = 0; idx < ARRAY_SIZE(possible_strength); idx++)\n\t\t\tif (possible_strength[idx] >= strength)\n\t\t\t\tbreak;\n\n\t\tidx = min_t(unsigned int, idx,\n\t\t\t    ARRAY_SIZE(possible_strength) - 1);\n\t} else {\n\t\t \n\t\tidx = ARRAY_SIZE(possible_strength) - 1;\n\t}\n\n\t \n\tfor (; idx >= 0; idx--) {\n\t\tif (spare_size[idx] * steps <= mtd->oobsize)\n\t\t\tbreak;\n\t}\n\n\t \n\tif (idx < 0)\n\t\treturn -EINVAL;\n\n\t \n\twritel(ECC_TYP(idx), mxic->regs + DP_CONFIG);\n\tconf->strength = possible_strength[idx];\n\tspare_reg = readl(mxic->regs + SPARE_SIZE);\n\n\tctx->steps = steps;\n\tctx->data_step_sz = mtd->writesize / steps;\n\tctx->oob_step_sz = mtd->oobsize / steps;\n\tctx->parity_sz = PARITY_SZ(spare_reg);\n\tctx->meta_sz = META_SZ(spare_reg);\n\n\t \n\tctx->req_ctx.oob_buffer_size = nanddev_per_page_oobsize(nand) +\n\t\t\t\t\t(ctx->steps * STAT_BYTES);\n\tret = nand_ecc_init_req_tweaking(&ctx->req_ctx, nand);\n\tif (ret)\n\t\treturn ret;\n\n\tctx->oobwithstat = kmalloc(mtd->oobsize + (ctx->steps * STAT_BYTES),\n\t\t\t\t   GFP_KERNEL);\n\tif (!ctx->oobwithstat) {\n\t\tret = -ENOMEM;\n\t\tgoto cleanup_req_tweak;\n\t}\n\n\tsg_init_table(ctx->sg, 2);\n\n\t \n\tdev_err(dev, \"DPE version number: %d\\n\",\n\t\treadl(mxic->regs + DP_VER) >> DP_VER_OFFSET);\n\tdev_err(dev, \"Chunk size: %d\\n\", readl(mxic->regs + CHUNK_SIZE));\n\tdev_err(dev, \"Main size: %d\\n\", readl(mxic->regs + MAIN_SIZE));\n\tdev_err(dev, \"Spare size: %d\\n\", SPARE_SZ(spare_reg));\n\tdev_err(dev, \"Rsv size: %ld\\n\", RSV_SZ(spare_reg));\n\tdev_err(dev, \"Parity size: %d\\n\", ctx->parity_sz);\n\tdev_err(dev, \"Meta size: %d\\n\", ctx->meta_sz);\n\n\tif ((ctx->meta_sz + ctx->parity_sz + RSV_SZ(spare_reg)) !=\n\t    SPARE_SZ(spare_reg)) {\n\t\tdev_err(dev, \"Wrong OOB configuration: %d + %d + %ld != %d\\n\",\n\t\t\tctx->meta_sz, ctx->parity_sz, RSV_SZ(spare_reg),\n\t\t\tSPARE_SZ(spare_reg));\n\t\tret = -EINVAL;\n\t\tgoto free_oobwithstat;\n\t}\n\n\tif (ctx->oob_step_sz != SPARE_SZ(spare_reg)) {\n\t\tdev_err(dev, \"Wrong OOB configuration: %d != %d\\n\",\n\t\t\tctx->oob_step_sz, SPARE_SZ(spare_reg));\n\t\tret = -EINVAL;\n\t\tgoto free_oobwithstat;\n\t}\n\n\treturn 0;\n\nfree_oobwithstat:\n\tkfree(ctx->oobwithstat);\ncleanup_req_tweak:\n\tnand_ecc_cleanup_req_tweaking(&ctx->req_ctx);\n\n\treturn ret;\n}\n\nstatic int mxic_ecc_init_ctx_external(struct nand_device *nand)\n{\n\tstruct mxic_ecc_engine *mxic = nand_to_mxic(nand);\n\tstruct device *dev = nand->ecc.engine->dev;\n\tint ret;\n\n\tdev_info(dev, \"Macronix ECC engine in external mode\\n\");\n\n\tret = mxic_ecc_init_ctx(nand, dev);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\twritel(1, mxic->regs + CHUNK_CNT);\n\twritel(BURST_TYP_INCREASING | ECC_PACKED | MEM2MEM,\n\t       mxic->regs + HC_CONFIG);\n\n\treturn 0;\n}\n\nstatic int mxic_ecc_init_ctx_pipelined(struct nand_device *nand)\n{\n\tstruct mxic_ecc_engine *mxic = nand_to_mxic(nand);\n\tstruct mxic_ecc_ctx *ctx;\n\tstruct device *dev;\n\tint ret;\n\n\tdev = nand_ecc_get_engine_dev(nand->ecc.engine->dev);\n\tif (!dev)\n\t\treturn -EINVAL;\n\n\tdev_info(dev, \"Macronix ECC engine in pipelined/mapping mode\\n\");\n\n\tret = mxic_ecc_init_ctx(nand, dev);\n\tif (ret)\n\t\treturn ret;\n\n\tctx = nand_to_ecc_ctx(nand);\n\n\t \n\twritel(ctx->steps, mxic->regs + CHUNK_CNT);\n\n\t \n\twritel(BURST_TYP_INCREASING | ECC_PACKED | MAPPING,\n\t       mxic->regs + HC_CONFIG);\n\n\treturn 0;\n}\n\nstatic void mxic_ecc_cleanup_ctx(struct nand_device *nand)\n{\n\tstruct mxic_ecc_ctx *ctx = nand_to_ecc_ctx(nand);\n\n\tif (ctx) {\n\t\tnand_ecc_cleanup_req_tweaking(&ctx->req_ctx);\n\t\tkfree(ctx->oobwithstat);\n\t}\n}\n\nstatic int mxic_ecc_data_xfer_wait_for_completion(struct mxic_ecc_engine *mxic)\n{\n\tu32 val;\n\tint ret;\n\n\tif (mxic->irq) {\n\t\treinit_completion(&mxic->complete);\n\t\tmxic_ecc_enable_int(mxic);\n\t\tret = wait_for_completion_timeout(&mxic->complete,\n\t\t\t\t\t\t  msecs_to_jiffies(1000));\n\t\tret = ret ? 0 : -ETIMEDOUT;\n\t\tmxic_ecc_disable_int(mxic);\n\t} else {\n\t\tret = readl_poll_timeout(mxic->regs + INTRPT_STS, val,\n\t\t\t\t\t val & TRANS_CMPLT, 10, USEC_PER_SEC);\n\t\twritel(val, mxic->regs + INTRPT_STS);\n\t}\n\n\tif (ret) {\n\t\tdev_err(mxic->dev, \"Timeout on data xfer completion\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\treturn 0;\n}\n\nstatic int mxic_ecc_process_data(struct mxic_ecc_engine *mxic,\n\t\t\t\t unsigned int direction)\n{\n\tunsigned int dir = (direction == NAND_PAGE_READ) ?\n\t\t\t   READ_NAND : WRITE_NAND;\n\tint ret;\n\n\tmxic_ecc_enable_engine(mxic);\n\n\t \n\twritel(SDMA_STRT | dir, mxic->regs + SDMA_CTRL);\n\n\t \n\tret = mxic_ecc_data_xfer_wait_for_completion(mxic);\n\n\tmxic_ecc_disable_engine(mxic);\n\n\treturn ret;\n}\n\nint mxic_ecc_process_data_pipelined(struct nand_ecc_engine *eng,\n\t\t\t\t    unsigned int direction, dma_addr_t dirmap)\n{\n\tstruct mxic_ecc_engine *mxic = pip_ecc_eng_to_mxic(eng);\n\n\tif (dirmap)\n\t\twritel(dirmap, mxic->regs + HC_SLV_ADDR);\n\n\treturn mxic_ecc_process_data(mxic, direction);\n}\nEXPORT_SYMBOL_GPL(mxic_ecc_process_data_pipelined);\n\nstatic void mxic_ecc_extract_status_bytes(struct mxic_ecc_ctx *ctx)\n{\n\tu8 *buf = ctx->oobwithstat;\n\tint next_stat_pos;\n\tint step;\n\n\t \n\tfor (step = 0; step < ctx->steps; step++) {\n\t\tnext_stat_pos = ctx->oob_step_sz +\n\t\t\t\t((STAT_BYTES + ctx->oob_step_sz) * step);\n\n\t\tctx->status[step] = buf[next_stat_pos];\n\t}\n}\n\nstatic void mxic_ecc_reconstruct_oobbuf(struct mxic_ecc_ctx *ctx,\n\t\t\t\t\tu8 *dst, const u8 *src)\n{\n\tint step;\n\n\t \n\tfor (step = 0; step < ctx->steps; step++)\n\t\tmemcpy(dst + (step * ctx->oob_step_sz),\n\t\t       src + (step * (ctx->oob_step_sz + STAT_BYTES)),\n\t\t       ctx->oob_step_sz);\n}\n\nstatic void mxic_ecc_add_room_in_oobbuf(struct mxic_ecc_ctx *ctx,\n\t\t\t\t\tu8 *dst, const u8 *src)\n{\n\tint step;\n\n\t \n\tfor (step = 0; step < ctx->steps; step++)\n\t\tmemcpy(dst + (step * (ctx->oob_step_sz + STAT_BYTES)),\n\t\t       src + (step * ctx->oob_step_sz),\n\t\t       ctx->oob_step_sz);\n}\n\nstatic int mxic_ecc_count_biterrs(struct mxic_ecc_engine *mxic,\n\t\t\t\t  struct nand_device *nand)\n{\n\tstruct mxic_ecc_ctx *ctx = nand_to_ecc_ctx(nand);\n\tstruct mtd_info *mtd = nanddev_to_mtd(nand);\n\tstruct device *dev = mxic->dev;\n\tunsigned int max_bf = 0;\n\tbool failure = false;\n\tint step;\n\n\tfor (step = 0; step < ctx->steps; step++) {\n\t\tu8 stat = ctx->status[step];\n\n\t\tif (stat == NO_ERR) {\n\t\t\tdev_dbg(dev, \"ECC step %d: no error\\n\", step);\n\t\t} else if (stat == ERASED_CHUNK) {\n\t\t\tdev_dbg(dev, \"ECC step %d: erased\\n\", step);\n\t\t} else if (stat == UNCORR_ERR || stat > MAX_CORR_ERR) {\n\t\t\tdev_dbg(dev, \"ECC step %d: uncorrectable\\n\", step);\n\t\t\tmtd->ecc_stats.failed++;\n\t\t\tfailure = true;\n\t\t} else {\n\t\t\tdev_dbg(dev, \"ECC step %d: %d bits corrected\\n\",\n\t\t\t\tstep, stat);\n\t\t\tmax_bf = max_t(unsigned int, max_bf, stat);\n\t\t\tmtd->ecc_stats.corrected += stat;\n\t\t}\n\t}\n\n\treturn failure ? -EBADMSG : max_bf;\n}\n\n \nstatic int mxic_ecc_prepare_io_req_external(struct nand_device *nand,\n\t\t\t\t\t    struct nand_page_io_req *req)\n{\n\tstruct mxic_ecc_engine *mxic = nand_to_mxic(nand);\n\tstruct mxic_ecc_ctx *ctx = nand_to_ecc_ctx(nand);\n\tstruct mtd_info *mtd = nanddev_to_mtd(nand);\n\tint offset, nents, step, ret;\n\n\tif (req->mode == MTD_OPS_RAW)\n\t\treturn 0;\n\n\tnand_ecc_tweak_req(&ctx->req_ctx, req);\n\tctx->req = req;\n\n\tif (req->type == NAND_PAGE_READ)\n\t\treturn 0;\n\n\tmxic_ecc_add_room_in_oobbuf(ctx, ctx->oobwithstat,\n\t\t\t\t    ctx->req->oobbuf.out);\n\n\tsg_set_buf(&ctx->sg[0], req->databuf.out, req->datalen);\n\tsg_set_buf(&ctx->sg[1], ctx->oobwithstat,\n\t\t   req->ooblen + (ctx->steps * STAT_BYTES));\n\n\tnents = dma_map_sg(mxic->dev, ctx->sg, 2, DMA_BIDIRECTIONAL);\n\tif (!nents)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&mxic->lock);\n\n\tfor (step = 0; step < ctx->steps; step++) {\n\t\twritel(sg_dma_address(&ctx->sg[0]) + (step * ctx->data_step_sz),\n\t\t       mxic->regs + SDMA_MAIN_ADDR);\n\t\twritel(sg_dma_address(&ctx->sg[1]) + (step * (ctx->oob_step_sz + STAT_BYTES)),\n\t\t       mxic->regs + SDMA_SPARE_ADDR);\n\t\tret = mxic_ecc_process_data(mxic, ctx->req->type);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\tmutex_unlock(&mxic->lock);\n\n\tdma_unmap_sg(mxic->dev, ctx->sg, 2, DMA_BIDIRECTIONAL);\n\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tfor (step = 0; step < ctx->steps; step++) {\n\t\toffset = ctx->meta_sz + (step * ctx->oob_step_sz);\n\t\tmtd_ooblayout_get_eccbytes(mtd,\n\t\t\t\t\t   (u8 *)ctx->req->oobbuf.out + offset,\n\t\t\t\t\t   ctx->oobwithstat + (step * STAT_BYTES),\n\t\t\t\t\t   step * ctx->parity_sz,\n\t\t\t\t\t   ctx->parity_sz);\n\t}\n\n\treturn 0;\n}\n\nstatic int mxic_ecc_finish_io_req_external(struct nand_device *nand,\n\t\t\t\t\t   struct nand_page_io_req *req)\n{\n\tstruct mxic_ecc_engine *mxic = nand_to_mxic(nand);\n\tstruct mxic_ecc_ctx *ctx = nand_to_ecc_ctx(nand);\n\tint nents, step, ret;\n\n\tif (req->mode == MTD_OPS_RAW)\n\t\treturn 0;\n\n\tif (req->type == NAND_PAGE_WRITE) {\n\t\tnand_ecc_restore_req(&ctx->req_ctx, req);\n\t\treturn 0;\n\t}\n\n\t \n\tmxic_ecc_add_room_in_oobbuf(ctx, ctx->oobwithstat, ctx->req->oobbuf.in);\n\n\tsg_set_buf(&ctx->sg[0], req->databuf.in, req->datalen);\n\tsg_set_buf(&ctx->sg[1], ctx->oobwithstat,\n\t\t   req->ooblen + (ctx->steps * STAT_BYTES));\n\tnents = dma_map_sg(mxic->dev, ctx->sg, 2, DMA_BIDIRECTIONAL);\n\tif (!nents)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&mxic->lock);\n\n\tfor (step = 0; step < ctx->steps; step++) {\n\t\twritel(sg_dma_address(&ctx->sg[0]) + (step * ctx->data_step_sz),\n\t\t       mxic->regs + SDMA_MAIN_ADDR);\n\t\twritel(sg_dma_address(&ctx->sg[1]) + (step * (ctx->oob_step_sz + STAT_BYTES)),\n\t\t       mxic->regs + SDMA_SPARE_ADDR);\n\t\tret = mxic_ecc_process_data(mxic, ctx->req->type);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\tmutex_unlock(&mxic->lock);\n\n\tdma_unmap_sg(mxic->dev, ctx->sg, 2, DMA_BIDIRECTIONAL);\n\n\tif (ret) {\n\t\tnand_ecc_restore_req(&ctx->req_ctx, req);\n\t\treturn ret;\n\t}\n\n\t \n\tmxic_ecc_extract_status_bytes(ctx);\n\tmxic_ecc_reconstruct_oobbuf(ctx, ctx->req->oobbuf.in, ctx->oobwithstat);\n\n\tnand_ecc_restore_req(&ctx->req_ctx, req);\n\n\treturn mxic_ecc_count_biterrs(mxic, nand);\n}\n\n \nstatic int mxic_ecc_prepare_io_req_pipelined(struct nand_device *nand,\n\t\t\t\t\t     struct nand_page_io_req *req)\n{\n\tstruct mxic_ecc_engine *mxic = nand_to_mxic(nand);\n\tstruct mxic_ecc_ctx *ctx = nand_to_ecc_ctx(nand);\n\tint nents;\n\n\tif (req->mode == MTD_OPS_RAW)\n\t\treturn 0;\n\n\tnand_ecc_tweak_req(&ctx->req_ctx, req);\n\tctx->req = req;\n\n\t \n\tmxic_ecc_add_room_in_oobbuf(ctx, ctx->oobwithstat, ctx->req->oobbuf.in);\n\n\tsg_set_buf(&ctx->sg[0], req->databuf.in, req->datalen);\n\tsg_set_buf(&ctx->sg[1], ctx->oobwithstat,\n\t\t   req->ooblen + (ctx->steps * STAT_BYTES));\n\n\tnents = dma_map_sg(mxic->dev, ctx->sg, 2, DMA_BIDIRECTIONAL);\n\tif (!nents)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&mxic->lock);\n\n\twritel(sg_dma_address(&ctx->sg[0]), mxic->regs + SDMA_MAIN_ADDR);\n\twritel(sg_dma_address(&ctx->sg[1]), mxic->regs + SDMA_SPARE_ADDR);\n\n\treturn 0;\n}\n\nstatic int mxic_ecc_finish_io_req_pipelined(struct nand_device *nand,\n\t\t\t\t\t    struct nand_page_io_req *req)\n{\n\tstruct mxic_ecc_engine *mxic = nand_to_mxic(nand);\n\tstruct mxic_ecc_ctx *ctx = nand_to_ecc_ctx(nand);\n\tint ret = 0;\n\n\tif (req->mode == MTD_OPS_RAW)\n\t\treturn 0;\n\n\tmutex_unlock(&mxic->lock);\n\n\tdma_unmap_sg(mxic->dev, ctx->sg, 2, DMA_BIDIRECTIONAL);\n\n\tif (req->type == NAND_PAGE_READ) {\n\t\tmxic_ecc_extract_status_bytes(ctx);\n\t\tmxic_ecc_reconstruct_oobbuf(ctx, ctx->req->oobbuf.in,\n\t\t\t\t\t    ctx->oobwithstat);\n\t\tret = mxic_ecc_count_biterrs(mxic, nand);\n\t}\n\n\tnand_ecc_restore_req(&ctx->req_ctx, req);\n\n\treturn ret;\n}\n\nstatic struct nand_ecc_engine_ops mxic_ecc_engine_external_ops = {\n\t.init_ctx = mxic_ecc_init_ctx_external,\n\t.cleanup_ctx = mxic_ecc_cleanup_ctx,\n\t.prepare_io_req = mxic_ecc_prepare_io_req_external,\n\t.finish_io_req = mxic_ecc_finish_io_req_external,\n};\n\nstatic struct nand_ecc_engine_ops mxic_ecc_engine_pipelined_ops = {\n\t.init_ctx = mxic_ecc_init_ctx_pipelined,\n\t.cleanup_ctx = mxic_ecc_cleanup_ctx,\n\t.prepare_io_req = mxic_ecc_prepare_io_req_pipelined,\n\t.finish_io_req = mxic_ecc_finish_io_req_pipelined,\n};\n\nstruct nand_ecc_engine_ops *mxic_ecc_get_pipelined_ops(void)\n{\n\treturn &mxic_ecc_engine_pipelined_ops;\n}\nEXPORT_SYMBOL_GPL(mxic_ecc_get_pipelined_ops);\n\nstatic struct platform_device *\nmxic_ecc_get_pdev(struct platform_device *spi_pdev)\n{\n\tstruct platform_device *eng_pdev;\n\tstruct device_node *np;\n\n\t \n\tnp = of_parse_phandle(spi_pdev->dev.of_node, \"nand-ecc-engine\", 0);\n\tif (!np)\n\t\treturn NULL;\n\n\t \n\teng_pdev = of_find_device_by_node(np);\n\tof_node_put(np);\n\n\treturn eng_pdev;\n}\n\nvoid mxic_ecc_put_pipelined_engine(struct nand_ecc_engine *eng)\n{\n\tstruct mxic_ecc_engine *mxic = pip_ecc_eng_to_mxic(eng);\n\n\tplatform_device_put(to_platform_device(mxic->dev));\n}\nEXPORT_SYMBOL_GPL(mxic_ecc_put_pipelined_engine);\n\nstruct nand_ecc_engine *\nmxic_ecc_get_pipelined_engine(struct platform_device *spi_pdev)\n{\n\tstruct platform_device *eng_pdev;\n\tstruct mxic_ecc_engine *mxic;\n\n\teng_pdev = mxic_ecc_get_pdev(spi_pdev);\n\tif (!eng_pdev)\n\t\treturn ERR_PTR(-ENODEV);\n\n\tmxic = platform_get_drvdata(eng_pdev);\n\tif (!mxic) {\n\t\tplatform_device_put(eng_pdev);\n\t\treturn ERR_PTR(-EPROBE_DEFER);\n\t}\n\n\treturn &mxic->pipelined_engine;\n}\nEXPORT_SYMBOL_GPL(mxic_ecc_get_pipelined_engine);\n\n \nstatic int mxic_ecc_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct mxic_ecc_engine *mxic;\n\tint ret;\n\n\tmxic = devm_kzalloc(&pdev->dev, sizeof(*mxic), GFP_KERNEL);\n\tif (!mxic)\n\t\treturn -ENOMEM;\n\n\tmxic->dev = &pdev->dev;\n\n\t \n\tmxic->regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(mxic->regs)) {\n\t\tdev_err(&pdev->dev, \"Missing memory region\\n\");\n\t\treturn PTR_ERR(mxic->regs);\n\t}\n\n\tmxic_ecc_disable_engine(mxic);\n\tmxic_ecc_disable_int(mxic);\n\n\t \n\tmxic->irq = platform_get_irq_byname_optional(pdev, \"ecc-engine\");\n\tif (mxic->irq > 0) {\n\t\tret = devm_request_irq(&pdev->dev, mxic->irq, mxic_ecc_isr, 0,\n\t\t\t\t       \"mxic-ecc\", mxic);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else {\n\t\tdev_info(dev, \"Invalid or missing IRQ, fallback to polling\\n\");\n\t\tmxic->irq = 0;\n\t}\n\n\tmutex_init(&mxic->lock);\n\n\t \n\tmxic->external_engine.dev = &pdev->dev;\n\tmxic->external_engine.integration = NAND_ECC_ENGINE_INTEGRATION_EXTERNAL;\n\tmxic->external_engine.ops = &mxic_ecc_engine_external_ops;\n\n\tnand_ecc_register_on_host_hw_engine(&mxic->external_engine);\n\n\tplatform_set_drvdata(pdev, mxic);\n\n\treturn 0;\n}\n\nstatic void mxic_ecc_remove(struct platform_device *pdev)\n{\n\tstruct mxic_ecc_engine *mxic = platform_get_drvdata(pdev);\n\n\tnand_ecc_unregister_on_host_hw_engine(&mxic->external_engine);\n}\n\nstatic const struct of_device_id mxic_ecc_of_ids[] = {\n\t{\n\t\t.compatible = \"mxicy,nand-ecc-engine-rev3\",\n\t},\n\t{   },\n};\nMODULE_DEVICE_TABLE(of, mxic_ecc_of_ids);\n\nstatic struct platform_driver mxic_ecc_driver = {\n\t.driver\t= {\n\t\t.name = \"mxic-nand-ecc-engine\",\n\t\t.of_match_table = mxic_ecc_of_ids,\n\t},\n\t.probe = mxic_ecc_probe,\n\t.remove_new = mxic_ecc_remove,\n};\nmodule_platform_driver(mxic_ecc_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Miquel Raynal <miquel.raynal@bootlin.com>\");\nMODULE_DESCRIPTION(\"Macronix NAND hardware ECC controller\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}