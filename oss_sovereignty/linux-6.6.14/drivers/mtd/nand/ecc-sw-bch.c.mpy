{
  "module_name": "ecc-sw-bch.c",
  "hash_id": "d686fcb833febe08dfe4f78303a223e45d3a1ab816c4118511626ed06ac5d978",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/nand/ecc-sw-bch.c",
  "human_readable_source": "\n \n\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/mtd/nand.h>\n#include <linux/mtd/nand-ecc-sw-bch.h>\n\n \nint nand_ecc_sw_bch_calculate(struct nand_device *nand,\n\t\t\t      const unsigned char *buf, unsigned char *code)\n{\n\tstruct nand_ecc_sw_bch_conf *engine_conf = nand->ecc.ctx.priv;\n\tunsigned int i;\n\n\tmemset(code, 0, engine_conf->code_size);\n\tbch_encode(engine_conf->bch, buf, nand->ecc.ctx.conf.step_size, code);\n\n\t \n\tfor (i = 0; i < engine_conf->code_size; i++)\n\t\tcode[i] ^= engine_conf->eccmask[i];\n\n\treturn 0;\n}\nEXPORT_SYMBOL(nand_ecc_sw_bch_calculate);\n\n \nint nand_ecc_sw_bch_correct(struct nand_device *nand, unsigned char *buf,\n\t\t\t    unsigned char *read_ecc, unsigned char *calc_ecc)\n{\n\tstruct nand_ecc_sw_bch_conf *engine_conf = nand->ecc.ctx.priv;\n\tunsigned int step_size = nand->ecc.ctx.conf.step_size;\n\tunsigned int *errloc = engine_conf->errloc;\n\tint i, count;\n\n\tcount = bch_decode(engine_conf->bch, NULL, step_size, read_ecc,\n\t\t\t   calc_ecc, NULL, errloc);\n\tif (count > 0) {\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tif (errloc[i] < (step_size * 8))\n\t\t\t\t \n\t\t\t\tbuf[errloc[i] >> 3] ^= (1 << (errloc[i] & 7));\n\n\t\t\t \n\t\t\tpr_debug(\"%s: corrected bitflip %u\\n\", __func__,\n\t\t\t\t errloc[i]);\n\t\t}\n\t} else if (count < 0) {\n\t\tpr_err(\"ECC unrecoverable error\\n\");\n\t\tcount = -EBADMSG;\n\t}\n\n\treturn count;\n}\nEXPORT_SYMBOL(nand_ecc_sw_bch_correct);\n\n \nstatic void nand_ecc_sw_bch_cleanup(struct nand_device *nand)\n{\n\tstruct nand_ecc_sw_bch_conf *engine_conf = nand->ecc.ctx.priv;\n\n\tbch_free(engine_conf->bch);\n\tkfree(engine_conf->errloc);\n\tkfree(engine_conf->eccmask);\n}\n\n \nstatic int nand_ecc_sw_bch_init(struct nand_device *nand)\n{\n\tstruct nand_ecc_sw_bch_conf *engine_conf = nand->ecc.ctx.priv;\n\tunsigned int eccsize = nand->ecc.ctx.conf.step_size;\n\tunsigned int eccbytes = engine_conf->code_size;\n\tunsigned int m, t, i;\n\tunsigned char *erased_page;\n\tint ret;\n\n\tm = fls(1 + (8 * eccsize));\n\tt = (eccbytes * 8) / m;\n\n\tengine_conf->bch = bch_init(m, t, 0, false);\n\tif (!engine_conf->bch)\n\t\treturn -EINVAL;\n\n\tengine_conf->eccmask = kzalloc(eccbytes, GFP_KERNEL);\n\tengine_conf->errloc = kmalloc_array(t, sizeof(*engine_conf->errloc),\n\t\t\t\t\t    GFP_KERNEL);\n\tif (!engine_conf->eccmask || !engine_conf->errloc) {\n\t\tret = -ENOMEM;\n\t\tgoto cleanup;\n\t}\n\n\t \n\terased_page = kmalloc(eccsize, GFP_KERNEL);\n\tif (!erased_page) {\n\t\tret = -ENOMEM;\n\t\tgoto cleanup;\n\t}\n\n\tmemset(erased_page, 0xff, eccsize);\n\tbch_encode(engine_conf->bch, erased_page, eccsize,\n\t\t   engine_conf->eccmask);\n\tkfree(erased_page);\n\n\tfor (i = 0; i < eccbytes; i++)\n\t\tengine_conf->eccmask[i] ^= 0xff;\n\n\t \n\tif (engine_conf->bch->ecc_bytes != eccbytes) {\n\t\tpr_err(\"Invalid number of ECC bytes: %u, expected: %u\\n\",\n\t\t       eccbytes, engine_conf->bch->ecc_bytes);\n\t\tret = -EINVAL;\n\t\tgoto cleanup;\n\t}\n\n\t \n\tif (8 * (eccsize + eccbytes) >= (1 << m)) {\n\t\tpr_err(\"ECC step size is too large (%u)\\n\", eccsize);\n\t\tret = -EINVAL;\n\t\tgoto cleanup;\n\t}\n\n\treturn 0;\n\ncleanup:\n\tnand_ecc_sw_bch_cleanup(nand);\n\n\treturn ret;\n}\n\nint nand_ecc_sw_bch_init_ctx(struct nand_device *nand)\n{\n\tstruct nand_ecc_props *conf = &nand->ecc.ctx.conf;\n\tstruct mtd_info *mtd = nanddev_to_mtd(nand);\n\tstruct nand_ecc_sw_bch_conf *engine_conf;\n\tunsigned int code_size = 0, nsteps;\n\tint ret;\n\n\t \n\tif (mtd->oobsize < 64) {\n\t\tpr_err(\"BCH cannot be used with small page NAND chips\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!mtd->ooblayout)\n\t\tmtd_set_ooblayout(mtd, nand_get_large_page_ooblayout());\n\n\tconf->engine_type = NAND_ECC_ENGINE_TYPE_SOFT;\n\tconf->algo = NAND_ECC_ALGO_BCH;\n\tconf->step_size = nand->ecc.user_conf.step_size;\n\tconf->strength = nand->ecc.user_conf.strength;\n\n\t \n\tif (!conf->step_size) {\n\t\tif (mtd->oobsize >= 64)\n\t\t\tconf->step_size = 512;\n\t\telse\n\t\t\tconf->step_size = 256;\n\n\t\tconf->strength = 4;\n\t}\n\n\tnsteps = mtd->writesize / conf->step_size;\n\n\t \n\tif (nand->ecc.user_conf.flags & NAND_ECC_MAXIMIZE_STRENGTH) {\n\t\tconf->step_size = 1024;\n\t\tnsteps = mtd->writesize / conf->step_size;\n\t\t \n\t\tcode_size = (mtd->oobsize - 2) / nsteps;\n\t\tconf->strength = code_size * 8 / fls(8 * conf->step_size);\n\t}\n\n\tif (!code_size)\n\t\tcode_size = DIV_ROUND_UP(conf->strength *\n\t\t\t\t\t fls(8 * conf->step_size), 8);\n\n\tif (!conf->strength)\n\t\tconf->strength = (code_size * 8) / fls(8 * conf->step_size);\n\n\tif (!code_size && !conf->strength) {\n\t\tpr_err(\"Missing ECC parameters\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tengine_conf = kzalloc(sizeof(*engine_conf), GFP_KERNEL);\n\tif (!engine_conf)\n\t\treturn -ENOMEM;\n\n\tret = nand_ecc_init_req_tweaking(&engine_conf->req_ctx, nand);\n\tif (ret)\n\t\tgoto free_engine_conf;\n\n\tengine_conf->code_size = code_size;\n\tengine_conf->calc_buf = kzalloc(mtd->oobsize, GFP_KERNEL);\n\tengine_conf->code_buf = kzalloc(mtd->oobsize, GFP_KERNEL);\n\tif (!engine_conf->calc_buf || !engine_conf->code_buf) {\n\t\tret = -ENOMEM;\n\t\tgoto free_bufs;\n\t}\n\n\tnand->ecc.ctx.priv = engine_conf;\n\tnand->ecc.ctx.nsteps = nsteps;\n\tnand->ecc.ctx.total = nsteps * code_size;\n\n\tret = nand_ecc_sw_bch_init(nand);\n\tif (ret)\n\t\tgoto free_bufs;\n\n\t \n\tif (mtd_ooblayout_count_eccbytes(mtd) !=\n\t    nand->ecc.ctx.nsteps * engine_conf->code_size) {\n\t\tpr_err(\"Invalid ECC layout\\n\");\n\t\tret = -EINVAL;\n\t\tgoto cleanup_bch_ctx;\n\t}\n\n\treturn 0;\n\ncleanup_bch_ctx:\n\tnand_ecc_sw_bch_cleanup(nand);\nfree_bufs:\n\tnand_ecc_cleanup_req_tweaking(&engine_conf->req_ctx);\n\tkfree(engine_conf->calc_buf);\n\tkfree(engine_conf->code_buf);\nfree_engine_conf:\n\tkfree(engine_conf);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(nand_ecc_sw_bch_init_ctx);\n\nvoid nand_ecc_sw_bch_cleanup_ctx(struct nand_device *nand)\n{\n\tstruct nand_ecc_sw_bch_conf *engine_conf = nand->ecc.ctx.priv;\n\n\tif (engine_conf) {\n\t\tnand_ecc_sw_bch_cleanup(nand);\n\t\tnand_ecc_cleanup_req_tweaking(&engine_conf->req_ctx);\n\t\tkfree(engine_conf->calc_buf);\n\t\tkfree(engine_conf->code_buf);\n\t\tkfree(engine_conf);\n\t}\n}\nEXPORT_SYMBOL(nand_ecc_sw_bch_cleanup_ctx);\n\nstatic int nand_ecc_sw_bch_prepare_io_req(struct nand_device *nand,\n\t\t\t\t\t  struct nand_page_io_req *req)\n{\n\tstruct nand_ecc_sw_bch_conf *engine_conf = nand->ecc.ctx.priv;\n\tstruct mtd_info *mtd = nanddev_to_mtd(nand);\n\tint eccsize = nand->ecc.ctx.conf.step_size;\n\tint eccbytes = engine_conf->code_size;\n\tint eccsteps = nand->ecc.ctx.nsteps;\n\tint total = nand->ecc.ctx.total;\n\tu8 *ecccalc = engine_conf->calc_buf;\n\tconst u8 *data;\n\tint i;\n\n\t \n\tif (req->mode == MTD_OPS_RAW)\n\t\treturn 0;\n\n\t \n\tif (!req->datalen)\n\t\treturn 0;\n\n\tnand_ecc_tweak_req(&engine_conf->req_ctx, req);\n\n\t \n\tif (req->type == NAND_PAGE_READ)\n\t\treturn 0;\n\n\t \n\tfor (i = 0, data = req->databuf.out;\n\t     eccsteps;\n\t     eccsteps--, i += eccbytes, data += eccsize)\n\t\tnand_ecc_sw_bch_calculate(nand, data, &ecccalc[i]);\n\n\treturn mtd_ooblayout_set_eccbytes(mtd, ecccalc, (void *)req->oobbuf.out,\n\t\t\t\t\t  0, total);\n}\n\nstatic int nand_ecc_sw_bch_finish_io_req(struct nand_device *nand,\n\t\t\t\t\t struct nand_page_io_req *req)\n{\n\tstruct nand_ecc_sw_bch_conf *engine_conf = nand->ecc.ctx.priv;\n\tstruct mtd_info *mtd = nanddev_to_mtd(nand);\n\tint eccsize = nand->ecc.ctx.conf.step_size;\n\tint total = nand->ecc.ctx.total;\n\tint eccbytes = engine_conf->code_size;\n\tint eccsteps = nand->ecc.ctx.nsteps;\n\tu8 *ecccalc = engine_conf->calc_buf;\n\tu8 *ecccode = engine_conf->code_buf;\n\tunsigned int max_bitflips = 0;\n\tu8 *data = req->databuf.in;\n\tint i, ret;\n\n\t \n\tif (req->mode == MTD_OPS_RAW)\n\t\treturn 0;\n\n\t \n\tif (!req->datalen)\n\t\treturn 0;\n\n\t \n\tif (req->type == NAND_PAGE_WRITE) {\n\t\tnand_ecc_restore_req(&engine_conf->req_ctx, req);\n\t\treturn 0;\n\t}\n\n\t \n\tret = mtd_ooblayout_get_eccbytes(mtd, ecccode, req->oobbuf.in, 0,\n\t\t\t\t\t total);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tfor (i = 0; eccsteps; eccsteps--, i += eccbytes, data += eccsize)\n\t\tnand_ecc_sw_bch_calculate(nand, data, &ecccalc[i]);\n\n\t \n\tfor (eccsteps = nand->ecc.ctx.nsteps, i = 0, data = req->databuf.in;\n\t     eccsteps;\n\t     eccsteps--, i += eccbytes, data += eccsize) {\n\t\tint stat =  nand_ecc_sw_bch_correct(nand, data,\n\t\t\t\t\t\t    &ecccode[i],\n\t\t\t\t\t\t    &ecccalc[i]);\n\t\tif (stat < 0) {\n\t\t\tmtd->ecc_stats.failed++;\n\t\t} else {\n\t\t\tmtd->ecc_stats.corrected += stat;\n\t\t\tmax_bitflips = max_t(unsigned int, max_bitflips, stat);\n\t\t}\n\t}\n\n\tnand_ecc_restore_req(&engine_conf->req_ctx, req);\n\n\treturn max_bitflips;\n}\n\nstatic struct nand_ecc_engine_ops nand_ecc_sw_bch_engine_ops = {\n\t.init_ctx = nand_ecc_sw_bch_init_ctx,\n\t.cleanup_ctx = nand_ecc_sw_bch_cleanup_ctx,\n\t.prepare_io_req = nand_ecc_sw_bch_prepare_io_req,\n\t.finish_io_req = nand_ecc_sw_bch_finish_io_req,\n};\n\nstatic struct nand_ecc_engine nand_ecc_sw_bch_engine = {\n\t.ops = &nand_ecc_sw_bch_engine_ops,\n};\n\nstruct nand_ecc_engine *nand_ecc_sw_bch_get_engine(void)\n{\n\treturn &nand_ecc_sw_bch_engine;\n}\nEXPORT_SYMBOL(nand_ecc_sw_bch_get_engine);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Ivan Djelic <ivan.djelic@parrot.com>\");\nMODULE_DESCRIPTION(\"NAND software BCH ECC support\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}