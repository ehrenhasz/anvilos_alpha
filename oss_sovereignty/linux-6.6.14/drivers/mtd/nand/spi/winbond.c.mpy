{
  "module_name": "winbond.c",
  "hash_id": "7653d34e0f0d74ba5bc6324c5493da445b95e8d5cc8a3e88b7748be360c96429",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/nand/spi/winbond.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/kernel.h>\n#include <linux/mtd/spinand.h>\n\n#define SPINAND_MFR_WINBOND\t\t0xEF\n\n#define WINBOND_CFG_BUF_READ\t\tBIT(3)\n\nstatic SPINAND_OP_VARIANTS(read_cache_variants,\n\t\tSPINAND_PAGE_READ_FROM_CACHE_QUADIO_OP(0, 2, NULL, 0),\n\t\tSPINAND_PAGE_READ_FROM_CACHE_X4_OP(0, 1, NULL, 0),\n\t\tSPINAND_PAGE_READ_FROM_CACHE_DUALIO_OP(0, 1, NULL, 0),\n\t\tSPINAND_PAGE_READ_FROM_CACHE_X2_OP(0, 1, NULL, 0),\n\t\tSPINAND_PAGE_READ_FROM_CACHE_OP(true, 0, 1, NULL, 0),\n\t\tSPINAND_PAGE_READ_FROM_CACHE_OP(false, 0, 1, NULL, 0));\n\nstatic SPINAND_OP_VARIANTS(write_cache_variants,\n\t\tSPINAND_PROG_LOAD_X4(true, 0, NULL, 0),\n\t\tSPINAND_PROG_LOAD(true, 0, NULL, 0));\n\nstatic SPINAND_OP_VARIANTS(update_cache_variants,\n\t\tSPINAND_PROG_LOAD_X4(false, 0, NULL, 0),\n\t\tSPINAND_PROG_LOAD(false, 0, NULL, 0));\n\nstatic int w25m02gv_ooblayout_ecc(struct mtd_info *mtd, int section,\n\t\t\t\t  struct mtd_oob_region *region)\n{\n\tif (section > 3)\n\t\treturn -ERANGE;\n\n\tregion->offset = (16 * section) + 8;\n\tregion->length = 8;\n\n\treturn 0;\n}\n\nstatic int w25m02gv_ooblayout_free(struct mtd_info *mtd, int section,\n\t\t\t\t   struct mtd_oob_region *region)\n{\n\tif (section > 3)\n\t\treturn -ERANGE;\n\n\tregion->offset = (16 * section) + 2;\n\tregion->length = 6;\n\n\treturn 0;\n}\n\nstatic const struct mtd_ooblayout_ops w25m02gv_ooblayout = {\n\t.ecc = w25m02gv_ooblayout_ecc,\n\t.free = w25m02gv_ooblayout_free,\n};\n\nstatic int w25m02gv_select_target(struct spinand_device *spinand,\n\t\t\t\t  unsigned int target)\n{\n\tstruct spi_mem_op op = SPI_MEM_OP(SPI_MEM_OP_CMD(0xc2, 1),\n\t\t\t\t\t  SPI_MEM_OP_NO_ADDR,\n\t\t\t\t\t  SPI_MEM_OP_NO_DUMMY,\n\t\t\t\t\t  SPI_MEM_OP_DATA_OUT(1,\n\t\t\t\t\t\t\tspinand->scratchbuf,\n\t\t\t\t\t\t\t1));\n\n\t*spinand->scratchbuf = target;\n\treturn spi_mem_exec_op(spinand->spimem, &op);\n}\n\nstatic int w25n02kv_ooblayout_ecc(struct mtd_info *mtd, int section,\n\t\t\t\t  struct mtd_oob_region *region)\n{\n\tif (section > 3)\n\t\treturn -ERANGE;\n\n\tregion->offset = 64 + (16 * section);\n\tregion->length = 13;\n\n\treturn 0;\n}\n\nstatic int w25n02kv_ooblayout_free(struct mtd_info *mtd, int section,\n\t\t\t\t   struct mtd_oob_region *region)\n{\n\tif (section > 3)\n\t\treturn -ERANGE;\n\n\tregion->offset = (16 * section) + 2;\n\tregion->length = 14;\n\n\treturn 0;\n}\n\nstatic const struct mtd_ooblayout_ops w25n02kv_ooblayout = {\n\t.ecc = w25n02kv_ooblayout_ecc,\n\t.free = w25n02kv_ooblayout_free,\n};\n\nstatic int w25n02kv_ecc_get_status(struct spinand_device *spinand,\n\t\t\t\t   u8 status)\n{\n\tstruct nand_device *nand = spinand_to_nand(spinand);\n\tu8 mbf = 0;\n\tstruct spi_mem_op op = SPINAND_GET_FEATURE_OP(0x30, spinand->scratchbuf);\n\n\tswitch (status & STATUS_ECC_MASK) {\n\tcase STATUS_ECC_NO_BITFLIPS:\n\t\treturn 0;\n\n\tcase STATUS_ECC_UNCOR_ERROR:\n\t\treturn -EBADMSG;\n\n\tcase STATUS_ECC_HAS_BITFLIPS:\n\t\t \n\t\tif (spi_mem_exec_op(spinand->spimem, &op))\n\t\t\treturn nanddev_get_ecc_conf(nand)->strength;\n\n\t\tmbf = *(spinand->scratchbuf) >> 4;\n\n\t\tif (WARN_ON(mbf > nanddev_get_ecc_conf(nand)->strength || !mbf))\n\t\t\treturn nanddev_get_ecc_conf(nand)->strength;\n\n\t\treturn mbf;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic const struct spinand_info winbond_spinand_table[] = {\n\tSPINAND_INFO(\"W25M02GV\",\n\t\t     SPINAND_ID(SPINAND_READID_METHOD_OPCODE_DUMMY, 0xab, 0x21),\n\t\t     NAND_MEMORG(1, 2048, 64, 64, 1024, 20, 1, 1, 2),\n\t\t     NAND_ECCREQ(1, 512),\n\t\t     SPINAND_INFO_OP_VARIANTS(&read_cache_variants,\n\t\t\t\t\t      &write_cache_variants,\n\t\t\t\t\t      &update_cache_variants),\n\t\t     0,\n\t\t     SPINAND_ECCINFO(&w25m02gv_ooblayout, NULL),\n\t\t     SPINAND_SELECT_TARGET(w25m02gv_select_target)),\n\tSPINAND_INFO(\"W25N01GV\",\n\t\t     SPINAND_ID(SPINAND_READID_METHOD_OPCODE_DUMMY, 0xaa, 0x21),\n\t\t     NAND_MEMORG(1, 2048, 64, 64, 1024, 20, 1, 1, 1),\n\t\t     NAND_ECCREQ(1, 512),\n\t\t     SPINAND_INFO_OP_VARIANTS(&read_cache_variants,\n\t\t\t\t\t      &write_cache_variants,\n\t\t\t\t\t      &update_cache_variants),\n\t\t     0,\n\t\t     SPINAND_ECCINFO(&w25m02gv_ooblayout, NULL)),\n\tSPINAND_INFO(\"W25N02KV\",\n\t\t     SPINAND_ID(SPINAND_READID_METHOD_OPCODE_DUMMY, 0xaa, 0x22),\n\t\t     NAND_MEMORG(1, 2048, 128, 64, 2048, 40, 1, 1, 1),\n\t\t     NAND_ECCREQ(8, 512),\n\t\t     SPINAND_INFO_OP_VARIANTS(&read_cache_variants,\n\t\t\t\t\t      &write_cache_variants,\n\t\t\t\t\t      &update_cache_variants),\n\t\t     0,\n\t\t     SPINAND_ECCINFO(&w25n02kv_ooblayout, w25n02kv_ecc_get_status)),\n};\n\nstatic int winbond_spinand_init(struct spinand_device *spinand)\n{\n\tstruct nand_device *nand = spinand_to_nand(spinand);\n\tunsigned int i;\n\n\t \n\tfor (i = 0; i < nand->memorg.ntargets; i++) {\n\t\tspinand_select_target(spinand, i);\n\t\tspinand_upd_cfg(spinand, WINBOND_CFG_BUF_READ,\n\t\t\t\tWINBOND_CFG_BUF_READ);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct spinand_manufacturer_ops winbond_spinand_manuf_ops = {\n\t.init = winbond_spinand_init,\n};\n\nconst struct spinand_manufacturer winbond_spinand_manufacturer = {\n\t.id = SPINAND_MFR_WINBOND,\n\t.name = \"Winbond\",\n\t.chips = winbond_spinand_table,\n\t.nchips = ARRAY_SIZE(winbond_spinand_table),\n\t.ops = &winbond_spinand_manuf_ops,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}