{
  "module_name": "nftlmount.c",
  "hash_id": "8ac723584e0f62cdf9c93bb7c0379a9ed7976d016a8599fdb6c8857343054a50",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/nftlmount.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <asm/errno.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/mtd/mtd.h>\n#include <linux/mtd/rawnand.h>\n#include <linux/mtd/nftl.h>\n\n#define SECTORSIZE 512\n\n \nstatic int find_boot_record(struct NFTLrecord *nftl)\n{\n\tstruct nftl_uci1 h1;\n\tunsigned int block, boot_record_count = 0;\n\tsize_t retlen;\n\tu8 buf[SECTORSIZE];\n\tstruct NFTLMediaHeader *mh = &nftl->MediaHdr;\n\tstruct mtd_info *mtd = nftl->mbd.mtd;\n\tunsigned int i;\n\n         \n\t \n\tnftl->EraseSize = nftl->mbd.mtd->erasesize;\n        nftl->nb_blocks = (u32)nftl->mbd.mtd->size / nftl->EraseSize;\n\n\tnftl->MediaUnit = BLOCK_NIL;\n\tnftl->SpareMediaUnit = BLOCK_NIL;\n\n\t \n\tfor (block = 0; block < nftl->nb_blocks; block++) {\n\t\tint ret;\n\n\t\t \n\t\tret = mtd_read(mtd, block * nftl->EraseSize, SECTORSIZE,\n\t\t\t       &retlen, buf);\n\t\t \n\t\tif (retlen != SECTORSIZE) {\n\t\t\tstatic int warncount = 5;\n\n\t\t\tif (warncount) {\n\t\t\t\tprintk(KERN_WARNING \"Block read at 0x%x of mtd%d failed: %d\\n\",\n\t\t\t\t       block * nftl->EraseSize, nftl->mbd.mtd->index, ret);\n\t\t\t\tif (!--warncount)\n\t\t\t\t\tprintk(KERN_WARNING \"Further failures for this block will not be printed\\n\");\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (retlen < 6 || memcmp(buf, \"ANAND\", 6)) {\n\t\t\t \n#if 0\n\t\t\tprintk(KERN_DEBUG \"ANAND header not found at 0x%x in mtd%d\\n\",\n\t\t\t       block * nftl->EraseSize, nftl->mbd.mtd->index);\n#endif\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tret = nftl_read_oob(mtd, block * nftl->EraseSize +\n\t\t\t\t\t SECTORSIZE + 8, 8, &retlen,\n\t\t\t\t\t (char *)&h1);\n\t\tif (ret < 0) {\n\t\t\tprintk(KERN_WARNING \"ANAND header found at 0x%x in mtd%d, but OOB data read failed (err %d)\\n\",\n\t\t\t       block * nftl->EraseSize, nftl->mbd.mtd->index, ret);\n\t\t\tcontinue;\n\t\t}\n\n#if 0  \n\t\tif (le16_to_cpu(h1.EraseMark | h1.EraseMark1) != ERASE_MARK) {\n\t\t\tprintk(KERN_NOTICE \"ANAND header found at 0x%x in mtd%d, but erase mark not present (0x%04x,0x%04x instead)\\n\",\n\t\t\t       block * nftl->EraseSize, nftl->mbd.mtd->index,\n\t\t\t       le16_to_cpu(h1.EraseMark), le16_to_cpu(h1.EraseMark1));\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tret = mtd->read(mtd, block * nftl->EraseSize, SECTORSIZE,\n\t\t\t\t&retlen, buf);\n\t\tif (ret < 0) {\n\t\t\tprintk(KERN_NOTICE \"ANAND header found at 0x%x in mtd%d, but ECC read failed (err %d)\\n\",\n\t\t\t       block * nftl->EraseSize, nftl->mbd.mtd->index, ret);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (memcmp(buf, \"ANAND\", 6)) {\n\t\t\tprintk(KERN_NOTICE \"ANAND header found at 0x%x in mtd%d, but went away on reread!\\n\",\n\t\t\t       block * nftl->EraseSize, nftl->mbd.mtd->index);\n\t\t\tprintk(KERN_NOTICE \"New data are: %6ph\\n\", buf);\n\t\t\tcontinue;\n\t\t}\n#endif\n\t\t \n\n\t\tif (boot_record_count) {\n\t\t\t \n\t\t\tif (memcmp(mh, buf, sizeof(struct NFTLMediaHeader))) {\n\t\t\t\tprintk(KERN_NOTICE \"NFTL Media Headers at 0x%x and 0x%x disagree.\\n\",\n\t\t\t\t       nftl->MediaUnit * nftl->EraseSize, block * nftl->EraseSize);\n\t\t\t\t \n\t\t\t\tif (boot_record_count < 2) {\n\t\t\t\t\t \n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (boot_record_count == 1)\n\t\t\t\tnftl->SpareMediaUnit = block;\n\n\t\t\t \n\t\t\tnftl->ReplUnitTable[block] = BLOCK_RESERVED;\n\n\n\t\t\tboot_record_count++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tmemcpy(mh, buf, sizeof(struct NFTLMediaHeader));\n\n\t\t \n#if 0\nThe new DiskOnChip driver scans the MediaHeader itself, and presents a virtual\nerasesize based on UnitSizeFactor.  So the erasesize we read from the mtd\ndevice is already correct.\n\t\tif (mh->UnitSizeFactor == 0) {\n\t\t\tprintk(KERN_NOTICE \"NFTL: UnitSizeFactor 0x00 detected. This violates the spec but we think we know what it means...\\n\");\n\t\t} else if (mh->UnitSizeFactor < 0xfc) {\n\t\t\tprintk(KERN_NOTICE \"Sorry, we don't support UnitSizeFactor 0x%02x\\n\",\n\t\t\t       mh->UnitSizeFactor);\n\t\t\treturn -1;\n\t\t} else if (mh->UnitSizeFactor != 0xff) {\n\t\t\tprintk(KERN_NOTICE \"WARNING: Support for NFTL with UnitSizeFactor 0x%02x is experimental\\n\",\n\t\t\t       mh->UnitSizeFactor);\n\t\t\tnftl->EraseSize = nftl->mbd.mtd->erasesize << (0xff - mh->UnitSizeFactor);\n\t\t\tnftl->nb_blocks = (u32)nftl->mbd.mtd->size / nftl->EraseSize;\n\t\t}\n#endif\n\t\tnftl->nb_boot_blocks = le16_to_cpu(mh->FirstPhysicalEUN);\n\t\tif ((nftl->nb_boot_blocks + 2) >= nftl->nb_blocks) {\n\t\t\tprintk(KERN_NOTICE \"NFTL Media Header sanity check failed:\\n\");\n\t\t\tprintk(KERN_NOTICE \"nb_boot_blocks (%d) + 2 > nb_blocks (%d)\\n\",\n\t\t\t       nftl->nb_boot_blocks, nftl->nb_blocks);\n\t\t\treturn -1;\n\t\t}\n\n\t\tnftl->numvunits = le32_to_cpu(mh->FormattedSize) / nftl->EraseSize;\n\t\tif (nftl->numvunits > (nftl->nb_blocks - nftl->nb_boot_blocks - 2)) {\n\t\t\tprintk(KERN_NOTICE \"NFTL Media Header sanity check failed:\\n\");\n\t\t\tprintk(KERN_NOTICE \"numvunits (%d) > nb_blocks (%d) - nb_boot_blocks(%d) - 2\\n\",\n\t\t\t       nftl->numvunits, nftl->nb_blocks, nftl->nb_boot_blocks);\n\t\t\treturn -1;\n\t\t}\n\n\t\tnftl->mbd.size  = nftl->numvunits * (nftl->EraseSize / SECTORSIZE);\n\n\t\t \n\t\tnftl->nb_blocks = le16_to_cpu(mh->NumEraseUnits) + le16_to_cpu(mh->FirstPhysicalEUN);\n\n\t\t \n\t\tnftl->lastEUN = nftl->nb_blocks - 1;\n\n\t\t \n\t\tnftl->EUNtable = kmalloc_array(nftl->nb_blocks, sizeof(u16),\n\t\t\t\t\t       GFP_KERNEL);\n\t\tif (!nftl->EUNtable)\n\t\t\treturn -ENOMEM;\n\n\t\tnftl->ReplUnitTable = kmalloc_array(nftl->nb_blocks,\n\t\t\t\t\t\t    sizeof(u16),\n\t\t\t\t\t\t    GFP_KERNEL);\n\t\tif (!nftl->ReplUnitTable) {\n\t\t\tkfree(nftl->EUNtable);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\t \n\t\tfor (i = 0; i < nftl->nb_boot_blocks; i++)\n\t\t\tnftl->ReplUnitTable[i] = BLOCK_RESERVED;\n\t\t \n\t\tfor (; i < nftl->nb_blocks; i++) {\n\t\t\tnftl->ReplUnitTable[i] = BLOCK_NOTEXPLORED;\n\t\t}\n\n\t\t \n\t\tnftl->ReplUnitTable[block] = BLOCK_RESERVED;\n\n\t\t \n\t\tfor (i = 0; i < nftl->nb_blocks; i++) {\n#if 0\nThe new DiskOnChip driver already scanned the bad block table.  Just query it.\n\t\t\tif ((i & (SECTORSIZE - 1)) == 0) {\n\t\t\t\t \n\t\t\t\tret = mtd->read(nftl->mbd.mtd,\n\t\t\t\t\t\tblock * nftl->EraseSize + i +\n\t\t\t\t\t\tSECTORSIZE, SECTORSIZE,\n\t\t\t\t\t\t&retlen, buf);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tprintk(KERN_NOTICE \"Read of bad sector table failed (err %d)\\n\",\n\t\t\t\t\t       ret);\n\t\t\t\t\tkfree(nftl->ReplUnitTable);\n\t\t\t\t\tkfree(nftl->EUNtable);\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\t \n\t\t\tif (buf[i & (SECTORSIZE - 1)] != 0xff)\n\t\t\t\tnftl->ReplUnitTable[i] = BLOCK_RESERVED;\n#endif\n\t\t\tif (mtd_block_isbad(nftl->mbd.mtd,\n\t\t\t\t\t    i * nftl->EraseSize))\n\t\t\t\tnftl->ReplUnitTable[i] = BLOCK_RESERVED;\n\t\t}\n\n\t\tnftl->MediaUnit = block;\n\t\tboot_record_count++;\n\n\t}  \n\n\treturn boot_record_count?0:-1;\n}\n\nstatic int memcmpb(void *a, int c, int n)\n{\n\tint i;\n\tfor (i = 0; i < n; i++) {\n\t\tif (c != ((unsigned char *)a)[i])\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n \nstatic int check_free_sectors(struct NFTLrecord *nftl, unsigned int address, int len,\n\t\t\t      int check_oob)\n{\n\tstruct mtd_info *mtd = nftl->mbd.mtd;\n\tsize_t retlen;\n\tint i, ret;\n\tu8 *buf;\n\n\tbuf = kmalloc(SECTORSIZE + mtd->oobsize, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tret = -1;\n\tfor (i = 0; i < len; i += SECTORSIZE) {\n\t\tif (mtd_read(mtd, address, SECTORSIZE, &retlen, buf))\n\t\t\tgoto out;\n\t\tif (memcmpb(buf, 0xff, SECTORSIZE) != 0)\n\t\t\tgoto out;\n\n\t\tif (check_oob) {\n\t\t\tif(nftl_read_oob(mtd, address, mtd->oobsize,\n\t\t\t\t\t &retlen, &buf[SECTORSIZE]) < 0)\n\t\t\t\tgoto out;\n\t\t\tif (memcmpb(buf + SECTORSIZE, 0xff, mtd->oobsize) != 0)\n\t\t\t\tgoto out;\n\t\t}\n\t\taddress += SECTORSIZE;\n\t}\n\n\tret = 0;\n\nout:\n\tkfree(buf);\n\treturn ret;\n}\n\n \nint NFTL_formatblock(struct NFTLrecord *nftl, int block)\n{\n\tsize_t retlen;\n\tunsigned int nb_erases, erase_mark;\n\tstruct nftl_uci1 uci;\n\tstruct erase_info *instr = &nftl->instr;\n\tstruct mtd_info *mtd = nftl->mbd.mtd;\n\n\t \n\tif (nftl_read_oob(mtd, block * nftl->EraseSize + SECTORSIZE + 8,\n\t\t\t  8, &retlen, (char *)&uci) < 0)\n\t\tgoto default_uci1;\n\n\terase_mark = le16_to_cpu ((uci.EraseMark | uci.EraseMark1));\n\tif (erase_mark != ERASE_MARK) {\n\tdefault_uci1:\n\t\tuci.EraseMark = cpu_to_le16(ERASE_MARK);\n\t\tuci.EraseMark1 = cpu_to_le16(ERASE_MARK);\n\t\tuci.WearInfo = cpu_to_le32(0);\n\t}\n\n\tmemset(instr, 0, sizeof(struct erase_info));\n\n\t \n\tinstr->addr = block * nftl->EraseSize;\n\tinstr->len = nftl->EraseSize;\n\tif (mtd_erase(mtd, instr)) {\n\t\tprintk(\"Error while formatting block %d\\n\", block);\n\t\tgoto fail;\n\t}\n\n\t \n\tnb_erases = le32_to_cpu(uci.WearInfo);\n\tnb_erases++;\n\n\t \n\tif (nb_erases == 0)\n\t\tnb_erases = 1;\n\n\t \n\tif (check_free_sectors(nftl, instr->addr, nftl->EraseSize, 1) != 0)\n\t\tgoto fail;\n\n\tuci.WearInfo = le32_to_cpu(nb_erases);\n\tif (nftl_write_oob(mtd, block * nftl->EraseSize + SECTORSIZE +\n\t\t\t   8, 8, &retlen, (char *)&uci) < 0)\n\t\tgoto fail;\n\treturn 0;\nfail:\n\t \n\tmtd_block_markbad(nftl->mbd.mtd, instr->addr);\n\treturn -1;\n}\n\n \nstatic void check_sectors_in_chain(struct NFTLrecord *nftl, unsigned int first_block)\n{\n\tstruct mtd_info *mtd = nftl->mbd.mtd;\n\tunsigned int block, i, status;\n\tstruct nftl_bci bci;\n\tint sectors_per_block;\n\tsize_t retlen;\n\n\tsectors_per_block = nftl->EraseSize / SECTORSIZE;\n\tblock = first_block;\n\tfor (;;) {\n\t\tfor (i = 0; i < sectors_per_block; i++) {\n\t\t\tif (nftl_read_oob(mtd,\n\t\t\t\t\t  block * nftl->EraseSize + i * SECTORSIZE,\n\t\t\t\t\t  8, &retlen, (char *)&bci) < 0)\n\t\t\t\tstatus = SECTOR_IGNORE;\n\t\t\telse\n\t\t\t\tstatus = bci.Status | bci.Status1;\n\n\t\t\tswitch(status) {\n\t\t\tcase SECTOR_FREE:\n\t\t\t\t \n\t\t\t\tif (memcmpb(&bci, 0xff, 8) != 0 ||\n\t\t\t\t    check_free_sectors(nftl, block * nftl->EraseSize + i * SECTORSIZE,\n\t\t\t\t\t\t       SECTORSIZE, 0) != 0) {\n\t\t\t\t\tprintk(\"Incorrect free sector %d in block %d: \"\n\t\t\t\t\t       \"marking it as ignored\\n\",\n\t\t\t\t\t       i, block);\n\n\t\t\t\t\t \n\t\t\t\t\tbci.Status = SECTOR_IGNORE;\n\t\t\t\t\tbci.Status1 = SECTOR_IGNORE;\n\t\t\t\t\tnftl_write_oob(mtd, block *\n\t\t\t\t\t\t       nftl->EraseSize +\n\t\t\t\t\t\t       i * SECTORSIZE, 8,\n\t\t\t\t\t\t       &retlen, (char *)&bci);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tblock = nftl->ReplUnitTable[block];\n\t\tif (!(block == BLOCK_NIL || block < nftl->nb_blocks))\n\t\t\tprintk(\"incorrect ReplUnitTable[] : %d\\n\", block);\n\t\tif (block == BLOCK_NIL || block >= nftl->nb_blocks)\n\t\t\tbreak;\n\t}\n}\n\n \nstatic int calc_chain_length(struct NFTLrecord *nftl, unsigned int first_block)\n{\n\tunsigned int length = 0, block = first_block;\n\n\tfor (;;) {\n\t\tlength++;\n\t\t \n\t\tif (length >= nftl->nb_blocks) {\n\t\t\tprintk(\"nftl: length too long %d !\\n\", length);\n\t\t\tbreak;\n\t\t}\n\n\t\tblock = nftl->ReplUnitTable[block];\n\t\tif (!(block == BLOCK_NIL || block < nftl->nb_blocks))\n\t\t\tprintk(\"incorrect ReplUnitTable[] : %d\\n\", block);\n\t\tif (block == BLOCK_NIL || block >= nftl->nb_blocks)\n\t\t\tbreak;\n\t}\n\treturn length;\n}\n\n \nstatic void format_chain(struct NFTLrecord *nftl, unsigned int first_block)\n{\n\tunsigned int block = first_block, block1;\n\n\tprintk(\"Formatting chain at block %d\\n\", first_block);\n\n\tfor (;;) {\n\t\tblock1 = nftl->ReplUnitTable[block];\n\n\t\tprintk(\"Formatting block %d\\n\", block);\n\t\tif (NFTL_formatblock(nftl, block) < 0) {\n\t\t\t \n\t\t\tnftl->ReplUnitTable[block] = BLOCK_RESERVED;\n\t\t} else {\n\t\t\tnftl->ReplUnitTable[block] = BLOCK_FREE;\n\t\t}\n\n\t\t \n\t\tblock = block1;\n\n\t\tif (!(block == BLOCK_NIL || block < nftl->nb_blocks))\n\t\t\tprintk(\"incorrect ReplUnitTable[] : %d\\n\", block);\n\t\tif (block == BLOCK_NIL || block >= nftl->nb_blocks)\n\t\t\tbreak;\n\t}\n}\n\n \nstatic int check_and_mark_free_block(struct NFTLrecord *nftl, int block)\n{\n\tstruct mtd_info *mtd = nftl->mbd.mtd;\n\tstruct nftl_uci1 h1;\n\tunsigned int erase_mark;\n\tsize_t retlen;\n\n\t \n\tif (nftl_read_oob(mtd, block * nftl->EraseSize + SECTORSIZE + 8, 8,\n\t\t\t  &retlen, (char *)&h1) < 0)\n\t\treturn -1;\n\n\terase_mark = le16_to_cpu ((h1.EraseMark | h1.EraseMark1));\n\tif (erase_mark != ERASE_MARK) {\n\t\t \n\t\tif (check_free_sectors (nftl, block * nftl->EraseSize, nftl->EraseSize, 1) != 0)\n\t\t\treturn -1;\n\n\t\t \n\t\th1.EraseMark = cpu_to_le16(ERASE_MARK);\n\t\th1.EraseMark1 = cpu_to_le16(ERASE_MARK);\n\t\th1.WearInfo = cpu_to_le32(0);\n\t\tif (nftl_write_oob(mtd,\n\t\t\t\t   block * nftl->EraseSize + SECTORSIZE + 8, 8,\n\t\t\t\t   &retlen, (char *)&h1) < 0)\n\t\t\treturn -1;\n\t} else {\n#if 0\n\t\t \n\t\tfor (i = 0; i < nftl->EraseSize; i += SECTORSIZE) {\n\t\t\t \n\t\t\tif (check_free_sectors (nftl, block * nftl->EraseSize + i,\n\t\t\t\t\t\tSECTORSIZE, 0) != 0)\n\t\t\t\treturn -1;\n\n\t\t\tif (nftl_read_oob(mtd, block * nftl->EraseSize + i,\n\t\t\t\t\t  16, &retlen, buf) < 0)\n\t\t\t\treturn -1;\n\t\t\tif (i == SECTORSIZE) {\n\t\t\t\t \n\t\t\t\tif (memcmpb(buf, 0xff, 8))\n\t\t\t\t\treturn -1;\n\t\t\t} else {\n\t\t\t\tif (memcmpb(buf, 0xff, 16))\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n#endif\n\t}\n\n\treturn 0;\n}\n\n \nstatic int get_fold_mark(struct NFTLrecord *nftl, unsigned int block)\n{\n\tstruct mtd_info *mtd = nftl->mbd.mtd;\n\tstruct nftl_uci2 uci;\n\tsize_t retlen;\n\n\tif (nftl_read_oob(mtd, block * nftl->EraseSize + 2 * SECTORSIZE + 8,\n\t\t\t  8, &retlen, (char *)&uci) < 0)\n\t\treturn 0;\n\n\treturn le16_to_cpu((uci.FoldMark | uci.FoldMark1));\n}\n\nint NFTL_mount(struct NFTLrecord *s)\n{\n\tint i;\n\tunsigned int first_logical_block, logical_block, rep_block, erase_mark;\n\tunsigned int block, first_block, is_first_block;\n\tint chain_length, do_format_chain;\n\tstruct nftl_uci0 h0;\n\tstruct nftl_uci1 h1;\n\tstruct mtd_info *mtd = s->mbd.mtd;\n\tsize_t retlen;\n\n\t \n\tif (find_boot_record(s) < 0) {\n\t\tprintk(\"Could not find valid boot record\\n\");\n\t\treturn -1;\n\t}\n\n\t \n\tfor (i = 0; i < s->nb_blocks; i++) {\n\t\ts->EUNtable[i] = BLOCK_NIL;\n\t}\n\n\t \n\tfirst_logical_block = 0;\n\tfor (first_block = 0; first_block < s->nb_blocks; first_block++) {\n\t\t \n\t\tif (s->ReplUnitTable[first_block] == BLOCK_NOTEXPLORED) {\n\t\t\tblock = first_block;\n\t\t\tchain_length = 0;\n\t\t\tdo_format_chain = 0;\n\n\t\t\tfor (;;) {\n\t\t\t\t \n\t\t\t\tif (nftl_read_oob(mtd,\n\t\t\t\t\t\t  block * s->EraseSize + 8, 8,\n\t\t\t\t\t\t  &retlen, (char *)&h0) < 0 ||\n\t\t\t\t    nftl_read_oob(mtd,\n\t\t\t\t\t\t  block * s->EraseSize +\n\t\t\t\t\t\t  SECTORSIZE + 8, 8,\n\t\t\t\t\t\t  &retlen, (char *)&h1) < 0) {\n\t\t\t\t\ts->ReplUnitTable[block] = BLOCK_NIL;\n\t\t\t\t\tdo_format_chain = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tlogical_block = le16_to_cpu ((h0.VirtUnitNum | h0.SpareVirtUnitNum));\n\t\t\t\trep_block = le16_to_cpu ((h0.ReplUnitNum | h0.SpareReplUnitNum));\n\t\t\t\terase_mark = le16_to_cpu ((h1.EraseMark | h1.EraseMark1));\n\n\t\t\t\tis_first_block = !(logical_block >> 15);\n\t\t\t\tlogical_block = logical_block & 0x7fff;\n\n\t\t\t\t \n\t\t\t\tif (erase_mark != ERASE_MARK || logical_block >= s->nb_blocks) {\n\t\t\t\t\tif (chain_length == 0) {\n\t\t\t\t\t\t \n\t\t\t\t\t\tif (check_and_mark_free_block(s, block) < 0) {\n\t\t\t\t\t\t\t \n\t\t\t\t\t\t\tprintk(\"Formatting block %d\\n\", block);\n\t\t\t\t\t\t\tif (NFTL_formatblock(s, block) < 0) {\n\t\t\t\t\t\t\t\t \n\t\t\t\t\t\t\t\ts->ReplUnitTable[block] = BLOCK_RESERVED;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ts->ReplUnitTable[block] = BLOCK_FREE;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t \n\t\t\t\t\t\t\ts->ReplUnitTable[block] = BLOCK_FREE;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t \n\t\t\t\t\t\tgoto examine_ReplUnitTable;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t \n\t\t\t\t\t\tprintk(\"Block %d: free but referenced in chain %d\\n\",\n\t\t\t\t\t\t       block, first_block);\n\t\t\t\t\t\ts->ReplUnitTable[block] = BLOCK_NIL;\n\t\t\t\t\t\tdo_format_chain = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t \n\t\t\t\tif (chain_length == 0) {\n\t\t\t\t\t \n\t\t\t\t\tif (!is_first_block)\n\t\t\t\t\t\tgoto examine_ReplUnitTable;\n\t\t\t\t\tfirst_logical_block = logical_block;\n\t\t\t\t} else {\n\t\t\t\t\tif (logical_block != first_logical_block) {\n\t\t\t\t\t\tprintk(\"Block %d: incorrect logical block: %d expected: %d\\n\",\n\t\t\t\t\t\t       block, logical_block, first_logical_block);\n\t\t\t\t\t\t \n\t\t\t\t\t\tdo_format_chain = 1;\n\t\t\t\t\t}\n\t\t\t\t\tif (is_first_block) {\n\t\t\t\t\t\t \n\t\t\t\t\t\tif (get_fold_mark(s, block) != FOLD_MARK_IN_PROGRESS ||\n\t\t\t\t\t\t    rep_block != 0xffff) {\n\t\t\t\t\t\t\tprintk(\"Block %d: incorrectly marked as first block in chain\\n\",\n\t\t\t\t\t\t\t       block);\n\t\t\t\t\t\t\t \n\t\t\t\t\t\t\tdo_format_chain = 1;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tprintk(\"Block %d: folding in progress - ignoring first block flag\\n\",\n\t\t\t\t\t\t\t       block);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tchain_length++;\n\t\t\t\tif (rep_block == 0xffff) {\n\t\t\t\t\t \n\t\t\t\t\ts->ReplUnitTable[block] = BLOCK_NIL;\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (rep_block >= s->nb_blocks) {\n\t\t\t\t\tprintk(\"Block %d: referencing invalid block %d\\n\",\n\t\t\t\t\t       block, rep_block);\n\t\t\t\t\tdo_format_chain = 1;\n\t\t\t\t\ts->ReplUnitTable[block] = BLOCK_NIL;\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (s->ReplUnitTable[rep_block] != BLOCK_NOTEXPLORED) {\n\t\t\t\t\t \n\t\t\t\t\tif (s->ReplUnitTable[rep_block] == BLOCK_NIL &&\n\t\t\t\t\t    s->EUNtable[first_logical_block] == rep_block &&\n\t\t\t\t\t    get_fold_mark(s, first_block) == FOLD_MARK_IN_PROGRESS) {\n\t\t\t\t\t\t \n\t\t\t\t\t\tprintk(\"Block %d: folding in progress - ignoring first block flag\\n\",\n\t\t\t\t\t\t       rep_block);\n\t\t\t\t\t\ts->ReplUnitTable[block] = rep_block;\n\t\t\t\t\t\ts->EUNtable[first_logical_block] = BLOCK_NIL;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tprintk(\"Block %d: referencing block %d already in another chain\\n\",\n\t\t\t\t\t\t       block, rep_block);\n\t\t\t\t\t\t \n\t\t\t\t\t\tdo_format_chain = 1;\n\t\t\t\t\t\ts->ReplUnitTable[block] = BLOCK_NIL;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t \n\t\t\t\t\ts->ReplUnitTable[block] = rep_block;\n\t\t\t\t\tblock = rep_block;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t \n\t\t\tif (do_format_chain) {\n\t\t\t\t \n\t\t\t\tformat_chain(s, first_block);\n\t\t\t} else {\n\t\t\t\tunsigned int first_block1, chain_to_format, chain_length1;\n\t\t\t\tint fold_mark;\n\n\t\t\t\t \n\t\t\t\tfold_mark = get_fold_mark(s, first_block);\n\t\t\t\tif (fold_mark == 0) {\n\t\t\t\t\t \n\t\t\t\t\tprintk(\"Could read foldmark at block %d\\n\", first_block);\n\t\t\t\t\tformat_chain(s, first_block);\n\t\t\t\t} else {\n\t\t\t\t\tif (fold_mark == FOLD_MARK_IN_PROGRESS)\n\t\t\t\t\t\tcheck_sectors_in_chain(s, first_block);\n\n\t\t\t\t\t \n\t\t\t\t\tfirst_block1 = s->EUNtable[first_logical_block];\n\t\t\t\t\tif (first_block1 != BLOCK_NIL) {\n\t\t\t\t\t\t \n\t\t\t\t\t\tchain_length1 = calc_chain_length(s, first_block1);\n\t\t\t\t\t\tprintk(\"Two chains at blocks %d (len=%d) and %d (len=%d)\\n\",\n\t\t\t\t\t\t       first_block1, chain_length1, first_block, chain_length);\n\n\t\t\t\t\t\tif (chain_length >= chain_length1) {\n\t\t\t\t\t\t\tchain_to_format = first_block1;\n\t\t\t\t\t\t\ts->EUNtable[first_logical_block] = first_block;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tchain_to_format = first_block;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tformat_chain(s, chain_to_format);\n\t\t\t\t\t} else {\n\t\t\t\t\t\ts->EUNtable[first_logical_block] = first_block;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\texamine_ReplUnitTable:;\n\t}\n\n\t \n\ts->numfreeEUNs = 0;\n\ts->LastFreeEUN = le16_to_cpu(s->MediaHdr.FirstPhysicalEUN);\n\n\tfor (block = 0; block < s->nb_blocks; block++) {\n\t\tif (s->ReplUnitTable[block] == BLOCK_NOTEXPLORED) {\n\t\t\tprintk(\"Unreferenced block %d, formatting it\\n\", block);\n\t\t\tif (NFTL_formatblock(s, block) < 0)\n\t\t\t\ts->ReplUnitTable[block] = BLOCK_RESERVED;\n\t\t\telse\n\t\t\t\ts->ReplUnitTable[block] = BLOCK_FREE;\n\t\t}\n\t\tif (s->ReplUnitTable[block] == BLOCK_FREE) {\n\t\t\ts->numfreeEUNs++;\n\t\t\ts->LastFreeEUN = block;\n\t\t}\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}