{
  "module_name": "rfd_ftl.c",
  "hash_id": "9ab4000720da229f8d1fac7d009d0686b86d3d034e51674a8c6281e0a14a9ecd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/rfd_ftl.c",
  "human_readable_source": "\n \n\n#include <linux/hdreg.h>\n#include <linux/init.h>\n#include <linux/mtd/blktrans.h>\n#include <linux/mtd/mtd.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/module.h>\n\n#include <asm/types.h>\n\nstatic int block_size = 0;\nmodule_param(block_size, int, 0);\nMODULE_PARM_DESC(block_size, \"Block size to use by RFD, defaults to erase unit size\");\n\n#define PREFIX \"rfd_ftl: \"\n\n \n#ifndef RFD_FTL_MAJOR\n#define RFD_FTL_MAJOR\t\t256\n#endif\n\n \n#define PART_BITS\t\t4\n\n \n#define RFD_MAGIC\t\t0x9193\n\n \n\n \n\n \n#define HEADER_MAP_OFFSET\t3\n#define SECTOR_DELETED\t\t0x0000\n#define SECTOR_ZERO\t\t0xfffe\n#define SECTOR_FREE\t\t0xffff\n\n#define SECTOR_SIZE\t\t512\n\n#define SECTORS_PER_TRACK\t63\n\nstruct block {\n\tenum {\n\t\tBLOCK_OK,\n\t\tBLOCK_ERASING,\n\t\tBLOCK_ERASED,\n\t\tBLOCK_UNUSED,\n\t\tBLOCK_FAILED\n\t} state;\n\tint free_sectors;\n\tint used_sectors;\n\tint erases;\n\tu_long offset;\n};\n\nstruct partition {\n\tstruct mtd_blktrans_dev mbd;\n\n\tu_int block_size;\t\t \n\tu_int total_blocks;\t\t \n\tu_int header_sectors_per_block;\t \n\tu_int data_sectors_per_block;\t \n\tu_int sector_count;\t\t \n\tu_int header_size;\t\t \n\tint reserved_block;\t\t \n\tint current_block;\t\t \n\tu16 *header_cache;\t\t \n\n\tint is_reclaiming;\n\tint cylinders;\n\tint errors;\n\tu_long *sector_map;\n\tstruct block *blocks;\n};\n\nstatic int rfd_ftl_writesect(struct mtd_blktrans_dev *dev, u_long sector, char *buf);\n\nstatic int build_block_map(struct partition *part, int block_no)\n{\n\tstruct block *block = &part->blocks[block_no];\n\tint i;\n\n\tblock->offset = part->block_size * block_no;\n\n\tif (le16_to_cpu(part->header_cache[0]) != RFD_MAGIC) {\n\t\tblock->state = BLOCK_UNUSED;\n\t\treturn -ENOENT;\n\t}\n\n\tblock->state = BLOCK_OK;\n\n\tfor (i=0; i<part->data_sectors_per_block; i++) {\n\t\tu16 entry;\n\n\t\tentry = le16_to_cpu(part->header_cache[HEADER_MAP_OFFSET + i]);\n\n\t\tif (entry == SECTOR_DELETED)\n\t\t\tcontinue;\n\n\t\tif (entry == SECTOR_FREE) {\n\t\t\tblock->free_sectors++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (entry == SECTOR_ZERO)\n\t\t\tentry = 0;\n\n\t\tif (entry >= part->sector_count) {\n\t\t\tprintk(KERN_WARNING PREFIX\n\t\t\t\t\"'%s': unit #%d: entry %d corrupt, \"\n\t\t\t\t\"sector %d out of range\\n\",\n\t\t\t\tpart->mbd.mtd->name, block_no, i, entry);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (part->sector_map[entry] != -1) {\n\t\t\tprintk(KERN_WARNING PREFIX\n\t\t\t\t\"'%s': more than one entry for sector %d\\n\",\n\t\t\t\tpart->mbd.mtd->name, entry);\n\t\t\tpart->errors = 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tpart->sector_map[entry] = block->offset +\n\t\t\t(i + part->header_sectors_per_block) * SECTOR_SIZE;\n\n\t\tblock->used_sectors++;\n\t}\n\n\tif (block->free_sectors == part->data_sectors_per_block)\n\t\tpart->reserved_block = block_no;\n\n\treturn 0;\n}\n\nstatic int scan_header(struct partition *part)\n{\n\tint sectors_per_block;\n\tint i, rc = -ENOMEM;\n\tint blocks_found;\n\tsize_t retlen;\n\n\tsectors_per_block = part->block_size / SECTOR_SIZE;\n\tpart->total_blocks = (u32)part->mbd.mtd->size / part->block_size;\n\n\tif (part->total_blocks < 2)\n\t\treturn -ENOENT;\n\n\t \n\tpart->header_sectors_per_block =\n\t\t\t((HEADER_MAP_OFFSET + sectors_per_block) *\n\t\t\tsizeof(u16) + SECTOR_SIZE - 1) / SECTOR_SIZE;\n\n\tpart->data_sectors_per_block = sectors_per_block -\n\t\t\tpart->header_sectors_per_block;\n\n\tpart->header_size = (HEADER_MAP_OFFSET +\n\t\t\tpart->data_sectors_per_block) * sizeof(u16);\n\n\tpart->cylinders = (part->data_sectors_per_block *\n\t\t\t(part->total_blocks - 1) - 1) / SECTORS_PER_TRACK;\n\n\tpart->sector_count = part->cylinders * SECTORS_PER_TRACK;\n\n\tpart->current_block = -1;\n\tpart->reserved_block = -1;\n\tpart->is_reclaiming = 0;\n\n\tpart->header_cache = kmalloc(part->header_size, GFP_KERNEL);\n\tif (!part->header_cache)\n\t\tgoto err;\n\n\tpart->blocks = kcalloc(part->total_blocks, sizeof(struct block),\n\t\t\tGFP_KERNEL);\n\tif (!part->blocks)\n\t\tgoto err;\n\n\tpart->sector_map = vmalloc(array_size(sizeof(u_long),\n\t\t\t\t\t      part->sector_count));\n\tif (!part->sector_map)\n\t\tgoto err;\n\n\tfor (i=0; i<part->sector_count; i++)\n\t\tpart->sector_map[i] = -1;\n\n\tfor (i=0, blocks_found=0; i<part->total_blocks; i++) {\n\t\trc = mtd_read(part->mbd.mtd, i * part->block_size,\n\t\t\t      part->header_size, &retlen,\n\t\t\t      (u_char *)part->header_cache);\n\n\t\tif (!rc && retlen != part->header_size)\n\t\t\trc = -EIO;\n\n\t\tif (rc)\n\t\t\tgoto err;\n\n\t\tif (!build_block_map(part, i))\n\t\t\tblocks_found++;\n\t}\n\n\tif (blocks_found == 0) {\n\t\tprintk(KERN_NOTICE PREFIX \"no RFD magic found in '%s'\\n\",\n\t\t\t\tpart->mbd.mtd->name);\n\t\trc = -ENOENT;\n\t\tgoto err;\n\t}\n\n\tif (part->reserved_block == -1) {\n\t\tprintk(KERN_WARNING PREFIX \"'%s': no empty erase unit found\\n\",\n\t\t\t\tpart->mbd.mtd->name);\n\n\t\tpart->errors = 1;\n\t}\n\n\treturn 0;\n\nerr:\n\tvfree(part->sector_map);\n\tkfree(part->header_cache);\n\tkfree(part->blocks);\n\n\treturn rc;\n}\n\nstatic int rfd_ftl_readsect(struct mtd_blktrans_dev *dev, u_long sector, char *buf)\n{\n\tstruct partition *part = container_of(dev, struct partition, mbd);\n\tu_long addr;\n\tsize_t retlen;\n\tint rc;\n\n\tif (sector >= part->sector_count)\n\t\treturn -EIO;\n\n\taddr = part->sector_map[sector];\n\tif (addr != -1) {\n\t\trc = mtd_read(part->mbd.mtd, addr, SECTOR_SIZE, &retlen,\n\t\t\t      (u_char *)buf);\n\t\tif (!rc && retlen != SECTOR_SIZE)\n\t\t\trc = -EIO;\n\n\t\tif (rc) {\n\t\t\tprintk(KERN_WARNING PREFIX \"error reading '%s' at \"\n\t\t\t\t\"0x%lx\\n\", part->mbd.mtd->name, addr);\n\t\t\treturn rc;\n\t\t}\n\t} else\n\t\tmemset(buf, 0, SECTOR_SIZE);\n\n\treturn 0;\n}\n\nstatic int erase_block(struct partition *part, int block)\n{\n\tstruct erase_info *erase;\n\tint rc;\n\n\terase = kmalloc(sizeof(struct erase_info), GFP_KERNEL);\n\tif (!erase)\n\t\treturn -ENOMEM;\n\n\terase->addr = part->blocks[block].offset;\n\terase->len = part->block_size;\n\n\tpart->blocks[block].state = BLOCK_ERASING;\n\tpart->blocks[block].free_sectors = 0;\n\n\trc = mtd_erase(part->mbd.mtd, erase);\n\tif (rc) {\n\t\tprintk(KERN_ERR PREFIX \"erase of region %llx,%llx on '%s' \"\n\t\t\t\t\"failed\\n\", (unsigned long long)erase->addr,\n\t\t\t\t(unsigned long long)erase->len, part->mbd.mtd->name);\n\t\tpart->blocks[block].state = BLOCK_FAILED;\n\t\tpart->blocks[block].free_sectors = 0;\n\t\tpart->blocks[block].used_sectors = 0;\n\t} else {\n\t\tu16 magic = cpu_to_le16(RFD_MAGIC);\n\t\tsize_t retlen;\n\n\t\tpart->blocks[block].state = BLOCK_ERASED;\n\t\tpart->blocks[block].free_sectors = part->data_sectors_per_block;\n\t\tpart->blocks[block].used_sectors = 0;\n\t\tpart->blocks[block].erases++;\n\n\t\trc = mtd_write(part->mbd.mtd, part->blocks[block].offset,\n\t\t\t       sizeof(magic), &retlen, (u_char *)&magic);\n\t\tif (!rc && retlen != sizeof(magic))\n\t\t\trc = -EIO;\n\n\t\tif (rc) {\n\t\t\tpr_err(PREFIX \"'%s': unable to write RFD header at 0x%lx\\n\",\n\t\t\t       part->mbd.mtd->name, part->blocks[block].offset);\n\t\t\tpart->blocks[block].state = BLOCK_FAILED;\n\t\t} else {\n\t\t\tpart->blocks[block].state = BLOCK_OK;\n\t\t}\n\t}\n\n\tkfree(erase);\n\n\treturn rc;\n}\n\nstatic int move_block_contents(struct partition *part, int block_no, u_long *old_sector)\n{\n\tvoid *sector_data;\n\tu16 *map;\n\tsize_t retlen;\n\tint i, rc = -ENOMEM;\n\n\tpart->is_reclaiming = 1;\n\n\tsector_data = kmalloc(SECTOR_SIZE, GFP_KERNEL);\n\tif (!sector_data)\n\t\tgoto err3;\n\n\tmap = kmalloc(part->header_size, GFP_KERNEL);\n\tif (!map)\n\t\tgoto err2;\n\n\trc = mtd_read(part->mbd.mtd, part->blocks[block_no].offset,\n\t\t      part->header_size, &retlen, (u_char *)map);\n\n\tif (!rc && retlen != part->header_size)\n\t\trc = -EIO;\n\n\tif (rc) {\n\t\tprintk(KERN_ERR PREFIX \"error reading '%s' at \"\n\t\t\t\"0x%lx\\n\", part->mbd.mtd->name,\n\t\t\tpart->blocks[block_no].offset);\n\n\t\tgoto err;\n\t}\n\n\tfor (i=0; i<part->data_sectors_per_block; i++) {\n\t\tu16 entry = le16_to_cpu(map[HEADER_MAP_OFFSET + i]);\n\t\tu_long addr;\n\n\n\t\tif (entry == SECTOR_FREE || entry == SECTOR_DELETED)\n\t\t\tcontinue;\n\n\t\tif (entry == SECTOR_ZERO)\n\t\t\tentry = 0;\n\n\t\t \n\t\tif (entry >= part->sector_count)\n\t\t\tcontinue;\n\n\t\taddr = part->blocks[block_no].offset +\n\t\t\t(i + part->header_sectors_per_block) * SECTOR_SIZE;\n\n\t\tif (*old_sector == addr) {\n\t\t\t*old_sector = -1;\n\t\t\tif (!part->blocks[block_no].used_sectors--) {\n\t\t\t\trc = erase_block(part, block_no);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\trc = mtd_read(part->mbd.mtd, addr, SECTOR_SIZE, &retlen,\n\t\t\t      sector_data);\n\n\t\tif (!rc && retlen != SECTOR_SIZE)\n\t\t\trc = -EIO;\n\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR PREFIX \"'%s': Unable to \"\n\t\t\t\t\"read sector for relocation\\n\",\n\t\t\t\tpart->mbd.mtd->name);\n\n\t\t\tgoto err;\n\t\t}\n\n\t\trc = rfd_ftl_writesect((struct mtd_blktrans_dev*)part,\n\t\t\t\tentry, sector_data);\n\n\t\tif (rc)\n\t\t\tgoto err;\n\t}\n\nerr:\n\tkfree(map);\nerr2:\n\tkfree(sector_data);\nerr3:\n\tpart->is_reclaiming = 0;\n\n\treturn rc;\n}\n\nstatic int reclaim_block(struct partition *part, u_long *old_sector)\n{\n\tint block, best_block, score, old_sector_block;\n\tint rc;\n\n\t \n\tmtd_sync(part->mbd.mtd);\n\n\tscore = 0x7fffffff;  \n\tbest_block = -1;\n\tif (*old_sector != -1)\n\t\told_sector_block = *old_sector / part->block_size;\n\telse\n\t\told_sector_block = -1;\n\n\tfor (block=0; block<part->total_blocks; block++) {\n\t\tint this_score;\n\n\t\tif (block == part->reserved_block)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (part->blocks[block].free_sectors)\n\t\t\treturn 0;\n\n\t\tthis_score = part->blocks[block].used_sectors;\n\n\t\tif (block == old_sector_block)\n\t\t\tthis_score--;\n\t\telse {\n\t\t\t \n\t\t\tif (part->blocks[block].used_sectors ==\n\t\t\t\t\tpart->data_sectors_per_block)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tthis_score += part->blocks[block].erases;\n\n\t\tif (this_score < score) {\n\t\t\tbest_block = block;\n\t\t\tscore = this_score;\n\t\t}\n\t}\n\n\tif (best_block == -1)\n\t\treturn -ENOSPC;\n\n\tpart->current_block = -1;\n\tpart->reserved_block = best_block;\n\n\tpr_debug(\"reclaim_block: reclaiming block #%d with %d used \"\n\t\t \"%d free sectors\\n\", best_block,\n\t\t part->blocks[best_block].used_sectors,\n\t\t part->blocks[best_block].free_sectors);\n\n\tif (part->blocks[best_block].used_sectors)\n\t\trc = move_block_contents(part, best_block, old_sector);\n\telse\n\t\trc = erase_block(part, best_block);\n\n\treturn rc;\n}\n\n \nstatic int find_free_block(struct partition *part)\n{\n\tint block, stop;\n\n\tblock = part->current_block == -1 ?\n\t\t\tjiffies % part->total_blocks : part->current_block;\n\tstop = block;\n\n\tdo {\n\t\tif (part->blocks[block].free_sectors &&\n\t\t\t\tblock != part->reserved_block)\n\t\t\treturn block;\n\n\t\tif (part->blocks[block].state == BLOCK_UNUSED)\n\t\t\terase_block(part, block);\n\n\t\tif (++block >= part->total_blocks)\n\t\t\tblock = 0;\n\n\t} while (block != stop);\n\n\treturn -1;\n}\n\nstatic int find_writable_block(struct partition *part, u_long *old_sector)\n{\n\tint rc, block;\n\tsize_t retlen;\n\n\tblock = find_free_block(part);\n\n\tif (block == -1) {\n\t\tif (!part->is_reclaiming) {\n\t\t\trc = reclaim_block(part, old_sector);\n\t\t\tif (rc)\n\t\t\t\tgoto err;\n\n\t\t\tblock = find_free_block(part);\n\t\t}\n\n\t\tif (block == -1) {\n\t\t\trc = -ENOSPC;\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\trc = mtd_read(part->mbd.mtd, part->blocks[block].offset,\n\t\t      part->header_size, &retlen,\n\t\t      (u_char *)part->header_cache);\n\n\tif (!rc && retlen != part->header_size)\n\t\trc = -EIO;\n\n\tif (rc) {\n\t\tprintk(KERN_ERR PREFIX \"'%s': unable to read header at \"\n\t\t\t\t\"0x%lx\\n\", part->mbd.mtd->name,\n\t\t\t\tpart->blocks[block].offset);\n\t\tgoto err;\n\t}\n\n\tpart->current_block = block;\n\nerr:\n\treturn rc;\n}\n\nstatic int mark_sector_deleted(struct partition *part, u_long old_addr)\n{\n\tint block, offset, rc;\n\tu_long addr;\n\tsize_t retlen;\n\tu16 del = cpu_to_le16(SECTOR_DELETED);\n\n\tblock = old_addr / part->block_size;\n\toffset = (old_addr % part->block_size) / SECTOR_SIZE -\n\t\tpart->header_sectors_per_block;\n\n\taddr = part->blocks[block].offset +\n\t\t\t(HEADER_MAP_OFFSET + offset) * sizeof(u16);\n\trc = mtd_write(part->mbd.mtd, addr, sizeof(del), &retlen,\n\t\t       (u_char *)&del);\n\n\tif (!rc && retlen != sizeof(del))\n\t\trc = -EIO;\n\n\tif (rc) {\n\t\tprintk(KERN_ERR PREFIX \"error writing '%s' at \"\n\t\t\t\"0x%lx\\n\", part->mbd.mtd->name, addr);\n\t\tgoto err;\n\t}\n\tif (block == part->current_block)\n\t\tpart->header_cache[offset + HEADER_MAP_OFFSET] = del;\n\n\tpart->blocks[block].used_sectors--;\n\n\tif (!part->blocks[block].used_sectors &&\n\t    !part->blocks[block].free_sectors)\n\t\trc = erase_block(part, block);\n\nerr:\n\treturn rc;\n}\n\nstatic int find_free_sector(const struct partition *part, const struct block *block)\n{\n\tint i, stop;\n\n\ti = stop = part->data_sectors_per_block - block->free_sectors;\n\n\tdo {\n\t\tif (le16_to_cpu(part->header_cache[HEADER_MAP_OFFSET + i])\n\t\t\t\t== SECTOR_FREE)\n\t\t\treturn i;\n\n\t\tif (++i == part->data_sectors_per_block)\n\t\t\ti = 0;\n\t}\n\twhile(i != stop);\n\n\treturn -1;\n}\n\nstatic int do_writesect(struct mtd_blktrans_dev *dev, u_long sector, char *buf, ulong *old_addr)\n{\n\tstruct partition *part = container_of(dev, struct partition, mbd);\n\tstruct block *block;\n\tu_long addr;\n\tint i;\n\tint rc;\n\tsize_t retlen;\n\tu16 entry;\n\n\tif (part->current_block == -1 ||\n\t\t!part->blocks[part->current_block].free_sectors) {\n\n\t\trc = find_writable_block(part, old_addr);\n\t\tif (rc)\n\t\t\tgoto err;\n\t}\n\n\tblock = &part->blocks[part->current_block];\n\n\ti = find_free_sector(part, block);\n\n\tif (i < 0) {\n\t\trc = -ENOSPC;\n\t\tgoto err;\n\t}\n\n\taddr = (i + part->header_sectors_per_block) * SECTOR_SIZE +\n\t\tblock->offset;\n\trc = mtd_write(part->mbd.mtd, addr, SECTOR_SIZE, &retlen,\n\t\t       (u_char *)buf);\n\n\tif (!rc && retlen != SECTOR_SIZE)\n\t\trc = -EIO;\n\n\tif (rc) {\n\t\tprintk(KERN_ERR PREFIX \"error writing '%s' at 0x%lx\\n\",\n\t\t\t\tpart->mbd.mtd->name, addr);\n\t\tgoto err;\n\t}\n\n\tpart->sector_map[sector] = addr;\n\n\tentry = cpu_to_le16(sector == 0 ? SECTOR_ZERO : sector);\n\n\tpart->header_cache[i + HEADER_MAP_OFFSET] = entry;\n\n\taddr = block->offset + (HEADER_MAP_OFFSET + i) * sizeof(u16);\n\trc = mtd_write(part->mbd.mtd, addr, sizeof(entry), &retlen,\n\t\t       (u_char *)&entry);\n\n\tif (!rc && retlen != sizeof(entry))\n\t\trc = -EIO;\n\n\tif (rc) {\n\t\tprintk(KERN_ERR PREFIX \"error writing '%s' at 0x%lx\\n\",\n\t\t\t\tpart->mbd.mtd->name, addr);\n\t\tgoto err;\n\t}\n\tblock->used_sectors++;\n\tblock->free_sectors--;\n\nerr:\n\treturn rc;\n}\n\nstatic int rfd_ftl_writesect(struct mtd_blktrans_dev *dev, u_long sector, char *buf)\n{\n\tstruct partition *part = container_of(dev, struct partition, mbd);\n\tu_long old_addr;\n\tint i;\n\tint rc = 0;\n\n\tpr_debug(\"rfd_ftl_writesect(sector=0x%lx)\\n\", sector);\n\n\tif (part->reserved_block == -1) {\n\t\trc = -EACCES;\n\t\tgoto err;\n\t}\n\n\tif (sector >= part->sector_count) {\n\t\trc = -EIO;\n\t\tgoto err;\n\t}\n\n\told_addr = part->sector_map[sector];\n\n\tfor (i=0; i<SECTOR_SIZE; i++) {\n\t\tif (!buf[i])\n\t\t\tcontinue;\n\n\t\trc = do_writesect(dev, sector, buf, &old_addr);\n\t\tif (rc)\n\t\t\tgoto err;\n\t\tbreak;\n\t}\n\n\tif (i == SECTOR_SIZE)\n\t\tpart->sector_map[sector] = -1;\n\n\tif (old_addr != -1)\n\t\trc = mark_sector_deleted(part, old_addr);\n\nerr:\n\treturn rc;\n}\n\nstatic int rfd_ftl_discardsect(struct mtd_blktrans_dev *dev,\n\t\t\t       unsigned long sector, unsigned int nr_sects)\n{\n\tstruct partition *part = container_of(dev, struct partition, mbd);\n\tu_long addr;\n\tint rc;\n\n\twhile (nr_sects) {\n\t\tif (sector >= part->sector_count)\n\t\t\treturn -EIO;\n\n\t\taddr = part->sector_map[sector];\n\n\t\tif (addr != -1) {\n\t\t\trc = mark_sector_deleted(part, addr);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\n\t\t\tpart->sector_map[sector] = -1;\n\t\t}\n\n\t\tsector++;\n\t\tnr_sects--;\n\t}\n\n\treturn 0;\n}\n\nstatic int rfd_ftl_getgeo(struct mtd_blktrans_dev *dev, struct hd_geometry *geo)\n{\n\tstruct partition *part = container_of(dev, struct partition, mbd);\n\n\tgeo->heads = 1;\n\tgeo->sectors = SECTORS_PER_TRACK;\n\tgeo->cylinders = part->cylinders;\n\n\treturn 0;\n}\n\nstatic void rfd_ftl_add_mtd(struct mtd_blktrans_ops *tr, struct mtd_info *mtd)\n{\n\tstruct partition *part;\n\n\tif ((mtd->type != MTD_NORFLASH && mtd->type != MTD_RAM) ||\n\t    mtd->size > UINT_MAX)\n\t\treturn;\n\n\tpart = kzalloc(sizeof(struct partition), GFP_KERNEL);\n\tif (!part)\n\t\treturn;\n\n\tpart->mbd.mtd = mtd;\n\n\tif (block_size)\n\t\tpart->block_size = block_size;\n\telse {\n\t\tif (!mtd->erasesize) {\n\t\t\tprintk(KERN_WARNING PREFIX \"please provide block_size\");\n\t\t\tgoto out;\n\t\t} else\n\t\t\tpart->block_size = mtd->erasesize;\n\t}\n\n\tif (scan_header(part) == 0) {\n\t\tpart->mbd.size = part->sector_count;\n\t\tpart->mbd.tr = tr;\n\t\tpart->mbd.devnum = -1;\n\t\tif (!(mtd->flags & MTD_WRITEABLE))\n\t\t\tpart->mbd.readonly = 1;\n\t\telse if (part->errors) {\n\t\t\tprintk(KERN_WARNING PREFIX \"'%s': errors found, \"\n\t\t\t\t\t\"setting read-only\\n\", mtd->name);\n\t\t\tpart->mbd.readonly = 1;\n\t\t}\n\n\t\tprintk(KERN_INFO PREFIX \"name: '%s' type: %d flags %x\\n\",\n\t\t\t\tmtd->name, mtd->type, mtd->flags);\n\n\t\tif (!add_mtd_blktrans_dev(&part->mbd))\n\t\t\treturn;\n\t}\nout:\n\tkfree(part);\n}\n\nstatic void rfd_ftl_remove_dev(struct mtd_blktrans_dev *dev)\n{\n\tstruct partition *part = container_of(dev, struct partition, mbd);\n\tint i;\n\n\tfor (i=0; i<part->total_blocks; i++) {\n\t\tpr_debug(\"rfd_ftl_remove_dev:'%s': erase unit #%02d: %d erases\\n\",\n\t\t\tpart->mbd.mtd->name, i, part->blocks[i].erases);\n\t}\n\n\tvfree(part->sector_map);\n\tkfree(part->header_cache);\n\tkfree(part->blocks);\n\tdel_mtd_blktrans_dev(&part->mbd);\n}\n\nstatic struct mtd_blktrans_ops rfd_ftl_tr = {\n\t.name\t\t= \"rfd\",\n\t.major\t\t= RFD_FTL_MAJOR,\n\t.part_bits\t= PART_BITS,\n\t.blksize \t= SECTOR_SIZE,\n\n\t.readsect\t= rfd_ftl_readsect,\n\t.writesect\t= rfd_ftl_writesect,\n\t.discard\t= rfd_ftl_discardsect,\n\t.getgeo\t\t= rfd_ftl_getgeo,\n\t.add_mtd\t= rfd_ftl_add_mtd,\n\t.remove_dev\t= rfd_ftl_remove_dev,\n\t.owner\t\t= THIS_MODULE,\n};\n\nmodule_mtd_blktrans(rfd_ftl_tr);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Sean Young <sean@mess.org>\");\nMODULE_DESCRIPTION(\"Support code for RFD Flash Translation Layer, \"\n\t\t\"used by General Software's Embedded BIOS\");\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}