{
  "module_name": "mtdpart.c",
  "hash_id": "51df5e29f4b540b5a63b94c8df5fdff8f188be262566343c623aafbd7f308ac2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/mtdpart.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/mtd/mtd.h>\n#include <linux/mtd/partitions.h>\n#include <linux/err.h>\n#include <linux/of.h>\n#include <linux/of_platform.h>\n\n#include \"mtdcore.h\"\n\n \n\nstatic inline void free_partition(struct mtd_info *mtd)\n{\n\tkfree(mtd->name);\n\tkfree(mtd);\n}\n\nvoid release_mtd_partition(struct mtd_info *mtd)\n{\n\tWARN_ON(!list_empty(&mtd->part.node));\n\tfree_partition(mtd);\n}\n\nstatic struct mtd_info *allocate_partition(struct mtd_info *parent,\n\t\t\t\t\t   const struct mtd_partition *part,\n\t\t\t\t\t   int partno, uint64_t cur_offset)\n{\n\tstruct mtd_info *master = mtd_get_master(parent);\n\tint wr_alignment = (parent->flags & MTD_NO_ERASE) ?\n\t\t\t   master->writesize : master->erasesize;\n\tu64 parent_size = mtd_is_partition(parent) ?\n\t\t\t  parent->part.size : parent->size;\n\tstruct mtd_info *child;\n\tu32 remainder;\n\tchar *name;\n\tu64 tmp;\n\n\t \n\tchild = kzalloc(sizeof(*child), GFP_KERNEL);\n\tname = kstrdup(part->name, GFP_KERNEL);\n\tif (!name || !child) {\n\t\tprintk(KERN_ERR\"memory allocation error while creating partitions for \\\"%s\\\"\\n\",\n\t\t       parent->name);\n\t\tkfree(name);\n\t\tkfree(child);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\t \n\tchild->type = parent->type;\n\tchild->part.flags = parent->flags & ~part->mask_flags;\n\tchild->part.flags |= part->add_flags;\n\tchild->flags = child->part.flags;\n\tchild->part.size = part->size;\n\tchild->writesize = parent->writesize;\n\tchild->writebufsize = parent->writebufsize;\n\tchild->oobsize = parent->oobsize;\n\tchild->oobavail = parent->oobavail;\n\tchild->subpage_sft = parent->subpage_sft;\n\n\tchild->name = name;\n\tchild->owner = parent->owner;\n\n\t \n\tchild->dev.parent = IS_ENABLED(CONFIG_MTD_PARTITIONED_MASTER) || mtd_is_partition(parent) ?\n\t\t\t    &parent->dev : parent->dev.parent;\n\tchild->dev.of_node = part->of_node;\n\tchild->parent = parent;\n\tchild->part.offset = part->offset;\n\tINIT_LIST_HEAD(&child->partitions);\n\n\tif (child->part.offset == MTDPART_OFS_APPEND)\n\t\tchild->part.offset = cur_offset;\n\tif (child->part.offset == MTDPART_OFS_NXTBLK) {\n\t\ttmp = cur_offset;\n\t\tchild->part.offset = cur_offset;\n\t\tremainder = do_div(tmp, wr_alignment);\n\t\tif (remainder) {\n\t\t\tchild->part.offset += wr_alignment - remainder;\n\t\t\tprintk(KERN_NOTICE \"Moving partition %d: \"\n\t\t\t       \"0x%012llx -> 0x%012llx\\n\", partno,\n\t\t\t       (unsigned long long)cur_offset,\n\t\t\t       child->part.offset);\n\t\t}\n\t}\n\tif (child->part.offset == MTDPART_OFS_RETAIN) {\n\t\tchild->part.offset = cur_offset;\n\t\tif (parent_size - child->part.offset >= child->part.size) {\n\t\t\tchild->part.size = parent_size - child->part.offset -\n\t\t\t\t\t   child->part.size;\n\t\t} else {\n\t\t\tprintk(KERN_ERR \"mtd partition \\\"%s\\\" doesn't have enough space: %#llx < %#llx, disabled\\n\",\n\t\t\t\tpart->name, parent_size - child->part.offset,\n\t\t\t\tchild->part.size);\n\t\t\t \n\t\t\tgoto out_register;\n\t\t}\n\t}\n\tif (child->part.size == MTDPART_SIZ_FULL)\n\t\tchild->part.size = parent_size - child->part.offset;\n\n\tprintk(KERN_NOTICE \"0x%012llx-0x%012llx : \\\"%s\\\"\\n\",\n\t       child->part.offset, child->part.offset + child->part.size,\n\t       child->name);\n\n\t \n\tif (child->part.offset >= parent_size) {\n\t\t \n\t\tchild->part.offset = 0;\n\t\tchild->part.size = 0;\n\n\t\t \n\t\tchild->erasesize = parent->erasesize;\n\t\tprintk(KERN_ERR\"mtd: partition \\\"%s\\\" is out of reach -- disabled\\n\",\n\t\t\tpart->name);\n\t\tgoto out_register;\n\t}\n\tif (child->part.offset + child->part.size > parent->size) {\n\t\tchild->part.size = parent_size - child->part.offset;\n\t\tprintk(KERN_WARNING\"mtd: partition \\\"%s\\\" extends beyond the end of device \\\"%s\\\" -- size truncated to %#llx\\n\",\n\t\t\tpart->name, parent->name, child->part.size);\n\t}\n\n\tif (parent->numeraseregions > 1) {\n\t\t \n\t\tint i, max = parent->numeraseregions;\n\t\tu64 end = child->part.offset + child->part.size;\n\t\tstruct mtd_erase_region_info *regions = parent->eraseregions;\n\n\t\t \n\t\tfor (i = 0; i < max && regions[i].offset <= child->part.offset;\n\t\t     i++)\n\t\t\t;\n\t\t \n\t\tif (i > 0)\n\t\t\ti--;\n\n\t\t \n\t\tfor (; i < max && regions[i].offset < end; i++) {\n\t\t\tif (child->erasesize < regions[i].erasesize)\n\t\t\t\tchild->erasesize = regions[i].erasesize;\n\t\t}\n\t\tBUG_ON(child->erasesize == 0);\n\t} else {\n\t\t \n\t\tchild->erasesize = master->erasesize;\n\t}\n\n\t \n\tif (!(child->flags & MTD_NO_ERASE))\n\t\twr_alignment = child->erasesize;\n\n\ttmp = mtd_get_master_ofs(child, 0);\n\tremainder = do_div(tmp, wr_alignment);\n\tif ((child->flags & MTD_WRITEABLE) && remainder) {\n\t\t \n\t\t \n\t\tchild->flags &= ~MTD_WRITEABLE;\n\t\tprintk(KERN_WARNING\"mtd: partition \\\"%s\\\" doesn't start on an erase/write block boundary -- force read-only\\n\",\n\t\t\tpart->name);\n\t}\n\n\ttmp = mtd_get_master_ofs(child, 0) + child->part.size;\n\tremainder = do_div(tmp, wr_alignment);\n\tif ((child->flags & MTD_WRITEABLE) && remainder) {\n\t\tchild->flags &= ~MTD_WRITEABLE;\n\t\tprintk(KERN_WARNING\"mtd: partition \\\"%s\\\" doesn't end on an erase/write block -- force read-only\\n\",\n\t\t\tpart->name);\n\t}\n\n\tchild->size = child->part.size;\n\tchild->ecc_step_size = parent->ecc_step_size;\n\tchild->ecc_strength = parent->ecc_strength;\n\tchild->bitflip_threshold = parent->bitflip_threshold;\n\n\tif (master->_block_isbad) {\n\t\tuint64_t offs = 0;\n\n\t\twhile (offs < child->part.size) {\n\t\t\tif (mtd_block_isreserved(child, offs))\n\t\t\t\tchild->ecc_stats.bbtblocks++;\n\t\t\telse if (mtd_block_isbad(child, offs))\n\t\t\t\tchild->ecc_stats.badblocks++;\n\t\t\toffs += child->erasesize;\n\t\t}\n\t}\n\nout_register:\n\treturn child;\n}\n\nstatic ssize_t offset_show(struct device *dev,\n\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tstruct mtd_info *mtd = dev_get_drvdata(dev);\n\n\treturn sysfs_emit(buf, \"%lld\\n\", mtd->part.offset);\n}\nstatic DEVICE_ATTR_RO(offset);\t \n\nstatic const struct attribute *mtd_partition_attrs[] = {\n\t&dev_attr_offset.attr,\n\tNULL\n};\n\nstatic int mtd_add_partition_attrs(struct mtd_info *new)\n{\n\tint ret = sysfs_create_files(&new->dev.kobj, mtd_partition_attrs);\n\tif (ret)\n\t\tprintk(KERN_WARNING\n\t\t       \"mtd: failed to create partition attrs, err=%d\\n\", ret);\n\treturn ret;\n}\n\nint mtd_add_partition(struct mtd_info *parent, const char *name,\n\t\t      long long offset, long long length)\n{\n\tstruct mtd_info *master = mtd_get_master(parent);\n\tu64 parent_size = mtd_is_partition(parent) ?\n\t\t\t  parent->part.size : parent->size;\n\tstruct mtd_partition part;\n\tstruct mtd_info *child;\n\tint ret = 0;\n\n\t \n\tif (offset == MTDPART_OFS_APPEND ||\n\t    offset == MTDPART_OFS_NXTBLK)\n\t\treturn -EINVAL;\n\n\tif (length == MTDPART_SIZ_FULL)\n\t\tlength = parent_size - offset;\n\n\tif (length <= 0)\n\t\treturn -EINVAL;\n\n\tmemset(&part, 0, sizeof(part));\n\tpart.name = name;\n\tpart.size = length;\n\tpart.offset = offset;\n\n\tchild = allocate_partition(parent, &part, -1, offset);\n\tif (IS_ERR(child))\n\t\treturn PTR_ERR(child);\n\n\tmutex_lock(&master->master.partitions_lock);\n\tlist_add_tail(&child->part.node, &parent->partitions);\n\tmutex_unlock(&master->master.partitions_lock);\n\n\tret = add_mtd_device(child);\n\tif (ret)\n\t\tgoto err_remove_part;\n\n\tmtd_add_partition_attrs(child);\n\n\treturn 0;\n\nerr_remove_part:\n\tmutex_lock(&master->master.partitions_lock);\n\tlist_del(&child->part.node);\n\tmutex_unlock(&master->master.partitions_lock);\n\n\tfree_partition(child);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(mtd_add_partition);\n\n \nstatic int __mtd_del_partition(struct mtd_info *mtd)\n{\n\tstruct mtd_info *child, *next;\n\tint err;\n\n\tlist_for_each_entry_safe(child, next, &mtd->partitions, part.node) {\n\t\terr = __mtd_del_partition(child);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tsysfs_remove_files(&mtd->dev.kobj, mtd_partition_attrs);\n\n\tlist_del_init(&mtd->part.node);\n\terr = del_mtd_device(mtd);\n\tif (err)\n\t\treturn err;\n\n\treturn 0;\n}\n\n \nstatic int __del_mtd_partitions(struct mtd_info *mtd)\n{\n\tstruct mtd_info *child, *next;\n\tint ret, err = 0;\n\n\tlist_for_each_entry_safe(child, next, &mtd->partitions, part.node) {\n\t\tif (mtd_has_partitions(child))\n\t\t\t__del_mtd_partitions(child);\n\n\t\tpr_info(\"Deleting %s MTD partition\\n\", child->name);\n\t\tlist_del_init(&child->part.node);\n\t\tret = del_mtd_device(child);\n\t\tif (ret < 0) {\n\t\t\tpr_err(\"Error when deleting partition \\\"%s\\\" (%d)\\n\",\n\t\t\t       child->name, ret);\n\t\t\terr = ret;\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\treturn err;\n}\n\nint del_mtd_partitions(struct mtd_info *mtd)\n{\n\tstruct mtd_info *master = mtd_get_master(mtd);\n\tint ret;\n\n\tpr_info(\"Deleting MTD partitions on \\\"%s\\\":\\n\", mtd->name);\n\n\tmutex_lock(&master->master.partitions_lock);\n\tret = __del_mtd_partitions(mtd);\n\tmutex_unlock(&master->master.partitions_lock);\n\n\treturn ret;\n}\n\nint mtd_del_partition(struct mtd_info *mtd, int partno)\n{\n\tstruct mtd_info *child, *master = mtd_get_master(mtd);\n\tint ret = -EINVAL;\n\n\tmutex_lock(&master->master.partitions_lock);\n\tlist_for_each_entry(child, &mtd->partitions, part.node) {\n\t\tif (child->index == partno) {\n\t\t\tret = __mtd_del_partition(child);\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&master->master.partitions_lock);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(mtd_del_partition);\n\n \n\nint add_mtd_partitions(struct mtd_info *parent,\n\t\t       const struct mtd_partition *parts,\n\t\t       int nbparts)\n{\n\tstruct mtd_info *child, *master = mtd_get_master(parent);\n\tuint64_t cur_offset = 0;\n\tint i, ret;\n\n\tprintk(KERN_NOTICE \"Creating %d MTD partitions on \\\"%s\\\":\\n\",\n\t       nbparts, parent->name);\n\n\tfor (i = 0; i < nbparts; i++) {\n\t\tchild = allocate_partition(parent, parts + i, i, cur_offset);\n\t\tif (IS_ERR(child)) {\n\t\t\tret = PTR_ERR(child);\n\t\t\tgoto err_del_partitions;\n\t\t}\n\n\t\tmutex_lock(&master->master.partitions_lock);\n\t\tlist_add_tail(&child->part.node, &parent->partitions);\n\t\tmutex_unlock(&master->master.partitions_lock);\n\n\t\tret = add_mtd_device(child);\n\t\tif (ret) {\n\t\t\tmutex_lock(&master->master.partitions_lock);\n\t\t\tlist_del(&child->part.node);\n\t\t\tmutex_unlock(&master->master.partitions_lock);\n\n\t\t\tfree_partition(child);\n\t\t\tgoto err_del_partitions;\n\t\t}\n\n\t\tmtd_add_partition_attrs(child);\n\n\t\t \n\t\tparse_mtd_partitions(child, parts[i].types, NULL);\n\n\t\tcur_offset = child->part.offset + child->part.size;\n\t}\n\n\treturn 0;\n\nerr_del_partitions:\n\tdel_mtd_partitions(master);\n\n\treturn ret;\n}\n\nstatic DEFINE_SPINLOCK(part_parser_lock);\nstatic LIST_HEAD(part_parsers);\n\nstatic struct mtd_part_parser *mtd_part_parser_get(const char *name)\n{\n\tstruct mtd_part_parser *p, *ret = NULL;\n\n\tspin_lock(&part_parser_lock);\n\n\tlist_for_each_entry(p, &part_parsers, list)\n\t\tif (!strcmp(p->name, name) && try_module_get(p->owner)) {\n\t\t\tret = p;\n\t\t\tbreak;\n\t\t}\n\n\tspin_unlock(&part_parser_lock);\n\n\treturn ret;\n}\n\nstatic inline void mtd_part_parser_put(const struct mtd_part_parser *p)\n{\n\tmodule_put(p->owner);\n}\n\n \nstatic void mtd_part_parser_cleanup_default(const struct mtd_partition *pparts,\n\t\t\t\t\t    int nr_parts)\n{\n\tkfree(pparts);\n}\n\nint __register_mtd_parser(struct mtd_part_parser *p, struct module *owner)\n{\n\tp->owner = owner;\n\n\tif (!p->cleanup)\n\t\tp->cleanup = &mtd_part_parser_cleanup_default;\n\n\tspin_lock(&part_parser_lock);\n\tlist_add(&p->list, &part_parsers);\n\tspin_unlock(&part_parser_lock);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(__register_mtd_parser);\n\nvoid deregister_mtd_parser(struct mtd_part_parser *p)\n{\n\tspin_lock(&part_parser_lock);\n\tlist_del(&p->list);\n\tspin_unlock(&part_parser_lock);\n}\nEXPORT_SYMBOL_GPL(deregister_mtd_parser);\n\n \nstatic const char * const default_mtd_part_types[] = {\n\t\"cmdlinepart\",\n\t\"ofpart\",\n\tNULL\n};\n\n \nstatic const char * const default_subpartition_types[] = {\n\t\"ofpart\",\n\tNULL\n};\n\nstatic int mtd_part_do_parse(struct mtd_part_parser *parser,\n\t\t\t     struct mtd_info *master,\n\t\t\t     struct mtd_partitions *pparts,\n\t\t\t     struct mtd_part_parser_data *data)\n{\n\tint ret;\n\n\tret = (*parser->parse_fn)(master, &pparts->parts, data);\n\tpr_debug(\"%s: parser %s: %i\\n\", master->name, parser->name, ret);\n\tif (ret <= 0)\n\t\treturn ret;\n\n\tpr_notice(\"%d %s partitions found on MTD device %s\\n\", ret,\n\t\t  parser->name, master->name);\n\n\tpparts->nr_parts = ret;\n\tpparts->parser = parser;\n\n\treturn ret;\n}\n\n \nstatic struct mtd_part_parser *mtd_part_get_compatible_parser(const char *compat)\n{\n\tstruct mtd_part_parser *p, *ret = NULL;\n\n\tspin_lock(&part_parser_lock);\n\n\tlist_for_each_entry(p, &part_parsers, list) {\n\t\tconst struct of_device_id *matches;\n\n\t\tmatches = p->of_match_table;\n\t\tif (!matches)\n\t\t\tcontinue;\n\n\t\tfor (; matches->compatible[0]; matches++) {\n\t\t\tif (!strcmp(matches->compatible, compat) &&\n\t\t\t    try_module_get(p->owner)) {\n\t\t\t\tret = p;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\tspin_unlock(&part_parser_lock);\n\n\treturn ret;\n}\n\nstatic int mtd_part_of_parse(struct mtd_info *master,\n\t\t\t     struct mtd_partitions *pparts)\n{\n\tstruct mtd_part_parser *parser;\n\tstruct device_node *np;\n\tstruct device_node *child;\n\tstruct property *prop;\n\tstruct device *dev;\n\tconst char *compat;\n\tconst char *fixed = \"fixed-partitions\";\n\tint ret, err = 0;\n\n\tdev = &master->dev;\n\t \n\tif (!IS_ENABLED(CONFIG_MTD_PARTITIONED_MASTER) && !mtd_is_partition(master))\n\t\tdev = master->dev.parent;\n\n\tnp = mtd_get_of_node(master);\n\tif (mtd_is_partition(master))\n\t\tof_node_get(np);\n\telse\n\t\tnp = of_get_child_by_name(np, \"partitions\");\n\n\t \n\tfor_each_child_of_node(np, child)\n\t\tif (of_device_is_compatible(child, \"nvmem-cells\"))\n\t\t\tof_node_set_flag(child, OF_POPULATED);\n\n\tof_property_for_each_string(np, \"compatible\", prop, compat) {\n\t\tparser = mtd_part_get_compatible_parser(compat);\n\t\tif (!parser)\n\t\t\tcontinue;\n\t\tret = mtd_part_do_parse(parser, master, pparts, NULL);\n\t\tif (ret > 0) {\n\t\t\tof_platform_populate(np, NULL, NULL, dev);\n\t\t\tof_node_put(np);\n\t\t\treturn ret;\n\t\t}\n\t\tmtd_part_parser_put(parser);\n\t\tif (ret < 0 && !err)\n\t\t\terr = ret;\n\t}\n\tof_platform_populate(np, NULL, NULL, dev);\n\tof_node_put(np);\n\n\t \n\tparser = mtd_part_parser_get(fixed);\n\tif (!parser && !request_module(\"%s\", fixed))\n\t\tparser = mtd_part_parser_get(fixed);\n\tif (parser) {\n\t\tret = mtd_part_do_parse(parser, master, pparts, NULL);\n\t\tif (ret > 0)\n\t\t\treturn ret;\n\t\tmtd_part_parser_put(parser);\n\t\tif (ret < 0 && !err)\n\t\t\terr = ret;\n\t}\n\n\treturn err;\n}\n\n \nint parse_mtd_partitions(struct mtd_info *master, const char *const *types,\n\t\t\t struct mtd_part_parser_data *data)\n{\n\tstruct mtd_partitions pparts = { };\n\tstruct mtd_part_parser *parser;\n\tint ret, err = 0;\n\n\tif (!types)\n\t\ttypes = mtd_is_partition(master) ? default_subpartition_types :\n\t\t\tdefault_mtd_part_types;\n\n\tfor ( ; *types; types++) {\n\t\t \n\t\tif (!strcmp(*types, \"ofpart\")) {\n\t\t\tret = mtd_part_of_parse(master, &pparts);\n\t\t} else {\n\t\t\tpr_debug(\"%s: parsing partitions %s\\n\", master->name,\n\t\t\t\t *types);\n\t\t\tparser = mtd_part_parser_get(*types);\n\t\t\tif (!parser && !request_module(\"%s\", *types))\n\t\t\t\tparser = mtd_part_parser_get(*types);\n\t\t\tpr_debug(\"%s: got parser %s\\n\", master->name,\n\t\t\t\tparser ? parser->name : NULL);\n\t\t\tif (!parser)\n\t\t\t\tcontinue;\n\t\t\tret = mtd_part_do_parse(parser, master, &pparts, data);\n\t\t\tif (ret <= 0)\n\t\t\t\tmtd_part_parser_put(parser);\n\t\t}\n\t\t \n\t\tif (ret > 0) {\n\t\t\terr = add_mtd_partitions(master, pparts.parts,\n\t\t\t\t\t\t pparts.nr_parts);\n\t\t\tmtd_part_parser_cleanup(&pparts);\n\t\t\treturn err ? err : pparts.nr_parts;\n\t\t}\n\t\t \n\t\tif (ret < 0 && !err)\n\t\t\terr = ret;\n\t}\n\treturn err;\n}\n\nvoid mtd_part_parser_cleanup(struct mtd_partitions *parts)\n{\n\tconst struct mtd_part_parser *parser;\n\n\tif (!parts)\n\t\treturn;\n\n\tparser = parts->parser;\n\tif (parser) {\n\t\tif (parser->cleanup)\n\t\t\tparser->cleanup(parts->parts, parts->nr_parts);\n\n\t\tmtd_part_parser_put(parser);\n\t}\n}\n\n \nuint64_t mtd_get_device_size(const struct mtd_info *mtd)\n{\n\tstruct mtd_info *master = mtd_get_master((struct mtd_info *)mtd);\n\n\treturn master->size;\n}\nEXPORT_SYMBOL_GPL(mtd_get_device_size);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}