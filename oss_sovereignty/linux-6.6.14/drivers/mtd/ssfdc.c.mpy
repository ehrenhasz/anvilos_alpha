{
  "module_name": "ssfdc.c",
  "hash_id": "c2176693cc21f3b520047efe584fefb02850faad09fad3535faddc34630d669e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/ssfdc.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/hdreg.h>\n#include <linux/mtd/mtd.h>\n#include <linux/mtd/rawnand.h>\n#include <linux/mtd/blktrans.h>\n\nstruct ssfdcr_record {\n\tstruct mtd_blktrans_dev mbd;\n\tint usecount;\n\tunsigned char heads;\n\tunsigned char sectors;\n\tunsigned short cylinders;\n\tint cis_block;\t\t\t \n\tint erase_size;\t\t\t \n\tunsigned short *logic_block_map;  \n\tint map_len;\t\t\t \n};\n\n#define SSFDCR_MAJOR\t\t257\n#define SSFDCR_PARTN_BITS\t3\n\n#define SECTOR_SIZE\t\t512\n#define SECTOR_SHIFT\t\t9\n#define OOB_SIZE\t\t16\n\n#define MAX_LOGIC_BLK_PER_ZONE\t1000\n#define MAX_PHYS_BLK_PER_ZONE\t1024\n\n#define KiB(x)\t( (x) * 1024L )\n#define MiB(x)\t( KiB(x) * 1024L )\n\n \n\ntypedef struct {\n\tunsigned long size;\n\tunsigned short cyl;\n\tunsigned char head;\n\tunsigned char sec;\n} chs_entry_t;\n\n \nstatic const chs_entry_t chs_table[] = {\n\t{ MiB(  1), 125,  4,  4 },\n\t{ MiB(  2), 125,  4,  8 },\n\t{ MiB(  4), 250,  4,  8 },\n\t{ MiB(  8), 250,  4, 16 },\n\t{ MiB( 16), 500,  4, 16 },\n\t{ MiB( 32), 500,  8, 16 },\n\t{ MiB( 64), 500,  8, 32 },\n\t{ MiB(128), 500, 16, 32 },\n\t{ 0 },\n};\n\nstatic int get_chs(unsigned long size, unsigned short *cyl, unsigned char *head,\n\t\t\tunsigned char *sec)\n{\n\tint k;\n\tint found = 0;\n\n\tk = 0;\n\twhile (chs_table[k].size > 0 && size > chs_table[k].size)\n\t\tk++;\n\n\tif (chs_table[k].size > 0) {\n\t\tif (cyl)\n\t\t\t*cyl = chs_table[k].cyl;\n\t\tif (head)\n\t\t\t*head = chs_table[k].head;\n\t\tif (sec)\n\t\t\t*sec = chs_table[k].sec;\n\t\tfound = 1;\n\t}\n\n\treturn found;\n}\n\n \nstatic const uint8_t cis_numbers[] = {\n\t0x01, 0x03, 0xD9, 0x01, 0xFF, 0x18, 0x02, 0xDF, 0x01, 0x20\n};\n\n \nstatic int get_valid_cis_sector(struct mtd_info *mtd)\n{\n\tint ret, k, cis_sector;\n\tsize_t retlen;\n\tloff_t offset;\n\tuint8_t *sect_buf;\n\n\tcis_sector = -1;\n\n\tsect_buf = kmalloc(SECTOR_SIZE, GFP_KERNEL);\n\tif (!sect_buf)\n\t\tgoto out;\n\n\t \n\tfor (k = 0, offset = 0; k < 4; k++, offset += mtd->erasesize) {\n\t\tif (mtd_block_isbad(mtd, offset)) {\n\t\t\tret = mtd_read(mtd, offset, SECTOR_SIZE, &retlen,\n\t\t\t\t       sect_buf);\n\n\t\t\t \n\t\t\tif (ret < 0 || retlen != SECTOR_SIZE) {\n\t\t\t\tprintk(KERN_WARNING\n\t\t\t\t\t\"SSFDC_RO:can't read CIS/IDI sector\\n\");\n\t\t\t} else if (!memcmp(sect_buf, cis_numbers,\n\t\t\t\t\tsizeof(cis_numbers))) {\n\t\t\t\t \n\t\t\t\tcis_sector = (int)(offset >> SECTOR_SHIFT);\n\t\t\t} else {\n\t\t\t\tpr_debug(\"SSFDC_RO: CIS/IDI sector not found\"\n\t\t\t\t\t\" on %s (mtd%d)\\n\", mtd->name,\n\t\t\t\t\tmtd->index);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tkfree(sect_buf);\n out:\n\treturn cis_sector;\n}\n\n \nstatic int read_physical_sector(struct mtd_info *mtd, uint8_t *sect_buf,\n\t\t\t\tint sect_no)\n{\n\tint ret;\n\tsize_t retlen;\n\tloff_t offset = (loff_t)sect_no << SECTOR_SHIFT;\n\n\tret = mtd_read(mtd, offset, SECTOR_SIZE, &retlen, sect_buf);\n\tif (ret < 0 || retlen != SECTOR_SIZE)\n\t\treturn -1;\n\n\treturn 0;\n}\n\n \nstatic int read_raw_oob(struct mtd_info *mtd, loff_t offs, uint8_t *buf)\n{\n\tstruct mtd_oob_ops ops = { };\n\tint ret;\n\n\tops.mode = MTD_OPS_RAW;\n\tops.ooboffs = 0;\n\tops.ooblen = OOB_SIZE;\n\tops.oobbuf = buf;\n\tops.datbuf = NULL;\n\n\tret = mtd_read_oob(mtd, offs, &ops);\n\tif (ret < 0 || ops.oobretlen != OOB_SIZE)\n\t\treturn -1;\n\n\treturn 0;\n}\n\n \nstatic int get_parity(int number, int size)\n{\n \tint k;\n\tint parity;\n\n\tparity = 1;\n\tfor (k = 0; k < size; k++) {\n\t\tparity += (number >> k);\n\t\tparity &= 1;\n\t}\n\treturn parity;\n}\n\n \nstatic int get_logical_address(uint8_t *oob_buf)\n{\n\tint block_address, parity;\n\tint offset[2] = {6, 11};  \n\tint j;\n\tint ok = 0;\n\n\t \n\tfor (j = 0; j < ARRAY_SIZE(offset); j++) {\n\t\tblock_address = ((int)oob_buf[offset[j]] << 8) |\n\t\t\toob_buf[offset[j]+1];\n\n\t\t \n\t\tif ((block_address & ~0x7FF) == 0x1000) {\n\t\t\tparity = block_address & 0x01;\n\t\t\tblock_address &= 0x7FF;\n\t\t\tblock_address >>= 1;\n\n\t\t\tif (get_parity(block_address, 10) != parity) {\n\t\t\t\tpr_debug(\"SSFDC_RO: logical address field%d\"\n\t\t\t\t\t\"parity error(0x%04X)\\n\", j+1,\n\t\t\t\t\tblock_address);\n\t\t\t} else {\n\t\t\t\tok = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!ok)\n\t\tblock_address = -2;\n\n\tpr_debug(\"SSFDC_RO: get_logical_address() %d\\n\",\n\t\tblock_address);\n\n\treturn block_address;\n}\n\n \nstatic int build_logical_block_map(struct ssfdcr_record *ssfdc)\n{\n\tunsigned long offset;\n\tuint8_t oob_buf[OOB_SIZE];\n\tint ret, block_address, phys_block;\n\tstruct mtd_info *mtd = ssfdc->mbd.mtd;\n\n\tpr_debug(\"SSFDC_RO: build_block_map() nblks=%d (%luK)\\n\",\n\t      ssfdc->map_len,\n\t      (unsigned long)ssfdc->map_len * ssfdc->erase_size / 1024);\n\n\t \n\tfor (phys_block = ssfdc->cis_block + 1; phys_block < ssfdc->map_len;\n\t\t\tphys_block++) {\n\t\toffset = (unsigned long)phys_block * ssfdc->erase_size;\n\t\tif (mtd_block_isbad(mtd, offset))\n\t\t\tcontinue;\t \n\n\t\tret = read_raw_oob(mtd, offset, oob_buf);\n\t\tif (ret < 0) {\n\t\t\tpr_debug(\"SSFDC_RO: mtd read_oob() failed at %lu\\n\",\n\t\t\t\toffset);\n\t\t\treturn -1;\n\t\t}\n\t\tblock_address = get_logical_address(oob_buf);\n\n\t\t \n\t\tif (block_address >= 0 &&\n\t\t\t\tblock_address < MAX_LOGIC_BLK_PER_ZONE) {\n\t\t\tint zone_index;\n\n\t\t\tzone_index = phys_block / MAX_PHYS_BLK_PER_ZONE;\n\t\t\tblock_address += zone_index * MAX_LOGIC_BLK_PER_ZONE;\n\t\t\tssfdc->logic_block_map[block_address] =\n\t\t\t\t(unsigned short)phys_block;\n\n\t\t\tpr_debug(\"SSFDC_RO: build_block_map() phys_block=%d,\"\n\t\t\t\t\"logic_block_addr=%d, zone=%d\\n\",\n\t\t\t\tphys_block, block_address, zone_index);\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic void ssfdcr_add_mtd(struct mtd_blktrans_ops *tr, struct mtd_info *mtd)\n{\n\tstruct ssfdcr_record *ssfdc;\n\tint cis_sector;\n\n\t \n\tif (!mtd_type_is_nand(mtd) || mtd->oobsize != OOB_SIZE ||\n\t    mtd->size > UINT_MAX)\n\t\treturn;\n\n\t \n\tcis_sector = get_valid_cis_sector(mtd);\n\tif (cis_sector == -1)\n\t\treturn;\n\n\tssfdc = kzalloc(sizeof(struct ssfdcr_record), GFP_KERNEL);\n\tif (!ssfdc)\n\t\treturn;\n\n\tssfdc->mbd.mtd = mtd;\n\tssfdc->mbd.devnum = -1;\n\tssfdc->mbd.tr = tr;\n\tssfdc->mbd.readonly = 1;\n\n\tssfdc->cis_block = cis_sector / (mtd->erasesize >> SECTOR_SHIFT);\n\tssfdc->erase_size = mtd->erasesize;\n\tssfdc->map_len = (u32)mtd->size / mtd->erasesize;\n\n\tpr_debug(\"SSFDC_RO: cis_block=%d,erase_size=%d,map_len=%d,n_zones=%d\\n\",\n\t\tssfdc->cis_block, ssfdc->erase_size, ssfdc->map_len,\n\t\tDIV_ROUND_UP(ssfdc->map_len, MAX_PHYS_BLK_PER_ZONE));\n\n\t \n\tssfdc->heads = 16;\n\tssfdc->sectors = 32;\n\tget_chs(mtd->size, NULL, &ssfdc->heads, &ssfdc->sectors);\n\tssfdc->cylinders = (unsigned short)(((u32)mtd->size >> SECTOR_SHIFT) /\n\t\t\t((long)ssfdc->sectors * (long)ssfdc->heads));\n\n\tpr_debug(\"SSFDC_RO: using C:%d H:%d S:%d == %ld sects\\n\",\n\t\tssfdc->cylinders, ssfdc->heads , ssfdc->sectors,\n\t\t(long)ssfdc->cylinders * (long)ssfdc->heads *\n\t\t(long)ssfdc->sectors);\n\n\tssfdc->mbd.size = (long)ssfdc->heads * (long)ssfdc->cylinders *\n\t\t\t\t(long)ssfdc->sectors;\n\n\t \n\tssfdc->logic_block_map =\n\t\tkmalloc_array(ssfdc->map_len,\n\t\t\t      sizeof(ssfdc->logic_block_map[0]), GFP_KERNEL);\n\tif (!ssfdc->logic_block_map)\n\t\tgoto out_err;\n\tmemset(ssfdc->logic_block_map, 0xff, sizeof(ssfdc->logic_block_map[0]) *\n\t\tssfdc->map_len);\n\n\t \n\tif (build_logical_block_map(ssfdc) < 0)\n\t\tgoto out_err;\n\n\t \n\tif (add_mtd_blktrans_dev(&ssfdc->mbd))\n\t\tgoto out_err;\n\n\tprintk(KERN_INFO \"SSFDC_RO: Found ssfdc%c on mtd%d (%s)\\n\",\n\t\tssfdc->mbd.devnum + 'a', mtd->index, mtd->name);\n\treturn;\n\nout_err:\n\tkfree(ssfdc->logic_block_map);\n        kfree(ssfdc);\n}\n\nstatic void ssfdcr_remove_dev(struct mtd_blktrans_dev *dev)\n{\n\tstruct ssfdcr_record *ssfdc = (struct ssfdcr_record *)dev;\n\n\tpr_debug(\"SSFDC_RO: remove_dev (i=%d)\\n\", dev->devnum);\n\n\tdel_mtd_blktrans_dev(dev);\n\tkfree(ssfdc->logic_block_map);\n}\n\nstatic int ssfdcr_readsect(struct mtd_blktrans_dev *dev,\n\t\t\t\tunsigned long logic_sect_no, char *buf)\n{\n\tstruct ssfdcr_record *ssfdc = (struct ssfdcr_record *)dev;\n\tint sectors_per_block, offset, block_address;\n\n\tsectors_per_block = ssfdc->erase_size >> SECTOR_SHIFT;\n\toffset = (int)(logic_sect_no % sectors_per_block);\n\tblock_address = (int)(logic_sect_no / sectors_per_block);\n\n\tpr_debug(\"SSFDC_RO: ssfdcr_readsect(%lu) sec_per_blk=%d, ofst=%d,\"\n\t\t\" block_addr=%d\\n\", logic_sect_no, sectors_per_block, offset,\n\t\tblock_address);\n\n\tBUG_ON(block_address >= ssfdc->map_len);\n\n\tblock_address = ssfdc->logic_block_map[block_address];\n\n\tpr_debug(\"SSFDC_RO: ssfdcr_readsect() phys_block_addr=%d\\n\",\n\t\tblock_address);\n\n\tif (block_address < 0xffff) {\n\t\tunsigned long sect_no;\n\n\t\tsect_no = (unsigned long)block_address * sectors_per_block +\n\t\t\t\toffset;\n\n\t\tpr_debug(\"SSFDC_RO: ssfdcr_readsect() phys_sect_no=%lu\\n\",\n\t\t\tsect_no);\n\n\t\tif (read_physical_sector(ssfdc->mbd.mtd, buf, sect_no) < 0)\n\t\t\treturn -EIO;\n\t} else {\n\t\tmemset(buf, 0xff, SECTOR_SIZE);\n\t}\n\n\treturn 0;\n}\n\nstatic int ssfdcr_getgeo(struct mtd_blktrans_dev *dev,  struct hd_geometry *geo)\n{\n\tstruct ssfdcr_record *ssfdc = (struct ssfdcr_record *)dev;\n\n\tpr_debug(\"SSFDC_RO: ssfdcr_getgeo() C=%d, H=%d, S=%d\\n\",\n\t\t\tssfdc->cylinders, ssfdc->heads, ssfdc->sectors);\n\n\tgeo->heads = ssfdc->heads;\n\tgeo->sectors = ssfdc->sectors;\n\tgeo->cylinders = ssfdc->cylinders;\n\n\treturn 0;\n}\n\n \n\nstatic struct mtd_blktrans_ops ssfdcr_tr = {\n\t.name\t\t= \"ssfdc\",\n\t.major\t\t= SSFDCR_MAJOR,\n\t.part_bits\t= SSFDCR_PARTN_BITS,\n\t.blksize\t= SECTOR_SIZE,\n\t.getgeo\t\t= ssfdcr_getgeo,\n\t.readsect\t= ssfdcr_readsect,\n\t.add_mtd\t= ssfdcr_add_mtd,\n\t.remove_dev\t= ssfdcr_remove_dev,\n\t.owner\t\t= THIS_MODULE,\n};\n\nstatic int __init init_ssfdcr(void)\n{\n\tprintk(KERN_INFO \"SSFDC read-only Flash Translation layer\\n\");\n\n\treturn register_mtd_blktrans(&ssfdcr_tr);\n}\n\nstatic void __exit cleanup_ssfdcr(void)\n{\n\tderegister_mtd_blktrans(&ssfdcr_tr);\n}\n\nmodule_init(init_ssfdcr);\nmodule_exit(cleanup_ssfdcr);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Claudio Lanconelli <lanconelli.claudio@eptar.com>\");\nMODULE_DESCRIPTION(\"Flash Translation Layer for read-only SSFDC SmartMedia card\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}