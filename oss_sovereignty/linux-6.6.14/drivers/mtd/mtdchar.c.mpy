{
  "module_name": "mtdchar.c",
  "hash_id": "904df440d6b6e4d63c11688d3a385dd9d9fb9ec2c7b83bcc105364a221462630",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/mtdchar.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/err.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/backing-dev.h>\n#include <linux/compat.h>\n#include <linux/mount.h>\n#include <linux/blkpg.h>\n#include <linux/magic.h>\n#include <linux/major.h>\n#include <linux/mtd/mtd.h>\n#include <linux/mtd/partitions.h>\n#include <linux/mtd/map.h>\n\n#include <linux/uaccess.h>\n\n#include \"mtdcore.h\"\n\n \nstruct mtd_file_info {\n\tstruct mtd_info *mtd;\n\tenum mtd_file_modes mode;\n};\n\nstatic loff_t mtdchar_lseek(struct file *file, loff_t offset, int orig)\n{\n\tstruct mtd_file_info *mfi = file->private_data;\n\treturn fixed_size_llseek(file, offset, orig, mfi->mtd->size);\n}\n\nstatic int mtdchar_open(struct inode *inode, struct file *file)\n{\n\tint minor = iminor(inode);\n\tint devnum = minor >> 1;\n\tint ret = 0;\n\tstruct mtd_info *mtd;\n\tstruct mtd_file_info *mfi;\n\n\tpr_debug(\"MTD_open\\n\");\n\n\t \n\tif ((file->f_mode & FMODE_WRITE) && (minor & 1))\n\t\treturn -EACCES;\n\n\tmtd = get_mtd_device(NULL, devnum);\n\n\tif (IS_ERR(mtd))\n\t\treturn PTR_ERR(mtd);\n\n\tif (mtd->type == MTD_ABSENT) {\n\t\tret = -ENODEV;\n\t\tgoto out1;\n\t}\n\n\t \n\tif ((file->f_mode & FMODE_WRITE) && !(mtd->flags & MTD_WRITEABLE)) {\n\t\tret = -EACCES;\n\t\tgoto out1;\n\t}\n\n\tmfi = kzalloc(sizeof(*mfi), GFP_KERNEL);\n\tif (!mfi) {\n\t\tret = -ENOMEM;\n\t\tgoto out1;\n\t}\n\tmfi->mtd = mtd;\n\tfile->private_data = mfi;\n\treturn 0;\n\nout1:\n\tput_mtd_device(mtd);\n\treturn ret;\n}  \n\n \n\nstatic int mtdchar_close(struct inode *inode, struct file *file)\n{\n\tstruct mtd_file_info *mfi = file->private_data;\n\tstruct mtd_info *mtd = mfi->mtd;\n\n\tpr_debug(\"MTD_close\\n\");\n\n\t \n\tif ((file->f_mode & FMODE_WRITE))\n\t\tmtd_sync(mtd);\n\n\tput_mtd_device(mtd);\n\tfile->private_data = NULL;\n\tkfree(mfi);\n\n\treturn 0;\n}  \n\n \n\nstatic ssize_t mtdchar_read(struct file *file, char __user *buf, size_t count,\n\t\t\tloff_t *ppos)\n{\n\tstruct mtd_file_info *mfi = file->private_data;\n\tstruct mtd_info *mtd = mfi->mtd;\n\tsize_t retlen;\n\tsize_t total_retlen=0;\n\tint ret=0;\n\tint len;\n\tsize_t size = count;\n\tchar *kbuf;\n\n\tpr_debug(\"MTD_read\\n\");\n\n\tif (*ppos + count > mtd->size) {\n\t\tif (*ppos < mtd->size)\n\t\t\tcount = mtd->size - *ppos;\n\t\telse\n\t\t\tcount = 0;\n\t}\n\n\tif (!count)\n\t\treturn 0;\n\n\tkbuf = mtd_kmalloc_up_to(mtd, &size);\n\tif (!kbuf)\n\t\treturn -ENOMEM;\n\n\twhile (count) {\n\t\tlen = min_t(size_t, count, size);\n\n\t\tswitch (mfi->mode) {\n\t\tcase MTD_FILE_MODE_OTP_FACTORY:\n\t\t\tret = mtd_read_fact_prot_reg(mtd, *ppos, len,\n\t\t\t\t\t\t     &retlen, kbuf);\n\t\t\tbreak;\n\t\tcase MTD_FILE_MODE_OTP_USER:\n\t\t\tret = mtd_read_user_prot_reg(mtd, *ppos, len,\n\t\t\t\t\t\t     &retlen, kbuf);\n\t\t\tbreak;\n\t\tcase MTD_FILE_MODE_RAW:\n\t\t{\n\t\t\tstruct mtd_oob_ops ops = {};\n\n\t\t\tops.mode = MTD_OPS_RAW;\n\t\t\tops.datbuf = kbuf;\n\t\t\tops.oobbuf = NULL;\n\t\t\tops.len = len;\n\n\t\t\tret = mtd_read_oob(mtd, *ppos, &ops);\n\t\t\tretlen = ops.retlen;\n\t\t\tbreak;\n\t\t}\n\t\tdefault:\n\t\t\tret = mtd_read(mtd, *ppos, len, &retlen, kbuf);\n\t\t}\n\t\t \n\t\tif (!ret || mtd_is_bitflip_or_eccerr(ret)) {\n\t\t\t*ppos += retlen;\n\t\t\tif (copy_to_user(buf, kbuf, retlen)) {\n\t\t\t\tkfree(kbuf);\n\t\t\t\treturn -EFAULT;\n\t\t\t}\n\t\t\telse\n\t\t\t\ttotal_retlen += retlen;\n\n\t\t\tcount -= retlen;\n\t\t\tbuf += retlen;\n\t\t\tif (retlen == 0)\n\t\t\t\tcount = 0;\n\t\t}\n\t\telse {\n\t\t\tkfree(kbuf);\n\t\t\treturn ret;\n\t\t}\n\n\t}\n\n\tkfree(kbuf);\n\treturn total_retlen;\n}  \n\nstatic ssize_t mtdchar_write(struct file *file, const char __user *buf, size_t count,\n\t\t\tloff_t *ppos)\n{\n\tstruct mtd_file_info *mfi = file->private_data;\n\tstruct mtd_info *mtd = mfi->mtd;\n\tsize_t size = count;\n\tchar *kbuf;\n\tsize_t retlen;\n\tsize_t total_retlen=0;\n\tint ret=0;\n\tint len;\n\n\tpr_debug(\"MTD_write\\n\");\n\n\tif (*ppos >= mtd->size)\n\t\treturn -ENOSPC;\n\n\tif (*ppos + count > mtd->size)\n\t\tcount = mtd->size - *ppos;\n\n\tif (!count)\n\t\treturn 0;\n\n\tkbuf = mtd_kmalloc_up_to(mtd, &size);\n\tif (!kbuf)\n\t\treturn -ENOMEM;\n\n\twhile (count) {\n\t\tlen = min_t(size_t, count, size);\n\n\t\tif (copy_from_user(kbuf, buf, len)) {\n\t\t\tkfree(kbuf);\n\t\t\treturn -EFAULT;\n\t\t}\n\n\t\tswitch (mfi->mode) {\n\t\tcase MTD_FILE_MODE_OTP_FACTORY:\n\t\t\tret = -EROFS;\n\t\t\tbreak;\n\t\tcase MTD_FILE_MODE_OTP_USER:\n\t\t\tret = mtd_write_user_prot_reg(mtd, *ppos, len,\n\t\t\t\t\t\t      &retlen, kbuf);\n\t\t\tbreak;\n\n\t\tcase MTD_FILE_MODE_RAW:\n\t\t{\n\t\t\tstruct mtd_oob_ops ops = {};\n\n\t\t\tops.mode = MTD_OPS_RAW;\n\t\t\tops.datbuf = kbuf;\n\t\t\tops.oobbuf = NULL;\n\t\t\tops.ooboffs = 0;\n\t\t\tops.len = len;\n\n\t\t\tret = mtd_write_oob(mtd, *ppos, &ops);\n\t\t\tretlen = ops.retlen;\n\t\t\tbreak;\n\t\t}\n\n\t\tdefault:\n\t\t\tret = mtd_write(mtd, *ppos, len, &retlen, kbuf);\n\t\t}\n\n\t\t \n\t\tif ((ret == -ENOSPC) && (total_retlen))\n\t\t\tbreak;\n\n\t\tif (!ret) {\n\t\t\t*ppos += retlen;\n\t\t\ttotal_retlen += retlen;\n\t\t\tcount -= retlen;\n\t\t\tbuf += retlen;\n\t\t}\n\t\telse {\n\t\t\tkfree(kbuf);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tkfree(kbuf);\n\treturn total_retlen;\n}  \n\n \n\nstatic int otp_select_filemode(struct mtd_file_info *mfi, int mode)\n{\n\tstruct mtd_info *mtd = mfi->mtd;\n\tsize_t retlen;\n\n\tswitch (mode) {\n\tcase MTD_OTP_FACTORY:\n\t\tif (mtd_read_fact_prot_reg(mtd, -1, 0, &retlen, NULL) ==\n\t\t\t\t-EOPNOTSUPP)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tmfi->mode = MTD_FILE_MODE_OTP_FACTORY;\n\t\tbreak;\n\tcase MTD_OTP_USER:\n\t\tif (mtd_read_user_prot_reg(mtd, -1, 0, &retlen, NULL) ==\n\t\t\t\t-EOPNOTSUPP)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tmfi->mode = MTD_FILE_MODE_OTP_USER;\n\t\tbreak;\n\tcase MTD_OTP_OFF:\n\t\tmfi->mode = MTD_FILE_MODE_NORMAL;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int mtdchar_writeoob(struct file *file, struct mtd_info *mtd,\n\tuint64_t start, uint32_t length, void __user *ptr,\n\tuint32_t __user *retp)\n{\n\tstruct mtd_info *master  = mtd_get_master(mtd);\n\tstruct mtd_file_info *mfi = file->private_data;\n\tstruct mtd_oob_ops ops = {};\n\tuint32_t retlen;\n\tint ret = 0;\n\n\tif (length > 4096)\n\t\treturn -EINVAL;\n\n\tif (!master->_write_oob)\n\t\treturn -EOPNOTSUPP;\n\n\tops.ooblen = length;\n\tops.ooboffs = start & (mtd->writesize - 1);\n\tops.datbuf = NULL;\n\tops.mode = (mfi->mode == MTD_FILE_MODE_RAW) ? MTD_OPS_RAW :\n\t\tMTD_OPS_PLACE_OOB;\n\n\tif (ops.ooboffs && ops.ooblen > (mtd->oobsize - ops.ooboffs))\n\t\treturn -EINVAL;\n\n\tops.oobbuf = memdup_user(ptr, length);\n\tif (IS_ERR(ops.oobbuf))\n\t\treturn PTR_ERR(ops.oobbuf);\n\n\tstart &= ~((uint64_t)mtd->writesize - 1);\n\tret = mtd_write_oob(mtd, start, &ops);\n\n\tif (ops.oobretlen > 0xFFFFFFFFU)\n\t\tret = -EOVERFLOW;\n\tretlen = ops.oobretlen;\n\tif (copy_to_user(retp, &retlen, sizeof(length)))\n\t\tret = -EFAULT;\n\n\tkfree(ops.oobbuf);\n\treturn ret;\n}\n\nstatic int mtdchar_readoob(struct file *file, struct mtd_info *mtd,\n\tuint64_t start, uint32_t length, void __user *ptr,\n\tuint32_t __user *retp)\n{\n\tstruct mtd_file_info *mfi = file->private_data;\n\tstruct mtd_oob_ops ops = {};\n\tint ret = 0;\n\n\tif (length > 4096)\n\t\treturn -EINVAL;\n\n\tops.ooblen = length;\n\tops.ooboffs = start & (mtd->writesize - 1);\n\tops.datbuf = NULL;\n\tops.mode = (mfi->mode == MTD_FILE_MODE_RAW) ? MTD_OPS_RAW :\n\t\tMTD_OPS_PLACE_OOB;\n\n\tif (ops.ooboffs && ops.ooblen > (mtd->oobsize - ops.ooboffs))\n\t\treturn -EINVAL;\n\n\tops.oobbuf = kmalloc(length, GFP_KERNEL);\n\tif (!ops.oobbuf)\n\t\treturn -ENOMEM;\n\n\tstart &= ~((uint64_t)mtd->writesize - 1);\n\tret = mtd_read_oob(mtd, start, &ops);\n\n\tif (put_user(ops.oobretlen, retp))\n\t\tret = -EFAULT;\n\telse if (ops.oobretlen && copy_to_user(ptr, ops.oobbuf,\n\t\t\t\t\t    ops.oobretlen))\n\t\tret = -EFAULT;\n\n\tkfree(ops.oobbuf);\n\n\t \n\tif (mtd_is_bitflip_or_eccerr(ret))\n\t\treturn 0;\n\n\treturn ret;\n}\n\n \nstatic int shrink_ecclayout(struct mtd_info *mtd,\n\t\t\t    struct nand_ecclayout_user *to)\n{\n\tstruct mtd_oob_region oobregion;\n\tint i, section = 0, ret;\n\n\tif (!mtd || !to)\n\t\treturn -EINVAL;\n\n\tmemset(to, 0, sizeof(*to));\n\n\tto->eccbytes = 0;\n\tfor (i = 0; i < MTD_MAX_ECCPOS_ENTRIES;) {\n\t\tu32 eccpos;\n\n\t\tret = mtd_ooblayout_ecc(mtd, section++, &oobregion);\n\t\tif (ret < 0) {\n\t\t\tif (ret != -ERANGE)\n\t\t\t\treturn ret;\n\n\t\t\tbreak;\n\t\t}\n\n\t\teccpos = oobregion.offset;\n\t\tfor (; i < MTD_MAX_ECCPOS_ENTRIES &&\n\t\t       eccpos < oobregion.offset + oobregion.length; i++) {\n\t\t\tto->eccpos[i] = eccpos++;\n\t\t\tto->eccbytes++;\n\t\t}\n\t}\n\n\tfor (i = 0; i < MTD_MAX_OOBFREE_ENTRIES; i++) {\n\t\tret = mtd_ooblayout_free(mtd, i, &oobregion);\n\t\tif (ret < 0) {\n\t\t\tif (ret != -ERANGE)\n\t\t\t\treturn ret;\n\n\t\t\tbreak;\n\t\t}\n\n\t\tto->oobfree[i].offset = oobregion.offset;\n\t\tto->oobfree[i].length = oobregion.length;\n\t\tto->oobavail += to->oobfree[i].length;\n\t}\n\n\treturn 0;\n}\n\nstatic int get_oobinfo(struct mtd_info *mtd, struct nand_oobinfo *to)\n{\n\tstruct mtd_oob_region oobregion;\n\tint i, section = 0, ret;\n\n\tif (!mtd || !to)\n\t\treturn -EINVAL;\n\n\tmemset(to, 0, sizeof(*to));\n\n\tto->eccbytes = 0;\n\tfor (i = 0; i < ARRAY_SIZE(to->eccpos);) {\n\t\tu32 eccpos;\n\n\t\tret = mtd_ooblayout_ecc(mtd, section++, &oobregion);\n\t\tif (ret < 0) {\n\t\t\tif (ret != -ERANGE)\n\t\t\t\treturn ret;\n\n\t\t\tbreak;\n\t\t}\n\n\t\tif (oobregion.length + i > ARRAY_SIZE(to->eccpos))\n\t\t\treturn -EINVAL;\n\n\t\teccpos = oobregion.offset;\n\t\tfor (; eccpos < oobregion.offset + oobregion.length; i++) {\n\t\t\tto->eccpos[i] = eccpos++;\n\t\t\tto->eccbytes++;\n\t\t}\n\t}\n\n\tfor (i = 0; i < 8; i++) {\n\t\tret = mtd_ooblayout_free(mtd, i, &oobregion);\n\t\tif (ret < 0) {\n\t\t\tif (ret != -ERANGE)\n\t\t\t\treturn ret;\n\n\t\t\tbreak;\n\t\t}\n\n\t\tto->oobfree[i][0] = oobregion.offset;\n\t\tto->oobfree[i][1] = oobregion.length;\n\t}\n\n\tto->useecc = MTD_NANDECC_AUTOPLACE;\n\n\treturn 0;\n}\n\nstatic int mtdchar_blkpg_ioctl(struct mtd_info *mtd,\n\t\t\t       struct blkpg_ioctl_arg *arg)\n{\n\tstruct blkpg_partition p;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tif (copy_from_user(&p, arg->data, sizeof(p)))\n\t\treturn -EFAULT;\n\n\tswitch (arg->op) {\n\tcase BLKPG_ADD_PARTITION:\n\n\t\t \n\t\tif (mtd_is_partition(mtd))\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\tp.devname[BLKPG_DEVNAMELTH - 1] = '\\0';\n\n\t\treturn mtd_add_partition(mtd, p.devname, p.start, p.length);\n\n\tcase BLKPG_DEL_PARTITION:\n\n\t\tif (p.pno < 0)\n\t\t\treturn -EINVAL;\n\n\t\treturn mtd_del_partition(mtd, p.pno);\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic void adjust_oob_length(struct mtd_info *mtd, uint64_t start,\n\t\t\t      struct mtd_oob_ops *ops)\n{\n\tuint32_t start_page, end_page;\n\tu32 oob_per_page;\n\n\tif (ops->len == 0 || ops->ooblen == 0)\n\t\treturn;\n\n\tstart_page = mtd_div_by_ws(start, mtd);\n\tend_page = mtd_div_by_ws(start + ops->len - 1, mtd);\n\toob_per_page = mtd_oobavail(mtd, ops);\n\n\tops->ooblen = min_t(size_t, ops->ooblen,\n\t\t\t    (end_page - start_page + 1) * oob_per_page);\n}\n\nstatic noinline_for_stack int\nmtdchar_write_ioctl(struct mtd_info *mtd, struct mtd_write_req __user *argp)\n{\n\tstruct mtd_info *master = mtd_get_master(mtd);\n\tstruct mtd_write_req req;\n\tconst void __user *usr_data, *usr_oob;\n\tuint8_t *datbuf = NULL, *oobbuf = NULL;\n\tsize_t datbuf_len, oobbuf_len;\n\tint ret = 0;\n\n\tif (copy_from_user(&req, argp, sizeof(req)))\n\t\treturn -EFAULT;\n\n\tusr_data = (const void __user *)(uintptr_t)req.usr_data;\n\tusr_oob = (const void __user *)(uintptr_t)req.usr_oob;\n\n\tif (!master->_write_oob)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!usr_data)\n\t\treq.len = 0;\n\n\tif (!usr_oob)\n\t\treq.ooblen = 0;\n\n\treq.len &= 0xffffffff;\n\treq.ooblen &= 0xffffffff;\n\n\tif (req.start + req.len > mtd->size)\n\t\treturn -EINVAL;\n\n\tdatbuf_len = min_t(size_t, req.len, mtd->erasesize);\n\tif (datbuf_len > 0) {\n\t\tdatbuf = kvmalloc(datbuf_len, GFP_KERNEL);\n\t\tif (!datbuf)\n\t\t\treturn -ENOMEM;\n\t}\n\n\toobbuf_len = min_t(size_t, req.ooblen, mtd->erasesize);\n\tif (oobbuf_len > 0) {\n\t\toobbuf = kvmalloc(oobbuf_len, GFP_KERNEL);\n\t\tif (!oobbuf) {\n\t\t\tkvfree(datbuf);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\twhile (req.len > 0 || (!usr_data && req.ooblen > 0)) {\n\t\tstruct mtd_oob_ops ops = {\n\t\t\t.mode = req.mode,\n\t\t\t.len = min_t(size_t, req.len, datbuf_len),\n\t\t\t.ooblen = min_t(size_t, req.ooblen, oobbuf_len),\n\t\t\t.datbuf = datbuf,\n\t\t\t.oobbuf = oobbuf,\n\t\t};\n\n\t\t \n\t\tif (ops.len == mtd->erasesize)\n\t\t\tops.len -= mtd_mod_by_ws(req.start + ops.len, mtd);\n\n\t\t \n\t\tadjust_oob_length(mtd, req.start, &ops);\n\n\t\tif (copy_from_user(datbuf, usr_data, ops.len) ||\n\t\t    copy_from_user(oobbuf, usr_oob, ops.ooblen)) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tret = mtd_write_oob(mtd, req.start, &ops);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\treq.start += ops.retlen;\n\t\treq.len -= ops.retlen;\n\t\tusr_data += ops.retlen;\n\n\t\treq.ooblen -= ops.oobretlen;\n\t\tusr_oob += ops.oobretlen;\n\t}\n\n\tkvfree(datbuf);\n\tkvfree(oobbuf);\n\n\treturn ret;\n}\n\nstatic noinline_for_stack int\nmtdchar_read_ioctl(struct mtd_info *mtd, struct mtd_read_req __user *argp)\n{\n\tstruct mtd_info *master = mtd_get_master(mtd);\n\tstruct mtd_read_req req;\n\tvoid __user *usr_data, *usr_oob;\n\tuint8_t *datbuf = NULL, *oobbuf = NULL;\n\tsize_t datbuf_len, oobbuf_len;\n\tsize_t orig_len, orig_ooblen;\n\tint ret = 0;\n\n\tif (copy_from_user(&req, argp, sizeof(req)))\n\t\treturn -EFAULT;\n\n\torig_len = req.len;\n\torig_ooblen = req.ooblen;\n\n\tusr_data = (void __user *)(uintptr_t)req.usr_data;\n\tusr_oob = (void __user *)(uintptr_t)req.usr_oob;\n\n\tif (!master->_read_oob)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!usr_data)\n\t\treq.len = 0;\n\n\tif (!usr_oob)\n\t\treq.ooblen = 0;\n\n\treq.ecc_stats.uncorrectable_errors = 0;\n\treq.ecc_stats.corrected_bitflips = 0;\n\treq.ecc_stats.max_bitflips = 0;\n\n\treq.len &= 0xffffffff;\n\treq.ooblen &= 0xffffffff;\n\n\tif (req.start + req.len > mtd->size) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tdatbuf_len = min_t(size_t, req.len, mtd->erasesize);\n\tif (datbuf_len > 0) {\n\t\tdatbuf = kvmalloc(datbuf_len, GFP_KERNEL);\n\t\tif (!datbuf) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\toobbuf_len = min_t(size_t, req.ooblen, mtd->erasesize);\n\tif (oobbuf_len > 0) {\n\t\toobbuf = kvmalloc(oobbuf_len, GFP_KERNEL);\n\t\tif (!oobbuf) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\twhile (req.len > 0 || (!usr_data && req.ooblen > 0)) {\n\t\tstruct mtd_req_stats stats;\n\t\tstruct mtd_oob_ops ops = {\n\t\t\t.mode = req.mode,\n\t\t\t.len = min_t(size_t, req.len, datbuf_len),\n\t\t\t.ooblen = min_t(size_t, req.ooblen, oobbuf_len),\n\t\t\t.datbuf = datbuf,\n\t\t\t.oobbuf = oobbuf,\n\t\t\t.stats = &stats,\n\t\t};\n\n\t\t \n\t\tif (ops.len == mtd->erasesize)\n\t\t\tops.len -= mtd_mod_by_ws(req.start + ops.len, mtd);\n\n\t\tret = mtd_read_oob(mtd, (loff_t)req.start, &ops);\n\n\t\treq.ecc_stats.uncorrectable_errors +=\n\t\t\tstats.uncorrectable_errors;\n\t\treq.ecc_stats.corrected_bitflips += stats.corrected_bitflips;\n\t\treq.ecc_stats.max_bitflips =\n\t\t\tmax(req.ecc_stats.max_bitflips, stats.max_bitflips);\n\n\t\tif (ret && !mtd_is_bitflip_or_eccerr(ret))\n\t\t\tbreak;\n\n\t\tif (copy_to_user(usr_data, ops.datbuf, ops.retlen) ||\n\t\t    copy_to_user(usr_oob, ops.oobbuf, ops.oobretlen)) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\treq.start += ops.retlen;\n\t\treq.len -= ops.retlen;\n\t\tusr_data += ops.retlen;\n\n\t\treq.ooblen -= ops.oobretlen;\n\t\tusr_oob += ops.oobretlen;\n\t}\n\n\t \n\tif (!ret || mtd_is_bitflip(ret)) {\n\t\tif (req.ecc_stats.uncorrectable_errors > 0)\n\t\t\tret = -EBADMSG;\n\t\telse if (req.ecc_stats.corrected_bitflips > 0)\n\t\t\tret = -EUCLEAN;\n\t}\n\nout:\n\treq.len = orig_len - req.len;\n\treq.ooblen = orig_ooblen - req.ooblen;\n\n\tif (copy_to_user(argp, &req, sizeof(req)))\n\t\tret = -EFAULT;\n\n\tkvfree(datbuf);\n\tkvfree(oobbuf);\n\n\treturn ret;\n}\n\nstatic int mtdchar_ioctl(struct file *file, u_int cmd, u_long arg)\n{\n\tstruct mtd_file_info *mfi = file->private_data;\n\tstruct mtd_info *mtd = mfi->mtd;\n\tstruct mtd_info *master = mtd_get_master(mtd);\n\tvoid __user *argp = (void __user *)arg;\n\tint ret = 0;\n\tstruct mtd_info_user info;\n\n\tpr_debug(\"MTD_ioctl\\n\");\n\n\t \n\tswitch (cmd) {\n\t \n\tcase MEMGETREGIONCOUNT:\n\tcase MEMGETREGIONINFO:\n\tcase MEMGETINFO:\n\tcase MEMREADOOB:\n\tcase MEMREADOOB64:\n\tcase MEMREAD:\n\tcase MEMISLOCKED:\n\tcase MEMGETOOBSEL:\n\tcase MEMGETBADBLOCK:\n\tcase OTPSELECT:\n\tcase OTPGETREGIONCOUNT:\n\tcase OTPGETREGIONINFO:\n\tcase ECCGETLAYOUT:\n\tcase ECCGETSTATS:\n\tcase MTDFILEMODE:\n\tcase BLKPG:\n\tcase BLKRRPART:\n\t\tbreak;\n\n\t \n\tcase MEMERASE:\n\tcase MEMERASE64:\n\tcase MEMLOCK:\n\tcase MEMUNLOCK:\n\tcase MEMSETBADBLOCK:\n\tcase MEMWRITEOOB:\n\tcase MEMWRITEOOB64:\n\tcase MEMWRITE:\n\tcase OTPLOCK:\n\tcase OTPERASE:\n\t\tif (!(file->f_mode & FMODE_WRITE))\n\t\t\treturn -EPERM;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -ENOTTY;\n\t}\n\n\tswitch (cmd) {\n\tcase MEMGETREGIONCOUNT:\n\t\tif (copy_to_user(argp, &(mtd->numeraseregions), sizeof(int)))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n\n\tcase MEMGETREGIONINFO:\n\t{\n\t\tuint32_t ur_idx;\n\t\tstruct mtd_erase_region_info *kr;\n\t\tstruct region_info_user __user *ur = argp;\n\n\t\tif (get_user(ur_idx, &(ur->regionindex)))\n\t\t\treturn -EFAULT;\n\n\t\tif (ur_idx >= mtd->numeraseregions)\n\t\t\treturn -EINVAL;\n\n\t\tkr = &(mtd->eraseregions[ur_idx]);\n\n\t\tif (put_user(kr->offset, &(ur->offset))\n\t\t    || put_user(kr->erasesize, &(ur->erasesize))\n\t\t    || put_user(kr->numblocks, &(ur->numblocks)))\n\t\t\treturn -EFAULT;\n\n\t\tbreak;\n\t}\n\n\tcase MEMGETINFO:\n\t\tmemset(&info, 0, sizeof(info));\n\t\tinfo.type\t= mtd->type;\n\t\tinfo.flags\t= mtd->flags;\n\t\tinfo.size\t= mtd->size;\n\t\tinfo.erasesize\t= mtd->erasesize;\n\t\tinfo.writesize\t= mtd->writesize;\n\t\tinfo.oobsize\t= mtd->oobsize;\n\t\t \n\t\tinfo.padding\t= 0;\n\t\tif (copy_to_user(argp, &info, sizeof(struct mtd_info_user)))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n\n\tcase MEMERASE:\n\tcase MEMERASE64:\n\t{\n\t\tstruct erase_info *erase;\n\n\t\terase=kzalloc(sizeof(struct erase_info),GFP_KERNEL);\n\t\tif (!erase)\n\t\t\tret = -ENOMEM;\n\t\telse {\n\t\t\tif (cmd == MEMERASE64) {\n\t\t\t\tstruct erase_info_user64 einfo64;\n\n\t\t\t\tif (copy_from_user(&einfo64, argp,\n\t\t\t\t\t    sizeof(struct erase_info_user64))) {\n\t\t\t\t\tkfree(erase);\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\t}\n\t\t\t\terase->addr = einfo64.start;\n\t\t\t\terase->len = einfo64.length;\n\t\t\t} else {\n\t\t\t\tstruct erase_info_user einfo32;\n\n\t\t\t\tif (copy_from_user(&einfo32, argp,\n\t\t\t\t\t    sizeof(struct erase_info_user))) {\n\t\t\t\t\tkfree(erase);\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\t}\n\t\t\t\terase->addr = einfo32.start;\n\t\t\t\terase->len = einfo32.length;\n\t\t\t}\n\n\t\t\tret = mtd_erase(mtd, erase);\n\t\t\tkfree(erase);\n\t\t}\n\t\tbreak;\n\t}\n\n\tcase MEMWRITEOOB:\n\t{\n\t\tstruct mtd_oob_buf buf;\n\t\tstruct mtd_oob_buf __user *buf_user = argp;\n\n\t\t \n\t\tif (copy_from_user(&buf, argp, sizeof(buf)))\n\t\t\tret = -EFAULT;\n\t\telse\n\t\t\tret = mtdchar_writeoob(file, mtd, buf.start, buf.length,\n\t\t\t\tbuf.ptr, &buf_user->length);\n\t\tbreak;\n\t}\n\n\tcase MEMREADOOB:\n\t{\n\t\tstruct mtd_oob_buf buf;\n\t\tstruct mtd_oob_buf __user *buf_user = argp;\n\n\t\t \n\t\tif (copy_from_user(&buf, argp, sizeof(buf)))\n\t\t\tret = -EFAULT;\n\t\telse\n\t\t\tret = mtdchar_readoob(file, mtd, buf.start, buf.length,\n\t\t\t\tbuf.ptr, &buf_user->start);\n\t\tbreak;\n\t}\n\n\tcase MEMWRITEOOB64:\n\t{\n\t\tstruct mtd_oob_buf64 buf;\n\t\tstruct mtd_oob_buf64 __user *buf_user = argp;\n\n\t\tif (copy_from_user(&buf, argp, sizeof(buf)))\n\t\t\tret = -EFAULT;\n\t\telse\n\t\t\tret = mtdchar_writeoob(file, mtd, buf.start, buf.length,\n\t\t\t\t(void __user *)(uintptr_t)buf.usr_ptr,\n\t\t\t\t&buf_user->length);\n\t\tbreak;\n\t}\n\n\tcase MEMREADOOB64:\n\t{\n\t\tstruct mtd_oob_buf64 buf;\n\t\tstruct mtd_oob_buf64 __user *buf_user = argp;\n\n\t\tif (copy_from_user(&buf, argp, sizeof(buf)))\n\t\t\tret = -EFAULT;\n\t\telse\n\t\t\tret = mtdchar_readoob(file, mtd, buf.start, buf.length,\n\t\t\t\t(void __user *)(uintptr_t)buf.usr_ptr,\n\t\t\t\t&buf_user->length);\n\t\tbreak;\n\t}\n\n\tcase MEMWRITE:\n\t{\n\t\tret = mtdchar_write_ioctl(mtd,\n\t\t      (struct mtd_write_req __user *)arg);\n\t\tbreak;\n\t}\n\n\tcase MEMREAD:\n\t{\n\t\tret = mtdchar_read_ioctl(mtd,\n\t\t      (struct mtd_read_req __user *)arg);\n\t\tbreak;\n\t}\n\n\tcase MEMLOCK:\n\t{\n\t\tstruct erase_info_user einfo;\n\n\t\tif (copy_from_user(&einfo, argp, sizeof(einfo)))\n\t\t\treturn -EFAULT;\n\n\t\tret = mtd_lock(mtd, einfo.start, einfo.length);\n\t\tbreak;\n\t}\n\n\tcase MEMUNLOCK:\n\t{\n\t\tstruct erase_info_user einfo;\n\n\t\tif (copy_from_user(&einfo, argp, sizeof(einfo)))\n\t\t\treturn -EFAULT;\n\n\t\tret = mtd_unlock(mtd, einfo.start, einfo.length);\n\t\tbreak;\n\t}\n\n\tcase MEMISLOCKED:\n\t{\n\t\tstruct erase_info_user einfo;\n\n\t\tif (copy_from_user(&einfo, argp, sizeof(einfo)))\n\t\t\treturn -EFAULT;\n\n\t\tret = mtd_is_locked(mtd, einfo.start, einfo.length);\n\t\tbreak;\n\t}\n\n\t \n\tcase MEMGETOOBSEL:\n\t{\n\t\tstruct nand_oobinfo oi;\n\n\t\tif (!master->ooblayout)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tret = get_oobinfo(mtd, &oi);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (copy_to_user(argp, &oi, sizeof(struct nand_oobinfo)))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n\t}\n\n\tcase MEMGETBADBLOCK:\n\t{\n\t\tloff_t offs;\n\n\t\tif (copy_from_user(&offs, argp, sizeof(loff_t)))\n\t\t\treturn -EFAULT;\n\t\treturn mtd_block_isbad(mtd, offs);\n\t}\n\n\tcase MEMSETBADBLOCK:\n\t{\n\t\tloff_t offs;\n\n\t\tif (copy_from_user(&offs, argp, sizeof(loff_t)))\n\t\t\treturn -EFAULT;\n\t\treturn mtd_block_markbad(mtd, offs);\n\t}\n\n\tcase OTPSELECT:\n\t{\n\t\tint mode;\n\t\tif (copy_from_user(&mode, argp, sizeof(int)))\n\t\t\treturn -EFAULT;\n\n\t\tmfi->mode = MTD_FILE_MODE_NORMAL;\n\n\t\tret = otp_select_filemode(mfi, mode);\n\n\t\tfile->f_pos = 0;\n\t\tbreak;\n\t}\n\n\tcase OTPGETREGIONCOUNT:\n\tcase OTPGETREGIONINFO:\n\t{\n\t\tstruct otp_info *buf = kmalloc(4096, GFP_KERNEL);\n\t\tsize_t retlen;\n\t\tif (!buf)\n\t\t\treturn -ENOMEM;\n\t\tswitch (mfi->mode) {\n\t\tcase MTD_FILE_MODE_OTP_FACTORY:\n\t\t\tret = mtd_get_fact_prot_info(mtd, 4096, &retlen, buf);\n\t\t\tbreak;\n\t\tcase MTD_FILE_MODE_OTP_USER:\n\t\t\tret = mtd_get_user_prot_info(mtd, 4096, &retlen, buf);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tif (!ret) {\n\t\t\tif (cmd == OTPGETREGIONCOUNT) {\n\t\t\t\tint nbr = retlen / sizeof(struct otp_info);\n\t\t\t\tret = copy_to_user(argp, &nbr, sizeof(int));\n\t\t\t} else\n\t\t\t\tret = copy_to_user(argp, buf, retlen);\n\t\t\tif (ret)\n\t\t\t\tret = -EFAULT;\n\t\t}\n\t\tkfree(buf);\n\t\tbreak;\n\t}\n\n\tcase OTPLOCK:\n\tcase OTPERASE:\n\t{\n\t\tstruct otp_info oinfo;\n\n\t\tif (mfi->mode != MTD_FILE_MODE_OTP_USER)\n\t\t\treturn -EINVAL;\n\t\tif (copy_from_user(&oinfo, argp, sizeof(oinfo)))\n\t\t\treturn -EFAULT;\n\t\tif (cmd == OTPLOCK)\n\t\t\tret = mtd_lock_user_prot_reg(mtd, oinfo.start, oinfo.length);\n\t\telse\n\t\t\tret = mtd_erase_user_prot_reg(mtd, oinfo.start, oinfo.length);\n\t\tbreak;\n\t}\n\n\t \n\tcase ECCGETLAYOUT:\n\t{\n\t\tstruct nand_ecclayout_user *usrlay;\n\n\t\tif (!master->ooblayout)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tusrlay = kmalloc(sizeof(*usrlay), GFP_KERNEL);\n\t\tif (!usrlay)\n\t\t\treturn -ENOMEM;\n\n\t\tshrink_ecclayout(mtd, usrlay);\n\n\t\tif (copy_to_user(argp, usrlay, sizeof(*usrlay)))\n\t\t\tret = -EFAULT;\n\t\tkfree(usrlay);\n\t\tbreak;\n\t}\n\n\tcase ECCGETSTATS:\n\t{\n\t\tif (copy_to_user(argp, &mtd->ecc_stats,\n\t\t\t\t sizeof(struct mtd_ecc_stats)))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n\t}\n\n\tcase MTDFILEMODE:\n\t{\n\t\tmfi->mode = 0;\n\n\t\tswitch(arg) {\n\t\tcase MTD_FILE_MODE_OTP_FACTORY:\n\t\tcase MTD_FILE_MODE_OTP_USER:\n\t\t\tret = otp_select_filemode(mfi, arg);\n\t\t\tbreak;\n\n\t\tcase MTD_FILE_MODE_RAW:\n\t\t\tif (!mtd_has_oob(mtd))\n\t\t\t\treturn -EOPNOTSUPP;\n\t\t\tmfi->mode = arg;\n\t\t\tbreak;\n\n\t\tcase MTD_FILE_MODE_NORMAL:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = -EINVAL;\n\t\t}\n\t\tfile->f_pos = 0;\n\t\tbreak;\n\t}\n\n\tcase BLKPG:\n\t{\n\t\tstruct blkpg_ioctl_arg __user *blk_arg = argp;\n\t\tstruct blkpg_ioctl_arg a;\n\n\t\tif (copy_from_user(&a, blk_arg, sizeof(a)))\n\t\t\tret = -EFAULT;\n\t\telse\n\t\t\tret = mtdchar_blkpg_ioctl(mtd, &a);\n\t\tbreak;\n\t}\n\n\tcase BLKRRPART:\n\t{\n\t\t \n\t\tret = 0;\n\t\tbreak;\n\t}\n\t}\n\n\treturn ret;\n}  \n\nstatic long mtdchar_unlocked_ioctl(struct file *file, u_int cmd, u_long arg)\n{\n\tstruct mtd_file_info *mfi = file->private_data;\n\tstruct mtd_info *mtd = mfi->mtd;\n\tstruct mtd_info *master = mtd_get_master(mtd);\n\tint ret;\n\n\tmutex_lock(&master->master.chrdev_lock);\n\tret = mtdchar_ioctl(file, cmd, arg);\n\tmutex_unlock(&master->master.chrdev_lock);\n\n\treturn ret;\n}\n\n#ifdef CONFIG_COMPAT\n\nstruct mtd_oob_buf32 {\n\tu_int32_t start;\n\tu_int32_t length;\n\tcompat_caddr_t ptr;\t \n};\n\n#define MEMWRITEOOB32\t\t_IOWR('M', 3, struct mtd_oob_buf32)\n#define MEMREADOOB32\t\t_IOWR('M', 4, struct mtd_oob_buf32)\n\nstatic long mtdchar_compat_ioctl(struct file *file, unsigned int cmd,\n\tunsigned long arg)\n{\n\tstruct mtd_file_info *mfi = file->private_data;\n\tstruct mtd_info *mtd = mfi->mtd;\n\tstruct mtd_info *master = mtd_get_master(mtd);\n\tvoid __user *argp = compat_ptr(arg);\n\tint ret = 0;\n\n\tmutex_lock(&master->master.chrdev_lock);\n\n\tswitch (cmd) {\n\tcase MEMWRITEOOB32:\n\t{\n\t\tstruct mtd_oob_buf32 buf;\n\t\tstruct mtd_oob_buf32 __user *buf_user = argp;\n\n\t\tif (!(file->f_mode & FMODE_WRITE)) {\n\t\t\tret = -EPERM;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (copy_from_user(&buf, argp, sizeof(buf)))\n\t\t\tret = -EFAULT;\n\t\telse\n\t\t\tret = mtdchar_writeoob(file, mtd, buf.start,\n\t\t\t\tbuf.length, compat_ptr(buf.ptr),\n\t\t\t\t&buf_user->length);\n\t\tbreak;\n\t}\n\n\tcase MEMREADOOB32:\n\t{\n\t\tstruct mtd_oob_buf32 buf;\n\t\tstruct mtd_oob_buf32 __user *buf_user = argp;\n\n\t\t \n\t\tif (copy_from_user(&buf, argp, sizeof(buf)))\n\t\t\tret = -EFAULT;\n\t\telse\n\t\t\tret = mtdchar_readoob(file, mtd, buf.start,\n\t\t\t\tbuf.length, compat_ptr(buf.ptr),\n\t\t\t\t&buf_user->start);\n\t\tbreak;\n\t}\n\n\tcase BLKPG:\n\t{\n\t\t \n\t\tstruct blkpg_compat_ioctl_arg __user *uarg = argp;\n\t\tstruct blkpg_compat_ioctl_arg compat_arg;\n\t\tstruct blkpg_ioctl_arg a;\n\n\t\tif (copy_from_user(&compat_arg, uarg, sizeof(compat_arg))) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tmemset(&a, 0, sizeof(a));\n\t\ta.op = compat_arg.op;\n\t\ta.flags = compat_arg.flags;\n\t\ta.datalen = compat_arg.datalen;\n\t\ta.data = compat_ptr(compat_arg.data);\n\n\t\tret = mtdchar_blkpg_ioctl(mtd, &a);\n\t\tbreak;\n\t}\n\n\tdefault:\n\t\tret = mtdchar_ioctl(file, cmd, (unsigned long)argp);\n\t}\n\n\tmutex_unlock(&master->master.chrdev_lock);\n\n\treturn ret;\n}\n\n#endif  \n\n \n#ifndef CONFIG_MMU\nstatic unsigned long mtdchar_get_unmapped_area(struct file *file,\n\t\t\t\t\t   unsigned long addr,\n\t\t\t\t\t   unsigned long len,\n\t\t\t\t\t   unsigned long pgoff,\n\t\t\t\t\t   unsigned long flags)\n{\n\tstruct mtd_file_info *mfi = file->private_data;\n\tstruct mtd_info *mtd = mfi->mtd;\n\tunsigned long offset;\n\tint ret;\n\n\tif (addr != 0)\n\t\treturn (unsigned long) -EINVAL;\n\n\tif (len > mtd->size || pgoff >= (mtd->size >> PAGE_SHIFT))\n\t\treturn (unsigned long) -EINVAL;\n\n\toffset = pgoff << PAGE_SHIFT;\n\tif (offset > mtd->size - len)\n\t\treturn (unsigned long) -EINVAL;\n\n\tret = mtd_get_unmapped_area(mtd, len, offset, flags);\n\treturn ret == -EOPNOTSUPP ? -ENODEV : ret;\n}\n\nstatic unsigned mtdchar_mmap_capabilities(struct file *file)\n{\n\tstruct mtd_file_info *mfi = file->private_data;\n\n\treturn mtd_mmap_capabilities(mfi->mtd);\n}\n#endif\n\n \nstatic int mtdchar_mmap(struct file *file, struct vm_area_struct *vma)\n{\n#ifdef CONFIG_MMU\n\tstruct mtd_file_info *mfi = file->private_data;\n\tstruct mtd_info *mtd = mfi->mtd;\n\tstruct map_info *map = mtd->priv;\n\n         \n\tif (0  ) {\n#ifdef pgprot_noncached\n\t\tif (file->f_flags & O_DSYNC || map->phys >= __pa(high_memory))\n\t\t\tvma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);\n#endif\n\t\treturn vm_iomap_memory(vma, map->phys, map->size);\n\t}\n\treturn -ENODEV;\n#else\n\treturn vma->vm_flags & VM_SHARED ? 0 : -EACCES;\n#endif\n}\n\nstatic const struct file_operations mtd_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.llseek\t\t= mtdchar_lseek,\n\t.read\t\t= mtdchar_read,\n\t.write\t\t= mtdchar_write,\n\t.unlocked_ioctl\t= mtdchar_unlocked_ioctl,\n#ifdef CONFIG_COMPAT\n\t.compat_ioctl\t= mtdchar_compat_ioctl,\n#endif\n\t.open\t\t= mtdchar_open,\n\t.release\t= mtdchar_close,\n\t.mmap\t\t= mtdchar_mmap,\n#ifndef CONFIG_MMU\n\t.get_unmapped_area = mtdchar_get_unmapped_area,\n\t.mmap_capabilities = mtdchar_mmap_capabilities,\n#endif\n};\n\nint __init init_mtdchar(void)\n{\n\tint ret;\n\n\tret = __register_chrdev(MTD_CHAR_MAJOR, 0, 1 << MINORBITS,\n\t\t\t\t   \"mtd\", &mtd_fops);\n\tif (ret < 0) {\n\t\tpr_err(\"Can't allocate major number %d for MTD\\n\",\n\t\t       MTD_CHAR_MAJOR);\n\t\treturn ret;\n\t}\n\n\treturn ret;\n}\n\nvoid __exit cleanup_mtdchar(void)\n{\n\t__unregister_chrdev(MTD_CHAR_MAJOR, 0, 1 << MINORBITS, \"mtd\");\n}\n\nMODULE_ALIAS_CHARDEV_MAJOR(MTD_CHAR_MAJOR);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}