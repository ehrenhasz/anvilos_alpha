{
  "module_name": "rpc-if.c",
  "hash_id": "4e0552d40bba023fff26bc6da4317579ad7cb83b52d988f365c53880cc487bcb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/hyperbus/rpc-if.c",
  "human_readable_source": "\n \n\n#include <linux/err.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/mtd/hyperbus.h>\n#include <linux/mtd/mtd.h>\n#include <linux/mux/consumer.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/types.h>\n\n#include <memory/renesas-rpc-if.h>\n\nstruct\trpcif_hyperbus {\n\tstruct rpcif rpc;\n\tstruct hyperbus_ctlr ctlr;\n\tstruct hyperbus_device hbdev;\n};\n\nstatic const struct rpcif_op rpcif_op_tmpl = {\n\t.cmd = {\n\t\t.buswidth = 8,\n\t\t.ddr = true,\n\t},\n\t.ocmd = {\n\t\t.buswidth = 8,\n\t\t.ddr = true,\n\t},\n\t.addr = {\n\t\t.nbytes = 1,\n\t\t.buswidth = 8,\n\t\t.ddr = true,\n\t},\n\t.data = {\n\t\t.buswidth = 8,\n\t\t.ddr = true,\n\t},\n};\n\nstatic void rpcif_hb_prepare_read(struct rpcif *rpc, void *to,\n\t\t\t\t  unsigned long from, ssize_t len)\n{\n\tstruct rpcif_op op = rpcif_op_tmpl;\n\n\top.cmd.opcode = HYPERBUS_RW_READ | HYPERBUS_AS_MEM;\n\top.addr.val = from >> 1;\n\top.dummy.buswidth = 1;\n\top.dummy.ncycles = 15;\n\top.data.dir = RPCIF_DATA_IN;\n\top.data.nbytes = len;\n\top.data.buf.in = to;\n\n\trpcif_prepare(rpc->dev, &op, NULL, NULL);\n}\n\nstatic void rpcif_hb_prepare_write(struct rpcif *rpc, unsigned long to,\n\t\t\t\t   void *from, ssize_t len)\n{\n\tstruct rpcif_op op = rpcif_op_tmpl;\n\n\top.cmd.opcode = HYPERBUS_RW_WRITE | HYPERBUS_AS_MEM;\n\top.addr.val = to >> 1;\n\top.data.dir = RPCIF_DATA_OUT;\n\top.data.nbytes = len;\n\top.data.buf.out = from;\n\n\trpcif_prepare(rpc->dev, &op, NULL, NULL);\n}\n\nstatic u16 rpcif_hb_read16(struct hyperbus_device *hbdev, unsigned long addr)\n{\n\tstruct rpcif_hyperbus *hyperbus =\n\t\tcontainer_of(hbdev, struct rpcif_hyperbus, hbdev);\n\tmap_word data;\n\n\trpcif_hb_prepare_read(&hyperbus->rpc, &data, addr, 2);\n\n\trpcif_manual_xfer(hyperbus->rpc.dev);\n\n\treturn data.x[0];\n}\n\nstatic void rpcif_hb_write16(struct hyperbus_device *hbdev, unsigned long addr,\n\t\t\t     u16 data)\n{\n\tstruct rpcif_hyperbus *hyperbus =\n\t\tcontainer_of(hbdev, struct rpcif_hyperbus, hbdev);\n\n\trpcif_hb_prepare_write(&hyperbus->rpc, addr, &data, 2);\n\n\trpcif_manual_xfer(hyperbus->rpc.dev);\n}\n\nstatic void rpcif_hb_copy_from(struct hyperbus_device *hbdev, void *to,\n\t\t\t       unsigned long from, ssize_t len)\n{\n\tstruct rpcif_hyperbus *hyperbus =\n\t\tcontainer_of(hbdev, struct rpcif_hyperbus, hbdev);\n\n\trpcif_hb_prepare_read(&hyperbus->rpc, to, from, len);\n\n\trpcif_dirmap_read(hyperbus->rpc.dev, from, len, to);\n}\n\nstatic const struct hyperbus_ops rpcif_hb_ops = {\n\t.read16 = rpcif_hb_read16,\n\t.write16 = rpcif_hb_write16,\n\t.copy_from = rpcif_hb_copy_from,\n};\n\nstatic int rpcif_hb_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct rpcif_hyperbus *hyperbus;\n\tint error;\n\n\thyperbus = devm_kzalloc(dev, sizeof(*hyperbus), GFP_KERNEL);\n\tif (!hyperbus)\n\t\treturn -ENOMEM;\n\n\terror = rpcif_sw_init(&hyperbus->rpc, pdev->dev.parent);\n\tif (error)\n\t\treturn error;\n\n\tplatform_set_drvdata(pdev, hyperbus);\n\n\tpm_runtime_enable(hyperbus->rpc.dev);\n\n\terror = rpcif_hw_init(hyperbus->rpc.dev, true);\n\tif (error)\n\t\tgoto out_disable_rpm;\n\n\thyperbus->hbdev.map.size = hyperbus->rpc.size;\n\thyperbus->hbdev.map.virt = hyperbus->rpc.dirmap;\n\n\thyperbus->ctlr.dev = dev;\n\thyperbus->ctlr.ops = &rpcif_hb_ops;\n\thyperbus->hbdev.ctlr = &hyperbus->ctlr;\n\thyperbus->hbdev.np = of_get_next_child(pdev->dev.parent->of_node, NULL);\n\terror = hyperbus_register_device(&hyperbus->hbdev);\n\tif (error)\n\t\tgoto out_disable_rpm;\n\n\treturn 0;\n\nout_disable_rpm:\n\tpm_runtime_disable(hyperbus->rpc.dev);\n\treturn error;\n}\n\nstatic int rpcif_hb_remove(struct platform_device *pdev)\n{\n\tstruct rpcif_hyperbus *hyperbus = platform_get_drvdata(pdev);\n\n\thyperbus_unregister_device(&hyperbus->hbdev);\n\n\tpm_runtime_disable(hyperbus->rpc.dev);\n\n\treturn 0;\n}\n\nstatic struct platform_driver rpcif_platform_driver = {\n\t.probe\t= rpcif_hb_probe,\n\t.remove\t= rpcif_hb_remove,\n\t.driver\t= {\n\t\t.name\t= \"rpc-if-hyperflash\",\n\t},\n};\n\nmodule_platform_driver(rpcif_platform_driver);\n\nMODULE_DESCRIPTION(\"Renesas RPC-IF HyperFlash driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}