{
  "module_name": "hbmc-am654.c",
  "hash_id": "a1e04636975218008e8017c38498e4490560d3e6883edb455714c81efe0f80ec",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/hyperbus/hbmc-am654.c",
  "human_readable_source": "\n\n\n\n\n#include <linux/completion.h>\n#include <linux/dma-direction.h>\n#include <linux/dma-mapping.h>\n#include <linux/dmaengine.h>\n#include <linux/err.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/mtd/cfi.h>\n#include <linux/mtd/hyperbus.h>\n#include <linux/mtd/mtd.h>\n#include <linux/mux/consumer.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/platform_device.h>\n#include <linux/sched/task_stack.h>\n#include <linux/types.h>\n\n#define AM654_HBMC_CALIB_COUNT 25\n\nstruct am654_hbmc_device_priv {\n\tstruct completion rx_dma_complete;\n\tphys_addr_t device_base;\n\tstruct hyperbus_ctlr *ctlr;\n\tstruct dma_chan *rx_chan;\n};\n\nstruct am654_hbmc_priv {\n\tstruct hyperbus_ctlr ctlr;\n\tstruct hyperbus_device hbdev;\n\tstruct mux_control *mux_ctrl;\n};\n\nstatic int am654_hbmc_calibrate(struct hyperbus_device *hbdev)\n{\n\tstruct map_info *map = &hbdev->map;\n\tstruct cfi_private cfi;\n\tint count = AM654_HBMC_CALIB_COUNT;\n\tint pass_count = 0;\n\tint ret;\n\n\tcfi.interleave = 1;\n\tcfi.device_type = CFI_DEVICETYPE_X16;\n\tcfi_send_gen_cmd(0xF0, 0, 0, map, &cfi, cfi.device_type, NULL);\n\tcfi_send_gen_cmd(0x98, 0x55, 0, map, &cfi, cfi.device_type, NULL);\n\n\twhile (count--) {\n\t\tret = cfi_qry_present(map, 0, &cfi);\n\t\tif (ret)\n\t\t\tpass_count++;\n\t\telse\n\t\t\tpass_count = 0;\n\t\tif (pass_count == 5)\n\t\t\tbreak;\n\t}\n\n\tcfi_qry_mode_off(0, map, &cfi);\n\n\treturn ret;\n}\n\nstatic void am654_hbmc_dma_callback(void *param)\n{\n\tstruct am654_hbmc_device_priv *priv = param;\n\n\tcomplete(&priv->rx_dma_complete);\n}\n\nstatic int am654_hbmc_dma_read(struct am654_hbmc_device_priv *priv, void *to,\n\t\t\t       unsigned long from, ssize_t len)\n\n{\n\tenum dma_ctrl_flags flags = DMA_CTRL_ACK | DMA_PREP_INTERRUPT;\n\tstruct dma_chan *rx_chan = priv->rx_chan;\n\tstruct dma_async_tx_descriptor *tx;\n\tdma_addr_t dma_dst, dma_src;\n\tdma_cookie_t cookie;\n\tint ret;\n\n\tif (!priv->rx_chan || !virt_addr_valid(to) || object_is_on_stack(to))\n\t\treturn -EINVAL;\n\n\tdma_dst = dma_map_single(rx_chan->device->dev, to, len, DMA_FROM_DEVICE);\n\tif (dma_mapping_error(rx_chan->device->dev, dma_dst)) {\n\t\tdev_dbg(priv->ctlr->dev, \"DMA mapping failed\\n\");\n\t\treturn -EIO;\n\t}\n\n\tdma_src = priv->device_base + from;\n\ttx = dmaengine_prep_dma_memcpy(rx_chan, dma_dst, dma_src, len, flags);\n\tif (!tx) {\n\t\tdev_err(priv->ctlr->dev, \"device_prep_dma_memcpy error\\n\");\n\t\tret = -EIO;\n\t\tgoto unmap_dma;\n\t}\n\n\treinit_completion(&priv->rx_dma_complete);\n\ttx->callback = am654_hbmc_dma_callback;\n\ttx->callback_param = priv;\n\tcookie = dmaengine_submit(tx);\n\n\tret = dma_submit_error(cookie);\n\tif (ret) {\n\t\tdev_err(priv->ctlr->dev, \"dma_submit_error %d\\n\", cookie);\n\t\tgoto unmap_dma;\n\t}\n\n\tdma_async_issue_pending(rx_chan);\n\tif (!wait_for_completion_timeout(&priv->rx_dma_complete,  msecs_to_jiffies(len + 1000))) {\n\t\tdmaengine_terminate_sync(rx_chan);\n\t\tdev_err(priv->ctlr->dev, \"DMA wait_for_completion_timeout\\n\");\n\t\tret = -ETIMEDOUT;\n\t}\n\nunmap_dma:\n\tdma_unmap_single(rx_chan->device->dev, dma_dst, len, DMA_FROM_DEVICE);\n\treturn ret;\n}\n\nstatic void am654_hbmc_read(struct hyperbus_device *hbdev, void *to,\n\t\t\t    unsigned long from, ssize_t len)\n{\n\tstruct am654_hbmc_device_priv *priv = hbdev->priv;\n\n\tif (len < SZ_1K || am654_hbmc_dma_read(priv, to, from, len))\n\t\tmemcpy_fromio(to, hbdev->map.virt + from, len);\n}\n\nstatic const struct hyperbus_ops am654_hbmc_ops = {\n\t.calibrate = am654_hbmc_calibrate,\n\t.copy_from = am654_hbmc_read,\n};\n\nstatic int am654_hbmc_request_mmap_dma(struct am654_hbmc_device_priv *priv)\n{\n\tstruct dma_chan *rx_chan;\n\tdma_cap_mask_t mask;\n\n\tdma_cap_zero(mask);\n\tdma_cap_set(DMA_MEMCPY, mask);\n\n\trx_chan = dma_request_chan_by_mask(&mask);\n\tif (IS_ERR(rx_chan)) {\n\t\tif (PTR_ERR(rx_chan) == -EPROBE_DEFER)\n\t\t\treturn -EPROBE_DEFER;\n\t\tdev_dbg(priv->ctlr->dev, \"No DMA channel available\\n\");\n\t\treturn 0;\n\t}\n\tpriv->rx_chan = rx_chan;\n\tinit_completion(&priv->rx_dma_complete);\n\n\treturn 0;\n}\n\nstatic int am654_hbmc_probe(struct platform_device *pdev)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct am654_hbmc_device_priv *dev_priv;\n\tstruct device *dev = &pdev->dev;\n\tstruct am654_hbmc_priv *priv;\n\tstruct resource res;\n\tint ret;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, priv);\n\n\tpriv->hbdev.np = of_get_next_child(np, NULL);\n\tret = of_address_to_resource(priv->hbdev.np, 0, &res);\n\tif (ret)\n\t\treturn ret;\n\n\tif (of_property_read_bool(dev->of_node, \"mux-controls\")) {\n\t\tstruct mux_control *control = devm_mux_control_get(dev, NULL);\n\n\t\tif (IS_ERR(control))\n\t\t\treturn PTR_ERR(control);\n\n\t\tret = mux_control_select(control, 1);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"Failed to select HBMC mux\\n\");\n\t\t\treturn ret;\n\t\t}\n\t\tpriv->mux_ctrl = control;\n\t}\n\n\tpriv->hbdev.map.size = resource_size(&res);\n\tpriv->hbdev.map.virt = devm_ioremap_resource(dev, &res);\n\tif (IS_ERR(priv->hbdev.map.virt))\n\t\treturn PTR_ERR(priv->hbdev.map.virt);\n\n\tpriv->ctlr.dev = dev;\n\tpriv->ctlr.ops = &am654_hbmc_ops;\n\tpriv->hbdev.ctlr = &priv->ctlr;\n\n\tdev_priv = devm_kzalloc(dev, sizeof(*dev_priv), GFP_KERNEL);\n\tif (!dev_priv) {\n\t\tret = -ENOMEM;\n\t\tgoto disable_mux;\n\t}\n\n\tpriv->hbdev.priv = dev_priv;\n\tdev_priv->device_base = res.start;\n\tdev_priv->ctlr = &priv->ctlr;\n\n\tret = am654_hbmc_request_mmap_dma(dev_priv);\n\tif (ret)\n\t\tgoto disable_mux;\n\n\tret = hyperbus_register_device(&priv->hbdev);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to register controller\\n\");\n\t\tgoto release_dma;\n\t}\n\n\treturn 0;\nrelease_dma:\n\tif (dev_priv->rx_chan)\n\t\tdma_release_channel(dev_priv->rx_chan);\ndisable_mux:\n\tif (priv->mux_ctrl)\n\t\tmux_control_deselect(priv->mux_ctrl);\n\treturn ret;\n}\n\nstatic int am654_hbmc_remove(struct platform_device *pdev)\n{\n\tstruct am654_hbmc_priv *priv = platform_get_drvdata(pdev);\n\tstruct am654_hbmc_device_priv *dev_priv = priv->hbdev.priv;\n\n\thyperbus_unregister_device(&priv->hbdev);\n\n\tif (priv->mux_ctrl)\n\t\tmux_control_deselect(priv->mux_ctrl);\n\n\tif (dev_priv->rx_chan)\n\t\tdma_release_channel(dev_priv->rx_chan);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id am654_hbmc_dt_ids[] = {\n\t{\n\t\t.compatible = \"ti,am654-hbmc\",\n\t},\n\t{   }\n};\n\nMODULE_DEVICE_TABLE(of, am654_hbmc_dt_ids);\n\nstatic struct platform_driver am654_hbmc_platform_driver = {\n\t.probe = am654_hbmc_probe,\n\t.remove = am654_hbmc_remove,\n\t.driver = {\n\t\t.name = \"hbmc-am654\",\n\t\t.of_match_table = am654_hbmc_dt_ids,\n\t},\n};\n\nmodule_platform_driver(am654_hbmc_platform_driver);\n\nMODULE_DESCRIPTION(\"HBMC driver for AM654 SoC\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"platform:hbmc-am654\");\nMODULE_AUTHOR(\"Vignesh Raghavendra <vigneshr@ti.com>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}