{
  "module_name": "lpddr_cmds.c",
  "hash_id": "9359d28cbe57be92b62ccd40ac1d5ea92ac59513b6f8e2216a778c46317c096c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/lpddr/lpddr_cmds.c",
  "human_readable_source": "\n \n#include <linux/mtd/pfow.h>\n#include <linux/mtd/qinfo.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic int lpddr_read(struct mtd_info *mtd, loff_t adr, size_t len,\n\t\t\t\t\tsize_t *retlen, u_char *buf);\nstatic int lpddr_write_buffers(struct mtd_info *mtd, loff_t to,\n\t\t\t\tsize_t len, size_t *retlen, const u_char *buf);\nstatic int lpddr_writev(struct mtd_info *mtd, const struct kvec *vecs,\n\t\t\t\tunsigned long count, loff_t to, size_t *retlen);\nstatic int lpddr_erase(struct mtd_info *mtd, struct erase_info *instr);\nstatic int lpddr_lock(struct mtd_info *mtd, loff_t ofs, uint64_t len);\nstatic int lpddr_unlock(struct mtd_info *mtd, loff_t ofs, uint64_t len);\nstatic int lpddr_point(struct mtd_info *mtd, loff_t adr, size_t len,\n\t\t\tsize_t *retlen, void **mtdbuf, resource_size_t *phys);\nstatic int lpddr_unpoint(struct mtd_info *mtd, loff_t adr, size_t len);\nstatic int get_chip(struct map_info *map, struct flchip *chip, int mode);\nstatic int chip_ready(struct map_info *map, struct flchip *chip, int mode);\nstatic void put_chip(struct map_info *map, struct flchip *chip);\n\nstruct mtd_info *lpddr_cmdset(struct map_info *map)\n{\n\tstruct lpddr_private *lpddr = map->fldrv_priv;\n\tstruct flchip_shared *shared;\n\tstruct flchip *chip;\n\tstruct mtd_info *mtd;\n\tint numchips;\n\tint i, j;\n\n\tmtd = kzalloc(sizeof(*mtd), GFP_KERNEL);\n\tif (!mtd)\n\t\treturn NULL;\n\tmtd->priv = map;\n\tmtd->type = MTD_NORFLASH;\n\n\t \n\tmtd->_read = lpddr_read;\n\tmtd->type = MTD_NORFLASH;\n\tmtd->flags = MTD_CAP_NORFLASH;\n\tmtd->flags &= ~MTD_BIT_WRITEABLE;\n\tmtd->_erase = lpddr_erase;\n\tmtd->_write = lpddr_write_buffers;\n\tmtd->_writev = lpddr_writev;\n\tmtd->_lock = lpddr_lock;\n\tmtd->_unlock = lpddr_unlock;\n\tif (map_is_linear(map)) {\n\t\tmtd->_point = lpddr_point;\n\t\tmtd->_unpoint = lpddr_unpoint;\n\t}\n\tmtd->size = 1 << lpddr->qinfo->DevSizeShift;\n\tmtd->erasesize = 1 << lpddr->qinfo->UniformBlockSizeShift;\n\tmtd->writesize = 1 << lpddr->qinfo->BufSizeShift;\n\n\tshared = kmalloc_array(lpddr->numchips, sizeof(struct flchip_shared),\n\t\t\t\t\t\tGFP_KERNEL);\n\tif (!shared) {\n\t\tkfree(mtd);\n\t\treturn NULL;\n\t}\n\n\tchip = &lpddr->chips[0];\n\tnumchips = lpddr->numchips / lpddr->qinfo->HWPartsNum;\n\tfor (i = 0; i < numchips; i++) {\n\t\tshared[i].writing = shared[i].erasing = NULL;\n\t\tmutex_init(&shared[i].lock);\n\t\tfor (j = 0; j < lpddr->qinfo->HWPartsNum; j++) {\n\t\t\t*chip = lpddr->chips[i];\n\t\t\tchip->start += j << lpddr->chipshift;\n\t\t\tchip->oldstate = chip->state = FL_READY;\n\t\t\tchip->priv = &shared[i];\n\t\t\t \n\t\t\tinit_waitqueue_head(&chip->wq);\n\t\t\tmutex_init(&chip->mutex);\n\t\t\tchip++;\n\t\t}\n\t}\n\n\treturn mtd;\n}\nEXPORT_SYMBOL(lpddr_cmdset);\n\nstatic void print_drs_error(unsigned int dsr)\n{\n\tint prog_status = (dsr & DSR_RPS) >> 8;\n\n\tif (!(dsr & DSR_AVAILABLE))\n\t\tpr_notice(\"DSR.15: (0) Device not Available\\n\");\n\tif ((prog_status & 0x03) == 0x03)\n\t\tpr_notice(\"DSR.9,8: (11) Attempt to program invalid half with 41h command\\n\");\n\telse if (prog_status & 0x02)\n\t\tpr_notice(\"DSR.9,8: (10) Object Mode Program attempt in region with Control Mode data\\n\");\n\telse if (prog_status &  0x01)\n\t\tpr_notice(\"DSR.9,8: (01) Program attempt in region with Object Mode data\\n\");\n\tif (!(dsr & DSR_READY_STATUS))\n\t\tpr_notice(\"DSR.7: (0) Device is Busy\\n\");\n\tif (dsr & DSR_ESS)\n\t\tpr_notice(\"DSR.6: (1) Erase Suspended\\n\");\n\tif (dsr & DSR_ERASE_STATUS)\n\t\tpr_notice(\"DSR.5: (1) Erase/Blank check error\\n\");\n\tif (dsr & DSR_PROGRAM_STATUS)\n\t\tpr_notice(\"DSR.4: (1) Program Error\\n\");\n\tif (dsr & DSR_VPPS)\n\t\tpr_notice(\"DSR.3: (1) Vpp low detect, operation aborted\\n\");\n\tif (dsr & DSR_PSS)\n\t\tpr_notice(\"DSR.2: (1) Program suspended\\n\");\n\tif (dsr & DSR_DPS)\n\t\tpr_notice(\"DSR.1: (1) Aborted Erase/Program attempt on locked block\\n\");\n}\n\nstatic int wait_for_ready(struct map_info *map, struct flchip *chip,\n\t\tunsigned int chip_op_time)\n{\n\tunsigned int timeo, reset_timeo, sleep_time;\n\tunsigned int dsr;\n\tflstate_t chip_state = chip->state;\n\tint ret = 0;\n\n\t \n\ttimeo = chip_op_time * 8;\n\tif (!timeo)\n\t\ttimeo = 500000;\n\treset_timeo = timeo;\n\tsleep_time = chip_op_time / 2;\n\n\tfor (;;) {\n\t\tdsr = CMDVAL(map_read(map, map->pfow_base + PFOW_DSR));\n\t\tif (dsr & DSR_READY_STATUS)\n\t\t\tbreak;\n\t\tif (!timeo) {\n\t\t\tprintk(KERN_ERR \"%s: Flash timeout error state %d \\n\",\n\t\t\t\t\t\t\tmap->name, chip_state);\n\t\t\tret = -ETIME;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tmutex_unlock(&chip->mutex);\n\t\tif (sleep_time >= 1000000/HZ) {\n\t\t\t \n\t\t\tmsleep(sleep_time/1000);\n\t\t\ttimeo -= sleep_time;\n\t\t\tsleep_time = 1000000/HZ;\n\t\t} else {\n\t\t\tudelay(1);\n\t\t\tcond_resched();\n\t\t\ttimeo--;\n\t\t}\n\t\tmutex_lock(&chip->mutex);\n\n\t\twhile (chip->state != chip_state) {\n\t\t\t \n\t\t\tDECLARE_WAITQUEUE(wait, current);\n\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\tadd_wait_queue(&chip->wq, &wait);\n\t\t\tmutex_unlock(&chip->mutex);\n\t\t\tschedule();\n\t\t\tremove_wait_queue(&chip->wq, &wait);\n\t\t\tmutex_lock(&chip->mutex);\n\t\t}\n\t\tif (chip->erase_suspended || chip->write_suspended)  {\n\t\t\t \n\t\t\ttimeo = reset_timeo;\n\t\t\tchip->erase_suspended = chip->write_suspended = 0;\n\t\t}\n\t}\n\t \n\tif (dsr & DSR_ERR) {\n\t\t \n\t\tmap_write(map, CMD(~(DSR_ERR)), map->pfow_base + PFOW_DSR);\n\t\tprintk(KERN_WARNING\"%s: Bad status on wait: 0x%x \\n\",\n\t\t\t\tmap->name, dsr);\n\t\tprint_drs_error(dsr);\n\t\tret = -EIO;\n\t}\n\tchip->state = FL_READY;\n\treturn ret;\n}\n\nstatic int get_chip(struct map_info *map, struct flchip *chip, int mode)\n{\n\tint ret;\n\tDECLARE_WAITQUEUE(wait, current);\n\n retry:\n\tif (chip->priv && (mode == FL_WRITING || mode == FL_ERASING)\n\t\t&& chip->state != FL_SYNCING) {\n\t\t \n\t\tstruct flchip_shared *shared = chip->priv;\n\t\tstruct flchip *contender;\n\t\tmutex_lock(&shared->lock);\n\t\tcontender = shared->writing;\n\t\tif (contender && contender != chip) {\n\t\t\t \n\t\t\tret = mutex_trylock(&contender->mutex);\n\t\t\tmutex_unlock(&shared->lock);\n\t\t\tif (!ret)\n\t\t\t\tgoto retry;\n\t\t\tmutex_unlock(&chip->mutex);\n\t\t\tret = chip_ready(map, contender, mode);\n\t\t\tmutex_lock(&chip->mutex);\n\n\t\t\tif (ret == -EAGAIN) {\n\t\t\t\tmutex_unlock(&contender->mutex);\n\t\t\t\tgoto retry;\n\t\t\t}\n\t\t\tif (ret) {\n\t\t\t\tmutex_unlock(&contender->mutex);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tmutex_lock(&shared->lock);\n\n\t\t\t \n\t\t\tif (chip->state == FL_SYNCING) {\n\t\t\t\tput_chip(map, contender);\n\t\t\t\tmutex_unlock(&contender->mutex);\n\t\t\t\tgoto retry;\n\t\t\t}\n\t\t\tmutex_unlock(&contender->mutex);\n\t\t}\n\n\t\t \n\t\tif (mode == FL_ERASING && shared->erasing\n\t\t    && shared->erasing->oldstate == FL_ERASING) {\n\t\t\tmutex_unlock(&shared->lock);\n\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\tadd_wait_queue(&chip->wq, &wait);\n\t\t\tmutex_unlock(&chip->mutex);\n\t\t\tschedule();\n\t\t\tremove_wait_queue(&chip->wq, &wait);\n\t\t\tmutex_lock(&chip->mutex);\n\t\t\tgoto retry;\n\t\t}\n\n\t\t \n\t\tshared->writing = chip;\n\t\tif (mode == FL_ERASING)\n\t\t\tshared->erasing = chip;\n\t\tmutex_unlock(&shared->lock);\n\t}\n\n\tret = chip_ready(map, chip, mode);\n\tif (ret == -EAGAIN)\n\t\tgoto retry;\n\n\treturn ret;\n}\n\nstatic int chip_ready(struct map_info *map, struct flchip *chip, int mode)\n{\n\tstruct lpddr_private *lpddr = map->fldrv_priv;\n\tint ret = 0;\n\tDECLARE_WAITQUEUE(wait, current);\n\n\t \n\tif (FL_SYNCING == mode && FL_READY != chip->oldstate)\n\t\tgoto sleep;\n\n\tswitch (chip->state) {\n\tcase FL_READY:\n\tcase FL_JEDEC_QUERY:\n\t\treturn 0;\n\n\tcase FL_ERASING:\n\t\tif (!lpddr->qinfo->SuspEraseSupp ||\n\t\t\t!(mode == FL_READY || mode == FL_POINT))\n\t\t\tgoto sleep;\n\n\t\tmap_write(map, CMD(LPDDR_SUSPEND),\n\t\t\tmap->pfow_base + PFOW_PROGRAM_ERASE_SUSPEND);\n\t\tchip->oldstate = FL_ERASING;\n\t\tchip->state = FL_ERASE_SUSPENDING;\n\t\tret = wait_for_ready(map, chip, 0);\n\t\tif (ret) {\n\t\t\t \n\t\t\t \n\t\t\tput_chip(map, chip);\n\t\t\tprintk(KERN_ERR \"%s: suspend operation failed.\"\n\t\t\t\t\t\"State may be wrong \\n\", map->name);\n\t\t\treturn -EIO;\n\t\t}\n\t\tchip->erase_suspended = 1;\n\t\tchip->state = FL_READY;\n\t\treturn 0;\n\t\t \n\tcase FL_POINT:\n\t\t \n\t\tif (mode == FL_READY && chip->oldstate == FL_READY)\n\t\t\treturn 0;\n\t\tfallthrough;\n\tdefault:\nsleep:\n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\tadd_wait_queue(&chip->wq, &wait);\n\t\tmutex_unlock(&chip->mutex);\n\t\tschedule();\n\t\tremove_wait_queue(&chip->wq, &wait);\n\t\tmutex_lock(&chip->mutex);\n\t\treturn -EAGAIN;\n\t}\n}\n\nstatic void put_chip(struct map_info *map, struct flchip *chip)\n{\n\tif (chip->priv) {\n\t\tstruct flchip_shared *shared = chip->priv;\n\t\tmutex_lock(&shared->lock);\n\t\tif (shared->writing == chip && chip->oldstate == FL_READY) {\n\t\t\t \n\t\t\tshared->writing = shared->erasing;\n\t\t\tif (shared->writing && shared->writing != chip) {\n\t\t\t\t \n\t\t\t\tstruct flchip *loaner = shared->writing;\n\t\t\t\tmutex_lock(&loaner->mutex);\n\t\t\t\tmutex_unlock(&shared->lock);\n\t\t\t\tmutex_unlock(&chip->mutex);\n\t\t\t\tput_chip(map, loaner);\n\t\t\t\tmutex_lock(&chip->mutex);\n\t\t\t\tmutex_unlock(&loaner->mutex);\n\t\t\t\twake_up(&chip->wq);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tshared->erasing = NULL;\n\t\t\tshared->writing = NULL;\n\t\t} else if (shared->erasing == chip && shared->writing != chip) {\n\t\t\t \n\t\t\tmutex_unlock(&shared->lock);\n\t\t\twake_up(&chip->wq);\n\t\t\treturn;\n\t\t}\n\t\tmutex_unlock(&shared->lock);\n\t}\n\n\tswitch (chip->oldstate) {\n\tcase FL_ERASING:\n\t\tmap_write(map, CMD(LPDDR_RESUME),\n\t\t\t\tmap->pfow_base + PFOW_COMMAND_CODE);\n\t\tmap_write(map, CMD(LPDDR_START_EXECUTION),\n\t\t\t\tmap->pfow_base + PFOW_COMMAND_EXECUTE);\n\t\tchip->oldstate = FL_READY;\n\t\tchip->state = FL_ERASING;\n\t\tbreak;\n\tcase FL_READY:\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_ERR \"%s: put_chip() called with oldstate %d!\\n\",\n\t\t\t\tmap->name, chip->oldstate);\n\t}\n\twake_up(&chip->wq);\n}\n\nstatic int do_write_buffer(struct map_info *map, struct flchip *chip,\n\t\t\tunsigned long adr, const struct kvec **pvec,\n\t\t\tunsigned long *pvec_seek, int len)\n{\n\tstruct lpddr_private *lpddr = map->fldrv_priv;\n\tmap_word datum;\n\tint ret, wbufsize, word_gap;\n\tconst struct kvec *vec;\n\tunsigned long vec_seek;\n\tunsigned long prog_buf_ofs;\n\n\twbufsize = 1 << lpddr->qinfo->BufSizeShift;\n\n\tmutex_lock(&chip->mutex);\n\tret = get_chip(map, chip, FL_WRITING);\n\tif (ret) {\n\t\tmutex_unlock(&chip->mutex);\n\t\treturn ret;\n\t}\n\t \n\tword_gap = (-adr & (map_bankwidth(map)-1));\n\tif (word_gap) {\n\t\tword_gap = map_bankwidth(map) - word_gap;\n\t\tadr -= word_gap;\n\t\tdatum = map_word_ff(map);\n\t}\n\t \n\t \n\tprog_buf_ofs = map->pfow_base + CMDVAL(map_read(map,\n\t\t\t\tmap->pfow_base + PFOW_PROGRAM_BUFFER_OFFSET));\n\tvec = *pvec;\n\tvec_seek = *pvec_seek;\n\tdo {\n\t\tint n = map_bankwidth(map) - word_gap;\n\n\t\tif (n > vec->iov_len - vec_seek)\n\t\t\tn = vec->iov_len - vec_seek;\n\t\tif (n > len)\n\t\t\tn = len;\n\n\t\tif (!word_gap && (len < map_bankwidth(map)))\n\t\t\tdatum = map_word_ff(map);\n\n\t\tdatum = map_word_load_partial(map, datum,\n\t\t\t\tvec->iov_base + vec_seek, word_gap, n);\n\n\t\tlen -= n;\n\t\tword_gap += n;\n\t\tif (!len || word_gap == map_bankwidth(map)) {\n\t\t\tmap_write(map, datum, prog_buf_ofs);\n\t\t\tprog_buf_ofs += map_bankwidth(map);\n\t\t\tword_gap = 0;\n\t\t}\n\n\t\tvec_seek += n;\n\t\tif (vec_seek == vec->iov_len) {\n\t\t\tvec++;\n\t\t\tvec_seek = 0;\n\t\t}\n\t} while (len);\n\t*pvec = vec;\n\t*pvec_seek = vec_seek;\n\n\t \n\tsend_pfow_command(map, LPDDR_BUFF_PROGRAM, adr, wbufsize, NULL);\n\tchip->state = FL_WRITING;\n\tret = wait_for_ready(map, chip, (1<<lpddr->qinfo->ProgBufferTime));\n\tif (ret)\t{\n\t\tprintk(KERN_WARNING\"%s Buffer program error: %d at %lx; \\n\",\n\t\t\tmap->name, ret, adr);\n\t\tgoto out;\n\t}\n\n out:\tput_chip(map, chip);\n\tmutex_unlock(&chip->mutex);\n\treturn ret;\n}\n\nstatic int do_erase_oneblock(struct mtd_info *mtd, loff_t adr)\n{\n\tstruct map_info *map = mtd->priv;\n\tstruct lpddr_private *lpddr = map->fldrv_priv;\n\tint chipnum = adr >> lpddr->chipshift;\n\tstruct flchip *chip = &lpddr->chips[chipnum];\n\tint ret;\n\n\tmutex_lock(&chip->mutex);\n\tret = get_chip(map, chip, FL_ERASING);\n\tif (ret) {\n\t\tmutex_unlock(&chip->mutex);\n\t\treturn ret;\n\t}\n\tsend_pfow_command(map, LPDDR_BLOCK_ERASE, adr, 0, NULL);\n\tchip->state = FL_ERASING;\n\tret = wait_for_ready(map, chip, (1<<lpddr->qinfo->BlockEraseTime)*1000);\n\tif (ret) {\n\t\tprintk(KERN_WARNING\"%s Erase block error %d at : %llx\\n\",\n\t\t\tmap->name, ret, adr);\n\t\tgoto out;\n\t}\n out:\tput_chip(map, chip);\n\tmutex_unlock(&chip->mutex);\n\treturn ret;\n}\n\nstatic int lpddr_read(struct mtd_info *mtd, loff_t adr, size_t len,\n\t\t\tsize_t *retlen, u_char *buf)\n{\n\tstruct map_info *map = mtd->priv;\n\tstruct lpddr_private *lpddr = map->fldrv_priv;\n\tint chipnum = adr >> lpddr->chipshift;\n\tstruct flchip *chip = &lpddr->chips[chipnum];\n\tint ret = 0;\n\n\tmutex_lock(&chip->mutex);\n\tret = get_chip(map, chip, FL_READY);\n\tif (ret) {\n\t\tmutex_unlock(&chip->mutex);\n\t\treturn ret;\n\t}\n\n\tmap_copy_from(map, buf, adr, len);\n\t*retlen = len;\n\n\tput_chip(map, chip);\n\tmutex_unlock(&chip->mutex);\n\treturn ret;\n}\n\nstatic int lpddr_point(struct mtd_info *mtd, loff_t adr, size_t len,\n\t\t\tsize_t *retlen, void **mtdbuf, resource_size_t *phys)\n{\n\tstruct map_info *map = mtd->priv;\n\tstruct lpddr_private *lpddr = map->fldrv_priv;\n\tint chipnum = adr >> lpddr->chipshift;\n\tunsigned long ofs, last_end = 0;\n\tstruct flchip *chip = &lpddr->chips[chipnum];\n\tint ret = 0;\n\n\tif (!map->virt)\n\t\treturn -EINVAL;\n\n\t \n\tofs = adr - (chipnum << lpddr->chipshift);\n\t*mtdbuf = (void *)map->virt + chip->start + ofs;\n\n\twhile (len) {\n\t\tunsigned long thislen;\n\n\t\tif (chipnum >= lpddr->numchips)\n\t\t\tbreak;\n\n\t\t \n\t\tif (!last_end)\n\t\t\tlast_end = chip->start;\n\t\telse if (chip->start != last_end)\n\t\t\tbreak;\n\n\t\tif ((len + ofs - 1) >> lpddr->chipshift)\n\t\t\tthislen = (1<<lpddr->chipshift) - ofs;\n\t\telse\n\t\t\tthislen = len;\n\t\t \n\t\tmutex_lock(&chip->mutex);\n\t\tret = get_chip(map, chip, FL_POINT);\n\t\tmutex_unlock(&chip->mutex);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tchip->state = FL_POINT;\n\t\tchip->ref_point_counter++;\n\t\t*retlen += thislen;\n\t\tlen -= thislen;\n\n\t\tofs = 0;\n\t\tlast_end += 1 << lpddr->chipshift;\n\t\tchipnum++;\n\t\tchip = &lpddr->chips[chipnum];\n\t}\n\treturn 0;\n}\n\nstatic int lpddr_unpoint (struct mtd_info *mtd, loff_t adr, size_t len)\n{\n\tstruct map_info *map = mtd->priv;\n\tstruct lpddr_private *lpddr = map->fldrv_priv;\n\tint chipnum = adr >> lpddr->chipshift, err = 0;\n\tunsigned long ofs;\n\n\t \n\tofs = adr - (chipnum << lpddr->chipshift);\n\n\twhile (len) {\n\t\tunsigned long thislen;\n\t\tstruct flchip *chip;\n\n\t\tchip = &lpddr->chips[chipnum];\n\t\tif (chipnum >= lpddr->numchips)\n\t\t\tbreak;\n\n\t\tif ((len + ofs - 1) >> lpddr->chipshift)\n\t\t\tthislen = (1<<lpddr->chipshift) - ofs;\n\t\telse\n\t\t\tthislen = len;\n\n\t\tmutex_lock(&chip->mutex);\n\t\tif (chip->state == FL_POINT) {\n\t\t\tchip->ref_point_counter--;\n\t\t\tif (chip->ref_point_counter == 0)\n\t\t\t\tchip->state = FL_READY;\n\t\t} else {\n\t\t\tprintk(KERN_WARNING \"%s: Warning: unpoint called on non\"\n\t\t\t\t\t\"pointed region\\n\", map->name);\n\t\t\terr = -EINVAL;\n\t\t}\n\n\t\tput_chip(map, chip);\n\t\tmutex_unlock(&chip->mutex);\n\n\t\tlen -= thislen;\n\t\tofs = 0;\n\t\tchipnum++;\n\t}\n\n\treturn err;\n}\n\nstatic int lpddr_write_buffers(struct mtd_info *mtd, loff_t to, size_t len,\n\t\t\t\tsize_t *retlen, const u_char *buf)\n{\n\tstruct kvec vec;\n\n\tvec.iov_base = (void *) buf;\n\tvec.iov_len = len;\n\n\treturn lpddr_writev(mtd, &vec, 1, to, retlen);\n}\n\n\nstatic int lpddr_writev(struct mtd_info *mtd, const struct kvec *vecs,\n\t\t\t\tunsigned long count, loff_t to, size_t *retlen)\n{\n\tstruct map_info *map = mtd->priv;\n\tstruct lpddr_private *lpddr = map->fldrv_priv;\n\tint ret = 0;\n\tint chipnum;\n\tunsigned long ofs, vec_seek, i;\n\tint wbufsize = 1 << lpddr->qinfo->BufSizeShift;\n\tsize_t len = 0;\n\n\tfor (i = 0; i < count; i++)\n\t\tlen += vecs[i].iov_len;\n\n\tif (!len)\n\t\treturn 0;\n\n\tchipnum = to >> lpddr->chipshift;\n\n\tofs = to;\n\tvec_seek = 0;\n\n\tdo {\n\t\t \n\t\tint size = wbufsize - (ofs & (wbufsize-1));\n\n\t\tif (size > len)\n\t\t\tsize = len;\n\n\t\tret = do_write_buffer(map, &lpddr->chips[chipnum],\n\t\t\t\t\t  ofs, &vecs, &vec_seek, size);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tofs += size;\n\t\t(*retlen) += size;\n\t\tlen -= size;\n\n\t\t \n\t\tcond_resched();\n\n\t} while (len);\n\n\treturn 0;\n}\n\nstatic int lpddr_erase(struct mtd_info *mtd, struct erase_info *instr)\n{\n\tunsigned long ofs, len;\n\tint ret;\n\tstruct map_info *map = mtd->priv;\n\tstruct lpddr_private *lpddr = map->fldrv_priv;\n\tint size = 1 << lpddr->qinfo->UniformBlockSizeShift;\n\n\tofs = instr->addr;\n\tlen = instr->len;\n\n\twhile (len > 0) {\n\t\tret = do_erase_oneblock(mtd, ofs);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tofs += size;\n\t\tlen -= size;\n\t}\n\n\treturn 0;\n}\n\n#define DO_XXLOCK_LOCK\t\t1\n#define DO_XXLOCK_UNLOCK\t2\nstatic int do_xxlock(struct mtd_info *mtd, loff_t adr, uint32_t len, int thunk)\n{\n\tint ret = 0;\n\tstruct map_info *map = mtd->priv;\n\tstruct lpddr_private *lpddr = map->fldrv_priv;\n\tint chipnum = adr >> lpddr->chipshift;\n\tstruct flchip *chip = &lpddr->chips[chipnum];\n\n\tmutex_lock(&chip->mutex);\n\tret = get_chip(map, chip, FL_LOCKING);\n\tif (ret) {\n\t\tmutex_unlock(&chip->mutex);\n\t\treturn ret;\n\t}\n\n\tif (thunk == DO_XXLOCK_LOCK) {\n\t\tsend_pfow_command(map, LPDDR_LOCK_BLOCK, adr, adr + len, NULL);\n\t\tchip->state = FL_LOCKING;\n\t} else if (thunk == DO_XXLOCK_UNLOCK) {\n\t\tsend_pfow_command(map, LPDDR_UNLOCK_BLOCK, adr, adr + len, NULL);\n\t\tchip->state = FL_UNLOCKING;\n\t} else\n\t\tBUG();\n\n\tret = wait_for_ready(map, chip, 1);\n\tif (ret)\t{\n\t\tprintk(KERN_ERR \"%s: block unlock error status %d \\n\",\n\t\t\t\tmap->name, ret);\n\t\tgoto out;\n\t}\nout:\tput_chip(map, chip);\n\tmutex_unlock(&chip->mutex);\n\treturn ret;\n}\n\nstatic int lpddr_lock(struct mtd_info *mtd, loff_t ofs, uint64_t len)\n{\n\treturn do_xxlock(mtd, ofs, len, DO_XXLOCK_LOCK);\n}\n\nstatic int lpddr_unlock(struct mtd_info *mtd, loff_t ofs, uint64_t len)\n{\n\treturn do_xxlock(mtd, ofs, len, DO_XXLOCK_UNLOCK);\n}\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Alexey Korolev <akorolev@infradead.org>\");\nMODULE_DESCRIPTION(\"MTD driver for LPDDR flash chips\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}