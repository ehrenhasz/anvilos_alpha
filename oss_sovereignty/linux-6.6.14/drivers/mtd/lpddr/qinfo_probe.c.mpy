{
  "module_name": "qinfo_probe.c",
  "hash_id": "f9d40851977e9ed7573a6d907f6ed1c4daf33ead467e8f86f7a952b19a8fd7de",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/lpddr/qinfo_probe.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n\n#include <linux/mtd/xip.h>\n#include <linux/mtd/map.h>\n#include <linux/mtd/pfow.h>\n#include <linux/mtd/qinfo.h>\n\nstatic int lpddr_chip_setup(struct map_info *map, struct lpddr_private *lpddr);\nstruct mtd_info *lpddr_probe(struct map_info *map);\nstatic struct lpddr_private *lpddr_probe_chip(struct map_info *map);\nstatic int lpddr_pfow_present(struct map_info *map,\n\t\t\tstruct lpddr_private *lpddr);\n\nstatic struct qinfo_query_info qinfo_array[] = {\n\t \n\t{0, 0, \"DevSizeShift\", \"Device size 2^n bytes\"},\n\t{0, 3, \"BufSizeShift\", \"Program buffer size 2^n bytes\"},\n\t \n\t{1, 1, \"TotalBlocksNum\", \"Total number of blocks\"},\n\t{1, 2, \"UniformBlockSizeShift\", \"Uniform block size 2^n bytes\"},\n\t \n\t{2, 1, \"HWPartsNum\", \"Number of hardware partitions\"},\n\t \n\t{5, 1, \"SuspEraseSupp\", \"Suspend erase supported\"},\n\t \n\t{10, 0, \"SingleWordProgTime\", \"Single word program 2^n u-sec\"},\n\t{10, 1, \"ProgBufferTime\", \"Program buffer write 2^n u-sec\"},\n\t{10, 2, \"BlockEraseTime\", \"Block erase 2^n m-sec\"},\n\t{10, 3, \"FullChipEraseTime\", \"Full chip erase 2^n m-sec\"},\n};\n\nstatic long lpddr_get_qinforec_pos(struct map_info *map, char *id_str)\n{\n\tint qinfo_lines = ARRAY_SIZE(qinfo_array);\n\tint i;\n\tint bankwidth = map_bankwidth(map) * 8;\n\tint major, minor;\n\n\tfor (i = 0; i < qinfo_lines; i++) {\n\t\tif (strcmp(id_str, qinfo_array[i].id_str) == 0) {\n\t\t\tmajor = qinfo_array[i].major & ((1 << bankwidth) - 1);\n\t\t\tminor = qinfo_array[i].minor & ((1 << bankwidth) - 1);\n\t\t\treturn minor | (major << bankwidth);\n\t\t}\n\t}\n\tprintk(KERN_ERR\"%s qinfo id string is wrong! \\n\", map->name);\n\tBUG();\n\treturn -1;\n}\n\nstatic uint16_t lpddr_info_query(struct map_info *map, char *id_str)\n{\n\tunsigned int dsr, val;\n\tint bits_per_chip = map_bankwidth(map) * 8;\n\tunsigned long adr = lpddr_get_qinforec_pos(map, id_str);\n\tint attempts = 20;\n\n\t \n\tmap_write(map, CMD(LPDDR_INFO_QUERY),\n\t\t\tmap->pfow_base + PFOW_COMMAND_CODE);\n\tmap_write(map, CMD(adr & ((1 << bits_per_chip) - 1)),\n\t\t\tmap->pfow_base + PFOW_COMMAND_ADDRESS_L);\n\tmap_write(map, CMD(adr >> bits_per_chip),\n\t\t\tmap->pfow_base + PFOW_COMMAND_ADDRESS_H);\n\tmap_write(map, CMD(LPDDR_START_EXECUTION),\n\t\t\tmap->pfow_base + PFOW_COMMAND_EXECUTE);\n\n\twhile ((attempts--) > 0) {\n\t\tdsr = CMDVAL(map_read(map, map->pfow_base + PFOW_DSR));\n\t\tif (dsr & DSR_READY_STATUS)\n\t\t\tbreak;\n\t\tudelay(10);\n\t}\n\n\tval = CMDVAL(map_read(map, map->pfow_base + PFOW_COMMAND_DATA));\n\treturn val;\n}\n\nstatic int lpddr_pfow_present(struct map_info *map, struct lpddr_private *lpddr)\n{\n\tmap_word pfow_val[4];\n\n\t \n\tpfow_val[0] = map_read(map, map->pfow_base + PFOW_QUERY_STRING_P);\n\tpfow_val[1] = map_read(map, map->pfow_base + PFOW_QUERY_STRING_F);\n\tpfow_val[2] = map_read(map, map->pfow_base + PFOW_QUERY_STRING_O);\n\tpfow_val[3] = map_read(map, map->pfow_base + PFOW_QUERY_STRING_W);\n\n\tif (!map_word_equal(map, CMD('P'), pfow_val[0]))\n\t\tgoto out;\n\n\tif (!map_word_equal(map, CMD('F'), pfow_val[1]))\n\t\tgoto out;\n\n\tif (!map_word_equal(map, CMD('O'), pfow_val[2]))\n\t\tgoto out;\n\n\tif (!map_word_equal(map, CMD('W'), pfow_val[3]))\n\t\tgoto out;\n\n\treturn 1;\t \nout:\n\tprintk(KERN_WARNING\"%s: PFOW string at 0x%lx is not found \\n\",\n\t\t\t\t\tmap->name, map->pfow_base);\n\treturn 0;\n}\n\nstatic int lpddr_chip_setup(struct map_info *map, struct lpddr_private *lpddr)\n{\n\n\tlpddr->qinfo = kzalloc(sizeof(struct qinfo_chip), GFP_KERNEL);\n\tif (!lpddr->qinfo)\n\t\treturn 0;\n\n\t \n\tlpddr->ManufactId = CMDVAL(map_read(map, map->pfow_base + PFOW_MANUFACTURER_ID));\n\t \n\tlpddr->DevId = CMDVAL(map_read(map, map->pfow_base + PFOW_DEVICE_ID));\n\t \n\tlpddr->qinfo->DevSizeShift = lpddr_info_query(map, \"DevSizeShift\");\n\tlpddr->qinfo->TotalBlocksNum = lpddr_info_query(map, \"TotalBlocksNum\");\n\tlpddr->qinfo->BufSizeShift = lpddr_info_query(map, \"BufSizeShift\");\n\tlpddr->qinfo->HWPartsNum = lpddr_info_query(map, \"HWPartsNum\");\n\tlpddr->qinfo->UniformBlockSizeShift =\n\t\t\t\tlpddr_info_query(map, \"UniformBlockSizeShift\");\n\tlpddr->qinfo->SuspEraseSupp = lpddr_info_query(map, \"SuspEraseSupp\");\n\tlpddr->qinfo->SingleWordProgTime =\n\t\t\t\tlpddr_info_query(map, \"SingleWordProgTime\");\n\tlpddr->qinfo->ProgBufferTime = lpddr_info_query(map, \"ProgBufferTime\");\n\tlpddr->qinfo->BlockEraseTime = lpddr_info_query(map, \"BlockEraseTime\");\n\treturn 1;\n}\nstatic struct lpddr_private *lpddr_probe_chip(struct map_info *map)\n{\n\tstruct lpddr_private lpddr;\n\tstruct lpddr_private *retlpddr;\n\tint numvirtchips;\n\n\n\tif ((map->pfow_base + 0x1000) >= map->size) {\n\t\tprintk(KERN_NOTICE\"%s Probe at base (0x%08lx) past the end of\"\n\t\t\t\t\"the map(0x%08lx)\\n\", map->name,\n\t\t\t\t(unsigned long)map->pfow_base, map->size - 1);\n\t\treturn NULL;\n\t}\n\tmemset(&lpddr, 0, sizeof(struct lpddr_private));\n\tif (!lpddr_pfow_present(map, &lpddr))\n\t\treturn NULL;\n\n\tif (!lpddr_chip_setup(map, &lpddr))\n\t\treturn NULL;\n\n\t \n\tlpddr.chipshift = lpddr.qinfo->DevSizeShift;\n\tlpddr.numchips = 1;\n\n\tnumvirtchips = lpddr.numchips * lpddr.qinfo->HWPartsNum;\n\tretlpddr = kzalloc(struct_size(retlpddr, chips, numvirtchips),\n\t\t\t   GFP_KERNEL);\n\tif (!retlpddr)\n\t\treturn NULL;\n\n\tmemcpy(retlpddr, &lpddr, sizeof(struct lpddr_private));\n\n\tretlpddr->numchips = numvirtchips;\n\tretlpddr->chipshift = retlpddr->qinfo->DevSizeShift -\n\t\t\t\t__ffs(retlpddr->qinfo->HWPartsNum);\n\n\treturn retlpddr;\n}\n\nstruct mtd_info *lpddr_probe(struct map_info *map)\n{\n\tstruct mtd_info *mtd = NULL;\n\tstruct lpddr_private *lpddr;\n\n\t \n\tlpddr = lpddr_probe_chip(map);\n\tif (!lpddr)\n\t\treturn NULL;\n\n\tmap->fldrv_priv = lpddr;\n\tmtd = lpddr_cmdset(map);\n\tif (mtd) {\n\t\tif (mtd->size > map->size) {\n\t\t\tprintk(KERN_WARNING \"Reducing visibility of %ldKiB chip\"\n\t\t\t\t\"to %ldKiB\\n\", (unsigned long)mtd->size >> 10,\n\t\t\t\t(unsigned long)map->size >> 10);\n\t\t\tmtd->size = map->size;\n\t\t}\n\t\treturn mtd;\n\t}\n\n\tkfree(lpddr->qinfo);\n\tkfree(lpddr);\n\tmap->fldrv_priv = NULL;\n\treturn NULL;\n}\n\nstatic struct mtd_chip_driver lpddr_chipdrv = {\n\t.probe\t\t= lpddr_probe,\n\t.name\t\t= \"qinfo_probe\",\n\t.module\t\t= THIS_MODULE\n};\n\nstatic int __init lpddr_probe_init(void)\n{\n\tregister_mtd_chip_driver(&lpddr_chipdrv);\n\treturn 0;\n}\n\nstatic void __exit lpddr_probe_exit(void)\n{\n\tunregister_mtd_chip_driver(&lpddr_chipdrv);\n}\n\nmodule_init(lpddr_probe_init);\nmodule_exit(lpddr_probe_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Vasiliy Leonenko <vasiliy.leonenko@gmail.com>\");\nMODULE_DESCRIPTION(\"Driver to probe qinfo flash chips\");\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}