{
  "module_name": "lpddr2_nvm.c",
  "hash_id": "969a074d95ea45c5c6bc71b4a350c8153a485d1ab22f53b74e8d140e5887a86e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/lpddr/lpddr2_nvm.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": %s: \" fmt, __func__\n\n#include <linux/init.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/mtd/map.h>\n#include <linux/mtd/mtd.h>\n#include <linux/mtd/partitions.h>\n#include <linux/slab.h>\n#include <linux/platform_device.h>\n#include <linux/ioport.h>\n#include <linux/err.h>\n\n \n#define ERASE_BLOCKSIZE\t\t\t(0x00020000/2)\t \n#define WRITE_BUFFSIZE\t\t\t(0x00000400/2)\t \n#define OW_BASE_ADDRESS\t\t\t0x00000000\t \n#define BUS_WIDTH\t\t\t0x00000020\t \n\n \n#define PFOW_QUERY_STRING_P\t\t(0x0000/2)\t \n#define PFOW_QUERY_STRING_F\t\t(0x0002/2)\t \n#define PFOW_QUERY_STRING_O\t\t(0x0004/2)\t \n#define PFOW_QUERY_STRING_W\t\t(0x0006/2)\t \n\n \n#define CMD_CODE_OFS\t\t\t(0x0080/2)\t \n#define CMD_DATA_OFS\t\t\t(0x0084/2)\t \n#define CMD_ADD_L_OFS\t\t\t(0x0088/2)\t \n#define CMD_ADD_H_OFS\t\t\t(0x008A/2)\t \n#define MPR_L_OFS\t\t\t(0x0090/2)\t \n#define MPR_H_OFS\t\t\t(0x0092/2)\t \n#define CMD_EXEC_OFS\t\t\t(0x00C0/2)\t \n#define STATUS_REG_OFS\t\t\t(0x00CC/2)\t \n#define PRG_BUFFER_OFS\t\t\t(0x0010/2)\t \n\n \n#define MR_CFGMASK\t\t\t0x8000\n#define SR_OK_DATAMASK\t\t\t0x0080\n\n \n#define LPDDR2_NVM_LOCK\t\t\t0x0061\n#define LPDDR2_NVM_UNLOCK\t\t0x0062\n#define LPDDR2_NVM_SW_PROGRAM\t\t0x0041\n#define LPDDR2_NVM_SW_OVERWRITE\t\t0x0042\n#define LPDDR2_NVM_BUF_PROGRAM\t\t0x00E9\n#define LPDDR2_NVM_BUF_OVERWRITE\t0x00EA\n#define LPDDR2_NVM_ERASE\t\t0x0020\n\n \n#define LPDDR2_MODE_REG_DATA\t\t0x0040\n#define LPDDR2_MODE_REG_CFG\t\t0x0050\n\n \nstruct pcm_int_data {\n\tvoid __iomem *ctl_regs;\n\tint bus_width;\n};\n\nstatic DEFINE_MUTEX(lpdd2_nvm_mutex);\n\n \nstatic inline map_word build_map_word(u_long myword)\n{\n\tmap_word val = { {0} };\n\tval.x[0] = myword;\n\treturn val;\n}\n\n \nstatic inline u_int build_mr_cfgmask(u_int bus_width)\n{\n\tu_int val = MR_CFGMASK;\n\n\tif (bus_width == 0x0004)\t\t \n\t\tval = val << 16;\n\n\treturn val;\n}\n\n \nstatic inline u_int build_sr_ok_datamask(u_int bus_width)\n{\n\tu_int val = SR_OK_DATAMASK;\n\n\tif (bus_width == 0x0004)\t\t \n\t\tval = (val << 16)+val;\n\n\treturn val;\n}\n\n \nstatic inline u_long ow_reg_add(struct map_info *map, u_long offset)\n{\n\tu_long val = 0;\n\tstruct pcm_int_data *pcm_data = map->fldrv_priv;\n\n\tval = map->pfow_base + offset*pcm_data->bus_width;\n\n\treturn val;\n}\n\n \nstatic inline void ow_enable(struct map_info *map)\n{\n\tstruct pcm_int_data *pcm_data = map->fldrv_priv;\n\n\twritel_relaxed(build_mr_cfgmask(pcm_data->bus_width) | 0x18,\n\t\tpcm_data->ctl_regs + LPDDR2_MODE_REG_CFG);\n\twritel_relaxed(0x01, pcm_data->ctl_regs + LPDDR2_MODE_REG_DATA);\n}\n\n \nstatic inline void ow_disable(struct map_info *map)\n{\n\tstruct pcm_int_data *pcm_data = map->fldrv_priv;\n\n\twritel_relaxed(build_mr_cfgmask(pcm_data->bus_width) | 0x18,\n\t\tpcm_data->ctl_regs + LPDDR2_MODE_REG_CFG);\n\twritel_relaxed(0x02, pcm_data->ctl_regs + LPDDR2_MODE_REG_DATA);\n}\n\n \nstatic int lpddr2_nvm_do_op(struct map_info *map, u_long cmd_code,\n\tu_long cmd_data, u_long cmd_add, u_long cmd_mpr, u_char *buf)\n{\n\tmap_word add_l = { {0} }, add_h = { {0} }, mpr_l = { {0} },\n\t\tmpr_h = { {0} }, data_l = { {0} }, cmd = { {0} },\n\t\texec_cmd = { {0} }, sr;\n\tmap_word data_h = { {0} };\t \n\tu_long i, status_reg, prg_buff_ofs;\n\tstruct pcm_int_data *pcm_data = map->fldrv_priv;\n\tu_int sr_ok_datamask = build_sr_ok_datamask(pcm_data->bus_width);\n\n\t \n\tadd_l.x[0]\t= cmd_add & 0x0000FFFF;\n\tadd_h.x[0]\t= (cmd_add >> 16) & 0x0000FFFF;\n\tmpr_l.x[0]\t= cmd_mpr & 0x0000FFFF;\n\tmpr_h.x[0]\t= (cmd_mpr >> 16) & 0x0000FFFF;\n\tcmd.x[0]\t= cmd_code & 0x0000FFFF;\n\texec_cmd.x[0]\t= 0x0001;\n\tdata_l.x[0]\t= cmd_data & 0x0000FFFF;\n\tdata_h.x[0]\t= (cmd_data >> 16) & 0x0000FFFF;  \n\n\t \n\tmap_write(map, cmd, ow_reg_add(map, CMD_CODE_OFS));\n\tmap_write(map, data_l, ow_reg_add(map, CMD_DATA_OFS));\n\tmap_write(map, add_l, ow_reg_add(map, CMD_ADD_L_OFS));\n\tmap_write(map, add_h, ow_reg_add(map, CMD_ADD_H_OFS));\n\tmap_write(map, mpr_l, ow_reg_add(map, MPR_L_OFS));\n\tmap_write(map, mpr_h, ow_reg_add(map, MPR_H_OFS));\n\tif (pcm_data->bus_width == 0x0004) {\t \n\t\tmap_write(map, cmd, ow_reg_add(map, CMD_CODE_OFS) + 2);\n\t\tmap_write(map, data_h, ow_reg_add(map, CMD_DATA_OFS) + 2);\n\t\tmap_write(map, add_l, ow_reg_add(map, CMD_ADD_L_OFS) + 2);\n\t\tmap_write(map, add_h, ow_reg_add(map, CMD_ADD_H_OFS) + 2);\n\t\tmap_write(map, mpr_l, ow_reg_add(map, MPR_L_OFS) + 2);\n\t\tmap_write(map, mpr_h, ow_reg_add(map, MPR_H_OFS) + 2);\n\t}\n\n\t \n\tif ((cmd_code == LPDDR2_NVM_BUF_PROGRAM) ||\n\t\t(cmd_code == LPDDR2_NVM_BUF_OVERWRITE)) {\n\t\tprg_buff_ofs = (map_read(map,\n\t\t\tow_reg_add(map, PRG_BUFFER_OFS))).x[0];\n\t\tfor (i = 0; i < cmd_mpr; i++) {\n\t\t\tmap_write(map, build_map_word(buf[i]), map->pfow_base +\n\t\t\tprg_buff_ofs + i);\n\t\t}\n\t}\n\n\t \n\tmap_write(map, exec_cmd, ow_reg_add(map, CMD_EXEC_OFS));\n\tif (pcm_data->bus_width == 0x0004)\t \n\t\tmap_write(map, exec_cmd, ow_reg_add(map, CMD_EXEC_OFS) + 2);\n\n\t \n\tdo {\n\t\tsr = map_read(map, ow_reg_add(map, STATUS_REG_OFS));\n\t\tstatus_reg = sr.x[0];\n\t\tif (pcm_data->bus_width == 0x0004) { \n\t\t\tsr = map_read(map, ow_reg_add(map,\n\t\t\t\tSTATUS_REG_OFS) + 2);\n\t\t\tstatus_reg += sr.x[0] << 16;\n\t\t}\n\t} while ((status_reg & sr_ok_datamask) != sr_ok_datamask);\n\n\treturn (((status_reg & sr_ok_datamask) == sr_ok_datamask) ? 0 : -EIO);\n}\n\n \nstatic int lpddr2_nvm_do_block_op(struct mtd_info *mtd, loff_t start_add,\n\tuint64_t len, u_char block_op)\n{\n\tstruct map_info *map = mtd->priv;\n\tu_long add, end_add;\n\tint ret = 0;\n\n\tmutex_lock(&lpdd2_nvm_mutex);\n\n\tow_enable(map);\n\n\tadd = start_add;\n\tend_add = add + len;\n\n\tdo {\n\t\tret = lpddr2_nvm_do_op(map, block_op, 0x00, add, add, NULL);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tadd += mtd->erasesize;\n\t} while (add < end_add);\n\nout:\n\tow_disable(map);\n\tmutex_unlock(&lpdd2_nvm_mutex);\n\treturn ret;\n}\n\n \nstatic int lpddr2_nvm_pfow_present(struct map_info *map)\n{\n\tmap_word pfow_val[4];\n\tunsigned int found = 1;\n\n\tmutex_lock(&lpdd2_nvm_mutex);\n\n\tow_enable(map);\n\n\t \n\tpfow_val[0] = map_read(map, ow_reg_add(map, PFOW_QUERY_STRING_P));\n\tpfow_val[1] = map_read(map, ow_reg_add(map, PFOW_QUERY_STRING_F));\n\tpfow_val[2] = map_read(map, ow_reg_add(map, PFOW_QUERY_STRING_O));\n\tpfow_val[3] = map_read(map, ow_reg_add(map, PFOW_QUERY_STRING_W));\n\n\t \n\tif (!map_word_equal(map, build_map_word('P'), pfow_val[0]))\n\t\tfound = 0;\n\tif (!map_word_equal(map, build_map_word('F'), pfow_val[1]))\n\t\tfound = 0;\n\tif (!map_word_equal(map, build_map_word('O'), pfow_val[2]))\n\t\tfound = 0;\n\tif (!map_word_equal(map, build_map_word('W'), pfow_val[3]))\n\t\tfound = 0;\n\n\tow_disable(map);\n\n\tmutex_unlock(&lpdd2_nvm_mutex);\n\n\treturn found;\n}\n\n \nstatic int lpddr2_nvm_read(struct mtd_info *mtd, loff_t start_add,\n\t\t\t\tsize_t len, size_t *retlen, u_char *buf)\n{\n\tstruct map_info *map = mtd->priv;\n\n\tmutex_lock(&lpdd2_nvm_mutex);\n\n\t*retlen = len;\n\n\tmap_copy_from(map, buf, start_add, *retlen);\n\n\tmutex_unlock(&lpdd2_nvm_mutex);\n\treturn 0;\n}\n\n \nstatic int lpddr2_nvm_write(struct mtd_info *mtd, loff_t start_add,\n\t\t\t\tsize_t len, size_t *retlen, const u_char *buf)\n{\n\tstruct map_info *map = mtd->priv;\n\tstruct pcm_int_data *pcm_data = map->fldrv_priv;\n\tu_long add, current_len, tot_len, target_len, my_data;\n\tu_char *write_buf = (u_char *)buf;\n\tint ret = 0;\n\n\tmutex_lock(&lpdd2_nvm_mutex);\n\n\tow_enable(map);\n\n\t \n\tadd = start_add;\n\ttarget_len = len;\n\ttot_len = 0;\n\n\twhile (tot_len < target_len) {\n\t\tif (!(IS_ALIGNED(add, mtd->writesize))) {  \n\t\t\tmy_data = write_buf[tot_len];\n\t\t\tmy_data += (write_buf[tot_len+1]) << 8;\n\t\t\tif (pcm_data->bus_width == 0x0004) { \n\t\t\t\tmy_data += (write_buf[tot_len+2]) << 16;\n\t\t\t\tmy_data += (write_buf[tot_len+3]) << 24;\n\t\t\t}\n\t\t\tret = lpddr2_nvm_do_op(map, LPDDR2_NVM_SW_OVERWRITE,\n\t\t\t\tmy_data, add, 0x00, NULL);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\n\t\t\tadd += pcm_data->bus_width;\n\t\t\ttot_len += pcm_data->bus_width;\n\t\t} else {\t\t \n\t\t\tcurrent_len = min(target_len - tot_len,\n\t\t\t\t(u_long) mtd->writesize);\n\t\t\tret = lpddr2_nvm_do_op(map, LPDDR2_NVM_BUF_OVERWRITE,\n\t\t\t\t0x00, add, current_len, write_buf + tot_len);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\n\t\t\tadd += current_len;\n\t\t\ttot_len += current_len;\n\t\t}\n\t}\n\nout:\n\t*retlen = tot_len;\n\tow_disable(map);\n\tmutex_unlock(&lpdd2_nvm_mutex);\n\treturn ret;\n}\n\n \nstatic int lpddr2_nvm_erase(struct mtd_info *mtd, struct erase_info *instr)\n{\n\treturn lpddr2_nvm_do_block_op(mtd, instr->addr, instr->len,\n\t\t\t\t      LPDDR2_NVM_ERASE);\n}\n\n \nstatic int lpddr2_nvm_unlock(struct mtd_info *mtd, loff_t start_add,\n\tuint64_t len)\n{\n\treturn lpddr2_nvm_do_block_op(mtd, start_add, len, LPDDR2_NVM_UNLOCK);\n}\n\n \nstatic int lpddr2_nvm_lock(struct mtd_info *mtd, loff_t start_add,\n\tuint64_t len)\n{\n\treturn lpddr2_nvm_do_block_op(mtd, start_add, len, LPDDR2_NVM_LOCK);\n}\n\nstatic const struct mtd_info lpddr2_nvm_mtd_info = {\n\t.type\t\t= MTD_RAM,\n\t.writesize\t= 1,\n\t.flags\t\t= (MTD_CAP_NVRAM | MTD_POWERUP_LOCK),\n\t._read\t\t= lpddr2_nvm_read,\n\t._write\t\t= lpddr2_nvm_write,\n\t._erase\t\t= lpddr2_nvm_erase,\n\t._unlock\t= lpddr2_nvm_unlock,\n\t._lock\t\t= lpddr2_nvm_lock,\n};\n\n \nstatic int lpddr2_nvm_probe(struct platform_device *pdev)\n{\n\tstruct map_info *map;\n\tstruct mtd_info *mtd;\n\tstruct resource *add_range;\n\tstruct pcm_int_data *pcm_data;\n\n\t \n\tpcm_data = devm_kzalloc(&pdev->dev, sizeof(*pcm_data), GFP_KERNEL);\n\tif (!pcm_data)\n\t\treturn -ENOMEM;\n\n\tpcm_data->bus_width = BUS_WIDTH;\n\n\t \n\tmap = devm_kzalloc(&pdev->dev, sizeof(*map), GFP_KERNEL);\n\tif (!map)\n\t\treturn -ENOMEM;\n\n\tmtd = devm_kzalloc(&pdev->dev, sizeof(*mtd), GFP_KERNEL);\n\tif (!mtd)\n\t\treturn -ENOMEM;\n\n\t \n\tadd_range = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!add_range)\n\t\treturn -ENODEV;\n\n\t \n\t*map = (struct map_info) {\n\t\t.virt\t\t= devm_ioremap_resource(&pdev->dev, add_range),\n\t\t.name\t\t= pdev->dev.init_name,\n\t\t.phys\t\t= add_range->start,\n\t\t.size\t\t= resource_size(add_range),\n\t\t.bankwidth\t= pcm_data->bus_width / 2,\n\t\t.pfow_base\t= OW_BASE_ADDRESS,\n\t\t.fldrv_priv\t= pcm_data,\n\t};\n\n\tif (IS_ERR(map->virt))\n\t\treturn PTR_ERR(map->virt);\n\n\tsimple_map_init(map);\t \n\n\tpcm_data->ctl_regs = devm_platform_ioremap_resource(pdev, 1);\n\tif (IS_ERR(pcm_data->ctl_regs))\n\t\treturn PTR_ERR(pcm_data->ctl_regs);\n\n\t \n\t*mtd = lpddr2_nvm_mtd_info;\n\tmtd->dev.parent\t\t= &pdev->dev;\n\tmtd->name\t\t= pdev->dev.init_name;\n\tmtd->priv\t\t= map;\n\tmtd->size\t\t= resource_size(add_range);\n\tmtd->erasesize\t\t= ERASE_BLOCKSIZE * pcm_data->bus_width;\n\tmtd->writebufsize\t= WRITE_BUFFSIZE * pcm_data->bus_width;\n\n\t \n\tif (!lpddr2_nvm_pfow_present(map)) {\n\t\tpr_err(\"device not recognized\\n\");\n\t\treturn -EINVAL;\n\t}\n\t \n\treturn mtd_device_register(mtd, NULL, 0);\n}\n\n \nstatic int lpddr2_nvm_remove(struct platform_device *pdev)\n{\n\tWARN_ON(mtd_device_unregister(dev_get_drvdata(&pdev->dev)));\n\n\treturn 0;\n}\n\n \nstatic struct platform_driver lpddr2_nvm_drv = {\n\t.driver\t\t= {\n\t\t.name\t= \"lpddr2_nvm\",\n\t},\n\t.probe\t\t= lpddr2_nvm_probe,\n\t.remove\t\t= lpddr2_nvm_remove,\n};\n\nmodule_platform_driver(lpddr2_nvm_drv);\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Vincenzo Aliberti <vincenzo.aliberti@gmail.com>\");\nMODULE_DESCRIPTION(\"MTD driver for LPDDR2-NVM PCM memories\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}