{
  "module_name": "misc.c",
  "hash_id": "9deccf0398e2f73d7d344dfa3a34ae324c2ac233ce727c276d4c43033bef2014",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/ubi/misc.c",
  "human_readable_source": "\n \n\n \n\n#include \"ubi.h\"\n\n \nint ubi_calc_data_len(const struct ubi_device *ubi, const void *buf,\n\t\t      int length)\n{\n\tint i;\n\n\tubi_assert(!(length & (ubi->min_io_size - 1)));\n\n\tfor (i = length - 1; i >= 0; i--)\n\t\tif (((const uint8_t *)buf)[i] != 0xFF)\n\t\t\tbreak;\n\n\t \n\tlength = ALIGN(i + 1, ubi->min_io_size);\n\treturn length;\n}\n\n \nint ubi_check_volume(struct ubi_device *ubi, int vol_id)\n{\n\tvoid *buf;\n\tint err = 0, i;\n\tstruct ubi_volume *vol = ubi->volumes[vol_id];\n\n\tif (vol->vol_type != UBI_STATIC_VOLUME)\n\t\treturn 0;\n\n\tbuf = vmalloc(vol->usable_leb_size);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < vol->used_ebs; i++) {\n\t\tint size;\n\n\t\tcond_resched();\n\n\t\tif (i == vol->used_ebs - 1)\n\t\t\tsize = vol->last_eb_bytes;\n\t\telse\n\t\t\tsize = vol->usable_leb_size;\n\n\t\terr = ubi_eba_read_leb(ubi, vol, i, buf, 0, size, 1);\n\t\tif (err) {\n\t\t\tif (mtd_is_eccerr(err))\n\t\t\t\terr = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tvfree(buf);\n\treturn err;\n}\n\n \nvoid ubi_update_reserved(struct ubi_device *ubi)\n{\n\tint need = ubi->beb_rsvd_level - ubi->beb_rsvd_pebs;\n\n\tif (need <= 0 || ubi->avail_pebs == 0)\n\t\treturn;\n\n\tneed = min_t(int, need, ubi->avail_pebs);\n\tubi->avail_pebs -= need;\n\tubi->rsvd_pebs += need;\n\tubi->beb_rsvd_pebs += need;\n\tubi_msg(ubi, \"reserved more %d PEBs for bad PEB handling\", need);\n}\n\n \nvoid ubi_calculate_reserved(struct ubi_device *ubi)\n{\n\t \n\tubi->beb_rsvd_level = ubi->bad_peb_limit - ubi->bad_peb_count;\n\tif (ubi->beb_rsvd_level < 0) {\n\t\tubi->beb_rsvd_level = 0;\n\t\tubi_warn(ubi, \"number of bad PEBs (%d) is above the expected limit (%d), not reserving any PEBs for bad PEB handling, will use available PEBs (if any)\",\n\t\t\t ubi->bad_peb_count, ubi->bad_peb_limit);\n\t}\n}\n\n \nint ubi_check_pattern(const void *buf, uint8_t patt, int size)\n{\n\tint i;\n\n\tfor (i = 0; i < size; i++)\n\t\tif (((const uint8_t *)buf)[i] != patt)\n\t\t\treturn 0;\n\treturn 1;\n}\n\n \nvoid ubi_msg(const struct ubi_device *ubi, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_notice(UBI_NAME_STR \"%d: %pV\\n\", ubi->ubi_num, &vaf);\n\n\tva_end(args);\n}\n\n \nvoid ubi_warn(const struct ubi_device *ubi, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_warn(UBI_NAME_STR \"%d warning: %ps: %pV\\n\",\n\t\tubi->ubi_num, __builtin_return_address(0), &vaf);\n\n\tva_end(args);\n}\n\n \nvoid ubi_err(const struct ubi_device *ubi, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(UBI_NAME_STR \"%d error: %ps: %pV\\n\",\n\t       ubi->ubi_num, __builtin_return_address(0), &vaf);\n\tva_end(args);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}