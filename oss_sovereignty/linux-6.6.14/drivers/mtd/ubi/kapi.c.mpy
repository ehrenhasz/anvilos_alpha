{
  "module_name": "kapi.c",
  "hash_id": "fad8bd0251780e49fcef8dd64ff89d98cdb36a6bd7435e587f7c923501e7cf6f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/ubi/kapi.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <asm/div64.h>\n#include \"ubi.h\"\n\n \nvoid ubi_do_get_device_info(struct ubi_device *ubi, struct ubi_device_info *di)\n{\n\tdi->ubi_num = ubi->ubi_num;\n\tdi->leb_size = ubi->leb_size;\n\tdi->leb_start = ubi->leb_start;\n\tdi->min_io_size = ubi->min_io_size;\n\tdi->max_write_size = ubi->max_write_size;\n\tdi->ro_mode = ubi->ro_mode;\n\tdi->cdev = ubi->cdev.dev;\n}\nEXPORT_SYMBOL_GPL(ubi_do_get_device_info);\n\n \nint ubi_get_device_info(int ubi_num, struct ubi_device_info *di)\n{\n\tstruct ubi_device *ubi;\n\n\tif (ubi_num < 0 || ubi_num >= UBI_MAX_DEVICES)\n\t\treturn -EINVAL;\n\tubi = ubi_get_device(ubi_num);\n\tif (!ubi)\n\t\treturn -ENODEV;\n\tubi_do_get_device_info(ubi, di);\n\tubi_put_device(ubi);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(ubi_get_device_info);\n\n \nvoid ubi_do_get_volume_info(struct ubi_device *ubi, struct ubi_volume *vol,\n\t\t\t    struct ubi_volume_info *vi)\n{\n\tvi->vol_id = vol->vol_id;\n\tvi->ubi_num = ubi->ubi_num;\n\tvi->size = vol->reserved_pebs;\n\tvi->used_bytes = vol->used_bytes;\n\tvi->vol_type = vol->vol_type;\n\tvi->corrupted = vol->corrupted;\n\tvi->upd_marker = vol->upd_marker;\n\tvi->alignment = vol->alignment;\n\tvi->usable_leb_size = vol->usable_leb_size;\n\tvi->name_len = vol->name_len;\n\tvi->name = vol->name;\n\tvi->cdev = vol->cdev.dev;\n\tvi->dev = &vol->dev;\n}\n\n \nvoid ubi_get_volume_info(struct ubi_volume_desc *desc,\n\t\t\t struct ubi_volume_info *vi)\n{\n\tubi_do_get_volume_info(desc->vol->ubi, desc->vol, vi);\n}\nEXPORT_SYMBOL_GPL(ubi_get_volume_info);\n\n \nstruct ubi_volume_desc *ubi_open_volume(int ubi_num, int vol_id, int mode)\n{\n\tint err;\n\tstruct ubi_volume_desc *desc;\n\tstruct ubi_device *ubi;\n\tstruct ubi_volume *vol;\n\n\tdbg_gen(\"open device %d, volume %d, mode %d\", ubi_num, vol_id, mode);\n\n\tif (ubi_num < 0 || ubi_num >= UBI_MAX_DEVICES)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (mode != UBI_READONLY && mode != UBI_READWRITE &&\n\t    mode != UBI_EXCLUSIVE && mode != UBI_METAONLY)\n\t\treturn ERR_PTR(-EINVAL);\n\n\t \n\tubi = ubi_get_device(ubi_num);\n\tif (!ubi)\n\t\treturn ERR_PTR(-ENODEV);\n\n\tif (vol_id < 0 || vol_id >= ubi->vtbl_slots) {\n\t\terr = -EINVAL;\n\t\tgoto out_put_ubi;\n\t}\n\n\tdesc = kmalloc(sizeof(struct ubi_volume_desc), GFP_KERNEL);\n\tif (!desc) {\n\t\terr = -ENOMEM;\n\t\tgoto out_put_ubi;\n\t}\n\n\terr = -ENODEV;\n\tif (!try_module_get(THIS_MODULE))\n\t\tgoto out_free;\n\n\tspin_lock(&ubi->volumes_lock);\n\tvol = ubi->volumes[vol_id];\n\tif (!vol)\n\t\tgoto out_unlock;\n\n\terr = -EBUSY;\n\tswitch (mode) {\n\tcase UBI_READONLY:\n\t\tif (vol->exclusive)\n\t\t\tgoto out_unlock;\n\t\tvol->readers += 1;\n\t\tbreak;\n\n\tcase UBI_READWRITE:\n\t\tif (vol->exclusive || vol->writers > 0)\n\t\t\tgoto out_unlock;\n\t\tvol->writers += 1;\n\t\tbreak;\n\n\tcase UBI_EXCLUSIVE:\n\t\tif (vol->exclusive || vol->writers || vol->readers ||\n\t\t    vol->metaonly)\n\t\t\tgoto out_unlock;\n\t\tvol->exclusive = 1;\n\t\tbreak;\n\n\tcase UBI_METAONLY:\n\t\tif (vol->metaonly || vol->exclusive)\n\t\t\tgoto out_unlock;\n\t\tvol->metaonly = 1;\n\t\tbreak;\n\t}\n\tget_device(&vol->dev);\n\tvol->ref_count += 1;\n\tspin_unlock(&ubi->volumes_lock);\n\n\tdesc->vol = vol;\n\tdesc->mode = mode;\n\n\tmutex_lock(&ubi->ckvol_mutex);\n\tif (!vol->checked && !vol->skip_check) {\n\t\t \n\t\terr = ubi_check_volume(ubi, vol_id);\n\t\tif (err < 0) {\n\t\t\tmutex_unlock(&ubi->ckvol_mutex);\n\t\t\tubi_close_volume(desc);\n\t\t\treturn ERR_PTR(err);\n\t\t}\n\t\tif (err == 1) {\n\t\t\tubi_warn(ubi, \"volume %d on UBI device %d is corrupted\",\n\t\t\t\t vol_id, ubi->ubi_num);\n\t\t\tvol->corrupted = 1;\n\t\t}\n\t\tvol->checked = 1;\n\t}\n\tmutex_unlock(&ubi->ckvol_mutex);\n\n\treturn desc;\n\nout_unlock:\n\tspin_unlock(&ubi->volumes_lock);\n\tmodule_put(THIS_MODULE);\nout_free:\n\tkfree(desc);\nout_put_ubi:\n\tubi_err(ubi, \"cannot open device %d, volume %d, error %d\",\n\t\tubi_num, vol_id, err);\n\tubi_put_device(ubi);\n\treturn ERR_PTR(err);\n}\nEXPORT_SYMBOL_GPL(ubi_open_volume);\n\n \nstruct ubi_volume_desc *ubi_open_volume_nm(int ubi_num, const char *name,\n\t\t\t\t\t   int mode)\n{\n\tint i, vol_id = -1, len;\n\tstruct ubi_device *ubi;\n\tstruct ubi_volume_desc *ret;\n\n\tdbg_gen(\"open device %d, volume %s, mode %d\", ubi_num, name, mode);\n\n\tif (!name)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tlen = strnlen(name, UBI_VOL_NAME_MAX + 1);\n\tif (len > UBI_VOL_NAME_MAX)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (ubi_num < 0 || ubi_num >= UBI_MAX_DEVICES)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tubi = ubi_get_device(ubi_num);\n\tif (!ubi)\n\t\treturn ERR_PTR(-ENODEV);\n\n\tspin_lock(&ubi->volumes_lock);\n\t \n\tfor (i = 0; i < ubi->vtbl_slots; i++) {\n\t\tstruct ubi_volume *vol = ubi->volumes[i];\n\n\t\tif (vol && len == vol->name_len && !strcmp(name, vol->name)) {\n\t\t\tvol_id = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&ubi->volumes_lock);\n\n\tif (vol_id >= 0)\n\t\tret = ubi_open_volume(ubi_num, vol_id, mode);\n\telse\n\t\tret = ERR_PTR(-ENODEV);\n\n\t \n\tubi_put_device(ubi);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(ubi_open_volume_nm);\n\n \nstruct ubi_volume_desc *ubi_open_volume_path(const char *pathname, int mode)\n{\n\tint error, ubi_num, vol_id;\n\tstruct path path;\n\tstruct kstat stat;\n\n\tdbg_gen(\"open volume %s, mode %d\", pathname, mode);\n\n\tif (!pathname || !*pathname)\n\t\treturn ERR_PTR(-EINVAL);\n\n\terror = kern_path(pathname, LOOKUP_FOLLOW, &path);\n\tif (error)\n\t\treturn ERR_PTR(error);\n\n\terror = vfs_getattr(&path, &stat, STATX_TYPE, AT_STATX_SYNC_AS_STAT);\n\tpath_put(&path);\n\tif (error)\n\t\treturn ERR_PTR(error);\n\n\tif (!S_ISCHR(stat.mode))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tubi_num = ubi_major2num(MAJOR(stat.rdev));\n\tvol_id = MINOR(stat.rdev) - 1;\n\n\tif (vol_id >= 0 && ubi_num >= 0)\n\t\treturn ubi_open_volume(ubi_num, vol_id, mode);\n\treturn ERR_PTR(-ENODEV);\n}\nEXPORT_SYMBOL_GPL(ubi_open_volume_path);\n\n \nvoid ubi_close_volume(struct ubi_volume_desc *desc)\n{\n\tstruct ubi_volume *vol = desc->vol;\n\tstruct ubi_device *ubi = vol->ubi;\n\n\tdbg_gen(\"close device %d, volume %d, mode %d\",\n\t\tubi->ubi_num, vol->vol_id, desc->mode);\n\n\tspin_lock(&ubi->volumes_lock);\n\tswitch (desc->mode) {\n\tcase UBI_READONLY:\n\t\tvol->readers -= 1;\n\t\tbreak;\n\tcase UBI_READWRITE:\n\t\tvol->writers -= 1;\n\t\tbreak;\n\tcase UBI_EXCLUSIVE:\n\t\tvol->exclusive = 0;\n\t\tbreak;\n\tcase UBI_METAONLY:\n\t\tvol->metaonly = 0;\n\t\tbreak;\n\t}\n\tvol->ref_count -= 1;\n\tspin_unlock(&ubi->volumes_lock);\n\n\tkfree(desc);\n\tput_device(&vol->dev);\n\tubi_put_device(ubi);\n\tmodule_put(THIS_MODULE);\n}\nEXPORT_SYMBOL_GPL(ubi_close_volume);\n\n \nstatic int leb_read_sanity_check(struct ubi_volume_desc *desc, int lnum,\n\t\t\t\t int offset, int len)\n{\n\tstruct ubi_volume *vol = desc->vol;\n\tstruct ubi_device *ubi = vol->ubi;\n\tint vol_id = vol->vol_id;\n\n\tif (vol_id < 0 || vol_id >= ubi->vtbl_slots || lnum < 0 ||\n\t    lnum >= vol->used_ebs || offset < 0 || len < 0 ||\n\t    offset + len > vol->usable_leb_size)\n\t\treturn -EINVAL;\n\n\tif (vol->vol_type == UBI_STATIC_VOLUME) {\n\t\tif (vol->used_ebs == 0)\n\t\t\t \n\t\t\treturn 0;\n\t\tif (lnum == vol->used_ebs - 1 &&\n\t\t    offset + len > vol->last_eb_bytes)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (vol->upd_marker)\n\t\treturn -EBADF;\n\n\treturn 0;\n}\n\n \nint ubi_leb_read(struct ubi_volume_desc *desc, int lnum, char *buf, int offset,\n\t\t int len, int check)\n{\n\tstruct ubi_volume *vol = desc->vol;\n\tstruct ubi_device *ubi = vol->ubi;\n\tint err, vol_id = vol->vol_id;\n\n\tdbg_gen(\"read %d bytes from LEB %d:%d:%d\", len, vol_id, lnum, offset);\n\n\terr = leb_read_sanity_check(desc, lnum, offset, len);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (len == 0)\n\t\treturn 0;\n\n\terr = ubi_eba_read_leb(ubi, vol, lnum, buf, offset, len, check);\n\tif (err && mtd_is_eccerr(err) && vol->vol_type == UBI_STATIC_VOLUME) {\n\t\tubi_warn(ubi, \"mark volume %d as corrupted\", vol_id);\n\t\tvol->corrupted = 1;\n\t}\n\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(ubi_leb_read);\n\n\n \nint ubi_leb_read_sg(struct ubi_volume_desc *desc, int lnum, struct ubi_sgl *sgl,\n\t\t    int offset, int len, int check)\n{\n\tstruct ubi_volume *vol = desc->vol;\n\tstruct ubi_device *ubi = vol->ubi;\n\tint err, vol_id = vol->vol_id;\n\n\tdbg_gen(\"read %d bytes from LEB %d:%d:%d\", len, vol_id, lnum, offset);\n\n\terr = leb_read_sanity_check(desc, lnum, offset, len);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (len == 0)\n\t\treturn 0;\n\n\terr = ubi_eba_read_leb_sg(ubi, vol, sgl, lnum, offset, len, check);\n\tif (err && mtd_is_eccerr(err) && vol->vol_type == UBI_STATIC_VOLUME) {\n\t\tubi_warn(ubi, \"mark volume %d as corrupted\", vol_id);\n\t\tvol->corrupted = 1;\n\t}\n\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(ubi_leb_read_sg);\n\n \nint ubi_leb_write(struct ubi_volume_desc *desc, int lnum, const void *buf,\n\t\t  int offset, int len)\n{\n\tstruct ubi_volume *vol = desc->vol;\n\tstruct ubi_device *ubi = vol->ubi;\n\tint vol_id = vol->vol_id;\n\n\tdbg_gen(\"write %d bytes to LEB %d:%d:%d\", len, vol_id, lnum, offset);\n\n\tif (vol_id < 0 || vol_id >= ubi->vtbl_slots)\n\t\treturn -EINVAL;\n\n\tif (desc->mode == UBI_READONLY || vol->vol_type == UBI_STATIC_VOLUME)\n\t\treturn -EROFS;\n\n\tif (!ubi_leb_valid(vol, lnum) || offset < 0 || len < 0 ||\n\t    offset + len > vol->usable_leb_size ||\n\t    offset & (ubi->min_io_size - 1) || len & (ubi->min_io_size - 1))\n\t\treturn -EINVAL;\n\n\tif (vol->upd_marker)\n\t\treturn -EBADF;\n\n\tif (len == 0)\n\t\treturn 0;\n\n\treturn ubi_eba_write_leb(ubi, vol, lnum, buf, offset, len);\n}\nEXPORT_SYMBOL_GPL(ubi_leb_write);\n\n \nint ubi_leb_change(struct ubi_volume_desc *desc, int lnum, const void *buf,\n\t\t   int len)\n{\n\tstruct ubi_volume *vol = desc->vol;\n\tstruct ubi_device *ubi = vol->ubi;\n\tint vol_id = vol->vol_id;\n\n\tdbg_gen(\"atomically write %d bytes to LEB %d:%d\", len, vol_id, lnum);\n\n\tif (vol_id < 0 || vol_id >= ubi->vtbl_slots)\n\t\treturn -EINVAL;\n\n\tif (desc->mode == UBI_READONLY || vol->vol_type == UBI_STATIC_VOLUME)\n\t\treturn -EROFS;\n\n\tif (!ubi_leb_valid(vol, lnum) || len < 0 ||\n\t    len > vol->usable_leb_size || len & (ubi->min_io_size - 1))\n\t\treturn -EINVAL;\n\n\tif (vol->upd_marker)\n\t\treturn -EBADF;\n\n\tif (len == 0)\n\t\treturn 0;\n\n\treturn ubi_eba_atomic_leb_change(ubi, vol, lnum, buf, len);\n}\nEXPORT_SYMBOL_GPL(ubi_leb_change);\n\n \nint ubi_leb_erase(struct ubi_volume_desc *desc, int lnum)\n{\n\tstruct ubi_volume *vol = desc->vol;\n\tstruct ubi_device *ubi = vol->ubi;\n\tint err;\n\n\tdbg_gen(\"erase LEB %d:%d\", vol->vol_id, lnum);\n\n\tif (desc->mode == UBI_READONLY || vol->vol_type == UBI_STATIC_VOLUME)\n\t\treturn -EROFS;\n\n\tif (!ubi_leb_valid(vol, lnum))\n\t\treturn -EINVAL;\n\n\tif (vol->upd_marker)\n\t\treturn -EBADF;\n\n\terr = ubi_eba_unmap_leb(ubi, vol, lnum);\n\tif (err)\n\t\treturn err;\n\n\treturn ubi_wl_flush(ubi, vol->vol_id, lnum);\n}\nEXPORT_SYMBOL_GPL(ubi_leb_erase);\n\n \nint ubi_leb_unmap(struct ubi_volume_desc *desc, int lnum)\n{\n\tstruct ubi_volume *vol = desc->vol;\n\tstruct ubi_device *ubi = vol->ubi;\n\n\tdbg_gen(\"unmap LEB %d:%d\", vol->vol_id, lnum);\n\n\tif (desc->mode == UBI_READONLY || vol->vol_type == UBI_STATIC_VOLUME)\n\t\treturn -EROFS;\n\n\tif (!ubi_leb_valid(vol, lnum))\n\t\treturn -EINVAL;\n\n\tif (vol->upd_marker)\n\t\treturn -EBADF;\n\n\treturn ubi_eba_unmap_leb(ubi, vol, lnum);\n}\nEXPORT_SYMBOL_GPL(ubi_leb_unmap);\n\n \nint ubi_leb_map(struct ubi_volume_desc *desc, int lnum)\n{\n\tstruct ubi_volume *vol = desc->vol;\n\tstruct ubi_device *ubi = vol->ubi;\n\n\tdbg_gen(\"map LEB %d:%d\", vol->vol_id, lnum);\n\n\tif (desc->mode == UBI_READONLY || vol->vol_type == UBI_STATIC_VOLUME)\n\t\treturn -EROFS;\n\n\tif (!ubi_leb_valid(vol, lnum))\n\t\treturn -EINVAL;\n\n\tif (vol->upd_marker)\n\t\treturn -EBADF;\n\n\tif (ubi_eba_is_mapped(vol, lnum))\n\t\treturn -EBADMSG;\n\n\treturn ubi_eba_write_leb(ubi, vol, lnum, NULL, 0, 0);\n}\nEXPORT_SYMBOL_GPL(ubi_leb_map);\n\n \nint ubi_is_mapped(struct ubi_volume_desc *desc, int lnum)\n{\n\tstruct ubi_volume *vol = desc->vol;\n\n\tdbg_gen(\"test LEB %d:%d\", vol->vol_id, lnum);\n\n\tif (!ubi_leb_valid(vol, lnum))\n\t\treturn -EINVAL;\n\n\tif (vol->upd_marker)\n\t\treturn -EBADF;\n\n\treturn ubi_eba_is_mapped(vol, lnum);\n}\nEXPORT_SYMBOL_GPL(ubi_is_mapped);\n\n \nint ubi_sync(int ubi_num)\n{\n\tstruct ubi_device *ubi;\n\n\tubi = ubi_get_device(ubi_num);\n\tif (!ubi)\n\t\treturn -ENODEV;\n\n\tmtd_sync(ubi->mtd);\n\tubi_put_device(ubi);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(ubi_sync);\n\n \nint ubi_flush(int ubi_num, int vol_id, int lnum)\n{\n\tstruct ubi_device *ubi;\n\tint err = 0;\n\n\tubi = ubi_get_device(ubi_num);\n\tif (!ubi)\n\t\treturn -ENODEV;\n\n\terr = ubi_wl_flush(ubi, vol_id, lnum);\n\tubi_put_device(ubi);\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(ubi_flush);\n\nBLOCKING_NOTIFIER_HEAD(ubi_notifiers);\n\n \nint ubi_register_volume_notifier(struct notifier_block *nb,\n\t\t\t\t int ignore_existing)\n{\n\tint err;\n\n\terr = blocking_notifier_chain_register(&ubi_notifiers, nb);\n\tif (err != 0)\n\t\treturn err;\n\tif (ignore_existing)\n\t\treturn 0;\n\n\t \n\tmutex_lock(&ubi_devices_mutex);\n\tubi_enumerate_volumes(nb);\n\tmutex_unlock(&ubi_devices_mutex);\n\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(ubi_register_volume_notifier);\n\n \nint ubi_unregister_volume_notifier(struct notifier_block *nb)\n{\n\treturn blocking_notifier_chain_unregister(&ubi_notifiers, nb);\n}\nEXPORT_SYMBOL_GPL(ubi_unregister_volume_notifier);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}