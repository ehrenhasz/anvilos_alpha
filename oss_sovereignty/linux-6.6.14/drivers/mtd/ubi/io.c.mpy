{
  "module_name": "io.c",
  "hash_id": "12bdb90638741ccabc9f7e97e5f44fa3a942dda3440f33b32cd0c824354e1044",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/ubi/io.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/crc32.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include \"ubi.h\"\n\nstatic int self_check_not_bad(const struct ubi_device *ubi, int pnum);\nstatic int self_check_peb_ec_hdr(const struct ubi_device *ubi, int pnum);\nstatic int self_check_ec_hdr(const struct ubi_device *ubi, int pnum,\n\t\t\t     const struct ubi_ec_hdr *ec_hdr);\nstatic int self_check_peb_vid_hdr(const struct ubi_device *ubi, int pnum);\nstatic int self_check_vid_hdr(const struct ubi_device *ubi, int pnum,\n\t\t\t      const struct ubi_vid_hdr *vid_hdr);\nstatic int self_check_write(struct ubi_device *ubi, const void *buf, int pnum,\n\t\t\t    int offset, int len);\n\n \nint ubi_io_read(const struct ubi_device *ubi, void *buf, int pnum, int offset,\n\t\tint len)\n{\n\tint err, retries = 0;\n\tsize_t read;\n\tloff_t addr;\n\n\tdbg_io(\"read %d bytes from PEB %d:%d\", len, pnum, offset);\n\n\tubi_assert(pnum >= 0 && pnum < ubi->peb_count);\n\tubi_assert(offset >= 0 && offset + len <= ubi->peb_size);\n\tubi_assert(len > 0);\n\n\terr = self_check_not_bad(ubi, pnum);\n\tif (err)\n\t\treturn err;\n\n\t \n\t*((uint8_t *)buf) ^= 0xFF;\n\n\taddr = (loff_t)pnum * ubi->peb_size + offset;\nretry:\n\terr = mtd_read(ubi->mtd, addr, len, &read, buf);\n\tif (err) {\n\t\tconst char *errstr = mtd_is_eccerr(err) ? \" (ECC error)\" : \"\";\n\n\t\tif (mtd_is_bitflip(err)) {\n\t\t\t \n\t\t\tubi_msg(ubi, \"fixable bit-flip detected at PEB %d\",\n\t\t\t\tpnum);\n\t\t\tubi_assert(len == read);\n\t\t\treturn UBI_IO_BITFLIPS;\n\t\t}\n\n\t\tif (retries++ < UBI_IO_RETRIES) {\n\t\t\tubi_warn(ubi, \"error %d%s while reading %d bytes from PEB %d:%d, read only %zd bytes, retry\",\n\t\t\t\t err, errstr, len, pnum, offset, read);\n\t\t\tyield();\n\t\t\tgoto retry;\n\t\t}\n\n\t\tubi_err(ubi, \"error %d%s while reading %d bytes from PEB %d:%d, read %zd bytes\",\n\t\t\terr, errstr, len, pnum, offset, read);\n\t\tdump_stack();\n\n\t\t \n\t\tif (read != len && mtd_is_eccerr(err)) {\n\t\t\tubi_assert(0);\n\t\t\terr = -EIO;\n\t\t}\n\t} else {\n\t\tubi_assert(len == read);\n\n\t\tif (ubi_dbg_is_bitflip(ubi)) {\n\t\t\tdbg_gen(\"bit-flip (emulated)\");\n\t\t\terr = UBI_IO_BITFLIPS;\n\t\t}\n\t}\n\n\treturn err;\n}\n\n \nint ubi_io_write(struct ubi_device *ubi, const void *buf, int pnum, int offset,\n\t\t int len)\n{\n\tint err;\n\tsize_t written;\n\tloff_t addr;\n\n\tdbg_io(\"write %d bytes to PEB %d:%d\", len, pnum, offset);\n\n\tubi_assert(pnum >= 0 && pnum < ubi->peb_count);\n\tubi_assert(offset >= 0 && offset + len <= ubi->peb_size);\n\tubi_assert(offset % ubi->hdrs_min_io_size == 0);\n\tubi_assert(len > 0 && len % ubi->hdrs_min_io_size == 0);\n\n\tif (ubi->ro_mode) {\n\t\tubi_err(ubi, \"read-only mode\");\n\t\treturn -EROFS;\n\t}\n\n\terr = self_check_not_bad(ubi, pnum);\n\tif (err)\n\t\treturn err;\n\n\t \n\terr = ubi_self_check_all_ff(ubi, pnum, offset, len);\n\tif (err)\n\t\treturn err;\n\n\tif (offset >= ubi->leb_start) {\n\t\t \n\t\terr = self_check_peb_ec_hdr(ubi, pnum);\n\t\tif (err)\n\t\t\treturn err;\n\t\terr = self_check_peb_vid_hdr(ubi, pnum);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (ubi_dbg_is_write_failure(ubi)) {\n\t\tubi_err(ubi, \"cannot write %d bytes to PEB %d:%d (emulated)\",\n\t\t\tlen, pnum, offset);\n\t\tdump_stack();\n\t\treturn -EIO;\n\t}\n\n\taddr = (loff_t)pnum * ubi->peb_size + offset;\n\terr = mtd_write(ubi->mtd, addr, len, &written, buf);\n\tif (err) {\n\t\tubi_err(ubi, \"error %d while writing %d bytes to PEB %d:%d, written %zd bytes\",\n\t\t\terr, len, pnum, offset, written);\n\t\tdump_stack();\n\t\tubi_dump_flash(ubi, pnum, offset, len);\n\t} else\n\t\tubi_assert(written == len);\n\n\tif (!err) {\n\t\terr = self_check_write(ubi, buf, pnum, offset, len);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\t \n\t\toffset += len;\n\t\tlen = ubi->peb_size - offset;\n\t\tif (len)\n\t\t\terr = ubi_self_check_all_ff(ubi, pnum, offset, len);\n\t}\n\n\treturn err;\n}\n\n \nstatic int do_sync_erase(struct ubi_device *ubi, int pnum)\n{\n\tint err, retries = 0;\n\tstruct erase_info ei;\n\n\tdbg_io(\"erase PEB %d\", pnum);\n\tubi_assert(pnum >= 0 && pnum < ubi->peb_count);\n\n\tif (ubi->ro_mode) {\n\t\tubi_err(ubi, \"read-only mode\");\n\t\treturn -EROFS;\n\t}\n\nretry:\n\tmemset(&ei, 0, sizeof(struct erase_info));\n\n\tei.addr     = (loff_t)pnum * ubi->peb_size;\n\tei.len      = ubi->peb_size;\n\n\terr = mtd_erase(ubi->mtd, &ei);\n\tif (err) {\n\t\tif (retries++ < UBI_IO_RETRIES) {\n\t\t\tubi_warn(ubi, \"error %d while erasing PEB %d, retry\",\n\t\t\t\t err, pnum);\n\t\t\tyield();\n\t\t\tgoto retry;\n\t\t}\n\t\tubi_err(ubi, \"cannot erase PEB %d, error %d\", pnum, err);\n\t\tdump_stack();\n\t\treturn err;\n\t}\n\n\terr = ubi_self_check_all_ff(ubi, pnum, 0, ubi->peb_size);\n\tif (err)\n\t\treturn err;\n\n\tif (ubi_dbg_is_erase_failure(ubi)) {\n\t\tubi_err(ubi, \"cannot erase PEB %d (emulated)\", pnum);\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\n \nstatic uint8_t patterns[] = {0xa5, 0x5a, 0x0};\n\n \nstatic int torture_peb(struct ubi_device *ubi, int pnum)\n{\n\tint err, i, patt_count;\n\n\tubi_msg(ubi, \"run torture test for PEB %d\", pnum);\n\tpatt_count = ARRAY_SIZE(patterns);\n\tubi_assert(patt_count > 0);\n\n\tmutex_lock(&ubi->buf_mutex);\n\tfor (i = 0; i < patt_count; i++) {\n\t\terr = do_sync_erase(ubi, pnum);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\t \n\t\terr = ubi_io_read(ubi, ubi->peb_buf, pnum, 0, ubi->peb_size);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\terr = ubi_check_pattern(ubi->peb_buf, 0xFF, ubi->peb_size);\n\t\tif (err == 0) {\n\t\t\tubi_err(ubi, \"erased PEB %d, but a non-0xFF byte found\",\n\t\t\t\tpnum);\n\t\t\terr = -EIO;\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\tmemset(ubi->peb_buf, patterns[i], ubi->peb_size);\n\t\terr = ubi_io_write(ubi, ubi->peb_buf, pnum, 0, ubi->peb_size);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tmemset(ubi->peb_buf, ~patterns[i], ubi->peb_size);\n\t\terr = ubi_io_read(ubi, ubi->peb_buf, pnum, 0, ubi->peb_size);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\terr = ubi_check_pattern(ubi->peb_buf, patterns[i],\n\t\t\t\t\tubi->peb_size);\n\t\tif (err == 0) {\n\t\t\tubi_err(ubi, \"pattern %x checking failed for PEB %d\",\n\t\t\t\tpatterns[i], pnum);\n\t\t\terr = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\terr = patt_count;\n\tubi_msg(ubi, \"PEB %d passed torture test, do not mark it as bad\", pnum);\n\nout:\n\tmutex_unlock(&ubi->buf_mutex);\n\tif (err == UBI_IO_BITFLIPS || mtd_is_eccerr(err)) {\n\t\t \n\t\tubi_err(ubi, \"read problems on freshly erased PEB %d, must be bad\",\n\t\t\tpnum);\n\t\terr = -EIO;\n\t}\n\treturn err;\n}\n\n \nstatic int nor_erase_prepare(struct ubi_device *ubi, int pnum)\n{\n\tint err;\n\tsize_t written;\n\tloff_t addr;\n\tuint32_t data = 0;\n\tstruct ubi_ec_hdr ec_hdr;\n\tstruct ubi_vid_io_buf vidb;\n\n\t \n\tstruct ubi_vid_hdr vid_hdr;\n\n\t \n\taddr = (loff_t)pnum * ubi->peb_size;\n\terr = ubi_io_read_ec_hdr(ubi, pnum, &ec_hdr, 0);\n\tif (err != UBI_IO_BAD_HDR_EBADMSG && err != UBI_IO_BAD_HDR &&\n\t    err != UBI_IO_FF){\n\t\terr = mtd_write(ubi->mtd, addr, 4, &written, (void *)&data);\n\t\tif(err)\n\t\t\tgoto error;\n\t}\n\n\tubi_init_vid_buf(ubi, &vidb, &vid_hdr);\n\tubi_assert(&vid_hdr == ubi_get_vid_hdr(&vidb));\n\n\terr = ubi_io_read_vid_hdr(ubi, pnum, &vidb, 0);\n\tif (err != UBI_IO_BAD_HDR_EBADMSG && err != UBI_IO_BAD_HDR &&\n\t    err != UBI_IO_FF){\n\t\taddr += ubi->vid_hdr_aloffset;\n\t\terr = mtd_write(ubi->mtd, addr, 4, &written, (void *)&data);\n\t\tif (err)\n\t\t\tgoto error;\n\t}\n\treturn 0;\n\nerror:\n\t \n\tubi_err(ubi, \"cannot invalidate PEB %d, write returned %d\", pnum, err);\n\tubi_dump_flash(ubi, pnum, 0, ubi->peb_size);\n\treturn -EIO;\n}\n\n \nint ubi_io_sync_erase(struct ubi_device *ubi, int pnum, int torture)\n{\n\tint err, ret = 0;\n\n\tubi_assert(pnum >= 0 && pnum < ubi->peb_count);\n\n\terr = self_check_not_bad(ubi, pnum);\n\tif (err != 0)\n\t\treturn err;\n\n\tif (ubi->ro_mode) {\n\t\tubi_err(ubi, \"read-only mode\");\n\t\treturn -EROFS;\n\t}\n\n\t \n\tif (ubi->nor_flash && ubi->mtd->writesize == 1) {\n\t\terr = nor_erase_prepare(ubi, pnum);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (torture) {\n\t\tret = torture_peb(ubi, pnum);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\terr = do_sync_erase(ubi, pnum);\n\tif (err)\n\t\treturn err;\n\n\treturn ret + 1;\n}\n\n \nint ubi_io_is_bad(const struct ubi_device *ubi, int pnum)\n{\n\tstruct mtd_info *mtd = ubi->mtd;\n\n\tubi_assert(pnum >= 0 && pnum < ubi->peb_count);\n\n\tif (ubi->bad_allowed) {\n\t\tint ret;\n\n\t\tret = mtd_block_isbad(mtd, (loff_t)pnum * ubi->peb_size);\n\t\tif (ret < 0)\n\t\t\tubi_err(ubi, \"error %d while checking if PEB %d is bad\",\n\t\t\t\tret, pnum);\n\t\telse if (ret)\n\t\t\tdbg_io(\"PEB %d is bad\", pnum);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n \nint ubi_io_mark_bad(const struct ubi_device *ubi, int pnum)\n{\n\tint err;\n\tstruct mtd_info *mtd = ubi->mtd;\n\n\tubi_assert(pnum >= 0 && pnum < ubi->peb_count);\n\n\tif (ubi->ro_mode) {\n\t\tubi_err(ubi, \"read-only mode\");\n\t\treturn -EROFS;\n\t}\n\n\tif (!ubi->bad_allowed)\n\t\treturn 0;\n\n\terr = mtd_block_markbad(mtd, (loff_t)pnum * ubi->peb_size);\n\tif (err)\n\t\tubi_err(ubi, \"cannot mark PEB %d bad, error %d\", pnum, err);\n\treturn err;\n}\n\n \nstatic int validate_ec_hdr(const struct ubi_device *ubi,\n\t\t\t   const struct ubi_ec_hdr *ec_hdr)\n{\n\tlong long ec;\n\tint vid_hdr_offset, leb_start;\n\n\tec = be64_to_cpu(ec_hdr->ec);\n\tvid_hdr_offset = be32_to_cpu(ec_hdr->vid_hdr_offset);\n\tleb_start = be32_to_cpu(ec_hdr->data_offset);\n\n\tif (ec_hdr->version != UBI_VERSION) {\n\t\tubi_err(ubi, \"node with incompatible UBI version found: this UBI version is %d, image version is %d\",\n\t\t\tUBI_VERSION, (int)ec_hdr->version);\n\t\tgoto bad;\n\t}\n\n\tif (vid_hdr_offset != ubi->vid_hdr_offset) {\n\t\tubi_err(ubi, \"bad VID header offset %d, expected %d\",\n\t\t\tvid_hdr_offset, ubi->vid_hdr_offset);\n\t\tgoto bad;\n\t}\n\n\tif (leb_start != ubi->leb_start) {\n\t\tubi_err(ubi, \"bad data offset %d, expected %d\",\n\t\t\tleb_start, ubi->leb_start);\n\t\tgoto bad;\n\t}\n\n\tif (ec < 0 || ec > UBI_MAX_ERASECOUNTER) {\n\t\tubi_err(ubi, \"bad erase counter %lld\", ec);\n\t\tgoto bad;\n\t}\n\n\treturn 0;\n\nbad:\n\tubi_err(ubi, \"bad EC header\");\n\tubi_dump_ec_hdr(ec_hdr);\n\tdump_stack();\n\treturn 1;\n}\n\n \nint ubi_io_read_ec_hdr(struct ubi_device *ubi, int pnum,\n\t\t       struct ubi_ec_hdr *ec_hdr, int verbose)\n{\n\tint err, read_err;\n\tuint32_t crc, magic, hdr_crc;\n\n\tdbg_io(\"read EC header from PEB %d\", pnum);\n\tubi_assert(pnum >= 0 && pnum < ubi->peb_count);\n\n\tread_err = ubi_io_read(ubi, ec_hdr, pnum, 0, UBI_EC_HDR_SIZE);\n\tif (read_err) {\n\t\tif (read_err != UBI_IO_BITFLIPS && !mtd_is_eccerr(read_err))\n\t\t\treturn read_err;\n\n\t\t \n\t}\n\n\tmagic = be32_to_cpu(ec_hdr->magic);\n\tif (magic != UBI_EC_HDR_MAGIC) {\n\t\tif (mtd_is_eccerr(read_err))\n\t\t\treturn UBI_IO_BAD_HDR_EBADMSG;\n\n\t\t \n\t\tif (ubi_check_pattern(ec_hdr, 0xFF, UBI_EC_HDR_SIZE)) {\n\t\t\t \n\t\t\tif (verbose)\n\t\t\t\tubi_warn(ubi, \"no EC header found at PEB %d, only 0xFF bytes\",\n\t\t\t\t\t pnum);\n\t\t\tdbg_bld(\"no EC header found at PEB %d, only 0xFF bytes\",\n\t\t\t\tpnum);\n\t\t\tif (!read_err)\n\t\t\t\treturn UBI_IO_FF;\n\t\t\telse\n\t\t\t\treturn UBI_IO_FF_BITFLIPS;\n\t\t}\n\n\t\t \n\t\tif (verbose) {\n\t\t\tubi_warn(ubi, \"bad magic number at PEB %d: %08x instead of %08x\",\n\t\t\t\t pnum, magic, UBI_EC_HDR_MAGIC);\n\t\t\tubi_dump_ec_hdr(ec_hdr);\n\t\t}\n\t\tdbg_bld(\"bad magic number at PEB %d: %08x instead of %08x\",\n\t\t\tpnum, magic, UBI_EC_HDR_MAGIC);\n\t\treturn UBI_IO_BAD_HDR;\n\t}\n\n\tcrc = crc32(UBI_CRC32_INIT, ec_hdr, UBI_EC_HDR_SIZE_CRC);\n\thdr_crc = be32_to_cpu(ec_hdr->hdr_crc);\n\n\tif (hdr_crc != crc) {\n\t\tif (verbose) {\n\t\t\tubi_warn(ubi, \"bad EC header CRC at PEB %d, calculated %#08x, read %#08x\",\n\t\t\t\t pnum, crc, hdr_crc);\n\t\t\tubi_dump_ec_hdr(ec_hdr);\n\t\t}\n\t\tdbg_bld(\"bad EC header CRC at PEB %d, calculated %#08x, read %#08x\",\n\t\t\tpnum, crc, hdr_crc);\n\n\t\tif (!read_err)\n\t\t\treturn UBI_IO_BAD_HDR;\n\t\telse\n\t\t\treturn UBI_IO_BAD_HDR_EBADMSG;\n\t}\n\n\t \n\terr = validate_ec_hdr(ubi, ec_hdr);\n\tif (err) {\n\t\tubi_err(ubi, \"validation failed for PEB %d\", pnum);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\treturn read_err ? UBI_IO_BITFLIPS : 0;\n}\n\n \nint ubi_io_write_ec_hdr(struct ubi_device *ubi, int pnum,\n\t\t\tstruct ubi_ec_hdr *ec_hdr)\n{\n\tint err;\n\tuint32_t crc;\n\n\tdbg_io(\"write EC header to PEB %d\", pnum);\n\tubi_assert(pnum >= 0 &&  pnum < ubi->peb_count);\n\n\tec_hdr->magic = cpu_to_be32(UBI_EC_HDR_MAGIC);\n\tec_hdr->version = UBI_VERSION;\n\tec_hdr->vid_hdr_offset = cpu_to_be32(ubi->vid_hdr_offset);\n\tec_hdr->data_offset = cpu_to_be32(ubi->leb_start);\n\tec_hdr->image_seq = cpu_to_be32(ubi->image_seq);\n\tcrc = crc32(UBI_CRC32_INIT, ec_hdr, UBI_EC_HDR_SIZE_CRC);\n\tec_hdr->hdr_crc = cpu_to_be32(crc);\n\n\terr = self_check_ec_hdr(ubi, pnum, ec_hdr);\n\tif (err)\n\t\treturn err;\n\n\tif (ubi_dbg_power_cut(ubi, POWER_CUT_EC_WRITE))\n\t\treturn -EROFS;\n\n\terr = ubi_io_write(ubi, ec_hdr, pnum, 0, ubi->ec_hdr_alsize);\n\treturn err;\n}\n\n \nstatic int validate_vid_hdr(const struct ubi_device *ubi,\n\t\t\t    const struct ubi_vid_hdr *vid_hdr)\n{\n\tint vol_type = vid_hdr->vol_type;\n\tint copy_flag = vid_hdr->copy_flag;\n\tint vol_id = be32_to_cpu(vid_hdr->vol_id);\n\tint lnum = be32_to_cpu(vid_hdr->lnum);\n\tint compat = vid_hdr->compat;\n\tint data_size = be32_to_cpu(vid_hdr->data_size);\n\tint used_ebs = be32_to_cpu(vid_hdr->used_ebs);\n\tint data_pad = be32_to_cpu(vid_hdr->data_pad);\n\tint data_crc = be32_to_cpu(vid_hdr->data_crc);\n\tint usable_leb_size = ubi->leb_size - data_pad;\n\n\tif (copy_flag != 0 && copy_flag != 1) {\n\t\tubi_err(ubi, \"bad copy_flag\");\n\t\tgoto bad;\n\t}\n\n\tif (vol_id < 0 || lnum < 0 || data_size < 0 || used_ebs < 0 ||\n\t    data_pad < 0) {\n\t\tubi_err(ubi, \"negative values\");\n\t\tgoto bad;\n\t}\n\n\tif (vol_id >= UBI_MAX_VOLUMES && vol_id < UBI_INTERNAL_VOL_START) {\n\t\tubi_err(ubi, \"bad vol_id\");\n\t\tgoto bad;\n\t}\n\n\tif (vol_id < UBI_INTERNAL_VOL_START && compat != 0) {\n\t\tubi_err(ubi, \"bad compat\");\n\t\tgoto bad;\n\t}\n\n\tif (vol_id >= UBI_INTERNAL_VOL_START && compat != UBI_COMPAT_DELETE &&\n\t    compat != UBI_COMPAT_RO && compat != UBI_COMPAT_PRESERVE &&\n\t    compat != UBI_COMPAT_REJECT) {\n\t\tubi_err(ubi, \"bad compat\");\n\t\tgoto bad;\n\t}\n\n\tif (vol_type != UBI_VID_DYNAMIC && vol_type != UBI_VID_STATIC) {\n\t\tubi_err(ubi, \"bad vol_type\");\n\t\tgoto bad;\n\t}\n\n\tif (data_pad >= ubi->leb_size / 2) {\n\t\tubi_err(ubi, \"bad data_pad\");\n\t\tgoto bad;\n\t}\n\n\tif (data_size > ubi->leb_size) {\n\t\tubi_err(ubi, \"bad data_size\");\n\t\tgoto bad;\n\t}\n\n\tif (vol_type == UBI_VID_STATIC) {\n\t\t \n\t\tif (used_ebs == 0) {\n\t\t\tubi_err(ubi, \"zero used_ebs\");\n\t\t\tgoto bad;\n\t\t}\n\t\tif (data_size == 0) {\n\t\t\tubi_err(ubi, \"zero data_size\");\n\t\t\tgoto bad;\n\t\t}\n\t\tif (lnum < used_ebs - 1) {\n\t\t\tif (data_size != usable_leb_size) {\n\t\t\t\tubi_err(ubi, \"bad data_size\");\n\t\t\t\tgoto bad;\n\t\t\t}\n\t\t} else if (lnum > used_ebs - 1) {\n\t\t\tubi_err(ubi, \"too high lnum\");\n\t\t\tgoto bad;\n\t\t}\n\t} else {\n\t\tif (copy_flag == 0) {\n\t\t\tif (data_crc != 0) {\n\t\t\t\tubi_err(ubi, \"non-zero data CRC\");\n\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (data_size != 0) {\n\t\t\t\tubi_err(ubi, \"non-zero data_size\");\n\t\t\t\tgoto bad;\n\t\t\t}\n\t\t} else {\n\t\t\tif (data_size == 0) {\n\t\t\t\tubi_err(ubi, \"zero data_size of copy\");\n\t\t\t\tgoto bad;\n\t\t\t}\n\t\t}\n\t\tif (used_ebs != 0) {\n\t\t\tubi_err(ubi, \"bad used_ebs\");\n\t\t\tgoto bad;\n\t\t}\n\t}\n\n\treturn 0;\n\nbad:\n\tubi_err(ubi, \"bad VID header\");\n\tubi_dump_vid_hdr(vid_hdr);\n\tdump_stack();\n\treturn 1;\n}\n\n \nint ubi_io_read_vid_hdr(struct ubi_device *ubi, int pnum,\n\t\t\tstruct ubi_vid_io_buf *vidb, int verbose)\n{\n\tint err, read_err;\n\tuint32_t crc, magic, hdr_crc;\n\tstruct ubi_vid_hdr *vid_hdr = ubi_get_vid_hdr(vidb);\n\tvoid *p = vidb->buffer;\n\n\tdbg_io(\"read VID header from PEB %d\", pnum);\n\tubi_assert(pnum >= 0 &&  pnum < ubi->peb_count);\n\n\tread_err = ubi_io_read(ubi, p, pnum, ubi->vid_hdr_aloffset,\n\t\t\t  ubi->vid_hdr_shift + UBI_VID_HDR_SIZE);\n\tif (read_err && read_err != UBI_IO_BITFLIPS && !mtd_is_eccerr(read_err))\n\t\treturn read_err;\n\n\tmagic = be32_to_cpu(vid_hdr->magic);\n\tif (magic != UBI_VID_HDR_MAGIC) {\n\t\tif (mtd_is_eccerr(read_err))\n\t\t\treturn UBI_IO_BAD_HDR_EBADMSG;\n\n\t\tif (ubi_check_pattern(vid_hdr, 0xFF, UBI_VID_HDR_SIZE)) {\n\t\t\tif (verbose)\n\t\t\t\tubi_warn(ubi, \"no VID header found at PEB %d, only 0xFF bytes\",\n\t\t\t\t\t pnum);\n\t\t\tdbg_bld(\"no VID header found at PEB %d, only 0xFF bytes\",\n\t\t\t\tpnum);\n\t\t\tif (!read_err)\n\t\t\t\treturn UBI_IO_FF;\n\t\t\telse\n\t\t\t\treturn UBI_IO_FF_BITFLIPS;\n\t\t}\n\n\t\tif (verbose) {\n\t\t\tubi_warn(ubi, \"bad magic number at PEB %d: %08x instead of %08x\",\n\t\t\t\t pnum, magic, UBI_VID_HDR_MAGIC);\n\t\t\tubi_dump_vid_hdr(vid_hdr);\n\t\t}\n\t\tdbg_bld(\"bad magic number at PEB %d: %08x instead of %08x\",\n\t\t\tpnum, magic, UBI_VID_HDR_MAGIC);\n\t\treturn UBI_IO_BAD_HDR;\n\t}\n\n\tcrc = crc32(UBI_CRC32_INIT, vid_hdr, UBI_VID_HDR_SIZE_CRC);\n\thdr_crc = be32_to_cpu(vid_hdr->hdr_crc);\n\n\tif (hdr_crc != crc) {\n\t\tif (verbose) {\n\t\t\tubi_warn(ubi, \"bad CRC at PEB %d, calculated %#08x, read %#08x\",\n\t\t\t\t pnum, crc, hdr_crc);\n\t\t\tubi_dump_vid_hdr(vid_hdr);\n\t\t}\n\t\tdbg_bld(\"bad CRC at PEB %d, calculated %#08x, read %#08x\",\n\t\t\tpnum, crc, hdr_crc);\n\t\tif (!read_err)\n\t\t\treturn UBI_IO_BAD_HDR;\n\t\telse\n\t\t\treturn UBI_IO_BAD_HDR_EBADMSG;\n\t}\n\n\terr = validate_vid_hdr(ubi, vid_hdr);\n\tif (err) {\n\t\tubi_err(ubi, \"validation failed for PEB %d\", pnum);\n\t\treturn -EINVAL;\n\t}\n\n\treturn read_err ? UBI_IO_BITFLIPS : 0;\n}\n\n \nint ubi_io_write_vid_hdr(struct ubi_device *ubi, int pnum,\n\t\t\t struct ubi_vid_io_buf *vidb)\n{\n\tstruct ubi_vid_hdr *vid_hdr = ubi_get_vid_hdr(vidb);\n\tint err;\n\tuint32_t crc;\n\tvoid *p = vidb->buffer;\n\n\tdbg_io(\"write VID header to PEB %d\", pnum);\n\tubi_assert(pnum >= 0 &&  pnum < ubi->peb_count);\n\n\terr = self_check_peb_ec_hdr(ubi, pnum);\n\tif (err)\n\t\treturn err;\n\n\tvid_hdr->magic = cpu_to_be32(UBI_VID_HDR_MAGIC);\n\tvid_hdr->version = UBI_VERSION;\n\tcrc = crc32(UBI_CRC32_INIT, vid_hdr, UBI_VID_HDR_SIZE_CRC);\n\tvid_hdr->hdr_crc = cpu_to_be32(crc);\n\n\terr = self_check_vid_hdr(ubi, pnum, vid_hdr);\n\tif (err)\n\t\treturn err;\n\n\tif (ubi_dbg_power_cut(ubi, POWER_CUT_VID_WRITE))\n\t\treturn -EROFS;\n\n\terr = ubi_io_write(ubi, p, pnum, ubi->vid_hdr_aloffset,\n\t\t\t   ubi->vid_hdr_alsize);\n\treturn err;\n}\n\n \nstatic int self_check_not_bad(const struct ubi_device *ubi, int pnum)\n{\n\tint err;\n\n\tif (!ubi_dbg_chk_io(ubi))\n\t\treturn 0;\n\n\terr = ubi_io_is_bad(ubi, pnum);\n\tif (!err)\n\t\treturn err;\n\n\tubi_err(ubi, \"self-check failed for PEB %d\", pnum);\n\tdump_stack();\n\treturn err > 0 ? -EINVAL : err;\n}\n\n \nstatic int self_check_ec_hdr(const struct ubi_device *ubi, int pnum,\n\t\t\t     const struct ubi_ec_hdr *ec_hdr)\n{\n\tint err;\n\tuint32_t magic;\n\n\tif (!ubi_dbg_chk_io(ubi))\n\t\treturn 0;\n\n\tmagic = be32_to_cpu(ec_hdr->magic);\n\tif (magic != UBI_EC_HDR_MAGIC) {\n\t\tubi_err(ubi, \"bad magic %#08x, must be %#08x\",\n\t\t\tmagic, UBI_EC_HDR_MAGIC);\n\t\tgoto fail;\n\t}\n\n\terr = validate_ec_hdr(ubi, ec_hdr);\n\tif (err) {\n\t\tubi_err(ubi, \"self-check failed for PEB %d\", pnum);\n\t\tgoto fail;\n\t}\n\n\treturn 0;\n\nfail:\n\tubi_dump_ec_hdr(ec_hdr);\n\tdump_stack();\n\treturn -EINVAL;\n}\n\n \nstatic int self_check_peb_ec_hdr(const struct ubi_device *ubi, int pnum)\n{\n\tint err;\n\tuint32_t crc, hdr_crc;\n\tstruct ubi_ec_hdr *ec_hdr;\n\n\tif (!ubi_dbg_chk_io(ubi))\n\t\treturn 0;\n\n\tec_hdr = kzalloc(ubi->ec_hdr_alsize, GFP_NOFS);\n\tif (!ec_hdr)\n\t\treturn -ENOMEM;\n\n\terr = ubi_io_read(ubi, ec_hdr, pnum, 0, UBI_EC_HDR_SIZE);\n\tif (err && err != UBI_IO_BITFLIPS && !mtd_is_eccerr(err))\n\t\tgoto exit;\n\n\tcrc = crc32(UBI_CRC32_INIT, ec_hdr, UBI_EC_HDR_SIZE_CRC);\n\thdr_crc = be32_to_cpu(ec_hdr->hdr_crc);\n\tif (hdr_crc != crc) {\n\t\tubi_err(ubi, \"bad CRC, calculated %#08x, read %#08x\",\n\t\t\tcrc, hdr_crc);\n\t\tubi_err(ubi, \"self-check failed for PEB %d\", pnum);\n\t\tubi_dump_ec_hdr(ec_hdr);\n\t\tdump_stack();\n\t\terr = -EINVAL;\n\t\tgoto exit;\n\t}\n\n\terr = self_check_ec_hdr(ubi, pnum, ec_hdr);\n\nexit:\n\tkfree(ec_hdr);\n\treturn err;\n}\n\n \nstatic int self_check_vid_hdr(const struct ubi_device *ubi, int pnum,\n\t\t\t      const struct ubi_vid_hdr *vid_hdr)\n{\n\tint err;\n\tuint32_t magic;\n\n\tif (!ubi_dbg_chk_io(ubi))\n\t\treturn 0;\n\n\tmagic = be32_to_cpu(vid_hdr->magic);\n\tif (magic != UBI_VID_HDR_MAGIC) {\n\t\tubi_err(ubi, \"bad VID header magic %#08x at PEB %d, must be %#08x\",\n\t\t\tmagic, pnum, UBI_VID_HDR_MAGIC);\n\t\tgoto fail;\n\t}\n\n\terr = validate_vid_hdr(ubi, vid_hdr);\n\tif (err) {\n\t\tubi_err(ubi, \"self-check failed for PEB %d\", pnum);\n\t\tgoto fail;\n\t}\n\n\treturn err;\n\nfail:\n\tubi_err(ubi, \"self-check failed for PEB %d\", pnum);\n\tubi_dump_vid_hdr(vid_hdr);\n\tdump_stack();\n\treturn -EINVAL;\n\n}\n\n \nstatic int self_check_peb_vid_hdr(const struct ubi_device *ubi, int pnum)\n{\n\tint err;\n\tuint32_t crc, hdr_crc;\n\tstruct ubi_vid_io_buf *vidb;\n\tstruct ubi_vid_hdr *vid_hdr;\n\tvoid *p;\n\n\tif (!ubi_dbg_chk_io(ubi))\n\t\treturn 0;\n\n\tvidb = ubi_alloc_vid_buf(ubi, GFP_NOFS);\n\tif (!vidb)\n\t\treturn -ENOMEM;\n\n\tvid_hdr = ubi_get_vid_hdr(vidb);\n\tp = vidb->buffer;\n\terr = ubi_io_read(ubi, p, pnum, ubi->vid_hdr_aloffset,\n\t\t\t  ubi->vid_hdr_alsize);\n\tif (err && err != UBI_IO_BITFLIPS && !mtd_is_eccerr(err))\n\t\tgoto exit;\n\n\tcrc = crc32(UBI_CRC32_INIT, vid_hdr, UBI_VID_HDR_SIZE_CRC);\n\thdr_crc = be32_to_cpu(vid_hdr->hdr_crc);\n\tif (hdr_crc != crc) {\n\t\tubi_err(ubi, \"bad VID header CRC at PEB %d, calculated %#08x, read %#08x\",\n\t\t\tpnum, crc, hdr_crc);\n\t\tubi_err(ubi, \"self-check failed for PEB %d\", pnum);\n\t\tubi_dump_vid_hdr(vid_hdr);\n\t\tdump_stack();\n\t\terr = -EINVAL;\n\t\tgoto exit;\n\t}\n\n\terr = self_check_vid_hdr(ubi, pnum, vid_hdr);\n\nexit:\n\tubi_free_vid_buf(vidb);\n\treturn err;\n}\n\n \nstatic int self_check_write(struct ubi_device *ubi, const void *buf, int pnum,\n\t\t\t    int offset, int len)\n{\n\tint err, i;\n\tsize_t read;\n\tvoid *buf1;\n\tloff_t addr = (loff_t)pnum * ubi->peb_size + offset;\n\n\tif (!ubi_dbg_chk_io(ubi))\n\t\treturn 0;\n\n\tbuf1 = __vmalloc(len, GFP_NOFS);\n\tif (!buf1) {\n\t\tubi_err(ubi, \"cannot allocate memory to check writes\");\n\t\treturn 0;\n\t}\n\n\terr = mtd_read(ubi->mtd, addr, len, &read, buf1);\n\tif (err && !mtd_is_bitflip(err))\n\t\tgoto out_free;\n\n\tfor (i = 0; i < len; i++) {\n\t\tuint8_t c = ((uint8_t *)buf)[i];\n\t\tuint8_t c1 = ((uint8_t *)buf1)[i];\n\t\tint dump_len;\n\n\t\tif (c == c1)\n\t\t\tcontinue;\n\n\t\tubi_err(ubi, \"self-check failed for PEB %d:%d, len %d\",\n\t\t\tpnum, offset, len);\n\t\tubi_msg(ubi, \"data differ at position %d\", i);\n\t\tdump_len = max_t(int, 128, len - i);\n\t\tubi_msg(ubi, \"hex dump of the original buffer from %d to %d\",\n\t\t\ti, i + dump_len);\n\t\tprint_hex_dump(KERN_DEBUG, \"\", DUMP_PREFIX_OFFSET, 32, 1,\n\t\t\t       buf + i, dump_len, 1);\n\t\tubi_msg(ubi, \"hex dump of the read buffer from %d to %d\",\n\t\t\ti, i + dump_len);\n\t\tprint_hex_dump(KERN_DEBUG, \"\", DUMP_PREFIX_OFFSET, 32, 1,\n\t\t\t       buf1 + i, dump_len, 1);\n\t\tdump_stack();\n\t\terr = -EINVAL;\n\t\tgoto out_free;\n\t}\n\n\tvfree(buf1);\n\treturn 0;\n\nout_free:\n\tvfree(buf1);\n\treturn err;\n}\n\n \nint ubi_self_check_all_ff(struct ubi_device *ubi, int pnum, int offset, int len)\n{\n\tsize_t read;\n\tint err;\n\tvoid *buf;\n\tloff_t addr = (loff_t)pnum * ubi->peb_size + offset;\n\n\tif (!ubi_dbg_chk_io(ubi))\n\t\treturn 0;\n\n\tbuf = __vmalloc(len, GFP_NOFS);\n\tif (!buf) {\n\t\tubi_err(ubi, \"cannot allocate memory to check for 0xFFs\");\n\t\treturn 0;\n\t}\n\n\terr = mtd_read(ubi->mtd, addr, len, &read, buf);\n\tif (err && !mtd_is_bitflip(err)) {\n\t\tubi_err(ubi, \"err %d while reading %d bytes from PEB %d:%d, read %zd bytes\",\n\t\t\terr, len, pnum, offset, read);\n\t\tgoto error;\n\t}\n\n\terr = ubi_check_pattern(buf, 0xFF, len);\n\tif (err == 0) {\n\t\tubi_err(ubi, \"flash region at PEB %d:%d, length %d does not contain all 0xFF bytes\",\n\t\t\tpnum, offset, len);\n\t\tgoto fail;\n\t}\n\n\tvfree(buf);\n\treturn 0;\n\nfail:\n\tubi_err(ubi, \"self-check failed for PEB %d\", pnum);\n\tubi_msg(ubi, \"hex dump of the %d-%d region\", offset, offset + len);\n\tprint_hex_dump(KERN_DEBUG, \"\", DUMP_PREFIX_OFFSET, 32, 1, buf, len, 1);\n\terr = -EINVAL;\nerror:\n\tdump_stack();\n\tvfree(buf);\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}