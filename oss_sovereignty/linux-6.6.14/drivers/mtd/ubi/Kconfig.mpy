{
  "module_name": "Kconfig",
  "hash_id": "71e79731b5a663ededdb64fc6c7cce985380f97755b9076d76c0ec36b3371be3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/ubi/Kconfig",
  "human_readable_source": "# SPDX-License-Identifier: GPL-2.0-only\nmenuconfig MTD_UBI\n\ttristate \"Enable UBI - Unsorted block images\"\n\tselect CRC32\n\thelp\n\t  UBI is a software layer above MTD layer which admits use of LVM-like\n\t  logical volumes on top of MTD devices, hides some complexities of\n\t  flash chips like wear and bad blocks and provides some other useful\n\t  capabilities. Please, consult the MTD web site for more details\n\t  (www.linux-mtd.infradead.org).\n\nif MTD_UBI\n\nconfig MTD_UBI_WL_THRESHOLD\n\tint \"UBI wear-leveling threshold\"\n\tdefault 4096\n\trange 2 65536\n\thelp\n\t  This parameter defines the maximum difference between the highest\n\t  erase counter value and the lowest erase counter value of eraseblocks\n\t  of UBI devices. When this threshold is exceeded, UBI starts performing\n\t  wear leveling by means of moving data from eraseblock with low erase\n\t  counter to eraseblocks with high erase counter.\n\n\t  The default value should be OK for SLC NAND flashes, NOR flashes and\n\t  other flashes which have eraseblock life-cycle 100000 or more.\n\t  However, in case of MLC NAND flashes which typically have eraseblock\n\t  life-cycle less than 10000, the threshold should be lessened (e.g.,\n\t  to 128 or 256, although it does not have to be power of 2).\n\nconfig MTD_UBI_BEB_LIMIT\n\tint \"Maximum expected bad eraseblock count per 1024 eraseblocks\"\n\tdefault 20\n\trange 0 768\n\thelp\n\t  This option specifies the maximum bad physical eraseblocks UBI\n\t  expects on the MTD device (per 1024 eraseblocks). If the underlying\n\t  flash does not admit of bad eraseblocks (e.g. NOR flash), this value\n\t  is ignored.\n\n\t  NAND datasheets often specify the minimum and maximum NVM (Number of\n\t  Valid Blocks) for the flashes' endurance lifetime. The maximum\n\t  expected bad eraseblocks per 1024 eraseblocks then can be calculated\n\t  as \"1024 * (1 - MinNVB / MaxNVB)\", which gives 20 for most NANDs\n\t  (MaxNVB is basically the total count of eraseblocks on the chip).\n\n\t  To put it differently, if this value is 20, UBI will try to reserve\n\t  about 1.9% of physical eraseblocks for bad blocks handling. And that\n\t  will be 1.9% of eraseblocks on the entire NAND chip, not just the MTD\n\t  partition UBI attaches. This means that if you have, say, a NAND\n\t  flash chip admits maximum 40 bad eraseblocks, and it is split on two\n\t  MTD partitions of the same size, UBI will reserve 40 eraseblocks when\n\t  attaching a partition.\n\n\t  This option can be overridden by the \"mtd=\" UBI module parameter or\n\t  by the \"attach\" ioctl.\n\n\t  Leave the default value if unsure.\n\nconfig MTD_UBI_FASTMAP\n\tbool \"UBI Fastmap (Experimental feature)\"\n\tdefault n\n\thelp\n\t   Important: this feature is experimental so far and the on-flash\n\t   format for fastmap may change in the next kernel versions\n\n\t   Fastmap is a mechanism which allows attaching an UBI device\n\t   in nearly constant time. Instead of scanning the whole MTD device it\n\t   only has to locate a checkpoint (called fastmap) on the device.\n\t   The on-flash fastmap contains all information needed to attach\n\t   the device. Using fastmap makes only sense on large devices where\n\t   attaching by scanning takes long. UBI will not automatically install\n\t   a fastmap on old images, but you can set the UBI module parameter\n\t   fm_autoconvert to 1 if you want so. Please note that fastmap-enabled\n\t   images are still usable with UBI implementations without\n\t   fastmap support. On typical flash devices the whole fastmap fits\n\t   into one PEB. UBI will reserve PEBs to hold two fastmaps.\n\n\t   If in doubt, say \"N\".\n\nconfig MTD_UBI_GLUEBI\n\ttristate \"MTD devices emulation driver (gluebi)\"\n\thelp\n\t   This option enables gluebi - an additional driver which emulates MTD\n\t   devices on top of UBI volumes: for each UBI volumes an MTD device is\n\t   created, and all I/O to this MTD device is redirected to the UBI\n\t   volume. This is handy to make MTD-oriented software (like JFFS2)\n\t   work on top of UBI. Do not enable this unless you use legacy\n\t   software.\n\nconfig MTD_UBI_BLOCK\n\tbool \"Read-only block devices on top of UBI volumes\"\n\tdefault n\n\tdepends on BLOCK\n\thelp\n\t   This option enables read-only UBI block devices support. UBI block\n\t   devices will be layered on top of UBI volumes, which means that the\n\t   UBI driver will transparently handle things like bad eraseblocks and\n\t   bit-flips. You can put any block-oriented file system on top of UBI\n\t   volumes in read-only mode (e.g., ext4), but it is probably most\n\t   practical for read-only file systems, like squashfs.\n\n\t   When selected, this feature will be built in the UBI driver.\n\n\t   If in doubt, say \"N\".\n\nendif # MTD_UBI\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}