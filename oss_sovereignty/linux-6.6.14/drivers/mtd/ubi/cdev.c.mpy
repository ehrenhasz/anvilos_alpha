{
  "module_name": "cdev.c",
  "hash_id": "73f238741e755b0d508585c0dc6c2dd29ff8f729b30f1bebdaf24724fead2802",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/ubi/cdev.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/module.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n#include <linux/ioctl.h>\n#include <linux/capability.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/math64.h>\n#include <mtd/ubi-user.h>\n#include \"ubi.h\"\n\n \nstatic int get_exclusive(struct ubi_volume_desc *desc)\n{\n\tint users, err;\n\tstruct ubi_volume *vol = desc->vol;\n\n\tspin_lock(&vol->ubi->volumes_lock);\n\tusers = vol->readers + vol->writers + vol->exclusive + vol->metaonly;\n\tubi_assert(users > 0);\n\tif (users > 1) {\n\t\tubi_err(vol->ubi, \"%d users for volume %d\", users, vol->vol_id);\n\t\terr = -EBUSY;\n\t} else {\n\t\tvol->readers = vol->writers = vol->metaonly = 0;\n\t\tvol->exclusive = 1;\n\t\terr = desc->mode;\n\t\tdesc->mode = UBI_EXCLUSIVE;\n\t}\n\tspin_unlock(&vol->ubi->volumes_lock);\n\n\treturn err;\n}\n\n \nstatic void revoke_exclusive(struct ubi_volume_desc *desc, int mode)\n{\n\tstruct ubi_volume *vol = desc->vol;\n\n\tspin_lock(&vol->ubi->volumes_lock);\n\tubi_assert(vol->readers == 0 && vol->writers == 0 && vol->metaonly == 0);\n\tubi_assert(vol->exclusive == 1 && desc->mode == UBI_EXCLUSIVE);\n\tvol->exclusive = 0;\n\tif (mode == UBI_READONLY)\n\t\tvol->readers = 1;\n\telse if (mode == UBI_READWRITE)\n\t\tvol->writers = 1;\n\telse if (mode == UBI_METAONLY)\n\t\tvol->metaonly = 1;\n\telse\n\t\tvol->exclusive = 1;\n\tspin_unlock(&vol->ubi->volumes_lock);\n\n\tdesc->mode = mode;\n}\n\nstatic int vol_cdev_open(struct inode *inode, struct file *file)\n{\n\tstruct ubi_volume_desc *desc;\n\tint vol_id = iminor(inode) - 1, mode, ubi_num;\n\n\tubi_num = ubi_major2num(imajor(inode));\n\tif (ubi_num < 0)\n\t\treturn ubi_num;\n\n\tif (file->f_mode & FMODE_WRITE)\n\t\tmode = UBI_READWRITE;\n\telse\n\t\tmode = UBI_READONLY;\n\n\tdbg_gen(\"open device %d, volume %d, mode %d\",\n\t\tubi_num, vol_id, mode);\n\n\tdesc = ubi_open_volume(ubi_num, vol_id, mode);\n\tif (IS_ERR(desc))\n\t\treturn PTR_ERR(desc);\n\n\tfile->private_data = desc;\n\treturn 0;\n}\n\nstatic int vol_cdev_release(struct inode *inode, struct file *file)\n{\n\tstruct ubi_volume_desc *desc = file->private_data;\n\tstruct ubi_volume *vol = desc->vol;\n\n\tdbg_gen(\"release device %d, volume %d, mode %d\",\n\t\tvol->ubi->ubi_num, vol->vol_id, desc->mode);\n\n\tif (vol->updating) {\n\t\tubi_warn(vol->ubi, \"update of volume %d not finished, volume is damaged\",\n\t\t\t vol->vol_id);\n\t\tubi_assert(!vol->changing_leb);\n\t\tvol->updating = 0;\n\t\tvfree(vol->upd_buf);\n\t} else if (vol->changing_leb) {\n\t\tdbg_gen(\"only %lld of %lld bytes received for atomic LEB change for volume %d:%d, cancel\",\n\t\t\tvol->upd_received, vol->upd_bytes, vol->ubi->ubi_num,\n\t\t\tvol->vol_id);\n\t\tvol->changing_leb = 0;\n\t\tvfree(vol->upd_buf);\n\t}\n\n\tubi_close_volume(desc);\n\treturn 0;\n}\n\nstatic loff_t vol_cdev_llseek(struct file *file, loff_t offset, int origin)\n{\n\tstruct ubi_volume_desc *desc = file->private_data;\n\tstruct ubi_volume *vol = desc->vol;\n\n\tif (vol->updating) {\n\t\t \n\t\tubi_err(vol->ubi, \"updating\");\n\t\treturn -EBUSY;\n\t}\n\n\treturn fixed_size_llseek(file, offset, origin, vol->used_bytes);\n}\n\nstatic int vol_cdev_fsync(struct file *file, loff_t start, loff_t end,\n\t\t\t  int datasync)\n{\n\tstruct ubi_volume_desc *desc = file->private_data;\n\tstruct ubi_device *ubi = desc->vol->ubi;\n\tstruct inode *inode = file_inode(file);\n\tint err;\n\tinode_lock(inode);\n\terr = ubi_sync(ubi->ubi_num);\n\tinode_unlock(inode);\n\treturn err;\n}\n\n\nstatic ssize_t vol_cdev_read(struct file *file, __user char *buf, size_t count,\n\t\t\t     loff_t *offp)\n{\n\tstruct ubi_volume_desc *desc = file->private_data;\n\tstruct ubi_volume *vol = desc->vol;\n\tstruct ubi_device *ubi = vol->ubi;\n\tint err, lnum, off, len,  tbuf_size;\n\tsize_t count_save = count;\n\tvoid *tbuf;\n\n\tdbg_gen(\"read %zd bytes from offset %lld of volume %d\",\n\t\tcount, *offp, vol->vol_id);\n\n\tif (vol->updating) {\n\t\tubi_err(vol->ubi, \"updating\");\n\t\treturn -EBUSY;\n\t}\n\tif (vol->upd_marker) {\n\t\tubi_err(vol->ubi, \"damaged volume, update marker is set\");\n\t\treturn -EBADF;\n\t}\n\tif (*offp == vol->used_bytes || count == 0)\n\t\treturn 0;\n\n\tif (vol->corrupted)\n\t\tdbg_gen(\"read from corrupted volume %d\", vol->vol_id);\n\n\tif (*offp + count > vol->used_bytes)\n\t\tcount_save = count = vol->used_bytes - *offp;\n\n\ttbuf_size = vol->usable_leb_size;\n\tif (count < tbuf_size)\n\t\ttbuf_size = ALIGN(count, ubi->min_io_size);\n\ttbuf = vmalloc(tbuf_size);\n\tif (!tbuf)\n\t\treturn -ENOMEM;\n\n\tlen = count > tbuf_size ? tbuf_size : count;\n\tlnum = div_u64_rem(*offp, vol->usable_leb_size, &off);\n\n\tdo {\n\t\tcond_resched();\n\n\t\tif (off + len >= vol->usable_leb_size)\n\t\t\tlen = vol->usable_leb_size - off;\n\n\t\terr = ubi_eba_read_leb(ubi, vol, lnum, tbuf, off, len, 0);\n\t\tif (err)\n\t\t\tbreak;\n\n\t\toff += len;\n\t\tif (off == vol->usable_leb_size) {\n\t\t\tlnum += 1;\n\t\t\toff -= vol->usable_leb_size;\n\t\t}\n\n\t\tcount -= len;\n\t\t*offp += len;\n\n\t\terr = copy_to_user(buf, tbuf, len);\n\t\tif (err) {\n\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tbuf += len;\n\t\tlen = count > tbuf_size ? tbuf_size : count;\n\t} while (count);\n\n\tvfree(tbuf);\n\treturn err ? err : count_save - count;\n}\n\n \nstatic ssize_t vol_cdev_direct_write(struct file *file, const char __user *buf,\n\t\t\t\t     size_t count, loff_t *offp)\n{\n\tstruct ubi_volume_desc *desc = file->private_data;\n\tstruct ubi_volume *vol = desc->vol;\n\tstruct ubi_device *ubi = vol->ubi;\n\tint lnum, off, len, tbuf_size, err = 0;\n\tsize_t count_save = count;\n\tchar *tbuf;\n\n\tif (!vol->direct_writes)\n\t\treturn -EPERM;\n\n\tdbg_gen(\"requested: write %zd bytes to offset %lld of volume %u\",\n\t\tcount, *offp, vol->vol_id);\n\n\tif (vol->vol_type == UBI_STATIC_VOLUME)\n\t\treturn -EROFS;\n\n\tlnum = div_u64_rem(*offp, vol->usable_leb_size, &off);\n\tif (off & (ubi->min_io_size - 1)) {\n\t\tubi_err(ubi, \"unaligned position\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (*offp + count > vol->used_bytes)\n\t\tcount_save = count = vol->used_bytes - *offp;\n\n\t \n\tif (count & (ubi->min_io_size - 1)) {\n\t\tubi_err(ubi, \"unaligned write length\");\n\t\treturn -EINVAL;\n\t}\n\n\ttbuf_size = vol->usable_leb_size;\n\tif (count < tbuf_size)\n\t\ttbuf_size = ALIGN(count, ubi->min_io_size);\n\ttbuf = vmalloc(tbuf_size);\n\tif (!tbuf)\n\t\treturn -ENOMEM;\n\n\tlen = count > tbuf_size ? tbuf_size : count;\n\n\twhile (count) {\n\t\tcond_resched();\n\n\t\tif (off + len >= vol->usable_leb_size)\n\t\t\tlen = vol->usable_leb_size - off;\n\n\t\terr = copy_from_user(tbuf, buf, len);\n\t\tif (err) {\n\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\terr = ubi_eba_write_leb(ubi, vol, lnum, tbuf, off, len);\n\t\tif (err)\n\t\t\tbreak;\n\n\t\toff += len;\n\t\tif (off == vol->usable_leb_size) {\n\t\t\tlnum += 1;\n\t\t\toff -= vol->usable_leb_size;\n\t\t}\n\n\t\tcount -= len;\n\t\t*offp += len;\n\t\tbuf += len;\n\t\tlen = count > tbuf_size ? tbuf_size : count;\n\t}\n\n\tvfree(tbuf);\n\treturn err ? err : count_save - count;\n}\n\nstatic ssize_t vol_cdev_write(struct file *file, const char __user *buf,\n\t\t\t      size_t count, loff_t *offp)\n{\n\tint err = 0;\n\tstruct ubi_volume_desc *desc = file->private_data;\n\tstruct ubi_volume *vol = desc->vol;\n\tstruct ubi_device *ubi = vol->ubi;\n\n\tif (!vol->updating && !vol->changing_leb)\n\t\treturn vol_cdev_direct_write(file, buf, count, offp);\n\n\tif (vol->updating)\n\t\terr = ubi_more_update_data(ubi, vol, buf, count);\n\telse\n\t\terr = ubi_more_leb_change_data(ubi, vol, buf, count);\n\n\tif (err < 0) {\n\t\tubi_err(ubi, \"cannot accept more %zd bytes of data, error %d\",\n\t\t\tcount, err);\n\t\treturn err;\n\t}\n\n\tif (err) {\n\t\t \n\t\tcount = err;\n\n\t\tif (vol->changing_leb) {\n\t\t\trevoke_exclusive(desc, UBI_READWRITE);\n\t\t\treturn count;\n\t\t}\n\n\t\t \n\t\terr = ubi_check_volume(ubi, vol->vol_id);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tif (err) {\n\t\t\tubi_warn(ubi, \"volume %d on UBI device %d is corrupted\",\n\t\t\t\t vol->vol_id, ubi->ubi_num);\n\t\t\tvol->corrupted = 1;\n\t\t}\n\t\tvol->checked = 1;\n\t\tubi_volume_notify(ubi, vol, UBI_VOLUME_UPDATED);\n\t\trevoke_exclusive(desc, UBI_READWRITE);\n\t}\n\n\treturn count;\n}\n\nstatic long vol_cdev_ioctl(struct file *file, unsigned int cmd,\n\t\t\t   unsigned long arg)\n{\n\tint err = 0;\n\tstruct ubi_volume_desc *desc = file->private_data;\n\tstruct ubi_volume *vol = desc->vol;\n\tstruct ubi_device *ubi = vol->ubi;\n\tvoid __user *argp = (void __user *)arg;\n\n\tswitch (cmd) {\n\t \n\tcase UBI_IOCVOLUP:\n\t{\n\t\tint64_t bytes, rsvd_bytes;\n\n\t\tif (!capable(CAP_SYS_RESOURCE)) {\n\t\t\terr = -EPERM;\n\t\t\tbreak;\n\t\t}\n\n\t\terr = copy_from_user(&bytes, argp, sizeof(int64_t));\n\t\tif (err) {\n\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (desc->mode == UBI_READONLY) {\n\t\t\terr = -EROFS;\n\t\t\tbreak;\n\t\t}\n\n\t\trsvd_bytes = (long long)vol->reserved_pebs *\n\t\t\t\t\tvol->usable_leb_size;\n\t\tif (bytes < 0 || bytes > rsvd_bytes) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\terr = get_exclusive(desc);\n\t\tif (err < 0)\n\t\t\tbreak;\n\n\t\terr = ubi_start_update(ubi, vol, bytes);\n\t\tif (bytes == 0) {\n\t\t\tubi_volume_notify(ubi, vol, UBI_VOLUME_UPDATED);\n\t\t\trevoke_exclusive(desc, UBI_READWRITE);\n\t\t}\n\t\tbreak;\n\t}\n\n\t \n\tcase UBI_IOCEBCH:\n\t{\n\t\tstruct ubi_leb_change_req req;\n\n\t\terr = copy_from_user(&req, argp,\n\t\t\t\t     sizeof(struct ubi_leb_change_req));\n\t\tif (err) {\n\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (desc->mode == UBI_READONLY ||\n\t\t    vol->vol_type == UBI_STATIC_VOLUME) {\n\t\t\terr = -EROFS;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\terr = -EINVAL;\n\t\tif (!ubi_leb_valid(vol, req.lnum) ||\n\t\t    req.bytes < 0 || req.bytes > vol->usable_leb_size)\n\t\t\tbreak;\n\n\t\terr = get_exclusive(desc);\n\t\tif (err < 0)\n\t\t\tbreak;\n\n\t\terr = ubi_start_leb_change(ubi, vol, &req);\n\t\tif (req.bytes == 0)\n\t\t\trevoke_exclusive(desc, UBI_READWRITE);\n\t\tbreak;\n\t}\n\n\t \n\tcase UBI_IOCEBER:\n\t{\n\t\tint32_t lnum;\n\n\t\terr = get_user(lnum, (__user int32_t *)argp);\n\t\tif (err) {\n\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (desc->mode == UBI_READONLY ||\n\t\t    vol->vol_type == UBI_STATIC_VOLUME) {\n\t\t\terr = -EROFS;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!ubi_leb_valid(vol, lnum)) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tdbg_gen(\"erase LEB %d:%d\", vol->vol_id, lnum);\n\t\terr = ubi_eba_unmap_leb(ubi, vol, lnum);\n\t\tif (err)\n\t\t\tbreak;\n\n\t\terr = ubi_wl_flush(ubi, UBI_ALL, UBI_ALL);\n\t\tbreak;\n\t}\n\n\t \n\tcase UBI_IOCEBMAP:\n\t{\n\t\tstruct ubi_map_req req;\n\n\t\terr = copy_from_user(&req, argp, sizeof(struct ubi_map_req));\n\t\tif (err) {\n\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\terr = ubi_leb_map(desc, req.lnum);\n\t\tbreak;\n\t}\n\n\t \n\tcase UBI_IOCEBUNMAP:\n\t{\n\t\tint32_t lnum;\n\n\t\terr = get_user(lnum, (__user int32_t *)argp);\n\t\tif (err) {\n\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\terr = ubi_leb_unmap(desc, lnum);\n\t\tbreak;\n\t}\n\n\t \n\tcase UBI_IOCEBISMAP:\n\t{\n\t\tint32_t lnum;\n\n\t\terr = get_user(lnum, (__user int32_t *)argp);\n\t\tif (err) {\n\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\terr = ubi_is_mapped(desc, lnum);\n\t\tbreak;\n\t}\n\n\t \n\tcase UBI_IOCSETVOLPROP:\n\t{\n\t\tstruct ubi_set_vol_prop_req req;\n\n\t\terr = copy_from_user(&req, argp,\n\t\t\t\t     sizeof(struct ubi_set_vol_prop_req));\n\t\tif (err) {\n\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tswitch (req.property) {\n\t\tcase UBI_VOL_PROP_DIRECT_WRITE:\n\t\t\tmutex_lock(&ubi->device_mutex);\n\t\t\tdesc->vol->direct_writes = !!req.value;\n\t\t\tmutex_unlock(&ubi->device_mutex);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n\n\t \n\tcase UBI_IOCVOLCRBLK:\n\t{\n\t\tstruct ubi_volume_info vi;\n\n\t\tubi_get_volume_info(desc, &vi);\n\t\terr = ubiblock_create(&vi);\n\t\tbreak;\n\t}\n\n\t \n\tcase UBI_IOCVOLRMBLK:\n\t{\n\t\tstruct ubi_volume_info vi;\n\n\t\tubi_get_volume_info(desc, &vi);\n\t\terr = ubiblock_remove(&vi);\n\t\tbreak;\n\t}\n\n\tdefault:\n\t\terr = -ENOTTY;\n\t\tbreak;\n\t}\n\treturn err;\n}\n\n \nstatic int verify_mkvol_req(const struct ubi_device *ubi,\n\t\t\t    const struct ubi_mkvol_req *req)\n{\n\tint n, err = -EINVAL;\n\n\tif (req->bytes < 0 || req->alignment < 0 || req->vol_type < 0 ||\n\t    req->name_len < 0)\n\t\tgoto bad;\n\n\tif ((req->vol_id < 0 || req->vol_id >= ubi->vtbl_slots) &&\n\t    req->vol_id != UBI_VOL_NUM_AUTO)\n\t\tgoto bad;\n\n\tif (req->alignment == 0)\n\t\tgoto bad;\n\n\tif (req->bytes == 0)\n\t\tgoto bad;\n\n\tif (req->vol_type != UBI_DYNAMIC_VOLUME &&\n\t    req->vol_type != UBI_STATIC_VOLUME)\n\t\tgoto bad;\n\n\tif (req->flags & ~UBI_VOL_VALID_FLGS)\n\t\tgoto bad;\n\n\tif (req->flags & UBI_VOL_SKIP_CRC_CHECK_FLG &&\n\t    req->vol_type != UBI_STATIC_VOLUME)\n\t\tgoto bad;\n\n\tif (req->alignment > ubi->leb_size)\n\t\tgoto bad;\n\n\tn = req->alignment & (ubi->min_io_size - 1);\n\tif (req->alignment != 1 && n)\n\t\tgoto bad;\n\n\tif (!req->name[0] || !req->name_len)\n\t\tgoto bad;\n\n\tif (req->name_len > UBI_VOL_NAME_MAX) {\n\t\terr = -ENAMETOOLONG;\n\t\tgoto bad;\n\t}\n\n\tn = strnlen(req->name, req->name_len + 1);\n\tif (n != req->name_len)\n\t\tgoto bad;\n\n\treturn 0;\n\nbad:\n\tubi_err(ubi, \"bad volume creation request\");\n\tubi_dump_mkvol_req(req);\n\treturn err;\n}\n\n \nstatic int verify_rsvol_req(const struct ubi_device *ubi,\n\t\t\t    const struct ubi_rsvol_req *req)\n{\n\tif (req->bytes <= 0)\n\t\treturn -EINVAL;\n\n\tif (req->vol_id < 0 || req->vol_id >= ubi->vtbl_slots)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\n \nstatic int rename_volumes(struct ubi_device *ubi,\n\t\t\t  struct ubi_rnvol_req *req)\n{\n\tint i, n, err;\n\tstruct list_head rename_list;\n\tstruct ubi_rename_entry *re, *re1;\n\n\tif (req->count < 0 || req->count > UBI_MAX_RNVOL)\n\t\treturn -EINVAL;\n\n\tif (req->count == 0)\n\t\treturn 0;\n\n\t \n\tfor (i = 0; i < req->count; i++) {\n\t\tif (req->ents[i].vol_id < 0 ||\n\t\t    req->ents[i].vol_id >= ubi->vtbl_slots)\n\t\t\treturn -EINVAL;\n\t\tif (req->ents[i].name_len < 0)\n\t\t\treturn -EINVAL;\n\t\tif (req->ents[i].name_len > UBI_VOL_NAME_MAX)\n\t\t\treturn -ENAMETOOLONG;\n\t\treq->ents[i].name[req->ents[i].name_len] = '\\0';\n\t\tn = strlen(req->ents[i].name);\n\t\tif (n != req->ents[i].name_len)\n\t\t\treturn -EINVAL;\n\t}\n\n\t \n\tfor (i = 0; i < req->count - 1; i++) {\n\t\tfor (n = i + 1; n < req->count; n++) {\n\t\t\tif (req->ents[i].vol_id == req->ents[n].vol_id) {\n\t\t\t\tubi_err(ubi, \"duplicated volume id %d\",\n\t\t\t\t\treq->ents[i].vol_id);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tif (!strcmp(req->ents[i].name, req->ents[n].name)) {\n\t\t\t\tubi_err(ubi, \"duplicated volume name \\\"%s\\\"\",\n\t\t\t\t\treq->ents[i].name);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tINIT_LIST_HEAD(&rename_list);\n\tfor (i = 0; i < req->count; i++) {\n\t\tint vol_id = req->ents[i].vol_id;\n\t\tint name_len = req->ents[i].name_len;\n\t\tconst char *name = req->ents[i].name;\n\n\t\tre = kzalloc(sizeof(struct ubi_rename_entry), GFP_KERNEL);\n\t\tif (!re) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out_free;\n\t\t}\n\n\t\tre->desc = ubi_open_volume(ubi->ubi_num, vol_id, UBI_METAONLY);\n\t\tif (IS_ERR(re->desc)) {\n\t\t\terr = PTR_ERR(re->desc);\n\t\t\tubi_err(ubi, \"cannot open volume %d, error %d\",\n\t\t\t\tvol_id, err);\n\t\t\tkfree(re);\n\t\t\tgoto out_free;\n\t\t}\n\n\t\t \n\t\tif (re->desc->vol->name_len == name_len &&\n\t\t    !memcmp(re->desc->vol->name, name, name_len)) {\n\t\t\tubi_close_volume(re->desc);\n\t\t\tkfree(re);\n\t\t\tcontinue;\n\t\t}\n\n\t\tre->new_name_len = name_len;\n\t\tmemcpy(re->new_name, name, name_len);\n\t\tlist_add_tail(&re->list, &rename_list);\n\t\tdbg_gen(\"will rename volume %d from \\\"%s\\\" to \\\"%s\\\"\",\n\t\t\tvol_id, re->desc->vol->name, name);\n\t}\n\n\tif (list_empty(&rename_list))\n\t\treturn 0;\n\n\t \n\tlist_for_each_entry(re, &rename_list, list) {\n\t\tstruct ubi_volume_desc *desc;\n\t\tint no_remove_needed = 0;\n\n\t\t \n\t\tlist_for_each_entry(re1, &rename_list, list) {\n\t\t\tif (re->new_name_len == re1->desc->vol->name_len &&\n\t\t\t    !memcmp(re->new_name, re1->desc->vol->name,\n\t\t\t\t    re1->desc->vol->name_len)) {\n\t\t\t\tno_remove_needed = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (no_remove_needed)\n\t\t\tcontinue;\n\n\t\t \n\t\tdesc = ubi_open_volume_nm(ubi->ubi_num, re->new_name,\n\t\t\t\t\t  UBI_EXCLUSIVE);\n\t\tif (IS_ERR(desc)) {\n\t\t\terr = PTR_ERR(desc);\n\t\t\tif (err == -ENODEV)\n\t\t\t\t \n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tubi_err(ubi, \"cannot open volume \\\"%s\\\", error %d\",\n\t\t\t\tre->new_name, err);\n\t\t\tgoto out_free;\n\t\t}\n\n\t\tre1 = kzalloc(sizeof(struct ubi_rename_entry), GFP_KERNEL);\n\t\tif (!re1) {\n\t\t\terr = -ENOMEM;\n\t\t\tubi_close_volume(desc);\n\t\t\tgoto out_free;\n\t\t}\n\n\t\tre1->remove = 1;\n\t\tre1->desc = desc;\n\t\tlist_add(&re1->list, &rename_list);\n\t\tdbg_gen(\"will remove volume %d, name \\\"%s\\\"\",\n\t\t\tre1->desc->vol->vol_id, re1->desc->vol->name);\n\t}\n\n\tmutex_lock(&ubi->device_mutex);\n\terr = ubi_rename_volumes(ubi, &rename_list);\n\tmutex_unlock(&ubi->device_mutex);\n\nout_free:\n\tlist_for_each_entry_safe(re, re1, &rename_list, list) {\n\t\tubi_close_volume(re->desc);\n\t\tlist_del(&re->list);\n\t\tkfree(re);\n\t}\n\treturn err;\n}\n\nstatic long ubi_cdev_ioctl(struct file *file, unsigned int cmd,\n\t\t\t   unsigned long arg)\n{\n\tint err = 0;\n\tstruct ubi_device *ubi;\n\tstruct ubi_volume_desc *desc;\n\tvoid __user *argp = (void __user *)arg;\n\n\tif (!capable(CAP_SYS_RESOURCE))\n\t\treturn -EPERM;\n\n\tubi = ubi_get_by_major(imajor(file->f_mapping->host));\n\tif (!ubi)\n\t\treturn -ENODEV;\n\n\tswitch (cmd) {\n\t \n\tcase UBI_IOCMKVOL:\n\t{\n\t\tstruct ubi_mkvol_req req;\n\n\t\tdbg_gen(\"create volume\");\n\t\terr = copy_from_user(&req, argp, sizeof(struct ubi_mkvol_req));\n\t\tif (err) {\n\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\terr = verify_mkvol_req(ubi, &req);\n\t\tif (err)\n\t\t\tbreak;\n\n\t\tmutex_lock(&ubi->device_mutex);\n\t\terr = ubi_create_volume(ubi, &req);\n\t\tmutex_unlock(&ubi->device_mutex);\n\t\tif (err)\n\t\t\tbreak;\n\n\t\terr = put_user(req.vol_id, (__user int32_t *)argp);\n\t\tif (err)\n\t\t\terr = -EFAULT;\n\n\t\tbreak;\n\t}\n\n\t \n\tcase UBI_IOCRMVOL:\n\t{\n\t\tint vol_id;\n\n\t\tdbg_gen(\"remove volume\");\n\t\terr = get_user(vol_id, (__user int32_t *)argp);\n\t\tif (err) {\n\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tdesc = ubi_open_volume(ubi->ubi_num, vol_id, UBI_EXCLUSIVE);\n\t\tif (IS_ERR(desc)) {\n\t\t\terr = PTR_ERR(desc);\n\t\t\tbreak;\n\t\t}\n\n\t\tmutex_lock(&ubi->device_mutex);\n\t\terr = ubi_remove_volume(desc, 0);\n\t\tmutex_unlock(&ubi->device_mutex);\n\n\t\t \n\t\tubi_close_volume(desc);\n\t\tbreak;\n\t}\n\n\t \n\tcase UBI_IOCRSVOL:\n\t{\n\t\tint pebs;\n\t\tstruct ubi_rsvol_req req;\n\n\t\tdbg_gen(\"re-size volume\");\n\t\terr = copy_from_user(&req, argp, sizeof(struct ubi_rsvol_req));\n\t\tif (err) {\n\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\terr = verify_rsvol_req(ubi, &req);\n\t\tif (err)\n\t\t\tbreak;\n\n\t\tdesc = ubi_open_volume(ubi->ubi_num, req.vol_id, UBI_EXCLUSIVE);\n\t\tif (IS_ERR(desc)) {\n\t\t\terr = PTR_ERR(desc);\n\t\t\tbreak;\n\t\t}\n\n\t\tpebs = div_u64(req.bytes + desc->vol->usable_leb_size - 1,\n\t\t\t       desc->vol->usable_leb_size);\n\n\t\tmutex_lock(&ubi->device_mutex);\n\t\terr = ubi_resize_volume(desc, pebs);\n\t\tmutex_unlock(&ubi->device_mutex);\n\t\tubi_close_volume(desc);\n\t\tbreak;\n\t}\n\n\t \n\tcase UBI_IOCRNVOL:\n\t{\n\t\tstruct ubi_rnvol_req *req;\n\n\t\tdbg_gen(\"re-name volumes\");\n\t\treq = kmalloc(sizeof(struct ubi_rnvol_req), GFP_KERNEL);\n\t\tif (!req) {\n\t\t\terr = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\n\t\terr = copy_from_user(req, argp, sizeof(struct ubi_rnvol_req));\n\t\tif (err) {\n\t\t\terr = -EFAULT;\n\t\t\tkfree(req);\n\t\t\tbreak;\n\t\t}\n\n\t\terr = rename_volumes(ubi, req);\n\t\tkfree(req);\n\t\tbreak;\n\t}\n\n\t \n\tcase UBI_IOCRPEB:\n\t{\n\t\tint pnum;\n\n\t\terr = get_user(pnum, (__user int32_t *)argp);\n\t\tif (err) {\n\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\terr = ubi_bitflip_check(ubi, pnum, 0);\n\t\tbreak;\n\t}\n\n\t \n\tcase UBI_IOCSPEB:\n\t{\n\t\tint pnum;\n\n\t\terr = get_user(pnum, (__user int32_t *)argp);\n\t\tif (err) {\n\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\terr = ubi_bitflip_check(ubi, pnum, 1);\n\t\tbreak;\n\t}\n\n\tdefault:\n\t\terr = -ENOTTY;\n\t\tbreak;\n\t}\n\n\tubi_put_device(ubi);\n\treturn err;\n}\n\nstatic long ctrl_cdev_ioctl(struct file *file, unsigned int cmd,\n\t\t\t    unsigned long arg)\n{\n\tint err = 0;\n\tvoid __user *argp = (void __user *)arg;\n\n\tif (!capable(CAP_SYS_RESOURCE))\n\t\treturn -EPERM;\n\n\tswitch (cmd) {\n\t \n\tcase UBI_IOCATT:\n\t{\n\t\tstruct ubi_attach_req req;\n\t\tstruct mtd_info *mtd;\n\n\t\tdbg_gen(\"attach MTD device\");\n\t\terr = copy_from_user(&req, argp, sizeof(struct ubi_attach_req));\n\t\tif (err) {\n\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (req.mtd_num < 0 ||\n\t\t    (req.ubi_num < 0 && req.ubi_num != UBI_DEV_NUM_AUTO)) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tmtd = get_mtd_device(NULL, req.mtd_num);\n\t\tif (IS_ERR(mtd)) {\n\t\t\terr = PTR_ERR(mtd);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tmutex_lock(&ubi_devices_mutex);\n\t\terr = ubi_attach_mtd_dev(mtd, req.ubi_num, req.vid_hdr_offset,\n\t\t\t\t\t req.max_beb_per1024, !!req.disable_fm);\n\t\tmutex_unlock(&ubi_devices_mutex);\n\t\tif (err < 0)\n\t\t\tput_mtd_device(mtd);\n\t\telse\n\t\t\t \n\t\t\terr = put_user(err, (__user int32_t *)argp);\n\n\t\tbreak;\n\t}\n\n\t \n\tcase UBI_IOCDET:\n\t{\n\t\tint ubi_num;\n\n\t\tdbg_gen(\"detach MTD device\");\n\t\terr = get_user(ubi_num, (__user int32_t *)argp);\n\t\tif (err) {\n\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tmutex_lock(&ubi_devices_mutex);\n\t\terr = ubi_detach_mtd_dev(ubi_num, 0);\n\t\tmutex_unlock(&ubi_devices_mutex);\n\t\tbreak;\n\t}\n\n\tdefault:\n\t\terr = -ENOTTY;\n\t\tbreak;\n\t}\n\n\treturn err;\n}\n\n \nconst struct file_operations ubi_vol_cdev_operations = {\n\t.owner          = THIS_MODULE,\n\t.open           = vol_cdev_open,\n\t.release        = vol_cdev_release,\n\t.llseek         = vol_cdev_llseek,\n\t.read           = vol_cdev_read,\n\t.write          = vol_cdev_write,\n\t.fsync\t\t= vol_cdev_fsync,\n\t.unlocked_ioctl = vol_cdev_ioctl,\n\t.compat_ioctl   = compat_ptr_ioctl,\n};\n\n \nconst struct file_operations ubi_cdev_operations = {\n\t.owner          = THIS_MODULE,\n\t.llseek         = no_llseek,\n\t.unlocked_ioctl = ubi_cdev_ioctl,\n\t.compat_ioctl   = compat_ptr_ioctl,\n};\n\n \nconst struct file_operations ubi_ctrl_cdev_operations = {\n\t.owner          = THIS_MODULE,\n\t.unlocked_ioctl = ctrl_cdev_ioctl,\n\t.compat_ioctl   = compat_ptr_ioctl,\n\t.llseek\t\t= no_llseek,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}