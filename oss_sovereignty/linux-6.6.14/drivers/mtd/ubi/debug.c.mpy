{
  "module_name": "debug.c",
  "hash_id": "47c0aba913c60e91a0efc58daf8353da760902eb90bb45905d2f83ace6e441dc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/ubi/debug.c",
  "human_readable_source": "\n \n\n#include \"ubi.h\"\n#include <linux/debugfs.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/seq_file.h>\n\n\n \nvoid ubi_dump_flash(struct ubi_device *ubi, int pnum, int offset, int len)\n{\n\tint err;\n\tsize_t read;\n\tvoid *buf;\n\tloff_t addr = (loff_t)pnum * ubi->peb_size + offset;\n\n\tbuf = vmalloc(len);\n\tif (!buf)\n\t\treturn;\n\terr = mtd_read(ubi->mtd, addr, len, &read, buf);\n\tif (err && err != -EUCLEAN) {\n\t\tubi_err(ubi, \"err %d while reading %d bytes from PEB %d:%d, read %zd bytes\",\n\t\t\terr, len, pnum, offset, read);\n\t\tgoto out;\n\t}\n\n\tubi_msg(ubi, \"dumping %d bytes of data from PEB %d, offset %d\",\n\t\tlen, pnum, offset);\n\tprint_hex_dump(KERN_DEBUG, \"\", DUMP_PREFIX_OFFSET, 32, 1, buf, len, 1);\nout:\n\tvfree(buf);\n\treturn;\n}\n\n \nvoid ubi_dump_ec_hdr(const struct ubi_ec_hdr *ec_hdr)\n{\n\tpr_err(\"Erase counter header dump:\\n\");\n\tpr_err(\"\\tmagic          %#08x\\n\", be32_to_cpu(ec_hdr->magic));\n\tpr_err(\"\\tversion        %d\\n\", (int)ec_hdr->version);\n\tpr_err(\"\\tec             %llu\\n\", (long long)be64_to_cpu(ec_hdr->ec));\n\tpr_err(\"\\tvid_hdr_offset %d\\n\", be32_to_cpu(ec_hdr->vid_hdr_offset));\n\tpr_err(\"\\tdata_offset    %d\\n\", be32_to_cpu(ec_hdr->data_offset));\n\tpr_err(\"\\timage_seq      %d\\n\", be32_to_cpu(ec_hdr->image_seq));\n\tpr_err(\"\\thdr_crc        %#08x\\n\", be32_to_cpu(ec_hdr->hdr_crc));\n\tpr_err(\"erase counter header hexdump:\\n\");\n\tprint_hex_dump(KERN_DEBUG, \"\", DUMP_PREFIX_OFFSET, 32, 1,\n\t\t       ec_hdr, UBI_EC_HDR_SIZE, 1);\n}\n\n \nvoid ubi_dump_vid_hdr(const struct ubi_vid_hdr *vid_hdr)\n{\n\tpr_err(\"Volume identifier header dump:\\n\");\n\tpr_err(\"\\tmagic     %08x\\n\", be32_to_cpu(vid_hdr->magic));\n\tpr_err(\"\\tversion   %d\\n\",  (int)vid_hdr->version);\n\tpr_err(\"\\tvol_type  %d\\n\",  (int)vid_hdr->vol_type);\n\tpr_err(\"\\tcopy_flag %d\\n\",  (int)vid_hdr->copy_flag);\n\tpr_err(\"\\tcompat    %d\\n\",  (int)vid_hdr->compat);\n\tpr_err(\"\\tvol_id    %d\\n\",  be32_to_cpu(vid_hdr->vol_id));\n\tpr_err(\"\\tlnum      %d\\n\",  be32_to_cpu(vid_hdr->lnum));\n\tpr_err(\"\\tdata_size %d\\n\",  be32_to_cpu(vid_hdr->data_size));\n\tpr_err(\"\\tused_ebs  %d\\n\",  be32_to_cpu(vid_hdr->used_ebs));\n\tpr_err(\"\\tdata_pad  %d\\n\",  be32_to_cpu(vid_hdr->data_pad));\n\tpr_err(\"\\tsqnum     %llu\\n\",\n\t\t(unsigned long long)be64_to_cpu(vid_hdr->sqnum));\n\tpr_err(\"\\thdr_crc   %08x\\n\", be32_to_cpu(vid_hdr->hdr_crc));\n\tpr_err(\"Volume identifier header hexdump:\\n\");\n\tprint_hex_dump(KERN_DEBUG, \"\", DUMP_PREFIX_OFFSET, 32, 1,\n\t\t       vid_hdr, UBI_VID_HDR_SIZE, 1);\n}\n\n \nvoid ubi_dump_vol_info(const struct ubi_volume *vol)\n{\n\tpr_err(\"Volume information dump:\\n\");\n\tpr_err(\"\\tvol_id          %d\\n\", vol->vol_id);\n\tpr_err(\"\\treserved_pebs   %d\\n\", vol->reserved_pebs);\n\tpr_err(\"\\talignment       %d\\n\", vol->alignment);\n\tpr_err(\"\\tdata_pad        %d\\n\", vol->data_pad);\n\tpr_err(\"\\tvol_type        %d\\n\", vol->vol_type);\n\tpr_err(\"\\tname_len        %d\\n\", vol->name_len);\n\tpr_err(\"\\tusable_leb_size %d\\n\", vol->usable_leb_size);\n\tpr_err(\"\\tused_ebs        %d\\n\", vol->used_ebs);\n\tpr_err(\"\\tused_bytes      %lld\\n\", vol->used_bytes);\n\tpr_err(\"\\tlast_eb_bytes   %d\\n\", vol->last_eb_bytes);\n\tpr_err(\"\\tcorrupted       %d\\n\", vol->corrupted);\n\tpr_err(\"\\tupd_marker      %d\\n\", vol->upd_marker);\n\tpr_err(\"\\tskip_check      %d\\n\", vol->skip_check);\n\n\tif (vol->name_len <= UBI_VOL_NAME_MAX &&\n\t    strnlen(vol->name, vol->name_len + 1) == vol->name_len) {\n\t\tpr_err(\"\\tname            %s\\n\", vol->name);\n\t} else {\n\t\tpr_err(\"\\t1st 5 characters of name: %c%c%c%c%c\\n\",\n\t\t       vol->name[0], vol->name[1], vol->name[2],\n\t\t       vol->name[3], vol->name[4]);\n\t}\n}\n\n \nvoid ubi_dump_vtbl_record(const struct ubi_vtbl_record *r, int idx)\n{\n\tint name_len = be16_to_cpu(r->name_len);\n\n\tpr_err(\"Volume table record %d dump:\\n\", idx);\n\tpr_err(\"\\treserved_pebs   %d\\n\", be32_to_cpu(r->reserved_pebs));\n\tpr_err(\"\\talignment       %d\\n\", be32_to_cpu(r->alignment));\n\tpr_err(\"\\tdata_pad        %d\\n\", be32_to_cpu(r->data_pad));\n\tpr_err(\"\\tvol_type        %d\\n\", (int)r->vol_type);\n\tpr_err(\"\\tupd_marker      %d\\n\", (int)r->upd_marker);\n\tpr_err(\"\\tname_len        %d\\n\", name_len);\n\n\tif (r->name[0] == '\\0') {\n\t\tpr_err(\"\\tname            NULL\\n\");\n\t\treturn;\n\t}\n\n\tif (name_len <= UBI_VOL_NAME_MAX &&\n\t    strnlen(&r->name[0], name_len + 1) == name_len) {\n\t\tpr_err(\"\\tname            %s\\n\", &r->name[0]);\n\t} else {\n\t\tpr_err(\"\\t1st 5 characters of name: %c%c%c%c%c\\n\",\n\t\t\tr->name[0], r->name[1], r->name[2], r->name[3],\n\t\t\tr->name[4]);\n\t}\n\tpr_err(\"\\tcrc             %#08x\\n\", be32_to_cpu(r->crc));\n}\n\n \nvoid ubi_dump_av(const struct ubi_ainf_volume *av)\n{\n\tpr_err(\"Volume attaching information dump:\\n\");\n\tpr_err(\"\\tvol_id         %d\\n\", av->vol_id);\n\tpr_err(\"\\thighest_lnum   %d\\n\", av->highest_lnum);\n\tpr_err(\"\\tleb_count      %d\\n\", av->leb_count);\n\tpr_err(\"\\tcompat         %d\\n\", av->compat);\n\tpr_err(\"\\tvol_type       %d\\n\", av->vol_type);\n\tpr_err(\"\\tused_ebs       %d\\n\", av->used_ebs);\n\tpr_err(\"\\tlast_data_size %d\\n\", av->last_data_size);\n\tpr_err(\"\\tdata_pad       %d\\n\", av->data_pad);\n}\n\n \nvoid ubi_dump_aeb(const struct ubi_ainf_peb *aeb, int type)\n{\n\tpr_err(\"eraseblock attaching information dump:\\n\");\n\tpr_err(\"\\tec       %d\\n\", aeb->ec);\n\tpr_err(\"\\tpnum     %d\\n\", aeb->pnum);\n\tif (type == 0) {\n\t\tpr_err(\"\\tlnum     %d\\n\", aeb->lnum);\n\t\tpr_err(\"\\tscrub    %d\\n\", aeb->scrub);\n\t\tpr_err(\"\\tsqnum    %llu\\n\", aeb->sqnum);\n\t}\n}\n\n \nvoid ubi_dump_mkvol_req(const struct ubi_mkvol_req *req)\n{\n\tchar nm[17];\n\n\tpr_err(\"Volume creation request dump:\\n\");\n\tpr_err(\"\\tvol_id    %d\\n\",   req->vol_id);\n\tpr_err(\"\\talignment %d\\n\",   req->alignment);\n\tpr_err(\"\\tbytes     %lld\\n\", (long long)req->bytes);\n\tpr_err(\"\\tvol_type  %d\\n\",   req->vol_type);\n\tpr_err(\"\\tname_len  %d\\n\",   req->name_len);\n\n\tmemcpy(nm, req->name, 16);\n\tnm[16] = 0;\n\tpr_err(\"\\t1st 16 characters of name: %s\\n\", nm);\n}\n\n \nstatic struct dentry *dfs_rootdir;\n\n \nint ubi_debugfs_init(void)\n{\n\tif (!IS_ENABLED(CONFIG_DEBUG_FS))\n\t\treturn 0;\n\n\tdfs_rootdir = debugfs_create_dir(\"ubi\", NULL);\n\tif (IS_ERR_OR_NULL(dfs_rootdir)) {\n\t\tint err = dfs_rootdir ? PTR_ERR(dfs_rootdir) : -ENODEV;\n\n\t\tpr_err(\"UBI error: cannot create \\\"ubi\\\" debugfs directory, error %d\\n\",\n\t\t       err);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\n \nvoid ubi_debugfs_exit(void)\n{\n\tif (IS_ENABLED(CONFIG_DEBUG_FS))\n\t\tdebugfs_remove(dfs_rootdir);\n}\n\n \nstatic ssize_t dfs_file_read(struct file *file, char __user *user_buf,\n\t\t\t     size_t count, loff_t *ppos)\n{\n\tunsigned long ubi_num = (unsigned long)file->private_data;\n\tstruct dentry *dent = file->f_path.dentry;\n\tstruct ubi_device *ubi;\n\tstruct ubi_debug_info *d;\n\tchar buf[8];\n\tint val;\n\n\tubi = ubi_get_device(ubi_num);\n\tif (!ubi)\n\t\treturn -ENODEV;\n\td = &ubi->dbg;\n\n\tif (dent == d->dfs_chk_gen)\n\t\tval = d->chk_gen;\n\telse if (dent == d->dfs_chk_io)\n\t\tval = d->chk_io;\n\telse if (dent == d->dfs_chk_fastmap)\n\t\tval = d->chk_fastmap;\n\telse if (dent == d->dfs_disable_bgt)\n\t\tval = d->disable_bgt;\n\telse if (dent == d->dfs_emulate_bitflips)\n\t\tval = d->emulate_bitflips;\n\telse if (dent == d->dfs_emulate_io_failures)\n\t\tval = d->emulate_io_failures;\n\telse if (dent == d->dfs_emulate_power_cut) {\n\t\tsnprintf(buf, sizeof(buf), \"%u\\n\", d->emulate_power_cut);\n\t\tcount = simple_read_from_buffer(user_buf, count, ppos,\n\t\t\t\t\t\tbuf, strlen(buf));\n\t\tgoto out;\n\t} else if (dent == d->dfs_power_cut_min) {\n\t\tsnprintf(buf, sizeof(buf), \"%u\\n\", d->power_cut_min);\n\t\tcount = simple_read_from_buffer(user_buf, count, ppos,\n\t\t\t\t\t\tbuf, strlen(buf));\n\t\tgoto out;\n\t} else if (dent == d->dfs_power_cut_max) {\n\t\tsnprintf(buf, sizeof(buf), \"%u\\n\", d->power_cut_max);\n\t\tcount = simple_read_from_buffer(user_buf, count, ppos,\n\t\t\t\t\t\tbuf, strlen(buf));\n\t\tgoto out;\n\t}\n\telse {\n\t\tcount = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (val)\n\t\tbuf[0] = '1';\n\telse\n\t\tbuf[0] = '0';\n\tbuf[1] = '\\n';\n\tbuf[2] = 0x00;\n\n\tcount = simple_read_from_buffer(user_buf, count, ppos, buf, 2);\n\nout:\n\tubi_put_device(ubi);\n\treturn count;\n}\n\n \nstatic ssize_t dfs_file_write(struct file *file, const char __user *user_buf,\n\t\t\t      size_t count, loff_t *ppos)\n{\n\tunsigned long ubi_num = (unsigned long)file->private_data;\n\tstruct dentry *dent = file->f_path.dentry;\n\tstruct ubi_device *ubi;\n\tstruct ubi_debug_info *d;\n\tsize_t buf_size;\n\tchar buf[8] = {0};\n\tint val;\n\n\tubi = ubi_get_device(ubi_num);\n\tif (!ubi)\n\t\treturn -ENODEV;\n\td = &ubi->dbg;\n\n\tbuf_size = min_t(size_t, count, (sizeof(buf) - 1));\n\tif (copy_from_user(buf, user_buf, buf_size)) {\n\t\tcount = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tif (dent == d->dfs_power_cut_min) {\n\t\tif (kstrtouint(buf, 0, &d->power_cut_min) != 0)\n\t\t\tcount = -EINVAL;\n\t\tgoto out;\n\t} else if (dent == d->dfs_power_cut_max) {\n\t\tif (kstrtouint(buf, 0, &d->power_cut_max) != 0)\n\t\t\tcount = -EINVAL;\n\t\tgoto out;\n\t} else if (dent == d->dfs_emulate_power_cut) {\n\t\tif (kstrtoint(buf, 0, &val) != 0)\n\t\t\tcount = -EINVAL;\n\t\telse\n\t\t\td->emulate_power_cut = val;\n\t\tgoto out;\n\t}\n\n\tif (buf[0] == '1')\n\t\tval = 1;\n\telse if (buf[0] == '0')\n\t\tval = 0;\n\telse {\n\t\tcount = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (dent == d->dfs_chk_gen)\n\t\td->chk_gen = val;\n\telse if (dent == d->dfs_chk_io)\n\t\td->chk_io = val;\n\telse if (dent == d->dfs_chk_fastmap)\n\t\td->chk_fastmap = val;\n\telse if (dent == d->dfs_disable_bgt)\n\t\td->disable_bgt = val;\n\telse if (dent == d->dfs_emulate_bitflips)\n\t\td->emulate_bitflips = val;\n\telse if (dent == d->dfs_emulate_io_failures)\n\t\td->emulate_io_failures = val;\n\telse\n\t\tcount = -EINVAL;\n\nout:\n\tubi_put_device(ubi);\n\treturn count;\n}\n\n \nstatic const struct file_operations dfs_fops = {\n\t.read   = dfs_file_read,\n\t.write  = dfs_file_write,\n\t.open\t= simple_open,\n\t.llseek = no_llseek,\n\t.owner  = THIS_MODULE,\n};\n\n \nstatic void *eraseblk_count_seq_start(struct seq_file *s, loff_t *pos)\n{\n\tstruct ubi_device *ubi = s->private;\n\n\tif (*pos < ubi->peb_count)\n\t\treturn pos;\n\n\treturn NULL;\n}\n\n \nstatic void *eraseblk_count_seq_next(struct seq_file *s, void *v, loff_t *pos)\n{\n\tstruct ubi_device *ubi = s->private;\n\n\t(*pos)++;\n\n\tif (*pos < ubi->peb_count)\n\t\treturn pos;\n\n\treturn NULL;\n}\n\nstatic void eraseblk_count_seq_stop(struct seq_file *s, void *v)\n{\n}\n\nstatic int eraseblk_count_seq_show(struct seq_file *s, void *iter)\n{\n\tstruct ubi_device *ubi = s->private;\n\tstruct ubi_wl_entry *wl;\n\tint *block_number = iter;\n\tint erase_count = -1;\n\tint err;\n\n\t \n\tif (*block_number == 0)\n\t\tseq_puts(s, \"physical_block_number\\terase_count\\n\");\n\n\terr = ubi_io_is_bad(ubi, *block_number);\n\tif (err)\n\t\treturn err;\n\n\tspin_lock(&ubi->wl_lock);\n\n\twl = ubi->lookuptbl[*block_number];\n\tif (wl)\n\t\terase_count = wl->ec;\n\n\tspin_unlock(&ubi->wl_lock);\n\n\tif (erase_count < 0)\n\t\treturn 0;\n\n\tseq_printf(s, \"%-22d\\t%-11d\\n\", *block_number, erase_count);\n\n\treturn 0;\n}\n\nstatic const struct seq_operations eraseblk_count_seq_ops = {\n\t.start = eraseblk_count_seq_start,\n\t.next = eraseblk_count_seq_next,\n\t.stop = eraseblk_count_seq_stop,\n\t.show = eraseblk_count_seq_show\n};\n\nstatic int eraseblk_count_open(struct inode *inode, struct file *f)\n{\n\tstruct seq_file *s;\n\tint err;\n\n\terr = seq_open(f, &eraseblk_count_seq_ops);\n\tif (err)\n\t\treturn err;\n\n\ts = f->private_data;\n\ts->private = ubi_get_device((unsigned long)inode->i_private);\n\n\tif (!s->private)\n\t\treturn -ENODEV;\n\telse\n\t\treturn 0;\n}\n\nstatic int eraseblk_count_release(struct inode *inode, struct file *f)\n{\n\tstruct seq_file *s = f->private_data;\n\tstruct ubi_device *ubi = s->private;\n\n\tubi_put_device(ubi);\n\n\treturn seq_release(inode, f);\n}\n\nstatic const struct file_operations eraseblk_count_fops = {\n\t.owner = THIS_MODULE,\n\t.open = eraseblk_count_open,\n\t.read = seq_read,\n\t.llseek = seq_lseek,\n\t.release = eraseblk_count_release,\n};\n\n \nint ubi_debugfs_init_dev(struct ubi_device *ubi)\n{\n\tunsigned long ubi_num = ubi->ubi_num;\n\tstruct ubi_debug_info *d = &ubi->dbg;\n\tumode_t mode = S_IRUSR | S_IWUSR;\n\tint n;\n\n\tif (!IS_ENABLED(CONFIG_DEBUG_FS))\n\t\treturn 0;\n\n\tn = snprintf(d->dfs_dir_name, UBI_DFS_DIR_LEN + 1, UBI_DFS_DIR_NAME,\n\t\t     ubi->ubi_num);\n\tif (n > UBI_DFS_DIR_LEN) {\n\t\t \n\t\treturn -EINVAL;\n\t}\n\n\td->dfs_dir = debugfs_create_dir(d->dfs_dir_name, dfs_rootdir);\n\n\td->dfs_chk_gen = debugfs_create_file(\"chk_gen\", mode, d->dfs_dir,\n\t\t\t\t\t     (void *)ubi_num, &dfs_fops);\n\n\td->dfs_chk_io = debugfs_create_file(\"chk_io\", mode, d->dfs_dir,\n\t\t\t\t\t    (void *)ubi_num, &dfs_fops);\n\n\td->dfs_chk_fastmap = debugfs_create_file(\"chk_fastmap\", mode,\n\t\t\t\t\t\t d->dfs_dir, (void *)ubi_num,\n\t\t\t\t\t\t &dfs_fops);\n\n\td->dfs_disable_bgt = debugfs_create_file(\"tst_disable_bgt\", mode,\n\t\t\t\t\t\t d->dfs_dir, (void *)ubi_num,\n\t\t\t\t\t\t &dfs_fops);\n\n\td->dfs_emulate_bitflips = debugfs_create_file(\"tst_emulate_bitflips\",\n\t\t\t\t\t\t      mode, d->dfs_dir,\n\t\t\t\t\t\t      (void *)ubi_num,\n\t\t\t\t\t\t      &dfs_fops);\n\n\td->dfs_emulate_io_failures = debugfs_create_file(\"tst_emulate_io_failures\",\n\t\t\t\t\t\t\t mode, d->dfs_dir,\n\t\t\t\t\t\t\t (void *)ubi_num,\n\t\t\t\t\t\t\t &dfs_fops);\n\n\td->dfs_emulate_power_cut = debugfs_create_file(\"tst_emulate_power_cut\",\n\t\t\t\t\t\t       mode, d->dfs_dir,\n\t\t\t\t\t\t       (void *)ubi_num,\n\t\t\t\t\t\t       &dfs_fops);\n\n\td->dfs_power_cut_min = debugfs_create_file(\"tst_emulate_power_cut_min\",\n\t\t\t\t\t\t   mode, d->dfs_dir,\n\t\t\t\t\t\t   (void *)ubi_num, &dfs_fops);\n\n\td->dfs_power_cut_max = debugfs_create_file(\"tst_emulate_power_cut_max\",\n\t\t\t\t\t\t   mode, d->dfs_dir,\n\t\t\t\t\t\t   (void *)ubi_num, &dfs_fops);\n\n\tdebugfs_create_file(\"detailed_erase_block_info\", S_IRUSR, d->dfs_dir,\n\t\t\t    (void *)ubi_num, &eraseblk_count_fops);\n\n\treturn 0;\n}\n\n \nvoid ubi_debugfs_exit_dev(struct ubi_device *ubi)\n{\n\tif (IS_ENABLED(CONFIG_DEBUG_FS))\n\t\tdebugfs_remove_recursive(ubi->dbg.dfs_dir);\n}\n\n \nint ubi_dbg_power_cut(struct ubi_device *ubi, int caller)\n{\n\tunsigned int range;\n\n\tif ((ubi->dbg.emulate_power_cut & caller) == 0)\n\t\treturn 0;\n\n\tif (ubi->dbg.power_cut_counter == 0) {\n\t\tubi->dbg.power_cut_counter = ubi->dbg.power_cut_min;\n\n\t\tif (ubi->dbg.power_cut_max > ubi->dbg.power_cut_min) {\n\t\t\trange = ubi->dbg.power_cut_max - ubi->dbg.power_cut_min;\n\t\t\tubi->dbg.power_cut_counter += get_random_u32_below(range);\n\t\t}\n\t\treturn 0;\n\t}\n\n\tubi->dbg.power_cut_counter--;\n\tif (ubi->dbg.power_cut_counter)\n\t\treturn 0;\n\n\tubi_msg(ubi, \"XXXXXXXXXXXXXXX emulating a power cut XXXXXXXXXXXXXXXX\");\n\tubi_ro_mode(ubi);\n\treturn 1;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}