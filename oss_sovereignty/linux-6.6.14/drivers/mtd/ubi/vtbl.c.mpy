{
  "module_name": "vtbl.c",
  "hash_id": "fc2a599313ec8c0434b1d1c6ae20bcd7691fa4a6c32b2151ddbbe328acee90ad",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/ubi/vtbl.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/crc32.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <asm/div64.h>\n#include \"ubi.h\"\n\nstatic void self_vtbl_check(const struct ubi_device *ubi);\n\n \nstatic struct ubi_vtbl_record empty_vtbl_record;\n\n \nstatic int ubi_update_layout_vol(struct ubi_device *ubi)\n{\n\tstruct ubi_volume *layout_vol;\n\tint i, err;\n\n\tlayout_vol = ubi->volumes[vol_id2idx(ubi, UBI_LAYOUT_VOLUME_ID)];\n\tfor (i = 0; i < UBI_LAYOUT_VOLUME_EBS; i++) {\n\t\terr = ubi_eba_atomic_leb_change(ubi, layout_vol, i, ubi->vtbl,\n\t\t\t\t\t\tubi->vtbl_size);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\n \nint ubi_change_vtbl_record(struct ubi_device *ubi, int idx,\n\t\t\t   struct ubi_vtbl_record *vtbl_rec)\n{\n\tint err;\n\tuint32_t crc;\n\n\tubi_assert(idx >= 0 && idx < ubi->vtbl_slots);\n\n\tif (!vtbl_rec)\n\t\tvtbl_rec = &empty_vtbl_record;\n\telse {\n\t\tcrc = crc32(UBI_CRC32_INIT, vtbl_rec, UBI_VTBL_RECORD_SIZE_CRC);\n\t\tvtbl_rec->crc = cpu_to_be32(crc);\n\t}\n\n\tmemcpy(&ubi->vtbl[idx], vtbl_rec, sizeof(struct ubi_vtbl_record));\n\terr = ubi_update_layout_vol(ubi);\n\n\tself_vtbl_check(ubi);\n\treturn err ? err : 0;\n}\n\n \nint ubi_vtbl_rename_volumes(struct ubi_device *ubi,\n\t\t\t    struct list_head *rename_list)\n{\n\tstruct ubi_rename_entry *re;\n\n\tlist_for_each_entry(re, rename_list, list) {\n\t\tuint32_t crc;\n\t\tstruct ubi_volume *vol = re->desc->vol;\n\t\tstruct ubi_vtbl_record *vtbl_rec = &ubi->vtbl[vol->vol_id];\n\n\t\tif (re->remove) {\n\t\t\tmemcpy(vtbl_rec, &empty_vtbl_record,\n\t\t\t       sizeof(struct ubi_vtbl_record));\n\t\t\tcontinue;\n\t\t}\n\n\t\tvtbl_rec->name_len = cpu_to_be16(re->new_name_len);\n\t\tmemcpy(vtbl_rec->name, re->new_name, re->new_name_len);\n\t\tmemset(vtbl_rec->name + re->new_name_len, 0,\n\t\t       UBI_VOL_NAME_MAX + 1 - re->new_name_len);\n\t\tcrc = crc32(UBI_CRC32_INIT, vtbl_rec,\n\t\t\t    UBI_VTBL_RECORD_SIZE_CRC);\n\t\tvtbl_rec->crc = cpu_to_be32(crc);\n\t}\n\n\treturn ubi_update_layout_vol(ubi);\n}\n\n \nstatic int vtbl_check(const struct ubi_device *ubi,\n\t\t      const struct ubi_vtbl_record *vtbl)\n{\n\tint i, n, reserved_pebs, alignment, data_pad, vol_type, name_len;\n\tint upd_marker, err;\n\tuint32_t crc;\n\tconst char *name;\n\n\tfor (i = 0; i < ubi->vtbl_slots; i++) {\n\t\tcond_resched();\n\n\t\treserved_pebs = be32_to_cpu(vtbl[i].reserved_pebs);\n\t\talignment = be32_to_cpu(vtbl[i].alignment);\n\t\tdata_pad = be32_to_cpu(vtbl[i].data_pad);\n\t\tupd_marker = vtbl[i].upd_marker;\n\t\tvol_type = vtbl[i].vol_type;\n\t\tname_len = be16_to_cpu(vtbl[i].name_len);\n\t\tname = &vtbl[i].name[0];\n\n\t\tcrc = crc32(UBI_CRC32_INIT, &vtbl[i], UBI_VTBL_RECORD_SIZE_CRC);\n\t\tif (be32_to_cpu(vtbl[i].crc) != crc) {\n\t\t\tubi_err(ubi, \"bad CRC at record %u: %#08x, not %#08x\",\n\t\t\t\t i, crc, be32_to_cpu(vtbl[i].crc));\n\t\t\tubi_dump_vtbl_record(&vtbl[i], i);\n\t\t\treturn 1;\n\t\t}\n\n\t\tif (reserved_pebs == 0) {\n\t\t\tif (memcmp(&vtbl[i], &empty_vtbl_record,\n\t\t\t\t\t\tUBI_VTBL_RECORD_SIZE)) {\n\t\t\t\terr = 2;\n\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (reserved_pebs < 0 || alignment < 0 || data_pad < 0 ||\n\t\t    name_len < 0) {\n\t\t\terr = 3;\n\t\t\tgoto bad;\n\t\t}\n\n\t\tif (alignment > ubi->leb_size || alignment == 0) {\n\t\t\terr = 4;\n\t\t\tgoto bad;\n\t\t}\n\n\t\tn = alignment & (ubi->min_io_size - 1);\n\t\tif (alignment != 1 && n) {\n\t\t\terr = 5;\n\t\t\tgoto bad;\n\t\t}\n\n\t\tn = ubi->leb_size % alignment;\n\t\tif (data_pad != n) {\n\t\t\tubi_err(ubi, \"bad data_pad, has to be %d\", n);\n\t\t\terr = 6;\n\t\t\tgoto bad;\n\t\t}\n\n\t\tif (vol_type != UBI_VID_DYNAMIC && vol_type != UBI_VID_STATIC) {\n\t\t\terr = 7;\n\t\t\tgoto bad;\n\t\t}\n\n\t\tif (upd_marker != 0 && upd_marker != 1) {\n\t\t\terr = 8;\n\t\t\tgoto bad;\n\t\t}\n\n\t\tif (reserved_pebs > ubi->good_peb_count) {\n\t\t\tubi_err(ubi, \"too large reserved_pebs %d, good PEBs %d\",\n\t\t\t\treserved_pebs, ubi->good_peb_count);\n\t\t\terr = 9;\n\t\t\tgoto bad;\n\t\t}\n\n\t\tif (name_len > UBI_VOL_NAME_MAX) {\n\t\t\terr = 10;\n\t\t\tgoto bad;\n\t\t}\n\n\t\tif (name[0] == '\\0') {\n\t\t\terr = 11;\n\t\t\tgoto bad;\n\t\t}\n\n\t\tif (name_len != strnlen(name, name_len + 1)) {\n\t\t\terr = 12;\n\t\t\tgoto bad;\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < ubi->vtbl_slots - 1; i++) {\n\t\tfor (n = i + 1; n < ubi->vtbl_slots; n++) {\n\t\t\tint len1 = be16_to_cpu(vtbl[i].name_len);\n\t\t\tint len2 = be16_to_cpu(vtbl[n].name_len);\n\n\t\t\tif (len1 > 0 && len1 == len2 &&\n\t\t\t    !strncmp(vtbl[i].name, vtbl[n].name, len1)) {\n\t\t\t\tubi_err(ubi, \"volumes %d and %d have the same name \\\"%s\\\"\",\n\t\t\t\t\ti, n, vtbl[i].name);\n\t\t\t\tubi_dump_vtbl_record(&vtbl[i], i);\n\t\t\t\tubi_dump_vtbl_record(&vtbl[n], n);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n\nbad:\n\tubi_err(ubi, \"volume table check failed: record %d, error %d\", i, err);\n\tubi_dump_vtbl_record(&vtbl[i], i);\n\treturn -EINVAL;\n}\n\n \nstatic int create_vtbl(struct ubi_device *ubi, struct ubi_attach_info *ai,\n\t\t       int copy, void *vtbl)\n{\n\tint err, tries = 0;\n\tstruct ubi_vid_io_buf *vidb;\n\tstruct ubi_vid_hdr *vid_hdr;\n\tstruct ubi_ainf_peb *new_aeb;\n\n\tdbg_gen(\"create volume table (copy #%d)\", copy + 1);\n\n\tvidb = ubi_alloc_vid_buf(ubi, GFP_KERNEL);\n\tif (!vidb)\n\t\treturn -ENOMEM;\n\n\tvid_hdr = ubi_get_vid_hdr(vidb);\n\nretry:\n\tnew_aeb = ubi_early_get_peb(ubi, ai);\n\tif (IS_ERR(new_aeb)) {\n\t\terr = PTR_ERR(new_aeb);\n\t\tgoto out_free;\n\t}\n\n\tvid_hdr->vol_type = UBI_LAYOUT_VOLUME_TYPE;\n\tvid_hdr->vol_id = cpu_to_be32(UBI_LAYOUT_VOLUME_ID);\n\tvid_hdr->compat = UBI_LAYOUT_VOLUME_COMPAT;\n\tvid_hdr->data_size = vid_hdr->used_ebs =\n\t\t\t     vid_hdr->data_pad = cpu_to_be32(0);\n\tvid_hdr->lnum = cpu_to_be32(copy);\n\tvid_hdr->sqnum = cpu_to_be64(++ai->max_sqnum);\n\n\t \n\terr = ubi_io_write_vid_hdr(ubi, new_aeb->pnum, vidb);\n\tif (err)\n\t\tgoto write_error;\n\n\t \n\terr = ubi_io_write_data(ubi, vtbl, new_aeb->pnum, 0, ubi->vtbl_size);\n\tif (err)\n\t\tgoto write_error;\n\n\t \n\terr = ubi_add_to_av(ubi, ai, new_aeb->pnum, new_aeb->ec, vid_hdr, 0);\n\tubi_free_aeb(ai, new_aeb);\n\tubi_free_vid_buf(vidb);\n\treturn err;\n\nwrite_error:\n\tif (err == -EIO && ++tries <= 5) {\n\t\t \n\t\tlist_add(&new_aeb->u.list, &ai->erase);\n\t\tgoto retry;\n\t}\n\tubi_free_aeb(ai, new_aeb);\nout_free:\n\tubi_free_vid_buf(vidb);\n\treturn err;\n\n}\n\n \nstatic struct ubi_vtbl_record *process_lvol(struct ubi_device *ubi,\n\t\t\t\t\t    struct ubi_attach_info *ai,\n\t\t\t\t\t    struct ubi_ainf_volume *av)\n{\n\tint err;\n\tstruct rb_node *rb;\n\tstruct ubi_ainf_peb *aeb;\n\tstruct ubi_vtbl_record *leb[UBI_LAYOUT_VOLUME_EBS] = { NULL, NULL };\n\tint leb_corrupted[UBI_LAYOUT_VOLUME_EBS] = {1, 1};\n\n\t \n\n\tdbg_gen(\"check layout volume\");\n\n\t \n\tubi_rb_for_each_entry(rb, aeb, &av->root, u.rb) {\n\t\tleb[aeb->lnum] = vzalloc(ubi->vtbl_size);\n\t\tif (!leb[aeb->lnum]) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out_free;\n\t\t}\n\n\t\terr = ubi_io_read_data(ubi, leb[aeb->lnum], aeb->pnum, 0,\n\t\t\t\t       ubi->vtbl_size);\n\t\tif (err == UBI_IO_BITFLIPS || mtd_is_eccerr(err))\n\t\t\t \n\t\t\taeb->scrub = 1;\n\t\telse if (err)\n\t\t\tgoto out_free;\n\t}\n\n\terr = -EINVAL;\n\tif (leb[0]) {\n\t\tleb_corrupted[0] = vtbl_check(ubi, leb[0]);\n\t\tif (leb_corrupted[0] < 0)\n\t\t\tgoto out_free;\n\t}\n\n\tif (!leb_corrupted[0]) {\n\t\t \n\t\tif (leb[1])\n\t\t\tleb_corrupted[1] = memcmp(leb[0], leb[1],\n\t\t\t\t\t\t  ubi->vtbl_size);\n\t\tif (leb_corrupted[1]) {\n\t\t\tubi_warn(ubi, \"volume table copy #2 is corrupted\");\n\t\t\terr = create_vtbl(ubi, ai, 1, leb[0]);\n\t\t\tif (err)\n\t\t\t\tgoto out_free;\n\t\t\tubi_msg(ubi, \"volume table was restored\");\n\t\t}\n\n\t\t \n\t\tvfree(leb[1]);\n\t\treturn leb[0];\n\t} else {\n\t\t \n\t\tif (leb[1]) {\n\t\t\tleb_corrupted[1] = vtbl_check(ubi, leb[1]);\n\t\t\tif (leb_corrupted[1] < 0)\n\t\t\t\tgoto out_free;\n\t\t}\n\t\tif (leb_corrupted[1]) {\n\t\t\t \n\t\t\tubi_err(ubi, \"both volume tables are corrupted\");\n\t\t\tgoto out_free;\n\t\t}\n\n\t\tubi_warn(ubi, \"volume table copy #1 is corrupted\");\n\t\terr = create_vtbl(ubi, ai, 0, leb[1]);\n\t\tif (err)\n\t\t\tgoto out_free;\n\t\tubi_msg(ubi, \"volume table was restored\");\n\n\t\tvfree(leb[0]);\n\t\treturn leb[1];\n\t}\n\nout_free:\n\tvfree(leb[0]);\n\tvfree(leb[1]);\n\treturn ERR_PTR(err);\n}\n\n \nstatic struct ubi_vtbl_record *create_empty_lvol(struct ubi_device *ubi,\n\t\t\t\t\t\t struct ubi_attach_info *ai)\n{\n\tint i;\n\tstruct ubi_vtbl_record *vtbl;\n\n\tvtbl = vzalloc(ubi->vtbl_size);\n\tif (!vtbl)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tfor (i = 0; i < ubi->vtbl_slots; i++)\n\t\tmemcpy(&vtbl[i], &empty_vtbl_record, UBI_VTBL_RECORD_SIZE);\n\n\tfor (i = 0; i < UBI_LAYOUT_VOLUME_EBS; i++) {\n\t\tint err;\n\n\t\terr = create_vtbl(ubi, ai, i, vtbl);\n\t\tif (err) {\n\t\t\tvfree(vtbl);\n\t\t\treturn ERR_PTR(err);\n\t\t}\n\t}\n\n\treturn vtbl;\n}\n\n \nstatic int init_volumes(struct ubi_device *ubi,\n\t\t\tconst struct ubi_attach_info *ai,\n\t\t\tconst struct ubi_vtbl_record *vtbl)\n{\n\tint i, err, reserved_pebs = 0;\n\tstruct ubi_ainf_volume *av;\n\tstruct ubi_volume *vol;\n\n\tfor (i = 0; i < ubi->vtbl_slots; i++) {\n\t\tcond_resched();\n\n\t\tif (be32_to_cpu(vtbl[i].reserved_pebs) == 0)\n\t\t\tcontinue;  \n\n\t\tvol = kzalloc(sizeof(struct ubi_volume), GFP_KERNEL);\n\t\tif (!vol)\n\t\t\treturn -ENOMEM;\n\n\t\tvol->reserved_pebs = be32_to_cpu(vtbl[i].reserved_pebs);\n\t\tvol->alignment = be32_to_cpu(vtbl[i].alignment);\n\t\tvol->data_pad = be32_to_cpu(vtbl[i].data_pad);\n\t\tvol->upd_marker = vtbl[i].upd_marker;\n\t\tvol->vol_type = vtbl[i].vol_type == UBI_VID_DYNAMIC ?\n\t\t\t\t\tUBI_DYNAMIC_VOLUME : UBI_STATIC_VOLUME;\n\t\tvol->name_len = be16_to_cpu(vtbl[i].name_len);\n\t\tvol->usable_leb_size = ubi->leb_size - vol->data_pad;\n\t\tmemcpy(vol->name, vtbl[i].name, vol->name_len);\n\t\tvol->name[vol->name_len] = '\\0';\n\t\tvol->vol_id = i;\n\n\t\tif (vtbl[i].flags & UBI_VTBL_SKIP_CRC_CHECK_FLG)\n\t\t\tvol->skip_check = 1;\n\n\t\tif (vtbl[i].flags & UBI_VTBL_AUTORESIZE_FLG) {\n\t\t\t \n\t\t\tif (ubi->autoresize_vol_id != -1) {\n\t\t\t\tubi_err(ubi, \"more than one auto-resize volume (%d and %d)\",\n\t\t\t\t\tubi->autoresize_vol_id, i);\n\t\t\t\tkfree(vol);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tubi->autoresize_vol_id = i;\n\t\t}\n\n\t\tubi_assert(!ubi->volumes[i]);\n\t\tubi->volumes[i] = vol;\n\t\tubi->vol_count += 1;\n\t\tvol->ubi = ubi;\n\t\treserved_pebs += vol->reserved_pebs;\n\n\t\t \n\t\terr = ubi_fastmap_init_checkmap(vol, ubi->peb_count);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\t \n\t\tif (vol->vol_type == UBI_DYNAMIC_VOLUME) {\n\t\t\tvol->used_ebs = vol->reserved_pebs;\n\t\t\tvol->last_eb_bytes = vol->usable_leb_size;\n\t\t\tvol->used_bytes =\n\t\t\t\t(long long)vol->used_ebs * vol->usable_leb_size;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tav = ubi_find_av(ai, i);\n\t\tif (!av || !av->leb_count) {\n\t\t\t \n\t\t\tcontinue;\n\t\t}\n\n\t\tif (av->leb_count != av->used_ebs) {\n\t\t\t \n\t\t\tubi_warn(ubi, \"static volume %d misses %d LEBs - corrupted\",\n\t\t\t\t av->vol_id, av->used_ebs - av->leb_count);\n\t\t\tvol->corrupted = 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tvol->used_ebs = av->used_ebs;\n\t\tvol->used_bytes =\n\t\t\t(long long)(vol->used_ebs - 1) * vol->usable_leb_size;\n\t\tvol->used_bytes += av->last_data_size;\n\t\tvol->last_eb_bytes = av->last_data_size;\n\t}\n\n\t \n\tvol = kzalloc(sizeof(struct ubi_volume), GFP_KERNEL);\n\tif (!vol)\n\t\treturn -ENOMEM;\n\n\tvol->reserved_pebs = UBI_LAYOUT_VOLUME_EBS;\n\tvol->alignment = UBI_LAYOUT_VOLUME_ALIGN;\n\tvol->vol_type = UBI_DYNAMIC_VOLUME;\n\tvol->name_len = sizeof(UBI_LAYOUT_VOLUME_NAME) - 1;\n\tmemcpy(vol->name, UBI_LAYOUT_VOLUME_NAME, vol->name_len + 1);\n\tvol->usable_leb_size = ubi->leb_size;\n\tvol->used_ebs = vol->reserved_pebs;\n\tvol->last_eb_bytes = vol->reserved_pebs;\n\tvol->used_bytes =\n\t\t(long long)vol->used_ebs * (ubi->leb_size - vol->data_pad);\n\tvol->vol_id = UBI_LAYOUT_VOLUME_ID;\n\tvol->ref_count = 1;\n\n\tubi_assert(!ubi->volumes[i]);\n\tubi->volumes[vol_id2idx(ubi, vol->vol_id)] = vol;\n\treserved_pebs += vol->reserved_pebs;\n\tubi->vol_count += 1;\n\tvol->ubi = ubi;\n\terr = ubi_fastmap_init_checkmap(vol, UBI_LAYOUT_VOLUME_EBS);\n\tif (err)\n\t\treturn err;\n\n\tif (reserved_pebs > ubi->avail_pebs) {\n\t\tubi_err(ubi, \"not enough PEBs, required %d, available %d\",\n\t\t\treserved_pebs, ubi->avail_pebs);\n\t\tif (ubi->corr_peb_count)\n\t\t\tubi_err(ubi, \"%d PEBs are corrupted and not used\",\n\t\t\t\tubi->corr_peb_count);\n\t\treturn -ENOSPC;\n\t}\n\tubi->rsvd_pebs += reserved_pebs;\n\tubi->avail_pebs -= reserved_pebs;\n\n\treturn 0;\n}\n\n \nstatic int check_av(const struct ubi_volume *vol,\n\t\t    const struct ubi_ainf_volume *av)\n{\n\tint err;\n\n\tif (av->highest_lnum >= vol->reserved_pebs) {\n\t\terr = 1;\n\t\tgoto bad;\n\t}\n\tif (av->leb_count > vol->reserved_pebs) {\n\t\terr = 2;\n\t\tgoto bad;\n\t}\n\tif (av->vol_type != vol->vol_type) {\n\t\terr = 3;\n\t\tgoto bad;\n\t}\n\tif (av->used_ebs > vol->reserved_pebs) {\n\t\terr = 4;\n\t\tgoto bad;\n\t}\n\tif (av->data_pad != vol->data_pad) {\n\t\terr = 5;\n\t\tgoto bad;\n\t}\n\treturn 0;\n\nbad:\n\tubi_err(vol->ubi, \"bad attaching information, error %d\", err);\n\tubi_dump_av(av);\n\tubi_dump_vol_info(vol);\n\treturn -EINVAL;\n}\n\n \nstatic int check_attaching_info(const struct ubi_device *ubi,\n\t\t\t       struct ubi_attach_info *ai)\n{\n\tint err, i;\n\tstruct ubi_ainf_volume *av;\n\tstruct ubi_volume *vol;\n\n\tif (ai->vols_found > UBI_INT_VOL_COUNT + ubi->vtbl_slots) {\n\t\tubi_err(ubi, \"found %d volumes while attaching, maximum is %d + %d\",\n\t\t\tai->vols_found, UBI_INT_VOL_COUNT, ubi->vtbl_slots);\n\t\treturn -EINVAL;\n\t}\n\n\tif (ai->highest_vol_id >= ubi->vtbl_slots + UBI_INT_VOL_COUNT &&\n\t    ai->highest_vol_id < UBI_INTERNAL_VOL_START) {\n\t\tubi_err(ubi, \"too large volume ID %d found\",\n\t\t\tai->highest_vol_id);\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < ubi->vtbl_slots + UBI_INT_VOL_COUNT; i++) {\n\t\tcond_resched();\n\n\t\tav = ubi_find_av(ai, i);\n\t\tvol = ubi->volumes[i];\n\t\tif (!vol) {\n\t\t\tif (av)\n\t\t\t\tubi_remove_av(ai, av);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (vol->reserved_pebs == 0) {\n\t\t\tubi_assert(i < ubi->vtbl_slots);\n\n\t\t\tif (!av)\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tubi_msg(ubi, \"finish volume %d removal\", av->vol_id);\n\t\t\tubi_remove_av(ai, av);\n\t\t} else if (av) {\n\t\t\terr = check_av(vol, av);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nint ubi_read_volume_table(struct ubi_device *ubi, struct ubi_attach_info *ai)\n{\n\tint err;\n\tstruct ubi_ainf_volume *av;\n\n\tempty_vtbl_record.crc = cpu_to_be32(0xf116c36b);\n\n\t \n\tubi->vtbl_slots = ubi->leb_size / UBI_VTBL_RECORD_SIZE;\n\tif (ubi->vtbl_slots > UBI_MAX_VOLUMES)\n\t\tubi->vtbl_slots = UBI_MAX_VOLUMES;\n\n\tubi->vtbl_size = ubi->vtbl_slots * UBI_VTBL_RECORD_SIZE;\n\tubi->vtbl_size = ALIGN(ubi->vtbl_size, ubi->min_io_size);\n\n\tav = ubi_find_av(ai, UBI_LAYOUT_VOLUME_ID);\n\tif (!av) {\n\t\t \n\t\tif (ai->is_empty) {\n\t\t\tubi->vtbl = create_empty_lvol(ubi, ai);\n\t\t\tif (IS_ERR(ubi->vtbl))\n\t\t\t\treturn PTR_ERR(ubi->vtbl);\n\t\t} else {\n\t\t\tubi_err(ubi, \"the layout volume was not found\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else {\n\t\tif (av->leb_count > UBI_LAYOUT_VOLUME_EBS) {\n\t\t\t \n\t\t\tubi_err(ubi, \"too many LEBs (%d) in layout volume\",\n\t\t\t\tav->leb_count);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tubi->vtbl = process_lvol(ubi, ai, av);\n\t\tif (IS_ERR(ubi->vtbl))\n\t\t\treturn PTR_ERR(ubi->vtbl);\n\t}\n\n\tubi->avail_pebs = ubi->good_peb_count - ubi->corr_peb_count;\n\n\t \n\terr = init_volumes(ubi, ai, ubi->vtbl);\n\tif (err)\n\t\tgoto out_free;\n\n\t \n\terr = check_attaching_info(ubi, ai);\n\tif (err)\n\t\tgoto out_free;\n\n\treturn 0;\n\nout_free:\n\tvfree(ubi->vtbl);\n\tubi_free_all_volumes(ubi);\n\treturn err;\n}\n\n \nstatic void self_vtbl_check(const struct ubi_device *ubi)\n{\n\tif (!ubi_dbg_chk_gen(ubi))\n\t\treturn;\n\n\tif (vtbl_check(ubi, ubi->vtbl)) {\n\t\tubi_err(ubi, \"self-check failed\");\n\t\tBUG();\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}