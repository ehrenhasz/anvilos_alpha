{
  "module_name": "gluebi.c",
  "hash_id": "7776f0e550239b55f2dff17574daa2e17ccdc6a1620f6e7155fcce9a6f52258c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/ubi/gluebi.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/err.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/mtd/ubi.h>\n#include <linux/mtd/mtd.h>\n#include \"ubi-media.h\"\n\n#define err_msg(fmt, ...)                                   \\\n\tpr_err(\"gluebi (pid %d): %s: \" fmt \"\\n\",            \\\n\t       current->pid, __func__, ##__VA_ARGS__)\n\n \nstruct gluebi_device {\n\tstruct mtd_info mtd;\n\tint refcnt;\n\tstruct ubi_volume_desc *desc;\n\tint ubi_num;\n\tint vol_id;\n\tstruct list_head list;\n};\n\n \nstatic LIST_HEAD(gluebi_devices);\nstatic DEFINE_MUTEX(devices_mutex);\n\n \nstatic struct gluebi_device *find_gluebi_nolock(int ubi_num, int vol_id)\n{\n\tstruct gluebi_device *gluebi;\n\n\tlist_for_each_entry(gluebi, &gluebi_devices, list)\n\t\tif (gluebi->ubi_num == ubi_num && gluebi->vol_id == vol_id)\n\t\t\treturn gluebi;\n\treturn NULL;\n}\n\n \nstatic int gluebi_get_device(struct mtd_info *mtd)\n{\n\tstruct gluebi_device *gluebi;\n\tint ubi_mode = UBI_READONLY;\n\n\tif (mtd->flags & MTD_WRITEABLE)\n\t\tubi_mode = UBI_READWRITE;\n\n\tgluebi = container_of(mtd, struct gluebi_device, mtd);\n\tmutex_lock(&devices_mutex);\n\tif (gluebi->refcnt > 0) {\n\t\t \n\t\tgluebi->refcnt += 1;\n\t\tmutex_unlock(&devices_mutex);\n\t\treturn 0;\n\t}\n\n\t \n\tgluebi->desc = ubi_open_volume(gluebi->ubi_num, gluebi->vol_id,\n\t\t\t\t       ubi_mode);\n\tif (IS_ERR(gluebi->desc)) {\n\t\tmutex_unlock(&devices_mutex);\n\t\treturn PTR_ERR(gluebi->desc);\n\t}\n\tgluebi->refcnt += 1;\n\tmutex_unlock(&devices_mutex);\n\treturn 0;\n}\n\n \nstatic void gluebi_put_device(struct mtd_info *mtd)\n{\n\tstruct gluebi_device *gluebi;\n\n\tgluebi = container_of(mtd, struct gluebi_device, mtd);\n\tmutex_lock(&devices_mutex);\n\tgluebi->refcnt -= 1;\n\tif (gluebi->refcnt == 0)\n\t\tubi_close_volume(gluebi->desc);\n\tmutex_unlock(&devices_mutex);\n}\n\n \nstatic int gluebi_read(struct mtd_info *mtd, loff_t from, size_t len,\n\t\t       size_t *retlen, unsigned char *buf)\n{\n\tint err = 0, lnum, offs, bytes_left;\n\tstruct gluebi_device *gluebi;\n\n\tgluebi = container_of(mtd, struct gluebi_device, mtd);\n\tlnum = div_u64_rem(from, mtd->erasesize, &offs);\n\tbytes_left = len;\n\twhile (bytes_left) {\n\t\tsize_t to_read = mtd->erasesize - offs;\n\n\t\tif (to_read > bytes_left)\n\t\t\tto_read = bytes_left;\n\n\t\terr = ubi_read(gluebi->desc, lnum, buf, offs, to_read);\n\t\tif (err)\n\t\t\tbreak;\n\n\t\tlnum += 1;\n\t\toffs = 0;\n\t\tbytes_left -= to_read;\n\t\tbuf += to_read;\n\t}\n\n\t*retlen = len - bytes_left;\n\treturn err;\n}\n\n \nstatic int gluebi_write(struct mtd_info *mtd, loff_t to, size_t len,\n\t\t\tsize_t *retlen, const u_char *buf)\n{\n\tint err = 0, lnum, offs, bytes_left;\n\tstruct gluebi_device *gluebi;\n\n\tgluebi = container_of(mtd, struct gluebi_device, mtd);\n\tlnum = div_u64_rem(to, mtd->erasesize, &offs);\n\n\tif (len % mtd->writesize || offs % mtd->writesize)\n\t\treturn -EINVAL;\n\n\tbytes_left = len;\n\twhile (bytes_left) {\n\t\tsize_t to_write = mtd->erasesize - offs;\n\n\t\tif (to_write > bytes_left)\n\t\t\tto_write = bytes_left;\n\n\t\terr = ubi_leb_write(gluebi->desc, lnum, buf, offs, to_write);\n\t\tif (err)\n\t\t\tbreak;\n\n\t\tlnum += 1;\n\t\toffs = 0;\n\t\tbytes_left -= to_write;\n\t\tbuf += to_write;\n\t}\n\n\t*retlen = len - bytes_left;\n\treturn err;\n}\n\n \nstatic int gluebi_erase(struct mtd_info *mtd, struct erase_info *instr)\n{\n\tint err, i, lnum, count;\n\tstruct gluebi_device *gluebi;\n\n\tif (mtd_mod_by_ws(instr->addr, mtd) || mtd_mod_by_ws(instr->len, mtd))\n\t\treturn -EINVAL;\n\n\tlnum = mtd_div_by_eb(instr->addr, mtd);\n\tcount = mtd_div_by_eb(instr->len, mtd);\n\tgluebi = container_of(mtd, struct gluebi_device, mtd);\n\n\tfor (i = 0; i < count - 1; i++) {\n\t\terr = ubi_leb_unmap(gluebi->desc, lnum + i);\n\t\tif (err)\n\t\t\tgoto out_err;\n\t}\n\t \n\terr = ubi_leb_erase(gluebi->desc, lnum + i);\n\tif (err)\n\t\tgoto out_err;\n\n\treturn 0;\n\nout_err:\n\tinstr->fail_addr = (long long)lnum * mtd->erasesize;\n\treturn err;\n}\n\n \nstatic int gluebi_create(struct ubi_device_info *di,\n\t\t\t struct ubi_volume_info *vi)\n{\n\tstruct gluebi_device *gluebi, *g;\n\tstruct mtd_info *mtd;\n\n\tgluebi = kzalloc(sizeof(struct gluebi_device), GFP_KERNEL);\n\tif (!gluebi)\n\t\treturn -ENOMEM;\n\n\tmtd = &gluebi->mtd;\n\tmtd->name = kmemdup(vi->name, vi->name_len + 1, GFP_KERNEL);\n\tif (!mtd->name) {\n\t\tkfree(gluebi);\n\t\treturn -ENOMEM;\n\t}\n\n\tgluebi->vol_id = vi->vol_id;\n\tgluebi->ubi_num = vi->ubi_num;\n\tmtd->type = MTD_UBIVOLUME;\n\tif (!di->ro_mode)\n\t\tmtd->flags = MTD_WRITEABLE;\n\tmtd->owner      = THIS_MODULE;\n\tmtd->writesize  = di->min_io_size;\n\tmtd->erasesize  = vi->usable_leb_size;\n\tmtd->_read       = gluebi_read;\n\tmtd->_write      = gluebi_write;\n\tmtd->_erase      = gluebi_erase;\n\tmtd->_get_device = gluebi_get_device;\n\tmtd->_put_device = gluebi_put_device;\n\n\t \n\tif (vi->vol_type == UBI_DYNAMIC_VOLUME)\n\t\tmtd->size = (unsigned long long)vi->usable_leb_size * vi->size;\n\telse\n\t\tmtd->size = vi->used_bytes;\n\n\t \n\tmutex_lock(&devices_mutex);\n\tg = find_gluebi_nolock(vi->ubi_num, vi->vol_id);\n\tif (g)\n\t\terr_msg(\"gluebi MTD device %d form UBI device %d volume %d already exists\",\n\t\t\tg->mtd.index, vi->ubi_num, vi->vol_id);\n\tmutex_unlock(&devices_mutex);\n\n\tif (mtd_device_register(mtd, NULL, 0)) {\n\t\terr_msg(\"cannot add MTD device\");\n\t\tkfree(mtd->name);\n\t\tkfree(gluebi);\n\t\treturn -ENFILE;\n\t}\n\n\tmutex_lock(&devices_mutex);\n\tlist_add_tail(&gluebi->list, &gluebi_devices);\n\tmutex_unlock(&devices_mutex);\n\treturn 0;\n}\n\n \nstatic int gluebi_remove(struct ubi_volume_info *vi)\n{\n\tint err = 0;\n\tstruct mtd_info *mtd;\n\tstruct gluebi_device *gluebi;\n\n\tmutex_lock(&devices_mutex);\n\tgluebi = find_gluebi_nolock(vi->ubi_num, vi->vol_id);\n\tif (!gluebi) {\n\t\terr_msg(\"got remove notification for unknown UBI device %d volume %d\",\n\t\t\tvi->ubi_num, vi->vol_id);\n\t\terr = -ENOENT;\n\t} else if (gluebi->refcnt)\n\t\terr = -EBUSY;\n\telse\n\t\tlist_del(&gluebi->list);\n\tmutex_unlock(&devices_mutex);\n\tif (err)\n\t\treturn err;\n\n\tmtd = &gluebi->mtd;\n\terr = mtd_device_unregister(mtd);\n\tif (err) {\n\t\terr_msg(\"cannot remove fake MTD device %d, UBI device %d, volume %d, error %d\",\n\t\t\tmtd->index, gluebi->ubi_num, gluebi->vol_id, err);\n\t\tmutex_lock(&devices_mutex);\n\t\tlist_add_tail(&gluebi->list, &gluebi_devices);\n\t\tmutex_unlock(&devices_mutex);\n\t\treturn err;\n\t}\n\n\tkfree(mtd->name);\n\tkfree(gluebi);\n\treturn 0;\n}\n\n \nstatic int gluebi_updated(struct ubi_volume_info *vi)\n{\n\tstruct gluebi_device *gluebi;\n\n\tmutex_lock(&devices_mutex);\n\tgluebi = find_gluebi_nolock(vi->ubi_num, vi->vol_id);\n\tif (!gluebi) {\n\t\tmutex_unlock(&devices_mutex);\n\t\terr_msg(\"got update notification for unknown UBI device %d volume %d\",\n\t\t\tvi->ubi_num, vi->vol_id);\n\t\treturn -ENOENT;\n\t}\n\n\tif (vi->vol_type == UBI_STATIC_VOLUME)\n\t\tgluebi->mtd.size = vi->used_bytes;\n\tmutex_unlock(&devices_mutex);\n\treturn 0;\n}\n\n \nstatic int gluebi_resized(struct ubi_volume_info *vi)\n{\n\tstruct gluebi_device *gluebi;\n\n\tmutex_lock(&devices_mutex);\n\tgluebi = find_gluebi_nolock(vi->ubi_num, vi->vol_id);\n\tif (!gluebi) {\n\t\tmutex_unlock(&devices_mutex);\n\t\terr_msg(\"got update notification for unknown UBI device %d volume %d\",\n\t\t\tvi->ubi_num, vi->vol_id);\n\t\treturn -ENOENT;\n\t}\n\tgluebi->mtd.size = vi->used_bytes;\n\tmutex_unlock(&devices_mutex);\n\treturn 0;\n}\n\n \nstatic int gluebi_notify(struct notifier_block *nb, unsigned long l,\n\t\t\t void *ns_ptr)\n{\n\tstruct ubi_notification *nt = ns_ptr;\n\n\tswitch (l) {\n\tcase UBI_VOLUME_ADDED:\n\t\tgluebi_create(&nt->di, &nt->vi);\n\t\tbreak;\n\tcase UBI_VOLUME_REMOVED:\n\t\tgluebi_remove(&nt->vi);\n\t\tbreak;\n\tcase UBI_VOLUME_RESIZED:\n\t\tgluebi_resized(&nt->vi);\n\t\tbreak;\n\tcase UBI_VOLUME_UPDATED:\n\t\tgluebi_updated(&nt->vi);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn NOTIFY_OK;\n}\n\nstatic struct notifier_block gluebi_notifier = {\n\t.notifier_call\t= gluebi_notify,\n};\n\nstatic int __init ubi_gluebi_init(void)\n{\n\treturn ubi_register_volume_notifier(&gluebi_notifier, 0);\n}\n\nstatic void __exit ubi_gluebi_exit(void)\n{\n\tstruct gluebi_device *gluebi, *g;\n\n\tlist_for_each_entry_safe(gluebi, g, &gluebi_devices, list) {\n\t\tint err;\n\t\tstruct mtd_info *mtd = &gluebi->mtd;\n\n\t\terr = mtd_device_unregister(mtd);\n\t\tif (err)\n\t\t\terr_msg(\"error %d while removing gluebi MTD device %d, UBI device %d, volume %d - ignoring\",\n\t\t\t\terr, mtd->index, gluebi->ubi_num,\n\t\t\t\tgluebi->vol_id);\n\t\tkfree(mtd->name);\n\t\tkfree(gluebi);\n\t}\n\tubi_unregister_volume_notifier(&gluebi_notifier);\n}\n\nmodule_init(ubi_gluebi_init);\nmodule_exit(ubi_gluebi_exit);\nMODULE_DESCRIPTION(\"MTD emulation layer over UBI volumes\");\nMODULE_AUTHOR(\"Artem Bityutskiy, Joern Engel\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}