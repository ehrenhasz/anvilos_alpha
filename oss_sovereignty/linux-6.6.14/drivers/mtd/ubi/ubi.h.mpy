{
  "module_name": "ubi.h",
  "hash_id": "9390f40e7e3a2306c99af19f89572d781ee4d95175fd101ae8b113a0f926728d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/ubi/ubi.h",
  "human_readable_source": " \n \n\n#ifndef __UBI_UBI_H__\n#define __UBI_UBI_H__\n\n#include <linux/types.h>\n#include <linux/list.h>\n#include <linux/rbtree.h>\n#include <linux/sched.h>\n#include <linux/wait.h>\n#include <linux/mutex.h>\n#include <linux/rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/fs.h>\n#include <linux/cdev.h>\n#include <linux/device.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/notifier.h>\n#include <linux/mtd/mtd.h>\n#include <linux/mtd/ubi.h>\n#include <linux/pgtable.h>\n\n#include \"ubi-media.h\"\n\n \n#define UBI_MAX_DEVICES 32\n\n \n#define UBI_NAME_STR \"ubi\"\n\nstruct ubi_device;\n\n \n__printf(2, 3)\nvoid ubi_msg(const struct ubi_device *ubi, const char *fmt, ...);\n\n \n__printf(2, 3)\nvoid ubi_warn(const struct ubi_device *ubi, const char *fmt, ...);\n\n \n__printf(2, 3)\nvoid ubi_err(const struct ubi_device *ubi, const char *fmt, ...);\n\n \n#define UBI_BGT_NAME_PATTERN \"ubi_bgt%dd\"\n\n \n#define UBI_LEB_UNMAPPED -1\n\n \n#define UBI_IO_RETRIES 3\n\n \n#define UBI_PROT_QUEUE_LEN 10\n\n \n#define UBI_UNKNOWN -1\n\n \n#define UBI_DFS_DIR_NAME \"ubi%d\"\n#define UBI_DFS_DIR_LEN  (3 + 2 + 1)\n\n \nenum {\n\tUBI_IO_FF = 1,\n\tUBI_IO_FF_BITFLIPS,\n\tUBI_IO_BAD_HDR,\n\tUBI_IO_BAD_HDR_EBADMSG,\n\tUBI_IO_BITFLIPS,\n};\n\n \nenum {\n\tMOVE_CANCEL_RACE = 1,\n\tMOVE_SOURCE_RD_ERR,\n\tMOVE_TARGET_RD_ERR,\n\tMOVE_TARGET_WR_ERR,\n\tMOVE_TARGET_BITFLIPS,\n\tMOVE_RETRY,\n};\n\n \nenum {\n\tUBI_NO_FASTMAP = 1,\n\tUBI_BAD_FASTMAP,\n};\n\n \nenum {\n\tPOWER_CUT_EC_WRITE = 0x01,\n\tPOWER_CUT_VID_WRITE = 0x02,\n};\n\n \nstruct ubi_vid_io_buf {\n\tstruct ubi_vid_hdr *hdr;\n\tvoid *buffer;\n};\n\n \nstruct ubi_wl_entry {\n\tunion {\n\t\tstruct rb_node rb;\n\t\tstruct list_head list;\n\t} u;\n\tint ec;\n\tint pnum;\n};\n\n \nstruct ubi_ltree_entry {\n\tstruct rb_node rb;\n\tint vol_id;\n\tint lnum;\n\tint users;\n\tstruct rw_semaphore mutex;\n};\n\n \nstruct ubi_rename_entry {\n\tint new_name_len;\n\tchar new_name[UBI_VOL_NAME_MAX + 1];\n\tint remove;\n\tstruct ubi_volume_desc *desc;\n\tstruct list_head list;\n};\n\nstruct ubi_volume_desc;\n\n \nstruct ubi_fastmap_layout {\n\tstruct ubi_wl_entry *e[UBI_FM_MAX_BLOCKS];\n\tint to_be_tortured[UBI_FM_MAX_BLOCKS];\n\tint used_blocks;\n\tint max_pool_size;\n\tint max_wl_pool_size;\n};\n\n \nstruct ubi_fm_pool {\n\tint pebs[UBI_FM_MAX_POOL_SIZE];\n\tint used;\n\tint size;\n\tint max_size;\n};\n\n \nstruct ubi_eba_leb_desc {\n\tint lnum;\n\tint pnum;\n};\n\n \nstruct ubi_volume {\n\tstruct device dev;\n\tstruct cdev cdev;\n\tstruct ubi_device *ubi;\n\tint vol_id;\n\tint ref_count;\n\tint readers;\n\tint writers;\n\tint exclusive;\n\tint metaonly;\n\n\tint reserved_pebs;\n\tint vol_type;\n\tint usable_leb_size;\n\tint used_ebs;\n\tint last_eb_bytes;\n\tlong long used_bytes;\n\tint alignment;\n\tint data_pad;\n\tint name_len;\n\tchar name[UBI_VOL_NAME_MAX + 1];\n\n\tint upd_ebs;\n\tint ch_lnum;\n\tlong long upd_bytes;\n\tlong long upd_received;\n\tvoid *upd_buf;\n\n\tstruct ubi_eba_table *eba_tbl;\n\tunsigned int skip_check:1;\n\tunsigned int checked:1;\n\tunsigned int corrupted:1;\n\tunsigned int upd_marker:1;\n\tunsigned int updating:1;\n\tunsigned int changing_leb:1;\n\tunsigned int direct_writes:1;\n\n#ifdef CONFIG_MTD_UBI_FASTMAP\n\tunsigned long *checkmap;\n#endif\n};\n\n \nstruct ubi_volume_desc {\n\tstruct ubi_volume *vol;\n\tint mode;\n};\n\n \nstruct ubi_debug_info {\n\tunsigned int chk_gen:1;\n\tunsigned int chk_io:1;\n\tunsigned int chk_fastmap:1;\n\tunsigned int disable_bgt:1;\n\tunsigned int emulate_bitflips:1;\n\tunsigned int emulate_io_failures:1;\n\tunsigned int emulate_power_cut:2;\n\tunsigned int power_cut_counter;\n\tunsigned int power_cut_min;\n\tunsigned int power_cut_max;\n\tchar dfs_dir_name[UBI_DFS_DIR_LEN + 1];\n\tstruct dentry *dfs_dir;\n\tstruct dentry *dfs_chk_gen;\n\tstruct dentry *dfs_chk_io;\n\tstruct dentry *dfs_chk_fastmap;\n\tstruct dentry *dfs_disable_bgt;\n\tstruct dentry *dfs_emulate_bitflips;\n\tstruct dentry *dfs_emulate_io_failures;\n\tstruct dentry *dfs_emulate_power_cut;\n\tstruct dentry *dfs_power_cut_min;\n\tstruct dentry *dfs_power_cut_max;\n};\n\n \nstruct ubi_device {\n\tstruct cdev cdev;\n\tstruct device dev;\n\tint ubi_num;\n\tchar ubi_name[sizeof(UBI_NAME_STR)+5];\n\tint vol_count;\n\tstruct ubi_volume *volumes[UBI_MAX_VOLUMES+UBI_INT_VOL_COUNT];\n\tspinlock_t volumes_lock;\n\tint ref_count;\n\tint image_seq;\n\n\tint rsvd_pebs;\n\tint avail_pebs;\n\tint beb_rsvd_pebs;\n\tint beb_rsvd_level;\n\tint bad_peb_limit;\n\n\tint autoresize_vol_id;\n\tint vtbl_slots;\n\tint vtbl_size;\n\tstruct ubi_vtbl_record *vtbl;\n\tstruct mutex device_mutex;\n\n\tint max_ec;\n\t \n\tint mean_ec;\n\n\t \n\tunsigned long long global_sqnum;\n\tspinlock_t ltree_lock;\n\tstruct rb_root ltree;\n\tstruct mutex alc_mutex;\n\n\t \n\tint fm_disabled;\n\tstruct ubi_fastmap_layout *fm;\n\tstruct ubi_fm_pool fm_pool;\n\tstruct ubi_fm_pool fm_wl_pool;\n\tstruct rw_semaphore fm_eba_sem;\n\tstruct rw_semaphore fm_protect;\n\tvoid *fm_buf;\n\tsize_t fm_size;\n\tstruct work_struct fm_work;\n\tint fm_work_scheduled;\n\tint fast_attach;\n\tstruct ubi_wl_entry *fm_anchor;\n\tint fm_do_produce_anchor;\n\n\t \n\tstruct rb_root used;\n\tstruct rb_root erroneous;\n\tstruct rb_root free;\n\tint free_count;\n\tstruct rb_root scrub;\n\tstruct list_head pq[UBI_PROT_QUEUE_LEN];\n\tint pq_head;\n\tspinlock_t wl_lock;\n\tstruct mutex move_mutex;\n\tstruct rw_semaphore work_sem;\n\tint wl_scheduled;\n\tstruct ubi_wl_entry **lookuptbl;\n\tstruct ubi_wl_entry *move_from;\n\tstruct ubi_wl_entry *move_to;\n\tint move_to_put;\n\tstruct list_head works;\n\tint works_count;\n\tstruct task_struct *bgt_thread;\n\tint thread_enabled;\n\tchar bgt_name[sizeof(UBI_BGT_NAME_PATTERN)+2];\n\n\t \n\tlong long flash_size;\n\tint peb_count;\n\tint peb_size;\n\tint bad_peb_count;\n\tint good_peb_count;\n\tint corr_peb_count;\n\tint erroneous_peb_count;\n\tint max_erroneous;\n\tint min_io_size;\n\tint hdrs_min_io_size;\n\tint ro_mode;\n\tint leb_size;\n\tint leb_start;\n\tint ec_hdr_alsize;\n\tint vid_hdr_alsize;\n\tint vid_hdr_offset;\n\tint vid_hdr_aloffset;\n\tint vid_hdr_shift;\n\tunsigned int bad_allowed:1;\n\tunsigned int nor_flash:1;\n\tint max_write_size;\n\tstruct mtd_info *mtd;\n\n\tvoid *peb_buf;\n\tstruct mutex buf_mutex;\n\tstruct mutex ckvol_mutex;\n\n\tstruct ubi_debug_info dbg;\n};\n\n \nstruct ubi_ainf_peb {\n\tint ec;\n\tint pnum;\n\tint vol_id;\n\tint lnum;\n\tunsigned int scrub:1;\n\tunsigned int copy_flag:1;\n\tunsigned long long sqnum;\n\tunion {\n\t\tstruct rb_node rb;\n\t\tstruct list_head list;\n\t} u;\n};\n\n \nstruct ubi_ainf_volume {\n\tint vol_id;\n\tint highest_lnum;\n\tint leb_count;\n\tint vol_type;\n\tint used_ebs;\n\tint last_data_size;\n\tint data_pad;\n\tint compat;\n\tstruct rb_node rb;\n\tstruct rb_root root;\n};\n\n \nstruct ubi_attach_info {\n\tstruct rb_root volumes;\n\tstruct list_head corr;\n\tstruct list_head free;\n\tstruct list_head erase;\n\tstruct list_head alien;\n\tstruct list_head fastmap;\n\tint corr_peb_count;\n\tint empty_peb_count;\n\tint alien_peb_count;\n\tint bad_peb_count;\n\tint maybe_bad_peb_count;\n\tint vols_found;\n\tint highest_vol_id;\n\tint is_empty;\n\tint force_full_scan;\n\tint min_ec;\n\tint max_ec;\n\tunsigned long long max_sqnum;\n\tint mean_ec;\n\tuint64_t ec_sum;\n\tint ec_count;\n\tstruct kmem_cache *aeb_slab_cache;\n\tstruct ubi_ec_hdr *ech;\n\tstruct ubi_vid_io_buf *vidb;\n};\n\n \nstruct ubi_work {\n\tstruct list_head list;\n\tint (*func)(struct ubi_device *ubi, struct ubi_work *wrk, int shutdown);\n\t \n\tstruct ubi_wl_entry *e;\n\tint vol_id;\n\tint lnum;\n\tint torture;\n};\n\n#include \"debug.h\"\n\nextern struct kmem_cache *ubi_wl_entry_slab;\nextern const struct file_operations ubi_ctrl_cdev_operations;\nextern const struct file_operations ubi_cdev_operations;\nextern const struct file_operations ubi_vol_cdev_operations;\nextern struct class ubi_class;\nextern struct mutex ubi_devices_mutex;\nextern struct blocking_notifier_head ubi_notifiers;\n\n \nstruct ubi_ainf_peb *ubi_alloc_aeb(struct ubi_attach_info *ai, int pnum,\n\t\t\t\t   int ec);\nvoid ubi_free_aeb(struct ubi_attach_info *ai, struct ubi_ainf_peb *aeb);\nint ubi_add_to_av(struct ubi_device *ubi, struct ubi_attach_info *ai, int pnum,\n\t\t  int ec, const struct ubi_vid_hdr *vid_hdr, int bitflips);\nstruct ubi_ainf_volume *ubi_add_av(struct ubi_attach_info *ai, int vol_id);\nstruct ubi_ainf_volume *ubi_find_av(const struct ubi_attach_info *ai,\n\t\t\t\t    int vol_id);\nvoid ubi_remove_av(struct ubi_attach_info *ai, struct ubi_ainf_volume *av);\nstruct ubi_ainf_peb *ubi_early_get_peb(struct ubi_device *ubi,\n\t\t\t\t       struct ubi_attach_info *ai);\nint ubi_attach(struct ubi_device *ubi, int force_scan);\nvoid ubi_destroy_ai(struct ubi_attach_info *ai);\n\n \nint ubi_change_vtbl_record(struct ubi_device *ubi, int idx,\n\t\t\t   struct ubi_vtbl_record *vtbl_rec);\nint ubi_vtbl_rename_volumes(struct ubi_device *ubi,\n\t\t\t    struct list_head *rename_list);\nint ubi_read_volume_table(struct ubi_device *ubi, struct ubi_attach_info *ai);\n\n \nint ubi_create_volume(struct ubi_device *ubi, struct ubi_mkvol_req *req);\nint ubi_remove_volume(struct ubi_volume_desc *desc, int no_vtbl);\nint ubi_resize_volume(struct ubi_volume_desc *desc, int reserved_pebs);\nint ubi_rename_volumes(struct ubi_device *ubi, struct list_head *rename_list);\nint ubi_add_volume(struct ubi_device *ubi, struct ubi_volume *vol);\nvoid ubi_free_volume(struct ubi_device *ubi, struct ubi_volume *vol);\n\n \nint ubi_start_update(struct ubi_device *ubi, struct ubi_volume *vol,\n\t\t     long long bytes);\nint ubi_more_update_data(struct ubi_device *ubi, struct ubi_volume *vol,\n\t\t\t const void __user *buf, int count);\nint ubi_start_leb_change(struct ubi_device *ubi, struct ubi_volume *vol,\n\t\t\t const struct ubi_leb_change_req *req);\nint ubi_more_leb_change_data(struct ubi_device *ubi, struct ubi_volume *vol,\n\t\t\t     const void __user *buf, int count);\n\n \nint ubi_calc_data_len(const struct ubi_device *ubi, const void *buf,\n\t\t      int length);\nint ubi_check_volume(struct ubi_device *ubi, int vol_id);\nvoid ubi_update_reserved(struct ubi_device *ubi);\nvoid ubi_calculate_reserved(struct ubi_device *ubi);\nint ubi_check_pattern(const void *buf, uint8_t patt, int size);\n\nstatic inline bool ubi_leb_valid(struct ubi_volume *vol, int lnum)\n{\n\treturn lnum >= 0 && lnum < vol->reserved_pebs;\n}\n\n \nstruct ubi_eba_table *ubi_eba_create_table(struct ubi_volume *vol,\n\t\t\t\t\t   int nentries);\nvoid ubi_eba_destroy_table(struct ubi_eba_table *tbl);\nvoid ubi_eba_copy_table(struct ubi_volume *vol, struct ubi_eba_table *dst,\n\t\t\tint nentries);\nvoid ubi_eba_replace_table(struct ubi_volume *vol, struct ubi_eba_table *tbl);\nvoid ubi_eba_get_ldesc(struct ubi_volume *vol, int lnum,\n\t\t       struct ubi_eba_leb_desc *ldesc);\nbool ubi_eba_is_mapped(struct ubi_volume *vol, int lnum);\nint ubi_eba_unmap_leb(struct ubi_device *ubi, struct ubi_volume *vol,\n\t\t      int lnum);\nint ubi_eba_read_leb(struct ubi_device *ubi, struct ubi_volume *vol, int lnum,\n\t\t     void *buf, int offset, int len, int check);\nint ubi_eba_read_leb_sg(struct ubi_device *ubi, struct ubi_volume *vol,\n\t\t\tstruct ubi_sgl *sgl, int lnum, int offset, int len,\n\t\t\tint check);\nint ubi_eba_write_leb(struct ubi_device *ubi, struct ubi_volume *vol, int lnum,\n\t\t      const void *buf, int offset, int len);\nint ubi_eba_write_leb_st(struct ubi_device *ubi, struct ubi_volume *vol,\n\t\t\t int lnum, const void *buf, int len, int used_ebs);\nint ubi_eba_atomic_leb_change(struct ubi_device *ubi, struct ubi_volume *vol,\n\t\t\t      int lnum, const void *buf, int len);\nint ubi_eba_copy_leb(struct ubi_device *ubi, int from, int to,\n\t\t     struct ubi_vid_io_buf *vidb);\nint ubi_eba_init(struct ubi_device *ubi, struct ubi_attach_info *ai);\nunsigned long long ubi_next_sqnum(struct ubi_device *ubi);\nint self_check_eba(struct ubi_device *ubi, struct ubi_attach_info *ai_fastmap,\n\t\t   struct ubi_attach_info *ai_scan);\n\n \nint ubi_wl_get_peb(struct ubi_device *ubi);\nint ubi_wl_put_peb(struct ubi_device *ubi, int vol_id, int lnum,\n\t\t   int pnum, int torture);\nint ubi_wl_flush(struct ubi_device *ubi, int vol_id, int lnum);\nint ubi_wl_scrub_peb(struct ubi_device *ubi, int pnum);\nint ubi_wl_init(struct ubi_device *ubi, struct ubi_attach_info *ai);\nvoid ubi_wl_close(struct ubi_device *ubi);\nint ubi_thread(void *u);\nstruct ubi_wl_entry *ubi_wl_get_fm_peb(struct ubi_device *ubi, int anchor);\nint ubi_wl_put_fm_peb(struct ubi_device *ubi, struct ubi_wl_entry *used_e,\n\t\t      int lnum, int torture);\nint ubi_is_erase_work(struct ubi_work *wrk);\nvoid ubi_refill_pools(struct ubi_device *ubi);\nint ubi_ensure_anchor_pebs(struct ubi_device *ubi);\nint ubi_bitflip_check(struct ubi_device *ubi, int pnum, int force_scrub);\n\n \nint ubi_io_read(const struct ubi_device *ubi, void *buf, int pnum, int offset,\n\t\tint len);\nint ubi_io_write(struct ubi_device *ubi, const void *buf, int pnum, int offset,\n\t\t int len);\nint ubi_io_sync_erase(struct ubi_device *ubi, int pnum, int torture);\nint ubi_io_is_bad(const struct ubi_device *ubi, int pnum);\nint ubi_io_mark_bad(const struct ubi_device *ubi, int pnum);\nint ubi_io_read_ec_hdr(struct ubi_device *ubi, int pnum,\n\t\t       struct ubi_ec_hdr *ec_hdr, int verbose);\nint ubi_io_write_ec_hdr(struct ubi_device *ubi, int pnum,\n\t\t\tstruct ubi_ec_hdr *ec_hdr);\nint ubi_io_read_vid_hdr(struct ubi_device *ubi, int pnum,\n\t\t\tstruct ubi_vid_io_buf *vidb, int verbose);\nint ubi_io_write_vid_hdr(struct ubi_device *ubi, int pnum,\n\t\t\t struct ubi_vid_io_buf *vidb);\n\n \nint ubi_attach_mtd_dev(struct mtd_info *mtd, int ubi_num,\n\t\t       int vid_hdr_offset, int max_beb_per1024,\n\t\t       bool disable_fm);\nint ubi_detach_mtd_dev(int ubi_num, int anyway);\nstruct ubi_device *ubi_get_device(int ubi_num);\nvoid ubi_put_device(struct ubi_device *ubi);\nstruct ubi_device *ubi_get_by_major(int major);\nint ubi_major2num(int major);\nint ubi_volume_notify(struct ubi_device *ubi, struct ubi_volume *vol,\n\t\t      int ntype);\nint ubi_notify_all(struct ubi_device *ubi, int ntype,\n\t\t   struct notifier_block *nb);\nint ubi_enumerate_volumes(struct notifier_block *nb);\nvoid ubi_free_all_volumes(struct ubi_device *ubi);\nvoid ubi_free_internal_volumes(struct ubi_device *ubi);\n\n \nvoid ubi_do_get_device_info(struct ubi_device *ubi, struct ubi_device_info *di);\nvoid ubi_do_get_volume_info(struct ubi_device *ubi, struct ubi_volume *vol,\n\t\t\t    struct ubi_volume_info *vi);\n \nint ubi_compare_lebs(struct ubi_device *ubi, const struct ubi_ainf_peb *aeb,\n\t\t      int pnum, const struct ubi_vid_hdr *vid_hdr);\n\n \n#ifdef CONFIG_MTD_UBI_FASTMAP\nsize_t ubi_calc_fm_size(struct ubi_device *ubi);\nint ubi_update_fastmap(struct ubi_device *ubi);\nint ubi_scan_fastmap(struct ubi_device *ubi, struct ubi_attach_info *ai,\n\t\t     struct ubi_attach_info *scan_ai);\nint ubi_fastmap_init_checkmap(struct ubi_volume *vol, int leb_count);\nvoid ubi_fastmap_destroy_checkmap(struct ubi_volume *vol);\n#else\nstatic inline int ubi_update_fastmap(struct ubi_device *ubi) { return 0; }\nstatic inline int ubi_fastmap_init_checkmap(struct ubi_volume *vol, int leb_count) { return 0; }\nstatic inline void ubi_fastmap_destroy_checkmap(struct ubi_volume *vol) {}\n#endif\n\n \n#ifdef CONFIG_MTD_UBI_BLOCK\nint ubiblock_init(void);\nvoid ubiblock_exit(void);\nint ubiblock_create(struct ubi_volume_info *vi);\nint ubiblock_remove(struct ubi_volume_info *vi);\n#else\nstatic inline int ubiblock_init(void) { return 0; }\nstatic inline void ubiblock_exit(void) {}\nstatic inline int ubiblock_create(struct ubi_volume_info *vi)\n{\n\treturn -ENOSYS;\n}\nstatic inline int ubiblock_remove(struct ubi_volume_info *vi)\n{\n\treturn -ENOSYS;\n}\n#endif\n\n \n#define ubi_for_each_free_peb(ubi, e, tmp_rb)\t\\\n\tubi_rb_for_each_entry((tmp_rb), (e), &(ubi)->free, u.rb)\n\n \n#define ubi_for_each_used_peb(ubi, e, tmp_rb)\t\\\n\tubi_rb_for_each_entry((tmp_rb), (e), &(ubi)->used, u.rb)\n\n \n#define ubi_for_each_scrub_peb(ubi, e, tmp_rb)\t\\\n\tubi_rb_for_each_entry((tmp_rb), (e), &(ubi)->scrub, u.rb)\n\n \n#define ubi_for_each_protected_peb(ubi, i, e)\t\\\n\tfor ((i) = 0; (i) < UBI_PROT_QUEUE_LEN; (i)++)\t\\\n\t\tlist_for_each_entry((e), &(ubi->pq[(i)]), u.list)\n\n \n#define ubi_rb_for_each_entry(rb, pos, root, member)                         \\\n\tfor (rb = rb_first(root),                                            \\\n\t     pos = (rb ? container_of(rb, typeof(*pos), member) : NULL);     \\\n\t     rb;                                                             \\\n\t     rb = rb_next(rb),                                               \\\n\t     pos = (rb ? container_of(rb, typeof(*pos), member) : NULL))\n\n \nstatic inline void ubi_move_aeb_to_list(struct ubi_ainf_volume *av,\n\t\t\t\t\t struct ubi_ainf_peb *aeb,\n\t\t\t\t\t struct list_head *list)\n{\n\t\trb_erase(&aeb->u.rb, &av->root);\n\t\tlist_add_tail(&aeb->u.list, list);\n}\n\n \nstatic inline void ubi_init_vid_buf(const struct ubi_device *ubi,\n\t\t\t\t    struct ubi_vid_io_buf *vidb,\n\t\t\t\t    void *buf)\n{\n\tif (buf)\n\t\tmemset(buf, 0, ubi->vid_hdr_alsize);\n\n\tvidb->buffer = buf;\n\tvidb->hdr = buf + ubi->vid_hdr_shift;\n}\n\n \nstatic inline struct ubi_vid_io_buf *\nubi_alloc_vid_buf(const struct ubi_device *ubi, gfp_t gfp_flags)\n{\n\tstruct ubi_vid_io_buf *vidb;\n\tvoid *buf;\n\n\tvidb = kzalloc(sizeof(*vidb), gfp_flags);\n\tif (!vidb)\n\t\treturn NULL;\n\n\tbuf = kmalloc(ubi->vid_hdr_alsize, gfp_flags);\n\tif (!buf) {\n\t\tkfree(vidb);\n\t\treturn NULL;\n\t}\n\n\tubi_init_vid_buf(ubi, vidb, buf);\n\n\treturn vidb;\n}\n\n \nstatic inline void ubi_free_vid_buf(struct ubi_vid_io_buf *vidb)\n{\n\tif (!vidb)\n\t\treturn;\n\n\tkfree(vidb->buffer);\n\tkfree(vidb);\n}\n\n \nstatic inline struct ubi_vid_hdr *ubi_get_vid_hdr(struct ubi_vid_io_buf *vidb)\n{\n\treturn vidb->hdr;\n}\n\n \nstatic inline int ubi_io_read_data(const struct ubi_device *ubi, void *buf,\n\t\t\t\t   int pnum, int offset, int len)\n{\n\tubi_assert(offset >= 0);\n\treturn ubi_io_read(ubi, buf, pnum, offset + ubi->leb_start, len);\n}\n\n \nstatic inline int ubi_io_write_data(struct ubi_device *ubi, const void *buf,\n\t\t\t\t    int pnum, int offset, int len)\n{\n\tubi_assert(offset >= 0);\n\treturn ubi_io_write(ubi, buf, pnum, offset + ubi->leb_start, len);\n}\n\n \nstatic inline void ubi_ro_mode(struct ubi_device *ubi)\n{\n\tif (!ubi->ro_mode) {\n\t\tubi->ro_mode = 1;\n\t\tubi_warn(ubi, \"switch to read-only mode\");\n\t\tdump_stack();\n\t}\n}\n\n \nstatic inline int vol_id2idx(const struct ubi_device *ubi, int vol_id)\n{\n\tif (vol_id >= UBI_INTERNAL_VOL_START)\n\t\treturn vol_id - UBI_INTERNAL_VOL_START + ubi->vtbl_slots;\n\telse\n\t\treturn vol_id;\n}\n\n \nstatic inline int idx2vol_id(const struct ubi_device *ubi, int idx)\n{\n\tif (idx >= ubi->vtbl_slots)\n\t\treturn idx - ubi->vtbl_slots + UBI_INTERNAL_VOL_START;\n\telse\n\t\treturn idx;\n}\n\n \nstatic inline bool ubi_is_fm_vol(int vol_id)\n{\n\tswitch (vol_id) {\n\t\tcase UBI_FM_SB_VOLUME_ID:\n\t\tcase UBI_FM_DATA_VOLUME_ID:\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n \nstatic inline struct ubi_wl_entry *ubi_find_fm_block(const struct ubi_device *ubi,\n\t\t\t\t\t\t     int pnum)\n{\n\tint i;\n\n\tif (ubi->fm) {\n\t\tfor (i = 0; i < ubi->fm->used_blocks; i++) {\n\t\t\tif (ubi->fm->e[i]->pnum == pnum)\n\t\t\t\treturn ubi->fm->e[i];\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}