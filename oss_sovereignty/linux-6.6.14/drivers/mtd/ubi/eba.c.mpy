{
  "module_name": "eba.c",
  "hash_id": "63674d15c9e53c354d00b430af4f9598ddfb8929089917709d4352a0353011b8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/ubi/eba.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/slab.h>\n#include <linux/crc32.h>\n#include <linux/err.h>\n#include \"ubi.h\"\n\n \n#define EBA_RESERVED_PEBS 1\n\n \nstruct ubi_eba_entry {\n\tint pnum;\n};\n\n \nstruct ubi_eba_table {\n\tstruct ubi_eba_entry *entries;\n};\n\n \nunsigned long long ubi_next_sqnum(struct ubi_device *ubi)\n{\n\tunsigned long long sqnum;\n\n\tspin_lock(&ubi->ltree_lock);\n\tsqnum = ubi->global_sqnum++;\n\tspin_unlock(&ubi->ltree_lock);\n\n\treturn sqnum;\n}\n\n \nstatic int ubi_get_compat(const struct ubi_device *ubi, int vol_id)\n{\n\tif (vol_id == UBI_LAYOUT_VOLUME_ID)\n\t\treturn UBI_LAYOUT_VOLUME_COMPAT;\n\treturn 0;\n}\n\n \nvoid ubi_eba_get_ldesc(struct ubi_volume *vol, int lnum,\n\t\t       struct ubi_eba_leb_desc *ldesc)\n{\n\tldesc->lnum = lnum;\n\tldesc->pnum = vol->eba_tbl->entries[lnum].pnum;\n}\n\n \nstruct ubi_eba_table *ubi_eba_create_table(struct ubi_volume *vol,\n\t\t\t\t\t   int nentries)\n{\n\tstruct ubi_eba_table *tbl;\n\tint err = -ENOMEM;\n\tint i;\n\n\ttbl = kzalloc(sizeof(*tbl), GFP_KERNEL);\n\tif (!tbl)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\ttbl->entries = kmalloc_array(nentries, sizeof(*tbl->entries),\n\t\t\t\t     GFP_KERNEL);\n\tif (!tbl->entries)\n\t\tgoto err;\n\n\tfor (i = 0; i < nentries; i++)\n\t\ttbl->entries[i].pnum = UBI_LEB_UNMAPPED;\n\n\treturn tbl;\n\nerr:\n\tkfree(tbl);\n\n\treturn ERR_PTR(err);\n}\n\n \nvoid ubi_eba_destroy_table(struct ubi_eba_table *tbl)\n{\n\tif (!tbl)\n\t\treturn;\n\n\tkfree(tbl->entries);\n\tkfree(tbl);\n}\n\n \nvoid ubi_eba_copy_table(struct ubi_volume *vol, struct ubi_eba_table *dst,\n\t\t\tint nentries)\n{\n\tstruct ubi_eba_table *src;\n\tint i;\n\n\tubi_assert(dst && vol && vol->eba_tbl);\n\n\tsrc = vol->eba_tbl;\n\n\tfor (i = 0; i < nentries; i++)\n\t\tdst->entries[i].pnum = src->entries[i].pnum;\n}\n\n \nvoid ubi_eba_replace_table(struct ubi_volume *vol, struct ubi_eba_table *tbl)\n{\n\tubi_eba_destroy_table(vol->eba_tbl);\n\tvol->eba_tbl = tbl;\n}\n\n \nstatic struct ubi_ltree_entry *ltree_lookup(struct ubi_device *ubi, int vol_id,\n\t\t\t\t\t    int lnum)\n{\n\tstruct rb_node *p;\n\n\tp = ubi->ltree.rb_node;\n\twhile (p) {\n\t\tstruct ubi_ltree_entry *le;\n\n\t\tle = rb_entry(p, struct ubi_ltree_entry, rb);\n\n\t\tif (vol_id < le->vol_id)\n\t\t\tp = p->rb_left;\n\t\telse if (vol_id > le->vol_id)\n\t\t\tp = p->rb_right;\n\t\telse {\n\t\t\tif (lnum < le->lnum)\n\t\t\t\tp = p->rb_left;\n\t\t\telse if (lnum > le->lnum)\n\t\t\t\tp = p->rb_right;\n\t\t\telse\n\t\t\t\treturn le;\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\n \nstatic struct ubi_ltree_entry *ltree_add_entry(struct ubi_device *ubi,\n\t\t\t\t\t       int vol_id, int lnum)\n{\n\tstruct ubi_ltree_entry *le, *le1, *le_free;\n\n\tle = kmalloc(sizeof(struct ubi_ltree_entry), GFP_NOFS);\n\tif (!le)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tle->users = 0;\n\tinit_rwsem(&le->mutex);\n\tle->vol_id = vol_id;\n\tle->lnum = lnum;\n\n\tspin_lock(&ubi->ltree_lock);\n\tle1 = ltree_lookup(ubi, vol_id, lnum);\n\n\tif (le1) {\n\t\t \n\t\tle_free = le;\n\t\tle = le1;\n\t} else {\n\t\tstruct rb_node **p, *parent = NULL;\n\n\t\t \n\t\tle_free = NULL;\n\n\t\tp = &ubi->ltree.rb_node;\n\t\twhile (*p) {\n\t\t\tparent = *p;\n\t\t\tle1 = rb_entry(parent, struct ubi_ltree_entry, rb);\n\n\t\t\tif (vol_id < le1->vol_id)\n\t\t\t\tp = &(*p)->rb_left;\n\t\t\telse if (vol_id > le1->vol_id)\n\t\t\t\tp = &(*p)->rb_right;\n\t\t\telse {\n\t\t\t\tubi_assert(lnum != le1->lnum);\n\t\t\t\tif (lnum < le1->lnum)\n\t\t\t\t\tp = &(*p)->rb_left;\n\t\t\t\telse\n\t\t\t\t\tp = &(*p)->rb_right;\n\t\t\t}\n\t\t}\n\n\t\trb_link_node(&le->rb, parent, p);\n\t\trb_insert_color(&le->rb, &ubi->ltree);\n\t}\n\tle->users += 1;\n\tspin_unlock(&ubi->ltree_lock);\n\n\tkfree(le_free);\n\treturn le;\n}\n\n \nstatic int leb_read_lock(struct ubi_device *ubi, int vol_id, int lnum)\n{\n\tstruct ubi_ltree_entry *le;\n\n\tle = ltree_add_entry(ubi, vol_id, lnum);\n\tif (IS_ERR(le))\n\t\treturn PTR_ERR(le);\n\tdown_read(&le->mutex);\n\treturn 0;\n}\n\n \nstatic void leb_read_unlock(struct ubi_device *ubi, int vol_id, int lnum)\n{\n\tstruct ubi_ltree_entry *le;\n\n\tspin_lock(&ubi->ltree_lock);\n\tle = ltree_lookup(ubi, vol_id, lnum);\n\tle->users -= 1;\n\tubi_assert(le->users >= 0);\n\tup_read(&le->mutex);\n\tif (le->users == 0) {\n\t\trb_erase(&le->rb, &ubi->ltree);\n\t\tkfree(le);\n\t}\n\tspin_unlock(&ubi->ltree_lock);\n}\n\n \nstatic int leb_write_lock(struct ubi_device *ubi, int vol_id, int lnum)\n{\n\tstruct ubi_ltree_entry *le;\n\n\tle = ltree_add_entry(ubi, vol_id, lnum);\n\tif (IS_ERR(le))\n\t\treturn PTR_ERR(le);\n\tdown_write(&le->mutex);\n\treturn 0;\n}\n\n \nstatic int leb_write_trylock(struct ubi_device *ubi, int vol_id, int lnum)\n{\n\tstruct ubi_ltree_entry *le;\n\n\tle = ltree_add_entry(ubi, vol_id, lnum);\n\tif (IS_ERR(le))\n\t\treturn PTR_ERR(le);\n\tif (down_write_trylock(&le->mutex))\n\t\treturn 0;\n\n\t \n\tspin_lock(&ubi->ltree_lock);\n\tle->users -= 1;\n\tubi_assert(le->users >= 0);\n\tif (le->users == 0) {\n\t\trb_erase(&le->rb, &ubi->ltree);\n\t\tkfree(le);\n\t}\n\tspin_unlock(&ubi->ltree_lock);\n\n\treturn 1;\n}\n\n \nstatic void leb_write_unlock(struct ubi_device *ubi, int vol_id, int lnum)\n{\n\tstruct ubi_ltree_entry *le;\n\n\tspin_lock(&ubi->ltree_lock);\n\tle = ltree_lookup(ubi, vol_id, lnum);\n\tle->users -= 1;\n\tubi_assert(le->users >= 0);\n\tup_write(&le->mutex);\n\tif (le->users == 0) {\n\t\trb_erase(&le->rb, &ubi->ltree);\n\t\tkfree(le);\n\t}\n\tspin_unlock(&ubi->ltree_lock);\n}\n\n \nbool ubi_eba_is_mapped(struct ubi_volume *vol, int lnum)\n{\n\treturn vol->eba_tbl->entries[lnum].pnum >= 0;\n}\n\n \nint ubi_eba_unmap_leb(struct ubi_device *ubi, struct ubi_volume *vol,\n\t\t      int lnum)\n{\n\tint err, pnum, vol_id = vol->vol_id;\n\n\tif (ubi->ro_mode)\n\t\treturn -EROFS;\n\n\terr = leb_write_lock(ubi, vol_id, lnum);\n\tif (err)\n\t\treturn err;\n\n\tpnum = vol->eba_tbl->entries[lnum].pnum;\n\tif (pnum < 0)\n\t\t \n\t\tgoto out_unlock;\n\n\tdbg_eba(\"erase LEB %d:%d, PEB %d\", vol_id, lnum, pnum);\n\n\tdown_read(&ubi->fm_eba_sem);\n\tvol->eba_tbl->entries[lnum].pnum = UBI_LEB_UNMAPPED;\n\tup_read(&ubi->fm_eba_sem);\n\terr = ubi_wl_put_peb(ubi, vol_id, lnum, pnum, 0);\n\nout_unlock:\n\tleb_write_unlock(ubi, vol_id, lnum);\n\treturn err;\n}\n\n#ifdef CONFIG_MTD_UBI_FASTMAP\n \nstatic int check_mapping(struct ubi_device *ubi, struct ubi_volume *vol, int lnum,\n\t\t\t int *pnum)\n{\n\tint err;\n\tstruct ubi_vid_io_buf *vidb;\n\tstruct ubi_vid_hdr *vid_hdr;\n\n\tif (!ubi->fast_attach)\n\t\treturn 0;\n\n\tif (!vol->checkmap || test_bit(lnum, vol->checkmap))\n\t\treturn 0;\n\n\tvidb = ubi_alloc_vid_buf(ubi, GFP_NOFS);\n\tif (!vidb)\n\t\treturn -ENOMEM;\n\n\terr = ubi_io_read_vid_hdr(ubi, *pnum, vidb, 0);\n\tif (err > 0 && err != UBI_IO_BITFLIPS) {\n\t\tint torture = 0;\n\n\t\tswitch (err) {\n\t\t\tcase UBI_IO_FF:\n\t\t\tcase UBI_IO_FF_BITFLIPS:\n\t\t\tcase UBI_IO_BAD_HDR:\n\t\t\tcase UBI_IO_BAD_HDR_EBADMSG:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tubi_assert(0);\n\t\t}\n\n\t\tif (err == UBI_IO_BAD_HDR_EBADMSG || err == UBI_IO_FF_BITFLIPS)\n\t\t\ttorture = 1;\n\n\t\tdown_read(&ubi->fm_eba_sem);\n\t\tvol->eba_tbl->entries[lnum].pnum = UBI_LEB_UNMAPPED;\n\t\tup_read(&ubi->fm_eba_sem);\n\t\tubi_wl_put_peb(ubi, vol->vol_id, lnum, *pnum, torture);\n\n\t\t*pnum = UBI_LEB_UNMAPPED;\n\t} else if (err < 0) {\n\t\tubi_err(ubi, \"unable to read VID header back from PEB %i: %i\",\n\t\t\t*pnum, err);\n\n\t\tgoto out_free;\n\t} else {\n\t\tint found_vol_id, found_lnum;\n\n\t\tubi_assert(err == 0 || err == UBI_IO_BITFLIPS);\n\n\t\tvid_hdr = ubi_get_vid_hdr(vidb);\n\t\tfound_vol_id = be32_to_cpu(vid_hdr->vol_id);\n\t\tfound_lnum = be32_to_cpu(vid_hdr->lnum);\n\n\t\tif (found_lnum != lnum || found_vol_id != vol->vol_id) {\n\t\t\tubi_err(ubi, \"EBA mismatch! PEB %i is LEB %i:%i instead of LEB %i:%i\",\n\t\t\t\t*pnum, found_vol_id, found_lnum, vol->vol_id, lnum);\n\t\t\tubi_ro_mode(ubi);\n\t\t\terr = -EINVAL;\n\t\t\tgoto out_free;\n\t\t}\n\t}\n\n\tset_bit(lnum, vol->checkmap);\n\terr = 0;\n\nout_free:\n\tubi_free_vid_buf(vidb);\n\n\treturn err;\n}\n#else\nstatic int check_mapping(struct ubi_device *ubi, struct ubi_volume *vol, int lnum,\n\t\t  int *pnum)\n{\n\treturn 0;\n}\n#endif\n\n \nint ubi_eba_read_leb(struct ubi_device *ubi, struct ubi_volume *vol, int lnum,\n\t\t     void *buf, int offset, int len, int check)\n{\n\tint err, pnum, scrub = 0, vol_id = vol->vol_id;\n\tstruct ubi_vid_io_buf *vidb;\n\tstruct ubi_vid_hdr *vid_hdr;\n\tuint32_t crc;\n\n\terr = leb_read_lock(ubi, vol_id, lnum);\n\tif (err)\n\t\treturn err;\n\n\tpnum = vol->eba_tbl->entries[lnum].pnum;\n\tif (pnum >= 0) {\n\t\terr = check_mapping(ubi, vol, lnum, &pnum);\n\t\tif (err < 0)\n\t\t\tgoto out_unlock;\n\t}\n\n\tif (pnum == UBI_LEB_UNMAPPED) {\n\t\t \n\t\tdbg_eba(\"read %d bytes from offset %d of LEB %d:%d (unmapped)\",\n\t\t\tlen, offset, vol_id, lnum);\n\t\tleb_read_unlock(ubi, vol_id, lnum);\n\t\tubi_assert(vol->vol_type != UBI_STATIC_VOLUME);\n\t\tmemset(buf, 0xFF, len);\n\t\treturn 0;\n\t}\n\n\tdbg_eba(\"read %d bytes from offset %d of LEB %d:%d, PEB %d\",\n\t\tlen, offset, vol_id, lnum, pnum);\n\n\tif (vol->vol_type == UBI_DYNAMIC_VOLUME)\n\t\tcheck = 0;\n\nretry:\n\tif (check) {\n\t\tvidb = ubi_alloc_vid_buf(ubi, GFP_NOFS);\n\t\tif (!vidb) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tvid_hdr = ubi_get_vid_hdr(vidb);\n\n\t\terr = ubi_io_read_vid_hdr(ubi, pnum, vidb, 1);\n\t\tif (err && err != UBI_IO_BITFLIPS) {\n\t\t\tif (err > 0) {\n\t\t\t\t \n\t\t\t\tif (err == UBI_IO_BAD_HDR_EBADMSG ||\n\t\t\t\t    err == UBI_IO_BAD_HDR) {\n\t\t\t\t\tubi_warn(ubi, \"corrupted VID header at PEB %d, LEB %d:%d\",\n\t\t\t\t\t\t pnum, vol_id, lnum);\n\t\t\t\t\terr = -EBADMSG;\n\t\t\t\t} else {\n\t\t\t\t\t \n\t\t\t\t\tif (ubi->fast_attach) {\n\t\t\t\t\t\terr = -EBADMSG;\n\t\t\t\t\t} else {\n\t\t\t\t\t\terr = -EINVAL;\n\t\t\t\t\t\tubi_ro_mode(ubi);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tgoto out_free;\n\t\t} else if (err == UBI_IO_BITFLIPS)\n\t\t\tscrub = 1;\n\n\t\tubi_assert(lnum < be32_to_cpu(vid_hdr->used_ebs));\n\t\tubi_assert(len == be32_to_cpu(vid_hdr->data_size));\n\n\t\tcrc = be32_to_cpu(vid_hdr->data_crc);\n\t\tubi_free_vid_buf(vidb);\n\t}\n\n\terr = ubi_io_read_data(ubi, buf, pnum, offset, len);\n\tif (err) {\n\t\tif (err == UBI_IO_BITFLIPS)\n\t\t\tscrub = 1;\n\t\telse if (mtd_is_eccerr(err)) {\n\t\t\tif (vol->vol_type == UBI_DYNAMIC_VOLUME)\n\t\t\t\tgoto out_unlock;\n\t\t\tscrub = 1;\n\t\t\tif (!check) {\n\t\t\t\tubi_msg(ubi, \"force data checking\");\n\t\t\t\tcheck = 1;\n\t\t\t\tgoto retry;\n\t\t\t}\n\t\t} else\n\t\t\tgoto out_unlock;\n\t}\n\n\tif (check) {\n\t\tuint32_t crc1 = crc32(UBI_CRC32_INIT, buf, len);\n\t\tif (crc1 != crc) {\n\t\t\tubi_warn(ubi, \"CRC error: calculated %#08x, must be %#08x\",\n\t\t\t\t crc1, crc);\n\t\t\terr = -EBADMSG;\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\tif (scrub)\n\t\terr = ubi_wl_scrub_peb(ubi, pnum);\n\n\tleb_read_unlock(ubi, vol_id, lnum);\n\treturn err;\n\nout_free:\n\tubi_free_vid_buf(vidb);\nout_unlock:\n\tleb_read_unlock(ubi, vol_id, lnum);\n\treturn err;\n}\n\n \nint ubi_eba_read_leb_sg(struct ubi_device *ubi, struct ubi_volume *vol,\n\t\t\tstruct ubi_sgl *sgl, int lnum, int offset, int len,\n\t\t\tint check)\n{\n\tint to_read;\n\tint ret;\n\tstruct scatterlist *sg;\n\n\tfor (;;) {\n\t\tubi_assert(sgl->list_pos < UBI_MAX_SG_COUNT);\n\t\tsg = &sgl->sg[sgl->list_pos];\n\t\tif (len < sg->length - sgl->page_pos)\n\t\t\tto_read = len;\n\t\telse\n\t\t\tto_read = sg->length - sgl->page_pos;\n\n\t\tret = ubi_eba_read_leb(ubi, vol, lnum,\n\t\t\t\t       sg_virt(sg) + sgl->page_pos, offset,\n\t\t\t\t       to_read, check);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\toffset += to_read;\n\t\tlen -= to_read;\n\t\tif (!len) {\n\t\t\tsgl->page_pos += to_read;\n\t\t\tif (sgl->page_pos == sg->length) {\n\t\t\t\tsgl->list_pos++;\n\t\t\t\tsgl->page_pos = 0;\n\t\t\t}\n\n\t\t\tbreak;\n\t\t}\n\n\t\tsgl->list_pos++;\n\t\tsgl->page_pos = 0;\n\t}\n\n\treturn ret;\n}\n\n \nstatic int try_recover_peb(struct ubi_volume *vol, int pnum, int lnum,\n\t\t\t   const void *buf, int offset, int len,\n\t\t\t   struct ubi_vid_io_buf *vidb, bool *retry)\n{\n\tstruct ubi_device *ubi = vol->ubi;\n\tstruct ubi_vid_hdr *vid_hdr;\n\tint new_pnum, err, vol_id = vol->vol_id, data_size;\n\tuint32_t crc;\n\n\t*retry = false;\n\n\tnew_pnum = ubi_wl_get_peb(ubi);\n\tif (new_pnum < 0) {\n\t\terr = new_pnum;\n\t\tgoto out_put;\n\t}\n\n\tubi_msg(ubi, \"recover PEB %d, move data to PEB %d\",\n\t\tpnum, new_pnum);\n\n\terr = ubi_io_read_vid_hdr(ubi, pnum, vidb, 1);\n\tif (err && err != UBI_IO_BITFLIPS) {\n\t\tif (err > 0)\n\t\t\terr = -EIO;\n\t\tgoto out_put;\n\t}\n\n\tvid_hdr = ubi_get_vid_hdr(vidb);\n\tubi_assert(vid_hdr->vol_type == UBI_VID_DYNAMIC);\n\n\tmutex_lock(&ubi->buf_mutex);\n\tmemset(ubi->peb_buf + offset, 0xFF, len);\n\n\t \n\tif (offset > 0) {\n\t\terr = ubi_io_read_data(ubi, ubi->peb_buf, pnum, 0, offset);\n\t\tif (err && err != UBI_IO_BITFLIPS)\n\t\t\tgoto out_unlock;\n\t}\n\n\t*retry = true;\n\n\tmemcpy(ubi->peb_buf + offset, buf, len);\n\n\tdata_size = offset + len;\n\tcrc = crc32(UBI_CRC32_INIT, ubi->peb_buf, data_size);\n\tvid_hdr->sqnum = cpu_to_be64(ubi_next_sqnum(ubi));\n\tvid_hdr->copy_flag = 1;\n\tvid_hdr->data_size = cpu_to_be32(data_size);\n\tvid_hdr->data_crc = cpu_to_be32(crc);\n\terr = ubi_io_write_vid_hdr(ubi, new_pnum, vidb);\n\tif (err)\n\t\tgoto out_unlock;\n\n\terr = ubi_io_write_data(ubi, ubi->peb_buf, new_pnum, 0, data_size);\n\nout_unlock:\n\tmutex_unlock(&ubi->buf_mutex);\n\n\tif (!err)\n\t\tvol->eba_tbl->entries[lnum].pnum = new_pnum;\n\nout_put:\n\tup_read(&ubi->fm_eba_sem);\n\n\tif (!err) {\n\t\tubi_wl_put_peb(ubi, vol_id, lnum, pnum, 1);\n\t\tubi_msg(ubi, \"data was successfully recovered\");\n\t} else if (new_pnum >= 0) {\n\t\t \n\t\tubi_wl_put_peb(ubi, vol_id, lnum, new_pnum, 1);\n\t\tubi_warn(ubi, \"failed to write to PEB %d\", new_pnum);\n\t}\n\n\treturn err;\n}\n\n \nstatic int recover_peb(struct ubi_device *ubi, int pnum, int vol_id, int lnum,\n\t\t       const void *buf, int offset, int len)\n{\n\tint err, idx = vol_id2idx(ubi, vol_id), tries;\n\tstruct ubi_volume *vol = ubi->volumes[idx];\n\tstruct ubi_vid_io_buf *vidb;\n\n\tvidb = ubi_alloc_vid_buf(ubi, GFP_NOFS);\n\tif (!vidb)\n\t\treturn -ENOMEM;\n\n\tfor (tries = 0; tries <= UBI_IO_RETRIES; tries++) {\n\t\tbool retry;\n\n\t\terr = try_recover_peb(vol, pnum, lnum, buf, offset, len, vidb,\n\t\t\t\t      &retry);\n\t\tif (!err || !retry)\n\t\t\tbreak;\n\n\t\tubi_msg(ubi, \"try again\");\n\t}\n\n\tubi_free_vid_buf(vidb);\n\n\treturn err;\n}\n\n \nstatic int try_write_vid_and_data(struct ubi_volume *vol, int lnum,\n\t\t\t\t  struct ubi_vid_io_buf *vidb, const void *buf,\n\t\t\t\t  int offset, int len)\n{\n\tstruct ubi_device *ubi = vol->ubi;\n\tint pnum, opnum, err, err2, vol_id = vol->vol_id;\n\n\tpnum = ubi_wl_get_peb(ubi);\n\tif (pnum < 0) {\n\t\terr = pnum;\n\t\tgoto out_put;\n\t}\n\n\topnum = vol->eba_tbl->entries[lnum].pnum;\n\n\tdbg_eba(\"write VID hdr and %d bytes at offset %d of LEB %d:%d, PEB %d\",\n\t\tlen, offset, vol_id, lnum, pnum);\n\n\terr = ubi_io_write_vid_hdr(ubi, pnum, vidb);\n\tif (err) {\n\t\tubi_warn(ubi, \"failed to write VID header to LEB %d:%d, PEB %d\",\n\t\t\t vol_id, lnum, pnum);\n\t\tgoto out_put;\n\t}\n\n\tif (len) {\n\t\terr = ubi_io_write_data(ubi, buf, pnum, offset, len);\n\t\tif (err) {\n\t\t\tubi_warn(ubi,\n\t\t\t\t \"failed to write %d bytes at offset %d of LEB %d:%d, PEB %d\",\n\t\t\t\t len, offset, vol_id, lnum, pnum);\n\t\t\tgoto out_put;\n\t\t}\n\t}\n\n\tvol->eba_tbl->entries[lnum].pnum = pnum;\n\nout_put:\n\tup_read(&ubi->fm_eba_sem);\n\n\tif (err && pnum >= 0) {\n\t\terr2 = ubi_wl_put_peb(ubi, vol_id, lnum, pnum, 1);\n\t\tif (err2) {\n\t\t\tubi_warn(ubi, \"failed to return physical eraseblock %d, error %d\",\n\t\t\t\t pnum, err2);\n\t\t}\n\t} else if (!err && opnum >= 0) {\n\t\terr2 = ubi_wl_put_peb(ubi, vol_id, lnum, opnum, 0);\n\t\tif (err2) {\n\t\t\tubi_warn(ubi, \"failed to return physical eraseblock %d, error %d\",\n\t\t\t\t opnum, err2);\n\t\t}\n\t}\n\n\treturn err;\n}\n\n \nint ubi_eba_write_leb(struct ubi_device *ubi, struct ubi_volume *vol, int lnum,\n\t\t      const void *buf, int offset, int len)\n{\n\tint err, pnum, tries, vol_id = vol->vol_id;\n\tstruct ubi_vid_io_buf *vidb;\n\tstruct ubi_vid_hdr *vid_hdr;\n\n\tif (ubi->ro_mode)\n\t\treturn -EROFS;\n\n\terr = leb_write_lock(ubi, vol_id, lnum);\n\tif (err)\n\t\treturn err;\n\n\tpnum = vol->eba_tbl->entries[lnum].pnum;\n\tif (pnum >= 0) {\n\t\terr = check_mapping(ubi, vol, lnum, &pnum);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\t}\n\n\tif (pnum >= 0) {\n\t\tdbg_eba(\"write %d bytes at offset %d of LEB %d:%d, PEB %d\",\n\t\t\tlen, offset, vol_id, lnum, pnum);\n\n\t\terr = ubi_io_write_data(ubi, buf, pnum, offset, len);\n\t\tif (err) {\n\t\t\tubi_warn(ubi, \"failed to write data to PEB %d\", pnum);\n\t\t\tif (err == -EIO && ubi->bad_allowed)\n\t\t\t\terr = recover_peb(ubi, pnum, vol_id, lnum, buf,\n\t\t\t\t\t\t  offset, len);\n\t\t}\n\n\t\tgoto out;\n\t}\n\n\t \n\tvidb = ubi_alloc_vid_buf(ubi, GFP_NOFS);\n\tif (!vidb) {\n\t\tleb_write_unlock(ubi, vol_id, lnum);\n\t\treturn -ENOMEM;\n\t}\n\n\tvid_hdr = ubi_get_vid_hdr(vidb);\n\n\tvid_hdr->vol_type = UBI_VID_DYNAMIC;\n\tvid_hdr->sqnum = cpu_to_be64(ubi_next_sqnum(ubi));\n\tvid_hdr->vol_id = cpu_to_be32(vol_id);\n\tvid_hdr->lnum = cpu_to_be32(lnum);\n\tvid_hdr->compat = ubi_get_compat(ubi, vol_id);\n\tvid_hdr->data_pad = cpu_to_be32(vol->data_pad);\n\n\tfor (tries = 0; tries <= UBI_IO_RETRIES; tries++) {\n\t\terr = try_write_vid_and_data(vol, lnum, vidb, buf, offset, len);\n\t\tif (err != -EIO || !ubi->bad_allowed)\n\t\t\tbreak;\n\n\t\t \n\t\tvid_hdr->sqnum = cpu_to_be64(ubi_next_sqnum(ubi));\n\t\tubi_msg(ubi, \"try another PEB\");\n\t}\n\n\tubi_free_vid_buf(vidb);\n\nout:\n\tif (err)\n\t\tubi_ro_mode(ubi);\n\n\tleb_write_unlock(ubi, vol_id, lnum);\n\n\treturn err;\n}\n\n \nint ubi_eba_write_leb_st(struct ubi_device *ubi, struct ubi_volume *vol,\n\t\t\t int lnum, const void *buf, int len, int used_ebs)\n{\n\tint err, tries, data_size = len, vol_id = vol->vol_id;\n\tstruct ubi_vid_io_buf *vidb;\n\tstruct ubi_vid_hdr *vid_hdr;\n\tuint32_t crc;\n\n\tif (ubi->ro_mode)\n\t\treturn -EROFS;\n\n\tif (lnum == used_ebs - 1)\n\t\t \n\t\tlen = ALIGN(data_size, ubi->min_io_size);\n\telse\n\t\tubi_assert(!(len & (ubi->min_io_size - 1)));\n\n\tvidb = ubi_alloc_vid_buf(ubi, GFP_NOFS);\n\tif (!vidb)\n\t\treturn -ENOMEM;\n\n\tvid_hdr = ubi_get_vid_hdr(vidb);\n\n\terr = leb_write_lock(ubi, vol_id, lnum);\n\tif (err)\n\t\tgoto out;\n\n\tvid_hdr->sqnum = cpu_to_be64(ubi_next_sqnum(ubi));\n\tvid_hdr->vol_id = cpu_to_be32(vol_id);\n\tvid_hdr->lnum = cpu_to_be32(lnum);\n\tvid_hdr->compat = ubi_get_compat(ubi, vol_id);\n\tvid_hdr->data_pad = cpu_to_be32(vol->data_pad);\n\n\tcrc = crc32(UBI_CRC32_INIT, buf, data_size);\n\tvid_hdr->vol_type = UBI_VID_STATIC;\n\tvid_hdr->data_size = cpu_to_be32(data_size);\n\tvid_hdr->used_ebs = cpu_to_be32(used_ebs);\n\tvid_hdr->data_crc = cpu_to_be32(crc);\n\n\tubi_assert(vol->eba_tbl->entries[lnum].pnum < 0);\n\n\tfor (tries = 0; tries <= UBI_IO_RETRIES; tries++) {\n\t\terr = try_write_vid_and_data(vol, lnum, vidb, buf, 0, len);\n\t\tif (err != -EIO || !ubi->bad_allowed)\n\t\t\tbreak;\n\n\t\tvid_hdr->sqnum = cpu_to_be64(ubi_next_sqnum(ubi));\n\t\tubi_msg(ubi, \"try another PEB\");\n\t}\n\n\tif (err)\n\t\tubi_ro_mode(ubi);\n\n\tleb_write_unlock(ubi, vol_id, lnum);\n\nout:\n\tubi_free_vid_buf(vidb);\n\n\treturn err;\n}\n\n \nint ubi_eba_atomic_leb_change(struct ubi_device *ubi, struct ubi_volume *vol,\n\t\t\t      int lnum, const void *buf, int len)\n{\n\tint err, tries, vol_id = vol->vol_id;\n\tstruct ubi_vid_io_buf *vidb;\n\tstruct ubi_vid_hdr *vid_hdr;\n\tuint32_t crc;\n\n\tif (ubi->ro_mode)\n\t\treturn -EROFS;\n\n\tif (len == 0) {\n\t\t \n\t\terr = ubi_eba_unmap_leb(ubi, vol, lnum);\n\t\tif (err)\n\t\t\treturn err;\n\t\treturn ubi_eba_write_leb(ubi, vol, lnum, NULL, 0, 0);\n\t}\n\n\tvidb = ubi_alloc_vid_buf(ubi, GFP_NOFS);\n\tif (!vidb)\n\t\treturn -ENOMEM;\n\n\tvid_hdr = ubi_get_vid_hdr(vidb);\n\n\tmutex_lock(&ubi->alc_mutex);\n\terr = leb_write_lock(ubi, vol_id, lnum);\n\tif (err)\n\t\tgoto out_mutex;\n\n\tvid_hdr->sqnum = cpu_to_be64(ubi_next_sqnum(ubi));\n\tvid_hdr->vol_id = cpu_to_be32(vol_id);\n\tvid_hdr->lnum = cpu_to_be32(lnum);\n\tvid_hdr->compat = ubi_get_compat(ubi, vol_id);\n\tvid_hdr->data_pad = cpu_to_be32(vol->data_pad);\n\n\tcrc = crc32(UBI_CRC32_INIT, buf, len);\n\tvid_hdr->vol_type = UBI_VID_DYNAMIC;\n\tvid_hdr->data_size = cpu_to_be32(len);\n\tvid_hdr->copy_flag = 1;\n\tvid_hdr->data_crc = cpu_to_be32(crc);\n\n\tdbg_eba(\"change LEB %d:%d\", vol_id, lnum);\n\n\tfor (tries = 0; tries <= UBI_IO_RETRIES; tries++) {\n\t\terr = try_write_vid_and_data(vol, lnum, vidb, buf, 0, len);\n\t\tif (err != -EIO || !ubi->bad_allowed)\n\t\t\tbreak;\n\n\t\tvid_hdr->sqnum = cpu_to_be64(ubi_next_sqnum(ubi));\n\t\tubi_msg(ubi, \"try another PEB\");\n\t}\n\n\t \n\tif (err)\n\t\tubi_ro_mode(ubi);\n\n\tleb_write_unlock(ubi, vol_id, lnum);\n\nout_mutex:\n\tmutex_unlock(&ubi->alc_mutex);\n\tubi_free_vid_buf(vidb);\n\treturn err;\n}\n\n \nstatic int is_error_sane(int err)\n{\n\tif (err == -EIO || err == -ENOMEM || err == UBI_IO_BAD_HDR ||\n\t    err == UBI_IO_BAD_HDR_EBADMSG || err == -ETIMEDOUT)\n\t\treturn 0;\n\treturn 1;\n}\n\n \nint ubi_eba_copy_leb(struct ubi_device *ubi, int from, int to,\n\t\t     struct ubi_vid_io_buf *vidb)\n{\n\tint err, vol_id, lnum, data_size, aldata_size, idx;\n\tstruct ubi_vid_hdr *vid_hdr = ubi_get_vid_hdr(vidb);\n\tstruct ubi_volume *vol;\n\tuint32_t crc;\n\n\tubi_assert(rwsem_is_locked(&ubi->fm_eba_sem));\n\n\tvol_id = be32_to_cpu(vid_hdr->vol_id);\n\tlnum = be32_to_cpu(vid_hdr->lnum);\n\n\tdbg_wl(\"copy LEB %d:%d, PEB %d to PEB %d\", vol_id, lnum, from, to);\n\n\tif (vid_hdr->vol_type == UBI_VID_STATIC) {\n\t\tdata_size = be32_to_cpu(vid_hdr->data_size);\n\t\taldata_size = ALIGN(data_size, ubi->min_io_size);\n\t} else\n\t\tdata_size = aldata_size =\n\t\t\t    ubi->leb_size - be32_to_cpu(vid_hdr->data_pad);\n\n\tidx = vol_id2idx(ubi, vol_id);\n\tspin_lock(&ubi->volumes_lock);\n\t \n\tvol = ubi->volumes[idx];\n\tspin_unlock(&ubi->volumes_lock);\n\tif (!vol) {\n\t\t \n\t\tdbg_wl(\"volume %d is being removed, cancel\", vol_id);\n\t\treturn MOVE_CANCEL_RACE;\n\t}\n\n\t \n\terr = leb_write_trylock(ubi, vol_id, lnum);\n\tif (err) {\n\t\tdbg_wl(\"contention on LEB %d:%d, cancel\", vol_id, lnum);\n\t\treturn MOVE_RETRY;\n\t}\n\n\t \n\tif (vol->eba_tbl->entries[lnum].pnum != from) {\n\t\tdbg_wl(\"LEB %d:%d is no longer mapped to PEB %d, mapped to PEB %d, cancel\",\n\t\t       vol_id, lnum, from, vol->eba_tbl->entries[lnum].pnum);\n\t\terr = MOVE_CANCEL_RACE;\n\t\tgoto out_unlock_leb;\n\t}\n\n\t \n\tmutex_lock(&ubi->buf_mutex);\n\tdbg_wl(\"read %d bytes of data\", aldata_size);\n\terr = ubi_io_read_data(ubi, ubi->peb_buf, from, 0, aldata_size);\n\tif (err && err != UBI_IO_BITFLIPS) {\n\t\tubi_warn(ubi, \"error %d while reading data from PEB %d\",\n\t\t\t err, from);\n\t\terr = MOVE_SOURCE_RD_ERR;\n\t\tgoto out_unlock_buf;\n\t}\n\n\t \n\tif (vid_hdr->vol_type == UBI_VID_DYNAMIC)\n\t\taldata_size = data_size =\n\t\t\tubi_calc_data_len(ubi, ubi->peb_buf, data_size);\n\n\tcond_resched();\n\tcrc = crc32(UBI_CRC32_INIT, ubi->peb_buf, data_size);\n\tcond_resched();\n\n\t \n\tif (data_size > 0) {\n\t\tvid_hdr->copy_flag = 1;\n\t\tvid_hdr->data_size = cpu_to_be32(data_size);\n\t\tvid_hdr->data_crc = cpu_to_be32(crc);\n\t}\n\tvid_hdr->sqnum = cpu_to_be64(ubi_next_sqnum(ubi));\n\n\terr = ubi_io_write_vid_hdr(ubi, to, vidb);\n\tif (err) {\n\t\tif (err == -EIO)\n\t\t\terr = MOVE_TARGET_WR_ERR;\n\t\tgoto out_unlock_buf;\n\t}\n\n\tcond_resched();\n\n\t \n\terr = ubi_io_read_vid_hdr(ubi, to, vidb, 1);\n\tif (err) {\n\t\tif (err != UBI_IO_BITFLIPS) {\n\t\t\tubi_warn(ubi, \"error %d while reading VID header back from PEB %d\",\n\t\t\t\t err, to);\n\t\t\tif (is_error_sane(err))\n\t\t\t\terr = MOVE_TARGET_RD_ERR;\n\t\t} else\n\t\t\terr = MOVE_TARGET_BITFLIPS;\n\t\tgoto out_unlock_buf;\n\t}\n\n\tif (data_size > 0) {\n\t\terr = ubi_io_write_data(ubi, ubi->peb_buf, to, 0, aldata_size);\n\t\tif (err) {\n\t\t\tif (err == -EIO)\n\t\t\t\terr = MOVE_TARGET_WR_ERR;\n\t\t\tgoto out_unlock_buf;\n\t\t}\n\n\t\tcond_resched();\n\t}\n\n\tubi_assert(vol->eba_tbl->entries[lnum].pnum == from);\n\tvol->eba_tbl->entries[lnum].pnum = to;\n\nout_unlock_buf:\n\tmutex_unlock(&ubi->buf_mutex);\nout_unlock_leb:\n\tleb_write_unlock(ubi, vol_id, lnum);\n\treturn err;\n}\n\n \nstatic void print_rsvd_warning(struct ubi_device *ubi,\n\t\t\t       struct ubi_attach_info *ai)\n{\n\t \n\tif (ai->max_sqnum > (1 << 18)) {\n\t\tint min = ubi->beb_rsvd_level / 10;\n\n\t\tif (!min)\n\t\t\tmin = 1;\n\t\tif (ubi->beb_rsvd_pebs > min)\n\t\t\treturn;\n\t}\n\n\tubi_warn(ubi, \"cannot reserve enough PEBs for bad PEB handling, reserved %d, need %d\",\n\t\t ubi->beb_rsvd_pebs, ubi->beb_rsvd_level);\n\tif (ubi->corr_peb_count)\n\t\tubi_warn(ubi, \"%d PEBs are corrupted and not used\",\n\t\t\t ubi->corr_peb_count);\n}\n\n \nint self_check_eba(struct ubi_device *ubi, struct ubi_attach_info *ai_fastmap,\n\t\t   struct ubi_attach_info *ai_scan)\n{\n\tint i, j, num_volumes, ret = 0;\n\tint **scan_eba, **fm_eba;\n\tstruct ubi_ainf_volume *av;\n\tstruct ubi_volume *vol;\n\tstruct ubi_ainf_peb *aeb;\n\tstruct rb_node *rb;\n\n\tnum_volumes = ubi->vtbl_slots + UBI_INT_VOL_COUNT;\n\n\tscan_eba = kmalloc_array(num_volumes, sizeof(*scan_eba), GFP_KERNEL);\n\tif (!scan_eba)\n\t\treturn -ENOMEM;\n\n\tfm_eba = kmalloc_array(num_volumes, sizeof(*fm_eba), GFP_KERNEL);\n\tif (!fm_eba) {\n\t\tkfree(scan_eba);\n\t\treturn -ENOMEM;\n\t}\n\n\tfor (i = 0; i < num_volumes; i++) {\n\t\tvol = ubi->volumes[i];\n\t\tif (!vol)\n\t\t\tcontinue;\n\n\t\tscan_eba[i] = kmalloc_array(vol->reserved_pebs,\n\t\t\t\t\t    sizeof(**scan_eba),\n\t\t\t\t\t    GFP_KERNEL);\n\t\tif (!scan_eba[i]) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out_free;\n\t\t}\n\n\t\tfm_eba[i] = kmalloc_array(vol->reserved_pebs,\n\t\t\t\t\t  sizeof(**fm_eba),\n\t\t\t\t\t  GFP_KERNEL);\n\t\tif (!fm_eba[i]) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out_free;\n\t\t}\n\n\t\tfor (j = 0; j < vol->reserved_pebs; j++)\n\t\t\tscan_eba[i][j] = fm_eba[i][j] = UBI_LEB_UNMAPPED;\n\n\t\tav = ubi_find_av(ai_scan, idx2vol_id(ubi, i));\n\t\tif (!av)\n\t\t\tcontinue;\n\n\t\tubi_rb_for_each_entry(rb, aeb, &av->root, u.rb)\n\t\t\tscan_eba[i][aeb->lnum] = aeb->pnum;\n\n\t\tav = ubi_find_av(ai_fastmap, idx2vol_id(ubi, i));\n\t\tif (!av)\n\t\t\tcontinue;\n\n\t\tubi_rb_for_each_entry(rb, aeb, &av->root, u.rb)\n\t\t\tfm_eba[i][aeb->lnum] = aeb->pnum;\n\n\t\tfor (j = 0; j < vol->reserved_pebs; j++) {\n\t\t\tif (scan_eba[i][j] != fm_eba[i][j]) {\n\t\t\t\tif (scan_eba[i][j] == UBI_LEB_UNMAPPED ||\n\t\t\t\t\tfm_eba[i][j] == UBI_LEB_UNMAPPED)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tubi_err(ubi, \"LEB:%i:%i is PEB:%i instead of %i!\",\n\t\t\t\t\tvol->vol_id, j, fm_eba[i][j],\n\t\t\t\t\tscan_eba[i][j]);\n\t\t\t\tubi_assert(0);\n\t\t\t}\n\t\t}\n\t}\n\nout_free:\n\tfor (i = 0; i < num_volumes; i++) {\n\t\tif (!ubi->volumes[i])\n\t\t\tcontinue;\n\n\t\tkfree(scan_eba[i]);\n\t\tkfree(fm_eba[i]);\n\t}\n\n\tkfree(scan_eba);\n\tkfree(fm_eba);\n\treturn ret;\n}\n\n \nint ubi_eba_init(struct ubi_device *ubi, struct ubi_attach_info *ai)\n{\n\tint i, err, num_volumes;\n\tstruct ubi_ainf_volume *av;\n\tstruct ubi_volume *vol;\n\tstruct ubi_ainf_peb *aeb;\n\tstruct rb_node *rb;\n\n\tdbg_eba(\"initialize EBA sub-system\");\n\n\tspin_lock_init(&ubi->ltree_lock);\n\tmutex_init(&ubi->alc_mutex);\n\tubi->ltree = RB_ROOT;\n\n\tubi->global_sqnum = ai->max_sqnum + 1;\n\tnum_volumes = ubi->vtbl_slots + UBI_INT_VOL_COUNT;\n\n\tfor (i = 0; i < num_volumes; i++) {\n\t\tstruct ubi_eba_table *tbl;\n\n\t\tvol = ubi->volumes[i];\n\t\tif (!vol)\n\t\t\tcontinue;\n\n\t\tcond_resched();\n\n\t\ttbl = ubi_eba_create_table(vol, vol->reserved_pebs);\n\t\tif (IS_ERR(tbl)) {\n\t\t\terr = PTR_ERR(tbl);\n\t\t\tgoto out_free;\n\t\t}\n\n\t\tubi_eba_replace_table(vol, tbl);\n\n\t\tav = ubi_find_av(ai, idx2vol_id(ubi, i));\n\t\tif (!av)\n\t\t\tcontinue;\n\n\t\tubi_rb_for_each_entry(rb, aeb, &av->root, u.rb) {\n\t\t\tif (aeb->lnum >= vol->reserved_pebs) {\n\t\t\t\t \n\t\t\t\tubi_move_aeb_to_list(av, aeb, &ai->erase);\n\t\t\t} else {\n\t\t\t\tstruct ubi_eba_entry *entry;\n\n\t\t\t\tentry = &vol->eba_tbl->entries[aeb->lnum];\n\t\t\t\tentry->pnum = aeb->pnum;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (ubi->avail_pebs < EBA_RESERVED_PEBS) {\n\t\tubi_err(ubi, \"no enough physical eraseblocks (%d, need %d)\",\n\t\t\tubi->avail_pebs, EBA_RESERVED_PEBS);\n\t\tif (ubi->corr_peb_count)\n\t\t\tubi_err(ubi, \"%d PEBs are corrupted and not used\",\n\t\t\t\tubi->corr_peb_count);\n\t\terr = -ENOSPC;\n\t\tgoto out_free;\n\t}\n\tubi->avail_pebs -= EBA_RESERVED_PEBS;\n\tubi->rsvd_pebs += EBA_RESERVED_PEBS;\n\n\tif (ubi->bad_allowed) {\n\t\tubi_calculate_reserved(ubi);\n\n\t\tif (ubi->avail_pebs < ubi->beb_rsvd_level) {\n\t\t\t \n\t\t\tubi->beb_rsvd_pebs = ubi->avail_pebs;\n\t\t\tprint_rsvd_warning(ubi, ai);\n\t\t} else\n\t\t\tubi->beb_rsvd_pebs = ubi->beb_rsvd_level;\n\n\t\tubi->avail_pebs -= ubi->beb_rsvd_pebs;\n\t\tubi->rsvd_pebs  += ubi->beb_rsvd_pebs;\n\t}\n\n\tdbg_eba(\"EBA sub-system is initialized\");\n\treturn 0;\n\nout_free:\n\tfor (i = 0; i < num_volumes; i++) {\n\t\tif (!ubi->volumes[i])\n\t\t\tcontinue;\n\t\tubi_eba_replace_table(ubi->volumes[i], NULL);\n\t}\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}