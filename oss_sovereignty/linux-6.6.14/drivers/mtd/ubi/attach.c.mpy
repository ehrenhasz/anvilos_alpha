{
  "module_name": "attach.c",
  "hash_id": "f939011e75f38be4c640aeef69fdff17146966d3ef231abdecbc2b45be85c8e5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/ubi/attach.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/crc32.h>\n#include <linux/math64.h>\n#include <linux/random.h>\n#include \"ubi.h\"\n\nstatic int self_check_ai(struct ubi_device *ubi, struct ubi_attach_info *ai);\n\n#define AV_FIND\t\tBIT(0)\n#define AV_ADD\t\tBIT(1)\n#define AV_FIND_OR_ADD\t(AV_FIND | AV_ADD)\n\n \nstatic struct ubi_ainf_volume *find_or_add_av(struct ubi_attach_info *ai,\n\t\t\t\t\t      int vol_id, unsigned int flags,\n\t\t\t\t\t      bool *created)\n{\n\tstruct ubi_ainf_volume *av;\n\tstruct rb_node **p = &ai->volumes.rb_node, *parent = NULL;\n\n\t \n\twhile (*p) {\n\t\tparent = *p;\n\t\tav = rb_entry(parent, struct ubi_ainf_volume, rb);\n\n\t\tif (vol_id == av->vol_id) {\n\t\t\t*created = false;\n\n\t\t\tif (!(flags & AV_FIND))\n\t\t\t\treturn ERR_PTR(-EEXIST);\n\n\t\t\treturn av;\n\t\t}\n\n\t\tif (vol_id > av->vol_id)\n\t\t\tp = &(*p)->rb_left;\n\t\telse\n\t\t\tp = &(*p)->rb_right;\n\t}\n\n\tif (!(flags & AV_ADD))\n\t\treturn NULL;\n\n\t \n\tav = kzalloc(sizeof(*av), GFP_KERNEL);\n\tif (!av)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tav->vol_id = vol_id;\n\n\tif (vol_id > ai->highest_vol_id)\n\t\tai->highest_vol_id = vol_id;\n\n\trb_link_node(&av->rb, parent, p);\n\trb_insert_color(&av->rb, &ai->volumes);\n\tai->vols_found += 1;\n\t*created = true;\n\tdbg_bld(\"added volume %d\", vol_id);\n\treturn av;\n}\n\n \nstatic struct ubi_ainf_volume *ubi_find_or_add_av(struct ubi_attach_info *ai,\n\t\t\t\t\t\t  int vol_id, bool *created)\n{\n\treturn find_or_add_av(ai, vol_id, AV_FIND_OR_ADD, created);\n}\n\n \nstruct ubi_ainf_peb *ubi_alloc_aeb(struct ubi_attach_info *ai, int pnum,\n\t\t\t\t   int ec)\n{\n\tstruct ubi_ainf_peb *aeb;\n\n\taeb = kmem_cache_zalloc(ai->aeb_slab_cache, GFP_KERNEL);\n\tif (!aeb)\n\t\treturn NULL;\n\n\taeb->pnum = pnum;\n\taeb->ec = ec;\n\taeb->vol_id = UBI_UNKNOWN;\n\taeb->lnum = UBI_UNKNOWN;\n\n\treturn aeb;\n}\n\n \nvoid ubi_free_aeb(struct ubi_attach_info *ai, struct ubi_ainf_peb *aeb)\n{\n\tkmem_cache_free(ai->aeb_slab_cache, aeb);\n}\n\n \nstatic int add_to_list(struct ubi_attach_info *ai, int pnum, int vol_id,\n\t\t       int lnum, int ec, int to_head, struct list_head *list)\n{\n\tstruct ubi_ainf_peb *aeb;\n\n\tif (list == &ai->free) {\n\t\tdbg_bld(\"add to free: PEB %d, EC %d\", pnum, ec);\n\t} else if (list == &ai->erase) {\n\t\tdbg_bld(\"add to erase: PEB %d, EC %d\", pnum, ec);\n\t} else if (list == &ai->alien) {\n\t\tdbg_bld(\"add to alien: PEB %d, EC %d\", pnum, ec);\n\t\tai->alien_peb_count += 1;\n\t} else\n\t\tBUG();\n\n\taeb = ubi_alloc_aeb(ai, pnum, ec);\n\tif (!aeb)\n\t\treturn -ENOMEM;\n\n\taeb->vol_id = vol_id;\n\taeb->lnum = lnum;\n\tif (to_head)\n\t\tlist_add(&aeb->u.list, list);\n\telse\n\t\tlist_add_tail(&aeb->u.list, list);\n\treturn 0;\n}\n\n \nstatic int add_corrupted(struct ubi_attach_info *ai, int pnum, int ec)\n{\n\tstruct ubi_ainf_peb *aeb;\n\n\tdbg_bld(\"add to corrupted: PEB %d, EC %d\", pnum, ec);\n\n\taeb = ubi_alloc_aeb(ai, pnum, ec);\n\tif (!aeb)\n\t\treturn -ENOMEM;\n\n\tai->corr_peb_count += 1;\n\tlist_add(&aeb->u.list, &ai->corr);\n\treturn 0;\n}\n\n \nstatic int add_fastmap(struct ubi_attach_info *ai, int pnum,\n\t\t       struct ubi_vid_hdr *vid_hdr, int ec)\n{\n\tstruct ubi_ainf_peb *aeb;\n\n\taeb = ubi_alloc_aeb(ai, pnum, ec);\n\tif (!aeb)\n\t\treturn -ENOMEM;\n\n\taeb->vol_id = be32_to_cpu(vid_hdr->vol_id);\n\taeb->sqnum = be64_to_cpu(vid_hdr->sqnum);\n\tlist_add(&aeb->u.list, &ai->fastmap);\n\n\tdbg_bld(\"add to fastmap list: PEB %d, vol_id %d, sqnum: %llu\", pnum,\n\t\taeb->vol_id, aeb->sqnum);\n\n\treturn 0;\n}\n\n \nstatic int validate_vid_hdr(const struct ubi_device *ubi,\n\t\t\t    const struct ubi_vid_hdr *vid_hdr,\n\t\t\t    const struct ubi_ainf_volume *av, int pnum)\n{\n\tint vol_type = vid_hdr->vol_type;\n\tint vol_id = be32_to_cpu(vid_hdr->vol_id);\n\tint used_ebs = be32_to_cpu(vid_hdr->used_ebs);\n\tint data_pad = be32_to_cpu(vid_hdr->data_pad);\n\n\tif (av->leb_count != 0) {\n\t\tint av_vol_type;\n\n\t\t \n\n\t\tif (vol_id != av->vol_id) {\n\t\t\tubi_err(ubi, \"inconsistent vol_id\");\n\t\t\tgoto bad;\n\t\t}\n\n\t\tif (av->vol_type == UBI_STATIC_VOLUME)\n\t\t\tav_vol_type = UBI_VID_STATIC;\n\t\telse\n\t\t\tav_vol_type = UBI_VID_DYNAMIC;\n\n\t\tif (vol_type != av_vol_type) {\n\t\t\tubi_err(ubi, \"inconsistent vol_type\");\n\t\t\tgoto bad;\n\t\t}\n\n\t\tif (used_ebs != av->used_ebs) {\n\t\t\tubi_err(ubi, \"inconsistent used_ebs\");\n\t\t\tgoto bad;\n\t\t}\n\n\t\tif (data_pad != av->data_pad) {\n\t\t\tubi_err(ubi, \"inconsistent data_pad\");\n\t\t\tgoto bad;\n\t\t}\n\t}\n\n\treturn 0;\n\nbad:\n\tubi_err(ubi, \"inconsistent VID header at PEB %d\", pnum);\n\tubi_dump_vid_hdr(vid_hdr);\n\tubi_dump_av(av);\n\treturn -EINVAL;\n}\n\n \nstatic struct ubi_ainf_volume *add_volume(struct ubi_attach_info *ai,\n\t\t\t\t\t  int vol_id, int pnum,\n\t\t\t\t\t  const struct ubi_vid_hdr *vid_hdr)\n{\n\tstruct ubi_ainf_volume *av;\n\tbool created;\n\n\tubi_assert(vol_id == be32_to_cpu(vid_hdr->vol_id));\n\n\tav = ubi_find_or_add_av(ai, vol_id, &created);\n\tif (IS_ERR(av) || !created)\n\t\treturn av;\n\n\tav->used_ebs = be32_to_cpu(vid_hdr->used_ebs);\n\tav->data_pad = be32_to_cpu(vid_hdr->data_pad);\n\tav->compat = vid_hdr->compat;\n\tav->vol_type = vid_hdr->vol_type == UBI_VID_DYNAMIC ? UBI_DYNAMIC_VOLUME\n\t\t\t\t\t\t\t    : UBI_STATIC_VOLUME;\n\n\treturn av;\n}\n\n \nint ubi_compare_lebs(struct ubi_device *ubi, const struct ubi_ainf_peb *aeb,\n\t\t\tint pnum, const struct ubi_vid_hdr *vid_hdr)\n{\n\tint len, err, second_is_newer, bitflips = 0, corrupted = 0;\n\tuint32_t data_crc, crc;\n\tstruct ubi_vid_io_buf *vidb = NULL;\n\tunsigned long long sqnum2 = be64_to_cpu(vid_hdr->sqnum);\n\n\tif (sqnum2 == aeb->sqnum) {\n\t\t \n\t\tubi_err(ubi, \"unsupported on-flash UBI format\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tsecond_is_newer = (sqnum2 > aeb->sqnum);\n\n\t \n\n\tif (second_is_newer) {\n\t\tif (!vid_hdr->copy_flag) {\n\t\t\t \n\t\t\tdbg_bld(\"second PEB %d is newer, copy_flag is unset\",\n\t\t\t\tpnum);\n\t\t\treturn 1;\n\t\t}\n\t} else {\n\t\tif (!aeb->copy_flag) {\n\t\t\t \n\t\t\tdbg_bld(\"first PEB %d is newer, copy_flag is unset\",\n\t\t\t\tpnum);\n\t\t\treturn bitflips << 1;\n\t\t}\n\n\t\tvidb = ubi_alloc_vid_buf(ubi, GFP_KERNEL);\n\t\tif (!vidb)\n\t\t\treturn -ENOMEM;\n\n\t\tpnum = aeb->pnum;\n\t\terr = ubi_io_read_vid_hdr(ubi, pnum, vidb, 0);\n\t\tif (err) {\n\t\t\tif (err == UBI_IO_BITFLIPS)\n\t\t\t\tbitflips = 1;\n\t\t\telse {\n\t\t\t\tubi_err(ubi, \"VID of PEB %d header is bad, but it was OK earlier, err %d\",\n\t\t\t\t\tpnum, err);\n\t\t\t\tif (err > 0)\n\t\t\t\t\terr = -EIO;\n\n\t\t\t\tgoto out_free_vidh;\n\t\t\t}\n\t\t}\n\n\t\tvid_hdr = ubi_get_vid_hdr(vidb);\n\t}\n\n\t \n\n\tlen = be32_to_cpu(vid_hdr->data_size);\n\n\tmutex_lock(&ubi->buf_mutex);\n\terr = ubi_io_read_data(ubi, ubi->peb_buf, pnum, 0, len);\n\tif (err && err != UBI_IO_BITFLIPS && !mtd_is_eccerr(err))\n\t\tgoto out_unlock;\n\n\tdata_crc = be32_to_cpu(vid_hdr->data_crc);\n\tcrc = crc32(UBI_CRC32_INIT, ubi->peb_buf, len);\n\tif (crc != data_crc) {\n\t\tdbg_bld(\"PEB %d CRC error: calculated %#08x, must be %#08x\",\n\t\t\tpnum, crc, data_crc);\n\t\tcorrupted = 1;\n\t\tbitflips = 0;\n\t\tsecond_is_newer = !second_is_newer;\n\t} else {\n\t\tdbg_bld(\"PEB %d CRC is OK\", pnum);\n\t\tbitflips |= !!err;\n\t}\n\tmutex_unlock(&ubi->buf_mutex);\n\n\tubi_free_vid_buf(vidb);\n\n\tif (second_is_newer)\n\t\tdbg_bld(\"second PEB %d is newer, copy_flag is set\", pnum);\n\telse\n\t\tdbg_bld(\"first PEB %d is newer, copy_flag is set\", pnum);\n\n\treturn second_is_newer | (bitflips << 1) | (corrupted << 2);\n\nout_unlock:\n\tmutex_unlock(&ubi->buf_mutex);\nout_free_vidh:\n\tubi_free_vid_buf(vidb);\n\treturn err;\n}\n\n \nint ubi_add_to_av(struct ubi_device *ubi, struct ubi_attach_info *ai, int pnum,\n\t\t  int ec, const struct ubi_vid_hdr *vid_hdr, int bitflips)\n{\n\tint err, vol_id, lnum;\n\tunsigned long long sqnum;\n\tstruct ubi_ainf_volume *av;\n\tstruct ubi_ainf_peb *aeb;\n\tstruct rb_node **p, *parent = NULL;\n\n\tvol_id = be32_to_cpu(vid_hdr->vol_id);\n\tlnum = be32_to_cpu(vid_hdr->lnum);\n\tsqnum = be64_to_cpu(vid_hdr->sqnum);\n\n\tdbg_bld(\"PEB %d, LEB %d:%d, EC %d, sqnum %llu, bitflips %d\",\n\t\tpnum, vol_id, lnum, ec, sqnum, bitflips);\n\n\tav = add_volume(ai, vol_id, pnum, vid_hdr);\n\tif (IS_ERR(av))\n\t\treturn PTR_ERR(av);\n\n\tif (ai->max_sqnum < sqnum)\n\t\tai->max_sqnum = sqnum;\n\n\t \n\tp = &av->root.rb_node;\n\twhile (*p) {\n\t\tint cmp_res;\n\n\t\tparent = *p;\n\t\taeb = rb_entry(parent, struct ubi_ainf_peb, u.rb);\n\t\tif (lnum != aeb->lnum) {\n\t\t\tif (lnum < aeb->lnum)\n\t\t\t\tp = &(*p)->rb_left;\n\t\t\telse\n\t\t\t\tp = &(*p)->rb_right;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\n\t\tdbg_bld(\"this LEB already exists: PEB %d, sqnum %llu, EC %d\",\n\t\t\taeb->pnum, aeb->sqnum, aeb->ec);\n\n\t\t \n\t\tif (aeb->sqnum == sqnum && sqnum != 0) {\n\t\t\tubi_err(ubi, \"two LEBs with same sequence number %llu\",\n\t\t\t\tsqnum);\n\t\t\tubi_dump_aeb(aeb, 0);\n\t\t\tubi_dump_vid_hdr(vid_hdr);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\tcmp_res = ubi_compare_lebs(ubi, aeb, pnum, vid_hdr);\n\t\tif (cmp_res < 0)\n\t\t\treturn cmp_res;\n\n\t\tif (cmp_res & 1) {\n\t\t\t \n\t\t\terr = validate_vid_hdr(ubi, vid_hdr, av, pnum);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t\terr = add_to_list(ai, aeb->pnum, aeb->vol_id,\n\t\t\t\t\t  aeb->lnum, aeb->ec, cmp_res & 4,\n\t\t\t\t\t  &ai->erase);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t\taeb->ec = ec;\n\t\t\taeb->pnum = pnum;\n\t\t\taeb->vol_id = vol_id;\n\t\t\taeb->lnum = lnum;\n\t\t\taeb->scrub = ((cmp_res & 2) || bitflips);\n\t\t\taeb->copy_flag = vid_hdr->copy_flag;\n\t\t\taeb->sqnum = sqnum;\n\n\t\t\tif (av->highest_lnum == lnum)\n\t\t\t\tav->last_data_size =\n\t\t\t\t\tbe32_to_cpu(vid_hdr->data_size);\n\n\t\t\treturn 0;\n\t\t} else {\n\t\t\t \n\t\t\treturn add_to_list(ai, pnum, vol_id, lnum, ec,\n\t\t\t\t\t   cmp_res & 4, &ai->erase);\n\t\t}\n\t}\n\n\t \n\n\terr = validate_vid_hdr(ubi, vid_hdr, av, pnum);\n\tif (err)\n\t\treturn err;\n\n\taeb = ubi_alloc_aeb(ai, pnum, ec);\n\tif (!aeb)\n\t\treturn -ENOMEM;\n\n\taeb->vol_id = vol_id;\n\taeb->lnum = lnum;\n\taeb->scrub = bitflips;\n\taeb->copy_flag = vid_hdr->copy_flag;\n\taeb->sqnum = sqnum;\n\n\tif (av->highest_lnum <= lnum) {\n\t\tav->highest_lnum = lnum;\n\t\tav->last_data_size = be32_to_cpu(vid_hdr->data_size);\n\t}\n\n\tav->leb_count += 1;\n\trb_link_node(&aeb->u.rb, parent, p);\n\trb_insert_color(&aeb->u.rb, &av->root);\n\treturn 0;\n}\n\n \nstruct ubi_ainf_volume *ubi_add_av(struct ubi_attach_info *ai, int vol_id)\n{\n\tbool created;\n\n\treturn find_or_add_av(ai, vol_id, AV_ADD, &created);\n}\n\n \nstruct ubi_ainf_volume *ubi_find_av(const struct ubi_attach_info *ai,\n\t\t\t\t    int vol_id)\n{\n\tbool created;\n\n\treturn find_or_add_av((struct ubi_attach_info *)ai, vol_id, AV_FIND,\n\t\t\t      &created);\n}\n\nstatic void destroy_av(struct ubi_attach_info *ai, struct ubi_ainf_volume *av,\n\t\t       struct list_head *list);\n\n \nvoid ubi_remove_av(struct ubi_attach_info *ai, struct ubi_ainf_volume *av)\n{\n\tdbg_bld(\"remove attaching information about volume %d\", av->vol_id);\n\n\trb_erase(&av->rb, &ai->volumes);\n\tdestroy_av(ai, av, &ai->erase);\n\tai->vols_found -= 1;\n}\n\n \nstatic int early_erase_peb(struct ubi_device *ubi,\n\t\t\t   const struct ubi_attach_info *ai, int pnum, int ec)\n{\n\tint err;\n\tstruct ubi_ec_hdr *ec_hdr;\n\n\tif ((long long)ec >= UBI_MAX_ERASECOUNTER) {\n\t\t \n\t\tubi_err(ubi, \"erase counter overflow at PEB %d, EC %d\",\n\t\t\tpnum, ec);\n\t\treturn -EINVAL;\n\t}\n\n\tec_hdr = kzalloc(ubi->ec_hdr_alsize, GFP_KERNEL);\n\tif (!ec_hdr)\n\t\treturn -ENOMEM;\n\n\tec_hdr->ec = cpu_to_be64(ec);\n\n\terr = ubi_io_sync_erase(ubi, pnum, 0);\n\tif (err < 0)\n\t\tgoto out_free;\n\n\terr = ubi_io_write_ec_hdr(ubi, pnum, ec_hdr);\n\nout_free:\n\tkfree(ec_hdr);\n\treturn err;\n}\n\n \nstruct ubi_ainf_peb *ubi_early_get_peb(struct ubi_device *ubi,\n\t\t\t\t       struct ubi_attach_info *ai)\n{\n\tint err = 0;\n\tstruct ubi_ainf_peb *aeb, *tmp_aeb;\n\n\tif (!list_empty(&ai->free)) {\n\t\taeb = list_entry(ai->free.next, struct ubi_ainf_peb, u.list);\n\t\tlist_del(&aeb->u.list);\n\t\tdbg_bld(\"return free PEB %d, EC %d\", aeb->pnum, aeb->ec);\n\t\treturn aeb;\n\t}\n\n\t \n\tlist_for_each_entry_safe(aeb, tmp_aeb, &ai->erase, u.list) {\n\t\tif (aeb->ec == UBI_UNKNOWN)\n\t\t\taeb->ec = ai->mean_ec;\n\n\t\terr = early_erase_peb(ubi, ai, aeb->pnum, aeb->ec+1);\n\t\tif (err)\n\t\t\tcontinue;\n\n\t\taeb->ec += 1;\n\t\tlist_del(&aeb->u.list);\n\t\tdbg_bld(\"return PEB %d, EC %d\", aeb->pnum, aeb->ec);\n\t\treturn aeb;\n\t}\n\n\tubi_err(ubi, \"no free eraseblocks\");\n\treturn ERR_PTR(-ENOSPC);\n}\n\n \nstatic int check_corruption(struct ubi_device *ubi, struct ubi_vid_hdr *vid_hdr,\n\t\t\t    int pnum)\n{\n\tint err;\n\n\tmutex_lock(&ubi->buf_mutex);\n\tmemset(ubi->peb_buf, 0x00, ubi->leb_size);\n\n\terr = ubi_io_read(ubi, ubi->peb_buf, pnum, ubi->leb_start,\n\t\t\t  ubi->leb_size);\n\tif (err == UBI_IO_BITFLIPS || mtd_is_eccerr(err)) {\n\t\t \n\t\terr = 0;\n\t\tgoto out_unlock;\n\t}\n\n\tif (err)\n\t\tgoto out_unlock;\n\n\tif (ubi_check_pattern(ubi->peb_buf, 0xFF, ubi->leb_size))\n\t\tgoto out_unlock;\n\n\tubi_err(ubi, \"PEB %d contains corrupted VID header, and the data does not contain all 0xFF\",\n\t\tpnum);\n\tubi_err(ubi, \"this may be a non-UBI PEB or a severe VID header corruption which requires manual inspection\");\n\tubi_dump_vid_hdr(vid_hdr);\n\tpr_err(\"hexdump of PEB %d offset %d, length %d\",\n\t       pnum, ubi->leb_start, ubi->leb_size);\n\tubi_dbg_print_hex_dump(KERN_DEBUG, \"\", DUMP_PREFIX_OFFSET, 32, 1,\n\t\t\t       ubi->peb_buf, ubi->leb_size, 1);\n\terr = 1;\n\nout_unlock:\n\tmutex_unlock(&ubi->buf_mutex);\n\treturn err;\n}\n\nstatic bool vol_ignored(int vol_id)\n{\n\tswitch (vol_id) {\n\t\tcase UBI_LAYOUT_VOLUME_ID:\n\t\treturn true;\n\t}\n\n#ifdef CONFIG_MTD_UBI_FASTMAP\n\treturn ubi_is_fm_vol(vol_id);\n#else\n\treturn false;\n#endif\n}\n\n \nstatic int scan_peb(struct ubi_device *ubi, struct ubi_attach_info *ai,\n\t\t    int pnum, bool fast)\n{\n\tstruct ubi_ec_hdr *ech = ai->ech;\n\tstruct ubi_vid_io_buf *vidb = ai->vidb;\n\tstruct ubi_vid_hdr *vidh = ubi_get_vid_hdr(vidb);\n\tlong long ec;\n\tint err, bitflips = 0, vol_id = -1, ec_err = 0;\n\n\tdbg_bld(\"scan PEB %d\", pnum);\n\n\t \n\terr = ubi_io_is_bad(ubi, pnum);\n\tif (err < 0)\n\t\treturn err;\n\telse if (err) {\n\t\tai->bad_peb_count += 1;\n\t\treturn 0;\n\t}\n\n\terr = ubi_io_read_ec_hdr(ubi, pnum, ech, 0);\n\tif (err < 0)\n\t\treturn err;\n\tswitch (err) {\n\tcase 0:\n\t\tbreak;\n\tcase UBI_IO_BITFLIPS:\n\t\tbitflips = 1;\n\t\tbreak;\n\tcase UBI_IO_FF:\n\t\tai->empty_peb_count += 1;\n\t\treturn add_to_list(ai, pnum, UBI_UNKNOWN, UBI_UNKNOWN,\n\t\t\t\t   UBI_UNKNOWN, 0, &ai->erase);\n\tcase UBI_IO_FF_BITFLIPS:\n\t\tai->empty_peb_count += 1;\n\t\treturn add_to_list(ai, pnum, UBI_UNKNOWN, UBI_UNKNOWN,\n\t\t\t\t   UBI_UNKNOWN, 1, &ai->erase);\n\tcase UBI_IO_BAD_HDR_EBADMSG:\n\tcase UBI_IO_BAD_HDR:\n\t\t \n\t\tec_err = err;\n\t\tec = UBI_UNKNOWN;\n\t\tbitflips = 1;\n\t\tbreak;\n\tdefault:\n\t\tubi_err(ubi, \"'ubi_io_read_ec_hdr()' returned unknown code %d\",\n\t\t\terr);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!ec_err) {\n\t\tint image_seq;\n\n\t\t \n\t\tif (ech->version != UBI_VERSION) {\n\t\t\tubi_err(ubi, \"this UBI version is %d, image version is %d\",\n\t\t\t\tUBI_VERSION, (int)ech->version);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tec = be64_to_cpu(ech->ec);\n\t\tif (ec > UBI_MAX_ERASECOUNTER) {\n\t\t\t \n\t\t\tubi_err(ubi, \"erase counter overflow, max is %d\",\n\t\t\t\tUBI_MAX_ERASECOUNTER);\n\t\t\tubi_dump_ec_hdr(ech);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\timage_seq = be32_to_cpu(ech->image_seq);\n\t\tif (!ubi->image_seq)\n\t\t\tubi->image_seq = image_seq;\n\t\tif (image_seq && ubi->image_seq != image_seq) {\n\t\t\tubi_err(ubi, \"bad image sequence number %d in PEB %d, expected %d\",\n\t\t\t\timage_seq, pnum, ubi->image_seq);\n\t\t\tubi_dump_ec_hdr(ech);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t \n\n\terr = ubi_io_read_vid_hdr(ubi, pnum, vidb, 0);\n\tif (err < 0)\n\t\treturn err;\n\tswitch (err) {\n\tcase 0:\n\t\tbreak;\n\tcase UBI_IO_BITFLIPS:\n\t\tbitflips = 1;\n\t\tbreak;\n\tcase UBI_IO_BAD_HDR_EBADMSG:\n\t\tif (ec_err == UBI_IO_BAD_HDR_EBADMSG)\n\t\t\t \n\t\t\tai->maybe_bad_peb_count += 1;\n\t\tfallthrough;\n\tcase UBI_IO_BAD_HDR:\n\t\t\t \n\t\t\tif (fast)\n\t\t\t\tai->force_full_scan = 1;\n\n\t\tif (ec_err)\n\t\t\t \n\t\t\terr = 0;\n\t\telse\n\t\t\t \n\t\t\terr = check_corruption(ubi, vidh, pnum);\n\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\telse if (!err)\n\t\t\t \n\t\t\terr = add_to_list(ai, pnum, UBI_UNKNOWN,\n\t\t\t\t\t  UBI_UNKNOWN, ec, 1, &ai->erase);\n\t\telse\n\t\t\t \n\t\t\terr = add_corrupted(ai, pnum, ec);\n\t\tif (err)\n\t\t\treturn err;\n\t\tgoto adjust_mean_ec;\n\tcase UBI_IO_FF_BITFLIPS:\n\t\terr = add_to_list(ai, pnum, UBI_UNKNOWN, UBI_UNKNOWN,\n\t\t\t\t  ec, 1, &ai->erase);\n\t\tif (err)\n\t\t\treturn err;\n\t\tgoto adjust_mean_ec;\n\tcase UBI_IO_FF:\n\t\tif (ec_err || bitflips)\n\t\t\terr = add_to_list(ai, pnum, UBI_UNKNOWN,\n\t\t\t\t\t  UBI_UNKNOWN, ec, 1, &ai->erase);\n\t\telse\n\t\t\terr = add_to_list(ai, pnum, UBI_UNKNOWN,\n\t\t\t\t\t  UBI_UNKNOWN, ec, 0, &ai->free);\n\t\tif (err)\n\t\t\treturn err;\n\t\tgoto adjust_mean_ec;\n\tdefault:\n\t\tubi_err(ubi, \"'ubi_io_read_vid_hdr()' returned unknown code %d\",\n\t\t\terr);\n\t\treturn -EINVAL;\n\t}\n\n\tvol_id = be32_to_cpu(vidh->vol_id);\n\tif (vol_id > UBI_MAX_VOLUMES && !vol_ignored(vol_id)) {\n\t\tint lnum = be32_to_cpu(vidh->lnum);\n\n\t\t \n\t\tswitch (vidh->compat) {\n\t\tcase UBI_COMPAT_DELETE:\n\t\t\tubi_msg(ubi, \"\\\"delete\\\" compatible internal volume %d:%d found, will remove it\",\n\t\t\t\tvol_id, lnum);\n\n\t\t\terr = add_to_list(ai, pnum, vol_id, lnum,\n\t\t\t\t\t  ec, 1, &ai->erase);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\treturn 0;\n\n\t\tcase UBI_COMPAT_RO:\n\t\t\tubi_msg(ubi, \"read-only compatible internal volume %d:%d found, switch to read-only mode\",\n\t\t\t\tvol_id, lnum);\n\t\t\tubi->ro_mode = 1;\n\t\t\tbreak;\n\n\t\tcase UBI_COMPAT_PRESERVE:\n\t\t\tubi_msg(ubi, \"\\\"preserve\\\" compatible internal volume %d:%d found\",\n\t\t\t\tvol_id, lnum);\n\t\t\terr = add_to_list(ai, pnum, vol_id, lnum,\n\t\t\t\t\t  ec, 0, &ai->alien);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\treturn 0;\n\n\t\tcase UBI_COMPAT_REJECT:\n\t\t\tubi_err(ubi, \"incompatible internal volume %d:%d found\",\n\t\t\t\tvol_id, lnum);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (ec_err)\n\t\tubi_warn(ubi, \"valid VID header but corrupted EC header at PEB %d\",\n\t\t\t pnum);\n\n\tif (ubi_is_fm_vol(vol_id))\n\t\terr = add_fastmap(ai, pnum, vidh, ec);\n\telse\n\t\terr = ubi_add_to_av(ubi, ai, pnum, ec, vidh, bitflips);\n\n\tif (err)\n\t\treturn err;\n\nadjust_mean_ec:\n\tif (!ec_err) {\n\t\tai->ec_sum += ec;\n\t\tai->ec_count += 1;\n\t\tif (ec > ai->max_ec)\n\t\t\tai->max_ec = ec;\n\t\tif (ec < ai->min_ec)\n\t\t\tai->min_ec = ec;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int late_analysis(struct ubi_device *ubi, struct ubi_attach_info *ai)\n{\n\tstruct ubi_ainf_peb *aeb;\n\tint max_corr, peb_count;\n\n\tpeb_count = ubi->peb_count - ai->bad_peb_count - ai->alien_peb_count;\n\tmax_corr = peb_count / 20 ?: 8;\n\n\t \n\tif (ai->corr_peb_count) {\n\t\tubi_err(ubi, \"%d PEBs are corrupted and preserved\",\n\t\t\tai->corr_peb_count);\n\t\tpr_err(\"Corrupted PEBs are:\");\n\t\tlist_for_each_entry(aeb, &ai->corr, u.list)\n\t\t\tpr_cont(\" %d\", aeb->pnum);\n\t\tpr_cont(\"\\n\");\n\n\t\t \n\t\tif (ai->corr_peb_count >= max_corr) {\n\t\t\tubi_err(ubi, \"too many corrupted PEBs, refusing\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (ai->empty_peb_count + ai->maybe_bad_peb_count == peb_count) {\n\t\t \n\t\tif (ai->maybe_bad_peb_count <= 2) {\n\t\t\tai->is_empty = 1;\n\t\t\tubi_msg(ubi, \"empty MTD device detected\");\n\t\t\tget_random_bytes(&ubi->image_seq,\n\t\t\t\t\t sizeof(ubi->image_seq));\n\t\t} else {\n\t\t\tubi_err(ubi, \"MTD device is not UBI-formatted and possibly contains non-UBI data - refusing it\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t}\n\n\treturn 0;\n}\n\n \nstatic void destroy_av(struct ubi_attach_info *ai, struct ubi_ainf_volume *av,\n\t\t       struct list_head *list)\n{\n\tstruct ubi_ainf_peb *aeb;\n\tstruct rb_node *this = av->root.rb_node;\n\n\twhile (this) {\n\t\tif (this->rb_left)\n\t\t\tthis = this->rb_left;\n\t\telse if (this->rb_right)\n\t\t\tthis = this->rb_right;\n\t\telse {\n\t\t\taeb = rb_entry(this, struct ubi_ainf_peb, u.rb);\n\t\t\tthis = rb_parent(this);\n\t\t\tif (this) {\n\t\t\t\tif (this->rb_left == &aeb->u.rb)\n\t\t\t\t\tthis->rb_left = NULL;\n\t\t\t\telse\n\t\t\t\t\tthis->rb_right = NULL;\n\t\t\t}\n\n\t\t\tif (list)\n\t\t\t\tlist_add_tail(&aeb->u.list, list);\n\t\t\telse\n\t\t\t\tubi_free_aeb(ai, aeb);\n\t\t}\n\t}\n\tkfree(av);\n}\n\n \nstatic void destroy_ai(struct ubi_attach_info *ai)\n{\n\tstruct ubi_ainf_peb *aeb, *aeb_tmp;\n\tstruct ubi_ainf_volume *av;\n\tstruct rb_node *rb;\n\n\tlist_for_each_entry_safe(aeb, aeb_tmp, &ai->alien, u.list) {\n\t\tlist_del(&aeb->u.list);\n\t\tubi_free_aeb(ai, aeb);\n\t}\n\tlist_for_each_entry_safe(aeb, aeb_tmp, &ai->erase, u.list) {\n\t\tlist_del(&aeb->u.list);\n\t\tubi_free_aeb(ai, aeb);\n\t}\n\tlist_for_each_entry_safe(aeb, aeb_tmp, &ai->corr, u.list) {\n\t\tlist_del(&aeb->u.list);\n\t\tubi_free_aeb(ai, aeb);\n\t}\n\tlist_for_each_entry_safe(aeb, aeb_tmp, &ai->free, u.list) {\n\t\tlist_del(&aeb->u.list);\n\t\tubi_free_aeb(ai, aeb);\n\t}\n\tlist_for_each_entry_safe(aeb, aeb_tmp, &ai->fastmap, u.list) {\n\t\tlist_del(&aeb->u.list);\n\t\tubi_free_aeb(ai, aeb);\n\t}\n\n\t \n\trb = ai->volumes.rb_node;\n\twhile (rb) {\n\t\tif (rb->rb_left)\n\t\t\trb = rb->rb_left;\n\t\telse if (rb->rb_right)\n\t\t\trb = rb->rb_right;\n\t\telse {\n\t\t\tav = rb_entry(rb, struct ubi_ainf_volume, rb);\n\n\t\t\trb = rb_parent(rb);\n\t\t\tif (rb) {\n\t\t\t\tif (rb->rb_left == &av->rb)\n\t\t\t\t\trb->rb_left = NULL;\n\t\t\t\telse\n\t\t\t\t\trb->rb_right = NULL;\n\t\t\t}\n\n\t\t\tdestroy_av(ai, av, NULL);\n\t\t}\n\t}\n\n\tkmem_cache_destroy(ai->aeb_slab_cache);\n\tkfree(ai);\n}\n\n \nstatic int scan_all(struct ubi_device *ubi, struct ubi_attach_info *ai,\n\t\t    int start)\n{\n\tint err, pnum;\n\tstruct rb_node *rb1, *rb2;\n\tstruct ubi_ainf_volume *av;\n\tstruct ubi_ainf_peb *aeb;\n\n\terr = -ENOMEM;\n\n\tai->ech = kzalloc(ubi->ec_hdr_alsize, GFP_KERNEL);\n\tif (!ai->ech)\n\t\treturn err;\n\n\tai->vidb = ubi_alloc_vid_buf(ubi, GFP_KERNEL);\n\tif (!ai->vidb)\n\t\tgoto out_ech;\n\n\tfor (pnum = start; pnum < ubi->peb_count; pnum++) {\n\t\tcond_resched();\n\n\t\tdbg_gen(\"process PEB %d\", pnum);\n\t\terr = scan_peb(ubi, ai, pnum, false);\n\t\tif (err < 0)\n\t\t\tgoto out_vidh;\n\t}\n\n\tubi_msg(ubi, \"scanning is finished\");\n\n\t \n\tif (ai->ec_count)\n\t\tai->mean_ec = div_u64(ai->ec_sum, ai->ec_count);\n\n\terr = late_analysis(ubi, ai);\n\tif (err)\n\t\tgoto out_vidh;\n\n\t \n\tubi_rb_for_each_entry(rb1, av, &ai->volumes, rb) {\n\t\tubi_rb_for_each_entry(rb2, aeb, &av->root, u.rb)\n\t\t\tif (aeb->ec == UBI_UNKNOWN)\n\t\t\t\taeb->ec = ai->mean_ec;\n\t}\n\n\tlist_for_each_entry(aeb, &ai->free, u.list) {\n\t\tif (aeb->ec == UBI_UNKNOWN)\n\t\t\taeb->ec = ai->mean_ec;\n\t}\n\n\tlist_for_each_entry(aeb, &ai->corr, u.list)\n\t\tif (aeb->ec == UBI_UNKNOWN)\n\t\t\taeb->ec = ai->mean_ec;\n\n\tlist_for_each_entry(aeb, &ai->erase, u.list)\n\t\tif (aeb->ec == UBI_UNKNOWN)\n\t\t\taeb->ec = ai->mean_ec;\n\n\terr = self_check_ai(ubi, ai);\n\tif (err)\n\t\tgoto out_vidh;\n\n\tubi_free_vid_buf(ai->vidb);\n\tkfree(ai->ech);\n\n\treturn 0;\n\nout_vidh:\n\tubi_free_vid_buf(ai->vidb);\nout_ech:\n\tkfree(ai->ech);\n\treturn err;\n}\n\nstatic struct ubi_attach_info *alloc_ai(void)\n{\n\tstruct ubi_attach_info *ai;\n\n\tai = kzalloc(sizeof(struct ubi_attach_info), GFP_KERNEL);\n\tif (!ai)\n\t\treturn ai;\n\n\tINIT_LIST_HEAD(&ai->corr);\n\tINIT_LIST_HEAD(&ai->free);\n\tINIT_LIST_HEAD(&ai->erase);\n\tINIT_LIST_HEAD(&ai->alien);\n\tINIT_LIST_HEAD(&ai->fastmap);\n\tai->volumes = RB_ROOT;\n\tai->aeb_slab_cache = kmem_cache_create(\"ubi_aeb_slab_cache\",\n\t\t\t\t\t       sizeof(struct ubi_ainf_peb),\n\t\t\t\t\t       0, 0, NULL);\n\tif (!ai->aeb_slab_cache) {\n\t\tkfree(ai);\n\t\tai = NULL;\n\t}\n\n\treturn ai;\n}\n\n#ifdef CONFIG_MTD_UBI_FASTMAP\n\n \nstatic int scan_fast(struct ubi_device *ubi, struct ubi_attach_info **ai)\n{\n\tint err, pnum;\n\tstruct ubi_attach_info *scan_ai;\n\n\terr = -ENOMEM;\n\n\tscan_ai = alloc_ai();\n\tif (!scan_ai)\n\t\tgoto out;\n\n\tscan_ai->ech = kzalloc(ubi->ec_hdr_alsize, GFP_KERNEL);\n\tif (!scan_ai->ech)\n\t\tgoto out_ai;\n\n\tscan_ai->vidb = ubi_alloc_vid_buf(ubi, GFP_KERNEL);\n\tif (!scan_ai->vidb)\n\t\tgoto out_ech;\n\n\tfor (pnum = 0; pnum < UBI_FM_MAX_START; pnum++) {\n\t\tcond_resched();\n\n\t\tdbg_gen(\"process PEB %d\", pnum);\n\t\terr = scan_peb(ubi, scan_ai, pnum, true);\n\t\tif (err < 0)\n\t\t\tgoto out_vidh;\n\t}\n\n\tubi_free_vid_buf(scan_ai->vidb);\n\tkfree(scan_ai->ech);\n\n\tif (scan_ai->force_full_scan)\n\t\terr = UBI_NO_FASTMAP;\n\telse\n\t\terr = ubi_scan_fastmap(ubi, *ai, scan_ai);\n\n\tif (err) {\n\t\t \n\t\tdestroy_ai(*ai);\n\t\t*ai = scan_ai;\n\t} else\n\t\tdestroy_ai(scan_ai);\n\n\treturn err;\n\nout_vidh:\n\tubi_free_vid_buf(scan_ai->vidb);\nout_ech:\n\tkfree(scan_ai->ech);\nout_ai:\n\tdestroy_ai(scan_ai);\nout:\n\treturn err;\n}\n\n#endif\n\n \nint ubi_attach(struct ubi_device *ubi, int force_scan)\n{\n\tint err;\n\tstruct ubi_attach_info *ai;\n\n\tai = alloc_ai();\n\tif (!ai)\n\t\treturn -ENOMEM;\n\n#ifdef CONFIG_MTD_UBI_FASTMAP\n\t \n\tif ((int)mtd_div_by_eb(ubi->mtd->size, ubi->mtd) <= UBI_FM_MAX_START) {\n\t\tubi->fm_disabled = 1;\n\t\tforce_scan = 1;\n\t}\n\n\tif (force_scan)\n\t\terr = scan_all(ubi, ai, 0);\n\telse {\n\t\terr = scan_fast(ubi, &ai);\n\t\tif (err > 0 || mtd_is_eccerr(err)) {\n\t\t\tif (err != UBI_NO_FASTMAP) {\n\t\t\t\tdestroy_ai(ai);\n\t\t\t\tai = alloc_ai();\n\t\t\t\tif (!ai)\n\t\t\t\t\treturn -ENOMEM;\n\n\t\t\t\terr = scan_all(ubi, ai, 0);\n\t\t\t} else {\n\t\t\t\terr = scan_all(ubi, ai, UBI_FM_MAX_START);\n\t\t\t}\n\t\t}\n\t}\n#else\n\terr = scan_all(ubi, ai, 0);\n#endif\n\tif (err)\n\t\tgoto out_ai;\n\n\tubi->bad_peb_count = ai->bad_peb_count;\n\tubi->good_peb_count = ubi->peb_count - ubi->bad_peb_count;\n\tubi->corr_peb_count = ai->corr_peb_count;\n\tubi->max_ec = ai->max_ec;\n\tubi->mean_ec = ai->mean_ec;\n\tdbg_gen(\"max. sequence number:       %llu\", ai->max_sqnum);\n\n\terr = ubi_read_volume_table(ubi, ai);\n\tif (err)\n\t\tgoto out_ai;\n\n\terr = ubi_wl_init(ubi, ai);\n\tif (err)\n\t\tgoto out_vtbl;\n\n\terr = ubi_eba_init(ubi, ai);\n\tif (err)\n\t\tgoto out_wl;\n\n#ifdef CONFIG_MTD_UBI_FASTMAP\n\tif (ubi->fm && ubi_dbg_chk_fastmap(ubi)) {\n\t\tstruct ubi_attach_info *scan_ai;\n\n\t\tscan_ai = alloc_ai();\n\t\tif (!scan_ai) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out_wl;\n\t\t}\n\n\t\terr = scan_all(ubi, scan_ai, 0);\n\t\tif (err) {\n\t\t\tdestroy_ai(scan_ai);\n\t\t\tgoto out_wl;\n\t\t}\n\n\t\terr = self_check_eba(ubi, ai, scan_ai);\n\t\tdestroy_ai(scan_ai);\n\n\t\tif (err)\n\t\t\tgoto out_wl;\n\t}\n#endif\n\n\tdestroy_ai(ai);\n\treturn 0;\n\nout_wl:\n\tubi_wl_close(ubi);\nout_vtbl:\n\tubi_free_all_volumes(ubi);\n\tvfree(ubi->vtbl);\nout_ai:\n\tdestroy_ai(ai);\n\treturn err;\n}\n\n \nstatic int self_check_ai(struct ubi_device *ubi, struct ubi_attach_info *ai)\n{\n\tstruct ubi_vid_io_buf *vidb = ai->vidb;\n\tstruct ubi_vid_hdr *vidh = ubi_get_vid_hdr(vidb);\n\tint pnum, err, vols_found = 0;\n\tstruct rb_node *rb1, *rb2;\n\tstruct ubi_ainf_volume *av;\n\tstruct ubi_ainf_peb *aeb, *last_aeb;\n\tuint8_t *buf;\n\n\tif (!ubi_dbg_chk_gen(ubi))\n\t\treturn 0;\n\n\t \n\tubi_rb_for_each_entry(rb1, av, &ai->volumes, rb) {\n\t\tint leb_count = 0;\n\n\t\tcond_resched();\n\n\t\tvols_found += 1;\n\n\t\tif (ai->is_empty) {\n\t\t\tubi_err(ubi, \"bad is_empty flag\");\n\t\t\tgoto bad_av;\n\t\t}\n\n\t\tif (av->vol_id < 0 || av->highest_lnum < 0 ||\n\t\t    av->leb_count < 0 || av->vol_type < 0 || av->used_ebs < 0 ||\n\t\t    av->data_pad < 0 || av->last_data_size < 0) {\n\t\t\tubi_err(ubi, \"negative values\");\n\t\t\tgoto bad_av;\n\t\t}\n\n\t\tif (av->vol_id >= UBI_MAX_VOLUMES &&\n\t\t    av->vol_id < UBI_INTERNAL_VOL_START) {\n\t\t\tubi_err(ubi, \"bad vol_id\");\n\t\t\tgoto bad_av;\n\t\t}\n\n\t\tif (av->vol_id > ai->highest_vol_id) {\n\t\t\tubi_err(ubi, \"highest_vol_id is %d, but vol_id %d is there\",\n\t\t\t\tai->highest_vol_id, av->vol_id);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (av->vol_type != UBI_DYNAMIC_VOLUME &&\n\t\t    av->vol_type != UBI_STATIC_VOLUME) {\n\t\t\tubi_err(ubi, \"bad vol_type\");\n\t\t\tgoto bad_av;\n\t\t}\n\n\t\tif (av->data_pad > ubi->leb_size / 2) {\n\t\t\tubi_err(ubi, \"bad data_pad\");\n\t\t\tgoto bad_av;\n\t\t}\n\n\t\tlast_aeb = NULL;\n\t\tubi_rb_for_each_entry(rb2, aeb, &av->root, u.rb) {\n\t\t\tcond_resched();\n\n\t\t\tlast_aeb = aeb;\n\t\t\tleb_count += 1;\n\n\t\t\tif (aeb->pnum < 0 || aeb->ec < 0) {\n\t\t\t\tubi_err(ubi, \"negative values\");\n\t\t\t\tgoto bad_aeb;\n\t\t\t}\n\n\t\t\tif (aeb->ec < ai->min_ec) {\n\t\t\t\tubi_err(ubi, \"bad ai->min_ec (%d), %d found\",\n\t\t\t\t\tai->min_ec, aeb->ec);\n\t\t\t\tgoto bad_aeb;\n\t\t\t}\n\n\t\t\tif (aeb->ec > ai->max_ec) {\n\t\t\t\tubi_err(ubi, \"bad ai->max_ec (%d), %d found\",\n\t\t\t\t\tai->max_ec, aeb->ec);\n\t\t\t\tgoto bad_aeb;\n\t\t\t}\n\n\t\t\tif (aeb->pnum >= ubi->peb_count) {\n\t\t\t\tubi_err(ubi, \"too high PEB number %d, total PEBs %d\",\n\t\t\t\t\taeb->pnum, ubi->peb_count);\n\t\t\t\tgoto bad_aeb;\n\t\t\t}\n\n\t\t\tif (av->vol_type == UBI_STATIC_VOLUME) {\n\t\t\t\tif (aeb->lnum >= av->used_ebs) {\n\t\t\t\t\tubi_err(ubi, \"bad lnum or used_ebs\");\n\t\t\t\t\tgoto bad_aeb;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (av->used_ebs != 0) {\n\t\t\t\t\tubi_err(ubi, \"non-zero used_ebs\");\n\t\t\t\t\tgoto bad_aeb;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (aeb->lnum > av->highest_lnum) {\n\t\t\t\tubi_err(ubi, \"incorrect highest_lnum or lnum\");\n\t\t\t\tgoto bad_aeb;\n\t\t\t}\n\t\t}\n\n\t\tif (av->leb_count != leb_count) {\n\t\t\tubi_err(ubi, \"bad leb_count, %d objects in the tree\",\n\t\t\t\tleb_count);\n\t\t\tgoto bad_av;\n\t\t}\n\n\t\tif (!last_aeb)\n\t\t\tcontinue;\n\n\t\taeb = last_aeb;\n\n\t\tif (aeb->lnum != av->highest_lnum) {\n\t\t\tubi_err(ubi, \"bad highest_lnum\");\n\t\t\tgoto bad_aeb;\n\t\t}\n\t}\n\n\tif (vols_found != ai->vols_found) {\n\t\tubi_err(ubi, \"bad ai->vols_found %d, should be %d\",\n\t\t\tai->vols_found, vols_found);\n\t\tgoto out;\n\t}\n\n\t \n\tubi_rb_for_each_entry(rb1, av, &ai->volumes, rb) {\n\t\tlast_aeb = NULL;\n\t\tubi_rb_for_each_entry(rb2, aeb, &av->root, u.rb) {\n\t\t\tint vol_type;\n\n\t\t\tcond_resched();\n\n\t\t\tlast_aeb = aeb;\n\n\t\t\terr = ubi_io_read_vid_hdr(ubi, aeb->pnum, vidb, 1);\n\t\t\tif (err && err != UBI_IO_BITFLIPS) {\n\t\t\t\tubi_err(ubi, \"VID header is not OK (%d)\",\n\t\t\t\t\terr);\n\t\t\t\tif (err > 0)\n\t\t\t\t\terr = -EIO;\n\t\t\t\treturn err;\n\t\t\t}\n\n\t\t\tvol_type = vidh->vol_type == UBI_VID_DYNAMIC ?\n\t\t\t\t   UBI_DYNAMIC_VOLUME : UBI_STATIC_VOLUME;\n\t\t\tif (av->vol_type != vol_type) {\n\t\t\t\tubi_err(ubi, \"bad vol_type\");\n\t\t\t\tgoto bad_vid_hdr;\n\t\t\t}\n\n\t\t\tif (aeb->sqnum != be64_to_cpu(vidh->sqnum)) {\n\t\t\t\tubi_err(ubi, \"bad sqnum %llu\", aeb->sqnum);\n\t\t\t\tgoto bad_vid_hdr;\n\t\t\t}\n\n\t\t\tif (av->vol_id != be32_to_cpu(vidh->vol_id)) {\n\t\t\t\tubi_err(ubi, \"bad vol_id %d\", av->vol_id);\n\t\t\t\tgoto bad_vid_hdr;\n\t\t\t}\n\n\t\t\tif (av->compat != vidh->compat) {\n\t\t\t\tubi_err(ubi, \"bad compat %d\", vidh->compat);\n\t\t\t\tgoto bad_vid_hdr;\n\t\t\t}\n\n\t\t\tif (aeb->lnum != be32_to_cpu(vidh->lnum)) {\n\t\t\t\tubi_err(ubi, \"bad lnum %d\", aeb->lnum);\n\t\t\t\tgoto bad_vid_hdr;\n\t\t\t}\n\n\t\t\tif (av->used_ebs != be32_to_cpu(vidh->used_ebs)) {\n\t\t\t\tubi_err(ubi, \"bad used_ebs %d\", av->used_ebs);\n\t\t\t\tgoto bad_vid_hdr;\n\t\t\t}\n\n\t\t\tif (av->data_pad != be32_to_cpu(vidh->data_pad)) {\n\t\t\t\tubi_err(ubi, \"bad data_pad %d\", av->data_pad);\n\t\t\t\tgoto bad_vid_hdr;\n\t\t\t}\n\t\t}\n\n\t\tif (!last_aeb)\n\t\t\tcontinue;\n\n\t\tif (av->highest_lnum != be32_to_cpu(vidh->lnum)) {\n\t\t\tubi_err(ubi, \"bad highest_lnum %d\", av->highest_lnum);\n\t\t\tgoto bad_vid_hdr;\n\t\t}\n\n\t\tif (av->last_data_size != be32_to_cpu(vidh->data_size)) {\n\t\t\tubi_err(ubi, \"bad last_data_size %d\",\n\t\t\t\tav->last_data_size);\n\t\t\tgoto bad_vid_hdr;\n\t\t}\n\t}\n\n\t \n\tbuf = kzalloc(ubi->peb_count, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tfor (pnum = 0; pnum < ubi->peb_count; pnum++) {\n\t\terr = ubi_io_is_bad(ubi, pnum);\n\t\tif (err < 0) {\n\t\t\tkfree(buf);\n\t\t\treturn err;\n\t\t} else if (err)\n\t\t\tbuf[pnum] = 1;\n\t}\n\n\tubi_rb_for_each_entry(rb1, av, &ai->volumes, rb)\n\t\tubi_rb_for_each_entry(rb2, aeb, &av->root, u.rb)\n\t\t\tbuf[aeb->pnum] = 1;\n\n\tlist_for_each_entry(aeb, &ai->free, u.list)\n\t\tbuf[aeb->pnum] = 1;\n\n\tlist_for_each_entry(aeb, &ai->corr, u.list)\n\t\tbuf[aeb->pnum] = 1;\n\n\tlist_for_each_entry(aeb, &ai->erase, u.list)\n\t\tbuf[aeb->pnum] = 1;\n\n\tlist_for_each_entry(aeb, &ai->alien, u.list)\n\t\tbuf[aeb->pnum] = 1;\n\n\terr = 0;\n\tfor (pnum = 0; pnum < ubi->peb_count; pnum++)\n\t\tif (!buf[pnum]) {\n\t\t\tubi_err(ubi, \"PEB %d is not referred\", pnum);\n\t\t\terr = 1;\n\t\t}\n\n\tkfree(buf);\n\tif (err)\n\t\tgoto out;\n\treturn 0;\n\nbad_aeb:\n\tubi_err(ubi, \"bad attaching information about LEB %d\", aeb->lnum);\n\tubi_dump_aeb(aeb, 0);\n\tubi_dump_av(av);\n\tgoto out;\n\nbad_av:\n\tubi_err(ubi, \"bad attaching information about volume %d\", av->vol_id);\n\tubi_dump_av(av);\n\tgoto out;\n\nbad_vid_hdr:\n\tubi_err(ubi, \"bad attaching information about volume %d\", av->vol_id);\n\tubi_dump_av(av);\n\tubi_dump_vid_hdr(vidh);\n\nout:\n\tdump_stack();\n\treturn -EINVAL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}