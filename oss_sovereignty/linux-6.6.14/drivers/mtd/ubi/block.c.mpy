{
  "module_name": "block.c",
  "hash_id": "7cc191c0a5bc6e6c01e4b224f65661ad2853e8a90a1c09122cf22b899c201905",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/ubi/block.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/err.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/mtd/ubi.h>\n#include <linux/blkdev.h>\n#include <linux/blk-mq.h>\n#include <linux/hdreg.h>\n#include <linux/scatterlist.h>\n#include <linux/idr.h>\n#include <asm/div64.h>\n\n#include \"ubi-media.h\"\n#include \"ubi.h\"\n\n \n#define UBIBLOCK_MAX_DEVICES 32\n\n \n#define UBIBLOCK_PARAM_LEN 63\n\n \n#define UBIBLOCK_PARAM_COUNT 2\n\nstruct ubiblock_param {\n\tint ubi_num;\n\tint vol_id;\n\tchar name[UBIBLOCK_PARAM_LEN+1];\n};\n\nstruct ubiblock_pdu {\n\tstruct ubi_sgl usgl;\n};\n\n \nstatic int ubiblock_devs __initdata;\n\n \nstatic struct ubiblock_param ubiblock_param[UBIBLOCK_MAX_DEVICES] __initdata;\n\nstruct ubiblock {\n\tstruct ubi_volume_desc *desc;\n\tint ubi_num;\n\tint vol_id;\n\tint refcnt;\n\tint leb_size;\n\n\tstruct gendisk *gd;\n\tstruct request_queue *rq;\n\n\tstruct mutex dev_mutex;\n\tstruct list_head list;\n\tstruct blk_mq_tag_set tag_set;\n};\n\n \nstatic LIST_HEAD(ubiblock_devices);\nstatic DEFINE_IDR(ubiblock_minor_idr);\n \nstatic DEFINE_MUTEX(devices_mutex);\nstatic int ubiblock_major;\n\nstatic int __init ubiblock_set_param(const char *val,\n\t\t\t\t     const struct kernel_param *kp)\n{\n\tint i, ret;\n\tsize_t len;\n\tstruct ubiblock_param *param;\n\tchar buf[UBIBLOCK_PARAM_LEN];\n\tchar *pbuf = &buf[0];\n\tchar *tokens[UBIBLOCK_PARAM_COUNT];\n\n\tif (!val)\n\t\treturn -EINVAL;\n\n\tlen = strnlen(val, UBIBLOCK_PARAM_LEN);\n\tif (len == 0) {\n\t\tpr_warn(\"UBI: block: empty 'block=' parameter - ignored\\n\");\n\t\treturn 0;\n\t}\n\n\tif (len == UBIBLOCK_PARAM_LEN) {\n\t\tpr_err(\"UBI: block: parameter \\\"%s\\\" is too long, max. is %d\\n\",\n\t\t       val, UBIBLOCK_PARAM_LEN);\n\t\treturn -EINVAL;\n\t}\n\n\tstrcpy(buf, val);\n\n\t \n\tif (buf[len - 1] == '\\n')\n\t\tbuf[len - 1] = '\\0';\n\n\tfor (i = 0; i < UBIBLOCK_PARAM_COUNT; i++)\n\t\ttokens[i] = strsep(&pbuf, \",\");\n\n\tparam = &ubiblock_param[ubiblock_devs];\n\tif (tokens[1]) {\n\t\t \n\t\tret = kstrtoint(tokens[0], 10, &param->ubi_num);\n\t\tif (ret < 0)\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\tret = kstrtoint(tokens[1], 10, &param->vol_id);\n\t\tif (ret < 0) {\n\t\t\tparam->vol_id = -1;\n\t\t\tstrcpy(param->name, tokens[1]);\n\t\t}\n\n\t} else {\n\t\t \n\t\tstrcpy(param->name, tokens[0]);\n\t\tparam->ubi_num = -1;\n\t\tparam->vol_id = -1;\n\t}\n\n\tubiblock_devs++;\n\n\treturn 0;\n}\n\nstatic const struct kernel_param_ops ubiblock_param_ops = {\n\t.set    = ubiblock_set_param,\n};\nmodule_param_cb(block, &ubiblock_param_ops, NULL, 0);\nMODULE_PARM_DESC(block, \"Attach block devices to UBI volumes. Parameter format: block=<path|dev,num|dev,name>.\\n\"\n\t\t\t\"Multiple \\\"block\\\" parameters may be specified.\\n\"\n\t\t\t\"UBI volumes may be specified by their number, name, or path to the device node.\\n\"\n\t\t\t\"Examples\\n\"\n\t\t\t\"Using the UBI volume path:\\n\"\n\t\t\t\"ubi.block=/dev/ubi0_0\\n\"\n\t\t\t\"Using the UBI device, and the volume name:\\n\"\n\t\t\t\"ubi.block=0,rootfs\\n\"\n\t\t\t\"Using both UBI device number and UBI volume number:\\n\"\n\t\t\t\"ubi.block=0,0\\n\");\n\nstatic struct ubiblock *find_dev_nolock(int ubi_num, int vol_id)\n{\n\tstruct ubiblock *dev;\n\n\tlist_for_each_entry(dev, &ubiblock_devices, list)\n\t\tif (dev->ubi_num == ubi_num && dev->vol_id == vol_id)\n\t\t\treturn dev;\n\treturn NULL;\n}\n\nstatic blk_status_t ubiblock_read(struct request *req)\n{\n\tstruct ubiblock_pdu *pdu = blk_mq_rq_to_pdu(req);\n\tstruct ubiblock *dev = req->q->queuedata;\n\tu64 pos = blk_rq_pos(req) << 9;\n\tint to_read = blk_rq_bytes(req);\n\tint bytes_left = to_read;\n\t \n\tint offset = do_div(pos, dev->leb_size);\n\tint leb = pos;\n\tstruct req_iterator iter;\n\tstruct bio_vec bvec;\n\tint ret;\n\n\tblk_mq_start_request(req);\n\n\t \n\tubi_sgl_init(&pdu->usgl);\n\tblk_rq_map_sg(req->q, req, pdu->usgl.sg);\n\n\twhile (bytes_left) {\n\t\t \n\t\tif (offset + to_read > dev->leb_size)\n\t\t\tto_read = dev->leb_size - offset;\n\n\t\tret = ubi_read_sg(dev->desc, leb, &pdu->usgl, offset, to_read);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\n\t\tbytes_left -= to_read;\n\t\tto_read = bytes_left;\n\t\tleb += 1;\n\t\toffset = 0;\n\t}\n\n\trq_for_each_segment(bvec, req, iter)\n\t\tflush_dcache_page(bvec.bv_page);\n\n\tblk_mq_end_request(req, errno_to_blk_status(ret));\n\n\treturn BLK_STS_OK;\n}\n\nstatic int ubiblock_open(struct gendisk *disk, blk_mode_t mode)\n{\n\tstruct ubiblock *dev = disk->private_data;\n\tint ret;\n\n\tmutex_lock(&dev->dev_mutex);\n\tif (dev->refcnt > 0) {\n\t\t \n\t\tgoto out_done;\n\t}\n\n\t \n\tif (mode & BLK_OPEN_WRITE) {\n\t\tret = -EROFS;\n\t\tgoto out_unlock;\n\t}\n\tdev->desc = ubi_open_volume(dev->ubi_num, dev->vol_id, UBI_READONLY);\n\tif (IS_ERR(dev->desc)) {\n\t\tdev_err(disk_to_dev(dev->gd), \"failed to open ubi volume %d_%d\",\n\t\t\tdev->ubi_num, dev->vol_id);\n\t\tret = PTR_ERR(dev->desc);\n\t\tdev->desc = NULL;\n\t\tgoto out_unlock;\n\t}\n\nout_done:\n\tdev->refcnt++;\n\tmutex_unlock(&dev->dev_mutex);\n\treturn 0;\n\nout_unlock:\n\tmutex_unlock(&dev->dev_mutex);\n\treturn ret;\n}\n\nstatic void ubiblock_release(struct gendisk *gd)\n{\n\tstruct ubiblock *dev = gd->private_data;\n\n\tmutex_lock(&dev->dev_mutex);\n\tdev->refcnt--;\n\tif (dev->refcnt == 0) {\n\t\tubi_close_volume(dev->desc);\n\t\tdev->desc = NULL;\n\t}\n\tmutex_unlock(&dev->dev_mutex);\n}\n\nstatic int ubiblock_getgeo(struct block_device *bdev, struct hd_geometry *geo)\n{\n\t \n\tgeo->heads = 1;\n\tgeo->cylinders = 1;\n\tgeo->sectors = get_capacity(bdev->bd_disk);\n\tgeo->start = 0;\n\treturn 0;\n}\n\nstatic const struct block_device_operations ubiblock_ops = {\n\t.owner = THIS_MODULE,\n\t.open = ubiblock_open,\n\t.release = ubiblock_release,\n\t.getgeo\t= ubiblock_getgeo,\n};\n\nstatic blk_status_t ubiblock_queue_rq(struct blk_mq_hw_ctx *hctx,\n\t\t\t     const struct blk_mq_queue_data *bd)\n{\n\tswitch (req_op(bd->rq)) {\n\tcase REQ_OP_READ:\n\t\treturn ubiblock_read(bd->rq);\n\tdefault:\n\t\treturn BLK_STS_IOERR;\n\t}\n}\n\nstatic int ubiblock_init_request(struct blk_mq_tag_set *set,\n\t\tstruct request *req, unsigned int hctx_idx,\n\t\tunsigned int numa_node)\n{\n\tstruct ubiblock_pdu *pdu = blk_mq_rq_to_pdu(req);\n\n\tsg_init_table(pdu->usgl.sg, UBI_MAX_SG_COUNT);\n\treturn 0;\n}\n\nstatic const struct blk_mq_ops ubiblock_mq_ops = {\n\t.queue_rq       = ubiblock_queue_rq,\n\t.init_request\t= ubiblock_init_request,\n};\n\nstatic int calc_disk_capacity(struct ubi_volume_info *vi, u64 *disk_capacity)\n{\n\tu64 size = vi->used_bytes >> 9;\n\n\tif (vi->used_bytes % 512) {\n\t\tif (vi->vol_type == UBI_DYNAMIC_VOLUME)\n\t\t\tpr_warn(\"UBI: block: volume size is not a multiple of 512, last %llu bytes are ignored!\\n\",\n\t\t\t\tvi->used_bytes - (size << 9));\n\t\telse\n\t\t\tpr_info(\"UBI: block: volume size is not a multiple of 512, last %llu bytes are ignored!\\n\",\n\t\t\t\tvi->used_bytes - (size << 9));\n\t}\n\n\tif ((sector_t)size != size)\n\t\treturn -EFBIG;\n\n\t*disk_capacity = size;\n\n\treturn 0;\n}\n\nint ubiblock_create(struct ubi_volume_info *vi)\n{\n\tstruct ubiblock *dev;\n\tstruct gendisk *gd;\n\tu64 disk_capacity;\n\tint ret;\n\n\tret = calc_disk_capacity(vi, &disk_capacity);\n\tif (ret) {\n\t\treturn ret;\n\t}\n\n\t \n\tmutex_lock(&devices_mutex);\n\tif (find_dev_nolock(vi->ubi_num, vi->vol_id)) {\n\t\tret = -EEXIST;\n\t\tgoto out_unlock;\n\t}\n\n\tdev = kzalloc(sizeof(struct ubiblock), GFP_KERNEL);\n\tif (!dev) {\n\t\tret = -ENOMEM;\n\t\tgoto out_unlock;\n\t}\n\n\tmutex_init(&dev->dev_mutex);\n\n\tdev->ubi_num = vi->ubi_num;\n\tdev->vol_id = vi->vol_id;\n\tdev->leb_size = vi->usable_leb_size;\n\n\tdev->tag_set.ops = &ubiblock_mq_ops;\n\tdev->tag_set.queue_depth = 64;\n\tdev->tag_set.numa_node = NUMA_NO_NODE;\n\tdev->tag_set.flags = BLK_MQ_F_SHOULD_MERGE | BLK_MQ_F_BLOCKING;\n\tdev->tag_set.cmd_size = sizeof(struct ubiblock_pdu);\n\tdev->tag_set.driver_data = dev;\n\tdev->tag_set.nr_hw_queues = 1;\n\n\tret = blk_mq_alloc_tag_set(&dev->tag_set);\n\tif (ret) {\n\t\tdev_err(disk_to_dev(dev->gd), \"blk_mq_alloc_tag_set failed\");\n\t\tgoto out_free_dev;\n\t}\n\n\n\t \n\tgd = blk_mq_alloc_disk(&dev->tag_set, dev);\n\tif (IS_ERR(gd)) {\n\t\tret = PTR_ERR(gd);\n\t\tgoto out_free_tags;\n\t}\n\n\tgd->fops = &ubiblock_ops;\n\tgd->major = ubiblock_major;\n\tgd->minors = 1;\n\tgd->first_minor = idr_alloc(&ubiblock_minor_idr, dev, 0, 0, GFP_KERNEL);\n\tif (gd->first_minor < 0) {\n\t\tdev_err(disk_to_dev(gd),\n\t\t\t\"block: dynamic minor allocation failed\");\n\t\tret = -ENODEV;\n\t\tgoto out_cleanup_disk;\n\t}\n\tgd->flags |= GENHD_FL_NO_PART;\n\tgd->private_data = dev;\n\tsprintf(gd->disk_name, \"ubiblock%d_%d\", dev->ubi_num, dev->vol_id);\n\tset_capacity(gd, disk_capacity);\n\tdev->gd = gd;\n\n\tdev->rq = gd->queue;\n\tblk_queue_max_segments(dev->rq, UBI_MAX_SG_COUNT);\n\n\tlist_add_tail(&dev->list, &ubiblock_devices);\n\n\t \n\tret = device_add_disk(vi->dev, dev->gd, NULL);\n\tif (ret)\n\t\tgoto out_remove_minor;\n\n\tdev_info(disk_to_dev(dev->gd), \"created from ubi%d:%d(%s)\",\n\t\t dev->ubi_num, dev->vol_id, vi->name);\n\tmutex_unlock(&devices_mutex);\n\treturn 0;\n\nout_remove_minor:\n\tlist_del(&dev->list);\n\tidr_remove(&ubiblock_minor_idr, gd->first_minor);\nout_cleanup_disk:\n\tput_disk(dev->gd);\nout_free_tags:\n\tblk_mq_free_tag_set(&dev->tag_set);\nout_free_dev:\n\tkfree(dev);\nout_unlock:\n\tmutex_unlock(&devices_mutex);\n\n\treturn ret;\n}\n\nstatic void ubiblock_cleanup(struct ubiblock *dev)\n{\n\t \n\tdel_gendisk(dev->gd);\n\t \n\tdev_info(disk_to_dev(dev->gd), \"released\");\n\tput_disk(dev->gd);\n\tblk_mq_free_tag_set(&dev->tag_set);\n\tidr_remove(&ubiblock_minor_idr, dev->gd->first_minor);\n}\n\nint ubiblock_remove(struct ubi_volume_info *vi)\n{\n\tstruct ubiblock *dev;\n\tint ret;\n\n\tmutex_lock(&devices_mutex);\n\tdev = find_dev_nolock(vi->ubi_num, vi->vol_id);\n\tif (!dev) {\n\t\tret = -ENODEV;\n\t\tgoto out_unlock;\n\t}\n\n\t \n\tmutex_lock(&dev->dev_mutex);\n\tif (dev->refcnt > 0) {\n\t\tret = -EBUSY;\n\t\tgoto out_unlock_dev;\n\t}\n\n\t \n\tlist_del(&dev->list);\n\tubiblock_cleanup(dev);\n\tmutex_unlock(&dev->dev_mutex);\n\tmutex_unlock(&devices_mutex);\n\n\tkfree(dev);\n\treturn 0;\n\nout_unlock_dev:\n\tmutex_unlock(&dev->dev_mutex);\nout_unlock:\n\tmutex_unlock(&devices_mutex);\n\treturn ret;\n}\n\nstatic int ubiblock_resize(struct ubi_volume_info *vi)\n{\n\tstruct ubiblock *dev;\n\tu64 disk_capacity;\n\tint ret;\n\n\t \n\tmutex_lock(&devices_mutex);\n\tdev = find_dev_nolock(vi->ubi_num, vi->vol_id);\n\tif (!dev) {\n\t\tmutex_unlock(&devices_mutex);\n\t\treturn -ENODEV;\n\t}\n\n\tret = calc_disk_capacity(vi, &disk_capacity);\n\tif (ret) {\n\t\tmutex_unlock(&devices_mutex);\n\t\tif (ret == -EFBIG) {\n\t\t\tdev_warn(disk_to_dev(dev->gd),\n\t\t\t\t \"the volume is too big (%d LEBs), cannot resize\",\n\t\t\t\t vi->size);\n\t\t}\n\t\treturn ret;\n\t}\n\n\tmutex_lock(&dev->dev_mutex);\n\n\tif (get_capacity(dev->gd) != disk_capacity) {\n\t\tset_capacity(dev->gd, disk_capacity);\n\t\tdev_info(disk_to_dev(dev->gd), \"resized to %lld bytes\",\n\t\t\t vi->used_bytes);\n\t}\n\tmutex_unlock(&dev->dev_mutex);\n\tmutex_unlock(&devices_mutex);\n\treturn 0;\n}\n\nstatic int ubiblock_notify(struct notifier_block *nb,\n\t\t\t unsigned long notification_type, void *ns_ptr)\n{\n\tstruct ubi_notification *nt = ns_ptr;\n\n\tswitch (notification_type) {\n\tcase UBI_VOLUME_ADDED:\n\t\t \n\t\tbreak;\n\tcase UBI_VOLUME_REMOVED:\n\t\tubiblock_remove(&nt->vi);\n\t\tbreak;\n\tcase UBI_VOLUME_RESIZED:\n\t\tubiblock_resize(&nt->vi);\n\t\tbreak;\n\tcase UBI_VOLUME_UPDATED:\n\t\t \n\t\tif (nt->vi.vol_type == UBI_STATIC_VOLUME)\n\t\t\tubiblock_resize(&nt->vi);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn NOTIFY_OK;\n}\n\nstatic struct notifier_block ubiblock_notifier = {\n\t.notifier_call = ubiblock_notify,\n};\n\nstatic struct ubi_volume_desc * __init\nopen_volume_desc(const char *name, int ubi_num, int vol_id)\n{\n\tif (ubi_num == -1)\n\t\t \n\t\treturn ubi_open_volume_path(name, UBI_READONLY);\n\telse if (vol_id == -1)\n\t\t \n\t\treturn ubi_open_volume_nm(ubi_num, name, UBI_READONLY);\n\telse\n\t\treturn ubi_open_volume(ubi_num, vol_id, UBI_READONLY);\n}\n\nstatic void __init ubiblock_create_from_param(void)\n{\n\tint i, ret = 0;\n\tstruct ubiblock_param *p;\n\tstruct ubi_volume_desc *desc;\n\tstruct ubi_volume_info vi;\n\n\t \n\tfor (i = 0; i < ubiblock_devs; i++) {\n\t\tp = &ubiblock_param[i];\n\n\t\tdesc = open_volume_desc(p->name, p->ubi_num, p->vol_id);\n\t\tif (IS_ERR(desc)) {\n\t\t\tpr_err(\n\t\t\t       \"UBI: block: can't open volume on ubi%d_%d, err=%ld\\n\",\n\t\t\t       p->ubi_num, p->vol_id, PTR_ERR(desc));\n\t\t\tcontinue;\n\t\t}\n\n\t\tubi_get_volume_info(desc, &vi);\n\t\tubi_close_volume(desc);\n\n\t\tret = ubiblock_create(&vi);\n\t\tif (ret) {\n\t\t\tpr_err(\n\t\t\t       \"UBI: block: can't add '%s' volume on ubi%d_%d, err=%d\\n\",\n\t\t\t       vi.name, p->ubi_num, p->vol_id, ret);\n\t\t\tcontinue;\n\t\t}\n\t}\n}\n\nstatic void ubiblock_remove_all(void)\n{\n\tstruct ubiblock *next;\n\tstruct ubiblock *dev;\n\n\tmutex_lock(&devices_mutex);\n\tlist_for_each_entry_safe(dev, next, &ubiblock_devices, list) {\n\t\t \n\t\tWARN_ON(dev->desc);\n\t\t \n\t\tlist_del(&dev->list);\n\t\tubiblock_cleanup(dev);\n\t\tkfree(dev);\n\t}\n\tmutex_unlock(&devices_mutex);\n}\n\nint __init ubiblock_init(void)\n{\n\tint ret;\n\n\tubiblock_major = register_blkdev(0, \"ubiblock\");\n\tif (ubiblock_major < 0)\n\t\treturn ubiblock_major;\n\n\t \n\tubiblock_create_from_param();\n\n\t \n\tret = ubi_register_volume_notifier(&ubiblock_notifier, 1);\n\tif (ret)\n\t\tgoto err_unreg;\n\treturn 0;\n\nerr_unreg:\n\tunregister_blkdev(ubiblock_major, \"ubiblock\");\n\tubiblock_remove_all();\n\treturn ret;\n}\n\nvoid __exit ubiblock_exit(void)\n{\n\tubi_unregister_volume_notifier(&ubiblock_notifier);\n\tubiblock_remove_all();\n\tunregister_blkdev(ubiblock_major, \"ubiblock\");\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}