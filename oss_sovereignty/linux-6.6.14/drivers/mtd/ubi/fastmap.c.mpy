{
  "module_name": "fastmap.c",
  "hash_id": "4f55b0216da688e65e64f4b7f13074e1bb4f82f0f17b48b57518e375461cb611",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/ubi/fastmap.c",
  "human_readable_source": "\n \n\n#include <linux/crc32.h>\n#include <linux/bitmap.h>\n#include \"ubi.h\"\n\n \nstatic inline unsigned long *init_seen(struct ubi_device *ubi)\n{\n\tunsigned long *ret;\n\n\tif (!ubi_dbg_chk_fastmap(ubi))\n\t\treturn NULL;\n\n\tret = bitmap_zalloc(ubi->peb_count, GFP_KERNEL);\n\tif (!ret)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\treturn ret;\n}\n\n \nstatic inline void free_seen(unsigned long *seen)\n{\n\tbitmap_free(seen);\n}\n\n \nstatic inline void set_seen(struct ubi_device *ubi, int pnum, unsigned long *seen)\n{\n\tif (!ubi_dbg_chk_fastmap(ubi) || !seen)\n\t\treturn;\n\n\tset_bit(pnum, seen);\n}\n\n \nstatic int self_check_seen(struct ubi_device *ubi, unsigned long *seen)\n{\n\tint pnum, ret = 0;\n\n\tif (!ubi_dbg_chk_fastmap(ubi) || !seen)\n\t\treturn 0;\n\n\tfor (pnum = 0; pnum < ubi->peb_count; pnum++) {\n\t\tif (!test_bit(pnum, seen) && ubi->lookuptbl[pnum]) {\n\t\t\tubi_err(ubi, \"self-check failed for PEB %d, fastmap didn't see it\", pnum);\n\t\t\tret = -EINVAL;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\n \nsize_t ubi_calc_fm_size(struct ubi_device *ubi)\n{\n\tsize_t size;\n\n\tsize = sizeof(struct ubi_fm_sb) +\n\t\tsizeof(struct ubi_fm_hdr) +\n\t\tsizeof(struct ubi_fm_scan_pool) +\n\t\tsizeof(struct ubi_fm_scan_pool) +\n\t\t(ubi->peb_count * sizeof(struct ubi_fm_ec)) +\n\t\t(sizeof(struct ubi_fm_eba) +\n\t\t(ubi->peb_count * sizeof(__be32))) +\n\t\tsizeof(struct ubi_fm_volhdr) * UBI_MAX_VOLUMES;\n\treturn roundup(size, ubi->leb_size);\n}\n\n\n \nstatic struct ubi_vid_io_buf *new_fm_vbuf(struct ubi_device *ubi, int vol_id)\n{\n\tstruct ubi_vid_io_buf *new;\n\tstruct ubi_vid_hdr *vh;\n\n\tnew = ubi_alloc_vid_buf(ubi, GFP_KERNEL);\n\tif (!new)\n\t\tgoto out;\n\n\tvh = ubi_get_vid_hdr(new);\n\tvh->vol_type = UBI_VID_DYNAMIC;\n\tvh->vol_id = cpu_to_be32(vol_id);\n\n\t \n\tvh->compat = UBI_COMPAT_DELETE;\n\nout:\n\treturn new;\n}\n\n \nstatic int add_aeb(struct ubi_attach_info *ai, struct list_head *list,\n\t\t   int pnum, int ec, int scrub)\n{\n\tstruct ubi_ainf_peb *aeb;\n\n\taeb = ubi_alloc_aeb(ai, pnum, ec);\n\tif (!aeb)\n\t\treturn -ENOMEM;\n\n\taeb->lnum = -1;\n\taeb->scrub = scrub;\n\taeb->copy_flag = aeb->sqnum = 0;\n\n\tai->ec_sum += aeb->ec;\n\tai->ec_count++;\n\n\tif (ai->max_ec < aeb->ec)\n\t\tai->max_ec = aeb->ec;\n\n\tif (ai->min_ec > aeb->ec)\n\t\tai->min_ec = aeb->ec;\n\n\tlist_add_tail(&aeb->u.list, list);\n\n\treturn 0;\n}\n\n \nstatic struct ubi_ainf_volume *add_vol(struct ubi_attach_info *ai, int vol_id,\n\t\t\t\t       int used_ebs, int data_pad, u8 vol_type,\n\t\t\t\t       int last_eb_bytes)\n{\n\tstruct ubi_ainf_volume *av;\n\n\tav = ubi_add_av(ai, vol_id);\n\tif (IS_ERR(av))\n\t\treturn av;\n\n\tav->data_pad = data_pad;\n\tav->last_data_size = last_eb_bytes;\n\tav->compat = 0;\n\tav->vol_type = vol_type;\n\tif (av->vol_type == UBI_STATIC_VOLUME)\n\t\tav->used_ebs = used_ebs;\n\n\tdbg_bld(\"found volume (ID %i)\", vol_id);\n\treturn av;\n}\n\n \nstatic void assign_aeb_to_av(struct ubi_attach_info *ai,\n\t\t\t     struct ubi_ainf_peb *aeb,\n\t\t\t     struct ubi_ainf_volume *av)\n{\n\tstruct ubi_ainf_peb *tmp_aeb;\n\tstruct rb_node **p = &av->root.rb_node, *parent = NULL;\n\n\twhile (*p) {\n\t\tparent = *p;\n\n\t\ttmp_aeb = rb_entry(parent, struct ubi_ainf_peb, u.rb);\n\t\tif (aeb->lnum != tmp_aeb->lnum) {\n\t\t\tif (aeb->lnum < tmp_aeb->lnum)\n\t\t\t\tp = &(*p)->rb_left;\n\t\t\telse\n\t\t\t\tp = &(*p)->rb_right;\n\n\t\t\tcontinue;\n\t\t} else\n\t\t\tbreak;\n\t}\n\n\tlist_del(&aeb->u.list);\n\tav->leb_count++;\n\n\trb_link_node(&aeb->u.rb, parent, p);\n\trb_insert_color(&aeb->u.rb, &av->root);\n}\n\n \nstatic int update_vol(struct ubi_device *ubi, struct ubi_attach_info *ai,\n\t\t      struct ubi_ainf_volume *av, struct ubi_vid_hdr *new_vh,\n\t\t      struct ubi_ainf_peb *new_aeb)\n{\n\tstruct rb_node **p = &av->root.rb_node, *parent = NULL;\n\tstruct ubi_ainf_peb *aeb, *victim;\n\tint cmp_res;\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\taeb = rb_entry(parent, struct ubi_ainf_peb, u.rb);\n\n\t\tif (be32_to_cpu(new_vh->lnum) != aeb->lnum) {\n\t\t\tif (be32_to_cpu(new_vh->lnum) < aeb->lnum)\n\t\t\t\tp = &(*p)->rb_left;\n\t\t\telse\n\t\t\t\tp = &(*p)->rb_right;\n\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (aeb->pnum == new_aeb->pnum) {\n\t\t\tubi_assert(aeb->lnum == new_aeb->lnum);\n\t\t\tubi_free_aeb(ai, new_aeb);\n\n\t\t\treturn 0;\n\t\t}\n\n\t\tcmp_res = ubi_compare_lebs(ubi, aeb, new_aeb->pnum, new_vh);\n\t\tif (cmp_res < 0)\n\t\t\treturn cmp_res;\n\n\t\t \n\t\tif (cmp_res & 1) {\n\t\t\tvictim = ubi_alloc_aeb(ai, aeb->pnum, aeb->ec);\n\t\t\tif (!victim)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tlist_add_tail(&victim->u.list, &ai->erase);\n\n\t\t\tif (av->highest_lnum == be32_to_cpu(new_vh->lnum))\n\t\t\t\tav->last_data_size =\n\t\t\t\t\tbe32_to_cpu(new_vh->data_size);\n\n\t\t\tdbg_bld(\"vol %i: AEB %i's PEB %i is the newer\",\n\t\t\t\tav->vol_id, aeb->lnum, new_aeb->pnum);\n\n\t\t\taeb->ec = new_aeb->ec;\n\t\t\taeb->pnum = new_aeb->pnum;\n\t\t\taeb->copy_flag = new_vh->copy_flag;\n\t\t\taeb->scrub = new_aeb->scrub;\n\t\t\taeb->sqnum = new_aeb->sqnum;\n\t\t\tubi_free_aeb(ai, new_aeb);\n\n\t\t \n\t\t} else {\n\t\t\tdbg_bld(\"vol %i: AEB %i's PEB %i is old, dropping it\",\n\t\t\t\tav->vol_id, aeb->lnum, new_aeb->pnum);\n\t\t\tlist_add_tail(&new_aeb->u.list, &ai->erase);\n\t\t}\n\n\t\treturn 0;\n\t}\n\t \n\n\tif (av->highest_lnum <= be32_to_cpu(new_vh->lnum)) {\n\t\tav->highest_lnum = be32_to_cpu(new_vh->lnum);\n\t\tav->last_data_size = be32_to_cpu(new_vh->data_size);\n\t}\n\n\tif (av->vol_type == UBI_STATIC_VOLUME)\n\t\tav->used_ebs = be32_to_cpu(new_vh->used_ebs);\n\n\tav->leb_count++;\n\n\trb_link_node(&new_aeb->u.rb, parent, p);\n\trb_insert_color(&new_aeb->u.rb, &av->root);\n\n\treturn 0;\n}\n\n \nstatic int process_pool_aeb(struct ubi_device *ubi, struct ubi_attach_info *ai,\n\t\t\t    struct ubi_vid_hdr *new_vh,\n\t\t\t    struct ubi_ainf_peb *new_aeb)\n{\n\tint vol_id = be32_to_cpu(new_vh->vol_id);\n\tstruct ubi_ainf_volume *av;\n\n\tif (vol_id == UBI_FM_SB_VOLUME_ID || vol_id == UBI_FM_DATA_VOLUME_ID) {\n\t\tubi_free_aeb(ai, new_aeb);\n\n\t\treturn 0;\n\t}\n\n\t \n\tav = ubi_find_av(ai, vol_id);\n\tif (!av) {\n\t\tubi_err(ubi, \"orphaned volume in fastmap pool!\");\n\t\tubi_free_aeb(ai, new_aeb);\n\t\treturn UBI_BAD_FASTMAP;\n\t}\n\n\tubi_assert(vol_id == av->vol_id);\n\n\treturn update_vol(ubi, ai, av, new_vh, new_aeb);\n}\n\n \nstatic void unmap_peb(struct ubi_attach_info *ai, int pnum)\n{\n\tstruct ubi_ainf_volume *av;\n\tstruct rb_node *node, *node2;\n\tstruct ubi_ainf_peb *aeb;\n\n\tubi_rb_for_each_entry(node, av, &ai->volumes, rb) {\n\t\tubi_rb_for_each_entry(node2, aeb, &av->root, u.rb) {\n\t\t\tif (aeb->pnum == pnum) {\n\t\t\t\trb_erase(&aeb->u.rb, &av->root);\n\t\t\t\tav->leb_count--;\n\t\t\t\tubi_free_aeb(ai, aeb);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n}\n\n \nstatic int scan_pool(struct ubi_device *ubi, struct ubi_attach_info *ai,\n\t\t     __be32 *pebs, int pool_size, unsigned long long *max_sqnum,\n\t\t     struct list_head *free)\n{\n\tstruct ubi_vid_io_buf *vb;\n\tstruct ubi_vid_hdr *vh;\n\tstruct ubi_ec_hdr *ech;\n\tstruct ubi_ainf_peb *new_aeb;\n\tint i, pnum, err, ret = 0;\n\n\tech = kzalloc(ubi->ec_hdr_alsize, GFP_KERNEL);\n\tif (!ech)\n\t\treturn -ENOMEM;\n\n\tvb = ubi_alloc_vid_buf(ubi, GFP_KERNEL);\n\tif (!vb) {\n\t\tkfree(ech);\n\t\treturn -ENOMEM;\n\t}\n\n\tvh = ubi_get_vid_hdr(vb);\n\n\tdbg_bld(\"scanning fastmap pool: size = %i\", pool_size);\n\n\t \n\tfor (i = 0; i < pool_size; i++) {\n\t\tint scrub = 0;\n\t\tint image_seq;\n\n\t\tpnum = be32_to_cpu(pebs[i]);\n\n\t\tif (ubi_io_is_bad(ubi, pnum)) {\n\t\t\tubi_err(ubi, \"bad PEB in fastmap pool!\");\n\t\t\tret = UBI_BAD_FASTMAP;\n\t\t\tgoto out;\n\t\t}\n\n\t\terr = ubi_io_read_ec_hdr(ubi, pnum, ech, 0);\n\t\tif (err && err != UBI_IO_BITFLIPS) {\n\t\t\tubi_err(ubi, \"unable to read EC header! PEB:%i err:%i\",\n\t\t\t\tpnum, err);\n\t\t\tret = err > 0 ? UBI_BAD_FASTMAP : err;\n\t\t\tgoto out;\n\t\t} else if (err == UBI_IO_BITFLIPS)\n\t\t\tscrub = 1;\n\n\t\t \n\t\timage_seq = be32_to_cpu(ech->image_seq);\n\n\t\tif (image_seq && (image_seq != ubi->image_seq)) {\n\t\t\tubi_err(ubi, \"bad image seq: 0x%x, expected: 0x%x\",\n\t\t\t\tbe32_to_cpu(ech->image_seq), ubi->image_seq);\n\t\t\tret = UBI_BAD_FASTMAP;\n\t\t\tgoto out;\n\t\t}\n\n\t\terr = ubi_io_read_vid_hdr(ubi, pnum, vb, 0);\n\t\tif (err == UBI_IO_FF || err == UBI_IO_FF_BITFLIPS) {\n\t\t\tunsigned long long ec = be64_to_cpu(ech->ec);\n\t\t\tunmap_peb(ai, pnum);\n\t\t\tdbg_bld(\"Adding PEB to free: %i\", pnum);\n\n\t\t\tif (err == UBI_IO_FF_BITFLIPS)\n\t\t\t\tscrub = 1;\n\n\t\t\tret = add_aeb(ai, free, pnum, ec, scrub);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t\tcontinue;\n\t\t} else if (err == 0 || err == UBI_IO_BITFLIPS) {\n\t\t\tdbg_bld(\"Found non empty PEB:%i in pool\", pnum);\n\n\t\t\tif (err == UBI_IO_BITFLIPS)\n\t\t\t\tscrub = 1;\n\n\t\t\tnew_aeb = ubi_alloc_aeb(ai, pnum, be64_to_cpu(ech->ec));\n\t\t\tif (!new_aeb) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tnew_aeb->lnum = be32_to_cpu(vh->lnum);\n\t\t\tnew_aeb->sqnum = be64_to_cpu(vh->sqnum);\n\t\t\tnew_aeb->copy_flag = vh->copy_flag;\n\t\t\tnew_aeb->scrub = scrub;\n\n\t\t\tif (*max_sqnum < new_aeb->sqnum)\n\t\t\t\t*max_sqnum = new_aeb->sqnum;\n\n\t\t\terr = process_pool_aeb(ubi, ai, vh, new_aeb);\n\t\t\tif (err) {\n\t\t\t\tret = err > 0 ? UBI_BAD_FASTMAP : err;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tubi_err(ubi, \"fastmap pool PEBs contains damaged PEBs!\");\n\t\t\tret = err > 0 ? UBI_BAD_FASTMAP : err;\n\t\t\tgoto out;\n\t\t}\n\n\t}\n\nout:\n\tubi_free_vid_buf(vb);\n\tkfree(ech);\n\treturn ret;\n}\n\n \nstatic int count_fastmap_pebs(struct ubi_attach_info *ai)\n{\n\tstruct ubi_ainf_peb *aeb;\n\tstruct ubi_ainf_volume *av;\n\tstruct rb_node *rb1, *rb2;\n\tint n = 0;\n\n\tlist_for_each_entry(aeb, &ai->erase, u.list)\n\t\tn++;\n\n\tlist_for_each_entry(aeb, &ai->free, u.list)\n\t\tn++;\n\n\tubi_rb_for_each_entry(rb1, av, &ai->volumes, rb)\n\t\tubi_rb_for_each_entry(rb2, aeb, &av->root, u.rb)\n\t\t\tn++;\n\n\treturn n;\n}\n\n \nstatic int ubi_attach_fastmap(struct ubi_device *ubi,\n\t\t\t      struct ubi_attach_info *ai,\n\t\t\t      struct ubi_fastmap_layout *fm)\n{\n\tstruct list_head used, free;\n\tstruct ubi_ainf_volume *av;\n\tstruct ubi_ainf_peb *aeb, *tmp_aeb, *_tmp_aeb;\n\tstruct ubi_fm_sb *fmsb;\n\tstruct ubi_fm_hdr *fmhdr;\n\tstruct ubi_fm_scan_pool *fmpl, *fmpl_wl;\n\tstruct ubi_fm_ec *fmec;\n\tstruct ubi_fm_volhdr *fmvhdr;\n\tstruct ubi_fm_eba *fm_eba;\n\tint ret, i, j, pool_size, wl_pool_size;\n\tsize_t fm_pos = 0, fm_size = ubi->fm_size;\n\tunsigned long long max_sqnum = 0;\n\tvoid *fm_raw = ubi->fm_buf;\n\n\tINIT_LIST_HEAD(&used);\n\tINIT_LIST_HEAD(&free);\n\tai->min_ec = UBI_MAX_ERASECOUNTER;\n\n\tfmsb = (struct ubi_fm_sb *)(fm_raw);\n\tai->max_sqnum = fmsb->sqnum;\n\tfm_pos += sizeof(struct ubi_fm_sb);\n\tif (fm_pos >= fm_size)\n\t\tgoto fail_bad;\n\n\tfmhdr = (struct ubi_fm_hdr *)(fm_raw + fm_pos);\n\tfm_pos += sizeof(*fmhdr);\n\tif (fm_pos >= fm_size)\n\t\tgoto fail_bad;\n\n\tif (be32_to_cpu(fmhdr->magic) != UBI_FM_HDR_MAGIC) {\n\t\tubi_err(ubi, \"bad fastmap header magic: 0x%x, expected: 0x%x\",\n\t\t\tbe32_to_cpu(fmhdr->magic), UBI_FM_HDR_MAGIC);\n\t\tgoto fail_bad;\n\t}\n\n\tfmpl = (struct ubi_fm_scan_pool *)(fm_raw + fm_pos);\n\tfm_pos += sizeof(*fmpl);\n\tif (fm_pos >= fm_size)\n\t\tgoto fail_bad;\n\tif (be32_to_cpu(fmpl->magic) != UBI_FM_POOL_MAGIC) {\n\t\tubi_err(ubi, \"bad fastmap pool magic: 0x%x, expected: 0x%x\",\n\t\t\tbe32_to_cpu(fmpl->magic), UBI_FM_POOL_MAGIC);\n\t\tgoto fail_bad;\n\t}\n\n\tfmpl_wl = (struct ubi_fm_scan_pool *)(fm_raw + fm_pos);\n\tfm_pos += sizeof(*fmpl_wl);\n\tif (fm_pos >= fm_size)\n\t\tgoto fail_bad;\n\tif (be32_to_cpu(fmpl_wl->magic) != UBI_FM_POOL_MAGIC) {\n\t\tubi_err(ubi, \"bad fastmap WL pool magic: 0x%x, expected: 0x%x\",\n\t\t\tbe32_to_cpu(fmpl_wl->magic), UBI_FM_POOL_MAGIC);\n\t\tgoto fail_bad;\n\t}\n\n\tpool_size = be16_to_cpu(fmpl->size);\n\twl_pool_size = be16_to_cpu(fmpl_wl->size);\n\tfm->max_pool_size = be16_to_cpu(fmpl->max_size);\n\tfm->max_wl_pool_size = be16_to_cpu(fmpl_wl->max_size);\n\n\tif (pool_size > UBI_FM_MAX_POOL_SIZE || pool_size < 0) {\n\t\tubi_err(ubi, \"bad pool size: %i\", pool_size);\n\t\tgoto fail_bad;\n\t}\n\n\tif (wl_pool_size > UBI_FM_MAX_POOL_SIZE || wl_pool_size < 0) {\n\t\tubi_err(ubi, \"bad WL pool size: %i\", wl_pool_size);\n\t\tgoto fail_bad;\n\t}\n\n\n\tif (fm->max_pool_size > UBI_FM_MAX_POOL_SIZE ||\n\t    fm->max_pool_size < 0) {\n\t\tubi_err(ubi, \"bad maximal pool size: %i\", fm->max_pool_size);\n\t\tgoto fail_bad;\n\t}\n\n\tif (fm->max_wl_pool_size > UBI_FM_MAX_POOL_SIZE ||\n\t    fm->max_wl_pool_size < 0) {\n\t\tubi_err(ubi, \"bad maximal WL pool size: %i\",\n\t\t\tfm->max_wl_pool_size);\n\t\tgoto fail_bad;\n\t}\n\n\t \n\tfor (i = 0; i < be32_to_cpu(fmhdr->free_peb_count); i++) {\n\t\tfmec = (struct ubi_fm_ec *)(fm_raw + fm_pos);\n\t\tfm_pos += sizeof(*fmec);\n\t\tif (fm_pos >= fm_size)\n\t\t\tgoto fail_bad;\n\n\t\tret = add_aeb(ai, &ai->free, be32_to_cpu(fmec->pnum),\n\t\t\t      be32_to_cpu(fmec->ec), 0);\n\t\tif (ret)\n\t\t\tgoto fail;\n\t}\n\n\t \n\tfor (i = 0; i < be32_to_cpu(fmhdr->used_peb_count); i++) {\n\t\tfmec = (struct ubi_fm_ec *)(fm_raw + fm_pos);\n\t\tfm_pos += sizeof(*fmec);\n\t\tif (fm_pos >= fm_size)\n\t\t\tgoto fail_bad;\n\n\t\tret = add_aeb(ai, &used, be32_to_cpu(fmec->pnum),\n\t\t\t      be32_to_cpu(fmec->ec), 0);\n\t\tif (ret)\n\t\t\tgoto fail;\n\t}\n\n\t \n\tfor (i = 0; i < be32_to_cpu(fmhdr->scrub_peb_count); i++) {\n\t\tfmec = (struct ubi_fm_ec *)(fm_raw + fm_pos);\n\t\tfm_pos += sizeof(*fmec);\n\t\tif (fm_pos >= fm_size)\n\t\t\tgoto fail_bad;\n\n\t\tret = add_aeb(ai, &used, be32_to_cpu(fmec->pnum),\n\t\t\t      be32_to_cpu(fmec->ec), 1);\n\t\tif (ret)\n\t\t\tgoto fail;\n\t}\n\n\t \n\tfor (i = 0; i < be32_to_cpu(fmhdr->erase_peb_count); i++) {\n\t\tfmec = (struct ubi_fm_ec *)(fm_raw + fm_pos);\n\t\tfm_pos += sizeof(*fmec);\n\t\tif (fm_pos >= fm_size)\n\t\t\tgoto fail_bad;\n\n\t\tret = add_aeb(ai, &ai->erase, be32_to_cpu(fmec->pnum),\n\t\t\t      be32_to_cpu(fmec->ec), 1);\n\t\tif (ret)\n\t\t\tgoto fail;\n\t}\n\n\tai->mean_ec = div_u64(ai->ec_sum, ai->ec_count);\n\tai->bad_peb_count = be32_to_cpu(fmhdr->bad_peb_count);\n\n\t \n\tfor (i = 0; i < be32_to_cpu(fmhdr->vol_count); i++) {\n\t\tfmvhdr = (struct ubi_fm_volhdr *)(fm_raw + fm_pos);\n\t\tfm_pos += sizeof(*fmvhdr);\n\t\tif (fm_pos >= fm_size)\n\t\t\tgoto fail_bad;\n\n\t\tif (be32_to_cpu(fmvhdr->magic) != UBI_FM_VHDR_MAGIC) {\n\t\t\tubi_err(ubi, \"bad fastmap vol header magic: 0x%x, expected: 0x%x\",\n\t\t\t\tbe32_to_cpu(fmvhdr->magic), UBI_FM_VHDR_MAGIC);\n\t\t\tgoto fail_bad;\n\t\t}\n\n\t\tav = add_vol(ai, be32_to_cpu(fmvhdr->vol_id),\n\t\t\t     be32_to_cpu(fmvhdr->used_ebs),\n\t\t\t     be32_to_cpu(fmvhdr->data_pad),\n\t\t\t     fmvhdr->vol_type,\n\t\t\t     be32_to_cpu(fmvhdr->last_eb_bytes));\n\n\t\tif (IS_ERR(av)) {\n\t\t\tif (PTR_ERR(av) == -EEXIST)\n\t\t\t\tubi_err(ubi, \"volume (ID %i) already exists\",\n\t\t\t\t\tfmvhdr->vol_id);\n\n\t\t\tgoto fail_bad;\n\t\t}\n\n\t\tai->vols_found++;\n\t\tif (ai->highest_vol_id < be32_to_cpu(fmvhdr->vol_id))\n\t\t\tai->highest_vol_id = be32_to_cpu(fmvhdr->vol_id);\n\n\t\tfm_eba = (struct ubi_fm_eba *)(fm_raw + fm_pos);\n\t\tfm_pos += sizeof(*fm_eba);\n\t\tfm_pos += (sizeof(__be32) * be32_to_cpu(fm_eba->reserved_pebs));\n\t\tif (fm_pos >= fm_size)\n\t\t\tgoto fail_bad;\n\n\t\tif (be32_to_cpu(fm_eba->magic) != UBI_FM_EBA_MAGIC) {\n\t\t\tubi_err(ubi, \"bad fastmap EBA header magic: 0x%x, expected: 0x%x\",\n\t\t\t\tbe32_to_cpu(fm_eba->magic), UBI_FM_EBA_MAGIC);\n\t\t\tgoto fail_bad;\n\t\t}\n\n\t\tfor (j = 0; j < be32_to_cpu(fm_eba->reserved_pebs); j++) {\n\t\t\tint pnum = be32_to_cpu(fm_eba->pnum[j]);\n\n\t\t\tif (pnum < 0)\n\t\t\t\tcontinue;\n\n\t\t\taeb = NULL;\n\t\t\tlist_for_each_entry(tmp_aeb, &used, u.list) {\n\t\t\t\tif (tmp_aeb->pnum == pnum) {\n\t\t\t\t\taeb = tmp_aeb;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!aeb) {\n\t\t\t\tubi_err(ubi, \"PEB %i is in EBA but not in used list\", pnum);\n\t\t\t\tgoto fail_bad;\n\t\t\t}\n\n\t\t\taeb->lnum = j;\n\n\t\t\tif (av->highest_lnum <= aeb->lnum)\n\t\t\t\tav->highest_lnum = aeb->lnum;\n\n\t\t\tassign_aeb_to_av(ai, aeb, av);\n\n\t\t\tdbg_bld(\"inserting PEB:%i (LEB %i) to vol %i\",\n\t\t\t\taeb->pnum, aeb->lnum, av->vol_id);\n\t\t}\n\t}\n\n\tret = scan_pool(ubi, ai, fmpl->pebs, pool_size, &max_sqnum, &free);\n\tif (ret)\n\t\tgoto fail;\n\n\tret = scan_pool(ubi, ai, fmpl_wl->pebs, wl_pool_size, &max_sqnum, &free);\n\tif (ret)\n\t\tgoto fail;\n\n\tif (max_sqnum > ai->max_sqnum)\n\t\tai->max_sqnum = max_sqnum;\n\n\tlist_for_each_entry_safe(tmp_aeb, _tmp_aeb, &free, u.list)\n\t\tlist_move_tail(&tmp_aeb->u.list, &ai->free);\n\n\tlist_for_each_entry_safe(tmp_aeb, _tmp_aeb, &used, u.list)\n\t\tlist_move_tail(&tmp_aeb->u.list, &ai->erase);\n\n\tubi_assert(list_empty(&free));\n\n\t \n\tif (WARN_ON(count_fastmap_pebs(ai) != ubi->peb_count -\n\t\t    ai->bad_peb_count - fm->used_blocks))\n\t\tgoto fail_bad;\n\n\treturn 0;\n\nfail_bad:\n\tret = UBI_BAD_FASTMAP;\nfail:\n\tlist_for_each_entry_safe(tmp_aeb, _tmp_aeb, &used, u.list) {\n\t\tlist_del(&tmp_aeb->u.list);\n\t\tubi_free_aeb(ai, tmp_aeb);\n\t}\n\tlist_for_each_entry_safe(tmp_aeb, _tmp_aeb, &free, u.list) {\n\t\tlist_del(&tmp_aeb->u.list);\n\t\tubi_free_aeb(ai, tmp_aeb);\n\t}\n\n\treturn ret;\n}\n\n \nstatic int find_fm_anchor(struct ubi_attach_info *ai)\n{\n\tint ret = -1;\n\tstruct ubi_ainf_peb *aeb;\n\tunsigned long long max_sqnum = 0;\n\n\tlist_for_each_entry(aeb, &ai->fastmap, u.list) {\n\t\tif (aeb->vol_id == UBI_FM_SB_VOLUME_ID && aeb->sqnum > max_sqnum) {\n\t\t\tmax_sqnum = aeb->sqnum;\n\t\t\tret = aeb->pnum;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic struct ubi_ainf_peb *clone_aeb(struct ubi_attach_info *ai,\n\t\t\t\t      struct ubi_ainf_peb *old)\n{\n\tstruct ubi_ainf_peb *new;\n\n\tnew = ubi_alloc_aeb(ai, old->pnum, old->ec);\n\tif (!new)\n\t\treturn NULL;\n\n\tnew->vol_id = old->vol_id;\n\tnew->sqnum = old->sqnum;\n\tnew->lnum = old->lnum;\n\tnew->scrub = old->scrub;\n\tnew->copy_flag = old->copy_flag;\n\n\treturn new;\n}\n\n \nint ubi_scan_fastmap(struct ubi_device *ubi, struct ubi_attach_info *ai,\n\t\t     struct ubi_attach_info *scan_ai)\n{\n\tstruct ubi_fm_sb *fmsb, *fmsb2;\n\tstruct ubi_vid_io_buf *vb;\n\tstruct ubi_vid_hdr *vh;\n\tstruct ubi_ec_hdr *ech;\n\tstruct ubi_fastmap_layout *fm;\n\tstruct ubi_ainf_peb *aeb;\n\tint i, used_blocks, pnum, fm_anchor, ret = 0;\n\tsize_t fm_size;\n\t__be32 crc, tmp_crc;\n\tunsigned long long sqnum = 0;\n\n\tfm_anchor = find_fm_anchor(scan_ai);\n\tif (fm_anchor < 0)\n\t\treturn UBI_NO_FASTMAP;\n\n\t \n\tlist_for_each_entry(aeb, &scan_ai->fastmap, u.list) {\n\t\tstruct ubi_ainf_peb *new;\n\n\t\tnew = clone_aeb(ai, aeb);\n\t\tif (!new)\n\t\t\treturn -ENOMEM;\n\n\t\tlist_add(&new->u.list, &ai->fastmap);\n\t}\n\n\tdown_write(&ubi->fm_protect);\n\tmemset(ubi->fm_buf, 0, ubi->fm_size);\n\n\tfmsb = kmalloc(sizeof(*fmsb), GFP_KERNEL);\n\tif (!fmsb) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tfm = kzalloc(sizeof(*fm), GFP_KERNEL);\n\tif (!fm) {\n\t\tret = -ENOMEM;\n\t\tkfree(fmsb);\n\t\tgoto out;\n\t}\n\n\tret = ubi_io_read_data(ubi, fmsb, fm_anchor, 0, sizeof(*fmsb));\n\tif (ret && ret != UBI_IO_BITFLIPS)\n\t\tgoto free_fm_sb;\n\telse if (ret == UBI_IO_BITFLIPS)\n\t\tfm->to_be_tortured[0] = 1;\n\n\tif (be32_to_cpu(fmsb->magic) != UBI_FM_SB_MAGIC) {\n\t\tubi_err(ubi, \"bad super block magic: 0x%x, expected: 0x%x\",\n\t\t\tbe32_to_cpu(fmsb->magic), UBI_FM_SB_MAGIC);\n\t\tret = UBI_BAD_FASTMAP;\n\t\tgoto free_fm_sb;\n\t}\n\n\tif (fmsb->version != UBI_FM_FMT_VERSION) {\n\t\tubi_err(ubi, \"bad fastmap version: %i, expected: %i\",\n\t\t\tfmsb->version, UBI_FM_FMT_VERSION);\n\t\tret = UBI_BAD_FASTMAP;\n\t\tgoto free_fm_sb;\n\t}\n\n\tused_blocks = be32_to_cpu(fmsb->used_blocks);\n\tif (used_blocks > UBI_FM_MAX_BLOCKS || used_blocks < 1) {\n\t\tubi_err(ubi, \"number of fastmap blocks is invalid: %i\",\n\t\t\tused_blocks);\n\t\tret = UBI_BAD_FASTMAP;\n\t\tgoto free_fm_sb;\n\t}\n\n\tfm_size = ubi->leb_size * used_blocks;\n\tif (fm_size != ubi->fm_size) {\n\t\tubi_err(ubi, \"bad fastmap size: %zi, expected: %zi\",\n\t\t\tfm_size, ubi->fm_size);\n\t\tret = UBI_BAD_FASTMAP;\n\t\tgoto free_fm_sb;\n\t}\n\n\tech = kzalloc(ubi->ec_hdr_alsize, GFP_KERNEL);\n\tif (!ech) {\n\t\tret = -ENOMEM;\n\t\tgoto free_fm_sb;\n\t}\n\n\tvb = ubi_alloc_vid_buf(ubi, GFP_KERNEL);\n\tif (!vb) {\n\t\tret = -ENOMEM;\n\t\tgoto free_hdr;\n\t}\n\n\tvh = ubi_get_vid_hdr(vb);\n\n\tfor (i = 0; i < used_blocks; i++) {\n\t\tint image_seq;\n\n\t\tpnum = be32_to_cpu(fmsb->block_loc[i]);\n\n\t\tif (ubi_io_is_bad(ubi, pnum)) {\n\t\t\tret = UBI_BAD_FASTMAP;\n\t\t\tgoto free_hdr;\n\t\t}\n\n\t\tif (i == 0 && pnum != fm_anchor) {\n\t\t\tubi_err(ubi, \"Fastmap anchor PEB mismatch: PEB: %i vs. %i\",\n\t\t\t\tpnum, fm_anchor);\n\t\t\tret = UBI_BAD_FASTMAP;\n\t\t\tgoto free_hdr;\n\t\t}\n\n\t\tret = ubi_io_read_ec_hdr(ubi, pnum, ech, 0);\n\t\tif (ret && ret != UBI_IO_BITFLIPS) {\n\t\t\tubi_err(ubi, \"unable to read fastmap block# %i EC (PEB: %i)\",\n\t\t\t\ti, pnum);\n\t\t\tif (ret > 0)\n\t\t\t\tret = UBI_BAD_FASTMAP;\n\t\t\tgoto free_hdr;\n\t\t} else if (ret == UBI_IO_BITFLIPS)\n\t\t\tfm->to_be_tortured[i] = 1;\n\n\t\timage_seq = be32_to_cpu(ech->image_seq);\n\t\tif (!ubi->image_seq)\n\t\t\tubi->image_seq = image_seq;\n\n\t\t \n\t\tif (image_seq && (image_seq != ubi->image_seq)) {\n\t\t\tubi_err(ubi, \"wrong image seq:%d instead of %d\",\n\t\t\t\tbe32_to_cpu(ech->image_seq), ubi->image_seq);\n\t\t\tret = UBI_BAD_FASTMAP;\n\t\t\tgoto free_hdr;\n\t\t}\n\n\t\tret = ubi_io_read_vid_hdr(ubi, pnum, vb, 0);\n\t\tif (ret && ret != UBI_IO_BITFLIPS) {\n\t\t\tubi_err(ubi, \"unable to read fastmap block# %i (PEB: %i)\",\n\t\t\t\ti, pnum);\n\t\t\tgoto free_hdr;\n\t\t}\n\n\t\tif (i == 0) {\n\t\t\tif (be32_to_cpu(vh->vol_id) != UBI_FM_SB_VOLUME_ID) {\n\t\t\t\tubi_err(ubi, \"bad fastmap anchor vol_id: 0x%x, expected: 0x%x\",\n\t\t\t\t\tbe32_to_cpu(vh->vol_id),\n\t\t\t\t\tUBI_FM_SB_VOLUME_ID);\n\t\t\t\tret = UBI_BAD_FASTMAP;\n\t\t\t\tgoto free_hdr;\n\t\t\t}\n\t\t} else {\n\t\t\tif (be32_to_cpu(vh->vol_id) != UBI_FM_DATA_VOLUME_ID) {\n\t\t\t\tubi_err(ubi, \"bad fastmap data vol_id: 0x%x, expected: 0x%x\",\n\t\t\t\t\tbe32_to_cpu(vh->vol_id),\n\t\t\t\t\tUBI_FM_DATA_VOLUME_ID);\n\t\t\t\tret = UBI_BAD_FASTMAP;\n\t\t\t\tgoto free_hdr;\n\t\t\t}\n\t\t}\n\n\t\tif (sqnum < be64_to_cpu(vh->sqnum))\n\t\t\tsqnum = be64_to_cpu(vh->sqnum);\n\n\t\tret = ubi_io_read_data(ubi, ubi->fm_buf + (ubi->leb_size * i),\n\t\t\t\t       pnum, 0, ubi->leb_size);\n\t\tif (ret && ret != UBI_IO_BITFLIPS) {\n\t\t\tubi_err(ubi, \"unable to read fastmap block# %i (PEB: %i, \"\n\t\t\t\t\"err: %i)\", i, pnum, ret);\n\t\t\tgoto free_hdr;\n\t\t}\n\t}\n\n\tkfree(fmsb);\n\tfmsb = NULL;\n\n\tfmsb2 = (struct ubi_fm_sb *)(ubi->fm_buf);\n\ttmp_crc = be32_to_cpu(fmsb2->data_crc);\n\tfmsb2->data_crc = 0;\n\tcrc = crc32(UBI_CRC32_INIT, ubi->fm_buf, fm_size);\n\tif (crc != tmp_crc) {\n\t\tubi_err(ubi, \"fastmap data CRC is invalid\");\n\t\tubi_err(ubi, \"CRC should be: 0x%x, calc: 0x%x\",\n\t\t\ttmp_crc, crc);\n\t\tret = UBI_BAD_FASTMAP;\n\t\tgoto free_hdr;\n\t}\n\n\tfmsb2->sqnum = sqnum;\n\n\tfm->used_blocks = used_blocks;\n\n\tret = ubi_attach_fastmap(ubi, ai, fm);\n\tif (ret) {\n\t\tif (ret > 0)\n\t\t\tret = UBI_BAD_FASTMAP;\n\t\tgoto free_hdr;\n\t}\n\n\tfor (i = 0; i < used_blocks; i++) {\n\t\tstruct ubi_wl_entry *e;\n\n\t\te = kmem_cache_alloc(ubi_wl_entry_slab, GFP_KERNEL);\n\t\tif (!e) {\n\t\t\twhile (i--)\n\t\t\t\tkmem_cache_free(ubi_wl_entry_slab, fm->e[i]);\n\n\t\t\tret = -ENOMEM;\n\t\t\tgoto free_hdr;\n\t\t}\n\n\t\te->pnum = be32_to_cpu(fmsb2->block_loc[i]);\n\t\te->ec = be32_to_cpu(fmsb2->block_ec[i]);\n\t\tfm->e[i] = e;\n\t}\n\n\tubi->fm = fm;\n\tubi->fm_pool.max_size = ubi->fm->max_pool_size;\n\tubi->fm_wl_pool.max_size = ubi->fm->max_wl_pool_size;\n\tubi_msg(ubi, \"attached by fastmap\");\n\tubi_msg(ubi, \"fastmap pool size: %d\", ubi->fm_pool.max_size);\n\tubi_msg(ubi, \"fastmap WL pool size: %d\",\n\t\tubi->fm_wl_pool.max_size);\n\tubi->fm_disabled = 0;\n\tubi->fast_attach = 1;\n\n\tubi_free_vid_buf(vb);\n\tkfree(ech);\nout:\n\tup_write(&ubi->fm_protect);\n\tif (ret == UBI_BAD_FASTMAP)\n\t\tubi_err(ubi, \"Attach by fastmap failed, doing a full scan!\");\n\treturn ret;\n\nfree_hdr:\n\tubi_free_vid_buf(vb);\n\tkfree(ech);\nfree_fm_sb:\n\tkfree(fmsb);\n\tkfree(fm);\n\tgoto out;\n}\n\nint ubi_fastmap_init_checkmap(struct ubi_volume *vol, int leb_count)\n{\n\tstruct ubi_device *ubi = vol->ubi;\n\n\tif (!ubi->fast_attach)\n\t\treturn 0;\n\n\tvol->checkmap = bitmap_zalloc(leb_count, GFP_KERNEL);\n\tif (!vol->checkmap)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nvoid ubi_fastmap_destroy_checkmap(struct ubi_volume *vol)\n{\n\tbitmap_free(vol->checkmap);\n}\n\n \nstatic int ubi_write_fastmap(struct ubi_device *ubi,\n\t\t\t     struct ubi_fastmap_layout *new_fm)\n{\n\tsize_t fm_pos = 0;\n\tvoid *fm_raw;\n\tstruct ubi_fm_sb *fmsb;\n\tstruct ubi_fm_hdr *fmh;\n\tstruct ubi_fm_scan_pool *fmpl, *fmpl_wl;\n\tstruct ubi_fm_ec *fec;\n\tstruct ubi_fm_volhdr *fvh;\n\tstruct ubi_fm_eba *feba;\n\tstruct ubi_wl_entry *wl_e;\n\tstruct ubi_volume *vol;\n\tstruct ubi_vid_io_buf *avbuf, *dvbuf;\n\tstruct ubi_vid_hdr *avhdr, *dvhdr;\n\tstruct ubi_work *ubi_wrk;\n\tstruct rb_node *tmp_rb;\n\tint ret, i, j, free_peb_count, used_peb_count, vol_count;\n\tint scrub_peb_count, erase_peb_count;\n\tunsigned long *seen_pebs;\n\n\tfm_raw = ubi->fm_buf;\n\tmemset(ubi->fm_buf, 0, ubi->fm_size);\n\n\tavbuf = new_fm_vbuf(ubi, UBI_FM_SB_VOLUME_ID);\n\tif (!avbuf) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tdvbuf = new_fm_vbuf(ubi, UBI_FM_DATA_VOLUME_ID);\n\tif (!dvbuf) {\n\t\tret = -ENOMEM;\n\t\tgoto out_free_avbuf;\n\t}\n\n\tavhdr = ubi_get_vid_hdr(avbuf);\n\tdvhdr = ubi_get_vid_hdr(dvbuf);\n\n\tseen_pebs = init_seen(ubi);\n\tif (IS_ERR(seen_pebs)) {\n\t\tret = PTR_ERR(seen_pebs);\n\t\tgoto out_free_dvbuf;\n\t}\n\n\tspin_lock(&ubi->volumes_lock);\n\tspin_lock(&ubi->wl_lock);\n\n\tfmsb = (struct ubi_fm_sb *)fm_raw;\n\tfm_pos += sizeof(*fmsb);\n\tubi_assert(fm_pos <= ubi->fm_size);\n\n\tfmh = (struct ubi_fm_hdr *)(fm_raw + fm_pos);\n\tfm_pos += sizeof(*fmh);\n\tubi_assert(fm_pos <= ubi->fm_size);\n\n\tfmsb->magic = cpu_to_be32(UBI_FM_SB_MAGIC);\n\tfmsb->version = UBI_FM_FMT_VERSION;\n\tfmsb->used_blocks = cpu_to_be32(new_fm->used_blocks);\n\t \n\tfmsb->sqnum = 0;\n\n\tfmh->magic = cpu_to_be32(UBI_FM_HDR_MAGIC);\n\tfree_peb_count = 0;\n\tused_peb_count = 0;\n\tscrub_peb_count = 0;\n\terase_peb_count = 0;\n\tvol_count = 0;\n\n\tfmpl = (struct ubi_fm_scan_pool *)(fm_raw + fm_pos);\n\tfm_pos += sizeof(*fmpl);\n\tfmpl->magic = cpu_to_be32(UBI_FM_POOL_MAGIC);\n\tfmpl->size = cpu_to_be16(ubi->fm_pool.size);\n\tfmpl->max_size = cpu_to_be16(ubi->fm_pool.max_size);\n\n\tfor (i = 0; i < ubi->fm_pool.size; i++) {\n\t\tfmpl->pebs[i] = cpu_to_be32(ubi->fm_pool.pebs[i]);\n\t\tset_seen(ubi, ubi->fm_pool.pebs[i], seen_pebs);\n\t}\n\n\tfmpl_wl = (struct ubi_fm_scan_pool *)(fm_raw + fm_pos);\n\tfm_pos += sizeof(*fmpl_wl);\n\tfmpl_wl->magic = cpu_to_be32(UBI_FM_POOL_MAGIC);\n\tfmpl_wl->size = cpu_to_be16(ubi->fm_wl_pool.size);\n\tfmpl_wl->max_size = cpu_to_be16(ubi->fm_wl_pool.max_size);\n\n\tfor (i = 0; i < ubi->fm_wl_pool.size; i++) {\n\t\tfmpl_wl->pebs[i] = cpu_to_be32(ubi->fm_wl_pool.pebs[i]);\n\t\tset_seen(ubi, ubi->fm_wl_pool.pebs[i], seen_pebs);\n\t}\n\n\tubi_for_each_free_peb(ubi, wl_e, tmp_rb) {\n\t\tfec = (struct ubi_fm_ec *)(fm_raw + fm_pos);\n\n\t\tfec->pnum = cpu_to_be32(wl_e->pnum);\n\t\tset_seen(ubi, wl_e->pnum, seen_pebs);\n\t\tfec->ec = cpu_to_be32(wl_e->ec);\n\n\t\tfree_peb_count++;\n\t\tfm_pos += sizeof(*fec);\n\t\tubi_assert(fm_pos <= ubi->fm_size);\n\t}\n\tfmh->free_peb_count = cpu_to_be32(free_peb_count);\n\n\tubi_for_each_used_peb(ubi, wl_e, tmp_rb) {\n\t\tfec = (struct ubi_fm_ec *)(fm_raw + fm_pos);\n\n\t\tfec->pnum = cpu_to_be32(wl_e->pnum);\n\t\tset_seen(ubi, wl_e->pnum, seen_pebs);\n\t\tfec->ec = cpu_to_be32(wl_e->ec);\n\n\t\tused_peb_count++;\n\t\tfm_pos += sizeof(*fec);\n\t\tubi_assert(fm_pos <= ubi->fm_size);\n\t}\n\n\tubi_for_each_protected_peb(ubi, i, wl_e) {\n\t\tfec = (struct ubi_fm_ec *)(fm_raw + fm_pos);\n\n\t\tfec->pnum = cpu_to_be32(wl_e->pnum);\n\t\tset_seen(ubi, wl_e->pnum, seen_pebs);\n\t\tfec->ec = cpu_to_be32(wl_e->ec);\n\n\t\tused_peb_count++;\n\t\tfm_pos += sizeof(*fec);\n\t\tubi_assert(fm_pos <= ubi->fm_size);\n\t}\n\tfmh->used_peb_count = cpu_to_be32(used_peb_count);\n\n\tubi_for_each_scrub_peb(ubi, wl_e, tmp_rb) {\n\t\tfec = (struct ubi_fm_ec *)(fm_raw + fm_pos);\n\n\t\tfec->pnum = cpu_to_be32(wl_e->pnum);\n\t\tset_seen(ubi, wl_e->pnum, seen_pebs);\n\t\tfec->ec = cpu_to_be32(wl_e->ec);\n\n\t\tscrub_peb_count++;\n\t\tfm_pos += sizeof(*fec);\n\t\tubi_assert(fm_pos <= ubi->fm_size);\n\t}\n\tfmh->scrub_peb_count = cpu_to_be32(scrub_peb_count);\n\n\n\tlist_for_each_entry(ubi_wrk, &ubi->works, list) {\n\t\tif (ubi_is_erase_work(ubi_wrk)) {\n\t\t\twl_e = ubi_wrk->e;\n\t\t\tubi_assert(wl_e);\n\n\t\t\tfec = (struct ubi_fm_ec *)(fm_raw + fm_pos);\n\n\t\t\tfec->pnum = cpu_to_be32(wl_e->pnum);\n\t\t\tset_seen(ubi, wl_e->pnum, seen_pebs);\n\t\t\tfec->ec = cpu_to_be32(wl_e->ec);\n\n\t\t\terase_peb_count++;\n\t\t\tfm_pos += sizeof(*fec);\n\t\t\tubi_assert(fm_pos <= ubi->fm_size);\n\t\t}\n\t}\n\tfmh->erase_peb_count = cpu_to_be32(erase_peb_count);\n\n\tfor (i = 0; i < UBI_MAX_VOLUMES + UBI_INT_VOL_COUNT; i++) {\n\t\tvol = ubi->volumes[i];\n\n\t\tif (!vol)\n\t\t\tcontinue;\n\n\t\tvol_count++;\n\n\t\tfvh = (struct ubi_fm_volhdr *)(fm_raw + fm_pos);\n\t\tfm_pos += sizeof(*fvh);\n\t\tubi_assert(fm_pos <= ubi->fm_size);\n\n\t\tfvh->magic = cpu_to_be32(UBI_FM_VHDR_MAGIC);\n\t\tfvh->vol_id = cpu_to_be32(vol->vol_id);\n\t\tfvh->vol_type = vol->vol_type;\n\t\tfvh->used_ebs = cpu_to_be32(vol->used_ebs);\n\t\tfvh->data_pad = cpu_to_be32(vol->data_pad);\n\t\tfvh->last_eb_bytes = cpu_to_be32(vol->last_eb_bytes);\n\n\t\tubi_assert(vol->vol_type == UBI_DYNAMIC_VOLUME ||\n\t\t\tvol->vol_type == UBI_STATIC_VOLUME);\n\n\t\tfeba = (struct ubi_fm_eba *)(fm_raw + fm_pos);\n\t\tfm_pos += sizeof(*feba) + (sizeof(__be32) * vol->reserved_pebs);\n\t\tubi_assert(fm_pos <= ubi->fm_size);\n\n\t\tfor (j = 0; j < vol->reserved_pebs; j++) {\n\t\t\tstruct ubi_eba_leb_desc ldesc;\n\n\t\t\tubi_eba_get_ldesc(vol, j, &ldesc);\n\t\t\tfeba->pnum[j] = cpu_to_be32(ldesc.pnum);\n\t\t}\n\n\t\tfeba->reserved_pebs = cpu_to_be32(j);\n\t\tfeba->magic = cpu_to_be32(UBI_FM_EBA_MAGIC);\n\t}\n\tfmh->vol_count = cpu_to_be32(vol_count);\n\tfmh->bad_peb_count = cpu_to_be32(ubi->bad_peb_count);\n\n\tavhdr->sqnum = cpu_to_be64(ubi_next_sqnum(ubi));\n\tavhdr->lnum = 0;\n\n\tspin_unlock(&ubi->wl_lock);\n\tspin_unlock(&ubi->volumes_lock);\n\n\tdbg_bld(\"writing fastmap SB to PEB %i\", new_fm->e[0]->pnum);\n\tret = ubi_io_write_vid_hdr(ubi, new_fm->e[0]->pnum, avbuf);\n\tif (ret) {\n\t\tubi_err(ubi, \"unable to write vid_hdr to fastmap SB!\");\n\t\tgoto out_free_seen;\n\t}\n\n\tfor (i = 0; i < new_fm->used_blocks; i++) {\n\t\tfmsb->block_loc[i] = cpu_to_be32(new_fm->e[i]->pnum);\n\t\tset_seen(ubi, new_fm->e[i]->pnum, seen_pebs);\n\t\tfmsb->block_ec[i] = cpu_to_be32(new_fm->e[i]->ec);\n\t}\n\n\tfmsb->data_crc = 0;\n\tfmsb->data_crc = cpu_to_be32(crc32(UBI_CRC32_INIT, fm_raw,\n\t\t\t\t\t   ubi->fm_size));\n\n\tfor (i = 1; i < new_fm->used_blocks; i++) {\n\t\tdvhdr->sqnum = cpu_to_be64(ubi_next_sqnum(ubi));\n\t\tdvhdr->lnum = cpu_to_be32(i);\n\t\tdbg_bld(\"writing fastmap data to PEB %i sqnum %llu\",\n\t\t\tnew_fm->e[i]->pnum, be64_to_cpu(dvhdr->sqnum));\n\t\tret = ubi_io_write_vid_hdr(ubi, new_fm->e[i]->pnum, dvbuf);\n\t\tif (ret) {\n\t\t\tubi_err(ubi, \"unable to write vid_hdr to PEB %i!\",\n\t\t\t\tnew_fm->e[i]->pnum);\n\t\t\tgoto out_free_seen;\n\t\t}\n\t}\n\n\tfor (i = 0; i < new_fm->used_blocks; i++) {\n\t\tret = ubi_io_write_data(ubi, fm_raw + (i * ubi->leb_size),\n\t\t\t\t\tnew_fm->e[i]->pnum, 0, ubi->leb_size);\n\t\tif (ret) {\n\t\t\tubi_err(ubi, \"unable to write fastmap to PEB %i!\",\n\t\t\t\tnew_fm->e[i]->pnum);\n\t\t\tgoto out_free_seen;\n\t\t}\n\t}\n\n\tubi_assert(new_fm);\n\tubi->fm = new_fm;\n\n\tret = self_check_seen(ubi, seen_pebs);\n\tdbg_bld(\"fastmap written!\");\n\nout_free_seen:\n\tfree_seen(seen_pebs);\nout_free_dvbuf:\n\tubi_free_vid_buf(dvbuf);\nout_free_avbuf:\n\tubi_free_vid_buf(avbuf);\n\nout:\n\treturn ret;\n}\n\n \nstatic int erase_block(struct ubi_device *ubi, int pnum)\n{\n\tint ret;\n\tstruct ubi_ec_hdr *ec_hdr;\n\tlong long ec;\n\n\tec_hdr = kzalloc(ubi->ec_hdr_alsize, GFP_KERNEL);\n\tif (!ec_hdr)\n\t\treturn -ENOMEM;\n\n\tret = ubi_io_read_ec_hdr(ubi, pnum, ec_hdr, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\telse if (ret && ret != UBI_IO_BITFLIPS) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tret = ubi_io_sync_erase(ubi, pnum, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tec = be64_to_cpu(ec_hdr->ec);\n\tec += ret;\n\tif (ec > UBI_MAX_ERASECOUNTER) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tec_hdr->ec = cpu_to_be64(ec);\n\tret = ubi_io_write_ec_hdr(ubi, pnum, ec_hdr);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = ec;\nout:\n\tkfree(ec_hdr);\n\treturn ret;\n}\n\n \nstatic int invalidate_fastmap(struct ubi_device *ubi)\n{\n\tint ret;\n\tstruct ubi_fastmap_layout *fm;\n\tstruct ubi_wl_entry *e;\n\tstruct ubi_vid_io_buf *vb = NULL;\n\tstruct ubi_vid_hdr *vh;\n\n\tif (!ubi->fm)\n\t\treturn 0;\n\n\tubi->fm = NULL;\n\n\tret = -ENOMEM;\n\tfm = kzalloc(sizeof(*fm), GFP_KERNEL);\n\tif (!fm)\n\t\tgoto out;\n\n\tvb = new_fm_vbuf(ubi, UBI_FM_SB_VOLUME_ID);\n\tif (!vb)\n\t\tgoto out_free_fm;\n\n\tvh = ubi_get_vid_hdr(vb);\n\n\tret = -ENOSPC;\n\te = ubi_wl_get_fm_peb(ubi, 1);\n\tif (!e)\n\t\tgoto out_free_fm;\n\n\t \n\tvh->sqnum = cpu_to_be64(ubi_next_sqnum(ubi));\n\tret = ubi_io_write_vid_hdr(ubi, e->pnum, vb);\n\tif (ret < 0) {\n\t\tubi_wl_put_fm_peb(ubi, e, 0, 0);\n\t\tgoto out_free_fm;\n\t}\n\n\tfm->used_blocks = 1;\n\tfm->e[0] = e;\n\n\tubi->fm = fm;\n\nout:\n\tubi_free_vid_buf(vb);\n\treturn ret;\n\nout_free_fm:\n\tkfree(fm);\n\tgoto out;\n}\n\n \nstatic void return_fm_pebs(struct ubi_device *ubi,\n\t\t\t   struct ubi_fastmap_layout *fm)\n{\n\tint i;\n\n\tif (!fm)\n\t\treturn;\n\n\tfor (i = 0; i < fm->used_blocks; i++) {\n\t\tif (fm->e[i]) {\n\t\t\tubi_wl_put_fm_peb(ubi, fm->e[i], i,\n\t\t\t\t\t  fm->to_be_tortured[i]);\n\t\t\tfm->e[i] = NULL;\n\t\t}\n\t}\n}\n\n \nint ubi_update_fastmap(struct ubi_device *ubi)\n{\n\tint ret, i, j;\n\tstruct ubi_fastmap_layout *new_fm, *old_fm;\n\tstruct ubi_wl_entry *tmp_e;\n\n\tdown_write(&ubi->fm_protect);\n\tdown_write(&ubi->work_sem);\n\tdown_write(&ubi->fm_eba_sem);\n\n\tubi_refill_pools(ubi);\n\n\tif (ubi->ro_mode || ubi->fm_disabled) {\n\t\tup_write(&ubi->fm_eba_sem);\n\t\tup_write(&ubi->work_sem);\n\t\tup_write(&ubi->fm_protect);\n\t\treturn 0;\n\t}\n\n\tnew_fm = kzalloc(sizeof(*new_fm), GFP_KERNEL);\n\tif (!new_fm) {\n\t\tup_write(&ubi->fm_eba_sem);\n\t\tup_write(&ubi->work_sem);\n\t\tup_write(&ubi->fm_protect);\n\t\treturn -ENOMEM;\n\t}\n\n\tnew_fm->used_blocks = ubi->fm_size / ubi->leb_size;\n\told_fm = ubi->fm;\n\tubi->fm = NULL;\n\n\tif (new_fm->used_blocks > UBI_FM_MAX_BLOCKS) {\n\t\tubi_err(ubi, \"fastmap too large\");\n\t\tret = -ENOSPC;\n\t\tgoto err;\n\t}\n\n\tfor (i = 1; i < new_fm->used_blocks; i++) {\n\t\tspin_lock(&ubi->wl_lock);\n\t\ttmp_e = ubi_wl_get_fm_peb(ubi, 0);\n\t\tspin_unlock(&ubi->wl_lock);\n\n\t\tif (!tmp_e) {\n\t\t\tif (old_fm && old_fm->e[i]) {\n\t\t\t\tret = erase_block(ubi, old_fm->e[i]->pnum);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tubi_err(ubi, \"could not erase old fastmap PEB\");\n\n\t\t\t\t\tfor (j = 1; j < i; j++) {\n\t\t\t\t\t\tubi_wl_put_fm_peb(ubi, new_fm->e[j],\n\t\t\t\t\t\t\t\t  j, 0);\n\t\t\t\t\t\tnew_fm->e[j] = NULL;\n\t\t\t\t\t}\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t\tnew_fm->e[i] = old_fm->e[i];\n\t\t\t\told_fm->e[i] = NULL;\n\t\t\t} else {\n\t\t\t\tubi_err(ubi, \"could not get any free erase block\");\n\n\t\t\t\tfor (j = 1; j < i; j++) {\n\t\t\t\t\tubi_wl_put_fm_peb(ubi, new_fm->e[j], j, 0);\n\t\t\t\t\tnew_fm->e[j] = NULL;\n\t\t\t\t}\n\n\t\t\t\tret = -ENOSPC;\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t} else {\n\t\t\tnew_fm->e[i] = tmp_e;\n\n\t\t\tif (old_fm && old_fm->e[i]) {\n\t\t\t\tubi_wl_put_fm_peb(ubi, old_fm->e[i], i,\n\t\t\t\t\t\t  old_fm->to_be_tortured[i]);\n\t\t\t\told_fm->e[i] = NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tif (old_fm && new_fm->used_blocks < old_fm->used_blocks) {\n\t\tfor (i = new_fm->used_blocks; i < old_fm->used_blocks; i++) {\n\t\t\tubi_wl_put_fm_peb(ubi, old_fm->e[i], i,\n\t\t\t\t\t  old_fm->to_be_tortured[i]);\n\t\t\told_fm->e[i] = NULL;\n\t\t}\n\t}\n\n\tspin_lock(&ubi->wl_lock);\n\ttmp_e = ubi->fm_anchor;\n\tubi->fm_anchor = NULL;\n\tspin_unlock(&ubi->wl_lock);\n\n\tif (old_fm) {\n\t\t \n\t\tif (!tmp_e) {\n\t\t\tret = erase_block(ubi, old_fm->e[0]->pnum);\n\t\t\tif (ret < 0) {\n\t\t\t\tubi_err(ubi, \"could not erase old anchor PEB\");\n\n\t\t\t\tfor (i = 1; i < new_fm->used_blocks; i++) {\n\t\t\t\t\tubi_wl_put_fm_peb(ubi, new_fm->e[i],\n\t\t\t\t\t\t\t  i, 0);\n\t\t\t\t\tnew_fm->e[i] = NULL;\n\t\t\t\t}\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\tnew_fm->e[0] = old_fm->e[0];\n\t\t\tnew_fm->e[0]->ec = ret;\n\t\t\told_fm->e[0] = NULL;\n\t\t} else {\n\t\t\t \n\t\t\tubi_wl_put_fm_peb(ubi, old_fm->e[0], 0,\n\t\t\t\t\t  old_fm->to_be_tortured[0]);\n\t\t\tnew_fm->e[0] = tmp_e;\n\t\t\told_fm->e[0] = NULL;\n\t\t}\n\t} else {\n\t\tif (!tmp_e) {\n\t\t\tubi_err(ubi, \"could not find any anchor PEB\");\n\n\t\t\tfor (i = 1; i < new_fm->used_blocks; i++) {\n\t\t\t\tubi_wl_put_fm_peb(ubi, new_fm->e[i], i, 0);\n\t\t\t\tnew_fm->e[i] = NULL;\n\t\t\t}\n\n\t\t\tret = -ENOSPC;\n\t\t\tgoto err;\n\t\t}\n\t\tnew_fm->e[0] = tmp_e;\n\t}\n\n\tret = ubi_write_fastmap(ubi, new_fm);\n\n\tif (ret)\n\t\tgoto err;\n\nout_unlock:\n\tup_write(&ubi->fm_eba_sem);\n\tup_write(&ubi->work_sem);\n\tup_write(&ubi->fm_protect);\n\tkfree(old_fm);\n\n\tubi_ensure_anchor_pebs(ubi);\n\n\treturn ret;\n\nerr:\n\tubi_warn(ubi, \"Unable to write new fastmap, err=%i\", ret);\n\n\tret = invalidate_fastmap(ubi);\n\tif (ret < 0) {\n\t\tubi_err(ubi, \"Unable to invalidate current fastmap!\");\n\t\tubi_ro_mode(ubi);\n\t} else {\n\t\treturn_fm_pebs(ubi, old_fm);\n\t\treturn_fm_pebs(ubi, new_fm);\n\t\tret = 0;\n\t}\n\n\tkfree(new_fm);\n\tgoto out_unlock;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}