{
  "module_name": "vmt.c",
  "hash_id": "2b320f2ee6b6e96d689b010a8729836b1268720a2a30c1b450c91eca483ea0d0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/ubi/vmt.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/err.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include \"ubi.h\"\n\nstatic int self_check_volumes(struct ubi_device *ubi);\n\nstatic ssize_t vol_attribute_show(struct device *dev,\n\t\t\t\t  struct device_attribute *attr, char *buf);\n\n \nstatic struct device_attribute attr_vol_reserved_ebs =\n\t__ATTR(reserved_ebs, S_IRUGO, vol_attribute_show, NULL);\nstatic struct device_attribute attr_vol_type =\n\t__ATTR(type, S_IRUGO, vol_attribute_show, NULL);\nstatic struct device_attribute attr_vol_name =\n\t__ATTR(name, S_IRUGO, vol_attribute_show, NULL);\nstatic struct device_attribute attr_vol_corrupted =\n\t__ATTR(corrupted, S_IRUGO, vol_attribute_show, NULL);\nstatic struct device_attribute attr_vol_alignment =\n\t__ATTR(alignment, S_IRUGO, vol_attribute_show, NULL);\nstatic struct device_attribute attr_vol_usable_eb_size =\n\t__ATTR(usable_eb_size, S_IRUGO, vol_attribute_show, NULL);\nstatic struct device_attribute attr_vol_data_bytes =\n\t__ATTR(data_bytes, S_IRUGO, vol_attribute_show, NULL);\nstatic struct device_attribute attr_vol_upd_marker =\n\t__ATTR(upd_marker, S_IRUGO, vol_attribute_show, NULL);\n\n \nstatic ssize_t vol_attribute_show(struct device *dev,\n\t\t\t\t  struct device_attribute *attr, char *buf)\n{\n\tint ret;\n\tstruct ubi_volume *vol = container_of(dev, struct ubi_volume, dev);\n\tstruct ubi_device *ubi = vol->ubi;\n\n\tspin_lock(&ubi->volumes_lock);\n\tif (!ubi->volumes[vol->vol_id]) {\n\t\tspin_unlock(&ubi->volumes_lock);\n\t\treturn -ENODEV;\n\t}\n\t \n\tvol->ref_count += 1;\n\tspin_unlock(&ubi->volumes_lock);\n\n\tif (attr == &attr_vol_reserved_ebs)\n\t\tret = sprintf(buf, \"%d\\n\", vol->reserved_pebs);\n\telse if (attr == &attr_vol_type) {\n\t\tconst char *tp;\n\n\t\tif (vol->vol_type == UBI_DYNAMIC_VOLUME)\n\t\t\ttp = \"dynamic\";\n\t\telse\n\t\t\ttp = \"static\";\n\t\tret = sprintf(buf, \"%s\\n\", tp);\n\t} else if (attr == &attr_vol_name)\n\t\tret = sprintf(buf, \"%s\\n\", vol->name);\n\telse if (attr == &attr_vol_corrupted)\n\t\tret = sprintf(buf, \"%d\\n\", vol->corrupted);\n\telse if (attr == &attr_vol_alignment)\n\t\tret = sprintf(buf, \"%d\\n\", vol->alignment);\n\telse if (attr == &attr_vol_usable_eb_size)\n\t\tret = sprintf(buf, \"%d\\n\", vol->usable_leb_size);\n\telse if (attr == &attr_vol_data_bytes)\n\t\tret = sprintf(buf, \"%lld\\n\", vol->used_bytes);\n\telse if (attr == &attr_vol_upd_marker)\n\t\tret = sprintf(buf, \"%d\\n\", vol->upd_marker);\n\telse\n\t\t \n\t\tret = -EINVAL;\n\n\t \n\tspin_lock(&ubi->volumes_lock);\n\tvol->ref_count -= 1;\n\tubi_assert(vol->ref_count >= 0);\n\tspin_unlock(&ubi->volumes_lock);\n\treturn ret;\n}\n\nstatic struct attribute *volume_dev_attrs[] = {\n\t&attr_vol_reserved_ebs.attr,\n\t&attr_vol_type.attr,\n\t&attr_vol_name.attr,\n\t&attr_vol_corrupted.attr,\n\t&attr_vol_alignment.attr,\n\t&attr_vol_usable_eb_size.attr,\n\t&attr_vol_data_bytes.attr,\n\t&attr_vol_upd_marker.attr,\n\tNULL\n};\nATTRIBUTE_GROUPS(volume_dev);\n\n \nstatic void vol_release(struct device *dev)\n{\n\tstruct ubi_volume *vol = container_of(dev, struct ubi_volume, dev);\n\n\tubi_eba_replace_table(vol, NULL);\n\tubi_fastmap_destroy_checkmap(vol);\n\tkfree(vol);\n}\n\n \nint ubi_create_volume(struct ubi_device *ubi, struct ubi_mkvol_req *req)\n{\n\tint i, err, vol_id = req->vol_id;\n\tstruct ubi_volume *vol;\n\tstruct ubi_vtbl_record vtbl_rec;\n\tstruct ubi_eba_table *eba_tbl = NULL;\n\n\tif (ubi->ro_mode)\n\t\treturn -EROFS;\n\n\tvol = kzalloc(sizeof(struct ubi_volume), GFP_KERNEL);\n\tif (!vol)\n\t\treturn -ENOMEM;\n\n\tdevice_initialize(&vol->dev);\n\tvol->dev.release = vol_release;\n\tvol->dev.parent = &ubi->dev;\n\tvol->dev.class = &ubi_class;\n\tvol->dev.groups = volume_dev_groups;\n\n\tif (req->flags & UBI_VOL_SKIP_CRC_CHECK_FLG)\n\t\tvol->skip_check = 1;\n\n\tspin_lock(&ubi->volumes_lock);\n\tif (vol_id == UBI_VOL_NUM_AUTO) {\n\t\t \n\t\tdbg_gen(\"search for vacant volume ID\");\n\t\tfor (i = 0; i < ubi->vtbl_slots; i++)\n\t\t\tif (!ubi->volumes[i]) {\n\t\t\t\tvol_id = i;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\tif (vol_id == UBI_VOL_NUM_AUTO) {\n\t\t\tubi_err(ubi, \"out of volume IDs\");\n\t\t\terr = -ENFILE;\n\t\t\tgoto out_unlock;\n\t\t}\n\t\treq->vol_id = vol_id;\n\t}\n\n\tdbg_gen(\"create device %d, volume %d, %llu bytes, type %d, name %s\",\n\t\tubi->ubi_num, vol_id, (unsigned long long)req->bytes,\n\t\t(int)req->vol_type, req->name);\n\n\t \n\terr = -EEXIST;\n\tif (ubi->volumes[vol_id]) {\n\t\tubi_err(ubi, \"volume %d already exists\", vol_id);\n\t\tgoto out_unlock;\n\t}\n\n\t \n\tfor (i = 0; i < ubi->vtbl_slots; i++)\n\t\tif (ubi->volumes[i] &&\n\t\t    ubi->volumes[i]->name_len == req->name_len &&\n\t\t    !strcmp(ubi->volumes[i]->name, req->name)) {\n\t\t\tubi_err(ubi, \"volume \\\"%s\\\" exists (ID %d)\",\n\t\t\t\treq->name, i);\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t \n\tvol->usable_leb_size = ubi->leb_size - ubi->leb_size % req->alignment;\n\tvol->reserved_pebs = div_u64(req->bytes + vol->usable_leb_size - 1,\n\t\t\t\t     vol->usable_leb_size);\n\n\t \n\tif (vol->reserved_pebs > ubi->avail_pebs) {\n\t\tubi_err(ubi, \"not enough PEBs, only %d available\",\n\t\t\tubi->avail_pebs);\n\t\tif (ubi->corr_peb_count)\n\t\t\tubi_err(ubi, \"%d PEBs are corrupted and not used\",\n\t\t\t\tubi->corr_peb_count);\n\t\terr = -ENOSPC;\n\t\tgoto out_unlock;\n\t}\n\tubi->avail_pebs -= vol->reserved_pebs;\n\tubi->rsvd_pebs += vol->reserved_pebs;\n\tspin_unlock(&ubi->volumes_lock);\n\n\tvol->vol_id    = vol_id;\n\tvol->alignment = req->alignment;\n\tvol->data_pad  = ubi->leb_size % vol->alignment;\n\tvol->vol_type  = req->vol_type;\n\tvol->name_len  = req->name_len;\n\tmemcpy(vol->name, req->name, vol->name_len);\n\tvol->ubi = ubi;\n\n\t \n\terr = ubi_wl_flush(ubi, vol_id, UBI_ALL);\n\tif (err)\n\t\tgoto out_acc;\n\n\teba_tbl = ubi_eba_create_table(vol, vol->reserved_pebs);\n\tif (IS_ERR(eba_tbl)) {\n\t\terr = PTR_ERR(eba_tbl);\n\t\tgoto out_acc;\n\t}\n\n\tubi_eba_replace_table(vol, eba_tbl);\n\n\tif (vol->vol_type == UBI_DYNAMIC_VOLUME) {\n\t\tvol->used_ebs = vol->reserved_pebs;\n\t\tvol->last_eb_bytes = vol->usable_leb_size;\n\t\tvol->used_bytes =\n\t\t\t(long long)vol->used_ebs * vol->usable_leb_size;\n\t} else {\n\t\tvol->used_ebs = div_u64_rem(vol->used_bytes,\n\t\t\t\t\t    vol->usable_leb_size,\n\t\t\t\t\t    &vol->last_eb_bytes);\n\t\tif (vol->last_eb_bytes != 0)\n\t\t\tvol->used_ebs += 1;\n\t\telse\n\t\t\tvol->last_eb_bytes = vol->usable_leb_size;\n\t}\n\n\t \n\tspin_lock(&ubi->volumes_lock);\n\tubi->volumes[vol_id] = vol;\n\tubi->vol_count += 1;\n\tspin_unlock(&ubi->volumes_lock);\n\n\t \n\tcdev_init(&vol->cdev, &ubi_vol_cdev_operations);\n\tvol->cdev.owner = THIS_MODULE;\n\n\tvol->dev.devt = MKDEV(MAJOR(ubi->cdev.dev), vol_id + 1);\n\tdev_set_name(&vol->dev, \"%s_%d\", ubi->ubi_name, vol->vol_id);\n\terr = cdev_device_add(&vol->cdev, &vol->dev);\n\tif (err) {\n\t\tubi_err(ubi, \"cannot add device\");\n\t\tgoto out_mapping;\n\t}\n\n\t \n\tmemset(&vtbl_rec, 0, sizeof(struct ubi_vtbl_record));\n\tvtbl_rec.reserved_pebs = cpu_to_be32(vol->reserved_pebs);\n\tvtbl_rec.alignment     = cpu_to_be32(vol->alignment);\n\tvtbl_rec.data_pad      = cpu_to_be32(vol->data_pad);\n\tvtbl_rec.name_len      = cpu_to_be16(vol->name_len);\n\tif (vol->vol_type == UBI_DYNAMIC_VOLUME)\n\t\tvtbl_rec.vol_type = UBI_VID_DYNAMIC;\n\telse\n\t\tvtbl_rec.vol_type = UBI_VID_STATIC;\n\n\tif (vol->skip_check)\n\t\tvtbl_rec.flags |= UBI_VTBL_SKIP_CRC_CHECK_FLG;\n\n\tmemcpy(vtbl_rec.name, vol->name, vol->name_len);\n\n\terr = ubi_change_vtbl_record(ubi, vol_id, &vtbl_rec);\n\tif (err)\n\t\tgoto out_sysfs;\n\n\tubi_volume_notify(ubi, vol, UBI_VOLUME_ADDED);\n\tself_check_volumes(ubi);\n\treturn err;\n\nout_sysfs:\n\t \n\tcdev_device_del(&vol->cdev, &vol->dev);\nout_mapping:\n\tspin_lock(&ubi->volumes_lock);\n\tubi->volumes[vol_id] = NULL;\n\tubi->vol_count -= 1;\n\tspin_unlock(&ubi->volumes_lock);\nout_acc:\n\tspin_lock(&ubi->volumes_lock);\n\tubi->rsvd_pebs -= vol->reserved_pebs;\n\tubi->avail_pebs += vol->reserved_pebs;\nout_unlock:\n\tspin_unlock(&ubi->volumes_lock);\n\tput_device(&vol->dev);\n\tubi_err(ubi, \"cannot create volume %d, error %d\", vol_id, err);\n\treturn err;\n}\n\n \nint ubi_remove_volume(struct ubi_volume_desc *desc, int no_vtbl)\n{\n\tstruct ubi_volume *vol = desc->vol;\n\tstruct ubi_device *ubi = vol->ubi;\n\tint i, err, vol_id = vol->vol_id, reserved_pebs = vol->reserved_pebs;\n\n\tdbg_gen(\"remove device %d, volume %d\", ubi->ubi_num, vol_id);\n\tubi_assert(desc->mode == UBI_EXCLUSIVE);\n\tubi_assert(vol == ubi->volumes[vol_id]);\n\n\tif (ubi->ro_mode)\n\t\treturn -EROFS;\n\n\tspin_lock(&ubi->volumes_lock);\n\tif (vol->ref_count > 1) {\n\t\t \n\t\terr = -EBUSY;\n\t\tgoto out_unlock;\n\t}\n\tubi->volumes[vol_id] = NULL;\n\tspin_unlock(&ubi->volumes_lock);\n\n\tif (!no_vtbl) {\n\t\terr = ubi_change_vtbl_record(ubi, vol_id, NULL);\n\t\tif (err)\n\t\t\tgoto out_err;\n\t}\n\n\tfor (i = 0; i < vol->reserved_pebs; i++) {\n\t\terr = ubi_eba_unmap_leb(ubi, vol, i);\n\t\tif (err)\n\t\t\tgoto out_err;\n\t}\n\n\tcdev_device_del(&vol->cdev, &vol->dev);\n\tput_device(&vol->dev);\n\n\tspin_lock(&ubi->volumes_lock);\n\tubi->rsvd_pebs -= reserved_pebs;\n\tubi->avail_pebs += reserved_pebs;\n\tubi_update_reserved(ubi);\n\tubi->vol_count -= 1;\n\tspin_unlock(&ubi->volumes_lock);\n\n\tubi_volume_notify(ubi, vol, UBI_VOLUME_REMOVED);\n\tif (!no_vtbl)\n\t\tself_check_volumes(ubi);\n\n\treturn 0;\n\nout_err:\n\tubi_err(ubi, \"cannot remove volume %d, error %d\", vol_id, err);\n\tspin_lock(&ubi->volumes_lock);\n\tubi->volumes[vol_id] = vol;\nout_unlock:\n\tspin_unlock(&ubi->volumes_lock);\n\treturn err;\n}\n\n \nint ubi_resize_volume(struct ubi_volume_desc *desc, int reserved_pebs)\n{\n\tint i, err, pebs;\n\tstruct ubi_volume *vol = desc->vol;\n\tstruct ubi_device *ubi = vol->ubi;\n\tstruct ubi_vtbl_record vtbl_rec;\n\tstruct ubi_eba_table *new_eba_tbl = NULL;\n\tint vol_id = vol->vol_id;\n\n\tif (ubi->ro_mode)\n\t\treturn -EROFS;\n\n\tdbg_gen(\"re-size device %d, volume %d to from %d to %d PEBs\",\n\t\tubi->ubi_num, vol_id, vol->reserved_pebs, reserved_pebs);\n\n\tif (vol->vol_type == UBI_STATIC_VOLUME &&\n\t    reserved_pebs < vol->used_ebs) {\n\t\tubi_err(ubi, \"too small size %d, %d LEBs contain data\",\n\t\t\treserved_pebs, vol->used_ebs);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (reserved_pebs == vol->reserved_pebs)\n\t\treturn 0;\n\n\tnew_eba_tbl = ubi_eba_create_table(vol, reserved_pebs);\n\tif (IS_ERR(new_eba_tbl))\n\t\treturn PTR_ERR(new_eba_tbl);\n\n\tspin_lock(&ubi->volumes_lock);\n\tif (vol->ref_count > 1) {\n\t\tspin_unlock(&ubi->volumes_lock);\n\t\terr = -EBUSY;\n\t\tgoto out_free;\n\t}\n\tspin_unlock(&ubi->volumes_lock);\n\n\t \n\tpebs = reserved_pebs - vol->reserved_pebs;\n\tif (pebs > 0) {\n\t\tspin_lock(&ubi->volumes_lock);\n\t\tif (pebs > ubi->avail_pebs) {\n\t\t\tubi_err(ubi, \"not enough PEBs: requested %d, available %d\",\n\t\t\t\tpebs, ubi->avail_pebs);\n\t\t\tif (ubi->corr_peb_count)\n\t\t\t\tubi_err(ubi, \"%d PEBs are corrupted and not used\",\n\t\t\t\t\tubi->corr_peb_count);\n\t\t\tspin_unlock(&ubi->volumes_lock);\n\t\t\terr = -ENOSPC;\n\t\t\tgoto out_free;\n\t\t}\n\t\tubi->avail_pebs -= pebs;\n\t\tubi->rsvd_pebs += pebs;\n\t\tubi_eba_copy_table(vol, new_eba_tbl, vol->reserved_pebs);\n\t\tubi_eba_replace_table(vol, new_eba_tbl);\n\t\tspin_unlock(&ubi->volumes_lock);\n\t}\n\n\tif (pebs < 0) {\n\t\tfor (i = 0; i < -pebs; i++) {\n\t\t\terr = ubi_eba_unmap_leb(ubi, vol, reserved_pebs + i);\n\t\t\tif (err)\n\t\t\t\tgoto out_free;\n\t\t}\n\t\tspin_lock(&ubi->volumes_lock);\n\t\tubi->rsvd_pebs += pebs;\n\t\tubi->avail_pebs -= pebs;\n\t\tubi_update_reserved(ubi);\n\t\tubi_eba_copy_table(vol, new_eba_tbl, reserved_pebs);\n\t\tubi_eba_replace_table(vol, new_eba_tbl);\n\t\tspin_unlock(&ubi->volumes_lock);\n\t}\n\n\t \n\tif (pebs < 0) {\n\t\terr = ubi_wl_flush(ubi, vol_id, UBI_ALL);\n\t\tif (err)\n\t\t\tgoto out_acc;\n\t}\n\n\t \n\tvtbl_rec = ubi->vtbl[vol_id];\n\tvtbl_rec.reserved_pebs = cpu_to_be32(reserved_pebs);\n\terr = ubi_change_vtbl_record(ubi, vol_id, &vtbl_rec);\n\tif (err)\n\t\tgoto out_acc;\n\n\tvol->reserved_pebs = reserved_pebs;\n\tif (vol->vol_type == UBI_DYNAMIC_VOLUME) {\n\t\tvol->used_ebs = reserved_pebs;\n\t\tvol->last_eb_bytes = vol->usable_leb_size;\n\t\tvol->used_bytes =\n\t\t\t(long long)vol->used_ebs * vol->usable_leb_size;\n\t}\n\n\tubi_volume_notify(ubi, vol, UBI_VOLUME_RESIZED);\n\tself_check_volumes(ubi);\n\treturn err;\n\nout_acc:\n\tif (pebs > 0) {\n\t\tspin_lock(&ubi->volumes_lock);\n\t\tubi->rsvd_pebs -= pebs;\n\t\tubi->avail_pebs += pebs;\n\t\tspin_unlock(&ubi->volumes_lock);\n\t}\n\treturn err;\n\nout_free:\n\tubi_eba_destroy_table(new_eba_tbl);\n\treturn err;\n}\n\n \nint ubi_rename_volumes(struct ubi_device *ubi, struct list_head *rename_list)\n{\n\tint err;\n\tstruct ubi_rename_entry *re;\n\n\terr = ubi_vtbl_rename_volumes(ubi, rename_list);\n\tif (err)\n\t\treturn err;\n\n\tlist_for_each_entry(re, rename_list, list) {\n\t\tif (re->remove) {\n\t\t\terr = ubi_remove_volume(re->desc, 1);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tstruct ubi_volume *vol = re->desc->vol;\n\n\t\t\tspin_lock(&ubi->volumes_lock);\n\t\t\tvol->name_len = re->new_name_len;\n\t\t\tmemcpy(vol->name, re->new_name, re->new_name_len + 1);\n\t\t\tspin_unlock(&ubi->volumes_lock);\n\t\t\tubi_volume_notify(ubi, vol, UBI_VOLUME_RENAMED);\n\t\t}\n\t}\n\n\tif (!err)\n\t\tself_check_volumes(ubi);\n\treturn err;\n}\n\n \nint ubi_add_volume(struct ubi_device *ubi, struct ubi_volume *vol)\n{\n\tint err, vol_id = vol->vol_id;\n\tdev_t dev;\n\n\tdbg_gen(\"add volume %d\", vol_id);\n\n\t \n\tcdev_init(&vol->cdev, &ubi_vol_cdev_operations);\n\tvol->cdev.owner = THIS_MODULE;\n\tdev = MKDEV(MAJOR(ubi->cdev.dev), vol->vol_id + 1);\n\terr = cdev_add(&vol->cdev, dev, 1);\n\tif (err) {\n\t\tubi_err(ubi, \"cannot add character device for volume %d, error %d\",\n\t\t\tvol_id, err);\n\t\tvol_release(&vol->dev);\n\t\treturn err;\n\t}\n\n\tvol->dev.release = vol_release;\n\tvol->dev.parent = &ubi->dev;\n\tvol->dev.devt = dev;\n\tvol->dev.class = &ubi_class;\n\tvol->dev.groups = volume_dev_groups;\n\tdev_set_name(&vol->dev, \"%s_%d\", ubi->ubi_name, vol->vol_id);\n\terr = device_register(&vol->dev);\n\tif (err) {\n\t\tcdev_del(&vol->cdev);\n\t\tput_device(&vol->dev);\n\t\treturn err;\n\t}\n\n\tself_check_volumes(ubi);\n\treturn err;\n}\n\n \nvoid ubi_free_volume(struct ubi_device *ubi, struct ubi_volume *vol)\n{\n\tdbg_gen(\"free volume %d\", vol->vol_id);\n\n\tubi->volumes[vol->vol_id] = NULL;\n\tcdev_del(&vol->cdev);\n\tdevice_unregister(&vol->dev);\n}\n\n \nstatic int self_check_volume(struct ubi_device *ubi, int vol_id)\n{\n\tint idx = vol_id2idx(ubi, vol_id);\n\tint reserved_pebs, alignment, data_pad, vol_type, name_len, upd_marker;\n\tconst struct ubi_volume *vol;\n\tlong long n;\n\tconst char *name;\n\n\tspin_lock(&ubi->volumes_lock);\n\treserved_pebs = be32_to_cpu(ubi->vtbl[vol_id].reserved_pebs);\n\tvol = ubi->volumes[idx];\n\n\tif (!vol) {\n\t\tif (reserved_pebs) {\n\t\t\tubi_err(ubi, \"no volume info, but volume exists\");\n\t\t\tgoto fail;\n\t\t}\n\t\tspin_unlock(&ubi->volumes_lock);\n\t\treturn 0;\n\t}\n\n\tif (vol->reserved_pebs < 0 || vol->alignment < 0 || vol->data_pad < 0 ||\n\t    vol->name_len < 0) {\n\t\tubi_err(ubi, \"negative values\");\n\t\tgoto fail;\n\t}\n\tif (vol->alignment > ubi->leb_size || vol->alignment == 0) {\n\t\tubi_err(ubi, \"bad alignment\");\n\t\tgoto fail;\n\t}\n\n\tn = vol->alignment & (ubi->min_io_size - 1);\n\tif (vol->alignment != 1 && n) {\n\t\tubi_err(ubi, \"alignment is not multiple of min I/O unit\");\n\t\tgoto fail;\n\t}\n\n\tn = ubi->leb_size % vol->alignment;\n\tif (vol->data_pad != n) {\n\t\tubi_err(ubi, \"bad data_pad, has to be %lld\", n);\n\t\tgoto fail;\n\t}\n\n\tif (vol->vol_type != UBI_DYNAMIC_VOLUME &&\n\t    vol->vol_type != UBI_STATIC_VOLUME) {\n\t\tubi_err(ubi, \"bad vol_type\");\n\t\tgoto fail;\n\t}\n\n\tif (vol->upd_marker && vol->corrupted) {\n\t\tubi_err(ubi, \"update marker and corrupted simultaneously\");\n\t\tgoto fail;\n\t}\n\n\tif (vol->reserved_pebs > ubi->good_peb_count) {\n\t\tubi_err(ubi, \"too large reserved_pebs\");\n\t\tgoto fail;\n\t}\n\n\tn = ubi->leb_size - vol->data_pad;\n\tif (vol->usable_leb_size != ubi->leb_size - vol->data_pad) {\n\t\tubi_err(ubi, \"bad usable_leb_size, has to be %lld\", n);\n\t\tgoto fail;\n\t}\n\n\tif (vol->name_len > UBI_VOL_NAME_MAX) {\n\t\tubi_err(ubi, \"too long volume name, max is %d\",\n\t\t\tUBI_VOL_NAME_MAX);\n\t\tgoto fail;\n\t}\n\n\tn = strnlen(vol->name, vol->name_len + 1);\n\tif (n != vol->name_len) {\n\t\tubi_err(ubi, \"bad name_len %lld\", n);\n\t\tgoto fail;\n\t}\n\n\tn = (long long)vol->used_ebs * vol->usable_leb_size;\n\tif (vol->vol_type == UBI_DYNAMIC_VOLUME) {\n\t\tif (vol->corrupted) {\n\t\t\tubi_err(ubi, \"corrupted dynamic volume\");\n\t\t\tgoto fail;\n\t\t}\n\t\tif (vol->used_ebs != vol->reserved_pebs) {\n\t\t\tubi_err(ubi, \"bad used_ebs\");\n\t\t\tgoto fail;\n\t\t}\n\t\tif (vol->last_eb_bytes != vol->usable_leb_size) {\n\t\t\tubi_err(ubi, \"bad last_eb_bytes\");\n\t\t\tgoto fail;\n\t\t}\n\t\tif (vol->used_bytes != n) {\n\t\t\tubi_err(ubi, \"bad used_bytes\");\n\t\t\tgoto fail;\n\t\t}\n\n\t\tif (vol->skip_check) {\n\t\t\tubi_err(ubi, \"bad skip_check\");\n\t\t\tgoto fail;\n\t\t}\n\t} else {\n\t\tif (vol->used_ebs < 0 || vol->used_ebs > vol->reserved_pebs) {\n\t\t\tubi_err(ubi, \"bad used_ebs\");\n\t\t\tgoto fail;\n\t\t}\n\t\tif (vol->last_eb_bytes < 0 ||\n\t\t    vol->last_eb_bytes > vol->usable_leb_size) {\n\t\t\tubi_err(ubi, \"bad last_eb_bytes\");\n\t\t\tgoto fail;\n\t\t}\n\t\tif (vol->used_bytes < 0 || vol->used_bytes > n ||\n\t\t    vol->used_bytes < n - vol->usable_leb_size) {\n\t\t\tubi_err(ubi, \"bad used_bytes\");\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\talignment  = be32_to_cpu(ubi->vtbl[vol_id].alignment);\n\tdata_pad   = be32_to_cpu(ubi->vtbl[vol_id].data_pad);\n\tname_len   = be16_to_cpu(ubi->vtbl[vol_id].name_len);\n\tupd_marker = ubi->vtbl[vol_id].upd_marker;\n\tname       = &ubi->vtbl[vol_id].name[0];\n\tif (ubi->vtbl[vol_id].vol_type == UBI_VID_DYNAMIC)\n\t\tvol_type = UBI_DYNAMIC_VOLUME;\n\telse\n\t\tvol_type = UBI_STATIC_VOLUME;\n\n\tif (alignment != vol->alignment || data_pad != vol->data_pad ||\n\t    upd_marker != vol->upd_marker || vol_type != vol->vol_type ||\n\t    name_len != vol->name_len || strncmp(name, vol->name, name_len)) {\n\t\tubi_err(ubi, \"volume info is different\");\n\t\tgoto fail;\n\t}\n\n\tspin_unlock(&ubi->volumes_lock);\n\treturn 0;\n\nfail:\n\tubi_err(ubi, \"self-check failed for volume %d\", vol_id);\n\tif (vol)\n\t\tubi_dump_vol_info(vol);\n\tubi_dump_vtbl_record(&ubi->vtbl[vol_id], vol_id);\n\tdump_stack();\n\tspin_unlock(&ubi->volumes_lock);\n\treturn -EINVAL;\n}\n\n \nstatic int self_check_volumes(struct ubi_device *ubi)\n{\n\tint i, err = 0;\n\n\tif (!ubi_dbg_chk_gen(ubi))\n\t\treturn 0;\n\n\tfor (i = 0; i < ubi->vtbl_slots; i++) {\n\t\terr = self_check_volume(ubi, i);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}