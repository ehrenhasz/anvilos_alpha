{
  "module_name": "upd.c",
  "hash_id": "9731268274f7bbbf8590e924e3c44649f4e6fa1e962779d299d23522e5b0538b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/ubi/upd.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/err.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include \"ubi.h\"\n\n \nstatic int set_update_marker(struct ubi_device *ubi, struct ubi_volume *vol)\n{\n\tint err;\n\tstruct ubi_vtbl_record vtbl_rec;\n\n\tdbg_gen(\"set update marker for volume %d\", vol->vol_id);\n\n\tif (vol->upd_marker) {\n\t\tubi_assert(ubi->vtbl[vol->vol_id].upd_marker);\n\t\tdbg_gen(\"already set\");\n\t\treturn 0;\n\t}\n\n\tvtbl_rec = ubi->vtbl[vol->vol_id];\n\tvtbl_rec.upd_marker = 1;\n\n\tmutex_lock(&ubi->device_mutex);\n\terr = ubi_change_vtbl_record(ubi, vol->vol_id, &vtbl_rec);\n\tvol->upd_marker = 1;\n\tmutex_unlock(&ubi->device_mutex);\n\treturn err;\n}\n\n \nstatic int clear_update_marker(struct ubi_device *ubi, struct ubi_volume *vol,\n\t\t\t       long long bytes)\n{\n\tint err;\n\tstruct ubi_vtbl_record vtbl_rec;\n\n\tdbg_gen(\"clear update marker for volume %d\", vol->vol_id);\n\n\tvtbl_rec = ubi->vtbl[vol->vol_id];\n\tubi_assert(vol->upd_marker && vtbl_rec.upd_marker);\n\tvtbl_rec.upd_marker = 0;\n\n\tif (vol->vol_type == UBI_STATIC_VOLUME) {\n\t\tvol->corrupted = 0;\n\t\tvol->used_bytes = bytes;\n\t\tvol->used_ebs = div_u64_rem(bytes, vol->usable_leb_size,\n\t\t\t\t\t    &vol->last_eb_bytes);\n\t\tif (vol->last_eb_bytes)\n\t\t\tvol->used_ebs += 1;\n\t\telse\n\t\t\tvol->last_eb_bytes = vol->usable_leb_size;\n\t}\n\n\tmutex_lock(&ubi->device_mutex);\n\terr = ubi_change_vtbl_record(ubi, vol->vol_id, &vtbl_rec);\n\tvol->upd_marker = 0;\n\tmutex_unlock(&ubi->device_mutex);\n\treturn err;\n}\n\n \nint ubi_start_update(struct ubi_device *ubi, struct ubi_volume *vol,\n\t\t     long long bytes)\n{\n\tint i, err;\n\n\tdbg_gen(\"start update of volume %d, %llu bytes\", vol->vol_id, bytes);\n\tubi_assert(!vol->updating && !vol->changing_leb);\n\tvol->updating = 1;\n\n\tvol->upd_buf = vmalloc(ubi->leb_size);\n\tif (!vol->upd_buf)\n\t\treturn -ENOMEM;\n\n\terr = set_update_marker(ubi, vol);\n\tif (err)\n\t\treturn err;\n\n\t \n\tfor (i = 0; i < vol->reserved_pebs; i++) {\n\t\terr = ubi_eba_unmap_leb(ubi, vol, i);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\terr = ubi_wl_flush(ubi, UBI_ALL, UBI_ALL);\n\tif (err)\n\t\treturn err;\n\n\tif (bytes == 0) {\n\t\terr = clear_update_marker(ubi, vol, 0);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tvfree(vol->upd_buf);\n\t\tvol->updating = 0;\n\t\treturn 0;\n\t}\n\n\tvol->upd_ebs = div_u64(bytes + vol->usable_leb_size - 1,\n\t\t\t       vol->usable_leb_size);\n\tvol->upd_bytes = bytes;\n\tvol->upd_received = 0;\n\treturn 0;\n}\n\n \nint ubi_start_leb_change(struct ubi_device *ubi, struct ubi_volume *vol,\n\t\t\t const struct ubi_leb_change_req *req)\n{\n\tubi_assert(!vol->updating && !vol->changing_leb);\n\n\tdbg_gen(\"start changing LEB %d:%d, %u bytes\",\n\t\tvol->vol_id, req->lnum, req->bytes);\n\tif (req->bytes == 0)\n\t\treturn ubi_eba_atomic_leb_change(ubi, vol, req->lnum, NULL, 0);\n\n\tvol->upd_bytes = req->bytes;\n\tvol->upd_received = 0;\n\tvol->changing_leb = 1;\n\tvol->ch_lnum = req->lnum;\n\n\tvol->upd_buf = vmalloc(ALIGN((int)req->bytes, ubi->min_io_size));\n\tif (!vol->upd_buf)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\n \nstatic int write_leb(struct ubi_device *ubi, struct ubi_volume *vol, int lnum,\n\t\t     void *buf, int len, int used_ebs)\n{\n\tint err;\n\n\tif (vol->vol_type == UBI_DYNAMIC_VOLUME) {\n\t\tint l = ALIGN(len, ubi->min_io_size);\n\n\t\tmemset(buf + len, 0xFF, l - len);\n\t\tlen = ubi_calc_data_len(ubi, buf, l);\n\t\tif (len == 0) {\n\t\t\tdbg_gen(\"all %d bytes contain 0xFF - skip\", len);\n\t\t\treturn 0;\n\t\t}\n\n\t\terr = ubi_eba_write_leb(ubi, vol, lnum, buf, 0, len);\n\t} else {\n\t\t \n\t\tmemset(buf + len, 0, vol->usable_leb_size - len);\n\t\terr = ubi_eba_write_leb_st(ubi, vol, lnum, buf, len, used_ebs);\n\t}\n\n\treturn err;\n}\n\n \nint ubi_more_update_data(struct ubi_device *ubi, struct ubi_volume *vol,\n\t\t\t const void __user *buf, int count)\n{\n\tint lnum, offs, err = 0, len, to_write = count;\n\n\tdbg_gen(\"write %d of %lld bytes, %lld already passed\",\n\t\tcount, vol->upd_bytes, vol->upd_received);\n\n\tif (ubi->ro_mode)\n\t\treturn -EROFS;\n\n\tlnum = div_u64_rem(vol->upd_received,  vol->usable_leb_size, &offs);\n\tif (vol->upd_received + count > vol->upd_bytes)\n\t\tto_write = count = vol->upd_bytes - vol->upd_received;\n\n\t \n\tif (offs != 0) {\n\t\t \n\n\t\tlen = vol->usable_leb_size - offs;\n\t\tif (len > count)\n\t\t\tlen = count;\n\n\t\terr = copy_from_user(vol->upd_buf + offs, buf, len);\n\t\tif (err)\n\t\t\treturn -EFAULT;\n\n\t\tif (offs + len == vol->usable_leb_size ||\n\t\t    vol->upd_received + len == vol->upd_bytes) {\n\t\t\tint flush_len = offs + len;\n\n\t\t\t \n\t\t\tubi_assert(flush_len <= vol->usable_leb_size);\n\t\t\terr = write_leb(ubi, vol, lnum, vol->upd_buf, flush_len,\n\t\t\t\t\tvol->upd_ebs);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\n\t\tvol->upd_received += len;\n\t\tcount -= len;\n\t\tbuf += len;\n\t\tlnum += 1;\n\t}\n\n\t \n\twhile (count) {\n\t\tif (count > vol->usable_leb_size)\n\t\t\tlen = vol->usable_leb_size;\n\t\telse\n\t\t\tlen = count;\n\n\t\terr = copy_from_user(vol->upd_buf, buf, len);\n\t\tif (err)\n\t\t\treturn -EFAULT;\n\n\t\tif (len == vol->usable_leb_size ||\n\t\t    vol->upd_received + len == vol->upd_bytes) {\n\t\t\terr = write_leb(ubi, vol, lnum, vol->upd_buf,\n\t\t\t\t\tlen, vol->upd_ebs);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tvol->upd_received += len;\n\t\tcount -= len;\n\t\tlnum += 1;\n\t\tbuf += len;\n\t}\n\n\tubi_assert(vol->upd_received <= vol->upd_bytes);\n\tif (vol->upd_received == vol->upd_bytes) {\n\t\terr = ubi_wl_flush(ubi, UBI_ALL, UBI_ALL);\n\t\tif (err)\n\t\t\treturn err;\n\t\t \n\t\terr = clear_update_marker(ubi, vol, vol->upd_bytes);\n\t\tif (err)\n\t\t\treturn err;\n\t\tvol->updating = 0;\n\t\terr = to_write;\n\t\tvfree(vol->upd_buf);\n\t}\n\n\treturn err;\n}\n\n \nint ubi_more_leb_change_data(struct ubi_device *ubi, struct ubi_volume *vol,\n\t\t\t     const void __user *buf, int count)\n{\n\tint err;\n\n\tdbg_gen(\"write %d of %lld bytes, %lld already passed\",\n\t\tcount, vol->upd_bytes, vol->upd_received);\n\n\tif (ubi->ro_mode)\n\t\treturn -EROFS;\n\n\tif (vol->upd_received + count > vol->upd_bytes)\n\t\tcount = vol->upd_bytes - vol->upd_received;\n\n\terr = copy_from_user(vol->upd_buf + vol->upd_received, buf, count);\n\tif (err)\n\t\treturn -EFAULT;\n\n\tvol->upd_received += count;\n\n\tif (vol->upd_received == vol->upd_bytes) {\n\t\tint len = ALIGN((int)vol->upd_bytes, ubi->min_io_size);\n\n\t\tmemset(vol->upd_buf + vol->upd_bytes, 0xFF,\n\t\t       len - vol->upd_bytes);\n\t\tlen = ubi_calc_data_len(ubi, vol->upd_buf, len);\n\t\terr = ubi_eba_atomic_leb_change(ubi, vol, vol->ch_lnum,\n\t\t\t\t\t\tvol->upd_buf, len);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tubi_assert(vol->upd_received <= vol->upd_bytes);\n\tif (vol->upd_received == vol->upd_bytes) {\n\t\tvol->changing_leb = 0;\n\t\terr = count;\n\t\tvfree(vol->upd_buf);\n\t}\n\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}