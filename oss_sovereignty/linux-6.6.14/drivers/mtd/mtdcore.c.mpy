{
  "module_name": "mtdcore.c",
  "hash_id": "0dc5707ef288101bc47ce2f12907cf5cbe0a4fe16d077c48dee256212b88d5c1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/mtdcore.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/ptrace.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/timer.h>\n#include <linux/major.h>\n#include <linux/fs.h>\n#include <linux/err.h>\n#include <linux/ioctl.h>\n#include <linux/init.h>\n#include <linux/of.h>\n#include <linux/proc_fs.h>\n#include <linux/idr.h>\n#include <linux/backing-dev.h>\n#include <linux/gfp.h>\n#include <linux/random.h>\n#include <linux/slab.h>\n#include <linux/reboot.h>\n#include <linux/leds.h>\n#include <linux/debugfs.h>\n#include <linux/nvmem-provider.h>\n#include <linux/root_dev.h>\n\n#include <linux/mtd/mtd.h>\n#include <linux/mtd/partitions.h>\n\n#include \"mtdcore.h\"\n\nstruct backing_dev_info *mtd_bdi;\n\n#ifdef CONFIG_PM_SLEEP\n\nstatic int mtd_cls_suspend(struct device *dev)\n{\n\tstruct mtd_info *mtd = dev_get_drvdata(dev);\n\n\treturn mtd ? mtd_suspend(mtd) : 0;\n}\n\nstatic int mtd_cls_resume(struct device *dev)\n{\n\tstruct mtd_info *mtd = dev_get_drvdata(dev);\n\n\tif (mtd)\n\t\tmtd_resume(mtd);\n\treturn 0;\n}\n\nstatic SIMPLE_DEV_PM_OPS(mtd_cls_pm_ops, mtd_cls_suspend, mtd_cls_resume);\n#define MTD_CLS_PM_OPS (&mtd_cls_pm_ops)\n#else\n#define MTD_CLS_PM_OPS NULL\n#endif\n\nstatic struct class mtd_class = {\n\t.name = \"mtd\",\n\t.pm = MTD_CLS_PM_OPS,\n};\n\nstatic DEFINE_IDR(mtd_idr);\n\n \nDEFINE_MUTEX(mtd_table_mutex);\nEXPORT_SYMBOL_GPL(mtd_table_mutex);\n\nstruct mtd_info *__mtd_next_device(int i)\n{\n\treturn idr_get_next(&mtd_idr, &i);\n}\nEXPORT_SYMBOL_GPL(__mtd_next_device);\n\nstatic LIST_HEAD(mtd_notifiers);\n\n\n#define MTD_DEVT(index) MKDEV(MTD_CHAR_MAJOR, (index)*2)\n\n \nstatic void mtd_release(struct device *dev)\n{\n\tstruct mtd_info *mtd = dev_get_drvdata(dev);\n\tdev_t index = MTD_DEVT(mtd->index);\n\n\tidr_remove(&mtd_idr, mtd->index);\n\tof_node_put(mtd_get_of_node(mtd));\n\n\tif (mtd_is_partition(mtd))\n\t\trelease_mtd_partition(mtd);\n\n\t \n\tdevice_destroy(&mtd_class, index + 1);\n}\n\nstatic void mtd_device_release(struct kref *kref)\n{\n\tstruct mtd_info *mtd = container_of(kref, struct mtd_info, refcnt);\n\tbool is_partition = mtd_is_partition(mtd);\n\n\tdebugfs_remove_recursive(mtd->dbg.dfs_dir);\n\n\t \n\tnvmem_unregister(mtd->nvmem);\n\n\tdevice_unregister(&mtd->dev);\n\n\t \n\tif (!is_partition)\n\t\tmemset(&mtd->dev, 0, sizeof(mtd->dev));\n\n\tmodule_put(THIS_MODULE);\n}\n\n#define MTD_DEVICE_ATTR_RO(name) \\\nstatic DEVICE_ATTR(name, 0444, mtd_##name##_show, NULL)\n\n#define MTD_DEVICE_ATTR_RW(name) \\\nstatic DEVICE_ATTR(name, 0644, mtd_##name##_show, mtd_##name##_store)\n\nstatic ssize_t mtd_type_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct mtd_info *mtd = dev_get_drvdata(dev);\n\tchar *type;\n\n\tswitch (mtd->type) {\n\tcase MTD_ABSENT:\n\t\ttype = \"absent\";\n\t\tbreak;\n\tcase MTD_RAM:\n\t\ttype = \"ram\";\n\t\tbreak;\n\tcase MTD_ROM:\n\t\ttype = \"rom\";\n\t\tbreak;\n\tcase MTD_NORFLASH:\n\t\ttype = \"nor\";\n\t\tbreak;\n\tcase MTD_NANDFLASH:\n\t\ttype = \"nand\";\n\t\tbreak;\n\tcase MTD_DATAFLASH:\n\t\ttype = \"dataflash\";\n\t\tbreak;\n\tcase MTD_UBIVOLUME:\n\t\ttype = \"ubi\";\n\t\tbreak;\n\tcase MTD_MLCNANDFLASH:\n\t\ttype = \"mlc-nand\";\n\t\tbreak;\n\tdefault:\n\t\ttype = \"unknown\";\n\t}\n\n\treturn sysfs_emit(buf, \"%s\\n\", type);\n}\nMTD_DEVICE_ATTR_RO(type);\n\nstatic ssize_t mtd_flags_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct mtd_info *mtd = dev_get_drvdata(dev);\n\n\treturn sysfs_emit(buf, \"0x%lx\\n\", (unsigned long)mtd->flags);\n}\nMTD_DEVICE_ATTR_RO(flags);\n\nstatic ssize_t mtd_size_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct mtd_info *mtd = dev_get_drvdata(dev);\n\n\treturn sysfs_emit(buf, \"%llu\\n\", (unsigned long long)mtd->size);\n}\nMTD_DEVICE_ATTR_RO(size);\n\nstatic ssize_t mtd_erasesize_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct mtd_info *mtd = dev_get_drvdata(dev);\n\n\treturn sysfs_emit(buf, \"%lu\\n\", (unsigned long)mtd->erasesize);\n}\nMTD_DEVICE_ATTR_RO(erasesize);\n\nstatic ssize_t mtd_writesize_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct mtd_info *mtd = dev_get_drvdata(dev);\n\n\treturn sysfs_emit(buf, \"%lu\\n\", (unsigned long)mtd->writesize);\n}\nMTD_DEVICE_ATTR_RO(writesize);\n\nstatic ssize_t mtd_subpagesize_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct mtd_info *mtd = dev_get_drvdata(dev);\n\tunsigned int subpagesize = mtd->writesize >> mtd->subpage_sft;\n\n\treturn sysfs_emit(buf, \"%u\\n\", subpagesize);\n}\nMTD_DEVICE_ATTR_RO(subpagesize);\n\nstatic ssize_t mtd_oobsize_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct mtd_info *mtd = dev_get_drvdata(dev);\n\n\treturn sysfs_emit(buf, \"%lu\\n\", (unsigned long)mtd->oobsize);\n}\nMTD_DEVICE_ATTR_RO(oobsize);\n\nstatic ssize_t mtd_oobavail_show(struct device *dev,\n\t\t\t\t struct device_attribute *attr, char *buf)\n{\n\tstruct mtd_info *mtd = dev_get_drvdata(dev);\n\n\treturn sysfs_emit(buf, \"%u\\n\", mtd->oobavail);\n}\nMTD_DEVICE_ATTR_RO(oobavail);\n\nstatic ssize_t mtd_numeraseregions_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct mtd_info *mtd = dev_get_drvdata(dev);\n\n\treturn sysfs_emit(buf, \"%u\\n\", mtd->numeraseregions);\n}\nMTD_DEVICE_ATTR_RO(numeraseregions);\n\nstatic ssize_t mtd_name_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct mtd_info *mtd = dev_get_drvdata(dev);\n\n\treturn sysfs_emit(buf, \"%s\\n\", mtd->name);\n}\nMTD_DEVICE_ATTR_RO(name);\n\nstatic ssize_t mtd_ecc_strength_show(struct device *dev,\n\t\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tstruct mtd_info *mtd = dev_get_drvdata(dev);\n\n\treturn sysfs_emit(buf, \"%u\\n\", mtd->ecc_strength);\n}\nMTD_DEVICE_ATTR_RO(ecc_strength);\n\nstatic ssize_t mtd_bitflip_threshold_show(struct device *dev,\n\t\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t\t  char *buf)\n{\n\tstruct mtd_info *mtd = dev_get_drvdata(dev);\n\n\treturn sysfs_emit(buf, \"%u\\n\", mtd->bitflip_threshold);\n}\n\nstatic ssize_t mtd_bitflip_threshold_store(struct device *dev,\n\t\t\t\t\t   struct device_attribute *attr,\n\t\t\t\t\t   const char *buf, size_t count)\n{\n\tstruct mtd_info *mtd = dev_get_drvdata(dev);\n\tunsigned int bitflip_threshold;\n\tint retval;\n\n\tretval = kstrtouint(buf, 0, &bitflip_threshold);\n\tif (retval)\n\t\treturn retval;\n\n\tmtd->bitflip_threshold = bitflip_threshold;\n\treturn count;\n}\nMTD_DEVICE_ATTR_RW(bitflip_threshold);\n\nstatic ssize_t mtd_ecc_step_size_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct mtd_info *mtd = dev_get_drvdata(dev);\n\n\treturn sysfs_emit(buf, \"%u\\n\", mtd->ecc_step_size);\n\n}\nMTD_DEVICE_ATTR_RO(ecc_step_size);\n\nstatic ssize_t mtd_corrected_bits_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct mtd_info *mtd = dev_get_drvdata(dev);\n\tstruct mtd_ecc_stats *ecc_stats = &mtd->ecc_stats;\n\n\treturn sysfs_emit(buf, \"%u\\n\", ecc_stats->corrected);\n}\nMTD_DEVICE_ATTR_RO(corrected_bits);\t \n\nstatic ssize_t mtd_ecc_failures_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct mtd_info *mtd = dev_get_drvdata(dev);\n\tstruct mtd_ecc_stats *ecc_stats = &mtd->ecc_stats;\n\n\treturn sysfs_emit(buf, \"%u\\n\", ecc_stats->failed);\n}\nMTD_DEVICE_ATTR_RO(ecc_failures);\t \n\nstatic ssize_t mtd_bad_blocks_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct mtd_info *mtd = dev_get_drvdata(dev);\n\tstruct mtd_ecc_stats *ecc_stats = &mtd->ecc_stats;\n\n\treturn sysfs_emit(buf, \"%u\\n\", ecc_stats->badblocks);\n}\nMTD_DEVICE_ATTR_RO(bad_blocks);\n\nstatic ssize_t mtd_bbt_blocks_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct mtd_info *mtd = dev_get_drvdata(dev);\n\tstruct mtd_ecc_stats *ecc_stats = &mtd->ecc_stats;\n\n\treturn sysfs_emit(buf, \"%u\\n\", ecc_stats->bbtblocks);\n}\nMTD_DEVICE_ATTR_RO(bbt_blocks);\n\nstatic struct attribute *mtd_attrs[] = {\n\t&dev_attr_type.attr,\n\t&dev_attr_flags.attr,\n\t&dev_attr_size.attr,\n\t&dev_attr_erasesize.attr,\n\t&dev_attr_writesize.attr,\n\t&dev_attr_subpagesize.attr,\n\t&dev_attr_oobsize.attr,\n\t&dev_attr_oobavail.attr,\n\t&dev_attr_numeraseregions.attr,\n\t&dev_attr_name.attr,\n\t&dev_attr_ecc_strength.attr,\n\t&dev_attr_ecc_step_size.attr,\n\t&dev_attr_corrected_bits.attr,\n\t&dev_attr_ecc_failures.attr,\n\t&dev_attr_bad_blocks.attr,\n\t&dev_attr_bbt_blocks.attr,\n\t&dev_attr_bitflip_threshold.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(mtd);\n\nstatic const struct device_type mtd_devtype = {\n\t.name\t\t= \"mtd\",\n\t.groups\t\t= mtd_groups,\n\t.release\t= mtd_release,\n};\n\nstatic bool mtd_expert_analysis_mode;\n\n#ifdef CONFIG_DEBUG_FS\nbool mtd_check_expert_analysis_mode(void)\n{\n\tconst char *mtd_expert_analysis_warning =\n\t\t\"Bad block checks have been entirely disabled.\\n\"\n\t\t\"This is only reserved for post-mortem forensics and debug purposes.\\n\"\n\t\t\"Never enable this mode if you do not know what you are doing!\\n\";\n\n\treturn WARN_ONCE(mtd_expert_analysis_mode, mtd_expert_analysis_warning);\n}\nEXPORT_SYMBOL_GPL(mtd_check_expert_analysis_mode);\n#endif\n\nstatic struct dentry *dfs_dir_mtd;\n\nstatic void mtd_debugfs_populate(struct mtd_info *mtd)\n{\n\tstruct device *dev = &mtd->dev;\n\n\tif (IS_ERR_OR_NULL(dfs_dir_mtd))\n\t\treturn;\n\n\tmtd->dbg.dfs_dir = debugfs_create_dir(dev_name(dev), dfs_dir_mtd);\n}\n\n#ifndef CONFIG_MMU\nunsigned mtd_mmap_capabilities(struct mtd_info *mtd)\n{\n\tswitch (mtd->type) {\n\tcase MTD_RAM:\n\t\treturn NOMMU_MAP_COPY | NOMMU_MAP_DIRECT | NOMMU_MAP_EXEC |\n\t\t\tNOMMU_MAP_READ | NOMMU_MAP_WRITE;\n\tcase MTD_ROM:\n\t\treturn NOMMU_MAP_COPY | NOMMU_MAP_DIRECT | NOMMU_MAP_EXEC |\n\t\t\tNOMMU_MAP_READ;\n\tdefault:\n\t\treturn NOMMU_MAP_COPY;\n\t}\n}\nEXPORT_SYMBOL_GPL(mtd_mmap_capabilities);\n#endif\n\nstatic int mtd_reboot_notifier(struct notifier_block *n, unsigned long state,\n\t\t\t       void *cmd)\n{\n\tstruct mtd_info *mtd;\n\n\tmtd = container_of(n, struct mtd_info, reboot_notifier);\n\tmtd->_reboot(mtd);\n\n\treturn NOTIFY_DONE;\n}\n\n \nint mtd_wunit_to_pairing_info(struct mtd_info *mtd, int wunit,\n\t\t\t      struct mtd_pairing_info *info)\n{\n\tstruct mtd_info *master = mtd_get_master(mtd);\n\tint npairs = mtd_wunit_per_eb(master) / mtd_pairing_groups(master);\n\n\tif (wunit < 0 || wunit >= npairs)\n\t\treturn -EINVAL;\n\n\tif (master->pairing && master->pairing->get_info)\n\t\treturn master->pairing->get_info(master, wunit, info);\n\n\tinfo->group = 0;\n\tinfo->pair = wunit;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(mtd_wunit_to_pairing_info);\n\n \nint mtd_pairing_info_to_wunit(struct mtd_info *mtd,\n\t\t\t      const struct mtd_pairing_info *info)\n{\n\tstruct mtd_info *master = mtd_get_master(mtd);\n\tint ngroups = mtd_pairing_groups(master);\n\tint npairs = mtd_wunit_per_eb(master) / ngroups;\n\n\tif (!info || info->pair < 0 || info->pair >= npairs ||\n\t    info->group < 0 || info->group >= ngroups)\n\t\treturn -EINVAL;\n\n\tif (master->pairing && master->pairing->get_wunit)\n\t\treturn mtd->pairing->get_wunit(master, info);\n\n\treturn info->pair;\n}\nEXPORT_SYMBOL_GPL(mtd_pairing_info_to_wunit);\n\n \nint mtd_pairing_groups(struct mtd_info *mtd)\n{\n\tstruct mtd_info *master = mtd_get_master(mtd);\n\n\tif (!master->pairing || !master->pairing->ngroups)\n\t\treturn 1;\n\n\treturn master->pairing->ngroups;\n}\nEXPORT_SYMBOL_GPL(mtd_pairing_groups);\n\nstatic int mtd_nvmem_reg_read(void *priv, unsigned int offset,\n\t\t\t      void *val, size_t bytes)\n{\n\tstruct mtd_info *mtd = priv;\n\tsize_t retlen;\n\tint err;\n\n\terr = mtd_read(mtd, offset, bytes, &retlen, val);\n\tif (err && err != -EUCLEAN)\n\t\treturn err;\n\n\treturn retlen == bytes ? 0 : -EIO;\n}\n\nstatic int mtd_nvmem_add(struct mtd_info *mtd)\n{\n\tstruct device_node *node = mtd_get_of_node(mtd);\n\tstruct nvmem_config config = {};\n\n\tconfig.id = NVMEM_DEVID_NONE;\n\tconfig.dev = &mtd->dev;\n\tconfig.name = dev_name(&mtd->dev);\n\tconfig.owner = THIS_MODULE;\n\tconfig.reg_read = mtd_nvmem_reg_read;\n\tconfig.size = mtd->size;\n\tconfig.word_size = 1;\n\tconfig.stride = 1;\n\tconfig.read_only = true;\n\tconfig.root_only = true;\n\tconfig.ignore_wp = true;\n\tconfig.no_of_node = !of_device_is_compatible(node, \"nvmem-cells\");\n\tconfig.priv = mtd;\n\n\tmtd->nvmem = nvmem_register(&config);\n\tif (IS_ERR(mtd->nvmem)) {\n\t\t \n\t\tif (PTR_ERR(mtd->nvmem) == -EOPNOTSUPP)\n\t\t\tmtd->nvmem = NULL;\n\t\telse\n\t\t\treturn dev_err_probe(&mtd->dev, PTR_ERR(mtd->nvmem),\n\t\t\t\t\t     \"Failed to register NVMEM device\\n\");\n\t}\n\n\treturn 0;\n}\n\nstatic void mtd_check_of_node(struct mtd_info *mtd)\n{\n\tstruct device_node *partitions, *parent_dn, *mtd_dn = NULL;\n\tconst char *pname, *prefix = \"partition-\";\n\tint plen, mtd_name_len, offset, prefix_len;\n\n\t \n\tif (mtd_get_of_node(mtd))\n\t\treturn;\n\n\tif (!mtd_is_partition(mtd))\n\t\treturn;\n\n\tparent_dn = of_node_get(mtd_get_of_node(mtd->parent));\n\tif (!parent_dn)\n\t\treturn;\n\n\tif (mtd_is_partition(mtd->parent))\n\t\tpartitions = of_node_get(parent_dn);\n\telse\n\t\tpartitions = of_get_child_by_name(parent_dn, \"partitions\");\n\tif (!partitions)\n\t\tgoto exit_parent;\n\n\tprefix_len = strlen(prefix);\n\tmtd_name_len = strlen(mtd->name);\n\n\t \n\tfor_each_child_of_node(partitions, mtd_dn) {\n\t\t \n\t\tif (!of_node_name_prefix(mtd_dn, prefix))\n\t\t\tcontinue;\n\n\t\t \n\t\tif (!of_property_read_string(mtd_dn, \"label\", &pname)) {\n\t\t\toffset = 0;\n\t\t} else {\n\t\t\tpname = mtd_dn->name;\n\t\t\toffset = prefix_len;\n\t\t}\n\n\t\tplen = strlen(pname) - offset;\n\t\tif (plen == mtd_name_len &&\n\t\t    !strncmp(mtd->name, pname + offset, plen)) {\n\t\t\tmtd_set_of_node(mtd, mtd_dn);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tof_node_put(partitions);\nexit_parent:\n\tof_node_put(parent_dn);\n}\n\n \n\nint add_mtd_device(struct mtd_info *mtd)\n{\n\tstruct device_node *np = mtd_get_of_node(mtd);\n\tstruct mtd_info *master = mtd_get_master(mtd);\n\tstruct mtd_notifier *not;\n\tint i, error, ofidx;\n\n\t \n\tif (WARN_ONCE(mtd->dev.type, \"MTD already registered\\n\"))\n\t\treturn -EEXIST;\n\n\tBUG_ON(mtd->writesize == 0);\n\n\t \n\tif (WARN_ON((mtd->_write && mtd->_write_oob) ||\n\t\t    (mtd->_read && mtd->_read_oob)))\n\t\treturn -EINVAL;\n\n\tif (WARN_ON((!mtd->erasesize || !master->_erase) &&\n\t\t    !(mtd->flags & MTD_NO_ERASE)))\n\t\treturn -EINVAL;\n\n\t \n\tif (mtd->flags & MTD_SLC_ON_MLC_EMULATION &&\n\t    (!mtd_is_partition(mtd) || master->type != MTD_MLCNANDFLASH ||\n\t     !master->pairing || master->_writev))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&mtd_table_mutex);\n\n\tofidx = -1;\n\tif (np)\n\t\tofidx = of_alias_get_id(np, \"mtd\");\n\tif (ofidx >= 0)\n\t\ti = idr_alloc(&mtd_idr, mtd, ofidx, ofidx + 1, GFP_KERNEL);\n\telse\n\t\ti = idr_alloc(&mtd_idr, mtd, 0, 0, GFP_KERNEL);\n\tif (i < 0) {\n\t\terror = i;\n\t\tgoto fail_locked;\n\t}\n\n\tmtd->index = i;\n\tkref_init(&mtd->refcnt);\n\n\t \n\tif (mtd->bitflip_threshold == 0)\n\t\tmtd->bitflip_threshold = mtd->ecc_strength;\n\n\tif (mtd->flags & MTD_SLC_ON_MLC_EMULATION) {\n\t\tint ngroups = mtd_pairing_groups(master);\n\n\t\tmtd->erasesize /= ngroups;\n\t\tmtd->size = (u64)mtd_div_by_eb(mtd->size, master) *\n\t\t\t    mtd->erasesize;\n\t}\n\n\tif (is_power_of_2(mtd->erasesize))\n\t\tmtd->erasesize_shift = ffs(mtd->erasesize) - 1;\n\telse\n\t\tmtd->erasesize_shift = 0;\n\n\tif (is_power_of_2(mtd->writesize))\n\t\tmtd->writesize_shift = ffs(mtd->writesize) - 1;\n\telse\n\t\tmtd->writesize_shift = 0;\n\n\tmtd->erasesize_mask = (1 << mtd->erasesize_shift) - 1;\n\tmtd->writesize_mask = (1 << mtd->writesize_shift) - 1;\n\n\t \n\tif ((mtd->flags & MTD_WRITEABLE) && (mtd->flags & MTD_POWERUP_LOCK)) {\n\t\terror = mtd_unlock(mtd, 0, mtd->size);\n\t\tif (error && error != -EOPNOTSUPP)\n\t\t\tprintk(KERN_WARNING\n\t\t\t       \"%s: unlock failed, writes may not work\\n\",\n\t\t\t       mtd->name);\n\t\t \n\t\terror = 0;\n\t}\n\n\t \n\tmtd->dev.type = &mtd_devtype;\n\tmtd->dev.class = &mtd_class;\n\tmtd->dev.devt = MTD_DEVT(i);\n\tdev_set_name(&mtd->dev, \"mtd%d\", i);\n\tdev_set_drvdata(&mtd->dev, mtd);\n\tmtd_check_of_node(mtd);\n\tof_node_get(mtd_get_of_node(mtd));\n\terror = device_register(&mtd->dev);\n\tif (error) {\n\t\tput_device(&mtd->dev);\n\t\tgoto fail_added;\n\t}\n\n\t \n\terror = mtd_nvmem_add(mtd);\n\tif (error)\n\t\tgoto fail_nvmem_add;\n\n\tmtd_debugfs_populate(mtd);\n\n\tdevice_create(&mtd_class, mtd->dev.parent, MTD_DEVT(i) + 1, NULL,\n\t\t      \"mtd%dro\", i);\n\n\tpr_debug(\"mtd: Giving out device %d to %s\\n\", i, mtd->name);\n\t \n\tlist_for_each_entry(not, &mtd_notifiers, list)\n\t\tnot->add(mtd);\n\n\tmutex_unlock(&mtd_table_mutex);\n\n\tif (of_property_read_bool(mtd_get_of_node(mtd), \"linux,rootfs\")) {\n\t\tif (IS_BUILTIN(CONFIG_MTD)) {\n\t\t\tpr_info(\"mtd: setting mtd%d (%s) as root device\\n\", mtd->index, mtd->name);\n\t\t\tROOT_DEV = MKDEV(MTD_BLOCK_MAJOR, mtd->index);\n\t\t} else {\n\t\t\tpr_warn(\"mtd: can't set mtd%d (%s) as root device - mtd must be builtin\\n\",\n\t\t\t\tmtd->index, mtd->name);\n\t\t}\n\t}\n\n\t \n\t__module_get(THIS_MODULE);\n\treturn 0;\n\nfail_nvmem_add:\n\tdevice_unregister(&mtd->dev);\nfail_added:\n\tof_node_put(mtd_get_of_node(mtd));\n\tidr_remove(&mtd_idr, i);\nfail_locked:\n\tmutex_unlock(&mtd_table_mutex);\n\treturn error;\n}\n\n \n\nint del_mtd_device(struct mtd_info *mtd)\n{\n\tint ret;\n\tstruct mtd_notifier *not;\n\n\tmutex_lock(&mtd_table_mutex);\n\n\tif (idr_find(&mtd_idr, mtd->index) != mtd) {\n\t\tret = -ENODEV;\n\t\tgoto out_error;\n\t}\n\n\t \n\tlist_for_each_entry(not, &mtd_notifiers, list)\n\t\tnot->remove(mtd);\n\n\tkref_put(&mtd->refcnt, mtd_device_release);\n\tret = 0;\n\nout_error:\n\tmutex_unlock(&mtd_table_mutex);\n\treturn ret;\n}\n\n \nstatic void mtd_set_dev_defaults(struct mtd_info *mtd)\n{\n\tif (mtd->dev.parent) {\n\t\tif (!mtd->owner && mtd->dev.parent->driver)\n\t\t\tmtd->owner = mtd->dev.parent->driver->owner;\n\t\tif (!mtd->name)\n\t\t\tmtd->name = dev_name(mtd->dev.parent);\n\t} else {\n\t\tpr_debug(\"mtd device won't show a device symlink in sysfs\\n\");\n\t}\n\n\tINIT_LIST_HEAD(&mtd->partitions);\n\tmutex_init(&mtd->master.partitions_lock);\n\tmutex_init(&mtd->master.chrdev_lock);\n}\n\nstatic ssize_t mtd_otp_size(struct mtd_info *mtd, bool is_user)\n{\n\tstruct otp_info *info;\n\tssize_t size = 0;\n\tunsigned int i;\n\tsize_t retlen;\n\tint ret;\n\n\tinfo = kmalloc(PAGE_SIZE, GFP_KERNEL);\n\tif (!info)\n\t\treturn -ENOMEM;\n\n\tif (is_user)\n\t\tret = mtd_get_user_prot_info(mtd, PAGE_SIZE, &retlen, info);\n\telse\n\t\tret = mtd_get_fact_prot_info(mtd, PAGE_SIZE, &retlen, info);\n\tif (ret)\n\t\tgoto err;\n\n\tfor (i = 0; i < retlen / sizeof(*info); i++)\n\t\tsize += info[i].length;\n\n\tkfree(info);\n\treturn size;\n\nerr:\n\tkfree(info);\n\n\t \n\treturn ret == -ENODATA ? 0 : ret;\n}\n\nstatic struct nvmem_device *mtd_otp_nvmem_register(struct mtd_info *mtd,\n\t\t\t\t\t\t   const char *compatible,\n\t\t\t\t\t\t   int size,\n\t\t\t\t\t\t   nvmem_reg_read_t reg_read)\n{\n\tstruct nvmem_device *nvmem = NULL;\n\tstruct nvmem_config config = {};\n\tstruct device_node *np;\n\n\t \n\tnp = of_get_compatible_child(mtd->dev.of_node, compatible);\n\n\t \n\tconfig.dev = mtd->dev.parent;\n\tconfig.name = compatible;\n\tconfig.id = NVMEM_DEVID_AUTO;\n\tconfig.owner = THIS_MODULE;\n\tconfig.type = NVMEM_TYPE_OTP;\n\tconfig.root_only = true;\n\tconfig.ignore_wp = true;\n\tconfig.reg_read = reg_read;\n\tconfig.size = size;\n\tconfig.of_node = np;\n\tconfig.priv = mtd;\n\n\tnvmem = nvmem_register(&config);\n\t \n\tif (IS_ERR(nvmem) && PTR_ERR(nvmem) == -EOPNOTSUPP)\n\t\tnvmem = NULL;\n\n\tof_node_put(np);\n\n\treturn nvmem;\n}\n\nstatic int mtd_nvmem_user_otp_reg_read(void *priv, unsigned int offset,\n\t\t\t\t       void *val, size_t bytes)\n{\n\tstruct mtd_info *mtd = priv;\n\tsize_t retlen;\n\tint ret;\n\n\tret = mtd_read_user_prot_reg(mtd, offset, bytes, &retlen, val);\n\tif (ret)\n\t\treturn ret;\n\n\treturn retlen == bytes ? 0 : -EIO;\n}\n\nstatic int mtd_nvmem_fact_otp_reg_read(void *priv, unsigned int offset,\n\t\t\t\t       void *val, size_t bytes)\n{\n\tstruct mtd_info *mtd = priv;\n\tsize_t retlen;\n\tint ret;\n\n\tret = mtd_read_fact_prot_reg(mtd, offset, bytes, &retlen, val);\n\tif (ret)\n\t\treturn ret;\n\n\treturn retlen == bytes ? 0 : -EIO;\n}\n\nstatic int mtd_otp_nvmem_add(struct mtd_info *mtd)\n{\n\tstruct device *dev = mtd->dev.parent;\n\tstruct nvmem_device *nvmem;\n\tssize_t size;\n\tint err;\n\n\tif (mtd->_get_user_prot_info && mtd->_read_user_prot_reg) {\n\t\tsize = mtd_otp_size(mtd, true);\n\t\tif (size < 0)\n\t\t\treturn size;\n\n\t\tif (size > 0) {\n\t\t\tnvmem = mtd_otp_nvmem_register(mtd, \"user-otp\", size,\n\t\t\t\t\t\t       mtd_nvmem_user_otp_reg_read);\n\t\t\tif (IS_ERR(nvmem)) {\n\t\t\t\terr = PTR_ERR(nvmem);\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\tmtd->otp_user_nvmem = nvmem;\n\t\t}\n\t}\n\n\tif (mtd->_get_fact_prot_info && mtd->_read_fact_prot_reg) {\n\t\tsize = mtd_otp_size(mtd, false);\n\t\tif (size < 0) {\n\t\t\terr = size;\n\t\t\tgoto err;\n\t\t}\n\n\t\tif (size > 0) {\n\t\t\t \n\t\t\tvoid *otp;\n\n\t\t\totp = kmalloc(size, GFP_KERNEL);\n\t\t\tif (!otp) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\terr = mtd_nvmem_fact_otp_reg_read(mtd, 0, otp, size);\n\t\t\tif (err < 0) {\n\t\t\t\tkfree(otp);\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\tadd_device_randomness(otp, err);\n\t\t\tkfree(otp);\n\n\t\t\tnvmem = mtd_otp_nvmem_register(mtd, \"factory-otp\", size,\n\t\t\t\t\t\t       mtd_nvmem_fact_otp_reg_read);\n\t\t\tif (IS_ERR(nvmem)) {\n\t\t\t\terr = PTR_ERR(nvmem);\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\tmtd->otp_factory_nvmem = nvmem;\n\t\t}\n\t}\n\n\treturn 0;\n\nerr:\n\tnvmem_unregister(mtd->otp_user_nvmem);\n\treturn dev_err_probe(dev, err, \"Failed to register OTP NVMEM device\\n\");\n}\n\n \nint mtd_device_parse_register(struct mtd_info *mtd, const char * const *types,\n\t\t\t      struct mtd_part_parser_data *parser_data,\n\t\t\t      const struct mtd_partition *parts,\n\t\t\t      int nr_parts)\n{\n\tint ret;\n\n\tmtd_set_dev_defaults(mtd);\n\n\tret = mtd_otp_nvmem_add(mtd);\n\tif (ret)\n\t\tgoto out;\n\n\tif (IS_ENABLED(CONFIG_MTD_PARTITIONED_MASTER)) {\n\t\tret = add_mtd_device(mtd);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\t \n\tret = parse_mtd_partitions(mtd, types, parser_data);\n\tif (ret == -EPROBE_DEFER)\n\t\tgoto out;\n\n\tif (ret > 0)\n\t\tret = 0;\n\telse if (nr_parts)\n\t\tret = add_mtd_partitions(mtd, parts, nr_parts);\n\telse if (!device_is_registered(&mtd->dev))\n\t\tret = add_mtd_device(mtd);\n\telse\n\t\tret = 0;\n\n\tif (ret)\n\t\tgoto out;\n\n\t \n\tWARN_ONCE(mtd->_reboot && mtd->reboot_notifier.notifier_call,\n\t\t  \"MTD already registered\\n\");\n\tif (mtd->_reboot && !mtd->reboot_notifier.notifier_call) {\n\t\tmtd->reboot_notifier.notifier_call = mtd_reboot_notifier;\n\t\tregister_reboot_notifier(&mtd->reboot_notifier);\n\t}\n\nout:\n\tif (ret) {\n\t\tnvmem_unregister(mtd->otp_user_nvmem);\n\t\tnvmem_unregister(mtd->otp_factory_nvmem);\n\t}\n\n\tif (ret && device_is_registered(&mtd->dev))\n\t\tdel_mtd_device(mtd);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(mtd_device_parse_register);\n\n \nint mtd_device_unregister(struct mtd_info *master)\n{\n\tint err;\n\n\tif (master->_reboot) {\n\t\tunregister_reboot_notifier(&master->reboot_notifier);\n\t\tmemset(&master->reboot_notifier, 0, sizeof(master->reboot_notifier));\n\t}\n\n\tnvmem_unregister(master->otp_user_nvmem);\n\tnvmem_unregister(master->otp_factory_nvmem);\n\n\terr = del_mtd_partitions(master);\n\tif (err)\n\t\treturn err;\n\n\tif (!device_is_registered(&master->dev))\n\t\treturn 0;\n\n\treturn del_mtd_device(master);\n}\nEXPORT_SYMBOL_GPL(mtd_device_unregister);\n\n \nvoid register_mtd_user (struct mtd_notifier *new)\n{\n\tstruct mtd_info *mtd;\n\n\tmutex_lock(&mtd_table_mutex);\n\n\tlist_add(&new->list, &mtd_notifiers);\n\n\t__module_get(THIS_MODULE);\n\n\tmtd_for_each_device(mtd)\n\t\tnew->add(mtd);\n\n\tmutex_unlock(&mtd_table_mutex);\n}\nEXPORT_SYMBOL_GPL(register_mtd_user);\n\n \nint unregister_mtd_user (struct mtd_notifier *old)\n{\n\tstruct mtd_info *mtd;\n\n\tmutex_lock(&mtd_table_mutex);\n\n\tmodule_put(THIS_MODULE);\n\n\tmtd_for_each_device(mtd)\n\t\told->remove(mtd);\n\n\tlist_del(&old->list);\n\tmutex_unlock(&mtd_table_mutex);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(unregister_mtd_user);\n\n \nstruct mtd_info *get_mtd_device(struct mtd_info *mtd, int num)\n{\n\tstruct mtd_info *ret = NULL, *other;\n\tint err = -ENODEV;\n\n\tmutex_lock(&mtd_table_mutex);\n\n\tif (num == -1) {\n\t\tmtd_for_each_device(other) {\n\t\t\tif (other == mtd) {\n\t\t\t\tret = mtd;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else if (num >= 0) {\n\t\tret = idr_find(&mtd_idr, num);\n\t\tif (mtd && mtd != ret)\n\t\t\tret = NULL;\n\t}\n\n\tif (!ret) {\n\t\tret = ERR_PTR(err);\n\t\tgoto out;\n\t}\n\n\terr = __get_mtd_device(ret);\n\tif (err)\n\t\tret = ERR_PTR(err);\nout:\n\tmutex_unlock(&mtd_table_mutex);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(get_mtd_device);\n\n\nint __get_mtd_device(struct mtd_info *mtd)\n{\n\tstruct mtd_info *master = mtd_get_master(mtd);\n\tint err;\n\n\tif (master->_get_device) {\n\t\terr = master->_get_device(mtd);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (!try_module_get(master->owner)) {\n\t\tif (master->_put_device)\n\t\t\tmaster->_put_device(master);\n\t\treturn -ENODEV;\n\t}\n\n\twhile (mtd) {\n\t\tif (mtd != master)\n\t\t\tkref_get(&mtd->refcnt);\n\t\tmtd = mtd->parent;\n\t}\n\n\tif (IS_ENABLED(CONFIG_MTD_PARTITIONED_MASTER))\n\t\tkref_get(&master->refcnt);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(__get_mtd_device);\n\n \nstruct mtd_info *of_get_mtd_device_by_node(struct device_node *np)\n{\n\tstruct mtd_info *mtd = NULL;\n\tstruct mtd_info *tmp;\n\tint err;\n\n\tmutex_lock(&mtd_table_mutex);\n\n\terr = -EPROBE_DEFER;\n\tmtd_for_each_device(tmp) {\n\t\tif (mtd_get_of_node(tmp) == np) {\n\t\t\tmtd = tmp;\n\t\t\terr = __get_mtd_device(mtd);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tmutex_unlock(&mtd_table_mutex);\n\n\treturn err ? ERR_PTR(err) : mtd;\n}\nEXPORT_SYMBOL_GPL(of_get_mtd_device_by_node);\n\n \nstruct mtd_info *get_mtd_device_nm(const char *name)\n{\n\tint err = -ENODEV;\n\tstruct mtd_info *mtd = NULL, *other;\n\n\tmutex_lock(&mtd_table_mutex);\n\n\tmtd_for_each_device(other) {\n\t\tif (!strcmp(name, other->name)) {\n\t\t\tmtd = other;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!mtd)\n\t\tgoto out_unlock;\n\n\terr = __get_mtd_device(mtd);\n\tif (err)\n\t\tgoto out_unlock;\n\n\tmutex_unlock(&mtd_table_mutex);\n\treturn mtd;\n\nout_unlock:\n\tmutex_unlock(&mtd_table_mutex);\n\treturn ERR_PTR(err);\n}\nEXPORT_SYMBOL_GPL(get_mtd_device_nm);\n\nvoid put_mtd_device(struct mtd_info *mtd)\n{\n\tmutex_lock(&mtd_table_mutex);\n\t__put_mtd_device(mtd);\n\tmutex_unlock(&mtd_table_mutex);\n\n}\nEXPORT_SYMBOL_GPL(put_mtd_device);\n\nvoid __put_mtd_device(struct mtd_info *mtd)\n{\n\tstruct mtd_info *master = mtd_get_master(mtd);\n\n\twhile (mtd) {\n\t\t \n\t\tstruct mtd_info *parent = mtd->parent;\n\n\t\tif (mtd != master)\n\t\t\tkref_put(&mtd->refcnt, mtd_device_release);\n\t\tmtd = parent;\n\t}\n\n\tif (IS_ENABLED(CONFIG_MTD_PARTITIONED_MASTER))\n\t\tkref_put(&master->refcnt, mtd_device_release);\n\n\tmodule_put(master->owner);\n\n\t \n\tif (master->_put_device)\n\t\tmaster->_put_device(master);\n}\nEXPORT_SYMBOL_GPL(__put_mtd_device);\n\n \nint mtd_erase(struct mtd_info *mtd, struct erase_info *instr)\n{\n\tstruct mtd_info *master = mtd_get_master(mtd);\n\tu64 mst_ofs = mtd_get_master_ofs(mtd, 0);\n\tstruct erase_info adjinstr;\n\tint ret;\n\n\tinstr->fail_addr = MTD_FAIL_ADDR_UNKNOWN;\n\tadjinstr = *instr;\n\n\tif (!mtd->erasesize || !master->_erase)\n\t\treturn -ENOTSUPP;\n\n\tif (instr->addr >= mtd->size || instr->len > mtd->size - instr->addr)\n\t\treturn -EINVAL;\n\tif (!(mtd->flags & MTD_WRITEABLE))\n\t\treturn -EROFS;\n\n\tif (!instr->len)\n\t\treturn 0;\n\n\tledtrig_mtd_activity();\n\n\tif (mtd->flags & MTD_SLC_ON_MLC_EMULATION) {\n\t\tadjinstr.addr = (loff_t)mtd_div_by_eb(instr->addr, mtd) *\n\t\t\t\tmaster->erasesize;\n\t\tadjinstr.len = ((u64)mtd_div_by_eb(instr->addr + instr->len, mtd) *\n\t\t\t\tmaster->erasesize) -\n\t\t\t       adjinstr.addr;\n\t}\n\n\tadjinstr.addr += mst_ofs;\n\n\tret = master->_erase(master, &adjinstr);\n\n\tif (adjinstr.fail_addr != MTD_FAIL_ADDR_UNKNOWN) {\n\t\tinstr->fail_addr = adjinstr.fail_addr - mst_ofs;\n\t\tif (mtd->flags & MTD_SLC_ON_MLC_EMULATION) {\n\t\t\tinstr->fail_addr = mtd_div_by_eb(instr->fail_addr,\n\t\t\t\t\t\t\t master);\n\t\t\tinstr->fail_addr *= mtd->erasesize;\n\t\t}\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(mtd_erase);\n\n \nint mtd_point(struct mtd_info *mtd, loff_t from, size_t len, size_t *retlen,\n\t      void **virt, resource_size_t *phys)\n{\n\tstruct mtd_info *master = mtd_get_master(mtd);\n\n\t*retlen = 0;\n\t*virt = NULL;\n\tif (phys)\n\t\t*phys = 0;\n\tif (!master->_point)\n\t\treturn -EOPNOTSUPP;\n\tif (from < 0 || from >= mtd->size || len > mtd->size - from)\n\t\treturn -EINVAL;\n\tif (!len)\n\t\treturn 0;\n\n\tfrom = mtd_get_master_ofs(mtd, from);\n\treturn master->_point(master, from, len, retlen, virt, phys);\n}\nEXPORT_SYMBOL_GPL(mtd_point);\n\n \nint mtd_unpoint(struct mtd_info *mtd, loff_t from, size_t len)\n{\n\tstruct mtd_info *master = mtd_get_master(mtd);\n\n\tif (!master->_unpoint)\n\t\treturn -EOPNOTSUPP;\n\tif (from < 0 || from >= mtd->size || len > mtd->size - from)\n\t\treturn -EINVAL;\n\tif (!len)\n\t\treturn 0;\n\treturn master->_unpoint(master, mtd_get_master_ofs(mtd, from), len);\n}\nEXPORT_SYMBOL_GPL(mtd_unpoint);\n\n \nunsigned long mtd_get_unmapped_area(struct mtd_info *mtd, unsigned long len,\n\t\t\t\t    unsigned long offset, unsigned long flags)\n{\n\tsize_t retlen;\n\tvoid *virt;\n\tint ret;\n\n\tret = mtd_point(mtd, offset, len, &retlen, &virt, NULL);\n\tif (ret)\n\t\treturn ret;\n\tif (retlen != len) {\n\t\tmtd_unpoint(mtd, offset, retlen);\n\t\treturn -ENOSYS;\n\t}\n\treturn (unsigned long)virt;\n}\nEXPORT_SYMBOL_GPL(mtd_get_unmapped_area);\n\nstatic void mtd_update_ecc_stats(struct mtd_info *mtd, struct mtd_info *master,\n\t\t\t\t const struct mtd_ecc_stats *old_stats)\n{\n\tstruct mtd_ecc_stats diff;\n\n\tif (master == mtd)\n\t\treturn;\n\n\tdiff = master->ecc_stats;\n\tdiff.failed -= old_stats->failed;\n\tdiff.corrected -= old_stats->corrected;\n\n\twhile (mtd->parent) {\n\t\tmtd->ecc_stats.failed += diff.failed;\n\t\tmtd->ecc_stats.corrected += diff.corrected;\n\t\tmtd = mtd->parent;\n\t}\n}\n\nint mtd_read(struct mtd_info *mtd, loff_t from, size_t len, size_t *retlen,\n\t     u_char *buf)\n{\n\tstruct mtd_oob_ops ops = {\n\t\t.len = len,\n\t\t.datbuf = buf,\n\t};\n\tint ret;\n\n\tret = mtd_read_oob(mtd, from, &ops);\n\t*retlen = ops.retlen;\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(mtd_read);\n\nint mtd_write(struct mtd_info *mtd, loff_t to, size_t len, size_t *retlen,\n\t      const u_char *buf)\n{\n\tstruct mtd_oob_ops ops = {\n\t\t.len = len,\n\t\t.datbuf = (u8 *)buf,\n\t};\n\tint ret;\n\n\tret = mtd_write_oob(mtd, to, &ops);\n\t*retlen = ops.retlen;\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(mtd_write);\n\n \nint mtd_panic_write(struct mtd_info *mtd, loff_t to, size_t len, size_t *retlen,\n\t\t    const u_char *buf)\n{\n\tstruct mtd_info *master = mtd_get_master(mtd);\n\n\t*retlen = 0;\n\tif (!master->_panic_write)\n\t\treturn -EOPNOTSUPP;\n\tif (to < 0 || to >= mtd->size || len > mtd->size - to)\n\t\treturn -EINVAL;\n\tif (!(mtd->flags & MTD_WRITEABLE))\n\t\treturn -EROFS;\n\tif (!len)\n\t\treturn 0;\n\tif (!master->oops_panic_write)\n\t\tmaster->oops_panic_write = true;\n\n\treturn master->_panic_write(master, mtd_get_master_ofs(mtd, to), len,\n\t\t\t\t    retlen, buf);\n}\nEXPORT_SYMBOL_GPL(mtd_panic_write);\n\nstatic int mtd_check_oob_ops(struct mtd_info *mtd, loff_t offs,\n\t\t\t     struct mtd_oob_ops *ops)\n{\n\t \n\tif (!ops->datbuf)\n\t\tops->len = 0;\n\n\tif (!ops->oobbuf)\n\t\tops->ooblen = 0;\n\n\tif (offs < 0 || offs + ops->len > mtd->size)\n\t\treturn -EINVAL;\n\n\tif (ops->ooblen) {\n\t\tsize_t maxooblen;\n\n\t\tif (ops->ooboffs >= mtd_oobavail(mtd, ops))\n\t\t\treturn -EINVAL;\n\n\t\tmaxooblen = ((size_t)(mtd_div_by_ws(mtd->size, mtd) -\n\t\t\t\t      mtd_div_by_ws(offs, mtd)) *\n\t\t\t     mtd_oobavail(mtd, ops)) - ops->ooboffs;\n\t\tif (ops->ooblen > maxooblen)\n\t\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int mtd_read_oob_std(struct mtd_info *mtd, loff_t from,\n\t\t\t    struct mtd_oob_ops *ops)\n{\n\tstruct mtd_info *master = mtd_get_master(mtd);\n\tint ret;\n\n\tfrom = mtd_get_master_ofs(mtd, from);\n\tif (master->_read_oob)\n\t\tret = master->_read_oob(master, from, ops);\n\telse\n\t\tret = master->_read(master, from, ops->len, &ops->retlen,\n\t\t\t\t    ops->datbuf);\n\n\treturn ret;\n}\n\nstatic int mtd_write_oob_std(struct mtd_info *mtd, loff_t to,\n\t\t\t     struct mtd_oob_ops *ops)\n{\n\tstruct mtd_info *master = mtd_get_master(mtd);\n\tint ret;\n\n\tto = mtd_get_master_ofs(mtd, to);\n\tif (master->_write_oob)\n\t\tret = master->_write_oob(master, to, ops);\n\telse\n\t\tret = master->_write(master, to, ops->len, &ops->retlen,\n\t\t\t\t     ops->datbuf);\n\n\treturn ret;\n}\n\nstatic int mtd_io_emulated_slc(struct mtd_info *mtd, loff_t start, bool read,\n\t\t\t       struct mtd_oob_ops *ops)\n{\n\tstruct mtd_info *master = mtd_get_master(mtd);\n\tint ngroups = mtd_pairing_groups(master);\n\tint npairs = mtd_wunit_per_eb(master) / ngroups;\n\tstruct mtd_oob_ops adjops = *ops;\n\tunsigned int wunit, oobavail;\n\tstruct mtd_pairing_info info;\n\tint max_bitflips = 0;\n\tu32 ebofs, pageofs;\n\tloff_t base, pos;\n\n\tebofs = mtd_mod_by_eb(start, mtd);\n\tbase = (loff_t)mtd_div_by_eb(start, mtd) * master->erasesize;\n\tinfo.group = 0;\n\tinfo.pair = mtd_div_by_ws(ebofs, mtd);\n\tpageofs = mtd_mod_by_ws(ebofs, mtd);\n\toobavail = mtd_oobavail(mtd, ops);\n\n\twhile (ops->retlen < ops->len || ops->oobretlen < ops->ooblen) {\n\t\tint ret;\n\n\t\tif (info.pair >= npairs) {\n\t\t\tinfo.pair = 0;\n\t\t\tbase += master->erasesize;\n\t\t}\n\n\t\twunit = mtd_pairing_info_to_wunit(master, &info);\n\t\tpos = mtd_wunit_to_offset(mtd, base, wunit);\n\n\t\tadjops.len = ops->len - ops->retlen;\n\t\tif (adjops.len > mtd->writesize - pageofs)\n\t\t\tadjops.len = mtd->writesize - pageofs;\n\n\t\tadjops.ooblen = ops->ooblen - ops->oobretlen;\n\t\tif (adjops.ooblen > oobavail - adjops.ooboffs)\n\t\t\tadjops.ooblen = oobavail - adjops.ooboffs;\n\n\t\tif (read) {\n\t\t\tret = mtd_read_oob_std(mtd, pos + pageofs, &adjops);\n\t\t\tif (ret > 0)\n\t\t\t\tmax_bitflips = max(max_bitflips, ret);\n\t\t} else {\n\t\t\tret = mtd_write_oob_std(mtd, pos + pageofs, &adjops);\n\t\t}\n\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tmax_bitflips = max(max_bitflips, ret);\n\t\tops->retlen += adjops.retlen;\n\t\tops->oobretlen += adjops.oobretlen;\n\t\tadjops.datbuf += adjops.retlen;\n\t\tadjops.oobbuf += adjops.oobretlen;\n\t\tadjops.ooboffs = 0;\n\t\tpageofs = 0;\n\t\tinfo.pair++;\n\t}\n\n\treturn max_bitflips;\n}\n\nint mtd_read_oob(struct mtd_info *mtd, loff_t from, struct mtd_oob_ops *ops)\n{\n\tstruct mtd_info *master = mtd_get_master(mtd);\n\tstruct mtd_ecc_stats old_stats = master->ecc_stats;\n\tint ret_code;\n\n\tops->retlen = ops->oobretlen = 0;\n\n\tret_code = mtd_check_oob_ops(mtd, from, ops);\n\tif (ret_code)\n\t\treturn ret_code;\n\n\tledtrig_mtd_activity();\n\n\t \n\tif (!master->_read_oob && (!master->_read || ops->oobbuf))\n\t\treturn -EOPNOTSUPP;\n\n\tif (ops->stats)\n\t\tmemset(ops->stats, 0, sizeof(*ops->stats));\n\n\tif (mtd->flags & MTD_SLC_ON_MLC_EMULATION)\n\t\tret_code = mtd_io_emulated_slc(mtd, from, true, ops);\n\telse\n\t\tret_code = mtd_read_oob_std(mtd, from, ops);\n\n\tmtd_update_ecc_stats(mtd, master, &old_stats);\n\n\t \n\tif (unlikely(ret_code < 0))\n\t\treturn ret_code;\n\tif (mtd->ecc_strength == 0)\n\t\treturn 0;\t \n\tif (ops->stats)\n\t\tops->stats->max_bitflips = ret_code;\n\treturn ret_code >= mtd->bitflip_threshold ? -EUCLEAN : 0;\n}\nEXPORT_SYMBOL_GPL(mtd_read_oob);\n\nint mtd_write_oob(struct mtd_info *mtd, loff_t to,\n\t\t\t\tstruct mtd_oob_ops *ops)\n{\n\tstruct mtd_info *master = mtd_get_master(mtd);\n\tint ret;\n\n\tops->retlen = ops->oobretlen = 0;\n\n\tif (!(mtd->flags & MTD_WRITEABLE))\n\t\treturn -EROFS;\n\n\tret = mtd_check_oob_ops(mtd, to, ops);\n\tif (ret)\n\t\treturn ret;\n\n\tledtrig_mtd_activity();\n\n\t \n\tif (!master->_write_oob && (!master->_write || ops->oobbuf))\n\t\treturn -EOPNOTSUPP;\n\n\tif (mtd->flags & MTD_SLC_ON_MLC_EMULATION)\n\t\treturn mtd_io_emulated_slc(mtd, to, false, ops);\n\n\treturn mtd_write_oob_std(mtd, to, ops);\n}\nEXPORT_SYMBOL_GPL(mtd_write_oob);\n\n \nint mtd_ooblayout_ecc(struct mtd_info *mtd, int section,\n\t\t      struct mtd_oob_region *oobecc)\n{\n\tstruct mtd_info *master = mtd_get_master(mtd);\n\n\tmemset(oobecc, 0, sizeof(*oobecc));\n\n\tif (!master || section < 0)\n\t\treturn -EINVAL;\n\n\tif (!master->ooblayout || !master->ooblayout->ecc)\n\t\treturn -ENOTSUPP;\n\n\treturn master->ooblayout->ecc(master, section, oobecc);\n}\nEXPORT_SYMBOL_GPL(mtd_ooblayout_ecc);\n\n \nint mtd_ooblayout_free(struct mtd_info *mtd, int section,\n\t\t       struct mtd_oob_region *oobfree)\n{\n\tstruct mtd_info *master = mtd_get_master(mtd);\n\n\tmemset(oobfree, 0, sizeof(*oobfree));\n\n\tif (!master || section < 0)\n\t\treturn -EINVAL;\n\n\tif (!master->ooblayout || !master->ooblayout->free)\n\t\treturn -ENOTSUPP;\n\n\treturn master->ooblayout->free(master, section, oobfree);\n}\nEXPORT_SYMBOL_GPL(mtd_ooblayout_free);\n\n \nstatic int mtd_ooblayout_find_region(struct mtd_info *mtd, int byte,\n\t\t\t\tint *sectionp, struct mtd_oob_region *oobregion,\n\t\t\t\tint (*iter)(struct mtd_info *,\n\t\t\t\t\t    int section,\n\t\t\t\t\t    struct mtd_oob_region *oobregion))\n{\n\tint pos = 0, ret, section = 0;\n\n\tmemset(oobregion, 0, sizeof(*oobregion));\n\n\twhile (1) {\n\t\tret = iter(mtd, section, oobregion);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (pos + oobregion->length > byte)\n\t\t\tbreak;\n\n\t\tpos += oobregion->length;\n\t\tsection++;\n\t}\n\n\t \n\toobregion->offset += byte - pos;\n\toobregion->length -= byte - pos;\n\t*sectionp = section;\n\n\treturn 0;\n}\n\n \nint mtd_ooblayout_find_eccregion(struct mtd_info *mtd, int eccbyte,\n\t\t\t\t int *section,\n\t\t\t\t struct mtd_oob_region *oobregion)\n{\n\treturn mtd_ooblayout_find_region(mtd, eccbyte, section, oobregion,\n\t\t\t\t\t mtd_ooblayout_ecc);\n}\nEXPORT_SYMBOL_GPL(mtd_ooblayout_find_eccregion);\n\n \nstatic int mtd_ooblayout_get_bytes(struct mtd_info *mtd, u8 *buf,\n\t\t\t\tconst u8 *oobbuf, int start, int nbytes,\n\t\t\t\tint (*iter)(struct mtd_info *,\n\t\t\t\t\t    int section,\n\t\t\t\t\t    struct mtd_oob_region *oobregion))\n{\n\tstruct mtd_oob_region oobregion;\n\tint section, ret;\n\n\tret = mtd_ooblayout_find_region(mtd, start, &section,\n\t\t\t\t\t&oobregion, iter);\n\n\twhile (!ret) {\n\t\tint cnt;\n\n\t\tcnt = min_t(int, nbytes, oobregion.length);\n\t\tmemcpy(buf, oobbuf + oobregion.offset, cnt);\n\t\tbuf += cnt;\n\t\tnbytes -= cnt;\n\n\t\tif (!nbytes)\n\t\t\tbreak;\n\n\t\tret = iter(mtd, ++section, &oobregion);\n\t}\n\n\treturn ret;\n}\n\n \nstatic int mtd_ooblayout_set_bytes(struct mtd_info *mtd, const u8 *buf,\n\t\t\t\tu8 *oobbuf, int start, int nbytes,\n\t\t\t\tint (*iter)(struct mtd_info *,\n\t\t\t\t\t    int section,\n\t\t\t\t\t    struct mtd_oob_region *oobregion))\n{\n\tstruct mtd_oob_region oobregion;\n\tint section, ret;\n\n\tret = mtd_ooblayout_find_region(mtd, start, &section,\n\t\t\t\t\t&oobregion, iter);\n\n\twhile (!ret) {\n\t\tint cnt;\n\n\t\tcnt = min_t(int, nbytes, oobregion.length);\n\t\tmemcpy(oobbuf + oobregion.offset, buf, cnt);\n\t\tbuf += cnt;\n\t\tnbytes -= cnt;\n\n\t\tif (!nbytes)\n\t\t\tbreak;\n\n\t\tret = iter(mtd, ++section, &oobregion);\n\t}\n\n\treturn ret;\n}\n\n \nstatic int mtd_ooblayout_count_bytes(struct mtd_info *mtd,\n\t\t\t\tint (*iter)(struct mtd_info *,\n\t\t\t\t\t    int section,\n\t\t\t\t\t    struct mtd_oob_region *oobregion))\n{\n\tstruct mtd_oob_region oobregion;\n\tint section = 0, ret, nbytes = 0;\n\n\twhile (1) {\n\t\tret = iter(mtd, section++, &oobregion);\n\t\tif (ret) {\n\t\t\tif (ret == -ERANGE)\n\t\t\t\tret = nbytes;\n\t\t\tbreak;\n\t\t}\n\n\t\tnbytes += oobregion.length;\n\t}\n\n\treturn ret;\n}\n\n \nint mtd_ooblayout_get_eccbytes(struct mtd_info *mtd, u8 *eccbuf,\n\t\t\t       const u8 *oobbuf, int start, int nbytes)\n{\n\treturn mtd_ooblayout_get_bytes(mtd, eccbuf, oobbuf, start, nbytes,\n\t\t\t\t       mtd_ooblayout_ecc);\n}\nEXPORT_SYMBOL_GPL(mtd_ooblayout_get_eccbytes);\n\n \nint mtd_ooblayout_set_eccbytes(struct mtd_info *mtd, const u8 *eccbuf,\n\t\t\t       u8 *oobbuf, int start, int nbytes)\n{\n\treturn mtd_ooblayout_set_bytes(mtd, eccbuf, oobbuf, start, nbytes,\n\t\t\t\t       mtd_ooblayout_ecc);\n}\nEXPORT_SYMBOL_GPL(mtd_ooblayout_set_eccbytes);\n\n \nint mtd_ooblayout_get_databytes(struct mtd_info *mtd, u8 *databuf,\n\t\t\t\tconst u8 *oobbuf, int start, int nbytes)\n{\n\treturn mtd_ooblayout_get_bytes(mtd, databuf, oobbuf, start, nbytes,\n\t\t\t\t       mtd_ooblayout_free);\n}\nEXPORT_SYMBOL_GPL(mtd_ooblayout_get_databytes);\n\n \nint mtd_ooblayout_set_databytes(struct mtd_info *mtd, const u8 *databuf,\n\t\t\t\tu8 *oobbuf, int start, int nbytes)\n{\n\treturn mtd_ooblayout_set_bytes(mtd, databuf, oobbuf, start, nbytes,\n\t\t\t\t       mtd_ooblayout_free);\n}\nEXPORT_SYMBOL_GPL(mtd_ooblayout_set_databytes);\n\n \nint mtd_ooblayout_count_freebytes(struct mtd_info *mtd)\n{\n\treturn mtd_ooblayout_count_bytes(mtd, mtd_ooblayout_free);\n}\nEXPORT_SYMBOL_GPL(mtd_ooblayout_count_freebytes);\n\n \nint mtd_ooblayout_count_eccbytes(struct mtd_info *mtd)\n{\n\treturn mtd_ooblayout_count_bytes(mtd, mtd_ooblayout_ecc);\n}\nEXPORT_SYMBOL_GPL(mtd_ooblayout_count_eccbytes);\n\n \nint mtd_get_fact_prot_info(struct mtd_info *mtd, size_t len, size_t *retlen,\n\t\t\t   struct otp_info *buf)\n{\n\tstruct mtd_info *master = mtd_get_master(mtd);\n\n\tif (!master->_get_fact_prot_info)\n\t\treturn -EOPNOTSUPP;\n\tif (!len)\n\t\treturn 0;\n\treturn master->_get_fact_prot_info(master, len, retlen, buf);\n}\nEXPORT_SYMBOL_GPL(mtd_get_fact_prot_info);\n\nint mtd_read_fact_prot_reg(struct mtd_info *mtd, loff_t from, size_t len,\n\t\t\t   size_t *retlen, u_char *buf)\n{\n\tstruct mtd_info *master = mtd_get_master(mtd);\n\n\t*retlen = 0;\n\tif (!master->_read_fact_prot_reg)\n\t\treturn -EOPNOTSUPP;\n\tif (!len)\n\t\treturn 0;\n\treturn master->_read_fact_prot_reg(master, from, len, retlen, buf);\n}\nEXPORT_SYMBOL_GPL(mtd_read_fact_prot_reg);\n\nint mtd_get_user_prot_info(struct mtd_info *mtd, size_t len, size_t *retlen,\n\t\t\t   struct otp_info *buf)\n{\n\tstruct mtd_info *master = mtd_get_master(mtd);\n\n\tif (!master->_get_user_prot_info)\n\t\treturn -EOPNOTSUPP;\n\tif (!len)\n\t\treturn 0;\n\treturn master->_get_user_prot_info(master, len, retlen, buf);\n}\nEXPORT_SYMBOL_GPL(mtd_get_user_prot_info);\n\nint mtd_read_user_prot_reg(struct mtd_info *mtd, loff_t from, size_t len,\n\t\t\t   size_t *retlen, u_char *buf)\n{\n\tstruct mtd_info *master = mtd_get_master(mtd);\n\n\t*retlen = 0;\n\tif (!master->_read_user_prot_reg)\n\t\treturn -EOPNOTSUPP;\n\tif (!len)\n\t\treturn 0;\n\treturn master->_read_user_prot_reg(master, from, len, retlen, buf);\n}\nEXPORT_SYMBOL_GPL(mtd_read_user_prot_reg);\n\nint mtd_write_user_prot_reg(struct mtd_info *mtd, loff_t to, size_t len,\n\t\t\t    size_t *retlen, const u_char *buf)\n{\n\tstruct mtd_info *master = mtd_get_master(mtd);\n\tint ret;\n\n\t*retlen = 0;\n\tif (!master->_write_user_prot_reg)\n\t\treturn -EOPNOTSUPP;\n\tif (!len)\n\t\treturn 0;\n\tret = master->_write_user_prot_reg(master, to, len, retlen, buf);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\treturn (*retlen) ? 0 : -ENOSPC;\n}\nEXPORT_SYMBOL_GPL(mtd_write_user_prot_reg);\n\nint mtd_lock_user_prot_reg(struct mtd_info *mtd, loff_t from, size_t len)\n{\n\tstruct mtd_info *master = mtd_get_master(mtd);\n\n\tif (!master->_lock_user_prot_reg)\n\t\treturn -EOPNOTSUPP;\n\tif (!len)\n\t\treturn 0;\n\treturn master->_lock_user_prot_reg(master, from, len);\n}\nEXPORT_SYMBOL_GPL(mtd_lock_user_prot_reg);\n\nint mtd_erase_user_prot_reg(struct mtd_info *mtd, loff_t from, size_t len)\n{\n\tstruct mtd_info *master = mtd_get_master(mtd);\n\n\tif (!master->_erase_user_prot_reg)\n\t\treturn -EOPNOTSUPP;\n\tif (!len)\n\t\treturn 0;\n\treturn master->_erase_user_prot_reg(master, from, len);\n}\nEXPORT_SYMBOL_GPL(mtd_erase_user_prot_reg);\n\n \nint mtd_lock(struct mtd_info *mtd, loff_t ofs, uint64_t len)\n{\n\tstruct mtd_info *master = mtd_get_master(mtd);\n\n\tif (!master->_lock)\n\t\treturn -EOPNOTSUPP;\n\tif (ofs < 0 || ofs >= mtd->size || len > mtd->size - ofs)\n\t\treturn -EINVAL;\n\tif (!len)\n\t\treturn 0;\n\n\tif (mtd->flags & MTD_SLC_ON_MLC_EMULATION) {\n\t\tofs = (loff_t)mtd_div_by_eb(ofs, mtd) * master->erasesize;\n\t\tlen = (u64)mtd_div_by_eb(len, mtd) * master->erasesize;\n\t}\n\n\treturn master->_lock(master, mtd_get_master_ofs(mtd, ofs), len);\n}\nEXPORT_SYMBOL_GPL(mtd_lock);\n\nint mtd_unlock(struct mtd_info *mtd, loff_t ofs, uint64_t len)\n{\n\tstruct mtd_info *master = mtd_get_master(mtd);\n\n\tif (!master->_unlock)\n\t\treturn -EOPNOTSUPP;\n\tif (ofs < 0 || ofs >= mtd->size || len > mtd->size - ofs)\n\t\treturn -EINVAL;\n\tif (!len)\n\t\treturn 0;\n\n\tif (mtd->flags & MTD_SLC_ON_MLC_EMULATION) {\n\t\tofs = (loff_t)mtd_div_by_eb(ofs, mtd) * master->erasesize;\n\t\tlen = (u64)mtd_div_by_eb(len, mtd) * master->erasesize;\n\t}\n\n\treturn master->_unlock(master, mtd_get_master_ofs(mtd, ofs), len);\n}\nEXPORT_SYMBOL_GPL(mtd_unlock);\n\nint mtd_is_locked(struct mtd_info *mtd, loff_t ofs, uint64_t len)\n{\n\tstruct mtd_info *master = mtd_get_master(mtd);\n\n\tif (!master->_is_locked)\n\t\treturn -EOPNOTSUPP;\n\tif (ofs < 0 || ofs >= mtd->size || len > mtd->size - ofs)\n\t\treturn -EINVAL;\n\tif (!len)\n\t\treturn 0;\n\n\tif (mtd->flags & MTD_SLC_ON_MLC_EMULATION) {\n\t\tofs = (loff_t)mtd_div_by_eb(ofs, mtd) * master->erasesize;\n\t\tlen = (u64)mtd_div_by_eb(len, mtd) * master->erasesize;\n\t}\n\n\treturn master->_is_locked(master, mtd_get_master_ofs(mtd, ofs), len);\n}\nEXPORT_SYMBOL_GPL(mtd_is_locked);\n\nint mtd_block_isreserved(struct mtd_info *mtd, loff_t ofs)\n{\n\tstruct mtd_info *master = mtd_get_master(mtd);\n\n\tif (ofs < 0 || ofs >= mtd->size)\n\t\treturn -EINVAL;\n\tif (!master->_block_isreserved)\n\t\treturn 0;\n\n\tif (mtd->flags & MTD_SLC_ON_MLC_EMULATION)\n\t\tofs = (loff_t)mtd_div_by_eb(ofs, mtd) * master->erasesize;\n\n\treturn master->_block_isreserved(master, mtd_get_master_ofs(mtd, ofs));\n}\nEXPORT_SYMBOL_GPL(mtd_block_isreserved);\n\nint mtd_block_isbad(struct mtd_info *mtd, loff_t ofs)\n{\n\tstruct mtd_info *master = mtd_get_master(mtd);\n\n\tif (ofs < 0 || ofs >= mtd->size)\n\t\treturn -EINVAL;\n\tif (!master->_block_isbad)\n\t\treturn 0;\n\n\tif (mtd->flags & MTD_SLC_ON_MLC_EMULATION)\n\t\tofs = (loff_t)mtd_div_by_eb(ofs, mtd) * master->erasesize;\n\n\treturn master->_block_isbad(master, mtd_get_master_ofs(mtd, ofs));\n}\nEXPORT_SYMBOL_GPL(mtd_block_isbad);\n\nint mtd_block_markbad(struct mtd_info *mtd, loff_t ofs)\n{\n\tstruct mtd_info *master = mtd_get_master(mtd);\n\tint ret;\n\n\tif (!master->_block_markbad)\n\t\treturn -EOPNOTSUPP;\n\tif (ofs < 0 || ofs >= mtd->size)\n\t\treturn -EINVAL;\n\tif (!(mtd->flags & MTD_WRITEABLE))\n\t\treturn -EROFS;\n\n\tif (mtd->flags & MTD_SLC_ON_MLC_EMULATION)\n\t\tofs = (loff_t)mtd_div_by_eb(ofs, mtd) * master->erasesize;\n\n\tret = master->_block_markbad(master, mtd_get_master_ofs(mtd, ofs));\n\tif (ret)\n\t\treturn ret;\n\n\twhile (mtd->parent) {\n\t\tmtd->ecc_stats.badblocks++;\n\t\tmtd = mtd->parent;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(mtd_block_markbad);\n\n \nstatic int default_mtd_writev(struct mtd_info *mtd, const struct kvec *vecs,\n\t\t\t      unsigned long count, loff_t to, size_t *retlen)\n{\n\tunsigned long i;\n\tsize_t totlen = 0, thislen;\n\tint ret = 0;\n\n\tfor (i = 0; i < count; i++) {\n\t\tif (!vecs[i].iov_len)\n\t\t\tcontinue;\n\t\tret = mtd_write(mtd, to, vecs[i].iov_len, &thislen,\n\t\t\t\tvecs[i].iov_base);\n\t\ttotlen += thislen;\n\t\tif (ret || thislen != vecs[i].iov_len)\n\t\t\tbreak;\n\t\tto += vecs[i].iov_len;\n\t}\n\t*retlen = totlen;\n\treturn ret;\n}\n\n \nint mtd_writev(struct mtd_info *mtd, const struct kvec *vecs,\n\t       unsigned long count, loff_t to, size_t *retlen)\n{\n\tstruct mtd_info *master = mtd_get_master(mtd);\n\n\t*retlen = 0;\n\tif (!(mtd->flags & MTD_WRITEABLE))\n\t\treturn -EROFS;\n\n\tif (!master->_writev)\n\t\treturn default_mtd_writev(mtd, vecs, count, to, retlen);\n\n\treturn master->_writev(master, vecs, count,\n\t\t\t       mtd_get_master_ofs(mtd, to), retlen);\n}\nEXPORT_SYMBOL_GPL(mtd_writev);\n\n \nvoid *mtd_kmalloc_up_to(const struct mtd_info *mtd, size_t *size)\n{\n\tgfp_t flags = __GFP_NOWARN | __GFP_DIRECT_RECLAIM | __GFP_NORETRY;\n\tsize_t min_alloc = max_t(size_t, mtd->writesize, PAGE_SIZE);\n\tvoid *kbuf;\n\n\t*size = min_t(size_t, *size, KMALLOC_MAX_SIZE);\n\n\twhile (*size > min_alloc) {\n\t\tkbuf = kmalloc(*size, flags);\n\t\tif (kbuf)\n\t\t\treturn kbuf;\n\n\t\t*size >>= 1;\n\t\t*size = ALIGN(*size, mtd->writesize);\n\t}\n\n\t \n\treturn kmalloc(*size, GFP_KERNEL);\n}\nEXPORT_SYMBOL_GPL(mtd_kmalloc_up_to);\n\n#ifdef CONFIG_PROC_FS\n\n \n \n\nstatic int mtd_proc_show(struct seq_file *m, void *v)\n{\n\tstruct mtd_info *mtd;\n\n\tseq_puts(m, \"dev:    size   erasesize  name\\n\");\n\tmutex_lock(&mtd_table_mutex);\n\tmtd_for_each_device(mtd) {\n\t\tseq_printf(m, \"mtd%d: %8.8llx %8.8x \\\"%s\\\"\\n\",\n\t\t\t   mtd->index, (unsigned long long)mtd->size,\n\t\t\t   mtd->erasesize, mtd->name);\n\t}\n\tmutex_unlock(&mtd_table_mutex);\n\treturn 0;\n}\n#endif  \n\n \n \n\nstatic struct backing_dev_info * __init mtd_bdi_init(const char *name)\n{\n\tstruct backing_dev_info *bdi;\n\tint ret;\n\n\tbdi = bdi_alloc(NUMA_NO_NODE);\n\tif (!bdi)\n\t\treturn ERR_PTR(-ENOMEM);\n\tbdi->ra_pages = 0;\n\tbdi->io_pages = 0;\n\n\t \n\tret = bdi_register(bdi, \"%.28s-0\", name);\n\tif (ret)\n\t\tbdi_put(bdi);\n\n\treturn ret ? ERR_PTR(ret) : bdi;\n}\n\nstatic struct proc_dir_entry *proc_mtd;\n\nstatic int __init init_mtd(void)\n{\n\tint ret;\n\n\tret = class_register(&mtd_class);\n\tif (ret)\n\t\tgoto err_reg;\n\n\tmtd_bdi = mtd_bdi_init(\"mtd\");\n\tif (IS_ERR(mtd_bdi)) {\n\t\tret = PTR_ERR(mtd_bdi);\n\t\tgoto err_bdi;\n\t}\n\n\tproc_mtd = proc_create_single(\"mtd\", 0, NULL, mtd_proc_show);\n\n\tret = init_mtdchar();\n\tif (ret)\n\t\tgoto out_procfs;\n\n\tdfs_dir_mtd = debugfs_create_dir(\"mtd\", NULL);\n\tdebugfs_create_bool(\"expert_analysis_mode\", 0600, dfs_dir_mtd,\n\t\t\t    &mtd_expert_analysis_mode);\n\n\treturn 0;\n\nout_procfs:\n\tif (proc_mtd)\n\t\tremove_proc_entry(\"mtd\", NULL);\n\tbdi_unregister(mtd_bdi);\n\tbdi_put(mtd_bdi);\nerr_bdi:\n\tclass_unregister(&mtd_class);\nerr_reg:\n\tpr_err(\"Error registering mtd class or bdi: %d\\n\", ret);\n\treturn ret;\n}\n\nstatic void __exit cleanup_mtd(void)\n{\n\tdebugfs_remove_recursive(dfs_dir_mtd);\n\tcleanup_mtdchar();\n\tif (proc_mtd)\n\t\tremove_proc_entry(\"mtd\", NULL);\n\tclass_unregister(&mtd_class);\n\tbdi_unregister(mtd_bdi);\n\tbdi_put(mtd_bdi);\n\tidr_destroy(&mtd_idr);\n}\n\nmodule_init(init_mtd);\nmodule_exit(cleanup_mtd);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"David Woodhouse <dwmw2@infradead.org>\");\nMODULE_DESCRIPTION(\"Core MTD registration and access routines\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}