{
  "module_name": "mtdswap.c",
  "hash_id": "6ab035505d5cab59ec4ba2216bad8fa9cb92a365c6fffc0a2ee9e61ebe653da8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/mtdswap.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/mtd/mtd.h>\n#include <linux/mtd/blktrans.h>\n#include <linux/rbtree.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/swap.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/device.h>\n#include <linux/math64.h>\n\n#define MTDSWAP_PREFIX \"mtdswap\"\n\n \n#define CLEAN_BLOCK_THRESHOLD\t20\n\n \n#define LOW_FRAG_GC_THRESHOLD\t5\n\n \n#define MAX_ERASE_DIFF\t\t4000\n#define COLLECT_NONDIRTY_BASE\tMAX_ERASE_DIFF\n#define COLLECT_NONDIRTY_FREQ1\t6\n#define COLLECT_NONDIRTY_FREQ2\t4\n\n#define PAGE_UNDEF\t\tUINT_MAX\n#define BLOCK_UNDEF\t\tUINT_MAX\n#define BLOCK_ERROR\t\t(UINT_MAX - 1)\n#define BLOCK_MAX\t\t(UINT_MAX - 2)\n\n#define EBLOCK_BAD\t\t(1 << 0)\n#define EBLOCK_NOMAGIC\t\t(1 << 1)\n#define EBLOCK_BITFLIP\t\t(1 << 2)\n#define EBLOCK_FAILED\t\t(1 << 3)\n#define EBLOCK_READERR\t\t(1 << 4)\n#define EBLOCK_IDX_SHIFT\t5\n\nstruct swap_eb {\n\tstruct rb_node rb;\n\tstruct rb_root *root;\n\n\tunsigned int flags;\n\tunsigned int active_count;\n\tunsigned int erase_count;\n\tunsigned int pad;\t\t \n};\n\n#define MTDSWAP_ECNT_MIN(rbroot) (rb_entry(rb_first(rbroot), struct swap_eb, \\\n\t\t\t\trb)->erase_count)\n#define MTDSWAP_ECNT_MAX(rbroot) (rb_entry(rb_last(rbroot), struct swap_eb, \\\n\t\t\t\trb)->erase_count)\n\nstruct mtdswap_tree {\n\tstruct rb_root root;\n\tunsigned int count;\n};\n\nenum {\n\tMTDSWAP_CLEAN,\n\tMTDSWAP_USED,\n\tMTDSWAP_LOWFRAG,\n\tMTDSWAP_HIFRAG,\n\tMTDSWAP_DIRTY,\n\tMTDSWAP_BITFLIP,\n\tMTDSWAP_FAILING,\n\tMTDSWAP_TREE_CNT,\n};\n\nstruct mtdswap_dev {\n\tstruct mtd_blktrans_dev *mbd_dev;\n\tstruct mtd_info *mtd;\n\tstruct device *dev;\n\n\tunsigned int *page_data;\n\tunsigned int *revmap;\n\n\tunsigned int eblks;\n\tunsigned int spare_eblks;\n\tunsigned int pages_per_eblk;\n\tunsigned int max_erase_count;\n\tstruct swap_eb *eb_data;\n\n\tstruct mtdswap_tree trees[MTDSWAP_TREE_CNT];\n\n\tunsigned long long sect_read_count;\n\tunsigned long long sect_write_count;\n\tunsigned long long mtd_write_count;\n\tunsigned long long mtd_read_count;\n\tunsigned long long discard_count;\n\tunsigned long long discard_page_count;\n\n\tunsigned int curr_write_pos;\n\tstruct swap_eb *curr_write;\n\n\tchar *page_buf;\n\tchar *oob_buf;\n};\n\nstruct mtdswap_oobdata {\n\t__le16 magic;\n\t__le32 count;\n} __packed;\n\n#define MTDSWAP_MAGIC_CLEAN\t0x2095\n#define MTDSWAP_MAGIC_DIRTY\t(MTDSWAP_MAGIC_CLEAN + 1)\n#define MTDSWAP_TYPE_CLEAN\t0\n#define MTDSWAP_TYPE_DIRTY\t1\n#define MTDSWAP_OOBSIZE\t\tsizeof(struct mtdswap_oobdata)\n\n#define MTDSWAP_ERASE_RETRIES\t3  \n#define MTDSWAP_IO_RETRIES\t3\n\nenum {\n\tMTDSWAP_SCANNED_CLEAN,\n\tMTDSWAP_SCANNED_DIRTY,\n\tMTDSWAP_SCANNED_BITFLIP,\n\tMTDSWAP_SCANNED_BAD,\n};\n\n \n#define MIN_SPARE_EBLOCKS\t2\n#define MIN_ERASE_BLOCKS\t(MIN_SPARE_EBLOCKS + 1)\n\n#define TREE_ROOT(d, name) (&d->trees[MTDSWAP_ ## name].root)\n#define TREE_EMPTY(d, name) (TREE_ROOT(d, name)->rb_node == NULL)\n#define TREE_NONEMPTY(d, name) (!TREE_EMPTY(d, name))\n#define TREE_COUNT(d, name) (d->trees[MTDSWAP_ ## name].count)\n\n#define MTDSWAP_MBD_TO_MTDSWAP(dev) ((struct mtdswap_dev *)dev->priv)\n\nstatic char partitions[128] = \"\";\nmodule_param_string(partitions, partitions, sizeof(partitions), 0444);\nMODULE_PARM_DESC(partitions, \"MTD partition numbers to use as swap \"\n\t\t\"partitions=\\\"1,3,5\\\"\");\n\nstatic unsigned int spare_eblocks = 10;\nmodule_param(spare_eblocks, uint, 0444);\nMODULE_PARM_DESC(spare_eblocks, \"Percentage of spare erase blocks for \"\n\t\t\"garbage collection (default 10%)\");\n\nstatic bool header;  \nmodule_param(header, bool, 0444);\nMODULE_PARM_DESC(header,\n\t\t\"Include builtin swap header (default 0, without header)\");\n\nstatic int mtdswap_gc(struct mtdswap_dev *d, unsigned int background);\n\nstatic loff_t mtdswap_eb_offset(struct mtdswap_dev *d, struct swap_eb *eb)\n{\n\treturn (loff_t)(eb - d->eb_data) * d->mtd->erasesize;\n}\n\nstatic void mtdswap_eb_detach(struct mtdswap_dev *d, struct swap_eb *eb)\n{\n\tunsigned int oldidx;\n\tstruct mtdswap_tree *tp;\n\n\tif (eb->root) {\n\t\ttp = container_of(eb->root, struct mtdswap_tree, root);\n\t\toldidx = tp - &d->trees[0];\n\n\t\td->trees[oldidx].count--;\n\t\trb_erase(&eb->rb, eb->root);\n\t}\n}\n\nstatic void __mtdswap_rb_add(struct rb_root *root, struct swap_eb *eb)\n{\n\tstruct rb_node **p, *parent = NULL;\n\tstruct swap_eb *cur;\n\n\tp = &root->rb_node;\n\twhile (*p) {\n\t\tparent = *p;\n\t\tcur = rb_entry(parent, struct swap_eb, rb);\n\t\tif (eb->erase_count > cur->erase_count)\n\t\t\tp = &(*p)->rb_right;\n\t\telse\n\t\t\tp = &(*p)->rb_left;\n\t}\n\n\trb_link_node(&eb->rb, parent, p);\n\trb_insert_color(&eb->rb, root);\n}\n\nstatic void mtdswap_rb_add(struct mtdswap_dev *d, struct swap_eb *eb, int idx)\n{\n\tstruct rb_root *root;\n\n\tif (eb->root == &d->trees[idx].root)\n\t\treturn;\n\n\tmtdswap_eb_detach(d, eb);\n\troot = &d->trees[idx].root;\n\t__mtdswap_rb_add(root, eb);\n\teb->root = root;\n\td->trees[idx].count++;\n}\n\nstatic struct rb_node *mtdswap_rb_index(struct rb_root *root, unsigned int idx)\n{\n\tstruct rb_node *p;\n\tunsigned int i;\n\n\tp = rb_first(root);\n\ti = 0;\n\twhile (i < idx && p) {\n\t\tp = rb_next(p);\n\t\ti++;\n\t}\n\n\treturn p;\n}\n\nstatic int mtdswap_handle_badblock(struct mtdswap_dev *d, struct swap_eb *eb)\n{\n\tint ret;\n\tloff_t offset;\n\n\td->spare_eblks--;\n\teb->flags |= EBLOCK_BAD;\n\tmtdswap_eb_detach(d, eb);\n\teb->root = NULL;\n\n\t \n\tif (!mtd_can_have_bb(d->mtd))\n\t\treturn 1;\n\n\toffset = mtdswap_eb_offset(d, eb);\n\tdev_warn(d->dev, \"Marking bad block at %08llx\\n\", offset);\n\tret = mtd_block_markbad(d->mtd, offset);\n\n\tif (ret) {\n\t\tdev_warn(d->dev, \"Mark block bad failed for block at %08llx \"\n\t\t\t\"error %d\\n\", offset, ret);\n\t\treturn ret;\n\t}\n\n\treturn 1;\n\n}\n\nstatic int mtdswap_handle_write_error(struct mtdswap_dev *d, struct swap_eb *eb)\n{\n\tunsigned int marked = eb->flags & EBLOCK_FAILED;\n\tstruct swap_eb *curr_write = d->curr_write;\n\n\teb->flags |= EBLOCK_FAILED;\n\tif (curr_write == eb) {\n\t\td->curr_write = NULL;\n\n\t\tif (!marked && d->curr_write_pos != 0) {\n\t\t\tmtdswap_rb_add(d, eb, MTDSWAP_FAILING);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn mtdswap_handle_badblock(d, eb);\n}\n\nstatic int mtdswap_read_oob(struct mtdswap_dev *d, loff_t from,\n\t\t\tstruct mtd_oob_ops *ops)\n{\n\tint ret = mtd_read_oob(d->mtd, from, ops);\n\n\tif (mtd_is_bitflip(ret))\n\t\treturn ret;\n\n\tif (ret) {\n\t\tdev_warn(d->dev, \"Read OOB failed %d for block at %08llx\\n\",\n\t\t\tret, from);\n\t\treturn ret;\n\t}\n\n\tif (ops->oobretlen < ops->ooblen) {\n\t\tdev_warn(d->dev, \"Read OOB return short read (%zd bytes not \"\n\t\t\t\"%zd) for block at %08llx\\n\",\n\t\t\tops->oobretlen, ops->ooblen, from);\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic int mtdswap_read_markers(struct mtdswap_dev *d, struct swap_eb *eb)\n{\n\tstruct mtdswap_oobdata *data, *data2;\n\tint ret;\n\tloff_t offset;\n\tstruct mtd_oob_ops ops = { };\n\n\toffset = mtdswap_eb_offset(d, eb);\n\n\t \n\tif (mtd_can_have_bb(d->mtd) && mtd_block_isbad(d->mtd, offset))\n\t\treturn MTDSWAP_SCANNED_BAD;\n\n\tops.ooblen = 2 * d->mtd->oobavail;\n\tops.oobbuf = d->oob_buf;\n\tops.ooboffs = 0;\n\tops.datbuf = NULL;\n\tops.mode = MTD_OPS_AUTO_OOB;\n\n\tret = mtdswap_read_oob(d, offset, &ops);\n\n\tif (ret && !mtd_is_bitflip(ret))\n\t\treturn ret;\n\n\tdata = (struct mtdswap_oobdata *)d->oob_buf;\n\tdata2 = (struct mtdswap_oobdata *)\n\t\t(d->oob_buf + d->mtd->oobavail);\n\n\tif (le16_to_cpu(data->magic) == MTDSWAP_MAGIC_CLEAN) {\n\t\teb->erase_count = le32_to_cpu(data->count);\n\t\tif (mtd_is_bitflip(ret))\n\t\t\tret = MTDSWAP_SCANNED_BITFLIP;\n\t\telse {\n\t\t\tif (le16_to_cpu(data2->magic) == MTDSWAP_MAGIC_DIRTY)\n\t\t\t\tret = MTDSWAP_SCANNED_DIRTY;\n\t\t\telse\n\t\t\t\tret = MTDSWAP_SCANNED_CLEAN;\n\t\t}\n\t} else {\n\t\teb->flags |= EBLOCK_NOMAGIC;\n\t\tret = MTDSWAP_SCANNED_DIRTY;\n\t}\n\n\treturn ret;\n}\n\nstatic int mtdswap_write_marker(struct mtdswap_dev *d, struct swap_eb *eb,\n\t\t\t\tu16 marker)\n{\n\tstruct mtdswap_oobdata n;\n\tint ret;\n\tloff_t offset;\n\tstruct mtd_oob_ops ops = { };\n\n\tops.ooboffs = 0;\n\tops.oobbuf = (uint8_t *)&n;\n\tops.mode = MTD_OPS_AUTO_OOB;\n\tops.datbuf = NULL;\n\n\tif (marker == MTDSWAP_TYPE_CLEAN) {\n\t\tn.magic = cpu_to_le16(MTDSWAP_MAGIC_CLEAN);\n\t\tn.count = cpu_to_le32(eb->erase_count);\n\t\tops.ooblen = MTDSWAP_OOBSIZE;\n\t\toffset = mtdswap_eb_offset(d, eb);\n\t} else {\n\t\tn.magic = cpu_to_le16(MTDSWAP_MAGIC_DIRTY);\n\t\tops.ooblen = sizeof(n.magic);\n\t\toffset = mtdswap_eb_offset(d, eb) + d->mtd->writesize;\n\t}\n\n\tret = mtd_write_oob(d->mtd, offset, &ops);\n\n\tif (ret) {\n\t\tdev_warn(d->dev, \"Write OOB failed for block at %08llx \"\n\t\t\t\"error %d\\n\", offset, ret);\n\t\tif (ret == -EIO || mtd_is_eccerr(ret))\n\t\t\tmtdswap_handle_write_error(d, eb);\n\t\treturn ret;\n\t}\n\n\tif (ops.oobretlen != ops.ooblen) {\n\t\tdev_warn(d->dev, \"Short OOB write for block at %08llx: \"\n\t\t\t\"%zd not %zd\\n\",\n\t\t\toffset, ops.oobretlen, ops.ooblen);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n \nstatic void mtdswap_check_counts(struct mtdswap_dev *d)\n{\n\tstruct rb_root hist_root = RB_ROOT;\n\tstruct rb_node *medrb;\n\tstruct swap_eb *eb;\n\tunsigned int i, cnt, median;\n\n\tcnt = 0;\n\tfor (i = 0; i < d->eblks; i++) {\n\t\teb = d->eb_data + i;\n\n\t\tif (eb->flags & (EBLOCK_NOMAGIC | EBLOCK_BAD | EBLOCK_READERR))\n\t\t\tcontinue;\n\n\t\t__mtdswap_rb_add(&hist_root, eb);\n\t\tcnt++;\n\t}\n\n\tif (cnt == 0)\n\t\treturn;\n\n\tmedrb = mtdswap_rb_index(&hist_root, cnt / 2);\n\tmedian = rb_entry(medrb, struct swap_eb, rb)->erase_count;\n\n\td->max_erase_count = MTDSWAP_ECNT_MAX(&hist_root);\n\n\tfor (i = 0; i < d->eblks; i++) {\n\t\teb = d->eb_data + i;\n\n\t\tif (eb->flags & (EBLOCK_NOMAGIC | EBLOCK_READERR))\n\t\t\teb->erase_count = median;\n\n\t\tif (eb->flags & (EBLOCK_NOMAGIC | EBLOCK_BAD | EBLOCK_READERR))\n\t\t\tcontinue;\n\n\t\trb_erase(&eb->rb, &hist_root);\n\t}\n}\n\nstatic void mtdswap_scan_eblks(struct mtdswap_dev *d)\n{\n\tint status;\n\tunsigned int i, idx;\n\tstruct swap_eb *eb;\n\n\tfor (i = 0; i < d->eblks; i++) {\n\t\teb = d->eb_data + i;\n\n\t\tstatus = mtdswap_read_markers(d, eb);\n\t\tif (status < 0)\n\t\t\teb->flags |= EBLOCK_READERR;\n\t\telse if (status == MTDSWAP_SCANNED_BAD) {\n\t\t\teb->flags |= EBLOCK_BAD;\n\t\t\tcontinue;\n\t\t}\n\n\t\tswitch (status) {\n\t\tcase MTDSWAP_SCANNED_CLEAN:\n\t\t\tidx = MTDSWAP_CLEAN;\n\t\t\tbreak;\n\t\tcase MTDSWAP_SCANNED_DIRTY:\n\t\tcase MTDSWAP_SCANNED_BITFLIP:\n\t\t\tidx = MTDSWAP_DIRTY;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tidx = MTDSWAP_FAILING;\n\t\t}\n\n\t\teb->flags |= (idx << EBLOCK_IDX_SHIFT);\n\t}\n\n\tmtdswap_check_counts(d);\n\n\tfor (i = 0; i < d->eblks; i++) {\n\t\teb = d->eb_data + i;\n\n\t\tif (eb->flags & EBLOCK_BAD)\n\t\t\tcontinue;\n\n\t\tidx = eb->flags >> EBLOCK_IDX_SHIFT;\n\t\tmtdswap_rb_add(d, eb, idx);\n\t}\n}\n\n \nstatic void mtdswap_store_eb(struct mtdswap_dev *d, struct swap_eb *eb)\n{\n\tunsigned int weight = eb->active_count;\n\tunsigned int maxweight = d->pages_per_eblk;\n\n\tif (eb == d->curr_write)\n\t\treturn;\n\n\tif (eb->flags & EBLOCK_BITFLIP)\n\t\tmtdswap_rb_add(d, eb, MTDSWAP_BITFLIP);\n\telse if (eb->flags & (EBLOCK_READERR | EBLOCK_FAILED))\n\t\tmtdswap_rb_add(d, eb, MTDSWAP_FAILING);\n\tif (weight == maxweight)\n\t\tmtdswap_rb_add(d, eb, MTDSWAP_USED);\n\telse if (weight == 0)\n\t\tmtdswap_rb_add(d, eb, MTDSWAP_DIRTY);\n\telse if (weight > (maxweight/2))\n\t\tmtdswap_rb_add(d, eb, MTDSWAP_LOWFRAG);\n\telse\n\t\tmtdswap_rb_add(d, eb, MTDSWAP_HIFRAG);\n}\n\nstatic int mtdswap_erase_block(struct mtdswap_dev *d, struct swap_eb *eb)\n{\n\tstruct mtd_info *mtd = d->mtd;\n\tstruct erase_info erase;\n\tunsigned int retries = 0;\n\tint ret;\n\n\teb->erase_count++;\n\tif (eb->erase_count > d->max_erase_count)\n\t\td->max_erase_count = eb->erase_count;\n\nretry:\n\tmemset(&erase, 0, sizeof(struct erase_info));\n\terase.addr\t= mtdswap_eb_offset(d, eb);\n\terase.len\t= mtd->erasesize;\n\n\tret = mtd_erase(mtd, &erase);\n\tif (ret) {\n\t\tif (retries++ < MTDSWAP_ERASE_RETRIES) {\n\t\t\tdev_warn(d->dev,\n\t\t\t\t\"erase of erase block %#llx on %s failed\",\n\t\t\t\terase.addr, mtd->name);\n\t\t\tyield();\n\t\t\tgoto retry;\n\t\t}\n\n\t\tdev_err(d->dev, \"Cannot erase erase block %#llx on %s\\n\",\n\t\t\terase.addr, mtd->name);\n\n\t\tmtdswap_handle_badblock(d, eb);\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic int mtdswap_map_free_block(struct mtdswap_dev *d, unsigned int page,\n\t\t\t\tunsigned int *block)\n{\n\tint ret;\n\tstruct swap_eb *old_eb = d->curr_write;\n\tstruct rb_root *clean_root;\n\tstruct swap_eb *eb;\n\n\tif (old_eb == NULL || d->curr_write_pos >= d->pages_per_eblk) {\n\t\tdo {\n\t\t\tif (TREE_EMPTY(d, CLEAN))\n\t\t\t\treturn -ENOSPC;\n\n\t\t\tclean_root = TREE_ROOT(d, CLEAN);\n\t\t\teb = rb_entry(rb_first(clean_root), struct swap_eb, rb);\n\t\t\trb_erase(&eb->rb, clean_root);\n\t\t\teb->root = NULL;\n\t\t\tTREE_COUNT(d, CLEAN)--;\n\n\t\t\tret = mtdswap_write_marker(d, eb, MTDSWAP_TYPE_DIRTY);\n\t\t} while (ret == -EIO || mtd_is_eccerr(ret));\n\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\td->curr_write_pos = 0;\n\t\td->curr_write = eb;\n\t\tif (old_eb)\n\t\t\tmtdswap_store_eb(d, old_eb);\n\t}\n\n\t*block = (d->curr_write - d->eb_data) * d->pages_per_eblk +\n\t\td->curr_write_pos;\n\n\td->curr_write->active_count++;\n\td->revmap[*block] = page;\n\td->curr_write_pos++;\n\n\treturn 0;\n}\n\nstatic unsigned int mtdswap_free_page_cnt(struct mtdswap_dev *d)\n{\n\treturn TREE_COUNT(d, CLEAN) * d->pages_per_eblk +\n\t\td->pages_per_eblk - d->curr_write_pos;\n}\n\nstatic unsigned int mtdswap_enough_free_pages(struct mtdswap_dev *d)\n{\n\treturn mtdswap_free_page_cnt(d) > d->pages_per_eblk;\n}\n\nstatic int mtdswap_write_block(struct mtdswap_dev *d, char *buf,\n\t\t\tunsigned int page, unsigned int *bp, int gc_context)\n{\n\tstruct mtd_info *mtd = d->mtd;\n\tstruct swap_eb *eb;\n\tsize_t retlen;\n\tloff_t writepos;\n\tint ret;\n\nretry:\n\tif (!gc_context)\n\t\twhile (!mtdswap_enough_free_pages(d))\n\t\t\tif (mtdswap_gc(d, 0) > 0)\n\t\t\t\treturn -ENOSPC;\n\n\tret = mtdswap_map_free_block(d, page, bp);\n\teb = d->eb_data + (*bp / d->pages_per_eblk);\n\n\tif (ret == -EIO || mtd_is_eccerr(ret)) {\n\t\td->curr_write = NULL;\n\t\teb->active_count--;\n\t\td->revmap[*bp] = PAGE_UNDEF;\n\t\tgoto retry;\n\t}\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\twritepos = (loff_t)*bp << PAGE_SHIFT;\n\tret =  mtd_write(mtd, writepos, PAGE_SIZE, &retlen, buf);\n\tif (ret == -EIO || mtd_is_eccerr(ret)) {\n\t\td->curr_write_pos--;\n\t\teb->active_count--;\n\t\td->revmap[*bp] = PAGE_UNDEF;\n\t\tmtdswap_handle_write_error(d, eb);\n\t\tgoto retry;\n\t}\n\n\tif (ret < 0) {\n\t\tdev_err(d->dev, \"Write to MTD device failed: %d (%zd written)\",\n\t\t\tret, retlen);\n\t\tgoto err;\n\t}\n\n\tif (retlen != PAGE_SIZE) {\n\t\tdev_err(d->dev, \"Short write to MTD device: %zd written\",\n\t\t\tretlen);\n\t\tret = -EIO;\n\t\tgoto err;\n\t}\n\n\treturn ret;\n\nerr:\n\td->curr_write_pos--;\n\teb->active_count--;\n\td->revmap[*bp] = PAGE_UNDEF;\n\n\treturn ret;\n}\n\nstatic int mtdswap_move_block(struct mtdswap_dev *d, unsigned int oldblock,\n\t\tunsigned int *newblock)\n{\n\tstruct mtd_info *mtd = d->mtd;\n\tstruct swap_eb *eb, *oldeb;\n\tint ret;\n\tsize_t retlen;\n\tunsigned int page, retries;\n\tloff_t readpos;\n\n\tpage = d->revmap[oldblock];\n\treadpos = (loff_t) oldblock << PAGE_SHIFT;\n\tretries = 0;\n\nretry:\n\tret = mtd_read(mtd, readpos, PAGE_SIZE, &retlen, d->page_buf);\n\n\tif (ret < 0 && !mtd_is_bitflip(ret)) {\n\t\toldeb = d->eb_data + oldblock / d->pages_per_eblk;\n\t\toldeb->flags |= EBLOCK_READERR;\n\n\t\tdev_err(d->dev, \"Read Error: %d (block %u)\\n\", ret,\n\t\t\toldblock);\n\t\tretries++;\n\t\tif (retries < MTDSWAP_IO_RETRIES)\n\t\t\tgoto retry;\n\n\t\tgoto read_error;\n\t}\n\n\tif (retlen != PAGE_SIZE) {\n\t\tdev_err(d->dev, \"Short read: %zd (block %u)\\n\", retlen,\n\t\t       oldblock);\n\t\tret = -EIO;\n\t\tgoto read_error;\n\t}\n\n\tret = mtdswap_write_block(d, d->page_buf, page, newblock, 1);\n\tif (ret < 0) {\n\t\td->page_data[page] = BLOCK_ERROR;\n\t\tdev_err(d->dev, \"Write error: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\td->page_data[page] = *newblock;\n\td->revmap[oldblock] = PAGE_UNDEF;\n\teb = d->eb_data + oldblock / d->pages_per_eblk;\n\teb->active_count--;\n\n\treturn 0;\n\nread_error:\n\td->page_data[page] = BLOCK_ERROR;\n\td->revmap[oldblock] = PAGE_UNDEF;\n\treturn ret;\n}\n\nstatic int mtdswap_gc_eblock(struct mtdswap_dev *d, struct swap_eb *eb)\n{\n\tunsigned int i, block, eblk_base, newblock;\n\tint ret, errcode;\n\n\terrcode = 0;\n\teblk_base = (eb - d->eb_data) * d->pages_per_eblk;\n\n\tfor (i = 0; i < d->pages_per_eblk; i++) {\n\t\tif (d->spare_eblks < MIN_SPARE_EBLOCKS)\n\t\t\treturn -ENOSPC;\n\n\t\tblock = eblk_base + i;\n\t\tif (d->revmap[block] == PAGE_UNDEF)\n\t\t\tcontinue;\n\n\t\tret = mtdswap_move_block(d, block, &newblock);\n\t\tif (ret < 0 && !errcode)\n\t\t\terrcode = ret;\n\t}\n\n\treturn errcode;\n}\n\nstatic int __mtdswap_choose_gc_tree(struct mtdswap_dev *d)\n{\n\tint idx, stopat;\n\n\tif (TREE_COUNT(d, CLEAN) < LOW_FRAG_GC_THRESHOLD)\n\t\tstopat = MTDSWAP_LOWFRAG;\n\telse\n\t\tstopat = MTDSWAP_HIFRAG;\n\n\tfor (idx = MTDSWAP_BITFLIP; idx >= stopat; idx--)\n\t\tif (d->trees[idx].root.rb_node != NULL)\n\t\t\treturn idx;\n\n\treturn -1;\n}\n\nstatic int mtdswap_wlfreq(unsigned int maxdiff)\n{\n\tunsigned int h, x, y, dist, base;\n\n\t \n\n\tdist = maxdiff - MAX_ERASE_DIFF;\n\tif (dist > COLLECT_NONDIRTY_BASE)\n\t\tdist = COLLECT_NONDIRTY_BASE;\n\n\t \n\th = COLLECT_NONDIRTY_FREQ1 - COLLECT_NONDIRTY_FREQ2;\n\tbase = COLLECT_NONDIRTY_BASE;\n\n\tx = dist - base;\n\ty = (x * h + base / 2) / base;\n\n\treturn COLLECT_NONDIRTY_FREQ2 + y;\n}\n\nstatic int mtdswap_choose_wl_tree(struct mtdswap_dev *d)\n{\n\tstatic unsigned int pick_cnt;\n\tunsigned int i, idx = -1, wear, max;\n\tstruct rb_root *root;\n\n\tmax = 0;\n\tfor (i = 0; i <= MTDSWAP_DIRTY; i++) {\n\t\troot = &d->trees[i].root;\n\t\tif (root->rb_node == NULL)\n\t\t\tcontinue;\n\n\t\twear = d->max_erase_count - MTDSWAP_ECNT_MIN(root);\n\t\tif (wear > max) {\n\t\t\tmax = wear;\n\t\t\tidx = i;\n\t\t}\n\t}\n\n\tif (max > MAX_ERASE_DIFF && pick_cnt >= mtdswap_wlfreq(max) - 1) {\n\t\tpick_cnt = 0;\n\t\treturn idx;\n\t}\n\n\tpick_cnt++;\n\treturn -1;\n}\n\nstatic int mtdswap_choose_gc_tree(struct mtdswap_dev *d,\n\t\t\t\tunsigned int background)\n{\n\tint idx;\n\n\tif (TREE_NONEMPTY(d, FAILING) &&\n\t\t(background || (TREE_EMPTY(d, CLEAN) && TREE_EMPTY(d, DIRTY))))\n\t\treturn MTDSWAP_FAILING;\n\n\tidx = mtdswap_choose_wl_tree(d);\n\tif (idx >= MTDSWAP_CLEAN)\n\t\treturn idx;\n\n\treturn __mtdswap_choose_gc_tree(d);\n}\n\nstatic struct swap_eb *mtdswap_pick_gc_eblk(struct mtdswap_dev *d,\n\t\t\t\t\tunsigned int background)\n{\n\tstruct rb_root *rp = NULL;\n\tstruct swap_eb *eb = NULL;\n\tint idx;\n\n\tif (background && TREE_COUNT(d, CLEAN) > CLEAN_BLOCK_THRESHOLD &&\n\t\tTREE_EMPTY(d, DIRTY) && TREE_EMPTY(d, FAILING))\n\t\treturn NULL;\n\n\tidx = mtdswap_choose_gc_tree(d, background);\n\tif (idx < 0)\n\t\treturn NULL;\n\n\trp = &d->trees[idx].root;\n\teb = rb_entry(rb_first(rp), struct swap_eb, rb);\n\n\trb_erase(&eb->rb, rp);\n\teb->root = NULL;\n\td->trees[idx].count--;\n\treturn eb;\n}\n\nstatic unsigned int mtdswap_test_patt(unsigned int i)\n{\n\treturn i % 2 ? 0x55555555 : 0xAAAAAAAA;\n}\n\nstatic unsigned int mtdswap_eblk_passes(struct mtdswap_dev *d,\n\t\t\t\t\tstruct swap_eb *eb)\n{\n\tstruct mtd_info *mtd = d->mtd;\n\tunsigned int test, i, j, patt, mtd_pages;\n\tloff_t base, pos;\n\tunsigned int *p1 = (unsigned int *)d->page_buf;\n\tunsigned char *p2 = (unsigned char *)d->oob_buf;\n\tstruct mtd_oob_ops ops = { };\n\tint ret;\n\n\tops.mode = MTD_OPS_AUTO_OOB;\n\tops.len = mtd->writesize;\n\tops.ooblen = mtd->oobavail;\n\tops.ooboffs = 0;\n\tops.datbuf = d->page_buf;\n\tops.oobbuf = d->oob_buf;\n\tbase = mtdswap_eb_offset(d, eb);\n\tmtd_pages = d->pages_per_eblk * PAGE_SIZE / mtd->writesize;\n\n\tfor (test = 0; test < 2; test++) {\n\t\tpos = base;\n\t\tfor (i = 0; i < mtd_pages; i++) {\n\t\t\tpatt = mtdswap_test_patt(test + i);\n\t\t\tmemset(d->page_buf, patt, mtd->writesize);\n\t\t\tmemset(d->oob_buf, patt, mtd->oobavail);\n\t\t\tret = mtd_write_oob(mtd, pos, &ops);\n\t\t\tif (ret)\n\t\t\t\tgoto error;\n\n\t\t\tpos += mtd->writesize;\n\t\t}\n\n\t\tpos = base;\n\t\tfor (i = 0; i < mtd_pages; i++) {\n\t\t\tret = mtd_read_oob(mtd, pos, &ops);\n\t\t\tif (ret)\n\t\t\t\tgoto error;\n\n\t\t\tpatt = mtdswap_test_patt(test + i);\n\t\t\tfor (j = 0; j < mtd->writesize/sizeof(int); j++)\n\t\t\t\tif (p1[j] != patt)\n\t\t\t\t\tgoto error;\n\n\t\t\tfor (j = 0; j < mtd->oobavail; j++)\n\t\t\t\tif (p2[j] != (unsigned char)patt)\n\t\t\t\t\tgoto error;\n\n\t\t\tpos += mtd->writesize;\n\t\t}\n\n\t\tret = mtdswap_erase_block(d, eb);\n\t\tif (ret)\n\t\t\tgoto error;\n\t}\n\n\teb->flags &= ~EBLOCK_READERR;\n\treturn 1;\n\nerror:\n\tmtdswap_handle_badblock(d, eb);\n\treturn 0;\n}\n\nstatic int mtdswap_gc(struct mtdswap_dev *d, unsigned int background)\n{\n\tstruct swap_eb *eb;\n\tint ret;\n\n\tif (d->spare_eblks < MIN_SPARE_EBLOCKS)\n\t\treturn 1;\n\n\teb = mtdswap_pick_gc_eblk(d, background);\n\tif (!eb)\n\t\treturn 1;\n\n\tret = mtdswap_gc_eblock(d, eb);\n\tif (ret == -ENOSPC)\n\t\treturn 1;\n\n\tif (eb->flags & EBLOCK_FAILED) {\n\t\tmtdswap_handle_badblock(d, eb);\n\t\treturn 0;\n\t}\n\n\teb->flags &= ~EBLOCK_BITFLIP;\n\tret = mtdswap_erase_block(d, eb);\n\tif ((eb->flags & EBLOCK_READERR) &&\n\t\t(ret || !mtdswap_eblk_passes(d, eb)))\n\t\treturn 0;\n\n\tif (ret == 0)\n\t\tret = mtdswap_write_marker(d, eb, MTDSWAP_TYPE_CLEAN);\n\n\tif (ret == 0)\n\t\tmtdswap_rb_add(d, eb, MTDSWAP_CLEAN);\n\telse if (ret != -EIO && !mtd_is_eccerr(ret))\n\t\tmtdswap_rb_add(d, eb, MTDSWAP_DIRTY);\n\n\treturn 0;\n}\n\nstatic void mtdswap_background(struct mtd_blktrans_dev *dev)\n{\n\tstruct mtdswap_dev *d = MTDSWAP_MBD_TO_MTDSWAP(dev);\n\tint ret;\n\n\twhile (1) {\n\t\tret = mtdswap_gc(d, 1);\n\t\tif (ret || mtd_blktrans_cease_background(dev))\n\t\t\treturn;\n\t}\n}\n\nstatic void mtdswap_cleanup(struct mtdswap_dev *d)\n{\n\tvfree(d->eb_data);\n\tvfree(d->revmap);\n\tvfree(d->page_data);\n\tkfree(d->oob_buf);\n\tkfree(d->page_buf);\n}\n\nstatic int mtdswap_flush(struct mtd_blktrans_dev *dev)\n{\n\tstruct mtdswap_dev *d = MTDSWAP_MBD_TO_MTDSWAP(dev);\n\n\tmtd_sync(d->mtd);\n\treturn 0;\n}\n\nstatic unsigned int mtdswap_badblocks(struct mtd_info *mtd, uint64_t size)\n{\n\tloff_t offset;\n\tunsigned int badcnt;\n\n\tbadcnt = 0;\n\n\tif (mtd_can_have_bb(mtd))\n\t\tfor (offset = 0; offset < size; offset += mtd->erasesize)\n\t\t\tif (mtd_block_isbad(mtd, offset))\n\t\t\t\tbadcnt++;\n\n\treturn badcnt;\n}\n\nstatic int mtdswap_writesect(struct mtd_blktrans_dev *dev,\n\t\t\tunsigned long page, char *buf)\n{\n\tstruct mtdswap_dev *d = MTDSWAP_MBD_TO_MTDSWAP(dev);\n\tunsigned int newblock, mapped;\n\tstruct swap_eb *eb;\n\tint ret;\n\n\td->sect_write_count++;\n\n\tif (d->spare_eblks < MIN_SPARE_EBLOCKS)\n\t\treturn -ENOSPC;\n\n\tif (header) {\n\t\t \n\t\tif (unlikely(page == 0))\n\t\t\treturn 0;\n\n\t\tpage--;\n\t}\n\n\tmapped = d->page_data[page];\n\tif (mapped <= BLOCK_MAX) {\n\t\teb = d->eb_data + (mapped / d->pages_per_eblk);\n\t\teb->active_count--;\n\t\tmtdswap_store_eb(d, eb);\n\t\td->page_data[page] = BLOCK_UNDEF;\n\t\td->revmap[mapped] = PAGE_UNDEF;\n\t}\n\n\tret = mtdswap_write_block(d, buf, page, &newblock, 0);\n\td->mtd_write_count++;\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\td->page_data[page] = newblock;\n\n\treturn 0;\n}\n\n \nstatic int mtdswap_auto_header(struct mtdswap_dev *d, char *buf)\n{\n\tunion swap_header *hd = (union swap_header *)(buf);\n\n\tmemset(buf, 0, PAGE_SIZE - 10);\n\n\thd->info.version = 1;\n\thd->info.last_page = d->mbd_dev->size - 1;\n\thd->info.nr_badpages = 0;\n\n\tmemcpy(buf + PAGE_SIZE - 10, \"SWAPSPACE2\", 10);\n\n\treturn 0;\n}\n\nstatic int mtdswap_readsect(struct mtd_blktrans_dev *dev,\n\t\t\tunsigned long page, char *buf)\n{\n\tstruct mtdswap_dev *d = MTDSWAP_MBD_TO_MTDSWAP(dev);\n\tstruct mtd_info *mtd = d->mtd;\n\tunsigned int realblock, retries;\n\tloff_t readpos;\n\tstruct swap_eb *eb;\n\tsize_t retlen;\n\tint ret;\n\n\td->sect_read_count++;\n\n\tif (header) {\n\t\tif (unlikely(page == 0))\n\t\t\treturn mtdswap_auto_header(d, buf);\n\n\t\tpage--;\n\t}\n\n\trealblock = d->page_data[page];\n\tif (realblock > BLOCK_MAX) {\n\t\tmemset(buf, 0x0, PAGE_SIZE);\n\t\tif (realblock == BLOCK_UNDEF)\n\t\t\treturn 0;\n\t\telse\n\t\t\treturn -EIO;\n\t}\n\n\teb = d->eb_data + (realblock / d->pages_per_eblk);\n\tBUG_ON(d->revmap[realblock] == PAGE_UNDEF);\n\n\treadpos = (loff_t)realblock << PAGE_SHIFT;\n\tretries = 0;\n\nretry:\n\tret = mtd_read(mtd, readpos, PAGE_SIZE, &retlen, buf);\n\n\td->mtd_read_count++;\n\tif (mtd_is_bitflip(ret)) {\n\t\teb->flags |= EBLOCK_BITFLIP;\n\t\tmtdswap_rb_add(d, eb, MTDSWAP_BITFLIP);\n\t\tret = 0;\n\t}\n\n\tif (ret < 0) {\n\t\tdev_err(d->dev, \"Read error %d\\n\", ret);\n\t\teb->flags |= EBLOCK_READERR;\n\t\tmtdswap_rb_add(d, eb, MTDSWAP_FAILING);\n\t\tretries++;\n\t\tif (retries < MTDSWAP_IO_RETRIES)\n\t\t\tgoto retry;\n\n\t\treturn ret;\n\t}\n\n\tif (retlen != PAGE_SIZE) {\n\t\tdev_err(d->dev, \"Short read %zd\\n\", retlen);\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic int mtdswap_discard(struct mtd_blktrans_dev *dev, unsigned long first,\n\t\t\tunsigned nr_pages)\n{\n\tstruct mtdswap_dev *d = MTDSWAP_MBD_TO_MTDSWAP(dev);\n\tunsigned long page;\n\tstruct swap_eb *eb;\n\tunsigned int mapped;\n\n\td->discard_count++;\n\n\tfor (page = first; page < first + nr_pages; page++) {\n\t\tmapped = d->page_data[page];\n\t\tif (mapped <= BLOCK_MAX) {\n\t\t\teb = d->eb_data + (mapped / d->pages_per_eblk);\n\t\t\teb->active_count--;\n\t\t\tmtdswap_store_eb(d, eb);\n\t\t\td->page_data[page] = BLOCK_UNDEF;\n\t\t\td->revmap[mapped] = PAGE_UNDEF;\n\t\t\td->discard_page_count++;\n\t\t} else if (mapped == BLOCK_ERROR) {\n\t\t\td->page_data[page] = BLOCK_UNDEF;\n\t\t\td->discard_page_count++;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int mtdswap_show(struct seq_file *s, void *data)\n{\n\tstruct mtdswap_dev *d = (struct mtdswap_dev *) s->private;\n\tunsigned long sum;\n\tunsigned int count[MTDSWAP_TREE_CNT];\n\tunsigned int min[MTDSWAP_TREE_CNT];\n\tunsigned int max[MTDSWAP_TREE_CNT];\n\tunsigned int i, cw = 0, cwp = 0, cwecount = 0, bb_cnt, mapped, pages;\n\tuint64_t use_size;\n\tstatic const char * const name[] = {\n\t\t\"clean\", \"used\", \"low\", \"high\", \"dirty\", \"bitflip\", \"failing\"\n\t};\n\n\tmutex_lock(&d->mbd_dev->lock);\n\n\tfor (i = 0; i < MTDSWAP_TREE_CNT; i++) {\n\t\tstruct rb_root *root = &d->trees[i].root;\n\n\t\tif (root->rb_node) {\n\t\t\tcount[i] = d->trees[i].count;\n\t\t\tmin[i] = MTDSWAP_ECNT_MIN(root);\n\t\t\tmax[i] = MTDSWAP_ECNT_MAX(root);\n\t\t} else\n\t\t\tcount[i] = 0;\n\t}\n\n\tif (d->curr_write) {\n\t\tcw = 1;\n\t\tcwp = d->curr_write_pos;\n\t\tcwecount = d->curr_write->erase_count;\n\t}\n\n\tsum = 0;\n\tfor (i = 0; i < d->eblks; i++)\n\t\tsum += d->eb_data[i].erase_count;\n\n\tuse_size = (uint64_t)d->eblks * d->mtd->erasesize;\n\tbb_cnt = mtdswap_badblocks(d->mtd, use_size);\n\n\tmapped = 0;\n\tpages = d->mbd_dev->size;\n\tfor (i = 0; i < pages; i++)\n\t\tif (d->page_data[i] != BLOCK_UNDEF)\n\t\t\tmapped++;\n\n\tmutex_unlock(&d->mbd_dev->lock);\n\n\tfor (i = 0; i < MTDSWAP_TREE_CNT; i++) {\n\t\tif (!count[i])\n\t\t\tcontinue;\n\n\t\tif (min[i] != max[i])\n\t\t\tseq_printf(s, \"%s:\\t%5d erase blocks, erased min %d, \"\n\t\t\t\t\"max %d times\\n\",\n\t\t\t\tname[i], count[i], min[i], max[i]);\n\t\telse\n\t\t\tseq_printf(s, \"%s:\\t%5d erase blocks, all erased %d \"\n\t\t\t\t\"times\\n\", name[i], count[i], min[i]);\n\t}\n\n\tif (bb_cnt)\n\t\tseq_printf(s, \"bad:\\t%5u erase blocks\\n\", bb_cnt);\n\n\tif (cw)\n\t\tseq_printf(s, \"current erase block: %u pages used, %u free, \"\n\t\t\t\"erased %u times\\n\",\n\t\t\tcwp, d->pages_per_eblk - cwp, cwecount);\n\n\tseq_printf(s, \"total erasures: %lu\\n\", sum);\n\n\tseq_puts(s, \"\\n\");\n\n\tseq_printf(s, \"mtdswap_readsect count: %llu\\n\", d->sect_read_count);\n\tseq_printf(s, \"mtdswap_writesect count: %llu\\n\", d->sect_write_count);\n\tseq_printf(s, \"mtdswap_discard count: %llu\\n\", d->discard_count);\n\tseq_printf(s, \"mtd read count: %llu\\n\", d->mtd_read_count);\n\tseq_printf(s, \"mtd write count: %llu\\n\", d->mtd_write_count);\n\tseq_printf(s, \"discarded pages count: %llu\\n\", d->discard_page_count);\n\n\tseq_puts(s, \"\\n\");\n\tseq_printf(s, \"total pages: %u\\n\", pages);\n\tseq_printf(s, \"pages mapped: %u\\n\", mapped);\n\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(mtdswap);\n\nstatic int mtdswap_add_debugfs(struct mtdswap_dev *d)\n{\n\tstruct dentry *root = d->mtd->dbg.dfs_dir;\n\n\tif (!IS_ENABLED(CONFIG_DEBUG_FS))\n\t\treturn 0;\n\n\tif (IS_ERR_OR_NULL(root))\n\t\treturn -1;\n\n\tdebugfs_create_file(\"mtdswap_stats\", S_IRUSR, root, d, &mtdswap_fops);\n\n\treturn 0;\n}\n\nstatic int mtdswap_init(struct mtdswap_dev *d, unsigned int eblocks,\n\t\t\tunsigned int spare_cnt)\n{\n\tstruct mtd_info *mtd = d->mbd_dev->mtd;\n\tunsigned int i, eblk_bytes, pages, blocks;\n\tint ret = -ENOMEM;\n\n\td->mtd = mtd;\n\td->eblks = eblocks;\n\td->spare_eblks = spare_cnt;\n\td->pages_per_eblk = mtd->erasesize >> PAGE_SHIFT;\n\n\tpages = d->mbd_dev->size;\n\tblocks = eblocks * d->pages_per_eblk;\n\n\tfor (i = 0; i < MTDSWAP_TREE_CNT; i++)\n\t\td->trees[i].root = RB_ROOT;\n\n\td->page_data = vmalloc(array_size(pages, sizeof(int)));\n\tif (!d->page_data)\n\t\tgoto page_data_fail;\n\n\td->revmap = vmalloc(array_size(blocks, sizeof(int)));\n\tif (!d->revmap)\n\t\tgoto revmap_fail;\n\n\teblk_bytes = sizeof(struct swap_eb)*d->eblks;\n\td->eb_data = vzalloc(eblk_bytes);\n\tif (!d->eb_data)\n\t\tgoto eb_data_fail;\n\n\tfor (i = 0; i < pages; i++)\n\t\td->page_data[i] = BLOCK_UNDEF;\n\n\tfor (i = 0; i < blocks; i++)\n\t\td->revmap[i] = PAGE_UNDEF;\n\n\td->page_buf = kmalloc(PAGE_SIZE, GFP_KERNEL);\n\tif (!d->page_buf)\n\t\tgoto page_buf_fail;\n\n\td->oob_buf = kmalloc_array(2, mtd->oobavail, GFP_KERNEL);\n\tif (!d->oob_buf)\n\t\tgoto oob_buf_fail;\n\n\tmtdswap_scan_eblks(d);\n\n\treturn 0;\n\noob_buf_fail:\n\tkfree(d->page_buf);\npage_buf_fail:\n\tvfree(d->eb_data);\neb_data_fail:\n\tvfree(d->revmap);\nrevmap_fail:\n\tvfree(d->page_data);\npage_data_fail:\n\tprintk(KERN_ERR \"%s: init failed (%d)\\n\", MTDSWAP_PREFIX, ret);\n\treturn ret;\n}\n\nstatic void mtdswap_add_mtd(struct mtd_blktrans_ops *tr, struct mtd_info *mtd)\n{\n\tstruct mtdswap_dev *d;\n\tstruct mtd_blktrans_dev *mbd_dev;\n\tchar *parts;\n\tchar *this_opt;\n\tunsigned long part;\n\tunsigned int eblocks, eavailable, bad_blocks, spare_cnt;\n\tuint64_t swap_size, use_size, size_limit;\n\tint ret;\n\n\tparts = &partitions[0];\n\tif (!*parts)\n\t\treturn;\n\n\twhile ((this_opt = strsep(&parts, \",\")) != NULL) {\n\t\tif (kstrtoul(this_opt, 0, &part) < 0)\n\t\t\treturn;\n\n\t\tif (mtd->index == part)\n\t\t\tbreak;\n\t}\n\n\tif (mtd->index != part)\n\t\treturn;\n\n\tif (mtd->erasesize < PAGE_SIZE || mtd->erasesize % PAGE_SIZE) {\n\t\tprintk(KERN_ERR \"%s: Erase size %u not multiple of PAGE_SIZE \"\n\t\t\t\"%lu\\n\", MTDSWAP_PREFIX, mtd->erasesize, PAGE_SIZE);\n\t\treturn;\n\t}\n\n\tif (PAGE_SIZE % mtd->writesize || mtd->writesize > PAGE_SIZE) {\n\t\tprintk(KERN_ERR \"%s: PAGE_SIZE %lu not multiple of write size\"\n\t\t\t\" %u\\n\", MTDSWAP_PREFIX, PAGE_SIZE, mtd->writesize);\n\t\treturn;\n\t}\n\n\tif (!mtd->oobsize || mtd->oobavail < MTDSWAP_OOBSIZE) {\n\t\tprintk(KERN_ERR \"%s: Not enough free bytes in OOB, \"\n\t\t\t\"%d available, %zu needed.\\n\",\n\t\t\tMTDSWAP_PREFIX, mtd->oobavail, MTDSWAP_OOBSIZE);\n\t\treturn;\n\t}\n\n\tif (spare_eblocks > 100)\n\t\tspare_eblocks = 100;\n\n\tuse_size = mtd->size;\n\tsize_limit = (uint64_t) BLOCK_MAX * PAGE_SIZE;\n\n\tif (mtd->size > size_limit) {\n\t\tprintk(KERN_WARNING \"%s: Device too large. Limiting size to \"\n\t\t\t\"%llu bytes\\n\", MTDSWAP_PREFIX, size_limit);\n\t\tuse_size = size_limit;\n\t}\n\n\teblocks = mtd_div_by_eb(use_size, mtd);\n\tuse_size = (uint64_t)eblocks * mtd->erasesize;\n\tbad_blocks = mtdswap_badblocks(mtd, use_size);\n\teavailable = eblocks - bad_blocks;\n\n\tif (eavailable < MIN_ERASE_BLOCKS) {\n\t\tprintk(KERN_ERR \"%s: Not enough erase blocks. %u available, \"\n\t\t\t\"%d needed\\n\", MTDSWAP_PREFIX, eavailable,\n\t\t\tMIN_ERASE_BLOCKS);\n\t\treturn;\n\t}\n\n\tspare_cnt = div_u64((uint64_t)eavailable * spare_eblocks, 100);\n\n\tif (spare_cnt < MIN_SPARE_EBLOCKS)\n\t\tspare_cnt = MIN_SPARE_EBLOCKS;\n\n\tif (spare_cnt > eavailable - 1)\n\t\tspare_cnt = eavailable - 1;\n\n\tswap_size = (uint64_t)(eavailable - spare_cnt) * mtd->erasesize +\n\t\t(header ? PAGE_SIZE : 0);\n\n\tprintk(KERN_INFO \"%s: Enabling MTD swap on device %lu, size %llu KB, \"\n\t\t\"%u spare, %u bad blocks\\n\",\n\t\tMTDSWAP_PREFIX, part, swap_size / 1024, spare_cnt, bad_blocks);\n\n\td = kzalloc(sizeof(struct mtdswap_dev), GFP_KERNEL);\n\tif (!d)\n\t\treturn;\n\n\tmbd_dev = kzalloc(sizeof(struct mtd_blktrans_dev), GFP_KERNEL);\n\tif (!mbd_dev) {\n\t\tkfree(d);\n\t\treturn;\n\t}\n\n\td->mbd_dev = mbd_dev;\n\tmbd_dev->priv = d;\n\n\tmbd_dev->mtd = mtd;\n\tmbd_dev->devnum = mtd->index;\n\tmbd_dev->size = swap_size >> PAGE_SHIFT;\n\tmbd_dev->tr = tr;\n\n\tif (!(mtd->flags & MTD_WRITEABLE))\n\t\tmbd_dev->readonly = 1;\n\n\tif (mtdswap_init(d, eblocks, spare_cnt) < 0)\n\t\tgoto init_failed;\n\n\tif (add_mtd_blktrans_dev(mbd_dev) < 0)\n\t\tgoto cleanup;\n\n\td->dev = disk_to_dev(mbd_dev->disk);\n\n\tret = mtdswap_add_debugfs(d);\n\tif (ret < 0)\n\t\tgoto debugfs_failed;\n\n\treturn;\n\ndebugfs_failed:\n\tdel_mtd_blktrans_dev(mbd_dev);\n\ncleanup:\n\tmtdswap_cleanup(d);\n\ninit_failed:\n\tkfree(mbd_dev);\n\tkfree(d);\n}\n\nstatic void mtdswap_remove_dev(struct mtd_blktrans_dev *dev)\n{\n\tstruct mtdswap_dev *d = MTDSWAP_MBD_TO_MTDSWAP(dev);\n\n\tdel_mtd_blktrans_dev(dev);\n\tmtdswap_cleanup(d);\n\tkfree(d);\n}\n\nstatic struct mtd_blktrans_ops mtdswap_ops = {\n\t.name\t\t= \"mtdswap\",\n\t.major\t\t= 0,\n\t.part_bits\t= 0,\n\t.blksize\t= PAGE_SIZE,\n\t.flush\t\t= mtdswap_flush,\n\t.readsect\t= mtdswap_readsect,\n\t.writesect\t= mtdswap_writesect,\n\t.discard\t= mtdswap_discard,\n\t.background\t= mtdswap_background,\n\t.add_mtd\t= mtdswap_add_mtd,\n\t.remove_dev\t= mtdswap_remove_dev,\n\t.owner\t\t= THIS_MODULE,\n};\n\nmodule_mtd_blktrans(mtdswap_ops);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Jarkko Lavinen <jarkko.lavinen@nokia.com>\");\nMODULE_DESCRIPTION(\"Block device access to an MTD suitable for using as \"\n\t\t\"swap space\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}