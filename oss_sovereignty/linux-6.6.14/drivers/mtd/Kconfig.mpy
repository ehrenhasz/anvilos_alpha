{
  "module_name": "Kconfig",
  "hash_id": "5d8ed55729d652e38f564695389a2ff7d41f53f6592120355ac9a744579711b5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/Kconfig",
  "human_readable_source": "menuconfig MTD\n\ttristate \"Memory Technology Device (MTD) support\"\n\timply NVMEM\n\thelp\n\t  Memory Technology Devices are flash, RAM and similar chips, often\n\t  used for solid state file systems on embedded devices. This option\n\t  will provide the generic support for MTD drivers to register\n\t  themselves with the kernel and for potential users of MTD devices\n\t  to enumerate the devices which are present and obtain a handle on\n\t  them. It will also allow you to select individual drivers for\n\t  particular hardware and users of MTD devices. If unsure, say N.\n\nif MTD\n\nconfig MTD_TESTS\n\ttristate \"MTD tests support (DANGEROUS)\"\n\tdepends on m\n\thelp\n\t  This option includes various MTD tests into compilation. The tests\n\t  should normally be compiled as kernel modules. The modules perform\n\t  various checks and verifications when loaded.\n\n\t  WARNING: some of the tests will ERASE entire MTD device which they\n\t  test. Do not use these tests unless you really know what you do.\n\nmenu \"Partition parsers\"\nsource \"drivers/mtd/parsers/Kconfig\"\nendmenu\n\ncomment \"User Modules And Translation Layers\"\n\n#\n# MTD block device support is select'ed if needed\n#\nconfig MTD_BLKDEVS\n\ttristate\n\nconfig MTD_BLOCK\n\ttristate \"Caching block device access to MTD devices\"\n\tdepends on BLOCK\n\tselect MTD_BLKDEVS\n\thelp\n\t  Although most flash chips have an erase size too large to be useful\n\t  as block devices, it is possible to use MTD devices which are based\n\t  on RAM chips in this manner. This block device is a user of MTD\n\t  devices performing that function.\n\n\t  Note that mounting a JFFS2 filesystem doesn't require using mtdblock.\n\t  It's possible to mount a rootfs using the MTD device on the \"root=\"\n\t  bootargs as \"root=mtd2\" or \"root=mtd:name_of_device\".\n\n\t  Later, it may be extended to perform read/erase/modify/write cycles\n\t  on flash chips to emulate a smaller block size. Needless to say,\n\t  this is very unsafe, but could be useful for file systems which are\n\t  almost never written to.\n\n\t  You do not need this option for use with the DiskOnChip devices. For\n\t  those, enable NFTL support (CONFIG_NFTL) instead.\n\nconfig MTD_BLOCK_RO\n\ttristate \"Readonly block device access to MTD devices\"\n\tdepends on MTD_BLOCK!=y && BLOCK\n\tselect MTD_BLKDEVS\n\thelp\n\t  This allows you to mount read-only file systems (such as cramfs)\n\t  from an MTD device, without the overhead (and danger) of the caching\n\t  driver.\n\n\t  You do not need this option for use with the DiskOnChip devices. For\n\t  those, enable NFTL support (CONFIG_NFTL) instead.\n\ncomment \"Note that in some cases UBI block is preferred. See MTD_UBI_BLOCK.\"\n\tdepends on MTD_BLOCK || MTD_BLOCK_RO\n\nconfig FTL\n\ttristate \"FTL (Flash Translation Layer) support\"\n\tdepends on BLOCK\n\tselect MTD_BLKDEVS\n\thelp\n\t  This provides support for the original Flash Translation Layer which\n\t  is part of the PCMCIA specification. It uses a kind of pseudo-\n\t  file system on a flash device to emulate a block device with\n\t  512-byte sectors, on top of which you put a 'normal' file system.\n\n\t  You may find that the algorithms used in this code are patented\n\t  unless you live in the Free World where software patents aren't\n\t  legal - in the USA you are only permitted to use this on PCMCIA\n\t  hardware, although under the terms of the GPL you're obviously\n\t  permitted to copy, modify and distribute the code as you wish. Just\n\t  not use it.\n\nconfig NFTL\n\ttristate \"NFTL (NAND Flash Translation Layer) support\"\n\tdepends on BLOCK\n\tselect MTD_BLKDEVS\n\thelp\n\t  This provides support for the NAND Flash Translation Layer which is\n\t  used on M-Systems' DiskOnChip devices. It uses a kind of pseudo-\n\t  file system on a flash device to emulate a block device with\n\t  512-byte sectors, on top of which you put a 'normal' file system.\n\n\t  You may find that the algorithms used in this code are patented\n\t  unless you live in the Free World where software patents aren't\n\t  legal - in the USA you are only permitted to use this on DiskOnChip\n\t  hardware, although under the terms of the GPL you're obviously\n\t  permitted to copy, modify and distribute the code as you wish. Just\n\t  not use it.\n\nconfig NFTL_RW\n\tbool \"Write support for NFTL\"\n\tdepends on NFTL\n\thelp\n\t  Support for writing to the NAND Flash Translation Layer, as used\n\t  on the DiskOnChip.\n\nconfig INFTL\n\ttristate \"INFTL (Inverse NAND Flash Translation Layer) support\"\n\tdepends on BLOCK\n\tselect MTD_BLKDEVS\n\thelp\n\t  This provides support for the Inverse NAND Flash Translation\n\t  Layer which is used on M-Systems' newer DiskOnChip devices. It\n\t  uses a kind of pseudo-file system on a flash device to emulate\n\t  a block device with 512-byte sectors, on top of which you put\n\t  a 'normal' file system.\n\n\t  You may find that the algorithms used in this code are patented\n\t  unless you live in the Free World where software patents aren't\n\t  legal - in the USA you are only permitted to use this on DiskOnChip\n\t  hardware, although under the terms of the GPL you're obviously\n\t  permitted to copy, modify and distribute the code as you wish. Just\n\t  not use it.\n\nconfig RFD_FTL\n\ttristate \"Resident Flash Disk (Flash Translation Layer) support\"\n\tdepends on BLOCK\n\tselect MTD_BLKDEVS\n\thelp\n\t  This provides support for the flash translation layer known\n\t  as the Resident Flash Disk (RFD), as used by the Embedded BIOS\n\t  of General Software. There is a blurb at:\n\n\t\thttp://www.gensw.com/pages/prod/bios/rfd.htm\n\nconfig SSFDC\n\ttristate \"NAND SSFDC (SmartMedia) read only translation layer\"\n\tdepends on BLOCK\n\tselect MTD_BLKDEVS\n\thelp\n\t  This enables read only access to SmartMedia formatted NAND\n\t  flash. You can mount it with FAT file system.\n\nconfig SM_FTL\n\ttristate \"SmartMedia/xD new translation layer\"\n\tdepends on BLOCK\n\tselect MTD_BLKDEVS\n\tselect MTD_NAND_CORE\n\tselect MTD_NAND_ECC_SW_HAMMING\n\thelp\n\t  This enables EXPERIMENTAL R/W support for SmartMedia/xD\n\t  FTL (Flash translation layer).\n\t  Write support is only lightly tested, therefore this driver\n\t  isn't recommended to use with valuable data (anyway if you have\n\t  valuable data, do backups regardless of software/hardware you\n\t  use, because you never know what will eat your data...)\n\t  If you only need R/O access, you can use older R/O driver\n\t  (CONFIG_SSFDC)\n\nconfig MTD_OOPS\n\ttristate \"Log panic/oops to an MTD buffer\"\n\thelp\n\t  This enables panic and oops messages to be logged to a circular\n\t  buffer in a flash partition where it can be read back at some\n\t  later point.\n\nconfig MTD_PSTORE\n\ttristate \"Log panic/oops to an MTD buffer based on pstore\"\n\tdepends on PSTORE_BLK\n\thelp\n\t  This enables panic and oops messages to be logged to a circular\n\t  buffer in a flash partition where it can be read back as files after\n\t  mounting pstore filesystem.\n\n\t  If unsure, say N.\n\nconfig MTD_SWAP\n\ttristate \"Swap on MTD device support\"\n\tdepends on MTD && SWAP\n\tselect MTD_BLKDEVS\n\thelp\n\t  Provides volatile block device driver on top of mtd partition\n\t  suitable for swapping.  The mapping of written blocks is not saved.\n\t  The driver provides wear leveling by storing erase counter into the\n\t  OOB.\n\nconfig MTD_PARTITIONED_MASTER\n\tbool \"Retain master device when partitioned\"\n\tdefault n\n\tdepends on MTD\n\thelp\n\t  For historical reasons, by default, either a master is present or\n\t  several partitions are present, but not both. The concern was that\n\t  data listed in multiple partitions was dangerous; however, SCSI does\n\t  this and it is frequently useful for applications. This config option\n\t  leaves the master in even if the device is partitioned. It also makes\n\t  the parent of the partition device be the master device, rather than\n\t  what lies behind the master.\n\nsource \"drivers/mtd/chips/Kconfig\"\n\nsource \"drivers/mtd/maps/Kconfig\"\n\nsource \"drivers/mtd/devices/Kconfig\"\n\nsource \"drivers/mtd/nand/Kconfig\"\n\nsource \"drivers/mtd/lpddr/Kconfig\"\n\nsource \"drivers/mtd/spi-nor/Kconfig\"\n\nsource \"drivers/mtd/ubi/Kconfig\"\n\nsource \"drivers/mtd/hyperbus/Kconfig\"\n\nendif # MTD\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}