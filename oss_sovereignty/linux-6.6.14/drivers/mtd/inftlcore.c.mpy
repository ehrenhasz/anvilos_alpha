{
  "module_name": "inftlcore.c",
  "hash_id": "dbd887ed20ebc55f3d203de876f648dc55c12293e42ce33ef5dde8875375f74e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/inftlcore.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/kmod.h>\n#include <linux/hdreg.h>\n#include <linux/mtd/mtd.h>\n#include <linux/mtd/nftl.h>\n#include <linux/mtd/inftl.h>\n#include <linux/mtd/rawnand.h>\n#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/io.h>\n\n \n#define MAX_LOOPS 10000\n\nstatic void inftl_add_mtd(struct mtd_blktrans_ops *tr, struct mtd_info *mtd)\n{\n\tstruct INFTLrecord *inftl;\n\tunsigned long temp;\n\n\tif (!mtd_type_is_nand(mtd) || mtd->size > UINT_MAX)\n\t\treturn;\n\t \n\tif (memcmp(mtd->name, \"DiskOnChip\", 10))\n\t\treturn;\n\n\tif (!mtd->_block_isbad) {\n\t\tprintk(KERN_ERR\n\"INFTL no longer supports the old DiskOnChip drivers loaded via docprobe.\\n\"\n\"Please use the new diskonchip driver under the NAND subsystem.\\n\");\n\t\treturn;\n\t}\n\n\tpr_debug(\"INFTL: add_mtd for %s\\n\", mtd->name);\n\n\tinftl = kzalloc(sizeof(*inftl), GFP_KERNEL);\n\n\tif (!inftl)\n\t\treturn;\n\n\tinftl->mbd.mtd = mtd;\n\tinftl->mbd.devnum = -1;\n\n\tinftl->mbd.tr = tr;\n\n\tif (INFTL_mount(inftl) < 0) {\n\t\tprintk(KERN_WARNING \"INFTL: could not mount device\\n\");\n\t\tkfree(inftl);\n\t\treturn;\n\t}\n\n\t \n\n\t \n\tinftl->cylinders = 1024;\n\tinftl->heads = 16;\n\n\ttemp = inftl->cylinders * inftl->heads;\n\tinftl->sectors = inftl->mbd.size / temp;\n\tif (inftl->mbd.size % temp) {\n\t\tinftl->sectors++;\n\t\ttemp = inftl->cylinders * inftl->sectors;\n\t\tinftl->heads = inftl->mbd.size / temp;\n\n\t\tif (inftl->mbd.size % temp) {\n\t\t\tinftl->heads++;\n\t\t\ttemp = inftl->heads * inftl->sectors;\n\t\t\tinftl->cylinders = inftl->mbd.size / temp;\n\t\t}\n\t}\n\n\tif (inftl->mbd.size != inftl->heads * inftl->cylinders * inftl->sectors) {\n\t\t \n\t\tprintk(KERN_WARNING \"INFTL: cannot calculate a geometry to \"\n\t\t       \"match size of 0x%lx.\\n\", inftl->mbd.size);\n\t\tprintk(KERN_WARNING \"INFTL: using C:%d H:%d S:%d \"\n\t\t\t\"(== 0x%lx sects)\\n\",\n\t\t\tinftl->cylinders, inftl->heads , inftl->sectors,\n\t\t\t(long)inftl->cylinders * (long)inftl->heads *\n\t\t\t(long)inftl->sectors );\n\t}\n\n\tif (add_mtd_blktrans_dev(&inftl->mbd)) {\n\t\tkfree(inftl->PUtable);\n\t\tkfree(inftl->VUtable);\n\t\tkfree(inftl);\n\t\treturn;\n\t}\n#ifdef PSYCHO_DEBUG\n\tprintk(KERN_INFO \"INFTL: Found new inftl%c\\n\", inftl->mbd.devnum + 'a');\n#endif\n\treturn;\n}\n\nstatic void inftl_remove_dev(struct mtd_blktrans_dev *dev)\n{\n\tstruct INFTLrecord *inftl = (void *)dev;\n\n\tpr_debug(\"INFTL: remove_dev (i=%d)\\n\", dev->devnum);\n\n\tdel_mtd_blktrans_dev(dev);\n\n\tkfree(inftl->PUtable);\n\tkfree(inftl->VUtable);\n}\n\n \n\n \nint inftl_read_oob(struct mtd_info *mtd, loff_t offs, size_t len,\n\t\t   size_t *retlen, uint8_t *buf)\n{\n\tstruct mtd_oob_ops ops = { };\n\tint res;\n\n\tops.mode = MTD_OPS_PLACE_OOB;\n\tops.ooboffs = offs & (mtd->writesize - 1);\n\tops.ooblen = len;\n\tops.oobbuf = buf;\n\tops.datbuf = NULL;\n\n\tres = mtd_read_oob(mtd, offs & ~(mtd->writesize - 1), &ops);\n\t*retlen = ops.oobretlen;\n\treturn res;\n}\n\n \nint inftl_write_oob(struct mtd_info *mtd, loff_t offs, size_t len,\n\t\t    size_t *retlen, uint8_t *buf)\n{\n\tstruct mtd_oob_ops ops = { };\n\tint res;\n\n\tops.mode = MTD_OPS_PLACE_OOB;\n\tops.ooboffs = offs & (mtd->writesize - 1);\n\tops.ooblen = len;\n\tops.oobbuf = buf;\n\tops.datbuf = NULL;\n\n\tres = mtd_write_oob(mtd, offs & ~(mtd->writesize - 1), &ops);\n\t*retlen = ops.oobretlen;\n\treturn res;\n}\n\n \nstatic int inftl_write(struct mtd_info *mtd, loff_t offs, size_t len,\n\t\t       size_t *retlen, uint8_t *buf, uint8_t *oob)\n{\n\tstruct mtd_oob_ops ops = { };\n\tint res;\n\n\tops.mode = MTD_OPS_PLACE_OOB;\n\tops.ooboffs = offs;\n\tops.ooblen = mtd->oobsize;\n\tops.oobbuf = oob;\n\tops.datbuf = buf;\n\tops.len = len;\n\n\tres = mtd_write_oob(mtd, offs & ~(mtd->writesize - 1), &ops);\n\t*retlen = ops.retlen;\n\treturn res;\n}\n\n \nstatic u16 INFTL_findfreeblock(struct INFTLrecord *inftl, int desperate)\n{\n\tu16 pot = inftl->LastFreeEUN;\n\tint silly = inftl->nb_blocks;\n\n\tpr_debug(\"INFTL: INFTL_findfreeblock(inftl=%p,desperate=%d)\\n\",\n\t\t\tinftl, desperate);\n\n\t \n\tif (!desperate && inftl->numfreeEUNs < 2) {\n\t\tpr_debug(\"INFTL: there are too few free EUNs (%d)\\n\",\n\t\t\t\tinftl->numfreeEUNs);\n\t\treturn BLOCK_NIL;\n\t}\n\n\t \n\tdo {\n\t\tif (inftl->PUtable[pot] == BLOCK_FREE) {\n\t\t\tinftl->LastFreeEUN = pot;\n\t\t\treturn pot;\n\t\t}\n\n\t\tif (++pot > inftl->lastEUN)\n\t\t\tpot = 0;\n\n\t\tif (!silly--) {\n\t\t\tprintk(KERN_WARNING \"INFTL: no free blocks found!  \"\n\t\t\t\t\"EUN range = %d - %d\\n\", 0, inftl->LastFreeEUN);\n\t\t\treturn BLOCK_NIL;\n\t\t}\n\t} while (pot != inftl->LastFreeEUN);\n\n\treturn BLOCK_NIL;\n}\n\nstatic u16 INFTL_foldchain(struct INFTLrecord *inftl, unsigned thisVUC, unsigned pendingblock)\n{\n\tu16 BlockMap[MAX_SECTORS_PER_UNIT];\n\tunsigned char BlockDeleted[MAX_SECTORS_PER_UNIT];\n\tunsigned int thisEUN, prevEUN, status;\n\tstruct mtd_info *mtd = inftl->mbd.mtd;\n\tint block, silly;\n\tunsigned int targetEUN;\n\tstruct inftl_oob oob;\n\tsize_t retlen;\n\n\tpr_debug(\"INFTL: INFTL_foldchain(inftl=%p,thisVUC=%d,pending=%d)\\n\",\n\t\t\tinftl, thisVUC, pendingblock);\n\n\tmemset(BlockMap, 0xff, sizeof(BlockMap));\n\tmemset(BlockDeleted, 0, sizeof(BlockDeleted));\n\n\tthisEUN = targetEUN = inftl->VUtable[thisVUC];\n\n\tif (thisEUN == BLOCK_NIL) {\n\t\tprintk(KERN_WARNING \"INFTL: trying to fold non-existent \"\n\t\t       \"Virtual Unit Chain %d!\\n\", thisVUC);\n\t\treturn BLOCK_NIL;\n\t}\n\n\t \n\tsilly = MAX_LOOPS;\n\twhile (thisEUN < inftl->nb_blocks) {\n\t\tfor (block = 0; block < inftl->EraseSize/SECTORSIZE; block ++) {\n\t\t\tif ((BlockMap[block] != BLOCK_NIL) ||\n\t\t\t    BlockDeleted[block])\n\t\t\t\tcontinue;\n\n\t\t\tif (inftl_read_oob(mtd, (thisEUN * inftl->EraseSize)\n\t\t\t\t\t   + (block * SECTORSIZE), 16, &retlen,\n\t\t\t\t\t   (char *)&oob) < 0)\n\t\t\t\tstatus = SECTOR_IGNORE;\n\t\t\telse\n\t\t\t\tstatus = oob.b.Status | oob.b.Status1;\n\n\t\t\tswitch(status) {\n\t\t\tcase SECTOR_FREE:\n\t\t\tcase SECTOR_IGNORE:\n\t\t\t\tbreak;\n\t\t\tcase SECTOR_USED:\n\t\t\t\tBlockMap[block] = thisEUN;\n\t\t\t\tcontinue;\n\t\t\tcase SECTOR_DELETED:\n\t\t\t\tBlockDeleted[block] = 1;\n\t\t\t\tcontinue;\n\t\t\tdefault:\n\t\t\t\tprintk(KERN_WARNING \"INFTL: unknown status \"\n\t\t\t\t\t\"for block %d in EUN %d: %x\\n\",\n\t\t\t\t\tblock, thisEUN, status);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!silly--) {\n\t\t\tprintk(KERN_WARNING \"INFTL: infinite loop in Virtual \"\n\t\t\t\t\"Unit Chain 0x%x\\n\", thisVUC);\n\t\t\treturn BLOCK_NIL;\n\t\t}\n\n\t\tthisEUN = inftl->PUtable[thisEUN];\n\t}\n\n\t \n\tpr_debug(\"INFTL: folding chain %d into unit %d\\n\", thisVUC, targetEUN);\n\n\tfor (block = 0; block < inftl->EraseSize/SECTORSIZE ; block++) {\n\t\tunsigned char movebuf[SECTORSIZE];\n\t\tint ret;\n\n\t\t \n\t\tif (BlockMap[block] == targetEUN || (pendingblock ==\n\t\t    (thisVUC * (inftl->EraseSize / SECTORSIZE) + block))) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (BlockMap[block] == BLOCK_NIL)\n\t\t\tcontinue;\n\n\t\tret = mtd_read(mtd,\n\t\t\t       (inftl->EraseSize * BlockMap[block]) + (block * SECTORSIZE),\n\t\t\t       SECTORSIZE,\n\t\t\t       &retlen,\n\t\t\t       movebuf);\n\t\tif (ret < 0 && !mtd_is_bitflip(ret)) {\n\t\t\tret = mtd_read(mtd,\n\t\t\t\t       (inftl->EraseSize * BlockMap[block]) + (block * SECTORSIZE),\n\t\t\t\t       SECTORSIZE,\n\t\t\t\t       &retlen,\n\t\t\t\t       movebuf);\n\t\t\tif (ret != -EIO)\n\t\t\t\tpr_debug(\"INFTL: error went away on retry?\\n\");\n\t\t}\n\t\tmemset(&oob, 0xff, sizeof(struct inftl_oob));\n\t\toob.b.Status = oob.b.Status1 = SECTOR_USED;\n\n\t\tinftl_write(inftl->mbd.mtd, (inftl->EraseSize * targetEUN) +\n\t\t\t    (block * SECTORSIZE), SECTORSIZE, &retlen,\n\t\t\t    movebuf, (char *)&oob);\n\t}\n\n\t \n\tpr_debug(\"INFTL: want to erase virtual chain %d\\n\", thisVUC);\n\n\tfor (;;) {\n\t\t \n\t\tthisEUN = inftl->VUtable[thisVUC];\n\t\tprevEUN = BLOCK_NIL;\n\t\twhile (inftl->PUtable[thisEUN] != BLOCK_NIL) {\n\t\t\tprevEUN = thisEUN;\n\t\t\tthisEUN = inftl->PUtable[thisEUN];\n\t\t}\n\n\t\t \n\t\tif (thisEUN == targetEUN)\n\t\t\tbreak;\n\n\t\t \n\t\tinftl->PUtable[prevEUN] = BLOCK_NIL;\n\n\t\t \n\t\tif (INFTL_formatblock(inftl, thisEUN) < 0) {\n\t\t\t \n\t\t\tinftl->PUtable[thisEUN] = BLOCK_RESERVED;\n\t\t} else {\n\t\t\t \n\t\t\tinftl->PUtable[thisEUN] = BLOCK_FREE;\n\t\t\tinftl->numfreeEUNs++;\n\t\t}\n\t}\n\n\treturn targetEUN;\n}\n\nstatic u16 INFTL_makefreeblock(struct INFTLrecord *inftl, unsigned pendingblock)\n{\n\t \n\tu16 LongestChain = 0;\n\tu16 ChainLength = 0, thislen;\n\tu16 chain, EUN;\n\n\tpr_debug(\"INFTL: INFTL_makefreeblock(inftl=%p,\"\n\t\t\"pending=%d)\\n\", inftl, pendingblock);\n\n\tfor (chain = 0; chain < inftl->nb_blocks; chain++) {\n\t\tEUN = inftl->VUtable[chain];\n\t\tthislen = 0;\n\n\t\twhile (EUN <= inftl->lastEUN) {\n\t\t\tthislen++;\n\t\t\tEUN = inftl->PUtable[EUN];\n\t\t\tif (thislen > 0xff00) {\n\t\t\t\tprintk(KERN_WARNING \"INFTL: endless loop in \"\n\t\t\t\t\t\"Virtual Chain %d: Unit %x\\n\",\n\t\t\t\t\tchain, EUN);\n\t\t\t\t \n\t\t\t\tthislen = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (thislen > ChainLength) {\n\t\t\tChainLength = thislen;\n\t\t\tLongestChain = chain;\n\t\t}\n\t}\n\n\tif (ChainLength < 2) {\n\t\tprintk(KERN_WARNING \"INFTL: no Virtual Unit Chains available \"\n\t\t\t\"for folding. Failing request\\n\");\n\t\treturn BLOCK_NIL;\n\t}\n\n\treturn INFTL_foldchain(inftl, LongestChain, pendingblock);\n}\n\nstatic int nrbits(unsigned int val, int bitcount)\n{\n\tint i, total = 0;\n\n\tfor (i = 0; (i < bitcount); i++)\n\t\ttotal += (((0x1 << i) & val) ? 1 : 0);\n\treturn total;\n}\n\n \nstatic inline u16 INFTL_findwriteunit(struct INFTLrecord *inftl, unsigned block)\n{\n\tunsigned int thisVUC = block / (inftl->EraseSize / SECTORSIZE);\n\tunsigned int thisEUN, writeEUN, prev_block, status;\n\tunsigned long blockofs = (block * SECTORSIZE) & (inftl->EraseSize -1);\n\tstruct mtd_info *mtd = inftl->mbd.mtd;\n\tstruct inftl_oob oob;\n\tstruct inftl_bci bci;\n\tunsigned char anac, nacs, parity;\n\tsize_t retlen;\n\tint silly, silly2 = 3;\n\n\tpr_debug(\"INFTL: INFTL_findwriteunit(inftl=%p,block=%d)\\n\",\n\t\t\tinftl, block);\n\n\tdo {\n\t\t \n\t\twriteEUN = BLOCK_NIL;\n\t\tthisEUN = inftl->VUtable[thisVUC];\n\t\tsilly = MAX_LOOPS;\n\n\t\twhile (thisEUN <= inftl->lastEUN) {\n\t\t\tinftl_read_oob(mtd, (thisEUN * inftl->EraseSize) +\n\t\t\t\t       blockofs, 8, &retlen, (char *)&bci);\n\n\t\t\tstatus = bci.Status | bci.Status1;\n\t\t\tpr_debug(\"INFTL: status of block %d in EUN %d is %x\\n\",\n\t\t\t\t\tblock , writeEUN, status);\n\n\t\t\tswitch(status) {\n\t\t\tcase SECTOR_FREE:\n\t\t\t\twriteEUN = thisEUN;\n\t\t\t\tbreak;\n\t\t\tcase SECTOR_DELETED:\n\t\t\tcase SECTOR_USED:\n\t\t\t\t \n\t\t\t\tgoto hitused;\n\t\t\tcase SECTOR_IGNORE:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t \n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (!silly--) {\n\t\t\t\tprintk(KERN_WARNING \"INFTL: infinite loop in \"\n\t\t\t\t\t\"Virtual Unit Chain 0x%x\\n\", thisVUC);\n\t\t\t\treturn BLOCK_NIL;\n\t\t\t}\n\n\t\t\t \n\t\t\tthisEUN = inftl->PUtable[thisEUN];\n\t\t}\n\nhitused:\n\t\tif (writeEUN != BLOCK_NIL)\n\t\t\treturn writeEUN;\n\n\n\t\t \n\t\twriteEUN = INFTL_findfreeblock(inftl, 0);\n\n\t\tif (writeEUN == BLOCK_NIL) {\n\t\t\t \n\t\t\tthisEUN = INFTL_makefreeblock(inftl, block);\n\n\t\t\t \n\t\t\tpr_debug(\"INFTL: using desperate==1 to find free EUN \"\n\t\t\t\t\t\"to accommodate write to VUC %d\\n\",\n\t\t\t\t\tthisVUC);\n\t\t\twriteEUN = INFTL_findfreeblock(inftl, 1);\n\t\t\tif (writeEUN == BLOCK_NIL) {\n\t\t\t\t \n\t\t\t\tprintk(KERN_WARNING \"INFTL: cannot make free \"\n\t\t\t\t\t\"space.\\n\");\n#ifdef DEBUG\n\t\t\t\tINFTL_dumptables(inftl);\n\t\t\t\tINFTL_dumpVUchains(inftl);\n#endif\n\t\t\t\treturn BLOCK_NIL;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tanac = 0;\n\t\tnacs = 0;\n\t\tthisEUN = inftl->VUtable[thisVUC];\n\t\tif (thisEUN != BLOCK_NIL) {\n\t\t\tinftl_read_oob(mtd, thisEUN * inftl->EraseSize\n\t\t\t\t       + 8, 8, &retlen, (char *)&oob.u);\n\t\t\tanac = oob.u.a.ANAC + 1;\n\t\t\tnacs = oob.u.a.NACs + 1;\n\t\t}\n\n\t\tprev_block = inftl->VUtable[thisVUC];\n\t\tif (prev_block < inftl->nb_blocks)\n\t\t\tprev_block -= inftl->firstEUN;\n\n\t\tparity = (nrbits(thisVUC, 16) & 0x1) ? 0x1 : 0;\n\t\tparity |= (nrbits(prev_block, 16) & 0x1) ? 0x2 : 0;\n\t\tparity |= (nrbits(anac, 8) & 0x1) ? 0x4 : 0;\n\t\tparity |= (nrbits(nacs, 8) & 0x1) ? 0x8 : 0;\n\n\t\toob.u.a.virtualUnitNo = cpu_to_le16(thisVUC);\n\t\toob.u.a.prevUnitNo = cpu_to_le16(prev_block);\n\t\toob.u.a.ANAC = anac;\n\t\toob.u.a.NACs = nacs;\n\t\toob.u.a.parityPerField = parity;\n\t\toob.u.a.discarded = 0xaa;\n\n\t\tinftl_write_oob(mtd, writeEUN * inftl->EraseSize + 8, 8,\n\t\t\t\t&retlen, (char *)&oob.u);\n\n\t\t \n\t\toob.u.b.virtualUnitNo = cpu_to_le16(thisVUC);\n\t\toob.u.b.prevUnitNo = cpu_to_le16(prev_block);\n\t\toob.u.b.ANAC = anac;\n\t\toob.u.b.NACs = nacs;\n\t\toob.u.b.parityPerField = parity;\n\t\toob.u.b.discarded = 0xaa;\n\n\t\tinftl_write_oob(mtd, writeEUN * inftl->EraseSize +\n\t\t\t\tSECTORSIZE * 4 + 8, 8, &retlen, (char *)&oob.u);\n\n\t\tinftl->PUtable[writeEUN] = inftl->VUtable[thisVUC];\n\t\tinftl->VUtable[thisVUC] = writeEUN;\n\n\t\tinftl->numfreeEUNs--;\n\t\treturn writeEUN;\n\n\t} while (silly2--);\n\n\tprintk(KERN_WARNING \"INFTL: error folding to make room for Virtual \"\n\t\t\"Unit Chain 0x%x\\n\", thisVUC);\n\treturn BLOCK_NIL;\n}\n\n \nstatic void INFTL_trydeletechain(struct INFTLrecord *inftl, unsigned thisVUC)\n{\n\tstruct mtd_info *mtd = inftl->mbd.mtd;\n\tunsigned char BlockUsed[MAX_SECTORS_PER_UNIT];\n\tunsigned char BlockDeleted[MAX_SECTORS_PER_UNIT];\n\tunsigned int thisEUN, status;\n\tint block, silly;\n\tstruct inftl_bci bci;\n\tsize_t retlen;\n\n\tpr_debug(\"INFTL: INFTL_trydeletechain(inftl=%p,\"\n\t\t\"thisVUC=%d)\\n\", inftl, thisVUC);\n\n\tmemset(BlockUsed, 0, sizeof(BlockUsed));\n\tmemset(BlockDeleted, 0, sizeof(BlockDeleted));\n\n\tthisEUN = inftl->VUtable[thisVUC];\n\tif (thisEUN == BLOCK_NIL) {\n\t\tprintk(KERN_WARNING \"INFTL: trying to delete non-existent \"\n\t\t       \"Virtual Unit Chain %d!\\n\", thisVUC);\n\t\treturn;\n\t}\n\n\t \n\tsilly = MAX_LOOPS;\n\twhile (thisEUN < inftl->nb_blocks) {\n\t\tfor (block = 0; block < inftl->EraseSize/SECTORSIZE; block++) {\n\t\t\tif (BlockUsed[block] || BlockDeleted[block])\n\t\t\t\tcontinue;\n\n\t\t\tif (inftl_read_oob(mtd, (thisEUN * inftl->EraseSize)\n\t\t\t\t\t   + (block * SECTORSIZE), 8 , &retlen,\n\t\t\t\t\t  (char *)&bci) < 0)\n\t\t\t\tstatus = SECTOR_IGNORE;\n\t\t\telse\n\t\t\t\tstatus = bci.Status | bci.Status1;\n\n\t\t\tswitch(status) {\n\t\t\tcase SECTOR_FREE:\n\t\t\tcase SECTOR_IGNORE:\n\t\t\t\tbreak;\n\t\t\tcase SECTOR_USED:\n\t\t\t\tBlockUsed[block] = 1;\n\t\t\t\tcontinue;\n\t\t\tcase SECTOR_DELETED:\n\t\t\t\tBlockDeleted[block] = 1;\n\t\t\t\tcontinue;\n\t\t\tdefault:\n\t\t\t\tprintk(KERN_WARNING \"INFTL: unknown status \"\n\t\t\t\t\t\"for block %d in EUN %d: 0x%x\\n\",\n\t\t\t\t\tblock, thisEUN, status);\n\t\t\t}\n\t\t}\n\n\t\tif (!silly--) {\n\t\t\tprintk(KERN_WARNING \"INFTL: infinite loop in Virtual \"\n\t\t\t\t\"Unit Chain 0x%x\\n\", thisVUC);\n\t\t\treturn;\n\t\t}\n\n\t\tthisEUN = inftl->PUtable[thisEUN];\n\t}\n\n\tfor (block = 0; block < inftl->EraseSize/SECTORSIZE; block++)\n\t\tif (BlockUsed[block])\n\t\t\treturn;\n\n\t \n\tpr_debug(\"INFTL: deleting empty VUC %d\\n\", thisVUC);\n\n\tfor (;;) {\n\t\tu16 *prevEUN = &inftl->VUtable[thisVUC];\n\t\tthisEUN = *prevEUN;\n\n\t\t \n\t\tif (thisEUN == BLOCK_NIL) {\n\t\t\tpr_debug(\"INFTL: Empty VUC %d for deletion was already absent\\n\", thisEUN);\n\t\t\treturn;\n\t\t}\n\n\t\t \n\t\twhile (inftl->PUtable[thisEUN] != BLOCK_NIL) {\n\t\t\tBUG_ON(thisEUN >= inftl->nb_blocks);\n\n\t\t\tprevEUN = &inftl->PUtable[thisEUN];\n\t\t\tthisEUN = *prevEUN;\n\t\t}\n\n\t\tpr_debug(\"Deleting EUN %d from VUC %d\\n\",\n\t\t      thisEUN, thisVUC);\n\n\t\tif (INFTL_formatblock(inftl, thisEUN) < 0) {\n\t\t\t \n\t\t\tinftl->PUtable[thisEUN] = BLOCK_RESERVED;\n\t\t} else {\n\t\t\t \n\t\t\tinftl->PUtable[thisEUN] = BLOCK_FREE;\n\t\t\tinftl->numfreeEUNs++;\n\t\t}\n\n\t\t \n\t\t*prevEUN = BLOCK_NIL;\n\n\t\t \n\t\tcond_resched();\n\t}\n\n\tinftl->VUtable[thisVUC] = BLOCK_NIL;\n}\n\nstatic int INFTL_deleteblock(struct INFTLrecord *inftl, unsigned block)\n{\n\tunsigned int thisEUN = inftl->VUtable[block / (inftl->EraseSize / SECTORSIZE)];\n\tunsigned long blockofs = (block * SECTORSIZE) & (inftl->EraseSize - 1);\n\tstruct mtd_info *mtd = inftl->mbd.mtd;\n\tunsigned int status;\n\tint silly = MAX_LOOPS;\n\tsize_t retlen;\n\tstruct inftl_bci bci;\n\n\tpr_debug(\"INFTL: INFTL_deleteblock(inftl=%p,\"\n\t\t\"block=%d)\\n\", inftl, block);\n\n\twhile (thisEUN < inftl->nb_blocks) {\n\t\tif (inftl_read_oob(mtd, (thisEUN * inftl->EraseSize) +\n\t\t\t\t   blockofs, 8, &retlen, (char *)&bci) < 0)\n\t\t\tstatus = SECTOR_IGNORE;\n\t\telse\n\t\t\tstatus = bci.Status | bci.Status1;\n\n\t\tswitch (status) {\n\t\tcase SECTOR_FREE:\n\t\tcase SECTOR_IGNORE:\n\t\t\tbreak;\n\t\tcase SECTOR_DELETED:\n\t\t\tthisEUN = BLOCK_NIL;\n\t\t\tgoto foundit;\n\t\tcase SECTOR_USED:\n\t\t\tgoto foundit;\n\t\tdefault:\n\t\t\tprintk(KERN_WARNING \"INFTL: unknown status for \"\n\t\t\t\t\"block %d in EUN %d: 0x%x\\n\",\n\t\t\t\tblock, thisEUN, status);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!silly--) {\n\t\t\tprintk(KERN_WARNING \"INFTL: infinite loop in Virtual \"\n\t\t\t\t\"Unit Chain 0x%x\\n\",\n\t\t\t\tblock / (inftl->EraseSize / SECTORSIZE));\n\t\t\treturn 1;\n\t\t}\n\t\tthisEUN = inftl->PUtable[thisEUN];\n\t}\n\nfoundit:\n\tif (thisEUN != BLOCK_NIL) {\n\t\tloff_t ptr = (thisEUN * inftl->EraseSize) + blockofs;\n\n\t\tif (inftl_read_oob(mtd, ptr, 8, &retlen, (char *)&bci) < 0)\n\t\t\treturn -EIO;\n\t\tbci.Status = bci.Status1 = SECTOR_DELETED;\n\t\tif (inftl_write_oob(mtd, ptr, 8, &retlen, (char *)&bci) < 0)\n\t\t\treturn -EIO;\n\t\tINFTL_trydeletechain(inftl, block / (inftl->EraseSize / SECTORSIZE));\n\t}\n\treturn 0;\n}\n\nstatic int inftl_writeblock(struct mtd_blktrans_dev *mbd, unsigned long block,\n\t\t\t    char *buffer)\n{\n\tstruct INFTLrecord *inftl = (void *)mbd;\n\tunsigned int writeEUN;\n\tunsigned long blockofs = (block * SECTORSIZE) & (inftl->EraseSize - 1);\n\tsize_t retlen;\n\tstruct inftl_oob oob;\n\tchar *p, *pend;\n\n\tpr_debug(\"INFTL: inftl_writeblock(inftl=%p,block=%ld,\"\n\t\t\"buffer=%p)\\n\", inftl, block, buffer);\n\n\t \n\tpend = buffer + SECTORSIZE;\n\tfor (p = buffer; p < pend && !*p; p++)\n\t\t;\n\n\tif (p < pend) {\n\t\twriteEUN = INFTL_findwriteunit(inftl, block);\n\n\t\tif (writeEUN == BLOCK_NIL) {\n\t\t\tprintk(KERN_WARNING \"inftl_writeblock(): cannot find \"\n\t\t\t\t\"block to write to\\n\");\n\t\t\t \n\t\t\treturn 1;\n\t\t}\n\n\t\tmemset(&oob, 0xff, sizeof(struct inftl_oob));\n\t\toob.b.Status = oob.b.Status1 = SECTOR_USED;\n\n\t\tinftl_write(inftl->mbd.mtd, (writeEUN * inftl->EraseSize) +\n\t\t\t    blockofs, SECTORSIZE, &retlen, (char *)buffer,\n\t\t\t    (char *)&oob);\n\t\t \n\t} else {\n\t\tINFTL_deleteblock(inftl, block);\n\t}\n\n\treturn 0;\n}\n\nstatic int inftl_readblock(struct mtd_blktrans_dev *mbd, unsigned long block,\n\t\t\t   char *buffer)\n{\n\tstruct INFTLrecord *inftl = (void *)mbd;\n\tunsigned int thisEUN = inftl->VUtable[block / (inftl->EraseSize / SECTORSIZE)];\n\tunsigned long blockofs = (block * SECTORSIZE) & (inftl->EraseSize - 1);\n\tstruct mtd_info *mtd = inftl->mbd.mtd;\n\tunsigned int status;\n\tint silly = MAX_LOOPS;\n\tstruct inftl_bci bci;\n\tsize_t retlen;\n\n\tpr_debug(\"INFTL: inftl_readblock(inftl=%p,block=%ld,\"\n\t\t\"buffer=%p)\\n\", inftl, block, buffer);\n\n\twhile (thisEUN < inftl->nb_blocks) {\n\t\tif (inftl_read_oob(mtd, (thisEUN * inftl->EraseSize) +\n\t\t\t\t  blockofs, 8, &retlen, (char *)&bci) < 0)\n\t\t\tstatus = SECTOR_IGNORE;\n\t\telse\n\t\t\tstatus = bci.Status | bci.Status1;\n\n\t\tswitch (status) {\n\t\tcase SECTOR_DELETED:\n\t\t\tthisEUN = BLOCK_NIL;\n\t\t\tgoto foundit;\n\t\tcase SECTOR_USED:\n\t\t\tgoto foundit;\n\t\tcase SECTOR_FREE:\n\t\tcase SECTOR_IGNORE:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintk(KERN_WARNING \"INFTL: unknown status for \"\n\t\t\t\t\"block %ld in EUN %d: 0x%04x\\n\",\n\t\t\t\tblock, thisEUN, status);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!silly--) {\n\t\t\tprintk(KERN_WARNING \"INFTL: infinite loop in \"\n\t\t\t\t\"Virtual Unit Chain 0x%lx\\n\",\n\t\t\t\tblock / (inftl->EraseSize / SECTORSIZE));\n\t\t\treturn 1;\n\t\t}\n\n\t\tthisEUN = inftl->PUtable[thisEUN];\n\t}\n\nfoundit:\n\tif (thisEUN == BLOCK_NIL) {\n\t\t \n\t\tmemset(buffer, 0, SECTORSIZE);\n\t} else {\n\t\tsize_t retlen;\n\t\tloff_t ptr = (thisEUN * inftl->EraseSize) + blockofs;\n\t\tint ret = mtd_read(mtd, ptr, SECTORSIZE, &retlen, buffer);\n\n\t\t \n\t\tif (ret < 0 && !mtd_is_bitflip(ret))\n\t\t\treturn -EIO;\n\t}\n\treturn 0;\n}\n\nstatic int inftl_getgeo(struct mtd_blktrans_dev *dev, struct hd_geometry *geo)\n{\n\tstruct INFTLrecord *inftl = (void *)dev;\n\n\tgeo->heads = inftl->heads;\n\tgeo->sectors = inftl->sectors;\n\tgeo->cylinders = inftl->cylinders;\n\n\treturn 0;\n}\n\nstatic struct mtd_blktrans_ops inftl_tr = {\n\t.name\t\t= \"inftl\",\n\t.major\t\t= INFTL_MAJOR,\n\t.part_bits\t= INFTL_PARTN_BITS,\n\t.blksize \t= 512,\n\t.getgeo\t\t= inftl_getgeo,\n\t.readsect\t= inftl_readblock,\n\t.writesect\t= inftl_writeblock,\n\t.add_mtd\t= inftl_add_mtd,\n\t.remove_dev\t= inftl_remove_dev,\n\t.owner\t\t= THIS_MODULE,\n};\n\nmodule_mtd_blktrans(inftl_tr);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Greg Ungerer <gerg@snapgear.com>, David Woodhouse <dwmw2@infradead.org>, Fabrice Bellard <fabrice.bellard@netgem.com> et al.\");\nMODULE_DESCRIPTION(\"Support code for Inverse Flash Translation Layer, used on M-Systems DiskOnChip 2000, Millennium and Millennium Plus\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}