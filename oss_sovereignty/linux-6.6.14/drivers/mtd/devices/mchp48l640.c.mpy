{
  "module_name": "mchp48l640.c",
  "hash_id": "a703197dfd50e6dfe689dc4deb51a831e95926833dd165ae1f2cbb8b4c075255",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/devices/mchp48l640.c",
  "human_readable_source": "\n \n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/jiffies.h>\n#include <linux/module.h>\n#include <linux/mtd/mtd.h>\n#include <linux/mtd/partitions.h>\n#include <linux/mutex.h>\n#include <linux/sched.h>\n#include <linux/sizes.h>\n#include <linux/spi/flash.h>\n#include <linux/spi/spi.h>\n#include <linux/of.h>\n\nstruct mchp48_caps {\n\tunsigned int size;\n\tunsigned int page_size;\n};\n\nstruct mchp48l640_flash {\n\tstruct spi_device\t*spi;\n\tstruct mutex\t\tlock;\n\tstruct mtd_info\t\tmtd;\n\tconst struct mchp48_caps\t*caps;\n};\n\n#define MCHP48L640_CMD_WREN\t\t0x06\n#define MCHP48L640_CMD_WRDI\t\t0x04\n#define MCHP48L640_CMD_WRITE\t\t0x02\n#define MCHP48L640_CMD_READ\t\t0x03\n#define MCHP48L640_CMD_WRSR\t\t0x01\n#define MCHP48L640_CMD_RDSR\t\t0x05\n\n#define MCHP48L640_STATUS_RDY\t\t0x01\n#define MCHP48L640_STATUS_WEL\t\t0x02\n#define MCHP48L640_STATUS_BP0\t\t0x04\n#define MCHP48L640_STATUS_BP1\t\t0x08\n#define MCHP48L640_STATUS_SWM\t\t0x10\n#define MCHP48L640_STATUS_PRO\t\t0x20\n#define MCHP48L640_STATUS_ASE\t\t0x40\n\n#define MCHP48L640_TIMEOUT\t\t100\n\n#define MAX_CMD_SIZE\t\t\t0x10\n\n#define to_mchp48l640_flash(x) container_of(x, struct mchp48l640_flash, mtd)\n\nstatic int mchp48l640_mkcmd(struct mchp48l640_flash *flash, u8 cmd, loff_t addr, char *buf)\n{\n\tbuf[0] = cmd;\n\tbuf[1] = addr >> 8;\n\tbuf[2] = addr;\n\n\treturn 3;\n}\n\nstatic int mchp48l640_read_status(struct mchp48l640_flash *flash, int *status)\n{\n\tunsigned char cmd[2];\n\tint ret;\n\n\tcmd[0] = MCHP48L640_CMD_RDSR;\n\tcmd[1] = 0x00;\n\tmutex_lock(&flash->lock);\n\tret = spi_write_then_read(flash->spi, &cmd[0], 1, &cmd[1], 1);\n\tmutex_unlock(&flash->lock);\n\tif (!ret)\n\t\t*status = cmd[1];\n\tdev_dbg(&flash->spi->dev, \"read status ret: %d status: %x\", ret, *status);\n\n\treturn ret;\n}\n\nstatic int mchp48l640_waitforbit(struct mchp48l640_flash *flash, int bit, bool set)\n{\n\tint ret, status;\n\tunsigned long deadline;\n\n\tdeadline = jiffies + msecs_to_jiffies(MCHP48L640_TIMEOUT);\n\tdo {\n\t\tret = mchp48l640_read_status(flash, &status);\n\t\tdev_dbg(&flash->spi->dev, \"read status ret: %d bit: %x %sset status: %x\",\n\t\t\tret, bit, (set ? \"\" : \"not\"), status);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (set) {\n\t\t\tif ((status & bit) == bit)\n\t\t\t\treturn 0;\n\t\t} else {\n\t\t\tif ((status & bit) == 0)\n\t\t\t\treturn 0;\n\t\t}\n\n\t\tusleep_range(1000, 2000);\n\t} while (!time_after_eq(jiffies, deadline));\n\n\tdev_err(&flash->spi->dev, \"Timeout waiting for bit %x %s set in status register.\",\n\t\tbit, (set ? \"\" : \"not\"));\n\treturn -ETIMEDOUT;\n}\n\nstatic int mchp48l640_write_prepare(struct mchp48l640_flash *flash, bool enable)\n{\n\tunsigned char cmd[2];\n\tint ret;\n\n\tif (enable)\n\t\tcmd[0] = MCHP48L640_CMD_WREN;\n\telse\n\t\tcmd[0] = MCHP48L640_CMD_WRDI;\n\n\tmutex_lock(&flash->lock);\n\tret = spi_write(flash->spi, cmd, 1);\n\tmutex_unlock(&flash->lock);\n\n\tif (ret)\n\t\tdev_err(&flash->spi->dev, \"write %sable failed ret: %d\",\n\t\t\t(enable ? \"en\" : \"dis\"), ret);\n\n\tdev_dbg(&flash->spi->dev, \"write %sable success ret: %d\",\n\t\t(enable ? \"en\" : \"dis\"), ret);\n\tif (enable)\n\t\treturn mchp48l640_waitforbit(flash, MCHP48L640_STATUS_WEL, true);\n\n\treturn ret;\n}\n\nstatic int mchp48l640_set_mode(struct mchp48l640_flash *flash)\n{\n\tunsigned char cmd[2];\n\tint ret;\n\n\tret = mchp48l640_write_prepare(flash, true);\n\tif (ret)\n\t\treturn ret;\n\n\tcmd[0] = MCHP48L640_CMD_WRSR;\n\tcmd[1] = MCHP48L640_STATUS_PRO;\n\n\tmutex_lock(&flash->lock);\n\tret = spi_write(flash->spi, cmd, 2);\n\tmutex_unlock(&flash->lock);\n\tif (ret)\n\t\tdev_err(&flash->spi->dev, \"Could not set continuous mode ret: %d\", ret);\n\n\treturn mchp48l640_waitforbit(flash, MCHP48L640_STATUS_PRO, true);\n}\n\nstatic int mchp48l640_wait_rdy(struct mchp48l640_flash *flash)\n{\n\treturn mchp48l640_waitforbit(flash, MCHP48L640_STATUS_RDY, false);\n};\n\nstatic int mchp48l640_write_page(struct mtd_info *mtd, loff_t to, size_t len,\n\t\t\t    size_t *retlen, const unsigned char *buf)\n{\n\tstruct mchp48l640_flash *flash = to_mchp48l640_flash(mtd);\n\tunsigned char *cmd;\n\tint ret;\n\tint cmdlen;\n\n\tcmd = kmalloc((3 + len), GFP_KERNEL | GFP_DMA);\n\tif (!cmd)\n\t\treturn -ENOMEM;\n\n\tret = mchp48l640_wait_rdy(flash);\n\tif (ret)\n\t\tgoto fail;\n\n\tret = mchp48l640_write_prepare(flash, true);\n\tif (ret)\n\t\tgoto fail;\n\n\tmutex_lock(&flash->lock);\n\tcmdlen = mchp48l640_mkcmd(flash, MCHP48L640_CMD_WRITE, to, cmd);\n\tmemcpy(&cmd[cmdlen], buf, len);\n\tret = spi_write(flash->spi, cmd, cmdlen + len);\n\tmutex_unlock(&flash->lock);\n\tif (!ret)\n\t\t*retlen += len;\n\telse\n\t\tgoto fail;\n\n\tret = mchp48l640_waitforbit(flash, MCHP48L640_STATUS_WEL, false);\n\tif (ret)\n\t\tgoto fail;\n\n\tkfree(cmd);\n\treturn 0;\nfail:\n\tkfree(cmd);\n\tdev_err(&flash->spi->dev, \"write fail with: %d\", ret);\n\treturn ret;\n};\n\nstatic int mchp48l640_write(struct mtd_info *mtd, loff_t to, size_t len,\n\t\t\t    size_t *retlen, const unsigned char *buf)\n{\n\tstruct mchp48l640_flash *flash = to_mchp48l640_flash(mtd);\n\tint ret;\n\tsize_t wlen = 0;\n\tloff_t woff = to;\n\tsize_t ws;\n\tsize_t page_sz = flash->caps->page_size;\n\n\t \n\twhile (wlen < len) {\n\t\tws = min((len - wlen), page_sz);\n\t\tret = mchp48l640_write_page(mtd, woff, ws, retlen, &buf[wlen]);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\twlen += ws;\n\t\twoff += ws;\n\t}\n\n\treturn 0;\n}\n\nstatic int mchp48l640_read_page(struct mtd_info *mtd, loff_t from, size_t len,\n\t\t\t   size_t *retlen, unsigned char *buf)\n{\n\tstruct mchp48l640_flash *flash = to_mchp48l640_flash(mtd);\n\tunsigned char *cmd;\n\tint ret;\n\tint cmdlen;\n\n\tcmd = kmalloc((3 + len), GFP_KERNEL | GFP_DMA);\n\tif (!cmd)\n\t\treturn -ENOMEM;\n\n\tret = mchp48l640_wait_rdy(flash);\n\tif (ret)\n\t\tgoto fail;\n\n\tmutex_lock(&flash->lock);\n\tcmdlen = mchp48l640_mkcmd(flash, MCHP48L640_CMD_READ, from, cmd);\n\tret = spi_write_then_read(flash->spi, cmd, cmdlen, buf, len);\n\tmutex_unlock(&flash->lock);\n\tif (!ret)\n\t\t*retlen += len;\n\n\tkfree(cmd);\n\treturn ret;\n\nfail:\n\tkfree(cmd);\n\tdev_err(&flash->spi->dev, \"read fail with: %d\", ret);\n\treturn ret;\n}\n\nstatic int mchp48l640_read(struct mtd_info *mtd, loff_t from, size_t len,\n\t\t\t   size_t *retlen, unsigned char *buf)\n{\n\tstruct mchp48l640_flash *flash = to_mchp48l640_flash(mtd);\n\tint ret;\n\tsize_t wlen = 0;\n\tloff_t woff = from;\n\tsize_t ws;\n\tsize_t page_sz = flash->caps->page_size;\n\n\t \n\twhile (wlen < len) {\n\t\tws = min((len - wlen), page_sz);\n\t\tret = mchp48l640_read_page(mtd, woff, ws, retlen, &buf[wlen]);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\twlen += ws;\n\t\twoff += ws;\n\t}\n\n\treturn 0;\n};\n\nstatic const struct mchp48_caps mchp48l640_caps = {\n\t.size = SZ_8K,\n\t.page_size = 32,\n};\n\nstatic int mchp48l640_probe(struct spi_device *spi)\n{\n\tstruct mchp48l640_flash *flash;\n\tstruct flash_platform_data *data;\n\tint err;\n\tint status;\n\n\tflash = devm_kzalloc(&spi->dev, sizeof(*flash), GFP_KERNEL);\n\tif (!flash)\n\t\treturn -ENOMEM;\n\n\tflash->spi = spi;\n\tmutex_init(&flash->lock);\n\tspi_set_drvdata(spi, flash);\n\n\terr = mchp48l640_read_status(flash, &status);\n\tif (err)\n\t\treturn err;\n\n\terr = mchp48l640_set_mode(flash);\n\tif (err)\n\t\treturn err;\n\n\tdata = dev_get_platdata(&spi->dev);\n\n\tflash->caps = of_device_get_match_data(&spi->dev);\n\tif (!flash->caps)\n\t\tflash->caps = &mchp48l640_caps;\n\n\tmtd_set_of_node(&flash->mtd, spi->dev.of_node);\n\tflash->mtd.dev.parent\t= &spi->dev;\n\tflash->mtd.type\t\t= MTD_RAM;\n\tflash->mtd.flags\t= MTD_CAP_RAM;\n\tflash->mtd.writesize\t= flash->caps->page_size;\n\tflash->mtd.size\t\t= flash->caps->size;\n\tflash->mtd._read\t= mchp48l640_read;\n\tflash->mtd._write\t= mchp48l640_write;\n\n\terr = mtd_device_register(&flash->mtd, data ? data->parts : NULL,\n\t\t\t\t  data ? data->nr_parts : 0);\n\tif (err)\n\t\treturn err;\n\n\treturn 0;\n}\n\nstatic void mchp48l640_remove(struct spi_device *spi)\n{\n\tstruct mchp48l640_flash *flash = spi_get_drvdata(spi);\n\n\tWARN_ON(mtd_device_unregister(&flash->mtd));\n}\n\nstatic const struct of_device_id mchp48l640_of_table[] = {\n\t{\n\t\t.compatible = \"microchip,48l640\",\n\t\t.data = &mchp48l640_caps,\n\t},\n\t{}\n};\nMODULE_DEVICE_TABLE(of, mchp48l640_of_table);\n\nstatic const struct spi_device_id mchp48l640_spi_ids[] = {\n\t{\n\t\t.name = \"48l640\",\n\t\t.driver_data = (kernel_ulong_t)&mchp48l640_caps,\n\t},\n\t{}\n};\nMODULE_DEVICE_TABLE(spi, mchp48l640_spi_ids);\n\nstatic struct spi_driver mchp48l640_driver = {\n\t.driver = {\n\t\t.name\t= \"mchp48l640\",\n\t\t.of_match_table = mchp48l640_of_table,\n\t},\n\t.probe\t\t= mchp48l640_probe,\n\t.remove\t\t= mchp48l640_remove,\n\t.id_table\t= mchp48l640_spi_ids,\n};\n\nmodule_spi_driver(mchp48l640_driver);\n\nMODULE_DESCRIPTION(\"MTD SPI driver for Microchip 48l640 EERAM chips\");\nMODULE_AUTHOR(\"Heiko Schocher <hs@denx.de>\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"spi:mchp48l640\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}