{
  "module_name": "pmc551.c",
  "hash_id": "7612ded86d4cf5a8389354b22a0e160eeb150e152bbb7a8392f173540f9713a9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/devices/pmc551.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/ptrace.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/timer.h>\n#include <linux/major.h>\n#include <linux/fs.h>\n#include <linux/ioctl.h>\n#include <asm/io.h>\n#include <linux/pci.h>\n#include <linux/mtd/mtd.h>\n\n#define PMC551_VERSION \\\n\t\"Ramix PMC551 PCI Mezzanine Ram Driver. (C) 1999,2000 Nortel Networks.\\n\"\n\n#define PCI_VENDOR_ID_V3_SEMI 0x11b0\n#define PCI_DEVICE_ID_V3_SEMI_V370PDC 0x0200\n\n#define PMC551_PCI_MEM_MAP0 0x50\n#define PMC551_PCI_MEM_MAP1 0x54\n#define PMC551_PCI_MEM_MAP_MAP_ADDR_MASK 0x3ff00000\n#define PMC551_PCI_MEM_MAP_APERTURE_MASK 0x000000f0\n#define PMC551_PCI_MEM_MAP_REG_EN 0x00000002\n#define PMC551_PCI_MEM_MAP_ENABLE 0x00000001\n\n#define PMC551_SDRAM_MA  0x60\n#define PMC551_SDRAM_CMD 0x62\n#define PMC551_DRAM_CFG  0x64\n#define PMC551_SYS_CTRL_REG 0x78\n\n#define PMC551_DRAM_BLK0 0x68\n#define PMC551_DRAM_BLK1 0x6c\n#define PMC551_DRAM_BLK2 0x70\n#define PMC551_DRAM_BLK3 0x74\n#define PMC551_DRAM_BLK_GET_SIZE(x) (524288 << ((x >> 4) & 0x0f))\n#define PMC551_DRAM_BLK_SET_COL_MUX(x, v) (((x) & ~0x00007000) | (((v) & 0x7) << 12))\n#define PMC551_DRAM_BLK_SET_ROW_MUX(x, v) (((x) & ~0x00000f00) | (((v) & 0xf) << 8))\n\nstruct mypriv {\n\tstruct pci_dev *dev;\n\tu_char *start;\n\tu32 base_map0;\n\tu32 curr_map0;\n\tu32 asize;\n\tstruct mtd_info *nextpmc551;\n};\n\nstatic struct mtd_info *pmc551list;\n\nstatic int pmc551_point(struct mtd_info *mtd, loff_t from, size_t len,\n\t\t\tsize_t *retlen, void **virt, resource_size_t *phys);\n\nstatic int pmc551_erase(struct mtd_info *mtd, struct erase_info *instr)\n{\n\tstruct mypriv *priv = mtd->priv;\n\tu32 soff_hi;\t\t \n\tu32 eoff_hi, eoff_lo;\t \n\tunsigned long end;\n\tu_char *ptr;\n\tsize_t retlen;\n\n#ifdef CONFIG_MTD_PMC551_DEBUG\n\tprintk(KERN_DEBUG \"pmc551_erase(pos:%ld, len:%ld)\\n\", (long)instr->addr,\n\t\t(long)instr->len);\n#endif\n\n\tend = instr->addr + instr->len - 1;\n\teoff_hi = end & ~(priv->asize - 1);\n\tsoff_hi = instr->addr & ~(priv->asize - 1);\n\teoff_lo = end & (priv->asize - 1);\n\n\tpmc551_point(mtd, instr->addr, instr->len, &retlen,\n\t\t     (void **)&ptr, NULL);\n\n\tif (soff_hi == eoff_hi || mtd->size == priv->asize) {\n\t\t \n\t\tmemset(ptr, 0xff, instr->len);\n\t} else {\n\t\t \n\t\twhile (soff_hi != eoff_hi) {\n#ifdef CONFIG_MTD_PMC551_DEBUG\n\t\t\tprintk(KERN_DEBUG \"pmc551_erase() soff_hi: %ld, \"\n\t\t\t\t\"eoff_hi: %ld\\n\", (long)soff_hi, (long)eoff_hi);\n#endif\n\t\t\tmemset(ptr, 0xff, priv->asize);\n\t\t\tif (soff_hi + priv->asize >= mtd->size) {\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tsoff_hi += priv->asize;\n\t\t\tpmc551_point(mtd, (priv->base_map0 | soff_hi),\n\t\t\t\t     priv->asize, &retlen,\n\t\t\t\t     (void **)&ptr, NULL);\n\t\t}\n\t\tmemset(ptr, 0xff, eoff_lo);\n\t}\n\n      out:\n#ifdef CONFIG_MTD_PMC551_DEBUG\n\tprintk(KERN_DEBUG \"pmc551_erase() done\\n\");\n#endif\n\n\treturn 0;\n}\n\nstatic int pmc551_point(struct mtd_info *mtd, loff_t from, size_t len,\n\t\t\tsize_t *retlen, void **virt, resource_size_t *phys)\n{\n\tstruct mypriv *priv = mtd->priv;\n\tu32 soff_hi;\n\tu32 soff_lo;\n\n#ifdef CONFIG_MTD_PMC551_DEBUG\n\tprintk(KERN_DEBUG \"pmc551_point(%ld, %ld)\\n\", (long)from, (long)len);\n#endif\n\n\tsoff_hi = from & ~(priv->asize - 1);\n\tsoff_lo = from & (priv->asize - 1);\n\n\t \n\tif (priv->curr_map0 != from) {\n\t\tpci_write_config_dword(priv->dev, PMC551_PCI_MEM_MAP0,\n\t\t\t\t\t(priv->base_map0 | soff_hi));\n\t\tpriv->curr_map0 = soff_hi;\n\t}\n\n\t*virt = priv->start + soff_lo;\n\t*retlen = len;\n\treturn 0;\n}\n\nstatic int pmc551_unpoint(struct mtd_info *mtd, loff_t from, size_t len)\n{\n#ifdef CONFIG_MTD_PMC551_DEBUG\n\tprintk(KERN_DEBUG \"pmc551_unpoint()\\n\");\n#endif\n\treturn 0;\n}\n\nstatic int pmc551_read(struct mtd_info *mtd, loff_t from, size_t len,\n\t\t\tsize_t * retlen, u_char * buf)\n{\n\tstruct mypriv *priv = mtd->priv;\n\tu32 soff_hi;\t\t \n\tu32 eoff_hi, eoff_lo;\t \n\tunsigned long end;\n\tu_char *ptr;\n\tu_char *copyto = buf;\n\n#ifdef CONFIG_MTD_PMC551_DEBUG\n\tprintk(KERN_DEBUG \"pmc551_read(pos:%ld, len:%ld) asize: %ld\\n\",\n\t\t(long)from, (long)len, (long)priv->asize);\n#endif\n\n\tend = from + len - 1;\n\tsoff_hi = from & ~(priv->asize - 1);\n\teoff_hi = end & ~(priv->asize - 1);\n\teoff_lo = end & (priv->asize - 1);\n\n\tpmc551_point(mtd, from, len, retlen, (void **)&ptr, NULL);\n\n\tif (soff_hi == eoff_hi) {\n\t\t \n\t\tmemcpy(copyto, ptr, len);\n\t\tcopyto += len;\n\t} else {\n\t\t \n\t\twhile (soff_hi != eoff_hi) {\n#ifdef CONFIG_MTD_PMC551_DEBUG\n\t\t\tprintk(KERN_DEBUG \"pmc551_read() soff_hi: %ld, \"\n\t\t\t\t\"eoff_hi: %ld\\n\", (long)soff_hi, (long)eoff_hi);\n#endif\n\t\t\tmemcpy(copyto, ptr, priv->asize);\n\t\t\tcopyto += priv->asize;\n\t\t\tif (soff_hi + priv->asize >= mtd->size) {\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tsoff_hi += priv->asize;\n\t\t\tpmc551_point(mtd, soff_hi, priv->asize, retlen,\n\t\t\t\t     (void **)&ptr, NULL);\n\t\t}\n\t\tmemcpy(copyto, ptr, eoff_lo);\n\t\tcopyto += eoff_lo;\n\t}\n\n      out:\n#ifdef CONFIG_MTD_PMC551_DEBUG\n\tprintk(KERN_DEBUG \"pmc551_read() done\\n\");\n#endif\n\t*retlen = copyto - buf;\n\treturn 0;\n}\n\nstatic int pmc551_write(struct mtd_info *mtd, loff_t to, size_t len,\n\t\t\tsize_t * retlen, const u_char * buf)\n{\n\tstruct mypriv *priv = mtd->priv;\n\tu32 soff_hi;\t\t \n\tu32 eoff_hi, eoff_lo;\t \n\tunsigned long end;\n\tu_char *ptr;\n\tconst u_char *copyfrom = buf;\n\n#ifdef CONFIG_MTD_PMC551_DEBUG\n\tprintk(KERN_DEBUG \"pmc551_write(pos:%ld, len:%ld) asize:%ld\\n\",\n\t\t(long)to, (long)len, (long)priv->asize);\n#endif\n\n\tend = to + len - 1;\n\tsoff_hi = to & ~(priv->asize - 1);\n\teoff_hi = end & ~(priv->asize - 1);\n\teoff_lo = end & (priv->asize - 1);\n\n\tpmc551_point(mtd, to, len, retlen, (void **)&ptr, NULL);\n\n\tif (soff_hi == eoff_hi) {\n\t\t \n\t\tmemcpy(ptr, copyfrom, len);\n\t\tcopyfrom += len;\n\t} else {\n\t\t \n\t\twhile (soff_hi != eoff_hi) {\n#ifdef CONFIG_MTD_PMC551_DEBUG\n\t\t\tprintk(KERN_DEBUG \"pmc551_write() soff_hi: %ld, \"\n\t\t\t\t\"eoff_hi: %ld\\n\", (long)soff_hi, (long)eoff_hi);\n#endif\n\t\t\tmemcpy(ptr, copyfrom, priv->asize);\n\t\t\tcopyfrom += priv->asize;\n\t\t\tif (soff_hi >= mtd->size) {\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tsoff_hi += priv->asize;\n\t\t\tpmc551_point(mtd, soff_hi, priv->asize, retlen,\n\t\t\t\t     (void **)&ptr, NULL);\n\t\t}\n\t\tmemcpy(ptr, copyfrom, eoff_lo);\n\t\tcopyfrom += eoff_lo;\n\t}\n\n      out:\n#ifdef CONFIG_MTD_PMC551_DEBUG\n\tprintk(KERN_DEBUG \"pmc551_write() done\\n\");\n#endif\n\t*retlen = copyfrom - buf;\n\treturn 0;\n}\n\n \nstatic int __init fixup_pmc551(struct pci_dev *dev)\n{\n#ifdef CONFIG_MTD_PMC551_BUGFIX\n\tu32 dram_data;\n#endif\n\tu32 size, dcmd, cfg, dtmp;\n\tu16 cmd, tmp, i;\n\tu8 bcmd, counter;\n\n\t \n\tif (!dev) {\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tcounter = 0;\n\t \n\tpci_write_config_byte(dev, PMC551_SYS_CTRL_REG, 0xA5);\n\t \n\tpci_read_config_byte(dev, PMC551_SYS_CTRL_REG, &bcmd);\n\t \n\tfor (i = 0; i < 10; i++) {\n\t\tcounter = 0;\n\t\tbcmd &= ~0x80;\n\t\twhile (counter++ < 100) {\n\t\t\tpci_write_config_byte(dev, PMC551_SYS_CTRL_REG, bcmd);\n\t\t}\n\t\tcounter = 0;\n\t\tbcmd |= 0x80;\n\t\twhile (counter++ < 100) {\n\t\t\tpci_write_config_byte(dev, PMC551_SYS_CTRL_REG, bcmd);\n\t\t}\n\t}\n\tbcmd |= (0x40 | 0x20);\n\tpci_write_config_byte(dev, PMC551_SYS_CTRL_REG, bcmd);\n\n\t \n\tpci_read_config_word(dev, PCI_COMMAND, &cmd);\n\ttmp = cmd & ~(PCI_COMMAND_IO | PCI_COMMAND_MEMORY);\n\tpci_write_config_word(dev, PCI_COMMAND, tmp);\n\n\t \n\tpci_read_config_dword(dev, PMC551_PCI_MEM_MAP0, &dcmd);\n\tdtmp = (dcmd | PMC551_PCI_MEM_MAP_ENABLE | PMC551_PCI_MEM_MAP_REG_EN);\n\tpci_write_config_dword(dev, PMC551_PCI_MEM_MAP0, dtmp);\n\t \n\tpci_read_config_dword(dev, PCI_BASE_ADDRESS_0, &cfg);\n#ifndef CONFIG_MTD_PMC551_BUGFIX\n\tpci_write_config_dword(dev, PCI_BASE_ADDRESS_0, ~0);\n\tpci_read_config_dword(dev, PCI_BASE_ADDRESS_0, &size);\n\tsize = (size & PCI_BASE_ADDRESS_MEM_MASK);\n\tsize &= ~(size - 1);\n\tpci_write_config_dword(dev, PCI_BASE_ADDRESS_0, cfg);\n#else\n\t \n\tpci_read_config_dword(dev, PMC551_DRAM_BLK0, &dram_data);\n\tsize = PMC551_DRAM_BLK_GET_SIZE(dram_data);\n\tdram_data = PMC551_DRAM_BLK_SET_COL_MUX(dram_data, 0x5);\n\tdram_data = PMC551_DRAM_BLK_SET_ROW_MUX(dram_data, 0x9);\n\tpci_write_config_dword(dev, PMC551_DRAM_BLK0, dram_data);\n\n\tpci_read_config_dword(dev, PMC551_DRAM_BLK1, &dram_data);\n\tsize += PMC551_DRAM_BLK_GET_SIZE(dram_data);\n\tdram_data = PMC551_DRAM_BLK_SET_COL_MUX(dram_data, 0x5);\n\tdram_data = PMC551_DRAM_BLK_SET_ROW_MUX(dram_data, 0x9);\n\tpci_write_config_dword(dev, PMC551_DRAM_BLK1, dram_data);\n\n\tpci_read_config_dword(dev, PMC551_DRAM_BLK2, &dram_data);\n\tsize += PMC551_DRAM_BLK_GET_SIZE(dram_data);\n\tdram_data = PMC551_DRAM_BLK_SET_COL_MUX(dram_data, 0x5);\n\tdram_data = PMC551_DRAM_BLK_SET_ROW_MUX(dram_data, 0x9);\n\tpci_write_config_dword(dev, PMC551_DRAM_BLK2, dram_data);\n\n\tpci_read_config_dword(dev, PMC551_DRAM_BLK3, &dram_data);\n\tsize += PMC551_DRAM_BLK_GET_SIZE(dram_data);\n\tdram_data = PMC551_DRAM_BLK_SET_COL_MUX(dram_data, 0x5);\n\tdram_data = PMC551_DRAM_BLK_SET_ROW_MUX(dram_data, 0x9);\n\tpci_write_config_dword(dev, PMC551_DRAM_BLK3, dram_data);\n\n\t \n\tif ((size &= PCI_BASE_ADDRESS_MEM_MASK) == 0) {\n\t\treturn -ENODEV;\n\t}\n#endif\t\t\t\t \n\n\tif ((cfg & PCI_BASE_ADDRESS_SPACE) != PCI_BASE_ADDRESS_SPACE_MEMORY) {\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tpci_write_config_word(dev, PMC551_SDRAM_MA, 0x0400);\n\tpci_write_config_word(dev, PMC551_SDRAM_CMD, 0x00bf);\n\n\t \n\tdo {\n\t\tpci_read_config_word(dev, PMC551_SDRAM_CMD, &cmd);\n\t\tif (counter++ > 100)\n\t\t\tbreak;\n\t} while ((PCI_COMMAND_IO) & cmd);\n\n\t \n\tfor (i = 1; i <= 8; i++) {\n\t\tpci_write_config_word(dev, PMC551_SDRAM_CMD, 0x0df);\n\n\t\t \n\t\tcounter = 0;\n\t\tdo {\n\t\t\tpci_read_config_word(dev, PMC551_SDRAM_CMD, &cmd);\n\t\t\tif (counter++ > 100)\n\t\t\t\tbreak;\n\t\t} while ((PCI_COMMAND_IO) & cmd);\n\t}\n\n\tpci_write_config_word(dev, PMC551_SDRAM_MA, 0x0020);\n\tpci_write_config_word(dev, PMC551_SDRAM_CMD, 0x0ff);\n\n\t \n\tcounter = 0;\n\tdo {\n\t\tpci_read_config_word(dev, PMC551_SDRAM_CMD, &cmd);\n\t\tif (counter++ > 100)\n\t\t\tbreak;\n\t} while ((PCI_COMMAND_IO) & cmd);\n\n\tpci_read_config_dword(dev, PMC551_DRAM_CFG, &dcmd);\n\tdcmd |= 0x02000000;\n\tpci_write_config_dword(dev, PMC551_DRAM_CFG, dcmd);\n\n\t \n\tpci_read_config_word(dev, PCI_STATUS, &cmd);\n\tif ((cmd & PCI_COMMAND_FAST_BACK) == 0) {\n\t\tcmd |= PCI_COMMAND_FAST_BACK;\n\t\tpci_write_config_word(dev, PCI_STATUS, cmd);\n\t}\n\n\t \n\tif ((cmd & PCI_STATUS_DEVSEL_MASK) != 0x0) {\n\t\tcmd &= ~PCI_STATUS_DEVSEL_MASK;\n\t\tpci_write_config_word(dev, PCI_STATUS, cmd);\n\t}\n\t \n\t \n\n\t \n\tpci_write_config_word(dev, PCI_COMMAND,\n\t\t\t      PCI_COMMAND_MEMORY | PCI_COMMAND_IO);\n#ifdef CONFIG_MTD_PMC551_DEBUG\n\t \n\tprintk(KERN_DEBUG \"pmc551: %d%sB (0x%x) of %sprefetchable memory at \"\n\t\t\"0x%llx\\n\", (size < 1024) ? size : (size < 1048576) ?\n\t\tsize >> 10 : size >> 20,\n\t\t(size < 1024) ? \"\" : (size < 1048576) ? \"Ki\" : \"Mi\", size,\n\t\t((dcmd & (0x1 << 3)) == 0) ? \"non-\" : \"\",\n\t\t(unsigned long long)pci_resource_start(dev, 0));\n\n\t \n\tpci_read_config_dword(dev, PMC551_DRAM_BLK0, &dcmd);\n\tprintk(KERN_DEBUG \"pmc551: DRAM_BLK0 Flags: %s,%s\\n\"\n\t\t\"pmc551: DRAM_BLK0 Size: %d at %d\\n\"\n\t\t\"pmc551: DRAM_BLK0 Row MUX: %d, Col MUX: %d\\n\",\n\t\t(((0x1 << 1) & dcmd) == 0) ? \"RW\" : \"RO\",\n\t\t(((0x1 << 0) & dcmd) == 0) ? \"Off\" : \"On\",\n\t\tPMC551_DRAM_BLK_GET_SIZE(dcmd),\n\t\t((dcmd >> 20) & 0x7FF), ((dcmd >> 13) & 0x7),\n\t\t((dcmd >> 9) & 0xF));\n\n\tpci_read_config_dword(dev, PMC551_DRAM_BLK1, &dcmd);\n\tprintk(KERN_DEBUG \"pmc551: DRAM_BLK1 Flags: %s,%s\\n\"\n\t\t\"pmc551: DRAM_BLK1 Size: %d at %d\\n\"\n\t\t\"pmc551: DRAM_BLK1 Row MUX: %d, Col MUX: %d\\n\",\n\t\t(((0x1 << 1) & dcmd) == 0) ? \"RW\" : \"RO\",\n\t\t(((0x1 << 0) & dcmd) == 0) ? \"Off\" : \"On\",\n\t\tPMC551_DRAM_BLK_GET_SIZE(dcmd),\n\t\t((dcmd >> 20) & 0x7FF), ((dcmd >> 13) & 0x7),\n\t\t((dcmd >> 9) & 0xF));\n\n\tpci_read_config_dword(dev, PMC551_DRAM_BLK2, &dcmd);\n\tprintk(KERN_DEBUG \"pmc551: DRAM_BLK2 Flags: %s,%s\\n\"\n\t\t\"pmc551: DRAM_BLK2 Size: %d at %d\\n\"\n\t\t\"pmc551: DRAM_BLK2 Row MUX: %d, Col MUX: %d\\n\",\n\t\t(((0x1 << 1) & dcmd) == 0) ? \"RW\" : \"RO\",\n\t\t(((0x1 << 0) & dcmd) == 0) ? \"Off\" : \"On\",\n\t\tPMC551_DRAM_BLK_GET_SIZE(dcmd),\n\t\t((dcmd >> 20) & 0x7FF), ((dcmd >> 13) & 0x7),\n\t\t((dcmd >> 9) & 0xF));\n\n\tpci_read_config_dword(dev, PMC551_DRAM_BLK3, &dcmd);\n\tprintk(KERN_DEBUG \"pmc551: DRAM_BLK3 Flags: %s,%s\\n\"\n\t\t\"pmc551: DRAM_BLK3 Size: %d at %d\\n\"\n\t\t\"pmc551: DRAM_BLK3 Row MUX: %d, Col MUX: %d\\n\",\n\t\t(((0x1 << 1) & dcmd) == 0) ? \"RW\" : \"RO\",\n\t\t(((0x1 << 0) & dcmd) == 0) ? \"Off\" : \"On\",\n\t\tPMC551_DRAM_BLK_GET_SIZE(dcmd),\n\t\t((dcmd >> 20) & 0x7FF), ((dcmd >> 13) & 0x7),\n\t\t((dcmd >> 9) & 0xF));\n\n\tpci_read_config_word(dev, PCI_COMMAND, &cmd);\n\tprintk(KERN_DEBUG \"pmc551: Memory Access %s\\n\",\n\t\t(((0x1 << 1) & cmd) == 0) ? \"off\" : \"on\");\n\tprintk(KERN_DEBUG \"pmc551: I/O Access %s\\n\",\n\t\t(((0x1 << 0) & cmd) == 0) ? \"off\" : \"on\");\n\n\tpci_read_config_word(dev, PCI_STATUS, &cmd);\n\tprintk(KERN_DEBUG \"pmc551: Devsel %s\\n\",\n\t\t((PCI_STATUS_DEVSEL_MASK & cmd) == 0x000) ? \"Fast\" :\n\t\t((PCI_STATUS_DEVSEL_MASK & cmd) == 0x200) ? \"Medium\" :\n\t\t((PCI_STATUS_DEVSEL_MASK & cmd) == 0x400) ? \"Slow\" : \"Invalid\");\n\n\tprintk(KERN_DEBUG \"pmc551: %sFast Back-to-Back\\n\",\n\t\t((PCI_COMMAND_FAST_BACK & cmd) == 0) ? \"Not \" : \"\");\n\n\tpci_read_config_byte(dev, PMC551_SYS_CTRL_REG, &bcmd);\n\tprintk(KERN_DEBUG \"pmc551: EEPROM is under %s control\\n\"\n\t\t\"pmc551: System Control Register is %slocked to PCI access\\n\"\n\t\t\"pmc551: System Control Register is %slocked to EEPROM access\\n\",\n\t\t(bcmd & 0x1) ? \"software\" : \"hardware\",\n\t\t(bcmd & 0x20) ? \"\" : \"un\", (bcmd & 0x40) ? \"\" : \"un\");\n#endif\n\treturn size;\n}\n\n \n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Mark Ferrell <mferrell@mvista.com>\");\nMODULE_DESCRIPTION(PMC551_VERSION);\n\n \nstatic int msize = 0;\nstatic int asize = 0;\n\nmodule_param(msize, int, 0);\nMODULE_PARM_DESC(msize, \"memory size in MiB [1 - 1024]\");\nmodule_param(asize, int, 0);\nMODULE_PARM_DESC(asize, \"aperture size, must be <= memsize [1-1024]\");\n\n \nstatic int __init init_pmc551(void)\n{\n\tstruct pci_dev *PCI_Device = NULL;\n\tstruct mypriv *priv;\n\tint found = 0;\n\tstruct mtd_info *mtd;\n\tint length = 0;\n\n\tif (msize) {\n\t\tmsize = (1 << (ffs(msize) - 1)) << 20;\n\t\tif (msize > (1 << 30)) {\n\t\t\tprintk(KERN_NOTICE \"pmc551: Invalid memory size [%d]\\n\",\n\t\t\t\tmsize);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (asize) {\n\t\tasize = (1 << (ffs(asize) - 1)) << 20;\n\t\tif (asize > (1 << 30)) {\n\t\t\tprintk(KERN_NOTICE \"pmc551: Invalid aperture size \"\n\t\t\t\t\"[%d]\\n\", asize);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tprintk(KERN_INFO PMC551_VERSION);\n\n\t \n\tfor (;;) {\n\n\t\tif ((PCI_Device = pci_get_device(PCI_VENDOR_ID_V3_SEMI,\n\t\t\t\t\t\t  PCI_DEVICE_ID_V3_SEMI_V370PDC,\n\t\t\t\t\t\t  PCI_Device)) == NULL) {\n\t\t\tbreak;\n\t\t}\n\n\t\tprintk(KERN_NOTICE \"pmc551: Found PCI V370PDC at 0x%llx\\n\",\n\t\t\t(unsigned long long)pci_resource_start(PCI_Device, 0));\n\n\t\t \n\t\tif ((length = fixup_pmc551(PCI_Device)) <= 0) {\n\t\t\tprintk(KERN_NOTICE \"pmc551: Cannot init SDRAM\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (msize) {\n\t\t\tlength = msize;\n\t\t\tprintk(KERN_NOTICE \"pmc551: Using specified memory \"\n\t\t\t\t\"size 0x%x\\n\", length);\n\t\t} else {\n\t\t\tmsize = length;\n\t\t}\n\n\t\tmtd = kzalloc(sizeof(struct mtd_info), GFP_KERNEL);\n\t\tif (!mtd)\n\t\t\tbreak;\n\n\t\tpriv = kzalloc(sizeof(struct mypriv), GFP_KERNEL);\n\t\tif (!priv) {\n\t\t\tkfree(mtd);\n\t\t\tbreak;\n\t\t}\n\t\tmtd->priv = priv;\n\t\tpriv->dev = PCI_Device;\n\n\t\tif (asize > length) {\n\t\t\tprintk(KERN_NOTICE \"pmc551: reducing aperture size to \"\n\t\t\t\t\"fit %dM\\n\", length >> 20);\n\t\t\tpriv->asize = asize = length;\n\t\t} else if (asize == 0 || asize == length) {\n\t\t\tprintk(KERN_NOTICE \"pmc551: Using existing aperture \"\n\t\t\t\t\"size %dM\\n\", length >> 20);\n\t\t\tpriv->asize = asize = length;\n\t\t} else {\n\t\t\tprintk(KERN_NOTICE \"pmc551: Using specified aperture \"\n\t\t\t\t\"size %dM\\n\", asize >> 20);\n\t\t\tpriv->asize = asize;\n\t\t}\n\t\tpriv->start = pci_iomap(PCI_Device, 0, priv->asize);\n\n\t\tif (!priv->start) {\n\t\t\tprintk(KERN_NOTICE \"pmc551: Unable to map IO space\\n\");\n\t\t\tkfree(mtd->priv);\n\t\t\tkfree(mtd);\n\t\t\tbreak;\n\t\t}\n#ifdef CONFIG_MTD_PMC551_DEBUG\n\t\tprintk(KERN_DEBUG \"pmc551: setting aperture to %d\\n\",\n\t\t\tffs(priv->asize >> 20) - 1);\n#endif\n\n\t\tpriv->base_map0 = (PMC551_PCI_MEM_MAP_REG_EN\n\t\t\t\t   | PMC551_PCI_MEM_MAP_ENABLE\n\t\t\t\t   | (ffs(priv->asize >> 20) - 1) << 4);\n\t\tpriv->curr_map0 = priv->base_map0;\n\t\tpci_write_config_dword(priv->dev, PMC551_PCI_MEM_MAP0,\n\t\t\t\t\tpriv->curr_map0);\n\n#ifdef CONFIG_MTD_PMC551_DEBUG\n\t\tprintk(KERN_DEBUG \"pmc551: aperture set to %d\\n\",\n\t\t\t(priv->base_map0 & 0xF0) >> 4);\n#endif\n\n\t\tmtd->size = msize;\n\t\tmtd->flags = MTD_CAP_RAM;\n\t\tmtd->_erase = pmc551_erase;\n\t\tmtd->_read = pmc551_read;\n\t\tmtd->_write = pmc551_write;\n\t\tmtd->_point = pmc551_point;\n\t\tmtd->_unpoint = pmc551_unpoint;\n\t\tmtd->type = MTD_RAM;\n\t\tmtd->name = \"PMC551 RAM board\";\n\t\tmtd->erasesize = 0x10000;\n\t\tmtd->writesize = 1;\n\t\tmtd->owner = THIS_MODULE;\n\n\t\tif (mtd_device_register(mtd, NULL, 0)) {\n\t\t\tprintk(KERN_NOTICE \"pmc551: Failed to register new device\\n\");\n\t\t\tpci_iounmap(PCI_Device, priv->start);\n\t\t\tkfree(mtd->priv);\n\t\t\tkfree(mtd);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tpci_dev_get(PCI_Device);\n\n\t\tprintk(KERN_NOTICE \"Registered pmc551 memory device.\\n\");\n\t\tprintk(KERN_NOTICE \"Mapped %dMiB of memory from 0x%p to 0x%p\\n\",\n\t\t\tpriv->asize >> 20,\n\t\t\tpriv->start, priv->start + priv->asize);\n\t\tprintk(KERN_NOTICE \"Total memory is %d%sB\\n\",\n\t\t\t(length < 1024) ? length :\n\t\t\t(length < 1048576) ? length >> 10 : length >> 20,\n\t\t\t(length < 1024) ? \"\" : (length < 1048576) ? \"Ki\" : \"Mi\");\n\t\tpriv->nextpmc551 = pmc551list;\n\t\tpmc551list = mtd;\n\t\tfound++;\n\t}\n\n\t \n\tpci_dev_put(PCI_Device);\n\n\tif (!pmc551list) {\n\t\tprintk(KERN_NOTICE \"pmc551: not detected\\n\");\n\t\treturn -ENODEV;\n\t} else {\n\t\tprintk(KERN_NOTICE \"pmc551: %d pmc551 devices loaded\\n\", found);\n\t\treturn 0;\n\t}\n}\n\n \nstatic void __exit cleanup_pmc551(void)\n{\n\tint found = 0;\n\tstruct mtd_info *mtd;\n\tstruct mypriv *priv;\n\n\twhile ((mtd = pmc551list)) {\n\t\tpriv = mtd->priv;\n\t\tpmc551list = priv->nextpmc551;\n\n\t\tif (priv->start) {\n\t\t\tprintk(KERN_DEBUG \"pmc551: unmapping %dMiB starting at \"\n\t\t\t\t\"0x%p\\n\", priv->asize >> 20, priv->start);\n\t\t\tpci_iounmap(priv->dev, priv->start);\n\t\t}\n\t\tpci_dev_put(priv->dev);\n\n\t\tkfree(mtd->priv);\n\t\tmtd_device_unregister(mtd);\n\t\tkfree(mtd);\n\t\tfound++;\n\t}\n\n\tprintk(KERN_NOTICE \"pmc551: %d pmc551 devices unloaded\\n\", found);\n}\n\nmodule_init(init_pmc551);\nmodule_exit(cleanup_pmc551);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}