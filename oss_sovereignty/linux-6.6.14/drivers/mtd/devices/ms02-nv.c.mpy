{
  "module_name": "ms02-nv.c",
  "hash_id": "cf95fd55e3f30c23d9a05c244cc6a95eecebf8020abc8f958561b6d0f3fc5e11",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/devices/ms02-nv.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/mtd/mtd.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#include <asm/addrspace.h>\n#include <asm/bootinfo.h>\n#include <asm/dec/ioasic_addrs.h>\n#include <asm/dec/kn02.h>\n#include <asm/dec/kn03.h>\n#include <asm/io.h>\n#include <asm/paccess.h>\n\n#include \"ms02-nv.h\"\n\n\nstatic char version[] __initdata =\n\t\"ms02-nv.c: v.1.0.0  13 Aug 2001  Maciej W. Rozycki.\\n\";\n\nMODULE_AUTHOR(\"Maciej W. Rozycki <macro@linux-mips.org>\");\nMODULE_DESCRIPTION(\"DEC MS02-NV NVRAM module driver\");\nMODULE_LICENSE(\"GPL\");\n\n\n \nstatic ulong ms02nv_addrs[] __initdata = {\n\t0x07000000, 0x06800000, 0x06000000, 0x05800000, 0x05000000,\n\t0x04800000, 0x04000000, 0x03800000, 0x03000000, 0x02800000,\n\t0x02000000, 0x01800000, 0x01000000, 0x00800000\n};\n\nstatic const char ms02nv_name[] = \"DEC MS02-NV NVRAM\";\nstatic const char ms02nv_res_diag_ram[] = \"Diagnostic RAM\";\nstatic const char ms02nv_res_user_ram[] = \"General-purpose RAM\";\nstatic const char ms02nv_res_csr[] = \"Control and status register\";\n\nstatic struct mtd_info *root_ms02nv_mtd;\n\n\nstatic int ms02nv_read(struct mtd_info *mtd, loff_t from,\n\t\t\tsize_t len, size_t *retlen, u_char *buf)\n{\n\tstruct ms02nv_private *mp = mtd->priv;\n\n\tmemcpy(buf, mp->uaddr + from, len);\n\t*retlen = len;\n\treturn 0;\n}\n\nstatic int ms02nv_write(struct mtd_info *mtd, loff_t to,\n\t\t\tsize_t len, size_t *retlen, const u_char *buf)\n{\n\tstruct ms02nv_private *mp = mtd->priv;\n\n\tmemcpy(mp->uaddr + to, buf, len);\n\t*retlen = len;\n\treturn 0;\n}\n\n\nstatic inline uint ms02nv_probe_one(ulong addr)\n{\n\tms02nv_uint *ms02nv_diagp;\n\tms02nv_uint *ms02nv_magicp;\n\tuint ms02nv_diag;\n\tuint ms02nv_magic;\n\tsize_t size;\n\n\tint err;\n\n\t \n\tms02nv_diagp = (ms02nv_uint *)(CKSEG1ADDR(addr + MS02NV_DIAG));\n\tms02nv_magicp = (ms02nv_uint *)(CKSEG1ADDR(addr + MS02NV_MAGIC));\n\terr = get_dbe(ms02nv_magic, ms02nv_magicp);\n\tif (err)\n\t\treturn 0;\n\tif (ms02nv_magic != MS02NV_ID)\n\t\treturn 0;\n\n\tms02nv_diag = *ms02nv_diagp;\n\tsize = (ms02nv_diag & MS02NV_DIAG_SIZE_MASK) << MS02NV_DIAG_SIZE_SHIFT;\n\tif (size > MS02NV_CSR)\n\t\tsize = MS02NV_CSR;\n\n\treturn size;\n}\n\nstatic int __init ms02nv_init_one(ulong addr)\n{\n\tstruct mtd_info *mtd;\n\tstruct ms02nv_private *mp;\n\tstruct resource *mod_res;\n\tstruct resource *diag_res;\n\tstruct resource *user_res;\n\tstruct resource *csr_res;\n\tulong fixaddr;\n\tsize_t size, fixsize;\n\n\tstatic int version_printed;\n\n\tint ret = -ENODEV;\n\n\t \n\tmod_res = kzalloc(sizeof(*mod_res), GFP_KERNEL);\n\tif (!mod_res)\n\t\treturn -ENOMEM;\n\n\tmod_res->name = ms02nv_name;\n\tmod_res->start = addr;\n\tmod_res->end = addr + MS02NV_SLOT_SIZE - 1;\n\tmod_res->flags = IORESOURCE_MEM | IORESOURCE_BUSY;\n\tif (request_resource(&iomem_resource, mod_res) < 0)\n\t\tgoto err_out_mod_res;\n\n\tsize = ms02nv_probe_one(addr);\n\tif (!size)\n\t\tgoto err_out_mod_res_rel;\n\n\tif (!version_printed) {\n\t\tprintk(KERN_INFO \"%s\", version);\n\t\tversion_printed = 1;\n\t}\n\n\tret = -ENOMEM;\n\tmtd = kzalloc(sizeof(*mtd), GFP_KERNEL);\n\tif (!mtd)\n\t\tgoto err_out_mod_res_rel;\n\tmp = kzalloc(sizeof(*mp), GFP_KERNEL);\n\tif (!mp)\n\t\tgoto err_out_mtd;\n\n\tmtd->priv = mp;\n\tmp->resource.module = mod_res;\n\n\t \n\tdiag_res = kzalloc(sizeof(*diag_res), GFP_KERNEL);\n\tif (!diag_res)\n\t\tgoto err_out_mp;\n\n\tdiag_res->name = ms02nv_res_diag_ram;\n\tdiag_res->start = addr;\n\tdiag_res->end = addr + MS02NV_RAM - 1;\n\tdiag_res->flags = IORESOURCE_BUSY;\n\trequest_resource(mod_res, diag_res);\n\n\tmp->resource.diag_ram = diag_res;\n\n\t \n\tuser_res = kzalloc(sizeof(*user_res), GFP_KERNEL);\n\tif (!user_res)\n\t\tgoto err_out_diag_res;\n\n\tuser_res->name = ms02nv_res_user_ram;\n\tuser_res->start = addr + MS02NV_RAM;\n\tuser_res->end = addr + size - 1;\n\tuser_res->flags = IORESOURCE_BUSY;\n\trequest_resource(mod_res, user_res);\n\n\tmp->resource.user_ram = user_res;\n\n\t \n\tcsr_res = kzalloc(sizeof(*csr_res), GFP_KERNEL);\n\tif (!csr_res)\n\t\tgoto err_out_user_res;\n\n\tcsr_res->name = ms02nv_res_csr;\n\tcsr_res->start = addr + MS02NV_CSR;\n\tcsr_res->end = addr + MS02NV_CSR + 3;\n\tcsr_res->flags = IORESOURCE_BUSY;\n\trequest_resource(mod_res, csr_res);\n\n\tmp->resource.csr = csr_res;\n\n\tmp->addr = phys_to_virt(addr);\n\tmp->size = size;\n\n\t \n\tfixaddr = (addr + MS02NV_RAM + PAGE_SIZE - 1) & ~(PAGE_SIZE - 1);\n\tfixsize = (size - (fixaddr - addr)) & ~(PAGE_SIZE - 1);\n\tmp->uaddr = phys_to_virt(fixaddr);\n\n\tmtd->type = MTD_RAM;\n\tmtd->flags = MTD_CAP_RAM;\n\tmtd->size = fixsize;\n\tmtd->name = ms02nv_name;\n\tmtd->owner = THIS_MODULE;\n\tmtd->_read = ms02nv_read;\n\tmtd->_write = ms02nv_write;\n\tmtd->writesize = 1;\n\n\tret = -EIO;\n\tif (mtd_device_register(mtd, NULL, 0)) {\n\t\tprintk(KERN_ERR\n\t\t\t\"ms02-nv: Unable to register MTD device, aborting!\\n\");\n\t\tgoto err_out_csr_res;\n\t}\n\n\tprintk(KERN_INFO \"mtd%d: %s at 0x%08lx, size %zuMiB.\\n\",\n\t\tmtd->index, ms02nv_name, addr, size >> 20);\n\n\tmp->next = root_ms02nv_mtd;\n\troot_ms02nv_mtd = mtd;\n\n\treturn 0;\n\n\nerr_out_csr_res:\n\trelease_resource(csr_res);\n\tkfree(csr_res);\nerr_out_user_res:\n\trelease_resource(user_res);\n\tkfree(user_res);\nerr_out_diag_res:\n\trelease_resource(diag_res);\n\tkfree(diag_res);\nerr_out_mp:\n\tkfree(mp);\nerr_out_mtd:\n\tkfree(mtd);\nerr_out_mod_res_rel:\n\trelease_resource(mod_res);\nerr_out_mod_res:\n\tkfree(mod_res);\n\treturn ret;\n}\n\nstatic void __exit ms02nv_remove_one(void)\n{\n\tstruct mtd_info *mtd = root_ms02nv_mtd;\n\tstruct ms02nv_private *mp = mtd->priv;\n\n\troot_ms02nv_mtd = mp->next;\n\n\tmtd_device_unregister(mtd);\n\n\trelease_resource(mp->resource.csr);\n\tkfree(mp->resource.csr);\n\trelease_resource(mp->resource.user_ram);\n\tkfree(mp->resource.user_ram);\n\trelease_resource(mp->resource.diag_ram);\n\tkfree(mp->resource.diag_ram);\n\trelease_resource(mp->resource.module);\n\tkfree(mp->resource.module);\n\tkfree(mp);\n\tkfree(mtd);\n}\n\n\nstatic int __init ms02nv_init(void)\n{\n\tvolatile u32 *csr;\n\tuint stride = 0;\n\tint count = 0;\n\tint i;\n\n\tswitch (mips_machtype) {\n\tcase MACH_DS5000_200:\n\t\tcsr = (volatile u32 *)CKSEG1ADDR(KN02_SLOT_BASE + KN02_CSR);\n\t\tif (*csr & KN02_CSR_BNK32M)\n\t\t\tstride = 2;\n\t\tbreak;\n\tcase MACH_DS5000_2X0:\n\tcase MACH_DS5900:\n\t\tcsr = (volatile u32 *)CKSEG1ADDR(KN03_SLOT_BASE + IOASIC_MCR);\n\t\tif (*csr & KN03_MCR_BNK32M)\n\t\t\tstride = 2;\n\t\tbreak;\n\tdefault:\n\t\treturn -ENODEV;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(ms02nv_addrs); i++)\n\t\tif (!ms02nv_init_one(ms02nv_addrs[i] << stride))\n\t\t\tcount++;\n\n\treturn (count > 0) ? 0 : -ENODEV;\n}\n\nstatic void __exit ms02nv_cleanup(void)\n{\n\twhile (root_ms02nv_mtd)\n\t\tms02nv_remove_one();\n}\n\n\nmodule_init(ms02nv_init);\nmodule_exit(ms02nv_cleanup);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}