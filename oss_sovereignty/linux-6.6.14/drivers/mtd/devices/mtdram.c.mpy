{
  "module_name": "mtdram.c",
  "hash_id": "9053db351648ab34f80b1193ac44c69059acec17a4f495ea375a174c3295e38a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/devices/mtdram.c",
  "human_readable_source": " \n\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/ioport.h>\n#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/mtd/mtd.h>\n#include <linux/mtd/mtdram.h>\n\nstatic unsigned long total_size = CONFIG_MTDRAM_TOTAL_SIZE;\nstatic unsigned long erase_size = CONFIG_MTDRAM_ERASE_SIZE;\nstatic unsigned long writebuf_size = 64;\n#define MTDRAM_TOTAL_SIZE (total_size * 1024)\n#define MTDRAM_ERASE_SIZE (erase_size * 1024)\n\nmodule_param(total_size, ulong, 0);\nMODULE_PARM_DESC(total_size, \"Total device size in KiB\");\nmodule_param(erase_size, ulong, 0);\nMODULE_PARM_DESC(erase_size, \"Device erase block size in KiB\");\nmodule_param(writebuf_size, ulong, 0);\nMODULE_PARM_DESC(writebuf_size, \"Device write buf size in Bytes (Default: 64)\");\n\n\nstatic struct mtd_info *mtd_info;\n\nstatic int check_offs_len(struct mtd_info *mtd, loff_t ofs, uint64_t len)\n{\n\tint ret = 0;\n\n\t \n\tif (mtd_mod_by_eb(ofs, mtd)) {\n\t\tpr_debug(\"%s: unaligned address\\n\", __func__);\n\t\tret = -EINVAL;\n\t}\n\n\t \n\tif (mtd_mod_by_eb(len, mtd)) {\n\t\tpr_debug(\"%s: length not block aligned\\n\", __func__);\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}\n\nstatic int ram_erase(struct mtd_info *mtd, struct erase_info *instr)\n{\n\tif (check_offs_len(mtd, instr->addr, instr->len))\n\t\treturn -EINVAL;\n\tmemset((char *)mtd->priv + instr->addr, 0xff, instr->len);\n\n\treturn 0;\n}\n\nstatic int ram_point(struct mtd_info *mtd, loff_t from, size_t len,\n\t\tsize_t *retlen, void **virt, resource_size_t *phys)\n{\n\t*virt = mtd->priv + from;\n\t*retlen = len;\n\n\tif (phys) {\n\t\t \n\t\tunsigned long page_ofs = offset_in_page(*virt);\n\t\tvoid *addr = *virt - page_ofs;\n\t\tunsigned long pfn1, pfn0 = vmalloc_to_pfn(addr);\n\n\t\t*phys = __pfn_to_phys(pfn0) + page_ofs;\n\t\tlen += page_ofs;\n\t\twhile (len > PAGE_SIZE) {\n\t\t\tlen -= PAGE_SIZE;\n\t\t\taddr += PAGE_SIZE;\n\t\t\tpfn0++;\n\t\t\tpfn1 = vmalloc_to_pfn(addr);\n\t\t\tif (pfn1 != pfn0) {\n\t\t\t\t*retlen = addr - *virt;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int ram_unpoint(struct mtd_info *mtd, loff_t from, size_t len)\n{\n\treturn 0;\n}\n\nstatic int ram_read(struct mtd_info *mtd, loff_t from, size_t len,\n\t\tsize_t *retlen, u_char *buf)\n{\n\tmemcpy(buf, mtd->priv + from, len);\n\t*retlen = len;\n\treturn 0;\n}\n\nstatic int ram_write(struct mtd_info *mtd, loff_t to, size_t len,\n\t\tsize_t *retlen, const u_char *buf)\n{\n\tmemcpy((char *)mtd->priv + to, buf, len);\n\t*retlen = len;\n\treturn 0;\n}\n\nstatic void __exit cleanup_mtdram(void)\n{\n\tif (mtd_info) {\n\t\tmtd_device_unregister(mtd_info);\n\t\tvfree(mtd_info->priv);\n\t\tkfree(mtd_info);\n\t}\n}\n\nint mtdram_init_device(struct mtd_info *mtd, void *mapped_address,\n\t\tunsigned long size, const char *name)\n{\n\tmemset(mtd, 0, sizeof(*mtd));\n\n\t \n\tmtd->name = name;\n\tmtd->type = MTD_RAM;\n\tmtd->flags = MTD_CAP_RAM;\n\tmtd->size = size;\n\tmtd->writesize = 1;\n\tmtd->writebufsize = writebuf_size;\n\tmtd->erasesize = MTDRAM_ERASE_SIZE;\n\tmtd->priv = mapped_address;\n\n\tmtd->owner = THIS_MODULE;\n\tmtd->_erase = ram_erase;\n\tmtd->_point = ram_point;\n\tmtd->_unpoint = ram_unpoint;\n\tmtd->_read = ram_read;\n\tmtd->_write = ram_write;\n\n\tif (mtd_device_register(mtd, NULL, 0))\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nstatic int __init init_mtdram(void)\n{\n\tvoid *addr;\n\tint err;\n\n\tif (!total_size)\n\t\treturn -EINVAL;\n\n\t \n\tmtd_info = kmalloc(sizeof(struct mtd_info), GFP_KERNEL);\n\tif (!mtd_info)\n\t\treturn -ENOMEM;\n\n\taddr = vmalloc(MTDRAM_TOTAL_SIZE);\n\tif (!addr) {\n\t\tkfree(mtd_info);\n\t\tmtd_info = NULL;\n\t\treturn -ENOMEM;\n\t}\n\terr = mtdram_init_device(mtd_info, addr, MTDRAM_TOTAL_SIZE, \"mtdram test device\");\n\tif (err) {\n\t\tvfree(addr);\n\t\tkfree(mtd_info);\n\t\tmtd_info = NULL;\n\t\treturn err;\n\t}\n\tmemset(mtd_info->priv, 0xff, MTDRAM_TOTAL_SIZE);\n\treturn err;\n}\n\nmodule_init(init_mtdram);\nmodule_exit(cleanup_mtdram);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Alexander Larsson <alexl@redhat.com>\");\nMODULE_DESCRIPTION(\"Simulated MTD driver for testing\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}