{
  "module_name": "phram.c",
  "hash_id": "8ca293ec8bc877ca48289f07c0c9ac5225a387ba32f90c5a27341a997068ffe4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/devices/phram.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/io.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/slab.h>\n#include <linux/mtd/mtd.h>\n#include <asm/div64.h>\n#include <linux/platform_device.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n\nstruct phram_mtd_list {\n\tstruct mtd_info mtd;\n\tstruct list_head list;\n\tbool cached;\n};\n\nstatic LIST_HEAD(phram_list);\n\nstatic int phram_erase(struct mtd_info *mtd, struct erase_info *instr)\n{\n\tu_char *start = mtd->priv;\n\n\tmemset(start + instr->addr, 0xff, instr->len);\n\n\treturn 0;\n}\n\nstatic int phram_point(struct mtd_info *mtd, loff_t from, size_t len,\n\t\tsize_t *retlen, void **virt, resource_size_t *phys)\n{\n\t*virt = mtd->priv + from;\n\t*retlen = len;\n\treturn 0;\n}\n\nstatic int phram_unpoint(struct mtd_info *mtd, loff_t from, size_t len)\n{\n\treturn 0;\n}\n\nstatic int phram_read(struct mtd_info *mtd, loff_t from, size_t len,\n\t\tsize_t *retlen, u_char *buf)\n{\n\tu_char *start = mtd->priv;\n\n\tmemcpy(buf, start + from, len);\n\t*retlen = len;\n\treturn 0;\n}\n\nstatic int phram_write(struct mtd_info *mtd, loff_t to, size_t len,\n\t\tsize_t *retlen, const u_char *buf)\n{\n\tu_char *start = mtd->priv;\n\n\tmemcpy(start + to, buf, len);\n\t*retlen = len;\n\treturn 0;\n}\n\nstatic int phram_map(struct phram_mtd_list *phram, phys_addr_t start, size_t len)\n{\n\tvoid *addr = NULL;\n\n\tif (phram->cached)\n\t\taddr = memremap(start, len, MEMREMAP_WB);\n\telse\n\t\taddr = (void __force *)ioremap(start, len);\n\tif (!addr)\n\t\treturn -EIO;\n\n\tphram->mtd.priv = addr;\n\n\treturn 0;\n}\n\nstatic void phram_unmap(struct phram_mtd_list *phram)\n{\n\tvoid *addr = phram->mtd.priv;\n\n\tif (phram->cached) {\n\t\tmemunmap(addr);\n\t\treturn;\n\t}\n\n\tiounmap((void __iomem *)addr);\n}\n\nstatic void unregister_devices(void)\n{\n\tstruct phram_mtd_list *this, *safe;\n\n\tlist_for_each_entry_safe(this, safe, &phram_list, list) {\n\t\tmtd_device_unregister(&this->mtd);\n\t\tphram_unmap(this);\n\t\tkfree(this->mtd.name);\n\t\tkfree(this);\n\t}\n}\n\nstatic int register_device(struct platform_device *pdev, const char *name,\n\t\t\t   phys_addr_t start, size_t len, uint32_t erasesize)\n{\n\tstruct device_node *np = pdev ? pdev->dev.of_node : NULL;\n\tbool cached = np ? !of_property_read_bool(np, \"no-map\") : false;\n\tstruct phram_mtd_list *new;\n\tint ret = -ENOMEM;\n\n\tnew = kzalloc(sizeof(*new), GFP_KERNEL);\n\tif (!new)\n\t\tgoto out0;\n\n\tnew->cached = cached;\n\n\tret = phram_map(new, start, len);\n\tif (ret) {\n\t\tpr_err(\"ioremap failed\\n\");\n\t\tgoto out1;\n\t}\n\n\n\tnew->mtd.name = name;\n\tnew->mtd.size = len;\n\tnew->mtd.flags = MTD_CAP_RAM;\n\tnew->mtd._erase = phram_erase;\n\tnew->mtd._point = phram_point;\n\tnew->mtd._unpoint = phram_unpoint;\n\tnew->mtd._read = phram_read;\n\tnew->mtd._write = phram_write;\n\tnew->mtd.owner = THIS_MODULE;\n\tnew->mtd.type = MTD_RAM;\n\tnew->mtd.erasesize = erasesize;\n\tnew->mtd.writesize = 1;\n\n\tmtd_set_of_node(&new->mtd, np);\n\n\tret = -EAGAIN;\n\tif (mtd_device_register(&new->mtd, NULL, 0)) {\n\t\tpr_err(\"Failed to register new device\\n\");\n\t\tgoto out2;\n\t}\n\n\tif (pdev)\n\t\tplatform_set_drvdata(pdev, new);\n\telse\n\t\tlist_add_tail(&new->list, &phram_list);\n\n\treturn 0;\n\nout2:\n\tphram_unmap(new);\nout1:\n\tkfree(new);\nout0:\n\treturn ret;\n}\n\nstatic int parse_num64(uint64_t *num64, char *token)\n{\n\tsize_t len;\n\tint shift = 0;\n\tint ret;\n\n\tlen = strlen(token);\n\t \n\tif (len > 2) {\n\t\tif (token[len - 1] == 'i') {\n\t\t\tswitch (token[len - 2]) {\n\t\t\tcase 'G':\n\t\t\t\tshift += 10;\n\t\t\t\tfallthrough;\n\t\t\tcase 'M':\n\t\t\t\tshift += 10;\n\t\t\t\tfallthrough;\n\t\t\tcase 'k':\n\t\t\t\tshift += 10;\n\t\t\t\ttoken[len - 2] = 0;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t}\n\n\tret = kstrtou64(token, 0, num64);\n\t*num64 <<= shift;\n\n\treturn ret;\n}\n\nstatic int parse_name(char **pname, const char *token)\n{\n\tsize_t len;\n\tchar *name;\n\n\tlen = strlen(token) + 1;\n\tif (len > 64)\n\t\treturn -ENOSPC;\n\n\tname = kstrdup(token, GFP_KERNEL);\n\tif (!name)\n\t\treturn -ENOMEM;\n\n\t*pname = name;\n\treturn 0;\n}\n\n\nstatic inline void kill_final_newline(char *str)\n{\n\tchar *newline = strrchr(str, '\\n');\n\n\tif (newline && !newline[1])\n\t\t*newline = 0;\n}\n\n\n#define parse_err(fmt, args...) do {\t\\\n\tpr_err(fmt , ## args);\t\\\n\treturn 1;\t\t\\\n} while (0)\n\n#ifndef MODULE\nstatic int phram_init_called;\n \nstatic char phram_paramline[64 + 20 + 20 + 20];\n#endif\n\nstatic int phram_setup(const char *val)\n{\n\tchar buf[64 + 20 + 20 + 20], *str = buf;\n\tchar *token[4];\n\tchar *name;\n\tuint64_t start;\n\tuint64_t len;\n\tuint64_t erasesize = PAGE_SIZE;\n\tuint32_t rem;\n\tint i, ret;\n\n\tif (strnlen(val, sizeof(buf)) >= sizeof(buf))\n\t\tparse_err(\"parameter too long\\n\");\n\n\tstrcpy(str, val);\n\tkill_final_newline(str);\n\n\tfor (i = 0; i < 4; i++)\n\t\ttoken[i] = strsep(&str, \",\");\n\n\tif (str)\n\t\tparse_err(\"too many arguments\\n\");\n\n\tif (!token[2])\n\t\tparse_err(\"not enough arguments\\n\");\n\n\tret = parse_name(&name, token[0]);\n\tif (ret)\n\t\treturn ret;\n\n\tret = parse_num64(&start, token[1]);\n\tif (ret) {\n\t\tparse_err(\"illegal start address\\n\");\n\t\tgoto error;\n\t}\n\n\tret = parse_num64(&len, token[2]);\n\tif (ret) {\n\t\tparse_err(\"illegal device length\\n\");\n\t\tgoto error;\n\t}\n\n\tif (token[3]) {\n\t\tret = parse_num64(&erasesize, token[3]);\n\t\tif (ret) {\n\t\t\tparse_err(\"illegal erasesize\\n\");\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\tif (len == 0 || erasesize == 0 || erasesize > len\n\t    || erasesize > UINT_MAX) {\n\t\tparse_err(\"illegal erasesize or len\\n\");\n\t\tret = -EINVAL;\n\t\tgoto error;\n\t}\n\n\tdiv_u64_rem(len, (uint32_t)erasesize, &rem);\n\tif (rem) {\n\t\tparse_err(\"len is not multiple of erasesize\\n\");\n\t\tret = -EINVAL;\n\t\tgoto error;\n\t}\n\n\tret = register_device(NULL, name, start, len, (uint32_t)erasesize);\n\tif (ret)\n\t\tgoto error;\n\n\tpr_info(\"%s device: %#llx at %#llx for erasesize %#llx\\n\", name, len, start, erasesize);\n\treturn 0;\n\nerror:\n\tkfree(name);\n\treturn ret;\n}\n\nstatic int phram_param_call(const char *val, const struct kernel_param *kp)\n{\n#ifdef MODULE\n\treturn phram_setup(val);\n#else\n\t \n\n\tif (phram_init_called)\n\t\treturn phram_setup(val);\n\n\t \n\n\tif (strlen(val) >= sizeof(phram_paramline))\n\t\treturn -ENOSPC;\n\tstrcpy(phram_paramline, val);\n\n\treturn 0;\n#endif\n}\n\nmodule_param_call(phram, phram_param_call, NULL, NULL, 0200);\nMODULE_PARM_DESC(phram, \"Memory region to map. \\\"phram=<name>,<start>,<length>[,<erasesize>]\\\"\");\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id phram_of_match[] = {\n\t{ .compatible = \"phram\" },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, phram_of_match);\n#endif\n\nstatic int phram_probe(struct platform_device *pdev)\n{\n\tstruct resource *res;\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!res)\n\t\treturn -ENOMEM;\n\n\t \n\treturn register_device(pdev, NULL, res->start, resource_size(res),\n\t\t\t       PAGE_SIZE);\n}\n\nstatic int phram_remove(struct platform_device *pdev)\n{\n\tstruct phram_mtd_list *phram = platform_get_drvdata(pdev);\n\n\tmtd_device_unregister(&phram->mtd);\n\tphram_unmap(phram);\n\tkfree(phram);\n\n\treturn 0;\n}\n\nstatic struct platform_driver phram_driver = {\n\t.probe\t\t= phram_probe,\n\t.remove\t\t= phram_remove,\n\t.driver\t\t= {\n\t\t.name\t\t= \"phram\",\n\t\t.of_match_table\t= of_match_ptr(phram_of_match),\n\t},\n};\n\nstatic int __init init_phram(void)\n{\n\tint ret;\n\n\tret = platform_driver_register(&phram_driver);\n\tif (ret)\n\t\treturn ret;\n\n#ifndef MODULE\n\tif (phram_paramline[0])\n\t\tret = phram_setup(phram_paramline);\n\tphram_init_called = 1;\n#endif\n\n\tif (ret)\n\t\tplatform_driver_unregister(&phram_driver);\n\n\treturn ret;\n}\n\nstatic void __exit cleanup_phram(void)\n{\n\tunregister_devices();\n\tplatform_driver_unregister(&phram_driver);\n}\n\nmodule_init(init_phram);\nmodule_exit(cleanup_phram);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Joern Engel <joern@wh.fh-wedel.de>\");\nMODULE_DESCRIPTION(\"MTD driver for physical RAM\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}