{
  "module_name": "Kconfig",
  "hash_id": "c2a9bcbf1dd5e78b6810d97b4f5c37dccdeabf6bdbb696201670c9b2bb2ab387",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/devices/Kconfig",
  "human_readable_source": "# SPDX-License-Identifier: GPL-2.0-only\nmenu \"Self-contained MTD device drivers\"\n\tdepends on MTD!=n\n\tdepends on HAS_IOMEM\n\nconfig MTD_PMC551\n\ttristate \"Ramix PMC551 PCI Mezzanine RAM card support\"\n\tdepends on PCI\n\thelp\n\t  This provides a MTD device driver for the Ramix PMC551 RAM PCI card\n\t  from Ramix Inc. <http://www.ramix.com/products/memory/pmc551.html>.\n\t  These devices come in memory configurations from 32M - 1G.  If you\n\t  have one, you probably want to enable this.\n\n\t  If this driver is compiled as a module you get the ability to select\n\t  the size of the aperture window pointing into the devices memory.\n\t  What this means is that if you have a 1G card, normally the kernel\n\t  will use a 1G memory map as its view of the device.  As a module,\n\t  you can select a 1M window into the memory and the driver will\n\t  \"slide\" the window around the PMC551's memory.  This was\n\t  particularly useful on the 2.2 kernels on PPC architectures as there\n\t  was limited kernel space to deal with.\n\nconfig MTD_PMC551_BUGFIX\n\tbool \"PMC551 256M DRAM Bugfix\"\n\tdepends on MTD_PMC551\n\thelp\n\t  Some of Ramix's PMC551 boards with 256M configurations have invalid\n\t  column and row mux values.  This option will fix them, but will\n\t  break other memory configurations.  If unsure say N.\n\nconfig MTD_PMC551_DEBUG\n\tbool \"PMC551 Debugging\"\n\tdepends on MTD_PMC551\n\thelp\n\t  This option makes the PMC551 more verbose during its operation and\n\t  is only really useful if you are developing on this driver or\n\t  suspect a possible hardware or driver bug.  If unsure say N.\n\nconfig MTD_MS02NV\n\ttristate \"DEC MS02-NV NVRAM module support\"\n\tdepends on MACH_DECSTATION\n\thelp\n\t  This is an MTD driver for the DEC's MS02-NV (54-20948-01) battery\n\t  backed-up NVRAM module.  The module was originally meant as an NFS\n\t  accelerator.  Say Y here if you have a DECstation 5000/2x0 or a\n\t  DECsystem 5900 equipped with such a module.\n\n\t  If you want to compile this driver as a module ( = code which can be\n\t  inserted in and removed from the running kernel whenever you want),\n\t  say M here and read <file:Documentation/kbuild/modules.rst>.\n\t  The module will be called ms02-nv.\n\nconfig MTD_DATAFLASH\n\ttristate \"Support for AT45xxx DataFlash\"\n\tdepends on SPI_MASTER\n\thelp\n\t  This enables access to AT45xxx DataFlash chips, using SPI.\n\t  Sometimes DataFlash chips are packaged inside MMC-format\n\t  cards; at this writing, the MMC stack won't handle those.\n\nconfig MTD_DATAFLASH_WRITE_VERIFY\n\tbool \"Verify DataFlash page writes\"\n\tdepends on MTD_DATAFLASH\n\thelp\n\t  This adds an extra check when data is written to the flash.\n\t  It may help if you are verifying chip setup (timings etc) on\n\t  your board.  There is a rare possibility that even though the\n\t  device thinks the write was successful, a bit could have been\n\t  flipped accidentally due to device wear or something else.\n\nconfig MTD_DATAFLASH_OTP\n\tbool \"DataFlash OTP support (Security Register)\"\n\tdepends on MTD_DATAFLASH\n\thelp\n\t  Newer DataFlash chips (revisions C and D) support 128 bytes of\n\t  one-time-programmable (OTP) data.  The first half may be written\n\t  (once) with up to 64 bytes of data, such as a serial number or\n\t  other key product data.  The second half is programmed with a\n\t  unique-to-each-chip bit pattern at the factory.\n\nconfig MTD_MCHP23K256\n\ttristate \"Microchip 23K256 SRAM\"\n\tdepends on SPI_MASTER\n\thelp\n\t  This enables access to Microchip 23K256 SRAM chips, using SPI.\n\n\t  Set up your spi devices with the right board-specific\n\t  platform data, or a device tree description if you want to\n\t  specify device partitioning\n\nconfig MTD_MCHP48L640\n\ttristate \"Microchip 48L640 EERAM\"\n\tdepends on SPI_MASTER\n\thelp\n\t  This enables access to Microchip 48L640 EERAM chips, using SPI.\n\nconfig MTD_SPEAR_SMI\n\ttristate \"SPEAR MTD NOR Support through SMI controller\"\n\tdepends on PLAT_SPEAR || COMPILE_TEST\n\tdefault y\n\thelp\n\t  This enable SNOR support on SPEAR platforms using SMI controller\n\nconfig MTD_SST25L\n\ttristate \"Support SST25L (non JEDEC) SPI Flash chips\"\n\tdepends on SPI_MASTER\n\thelp\n\t  This enables access to the non JEDEC SST25L SPI flash chips, used\n\t  for program and data storage.\n\n\t  Set up your spi devices with the right board-specific platform data,\n\t  if you want to specify device partitioning.\n\nconfig MTD_BCM47XXSFLASH\n\ttristate \"Support for serial flash on BCMA bus\"\n\tdepends on BCMA_SFLASH && (MIPS || ARM)\n\thelp\n\t  BCMA bus can have various flash memories attached, they are\n\t  registered by bcma as platform devices. This enables driver for\n\t  serial flash memories.\n\nconfig MTD_SLRAM\n\ttristate \"Uncached system RAM\"\n\thelp\n\t  If your CPU cannot cache all of the physical memory in your machine,\n\t  you can still use it for storage or swap by using this driver to\n\t  present it to the system as a Memory Technology Device.\n\nconfig MTD_PHRAM\n\ttristate \"Physical system RAM\"\n\thelp\n\t  This is a re-implementation of the slram driver above.\n\n\t  Use this driver to access physical memory that the kernel proper\n\t  doesn't have access to, memory beyond the mem=xxx limit, nvram,\n\t  memory on the video card, etc...\n\nconfig MTD_MTDRAM\n\ttristate \"Test driver using RAM\"\n\thelp\n\t  This enables a test MTD device driver which uses vmalloc() to\n\t  provide storage.  You probably want to say 'N' unless you're\n\t  testing stuff.\n\nconfig MTDRAM_TOTAL_SIZE\n\tint \"MTDRAM device size in KiB\"\n\tdepends on MTD_MTDRAM\n\tdefault \"4096\"\n\thelp\n\t  This allows you to configure the total size of the MTD device\n\t  emulated by the MTDRAM driver.  If the MTDRAM driver is built\n\t  as a module, it is also possible to specify this as a parameter when\n\t  loading the module.\n\nconfig MTDRAM_ERASE_SIZE\n\tint \"MTDRAM erase block size in KiB\"\n\tdepends on MTD_MTDRAM\n\tdefault \"128\"\n\thelp\n\t  This allows you to configure the size of the erase blocks in the\n\t  device emulated by the MTDRAM driver.  If the MTDRAM driver is built\n\t  as a module, it is also possible to specify this as a parameter when\n\t  loading the module.\n\nconfig MTD_BLOCK2MTD\n\ttristate \"MTD using block device\"\n\tdepends on BLOCK\n\thelp\n\t  This driver allows a block device to appear as an MTD. It would\n\t  generally be used in the following cases:\n\n\t  Using Compact Flash as an MTD, these usually present themselves to\n\t  the system as an ATA drive.\n\t  Testing MTD users (eg JFFS2) on large media and media that might\n\t  be removed during a write (using the floppy drive).\n\nconfig MTD_POWERNV_FLASH\n\ttristate \"powernv flash MTD driver\"\n\tdepends on PPC_POWERNV\n\thelp\n\t  This provides an MTD device to access flash on powernv OPAL\n\t  platforms from Linux. This device abstracts away the\n\t  firmware interface for flash access.\n\ncomment \"Disk-On-Chip Device Drivers\"\n\nconfig MTD_DOCG3\n\ttristate \"M-Systems Disk-On-Chip G3\"\n\tselect BCH\n\tselect BCH_CONST_PARAMS if !MTD_NAND_ECC_SW_BCH\n\tselect BITREVERSE\n\thelp\n\t  This provides an MTD device driver for the M-Systems DiskOnChip\n\t  G3 devices.\n\n\t  The driver provides access to G3 DiskOnChip, distributed by\n\t  M-Systems and now Sandisk. The support is very experimental,\n\t  and doesn't give access to any write operations.\n\nconfig MTD_ST_SPI_FSM\n\ttristate \"ST Microelectronics SPI FSM Serial Flash Controller\"\n\tdepends on ARCH_STI\n\thelp\n\t  This provides an MTD device driver for the ST Microelectronics\n\t  SPI Fast Sequence Mode (FSM) Serial Flash Controller and support\n\t  for a subset of connected Serial Flash devices.\n\nif MTD_DOCG3\nconfig BCH_CONST_M\n\tdefault 14\nconfig BCH_CONST_T\n\tdefault 4\nendif\n\nendmenu\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}