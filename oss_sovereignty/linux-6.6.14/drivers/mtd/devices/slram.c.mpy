{
  "module_name": "slram.c",
  "hash_id": "a3da0c150ddcdb6833ce5ef93052fccb0599c66a08121eab28e3ae34aef817ef",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/devices/slram.c",
  "human_readable_source": "\n \n\n\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/ptrace.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/timer.h>\n#include <linux/major.h>\n#include <linux/fs.h>\n#include <linux/ioctl.h>\n#include <linux/init.h>\n#include <linux/io.h>\n\n#include <linux/mtd/mtd.h>\n\n#define SLRAM_MAX_DEVICES_PARAMS 6\t\t \n#define SLRAM_BLK_SZ 0x4000\n\n#define T(fmt, args...) printk(KERN_DEBUG fmt, ## args)\n#define E(fmt, args...) printk(KERN_NOTICE fmt, ## args)\n\ntypedef struct slram_priv {\n\tu_char *start;\n\tu_char *end;\n} slram_priv_t;\n\ntypedef struct slram_mtd_list {\n\tstruct mtd_info *mtdinfo;\n\tstruct slram_mtd_list *next;\n} slram_mtd_list_t;\n\n#ifdef MODULE\nstatic char *map[SLRAM_MAX_DEVICES_PARAMS];\n\nmodule_param_array(map, charp, NULL, 0);\nMODULE_PARM_DESC(map, \"List of memory regions to map. \\\"map=<name>, <start>, <length / end>\\\"\");\n#else\nstatic char *map;\n#endif\n\nstatic slram_mtd_list_t *slram_mtdlist = NULL;\n\nstatic int slram_erase(struct mtd_info *, struct erase_info *);\nstatic int slram_point(struct mtd_info *, loff_t, size_t, size_t *, void **,\n\t\tresource_size_t *);\nstatic int slram_unpoint(struct mtd_info *, loff_t, size_t);\nstatic int slram_read(struct mtd_info *, loff_t, size_t, size_t *, u_char *);\nstatic int slram_write(struct mtd_info *, loff_t, size_t, size_t *, const u_char *);\n\nstatic int slram_erase(struct mtd_info *mtd, struct erase_info *instr)\n{\n\tslram_priv_t *priv = mtd->priv;\n\n\tmemset(priv->start + instr->addr, 0xff, instr->len);\n\n\treturn(0);\n}\n\nstatic int slram_point(struct mtd_info *mtd, loff_t from, size_t len,\n\t\tsize_t *retlen, void **virt, resource_size_t *phys)\n{\n\tslram_priv_t *priv = mtd->priv;\n\n\t*virt = priv->start + from;\n\t*retlen = len;\n\treturn(0);\n}\n\nstatic int slram_unpoint(struct mtd_info *mtd, loff_t from, size_t len)\n{\n\treturn 0;\n}\n\nstatic int slram_read(struct mtd_info *mtd, loff_t from, size_t len,\n\t\tsize_t *retlen, u_char *buf)\n{\n\tslram_priv_t *priv = mtd->priv;\n\n\tmemcpy(buf, priv->start + from, len);\n\t*retlen = len;\n\treturn(0);\n}\n\nstatic int slram_write(struct mtd_info *mtd, loff_t to, size_t len,\n\t\tsize_t *retlen, const u_char *buf)\n{\n\tslram_priv_t *priv = mtd->priv;\n\n\tmemcpy(priv->start + to, buf, len);\n\t*retlen = len;\n\treturn(0);\n}\n\n \n\nstatic int register_device(char *name, unsigned long start, unsigned long length)\n{\n\tslram_mtd_list_t **curmtd;\n\n\tcurmtd = &slram_mtdlist;\n\twhile (*curmtd) {\n\t\tcurmtd = &(*curmtd)->next;\n\t}\n\n\t*curmtd = kmalloc(sizeof(slram_mtd_list_t), GFP_KERNEL);\n\tif (!(*curmtd)) {\n\t\tE(\"slram: Cannot allocate new MTD device.\\n\");\n\t\treturn(-ENOMEM);\n\t}\n\t(*curmtd)->mtdinfo = kzalloc(sizeof(struct mtd_info), GFP_KERNEL);\n\t(*curmtd)->next = NULL;\n\n\tif ((*curmtd)->mtdinfo)\t{\n\t\t(*curmtd)->mtdinfo->priv =\n\t\t\tkzalloc(sizeof(slram_priv_t), GFP_KERNEL);\n\n\t\tif (!(*curmtd)->mtdinfo->priv) {\n\t\t\tkfree((*curmtd)->mtdinfo);\n\t\t\t(*curmtd)->mtdinfo = NULL;\n\t\t}\n\t}\n\n\tif (!(*curmtd)->mtdinfo) {\n\t\tE(\"slram: Cannot allocate new MTD device.\\n\");\n\t\treturn(-ENOMEM);\n\t}\n\n\tif (!(((slram_priv_t *)(*curmtd)->mtdinfo->priv)->start =\n\t\tmemremap(start, length,\n\t\t\t MEMREMAP_WB | MEMREMAP_WT | MEMREMAP_WC))) {\n\t\tE(\"slram: memremap failed\\n\");\n\t\treturn -EIO;\n\t}\n\t((slram_priv_t *)(*curmtd)->mtdinfo->priv)->end =\n\t\t((slram_priv_t *)(*curmtd)->mtdinfo->priv)->start + length;\n\n\n\t(*curmtd)->mtdinfo->name = name;\n\t(*curmtd)->mtdinfo->size = length;\n\t(*curmtd)->mtdinfo->flags = MTD_CAP_RAM;\n\t(*curmtd)->mtdinfo->_erase = slram_erase;\n\t(*curmtd)->mtdinfo->_point = slram_point;\n\t(*curmtd)->mtdinfo->_unpoint = slram_unpoint;\n\t(*curmtd)->mtdinfo->_read = slram_read;\n\t(*curmtd)->mtdinfo->_write = slram_write;\n\t(*curmtd)->mtdinfo->owner = THIS_MODULE;\n\t(*curmtd)->mtdinfo->type = MTD_RAM;\n\t(*curmtd)->mtdinfo->erasesize = SLRAM_BLK_SZ;\n\t(*curmtd)->mtdinfo->writesize = 1;\n\n\tif (mtd_device_register((*curmtd)->mtdinfo, NULL, 0))\t{\n\t\tE(\"slram: Failed to register new device\\n\");\n\t\tmemunmap(((slram_priv_t *)(*curmtd)->mtdinfo->priv)->start);\n\t\tkfree((*curmtd)->mtdinfo->priv);\n\t\tkfree((*curmtd)->mtdinfo);\n\t\treturn(-EAGAIN);\n\t}\n\tT(\"slram: Registered device %s from %luKiB to %luKiB\\n\", name,\n\t\t\t(start / 1024), ((start + length) / 1024));\n\tT(\"slram: Mapped from 0x%p to 0x%p\\n\",\n\t\t\t((slram_priv_t *)(*curmtd)->mtdinfo->priv)->start,\n\t\t\t((slram_priv_t *)(*curmtd)->mtdinfo->priv)->end);\n\treturn(0);\n}\n\nstatic void unregister_devices(void)\n{\n\tslram_mtd_list_t *nextitem;\n\n\twhile (slram_mtdlist) {\n\t\tnextitem = slram_mtdlist->next;\n\t\tmtd_device_unregister(slram_mtdlist->mtdinfo);\n\t\tmemunmap(((slram_priv_t *)slram_mtdlist->mtdinfo->priv)->start);\n\t\tkfree(slram_mtdlist->mtdinfo->priv);\n\t\tkfree(slram_mtdlist->mtdinfo);\n\t\tkfree(slram_mtdlist);\n\t\tslram_mtdlist = nextitem;\n\t}\n}\n\nstatic unsigned long handle_unit(unsigned long value, char *unit)\n{\n\tif ((*unit == 'M') || (*unit == 'm')) {\n\t\treturn(value * 1024 * 1024);\n\t} else if ((*unit == 'K') || (*unit == 'k')) {\n\t\treturn(value * 1024);\n\t}\n\treturn(value);\n}\n\nstatic int parse_cmdline(char *devname, char *szstart, char *szlength)\n{\n\tchar *buffer;\n\tunsigned long devstart;\n\tunsigned long devlength;\n\n\tif ((!devname) || (!szstart) || (!szlength)) {\n\t\tunregister_devices();\n\t\treturn(-EINVAL);\n\t}\n\n\tdevstart = simple_strtoul(szstart, &buffer, 0);\n\tdevstart = handle_unit(devstart, buffer);\n\n\tif (*(szlength) != '+') {\n\t\tdevlength = simple_strtoul(szlength, &buffer, 0);\n\t\tdevlength = handle_unit(devlength, buffer);\n\t\tif (devlength < devstart)\n\t\t\tgoto err_out;\n\n\t\tdevlength -= devstart;\n\t} else {\n\t\tdevlength = simple_strtoul(szlength + 1, &buffer, 0);\n\t\tdevlength = handle_unit(devlength, buffer);\n\t}\n\tT(\"slram: devname=%s, devstart=0x%lx, devlength=0x%lx\\n\",\n\t\t\tdevname, devstart, devlength);\n\tif (devlength % SLRAM_BLK_SZ != 0)\n\t\tgoto err_out;\n\n\tif ((devstart = register_device(devname, devstart, devlength))){\n\t\tunregister_devices();\n\t\treturn((int)devstart);\n\t}\n\treturn(0);\n\nerr_out:\n\tE(\"slram: Illegal length parameter.\\n\");\n\treturn(-EINVAL);\n}\n\n#ifndef MODULE\n\nstatic int __init mtd_slram_setup(char *str)\n{\n\tmap = str;\n\treturn(1);\n}\n\n__setup(\"slram=\", mtd_slram_setup);\n\n#endif\n\nstatic int __init init_slram(void)\n{\n\tchar *devname;\n\n#ifndef MODULE\n\tchar *devstart;\n\tchar *devlength;\n\n\tif (!map) {\n\t\tE(\"slram: not enough parameters.\\n\");\n\t\treturn(-EINVAL);\n\t}\n\twhile (map) {\n\t\tdevname = devstart = devlength = NULL;\n\n\t\tif (!(devname = strsep(&map, \",\"))) {\n\t\t\tE(\"slram: No devicename specified.\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tT(\"slram: devname = %s\\n\", devname);\n\t\tif ((!map) || (!(devstart = strsep(&map, \",\")))) {\n\t\t\tE(\"slram: No devicestart specified.\\n\");\n\t\t}\n\t\tT(\"slram: devstart = %s\\n\", devstart);\n\t\tif ((!map) || (!(devlength = strsep(&map, \",\")))) {\n\t\t\tE(\"slram: No devicelength / -end specified.\\n\");\n\t\t}\n\t\tT(\"slram: devlength = %s\\n\", devlength);\n\t\tif (parse_cmdline(devname, devstart, devlength) != 0) {\n\t\t\treturn(-EINVAL);\n\t\t}\n\t}\n#else\n\tint count;\n\tint i;\n\n\tfor (count = 0; count < SLRAM_MAX_DEVICES_PARAMS && map[count];\n\t\t\tcount++) {\n\t}\n\n\tif ((count % 3 != 0) || (count == 0)) {\n\t\tE(\"slram: not enough parameters.\\n\");\n\t\treturn(-EINVAL);\n\t}\n\tfor (i = 0; i < (count / 3); i++) {\n\t\tdevname = map[i * 3];\n\n\t\tif (parse_cmdline(devname, map[i * 3 + 1], map[i * 3 + 2])!=0) {\n\t\t\treturn(-EINVAL);\n\t\t}\n\n\t}\n#endif  \n\n\treturn(0);\n}\n\nstatic void __exit cleanup_slram(void)\n{\n\tunregister_devices();\n}\n\nmodule_init(init_slram);\nmodule_exit(cleanup_slram);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Jochen Schaeuble <psionic@psionic.de>\");\nMODULE_DESCRIPTION(\"MTD driver for uncached system RAM\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}