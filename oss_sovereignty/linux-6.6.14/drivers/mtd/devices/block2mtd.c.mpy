{
  "module_name": "block2mtd.c",
  "hash_id": "d3a945bc95a950304cc2cabf51f9798d004cebea210bd7c0771ac3eb87ba5ae1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/devices/block2mtd.c",
  "human_readable_source": " \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n \n#define MTD_DEFAULT_TIMEOUT\t3\n\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/fs.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/bio.h>\n#include <linux/pagemap.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/mtd/mtd.h>\n#include <linux/mutex.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/major.h>\n\n \n#define BLOCK2MTD_PARAM_MAX_COUNT 3\n\n \nstruct block2mtd_dev {\n\tstruct list_head list;\n\tstruct block_device *blkdev;\n\tstruct mtd_info mtd;\n\tstruct mutex write_mutex;\n};\n\n\n \nstatic LIST_HEAD(blkmtd_device_list);\n\n\nstatic struct page *page_read(struct address_space *mapping, pgoff_t index)\n{\n\treturn read_mapping_page(mapping, index, NULL);\n}\n\n \nstatic int _block2mtd_erase(struct block2mtd_dev *dev, loff_t to, size_t len)\n{\n\tstruct address_space *mapping = dev->blkdev->bd_inode->i_mapping;\n\tstruct page *page;\n\tpgoff_t index = to >> PAGE_SHIFT;\t\n\tint pages = len >> PAGE_SHIFT;\n\tu_long *p;\n\tu_long *max;\n\n\twhile (pages) {\n\t\tpage = page_read(mapping, index);\n\t\tif (IS_ERR(page))\n\t\t\treturn PTR_ERR(page);\n\n\t\tmax = page_address(page) + PAGE_SIZE;\n\t\tfor (p=page_address(page); p<max; p++)\n\t\t\tif (*p != -1UL) {\n\t\t\t\tlock_page(page);\n\t\t\t\tmemset(page_address(page), 0xff, PAGE_SIZE);\n\t\t\t\tset_page_dirty(page);\n\t\t\t\tunlock_page(page);\n\t\t\t\tbalance_dirty_pages_ratelimited(mapping);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\tput_page(page);\n\t\tpages--;\n\t\tindex++;\n\t}\n\treturn 0;\n}\nstatic int block2mtd_erase(struct mtd_info *mtd, struct erase_info *instr)\n{\n\tstruct block2mtd_dev *dev = mtd->priv;\n\tsize_t from = instr->addr;\n\tsize_t len = instr->len;\n\tint err;\n\n\tmutex_lock(&dev->write_mutex);\n\terr = _block2mtd_erase(dev, from, len);\n\tmutex_unlock(&dev->write_mutex);\n\tif (err)\n\t\tpr_err(\"erase failed err = %d\\n\", err);\n\n\treturn err;\n}\n\n\nstatic int block2mtd_read(struct mtd_info *mtd, loff_t from, size_t len,\n\t\tsize_t *retlen, u_char *buf)\n{\n\tstruct block2mtd_dev *dev = mtd->priv;\n\tstruct page *page;\n\tpgoff_t index = from >> PAGE_SHIFT;\n\tint offset = from & (PAGE_SIZE-1);\n\tint cpylen;\n\n\twhile (len) {\n\t\tif ((offset + len) > PAGE_SIZE)\n\t\t\tcpylen = PAGE_SIZE - offset;\t\n\t\telse\n\t\t\tcpylen = len;\t\n\t\tlen = len - cpylen;\n\n\t\tpage = page_read(dev->blkdev->bd_inode->i_mapping, index);\n\t\tif (IS_ERR(page))\n\t\t\treturn PTR_ERR(page);\n\n\t\tmemcpy(buf, page_address(page) + offset, cpylen);\n\t\tput_page(page);\n\n\t\tif (retlen)\n\t\t\t*retlen += cpylen;\n\t\tbuf += cpylen;\n\t\toffset = 0;\n\t\tindex++;\n\t}\n\treturn 0;\n}\n\n\n \nstatic int _block2mtd_write(struct block2mtd_dev *dev, const u_char *buf,\n\t\tloff_t to, size_t len, size_t *retlen)\n{\n\tstruct page *page;\n\tstruct address_space *mapping = dev->blkdev->bd_inode->i_mapping;\n\tpgoff_t index = to >> PAGE_SHIFT;\t\n\tint offset = to & ~PAGE_MASK;\t\n\tint cpylen;\n\n\twhile (len) {\n\t\tif ((offset+len) > PAGE_SIZE)\n\t\t\tcpylen = PAGE_SIZE - offset;\t\n\t\telse\n\t\t\tcpylen = len;\t\t\t\n\t\tlen = len - cpylen;\n\n\t\tpage = page_read(mapping, index);\n\t\tif (IS_ERR(page))\n\t\t\treturn PTR_ERR(page);\n\n\t\tif (memcmp(page_address(page)+offset, buf, cpylen)) {\n\t\t\tlock_page(page);\n\t\t\tmemcpy(page_address(page) + offset, buf, cpylen);\n\t\t\tset_page_dirty(page);\n\t\t\tunlock_page(page);\n\t\t\tbalance_dirty_pages_ratelimited(mapping);\n\t\t}\n\t\tput_page(page);\n\n\t\tif (retlen)\n\t\t\t*retlen += cpylen;\n\n\t\tbuf += cpylen;\n\t\toffset = 0;\n\t\tindex++;\n\t}\n\treturn 0;\n}\n\n\nstatic int block2mtd_write(struct mtd_info *mtd, loff_t to, size_t len,\n\t\tsize_t *retlen, const u_char *buf)\n{\n\tstruct block2mtd_dev *dev = mtd->priv;\n\tint err;\n\n\tmutex_lock(&dev->write_mutex);\n\terr = _block2mtd_write(dev, buf, to, len, retlen);\n\tmutex_unlock(&dev->write_mutex);\n\tif (err > 0)\n\t\terr = 0;\n\treturn err;\n}\n\n\n \nstatic void block2mtd_sync(struct mtd_info *mtd)\n{\n\tstruct block2mtd_dev *dev = mtd->priv;\n\tsync_blockdev(dev->blkdev);\n\treturn;\n}\n\n\nstatic void block2mtd_free_device(struct block2mtd_dev *dev)\n{\n\tif (!dev)\n\t\treturn;\n\n\tkfree(dev->mtd.name);\n\n\tif (dev->blkdev) {\n\t\tinvalidate_mapping_pages(dev->blkdev->bd_inode->i_mapping,\n\t\t\t\t\t0, -1);\n\t\tblkdev_put(dev->blkdev, NULL);\n\t}\n\n\tkfree(dev);\n}\n\n \nstatic struct block_device __ref *mdtblock_early_get_bdev(const char *devname,\n\t\tblk_mode_t mode, int timeout, struct block2mtd_dev *dev)\n{\n\tstruct block_device *bdev = ERR_PTR(-ENODEV);\n#ifndef MODULE\n\tint i;\n\n\t \n\tif (system_state >= SYSTEM_RUNNING)\n\t\treturn bdev;\n\n\t \n\tfor (i = 0; i <= timeout; i++) {\n\t\tdev_t devt;\n\n\t\tif (i)\n\t\t\t \n\t\t\tmsleep(1000);\n\t\twait_for_device_probe();\n\n\t\tif (!early_lookup_bdev(devname, &devt)) {\n\t\t\tbdev = blkdev_get_by_dev(devt, mode, dev, NULL);\n\t\t\tif (!IS_ERR(bdev))\n\t\t\t\tbreak;\n\t\t}\n\t}\n#endif\n\treturn bdev;\n}\n\nstatic struct block2mtd_dev *add_device(char *devname, int erase_size,\n\t\tchar *label, int timeout)\n{\n\tconst blk_mode_t mode = BLK_OPEN_READ | BLK_OPEN_WRITE;\n\tstruct block_device *bdev;\n\tstruct block2mtd_dev *dev;\n\tchar *name;\n\n\tif (!devname)\n\t\treturn NULL;\n\n\tdev = kzalloc(sizeof(struct block2mtd_dev), GFP_KERNEL);\n\tif (!dev)\n\t\treturn NULL;\n\n\t \n\tbdev = blkdev_get_by_path(devname, mode, dev, NULL);\n\tif (IS_ERR(bdev))\n\t\tbdev = mdtblock_early_get_bdev(devname, mode, timeout, dev);\n\tif (IS_ERR(bdev)) {\n\t\tpr_err(\"error: cannot open device %s\\n\", devname);\n\t\tgoto err_free_block2mtd;\n\t}\n\tdev->blkdev = bdev;\n\n\tif (MAJOR(bdev->bd_dev) == MTD_BLOCK_MAJOR) {\n\t\tpr_err(\"attempting to use an MTD device as a block device\\n\");\n\t\tgoto err_free_block2mtd;\n\t}\n\n\tif ((long)dev->blkdev->bd_inode->i_size % erase_size) {\n\t\tpr_err(\"erasesize must be a divisor of device size\\n\");\n\t\tgoto err_free_block2mtd;\n\t}\n\n\tmutex_init(&dev->write_mutex);\n\n\t \n\t \n\tif (!label)\n\t\tname = kasprintf(GFP_KERNEL, \"block2mtd: %s\", devname);\n\telse\n\t\tname = kstrdup(label, GFP_KERNEL);\n\tif (!name)\n\t\tgoto err_destroy_mutex;\n\n\tdev->mtd.name = name;\n\n\tdev->mtd.size = dev->blkdev->bd_inode->i_size & PAGE_MASK;\n\tdev->mtd.erasesize = erase_size;\n\tdev->mtd.writesize = 1;\n\tdev->mtd.writebufsize = PAGE_SIZE;\n\tdev->mtd.type = MTD_RAM;\n\tdev->mtd.flags = MTD_CAP_RAM;\n\tdev->mtd._erase = block2mtd_erase;\n\tdev->mtd._write = block2mtd_write;\n\tdev->mtd._sync = block2mtd_sync;\n\tdev->mtd._read = block2mtd_read;\n\tdev->mtd.priv = dev;\n\tdev->mtd.owner = THIS_MODULE;\n\n\tif (mtd_device_register(&dev->mtd, NULL, 0)) {\n\t\t \n\t\tgoto err_destroy_mutex;\n\t}\n\n\tlist_add(&dev->list, &blkmtd_device_list);\n\tpr_info(\"mtd%d: [%s] erase_size = %dKiB [%d]\\n\",\n\t\tdev->mtd.index,\n\t\tlabel ? label : dev->mtd.name + strlen(\"block2mtd: \"),\n\t\tdev->mtd.erasesize >> 10, dev->mtd.erasesize);\n\treturn dev;\n\nerr_destroy_mutex:\n\tmutex_destroy(&dev->write_mutex);\nerr_free_block2mtd:\n\tblock2mtd_free_device(dev);\n\treturn NULL;\n}\n\n\n \nstatic int ustrtoul(const char *cp, char **endp, unsigned int base)\n{\n\tunsigned long result = simple_strtoul(cp, endp, base);\n\tswitch (**endp) {\n\tcase 'G' :\n\t\tresult *= 1024;\n\t\tfallthrough;\n\tcase 'M':\n\t\tresult *= 1024;\n\t\tfallthrough;\n\tcase 'K':\n\tcase 'k':\n\t\tresult *= 1024;\n\t \n\t\tif ((*endp)[1] == 'i') {\n\t\t\tif ((*endp)[2] == 'B')\n\t\t\t\t(*endp) += 3;\n\t\t\telse\n\t\t\t\t(*endp) += 2;\n\t\t}\n\t}\n\treturn result;\n}\n\n\nstatic int parse_num(size_t *num, const char *token)\n{\n\tchar *endp;\n\tsize_t n;\n\n\tn = (size_t) ustrtoul(token, &endp, 0);\n\tif (*endp)\n\t\treturn -EINVAL;\n\n\t*num = n;\n\treturn 0;\n}\n\n\nstatic inline void kill_final_newline(char *str)\n{\n\tchar *newline = strrchr(str, '\\n');\n\tif (newline && !newline[1])\n\t\t*newline = 0;\n}\n\n\n#ifndef MODULE\nstatic int block2mtd_init_called = 0;\n \nstatic char block2mtd_paramline[80 + 12];\n#endif\n\nstatic int block2mtd_setup2(const char *val)\n{\n\t \n\tchar buf[80 + 12 + 80 + 8];\n\tchar *str = buf;\n\tchar *token[BLOCK2MTD_PARAM_MAX_COUNT];\n\tchar *name;\n\tchar *label = NULL;\n\tsize_t erase_size = PAGE_SIZE;\n\tunsigned long timeout = MTD_DEFAULT_TIMEOUT;\n\tint i, ret;\n\n\tif (strnlen(val, sizeof(buf)) >= sizeof(buf)) {\n\t\tpr_err(\"parameter too long\\n\");\n\t\treturn 0;\n\t}\n\n\tstrcpy(str, val);\n\tkill_final_newline(str);\n\n\tfor (i = 0; i < BLOCK2MTD_PARAM_MAX_COUNT; i++)\n\t\ttoken[i] = strsep(&str, \",\");\n\n\tif (str) {\n\t\tpr_err(\"too many arguments\\n\");\n\t\treturn 0;\n\t}\n\n\tif (!token[0]) {\n\t\tpr_err(\"no argument\\n\");\n\t\treturn 0;\n\t}\n\n\tname = token[0];\n\tif (strlen(name) + 1 > 80) {\n\t\tpr_err(\"device name too long\\n\");\n\t\treturn 0;\n\t}\n\n\t \n\tif (token[1] && strlen(token[1])) {\n\t\tret = parse_num(&erase_size, token[1]);\n\t\tif (ret) {\n\t\t\tpr_err(\"illegal erase size\\n\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (token[2]) {\n\t\tlabel = token[2];\n\t\tpr_info(\"Using custom MTD label '%s' for dev %s\\n\", label, name);\n\t}\n\n\tadd_device(name, erase_size, label, timeout);\n\n\treturn 0;\n}\n\n\nstatic int block2mtd_setup(const char *val, const struct kernel_param *kp)\n{\n#ifdef MODULE\n\treturn block2mtd_setup2(val);\n#else\n\t \n\n\tif (block2mtd_init_called)\n\t\treturn block2mtd_setup2(val);\n\n\t \n\n\tstrscpy(block2mtd_paramline, val, sizeof(block2mtd_paramline));\n\n\treturn 0;\n#endif\n}\n\n\nmodule_param_call(block2mtd, block2mtd_setup, NULL, NULL, 0200);\nMODULE_PARM_DESC(block2mtd, \"Device to use. \\\"block2mtd=<dev>[,[<erasesize>][,<label>]]\\\"\");\n\nstatic int __init block2mtd_init(void)\n{\n\tint ret = 0;\n\n#ifndef MODULE\n\tif (strlen(block2mtd_paramline))\n\t\tret = block2mtd_setup2(block2mtd_paramline);\n\tblock2mtd_init_called = 1;\n#endif\n\n\treturn ret;\n}\n\n\nstatic void block2mtd_exit(void)\n{\n\tstruct list_head *pos, *next;\n\n\t \n\tlist_for_each_safe(pos, next, &blkmtd_device_list) {\n\t\tstruct block2mtd_dev *dev = list_entry(pos, typeof(*dev), list);\n\t\tblock2mtd_sync(&dev->mtd);\n\t\tmtd_device_unregister(&dev->mtd);\n\t\tmutex_destroy(&dev->write_mutex);\n\t\tpr_info(\"mtd%d: [%s] removed\\n\",\n\t\t\tdev->mtd.index,\n\t\t\tdev->mtd.name + strlen(\"block2mtd: \"));\n\t\tlist_del(&dev->list);\n\t\tblock2mtd_free_device(dev);\n\t}\n}\n\nlate_initcall(block2mtd_init);\nmodule_exit(block2mtd_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Joern Engel <joern@lazybastard.org>\");\nMODULE_DESCRIPTION(\"Emulate an MTD using a block device\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}