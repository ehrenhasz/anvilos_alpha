{
  "module_name": "docg3.c",
  "hash_id": "2120b6b91c9bfdb058faf09cf27fef92b2ba5ac55a86608d44808447cf518f27",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/devices/docg3.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/delay.h>\n#include <linux/mtd/mtd.h>\n#include <linux/mtd/partitions.h>\n#include <linux/bitmap.h>\n#include <linux/bitrev.h>\n#include <linux/bch.h>\n\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n\n#define CREATE_TRACE_POINTS\n#include \"docg3.h\"\n\n \n\nstatic unsigned int reliable_mode;\nmodule_param(reliable_mode, uint, 0);\nMODULE_PARM_DESC(reliable_mode, \"Set the docg3 mode (0=normal MLC, 1=fast, \"\n\t\t \"2=reliable) : MLC normal operations are in normal mode\");\n\nstatic int docg3_ooblayout_ecc(struct mtd_info *mtd, int section,\n\t\t\t       struct mtd_oob_region *oobregion)\n{\n\tif (section)\n\t\treturn -ERANGE;\n\n\t \n\toobregion->offset = 7;\n\toobregion->length = 8;\n\n\treturn 0;\n}\n\nstatic int docg3_ooblayout_free(struct mtd_info *mtd, int section,\n\t\t\t\tstruct mtd_oob_region *oobregion)\n{\n\tif (section > 1)\n\t\treturn -ERANGE;\n\n\t \n\tif (!section) {\n\t\toobregion->offset = 0;\n\t\toobregion->length = 7;\n\t} else {\n\t\toobregion->offset = 15;\n\t\toobregion->length = 1;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct mtd_ooblayout_ops nand_ooblayout_docg3_ops = {\n\t.ecc = docg3_ooblayout_ecc,\n\t.free = docg3_ooblayout_free,\n};\n\nstatic inline u8 doc_readb(struct docg3 *docg3, u16 reg)\n{\n\tu8 val = readb(docg3->cascade->base + reg);\n\n\ttrace_docg3_io(0, 8, reg, (int)val);\n\treturn val;\n}\n\nstatic inline u16 doc_readw(struct docg3 *docg3, u16 reg)\n{\n\tu16 val = readw(docg3->cascade->base + reg);\n\n\ttrace_docg3_io(0, 16, reg, (int)val);\n\treturn val;\n}\n\nstatic inline void doc_writeb(struct docg3 *docg3, u8 val, u16 reg)\n{\n\twriteb(val, docg3->cascade->base + reg);\n\ttrace_docg3_io(1, 8, reg, val);\n}\n\nstatic inline void doc_writew(struct docg3 *docg3, u16 val, u16 reg)\n{\n\twritew(val, docg3->cascade->base + reg);\n\ttrace_docg3_io(1, 16, reg, val);\n}\n\nstatic inline void doc_flash_command(struct docg3 *docg3, u8 cmd)\n{\n\tdoc_writeb(docg3, cmd, DOC_FLASHCOMMAND);\n}\n\nstatic inline void doc_flash_sequence(struct docg3 *docg3, u8 seq)\n{\n\tdoc_writeb(docg3, seq, DOC_FLASHSEQUENCE);\n}\n\nstatic inline void doc_flash_address(struct docg3 *docg3, u8 addr)\n{\n\tdoc_writeb(docg3, addr, DOC_FLASHADDRESS);\n}\n\nstatic char const * const part_probes[] = { \"cmdlinepart\", \"saftlpart\", NULL };\n\nstatic int doc_register_readb(struct docg3 *docg3, int reg)\n{\n\tu8 val;\n\n\tdoc_writew(docg3, reg, DOC_READADDRESS);\n\tval = doc_readb(docg3, reg);\n\tdoc_vdbg(\"Read register %04x : %02x\\n\", reg, val);\n\treturn val;\n}\n\nstatic int doc_register_readw(struct docg3 *docg3, int reg)\n{\n\tu16 val;\n\n\tdoc_writew(docg3, reg, DOC_READADDRESS);\n\tval = doc_readw(docg3, reg);\n\tdoc_vdbg(\"Read register %04x : %04x\\n\", reg, val);\n\treturn val;\n}\n\n \nstatic void doc_delay(struct docg3 *docg3, int nbNOPs)\n{\n\tint i;\n\n\tdoc_vdbg(\"NOP x %d\\n\", nbNOPs);\n\tfor (i = 0; i < nbNOPs; i++)\n\t\tdoc_writeb(docg3, 0, DOC_NOP);\n}\n\nstatic int is_prot_seq_error(struct docg3 *docg3)\n{\n\tint ctrl;\n\n\tctrl = doc_register_readb(docg3, DOC_FLASHCONTROL);\n\treturn ctrl & (DOC_CTRL_PROTECTION_ERROR | DOC_CTRL_SEQUENCE_ERROR);\n}\n\nstatic int doc_is_ready(struct docg3 *docg3)\n{\n\tint ctrl;\n\n\tctrl = doc_register_readb(docg3, DOC_FLASHCONTROL);\n\treturn ctrl & DOC_CTRL_FLASHREADY;\n}\n\nstatic int doc_wait_ready(struct docg3 *docg3)\n{\n\tint maxWaitCycles = 100;\n\n\tdo {\n\t\tdoc_delay(docg3, 4);\n\t\tcpu_relax();\n\t} while (!doc_is_ready(docg3) && maxWaitCycles--);\n\tdoc_delay(docg3, 2);\n\tif (maxWaitCycles > 0)\n\t\treturn 0;\n\telse\n\t\treturn -EIO;\n}\n\nstatic int doc_reset_seq(struct docg3 *docg3)\n{\n\tint ret;\n\n\tdoc_writeb(docg3, 0x10, DOC_FLASHCONTROL);\n\tdoc_flash_sequence(docg3, DOC_SEQ_RESET);\n\tdoc_flash_command(docg3, DOC_CMD_RESET);\n\tdoc_delay(docg3, 2);\n\tret = doc_wait_ready(docg3);\n\n\tdoc_dbg(\"doc_reset_seq() -> isReady=%s\\n\", ret ? \"false\" : \"true\");\n\treturn ret;\n}\n\n \nstatic void doc_read_data_area(struct docg3 *docg3, void *buf, int len,\n\t\t\t       int first)\n{\n\tint i, cdr, len4;\n\tu16 data16, *dst16;\n\tu8 data8, *dst8;\n\n\tdoc_dbg(\"doc_read_data_area(buf=%p, len=%d)\\n\", buf, len);\n\tcdr = len & 0x1;\n\tlen4 = len - cdr;\n\n\tif (first)\n\t\tdoc_writew(docg3, DOC_IOSPACE_DATA, DOC_READADDRESS);\n\tdst16 = buf;\n\tfor (i = 0; i < len4; i += 2) {\n\t\tdata16 = doc_readw(docg3, DOC_IOSPACE_DATA);\n\t\tif (dst16) {\n\t\t\t*dst16 = data16;\n\t\t\tdst16++;\n\t\t}\n\t}\n\n\tif (cdr) {\n\t\tdoc_writew(docg3, DOC_IOSPACE_DATA | DOC_READADDR_ONE_BYTE,\n\t\t\t   DOC_READADDRESS);\n\t\tdoc_delay(docg3, 1);\n\t\tdst8 = (u8 *)dst16;\n\t\tfor (i = 0; i < cdr; i++) {\n\t\t\tdata8 = doc_readb(docg3, DOC_IOSPACE_DATA);\n\t\t\tif (dst8) {\n\t\t\t\t*dst8 = data8;\n\t\t\t\tdst8++;\n\t\t\t}\n\t\t}\n\t}\n}\n\n \nstatic void doc_write_data_area(struct docg3 *docg3, const void *buf, int len)\n{\n\tint i, cdr, len4;\n\tu16 *src16;\n\tu8 *src8;\n\n\tdoc_dbg(\"doc_write_data_area(buf=%p, len=%d)\\n\", buf, len);\n\tcdr = len & 0x3;\n\tlen4 = len - cdr;\n\n\tdoc_writew(docg3, DOC_IOSPACE_DATA, DOC_READADDRESS);\n\tsrc16 = (u16 *)buf;\n\tfor (i = 0; i < len4; i += 2) {\n\t\tdoc_writew(docg3, *src16, DOC_IOSPACE_DATA);\n\t\tsrc16++;\n\t}\n\n\tsrc8 = (u8 *)src16;\n\tfor (i = 0; i < cdr; i++) {\n\t\tdoc_writew(docg3, DOC_IOSPACE_DATA | DOC_READADDR_ONE_BYTE,\n\t\t\t   DOC_READADDRESS);\n\t\tdoc_writeb(docg3, *src8, DOC_IOSPACE_DATA);\n\t\tsrc8++;\n\t}\n}\n\n \nstatic void doc_set_reliable_mode(struct docg3 *docg3)\n{\n\tstatic char *strmode[] = { \"normal\", \"fast\", \"reliable\", \"invalid\" };\n\n\tdoc_dbg(\"doc_set_reliable_mode(%s)\\n\", strmode[docg3->reliable]);\n\tswitch (docg3->reliable) {\n\tcase 0:\n\t\tbreak;\n\tcase 1:\n\t\tdoc_flash_sequence(docg3, DOC_SEQ_SET_FASTMODE);\n\t\tdoc_flash_command(docg3, DOC_CMD_FAST_MODE);\n\t\tbreak;\n\tcase 2:\n\t\tdoc_flash_sequence(docg3, DOC_SEQ_SET_RELIABLEMODE);\n\t\tdoc_flash_command(docg3, DOC_CMD_FAST_MODE);\n\t\tdoc_flash_command(docg3, DOC_CMD_RELIABLE_MODE);\n\t\tbreak;\n\tdefault:\n\t\tdoc_err(\"doc_set_reliable_mode(): invalid mode\\n\");\n\t\tbreak;\n\t}\n\tdoc_delay(docg3, 2);\n}\n\n \nstatic void doc_set_asic_mode(struct docg3 *docg3, u8 mode)\n{\n\tint i;\n\n\tfor (i = 0; i < 12; i++)\n\t\tdoc_readb(docg3, DOC_IOSPACE_IPL);\n\n\tmode |= DOC_ASICMODE_MDWREN;\n\tdoc_dbg(\"doc_set_asic_mode(%02x)\\n\", mode);\n\tdoc_writeb(docg3, mode, DOC_ASICMODE);\n\tdoc_writeb(docg3, ~mode, DOC_ASICMODECONFIRM);\n\tdoc_delay(docg3, 1);\n}\n\n \nstatic void doc_set_device_id(struct docg3 *docg3, int id)\n{\n\tu8 ctrl;\n\n\tdoc_dbg(\"doc_set_device_id(%d)\\n\", id);\n\tdoc_writeb(docg3, id, DOC_DEVICESELECT);\n\tctrl = doc_register_readb(docg3, DOC_FLASHCONTROL);\n\n\tctrl &= ~DOC_CTRL_VIOLATION;\n\tctrl |= DOC_CTRL_CE;\n\tdoc_writeb(docg3, ctrl, DOC_FLASHCONTROL);\n}\n\n \nstatic int doc_set_extra_page_mode(struct docg3 *docg3)\n{\n\tint fctrl;\n\n\tdoc_dbg(\"doc_set_extra_page_mode()\\n\");\n\tdoc_flash_sequence(docg3, DOC_SEQ_PAGE_SIZE_532);\n\tdoc_flash_command(docg3, DOC_CMD_PAGE_SIZE_532);\n\tdoc_delay(docg3, 2);\n\n\tfctrl = doc_register_readb(docg3, DOC_FLASHCONTROL);\n\tif (fctrl & (DOC_CTRL_PROTECTION_ERROR | DOC_CTRL_SEQUENCE_ERROR))\n\t\treturn -EIO;\n\telse\n\t\treturn 0;\n}\n\n \nstatic void doc_setup_addr_sector(struct docg3 *docg3, int sector)\n{\n\tdoc_delay(docg3, 1);\n\tdoc_flash_address(docg3, sector & 0xff);\n\tdoc_flash_address(docg3, (sector >> 8) & 0xff);\n\tdoc_flash_address(docg3, (sector >> 16) & 0xff);\n\tdoc_delay(docg3, 1);\n}\n\n \nstatic void doc_setup_writeaddr_sector(struct docg3 *docg3, int sector, int ofs)\n{\n\tofs = ofs >> 2;\n\tdoc_delay(docg3, 1);\n\tdoc_flash_address(docg3, ofs & 0xff);\n\tdoc_flash_address(docg3, sector & 0xff);\n\tdoc_flash_address(docg3, (sector >> 8) & 0xff);\n\tdoc_flash_address(docg3, (sector >> 16) & 0xff);\n\tdoc_delay(docg3, 1);\n}\n\n \nstatic int doc_read_seek(struct docg3 *docg3, int block0, int block1, int page,\n\t\t\t int wear, int ofs)\n{\n\tint sector, ret = 0;\n\n\tdoc_dbg(\"doc_seek(blocks=(%d,%d), page=%d, ofs=%d, wear=%d)\\n\",\n\t\tblock0, block1, page, ofs, wear);\n\n\tif (!wear && (ofs < 2 * DOC_LAYOUT_PAGE_SIZE)) {\n\t\tdoc_flash_sequence(docg3, DOC_SEQ_SET_PLANE1);\n\t\tdoc_flash_command(docg3, DOC_CMD_READ_PLANE1);\n\t\tdoc_delay(docg3, 2);\n\t} else {\n\t\tdoc_flash_sequence(docg3, DOC_SEQ_SET_PLANE2);\n\t\tdoc_flash_command(docg3, DOC_CMD_READ_PLANE2);\n\t\tdoc_delay(docg3, 2);\n\t}\n\n\tdoc_set_reliable_mode(docg3);\n\tif (wear)\n\t\tret = doc_set_extra_page_mode(docg3);\n\tif (ret)\n\t\tgoto out;\n\n\tdoc_flash_sequence(docg3, DOC_SEQ_READ);\n\tsector = (block0 << DOC_ADDR_BLOCK_SHIFT) + (page & DOC_ADDR_PAGE_MASK);\n\tdoc_flash_command(docg3, DOC_CMD_PROG_BLOCK_ADDR);\n\tdoc_setup_addr_sector(docg3, sector);\n\n\tsector = (block1 << DOC_ADDR_BLOCK_SHIFT) + (page & DOC_ADDR_PAGE_MASK);\n\tdoc_flash_command(docg3, DOC_CMD_PROG_BLOCK_ADDR);\n\tdoc_setup_addr_sector(docg3, sector);\n\tdoc_delay(docg3, 1);\n\nout:\n\treturn ret;\n}\n\n \nstatic int doc_write_seek(struct docg3 *docg3, int block0, int block1, int page,\n\t\t\t int ofs)\n{\n\tint ret = 0, sector;\n\n\tdoc_dbg(\"doc_write_seek(blocks=(%d,%d), page=%d, ofs=%d)\\n\",\n\t\tblock0, block1, page, ofs);\n\n\tdoc_set_reliable_mode(docg3);\n\n\tif (ofs < 2 * DOC_LAYOUT_PAGE_SIZE) {\n\t\tdoc_flash_sequence(docg3, DOC_SEQ_SET_PLANE1);\n\t\tdoc_flash_command(docg3, DOC_CMD_READ_PLANE1);\n\t\tdoc_delay(docg3, 2);\n\t} else {\n\t\tdoc_flash_sequence(docg3, DOC_SEQ_SET_PLANE2);\n\t\tdoc_flash_command(docg3, DOC_CMD_READ_PLANE2);\n\t\tdoc_delay(docg3, 2);\n\t}\n\n\tdoc_flash_sequence(docg3, DOC_SEQ_PAGE_SETUP);\n\tdoc_flash_command(docg3, DOC_CMD_PROG_CYCLE1);\n\n\tsector = (block0 << DOC_ADDR_BLOCK_SHIFT) + (page & DOC_ADDR_PAGE_MASK);\n\tdoc_setup_writeaddr_sector(docg3, sector, ofs);\n\n\tdoc_flash_command(docg3, DOC_CMD_PROG_CYCLE3);\n\tdoc_delay(docg3, 2);\n\tret = doc_wait_ready(docg3);\n\tif (ret)\n\t\tgoto out;\n\n\tdoc_flash_command(docg3, DOC_CMD_PROG_CYCLE1);\n\tsector = (block1 << DOC_ADDR_BLOCK_SHIFT) + (page & DOC_ADDR_PAGE_MASK);\n\tdoc_setup_writeaddr_sector(docg3, sector, ofs);\n\tdoc_delay(docg3, 1);\n\nout:\n\treturn ret;\n}\n\n\n \nstatic int doc_read_page_ecc_init(struct docg3 *docg3, int len)\n{\n\tdoc_writew(docg3, DOC_ECCCONF0_READ_MODE\n\t\t   | DOC_ECCCONF0_BCH_ENABLE | DOC_ECCCONF0_HAMMING_ENABLE\n\t\t   | (len & DOC_ECCCONF0_DATA_BYTES_MASK),\n\t\t   DOC_ECCCONF0);\n\tdoc_delay(docg3, 4);\n\tdoc_register_readb(docg3, DOC_FLASHCONTROL);\n\treturn doc_wait_ready(docg3);\n}\n\n \nstatic int doc_write_page_ecc_init(struct docg3 *docg3, int len)\n{\n\tdoc_writew(docg3, DOC_ECCCONF0_WRITE_MODE\n\t\t   | DOC_ECCCONF0_BCH_ENABLE | DOC_ECCCONF0_HAMMING_ENABLE\n\t\t   | (len & DOC_ECCCONF0_DATA_BYTES_MASK),\n\t\t   DOC_ECCCONF0);\n\tdoc_delay(docg3, 4);\n\tdoc_register_readb(docg3, DOC_FLASHCONTROL);\n\treturn doc_wait_ready(docg3);\n}\n\n \nstatic void doc_ecc_disable(struct docg3 *docg3)\n{\n\tdoc_writew(docg3, DOC_ECCCONF0_READ_MODE, DOC_ECCCONF0);\n\tdoc_delay(docg3, 4);\n}\n\n \nstatic void doc_hamming_ecc_init(struct docg3 *docg3, int nb_bytes)\n{\n\tu8 ecc_conf1;\n\n\tecc_conf1 = doc_register_readb(docg3, DOC_ECCCONF1);\n\tecc_conf1 &= ~DOC_ECCCONF1_HAMMING_BITS_MASK;\n\tecc_conf1 |= (nb_bytes & DOC_ECCCONF1_HAMMING_BITS_MASK);\n\tdoc_writeb(docg3, ecc_conf1, DOC_ECCCONF1);\n}\n\n \nstatic int doc_ecc_bch_fix_data(struct docg3 *docg3, void *buf, u8 *hwecc)\n{\n\tu8 ecc[DOC_ECC_BCH_SIZE];\n\tint errorpos[DOC_ECC_BCH_T], i, numerrs;\n\n\tfor (i = 0; i < DOC_ECC_BCH_SIZE; i++)\n\t\tecc[i] = bitrev8(hwecc[i]);\n\tnumerrs = bch_decode(docg3->cascade->bch, NULL,\n\t\t\t     DOC_ECC_BCH_COVERED_BYTES,\n\t\t\t     NULL, ecc, NULL, errorpos);\n\tBUG_ON(numerrs == -EINVAL);\n\tif (numerrs < 0)\n\t\tgoto out;\n\n\tfor (i = 0; i < numerrs; i++)\n\t\terrorpos[i] = (errorpos[i] & ~7) | (7 - (errorpos[i] & 7));\n\tfor (i = 0; i < numerrs; i++)\n\t\tif (errorpos[i] < DOC_ECC_BCH_COVERED_BYTES*8)\n\t\t\t \n\t\t\tchange_bit(errorpos[i], buf);\nout:\n\tdoc_dbg(\"doc_ecc_bch_fix_data: flipped %d bits\\n\", numerrs);\n\treturn numerrs;\n}\n\n\n \nstatic int doc_read_page_prepare(struct docg3 *docg3, int block0, int block1,\n\t\t\t\t int page, int offset)\n{\n\tint wear_area = 0, ret = 0;\n\n\tdoc_dbg(\"doc_read_page_prepare(blocks=(%d,%d), page=%d, ofsInPage=%d)\\n\",\n\t\tblock0, block1, page, offset);\n\tif (offset >= DOC_LAYOUT_WEAR_OFFSET)\n\t\twear_area = 1;\n\tif (!wear_area && offset > (DOC_LAYOUT_PAGE_OOB_SIZE * 2))\n\t\treturn -EINVAL;\n\n\tdoc_set_device_id(docg3, docg3->device_id);\n\tret = doc_reset_seq(docg3);\n\tif (ret)\n\t\tgoto err;\n\n\t \n\tret = doc_read_seek(docg3, block0, block1, page, wear_area, offset);\n\tif (ret)\n\t\tgoto err;\n\n\tdoc_flash_command(docg3, DOC_CMD_READ_ALL_PLANES);\n\tdoc_delay(docg3, 2);\n\tdoc_wait_ready(docg3);\n\n\tdoc_flash_command(docg3, DOC_CMD_SET_ADDR_READ);\n\tdoc_delay(docg3, 1);\n\tif (offset >= DOC_LAYOUT_PAGE_SIZE * 2)\n\t\toffset -= 2 * DOC_LAYOUT_PAGE_SIZE;\n\tdoc_flash_address(docg3, offset >> 2);\n\tdoc_delay(docg3, 1);\n\tdoc_wait_ready(docg3);\n\n\tdoc_flash_command(docg3, DOC_CMD_READ_FLASH);\n\n\treturn 0;\nerr:\n\tdoc_writeb(docg3, 0, DOC_DATAEND);\n\tdoc_delay(docg3, 2);\n\treturn -EIO;\n}\n\n \nstatic int doc_read_page_getbytes(struct docg3 *docg3, int len, u_char *buf,\n\t\t\t\t  int first, int last_odd)\n{\n\tif (last_odd && len > 0) {\n\t\tdoc_read_data_area(docg3, buf, 1, first);\n\t\tdoc_read_data_area(docg3, buf ? buf + 1 : buf, len - 1, 0);\n\t} else {\n\t\tdoc_read_data_area(docg3, buf, len, first);\n\t}\n\tdoc_delay(docg3, 2);\n\treturn len;\n}\n\n \nstatic void doc_write_page_putbytes(struct docg3 *docg3, int len,\n\t\t\t\t    const u_char *buf)\n{\n\tdoc_write_data_area(docg3, buf, len);\n\tdoc_delay(docg3, 2);\n}\n\n \nstatic void doc_get_bch_hw_ecc(struct docg3 *docg3, u8 *hwecc)\n{\n\tint i;\n\n\tfor (i = 0; i < DOC_ECC_BCH_SIZE; i++)\n\t\thwecc[i] = doc_register_readb(docg3, DOC_BCH_HW_ECC(i));\n}\n\n \nstatic void doc_page_finish(struct docg3 *docg3)\n{\n\tdoc_writeb(docg3, 0, DOC_DATAEND);\n\tdoc_delay(docg3, 2);\n}\n\n \nstatic void doc_read_page_finish(struct docg3 *docg3)\n{\n\tdoc_page_finish(docg3);\n\tdoc_set_device_id(docg3, 0);\n}\n\n \nstatic void calc_block_sector(loff_t from, int *block0, int *block1, int *page,\n\t\t\t      int *ofs, int reliable)\n{\n\tuint sector, pages_biblock;\n\n\tpages_biblock = DOC_LAYOUT_PAGES_PER_BLOCK * DOC_LAYOUT_NBPLANES;\n\tif (reliable == 1 || reliable == 2)\n\t\tpages_biblock /= 2;\n\n\tsector = from / DOC_LAYOUT_PAGE_SIZE;\n\t*block0 = sector / pages_biblock * DOC_LAYOUT_NBPLANES;\n\t*block1 = *block0 + 1;\n\t*page = sector % pages_biblock;\n\t*page /= DOC_LAYOUT_NBPLANES;\n\tif (reliable == 1 || reliable == 2)\n\t\t*page *= 2;\n\tif (sector % 2)\n\t\t*ofs = DOC_LAYOUT_PAGE_OOB_SIZE;\n\telse\n\t\t*ofs = 0;\n}\n\n \nstatic int doc_read_oob(struct mtd_info *mtd, loff_t from,\n\t\t\tstruct mtd_oob_ops *ops)\n{\n\tstruct docg3 *docg3 = mtd->priv;\n\tint block0, block1, page, ret, skip, ofs = 0;\n\tu8 *oobbuf = ops->oobbuf;\n\tu8 *buf = ops->datbuf;\n\tsize_t len, ooblen, nbdata, nboob;\n\tu8 hwecc[DOC_ECC_BCH_SIZE], eccconf1;\n\tstruct mtd_ecc_stats old_stats;\n\tint max_bitflips = 0;\n\n\tif (buf)\n\t\tlen = ops->len;\n\telse\n\t\tlen = 0;\n\tif (oobbuf)\n\t\tooblen = ops->ooblen;\n\telse\n\t\tooblen = 0;\n\n\tif (oobbuf && ops->mode == MTD_OPS_PLACE_OOB)\n\t\toobbuf += ops->ooboffs;\n\n\tdoc_dbg(\"doc_read_oob(from=%lld, mode=%d, data=(%p:%zu), oob=(%p:%zu))\\n\",\n\t\tfrom, ops->mode, buf, len, oobbuf, ooblen);\n\tif (ooblen % DOC_LAYOUT_OOB_SIZE)\n\t\treturn -EINVAL;\n\n\tops->oobretlen = 0;\n\tops->retlen = 0;\n\tret = 0;\n\tskip = from % DOC_LAYOUT_PAGE_SIZE;\n\tmutex_lock(&docg3->cascade->lock);\n\told_stats = mtd->ecc_stats;\n\twhile (ret >= 0 && (len > 0 || ooblen > 0)) {\n\t\tcalc_block_sector(from - skip, &block0, &block1, &page, &ofs,\n\t\t\tdocg3->reliable);\n\t\tnbdata = min_t(size_t, len, DOC_LAYOUT_PAGE_SIZE - skip);\n\t\tnboob = min_t(size_t, ooblen, (size_t)DOC_LAYOUT_OOB_SIZE);\n\t\tret = doc_read_page_prepare(docg3, block0, block1, page, ofs);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tret = doc_read_page_ecc_init(docg3, DOC_ECC_BCH_TOTAL_BYTES);\n\t\tif (ret < 0)\n\t\t\tgoto err_in_read;\n\t\tret = doc_read_page_getbytes(docg3, skip, NULL, 1, 0);\n\t\tif (ret < skip)\n\t\t\tgoto err_in_read;\n\t\tret = doc_read_page_getbytes(docg3, nbdata, buf, 0, skip % 2);\n\t\tif (ret < nbdata)\n\t\t\tgoto err_in_read;\n\t\tdoc_read_page_getbytes(docg3,\n\t\t\t\t       DOC_LAYOUT_PAGE_SIZE - nbdata - skip,\n\t\t\t\t       NULL, 0, (skip + nbdata) % 2);\n\t\tret = doc_read_page_getbytes(docg3, nboob, oobbuf, 0, 0);\n\t\tif (ret < nboob)\n\t\t\tgoto err_in_read;\n\t\tdoc_read_page_getbytes(docg3, DOC_LAYOUT_OOB_SIZE - nboob,\n\t\t\t\t       NULL, 0, nboob % 2);\n\n\t\tdoc_get_bch_hw_ecc(docg3, hwecc);\n\t\teccconf1 = doc_register_readb(docg3, DOC_ECCCONF1);\n\n\t\tif (nboob >= DOC_LAYOUT_OOB_SIZE) {\n\t\t\tdoc_dbg(\"OOB - INFO: %*phC\\n\", 7, oobbuf);\n\t\t\tdoc_dbg(\"OOB - HAMMING: %02x\\n\", oobbuf[7]);\n\t\t\tdoc_dbg(\"OOB - BCH_ECC: %*phC\\n\", 7, oobbuf + 8);\n\t\t\tdoc_dbg(\"OOB - UNUSED: %02x\\n\", oobbuf[15]);\n\t\t}\n\t\tdoc_dbg(\"ECC checks: ECCConf1=%x\\n\", eccconf1);\n\t\tdoc_dbg(\"ECC HW_ECC: %*phC\\n\", 7, hwecc);\n\n\t\tret = -EIO;\n\t\tif (is_prot_seq_error(docg3))\n\t\t\tgoto err_in_read;\n\t\tret = 0;\n\t\tif ((block0 >= DOC_LAYOUT_BLOCK_FIRST_DATA) &&\n\t\t    (eccconf1 & DOC_ECCCONF1_BCH_SYNDROM_ERR) &&\n\t\t    (eccconf1 & DOC_ECCCONF1_PAGE_IS_WRITTEN) &&\n\t\t    (ops->mode != MTD_OPS_RAW) &&\n\t\t    (nbdata == DOC_LAYOUT_PAGE_SIZE)) {\n\t\t\tret = doc_ecc_bch_fix_data(docg3, buf, hwecc);\n\t\t\tif (ret < 0) {\n\t\t\t\tmtd->ecc_stats.failed++;\n\t\t\t\tret = -EBADMSG;\n\t\t\t}\n\t\t\tif (ret > 0) {\n\t\t\t\tmtd->ecc_stats.corrected += ret;\n\t\t\t\tmax_bitflips = max(max_bitflips, ret);\n\t\t\t\tret = max_bitflips;\n\t\t\t}\n\t\t}\n\n\t\tdoc_read_page_finish(docg3);\n\t\tops->retlen += nbdata;\n\t\tops->oobretlen += nboob;\n\t\tbuf += nbdata;\n\t\toobbuf += nboob;\n\t\tlen -= nbdata;\n\t\tooblen -= nboob;\n\t\tfrom += DOC_LAYOUT_PAGE_SIZE;\n\t\tskip = 0;\n\t}\n\nout:\n\tif (ops->stats) {\n\t\tops->stats->uncorrectable_errors +=\n\t\t\tmtd->ecc_stats.failed - old_stats.failed;\n\t\tops->stats->corrected_bitflips +=\n\t\t\tmtd->ecc_stats.corrected - old_stats.corrected;\n\t}\n\tmutex_unlock(&docg3->cascade->lock);\n\treturn ret;\nerr_in_read:\n\tdoc_read_page_finish(docg3);\n\tgoto out;\n}\n\nstatic int doc_reload_bbt(struct docg3 *docg3)\n{\n\tint block = DOC_LAYOUT_BLOCK_BBT;\n\tint ret = 0, nbpages, page;\n\tu_char *buf = docg3->bbt;\n\n\tnbpages = DIV_ROUND_UP(docg3->max_block + 1, 8 * DOC_LAYOUT_PAGE_SIZE);\n\tfor (page = 0; !ret && (page < nbpages); page++) {\n\t\tret = doc_read_page_prepare(docg3, block, block + 1,\n\t\t\t\t\t    page + DOC_LAYOUT_PAGE_BBT, 0);\n\t\tif (!ret)\n\t\t\tret = doc_read_page_ecc_init(docg3,\n\t\t\t\t\t\t     DOC_LAYOUT_PAGE_SIZE);\n\t\tif (!ret)\n\t\t\tdoc_read_page_getbytes(docg3, DOC_LAYOUT_PAGE_SIZE,\n\t\t\t\t\t       buf, 1, 0);\n\t\tbuf += DOC_LAYOUT_PAGE_SIZE;\n\t}\n\tdoc_read_page_finish(docg3);\n\treturn ret;\n}\n\n \nstatic int doc_block_isbad(struct mtd_info *mtd, loff_t from)\n{\n\tstruct docg3 *docg3 = mtd->priv;\n\tint block0, block1, page, ofs, is_good;\n\n\tcalc_block_sector(from, &block0, &block1, &page, &ofs,\n\t\tdocg3->reliable);\n\tdoc_dbg(\"doc_block_isbad(from=%lld) => block=(%d,%d), page=%d, ofs=%d\\n\",\n\t\tfrom, block0, block1, page, ofs);\n\n\tif (block0 < DOC_LAYOUT_BLOCK_FIRST_DATA)\n\t\treturn 0;\n\tif (block1 > docg3->max_block)\n\t\treturn -EINVAL;\n\n\tis_good = docg3->bbt[block0 >> 3] & (1 << (block0 & 0x7));\n\treturn !is_good;\n}\n\n#if 0\n \nstatic int doc_get_erase_count(struct docg3 *docg3, loff_t from)\n{\n\tu8 buf[DOC_LAYOUT_WEAR_SIZE];\n\tint ret, plane1_erase_count, plane2_erase_count;\n\tint block0, block1, page, ofs;\n\n\tdoc_dbg(\"doc_get_erase_count(from=%lld, buf=%p)\\n\", from, buf);\n\tif (from % DOC_LAYOUT_PAGE_SIZE)\n\t\treturn -EINVAL;\n\tcalc_block_sector(from, &block0, &block1, &page, &ofs, docg3->reliable);\n\tif (block1 > docg3->max_block)\n\t\treturn -EINVAL;\n\n\tret = doc_reset_seq(docg3);\n\tif (!ret)\n\t\tret = doc_read_page_prepare(docg3, block0, block1, page,\n\t\t\t\t\t    ofs + DOC_LAYOUT_WEAR_OFFSET, 0);\n\tif (!ret)\n\t\tret = doc_read_page_getbytes(docg3, DOC_LAYOUT_WEAR_SIZE,\n\t\t\t\t\t     buf, 1, 0);\n\tdoc_read_page_finish(docg3);\n\n\tif (ret || (buf[0] != DOC_ERASE_MARK) || (buf[2] != DOC_ERASE_MARK))\n\t\treturn -EIO;\n\tplane1_erase_count = (u8)(~buf[1]) | ((u8)(~buf[4]) << 8)\n\t\t| ((u8)(~buf[5]) << 16);\n\tplane2_erase_count = (u8)(~buf[3]) | ((u8)(~buf[6]) << 8)\n\t\t| ((u8)(~buf[7]) << 16);\n\n\treturn max(plane1_erase_count, plane2_erase_count);\n}\n#endif\n\n \nstatic int doc_get_op_status(struct docg3 *docg3)\n{\n\tu8 status;\n\n\tdoc_flash_sequence(docg3, DOC_SEQ_PLANES_STATUS);\n\tdoc_flash_command(docg3, DOC_CMD_PLANES_STATUS);\n\tdoc_delay(docg3, 5);\n\n\tdoc_ecc_disable(docg3);\n\tdoc_read_data_area(docg3, &status, 1, 1);\n\treturn status;\n}\n\n \nstatic int doc_write_erase_wait_status(struct docg3 *docg3)\n{\n\tint i, status, ret = 0;\n\n\tfor (i = 0; !doc_is_ready(docg3) && i < 5; i++)\n\t\tmsleep(20);\n\tif (!doc_is_ready(docg3)) {\n\t\tdoc_dbg(\"Timeout reached and the chip is still not ready\\n\");\n\t\tret = -EAGAIN;\n\t\tgoto out;\n\t}\n\n\tstatus = doc_get_op_status(docg3);\n\tif (status & DOC_PLANES_STATUS_FAIL) {\n\t\tdoc_dbg(\"Erase/Write failed on (a) plane(s), status = %x\\n\",\n\t\t\tstatus);\n\t\tret = -EIO;\n\t}\n\nout:\n\tdoc_page_finish(docg3);\n\treturn ret;\n}\n\n \nstatic int doc_erase_block(struct docg3 *docg3, int block0, int block1)\n{\n\tint ret, sector;\n\n\tdoc_dbg(\"doc_erase_block(blocks=(%d,%d))\\n\", block0, block1);\n\tret = doc_reset_seq(docg3);\n\tif (ret)\n\t\treturn -EIO;\n\n\tdoc_set_reliable_mode(docg3);\n\tdoc_flash_sequence(docg3, DOC_SEQ_ERASE);\n\n\tsector = block0 << DOC_ADDR_BLOCK_SHIFT;\n\tdoc_flash_command(docg3, DOC_CMD_PROG_BLOCK_ADDR);\n\tdoc_setup_addr_sector(docg3, sector);\n\tsector = block1 << DOC_ADDR_BLOCK_SHIFT;\n\tdoc_flash_command(docg3, DOC_CMD_PROG_BLOCK_ADDR);\n\tdoc_setup_addr_sector(docg3, sector);\n\tdoc_delay(docg3, 1);\n\n\tdoc_flash_command(docg3, DOC_CMD_ERASECYCLE2);\n\tdoc_delay(docg3, 2);\n\n\tif (is_prot_seq_error(docg3)) {\n\t\tdoc_err(\"Erase blocks %d,%d error\\n\", block0, block1);\n\t\treturn -EIO;\n\t}\n\n\treturn doc_write_erase_wait_status(docg3);\n}\n\n \nstatic int doc_erase(struct mtd_info *mtd, struct erase_info *info)\n{\n\tstruct docg3 *docg3 = mtd->priv;\n\tuint64_t len;\n\tint block0, block1, page, ret = 0, ofs = 0;\n\n\tdoc_dbg(\"doc_erase(from=%lld, len=%lld\\n\", info->addr, info->len);\n\n\tcalc_block_sector(info->addr + info->len, &block0, &block1, &page,\n\t\t\t  &ofs, docg3->reliable);\n\tif (info->addr + info->len > mtd->size || page || ofs)\n\t\treturn -EINVAL;\n\n\tcalc_block_sector(info->addr, &block0, &block1, &page, &ofs,\n\t\t\t  docg3->reliable);\n\tmutex_lock(&docg3->cascade->lock);\n\tdoc_set_device_id(docg3, docg3->device_id);\n\tdoc_set_reliable_mode(docg3);\n\tfor (len = info->len; !ret && len > 0; len -= mtd->erasesize) {\n\t\tret = doc_erase_block(docg3, block0, block1);\n\t\tblock0 += 2;\n\t\tblock1 += 2;\n\t}\n\tmutex_unlock(&docg3->cascade->lock);\n\n\treturn ret;\n}\n\n \nstatic int doc_write_page(struct docg3 *docg3, loff_t to, const u_char *buf,\n\t\t\t  const u_char *oob, int autoecc)\n{\n\tint block0, block1, page, ret, ofs = 0;\n\tu8 hwecc[DOC_ECC_BCH_SIZE], hamming;\n\n\tdoc_dbg(\"doc_write_page(to=%lld)\\n\", to);\n\tcalc_block_sector(to, &block0, &block1, &page, &ofs, docg3->reliable);\n\n\tdoc_set_device_id(docg3, docg3->device_id);\n\tret = doc_reset_seq(docg3);\n\tif (ret)\n\t\tgoto err;\n\n\t \n\tret = doc_write_seek(docg3, block0, block1, page, ofs);\n\tif (ret)\n\t\tgoto err;\n\n\tdoc_write_page_ecc_init(docg3, DOC_ECC_BCH_TOTAL_BYTES);\n\tdoc_delay(docg3, 2);\n\tdoc_write_page_putbytes(docg3, DOC_LAYOUT_PAGE_SIZE, buf);\n\n\tif (oob && autoecc) {\n\t\tdoc_write_page_putbytes(docg3, DOC_LAYOUT_OOB_PAGEINFO_SZ, oob);\n\t\tdoc_delay(docg3, 2);\n\t\toob += DOC_LAYOUT_OOB_UNUSED_OFS;\n\n\t\thamming = doc_register_readb(docg3, DOC_HAMMINGPARITY);\n\t\tdoc_delay(docg3, 2);\n\t\tdoc_write_page_putbytes(docg3, DOC_LAYOUT_OOB_HAMMING_SZ,\n\t\t\t\t\t&hamming);\n\t\tdoc_delay(docg3, 2);\n\n\t\tdoc_get_bch_hw_ecc(docg3, hwecc);\n\t\tdoc_write_page_putbytes(docg3, DOC_LAYOUT_OOB_BCH_SZ, hwecc);\n\t\tdoc_delay(docg3, 2);\n\n\t\tdoc_write_page_putbytes(docg3, DOC_LAYOUT_OOB_UNUSED_SZ, oob);\n\t}\n\tif (oob && !autoecc)\n\t\tdoc_write_page_putbytes(docg3, DOC_LAYOUT_OOB_SIZE, oob);\n\n\tdoc_delay(docg3, 2);\n\tdoc_page_finish(docg3);\n\tdoc_delay(docg3, 2);\n\tdoc_flash_command(docg3, DOC_CMD_PROG_CYCLE2);\n\tdoc_delay(docg3, 2);\n\n\t \n\tret = doc_write_erase_wait_status(docg3);\n\treturn ret;\nerr:\n\tdoc_read_page_finish(docg3);\n\treturn ret;\n}\n\n \nstatic int doc_guess_autoecc(struct mtd_oob_ops *ops)\n{\n\tint autoecc;\n\n\tswitch (ops->mode) {\n\tcase MTD_OPS_PLACE_OOB:\n\tcase MTD_OPS_AUTO_OOB:\n\t\tautoecc = 1;\n\t\tbreak;\n\tcase MTD_OPS_RAW:\n\t\tautoecc = 0;\n\t\tbreak;\n\tdefault:\n\t\tautoecc = -EINVAL;\n\t}\n\treturn autoecc;\n}\n\n \nstatic void doc_fill_autooob(u8 *dst, u8 *oobsrc)\n{\n\tmemcpy(dst, oobsrc, DOC_LAYOUT_OOB_PAGEINFO_SZ);\n\tdst[DOC_LAYOUT_OOB_UNUSED_OFS] = oobsrc[DOC_LAYOUT_OOB_PAGEINFO_SZ];\n}\n\n \nstatic int doc_backup_oob(struct docg3 *docg3, loff_t to,\n\t\t\t  struct mtd_oob_ops *ops)\n{\n\tint ooblen = ops->ooblen, autoecc;\n\n\tif (ooblen != DOC_LAYOUT_OOB_SIZE)\n\t\treturn -EINVAL;\n\tautoecc = doc_guess_autoecc(ops);\n\tif (autoecc < 0)\n\t\treturn autoecc;\n\n\tdocg3->oob_write_ofs = to;\n\tdocg3->oob_autoecc = autoecc;\n\tif (ops->mode == MTD_OPS_AUTO_OOB) {\n\t\tdoc_fill_autooob(docg3->oob_write_buf, ops->oobbuf);\n\t\tops->oobretlen = 8;\n\t} else {\n\t\tmemcpy(docg3->oob_write_buf, ops->oobbuf, DOC_LAYOUT_OOB_SIZE);\n\t\tops->oobretlen = DOC_LAYOUT_OOB_SIZE;\n\t}\n\treturn 0;\n}\n\n \nstatic int doc_write_oob(struct mtd_info *mtd, loff_t ofs,\n\t\t\t struct mtd_oob_ops *ops)\n{\n\tstruct docg3 *docg3 = mtd->priv;\n\tint ret, autoecc, oobdelta;\n\tu8 *oobbuf = ops->oobbuf;\n\tu8 *buf = ops->datbuf;\n\tsize_t len, ooblen;\n\tu8 oob[DOC_LAYOUT_OOB_SIZE];\n\n\tif (buf)\n\t\tlen = ops->len;\n\telse\n\t\tlen = 0;\n\tif (oobbuf)\n\t\tooblen = ops->ooblen;\n\telse\n\t\tooblen = 0;\n\n\tif (oobbuf && ops->mode == MTD_OPS_PLACE_OOB)\n\t\toobbuf += ops->ooboffs;\n\n\tdoc_dbg(\"doc_write_oob(from=%lld, mode=%d, data=(%p:%zu), oob=(%p:%zu))\\n\",\n\t\tofs, ops->mode, buf, len, oobbuf, ooblen);\n\tswitch (ops->mode) {\n\tcase MTD_OPS_PLACE_OOB:\n\tcase MTD_OPS_RAW:\n\t\toobdelta = mtd->oobsize;\n\t\tbreak;\n\tcase MTD_OPS_AUTO_OOB:\n\t\toobdelta = mtd->oobavail;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tif ((len % DOC_LAYOUT_PAGE_SIZE) || (ooblen % oobdelta) ||\n\t    (ofs % DOC_LAYOUT_PAGE_SIZE))\n\t\treturn -EINVAL;\n\tif (len && ooblen &&\n\t    (len / DOC_LAYOUT_PAGE_SIZE) != (ooblen / oobdelta))\n\t\treturn -EINVAL;\n\n\tops->oobretlen = 0;\n\tops->retlen = 0;\n\tret = 0;\n\tif (len == 0 && ooblen == 0)\n\t\treturn -EINVAL;\n\tif (len == 0 && ooblen > 0)\n\t\treturn doc_backup_oob(docg3, ofs, ops);\n\n\tautoecc = doc_guess_autoecc(ops);\n\tif (autoecc < 0)\n\t\treturn autoecc;\n\n\tmutex_lock(&docg3->cascade->lock);\n\twhile (!ret && len > 0) {\n\t\tmemset(oob, 0, sizeof(oob));\n\t\tif (ofs == docg3->oob_write_ofs)\n\t\t\tmemcpy(oob, docg3->oob_write_buf, DOC_LAYOUT_OOB_SIZE);\n\t\telse if (ooblen > 0 && ops->mode == MTD_OPS_AUTO_OOB)\n\t\t\tdoc_fill_autooob(oob, oobbuf);\n\t\telse if (ooblen > 0)\n\t\t\tmemcpy(oob, oobbuf, DOC_LAYOUT_OOB_SIZE);\n\t\tret = doc_write_page(docg3, ofs, buf, oob, autoecc);\n\n\t\tofs += DOC_LAYOUT_PAGE_SIZE;\n\t\tlen -= DOC_LAYOUT_PAGE_SIZE;\n\t\tbuf += DOC_LAYOUT_PAGE_SIZE;\n\t\tif (ooblen) {\n\t\t\toobbuf += oobdelta;\n\t\t\tooblen -= oobdelta;\n\t\t\tops->oobretlen += oobdelta;\n\t\t}\n\t\tops->retlen += DOC_LAYOUT_PAGE_SIZE;\n\t}\n\n\tdoc_set_device_id(docg3, 0);\n\tmutex_unlock(&docg3->cascade->lock);\n\treturn ret;\n}\n\nstatic struct docg3 *sysfs_dev2docg3(struct device *dev,\n\t\t\t\t     struct device_attribute *attr)\n{\n\tint floor;\n\tstruct mtd_info **docg3_floors = dev_get_drvdata(dev);\n\n\tfloor = attr->attr.name[1] - '0';\n\tif (floor < 0 || floor >= DOC_MAX_NBFLOORS)\n\t\treturn NULL;\n\telse\n\t\treturn docg3_floors[floor]->priv;\n}\n\nstatic ssize_t dps0_is_key_locked(struct device *dev,\n\t\t\t\t  struct device_attribute *attr, char *buf)\n{\n\tstruct docg3 *docg3 = sysfs_dev2docg3(dev, attr);\n\tint dps0;\n\n\tmutex_lock(&docg3->cascade->lock);\n\tdoc_set_device_id(docg3, docg3->device_id);\n\tdps0 = doc_register_readb(docg3, DOC_DPS0_STATUS);\n\tdoc_set_device_id(docg3, 0);\n\tmutex_unlock(&docg3->cascade->lock);\n\n\treturn sprintf(buf, \"%d\\n\", !(dps0 & DOC_DPS_KEY_OK));\n}\n\nstatic ssize_t dps1_is_key_locked(struct device *dev,\n\t\t\t\t  struct device_attribute *attr, char *buf)\n{\n\tstruct docg3 *docg3 = sysfs_dev2docg3(dev, attr);\n\tint dps1;\n\n\tmutex_lock(&docg3->cascade->lock);\n\tdoc_set_device_id(docg3, docg3->device_id);\n\tdps1 = doc_register_readb(docg3, DOC_DPS1_STATUS);\n\tdoc_set_device_id(docg3, 0);\n\tmutex_unlock(&docg3->cascade->lock);\n\n\treturn sprintf(buf, \"%d\\n\", !(dps1 & DOC_DPS_KEY_OK));\n}\n\nstatic ssize_t dps0_insert_key(struct device *dev,\n\t\t\t       struct device_attribute *attr,\n\t\t\t       const char *buf, size_t count)\n{\n\tstruct docg3 *docg3 = sysfs_dev2docg3(dev, attr);\n\tint i;\n\n\tif (count != DOC_LAYOUT_DPS_KEY_LENGTH)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&docg3->cascade->lock);\n\tdoc_set_device_id(docg3, docg3->device_id);\n\tfor (i = 0; i < DOC_LAYOUT_DPS_KEY_LENGTH; i++)\n\t\tdoc_writeb(docg3, buf[i], DOC_DPS0_KEY);\n\tdoc_set_device_id(docg3, 0);\n\tmutex_unlock(&docg3->cascade->lock);\n\treturn count;\n}\n\nstatic ssize_t dps1_insert_key(struct device *dev,\n\t\t\t       struct device_attribute *attr,\n\t\t\t       const char *buf, size_t count)\n{\n\tstruct docg3 *docg3 = sysfs_dev2docg3(dev, attr);\n\tint i;\n\n\tif (count != DOC_LAYOUT_DPS_KEY_LENGTH)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&docg3->cascade->lock);\n\tdoc_set_device_id(docg3, docg3->device_id);\n\tfor (i = 0; i < DOC_LAYOUT_DPS_KEY_LENGTH; i++)\n\t\tdoc_writeb(docg3, buf[i], DOC_DPS1_KEY);\n\tdoc_set_device_id(docg3, 0);\n\tmutex_unlock(&docg3->cascade->lock);\n\treturn count;\n}\n\n#define FLOOR_SYSFS(id) { \\\n\t__ATTR(f##id##_dps0_is_keylocked, S_IRUGO, dps0_is_key_locked, NULL), \\\n\t__ATTR(f##id##_dps1_is_keylocked, S_IRUGO, dps1_is_key_locked, NULL), \\\n\t__ATTR(f##id##_dps0_protection_key, S_IWUSR|S_IWGRP, NULL, dps0_insert_key), \\\n\t__ATTR(f##id##_dps1_protection_key, S_IWUSR|S_IWGRP, NULL, dps1_insert_key), \\\n}\n\nstatic struct device_attribute doc_sys_attrs[DOC_MAX_NBFLOORS][4] = {\n\tFLOOR_SYSFS(0), FLOOR_SYSFS(1), FLOOR_SYSFS(2), FLOOR_SYSFS(3)\n};\n\nstatic int doc_register_sysfs(struct platform_device *pdev,\n\t\t\t      struct docg3_cascade *cascade)\n{\n\tstruct device *dev = &pdev->dev;\n\tint floor;\n\tint ret;\n\tint i;\n\n\tfor (floor = 0;\n\t     floor < DOC_MAX_NBFLOORS && cascade->floors[floor];\n\t     floor++) {\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tret = device_create_file(dev, &doc_sys_attrs[floor][i]);\n\t\t\tif (ret)\n\t\t\t\tgoto remove_files;\n\t\t}\n\t}\n\n\treturn 0;\n\nremove_files:\n\tdo {\n\t\twhile (--i >= 0)\n\t\t\tdevice_remove_file(dev, &doc_sys_attrs[floor][i]);\n\t\ti = 4;\n\t} while (--floor >= 0);\n\n\treturn ret;\n}\n\nstatic void doc_unregister_sysfs(struct platform_device *pdev,\n\t\t\t\t struct docg3_cascade *cascade)\n{\n\tstruct device *dev = &pdev->dev;\n\tint floor, i;\n\n\tfor (floor = 0; floor < DOC_MAX_NBFLOORS && cascade->floors[floor];\n\t     floor++)\n\t\tfor (i = 0; i < 4; i++)\n\t\t\tdevice_remove_file(dev, &doc_sys_attrs[floor][i]);\n}\n\n \nstatic int flashcontrol_show(struct seq_file *s, void *p)\n{\n\tstruct docg3 *docg3 = s->private;\n\n\tu8 fctrl;\n\n\tmutex_lock(&docg3->cascade->lock);\n\tfctrl = doc_register_readb(docg3, DOC_FLASHCONTROL);\n\tmutex_unlock(&docg3->cascade->lock);\n\n\tseq_printf(s, \"FlashControl : 0x%02x (%s,CE# %s,%s,%s,flash %s)\\n\",\n\t\t   fctrl,\n\t\t   fctrl & DOC_CTRL_VIOLATION ? \"protocol violation\" : \"-\",\n\t\t   fctrl & DOC_CTRL_CE ? \"active\" : \"inactive\",\n\t\t   fctrl & DOC_CTRL_PROTECTION_ERROR ? \"protection error\" : \"-\",\n\t\t   fctrl & DOC_CTRL_SEQUENCE_ERROR ? \"sequence error\" : \"-\",\n\t\t   fctrl & DOC_CTRL_FLASHREADY ? \"ready\" : \"not ready\");\n\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(flashcontrol);\n\nstatic int asic_mode_show(struct seq_file *s, void *p)\n{\n\tstruct docg3 *docg3 = s->private;\n\n\tint pctrl, mode;\n\n\tmutex_lock(&docg3->cascade->lock);\n\tpctrl = doc_register_readb(docg3, DOC_ASICMODE);\n\tmode = pctrl & 0x03;\n\tmutex_unlock(&docg3->cascade->lock);\n\n\tseq_printf(s,\n\t\t   \"%04x : RAM_WE=%d,RSTIN_RESET=%d,BDETCT_RESET=%d,WRITE_ENABLE=%d,POWERDOWN=%d,MODE=%d%d (\",\n\t\t   pctrl,\n\t\t   pctrl & DOC_ASICMODE_RAM_WE ? 1 : 0,\n\t\t   pctrl & DOC_ASICMODE_RSTIN_RESET ? 1 : 0,\n\t\t   pctrl & DOC_ASICMODE_BDETCT_RESET ? 1 : 0,\n\t\t   pctrl & DOC_ASICMODE_MDWREN ? 1 : 0,\n\t\t   pctrl & DOC_ASICMODE_POWERDOWN ? 1 : 0,\n\t\t   mode >> 1, mode & 0x1);\n\n\tswitch (mode) {\n\tcase DOC_ASICMODE_RESET:\n\t\tseq_puts(s, \"reset\");\n\t\tbreak;\n\tcase DOC_ASICMODE_NORMAL:\n\t\tseq_puts(s, \"normal\");\n\t\tbreak;\n\tcase DOC_ASICMODE_POWERDOWN:\n\t\tseq_puts(s, \"powerdown\");\n\t\tbreak;\n\t}\n\tseq_puts(s, \")\\n\");\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(asic_mode);\n\nstatic int device_id_show(struct seq_file *s, void *p)\n{\n\tstruct docg3 *docg3 = s->private;\n\tint id;\n\n\tmutex_lock(&docg3->cascade->lock);\n\tid = doc_register_readb(docg3, DOC_DEVICESELECT);\n\tmutex_unlock(&docg3->cascade->lock);\n\n\tseq_printf(s, \"DeviceId = %d\\n\", id);\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(device_id);\n\nstatic int protection_show(struct seq_file *s, void *p)\n{\n\tstruct docg3 *docg3 = s->private;\n\tint protect, dps0, dps0_low, dps0_high, dps1, dps1_low, dps1_high;\n\n\tmutex_lock(&docg3->cascade->lock);\n\tprotect = doc_register_readb(docg3, DOC_PROTECTION);\n\tdps0 = doc_register_readb(docg3, DOC_DPS0_STATUS);\n\tdps0_low = doc_register_readw(docg3, DOC_DPS0_ADDRLOW);\n\tdps0_high = doc_register_readw(docg3, DOC_DPS0_ADDRHIGH);\n\tdps1 = doc_register_readb(docg3, DOC_DPS1_STATUS);\n\tdps1_low = doc_register_readw(docg3, DOC_DPS1_ADDRLOW);\n\tdps1_high = doc_register_readw(docg3, DOC_DPS1_ADDRHIGH);\n\tmutex_unlock(&docg3->cascade->lock);\n\n\tseq_printf(s, \"Protection = 0x%02x (\", protect);\n\tif (protect & DOC_PROTECT_FOUNDRY_OTP_LOCK)\n\t\tseq_puts(s, \"FOUNDRY_OTP_LOCK,\");\n\tif (protect & DOC_PROTECT_CUSTOMER_OTP_LOCK)\n\t\tseq_puts(s, \"CUSTOMER_OTP_LOCK,\");\n\tif (protect & DOC_PROTECT_LOCK_INPUT)\n\t\tseq_puts(s, \"LOCK_INPUT,\");\n\tif (protect & DOC_PROTECT_STICKY_LOCK)\n\t\tseq_puts(s, \"STICKY_LOCK,\");\n\tif (protect & DOC_PROTECT_PROTECTION_ENABLED)\n\t\tseq_puts(s, \"PROTECTION ON,\");\n\tif (protect & DOC_PROTECT_IPL_DOWNLOAD_LOCK)\n\t\tseq_puts(s, \"IPL_DOWNLOAD_LOCK,\");\n\tif (protect & DOC_PROTECT_PROTECTION_ERROR)\n\t\tseq_puts(s, \"PROTECT_ERR,\");\n\telse\n\t\tseq_puts(s, \"NO_PROTECT_ERR\");\n\tseq_puts(s, \")\\n\");\n\n\tseq_printf(s, \"DPS0 = 0x%02x : Protected area [0x%x - 0x%x] : OTP=%d, READ=%d, WRITE=%d, HW_LOCK=%d, KEY_OK=%d\\n\",\n\t\t   dps0, dps0_low, dps0_high,\n\t\t   !!(dps0 & DOC_DPS_OTP_PROTECTED),\n\t\t   !!(dps0 & DOC_DPS_READ_PROTECTED),\n\t\t   !!(dps0 & DOC_DPS_WRITE_PROTECTED),\n\t\t   !!(dps0 & DOC_DPS_HW_LOCK_ENABLED),\n\t\t   !!(dps0 & DOC_DPS_KEY_OK));\n\tseq_printf(s, \"DPS1 = 0x%02x : Protected area [0x%x - 0x%x] : OTP=%d, READ=%d, WRITE=%d, HW_LOCK=%d, KEY_OK=%d\\n\",\n\t\t   dps1, dps1_low, dps1_high,\n\t\t   !!(dps1 & DOC_DPS_OTP_PROTECTED),\n\t\t   !!(dps1 & DOC_DPS_READ_PROTECTED),\n\t\t   !!(dps1 & DOC_DPS_WRITE_PROTECTED),\n\t\t   !!(dps1 & DOC_DPS_HW_LOCK_ENABLED),\n\t\t   !!(dps1 & DOC_DPS_KEY_OK));\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(protection);\n\nstatic void __init doc_dbg_register(struct mtd_info *floor)\n{\n\tstruct dentry *root = floor->dbg.dfs_dir;\n\tstruct docg3 *docg3 = floor->priv;\n\n\tif (IS_ERR_OR_NULL(root)) {\n\t\tif (IS_ENABLED(CONFIG_DEBUG_FS) &&\n\t\t    !IS_ENABLED(CONFIG_MTD_PARTITIONED_MASTER))\n\t\t\tdev_warn(floor->dev.parent,\n\t\t\t\t \"CONFIG_MTD_PARTITIONED_MASTER must be enabled to expose debugfs stuff\\n\");\n\t\treturn;\n\t}\n\n\tdebugfs_create_file(\"docg3_flashcontrol\", S_IRUSR, root, docg3,\n\t\t\t    &flashcontrol_fops);\n\tdebugfs_create_file(\"docg3_asic_mode\", S_IRUSR, root, docg3,\n\t\t\t    &asic_mode_fops);\n\tdebugfs_create_file(\"docg3_device_id\", S_IRUSR, root, docg3,\n\t\t\t    &device_id_fops);\n\tdebugfs_create_file(\"docg3_protection\", S_IRUSR, root, docg3,\n\t\t\t    &protection_fops);\n}\n\n \nstatic int __init doc_set_driver_info(int chip_id, struct mtd_info *mtd)\n{\n\tstruct docg3 *docg3 = mtd->priv;\n\tint cfg;\n\n\tcfg = doc_register_readb(docg3, DOC_CONFIGURATION);\n\tdocg3->if_cfg = (cfg & DOC_CONF_IF_CFG ? 1 : 0);\n\tdocg3->reliable = reliable_mode;\n\n\tswitch (chip_id) {\n\tcase DOC_CHIPID_G3:\n\t\tmtd->name = devm_kasprintf(docg3->dev, GFP_KERNEL, \"docg3.%d\",\n\t\t\t\t\t   docg3->device_id);\n\t\tif (!mtd->name)\n\t\t\treturn -ENOMEM;\n\t\tdocg3->max_block = 2047;\n\t\tbreak;\n\t}\n\tmtd->type = MTD_NANDFLASH;\n\tmtd->flags = MTD_CAP_NANDFLASH;\n\tmtd->size = (docg3->max_block + 1) * DOC_LAYOUT_BLOCK_SIZE;\n\tif (docg3->reliable == 2)\n\t\tmtd->size /= 2;\n\tmtd->erasesize = DOC_LAYOUT_BLOCK_SIZE * DOC_LAYOUT_NBPLANES;\n\tif (docg3->reliable == 2)\n\t\tmtd->erasesize /= 2;\n\tmtd->writebufsize = mtd->writesize = DOC_LAYOUT_PAGE_SIZE;\n\tmtd->oobsize = DOC_LAYOUT_OOB_SIZE;\n\tmtd->_erase = doc_erase;\n\tmtd->_read_oob = doc_read_oob;\n\tmtd->_write_oob = doc_write_oob;\n\tmtd->_block_isbad = doc_block_isbad;\n\tmtd_set_ooblayout(mtd, &nand_ooblayout_docg3_ops);\n\tmtd->oobavail = 8;\n\tmtd->ecc_strength = DOC_ECC_BCH_T;\n\n\treturn 0;\n}\n\n \nstatic struct mtd_info * __init\ndoc_probe_device(struct docg3_cascade *cascade, int floor, struct device *dev)\n{\n\tint ret, bbt_nbpages;\n\tu16 chip_id, chip_id_inv;\n\tstruct docg3 *docg3;\n\tstruct mtd_info *mtd;\n\n\tret = -ENOMEM;\n\tdocg3 = kzalloc(sizeof(struct docg3), GFP_KERNEL);\n\tif (!docg3)\n\t\tgoto nomem1;\n\tmtd = kzalloc(sizeof(struct mtd_info), GFP_KERNEL);\n\tif (!mtd)\n\t\tgoto nomem2;\n\tmtd->priv = docg3;\n\tmtd->dev.parent = dev;\n\tbbt_nbpages = DIV_ROUND_UP(docg3->max_block + 1,\n\t\t\t\t   8 * DOC_LAYOUT_PAGE_SIZE);\n\tdocg3->bbt = kcalloc(DOC_LAYOUT_PAGE_SIZE, bbt_nbpages, GFP_KERNEL);\n\tif (!docg3->bbt)\n\t\tgoto nomem3;\n\n\tdocg3->dev = dev;\n\tdocg3->device_id = floor;\n\tdocg3->cascade = cascade;\n\tdoc_set_device_id(docg3, docg3->device_id);\n\tif (!floor)\n\t\tdoc_set_asic_mode(docg3, DOC_ASICMODE_RESET);\n\tdoc_set_asic_mode(docg3, DOC_ASICMODE_NORMAL);\n\n\tchip_id = doc_register_readw(docg3, DOC_CHIPID);\n\tchip_id_inv = doc_register_readw(docg3, DOC_CHIPID_INV);\n\n\tret = 0;\n\tif (chip_id != (u16)(~chip_id_inv)) {\n\t\tgoto nomem4;\n\t}\n\n\tswitch (chip_id) {\n\tcase DOC_CHIPID_G3:\n\t\tdoc_info(\"Found a G3 DiskOnChip at addr %p, floor %d\\n\",\n\t\t\t docg3->cascade->base, floor);\n\t\tbreak;\n\tdefault:\n\t\tdoc_err(\"Chip id %04x is not a DiskOnChip G3 chip\\n\", chip_id);\n\t\tgoto nomem4;\n\t}\n\n\tret = doc_set_driver_info(chip_id, mtd);\n\tif (ret)\n\t\tgoto nomem4;\n\n\tdoc_hamming_ecc_init(docg3, DOC_LAYOUT_OOB_PAGEINFO_SZ);\n\tdoc_reload_bbt(docg3);\n\treturn mtd;\n\nnomem4:\n\tkfree(docg3->bbt);\nnomem3:\n\tkfree(mtd);\nnomem2:\n\tkfree(docg3);\nnomem1:\n\treturn ret ? ERR_PTR(ret) : NULL;\n}\n\n \nstatic void doc_release_device(struct mtd_info *mtd)\n{\n\tstruct docg3 *docg3 = mtd->priv;\n\n\tmtd_device_unregister(mtd);\n\tkfree(docg3->bbt);\n\tkfree(docg3);\n\tkfree(mtd);\n}\n\n \nstatic int docg3_resume(struct platform_device *pdev)\n{\n\tint i;\n\tstruct docg3_cascade *cascade;\n\tstruct mtd_info **docg3_floors, *mtd;\n\tstruct docg3 *docg3;\n\n\tcascade = platform_get_drvdata(pdev);\n\tdocg3_floors = cascade->floors;\n\tmtd = docg3_floors[0];\n\tdocg3 = mtd->priv;\n\n\tdoc_dbg(\"docg3_resume()\\n\");\n\tfor (i = 0; i < 12; i++)\n\t\tdoc_readb(docg3, DOC_IOSPACE_IPL);\n\treturn 0;\n}\n\n \nstatic int docg3_suspend(struct platform_device *pdev, pm_message_t state)\n{\n\tint floor, i;\n\tstruct docg3_cascade *cascade;\n\tstruct mtd_info **docg3_floors, *mtd;\n\tstruct docg3 *docg3;\n\tu8 ctrl, pwr_down;\n\n\tcascade = platform_get_drvdata(pdev);\n\tdocg3_floors = cascade->floors;\n\tfor (floor = 0; floor < DOC_MAX_NBFLOORS; floor++) {\n\t\tmtd = docg3_floors[floor];\n\t\tif (!mtd)\n\t\t\tcontinue;\n\t\tdocg3 = mtd->priv;\n\n\t\tdoc_writeb(docg3, floor, DOC_DEVICESELECT);\n\t\tctrl = doc_register_readb(docg3, DOC_FLASHCONTROL);\n\t\tctrl &= ~DOC_CTRL_VIOLATION & ~DOC_CTRL_CE;\n\t\tdoc_writeb(docg3, ctrl, DOC_FLASHCONTROL);\n\n\t\tfor (i = 0; i < 10; i++) {\n\t\t\tusleep_range(3000, 4000);\n\t\t\tpwr_down = doc_register_readb(docg3, DOC_POWERMODE);\n\t\t\tif (pwr_down & DOC_POWERDOWN_READY)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (pwr_down & DOC_POWERDOWN_READY) {\n\t\t\tdoc_dbg(\"docg3_suspend(): floor %d powerdown ok\\n\",\n\t\t\t\tfloor);\n\t\t} else {\n\t\t\tdoc_err(\"docg3_suspend(): floor %d powerdown failed\\n\",\n\t\t\t\tfloor);\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\tmtd = docg3_floors[0];\n\tdocg3 = mtd->priv;\n\tdoc_set_asic_mode(docg3, DOC_ASICMODE_POWERDOWN);\n\treturn 0;\n}\n\n \nstatic int __init docg3_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct mtd_info *mtd;\n\tstruct resource *ress;\n\tvoid __iomem *base;\n\tint ret, floor;\n\tstruct docg3_cascade *cascade;\n\n\tret = -ENXIO;\n\tress = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!ress) {\n\t\tdev_err(dev, \"No I/O memory resource defined\\n\");\n\t\treturn ret;\n\t}\n\n\tret = -ENOMEM;\n\tbase = devm_ioremap(dev, ress->start, DOC_IOSPACE_SIZE);\n\tif (!base) {\n\t\tdev_err(dev, \"devm_ioremap dev failed\\n\");\n\t\treturn ret;\n\t}\n\n\tcascade = devm_kcalloc(dev, DOC_MAX_NBFLOORS, sizeof(*cascade),\n\t\t\t       GFP_KERNEL);\n\tif (!cascade)\n\t\treturn ret;\n\tcascade->base = base;\n\tmutex_init(&cascade->lock);\n\tcascade->bch = bch_init(DOC_ECC_BCH_M, DOC_ECC_BCH_T,\n\t\t\t\tDOC_ECC_BCH_PRIMPOLY, false);\n\tif (!cascade->bch)\n\t\treturn ret;\n\n\tfor (floor = 0; floor < DOC_MAX_NBFLOORS; floor++) {\n\t\tmtd = doc_probe_device(cascade, floor, dev);\n\t\tif (IS_ERR(mtd)) {\n\t\t\tret = PTR_ERR(mtd);\n\t\t\tgoto err_probe;\n\t\t}\n\t\tif (!mtd) {\n\t\t\tif (floor == 0)\n\t\t\t\tgoto notfound;\n\t\t\telse\n\t\t\t\tcontinue;\n\t\t}\n\t\tcascade->floors[floor] = mtd;\n\t\tret = mtd_device_parse_register(mtd, part_probes, NULL, NULL,\n\t\t\t\t\t\t0);\n\t\tif (ret)\n\t\t\tgoto err_probe;\n\n\t\tdoc_dbg_register(cascade->floors[floor]);\n\t}\n\n\tret = doc_register_sysfs(pdev, cascade);\n\tif (ret)\n\t\tgoto err_probe;\n\n\tplatform_set_drvdata(pdev, cascade);\n\treturn 0;\n\nnotfound:\n\tret = -ENODEV;\n\tdev_info(dev, \"No supported DiskOnChip found\\n\");\nerr_probe:\n\tbch_free(cascade->bch);\n\tfor (floor = 0; floor < DOC_MAX_NBFLOORS; floor++)\n\t\tif (cascade->floors[floor])\n\t\t\tdoc_release_device(cascade->floors[floor]);\n\treturn ret;\n}\n\n \nstatic int docg3_release(struct platform_device *pdev)\n{\n\tstruct docg3_cascade *cascade = platform_get_drvdata(pdev);\n\tstruct docg3 *docg3 = cascade->floors[0]->priv;\n\tint floor;\n\n\tdoc_unregister_sysfs(pdev, cascade);\n\tfor (floor = 0; floor < DOC_MAX_NBFLOORS; floor++)\n\t\tif (cascade->floors[floor])\n\t\t\tdoc_release_device(cascade->floors[floor]);\n\n\tbch_free(docg3->cascade->bch);\n\treturn 0;\n}\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id docg3_dt_ids[] = {\n\t{ .compatible = \"m-systems,diskonchip-g3\" },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, docg3_dt_ids);\n#endif\n\nstatic struct platform_driver g3_driver = {\n\t.driver\t\t= {\n\t\t.name\t= \"docg3\",\n\t\t.of_match_table = of_match_ptr(docg3_dt_ids),\n\t},\n\t.suspend\t= docg3_suspend,\n\t.resume\t\t= docg3_resume,\n\t.remove\t\t= docg3_release,\n};\n\nmodule_platform_driver_probe(g3_driver, docg3_probe);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Robert Jarzmik <robert.jarzmik@free.fr>\");\nMODULE_DESCRIPTION(\"MTD driver for DiskOnChip G3\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}