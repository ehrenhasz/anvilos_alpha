{
  "module_name": "bcm47xxsflash.c",
  "hash_id": "9e465acca65c9ac7a219f75c9ddbf28b40737df670d74742e0c2cb96ea9e3417",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/devices/bcm47xxsflash.c",
  "human_readable_source": "\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/mtd/mtd.h>\n#include <linux/platform_device.h>\n#include <linux/bcma/bcma.h>\n\n#include \"bcm47xxsflash.h\"\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"Serial flash driver for BCMA bus\");\n\nstatic const char * const probes[] = { \"bcm47xxpart\", NULL };\n\n \n\nstatic void bcm47xxsflash_cmd(struct bcm47xxsflash *b47s, u32 opcode)\n{\n\tint i;\n\n\tb47s->cc_write(b47s, BCMA_CC_FLASHCTL, BCMA_CC_FLASHCTL_START | opcode);\n\tfor (i = 0; i < 1000; i++) {\n\t\tif (!(b47s->cc_read(b47s, BCMA_CC_FLASHCTL) &\n\t\t      BCMA_CC_FLASHCTL_BUSY))\n\t\t\treturn;\n\t\tcpu_relax();\n\t}\n\tpr_err(\"Control command failed (timeout)!\\n\");\n}\n\nstatic int bcm47xxsflash_poll(struct bcm47xxsflash *b47s, int timeout)\n{\n\tunsigned long deadline = jiffies + timeout;\n\n\tdo {\n\t\tswitch (b47s->type) {\n\t\tcase BCM47XXSFLASH_TYPE_ST:\n\t\t\tbcm47xxsflash_cmd(b47s, OPCODE_ST_RDSR);\n\t\t\tif (!(b47s->cc_read(b47s, BCMA_CC_FLASHDATA) &\n\t\t\t      SR_ST_WIP))\n\t\t\t\treturn 0;\n\t\t\tbreak;\n\t\tcase BCM47XXSFLASH_TYPE_ATMEL:\n\t\t\tbcm47xxsflash_cmd(b47s, OPCODE_AT_STATUS);\n\t\t\tif (b47s->cc_read(b47s, BCMA_CC_FLASHDATA) &\n\t\t\t    SR_AT_READY)\n\t\t\t\treturn 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tcpu_relax();\n\t\tudelay(1);\n\t} while (!time_after_eq(jiffies, deadline));\n\n\tpr_err(\"Timeout waiting for flash to be ready!\\n\");\n\n\treturn -EBUSY;\n}\n\n \n\nstatic int bcm47xxsflash_erase(struct mtd_info *mtd, struct erase_info *erase)\n{\n\tstruct bcm47xxsflash *b47s = mtd->priv;\n\n\tswitch (b47s->type) {\n\tcase BCM47XXSFLASH_TYPE_ST:\n\t\tbcm47xxsflash_cmd(b47s, OPCODE_ST_WREN);\n\t\tb47s->cc_write(b47s, BCMA_CC_FLASHADDR, erase->addr);\n\t\t \n\t\tif (b47s->blocksize < (64 * 1024))\n\t\t\tbcm47xxsflash_cmd(b47s, OPCODE_ST_SSE);\n\t\telse\n\t\t\tbcm47xxsflash_cmd(b47s, OPCODE_ST_SE);\n\t\tbreak;\n\tcase BCM47XXSFLASH_TYPE_ATMEL:\n\t\tb47s->cc_write(b47s, BCMA_CC_FLASHADDR, erase->addr << 1);\n\t\tbcm47xxsflash_cmd(b47s, OPCODE_AT_PAGE_ERASE);\n\t\tbreak;\n\t}\n\n\treturn bcm47xxsflash_poll(b47s, HZ);\n}\n\nstatic int bcm47xxsflash_read(struct mtd_info *mtd, loff_t from, size_t len,\n\t\t\t      size_t *retlen, u_char *buf)\n{\n\tstruct bcm47xxsflash *b47s = mtd->priv;\n\tsize_t orig_len = len;\n\n\t \n\tif ((from + len) > mtd->size)\n\t\treturn -EINVAL;\n\n\t \n\tif (from < BCM47XXSFLASH_WINDOW_SZ) {\n\t\tsize_t memcpy_len;\n\n\t\tmemcpy_len = min(len, (size_t)(BCM47XXSFLASH_WINDOW_SZ - from));\n\t\tmemcpy_fromio(buf, b47s->window + from, memcpy_len);\n\t\tfrom += memcpy_len;\n\t\tlen -= memcpy_len;\n\t\tbuf += memcpy_len;\n\t}\n\n\t \n\tfor (; len; len--) {\n\t\tb47s->cc_write(b47s, BCMA_CC_FLASHADDR, from++);\n\t\tbcm47xxsflash_cmd(b47s, OPCODE_ST_READ4B);\n\t\t*buf++ = b47s->cc_read(b47s, BCMA_CC_FLASHDATA);\n\t}\n\n\t*retlen = orig_len;\n\n\treturn orig_len;\n}\n\nstatic int bcm47xxsflash_write_st(struct mtd_info *mtd, u32 offset, size_t len,\n\t\t\t\t  const u_char *buf)\n{\n\tstruct bcm47xxsflash *b47s = mtd->priv;\n\tint written = 0;\n\n\t \n\tbcm47xxsflash_cmd(b47s, OPCODE_ST_WREN);\n\n\t \n\tb47s->cc_write(b47s, BCMA_CC_FLASHADDR, offset);\n\tb47s->cc_write(b47s, BCMA_CC_FLASHDATA, *buf++);\n\n\t \n\tif (b47s->bcma_cc->core->id.rev < 20) {\n\t\tbcm47xxsflash_cmd(b47s, OPCODE_ST_PP);\n\t\treturn 1;  \n\t}\n\n\t \n\tbcm47xxsflash_cmd(b47s, OPCODE_ST_CSA | OPCODE_ST_PP);\n\toffset++;\n\tlen--;\n\twritten++;\n\n\twhile (len > 0) {\n\t\t \n\t\tif ((offset & 0xFF) == 0)\n\t\t\tbreak;\n\n\t\tbcm47xxsflash_cmd(b47s, OPCODE_ST_CSA | *buf++);\n\t\toffset++;\n\t\tlen--;\n\t\twritten++;\n\t}\n\n\t \n\tb47s->cc_write(b47s, BCMA_CC_FLASHCTL, 0);\n\tudelay(1);\n\tif (bcm47xxsflash_poll(b47s, HZ / 10))\n\t\tpr_err(\"Flash rejected dropping CSA\\n\");\n\n\treturn written;\n}\n\nstatic int bcm47xxsflash_write_at(struct mtd_info *mtd, u32 offset, size_t len,\n\t\t\t\t  const u_char *buf)\n{\n\tstruct bcm47xxsflash *b47s = mtd->priv;\n\tu32 mask = b47s->blocksize - 1;\n\tu32 page = (offset & ~mask) << 1;\n\tu32 byte = offset & mask;\n\tint written = 0;\n\n\t \n\tif (byte || (len < b47s->blocksize)) {\n\t\tint err;\n\n\t\tb47s->cc_write(b47s, BCMA_CC_FLASHADDR, page);\n\t\tbcm47xxsflash_cmd(b47s, OPCODE_AT_BUF1_LOAD);\n\t\t \n\t\terr = bcm47xxsflash_poll(b47s, HZ / 1000);\n\t\tif (err) {\n\t\t\tpr_err(\"Timeout reading page 0x%X info buffer\\n\", page);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\t \n\twhile (len > 0) {\n\t\t \n\t\tif (byte == b47s->blocksize)\n\t\t\tbreak;\n\n\t\tb47s->cc_write(b47s, BCMA_CC_FLASHADDR, byte++);\n\t\tb47s->cc_write(b47s, BCMA_CC_FLASHDATA, *buf++);\n\t\tbcm47xxsflash_cmd(b47s, OPCODE_AT_BUF1_WRITE);\n\t\tlen--;\n\t\twritten++;\n\t}\n\n\t \n\tb47s->cc_write(b47s, BCMA_CC_FLASHADDR, page);\n\tbcm47xxsflash_cmd(b47s, OPCODE_AT_BUF1_PROGRAM);\n\n\treturn written;\n}\n\nstatic int bcm47xxsflash_write(struct mtd_info *mtd, loff_t to, size_t len,\n\t\t\t       size_t *retlen, const u_char *buf)\n{\n\tstruct bcm47xxsflash *b47s = mtd->priv;\n\tint written;\n\n\t \n\twhile (len > 0) {\n\t\tswitch (b47s->type) {\n\t\tcase BCM47XXSFLASH_TYPE_ST:\n\t\t\twritten = bcm47xxsflash_write_st(mtd, to, len, buf);\n\t\t\tbreak;\n\t\tcase BCM47XXSFLASH_TYPE_ATMEL:\n\t\t\twritten = bcm47xxsflash_write_at(mtd, to, len, buf);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tBUG_ON(1);\n\t\t}\n\t\tif (written < 0) {\n\t\t\tpr_err(\"Error writing at offset 0x%llX\\n\", to);\n\t\t\treturn written;\n\t\t}\n\t\tto += (loff_t)written;\n\t\tlen -= written;\n\t\t*retlen += written;\n\t\tbuf += written;\n\t}\n\n\treturn 0;\n}\n\nstatic void bcm47xxsflash_fill_mtd(struct bcm47xxsflash *b47s,\n\t\t\t\t   struct device *dev)\n{\n\tstruct mtd_info *mtd = &b47s->mtd;\n\n\tmtd->priv = b47s;\n\tmtd->dev.parent = dev;\n\tmtd->name = \"bcm47xxsflash\";\n\n\tmtd->type = MTD_NORFLASH;\n\tmtd->flags = MTD_CAP_NORFLASH;\n\tmtd->size = b47s->size;\n\tmtd->erasesize = b47s->blocksize;\n\tmtd->writesize = 1;\n\tmtd->writebufsize = 1;\n\n\tmtd->_erase = bcm47xxsflash_erase;\n\tmtd->_read = bcm47xxsflash_read;\n\tmtd->_write = bcm47xxsflash_write;\n}\n\n \n\nstatic int bcm47xxsflash_bcma_cc_read(struct bcm47xxsflash *b47s, u16 offset)\n{\n\treturn bcma_cc_read32(b47s->bcma_cc, offset);\n}\n\nstatic void bcm47xxsflash_bcma_cc_write(struct bcm47xxsflash *b47s, u16 offset,\n\t\t\t\t\tu32 value)\n{\n\tbcma_cc_write32(b47s->bcma_cc, offset, value);\n}\n\nstatic int bcm47xxsflash_bcma_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct bcma_sflash *sflash = dev_get_platdata(dev);\n\tstruct bcm47xxsflash *b47s;\n\tstruct resource *res;\n\tint err;\n\n\tb47s = devm_kzalloc(dev, sizeof(*b47s), GFP_KERNEL);\n\tif (!b47s)\n\t\treturn -ENOMEM;\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!res) {\n\t\tdev_err(dev, \"invalid resource\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (!devm_request_mem_region(dev, res->start, resource_size(res),\n\t\t\t\t     res->name)) {\n\t\tdev_err(dev, \"can't request region for resource %pR\\n\", res);\n\t\treturn -EBUSY;\n\t}\n\n\tb47s->bcma_cc = container_of(sflash, struct bcma_drv_cc, sflash);\n\tb47s->cc_read = bcm47xxsflash_bcma_cc_read;\n\tb47s->cc_write = bcm47xxsflash_bcma_cc_write;\n\n\t \n\tif (b47s->bcma_cc->core->id.rev == 54)\n\t\tb47s->window = ioremap(res->start, resource_size(res));\n\telse\n\t\tb47s->window = ioremap_cache(res->start, resource_size(res));\n\tif (!b47s->window) {\n\t\tdev_err(dev, \"ioremap failed for resource %pR\\n\", res);\n\t\treturn -ENOMEM;\n\t}\n\n\tswitch (b47s->bcma_cc->capabilities & BCMA_CC_CAP_FLASHT) {\n\tcase BCMA_CC_FLASHT_STSER:\n\t\tb47s->type = BCM47XXSFLASH_TYPE_ST;\n\t\tbreak;\n\tcase BCMA_CC_FLASHT_ATSER:\n\t\tb47s->type = BCM47XXSFLASH_TYPE_ATMEL;\n\t\tbreak;\n\t}\n\n\tb47s->blocksize = sflash->blocksize;\n\tb47s->numblocks = sflash->numblocks;\n\tb47s->size = sflash->size;\n\tbcm47xxsflash_fill_mtd(b47s, &pdev->dev);\n\n\tplatform_set_drvdata(pdev, b47s);\n\n\terr = mtd_device_parse_register(&b47s->mtd, probes, NULL, NULL, 0);\n\tif (err) {\n\t\tpr_err(\"Failed to register MTD device: %d\\n\", err);\n\t\tiounmap(b47s->window);\n\t\treturn err;\n\t}\n\n\tif (bcm47xxsflash_poll(b47s, HZ / 10))\n\t\tpr_warn(\"Serial flash busy\\n\");\n\n\treturn 0;\n}\n\nstatic int bcm47xxsflash_bcma_remove(struct platform_device *pdev)\n{\n\tstruct bcm47xxsflash *b47s = platform_get_drvdata(pdev);\n\n\tmtd_device_unregister(&b47s->mtd);\n\tiounmap(b47s->window);\n\n\treturn 0;\n}\n\nstatic struct platform_driver bcma_sflash_driver = {\n\t.probe\t= bcm47xxsflash_bcma_probe,\n\t.remove = bcm47xxsflash_bcma_remove,\n\t.driver = {\n\t\t.name = \"bcma_sflash\",\n\t},\n};\n\n \n\nmodule_platform_driver(bcma_sflash_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}