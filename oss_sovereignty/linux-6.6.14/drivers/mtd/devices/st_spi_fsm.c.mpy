{
  "module_name": "st_spi_fsm.c",
  "hash_id": "5f44be6bd7318b47c16dc666b5db25e6dbca1a0ff4036407d8524639683dabb1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/devices/st_spi_fsm.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/regmap.h>\n#include <linux/platform_device.h>\n#include <linux/mfd/syscon.h>\n#include <linux/mtd/mtd.h>\n#include <linux/mtd/partitions.h>\n#include <linux/mtd/spi-nor.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/io.h>\n#include <linux/of.h>\n#include <linux/clk.h>\n\n#include \"serial_flash_cmds.h\"\n\n \n#define SPI_CLOCKDIV\t\t\t0x0010\n#define SPI_MODESELECT\t\t\t0x0018\n#define SPI_CONFIGDATA\t\t\t0x0020\n#define SPI_STA_MODE_CHANGE\t\t0x0028\n#define SPI_FAST_SEQ_TRANSFER_SIZE\t0x0100\n#define SPI_FAST_SEQ_ADD1\t\t0x0104\n#define SPI_FAST_SEQ_ADD2\t\t0x0108\n#define SPI_FAST_SEQ_ADD_CFG\t\t0x010c\n#define SPI_FAST_SEQ_OPC1\t\t0x0110\n#define SPI_FAST_SEQ_OPC2\t\t0x0114\n#define SPI_FAST_SEQ_OPC3\t\t0x0118\n#define SPI_FAST_SEQ_OPC4\t\t0x011c\n#define SPI_FAST_SEQ_OPC5\t\t0x0120\n#define SPI_MODE_BITS\t\t\t0x0124\n#define SPI_DUMMY_BITS\t\t\t0x0128\n#define SPI_FAST_SEQ_FLASH_STA_DATA\t0x012c\n#define SPI_FAST_SEQ_1\t\t\t0x0130\n#define SPI_FAST_SEQ_2\t\t\t0x0134\n#define SPI_FAST_SEQ_3\t\t\t0x0138\n#define SPI_FAST_SEQ_4\t\t\t0x013c\n#define SPI_FAST_SEQ_CFG\t\t0x0140\n#define SPI_FAST_SEQ_STA\t\t0x0144\n#define SPI_QUAD_BOOT_SEQ_INIT_1\t0x0148\n#define SPI_QUAD_BOOT_SEQ_INIT_2\t0x014c\n#define SPI_QUAD_BOOT_READ_SEQ_1\t0x0150\n#define SPI_QUAD_BOOT_READ_SEQ_2\t0x0154\n#define SPI_PROGRAM_ERASE_TIME\t\t0x0158\n#define SPI_MULT_PAGE_REPEAT_SEQ_1\t0x015c\n#define SPI_MULT_PAGE_REPEAT_SEQ_2\t0x0160\n#define SPI_STATUS_WR_TIME_REG\t\t0x0164\n#define SPI_FAST_SEQ_DATA_REG\t\t0x0300\n\n \n#define SPI_MODESELECT_CONTIG\t\t0x01\n#define SPI_MODESELECT_FASTREAD\t\t0x02\n#define SPI_MODESELECT_DUALIO\t\t0x04\n#define SPI_MODESELECT_FSM\t\t0x08\n#define SPI_MODESELECT_QUADBOOT\t\t0x10\n\n \n#define SPI_CFG_DEVICE_ST\t\t0x1\n#define SPI_CFG_DEVICE_ATMEL\t\t0x4\n#define SPI_CFG_MIN_CS_HIGH(x)\t\t(((x) & 0xfff) << 4)\n#define SPI_CFG_CS_SETUPHOLD(x)\t\t(((x) & 0xff) << 16)\n#define SPI_CFG_DATA_HOLD(x)\t\t(((x) & 0xff) << 24)\n\n#define SPI_CFG_DEFAULT_MIN_CS_HIGH    SPI_CFG_MIN_CS_HIGH(0x0AA)\n#define SPI_CFG_DEFAULT_CS_SETUPHOLD   SPI_CFG_CS_SETUPHOLD(0xA0)\n#define SPI_CFG_DEFAULT_DATA_HOLD      SPI_CFG_DATA_HOLD(0x00)\n\n \n#define TRANSFER_SIZE(x)\t\t((x) * 8)\n\n \n#define ADR_CFG_CYCLES_ADD1(x)\t\t((x) << 0)\n#define ADR_CFG_PADS_1_ADD1\t\t(0x0 << 6)\n#define ADR_CFG_PADS_2_ADD1\t\t(0x1 << 6)\n#define ADR_CFG_PADS_4_ADD1\t\t(0x3 << 6)\n#define ADR_CFG_CSDEASSERT_ADD1\t\t(1   << 8)\n#define ADR_CFG_CYCLES_ADD2(x)\t\t((x) << (0+16))\n#define ADR_CFG_PADS_1_ADD2\t\t(0x0 << (6+16))\n#define ADR_CFG_PADS_2_ADD2\t\t(0x1 << (6+16))\n#define ADR_CFG_PADS_4_ADD2\t\t(0x3 << (6+16))\n#define ADR_CFG_CSDEASSERT_ADD2\t\t(1   << (8+16))\n\n \n#define SEQ_OPC_OPCODE(x)\t\t((x) << 0)\n#define SEQ_OPC_CYCLES(x)\t\t((x) << 8)\n#define SEQ_OPC_PADS_1\t\t\t(0x0 << 14)\n#define SEQ_OPC_PADS_2\t\t\t(0x1 << 14)\n#define SEQ_OPC_PADS_4\t\t\t(0x3 << 14)\n#define SEQ_OPC_CSDEASSERT\t\t(1   << 16)\n\n \n#define SEQ_CFG_STARTSEQ\t\t(1 << 0)\n#define SEQ_CFG_SWRESET\t\t\t(1 << 5)\n#define SEQ_CFG_CSDEASSERT\t\t(1 << 6)\n#define SEQ_CFG_READNOTWRITE\t\t(1 << 7)\n#define SEQ_CFG_ERASE\t\t\t(1 << 8)\n#define SEQ_CFG_PADS_1\t\t\t(0x0 << 16)\n#define SEQ_CFG_PADS_2\t\t\t(0x1 << 16)\n#define SEQ_CFG_PADS_4\t\t\t(0x3 << 16)\n\n \n#define MODE_DATA(x)\t\t\t(x & 0xff)\n#define MODE_CYCLES(x)\t\t\t((x & 0x3f) << 16)\n#define MODE_PADS_1\t\t\t(0x0 << 22)\n#define MODE_PADS_2\t\t\t(0x1 << 22)\n#define MODE_PADS_4\t\t\t(0x3 << 22)\n#define DUMMY_CSDEASSERT\t\t(1   << 24)\n\n \n#define DUMMY_CYCLES(x)\t\t\t((x & 0x3f) << 16)\n#define DUMMY_PADS_1\t\t\t(0x0 << 22)\n#define DUMMY_PADS_2\t\t\t(0x1 << 22)\n#define DUMMY_PADS_4\t\t\t(0x3 << 22)\n#define DUMMY_CSDEASSERT\t\t(1   << 24)\n\n \n#define STA_DATA_BYTE1(x)\t\t((x & 0xff) << 0)\n#define STA_DATA_BYTE2(x)\t\t((x & 0xff) << 8)\n#define STA_PADS_1\t\t\t(0x0 << 16)\n#define STA_PADS_2\t\t\t(0x1 << 16)\n#define STA_PADS_4\t\t\t(0x3 << 16)\n#define STA_CSDEASSERT\t\t\t(0x1 << 20)\n#define STA_RDNOTWR\t\t\t(0x1 << 21)\n\n \n#define STFSM_OPC_CMD\t\t\t0x1\n#define STFSM_OPC_ADD\t\t\t0x2\n#define STFSM_OPC_STA\t\t\t0x3\n#define STFSM_OPC_MODE\t\t\t0x4\n#define STFSM_OPC_DUMMY\t\t0x5\n#define STFSM_OPC_DATA\t\t\t0x6\n#define STFSM_OPC_WAIT\t\t\t0x7\n#define STFSM_OPC_JUMP\t\t\t0x8\n#define STFSM_OPC_GOTO\t\t\t0x9\n#define STFSM_OPC_STOP\t\t\t0xF\n\n \n#define STFSM_INSTR(cmd, op)\t\t((cmd) | ((op) << 4))\n\n#define STFSM_INST_CMD1\t\t\tSTFSM_INSTR(STFSM_OPC_CMD,\t1)\n#define STFSM_INST_CMD2\t\t\tSTFSM_INSTR(STFSM_OPC_CMD,\t2)\n#define STFSM_INST_CMD3\t\t\tSTFSM_INSTR(STFSM_OPC_CMD,\t3)\n#define STFSM_INST_CMD4\t\t\tSTFSM_INSTR(STFSM_OPC_CMD,\t4)\n#define STFSM_INST_CMD5\t\t\tSTFSM_INSTR(STFSM_OPC_CMD,\t5)\n#define STFSM_INST_ADD1\t\t\tSTFSM_INSTR(STFSM_OPC_ADD,\t1)\n#define STFSM_INST_ADD2\t\t\tSTFSM_INSTR(STFSM_OPC_ADD,\t2)\n\n#define STFSM_INST_DATA_WRITE\t\tSTFSM_INSTR(STFSM_OPC_DATA,\t1)\n#define STFSM_INST_DATA_READ\t\tSTFSM_INSTR(STFSM_OPC_DATA,\t2)\n\n#define STFSM_INST_STA_RD1\t\tSTFSM_INSTR(STFSM_OPC_STA,\t0x1)\n#define STFSM_INST_STA_WR1\t\tSTFSM_INSTR(STFSM_OPC_STA,\t0x1)\n#define STFSM_INST_STA_RD2\t\tSTFSM_INSTR(STFSM_OPC_STA,\t0x2)\n#define STFSM_INST_STA_WR1_2\t\tSTFSM_INSTR(STFSM_OPC_STA,\t0x3)\n\n#define STFSM_INST_MODE\t\t\tSTFSM_INSTR(STFSM_OPC_MODE,\t0)\n#define STFSM_INST_DUMMY\t\tSTFSM_INSTR(STFSM_OPC_DUMMY,\t0)\n#define STFSM_INST_WAIT\t\t\tSTFSM_INSTR(STFSM_OPC_WAIT,\t0)\n#define STFSM_INST_STOP\t\t\tSTFSM_INSTR(STFSM_OPC_STOP,\t0)\n\n#define STFSM_DEFAULT_EMI_FREQ 100000000UL                         \n#define STFSM_DEFAULT_WR_TIME  (STFSM_DEFAULT_EMI_FREQ * (15/1000))  \n\n#define STFSM_FLASH_SAFE_FREQ  10000000UL                          \n\n#define STFSM_MAX_WAIT_SEQ_MS  1000      \n\n \n#define S25FL_CMD_WRITE4_1_1_4 0x34\n#define S25FL_CMD_SE4          0xdc\n#define S25FL_CMD_CLSR         0x30\n#define S25FL_CMD_DYBWR                0xe1\n#define S25FL_CMD_DYBRD                0xe0\n#define S25FL_CMD_WRITE4       0x12     \n\n \n#define FLASH_STATUS_BUSY      0x01\n#define FLASH_STATUS_WEL       0x02\n#define FLASH_STATUS_BP0       0x04\n#define FLASH_STATUS_BP1       0x08\n#define FLASH_STATUS_BP2       0x10\n#define FLASH_STATUS_SRWP0     0x80\n#define FLASH_STATUS_TIMEOUT   0xff\n \n#define S25FL_STATUS_E_ERR     0x20\n#define S25FL_STATUS_P_ERR     0x40\n\n#define N25Q_CMD_WRVCR         0x81\n#define N25Q_CMD_RDVCR         0x85\n#define N25Q_CMD_RDVECR        0x65\n#define N25Q_CMD_RDNVCR        0xb5\n#define N25Q_CMD_WRNVCR        0xb1\n\n#define FLASH_PAGESIZE         256\t\t\t \n#define FLASH_PAGESIZE_32      (FLASH_PAGESIZE / 4)\t \n#define FLASH_MAX_BUSY_WAIT    (300 * HZ)\t \n\n \n#define CFG_READ_TOGGLE_32BIT_ADDR     0x00000001\n#define CFG_WRITE_TOGGLE_32BIT_ADDR    0x00000002\n#define CFG_ERASESEC_TOGGLE_32BIT_ADDR 0x00000008\n#define CFG_S25FL_CHECK_ERROR_FLAGS    0x00000010\n\nstruct stfsm_seq {\n\tuint32_t data_size;\n\tuint32_t addr1;\n\tuint32_t addr2;\n\tuint32_t addr_cfg;\n\tuint32_t seq_opc[5];\n\tuint32_t mode;\n\tuint32_t dummy;\n\tuint32_t status;\n\tuint8_t  seq[16];\n\tuint32_t seq_cfg;\n} __packed __aligned(4);\n\nstruct stfsm {\n\tstruct device\t\t*dev;\n\tvoid __iomem\t\t*base;\n\tstruct mtd_info\t\tmtd;\n\tstruct mutex\t\tlock;\n\tstruct flash_info       *info;\n\tstruct clk              *clk;\n\n\tuint32_t                configuration;\n\tuint32_t                fifo_dir_delay;\n\tbool                    booted_from_spi;\n\tbool                    reset_signal;\n\tbool                    reset_por;\n\n\tstruct stfsm_seq stfsm_seq_read;\n\tstruct stfsm_seq stfsm_seq_write;\n\tstruct stfsm_seq stfsm_seq_en_32bit_addr;\n};\n\n \nstruct seq_rw_config {\n\tuint32_t        flags;           \n\tuint8_t         cmd;             \n\tint             write;           \n\tuint8_t         addr_pads;       \n\tuint8_t         data_pads;       \n\tuint8_t         mode_data;       \n\tuint8_t         mode_cycles;     \n\tuint8_t         dummy_cycles;    \n};\n\n \nstruct flash_info {\n\tchar            *name;\n\t \n\tu32             jedec_id;\n\tu16             ext_id;\n\t \n\tunsigned        sector_size;\n\tu16             n_sectors;\n\tu32             flags;\n\t \n\tu32             max_freq;\n\tint             (*config)(struct stfsm *);\n};\n\nstatic int stfsm_n25q_config(struct stfsm *fsm);\nstatic int stfsm_mx25_config(struct stfsm *fsm);\nstatic int stfsm_s25fl_config(struct stfsm *fsm);\nstatic int stfsm_w25q_config(struct stfsm *fsm);\n\nstatic struct flash_info flash_types[] = {\n\t \n#define M25P_FLAG (FLASH_FLAG_READ_WRITE | FLASH_FLAG_READ_FAST)\n\t{ \"m25p40\",  0x202013, 0,  64 * 1024,   8, M25P_FLAG, 25, NULL },\n\t{ \"m25p80\",  0x202014, 0,  64 * 1024,  16, M25P_FLAG, 25, NULL },\n\t{ \"m25p16\",  0x202015, 0,  64 * 1024,  32, M25P_FLAG, 25, NULL },\n\t{ \"m25p32\",  0x202016, 0,  64 * 1024,  64, M25P_FLAG, 50, NULL },\n\t{ \"m25p64\",  0x202017, 0,  64 * 1024, 128, M25P_FLAG, 50, NULL },\n\t{ \"m25p128\", 0x202018, 0, 256 * 1024,  64, M25P_FLAG, 50, NULL },\n\n#define M25PX_FLAG (FLASH_FLAG_READ_WRITE      |\t\\\n\t\t    FLASH_FLAG_READ_FAST        |\t\\\n\t\t    FLASH_FLAG_READ_1_1_2       |\t\\\n\t\t    FLASH_FLAG_WRITE_1_1_2)\n\t{ \"m25px32\", 0x207116, 0,  64 * 1024,  64, M25PX_FLAG, 75, NULL },\n\t{ \"m25px64\", 0x207117, 0,  64 * 1024, 128, M25PX_FLAG, 75, NULL },\n\n\t \n#define MX25_FLAG (FLASH_FLAG_READ_WRITE       |\t\\\n\t\t   FLASH_FLAG_READ_FAST         |\t\\\n\t\t   FLASH_FLAG_READ_1_1_2        |\t\\\n\t\t   FLASH_FLAG_READ_1_2_2        |\t\\\n\t\t   FLASH_FLAG_READ_1_1_4        |\t\\\n\t\t   FLASH_FLAG_SE_4K             |\t\\\n\t\t   FLASH_FLAG_SE_32K)\n\t{ \"mx25l3255e\",  0xc29e16, 0, 64 * 1024, 64,\n\t  (MX25_FLAG | FLASH_FLAG_WRITE_1_4_4), 86,\n\t  stfsm_mx25_config},\n\t{ \"mx25l25635e\", 0xc22019, 0, 64*1024, 512,\n\t  (MX25_FLAG | FLASH_FLAG_32BIT_ADDR | FLASH_FLAG_RESET), 70,\n\t  stfsm_mx25_config },\n\t{ \"mx25l25655e\", 0xc22619, 0, 64*1024, 512,\n\t  (MX25_FLAG | FLASH_FLAG_32BIT_ADDR | FLASH_FLAG_RESET), 70,\n\t  stfsm_mx25_config},\n\n#define N25Q_FLAG (FLASH_FLAG_READ_WRITE       |\t\\\n\t\t   FLASH_FLAG_READ_FAST         |\t\\\n\t\t   FLASH_FLAG_READ_1_1_2        |\t\\\n\t\t   FLASH_FLAG_READ_1_2_2        |\t\\\n\t\t   FLASH_FLAG_READ_1_1_4        |\t\\\n\t\t   FLASH_FLAG_READ_1_4_4        |\t\\\n\t\t   FLASH_FLAG_WRITE_1_1_2       |\t\\\n\t\t   FLASH_FLAG_WRITE_1_2_2       |\t\\\n\t\t   FLASH_FLAG_WRITE_1_1_4       |\t\\\n\t\t   FLASH_FLAG_WRITE_1_4_4)\n\t{ \"n25q128\", 0x20ba18, 0, 64 * 1024,  256, N25Q_FLAG, 108,\n\t  stfsm_n25q_config },\n\t{ \"n25q256\", 0x20ba19, 0, 64 * 1024,  512,\n\t  N25Q_FLAG | FLASH_FLAG_32BIT_ADDR, 108, stfsm_n25q_config },\n\n\t \n#define S25FLXXXP_FLAG (FLASH_FLAG_READ_WRITE  |\t\\\n\t\t\tFLASH_FLAG_READ_1_1_2   |\t\\\n\t\t\tFLASH_FLAG_READ_1_2_2   |\t\\\n\t\t\tFLASH_FLAG_READ_1_1_4   |\t\\\n\t\t\tFLASH_FLAG_READ_1_4_4   |\t\\\n\t\t\tFLASH_FLAG_WRITE_1_1_4  |\t\\\n\t\t\tFLASH_FLAG_READ_FAST)\n\t{ \"s25fl032p\",  0x010215, 0x4d00,  64 * 1024,  64, S25FLXXXP_FLAG, 80,\n\t  stfsm_s25fl_config},\n\t{ \"s25fl129p0\", 0x012018, 0x4d00, 256 * 1024,  64, S25FLXXXP_FLAG, 80,\n\t  stfsm_s25fl_config },\n\t{ \"s25fl129p1\", 0x012018, 0x4d01,  64 * 1024, 256, S25FLXXXP_FLAG, 80,\n\t  stfsm_s25fl_config },\n\n\t \n#define S25FLXXXS_FLAG (S25FLXXXP_FLAG         |\t\\\n\t\t\tFLASH_FLAG_RESET        |\t\\\n\t\t\tFLASH_FLAG_DYB_LOCKING)\n\t{ \"s25fl128s0\", 0x012018, 0x0300,  256 * 1024, 64, S25FLXXXS_FLAG, 80,\n\t  stfsm_s25fl_config },\n\t{ \"s25fl128s1\", 0x012018, 0x0301,  64 * 1024, 256, S25FLXXXS_FLAG, 80,\n\t  stfsm_s25fl_config },\n\t{ \"s25fl256s0\", 0x010219, 0x4d00, 256 * 1024, 128,\n\t  S25FLXXXS_FLAG | FLASH_FLAG_32BIT_ADDR, 80, stfsm_s25fl_config },\n\t{ \"s25fl256s1\", 0x010219, 0x4d01,  64 * 1024, 512,\n\t  S25FLXXXS_FLAG | FLASH_FLAG_32BIT_ADDR, 80, stfsm_s25fl_config },\n\n\t \n#define W25X_FLAG (FLASH_FLAG_READ_WRITE       |\t\\\n\t\t   FLASH_FLAG_READ_FAST         |\t\\\n\t\t   FLASH_FLAG_READ_1_1_2        |\t\\\n\t\t   FLASH_FLAG_WRITE_1_1_2)\n\t{ \"w25x40\",  0xef3013, 0,  64 * 1024,   8, W25X_FLAG, 75, NULL },\n\t{ \"w25x80\",  0xef3014, 0,  64 * 1024,  16, W25X_FLAG, 75, NULL },\n\t{ \"w25x16\",  0xef3015, 0,  64 * 1024,  32, W25X_FLAG, 75, NULL },\n\t{ \"w25x32\",  0xef3016, 0,  64 * 1024,  64, W25X_FLAG, 75, NULL },\n\t{ \"w25x64\",  0xef3017, 0,  64 * 1024, 128, W25X_FLAG, 75, NULL },\n\n\t \n#define W25Q_FLAG (FLASH_FLAG_READ_WRITE       |\t\\\n\t\t   FLASH_FLAG_READ_FAST         |\t\\\n\t\t   FLASH_FLAG_READ_1_1_2        |\t\\\n\t\t   FLASH_FLAG_READ_1_2_2        |\t\\\n\t\t   FLASH_FLAG_READ_1_1_4        |\t\\\n\t\t   FLASH_FLAG_READ_1_4_4        |\t\\\n\t\t   FLASH_FLAG_WRITE_1_1_4)\n\t{ \"w25q80\",  0xef4014, 0,  64 * 1024,  16, W25Q_FLAG, 80,\n\t  stfsm_w25q_config },\n\t{ \"w25q16\",  0xef4015, 0,  64 * 1024,  32, W25Q_FLAG, 80,\n\t  stfsm_w25q_config },\n\t{ \"w25q32\",  0xef4016, 0,  64 * 1024,  64, W25Q_FLAG, 80,\n\t  stfsm_w25q_config },\n\t{ \"w25q64\",  0xef4017, 0,  64 * 1024, 128, W25Q_FLAG, 80,\n\t  stfsm_w25q_config },\n\n\t \n\t{ NULL, 0x000000, 0, 0, 0, 0, 0, NULL },\n};\n\n \n\n \nstatic struct seq_rw_config default_read_configs[] = {\n\t{FLASH_FLAG_READ_1_4_4, SPINOR_OP_READ_1_4_4,\t0, 4, 4, 0x00, 2, 4},\n\t{FLASH_FLAG_READ_1_1_4, SPINOR_OP_READ_1_1_4,\t0, 1, 4, 0x00, 4, 0},\n\t{FLASH_FLAG_READ_1_2_2, SPINOR_OP_READ_1_2_2,\t0, 2, 2, 0x00, 4, 0},\n\t{FLASH_FLAG_READ_1_1_2, SPINOR_OP_READ_1_1_2,\t0, 1, 2, 0x00, 0, 8},\n\t{FLASH_FLAG_READ_FAST,\tSPINOR_OP_READ_FAST,\t0, 1, 1, 0x00, 0, 8},\n\t{FLASH_FLAG_READ_WRITE, SPINOR_OP_READ,\t\t0, 1, 1, 0x00, 0, 0},\n\t{0x00,\t\t\t0,\t\t\t0, 0, 0, 0x00, 0, 0},\n};\n\n \nstatic struct seq_rw_config default_write_configs[] = {\n\t{FLASH_FLAG_WRITE_1_4_4, SPINOR_OP_WRITE_1_4_4, 1, 4, 4, 0x00, 0, 0},\n\t{FLASH_FLAG_WRITE_1_1_4, SPINOR_OP_WRITE_1_1_4, 1, 1, 4, 0x00, 0, 0},\n\t{FLASH_FLAG_WRITE_1_2_2, SPINOR_OP_WRITE_1_2_2, 1, 2, 2, 0x00, 0, 0},\n\t{FLASH_FLAG_WRITE_1_1_2, SPINOR_OP_WRITE_1_1_2, 1, 1, 2, 0x00, 0, 0},\n\t{FLASH_FLAG_READ_WRITE,  SPINOR_OP_WRITE,       1, 1, 1, 0x00, 0, 0},\n\t{0x00,\t\t\t 0,\t\t\t0, 0, 0, 0x00, 0, 0},\n};\n\n \n#define N25Q_VCR_DUMMY_CYCLES(x)\t(((x) & 0xf) << 4)\n#define N25Q_VCR_XIP_DISABLED\t\t((uint8_t)0x1 << 3)\n#define N25Q_VCR_WRAP_CONT\t\t0x3\n\n \nstatic struct seq_rw_config n25q_read3_configs[] = {\n\t{FLASH_FLAG_READ_1_4_4, SPINOR_OP_READ_1_4_4,\t0, 4, 4, 0x00, 0, 8},\n\t{FLASH_FLAG_READ_1_1_4, SPINOR_OP_READ_1_1_4,\t0, 1, 4, 0x00, 0, 8},\n\t{FLASH_FLAG_READ_1_2_2, SPINOR_OP_READ_1_2_2,\t0, 2, 2, 0x00, 0, 8},\n\t{FLASH_FLAG_READ_1_1_2, SPINOR_OP_READ_1_1_2,\t0, 1, 2, 0x00, 0, 8},\n\t{FLASH_FLAG_READ_FAST,\tSPINOR_OP_READ_FAST,\t0, 1, 1, 0x00, 0, 8},\n\t{FLASH_FLAG_READ_WRITE, SPINOR_OP_READ,\t        0, 1, 1, 0x00, 0, 0},\n\t{0x00,\t\t\t0,\t\t\t0, 0, 0, 0x00, 0, 0},\n};\n\n \nstatic struct seq_rw_config n25q_read4_configs[] = {\n\t{FLASH_FLAG_READ_1_4_4, SPINOR_OP_READ_1_4_4_4B, 0, 4, 4, 0x00, 0, 8},\n\t{FLASH_FLAG_READ_1_1_4, SPINOR_OP_READ_1_1_4_4B, 0, 1, 4, 0x00, 0, 8},\n\t{FLASH_FLAG_READ_1_2_2, SPINOR_OP_READ_1_2_2_4B, 0, 2, 2, 0x00, 0, 8},\n\t{FLASH_FLAG_READ_1_1_2, SPINOR_OP_READ_1_1_2_4B, 0, 1, 2, 0x00, 0, 8},\n\t{FLASH_FLAG_READ_FAST,\tSPINOR_OP_READ_FAST_4B,  0, 1, 1, 0x00, 0, 8},\n\t{FLASH_FLAG_READ_WRITE, SPINOR_OP_READ_4B,       0, 1, 1, 0x00, 0, 0},\n\t{0x00,\t\t\t0,                       0, 0, 0, 0x00, 0, 0},\n};\n\n \n#define MX25_STATUS_QE\t\t\t(0x1 << 6)\n\nstatic int stfsm_mx25_en_32bit_addr_seq(struct stfsm_seq *seq)\n{\n\tseq->seq_opc[0] = (SEQ_OPC_PADS_1 |\n\t\t\t   SEQ_OPC_CYCLES(8) |\n\t\t\t   SEQ_OPC_OPCODE(SPINOR_OP_EN4B) |\n\t\t\t   SEQ_OPC_CSDEASSERT);\n\n\tseq->seq[0] = STFSM_INST_CMD1;\n\tseq->seq[1] = STFSM_INST_WAIT;\n\tseq->seq[2] = STFSM_INST_STOP;\n\n\tseq->seq_cfg = (SEQ_CFG_PADS_1 |\n\t\t\tSEQ_CFG_ERASE |\n\t\t\tSEQ_CFG_READNOTWRITE |\n\t\t\tSEQ_CFG_CSDEASSERT |\n\t\t\tSEQ_CFG_STARTSEQ);\n\n\treturn 0;\n}\n\n \n#define STFSM_S25FL_CONFIG_QE\t\t(0x1 << 1)\n\n \nstatic struct seq_rw_config stfsm_s25fl_read4_configs[] = {\n\t{FLASH_FLAG_READ_1_4_4,  SPINOR_OP_READ_1_4_4_4B,  0, 4, 4, 0x00, 2, 4},\n\t{FLASH_FLAG_READ_1_1_4,  SPINOR_OP_READ_1_1_4_4B,  0, 1, 4, 0x00, 0, 8},\n\t{FLASH_FLAG_READ_1_2_2,  SPINOR_OP_READ_1_2_2_4B,  0, 2, 2, 0x00, 4, 0},\n\t{FLASH_FLAG_READ_1_1_2,  SPINOR_OP_READ_1_1_2_4B,  0, 1, 2, 0x00, 0, 8},\n\t{FLASH_FLAG_READ_FAST,   SPINOR_OP_READ_FAST_4B,   0, 1, 1, 0x00, 0, 8},\n\t{FLASH_FLAG_READ_WRITE,  SPINOR_OP_READ_4B,        0, 1, 1, 0x00, 0, 0},\n\t{0x00,                   0,                        0, 0, 0, 0x00, 0, 0},\n};\n\nstatic struct seq_rw_config stfsm_s25fl_write4_configs[] = {\n\t{FLASH_FLAG_WRITE_1_1_4, S25FL_CMD_WRITE4_1_1_4, 1, 1, 4, 0x00, 0, 0},\n\t{FLASH_FLAG_READ_WRITE,  S25FL_CMD_WRITE4,       1, 1, 1, 0x00, 0, 0},\n\t{0x00,                   0,                      0, 0, 0, 0x00, 0, 0},\n};\n\n \n#define W25Q_STATUS_QE\t\t\t(0x1 << 1)\n\nstatic struct stfsm_seq stfsm_seq_read_jedec = {\n\t.data_size = TRANSFER_SIZE(8),\n\t.seq_opc[0] = (SEQ_OPC_PADS_1 |\n\t\t       SEQ_OPC_CYCLES(8) |\n\t\t       SEQ_OPC_OPCODE(SPINOR_OP_RDID)),\n\t.seq = {\n\t\tSTFSM_INST_CMD1,\n\t\tSTFSM_INST_DATA_READ,\n\t\tSTFSM_INST_STOP,\n\t},\n\t.seq_cfg = (SEQ_CFG_PADS_1 |\n\t\t    SEQ_CFG_READNOTWRITE |\n\t\t    SEQ_CFG_CSDEASSERT |\n\t\t    SEQ_CFG_STARTSEQ),\n};\n\nstatic struct stfsm_seq stfsm_seq_read_status_fifo = {\n\t.data_size = TRANSFER_SIZE(4),\n\t.seq_opc[0] = (SEQ_OPC_PADS_1 |\n\t\t       SEQ_OPC_CYCLES(8) |\n\t\t       SEQ_OPC_OPCODE(SPINOR_OP_RDSR)),\n\t.seq = {\n\t\tSTFSM_INST_CMD1,\n\t\tSTFSM_INST_DATA_READ,\n\t\tSTFSM_INST_STOP,\n\t},\n\t.seq_cfg = (SEQ_CFG_PADS_1 |\n\t\t    SEQ_CFG_READNOTWRITE |\n\t\t    SEQ_CFG_CSDEASSERT |\n\t\t    SEQ_CFG_STARTSEQ),\n};\n\nstatic struct stfsm_seq stfsm_seq_erase_sector = {\n\t \n\t.seq_opc = {\n\t\t(SEQ_OPC_PADS_1 | SEQ_OPC_CYCLES(8) |\n\t\t SEQ_OPC_OPCODE(SPINOR_OP_WREN) | SEQ_OPC_CSDEASSERT),\n\n\t\t(SEQ_OPC_PADS_1 | SEQ_OPC_CYCLES(8) |\n\t\t SEQ_OPC_OPCODE(SPINOR_OP_SE)),\n\t},\n\t.seq = {\n\t\tSTFSM_INST_CMD1,\n\t\tSTFSM_INST_CMD2,\n\t\tSTFSM_INST_ADD1,\n\t\tSTFSM_INST_ADD2,\n\t\tSTFSM_INST_STOP,\n\t},\n\t.seq_cfg = (SEQ_CFG_PADS_1 |\n\t\t    SEQ_CFG_READNOTWRITE |\n\t\t    SEQ_CFG_CSDEASSERT |\n\t\t    SEQ_CFG_STARTSEQ),\n};\n\nstatic struct stfsm_seq stfsm_seq_erase_chip = {\n\t.seq_opc = {\n\t\t(SEQ_OPC_PADS_1 | SEQ_OPC_CYCLES(8) |\n\t\t SEQ_OPC_OPCODE(SPINOR_OP_WREN) | SEQ_OPC_CSDEASSERT),\n\n\t\t(SEQ_OPC_PADS_1 | SEQ_OPC_CYCLES(8) |\n\t\t SEQ_OPC_OPCODE(SPINOR_OP_CHIP_ERASE) | SEQ_OPC_CSDEASSERT),\n\t},\n\t.seq = {\n\t\tSTFSM_INST_CMD1,\n\t\tSTFSM_INST_CMD2,\n\t\tSTFSM_INST_WAIT,\n\t\tSTFSM_INST_STOP,\n\t},\n\t.seq_cfg = (SEQ_CFG_PADS_1 |\n\t\t    SEQ_CFG_ERASE |\n\t\t    SEQ_CFG_READNOTWRITE |\n\t\t    SEQ_CFG_CSDEASSERT |\n\t\t    SEQ_CFG_STARTSEQ),\n};\n\nstatic struct stfsm_seq stfsm_seq_write_status = {\n\t.seq_opc[0] = (SEQ_OPC_PADS_1 | SEQ_OPC_CYCLES(8) |\n\t\t       SEQ_OPC_OPCODE(SPINOR_OP_WREN) | SEQ_OPC_CSDEASSERT),\n\t.seq_opc[1] = (SEQ_OPC_PADS_1 | SEQ_OPC_CYCLES(8) |\n\t\t       SEQ_OPC_OPCODE(SPINOR_OP_WRSR)),\n\t.seq = {\n\t\tSTFSM_INST_CMD1,\n\t\tSTFSM_INST_CMD2,\n\t\tSTFSM_INST_STA_WR1,\n\t\tSTFSM_INST_STOP,\n\t},\n\t.seq_cfg = (SEQ_CFG_PADS_1 |\n\t\t    SEQ_CFG_READNOTWRITE |\n\t\t    SEQ_CFG_CSDEASSERT |\n\t\t    SEQ_CFG_STARTSEQ),\n};\n\n \nstatic const struct stfsm_seq stfsm_seq_load_fifo_byte = {\n\t.data_size = TRANSFER_SIZE(1),\n\t.seq_opc[0] = (SEQ_OPC_PADS_1 |\n\t\t       SEQ_OPC_CYCLES(8) |\n\t\t       SEQ_OPC_OPCODE(SPINOR_OP_RDID)),\n\t.seq = {\n\t\tSTFSM_INST_CMD1,\n\t\tSTFSM_INST_DATA_READ,\n\t\tSTFSM_INST_STOP,\n\t},\n\t.seq_cfg = (SEQ_CFG_PADS_1 |\n\t\t    SEQ_CFG_READNOTWRITE |\n\t\t    SEQ_CFG_CSDEASSERT |\n\t\t    SEQ_CFG_STARTSEQ),\n};\n\nstatic int stfsm_n25q_en_32bit_addr_seq(struct stfsm_seq *seq)\n{\n\tseq->seq_opc[0] = (SEQ_OPC_PADS_1 | SEQ_OPC_CYCLES(8) |\n\t\t\t   SEQ_OPC_OPCODE(SPINOR_OP_EN4B));\n\tseq->seq_opc[1] = (SEQ_OPC_PADS_1 | SEQ_OPC_CYCLES(8) |\n\t\t\t   SEQ_OPC_OPCODE(SPINOR_OP_WREN) |\n\t\t\t   SEQ_OPC_CSDEASSERT);\n\n\tseq->seq[0] = STFSM_INST_CMD2;\n\tseq->seq[1] = STFSM_INST_CMD1;\n\tseq->seq[2] = STFSM_INST_WAIT;\n\tseq->seq[3] = STFSM_INST_STOP;\n\n\tseq->seq_cfg = (SEQ_CFG_PADS_1 |\n\t\t\tSEQ_CFG_ERASE |\n\t\t\tSEQ_CFG_READNOTWRITE |\n\t\t\tSEQ_CFG_CSDEASSERT |\n\t\t\tSEQ_CFG_STARTSEQ);\n\n\treturn 0;\n}\n\nstatic inline int stfsm_is_idle(struct stfsm *fsm)\n{\n\treturn readl(fsm->base + SPI_FAST_SEQ_STA) & 0x10;\n}\n\nstatic inline uint32_t stfsm_fifo_available(struct stfsm *fsm)\n{\n\treturn (readl(fsm->base + SPI_FAST_SEQ_STA) >> 5) & 0x7f;\n}\n\nstatic inline void stfsm_load_seq(struct stfsm *fsm,\n\t\t\t\t  const struct stfsm_seq *seq)\n{\n\tvoid __iomem *dst = fsm->base + SPI_FAST_SEQ_TRANSFER_SIZE;\n\tconst uint32_t *src = (const uint32_t *)seq;\n\tint words = sizeof(*seq) / sizeof(*src);\n\n\tBUG_ON(!stfsm_is_idle(fsm));\n\n\twhile (words--) {\n\t\twritel(*src, dst);\n\t\tsrc++;\n\t\tdst += 4;\n\t}\n}\n\nstatic void stfsm_wait_seq(struct stfsm *fsm)\n{\n\tunsigned long deadline;\n\tint timeout = 0;\n\n\tdeadline = jiffies + msecs_to_jiffies(STFSM_MAX_WAIT_SEQ_MS);\n\n\twhile (!timeout) {\n\t\tif (time_after_eq(jiffies, deadline))\n\t\t\ttimeout = 1;\n\n\t\tif (stfsm_is_idle(fsm))\n\t\t\treturn;\n\n\t\tcond_resched();\n\t}\n\n\tdev_err(fsm->dev, \"timeout on sequence completion\\n\");\n}\n\nstatic void stfsm_read_fifo(struct stfsm *fsm, uint32_t *buf, uint32_t size)\n{\n\tuint32_t remaining = size >> 2;\n\tuint32_t avail;\n\tuint32_t words;\n\n\tdev_dbg(fsm->dev, \"Reading %d bytes from FIFO\\n\", size);\n\n\tBUG_ON((((uintptr_t)buf) & 0x3) || (size & 0x3));\n\n\twhile (remaining) {\n\t\tfor (;;) {\n\t\t\tavail = stfsm_fifo_available(fsm);\n\t\t\tif (avail)\n\t\t\t\tbreak;\n\t\t\tudelay(1);\n\t\t}\n\t\twords = min(avail, remaining);\n\t\tremaining -= words;\n\n\t\treadsl(fsm->base + SPI_FAST_SEQ_DATA_REG, buf, words);\n\t\tbuf += words;\n\t}\n}\n\n \nstatic void stfsm_clear_fifo(struct stfsm *fsm)\n{\n\tconst struct stfsm_seq *seq = &stfsm_seq_load_fifo_byte;\n\tuint32_t words, i;\n\n\t \n\twords = stfsm_fifo_available(fsm);\n\tif (words) {\n\t\tfor (i = 0; i < words; i++)\n\t\t\treadl(fsm->base + SPI_FAST_SEQ_DATA_REG);\n\t\tdev_dbg(fsm->dev, \"cleared %d words from FIFO\\n\", words);\n\t}\n\n\t \n\tfor (i = 0, words = 0; i < 4 && !words; i++) {\n\t\tstfsm_load_seq(fsm, seq);\n\t\tstfsm_wait_seq(fsm);\n\t\twords = stfsm_fifo_available(fsm);\n\t}\n\n\t \n\tif (words != 1) {\n\t\tdev_err(fsm->dev, \"failed to clear bytes from the data FIFO\\n\");\n\t\treturn;\n\t}\n\n\t \n\treadl(fsm->base + SPI_FAST_SEQ_DATA_REG);\n\n\tdev_dbg(fsm->dev, \"cleared %d byte(s) from the data FIFO\\n\", 4 - i);\n}\n\nstatic int stfsm_write_fifo(struct stfsm *fsm, const uint32_t *buf,\n\t\t\t    uint32_t size)\n{\n\tuint32_t words = size >> 2;\n\n\tdev_dbg(fsm->dev, \"writing %d bytes to FIFO\\n\", size);\n\n\tBUG_ON((((uintptr_t)buf) & 0x3) || (size & 0x3));\n\n\twritesl(fsm->base + SPI_FAST_SEQ_DATA_REG, buf, words);\n\n\treturn size;\n}\n\nstatic int stfsm_enter_32bit_addr(struct stfsm *fsm, int enter)\n{\n\tstruct stfsm_seq *seq = &fsm->stfsm_seq_en_32bit_addr;\n\tuint32_t cmd = enter ? SPINOR_OP_EN4B : SPINOR_OP_EX4B;\n\n\tseq->seq_opc[0] = (SEQ_OPC_PADS_1 |\n\t\t\t   SEQ_OPC_CYCLES(8) |\n\t\t\t   SEQ_OPC_OPCODE(cmd) |\n\t\t\t   SEQ_OPC_CSDEASSERT);\n\n\tstfsm_load_seq(fsm, seq);\n\n\tstfsm_wait_seq(fsm);\n\n\treturn 0;\n}\n\nstatic uint8_t stfsm_wait_busy(struct stfsm *fsm)\n{\n\tstruct stfsm_seq *seq = &stfsm_seq_read_status_fifo;\n\tunsigned long deadline;\n\tuint32_t status;\n\tint timeout = 0;\n\n\t \n\tseq->seq_opc[0] = (SEQ_OPC_PADS_1 |\n\t\t\t   SEQ_OPC_CYCLES(8) |\n\t\t\t   SEQ_OPC_OPCODE(SPINOR_OP_RDSR));\n\n\t \n\tstfsm_load_seq(fsm, seq);\n\n\t \n\tdeadline = jiffies + FLASH_MAX_BUSY_WAIT;\n\twhile (!timeout) {\n\t\tif (time_after_eq(jiffies, deadline))\n\t\t\ttimeout = 1;\n\n\t\tstfsm_wait_seq(fsm);\n\n\t\tstfsm_read_fifo(fsm, &status, 4);\n\n\t\tif ((status & FLASH_STATUS_BUSY) == 0)\n\t\t\treturn 0;\n\n\t\tif ((fsm->configuration & CFG_S25FL_CHECK_ERROR_FLAGS) &&\n\t\t    ((status & S25FL_STATUS_P_ERR) ||\n\t\t     (status & S25FL_STATUS_E_ERR)))\n\t\t\treturn (uint8_t)(status & 0xff);\n\n\t\tif (!timeout)\n\t\t\t \n\t\t\twritel(seq->seq_cfg, fsm->base + SPI_FAST_SEQ_CFG);\n\n\t\tcond_resched();\n\t}\n\n\tdev_err(fsm->dev, \"timeout on wait_busy\\n\");\n\n\treturn FLASH_STATUS_TIMEOUT;\n}\n\nstatic int stfsm_read_status(struct stfsm *fsm, uint8_t cmd,\n\t\t\t     uint8_t *data, int bytes)\n{\n\tstruct stfsm_seq *seq = &stfsm_seq_read_status_fifo;\n\tuint32_t tmp;\n\tuint8_t *t = (uint8_t *)&tmp;\n\tint i;\n\n\tdev_dbg(fsm->dev, \"read 'status' register [0x%02x], %d byte(s)\\n\",\n\t\tcmd, bytes);\n\n\tBUG_ON(bytes != 1 && bytes != 2);\n\n\tseq->seq_opc[0] = (SEQ_OPC_PADS_1 | SEQ_OPC_CYCLES(8) |\n\t\t\t   SEQ_OPC_OPCODE(cmd));\n\n\tstfsm_load_seq(fsm, seq);\n\n\tstfsm_read_fifo(fsm, &tmp, 4);\n\n\tfor (i = 0; i < bytes; i++)\n\t\tdata[i] = t[i];\n\n\tstfsm_wait_seq(fsm);\n\n\treturn 0;\n}\n\nstatic int stfsm_write_status(struct stfsm *fsm, uint8_t cmd,\n\t\t\t    uint16_t data, int bytes, int wait_busy)\n{\n\tstruct stfsm_seq *seq = &stfsm_seq_write_status;\n\n\tdev_dbg(fsm->dev,\n\t\t\"write 'status' register [0x%02x], %d byte(s), 0x%04x\\n\"\n\t\t\" %s wait-busy\\n\", cmd, bytes, data, wait_busy ? \"with\" : \"no\");\n\n\tBUG_ON(bytes != 1 && bytes != 2);\n\n\tseq->seq_opc[1] = (SEQ_OPC_PADS_1 | SEQ_OPC_CYCLES(8) |\n\t\t\t   SEQ_OPC_OPCODE(cmd));\n\n\tseq->status = (uint32_t)data | STA_PADS_1 | STA_CSDEASSERT;\n\tseq->seq[2] = (bytes == 1) ? STFSM_INST_STA_WR1 : STFSM_INST_STA_WR1_2;\n\n\tstfsm_load_seq(fsm, seq);\n\n\tstfsm_wait_seq(fsm);\n\n\tif (wait_busy)\n\t\tstfsm_wait_busy(fsm);\n\n\treturn 0;\n}\n\n \nstatic bool stfsm_can_handle_soc_reset(struct stfsm *fsm)\n{\n\t \n\tif (fsm->reset_signal && fsm->info->flags & FLASH_FLAG_RESET)\n\t\treturn true;\n\n\t \n\tif (fsm->reset_por)\n\t\treturn true;\n\n\t \n\treturn false;\n}\n\n \nstatic void stfsm_prepare_erasesec_seq(struct stfsm *fsm,\n\t\t\t\t       struct stfsm_seq *seq)\n{\n\tint addr1_cycles = fsm->info->flags & FLASH_FLAG_32BIT_ADDR ? 16 : 8;\n\n\tseq->addr_cfg = (ADR_CFG_CYCLES_ADD1(addr1_cycles) |\n\t\t\t ADR_CFG_PADS_1_ADD1 |\n\t\t\t ADR_CFG_CYCLES_ADD2(16) |\n\t\t\t ADR_CFG_PADS_1_ADD2 |\n\t\t\t ADR_CFG_CSDEASSERT_ADD2);\n}\n\n \nstatic struct seq_rw_config *\nstfsm_search_seq_rw_configs(struct stfsm *fsm,\n\t\t\t    struct seq_rw_config cfgs[])\n{\n\tstruct seq_rw_config *config;\n\tint flags = fsm->info->flags;\n\n\tfor (config = cfgs; config->cmd != 0; config++)\n\t\tif ((config->flags & flags) == config->flags)\n\t\t\treturn config;\n\n\treturn NULL;\n}\n\n \nstatic void stfsm_prepare_rw_seq(struct stfsm *fsm,\n\t\t\t\t struct stfsm_seq *seq,\n\t\t\t\t struct seq_rw_config *cfg)\n{\n\tint addr1_cycles, addr2_cycles;\n\tint i = 0;\n\n\tmemset(seq, 0, sizeof(*seq));\n\n\t \n\tseq->seq_opc[i++] = (SEQ_OPC_PADS_1 |\n\t\t\t     SEQ_OPC_CYCLES(8) |\n\t\t\t     SEQ_OPC_OPCODE(cfg->cmd));\n\n\t \n\tif (cfg->write)\n\t\tseq->seq_opc[i++] = (SEQ_OPC_PADS_1 |\n\t\t\t\t     SEQ_OPC_CYCLES(8) |\n\t\t\t\t     SEQ_OPC_OPCODE(SPINOR_OP_WREN) |\n\t\t\t\t     SEQ_OPC_CSDEASSERT);\n\n\t \n\taddr1_cycles  = (fsm->info->flags & FLASH_FLAG_32BIT_ADDR) ? 16 : 8;\n\taddr1_cycles /= cfg->addr_pads;\n\taddr2_cycles  = 16 / cfg->addr_pads;\n\tseq->addr_cfg = ((addr1_cycles & 0x3f) << 0 |\t \n\t\t\t (cfg->addr_pads - 1) << 6 |\t \n\t\t\t (addr2_cycles & 0x3f) << 16 |\t \n\t\t\t ((cfg->addr_pads - 1) << 22));\t \n\n\t \n\tseq->seq_cfg = ((cfg->data_pads - 1) << 16 |\n\t\t\tSEQ_CFG_STARTSEQ |\n\t\t\tSEQ_CFG_CSDEASSERT);\n\tif (!cfg->write)\n\t\tseq->seq_cfg |= SEQ_CFG_READNOTWRITE;\n\n\t \n\tseq->mode = ((cfg->mode_data & 0xff) << 0 |\t \n\t\t     (cfg->mode_cycles & 0x3f) << 16 |\t \n\t\t     (cfg->addr_pads - 1) << 22);\t \n\n\t \n\tseq->dummy = ((cfg->dummy_cycles & 0x3f) << 16 |\t \n\t\t      (cfg->addr_pads - 1) << 22);\t\t \n\n\n\t \n\ti = 0;\n\tif (cfg->write)\n\t\tseq->seq[i++] = STFSM_INST_CMD2;\n\n\tseq->seq[i++] = STFSM_INST_CMD1;\n\n\tseq->seq[i++] = STFSM_INST_ADD1;\n\tseq->seq[i++] = STFSM_INST_ADD2;\n\n\tif (cfg->mode_cycles)\n\t\tseq->seq[i++] = STFSM_INST_MODE;\n\n\tif (cfg->dummy_cycles)\n\t\tseq->seq[i++] = STFSM_INST_DUMMY;\n\n\tseq->seq[i++] =\n\t\tcfg->write ? STFSM_INST_DATA_WRITE : STFSM_INST_DATA_READ;\n\tseq->seq[i++] = STFSM_INST_STOP;\n}\n\nstatic int stfsm_search_prepare_rw_seq(struct stfsm *fsm,\n\t\t\t\t       struct stfsm_seq *seq,\n\t\t\t\t       struct seq_rw_config *cfgs)\n{\n\tstruct seq_rw_config *config;\n\n\tconfig = stfsm_search_seq_rw_configs(fsm, cfgs);\n\tif (!config) {\n\t\tdev_err(fsm->dev, \"failed to find suitable config\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tstfsm_prepare_rw_seq(fsm, seq, config);\n\n\treturn 0;\n}\n\n \nstatic int stfsm_prepare_rwe_seqs_default(struct stfsm *fsm)\n{\n\tuint32_t flags = fsm->info->flags;\n\tint ret;\n\n\t \n\tret = stfsm_search_prepare_rw_seq(fsm, &fsm->stfsm_seq_read,\n\t\t\t\t\t  default_read_configs);\n\tif (ret) {\n\t\tdev_err(fsm->dev,\n\t\t\t\"failed to prep READ sequence with flags [0x%08x]\\n\",\n\t\t\tflags);\n\t\treturn ret;\n\t}\n\n\t \n\tret = stfsm_search_prepare_rw_seq(fsm, &fsm->stfsm_seq_write,\n\t\t\t\t\t  default_write_configs);\n\tif (ret) {\n\t\tdev_err(fsm->dev,\n\t\t\t\"failed to prep WRITE sequence with flags [0x%08x]\\n\",\n\t\t\tflags);\n\t\treturn ret;\n\t}\n\n\t \n\tstfsm_prepare_erasesec_seq(fsm, &stfsm_seq_erase_sector);\n\n\treturn 0;\n}\n\nstatic int stfsm_mx25_config(struct stfsm *fsm)\n{\n\tuint32_t flags = fsm->info->flags;\n\tuint32_t data_pads;\n\tuint8_t sta;\n\tint ret;\n\tbool soc_reset;\n\n\t \n\tret = stfsm_prepare_rwe_seqs_default(fsm);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (flags & FLASH_FLAG_32BIT_ADDR) {\n\t\t \n\t\tstfsm_mx25_en_32bit_addr_seq(&fsm->stfsm_seq_en_32bit_addr);\n\n\t\tsoc_reset = stfsm_can_handle_soc_reset(fsm);\n\t\tif (soc_reset || !fsm->booted_from_spi)\n\t\t\t \n\t\t\tstfsm_enter_32bit_addr(fsm, 1);\n\n\t\telse\n\t\t\t \n\t\t\tfsm->configuration = (CFG_READ_TOGGLE_32BIT_ADDR |\n\t\t\t\t\t      CFG_WRITE_TOGGLE_32BIT_ADDR |\n\t\t\t\t\t      CFG_ERASESEC_TOGGLE_32BIT_ADDR);\n\t}\n\n\t \n\tstfsm_read_status(fsm, SPINOR_OP_RDSR, &sta, 1);\n\tdata_pads = ((fsm->stfsm_seq_read.seq_cfg >> 16) & 0x3) + 1;\n\tif (data_pads == 4) {\n\t\tif (!(sta & MX25_STATUS_QE)) {\n\t\t\t \n\t\t\tsta |= MX25_STATUS_QE;\n\n\t\t\tstfsm_write_status(fsm, SPINOR_OP_WRSR, sta, 1, 1);\n\t\t}\n\t} else {\n\t\tif (sta & MX25_STATUS_QE) {\n\t\t\t \n\t\t\tsta &= ~MX25_STATUS_QE;\n\n\t\t\tstfsm_write_status(fsm, SPINOR_OP_WRSR, sta, 1, 1);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int stfsm_n25q_config(struct stfsm *fsm)\n{\n\tuint32_t flags = fsm->info->flags;\n\tuint8_t vcr;\n\tint ret = 0;\n\tbool soc_reset;\n\n\t \n\tif (flags & FLASH_FLAG_32BIT_ADDR)\n\t\tret = stfsm_search_prepare_rw_seq(fsm, &fsm->stfsm_seq_read,\n\t\t\t\t\t\t  n25q_read4_configs);\n\telse\n\t\tret = stfsm_search_prepare_rw_seq(fsm, &fsm->stfsm_seq_read,\n\t\t\t\t\t\t  n25q_read3_configs);\n\tif (ret) {\n\t\tdev_err(fsm->dev,\n\t\t\t\"failed to prepare READ sequence with flags [0x%08x]\\n\",\n\t\t\tflags);\n\t\treturn ret;\n\t}\n\n\t \n\tret = stfsm_search_prepare_rw_seq(fsm, &fsm->stfsm_seq_write,\n\t\t\t\t\t  default_write_configs);\n\tif (ret) {\n\t\tdev_err(fsm->dev,\n\t\t\t\"preparing WRITE sequence using flags [0x%08x] failed\\n\",\n\t\t\tflags);\n\t\treturn ret;\n\t}\n\n\t \n\tstfsm_prepare_erasesec_seq(fsm, &stfsm_seq_erase_sector);\n\n\t \n\tif (flags & FLASH_FLAG_32BIT_ADDR) {\n\t\tstfsm_n25q_en_32bit_addr_seq(&fsm->stfsm_seq_en_32bit_addr);\n\n\t\tsoc_reset = stfsm_can_handle_soc_reset(fsm);\n\t\tif (soc_reset || !fsm->booted_from_spi) {\n\t\t\t \n\t\t\tstfsm_enter_32bit_addr(fsm, 1);\n\t\t} else {\n\t\t\t \n\t\t\tfsm->configuration = (CFG_WRITE_TOGGLE_32BIT_ADDR |\n\t\t\t\t\t      CFG_ERASESEC_TOGGLE_32BIT_ADDR);\n\t\t}\n\t}\n\n\t \n\tvcr = (N25Q_VCR_DUMMY_CYCLES(8) | N25Q_VCR_XIP_DISABLED |\n\t       N25Q_VCR_WRAP_CONT);\n\tstfsm_write_status(fsm, N25Q_CMD_WRVCR, vcr, 1, 0);\n\n\treturn 0;\n}\n\nstatic void stfsm_s25fl_prepare_erasesec_seq_32(struct stfsm_seq *seq)\n{\n\tseq->seq_opc[1] = (SEQ_OPC_PADS_1 |\n\t\t\t   SEQ_OPC_CYCLES(8) |\n\t\t\t   SEQ_OPC_OPCODE(S25FL_CMD_SE4));\n\n\tseq->addr_cfg = (ADR_CFG_CYCLES_ADD1(16) |\n\t\t\t ADR_CFG_PADS_1_ADD1 |\n\t\t\t ADR_CFG_CYCLES_ADD2(16) |\n\t\t\t ADR_CFG_PADS_1_ADD2 |\n\t\t\t ADR_CFG_CSDEASSERT_ADD2);\n}\n\nstatic void stfsm_s25fl_read_dyb(struct stfsm *fsm, uint32_t offs, uint8_t *dby)\n{\n\tuint32_t tmp;\n\tstruct stfsm_seq seq = {\n\t\t.data_size = TRANSFER_SIZE(4),\n\t\t.seq_opc[0] = (SEQ_OPC_PADS_1 |\n\t\t\t       SEQ_OPC_CYCLES(8) |\n\t\t\t       SEQ_OPC_OPCODE(S25FL_CMD_DYBRD)),\n\t\t.addr_cfg = (ADR_CFG_CYCLES_ADD1(16) |\n\t\t\t     ADR_CFG_PADS_1_ADD1 |\n\t\t\t     ADR_CFG_CYCLES_ADD2(16) |\n\t\t\t     ADR_CFG_PADS_1_ADD2),\n\t\t.addr1 = (offs >> 16) & 0xffff,\n\t\t.addr2 = offs & 0xffff,\n\t\t.seq = {\n\t\t\tSTFSM_INST_CMD1,\n\t\t\tSTFSM_INST_ADD1,\n\t\t\tSTFSM_INST_ADD2,\n\t\t\tSTFSM_INST_DATA_READ,\n\t\t\tSTFSM_INST_STOP,\n\t\t},\n\t\t.seq_cfg = (SEQ_CFG_PADS_1 |\n\t\t\t    SEQ_CFG_READNOTWRITE |\n\t\t\t    SEQ_CFG_CSDEASSERT |\n\t\t\t    SEQ_CFG_STARTSEQ),\n\t};\n\n\tstfsm_load_seq(fsm, &seq);\n\n\tstfsm_read_fifo(fsm, &tmp, 4);\n\n\t*dby = (uint8_t)(tmp >> 24);\n\n\tstfsm_wait_seq(fsm);\n}\n\nstatic void stfsm_s25fl_write_dyb(struct stfsm *fsm, uint32_t offs, uint8_t dby)\n{\n\tstruct stfsm_seq seq = {\n\t\t.seq_opc[0] = (SEQ_OPC_PADS_1 | SEQ_OPC_CYCLES(8) |\n\t\t\t       SEQ_OPC_OPCODE(SPINOR_OP_WREN) |\n\t\t\t       SEQ_OPC_CSDEASSERT),\n\t\t.seq_opc[1] = (SEQ_OPC_PADS_1 | SEQ_OPC_CYCLES(8) |\n\t\t\t       SEQ_OPC_OPCODE(S25FL_CMD_DYBWR)),\n\t\t.addr_cfg = (ADR_CFG_CYCLES_ADD1(16) |\n\t\t\t     ADR_CFG_PADS_1_ADD1 |\n\t\t\t     ADR_CFG_CYCLES_ADD2(16) |\n\t\t\t     ADR_CFG_PADS_1_ADD2),\n\t\t.status = (uint32_t)dby | STA_PADS_1 | STA_CSDEASSERT,\n\t\t.addr1 = (offs >> 16) & 0xffff,\n\t\t.addr2 = offs & 0xffff,\n\t\t.seq = {\n\t\t\tSTFSM_INST_CMD1,\n\t\t\tSTFSM_INST_CMD2,\n\t\t\tSTFSM_INST_ADD1,\n\t\t\tSTFSM_INST_ADD2,\n\t\t\tSTFSM_INST_STA_WR1,\n\t\t\tSTFSM_INST_STOP,\n\t\t},\n\t\t.seq_cfg = (SEQ_CFG_PADS_1 |\n\t\t\t    SEQ_CFG_READNOTWRITE |\n\t\t\t    SEQ_CFG_CSDEASSERT |\n\t\t\t    SEQ_CFG_STARTSEQ),\n\t};\n\n\tstfsm_load_seq(fsm, &seq);\n\tstfsm_wait_seq(fsm);\n\n\tstfsm_wait_busy(fsm);\n}\n\nstatic int stfsm_s25fl_clear_status_reg(struct stfsm *fsm)\n{\n\tstruct stfsm_seq seq = {\n\t\t.seq_opc[0] = (SEQ_OPC_PADS_1 |\n\t\t\t       SEQ_OPC_CYCLES(8) |\n\t\t\t       SEQ_OPC_OPCODE(S25FL_CMD_CLSR) |\n\t\t\t       SEQ_OPC_CSDEASSERT),\n\t\t.seq_opc[1] = (SEQ_OPC_PADS_1 |\n\t\t\t       SEQ_OPC_CYCLES(8) |\n\t\t\t       SEQ_OPC_OPCODE(SPINOR_OP_WRDI) |\n\t\t\t       SEQ_OPC_CSDEASSERT),\n\t\t.seq = {\n\t\t\tSTFSM_INST_CMD1,\n\t\t\tSTFSM_INST_CMD2,\n\t\t\tSTFSM_INST_WAIT,\n\t\t\tSTFSM_INST_STOP,\n\t\t},\n\t\t.seq_cfg = (SEQ_CFG_PADS_1 |\n\t\t\t    SEQ_CFG_ERASE |\n\t\t\t    SEQ_CFG_READNOTWRITE |\n\t\t\t    SEQ_CFG_CSDEASSERT |\n\t\t\t    SEQ_CFG_STARTSEQ),\n\t};\n\n\tstfsm_load_seq(fsm, &seq);\n\n\tstfsm_wait_seq(fsm);\n\n\treturn 0;\n}\n\nstatic int stfsm_s25fl_config(struct stfsm *fsm)\n{\n\tstruct flash_info *info = fsm->info;\n\tuint32_t flags = info->flags;\n\tuint32_t data_pads;\n\tuint32_t offs;\n\tuint16_t sta_wr;\n\tuint8_t sr1, cr1, dyb;\n\tint update_sr = 0;\n\tint ret;\n\n\tif (flags & FLASH_FLAG_32BIT_ADDR) {\n\t\t \n\t\tret = stfsm_search_prepare_rw_seq(fsm, &fsm->stfsm_seq_read,\n\t\t\t\t\t\t  stfsm_s25fl_read4_configs);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = stfsm_search_prepare_rw_seq(fsm, &fsm->stfsm_seq_write,\n\t\t\t\t\t\t  stfsm_s25fl_write4_configs);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tstfsm_s25fl_prepare_erasesec_seq_32(&stfsm_seq_erase_sector);\n\n\t} else {\n\t\t \n\t\tret = stfsm_prepare_rwe_seqs_default(fsm);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\tif (flags & FLASH_FLAG_DYB_LOCKING) {\n\t\toffs = 0;\n\t\tfor (offs = 0; offs < info->sector_size * info->n_sectors;) {\n\t\t\tstfsm_s25fl_read_dyb(fsm, offs, &dyb);\n\t\t\tif (dyb == 0x00)\n\t\t\t\tstfsm_s25fl_write_dyb(fsm, offs, 0xff);\n\n\t\t\t \n\t\t\tif ((offs < info->sector_size * 2) ||\n\t\t\t    (offs >= (info->sector_size - info->n_sectors * 4)))\n\t\t\t\toffs += 0x1000;\n\t\t\telse\n\t\t\t\toffs += 0x10000;\n\t\t}\n\t}\n\n\t \n\tstfsm_read_status(fsm, SPINOR_OP_RDCR, &cr1, 1);\n\tdata_pads = ((fsm->stfsm_seq_read.seq_cfg >> 16) & 0x3) + 1;\n\tif (data_pads == 4) {\n\t\tif (!(cr1 & STFSM_S25FL_CONFIG_QE)) {\n\t\t\t \n\t\t\tcr1 |= STFSM_S25FL_CONFIG_QE;\n\n\t\t\tupdate_sr = 1;\n\t\t}\n\t} else {\n\t\tif (cr1 & STFSM_S25FL_CONFIG_QE) {\n\t\t\t \n\t\t\tcr1 &= ~STFSM_S25FL_CONFIG_QE;\n\n\t\t\tupdate_sr = 1;\n\t\t}\n\t}\n\tif (update_sr) {\n\t\tstfsm_read_status(fsm, SPINOR_OP_RDSR, &sr1, 1);\n\t\tsta_wr = ((uint16_t)cr1  << 8) | sr1;\n\t\tstfsm_write_status(fsm, SPINOR_OP_WRSR, sta_wr, 2, 1);\n\t}\n\n\t \n\tfsm->configuration |= CFG_S25FL_CHECK_ERROR_FLAGS;\n\n\treturn 0;\n}\n\nstatic int stfsm_w25q_config(struct stfsm *fsm)\n{\n\tuint32_t data_pads;\n\tuint8_t sr1, sr2;\n\tuint16_t sr_wr;\n\tint update_sr = 0;\n\tint ret;\n\n\tret = stfsm_prepare_rwe_seqs_default(fsm);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tstfsm_read_status(fsm, SPINOR_OP_RDCR, &sr2, 1);\n\tdata_pads = ((fsm->stfsm_seq_read.seq_cfg >> 16) & 0x3) + 1;\n\tif (data_pads == 4) {\n\t\tif (!(sr2 & W25Q_STATUS_QE)) {\n\t\t\t \n\t\t\tsr2 |= W25Q_STATUS_QE;\n\t\t\tupdate_sr = 1;\n\t\t}\n\t} else {\n\t\tif (sr2 & W25Q_STATUS_QE) {\n\t\t\t \n\t\t\tsr2 &= ~W25Q_STATUS_QE;\n\t\t\tupdate_sr = 1;\n\t\t}\n\t}\n\tif (update_sr) {\n\t\t \n\t\tstfsm_read_status(fsm, SPINOR_OP_RDSR, &sr1, 1);\n\t\tsr_wr = ((uint16_t)sr2 << 8) | sr1;\n\t\tstfsm_write_status(fsm, SPINOR_OP_WRSR, sr_wr, 2, 1);\n\t}\n\n\treturn 0;\n}\n\nstatic int stfsm_read(struct stfsm *fsm, uint8_t *buf, uint32_t size,\n\t\t      uint32_t offset)\n{\n\tstruct stfsm_seq *seq = &fsm->stfsm_seq_read;\n\tuint32_t data_pads;\n\tuint32_t read_mask;\n\tuint32_t size_ub;\n\tuint32_t size_lb;\n\tuint32_t size_mop;\n\tuint32_t tmp[4];\n\tuint32_t page_buf[FLASH_PAGESIZE_32];\n\tuint8_t *p;\n\n\tdev_dbg(fsm->dev, \"reading %d bytes from 0x%08x\\n\", size, offset);\n\n\t \n\tif (fsm->configuration & CFG_READ_TOGGLE_32BIT_ADDR)\n\t\tstfsm_enter_32bit_addr(fsm, 1);\n\n\t \n\tdata_pads = ((seq->seq_cfg >> 16) & 0x3) + 1;\n\tread_mask = (data_pads << 2) - 1;\n\n\t \n\tp = ((uintptr_t)buf & 0x3) ? (uint8_t *)page_buf : buf;\n\n\t \n\tsize_ub = (size + read_mask) & ~read_mask;\n\tsize_lb = size & ~read_mask;\n\tsize_mop = size & read_mask;\n\n\tseq->data_size = TRANSFER_SIZE(size_ub);\n\tseq->addr1 = (offset >> 16) & 0xffff;\n\tseq->addr2 = offset & 0xffff;\n\n\tstfsm_load_seq(fsm, seq);\n\n\tif (size_lb)\n\t\tstfsm_read_fifo(fsm, (uint32_t *)p, size_lb);\n\n\tif (size_mop) {\n\t\tstfsm_read_fifo(fsm, tmp, read_mask + 1);\n\t\tmemcpy(p + size_lb, &tmp, size_mop);\n\t}\n\n\t \n\tif ((uintptr_t)buf & 0x3)\n\t\tmemcpy(buf, page_buf, size);\n\n\t \n\tstfsm_wait_seq(fsm);\n\n\tstfsm_clear_fifo(fsm);\n\n\t \n\tif (fsm->configuration & CFG_READ_TOGGLE_32BIT_ADDR)\n\t\tstfsm_enter_32bit_addr(fsm, 0);\n\n\treturn 0;\n}\n\nstatic int stfsm_write(struct stfsm *fsm, const uint8_t *buf,\n\t\t       uint32_t size, uint32_t offset)\n{\n\tstruct stfsm_seq *seq = &fsm->stfsm_seq_write;\n\tuint32_t data_pads;\n\tuint32_t write_mask;\n\tuint32_t size_ub;\n\tuint32_t size_lb;\n\tuint32_t size_mop;\n\tuint32_t tmp[4];\n\tuint32_t i;\n\tuint32_t page_buf[FLASH_PAGESIZE_32];\n\tuint8_t *t = (uint8_t *)&tmp;\n\tconst uint8_t *p;\n\tint ret;\n\n\tdev_dbg(fsm->dev, \"writing %d bytes to 0x%08x\\n\", size, offset);\n\n\t \n\tif (fsm->configuration & CFG_WRITE_TOGGLE_32BIT_ADDR)\n\t\tstfsm_enter_32bit_addr(fsm, 1);\n\n\t \n\tdata_pads = ((seq->seq_cfg >> 16) & 0x3) + 1;\n\twrite_mask = (data_pads << 2) - 1;\n\n\t \n\tif ((uintptr_t)buf & 0x3) {\n\t\tmemcpy(page_buf, buf, size);\n\t\tp = (uint8_t *)page_buf;\n\t} else {\n\t\tp = buf;\n\t}\n\n\t \n\tsize_ub = (size + write_mask) & ~write_mask;\n\tsize_lb = size & ~write_mask;\n\tsize_mop = size & write_mask;\n\n\tseq->data_size = TRANSFER_SIZE(size_ub);\n\tseq->addr1 = (offset >> 16) & 0xffff;\n\tseq->addr2 = offset & 0xffff;\n\n\t \n\twritel(0x00040000, fsm->base + SPI_FAST_SEQ_CFG);\n\n\t \n\tif (fsm->fifo_dir_delay == 0)\n\t\treadl(fsm->base + SPI_FAST_SEQ_CFG);\n\telse\n\t\tudelay(fsm->fifo_dir_delay);\n\n\n\t \n\tif (size_lb) {\n\t\tstfsm_write_fifo(fsm, (uint32_t *)p, size_lb);\n\t\tp += size_lb;\n\t}\n\n\t \n\tif (size_mop) {\n\t\tmemset(t, 0xff, write_mask + 1);\t \n\t\tfor (i = 0; i < size_mop; i++)\n\t\t\tt[i] = *p++;\n\n\t\tstfsm_write_fifo(fsm, tmp, write_mask + 1);\n\t}\n\n\t \n\tstfsm_load_seq(fsm, seq);\n\n\t \n\tstfsm_wait_seq(fsm);\n\n\t \n\tret = stfsm_wait_busy(fsm);\n\tif (ret && fsm->configuration & CFG_S25FL_CHECK_ERROR_FLAGS)\n\t\tstfsm_s25fl_clear_status_reg(fsm);\n\n\t \n\tif (fsm->configuration & CFG_WRITE_TOGGLE_32BIT_ADDR)\n\t\tstfsm_enter_32bit_addr(fsm, 0);\n\n\treturn 0;\n}\n\n \nstatic int stfsm_mtd_read(struct mtd_info *mtd, loff_t from, size_t len,\n\t\t\t  size_t *retlen, u_char *buf)\n{\n\tstruct stfsm *fsm = dev_get_drvdata(mtd->dev.parent);\n\tuint32_t bytes;\n\n\tdev_dbg(fsm->dev, \"%s from 0x%08x, len %zd\\n\",\n\t\t__func__, (u32)from, len);\n\n\tmutex_lock(&fsm->lock);\n\n\twhile (len > 0) {\n\t\tbytes = min_t(size_t, len, FLASH_PAGESIZE);\n\n\t\tstfsm_read(fsm, buf, bytes, from);\n\n\t\tbuf += bytes;\n\t\tfrom += bytes;\n\t\tlen -= bytes;\n\n\t\t*retlen += bytes;\n\t}\n\n\tmutex_unlock(&fsm->lock);\n\n\treturn 0;\n}\n\nstatic int stfsm_erase_sector(struct stfsm *fsm, uint32_t offset)\n{\n\tstruct stfsm_seq *seq = &stfsm_seq_erase_sector;\n\tint ret;\n\n\tdev_dbg(fsm->dev, \"erasing sector at 0x%08x\\n\", offset);\n\n\t \n\tif (fsm->configuration & CFG_ERASESEC_TOGGLE_32BIT_ADDR)\n\t\tstfsm_enter_32bit_addr(fsm, 1);\n\n\tseq->addr1 = (offset >> 16) & 0xffff;\n\tseq->addr2 = offset & 0xffff;\n\n\tstfsm_load_seq(fsm, seq);\n\n\tstfsm_wait_seq(fsm);\n\n\t \n\tret = stfsm_wait_busy(fsm);\n\tif (ret && fsm->configuration & CFG_S25FL_CHECK_ERROR_FLAGS)\n\t\tstfsm_s25fl_clear_status_reg(fsm);\n\n\t \n\tif (fsm->configuration & CFG_ERASESEC_TOGGLE_32BIT_ADDR)\n\t\tstfsm_enter_32bit_addr(fsm, 0);\n\n\treturn ret;\n}\n\nstatic int stfsm_erase_chip(struct stfsm *fsm)\n{\n\tconst struct stfsm_seq *seq = &stfsm_seq_erase_chip;\n\n\tdev_dbg(fsm->dev, \"erasing chip\\n\");\n\n\tstfsm_load_seq(fsm, seq);\n\n\tstfsm_wait_seq(fsm);\n\n\treturn stfsm_wait_busy(fsm);\n}\n\n \nstatic int stfsm_mtd_write(struct mtd_info *mtd, loff_t to, size_t len,\n\t\t\t   size_t *retlen, const u_char *buf)\n{\n\tstruct stfsm *fsm = dev_get_drvdata(mtd->dev.parent);\n\n\tu32 page_offs;\n\tu32 bytes;\n\tuint8_t *b = (uint8_t *)buf;\n\tint ret = 0;\n\n\tdev_dbg(fsm->dev, \"%s to 0x%08x, len %zd\\n\", __func__, (u32)to, len);\n\n\t \n\tpage_offs = to % FLASH_PAGESIZE;\n\n\tmutex_lock(&fsm->lock);\n\n\twhile (len) {\n\t\t \n\t\tbytes = min_t(size_t, FLASH_PAGESIZE - page_offs, len);\n\n\t\tret = stfsm_write(fsm, b, bytes, to);\n\t\tif (ret)\n\t\t\tgoto out1;\n\n\t\tb += bytes;\n\t\tlen -= bytes;\n\t\tto += bytes;\n\n\t\t \n\t\tpage_offs = 0;\n\n\t\t*retlen += bytes;\n\n\t}\n\nout1:\n\tmutex_unlock(&fsm->lock);\n\n\treturn ret;\n}\n\n \nstatic int stfsm_mtd_erase(struct mtd_info *mtd, struct erase_info *instr)\n{\n\tstruct stfsm *fsm = dev_get_drvdata(mtd->dev.parent);\n\tu32 addr, len;\n\tint ret;\n\n\tdev_dbg(fsm->dev, \"%s at 0x%llx, len %lld\\n\", __func__,\n\t\t(long long)instr->addr, (long long)instr->len);\n\n\taddr = instr->addr;\n\tlen = instr->len;\n\n\tmutex_lock(&fsm->lock);\n\n\t \n\tif (len == mtd->size) {\n\t\tret = stfsm_erase_chip(fsm);\n\t\tif (ret)\n\t\t\tgoto out1;\n\t} else {\n\t\twhile (len) {\n\t\t\tret = stfsm_erase_sector(fsm, addr);\n\t\t\tif (ret)\n\t\t\t\tgoto out1;\n\n\t\t\taddr += mtd->erasesize;\n\t\t\tlen -= mtd->erasesize;\n\t\t}\n\t}\n\n\tmutex_unlock(&fsm->lock);\n\n\treturn 0;\n\nout1:\n\tmutex_unlock(&fsm->lock);\n\n\treturn ret;\n}\n\nstatic void stfsm_read_jedec(struct stfsm *fsm, uint8_t *jedec)\n{\n\tconst struct stfsm_seq *seq = &stfsm_seq_read_jedec;\n\tuint32_t tmp[2];\n\n\tstfsm_load_seq(fsm, seq);\n\n\tstfsm_read_fifo(fsm, tmp, 8);\n\n\tmemcpy(jedec, tmp, 5);\n\n\tstfsm_wait_seq(fsm);\n}\n\nstatic struct flash_info *stfsm_jedec_probe(struct stfsm *fsm)\n{\n\tstruct flash_info\t*info;\n\tu16                     ext_jedec;\n\tu32\t\t\tjedec;\n\tu8\t\t\tid[5];\n\n\tstfsm_read_jedec(fsm, id);\n\n\tjedec     = id[0] << 16 | id[1] << 8 | id[2];\n\t \n\text_jedec = id[3] << 8  | id[4];\n\n\tdev_dbg(fsm->dev, \"JEDEC =  0x%08x [%5ph]\\n\", jedec, id);\n\n\tfor (info = flash_types; info->name; info++) {\n\t\tif (info->jedec_id == jedec) {\n\t\t\tif (info->ext_id && info->ext_id != ext_jedec)\n\t\t\t\tcontinue;\n\t\t\treturn info;\n\t\t}\n\t}\n\tdev_err(fsm->dev, \"Unrecognized JEDEC id %06x\\n\", jedec);\n\n\treturn NULL;\n}\n\nstatic int stfsm_set_mode(struct stfsm *fsm, uint32_t mode)\n{\n\tint ret, timeout = 10;\n\n\t \n\twhile (--timeout) {\n\t\tret = readl(fsm->base + SPI_STA_MODE_CHANGE);\n\t\tif (ret & 0x1)\n\t\t\tbreak;\n\t\tudelay(1);\n\t}\n\n\tif (!timeout)\n\t\treturn -EBUSY;\n\n\twritel(mode, fsm->base + SPI_MODESELECT);\n\n\treturn 0;\n}\n\nstatic void stfsm_set_freq(struct stfsm *fsm, uint32_t spi_freq)\n{\n\tuint32_t emi_freq;\n\tuint32_t clk_div;\n\n\temi_freq = clk_get_rate(fsm->clk);\n\n\t \n\tclk_div = 2 * DIV_ROUND_UP(emi_freq, 2 * spi_freq);\n\tif (clk_div < 2)\n\t\tclk_div = 2;\n\telse if (clk_div > 128)\n\t\tclk_div = 128;\n\n\t \n\tif (clk_div <= 4)\n\t\tfsm->fifo_dir_delay = 0;\n\telse if (clk_div <= 10)\n\t\tfsm->fifo_dir_delay = 1;\n\telse\n\t\tfsm->fifo_dir_delay = DIV_ROUND_UP(clk_div, 10);\n\n\tdev_dbg(fsm->dev, \"emi_clk = %uHZ, spi_freq = %uHZ, clk_div = %u\\n\",\n\t\temi_freq, spi_freq, clk_div);\n\n\twritel(clk_div, fsm->base + SPI_CLOCKDIV);\n}\n\nstatic int stfsm_init(struct stfsm *fsm)\n{\n\tint ret;\n\n\t \n\twritel(SEQ_CFG_SWRESET, fsm->base + SPI_FAST_SEQ_CFG);\n\tudelay(1);\n\twritel(0, fsm->base + SPI_FAST_SEQ_CFG);\n\n\t \n\tstfsm_set_freq(fsm, STFSM_FLASH_SAFE_FREQ);\n\n\t \n\tret = stfsm_set_mode(fsm, SPI_MODESELECT_FSM);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\twritel(SPI_CFG_DEVICE_ST            |\n\t       SPI_CFG_DEFAULT_MIN_CS_HIGH  |\n\t       SPI_CFG_DEFAULT_CS_SETUPHOLD |\n\t       SPI_CFG_DEFAULT_DATA_HOLD,\n\t       fsm->base + SPI_CONFIGDATA);\n\twritel(STFSM_DEFAULT_WR_TIME, fsm->base + SPI_STATUS_WR_TIME_REG);\n\n\t \n\twritel(0x00000001, fsm->base + SPI_PROGRAM_ERASE_TIME);\n\n\t \n\tstfsm_clear_fifo(fsm);\n\n\treturn 0;\n}\n\nstatic void stfsm_fetch_platform_configs(struct platform_device *pdev)\n{\n\tstruct stfsm *fsm = platform_get_drvdata(pdev);\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct regmap *regmap;\n\tuint32_t boot_device_reg;\n\tuint32_t boot_device_spi;\n\tuint32_t boot_device;      \n\tint ret;\n\n\t \n\tfsm->booted_from_spi = true;\n\n\tregmap = syscon_regmap_lookup_by_phandle(np, \"st,syscfg\");\n\tif (IS_ERR(regmap))\n\t\tgoto boot_device_fail;\n\n\tfsm->reset_signal = of_property_read_bool(np, \"st,reset-signal\");\n\n\tfsm->reset_por = of_property_read_bool(np, \"st,reset-por\");\n\n\t \n\tret = of_property_read_u32(np, \"st,boot-device-reg\", &boot_device_reg);\n\tif (ret)\n\t\tgoto boot_device_fail;\n\n\t \n\tret = of_property_read_u32(np, \"st,boot-device-spi\", &boot_device_spi);\n\tif (ret)\n\t\tgoto boot_device_fail;\n\n\tret = regmap_read(regmap, boot_device_reg, &boot_device);\n\tif (ret)\n\t\tgoto boot_device_fail;\n\n\tif (boot_device != boot_device_spi)\n\t\tfsm->booted_from_spi = false;\n\n\treturn;\n\nboot_device_fail:\n\tdev_warn(&pdev->dev,\n\t\t \"failed to fetch boot device, assuming boot from SPI\\n\");\n}\n\nstatic int stfsm_probe(struct platform_device *pdev)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct flash_info *info;\n\tstruct stfsm *fsm;\n\tint ret;\n\n\tif (!np) {\n\t\tdev_err(&pdev->dev, \"No DT found\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tfsm = devm_kzalloc(&pdev->dev, sizeof(*fsm), GFP_KERNEL);\n\tif (!fsm)\n\t\treturn -ENOMEM;\n\n\tfsm->dev = &pdev->dev;\n\n\tplatform_set_drvdata(pdev, fsm);\n\n\tfsm->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(fsm->base))\n\t\treturn PTR_ERR(fsm->base);\n\n\tfsm->clk = devm_clk_get_enabled(&pdev->dev, NULL);\n\tif (IS_ERR(fsm->clk)) {\n\t\tdev_err(fsm->dev, \"Couldn't find EMI clock.\\n\");\n\t\treturn PTR_ERR(fsm->clk);\n\t}\n\n\tmutex_init(&fsm->lock);\n\n\tret = stfsm_init(fsm);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Failed to initialise FSM Controller\\n\");\n\t\treturn ret;\n\t}\n\n\tstfsm_fetch_platform_configs(pdev);\n\n\t \n\tinfo = stfsm_jedec_probe(fsm);\n\tif (!info)\n\t\treturn -ENODEV;\n\tfsm->info = info;\n\n\t \n\tif (info->sector_size * info->n_sectors > 0x1000000)\n\t\tinfo->flags |= FLASH_FLAG_32BIT_ADDR;\n\n\t \n\tif (info->config)\n\t\tret = info->config(fsm);\n\telse\n\t\tret = stfsm_prepare_rwe_seqs_default(fsm);\n\tif (ret)\n\t\treturn ret;\n\n\tfsm->mtd.name\t\t= info->name;\n\tfsm->mtd.dev.parent\t= &pdev->dev;\n\tmtd_set_of_node(&fsm->mtd, np);\n\tfsm->mtd.type\t\t= MTD_NORFLASH;\n\tfsm->mtd.writesize\t= 4;\n\tfsm->mtd.writebufsize\t= fsm->mtd.writesize;\n\tfsm->mtd.flags\t\t= MTD_CAP_NORFLASH;\n\tfsm->mtd.size\t\t= info->sector_size * info->n_sectors;\n\tfsm->mtd.erasesize\t= info->sector_size;\n\n\tfsm->mtd._read  = stfsm_mtd_read;\n\tfsm->mtd._write = stfsm_mtd_write;\n\tfsm->mtd._erase = stfsm_mtd_erase;\n\n\tdev_info(&pdev->dev,\n\t\t\"Found serial flash device: %s\\n\"\n\t\t\" size = %llx (%lldMiB) erasesize = 0x%08x (%uKiB)\\n\",\n\t\tinfo->name,\n\t\t(long long)fsm->mtd.size, (long long)(fsm->mtd.size >> 20),\n\t\tfsm->mtd.erasesize, (fsm->mtd.erasesize >> 10));\n\n\treturn mtd_device_register(&fsm->mtd, NULL, 0);\n}\n\nstatic int stfsm_remove(struct platform_device *pdev)\n{\n\tstruct stfsm *fsm = platform_get_drvdata(pdev);\n\n\tWARN_ON(mtd_device_unregister(&fsm->mtd));\n\n\treturn 0;\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int stfsmfsm_suspend(struct device *dev)\n{\n\tstruct stfsm *fsm = dev_get_drvdata(dev);\n\n\tclk_disable_unprepare(fsm->clk);\n\n\treturn 0;\n}\n\nstatic int stfsmfsm_resume(struct device *dev)\n{\n\tstruct stfsm *fsm = dev_get_drvdata(dev);\n\n\treturn clk_prepare_enable(fsm->clk);\n}\n#endif\n\nstatic SIMPLE_DEV_PM_OPS(stfsm_pm_ops, stfsmfsm_suspend, stfsmfsm_resume);\n\nstatic const struct of_device_id stfsm_match[] = {\n\t{ .compatible = \"st,spi-fsm\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, stfsm_match);\n\nstatic struct platform_driver stfsm_driver = {\n\t.probe\t\t= stfsm_probe,\n\t.remove\t\t= stfsm_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"st-spi-fsm\",\n\t\t.of_match_table = stfsm_match,\n\t\t.pm     = &stfsm_pm_ops,\n\t},\n};\nmodule_platform_driver(stfsm_driver);\n\nMODULE_AUTHOR(\"Angus Clark <angus.clark@st.com>\");\nMODULE_DESCRIPTION(\"ST SPI FSM driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}