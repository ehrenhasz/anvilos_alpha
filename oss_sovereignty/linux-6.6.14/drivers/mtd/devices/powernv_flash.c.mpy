{
  "module_name": "powernv_flash.c",
  "hash_id": "6442d5907bf9e05b76af2648ad0df399978e26e2a8b543db71a29c4cb1f694c3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/devices/powernv_flash.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/platform_device.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mtd/mtd.h>\n#include <linux/mtd/partitions.h>\n\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n\n#include <asm/opal.h>\n\n\n \n\nstruct powernv_flash {\n\tstruct mtd_info\tmtd;\n\tu32 id;\n};\n\nenum flash_op {\n\tFLASH_OP_READ,\n\tFLASH_OP_WRITE,\n\tFLASH_OP_ERASE,\n};\n\n \nstatic int powernv_flash_async_op(struct mtd_info *mtd, enum flash_op op,\n\t\tloff_t offset, size_t len, size_t *retlen, u_char *buf)\n{\n\tstruct powernv_flash *info = (struct powernv_flash *)mtd->priv;\n\tstruct device *dev = &mtd->dev;\n\tint token;\n\tstruct opal_msg msg;\n\tint rc;\n\n\tdev_dbg(dev, \"%s(op=%d, offset=0x%llx, len=%zu)\\n\",\n\t\t\t__func__, op, offset, len);\n\n\ttoken = opal_async_get_token_interruptible();\n\tif (token < 0) {\n\t\tif (token != -ERESTARTSYS)\n\t\t\tdev_err(dev, \"Failed to get an async token\\n\");\n\t\telse\n\t\t\ttoken = -EINTR;\n\t\treturn token;\n\t}\n\n\tswitch (op) {\n\tcase FLASH_OP_READ:\n\t\trc = opal_flash_read(info->id, offset, __pa(buf), len, token);\n\t\tbreak;\n\tcase FLASH_OP_WRITE:\n\t\trc = opal_flash_write(info->id, offset, __pa(buf), len, token);\n\t\tbreak;\n\tcase FLASH_OP_ERASE:\n\t\trc = opal_flash_erase(info->id, offset, len, token);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\topal_async_release_token(token);\n\t\treturn -EIO;\n\t}\n\n\tif (rc == OPAL_ASYNC_COMPLETION) {\n\t\trc = opal_async_wait_response_interruptible(token, &msg);\n\t\tif (rc) {\n\t\t\t \n\t\t\trc = -EINTR;\n\t\t\tif (opal_async_wait_response(token, &msg))\n\t\t\t\tdev_err(dev, \"opal_async_wait_response() failed\\n\");\n\t\t\tgoto out;\n\t\t}\n\t\trc = opal_get_async_rc(msg);\n\t}\n\n\t \n\tif (rc != OPAL_SUCCESS && rc != OPAL_BUSY)\n\t\tdev_err(dev, \"opal_flash_async_op(op=%d) failed (rc %d)\\n\",\n\t\t\t\top, rc);\n\n\tif (rc == OPAL_SUCCESS && retlen)\n\t\t*retlen = len;\n\n\trc = opal_error_code(rc);\nout:\n\topal_async_release_token(token);\n\treturn rc;\n}\n\n \nstatic int powernv_flash_read(struct mtd_info *mtd, loff_t from, size_t len,\n\t     size_t *retlen, u_char *buf)\n{\n\treturn powernv_flash_async_op(mtd, FLASH_OP_READ, from,\n\t\t\tlen, retlen, buf);\n}\n\n \nstatic int powernv_flash_write(struct mtd_info *mtd, loff_t to, size_t len,\n\t\t     size_t *retlen, const u_char *buf)\n{\n\treturn powernv_flash_async_op(mtd, FLASH_OP_WRITE, to,\n\t\t\tlen, retlen, (u_char *)buf);\n}\n\n \nstatic int powernv_flash_erase(struct mtd_info *mtd, struct erase_info *erase)\n{\n\tint rc;\n\n\trc =  powernv_flash_async_op(mtd, FLASH_OP_ERASE, erase->addr,\n\t\t\terase->len, NULL, NULL);\n\tif (rc)\n\t\terase->fail_addr = erase->addr;\n\n\treturn rc;\n}\n\n \nstatic int powernv_flash_set_driver_info(struct device *dev,\n\t\tstruct mtd_info *mtd)\n{\n\tu64 size;\n\tu32 erase_size;\n\tint rc;\n\n\trc = of_property_read_u32(dev->of_node, \"ibm,flash-block-size\",\n\t\t\t&erase_size);\n\tif (rc) {\n\t\tdev_err(dev, \"couldn't get resource block size information\\n\");\n\t\treturn rc;\n\t}\n\n\trc = of_property_read_u64(dev->of_node, \"reg\", &size);\n\tif (rc) {\n\t\tdev_err(dev, \"couldn't get resource size information\\n\");\n\t\treturn rc;\n\t}\n\n\t \n\tmtd->name = devm_kasprintf(dev, GFP_KERNEL, \"%pOFP\", dev->of_node);\n\tmtd->type = MTD_NORFLASH;\n\tmtd->flags = MTD_WRITEABLE;\n\tmtd->size = size;\n\tmtd->erasesize = erase_size;\n\tmtd->writebufsize = mtd->writesize = 1;\n\tmtd->owner = THIS_MODULE;\n\tmtd->_erase = powernv_flash_erase;\n\tmtd->_read = powernv_flash_read;\n\tmtd->_write = powernv_flash_write;\n\tmtd->dev.parent = dev;\n\tmtd_set_of_node(mtd, dev->of_node);\n\treturn 0;\n}\n\n \nstatic int powernv_flash_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct powernv_flash *data;\n\tint ret;\n\n\tdata = devm_kzalloc(dev, sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tdata->mtd.priv = data;\n\n\tret = of_property_read_u32(dev->of_node, \"ibm,opal-id\", &(data->id));\n\tif (ret) {\n\t\tdev_err(dev, \"no device property 'ibm,opal-id'\\n\");\n\t\treturn ret;\n\t}\n\n\tret = powernv_flash_set_driver_info(dev, &data->mtd);\n\tif (ret)\n\t\treturn ret;\n\n\tdev_set_drvdata(dev, data);\n\n\t \n\treturn mtd_device_register(&data->mtd, NULL, 0);\n}\n\n \nstatic int powernv_flash_release(struct platform_device *pdev)\n{\n\tstruct powernv_flash *data = dev_get_drvdata(&(pdev->dev));\n\n\t \n\tWARN_ON(mtd_device_unregister(&data->mtd));\n\n\treturn 0;\n}\n\nstatic const struct of_device_id powernv_flash_match[] = {\n\t{ .compatible = \"ibm,opal-flash\" },\n\t{}\n};\n\nstatic struct platform_driver powernv_flash_driver = {\n\t.driver\t\t= {\n\t\t.name\t\t= \"powernv_flash\",\n\t\t.of_match_table\t= powernv_flash_match,\n\t},\n\t.remove\t\t= powernv_flash_release,\n\t.probe\t\t= powernv_flash_probe,\n};\n\nmodule_platform_driver(powernv_flash_driver);\n\nMODULE_DEVICE_TABLE(of, powernv_flash_match);\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Cyril Bur <cyril.bur@au1.ibm.com>\");\nMODULE_DESCRIPTION(\"MTD abstraction for OPAL flash\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}