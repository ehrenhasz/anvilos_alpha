{
  "module_name": "sst25l.c",
  "hash_id": "b2d0ee6c0f09728bba3234dff9097264cbfc2fd2da1fa9b992d994c2dfb381e2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/devices/sst25l.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/device.h>\n#include <linux/mutex.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\n#include <linux/mtd/mtd.h>\n#include <linux/mtd/partitions.h>\n\n#include <linux/spi/spi.h>\n#include <linux/spi/flash.h>\n\n \n#define MAX_READY_WAIT_JIFFIES\tmsecs_to_jiffies(3000)\n\n#define SST25L_CMD_WRSR\t\t0x01\t \n#define SST25L_CMD_WRDI\t\t0x04\t \n#define SST25L_CMD_RDSR\t\t0x05\t \n#define SST25L_CMD_WREN\t\t0x06\t \n#define SST25L_CMD_READ\t\t0x03\t \n\n#define SST25L_CMD_EWSR\t\t0x50\t \n#define SST25L_CMD_SECTOR_ERASE\t0x20\t \n#define SST25L_CMD_READ_ID\t0x90\t \n#define SST25L_CMD_AAI_PROGRAM\t0xaf\t \n\n#define SST25L_STATUS_BUSY\t(1 << 0)\t \n#define SST25L_STATUS_WREN\t(1 << 1)\t \n#define SST25L_STATUS_BP0\t(1 << 2)\t \n#define SST25L_STATUS_BP1\t(1 << 3)\t \n\nstruct sst25l_flash {\n\tstruct spi_device\t*spi;\n\tstruct mutex\t\tlock;\n\tstruct mtd_info\t\tmtd;\n};\n\nstruct flash_info {\n\tconst char\t\t*name;\n\tuint16_t\t\tdevice_id;\n\tunsigned\t\tpage_size;\n\tunsigned\t\tnr_pages;\n\tunsigned\t\terase_size;\n};\n\n#define to_sst25l_flash(x) container_of(x, struct sst25l_flash, mtd)\n\nstatic struct flash_info sst25l_flash_info[] = {\n\t{\"sst25lf020a\", 0xbf43, 256, 1024, 4096},\n\t{\"sst25lf040a\",\t0xbf44,\t256, 2048, 4096},\n};\n\nstatic int sst25l_status(struct sst25l_flash *flash, int *status)\n{\n\tstruct spi_message m;\n\tstruct spi_transfer t;\n\tunsigned char cmd_resp[2];\n\tint err;\n\n\tspi_message_init(&m);\n\tmemset(&t, 0, sizeof(struct spi_transfer));\n\n\tcmd_resp[0] = SST25L_CMD_RDSR;\n\tcmd_resp[1] = 0xff;\n\tt.tx_buf = cmd_resp;\n\tt.rx_buf = cmd_resp;\n\tt.len = sizeof(cmd_resp);\n\tspi_message_add_tail(&t, &m);\n\terr = spi_sync(flash->spi, &m);\n\tif (err < 0)\n\t\treturn err;\n\n\t*status = cmd_resp[1];\n\treturn 0;\n}\n\nstatic int sst25l_write_enable(struct sst25l_flash *flash, int enable)\n{\n\tunsigned char command[2];\n\tint status, err;\n\n\tcommand[0] = enable ? SST25L_CMD_WREN : SST25L_CMD_WRDI;\n\terr = spi_write(flash->spi, command, 1);\n\tif (err)\n\t\treturn err;\n\n\tcommand[0] = SST25L_CMD_EWSR;\n\terr = spi_write(flash->spi, command, 1);\n\tif (err)\n\t\treturn err;\n\n\tcommand[0] = SST25L_CMD_WRSR;\n\tcommand[1] = enable ? 0 : SST25L_STATUS_BP0 | SST25L_STATUS_BP1;\n\terr = spi_write(flash->spi, command, 2);\n\tif (err)\n\t\treturn err;\n\n\tif (enable) {\n\t\terr = sst25l_status(flash, &status);\n\t\tif (err)\n\t\t\treturn err;\n\t\tif (!(status & SST25L_STATUS_WREN))\n\t\t\treturn -EROFS;\n\t}\n\n\treturn 0;\n}\n\nstatic int sst25l_wait_till_ready(struct sst25l_flash *flash)\n{\n\tunsigned long deadline;\n\tint status, err;\n\n\tdeadline = jiffies + MAX_READY_WAIT_JIFFIES;\n\tdo {\n\t\terr = sst25l_status(flash, &status);\n\t\tif (err)\n\t\t\treturn err;\n\t\tif (!(status & SST25L_STATUS_BUSY))\n\t\t\treturn 0;\n\n\t\tcond_resched();\n\t} while (!time_after_eq(jiffies, deadline));\n\n\treturn -ETIMEDOUT;\n}\n\nstatic int sst25l_erase_sector(struct sst25l_flash *flash, uint32_t offset)\n{\n\tunsigned char command[4];\n\tint err;\n\n\terr = sst25l_write_enable(flash, 1);\n\tif (err)\n\t\treturn err;\n\n\tcommand[0] = SST25L_CMD_SECTOR_ERASE;\n\tcommand[1] = offset >> 16;\n\tcommand[2] = offset >> 8;\n\tcommand[3] = offset;\n\terr = spi_write(flash->spi, command, 4);\n\tif (err)\n\t\treturn err;\n\n\terr = sst25l_wait_till_ready(flash);\n\tif (err)\n\t\treturn err;\n\n\treturn sst25l_write_enable(flash, 0);\n}\n\nstatic int sst25l_erase(struct mtd_info *mtd, struct erase_info *instr)\n{\n\tstruct sst25l_flash *flash = to_sst25l_flash(mtd);\n\tuint32_t addr, end;\n\tint err;\n\n\t \n\tif ((uint32_t)instr->len % mtd->erasesize)\n\t\treturn -EINVAL;\n\n\tif ((uint32_t)instr->addr % mtd->erasesize)\n\t\treturn -EINVAL;\n\n\taddr = instr->addr;\n\tend = addr + instr->len;\n\n\tmutex_lock(&flash->lock);\n\n\terr = sst25l_wait_till_ready(flash);\n\tif (err) {\n\t\tmutex_unlock(&flash->lock);\n\t\treturn err;\n\t}\n\n\twhile (addr < end) {\n\t\terr = sst25l_erase_sector(flash, addr);\n\t\tif (err) {\n\t\t\tmutex_unlock(&flash->lock);\n\t\t\tdev_err(&flash->spi->dev, \"Erase failed\\n\");\n\t\t\treturn err;\n\t\t}\n\n\t\taddr += mtd->erasesize;\n\t}\n\n\tmutex_unlock(&flash->lock);\n\n\treturn 0;\n}\n\nstatic int sst25l_read(struct mtd_info *mtd, loff_t from, size_t len,\n\t\t       size_t *retlen, unsigned char *buf)\n{\n\tstruct sst25l_flash *flash = to_sst25l_flash(mtd);\n\tstruct spi_transfer transfer[2];\n\tstruct spi_message message;\n\tunsigned char command[4];\n\tint ret;\n\n\tspi_message_init(&message);\n\tmemset(&transfer, 0, sizeof(transfer));\n\n\tcommand[0] = SST25L_CMD_READ;\n\tcommand[1] = from >> 16;\n\tcommand[2] = from >> 8;\n\tcommand[3] = from;\n\n\ttransfer[0].tx_buf = command;\n\ttransfer[0].len = sizeof(command);\n\tspi_message_add_tail(&transfer[0], &message);\n\n\ttransfer[1].rx_buf = buf;\n\ttransfer[1].len = len;\n\tspi_message_add_tail(&transfer[1], &message);\n\n\tmutex_lock(&flash->lock);\n\n\t \n\tret = sst25l_wait_till_ready(flash);\n\tif (ret) {\n\t\tmutex_unlock(&flash->lock);\n\t\treturn ret;\n\t}\n\n\tspi_sync(flash->spi, &message);\n\n\tif (retlen && message.actual_length > sizeof(command))\n\t\t*retlen += message.actual_length - sizeof(command);\n\n\tmutex_unlock(&flash->lock);\n\treturn 0;\n}\n\nstatic int sst25l_write(struct mtd_info *mtd, loff_t to, size_t len,\n\t\t\tsize_t *retlen, const unsigned char *buf)\n{\n\tstruct sst25l_flash *flash = to_sst25l_flash(mtd);\n\tint i, j, ret, bytes, copied = 0;\n\tunsigned char command[5];\n\n\tif ((uint32_t)to % mtd->writesize)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&flash->lock);\n\n\tret = sst25l_write_enable(flash, 1);\n\tif (ret)\n\t\tgoto out;\n\n\tfor (i = 0; i < len; i += mtd->writesize) {\n\t\tret = sst25l_wait_till_ready(flash);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\t \n\t\tcommand[0] = SST25L_CMD_AAI_PROGRAM;\n\t\tcommand[1] = (to + i) >> 16;\n\t\tcommand[2] = (to + i) >> 8;\n\t\tcommand[3] = (to + i);\n\t\tcommand[4] = buf[i];\n\t\tret = spi_write(flash->spi, command, 5);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tcopied++;\n\n\t\t \n\t\tbytes = min_t(uint32_t, mtd->writesize, len - i);\n\t\tfor (j = 1; j < bytes; j++, copied++) {\n\t\t\tret = sst25l_wait_till_ready(flash);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\n\t\t\tcommand[1] = buf[i + j];\n\t\t\tret = spi_write(flash->spi, command, 2);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\tret = sst25l_write_enable(flash, 0);\n\n\tif (retlen)\n\t\t*retlen = copied;\n\n\tmutex_unlock(&flash->lock);\n\treturn ret;\n}\n\nstatic struct flash_info *sst25l_match_device(struct spi_device *spi)\n{\n\tstruct flash_info *flash_info = NULL;\n\tstruct spi_message m;\n\tstruct spi_transfer t;\n\tunsigned char cmd_resp[6];\n\tint i, err;\n\tuint16_t id;\n\n\tspi_message_init(&m);\n\tmemset(&t, 0, sizeof(struct spi_transfer));\n\n\tcmd_resp[0] = SST25L_CMD_READ_ID;\n\tcmd_resp[1] = 0;\n\tcmd_resp[2] = 0;\n\tcmd_resp[3] = 0;\n\tcmd_resp[4] = 0xff;\n\tcmd_resp[5] = 0xff;\n\tt.tx_buf = cmd_resp;\n\tt.rx_buf = cmd_resp;\n\tt.len = sizeof(cmd_resp);\n\tspi_message_add_tail(&t, &m);\n\terr = spi_sync(spi, &m);\n\tif (err < 0) {\n\t\tdev_err(&spi->dev, \"error reading device id\\n\");\n\t\treturn NULL;\n\t}\n\n\tid = (cmd_resp[4] << 8) | cmd_resp[5];\n\n\tfor (i = 0; i < ARRAY_SIZE(sst25l_flash_info); i++)\n\t\tif (sst25l_flash_info[i].device_id == id)\n\t\t\tflash_info = &sst25l_flash_info[i];\n\n\tif (!flash_info)\n\t\tdev_err(&spi->dev, \"unknown id %.4x\\n\", id);\n\n\treturn flash_info;\n}\n\nstatic int sst25l_probe(struct spi_device *spi)\n{\n\tstruct flash_info *flash_info;\n\tstruct sst25l_flash *flash;\n\tstruct flash_platform_data *data;\n\tint ret;\n\n\tflash_info = sst25l_match_device(spi);\n\tif (!flash_info)\n\t\treturn -ENODEV;\n\n\tflash = devm_kzalloc(&spi->dev, sizeof(*flash), GFP_KERNEL);\n\tif (!flash)\n\t\treturn -ENOMEM;\n\n\tflash->spi = spi;\n\tmutex_init(&flash->lock);\n\tspi_set_drvdata(spi, flash);\n\n\tdata = dev_get_platdata(&spi->dev);\n\tif (data && data->name)\n\t\tflash->mtd.name = data->name;\n\n\tflash->mtd.dev.parent   = &spi->dev;\n\tflash->mtd.type\t\t= MTD_NORFLASH;\n\tflash->mtd.flags\t= MTD_CAP_NORFLASH;\n\tflash->mtd.erasesize\t= flash_info->erase_size;\n\tflash->mtd.writesize\t= flash_info->page_size;\n\tflash->mtd.writebufsize\t= flash_info->page_size;\n\tflash->mtd.size\t\t= flash_info->page_size * flash_info->nr_pages;\n\tflash->mtd._erase\t= sst25l_erase;\n\tflash->mtd._read\t\t= sst25l_read;\n\tflash->mtd._write \t= sst25l_write;\n\n\tdev_info(&spi->dev, \"%s (%lld KiB)\\n\", flash_info->name,\n\t\t (long long)flash->mtd.size >> 10);\n\n\tpr_debug(\"mtd .name = %s, .size = 0x%llx (%lldMiB) \"\n\t      \".erasesize = 0x%.8x (%uKiB) .numeraseregions = %d\\n\",\n\t      flash->mtd.name,\n\t      (long long)flash->mtd.size, (long long)(flash->mtd.size >> 20),\n\t      flash->mtd.erasesize, flash->mtd.erasesize / 1024,\n\t      flash->mtd.numeraseregions);\n\n\n\tret = mtd_device_register(&flash->mtd, data ? data->parts : NULL,\n\t\t\t\t  data ? data->nr_parts : 0);\n\tif (ret)\n\t\treturn -ENODEV;\n\n\treturn 0;\n}\n\nstatic void sst25l_remove(struct spi_device *spi)\n{\n\tstruct sst25l_flash *flash = spi_get_drvdata(spi);\n\n\tWARN_ON(mtd_device_unregister(&flash->mtd));\n}\n\nstatic struct spi_driver sst25l_driver = {\n\t.driver = {\n\t\t.name\t= \"sst25l\",\n\t},\n\t.probe\t\t= sst25l_probe,\n\t.remove\t\t= sst25l_remove,\n};\n\nmodule_spi_driver(sst25l_driver);\n\nMODULE_DESCRIPTION(\"MTD SPI driver for SST25L Flash chips\");\nMODULE_AUTHOR(\"Andre Renaud <andre@bluewatersys.com>, \"\n\t      \"Ryan Mallon\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}