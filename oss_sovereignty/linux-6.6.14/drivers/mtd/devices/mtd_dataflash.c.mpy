{
  "module_name": "mtd_dataflash.c",
  "hash_id": "4232a867a22cbb8cc373e9f4524bb21cbdde0b4278a4f91bebeb1b8ced7083ef",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/devices/mtd_dataflash.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/mutex.h>\n#include <linux/err.h>\n#include <linux/math64.h>\n#include <linux/of.h>\n\n#include <linux/spi/spi.h>\n#include <linux/spi/flash.h>\n\n#include <linux/mtd/mtd.h>\n#include <linux/mtd/partitions.h>\n\n \n\n \n#define OP_READ_CONTINUOUS\t0xE8\n#define OP_READ_PAGE\t\t0xD2\n\n \n#define OP_READ_STATUS\t\t0xD7\t \n\n \n#define OP_READ_BUFFER1\t\t0xD4\t \n#define OP_READ_BUFFER2\t\t0xD6\t \n#define OP_WRITE_BUFFER1\t0x84\t \n#define OP_WRITE_BUFFER2\t0x87\t \n\n \n#define OP_ERASE_PAGE\t\t0x81\n#define OP_ERASE_BLOCK\t\t0x50\n\n \n#define OP_TRANSFER_BUF1\t0x53\n#define OP_TRANSFER_BUF2\t0x55\n#define OP_MREAD_BUFFER1\t0xD4\n#define OP_MREAD_BUFFER2\t0xD6\n#define OP_MWERASE_BUFFER1\t0x83\n#define OP_MWERASE_BUFFER2\t0x86\n#define OP_MWRITE_BUFFER1\t0x88\t \n#define OP_MWRITE_BUFFER2\t0x89\t \n\n \n#define OP_PROGRAM_VIA_BUF1\t0x82\n#define OP_PROGRAM_VIA_BUF2\t0x85\n\n \n#define OP_COMPARE_BUF1\t\t0x60\n#define OP_COMPARE_BUF2\t\t0x61\n\n \n#define OP_REWRITE_VIA_BUF1\t0x58\n#define OP_REWRITE_VIA_BUF2\t0x59\n\n \n#define OP_READ_ID\t\t0x9F\n#define OP_READ_SECURITY\t0x77\n#define OP_WRITE_SECURITY_REVC\t0x9A\n#define OP_WRITE_SECURITY\t0x9B\t \n\n#define CFI_MFR_ATMEL\t\t0x1F\n\n#define DATAFLASH_SHIFT_EXTID\t24\n#define DATAFLASH_SHIFT_ID\t40\n\nstruct dataflash {\n\tu8\t\t\tcommand[4];\n\tchar\t\t\tname[24];\n\n\tunsigned short\t\tpage_offset;\t \n\tunsigned int\t\tpage_size;\t \n\n\tstruct mutex\t\tlock;\n\tstruct spi_device\t*spi;\n\n\tstruct mtd_info\t\tmtd;\n};\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id dataflash_dt_ids[] = {\n\t{ .compatible = \"atmel,at45\", },\n\t{ .compatible = \"atmel,dataflash\", },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, dataflash_dt_ids);\n#endif\n\nstatic const struct spi_device_id dataflash_spi_ids[] = {\n\t{ .name = \"at45\", },\n\t{ .name = \"dataflash\", },\n\t{   }\n};\nMODULE_DEVICE_TABLE(spi, dataflash_spi_ids);\n\n \n\n \nstatic inline int dataflash_status(struct spi_device *spi)\n{\n\t \n\treturn spi_w8r8(spi, OP_READ_STATUS);\n}\n\n \nstatic int dataflash_waitready(struct spi_device *spi)\n{\n\tint\tstatus;\n\n\tfor (;;) {\n\t\tstatus = dataflash_status(spi);\n\t\tif (status < 0) {\n\t\t\tdev_dbg(&spi->dev, \"status %d?\\n\", status);\n\t\t\tstatus = 0;\n\t\t}\n\n\t\tif (status & (1 << 7))\t \n\t\t\treturn status;\n\n\t\tusleep_range(3000, 4000);\n\t}\n}\n\n \n\n \nstatic int dataflash_erase(struct mtd_info *mtd, struct erase_info *instr)\n{\n\tstruct dataflash\t*priv = mtd->priv;\n\tstruct spi_device\t*spi = priv->spi;\n\tstruct spi_transfer\tx = { };\n\tstruct spi_message\tmsg;\n\tunsigned\t\tblocksize = priv->page_size << 3;\n\tu8\t\t\t*command;\n\tu32\t\t\trem;\n\n\tdev_dbg(&spi->dev, \"erase addr=0x%llx len 0x%llx\\n\",\n\t\t(long long)instr->addr, (long long)instr->len);\n\n\tdiv_u64_rem(instr->len, priv->page_size, &rem);\n\tif (rem)\n\t\treturn -EINVAL;\n\tdiv_u64_rem(instr->addr, priv->page_size, &rem);\n\tif (rem)\n\t\treturn -EINVAL;\n\n\tspi_message_init(&msg);\n\n\tx.tx_buf = command = priv->command;\n\tx.len = 4;\n\tspi_message_add_tail(&x, &msg);\n\n\tmutex_lock(&priv->lock);\n\twhile (instr->len > 0) {\n\t\tunsigned int\tpageaddr;\n\t\tint\t\tstatus;\n\t\tint\t\tdo_block;\n\n\t\t \n\t\tpageaddr = div_u64(instr->addr, priv->page_size);\n\t\tdo_block = (pageaddr & 0x7) == 0 && instr->len >= blocksize;\n\t\tpageaddr = pageaddr << priv->page_offset;\n\n\t\tcommand[0] = do_block ? OP_ERASE_BLOCK : OP_ERASE_PAGE;\n\t\tcommand[1] = (u8)(pageaddr >> 16);\n\t\tcommand[2] = (u8)(pageaddr >> 8);\n\t\tcommand[3] = 0;\n\n\t\tdev_dbg(&spi->dev, \"ERASE %s: (%x) %x %x %x [%i]\\n\",\n\t\t\tdo_block ? \"block\" : \"page\",\n\t\t\tcommand[0], command[1], command[2], command[3],\n\t\t\tpageaddr);\n\n\t\tstatus = spi_sync(spi, &msg);\n\t\t(void) dataflash_waitready(spi);\n\n\t\tif (status < 0) {\n\t\t\tdev_err(&spi->dev, \"erase %x, err %d\\n\",\n\t\t\t\tpageaddr, status);\n\t\t\t \n\t\t\tcontinue;\n\t\t}\n\n\t\tif (do_block) {\n\t\t\tinstr->addr += blocksize;\n\t\t\tinstr->len -= blocksize;\n\t\t} else {\n\t\t\tinstr->addr += priv->page_size;\n\t\t\tinstr->len -= priv->page_size;\n\t\t}\n\t}\n\tmutex_unlock(&priv->lock);\n\n\treturn 0;\n}\n\n \nstatic int dataflash_read(struct mtd_info *mtd, loff_t from, size_t len,\n\t\t\t       size_t *retlen, u_char *buf)\n{\n\tstruct dataflash\t*priv = mtd->priv;\n\tstruct spi_transfer\tx[2] = { };\n\tstruct spi_message\tmsg;\n\tunsigned int\t\taddr;\n\tu8\t\t\t*command;\n\tint\t\t\tstatus;\n\n\tdev_dbg(&priv->spi->dev, \"read 0x%x..0x%x\\n\",\n\t\t  (unsigned int)from, (unsigned int)(from + len));\n\n\t \n\taddr = (((unsigned)from / priv->page_size) << priv->page_offset)\n\t\t+ ((unsigned)from % priv->page_size);\n\n\tcommand = priv->command;\n\n\tdev_dbg(&priv->spi->dev, \"READ: (%x) %x %x %x\\n\",\n\t\tcommand[0], command[1], command[2], command[3]);\n\n\tspi_message_init(&msg);\n\n\tx[0].tx_buf = command;\n\tx[0].len = 8;\n\tspi_message_add_tail(&x[0], &msg);\n\n\tx[1].rx_buf = buf;\n\tx[1].len = len;\n\tspi_message_add_tail(&x[1], &msg);\n\n\tmutex_lock(&priv->lock);\n\n\t \n\tcommand[0] = OP_READ_CONTINUOUS;\n\tcommand[1] = (u8)(addr >> 16);\n\tcommand[2] = (u8)(addr >> 8);\n\tcommand[3] = (u8)(addr >> 0);\n\t \n\n\tstatus = spi_sync(priv->spi, &msg);\n\tmutex_unlock(&priv->lock);\n\n\tif (status >= 0) {\n\t\t*retlen = msg.actual_length - 8;\n\t\tstatus = 0;\n\t} else\n\t\tdev_dbg(&priv->spi->dev, \"read %x..%x --> %d\\n\",\n\t\t\t(unsigned)from, (unsigned)(from + len),\n\t\t\tstatus);\n\treturn status;\n}\n\n \nstatic int dataflash_write(struct mtd_info *mtd, loff_t to, size_t len,\n\t\t\t\tsize_t * retlen, const u_char * buf)\n{\n\tstruct dataflash\t*priv = mtd->priv;\n\tstruct spi_device\t*spi = priv->spi;\n\tstruct spi_transfer\tx[2] = { };\n\tstruct spi_message\tmsg;\n\tunsigned int\t\tpageaddr, addr, offset, writelen;\n\tsize_t\t\t\tremaining = len;\n\tu_char\t\t\t*writebuf = (u_char *) buf;\n\tint\t\t\tstatus = -EINVAL;\n\tu8\t\t\t*command;\n\n\tdev_dbg(&spi->dev, \"write 0x%x..0x%x\\n\",\n\t\t(unsigned int)to, (unsigned int)(to + len));\n\n\tspi_message_init(&msg);\n\n\tx[0].tx_buf = command = priv->command;\n\tx[0].len = 4;\n\tspi_message_add_tail(&x[0], &msg);\n\n\tpageaddr = ((unsigned)to / priv->page_size);\n\toffset = ((unsigned)to % priv->page_size);\n\tif (offset + len > priv->page_size)\n\t\twritelen = priv->page_size - offset;\n\telse\n\t\twritelen = len;\n\n\tmutex_lock(&priv->lock);\n\twhile (remaining > 0) {\n\t\tdev_dbg(&spi->dev, \"write @ %i:%i len=%i\\n\",\n\t\t\tpageaddr, offset, writelen);\n\n\t\t \n\n\t\taddr = pageaddr << priv->page_offset;\n\n\t\t \n\t\tif (writelen != priv->page_size) {\n\t\t\tcommand[0] = OP_TRANSFER_BUF1;\n\t\t\tcommand[1] = (addr & 0x00FF0000) >> 16;\n\t\t\tcommand[2] = (addr & 0x0000FF00) >> 8;\n\t\t\tcommand[3] = 0;\n\n\t\t\tdev_dbg(&spi->dev, \"TRANSFER: (%x) %x %x %x\\n\",\n\t\t\t\tcommand[0], command[1], command[2], command[3]);\n\n\t\t\tstatus = spi_sync(spi, &msg);\n\t\t\tif (status < 0)\n\t\t\t\tdev_dbg(&spi->dev, \"xfer %u -> %d\\n\",\n\t\t\t\t\taddr, status);\n\n\t\t\t(void) dataflash_waitready(priv->spi);\n\t\t}\n\n\t\t \n\t\taddr += offset;\n\t\tcommand[0] = OP_PROGRAM_VIA_BUF1;\n\t\tcommand[1] = (addr & 0x00FF0000) >> 16;\n\t\tcommand[2] = (addr & 0x0000FF00) >> 8;\n\t\tcommand[3] = (addr & 0x000000FF);\n\n\t\tdev_dbg(&spi->dev, \"PROGRAM: (%x) %x %x %x\\n\",\n\t\t\tcommand[0], command[1], command[2], command[3]);\n\n\t\tx[1].tx_buf = writebuf;\n\t\tx[1].len = writelen;\n\t\tspi_message_add_tail(x + 1, &msg);\n\t\tstatus = spi_sync(spi, &msg);\n\t\tspi_transfer_del(x + 1);\n\t\tif (status < 0)\n\t\t\tdev_dbg(&spi->dev, \"pgm %u/%u -> %d\\n\",\n\t\t\t\taddr, writelen, status);\n\n\t\t(void) dataflash_waitready(priv->spi);\n\n\n#ifdef CONFIG_MTD_DATAFLASH_WRITE_VERIFY\n\n\t\t \n\t\taddr = pageaddr << priv->page_offset;\n\t\tcommand[0] = OP_COMPARE_BUF1;\n\t\tcommand[1] = (addr & 0x00FF0000) >> 16;\n\t\tcommand[2] = (addr & 0x0000FF00) >> 8;\n\t\tcommand[3] = 0;\n\n\t\tdev_dbg(&spi->dev, \"COMPARE: (%x) %x %x %x\\n\",\n\t\t\tcommand[0], command[1], command[2], command[3]);\n\n\t\tstatus = spi_sync(spi, &msg);\n\t\tif (status < 0)\n\t\t\tdev_dbg(&spi->dev, \"compare %u -> %d\\n\",\n\t\t\t\taddr, status);\n\n\t\tstatus = dataflash_waitready(priv->spi);\n\n\t\t \n\t\tif (status & (1 << 6)) {\n\t\t\tdev_err(&spi->dev, \"compare page %u, err %d\\n\",\n\t\t\t\tpageaddr, status);\n\t\t\tremaining = 0;\n\t\t\tstatus = -EIO;\n\t\t\tbreak;\n\t\t} else\n\t\t\tstatus = 0;\n\n#endif\t \n\n\t\tremaining = remaining - writelen;\n\t\tpageaddr++;\n\t\toffset = 0;\n\t\twritebuf += writelen;\n\t\t*retlen += writelen;\n\n\t\tif (remaining > priv->page_size)\n\t\t\twritelen = priv->page_size;\n\t\telse\n\t\t\twritelen = remaining;\n\t}\n\tmutex_unlock(&priv->lock);\n\n\treturn status;\n}\n\n \n\n#ifdef CONFIG_MTD_DATAFLASH_OTP\n\nstatic int dataflash_get_otp_info(struct mtd_info *mtd, size_t len,\n\t\t\t\t  size_t *retlen, struct otp_info *info)\n{\n\t \n\tinfo->start = 0;\n\tinfo->length = 64;\n\tinfo->locked = 1;\n\t*retlen = sizeof(*info);\n\treturn 0;\n}\n\nstatic ssize_t otp_read(struct spi_device *spi, unsigned base,\n\t\tu8 *buf, loff_t off, size_t len)\n{\n\tstruct spi_message\tm;\n\tsize_t\t\t\tl;\n\tu8\t\t\t*scratch;\n\tstruct spi_transfer\tt;\n\tint\t\t\tstatus;\n\n\tif (off > 64)\n\t\treturn -EINVAL;\n\n\tif ((off + len) > 64)\n\t\tlen = 64 - off;\n\n\tspi_message_init(&m);\n\n\tl = 4 + base + off + len;\n\tscratch = kzalloc(l, GFP_KERNEL);\n\tif (!scratch)\n\t\treturn -ENOMEM;\n\n\t \n\tscratch[0] = OP_READ_SECURITY;\n\n\tmemset(&t, 0, sizeof t);\n\tt.tx_buf = scratch;\n\tt.rx_buf = scratch;\n\tt.len = l;\n\tspi_message_add_tail(&t, &m);\n\n\tdataflash_waitready(spi);\n\n\tstatus = spi_sync(spi, &m);\n\tif (status >= 0) {\n\t\tmemcpy(buf, scratch + 4 + base + off, len);\n\t\tstatus = len;\n\t}\n\n\tkfree(scratch);\n\treturn status;\n}\n\nstatic int dataflash_read_fact_otp(struct mtd_info *mtd,\n\t\tloff_t from, size_t len, size_t *retlen, u_char *buf)\n{\n\tstruct dataflash\t*priv = mtd->priv;\n\tint\t\t\tstatus;\n\n\t \n\tmutex_lock(&priv->lock);\n\tstatus = otp_read(priv->spi, 64, buf, from, len);\n\tmutex_unlock(&priv->lock);\n\n\tif (status < 0)\n\t\treturn status;\n\t*retlen = status;\n\treturn 0;\n}\n\nstatic int dataflash_read_user_otp(struct mtd_info *mtd,\n\t\tloff_t from, size_t len, size_t *retlen, u_char *buf)\n{\n\tstruct dataflash\t*priv = mtd->priv;\n\tint\t\t\tstatus;\n\n\t \n\tmutex_lock(&priv->lock);\n\tstatus = otp_read(priv->spi, 0, buf, from, len);\n\tmutex_unlock(&priv->lock);\n\n\tif (status < 0)\n\t\treturn status;\n\t*retlen = status;\n\treturn 0;\n}\n\nstatic int dataflash_write_user_otp(struct mtd_info *mtd,\n\t\tloff_t from, size_t len, size_t *retlen, const u_char *buf)\n{\n\tstruct spi_message\tm;\n\tconst size_t\t\tl = 4 + 64;\n\tu8\t\t\t*scratch;\n\tstruct spi_transfer\tt;\n\tstruct dataflash\t*priv = mtd->priv;\n\tint\t\t\tstatus;\n\n\tif (from >= 64) {\n\t\t \n\t\t*retlen = 0;\n\t\treturn 0;\n\t}\n\n\t \n\tif ((from + len) > 64)\n\t\tlen = 64 - from;\n\n\t \n\tscratch = kzalloc(l, GFP_KERNEL);\n\tif (!scratch)\n\t\treturn -ENOMEM;\n\tscratch[0] = OP_WRITE_SECURITY;\n\tmemcpy(scratch + 4 + from, buf, len);\n\n\tspi_message_init(&m);\n\n\tmemset(&t, 0, sizeof t);\n\tt.tx_buf = scratch;\n\tt.len = l;\n\tspi_message_add_tail(&t, &m);\n\n\t \n\tmutex_lock(&priv->lock);\n\tdataflash_waitready(priv->spi);\n\tstatus = spi_sync(priv->spi, &m);\n\tmutex_unlock(&priv->lock);\n\n\tkfree(scratch);\n\n\tif (status >= 0) {\n\t\tstatus = 0;\n\t\t*retlen = len;\n\t}\n\treturn status;\n}\n\nstatic char *otp_setup(struct mtd_info *device, char revision)\n{\n\tdevice->_get_fact_prot_info = dataflash_get_otp_info;\n\tdevice->_read_fact_prot_reg = dataflash_read_fact_otp;\n\tdevice->_get_user_prot_info = dataflash_get_otp_info;\n\tdevice->_read_user_prot_reg = dataflash_read_user_otp;\n\n\t \n\tif (revision > 'c')\n\t\tdevice->_write_user_prot_reg = dataflash_write_user_otp;\n\n\treturn \", OTP\";\n}\n\n#else\n\nstatic char *otp_setup(struct mtd_info *device, char revision)\n{\n\treturn \" (OTP)\";\n}\n\n#endif\n\n \n\n \nstatic int add_dataflash_otp(struct spi_device *spi, char *name, int nr_pages,\n\t\t\t     int pagesize, int pageoffset, char revision)\n{\n\tstruct dataflash\t\t*priv;\n\tstruct mtd_info\t\t\t*device;\n\tstruct flash_platform_data\t*pdata = dev_get_platdata(&spi->dev);\n\tchar\t\t\t\t*otp_tag = \"\";\n\tint\t\t\t\terr = 0;\n\n\tpriv = kzalloc(sizeof *priv, GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&priv->lock);\n\tpriv->spi = spi;\n\tpriv->page_size = pagesize;\n\tpriv->page_offset = pageoffset;\n\n\t \n\tsprintf(priv->name, \"spi%d.%d-%s\",\n\t\t\tspi->master->bus_num, spi_get_chipselect(spi, 0),\n\t\t\tname);\n\n\tdevice = &priv->mtd;\n\tdevice->name = (pdata && pdata->name) ? pdata->name : priv->name;\n\tdevice->size = nr_pages * pagesize;\n\tdevice->erasesize = pagesize;\n\tdevice->writesize = pagesize;\n\tdevice->type = MTD_DATAFLASH;\n\tdevice->flags = MTD_WRITEABLE;\n\tdevice->_erase = dataflash_erase;\n\tdevice->_read = dataflash_read;\n\tdevice->_write = dataflash_write;\n\tdevice->priv = priv;\n\n\tdevice->dev.parent = &spi->dev;\n\tmtd_set_of_node(device, spi->dev.of_node);\n\n\tif (revision >= 'c')\n\t\totp_tag = otp_setup(device, revision);\n\n\tdev_info(&spi->dev, \"%s (%lld KBytes) pagesize %d bytes%s\\n\",\n\t\t\tname, (long long)((device->size + 1023) >> 10),\n\t\t\tpagesize, otp_tag);\n\tspi_set_drvdata(spi, priv);\n\n\terr = mtd_device_register(device,\n\t\t\tpdata ? pdata->parts : NULL,\n\t\t\tpdata ? pdata->nr_parts : 0);\n\n\tif (!err)\n\t\treturn 0;\n\n\tkfree(priv);\n\treturn err;\n}\n\nstatic inline int add_dataflash(struct spi_device *spi, char *name,\n\t\t\t\tint nr_pages, int pagesize, int pageoffset)\n{\n\treturn add_dataflash_otp(spi, name, nr_pages, pagesize,\n\t\t\tpageoffset, 0);\n}\n\nstruct flash_info {\n\tchar\t\t*name;\n\n\t \n\tu64\t\tjedec_id;\n\n\t \n\tunsigned\tnr_pages;\n\tu16\t\tpagesize;\n\tu16\t\tpageoffset;\n\n\tu16\t\tflags;\n#define SUP_EXTID\t0x0004\t\t \n#define SUP_POW2PS\t0x0002\t\t \n#define IS_POW2PS\t0x0001\t\t \n};\n\nstatic struct flash_info dataflash_data[] = {\n\n\t \n\t{ \"AT45DB011B\",  0x1f2200, 512, 264, 9, SUP_POW2PS},\n\t{ \"at45db011d\",  0x1f2200, 512, 256, 8, SUP_POW2PS | IS_POW2PS},\n\n\t{ \"AT45DB021B\",  0x1f2300, 1024, 264, 9, SUP_POW2PS},\n\t{ \"at45db021d\",  0x1f2300, 1024, 256, 8, SUP_POW2PS | IS_POW2PS},\n\n\t{ \"AT45DB041x\",  0x1f2400, 2048, 264, 9, SUP_POW2PS},\n\t{ \"at45db041d\",  0x1f2400, 2048, 256, 8, SUP_POW2PS | IS_POW2PS},\n\n\t{ \"AT45DB081B\",  0x1f2500, 4096, 264, 9, SUP_POW2PS},\n\t{ \"at45db081d\",  0x1f2500, 4096, 256, 8, SUP_POW2PS | IS_POW2PS},\n\n\t{ \"AT45DB161x\",  0x1f2600, 4096, 528, 10, SUP_POW2PS},\n\t{ \"at45db161d\",  0x1f2600, 4096, 512, 9, SUP_POW2PS | IS_POW2PS},\n\n\t{ \"AT45DB321x\",  0x1f2700, 8192, 528, 10, 0},\t\t \n\n\t{ \"AT45DB321x\",  0x1f2701, 8192, 528, 10, SUP_POW2PS},\n\t{ \"at45db321d\",  0x1f2701, 8192, 512, 9, SUP_POW2PS | IS_POW2PS},\n\n\t{ \"AT45DB642x\",  0x1f2800, 8192, 1056, 11, SUP_POW2PS},\n\t{ \"at45db642d\",  0x1f2800, 8192, 1024, 10, SUP_POW2PS | IS_POW2PS},\n\n\t{ \"AT45DB641E\",  0x1f28000100ULL, 32768, 264, 9, SUP_EXTID | SUP_POW2PS},\n\t{ \"at45db641e\",  0x1f28000100ULL, 32768, 256, 8, SUP_EXTID | SUP_POW2PS | IS_POW2PS},\n};\n\nstatic struct flash_info *jedec_lookup(struct spi_device *spi,\n\t\t\t\t       u64 jedec, bool use_extid)\n{\n\tstruct flash_info *info;\n\tint status;\n\n\tfor (info = dataflash_data;\n\t     info < dataflash_data + ARRAY_SIZE(dataflash_data);\n\t     info++) {\n\t\tif (use_extid && !(info->flags & SUP_EXTID))\n\t\t\tcontinue;\n\n\t\tif (info->jedec_id == jedec) {\n\t\t\tdev_dbg(&spi->dev, \"OTP, sector protect%s\\n\",\n\t\t\t\t(info->flags & SUP_POW2PS) ?\n\t\t\t\t\", binary pagesize\" : \"\");\n\t\t\tif (info->flags & SUP_POW2PS) {\n\t\t\t\tstatus = dataflash_status(spi);\n\t\t\t\tif (status < 0) {\n\t\t\t\t\tdev_dbg(&spi->dev, \"status error %d\\n\",\n\t\t\t\t\t\tstatus);\n\t\t\t\t\treturn ERR_PTR(status);\n\t\t\t\t}\n\t\t\t\tif (status & 0x1) {\n\t\t\t\t\tif (info->flags & IS_POW2PS)\n\t\t\t\t\t\treturn info;\n\t\t\t\t} else {\n\t\t\t\t\tif (!(info->flags & IS_POW2PS))\n\t\t\t\t\t\treturn info;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\treturn info;\n\t\t}\n\t}\n\n\treturn ERR_PTR(-ENODEV);\n}\n\nstatic struct flash_info *jedec_probe(struct spi_device *spi)\n{\n\tint ret;\n\tu8 code = OP_READ_ID;\n\tu64 jedec;\n\tu8 id[sizeof(jedec)] = {0};\n\tconst unsigned int id_size = 5;\n\tstruct flash_info *info;\n\n\t \n\tret = spi_write_then_read(spi, &code, 1, id, id_size);\n\tif (ret < 0) {\n\t\tdev_dbg(&spi->dev, \"error %d reading JEDEC ID\\n\", ret);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tif (id[0] != CFI_MFR_ATMEL)\n\t\treturn NULL;\n\n\tjedec = be64_to_cpup((__be64 *)id);\n\n\t \n\tinfo = jedec_lookup(spi, jedec >> DATAFLASH_SHIFT_EXTID, true);\n\tif (!IS_ERR(info))\n\t\treturn info;\n\t \n\tinfo = jedec_lookup(spi, jedec >> DATAFLASH_SHIFT_ID, false);\n\tif (!IS_ERR(info))\n\t\treturn info;\n\t \n\tdev_warn(&spi->dev, \"JEDEC id %016llx not handled\\n\", jedec);\n\treturn ERR_PTR(-ENODEV);\n}\n\n \nstatic int dataflash_probe(struct spi_device *spi)\n{\n\tint status;\n\tstruct flash_info\t*info;\n\n\t \n\tinfo = jedec_probe(spi);\n\tif (IS_ERR(info))\n\t\treturn PTR_ERR(info);\n\tif (info != NULL)\n\t\treturn add_dataflash_otp(spi, info->name, info->nr_pages,\n\t\t\t\tinfo->pagesize, info->pageoffset,\n\t\t\t\t(info->flags & SUP_POW2PS) ? 'd' : 'c');\n\n\t \n\tstatus = dataflash_status(spi);\n\tif (status <= 0 || status == 0xff) {\n\t\tdev_dbg(&spi->dev, \"status error %d\\n\", status);\n\t\tif (status == 0 || status == 0xff)\n\t\t\tstatus = -ENODEV;\n\t\treturn status;\n\t}\n\n\t \n\tswitch (status & 0x3c) {\n\tcase 0x0c:\t \n\t\tstatus = add_dataflash(spi, \"AT45DB011B\", 512, 264, 9);\n\t\tbreak;\n\tcase 0x14:\t \n\t\tstatus = add_dataflash(spi, \"AT45DB021B\", 1024, 264, 9);\n\t\tbreak;\n\tcase 0x1c:\t \n\t\tstatus = add_dataflash(spi, \"AT45DB041x\", 2048, 264, 9);\n\t\tbreak;\n\tcase 0x24:\t \n\t\tstatus = add_dataflash(spi, \"AT45DB081B\", 4096, 264, 9);\n\t\tbreak;\n\tcase 0x2c:\t \n\t\tstatus = add_dataflash(spi, \"AT45DB161x\", 4096, 528, 10);\n\t\tbreak;\n\tcase 0x34:\t \n\t\tstatus = add_dataflash(spi, \"AT45DB321x\", 8192, 528, 10);\n\t\tbreak;\n\tcase 0x38:\t \n\tcase 0x3c:\n\t\tstatus = add_dataflash(spi, \"AT45DB642x\", 8192, 1056, 11);\n\t\tbreak;\n\t \n\tdefault:\n\t\tdev_info(&spi->dev, \"unsupported device (%x)\\n\",\n\t\t\t\tstatus & 0x3c);\n\t\tstatus = -ENODEV;\n\t}\n\n\tif (status < 0)\n\t\tdev_dbg(&spi->dev, \"add_dataflash --> %d\\n\", status);\n\n\treturn status;\n}\n\nstatic void dataflash_remove(struct spi_device *spi)\n{\n\tstruct dataflash\t*flash = spi_get_drvdata(spi);\n\n\tdev_dbg(&spi->dev, \"remove\\n\");\n\n\tWARN_ON(mtd_device_unregister(&flash->mtd));\n\n\tkfree(flash);\n}\n\nstatic struct spi_driver dataflash_driver = {\n\t.driver = {\n\t\t.name\t\t= \"mtd_dataflash\",\n\t\t.of_match_table = of_match_ptr(dataflash_dt_ids),\n\t},\n\t.probe\t\t= dataflash_probe,\n\t.remove\t\t= dataflash_remove,\n\t.id_table\t= dataflash_spi_ids,\n\n\t \n};\n\nmodule_spi_driver(dataflash_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Andrew Victor, David Brownell\");\nMODULE_DESCRIPTION(\"MTD DataFlash driver\");\nMODULE_ALIAS(\"spi:mtd_dataflash\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}