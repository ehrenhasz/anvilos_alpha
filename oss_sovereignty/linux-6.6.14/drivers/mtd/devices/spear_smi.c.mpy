{
  "module_name": "spear_smi.c",
  "hash_id": "d509748367abe70e1b3b5db93a47b63f4354e5a14879a8c0fb50b5badb8c6828",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/devices/spear_smi.c",
  "human_readable_source": " \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/ioport.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/param.h>\n#include <linux/platform_device.h>\n#include <linux/pm.h>\n#include <linux/mtd/mtd.h>\n#include <linux/mtd/partitions.h>\n#include <linux/mtd/spear_smi.h>\n#include <linux/mutex.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n\n \n#define SMI_MAX_CLOCK_FREQ\t50000000  \n\n \n#define SMI_PROBE_TIMEOUT\t(HZ / 10)\n#define SMI_MAX_TIME_OUT\t(3 * HZ)\n\n \n#define SMI_CMD_TIMEOUT\t\t(HZ / 10)\n\n \n#define SMI_CR1\t\t0x0\t \n#define SMI_CR2\t\t0x4\t \n#define SMI_SR\t\t0x8\t \n#define SMI_TR\t\t0xC\t \n#define SMI_RR\t\t0x10\t \n\n \n#define BANK_EN\t\t(0xF << 0)\t \n#define DSEL_TIME\t(0x6 << 4)\t \n#define SW_MODE\t\t(0x1 << 28)\t \n#define WB_MODE\t\t(0x1 << 29)\t \n#define FAST_MODE\t(0x1 << 15)\t \n#define HOLD1\t\t(0x1 << 16)\t \n\n \n#define SEND\t\t(0x1 << 7)\t \n#define TFIE\t\t(0x1 << 8)\t \n#define WCIE\t\t(0x1 << 9)\t \n#define RD_STATUS_REG\t(0x1 << 10)\t \n#define WE\t\t(0x1 << 11)\t \n\n#define TX_LEN_SHIFT\t0\n#define RX_LEN_SHIFT\t4\n#define BANK_SHIFT\t12\n\n \n#define SR_WIP\t\t0x1\t \n#define SR_WEL\t\t0x2\t \n#define SR_BP0\t\t0x4\t \n#define SR_BP1\t\t0x8\t \n#define SR_BP2\t\t0x10\t \n#define SR_SRWD\t\t0x80\t \n#define TFF\t\t0x100\t \n#define WCF\t\t0x200\t \n#define ERF1\t\t0x400\t \n#define ERF2\t\t0x800\t \n\n#define WM_SHIFT\t12\n\n \n#define OPCODE_RDID\t0x9f\t \n\n \n\n \nstruct flash_device {\n\tchar *name;\n\tu8 erase_cmd;\n\tu32 device_id;\n\tu32 pagesize;\n\tunsigned long sectorsize;\n\tunsigned long size_in_bytes;\n};\n\n#define FLASH_ID(n, es, id, psize, ssize, size)\t\\\n{\t\t\t\t\\\n\t.name = n,\t\t\\\n\t.erase_cmd = es,\t\\\n\t.device_id = id,\t\\\n\t.pagesize = psize,\t\\\n\t.sectorsize = ssize,\t\\\n\t.size_in_bytes = size\t\\\n}\n\nstatic struct flash_device flash_devices[] = {\n\tFLASH_ID(\"st m25p16\"     , 0xd8, 0x00152020, 0x100, 0x10000, 0x200000),\n\tFLASH_ID(\"st m25p32\"     , 0xd8, 0x00162020, 0x100, 0x10000, 0x400000),\n\tFLASH_ID(\"st m25p64\"     , 0xd8, 0x00172020, 0x100, 0x10000, 0x800000),\n\tFLASH_ID(\"st m25p128\"    , 0xd8, 0x00182020, 0x100, 0x40000, 0x1000000),\n\tFLASH_ID(\"st m25p05\"     , 0xd8, 0x00102020, 0x80 , 0x8000 , 0x10000),\n\tFLASH_ID(\"st m25p10\"     , 0xd8, 0x00112020, 0x80 , 0x8000 , 0x20000),\n\tFLASH_ID(\"st m25p20\"     , 0xd8, 0x00122020, 0x100, 0x10000, 0x40000),\n\tFLASH_ID(\"st m25p40\"     , 0xd8, 0x00132020, 0x100, 0x10000, 0x80000),\n\tFLASH_ID(\"st m25p80\"     , 0xd8, 0x00142020, 0x100, 0x10000, 0x100000),\n\tFLASH_ID(\"st m45pe10\"    , 0xd8, 0x00114020, 0x100, 0x10000, 0x20000),\n\tFLASH_ID(\"st m45pe20\"    , 0xd8, 0x00124020, 0x100, 0x10000, 0x40000),\n\tFLASH_ID(\"st m45pe40\"    , 0xd8, 0x00134020, 0x100, 0x10000, 0x80000),\n\tFLASH_ID(\"st m45pe80\"    , 0xd8, 0x00144020, 0x100, 0x10000, 0x100000),\n\tFLASH_ID(\"sp s25fl004\"   , 0xd8, 0x00120201, 0x100, 0x10000, 0x80000),\n\tFLASH_ID(\"sp s25fl008\"   , 0xd8, 0x00130201, 0x100, 0x10000, 0x100000),\n\tFLASH_ID(\"sp s25fl016\"   , 0xd8, 0x00140201, 0x100, 0x10000, 0x200000),\n\tFLASH_ID(\"sp s25fl032\"   , 0xd8, 0x00150201, 0x100, 0x10000, 0x400000),\n\tFLASH_ID(\"sp s25fl064\"   , 0xd8, 0x00160201, 0x100, 0x10000, 0x800000),\n\tFLASH_ID(\"atmel 25f512\"  , 0x52, 0x0065001F, 0x80 , 0x8000 , 0x10000),\n\tFLASH_ID(\"atmel 25f1024\" , 0x52, 0x0060001F, 0x100, 0x8000 , 0x20000),\n\tFLASH_ID(\"atmel 25f2048\" , 0x52, 0x0063001F, 0x100, 0x10000, 0x40000),\n\tFLASH_ID(\"atmel 25f4096\" , 0x52, 0x0064001F, 0x100, 0x10000, 0x80000),\n\tFLASH_ID(\"atmel 25fs040\" , 0xd7, 0x0004661F, 0x100, 0x10000, 0x80000),\n\tFLASH_ID(\"mac 25l512\"    , 0xd8, 0x001020C2, 0x010, 0x10000, 0x10000),\n\tFLASH_ID(\"mac 25l1005\"   , 0xd8, 0x001120C2, 0x010, 0x10000, 0x20000),\n\tFLASH_ID(\"mac 25l2005\"   , 0xd8, 0x001220C2, 0x010, 0x10000, 0x40000),\n\tFLASH_ID(\"mac 25l4005\"   , 0xd8, 0x001320C2, 0x010, 0x10000, 0x80000),\n\tFLASH_ID(\"mac 25l4005a\"  , 0xd8, 0x001320C2, 0x010, 0x10000, 0x80000),\n\tFLASH_ID(\"mac 25l8005\"   , 0xd8, 0x001420C2, 0x010, 0x10000, 0x100000),\n\tFLASH_ID(\"mac 25l1605\"   , 0xd8, 0x001520C2, 0x100, 0x10000, 0x200000),\n\tFLASH_ID(\"mac 25l1605a\"  , 0xd8, 0x001520C2, 0x010, 0x10000, 0x200000),\n\tFLASH_ID(\"mac 25l3205\"   , 0xd8, 0x001620C2, 0x100, 0x10000, 0x400000),\n\tFLASH_ID(\"mac 25l3205a\"  , 0xd8, 0x001620C2, 0x100, 0x10000, 0x400000),\n\tFLASH_ID(\"mac 25l6405\"   , 0xd8, 0x001720C2, 0x100, 0x10000, 0x800000),\n};\n\n \n\nstruct spear_snor_flash;\n\n \nstruct spear_smi {\n\tstruct clk *clk;\n\tu32 status;\n\tunsigned long clk_rate;\n\tstruct mutex lock;\n\tvoid __iomem *io_base;\n\tstruct platform_device *pdev;\n\twait_queue_head_t cmd_complete;\n\tu32 num_flashes;\n\tstruct spear_snor_flash *flash[MAX_NUM_FLASH_CHIP];\n};\n\n \nstruct spear_snor_flash {\n\tu32 bank;\n\tu32 dev_id;\n\tstruct mutex lock;\n\tstruct mtd_info mtd;\n\tu32 num_parts;\n\tstruct mtd_partition *parts;\n\tu32 page_size;\n\tvoid __iomem *base_addr;\n\tu8 erase_cmd;\n\tu8 fast_mode;\n};\n\nstatic inline struct spear_snor_flash *get_flash_data(struct mtd_info *mtd)\n{\n\treturn container_of(mtd, struct spear_snor_flash, mtd);\n}\n\n \nstatic int spear_smi_read_sr(struct spear_smi *dev, u32 bank)\n{\n\tint ret;\n\tu32 ctrlreg1;\n\n\tmutex_lock(&dev->lock);\n\tdev->status = 0;  \n\n\tctrlreg1 = readl(dev->io_base + SMI_CR1);\n\t \n\twritel(ctrlreg1 & ~(SW_MODE | WB_MODE), dev->io_base + SMI_CR1);\n\n\t \n\twritel((bank << BANK_SHIFT) | RD_STATUS_REG | TFIE,\n\t\t\tdev->io_base + SMI_CR2);\n\n\t \n\tret = wait_event_interruptible_timeout(dev->cmd_complete,\n\t\t\tdev->status & TFF, SMI_CMD_TIMEOUT);\n\n\t \n\tif (ret > 0)\n\t\tret = dev->status & 0xffff;\n\telse if (ret == 0)\n\t\tret = -ETIMEDOUT;\n\n\t \n\twritel(ctrlreg1, dev->io_base + SMI_CR1);\n\twritel(0, dev->io_base + SMI_CR2);\n\tmutex_unlock(&dev->lock);\n\n\treturn ret;\n}\n\n \nstatic int spear_smi_wait_till_ready(struct spear_smi *dev, u32 bank,\n\t\tunsigned long timeout)\n{\n\tunsigned long finish;\n\tint status;\n\n\tfinish = jiffies + timeout;\n\tdo {\n\t\tstatus = spear_smi_read_sr(dev, bank);\n\t\tif (status < 0) {\n\t\t\tif (status == -ETIMEDOUT)\n\t\t\t\tcontinue;  \n\t\t\treturn status;\n\t\t} else if (!(status & SR_WIP)) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tcond_resched();\n\t} while (!time_after_eq(jiffies, finish));\n\n\tdev_err(&dev->pdev->dev, \"smi controller is busy, timeout\\n\");\n\treturn -EBUSY;\n}\n\n \nstatic irqreturn_t spear_smi_int_handler(int irq, void *dev_id)\n{\n\tu32 status = 0;\n\tstruct spear_smi *dev = dev_id;\n\n\tstatus = readl(dev->io_base + SMI_SR);\n\n\tif (unlikely(!status))\n\t\treturn IRQ_NONE;\n\n\t \n\twritel(0, dev->io_base + SMI_SR);\n\n\t \n\tdev->status |= status;\n\n\t \n\twake_up_interruptible(&dev->cmd_complete);\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic void spear_smi_hw_init(struct spear_smi *dev)\n{\n\tunsigned long rate = 0;\n\tu32 prescale = 0;\n\tu32 val;\n\n\trate = clk_get_rate(dev->clk);\n\n\t \n\tprescale = DIV_ROUND_UP(rate, dev->clk_rate);\n\n\t \n\tval = HOLD1 | BANK_EN | DSEL_TIME | (prescale << 8);\n\n\tmutex_lock(&dev->lock);\n\t \n\twritel(0, dev->io_base + SMI_SR);\n\n\twritel(val, dev->io_base + SMI_CR1);\n\tmutex_unlock(&dev->lock);\n}\n\n \nstatic int get_flash_index(u32 flash_id)\n{\n\tint index;\n\n\t \n\tfor (index = 0; index < ARRAY_SIZE(flash_devices); index++) {\n\t\tif (flash_devices[index].device_id == flash_id)\n\t\t\treturn index;\n\t}\n\n\t \n\treturn -ENODEV;\n}\n\n \nstatic int spear_smi_write_enable(struct spear_smi *dev, u32 bank)\n{\n\tint ret;\n\tu32 ctrlreg1;\n\n\tmutex_lock(&dev->lock);\n\tdev->status = 0;  \n\n\tctrlreg1 = readl(dev->io_base + SMI_CR1);\n\t \n\twritel(ctrlreg1 & ~SW_MODE, dev->io_base + SMI_CR1);\n\n\t \n\twritel((bank << BANK_SHIFT) | WE | TFIE, dev->io_base + SMI_CR2);\n\n\tret = wait_event_interruptible_timeout(dev->cmd_complete,\n\t\t\tdev->status & TFF, SMI_CMD_TIMEOUT);\n\n\t \n\twritel(ctrlreg1, dev->io_base + SMI_CR1);\n\twritel(0, dev->io_base + SMI_CR2);\n\n\tif (ret == 0) {\n\t\tret = -EIO;\n\t\tdev_err(&dev->pdev->dev,\n\t\t\t\"smi controller failed on write enable\\n\");\n\t} else if (ret > 0) {\n\t\t \n\t\tif (dev->status & (1 << (bank + WM_SHIFT)))\n\t\t\tret = 0;\n\t\telse {\n\t\t\tdev_err(&dev->pdev->dev, \"couldn't enable write\\n\");\n\t\t\tret = -EIO;\n\t\t}\n\t}\n\n\tmutex_unlock(&dev->lock);\n\treturn ret;\n}\n\nstatic inline u32\nget_sector_erase_cmd(struct spear_snor_flash *flash, u32 offset)\n{\n\tu32 cmd;\n\tu8 *x = (u8 *)&cmd;\n\n\tx[0] = flash->erase_cmd;\n\tx[1] = offset >> 16;\n\tx[2] = offset >> 8;\n\tx[3] = offset;\n\n\treturn cmd;\n}\n\n \nstatic int spear_smi_erase_sector(struct spear_smi *dev,\n\t\tu32 bank, u32 command, u32 bytes)\n{\n\tu32 ctrlreg1 = 0;\n\tint ret;\n\n\tret = spear_smi_wait_till_ready(dev, bank, SMI_MAX_TIME_OUT);\n\tif (ret)\n\t\treturn ret;\n\n\tret = spear_smi_write_enable(dev, bank);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_lock(&dev->lock);\n\n\tctrlreg1 = readl(dev->io_base + SMI_CR1);\n\twritel((ctrlreg1 | SW_MODE) & ~WB_MODE, dev->io_base + SMI_CR1);\n\n\t \n\twritel(command, dev->io_base + SMI_TR);\n\n\twritel((bank << BANK_SHIFT) | SEND | TFIE | (bytes << TX_LEN_SHIFT),\n\t\t\tdev->io_base + SMI_CR2);\n\n\tret = wait_event_interruptible_timeout(dev->cmd_complete,\n\t\t\tdev->status & TFF, SMI_CMD_TIMEOUT);\n\n\tif (ret == 0) {\n\t\tret = -EIO;\n\t\tdev_err(&dev->pdev->dev, \"sector erase failed\\n\");\n\t} else if (ret > 0)\n\t\tret = 0;  \n\n\t \n\twritel(ctrlreg1, dev->io_base + SMI_CR1);\n\twritel(0, dev->io_base + SMI_CR2);\n\n\tmutex_unlock(&dev->lock);\n\treturn ret;\n}\n\n \nstatic int spear_mtd_erase(struct mtd_info *mtd, struct erase_info *e_info)\n{\n\tstruct spear_snor_flash *flash = get_flash_data(mtd);\n\tstruct spear_smi *dev = mtd->priv;\n\tu32 addr, command, bank;\n\tint len, ret;\n\n\tif (!flash || !dev)\n\t\treturn -ENODEV;\n\n\tbank = flash->bank;\n\tif (bank > dev->num_flashes - 1) {\n\t\tdev_err(&dev->pdev->dev, \"Invalid Bank Num\");\n\t\treturn -EINVAL;\n\t}\n\n\taddr = e_info->addr;\n\tlen = e_info->len;\n\n\tmutex_lock(&flash->lock);\n\n\t \n\twhile (len) {\n\t\tcommand = get_sector_erase_cmd(flash, addr);\n\t\t \n\t\tret = spear_smi_erase_sector(dev, bank, command, 4);\n\t\tif (ret) {\n\t\t\tmutex_unlock(&flash->lock);\n\t\t\treturn ret;\n\t\t}\n\t\taddr += mtd->erasesize;\n\t\tlen -= mtd->erasesize;\n\t}\n\n\tmutex_unlock(&flash->lock);\n\n\treturn 0;\n}\n\n \nstatic int spear_mtd_read(struct mtd_info *mtd, loff_t from, size_t len,\n\t\tsize_t *retlen, u8 *buf)\n{\n\tstruct spear_snor_flash *flash = get_flash_data(mtd);\n\tstruct spear_smi *dev = mtd->priv;\n\tvoid __iomem *src;\n\tu32 ctrlreg1, val;\n\tint ret;\n\n\tif (!flash || !dev)\n\t\treturn -ENODEV;\n\n\tif (flash->bank > dev->num_flashes - 1) {\n\t\tdev_err(&dev->pdev->dev, \"Invalid Bank Num\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tsrc = flash->base_addr + from;\n\n\tmutex_lock(&flash->lock);\n\n\t \n\tret = spear_smi_wait_till_ready(dev, flash->bank, SMI_MAX_TIME_OUT);\n\tif (ret) {\n\t\tmutex_unlock(&flash->lock);\n\t\treturn ret;\n\t}\n\n\tmutex_lock(&dev->lock);\n\t \n\tctrlreg1 = val = readl(dev->io_base + SMI_CR1);\n\tval &= ~(SW_MODE | WB_MODE);\n\tif (flash->fast_mode)\n\t\tval |= FAST_MODE;\n\n\twritel(val, dev->io_base + SMI_CR1);\n\n\tmemcpy_fromio(buf, src, len);\n\n\t \n\twritel(ctrlreg1, dev->io_base + SMI_CR1);\n\tmutex_unlock(&dev->lock);\n\n\t*retlen = len;\n\tmutex_unlock(&flash->lock);\n\n\treturn 0;\n}\n\n \nstatic void spear_smi_memcpy_toio_b(volatile void __iomem *dest,\n\t\t\t\t    const void *src, size_t len)\n{\n\tconst unsigned char *from = src;\n\n\twhile (len) {\n\t\tlen--;\n\t\twriteb(*from, dest);\n\t\tfrom++;\n\t\tdest++;\n\t}\n}\n\nstatic inline int spear_smi_cpy_toio(struct spear_smi *dev, u32 bank,\n\t\tvoid __iomem *dest, const void *src, size_t len)\n{\n\tint ret;\n\tu32 ctrlreg1;\n\n\t \n\tret = spear_smi_wait_till_ready(dev, bank, SMI_MAX_TIME_OUT);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = spear_smi_write_enable(dev, bank);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tmutex_lock(&dev->lock);\n\n\tctrlreg1 = readl(dev->io_base + SMI_CR1);\n\twritel((ctrlreg1 | WB_MODE) & ~SW_MODE, dev->io_base + SMI_CR1);\n\n\t \n\tif (IS_ALIGNED(len, sizeof(u32)) &&\n\t    IS_ALIGNED((uintptr_t)dest, sizeof(u32)))\n\t\tmemcpy_toio(dest, src, len);\n\telse\n\t\tspear_smi_memcpy_toio_b(dest, src, len);\n\n\twritel(ctrlreg1, dev->io_base + SMI_CR1);\n\n\tmutex_unlock(&dev->lock);\n\treturn 0;\n}\n\n \nstatic int spear_mtd_write(struct mtd_info *mtd, loff_t to, size_t len,\n\t\tsize_t *retlen, const u8 *buf)\n{\n\tstruct spear_snor_flash *flash = get_flash_data(mtd);\n\tstruct spear_smi *dev = mtd->priv;\n\tvoid __iomem *dest;\n\tu32 page_offset, page_size;\n\tint ret;\n\n\tif (!flash || !dev)\n\t\treturn -ENODEV;\n\n\tif (flash->bank > dev->num_flashes - 1) {\n\t\tdev_err(&dev->pdev->dev, \"Invalid Bank Num\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tdest = flash->base_addr + to;\n\tmutex_lock(&flash->lock);\n\n\tpage_offset = (u32)to % flash->page_size;\n\n\t \n\tif (page_offset + len <= flash->page_size) {\n\t\tret = spear_smi_cpy_toio(dev, flash->bank, dest, buf, len);\n\t\tif (!ret)\n\t\t\t*retlen += len;\n\t} else {\n\t\tu32 i;\n\n\t\t \n\t\tpage_size = flash->page_size - page_offset;\n\n\t\tret = spear_smi_cpy_toio(dev, flash->bank, dest, buf,\n\t\t\t\tpage_size);\n\t\tif (ret)\n\t\t\tgoto err_write;\n\t\telse\n\t\t\t*retlen += page_size;\n\n\t\t \n\t\tfor (i = page_size; i < len; i += page_size) {\n\t\t\tpage_size = len - i;\n\t\t\tif (page_size > flash->page_size)\n\t\t\t\tpage_size = flash->page_size;\n\n\t\t\tret = spear_smi_cpy_toio(dev, flash->bank, dest + i,\n\t\t\t\t\tbuf + i, page_size);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t\telse\n\t\t\t\t*retlen += page_size;\n\t\t}\n\t}\n\nerr_write:\n\tmutex_unlock(&flash->lock);\n\n\treturn ret;\n}\n\n \nstatic int spear_smi_probe_flash(struct spear_smi *dev, u32 bank)\n{\n\tint ret;\n\tu32 val = 0;\n\n\tret = spear_smi_wait_till_ready(dev, bank, SMI_PROBE_TIMEOUT);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_lock(&dev->lock);\n\n\tdev->status = 0;  \n\t \n\tval = readl(dev->io_base + SMI_CR1);\n\twritel(val | SW_MODE, dev->io_base + SMI_CR1);\n\n\t \n\twritel(OPCODE_RDID, dev->io_base + SMI_TR);\n\n\tval = (bank << BANK_SHIFT) | SEND | (1 << TX_LEN_SHIFT) |\n\t\t(3 << RX_LEN_SHIFT) | TFIE;\n\twritel(val, dev->io_base + SMI_CR2);\n\n\t \n\tret = wait_event_interruptible_timeout(dev->cmd_complete,\n\t\t\tdev->status & TFF, SMI_CMD_TIMEOUT);\n\tif (ret <= 0) {\n\t\tret = -ENODEV;\n\t\tgoto err_probe;\n\t}\n\n\t \n\tval = readl(dev->io_base + SMI_RR);\n\tval &= 0x00ffffff;\n\tret = get_flash_index(val);\n\nerr_probe:\n\t \n\tval = readl(dev->io_base + SMI_CR1);\n\twritel(val & ~SW_MODE, dev->io_base + SMI_CR1);\n\n\tmutex_unlock(&dev->lock);\n\treturn ret;\n}\n\n\n#ifdef CONFIG_OF\nstatic int spear_smi_probe_config_dt(struct platform_device *pdev,\n\t\t\t\t     struct device_node *np)\n{\n\tstruct spear_smi_plat_data *pdata = dev_get_platdata(&pdev->dev);\n\tstruct device_node *pp;\n\tconst __be32 *addr;\n\tu32 val;\n\tint len;\n\tint i = 0;\n\n\tif (!np)\n\t\treturn -ENODEV;\n\n\tof_property_read_u32(np, \"clock-rate\", &val);\n\tpdata->clk_rate = val;\n\n\tpdata->board_flash_info = devm_kzalloc(&pdev->dev,\n\t\t\t\t\t       sizeof(*pdata->board_flash_info),\n\t\t\t\t\t       GFP_KERNEL);\n\tif (!pdata->board_flash_info)\n\t\treturn -ENOMEM;\n\n\t \n\tfor_each_child_of_node(np, pp) {\n\t\tpdata->np[i] = pp;\n\n\t\t \n\t\taddr = of_get_property(pp, \"reg\", &len);\n\t\tpdata->board_flash_info->mem_base = be32_to_cpup(&addr[0]);\n\t\tpdata->board_flash_info->size = be32_to_cpup(&addr[1]);\n\n\t\tpdata->board_flash_info->fast_mode =\n\t\t\tof_property_read_bool(pp, \"st,smi-fast-mode\");\n\n\t\ti++;\n\t}\n\n\tpdata->num_flashes = i;\n\n\treturn 0;\n}\n#else\nstatic int spear_smi_probe_config_dt(struct platform_device *pdev,\n\t\t\t\t     struct device_node *np)\n{\n\treturn -ENOSYS;\n}\n#endif\n\nstatic int spear_smi_setup_banks(struct platform_device *pdev,\n\t\t\t\t u32 bank, struct device_node *np)\n{\n\tstruct spear_smi *dev = platform_get_drvdata(pdev);\n\tstruct spear_smi_flash_info *flash_info;\n\tstruct spear_smi_plat_data *pdata;\n\tstruct spear_snor_flash *flash;\n\tstruct mtd_partition *parts = NULL;\n\tint count = 0;\n\tint flash_index;\n\tint ret = 0;\n\n\tpdata = dev_get_platdata(&pdev->dev);\n\tif (bank > pdata->num_flashes - 1)\n\t\treturn -EINVAL;\n\n\tflash_info = &pdata->board_flash_info[bank];\n\tif (!flash_info)\n\t\treturn -ENODEV;\n\n\tflash = devm_kzalloc(&pdev->dev, sizeof(*flash), GFP_ATOMIC);\n\tif (!flash)\n\t\treturn -ENOMEM;\n\tflash->bank = bank;\n\tflash->fast_mode = flash_info->fast_mode ? 1 : 0;\n\tmutex_init(&flash->lock);\n\n\t \n\tflash_index = spear_smi_probe_flash(dev, bank);\n\tif (flash_index < 0) {\n\t\tdev_info(&dev->pdev->dev, \"smi-nor%d not found\\n\", bank);\n\t\treturn flash_index;\n\t}\n\t \n\tflash->base_addr = devm_ioremap(&pdev->dev, flash_info->mem_base,\n\t\t\t\t\tflash_info->size);\n\tif (!flash->base_addr)\n\t\treturn -EIO;\n\n\tdev->flash[bank] = flash;\n\tflash->mtd.priv = dev;\n\n\tif (flash_info->name)\n\t\tflash->mtd.name = flash_info->name;\n\telse\n\t\tflash->mtd.name = flash_devices[flash_index].name;\n\n\tflash->mtd.dev.parent = &pdev->dev;\n\tmtd_set_of_node(&flash->mtd, np);\n\tflash->mtd.type = MTD_NORFLASH;\n\tflash->mtd.writesize = 1;\n\tflash->mtd.flags = MTD_CAP_NORFLASH;\n\tflash->mtd.size = flash_info->size;\n\tflash->mtd.erasesize = flash_devices[flash_index].sectorsize;\n\tflash->page_size = flash_devices[flash_index].pagesize;\n\tflash->mtd.writebufsize = flash->page_size;\n\tflash->erase_cmd = flash_devices[flash_index].erase_cmd;\n\tflash->mtd._erase = spear_mtd_erase;\n\tflash->mtd._read = spear_mtd_read;\n\tflash->mtd._write = spear_mtd_write;\n\tflash->dev_id = flash_devices[flash_index].device_id;\n\n\tdev_info(&dev->pdev->dev, \"mtd .name=%s .size=%llx(%lluM)\\n\",\n\t\t\tflash->mtd.name, flash->mtd.size,\n\t\t\tflash->mtd.size / (1024 * 1024));\n\n\tdev_info(&dev->pdev->dev, \".erasesize = 0x%x(%uK)\\n\",\n\t\t\tflash->mtd.erasesize, flash->mtd.erasesize / 1024);\n\n#ifndef CONFIG_OF\n\tif (flash_info->partitions) {\n\t\tparts = flash_info->partitions;\n\t\tcount = flash_info->nr_partitions;\n\t}\n#endif\n\n\tret = mtd_device_register(&flash->mtd, parts, count);\n\tif (ret) {\n\t\tdev_err(&dev->pdev->dev, \"Err MTD partition=%d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int spear_smi_probe(struct platform_device *pdev)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct spear_smi_plat_data *pdata = NULL;\n\tstruct spear_smi *dev;\n\tint irq, ret = 0;\n\tint i;\n\n\tif (np) {\n\t\tpdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);\n\t\tif (!pdata) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err;\n\t\t}\n\t\tpdev->dev.platform_data = pdata;\n\t\tret = spear_smi_probe_config_dt(pdev, np);\n\t\tif (ret) {\n\t\t\tret = -ENODEV;\n\t\t\tdev_err(&pdev->dev, \"no platform data\\n\");\n\t\t\tgoto err;\n\t\t}\n\t} else {\n\t\tpdata = dev_get_platdata(&pdev->dev);\n\t\tif (!pdata) {\n\t\t\tret = -ENODEV;\n\t\t\tdev_err(&pdev->dev, \"no platform data\\n\");\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0) {\n\t\tret = -ENODEV;\n\t\tgoto err;\n\t}\n\n\tdev = devm_kzalloc(&pdev->dev, sizeof(*dev), GFP_KERNEL);\n\tif (!dev) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tdev->io_base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(dev->io_base)) {\n\t\tret = PTR_ERR(dev->io_base);\n\t\tgoto err;\n\t}\n\n\tdev->pdev = pdev;\n\tdev->clk_rate = pdata->clk_rate;\n\n\tif (dev->clk_rate > SMI_MAX_CLOCK_FREQ)\n\t\tdev->clk_rate = SMI_MAX_CLOCK_FREQ;\n\n\tdev->num_flashes = pdata->num_flashes;\n\n\tif (dev->num_flashes > MAX_NUM_FLASH_CHIP) {\n\t\tdev_err(&pdev->dev, \"exceeding max number of flashes\\n\");\n\t\tdev->num_flashes = MAX_NUM_FLASH_CHIP;\n\t}\n\n\tdev->clk = devm_clk_get_enabled(&pdev->dev, NULL);\n\tif (IS_ERR(dev->clk)) {\n\t\tret = PTR_ERR(dev->clk);\n\t\tgoto err;\n\t}\n\n\tret = devm_request_irq(&pdev->dev, irq, spear_smi_int_handler, 0,\n\t\t\t       pdev->name, dev);\n\tif (ret) {\n\t\tdev_err(&dev->pdev->dev, \"SMI IRQ allocation failed\\n\");\n\t\tgoto err;\n\t}\n\n\tmutex_init(&dev->lock);\n\tinit_waitqueue_head(&dev->cmd_complete);\n\tspear_smi_hw_init(dev);\n\tplatform_set_drvdata(pdev, dev);\n\n\t \n\tfor (i = 0; i < dev->num_flashes; i++) {\n\t\tret = spear_smi_setup_banks(pdev, i, pdata->np[i]);\n\t\tif (ret) {\n\t\t\tdev_err(&dev->pdev->dev, \"bank setup failed\\n\");\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\treturn 0;\nerr:\n\treturn ret;\n}\n\n \nstatic int spear_smi_remove(struct platform_device *pdev)\n{\n\tstruct spear_smi *dev;\n\tstruct spear_snor_flash *flash;\n\tint i;\n\n\tdev = platform_get_drvdata(pdev);\n\n\t \n\tfor (i = 0; i < dev->num_flashes; i++) {\n\t\tflash = dev->flash[i];\n\t\tif (!flash)\n\t\t\tcontinue;\n\n\t\t \n\t\tWARN_ON(mtd_device_unregister(&flash->mtd));\n\t}\n\n\treturn 0;\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int spear_smi_suspend(struct device *dev)\n{\n\tstruct spear_smi *sdev = dev_get_drvdata(dev);\n\n\tif (sdev && sdev->clk)\n\t\tclk_disable_unprepare(sdev->clk);\n\n\treturn 0;\n}\n\nstatic int spear_smi_resume(struct device *dev)\n{\n\tstruct spear_smi *sdev = dev_get_drvdata(dev);\n\tint ret = -EPERM;\n\n\tif (sdev && sdev->clk)\n\t\tret = clk_prepare_enable(sdev->clk);\n\n\tif (!ret)\n\t\tspear_smi_hw_init(sdev);\n\treturn ret;\n}\n#endif\n\nstatic SIMPLE_DEV_PM_OPS(spear_smi_pm_ops, spear_smi_suspend, spear_smi_resume);\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id spear_smi_id_table[] = {\n\t{ .compatible = \"st,spear600-smi\" },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, spear_smi_id_table);\n#endif\n\nstatic struct platform_driver spear_smi_driver = {\n\t.driver = {\n\t\t.name = \"smi\",\n\t\t.bus = &platform_bus_type,\n\t\t.of_match_table = of_match_ptr(spear_smi_id_table),\n\t\t.pm = &spear_smi_pm_ops,\n\t},\n\t.probe = spear_smi_probe,\n\t.remove = spear_smi_remove,\n};\nmodule_platform_driver(spear_smi_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Ashish Priyadarshi, Shiraz Hashim <shiraz.linux.kernel@gmail.com>\");\nMODULE_DESCRIPTION(\"MTD SMI driver for serial nor flash chips\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}