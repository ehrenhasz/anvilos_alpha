{
  "module_name": "afs.c",
  "hash_id": "1b0fffdeec6cd7290acb97ba3d38096d1bcb60d1abd0b2cbc0889f57de11331b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/parsers/afs.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/init.h>\n\n#include <linux/mtd/mtd.h>\n#include <linux/mtd/map.h>\n#include <linux/mtd/partitions.h>\n\n#define AFSV1_FOOTER_MAGIC 0xA0FFFF9F\n#define AFSV2_FOOTER_MAGIC1 0x464C5348  \n#define AFSV2_FOOTER_MAGIC2 0x464F4F54  \n\nstruct footer_v1 {\n\tu32 image_info_base;\t \n\tu32 image_start;\t \n\tu32 signature;\t\t \n\tu32 type;\t\t \n\tu32 checksum;\t\t \n};\n\nstruct image_info_v1 {\n\tu32 bootFlags;\t\t \n\tu32 imageNumber;\t \n\tu32 loadAddress;\t \n\tu32 length;\t\t \n\tu32 address;\t\t \n\tchar name[16];\t\t \n\tu32 headerBase;\t\t \n\tu32 header_length;\t \n\tu32 headerType;\t\t \n\tu32 checksum;\t\t \n};\n\nstatic u32 word_sum(void *words, int num)\n{\n\tu32 *p = words;\n\tu32 sum = 0;\n\n\twhile (num--)\n\t\tsum += *p++;\n\n\treturn sum;\n}\n\nstatic u32 word_sum_v2(u32 *p, u32 num)\n{\n\tu32 sum = 0;\n\tint i;\n\n\tfor (i = 0; i < num; i++) {\n\t\tu32 val;\n\n\t\tval = p[i];\n\t\tif (val > ~sum)\n\t\t\tsum++;\n\t\tsum += val;\n\t}\n\treturn ~sum;\n}\n\nstatic bool afs_is_v1(struct mtd_info *mtd, u_int off)\n{\n\t \n\tu_int ptr = off + mtd->erasesize - 12;\n\tu32 magic;\n\tsize_t sz;\n\tint ret;\n\n\tret = mtd_read(mtd, ptr, 4, &sz, (u_char *)&magic);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR \"AFS: mtd read failed at 0x%x: %d\\n\",\n\t\t       ptr, ret);\n\t\treturn false;\n\t}\n\tif (ret >= 0 && sz != 4)\n\t\treturn false;\n\n\treturn (magic == AFSV1_FOOTER_MAGIC);\n}\n\nstatic bool afs_is_v2(struct mtd_info *mtd, u_int off)\n{\n\t \n\tu_int ptr = off + mtd->erasesize - 8;\n\tu32 foot[2];\n\tsize_t sz;\n\tint ret;\n\n\tret = mtd_read(mtd, ptr, 8, &sz, (u_char *)foot);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR \"AFS: mtd read failed at 0x%x: %d\\n\",\n\t\t       ptr, ret);\n\t\treturn false;\n\t}\n\tif (ret >= 0 && sz != 8)\n\t\treturn false;\n\n\treturn (foot[0] == AFSV2_FOOTER_MAGIC1 &&\n\t\tfoot[1] == AFSV2_FOOTER_MAGIC2);\n}\n\nstatic int afs_parse_v1_partition(struct mtd_info *mtd,\n\t\t\t\t  u_int off, struct mtd_partition *part)\n{\n\tstruct footer_v1 fs;\n\tstruct image_info_v1 iis;\n\tu_int mask;\n\t \n\tu_int iis_ptr;\n\tu_int img_ptr;\n\tu_int ptr;\n\tsize_t sz;\n\tint ret;\n\tint i;\n\n\t \n\tmask = mtd->size - 1;\n\n\tptr = off + mtd->erasesize - sizeof(fs);\n\tret = mtd_read(mtd, ptr, sizeof(fs), &sz, (u_char *)&fs);\n\tif (ret >= 0 && sz != sizeof(fs))\n\t\tret = -EINVAL;\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR \"AFS: mtd read failed at 0x%x: %d\\n\",\n\t\t       ptr, ret);\n\t\treturn ret;\n\t}\n\t \n\tif (word_sum(&fs, sizeof(fs) / sizeof(u32)) != 0xffffffff)\n\t\treturn -EINVAL;\n\n\t \n\tif (fs.type == 2)\n\t\treturn 0;\n\n\tiis_ptr = fs.image_info_base & mask;\n\timg_ptr = fs.image_start & mask;\n\n\t \n\tif (iis_ptr >= ptr)\n\t\treturn 0;\n\n\t \n\tif (img_ptr > off)\n\t\treturn 0;\n\n\t \n\tmemset(&iis, 0, sizeof(iis));\n\tret = mtd_read(mtd, iis_ptr, sizeof(iis), &sz, (u_char *)&iis);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR \"AFS: mtd read failed at 0x%x: %d\\n\",\n\t\t       iis_ptr, ret);\n\t\treturn -EINVAL;\n\t}\n\n\tif (sz != sizeof(iis))\n\t\treturn -EINVAL;\n\n\t \n\tfor (i = 0; i < sizeof(iis.name); i++)\n\t\tif (iis.name[i] == '\\0')\n\t\t\tbreak;\n\tif (i > sizeof(iis.name))\n\t\treturn -EINVAL;\n\n\tpart->name = kstrdup(iis.name, GFP_KERNEL);\n\tif (!part->name)\n\t\treturn -ENOMEM;\n\n\tpart->size = (iis.length + mtd->erasesize - 1) & ~(mtd->erasesize - 1);\n\tpart->offset = img_ptr;\n\tpart->mask_flags = 0;\n\n\tprintk(\"  mtd: at 0x%08x, %5lluKiB, %8u, %s\\n\",\n\t       img_ptr, part->size / 1024,\n\t       iis.imageNumber, part->name);\n\n\treturn 0;\n}\n\nstatic int afs_parse_v2_partition(struct mtd_info *mtd,\n\t\t\t\t  u_int off, struct mtd_partition *part)\n{\n\tu_int ptr;\n\tu32 footer[12];\n\tu32 imginfo[36];\n\tchar *name;\n\tu32 version;\n\tu32 entrypoint;\n\tu32 attributes;\n\tu32 region_count;\n\tu32 block_start;\n\tu32 block_end;\n\tu32 crc;\n\tsize_t sz;\n\tint ret;\n\tint i;\n\tint pad = 0;\n\n\tpr_debug(\"Parsing v2 partition @%08x-%08x\\n\",\n\t\t off, off + mtd->erasesize);\n\n\t \n\tptr = off + mtd->erasesize - sizeof(footer);\n\tret = mtd_read(mtd, ptr, sizeof(footer), &sz, (u_char *)footer);\n\tif ((ret < 0) || (ret >= 0 && sz != sizeof(footer))) {\n\t\tpr_err(\"AFS: mtd read failed at 0x%x: %d\\n\",\n\t\t       ptr, ret);\n\t\treturn -EIO;\n\t}\n\tname = (char *) &footer[0];\n\tversion = footer[9];\n\tptr = off + mtd->erasesize - sizeof(footer) - footer[8];\n\n\tpr_debug(\"found image \\\"%s\\\", version %08x, info @%08x\\n\",\n\t\t name, version, ptr);\n\n\t \n\tret = mtd_read(mtd, ptr, sizeof(imginfo), &sz, (u_char *)imginfo);\n\tif ((ret < 0) || (ret >= 0 && sz != sizeof(imginfo))) {\n\t\tpr_err(\"AFS: mtd read failed at 0x%x: %d\\n\",\n\t\t       ptr, ret);\n\t\treturn -EIO;\n\t}\n\n\t \n\tcrc = word_sum_v2(&imginfo[1], 34);\n\tif (!crc) {\n\t\tpr_debug(\"Padding 1 word (4 bytes)\\n\");\n\t\tpad = 1;\n\t} else {\n\t\t \n\t\tcrc = word_sum_v2(&imginfo[2], 34);\n\t\tif (!crc) {\n\t\t\tpr_debug(\"Padding 2 words (8 bytes)\\n\");\n\t\t\tpad = 2;\n\t\t}\n\t}\n\tif (crc) {\n\t\tpr_err(\"AFS: bad checksum on v2 image info: %08x\\n\", crc);\n\t\treturn -EINVAL;\n\t}\n\tentrypoint = imginfo[pad];\n\tattributes = imginfo[pad+1];\n\tregion_count = imginfo[pad+2];\n\tblock_start = imginfo[20];\n\tblock_end = imginfo[21];\n\n\tpr_debug(\"image entry=%08x, attr=%08x, regions=%08x, \"\n\t\t \"bs=%08x, be=%08x\\n\",\n\t\t entrypoint, attributes, region_count,\n\t\t block_start, block_end);\n\n\tfor (i = 0; i < region_count; i++) {\n\t\tu32 region_load_addr = imginfo[pad + 3 + i*4];\n\t\tu32 region_size = imginfo[pad + 4 + i*4];\n\t\tu32 region_offset = imginfo[pad + 5 + i*4];\n\t\tu32 region_start;\n\t\tu32 region_end;\n\n\t\tpr_debug(\"  region %d: address: %08x, size: %08x, \"\n\t\t\t \"offset: %08x\\n\",\n\t\t\t i,\n\t\t\t region_load_addr,\n\t\t\t region_size,\n\t\t\t region_offset);\n\n\t\tregion_start = off + region_offset;\n\t\tregion_end = region_start + region_size;\n\t\t \n\t\tregion_end += (mtd->erasesize - 1);\n\t\tregion_end &= ~(mtd->erasesize -1);\n\t\tpr_debug(\"   partition start = %08x, partition end = %08x\\n\",\n\t\t\t region_start, region_end);\n\n\t\t \n\t\tpart->name = kstrdup(name, GFP_KERNEL);\n\t\tif (!part->name)\n\t\t\treturn -ENOMEM;\n\t\tpart->offset = region_start;\n\t\tpart->size = region_end - region_start;\n\t\tpart->mask_flags = 0;\n\t}\n\n\treturn 0;\n}\n\nstatic int parse_afs_partitions(struct mtd_info *mtd,\n\t\t\t\tconst struct mtd_partition **pparts,\n\t\t\t\tstruct mtd_part_parser_data *data)\n{\n\tstruct mtd_partition *parts;\n\tu_int off, sz;\n\tint ret = 0;\n\tint i;\n\n\t \n\tfor (i = off = sz = 0; off < mtd->size; off += mtd->erasesize) {\n\t\tif (afs_is_v1(mtd, off)) {\n\t\t\tsz += sizeof(struct mtd_partition);\n\t\t\ti += 1;\n\t\t}\n\t\tif (afs_is_v2(mtd, off)) {\n\t\t\tsz += sizeof(struct mtd_partition);\n\t\t\ti += 1;\n\t\t}\n\t}\n\n\tif (!i)\n\t\treturn 0;\n\n\tparts = kzalloc(sz, GFP_KERNEL);\n\tif (!parts)\n\t\treturn -ENOMEM;\n\n\t \n\tfor (i = off = 0; off < mtd->size; off += mtd->erasesize) {\n\t\tif (afs_is_v1(mtd, off)) {\n\t\t\tret = afs_parse_v1_partition(mtd, off, &parts[i]);\n\t\t\tif (ret)\n\t\t\t\tgoto out_free_parts;\n\t\t\ti++;\n\t\t}\n\t\tif (afs_is_v2(mtd, off)) {\n\t\t\tret = afs_parse_v2_partition(mtd, off, &parts[i]);\n\t\t\tif (ret)\n\t\t\t\tgoto out_free_parts;\n\t\t\ti++;\n\t\t}\n\t}\n\n\t*pparts = parts;\n\treturn i;\n\nout_free_parts:\n\twhile (--i >= 0)\n\t\tkfree(parts[i].name);\n\tkfree(parts);\n\t*pparts = NULL;\n\treturn ret;\n}\n\nstatic const struct of_device_id mtd_parser_afs_of_match_table[] = {\n\t{ .compatible = \"arm,arm-firmware-suite\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, mtd_parser_afs_of_match_table);\n\nstatic struct mtd_part_parser afs_parser = {\n\t.parse_fn = parse_afs_partitions,\n\t.name = \"afs\",\n\t.of_match_table = mtd_parser_afs_of_match_table,\n};\nmodule_mtd_part_parser(afs_parser);\n\nMODULE_AUTHOR(\"ARM Ltd\");\nMODULE_DESCRIPTION(\"ARM Firmware Suite partition parser\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}