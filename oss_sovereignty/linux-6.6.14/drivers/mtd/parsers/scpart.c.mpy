{
  "module_name": "scpart.c",
  "hash_id": "3e599d7ba37319e5916411f31fd098776f54d9f09ff3c1c650fde290e914cc42",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/parsers/scpart.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/mtd/mtd.h>\n#include <linux/mtd/partitions.h>\n#include <linux/module.h>\n\n#define\tMOD_NAME\t\"scpart\"\n\n#ifdef pr_fmt\n#undef pr_fmt\n#endif\n\n#define pr_fmt(fmt) MOD_NAME \": \" fmt\n\n#define\tID_ALREADY_FOUND\t0xffffffffUL\n\n#define\tMAP_OFFS_IN_BLK\t\t0x800\n#define\tMAP_MIRROR_NUM\t\t2\n\nstatic const char sc_part_magic[] = {\n\t'S', 'C', 'F', 'L', 'M', 'A', 'P', 'O', 'K', '\\0',\n};\n#define\tPART_MAGIC_LEN\t\tsizeof(sc_part_magic)\n\n \nstruct sc_part_desc {\n\tuint32_t\tpart_id;\n\tuint32_t\tpart_offs;\n\tuint32_t\tpart_bytes;\n};\n\nstatic uint32_t scpart_desc_is_valid(struct sc_part_desc *pdesc)\n{\n\treturn ((pdesc->part_id != 0xffffffffUL) &&\n\t\t(pdesc->part_offs != 0xffffffffUL) &&\n\t\t(pdesc->part_bytes != 0xffffffffUL));\n}\n\nstatic int scpart_scan_partmap(struct mtd_info *master, loff_t partmap_offs,\n\t\t\t       struct sc_part_desc **ppdesc)\n{\n\tint cnt = 0;\n\tint res = 0;\n\tint res2;\n\tuint32_t offs;\n\tsize_t retlen;\n\tstruct sc_part_desc *pdesc = NULL;\n\tstruct sc_part_desc *tmpdesc;\n\tuint8_t *buf;\n\n\tbuf = kzalloc(master->erasesize, GFP_KERNEL);\n\tif (!buf) {\n\t\tres = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tres2 = mtd_read(master, partmap_offs, master->erasesize, &retlen, buf);\n\tif (res2 || retlen != master->erasesize) {\n\t\tres = -EIO;\n\t\tgoto free;\n\t}\n\n\tfor (offs = MAP_OFFS_IN_BLK;\n\t     offs < master->erasesize - sizeof(*tmpdesc);\n\t     offs += sizeof(*tmpdesc)) {\n\t\ttmpdesc = (struct sc_part_desc *)&buf[offs];\n\t\tif (!scpart_desc_is_valid(tmpdesc))\n\t\t\tbreak;\n\t\tcnt++;\n\t}\n\n\tif (cnt > 0) {\n\t\tint bytes = cnt * sizeof(*pdesc);\n\n\t\tpdesc = kcalloc(cnt, sizeof(*pdesc), GFP_KERNEL);\n\t\tif (!pdesc) {\n\t\t\tres = -ENOMEM;\n\t\t\tgoto free;\n\t\t}\n\t\tmemcpy(pdesc, &(buf[MAP_OFFS_IN_BLK]), bytes);\n\n\t\t*ppdesc = pdesc;\n\t\tres = cnt;\n\t}\n\nfree:\n\tkfree(buf);\n\nout:\n\treturn res;\n}\n\nstatic int scpart_find_partmap(struct mtd_info *master,\n\t\t\t       struct sc_part_desc **ppdesc)\n{\n\tint magic_found = 0;\n\tint res = 0;\n\tint res2;\n\tloff_t offs = 0;\n\tsize_t retlen;\n\tuint8_t rdbuf[PART_MAGIC_LEN];\n\n\twhile ((magic_found < MAP_MIRROR_NUM) &&\n\t\t\t(offs < master->size) &&\n\t\t\t !mtd_block_isbad(master, offs)) {\n\t\tres2 = mtd_read(master, offs, PART_MAGIC_LEN, &retlen, rdbuf);\n\t\tif (res2 || retlen != PART_MAGIC_LEN) {\n\t\t\tres = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t\tif (!memcmp(rdbuf, sc_part_magic, PART_MAGIC_LEN)) {\n\t\t\tpr_debug(\"Signature found at 0x%llx\\n\", offs);\n\t\t\tmagic_found++;\n\t\t\tres = scpart_scan_partmap(master, offs, ppdesc);\n\t\t\tif (res > 0)\n\t\t\t\tgoto out;\n\t\t}\n\t\toffs += master->erasesize;\n\t}\n\nout:\n\tif (res > 0)\n\t\tpr_info(\"Valid 'SC PART MAP' (%d partitions) found at 0x%llx\\n\", res, offs);\n\telse\n\t\tpr_info(\"No valid 'SC PART MAP' was found\\n\");\n\n\treturn res;\n}\n\nstatic int scpart_parse(struct mtd_info *master,\n\t\t\tconst struct mtd_partition **pparts,\n\t\t\tstruct mtd_part_parser_data *data)\n{\n\tconst char *partname;\n\tint n;\n\tint nr_scparts;\n\tint nr_parts = 0;\n\tint res = 0;\n\tstruct sc_part_desc *scpart_map = NULL;\n\tstruct mtd_partition *parts = NULL;\n\tstruct device_node *mtd_node;\n\tstruct device_node *ofpart_node;\n\tstruct device_node *pp;\n\n\tmtd_node = mtd_get_of_node(master);\n\tif (!mtd_node) {\n\t\tres = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tofpart_node = of_get_child_by_name(mtd_node, \"partitions\");\n\tif (!ofpart_node) {\n\t\tpr_info(\"%s: 'partitions' subnode not found on %pOF.\\n\",\n\t\t\t\tmaster->name, mtd_node);\n\t\tres = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tnr_scparts = scpart_find_partmap(master, &scpart_map);\n\tif (nr_scparts <= 0) {\n\t\tpr_info(\"No any partitions was found in 'SC PART MAP'.\\n\");\n\t\tres = -ENOENT;\n\t\tgoto free;\n\t}\n\n\tparts = kcalloc(of_get_child_count(ofpart_node), sizeof(*parts),\n\t\tGFP_KERNEL);\n\tif (!parts) {\n\t\tres = -ENOMEM;\n\t\tgoto free;\n\t}\n\n\tfor_each_child_of_node(ofpart_node, pp) {\n\t\tu32 scpart_id;\n\n\t\tif (of_property_read_u32(pp, \"sercomm,scpart-id\", &scpart_id))\n\t\t\tcontinue;\n\n\t\tfor (n = 0 ; n < nr_scparts ; n++)\n\t\t\tif ((scpart_map[n].part_id != ID_ALREADY_FOUND) &&\n\t\t\t\t\t(scpart_id == scpart_map[n].part_id))\n\t\t\t\tbreak;\n\t\tif (n >= nr_scparts)\n\t\t\t \n\t\t\tcontinue;\n\n\t\t \n\t\tparts[nr_parts].offset = scpart_map[n].part_offs;\n\t\tparts[nr_parts].size = scpart_map[n].part_bytes;\n\t\tparts[nr_parts].of_node = pp;\n\n\t\tif (!of_property_read_string(pp, \"label\", &partname))\n\t\t\tparts[nr_parts].name = partname;\n\t\tif (of_property_read_bool(pp, \"read-only\"))\n\t\t\tparts[nr_parts].mask_flags |= MTD_WRITEABLE;\n\t\tif (of_property_read_bool(pp, \"lock\"))\n\t\t\tparts[nr_parts].mask_flags |= MTD_POWERUP_LOCK;\n\n\t\t \n\t\tscpart_map[n].part_id = ID_ALREADY_FOUND;\n\n\t\tnr_parts++;\n\t}\n\n\tif (nr_parts > 0) {\n\t\t*pparts = parts;\n\t\tres = nr_parts;\n\t} else\n\t\tpr_info(\"No partition in OF matches partition ID with 'SC PART MAP'.\\n\");\n\n\tof_node_put(pp);\n\nfree:\n\tof_node_put(ofpart_node);\n\tkfree(scpart_map);\n\tif (res <= 0)\n\t\tkfree(parts);\n\nout:\n\treturn res;\n}\n\nstatic const struct of_device_id scpart_parser_of_match_table[] = {\n\t{ .compatible = \"sercomm,sc-partitions\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, scpart_parser_of_match_table);\n\nstatic struct mtd_part_parser scpart_parser = {\n\t.parse_fn = scpart_parse,\n\t.name = \"scpart\",\n\t.of_match_table = scpart_parser_of_match_table,\n};\nmodule_mtd_part_parser(scpart_parser);\n\n \nMODULE_ALIAS(\"scpart\");\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"NOGUCHI Hiroshi <drvlabo@gmail.com>\");\nMODULE_AUTHOR(\"Mikhail Zhilkin <csharper2005@gmail.com>\");\nMODULE_DESCRIPTION(\"Sercomm partition parser\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}