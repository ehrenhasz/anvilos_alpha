{
  "module_name": "sharpslpart.c",
  "hash_id": "bb03b92be95a05ff7b1159352531d11f7739fd96b498a904051165cfdec6086c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/parsers/sharpslpart.c",
  "human_readable_source": " \n\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/bitops.h>\n#include <linux/sizes.h>\n#include <linux/mtd/mtd.h>\n#include <linux/mtd/partitions.h>\n\n \n#define NAND_NOOB_LOGADDR_00\t\t8\n#define NAND_NOOB_LOGADDR_01\t\t9\n#define NAND_NOOB_LOGADDR_10\t\t10\n#define NAND_NOOB_LOGADDR_11\t\t11\n#define NAND_NOOB_LOGADDR_20\t\t12\n#define NAND_NOOB_LOGADDR_21\t\t13\n\n#define BLOCK_IS_RESERVED\t\t0xffff\n#define BLOCK_UNMASK_COMPLEMENT\t\t1\n\n \n#define SHARPSL_NAND_PARTS\t\t3\n#define SHARPSL_FTL_PART_SIZE\t\t(7 * SZ_1M)\n#define SHARPSL_PARTINFO1_LADDR\t\t0x00060000\n#define SHARPSL_PARTINFO2_LADDR\t\t0x00064000\n\n#define BOOT_MAGIC\t\t\t0x424f4f54\n#define FSRO_MAGIC\t\t\t0x4653524f\n#define FSRW_MAGIC\t\t\t0x46535257\n\n \nstruct sharpsl_ftl {\n\tunsigned int logmax;\n\tunsigned int *log2phy;\n};\n\n \nstatic int sharpsl_nand_check_ooblayout(struct mtd_info *mtd)\n{\n\tu8 freebytes = 0;\n\tint section = 0;\n\n\twhile (true) {\n\t\tstruct mtd_oob_region oobfree = { };\n\t\tint ret, i;\n\n\t\tret = mtd_ooblayout_free(mtd, section++, &oobfree);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tif (!oobfree.length || oobfree.offset > 15 ||\n\t\t    (oobfree.offset + oobfree.length) < 8)\n\t\t\tcontinue;\n\n\t\ti = oobfree.offset >= 8 ? oobfree.offset : 8;\n\t\tfor (; i < oobfree.offset + oobfree.length && i < 16; i++)\n\t\t\tfreebytes |= BIT(i - 8);\n\n\t\tif (freebytes == 0xff)\n\t\t\treturn 0;\n\t}\n\n\treturn -ENOTSUPP;\n}\n\nstatic int sharpsl_nand_read_oob(struct mtd_info *mtd, loff_t offs, u8 *buf)\n{\n\tstruct mtd_oob_ops ops = { };\n\tint ret;\n\n\tops.mode = MTD_OPS_PLACE_OOB;\n\tops.ooblen = mtd->oobsize;\n\tops.oobbuf = buf;\n\n\tret = mtd_read_oob(mtd, offs, &ops);\n\tif (ret != 0 || mtd->oobsize != ops.oobretlen)\n\t\treturn -1;\n\n\treturn 0;\n}\n\n \nstatic int sharpsl_nand_get_logical_num(u8 *oob)\n{\n\tu16 us;\n\tint good0, good1;\n\n\tif (oob[NAND_NOOB_LOGADDR_00] == oob[NAND_NOOB_LOGADDR_10] &&\n\t    oob[NAND_NOOB_LOGADDR_01] == oob[NAND_NOOB_LOGADDR_11]) {\n\t\tgood0 = NAND_NOOB_LOGADDR_00;\n\t\tgood1 = NAND_NOOB_LOGADDR_01;\n\t} else if (oob[NAND_NOOB_LOGADDR_10] == oob[NAND_NOOB_LOGADDR_20] &&\n\t\t   oob[NAND_NOOB_LOGADDR_11] == oob[NAND_NOOB_LOGADDR_21]) {\n\t\tgood0 = NAND_NOOB_LOGADDR_10;\n\t\tgood1 = NAND_NOOB_LOGADDR_11;\n\t} else if (oob[NAND_NOOB_LOGADDR_20] == oob[NAND_NOOB_LOGADDR_00] &&\n\t\t   oob[NAND_NOOB_LOGADDR_21] == oob[NAND_NOOB_LOGADDR_01]) {\n\t\tgood0 = NAND_NOOB_LOGADDR_20;\n\t\tgood1 = NAND_NOOB_LOGADDR_21;\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\n\tus = oob[good0] | oob[good1] << 8;\n\n\t \n\tif (hweight16(us) & BLOCK_UNMASK_COMPLEMENT)\n\t\treturn -EINVAL;\n\n\t \n\tif (us == BLOCK_IS_RESERVED)\n\t\treturn BLOCK_IS_RESERVED;\n\n\treturn (us >> 1) & GENMASK(9, 0);\n}\n\nstatic int sharpsl_nand_init_ftl(struct mtd_info *mtd, struct sharpsl_ftl *ftl)\n{\n\tunsigned int block_num, phymax;\n\tint i, ret, log_num;\n\tloff_t block_adr;\n\tu8 *oob;\n\n\toob = kzalloc(mtd->oobsize, GFP_KERNEL);\n\tif (!oob)\n\t\treturn -ENOMEM;\n\n\tphymax = mtd_div_by_eb(SHARPSL_FTL_PART_SIZE, mtd);\n\n\t \n\tftl->logmax = ((phymax * 95) / 100) - 1;\n\n\tftl->log2phy = kmalloc_array(ftl->logmax, sizeof(*ftl->log2phy),\n\t\t\t\t     GFP_KERNEL);\n\tif (!ftl->log2phy) {\n\t\tret = -ENOMEM;\n\t\tgoto exit;\n\t}\n\n\t \n\tfor (i = 0; i < ftl->logmax; i++)\n\t\tftl->log2phy[i] = UINT_MAX;\n\n\t \n\tfor (block_num = 0; block_num < phymax; block_num++) {\n\t\tblock_adr = (loff_t)block_num * mtd->erasesize;\n\n\t\tif (mtd_block_isbad(mtd, block_adr))\n\t\t\tcontinue;\n\n\t\tif (sharpsl_nand_read_oob(mtd, block_adr, oob))\n\t\t\tcontinue;\n\n\t\t \n\t\tlog_num = sharpsl_nand_get_logical_num(oob);\n\n\t\t \n\t\tif (log_num > 0 && log_num < ftl->logmax) {\n\t\t\tif (ftl->log2phy[log_num] == UINT_MAX)\n\t\t\t\tftl->log2phy[log_num] = block_num;\n\t\t}\n\t}\n\n\tpr_info(\"Sharp SL FTL: %d blocks used (%d logical, %d reserved)\\n\",\n\t\tphymax, ftl->logmax, phymax - ftl->logmax);\n\n\tret = 0;\nexit:\n\tkfree(oob);\n\treturn ret;\n}\n\nstatic void sharpsl_nand_cleanup_ftl(struct sharpsl_ftl *ftl)\n{\n\tkfree(ftl->log2phy);\n}\n\nstatic int sharpsl_nand_read_laddr(struct mtd_info *mtd,\n\t\t\t\t   loff_t from,\n\t\t\t\t   size_t len,\n\t\t\t\t   void *buf,\n\t\t\t\t   struct sharpsl_ftl *ftl)\n{\n\tunsigned int log_num, final_log_num;\n\tunsigned int block_num;\n\tloff_t block_adr;\n\tloff_t block_ofs;\n\tsize_t retlen;\n\tint err;\n\n\tlog_num = mtd_div_by_eb((u32)from, mtd);\n\tfinal_log_num = mtd_div_by_eb(((u32)from + len - 1), mtd);\n\n\tif (len <= 0 || log_num >= ftl->logmax || final_log_num > log_num)\n\t\treturn -EINVAL;\n\n\tblock_num = ftl->log2phy[log_num];\n\tblock_adr = (loff_t)block_num * mtd->erasesize;\n\tblock_ofs = mtd_mod_by_eb((u32)from, mtd);\n\n\terr = mtd_read(mtd, block_adr + block_ofs, len, &retlen, buf);\n\t \n\tif (mtd_is_bitflip(err))\n\t\terr = 0;\n\n\tif (!err && retlen != len)\n\t\terr = -EIO;\n\n\tif (err)\n\t\tpr_err(\"sharpslpart: error, read failed at %#llx\\n\",\n\t\t       block_adr + block_ofs);\n\n\treturn err;\n}\n\n \nstruct sharpsl_nand_partinfo {\n\t__le32 start;\n\t__le32 end;\n\t__be32 magic;\n\tu32 reserved;\n};\n\nstatic int sharpsl_nand_read_partinfo(struct mtd_info *master,\n\t\t\t\t      loff_t from,\n\t\t\t\t      size_t len,\n\t\t\t\t      struct sharpsl_nand_partinfo *buf,\n\t\t\t\t      struct sharpsl_ftl *ftl)\n{\n\tint ret;\n\n\tret = sharpsl_nand_read_laddr(master, from, len, buf, ftl);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (be32_to_cpu(buf[0].magic) != BOOT_MAGIC ||\n\t    be32_to_cpu(buf[1].magic) != FSRO_MAGIC ||\n\t    be32_to_cpu(buf[2].magic) != FSRW_MAGIC) {\n\t\tpr_err(\"sharpslpart: magic values mismatch\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tbuf[2].end = cpu_to_le32(master->size);\n\n\t \n\tif (le32_to_cpu(buf[0].end) <= le32_to_cpu(buf[0].start) ||\n\t    le32_to_cpu(buf[1].start) < le32_to_cpu(buf[0].end) ||\n\t    le32_to_cpu(buf[1].end) <= le32_to_cpu(buf[1].start) ||\n\t    le32_to_cpu(buf[2].start) < le32_to_cpu(buf[1].end) ||\n\t    le32_to_cpu(buf[2].end) <= le32_to_cpu(buf[2].start)) {\n\t\tpr_err(\"sharpslpart: partition sizes mismatch\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int sharpsl_parse_mtd_partitions(struct mtd_info *master,\n\t\t\t\t\tconst struct mtd_partition **pparts,\n\t\t\t\t\tstruct mtd_part_parser_data *data)\n{\n\tstruct sharpsl_ftl ftl;\n\tstruct sharpsl_nand_partinfo buf[SHARPSL_NAND_PARTS];\n\tstruct mtd_partition *sharpsl_nand_parts;\n\tint err;\n\n\t \n\terr = sharpsl_nand_check_ooblayout(master);\n\tif (err)\n\t\treturn err;\n\n\t \n\terr = sharpsl_nand_init_ftl(master, &ftl);\n\tif (err)\n\t\treturn err;\n\n\t \n\tpr_info(\"sharpslpart: try reading first partition table\\n\");\n\terr = sharpsl_nand_read_partinfo(master,\n\t\t\t\t\t SHARPSL_PARTINFO1_LADDR,\n\t\t\t\t\t sizeof(buf), buf, &ftl);\n\tif (err) {\n\t\t \n\t\tpr_warn(\"sharpslpart: first partition table is invalid, retry using the second\\n\");\n\t\terr = sharpsl_nand_read_partinfo(master,\n\t\t\t\t\t\t SHARPSL_PARTINFO2_LADDR,\n\t\t\t\t\t\t sizeof(buf), buf, &ftl);\n\t}\n\n\t \n\tsharpsl_nand_cleanup_ftl(&ftl);\n\n\tif (err) {\n\t\tpr_err(\"sharpslpart: both partition tables are invalid\\n\");\n\t\treturn err;\n\t}\n\n\tsharpsl_nand_parts = kcalloc(SHARPSL_NAND_PARTS,\n\t\t\t\t     sizeof(*sharpsl_nand_parts),\n\t\t\t\t     GFP_KERNEL);\n\tif (!sharpsl_nand_parts)\n\t\treturn -ENOMEM;\n\n\t \n\tsharpsl_nand_parts[0].name = \"smf\";\n\tsharpsl_nand_parts[0].offset = le32_to_cpu(buf[0].start);\n\tsharpsl_nand_parts[0].size = le32_to_cpu(buf[0].end) -\n\t\t\t\t     le32_to_cpu(buf[0].start);\n\n\tsharpsl_nand_parts[1].name = \"root\";\n\tsharpsl_nand_parts[1].offset = le32_to_cpu(buf[1].start);\n\tsharpsl_nand_parts[1].size = le32_to_cpu(buf[1].end) -\n\t\t\t\t     le32_to_cpu(buf[1].start);\n\n\tsharpsl_nand_parts[2].name = \"home\";\n\tsharpsl_nand_parts[2].offset = le32_to_cpu(buf[2].start);\n\tsharpsl_nand_parts[2].size = le32_to_cpu(buf[2].end) -\n\t\t\t\t     le32_to_cpu(buf[2].start);\n\n\t*pparts = sharpsl_nand_parts;\n\treturn SHARPSL_NAND_PARTS;\n}\n\nstatic struct mtd_part_parser sharpsl_mtd_parser = {\n\t.parse_fn = sharpsl_parse_mtd_partitions,\n\t.name = \"sharpslpart\",\n};\nmodule_mtd_part_parser(sharpsl_mtd_parser);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Andrea Adami <andrea.adami@gmail.com>\");\nMODULE_DESCRIPTION(\"MTD partitioning for NAND flash on Sharp SL Series\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}