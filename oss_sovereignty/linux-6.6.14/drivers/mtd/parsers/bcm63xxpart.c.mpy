{
  "module_name": "bcm63xxpart.c",
  "hash_id": "5e6824f0f0f02f98313753c53a0b03dbe74b77fc2e8f584bfd270635a89d91ab",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/parsers/bcm63xxpart.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/bcm963xx_nvram.h>\n#include <linux/bcm963xx_tag.h>\n#include <linux/crc32.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/sizes.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/mtd/mtd.h>\n#include <linux/mtd/partitions.h>\n#include <linux/of.h>\n\n#ifdef CONFIG_MIPS\n#include <asm/bootinfo.h>\n#include <asm/fw/cfe/cfe_api.h>\n#endif  \n\n#define BCM963XX_CFE_BLOCK_SIZE\t\tSZ_64K\t \n\n#define BCM963XX_CFE_MAGIC_OFFSET\t0x4e0\n#define BCM963XX_CFE_VERSION_OFFSET\t0x570\n#define BCM963XX_NVRAM_OFFSET\t\t0x580\n\n \n#define STR_NULL_TERMINATE(x) \\\n\tdo { char *_str = (x); _str[sizeof(x) - 1] = 0; } while (0)\n\nstatic inline int bcm63xx_detect_cfe(void)\n{\n\tint ret = 0;\n\n#ifdef CONFIG_MIPS\n\tret = (fw_arg3 == CFE_EPTSEAL);\n#endif  \n\n\treturn ret;\n}\n\nstatic int bcm63xx_read_nvram(struct mtd_info *master,\n\tstruct bcm963xx_nvram *nvram)\n{\n\tu32 actual_crc, expected_crc;\n\tsize_t retlen;\n\tint ret;\n\n\t \n\tret = mtd_read(master, BCM963XX_NVRAM_OFFSET, BCM963XX_NVRAM_V5_SIZE,\n\t\t\t&retlen, (void *)nvram);\n\tif (ret)\n\t\treturn ret;\n\n\tret = bcm963xx_nvram_checksum(nvram, &expected_crc, &actual_crc);\n\tif (ret)\n\t\tpr_warn(\"nvram checksum failed, contents may be invalid (expected %08x, got %08x)\\n\",\n\t\t\texpected_crc, actual_crc);\n\n\tif (!nvram->psi_size)\n\t\tnvram->psi_size = BCM963XX_DEFAULT_PSI_SIZE;\n\n\treturn 0;\n}\n\nstatic const char * const bcm63xx_cfe_part_types[] = {\n\t\"bcm963xx-imagetag\",\n\tNULL,\n};\n\nstatic int bcm63xx_parse_cfe_nor_partitions(struct mtd_info *master,\n\tconst struct mtd_partition **pparts, struct bcm963xx_nvram *nvram)\n{\n\tstruct mtd_partition *parts;\n\tint nrparts = 3, curpart = 0;\n\tunsigned int cfelen, nvramlen;\n\tunsigned int cfe_erasesize;\n\tint i;\n\n\tcfe_erasesize = max_t(uint32_t, master->erasesize,\n\t\t\t      BCM963XX_CFE_BLOCK_SIZE);\n\n\tcfelen = cfe_erasesize;\n\tnvramlen = nvram->psi_size * SZ_1K;\n\tnvramlen = roundup(nvramlen, cfe_erasesize);\n\n\tparts = kzalloc(sizeof(*parts) * nrparts + 10 * nrparts, GFP_KERNEL);\n\tif (!parts)\n\t\treturn -ENOMEM;\n\n\t \n\tparts[curpart].name = \"CFE\";\n\tparts[curpart].offset = 0;\n\tparts[curpart].size = cfelen;\n\tcurpart++;\n\n\tparts[curpart].name = \"nvram\";\n\tparts[curpart].offset = master->size - nvramlen;\n\tparts[curpart].size = nvramlen;\n\tcurpart++;\n\n\t \n\tparts[curpart].name = \"linux\";\n\tparts[curpart].offset = cfelen;\n\tparts[curpart].size = master->size - cfelen - nvramlen;\n\tparts[curpart].types = bcm63xx_cfe_part_types;\n\n\tfor (i = 0; i < nrparts; i++)\n\t\tpr_info(\"Partition %d is %s offset %llx and length %llx\\n\", i,\n\t\t\tparts[i].name, parts[i].offset,\tparts[i].size);\n\n\t*pparts = parts;\n\n\treturn nrparts;\n}\n\nstatic int bcm63xx_parse_cfe_partitions(struct mtd_info *master,\n\t\t\t\t\tconst struct mtd_partition **pparts,\n\t\t\t\t\tstruct mtd_part_parser_data *data)\n{\n\tstruct bcm963xx_nvram *nvram = NULL;\n\tint ret;\n\n\tif (!bcm63xx_detect_cfe())\n\t\treturn -EINVAL;\n\n\tnvram = vzalloc(sizeof(*nvram));\n\tif (!nvram)\n\t\treturn -ENOMEM;\n\n\tret = bcm63xx_read_nvram(master, nvram);\n\tif (ret)\n\t\tgoto out;\n\n\tif (!mtd_type_is_nand(master))\n\t\tret = bcm63xx_parse_cfe_nor_partitions(master, pparts, nvram);\n\telse\n\t\tret = -EINVAL;\n\nout:\n\tvfree(nvram);\n\treturn ret;\n};\n\nstatic const struct of_device_id parse_bcm63xx_cfe_match_table[] = {\n\t{ .compatible = \"brcm,bcm963xx-cfe-nor-partitions\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, parse_bcm63xx_cfe_match_table);\n\nstatic struct mtd_part_parser bcm63xx_cfe_parser = {\n\t.parse_fn = bcm63xx_parse_cfe_partitions,\n\t.name = \"bcm63xxpart\",\n\t.of_match_table = parse_bcm63xx_cfe_match_table,\n};\nmodule_mtd_part_parser(bcm63xx_cfe_parser);\n\nMODULE_AUTHOR(\"Daniel Dickinson <openwrt@cshore.neomailbox.net>\");\nMODULE_AUTHOR(\"Florian Fainelli <florian@openwrt.org>\");\nMODULE_AUTHOR(\"Mike Albon <malbon@openwrt.org>\");\nMODULE_AUTHOR(\"Jonas Gorski <jonas.gorski@gmail.com\");\nMODULE_DESCRIPTION(\"MTD partitioning for BCM63XX CFE bootloaders\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}