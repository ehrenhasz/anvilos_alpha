{
  "module_name": "parser_imagetag.c",
  "hash_id": "ff6298e8c6b7d33f792fe726e4203343cbb9cb7a85a2950f372d2b93604906ff",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/parsers/parser_imagetag.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/bcm963xx_tag.h>\n#include <linux/crc32.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/sizes.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/mtd/mtd.h>\n#include <linux/mtd/partitions.h>\n#include <linux/of.h>\n\n \n#define STR_NULL_TERMINATE(x) \\\n\tdo { char *_str = (x); _str[sizeof(x) - 1] = 0; } while (0)\n\nstatic int bcm963xx_read_imagetag(struct mtd_info *master, const char *name,\n\tloff_t tag_offset, struct bcm_tag *buf)\n{\n\tint ret;\n\tsize_t retlen;\n\tu32 computed_crc;\n\n\tret = mtd_read(master, tag_offset, sizeof(*buf), &retlen, (void *)buf);\n\tif (ret)\n\t\treturn ret;\n\n\tif (retlen != sizeof(*buf))\n\t\treturn -EIO;\n\n\tcomputed_crc = crc32_le(IMAGETAG_CRC_START, (u8 *)buf,\n\t\t\t\toffsetof(struct bcm_tag, header_crc));\n\tif (computed_crc == buf->header_crc) {\n\t\tSTR_NULL_TERMINATE(buf->board_id);\n\t\tSTR_NULL_TERMINATE(buf->tag_version);\n\n\t\tpr_info(\"%s: CFE image tag found at 0x%llx with version %s, board type %s\\n\",\n\t\t\tname, tag_offset, buf->tag_version, buf->board_id);\n\n\t\treturn 0;\n\t}\n\n\tpr_warn(\"%s: CFE image tag at 0x%llx CRC invalid (expected %08x, actual %08x)\\n\",\n\t\tname, tag_offset, buf->header_crc, computed_crc);\n\treturn -EINVAL;\n}\n\nstatic int bcm963xx_parse_imagetag_partitions(struct mtd_info *master,\n\t\t\t\t\tconst struct mtd_partition **pparts,\n\t\t\t\t\tstruct mtd_part_parser_data *data)\n{\n\t \n\tint nrparts = 0, curpart = 0;\n\tstruct bcm_tag *buf = NULL;\n\tstruct mtd_partition *parts;\n\tint ret;\n\tunsigned int rootfsaddr, kerneladdr, spareaddr, offset;\n\tunsigned int rootfslen, kernellen, sparelen, totallen;\n\tint i;\n\tbool rootfs_first = false;\n\n\tbuf = vmalloc(sizeof(struct bcm_tag));\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\t \n\tret = bcm963xx_read_imagetag(master, \"rootfs\", 0, buf);\n\tif (!ret) {\n\t\tSTR_NULL_TERMINATE(buf->flash_image_start);\n\t\tif (kstrtouint(buf->flash_image_start, 10, &rootfsaddr) ||\n\t\t\t\trootfsaddr < BCM963XX_EXTENDED_SIZE) {\n\t\t\tpr_err(\"invalid rootfs address: %*ph\\n\",\n\t\t\t\t(int)sizeof(buf->flash_image_start),\n\t\t\t\tbuf->flash_image_start);\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tSTR_NULL_TERMINATE(buf->kernel_address);\n\t\tif (kstrtouint(buf->kernel_address, 10, &kerneladdr) ||\n\t\t\t\tkerneladdr < BCM963XX_EXTENDED_SIZE) {\n\t\t\tpr_err(\"invalid kernel address: %*ph\\n\",\n\t\t\t\t(int)sizeof(buf->kernel_address),\n\t\t\t\tbuf->kernel_address);\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tSTR_NULL_TERMINATE(buf->kernel_length);\n\t\tif (kstrtouint(buf->kernel_length, 10, &kernellen)) {\n\t\t\tpr_err(\"invalid kernel length: %*ph\\n\",\n\t\t\t\t(int)sizeof(buf->kernel_length),\n\t\t\t\tbuf->kernel_length);\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tSTR_NULL_TERMINATE(buf->total_length);\n\t\tif (kstrtouint(buf->total_length, 10, &totallen)) {\n\t\t\tpr_err(\"invalid total length: %*ph\\n\",\n\t\t\t\t(int)sizeof(buf->total_length),\n\t\t\t\tbuf->total_length);\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\tif (rootfsaddr < kerneladdr)\n\t\t\toffset = rootfsaddr - sizeof(struct bcm_tag);\n\t\telse\n\t\t\toffset = kerneladdr - sizeof(struct bcm_tag);\n\n\t\tkerneladdr = kerneladdr - offset;\n\t\trootfsaddr = rootfsaddr - offset;\n\t\tspareaddr = roundup(totallen, master->erasesize);\n\n\t\tif (rootfsaddr < kerneladdr) {\n\t\t\t \n\t\t\trootfslen = kerneladdr - rootfsaddr;\n\t\t\trootfs_first = true;\n\t\t} else {\n\t\t\t \n\t\t\trootfsaddr = kerneladdr + kernellen;\n\t\t\trootfslen = spareaddr - rootfsaddr;\n\t\t}\n\t} else {\n\t\tgoto out;\n\t}\n\tsparelen = master->size - spareaddr;\n\n\t \n\tif (rootfslen > 0)\n\t\tnrparts++;\n\n\tif (kernellen > 0)\n\t\tnrparts++;\n\n\tparts = kzalloc(sizeof(*parts) * nrparts + 10 * nrparts, GFP_KERNEL);\n\tif (!parts) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\t \n\tif (kernellen > 0) {\n\t\tint kernelpart = curpart;\n\n\t\tif (rootfslen > 0 && rootfs_first)\n\t\t\tkernelpart++;\n\t\tparts[kernelpart].name = \"kernel\";\n\t\tparts[kernelpart].offset = kerneladdr;\n\t\tparts[kernelpart].size = kernellen;\n\t\tcurpart++;\n\t}\n\n\tif (rootfslen > 0) {\n\t\tint rootfspart = curpart;\n\n\t\tif (kernellen > 0 && rootfs_first)\n\t\t\trootfspart--;\n\t\tparts[rootfspart].name = \"rootfs\";\n\t\tparts[rootfspart].offset = rootfsaddr;\n\t\tparts[rootfspart].size = rootfslen;\n\t\tif (sparelen > 0  && !rootfs_first)\n\t\t\tparts[rootfspart].size += sparelen;\n\t\tcurpart++;\n\t}\n\n\tfor (i = 0; i < nrparts; i++)\n\t\tpr_info(\"Partition %d is %s offset %llx and length %llx\\n\", i,\n\t\t\tparts[i].name, parts[i].offset,\tparts[i].size);\n\n\tpr_info(\"Spare partition is offset %x and length %x\\n\",\tspareaddr,\n\t\tsparelen);\n\n\t*pparts = parts;\n\tret = 0;\n\nout:\n\tvfree(buf);\n\n\tif (ret)\n\t\treturn ret;\n\n\treturn nrparts;\n}\n\nstatic const struct of_device_id parse_bcm963xx_imagetag_match_table[] = {\n\t{ .compatible = \"brcm,bcm963xx-imagetag\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, parse_bcm963xx_imagetag_match_table);\n\nstatic struct mtd_part_parser bcm963xx_imagetag_parser = {\n\t.parse_fn = bcm963xx_parse_imagetag_partitions,\n\t.name = \"bcm963xx-imagetag\",\n\t.of_match_table = parse_bcm963xx_imagetag_match_table,\n};\nmodule_mtd_part_parser(bcm963xx_imagetag_parser);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Daniel Dickinson <openwrt@cshore.neomailbox.net>\");\nMODULE_AUTHOR(\"Florian Fainelli <florian@openwrt.org>\");\nMODULE_AUTHOR(\"Mike Albon <malbon@openwrt.org>\");\nMODULE_AUTHOR(\"Jonas Gorski <jonas.gorski@gmail.com>\");\nMODULE_DESCRIPTION(\"MTD parser for BCM963XX CFE Image Tag partitions\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}