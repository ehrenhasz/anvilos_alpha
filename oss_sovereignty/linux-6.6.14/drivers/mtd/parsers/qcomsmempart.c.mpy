{
  "module_name": "qcomsmempart.c",
  "hash_id": "76048b2a7269682b5c1af76f658d37a097c2bba89716e5786551bbb9d90dc81e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/parsers/qcomsmempart.c",
  "human_readable_source": "\n \n\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/mtd/mtd.h>\n#include <linux/mtd/partitions.h>\n#include <linux/slab.h>\n#include <linux/soc/qcom/smem.h>\n\n#define SMEM_AARM_PARTITION_TABLE\t9\n#define SMEM_APPS\t\t\t0\n\n#define SMEM_FLASH_PART_MAGIC1\t\t0x55ee73aa\n#define SMEM_FLASH_PART_MAGIC2\t\t0xe35ebddb\n#define SMEM_FLASH_PTABLE_V3\t\t3\n#define SMEM_FLASH_PTABLE_V4\t\t4\n#define SMEM_FLASH_PTABLE_MAX_PARTS_V3\t16\n#define SMEM_FLASH_PTABLE_MAX_PARTS_V4\t48\n#define SMEM_FLASH_PTABLE_HDR_LEN\t(4 * sizeof(u32))\n#define SMEM_FLASH_PTABLE_NAME_SIZE\t16\n\n \nstruct smem_flash_pentry {\n\tchar name[SMEM_FLASH_PTABLE_NAME_SIZE];\n\t__le32 offset;\n\t__le32 length;\n\tu8 attr;\n} __packed __aligned(4);\n\n \nstruct smem_flash_ptable {\n\t__le32 magic1;\n\t__le32 magic2;\n\t__le32 version;\n\t__le32 numparts;\n\tstruct smem_flash_pentry pentry[SMEM_FLASH_PTABLE_MAX_PARTS_V4];\n} __packed __aligned(4);\n\nstatic int parse_qcomsmem_part(struct mtd_info *mtd,\n\t\t\t       const struct mtd_partition **pparts,\n\t\t\t       struct mtd_part_parser_data *data)\n{\n\tsize_t len = SMEM_FLASH_PTABLE_HDR_LEN;\n\tint ret, i, j, tmpparts, numparts = 0;\n\tstruct smem_flash_pentry *pentry;\n\tstruct smem_flash_ptable *ptable;\n\tstruct mtd_partition *parts;\n\tchar *name, *c;\n\n\tif (IS_ENABLED(CONFIG_MTD_SPI_NOR_USE_4K_SECTORS)\n\t\t\t&& mtd->type == MTD_NORFLASH) {\n\t\tpr_err(\"%s: SMEM partition parser is incompatible with 4K sectors\\n\",\n\t\t\t\tmtd->name);\n\t\treturn -EINVAL;\n\t}\n\n\tpr_debug(\"Parsing partition table info from SMEM\\n\");\n\tptable = qcom_smem_get(SMEM_APPS, SMEM_AARM_PARTITION_TABLE, &len);\n\tif (IS_ERR(ptable)) {\n\t\tif (PTR_ERR(ptable) != -EPROBE_DEFER)\n\t\t\tpr_err(\"Error reading partition table header\\n\");\n\t\treturn PTR_ERR(ptable);\n\t}\n\n\t \n\tif (le32_to_cpu(ptable->magic1) != SMEM_FLASH_PART_MAGIC1 ||\n\t    le32_to_cpu(ptable->magic2) != SMEM_FLASH_PART_MAGIC2) {\n\t\tpr_err(\"Partition table magic verification failed\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\ttmpparts = le32_to_cpu(ptable->numparts);\n\tif (tmpparts > SMEM_FLASH_PTABLE_MAX_PARTS_V4) {\n\t\tpr_err(\"Partition numbers exceed the max limit\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (le32_to_cpu(ptable->version) <= SMEM_FLASH_PTABLE_V3) {\n\t\tlen = SMEM_FLASH_PTABLE_HDR_LEN + SMEM_FLASH_PTABLE_MAX_PARTS_V3 *\n\t\t\tsizeof(struct smem_flash_pentry);\n\t} else if (le32_to_cpu(ptable->version) == SMEM_FLASH_PTABLE_V4) {\n\t\tlen = SMEM_FLASH_PTABLE_HDR_LEN + SMEM_FLASH_PTABLE_MAX_PARTS_V4 *\n\t\t\tsizeof(struct smem_flash_pentry);\n\t} else {\n\t\tpr_err(\"Unknown ptable version (%d)\", le32_to_cpu(ptable->version));\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tptable = qcom_smem_get(SMEM_APPS, SMEM_AARM_PARTITION_TABLE, &len);\n\tif (IS_ERR(ptable)) {\n\t\tpr_err(\"Error reading partition table\\n\");\n\t\treturn PTR_ERR(ptable);\n\t}\n\n\tfor (i = 0; i < tmpparts; i++) {\n\t\tpentry = &ptable->pentry[i];\n\t\tif (pentry->name[0] != '\\0')\n\t\t\tnumparts++;\n\t}\n\n\tparts = kcalloc(numparts, sizeof(*parts), GFP_KERNEL);\n\tif (!parts)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0, j = 0; i < tmpparts; i++) {\n\t\tpentry = &ptable->pentry[i];\n\t\tif (pentry->name[0] == '\\0')\n\t\t\tcontinue;\n\n\t\tname = kstrdup(pentry->name, GFP_KERNEL);\n\t\tif (!name) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out_free_parts;\n\t\t}\n\n\t\t \n\t\tfor (c = name; *c != '\\0'; c++)\n\t\t\t*c = tolower(*c);\n\n\t\tparts[j].name = name;\n\t\tparts[j].offset = le32_to_cpu(pentry->offset) * mtd->erasesize;\n\t\tparts[j].mask_flags = pentry->attr;\n\t\tparts[j].size = le32_to_cpu(pentry->length) * mtd->erasesize;\n\t\tpr_debug(\"%d: %s offs=0x%08x size=0x%08x attr:0x%08x\\n\",\n\t\t\t i, pentry->name, le32_to_cpu(pentry->offset),\n\t\t\t le32_to_cpu(pentry->length), pentry->attr);\n\t\tj++;\n\t}\n\n\tpr_debug(\"SMEM partition table found: ver: %d len: %d\\n\",\n\t\t le32_to_cpu(ptable->version), tmpparts);\n\t*pparts = parts;\n\n\treturn numparts;\n\nout_free_parts:\n\twhile (--j >= 0)\n\t\tkfree(parts[j].name);\n\tkfree(parts);\n\t*pparts = NULL;\n\n\treturn ret;\n}\n\nstatic void parse_qcomsmem_cleanup(const struct mtd_partition *pparts,\n\t\t\t\t   int nr_parts)\n{\n\tint i;\n\n\tfor (i = 0; i < nr_parts; i++)\n\t\tkfree(pparts[i].name);\n\n\tkfree(pparts);\n}\n\nstatic const struct of_device_id qcomsmem_of_match_table[] = {\n\t{ .compatible = \"qcom,smem-part\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, qcomsmem_of_match_table);\n\nstatic struct mtd_part_parser mtd_parser_qcomsmem = {\n\t.parse_fn = parse_qcomsmem_part,\n\t.cleanup = parse_qcomsmem_cleanup,\n\t.name = \"qcomsmem\",\n\t.of_match_table = qcomsmem_of_match_table,\n};\nmodule_mtd_part_parser(mtd_parser_qcomsmem);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Manivannan Sadhasivam <manivannan.sadhasivam@linaro.org>\");\nMODULE_DESCRIPTION(\"Qualcomm SMEM NAND flash partition parser\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}