{
  "module_name": "tplink_safeloader.c",
  "hash_id": "a4be6678aea00b47ce6fd1e3eaaf8305f37a4cae8fae9f07b2f9089c21075ad2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/parsers/tplink_safeloader.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/mtd/mtd.h>\n#include <linux/mtd/partitions.h>\n#include <linux/of.h>\n#include <linux/slab.h>\n\n#define TPLINK_SAFELOADER_DATA_OFFSET\t\t4\n#define TPLINK_SAFELOADER_MAX_PARTS\t\t32\n\nstruct safeloader_cmn_header {\n\t__be32 size;\n\tuint32_t unused;\n} __packed;\n\nstatic void *mtd_parser_tplink_safeloader_read_table(struct mtd_info *mtd)\n{\n\tstruct safeloader_cmn_header hdr;\n\tstruct device_node *np;\n\tsize_t bytes_read;\n\tsize_t size;\n\tu32 offset;\n\tchar *buf;\n\tint err;\n\n\tnp = mtd_get_of_node(mtd);\n\tif (mtd_is_partition(mtd))\n\t\tof_node_get(np);\n\telse\n\t\tnp = of_get_child_by_name(np, \"partitions\");\n\n\tif (of_property_read_u32(np, \"partitions-table-offset\", &offset)) {\n\t\tpr_err(\"Failed to get partitions table offset\\n\");\n\t\tgoto err_put;\n\t}\n\n\terr = mtd_read(mtd, offset, sizeof(hdr), &bytes_read, (uint8_t *)&hdr);\n\tif (err && !mtd_is_bitflip(err)) {\n\t\tpr_err(\"Failed to read from %s at 0x%x\\n\", mtd->name, offset);\n\t\tgoto err_put;\n\t}\n\n\tsize = be32_to_cpu(hdr.size);\n\n\tbuf = kmalloc(size + 1, GFP_KERNEL);\n\tif (!buf)\n\t\tgoto err_put;\n\n\terr = mtd_read(mtd, offset + sizeof(hdr), size, &bytes_read, buf);\n\tif (err && !mtd_is_bitflip(err)) {\n\t\tpr_err(\"Failed to read from %s at 0x%zx\\n\", mtd->name, offset + sizeof(hdr));\n\t\tgoto err_kfree;\n\t}\n\n\tbuf[size] = '\\0';\n\n\tof_node_put(np);\n\n\treturn buf;\n\nerr_kfree:\n\tkfree(buf);\nerr_put:\n\tof_node_put(np);\n\treturn NULL;\n}\n\nstatic int mtd_parser_tplink_safeloader_parse(struct mtd_info *mtd,\n\t\t\t\t\t      const struct mtd_partition **pparts,\n\t\t\t\t\t      struct mtd_part_parser_data *data)\n{\n\tstruct mtd_partition *parts;\n\tchar name[65];\n\tsize_t offset;\n\tsize_t bytes;\n\tchar *buf;\n\tint idx;\n\tint err;\n\n\tparts = kcalloc(TPLINK_SAFELOADER_MAX_PARTS, sizeof(*parts), GFP_KERNEL);\n\tif (!parts) {\n\t\terr = -ENOMEM;\n\t\tgoto err_out;\n\t}\n\n\tbuf = mtd_parser_tplink_safeloader_read_table(mtd);\n\tif (!buf) {\n\t\terr = -ENOENT;\n\t\tgoto err_free_parts;\n\t}\n\n\tfor (idx = 0, offset = TPLINK_SAFELOADER_DATA_OFFSET;\n\t     idx < TPLINK_SAFELOADER_MAX_PARTS &&\n\t     sscanf(buf + offset, \"partition %64s base 0x%llx size 0x%llx%zn\\n\",\n\t\t    name, &parts[idx].offset, &parts[idx].size, &bytes) == 3;\n\t     idx++, offset += bytes + 1) {\n\t\tparts[idx].name = kstrdup(name, GFP_KERNEL);\n\t\tif (!parts[idx].name) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto err_free;\n\t\t}\n\t}\n\n\tif (idx == TPLINK_SAFELOADER_MAX_PARTS)\n\t\tpr_warn(\"Reached maximum number of partitions!\\n\");\n\n\tkfree(buf);\n\n\t*pparts = parts;\n\n\treturn idx;\n\nerr_free:\n\tfor (idx -= 1; idx >= 0; idx--)\n\t\tkfree(parts[idx].name);\nerr_free_parts:\n\tkfree(parts);\nerr_out:\n\treturn err;\n};\n\nstatic void mtd_parser_tplink_safeloader_cleanup(const struct mtd_partition *pparts,\n\t\t\t\t\t\t int nr_parts)\n{\n\tint i;\n\n\tfor (i = 0; i < nr_parts; i++)\n\t\tkfree(pparts[i].name);\n\n\tkfree(pparts);\n}\n\nstatic const struct of_device_id mtd_parser_tplink_safeloader_of_match_table[] = {\n\t{ .compatible = \"tplink,safeloader-partitions\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, mtd_parser_tplink_safeloader_of_match_table);\n\nstatic struct mtd_part_parser mtd_parser_tplink_safeloader = {\n\t.parse_fn = mtd_parser_tplink_safeloader_parse,\n\t.cleanup = mtd_parser_tplink_safeloader_cleanup,\n\t.name = \"tplink-safeloader\",\n\t.of_match_table = mtd_parser_tplink_safeloader_of_match_table,\n};\nmodule_mtd_part_parser(mtd_parser_tplink_safeloader);\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}