{
  "module_name": "parser_trx.c",
  "hash_id": "65c995e361f9ca52535bb790b833cdd5602d9eae4c8bb5d21204b464a3556176",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/parsers/parser_trx.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/mtd/mtd.h>\n#include <linux/mtd/partitions.h>\n\n#define TRX_PARSER_MAX_PARTS\t\t4\n\n \n#define TRX_MAGIC\t\t\t0x30524448\n#define UBI_EC_MAGIC\t\t\t0x23494255\t \n\nstruct trx_header {\n\tuint32_t magic;\n\tuint32_t length;\n\tuint32_t crc32;\n\tuint16_t flags;\n\tuint16_t version;\n\tuint32_t offset[3];\n} __packed;\n\nstatic const char *parser_trx_data_part_name(struct mtd_info *master,\n\t\t\t\t\t     size_t offset)\n{\n\tuint32_t buf;\n\tsize_t bytes_read;\n\tint err;\n\n\terr  = mtd_read(master, offset, sizeof(buf), &bytes_read,\n\t\t\t(uint8_t *)&buf);\n\tif (err && !mtd_is_bitflip(err)) {\n\t\tpr_err(\"mtd_read error while parsing (offset: 0x%zX): %d\\n\",\n\t\t\toffset, err);\n\t\tgoto out_default;\n\t}\n\n\tif (buf == UBI_EC_MAGIC)\n\t\treturn \"ubi\";\n\nout_default:\n\treturn \"rootfs\";\n}\n\nstatic int parser_trx_parse(struct mtd_info *mtd,\n\t\t\t    const struct mtd_partition **pparts,\n\t\t\t    struct mtd_part_parser_data *data)\n{\n\tstruct device_node *np = mtd_get_of_node(mtd);\n\tstruct mtd_partition *parts;\n\tstruct mtd_partition *part;\n\tstruct trx_header trx;\n\tsize_t bytes_read;\n\tuint8_t curr_part = 0, i = 0;\n\tuint32_t trx_magic = TRX_MAGIC;\n\tint err;\n\n\t \n\terr = of_property_read_u32(np, \"brcm,trx-magic\", &trx_magic);\n\tif (err != 0 && err != -EINVAL)\n\t\tpr_err(\"failed to parse \\\"brcm,trx-magic\\\" DT attribute, using default: %d\\n\", err);\n\n\tparts = kcalloc(TRX_PARSER_MAX_PARTS, sizeof(struct mtd_partition),\n\t\t\tGFP_KERNEL);\n\tif (!parts)\n\t\treturn -ENOMEM;\n\n\terr = mtd_read(mtd, 0, sizeof(trx), &bytes_read, (uint8_t *)&trx);\n\tif (err) {\n\t\tpr_err(\"MTD reading error: %d\\n\", err);\n\t\tkfree(parts);\n\t\treturn err;\n\t}\n\n\tif (trx.magic != trx_magic) {\n\t\tkfree(parts);\n\t\treturn -ENOENT;\n\t}\n\n\t \n\tif (trx.offset[2]) {\n\t\tpart = &parts[curr_part++];\n\t\tpart->name = \"loader\";\n\t\tpart->offset = trx.offset[i];\n\t\ti++;\n\t}\n\n\tif (trx.offset[i]) {\n\t\tpart = &parts[curr_part++];\n\t\tpart->name = \"linux\";\n\t\tpart->offset = trx.offset[i];\n\t\ti++;\n\t}\n\n\tif (trx.offset[i]) {\n\t\tpart = &parts[curr_part++];\n\t\tpart->name = parser_trx_data_part_name(mtd, trx.offset[i]);\n\t\tpart->offset = trx.offset[i];\n\t\ti++;\n\t}\n\n\t \n\tfor (i = 0; i < curr_part; i++) {\n\t\tu64 next_part_offset = (i < curr_part - 1) ?\n\t\t\t\t       parts[i + 1].offset : mtd->size;\n\n\t\tparts[i].size = next_part_offset - parts[i].offset;\n\t}\n\n\t*pparts = parts;\n\treturn i;\n};\n\nstatic const struct of_device_id mtd_parser_trx_of_match_table[] = {\n\t{ .compatible = \"brcm,trx\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, mtd_parser_trx_of_match_table);\n\nstatic struct mtd_part_parser mtd_parser_trx = {\n\t.parse_fn = parser_trx_parse,\n\t.name = \"trx\",\n\t.of_match_table = mtd_parser_trx_of_match_table,\n};\nmodule_mtd_part_parser(mtd_parser_trx);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"Parser for TRX format partitions\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}