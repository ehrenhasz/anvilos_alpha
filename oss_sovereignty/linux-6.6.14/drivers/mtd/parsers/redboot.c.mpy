{
  "module_name": "redboot.c",
  "hash_id": "891e33d1cf2bd8b381471036dd6ef86de14a9c9e638f638f6fd810c509f6b8fa",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/parsers/redboot.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/vmalloc.h>\n#include <linux/of.h>\n#include <linux/mtd/mtd.h>\n#include <linux/mtd/partitions.h>\n#include <linux/module.h>\n\nstruct fis_image_desc {\n\tunsigned char name[16];      \n\tu32\t  flash_base;    \n\tu32\t  mem_base;      \n\tu32\t  size;          \n\tu32\t  entry_point;   \n\tu32\t  data_length;   \n\tunsigned char _pad[256 - (16 + 7 * sizeof(u32))];\n\tu32\t  desc_cksum;    \n\tu32\t  file_cksum;    \n};\n\nstruct fis_list {\n\tstruct fis_image_desc *img;\n\tstruct fis_list *next;\n};\n\nstatic int directory = CONFIG_MTD_REDBOOT_DIRECTORY_BLOCK;\nmodule_param(directory, int, 0);\n\nstatic inline int redboot_checksum(struct fis_image_desc *img)\n{\n\t \n\treturn 1;\n}\n\nstatic void parse_redboot_of(struct mtd_info *master)\n{\n\tstruct device_node *np;\n\tstruct device_node *npart;\n\tu32 dirblock;\n\tint ret;\n\n\tnp = mtd_get_of_node(master);\n\tif (!np)\n\t\treturn;\n\n\tnpart = of_get_child_by_name(np, \"partitions\");\n\tif (!npart)\n\t\treturn;\n\n\tret = of_property_read_u32(npart, \"fis-index-block\", &dirblock);\n\tof_node_put(npart);\n\tif (ret)\n\t\treturn;\n\n\t \n\tdirectory = dirblock;\n}\n\nstatic int parse_redboot_partitions(struct mtd_info *master,\n\t\t\t\t    const struct mtd_partition **pparts,\n\t\t\t\t    struct mtd_part_parser_data *data)\n{\n\tint nrparts = 0;\n\tstruct fis_image_desc *buf;\n\tstruct mtd_partition *parts;\n\tstruct fis_list *fl = NULL, *tmp_fl;\n\tint ret, i;\n\tsize_t retlen;\n\tchar *names;\n\tchar *nullname;\n\tint namelen = 0;\n\tint nulllen = 0;\n\tint numslots;\n\tunsigned long offset;\n#ifdef CONFIG_MTD_REDBOOT_PARTS_UNALLOCATED\n\tstatic char nullstring[] = \"unallocated\";\n#endif\n\n\tparse_redboot_of(master);\n\n\tif (directory < 0) {\n\t\toffset = master->size + directory * master->erasesize;\n\t\twhile (mtd_block_isbad(master, offset)) {\n\t\t\tif (!offset) {\nnogood:\n\t\t\t\tpr_notice(\"Failed to find a non-bad block to check for RedBoot partition table\\n\");\n\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t\toffset -= master->erasesize;\n\t\t}\n\t} else {\n\t\toffset = directory * master->erasesize;\n\t\twhile (mtd_block_isbad(master, offset)) {\n\t\t\toffset += master->erasesize;\n\t\t\tif (offset == master->size)\n\t\t\t\tgoto nogood;\n\t\t}\n\t}\n\tbuf = vmalloc(master->erasesize);\n\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tpr_notice(\"Searching for RedBoot partition table in %s at offset 0x%lx\\n\",\n\t\t  master->name, offset);\n\n\tret = mtd_read(master, offset, master->erasesize, &retlen,\n\t\t       (void *)buf);\n\n\tif (ret)\n\t\tgoto out;\n\n\tif (retlen != master->erasesize) {\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n\tnumslots = (master->erasesize / sizeof(struct fis_image_desc));\n\tfor (i = 0; i < numslots; i++) {\n\t\tif (!memcmp(buf[i].name, \"FIS directory\", 14)) {\n\t\t\t \n\n\t\t\t \n\t\t\tif (swab32(buf[i].size) == master->erasesize ||\n\t\t\t    (buf[i].size > master->erasesize\n\t\t\t     && swab32(buf[i].size) < master->erasesize)) {\n\t\t\t\tint j;\n\t\t\t\t \n\t\t\t\tnumslots = swab32(buf[i].size) / sizeof(struct fis_image_desc);\n\t\t\t\tfor (j = 0; j < numslots; ++j) {\n\t\t\t\t\t \n\t\t\t\t\tif (buf[j].name[0] == 0xff) {\n\t\t\t\t\t\tif (buf[j].name[1] == 0xff) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t \n\t\t\t\t\tswab32s(&buf[j].flash_base);\n\t\t\t\t\tswab32s(&buf[j].mem_base);\n\t\t\t\t\tswab32s(&buf[j].size);\n\t\t\t\t\tswab32s(&buf[j].entry_point);\n\t\t\t\t\tswab32s(&buf[j].data_length);\n\t\t\t\t\tswab32s(&buf[j].desc_cksum);\n\t\t\t\t\tswab32s(&buf[j].file_cksum);\n\t\t\t\t}\n\t\t\t} else if (buf[i].size < master->erasesize) {\n\t\t\t\t \n\t\t\t\tnumslots = buf[i].size / sizeof(struct fis_image_desc);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (i == numslots) {\n\t\t \n\t\tpr_notice(\"No RedBoot partition table detected in %s\\n\",\n\t\t\t  master->name);\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < numslots; i++) {\n\t\tstruct fis_list *new_fl, **prev;\n\n\t\tif (buf[i].name[0] == 0xff) {\n\t\t\tif (buf[i].name[1] == 0xff) {\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (!redboot_checksum(&buf[i]))\n\t\t\tbreak;\n\n\t\tnew_fl = kmalloc(sizeof(struct fis_list), GFP_KERNEL);\n\t\tnamelen += strlen(buf[i].name) + 1;\n\t\tif (!new_fl) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tnew_fl->img = &buf[i];\n\t\tif (data && data->origin)\n\t\t\tbuf[i].flash_base -= data->origin;\n\t\telse\n\t\t\tbuf[i].flash_base &= master->size - 1;\n\n\t\t \n\t\tprev = &fl;\n\t\twhile (*prev && (*prev)->img->flash_base < new_fl->img->flash_base)\n\t\t\tprev = &(*prev)->next;\n\t\tnew_fl->next = *prev;\n\t\t*prev = new_fl;\n\n\t\tnrparts++;\n\t}\n#ifdef CONFIG_MTD_REDBOOT_PARTS_UNALLOCATED\n\tif (fl->img->flash_base) {\n\t\tnrparts++;\n\t\tnulllen = sizeof(nullstring);\n\t}\n\n\tfor (tmp_fl = fl; tmp_fl->next; tmp_fl = tmp_fl->next) {\n\t\tif (tmp_fl->img->flash_base + tmp_fl->img->size + master->erasesize <= tmp_fl->next->img->flash_base) {\n\t\t\tnrparts++;\n\t\t\tnulllen = sizeof(nullstring);\n\t\t}\n\t}\n#endif\n\tparts = kzalloc(sizeof(*parts) * nrparts + nulllen + namelen, GFP_KERNEL);\n\n\tif (!parts) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tnullname = (char *)&parts[nrparts];\n#ifdef CONFIG_MTD_REDBOOT_PARTS_UNALLOCATED\n\tif (nulllen > 0)\n\t\tstrcpy(nullname, nullstring);\n#endif\n\tnames = nullname + nulllen;\n\n\ti = 0;\n\n#ifdef CONFIG_MTD_REDBOOT_PARTS_UNALLOCATED\n\tif (fl->img->flash_base) {\n\t\tparts[0].name = nullname;\n\t\tparts[0].size = fl->img->flash_base;\n\t\tparts[0].offset = 0;\n\t\ti++;\n\t}\n#endif\n\tfor ( ; i < nrparts; i++) {\n\t\tparts[i].size = fl->img->size;\n\t\tparts[i].offset = fl->img->flash_base;\n\t\tparts[i].name = names;\n\n\t\tstrcpy(names, fl->img->name);\n#ifdef CONFIG_MTD_REDBOOT_PARTS_READONLY\n\t\tif (!memcmp(names, \"RedBoot\", 8) ||\n\t\t    !memcmp(names, \"RedBoot config\", 15) ||\n\t\t    !memcmp(names, \"FIS directory\", 14)) {\n\t\t\tparts[i].mask_flags = MTD_WRITEABLE;\n\t\t}\n#endif\n\t\tnames += strlen(names) + 1;\n\n#ifdef CONFIG_MTD_REDBOOT_PARTS_UNALLOCATED\n\t\tif (fl->next && fl->img->flash_base + fl->img->size + master->erasesize <= fl->next->img->flash_base) {\n\t\t\ti++;\n\t\t\tparts[i].offset = parts[i - 1].size + parts[i - 1].offset;\n\t\t\tparts[i].size = fl->next->img->flash_base - parts[i].offset;\n\t\t\tparts[i].name = nullname;\n\t\t}\n#endif\n\t\ttmp_fl = fl;\n\t\tfl = fl->next;\n\t\tkfree(tmp_fl);\n\t}\n\tret = nrparts;\n\t*pparts = parts;\n out:\n\twhile (fl) {\n\t\tstruct fis_list *old = fl;\n\n\t\tfl = fl->next;\n\t\tkfree(old);\n\t}\n\tvfree(buf);\n\treturn ret;\n}\n\nstatic const struct of_device_id mtd_parser_redboot_of_match_table[] = {\n\t{ .compatible = \"redboot-fis\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, mtd_parser_redboot_of_match_table);\n\nstatic struct mtd_part_parser redboot_parser = {\n\t.parse_fn = parse_redboot_partitions,\n\t.name = \"RedBoot\",\n\t.of_match_table = mtd_parser_redboot_of_match_table,\n};\nmodule_mtd_part_parser(redboot_parser);\n\n \nMODULE_ALIAS(\"RedBoot\");\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"David Woodhouse <dwmw2@infradead.org>\");\nMODULE_DESCRIPTION(\"Parsing code for RedBoot Flash Image System (FIS) tables\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}