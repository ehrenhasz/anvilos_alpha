{
  "module_name": "ofpart_core.c",
  "hash_id": "37f2dafb1cf819ceb4ad22fa727dfa782396da76cba9fcb2ac331f2cad2efef1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/parsers/ofpart_core.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/of.h>\n#include <linux/mtd/mtd.h>\n#include <linux/slab.h>\n#include <linux/mtd/partitions.h>\n\n#include \"ofpart_bcm4908.h\"\n#include \"ofpart_linksys_ns.h\"\n\nstruct fixed_partitions_quirks {\n\tint (*post_parse)(struct mtd_info *mtd, struct mtd_partition *parts, int nr_parts);\n};\n\nstatic struct fixed_partitions_quirks bcm4908_partitions_quirks = {\n\t.post_parse = bcm4908_partitions_post_parse,\n};\n\nstatic struct fixed_partitions_quirks linksys_ns_partitions_quirks = {\n\t.post_parse = linksys_ns_partitions_post_parse,\n};\n\nstatic const struct of_device_id parse_ofpart_match_table[];\n\nstatic bool node_has_compatible(struct device_node *pp)\n{\n\treturn of_get_property(pp, \"compatible\", NULL);\n}\n\nstatic int parse_fixed_partitions(struct mtd_info *master,\n\t\t\t\t  const struct mtd_partition **pparts,\n\t\t\t\t  struct mtd_part_parser_data *data)\n{\n\tconst struct fixed_partitions_quirks *quirks;\n\tconst struct of_device_id *of_id;\n\tstruct mtd_partition *parts;\n\tstruct device_node *mtd_node;\n\tstruct device_node *ofpart_node;\n\tconst char *partname;\n\tstruct device_node *pp;\n\tint nr_parts, i, ret = 0;\n\tbool dedicated = true;\n\n\t \n\tmtd_node = mtd_get_of_node(master);\n\tif (!mtd_node)\n\t\treturn 0;\n\n\tif (!master->parent) {  \n\t\tofpart_node = of_get_child_by_name(mtd_node, \"partitions\");\n\t\tif (!ofpart_node) {\n\t\t\t \n\t\t\tpr_debug(\"%s: 'partitions' subnode not found on %pOF. Trying to parse direct subnodes as partitions.\\n\",\n\t\t\t\tmaster->name, mtd_node);\n\t\t\tofpart_node = mtd_node;\n\t\t\tdedicated = false;\n\t\t}\n\t} else {  \n\t\tofpart_node = mtd_node;\n\t}\n\n\tof_id = of_match_node(parse_ofpart_match_table, ofpart_node);\n\tif (dedicated && !of_id) {\n\t\t \n\t\treturn 0;\n\t}\n\n\tquirks = of_id ? of_id->data : NULL;\n\n\t \n\tnr_parts = 0;\n\tfor_each_child_of_node(ofpart_node,  pp) {\n\t\tif (!dedicated && node_has_compatible(pp))\n\t\t\tcontinue;\n\n\t\tnr_parts++;\n\t}\n\n\tif (nr_parts == 0)\n\t\treturn 0;\n\n\tparts = kcalloc(nr_parts, sizeof(*parts), GFP_KERNEL);\n\tif (!parts)\n\t\treturn -ENOMEM;\n\n\ti = 0;\n\tfor_each_child_of_node(ofpart_node,  pp) {\n\t\tconst __be32 *reg;\n\t\tint len;\n\t\tint a_cells, s_cells;\n\n\t\tif (!dedicated && node_has_compatible(pp))\n\t\t\tcontinue;\n\n\t\treg = of_get_property(pp, \"reg\", &len);\n\t\tif (!reg) {\n\t\t\tif (dedicated) {\n\t\t\t\tpr_debug(\"%s: ofpart partition %pOF (%pOF) missing reg property.\\n\",\n\t\t\t\t\t master->name, pp,\n\t\t\t\t\t mtd_node);\n\t\t\t\tgoto ofpart_fail;\n\t\t\t} else {\n\t\t\t\tnr_parts--;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\ta_cells = of_n_addr_cells(pp);\n\t\ts_cells = of_n_size_cells(pp);\n\t\tif (!dedicated && s_cells == 0) {\n\t\t\t \n\t\t\tpr_warn(\"%s: ofpart partition %pOF (%pOF) #size-cells is wrongly set to <0>, assuming <1> for parsing partitions.\\n\",\n\t\t\t\tmaster->name, pp, mtd_node);\n\t\t\ts_cells = 1;\n\t\t}\n\t\tif (len / 4 != a_cells + s_cells) {\n\t\t\tpr_debug(\"%s: ofpart partition %pOF (%pOF) error parsing reg property.\\n\",\n\t\t\t\t master->name, pp,\n\t\t\t\t mtd_node);\n\t\t\tgoto ofpart_fail;\n\t\t}\n\n\t\tparts[i].offset = of_read_number(reg, a_cells);\n\t\tparts[i].size = of_read_number(reg + a_cells, s_cells);\n\t\tparts[i].of_node = pp;\n\n\t\tpartname = of_get_property(pp, \"label\", &len);\n\t\tif (!partname)\n\t\t\tpartname = of_get_property(pp, \"name\", &len);\n\t\tparts[i].name = partname;\n\n\t\tif (of_get_property(pp, \"read-only\", &len))\n\t\t\tparts[i].mask_flags |= MTD_WRITEABLE;\n\n\t\tif (of_get_property(pp, \"lock\", &len))\n\t\t\tparts[i].mask_flags |= MTD_POWERUP_LOCK;\n\n\t\tif (of_property_read_bool(pp, \"slc-mode\"))\n\t\t\tparts[i].add_flags |= MTD_SLC_ON_MLC_EMULATION;\n\n\t\ti++;\n\t}\n\n\tif (!nr_parts)\n\t\tgoto ofpart_none;\n\n\tif (quirks && quirks->post_parse)\n\t\tquirks->post_parse(master, parts, nr_parts);\n\n\t*pparts = parts;\n\treturn nr_parts;\n\nofpart_fail:\n\tpr_err(\"%s: error parsing ofpart partition %pOF (%pOF)\\n\",\n\t       master->name, pp, mtd_node);\n\tret = -EINVAL;\nofpart_none:\n\tof_node_put(pp);\n\tkfree(parts);\n\treturn ret;\n}\n\nstatic const struct of_device_id parse_ofpart_match_table[] = {\n\t \n\t{ .compatible = \"fixed-partitions\" },\n\t \n\t{ .compatible = \"brcm,bcm4908-partitions\", .data = &bcm4908_partitions_quirks, },\n\t{ .compatible = \"linksys,ns-partitions\", .data = &linksys_ns_partitions_quirks, },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, parse_ofpart_match_table);\n\nstatic struct mtd_part_parser ofpart_parser = {\n\t.parse_fn = parse_fixed_partitions,\n\t.name = \"fixed-partitions\",\n\t.of_match_table = parse_ofpart_match_table,\n};\n\nstatic int parse_ofoldpart_partitions(struct mtd_info *master,\n\t\t\t\t      const struct mtd_partition **pparts,\n\t\t\t\t      struct mtd_part_parser_data *data)\n{\n\tstruct mtd_partition *parts;\n\tstruct device_node *dp;\n\tint i, plen, nr_parts;\n\tconst struct {\n\t\t__be32 offset, len;\n\t} *part;\n\tconst char *names;\n\n\t \n\tdp = mtd_get_of_node(master);\n\tif (!dp)\n\t\treturn 0;\n\n\tpart = of_get_property(dp, \"partitions\", &plen);\n\tif (!part)\n\t\treturn 0;  \n\n\tpr_warn(\"Device tree uses obsolete partition map binding: %pOF\\n\", dp);\n\n\tnr_parts = plen / sizeof(part[0]);\n\n\tparts = kcalloc(nr_parts, sizeof(*parts), GFP_KERNEL);\n\tif (!parts)\n\t\treturn -ENOMEM;\n\n\tnames = of_get_property(dp, \"partition-names\", &plen);\n\n\tfor (i = 0; i < nr_parts; i++) {\n\t\tparts[i].offset = be32_to_cpu(part->offset);\n\t\tparts[i].size   = be32_to_cpu(part->len) & ~1;\n\t\t \n\t\tif (be32_to_cpu(part->len) & 1)\n\t\t\tparts[i].mask_flags = MTD_WRITEABLE;\n\n\t\tif (names && (plen > 0)) {\n\t\t\tint len = strlen(names) + 1;\n\n\t\t\tparts[i].name = names;\n\t\t\tplen -= len;\n\t\t\tnames += len;\n\t\t} else {\n\t\t\tparts[i].name = \"unnamed\";\n\t\t}\n\n\t\tpart++;\n\t}\n\n\t*pparts = parts;\n\treturn nr_parts;\n}\n\nstatic struct mtd_part_parser ofoldpart_parser = {\n\t.parse_fn = parse_ofoldpart_partitions,\n\t.name = \"ofoldpart\",\n};\n\nstatic int __init ofpart_parser_init(void)\n{\n\tregister_mtd_parser(&ofpart_parser);\n\tregister_mtd_parser(&ofoldpart_parser);\n\treturn 0;\n}\n\nstatic void __exit ofpart_parser_exit(void)\n{\n\tderegister_mtd_parser(&ofpart_parser);\n\tderegister_mtd_parser(&ofoldpart_parser);\n}\n\nmodule_init(ofpart_parser_init);\nmodule_exit(ofpart_parser_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"Parser for MTD partitioning information in device tree\");\nMODULE_AUTHOR(\"Vitaly Wool, David Gibson\");\n \nMODULE_ALIAS(\"fixed-partitions\");\nMODULE_ALIAS(\"ofoldpart\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}