{
  "module_name": "bcm47xxpart.c",
  "hash_id": "42f4b1f8ecc94b6f14e2d93c8046698f576e2c53b8397e46a53be01ad40e7c54",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/parsers/bcm47xxpart.c",
  "human_readable_source": "\n \n\n#include <linux/bcm47xx_nvram.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/mtd/mtd.h>\n#include <linux/mtd/partitions.h>\n\n#include <uapi/linux/magic.h>\n\n \n#define BCM47XXPART_MAX_PARTS\t\t20\n\n \n#define BCM47XXPART_BYTES_TO_READ\t0x4e8\n\n \n#define BOARD_DATA_MAGIC\t\t0x5246504D\t \n#define BOARD_DATA_MAGIC2\t\t0xBD0D0BBD\n#define CFE_MAGIC\t\t\t0x43464531\t \n#define FACTORY_MAGIC\t\t\t0x59544346\t \n#define NVRAM_HEADER\t\t\t0x48534C46\t \n#define POT_MAGIC1\t\t\t0x54544f50\t \n#define POT_MAGIC2\t\t\t0x504f\t\t \n#define ML_MAGIC1\t\t\t0x39685a42\n#define ML_MAGIC2\t\t\t0x26594131\n#define TRX_MAGIC\t\t\t0x30524448\n#define SHSQ_MAGIC\t\t\t0x71736873\t \n\nstatic const char * const trx_types[] = { \"trx\", NULL };\n\nstruct trx_header {\n\tuint32_t magic;\n\tuint32_t length;\n\tuint32_t crc32;\n\tuint16_t flags;\n\tuint16_t version;\n\tuint32_t offset[3];\n} __packed;\n\nstatic void bcm47xxpart_add_part(struct mtd_partition *part, const char *name,\n\t\t\t\t u64 offset, uint32_t mask_flags)\n{\n\tpart->name = name;\n\tpart->offset = offset;\n\tpart->mask_flags = mask_flags;\n}\n\n \nstatic int bcm47xxpart_bootpartition(void)\n{\n\tchar buf[4];\n\tint bootpartition;\n\n\t \n\tif (bcm47xx_nvram_getenv(\"bootpartition\", buf, sizeof(buf)) > 0) {\n\t\tif (!kstrtoint(buf, 0, &bootpartition))\n\t\t\treturn bootpartition;\n\t}\n\n\treturn 0;\n}\n\nstatic int bcm47xxpart_parse(struct mtd_info *master,\n\t\t\t     const struct mtd_partition **pparts,\n\t\t\t     struct mtd_part_parser_data *data)\n{\n\tstruct mtd_partition *parts;\n\tuint8_t i, curr_part = 0;\n\tuint32_t *buf;\n\tsize_t bytes_read;\n\tuint32_t offset;\n\tuint32_t blocksize = master->erasesize;\n\tint trx_parts[2];  \n\tint trx_num = 0;  \n\tint possible_nvram_sizes[] = { 0x8000, 0xF000, 0x10000, };\n\tint err;\n\n\t \n\tif (blocksize < 0x1000)\n\t\tblocksize = 0x1000;\n\n\t \n\tparts = kcalloc(BCM47XXPART_MAX_PARTS, sizeof(struct mtd_partition),\n\t\t\tGFP_KERNEL);\n\tif (!parts)\n\t\treturn -ENOMEM;\n\n\tbuf = kzalloc(BCM47XXPART_BYTES_TO_READ, GFP_KERNEL);\n\tif (!buf) {\n\t\tkfree(parts);\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tfor (offset = 0; offset <= master->size - blocksize;\n\t     offset += blocksize) {\n\t\t \n\t\tif (IS_ENABLED(CONFIG_BCM47XX) && offset >= 0x2000000)\n\t\t\tbreak;\n\n\t\tif (curr_part >= BCM47XXPART_MAX_PARTS) {\n\t\t\tpr_warn(\"Reached maximum number of partitions, scanning stopped!\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\terr = mtd_read(master, offset, BCM47XXPART_BYTES_TO_READ,\n\t\t\t       &bytes_read, (uint8_t *)buf);\n\t\tif (err && !mtd_is_bitflip(err)) {\n\t\t\tpr_err(\"mtd_read error while parsing (offset: 0x%X): %d\\n\",\n\t\t\t       offset, err);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif ((buf[0x4e0 / 4] == CFE_MAGIC && buf[0x4e4 / 4] == CFE_MAGIC) ||\n\t\t    (buf[0x400 / 4] == NVRAM_HEADER)) {\n\t\t\tbcm47xxpart_add_part(&parts[curr_part++], \"boot\",\n\t\t\t\t\t     offset, MTD_WRITEABLE);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (buf[0x100 / 4] == BOARD_DATA_MAGIC) {\n\t\t\tbcm47xxpart_add_part(&parts[curr_part++], \"board_data\",\n\t\t\t\t\t     offset, MTD_WRITEABLE);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (buf[0x000 / 4] == FACTORY_MAGIC) {\n\t\t\tbcm47xxpart_add_part(&parts[curr_part++], \"factory\",\n\t\t\t\t\t     offset, MTD_WRITEABLE);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (buf[0x000 / 4] == POT_MAGIC1 &&\n\t\t    (buf[0x004 / 4] & 0xFFFF) == POT_MAGIC2) {\n\t\t\tbcm47xxpart_add_part(&parts[curr_part++], \"POT\", offset,\n\t\t\t\t\t     MTD_WRITEABLE);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (buf[0x010 / 4] == ML_MAGIC1 &&\n\t\t    buf[0x014 / 4] == ML_MAGIC2) {\n\t\t\tbcm47xxpart_add_part(&parts[curr_part++], \"ML\", offset,\n\t\t\t\t\t     MTD_WRITEABLE);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (buf[0x000 / 4] == TRX_MAGIC) {\n\t\t\tstruct trx_header *trx;\n\t\t\tuint32_t last_subpart;\n\t\t\tuint32_t trx_size;\n\n\t\t\tif (trx_num >= ARRAY_SIZE(trx_parts))\n\t\t\t\tpr_warn(\"No enough space to store another TRX found at 0x%X\\n\",\n\t\t\t\t\toffset);\n\t\t\telse\n\t\t\t\ttrx_parts[trx_num++] = curr_part;\n\t\t\tbcm47xxpart_add_part(&parts[curr_part++], \"firmware\",\n\t\t\t\t\t     offset, 0);\n\n\t\t\t \n\t\t\ttrx = (struct trx_header *)buf;\n\t\t\tlast_subpart = max3(trx->offset[0], trx->offset[1],\n\t\t\t\t\t    trx->offset[2]);\n\t\t\ttrx_size = max(trx->length, last_subpart + blocksize);\n\n\t\t\t \n\t\t\toffset += roundup(trx_size, blocksize) - blocksize;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (le32_to_cpu(buf[0x000 / 4]) == SQUASHFS_MAGIC ||\n\t\t    buf[0x000 / 4] == SHSQ_MAGIC) {\n\t\t\tbcm47xxpart_add_part(&parts[curr_part++], \"rootfs\",\n\t\t\t\t\t     offset, 0);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (offset != master->size - blocksize &&\n\t\t    buf[0x000 / 4] == NVRAM_HEADER) {\n\t\t\tbcm47xxpart_add_part(&parts[curr_part++], \"nvram\",\n\t\t\t\t\t     offset, 0);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\terr = mtd_read(master, offset + (blocksize / 2), 0x4, &bytes_read,\n\t\t\t       (uint8_t *)buf);\n\t\tif (err && !mtd_is_bitflip(err)) {\n\t\t\tpr_err(\"mtd_read error while parsing (offset: 0x%X): %d\\n\",\n\t\t\t       offset + (blocksize / 2), err);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (buf[0x000 / 4] == BOARD_DATA_MAGIC2) {\n\t\t\tbcm47xxpart_add_part(&parts[curr_part++], \"board_data\",\n\t\t\t\t\t     offset, MTD_WRITEABLE);\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(possible_nvram_sizes); i++) {\n\t\tif (curr_part >= BCM47XXPART_MAX_PARTS) {\n\t\t\tpr_warn(\"Reached maximum number of partitions, scanning stopped!\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\toffset = master->size - possible_nvram_sizes[i];\n\t\terr = mtd_read(master, offset, 0x4, &bytes_read,\n\t\t\t       (uint8_t *)buf);\n\t\tif (err && !mtd_is_bitflip(err)) {\n\t\t\tpr_err(\"mtd_read error while reading (offset 0x%X): %d\\n\",\n\t\t\t       offset, err);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (buf[0] == NVRAM_HEADER) {\n\t\t\tbcm47xxpart_add_part(&parts[curr_part++], \"nvram\",\n\t\t\t\t\t     master->size - blocksize, 0);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tkfree(buf);\n\n\t \n\tfor (i = 0; i < curr_part; i++) {\n\t\tu64 next_part_offset = (i < curr_part - 1) ?\n\t\t\t\t       parts[i + 1].offset : master->size;\n\n\t\tparts[i].size = next_part_offset - parts[i].offset;\n\t}\n\n\t \n\tfor (i = 0; i < trx_num; i++) {\n\t\tstruct mtd_partition *trx = &parts[trx_parts[i]];\n\n\t\tif (i == bcm47xxpart_bootpartition())\n\t\t\ttrx->types = trx_types;\n\t\telse\n\t\t\ttrx->name = \"failsafe\";\n\t}\n\n\t*pparts = parts;\n\treturn curr_part;\n};\n\nstatic const struct of_device_id bcm47xxpart_of_match_table[] = {\n\t{ .compatible = \"brcm,bcm947xx-cfe-partitions\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, bcm47xxpart_of_match_table);\n\nstatic struct mtd_part_parser bcm47xxpart_mtd_parser = {\n\t.parse_fn = bcm47xxpart_parse,\n\t.name = \"bcm47xxpart\",\n\t.of_match_table = bcm47xxpart_of_match_table,\n};\nmodule_mtd_part_parser(bcm47xxpart_mtd_parser);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"MTD partitioning for BCM47XX flash memories\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}