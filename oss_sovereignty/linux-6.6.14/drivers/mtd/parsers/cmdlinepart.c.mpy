{
  "module_name": "cmdlinepart.c",
  "hash_id": "4e13dd6445c48484d33661e608add1938e562f21d584996cfe26001e8ff9fb50",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/parsers/cmdlinepart.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt)\t\"mtd: \" fmt\n\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/mtd/mtd.h>\n#include <linux/mtd/partitions.h>\n#include <linux/module.h>\n#include <linux/err.h>\n\n \n#if 0\n#define dbg(x) do { printk(\"DEBUG-CMDLINE-PART: \"); printk x; } while(0)\n#else\n#define dbg(x)\n#endif\n\n\n \n#define SIZE_REMAINING ULLONG_MAX\n#define OFFSET_CONTINUOUS ULLONG_MAX\n\nstruct cmdline_mtd_partition {\n\tstruct cmdline_mtd_partition *next;\n\tchar *mtd_id;\n\tint num_parts;\n\tstruct mtd_partition *parts;\n};\n\n \nstatic struct cmdline_mtd_partition *partitions;\n\n \nstatic char *mtdparts;\nstatic char *cmdline;\nstatic int cmdline_parsed;\n\n \nstatic struct mtd_partition * newpart(char *s,\n\t\t\t\t      char **retptr,\n\t\t\t\t      int *num_parts,\n\t\t\t\t      int this_part,\n\t\t\t\t      unsigned char **extra_mem_ptr,\n\t\t\t\t      int extra_mem_size)\n{\n\tstruct mtd_partition *parts;\n\tunsigned long long size, offset = OFFSET_CONTINUOUS;\n\tchar *name;\n\tint name_len;\n\tunsigned char *extra_mem;\n\tchar delim;\n\tunsigned int mask_flags, add_flags;\n\n\t \n\tif (*s == '-') {\n\t\t \n\t\tsize = SIZE_REMAINING;\n\t\ts++;\n\t} else {\n\t\tsize = memparse(s, &s);\n\t\tif (!size) {\n\t\t\tpr_err(\"partition has size 0\\n\");\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\t}\n\t}\n\n\t \n\tmask_flags = 0;  \n\tadd_flags = 0;\n\tdelim = 0;\n\n\t \n\tif (*s == '@') {\n\t\ts++;\n\t\toffset = memparse(s, &s);\n\t}\n\n\t \n\tif (*s == '(')\n\t\tdelim = ')';\n\n\tif (delim) {\n\t\tchar *p;\n\n\t\tname = ++s;\n\t\tp = strchr(name, delim);\n\t\tif (!p) {\n\t\t\tpr_err(\"no closing %c found in partition name\\n\", delim);\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\t}\n\t\tname_len = p - name;\n\t\ts = p + 1;\n\t} else {\n\t\tname = NULL;\n\t\tname_len = 13;  \n\t}\n\n\t \n\textra_mem_size += name_len + 1;\n\n\t \n\tif (strncmp(s, \"ro\", 2) == 0) {\n\t\tmask_flags |= MTD_WRITEABLE;\n\t\ts += 2;\n\t}\n\n\t \n\tif (strncmp(s, \"lk\", 2) == 0) {\n\t\tmask_flags |= MTD_POWERUP_LOCK;\n\t\ts += 2;\n\t}\n\n\t \n\tif (!strncmp(s, \"slc\", 3)) {\n\t\tadd_flags |= MTD_SLC_ON_MLC_EMULATION;\n\t\ts += 3;\n\t}\n\n\t \n\tif (*s == ',') {\n\t\tif (size == SIZE_REMAINING) {\n\t\t\tpr_err(\"no partitions allowed after a fill-up partition\\n\");\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\t}\n\t\t \n\t\tparts = newpart(s + 1, &s, num_parts, this_part + 1,\n\t\t\t\t&extra_mem, extra_mem_size);\n\t\tif (IS_ERR(parts))\n\t\t\treturn parts;\n\t} else {\n\t\t \n\t\tint alloc_size;\n\n\t\t*num_parts = this_part + 1;\n\t\talloc_size = *num_parts * sizeof(struct mtd_partition) +\n\t\t\t     extra_mem_size;\n\n\t\tparts = kzalloc(alloc_size, GFP_KERNEL);\n\t\tif (!parts)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\textra_mem = (unsigned char *)(parts + *num_parts);\n\t}\n\n\t \n\tparts[this_part].size = size;\n\tparts[this_part].offset = offset;\n\tparts[this_part].mask_flags = mask_flags;\n\tparts[this_part].add_flags = add_flags;\n\tif (name)\n\t\tstrscpy(extra_mem, name, name_len + 1);\n\telse\n\t\tsprintf(extra_mem, \"Partition_%03d\", this_part);\n\tparts[this_part].name = extra_mem;\n\textra_mem += name_len + 1;\n\n\tdbg((\"partition %d: name <%s>, offset %llx, size %llx, mask flags %x\\n\",\n\t     this_part, parts[this_part].name, parts[this_part].offset,\n\t     parts[this_part].size, parts[this_part].mask_flags));\n\n\t \n\tif (extra_mem_ptr)\n\t\t*extra_mem_ptr = extra_mem;\n\n\t \n\t*retptr = s;\n\n\t \n\treturn parts;\n}\n\n \nstatic int mtdpart_setup_real(char *s)\n{\n\tcmdline_parsed = 1;\n\n\tfor( ; s != NULL; )\n\t{\n\t\tstruct cmdline_mtd_partition *this_mtd;\n\t\tstruct mtd_partition *parts;\n\t\tint mtd_id_len, num_parts;\n\t\tchar *p, *mtd_id, *semicol, *open_parenth;\n\n\t\t \n\t\tsemicol = strchr(s, ';');\n\t\tif (semicol)\n\t\t\t*semicol = '\\0';\n\n\t\t \n\t\topen_parenth = strchr(s, '(');\n\t\tif (open_parenth)\n\t\t\t*open_parenth = '\\0';\n\n\t\tmtd_id = s;\n\n\t\t \n\t\tp = strrchr(s, ':');\n\n\t\t \n\t\tif (open_parenth)\n\t\t\t*open_parenth = '(';\n\n\t\t \n\t\tif (semicol)\n\t\t\t*semicol = ';';\n\n\t\tif (!p) {\n\t\t\tpr_err(\"no mtd-id\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmtd_id_len = p - mtd_id;\n\n\t\tdbg((\"parsing <%s>\\n\", p+1));\n\n\t\t \n\t\tparts = newpart(p + 1,\t\t \n\t\t\t\t&s,\t\t \n\t\t\t\t&num_parts,\t \n\t\t\t\t0,\t\t \n\t\t\t\t(unsigned char**)&this_mtd,  \n\t\t\t\tmtd_id_len + 1 + sizeof(*this_mtd) +\n\t\t\t\tsizeof(void*)-1  );\n\t\tif (IS_ERR(parts)) {\n\t\t\t \n\t\t\t return PTR_ERR(parts);\n\t\t }\n\n\t\t \n\t\tthis_mtd = (struct cmdline_mtd_partition *)\n\t\t\t\tALIGN((unsigned long)this_mtd, sizeof(void *));\n\t\t \n\t\tthis_mtd->parts = parts;\n\t\tthis_mtd->num_parts = num_parts;\n\t\tthis_mtd->mtd_id = (char*)(this_mtd + 1);\n\t\tstrscpy(this_mtd->mtd_id, mtd_id, mtd_id_len + 1);\n\n\t\t \n\t\tthis_mtd->next = partitions;\n\t\tpartitions = this_mtd;\n\n\t\tdbg((\"mtdid=<%s> num_parts=<%d>\\n\",\n\t\t     this_mtd->mtd_id, this_mtd->num_parts));\n\n\n\t\t \n\t\tif (*s == 0)\n\t\t\tbreak;\n\n\t\t \n\t\tif (*s != ';') {\n\t\t\tpr_err(\"bad character after partition (%c)\\n\", *s);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\ts++;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int parse_cmdline_partitions(struct mtd_info *master,\n\t\t\t\t    const struct mtd_partition **pparts,\n\t\t\t\t    struct mtd_part_parser_data *data)\n{\n\tunsigned long long offset;\n\tint i, err;\n\tstruct cmdline_mtd_partition *part;\n\tconst char *mtd_id = master->name;\n\n\t \n\tif (!cmdline_parsed) {\n\t\terr = mtdpart_setup_real(cmdline);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\t \n\tfor (part = partitions; part; part = part->next) {\n\t\tif ((!mtd_id) || (!strcmp(part->mtd_id, mtd_id)))\n\t\t\tbreak;\n\t}\n\n\tif (!part)\n\t\treturn 0;\n\n\tfor (i = 0, offset = 0; i < part->num_parts; i++) {\n\t\tif (part->parts[i].offset == OFFSET_CONTINUOUS)\n\t\t\tpart->parts[i].offset = offset;\n\t\telse\n\t\t\toffset = part->parts[i].offset;\n\n\t\tif (part->parts[i].size == SIZE_REMAINING)\n\t\t\tpart->parts[i].size = master->size - offset;\n\n\t\tif (offset + part->parts[i].size > master->size) {\n\t\t\tpr_warn(\"%s: partitioning exceeds flash size, truncating\\n\",\n\t\t\t\tpart->mtd_id);\n\t\t\tpart->parts[i].size = master->size - offset;\n\t\t}\n\t\toffset += part->parts[i].size;\n\n\t\tif (part->parts[i].size == 0) {\n\t\t\tpr_warn(\"%s: skipping zero sized partition\\n\",\n\t\t\t\tpart->mtd_id);\n\t\t\tpart->num_parts--;\n\t\t\tmemmove(&part->parts[i], &part->parts[i + 1],\n\t\t\t\tsizeof(*part->parts) * (part->num_parts - i));\n\t\t\ti--;\n\t\t}\n\t}\n\n\t*pparts = kmemdup(part->parts, sizeof(*part->parts) * part->num_parts,\n\t\t\t  GFP_KERNEL);\n\tif (!*pparts)\n\t\treturn -ENOMEM;\n\n\treturn part->num_parts;\n}\n\n\n \nstatic int __init mtdpart_setup(char *s)\n{\n\tcmdline = s;\n\treturn 1;\n}\n\n__setup(\"mtdparts=\", mtdpart_setup);\n\nstatic struct mtd_part_parser cmdline_parser = {\n\t.parse_fn = parse_cmdline_partitions,\n\t.name = \"cmdlinepart\",\n};\n\nstatic int __init cmdline_parser_init(void)\n{\n\tif (mtdparts)\n\t\tmtdpart_setup(mtdparts);\n\tregister_mtd_parser(&cmdline_parser);\n\treturn 0;\n}\n\nstatic void __exit cmdline_parser_exit(void)\n{\n\tderegister_mtd_parser(&cmdline_parser);\n}\n\nmodule_init(cmdline_parser_init);\nmodule_exit(cmdline_parser_exit);\n\nMODULE_PARM_DESC(mtdparts, \"Partitioning specification\");\nmodule_param(mtdparts, charp, 0);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Marius Groeger <mag@sysgo.de>\");\nMODULE_DESCRIPTION(\"Command line configuration of MTD partitions\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}