{
  "module_name": "sm_ftl.c",
  "hash_id": "6ba254f28a050f9fb7cace0fb0ad44595ae2e3d7e594b74e694644be6245929a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mtd/sm_ftl.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/random.h>\n#include <linux/hdreg.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/sysfs.h>\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/mtd/nand-ecc-sw-hamming.h>\n#include \"nand/raw/sm_common.h\"\n#include \"sm_ftl.h\"\n\n\n\nstatic struct workqueue_struct *cache_flush_workqueue;\n\nstatic int cache_timeout = 1000;\nmodule_param(cache_timeout, int, S_IRUGO);\nMODULE_PARM_DESC(cache_timeout,\n\t\"Timeout (in ms) for cache flush (1000 ms default\");\n\nstatic int debug;\nmodule_param(debug, int, S_IRUGO | S_IWUSR);\nMODULE_PARM_DESC(debug, \"Debug level (0-2)\");\n\n\n \nstruct sm_sysfs_attribute {\n\tstruct device_attribute dev_attr;\n\tchar *data;\n\tint len;\n};\n\nstatic ssize_t sm_attr_show(struct device *dev, struct device_attribute *attr,\n\t\t     char *buf)\n{\n\tstruct sm_sysfs_attribute *sm_attr =\n\t\tcontainer_of(attr, struct sm_sysfs_attribute, dev_attr);\n\n\tstrncpy(buf, sm_attr->data, sm_attr->len);\n\treturn sm_attr->len;\n}\n\n\n#define NUM_ATTRIBUTES 1\n#define SM_CIS_VENDOR_OFFSET 0x59\nstatic struct attribute_group *sm_create_sysfs_attributes(struct sm_ftl *ftl)\n{\n\tstruct attribute_group *attr_group;\n\tstruct attribute **attributes;\n\tstruct sm_sysfs_attribute *vendor_attribute;\n\tchar *vendor;\n\n\tvendor = kstrndup(ftl->cis_buffer + SM_CIS_VENDOR_OFFSET,\n\t\t\t  SM_SMALL_PAGE - SM_CIS_VENDOR_OFFSET, GFP_KERNEL);\n\tif (!vendor)\n\t\tgoto error1;\n\n\t \n\tvendor_attribute =\n\t\tkzalloc(sizeof(struct sm_sysfs_attribute), GFP_KERNEL);\n\tif (!vendor_attribute)\n\t\tgoto error2;\n\n\tsysfs_attr_init(&vendor_attribute->dev_attr.attr);\n\n\tvendor_attribute->data = vendor;\n\tvendor_attribute->len = strlen(vendor);\n\tvendor_attribute->dev_attr.attr.name = \"vendor\";\n\tvendor_attribute->dev_attr.attr.mode = S_IRUGO;\n\tvendor_attribute->dev_attr.show = sm_attr_show;\n\n\n\t \n\tattributes = kcalloc(NUM_ATTRIBUTES + 1, sizeof(struct attribute *),\n\t\t\t\t\t\t\t\tGFP_KERNEL);\n\tif (!attributes)\n\t\tgoto error3;\n\tattributes[0] = &vendor_attribute->dev_attr.attr;\n\n\t \n\tattr_group = kzalloc(sizeof(struct attribute_group), GFP_KERNEL);\n\tif (!attr_group)\n\t\tgoto error4;\n\tattr_group->attrs = attributes;\n\treturn attr_group;\nerror4:\n\tkfree(attributes);\nerror3:\n\tkfree(vendor_attribute);\nerror2:\n\tkfree(vendor);\nerror1:\n\treturn NULL;\n}\n\nstatic void sm_delete_sysfs_attributes(struct sm_ftl *ftl)\n{\n\tstruct attribute **attributes = ftl->disk_attributes->attrs;\n\tint i;\n\n\tfor (i = 0; attributes[i] ; i++) {\n\n\t\tstruct device_attribute *dev_attr = container_of(attributes[i],\n\t\t\tstruct device_attribute, attr);\n\n\t\tstruct sm_sysfs_attribute *sm_attr =\n\t\t\tcontainer_of(dev_attr,\n\t\t\t\tstruct sm_sysfs_attribute, dev_attr);\n\n\t\tkfree(sm_attr->data);\n\t\tkfree(sm_attr);\n\t}\n\n\tkfree(ftl->disk_attributes->attrs);\n\tkfree(ftl->disk_attributes);\n}\n\n\n \n\nstatic int sm_get_lba(uint8_t *lba)\n{\n\t \n\tif ((lba[0] & 0xF8) != 0x10)\n\t\treturn -2;\n\n\t \n\tif (hweight16(*(uint16_t *)lba) & 1)\n\t\treturn -2;\n\n\treturn (lba[1] >> 1) | ((lba[0] & 0x07) << 7);\n}\n\n\n \nstatic int sm_read_lba(struct sm_oob *oob)\n{\n\tstatic const uint32_t erased_pattern[4] = {\n\t\t0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF };\n\n\tuint16_t lba_test;\n\tint lba;\n\n\t \n\tif (!memcmp(oob, erased_pattern, SM_OOB_SIZE))\n\t\treturn -1;\n\n\t \n\tlba_test = *(uint16_t *)oob->lba_copy1 ^ *(uint16_t*)oob->lba_copy2;\n\tif (lba_test && !is_power_of_2(lba_test))\n\t\treturn -2;\n\n\t \n\tlba = sm_get_lba(oob->lba_copy1);\n\n\tif (lba == -2)\n\t\tlba = sm_get_lba(oob->lba_copy2);\n\n\treturn lba;\n}\n\nstatic void sm_write_lba(struct sm_oob *oob, uint16_t lba)\n{\n\tuint8_t tmp[2];\n\n\tWARN_ON(lba >= 1000);\n\n\ttmp[0] = 0x10 | ((lba >> 7) & 0x07);\n\ttmp[1] = (lba << 1) & 0xFF;\n\n\tif (hweight16(*(uint16_t *)tmp) & 0x01)\n\t\ttmp[1] |= 1;\n\n\toob->lba_copy1[0] = oob->lba_copy2[0] = tmp[0];\n\toob->lba_copy1[1] = oob->lba_copy2[1] = tmp[1];\n}\n\n\n \nstatic loff_t sm_mkoffset(struct sm_ftl *ftl, int zone, int block, int boffset)\n{\n\tWARN_ON(boffset & (SM_SECTOR_SIZE - 1));\n\tWARN_ON(zone < 0 || zone >= ftl->zone_count);\n\tWARN_ON(block >= ftl->zone_size);\n\tWARN_ON(boffset >= ftl->block_size);\n\n\tif (block == -1)\n\t\treturn -1;\n\n\treturn (zone * SM_MAX_ZONE_SIZE + block) * ftl->block_size + boffset;\n}\n\n \nstatic void sm_break_offset(struct sm_ftl *ftl, loff_t loffset,\n\t\t\t    int *zone, int *block, int *boffset)\n{\n\tu64 offset = loffset;\n\t*boffset = do_div(offset, ftl->block_size);\n\t*block = do_div(offset, ftl->max_lba);\n\t*zone = offset >= ftl->zone_count ? -1 : offset;\n}\n\n \n\nstatic int sm_correct_sector(uint8_t *buffer, struct sm_oob *oob)\n{\n\tbool sm_order = IS_ENABLED(CONFIG_MTD_NAND_ECC_SW_HAMMING_SMC);\n\tuint8_t ecc[3];\n\n\tecc_sw_hamming_calculate(buffer, SM_SMALL_PAGE, ecc, sm_order);\n\tif (ecc_sw_hamming_correct(buffer, ecc, oob->ecc1, SM_SMALL_PAGE,\n\t\t\t\t   sm_order) < 0)\n\t\treturn -EIO;\n\n\tbuffer += SM_SMALL_PAGE;\n\n\tecc_sw_hamming_calculate(buffer, SM_SMALL_PAGE, ecc, sm_order);\n\tif (ecc_sw_hamming_correct(buffer, ecc, oob->ecc2, SM_SMALL_PAGE,\n\t\t\t\t   sm_order) < 0)\n\t\treturn -EIO;\n\treturn 0;\n}\n\n \nstatic int sm_read_sector(struct sm_ftl *ftl,\n\t\t\t  int zone, int block, int boffset,\n\t\t\t  uint8_t *buffer, struct sm_oob *oob)\n{\n\tstruct mtd_info *mtd = ftl->trans->mtd;\n\tstruct mtd_oob_ops ops = { };\n\tstruct sm_oob tmp_oob;\n\tint ret = -EIO;\n\tint try = 0;\n\n\t \n\tif (block == -1) {\n\t\tif (buffer)\n\t\t\tmemset(buffer, 0xFF, SM_SECTOR_SIZE);\n\t\treturn 0;\n\t}\n\n\t \n\tif (!oob)\n\t\toob = &tmp_oob;\n\n\tops.mode = ftl->smallpagenand ? MTD_OPS_RAW : MTD_OPS_PLACE_OOB;\n\tops.ooboffs = 0;\n\tops.ooblen = SM_OOB_SIZE;\n\tops.oobbuf = (void *)oob;\n\tops.len = SM_SECTOR_SIZE;\n\tops.datbuf = buffer;\n\nagain:\n\tif (try++) {\n\t\t \n\t\tif (zone == 0 && block == ftl->cis_block && boffset ==\n\t\t\tftl->cis_boffset)\n\t\t\treturn ret;\n\n\t\t \n\t\tif (try == 3 || sm_recheck_media(ftl))\n\t\t\treturn ret;\n\t}\n\n\t \n\tret = mtd_read_oob(mtd, sm_mkoffset(ftl, zone, block, boffset), &ops);\n\n\t \n\tif (ret != 0 && !mtd_is_bitflip_or_eccerr(ret)) {\n\t\tdbg(\"read of block %d at zone %d, failed due to error (%d)\",\n\t\t\tblock, zone, ret);\n\t\tgoto again;\n\t}\n\n\t \n\tif (oob->reserved != 0xFFFFFFFF && !is_power_of_2(~oob->reserved))\n\t\tgoto again;\n\n\t \n\tWARN_ON(ops.oobretlen != SM_OOB_SIZE);\n\tWARN_ON(buffer && ops.retlen != SM_SECTOR_SIZE);\n\n\tif (!buffer)\n\t\treturn 0;\n\n\t \n\tif (!sm_sector_valid(oob)) {\n\t\tdbg(\"read of block %d at zone %d, failed because it is marked\"\n\t\t\t\" as bad\" , block, zone);\n\t\tgoto again;\n\t}\n\n\t \n\tif (mtd_is_eccerr(ret) ||\n\t\t(ftl->smallpagenand && sm_correct_sector(buffer, oob))) {\n\n\t\tdbg(\"read of block %d at zone %d, failed due to ECC error\",\n\t\t\tblock, zone);\n\t\tgoto again;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int sm_write_sector(struct sm_ftl *ftl,\n\t\t\t   int zone, int block, int boffset,\n\t\t\t   uint8_t *buffer, struct sm_oob *oob)\n{\n\tstruct mtd_oob_ops ops = { };\n\tstruct mtd_info *mtd = ftl->trans->mtd;\n\tint ret;\n\n\tBUG_ON(ftl->readonly);\n\n\tif (zone == 0 && (block == ftl->cis_block || block == 0)) {\n\t\tdbg(\"attempted to write the CIS!\");\n\t\treturn -EIO;\n\t}\n\n\tif (ftl->unstable)\n\t\treturn -EIO;\n\n\tops.mode = ftl->smallpagenand ? MTD_OPS_RAW : MTD_OPS_PLACE_OOB;\n\tops.len = SM_SECTOR_SIZE;\n\tops.datbuf = buffer;\n\tops.ooboffs = 0;\n\tops.ooblen = SM_OOB_SIZE;\n\tops.oobbuf = (void *)oob;\n\n\tret = mtd_write_oob(mtd, sm_mkoffset(ftl, zone, block, boffset), &ops);\n\n\t \n\n\tif (ret) {\n\t\tdbg(\"write to block %d at zone %d, failed with error %d\",\n\t\t\tblock, zone, ret);\n\n\t\tsm_recheck_media(ftl);\n\t\treturn ret;\n\t}\n\n\t \n\tWARN_ON(ops.oobretlen != SM_OOB_SIZE);\n\tWARN_ON(buffer && ops.retlen != SM_SECTOR_SIZE);\n\n\treturn 0;\n}\n\n \n\n \nstatic int sm_write_block(struct sm_ftl *ftl, uint8_t *buf,\n\t\t\t  int zone, int block, int lba,\n\t\t\t  unsigned long invalid_bitmap)\n{\n\tbool sm_order = IS_ENABLED(CONFIG_MTD_NAND_ECC_SW_HAMMING_SMC);\n\tstruct sm_oob oob;\n\tint boffset;\n\tint retry = 0;\n\n\t \n\tmemset(&oob, 0xFF, SM_OOB_SIZE);\n\tsm_write_lba(&oob, lba);\nrestart:\n\tif (ftl->unstable)\n\t\treturn -EIO;\n\n\tfor (boffset = 0; boffset < ftl->block_size;\n\t\t\t\tboffset += SM_SECTOR_SIZE) {\n\n\t\toob.data_status = 0xFF;\n\n\t\tif (test_bit(boffset / SM_SECTOR_SIZE, &invalid_bitmap)) {\n\n\t\t\tsm_printk(\"sector %d of block at LBA %d of zone %d\"\n\t\t\t\t\" couldn't be read, marking it as invalid\",\n\t\t\t\tboffset / SM_SECTOR_SIZE, lba, zone);\n\n\t\t\toob.data_status = 0;\n\t\t}\n\n\t\tif (ftl->smallpagenand) {\n\t\t\tecc_sw_hamming_calculate(buf + boffset,\n\t\t\t\t\t\t SM_SMALL_PAGE, oob.ecc1,\n\t\t\t\t\t\t sm_order);\n\n\t\t\tecc_sw_hamming_calculate(buf + boffset + SM_SMALL_PAGE,\n\t\t\t\t\t\t SM_SMALL_PAGE, oob.ecc2,\n\t\t\t\t\t\t sm_order);\n\t\t}\n\t\tif (!sm_write_sector(ftl, zone, block, boffset,\n\t\t\t\t\t\t\tbuf + boffset, &oob))\n\t\t\tcontinue;\n\n\t\tif (!retry) {\n\n\t\t\t \n\t\t\t \n\n\t\t\tif (sm_erase_block(ftl, zone, block, 0))\n\t\t\t\treturn -EIO;\n\n\t\t\tretry = 1;\n\t\t\tgoto restart;\n\t\t} else {\n\t\t\tsm_mark_block_bad(ftl, zone, block);\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\treturn 0;\n}\n\n\n \nstatic void sm_mark_block_bad(struct sm_ftl *ftl, int zone, int block)\n{\n\tstruct sm_oob oob;\n\tint boffset;\n\n\tmemset(&oob, 0xFF, SM_OOB_SIZE);\n\toob.block_status = 0xF0;\n\n\tif (ftl->unstable)\n\t\treturn;\n\n\tif (sm_recheck_media(ftl))\n\t\treturn;\n\n\tsm_printk(\"marking block %d of zone %d as bad\", block, zone);\n\n\t \n\t \n\tfor (boffset = 0; boffset < ftl->block_size; boffset += SM_SECTOR_SIZE)\n\t\tsm_write_sector(ftl, zone, block, boffset, NULL, &oob);\n}\n\n \nstatic int sm_erase_block(struct sm_ftl *ftl, int zone_num, uint16_t block,\n\t\t\t  int put_free)\n{\n\tstruct ftl_zone *zone = &ftl->zones[zone_num];\n\tstruct mtd_info *mtd = ftl->trans->mtd;\n\tstruct erase_info erase;\n\n\terase.addr = sm_mkoffset(ftl, zone_num, block, 0);\n\terase.len = ftl->block_size;\n\n\tif (ftl->unstable)\n\t\treturn -EIO;\n\n\tBUG_ON(ftl->readonly);\n\n\tif (zone_num == 0 && (block == ftl->cis_block || block == 0)) {\n\t\tsm_printk(\"attempted to erase the CIS!\");\n\t\treturn -EIO;\n\t}\n\n\tif (mtd_erase(mtd, &erase)) {\n\t\tsm_printk(\"erase of block %d in zone %d failed\",\n\t\t\t\t\t\t\tblock, zone_num);\n\t\tgoto error;\n\t}\n\n\tif (put_free)\n\t\tkfifo_in(&zone->free_sectors,\n\t\t\t(const unsigned char *)&block, sizeof(block));\n\n\treturn 0;\nerror:\n\tsm_mark_block_bad(ftl, zone_num, block);\n\treturn -EIO;\n}\n\n \nstatic int sm_check_block(struct sm_ftl *ftl, int zone, int block)\n{\n\tint boffset;\n\tstruct sm_oob oob;\n\tint lbas[] = { -3, 0, 0, 0 };\n\tint i = 0;\n\tint test_lba;\n\n\n\t \n\t \n\tfor (boffset = 0; boffset < ftl->block_size;\n\t\t\t\t\tboffset += SM_SECTOR_SIZE) {\n\n\t\t \n\t\tif (sm_read_sector(ftl, zone, block, boffset, NULL, &oob))\n\t\t\treturn -2;\n\n\t\ttest_lba = sm_read_lba(&oob);\n\n\t\tif (lbas[i] != test_lba)\n\t\t\tlbas[++i] = test_lba;\n\n\t\t \n\t\tif (i == 3)\n\t\t\treturn -EIO;\n\t}\n\n\t \n\tif (i == 2) {\n\t\tsm_erase_block(ftl, zone, block, 1);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\n \nstatic const struct chs_entry chs_table[] = {\n\t{ 1,    125,  4,  4  },\n\t{ 2,    125,  4,  8  },\n\t{ 4,    250,  4,  8  },\n\t{ 8,    250,  4,  16 },\n\t{ 16,   500,  4,  16 },\n\t{ 32,   500,  8,  16 },\n\t{ 64,   500,  8,  32 },\n\t{ 128,  500,  16, 32 },\n\t{ 256,  1000, 16, 32 },\n\t{ 512,  1015, 32, 63 },\n\t{ 1024, 985,  33, 63 },\n\t{ 2048, 985,  33, 63 },\n\t{ 0 },\n};\n\n\nstatic const uint8_t cis_signature[] = {\n\t0x01, 0x03, 0xD9, 0x01, 0xFF, 0x18, 0x02, 0xDF, 0x01, 0x20\n};\n \nstatic int sm_get_media_info(struct sm_ftl *ftl, struct mtd_info *mtd)\n{\n\tint i;\n\tint size_in_megs = mtd->size / (1024 * 1024);\n\n\tftl->readonly = mtd->type == MTD_ROM;\n\n\t \n\tftl->zone_count = 1;\n\tftl->smallpagenand = 0;\n\n\tswitch (size_in_megs) {\n\tcase 1:\n\t\t \n\t\tftl->zone_size = 256;\n\t\tftl->max_lba = 250;\n\t\tftl->block_size = 8 * SM_SECTOR_SIZE;\n\t\tftl->smallpagenand = 1;\n\n\t\tbreak;\n\tcase 2:\n\t\t \n\t\tif (mtd->writesize == SM_SMALL_PAGE) {\n\t\t\tftl->zone_size = 512;\n\t\t\tftl->max_lba = 500;\n\t\t\tftl->block_size = 8 * SM_SECTOR_SIZE;\n\t\t\tftl->smallpagenand = 1;\n\t\t \n\t\t} else {\n\n\t\t\tif (!ftl->readonly)\n\t\t\t\treturn -ENODEV;\n\n\t\t\tftl->zone_size = 256;\n\t\t\tftl->max_lba = 250;\n\t\t\tftl->block_size = 16 * SM_SECTOR_SIZE;\n\t\t}\n\t\tbreak;\n\tcase 4:\n\t\t \n\t\tftl->zone_size = 512;\n\t\tftl->max_lba = 500;\n\t\tftl->block_size = 16 * SM_SECTOR_SIZE;\n\t\tbreak;\n\tcase 8:\n\t\t \n\t\tftl->zone_size = 1024;\n\t\tftl->max_lba = 1000;\n\t\tftl->block_size = 16 * SM_SECTOR_SIZE;\n\t}\n\n\t \n\tif (size_in_megs >= 16) {\n\t\tftl->zone_count = size_in_megs / 16;\n\t\tftl->zone_size = 1024;\n\t\tftl->max_lba = 1000;\n\t\tftl->block_size = 32 * SM_SECTOR_SIZE;\n\t}\n\n\t \n\tif (mtd->erasesize > ftl->block_size)\n\t\treturn -ENODEV;\n\n\tif (mtd->writesize > SM_SECTOR_SIZE)\n\t\treturn -ENODEV;\n\n\tif (ftl->smallpagenand && mtd->oobsize < SM_SMALL_OOB_SIZE)\n\t\treturn -ENODEV;\n\n\tif (!ftl->smallpagenand && mtd->oobsize < SM_OOB_SIZE)\n\t\treturn -ENODEV;\n\n\t \n\tif (!mtd_has_oob(mtd))\n\t\treturn -ENODEV;\n\n\t \n\tfor (i = 0 ; i < ARRAY_SIZE(chs_table) ; i++) {\n\t\tif (chs_table[i].size == size_in_megs) {\n\t\t\tftl->cylinders = chs_table[i].cyl;\n\t\t\tftl->heads = chs_table[i].head;\n\t\t\tftl->sectors = chs_table[i].sec;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tsm_printk(\"media has unknown size : %dMiB\", size_in_megs);\n\tftl->cylinders = 985;\n\tftl->heads =  33;\n\tftl->sectors = 63;\n\treturn 0;\n}\n\n \nstatic int sm_read_cis(struct sm_ftl *ftl)\n{\n\tstruct sm_oob oob;\n\n\tif (sm_read_sector(ftl,\n\t\t0, ftl->cis_block, ftl->cis_boffset, ftl->cis_buffer, &oob))\n\t\t\treturn -EIO;\n\n\tif (!sm_sector_valid(&oob) || !sm_block_valid(&oob))\n\t\treturn -EIO;\n\n\tif (!memcmp(ftl->cis_buffer + ftl->cis_page_offset,\n\t\t\tcis_signature, sizeof(cis_signature))) {\n\t\treturn 0;\n\t}\n\n\treturn -EIO;\n}\n\n \nstatic int sm_find_cis(struct sm_ftl *ftl)\n{\n\tstruct sm_oob oob;\n\tint block, boffset;\n\tint block_found = 0;\n\tint cis_found = 0;\n\n\t \n\tfor (block = 0 ; block < ftl->zone_size - ftl->max_lba ; block++) {\n\n\t\tif (sm_read_sector(ftl, 0, block, 0, NULL, &oob))\n\t\t\tcontinue;\n\n\t\tif (!sm_block_valid(&oob))\n\t\t\tcontinue;\n\t\tblock_found = 1;\n\t\tbreak;\n\t}\n\n\tif (!block_found)\n\t\treturn -EIO;\n\n\t \n\tfor (boffset = 0 ; boffset < ftl->block_size;\n\t\t\t\t\t\tboffset += SM_SECTOR_SIZE) {\n\n\t\tif (sm_read_sector(ftl, 0, block, boffset, NULL, &oob))\n\t\t\tcontinue;\n\n\t\tif (!sm_sector_valid(&oob))\n\t\t\tcontinue;\n\t\tbreak;\n\t}\n\n\tif (boffset == ftl->block_size)\n\t\treturn -EIO;\n\n\tftl->cis_block = block;\n\tftl->cis_boffset = boffset;\n\tftl->cis_page_offset = 0;\n\n\tcis_found = !sm_read_cis(ftl);\n\n\tif (!cis_found) {\n\t\tftl->cis_page_offset = SM_SMALL_PAGE;\n\t\tcis_found = !sm_read_cis(ftl);\n\t}\n\n\tif (cis_found) {\n\t\tdbg(\"CIS block found at offset %x\",\n\t\t\tblock * ftl->block_size +\n\t\t\t\tboffset + ftl->cis_page_offset);\n\t\treturn 0;\n\t}\n\treturn -EIO;\n}\n\n \nstatic int sm_recheck_media(struct sm_ftl *ftl)\n{\n\tif (sm_read_cis(ftl)) {\n\n\t\tif (!ftl->unstable) {\n\t\t\tsm_printk(\"media unstable, not allowing writes\");\n\t\t\tftl->unstable = 1;\n\t\t}\n\t\treturn -EIO;\n\t}\n\treturn 0;\n}\n\n \nstatic int sm_init_zone(struct sm_ftl *ftl, int zone_num)\n{\n\tstruct ftl_zone *zone = &ftl->zones[zone_num];\n\tstruct sm_oob oob;\n\tuint16_t block;\n\tint lba;\n\tint i = 0;\n\tint len;\n\n\tdbg(\"initializing zone %d\", zone_num);\n\n\t \n\tzone->lba_to_phys_table = kmalloc_array(ftl->max_lba, 2, GFP_KERNEL);\n\n\tif (!zone->lba_to_phys_table)\n\t\treturn -ENOMEM;\n\tmemset(zone->lba_to_phys_table, -1, ftl->max_lba * 2);\n\n\n\t \n\tif (kfifo_alloc(&zone->free_sectors, ftl->zone_size * 2, GFP_KERNEL)) {\n\t\tkfree(zone->lba_to_phys_table);\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tfor (block = 0 ; block < ftl->zone_size ; block++) {\n\n\t\t \n\t\tif (zone_num == 0 && block <= ftl->cis_block)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (sm_read_sector(ftl, zone_num, block, 0, NULL, &oob)) {\n\t\t\tkfifo_free(&zone->free_sectors);\n\t\t\tkfree(zone->lba_to_phys_table);\n\t\t\treturn -EIO;\n\t\t}\n\n\t\t \n\t\tif (sm_block_erased(&oob)) {\n\t\t\tkfifo_in(&zone->free_sectors,\n\t\t\t\t(unsigned char *)&block, 2);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\t \n\t\t \n\t\tif (!sm_block_valid(&oob)) {\n\t\t\tdbg(\"PH %04d <-> <marked bad>\", block);\n\t\t\tcontinue;\n\t\t}\n\n\n\t\tlba = sm_read_lba(&oob);\n\n\t\t \n\t\t \n\t\tif (lba == -2 || lba >= ftl->max_lba) {\n\t\t\tdbg(\"PH %04d <-> LBA %04d(bad)\", block, lba);\n\t\t\tcontinue;\n\t\t}\n\n\n\t\t \n\t\tif (zone->lba_to_phys_table[lba] < 0) {\n\t\t\tdbg_verbose(\"PH %04d <-> LBA %04d\", block, lba);\n\t\t\tzone->lba_to_phys_table[lba] = block;\n\t\t\tcontinue;\n\t\t}\n\n\t\tsm_printk(\"collision\"\n\t\t\t\" of LBA %d between blocks %d and %d in zone %d\",\n\t\t\tlba, zone->lba_to_phys_table[lba], block, zone_num);\n\n\t\t \n\t\tif (sm_check_block(ftl, zone_num, block))\n\t\t\tcontinue;\n\n\t\t \n\t\tif (sm_check_block(ftl, zone_num,\n\t\t\t\t\tzone->lba_to_phys_table[lba])) {\n\t\t\tzone->lba_to_phys_table[lba] = block;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tsm_printk(\"both blocks are valid, erasing the later\");\n\t\tsm_erase_block(ftl, zone_num, block, 1);\n\t}\n\n\tdbg(\"zone initialized\");\n\tzone->initialized = 1;\n\n\t \n\tif (!kfifo_len(&zone->free_sectors)) {\n\t\tsm_printk(\"no free blocks in zone %d\", zone_num);\n\t\treturn 0;\n\t}\n\n\t \n\tget_random_bytes(&i, 2);\n\ti %= (kfifo_len(&zone->free_sectors) / 2);\n\n\twhile (i--) {\n\t\tlen = kfifo_out(&zone->free_sectors,\n\t\t\t\t\t(unsigned char *)&block, 2);\n\t\tWARN_ON(len != 2);\n\t\tkfifo_in(&zone->free_sectors, (const unsigned char *)&block, 2);\n\t}\n\treturn 0;\n}\n\n \nstatic struct ftl_zone *sm_get_zone(struct sm_ftl *ftl, int zone_num)\n{\n\tstruct ftl_zone *zone;\n\tint error;\n\n\tBUG_ON(zone_num >= ftl->zone_count);\n\tzone = &ftl->zones[zone_num];\n\n\tif (!zone->initialized) {\n\t\terror = sm_init_zone(ftl, zone_num);\n\n\t\tif (error)\n\t\t\treturn ERR_PTR(error);\n\t}\n\treturn zone;\n}\n\n\n \n\n \nstatic void sm_cache_init(struct sm_ftl *ftl)\n{\n\tftl->cache_data_invalid_bitmap = 0xFFFFFFFF;\n\tftl->cache_clean = 1;\n\tftl->cache_zone = -1;\n\tftl->cache_block = -1;\n\t \n}\n\n \nstatic void sm_cache_put(struct sm_ftl *ftl, char *buffer, int boffset)\n{\n\tmemcpy(ftl->cache_data + boffset, buffer, SM_SECTOR_SIZE);\n\tclear_bit(boffset / SM_SECTOR_SIZE, &ftl->cache_data_invalid_bitmap);\n\tftl->cache_clean = 0;\n}\n\n \nstatic int sm_cache_get(struct sm_ftl *ftl, char *buffer, int boffset)\n{\n\tif (test_bit(boffset / SM_SECTOR_SIZE,\n\t\t&ftl->cache_data_invalid_bitmap))\n\t\t\treturn -1;\n\n\tmemcpy(buffer, ftl->cache_data + boffset, SM_SECTOR_SIZE);\n\treturn 0;\n}\n\n \nstatic int sm_cache_flush(struct sm_ftl *ftl)\n{\n\tstruct ftl_zone *zone;\n\n\tint sector_num;\n\tuint16_t write_sector;\n\tint zone_num = ftl->cache_zone;\n\tint block_num;\n\n\tif (ftl->cache_clean)\n\t\treturn 0;\n\n\tif (ftl->unstable)\n\t\treturn -EIO;\n\n\tBUG_ON(zone_num < 0);\n\tzone = &ftl->zones[zone_num];\n\tblock_num = zone->lba_to_phys_table[ftl->cache_block];\n\n\n\t \n\tfor_each_set_bit(sector_num, &ftl->cache_data_invalid_bitmap,\n\t\tftl->block_size / SM_SECTOR_SIZE) {\n\n\t\tif (!sm_read_sector(ftl,\n\t\t\tzone_num, block_num, sector_num * SM_SECTOR_SIZE,\n\t\t\tftl->cache_data + sector_num * SM_SECTOR_SIZE, NULL))\n\t\t\t\tclear_bit(sector_num,\n\t\t\t\t\t&ftl->cache_data_invalid_bitmap);\n\t}\nrestart:\n\n\tif (ftl->unstable)\n\t\treturn -EIO;\n\n\t \n\t \n\tif (kfifo_out(&zone->free_sectors,\n\t\t\t\t(unsigned char *)&write_sector, 2) != 2) {\n\t\tdbg(\"no free sectors for write!\");\n\t\treturn -EIO;\n\t}\n\n\n\tif (sm_write_block(ftl, ftl->cache_data, zone_num, write_sector,\n\t\tftl->cache_block, ftl->cache_data_invalid_bitmap))\n\t\t\tgoto restart;\n\n\t \n\tzone->lba_to_phys_table[ftl->cache_block] = write_sector;\n\n\t \n\tif (block_num > 0)\n\t\tsm_erase_block(ftl, zone_num, block_num, 1);\n\n\tsm_cache_init(ftl);\n\treturn 0;\n}\n\n\n \nstatic void sm_cache_flush_timer(struct timer_list *t)\n{\n\tstruct sm_ftl *ftl = from_timer(ftl, t, timer);\n\tqueue_work(cache_flush_workqueue, &ftl->flush_work);\n}\n\n \nstatic void sm_cache_flush_work(struct work_struct *work)\n{\n\tstruct sm_ftl *ftl = container_of(work, struct sm_ftl, flush_work);\n\tmutex_lock(&ftl->mutex);\n\tsm_cache_flush(ftl);\n\tmutex_unlock(&ftl->mutex);\n\treturn;\n}\n\n \n\n \nstatic int sm_read(struct mtd_blktrans_dev *dev,\n\t\t   unsigned long sect_no, char *buf)\n{\n\tstruct sm_ftl *ftl = dev->priv;\n\tstruct ftl_zone *zone;\n\tint error = 0, in_cache = 0;\n\tint zone_num, block, boffset;\n\n\tsm_break_offset(ftl, sect_no << 9, &zone_num, &block, &boffset);\n\tmutex_lock(&ftl->mutex);\n\n\n\tzone = sm_get_zone(ftl, zone_num);\n\tif (IS_ERR(zone)) {\n\t\terror = PTR_ERR(zone);\n\t\tgoto unlock;\n\t}\n\n\t \n\tif (ftl->cache_zone == zone_num && ftl->cache_block == block) {\n\t\tin_cache = 1;\n\t\tif (!sm_cache_get(ftl, buf, boffset))\n\t\t\tgoto unlock;\n\t}\n\n\t \n\tblock = zone->lba_to_phys_table[block];\n\n\tif (block == -1) {\n\t\tmemset(buf, 0xFF, SM_SECTOR_SIZE);\n\t\tgoto unlock;\n\t}\n\n\tif (sm_read_sector(ftl, zone_num, block, boffset, buf, NULL)) {\n\t\terror = -EIO;\n\t\tgoto unlock;\n\t}\n\n\tif (in_cache)\n\t\tsm_cache_put(ftl, buf, boffset);\nunlock:\n\tmutex_unlock(&ftl->mutex);\n\treturn error;\n}\n\n \nstatic int sm_write(struct mtd_blktrans_dev *dev,\n\t\t\t\tunsigned long sec_no, char *buf)\n{\n\tstruct sm_ftl *ftl = dev->priv;\n\tstruct ftl_zone *zone;\n\tint error = 0, zone_num, block, boffset;\n\n\tBUG_ON(ftl->readonly);\n\tsm_break_offset(ftl, sec_no << 9, &zone_num, &block, &boffset);\n\n\t \n\tdel_timer(&ftl->timer);\n\tmutex_lock(&ftl->mutex);\n\n\tzone = sm_get_zone(ftl, zone_num);\n\tif (IS_ERR(zone)) {\n\t\terror = PTR_ERR(zone);\n\t\tgoto unlock;\n\t}\n\n\t \n\tif (ftl->cache_block != block || ftl->cache_zone != zone_num) {\n\n\t\terror = sm_cache_flush(ftl);\n\t\tif (error)\n\t\t\tgoto unlock;\n\n\t\tftl->cache_block = block;\n\t\tftl->cache_zone = zone_num;\n\t}\n\n\tsm_cache_put(ftl, buf, boffset);\nunlock:\n\tmod_timer(&ftl->timer, jiffies + msecs_to_jiffies(cache_timeout));\n\tmutex_unlock(&ftl->mutex);\n\treturn error;\n}\n\n \nstatic int sm_flush(struct mtd_blktrans_dev *dev)\n{\n\tstruct sm_ftl *ftl = dev->priv;\n\tint retval;\n\n\tmutex_lock(&ftl->mutex);\n\tretval =  sm_cache_flush(ftl);\n\tmutex_unlock(&ftl->mutex);\n\treturn retval;\n}\n\n \nstatic void sm_release(struct mtd_blktrans_dev *dev)\n{\n\tstruct sm_ftl *ftl = dev->priv;\n\n\tdel_timer_sync(&ftl->timer);\n\tcancel_work_sync(&ftl->flush_work);\n\tmutex_lock(&ftl->mutex);\n\tsm_cache_flush(ftl);\n\tmutex_unlock(&ftl->mutex);\n}\n\n \nstatic int sm_getgeo(struct mtd_blktrans_dev *dev, struct hd_geometry *geo)\n{\n\tstruct sm_ftl *ftl = dev->priv;\n\tgeo->heads = ftl->heads;\n\tgeo->sectors = ftl->sectors;\n\tgeo->cylinders = ftl->cylinders;\n\treturn 0;\n}\n\n \nstatic void sm_add_mtd(struct mtd_blktrans_ops *tr, struct mtd_info *mtd)\n{\n\tstruct mtd_blktrans_dev *trans;\n\tstruct sm_ftl *ftl;\n\n\t \n\tftl = kzalloc(sizeof(struct sm_ftl), GFP_KERNEL);\n\tif (!ftl)\n\t\tgoto error1;\n\n\n\tmutex_init(&ftl->mutex);\n\ttimer_setup(&ftl->timer, sm_cache_flush_timer, 0);\n\tINIT_WORK(&ftl->flush_work, sm_cache_flush_work);\n\n\t \n\tif (sm_get_media_info(ftl, mtd)) {\n\t\tdbg(\"found unsupported mtd device, aborting\");\n\t\tgoto error2;\n\t}\n\n\n\t \n\tftl->cis_buffer = kzalloc(SM_SECTOR_SIZE, GFP_KERNEL);\n\tif (!ftl->cis_buffer)\n\t\tgoto error2;\n\n\t \n\tftl->zones = kcalloc(ftl->zone_count, sizeof(struct ftl_zone),\n\t\t\t\t\t\t\t\tGFP_KERNEL);\n\tif (!ftl->zones)\n\t\tgoto error3;\n\n\t \n\tftl->cache_data = kzalloc(ftl->block_size, GFP_KERNEL);\n\n\tif (!ftl->cache_data)\n\t\tgoto error4;\n\n\tsm_cache_init(ftl);\n\n\n\t \n\ttrans = kzalloc(sizeof(struct mtd_blktrans_dev), GFP_KERNEL);\n\tif (!trans)\n\t\tgoto error5;\n\n\tftl->trans = trans;\n\ttrans->priv = ftl;\n\n\ttrans->tr = tr;\n\ttrans->mtd = mtd;\n\ttrans->devnum = -1;\n\ttrans->size = (ftl->block_size * ftl->max_lba * ftl->zone_count) >> 9;\n\ttrans->readonly = ftl->readonly;\n\n\tif (sm_find_cis(ftl)) {\n\t\tdbg(\"CIS not found on mtd device, aborting\");\n\t\tgoto error6;\n\t}\n\n\tftl->disk_attributes = sm_create_sysfs_attributes(ftl);\n\tif (!ftl->disk_attributes)\n\t\tgoto error6;\n\ttrans->disk_attributes = ftl->disk_attributes;\n\n\tsm_printk(\"Found %d MiB xD/SmartMedia FTL on mtd%d\",\n\t\t(int)(mtd->size / (1024 * 1024)), mtd->index);\n\n\tdbg(\"FTL layout:\");\n\tdbg(\"%d zone(s), each consists of %d blocks (+%d spares)\",\n\t\tftl->zone_count, ftl->max_lba,\n\t\tftl->zone_size - ftl->max_lba);\n\tdbg(\"each block consists of %d bytes\",\n\t\tftl->block_size);\n\n\n\t \n\tif (add_mtd_blktrans_dev(trans)) {\n\t\tdbg(\"error in mtdblktrans layer\");\n\t\tgoto error6;\n\t}\n\treturn;\nerror6:\n\tkfree(trans);\nerror5:\n\tkfree(ftl->cache_data);\nerror4:\n\tkfree(ftl->zones);\nerror3:\n\tkfree(ftl->cis_buffer);\nerror2:\n\tkfree(ftl);\nerror1:\n\treturn;\n}\n\n \nstatic void sm_remove_dev(struct mtd_blktrans_dev *dev)\n{\n\tstruct sm_ftl *ftl = dev->priv;\n\tint i;\n\n\tdel_mtd_blktrans_dev(dev);\n\tftl->trans = NULL;\n\n\tfor (i = 0 ; i < ftl->zone_count; i++) {\n\n\t\tif (!ftl->zones[i].initialized)\n\t\t\tcontinue;\n\n\t\tkfree(ftl->zones[i].lba_to_phys_table);\n\t\tkfifo_free(&ftl->zones[i].free_sectors);\n\t}\n\n\tsm_delete_sysfs_attributes(ftl);\n\tkfree(ftl->cis_buffer);\n\tkfree(ftl->zones);\n\tkfree(ftl->cache_data);\n\tkfree(ftl);\n}\n\nstatic struct mtd_blktrans_ops sm_ftl_ops = {\n\t.name\t\t= \"smblk\",\n\t.major\t\t= 0,\n\t.part_bits\t= SM_FTL_PARTN_BITS,\n\t.blksize\t= SM_SECTOR_SIZE,\n\t.getgeo\t\t= sm_getgeo,\n\n\t.add_mtd\t= sm_add_mtd,\n\t.remove_dev\t= sm_remove_dev,\n\n\t.readsect\t= sm_read,\n\t.writesect\t= sm_write,\n\n\t.flush\t\t= sm_flush,\n\t.release\t= sm_release,\n\n\t.owner\t\t= THIS_MODULE,\n};\n\nstatic __init int sm_module_init(void)\n{\n\tint error = 0;\n\n\tcache_flush_workqueue = create_freezable_workqueue(\"smflush\");\n\tif (!cache_flush_workqueue)\n\t\treturn -ENOMEM;\n\n\terror = register_mtd_blktrans(&sm_ftl_ops);\n\tif (error)\n\t\tdestroy_workqueue(cache_flush_workqueue);\n\treturn error;\n\n}\n\nstatic void __exit sm_module_exit(void)\n{\n\tdestroy_workqueue(cache_flush_workqueue);\n\tderegister_mtd_blktrans(&sm_ftl_ops);\n}\n\nmodule_init(sm_module_init);\nmodule_exit(sm_module_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Maxim Levitsky <maximlevitsky@gmail.com>\");\nMODULE_DESCRIPTION(\"Smartmedia/xD mtd translation layer\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}