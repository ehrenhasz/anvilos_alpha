{
  "module_name": "iphase.c",
  "hash_id": "46bea2b6fc7a5d184b35e99a6d50a3e8558c9591829e508e02176a0118c34913",
  "original_prompt": "Ingested from linux-6.6.14/drivers/atm/iphase.c",
  "human_readable_source": " \n\n#include <linux/module.h>  \n#include <linux/kernel.h>  \n#include <linux/mm.h>  \n#include <linux/pci.h>  \n#include <linux/errno.h>  \n#include <linux/atm.h>  \n#include <linux/atmdev.h>  \n#include <linux/ctype.h>\n#include <linux/sonet.h>  \n#include <linux/skbuff.h>  \n#include <linux/time.h>  \n#include <linux/delay.h>  \n#include <linux/uio.h>  \n#include <linux/init.h>  \n#include <linux/interrupt.h>\n#include <linux/wait.h>\n#include <linux/slab.h>\n#include <asm/io.h>  \n#include <linux/atomic.h>\n#include <linux/uaccess.h>  \n#include <asm/string.h>  \n#include <asm/byteorder.h>  \n#include <linux/vmalloc.h>\n#include <linux/jiffies.h>\n#include <linux/nospec.h>\n#include \"iphase.h\"\t\t  \n#include \"suni.h\"\t\t  \n#define swap_byte_order(x) (((x & 0xff) << 8) | ((x & 0xff00) >> 8))\n\n#define PRIV(dev) ((struct suni_priv *) dev->phy_data)\n\nstatic unsigned char ia_phy_get(struct atm_dev *dev, unsigned long addr);\nstatic void desc_dbg(IADEV *iadev);\n\nstatic IADEV *ia_dev[8];\nstatic struct atm_dev *_ia_dev[8];\nstatic int iadev_count;\nstatic void ia_led_timer(struct timer_list *unused);\nstatic DEFINE_TIMER(ia_timer, ia_led_timer);\nstatic int IA_TX_BUF = DFL_TX_BUFFERS, IA_TX_BUF_SZ = DFL_TX_BUF_SZ;\nstatic int IA_RX_BUF = DFL_RX_BUFFERS, IA_RX_BUF_SZ = DFL_RX_BUF_SZ;\nstatic uint IADebugFlag =   0; \n\nmodule_param(IA_TX_BUF, int, 0);\nmodule_param(IA_TX_BUF_SZ, int, 0);\nmodule_param(IA_RX_BUF, int, 0);\nmodule_param(IA_RX_BUF_SZ, int, 0);\nmodule_param(IADebugFlag, uint, 0644);\n\nMODULE_LICENSE(\"GPL\");\n\n \n\nstatic void ia_init_rtn_q (IARTN_Q *que) \n{ \n   que->next = NULL; \n   que->tail = NULL; \n}\n\nstatic void ia_enque_head_rtn_q (IARTN_Q *que, IARTN_Q * data) \n{\n   data->next = NULL;\n   if (que->next == NULL) \n      que->next = que->tail = data;\n   else {\n      data->next = que->next;\n      que->next = data;\n   } \n   return;\n}\n\nstatic int ia_enque_rtn_q (IARTN_Q *que, struct desc_tbl_t data) {\n   IARTN_Q *entry = kmalloc(sizeof(*entry), GFP_ATOMIC);\n   if (!entry)\n      return -ENOMEM;\n   entry->data = data;\n   entry->next = NULL;\n   if (que->next == NULL) \n      que->next = que->tail = entry;\n   else {\n      que->tail->next = entry;\n      que->tail = que->tail->next;\n   }      \n   return 1;\n}\n\nstatic IARTN_Q * ia_deque_rtn_q (IARTN_Q *que) {\n   IARTN_Q *tmpdata;\n   if (que->next == NULL)\n      return NULL;\n   tmpdata = que->next;\n   if ( que->next == que->tail)  \n      que->next = que->tail = NULL;\n   else \n      que->next = que->next->next;\n   return tmpdata;\n}\n\nstatic void ia_hack_tcq(IADEV *dev) {\n\n  u_short \t\tdesc1;\n  u_short\t\ttcq_wr;\n  struct ia_vcc         *iavcc_r = NULL; \n\n  tcq_wr = readl(dev->seg_reg+TCQ_WR_PTR) & 0xffff;\n  while (dev->host_tcq_wr != tcq_wr) {\n     desc1 = *(u_short *)(dev->seg_ram + dev->host_tcq_wr);\n     if (!desc1) ;\n     else if (!dev->desc_tbl[desc1 -1].timestamp) {\n        IF_ABR(printk(\" Desc %d is reset at %ld\\n\", desc1 -1, jiffies);)\n        *(u_short *) (dev->seg_ram + dev->host_tcq_wr) = 0;\n     }                                 \n     else if (dev->desc_tbl[desc1 -1].timestamp) {\n        if (!(iavcc_r = dev->desc_tbl[desc1 -1].iavcc)) { \n           printk(\"IA: Fatal err in get_desc\\n\");\n           continue;\n        }\n        iavcc_r->vc_desc_cnt--;\n        dev->desc_tbl[desc1 -1].timestamp = 0;\n        IF_EVENT(printk(\"ia_hack: return_q skb = 0x%p desc = %d\\n\",\n                                   dev->desc_tbl[desc1 -1].txskb, desc1);)\n        if (iavcc_r->pcr < dev->rate_limit) {\n           IA_SKB_STATE (dev->desc_tbl[desc1-1].txskb) |= IA_TX_DONE;\n           if (ia_enque_rtn_q(&dev->tx_return_q, dev->desc_tbl[desc1 -1]) < 0)\n              printk(\"ia_hack_tcq: No memory available\\n\");\n        } \n        dev->desc_tbl[desc1 -1].iavcc = NULL;\n        dev->desc_tbl[desc1 -1].txskb = NULL;\n     }\n     dev->host_tcq_wr += 2;\n     if (dev->host_tcq_wr > dev->ffL.tcq_ed) \n        dev->host_tcq_wr = dev->ffL.tcq_st;\n  }\n}  \n\nstatic u16 get_desc (IADEV *dev, struct ia_vcc *iavcc) {\n  u_short \t\tdesc_num, i;\n  struct ia_vcc         *iavcc_r = NULL; \n  unsigned long delta;\n  static unsigned long timer = 0;\n  int ltimeout;\n\n  ia_hack_tcq (dev);\n  if((time_after(jiffies,timer+50)) || ((dev->ffL.tcq_rd==dev->host_tcq_wr))) {\n     timer = jiffies; \n     i=0;\n     while (i < dev->num_tx_desc) {\n        if (!dev->desc_tbl[i].timestamp) {\n           i++;\n           continue;\n        }\n        ltimeout = dev->desc_tbl[i].iavcc->ltimeout; \n        delta = jiffies - dev->desc_tbl[i].timestamp;\n        if (delta >= ltimeout) {\n           IF_ABR(printk(\"RECOVER run!! desc_tbl %d = %d  delta = %ld, time = %ld\\n\", i,dev->desc_tbl[i].timestamp, delta, jiffies);)\n           if (dev->ffL.tcq_rd == dev->ffL.tcq_st) \n              dev->ffL.tcq_rd =  dev->ffL.tcq_ed;\n           else \n              dev->ffL.tcq_rd -= 2;\n           *(u_short *)(dev->seg_ram + dev->ffL.tcq_rd) = i+1;\n           if (!dev->desc_tbl[i].txskb || !(iavcc_r = dev->desc_tbl[i].iavcc))\n              printk(\"Fatal err, desc table vcc or skb is NULL\\n\");\n           else \n              iavcc_r->vc_desc_cnt--;\n           dev->desc_tbl[i].timestamp = 0;\n           dev->desc_tbl[i].iavcc = NULL;\n           dev->desc_tbl[i].txskb = NULL;\n        }\n        i++;\n     }  \n  }\n  if (dev->ffL.tcq_rd == dev->host_tcq_wr) \n     return 0xFFFF;\n    \n   \n  desc_num = *(u_short *)(dev->seg_ram + dev->ffL.tcq_rd);\n\n  while (!desc_num || (dev->desc_tbl[desc_num -1]).timestamp) {\n     dev->ffL.tcq_rd += 2;\n     if (dev->ffL.tcq_rd > dev->ffL.tcq_ed) \n\tdev->ffL.tcq_rd = dev->ffL.tcq_st;\n     if (dev->ffL.tcq_rd == dev->host_tcq_wr) \n        return 0xFFFF; \n     desc_num = *(u_short *)(dev->seg_ram + dev->ffL.tcq_rd);\n  }\n\n   \n  dev->desc_tbl[desc_num -1].timestamp = jiffies;\n  return desc_num;\n}\n\nstatic void clear_lockup (struct atm_vcc *vcc, IADEV *dev) {\n  u_char          \tfoundLockUp;\n  vcstatus_t\t\t*vcstatus;\n  u_short               *shd_tbl;\n  u_short               tempCellSlot, tempFract;\n  struct main_vc *abr_vc = (struct main_vc *)dev->MAIN_VC_TABLE_ADDR;\n  struct ext_vc *eabr_vc = (struct ext_vc *)dev->EXT_VC_TABLE_ADDR;\n  u_int  i;\n\n  if (vcc->qos.txtp.traffic_class == ATM_ABR) {\n     vcstatus = (vcstatus_t *) &(dev->testTable[vcc->vci]->vc_status);\n     vcstatus->cnt++;\n     foundLockUp = 0;\n     if( vcstatus->cnt == 0x05 ) {\n        abr_vc += vcc->vci;\n\teabr_vc += vcc->vci;\n\tif( eabr_vc->last_desc ) {\n\t   if( (abr_vc->status & 0x07) == ABR_STATE   ) {\n               \n              udelay(10);\n\t      if ((eabr_vc->last_desc)&&((abr_vc->status & 0x07)==ABR_STATE))\n\t\t foundLockUp = 1;\n           }\n\t   else {\n\t      tempCellSlot = abr_vc->last_cell_slot;\n              tempFract    = abr_vc->fraction;\n              if((tempCellSlot == dev->testTable[vcc->vci]->lastTime)\n                         && (tempFract == dev->testTable[vcc->vci]->fract))\n\t         foundLockUp = 1; \t\t    \n              dev->testTable[vcc->vci]->lastTime = tempCellSlot;   \n              dev->testTable[vcc->vci]->fract = tempFract; \n\t   } \t    \n        }  \t \t   \n        vcstatus->cnt = 0;     \t\n     }  \n\t\n     if (foundLockUp) {\n        IF_ABR(printk(\"LOCK UP found\\n\");) \n\twritew(0xFFFD, dev->seg_reg+MODE_REG_0);\n         \n        udelay(10); \n        abr_vc->status &= 0xFFF8;\n        abr_vc->status |= 0x0001;   \n\tshd_tbl = (u_short *)dev->ABR_SCHED_TABLE_ADDR;                \n\tfor( i = 0; ((i < dev->num_vc) && (shd_tbl[i])); i++ );\n\tif (i < dev->num_vc)\n           shd_tbl[i] = vcc->vci;\n        else\n           IF_ERR(printk(\"ABR Seg. may not continue on VC %x\\n\",vcc->vci);)\n        writew(T_ONLINE, dev->seg_reg+MODE_REG_0);\n        writew(~(TRANSMIT_DONE|TCQ_NOT_EMPTY), dev->seg_reg+SEG_MASK_REG);\n        writew(TRANSMIT_DONE, dev->seg_reg+SEG_INTR_STATUS_REG);       \n\tvcstatus->cnt = 0;\n     }  \n\n  }  \n\n\n}\n \n \nstatic u16\ncellrate_to_float(u32 cr)\n{\n\n#define\tNZ \t\t0x4000\n#define\tM_BITS\t\t9\t\t \n#define\tE_BITS\t\t5\t\t \n#define\tM_MASK\t\t0x1ff\t\t\n#define\tE_MASK\t\t0x1f\n  u16   flot;\n  u32\ttmp = cr & 0x00ffffff;\n  int \ti   = 0;\n  if (cr == 0)\n     return 0;\n  while (tmp != 1) {\n     tmp >>= 1;\n     i++;\n  }\n  if (i == M_BITS)\n     flot = NZ | (i << M_BITS) | (cr & M_MASK);\n  else if (i < M_BITS)\n     flot = NZ | (i << M_BITS) | ((cr << (M_BITS - i)) & M_MASK);\n  else\n     flot = NZ | (i << M_BITS) | ((cr >> (i - M_BITS)) & M_MASK);\n  return flot;\n}\n\n#if 0\n \nstatic u32\nfloat_to_cellrate(u16 rate)\n{\n  u32   exp, mantissa, cps;\n  if ((rate & NZ) == 0)\n     return 0;\n  exp = (rate >> M_BITS) & E_MASK;\n  mantissa = rate & M_MASK;\n  if (exp == 0)\n     return 1;\n  cps = (1 << M_BITS) | mantissa;\n  if (exp == M_BITS)\n     cps = cps;\n  else if (exp > M_BITS)\n     cps <<= (exp - M_BITS);\n  else\n     cps >>= (M_BITS - exp);\n  return cps;\n}\n#endif \n\nstatic void init_abr_vc (IADEV *dev, srv_cls_param_t *srv_p) {\n  srv_p->class_type = ATM_ABR;\n  srv_p->pcr        = dev->LineRate;\n  srv_p->mcr        = 0;\n  srv_p->icr        = 0x055cb7;\n  srv_p->tbe        = 0xffffff;\n  srv_p->frtt       = 0x3a;\n  srv_p->rif        = 0xf;\n  srv_p->rdf        = 0xb;\n  srv_p->nrm        = 0x4;\n  srv_p->trm        = 0x7;\n  srv_p->cdf        = 0x3;\n  srv_p->adtf       = 50;\n}\n\nstatic int\nia_open_abr_vc(IADEV *dev, srv_cls_param_t *srv_p, \n                                                struct atm_vcc *vcc, u8 flag)\n{\n  f_vc_abr_entry  *f_abr_vc;\n  r_vc_abr_entry  *r_abr_vc;\n  u32\t\ticr;\n  u8\t\ttrm, nrm, crm;\n  u16\t\tadtf, air, *ptr16;\t\n  f_abr_vc =(f_vc_abr_entry *)dev->MAIN_VC_TABLE_ADDR;\n  f_abr_vc += vcc->vci;       \n  switch (flag) {\n     case 1:  \n#if 0   \n       if (srv_p->pcr == 0)\n          return INVALID_PCR;\n       if (srv_p->pcr > dev->LineRate)\n          srv_p->pcr = dev->LineRate;\n       if ((srv_p->mcr + dev->sum_mcr) > dev->LineRate)\n\t  return MCR_UNAVAILABLE;\n       if (srv_p->mcr > srv_p->pcr)\n\t  return INVALID_MCR;\n       if (!(srv_p->icr))\n\t  srv_p->icr = srv_p->pcr;\n       if ((srv_p->icr < srv_p->mcr) || (srv_p->icr > srv_p->pcr))\n\t  return INVALID_ICR;\n       if ((srv_p->tbe < MIN_TBE) || (srv_p->tbe > MAX_TBE))\n\t  return INVALID_TBE;\n       if ((srv_p->frtt < MIN_FRTT) || (srv_p->frtt > MAX_FRTT))\n\t  return INVALID_FRTT;\n       if (srv_p->nrm > MAX_NRM)\n\t  return INVALID_NRM;\n       if (srv_p->trm > MAX_TRM)\n\t  return INVALID_TRM;\n       if (srv_p->adtf > MAX_ADTF)\n          return INVALID_ADTF;\n       else if (srv_p->adtf == 0)\n\t  srv_p->adtf = 1;\n       if (srv_p->cdf > MAX_CDF)\n\t  return INVALID_CDF;\n       if (srv_p->rif > MAX_RIF)\n\t  return INVALID_RIF;\n       if (srv_p->rdf > MAX_RDF)\n\t  return INVALID_RDF;\n#endif\n       memset ((caddr_t)f_abr_vc, 0, sizeof(*f_abr_vc));\n       f_abr_vc->f_vc_type = ABR;\n       nrm = 2 << srv_p->nrm;      \n\t\t\t           \n       f_abr_vc->f_nrm = nrm << 8 | nrm;\n       trm = 100000/(2 << (16 - srv_p->trm));\n       if ( trm == 0) trm = 1;\n       f_abr_vc->f_nrmexp =(((srv_p->nrm +1) & 0x0f) << 12)|(MRM << 8) | trm;\n       crm = srv_p->tbe / nrm;\n       if (crm == 0) crm = 1;\n       f_abr_vc->f_crm = crm & 0xff;\n       f_abr_vc->f_pcr = cellrate_to_float(srv_p->pcr);\n       icr = min( srv_p->icr, (srv_p->tbe > srv_p->frtt) ?\n\t\t\t\t((srv_p->tbe/srv_p->frtt)*1000000) :\n\t\t\t\t(1000000/(srv_p->frtt/srv_p->tbe)));\n       f_abr_vc->f_icr = cellrate_to_float(icr);\n       adtf = (10000 * srv_p->adtf)/8192;\n       if (adtf == 0) adtf = 1; \n       f_abr_vc->f_cdf = ((7 - srv_p->cdf) << 12 | adtf) & 0xfff;\n       f_abr_vc->f_mcr = cellrate_to_float(srv_p->mcr);\n       f_abr_vc->f_acr = f_abr_vc->f_icr;\n       f_abr_vc->f_status = 0x0042;\n       break;\n    case 0:  \t\n       ptr16 = (u_short *)(dev->reass_ram + REASS_TABLE*dev->memSize); \n       *(ptr16 + vcc->vci) = NO_AAL5_PKT | REASS_ABR;\n       r_abr_vc = (r_vc_abr_entry*)(dev->reass_ram+ABR_VC_TABLE*dev->memSize);\n       r_abr_vc += vcc->vci;\n       r_abr_vc->r_status_rdf = (15 - srv_p->rdf) & 0x000f;\n       air = srv_p->pcr << (15 - srv_p->rif);\n       if (air == 0) air = 1;\n       r_abr_vc->r_air = cellrate_to_float(air);\n       dev->testTable[vcc->vci]->vc_status = VC_ACTIVE | VC_ABR;\n       dev->sum_mcr\t   += srv_p->mcr;\n       dev->n_abr++;\n       break;\n    default:\n       break;\n  }\n  return\t0;\n}\nstatic int ia_cbr_setup (IADEV *dev, struct atm_vcc *vcc) {\n   u32 rateLow=0, rateHigh, rate;\n   int entries;\n   struct ia_vcc *ia_vcc;\n\n   int   idealSlot =0, testSlot, toBeAssigned, inc;\n   u32   spacing;\n   u16  *SchedTbl, *TstSchedTbl;\n   u16  cbrVC, vcIndex;\n   u32   fracSlot    = 0;\n   u32   sp_mod      = 0;\n   u32   sp_mod2     = 0;\n\n    \n   if (vcc->qos.txtp.max_pcr <= 0) {\n      IF_ERR(printk(\"PCR for CBR not defined\\n\");)\n      return -1;\n   }\n   rate = vcc->qos.txtp.max_pcr;\n   entries = rate / dev->Granularity;\n   IF_CBR(printk(\"CBR: CBR entries=0x%x for rate=0x%x & Gran=0x%x\\n\",\n                                entries, rate, dev->Granularity);)\n   if (entries < 1)\n      IF_CBR(printk(\"CBR: Bandwidth smaller than granularity of CBR table\\n\");) \n   rateLow  =  entries * dev->Granularity;\n   rateHigh = (entries + 1) * dev->Granularity;\n   if (3*(rate - rateLow) > (rateHigh - rate))\n      entries++;\n   if (entries > dev->CbrRemEntries) {\n      IF_CBR(printk(\"CBR: Not enough bandwidth to support this PCR.\\n\");)\n      IF_CBR(printk(\"Entries = 0x%x, CbrRemEntries = 0x%x.\\n\",\n                                       entries, dev->CbrRemEntries);)\n      return -EBUSY;\n   }   \n\n   ia_vcc = INPH_IA_VCC(vcc);\n   ia_vcc->NumCbrEntry = entries; \n   dev->sum_mcr += entries * dev->Granularity; \n    \n   \n   \n   cbrVC   = 0;\n   spacing = dev->CbrTotEntries / entries;\n   sp_mod  = dev->CbrTotEntries % entries; \n   toBeAssigned = entries;\n   fracSlot = 0;\n   vcIndex  = vcc->vci;\n   IF_CBR(printk(\"Vci=0x%x,Spacing=0x%x,Sp_mod=0x%x\\n\",vcIndex,spacing,sp_mod);)\n   while (toBeAssigned)\n   {\n      \n      \n      if (toBeAssigned == entries)\n      {\n         idealSlot = dev->CbrEntryPt;\n         dev->CbrEntryPt += 2;    \n         if (dev->CbrEntryPt >= dev->CbrTotEntries) \n            dev->CbrEntryPt -= dev->CbrTotEntries;\n      } else {\n         idealSlot += (u32)(spacing + fracSlot); \n         \n         fracSlot = ((sp_mod + sp_mod2) / entries);  \n         sp_mod2  = ((sp_mod + sp_mod2) % entries);  \n      }\n      if (idealSlot >= (int)dev->CbrTotEntries) \n         idealSlot -= dev->CbrTotEntries;  \n      \n      \n      SchedTbl = (u16*)(dev->seg_ram+CBR_SCHED_TABLE*dev->memSize); \n      inc = 0;\n      testSlot = idealSlot;\n      TstSchedTbl = (u16*)(SchedTbl+testSlot);  \n      IF_CBR(printk(\"CBR Testslot 0x%x AT Location 0x%p, NumToAssign=%d\\n\",\n                                testSlot, TstSchedTbl,toBeAssigned);)\n      memcpy((caddr_t)&cbrVC,(caddr_t)TstSchedTbl,sizeof(cbrVC));\n      while (cbrVC)  \n      {\n          inc++;\n          testSlot = idealSlot - inc;\n          if (testSlot < 0) { \n             testSlot += dev->CbrTotEntries;\n             IF_CBR(printk(\"Testslot Wrap. STable Start=0x%p,Testslot=%d\\n\",\n                                                       SchedTbl,testSlot);)\n          }\n          TstSchedTbl = (u16 *)(SchedTbl + testSlot);  \n          memcpy((caddr_t)&cbrVC,(caddr_t)TstSchedTbl,sizeof(cbrVC)); \n          if (!cbrVC)\n             break;\n          testSlot = idealSlot + inc;\n          if (testSlot >= (int)dev->CbrTotEntries) { \n             testSlot -= dev->CbrTotEntries;\n             IF_CBR(printk(\"TotCbrEntries=%d\",dev->CbrTotEntries);)\n             IF_CBR(printk(\" Testslot=0x%x ToBeAssgned=%d\\n\", \n                                            testSlot, toBeAssigned);)\n          } \n          \n          TstSchedTbl = (u16*)(SchedTbl + testSlot);\n          IF_CBR(printk(\"Reading CBR Tbl from 0x%p, CbrVal=0x%x Iteration %d\\n\",\n                          TstSchedTbl,cbrVC,inc);)\n          memcpy((caddr_t)&cbrVC,(caddr_t)TstSchedTbl,sizeof(cbrVC));\n       }  \n       \n       memcpy((caddr_t)TstSchedTbl, (caddr_t)&vcIndex, sizeof(*TstSchedTbl));\n       dev->CbrRemEntries--;\n       toBeAssigned--;\n   }   \n\n    \n   dev->NumEnabledCBR++;\n   if (dev->NumEnabledCBR == 1) {\n       writew((CBR_EN | UBR_EN | ABR_EN | (0x23 << 2)), dev->seg_reg+STPARMS);\n       IF_CBR(printk(\"CBR is enabled\\n\");)\n   }\n   return 0;\n}\nstatic void ia_cbrVc_close (struct atm_vcc *vcc) {\n   IADEV *iadev;\n   u16 *SchedTbl, NullVci = 0;\n   u32 i, NumFound;\n\n   iadev = INPH_IA_DEV(vcc->dev);\n   iadev->NumEnabledCBR--;\n   SchedTbl = (u16*)(iadev->seg_ram+CBR_SCHED_TABLE*iadev->memSize);\n   if (iadev->NumEnabledCBR == 0) {\n      writew((UBR_EN | ABR_EN | (0x23 << 2)), iadev->seg_reg+STPARMS);\n      IF_CBR (printk(\"CBR support disabled\\n\");)\n   }\n   NumFound = 0;\n   for (i=0; i < iadev->CbrTotEntries; i++)\n   {\n      if (*SchedTbl == vcc->vci) {\n         iadev->CbrRemEntries++;\n         *SchedTbl = NullVci;\n         IF_CBR(NumFound++;)\n      }\n      SchedTbl++;   \n   } \n   IF_CBR(printk(\"Exit ia_cbrVc_close, NumRemoved=%d\\n\",NumFound);)\n}\n\nstatic int ia_avail_descs(IADEV *iadev) {\n   int tmp = 0;\n   ia_hack_tcq(iadev);\n   if (iadev->host_tcq_wr >= iadev->ffL.tcq_rd)\n      tmp = (iadev->host_tcq_wr - iadev->ffL.tcq_rd) / 2;\n   else\n      tmp = (iadev->ffL.tcq_ed - iadev->ffL.tcq_rd + 2 + iadev->host_tcq_wr -\n                   iadev->ffL.tcq_st) / 2;\n   return tmp;\n}    \n\nstatic int ia_pkt_tx (struct atm_vcc *vcc, struct sk_buff *skb);\n\nstatic int ia_que_tx (IADEV *iadev) { \n   struct sk_buff *skb;\n   int num_desc;\n   struct atm_vcc *vcc;\n   num_desc = ia_avail_descs(iadev);\n\n   while (num_desc && (skb = skb_dequeue(&iadev->tx_backlog))) {\n      if (!(vcc = ATM_SKB(skb)->vcc)) {\n         dev_kfree_skb_any(skb);\n         printk(\"ia_que_tx: Null vcc\\n\");\n         break;\n      }\n      if (!test_bit(ATM_VF_READY,&vcc->flags)) {\n         dev_kfree_skb_any(skb);\n         printk(\"Free the SKB on closed vci %d \\n\", vcc->vci);\n         break;\n      }\n      if (ia_pkt_tx (vcc, skb)) {\n         skb_queue_head(&iadev->tx_backlog, skb);\n      }\n      num_desc--;\n   }\n   return 0;\n}\n\nstatic void ia_tx_poll (IADEV *iadev) {\n   struct atm_vcc *vcc = NULL;\n   struct sk_buff *skb = NULL, *skb1 = NULL;\n   struct ia_vcc *iavcc;\n   IARTN_Q *  rtne;\n\n   ia_hack_tcq(iadev);\n   while ( (rtne = ia_deque_rtn_q(&iadev->tx_return_q))) {\n       skb = rtne->data.txskb;\n       if (!skb) {\n           printk(\"ia_tx_poll: skb is null\\n\");\n           goto out;\n       }\n       vcc = ATM_SKB(skb)->vcc;\n       if (!vcc) {\n           printk(\"ia_tx_poll: vcc is null\\n\");\n           dev_kfree_skb_any(skb);\n\t   goto out;\n       }\n\n       iavcc = INPH_IA_VCC(vcc);\n       if (!iavcc) {\n           printk(\"ia_tx_poll: iavcc is null\\n\");\n           dev_kfree_skb_any(skb);\n\t   goto out;\n       }\n\n       skb1 = skb_dequeue(&iavcc->txing_skb);\n       while (skb1 && (skb1 != skb)) {\n          if (!(IA_SKB_STATE(skb1) & IA_TX_DONE)) {\n             printk(\"IA_tx_intr: Vci %d lost pkt!!!\\n\", vcc->vci);\n          }\n          IF_ERR(printk(\"Release the SKB not match\\n\");)\n          if ((vcc->pop) && (skb1->len != 0))\n          {\n             vcc->pop(vcc, skb1);\n             IF_EVENT(printk(\"Transmit Done - skb 0x%lx return\\n\",\n                                                          (long)skb1);)\n          }\n          else \n             dev_kfree_skb_any(skb1);\n          skb1 = skb_dequeue(&iavcc->txing_skb);\n       }                                                        \n       if (!skb1) {\n          IF_EVENT(printk(\"IA: Vci %d - skb not found requeued\\n\",vcc->vci);)\n          ia_enque_head_rtn_q (&iadev->tx_return_q, rtne);\n          break;\n       }\n       if ((vcc->pop) && (skb->len != 0))\n       {\n          vcc->pop(vcc, skb);\n          IF_EVENT(printk(\"Tx Done - skb 0x%lx return\\n\",(long)skb);)\n       }\n       else \n          dev_kfree_skb_any(skb);\n       kfree(rtne);\n    }\n    ia_que_tx(iadev);\nout:\n    return;\n}\n#if 0\nstatic void ia_eeprom_put (IADEV *iadev, u32 addr, u_short val)\n{\n        u32\tt;\n\tint\ti;\n\t \n\tNVRAM_CMD (EXTEND + EWEN);\n\tNVRAM_CLR_CE;\n\t \n\tNVRAM_CMD(IAWRITE + addr);\n\t \n\tfor (i=15; i>=0; i--) {\n\t\tNVRAM_CLKOUT (val & 0x8000);\n\t\tval <<= 1;\n\t}\n\tNVRAM_CLR_CE;\n\tCFG_OR(NVCE);\n\tt = readl(iadev->reg+IPHASE5575_EEPROM_ACCESS); \n\twhile (!(t & NVDO))\n\t\tt = readl(iadev->reg+IPHASE5575_EEPROM_ACCESS); \n\n\tNVRAM_CLR_CE;\n\t \n\tNVRAM_CMD(EXTEND + EWDS)\n\tNVRAM_CLR_CE;\n\tCFG_AND(~NVDI);\n}\n#endif\n\nstatic u16 ia_eeprom_get (IADEV *iadev, u32 addr)\n{\n\tu_short\tval;\n        u32\tt;\n\tint\ti;\n\t \n\tNVRAM_CMD(IAREAD + addr);\n\t \n\tval = 0;\n\tfor (i=15; i>=0; i--) {\n\t\tNVRAM_CLKIN(t);\n\t\tval |= (t << i);\n\t}\n\tNVRAM_CLR_CE;\n\tCFG_AND(~NVDI);\n\treturn val;\n}\n\nstatic void ia_hw_type(IADEV *iadev) {\n   u_short memType = ia_eeprom_get(iadev, 25);   \n   iadev->memType = memType;\n   if ((memType & MEM_SIZE_MASK) == MEM_SIZE_1M) {\n      iadev->num_tx_desc = IA_TX_BUF;\n      iadev->tx_buf_sz = IA_TX_BUF_SZ;\n      iadev->num_rx_desc = IA_RX_BUF;\n      iadev->rx_buf_sz = IA_RX_BUF_SZ; \n   } else if ((memType & MEM_SIZE_MASK) == MEM_SIZE_512K) {\n      if (IA_TX_BUF == DFL_TX_BUFFERS)\n        iadev->num_tx_desc = IA_TX_BUF / 2;\n      else \n        iadev->num_tx_desc = IA_TX_BUF;\n      iadev->tx_buf_sz = IA_TX_BUF_SZ;\n      if (IA_RX_BUF == DFL_RX_BUFFERS)\n        iadev->num_rx_desc = IA_RX_BUF / 2;\n      else\n        iadev->num_rx_desc = IA_RX_BUF;\n      iadev->rx_buf_sz = IA_RX_BUF_SZ;\n   }\n   else {\n      if (IA_TX_BUF == DFL_TX_BUFFERS) \n        iadev->num_tx_desc = IA_TX_BUF / 8;\n      else\n        iadev->num_tx_desc = IA_TX_BUF;\n      iadev->tx_buf_sz = IA_TX_BUF_SZ;\n      if (IA_RX_BUF == DFL_RX_BUFFERS)\n        iadev->num_rx_desc = IA_RX_BUF / 8;\n      else\n        iadev->num_rx_desc = IA_RX_BUF;\n      iadev->rx_buf_sz = IA_RX_BUF_SZ; \n   } \n   iadev->rx_pkt_ram = TX_PACKET_RAM + (iadev->num_tx_desc * iadev->tx_buf_sz); \n   IF_INIT(printk(\"BUF: tx=%d,sz=%d rx=%d sz= %d rx_pkt_ram=%d\\n\",\n         iadev->num_tx_desc, iadev->tx_buf_sz, iadev->num_rx_desc,\n         iadev->rx_buf_sz, iadev->rx_pkt_ram);)\n\n#if 0\n   if ((memType & FE_MASK) == FE_SINGLE_MODE) {\n      iadev->phy_type = PHY_OC3C_S;\n   else if ((memType & FE_MASK) == FE_UTP_OPTION)\n      iadev->phy_type = PHY_UTP155;\n   else\n     iadev->phy_type = PHY_OC3C_M;\n#endif\n   \n   iadev->phy_type = memType & FE_MASK;\n   IF_INIT(printk(\"memType = 0x%x iadev->phy_type = 0x%x\\n\", \n                                         memType,iadev->phy_type);)\n   if (iadev->phy_type == FE_25MBIT_PHY) \n      iadev->LineRate = (u32)(((25600000/8)*26)/(27*53));\n   else if (iadev->phy_type == FE_DS3_PHY)\n      iadev->LineRate = (u32)(((44736000/8)*26)/(27*53));\n   else if (iadev->phy_type == FE_E3_PHY) \n      iadev->LineRate = (u32)(((34368000/8)*26)/(27*53));\n   else\n       iadev->LineRate = (u32)(ATM_OC3_PCR);\n   IF_INIT(printk(\"iadev->LineRate = %d \\n\", iadev->LineRate);)\n\n}\n\nstatic u32 ia_phy_read32(struct iadev_priv *ia, unsigned int reg)\n{\n\treturn readl(ia->phy + (reg >> 2));\n}\n\nstatic void ia_phy_write32(struct iadev_priv *ia, unsigned int reg, u32 val)\n{\n\twritel(val, ia->phy + (reg >> 2));\n}\n\nstatic void ia_frontend_intr(struct iadev_priv *iadev)\n{\n\tu32 status;\n\n\tif (iadev->phy_type & FE_25MBIT_PHY) {\n\t\tstatus = ia_phy_read32(iadev, MB25_INTR_STATUS);\n\t\tiadev->carrier_detect = (status & MB25_IS_GSB) ? 1 : 0;\n\t} else if (iadev->phy_type & FE_DS3_PHY) {\n\t\tia_phy_read32(iadev, SUNI_DS3_FRM_INTR_STAT);\n\t\tstatus = ia_phy_read32(iadev, SUNI_DS3_FRM_STAT);\n\t\tiadev->carrier_detect = (status & SUNI_DS3_LOSV) ? 0 : 1;\n\t} else if (iadev->phy_type & FE_E3_PHY) {\n\t\tia_phy_read32(iadev, SUNI_E3_FRM_MAINT_INTR_IND);\n\t\tstatus = ia_phy_read32(iadev, SUNI_E3_FRM_FRAM_INTR_IND_STAT);\n\t\tiadev->carrier_detect = (status & SUNI_E3_LOS) ? 0 : 1;\n\t} else {\n\t\tstatus = ia_phy_read32(iadev, SUNI_RSOP_STATUS);\n\t\tiadev->carrier_detect = (status & SUNI_LOSV) ? 0 : 1;\n\t}\n\n\tprintk(KERN_INFO \"IA: SUNI carrier %s\\n\",\n\t\tiadev->carrier_detect ? \"detected\" : \"lost signal\");\n}\n\nstatic void ia_mb25_init(struct iadev_priv *iadev)\n{\n#if 0\n   mb25->mb25_master_ctrl = MB25_MC_DRIC | MB25_MC_DREC | MB25_MC_ENABLED;\n#endif\n\tia_phy_write32(iadev, MB25_MASTER_CTRL, MB25_MC_DRIC | MB25_MC_DREC);\n\tia_phy_write32(iadev, MB25_DIAG_CONTROL, 0);\n\n\tiadev->carrier_detect =\n\t\t(ia_phy_read32(iadev, MB25_INTR_STATUS) & MB25_IS_GSB) ? 1 : 0;\n}\n\nstruct ia_reg {\n\tu16 reg;\n\tu16 val;\n};\n\nstatic void ia_phy_write(struct iadev_priv *iadev,\n\t\t\t const struct ia_reg *regs, int len)\n{\n\twhile (len--) {\n\t\tia_phy_write32(iadev, regs->reg, regs->val);\n\t\tregs++;\n\t}\n}\n\nstatic void ia_suni_pm7345_init_ds3(struct iadev_priv *iadev)\n{\n\tstatic const struct ia_reg suni_ds3_init[] = {\n\t\t{ SUNI_DS3_FRM_INTR_ENBL,\t0x17 },\n\t\t{ SUNI_DS3_FRM_CFG,\t\t0x01 },\n\t\t{ SUNI_DS3_TRAN_CFG,\t\t0x01 },\n\t\t{ SUNI_CONFIG,\t\t\t0 },\n\t\t{ SUNI_SPLR_CFG,\t\t0 },\n\t\t{ SUNI_SPLT_CFG,\t\t0 }\n\t};\n\tu32 status;\n\n\tstatus = ia_phy_read32(iadev, SUNI_DS3_FRM_STAT);\n\tiadev->carrier_detect = (status & SUNI_DS3_LOSV) ? 0 : 1;\n\n\tia_phy_write(iadev, suni_ds3_init, ARRAY_SIZE(suni_ds3_init));\n}\n\nstatic void ia_suni_pm7345_init_e3(struct iadev_priv *iadev)\n{\n\tstatic const struct ia_reg suni_e3_init[] = {\n\t\t{ SUNI_E3_FRM_FRAM_OPTIONS,\t\t0x04 },\n\t\t{ SUNI_E3_FRM_MAINT_OPTIONS,\t\t0x20 },\n\t\t{ SUNI_E3_FRM_FRAM_INTR_ENBL,\t\t0x1d },\n\t\t{ SUNI_E3_FRM_MAINT_INTR_ENBL,\t\t0x30 },\n\t\t{ SUNI_E3_TRAN_STAT_DIAG_OPTIONS,\t0 },\n\t\t{ SUNI_E3_TRAN_FRAM_OPTIONS,\t\t0x01 },\n\t\t{ SUNI_CONFIG,\t\t\t\tSUNI_PM7345_E3ENBL },\n\t\t{ SUNI_SPLR_CFG,\t\t\t0x41 },\n\t\t{ SUNI_SPLT_CFG,\t\t\t0x41 }\n\t};\n\tu32 status;\n\n\tstatus = ia_phy_read32(iadev, SUNI_E3_FRM_FRAM_INTR_IND_STAT);\n\tiadev->carrier_detect = (status & SUNI_E3_LOS) ? 0 : 1;\n\tia_phy_write(iadev, suni_e3_init, ARRAY_SIZE(suni_e3_init));\n}\n\nstatic void ia_suni_pm7345_init(struct iadev_priv *iadev)\n{\n\tstatic const struct ia_reg suni_init[] = {\n\t\t \n\t\t{ SUNI_INTR_ENBL,\t\t0x28 },\n\t\t \n\t\t{ SUNI_ID_RESET,\t\t0 },\n\t\t \n\t\t{ SUNI_MASTER_TEST,\t\t0 },\n\n\t\t{ SUNI_RXCP_CTRL,\t\t0x2c },\n\t\t{ SUNI_RXCP_FCTRL,\t\t0x81 },\n\n\t\t{ SUNI_RXCP_IDLE_PAT_H1,\t0 },\n\t\t{ SUNI_RXCP_IDLE_PAT_H2,\t0 },\n\t\t{ SUNI_RXCP_IDLE_PAT_H3,\t0 },\n\t\t{ SUNI_RXCP_IDLE_PAT_H4,\t0x01 },\n\n\t\t{ SUNI_RXCP_IDLE_MASK_H1,\t0xff },\n\t\t{ SUNI_RXCP_IDLE_MASK_H2,\t0xff },\n\t\t{ SUNI_RXCP_IDLE_MASK_H3,\t0xff },\n\t\t{ SUNI_RXCP_IDLE_MASK_H4,\t0xfe },\n\n\t\t{ SUNI_RXCP_CELL_PAT_H1,\t0 },\n\t\t{ SUNI_RXCP_CELL_PAT_H2,\t0 },\n\t\t{ SUNI_RXCP_CELL_PAT_H3,\t0 },\n\t\t{ SUNI_RXCP_CELL_PAT_H4,\t0x01 },\n\n\t\t{ SUNI_RXCP_CELL_MASK_H1,\t0xff },\n\t\t{ SUNI_RXCP_CELL_MASK_H2,\t0xff },\n\t\t{ SUNI_RXCP_CELL_MASK_H3,\t0xff },\n\t\t{ SUNI_RXCP_CELL_MASK_H4,\t0xff },\n\n\t\t{ SUNI_TXCP_CTRL,\t\t0xa4 },\n\t\t{ SUNI_TXCP_INTR_EN_STS,\t0x10 },\n\t\t{ SUNI_TXCP_IDLE_PAT_H5,\t0x55 }\n\t};\n\n\tif (iadev->phy_type & FE_DS3_PHY)\n\t\tia_suni_pm7345_init_ds3(iadev);\n\telse\n\t\tia_suni_pm7345_init_e3(iadev);\n\n\tia_phy_write(iadev, suni_init, ARRAY_SIZE(suni_init));\n\n\tia_phy_write32(iadev, SUNI_CONFIG, ia_phy_read32(iadev, SUNI_CONFIG) &\n\t\t~(SUNI_PM7345_LLB | SUNI_PM7345_CLB |\n\t\t  SUNI_PM7345_DLB | SUNI_PM7345_PLB));\n#ifdef __SNMP__\n   suni_pm7345->suni_rxcp_intr_en_sts |= SUNI_OOCDE;\n#endif  \n   return;\n}\n\n\n \n    \n#ifdef CONFIG_ATM_IA_DEBUG\nstatic int tcnter = 0;\nstatic void xdump( u_char*  cp, int  length, char*  prefix )\n{\n    int col, count;\n    u_char prntBuf[120];\n    u_char*  pBuf = prntBuf;\n    count = 0;\n    while(count < length){\n        pBuf += sprintf( pBuf, \"%s\", prefix );\n        for(col = 0;count + col < length && col < 16; col++){\n            if (col != 0 && (col % 4) == 0)\n                pBuf += sprintf( pBuf, \" \" );\n            pBuf += sprintf( pBuf, \"%02X \", cp[count + col] );\n        }\n        while(col++ < 16){       \n            if ((col % 4) == 0)\n                sprintf( pBuf, \" \" );\n            pBuf += sprintf( pBuf, \"   \" );\n        }\n        pBuf += sprintf( pBuf, \"  \" );\n        for(col = 0;count + col < length && col < 16; col++){\n\t\tu_char c = cp[count + col];\n\n\t\tif (isascii(c) && isprint(c))\n\t\t\tpBuf += sprintf(pBuf, \"%c\", c);\n\t\telse\n\t\t\tpBuf += sprintf(pBuf, \".\");\n                }\n        printk(\"%s\\n\", prntBuf);\n        count += col;\n        pBuf = prntBuf;\n    }\n\n}   \n#endif  \n\n  \nstatic struct atm_dev *ia_boards = NULL;  \n  \n#define ACTUAL_RAM_BASE \\\n\tRAM_BASE*((iadev->mem)/(128 * 1024))  \n#define ACTUAL_SEG_RAM_BASE \\\n\tIPHASE5575_FRAG_CONTROL_RAM_BASE*((iadev->mem)/(128 * 1024))  \n#define ACTUAL_REASS_RAM_BASE \\\n\tIPHASE5575_REASS_CONTROL_RAM_BASE*((iadev->mem)/(128 * 1024))  \n  \n  \n   \n  \nstatic void desc_dbg(IADEV *iadev) {\n\n  u_short tcq_wr_ptr, tcq_st_ptr, tcq_ed_ptr;\n  u32 i;\n  void __iomem *tmp;\n  \n  tcq_wr_ptr =  readw(iadev->seg_reg+TCQ_WR_PTR);\n  printk(\"B_tcq_wr = 0x%x desc = %d last desc = %d\\n\",\n                     tcq_wr_ptr, readw(iadev->seg_ram+tcq_wr_ptr),\n                     readw(iadev->seg_ram+tcq_wr_ptr-2));\n  printk(\" host_tcq_wr = 0x%x  host_tcq_rd = 0x%x \\n\",  iadev->host_tcq_wr, \n                   iadev->ffL.tcq_rd);\n  tcq_st_ptr =  readw(iadev->seg_reg+TCQ_ST_ADR);\n  tcq_ed_ptr =  readw(iadev->seg_reg+TCQ_ED_ADR);\n  printk(\"tcq_st_ptr = 0x%x    tcq_ed_ptr = 0x%x \\n\", tcq_st_ptr, tcq_ed_ptr);\n  i = 0;\n  while (tcq_st_ptr != tcq_ed_ptr) {\n      tmp = iadev->seg_ram+tcq_st_ptr;\n      printk(\"TCQ slot %d desc = %d  Addr = %p\\n\", i++, readw(tmp), tmp);\n      tcq_st_ptr += 2;\n  }\n  for(i=0; i <iadev->num_tx_desc; i++)\n      printk(\"Desc_tbl[%d] = %d \\n\", i, iadev->desc_tbl[i].timestamp);\n} \n  \n  \n   \n \nstatic void rx_excp_rcvd(struct atm_dev *dev)  \n{  \n#if 0    \n  IADEV *iadev;  \n  u_short state;  \n  u_short excpq_rd_ptr;  \n  \n  int vci, error = 1;  \n  iadev = INPH_IA_DEV(dev);  \n  state = readl(iadev->reass_reg + STATE_REG) & 0xffff;  \n  while((state & EXCPQ_EMPTY) != EXCPQ_EMPTY)  \n  { printk(\"state = %x \\n\", state); \n        excpq_rd_ptr = readw(iadev->reass_reg + EXCP_Q_RD_PTR) & 0xffff;  \n printk(\"state = %x excpq_rd_ptr = %x \\n\", state, excpq_rd_ptr); \n        if (excpq_rd_ptr == *(u16*)(iadev->reass_reg + EXCP_Q_WR_PTR))\n            IF_ERR(printk(\"excpq_rd_ptr is wrong!!!\\n\");)\n        \n\tvci = readw(iadev->reass_ram+excpq_rd_ptr);  \n\terror = readw(iadev->reass_ram+excpq_rd_ptr+2) & 0x0007;  \n        \n\texcpq_rd_ptr += 4;  \n\tif (excpq_rd_ptr > (readw(iadev->reass_reg + EXCP_Q_ED_ADR)& 0xffff))  \n \t    excpq_rd_ptr = readw(iadev->reass_reg + EXCP_Q_ST_ADR)& 0xffff;\n\twritew( excpq_rd_ptr, iadev->reass_reg + EXCP_Q_RD_PTR);  \n        state = readl(iadev->reass_reg + STATE_REG) & 0xffff;  \n  }  \n#endif\n}  \n  \nstatic void free_desc(struct atm_dev *dev, int desc)  \n{  \n\tIADEV *iadev;  \n\tiadev = INPH_IA_DEV(dev);  \n        writew(desc, iadev->reass_ram+iadev->rfL.fdq_wr); \n\tiadev->rfL.fdq_wr +=2;\n\tif (iadev->rfL.fdq_wr > iadev->rfL.fdq_ed)\n\t\tiadev->rfL.fdq_wr =  iadev->rfL.fdq_st;  \n\twritew(iadev->rfL.fdq_wr, iadev->reass_reg+FREEQ_WR_PTR);  \n}  \n  \n  \nstatic int rx_pkt(struct atm_dev *dev)  \n{  \n\tIADEV *iadev;  \n\tstruct atm_vcc *vcc;  \n\tunsigned short status;  \n\tstruct rx_buf_desc __iomem *buf_desc_ptr;  \n\tint desc;   \n\tstruct dle* wr_ptr;  \n\tint len;  \n\tstruct sk_buff *skb;  \n\tu_int buf_addr, dma_addr;  \n\n\tiadev = INPH_IA_DEV(dev);  \n\tif (iadev->rfL.pcq_rd == (readw(iadev->reass_reg+PCQ_WR_PTR)&0xffff)) \n\t{  \n   \t    printk(KERN_ERR DEV_LABEL \"(itf %d) Receive queue empty\\n\", dev->number);  \n\t    return -EINVAL;  \n\t}  \n\t   \n\tdesc = readw(iadev->reass_ram+iadev->rfL.pcq_rd) & 0x1fff;  \n        IF_RX(printk(\"reass_ram = %p iadev->rfL.pcq_rd = 0x%x desc = %d\\n\", \n                                    iadev->reass_ram, iadev->rfL.pcq_rd, desc);\n              printk(\" pcq_wr_ptr = 0x%x\\n\",\n                               readw(iadev->reass_reg+PCQ_WR_PTR)&0xffff);)\n\t   \n\tif ( iadev->rfL.pcq_rd== iadev->rfL.pcq_ed) \n\t\tiadev->rfL.pcq_rd = iadev->rfL.pcq_st;  \n\telse  \n\t\tiadev->rfL.pcq_rd += 2;\n\twritew(iadev->rfL.pcq_rd, iadev->reass_reg+PCQ_RD_PTR);  \n  \n\t   \n\tbuf_desc_ptr = iadev->RX_DESC_BASE_ADDR;\n\t   \n\tbuf_desc_ptr += desc;\t  \n        if (!desc || (desc > iadev->num_rx_desc) || \n                      ((buf_desc_ptr->vc_index & 0xffff) >= iadev->num_vc)) {\n            free_desc(dev, desc);\n            IF_ERR(printk(\"IA: bad descriptor desc = %d \\n\", desc);)\n            return -1;\n        }\n\tvcc = iadev->rx_open[buf_desc_ptr->vc_index & 0xffff];  \n\tif (!vcc)  \n\t{      \n                free_desc(dev, desc); \n\t\tprintk(\"IA: null vcc, drop PDU\\n\");  \n\t\treturn -1;  \n\t}  \n\t  \n  \n\t   \n\tstatus = (u_short) (buf_desc_ptr->desc_mode);  \n\tif (status & (RX_CER | RX_PTE | RX_OFL))  \n\t{  \n                atomic_inc(&vcc->stats->rx_err);\n\t\tIF_ERR(printk(\"IA: bad packet, dropping it\");)  \n                if (status & RX_CER) { \n                    IF_ERR(printk(\" cause: packet CRC error\\n\");)\n                }\n                else if (status & RX_PTE) {\n                    IF_ERR(printk(\" cause: packet time out\\n\");)\n                }\n                else {\n                    IF_ERR(printk(\" cause: buffer overflow\\n\");)\n                }\n\t\tgoto out_free_desc;\n\t}  \n  \n\t   \n  \n\tbuf_addr = (buf_desc_ptr->buf_start_hi << 16) | buf_desc_ptr->buf_start_lo;  \n\tdma_addr = (buf_desc_ptr->dma_start_hi << 16) | buf_desc_ptr->dma_start_lo;  \n\tlen = dma_addr - buf_addr;  \n        if (len > iadev->rx_buf_sz) {\n           printk(\"Over %d bytes sdu received, dropped!!!\\n\", iadev->rx_buf_sz);\n           atomic_inc(&vcc->stats->rx_err);\n\t   goto out_free_desc;\n        }\n\t\t  \n        if (!(skb = atm_alloc_charge(vcc, len, GFP_ATOMIC))) {\n           if (vcc->vci < 32)\n              printk(\"Drop control packets\\n\");\n\t   goto out_free_desc;\n        }\n\tskb_put(skb,len);  \n         \n        ATM_SKB(skb)->vcc = vcc;\n        ATM_DESC(skb) = desc;        \n\tskb_queue_tail(&iadev->rx_dma_q, skb);  \n\n\t   \n\twr_ptr = iadev->rx_dle_q.write;  \n\twr_ptr->sys_pkt_addr = dma_map_single(&iadev->pci->dev, skb->data,\n\t\t\t\t\t      len, DMA_FROM_DEVICE);\n\twr_ptr->local_pkt_addr = buf_addr;  \n\twr_ptr->bytes = len;\t   \n\twr_ptr->mode = DMA_INT_ENABLE;  \n  \n\t   \n        if(++wr_ptr == iadev->rx_dle_q.end)\n             wr_ptr = iadev->rx_dle_q.start;\n\tiadev->rx_dle_q.write = wr_ptr;  \n\tudelay(1);  \n\t   \n\twritel(1, iadev->dma+IPHASE5575_RX_COUNTER);   \nout:\treturn 0;  \nout_free_desc:\n        free_desc(dev, desc);\n        goto out;\n}  \n  \nstatic void rx_intr(struct atm_dev *dev)  \n{  \n  IADEV *iadev;  \n  u_short status;  \n  u_short state, i;  \n  \n  iadev = INPH_IA_DEV(dev);  \n  status = readl(iadev->reass_reg+REASS_INTR_STATUS_REG) & 0xffff;  \n  IF_EVENT(printk(\"rx_intr: status = 0x%x\\n\", status);)\n  if (status & RX_PKT_RCVD)  \n  {  \n\t   \n\t   \n\tstate = readl(iadev->reass_reg + STATE_REG) & 0xffff;  \n        IF_EVENT(printk(\"Rx intr status: RX_PKT_RCVD %08x\\n\", status);) \n\twhile(!(state & PCQ_EMPTY))  \n\t{  \n             rx_pkt(dev);  \n\t     state = readl(iadev->reass_reg + STATE_REG) & 0xffff;  \n\t}  \n        iadev->rxing = 1;\n  }  \n  if (status & RX_FREEQ_EMPT)  \n  {   \n     if (iadev->rxing) {\n        iadev->rx_tmp_cnt = iadev->rx_pkt_cnt;\n        iadev->rx_tmp_jif = jiffies; \n        iadev->rxing = 0;\n     } \n     else if ((time_after(jiffies, iadev->rx_tmp_jif + 50)) &&\n               ((iadev->rx_pkt_cnt - iadev->rx_tmp_cnt) == 0)) {\n        for (i = 1; i <= iadev->num_rx_desc; i++)\n               free_desc(dev, i);\nprintk(\"Test logic RUN!!!!\\n\");\n        writew( ~(RX_FREEQ_EMPT|RX_EXCP_RCVD),iadev->reass_reg+REASS_MASK_REG);\n        iadev->rxing = 1;\n     }\n     IF_EVENT(printk(\"Rx intr status: RX_FREEQ_EMPT %08x\\n\", status);)  \n  }  \n\n  if (status & RX_EXCP_RCVD)  \n  {  \n\t   \n\tIF_EVENT(printk(\"Rx intr status: RX_EXCP_RCVD %08x\\n\", status);)  \n\trx_excp_rcvd(dev);  \n  }  \n\n\n  if (status & RX_RAW_RCVD)  \n  {  \n\t   \n\tIF_EVENT(printk(\"Rx intr status:  RX_RAW_RCVD %08x\\n\", status);)  \n  }  \n}  \n  \n  \nstatic void rx_dle_intr(struct atm_dev *dev)  \n{  \n  IADEV *iadev;  \n  struct atm_vcc *vcc;   \n  struct sk_buff *skb;  \n  int desc;  \n  u_short state;   \n  struct dle *dle, *cur_dle;  \n  u_int dle_lp;  \n  int len;\n  iadev = INPH_IA_DEV(dev);  \n \n     \n     \n  dle = iadev->rx_dle_q.read;  \n  dle_lp = readl(iadev->dma+IPHASE5575_RX_LIST_ADDR) & (sizeof(struct dle)*DLE_ENTRIES - 1);  \n  cur_dle = (struct dle*)(iadev->rx_dle_q.start + (dle_lp >> 4));  \n  while(dle != cur_dle)  \n  {  \n         \n      skb = skb_dequeue(&iadev->rx_dma_q);  \n      if (!skb)  \n         goto INCR_DLE;\n      desc = ATM_DESC(skb);\n      free_desc(dev, desc);  \n               \n      if (!(len = skb->len))\n      {  \n          printk(\"rx_dle_intr: skb len 0\\n\");  \n\t  dev_kfree_skb_any(skb);  \n      }  \n      else  \n      {  \n          struct cpcs_trailer *trailer;\n          u_short length;\n          struct ia_vcc *ia_vcc;\n\n\t  dma_unmap_single(&iadev->pci->dev, iadev->rx_dle_q.write->sys_pkt_addr,\n\t\t\t   len, DMA_FROM_DEVICE);\n             \n          vcc = ATM_SKB(skb)->vcc;\n\t  if (!vcc) {\n\t      printk(\"IA: null vcc\\n\");  \n              dev_kfree_skb_any(skb);\n              goto INCR_DLE;\n          }\n          ia_vcc = INPH_IA_VCC(vcc);\n          if (ia_vcc == NULL)\n          {\n             atomic_inc(&vcc->stats->rx_err);\n             atm_return(vcc, skb->truesize);\n             dev_kfree_skb_any(skb);\n             goto INCR_DLE;\n           }\n          \n          trailer = (struct cpcs_trailer*)((u_char *)skb->data +\n                                 skb->len - sizeof(*trailer));\n\t  length = swap_byte_order(trailer->length);\n          if ((length > iadev->rx_buf_sz) || (length > \n                              (skb->len - sizeof(struct cpcs_trailer))))\n          {\n             atomic_inc(&vcc->stats->rx_err);\n             IF_ERR(printk(\"rx_dle_intr: Bad  AAL5 trailer %d (skb len %d)\", \n                                                            length, skb->len);)\n             atm_return(vcc, skb->truesize);\n             dev_kfree_skb_any(skb);\n             goto INCR_DLE;\n          }\n          skb_trim(skb, length);\n          \n\t     \n\t  IF_RXPKT(printk(\"\\nDmad Recvd data: len = %d \\n\", skb->len);  \n          xdump(skb->data, skb->len, \"RX: \");\n          printk(\"\\n\");)\n\n\t  IF_RX(printk(\"rx_dle_intr: skb push\");)  \n\t  vcc->push(vcc,skb);  \n\t  atomic_inc(&vcc->stats->rx);\n          iadev->rx_pkt_cnt++;\n      }  \nINCR_DLE:\n      if (++dle == iadev->rx_dle_q.end)  \n    \t  dle = iadev->rx_dle_q.start;  \n  }  \n  iadev->rx_dle_q.read = dle;  \n  \n    \n  if (!iadev->rxing) {\n     state = readl(iadev->reass_reg + STATE_REG) & 0xffff;\n     if (!(state & FREEQ_EMPTY)) {\n        state = readl(iadev->reass_reg + REASS_MASK_REG) & 0xffff;\n        writel(state & ~(RX_FREEQ_EMPT |  RX_PKT_RCVD),\n                                      iadev->reass_reg+REASS_MASK_REG);\n        iadev->rxing++; \n     }\n  }\n}  \n  \n  \nstatic int open_rx(struct atm_vcc *vcc)  \n{  \n\tIADEV *iadev;  \n\tu_short __iomem *vc_table;  \n\tu_short __iomem *reass_ptr;  \n\tIF_EVENT(printk(\"iadev: open_rx %d.%d\\n\", vcc->vpi, vcc->vci);)\n\n\tif (vcc->qos.rxtp.traffic_class == ATM_NONE) return 0;    \n\tiadev = INPH_IA_DEV(vcc->dev);  \n        if (vcc->qos.rxtp.traffic_class == ATM_ABR) {  \n           if (iadev->phy_type & FE_25MBIT_PHY) {\n               printk(\"IA:  ABR not support\\n\");\n               return -EINVAL; \n           }\n        }\n\t   \n\tvc_table = iadev->reass_ram+RX_VC_TABLE*iadev->memSize;\n\tvc_table += vcc->vci;\n\t   \n\n        *vc_table = vcc->vci << 6;\n\t   \n\tif ((vcc->qos.rxtp.traffic_class == ATM_ABR) || \n                                (vcc->qos.txtp.traffic_class == ATM_ABR))  \n\t{  \n                srv_cls_param_t srv_p;\n                init_abr_vc(iadev, &srv_p);\n                ia_open_abr_vc(iadev, &srv_p, vcc, 0);\n\t} \n       \telse {   \n        \treass_ptr = iadev->reass_ram+REASS_TABLE*iadev->memSize;\n           \treass_ptr += vcc->vci;\n           \t*reass_ptr = NO_AAL5_PKT;\n       \t}\n\t\n\tif (iadev->rx_open[vcc->vci])  \n\t\tprintk(KERN_CRIT DEV_LABEL \"(itf %d): VCI %d already open\\n\",  \n\t\t\tvcc->dev->number, vcc->vci);  \n\tiadev->rx_open[vcc->vci] = vcc;  \n\treturn 0;  \n}  \n  \nstatic int rx_init(struct atm_dev *dev)  \n{  \n\tIADEV *iadev;  \n\tstruct rx_buf_desc __iomem *buf_desc_ptr;  \n\tunsigned long rx_pkt_start = 0;  \n\tvoid *dle_addr;  \n\tstruct abr_vc_table  *abr_vc_table; \n\tu16 *vc_table;  \n\tu16 *reass_table;  \n\tint i,j, vcsize_sel;  \n\tu_short freeq_st_adr;  \n\tu_short *freeq_start;  \n  \n\tiadev = INPH_IA_DEV(dev);  \n  \n  \n\t \n\tdle_addr = dma_alloc_coherent(&iadev->pci->dev, DLE_TOTAL_SIZE,\n\t\t\t\t      &iadev->rx_dle_dma, GFP_KERNEL);\n\tif (!dle_addr)  {  \n\t\tprintk(KERN_ERR DEV_LABEL \"can't allocate DLEs\\n\");\n\t\tgoto err_out;\n\t}\n\tiadev->rx_dle_q.start = (struct dle *)dle_addr;\n\tiadev->rx_dle_q.read = iadev->rx_dle_q.start;  \n\tiadev->rx_dle_q.write = iadev->rx_dle_q.start;  \n\tiadev->rx_dle_q.end = (struct dle*)((unsigned long)dle_addr+sizeof(struct dle)*DLE_ENTRIES);\n\t   \n  \n\t   \n\t \n\twritel(iadev->rx_dle_dma & 0xfffff000,\n\t       iadev->dma + IPHASE5575_RX_LIST_ADDR);  \n\tIF_INIT(printk(\"Tx Dle list addr: 0x%p value: 0x%0x\\n\",\n                      iadev->dma+IPHASE5575_TX_LIST_ADDR,\n                      readl(iadev->dma + IPHASE5575_TX_LIST_ADDR));\n\tprintk(\"Rx Dle list addr: 0x%p value: 0x%0x\\n\",\n                      iadev->dma+IPHASE5575_RX_LIST_ADDR,\n                      readl(iadev->dma + IPHASE5575_RX_LIST_ADDR));)\n  \n\twritew(0xffff, iadev->reass_reg+REASS_MASK_REG);  \n\twritew(0, iadev->reass_reg+MODE_REG);  \n\twritew(RESET_REASS, iadev->reass_reg+REASS_COMMAND_REG);  \n  \n\t   \n\t  \n\t   \n\twritew(RX_DESC_BASE >> 16, iadev->reass_reg+REASS_DESC_BASE);  \n\t   \n\twritew(iadev->rx_buf_sz, iadev->reass_reg+BUF_SIZE);  \n  \n\t   \n        iadev->RX_DESC_BASE_ADDR = iadev->reass_ram+RX_DESC_BASE*iadev->memSize;\n\tbuf_desc_ptr = iadev->RX_DESC_BASE_ADDR;\n\tmemset_io(buf_desc_ptr, 0, sizeof(*buf_desc_ptr));\n\tbuf_desc_ptr++;  \n\trx_pkt_start = iadev->rx_pkt_ram;  \n\tfor(i=1; i<=iadev->num_rx_desc; i++)  \n\t{  \n\t\tmemset_io(buf_desc_ptr, 0, sizeof(*buf_desc_ptr));  \n\t\tbuf_desc_ptr->buf_start_hi = rx_pkt_start >> 16;  \n\t\tbuf_desc_ptr->buf_start_lo = rx_pkt_start & 0x0000ffff;  \n\t\tbuf_desc_ptr++;\t\t  \n\t\trx_pkt_start += iadev->rx_buf_sz;  \n\t}  \n\tIF_INIT(printk(\"Rx Buffer desc ptr: 0x%p\\n\", buf_desc_ptr);)\n        i = FREE_BUF_DESC_Q*iadev->memSize; \n\twritew(i >> 16,  iadev->reass_reg+REASS_QUEUE_BASE); \n        writew(i, iadev->reass_reg+FREEQ_ST_ADR);\n        writew(i+iadev->num_rx_desc*sizeof(u_short), \n                                         iadev->reass_reg+FREEQ_ED_ADR);\n        writew(i, iadev->reass_reg+FREEQ_RD_PTR);\n        writew(i+iadev->num_rx_desc*sizeof(u_short), \n                                        iadev->reass_reg+FREEQ_WR_PTR);    \n\t   \n\tfreeq_st_adr = readw(iadev->reass_reg+FREEQ_ST_ADR);  \n\tfreeq_start = (u_short *)(iadev->reass_ram+freeq_st_adr);  \n\tfor(i=1; i<=iadev->num_rx_desc; i++)  \n\t{  \n\t\t*freeq_start = (u_short)i;  \n\t\tfreeq_start++;  \n\t}  \n\tIF_INIT(printk(\"freeq_start: 0x%p\\n\", freeq_start);)\n         \n        i = (PKT_COMP_Q * iadev->memSize) & 0xffff;\n        writew(i, iadev->reass_reg+PCQ_ST_ADR);\n        writew(i+iadev->num_vc*sizeof(u_short), iadev->reass_reg+PCQ_ED_ADR);\n        writew(i, iadev->reass_reg+PCQ_RD_PTR);\n        writew(i, iadev->reass_reg+PCQ_WR_PTR);\n\n         \n        i = (EXCEPTION_Q * iadev->memSize) & 0xffff;\n        writew(i, iadev->reass_reg+EXCP_Q_ST_ADR);\n        writew(i + NUM_RX_EXCP * sizeof(RX_ERROR_Q), \n                                             iadev->reass_reg+EXCP_Q_ED_ADR);\n        writew(i, iadev->reass_reg+EXCP_Q_RD_PTR);\n        writew(i, iadev->reass_reg+EXCP_Q_WR_PTR); \n \n    \t \n        iadev->rfL.fdq_st = readw(iadev->reass_reg+FREEQ_ST_ADR) & 0xffff;\n       \tiadev->rfL.fdq_ed = readw(iadev->reass_reg+FREEQ_ED_ADR) & 0xffff ;\n\tiadev->rfL.fdq_rd = readw(iadev->reass_reg+FREEQ_RD_PTR) & 0xffff;\n\tiadev->rfL.fdq_wr = readw(iadev->reass_reg+FREEQ_WR_PTR) & 0xffff;\n        iadev->rfL.pcq_st = readw(iadev->reass_reg+PCQ_ST_ADR) & 0xffff;\n\tiadev->rfL.pcq_ed = readw(iadev->reass_reg+PCQ_ED_ADR) & 0xffff;\n\tiadev->rfL.pcq_rd = readw(iadev->reass_reg+PCQ_RD_PTR) & 0xffff;\n\tiadev->rfL.pcq_wr = readw(iadev->reass_reg+PCQ_WR_PTR) & 0xffff;\n\t\n        IF_INIT(printk(\"INIT:pcq_st:0x%x pcq_ed:0x%x pcq_rd:0x%x pcq_wr:0x%x\", \n              iadev->rfL.pcq_st, iadev->rfL.pcq_ed, iadev->rfL.pcq_rd, \n              iadev->rfL.pcq_wr);)\t\t  \n\t   \n\t   \n\t   \n\t   \n  \n\t   \n        i =  REASS_TABLE * iadev->memSize;\n\twritew((i >> 3), iadev->reass_reg+REASS_TABLE_BASE);   \n \t   \n\treass_table = (u16 *)(iadev->reass_ram+i);  \n        j = REASS_TABLE_SZ * iadev->memSize;\n\tfor(i=0; i < j; i++)  \n\t\t*reass_table++ = NO_AAL5_PKT;  \n       i = 8*1024;\n       vcsize_sel =  0;\n       while (i != iadev->num_vc) {\n          i /= 2;\n          vcsize_sel++;\n       }\n       i = RX_VC_TABLE * iadev->memSize;\n       writew(((i>>3) & 0xfff8) | vcsize_sel, iadev->reass_reg+VC_LKUP_BASE);\n       vc_table = (u16 *)(iadev->reass_ram+RX_VC_TABLE*iadev->memSize);  \n        j = RX_VC_TABLE_SZ * iadev->memSize;\n\tfor(i = 0; i < j; i++)  \n\t{  \n\t\t   \n\t\t*vc_table = (i << 6) | 15;\t   \n\t\tvc_table++;  \n\t}  \n         \n        i =  ABR_VC_TABLE * iadev->memSize;\n        writew(i >> 3, iadev->reass_reg+ABR_LKUP_BASE);\n                   \n        i = ABR_VC_TABLE * iadev->memSize;\n\tabr_vc_table = (struct abr_vc_table *)(iadev->reass_ram+i);  \n        j = REASS_TABLE_SZ * iadev->memSize;\n        memset ((char*)abr_vc_table, 0, j * sizeof(*abr_vc_table));\n    \tfor(i = 0; i < j; i++) {   \t\t\n\t\tabr_vc_table->rdf = 0x0003;\n             \tabr_vc_table->air = 0x5eb1;\n\t       \tabr_vc_table++;   \t\n        }  \n\n\t   \n  \n\t   \n\twritew(0xff00, iadev->reass_reg+VP_FILTER);  \n        writew(0, iadev->reass_reg+XTRA_RM_OFFSET);\n\twritew(0x1,  iadev->reass_reg+PROTOCOL_ID);\n\n\t   \n        writew(0xF6F8, iadev->reass_reg+PKT_TM_CNT );\n\n        i = (j >> 6) & 0xFF;\n        j += 2 * (j - 1);\n        i |= ((j << 2) & 0xFF00);\n        writew(i, iadev->reass_reg+TMOUT_RANGE);\n\n         \n        for(i=0; i<iadev->num_tx_desc;i++)\n            iadev->desc_tbl[i].timestamp = 0;\n\n\t   \n\treadw(iadev->reass_reg+REASS_INTR_STATUS_REG);   \n  \n\t   \n\twritew(~(RX_FREEQ_EMPT|RX_PKT_RCVD), iadev->reass_reg+REASS_MASK_REG);  \n  \n\tskb_queue_head_init(&iadev->rx_dma_q);  \n\tiadev->rx_free_desc_qhead = NULL;   \n\n\tiadev->rx_open = kcalloc(iadev->num_vc, sizeof(void *), GFP_KERNEL);\n\tif (!iadev->rx_open) {\n\t\tprintk(KERN_ERR DEV_LABEL \"itf %d couldn't get free page\\n\",\n\t\tdev->number);  \n\t\tgoto err_free_dle;\n\t}  \n\n        iadev->rxing = 1;\n        iadev->rx_pkt_cnt = 0;\n\t   \n\twritew(R_ONLINE, iadev->reass_reg+MODE_REG);  \n\treturn 0;  \n\nerr_free_dle:\n\tdma_free_coherent(&iadev->pci->dev, DLE_TOTAL_SIZE, iadev->rx_dle_q.start,\n\t\t\t  iadev->rx_dle_dma);\nerr_out:\n\treturn -ENOMEM;\n}  \n  \n\n   \n  \nstatic void tx_intr(struct atm_dev *dev)  \n{  \n\tIADEV *iadev;  \n\tunsigned short status;  \n        unsigned long flags;\n\n\tiadev = INPH_IA_DEV(dev);  \n  \n\tstatus = readl(iadev->seg_reg+SEG_INTR_STATUS_REG);  \n        if (status & TRANSMIT_DONE){\n\n           IF_EVENT(printk(\"Transmit Done Intr logic run\\n\");)\n           spin_lock_irqsave(&iadev->tx_lock, flags);\n           ia_tx_poll(iadev);\n           spin_unlock_irqrestore(&iadev->tx_lock, flags);\n           writew(TRANSMIT_DONE, iadev->seg_reg+SEG_INTR_STATUS_REG);\n           if (iadev->close_pending)  \n               wake_up(&iadev->close_wait);\n        }     \t  \n\tif (status & TCQ_NOT_EMPTY)  \n\t{  \n\t    IF_EVENT(printk(\"TCQ_NOT_EMPTY int received\\n\");)  \n\t}  \n}  \n  \nstatic void tx_dle_intr(struct atm_dev *dev)\n{\n        IADEV *iadev;\n        struct dle *dle, *cur_dle; \n        struct sk_buff *skb;\n        struct atm_vcc *vcc;\n        struct ia_vcc  *iavcc;\n        u_int dle_lp;\n        unsigned long flags;\n\n        iadev = INPH_IA_DEV(dev);\n        spin_lock_irqsave(&iadev->tx_lock, flags);   \n        dle = iadev->tx_dle_q.read;\n        dle_lp = readl(iadev->dma+IPHASE5575_TX_LIST_ADDR) & \n                                        (sizeof(struct dle)*DLE_ENTRIES - 1);\n        cur_dle = (struct dle*)(iadev->tx_dle_q.start + (dle_lp >> 4));\n        while (dle != cur_dle)\n        {\n              \n            skb = skb_dequeue(&iadev->tx_dma_q); \n            if (!skb) break;\n\n\t     \n\t    if (!((dle - iadev->tx_dle_q.start)%(2*sizeof(struct dle)))) {\n\t\tdma_unmap_single(&iadev->pci->dev, dle->sys_pkt_addr, skb->len,\n\t\t\t\t DMA_TO_DEVICE);\n\t    }\n            vcc = ATM_SKB(skb)->vcc;\n            if (!vcc) {\n                  printk(\"tx_dle_intr: vcc is null\\n\");\n\t\t  spin_unlock_irqrestore(&iadev->tx_lock, flags);\n                  dev_kfree_skb_any(skb);\n\n                  return;\n            }\n            iavcc = INPH_IA_VCC(vcc);\n            if (!iavcc) {\n                  printk(\"tx_dle_intr: iavcc is null\\n\");\n\t\t  spin_unlock_irqrestore(&iadev->tx_lock, flags);\n                  dev_kfree_skb_any(skb);\n                  return;\n            }\n            if (vcc->qos.txtp.pcr >= iadev->rate_limit) {\n               if ((vcc->pop) && (skb->len != 0))\n               {     \n                 vcc->pop(vcc, skb);\n               } \n               else {\n                 dev_kfree_skb_any(skb);\n               }\n            }\n            else {  \n               IA_SKB_STATE(skb) |= IA_DLED;\n               skb_queue_tail(&iavcc->txing_skb, skb);\n            }\n            IF_EVENT(printk(\"tx_dle_intr: enque skb = 0x%p \\n\", skb);)\n            if (++dle == iadev->tx_dle_q.end)\n                 dle = iadev->tx_dle_q.start;\n        }\n        iadev->tx_dle_q.read = dle;\n        spin_unlock_irqrestore(&iadev->tx_lock, flags);\n}\n  \nstatic int open_tx(struct atm_vcc *vcc)  \n{  \n\tstruct ia_vcc *ia_vcc;  \n\tIADEV *iadev;  \n\tstruct main_vc *vc;  \n\tstruct ext_vc *evc;  \n        int ret;\n\tIF_EVENT(printk(\"iadev: open_tx entered vcc->vci = %d\\n\", vcc->vci);)  \n\tif (vcc->qos.txtp.traffic_class == ATM_NONE) return 0;  \n\tiadev = INPH_IA_DEV(vcc->dev);  \n        \n        if (iadev->phy_type & FE_25MBIT_PHY) {\n           if (vcc->qos.txtp.traffic_class == ATM_ABR) {\n               printk(\"IA:  ABR not support\\n\");\n               return -EINVAL; \n           }\n\t  if (vcc->qos.txtp.traffic_class == ATM_CBR) {\n               printk(\"IA:  CBR not support\\n\");\n               return -EINVAL; \n          }\n        }\n        ia_vcc =  INPH_IA_VCC(vcc);\n        memset((caddr_t)ia_vcc, 0, sizeof(*ia_vcc));\n        if (vcc->qos.txtp.max_sdu > \n                         (iadev->tx_buf_sz - sizeof(struct cpcs_trailer))){\n           printk(\"IA:  SDU size over (%d) the configured SDU size %d\\n\",\n\t\t  vcc->qos.txtp.max_sdu,iadev->tx_buf_sz);\n\t   vcc->dev_data = NULL;\n           kfree(ia_vcc);\n           return -EINVAL; \n        }\n\tia_vcc->vc_desc_cnt = 0;\n        ia_vcc->txing = 1;\n\n         \n        if (vcc->qos.txtp.max_pcr == ATM_MAX_PCR) \n           vcc->qos.txtp.pcr = iadev->LineRate;\n        else if ((vcc->qos.txtp.max_pcr == 0)&&( vcc->qos.txtp.pcr <= 0))\n           vcc->qos.txtp.pcr = iadev->LineRate;\n        else if ((vcc->qos.txtp.max_pcr > vcc->qos.txtp.pcr) && (vcc->qos.txtp.max_pcr> 0)) \n           vcc->qos.txtp.pcr = vcc->qos.txtp.max_pcr;\n        if (vcc->qos.txtp.pcr > iadev->LineRate)\n             vcc->qos.txtp.pcr = iadev->LineRate;\n        ia_vcc->pcr = vcc->qos.txtp.pcr;\n\n        if (ia_vcc->pcr > (iadev->LineRate / 6) ) ia_vcc->ltimeout = HZ / 10;\n        else if (ia_vcc->pcr > (iadev->LineRate / 130)) ia_vcc->ltimeout = HZ;\n        else if (ia_vcc->pcr <= 170) ia_vcc->ltimeout = 16 * HZ;\n        else ia_vcc->ltimeout = 2700 * HZ  / ia_vcc->pcr;\n        if (ia_vcc->pcr < iadev->rate_limit)\n           skb_queue_head_init (&ia_vcc->txing_skb);\n        if (ia_vcc->pcr < iadev->rate_limit) {\n\t   struct sock *sk = sk_atm(vcc);\n\n\t   if (vcc->qos.txtp.max_sdu != 0) {\n               if (ia_vcc->pcr > 60000)\n                  sk->sk_sndbuf = vcc->qos.txtp.max_sdu * 5;\n               else if (ia_vcc->pcr > 2000)\n                  sk->sk_sndbuf = vcc->qos.txtp.max_sdu * 4;\n               else\n                 sk->sk_sndbuf = vcc->qos.txtp.max_sdu * 3;\n           }\n           else\n             sk->sk_sndbuf = 24576;\n        }\n           \n\tvc = (struct main_vc *)iadev->MAIN_VC_TABLE_ADDR;  \n\tevc = (struct ext_vc *)iadev->EXT_VC_TABLE_ADDR;  \n\tvc += vcc->vci;  \n\tevc += vcc->vci;  \n\tmemset((caddr_t)vc, 0, sizeof(*vc));  \n\tmemset((caddr_t)evc, 0, sizeof(*evc));  \n\t  \n\t   \n\tevc->atm_hdr1 = (vcc->vci >> 12) & 0x000f;  \n\tevc->atm_hdr2 = (vcc->vci & 0x0fff) << 4;  \n \n\t   \n\tif (vcc->qos.txtp.traffic_class == ATM_UBR)  \n\t{  \n\t\tvc->type = UBR;  \n                vc->status = CRC_APPEND;\n\t\tvc->acr = cellrate_to_float(iadev->LineRate);  \n                if (vcc->qos.txtp.pcr > 0) \n                   vc->acr = cellrate_to_float(vcc->qos.txtp.pcr);  \n                IF_UBR(printk(\"UBR: txtp.pcr = 0x%x f_rate = 0x%x\\n\", \n                                             vcc->qos.txtp.max_pcr,vc->acr);)\n\t}  \n\telse if (vcc->qos.txtp.traffic_class == ATM_ABR)  \n\t{       srv_cls_param_t srv_p;\n\t\tIF_ABR(printk(\"Tx ABR VCC\\n\");)  \n                init_abr_vc(iadev, &srv_p);\n                if (vcc->qos.txtp.pcr > 0) \n                   srv_p.pcr = vcc->qos.txtp.pcr;\n                if (vcc->qos.txtp.min_pcr > 0) {\n                   int tmpsum = iadev->sum_mcr+iadev->sum_cbr+vcc->qos.txtp.min_pcr;\n                   if (tmpsum > iadev->LineRate)\n                       return -EBUSY;\n                   srv_p.mcr = vcc->qos.txtp.min_pcr;\n                   iadev->sum_mcr += vcc->qos.txtp.min_pcr;\n                } \n                else srv_p.mcr = 0;\n                if (vcc->qos.txtp.icr)\n                   srv_p.icr = vcc->qos.txtp.icr;\n                if (vcc->qos.txtp.tbe)\n                   srv_p.tbe = vcc->qos.txtp.tbe;\n                if (vcc->qos.txtp.frtt)\n                   srv_p.frtt = vcc->qos.txtp.frtt;\n                if (vcc->qos.txtp.rif)\n                   srv_p.rif = vcc->qos.txtp.rif;\n                if (vcc->qos.txtp.rdf)\n                   srv_p.rdf = vcc->qos.txtp.rdf;\n                if (vcc->qos.txtp.nrm_pres)\n                   srv_p.nrm = vcc->qos.txtp.nrm;\n                if (vcc->qos.txtp.trm_pres)\n                   srv_p.trm = vcc->qos.txtp.trm;\n                if (vcc->qos.txtp.adtf_pres)\n                   srv_p.adtf = vcc->qos.txtp.adtf;\n                if (vcc->qos.txtp.cdf_pres)\n                   srv_p.cdf = vcc->qos.txtp.cdf;    \n                if (srv_p.icr > srv_p.pcr)\n                   srv_p.icr = srv_p.pcr;    \n                IF_ABR(printk(\"ABR:vcc->qos.txtp.max_pcr = %d  mcr = %d\\n\", \n                                                      srv_p.pcr, srv_p.mcr);)\n\t\tia_open_abr_vc(iadev, &srv_p, vcc, 1);\n\t} else if (vcc->qos.txtp.traffic_class == ATM_CBR) {\n                if (iadev->phy_type & FE_25MBIT_PHY) {\n                    printk(\"IA:  CBR not support\\n\");\n                    return -EINVAL; \n                }\n                if (vcc->qos.txtp.max_pcr > iadev->LineRate) {\n                   IF_CBR(printk(\"PCR is not available\\n\");)\n                   return -1;\n                }\n                vc->type = CBR;\n                vc->status = CRC_APPEND;\n                if ((ret = ia_cbr_setup (iadev, vcc)) < 0) {     \n                    return ret;\n                }\n\t} else {\n\t\tprintk(\"iadev:  Non UBR, ABR and CBR traffic not supported\\n\");\n\t}\n        \n        iadev->testTable[vcc->vci]->vc_status |= VC_ACTIVE;\n\tIF_EVENT(printk(\"ia open_tx returning \\n\");)  \n\treturn 0;  \n}  \n  \n  \nstatic int tx_init(struct atm_dev *dev)  \n{  \n\tIADEV *iadev;  \n\tstruct tx_buf_desc *buf_desc_ptr;\n\tunsigned int tx_pkt_start;  \n\tvoid *dle_addr;  \n\tint i;  \n\tu_short tcq_st_adr;  \n\tu_short *tcq_start;  \n\tu_short prq_st_adr;  \n\tu_short *prq_start;  \n\tstruct main_vc *vc;  \n\tstruct ext_vc *evc;   \n        u_short tmp16;\n        u32 vcsize_sel;\n \n\tiadev = INPH_IA_DEV(dev);  \n        spin_lock_init(&iadev->tx_lock);\n \n\tIF_INIT(printk(\"Tx MASK REG: 0x%0x\\n\", \n                                readw(iadev->seg_reg+SEG_MASK_REG));)  \n\n\t \n\tdle_addr = dma_alloc_coherent(&iadev->pci->dev, DLE_TOTAL_SIZE,\n\t\t\t\t      &iadev->tx_dle_dma, GFP_KERNEL);\n\tif (!dle_addr)  {\n\t\tprintk(KERN_ERR DEV_LABEL \"can't allocate DLEs\\n\");\n\t\tgoto err_out;\n\t}\n\tiadev->tx_dle_q.start = (struct dle*)dle_addr;  \n\tiadev->tx_dle_q.read = iadev->tx_dle_q.start;  \n\tiadev->tx_dle_q.write = iadev->tx_dle_q.start;  \n\tiadev->tx_dle_q.end = (struct dle*)((unsigned long)dle_addr+sizeof(struct dle)*DLE_ENTRIES);\n\n\t   \n\twritel(iadev->tx_dle_dma & 0xfffff000,\n\t       iadev->dma + IPHASE5575_TX_LIST_ADDR);  \n\twritew(0xffff, iadev->seg_reg+SEG_MASK_REG);  \n\twritew(0, iadev->seg_reg+MODE_REG_0);  \n\twritew(RESET_SEG, iadev->seg_reg+SEG_COMMAND_REG);  \n        iadev->MAIN_VC_TABLE_ADDR = iadev->seg_ram+MAIN_VC_TABLE*iadev->memSize;\n        iadev->EXT_VC_TABLE_ADDR = iadev->seg_ram+EXT_VC_TABLE*iadev->memSize;\n        iadev->ABR_SCHED_TABLE_ADDR=iadev->seg_ram+ABR_SCHED_TABLE*iadev->memSize;\n  \n\t   \n     \n\t   \n\twritew(TX_DESC_BASE, iadev->seg_reg+SEG_DESC_BASE);  \n  \n\t   \n\tbuf_desc_ptr =(struct tx_buf_desc *)(iadev->seg_ram+TX_DESC_BASE);  \n\tmemset((caddr_t)buf_desc_ptr, 0, sizeof(*buf_desc_ptr));  \n\tbuf_desc_ptr++;  \n\ttx_pkt_start = TX_PACKET_RAM;  \n\tfor(i=1; i<=iadev->num_tx_desc; i++)  \n\t{  \n\t\tmemset((caddr_t)buf_desc_ptr, 0, sizeof(*buf_desc_ptr));  \n\t\tbuf_desc_ptr->desc_mode = AAL5;  \n\t\tbuf_desc_ptr->buf_start_hi = tx_pkt_start >> 16;  \n\t\tbuf_desc_ptr->buf_start_lo = tx_pkt_start & 0x0000ffff;  \n\t\tbuf_desc_ptr++;\t\t  \n\t\ttx_pkt_start += iadev->tx_buf_sz;  \n\t}  \n\tiadev->tx_buf = kmalloc_array(iadev->num_tx_desc,\n\t\t\t\t      sizeof(*iadev->tx_buf),\n\t\t\t\t      GFP_KERNEL);\n        if (!iadev->tx_buf) {\n            printk(KERN_ERR DEV_LABEL \" couldn't get mem\\n\");\n\t    goto err_free_dle;\n        }\n       \tfor (i= 0; i< iadev->num_tx_desc; i++)\n       \t{\n\t    struct cpcs_trailer *cpcs;\n \n       \t    cpcs = kmalloc(sizeof(*cpcs), GFP_KERNEL|GFP_DMA);\n            if(!cpcs) {                \n\t\tprintk(KERN_ERR DEV_LABEL \" couldn't get freepage\\n\"); \n\t\tgoto err_free_tx_bufs;\n            }\n\t    iadev->tx_buf[i].cpcs = cpcs;\n\t    iadev->tx_buf[i].dma_addr = dma_map_single(&iadev->pci->dev,\n\t\t\t\t\t\t       cpcs,\n\t\t\t\t\t\t       sizeof(*cpcs),\n\t\t\t\t\t\t       DMA_TO_DEVICE);\n        }\n\tiadev->desc_tbl = kmalloc_array(iadev->num_tx_desc,\n\t\t\t\t\tsizeof(*iadev->desc_tbl),\n\t\t\t\t\tGFP_KERNEL);\n\tif (!iadev->desc_tbl) {\n\t\tprintk(KERN_ERR DEV_LABEL \" couldn't get mem\\n\");\n\t\tgoto err_free_all_tx_bufs;\n\t}\n  \n\t   \n        i = TX_COMP_Q * iadev->memSize;\n\twritew(i >> 16, iadev->seg_reg+SEG_QUEUE_BASE);  \n  \n\t   \n\twritew(i, iadev->seg_reg+TCQ_ST_ADR);  \n\twritew(i, iadev->seg_reg+TCQ_RD_PTR);  \n\twritew(i+iadev->num_tx_desc*sizeof(u_short),iadev->seg_reg+TCQ_WR_PTR); \n\tiadev->host_tcq_wr = i + iadev->num_tx_desc*sizeof(u_short);\n        writew(i+2 * iadev->num_tx_desc * sizeof(u_short), \n                                              iadev->seg_reg+TCQ_ED_ADR); \n\t   \n\ttcq_st_adr = readw(iadev->seg_reg+TCQ_ST_ADR);  \n\ttcq_start = (u_short *)(iadev->seg_ram+tcq_st_adr);  \n\tfor(i=1; i<=iadev->num_tx_desc; i++)  \n\t{  \n\t\t*tcq_start = (u_short)i;  \n\t\ttcq_start++;  \n\t}  \n  \n\t   \n        i = PKT_RDY_Q * iadev->memSize; \n\twritew(i, iadev->seg_reg+PRQ_ST_ADR);  \n\twritew(i+2 * iadev->num_tx_desc * sizeof(u_short), \n                                              iadev->seg_reg+PRQ_ED_ADR);\n\twritew(i, iadev->seg_reg+PRQ_RD_PTR);  \n\twritew(i, iadev->seg_reg+PRQ_WR_PTR);  \n\t \n         \n        iadev->ffL.prq_st = readw(iadev->seg_reg+PRQ_ST_ADR) & 0xffff;\n\tiadev->ffL.prq_ed = readw(iadev->seg_reg+PRQ_ED_ADR) & 0xffff;\n \tiadev->ffL.prq_wr = readw(iadev->seg_reg+PRQ_WR_PTR) & 0xffff;\n\n\tiadev->ffL.tcq_st = readw(iadev->seg_reg+TCQ_ST_ADR) & 0xffff;\n\tiadev->ffL.tcq_ed = readw(iadev->seg_reg+TCQ_ED_ADR) & 0xffff;\n\tiadev->ffL.tcq_rd = readw(iadev->seg_reg+TCQ_RD_PTR) & 0xffff;\n\n\t   \n\t   \n\tprq_st_adr = readw(iadev->seg_reg+PRQ_ST_ADR);  \n\tprq_start = (u_short *)(iadev->seg_ram+prq_st_adr);  \n\tfor(i=1; i<=iadev->num_tx_desc; i++)  \n\t{  \n\t\t*prq_start = (u_short)0;\t   \n\t\tprq_start++;  \n\t}  \n\t   \n        IF_INIT(printk(\"Start CBR Init\\n\");)\n#if 1   \n        writew(0,iadev->seg_reg+CBR_PTR_BASE);\n#else  \n        tmp16 = (iadev->seg_ram+CBR_SCHED_TABLE*iadev->memSize)>>17;\n        IF_INIT(printk(\"cbr_ptr_base = 0x%x \", tmp16);)\n        writew(tmp16,iadev->seg_reg+CBR_PTR_BASE);\n#endif\n\n        IF_INIT(printk(\"value in register = 0x%x\\n\",\n                                   readw(iadev->seg_reg+CBR_PTR_BASE));)\n        tmp16 = (CBR_SCHED_TABLE*iadev->memSize) >> 1;\n        writew(tmp16, iadev->seg_reg+CBR_TAB_BEG);\n        IF_INIT(printk(\"cbr_tab_beg = 0x%x in reg = 0x%x \\n\", tmp16,\n                                        readw(iadev->seg_reg+CBR_TAB_BEG));)\n        writew(tmp16, iadev->seg_reg+CBR_TAB_END+1);  \n        tmp16 = (CBR_SCHED_TABLE*iadev->memSize + iadev->num_vc*6 - 2) >> 1;\n        writew(tmp16, iadev->seg_reg+CBR_TAB_END);\n        IF_INIT(printk(\"iadev->seg_reg = 0x%p CBR_PTR_BASE = 0x%x\\n\",\n               iadev->seg_reg, readw(iadev->seg_reg+CBR_PTR_BASE));)\n        IF_INIT(printk(\"CBR_TAB_BEG = 0x%x, CBR_TAB_END = 0x%x, CBR_PTR = 0x%x\\n\",\n          readw(iadev->seg_reg+CBR_TAB_BEG), readw(iadev->seg_reg+CBR_TAB_END),\n          readw(iadev->seg_reg+CBR_TAB_END+1));)\n\n         \n        memset_io(iadev->seg_ram+CBR_SCHED_TABLE*iadev->memSize, \n                                                          0, iadev->num_vc*6); \n        iadev->CbrRemEntries = iadev->CbrTotEntries = iadev->num_vc*3;\n        iadev->CbrEntryPt = 0;\n        iadev->Granularity = MAX_ATM_155 / iadev->CbrTotEntries;\n        iadev->NumEnabledCBR = 0;\n\n\t   \n\t   \n        \n        vcsize_sel = 0;\n        i = 8*1024;\n        while (i != iadev->num_vc) {\n          i /= 2;\n          vcsize_sel++;\n        }\n \n        i = MAIN_VC_TABLE * iadev->memSize;\n        writew(vcsize_sel | ((i >> 8) & 0xfff8),iadev->seg_reg+VCT_BASE);\n        i =  EXT_VC_TABLE * iadev->memSize;\n        writew((i >> 8) & 0xfffe, iadev->seg_reg+VCTE_BASE);\n        i = UBR_SCHED_TABLE * iadev->memSize;\n        writew((i & 0xffff) >> 11,  iadev->seg_reg+UBR_SBPTR_BASE);\n        i = UBR_WAIT_Q * iadev->memSize; \n        writew((i >> 7) & 0xffff,  iadev->seg_reg+UBRWQ_BASE);\n \tmemset((caddr_t)(iadev->seg_ram+UBR_SCHED_TABLE*iadev->memSize),\n                                                       0, iadev->num_vc*8);\n\t   \n\t   \n        i = ABR_SCHED_TABLE * iadev->memSize;\n        writew((i >> 11) & 0xffff, iadev->seg_reg+ABR_SBPTR_BASE);\n        i = ABR_WAIT_Q * iadev->memSize;\n        writew((i >> 7) & 0xffff, iadev->seg_reg+ABRWQ_BASE);\n \n        i = ABR_SCHED_TABLE*iadev->memSize;\n\tmemset((caddr_t)(iadev->seg_ram+i),  0, iadev->num_vc*4);\n\tvc = (struct main_vc *)iadev->MAIN_VC_TABLE_ADDR;  \n\tevc = (struct ext_vc *)iadev->EXT_VC_TABLE_ADDR;  \n\tiadev->testTable = kmalloc_array(iadev->num_vc,\n\t\t\t\t\t sizeof(*iadev->testTable),\n\t\t\t\t\t GFP_KERNEL);\n        if (!iadev->testTable) {\n           printk(\"Get freepage  failed\\n\");\n\t   goto err_free_desc_tbl;\n        }\n\tfor(i=0; i<iadev->num_vc; i++)  \n\t{  \n\t\tmemset((caddr_t)vc, 0, sizeof(*vc));  \n\t\tmemset((caddr_t)evc, 0, sizeof(*evc));  \n                iadev->testTable[i] = kmalloc(sizeof(struct testTable_t),\n\t\t\t\t\t\tGFP_KERNEL);\n\t\tif (!iadev->testTable[i])\n\t\t\tgoto err_free_test_tables;\n              \tiadev->testTable[i]->lastTime = 0;\n \t\tiadev->testTable[i]->fract = 0;\n                iadev->testTable[i]->vc_status = VC_UBR;\n\t\tvc++;  \n\t\tevc++;  \n\t}  \n  \n\t   \n\t  \n\t   \n        if (iadev->phy_type & FE_25MBIT_PHY) {\n\t   writew(RATE25, iadev->seg_reg+MAXRATE);  \n\t   writew((UBR_EN | (0x23 << 2)), iadev->seg_reg+STPARMS);  \n        }\n        else {\n\t   writew(cellrate_to_float(iadev->LineRate),iadev->seg_reg+MAXRATE);\n\t   writew((UBR_EN | ABR_EN | (0x23 << 2)), iadev->seg_reg+STPARMS);  \n        }\n\t   \n\twritew(0, iadev->seg_reg+IDLEHEADHI);  \n\twritew(0, iadev->seg_reg+IDLEHEADLO);  \n  \n\t \n        writew(0xaa00, iadev->seg_reg+ABRUBR_ARB); \n\n        iadev->close_pending = 0;\n        init_waitqueue_head(&iadev->close_wait);\n        init_waitqueue_head(&iadev->timeout_wait);\n\tskb_queue_head_init(&iadev->tx_dma_q);  \n\tia_init_rtn_q(&iadev->tx_return_q);  \n\n\t   \n\twritew(RM_TYPE_4_0, iadev->seg_reg+RM_TYPE);  \n        skb_queue_head_init (&iadev->tx_backlog);\n  \n\t   \n\twritew(MODE_REG_1_VAL, iadev->seg_reg+MODE_REG_1);  \n  \n\t   \n\twritew(T_ONLINE, iadev->seg_reg+MODE_REG_0);  \n  \n\t   \n\treadw(iadev->seg_reg+SEG_INTR_STATUS_REG);  \n  \n\t   \n        writew(~(TRANSMIT_DONE | TCQ_NOT_EMPTY), iadev->seg_reg+SEG_MASK_REG);\n        writew(TRANSMIT_DONE, iadev->seg_reg+SEG_INTR_STATUS_REG);  \n        iadev->tx_pkt_cnt = 0;\n        iadev->rate_limit = iadev->LineRate / 3;\n  \n\treturn 0;\n\nerr_free_test_tables:\n\twhile (--i >= 0)\n\t\tkfree(iadev->testTable[i]);\n\tkfree(iadev->testTable);\nerr_free_desc_tbl:\n\tkfree(iadev->desc_tbl);\nerr_free_all_tx_bufs:\n\ti = iadev->num_tx_desc;\nerr_free_tx_bufs:\n\twhile (--i >= 0) {\n\t\tstruct cpcs_trailer_desc *desc = iadev->tx_buf + i;\n\n\t\tdma_unmap_single(&iadev->pci->dev, desc->dma_addr,\n\t\t\t\t sizeof(*desc->cpcs), DMA_TO_DEVICE);\n\t\tkfree(desc->cpcs);\n\t}\n\tkfree(iadev->tx_buf);\nerr_free_dle:\n\tdma_free_coherent(&iadev->pci->dev, DLE_TOTAL_SIZE, iadev->tx_dle_q.start,\n\t\t\t  iadev->tx_dle_dma);\nerr_out:\n\treturn -ENOMEM;\n}   \n   \nstatic irqreturn_t ia_int(int irq, void *dev_id)  \n{  \n   struct atm_dev *dev;  \n   IADEV *iadev;  \n   unsigned int status;  \n   int handled = 0;\n\n   dev = dev_id;  \n   iadev = INPH_IA_DEV(dev);  \n   while( (status = readl(iadev->reg+IPHASE5575_BUS_STATUS_REG) & 0x7f))  \n   { \n\thandled = 1;\n        IF_EVENT(printk(\"ia_int: status = 0x%x\\n\", status);) \n\tif (status & STAT_REASSINT)  \n\t{  \n\t      \n\t   IF_EVENT(printk(\"REASSINT Bus status reg: %08x\\n\", status);) \n\t   rx_intr(dev);  \n\t}  \n\tif (status & STAT_DLERINT)  \n\t{  \n\t      \n\t   writel(STAT_DLERINT, iadev->reg + IPHASE5575_BUS_STATUS_REG);\n\t   rx_dle_intr(dev);  \n\t}  \n\tif (status & STAT_SEGINT)  \n\t{  \n\t     \n           IF_EVENT(printk(\"IA: tx_intr \\n\");) \n\t   tx_intr(dev);  \n\t}  \n\tif (status & STAT_DLETINT)  \n\t{  \n\t   writel(STAT_DLETINT, iadev->reg + IPHASE5575_BUS_STATUS_REG);\n\t   tx_dle_intr(dev);  \n\t}  \n\tif (status & (STAT_FEINT | STAT_ERRINT | STAT_MARKINT))  \n\t{  \n           if (status & STAT_FEINT) \n               ia_frontend_intr(iadev);\n\t}  \n   }\n   return IRQ_RETVAL(handled);\n}  \n\t  \n\t  \n\t  \n   \nstatic int get_esi(struct atm_dev *dev)  \n{  \n\tIADEV *iadev;  \n\tint i;  \n\tu32 mac1;  \n\tu16 mac2;  \n\t  \n\tiadev = INPH_IA_DEV(dev);  \n\tmac1 = cpu_to_be32(le32_to_cpu(readl(  \n\t\t\t\tiadev->reg+IPHASE5575_MAC1)));  \n\tmac2 = cpu_to_be16(le16_to_cpu(readl(iadev->reg+IPHASE5575_MAC2)));  \n\tIF_INIT(printk(\"ESI: 0x%08x%04x\\n\", mac1, mac2);)  \n\tfor (i=0; i<MAC1_LEN; i++)  \n\t\tdev->esi[i] = mac1 >>(8*(MAC1_LEN-1-i));  \n\t  \n\tfor (i=0; i<MAC2_LEN; i++)  \n\t\tdev->esi[i+MAC1_LEN] = mac2 >>(8*(MAC2_LEN - 1 -i));  \n\treturn 0;  \n}  \n\t  \nstatic int reset_sar(struct atm_dev *dev)  \n{  \n\tIADEV *iadev;  \n\tint i, error;\n\tunsigned int pci[64];  \n\t  \n\tiadev = INPH_IA_DEV(dev);  \n\tfor (i = 0; i < 64; i++) {\n\t\terror = pci_read_config_dword(iadev->pci, i * 4, &pci[i]);\n\t\tif (error != PCIBIOS_SUCCESSFUL)\n\t\t\treturn error;\n\t}\n\twritel(0, iadev->reg+IPHASE5575_EXT_RESET);  \n\tfor (i = 0; i < 64; i++) {\n\t\terror = pci_write_config_dword(iadev->pci, i * 4, pci[i]);\n\t\tif (error != PCIBIOS_SUCCESSFUL)\n\t\t\treturn error;\n\t}\n\tudelay(5);  \n\treturn 0;  \n}  \n\t  \n\t  \nstatic int ia_init(struct atm_dev *dev)\n{  \n\tIADEV *iadev;  \n\tunsigned long real_base;\n\tvoid __iomem *base;\n\tunsigned short command;  \n\tint error, i; \n\t  \n\t   \n\t  \n\tIF_INIT(printk(\">ia_init\\n\");)  \n\tdev->ci_range.vpi_bits = 0;  \n\tdev->ci_range.vci_bits = NR_VCI_LD;  \n\n\tiadev = INPH_IA_DEV(dev);  \n\treal_base = pci_resource_start (iadev->pci, 0);\n\tiadev->irq = iadev->pci->irq;\n\t\t  \n\terror = pci_read_config_word(iadev->pci, PCI_COMMAND, &command);\n\tif (error) {\n\t\tprintk(KERN_ERR DEV_LABEL \"(itf %d): init error 0x%x\\n\",  \n\t\t\t\tdev->number,error);  \n\t\treturn -EINVAL;  \n\t}  \n\tIF_INIT(printk(DEV_LABEL \"(itf %d): rev.%d,realbase=0x%lx,irq=%d\\n\",  \n\t\t\tdev->number, iadev->pci->revision, real_base, iadev->irq);)\n\t  \n\t   \n\t  \n\tiadev->pci_map_size = pci_resource_len(iadev->pci, 0);\n\n        if (iadev->pci_map_size == 0x100000){\n          iadev->num_vc = 4096;\n\t  dev->ci_range.vci_bits = NR_VCI_4K_LD;  \n          iadev->memSize = 4;\n        }\n        else if (iadev->pci_map_size == 0x40000) {\n          iadev->num_vc = 1024;\n          iadev->memSize = 1;\n        }\n        else {\n           printk(\"Unknown pci_map_size = 0x%x\\n\", iadev->pci_map_size);\n           return -EINVAL;\n        }\n\tIF_INIT(printk (DEV_LABEL \"map size: %i\\n\", iadev->pci_map_size);)  \n\t  \n\t \n\tpci_set_master(iadev->pci);\n\n\t   \n\tudelay(10);  \n\t  \n\t   \n\tbase = ioremap(real_base,iadev->pci_map_size);     \n\t  \n\tif (!base)  \n\t{  \n\t\tprintk(DEV_LABEL \" (itf %d): can't set up page mapping\\n\",  \n\t\t\t    dev->number);  \n\t\treturn -ENOMEM;\n\t}  \n\tIF_INIT(printk(DEV_LABEL \" (itf %d): rev.%d,base=%p,irq=%d\\n\",  \n\t\t\tdev->number, iadev->pci->revision, base, iadev->irq);)\n\t  \n\t   \n\tiadev->mem = iadev->pci_map_size /2;  \n\tiadev->real_base = real_base;  \n\tiadev->base = base;  \n\t\t  \n\t   \n\tiadev->reg = base + REG_BASE;\n\t   \n\tiadev->seg_reg = base + SEG_BASE;\n\t   \n\tiadev->reass_reg = base + REASS_BASE;  \n\t   \n\tiadev->phy = base + PHY_BASE;  \n\tiadev->dma = base + PHY_BASE;  \n\t   \n\tiadev->ram = base + ACTUAL_RAM_BASE;  \n\tiadev->seg_ram = base + ACTUAL_SEG_RAM_BASE;  \n\tiadev->reass_ram = base + ACTUAL_REASS_RAM_BASE;  \n  \n\t   \n\tIF_INIT(printk(\"Base addrs: %p %p %p \\n %p %p %p %p\\n\", \n          iadev->reg,iadev->seg_reg,iadev->reass_reg, \n          iadev->phy, iadev->ram, iadev->seg_ram, \n          iadev->reass_ram);) \n\t  \n\t   \n\terror = get_esi(dev);  \n\tif (error) {\n\t  iounmap(iadev->base);\n\t  return error;  \n\t}\n        printk(\"IA: \");\n\tfor (i=0; i < ESI_LEN; i++)  \n                printk(\"%s%02X\",i ? \"-\" : \"\",dev->esi[i]);  \n        printk(\"\\n\");  \n  \n           \n        if (reset_sar(dev)) {\n\t   iounmap(iadev->base);\n           printk(\"IA: reset SAR fail, please try again\\n\");\n           return 1;\n        }\n\treturn 0;  \n}  \n\nstatic void ia_update_stats(IADEV *iadev) {\n    if (!iadev->carrier_detect)\n        return;\n    iadev->rx_cell_cnt += readw(iadev->reass_reg+CELL_CTR0)&0xffff;\n    iadev->rx_cell_cnt += (readw(iadev->reass_reg+CELL_CTR1) & 0xffff) << 16;\n    iadev->drop_rxpkt +=  readw(iadev->reass_reg + DRP_PKT_CNTR ) & 0xffff;\n    iadev->drop_rxcell += readw(iadev->reass_reg + ERR_CNTR) & 0xffff;\n    iadev->tx_cell_cnt += readw(iadev->seg_reg + CELL_CTR_LO_AUTO)&0xffff;\n    iadev->tx_cell_cnt += (readw(iadev->seg_reg+CELL_CTR_HIGH_AUTO)&0xffff)<<16;\n    return;\n}\n  \nstatic void ia_led_timer(struct timer_list *unused) {\n \tunsigned long flags;\n  \tstatic u_char blinking[8] = {0, 0, 0, 0, 0, 0, 0, 0};\n        u_char i;\n        static u32 ctrl_reg; \n        for (i = 0; i < iadev_count; i++) {\n           if (ia_dev[i]) {\n\t      ctrl_reg = readl(ia_dev[i]->reg+IPHASE5575_BUS_CONTROL_REG);\n\t      if (blinking[i] == 0) {\n\t\t blinking[i]++;\n                 ctrl_reg &= (~CTRL_LED);\n                 writel(ctrl_reg, ia_dev[i]->reg+IPHASE5575_BUS_CONTROL_REG);\n                 ia_update_stats(ia_dev[i]);\n              }\n              else {\n\t\t blinking[i] = 0;\n\t\t ctrl_reg |= CTRL_LED;\n                 writel(ctrl_reg, ia_dev[i]->reg+IPHASE5575_BUS_CONTROL_REG);\n                 spin_lock_irqsave(&ia_dev[i]->tx_lock, flags);\n                 if (ia_dev[i]->close_pending)  \n                    wake_up(&ia_dev[i]->close_wait);\n                 ia_tx_poll(ia_dev[i]);\n                 spin_unlock_irqrestore(&ia_dev[i]->tx_lock, flags);\n              }\n           }\n        }\n\tmod_timer(&ia_timer, jiffies + HZ / 4);\n \treturn;\n}\n\nstatic void ia_phy_put(struct atm_dev *dev, unsigned char value,   \n\tunsigned long addr)  \n{  \n\twritel(value, INPH_IA_DEV(dev)->phy+addr);  \n}  \n  \nstatic unsigned char ia_phy_get(struct atm_dev *dev, unsigned long addr)  \n{  \n\treturn readl(INPH_IA_DEV(dev)->phy+addr);  \n}  \n\nstatic void ia_free_tx(IADEV *iadev)\n{\n\tint i;\n\n\tkfree(iadev->desc_tbl);\n\tfor (i = 0; i < iadev->num_vc; i++)\n\t\tkfree(iadev->testTable[i]);\n\tkfree(iadev->testTable);\n\tfor (i = 0; i < iadev->num_tx_desc; i++) {\n\t\tstruct cpcs_trailer_desc *desc = iadev->tx_buf + i;\n\n\t\tdma_unmap_single(&iadev->pci->dev, desc->dma_addr,\n\t\t\t\t sizeof(*desc->cpcs), DMA_TO_DEVICE);\n\t\tkfree(desc->cpcs);\n\t}\n\tkfree(iadev->tx_buf);\n\tdma_free_coherent(&iadev->pci->dev, DLE_TOTAL_SIZE, iadev->tx_dle_q.start,\n\t\t\t  iadev->tx_dle_dma);\n}\n\nstatic void ia_free_rx(IADEV *iadev)\n{\n\tkfree(iadev->rx_open);\n\tdma_free_coherent(&iadev->pci->dev, DLE_TOTAL_SIZE, iadev->rx_dle_q.start,\n\t\t\t  iadev->rx_dle_dma);\n}\n\nstatic int ia_start(struct atm_dev *dev)\n{  \n\tIADEV *iadev;  \n\tint error;  \n\tunsigned char phy;  \n\tu32 ctrl_reg;  \n\tIF_EVENT(printk(\">ia_start\\n\");)  \n\tiadev = INPH_IA_DEV(dev);  \n        if (request_irq(iadev->irq, &ia_int, IRQF_SHARED, DEV_LABEL, dev)) {\n                printk(KERN_ERR DEV_LABEL \"(itf %d): IRQ%d is already in use\\n\",  \n                    dev->number, iadev->irq);  \n\t\terror = -EAGAIN;\n\t\tgoto err_out;\n        }  \n           \n\t   \n        if ((error = pci_write_config_word(iadev->pci,   \n\t\t\t\tPCI_COMMAND,   \n\t\t\t\tPCI_COMMAND_MEMORY | PCI_COMMAND_MASTER )))   \n\t{  \n                printk(KERN_ERR DEV_LABEL \"(itf %d): can't enable memory+\"  \n                    \"master (0x%x)\\n\",dev->number, error);  \n\t\terror = -EIO;  \n\t\tgoto err_free_irq;\n        }  \n\tudelay(10);  \n  \n\t   \n  \n\tIF_INIT(printk(\"Bus ctrl reg: %08x\\n\", \n                            readl(iadev->reg+IPHASE5575_BUS_CONTROL_REG));)  \n\tctrl_reg = readl(iadev->reg+IPHASE5575_BUS_CONTROL_REG);  \n\tctrl_reg = (ctrl_reg & (CTRL_LED | CTRL_FE_RST))  \n\t\t\t| CTRL_B8  \n\t\t\t| CTRL_B16  \n\t\t\t| CTRL_B32  \n\t\t\t| CTRL_B48  \n\t\t\t| CTRL_B64  \n\t\t\t| CTRL_B128  \n\t\t\t| CTRL_ERRMASK  \n\t\t\t| CTRL_DLETMASK\t\t   \n\t\t\t| CTRL_DLERMASK  \n\t\t\t| CTRL_SEGMASK  \n\t\t\t| CTRL_REASSMASK \t  \n\t\t\t| CTRL_FEMASK  \n\t\t\t| CTRL_CSPREEMPT;  \n  \n       writel(ctrl_reg, iadev->reg+IPHASE5575_BUS_CONTROL_REG);   \n  \n\tIF_INIT(printk(\"Bus ctrl reg after initializing: %08x\\n\", \n                           readl(iadev->reg+IPHASE5575_BUS_CONTROL_REG));  \n\t   printk(\"Bus status reg after init: %08x\\n\", \n                            readl(iadev->reg+IPHASE5575_BUS_STATUS_REG));)  \n    \n        ia_hw_type(iadev); \n\terror = tx_init(dev);  \n\tif (error)\n\t\tgoto err_free_irq;\n\terror = rx_init(dev);  \n\tif (error)\n\t\tgoto err_free_tx;\n  \n\tctrl_reg = readl(iadev->reg+IPHASE5575_BUS_CONTROL_REG);  \n       \twritel(ctrl_reg | CTRL_FE_RST, iadev->reg+IPHASE5575_BUS_CONTROL_REG);   \n\tIF_INIT(printk(\"Bus ctrl reg after initializing: %08x\\n\", \n                               readl(iadev->reg+IPHASE5575_BUS_CONTROL_REG));)  \n        phy = 0;  \n        IF_INIT ( \n\tif ((phy=ia_phy_get(dev,0)) == 0x30)  \n\t\tprintk(\"IA: pm5346,rev.%d\\n\",phy&0x0f);  \n\telse  \n\t\tprintk(\"IA: utopia,rev.%0x\\n\",phy);) \n\n\tif (iadev->phy_type &  FE_25MBIT_PHY)\n           ia_mb25_init(iadev);\n\telse if (iadev->phy_type & (FE_DS3_PHY | FE_E3_PHY))\n           ia_suni_pm7345_init(iadev);\n\telse {\n\t\terror = suni_init(dev);\n\t\tif (error)\n\t\t\tgoto err_free_rx;\n\t\tif (dev->phy->start) {\n\t\t\terror = dev->phy->start(dev);\n\t\t\tif (error)\n\t\t\t\tgoto err_free_rx;\n\t\t}\n\t\t \n\t\tia_frontend_intr(iadev);\n\t}\n\treturn 0;\n\nerr_free_rx:\n\tia_free_rx(iadev);\nerr_free_tx:\n\tia_free_tx(iadev);\nerr_free_irq:\n\tfree_irq(iadev->irq, dev);  \nerr_out:\n\treturn error;\n}  \n  \nstatic void ia_close(struct atm_vcc *vcc)  \n{\n\tDEFINE_WAIT(wait);\n        u16 *vc_table;\n        IADEV *iadev;\n        struct ia_vcc *ia_vcc;\n        struct sk_buff *skb = NULL;\n        struct sk_buff_head tmp_tx_backlog, tmp_vcc_backlog;\n        unsigned long closetime, flags;\n\n        iadev = INPH_IA_DEV(vcc->dev);\n        ia_vcc = INPH_IA_VCC(vcc);\n\tif (!ia_vcc) return;  \n\n        IF_EVENT(printk(\"ia_close: ia_vcc->vc_desc_cnt = %d  vci = %d\\n\", \n                                              ia_vcc->vc_desc_cnt,vcc->vci);)\n\tclear_bit(ATM_VF_READY,&vcc->flags);\n        skb_queue_head_init (&tmp_tx_backlog);\n        skb_queue_head_init (&tmp_vcc_backlog); \n        if (vcc->qos.txtp.traffic_class != ATM_NONE) {\n           iadev->close_pending++;\n\t   prepare_to_wait(&iadev->timeout_wait, &wait, TASK_UNINTERRUPTIBLE);\n\t   schedule_timeout(msecs_to_jiffies(500));\n\t   finish_wait(&iadev->timeout_wait, &wait);\n           spin_lock_irqsave(&iadev->tx_lock, flags); \n           while((skb = skb_dequeue(&iadev->tx_backlog))) {\n              if (ATM_SKB(skb)->vcc == vcc){ \n                 if (vcc->pop) vcc->pop(vcc, skb);\n                 else dev_kfree_skb_any(skb);\n              }\n              else \n                 skb_queue_tail(&tmp_tx_backlog, skb);\n           } \n           while((skb = skb_dequeue(&tmp_tx_backlog))) \n             skb_queue_tail(&iadev->tx_backlog, skb);\n           IF_EVENT(printk(\"IA TX Done decs_cnt = %d\\n\", ia_vcc->vc_desc_cnt);) \n           closetime = 300000 / ia_vcc->pcr;\n           if (closetime == 0)\n              closetime = 1;\n           spin_unlock_irqrestore(&iadev->tx_lock, flags);\n           wait_event_timeout(iadev->close_wait, (ia_vcc->vc_desc_cnt <= 0), closetime);\n           spin_lock_irqsave(&iadev->tx_lock, flags);\n           iadev->close_pending--;\n           iadev->testTable[vcc->vci]->lastTime = 0;\n           iadev->testTable[vcc->vci]->fract = 0; \n           iadev->testTable[vcc->vci]->vc_status = VC_UBR; \n           if (vcc->qos.txtp.traffic_class == ATM_ABR) {\n              if (vcc->qos.txtp.min_pcr > 0)\n                 iadev->sum_mcr -= vcc->qos.txtp.min_pcr;\n           }\n           if (vcc->qos.txtp.traffic_class == ATM_CBR) {\n              ia_vcc = INPH_IA_VCC(vcc); \n              iadev->sum_mcr -= ia_vcc->NumCbrEntry*iadev->Granularity;\n              ia_cbrVc_close (vcc);\n           }\n           spin_unlock_irqrestore(&iadev->tx_lock, flags);\n        }\n        \n        if (vcc->qos.rxtp.traffic_class != ATM_NONE) {   \n            \n           vc_table = (u16 *)(iadev->reass_ram+REASS_TABLE*iadev->memSize);\n           vc_table += vcc->vci; \n           *vc_table = NO_AAL5_PKT;\n            \n           vc_table = (u16 *)(iadev->reass_ram+RX_VC_TABLE*iadev->memSize);\n           vc_table += vcc->vci;\n           *vc_table = (vcc->vci << 6) | 15;\n           if (vcc->qos.rxtp.traffic_class == ATM_ABR) {\n              struct abr_vc_table __iomem *abr_vc_table = \n                                (iadev->reass_ram+ABR_VC_TABLE*iadev->memSize);\n              abr_vc_table +=  vcc->vci;\n              abr_vc_table->rdf = 0x0003;\n              abr_vc_table->air = 0x5eb1;\n           }                                 \n            \n           rx_dle_intr(vcc->dev); \n           iadev->rx_open[vcc->vci] = NULL;\n        }\n\tkfree(INPH_IA_VCC(vcc));  \n        ia_vcc = NULL;\n        vcc->dev_data = NULL;\n        clear_bit(ATM_VF_ADDR,&vcc->flags);\n        return;        \n}  \n  \nstatic int ia_open(struct atm_vcc *vcc)\n{  \n\tstruct ia_vcc *ia_vcc;  \n\tint error;  \n\tif (!test_bit(ATM_VF_PARTIAL,&vcc->flags))  \n\t{  \n\t\tIF_EVENT(printk(\"ia: not partially allocated resources\\n\");)  \n\t\tvcc->dev_data = NULL;\n\t}  \n\tif (vcc->vci != ATM_VPI_UNSPEC && vcc->vpi != ATM_VCI_UNSPEC)  \n\t{  \n\t\tIF_EVENT(printk(\"iphase open: unspec part\\n\");)  \n\t\tset_bit(ATM_VF_ADDR,&vcc->flags);\n\t}  \n\tif (vcc->qos.aal != ATM_AAL5)  \n\t\treturn -EINVAL;  \n\tIF_EVENT(printk(DEV_LABEL \"(itf %d): open %d.%d\\n\", \n                                 vcc->dev->number, vcc->vpi, vcc->vci);)  \n  \n\t   \n\tia_vcc = kmalloc(sizeof(*ia_vcc), GFP_KERNEL);  \n\tif (!ia_vcc) return -ENOMEM;  \n\tvcc->dev_data = ia_vcc;\n  \n\tif ((error = open_rx(vcc)))  \n\t{  \n\t\tIF_EVENT(printk(\"iadev: error in open_rx, closing\\n\");)  \n\t\tia_close(vcc);  \n\t\treturn error;  \n\t}  \n  \n\tif ((error = open_tx(vcc)))  \n\t{  \n\t\tIF_EVENT(printk(\"iadev: error in open_tx, closing\\n\");)  \n\t\tia_close(vcc);  \n\t\treturn error;  \n\t}  \n  \n\tset_bit(ATM_VF_READY,&vcc->flags);\n\n#if 0\n        {\n           static u8 first = 1; \n           if (first) {\n              ia_timer.expires = jiffies + 3*HZ;\n              add_timer(&ia_timer);\n              first = 0;\n           }           \n        }\n#endif\n\tIF_EVENT(printk(\"ia open returning\\n\");)  \n\treturn 0;  \n}  \n  \nstatic int ia_change_qos(struct atm_vcc *vcc, struct atm_qos *qos, int flags)  \n{  \n\tIF_EVENT(printk(\">ia_change_qos\\n\");)  \n\treturn 0;  \n}  \n  \nstatic int ia_ioctl(struct atm_dev *dev, unsigned int cmd, void __user *arg)  \n{  \n   IA_CMDBUF ia_cmds;\n   IADEV *iadev;\n   int i, board;\n   u16 __user *tmps;\n   IF_EVENT(printk(\">ia_ioctl\\n\");)  \n   if (cmd != IA_CMD) {\n      if (!dev->phy->ioctl) return -EINVAL;\n      return dev->phy->ioctl(dev,cmd,arg);\n   }\n   if (copy_from_user(&ia_cmds, arg, sizeof ia_cmds)) return -EFAULT; \n   board = ia_cmds.status;\n\n\tif ((board < 0) || (board > iadev_count))\n\t\tboard = 0;\n\tboard = array_index_nospec(board, iadev_count + 1);\n\n   iadev = ia_dev[board];\n   switch (ia_cmds.cmd) {\n   case MEMDUMP:\n   {\n\tswitch (ia_cmds.sub_cmd) {\n          case MEMDUMP_SEGREG:\n\t     if (!capable(CAP_NET_ADMIN)) return -EPERM;\n             tmps = (u16 __user *)ia_cmds.buf;\n             for(i=0; i<0x80; i+=2, tmps++)\n                if(put_user((u16)(readl(iadev->seg_reg+i) & 0xffff), tmps)) return -EFAULT;\n             ia_cmds.status = 0;\n             ia_cmds.len = 0x80;\n             break;\n          case MEMDUMP_REASSREG:\n\t     if (!capable(CAP_NET_ADMIN)) return -EPERM;\n             tmps = (u16 __user *)ia_cmds.buf;\n             for(i=0; i<0x80; i+=2, tmps++)\n                if(put_user((u16)(readl(iadev->reass_reg+i) & 0xffff), tmps)) return -EFAULT;\n             ia_cmds.status = 0;\n             ia_cmds.len = 0x80;\n             break;\n          case MEMDUMP_FFL:\n          {  \n             ia_regs_t       *regs_local;\n             ffredn_t        *ffL;\n             rfredn_t        *rfL;\n                     \n\t     if (!capable(CAP_NET_ADMIN)) return -EPERM;\n\t     regs_local = kmalloc(sizeof(*regs_local), GFP_KERNEL);\n\t     if (!regs_local) return -ENOMEM;\n\t     ffL = &regs_local->ffredn;\n\t     rfL = &regs_local->rfredn;\n              \n \t     for (i=0; i<(sizeof (rfredn_t))/4; i++)\n                ((u_int *)rfL)[i] = readl(iadev->reass_reg + i) & 0xffff;\n             \t \n\t     for (i=0; i<(sizeof (ffredn_t))/4; i++)\n                ((u_int *)ffL)[i] = readl(iadev->seg_reg + i) & 0xffff;\n\n             if (copy_to_user(ia_cmds.buf, regs_local,sizeof(ia_regs_t))) {\n                kfree(regs_local);\n                return -EFAULT;\n             }\n             kfree(regs_local);\n             printk(\"Board %d registers dumped\\n\", board);\n             ia_cmds.status = 0;                  \n\t }\t\n    \t     break;        \n         case READ_REG:\n         {  \n\t     if (!capable(CAP_NET_ADMIN)) return -EPERM;\n             desc_dbg(iadev); \n             ia_cmds.status = 0; \n         }\n             break;\n         case 0x6:\n         {  \n             ia_cmds.status = 0; \n             printk(\"skb = 0x%p\\n\", skb_peek(&iadev->tx_backlog));\n             printk(\"rtn_q: 0x%p\\n\",ia_deque_rtn_q(&iadev->tx_return_q));\n         }\n             break;\n         case 0x8:\n         {\n             struct k_sonet_stats *stats;\n             stats = &PRIV(_ia_dev[board])->sonet_stats;\n             printk(\"section_bip: %d\\n\", atomic_read(&stats->section_bip));\n             printk(\"line_bip   : %d\\n\", atomic_read(&stats->line_bip));\n             printk(\"path_bip   : %d\\n\", atomic_read(&stats->path_bip));\n             printk(\"line_febe  : %d\\n\", atomic_read(&stats->line_febe));\n             printk(\"path_febe  : %d\\n\", atomic_read(&stats->path_febe));\n             printk(\"corr_hcs   : %d\\n\", atomic_read(&stats->corr_hcs));\n             printk(\"uncorr_hcs : %d\\n\", atomic_read(&stats->uncorr_hcs));\n             printk(\"tx_cells   : %d\\n\", atomic_read(&stats->tx_cells));\n             printk(\"rx_cells   : %d\\n\", atomic_read(&stats->rx_cells));\n         }\n            ia_cmds.status = 0;\n            break;\n         case 0x9:\n\t    if (!capable(CAP_NET_ADMIN)) return -EPERM;\n            for (i = 1; i <= iadev->num_rx_desc; i++)\n               free_desc(_ia_dev[board], i);\n            writew( ~(RX_FREEQ_EMPT | RX_EXCP_RCVD), \n                                            iadev->reass_reg+REASS_MASK_REG);\n            iadev->rxing = 1;\n            \n            ia_cmds.status = 0;\n            break;\n\n         case 0xb:\n\t    if (!capable(CAP_NET_ADMIN)) return -EPERM;\n            ia_frontend_intr(iadev);\n            break;\n         case 0xa:\n\t    if (!capable(CAP_NET_ADMIN)) return -EPERM;\n         {  \n             ia_cmds.status = 0; \n             IADebugFlag = ia_cmds.maddr;\n             printk(\"New debug option loaded\\n\");\n         }\n             break;\n         default:\n             ia_cmds.status = 0;\n             break;\n      }\t\n   }\n      break;\n   default:\n      break;\n\n   }\t\n   return 0;  \n}  \n  \nstatic int ia_pkt_tx (struct atm_vcc *vcc, struct sk_buff *skb) {\n        IADEV *iadev;\n        struct dle *wr_ptr;\n        struct tx_buf_desc __iomem *buf_desc_ptr;\n        int desc;\n        int comp_code;\n        int total_len;\n        struct cpcs_trailer *trailer;\n        struct ia_vcc *iavcc;\n\n        iadev = INPH_IA_DEV(vcc->dev);  \n        iavcc = INPH_IA_VCC(vcc);\n        if (!iavcc->txing) {\n           printk(\"discard packet on closed VC\\n\");\n           if (vcc->pop)\n\t\tvcc->pop(vcc, skb);\n           else\n\t\tdev_kfree_skb_any(skb);\n\t   return 0;\n        }\n\n        if (skb->len > iadev->tx_buf_sz - 8) {\n           printk(\"Transmit size over tx buffer size\\n\");\n           if (vcc->pop)\n                 vcc->pop(vcc, skb);\n           else\n                 dev_kfree_skb_any(skb);\n          return 0;\n        }\n        if ((unsigned long)skb->data & 3) {\n           printk(\"Misaligned SKB\\n\");\n           if (vcc->pop)\n                 vcc->pop(vcc, skb);\n           else\n                 dev_kfree_skb_any(skb);\n           return 0;\n        }       \n\t \n\tdesc = get_desc (iadev, iavcc);\n\tif (desc == 0xffff) \n\t    return 1;\n\tcomp_code = desc >> 13;  \n\tdesc &= 0x1fff;  \n  \n\tif ((desc == 0) || (desc > iadev->num_tx_desc))  \n\t{  \n\t\tIF_ERR(printk(DEV_LABEL \"invalid desc for send: %d\\n\", desc);) \n                atomic_inc(&vcc->stats->tx);\n\t\tif (vcc->pop)   \n\t\t    vcc->pop(vcc, skb);   \n\t\telse  \n\t\t    dev_kfree_skb_any(skb);\n\t\treturn 0;    \n\t}  \n  \n\tif (comp_code)  \n\t{  \n\t    IF_ERR(printk(DEV_LABEL \"send desc:%d completion code %d error\\n\", \n                                                            desc, comp_code);)  \n\t}  \n       \n         \n        iavcc->vc_desc_cnt++;\n        iadev->desc_tbl[desc-1].iavcc = iavcc;\n        iadev->desc_tbl[desc-1].txskb = skb;\n        IA_SKB_STATE(skb) = 0;\n\n        iadev->ffL.tcq_rd += 2;\n        if (iadev->ffL.tcq_rd > iadev->ffL.tcq_ed)\n\t  \tiadev->ffL.tcq_rd  = iadev->ffL.tcq_st;\n\twritew(iadev->ffL.tcq_rd, iadev->seg_reg+TCQ_RD_PTR);\n  \n\t    \n\t*(u16*)(iadev->seg_ram+iadev->ffL.prq_wr) = desc; \n\n \tiadev->ffL.prq_wr += 2;\n        if (iadev->ffL.prq_wr > iadev->ffL.prq_ed)\n                iadev->ffL.prq_wr = iadev->ffL.prq_st;\n\t  \n\t \n\ttotal_len = skb->len + sizeof(struct cpcs_trailer);  \n\ttotal_len = ((total_len + 47) / 48) * 48;\n\tIF_TX(printk(\"ia packet len:%d padding:%d\\n\", total_len, total_len - skb->len);)  \n \n\t    \n\ttrailer = iadev->tx_buf[desc-1].cpcs;\n        IF_TX(printk(\"Sent: skb = 0x%p skb->data: 0x%p len: %d, desc: %d\\n\",\n                  skb, skb->data, skb->len, desc);)\n\ttrailer->control = 0; \n          \n\ttrailer->length = ((skb->len & 0xff) << 8) | ((skb->len & 0xff00) >> 8);\n\ttrailer->crc32 = 0;\t   \n\n\t   \n\tIF_TXPKT(printk(\"Sent data: len = %d MsgNum = %d\\n\", \n                                                        skb->len, tcnter++);  \n        xdump(skb->data, skb->len, \"TX: \");\n        printk(\"\\n\");)\n\n\t   \n\tbuf_desc_ptr = iadev->seg_ram+TX_DESC_BASE;\n\tbuf_desc_ptr += desc;\t   \n\tbuf_desc_ptr->desc_mode = AAL5 | EOM_EN | APP_CRC32 | CMPL_INT;   \n\t \n        writew(TRANSMIT_DONE, iadev->seg_reg+SEG_INTR_STATUS_REG);\n\tbuf_desc_ptr->vc_index = vcc->vci;\n\tbuf_desc_ptr->bytes = total_len;  \n\n        if (vcc->qos.txtp.traffic_class == ATM_ABR)  \n\t   clear_lockup (vcc, iadev);\n\n\t   \n\twr_ptr = iadev->tx_dle_q.write;  \n\tmemset((caddr_t)wr_ptr, 0, sizeof(*wr_ptr));  \n\twr_ptr->sys_pkt_addr = dma_map_single(&iadev->pci->dev, skb->data,\n\t\t\t\t\t      skb->len, DMA_TO_DEVICE);\n\twr_ptr->local_pkt_addr = (buf_desc_ptr->buf_start_hi << 16) | \n                                                  buf_desc_ptr->buf_start_lo;  \n\t \n\twr_ptr->bytes = skb->len;  \n\n         \n        if ((wr_ptr->bytes >> 2) == 0xb)\n           wr_ptr->bytes = 0x30;\n\n\twr_ptr->mode = TX_DLE_PSI; \n\twr_ptr->prq_wr_ptr_data = 0;\n  \n\t   \n\tif (++wr_ptr == iadev->tx_dle_q.end)  \n\t\twr_ptr = iadev->tx_dle_q.start;  \n        \n         \n        wr_ptr->sys_pkt_addr = iadev->tx_buf[desc-1].dma_addr;\n        wr_ptr->local_pkt_addr = ((buf_desc_ptr->buf_start_hi << 16) | \n          buf_desc_ptr->buf_start_lo) + total_len - sizeof(struct cpcs_trailer);\n\n        wr_ptr->bytes = sizeof(struct cpcs_trailer);\n        wr_ptr->mode = DMA_INT_ENABLE; \n        wr_ptr->prq_wr_ptr_data = iadev->ffL.prq_wr;\n        \n         \n        if (++wr_ptr == iadev->tx_dle_q.end)  \n                wr_ptr = iadev->tx_dle_q.start;\n\n\tiadev->tx_dle_q.write = wr_ptr;  \n        ATM_DESC(skb) = vcc->vci;\n        skb_queue_tail(&iadev->tx_dma_q, skb);\n\n        atomic_inc(&vcc->stats->tx);\n        iadev->tx_pkt_cnt++;\n\t   \n\twritel(2, iadev->dma+IPHASE5575_TX_COUNTER);  \n        \n#if 0        \n          \n        if (atomic_read(&vcc->stats->tx) % 20 == 0) {\n          if (iavcc->vc_desc_cnt > 10) {\n             vcc->tx_quota =  vcc->tx_quota * 3 / 4;\n            printk(\"Tx1:  vcc->tx_quota = %d \\n\", (u32)vcc->tx_quota );\n              iavcc->flow_inc = -1;\n              iavcc->saved_tx_quota = vcc->tx_quota;\n           } else if ((iavcc->flow_inc < 0) && (iavcc->vc_desc_cnt < 3)) {\n              \n             printk(\"Tx2:  vcc->tx_quota = %d \\n\", (u32)vcc->tx_quota ); \n              iavcc->flow_inc = 0;\n           }\n        }\n#endif\n\tIF_TX(printk(\"ia send done\\n\");)  \n\treturn 0;  \n}  \n\nstatic int ia_send(struct atm_vcc *vcc, struct sk_buff *skb)\n{\n        IADEV *iadev; \n        unsigned long flags;\n\n        iadev = INPH_IA_DEV(vcc->dev);\n        if ((!skb)||(skb->len>(iadev->tx_buf_sz-sizeof(struct cpcs_trailer))))\n        {\n            if (!skb)\n                printk(KERN_CRIT \"null skb in ia_send\\n\");\n            else dev_kfree_skb_any(skb);\n            return -EINVAL;\n        }                         \n        spin_lock_irqsave(&iadev->tx_lock, flags); \n        if (!test_bit(ATM_VF_READY,&vcc->flags)){ \n            dev_kfree_skb_any(skb);\n            spin_unlock_irqrestore(&iadev->tx_lock, flags);\n            return -EINVAL; \n        }\n        ATM_SKB(skb)->vcc = vcc;\n \n        if (skb_peek(&iadev->tx_backlog)) {\n           skb_queue_tail(&iadev->tx_backlog, skb);\n        }\n        else {\n           if (ia_pkt_tx (vcc, skb)) {\n              skb_queue_tail(&iadev->tx_backlog, skb);\n           }\n        }\n        spin_unlock_irqrestore(&iadev->tx_lock, flags);\n        return 0;\n\n}\n\nstatic int ia_proc_read(struct atm_dev *dev,loff_t *pos,char *page)\n{ \n  int   left = *pos, n;   \n  char  *tmpPtr;\n  IADEV *iadev = INPH_IA_DEV(dev);\n  if(!left--) {\n     if (iadev->phy_type == FE_25MBIT_PHY) {\n       n = sprintf(page, \"  Board Type         :  Iphase5525-1KVC-128K\\n\");\n       return n;\n     }\n     if (iadev->phy_type == FE_DS3_PHY)\n        n = sprintf(page, \"  Board Type         :  Iphase-ATM-DS3\");\n     else if (iadev->phy_type == FE_E3_PHY)\n        n = sprintf(page, \"  Board Type         :  Iphase-ATM-E3\");\n     else if (iadev->phy_type == FE_UTP_OPTION)\n         n = sprintf(page, \"  Board Type         :  Iphase-ATM-UTP155\"); \n     else\n        n = sprintf(page, \"  Board Type         :  Iphase-ATM-OC3\");\n     tmpPtr = page + n;\n     if (iadev->pci_map_size == 0x40000)\n        n += sprintf(tmpPtr, \"-1KVC-\");\n     else\n        n += sprintf(tmpPtr, \"-4KVC-\");  \n     tmpPtr = page + n; \n     if ((iadev->memType & MEM_SIZE_MASK) == MEM_SIZE_1M)\n        n += sprintf(tmpPtr, \"1M  \\n\");\n     else if ((iadev->memType & MEM_SIZE_MASK) == MEM_SIZE_512K)\n        n += sprintf(tmpPtr, \"512K\\n\");\n     else\n       n += sprintf(tmpPtr, \"128K\\n\");\n     return n;\n  }\n  if (!left) {\n     return  sprintf(page, \"  Number of Tx Buffer:  %u\\n\"\n                           \"  Size of Tx Buffer  :  %u\\n\"\n                           \"  Number of Rx Buffer:  %u\\n\"\n                           \"  Size of Rx Buffer  :  %u\\n\"\n                           \"  Packets Received   :  %u\\n\"\n                           \"  Packets Transmitted:  %u\\n\"\n                           \"  Cells Received     :  %u\\n\"\n                           \"  Cells Transmitted  :  %u\\n\"\n                           \"  Board Dropped Cells:  %u\\n\"\n                           \"  Board Dropped Pkts :  %u\\n\",\n                           iadev->num_tx_desc,  iadev->tx_buf_sz,\n                           iadev->num_rx_desc,  iadev->rx_buf_sz,\n                           iadev->rx_pkt_cnt,   iadev->tx_pkt_cnt,\n                           iadev->rx_cell_cnt, iadev->tx_cell_cnt,\n                           iadev->drop_rxcell, iadev->drop_rxpkt);                        \n  }\n  return 0;\n}\n  \nstatic const struct atmdev_ops ops = {  \n\t.open\t\t= ia_open,  \n\t.close\t\t= ia_close,  \n\t.ioctl\t\t= ia_ioctl,  \n\t.send\t\t= ia_send,  \n\t.phy_put\t= ia_phy_put,  \n\t.phy_get\t= ia_phy_get,  \n\t.change_qos\t= ia_change_qos,  \n\t.proc_read\t= ia_proc_read,\n\t.owner\t\t= THIS_MODULE,\n};  \n\t  \nstatic int ia_init_one(struct pci_dev *pdev, const struct pci_device_id *ent)\n{  \n\tstruct atm_dev *dev;  \n\tIADEV *iadev;  \n\tint ret;\n\n\tiadev = kzalloc(sizeof(*iadev), GFP_KERNEL);\n\tif (!iadev) {\n\t\tret = -ENOMEM;\n\t\tgoto err_out;\n\t}\n\n\tiadev->pci = pdev;\n\n\tIF_INIT(printk(\"ia detected at bus:%d dev: %d function:%d\\n\",\n\t\tpdev->bus->number, PCI_SLOT(pdev->devfn), PCI_FUNC(pdev->devfn));)\n\tif (pci_enable_device(pdev)) {\n\t\tret = -ENODEV;\n\t\tgoto err_out_free_iadev;\n\t}\n\tdev = atm_dev_register(DEV_LABEL, &pdev->dev, &ops, -1, NULL);\n\tif (!dev) {\n\t\tret = -ENOMEM;\n\t\tgoto err_out_disable_dev;\n\t}\n\tdev->dev_data = iadev;\n\tIF_INIT(printk(DEV_LABEL \"registered at (itf :%d)\\n\", dev->number);)\n\tIF_INIT(printk(\"dev_id = 0x%p iadev->LineRate = %d \\n\", dev,\n\t\tiadev->LineRate);)\n\n\tpci_set_drvdata(pdev, dev);\n\n\tia_dev[iadev_count] = iadev;\n\t_ia_dev[iadev_count] = dev;\n\tiadev_count++;\n\tif (ia_init(dev) || ia_start(dev)) {  \n\t\tIF_INIT(printk(\"IA register failed!\\n\");)\n\t\tiadev_count--;\n\t\tia_dev[iadev_count] = NULL;\n\t\t_ia_dev[iadev_count] = NULL;\n\t\tret = -EINVAL;\n\t\tgoto err_out_deregister_dev;\n\t}\n\tIF_EVENT(printk(\"iadev_count = %d\\n\", iadev_count);)\n\n\tiadev->next_board = ia_boards;  \n\tia_boards = dev;  \n\n\treturn 0;\n\nerr_out_deregister_dev:\n\tatm_dev_deregister(dev);  \nerr_out_disable_dev:\n\tpci_disable_device(pdev);\nerr_out_free_iadev:\n\tkfree(iadev);\nerr_out:\n\treturn ret;\n}\n\nstatic void ia_remove_one(struct pci_dev *pdev)\n{\n\tstruct atm_dev *dev = pci_get_drvdata(pdev);\n\tIADEV *iadev = INPH_IA_DEV(dev);\n\n\t \n\tia_phy_put(dev, ia_phy_get(dev, SUNI_RSOP_CIE) & ~(SUNI_RSOP_CIE_LOSE),\n\t\t\t\t   SUNI_RSOP_CIE);\n\tudelay(1);\n\n\tif (dev->phy && dev->phy->stop)\n\t\tdev->phy->stop(dev);\n\n\t   \n      \tfree_irq(iadev->irq, dev);\n\tiadev_count--;\n\tia_dev[iadev_count] = NULL;\n\t_ia_dev[iadev_count] = NULL;\n\tIF_EVENT(printk(\"deregistering iav at (itf:%d)\\n\", dev->number);)\n\tatm_dev_deregister(dev);\n\n      \tiounmap(iadev->base);  \n\tpci_disable_device(pdev);\n\n\tia_free_rx(iadev);\n\tia_free_tx(iadev);\n\n      \tkfree(iadev);\n}\n\nstatic const struct pci_device_id ia_pci_tbl[] = {\n\t{ PCI_VENDOR_ID_IPHASE, 0x0008, PCI_ANY_ID, PCI_ANY_ID, },\n\t{ PCI_VENDOR_ID_IPHASE, 0x0009, PCI_ANY_ID, PCI_ANY_ID, },\n\t{ 0,}\n};\nMODULE_DEVICE_TABLE(pci, ia_pci_tbl);\n\nstatic struct pci_driver ia_driver = {\n\t.name =         DEV_LABEL,\n\t.id_table =     ia_pci_tbl,\n\t.probe =        ia_init_one,\n\t.remove =       ia_remove_one,\n};\n\nstatic int __init ia_module_init(void)\n{\n\tint ret;\n\n\tret = pci_register_driver(&ia_driver);\n\tif (ret >= 0) {\n\t\tia_timer.expires = jiffies + 3*HZ;\n\t\tadd_timer(&ia_timer); \n\t} else\n\t\tprintk(KERN_ERR DEV_LABEL \": no adapter found\\n\");  \n\treturn ret;\n}\n\nstatic void __exit ia_module_exit(void)\n{\n\tpci_unregister_driver(&ia_driver);\n\n\tdel_timer_sync(&ia_timer);\n}\n\nmodule_init(ia_module_init);\nmodule_exit(ia_module_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}