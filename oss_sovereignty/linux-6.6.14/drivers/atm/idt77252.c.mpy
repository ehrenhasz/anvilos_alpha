{
  "module_name": "idt77252.c",
  "hash_id": "24d03a87f04fc52ce97fc5207e89d8beb175261125b91cab6baa25f7d2cdcd28",
  "original_prompt": "Ingested from linux-6.6.14/drivers/atm/idt77252.c",
  "human_readable_source": " \n\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/poison.h>\n#include <linux/skbuff.h>\n#include <linux/kernel.h>\n#include <linux/vmalloc.h>\n#include <linux/netdevice.h>\n#include <linux/atmdev.h>\n#include <linux/atm.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/bitops.h>\n#include <linux/wait.h>\n#include <linux/jiffies.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n\n#ifdef CONFIG_ATM_IDT77252_USE_SUNI\n#include \"suni.h\"\n#endif  \n\n\n#include \"idt77252.h\"\n#include \"idt77252_tables.h\"\n\nstatic unsigned int vpibits = 1;\n\n\n#define ATM_IDT77252_SEND_IDLE 1\n\n\n \n#define DEBUG_MODULE 1\n#undef HAVE_EEPROM\t \n\n#ifdef CONFIG_ATM_IDT77252_DEBUG\nstatic unsigned long debug = DBG_GENERAL;\n#endif\n\n\n#define SAR_RX_DELAY\t(SAR_CFG_RXINT_NODELAY)\n\n\n \nstatic struct scq_info *alloc_scq(struct idt77252_dev *, int);\nstatic void free_scq(struct idt77252_dev *, struct scq_info *);\nstatic int queue_skb(struct idt77252_dev *, struct vc_map *,\n\t\t     struct sk_buff *, int oam);\nstatic void drain_scq(struct idt77252_dev *, struct vc_map *);\nstatic unsigned long get_free_scd(struct idt77252_dev *, struct vc_map *);\nstatic void fill_scd(struct idt77252_dev *, struct scq_info *, int);\n\n \nstatic int push_rx_skb(struct idt77252_dev *,\n\t\t       struct sk_buff *, int queue);\nstatic void recycle_rx_skb(struct idt77252_dev *, struct sk_buff *);\nstatic void flush_rx_pool(struct idt77252_dev *, struct rx_pool *);\nstatic void recycle_rx_pool_skb(struct idt77252_dev *,\n\t\t\t\tstruct rx_pool *);\nstatic void add_rx_skb(struct idt77252_dev *, int queue,\n\t\t       unsigned int size, unsigned int count);\n\n \nstatic int init_rsq(struct idt77252_dev *);\nstatic void deinit_rsq(struct idt77252_dev *);\nstatic void idt77252_rx(struct idt77252_dev *);\n\n \nstatic int init_tsq(struct idt77252_dev *);\nstatic void deinit_tsq(struct idt77252_dev *);\nstatic void idt77252_tx(struct idt77252_dev *);\n\n\n \nstatic void idt77252_dev_close(struct atm_dev *dev);\nstatic int idt77252_open(struct atm_vcc *vcc);\nstatic void idt77252_close(struct atm_vcc *vcc);\nstatic int idt77252_send(struct atm_vcc *vcc, struct sk_buff *skb);\nstatic int idt77252_send_oam(struct atm_vcc *vcc, void *cell,\n\t\t\t     int flags);\nstatic void idt77252_phy_put(struct atm_dev *dev, unsigned char value,\n\t\t\t     unsigned long addr);\nstatic unsigned char idt77252_phy_get(struct atm_dev *dev, unsigned long addr);\nstatic int idt77252_change_qos(struct atm_vcc *vcc, struct atm_qos *qos,\n\t\t\t       int flags);\nstatic int idt77252_proc_read(struct atm_dev *dev, loff_t * pos,\n\t\t\t      char *page);\nstatic void idt77252_softint(struct work_struct *work);\n\n\nstatic const struct atmdev_ops idt77252_ops =\n{\n\t.dev_close\t= idt77252_dev_close,\n\t.open\t\t= idt77252_open,\n\t.close\t\t= idt77252_close,\n\t.send\t\t= idt77252_send,\n\t.send_oam\t= idt77252_send_oam,\n\t.phy_put\t= idt77252_phy_put,\n\t.phy_get\t= idt77252_phy_get,\n\t.change_qos\t= idt77252_change_qos,\n\t.proc_read\t= idt77252_proc_read,\n\t.owner\t\t= THIS_MODULE\n};\n\nstatic struct idt77252_dev *idt77252_chain = NULL;\nstatic unsigned int idt77252_sram_write_errors = 0;\n\n \n \n \n \n \n\nstatic void\nwaitfor_idle(struct idt77252_dev *card)\n{\n\tu32 stat;\n\n\tstat = readl(SAR_REG_STAT);\n\twhile (stat & SAR_STAT_CMDBZ)\n\t\tstat = readl(SAR_REG_STAT);\n}\n\nstatic u32\nread_sram(struct idt77252_dev *card, unsigned long addr)\n{\n\tunsigned long flags;\n\tu32 value;\n\n\tspin_lock_irqsave(&card->cmd_lock, flags);\n\twritel(SAR_CMD_READ_SRAM | (addr << 2), SAR_REG_CMD);\n\twaitfor_idle(card);\n\tvalue = readl(SAR_REG_DR0);\n\tspin_unlock_irqrestore(&card->cmd_lock, flags);\n\treturn value;\n}\n\nstatic void\nwrite_sram(struct idt77252_dev *card, unsigned long addr, u32 value)\n{\n\tunsigned long flags;\n\n\tif ((idt77252_sram_write_errors == 0) &&\n\t    (((addr > card->tst[0] + card->tst_size - 2) &&\n\t      (addr < card->tst[0] + card->tst_size)) ||\n\t     ((addr > card->tst[1] + card->tst_size - 2) &&\n\t      (addr < card->tst[1] + card->tst_size)))) {\n\t\tprintk(\"%s: ERROR: TST JMP section at %08lx written: %08x\\n\",\n\t\t       card->name, addr, value);\n\t}\n\n\tspin_lock_irqsave(&card->cmd_lock, flags);\n\twritel(value, SAR_REG_DR0);\n\twritel(SAR_CMD_WRITE_SRAM | (addr << 2), SAR_REG_CMD);\n\twaitfor_idle(card);\n\tspin_unlock_irqrestore(&card->cmd_lock, flags);\n}\n\nstatic u8\nread_utility(void *dev, unsigned long ubus_addr)\n{\n\tstruct idt77252_dev *card = dev;\n\tunsigned long flags;\n\tu8 value;\n\n\tif (!card) {\n\t\tprintk(\"Error: No such device.\\n\");\n\t\treturn -1;\n\t}\n\n\tspin_lock_irqsave(&card->cmd_lock, flags);\n\twritel(SAR_CMD_READ_UTILITY + ubus_addr, SAR_REG_CMD);\n\twaitfor_idle(card);\n\tvalue = readl(SAR_REG_DR0);\n\tspin_unlock_irqrestore(&card->cmd_lock, flags);\n\treturn value;\n}\n\nstatic void\nwrite_utility(void *dev, unsigned long ubus_addr, u8 value)\n{\n\tstruct idt77252_dev *card = dev;\n\tunsigned long flags;\n\n\tif (!card) {\n\t\tprintk(\"Error: No such device.\\n\");\n\t\treturn;\n\t}\n\n\tspin_lock_irqsave(&card->cmd_lock, flags);\n\twritel((u32) value, SAR_REG_DR0);\n\twritel(SAR_CMD_WRITE_UTILITY + ubus_addr, SAR_REG_CMD);\n\twaitfor_idle(card);\n\tspin_unlock_irqrestore(&card->cmd_lock, flags);\n}\n\n#ifdef HAVE_EEPROM\nstatic u32 rdsrtab[] =\n{\n\tSAR_GP_EECS | SAR_GP_EESCLK,\n\t0,\n\tSAR_GP_EESCLK,\t\t\t \n\t0,\n\tSAR_GP_EESCLK,\t\t\t \n\t0,\n\tSAR_GP_EESCLK,\t\t\t \n\t0,\n\tSAR_GP_EESCLK,\t\t\t \n\t0,\n\tSAR_GP_EESCLK,\t\t\t \n\tSAR_GP_EEDO,\n\tSAR_GP_EESCLK | SAR_GP_EEDO,\t \n\t0,\n\tSAR_GP_EESCLK,\t\t\t \n\tSAR_GP_EEDO,\n\tSAR_GP_EESCLK | SAR_GP_EEDO\t \n};\n\nstatic u32 wrentab[] =\n{\n\tSAR_GP_EECS | SAR_GP_EESCLK,\n\t0,\n\tSAR_GP_EESCLK,\t\t\t \n\t0,\n\tSAR_GP_EESCLK,\t\t\t \n\t0,\n\tSAR_GP_EESCLK,\t\t\t \n\t0,\n\tSAR_GP_EESCLK,\t\t\t \n\tSAR_GP_EEDO,\n\tSAR_GP_EESCLK | SAR_GP_EEDO,\t \n\tSAR_GP_EEDO,\n\tSAR_GP_EESCLK | SAR_GP_EEDO,\t \n\t0,\n\tSAR_GP_EESCLK,\t\t\t \n\t0,\n\tSAR_GP_EESCLK\t\t\t \n};\n\nstatic u32 rdtab[] =\n{\n\tSAR_GP_EECS | SAR_GP_EESCLK,\n\t0,\n\tSAR_GP_EESCLK,\t\t\t \n\t0,\n\tSAR_GP_EESCLK,\t\t\t \n\t0,\n\tSAR_GP_EESCLK,\t\t\t \n\t0,\n\tSAR_GP_EESCLK,\t\t\t \n\t0,\n\tSAR_GP_EESCLK,\t\t\t \n\t0,\n\tSAR_GP_EESCLK,\t\t\t \n\tSAR_GP_EEDO,\n\tSAR_GP_EESCLK | SAR_GP_EEDO,\t \n\tSAR_GP_EEDO,\n\tSAR_GP_EESCLK | SAR_GP_EEDO\t \n};\n\nstatic u32 wrtab[] =\n{\n\tSAR_GP_EECS | SAR_GP_EESCLK,\n\t0,\n\tSAR_GP_EESCLK,\t\t\t \n\t0,\n\tSAR_GP_EESCLK,\t\t\t \n\t0,\n\tSAR_GP_EESCLK,\t\t\t \n\t0,\n\tSAR_GP_EESCLK,\t\t\t \n\t0,\n\tSAR_GP_EESCLK,\t\t\t \n\t0,\n\tSAR_GP_EESCLK,\t\t\t \n\tSAR_GP_EEDO,\n\tSAR_GP_EESCLK | SAR_GP_EEDO,\t \n\t0,\n\tSAR_GP_EESCLK\t\t\t \n};\n\nstatic u32 clktab[] =\n{\n\t0,\n\tSAR_GP_EESCLK,\n\t0,\n\tSAR_GP_EESCLK,\n\t0,\n\tSAR_GP_EESCLK,\n\t0,\n\tSAR_GP_EESCLK,\n\t0,\n\tSAR_GP_EESCLK,\n\t0,\n\tSAR_GP_EESCLK,\n\t0,\n\tSAR_GP_EESCLK,\n\t0,\n\tSAR_GP_EESCLK,\n\t0\n};\n\nstatic u32\nidt77252_read_gp(struct idt77252_dev *card)\n{\n\tu32 gp;\n\n\tgp = readl(SAR_REG_GP);\n#if 0\n\tprintk(\"RD: %s\\n\", gp & SAR_GP_EEDI ? \"1\" : \"0\");\n#endif\n\treturn gp;\n}\n\nstatic void\nidt77252_write_gp(struct idt77252_dev *card, u32 value)\n{\n\tunsigned long flags;\n\n#if 0\n\tprintk(\"WR: %s %s %s\\n\", value & SAR_GP_EECS ? \"   \" : \"/CS\",\n\t       value & SAR_GP_EESCLK ? \"HIGH\" : \"LOW \",\n\t       value & SAR_GP_EEDO   ? \"1\" : \"0\");\n#endif\n\n\tspin_lock_irqsave(&card->cmd_lock, flags);\n\twaitfor_idle(card);\n\twritel(value, SAR_REG_GP);\n\tspin_unlock_irqrestore(&card->cmd_lock, flags);\n}\n\nstatic u8\nidt77252_eeprom_read_status(struct idt77252_dev *card)\n{\n\tu8 byte;\n\tu32 gp;\n\tint i, j;\n\n\tgp = idt77252_read_gp(card) & ~(SAR_GP_EESCLK|SAR_GP_EECS|SAR_GP_EEDO);\n\n\tfor (i = 0; i < ARRAY_SIZE(rdsrtab); i++) {\n\t\tidt77252_write_gp(card, gp | rdsrtab[i]);\n\t\tudelay(5);\n\t}\n\tidt77252_write_gp(card, gp | SAR_GP_EECS);\n\tudelay(5);\n\n\tbyte = 0;\n\tfor (i = 0, j = 0; i < 8; i++) {\n\t\tbyte <<= 1;\n\n\t\tidt77252_write_gp(card, gp | clktab[j++]);\n\t\tudelay(5);\n\n\t\tbyte |= idt77252_read_gp(card) & SAR_GP_EEDI ? 1 : 0;\n\n\t\tidt77252_write_gp(card, gp | clktab[j++]);\n\t\tudelay(5);\n\t}\n\tidt77252_write_gp(card, gp | SAR_GP_EECS);\n\tudelay(5);\n\n\treturn byte;\n}\n\nstatic u8\nidt77252_eeprom_read_byte(struct idt77252_dev *card, u8 offset)\n{\n\tu8 byte;\n\tu32 gp;\n\tint i, j;\n\n\tgp = idt77252_read_gp(card) & ~(SAR_GP_EESCLK|SAR_GP_EECS|SAR_GP_EEDO);\n\n\tfor (i = 0; i < ARRAY_SIZE(rdtab); i++) {\n\t\tidt77252_write_gp(card, gp | rdtab[i]);\n\t\tudelay(5);\n\t}\n\tidt77252_write_gp(card, gp | SAR_GP_EECS);\n\tudelay(5);\n\n\tfor (i = 0, j = 0; i < 8; i++) {\n\t\tidt77252_write_gp(card, gp | clktab[j++] |\n\t\t\t\t\t(offset & 1 ? SAR_GP_EEDO : 0));\n\t\tudelay(5);\n\n\t\tidt77252_write_gp(card, gp | clktab[j++] |\n\t\t\t\t\t(offset & 1 ? SAR_GP_EEDO : 0));\n\t\tudelay(5);\n\n\t\toffset >>= 1;\n\t}\n\tidt77252_write_gp(card, gp | SAR_GP_EECS);\n\tudelay(5);\n\n\tbyte = 0;\n\tfor (i = 0, j = 0; i < 8; i++) {\n\t\tbyte <<= 1;\n\n\t\tidt77252_write_gp(card, gp | clktab[j++]);\n\t\tudelay(5);\n\n\t\tbyte |= idt77252_read_gp(card) & SAR_GP_EEDI ? 1 : 0;\n\n\t\tidt77252_write_gp(card, gp | clktab[j++]);\n\t\tudelay(5);\n\t}\n\tidt77252_write_gp(card, gp | SAR_GP_EECS);\n\tudelay(5);\n\n\treturn byte;\n}\n\nstatic void\nidt77252_eeprom_write_byte(struct idt77252_dev *card, u8 offset, u8 data)\n{\n\tu32 gp;\n\tint i, j;\n\n\tgp = idt77252_read_gp(card) & ~(SAR_GP_EESCLK|SAR_GP_EECS|SAR_GP_EEDO);\n\n\tfor (i = 0; i < ARRAY_SIZE(wrentab); i++) {\n\t\tidt77252_write_gp(card, gp | wrentab[i]);\n\t\tudelay(5);\n\t}\n\tidt77252_write_gp(card, gp | SAR_GP_EECS);\n\tudelay(5);\n\n\tfor (i = 0; i < ARRAY_SIZE(wrtab); i++) {\n\t\tidt77252_write_gp(card, gp | wrtab[i]);\n\t\tudelay(5);\n\t}\n\tidt77252_write_gp(card, gp | SAR_GP_EECS);\n\tudelay(5);\n\n\tfor (i = 0, j = 0; i < 8; i++) {\n\t\tidt77252_write_gp(card, gp | clktab[j++] |\n\t\t\t\t\t(offset & 1 ? SAR_GP_EEDO : 0));\n\t\tudelay(5);\n\n\t\tidt77252_write_gp(card, gp | clktab[j++] |\n\t\t\t\t\t(offset & 1 ? SAR_GP_EEDO : 0));\n\t\tudelay(5);\n\n\t\toffset >>= 1;\n\t}\n\tidt77252_write_gp(card, gp | SAR_GP_EECS);\n\tudelay(5);\n\n\tfor (i = 0, j = 0; i < 8; i++) {\n\t\tidt77252_write_gp(card, gp | clktab[j++] |\n\t\t\t\t\t(data & 1 ? SAR_GP_EEDO : 0));\n\t\tudelay(5);\n\n\t\tidt77252_write_gp(card, gp | clktab[j++] |\n\t\t\t\t\t(data & 1 ? SAR_GP_EEDO : 0));\n\t\tudelay(5);\n\n\t\tdata >>= 1;\n\t}\n\tidt77252_write_gp(card, gp | SAR_GP_EECS);\n\tudelay(5);\n}\n\nstatic void\nidt77252_eeprom_init(struct idt77252_dev *card)\n{\n\tu32 gp;\n\n\tgp = idt77252_read_gp(card) & ~(SAR_GP_EESCLK|SAR_GP_EECS|SAR_GP_EEDO);\n\n\tidt77252_write_gp(card, gp | SAR_GP_EECS | SAR_GP_EESCLK);\n\tudelay(5);\n\tidt77252_write_gp(card, gp | SAR_GP_EECS);\n\tudelay(5);\n\tidt77252_write_gp(card, gp | SAR_GP_EECS | SAR_GP_EESCLK);\n\tudelay(5);\n\tidt77252_write_gp(card, gp | SAR_GP_EECS);\n\tudelay(5);\n}\n#endif  \n\n\n#ifdef CONFIG_ATM_IDT77252_DEBUG\nstatic void\ndump_tct(struct idt77252_dev *card, int index)\n{\n\tunsigned long tct;\n\tint i;\n\n\ttct = (unsigned long) (card->tct_base + index * SAR_SRAM_TCT_SIZE);\n\n\tprintk(\"%s: TCT %x:\", card->name, index);\n\tfor (i = 0; i < 8; i++) {\n\t\tprintk(\" %08x\", read_sram(card, tct + i));\n\t}\n\tprintk(\"\\n\");\n}\n\nstatic void\nidt77252_tx_dump(struct idt77252_dev *card)\n{\n\tstruct atm_vcc *vcc;\n\tstruct vc_map *vc;\n\tint i;\n\n\tprintk(\"%s\\n\", __func__);\n\tfor (i = 0; i < card->tct_size; i++) {\n\t\tvc = card->vcs[i];\n\t\tif (!vc)\n\t\t\tcontinue;\n\n\t\tvcc = NULL;\n\t\tif (vc->rx_vcc)\n\t\t\tvcc = vc->rx_vcc;\n\t\telse if (vc->tx_vcc)\n\t\t\tvcc = vc->tx_vcc;\n\n\t\tif (!vcc)\n\t\t\tcontinue;\n\n\t\tprintk(\"%s: Connection %d:\\n\", card->name, vc->index);\n\t\tdump_tct(card, vc->index);\n\t}\n}\n#endif\n\n\n \n \n \n \n \n\nstatic int\nsb_pool_add(struct idt77252_dev *card, struct sk_buff *skb, int queue)\n{\n\tstruct sb_pool *pool = &card->sbpool[queue];\n\tint index;\n\n\tindex = pool->index;\n\twhile (pool->skb[index]) {\n\t\tindex = (index + 1) & FBQ_MASK;\n\t\tif (index == pool->index)\n\t\t\treturn -ENOBUFS;\n\t}\n\n\tpool->skb[index] = skb;\n\tIDT77252_PRV_POOL(skb) = POOL_HANDLE(queue, index);\n\n\tpool->index = (index + 1) & FBQ_MASK;\n\treturn 0;\n}\n\nstatic void\nsb_pool_remove(struct idt77252_dev *card, struct sk_buff *skb)\n{\n\tunsigned int queue, index;\n\tu32 handle;\n\n\thandle = IDT77252_PRV_POOL(skb);\n\n\tqueue = POOL_QUEUE(handle);\n\tif (queue > 3)\n\t\treturn;\n\n\tindex = POOL_INDEX(handle);\n\tif (index > FBQ_SIZE - 1)\n\t\treturn;\n\n\tcard->sbpool[queue].skb[index] = NULL;\n}\n\nstatic struct sk_buff *\nsb_pool_skb(struct idt77252_dev *card, u32 handle)\n{\n\tunsigned int queue, index;\n\n\tqueue = POOL_QUEUE(handle);\n\tif (queue > 3)\n\t\treturn NULL;\n\n\tindex = POOL_INDEX(handle);\n\tif (index > FBQ_SIZE - 1)\n\t\treturn NULL;\n\n\treturn card->sbpool[queue].skb[index];\n}\n\nstatic struct scq_info *\nalloc_scq(struct idt77252_dev *card, int class)\n{\n\tstruct scq_info *scq;\n\n\tscq = kzalloc(sizeof(struct scq_info), GFP_KERNEL);\n\tif (!scq)\n\t\treturn NULL;\n\tscq->base = dma_alloc_coherent(&card->pcidev->dev, SCQ_SIZE,\n\t\t\t\t       &scq->paddr, GFP_KERNEL);\n\tif (scq->base == NULL) {\n\t\tkfree(scq);\n\t\treturn NULL;\n\t}\n\n\tscq->next = scq->base;\n\tscq->last = scq->base + (SCQ_ENTRIES - 1);\n\tatomic_set(&scq->used, 0);\n\n\tspin_lock_init(&scq->lock);\n\tspin_lock_init(&scq->skblock);\n\n\tskb_queue_head_init(&scq->transmit);\n\tskb_queue_head_init(&scq->pending);\n\n\tTXPRINTK(\"idt77252: SCQ: base 0x%p, next 0x%p, last 0x%p, paddr %08llx\\n\",\n\t\t scq->base, scq->next, scq->last, (unsigned long long)scq->paddr);\n\n\treturn scq;\n}\n\nstatic void\nfree_scq(struct idt77252_dev *card, struct scq_info *scq)\n{\n\tstruct sk_buff *skb;\n\tstruct atm_vcc *vcc;\n\n\tdma_free_coherent(&card->pcidev->dev, SCQ_SIZE,\n\t\t\t  scq->base, scq->paddr);\n\n\twhile ((skb = skb_dequeue(&scq->transmit))) {\n\t\tdma_unmap_single(&card->pcidev->dev, IDT77252_PRV_PADDR(skb),\n\t\t\t\t skb->len, DMA_TO_DEVICE);\n\n\t\tvcc = ATM_SKB(skb)->vcc;\n\t\tif (vcc->pop)\n\t\t\tvcc->pop(vcc, skb);\n\t\telse\n\t\t\tdev_kfree_skb(skb);\n\t}\n\n\twhile ((skb = skb_dequeue(&scq->pending))) {\n\t\tdma_unmap_single(&card->pcidev->dev, IDT77252_PRV_PADDR(skb),\n\t\t\t\t skb->len, DMA_TO_DEVICE);\n\n\t\tvcc = ATM_SKB(skb)->vcc;\n\t\tif (vcc->pop)\n\t\t\tvcc->pop(vcc, skb);\n\t\telse\n\t\t\tdev_kfree_skb(skb);\n\t}\n\n\tkfree(scq);\n}\n\n\nstatic int\npush_on_scq(struct idt77252_dev *card, struct vc_map *vc, struct sk_buff *skb)\n{\n\tstruct scq_info *scq = vc->scq;\n\tunsigned long flags;\n\tstruct scqe *tbd;\n\tint entries;\n\n\tTXPRINTK(\"%s: SCQ: next 0x%p\\n\", card->name, scq->next);\n\n\tatomic_inc(&scq->used);\n\tentries = atomic_read(&scq->used);\n\tif (entries > (SCQ_ENTRIES - 1)) {\n\t\tatomic_dec(&scq->used);\n\t\tgoto out;\n\t}\n\n\tskb_queue_tail(&scq->transmit, skb);\n\n\tspin_lock_irqsave(&vc->lock, flags);\n\tif (vc->estimator) {\n\t\tstruct atm_vcc *vcc = vc->tx_vcc;\n\t\tstruct sock *sk = sk_atm(vcc);\n\n\t\tvc->estimator->cells += (skb->len + 47) / 48;\n\t\tif (refcount_read(&sk->sk_wmem_alloc) >\n\t\t    (sk->sk_sndbuf >> 1)) {\n\t\t\tu32 cps = vc->estimator->maxcps;\n\n\t\t\tvc->estimator->cps = cps;\n\t\t\tvc->estimator->avcps = cps << 5;\n\t\t\tif (vc->lacr < vc->init_er) {\n\t\t\t\tvc->lacr = vc->init_er;\n\t\t\t\twritel(TCMDQ_LACR | (vc->lacr << 16) |\n\t\t\t\t       vc->index, SAR_REG_TCMDQ);\n\t\t\t}\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&vc->lock, flags);\n\n\ttbd = &IDT77252_PRV_TBD(skb);\n\n\tspin_lock_irqsave(&scq->lock, flags);\n\tscq->next->word_1 = cpu_to_le32(tbd->word_1 |\n\t\t\t\t\tSAR_TBD_TSIF | SAR_TBD_GTSI);\n\tscq->next->word_2 = cpu_to_le32(tbd->word_2);\n\tscq->next->word_3 = cpu_to_le32(tbd->word_3);\n\tscq->next->word_4 = cpu_to_le32(tbd->word_4);\n\n\tif (scq->next == scq->last)\n\t\tscq->next = scq->base;\n\telse\n\t\tscq->next++;\n\n\twrite_sram(card, scq->scd,\n\t\t   scq->paddr +\n\t\t   (u32)((unsigned long)scq->next - (unsigned long)scq->base));\n\tspin_unlock_irqrestore(&scq->lock, flags);\n\n\tscq->trans_start = jiffies;\n\n\tif (test_and_clear_bit(VCF_IDLE, &vc->flags)) {\n\t\twritel(TCMDQ_START_LACR | (vc->lacr << 16) | vc->index,\n\t\t       SAR_REG_TCMDQ);\n\t}\n\n\tTXPRINTK(\"%d entries in SCQ used (push).\\n\", atomic_read(&scq->used));\n\n\tXPRINTK(\"%s: SCQ (after push %2d) head = 0x%x, next = 0x%p.\\n\",\n\t\tcard->name, atomic_read(&scq->used),\n\t\tread_sram(card, scq->scd + 1), scq->next);\n\n\treturn 0;\n\nout:\n\tif (time_after(jiffies, scq->trans_start + HZ)) {\n\t\tprintk(\"%s: Error pushing TBD for %d.%d\\n\",\n\t\t       card->name, vc->tx_vcc->vpi, vc->tx_vcc->vci);\n#ifdef CONFIG_ATM_IDT77252_DEBUG\n\t\tidt77252_tx_dump(card);\n#endif\n\t\tscq->trans_start = jiffies;\n\t}\n\n\treturn -ENOBUFS;\n}\n\n\nstatic void\ndrain_scq(struct idt77252_dev *card, struct vc_map *vc)\n{\n\tstruct scq_info *scq = vc->scq;\n\tstruct sk_buff *skb;\n\tstruct atm_vcc *vcc;\n\n\tTXPRINTK(\"%s: SCQ (before drain %2d) next = 0x%p.\\n\",\n\t\t card->name, atomic_read(&scq->used), scq->next);\n\n\tskb = skb_dequeue(&scq->transmit);\n\tif (skb) {\n\t\tTXPRINTK(\"%s: freeing skb at %p.\\n\", card->name, skb);\n\n\t\tdma_unmap_single(&card->pcidev->dev, IDT77252_PRV_PADDR(skb),\n\t\t\t\t skb->len, DMA_TO_DEVICE);\n\n\t\tvcc = ATM_SKB(skb)->vcc;\n\n\t\tif (vcc->pop)\n\t\t\tvcc->pop(vcc, skb);\n\t\telse\n\t\t\tdev_kfree_skb(skb);\n\n\t\tatomic_inc(&vcc->stats->tx);\n\t}\n\n\tatomic_dec(&scq->used);\n\n\tspin_lock(&scq->skblock);\n\twhile ((skb = skb_dequeue(&scq->pending))) {\n\t\tif (push_on_scq(card, vc, skb)) {\n\t\t\tskb_queue_head(&vc->scq->pending, skb);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&scq->skblock);\n}\n\nstatic int\nqueue_skb(struct idt77252_dev *card, struct vc_map *vc,\n\t  struct sk_buff *skb, int oam)\n{\n\tstruct atm_vcc *vcc;\n\tstruct scqe *tbd;\n\tunsigned long flags;\n\tint error;\n\tint aal;\n\tu32 word4;\n\n\tif (skb->len == 0) {\n\t\tprintk(\"%s: invalid skb->len (%d)\\n\", card->name, skb->len);\n\t\treturn -EINVAL;\n\t}\n\n\tTXPRINTK(\"%s: Sending %d bytes of data.\\n\",\n\t\t card->name, skb->len);\n\n\ttbd = &IDT77252_PRV_TBD(skb);\n\tvcc = ATM_SKB(skb)->vcc;\n\tword4 = (skb->data[0] << 24) | (skb->data[1] << 16) |\n\t\t\t(skb->data[2] <<  8) | (skb->data[3] <<  0);\n\n\tIDT77252_PRV_PADDR(skb) = dma_map_single(&card->pcidev->dev, skb->data,\n\t\t\t\t\t\t skb->len, DMA_TO_DEVICE);\n\n\terror = -EINVAL;\n\n\tif (oam) {\n\t\tif (skb->len != 52)\n\t\t\tgoto errout;\n\n\t\ttbd->word_1 = SAR_TBD_OAM | ATM_CELL_PAYLOAD | SAR_TBD_EPDU;\n\t\ttbd->word_2 = IDT77252_PRV_PADDR(skb) + 4;\n\t\ttbd->word_3 = 0x00000000;\n\t\ttbd->word_4 = word4;\n\n\t\tif (test_bit(VCF_RSV, &vc->flags))\n\t\t\tvc = card->vcs[0];\n\n\t\tgoto done;\n\t}\n\n\tif (test_bit(VCF_RSV, &vc->flags)) {\n\t\tprintk(\"%s: Trying to transmit on reserved VC\\n\", card->name);\n\t\tgoto errout;\n\t}\n\n\taal = vcc->qos.aal;\n\n\tswitch (aal) {\n\tcase ATM_AAL0:\n\tcase ATM_AAL34:\n\t\tif (skb->len > 52)\n\t\t\tgoto errout;\n\n\t\tif (aal == ATM_AAL0)\n\t\t\ttbd->word_1 = SAR_TBD_EPDU | SAR_TBD_AAL0 |\n\t\t\t\t      ATM_CELL_PAYLOAD;\n\t\telse\n\t\t\ttbd->word_1 = SAR_TBD_EPDU | SAR_TBD_AAL34 |\n\t\t\t\t      ATM_CELL_PAYLOAD;\n\n\t\ttbd->word_2 = IDT77252_PRV_PADDR(skb) + 4;\n\t\ttbd->word_3 = 0x00000000;\n\t\ttbd->word_4 = word4;\n\t\tbreak;\n\n\tcase ATM_AAL5:\n\t\ttbd->word_1 = SAR_TBD_EPDU | SAR_TBD_AAL5 | skb->len;\n\t\ttbd->word_2 = IDT77252_PRV_PADDR(skb);\n\t\ttbd->word_3 = skb->len;\n\t\ttbd->word_4 = (vcc->vpi << SAR_TBD_VPI_SHIFT) |\n\t\t\t      (vcc->vci << SAR_TBD_VCI_SHIFT);\n\t\tbreak;\n\n\tcase ATM_AAL1:\n\tcase ATM_AAL2:\n\tdefault:\n\t\tprintk(\"%s: Traffic type not supported.\\n\", card->name);\n\t\terror = -EPROTONOSUPPORT;\n\t\tgoto errout;\n\t}\n\ndone:\n\tspin_lock_irqsave(&vc->scq->skblock, flags);\n\tskb_queue_tail(&vc->scq->pending, skb);\n\n\twhile ((skb = skb_dequeue(&vc->scq->pending))) {\n\t\tif (push_on_scq(card, vc, skb)) {\n\t\t\tskb_queue_head(&vc->scq->pending, skb);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&vc->scq->skblock, flags);\n\n\treturn 0;\n\nerrout:\n\tdma_unmap_single(&card->pcidev->dev, IDT77252_PRV_PADDR(skb),\n\t\t\t skb->len, DMA_TO_DEVICE);\n\treturn error;\n}\n\nstatic unsigned long\nget_free_scd(struct idt77252_dev *card, struct vc_map *vc)\n{\n\tint i;\n\n\tfor (i = 0; i < card->scd_size; i++) {\n\t\tif (!card->scd2vc[i]) {\n\t\t\tcard->scd2vc[i] = vc;\n\t\t\tvc->scd_index = i;\n\t\t\treturn card->scd_base + i * SAR_SRAM_SCD_SIZE;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic void\nfill_scd(struct idt77252_dev *card, struct scq_info *scq, int class)\n{\n\twrite_sram(card, scq->scd, scq->paddr);\n\twrite_sram(card, scq->scd + 1, 0x00000000);\n\twrite_sram(card, scq->scd + 2, 0xffffffff);\n\twrite_sram(card, scq->scd + 3, 0x00000000);\n}\n\nstatic void\nclear_scd(struct idt77252_dev *card, struct scq_info *scq, int class)\n{\n\treturn;\n}\n\n \n \n \n \n \n\nstatic int\ninit_rsq(struct idt77252_dev *card)\n{\n\tstruct rsq_entry *rsqe;\n\n\tcard->rsq.base = dma_alloc_coherent(&card->pcidev->dev, RSQSIZE,\n\t\t\t\t\t    &card->rsq.paddr, GFP_KERNEL);\n\tif (card->rsq.base == NULL) {\n\t\tprintk(\"%s: can't allocate RSQ.\\n\", card->name);\n\t\treturn -1;\n\t}\n\n\tcard->rsq.last = card->rsq.base + RSQ_NUM_ENTRIES - 1;\n\tcard->rsq.next = card->rsq.last;\n\tfor (rsqe = card->rsq.base; rsqe <= card->rsq.last; rsqe++)\n\t\trsqe->word_4 = 0;\n\n\twritel((unsigned long) card->rsq.last - (unsigned long) card->rsq.base,\n\t       SAR_REG_RSQH);\n\twritel(card->rsq.paddr, SAR_REG_RSQB);\n\n\tIPRINTK(\"%s: RSQ base at 0x%lx (0x%x).\\n\", card->name,\n\t\t(unsigned long) card->rsq.base,\n\t\treadl(SAR_REG_RSQB));\n\tIPRINTK(\"%s: RSQ head = 0x%x, base = 0x%x, tail = 0x%x.\\n\",\n\t\tcard->name,\n\t\treadl(SAR_REG_RSQH),\n\t\treadl(SAR_REG_RSQB),\n\t\treadl(SAR_REG_RSQT));\n\n\treturn 0;\n}\n\nstatic void\ndeinit_rsq(struct idt77252_dev *card)\n{\n\tdma_free_coherent(&card->pcidev->dev, RSQSIZE,\n\t\t\t  card->rsq.base, card->rsq.paddr);\n}\n\nstatic void\ndequeue_rx(struct idt77252_dev *card, struct rsq_entry *rsqe)\n{\n\tstruct atm_vcc *vcc;\n\tstruct sk_buff *skb;\n\tstruct rx_pool *rpp;\n\tstruct vc_map *vc;\n\tu32 header, vpi, vci;\n\tu32 stat;\n\tint i;\n\n\tstat = le32_to_cpu(rsqe->word_4);\n\n\tif (stat & SAR_RSQE_IDLE) {\n\t\tRXPRINTK(\"%s: message about inactive connection.\\n\",\n\t\t\t card->name);\n\t\treturn;\n\t}\n\n\tskb = sb_pool_skb(card, le32_to_cpu(rsqe->word_2));\n\tif (skb == NULL) {\n\t\tprintk(\"%s: NULL skb in %s, rsqe: %08x %08x %08x %08x\\n\",\n\t\t       card->name, __func__,\n\t\t       le32_to_cpu(rsqe->word_1), le32_to_cpu(rsqe->word_2),\n\t\t       le32_to_cpu(rsqe->word_3), le32_to_cpu(rsqe->word_4));\n\t\treturn;\n\t}\n\n\theader = le32_to_cpu(rsqe->word_1);\n\tvpi = (header >> 16) & 0x00ff;\n\tvci = (header >>  0) & 0xffff;\n\n\tRXPRINTK(\"%s: SDU for %d.%d received in buffer 0x%p (data 0x%p).\\n\",\n\t\t card->name, vpi, vci, skb, skb->data);\n\n\tif ((vpi >= (1 << card->vpibits)) || (vci != (vci & card->vcimask))) {\n\t\tprintk(\"%s: SDU received for out-of-range vc %u.%u\\n\",\n\t\t       card->name, vpi, vci);\n\t\trecycle_rx_skb(card, skb);\n\t\treturn;\n\t}\n\n\tvc = card->vcs[VPCI2VC(card, vpi, vci)];\n\tif (!vc || !test_bit(VCF_RX, &vc->flags)) {\n\t\tprintk(\"%s: SDU received on non RX vc %u.%u\\n\",\n\t\t       card->name, vpi, vci);\n\t\trecycle_rx_skb(card, skb);\n\t\treturn;\n\t}\n\n\tvcc = vc->rx_vcc;\n\n\tdma_sync_single_for_cpu(&card->pcidev->dev, IDT77252_PRV_PADDR(skb),\n\t\t\t\tskb_end_pointer(skb) - skb->data,\n\t\t\t\tDMA_FROM_DEVICE);\n\n\tif ((vcc->qos.aal == ATM_AAL0) ||\n\t    (vcc->qos.aal == ATM_AAL34)) {\n\t\tstruct sk_buff *sb;\n\t\tunsigned char *cell;\n\t\tu32 aal0;\n\n\t\tcell = skb->data;\n\t\tfor (i = (stat & SAR_RSQE_CELLCNT); i; i--) {\n\t\t\tif ((sb = dev_alloc_skb(64)) == NULL) {\n\t\t\t\tprintk(\"%s: Can't allocate buffers for aal0.\\n\",\n\t\t\t\t       card->name);\n\t\t\t\tatomic_add(i, &vcc->stats->rx_drop);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!atm_charge(vcc, sb->truesize)) {\n\t\t\t\tRXPRINTK(\"%s: atm_charge() dropped aal0 packets.\\n\",\n\t\t\t\t\t card->name);\n\t\t\t\tatomic_add(i - 1, &vcc->stats->rx_drop);\n\t\t\t\tdev_kfree_skb(sb);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\taal0 = (vpi << ATM_HDR_VPI_SHIFT) |\n\t\t\t       (vci << ATM_HDR_VCI_SHIFT);\n\t\t\taal0 |= (stat & SAR_RSQE_EPDU) ? 0x00000002 : 0;\n\t\t\taal0 |= (stat & SAR_RSQE_CLP)  ? 0x00000001 : 0;\n\n\t\t\t*((u32 *) sb->data) = aal0;\n\t\t\tskb_put(sb, sizeof(u32));\n\t\t\tskb_put_data(sb, cell, ATM_CELL_PAYLOAD);\n\n\t\t\tATM_SKB(sb)->vcc = vcc;\n\t\t\t__net_timestamp(sb);\n\t\t\tvcc->push(vcc, sb);\n\t\t\tatomic_inc(&vcc->stats->rx);\n\n\t\t\tcell += ATM_CELL_PAYLOAD;\n\t\t}\n\n\t\trecycle_rx_skb(card, skb);\n\t\treturn;\n\t}\n\tif (vcc->qos.aal != ATM_AAL5) {\n\t\tprintk(\"%s: Unexpected AAL type in dequeue_rx(): %d.\\n\",\n\t\t       card->name, vcc->qos.aal);\n\t\trecycle_rx_skb(card, skb);\n\t\treturn;\n\t}\n\tskb->len = (stat & SAR_RSQE_CELLCNT) * ATM_CELL_PAYLOAD;\n\n\trpp = &vc->rcv.rx_pool;\n\n\t__skb_queue_tail(&rpp->queue, skb);\n\trpp->len += skb->len;\n\n\tif (stat & SAR_RSQE_EPDU) {\n\t\tunsigned char *l1l2;\n\t\tunsigned int len;\n\n\t\tl1l2 = (unsigned char *) ((unsigned long) skb->data + skb->len - 6);\n\n\t\tlen = (l1l2[0] << 8) | l1l2[1];\n\t\tlen = len ? len : 0x10000;\n\n\t\tRXPRINTK(\"%s: PDU has %d bytes.\\n\", card->name, len);\n\n\t\tif ((len + 8 > rpp->len) || (len + (47 + 8) < rpp->len)) {\n\t\t\tRXPRINTK(\"%s: AAL5 PDU size mismatch: %d != %d. \"\n\t\t\t         \"(CDC: %08x)\\n\",\n\t\t\t         card->name, len, rpp->len, readl(SAR_REG_CDC));\n\t\t\trecycle_rx_pool_skb(card, rpp);\n\t\t\tatomic_inc(&vcc->stats->rx_err);\n\t\t\treturn;\n\t\t}\n\t\tif (stat & SAR_RSQE_CRC) {\n\t\t\tRXPRINTK(\"%s: AAL5 CRC error.\\n\", card->name);\n\t\t\trecycle_rx_pool_skb(card, rpp);\n\t\t\tatomic_inc(&vcc->stats->rx_err);\n\t\t\treturn;\n\t\t}\n\t\tif (skb_queue_len(&rpp->queue) > 1) {\n\t\t\tstruct sk_buff *sb;\n\n\t\t\tskb = dev_alloc_skb(rpp->len);\n\t\t\tif (!skb) {\n\t\t\t\tRXPRINTK(\"%s: Can't alloc RX skb.\\n\",\n\t\t\t\t\t card->name);\n\t\t\t\trecycle_rx_pool_skb(card, rpp);\n\t\t\t\tatomic_inc(&vcc->stats->rx_err);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (!atm_charge(vcc, skb->truesize)) {\n\t\t\t\trecycle_rx_pool_skb(card, rpp);\n\t\t\t\tdev_kfree_skb(skb);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tskb_queue_walk(&rpp->queue, sb)\n\t\t\t\tskb_put_data(skb, sb->data, sb->len);\n\n\t\t\trecycle_rx_pool_skb(card, rpp);\n\n\t\t\tskb_trim(skb, len);\n\t\t\tATM_SKB(skb)->vcc = vcc;\n\t\t\t__net_timestamp(skb);\n\n\t\t\tvcc->push(vcc, skb);\n\t\t\tatomic_inc(&vcc->stats->rx);\n\n\t\t\treturn;\n\t\t}\n\n\t\tflush_rx_pool(card, rpp);\n\n\t\tif (!atm_charge(vcc, skb->truesize)) {\n\t\t\trecycle_rx_skb(card, skb);\n\t\t\treturn;\n\t\t}\n\n\t\tdma_unmap_single(&card->pcidev->dev, IDT77252_PRV_PADDR(skb),\n\t\t\t\t skb_end_pointer(skb) - skb->data,\n\t\t\t\t DMA_FROM_DEVICE);\n\t\tsb_pool_remove(card, skb);\n\n\t\tskb_trim(skb, len);\n\t\tATM_SKB(skb)->vcc = vcc;\n\t\t__net_timestamp(skb);\n\n\t\tvcc->push(vcc, skb);\n\t\tatomic_inc(&vcc->stats->rx);\n\n\t\tif (skb->truesize > SAR_FB_SIZE_3)\n\t\t\tadd_rx_skb(card, 3, SAR_FB_SIZE_3, 1);\n\t\telse if (skb->truesize > SAR_FB_SIZE_2)\n\t\t\tadd_rx_skb(card, 2, SAR_FB_SIZE_2, 1);\n\t\telse if (skb->truesize > SAR_FB_SIZE_1)\n\t\t\tadd_rx_skb(card, 1, SAR_FB_SIZE_1, 1);\n\t\telse\n\t\t\tadd_rx_skb(card, 0, SAR_FB_SIZE_0, 1);\n\t\treturn;\n\t}\n}\n\nstatic void\nidt77252_rx(struct idt77252_dev *card)\n{\n\tstruct rsq_entry *rsqe;\n\n\tif (card->rsq.next == card->rsq.last)\n\t\trsqe = card->rsq.base;\n\telse\n\t\trsqe = card->rsq.next + 1;\n\n\tif (!(le32_to_cpu(rsqe->word_4) & SAR_RSQE_VALID)) {\n\t\tRXPRINTK(\"%s: no entry in RSQ.\\n\", card->name);\n\t\treturn;\n\t}\n\n\tdo {\n\t\tdequeue_rx(card, rsqe);\n\t\trsqe->word_4 = 0;\n\t\tcard->rsq.next = rsqe;\n\t\tif (card->rsq.next == card->rsq.last)\n\t\t\trsqe = card->rsq.base;\n\t\telse\n\t\t\trsqe = card->rsq.next + 1;\n\t} while (le32_to_cpu(rsqe->word_4) & SAR_RSQE_VALID);\n\n\twritel((unsigned long) card->rsq.next - (unsigned long) card->rsq.base,\n\t       SAR_REG_RSQH);\n}\n\nstatic void\nidt77252_rx_raw(struct idt77252_dev *card)\n{\n\tstruct sk_buff\t*queue;\n\tu32\t\thead, tail;\n\tstruct atm_vcc\t*vcc;\n\tstruct vc_map\t*vc;\n\tstruct sk_buff\t*sb;\n\n\tif (card->raw_cell_head == NULL) {\n\t\tu32 handle = le32_to_cpu(*(card->raw_cell_hnd + 1));\n\t\tcard->raw_cell_head = sb_pool_skb(card, handle);\n\t}\n\n\tqueue = card->raw_cell_head;\n\tif (!queue)\n\t\treturn;\n\n\thead = IDT77252_PRV_PADDR(queue) + (queue->data - queue->head - 16);\n\ttail = readl(SAR_REG_RAWCT);\n\n\tdma_sync_single_for_cpu(&card->pcidev->dev, IDT77252_PRV_PADDR(queue),\n\t\t\t\tskb_end_offset(queue) - 16,\n\t\t\t\tDMA_FROM_DEVICE);\n\n\twhile (head != tail) {\n\t\tunsigned int vpi, vci;\n\t\tu32 header;\n\n\t\theader = le32_to_cpu(*(u32 *) &queue->data[0]);\n\n\t\tvpi = (header & ATM_HDR_VPI_MASK) >> ATM_HDR_VPI_SHIFT;\n\t\tvci = (header & ATM_HDR_VCI_MASK) >> ATM_HDR_VCI_SHIFT;\n\n#ifdef CONFIG_ATM_IDT77252_DEBUG\n\t\tif (debug & DBG_RAW_CELL) {\n\t\t\tint i;\n\n\t\t\tprintk(\"%s: raw cell %x.%02x.%04x.%x.%x\\n\",\n\t\t\t       card->name, (header >> 28) & 0x000f,\n\t\t\t       (header >> 20) & 0x00ff,\n\t\t\t       (header >>  4) & 0xffff,\n\t\t\t       (header >>  1) & 0x0007,\n\t\t\t       (header >>  0) & 0x0001);\n\t\t\tfor (i = 16; i < 64; i++)\n\t\t\t\tprintk(\" %02x\", queue->data[i]);\n\t\t\tprintk(\"\\n\");\n\t\t}\n#endif\n\n\t\tif (vpi >= (1<<card->vpibits) || vci >= (1<<card->vcibits)) {\n\t\t\tRPRINTK(\"%s: SDU received for out-of-range vc %u.%u\\n\",\n\t\t\t\tcard->name, vpi, vci);\n\t\t\tgoto drop;\n\t\t}\n\n\t\tvc = card->vcs[VPCI2VC(card, vpi, vci)];\n\t\tif (!vc || !test_bit(VCF_RX, &vc->flags)) {\n\t\t\tRPRINTK(\"%s: SDU received on non RX vc %u.%u\\n\",\n\t\t\t\tcard->name, vpi, vci);\n\t\t\tgoto drop;\n\t\t}\n\n\t\tvcc = vc->rx_vcc;\n\n\t\tif (vcc->qos.aal != ATM_AAL0) {\n\t\t\tRPRINTK(\"%s: raw cell for non AAL0 vc %u.%u\\n\",\n\t\t\t\tcard->name, vpi, vci);\n\t\t\tatomic_inc(&vcc->stats->rx_drop);\n\t\t\tgoto drop;\n\t\t}\n\t\n\t\tif ((sb = dev_alloc_skb(64)) == NULL) {\n\t\t\tprintk(\"%s: Can't allocate buffers for AAL0.\\n\",\n\t\t\t       card->name);\n\t\t\tatomic_inc(&vcc->stats->rx_err);\n\t\t\tgoto drop;\n\t\t}\n\n\t\tif (!atm_charge(vcc, sb->truesize)) {\n\t\t\tRXPRINTK(\"%s: atm_charge() dropped AAL0 packets.\\n\",\n\t\t\t\t card->name);\n\t\t\tdev_kfree_skb(sb);\n\t\t\tgoto drop;\n\t\t}\n\n\t\t*((u32 *) sb->data) = header;\n\t\tskb_put(sb, sizeof(u32));\n\t\tskb_put_data(sb, &(queue->data[16]), ATM_CELL_PAYLOAD);\n\n\t\tATM_SKB(sb)->vcc = vcc;\n\t\t__net_timestamp(sb);\n\t\tvcc->push(vcc, sb);\n\t\tatomic_inc(&vcc->stats->rx);\n\ndrop:\n\t\tskb_pull(queue, 64);\n\n\t\thead = IDT77252_PRV_PADDR(queue)\n\t\t\t\t\t+ (queue->data - queue->head - 16);\n\n\t\tif (queue->len < 128) {\n\t\t\tstruct sk_buff *next;\n\t\t\tu32 handle;\n\n\t\t\thead = le32_to_cpu(*(u32 *) &queue->data[0]);\n\t\t\thandle = le32_to_cpu(*(u32 *) &queue->data[4]);\n\n\t\t\tnext = sb_pool_skb(card, handle);\n\t\t\trecycle_rx_skb(card, queue);\n\n\t\t\tif (next) {\n\t\t\t\tcard->raw_cell_head = next;\n\t\t\t\tqueue = card->raw_cell_head;\n\t\t\t\tdma_sync_single_for_cpu(&card->pcidev->dev,\n\t\t\t\t\t\t\tIDT77252_PRV_PADDR(queue),\n\t\t\t\t\t\t\t(skb_end_pointer(queue) -\n\t\t\t\t\t\t\t queue->data),\n\t\t\t\t\t\t\tDMA_FROM_DEVICE);\n\t\t\t} else {\n\t\t\t\tcard->raw_cell_head = NULL;\n\t\t\t\tprintk(\"%s: raw cell queue overrun\\n\",\n\t\t\t\t       card->name);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n \n \n \n \n \n\nstatic int\ninit_tsq(struct idt77252_dev *card)\n{\n\tstruct tsq_entry *tsqe;\n\n\tcard->tsq.base = dma_alloc_coherent(&card->pcidev->dev, RSQSIZE,\n\t\t\t\t\t    &card->tsq.paddr, GFP_KERNEL);\n\tif (card->tsq.base == NULL) {\n\t\tprintk(\"%s: can't allocate TSQ.\\n\", card->name);\n\t\treturn -1;\n\t}\n\n\tcard->tsq.last = card->tsq.base + TSQ_NUM_ENTRIES - 1;\n\tcard->tsq.next = card->tsq.last;\n\tfor (tsqe = card->tsq.base; tsqe <= card->tsq.last; tsqe++)\n\t\ttsqe->word_2 = cpu_to_le32(SAR_TSQE_INVALID);\n\n\twritel(card->tsq.paddr, SAR_REG_TSQB);\n\twritel((unsigned long) card->tsq.next - (unsigned long) card->tsq.base,\n\t       SAR_REG_TSQH);\n\n\treturn 0;\n}\n\nstatic void\ndeinit_tsq(struct idt77252_dev *card)\n{\n\tdma_free_coherent(&card->pcidev->dev, TSQSIZE,\n\t\t\t  card->tsq.base, card->tsq.paddr);\n}\n\nstatic void\nidt77252_tx(struct idt77252_dev *card)\n{\n\tstruct tsq_entry *tsqe;\n\tunsigned int vpi, vci;\n\tstruct vc_map *vc;\n\tu32 conn, stat;\n\n\tif (card->tsq.next == card->tsq.last)\n\t\ttsqe = card->tsq.base;\n\telse\n\t\ttsqe = card->tsq.next + 1;\n\n\tTXPRINTK(\"idt77252_tx: tsq  %p: base %p, next %p, last %p\\n\", tsqe,\n\t\t card->tsq.base, card->tsq.next, card->tsq.last);\n\tTXPRINTK(\"idt77252_tx: tsqb %08x, tsqt %08x, tsqh %08x, \\n\",\n\t\t readl(SAR_REG_TSQB),\n\t\t readl(SAR_REG_TSQT),\n\t\t readl(SAR_REG_TSQH));\n\n\tstat = le32_to_cpu(tsqe->word_2);\n\n\tif (stat & SAR_TSQE_INVALID)\n\t\treturn;\n\n\tdo {\n\t\tTXPRINTK(\"tsqe: 0x%p [0x%08x 0x%08x]\\n\", tsqe,\n\t\t\t le32_to_cpu(tsqe->word_1),\n\t\t\t le32_to_cpu(tsqe->word_2));\n\n\t\tswitch (stat & SAR_TSQE_TYPE) {\n\t\tcase SAR_TSQE_TYPE_TIMER:\n\t\t\tTXPRINTK(\"%s: Timer RollOver detected.\\n\", card->name);\n\t\t\tbreak;\n\n\t\tcase SAR_TSQE_TYPE_IDLE:\n\n\t\t\tconn = le32_to_cpu(tsqe->word_1);\n\n\t\t\tif (SAR_TSQE_TAG(stat) == 0x10) {\n#ifdef\tNOTDEF\n\t\t\t\tprintk(\"%s: Connection %d halted.\\n\",\n\t\t\t\t       card->name,\n\t\t\t\t       le32_to_cpu(tsqe->word_1) & 0x1fff);\n#endif\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tvc = card->vcs[conn & 0x1fff];\n\t\t\tif (!vc) {\n\t\t\t\tprintk(\"%s: could not find VC from conn %d\\n\",\n\t\t\t\t       card->name, conn & 0x1fff);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tprintk(\"%s: Connection %d IDLE.\\n\",\n\t\t\t       card->name, vc->index);\n\n\t\t\tset_bit(VCF_IDLE, &vc->flags);\n\t\t\tbreak;\n\n\t\tcase SAR_TSQE_TYPE_TSR:\n\n\t\t\tconn = le32_to_cpu(tsqe->word_1);\n\n\t\t\tvc = card->vcs[conn & 0x1fff];\n\t\t\tif (!vc) {\n\t\t\t\tprintk(\"%s: no VC at index %d\\n\",\n\t\t\t\t       card->name,\n\t\t\t\t       le32_to_cpu(tsqe->word_1) & 0x1fff);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tdrain_scq(card, vc);\n\t\t\tbreak;\n\n\t\tcase SAR_TSQE_TYPE_TBD_COMP:\n\n\t\t\tconn = le32_to_cpu(tsqe->word_1);\n\n\t\t\tvpi = (conn >> SAR_TBD_VPI_SHIFT) & 0x00ff;\n\t\t\tvci = (conn >> SAR_TBD_VCI_SHIFT) & 0xffff;\n\n\t\t\tif (vpi >= (1 << card->vpibits) ||\n\t\t\t    vci >= (1 << card->vcibits)) {\n\t\t\t\tprintk(\"%s: TBD complete: \"\n\t\t\t\t       \"out of range VPI.VCI %u.%u\\n\",\n\t\t\t\t       card->name, vpi, vci);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tvc = card->vcs[VPCI2VC(card, vpi, vci)];\n\t\t\tif (!vc) {\n\t\t\t\tprintk(\"%s: TBD complete: \"\n\t\t\t\t       \"no VC at VPI.VCI %u.%u\\n\",\n\t\t\t\t       card->name, vpi, vci);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tdrain_scq(card, vc);\n\t\t\tbreak;\n\t\t}\n\n\t\ttsqe->word_2 = cpu_to_le32(SAR_TSQE_INVALID);\n\n\t\tcard->tsq.next = tsqe;\n\t\tif (card->tsq.next == card->tsq.last)\n\t\t\ttsqe = card->tsq.base;\n\t\telse\n\t\t\ttsqe = card->tsq.next + 1;\n\n\t\tTXPRINTK(\"tsqe: %p: base %p, next %p, last %p\\n\", tsqe,\n\t\t\t card->tsq.base, card->tsq.next, card->tsq.last);\n\n\t\tstat = le32_to_cpu(tsqe->word_2);\n\n\t} while (!(stat & SAR_TSQE_INVALID));\n\n\twritel((unsigned long)card->tsq.next - (unsigned long)card->tsq.base,\n\t       SAR_REG_TSQH);\n\n\tXPRINTK(\"idt77252_tx-after writel%d: TSQ head = 0x%x, tail = 0x%x, next = 0x%p.\\n\",\n\t\tcard->index, readl(SAR_REG_TSQH),\n\t\treadl(SAR_REG_TSQT), card->tsq.next);\n}\n\n\nstatic void\ntst_timer(struct timer_list *t)\n{\n\tstruct idt77252_dev *card = from_timer(card, t, tst_timer);\n\tunsigned long base, idle, jump;\n\tunsigned long flags;\n\tu32 pc;\n\tint e;\n\n\tspin_lock_irqsave(&card->tst_lock, flags);\n\n\tbase = card->tst[card->tst_index];\n\tidle = card->tst[card->tst_index ^ 1];\n\n\tif (test_bit(TST_SWITCH_WAIT, &card->tst_state)) {\n\t\tjump = base + card->tst_size - 2;\n\n\t\tpc = readl(SAR_REG_NOW) >> 2;\n\t\tif ((pc ^ idle) & ~(card->tst_size - 1)) {\n\t\t\tmod_timer(&card->tst_timer, jiffies + 1);\n\t\t\tgoto out;\n\t\t}\n\n\t\tclear_bit(TST_SWITCH_WAIT, &card->tst_state);\n\n\t\tcard->tst_index ^= 1;\n\t\twrite_sram(card, jump, TSTE_OPC_JMP | (base << 2));\n\n\t\tbase = card->tst[card->tst_index];\n\t\tidle = card->tst[card->tst_index ^ 1];\n\n\t\tfor (e = 0; e < card->tst_size - 2; e++) {\n\t\t\tif (card->soft_tst[e].tste & TSTE_PUSH_IDLE) {\n\t\t\t\twrite_sram(card, idle + e,\n\t\t\t\t\t   card->soft_tst[e].tste & TSTE_MASK);\n\t\t\t\tcard->soft_tst[e].tste &= ~(TSTE_PUSH_IDLE);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (test_and_clear_bit(TST_SWITCH_PENDING, &card->tst_state)) {\n\n\t\tfor (e = 0; e < card->tst_size - 2; e++) {\n\t\t\tif (card->soft_tst[e].tste & TSTE_PUSH_ACTIVE) {\n\t\t\t\twrite_sram(card, idle + e,\n\t\t\t\t\t   card->soft_tst[e].tste & TSTE_MASK);\n\t\t\t\tcard->soft_tst[e].tste &= ~(TSTE_PUSH_ACTIVE);\n\t\t\t\tcard->soft_tst[e].tste |= TSTE_PUSH_IDLE;\n\t\t\t}\n\t\t}\n\n\t\tjump = base + card->tst_size - 2;\n\n\t\twrite_sram(card, jump, TSTE_OPC_NULL);\n\t\tset_bit(TST_SWITCH_WAIT, &card->tst_state);\n\n\t\tmod_timer(&card->tst_timer, jiffies + 1);\n\t}\n\nout:\n\tspin_unlock_irqrestore(&card->tst_lock, flags);\n}\n\nstatic int\n__fill_tst(struct idt77252_dev *card, struct vc_map *vc,\n\t   int n, unsigned int opc)\n{\n\tunsigned long cl, avail;\n\tunsigned long idle;\n\tint e, r;\n\tu32 data;\n\n\tavail = card->tst_size - 2;\n\tfor (e = 0; e < avail; e++) {\n\t\tif (card->soft_tst[e].vc == NULL)\n\t\t\tbreak;\n\t}\n\tif (e >= avail) {\n\t\tprintk(\"%s: No free TST entries found\\n\", card->name);\n\t\treturn -1;\n\t}\n\n\tNPRINTK(\"%s: conn %d: first TST entry at %d.\\n\",\n\t\tcard->name, vc ? vc->index : -1, e);\n\n\tr = n;\n\tcl = avail;\n\tdata = opc & TSTE_OPC_MASK;\n\tif (vc && (opc != TSTE_OPC_NULL))\n\t\tdata = opc | vc->index;\n\n\tidle = card->tst[card->tst_index ^ 1];\n\n\t \n\twhile (r > 0) {\n\t\tif ((cl >= avail) && (card->soft_tst[e].vc == NULL)) {\n\t\t\tif (vc)\n\t\t\t\tcard->soft_tst[e].vc = vc;\n\t\t\telse\n\t\t\t\tcard->soft_tst[e].vc = (void *)-1;\n\n\t\t\tcard->soft_tst[e].tste = data;\n\t\t\tif (timer_pending(&card->tst_timer))\n\t\t\t\tcard->soft_tst[e].tste |= TSTE_PUSH_ACTIVE;\n\t\t\telse {\n\t\t\t\twrite_sram(card, idle + e, data);\n\t\t\t\tcard->soft_tst[e].tste |= TSTE_PUSH_IDLE;\n\t\t\t}\n\n\t\t\tcl -= card->tst_size;\n\t\t\tr--;\n\t\t}\n\n\t\tif (++e == avail)\n\t\t\te = 0;\n\t\tcl += n;\n\t}\n\n\treturn 0;\n}\n\nstatic int\nfill_tst(struct idt77252_dev *card, struct vc_map *vc, int n, unsigned int opc)\n{\n\tunsigned long flags;\n\tint res;\n\n\tspin_lock_irqsave(&card->tst_lock, flags);\n\n\tres = __fill_tst(card, vc, n, opc);\n\n\tset_bit(TST_SWITCH_PENDING, &card->tst_state);\n\tif (!timer_pending(&card->tst_timer))\n\t\tmod_timer(&card->tst_timer, jiffies + 1);\n\n\tspin_unlock_irqrestore(&card->tst_lock, flags);\n\treturn res;\n}\n\nstatic int\n__clear_tst(struct idt77252_dev *card, struct vc_map *vc)\n{\n\tunsigned long idle;\n\tint e;\n\n\tidle = card->tst[card->tst_index ^ 1];\n\n\tfor (e = 0; e < card->tst_size - 2; e++) {\n\t\tif (card->soft_tst[e].vc == vc) {\n\t\t\tcard->soft_tst[e].vc = NULL;\n\n\t\t\tcard->soft_tst[e].tste = TSTE_OPC_VAR;\n\t\t\tif (timer_pending(&card->tst_timer))\n\t\t\t\tcard->soft_tst[e].tste |= TSTE_PUSH_ACTIVE;\n\t\t\telse {\n\t\t\t\twrite_sram(card, idle + e, TSTE_OPC_VAR);\n\t\t\t\tcard->soft_tst[e].tste |= TSTE_PUSH_IDLE;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int\nclear_tst(struct idt77252_dev *card, struct vc_map *vc)\n{\n\tunsigned long flags;\n\tint res;\n\n\tspin_lock_irqsave(&card->tst_lock, flags);\n\n\tres = __clear_tst(card, vc);\n\n\tset_bit(TST_SWITCH_PENDING, &card->tst_state);\n\tif (!timer_pending(&card->tst_timer))\n\t\tmod_timer(&card->tst_timer, jiffies + 1);\n\n\tspin_unlock_irqrestore(&card->tst_lock, flags);\n\treturn res;\n}\n\nstatic int\nchange_tst(struct idt77252_dev *card, struct vc_map *vc,\n\t   int n, unsigned int opc)\n{\n\tunsigned long flags;\n\tint res;\n\n\tspin_lock_irqsave(&card->tst_lock, flags);\n\n\t__clear_tst(card, vc);\n\tres = __fill_tst(card, vc, n, opc);\n\n\tset_bit(TST_SWITCH_PENDING, &card->tst_state);\n\tif (!timer_pending(&card->tst_timer))\n\t\tmod_timer(&card->tst_timer, jiffies + 1);\n\n\tspin_unlock_irqrestore(&card->tst_lock, flags);\n\treturn res;\n}\n\n\nstatic int\nset_tct(struct idt77252_dev *card, struct vc_map *vc)\n{\n\tunsigned long tct;\n\n\ttct = (unsigned long) (card->tct_base + vc->index * SAR_SRAM_TCT_SIZE);\n\n\tswitch (vc->class) {\n\tcase SCHED_CBR:\n\t\tOPRINTK(\"%s: writing TCT at 0x%lx, SCD 0x%lx.\\n\",\n\t\t        card->name, tct, vc->scq->scd);\n\n\t\twrite_sram(card, tct + 0, TCT_CBR | vc->scq->scd);\n\t\twrite_sram(card, tct + 1, 0);\n\t\twrite_sram(card, tct + 2, 0);\n\t\twrite_sram(card, tct + 3, 0);\n\t\twrite_sram(card, tct + 4, 0);\n\t\twrite_sram(card, tct + 5, 0);\n\t\twrite_sram(card, tct + 6, 0);\n\t\twrite_sram(card, tct + 7, 0);\n\t\tbreak;\n\n\tcase SCHED_UBR:\n\t\tOPRINTK(\"%s: writing TCT at 0x%lx, SCD 0x%lx.\\n\",\n\t\t        card->name, tct, vc->scq->scd);\n\n\t\twrite_sram(card, tct + 0, TCT_UBR | vc->scq->scd);\n\t\twrite_sram(card, tct + 1, 0);\n\t\twrite_sram(card, tct + 2, TCT_TSIF);\n\t\twrite_sram(card, tct + 3, TCT_HALT | TCT_IDLE);\n\t\twrite_sram(card, tct + 4, 0);\n\t\twrite_sram(card, tct + 5, vc->init_er);\n\t\twrite_sram(card, tct + 6, 0);\n\t\twrite_sram(card, tct + 7, TCT_FLAG_UBR);\n\t\tbreak;\n\n\tcase SCHED_VBR:\n\tcase SCHED_ABR:\n\tdefault:\n\t\treturn -ENOSYS;\n\t}\n\n\treturn 0;\n}\n\n \n \n \n \n \n\nstatic __inline__ int\nidt77252_fbq_full(struct idt77252_dev *card, int queue)\n{\n\treturn (readl(SAR_REG_STAT) >> (16 + (queue << 2))) == 0x0f;\n}\n\nstatic int\npush_rx_skb(struct idt77252_dev *card, struct sk_buff *skb, int queue)\n{\n\tunsigned long flags;\n\tu32 handle;\n\tu32 addr;\n\n\tskb->data = skb->head;\n\tskb_reset_tail_pointer(skb);\n\tskb->len = 0;\n\n\tskb_reserve(skb, 16);\n\n\tswitch (queue) {\n\tcase 0:\n\t\tskb_put(skb, SAR_FB_SIZE_0);\n\t\tbreak;\n\tcase 1:\n\t\tskb_put(skb, SAR_FB_SIZE_1);\n\t\tbreak;\n\tcase 2:\n\t\tskb_put(skb, SAR_FB_SIZE_2);\n\t\tbreak;\n\tcase 3:\n\t\tskb_put(skb, SAR_FB_SIZE_3);\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\n\tif (idt77252_fbq_full(card, queue))\n\t\treturn -1;\n\n\tmemset(&skb->data[(skb->len & ~(0x3f)) - 64], 0, 2 * sizeof(u32));\n\n\thandle = IDT77252_PRV_POOL(skb);\n\taddr = IDT77252_PRV_PADDR(skb);\n\n\tspin_lock_irqsave(&card->cmd_lock, flags);\n\twritel(handle, card->fbq[queue]);\n\twritel(addr, card->fbq[queue]);\n\tspin_unlock_irqrestore(&card->cmd_lock, flags);\n\n\treturn 0;\n}\n\nstatic void\nadd_rx_skb(struct idt77252_dev *card, int queue,\n\t   unsigned int size, unsigned int count)\n{\n\tstruct sk_buff *skb;\n\tdma_addr_t paddr;\n\tu32 handle;\n\n\twhile (count--) {\n\t\tskb = dev_alloc_skb(size);\n\t\tif (!skb)\n\t\t\treturn;\n\n\t\tif (sb_pool_add(card, skb, queue)) {\n\t\t\tprintk(\"%s: SB POOL full\\n\", __func__);\n\t\t\tgoto outfree;\n\t\t}\n\n\t\tpaddr = dma_map_single(&card->pcidev->dev, skb->data,\n\t\t\t\t       skb_end_pointer(skb) - skb->data,\n\t\t\t\t       DMA_FROM_DEVICE);\n\t\tIDT77252_PRV_PADDR(skb) = paddr;\n\n\t\tif (push_rx_skb(card, skb, queue)) {\n\t\t\tprintk(\"%s: FB QUEUE full\\n\", __func__);\n\t\t\tgoto outunmap;\n\t\t}\n\t}\n\n\treturn;\n\noutunmap:\n\tdma_unmap_single(&card->pcidev->dev, IDT77252_PRV_PADDR(skb),\n\t\t\t skb_end_pointer(skb) - skb->data, DMA_FROM_DEVICE);\n\n\thandle = IDT77252_PRV_POOL(skb);\n\tcard->sbpool[POOL_QUEUE(handle)].skb[POOL_INDEX(handle)] = NULL;\n\noutfree:\n\tdev_kfree_skb(skb);\n}\n\n\nstatic void\nrecycle_rx_skb(struct idt77252_dev *card, struct sk_buff *skb)\n{\n\tu32 handle = IDT77252_PRV_POOL(skb);\n\tint err;\n\n\tdma_sync_single_for_device(&card->pcidev->dev, IDT77252_PRV_PADDR(skb),\n\t\t\t\t   skb_end_pointer(skb) - skb->data,\n\t\t\t\t   DMA_FROM_DEVICE);\n\n\terr = push_rx_skb(card, skb, POOL_QUEUE(handle));\n\tif (err) {\n\t\tdma_unmap_single(&card->pcidev->dev, IDT77252_PRV_PADDR(skb),\n\t\t\t\t skb_end_pointer(skb) - skb->data,\n\t\t\t\t DMA_FROM_DEVICE);\n\t\tsb_pool_remove(card, skb);\n\t\tdev_kfree_skb(skb);\n\t}\n}\n\nstatic void\nflush_rx_pool(struct idt77252_dev *card, struct rx_pool *rpp)\n{\n\tskb_queue_head_init(&rpp->queue);\n\trpp->len = 0;\n}\n\nstatic void\nrecycle_rx_pool_skb(struct idt77252_dev *card, struct rx_pool *rpp)\n{\n\tstruct sk_buff *skb, *tmp;\n\n\tskb_queue_walk_safe(&rpp->queue, skb, tmp)\n\t\trecycle_rx_skb(card, skb);\n\n\tflush_rx_pool(card, rpp);\n}\n\n \n \n \n \n \n\nstatic void\nidt77252_phy_put(struct atm_dev *dev, unsigned char value, unsigned long addr)\n{\n\twrite_utility(dev->dev_data, 0x100 + (addr & 0x1ff), value);\n}\n\nstatic unsigned char\nidt77252_phy_get(struct atm_dev *dev, unsigned long addr)\n{\n\treturn read_utility(dev->dev_data, 0x100 + (addr & 0x1ff));\n}\n\nstatic inline int\nidt77252_send_skb(struct atm_vcc *vcc, struct sk_buff *skb, int oam)\n{\n\tstruct atm_dev *dev = vcc->dev;\n\tstruct idt77252_dev *card = dev->dev_data;\n\tstruct vc_map *vc = vcc->dev_data;\n\tint err;\n\n\tif (vc == NULL) {\n\t\tprintk(\"%s: NULL connection in send().\\n\", card->name);\n\t\tatomic_inc(&vcc->stats->tx_err);\n\t\tdev_kfree_skb(skb);\n\t\treturn -EINVAL;\n\t}\n\tif (!test_bit(VCF_TX, &vc->flags)) {\n\t\tprintk(\"%s: Trying to transmit on a non-tx VC.\\n\", card->name);\n\t\tatomic_inc(&vcc->stats->tx_err);\n\t\tdev_kfree_skb(skb);\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (vcc->qos.aal) {\n\tcase ATM_AAL0:\n\tcase ATM_AAL1:\n\tcase ATM_AAL5:\n\t\tbreak;\n\tdefault:\n\t\tprintk(\"%s: Unsupported AAL: %d\\n\", card->name, vcc->qos.aal);\n\t\tatomic_inc(&vcc->stats->tx_err);\n\t\tdev_kfree_skb(skb);\n\t\treturn -EINVAL;\n\t}\n\n\tif (skb_shinfo(skb)->nr_frags != 0) {\n\t\tprintk(\"%s: No scatter-gather yet.\\n\", card->name);\n\t\tatomic_inc(&vcc->stats->tx_err);\n\t\tdev_kfree_skb(skb);\n\t\treturn -EINVAL;\n\t}\n\tATM_SKB(skb)->vcc = vcc;\n\n\terr = queue_skb(card, vc, skb, oam);\n\tif (err) {\n\t\tatomic_inc(&vcc->stats->tx_err);\n\t\tdev_kfree_skb(skb);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int idt77252_send(struct atm_vcc *vcc, struct sk_buff *skb)\n{\n\treturn idt77252_send_skb(vcc, skb, 0);\n}\n\nstatic int\nidt77252_send_oam(struct atm_vcc *vcc, void *cell, int flags)\n{\n\tstruct atm_dev *dev = vcc->dev;\n\tstruct idt77252_dev *card = dev->dev_data;\n\tstruct sk_buff *skb;\n\n\tskb = dev_alloc_skb(64);\n\tif (!skb) {\n\t\tprintk(\"%s: Out of memory in send_oam().\\n\", card->name);\n\t\tatomic_inc(&vcc->stats->tx_err);\n\t\treturn -ENOMEM;\n\t}\n\trefcount_add(skb->truesize, &sk_atm(vcc)->sk_wmem_alloc);\n\n\tskb_put_data(skb, cell, 52);\n\n\treturn idt77252_send_skb(vcc, skb, 1);\n}\n\nstatic __inline__ unsigned int\nidt77252_fls(unsigned int x)\n{\n\tint r = 1;\n\n\tif (x == 0)\n\t\treturn 0;\n\tif (x & 0xffff0000) {\n\t\tx >>= 16;\n\t\tr += 16;\n\t}\n\tif (x & 0xff00) {\n\t\tx >>= 8;\n\t\tr += 8;\n\t}\n\tif (x & 0xf0) {\n\t\tx >>= 4;\n\t\tr += 4;\n\t}\n\tif (x & 0xc) {\n\t\tx >>= 2;\n\t\tr += 2;\n\t}\n\tif (x & 0x2)\n\t\tr += 1;\n\treturn r;\n}\n\nstatic u16\nidt77252_int_to_atmfp(unsigned int rate)\n{\n\tu16 m, e;\n\n\tif (rate == 0)\n\t\treturn 0;\n\te = idt77252_fls(rate) - 1;\n\tif (e < 9)\n\t\tm = (rate - (1 << e)) << (9 - e);\n\telse if (e == 9)\n\t\tm = (rate - (1 << e));\n\telse  \n\t\tm = (rate - (1 << e)) >> (e - 9);\n\treturn 0x4000 | (e << 9) | m;\n}\n\nstatic u8\nidt77252_rate_logindex(struct idt77252_dev *card, int pcr)\n{\n\tu16 afp;\n\n\tafp = idt77252_int_to_atmfp(pcr < 0 ? -pcr : pcr);\n\tif (pcr < 0)\n\t\treturn rate_to_log[(afp >> 5) & 0x1ff];\n\treturn rate_to_log[((afp >> 5) + 1) & 0x1ff];\n}\n\nstatic void\nidt77252_est_timer(struct timer_list *t)\n{\n\tstruct rate_estimator *est = from_timer(est, t, timer);\n\tstruct vc_map *vc = est->vc;\n\tstruct idt77252_dev *card = vc->card;\n\tunsigned long flags;\n\tu32 rate, cps;\n\tu64 ncells;\n\tu8 lacr;\n\n\tspin_lock_irqsave(&vc->lock, flags);\n\tif (!vc->estimator)\n\t\tgoto out;\n\tncells = est->cells;\n\n\trate = ((u32)(ncells - est->last_cells)) << (7 - est->interval);\n\test->last_cells = ncells;\n\test->avcps += ((long)rate - (long)est->avcps) >> est->ewma_log;\n\test->cps = (est->avcps + 0x1f) >> 5;\n\n\tcps = est->cps;\n\tif (cps < (est->maxcps >> 4))\n\t\tcps = est->maxcps >> 4;\n\n\tlacr = idt77252_rate_logindex(card, cps);\n\tif (lacr > vc->max_er)\n\t\tlacr = vc->max_er;\n\n\tif (lacr != vc->lacr) {\n\t\tvc->lacr = lacr;\n\t\twritel(TCMDQ_LACR|(vc->lacr << 16)|vc->index, SAR_REG_TCMDQ);\n\t}\n\n\test->timer.expires = jiffies + ((HZ / 4) << est->interval);\n\tadd_timer(&est->timer);\n\nout:\n\tspin_unlock_irqrestore(&vc->lock, flags);\n}\n\nstatic struct rate_estimator *\nidt77252_init_est(struct vc_map *vc, int pcr)\n{\n\tstruct rate_estimator *est;\n\n\test = kzalloc(sizeof(struct rate_estimator), GFP_KERNEL);\n\tif (!est)\n\t\treturn NULL;\n\test->maxcps = pcr < 0 ? -pcr : pcr;\n\test->cps = est->maxcps;\n\test->avcps = est->cps << 5;\n\test->vc = vc;\n\n\test->interval = 2;\t\t \n\test->ewma_log = 2;\t\t \n\ttimer_setup(&est->timer, idt77252_est_timer, 0);\n\tmod_timer(&est->timer, jiffies + ((HZ / 4) << est->interval));\n\n\treturn est;\n}\n\nstatic int\nidt77252_init_cbr(struct idt77252_dev *card, struct vc_map *vc,\n\t\t  struct atm_vcc *vcc, struct atm_qos *qos)\n{\n\tint tst_free, tst_used, tst_entries;\n\tunsigned long tmpl, modl;\n\tint tcr, tcra;\n\n\tif ((qos->txtp.max_pcr == 0) &&\n\t    (qos->txtp.pcr == 0) && (qos->txtp.min_pcr == 0)) {\n\t\tprintk(\"%s: trying to open a CBR VC with cell rate = 0\\n\",\n\t\t       card->name);\n\t\treturn -EINVAL;\n\t}\n\n\ttst_used = 0;\n\ttst_free = card->tst_free;\n\tif (test_bit(VCF_TX, &vc->flags))\n\t\ttst_used = vc->ntste;\n\ttst_free += tst_used;\n\n\ttcr = atm_pcr_goal(&qos->txtp);\n\ttcra = tcr >= 0 ? tcr : -tcr;\n\n\tTXPRINTK(\"%s: CBR target cell rate = %d\\n\", card->name, tcra);\n\n\ttmpl = (unsigned long) tcra * ((unsigned long) card->tst_size - 2);\n\tmodl = tmpl % (unsigned long)card->utopia_pcr;\n\n\ttst_entries = (int) (tmpl / card->utopia_pcr);\n\tif (tcr > 0) {\n\t\tif (modl > 0)\n\t\t\ttst_entries++;\n\t} else if (tcr == 0) {\n\t\ttst_entries = tst_free - SAR_TST_RESERVED;\n\t\tif (tst_entries <= 0) {\n\t\t\tprintk(\"%s: no CBR bandwidth free.\\n\", card->name);\n\t\t\treturn -ENOSR;\n\t\t}\n\t}\n\n\tif (tst_entries == 0) {\n\t\tprintk(\"%s: selected CBR bandwidth < granularity.\\n\",\n\t\t       card->name);\n\t\treturn -EINVAL;\n\t}\n\n\tif (tst_entries > (tst_free - SAR_TST_RESERVED)) {\n\t\tprintk(\"%s: not enough CBR bandwidth free.\\n\", card->name);\n\t\treturn -ENOSR;\n\t}\n\n\tvc->ntste = tst_entries;\n\n\tcard->tst_free = tst_free - tst_entries;\n\tif (test_bit(VCF_TX, &vc->flags)) {\n\t\tif (tst_used == tst_entries)\n\t\t\treturn 0;\n\n\t\tOPRINTK(\"%s: modify %d -> %d entries in TST.\\n\",\n\t\t\tcard->name, tst_used, tst_entries);\n\t\tchange_tst(card, vc, tst_entries, TSTE_OPC_CBR);\n\t\treturn 0;\n\t}\n\n\tOPRINTK(\"%s: setting %d entries in TST.\\n\", card->name, tst_entries);\n\tfill_tst(card, vc, tst_entries, TSTE_OPC_CBR);\n\treturn 0;\n}\n\nstatic int\nidt77252_init_ubr(struct idt77252_dev *card, struct vc_map *vc,\n\t\t  struct atm_vcc *vcc, struct atm_qos *qos)\n{\n\tstruct rate_estimator *est = NULL;\n\tunsigned long flags;\n\tint tcr;\n\n\tspin_lock_irqsave(&vc->lock, flags);\n\tif (vc->estimator) {\n\t\test = vc->estimator;\n\t\tvc->estimator = NULL;\n\t}\n\tspin_unlock_irqrestore(&vc->lock, flags);\n\tif (est) {\n\t\ttimer_shutdown_sync(&est->timer);\n\t\tkfree(est);\n\t}\n\n\ttcr = atm_pcr_goal(&qos->txtp);\n\tif (tcr == 0)\n\t\ttcr = card->link_pcr;\n\n\tvc->estimator = idt77252_init_est(vc, tcr);\n\n\tvc->class = SCHED_UBR;\n\tvc->init_er = idt77252_rate_logindex(card, tcr);\n\tvc->lacr = vc->init_er;\n\tif (tcr < 0)\n\t\tvc->max_er = vc->init_er;\n\telse\n\t\tvc->max_er = 0xff;\n\n\treturn 0;\n}\n\nstatic int\nidt77252_init_tx(struct idt77252_dev *card, struct vc_map *vc,\n\t\t struct atm_vcc *vcc, struct atm_qos *qos)\n{\n\tint error;\n\n\tif (test_bit(VCF_TX, &vc->flags))\n\t\treturn -EBUSY;\n\n\tswitch (qos->txtp.traffic_class) {\n\t\tcase ATM_CBR:\n\t\t\tvc->class = SCHED_CBR;\n\t\t\tbreak;\n\n\t\tcase ATM_UBR:\n\t\t\tvc->class = SCHED_UBR;\n\t\t\tbreak;\n\n\t\tcase ATM_VBR:\n\t\tcase ATM_ABR:\n\t\tdefault:\n\t\t\treturn -EPROTONOSUPPORT;\n\t}\n\n\tvc->scq = alloc_scq(card, vc->class);\n\tif (!vc->scq) {\n\t\tprintk(\"%s: can't get SCQ.\\n\", card->name);\n\t\treturn -ENOMEM;\n\t}\n\n\tvc->scq->scd = get_free_scd(card, vc);\n\tif (vc->scq->scd == 0) {\n\t\tprintk(\"%s: no SCD available.\\n\", card->name);\n\t\tfree_scq(card, vc->scq);\n\t\treturn -ENOMEM;\n\t}\n\n\tfill_scd(card, vc->scq, vc->class);\n\n\tif (set_tct(card, vc)) {\n\t\tprintk(\"%s: class %d not supported.\\n\",\n\t\t       card->name, qos->txtp.traffic_class);\n\n\t\tcard->scd2vc[vc->scd_index] = NULL;\n\t\tfree_scq(card, vc->scq);\n\t\treturn -EPROTONOSUPPORT;\n\t}\n\n\tswitch (vc->class) {\n\t\tcase SCHED_CBR:\n\t\t\terror = idt77252_init_cbr(card, vc, vcc, qos);\n\t\t\tif (error) {\n\t\t\t\tcard->scd2vc[vc->scd_index] = NULL;\n\t\t\t\tfree_scq(card, vc->scq);\n\t\t\t\treturn error;\n\t\t\t}\n\n\t\t\tclear_bit(VCF_IDLE, &vc->flags);\n\t\t\twritel(TCMDQ_START | vc->index, SAR_REG_TCMDQ);\n\t\t\tbreak;\n\n\t\tcase SCHED_UBR:\n\t\t\terror = idt77252_init_ubr(card, vc, vcc, qos);\n\t\t\tif (error) {\n\t\t\t\tcard->scd2vc[vc->scd_index] = NULL;\n\t\t\t\tfree_scq(card, vc->scq);\n\t\t\t\treturn error;\n\t\t\t}\n\n\t\t\tset_bit(VCF_IDLE, &vc->flags);\n\t\t\tbreak;\n\t}\n\n\tvc->tx_vcc = vcc;\n\tset_bit(VCF_TX, &vc->flags);\n\treturn 0;\n}\n\nstatic int\nidt77252_init_rx(struct idt77252_dev *card, struct vc_map *vc,\n\t\t struct atm_vcc *vcc, struct atm_qos *qos)\n{\n\tunsigned long flags;\n\tunsigned long addr;\n\tu32 rcte = 0;\n\n\tif (test_bit(VCF_RX, &vc->flags))\n\t\treturn -EBUSY;\n\n\tvc->rx_vcc = vcc;\n\tset_bit(VCF_RX, &vc->flags);\n\n\tif ((vcc->vci == 3) || (vcc->vci == 4))\n\t\treturn 0;\n\n\tflush_rx_pool(card, &vc->rcv.rx_pool);\n\n\trcte |= SAR_RCTE_CONNECTOPEN;\n\trcte |= SAR_RCTE_RAWCELLINTEN;\n\n\tswitch (qos->aal) {\n\t\tcase ATM_AAL0:\n\t\t\trcte |= SAR_RCTE_RCQ;\n\t\t\tbreak;\n\t\tcase ATM_AAL1:\n\t\t\trcte |= SAR_RCTE_OAM;  \n\t\t\tbreak;\n\t\tcase ATM_AAL34:\n\t\t\trcte |= SAR_RCTE_AAL34;\n\t\t\tbreak;\n\t\tcase ATM_AAL5:\n\t\t\trcte |= SAR_RCTE_AAL5;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\trcte |= SAR_RCTE_RCQ;\n\t\t\tbreak;\n\t}\n\n\tif (qos->aal != ATM_AAL5)\n\t\trcte |= SAR_RCTE_FBP_1;\n\telse if (qos->rxtp.max_sdu > SAR_FB_SIZE_2)\n\t\trcte |= SAR_RCTE_FBP_3;\n\telse if (qos->rxtp.max_sdu > SAR_FB_SIZE_1)\n\t\trcte |= SAR_RCTE_FBP_2;\n\telse if (qos->rxtp.max_sdu > SAR_FB_SIZE_0)\n\t\trcte |= SAR_RCTE_FBP_1;\n\telse\n\t\trcte |= SAR_RCTE_FBP_01;\n\n\taddr = card->rct_base + (vc->index << 2);\n\n\tOPRINTK(\"%s: writing RCT at 0x%lx\\n\", card->name, addr);\n\twrite_sram(card, addr, rcte);\n\n\tspin_lock_irqsave(&card->cmd_lock, flags);\n\twritel(SAR_CMD_OPEN_CONNECTION | (addr << 2), SAR_REG_CMD);\n\twaitfor_idle(card);\n\tspin_unlock_irqrestore(&card->cmd_lock, flags);\n\n\treturn 0;\n}\n\nstatic int\nidt77252_open(struct atm_vcc *vcc)\n{\n\tstruct atm_dev *dev = vcc->dev;\n\tstruct idt77252_dev *card = dev->dev_data;\n\tstruct vc_map *vc;\n\tunsigned int index;\n\tunsigned int inuse;\n\tint error;\n\tint vci = vcc->vci;\n\tshort vpi = vcc->vpi;\n\n\tif (vpi == ATM_VPI_UNSPEC || vci == ATM_VCI_UNSPEC)\n\t\treturn 0;\n\n\tif (vpi >= (1 << card->vpibits)) {\n\t\tprintk(\"%s: unsupported VPI: %d\\n\", card->name, vpi);\n\t\treturn -EINVAL;\n\t}\n\n\tif (vci >= (1 << card->vcibits)) {\n\t\tprintk(\"%s: unsupported VCI: %d\\n\", card->name, vci);\n\t\treturn -EINVAL;\n\t}\n\n\tset_bit(ATM_VF_ADDR, &vcc->flags);\n\n\tmutex_lock(&card->mutex);\n\n\tOPRINTK(\"%s: opening vpi.vci: %d.%d\\n\", card->name, vpi, vci);\n\n\tswitch (vcc->qos.aal) {\n\tcase ATM_AAL0:\n\tcase ATM_AAL1:\n\tcase ATM_AAL5:\n\t\tbreak;\n\tdefault:\n\t\tprintk(\"%s: Unsupported AAL: %d\\n\", card->name, vcc->qos.aal);\n\t\tmutex_unlock(&card->mutex);\n\t\treturn -EPROTONOSUPPORT;\n\t}\n\n\tindex = VPCI2VC(card, vpi, vci);\n\tif (!card->vcs[index]) {\n\t\tcard->vcs[index] = kzalloc(sizeof(struct vc_map), GFP_KERNEL);\n\t\tif (!card->vcs[index]) {\n\t\t\tprintk(\"%s: can't alloc vc in open()\\n\", card->name);\n\t\t\tmutex_unlock(&card->mutex);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tcard->vcs[index]->card = card;\n\t\tcard->vcs[index]->index = index;\n\n\t\tspin_lock_init(&card->vcs[index]->lock);\n\t}\n\tvc = card->vcs[index];\n\n\tvcc->dev_data = vc;\n\n\tIPRINTK(\"%s: idt77252_open: vc = %d (%d.%d) %s/%s (max RX SDU: %u)\\n\",\n\t        card->name, vc->index, vcc->vpi, vcc->vci,\n\t        vcc->qos.rxtp.traffic_class != ATM_NONE ? \"rx\" : \"--\",\n\t        vcc->qos.txtp.traffic_class != ATM_NONE ? \"tx\" : \"--\",\n\t        vcc->qos.rxtp.max_sdu);\n\n\tinuse = 0;\n\tif (vcc->qos.txtp.traffic_class != ATM_NONE &&\n\t    test_bit(VCF_TX, &vc->flags))\n\t\tinuse = 1;\n\tif (vcc->qos.rxtp.traffic_class != ATM_NONE &&\n\t    test_bit(VCF_RX, &vc->flags))\n\t\tinuse += 2;\n\n\tif (inuse) {\n\t\tprintk(\"%s: %s vci already in use.\\n\", card->name,\n\t\t       inuse == 1 ? \"tx\" : inuse == 2 ? \"rx\" : \"tx and rx\");\n\t\tmutex_unlock(&card->mutex);\n\t\treturn -EADDRINUSE;\n\t}\n\n\tif (vcc->qos.txtp.traffic_class != ATM_NONE) {\n\t\terror = idt77252_init_tx(card, vc, vcc, &vcc->qos);\n\t\tif (error) {\n\t\t\tmutex_unlock(&card->mutex);\n\t\t\treturn error;\n\t\t}\n\t}\n\n\tif (vcc->qos.rxtp.traffic_class != ATM_NONE) {\n\t\terror = idt77252_init_rx(card, vc, vcc, &vcc->qos);\n\t\tif (error) {\n\t\t\tmutex_unlock(&card->mutex);\n\t\t\treturn error;\n\t\t}\n\t}\n\n\tset_bit(ATM_VF_READY, &vcc->flags);\n\n\tmutex_unlock(&card->mutex);\n\treturn 0;\n}\n\nstatic void\nidt77252_close(struct atm_vcc *vcc)\n{\n\tstruct atm_dev *dev = vcc->dev;\n\tstruct idt77252_dev *card = dev->dev_data;\n\tstruct vc_map *vc = vcc->dev_data;\n\tunsigned long flags;\n\tunsigned long addr;\n\tunsigned long timeout;\n\n\tmutex_lock(&card->mutex);\n\n\tIPRINTK(\"%s: idt77252_close: vc = %d (%d.%d)\\n\",\n\t\tcard->name, vc->index, vcc->vpi, vcc->vci);\n\n\tclear_bit(ATM_VF_READY, &vcc->flags);\n\n\tif (vcc->qos.rxtp.traffic_class != ATM_NONE) {\n\n\t\tspin_lock_irqsave(&vc->lock, flags);\n\t\tclear_bit(VCF_RX, &vc->flags);\n\t\tvc->rx_vcc = NULL;\n\t\tspin_unlock_irqrestore(&vc->lock, flags);\n\n\t\tif ((vcc->vci == 3) || (vcc->vci == 4))\n\t\t\tgoto done;\n\n\t\taddr = card->rct_base + vc->index * SAR_SRAM_RCT_SIZE;\n\n\t\tspin_lock_irqsave(&card->cmd_lock, flags);\n\t\twritel(SAR_CMD_CLOSE_CONNECTION | (addr << 2), SAR_REG_CMD);\n\t\twaitfor_idle(card);\n\t\tspin_unlock_irqrestore(&card->cmd_lock, flags);\n\n\t\tif (skb_queue_len(&vc->rcv.rx_pool.queue) != 0) {\n\t\t\tDPRINTK(\"%s: closing a VC with pending rx buffers.\\n\",\n\t\t\t\tcard->name);\n\n\t\t\trecycle_rx_pool_skb(card, &vc->rcv.rx_pool);\n\t\t}\n\t}\n\ndone:\n\tif (vcc->qos.txtp.traffic_class != ATM_NONE) {\n\n\t\tspin_lock_irqsave(&vc->lock, flags);\n\t\tclear_bit(VCF_TX, &vc->flags);\n\t\tclear_bit(VCF_IDLE, &vc->flags);\n\t\tclear_bit(VCF_RSV, &vc->flags);\n\t\tvc->tx_vcc = NULL;\n\n\t\tif (vc->estimator) {\n\t\t\ttimer_shutdown(&vc->estimator->timer);\n\t\t\tkfree(vc->estimator);\n\t\t\tvc->estimator = NULL;\n\t\t}\n\t\tspin_unlock_irqrestore(&vc->lock, flags);\n\n\t\ttimeout = 5 * 1000;\n\t\twhile (atomic_read(&vc->scq->used) > 0) {\n\t\t\ttimeout = msleep_interruptible(timeout);\n\t\t\tif (!timeout) {\n\t\t\t\tpr_warn(\"%s: SCQ drain timeout: %u used\\n\",\n\t\t\t\t\tcard->name, atomic_read(&vc->scq->used));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\twritel(TCMDQ_HALT | vc->index, SAR_REG_TCMDQ);\n\t\tclear_scd(card, vc->scq, vc->class);\n\n\t\tif (vc->class == SCHED_CBR) {\n\t\t\tclear_tst(card, vc);\n\t\t\tcard->tst_free += vc->ntste;\n\t\t\tvc->ntste = 0;\n\t\t}\n\n\t\tcard->scd2vc[vc->scd_index] = NULL;\n\t\tfree_scq(card, vc->scq);\n\t}\n\n\tmutex_unlock(&card->mutex);\n}\n\nstatic int\nidt77252_change_qos(struct atm_vcc *vcc, struct atm_qos *qos, int flags)\n{\n\tstruct atm_dev *dev = vcc->dev;\n\tstruct idt77252_dev *card = dev->dev_data;\n\tstruct vc_map *vc = vcc->dev_data;\n\tint error = 0;\n\n\tmutex_lock(&card->mutex);\n\n\tif (qos->txtp.traffic_class != ATM_NONE) {\n\t    \tif (!test_bit(VCF_TX, &vc->flags)) {\n\t\t\terror = idt77252_init_tx(card, vc, vcc, qos);\n\t\t\tif (error)\n\t\t\t\tgoto out;\n\t\t} else {\n\t\t\tswitch (qos->txtp.traffic_class) {\n\t\t\tcase ATM_CBR:\n\t\t\t\terror = idt77252_init_cbr(card, vc, vcc, qos);\n\t\t\t\tif (error)\n\t\t\t\t\tgoto out;\n\t\t\t\tbreak;\n\n\t\t\tcase ATM_UBR:\n\t\t\t\terror = idt77252_init_ubr(card, vc, vcc, qos);\n\t\t\t\tif (error)\n\t\t\t\t\tgoto out;\n\n\t\t\t\tif (!test_bit(VCF_IDLE, &vc->flags)) {\n\t\t\t\t\twritel(TCMDQ_LACR | (vc->lacr << 16) |\n\t\t\t\t\t       vc->index, SAR_REG_TCMDQ);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase ATM_VBR:\n\t\t\tcase ATM_ABR:\n\t\t\t\terror = -EOPNOTSUPP;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\n\tif ((qos->rxtp.traffic_class != ATM_NONE) &&\n\t    !test_bit(VCF_RX, &vc->flags)) {\n\t\terror = idt77252_init_rx(card, vc, vcc, qos);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\n\tmemcpy(&vcc->qos, qos, sizeof(struct atm_qos));\n\n\tset_bit(ATM_VF_HASQOS, &vcc->flags);\n\nout:\n\tmutex_unlock(&card->mutex);\n\treturn error;\n}\n\nstatic int\nidt77252_proc_read(struct atm_dev *dev, loff_t * pos, char *page)\n{\n\tstruct idt77252_dev *card = dev->dev_data;\n\tint i, left;\n\n\tleft = (int) *pos;\n\tif (!left--)\n\t\treturn sprintf(page, \"IDT77252 Interrupts:\\n\");\n\tif (!left--)\n\t\treturn sprintf(page, \"TSIF:  %lu\\n\", card->irqstat[15]);\n\tif (!left--)\n\t\treturn sprintf(page, \"TXICP: %lu\\n\", card->irqstat[14]);\n\tif (!left--)\n\t\treturn sprintf(page, \"TSQF:  %lu\\n\", card->irqstat[12]);\n\tif (!left--)\n\t\treturn sprintf(page, \"TMROF: %lu\\n\", card->irqstat[11]);\n\tif (!left--)\n\t\treturn sprintf(page, \"PHYI:  %lu\\n\", card->irqstat[10]);\n\tif (!left--)\n\t\treturn sprintf(page, \"FBQ3A: %lu\\n\", card->irqstat[8]);\n\tif (!left--)\n\t\treturn sprintf(page, \"FBQ2A: %lu\\n\", card->irqstat[7]);\n\tif (!left--)\n\t\treturn sprintf(page, \"RSQF:  %lu\\n\", card->irqstat[6]);\n\tif (!left--)\n\t\treturn sprintf(page, \"EPDU:  %lu\\n\", card->irqstat[5]);\n\tif (!left--)\n\t\treturn sprintf(page, \"RAWCF: %lu\\n\", card->irqstat[4]);\n\tif (!left--)\n\t\treturn sprintf(page, \"FBQ1A: %lu\\n\", card->irqstat[3]);\n\tif (!left--)\n\t\treturn sprintf(page, \"FBQ0A: %lu\\n\", card->irqstat[2]);\n\tif (!left--)\n\t\treturn sprintf(page, \"RSQAF: %lu\\n\", card->irqstat[1]);\n\tif (!left--)\n\t\treturn sprintf(page, \"IDT77252 Transmit Connection Table:\\n\");\n\n\tfor (i = 0; i < card->tct_size; i++) {\n\t\tunsigned long tct;\n\t\tstruct atm_vcc *vcc;\n\t\tstruct vc_map *vc;\n\t\tchar *p;\n\n\t\tvc = card->vcs[i];\n\t\tif (!vc)\n\t\t\tcontinue;\n\n\t\tvcc = NULL;\n\t\tif (vc->tx_vcc)\n\t\t\tvcc = vc->tx_vcc;\n\t\tif (!vcc)\n\t\t\tcontinue;\n\t\tif (left--)\n\t\t\tcontinue;\n\n\t\tp = page;\n\t\tp += sprintf(p, \"  %4u: %u.%u: \", i, vcc->vpi, vcc->vci);\n\t\ttct = (unsigned long) (card->tct_base + i * SAR_SRAM_TCT_SIZE);\n\n\t\tfor (i = 0; i < 8; i++)\n\t\t\tp += sprintf(p, \" %08x\", read_sram(card, tct + i));\n\t\tp += sprintf(p, \"\\n\");\n\t\treturn p - page;\n\t}\n\treturn 0;\n}\n\n \n \n \n \n \n\nstatic void\nidt77252_collect_stat(struct idt77252_dev *card)\n{\n\t(void) readl(SAR_REG_CDC);\n\t(void) readl(SAR_REG_VPEC);\n\t(void) readl(SAR_REG_ICC);\n\n}\n\nstatic irqreturn_t\nidt77252_interrupt(int irq, void *dev_id)\n{\n\tstruct idt77252_dev *card = dev_id;\n\tu32 stat;\n\n\tstat = readl(SAR_REG_STAT) & 0xffff;\n\tif (!stat)\t \n\t\treturn IRQ_NONE;\n\n\tif (test_and_set_bit(IDT77252_BIT_INTERRUPT, &card->flags)) {\n\t\tprintk(\"%s: Re-entering irq_handler()\\n\", card->name);\n\t\tgoto out;\n\t}\n\n\twritel(stat, SAR_REG_STAT);\t \n\n\tif (stat & SAR_STAT_TSIF) {\t \n\t\tINTPRINTK(\"%s: TSIF\\n\", card->name);\n\t\tcard->irqstat[15]++;\n\t\tidt77252_tx(card);\n\t}\n\tif (stat & SAR_STAT_TXICP) {\t \n\t\tINTPRINTK(\"%s: TXICP\\n\", card->name);\n\t\tcard->irqstat[14]++;\n#ifdef CONFIG_ATM_IDT77252_DEBUG\n\t\tidt77252_tx_dump(card);\n#endif\n\t}\n\tif (stat & SAR_STAT_TSQF) {\t \n\t\tINTPRINTK(\"%s: TSQF\\n\", card->name);\n\t\tcard->irqstat[12]++;\n\t\tidt77252_tx(card);\n\t}\n\tif (stat & SAR_STAT_TMROF) {\t \n\t\tINTPRINTK(\"%s: TMROF\\n\", card->name);\n\t\tcard->irqstat[11]++;\n\t\tidt77252_collect_stat(card);\n\t}\n\n\tif (stat & SAR_STAT_EPDU) {\t \n\t\tINTPRINTK(\"%s: EPDU\\n\", card->name);\n\t\tcard->irqstat[5]++;\n\t\tidt77252_rx(card);\n\t}\n\tif (stat & SAR_STAT_RSQAF) {\t \n\t\tINTPRINTK(\"%s: RSQAF\\n\", card->name);\n\t\tcard->irqstat[1]++;\n\t\tidt77252_rx(card);\n\t}\n\tif (stat & SAR_STAT_RSQF) {\t \n\t\tINTPRINTK(\"%s: RSQF\\n\", card->name);\n\t\tcard->irqstat[6]++;\n\t\tidt77252_rx(card);\n\t}\n\tif (stat & SAR_STAT_RAWCF) {\t \n\t\tINTPRINTK(\"%s: RAWCF\\n\", card->name);\n\t\tcard->irqstat[4]++;\n\t\tidt77252_rx_raw(card);\n\t}\n\n\tif (stat & SAR_STAT_PHYI) {\t \n\t\tINTPRINTK(\"%s: PHYI\", card->name);\n\t\tcard->irqstat[10]++;\n\t\tif (card->atmdev->phy && card->atmdev->phy->interrupt)\n\t\t\tcard->atmdev->phy->interrupt(card->atmdev);\n\t}\n\n\tif (stat & (SAR_STAT_FBQ0A | SAR_STAT_FBQ1A |\n\t\t    SAR_STAT_FBQ2A | SAR_STAT_FBQ3A)) {\n\n\t\twritel(readl(SAR_REG_CFG) & ~(SAR_CFG_FBIE), SAR_REG_CFG);\n\n\t\tINTPRINTK(\"%s: FBQA: %04x\\n\", card->name, stat);\n\n\t\tif (stat & SAR_STAT_FBQ0A)\n\t\t\tcard->irqstat[2]++;\n\t\tif (stat & SAR_STAT_FBQ1A)\n\t\t\tcard->irqstat[3]++;\n\t\tif (stat & SAR_STAT_FBQ2A)\n\t\t\tcard->irqstat[7]++;\n\t\tif (stat & SAR_STAT_FBQ3A)\n\t\t\tcard->irqstat[8]++;\n\n\t\tschedule_work(&card->tqueue);\n\t}\n\nout:\n\tclear_bit(IDT77252_BIT_INTERRUPT, &card->flags);\n\treturn IRQ_HANDLED;\n}\n\nstatic void\nidt77252_softint(struct work_struct *work)\n{\n\tstruct idt77252_dev *card =\n\t\tcontainer_of(work, struct idt77252_dev, tqueue);\n\tu32 stat;\n\tint done;\n\n\tfor (done = 1; ; done = 1) {\n\t\tstat = readl(SAR_REG_STAT) >> 16;\n\n\t\tif ((stat & 0x0f) < SAR_FBQ0_HIGH) {\n\t\t\tadd_rx_skb(card, 0, SAR_FB_SIZE_0, 32);\n\t\t\tdone = 0;\n\t\t}\n\n\t\tstat >>= 4;\n\t\tif ((stat & 0x0f) < SAR_FBQ1_HIGH) {\n\t\t\tadd_rx_skb(card, 1, SAR_FB_SIZE_1, 32);\n\t\t\tdone = 0;\n\t\t}\n\n\t\tstat >>= 4;\n\t\tif ((stat & 0x0f) < SAR_FBQ2_HIGH) {\n\t\t\tadd_rx_skb(card, 2, SAR_FB_SIZE_2, 32);\n\t\t\tdone = 0;\n\t\t}\n\n\t\tstat >>= 4;\n\t\tif ((stat & 0x0f) < SAR_FBQ3_HIGH) {\n\t\t\tadd_rx_skb(card, 3, SAR_FB_SIZE_3, 32);\n\t\t\tdone = 0;\n\t\t}\n\n\t\tif (done)\n\t\t\tbreak;\n\t}\n\n\twritel(readl(SAR_REG_CFG) | SAR_CFG_FBIE, SAR_REG_CFG);\n}\n\n\nstatic int\nopen_card_oam(struct idt77252_dev *card)\n{\n\tunsigned long flags;\n\tunsigned long addr;\n\tstruct vc_map *vc;\n\tint vpi, vci;\n\tint index;\n\tu32 rcte;\n\n\tfor (vpi = 0; vpi < (1 << card->vpibits); vpi++) {\n\t\tfor (vci = 3; vci < 5; vci++) {\n\t\t\tindex = VPCI2VC(card, vpi, vci);\n\n\t\t\tvc = kzalloc(sizeof(struct vc_map), GFP_KERNEL);\n\t\t\tif (!vc) {\n\t\t\t\tprintk(\"%s: can't alloc vc\\n\", card->name);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t\tvc->index = index;\n\t\t\tcard->vcs[index] = vc;\n\n\t\t\tflush_rx_pool(card, &vc->rcv.rx_pool);\n\n\t\t\trcte = SAR_RCTE_CONNECTOPEN |\n\t\t\t       SAR_RCTE_RAWCELLINTEN |\n\t\t\t       SAR_RCTE_RCQ |\n\t\t\t       SAR_RCTE_FBP_1;\n\n\t\t\taddr = card->rct_base + (vc->index << 2);\n\t\t\twrite_sram(card, addr, rcte);\n\n\t\t\tspin_lock_irqsave(&card->cmd_lock, flags);\n\t\t\twritel(SAR_CMD_OPEN_CONNECTION | (addr << 2),\n\t\t\t       SAR_REG_CMD);\n\t\t\twaitfor_idle(card);\n\t\t\tspin_unlock_irqrestore(&card->cmd_lock, flags);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void\nclose_card_oam(struct idt77252_dev *card)\n{\n\tunsigned long flags;\n\tunsigned long addr;\n\tstruct vc_map *vc;\n\tint vpi, vci;\n\tint index;\n\n\tfor (vpi = 0; vpi < (1 << card->vpibits); vpi++) {\n\t\tfor (vci = 3; vci < 5; vci++) {\n\t\t\tindex = VPCI2VC(card, vpi, vci);\n\t\t\tvc = card->vcs[index];\n\n\t\t\taddr = card->rct_base + vc->index * SAR_SRAM_RCT_SIZE;\n\n\t\t\tspin_lock_irqsave(&card->cmd_lock, flags);\n\t\t\twritel(SAR_CMD_CLOSE_CONNECTION | (addr << 2),\n\t\t\t       SAR_REG_CMD);\n\t\t\twaitfor_idle(card);\n\t\t\tspin_unlock_irqrestore(&card->cmd_lock, flags);\n\n\t\t\tif (skb_queue_len(&vc->rcv.rx_pool.queue) != 0) {\n\t\t\t\tDPRINTK(\"%s: closing a VC \"\n\t\t\t\t\t\"with pending rx buffers.\\n\",\n\t\t\t\t\tcard->name);\n\n\t\t\t\trecycle_rx_pool_skb(card, &vc->rcv.rx_pool);\n\t\t\t}\n\t\t\tkfree(vc);\n\t\t}\n\t}\n}\n\nstatic int\nopen_card_ubr0(struct idt77252_dev *card)\n{\n\tstruct vc_map *vc;\n\n\tvc = kzalloc(sizeof(struct vc_map), GFP_KERNEL);\n\tif (!vc) {\n\t\tprintk(\"%s: can't alloc vc\\n\", card->name);\n\t\treturn -ENOMEM;\n\t}\n\tcard->vcs[0] = vc;\n\tvc->class = SCHED_UBR0;\n\n\tvc->scq = alloc_scq(card, vc->class);\n\tif (!vc->scq) {\n\t\tprintk(\"%s: can't get SCQ.\\n\", card->name);\n\t\treturn -ENOMEM;\n\t}\n\n\tcard->scd2vc[0] = vc;\n\tvc->scd_index = 0;\n\tvc->scq->scd = card->scd_base;\n\n\tfill_scd(card, vc->scq, vc->class);\n\n\twrite_sram(card, card->tct_base + 0, TCT_UBR | card->scd_base);\n\twrite_sram(card, card->tct_base + 1, 0);\n\twrite_sram(card, card->tct_base + 2, 0);\n\twrite_sram(card, card->tct_base + 3, 0);\n\twrite_sram(card, card->tct_base + 4, 0);\n\twrite_sram(card, card->tct_base + 5, 0);\n\twrite_sram(card, card->tct_base + 6, 0);\n\twrite_sram(card, card->tct_base + 7, TCT_FLAG_UBR);\n\n\tclear_bit(VCF_IDLE, &vc->flags);\n\twritel(TCMDQ_START | 0, SAR_REG_TCMDQ);\n\treturn 0;\n}\n\nstatic void\nclose_card_ubr0(struct idt77252_dev *card)\n{\n\tstruct vc_map *vc = card->vcs[0];\n\n\tfree_scq(card, vc->scq);\n\tkfree(vc);\n}\n\nstatic int\nidt77252_dev_open(struct idt77252_dev *card)\n{\n\tu32 conf;\n\n\tif (!test_bit(IDT77252_BIT_INIT, &card->flags)) {\n\t\tprintk(\"%s: SAR not yet initialized.\\n\", card->name);\n\t\treturn -1;\n\t}\n\n\tconf = SAR_CFG_RXPTH|\t \n\t    SAR_RX_DELAY |\t \n\t    SAR_CFG_RAWIE |\t \n\t    SAR_CFG_RQFIE |\t \n\t    SAR_CFG_TMOIE |\t \n\t    SAR_CFG_FBIE |\t \n\t    SAR_CFG_TXEN |\t \n\t    SAR_CFG_TXINT |\t \n\t    SAR_CFG_TXUIE |\t \n\t    SAR_CFG_TXSFI |\t \n\t    SAR_CFG_PHYIE\t \n\t    ;\n\n#ifdef CONFIG_ATM_IDT77252_RCV_ALL\n\t \n\tconf |= SAR_CFG_VPECA;\n#endif\n\n\twritel(readl(SAR_REG_CFG) | conf, SAR_REG_CFG);\n\n\tif (open_card_oam(card)) {\n\t\tprintk(\"%s: Error initializing OAM.\\n\", card->name);\n\t\treturn -1;\n\t}\n\n\tif (open_card_ubr0(card)) {\n\t\tprintk(\"%s: Error initializing UBR0.\\n\", card->name);\n\t\treturn -1;\n\t}\n\n\tIPRINTK(\"%s: opened IDT77252 ABR SAR.\\n\", card->name);\n\treturn 0;\n}\n\nstatic void idt77252_dev_close(struct atm_dev *dev)\n{\n\tstruct idt77252_dev *card = dev->dev_data;\n\tu32 conf;\n\n\tclose_card_ubr0(card);\n\tclose_card_oam(card);\n\n\tconf = SAR_CFG_RXPTH |\t \n\t    SAR_RX_DELAY |\t \n\t    SAR_CFG_RAWIE |\t \n\t    SAR_CFG_RQFIE |\t \n\t    SAR_CFG_TMOIE |\t \n\t    SAR_CFG_FBIE |\t \n\t    SAR_CFG_TXEN |\t \n\t    SAR_CFG_TXINT |\t \n\t    SAR_CFG_TXUIE |\t \n\t    SAR_CFG_TXSFI\t \n\t    ;\n\n\twritel(readl(SAR_REG_CFG) & ~(conf), SAR_REG_CFG);\n\n\tDIPRINTK(\"%s: closed IDT77252 ABR SAR.\\n\", card->name);\n}\n\n\n \n \n \n \n \n\n\nstatic void\ndeinit_card(struct idt77252_dev *card)\n{\n\tstruct sk_buff *skb;\n\tint i, j;\n\n\tif (!test_bit(IDT77252_BIT_INIT, &card->flags)) {\n\t\tprintk(\"%s: SAR not yet initialized.\\n\", card->name);\n\t\treturn;\n\t}\n\tDIPRINTK(\"idt77252: deinitialize card %u\\n\", card->index);\n\n\twritel(0, SAR_REG_CFG);\n\n\tif (card->atmdev)\n\t\tatm_dev_deregister(card->atmdev);\n\n\tfor (i = 0; i < 4; i++) {\n\t\tfor (j = 0; j < FBQ_SIZE; j++) {\n\t\t\tskb = card->sbpool[i].skb[j];\n\t\t\tif (skb) {\n\t\t\t\tdma_unmap_single(&card->pcidev->dev,\n\t\t\t\t\t\t IDT77252_PRV_PADDR(skb),\n\t\t\t\t\t\t (skb_end_pointer(skb) -\n\t\t\t\t\t\t  skb->data),\n\t\t\t\t\t\t DMA_FROM_DEVICE);\n\t\t\t\tcard->sbpool[i].skb[j] = NULL;\n\t\t\t\tdev_kfree_skb(skb);\n\t\t\t}\n\t\t}\n\t}\n\n\tvfree(card->soft_tst);\n\n\tvfree(card->scd2vc);\n\n\tvfree(card->vcs);\n\n\tif (card->raw_cell_hnd) {\n\t\tdma_free_coherent(&card->pcidev->dev, 2 * sizeof(u32),\n\t\t\t\t  card->raw_cell_hnd, card->raw_cell_paddr);\n\t}\n\n\tif (card->rsq.base) {\n\t\tDIPRINTK(\"%s: Release RSQ ...\\n\", card->name);\n\t\tdeinit_rsq(card);\n\t}\n\n\tif (card->tsq.base) {\n\t\tDIPRINTK(\"%s: Release TSQ ...\\n\", card->name);\n\t\tdeinit_tsq(card);\n\t}\n\n\tDIPRINTK(\"idt77252: Release IRQ.\\n\");\n\tfree_irq(card->pcidev->irq, card);\n\n\tfor (i = 0; i < 4; i++) {\n\t\tif (card->fbq[i])\n\t\t\tiounmap(card->fbq[i]);\n\t}\n\n\tif (card->membase)\n\t\tiounmap(card->membase);\n\n\tclear_bit(IDT77252_BIT_INIT, &card->flags);\n\tDIPRINTK(\"%s: Card deinitialized.\\n\", card->name);\n}\n\n\nstatic void init_sram(struct idt77252_dev *card)\n{\n\tint i;\n\n\tfor (i = 0; i < card->sramsize; i += 4)\n\t\twrite_sram(card, (i >> 2), 0);\n\n\t \n\tif (card->sramsize == (512 * 1024)) {\n\t\tcard->tct_base = SAR_SRAM_TCT_128_BASE;\n\t\tcard->tct_size = (SAR_SRAM_TCT_128_TOP - card->tct_base + 1)\n\t\t    / SAR_SRAM_TCT_SIZE;\n\t\tcard->rct_base = SAR_SRAM_RCT_128_BASE;\n\t\tcard->rct_size = (SAR_SRAM_RCT_128_TOP - card->rct_base + 1)\n\t\t    / SAR_SRAM_RCT_SIZE;\n\t\tcard->rt_base = SAR_SRAM_RT_128_BASE;\n\t\tcard->scd_base = SAR_SRAM_SCD_128_BASE;\n\t\tcard->scd_size = (SAR_SRAM_SCD_128_TOP - card->scd_base + 1)\n\t\t    / SAR_SRAM_SCD_SIZE;\n\t\tcard->tst[0] = SAR_SRAM_TST1_128_BASE;\n\t\tcard->tst[1] = SAR_SRAM_TST2_128_BASE;\n\t\tcard->tst_size = SAR_SRAM_TST1_128_TOP - card->tst[0] + 1;\n\t\tcard->abrst_base = SAR_SRAM_ABRSTD_128_BASE;\n\t\tcard->abrst_size = SAR_ABRSTD_SIZE_8K;\n\t\tcard->fifo_base = SAR_SRAM_FIFO_128_BASE;\n\t\tcard->fifo_size = SAR_RXFD_SIZE_32K;\n\t} else {\n\t\tcard->tct_base = SAR_SRAM_TCT_32_BASE;\n\t\tcard->tct_size = (SAR_SRAM_TCT_32_TOP - card->tct_base + 1)\n\t\t    / SAR_SRAM_TCT_SIZE;\n\t\tcard->rct_base = SAR_SRAM_RCT_32_BASE;\n\t\tcard->rct_size = (SAR_SRAM_RCT_32_TOP - card->rct_base + 1)\n\t\t    / SAR_SRAM_RCT_SIZE;\n\t\tcard->rt_base = SAR_SRAM_RT_32_BASE;\n\t\tcard->scd_base = SAR_SRAM_SCD_32_BASE;\n\t\tcard->scd_size = (SAR_SRAM_SCD_32_TOP - card->scd_base + 1)\n\t\t    / SAR_SRAM_SCD_SIZE;\n\t\tcard->tst[0] = SAR_SRAM_TST1_32_BASE;\n\t\tcard->tst[1] = SAR_SRAM_TST2_32_BASE;\n\t\tcard->tst_size = (SAR_SRAM_TST1_32_TOP - card->tst[0] + 1);\n\t\tcard->abrst_base = SAR_SRAM_ABRSTD_32_BASE;\n\t\tcard->abrst_size = SAR_ABRSTD_SIZE_1K;\n\t\tcard->fifo_base = SAR_SRAM_FIFO_32_BASE;\n\t\tcard->fifo_size = SAR_RXFD_SIZE_4K;\n\t}\n\n\t \n\tfor (i = 0; i < card->tct_size; i++) {\n\t\twrite_sram(card, i * SAR_SRAM_TCT_SIZE + 0, 0);\n\t\twrite_sram(card, i * SAR_SRAM_TCT_SIZE + 1, 0);\n\t\twrite_sram(card, i * SAR_SRAM_TCT_SIZE + 2, 0);\n\t\twrite_sram(card, i * SAR_SRAM_TCT_SIZE + 3, 0);\n\t\twrite_sram(card, i * SAR_SRAM_TCT_SIZE + 4, 0);\n\t\twrite_sram(card, i * SAR_SRAM_TCT_SIZE + 5, 0);\n\t\twrite_sram(card, i * SAR_SRAM_TCT_SIZE + 6, 0);\n\t\twrite_sram(card, i * SAR_SRAM_TCT_SIZE + 7, 0);\n\t}\n\n\t \n\tfor (i = 0; i < card->rct_size; i++) {\n\t\twrite_sram(card, card->rct_base + i * SAR_SRAM_RCT_SIZE,\n\t\t\t\t    (u32) SAR_RCTE_RAWCELLINTEN);\n\t\twrite_sram(card, card->rct_base + i * SAR_SRAM_RCT_SIZE + 1,\n\t\t\t\t    (u32) 0);\n\t\twrite_sram(card, card->rct_base + i * SAR_SRAM_RCT_SIZE + 2,\n\t\t\t\t    (u32) 0);\n\t\twrite_sram(card, card->rct_base + i * SAR_SRAM_RCT_SIZE + 3,\n\t\t\t\t    (u32) 0xffffffff);\n\t}\n\n\twritel((SAR_FBQ0_LOW << 28) | (SAR_FB_SIZE_0 / 48), SAR_REG_FBQS0);\n\twritel((SAR_FBQ1_LOW << 28) | (SAR_FB_SIZE_1 / 48), SAR_REG_FBQS1);\n\twritel((SAR_FBQ2_LOW << 28) | (SAR_FB_SIZE_2 / 48), SAR_REG_FBQS2);\n\twritel((SAR_FBQ3_LOW << 28) | (SAR_FB_SIZE_3 / 48), SAR_REG_FBQS3);\n\n\t \n\tfor (i = 0; i < 256; i++) {\n\t\twrite_sram(card, card->rt_base + i, log_to_rate[i]);\n\t}\n\n\tfor (i = 0; i < 128; i++) {\n\t\tunsigned int tmp;\n\n\t\ttmp  = rate_to_log[(i << 2) + 0] << 0;\n\t\ttmp |= rate_to_log[(i << 2) + 1] << 8;\n\t\ttmp |= rate_to_log[(i << 2) + 2] << 16;\n\t\ttmp |= rate_to_log[(i << 2) + 3] << 24;\n\t\twrite_sram(card, card->rt_base + 256 + i, tmp);\n\t}\n\n#if 0  \n\tfor (i = 0; i < 128; i++) {\n\t\tunsigned int tmp;\n\n\t\ttmp = RDF[0][(i << 1) + 0] << 16;\n\t\ttmp |= RDF[0][(i << 1) + 1] << 0;\n\t\twrite_sram(card, card->rt_base + 512 + i, tmp);\n\t}\n\n\tfor (i = 0; i < 128; i++) {\n\t\tunsigned int tmp;\n\n\t\ttmp = AIR[0][(i << 1) + 0] << 16;\n\t\ttmp |= AIR[0][(i << 1) + 1] << 0;\n\t\twrite_sram(card, card->rt_base + 640 + i, tmp);\n\t}\n#endif\n\n\tIPRINTK(\"%s: initialize rate table ...\\n\", card->name);\n\twritel(card->rt_base << 2, SAR_REG_RTBL);\n\n\t \n\tIPRINTK(\"%s: initialize TST ...\\n\", card->name);\n\tcard->tst_free = card->tst_size - 2;\t \n\n\tfor (i = card->tst[0]; i < card->tst[0] + card->tst_size - 2; i++)\n\t\twrite_sram(card, i, TSTE_OPC_VAR);\n\twrite_sram(card, i++, TSTE_OPC_JMP | (card->tst[0] << 2));\n\tidt77252_sram_write_errors = 1;\n\twrite_sram(card, i++, TSTE_OPC_JMP | (card->tst[1] << 2));\n\tidt77252_sram_write_errors = 0;\n\tfor (i = card->tst[1]; i < card->tst[1] + card->tst_size - 2; i++)\n\t\twrite_sram(card, i, TSTE_OPC_VAR);\n\twrite_sram(card, i++, TSTE_OPC_JMP | (card->tst[1] << 2));\n\tidt77252_sram_write_errors = 1;\n\twrite_sram(card, i++, TSTE_OPC_JMP | (card->tst[0] << 2));\n\tidt77252_sram_write_errors = 0;\n\n\tcard->tst_index = 0;\n\twritel(card->tst[0] << 2, SAR_REG_TSTB);\n\n\t \n\tIPRINTK(\"%s: initialize ABRSTD ...\\n\", card->name);\n\twritel(card->abrst_size | (card->abrst_base << 2),\n\t       SAR_REG_ABRSTD);\n\n\tIPRINTK(\"%s: initialize receive fifo ...\\n\", card->name);\n\twritel(card->fifo_size | (card->fifo_base << 2),\n\t       SAR_REG_RXFD);\n\n\tIPRINTK(\"%s: SRAM initialization complete.\\n\", card->name);\n}\n\nstatic int init_card(struct atm_dev *dev)\n{\n\tstruct idt77252_dev *card = dev->dev_data;\n\tstruct pci_dev *pcidev = card->pcidev;\n\tunsigned long tmpl, modl;\n\tunsigned int linkrate, rsvdcr;\n\tunsigned int tst_entries;\n\tstruct net_device *tmp;\n\tchar tname[10];\n\n\tu32 size;\n\tu_char pci_byte;\n\tu32 conf;\n\tint i, k;\n\n\tif (test_bit(IDT77252_BIT_INIT, &card->flags)) {\n\t\tprintk(\"Error: SAR already initialized.\\n\");\n\t\treturn -1;\n\t}\n\n \n \n \n\n\t \n\tIPRINTK(\"%s: Checking PCI retries.\\n\", card->name);\n\tif (pci_read_config_byte(pcidev, 0x40, &pci_byte) != 0) {\n\t\tprintk(\"%s: can't read PCI retry timeout.\\n\", card->name);\n\t\tdeinit_card(card);\n\t\treturn -1;\n\t}\n\tif (pci_byte != 0) {\n\t\tIPRINTK(\"%s: PCI retry timeout: %d, set to 0.\\n\",\n\t\t\tcard->name, pci_byte);\n\t\tif (pci_write_config_byte(pcidev, 0x40, 0) != 0) {\n\t\t\tprintk(\"%s: can't set PCI retry timeout.\\n\",\n\t\t\t       card->name);\n\t\t\tdeinit_card(card);\n\t\t\treturn -1;\n\t\t}\n\t}\n\tIPRINTK(\"%s: Checking PCI TRDY.\\n\", card->name);\n\tif (pci_read_config_byte(pcidev, 0x41, &pci_byte) != 0) {\n\t\tprintk(\"%s: can't read PCI TRDY timeout.\\n\", card->name);\n\t\tdeinit_card(card);\n\t\treturn -1;\n\t}\n\tif (pci_byte != 0) {\n\t\tIPRINTK(\"%s: PCI TRDY timeout: %d, set to 0.\\n\",\n\t\t        card->name, pci_byte);\n\t\tif (pci_write_config_byte(pcidev, 0x41, 0) != 0) {\n\t\t\tprintk(\"%s: can't set PCI TRDY timeout.\\n\", card->name);\n\t\t\tdeinit_card(card);\n\t\t\treturn -1;\n\t\t}\n\t}\n\t \n\tif (readl(SAR_REG_STAT) & SAR_STAT_TMROF) {\n\t\tprintk(\"%s: resetting timer overflow.\\n\", card->name);\n\t\twritel(SAR_STAT_TMROF, SAR_REG_STAT);\n\t}\n\tIPRINTK(\"%s: Request IRQ ... \", card->name);\n\tif (request_irq(pcidev->irq, idt77252_interrupt, IRQF_SHARED,\n\t\t\tcard->name, card) != 0) {\n\t\tprintk(\"%s: can't allocate IRQ.\\n\", card->name);\n\t\tdeinit_card(card);\n\t\treturn -1;\n\t}\n\tIPRINTK(\"got %d.\\n\", pcidev->irq);\n\n \n \n \n\n\tIPRINTK(\"%s: Initializing SRAM\\n\", card->name);\n\n\t \n\tconf =\tSAR_CFG_TX_FIFO_SIZE_9 |\t \n\t\tSAR_CFG_RXSTQ_SIZE_8k |\t\t \n\t\tSAR_CFG_IDLE_CLP |\t\t \n#ifndef ATM_IDT77252_SEND_IDLE\n\t\tSAR_CFG_NO_IDLE |\t\t \n#endif\n\t\t0;\n\n\tif (card->sramsize == (512 * 1024))\n\t\tconf |= SAR_CFG_CNTBL_1k;\n\telse\n\t\tconf |= SAR_CFG_CNTBL_512;\n\n\tswitch (vpibits) {\n\tcase 0:\n\t\tconf |= SAR_CFG_VPVCS_0;\n\t\tbreak;\n\tdefault:\n\tcase 1:\n\t\tconf |= SAR_CFG_VPVCS_1;\n\t\tbreak;\n\tcase 2:\n\t\tconf |= SAR_CFG_VPVCS_2;\n\t\tbreak;\n\tcase 8:\n\t\tconf |= SAR_CFG_VPVCS_8;\n\t\tbreak;\n\t}\n\n\twritel(readl(SAR_REG_CFG) | conf, SAR_REG_CFG);\n\n\tinit_sram(card);\n\n \n \n \n\t \n\tif (0 != init_tsq(card)) {\n\t\tdeinit_card(card);\n\t\treturn -1;\n\t}\n\t \n\tif (0 != init_rsq(card)) {\n\t\tdeinit_card(card);\n\t\treturn -1;\n\t}\n\n\tcard->vpibits = vpibits;\n\tif (card->sramsize == (512 * 1024)) {\n\t\tcard->vcibits = 10 - card->vpibits;\n\t} else {\n\t\tcard->vcibits = 9 - card->vpibits;\n\t}\n\n\tcard->vcimask = 0;\n\tfor (k = 0, i = 1; k < card->vcibits; k++) {\n\t\tcard->vcimask |= i;\n\t\ti <<= 1;\n\t}\n\n\tIPRINTK(\"%s: Setting VPI/VCI mask to zero.\\n\", card->name);\n\twritel(0, SAR_REG_VPM);\n\n\t \n\twritel(0, SAR_REG_GP);\n\n\t \n\tcard->raw_cell_hnd = dma_alloc_coherent(&card->pcidev->dev,\n\t\t\t\t\t\t2 * sizeof(u32),\n\t\t\t\t\t\t&card->raw_cell_paddr,\n\t\t\t\t\t\tGFP_KERNEL);\n\tif (!card->raw_cell_hnd) {\n\t\tprintk(\"%s: memory allocation failure.\\n\", card->name);\n\t\tdeinit_card(card);\n\t\treturn -1;\n\t}\n\twritel(card->raw_cell_paddr, SAR_REG_RAWHND);\n\tIPRINTK(\"%s: raw cell handle is at 0x%p.\\n\", card->name,\n\t\tcard->raw_cell_hnd);\n\n\tsize = sizeof(struct vc_map *) * card->tct_size;\n\tIPRINTK(\"%s: allocate %d byte for VC map.\\n\", card->name, size);\n\tcard->vcs = vzalloc(size);\n\tif (!card->vcs) {\n\t\tprintk(\"%s: memory allocation failure.\\n\", card->name);\n\t\tdeinit_card(card);\n\t\treturn -1;\n\t}\n\n\tsize = sizeof(struct vc_map *) * card->scd_size;\n\tIPRINTK(\"%s: allocate %d byte for SCD to VC mapping.\\n\",\n\t        card->name, size);\n\tcard->scd2vc = vzalloc(size);\n\tif (!card->scd2vc) {\n\t\tprintk(\"%s: memory allocation failure.\\n\", card->name);\n\t\tdeinit_card(card);\n\t\treturn -1;\n\t}\n\n\tsize = sizeof(struct tst_info) * (card->tst_size - 2);\n\tIPRINTK(\"%s: allocate %d byte for TST to VC mapping.\\n\",\n\t\tcard->name, size);\n\tcard->soft_tst = vmalloc(size);\n\tif (!card->soft_tst) {\n\t\tprintk(\"%s: memory allocation failure.\\n\", card->name);\n\t\tdeinit_card(card);\n\t\treturn -1;\n\t}\n\tfor (i = 0; i < card->tst_size - 2; i++) {\n\t\tcard->soft_tst[i].tste = TSTE_OPC_VAR;\n\t\tcard->soft_tst[i].vc = NULL;\n\t}\n\n\tif (dev->phy == NULL) {\n\t\tprintk(\"%s: No LT device defined.\\n\", card->name);\n\t\tdeinit_card(card);\n\t\treturn -1;\n\t}\n\tif (dev->phy->ioctl == NULL) {\n\t\tprintk(\"%s: LT had no IOCTL function defined.\\n\", card->name);\n\t\tdeinit_card(card);\n\t\treturn -1;\n\t}\n\n#ifdef\tCONFIG_ATM_IDT77252_USE_SUNI\n\t \n\tlinkrate = 149760000;\n#endif\n\n\tcard->link_pcr = (linkrate / 8 / 53);\n\tprintk(\"%s: Linkrate on ATM line : %u bit/s, %u cell/s.\\n\",\n\t       card->name, linkrate, card->link_pcr);\n\n#ifdef ATM_IDT77252_SEND_IDLE\n\tcard->utopia_pcr = card->link_pcr;\n#else\n\tcard->utopia_pcr = (160000000 / 8 / 54);\n#endif\n\n\trsvdcr = 0;\n\tif (card->utopia_pcr > card->link_pcr)\n\t\trsvdcr = card->utopia_pcr - card->link_pcr;\n\n\ttmpl = (unsigned long) rsvdcr * ((unsigned long) card->tst_size - 2);\n\tmodl = tmpl % (unsigned long)card->utopia_pcr;\n\ttst_entries = (int) (tmpl / (unsigned long)card->utopia_pcr);\n\tif (modl)\n\t\ttst_entries++;\n\tcard->tst_free -= tst_entries;\n\tfill_tst(card, NULL, tst_entries, TSTE_OPC_NULL);\n\n#ifdef HAVE_EEPROM\n\tidt77252_eeprom_init(card);\n\tprintk(\"%s: EEPROM: %02x:\", card->name,\n\t\tidt77252_eeprom_read_status(card));\n\n\tfor (i = 0; i < 0x80; i++) {\n\t\tprintk(\" %02x\", \n\t\tidt77252_eeprom_read_byte(card, i)\n\t\t);\n\t}\n\tprintk(\"\\n\");\n#endif  \n\n\t \n\tsprintf(tname, \"eth%d\", card->index);\n\ttmp = dev_get_by_name(&init_net, tname);\t \n\tif (tmp) {\n\t\tmemcpy(card->atmdev->esi, tmp->dev_addr, 6);\n\t\tdev_put(tmp);\n\t\tprintk(\"%s: ESI %pM\\n\", card->name, card->atmdev->esi);\n\t}\n\t \n\n\t \n\twritel(0xffff, SAR_REG_MDFCT);\n\n\tset_bit(IDT77252_BIT_INIT, &card->flags);\n\n\tXPRINTK(\"%s: IDT77252 ABR SAR initialization complete.\\n\", card->name);\n\treturn 0;\n}\n\n\n \n \n \n \n \n\n\nstatic int idt77252_preset(struct idt77252_dev *card)\n{\n\tu16 pci_command;\n\n \n \n \n\n\tXPRINTK(\"%s: Enable PCI master and memory access for SAR.\\n\",\n\t\tcard->name);\n\tif (pci_read_config_word(card->pcidev, PCI_COMMAND, &pci_command)) {\n\t\tprintk(\"%s: can't read PCI_COMMAND.\\n\", card->name);\n\t\tdeinit_card(card);\n\t\treturn -1;\n\t}\n\tif (!(pci_command & PCI_COMMAND_IO)) {\n\t\tprintk(\"%s: PCI_COMMAND: %04x (?)\\n\",\n\t\t       card->name, pci_command);\n\t\tdeinit_card(card);\n\t\treturn (-1);\n\t}\n\tpci_command |= (PCI_COMMAND_MEMORY | PCI_COMMAND_MASTER);\n\tif (pci_write_config_word(card->pcidev, PCI_COMMAND, pci_command)) {\n\t\tprintk(\"%s: can't write PCI_COMMAND.\\n\", card->name);\n\t\tdeinit_card(card);\n\t\treturn -1;\n\t}\n \n \n \n\n\t \n\twritel(SAR_CFG_SWRST, SAR_REG_CFG);\n\tmdelay(1);\n\twritel(0, SAR_REG_CFG);\n\n\tIPRINTK(\"%s: Software resetted.\\n\", card->name);\n\treturn 0;\n}\n\n\nstatic unsigned long probe_sram(struct idt77252_dev *card)\n{\n\tu32 data, addr;\n\n\twritel(0, SAR_REG_DR0);\n\twritel(SAR_CMD_WRITE_SRAM | (0 << 2), SAR_REG_CMD);\n\n\tfor (addr = 0x4000; addr < 0x80000; addr += 0x4000) {\n\t\twritel(ATM_POISON, SAR_REG_DR0);\n\t\twritel(SAR_CMD_WRITE_SRAM | (addr << 2), SAR_REG_CMD);\n\n\t\twritel(SAR_CMD_READ_SRAM | (0 << 2), SAR_REG_CMD);\n\t\tdata = readl(SAR_REG_DR0);\n\n\t\tif (data != 0)\n\t\t\tbreak;\n\t}\n\n\treturn addr * sizeof(u32);\n}\n\nstatic int idt77252_init_one(struct pci_dev *pcidev,\n\t\t\t     const struct pci_device_id *id)\n{\n\tstatic struct idt77252_dev **last = &idt77252_chain;\n\tstatic int index = 0;\n\n\tunsigned long membase, srambase;\n\tstruct idt77252_dev *card;\n\tstruct atm_dev *dev;\n\tint i, err;\n\n\n\tif ((err = pci_enable_device(pcidev))) {\n\t\tprintk(\"idt77252: can't enable PCI device at %s\\n\", pci_name(pcidev));\n\t\treturn err;\n\t}\n\n\tif ((err = dma_set_mask_and_coherent(&pcidev->dev, DMA_BIT_MASK(32)))) {\n\t\tprintk(\"idt77252: can't enable DMA for PCI device at %s\\n\", pci_name(pcidev));\n\t\tgoto err_out_disable_pdev;\n\t}\n\n\tcard = kzalloc(sizeof(struct idt77252_dev), GFP_KERNEL);\n\tif (!card) {\n\t\tprintk(\"idt77252-%d: can't allocate private data\\n\", index);\n\t\terr = -ENOMEM;\n\t\tgoto err_out_disable_pdev;\n\t}\n\tcard->revision = pcidev->revision;\n\tcard->index = index;\n\tcard->pcidev = pcidev;\n\tsprintf(card->name, \"idt77252-%d\", card->index);\n\n\tINIT_WORK(&card->tqueue, idt77252_softint);\n\n\tmembase = pci_resource_start(pcidev, 1);\n\tsrambase = pci_resource_start(pcidev, 2);\n\n\tmutex_init(&card->mutex);\n\tspin_lock_init(&card->cmd_lock);\n\tspin_lock_init(&card->tst_lock);\n\n\ttimer_setup(&card->tst_timer, tst_timer, 0);\n\n\t \n\tcard->membase = ioremap(membase, 1024);\n\tif (!card->membase) {\n\t\tprintk(\"%s: can't ioremap() membase\\n\", card->name);\n\t\terr = -EIO;\n\t\tgoto err_out_free_card;\n\t}\n\n\tif (idt77252_preset(card)) {\n\t\tprintk(\"%s: preset failed\\n\", card->name);\n\t\terr = -EIO;\n\t\tgoto err_out_iounmap;\n\t}\n\n\tdev = atm_dev_register(\"idt77252\", &pcidev->dev, &idt77252_ops, -1,\n\t\t\t       NULL);\n\tif (!dev) {\n\t\tprintk(\"%s: can't register atm device\\n\", card->name);\n\t\terr = -EIO;\n\t\tgoto err_out_iounmap;\n\t}\n\tdev->dev_data = card;\n\tcard->atmdev = dev;\n\n#ifdef\tCONFIG_ATM_IDT77252_USE_SUNI\n\tsuni_init(dev);\n\tif (!dev->phy) {\n\t\tprintk(\"%s: can't init SUNI\\n\", card->name);\n\t\terr = -EIO;\n\t\tgoto err_out_deinit_card;\n\t}\n#endif\t \n\n\tcard->sramsize = probe_sram(card);\n\n\tfor (i = 0; i < 4; i++) {\n\t\tcard->fbq[i] = ioremap(srambase | 0x200000 | (i << 18), 4);\n\t\tif (!card->fbq[i]) {\n\t\t\tprintk(\"%s: can't ioremap() FBQ%d\\n\", card->name, i);\n\t\t\terr = -EIO;\n\t\t\tgoto err_out_deinit_card;\n\t\t}\n\t}\n\n\tprintk(\"%s: ABR SAR (Rev %c): MEM %08lx SRAM %08lx [%u KB]\\n\",\n\t       card->name, ((card->revision > 1) && (card->revision < 25)) ?\n\t       'A' + card->revision - 1 : '?', membase, srambase,\n\t       card->sramsize / 1024);\n\n\tif (init_card(dev)) {\n\t\tprintk(\"%s: init_card failed\\n\", card->name);\n\t\terr = -EIO;\n\t\tgoto err_out_deinit_card;\n\t}\n\n\tdev->ci_range.vpi_bits = card->vpibits;\n\tdev->ci_range.vci_bits = card->vcibits;\n\tdev->link_rate = card->link_pcr;\n\n\tif (dev->phy->start)\n\t\tdev->phy->start(dev);\n\n\tif (idt77252_dev_open(card)) {\n\t\tprintk(\"%s: dev_open failed\\n\", card->name);\n\t\terr = -EIO;\n\t\tgoto err_out_stop;\n\t}\n\n\t*last = card;\n\tlast = &card->next;\n\tindex++;\n\n\treturn 0;\n\nerr_out_stop:\n\tif (dev->phy->stop)\n\t\tdev->phy->stop(dev);\n\nerr_out_deinit_card:\n\tdeinit_card(card);\n\nerr_out_iounmap:\n\tiounmap(card->membase);\n\nerr_out_free_card:\n\tkfree(card);\n\nerr_out_disable_pdev:\n\tpci_disable_device(pcidev);\n\treturn err;\n}\n\nstatic const struct pci_device_id idt77252_pci_tbl[] =\n{\n\t{ PCI_VDEVICE(IDT, PCI_DEVICE_ID_IDT_IDT77252), 0 },\n\t{ 0, }\n};\n\nMODULE_DEVICE_TABLE(pci, idt77252_pci_tbl);\n\nstatic struct pci_driver idt77252_driver = {\n\t.name\t\t= \"idt77252\",\n\t.id_table\t= idt77252_pci_tbl,\n\t.probe\t\t= idt77252_init_one,\n};\n\nstatic int __init idt77252_init(void)\n{\n\tstruct sk_buff *skb;\n\n\tprintk(\"%s: at %p\\n\", __func__, idt77252_init);\n\tBUILD_BUG_ON(sizeof(skb->cb) < sizeof(struct idt77252_skb_prv) + sizeof(struct atm_skb_data));\n\treturn pci_register_driver(&idt77252_driver);\n}\n\nstatic void __exit idt77252_exit(void)\n{\n\tstruct idt77252_dev *card;\n\tstruct atm_dev *dev;\n\n\tpci_unregister_driver(&idt77252_driver);\n\n\twhile (idt77252_chain) {\n\t\tcard = idt77252_chain;\n\t\tdev = card->atmdev;\n\t\tidt77252_chain = card->next;\n\t\ttimer_shutdown_sync(&card->tst_timer);\n\n\t\tif (dev->phy->stop)\n\t\t\tdev->phy->stop(dev);\n\t\tdeinit_card(card);\n\t\tpci_disable_device(card->pcidev);\n\t\tkfree(card);\n\t}\n\n\tDIPRINTK(\"idt77252: finished cleanup-module().\\n\");\n}\n\nmodule_init(idt77252_init);\nmodule_exit(idt77252_exit);\n\nMODULE_LICENSE(\"GPL\");\n\nmodule_param(vpibits, uint, 0);\nMODULE_PARM_DESC(vpibits, \"number of VPI bits supported (0, 1, or 2)\");\n#ifdef CONFIG_ATM_IDT77252_DEBUG\nmodule_param(debug, ulong, 0644);\nMODULE_PARM_DESC(debug,   \"debug bitmap, see drivers/atm/idt77252.h\");\n#endif\n\nMODULE_AUTHOR(\"Eddie C. Dost <ecd@atecom.com>\");\nMODULE_DESCRIPTION(\"IDT77252 ABR SAR Driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}