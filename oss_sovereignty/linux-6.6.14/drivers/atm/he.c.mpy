{
  "module_name": "he.c",
  "hash_id": "c4d3f0bff83860959fa49c598988930befda2708aa6be5efe4becbf77a3c93e8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/atm/he.c",
  "human_readable_source": " \n\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/skbuff.h>\n#include <linux/pci.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/timer.h>\n#include <linux/interrupt.h>\n#include <linux/dma-mapping.h>\n#include <linux/bitmap.h>\n#include <linux/slab.h>\n#include <asm/io.h>\n#include <asm/byteorder.h>\n#include <linux/uaccess.h>\n\n#include <linux/atmdev.h>\n#include <linux/atm.h>\n#include <linux/sonet.h>\n\n#undef USE_SCATTERGATHER\n#undef USE_CHECKSUM_HW\t\t\t \n \n\n#include \"he.h\"\n#include \"suni.h\"\n#include <linux/atm_he.h>\n\n#define hprintk(fmt,args...)\tprintk(KERN_ERR DEV_LABEL \"%d: \" fmt, he_dev->number , ##args)\n\n#ifdef HE_DEBUG\n#define HPRINTK(fmt,args...)\tprintk(KERN_DEBUG DEV_LABEL \"%d: \" fmt, he_dev->number , ##args)\n#else  \n#define HPRINTK(fmt,args...)\tdo { } while (0)\n#endif  \n\n \n\nstatic int he_open(struct atm_vcc *vcc);\nstatic void he_close(struct atm_vcc *vcc);\nstatic int he_send(struct atm_vcc *vcc, struct sk_buff *skb);\nstatic int he_ioctl(struct atm_dev *dev, unsigned int cmd, void __user *arg);\nstatic irqreturn_t he_irq_handler(int irq, void *dev_id);\nstatic void he_tasklet(unsigned long data);\nstatic int he_proc_read(struct atm_dev *dev,loff_t *pos,char *page);\nstatic int he_start(struct atm_dev *dev);\nstatic void he_stop(struct he_dev *dev);\nstatic void he_phy_put(struct atm_dev *, unsigned char, unsigned long);\nstatic unsigned char he_phy_get(struct atm_dev *, unsigned long);\n\nstatic u8 read_prom_byte(struct he_dev *he_dev, int addr);\n\n \n\nstatic struct he_dev *he_devs;\nstatic bool disable64;\nstatic short nvpibits = -1;\nstatic short nvcibits = -1;\nstatic short rx_skb_reserve = 16;\nstatic bool irq_coalesce = true;\nstatic bool sdh;\n\n \nstatic unsigned int readtab[] = {\n\tCS_HIGH | CLK_HIGH,\n\tCS_LOW | CLK_LOW,\n\tCLK_HIGH,                \n\tCLK_LOW,\n\tCLK_HIGH,                \n\tCLK_LOW,\n\tCLK_HIGH,                \n\tCLK_LOW,\n\tCLK_HIGH,                \n\tCLK_LOW,\n\tCLK_HIGH,                \n\tCLK_LOW,\n\tCLK_HIGH,                \n\tCLK_LOW | SI_HIGH,\n\tCLK_HIGH | SI_HIGH,      \n\tCLK_LOW | SI_HIGH,\n\tCLK_HIGH | SI_HIGH       \n};     \n \n \nstatic unsigned int clocktab[] = {\n\tCLK_LOW,\n\tCLK_HIGH,\n\tCLK_LOW,\n\tCLK_HIGH,\n\tCLK_LOW,\n\tCLK_HIGH,\n\tCLK_LOW,\n\tCLK_HIGH,\n\tCLK_LOW,\n\tCLK_HIGH,\n\tCLK_LOW,\n\tCLK_HIGH,\n\tCLK_LOW,\n\tCLK_HIGH,\n\tCLK_LOW,\n\tCLK_HIGH,\n\tCLK_LOW\n};     \n\nstatic const struct atmdev_ops he_ops =\n{\n\t.open =\t\the_open,\n\t.close =\the_close,\t\n\t.ioctl =\the_ioctl,\t\n\t.send =\t\the_send,\n\t.phy_put =\the_phy_put,\n\t.phy_get =\the_phy_get,\n\t.proc_read =\the_proc_read,\n\t.owner =\tTHIS_MODULE\n};\n\n#define he_writel(dev, val, reg)\tdo { writel(val, (dev)->membase + (reg)); wmb(); } while (0)\n#define he_readl(dev, reg)\t\treadl((dev)->membase + (reg))\n\n \n\nstatic __inline__ void\nhe_writel_internal(struct he_dev *he_dev, unsigned val, unsigned addr,\n\t\t\t\t\t\t\t\tunsigned flags)\n{\n\the_writel(he_dev, val, CON_DAT);\n\t(void) he_readl(he_dev, CON_DAT);\t\t \n\the_writel(he_dev, flags | CON_CTL_WRITE | CON_CTL_ADDR(addr), CON_CTL);\n\twhile (he_readl(he_dev, CON_CTL) & CON_CTL_BUSY);\n}\n\n#define he_writel_rcm(dev, val, reg) \t\t\t\t\\\n\t\t\the_writel_internal(dev, val, reg, CON_CTL_RCM)\n\n#define he_writel_tcm(dev, val, reg) \t\t\t\t\\\n\t\t\the_writel_internal(dev, val, reg, CON_CTL_TCM)\n\n#define he_writel_mbox(dev, val, reg) \t\t\t\t\\\n\t\t\the_writel_internal(dev, val, reg, CON_CTL_MBOX)\n\nstatic unsigned\nhe_readl_internal(struct he_dev *he_dev, unsigned addr, unsigned flags)\n{\n\the_writel(he_dev, flags | CON_CTL_READ | CON_CTL_ADDR(addr), CON_CTL);\n\twhile (he_readl(he_dev, CON_CTL) & CON_CTL_BUSY);\n\treturn he_readl(he_dev, CON_DAT);\n}\n\n#define he_readl_rcm(dev, reg) \\\n\t\t\the_readl_internal(dev, reg, CON_CTL_RCM)\n\n#define he_readl_tcm(dev, reg) \\\n\t\t\the_readl_internal(dev, reg, CON_CTL_TCM)\n\n#define he_readl_mbox(dev, reg) \\\n\t\t\the_readl_internal(dev, reg, CON_CTL_MBOX)\n\n\n \n\n#define he_mkcid(dev, vpi, vci)\t\t(((vpi << (dev)->vcibits) | vci) & 0x1fff)\n\n \n\n#define he_writel_tsr0(dev, val, cid) \\\n\t\the_writel_tcm(dev, val, CONFIG_TSRA | (cid << 3) | 0)\n#define he_readl_tsr0(dev, cid) \\\n\t\the_readl_tcm(dev, CONFIG_TSRA | (cid << 3) | 0)\n\n#define he_writel_tsr1(dev, val, cid) \\\n\t\the_writel_tcm(dev, val, CONFIG_TSRA | (cid << 3) | 1)\n\n#define he_writel_tsr2(dev, val, cid) \\\n\t\the_writel_tcm(dev, val, CONFIG_TSRA | (cid << 3) | 2)\n\n#define he_writel_tsr3(dev, val, cid) \\\n\t\the_writel_tcm(dev, val, CONFIG_TSRA | (cid << 3) | 3)\n\n#define he_writel_tsr4(dev, val, cid) \\\n\t\the_writel_tcm(dev, val, CONFIG_TSRA | (cid << 3) | 4)\n\n\t \n\n#define he_writel_tsr4_upper(dev, val, cid) \\\n\t\the_writel_internal(dev, val, CONFIG_TSRA | (cid << 3) | 4, \\\n\t\t\t\t\t\t\tCON_CTL_TCM \\\n\t\t\t\t\t\t\t| CON_BYTE_DISABLE_2 \\\n\t\t\t\t\t\t\t| CON_BYTE_DISABLE_1 \\\n\t\t\t\t\t\t\t| CON_BYTE_DISABLE_0)\n\n#define he_readl_tsr4(dev, cid) \\\n\t\the_readl_tcm(dev, CONFIG_TSRA | (cid << 3) | 4)\n\n#define he_writel_tsr5(dev, val, cid) \\\n\t\the_writel_tcm(dev, val, CONFIG_TSRA | (cid << 3) | 5)\n\n#define he_writel_tsr6(dev, val, cid) \\\n\t\the_writel_tcm(dev, val, CONFIG_TSRA | (cid << 3) | 6)\n\n#define he_writel_tsr7(dev, val, cid) \\\n\t\the_writel_tcm(dev, val, CONFIG_TSRA | (cid << 3) | 7)\n\n\n#define he_writel_tsr8(dev, val, cid) \\\n\t\the_writel_tcm(dev, val, CONFIG_TSRB | (cid << 2) | 0)\n\n#define he_writel_tsr9(dev, val, cid) \\\n\t\the_writel_tcm(dev, val, CONFIG_TSRB | (cid << 2) | 1)\n\n#define he_writel_tsr10(dev, val, cid) \\\n\t\the_writel_tcm(dev, val, CONFIG_TSRB | (cid << 2) | 2)\n\n#define he_writel_tsr11(dev, val, cid) \\\n\t\the_writel_tcm(dev, val, CONFIG_TSRB | (cid << 2) | 3)\n\n\n#define he_writel_tsr12(dev, val, cid) \\\n\t\the_writel_tcm(dev, val, CONFIG_TSRC | (cid << 1) | 0)\n\n#define he_writel_tsr13(dev, val, cid) \\\n\t\the_writel_tcm(dev, val, CONFIG_TSRC | (cid << 1) | 1)\n\n\n#define he_writel_tsr14(dev, val, cid) \\\n\t\the_writel_tcm(dev, val, CONFIG_TSRD | cid)\n\n#define he_writel_tsr14_upper(dev, val, cid) \\\n\t\the_writel_internal(dev, val, CONFIG_TSRD | cid, \\\n\t\t\t\t\t\t\tCON_CTL_TCM \\\n\t\t\t\t\t\t\t| CON_BYTE_DISABLE_2 \\\n\t\t\t\t\t\t\t| CON_BYTE_DISABLE_1 \\\n\t\t\t\t\t\t\t| CON_BYTE_DISABLE_0)\n\n \n\n#define he_writel_rsr0(dev, val, cid) \\\n\t\the_writel_rcm(dev, val, 0x00000 | (cid << 3) | 0)\n#define he_readl_rsr0(dev, cid) \\\n\t\the_readl_rcm(dev, 0x00000 | (cid << 3) | 0)\n\n#define he_writel_rsr1(dev, val, cid) \\\n\t\the_writel_rcm(dev, val, 0x00000 | (cid << 3) | 1)\n\n#define he_writel_rsr2(dev, val, cid) \\\n\t\the_writel_rcm(dev, val, 0x00000 | (cid << 3) | 2)\n\n#define he_writel_rsr3(dev, val, cid) \\\n\t\the_writel_rcm(dev, val, 0x00000 | (cid << 3) | 3)\n\n#define he_writel_rsr4(dev, val, cid) \\\n\t\the_writel_rcm(dev, val, 0x00000 | (cid << 3) | 4)\n\n#define he_writel_rsr5(dev, val, cid) \\\n\t\the_writel_rcm(dev, val, 0x00000 | (cid << 3) | 5)\n\n#define he_writel_rsr6(dev, val, cid) \\\n\t\the_writel_rcm(dev, val, 0x00000 | (cid << 3) | 6)\n\n#define he_writel_rsr7(dev, val, cid) \\\n\t\the_writel_rcm(dev, val, 0x00000 | (cid << 3) | 7)\n\nstatic __inline__ struct atm_vcc*\n__find_vcc(struct he_dev *he_dev, unsigned cid)\n{\n\tstruct hlist_head *head;\n\tstruct atm_vcc *vcc;\n\tstruct sock *s;\n\tshort vpi;\n\tint vci;\n\n\tvpi = cid >> he_dev->vcibits;\n\tvci = cid & ((1 << he_dev->vcibits) - 1);\n\thead = &vcc_hash[vci & (VCC_HTABLE_SIZE -1)];\n\n\tsk_for_each(s, head) {\n\t\tvcc = atm_sk(s);\n\t\tif (vcc->dev == he_dev->atm_dev &&\n\t\t    vcc->vci == vci && vcc->vpi == vpi &&\n\t\t    vcc->qos.rxtp.traffic_class != ATM_NONE) {\n\t\t\t\treturn vcc;\n\t\t}\n\t}\n\treturn NULL;\n}\n\nstatic int he_init_one(struct pci_dev *pci_dev,\n\t\t       const struct pci_device_id *pci_ent)\n{\n\tstruct atm_dev *atm_dev = NULL;\n\tstruct he_dev *he_dev = NULL;\n\tint err = 0;\n\n\tprintk(KERN_INFO \"ATM he driver\\n\");\n\n\tif (pci_enable_device(pci_dev))\n\t\treturn -EIO;\n\tif (dma_set_mask_and_coherent(&pci_dev->dev, DMA_BIT_MASK(32)) != 0) {\n\t\tprintk(KERN_WARNING \"he: no suitable dma available\\n\");\n\t\terr = -EIO;\n\t\tgoto init_one_failure;\n\t}\n\n\tatm_dev = atm_dev_register(DEV_LABEL, &pci_dev->dev, &he_ops, -1, NULL);\n\tif (!atm_dev) {\n\t\terr = -ENODEV;\n\t\tgoto init_one_failure;\n\t}\n\tpci_set_drvdata(pci_dev, atm_dev);\n\n\the_dev = kzalloc(sizeof(struct he_dev),\n\t\t\t\t\t\t\tGFP_KERNEL);\n\tif (!he_dev) {\n\t\terr = -ENOMEM;\n\t\tgoto init_one_failure;\n\t}\n\the_dev->pci_dev = pci_dev;\n\the_dev->atm_dev = atm_dev;\n\the_dev->atm_dev->dev_data = he_dev;\n\tatm_dev->dev_data = he_dev;\n\the_dev->number = atm_dev->number;\n\ttasklet_init(&he_dev->tasklet, he_tasklet, (unsigned long) he_dev);\n\tspin_lock_init(&he_dev->global_lock);\n\n\tif (he_start(atm_dev)) {\n\t\the_stop(he_dev);\n\t\terr = -ENODEV;\n\t\tgoto init_one_failure;\n\t}\n\the_dev->next = NULL;\n\tif (he_devs)\n\t\the_dev->next = he_devs;\n\the_devs = he_dev;\n\treturn 0;\n\ninit_one_failure:\n\tif (atm_dev)\n\t\tatm_dev_deregister(atm_dev);\n\tkfree(he_dev);\n\tpci_disable_device(pci_dev);\n\treturn err;\n}\n\nstatic void he_remove_one(struct pci_dev *pci_dev)\n{\n\tstruct atm_dev *atm_dev;\n\tstruct he_dev *he_dev;\n\n\tatm_dev = pci_get_drvdata(pci_dev);\n\the_dev = HE_DEV(atm_dev);\n\n\t \n\n\the_stop(he_dev);\n\tatm_dev_deregister(atm_dev);\n\tkfree(he_dev);\n\n\tpci_disable_device(pci_dev);\n}\n\n\nstatic unsigned\nrate_to_atmf(unsigned rate)\t\t \n{\n#define NONZERO (1 << 14)\n\n\tunsigned exp = 0;\n\n\tif (rate == 0)\n\t\treturn 0;\n\n\trate <<= 9;\n\twhile (rate > 0x3ff) {\n\t\t++exp;\n\t\trate >>= 1;\n\t}\n\n\treturn (NONZERO | (exp << 9) | (rate & 0x1ff));\n}\n\nstatic void he_init_rx_lbfp0(struct he_dev *he_dev)\n{\n\tunsigned i, lbm_offset, lbufd_index, lbuf_addr, lbuf_count;\n\tunsigned lbufs_per_row = he_dev->cells_per_row / he_dev->cells_per_lbuf;\n\tunsigned lbuf_bufsize = he_dev->cells_per_lbuf * ATM_CELL_PAYLOAD;\n\tunsigned row_offset = he_dev->r0_startrow * he_dev->bytes_per_row;\n\t\n\tlbufd_index = 0;\n\tlbm_offset = he_readl(he_dev, RCMLBM_BA);\n\n\the_writel(he_dev, lbufd_index, RLBF0_H);\n\n\tfor (i = 0, lbuf_count = 0; i < he_dev->r0_numbuffs; ++i) {\n\t\tlbufd_index += 2;\n\t\tlbuf_addr = (row_offset + (lbuf_count * lbuf_bufsize)) / 32;\n\n\t\the_writel_rcm(he_dev, lbuf_addr, lbm_offset);\n\t\the_writel_rcm(he_dev, lbufd_index, lbm_offset + 1);\n\n\t\tif (++lbuf_count == lbufs_per_row) {\n\t\t\tlbuf_count = 0;\n\t\t\trow_offset += he_dev->bytes_per_row;\n\t\t}\n\t\tlbm_offset += 4;\n\t}\n\t\t\n\the_writel(he_dev, lbufd_index - 2, RLBF0_T);\n\the_writel(he_dev, he_dev->r0_numbuffs, RLBF0_C);\n}\n\nstatic void he_init_rx_lbfp1(struct he_dev *he_dev)\n{\n\tunsigned i, lbm_offset, lbufd_index, lbuf_addr, lbuf_count;\n\tunsigned lbufs_per_row = he_dev->cells_per_row / he_dev->cells_per_lbuf;\n\tunsigned lbuf_bufsize = he_dev->cells_per_lbuf * ATM_CELL_PAYLOAD;\n\tunsigned row_offset = he_dev->r1_startrow * he_dev->bytes_per_row;\n\t\n\tlbufd_index = 1;\n\tlbm_offset = he_readl(he_dev, RCMLBM_BA) + (2 * lbufd_index);\n\n\the_writel(he_dev, lbufd_index, RLBF1_H);\n\n\tfor (i = 0, lbuf_count = 0; i < he_dev->r1_numbuffs; ++i) {\n\t\tlbufd_index += 2;\n\t\tlbuf_addr = (row_offset + (lbuf_count * lbuf_bufsize)) / 32;\n\n\t\the_writel_rcm(he_dev, lbuf_addr, lbm_offset);\n\t\the_writel_rcm(he_dev, lbufd_index, lbm_offset + 1);\n\n\t\tif (++lbuf_count == lbufs_per_row) {\n\t\t\tlbuf_count = 0;\n\t\t\trow_offset += he_dev->bytes_per_row;\n\t\t}\n\t\tlbm_offset += 4;\n\t}\n\t\t\n\the_writel(he_dev, lbufd_index - 2, RLBF1_T);\n\the_writel(he_dev, he_dev->r1_numbuffs, RLBF1_C);\n}\n\nstatic void he_init_tx_lbfp(struct he_dev *he_dev)\n{\n\tunsigned i, lbm_offset, lbufd_index, lbuf_addr, lbuf_count;\n\tunsigned lbufs_per_row = he_dev->cells_per_row / he_dev->cells_per_lbuf;\n\tunsigned lbuf_bufsize = he_dev->cells_per_lbuf * ATM_CELL_PAYLOAD;\n\tunsigned row_offset = he_dev->tx_startrow * he_dev->bytes_per_row;\n\t\n\tlbufd_index = he_dev->r0_numbuffs + he_dev->r1_numbuffs;\n\tlbm_offset = he_readl(he_dev, RCMLBM_BA) + (2 * lbufd_index);\n\n\the_writel(he_dev, lbufd_index, TLBF_H);\n\n\tfor (i = 0, lbuf_count = 0; i < he_dev->tx_numbuffs; ++i) {\n\t\tlbufd_index += 1;\n\t\tlbuf_addr = (row_offset + (lbuf_count * lbuf_bufsize)) / 32;\n\n\t\the_writel_rcm(he_dev, lbuf_addr, lbm_offset);\n\t\the_writel_rcm(he_dev, lbufd_index, lbm_offset + 1);\n\n\t\tif (++lbuf_count == lbufs_per_row) {\n\t\t\tlbuf_count = 0;\n\t\t\trow_offset += he_dev->bytes_per_row;\n\t\t}\n\t\tlbm_offset += 2;\n\t}\n\t\t\n\the_writel(he_dev, lbufd_index - 1, TLBF_T);\n}\n\nstatic int he_init_tpdrq(struct he_dev *he_dev)\n{\n\the_dev->tpdrq_base = dma_alloc_coherent(&he_dev->pci_dev->dev,\n\t\t\t\t\t\tCONFIG_TPDRQ_SIZE * sizeof(struct he_tpdrq),\n\t\t\t\t\t\t&he_dev->tpdrq_phys,\n\t\t\t\t\t\tGFP_KERNEL);\n\tif (he_dev->tpdrq_base == NULL) {\n\t\thprintk(\"failed to alloc tpdrq\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\the_dev->tpdrq_tail = he_dev->tpdrq_base;\n\the_dev->tpdrq_head = he_dev->tpdrq_base;\n\n\the_writel(he_dev, he_dev->tpdrq_phys, TPDRQ_B_H);\n\the_writel(he_dev, 0, TPDRQ_T);\t\n\the_writel(he_dev, CONFIG_TPDRQ_SIZE - 1, TPDRQ_S);\n\n\treturn 0;\n}\n\nstatic void he_init_cs_block(struct he_dev *he_dev)\n{\n\tunsigned clock, rate, delta;\n\tint reg;\n\n\t \n\n\tfor (reg = 0; reg < 0x20; ++reg)\n\t\the_writel_mbox(he_dev, 0x0, CS_STTIM0 + reg);\n\n\t \n\n\tclock = he_is622(he_dev) ? 66667000 : 50000000;\n\trate = he_dev->atm_dev->link_rate;\n\tdelta = rate / 16 / 2;\n\n\tfor (reg = 0; reg < 0x10; ++reg) {\n\t\t \n\t\tunsigned period = clock / rate;\n\n\t\the_writel_mbox(he_dev, period, CS_TGRLD0 + reg);\n\t\trate -= delta;\n\t}\n\n\tif (he_is622(he_dev)) {\n\t\t \n\t\the_writel_mbox(he_dev, 0x000800fa, CS_ERTHR0);\n\t\the_writel_mbox(he_dev, 0x000c33cb, CS_ERTHR1);\n\t\the_writel_mbox(he_dev, 0x0010101b, CS_ERTHR2);\n\t\the_writel_mbox(he_dev, 0x00181dac, CS_ERTHR3);\n\t\the_writel_mbox(he_dev, 0x00280600, CS_ERTHR4);\n\n\t\t \n\t\the_writel_mbox(he_dev, 0x023de8b3, CS_ERCTL0);\n\t\the_writel_mbox(he_dev, 0x1801, CS_ERCTL1);\n\t\the_writel_mbox(he_dev, 0x68b3, CS_ERCTL2);\n\t\the_writel_mbox(he_dev, 0x1280, CS_ERSTAT0);\n\t\the_writel_mbox(he_dev, 0x68b3, CS_ERSTAT1);\n\t\the_writel_mbox(he_dev, 0x14585, CS_RTFWR);\n\n\t\the_writel_mbox(he_dev, 0x4680, CS_RTATR);\n\n\t\t \n\t\the_writel_mbox(he_dev, 0x00159ece, CS_TFBSET);\n\t\the_writel_mbox(he_dev, 0x68b3, CS_WCRMAX);\n\t\the_writel_mbox(he_dev, 0x5eb3, CS_WCRMIN);\n\t\the_writel_mbox(he_dev, 0xe8b3, CS_WCRINC);\n\t\the_writel_mbox(he_dev, 0xdeb3, CS_WCRDEC);\n\t\the_writel_mbox(he_dev, 0x68b3, CS_WCRCEIL);\n\n\t\t \n\t\the_writel_mbox(he_dev, 0x5, CS_OTPPER);\n\t\the_writel_mbox(he_dev, 0x14, CS_OTWPER);\n\t} else {\n\t\t \n\t\the_writel_mbox(he_dev, 0x000400ea, CS_ERTHR0);\n\t\the_writel_mbox(he_dev, 0x00063388, CS_ERTHR1);\n\t\the_writel_mbox(he_dev, 0x00081018, CS_ERTHR2);\n\t\the_writel_mbox(he_dev, 0x000c1dac, CS_ERTHR3);\n\t\the_writel_mbox(he_dev, 0x0014051a, CS_ERTHR4);\n\n\t\t \n\t\the_writel_mbox(he_dev, 0x0235e4b1, CS_ERCTL0);\n\t\the_writel_mbox(he_dev, 0x4701, CS_ERCTL1);\n\t\the_writel_mbox(he_dev, 0x64b1, CS_ERCTL2);\n\t\the_writel_mbox(he_dev, 0x1280, CS_ERSTAT0);\n\t\the_writel_mbox(he_dev, 0x64b1, CS_ERSTAT1);\n\t\the_writel_mbox(he_dev, 0xf424, CS_RTFWR);\n\n\t\the_writel_mbox(he_dev, 0x4680, CS_RTATR);\n\n\t\t \n\t\the_writel_mbox(he_dev, 0x000563b7, CS_TFBSET);\n\t\the_writel_mbox(he_dev, 0x64b1, CS_WCRMAX);\n\t\the_writel_mbox(he_dev, 0x5ab1, CS_WCRMIN);\n\t\the_writel_mbox(he_dev, 0xe4b1, CS_WCRINC);\n\t\the_writel_mbox(he_dev, 0xdab1, CS_WCRDEC);\n\t\the_writel_mbox(he_dev, 0x64b1, CS_WCRCEIL);\n\n\t\t \n\t\the_writel_mbox(he_dev, 0x6, CS_OTPPER);\n\t\the_writel_mbox(he_dev, 0x1e, CS_OTWPER);\n\t}\n\n\the_writel_mbox(he_dev, 0x8, CS_OTTLIM);\n\n\tfor (reg = 0; reg < 0x8; ++reg)\n\t\the_writel_mbox(he_dev, 0x0, CS_HGRRT0 + reg);\n\n}\n\nstatic int he_init_cs_block_rcm(struct he_dev *he_dev)\n{\n\tunsigned (*rategrid)[16][16];\n\tunsigned rate, delta;\n\tint i, j, reg;\n\n\tunsigned rate_atmf, exp, man;\n\tunsigned long long rate_cps;\n\tint mult, buf, buf_limit = 4;\n\n\trategrid = kmalloc( sizeof(unsigned) * 16 * 16, GFP_KERNEL);\n\tif (!rategrid)\n\t\treturn -ENOMEM;\n\n\t \n\n\tfor (reg = 0x0; reg < 0xff; ++reg)\n\t\the_writel_rcm(he_dev, 0x0, CONFIG_RCMABR + reg);\n\n\t \n\n\tfor (reg = 0x100; reg < 0x1ff; ++reg)\n\t\the_writel_rcm(he_dev, 0x0, CONFIG_RCMABR + reg);\n\t\n\t \n\n\t \n\t\n\t \n\n\trate = he_dev->atm_dev->link_rate;\n\tdelta = rate / 32;\n\n\t \n\n\tfor (j = 0; j < 16; j++) {\n\t\t(*rategrid)[0][j] = rate;\n\t\trate -= delta;\n\t}\n\n\tfor (i = 1; i < 16; i++)\n\t\tfor (j = 0; j < 16; j++)\n\t\t\tif (i > 14)\n\t\t\t\t(*rategrid)[i][j] = (*rategrid)[i - 1][j] / 4;\n\t\t\telse\n\t\t\t\t(*rategrid)[i][j] = (*rategrid)[i - 1][j] / 2;\n\n\t \n\n\trate_atmf = 0;\n\twhile (rate_atmf < 0x400) {\n\t\tman = (rate_atmf & 0x1f) << 4;\n\t\texp = rate_atmf >> 5;\n\n\t\t \n\t\trate_cps = (unsigned long long) (1UL << exp) * (man + 512) >> 9;\n\n\t\tif (rate_cps < 10)\n\t\t\trate_cps = 10;\t \n\n\t\tfor (i = 255; i > 0; i--)\n\t\t\tif ((*rategrid)[i/16][i%16] >= rate_cps)\n\t\t\t\tbreak;\t  \n\n\t\t \n\n#ifdef notdef\n\t\tbuf = rate_cps * he_dev->tx_numbuffs /\n\t\t\t\t(he_dev->atm_dev->link_rate * 2);\n#else\n\t\t \n\t\tmult = he_dev->atm_dev->link_rate / ATM_OC3_PCR;\n\t\tif (rate_cps > (272ULL * mult))\n\t\t\tbuf = 4;\n\t\telse if (rate_cps > (204ULL * mult))\n\t\t\tbuf = 3;\n\t\telse if (rate_cps > (136ULL * mult))\n\t\t\tbuf = 2;\n\t\telse if (rate_cps > (68ULL * mult))\n\t\t\tbuf = 1;\n\t\telse\n\t\t\tbuf = 0;\n#endif\n\t\tif (buf > buf_limit)\n\t\t\tbuf = buf_limit;\n\t\treg = (reg << 16) | ((i << 8) | buf);\n\n#define RTGTBL_OFFSET 0x400\n\t  \n\t\tif (rate_atmf & 0x1)\n\t\t\the_writel_rcm(he_dev, reg,\n\t\t\t\tCONFIG_RCMABR + RTGTBL_OFFSET + (rate_atmf >> 1));\n\n\t\t++rate_atmf;\n\t}\n\n\tkfree(rategrid);\n\treturn 0;\n}\n\nstatic int he_init_group(struct he_dev *he_dev, int group)\n{\n\tstruct he_buff *heb, *next;\n\tdma_addr_t mapping;\n\tint i;\n\n\the_writel(he_dev, 0x0, G0_RBPS_S + (group * 32));\n\the_writel(he_dev, 0x0, G0_RBPS_T + (group * 32));\n\the_writel(he_dev, 0x0, G0_RBPS_QI + (group * 32));\n\the_writel(he_dev, RBP_THRESH(0x1) | RBP_QSIZE(0x0),\n\t\t  G0_RBPS_BS + (group * 32));\n\n\t \n\the_dev->rbpl_table = bitmap_zalloc(RBPL_TABLE_SIZE, GFP_KERNEL);\n\tif (!he_dev->rbpl_table) {\n\t\thprintk(\"unable to allocate rbpl bitmap table\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\the_dev->rbpl_virt = kmalloc_array(RBPL_TABLE_SIZE,\n\t\t\t\t\t  sizeof(*he_dev->rbpl_virt),\n\t\t\t\t\t  GFP_KERNEL);\n\tif (!he_dev->rbpl_virt) {\n\t\thprintk(\"unable to allocate rbpl virt table\\n\");\n\t\tgoto out_free_rbpl_table;\n\t}\n\n\t \n\the_dev->rbpl_pool = dma_pool_create(\"rbpl\", &he_dev->pci_dev->dev,\n\t\t\t\t\t    CONFIG_RBPL_BUFSIZE, 64, 0);\n\tif (he_dev->rbpl_pool == NULL) {\n\t\thprintk(\"unable to create rbpl pool\\n\");\n\t\tgoto out_free_rbpl_virt;\n\t}\n\n\the_dev->rbpl_base = dma_alloc_coherent(&he_dev->pci_dev->dev,\n\t\t\t\t\t       CONFIG_RBPL_SIZE * sizeof(struct he_rbp),\n\t\t\t\t\t       &he_dev->rbpl_phys, GFP_KERNEL);\n\tif (he_dev->rbpl_base == NULL) {\n\t\thprintk(\"failed to alloc rbpl_base\\n\");\n\t\tgoto out_destroy_rbpl_pool;\n\t}\n\n\tINIT_LIST_HEAD(&he_dev->rbpl_outstanding);\n\n\tfor (i = 0; i < CONFIG_RBPL_SIZE; ++i) {\n\n\t\theb = dma_pool_alloc(he_dev->rbpl_pool, GFP_KERNEL, &mapping);\n\t\tif (!heb)\n\t\t\tgoto out_free_rbpl;\n\t\theb->mapping = mapping;\n\t\tlist_add(&heb->entry, &he_dev->rbpl_outstanding);\n\n\t\tset_bit(i, he_dev->rbpl_table);\n\t\the_dev->rbpl_virt[i] = heb;\n\t\the_dev->rbpl_hint = i + 1;\n\t\the_dev->rbpl_base[i].idx =  i << RBP_IDX_OFFSET;\n\t\the_dev->rbpl_base[i].phys = mapping + offsetof(struct he_buff, data);\n\t}\n\the_dev->rbpl_tail = &he_dev->rbpl_base[CONFIG_RBPL_SIZE - 1];\n\n\the_writel(he_dev, he_dev->rbpl_phys, G0_RBPL_S + (group * 32));\n\the_writel(he_dev, RBPL_MASK(he_dev->rbpl_tail),\n\t\t\t\t\t\tG0_RBPL_T + (group * 32));\n\the_writel(he_dev, (CONFIG_RBPL_BUFSIZE - sizeof(struct he_buff))/4,\n\t\t\t\t\t\tG0_RBPL_BS + (group * 32));\n\the_writel(he_dev,\n\t\t\tRBP_THRESH(CONFIG_RBPL_THRESH) |\n\t\t\tRBP_QSIZE(CONFIG_RBPL_SIZE - 1) |\n\t\t\tRBP_INT_ENB,\n\t\t\t\t\t\tG0_RBPL_QI + (group * 32));\n\n\t \n\n\the_dev->rbrq_base = dma_alloc_coherent(&he_dev->pci_dev->dev,\n\t\t\t\t\t       CONFIG_RBRQ_SIZE * sizeof(struct he_rbrq),\n\t\t\t\t\t       &he_dev->rbrq_phys, GFP_KERNEL);\n\tif (he_dev->rbrq_base == NULL) {\n\t\thprintk(\"failed to allocate rbrq\\n\");\n\t\tgoto out_free_rbpl;\n\t}\n\n\the_dev->rbrq_head = he_dev->rbrq_base;\n\the_writel(he_dev, he_dev->rbrq_phys, G0_RBRQ_ST + (group * 16));\n\the_writel(he_dev, 0, G0_RBRQ_H + (group * 16));\n\the_writel(he_dev,\n\t\tRBRQ_THRESH(CONFIG_RBRQ_THRESH) | RBRQ_SIZE(CONFIG_RBRQ_SIZE - 1),\n\t\t\t\t\t\tG0_RBRQ_Q + (group * 16));\n\tif (irq_coalesce) {\n\t\thprintk(\"coalescing interrupts\\n\");\n\t\the_writel(he_dev, RBRQ_TIME(768) | RBRQ_COUNT(7),\n\t\t\t\t\t\tG0_RBRQ_I + (group * 16));\n\t} else\n\t\the_writel(he_dev, RBRQ_TIME(0) | RBRQ_COUNT(1),\n\t\t\t\t\t\tG0_RBRQ_I + (group * 16));\n\n\t \n\n\the_dev->tbrq_base = dma_alloc_coherent(&he_dev->pci_dev->dev,\n\t\t\t\t\t       CONFIG_TBRQ_SIZE * sizeof(struct he_tbrq),\n\t\t\t\t\t       &he_dev->tbrq_phys, GFP_KERNEL);\n\tif (he_dev->tbrq_base == NULL) {\n\t\thprintk(\"failed to allocate tbrq\\n\");\n\t\tgoto out_free_rbpq_base;\n\t}\n\n\the_dev->tbrq_head = he_dev->tbrq_base;\n\n\the_writel(he_dev, he_dev->tbrq_phys, G0_TBRQ_B_T + (group * 16));\n\the_writel(he_dev, 0, G0_TBRQ_H + (group * 16));\n\the_writel(he_dev, CONFIG_TBRQ_SIZE - 1, G0_TBRQ_S + (group * 16));\n\the_writel(he_dev, CONFIG_TBRQ_THRESH, G0_TBRQ_THRESH + (group * 16));\n\n\treturn 0;\n\nout_free_rbpq_base:\n\tdma_free_coherent(&he_dev->pci_dev->dev, CONFIG_RBRQ_SIZE *\n\t\t\t  sizeof(struct he_rbrq), he_dev->rbrq_base,\n\t\t\t  he_dev->rbrq_phys);\nout_free_rbpl:\n\tlist_for_each_entry_safe(heb, next, &he_dev->rbpl_outstanding, entry)\n\t\tdma_pool_free(he_dev->rbpl_pool, heb, heb->mapping);\n\n\tdma_free_coherent(&he_dev->pci_dev->dev, CONFIG_RBPL_SIZE *\n\t\t\t  sizeof(struct he_rbp), he_dev->rbpl_base,\n\t\t\t  he_dev->rbpl_phys);\nout_destroy_rbpl_pool:\n\tdma_pool_destroy(he_dev->rbpl_pool);\nout_free_rbpl_virt:\n\tkfree(he_dev->rbpl_virt);\nout_free_rbpl_table:\n\tbitmap_free(he_dev->rbpl_table);\n\n\treturn -ENOMEM;\n}\n\nstatic int he_init_irq(struct he_dev *he_dev)\n{\n\tint i;\n\n\t \n\n\the_dev->irq_base = dma_alloc_coherent(&he_dev->pci_dev->dev,\n\t\t\t\t\t      (CONFIG_IRQ_SIZE + 1) * sizeof(struct he_irq),\n\t\t\t\t\t      &he_dev->irq_phys, GFP_KERNEL);\n\tif (he_dev->irq_base == NULL) {\n\t\thprintk(\"failed to allocate irq\\n\");\n\t\treturn -ENOMEM;\n\t}\n\the_dev->irq_tailoffset = (unsigned *)\n\t\t\t\t\t&he_dev->irq_base[CONFIG_IRQ_SIZE];\n\t*he_dev->irq_tailoffset = 0;\n\the_dev->irq_head = he_dev->irq_base;\n\the_dev->irq_tail = he_dev->irq_base;\n\n\tfor (i = 0; i < CONFIG_IRQ_SIZE; ++i)\n\t\the_dev->irq_base[i].isw = ITYPE_INVALID;\n\n\the_writel(he_dev, he_dev->irq_phys, IRQ0_BASE);\n\the_writel(he_dev,\n\t\tIRQ_SIZE(CONFIG_IRQ_SIZE) | IRQ_THRESH(CONFIG_IRQ_THRESH),\n\t\t\t\t\t\t\t\tIRQ0_HEAD);\n\the_writel(he_dev, IRQ_INT_A | IRQ_TYPE_LINE, IRQ0_CNTL);\n\the_writel(he_dev, 0x0, IRQ0_DATA);\n\n\the_writel(he_dev, 0x0, IRQ1_BASE);\n\the_writel(he_dev, 0x0, IRQ1_HEAD);\n\the_writel(he_dev, 0x0, IRQ1_CNTL);\n\the_writel(he_dev, 0x0, IRQ1_DATA);\n\n\the_writel(he_dev, 0x0, IRQ2_BASE);\n\the_writel(he_dev, 0x0, IRQ2_HEAD);\n\the_writel(he_dev, 0x0, IRQ2_CNTL);\n\the_writel(he_dev, 0x0, IRQ2_DATA);\n\n\the_writel(he_dev, 0x0, IRQ3_BASE);\n\the_writel(he_dev, 0x0, IRQ3_HEAD);\n\the_writel(he_dev, 0x0, IRQ3_CNTL);\n\the_writel(he_dev, 0x0, IRQ3_DATA);\n\n\t \n\n\the_writel(he_dev, 0x0, GRP_10_MAP);\n\the_writel(he_dev, 0x0, GRP_32_MAP);\n\the_writel(he_dev, 0x0, GRP_54_MAP);\n\the_writel(he_dev, 0x0, GRP_76_MAP);\n\n\tif (request_irq(he_dev->pci_dev->irq,\n\t\t\the_irq_handler, IRQF_SHARED, DEV_LABEL, he_dev)) {\n\t\thprintk(\"irq %d already in use\\n\", he_dev->pci_dev->irq);\n\t\treturn -EINVAL;\n\t}   \n\n\the_dev->irq = he_dev->pci_dev->irq;\n\n\treturn 0;\n}\n\nstatic int he_start(struct atm_dev *dev)\n{\n\tstruct he_dev *he_dev;\n\tstruct pci_dev *pci_dev;\n\tunsigned long membase;\n\n\tu16 command;\n\tu32 gen_cntl_0, host_cntl, lb_swap;\n\tu8 cache_size, timer;\n\t\n\tunsigned err;\n\tunsigned int status, reg;\n\tint i, group;\n\n\the_dev = HE_DEV(dev);\n\tpci_dev = he_dev->pci_dev;\n\n\tmembase = pci_resource_start(pci_dev, 0);\n\tHPRINTK(\"membase = 0x%lx  irq = %d.\\n\", membase, pci_dev->irq);\n\n\t \n\n\t \n\tif (pci_read_config_dword(pci_dev, GEN_CNTL_0, &gen_cntl_0) != 0) {\n\t\thprintk(\"can't read GEN_CNTL_0\\n\");\n\t\treturn -EINVAL;\n\t}\n\tgen_cntl_0 |= (MRL_ENB | MRM_ENB | IGNORE_TIMEOUT);\n\tif (pci_write_config_dword(pci_dev, GEN_CNTL_0, gen_cntl_0) != 0) {\n\t\thprintk(\"can't write GEN_CNTL_0.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (pci_read_config_word(pci_dev, PCI_COMMAND, &command) != 0) {\n\t\thprintk(\"can't read PCI_COMMAND.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tcommand |= (PCI_COMMAND_MEMORY | PCI_COMMAND_MASTER | PCI_COMMAND_INVALIDATE);\n\tif (pci_write_config_word(pci_dev, PCI_COMMAND, command) != 0) {\n\t\thprintk(\"can't enable memory.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (pci_read_config_byte(pci_dev, PCI_CACHE_LINE_SIZE, &cache_size)) {\n\t\thprintk(\"can't read cache line size?\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (cache_size < 16) {\n\t\tcache_size = 16;\n\t\tif (pci_write_config_byte(pci_dev, PCI_CACHE_LINE_SIZE, cache_size))\n\t\t\thprintk(\"can't set cache line size to %d\\n\", cache_size);\n\t}\n\n\tif (pci_read_config_byte(pci_dev, PCI_LATENCY_TIMER, &timer)) {\n\t\thprintk(\"can't read latency timer?\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t  \n#define LAT_TIMER 209\n\tif (timer < LAT_TIMER) {\n\t\tHPRINTK(\"latency timer was %d, setting to %d\\n\", timer, LAT_TIMER);\n\t\ttimer = LAT_TIMER;\n\t\tif (pci_write_config_byte(pci_dev, PCI_LATENCY_TIMER, timer))\n\t\t\thprintk(\"can't set latency timer to %d\\n\", timer);\n\t}\n\n\tif (!(he_dev->membase = ioremap(membase, HE_REGMAP_SIZE))) {\n\t\thprintk(\"can't set up page mapping\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\the_writel(he_dev, 0x0, RESET_CNTL);\n\the_writel(he_dev, 0xff, RESET_CNTL);\n\n\tmsleep(16);\t \n\tstatus = he_readl(he_dev, RESET_CNTL);\n\tif ((status & BOARD_RST_STATUS) == 0) {\n\t\thprintk(\"reset failed\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\thost_cntl = he_readl(he_dev, HOST_CNTL);\n\tif (host_cntl & PCI_BUS_SIZE64)\n\t\tgen_cntl_0 |= ENBL_64;\n\telse\n\t\tgen_cntl_0 &= ~ENBL_64;\n\n\tif (disable64 == 1) {\n\t\thprintk(\"disabling 64-bit pci bus transfers\\n\");\n\t\tgen_cntl_0 &= ~ENBL_64;\n\t}\n\n\tif (gen_cntl_0 & ENBL_64)\n\t\thprintk(\"64-bit transfers enabled\\n\");\n\n\tpci_write_config_dword(pci_dev, GEN_CNTL_0, gen_cntl_0);\n\n\t \n\tfor (i = 0; i < PROD_ID_LEN; ++i)\n\t\the_dev->prod_id[i] = read_prom_byte(he_dev, PROD_ID + i);\n\n\the_dev->media = read_prom_byte(he_dev, MEDIA);\n\n\tfor (i = 0; i < 6; ++i)\n\t\tdev->esi[i] = read_prom_byte(he_dev, MAC_ADDR + i);\n\n\thprintk(\"%s%s, %pM\\n\", he_dev->prod_id,\n\t\the_dev->media & 0x40 ? \"SM\" : \"MM\", dev->esi);\n\the_dev->atm_dev->link_rate = he_is622(he_dev) ?\n\t\t\t\t\t\tATM_OC12_PCR : ATM_OC3_PCR;\n\n\t \n\tlb_swap = he_readl(he_dev, LB_SWAP);\n\tif (he_is622(he_dev))\n\t\tlb_swap &= ~XFER_SIZE;\t\t \n\telse\n\t\tlb_swap |= XFER_SIZE;\t\t \n#ifdef __BIG_ENDIAN\n\tlb_swap |= DESC_WR_SWAP | INTR_SWAP | BIG_ENDIAN_HOST;\n#else\n\tlb_swap &= ~(DESC_WR_SWAP | INTR_SWAP | BIG_ENDIAN_HOST |\n\t\t\tDATA_WR_SWAP | DATA_RD_SWAP | DESC_RD_SWAP);\n#endif  \n\the_writel(he_dev, lb_swap, LB_SWAP);\n\n\t \n\the_writel(he_dev, he_is622(he_dev) ? LB_64_ENB : 0x0, SDRAM_CTL);\n\n\t \n\tlb_swap |= SWAP_RNUM_MAX(0xf);\n\the_writel(he_dev, lb_swap, LB_SWAP);\n\n\t \n\tif ((err = he_init_irq(he_dev)) != 0)\n\t\treturn err;\n\n\t \n\thost_cntl |= (OUTFF_ENB | CMDFF_ENB |\n\t\t\t\tQUICK_RD_RETRY | QUICK_WR_RETRY | PERR_INT_ENB);\n\the_writel(he_dev, host_cntl, HOST_CNTL);\n\n\tgen_cntl_0 |= INT_PROC_ENBL|INIT_ENB;\n\tpci_write_config_dword(pci_dev, GEN_CNTL_0, gen_cntl_0);\n\n\t \n\n\t \n\n\t \n\n\t \n\the_dev->vcibits = CONFIG_DEFAULT_VCIBITS;\n\the_dev->vpibits = CONFIG_DEFAULT_VPIBITS;\n\n\tif (nvpibits != -1 && nvcibits != -1 && nvpibits+nvcibits != HE_MAXCIDBITS) {\n\t\thprintk(\"nvpibits + nvcibits != %d\\n\", HE_MAXCIDBITS);\n\t\treturn -ENODEV;\n\t}\n\n\tif (nvpibits != -1) {\n\t\the_dev->vpibits = nvpibits;\n\t\the_dev->vcibits = HE_MAXCIDBITS - nvpibits;\n\t}\n\n\tif (nvcibits != -1) {\n\t\the_dev->vcibits = nvcibits;\n\t\the_dev->vpibits = HE_MAXCIDBITS - nvcibits;\n\t}\n\n\n\tif (he_is622(he_dev)) {\n\t\the_dev->cells_per_row = 40;\n\t\the_dev->bytes_per_row = 2048;\n\t\the_dev->r0_numrows = 256;\n\t\the_dev->tx_numrows = 512;\n\t\the_dev->r1_numrows = 256;\n\t\the_dev->r0_startrow = 0;\n\t\the_dev->tx_startrow = 256;\n\t\the_dev->r1_startrow = 768;\n\t} else {\n\t\the_dev->cells_per_row = 20;\n\t\the_dev->bytes_per_row = 1024;\n\t\the_dev->r0_numrows = 512;\n\t\the_dev->tx_numrows = 1018;\n\t\the_dev->r1_numrows = 512;\n\t\the_dev->r0_startrow = 6;\n\t\the_dev->tx_startrow = 518;\n\t\the_dev->r1_startrow = 1536;\n\t}\n\n\the_dev->cells_per_lbuf = 4;\n\the_dev->buffer_limit = 4;\n\the_dev->r0_numbuffs = he_dev->r0_numrows *\n\t\t\t\the_dev->cells_per_row / he_dev->cells_per_lbuf;\n\tif (he_dev->r0_numbuffs > 2560)\n\t\the_dev->r0_numbuffs = 2560;\n\n\the_dev->r1_numbuffs = he_dev->r1_numrows *\n\t\t\t\the_dev->cells_per_row / he_dev->cells_per_lbuf;\n\tif (he_dev->r1_numbuffs > 2560)\n\t\the_dev->r1_numbuffs = 2560;\n\n\the_dev->tx_numbuffs = he_dev->tx_numrows *\n\t\t\t\the_dev->cells_per_row / he_dev->cells_per_lbuf;\n\tif (he_dev->tx_numbuffs > 5120)\n\t\the_dev->tx_numbuffs = 5120;\n\n\t \n\n\the_writel(he_dev, \n\t\tSLICE_X(0x2) | ARB_RNUM_MAX(0xf) | TH_PRTY(0x3) |\n\t\tRH_PRTY(0x3) | TL_PRTY(0x2) | RL_PRTY(0x1) |\n\t\t(he_is622(he_dev) ? BUS_MULTI(0x28) : BUS_MULTI(0x46)) |\n\t\t(he_is622(he_dev) ? NET_PREF(0x50) : NET_PREF(0x8c)),\n\t\t\t\t\t\t\t\tLBARB);\n\n\the_writel(he_dev, BANK_ON |\n\t\t(he_is622(he_dev) ? (REF_RATE(0x384) | WIDE_DATA) : REF_RATE(0x150)),\n\t\t\t\t\t\t\t\tSDRAMCON);\n\n\the_writel(he_dev,\n\t\t(he_is622(he_dev) ? RM_BANK_WAIT(1) : RM_BANK_WAIT(0)) |\n\t\t\t\t\t\tRM_RW_WAIT(1), RCMCONFIG);\n\the_writel(he_dev,\n\t\t(he_is622(he_dev) ? TM_BANK_WAIT(2) : TM_BANK_WAIT(1)) |\n\t\t\t\t\t\tTM_RW_WAIT(1), TCMCONFIG);\n\n\the_writel(he_dev, he_dev->cells_per_lbuf * ATM_CELL_PAYLOAD, LB_CONFIG);\n\n\the_writel(he_dev, \n\t\t(he_is622(he_dev) ? UT_RD_DELAY(8) : UT_RD_DELAY(0)) |\n\t\t(he_is622(he_dev) ? RC_UT_MODE(0) : RC_UT_MODE(1)) |\n\t\tRX_VALVP(he_dev->vpibits) |\n\t\tRX_VALVC(he_dev->vcibits),\t\t\t RC_CONFIG);\n\n\the_writel(he_dev, DRF_THRESH(0x20) |\n\t\t(he_is622(he_dev) ? TX_UT_MODE(0) : TX_UT_MODE(1)) |\n\t\tTX_VCI_MASK(he_dev->vcibits) |\n\t\tLBFREE_CNT(he_dev->tx_numbuffs), \t\tTX_CONFIG);\n\n\the_writel(he_dev, 0x0, TXAAL5_PROTO);\n\n\the_writel(he_dev, PHY_INT_ENB |\n\t\t(he_is622(he_dev) ? PTMR_PRE(67 - 1) : PTMR_PRE(50 - 1)),\n\t\t\t\t\t\t\t\tRH_CONFIG);\n\n\t \n\n\tfor (i = 0; i < TCM_MEM_SIZE; ++i)\n\t\the_writel_tcm(he_dev, 0, i);\n\n\tfor (i = 0; i < RCM_MEM_SIZE; ++i)\n\t\the_writel_rcm(he_dev, 0, i);\n\n\t \n\n\the_writel(he_dev, CONFIG_TSRB, TSRB_BA);\n\the_writel(he_dev, CONFIG_TSRC, TSRC_BA);\n\the_writel(he_dev, CONFIG_TSRD, TSRD_BA);\n\the_writel(he_dev, CONFIG_TMABR, TMABR_BA);\n\the_writel(he_dev, CONFIG_TPDBA, TPD_BA);\n\n\n\t \n\n\the_writel(he_dev, 0x08000, RCMLBM_BA);\n\the_writel(he_dev, 0x0e000, RCMRSRB_BA);\n\the_writel(he_dev, 0x0d800, RCMABR_BA);\n\n\t \n\n\the_init_rx_lbfp0(he_dev);\n\the_init_rx_lbfp1(he_dev);\n\n\the_writel(he_dev, 0x0, RLBC_H);\n\the_writel(he_dev, 0x0, RLBC_T);\n\the_writel(he_dev, 0x0, RLBC_H2);\n\n\the_writel(he_dev, 512, RXTHRSH);\t \n\the_writel(he_dev, 256, LITHRSH); \t \n\n\the_init_tx_lbfp(he_dev);\n\n\the_writel(he_dev, he_is622(he_dev) ? 0x104780 : 0x800, UBUFF_BA);\n\n\t \n\n\tif (he_is622(he_dev)) {\n\t\the_writel(he_dev, 0x000f, G0_INMQ_S);\n\t\the_writel(he_dev, 0x200f, G0_INMQ_L);\n\n\t\the_writel(he_dev, 0x001f, G1_INMQ_S);\n\t\the_writel(he_dev, 0x201f, G1_INMQ_L);\n\n\t\the_writel(he_dev, 0x002f, G2_INMQ_S);\n\t\the_writel(he_dev, 0x202f, G2_INMQ_L);\n\n\t\the_writel(he_dev, 0x003f, G3_INMQ_S);\n\t\the_writel(he_dev, 0x203f, G3_INMQ_L);\n\n\t\the_writel(he_dev, 0x004f, G4_INMQ_S);\n\t\the_writel(he_dev, 0x204f, G4_INMQ_L);\n\n\t\the_writel(he_dev, 0x005f, G5_INMQ_S);\n\t\the_writel(he_dev, 0x205f, G5_INMQ_L);\n\n\t\the_writel(he_dev, 0x006f, G6_INMQ_S);\n\t\the_writel(he_dev, 0x206f, G6_INMQ_L);\n\n\t\the_writel(he_dev, 0x007f, G7_INMQ_S);\n\t\the_writel(he_dev, 0x207f, G7_INMQ_L);\n\t} else {\n\t\the_writel(he_dev, 0x0000, G0_INMQ_S);\n\t\the_writel(he_dev, 0x0008, G0_INMQ_L);\n\n\t\the_writel(he_dev, 0x0001, G1_INMQ_S);\n\t\the_writel(he_dev, 0x0009, G1_INMQ_L);\n\n\t\the_writel(he_dev, 0x0002, G2_INMQ_S);\n\t\the_writel(he_dev, 0x000a, G2_INMQ_L);\n\n\t\the_writel(he_dev, 0x0003, G3_INMQ_S);\n\t\the_writel(he_dev, 0x000b, G3_INMQ_L);\n\n\t\the_writel(he_dev, 0x0004, G4_INMQ_S);\n\t\the_writel(he_dev, 0x000c, G4_INMQ_L);\n\n\t\the_writel(he_dev, 0x0005, G5_INMQ_S);\n\t\the_writel(he_dev, 0x000d, G5_INMQ_L);\n\n\t\the_writel(he_dev, 0x0006, G6_INMQ_S);\n\t\the_writel(he_dev, 0x000e, G6_INMQ_L);\n\n\t\the_writel(he_dev, 0x0007, G7_INMQ_S);\n\t\the_writel(he_dev, 0x000f, G7_INMQ_L);\n\t}\n\n\t \n\n\the_writel(he_dev, 0x0, MCC);\n\the_writel(he_dev, 0x0, OEC);\n\the_writel(he_dev, 0x0, DCC);\n\the_writel(he_dev, 0x0, CEC);\n\t\n\t \n\n\the_init_cs_block(he_dev);\n\n\t \n\t\n\tif (he_init_cs_block_rcm(he_dev) < 0)\n\t\treturn -ENOMEM;\n\n\t \n\n\the_init_tpdrq(he_dev);\n\n\the_dev->tpd_pool = dma_pool_create(\"tpd\", &he_dev->pci_dev->dev,\n\t\t\t\t\t   sizeof(struct he_tpd), TPD_ALIGNMENT, 0);\n\tif (he_dev->tpd_pool == NULL) {\n\t\thprintk(\"unable to create tpd dma_pool\\n\");\n\t\treturn -ENOMEM;         \n\t}\n\n\tINIT_LIST_HEAD(&he_dev->outstanding_tpds);\n\n\tif (he_init_group(he_dev, 0) != 0)\n\t\treturn -ENOMEM;\n\n\tfor (group = 1; group < HE_NUM_GROUPS; ++group) {\n\t\the_writel(he_dev, 0x0, G0_RBPS_S + (group * 32));\n\t\the_writel(he_dev, 0x0, G0_RBPS_T + (group * 32));\n\t\the_writel(he_dev, 0x0, G0_RBPS_QI + (group * 32));\n\t\the_writel(he_dev, RBP_THRESH(0x1) | RBP_QSIZE(0x0),\n\t\t\t\t\t\tG0_RBPS_BS + (group * 32));\n\n\t\the_writel(he_dev, 0x0, G0_RBPL_S + (group * 32));\n\t\the_writel(he_dev, 0x0, G0_RBPL_T + (group * 32));\n\t\the_writel(he_dev, RBP_THRESH(0x1) | RBP_QSIZE(0x0),\n\t\t\t\t\t\tG0_RBPL_QI + (group * 32));\n\t\the_writel(he_dev, 0x0, G0_RBPL_BS + (group * 32));\n\n\t\the_writel(he_dev, 0x0, G0_RBRQ_ST + (group * 16));\n\t\the_writel(he_dev, 0x0, G0_RBRQ_H + (group * 16));\n\t\the_writel(he_dev, RBRQ_THRESH(0x1) | RBRQ_SIZE(0x0),\n\t\t\t\t\t\tG0_RBRQ_Q + (group * 16));\n\t\the_writel(he_dev, 0x0, G0_RBRQ_I + (group * 16));\n\n\t\the_writel(he_dev, 0x0, G0_TBRQ_B_T + (group * 16));\n\t\the_writel(he_dev, 0x0, G0_TBRQ_H + (group * 16));\n\t\the_writel(he_dev, TBRQ_THRESH(0x1),\n\t\t\t\t\t\tG0_TBRQ_THRESH + (group * 16));\n\t\the_writel(he_dev, 0x0, G0_TBRQ_S + (group * 16));\n\t}\n\n\t \n\n\the_dev->hsp = dma_alloc_coherent(&he_dev->pci_dev->dev,\n\t\t\t\t\t sizeof(struct he_hsp),\n\t\t\t\t\t &he_dev->hsp_phys, GFP_KERNEL);\n\tif (he_dev->hsp == NULL) {\n\t\thprintk(\"failed to allocate host status page\\n\");\n\t\treturn -ENOMEM;\n\t}\n\the_writel(he_dev, he_dev->hsp_phys, HSP_BA);\n\n\t \n\n#ifdef CONFIG_ATM_HE_USE_SUNI\n\tif (he_isMM(he_dev))\n\t\tsuni_init(he_dev->atm_dev);\n\tif (he_dev->atm_dev->phy && he_dev->atm_dev->phy->start)\n\t\the_dev->atm_dev->phy->start(he_dev->atm_dev);\n#endif  \n\n\tif (sdh) {\n\t\t \n\t\tint val;\n\n\t\tval = he_phy_get(he_dev->atm_dev, SUNI_TPOP_APM);\n\t\tval = (val & ~SUNI_TPOP_APM_S) | (SUNI_TPOP_S_SDH << SUNI_TPOP_APM_S_SHIFT);\n\t\the_phy_put(he_dev->atm_dev, val, SUNI_TPOP_APM);\n\t\the_phy_put(he_dev->atm_dev, SUNI_TACP_IUCHP_CLP, SUNI_TACP_IUCHP);\n\t}\n\n\t \n\n\treg = he_readl_mbox(he_dev, CS_ERCTL0);\n\treg |= TX_ENABLE|ER_ENABLE;\n\the_writel_mbox(he_dev, reg, CS_ERCTL0);\n\n\treg = he_readl(he_dev, RC_CONFIG);\n\treg |= RX_ENABLE;\n\the_writel(he_dev, reg, RC_CONFIG);\n\n\tfor (i = 0; i < HE_NUM_CS_STPER; ++i) {\n\t\the_dev->cs_stper[i].inuse = 0;\n\t\the_dev->cs_stper[i].pcr = -1;\n\t}\n\the_dev->total_bw = 0;\n\n\n\t \n\n\the_dev->atm_dev->ci_range.vpi_bits = he_dev->vpibits;\n\the_dev->atm_dev->ci_range.vci_bits = he_dev->vcibits;\n\n\the_dev->irq_peak = 0;\n\the_dev->rbrq_peak = 0;\n\the_dev->rbpl_peak = 0;\n\the_dev->tbrq_peak = 0;\n\n\tHPRINTK(\"hell bent for leather!\\n\");\n\n\treturn 0;\n}\n\nstatic void\nhe_stop(struct he_dev *he_dev)\n{\n\tstruct he_buff *heb, *next;\n\tstruct pci_dev *pci_dev;\n\tu32 gen_cntl_0, reg;\n\tu16 command;\n\n\tpci_dev = he_dev->pci_dev;\n\n\t \n\n\tif (he_dev->membase) {\n\t\tpci_read_config_dword(pci_dev, GEN_CNTL_0, &gen_cntl_0);\n\t\tgen_cntl_0 &= ~(INT_PROC_ENBL | INIT_ENB);\n\t\tpci_write_config_dword(pci_dev, GEN_CNTL_0, gen_cntl_0);\n\n\t\ttasklet_disable(&he_dev->tasklet);\n\n\t\t \n\n\t\treg = he_readl_mbox(he_dev, CS_ERCTL0);\n\t\treg &= ~(TX_ENABLE|ER_ENABLE);\n\t\the_writel_mbox(he_dev, reg, CS_ERCTL0);\n\n\t\treg = he_readl(he_dev, RC_CONFIG);\n\t\treg &= ~(RX_ENABLE);\n\t\the_writel(he_dev, reg, RC_CONFIG);\n\t}\n\n#ifdef CONFIG_ATM_HE_USE_SUNI\n\tif (he_dev->atm_dev->phy && he_dev->atm_dev->phy->stop)\n\t\the_dev->atm_dev->phy->stop(he_dev->atm_dev);\n#endif  \n\n\tif (he_dev->irq)\n\t\tfree_irq(he_dev->irq, he_dev);\n\n\tif (he_dev->irq_base)\n\t\tdma_free_coherent(&he_dev->pci_dev->dev, (CONFIG_IRQ_SIZE + 1)\n\t\t\t\t  * sizeof(struct he_irq), he_dev->irq_base, he_dev->irq_phys);\n\n\tif (he_dev->hsp)\n\t\tdma_free_coherent(&he_dev->pci_dev->dev, sizeof(struct he_hsp),\n\t\t\t\t  he_dev->hsp, he_dev->hsp_phys);\n\n\tif (he_dev->rbpl_base) {\n\t\tlist_for_each_entry_safe(heb, next, &he_dev->rbpl_outstanding, entry)\n\t\t\tdma_pool_free(he_dev->rbpl_pool, heb, heb->mapping);\n\n\t\tdma_free_coherent(&he_dev->pci_dev->dev, CONFIG_RBPL_SIZE\n\t\t\t\t  * sizeof(struct he_rbp), he_dev->rbpl_base, he_dev->rbpl_phys);\n\t}\n\n\tkfree(he_dev->rbpl_virt);\n\tbitmap_free(he_dev->rbpl_table);\n\tdma_pool_destroy(he_dev->rbpl_pool);\n\n\tif (he_dev->rbrq_base)\n\t\tdma_free_coherent(&he_dev->pci_dev->dev, CONFIG_RBRQ_SIZE * sizeof(struct he_rbrq),\n\t\t\t\t  he_dev->rbrq_base, he_dev->rbrq_phys);\n\n\tif (he_dev->tbrq_base)\n\t\tdma_free_coherent(&he_dev->pci_dev->dev, CONFIG_TBRQ_SIZE * sizeof(struct he_tbrq),\n\t\t\t\t  he_dev->tbrq_base, he_dev->tbrq_phys);\n\n\tif (he_dev->tpdrq_base)\n\t\tdma_free_coherent(&he_dev->pci_dev->dev, CONFIG_TBRQ_SIZE * sizeof(struct he_tbrq),\n\t\t\t\t  he_dev->tpdrq_base, he_dev->tpdrq_phys);\n\n\tdma_pool_destroy(he_dev->tpd_pool);\n\n\tif (he_dev->pci_dev) {\n\t\tpci_read_config_word(he_dev->pci_dev, PCI_COMMAND, &command);\n\t\tcommand &= ~(PCI_COMMAND_MEMORY | PCI_COMMAND_MASTER);\n\t\tpci_write_config_word(he_dev->pci_dev, PCI_COMMAND, command);\n\t}\n\t\n\tif (he_dev->membase)\n\t\tiounmap(he_dev->membase);\n}\n\nstatic struct he_tpd *\n__alloc_tpd(struct he_dev *he_dev)\n{\n\tstruct he_tpd *tpd;\n\tdma_addr_t mapping;\n\n\ttpd = dma_pool_alloc(he_dev->tpd_pool, GFP_ATOMIC, &mapping);\n\tif (tpd == NULL)\n\t\treturn NULL;\n\t\t\t\n\ttpd->status = TPD_ADDR(mapping);\n\ttpd->reserved = 0; \n\ttpd->iovec[0].addr = 0; tpd->iovec[0].len = 0;\n\ttpd->iovec[1].addr = 0; tpd->iovec[1].len = 0;\n\ttpd->iovec[2].addr = 0; tpd->iovec[2].len = 0;\n\n\treturn tpd;\n}\n\n#define AAL5_LEN(buf,len) \t\t\t\t\t\t\\\n\t\t\t((((unsigned char *)(buf))[(len)-6] << 8) |\t\\\n\t\t\t\t(((unsigned char *)(buf))[(len)-5]))\n\n \n\n#define TCP_CKSUM(buf,len) \t\t\t\t\t\t\\\n\t\t\t((((unsigned char *)(buf))[(len)-2] << 8) |\t\\\n\t\t\t\t(((unsigned char *)(buf))[(len-1)]))\n\nstatic int\nhe_service_rbrq(struct he_dev *he_dev, int group)\n{\n\tstruct he_rbrq *rbrq_tail = (struct he_rbrq *)\n\t\t\t\t((unsigned long)he_dev->rbrq_base |\n\t\t\t\t\the_dev->hsp->group[group].rbrq_tail);\n\tunsigned cid, lastcid = -1;\n\tstruct sk_buff *skb;\n\tstruct atm_vcc *vcc = NULL;\n\tstruct he_vcc *he_vcc;\n\tstruct he_buff *heb, *next;\n\tint i;\n\tint pdus_assembled = 0;\n\tint updated = 0;\n\n\tread_lock(&vcc_sklist_lock);\n\twhile (he_dev->rbrq_head != rbrq_tail) {\n\t\t++updated;\n\n\t\tHPRINTK(\"%p rbrq%d 0x%x len=%d cid=0x%x %s%s%s%s%s%s\\n\",\n\t\t\the_dev->rbrq_head, group,\n\t\t\tRBRQ_ADDR(he_dev->rbrq_head),\n\t\t\tRBRQ_BUFLEN(he_dev->rbrq_head),\n\t\t\tRBRQ_CID(he_dev->rbrq_head),\n\t\t\tRBRQ_CRC_ERR(he_dev->rbrq_head) ? \" CRC_ERR\" : \"\",\n\t\t\tRBRQ_LEN_ERR(he_dev->rbrq_head) ? \" LEN_ERR\" : \"\",\n\t\t\tRBRQ_END_PDU(he_dev->rbrq_head) ? \" END_PDU\" : \"\",\n\t\t\tRBRQ_AAL5_PROT(he_dev->rbrq_head) ? \" AAL5_PROT\" : \"\",\n\t\t\tRBRQ_CON_CLOSED(he_dev->rbrq_head) ? \" CON_CLOSED\" : \"\",\n\t\t\tRBRQ_HBUF_ERR(he_dev->rbrq_head) ? \" HBUF_ERR\" : \"\");\n\n\t\ti = RBRQ_ADDR(he_dev->rbrq_head) >> RBP_IDX_OFFSET;\n\t\theb = he_dev->rbpl_virt[i];\n\n\t\tcid = RBRQ_CID(he_dev->rbrq_head);\n\t\tif (cid != lastcid)\n\t\t\tvcc = __find_vcc(he_dev, cid);\n\t\tlastcid = cid;\n\n\t\tif (vcc == NULL || (he_vcc = HE_VCC(vcc)) == NULL) {\n\t\t\thprintk(\"vcc/he_vcc == NULL  (cid 0x%x)\\n\", cid);\n\t\t\tif (!RBRQ_HBUF_ERR(he_dev->rbrq_head)) {\n\t\t\t\tclear_bit(i, he_dev->rbpl_table);\n\t\t\t\tlist_del(&heb->entry);\n\t\t\t\tdma_pool_free(he_dev->rbpl_pool, heb, heb->mapping);\n\t\t\t}\n\t\t\t\t\t\n\t\t\tgoto next_rbrq_entry;\n\t\t}\n\n\t\tif (RBRQ_HBUF_ERR(he_dev->rbrq_head)) {\n\t\t\thprintk(\"HBUF_ERR!  (cid 0x%x)\\n\", cid);\n\t\t\tatomic_inc(&vcc->stats->rx_drop);\n\t\t\tgoto return_host_buffers;\n\t\t}\n\n\t\theb->len = RBRQ_BUFLEN(he_dev->rbrq_head) * 4;\n\t\tclear_bit(i, he_dev->rbpl_table);\n\t\tlist_move_tail(&heb->entry, &he_vcc->buffers);\n\t\the_vcc->pdu_len += heb->len;\n\n\t\tif (RBRQ_CON_CLOSED(he_dev->rbrq_head)) {\n\t\t\tlastcid = -1;\n\t\t\tHPRINTK(\"wake_up rx_waitq  (cid 0x%x)\\n\", cid);\n\t\t\twake_up(&he_vcc->rx_waitq);\n\t\t\tgoto return_host_buffers;\n\t\t}\n\n\t\tif (!RBRQ_END_PDU(he_dev->rbrq_head))\n\t\t\tgoto next_rbrq_entry;\n\n\t\tif (RBRQ_LEN_ERR(he_dev->rbrq_head)\n\t\t\t\t|| RBRQ_CRC_ERR(he_dev->rbrq_head)) {\n\t\t\tHPRINTK(\"%s%s (%d.%d)\\n\",\n\t\t\t\tRBRQ_CRC_ERR(he_dev->rbrq_head)\n\t\t\t\t\t\t\t? \"CRC_ERR \" : \"\",\n\t\t\t\tRBRQ_LEN_ERR(he_dev->rbrq_head)\n\t\t\t\t\t\t\t? \"LEN_ERR\" : \"\",\n\t\t\t\t\t\t\tvcc->vpi, vcc->vci);\n\t\t\tatomic_inc(&vcc->stats->rx_err);\n\t\t\tgoto return_host_buffers;\n\t\t}\n\n\t\tskb = atm_alloc_charge(vcc, he_vcc->pdu_len + rx_skb_reserve,\n\t\t\t\t\t\t\tGFP_ATOMIC);\n\t\tif (!skb) {\n\t\t\tHPRINTK(\"charge failed (%d.%d)\\n\", vcc->vpi, vcc->vci);\n\t\t\tgoto return_host_buffers;\n\t\t}\n\n\t\tif (rx_skb_reserve > 0)\n\t\t\tskb_reserve(skb, rx_skb_reserve);\n\n\t\t__net_timestamp(skb);\n\n\t\tlist_for_each_entry(heb, &he_vcc->buffers, entry)\n\t\t\tskb_put_data(skb, &heb->data, heb->len);\n\n\t\tswitch (vcc->qos.aal) {\n\t\t\tcase ATM_AAL0:\n\t\t\t\t \n\t\t\t\tskb->len = ATM_AAL0_SDU;\n\t\t\t\tskb_set_tail_pointer(skb, skb->len);\n\t\t\t\tbreak;\n\t\t\tcase ATM_AAL5:\n\t\t\t\t \n\n\t\t\t\tskb->len = AAL5_LEN(skb->data, he_vcc->pdu_len);\n\t\t\t\tskb_set_tail_pointer(skb, skb->len);\n#ifdef USE_CHECKSUM_HW\n\t\t\t\tif (vcc->vpi == 0 && vcc->vci >= ATM_NOT_RSV_VCI) {\n\t\t\t\t\tskb->ip_summed = CHECKSUM_COMPLETE;\n\t\t\t\t\tskb->csum = TCP_CKSUM(skb->data,\n\t\t\t\t\t\t\the_vcc->pdu_len);\n\t\t\t\t}\n#endif\n\t\t\t\tbreak;\n\t\t}\n\n#ifdef should_never_happen\n\t\tif (skb->len > vcc->qos.rxtp.max_sdu)\n\t\t\thprintk(\"pdu_len (%d) > vcc->qos.rxtp.max_sdu (%d)!  cid 0x%x\\n\", skb->len, vcc->qos.rxtp.max_sdu, cid);\n#endif\n\n#ifdef notdef\n\t\tATM_SKB(skb)->vcc = vcc;\n#endif\n\t\tspin_unlock(&he_dev->global_lock);\n\t\tvcc->push(vcc, skb);\n\t\tspin_lock(&he_dev->global_lock);\n\n\t\tatomic_inc(&vcc->stats->rx);\n\nreturn_host_buffers:\n\t\t++pdus_assembled;\n\n\t\tlist_for_each_entry_safe(heb, next, &he_vcc->buffers, entry)\n\t\t\tdma_pool_free(he_dev->rbpl_pool, heb, heb->mapping);\n\t\tINIT_LIST_HEAD(&he_vcc->buffers);\n\t\the_vcc->pdu_len = 0;\n\nnext_rbrq_entry:\n\t\the_dev->rbrq_head = (struct he_rbrq *)\n\t\t\t\t((unsigned long) he_dev->rbrq_base |\n\t\t\t\t\tRBRQ_MASK(he_dev->rbrq_head + 1));\n\n\t}\n\tread_unlock(&vcc_sklist_lock);\n\n\tif (updated) {\n\t\tif (updated > he_dev->rbrq_peak)\n\t\t\the_dev->rbrq_peak = updated;\n\n\t\the_writel(he_dev, RBRQ_MASK(he_dev->rbrq_head),\n\t\t\t\t\t\tG0_RBRQ_H + (group * 16));\n\t}\n\n\treturn pdus_assembled;\n}\n\nstatic void\nhe_service_tbrq(struct he_dev *he_dev, int group)\n{\n\tstruct he_tbrq *tbrq_tail = (struct he_tbrq *)\n\t\t\t\t((unsigned long)he_dev->tbrq_base |\n\t\t\t\t\the_dev->hsp->group[group].tbrq_tail);\n\tstruct he_tpd *tpd;\n\tint slot, updated = 0;\n\tstruct he_tpd *__tpd;\n\n\t \n\n\twhile (he_dev->tbrq_head != tbrq_tail) {\n\t\t++updated;\n\n\t\tHPRINTK(\"tbrq%d 0x%x%s%s\\n\",\n\t\t\tgroup,\n\t\t\tTBRQ_TPD(he_dev->tbrq_head), \n\t\t\tTBRQ_EOS(he_dev->tbrq_head) ? \" EOS\" : \"\",\n\t\t\tTBRQ_MULTIPLE(he_dev->tbrq_head) ? \" MULTIPLE\" : \"\");\n\t\ttpd = NULL;\n\t\tlist_for_each_entry(__tpd, &he_dev->outstanding_tpds, entry) {\n\t\t\tif (TPD_ADDR(__tpd->status) == TBRQ_TPD(he_dev->tbrq_head)) {\n\t\t\t\ttpd = __tpd;\n\t\t\t\tlist_del(&__tpd->entry);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (tpd == NULL) {\n\t\t\thprintk(\"unable to locate tpd for dma buffer %x\\n\",\n\t\t\t\t\t\tTBRQ_TPD(he_dev->tbrq_head));\n\t\t\tgoto next_tbrq_entry;\n\t\t}\n\n\t\tif (TBRQ_EOS(he_dev->tbrq_head)) {\n\t\t\tHPRINTK(\"wake_up(tx_waitq) cid 0x%x\\n\",\n\t\t\t\the_mkcid(he_dev, tpd->vcc->vpi, tpd->vcc->vci));\n\t\t\tif (tpd->vcc)\n\t\t\t\twake_up(&HE_VCC(tpd->vcc)->tx_waitq);\n\n\t\t\tgoto next_tbrq_entry;\n\t\t}\n\n\t\tfor (slot = 0; slot < TPD_MAXIOV; ++slot) {\n\t\t\tif (tpd->iovec[slot].addr)\n\t\t\t\tdma_unmap_single(&he_dev->pci_dev->dev,\n\t\t\t\t\ttpd->iovec[slot].addr,\n\t\t\t\t\ttpd->iovec[slot].len & TPD_LEN_MASK,\n\t\t\t\t\t\t\tDMA_TO_DEVICE);\n\t\t\tif (tpd->iovec[slot].len & TPD_LST)\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t}\n\n\t\tif (tpd->skb) {\t \n\t\t\tif (tpd->vcc && tpd->vcc->pop)\n\t\t\t\ttpd->vcc->pop(tpd->vcc, tpd->skb);\n\t\t\telse\n\t\t\t\tdev_kfree_skb_any(tpd->skb);\n\t\t}\n\nnext_tbrq_entry:\n\t\tif (tpd)\n\t\t\tdma_pool_free(he_dev->tpd_pool, tpd, TPD_ADDR(tpd->status));\n\t\the_dev->tbrq_head = (struct he_tbrq *)\n\t\t\t\t((unsigned long) he_dev->tbrq_base |\n\t\t\t\t\tTBRQ_MASK(he_dev->tbrq_head + 1));\n\t}\n\n\tif (updated) {\n\t\tif (updated > he_dev->tbrq_peak)\n\t\t\the_dev->tbrq_peak = updated;\n\n\t\the_writel(he_dev, TBRQ_MASK(he_dev->tbrq_head),\n\t\t\t\t\t\tG0_TBRQ_H + (group * 16));\n\t}\n}\n\nstatic void\nhe_service_rbpl(struct he_dev *he_dev, int group)\n{\n\tstruct he_rbp *new_tail;\n\tstruct he_rbp *rbpl_head;\n\tstruct he_buff *heb;\n\tdma_addr_t mapping;\n\tint i;\n\tint moved = 0;\n\n\trbpl_head = (struct he_rbp *) ((unsigned long)he_dev->rbpl_base |\n\t\t\t\t\tRBPL_MASK(he_readl(he_dev, G0_RBPL_S)));\n\n\tfor (;;) {\n\t\tnew_tail = (struct he_rbp *) ((unsigned long)he_dev->rbpl_base |\n\t\t\t\t\t\tRBPL_MASK(he_dev->rbpl_tail+1));\n\n\t\t \n\t\tif (new_tail == rbpl_head)\n\t\t\tbreak;\n\n\t\ti = find_next_zero_bit(he_dev->rbpl_table, RBPL_TABLE_SIZE, he_dev->rbpl_hint);\n\t\tif (i > (RBPL_TABLE_SIZE - 1)) {\n\t\t\ti = find_first_zero_bit(he_dev->rbpl_table, RBPL_TABLE_SIZE);\n\t\t\tif (i > (RBPL_TABLE_SIZE - 1))\n\t\t\t\tbreak;\n\t\t}\n\t\the_dev->rbpl_hint = i + 1;\n\n\t\theb = dma_pool_alloc(he_dev->rbpl_pool, GFP_ATOMIC, &mapping);\n\t\tif (!heb)\n\t\t\tbreak;\n\t\theb->mapping = mapping;\n\t\tlist_add(&heb->entry, &he_dev->rbpl_outstanding);\n\t\the_dev->rbpl_virt[i] = heb;\n\t\tset_bit(i, he_dev->rbpl_table);\n\t\tnew_tail->idx = i << RBP_IDX_OFFSET;\n\t\tnew_tail->phys = mapping + offsetof(struct he_buff, data);\n\n\t\the_dev->rbpl_tail = new_tail;\n\t\t++moved;\n\t} \n\n\tif (moved)\n\t\the_writel(he_dev, RBPL_MASK(he_dev->rbpl_tail), G0_RBPL_T);\n}\n\nstatic void\nhe_tasklet(unsigned long data)\n{\n\tunsigned long flags;\n\tstruct he_dev *he_dev = (struct he_dev *) data;\n\tint group, type;\n\tint updated = 0;\n\n\tHPRINTK(\"tasklet (0x%lx)\\n\", data);\n\tspin_lock_irqsave(&he_dev->global_lock, flags);\n\n\twhile (he_dev->irq_head != he_dev->irq_tail) {\n\t\t++updated;\n\n\t\ttype = ITYPE_TYPE(he_dev->irq_head->isw);\n\t\tgroup = ITYPE_GROUP(he_dev->irq_head->isw);\n\n\t\tswitch (type) {\n\t\t\tcase ITYPE_RBRQ_THRESH:\n\t\t\t\tHPRINTK(\"rbrq%d threshold\\n\", group);\n\t\t\t\tfallthrough;\n\t\t\tcase ITYPE_RBRQ_TIMER:\n\t\t\t\tif (he_service_rbrq(he_dev, group))\n\t\t\t\t\the_service_rbpl(he_dev, group);\n\t\t\t\tbreak;\n\t\t\tcase ITYPE_TBRQ_THRESH:\n\t\t\t\tHPRINTK(\"tbrq%d threshold\\n\", group);\n\t\t\t\tfallthrough;\n\t\t\tcase ITYPE_TPD_COMPLETE:\n\t\t\t\the_service_tbrq(he_dev, group);\n\t\t\t\tbreak;\n\t\t\tcase ITYPE_RBPL_THRESH:\n\t\t\t\the_service_rbpl(he_dev, group);\n\t\t\t\tbreak;\n\t\t\tcase ITYPE_RBPS_THRESH:\n\t\t\t\t \n\t\t\t\tbreak;\n\t\t\tcase ITYPE_PHY:\n\t\t\t\tHPRINTK(\"phy interrupt\\n\");\n#ifdef CONFIG_ATM_HE_USE_SUNI\n\t\t\t\tspin_unlock_irqrestore(&he_dev->global_lock, flags);\n\t\t\t\tif (he_dev->atm_dev->phy && he_dev->atm_dev->phy->interrupt)\n\t\t\t\t\the_dev->atm_dev->phy->interrupt(he_dev->atm_dev);\n\t\t\t\tspin_lock_irqsave(&he_dev->global_lock, flags);\n#endif\n\t\t\t\tbreak;\n\t\t\tcase ITYPE_OTHER:\n\t\t\t\tswitch (type|group) {\n\t\t\t\t\tcase ITYPE_PARITY:\n\t\t\t\t\t\thprintk(\"parity error\\n\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ITYPE_ABORT:\n\t\t\t\t\t\thprintk(\"abort 0x%x\\n\", he_readl(he_dev, ABORT_ADDR));\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase ITYPE_TYPE(ITYPE_INVALID):\n\t\t\t\t \n\n\t\t\t\tHPRINTK(\"isw not updated 0x%x\\n\", he_dev->irq_head->isw);\n\n\t\t\t\the_service_rbrq(he_dev, 0);\n\t\t\t\the_service_rbpl(he_dev, 0);\n\t\t\t\the_service_tbrq(he_dev, 0);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\thprintk(\"bad isw 0x%x?\\n\", he_dev->irq_head->isw);\n\t\t}\n\n\t\the_dev->irq_head->isw = ITYPE_INVALID;\n\n\t\the_dev->irq_head = (struct he_irq *) NEXT_ENTRY(he_dev->irq_base, he_dev->irq_head, IRQ_MASK);\n\t}\n\n\tif (updated) {\n\t\tif (updated > he_dev->irq_peak)\n\t\t\the_dev->irq_peak = updated;\n\n\t\the_writel(he_dev,\n\t\t\tIRQ_SIZE(CONFIG_IRQ_SIZE) |\n\t\t\tIRQ_THRESH(CONFIG_IRQ_THRESH) |\n\t\t\tIRQ_TAIL(he_dev->irq_tail), IRQ0_HEAD);\n\t\t(void) he_readl(he_dev, INT_FIFO);  \n\t}\n\tspin_unlock_irqrestore(&he_dev->global_lock, flags);\n}\n\nstatic irqreturn_t\nhe_irq_handler(int irq, void *dev_id)\n{\n\tunsigned long flags;\n\tstruct he_dev *he_dev = (struct he_dev * )dev_id;\n\tint handled = 0;\n\n\tif (he_dev == NULL)\n\t\treturn IRQ_NONE;\n\n\tspin_lock_irqsave(&he_dev->global_lock, flags);\n\n\the_dev->irq_tail = (struct he_irq *) (((unsigned long)he_dev->irq_base) |\n\t\t\t\t\t\t(*he_dev->irq_tailoffset << 2));\n\n\tif (he_dev->irq_tail == he_dev->irq_head) {\n\t\tHPRINTK(\"tailoffset not updated?\\n\");\n\t\the_dev->irq_tail = (struct he_irq *) ((unsigned long)he_dev->irq_base |\n\t\t\t((he_readl(he_dev, IRQ0_BASE) & IRQ_MASK) << 2));\n\t\t(void) he_readl(he_dev, INT_FIFO);\t \n\t}\n\n#ifdef DEBUG\n\tif (he_dev->irq_head == he_dev->irq_tail  )\n\t\thprintk(\"spurious (or shared) interrupt?\\n\");\n#endif\n\n\tif (he_dev->irq_head != he_dev->irq_tail) {\n\t\thandled = 1;\n\t\ttasklet_schedule(&he_dev->tasklet);\n\t\the_writel(he_dev, INT_CLEAR_A, INT_FIFO);\t \n\t\t(void) he_readl(he_dev, INT_FIFO);\t\t \n\t}\n\tspin_unlock_irqrestore(&he_dev->global_lock, flags);\n\treturn IRQ_RETVAL(handled);\n\n}\n\nstatic __inline__ void\n__enqueue_tpd(struct he_dev *he_dev, struct he_tpd *tpd, unsigned cid)\n{\n\tstruct he_tpdrq *new_tail;\n\n\tHPRINTK(\"tpdrq %p cid 0x%x -> tpdrq_tail %p\\n\",\n\t\t\t\t\ttpd, cid, he_dev->tpdrq_tail);\n\n\t \n\tnew_tail = (struct he_tpdrq *) ((unsigned long) he_dev->tpdrq_base |\n\t\t\t\t\tTPDRQ_MASK(he_dev->tpdrq_tail+1));\n\n\t \n\n\tif (new_tail == he_dev->tpdrq_head) {\n\t\the_dev->tpdrq_head = (struct he_tpdrq *)\n\t\t\t(((unsigned long)he_dev->tpdrq_base) |\n\t\t\t\tTPDRQ_MASK(he_readl(he_dev, TPDRQ_B_H)));\n\n\t\tif (new_tail == he_dev->tpdrq_head) {\n\t\t\tint slot;\n\n\t\t\thprintk(\"tpdrq full (cid 0x%x)\\n\", cid);\n\t\t\t \n\t\t\tfor (slot = 0; slot < TPD_MAXIOV; ++slot) {\n\t\t\t\tif (tpd->iovec[slot].addr)\n\t\t\t\t\tdma_unmap_single(&he_dev->pci_dev->dev,\n\t\t\t\t\t\ttpd->iovec[slot].addr,\n\t\t\t\t\t\ttpd->iovec[slot].len & TPD_LEN_MASK,\n\t\t\t\t\t\t\t\tDMA_TO_DEVICE);\n\t\t\t}\n\t\t\tif (tpd->skb) {\n\t\t\t\tif (tpd->vcc->pop)\n\t\t\t\t\ttpd->vcc->pop(tpd->vcc, tpd->skb);\n\t\t\t\telse\n\t\t\t\t\tdev_kfree_skb_any(tpd->skb);\n\t\t\t\tatomic_inc(&tpd->vcc->stats->tx_err);\n\t\t\t}\n\t\t\tdma_pool_free(he_dev->tpd_pool, tpd, TPD_ADDR(tpd->status));\n\t\t\treturn;\n\t\t}\n\t}\n\n\t \n\tlist_add_tail(&tpd->entry, &he_dev->outstanding_tpds);\n\the_dev->tpdrq_tail->tpd = TPD_ADDR(tpd->status);\n\the_dev->tpdrq_tail->cid = cid;\n\twmb();\n\n\the_dev->tpdrq_tail = new_tail;\n\n\the_writel(he_dev, TPDRQ_MASK(he_dev->tpdrq_tail), TPDRQ_T);\n\t(void) he_readl(he_dev, TPDRQ_T);\t\t \n}\n\nstatic int\nhe_open(struct atm_vcc *vcc)\n{\n\tunsigned long flags;\n\tstruct he_dev *he_dev = HE_DEV(vcc->dev);\n\tstruct he_vcc *he_vcc;\n\tint err = 0;\n\tunsigned cid, rsr0, rsr1, rsr4, tsr0, tsr0_aal, tsr4, period, reg, clock;\n\tshort vpi = vcc->vpi;\n\tint vci = vcc->vci;\n\n\tif (vci == ATM_VCI_UNSPEC || vpi == ATM_VPI_UNSPEC)\n\t\treturn 0;\n\n\tHPRINTK(\"open vcc %p %d.%d\\n\", vcc, vpi, vci);\n\n\tset_bit(ATM_VF_ADDR, &vcc->flags);\n\n\tcid = he_mkcid(he_dev, vpi, vci);\n\n\the_vcc = kmalloc(sizeof(struct he_vcc), GFP_ATOMIC);\n\tif (he_vcc == NULL) {\n\t\thprintk(\"unable to allocate he_vcc during open\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tINIT_LIST_HEAD(&he_vcc->buffers);\n\the_vcc->pdu_len = 0;\n\the_vcc->rc_index = -1;\n\n\tinit_waitqueue_head(&he_vcc->rx_waitq);\n\tinit_waitqueue_head(&he_vcc->tx_waitq);\n\n\tvcc->dev_data = he_vcc;\n\n\tif (vcc->qos.txtp.traffic_class != ATM_NONE) {\n\t\tint pcr_goal;\n\n\t\tpcr_goal = atm_pcr_goal(&vcc->qos.txtp);\n\t\tif (pcr_goal == 0)\n\t\t\tpcr_goal = he_dev->atm_dev->link_rate;\n\t\tif (pcr_goal < 0)\t \n\t\t\tpcr_goal = -pcr_goal;\n\n\t\tHPRINTK(\"open tx cid 0x%x pcr_goal %d\\n\", cid, pcr_goal);\n\n\t\tswitch (vcc->qos.aal) {\n\t\t\tcase ATM_AAL5:\n\t\t\t\ttsr0_aal = TSR0_AAL5;\n\t\t\t\ttsr4 = TSR4_AAL5;\n\t\t\t\tbreak;\n\t\t\tcase ATM_AAL0:\n\t\t\t\ttsr0_aal = TSR0_AAL0_SDU;\n\t\t\t\ttsr4 = TSR4_AAL0_SDU;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto open_failed;\n\t\t}\n\n\t\tspin_lock_irqsave(&he_dev->global_lock, flags);\n\t\ttsr0 = he_readl_tsr0(he_dev, cid);\n\t\tspin_unlock_irqrestore(&he_dev->global_lock, flags);\n\n\t\tif (TSR0_CONN_STATE(tsr0) != 0) {\n\t\t\thprintk(\"cid 0x%x not idle (tsr0 = 0x%x)\\n\", cid, tsr0);\n\t\t\terr = -EBUSY;\n\t\t\tgoto open_failed;\n\t\t}\n\n\t\tswitch (vcc->qos.txtp.traffic_class) {\n\t\t\tcase ATM_UBR:\n\t\t\t\t \n\n\t\t\t\ttsr0 = TSR0_UBR | TSR0_GROUP(0) | tsr0_aal |\n\t\t\t\t\tTSR0_USE_WMIN | TSR0_UPDATE_GER;\n\t\t\t\tbreak;\n\n\t\t\tcase ATM_CBR:\n\t\t\t\t \n\n\t\t\t\t \n\t\t\t\tif ((he_dev->total_bw + pcr_goal)\n\t\t\t\t\t> (he_dev->atm_dev->link_rate * 9 / 10))\n\t\t\t\t{\n\t\t\t\t\terr = -EBUSY;\n\t\t\t\t\tgoto open_failed;\n\t\t\t\t}\n\n\t\t\t\tspin_lock_irqsave(&he_dev->global_lock, flags);\t\t\t \n\n\t\t\t\t \n\t\t\t\tfor (reg = 0; reg < HE_NUM_CS_STPER; ++reg)\n\t\t\t\t\tif (he_dev->cs_stper[reg].inuse == 0 || \n\t\t\t\t\t    he_dev->cs_stper[reg].pcr == pcr_goal)\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\tif (reg == HE_NUM_CS_STPER) {\n\t\t\t\t\terr = -EBUSY;\n\t\t\t\t\tspin_unlock_irqrestore(&he_dev->global_lock, flags);\n\t\t\t\t\tgoto open_failed;\n\t\t\t\t}\n\n\t\t\t\the_dev->total_bw += pcr_goal;\n\n\t\t\t\the_vcc->rc_index = reg;\n\t\t\t\t++he_dev->cs_stper[reg].inuse;\n\t\t\t\the_dev->cs_stper[reg].pcr = pcr_goal;\n\n\t\t\t\tclock = he_is622(he_dev) ? 66667000 : 50000000;\n\t\t\t\tperiod = clock / pcr_goal;\n\t\t\t\t\n\t\t\t\tHPRINTK(\"rc_index = %d period = %d\\n\",\n\t\t\t\t\t\t\t\treg, period);\n\n\t\t\t\the_writel_mbox(he_dev, rate_to_atmf(period/2),\n\t\t\t\t\t\t\tCS_STPER0 + reg);\n\t\t\t\tspin_unlock_irqrestore(&he_dev->global_lock, flags);\n\n\t\t\t\ttsr0 = TSR0_CBR | TSR0_GROUP(0) | tsr0_aal |\n\t\t\t\t\t\t\tTSR0_RC_INDEX(reg);\n\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto open_failed;\n\t\t}\n\n\t\tspin_lock_irqsave(&he_dev->global_lock, flags);\n\n\t\the_writel_tsr0(he_dev, tsr0, cid);\n\t\the_writel_tsr4(he_dev, tsr4 | 1, cid);\n\t\the_writel_tsr1(he_dev, TSR1_MCR(rate_to_atmf(0)) |\n\t\t\t\t\tTSR1_PCR(rate_to_atmf(pcr_goal)), cid);\n\t\the_writel_tsr2(he_dev, TSR2_ACR(rate_to_atmf(pcr_goal)), cid);\n\t\the_writel_tsr9(he_dev, TSR9_OPEN_CONN, cid);\n\n\t\the_writel_tsr3(he_dev, 0x0, cid);\n\t\the_writel_tsr5(he_dev, 0x0, cid);\n\t\the_writel_tsr6(he_dev, 0x0, cid);\n\t\the_writel_tsr7(he_dev, 0x0, cid);\n\t\the_writel_tsr8(he_dev, 0x0, cid);\n\t\the_writel_tsr10(he_dev, 0x0, cid);\n\t\the_writel_tsr11(he_dev, 0x0, cid);\n\t\the_writel_tsr12(he_dev, 0x0, cid);\n\t\the_writel_tsr13(he_dev, 0x0, cid);\n\t\the_writel_tsr14(he_dev, 0x0, cid);\n\t\t(void) he_readl_tsr0(he_dev, cid);\t\t \n\t\tspin_unlock_irqrestore(&he_dev->global_lock, flags);\n\t}\n\n\tif (vcc->qos.rxtp.traffic_class != ATM_NONE) {\n\t\tunsigned aal;\n\n\t\tHPRINTK(\"open rx cid 0x%x (rx_waitq %p)\\n\", cid,\n\t\t \t\t\t\t&HE_VCC(vcc)->rx_waitq);\n\n\t\tswitch (vcc->qos.aal) {\n\t\t\tcase ATM_AAL5:\n\t\t\t\taal = RSR0_AAL5;\n\t\t\t\tbreak;\n\t\t\tcase ATM_AAL0:\n\t\t\t\taal = RSR0_RAWCELL;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto open_failed;\n\t\t}\n\n\t\tspin_lock_irqsave(&he_dev->global_lock, flags);\n\n\t\trsr0 = he_readl_rsr0(he_dev, cid);\n\t\tif (rsr0 & RSR0_OPEN_CONN) {\n\t\t\tspin_unlock_irqrestore(&he_dev->global_lock, flags);\n\n\t\t\thprintk(\"cid 0x%x not idle (rsr0 = 0x%x)\\n\", cid, rsr0);\n\t\t\terr = -EBUSY;\n\t\t\tgoto open_failed;\n\t\t}\n\n\t\trsr1 = RSR1_GROUP(0) | RSR1_RBPL_ONLY;\n\t\trsr4 = RSR4_GROUP(0) | RSR4_RBPL_ONLY;\n\t\trsr0 = vcc->qos.rxtp.traffic_class == ATM_UBR ? \n\t\t\t\t(RSR0_EPD_ENABLE|RSR0_PPD_ENABLE) : 0;\n\n#ifdef USE_CHECKSUM_HW\n\t\tif (vpi == 0 && vci >= ATM_NOT_RSV_VCI)\n\t\t\trsr0 |= RSR0_TCP_CKSUM;\n#endif\n\n\t\the_writel_rsr4(he_dev, rsr4, cid);\n\t\the_writel_rsr1(he_dev, rsr1, cid);\n\t\t \n\t\the_writel_rsr0(he_dev,\n\t\t\trsr0 | RSR0_START_PDU | RSR0_OPEN_CONN | aal, cid);\n\t\t(void) he_readl_rsr0(he_dev, cid);\t\t \n\n\t\tspin_unlock_irqrestore(&he_dev->global_lock, flags);\n\t}\n\nopen_failed:\n\n\tif (err) {\n\t\tkfree(he_vcc);\n\t\tclear_bit(ATM_VF_ADDR, &vcc->flags);\n\t}\n\telse\n\t\tset_bit(ATM_VF_READY, &vcc->flags);\n\n\treturn err;\n}\n\nstatic void\nhe_close(struct atm_vcc *vcc)\n{\n\tunsigned long flags;\n\tDECLARE_WAITQUEUE(wait, current);\n\tstruct he_dev *he_dev = HE_DEV(vcc->dev);\n\tstruct he_tpd *tpd;\n\tunsigned cid;\n\tstruct he_vcc *he_vcc = HE_VCC(vcc);\n#define MAX_RETRY 30\n\tint retry = 0, sleep = 1, tx_inuse;\n\n\tHPRINTK(\"close vcc %p %d.%d\\n\", vcc, vcc->vpi, vcc->vci);\n\n\tclear_bit(ATM_VF_READY, &vcc->flags);\n\tcid = he_mkcid(he_dev, vcc->vpi, vcc->vci);\n\n\tif (vcc->qos.rxtp.traffic_class != ATM_NONE) {\n\t\tint timeout;\n\n\t\tHPRINTK(\"close rx cid 0x%x\\n\", cid);\n\n\t\t \n\n\t\t \n\n\t\tspin_lock_irqsave(&he_dev->global_lock, flags);\n\t\twhile (he_readl(he_dev, RCC_STAT) & RCC_BUSY) {\n\t\t\tHPRINTK(\"close cid 0x%x RCC_BUSY\\n\", cid);\n\t\t\tudelay(250);\n\t\t}\n\n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\tadd_wait_queue(&he_vcc->rx_waitq, &wait);\n\n\t\the_writel_rsr0(he_dev, RSR0_CLOSE_CONN, cid);\n\t\t(void) he_readl_rsr0(he_dev, cid);\t\t \n\t\the_writel_mbox(he_dev, cid, RXCON_CLOSE);\n\t\tspin_unlock_irqrestore(&he_dev->global_lock, flags);\n\n\t\ttimeout = schedule_timeout(30*HZ);\n\n\t\tremove_wait_queue(&he_vcc->rx_waitq, &wait);\n\t\tset_current_state(TASK_RUNNING);\n\n\t\tif (timeout == 0)\n\t\t\thprintk(\"close rx timeout cid 0x%x\\n\", cid);\n\n\t\tHPRINTK(\"close rx cid 0x%x complete\\n\", cid);\n\n\t}\n\n\tif (vcc->qos.txtp.traffic_class != ATM_NONE) {\n\t\tvolatile unsigned tsr4, tsr0;\n\t\tint timeout;\n\n\t\tHPRINTK(\"close tx cid 0x%x\\n\", cid);\n\t\t\n\t\t \n\n\t\twhile (((tx_inuse = refcount_read(&sk_atm(vcc)->sk_wmem_alloc)) > 1) &&\n\t\t       (retry < MAX_RETRY)) {\n\t\t\tmsleep(sleep);\n\t\t\tif (sleep < 250)\n\t\t\t\tsleep = sleep * 2;\n\n\t\t\t++retry;\n\t\t}\n\n\t\tif (tx_inuse > 1)\n\t\t\thprintk(\"close tx cid 0x%x tx_inuse = %d\\n\", cid, tx_inuse);\n\n\t\t \n\n\t\tspin_lock_irqsave(&he_dev->global_lock, flags);\n\t\the_writel_tsr4_upper(he_dev, TSR4_FLUSH_CONN, cid);\n\t\t\t\t\t \n\n\t\tswitch (vcc->qos.txtp.traffic_class) {\n\t\t\tcase ATM_UBR:\n\t\t\t\the_writel_tsr1(he_dev, \n\t\t\t\t\tTSR1_MCR(rate_to_atmf(200000))\n\t\t\t\t\t| TSR1_PCR(0), cid);\n\t\t\t\tbreak;\n\t\t\tcase ATM_CBR:\n\t\t\t\the_writel_tsr14_upper(he_dev, TSR14_DELETE, cid);\n\t\t\t\tbreak;\n\t\t}\n\t\t(void) he_readl_tsr4(he_dev, cid);\t\t \n\n\t\ttpd = __alloc_tpd(he_dev);\n\t\tif (tpd == NULL) {\n\t\t\thprintk(\"close tx he_alloc_tpd failed cid 0x%x\\n\", cid);\n\t\t\tgoto close_tx_incomplete;\n\t\t}\n\t\ttpd->status |= TPD_EOS | TPD_INT;\n\t\ttpd->skb = NULL;\n\t\ttpd->vcc = vcc;\n\t\twmb();\n\n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\tadd_wait_queue(&he_vcc->tx_waitq, &wait);\n\t\t__enqueue_tpd(he_dev, tpd, cid);\n\t\tspin_unlock_irqrestore(&he_dev->global_lock, flags);\n\n\t\ttimeout = schedule_timeout(30*HZ);\n\n\t\tremove_wait_queue(&he_vcc->tx_waitq, &wait);\n\t\tset_current_state(TASK_RUNNING);\n\n\t\tspin_lock_irqsave(&he_dev->global_lock, flags);\n\n\t\tif (timeout == 0) {\n\t\t\thprintk(\"close tx timeout cid 0x%x\\n\", cid);\n\t\t\tgoto close_tx_incomplete;\n\t\t}\n\n\t\twhile (!((tsr4 = he_readl_tsr4(he_dev, cid)) & TSR4_SESSION_ENDED)) {\n\t\t\tHPRINTK(\"close tx cid 0x%x !TSR4_SESSION_ENDED (tsr4 = 0x%x)\\n\", cid, tsr4);\n\t\t\tudelay(250);\n\t\t}\n\n\t\twhile (TSR0_CONN_STATE(tsr0 = he_readl_tsr0(he_dev, cid)) != 0) {\n\t\t\tHPRINTK(\"close tx cid 0x%x TSR0_CONN_STATE != 0 (tsr0 = 0x%x)\\n\", cid, tsr0);\n\t\t\tudelay(250);\n\t\t}\n\nclose_tx_incomplete:\n\n\t\tif (vcc->qos.txtp.traffic_class == ATM_CBR) {\n\t\t\tint reg = he_vcc->rc_index;\n\n\t\t\tHPRINTK(\"cs_stper reg = %d\\n\", reg);\n\n\t\t\tif (he_dev->cs_stper[reg].inuse == 0)\n\t\t\t\thprintk(\"cs_stper[%d].inuse = 0!\\n\", reg);\n\t\t\telse\n\t\t\t\t--he_dev->cs_stper[reg].inuse;\n\n\t\t\the_dev->total_bw -= he_dev->cs_stper[reg].pcr;\n\t\t}\n\t\tspin_unlock_irqrestore(&he_dev->global_lock, flags);\n\n\t\tHPRINTK(\"close tx cid 0x%x complete\\n\", cid);\n\t}\n\n\tkfree(he_vcc);\n\n\tclear_bit(ATM_VF_ADDR, &vcc->flags);\n}\n\nstatic int\nhe_send(struct atm_vcc *vcc, struct sk_buff *skb)\n{\n\tunsigned long flags;\n\tstruct he_dev *he_dev = HE_DEV(vcc->dev);\n\tunsigned cid = he_mkcid(he_dev, vcc->vpi, vcc->vci);\n\tstruct he_tpd *tpd;\n#ifdef USE_SCATTERGATHER\n\tint i, slot = 0;\n#endif\n\n#define HE_TPD_BUFSIZE 0xffff\n\n\tHPRINTK(\"send %d.%d\\n\", vcc->vpi, vcc->vci);\n\n\tif ((skb->len > HE_TPD_BUFSIZE) ||\n\t    ((vcc->qos.aal == ATM_AAL0) && (skb->len != ATM_AAL0_SDU))) {\n\t\thprintk(\"buffer too large (or small) -- %d bytes\\n\", skb->len );\n\t\tif (vcc->pop)\n\t\t\tvcc->pop(vcc, skb);\n\t\telse\n\t\t\tdev_kfree_skb_any(skb);\n\t\tatomic_inc(&vcc->stats->tx_err);\n\t\treturn -EINVAL;\n\t}\n\n#ifndef USE_SCATTERGATHER\n\tif (skb_shinfo(skb)->nr_frags) {\n\t\thprintk(\"no scatter/gather support\\n\");\n\t\tif (vcc->pop)\n\t\t\tvcc->pop(vcc, skb);\n\t\telse\n\t\t\tdev_kfree_skb_any(skb);\n\t\tatomic_inc(&vcc->stats->tx_err);\n\t\treturn -EINVAL;\n\t}\n#endif\n\tspin_lock_irqsave(&he_dev->global_lock, flags);\n\n\ttpd = __alloc_tpd(he_dev);\n\tif (tpd == NULL) {\n\t\tif (vcc->pop)\n\t\t\tvcc->pop(vcc, skb);\n\t\telse\n\t\t\tdev_kfree_skb_any(skb);\n\t\tatomic_inc(&vcc->stats->tx_err);\n\t\tspin_unlock_irqrestore(&he_dev->global_lock, flags);\n\t\treturn -ENOMEM;\n\t}\n\n\tif (vcc->qos.aal == ATM_AAL5)\n\t\ttpd->status |= TPD_CELLTYPE(TPD_USERCELL);\n\telse {\n\t\tchar *pti_clp = (void *) (skb->data + 3);\n\t\tint clp, pti;\n\n\t\tpti = (*pti_clp & ATM_HDR_PTI_MASK) >> ATM_HDR_PTI_SHIFT; \n\t\tclp = (*pti_clp & ATM_HDR_CLP);\n\t\ttpd->status |= TPD_CELLTYPE(pti);\n\t\tif (clp)\n\t\t\ttpd->status |= TPD_CLP;\n\n\t\tskb_pull(skb, ATM_AAL0_SDU - ATM_CELL_PAYLOAD);\n\t}\n\n#ifdef USE_SCATTERGATHER\n\ttpd->iovec[slot].addr = dma_map_single(&he_dev->pci_dev->dev, skb->data,\n\t\t\t\tskb_headlen(skb), DMA_TO_DEVICE);\n\ttpd->iovec[slot].len = skb_headlen(skb);\n\t++slot;\n\n\tfor (i = 0; i < skb_shinfo(skb)->nr_frags; i++) {\n\t\tskb_frag_t *frag = &skb_shinfo(skb)->frags[i];\n\n\t\tif (slot == TPD_MAXIOV) {\t \n\t\t\ttpd->vcc = vcc;\n\t\t\ttpd->skb = NULL;\t \n\t\t\twmb();\n\n\t\t\t__enqueue_tpd(he_dev, tpd, cid);\n\t\t\ttpd = __alloc_tpd(he_dev);\n\t\t\tif (tpd == NULL) {\n\t\t\t\tif (vcc->pop)\n\t\t\t\t\tvcc->pop(vcc, skb);\n\t\t\t\telse\n\t\t\t\t\tdev_kfree_skb_any(skb);\n\t\t\t\tatomic_inc(&vcc->stats->tx_err);\n\t\t\t\tspin_unlock_irqrestore(&he_dev->global_lock, flags);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t\ttpd->status |= TPD_USERCELL;\n\t\t\tslot = 0;\n\t\t}\n\n\t\ttpd->iovec[slot].addr = skb_frag_dma_map(&he_dev->pci_dev->dev,\n\t\t\t\tfrag, 0, skb_frag_size(frag), DMA_TO_DEVICE);\n\t\ttpd->iovec[slot].len = skb_frag_size(frag);\n\t\t++slot;\n\n\t}\n\n\ttpd->iovec[slot - 1].len |= TPD_LST;\n#else\n\ttpd->address0 = dma_map_single(&he_dev->pci_dev->dev, skb->data, skb->len, DMA_TO_DEVICE);\n\ttpd->length0 = skb->len | TPD_LST;\n#endif\n\ttpd->status |= TPD_INT;\n\n\ttpd->vcc = vcc;\n\ttpd->skb = skb;\n\twmb();\n\tATM_SKB(skb)->vcc = vcc;\n\n\t__enqueue_tpd(he_dev, tpd, cid);\n\tspin_unlock_irqrestore(&he_dev->global_lock, flags);\n\n\tatomic_inc(&vcc->stats->tx);\n\n\treturn 0;\n}\n\nstatic int\nhe_ioctl(struct atm_dev *atm_dev, unsigned int cmd, void __user *arg)\n{\n\tunsigned long flags;\n\tstruct he_dev *he_dev = HE_DEV(atm_dev);\n\tstruct he_ioctl_reg reg;\n\tint err = 0;\n\n\tswitch (cmd) {\n\t\tcase HE_GET_REG:\n\t\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\t\treturn -EPERM;\n\n\t\t\tif (copy_from_user(&reg, arg,\n\t\t\t\t\t   sizeof(struct he_ioctl_reg)))\n\t\t\t\treturn -EFAULT;\n\n\t\t\tspin_lock_irqsave(&he_dev->global_lock, flags);\n\t\t\tswitch (reg.type) {\n\t\t\t\tcase HE_REGTYPE_PCI:\n\t\t\t\t\tif (reg.addr >= HE_REGMAP_SIZE) {\n\t\t\t\t\t\terr = -EINVAL;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\treg.val = he_readl(he_dev, reg.addr);\n\t\t\t\t\tbreak;\n\t\t\t\tcase HE_REGTYPE_RCM:\n\t\t\t\t\treg.val =\n\t\t\t\t\t\the_readl_rcm(he_dev, reg.addr);\n\t\t\t\t\tbreak;\n\t\t\t\tcase HE_REGTYPE_TCM:\n\t\t\t\t\treg.val =\n\t\t\t\t\t\the_readl_tcm(he_dev, reg.addr);\n\t\t\t\t\tbreak;\n\t\t\t\tcase HE_REGTYPE_MBOX:\n\t\t\t\t\treg.val =\n\t\t\t\t\t\the_readl_mbox(he_dev, reg.addr);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\terr = -EINVAL;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tspin_unlock_irqrestore(&he_dev->global_lock, flags);\n\t\t\tif (err == 0)\n\t\t\t\tif (copy_to_user(arg, &reg,\n\t\t\t\t\t\t\tsizeof(struct he_ioctl_reg)))\n\t\t\t\t\treturn -EFAULT;\n\t\t\tbreak;\n\t\tdefault:\n#ifdef CONFIG_ATM_HE_USE_SUNI\n\t\t\tif (atm_dev->phy && atm_dev->phy->ioctl)\n\t\t\t\terr = atm_dev->phy->ioctl(atm_dev, cmd, arg);\n#else  \n\t\t\terr = -EINVAL;\n#endif  \n\t\t\tbreak;\n\t}\n\n\treturn err;\n}\n\nstatic void\nhe_phy_put(struct atm_dev *atm_dev, unsigned char val, unsigned long addr)\n{\n\tunsigned long flags;\n\tstruct he_dev *he_dev = HE_DEV(atm_dev);\n\n\tHPRINTK(\"phy_put(val 0x%x, addr 0x%lx)\\n\", val, addr);\n\n\tspin_lock_irqsave(&he_dev->global_lock, flags);\n\the_writel(he_dev, val, FRAMER + (addr*4));\n\t(void) he_readl(he_dev, FRAMER + (addr*4));\t\t \n\tspin_unlock_irqrestore(&he_dev->global_lock, flags);\n}\n \n\t\nstatic unsigned char\nhe_phy_get(struct atm_dev *atm_dev, unsigned long addr)\n{ \n\tunsigned long flags;\n\tstruct he_dev *he_dev = HE_DEV(atm_dev);\n\tunsigned reg;\n\n\tspin_lock_irqsave(&he_dev->global_lock, flags);\n\treg = he_readl(he_dev, FRAMER + (addr*4));\n\tspin_unlock_irqrestore(&he_dev->global_lock, flags);\n\n\tHPRINTK(\"phy_get(addr 0x%lx) =0x%x\\n\", addr, reg);\n\treturn reg;\n}\n\nstatic int\nhe_proc_read(struct atm_dev *dev, loff_t *pos, char *page)\n{\n\tunsigned long flags;\n\tstruct he_dev *he_dev = HE_DEV(dev);\n\tint left, i;\n#ifdef notdef\n\tstruct he_rbrq *rbrq_tail;\n\tstruct he_tpdrq *tpdrq_head;\n\tint rbpl_head, rbpl_tail;\n#endif\n\tstatic long mcc = 0, oec = 0, dcc = 0, cec = 0;\n\n\n\tleft = *pos;\n\tif (!left--)\n\t\treturn sprintf(page, \"ATM he driver\\n\");\n\n\tif (!left--)\n\t\treturn sprintf(page, \"%s%s\\n\\n\",\n\t\t\the_dev->prod_id, he_dev->media & 0x40 ? \"SM\" : \"MM\");\n\n\tif (!left--)\n\t\treturn sprintf(page, \"Mismatched Cells  VPI/VCI Not Open  Dropped Cells  RCM Dropped Cells\\n\");\n\n\tspin_lock_irqsave(&he_dev->global_lock, flags);\n\tmcc += he_readl(he_dev, MCC);\n\toec += he_readl(he_dev, OEC);\n\tdcc += he_readl(he_dev, DCC);\n\tcec += he_readl(he_dev, CEC);\n\tspin_unlock_irqrestore(&he_dev->global_lock, flags);\n\n\tif (!left--)\n\t\treturn sprintf(page, \"%16ld  %16ld  %13ld  %17ld\\n\\n\", \n\t\t\t\t\t\t\tmcc, oec, dcc, cec);\n\n\tif (!left--)\n\t\treturn sprintf(page, \"irq_size = %d  inuse = ?  peak = %d\\n\",\n\t\t\t\tCONFIG_IRQ_SIZE, he_dev->irq_peak);\n\n\tif (!left--)\n\t\treturn sprintf(page, \"tpdrq_size = %d  inuse = ?\\n\",\n\t\t\t\t\t\tCONFIG_TPDRQ_SIZE);\n\n\tif (!left--)\n\t\treturn sprintf(page, \"rbrq_size = %d  inuse = ?  peak = %d\\n\",\n\t\t\t\tCONFIG_RBRQ_SIZE, he_dev->rbrq_peak);\n\n\tif (!left--)\n\t\treturn sprintf(page, \"tbrq_size = %d  peak = %d\\n\",\n\t\t\t\t\tCONFIG_TBRQ_SIZE, he_dev->tbrq_peak);\n\n\n#ifdef notdef\n\trbpl_head = RBPL_MASK(he_readl(he_dev, G0_RBPL_S));\n\trbpl_tail = RBPL_MASK(he_readl(he_dev, G0_RBPL_T));\n\n\tinuse = rbpl_head - rbpl_tail;\n\tif (inuse < 0)\n\t\tinuse += CONFIG_RBPL_SIZE * sizeof(struct he_rbp);\n\tinuse /= sizeof(struct he_rbp);\n\n\tif (!left--)\n\t\treturn sprintf(page, \"rbpl_size = %d  inuse = %d\\n\\n\",\n\t\t\t\t\t\tCONFIG_RBPL_SIZE, inuse);\n#endif\n\n\tif (!left--)\n\t\treturn sprintf(page, \"rate controller periods (cbr)\\n                 pcr  #vc\\n\");\n\n\tfor (i = 0; i < HE_NUM_CS_STPER; ++i)\n\t\tif (!left--)\n\t\t\treturn sprintf(page, \"cs_stper%-2d  %8ld  %3d\\n\", i,\n\t\t\t\t\t\the_dev->cs_stper[i].pcr,\n\t\t\t\t\t\the_dev->cs_stper[i].inuse);\n\n\tif (!left--)\n\t\treturn sprintf(page, \"total bw (cbr): %d  (limit %d)\\n\",\n\t\t\the_dev->total_bw, he_dev->atm_dev->link_rate * 10 / 9);\n\n\treturn 0;\n}\n\n \n\nstatic u8 read_prom_byte(struct he_dev *he_dev, int addr)\n{\n\tu32 val = 0, tmp_read = 0;\n\tint i, j = 0;\n\tu8 byte_read = 0;\n\n\tval = readl(he_dev->membase + HOST_CNTL);\n\tval &= 0xFFFFE0FF;\n       \n\t \n\tval |= 0x800;\n\the_writel(he_dev, val, HOST_CNTL);\n       \n\t \n\tfor (i = 0; i < ARRAY_SIZE(readtab); i++) {\n\t\the_writel(he_dev, val | readtab[i], HOST_CNTL);\n\t\tudelay(EEPROM_DELAY);\n\t}\n       \n\t \n\tfor (i = 7; i >= 0; i--) {\n\t\the_writel(he_dev, val | clocktab[j++] | (((addr >> i) & 1) << 9), HOST_CNTL);\n\t\tudelay(EEPROM_DELAY);\n\t\the_writel(he_dev, val | clocktab[j++] | (((addr >> i) & 1) << 9), HOST_CNTL);\n\t\tudelay(EEPROM_DELAY);\n\t}\n       \n\tj = 0;\n\n\tval &= 0xFFFFF7FF;       \n\the_writel(he_dev, val, HOST_CNTL);\n       \n\t \n\tfor (i = 7; i >= 0; i--) {\n\t\the_writel(he_dev, val | clocktab[j++], HOST_CNTL);\n\t\tudelay(EEPROM_DELAY);\n\t\ttmp_read = he_readl(he_dev, HOST_CNTL);\n\t\tbyte_read |= (unsigned char)\n\t\t\t   ((tmp_read & ID_DOUT) >> ID_DOFFSET << i);\n\t\the_writel(he_dev, val | clocktab[j++], HOST_CNTL);\n\t\tudelay(EEPROM_DELAY);\n\t}\n       \n\the_writel(he_dev, val | ID_CS, HOST_CNTL);\n\tudelay(EEPROM_DELAY);\n\n\treturn byte_read;\n}\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"chas williams <chas@cmf.nrl.navy.mil>\");\nMODULE_DESCRIPTION(\"ForeRunnerHE ATM Adapter driver\");\nmodule_param(disable64, bool, 0);\nMODULE_PARM_DESC(disable64, \"disable 64-bit pci bus transfers\");\nmodule_param(nvpibits, short, 0);\nMODULE_PARM_DESC(nvpibits, \"numbers of bits for vpi (default 0)\");\nmodule_param(nvcibits, short, 0);\nMODULE_PARM_DESC(nvcibits, \"numbers of bits for vci (default 12)\");\nmodule_param(rx_skb_reserve, short, 0);\nMODULE_PARM_DESC(rx_skb_reserve, \"padding for receive skb (default 16)\");\nmodule_param(irq_coalesce, bool, 0);\nMODULE_PARM_DESC(irq_coalesce, \"use interrupt coalescing (default 1)\");\nmodule_param(sdh, bool, 0);\nMODULE_PARM_DESC(sdh, \"use SDH framing (default 0)\");\n\nstatic const struct pci_device_id he_pci_tbl[] = {\n\t{ PCI_VDEVICE(FORE, PCI_DEVICE_ID_FORE_HE), 0 },\n\t{ 0, }\n};\n\nMODULE_DEVICE_TABLE(pci, he_pci_tbl);\n\nstatic struct pci_driver he_driver = {\n\t.name =\t\t\"he\",\n\t.probe =\the_init_one,\n\t.remove =\the_remove_one,\n\t.id_table =\the_pci_tbl,\n};\n\nmodule_pci_driver(he_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}