{
  "module_name": "eni.c",
  "hash_id": "06797732deeb56797745e814c5bd57dd8b86fd972d8009ec1aa2695aa40b8146",
  "original_prompt": "Ingested from linux-6.6.14/drivers/atm/eni.c",
  "human_readable_source": "\n \n \n \n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/mm.h>\n#include <linux/pci.h>\n#include <linux/errno.h>\n#include <linux/atm.h>\n#include <linux/atmdev.h>\n#include <linux/sonet.h>\n#include <linux/skbuff.h>\n#include <linux/time.h>\n#include <linux/delay.h>\n#include <linux/uio.h>\n#include <linux/init.h>\n#include <linux/atm_eni.h>\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <asm/io.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <asm/string.h>\n#include <asm/byteorder.h>\n\n#include \"tonga.h\"\n#include \"midway.h\"\n#include \"suni.h\"\n#include \"eni.h\"\n\n \n\n \n\n\n#if 0\n#define DPRINTK(format,args...) printk(KERN_DEBUG format,##args)\n#else\n#define DPRINTK(format,args...)\n#endif\n\n\n#ifndef CONFIG_ATM_ENI_TUNE_BURST\n#define CONFIG_ATM_ENI_BURST_TX_8W\n#define CONFIG_ATM_ENI_BURST_RX_4W\n#endif\n\n\n#ifndef CONFIG_ATM_ENI_DEBUG\n\n\n#define NULLCHECK(x)\n\n#define EVENT(s,a,b)\n\n\nstatic void event_dump(void)\n{\n}\n\n\n#else\n\n\n \n\n#define NULLCHECK(x) \\\n\tif ((unsigned long) (x) < 0x30) \\\n\t\tprintk(KERN_CRIT #x \"==0x%lx\\n\",(unsigned long) (x))\n\n \n\n#define EV 64\n\nstatic const char *ev[EV];\nstatic unsigned long ev_a[EV],ev_b[EV];\nstatic int ec = 0;\n\n\nstatic void EVENT(const char *s,unsigned long a,unsigned long b)\n{\n\tev[ec] = s; \n\tev_a[ec] = a;\n\tev_b[ec] = b;\n\tec = (ec+1) % EV;\n}\n\n\nstatic void event_dump(void)\n{\n\tint n,i;\n\n\tfor (n = 0; n < EV; n++) {\n\t\ti = (ec+n) % EV;\n\t\tprintk(KERN_NOTICE);\n\t\tprintk(ev[i] ? ev[i] : \"(null)\",ev_a[i],ev_b[i]);\n\t}\n}\n\n\n#endif  \n\n\n \n\n#define NEPJOK(a0,a1,b) \\\n    ((a0) < (a1) ? (b) <= (a0) || (b) > (a1) : (b) <= (a0) && (b) > (a1))\n#define EEPJOK(a0,a1,b) \\\n    ((a0) < (a1) ? (b) < (a0) || (b) >= (a1) : (b) < (a0) && (b) >= (a1))\n#define NEPMOK(a0,d,b,c) NEPJOK(a0,(a0+d) & (c-1),b)\n#define EEPMOK(a0,d,b,c) EEPJOK(a0,(a0+d) & (c-1),b)\n\n\nstatic int tx_complete = 0,dma_complete = 0,queued = 0,requeued = 0,\n  backlogged = 0,rx_enqueued = 0,rx_dequeued = 0,pushed = 0,submitted = 0,\n  putting = 0;\n\nstatic struct atm_dev *eni_boards = NULL;\n\n \n#define eni_in(r)\treadl(eni_dev->reg+(r)*4)\n#define eni_out(v,r)\twritel((v),eni_dev->reg+(r)*4)\n\n\n \n\n\nstatic void dump_mem(struct eni_dev *eni_dev)\n{\n\tint i;\n\n\tfor (i = 0; i < eni_dev->free_len; i++)\n\t\tprintk(KERN_DEBUG \"  %d: %p %d\\n\",i,\n\t\t    eni_dev->free_list[i].start,\n\t\t    1 << eni_dev->free_list[i].order);\n}\n\n\nstatic void dump(struct atm_dev *dev)\n{\n\tstruct eni_dev *eni_dev;\n\n\tint i;\n\n\teni_dev = ENI_DEV(dev);\n\tprintk(KERN_NOTICE \"Free memory\\n\");\n\tdump_mem(eni_dev);\n\tprintk(KERN_NOTICE \"TX buffers\\n\");\n\tfor (i = 0; i < NR_CHAN; i++)\n\t\tif (eni_dev->tx[i].send)\n\t\t\tprintk(KERN_NOTICE \"  TX %d @ %p: %ld\\n\",i,\n\t\t\t    eni_dev->tx[i].send,eni_dev->tx[i].words*4);\n\tprintk(KERN_NOTICE \"RX buffers\\n\");\n\tfor (i = 0; i < 1024; i++)\n\t\tif (eni_dev->rx_map[i] && ENI_VCC(eni_dev->rx_map[i])->rx)\n\t\t\tprintk(KERN_NOTICE \"  RX %d @ %p: %ld\\n\",i,\n\t\t\t    ENI_VCC(eni_dev->rx_map[i])->recv,\n\t\t\t    ENI_VCC(eni_dev->rx_map[i])->words*4);\n\tprintk(KERN_NOTICE \"----\\n\");\n}\n\n\nstatic void eni_put_free(struct eni_dev *eni_dev, void __iomem *start,\n    unsigned long size)\n{\n\tstruct eni_free *list;\n\tint len,order;\n\n\tDPRINTK(\"init 0x%lx+%ld(0x%lx)\\n\",start,size,size);\n\tstart += eni_dev->base_diff;\n\tlist = eni_dev->free_list;\n\tlen = eni_dev->free_len;\n\twhile (size) {\n\t\tif (len >= eni_dev->free_list_size) {\n\t\t\tprintk(KERN_CRIT \"eni_put_free overflow (%p,%ld)\\n\",\n\t\t\t    start,size);\n\t\t\tbreak;\n\t\t}\n\t\tfor (order = 0; !(((unsigned long)start | size) & (1 << order)); order++);\n\t\tif (MID_MIN_BUF_SIZE > (1 << order)) {\n\t\t\tprintk(KERN_CRIT \"eni_put_free: order %d too small\\n\",\n\t\t\t    order);\n\t\t\tbreak;\n\t\t}\n\t\tlist[len].start = (void __iomem *) start;\n\t\tlist[len].order = order;\n\t\tlen++;\n\t\tstart += 1 << order;\n\t\tsize -= 1 << order;\n\t}\n\teni_dev->free_len = len;\n\t \n}\n\n\nstatic void __iomem *eni_alloc_mem(struct eni_dev *eni_dev, unsigned long *size)\n{\n\tstruct eni_free *list;\n\tvoid __iomem *start;\n\tint len,i,order,best_order,index;\n\n\tlist = eni_dev->free_list;\n\tlen = eni_dev->free_len;\n\tif (*size < MID_MIN_BUF_SIZE) *size = MID_MIN_BUF_SIZE;\n\tif (*size > MID_MAX_BUF_SIZE) return NULL;\n\tfor (order = 0; (1 << order) < *size; order++)\n\t\t;\n\tDPRINTK(\"trying: %ld->%d\\n\",*size,order);\n\tbest_order = 65;  \n\tindex = 0;  \n\tfor (i = 0; i < len; i++)\n\t\tif (list[i].order == order) {\n\t\t\tbest_order = order;\n\t\t\tindex = i;\n\t\t\tbreak;\n\t\t}\n\t\telse if (best_order > list[i].order && list[i].order > order) {\n\t\t\t\tbest_order = list[i].order;\n\t\t\t\tindex = i;\n\t\t\t}\n\tif (best_order == 65) return NULL;\n\tstart = list[index].start-eni_dev->base_diff;\n\tlist[index] = list[--len];\n\teni_dev->free_len = len;\n\t*size = 1 << order;\n\teni_put_free(eni_dev,start+*size,(1 << best_order)-*size);\n\tDPRINTK(\"%ld bytes (order %d) at 0x%lx\\n\",*size,order,start);\n\tmemset_io(start,0,*size);        \n\t \n\treturn start;\n}\n\n\nstatic void eni_free_mem(struct eni_dev *eni_dev, void __iomem *start,\n    unsigned long size)\n{\n\tstruct eni_free *list;\n\tint len,i,order;\n\n\tstart += eni_dev->base_diff;\n\tlist = eni_dev->free_list;\n\tlen = eni_dev->free_len;\n\tfor (order = -1; size; order++) size >>= 1;\n\tDPRINTK(\"eni_free_mem: %p+0x%lx (order %d)\\n\",start,size,order);\n\tfor (i = 0; i < len; i++)\n\t\tif (((unsigned long) list[i].start) == ((unsigned long)start^(1 << order)) &&\n\t\t    list[i].order == order) {\n\t\t\tDPRINTK(\"match[%d]: 0x%lx/0x%lx(0x%x), %d/%d\\n\",i,\n\t\t\t    list[i].start,start,1 << order,list[i].order,order);\n\t\t\tlist[i] = list[--len];\n\t\t\tstart = (void __iomem *) ((unsigned long) start & ~(unsigned long) (1 << order));\n\t\t\torder++;\n\t\t\ti = -1;\n\t\t\tcontinue;\n\t\t}\n\tif (len >= eni_dev->free_list_size) {\n\t\tprintk(KERN_ALERT \"eni_free_mem overflow (%p,%d)\\n\",start,\n\t\t    order);\n\t\treturn;\n\t}\n\tlist[len].start = start;\n\tlist[len].order = order;\n\teni_dev->free_len = len+1;\n\t \n}\n\n\n \n\n\n#define ENI_VCC_NOS ((struct atm_vcc *) 1)\n\n\nstatic void rx_ident_err(struct atm_vcc *vcc)\n{\n\tstruct atm_dev *dev;\n\tstruct eni_dev *eni_dev;\n\tstruct eni_vcc *eni_vcc;\n\n\tdev = vcc->dev;\n\teni_dev = ENI_DEV(dev);\n\t \n\teni_out(eni_in(MID_MC_S) &\n\t    ~(MID_DMA_ENABLE | MID_TX_ENABLE | MID_RX_ENABLE),MID_MC_S);\n\t \n\teni_vcc = ENI_VCC(vcc);\n\tprintk(KERN_ALERT DEV_LABEL \"(itf %d): driver error - RX ident \"\n\t    \"mismatch\\n\",dev->number);\n\tprintk(KERN_ALERT \"  VCI %d, rxing %d, words %ld\\n\",vcc->vci,\n\t    eni_vcc->rxing,eni_vcc->words);\n\tprintk(KERN_ALERT \"  host descr 0x%lx, rx pos 0x%lx, descr value \"\n\t    \"0x%x\\n\",eni_vcc->descr,eni_vcc->rx_pos,\n\t    (unsigned) readl(eni_vcc->recv+eni_vcc->descr*4));\n\tprintk(KERN_ALERT \"  last %p, servicing %d\\n\",eni_vcc->last,\n\t    eni_vcc->servicing);\n\tEVENT(\"---dump ends here---\\n\",0,0);\n\tprintk(KERN_NOTICE \"---recent events---\\n\");\n\tevent_dump();\n\tENI_DEV(dev)->fast = NULL;  \n\tENI_DEV(dev)->slow = NULL;\n\tskb_queue_head_init(&ENI_DEV(dev)->rx_queue);\n}\n\n\nstatic int do_rx_dma(struct atm_vcc *vcc,struct sk_buff *skb,\n    unsigned long skip,unsigned long size,unsigned long eff)\n{\n\tstruct eni_dev *eni_dev;\n\tstruct eni_vcc *eni_vcc;\n\tu32 dma_rd,dma_wr;\n\tu32 dma[RX_DMA_BUF*2];\n\tdma_addr_t paddr;\n\tunsigned long here;\n\tint i,j;\n\n\teni_dev = ENI_DEV(vcc->dev);\n\teni_vcc = ENI_VCC(vcc);\n\tpaddr = 0;  \n\tif (skb) {\n\t\tpaddr = dma_map_single(&eni_dev->pci_dev->dev,skb->data,skb->len,\n\t\t\t\t       DMA_FROM_DEVICE);\n\t\tif (dma_mapping_error(&eni_dev->pci_dev->dev, paddr))\n\t\t\tgoto dma_map_error;\n\t\tENI_PRV_PADDR(skb) = paddr;\n\t\tif (paddr & 3)\n\t\t\tprintk(KERN_CRIT DEV_LABEL \"(itf %d): VCI %d has \"\n\t\t\t    \"mis-aligned RX data (0x%lx)\\n\",vcc->dev->number,\n\t\t\t    vcc->vci,(unsigned long) paddr);\n\t\tENI_PRV_SIZE(skb) = size+skip;\n\t\t     \n\t\tATM_SKB(skb)->vcc = vcc;\n\t}\n\tj = 0;\n\tif ((eff && skip) || 1) {  \n\t\there = (eni_vcc->descr+skip) & (eni_vcc->words-1);\n\t\tdma[j++] = (here << MID_DMA_COUNT_SHIFT) | (vcc->vci\n\t\t    << MID_DMA_VCI_SHIFT) | MID_DT_JK;\n\t\tdma[j++] = 0;\n\t}\n\there = (eni_vcc->descr+size+skip) & (eni_vcc->words-1);\n\tif (!eff) size += skip;\n\telse {\n\t\tunsigned long words;\n\n\t\tif (!size) {\n\t\t\tDPRINTK(\"strange things happen ...\\n\");\n\t\t\tEVENT(\"strange things happen ... (skip=%ld,eff=%ld)\\n\",\n\t\t\t    size,eff);\n\t\t}\n\t\twords = eff;\n\t\tif (paddr & 15) {\n\t\t\tunsigned long init;\n\n\t\t\tinit = 4-((paddr & 15) >> 2);\n\t\t\tif (init > words) init = words;\n\t\t\tdma[j++] = MID_DT_WORD | (init << MID_DMA_COUNT_SHIFT) |\n\t\t\t    (vcc->vci << MID_DMA_VCI_SHIFT);\n\t\t\tdma[j++] = paddr;\n\t\t\tpaddr += init << 2;\n\t\t\twords -= init;\n\t\t}\n#ifdef CONFIG_ATM_ENI_BURST_RX_16W  \n\t\tif (words & ~15) {\n\t\t\tdma[j++] = MID_DT_16W | ((words >> 4) <<\n\t\t\t    MID_DMA_COUNT_SHIFT) | (vcc->vci <<\n\t\t\t    MID_DMA_VCI_SHIFT);\n\t\t\tdma[j++] = paddr;\n\t\t\tpaddr += (words & ~15) << 2;\n\t\t\twords &= 15;\n\t\t}\n#endif\n#ifdef CONFIG_ATM_ENI_BURST_RX_8W   \n\t\tif (words & ~7) {\n\t\t\tdma[j++] = MID_DT_8W | ((words >> 3) <<\n\t\t\t    MID_DMA_COUNT_SHIFT) | (vcc->vci <<\n\t\t\t    MID_DMA_VCI_SHIFT);\n\t\t\tdma[j++] = paddr;\n\t\t\tpaddr += (words & ~7) << 2;\n\t\t\twords &= 7;\n\t\t}\n#endif\n#ifdef CONFIG_ATM_ENI_BURST_RX_4W  \n\t\tif (words & ~3) {\n\t\t\tdma[j++] = MID_DT_4W | ((words >> 2) <<\n\t\t\t    MID_DMA_COUNT_SHIFT) | (vcc->vci <<\n\t\t\t    MID_DMA_VCI_SHIFT);\n\t\t\tdma[j++] = paddr;\n\t\t\tpaddr += (words & ~3) << 2;\n\t\t\twords &= 3;\n\t\t}\n#endif\n#ifdef CONFIG_ATM_ENI_BURST_RX_2W  \n\t\tif (words & ~1) {\n\t\t\tdma[j++] = MID_DT_2W | ((words >> 1) <<\n\t\t\t    MID_DMA_COUNT_SHIFT) | (vcc->vci <<\n\t\t\t    MID_DMA_VCI_SHIFT);\n\t\t\tdma[j++] = paddr;\n\t\t\tpaddr += (words & ~1) << 2;\n\t\t\twords &= 1;\n\t\t}\n#endif\n\t\tif (words) {\n\t\t\tdma[j++] = MID_DT_WORD | (words << MID_DMA_COUNT_SHIFT)\n\t\t\t    | (vcc->vci << MID_DMA_VCI_SHIFT);\n\t\t\tdma[j++] = paddr;\n\t\t}\n\t}\n\tif (size != eff) {\n\t\tdma[j++] = (here << MID_DMA_COUNT_SHIFT) |\n\t\t    (vcc->vci << MID_DMA_VCI_SHIFT) | MID_DT_JK;\n\t\tdma[j++] = 0;\n\t}\n\tif (!j || j > 2*RX_DMA_BUF) {\n\t\tprintk(KERN_CRIT DEV_LABEL \"!j or j too big!!!\\n\");\n\t\tgoto trouble;\n\t}\n\tdma[j-2] |= MID_DMA_END;\n\tj = j >> 1;\n\tdma_wr = eni_in(MID_DMA_WR_RX);\n\tdma_rd = eni_in(MID_DMA_RD_RX);\n\t \n\tif (!NEPMOK(dma_wr,j+j+1,dma_rd,NR_DMA_RX)) {  \n\t\tprintk(KERN_WARNING DEV_LABEL \"(itf %d): RX DMA full\\n\",\n\t\t    vcc->dev->number);\n\t\tgoto trouble;\n\t}\n        for (i = 0; i < j; i++) {\n\t\twritel(dma[i*2],eni_dev->rx_dma+dma_wr*8);\n\t\twritel(dma[i*2+1],eni_dev->rx_dma+dma_wr*8+4);\n\t\tdma_wr = (dma_wr+1) & (NR_DMA_RX-1);\n        }\n\tif (skb) {\n\t\tENI_PRV_POS(skb) = eni_vcc->descr+size+1;\n\t\tskb_queue_tail(&eni_dev->rx_queue,skb);\n\t\teni_vcc->last = skb;\n\t\trx_enqueued++;\n\t}\n\teni_vcc->descr = here;\n\teni_out(dma_wr,MID_DMA_WR_RX);\n\treturn 0;\n\ntrouble:\n\tif (paddr)\n\t\tdma_unmap_single(&eni_dev->pci_dev->dev,paddr,skb->len,\n\t\t\t\t DMA_FROM_DEVICE);\ndma_map_error:\n\tif (skb) dev_kfree_skb_irq(skb);\n\treturn -1;\n}\n\n\nstatic void discard(struct atm_vcc *vcc,unsigned long size)\n{\n\tstruct eni_vcc *eni_vcc;\n\n\teni_vcc = ENI_VCC(vcc);\n\tEVENT(\"discard (size=%ld)\\n\",size,0);\n\twhile (do_rx_dma(vcc,NULL,1,size,0)) EVENT(\"BUSY LOOP\",0,0);\n\t     \n\tif (eni_vcc->rxing) ENI_PRV_POS(eni_vcc->last) += size+1;\n\telse eni_vcc->rx_pos = (eni_vcc->rx_pos+size+1) & (eni_vcc->words-1);\n}\n\n\n \n\nstatic int rx_aal0(struct atm_vcc *vcc)\n{\n\tstruct eni_vcc *eni_vcc;\n\tunsigned long descr;\n\tunsigned long length;\n\tstruct sk_buff *skb;\n\n\tDPRINTK(\">rx_aal0\\n\");\n\teni_vcc = ENI_VCC(vcc);\n\tdescr = readl(eni_vcc->recv+eni_vcc->descr*4);\n\tif ((descr & MID_RED_IDEN) != (MID_RED_RX_ID << MID_RED_SHIFT)) {\n\t\trx_ident_err(vcc);\n\t\treturn 1;\n\t}\n\tif (descr & MID_RED_T) {\n\t\tDPRINTK(DEV_LABEL \"(itf %d): trashing empty cell\\n\",\n\t\t    vcc->dev->number);\n\t\tlength = 0;\n\t\tatomic_inc(&vcc->stats->rx_err);\n\t}\n\telse {\n\t\tlength = ATM_CELL_SIZE-1;  \n\t}\n\tskb = length ? atm_alloc_charge(vcc,length,GFP_ATOMIC) : NULL;\n\tif (!skb) {\n\t\tdiscard(vcc,length >> 2);\n\t\treturn 0;\n\t}\n\tskb_put(skb,length);\n\tskb->tstamp = eni_vcc->timestamp;\n\tDPRINTK(\"got len %ld\\n\",length);\n\tif (do_rx_dma(vcc,skb,1,length >> 2,length >> 2)) return 1;\n\teni_vcc->rxing++;\n\treturn 0;\n}\n\n\nstatic int rx_aal5(struct atm_vcc *vcc)\n{\n\tstruct eni_vcc *eni_vcc;\n\tunsigned long descr;\n\tunsigned long size,eff,length;\n\tstruct sk_buff *skb;\n\n\tEVENT(\"rx_aal5\\n\",0,0);\n\tDPRINTK(\">rx_aal5\\n\");\n\teni_vcc = ENI_VCC(vcc);\n\tdescr = readl(eni_vcc->recv+eni_vcc->descr*4);\n\tif ((descr & MID_RED_IDEN) != (MID_RED_RX_ID << MID_RED_SHIFT)) {\n\t\trx_ident_err(vcc);\n\t\treturn 1;\n\t}\n\tif (descr & (MID_RED_T | MID_RED_CRC_ERR)) {\n\t\tif (descr & MID_RED_T) {\n\t\t\tEVENT(\"empty cell (descr=0x%lx)\\n\",descr,0);\n\t\t\tDPRINTK(DEV_LABEL \"(itf %d): trashing empty cell\\n\",\n\t\t\t    vcc->dev->number);\n\t\t\tsize = 0;\n\t\t}\n\t\telse {\n\t\t\tstatic unsigned long silence = 0;\n\n\t\t\tif (time_after(jiffies, silence) || silence == 0) {\n\t\t\t\tprintk(KERN_WARNING DEV_LABEL \"(itf %d): \"\n\t\t\t\t    \"discarding PDU(s) with CRC error\\n\",\n\t\t\t\t    vcc->dev->number);\n\t\t\t\tsilence = (jiffies+2*HZ)|1;\n\t\t\t}\n\t\t\tsize = (descr & MID_RED_COUNT)*(ATM_CELL_PAYLOAD >> 2);\n\t\t\tEVENT(\"CRC error (descr=0x%lx,size=%ld)\\n\",descr,\n\t\t\t    size);\n\t\t}\n\t\teff = length = 0;\n\t\tatomic_inc(&vcc->stats->rx_err);\n\t}\n\telse {\n\t\tsize = (descr & MID_RED_COUNT)*(ATM_CELL_PAYLOAD >> 2);\n\t\tDPRINTK(\"size=%ld\\n\",size);\n\t\tlength = readl(eni_vcc->recv+(((eni_vcc->descr+size-1) &\n\t\t    (eni_vcc->words-1)))*4) & 0xffff;\n\t\t\t\t \n\t\tif (length && length <= (size << 2)-8 && length <=\n\t\t  ATM_MAX_AAL5_PDU) eff = (length+3) >> 2;\n\t\telse {\t\t\t\t  \n\t\t\tEVENT(\"bad PDU (descr=0x08%lx,length=%ld)\\n\",descr,\n\t\t\t    length);\n\t\t\tprintk(KERN_ERR DEV_LABEL \"(itf %d): bad AAL5 PDU \"\n\t\t\t    \"(VCI=%d,length=%ld,size=%ld (descr 0x%lx))\\n\",\n\t\t\t    vcc->dev->number,vcc->vci,length,size << 2,descr);\n\t\t\tlength = eff = 0;\n\t\t\tatomic_inc(&vcc->stats->rx_err);\n\t\t}\n\t}\n\tskb = eff ? atm_alloc_charge(vcc,eff << 2,GFP_ATOMIC) : NULL;\n\tif (!skb) {\n\t\tdiscard(vcc,size);\n\t\treturn 0;\n\t}\n\tskb_put(skb,length);\n\tDPRINTK(\"got len %ld\\n\",length);\n\tif (do_rx_dma(vcc,skb,1,size,eff)) return 1;\n\teni_vcc->rxing++;\n\treturn 0;\n}\n\n\nstatic inline int rx_vcc(struct atm_vcc *vcc)\n{\n\tvoid __iomem *vci_dsc;\n\tunsigned long tmp;\n\tstruct eni_vcc *eni_vcc;\n\n\teni_vcc = ENI_VCC(vcc);\n\tvci_dsc = ENI_DEV(vcc->dev)->vci+vcc->vci*16;\n\tEVENT(\"rx_vcc(1)\\n\",0,0);\n\twhile (eni_vcc->descr != (tmp = (readl(vci_dsc+4) & MID_VCI_DESCR) >>\n\t    MID_VCI_DESCR_SHIFT)) {\n\t\tEVENT(\"rx_vcc(2: host dsc=0x%lx, nic dsc=0x%lx)\\n\",\n\t\t    eni_vcc->descr,tmp);\n\t\tDPRINTK(\"CB_DESCR %ld REG_DESCR %d\\n\",ENI_VCC(vcc)->descr,\n\t\t    (((unsigned) readl(vci_dsc+4) & MID_VCI_DESCR) >>\n\t\t    MID_VCI_DESCR_SHIFT));\n\t\tif (ENI_VCC(vcc)->rx(vcc)) return 1;\n\t}\n\t \n\twritel(readl(vci_dsc) & ~MID_VCI_IN_SERVICE,vci_dsc);\n\t \n\tEVENT(\"rx_vcc(3)\\n\",0,0);\n\twhile (ENI_VCC(vcc)->descr != (tmp = (readl(vci_dsc+4) & MID_VCI_DESCR)\n\t    >> MID_VCI_DESCR_SHIFT)) {\n\t\tEVENT(\"rx_vcc(4: host dsc=0x%lx, nic dsc=0x%lx)\\n\",\n\t\t    eni_vcc->descr,tmp);\n\t\tDPRINTK(\"CB_DESCR %ld REG_DESCR %d\\n\",ENI_VCC(vcc)->descr,\n\t\t    (((unsigned) readl(vci_dsc+4) & MID_VCI_DESCR) >>\n\t\t    MID_VCI_DESCR_SHIFT));\n\t\tif (ENI_VCC(vcc)->rx(vcc)) return 1;\n\t}\n\treturn 0;\n}\n\n\nstatic void poll_rx(struct atm_dev *dev)\n{\n\tstruct eni_dev *eni_dev;\n\tstruct atm_vcc *curr;\n\n\teni_dev = ENI_DEV(dev);\n\twhile ((curr = eni_dev->fast)) {\n\t\tEVENT(\"poll_rx.fast\\n\",0,0);\n\t\tif (rx_vcc(curr)) return;\n\t\teni_dev->fast = ENI_VCC(curr)->next;\n\t\tENI_VCC(curr)->next = ENI_VCC_NOS;\n\t\tbarrier();\n\t\tENI_VCC(curr)->servicing--;\n\t}\n\twhile ((curr = eni_dev->slow)) {\n\t\tEVENT(\"poll_rx.slow\\n\",0,0);\n\t\tif (rx_vcc(curr)) return;\n\t\teni_dev->slow = ENI_VCC(curr)->next;\n\t\tENI_VCC(curr)->next = ENI_VCC_NOS;\n\t\tbarrier();\n\t\tENI_VCC(curr)->servicing--;\n\t}\n}\n\n\nstatic void get_service(struct atm_dev *dev)\n{\n\tstruct eni_dev *eni_dev;\n\tstruct atm_vcc *vcc;\n\tunsigned long vci;\n\n\tDPRINTK(\">get_service\\n\");\n\teni_dev = ENI_DEV(dev);\n\twhile (eni_in(MID_SERV_WRITE) != eni_dev->serv_read) {\n\t\tvci = readl(eni_dev->service+eni_dev->serv_read*4);\n\t\teni_dev->serv_read = (eni_dev->serv_read+1) & (NR_SERVICE-1);\n\t\tvcc = eni_dev->rx_map[vci & 1023];\n\t\tif (!vcc) {\n\t\t\tprintk(KERN_CRIT DEV_LABEL \"(itf %d): VCI %ld not \"\n\t\t\t    \"found\\n\",dev->number,vci);\n\t\t\tcontinue;  \n\t\t\t \n\t\t}\n\t\tEVENT(\"getting from service\\n\",0,0);\n\t\tif (ENI_VCC(vcc)->next != ENI_VCC_NOS) {\n\t\t\tEVENT(\"double service\\n\",0,0);\n\t\t\tDPRINTK(\"Grr, servicing VCC %ld twice\\n\",vci);\n\t\t\tcontinue;\n\t\t}\n\t\tENI_VCC(vcc)->timestamp = ktime_get_real();\n\t\tENI_VCC(vcc)->next = NULL;\n\t\tif (vcc->qos.rxtp.traffic_class == ATM_CBR) {\n\t\t\tif (eni_dev->fast)\n\t\t\t\tENI_VCC(eni_dev->last_fast)->next = vcc;\n\t\t\telse eni_dev->fast = vcc;\n\t\t\teni_dev->last_fast = vcc;\n\t\t}\n\t\telse {\n\t\t\tif (eni_dev->slow)\n\t\t\t\tENI_VCC(eni_dev->last_slow)->next = vcc;\n\t\t\telse eni_dev->slow = vcc;\n\t\t\teni_dev->last_slow = vcc;\n\t\t}\n\t\tputting++;\n\t\tENI_VCC(vcc)->servicing++;\n\t}\n}\n\n\nstatic void dequeue_rx(struct atm_dev *dev)\n{\n\tstruct eni_dev *eni_dev;\n\tstruct eni_vcc *eni_vcc;\n\tstruct atm_vcc *vcc;\n\tstruct sk_buff *skb;\n\tvoid __iomem *vci_dsc;\n\tint first;\n\n\teni_dev = ENI_DEV(dev);\n\tfirst = 1;\n\twhile (1) {\n\t\tskb = skb_dequeue(&eni_dev->rx_queue);\n\t\tif (!skb) {\n\t\t\tif (first) {\n\t\t\t\tDPRINTK(DEV_LABEL \"(itf %d): RX but not \"\n\t\t\t\t    \"rxing\\n\",dev->number);\n\t\t\t\tEVENT(\"nothing to dequeue\\n\",0,0);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tEVENT(\"dequeued (size=%ld,pos=0x%lx)\\n\",ENI_PRV_SIZE(skb),\n\t\t    ENI_PRV_POS(skb));\n\t\trx_dequeued++;\n\t\tvcc = ATM_SKB(skb)->vcc;\n\t\teni_vcc = ENI_VCC(vcc);\n\t\tfirst = 0;\n\t\tvci_dsc = eni_dev->vci+vcc->vci*16;\n\t\tif (!EEPMOK(eni_vcc->rx_pos,ENI_PRV_SIZE(skb),\n\t\t    (readl(vci_dsc+4) & MID_VCI_READ) >> MID_VCI_READ_SHIFT,\n\t\t    eni_vcc->words)) {\n\t\t\tEVENT(\"requeuing\\n\",0,0);\n\t\t\tskb_queue_head(&eni_dev->rx_queue,skb);\n\t\t\tbreak;\n\t\t}\n\t\teni_vcc->rxing--;\n\t\teni_vcc->rx_pos = ENI_PRV_POS(skb) & (eni_vcc->words-1);\n\t\tdma_unmap_single(&eni_dev->pci_dev->dev,ENI_PRV_PADDR(skb),skb->len,\n\t\t\t         DMA_TO_DEVICE);\n\t\tif (!skb->len) dev_kfree_skb_irq(skb);\n\t\telse {\n\t\t\tEVENT(\"pushing (len=%ld)\\n\",skb->len,0);\n\t\t\tif (vcc->qos.aal == ATM_AAL0)\n\t\t\t\t*(unsigned long *) skb->data =\n\t\t\t\t    ntohl(*(unsigned long *) skb->data);\n\t\t\tmemset(skb->cb,0,sizeof(struct eni_skb_prv));\n\t\t\tvcc->push(vcc,skb);\n\t\t\tpushed++;\n\t\t}\n\t\tatomic_inc(&vcc->stats->rx);\n\t}\n\twake_up(&eni_dev->rx_wait);\n}\n\n\nstatic int open_rx_first(struct atm_vcc *vcc)\n{\n\tstruct eni_dev *eni_dev;\n\tstruct eni_vcc *eni_vcc;\n\tunsigned long size;\n\n\tDPRINTK(\"open_rx_first\\n\");\n\teni_dev = ENI_DEV(vcc->dev);\n\teni_vcc = ENI_VCC(vcc);\n\teni_vcc->rx = NULL;\n\tif (vcc->qos.rxtp.traffic_class == ATM_NONE) return 0;\n\tsize = vcc->qos.rxtp.max_sdu*eni_dev->rx_mult/100;\n\tif (size > MID_MAX_BUF_SIZE && vcc->qos.rxtp.max_sdu <=\n\t    MID_MAX_BUF_SIZE)\n\t\tsize = MID_MAX_BUF_SIZE;\n\teni_vcc->recv = eni_alloc_mem(eni_dev,&size);\n\tDPRINTK(\"rx at 0x%lx\\n\",eni_vcc->recv);\n\teni_vcc->words = size >> 2;\n\tif (!eni_vcc->recv) return -ENOBUFS;\n\teni_vcc->rx = vcc->qos.aal == ATM_AAL5 ? rx_aal5 : rx_aal0;\n\teni_vcc->descr = 0;\n\teni_vcc->rx_pos = 0;\n\teni_vcc->rxing = 0;\n\teni_vcc->servicing = 0;\n\teni_vcc->next = ENI_VCC_NOS;\n\treturn 0;\n}\n\n\nstatic int open_rx_second(struct atm_vcc *vcc)\n{\n\tvoid __iomem *here;\n\tstruct eni_dev *eni_dev;\n\tstruct eni_vcc *eni_vcc;\n\tunsigned long size;\n\tint order;\n\n\tDPRINTK(\"open_rx_second\\n\");\n\teni_dev = ENI_DEV(vcc->dev);\n\teni_vcc = ENI_VCC(vcc);\n\tif (!eni_vcc->rx) return 0;\n\t \n\there = eni_dev->vci+vcc->vci*16;\n\tDPRINTK(\"loc 0x%x\\n\",(unsigned) (eni_vcc->recv-eni_dev->ram)/4);\n\tsize = eni_vcc->words >> 8;\n\tfor (order = -1; size; order++) size >>= 1;\n\twritel(0,here+4);  \n\twritel(0,here+8);  \n\tif (eni_dev->rx_map[vcc->vci])\n\t\tprintk(KERN_CRIT DEV_LABEL \"(itf %d): BUG - VCI %d already \"\n\t\t    \"in use\\n\",vcc->dev->number,vcc->vci);\n\teni_dev->rx_map[vcc->vci] = vcc;  \n\twritel(((vcc->qos.aal != ATM_AAL5 ? MID_MODE_RAW : MID_MODE_AAL5) <<\n\t    MID_VCI_MODE_SHIFT) | MID_VCI_PTI_MODE |\n\t    (((eni_vcc->recv-eni_dev->ram) >> (MID_LOC_SKIP+2)) <<\n\t    MID_VCI_LOCATION_SHIFT) | (order << MID_VCI_SIZE_SHIFT),here);\n\treturn 0;\n}\n\n\nstatic void close_rx(struct atm_vcc *vcc)\n{\n\tDECLARE_WAITQUEUE(wait,current);\n\tvoid __iomem *here;\n\tstruct eni_dev *eni_dev;\n\tstruct eni_vcc *eni_vcc;\n\n\teni_vcc = ENI_VCC(vcc);\n\tif (!eni_vcc->rx) return;\n\teni_dev = ENI_DEV(vcc->dev);\n\tif (vcc->vpi != ATM_VPI_UNSPEC && vcc->vci != ATM_VCI_UNSPEC) {\n\t\there = eni_dev->vci+vcc->vci*16;\n\t\t \n\t\twritel((readl(here) & ~MID_VCI_MODE) | (MID_MODE_TRASH <<\n\t\t    MID_VCI_MODE_SHIFT),here);\n\t\t \n\t\tudelay(27);\n\t\t \n\t\twritel(readl(here) & ~MID_VCI_IN_SERVICE,here);\n\t\t \n\t\teni_dev->rx_map[vcc->vci] = NULL;\n\t\t \n\t\tDPRINTK(\"eni_close: waiting for RX ...\\n\");\n\t\tEVENT(\"RX closing\\n\",0,0);\n\t\tadd_wait_queue(&eni_dev->rx_wait,&wait);\n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\tbarrier();\n\t\tfor (;;) {\n\t\t\t \n\t\t\tif (!eni_vcc->servicing) {\n\t\t\t\tbarrier();\n\t\t\t\tif (!eni_vcc->rxing) break;\n\t\t\t}\n\t\t\tEVENT(\"drain PDUs (rx %ld, serv %ld)\\n\",eni_vcc->rxing,\n\t\t\t    eni_vcc->servicing);\n\t\t\tprintk(KERN_INFO \"%d+%d RX left\\n\",eni_vcc->servicing,\n\t\t\t    eni_vcc->rxing);\n\t\t\tschedule();\n\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t}\n\t\tfor (;;) {\n\t\t\tint at_end;\n\t\t\tu32 tmp;\n\n\t\t\ttasklet_disable(&eni_dev->task);\n\t\t\ttmp = readl(eni_dev->vci+vcc->vci*16+4) & MID_VCI_READ;\n\t\t\tat_end = eni_vcc->rx_pos == tmp >> MID_VCI_READ_SHIFT;\n\t\t\ttasklet_enable(&eni_dev->task);\n\t\t\tif (at_end) break;\n\t\t\tEVENT(\"drain discard (host 0x%lx, nic 0x%lx)\\n\",\n\t\t\t    eni_vcc->rx_pos,tmp);\n\t\t\tprintk(KERN_INFO \"draining RX: host 0x%lx, nic 0x%x\\n\",\n\t\t\t    eni_vcc->rx_pos,tmp);\n\t\t\tschedule();\n\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t}\n\t\tset_current_state(TASK_RUNNING);\n\t\tremove_wait_queue(&eni_dev->rx_wait,&wait);\n\t}\n\teni_free_mem(eni_dev,eni_vcc->recv,eni_vcc->words << 2);\n\teni_vcc->rx = NULL;\n}\n\n\nstatic int start_rx(struct atm_dev *dev)\n{\n\tstruct eni_dev *eni_dev;\n\n\teni_dev = ENI_DEV(dev);\n\teni_dev->rx_map = (struct atm_vcc **) get_zeroed_page(GFP_KERNEL);\n\tif (!eni_dev->rx_map) {\n\t\tprintk(KERN_ERR DEV_LABEL \"(itf %d): couldn't get free page\\n\",\n\t\t    dev->number);\n\t\tfree_page((unsigned long) eni_dev->free_list);\n\t\treturn -ENOMEM;\n\t}\n\teni_dev->rx_mult = DEFAULT_RX_MULT;\n\teni_dev->fast = eni_dev->last_fast = NULL;\n\teni_dev->slow = eni_dev->last_slow = NULL;\n\tinit_waitqueue_head(&eni_dev->rx_wait);\n\tskb_queue_head_init(&eni_dev->rx_queue);\n\teni_dev->serv_read = eni_in(MID_SERV_WRITE);\n\teni_out(0,MID_DMA_WR_RX);\n\treturn 0;\n}\n\n\n \n\n\nenum enq_res { enq_ok,enq_next,enq_jam };\n\n\nstatic inline void put_dma(int chan,u32 *dma,int *j,dma_addr_t paddr,\n    u32 size)\n{\n\tu32 init,words;\n\n\tDPRINTK(\"put_dma: 0x%lx+0x%x\\n\",(unsigned long) paddr,size);\n\tEVENT(\"put_dma: 0x%lx+0x%lx\\n\",(unsigned long) paddr,size);\n#if 0  \n\tif (paddr & 3)\n\t\tprintk(KERN_ERR \"put_dma: unaligned addr (0x%lx)\\n\",paddr);\n\tif (size & 3)\n\t\tprintk(KERN_ERR \"put_dma: unaligned size (0x%lx)\\n\",size);\n#endif\n\tif (paddr & 3) {\n\t\tinit = 4-(paddr & 3);\n\t\tif (init > size || size < 7) init = size;\n\t\tDPRINTK(\"put_dma: %lx DMA: %d/%d bytes\\n\",\n\t\t    (unsigned long) paddr,init,size);\n\t\tdma[(*j)++] = MID_DT_BYTE | (init << MID_DMA_COUNT_SHIFT) |\n\t\t    (chan << MID_DMA_CHAN_SHIFT);\n\t\tdma[(*j)++] = paddr;\n\t\tpaddr += init;\n\t\tsize -= init;\n\t}\n\twords = size >> 2;\n\tsize &= 3;\n\tif (words && (paddr & 31)) {\n\t\tinit = 8-((paddr & 31) >> 2);\n\t\tif (init > words) init = words;\n\t\tDPRINTK(\"put_dma: %lx DMA: %d/%d words\\n\",\n\t\t    (unsigned long) paddr,init,words);\n\t\tdma[(*j)++] = MID_DT_WORD | (init << MID_DMA_COUNT_SHIFT) |\n\t\t    (chan << MID_DMA_CHAN_SHIFT);\n\t\tdma[(*j)++] = paddr;\n\t\tpaddr += init << 2;\n\t\twords -= init;\n\t}\n#ifdef CONFIG_ATM_ENI_BURST_TX_16W  \n\tif (words & ~15) {\n\t\tDPRINTK(\"put_dma: %lx DMA: %d*16/%d words\\n\",\n\t\t    (unsigned long) paddr,words >> 4,words);\n\t\tdma[(*j)++] = MID_DT_16W | ((words >> 4) << MID_DMA_COUNT_SHIFT)\n\t\t    | (chan << MID_DMA_CHAN_SHIFT);\n\t\tdma[(*j)++] = paddr;\n\t\tpaddr += (words & ~15) << 2;\n\t\twords &= 15;\n\t}\n#endif\n#ifdef CONFIG_ATM_ENI_BURST_TX_8W  \n\tif (words & ~7) {\n\t\tDPRINTK(\"put_dma: %lx DMA: %d*8/%d words\\n\",\n\t\t    (unsigned long) paddr,words >> 3,words);\n\t\tdma[(*j)++] = MID_DT_8W | ((words >> 3) << MID_DMA_COUNT_SHIFT)\n\t\t    | (chan << MID_DMA_CHAN_SHIFT);\n\t\tdma[(*j)++] = paddr;\n\t\tpaddr += (words & ~7) << 2;\n\t\twords &= 7;\n\t}\n#endif\n#ifdef CONFIG_ATM_ENI_BURST_TX_4W  \n\tif (words & ~3) {\n\t\tDPRINTK(\"put_dma: %lx DMA: %d*4/%d words\\n\",\n\t\t    (unsigned long) paddr,words >> 2,words);\n\t\tdma[(*j)++] = MID_DT_4W | ((words >> 2) << MID_DMA_COUNT_SHIFT)\n\t\t    | (chan << MID_DMA_CHAN_SHIFT);\n\t\tdma[(*j)++] = paddr;\n\t\tpaddr += (words & ~3) << 2;\n\t\twords &= 3;\n\t}\n#endif\n#ifdef CONFIG_ATM_ENI_BURST_TX_2W  \n\tif (words & ~1) {\n\t\tDPRINTK(\"put_dma: %lx DMA: %d*2/%d words\\n\",\n\t\t    (unsigned long) paddr,words >> 1,words);\n\t\tdma[(*j)++] = MID_DT_2W | ((words >> 1) << MID_DMA_COUNT_SHIFT)\n\t\t    | (chan << MID_DMA_CHAN_SHIFT);\n\t\tdma[(*j)++] = paddr;\n\t\tpaddr += (words & ~1) << 2;\n\t\twords &= 1;\n\t}\n#endif\n\tif (words) {\n\t\tDPRINTK(\"put_dma: %lx DMA: %d words\\n\",(unsigned long) paddr,\n\t\t    words);\n\t\tdma[(*j)++] = MID_DT_WORD | (words << MID_DMA_COUNT_SHIFT) |\n\t\t    (chan << MID_DMA_CHAN_SHIFT);\n\t\tdma[(*j)++] = paddr;\n\t\tpaddr += words << 2;\n\t}\n\tif (size) {\n\t\tDPRINTK(\"put_dma: %lx DMA: %d bytes\\n\",(unsigned long) paddr,\n\t\t    size);\n\t\tdma[(*j)++] = MID_DT_BYTE | (size << MID_DMA_COUNT_SHIFT) |\n\t\t    (chan << MID_DMA_CHAN_SHIFT);\n\t\tdma[(*j)++] = paddr;\n\t}\n}\n\n\nstatic enum enq_res do_tx(struct sk_buff *skb)\n{\n\tstruct atm_vcc *vcc;\n\tstruct eni_dev *eni_dev;\n\tstruct eni_vcc *eni_vcc;\n\tstruct eni_tx *tx;\n\tdma_addr_t paddr;\n\tu32 dma_rd,dma_wr;\n\tu32 size;  \n\tint aal5,dma_size,i,j;\n\tunsigned char skb_data3;\n\n\tDPRINTK(\">do_tx\\n\");\n\tNULLCHECK(skb);\n\tEVENT(\"do_tx: skb=0x%lx, %ld bytes\\n\",(unsigned long) skb,skb->len);\n\tvcc = ATM_SKB(skb)->vcc;\n\tNULLCHECK(vcc);\n\teni_dev = ENI_DEV(vcc->dev);\n\tNULLCHECK(eni_dev);\n\teni_vcc = ENI_VCC(vcc);\n\ttx = eni_vcc->tx;\n\tNULLCHECK(tx);\n#if 0  \n\t{\n\t\tunsigned int hack = *((char *) skb->data)-'0';\n\n\t\tif (hack < 8) {\n\t\t\tskb->data += hack;\n\t\t\tskb->len -= hack;\n\t\t}\n\t}\n#endif\n#if 0  \n\tif ((unsigned long) skb->data & 3)\n\t\tprintk(KERN_ERR DEV_LABEL \"(itf %d): VCI %d has mis-aligned \"\n\t\t    \"TX data\\n\",vcc->dev->number,vcc->vci);\n#endif\n\t \n\n\taal5 = vcc->qos.aal == ATM_AAL5;\n\t \n\tif (!aal5)\n\t\tsize = (ATM_CELL_PAYLOAD >> 2)+TX_DESCR_SIZE;\n\t\t\t \n\telse {\n\t\tsize = skb->len+4*AAL5_TRAILER+ATM_CELL_PAYLOAD-1;\n\t\t\t \n\t\tsize = ((size-(size % ATM_CELL_PAYLOAD)) >> 2)+TX_DESCR_SIZE;\n\t\t\t\t\t\t \n\t}\n\t \n\tif (!NEPMOK(tx->tx_pos,size+TX_GAP,\n\t    eni_in(MID_TX_RDPTR(tx->index)),tx->words)) {\n\t\tDPRINTK(DEV_LABEL \"(itf %d): TX full (size %d)\\n\",\n\t\t    vcc->dev->number,size);\n\t\treturn enq_next;\n\t}\n\t \n\tdma_wr = eni_in(MID_DMA_WR_TX);\n\tdma_rd = eni_in(MID_DMA_RD_TX);\n\tdma_size = 3;  \nDPRINTK(\"iovcnt = %d\\n\",skb_shinfo(skb)->nr_frags);\n\tif (!skb_shinfo(skb)->nr_frags) dma_size += 5;\n\telse dma_size += 5*(skb_shinfo(skb)->nr_frags+1);\n\tif (dma_size > TX_DMA_BUF) {\n\t\tprintk(KERN_CRIT DEV_LABEL \"(itf %d): needs %d DMA entries \"\n\t\t    \"(got only %d)\\n\",vcc->dev->number,dma_size,TX_DMA_BUF);\n\t}\n\tDPRINTK(\"dma_wr is %d, tx_pos is %ld\\n\",dma_wr,tx->tx_pos);\n\tif (dma_wr != dma_rd && ((dma_rd+NR_DMA_TX-dma_wr) & (NR_DMA_TX-1)) <\n\t     dma_size) {\n\t\tprintk(KERN_WARNING DEV_LABEL \"(itf %d): TX DMA full\\n\",\n\t\t    vcc->dev->number);\n\t\treturn enq_jam;\n\t}\n\tskb_data3 = skb->data[3];\n\tpaddr = dma_map_single(&eni_dev->pci_dev->dev,skb->data,skb->len,\n\t\t\t       DMA_TO_DEVICE);\n\tif (dma_mapping_error(&eni_dev->pci_dev->dev, paddr))\n\t\treturn enq_next;\n\tENI_PRV_PADDR(skb) = paddr;\n\t \n\tj = 0;\n\teni_dev->dma[j++] = (((tx->tx_pos+TX_DESCR_SIZE) & (tx->words-1)) <<\n\t     MID_DMA_COUNT_SHIFT) | (tx->index << MID_DMA_CHAN_SHIFT) |\n\t     MID_DT_JK;\n\tj++;\n\tif (!skb_shinfo(skb)->nr_frags)\n\t\tif (aal5) put_dma(tx->index,eni_dev->dma,&j,paddr,skb->len);\n\t\telse put_dma(tx->index,eni_dev->dma,&j,paddr+4,skb->len-4);\n\telse {\nDPRINTK(\"doing direct send\\n\");  \n\t\tfor (i = -1; i < skb_shinfo(skb)->nr_frags; i++)\n\t\t\tif (i == -1)\n\t\t\t\tput_dma(tx->index,eni_dev->dma,&j,(unsigned long)\n\t\t\t\t    skb->data,\n\t\t\t\t    skb_headlen(skb));\n\t\t\telse\n\t\t\t\tput_dma(tx->index,eni_dev->dma,&j,(unsigned long)\n\t\t\t\t    skb_frag_page(&skb_shinfo(skb)->frags[i]) +\n\t\t\t\t\tskb_frag_off(&skb_shinfo(skb)->frags[i]),\n\t\t\t\t    skb_frag_size(&skb_shinfo(skb)->frags[i]));\n\t}\n\tif (skb->len & 3) {\n\t\tput_dma(tx->index, eni_dev->dma, &j, eni_dev->zero.dma,\n\t\t\t4 - (skb->len & 3));\n\t}\n\t \n\teni_dev->dma[j++] = (((tx->tx_pos+size) & (tx->words-1)) <<\n\t     MID_DMA_COUNT_SHIFT) | (tx->index << MID_DMA_CHAN_SHIFT) |\n\t     MID_DMA_END | MID_DT_JK;\n\tj++;\n\tDPRINTK(\"DMA at end: %d\\n\",j);\n\t \n\twritel((MID_SEG_TX_ID << MID_SEG_ID_SHIFT) |\n\t    (aal5 ? MID_SEG_AAL5 : 0) | (tx->prescaler << MID_SEG_PR_SHIFT) |\n\t    (tx->resolution << MID_SEG_RATE_SHIFT) |\n\t    (size/(ATM_CELL_PAYLOAD/4)),tx->send+tx->tx_pos*4);\n \n\twritel((vcc->vci << MID_SEG_VCI_SHIFT) |\n            (aal5 ? 0 : (skb_data3 & 0xf)) |\n\t    (ATM_SKB(skb)->atm_options & ATM_ATMOPT_CLP ? MID_SEG_CLP : 0),\n\t    tx->send+((tx->tx_pos+1) & (tx->words-1))*4);\n\tDPRINTK(\"size: %d, len:%d\\n\",size,skb->len);\n\tif (aal5)\n\t\twritel(skb->len,tx->send+\n                    ((tx->tx_pos+size-AAL5_TRAILER) & (tx->words-1))*4);\n\tj = j >> 1;\n\tfor (i = 0; i < j; i++) {\n\t\twritel(eni_dev->dma[i*2],eni_dev->tx_dma+dma_wr*8);\n\t\twritel(eni_dev->dma[i*2+1],eni_dev->tx_dma+dma_wr*8+4);\n\t\tdma_wr = (dma_wr+1) & (NR_DMA_TX-1);\n\t}\n\tENI_PRV_POS(skb) = tx->tx_pos;\n\tENI_PRV_SIZE(skb) = size;\n\tENI_VCC(vcc)->txing += size;\n\ttx->tx_pos = (tx->tx_pos+size) & (tx->words-1);\n\tDPRINTK(\"dma_wr set to %d, tx_pos is now %ld\\n\",dma_wr,tx->tx_pos);\n\teni_out(dma_wr,MID_DMA_WR_TX);\n\tskb_queue_tail(&eni_dev->tx_queue,skb);\n\tqueued++;\n\treturn enq_ok;\n}\n\n\nstatic void poll_tx(struct atm_dev *dev)\n{\n\tstruct eni_tx *tx;\n\tstruct sk_buff *skb;\n\tenum enq_res res;\n\tint i;\n\n\tDPRINTK(\">poll_tx\\n\");\n\tfor (i = NR_CHAN-1; i >= 0; i--) {\n\t\ttx = &ENI_DEV(dev)->tx[i];\n\t\tif (tx->send)\n\t\t\twhile ((skb = skb_dequeue(&tx->backlog))) {\n\t\t\t\tres = do_tx(skb);\n\t\t\t\tif (res == enq_ok) continue;\n\t\t\t\tDPRINTK(\"re-queuing TX PDU\\n\");\n\t\t\t\tskb_queue_head(&tx->backlog,skb);\n\t\t\t\trequeued++;\n\t\t\t\tif (res == enq_jam) return;\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n}\n\n\nstatic void dequeue_tx(struct atm_dev *dev)\n{\n\tstruct eni_dev *eni_dev;\n\tstruct atm_vcc *vcc;\n\tstruct sk_buff *skb;\n\tstruct eni_tx *tx;\n\n\tNULLCHECK(dev);\n\teni_dev = ENI_DEV(dev);\n\tNULLCHECK(eni_dev);\n\twhile ((skb = skb_dequeue(&eni_dev->tx_queue))) {\n\t\tvcc = ATM_SKB(skb)->vcc;\n\t\tNULLCHECK(vcc);\n\t\ttx = ENI_VCC(vcc)->tx;\n\t\tNULLCHECK(ENI_VCC(vcc)->tx);\n\t\tDPRINTK(\"dequeue_tx: next 0x%lx curr 0x%x\\n\",ENI_PRV_POS(skb),\n\t\t    (unsigned) eni_in(MID_TX_DESCRSTART(tx->index)));\n\t\tif (ENI_VCC(vcc)->txing < tx->words && ENI_PRV_POS(skb) ==\n\t\t    eni_in(MID_TX_DESCRSTART(tx->index))) {\n\t\t\tskb_queue_head(&eni_dev->tx_queue,skb);\n\t\t\tbreak;\n\t\t}\n\t\tENI_VCC(vcc)->txing -= ENI_PRV_SIZE(skb);\n\t\tdma_unmap_single(&eni_dev->pci_dev->dev,ENI_PRV_PADDR(skb),skb->len,\n\t\t\t\t DMA_TO_DEVICE);\n\t\tif (vcc->pop) vcc->pop(vcc,skb);\n\t\telse dev_kfree_skb_irq(skb);\n\t\tatomic_inc(&vcc->stats->tx);\n\t\twake_up(&eni_dev->tx_wait);\n\t\tdma_complete++;\n\t}\n}\n\n\nstatic struct eni_tx *alloc_tx(struct eni_dev *eni_dev,int ubr)\n{\n\tint i;\n\n\tfor (i = !ubr; i < NR_CHAN; i++)\n\t\tif (!eni_dev->tx[i].send) return eni_dev->tx+i;\n\treturn NULL;\n}\n\n\nstatic int comp_tx(struct eni_dev *eni_dev,int *pcr,int reserved,int *pre,\n    int *res,int unlimited)\n{\n\tstatic const int pre_div[] = { 4,16,128,2048 };\n\t     \n\n\tif (unlimited) *pre = *res = 0;\n\telse {\n\t\tif (*pcr > 0) {\n\t\t\tint div;\n\n\t\t\tfor (*pre = 0; *pre < 3; (*pre)++)\n\t\t\t\tif (TS_CLOCK/pre_div[*pre]/64 <= *pcr) break;\n\t\t\tdiv = pre_div[*pre]**pcr;\n\t\t\tDPRINTK(\"min div %d\\n\",div);\n\t\t\t*res = TS_CLOCK/div-1;\n\t\t}\n\t\telse {\n\t\t\tint div;\n\n\t\t\tif (!*pcr) *pcr = eni_dev->tx_bw+reserved;\n\t\t\tfor (*pre = 3; *pre >= 0; (*pre)--)\n\t\t\t\tif (TS_CLOCK/pre_div[*pre]/64 > -*pcr) break;\n\t\t\tif (*pre < 3) (*pre)++;  \n\t\t\tdiv = pre_div[*pre]*-*pcr;\n\t\t\tDPRINTK(\"max div %d\\n\",div);\n\t\t\t*res = DIV_ROUND_UP(TS_CLOCK, div)-1;\n\t\t}\n\t\tif (*res < 0) *res = 0;\n\t\tif (*res > MID_SEG_MAX_RATE) *res = MID_SEG_MAX_RATE;\n\t}\n\t*pcr = TS_CLOCK/pre_div[*pre]/(*res+1);\n\tDPRINTK(\"out pcr: %d (%d:%d)\\n\",*pcr,*pre,*res);\n\treturn 0;\n}\n\n\nstatic int reserve_or_set_tx(struct atm_vcc *vcc,struct atm_trafprm *txtp,\n    int set_rsv,int set_shp)\n{\n\tstruct eni_dev *eni_dev = ENI_DEV(vcc->dev);\n\tstruct eni_vcc *eni_vcc = ENI_VCC(vcc);\n\tstruct eni_tx *tx;\n\tunsigned long size;\n\tvoid __iomem *mem;\n\tint rate,ubr,unlimited,new_tx;\n\tint pre,res,order;\n\tint error;\n\n\trate = atm_pcr_goal(txtp);\n\tubr = txtp->traffic_class == ATM_UBR;\n\tunlimited = ubr && (!rate || rate <= -ATM_OC3_PCR ||\n\t    rate >= ATM_OC3_PCR);\n\tif (!unlimited) {\n\t\tsize = txtp->max_sdu*eni_dev->tx_mult/100;\n\t\tif (size > MID_MAX_BUF_SIZE && txtp->max_sdu <=\n\t\t    MID_MAX_BUF_SIZE)\n\t\t\tsize = MID_MAX_BUF_SIZE;\n\t}\n\telse {\n\t\tif (eni_dev->ubr) {\n\t\t\teni_vcc->tx = eni_dev->ubr;\n\t\t\ttxtp->pcr = ATM_OC3_PCR;\n\t\t\treturn 0;\n\t\t}\n\t\tsize = UBR_BUFFER;\n\t}\n\tnew_tx = !eni_vcc->tx;\n\tmem = NULL;  \n\tif (!new_tx) tx = eni_vcc->tx;\n\telse {\n\t\tmem = eni_alloc_mem(eni_dev,&size);\n\t\tif (!mem) return -ENOBUFS;\n\t\ttx = alloc_tx(eni_dev,unlimited);\n\t\tif (!tx) {\n\t\t\teni_free_mem(eni_dev,mem,size);\n\t\t\treturn -EBUSY;\n\t\t}\n\t\tDPRINTK(\"got chan %d\\n\",tx->index);\n\t\ttx->reserved = tx->shaping = 0;\n\t\ttx->send = mem;\n\t\ttx->words = size >> 2;\n\t\tskb_queue_head_init(&tx->backlog);\n\t\tfor (order = 0; size > (1 << (order+10)); order++);\n\t\teni_out((order << MID_SIZE_SHIFT) |\n\t\t    ((tx->send-eni_dev->ram) >> (MID_LOC_SKIP+2)),\n\t\t    MID_TX_PLACE(tx->index));\n\t\ttx->tx_pos = eni_in(MID_TX_DESCRSTART(tx->index)) &\n\t\t    MID_DESCR_START;\n\t}\n\terror = comp_tx(eni_dev,&rate,tx->reserved,&pre,&res,unlimited);\n\tif (!error  && txtp->min_pcr > rate) error = -EINVAL;\n\tif (!error && txtp->max_pcr && txtp->max_pcr != ATM_MAX_PCR &&\n\t    txtp->max_pcr < rate) error = -EINVAL;\n\tif (!error && !ubr && rate > eni_dev->tx_bw+tx->reserved)\n\t\terror = -EINVAL;\n\tif (!error && set_rsv && !set_shp && rate < tx->shaping)\n\t\terror = -EINVAL;\n\tif (!error && !set_rsv && rate > tx->reserved && !ubr)\n\t\terror = -EINVAL;\n\tif (error) {\n\t\tif (new_tx) {\n\t\t\ttx->send = NULL;\n\t\t\teni_free_mem(eni_dev,mem,size);\n\t\t}\n\t\treturn error;\n\t}\n\ttxtp->pcr = rate;\n\tif (set_rsv && !ubr) {\n\t\teni_dev->tx_bw += tx->reserved;\n\t\ttx->reserved = rate;\n\t\teni_dev->tx_bw -= rate;\n\t}\n\tif (set_shp || (unlimited && new_tx)) {\n\t\tif (unlimited && new_tx) eni_dev->ubr = tx;\n\t\ttx->prescaler = pre;\n\t\ttx->resolution = res;\n\t\ttx->shaping = rate;\n\t}\n\tif (set_shp) eni_vcc->tx = tx;\n\tDPRINTK(\"rsv %d shp %d\\n\",tx->reserved,tx->shaping);\n\treturn 0;\n}\n\n\nstatic int open_tx_first(struct atm_vcc *vcc)\n{\n\tENI_VCC(vcc)->tx = NULL;\n\tif (vcc->qos.txtp.traffic_class == ATM_NONE) return 0;\n\tENI_VCC(vcc)->txing = 0;\n\treturn reserve_or_set_tx(vcc,&vcc->qos.txtp,1,1);\n}\n\n\nstatic int open_tx_second(struct atm_vcc *vcc)\n{\n\treturn 0;  \n}\n\n\nstatic void close_tx(struct atm_vcc *vcc)\n{\n\tDECLARE_WAITQUEUE(wait,current);\n\tstruct eni_dev *eni_dev;\n\tstruct eni_vcc *eni_vcc;\n\n\teni_vcc = ENI_VCC(vcc);\n\tif (!eni_vcc->tx) return;\n\teni_dev = ENI_DEV(vcc->dev);\n\t \n\tDPRINTK(\"eni_close: waiting for TX ...\\n\");\n\tadd_wait_queue(&eni_dev->tx_wait,&wait);\n\tset_current_state(TASK_UNINTERRUPTIBLE);\n\tfor (;;) {\n\t\tint txing;\n\n\t\ttasklet_disable(&eni_dev->task);\n\t\ttxing = skb_peek(&eni_vcc->tx->backlog) || eni_vcc->txing;\n\t\ttasklet_enable(&eni_dev->task);\n\t\tif (!txing) break;\n\t\tDPRINTK(\"%d TX left\\n\",eni_vcc->txing);\n\t\tschedule();\n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t}\n\tset_current_state(TASK_RUNNING);\n\tremove_wait_queue(&eni_dev->tx_wait,&wait);\n\tif (eni_vcc->tx != eni_dev->ubr) {\n\t\t \n\t\twhile (eni_in(MID_TX_RDPTR(eni_vcc->tx->index)) !=\n\t\t    eni_in(MID_TX_DESCRSTART(eni_vcc->tx->index)))\n\t\t\tschedule();\n\t\teni_free_mem(eni_dev,eni_vcc->tx->send,eni_vcc->tx->words << 2);\n\t\teni_vcc->tx->send = NULL;\n\t\teni_dev->tx_bw += eni_vcc->tx->reserved;\n\t}\n\teni_vcc->tx = NULL;\n}\n\n\nstatic int start_tx(struct atm_dev *dev)\n{\n\tstruct eni_dev *eni_dev;\n\tint i;\n\n\teni_dev = ENI_DEV(dev);\n\teni_dev->lost = 0;\n\teni_dev->tx_bw = ATM_OC3_PCR;\n\teni_dev->tx_mult = DEFAULT_TX_MULT;\n\tinit_waitqueue_head(&eni_dev->tx_wait);\n\teni_dev->ubr = NULL;\n\tskb_queue_head_init(&eni_dev->tx_queue);\n\teni_out(0,MID_DMA_WR_TX);\n\tfor (i = 0; i < NR_CHAN; i++) {\n\t\teni_dev->tx[i].send = NULL;\n\t\teni_dev->tx[i].index = i;\n\t}\n\treturn 0;\n}\n\n\n \n\n\n#if 0  \n\nstatic void foo(void)\n{\nprintk(KERN_INFO\n  \"tx_complete=%d,dma_complete=%d,queued=%d,requeued=%d,sub=%d,\\n\"\n  \"backlogged=%d,rx_enqueued=%d,rx_dequeued=%d,putting=%d,pushed=%d\\n\",\n  tx_complete,dma_complete,queued,requeued,submitted,backlogged,\n  rx_enqueued,rx_dequeued,putting,pushed);\nif (eni_boards) printk(KERN_INFO \"loss: %ld\\n\",ENI_DEV(eni_boards)->lost);\n}\n\n#endif\n\n\nstatic void bug_int(struct atm_dev *dev,unsigned long reason)\n{\n\tDPRINTK(\">bug_int\\n\");\n\tif (reason & MID_DMA_ERR_ACK)\n\t\tprintk(KERN_CRIT DEV_LABEL \"(itf %d): driver error - DMA \"\n\t\t    \"error\\n\",dev->number);\n\tif (reason & MID_TX_IDENT_MISM)\n\t\tprintk(KERN_CRIT DEV_LABEL \"(itf %d): driver error - ident \"\n\t\t    \"mismatch\\n\",dev->number);\n\tif (reason & MID_TX_DMA_OVFL)\n\t\tprintk(KERN_CRIT DEV_LABEL \"(itf %d): driver error - DMA \"\n\t\t    \"overflow\\n\",dev->number);\n\tEVENT(\"---dump ends here---\\n\",0,0);\n\tprintk(KERN_NOTICE \"---recent events---\\n\");\n\tevent_dump();\n}\n\n\nstatic irqreturn_t eni_int(int irq,void *dev_id)\n{\n\tstruct atm_dev *dev;\n\tstruct eni_dev *eni_dev;\n\tu32 reason;\n\n\tDPRINTK(\">eni_int\\n\");\n\tdev = dev_id;\n\teni_dev = ENI_DEV(dev);\n\treason = eni_in(MID_ISA);\n\tDPRINTK(DEV_LABEL \": int 0x%lx\\n\",(unsigned long) reason);\n\t \n\tif (reason & MID_STAT_OVFL) {\n\t\tEVENT(\"stat overflow\\n\",0,0);\n\t\teni_dev->lost += eni_in(MID_STAT) & MID_OVFL_TRASH;\n\t}\n\tif (reason & MID_SUNI_INT) {\n\t\tEVENT(\"SUNI int\\n\",0,0);\n\t\tdev->phy->interrupt(dev);\n#if 0\n\t\tfoo();\n#endif\n\t}\n\tspin_lock(&eni_dev->lock);\n\teni_dev->events |= reason;\n\tspin_unlock(&eni_dev->lock);\n\ttasklet_schedule(&eni_dev->task);\n\treturn IRQ_HANDLED;\n}\n\n\nstatic void eni_tasklet(unsigned long data)\n{\n\tstruct atm_dev *dev = (struct atm_dev *) data;\n\tstruct eni_dev *eni_dev = ENI_DEV(dev);\n\tunsigned long flags;\n\tu32 events;\n\n\tDPRINTK(\"eni_tasklet (dev %p)\\n\",dev);\n\tspin_lock_irqsave(&eni_dev->lock,flags);\n\tevents = xchg(&eni_dev->events,0);\n\tspin_unlock_irqrestore(&eni_dev->lock,flags);\n\tif (events & MID_RX_DMA_COMPLETE) {\n\t\tEVENT(\"INT: RX DMA complete, starting dequeue_rx\\n\",0,0);\n\t\tdequeue_rx(dev);\n\t\tEVENT(\"dequeue_rx done, starting poll_rx\\n\",0,0);\n\t\tpoll_rx(dev);\n\t\tEVENT(\"poll_rx done\\n\",0,0);\n\t\t \n\t}\n\tif (events & MID_SERVICE) {\n\t\tEVENT(\"INT: service, starting get_service\\n\",0,0);\n\t\tget_service(dev);\n\t\tEVENT(\"get_service done, starting poll_rx\\n\",0,0);\n\t\tpoll_rx(dev);\n\t\tEVENT(\"poll_rx done\\n\",0,0);\n\t}\n \tif (events & MID_TX_DMA_COMPLETE) {\n\t\tEVENT(\"INT: TX DMA COMPLETE\\n\",0,0);\n\t\tdequeue_tx(dev);\n\t}\n\tif (events & MID_TX_COMPLETE) {\n\t\tEVENT(\"INT: TX COMPLETE\\n\",0,0);\n\t\ttx_complete++;\n\t\twake_up(&eni_dev->tx_wait);\n\t\t \n\t}\n\tif (events & (MID_DMA_ERR_ACK | MID_TX_IDENT_MISM | MID_TX_DMA_OVFL)) {\n\t\tEVENT(\"bug interrupt\\n\",0,0);\n\t\tbug_int(dev,events);\n\t}\n\tpoll_tx(dev);\n}\n\n\n \n\n\nstatic char * const media_name[] = {\n    \"MMF\", \"SMF\", \"MMF\", \"03?\",  \n    \"UTP\", \"05?\", \"06?\", \"07?\",  \n    \"TAXI\",\"09?\", \"10?\", \"11?\",  \n    \"12?\", \"13?\", \"14?\", \"15?\",  \n    \"MMF\", \"SMF\", \"18?\", \"19?\",  \n    \"UTP\", \"21?\", \"22?\", \"23?\",  \n    \"24?\", \"25?\", \"26?\", \"27?\",  \n    \"28?\", \"29?\", \"30?\", \"31?\"   \n};\n\n\n#define SET_SEPROM \\\n  ({ if (!error && !pci_error) { \\\n    pci_error = pci_write_config_byte(eni_dev->pci_dev,PCI_TONGA_CTRL,tonga); \\\n    udelay(10);   \\\n  } })\n#define GET_SEPROM \\\n  ({ if (!error && !pci_error) { \\\n    pci_error = pci_read_config_byte(eni_dev->pci_dev,PCI_TONGA_CTRL,&tonga); \\\n    udelay(10);   \\\n  } })\n\n\nstatic int get_esi_asic(struct atm_dev *dev)\n{\n\tstruct eni_dev *eni_dev;\n\tunsigned char tonga;\n\tint error,failed,pci_error;\n\tint address,i,j;\n\n\teni_dev = ENI_DEV(dev);\n\terror = pci_error = 0;\n\ttonga = SEPROM_MAGIC | SEPROM_DATA | SEPROM_CLK;\n\tSET_SEPROM;\n\tfor (i = 0; i < ESI_LEN && !error && !pci_error; i++) {\n\t\t \n\t\ttonga |= SEPROM_DATA;\n\t\tSET_SEPROM;\n\t\ttonga |= SEPROM_CLK;\n\t\tSET_SEPROM;\n\t\ttonga &= ~SEPROM_DATA;\n\t\tSET_SEPROM;\n\t\ttonga &= ~SEPROM_CLK;\n\t\tSET_SEPROM;\n\t\t \n\t\taddress = ((i+SEPROM_ESI_BASE) << 1)+1;\n\t\tfor (j = 7; j >= 0; j--) {\n\t\t\ttonga = (address >> j) & 1 ? tonga | SEPROM_DATA :\n\t\t\t    tonga & ~SEPROM_DATA;\n\t\t\tSET_SEPROM;\n\t\t\ttonga |= SEPROM_CLK;\n\t\t\tSET_SEPROM;\n\t\t\ttonga &= ~SEPROM_CLK;\n\t\t\tSET_SEPROM;\n\t\t}\n\t\t \n\t\ttonga |= SEPROM_DATA;\n\t\tSET_SEPROM;\n\t\ttonga |= SEPROM_CLK;\n\t\tSET_SEPROM;\n\t\tGET_SEPROM;\n\t\tfailed = tonga & SEPROM_DATA;\n\t\ttonga &= ~SEPROM_CLK;\n\t\tSET_SEPROM;\n\t\ttonga |= SEPROM_DATA;\n\t\tSET_SEPROM;\n\t\tif (failed) error = -EIO;\n\t\telse {\n\t\t\tdev->esi[i] = 0;\n\t\t\tfor (j = 7; j >= 0; j--) {\n\t\t\t\tdev->esi[i] <<= 1;\n\t\t\t\ttonga |= SEPROM_DATA;\n\t\t\t\tSET_SEPROM;\n\t\t\t\ttonga |= SEPROM_CLK;\n\t\t\t\tSET_SEPROM;\n\t\t\t\tGET_SEPROM;\n\t\t\t\tif (tonga & SEPROM_DATA) dev->esi[i] |= 1;\n\t\t\t\ttonga &= ~SEPROM_CLK;\n\t\t\t\tSET_SEPROM;\n\t\t\t\ttonga |= SEPROM_DATA;\n\t\t\t\tSET_SEPROM;\n\t\t\t}\n\t\t\t \n\t\t\ttonga |= SEPROM_DATA;\n\t\t\tSET_SEPROM;\n\t\t\ttonga |= SEPROM_CLK;\n\t\t\tSET_SEPROM;\n\t\t\tGET_SEPROM;\n\t\t\tif (!(tonga & SEPROM_DATA)) error = -EIO;\n\t\t\ttonga &= ~SEPROM_CLK;\n\t\t\tSET_SEPROM;\n\t\t\ttonga |= SEPROM_DATA;\n\t\t\tSET_SEPROM;\n\t\t}\n\t\t \n\t\ttonga &= ~SEPROM_DATA;\n\t\tSET_SEPROM;\n\t\ttonga |= SEPROM_CLK;\n\t\tSET_SEPROM;\n\t\ttonga |= SEPROM_DATA;\n\t\tSET_SEPROM;\n\t}\n\tif (pci_error) {\n\t\tprintk(KERN_ERR DEV_LABEL \"(itf %d): error reading ESI \"\n\t\t    \"(0x%02x)\\n\",dev->number,pci_error);\n\t\terror = -EIO;\n\t}\n\treturn error;\n}\n\n\n#undef SET_SEPROM\n#undef GET_SEPROM\n\n\nstatic int get_esi_fpga(struct atm_dev *dev, void __iomem *base)\n{\n\tvoid __iomem *mac_base;\n\tint i;\n\n\tmac_base = base+EPROM_SIZE-sizeof(struct midway_eprom);\n\tfor (i = 0; i < ESI_LEN; i++) dev->esi[i] = readb(mac_base+(i^3));\n\treturn 0;\n}\n\n\nstatic int eni_do_init(struct atm_dev *dev)\n{\n\tstruct midway_eprom __iomem *eprom;\n\tstruct eni_dev *eni_dev;\n\tstruct pci_dev *pci_dev;\n\tunsigned long real_base;\n\tvoid __iomem *base;\n\tint error,i,last;\n\n\tDPRINTK(\">eni_init\\n\");\n\tdev->ci_range.vpi_bits = 0;\n\tdev->ci_range.vci_bits = NR_VCI_LD;\n\tdev->link_rate = ATM_OC3_PCR;\n\teni_dev = ENI_DEV(dev);\n\tpci_dev = eni_dev->pci_dev;\n\treal_base = pci_resource_start(pci_dev, 0);\n\teni_dev->irq = pci_dev->irq;\n\tif ((error = pci_write_config_word(pci_dev,PCI_COMMAND,\n\t    PCI_COMMAND_MEMORY |\n\t    (eni_dev->asic ? PCI_COMMAND_PARITY | PCI_COMMAND_SERR : 0)))) {\n\t\tprintk(KERN_ERR DEV_LABEL \"(itf %d): can't enable memory \"\n\t\t    \"(0x%02x)\\n\",dev->number,error);\n\t\treturn -EIO;\n\t}\n\tprintk(KERN_NOTICE DEV_LABEL \"(itf %d): rev.%d,base=0x%lx,irq=%d,\",\n\t    dev->number,pci_dev->revision,real_base,eni_dev->irq);\n\tif (!(base = ioremap(real_base,MAP_MAX_SIZE))) {\n\t\tprintk(\"\\n\");\n\t\tprintk(KERN_ERR DEV_LABEL \"(itf %d): can't set up page \"\n\t\t    \"mapping\\n\",dev->number);\n\t\treturn -ENOMEM;\n\t}\n\teni_dev->ioaddr = base;\n\teni_dev->base_diff = real_base - (unsigned long) base;\n\t \n\tif (!eni_dev->asic) {\n\t\teprom = (base+EPROM_SIZE-sizeof(struct midway_eprom));\n\t\tif (readl(&eprom->magic) != ENI155_MAGIC) {\n\t\t\tprintk(\"\\n\");\n\t\t\tprintk(KERN_ERR DEV_LABEL\n\t\t\t       \"(itf %d): bad magic - expected 0x%x, got 0x%x\\n\",\n\t\t\t       dev->number, ENI155_MAGIC,\n\t\t\t       (unsigned)readl(&eprom->magic));\n\t\t\terror = -EINVAL;\n\t\t\tgoto unmap;\n\t\t}\n\t}\n\teni_dev->phy = base+PHY_BASE;\n\teni_dev->reg = base+REG_BASE;\n\teni_dev->ram = base+RAM_BASE;\n\tlast = MAP_MAX_SIZE-RAM_BASE;\n\tfor (i = last-RAM_INCREMENT; i >= 0; i -= RAM_INCREMENT) {\n\t\twritel(0x55555555,eni_dev->ram+i);\n\t\tif (readl(eni_dev->ram+i) != 0x55555555) last = i;\n\t\telse {\n\t\t\twritel(0xAAAAAAAA,eni_dev->ram+i);\n\t\t\tif (readl(eni_dev->ram+i) != 0xAAAAAAAA) last = i;\n\t\t\telse writel(i,eni_dev->ram+i);\n\t\t}\n\t}\n\tfor (i = 0; i < last; i += RAM_INCREMENT)\n\t\tif (readl(eni_dev->ram+i) != i) break;\n\teni_dev->mem = i;\n\tmemset_io(eni_dev->ram,0,eni_dev->mem);\n\t \n\tprintk(\"mem=%dkB (\",eni_dev->mem >> 10);\n\t \n\tif (!(eni_in(MID_RES_ID_MCON) & 0x200) != !eni_dev->asic) {\n\t\tprintk(\")\\n\");\n\t\tprintk(KERN_ERR DEV_LABEL \"(itf %d): ERROR - wrong id 0x%x\\n\",\n\t\t    dev->number,(unsigned) eni_in(MID_RES_ID_MCON));\n\t\terror = -EINVAL;\n\t\tgoto unmap;\n\t}\n\terror = eni_dev->asic ? get_esi_asic(dev) : get_esi_fpga(dev,base);\n\tif (error)\n\t\tgoto unmap;\n\tfor (i = 0; i < ESI_LEN; i++)\n\t\tprintk(\"%s%02X\",i ? \"-\" : \"\",dev->esi[i]);\n\tprintk(\")\\n\");\n\tprintk(KERN_NOTICE DEV_LABEL \"(itf %d): %s,%s\\n\",dev->number,\n\t    eni_in(MID_RES_ID_MCON) & 0x200 ? \"ASIC\" : \"FPGA\",\n\t    media_name[eni_in(MID_RES_ID_MCON) & DAUGHTER_ID]);\n\n\terror = suni_init(dev);\n\tif (error)\n\t\tgoto unmap;\nout:\n\treturn error;\nunmap:\n\tiounmap(base);\n\tgoto out;\n}\n\nstatic void eni_do_release(struct atm_dev *dev)\n{\n\tstruct eni_dev *ed = ENI_DEV(dev);\n\n\tdev->phy->stop(dev);\n\tdev->phy = NULL;\n\tiounmap(ed->ioaddr);\n}\n\nstatic int eni_start(struct atm_dev *dev)\n{\n\tstruct eni_dev *eni_dev;\n\t\n\tvoid __iomem *buf;\n\tunsigned long buffer_mem;\n\tint error;\n\n\tDPRINTK(\">eni_start\\n\");\n\teni_dev = ENI_DEV(dev);\n\tif (request_irq(eni_dev->irq,&eni_int,IRQF_SHARED,DEV_LABEL,dev)) {\n\t\tprintk(KERN_ERR DEV_LABEL \"(itf %d): IRQ%d is already in use\\n\",\n\t\t    dev->number,eni_dev->irq);\n\t\terror = -EAGAIN;\n\t\tgoto out;\n\t}\n\tpci_set_master(eni_dev->pci_dev);\n\tif ((error = pci_write_config_word(eni_dev->pci_dev,PCI_COMMAND,\n\t    PCI_COMMAND_MEMORY | PCI_COMMAND_MASTER |\n\t    (eni_dev->asic ? PCI_COMMAND_PARITY | PCI_COMMAND_SERR : 0)))) {\n\t\tprintk(KERN_ERR DEV_LABEL \"(itf %d): can't enable memory+\"\n\t\t    \"master (0x%02x)\\n\",dev->number,error);\n\t\tgoto free_irq;\n\t}\n\tif ((error = pci_write_config_byte(eni_dev->pci_dev,PCI_TONGA_CTRL,\n\t    END_SWAP_DMA))) {\n\t\tprintk(KERN_ERR DEV_LABEL \"(itf %d): can't set endian swap \"\n\t\t    \"(0x%02x)\\n\",dev->number,error);\n\t\tgoto free_irq;\n\t}\n\t \n\teni_dev->vci = eni_dev->ram;\n\teni_dev->rx_dma = eni_dev->ram+NR_VCI*16;\n\teni_dev->tx_dma = eni_dev->rx_dma+NR_DMA_RX*8;\n\teni_dev->service = eni_dev->tx_dma+NR_DMA_TX*8;\n\tbuf = eni_dev->service+NR_SERVICE*4;\n\tDPRINTK(\"vci 0x%lx,rx 0x%lx, tx 0x%lx,srv 0x%lx,buf 0x%lx\\n\",\n\t     eni_dev->vci,eni_dev->rx_dma,eni_dev->tx_dma,\n\t     eni_dev->service,buf);\n\tspin_lock_init(&eni_dev->lock);\n\ttasklet_init(&eni_dev->task,eni_tasklet,(unsigned long) dev);\n\teni_dev->events = 0;\n\t \n\tbuffer_mem = eni_dev->mem - (buf - eni_dev->ram);\n\teni_dev->free_list_size = buffer_mem/MID_MIN_BUF_SIZE/2;\n\teni_dev->free_list = kmalloc_array(eni_dev->free_list_size + 1,\n\t\t\t\t\t   sizeof(*eni_dev->free_list),\n\t\t\t\t\t   GFP_KERNEL);\n\tif (!eni_dev->free_list) {\n\t\tprintk(KERN_ERR DEV_LABEL \"(itf %d): couldn't get free page\\n\",\n\t\t    dev->number);\n\t\terror = -ENOMEM;\n\t\tgoto free_irq;\n\t}\n\teni_dev->free_len = 0;\n\teni_put_free(eni_dev,buf,buffer_mem);\n\tmemset_io(eni_dev->vci,0,16*NR_VCI);  \n\t \n\teni_out(0xffffffff,MID_IE);\n\terror = start_tx(dev);\n\tif (error) goto free_list;\n\terror = start_rx(dev);\n\tif (error) goto free_list;\n\terror = dev->phy->start(dev);\n\tif (error) goto free_list;\n\teni_out(eni_in(MID_MC_S) | (1 << MID_INT_SEL_SHIFT) |\n\t    MID_TX_LOCK_MODE | MID_DMA_ENABLE | MID_TX_ENABLE | MID_RX_ENABLE,\n\t    MID_MC_S);\n\t     \n\t(void) eni_in(MID_ISA);  \n\treturn 0;\n\nfree_list:\n\tkfree(eni_dev->free_list);\n\nfree_irq:\n\tfree_irq(eni_dev->irq, dev);\n\nout:\n\treturn error;\n}\n\n\nstatic void eni_close(struct atm_vcc *vcc)\n{\n\tDPRINTK(\">eni_close\\n\");\n\tif (!ENI_VCC(vcc)) return;\n\tclear_bit(ATM_VF_READY,&vcc->flags);\n\tclose_rx(vcc);\n\tclose_tx(vcc);\n\tDPRINTK(\"eni_close: done waiting\\n\");\n\t \n\tkfree(ENI_VCC(vcc));\n\tvcc->dev_data = NULL;\n\tclear_bit(ATM_VF_ADDR,&vcc->flags);\n\t \n}\n\n\nstatic int eni_open(struct atm_vcc *vcc)\n{\n\tstruct eni_vcc *eni_vcc;\n\tint error;\n\tshort vpi = vcc->vpi;\n\tint vci = vcc->vci;\n\n\tDPRINTK(\">eni_open\\n\");\n\tEVENT(\"eni_open\\n\",0,0);\n\tif (!test_bit(ATM_VF_PARTIAL,&vcc->flags))\n\t\tvcc->dev_data = NULL;\n\tif (vci != ATM_VPI_UNSPEC && vpi != ATM_VCI_UNSPEC)\n\t\tset_bit(ATM_VF_ADDR,&vcc->flags);\n\tif (vcc->qos.aal != ATM_AAL0 && vcc->qos.aal != ATM_AAL5)\n\t\treturn -EINVAL;\n\tDPRINTK(DEV_LABEL \"(itf %d): open %d.%d\\n\",vcc->dev->number,vcc->vpi,\n\t    vcc->vci);\n\tif (!test_bit(ATM_VF_PARTIAL,&vcc->flags)) {\n\t\teni_vcc = kmalloc(sizeof(struct eni_vcc),GFP_KERNEL);\n\t\tif (!eni_vcc) return -ENOMEM;\n\t\tvcc->dev_data = eni_vcc;\n\t\teni_vcc->tx = NULL;  \n\t\tif ((error = open_rx_first(vcc))) {\n\t\t\teni_close(vcc);\n\t\t\treturn error;\n\t\t}\n\t\tif ((error = open_tx_first(vcc))) {\n\t\t\teni_close(vcc);\n\t\t\treturn error;\n\t\t}\n\t}\n\tif (vci == ATM_VPI_UNSPEC || vpi == ATM_VCI_UNSPEC) return 0;\n\tif ((error = open_rx_second(vcc))) {\n\t\teni_close(vcc);\n\t\treturn error;\n\t}\n\tif ((error = open_tx_second(vcc))) {\n\t\teni_close(vcc);\n\t\treturn error;\n\t}\n\tset_bit(ATM_VF_READY,&vcc->flags);\n\t \n\treturn 0;\n}\n\n\nstatic int eni_change_qos(struct atm_vcc *vcc,struct atm_qos *qos,int flgs)\n{\n\tstruct eni_dev *eni_dev = ENI_DEV(vcc->dev);\n\tstruct eni_tx *tx = ENI_VCC(vcc)->tx;\n\tstruct sk_buff *skb;\n\tint error,rate,rsv,shp;\n\n\tif (qos->txtp.traffic_class == ATM_NONE) return 0;\n\tif (tx == eni_dev->ubr) return -EBADFD;\n\trate = atm_pcr_goal(&qos->txtp);\n\tif (rate < 0) rate = -rate;\n\trsv = shp = 0;\n\tif ((flgs & ATM_MF_DEC_RSV) && rate && rate < tx->reserved) rsv = 1;\n\tif ((flgs & ATM_MF_INC_RSV) && (!rate || rate > tx->reserved)) rsv = 1;\n\tif ((flgs & ATM_MF_DEC_SHP) && rate && rate < tx->shaping) shp = 1;\n\tif ((flgs & ATM_MF_INC_SHP) && (!rate || rate > tx->shaping)) shp = 1;\n\tif (!rsv && !shp) return 0;\n\terror = reserve_or_set_tx(vcc,&qos->txtp,rsv,shp);\n\tif (error) return error;\n\tif (shp && !(flgs & ATM_MF_IMMED)) return 0;\n\t \n\ttasklet_disable(&eni_dev->task);\n\tskb_queue_walk(&eni_dev->tx_queue, skb) {\n\t\tvoid __iomem *dsc;\n\n\t\tif (ATM_SKB(skb)->vcc != vcc) continue;\n\t\tdsc = tx->send+ENI_PRV_POS(skb)*4;\n\t\twritel((readl(dsc) & ~(MID_SEG_RATE | MID_SEG_PR)) |\n\t\t    (tx->prescaler << MID_SEG_PR_SHIFT) |\n\t\t    (tx->resolution << MID_SEG_RATE_SHIFT), dsc);\n\t}\n\ttasklet_enable(&eni_dev->task);\n\treturn 0;\n}\n\n\nstatic int eni_ioctl(struct atm_dev *dev,unsigned int cmd,void __user *arg)\n{\n\tstruct eni_dev *eni_dev = ENI_DEV(dev);\n\n\tif (cmd == ENI_MEMDUMP) {\n\t\tif (!capable(CAP_NET_ADMIN)) return -EPERM;\n\t\tprintk(KERN_WARNING \"Please use /proc/atm/\" DEV_LABEL \":%d \"\n\t\t    \"instead of obsolete ioctl ENI_MEMDUMP\\n\",dev->number);\n\t\tdump(dev);\n\t\treturn 0;\n\t}\n\tif (cmd == ENI_SETMULT) {\n\t\tstruct eni_multipliers mult;\n\n\t\tif (!capable(CAP_NET_ADMIN)) return -EPERM;\n\t\tif (copy_from_user(&mult, arg,\n\t\t    sizeof(struct eni_multipliers)))\n\t\t\treturn -EFAULT;\n\t\tif ((mult.tx && mult.tx <= 100) || (mult.rx &&mult.rx <= 100) ||\n\t\t    mult.tx > 65536 || mult.rx > 65536)\n\t\t\treturn -EINVAL;\n\t\tif (mult.tx) eni_dev->tx_mult = mult.tx;\n\t\tif (mult.rx) eni_dev->rx_mult = mult.rx;\n\t\treturn 0;\n\t}\n\tif (cmd == ATM_SETCIRANGE) {\n\t\tstruct atm_cirange ci;\n\n\t\tif (copy_from_user(&ci, arg,sizeof(struct atm_cirange)))\n\t\t\treturn -EFAULT;\n\t\tif ((ci.vpi_bits == 0 || ci.vpi_bits == ATM_CI_MAX) &&\n\t\t    (ci.vci_bits == NR_VCI_LD || ci.vpi_bits == ATM_CI_MAX))\n\t\t    return 0;\n\t\treturn -EINVAL;\n\t}\n\tif (!dev->phy->ioctl) return -ENOIOCTLCMD;\n\treturn dev->phy->ioctl(dev,cmd,arg);\n}\n\nstatic int eni_send(struct atm_vcc *vcc,struct sk_buff *skb)\n{\n\tenum enq_res res;\n\n\tDPRINTK(\">eni_send\\n\");\n\tif (!ENI_VCC(vcc)->tx) {\n\t\tif (vcc->pop) vcc->pop(vcc,skb);\n\t\telse dev_kfree_skb(skb);\n\t\treturn -EINVAL;\n\t}\n\tif (!skb) {\n\t\tprintk(KERN_CRIT \"!skb in eni_send ?\\n\");\n\t\tif (vcc->pop) vcc->pop(vcc,skb);\n\t\treturn -EINVAL;\n\t}\n\tif (vcc->qos.aal == ATM_AAL0) {\n\t\tif (skb->len != ATM_CELL_SIZE-1) {\n\t\t\tif (vcc->pop) vcc->pop(vcc,skb);\n\t\t\telse dev_kfree_skb(skb);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t*(u32 *) skb->data = htonl(*(u32 *) skb->data);\n\t}\n\tsubmitted++;\n\tATM_SKB(skb)->vcc = vcc;\n\ttasklet_disable_in_atomic(&ENI_DEV(vcc->dev)->task);\n\tres = do_tx(skb);\n\ttasklet_enable(&ENI_DEV(vcc->dev)->task);\n\tif (res == enq_ok) return 0;\n\tskb_queue_tail(&ENI_VCC(vcc)->tx->backlog,skb);\n\tbacklogged++;\n\ttasklet_schedule(&ENI_DEV(vcc->dev)->task);\n\treturn 0;\n}\n\nstatic void eni_phy_put(struct atm_dev *dev,unsigned char value,\n    unsigned long addr)\n{\n\twritel(value,ENI_DEV(dev)->phy+addr*4);\n}\n\n\n\nstatic unsigned char eni_phy_get(struct atm_dev *dev,unsigned long addr)\n{\n\treturn readl(ENI_DEV(dev)->phy+addr*4);\n}\n\n\nstatic int eni_proc_read(struct atm_dev *dev,loff_t *pos,char *page)\n{\n\tstruct sock *s;\n\tstatic const char *signal[] = { \"LOST\",\"unknown\",\"okay\" };\n\tstruct eni_dev *eni_dev = ENI_DEV(dev);\n\tstruct atm_vcc *vcc;\n\tint left,i;\n\n\tleft = *pos;\n\tif (!left)\n\t\treturn sprintf(page,DEV_LABEL \"(itf %d) signal %s, %dkB, \"\n\t\t    \"%d cps remaining\\n\",dev->number,signal[(int) dev->signal],\n\t\t    eni_dev->mem >> 10,eni_dev->tx_bw);\n\tif (!--left)\n\t\treturn sprintf(page,\"%4sBursts: TX\"\n#if !defined(CONFIG_ATM_ENI_BURST_TX_16W) && \\\n    !defined(CONFIG_ATM_ENI_BURST_TX_8W) && \\\n    !defined(CONFIG_ATM_ENI_BURST_TX_4W) && \\\n    !defined(CONFIG_ATM_ENI_BURST_TX_2W)\n\t\t    \" none\"\n#endif\n#ifdef CONFIG_ATM_ENI_BURST_TX_16W\n\t\t    \" 16W\"\n#endif\n#ifdef CONFIG_ATM_ENI_BURST_TX_8W\n\t\t    \" 8W\"\n#endif\n#ifdef CONFIG_ATM_ENI_BURST_TX_4W\n\t\t    \" 4W\"\n#endif\n#ifdef CONFIG_ATM_ENI_BURST_TX_2W\n\t\t    \" 2W\"\n#endif\n\t\t    \", RX\"\n#if !defined(CONFIG_ATM_ENI_BURST_RX_16W) && \\\n    !defined(CONFIG_ATM_ENI_BURST_RX_8W) && \\\n    !defined(CONFIG_ATM_ENI_BURST_RX_4W) && \\\n    !defined(CONFIG_ATM_ENI_BURST_RX_2W)\n\t\t    \" none\"\n#endif\n#ifdef CONFIG_ATM_ENI_BURST_RX_16W\n\t\t    \" 16W\"\n#endif\n#ifdef CONFIG_ATM_ENI_BURST_RX_8W\n\t\t    \" 8W\"\n#endif\n#ifdef CONFIG_ATM_ENI_BURST_RX_4W\n\t\t    \" 4W\"\n#endif\n#ifdef CONFIG_ATM_ENI_BURST_RX_2W\n\t\t    \" 2W\"\n#endif\n#ifndef CONFIG_ATM_ENI_TUNE_BURST\n\t\t    \" (default)\"\n#endif\n\t\t    \"\\n\",\"\");\n\tif (!--left) \n\t\treturn sprintf(page,\"%4sBuffer multipliers: tx %d%%, rx %d%%\\n\",\n\t\t    \"\",eni_dev->tx_mult,eni_dev->rx_mult);\n\tfor (i = 0; i < NR_CHAN; i++) {\n\t\tstruct eni_tx *tx = eni_dev->tx+i;\n\n\t\tif (!tx->send) continue;\n\t\tif (!--left) {\n\t\t\treturn sprintf(page, \"tx[%d]:    0x%lx-0x%lx \"\n\t\t\t    \"(%6ld bytes), rsv %d cps, shp %d cps%s\\n\",i,\n\t\t\t    (unsigned long) (tx->send - eni_dev->ram),\n\t\t\t    tx->send-eni_dev->ram+tx->words*4-1,tx->words*4,\n\t\t\t    tx->reserved,tx->shaping,\n\t\t\t    tx == eni_dev->ubr ? \" (UBR)\" : \"\");\n\t\t}\n\t\tif (--left) continue;\n\t\treturn sprintf(page,\"%10sbacklog %u packets\\n\",\"\",\n\t\t    skb_queue_len(&tx->backlog));\n\t}\n\tread_lock(&vcc_sklist_lock);\n\tfor(i = 0; i < VCC_HTABLE_SIZE; ++i) {\n\t\tstruct hlist_head *head = &vcc_hash[i];\n\n\t\tsk_for_each(s, head) {\n\t\t\tstruct eni_vcc *eni_vcc;\n\t\t\tint length;\n\n\t\t\tvcc = atm_sk(s);\n\t\t\tif (vcc->dev != dev)\n\t\t\t\tcontinue;\n\t\t\teni_vcc = ENI_VCC(vcc);\n\t\t\tif (--left) continue;\n\t\t\tlength = sprintf(page,\"vcc %4d: \",vcc->vci);\n\t\t\tif (eni_vcc->rx) {\n\t\t\t\tlength += sprintf(page+length, \"0x%lx-0x%lx \"\n\t\t\t\t    \"(%6ld bytes)\",\n\t\t\t\t    (unsigned long) (eni_vcc->recv - eni_dev->ram),\n\t\t\t\t    eni_vcc->recv-eni_dev->ram+eni_vcc->words*4-1,\n\t\t\t\t    eni_vcc->words*4);\n\t\t\t\tif (eni_vcc->tx) length += sprintf(page+length,\", \");\n\t\t\t}\n\t\t\tif (eni_vcc->tx)\n\t\t\t\tlength += sprintf(page+length,\"tx[%d], txing %d bytes\",\n\t\t\t\t    eni_vcc->tx->index,eni_vcc->txing);\n\t\t\tpage[length] = '\\n';\n\t\t\tread_unlock(&vcc_sklist_lock);\n\t\t\treturn length+1;\n\t\t}\n\t}\n\tread_unlock(&vcc_sklist_lock);\n\tfor (i = 0; i < eni_dev->free_len; i++) {\n\t\tstruct eni_free *fe = eni_dev->free_list+i;\n\t\tunsigned long offset;\n\n\t\tif (--left) continue;\n\t\toffset = (unsigned long) eni_dev->ram+eni_dev->base_diff;\n\t\treturn sprintf(page,\"free      %p-%p (%6d bytes)\\n\",\n\t\t    fe->start-offset,fe->start-offset+(1 << fe->order)-1,\n\t\t    1 << fe->order);\n\t}\n\treturn 0;\n}\n\n\nstatic const struct atmdev_ops ops = {\n\t.open\t\t= eni_open,\n\t.close\t\t= eni_close,\n\t.ioctl\t\t= eni_ioctl,\n\t.send\t\t= eni_send,\n\t.phy_put\t= eni_phy_put,\n\t.phy_get\t= eni_phy_get,\n\t.change_qos\t= eni_change_qos,\n\t.proc_read\t= eni_proc_read\n};\n\n\nstatic int eni_init_one(struct pci_dev *pci_dev,\n\t\t\tconst struct pci_device_id *ent)\n{\n\tstruct atm_dev *dev;\n\tstruct eni_dev *eni_dev;\n\tstruct eni_zero *zero;\n\tint rc;\n\n\trc = pci_enable_device(pci_dev);\n\tif (rc < 0)\n\t\tgoto out;\n\n\trc = dma_set_mask_and_coherent(&pci_dev->dev, DMA_BIT_MASK(32));\n\tif (rc < 0)\n\t\tgoto err_disable;\n\n\trc = -ENOMEM;\n\teni_dev = kmalloc(sizeof(struct eni_dev), GFP_KERNEL);\n\tif (!eni_dev)\n\t\tgoto err_disable;\n\n\tzero = &eni_dev->zero;\n\tzero->addr = dma_alloc_coherent(&pci_dev->dev,\n\t\t\t\t\tENI_ZEROES_SIZE, &zero->dma, GFP_KERNEL);\n\tif (!zero->addr)\n\t\tgoto err_kfree;\n\n\tdev = atm_dev_register(DEV_LABEL, &pci_dev->dev, &ops, -1, NULL);\n\tif (!dev)\n\t\tgoto err_free_consistent;\n\n\tdev->dev_data = eni_dev;\n\tpci_set_drvdata(pci_dev, dev);\n\teni_dev->pci_dev = pci_dev;\n\teni_dev->asic = ent->driver_data;\n\n\trc = eni_do_init(dev);\n\tif (rc < 0)\n\t\tgoto err_unregister;\n\n\trc = eni_start(dev);\n\tif (rc < 0)\n\t\tgoto err_eni_release;\n\n\teni_dev->more = eni_boards;\n\teni_boards = dev;\nout:\n\treturn rc;\n\nerr_eni_release:\n\tdev->phy = NULL;\n\tiounmap(ENI_DEV(dev)->ioaddr);\nerr_unregister:\n\tatm_dev_deregister(dev);\nerr_free_consistent:\n\tdma_free_coherent(&pci_dev->dev, ENI_ZEROES_SIZE, zero->addr, zero->dma);\nerr_kfree:\n\tkfree(eni_dev);\nerr_disable:\n\tpci_disable_device(pci_dev);\n\tgoto out;\n}\n\n\nstatic const struct pci_device_id eni_pci_tbl[] = {\n\t{ PCI_VDEVICE(EF, PCI_DEVICE_ID_EF_ATM_FPGA), 0   },\n\t{ PCI_VDEVICE(EF, PCI_DEVICE_ID_EF_ATM_ASIC), 1   },\n\t{ 0, }\n};\nMODULE_DEVICE_TABLE(pci,eni_pci_tbl);\n\n\nstatic void eni_remove_one(struct pci_dev *pdev)\n{\n\tstruct atm_dev *dev = pci_get_drvdata(pdev);\n\tstruct eni_dev *ed = ENI_DEV(dev);\n\tstruct eni_zero *zero = &ed->zero;\n\n\teni_do_release(dev);\n\tatm_dev_deregister(dev);\n\tdma_free_coherent(&pdev->dev, ENI_ZEROES_SIZE, zero->addr, zero->dma);\n\tkfree(ed);\n\tpci_disable_device(pdev);\n}\n\n\nstatic struct pci_driver eni_driver = {\n\t.name\t\t= DEV_LABEL,\n\t.id_table\t= eni_pci_tbl,\n\t.probe\t\t= eni_init_one,\n\t.remove\t\t= eni_remove_one,\n};\n\n\nstatic int __init eni_init(void)\n{\n\tstruct sk_buff *skb;  \n\n\tBUILD_BUG_ON(sizeof(skb->cb) < sizeof(struct eni_skb_prv));\n\treturn pci_register_driver(&eni_driver);\n}\n\n\nmodule_init(eni_init);\n \n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}