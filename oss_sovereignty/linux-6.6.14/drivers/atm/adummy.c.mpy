{
  "module_name": "adummy.c",
  "hash_id": "98d92541665759bc13fb3e510ddbe34d5139ccd8489788062f015baa5670eb6d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/atm/adummy.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/skbuff.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/timer.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <asm/io.h>\n#include <asm/byteorder.h>\n#include <linux/uaccess.h>\n\n#include <linux/atmdev.h>\n#include <linux/atm.h>\n#include <linux/sonet.h>\n\n \n\n#define DRV_VERSION \"1.0\"\n\n#define DEV_LABEL \"adummy\"\n\n#define ADUMMY_DEV(dev) ((struct adummy_dev *) (dev)->dev_data)\n\nstruct adummy_dev {\n\tstruct atm_dev *atm_dev;\n\n\tstruct list_head entry;\n};\n\n \n\nstatic LIST_HEAD(adummy_devs);\n\nstatic ssize_t __set_signal(struct device *dev,\n\t\tstruct device_attribute *attr,\n\t\tconst char *buf, size_t len)\n{\n\tstruct atm_dev *atm_dev = container_of(dev, struct atm_dev, class_dev);\n\tint signal;\n\n\tif (sscanf(buf, \"%d\", &signal) == 1) {\n\n\t\tif (signal < ATM_PHY_SIG_LOST || signal > ATM_PHY_SIG_FOUND)\n\t\t\tsignal = ATM_PHY_SIG_UNKNOWN;\n\n\t\tatm_dev_signal_change(atm_dev, signal);\n\t\treturn 1;\n\t}\n\treturn -EINVAL;\n}\n\nstatic ssize_t __show_signal(struct device *dev,\n\tstruct device_attribute *attr, char *buf)\n{\n\tstruct atm_dev *atm_dev = container_of(dev, struct atm_dev, class_dev);\n\treturn sprintf(buf, \"%d\\n\", atm_dev->signal);\n}\nstatic DEVICE_ATTR(signal, 0644, __show_signal, __set_signal);\n\nstatic struct attribute *adummy_attrs[] = {\n\t&dev_attr_signal.attr,\n\tNULL\n};\n\nstatic const struct attribute_group adummy_group_attrs = {\n\t.name = NULL,  \n\t.attrs = adummy_attrs\n};\n\nstatic int __init\nadummy_start(struct atm_dev *dev)\n{\n\tdev->ci_range.vpi_bits = 4;\n\tdev->ci_range.vci_bits = 12;\n\n\treturn 0;\n}\n\nstatic int\nadummy_open(struct atm_vcc *vcc)\n{\n\tshort vpi = vcc->vpi;\n\tint vci = vcc->vci;\n\n\tif (vci == ATM_VCI_UNSPEC || vpi == ATM_VPI_UNSPEC)\n\t\treturn 0;\n\n\tset_bit(ATM_VF_ADDR, &vcc->flags);\n\tset_bit(ATM_VF_READY, &vcc->flags);\n\n\treturn 0;\n}\n\nstatic void\nadummy_close(struct atm_vcc *vcc)\n{\n\tclear_bit(ATM_VF_READY, &vcc->flags);\n\tclear_bit(ATM_VF_ADDR, &vcc->flags);\n}\n\nstatic int\nadummy_send(struct atm_vcc *vcc, struct sk_buff *skb)\n{\n\tif (vcc->pop)\n\t\tvcc->pop(vcc, skb);\n\telse\n\t\tdev_kfree_skb_any(skb);\n\tatomic_inc(&vcc->stats->tx);\n\n\treturn 0;\n}\n\nstatic int\nadummy_proc_read(struct atm_dev *dev, loff_t *pos, char *page)\n{\n\tint left = *pos;\n\n\tif (!left--)\n\t\treturn sprintf(page, \"version %s\\n\", DRV_VERSION);\n\n\treturn 0;\n}\n\nstatic const struct atmdev_ops adummy_ops =\n{\n\t.open =\t\tadummy_open,\n\t.close =\tadummy_close,\t\n\t.send =\t\tadummy_send,\n\t.proc_read =\tadummy_proc_read,\n\t.owner =\tTHIS_MODULE\n};\n\nstatic int __init adummy_init(void)\n{\n\tstruct atm_dev *atm_dev;\n\tstruct adummy_dev *adummy_dev;\n\tint err = 0;\n\n\tprintk(KERN_ERR \"adummy: version %s\\n\", DRV_VERSION);\n\n\tadummy_dev = kzalloc(sizeof(struct adummy_dev),\n\t\t\t\t\t\t   GFP_KERNEL);\n\tif (!adummy_dev) {\n\t\tprintk(KERN_ERR DEV_LABEL \": kzalloc() failed\\n\");\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\tatm_dev = atm_dev_register(DEV_LABEL, NULL, &adummy_ops, -1, NULL);\n\tif (!atm_dev) {\n\t\tprintk(KERN_ERR DEV_LABEL \": atm_dev_register() failed\\n\");\n\t\terr = -ENODEV;\n\t\tgoto out_kfree;\n\t}\n\n\tadummy_dev->atm_dev = atm_dev;\n\tatm_dev->dev_data = adummy_dev;\n\n\tif (sysfs_create_group(&atm_dev->class_dev.kobj, &adummy_group_attrs))\n\t\tdev_err(&atm_dev->class_dev, \"Could not register attrs for adummy\\n\");\n\n\tif (adummy_start(atm_dev)) {\n\t\tprintk(KERN_ERR DEV_LABEL \": adummy_start() failed\\n\");\n\t\terr = -ENODEV;\n\t\tgoto out_unregister;\n\t}\n\n\tlist_add(&adummy_dev->entry, &adummy_devs);\nout:\n\treturn err;\n\nout_unregister:\n\tatm_dev_deregister(atm_dev);\nout_kfree:\n\tkfree(adummy_dev);\n\tgoto out;\n}\n\nstatic void __exit adummy_cleanup(void)\n{\n\tstruct adummy_dev *adummy_dev, *next;\n\n\tlist_for_each_entry_safe(adummy_dev, next, &adummy_devs, entry) {\n\t\tatm_dev_deregister(adummy_dev->atm_dev);\n\t\tkfree(adummy_dev);\n\t}\n}\n\nmodule_init(adummy_init);\nmodule_exit(adummy_cleanup);\n\nMODULE_AUTHOR(\"chas williams <chas@cmf.nrl.navy.mil>\");\nMODULE_DESCRIPTION(\"dummy ATM driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}