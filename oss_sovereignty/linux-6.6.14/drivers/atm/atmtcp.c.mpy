{
  "module_name": "atmtcp.c",
  "hash_id": "d23505642a77257ded25b6927c4ce1ccc400aa292e9b2ee9d1c63587b7f9669d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/atm/atmtcp.c",
  "human_readable_source": "\n \n\n \n\n\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/atmdev.h>\n#include <linux/atm_tcp.h>\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/atomic.h>\n\n\nextern int atm_init_aal5(struct atm_vcc *vcc);  \n\n\n#define PRIV(dev) ((struct atmtcp_dev_data *) ((dev)->dev_data))\n\n\nstruct atmtcp_dev_data {\n\tstruct atm_vcc *vcc;\t \n\tint persist;\t\t \n};\n\n\n#define DEV_LABEL    \"atmtcp\"\n\n#define MAX_VPI_BITS  8\t \n#define MAX_VCI_BITS 16\n\n\n \n\n\nstatic int atmtcp_send_control(struct atm_vcc *vcc,int type,\n    const struct atmtcp_control *msg,int flag)\n{\n\tDECLARE_WAITQUEUE(wait,current);\n\tstruct atm_vcc *out_vcc;\n\tstruct sk_buff *skb;\n\tstruct atmtcp_control *new_msg;\n\tint old_test;\n\tint error = 0;\n\n\tout_vcc = PRIV(vcc->dev) ? PRIV(vcc->dev)->vcc : NULL;\n\tif (!out_vcc) return -EUNATCH;\n\tskb = alloc_skb(sizeof(*msg),GFP_KERNEL);\n\tif (!skb) return -ENOMEM;\n\tmb();\n\tout_vcc = PRIV(vcc->dev) ? PRIV(vcc->dev)->vcc : NULL;\n\tif (!out_vcc) {\n\t\tdev_kfree_skb(skb);\n\t\treturn -EUNATCH;\n\t}\n\tatm_force_charge(out_vcc,skb->truesize);\n\tnew_msg = skb_put(skb, sizeof(*new_msg));\n\t*new_msg = *msg;\n\tnew_msg->hdr.length = ATMTCP_HDR_MAGIC;\n\tnew_msg->type = type;\n\tmemset(&new_msg->vcc,0,sizeof(atm_kptr_t));\n\t*(struct atm_vcc **) &new_msg->vcc = vcc;\n\told_test = test_bit(flag,&vcc->flags);\n\tout_vcc->push(out_vcc,skb);\n\tadd_wait_queue(sk_sleep(sk_atm(vcc)), &wait);\n\twhile (test_bit(flag,&vcc->flags) == old_test) {\n\t\tmb();\n\t\tout_vcc = PRIV(vcc->dev) ? PRIV(vcc->dev)->vcc : NULL;\n\t\tif (!out_vcc) {\n\t\t\terror = -EUNATCH;\n\t\t\tbreak;\n\t\t}\n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\tschedule();\n\t}\n\tset_current_state(TASK_RUNNING);\n\tremove_wait_queue(sk_sleep(sk_atm(vcc)), &wait);\n\treturn error;\n}\n\n\nstatic int atmtcp_recv_control(const struct atmtcp_control *msg)\n{\n\tstruct atm_vcc *vcc = *(struct atm_vcc **) &msg->vcc;\n\n\tvcc->vpi = msg->addr.sap_addr.vpi;\n\tvcc->vci = msg->addr.sap_addr.vci;\n\tvcc->qos = msg->qos;\n\tsk_atm(vcc)->sk_err = -msg->result;\n\tswitch (msg->type) {\n\t    case ATMTCP_CTRL_OPEN:\n\t\tchange_bit(ATM_VF_READY,&vcc->flags);\n\t\tbreak;\n\t    case ATMTCP_CTRL_CLOSE:\n\t\tchange_bit(ATM_VF_ADDR,&vcc->flags);\n\t\tbreak;\n\t    default:\n\t\tprintk(KERN_ERR \"atmtcp_recv_control: unknown type %d\\n\",\n\t\t    msg->type);\n\t\treturn -EINVAL;\n\t}\n\twake_up(sk_sleep(sk_atm(vcc)));\n\treturn 0;\n}\n\n\nstatic void atmtcp_v_dev_close(struct atm_dev *dev)\n{\n\t \n}\n\n\nstatic int atmtcp_v_open(struct atm_vcc *vcc)\n{\n\tstruct atmtcp_control msg;\n\tint error;\n\tshort vpi = vcc->vpi;\n\tint vci = vcc->vci;\n\n\tmemset(&msg,0,sizeof(msg));\n\tmsg.addr.sap_family = AF_ATMPVC;\n\tmsg.hdr.vpi = htons(vpi);\n\tmsg.addr.sap_addr.vpi = vpi;\n\tmsg.hdr.vci = htons(vci);\n\tmsg.addr.sap_addr.vci = vci;\n\tif (vpi == ATM_VPI_UNSPEC || vci == ATM_VCI_UNSPEC) return 0;\n\tmsg.type = ATMTCP_CTRL_OPEN;\n\tmsg.qos = vcc->qos;\n\tset_bit(ATM_VF_ADDR,&vcc->flags);\n\tclear_bit(ATM_VF_READY,&vcc->flags);  \n\terror = atmtcp_send_control(vcc,ATMTCP_CTRL_OPEN,&msg,ATM_VF_READY);\n\tif (error) return error;\n\treturn -sk_atm(vcc)->sk_err;\n}\n\n\nstatic void atmtcp_v_close(struct atm_vcc *vcc)\n{\n\tstruct atmtcp_control msg;\n\n\tmemset(&msg,0,sizeof(msg));\n\tmsg.addr.sap_family = AF_ATMPVC;\n\tmsg.addr.sap_addr.vpi = vcc->vpi;\n\tmsg.addr.sap_addr.vci = vcc->vci;\n\tclear_bit(ATM_VF_READY,&vcc->flags);\n\t(void) atmtcp_send_control(vcc,ATMTCP_CTRL_CLOSE,&msg,ATM_VF_ADDR);\n}\n\n\nstatic int atmtcp_v_ioctl(struct atm_dev *dev,unsigned int cmd,void __user *arg)\n{\n\tstruct atm_cirange ci;\n\tstruct atm_vcc *vcc;\n\tstruct sock *s;\n\tint i;\n\n\tif (cmd != ATM_SETCIRANGE) return -ENOIOCTLCMD;\n\tif (copy_from_user(&ci, arg,sizeof(ci))) return -EFAULT;\n\tif (ci.vpi_bits == ATM_CI_MAX) ci.vpi_bits = MAX_VPI_BITS;\n\tif (ci.vci_bits == ATM_CI_MAX) ci.vci_bits = MAX_VCI_BITS;\n\tif (ci.vpi_bits > MAX_VPI_BITS || ci.vpi_bits < 0 ||\n\t    ci.vci_bits > MAX_VCI_BITS || ci.vci_bits < 0) return -EINVAL;\n\tread_lock(&vcc_sklist_lock);\n\tfor(i = 0; i < VCC_HTABLE_SIZE; ++i) {\n\t\tstruct hlist_head *head = &vcc_hash[i];\n\n\t\tsk_for_each(s, head) {\n\t\t\tvcc = atm_sk(s);\n\t\t\tif (vcc->dev != dev)\n\t\t\t\tcontinue;\n\t\t\tif ((vcc->vpi >> ci.vpi_bits) ||\n\t\t\t    (vcc->vci >> ci.vci_bits)) {\n\t\t\t\tread_unlock(&vcc_sklist_lock);\n\t\t\t\treturn -EBUSY;\n\t\t\t}\n\t\t}\n\t}\n\tread_unlock(&vcc_sklist_lock);\n\tdev->ci_range = ci;\n\treturn 0;\n}\n\n\nstatic int atmtcp_v_send(struct atm_vcc *vcc,struct sk_buff *skb)\n{\n\tstruct atmtcp_dev_data *dev_data;\n\tstruct atm_vcc *out_vcc=NULL;  \n\tstruct sk_buff *new_skb;\n\tstruct atmtcp_hdr *hdr;\n\tint size;\n\n\tif (vcc->qos.txtp.traffic_class == ATM_NONE) {\n\t\tif (vcc->pop) vcc->pop(vcc,skb);\n\t\telse dev_kfree_skb(skb);\n\t\treturn -EINVAL;\n\t}\n\tdev_data = PRIV(vcc->dev);\n\tif (dev_data) out_vcc = dev_data->vcc;\n\tif (!dev_data || !out_vcc) {\n\t\tif (vcc->pop) vcc->pop(vcc,skb);\n\t\telse dev_kfree_skb(skb);\n\t\tif (dev_data) return 0;\n\t\tatomic_inc(&vcc->stats->tx_err);\n\t\treturn -ENOLINK;\n\t}\n\tsize = skb->len+sizeof(struct atmtcp_hdr);\n\tnew_skb = atm_alloc_charge(out_vcc,size,GFP_ATOMIC);\n\tif (!new_skb) {\n\t\tif (vcc->pop) vcc->pop(vcc,skb);\n\t\telse dev_kfree_skb(skb);\n\t\tatomic_inc(&vcc->stats->tx_err);\n\t\treturn -ENOBUFS;\n\t}\n\thdr = skb_put(new_skb, sizeof(struct atmtcp_hdr));\n\thdr->vpi = htons(vcc->vpi);\n\thdr->vci = htons(vcc->vci);\n\thdr->length = htonl(skb->len);\n\tskb_copy_from_linear_data(skb, skb_put(new_skb, skb->len), skb->len);\n\tif (vcc->pop) vcc->pop(vcc,skb);\n\telse dev_kfree_skb(skb);\n\tout_vcc->push(out_vcc,new_skb);\n\tatomic_inc(&vcc->stats->tx);\n\tatomic_inc(&out_vcc->stats->rx);\n\treturn 0;\n}\n\n\nstatic int atmtcp_v_proc(struct atm_dev *dev,loff_t *pos,char *page)\n{\n\tstruct atmtcp_dev_data *dev_data = PRIV(dev);\n\n\tif (*pos) return 0;\n\tif (!dev_data->persist) return sprintf(page,\"ephemeral\\n\");\n\treturn sprintf(page,\"persistent, %sconnected\\n\",\n\t    dev_data->vcc ? \"\" : \"dis\");\n}\n\n\nstatic void atmtcp_c_close(struct atm_vcc *vcc)\n{\n\tstruct atm_dev *atmtcp_dev;\n\tstruct atmtcp_dev_data *dev_data;\n\n\tatmtcp_dev = (struct atm_dev *) vcc->dev_data;\n\tdev_data = PRIV(atmtcp_dev);\n\tdev_data->vcc = NULL;\n\tif (dev_data->persist) return;\n\tatmtcp_dev->dev_data = NULL;\n\tkfree(dev_data);\n\tatm_dev_deregister(atmtcp_dev);\n\tvcc->dev_data = NULL;\n\tmodule_put(THIS_MODULE);\n}\n\n\nstatic struct atm_vcc *find_vcc(struct atm_dev *dev, short vpi, int vci)\n{\n        struct hlist_head *head;\n        struct atm_vcc *vcc;\n        struct sock *s;\n\n        head = &vcc_hash[vci & (VCC_HTABLE_SIZE -1)];\n\n\tsk_for_each(s, head) {\n                vcc = atm_sk(s);\n                if (vcc->dev == dev &&\n                    vcc->vci == vci && vcc->vpi == vpi &&\n                    vcc->qos.rxtp.traffic_class != ATM_NONE) {\n                                return vcc;\n                }\n        }\n        return NULL;\n}\n\n\nstatic int atmtcp_c_send(struct atm_vcc *vcc,struct sk_buff *skb)\n{\n\tstruct atm_dev *dev;\n\tstruct atmtcp_hdr *hdr;\n\tstruct atm_vcc *out_vcc;\n\tstruct sk_buff *new_skb;\n\tint result = 0;\n\n\tif (!skb->len) return 0;\n\tdev = vcc->dev_data;\n\thdr = (struct atmtcp_hdr *) skb->data;\n\tif (hdr->length == ATMTCP_HDR_MAGIC) {\n\t\tresult = atmtcp_recv_control(\n\t\t    (struct atmtcp_control *) skb->data);\n\t\tgoto done;\n\t}\n\tread_lock(&vcc_sklist_lock);\n\tout_vcc = find_vcc(dev, ntohs(hdr->vpi), ntohs(hdr->vci));\n\tread_unlock(&vcc_sklist_lock);\n\tif (!out_vcc) {\n\t\tresult = -EUNATCH;\n\t\tatomic_inc(&vcc->stats->tx_err);\n\t\tgoto done;\n\t}\n\tskb_pull(skb,sizeof(struct atmtcp_hdr));\n\tnew_skb = atm_alloc_charge(out_vcc,skb->len,GFP_KERNEL);\n\tif (!new_skb) {\n\t\tresult = -ENOBUFS;\n\t\tgoto done;\n\t}\n\t__net_timestamp(new_skb);\n\tskb_copy_from_linear_data(skb, skb_put(new_skb, skb->len), skb->len);\n\tout_vcc->push(out_vcc,new_skb);\n\tatomic_inc(&vcc->stats->tx);\n\tatomic_inc(&out_vcc->stats->rx);\ndone:\n\tif (vcc->pop) vcc->pop(vcc,skb);\n\telse dev_kfree_skb(skb);\n\treturn result;\n}\n\n\n \n\n\nstatic const struct atmdev_ops atmtcp_v_dev_ops = {\n\t.dev_close\t= atmtcp_v_dev_close,\n\t.open\t\t= atmtcp_v_open,\n\t.close\t\t= atmtcp_v_close,\n\t.ioctl\t\t= atmtcp_v_ioctl,\n\t.send\t\t= atmtcp_v_send,\n\t.proc_read\t= atmtcp_v_proc,\n\t.owner\t\t= THIS_MODULE\n};\n\n\n \n\n\nstatic const struct atmdev_ops atmtcp_c_dev_ops = {\n\t.close\t\t= atmtcp_c_close,\n\t.send\t\t= atmtcp_c_send\n};\n\n\nstatic struct atm_dev atmtcp_control_dev = {\n\t.ops\t\t= &atmtcp_c_dev_ops,\n\t.type\t\t= \"atmtcp\",\n\t.number\t\t= 999,\n\t.lock\t\t= __SPIN_LOCK_UNLOCKED(atmtcp_control_dev.lock)\n};\n\n\nstatic int atmtcp_create(int itf,int persist,struct atm_dev **result)\n{\n\tstruct atmtcp_dev_data *dev_data;\n\tstruct atm_dev *dev;\n\n\tdev_data = kmalloc(sizeof(*dev_data),GFP_KERNEL);\n\tif (!dev_data)\n\t\treturn -ENOMEM;\n\n\tdev = atm_dev_register(DEV_LABEL,NULL,&atmtcp_v_dev_ops,itf,NULL);\n\tif (!dev) {\n\t\tkfree(dev_data);\n\t\treturn itf == -1 ? -ENOMEM : -EBUSY;\n\t}\n\tdev->ci_range.vpi_bits = MAX_VPI_BITS;\n\tdev->ci_range.vci_bits = MAX_VCI_BITS;\n\tdev->dev_data = dev_data;\n\tPRIV(dev)->vcc = NULL;\n\tPRIV(dev)->persist = persist;\n\tif (result) *result = dev;\n\treturn 0;\n}\n\n\nstatic int atmtcp_attach(struct atm_vcc *vcc,int itf)\n{\n\tstruct atm_dev *dev;\n\n\tdev = NULL;\n\tif (itf != -1) dev = atm_dev_lookup(itf);\n\tif (dev) {\n\t\tif (dev->ops != &atmtcp_v_dev_ops) {\n\t\t\tatm_dev_put(dev);\n\t\t\treturn -EMEDIUMTYPE;\n\t\t}\n\t\tif (PRIV(dev)->vcc) {\n\t\t\tatm_dev_put(dev);\n\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\telse {\n\t\tint error;\n\n\t\terror = atmtcp_create(itf,0,&dev);\n\t\tif (error) return error;\n\t}\n\tPRIV(dev)->vcc = vcc;\n\tvcc->dev = &atmtcp_control_dev;\n\tvcc_insert_socket(sk_atm(vcc));\n\tset_bit(ATM_VF_META,&vcc->flags);\n\tset_bit(ATM_VF_READY,&vcc->flags);\n\tvcc->dev_data = dev;\n\t(void) atm_init_aal5(vcc);  \n\tvcc->stats = &atmtcp_control_dev.stats.aal5;\n\treturn dev->number;\n}\n\n\nstatic int atmtcp_create_persistent(int itf)\n{\n\treturn atmtcp_create(itf,1,NULL);\n}\n\n\nstatic int atmtcp_remove_persistent(int itf)\n{\n\tstruct atm_dev *dev;\n\tstruct atmtcp_dev_data *dev_data;\n\n\tdev = atm_dev_lookup(itf);\n\tif (!dev) return -ENODEV;\n\tif (dev->ops != &atmtcp_v_dev_ops) {\n\t\tatm_dev_put(dev);\n\t\treturn -EMEDIUMTYPE;\n\t}\n\tdev_data = PRIV(dev);\n\tif (!dev_data->persist) {\n\t\tatm_dev_put(dev);\n\t\treturn 0;\n\t}\n\tdev_data->persist = 0;\n\tif (PRIV(dev)->vcc) {\n\t\tatm_dev_put(dev);\n\t\treturn 0;\n\t}\n\tkfree(dev_data);\n\tatm_dev_put(dev);\n\tatm_dev_deregister(dev);\n\treturn 0;\n}\n\nstatic int atmtcp_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg)\n{\n\tint err = 0;\n\tstruct atm_vcc *vcc = ATM_SD(sock);\n\n\tif (cmd != SIOCSIFATMTCP && cmd != ATMTCP_CREATE && cmd != ATMTCP_REMOVE)\n\t\treturn -ENOIOCTLCMD;\n\n\tif (!capable(CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tswitch (cmd) {\n\t\tcase SIOCSIFATMTCP:\n\t\t\terr = atmtcp_attach(vcc, (int) arg);\n\t\t\tif (err >= 0) {\n\t\t\t\tsock->state = SS_CONNECTED;\n\t\t\t\t__module_get(THIS_MODULE);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase ATMTCP_CREATE:\n\t\t\terr = atmtcp_create_persistent((int) arg);\n\t\t\tbreak;\n\t\tcase ATMTCP_REMOVE:\n\t\t\terr = atmtcp_remove_persistent((int) arg);\n\t\t\tbreak;\n\t}\n\treturn err;\n}\n\nstatic struct atm_ioctl atmtcp_ioctl_ops = {\n\t.owner \t= THIS_MODULE,\n\t.ioctl\t= atmtcp_ioctl,\n};\n\nstatic __init int atmtcp_init(void)\n{\n\tregister_atm_ioctl(&atmtcp_ioctl_ops);\n\treturn 0;\n}\n\n\nstatic void __exit atmtcp_exit(void)\n{\n\tderegister_atm_ioctl(&atmtcp_ioctl_ops);\n}\n\nMODULE_LICENSE(\"GPL\");\nmodule_init(atmtcp_init);\nmodule_exit(atmtcp_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}