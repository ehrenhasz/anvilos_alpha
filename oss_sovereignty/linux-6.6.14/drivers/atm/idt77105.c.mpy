{
  "module_name": "idt77105.c",
  "hash_id": "0675eabc0b1ce5309f71fc2c3ef062f78f503d5a7b051e3f3af59965378b3f63",
  "original_prompt": "Ingested from linux-6.6.14/drivers/atm/idt77105.c",
  "human_readable_source": "\n \n \n \n\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/atmdev.h>\n#include <linux/sonet.h>\n#include <linux/delay.h>\n#include <linux/timer.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/atm_idt77105.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <asm/param.h>\n#include <linux/uaccess.h>\n\n#include \"idt77105.h\"\n\n#undef GENERAL_DEBUG\n\n#ifdef GENERAL_DEBUG\n#define DPRINTK(format,args...) printk(KERN_DEBUG format,##args)\n#else\n#define DPRINTK(format,args...)\n#endif\n\n\nstruct idt77105_priv {\n\tstruct idt77105_stats stats;     \n\tstruct atm_dev *dev;\t\t \n\tstruct idt77105_priv *next;\n        int loop_mode;\n        unsigned char old_mcr;           \n};\n\nstatic DEFINE_SPINLOCK(idt77105_priv_lock);\n\n#define PRIV(dev) ((struct idt77105_priv *) dev->phy_data)\n\n#define PUT(val,reg) dev->ops->phy_put(dev,val,IDT77105_##reg)\n#define GET(reg) dev->ops->phy_get(dev,IDT77105_##reg)\n\nstatic void idt77105_stats_timer_func(struct timer_list *);\nstatic void idt77105_restart_timer_func(struct timer_list *);\n\n\nstatic DEFINE_TIMER(stats_timer, idt77105_stats_timer_func);\nstatic DEFINE_TIMER(restart_timer, idt77105_restart_timer_func);\nstatic int start_timer = 1;\nstatic struct idt77105_priv *idt77105_all = NULL;\n\n \nstatic u16 get_counter(struct atm_dev *dev, int counter)\n{\n        u16 val;\n        \n         \n        PUT(counter, CTRSEL);\n         \n        val = GET(CTRLO);\n         \n        val |= GET(CTRHI)<<8;\n        \n        return val;\n}\n\n \nstatic void idt77105_stats_timer_func(struct timer_list *unused)\n{\n\tstruct idt77105_priv *walk;\n\tstruct atm_dev *dev;\n\tstruct idt77105_stats *stats;\n\n        DPRINTK(\"IDT77105 gathering statistics\\n\");\n\tfor (walk = idt77105_all; walk; walk = walk->next) {\n\t\tdev = walk->dev;\n                \n\t\tstats = &walk->stats;\n                stats->symbol_errors += get_counter(dev, IDT77105_CTRSEL_SEC);\n                stats->tx_cells += get_counter(dev, IDT77105_CTRSEL_TCC);\n                stats->rx_cells += get_counter(dev, IDT77105_CTRSEL_RCC);\n                stats->rx_hec_errors += get_counter(dev, IDT77105_CTRSEL_RHEC);\n\t}\n        if (!start_timer) mod_timer(&stats_timer,jiffies+IDT77105_STATS_TIMER_PERIOD);\n}\n\n\n \nstatic void idt77105_restart_timer_func(struct timer_list *unused)\n{\n\tstruct idt77105_priv *walk;\n\tstruct atm_dev *dev;\n        unsigned char istat;\n\n        DPRINTK(\"IDT77105 checking for cable re-insertion\\n\");\n\tfor (walk = idt77105_all; walk; walk = walk->next) {\n\t\tdev = walk->dev;\n                \n                if (dev->signal != ATM_PHY_SIG_LOST)\n                    continue;\n                    \n                istat = GET(ISTAT);  \n                if (istat & IDT77105_ISTAT_GOODSIG) {\n                     \n                    atm_dev_signal_change(dev, ATM_PHY_SIG_FOUND);\n\t            printk(KERN_NOTICE \"%s(itf %d): signal detected again\\n\",\n                        dev->type,dev->number);\n                     \n                    PUT( GET(DIAG) | IDT77105_DIAG_RFLUSH, DIAG);\n                     \n\t            PUT( walk->old_mcr ,MCR);\n                }\n\t}\n        if (!start_timer) mod_timer(&restart_timer,jiffies+IDT77105_RESTART_TIMER_PERIOD);\n}\n\n\nstatic int fetch_stats(struct atm_dev *dev,struct idt77105_stats __user *arg,int zero)\n{\n\tunsigned long flags;\n\tstruct idt77105_stats stats;\n\n\tspin_lock_irqsave(&idt77105_priv_lock, flags);\n\tmemcpy(&stats, &PRIV(dev)->stats, sizeof(struct idt77105_stats));\n\tif (zero)\n\t\tmemset(&PRIV(dev)->stats, 0, sizeof(struct idt77105_stats));\n\tspin_unlock_irqrestore(&idt77105_priv_lock, flags);\n\tif (arg == NULL)\n\t\treturn 0;\n\treturn copy_to_user(arg, &stats,\n\t\t    sizeof(struct idt77105_stats)) ? -EFAULT : 0;\n}\n\n\nstatic int set_loopback(struct atm_dev *dev,int mode)\n{\n\tint diag;\n\n\tdiag = GET(DIAG) & ~IDT77105_DIAG_LCMASK;\n\tswitch (mode) {\n\t\tcase ATM_LM_NONE:\n\t\t\tbreak;\n\t\tcase ATM_LM_LOC_ATM:\n\t\t\tdiag |= IDT77105_DIAG_LC_PHY_LOOPBACK;\n\t\t\tbreak;\n\t\tcase ATM_LM_RMT_ATM:\n\t\t\tdiag |= IDT77105_DIAG_LC_LINE_LOOPBACK;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t}\n\tPUT(diag,DIAG);\n\tprintk(KERN_NOTICE \"%s(%d) Loopback mode is: %s\\n\", dev->type,\n\t    dev->number,\n\t    (mode == ATM_LM_NONE ? \"NONE\" : \n\t      (mode == ATM_LM_LOC_ATM ? \"DIAG (local)\" :\n\t\t(mode == IDT77105_DIAG_LC_LINE_LOOPBACK ? \"LOOP (remote)\" :\n\t\t  \"unknown\")))\n\t\t    );\n\tPRIV(dev)->loop_mode = mode;\n\treturn 0;\n}\n\n\nstatic int idt77105_ioctl(struct atm_dev *dev,unsigned int cmd,void __user *arg)\n{\n        printk(KERN_NOTICE \"%s(%d) idt77105_ioctl() called\\n\",dev->type,dev->number);\n\tswitch (cmd) {\n\t\tcase IDT77105_GETSTATZ:\n\t\t\tif (!capable(CAP_NET_ADMIN)) return -EPERM;\n\t\t\tfallthrough;\n\t\tcase IDT77105_GETSTAT:\n\t\t\treturn fetch_stats(dev, arg, cmd == IDT77105_GETSTATZ);\n\t\tcase ATM_SETLOOP:\n\t\t\treturn set_loopback(dev,(int)(unsigned long) arg);\n\t\tcase ATM_GETLOOP:\n\t\t\treturn put_user(PRIV(dev)->loop_mode,(int __user *)arg) ?\n\t\t\t    -EFAULT : 0;\n\t\tcase ATM_QUERYLOOP:\n\t\t\treturn put_user(ATM_LM_LOC_ATM | ATM_LM_RMT_ATM,\n\t\t\t    (int __user *) arg) ? -EFAULT : 0;\n\t\tdefault:\n\t\t\treturn -ENOIOCTLCMD;\n\t}\n}\n\n\n\nstatic void idt77105_int(struct atm_dev *dev)\n{\n        unsigned char istat;\n        \n        istat = GET(ISTAT);  \n     \n        DPRINTK(\"IDT77105 generated an interrupt, istat=%02x\\n\", (unsigned)istat);\n                \n        if (istat & IDT77105_ISTAT_RSCC) {\n             \n            if (istat & IDT77105_ISTAT_GOODSIG) {    \n                 \n\t\tatm_dev_signal_change(dev, ATM_PHY_SIG_FOUND);\n            } else {     \n                 \n                PRIV(dev)->old_mcr = GET(MCR);\n\t        PUT(\n                    (PRIV(dev)->old_mcr|\n                    IDT77105_MCR_DREC|\n                    IDT77105_MCR_DRIC|\n                    IDT77105_MCR_HALTTX\n                    ) & ~IDT77105_MCR_EIP, MCR);\n\t\tatm_dev_signal_change(dev, ATM_PHY_SIG_LOST);\n\t        printk(KERN_NOTICE \"%s(itf %d): signal lost\\n\",\n                    dev->type,dev->number);\n            }\n        }\n        \n        if (istat & IDT77105_ISTAT_RFO) {\n             \n            PUT( GET(DIAG) | IDT77105_DIAG_RFLUSH, DIAG);\n\t    printk(KERN_NOTICE \"%s(itf %d): receive FIFO overrun\\n\",\n                dev->type,dev->number);\n        }\n#ifdef GENERAL_DEBUG\n        if (istat & (IDT77105_ISTAT_HECERR | IDT77105_ISTAT_SCR |\n                     IDT77105_ISTAT_RSE)) {\n             \n\t    printk(KERN_NOTICE \"%s(itf %d): received cell with error\\n\",\n                dev->type,dev->number);\n        }\n#endif\n}\n\n\nstatic int idt77105_start(struct atm_dev *dev)\n{\n\tunsigned long flags;\n\n\tif (!(dev->phy_data = kmalloc(sizeof(struct idt77105_priv),GFP_KERNEL)))\n\t\treturn -ENOMEM;\n\tPRIV(dev)->dev = dev;\n\tspin_lock_irqsave(&idt77105_priv_lock, flags);\n\tPRIV(dev)->next = idt77105_all;\n\tidt77105_all = PRIV(dev);\n\tspin_unlock_irqrestore(&idt77105_priv_lock, flags);\n\tmemset(&PRIV(dev)->stats,0,sizeof(struct idt77105_stats));\n        \n         \n\tatm_dev_signal_change(dev,\n\t\tGET(ISTAT) & IDT77105_ISTAT_GOODSIG ?\n\t\tATM_PHY_SIG_FOUND : ATM_PHY_SIG_LOST);\n\tif (dev->signal == ATM_PHY_SIG_LOST)\n\t\tprintk(KERN_WARNING \"%s(itf %d): no signal\\n\",dev->type,\n\t\t    dev->number);\n\n         \n        switch ( GET(DIAG) & IDT77105_DIAG_LCMASK ) {\n        case IDT77105_DIAG_LC_NORMAL:\n            PRIV(dev)->loop_mode = ATM_LM_NONE;\n            break;\n        case IDT77105_DIAG_LC_PHY_LOOPBACK:\n            PRIV(dev)->loop_mode = ATM_LM_LOC_ATM;\n            break;\n        case IDT77105_DIAG_LC_LINE_LOOPBACK:\n            PRIV(dev)->loop_mode = ATM_LM_RMT_ATM;\n            break;\n        }\n        \n         \n        PRIV(dev)->old_mcr = GET(MCR);\n        if (dev->signal == ATM_PHY_SIG_FOUND) {\n            PRIV(dev)->old_mcr |= IDT77105_MCR_EIP;\n\t    PUT(PRIV(dev)->old_mcr, MCR);\n        }\n\n                    \n\tidt77105_stats_timer_func(0);  \n\t(void) fetch_stats(dev,NULL,1);  \n        \n\tspin_lock_irqsave(&idt77105_priv_lock, flags);\n\tif (start_timer) {\n\t\tstart_timer = 0;\n                \n\t\tstats_timer.expires = jiffies+IDT77105_STATS_TIMER_PERIOD;\n\t\tadd_timer(&stats_timer);\n                \n\t\trestart_timer.expires = jiffies+IDT77105_RESTART_TIMER_PERIOD;\n\t\tadd_timer(&restart_timer);\n\t}\n\tspin_unlock_irqrestore(&idt77105_priv_lock, flags);\n\treturn 0;\n}\n\n\nstatic int idt77105_stop(struct atm_dev *dev)\n{\n\tstruct idt77105_priv *walk, *prev;\n\n        DPRINTK(\"%s(itf %d): stopping IDT77105\\n\",dev->type,dev->number);\n        \n         \n\tPUT( GET(MCR) & ~IDT77105_MCR_EIP, MCR );\n        \n         \n\tfor (prev = NULL, walk = idt77105_all ;\n             walk != NULL;\n             prev = walk, walk = walk->next) {\n            if (walk->dev == dev) {\n                if (prev != NULL)\n                    prev->next = walk->next;\n                else\n                    idt77105_all = walk->next;\n\t        dev->phy = NULL;\n                dev->phy_data = NULL;\n                kfree(walk);\n                break;\n            }\n        }\n\n\treturn 0;\n}\n\n\nstatic const struct atmphy_ops idt77105_ops = {\n\t.start = \tidt77105_start,\n\t.ioctl =\tidt77105_ioctl,\n\t.interrupt =\tidt77105_int,\n\t.stop =\t\tidt77105_stop,\n};\n\n\nint idt77105_init(struct atm_dev *dev)\n{\n\tdev->phy = &idt77105_ops;\n\treturn 0;\n}\n\nEXPORT_SYMBOL(idt77105_init);\n\nstatic void __exit idt77105_exit(void)\n{\n\t \n\tdel_timer_sync(&stats_timer);\n\tdel_timer_sync(&restart_timer);\n}\n\nmodule_exit(idt77105_exit);\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}