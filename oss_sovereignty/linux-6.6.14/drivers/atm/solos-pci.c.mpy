{
  "module_name": "solos-pci.c",
  "hash_id": "121f8ac5d5d57e760769cd62ae7ef1557555498a1f99abd2f256caf6d6a22f99",
  "original_prompt": "Ingested from linux-6.6.14/drivers/atm/solos-pci.c",
  "human_readable_source": "\n \n\n#define DEBUG\n#define VERBOSE_DEBUG\n\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/ioport.h>\n#include <linux/types.h>\n#include <linux/pci.h>\n#include <linux/atm.h>\n#include <linux/atmdev.h>\n#include <linux/skbuff.h>\n#include <linux/sysfs.h>\n#include <linux/device.h>\n#include <linux/kobject.h>\n#include <linux/firmware.h>\n#include <linux/ctype.h>\n#include <linux/swab.h>\n#include <linux/slab.h>\n\n#define VERSION \"1.04\"\n#define DRIVER_VERSION 0x01\n#define PTAG \"solos-pci\"\n\n#define CONFIG_RAM_SIZE\t128\n#define FLAGS_ADDR\t0x7C\n#define IRQ_EN_ADDR\t0x78\n#define FPGA_VER\t0x74\n#define IRQ_CLEAR\t0x70\n#define WRITE_FLASH\t0x6C\n#define PORTS\t\t0x68\n#define FLASH_BLOCK\t0x64\n#define FLASH_BUSY\t0x60\n#define FPGA_MODE\t0x5C\n#define FLASH_MODE\t0x58\n#define GPIO_STATUS\t0x54\n#define DRIVER_VER\t0x50\n#define TX_DMA_ADDR(port)\t(0x40 + (4 * (port)))\n#define RX_DMA_ADDR(port)\t(0x30 + (4 * (port)))\n\n#define DATA_RAM_SIZE\t32768\n#define BUF_SIZE\t2048\n#define OLD_BUF_SIZE\t4096  \n \n#define ATMEL_FPGA_PAGE\t528  \n#define ATMEL_SOLOS_PAGE\t512  \n#define ATMEL_FPGA_BLOCK\t(ATMEL_FPGA_PAGE * 8)  \n#define ATMEL_SOLOS_BLOCK\t(ATMEL_SOLOS_PAGE * 8)  \n \n#define SPI_FLASH_BLOCK\t(256 * 64)\n\n#define RX_BUF(card, nr) ((card->buffers) + (nr)*(card->buffer_size)*2)\n#define TX_BUF(card, nr) ((card->buffers) + (nr)*(card->buffer_size)*2 + (card->buffer_size))\n#define FLASH_BUF ((card->buffers) + 4*(card->buffer_size)*2)\n\n#define RX_DMA_SIZE\t2048\n\n#define FPGA_VERSION(a,b) (((a) << 8) + (b))\n#define LEGACY_BUFFERS\t2\n#define DMA_SUPPORTED\t4\n\nstatic int reset = 0;\nstatic int atmdebug = 0;\nstatic int firmware_upgrade = 0;\nstatic int fpga_upgrade = 0;\nstatic int db_firmware_upgrade = 0;\nstatic int db_fpga_upgrade = 0;\n\nstruct pkt_hdr {\n\t__le16 size;\n\t__le16 vpi;\n\t__le16 vci;\n\t__le16 type;\n};\n\nstruct solos_skb_cb {\n\tstruct atm_vcc *vcc;\n\tuint32_t dma_addr;\n};\n\n\n#define SKB_CB(skb)\t\t((struct solos_skb_cb *)skb->cb)\n\n#define PKT_DATA\t0\n#define PKT_COMMAND\t1\n#define PKT_POPEN\t3\n#define PKT_PCLOSE\t4\n#define PKT_STATUS\t5\n\nstruct solos_card {\n\tvoid __iomem *config_regs;\n\tvoid __iomem *buffers;\n\tint nr_ports;\n\tint tx_mask;\n\tstruct pci_dev *dev;\n\tstruct atm_dev *atmdev[4];\n\tstruct tasklet_struct tlet;\n\tspinlock_t tx_lock;\n\tspinlock_t tx_queue_lock;\n\tspinlock_t cli_queue_lock;\n\tspinlock_t param_queue_lock;\n\tstruct list_head param_queue;\n\tstruct sk_buff_head tx_queue[4];\n\tstruct sk_buff_head cli_queue[4];\n\tstruct sk_buff *tx_skb[4];\n\tstruct sk_buff *rx_skb[4];\n\tunsigned char *dma_bounce;\n\twait_queue_head_t param_wq;\n\twait_queue_head_t fw_wq;\n\tint using_dma;\n\tint dma_alignment;\n\tint fpga_version;\n\tint buffer_size;\n\tint atmel_flash;\n};\n\n\nstruct solos_param {\n\tstruct list_head list;\n\tpid_t pid;\n\tint port;\n\tstruct sk_buff *response;\n};\n\n#define SOLOS_CHAN(atmdev) ((int)(unsigned long)(atmdev)->phy_data)\n\nMODULE_AUTHOR(\"Traverse Technologies <support@traverse.com.au>\");\nMODULE_DESCRIPTION(\"Solos PCI driver\");\nMODULE_VERSION(VERSION);\nMODULE_LICENSE(\"GPL\");\nMODULE_FIRMWARE(\"solos-FPGA.bin\");\nMODULE_FIRMWARE(\"solos-Firmware.bin\");\nMODULE_FIRMWARE(\"solos-db-FPGA.bin\");\nMODULE_PARM_DESC(reset, \"Reset Solos chips on startup\");\nMODULE_PARM_DESC(atmdebug, \"Print ATM data\");\nMODULE_PARM_DESC(firmware_upgrade, \"Initiate Solos firmware upgrade\");\nMODULE_PARM_DESC(fpga_upgrade, \"Initiate FPGA upgrade\");\nMODULE_PARM_DESC(db_firmware_upgrade, \"Initiate daughter board Solos firmware upgrade\");\nMODULE_PARM_DESC(db_fpga_upgrade, \"Initiate daughter board FPGA upgrade\");\nmodule_param(reset, int, 0444);\nmodule_param(atmdebug, int, 0644);\nmodule_param(firmware_upgrade, int, 0444);\nmodule_param(fpga_upgrade, int, 0444);\nmodule_param(db_firmware_upgrade, int, 0444);\nmodule_param(db_fpga_upgrade, int, 0444);\n\nstatic void fpga_queue(struct solos_card *card, int port, struct sk_buff *skb,\n\t\t       struct atm_vcc *vcc);\nstatic uint32_t fpga_tx(struct solos_card *);\nstatic irqreturn_t solos_irq(int irq, void *dev_id);\nstatic struct atm_vcc* find_vcc(struct atm_dev *dev, short vpi, int vci);\nstatic int atm_init(struct solos_card *, struct device *);\nstatic void atm_remove(struct solos_card *);\nstatic int send_command(struct solos_card *card, int dev, const char *buf, size_t size);\nstatic void solos_bh(unsigned long);\nstatic int print_buffer(struct sk_buff *buf);\n\nstatic inline void solos_pop(struct atm_vcc *vcc, struct sk_buff *skb)\n{\n        if (vcc->pop)\n                vcc->pop(vcc, skb);\n        else\n                dev_kfree_skb_any(skb);\n}\n\nstatic ssize_t solos_param_show(struct device *dev, struct device_attribute *attr,\n\t\t\t\tchar *buf)\n{\n\tstruct atm_dev *atmdev = container_of(dev, struct atm_dev, class_dev);\n\tstruct solos_card *card = atmdev->dev_data;\n\tstruct solos_param prm;\n\tstruct sk_buff *skb;\n\tstruct pkt_hdr *header;\n\tint buflen;\n\n\tbuflen = strlen(attr->attr.name) + 10;\n\n\tskb = alloc_skb(sizeof(*header) + buflen, GFP_KERNEL);\n\tif (!skb) {\n\t\tdev_warn(&card->dev->dev, \"Failed to allocate sk_buff in solos_param_show()\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\theader = skb_put(skb, sizeof(*header));\n\n\tbuflen = snprintf((void *)&header[1], buflen - 1,\n\t\t\t  \"L%05d\\n%s\\n\", current->pid, attr->attr.name);\n\tskb_put(skb, buflen);\n\n\theader->size = cpu_to_le16(buflen);\n\theader->vpi = cpu_to_le16(0);\n\theader->vci = cpu_to_le16(0);\n\theader->type = cpu_to_le16(PKT_COMMAND);\n\n\tprm.pid = current->pid;\n\tprm.response = NULL;\n\tprm.port = SOLOS_CHAN(atmdev);\n\n\tspin_lock_irq(&card->param_queue_lock);\n\tlist_add(&prm.list, &card->param_queue);\n\tspin_unlock_irq(&card->param_queue_lock);\n\n\tfpga_queue(card, prm.port, skb, NULL);\n\n\twait_event_timeout(card->param_wq, prm.response, 5 * HZ);\n\n\tspin_lock_irq(&card->param_queue_lock);\n\tlist_del(&prm.list);\n\tspin_unlock_irq(&card->param_queue_lock);\n\n\tif (!prm.response)\n\t\treturn -EIO;\n\n\tbuflen = prm.response->len;\n\tmemcpy(buf, prm.response->data, buflen);\n\tkfree_skb(prm.response);\n\n\treturn buflen;\n}\n\nstatic ssize_t solos_param_store(struct device *dev, struct device_attribute *attr,\n\t\t\t\t const char *buf, size_t count)\n{\n\tstruct atm_dev *atmdev = container_of(dev, struct atm_dev, class_dev);\n\tstruct solos_card *card = atmdev->dev_data;\n\tstruct solos_param prm;\n\tstruct sk_buff *skb;\n\tstruct pkt_hdr *header;\n\tint buflen;\n\tssize_t ret;\n\n\tbuflen = strlen(attr->attr.name) + 11 + count;\n\n\tskb = alloc_skb(sizeof(*header) + buflen, GFP_KERNEL);\n\tif (!skb) {\n\t\tdev_warn(&card->dev->dev, \"Failed to allocate sk_buff in solos_param_store()\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\theader = skb_put(skb, sizeof(*header));\n\n\tbuflen = snprintf((void *)&header[1], buflen - 1,\n\t\t\t  \"L%05d\\n%s\\n%s\\n\", current->pid, attr->attr.name, buf);\n\n\tskb_put(skb, buflen);\n\theader->size = cpu_to_le16(buflen);\n\theader->vpi = cpu_to_le16(0);\n\theader->vci = cpu_to_le16(0);\n\theader->type = cpu_to_le16(PKT_COMMAND);\n\n\tprm.pid = current->pid;\n\tprm.response = NULL;\n\tprm.port = SOLOS_CHAN(atmdev);\n\n\tspin_lock_irq(&card->param_queue_lock);\n\tlist_add(&prm.list, &card->param_queue);\n\tspin_unlock_irq(&card->param_queue_lock);\n\n\tfpga_queue(card, prm.port, skb, NULL);\n\n\twait_event_timeout(card->param_wq, prm.response, 5 * HZ);\n\n\tspin_lock_irq(&card->param_queue_lock);\n\tlist_del(&prm.list);\n\tspin_unlock_irq(&card->param_queue_lock);\n\n\tskb = prm.response;\n\n\tif (!skb)\n\t\treturn -EIO;\n\n\tbuflen = skb->len;\n\n\t \n\tif (skb->data[buflen - 1] == '\\n')\n\t\tbuflen--;\n\n\tif (buflen == 2 && !strncmp(skb->data, \"OK\", 2))\n\t\tret = count;\n\telse if (buflen == 5 && !strncmp(skb->data, \"ERROR\", 5))\n\t\tret = -EIO;\n\telse {\n\t\t \n\t\tskb->data[buflen] = 0;\n\t\n\t\tdev_warn(&card->dev->dev, \"Unexpected parameter response: '%s'\\n\",\n\t\t\t skb->data);\n\t\tret = -EIO;\n\t}\n\tkfree_skb(skb);\n\n\treturn ret;\n}\n\nstatic char *next_string(struct sk_buff *skb)\n{\n\tint i = 0;\n\tchar *this = skb->data;\n\t\n\tfor (i = 0; i < skb->len; i++) {\n\t\tif (this[i] == '\\n') {\n\t\t\tthis[i] = 0;\n\t\t\tskb_pull(skb, i + 1);\n\t\t\treturn this;\n\t\t}\n\t\tif (!isprint(this[i]))\n\t\t\treturn NULL;\n\t}\n\treturn NULL;\n}\n\n        \nstatic int process_status(struct solos_card *card, int port, struct sk_buff *skb)\n{\n\tchar *str, *state_str, *snr, *attn;\n\tint ver, rate_up, rate_down, err;\n\n\tif (!card->atmdev[port])\n\t\treturn -ENODEV;\n\n\tstr = next_string(skb);\n\tif (!str)\n\t\treturn -EIO;\n\n\terr = kstrtoint(str, 10, &ver);\n\tif (err) {\n\t\tdev_warn(&card->dev->dev, \"Unexpected status interrupt version\\n\");\n\t\treturn err;\n\t}\n\tif (ver < 1) {\n\t\tdev_warn(&card->dev->dev, \"Unexpected status interrupt version %d\\n\",\n\t\t\t ver);\n\t\treturn -EIO;\n\t}\n\n\tstr = next_string(skb);\n\tif (!str)\n\t\treturn -EIO;\n\tif (!strcmp(str, \"ERROR\")) {\n\t\tdev_dbg(&card->dev->dev, \"Status packet indicated Solos error on port %d (starting up?)\\n\",\n\t\t\t port);\n\t\treturn 0;\n\t}\n\n\terr = kstrtoint(str, 10, &rate_down);\n\tif (err)\n\t\treturn err;\n\n\tstr = next_string(skb);\n\tif (!str)\n\t\treturn -EIO;\n\terr = kstrtoint(str, 10, &rate_up);\n\tif (err)\n\t\treturn err;\n\n\tstate_str = next_string(skb);\n\tif (!state_str)\n\t\treturn -EIO;\n\n\t \n\tif (strcmp(state_str, \"Showtime\")) {\n\t\tatm_dev_signal_change(card->atmdev[port], ATM_PHY_SIG_LOST);\n\t\tdev_info(&card->dev->dev, \"Port %d: %s\\n\", port, state_str);\n\t\treturn 0;\n\t}\n\n\tsnr = next_string(skb);\n\tif (!snr)\n\t\treturn -EIO;\n\tattn = next_string(skb);\n\tif (!attn)\n\t\treturn -EIO;\n\n\tdev_info(&card->dev->dev, \"Port %d: %s @%d/%d kb/s%s%s%s%s\\n\",\n\t\t port, state_str, rate_down/1000, rate_up/1000,\n\t\t snr[0]?\", SNR \":\"\", snr, attn[0]?\", Attn \":\"\", attn);\n\t\n\tcard->atmdev[port]->link_rate = rate_down / 424;\n\tatm_dev_signal_change(card->atmdev[port], ATM_PHY_SIG_FOUND);\n\n\treturn 0;\n}\n\nstatic int process_command(struct solos_card *card, int port, struct sk_buff *skb)\n{\n\tstruct solos_param *prm;\n\tunsigned long flags;\n\tint cmdpid;\n\tint found = 0, err;\n\n\tif (skb->len < 7)\n\t\treturn 0;\n\n\tif (skb->data[0] != 'L'    || !isdigit(skb->data[1]) ||\n\t    !isdigit(skb->data[2]) || !isdigit(skb->data[3]) ||\n\t    !isdigit(skb->data[4]) || !isdigit(skb->data[5]) ||\n\t    skb->data[6] != '\\n')\n\t\treturn 0;\n\n\terr = kstrtoint(&skb->data[1], 10, &cmdpid);\n\tif (err)\n\t\treturn err;\n\n\tspin_lock_irqsave(&card->param_queue_lock, flags);\n\tlist_for_each_entry(prm, &card->param_queue, list) {\n\t\tif (prm->port == port && prm->pid == cmdpid) {\n\t\t\tprm->response = skb;\n\t\t\tskb_pull(skb, 7);\n\t\t\twake_up(&card->param_wq);\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&card->param_queue_lock, flags);\n\treturn found;\n}\n\nstatic ssize_t console_show(struct device *dev, struct device_attribute *attr,\n\t\t\t    char *buf)\n{\n\tstruct atm_dev *atmdev = container_of(dev, struct atm_dev, class_dev);\n\tstruct solos_card *card = atmdev->dev_data;\n\tstruct sk_buff *skb;\n\tunsigned int len;\n\n\tspin_lock_bh(&card->cli_queue_lock);\n\tskb = skb_dequeue(&card->cli_queue[SOLOS_CHAN(atmdev)]);\n\tspin_unlock_bh(&card->cli_queue_lock);\n\tif(skb == NULL)\n\t\treturn sprintf(buf, \"No data.\\n\");\n\n\tlen = skb->len;\n\tmemcpy(buf, skb->data, len);\n\n\tkfree_skb(skb);\n\treturn len;\n}\n\nstatic int send_command(struct solos_card *card, int dev, const char *buf, size_t size)\n{\n\tstruct sk_buff *skb;\n\tstruct pkt_hdr *header;\n\n\tif (size > (BUF_SIZE - sizeof(*header))) {\n\t\tdev_dbg(&card->dev->dev, \"Command is too big.  Dropping request\\n\");\n\t\treturn 0;\n\t}\n\tskb = alloc_skb(size + sizeof(*header), GFP_ATOMIC);\n\tif (!skb) {\n\t\tdev_warn(&card->dev->dev, \"Failed to allocate sk_buff in send_command()\\n\");\n\t\treturn 0;\n\t}\n\n\theader = skb_put(skb, sizeof(*header));\n\n\theader->size = cpu_to_le16(size);\n\theader->vpi = cpu_to_le16(0);\n\theader->vci = cpu_to_le16(0);\n\theader->type = cpu_to_le16(PKT_COMMAND);\n\n\tskb_put_data(skb, buf, size);\n\n\tfpga_queue(card, dev, skb, NULL);\n\n\treturn 0;\n}\n\nstatic ssize_t console_store(struct device *dev, struct device_attribute *attr,\n\t\t\t     const char *buf, size_t count)\n{\n\tstruct atm_dev *atmdev = container_of(dev, struct atm_dev, class_dev);\n\tstruct solos_card *card = atmdev->dev_data;\n\tint err;\n\n\terr = send_command(card, SOLOS_CHAN(atmdev), buf, count);\n\n\treturn err?:count;\n}\n\nstruct geos_gpio_attr {\n\tstruct device_attribute attr;\n\tint offset;\n};\n\n#define SOLOS_GPIO_ATTR(_name, _mode, _show, _store, _offset)\t\\\n\tstruct geos_gpio_attr gpio_attr_##_name = {\t\t\\\n\t\t.attr = __ATTR(_name, _mode, _show, _store),\t\\\n\t\t.offset = _offset }\n\nstatic ssize_t geos_gpio_store(struct device *dev, struct device_attribute *attr,\n\t\t\t       const char *buf, size_t count)\n{\n\tstruct geos_gpio_attr *gattr = container_of(attr, struct geos_gpio_attr, attr);\n\tstruct solos_card *card = dev_get_drvdata(dev);\n\tuint32_t data32;\n\n\tif (count != 1 && (count != 2 || buf[1] != '\\n'))\n\t\treturn -EINVAL;\n\n\tspin_lock_irq(&card->param_queue_lock);\n\tdata32 = ioread32(card->config_regs + GPIO_STATUS);\n\tif (buf[0] == '1') {\n\t\tdata32 |= 1 << gattr->offset;\n\t\tiowrite32(data32, card->config_regs + GPIO_STATUS);\n\t} else if (buf[0] == '0') {\n\t\tdata32 &= ~(1 << gattr->offset);\n\t\tiowrite32(data32, card->config_regs + GPIO_STATUS);\n\t} else {\n\t\tcount = -EINVAL;\n\t}\n\tspin_unlock_irq(&card->param_queue_lock);\n\treturn count;\n}\n\nstatic ssize_t geos_gpio_show(struct device *dev, struct device_attribute *attr,\n\t\t\t      char *buf)\n{\n\tstruct geos_gpio_attr *gattr = container_of(attr, struct geos_gpio_attr, attr);\n\tstruct solos_card *card = dev_get_drvdata(dev);\n\tuint32_t data32;\n\n\tdata32 = ioread32(card->config_regs + GPIO_STATUS);\n\tdata32 = (data32 >> gattr->offset) & 1;\n\n\treturn sprintf(buf, \"%d\\n\", data32);\n}\n\nstatic ssize_t hardware_show(struct device *dev, struct device_attribute *attr,\n\t\t\t     char *buf)\n{\n\tstruct geos_gpio_attr *gattr = container_of(attr, struct geos_gpio_attr, attr);\n\tstruct solos_card *card = dev_get_drvdata(dev);\n\tuint32_t data32;\n\n\tdata32 = ioread32(card->config_regs + GPIO_STATUS);\n\tswitch (gattr->offset) {\n\tcase 0:\n\t\t \n\t\tdata32 = data32 & 0x1F;\n\t\tbreak;\n\tcase 1:\n\t\t \n\t\tdata32 = (data32 >> 5) & 0x0F;\n\t\tbreak;\n\t}\n\treturn sprintf(buf, \"%d\\n\", data32);\n}\n\nstatic DEVICE_ATTR_RW(console);\n\n\n#define SOLOS_ATTR_RO(x) static DEVICE_ATTR(x, 0444, solos_param_show, NULL);\n#define SOLOS_ATTR_RW(x) static DEVICE_ATTR(x, 0644, solos_param_show, solos_param_store);\n\n#include \"solos-attrlist.c\"\n\nstatic SOLOS_GPIO_ATTR(GPIO1, 0644, geos_gpio_show, geos_gpio_store, 9);\nstatic SOLOS_GPIO_ATTR(GPIO2, 0644, geos_gpio_show, geos_gpio_store, 10);\nstatic SOLOS_GPIO_ATTR(GPIO3, 0644, geos_gpio_show, geos_gpio_store, 11);\nstatic SOLOS_GPIO_ATTR(GPIO4, 0644, geos_gpio_show, geos_gpio_store, 12);\nstatic SOLOS_GPIO_ATTR(GPIO5, 0644, geos_gpio_show, geos_gpio_store, 13);\nstatic SOLOS_GPIO_ATTR(PushButton, 0444, geos_gpio_show, NULL, 14);\nstatic SOLOS_GPIO_ATTR(HardwareVersion, 0444, hardware_show, NULL, 0);\nstatic SOLOS_GPIO_ATTR(HardwareVariant, 0444, hardware_show, NULL, 1);\n#undef SOLOS_ATTR_RO\n#undef SOLOS_ATTR_RW\n\n#define SOLOS_ATTR_RO(x) &dev_attr_##x.attr,\n#define SOLOS_ATTR_RW(x) &dev_attr_##x.attr,\n\nstatic struct attribute *solos_attrs[] = {\n#include \"solos-attrlist.c\"\n\tNULL\n};\n\nstatic const struct attribute_group solos_attr_group = {\n\t.attrs = solos_attrs,\n\t.name = \"parameters\",\n};\n\nstatic struct attribute *gpio_attrs[] = {\n\t&gpio_attr_GPIO1.attr.attr,\n\t&gpio_attr_GPIO2.attr.attr,\n\t&gpio_attr_GPIO3.attr.attr,\n\t&gpio_attr_GPIO4.attr.attr,\n\t&gpio_attr_GPIO5.attr.attr,\n\t&gpio_attr_PushButton.attr.attr,\n\t&gpio_attr_HardwareVersion.attr.attr,\n\t&gpio_attr_HardwareVariant.attr.attr,\n\tNULL\n};\n\nstatic const struct attribute_group gpio_attr_group = {\n\t.attrs = gpio_attrs,\n\t.name = \"gpio\",\n};\n\nstatic int flash_upgrade(struct solos_card *card, int chip)\n{\n\tconst struct firmware *fw;\n\tconst char *fw_name;\n\tint blocksize = 0;\n\tint numblocks = 0;\n\tint offset;\n\n\tswitch (chip) {\n\tcase 0:\n\t\tfw_name = \"solos-FPGA.bin\";\n\t\tif (card->atmel_flash)\n\t\t\tblocksize = ATMEL_FPGA_BLOCK;\n\t\telse\n\t\t\tblocksize = SPI_FLASH_BLOCK;\n\t\tbreak;\n\tcase 1:\n\t\tfw_name = \"solos-Firmware.bin\";\n\t\tif (card->atmel_flash)\n\t\t\tblocksize = ATMEL_SOLOS_BLOCK;\n\t\telse\n\t\t\tblocksize = SPI_FLASH_BLOCK;\n\t\tbreak;\n\tcase 2:\n\t\tif (card->fpga_version > LEGACY_BUFFERS){\n\t\t\tfw_name = \"solos-db-FPGA.bin\";\n\t\t\tif (card->atmel_flash)\n\t\t\t\tblocksize = ATMEL_FPGA_BLOCK;\n\t\t\telse\n\t\t\t\tblocksize = SPI_FLASH_BLOCK;\n\t\t} else {\n\t\t\tdev_info(&card->dev->dev, \"FPGA version doesn't support\"\n\t\t\t\t\t\" daughter board upgrades\\n\");\n\t\t\treturn -EPERM;\n\t\t}\n\t\tbreak;\n\tcase 3:\n\t\tif (card->fpga_version > LEGACY_BUFFERS){\n\t\t\tfw_name = \"solos-Firmware.bin\";\n\t\t\tif (card->atmel_flash)\n\t\t\t\tblocksize = ATMEL_SOLOS_BLOCK;\n\t\t\telse\n\t\t\t\tblocksize = SPI_FLASH_BLOCK;\n\t\t} else {\n\t\t\tdev_info(&card->dev->dev, \"FPGA version doesn't support\"\n\t\t\t\t\t\" daughter board upgrades\\n\");\n\t\t\treturn -EPERM;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -ENODEV;\n\t}\n\n\tif (request_firmware(&fw, fw_name, &card->dev->dev))\n\t\treturn -ENOENT;\n\n\tdev_info(&card->dev->dev, \"Flash upgrade starting\\n\");\n\n\t \n\tiowrite32(DRIVER_VERSION, card->config_regs + DRIVER_VER);\n\n\tnumblocks = fw->size / blocksize;\n\tdev_info(&card->dev->dev, \"Firmware size: %zd\\n\", fw->size);\n\tdev_info(&card->dev->dev, \"Number of blocks: %d\\n\", numblocks);\n\t\n\tdev_info(&card->dev->dev, \"Changing FPGA to Update mode\\n\");\n\tiowrite32(1, card->config_regs + FPGA_MODE);\n\t(void) ioread32(card->config_regs + FPGA_MODE); \n\n\t \n\tif(chip == 0 || chip == 2)\n\t\tdev_info(&card->dev->dev, \"Set FPGA Flash mode to FPGA Chip Erase\\n\");\n\tif(chip == 1 || chip == 3)\n\t\tdev_info(&card->dev->dev, \"Set FPGA Flash mode to Solos Chip Erase\\n\");\n\tiowrite32((chip * 2), card->config_regs + FLASH_MODE);\n\n\n\tiowrite32(1, card->config_regs + WRITE_FLASH);\n\twait_event(card->fw_wq, !ioread32(card->config_regs + FLASH_BUSY));\n\n\tfor (offset = 0; offset < fw->size; offset += blocksize) {\n\t\tint i;\n\n\t\t \n\t\tiowrite32(0, card->config_regs + WRITE_FLASH);\n\n\t\t \n\t\t \n\t\tiowrite32(((chip * 2) + 1), card->config_regs + FLASH_MODE);\n\n\t\t \n\t\tfor(i = 0; i < blocksize; i += 4) {\n\t\t\tuint32_t word;\n\t\t\tif (card->atmel_flash)\n\t\t\t\tword = swahb32p((uint32_t *)(fw->data + offset + i));\n\t\t\telse\n\t\t\t\tword = *(uint32_t *)(fw->data + offset + i);\n\t\t\tif(card->fpga_version > LEGACY_BUFFERS)\n\t\t\t\tiowrite32(word, FLASH_BUF + i);\n\t\t\telse\n\t\t\t\tiowrite32(word, RX_BUF(card, 3) + i);\n\t\t}\n\n\t\t \n\t\tiowrite32(offset / blocksize, card->config_regs + FLASH_BLOCK);\n\t\tiowrite32(1, card->config_regs + WRITE_FLASH);\n\t\twait_event(card->fw_wq, !ioread32(card->config_regs + FLASH_BUSY));\n\t}\n\n\trelease_firmware(fw);\n\tiowrite32(0, card->config_regs + WRITE_FLASH);\n\tiowrite32(0, card->config_regs + FPGA_MODE);\n\tiowrite32(0, card->config_regs + FLASH_MODE);\n\tdev_info(&card->dev->dev, \"Returning FPGA to Data mode\\n\");\n\treturn 0;\n}\n\nstatic irqreturn_t solos_irq(int irq, void *dev_id)\n{\n\tstruct solos_card *card = dev_id;\n\tint handled = 1;\n\n\tiowrite32(0, card->config_regs + IRQ_CLEAR);\n\n\t \n\tif (card->atmdev[0])\n\t\ttasklet_schedule(&card->tlet);\n\telse\n\t\twake_up(&card->fw_wq);\n\n\treturn IRQ_RETVAL(handled);\n}\n\nstatic void solos_bh(unsigned long card_arg)\n{\n\tstruct solos_card *card = (void *)card_arg;\n\tuint32_t card_flags;\n\tuint32_t rx_done = 0;\n\tint port;\n\n\t \n\tcard_flags = fpga_tx(card);\n\n\tfor (port = 0; port < card->nr_ports; port++) {\n\t\tif (card_flags & (0x10 << port)) {\n\t\t\tstruct pkt_hdr _hdr, *header;\n\t\t\tstruct sk_buff *skb;\n\t\t\tstruct atm_vcc *vcc;\n\t\t\tint size;\n\n\t\t\tif (card->using_dma) {\n\t\t\t\tskb = card->rx_skb[port];\n\t\t\t\tcard->rx_skb[port] = NULL;\n\n\t\t\t\tdma_unmap_single(&card->dev->dev, SKB_CB(skb)->dma_addr,\n\t\t\t\t\t\t RX_DMA_SIZE, DMA_FROM_DEVICE);\n\n\t\t\t\theader = (void *)skb->data;\n\t\t\t\tsize = le16_to_cpu(header->size);\n\t\t\t\tskb_put(skb, size + sizeof(*header));\n\t\t\t\tskb_pull(skb, sizeof(*header));\n\t\t\t} else {\n\t\t\t\theader = &_hdr;\n\n\t\t\t\trx_done |= 0x10 << port;\n\n\t\t\t\tmemcpy_fromio(header, RX_BUF(card, port), sizeof(*header));\n\n\t\t\t\tsize = le16_to_cpu(header->size);\n\t\t\t\tif (size > (card->buffer_size - sizeof(*header))){\n\t\t\t\t\tdev_warn(&card->dev->dev, \"Invalid buffer size\\n\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t \n\t\t\t\tskb = netdev_alloc_skb_ip_align(NULL, size + 1);\n\t\t\t\tif (!skb) {\n\t\t\t\t\tif (net_ratelimit())\n\t\t\t\t\t\tdev_warn(&card->dev->dev, \"Failed to allocate sk_buff for RX\\n\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tmemcpy_fromio(skb_put(skb, size),\n\t\t\t\t\t      RX_BUF(card, port) + sizeof(*header),\n\t\t\t\t\t      size);\n\t\t\t}\n\t\t\tif (atmdebug) {\n\t\t\t\tdev_info(&card->dev->dev, \"Received: port %d\\n\", port);\n\t\t\t\tdev_info(&card->dev->dev, \"size: %d VPI: %d VCI: %d\\n\",\n\t\t\t\t\t size, le16_to_cpu(header->vpi),\n\t\t\t\t\t le16_to_cpu(header->vci));\n\t\t\t\tprint_buffer(skb);\n\t\t\t}\n\n\t\t\tswitch (le16_to_cpu(header->type)) {\n\t\t\tcase PKT_DATA:\n\t\t\t\tvcc = find_vcc(card->atmdev[port], le16_to_cpu(header->vpi),\n\t\t\t\t\t       le16_to_cpu(header->vci));\n\t\t\t\tif (!vcc) {\n\t\t\t\t\tif (net_ratelimit())\n\t\t\t\t\t\tdev_warn(&card->dev->dev, \"Received packet for unknown VPI.VCI %d.%d on port %d\\n\",\n\t\t\t\t\t\t\t le16_to_cpu(header->vpi), le16_to_cpu(header->vci),\n\t\t\t\t\t\t\t port);\n\t\t\t\t\tdev_kfree_skb_any(skb);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tatm_charge(vcc, skb->truesize);\n\t\t\t\tvcc->push(vcc, skb);\n\t\t\t\tatomic_inc(&vcc->stats->rx);\n\t\t\t\tbreak;\n\n\t\t\tcase PKT_STATUS:\n\t\t\t\tif (process_status(card, port, skb) &&\n\t\t\t\t    net_ratelimit()) {\n\t\t\t\t\tdev_warn(&card->dev->dev, \"Bad status packet of %d bytes on port %d:\\n\", skb->len, port);\n\t\t\t\t\tprint_buffer(skb);\n\t\t\t\t}\n\t\t\t\tdev_kfree_skb_any(skb);\n\t\t\t\tbreak;\n\n\t\t\tcase PKT_COMMAND:\n\t\t\tdefault:  \n\t\t\t\tif (process_command(card, port, skb))\n\t\t\t\t\tbreak;\n\t\t\t\tspin_lock(&card->cli_queue_lock);\n\t\t\t\tif (skb_queue_len(&card->cli_queue[port]) > 10) {\n\t\t\t\t\tif (net_ratelimit())\n\t\t\t\t\t\tdev_warn(&card->dev->dev, \"Dropping console response on port %d\\n\",\n\t\t\t\t\t\t\t port);\n\t\t\t\t\tdev_kfree_skb_any(skb);\n\t\t\t\t} else\n\t\t\t\t\tskb_queue_tail(&card->cli_queue[port], skb);\n\t\t\t\tspin_unlock(&card->cli_queue_lock);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t \n\t\tif (card->using_dma && card->atmdev[port] &&\n\t\t    !card->rx_skb[port]) {\n\t\t\t \n\t\t\tstruct sk_buff *skb = dev_alloc_skb(RX_DMA_SIZE);\n\t\t\tif (skb) {\n\t\t\t\tSKB_CB(skb)->dma_addr =\n\t\t\t\t\tdma_map_single(&card->dev->dev, skb->data,\n\t\t\t\t\t\t       RX_DMA_SIZE, DMA_FROM_DEVICE);\n\t\t\t\tiowrite32(SKB_CB(skb)->dma_addr,\n\t\t\t\t\t  card->config_regs + RX_DMA_ADDR(port));\n\t\t\t\tcard->rx_skb[port] = skb;\n\t\t\t} else {\n\t\t\t\tif (net_ratelimit())\n\t\t\t\t\tdev_warn(&card->dev->dev, \"Failed to allocate RX skb\");\n\n\t\t\t\t \n\t\t\t\ttasklet_schedule(&card->tlet);\n\t\t\t}\n\t\t}\n\t}\n\tif (rx_done)\n\t\tiowrite32(rx_done, card->config_regs + FLAGS_ADDR);\n\n\treturn;\n}\n\nstatic struct atm_vcc *find_vcc(struct atm_dev *dev, short vpi, int vci)\n{\n\tstruct hlist_head *head;\n\tstruct atm_vcc *vcc = NULL;\n\tstruct sock *s;\n\n\tread_lock(&vcc_sklist_lock);\n\thead = &vcc_hash[vci & (VCC_HTABLE_SIZE -1)];\n\tsk_for_each(s, head) {\n\t\tvcc = atm_sk(s);\n\t\tif (vcc->dev == dev && vcc->vci == vci &&\n\t\t    vcc->vpi == vpi && vcc->qos.rxtp.traffic_class != ATM_NONE &&\n\t\t    test_bit(ATM_VF_READY, &vcc->flags))\n\t\t\tgoto out;\n\t}\n\tvcc = NULL;\n out:\n\tread_unlock(&vcc_sklist_lock);\n\treturn vcc;\n}\n\nstatic int popen(struct atm_vcc *vcc)\n{\n\tstruct solos_card *card = vcc->dev->dev_data;\n\tstruct sk_buff *skb;\n\tstruct pkt_hdr *header;\n\n\tif (vcc->qos.aal != ATM_AAL5) {\n\t\tdev_warn(&card->dev->dev, \"Unsupported ATM type %d\\n\",\n\t\t\t vcc->qos.aal);\n\t\treturn -EINVAL;\n\t}\n\n\tskb = alloc_skb(sizeof(*header), GFP_KERNEL);\n\tif (!skb) {\n\t\tif (net_ratelimit())\n\t\t\tdev_warn(&card->dev->dev, \"Failed to allocate sk_buff in popen()\\n\");\n\t\treturn -ENOMEM;\n\t}\n\theader = skb_put(skb, sizeof(*header));\n\n\theader->size = cpu_to_le16(0);\n\theader->vpi = cpu_to_le16(vcc->vpi);\n\theader->vci = cpu_to_le16(vcc->vci);\n\theader->type = cpu_to_le16(PKT_POPEN);\n\n\tfpga_queue(card, SOLOS_CHAN(vcc->dev), skb, NULL);\n\n\tset_bit(ATM_VF_ADDR, &vcc->flags);\n\tset_bit(ATM_VF_READY, &vcc->flags);\n\n\treturn 0;\n}\n\nstatic void pclose(struct atm_vcc *vcc)\n{\n\tstruct solos_card *card = vcc->dev->dev_data;\n\tunsigned char port = SOLOS_CHAN(vcc->dev);\n\tstruct sk_buff *skb, *tmpskb;\n\tstruct pkt_hdr *header;\n\n\t \n\tspin_lock_bh(&card->tx_queue_lock);\n\tskb_queue_walk_safe(&card->tx_queue[port], skb, tmpskb) {\n\t\tif (SKB_CB(skb)->vcc == vcc) {\n\t\t\tskb_unlink(skb, &card->tx_queue[port]);\n\t\t\tsolos_pop(vcc, skb);\n\t\t}\n\t}\n\tspin_unlock_bh(&card->tx_queue_lock);\n\n\tskb = alloc_skb(sizeof(*header), GFP_KERNEL);\n\tif (!skb) {\n\t\tdev_warn(&card->dev->dev, \"Failed to allocate sk_buff in pclose()\\n\");\n\t\treturn;\n\t}\n\theader = skb_put(skb, sizeof(*header));\n\n\theader->size = cpu_to_le16(0);\n\theader->vpi = cpu_to_le16(vcc->vpi);\n\theader->vci = cpu_to_le16(vcc->vci);\n\theader->type = cpu_to_le16(PKT_PCLOSE);\n\n\tskb_get(skb);\n\tfpga_queue(card, port, skb, NULL);\n\n\tif (!wait_event_timeout(card->param_wq, !skb_shared(skb), 5 * HZ))\n\t\tdev_warn(&card->dev->dev,\n\t\t\t \"Timeout waiting for VCC close on port %d\\n\", port);\n\n\tdev_kfree_skb(skb);\n\n\t \n\ttasklet_unlock_wait(&card->tlet);\n\n\tclear_bit(ATM_VF_ADDR, &vcc->flags);\n\n\treturn;\n}\n\nstatic int print_buffer(struct sk_buff *buf)\n{\n\tint len,i;\n\tchar msg[500];\n\tchar item[10];\n\n\tlen = buf->len;\n\tfor (i = 0; i < len; i++){\n\t\tif(i % 8 == 0)\n\t\t\tsprintf(msg, \"%02X: \", i);\n\n\t\tsprintf(item,\"%02X \",*(buf->data + i));\n\t\tstrcat(msg, item);\n\t\tif(i % 8 == 7) {\n\t\t\tsprintf(item, \"\\n\");\n\t\t\tstrcat(msg, item);\n\t\t\tprintk(KERN_DEBUG \"%s\", msg);\n\t\t}\n\t}\n\tif (i % 8 != 0) {\n\t\tsprintf(item, \"\\n\");\n\t\tstrcat(msg, item);\n\t\tprintk(KERN_DEBUG \"%s\", msg);\n\t}\n\tprintk(KERN_DEBUG \"\\n\");\n\n\treturn 0;\n}\n\nstatic void fpga_queue(struct solos_card *card, int port, struct sk_buff *skb,\n\t\t       struct atm_vcc *vcc)\n{\n\tint old_len;\n\tunsigned long flags;\n\n\tSKB_CB(skb)->vcc = vcc;\n\n\tspin_lock_irqsave(&card->tx_queue_lock, flags);\n\told_len = skb_queue_len(&card->tx_queue[port]);\n\tskb_queue_tail(&card->tx_queue[port], skb);\n\tif (!old_len)\n\t\tcard->tx_mask |= (1 << port);\n\tspin_unlock_irqrestore(&card->tx_queue_lock, flags);\n\n\t \n\tif (!old_len)\n\t\tfpga_tx(card);\n}\n\nstatic uint32_t fpga_tx(struct solos_card *card)\n{\n\tuint32_t tx_pending, card_flags;\n\tuint32_t tx_started = 0;\n\tstruct sk_buff *skb;\n\tstruct atm_vcc *vcc;\n\tunsigned char port;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&card->tx_lock, flags);\n\t\n\tcard_flags = ioread32(card->config_regs + FLAGS_ADDR);\n\t \n\ttx_pending = card->tx_mask & ~card_flags;\n\n\tfor (port = 0; tx_pending; tx_pending >>= 1, port++) {\n\t\tif (tx_pending & 1) {\n\t\t\tstruct sk_buff *oldskb = card->tx_skb[port];\n\t\t\tif (oldskb) {\n\t\t\t\tdma_unmap_single(&card->dev->dev, SKB_CB(oldskb)->dma_addr,\n\t\t\t\t\t\t oldskb->len, DMA_TO_DEVICE);\n\t\t\t\tcard->tx_skb[port] = NULL;\n\t\t\t}\n\t\t\tspin_lock(&card->tx_queue_lock);\n\t\t\tskb = skb_dequeue(&card->tx_queue[port]);\n\t\t\tif (!skb)\n\t\t\t\tcard->tx_mask &= ~(1 << port);\n\t\t\tspin_unlock(&card->tx_queue_lock);\n\n\t\t\tif (skb && !card->using_dma) {\n\t\t\t\tmemcpy_toio(TX_BUF(card, port), skb->data, skb->len);\n\t\t\t\ttx_started |= 1 << port;\n\t\t\t\toldskb = skb;  \n\t\t\t} else if (skb && card->using_dma) {\n\t\t\t\tunsigned char *data = skb->data;\n\t\t\t\tif ((unsigned long)data & card->dma_alignment) {\n\t\t\t\t\tdata = card->dma_bounce + (BUF_SIZE * port);\n\t\t\t\t\tmemcpy(data, skb->data, skb->len);\n\t\t\t\t}\n\t\t\t\tSKB_CB(skb)->dma_addr = dma_map_single(&card->dev->dev, data,\n\t\t\t\t\t\t\t\t       skb->len, DMA_TO_DEVICE);\n\t\t\t\tcard->tx_skb[port] = skb;\n\t\t\t\tiowrite32(SKB_CB(skb)->dma_addr,\n\t\t\t\t\t  card->config_regs + TX_DMA_ADDR(port));\n\t\t\t}\n\n\t\t\tif (!oldskb)\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tif (atmdebug) {\n\t\t\t\tstruct pkt_hdr *header = (void *)oldskb->data;\n\t\t\t\tint size = le16_to_cpu(header->size);\n\n\t\t\t\tskb_pull(oldskb, sizeof(*header));\n\t\t\t\tdev_info(&card->dev->dev, \"Transmitted: port %d\\n\",\n\t\t\t\t\t port);\n\t\t\t\tdev_info(&card->dev->dev, \"size: %d VPI: %d VCI: %d\\n\",\n\t\t\t\t\t size, le16_to_cpu(header->vpi),\n\t\t\t\t\t le16_to_cpu(header->vci));\n\t\t\t\tprint_buffer(oldskb);\n\t\t\t}\n\n\t\t\tvcc = SKB_CB(oldskb)->vcc;\n\n\t\t\tif (vcc) {\n\t\t\t\tatomic_inc(&vcc->stats->tx);\n\t\t\t\tsolos_pop(vcc, oldskb);\n\t\t\t} else {\n\t\t\t\tdev_kfree_skb_irq(oldskb);\n\t\t\t\twake_up(&card->param_wq);\n\t\t\t}\n\t\t}\n\t}\n\t \n\tif (tx_started)\n\t\tiowrite32(tx_started, card->config_regs + FLAGS_ADDR);\n\n\tspin_unlock_irqrestore(&card->tx_lock, flags);\n\treturn card_flags;\n}\n\nstatic int psend(struct atm_vcc *vcc, struct sk_buff *skb)\n{\n\tstruct solos_card *card = vcc->dev->dev_data;\n\tstruct pkt_hdr *header;\n\tint pktlen;\n\n\tpktlen = skb->len;\n\tif (pktlen > (BUF_SIZE - sizeof(*header))) {\n\t\tdev_warn(&card->dev->dev, \"Length of PDU is too large. Dropping PDU.\\n\");\n\t\tsolos_pop(vcc, skb);\n\t\treturn 0;\n\t}\n\n\tif (!skb_clone_writable(skb, sizeof(*header))) {\n\t\tint expand_by = 0;\n\t\tint ret;\n\n\t\tif (skb_headroom(skb) < sizeof(*header))\n\t\t\texpand_by = sizeof(*header) - skb_headroom(skb);\n\n\t\tret = pskb_expand_head(skb, expand_by, 0, GFP_ATOMIC);\n\t\tif (ret) {\n\t\t\tdev_warn(&card->dev->dev, \"pskb_expand_head failed.\\n\");\n\t\t\tsolos_pop(vcc, skb);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\theader = skb_push(skb, sizeof(*header));\n\n\t \n\theader->size = cpu_to_le16(pktlen);\n\theader->vpi = cpu_to_le16(vcc->vpi);\n\theader->vci = cpu_to_le16(vcc->vci);\n\theader->type = cpu_to_le16(PKT_DATA);\n\n\tfpga_queue(card, SOLOS_CHAN(vcc->dev), skb, vcc);\n\n\treturn 0;\n}\n\nstatic const struct atmdev_ops fpga_ops = {\n\t.open =\t\tpopen,\n\t.close =\tpclose,\n\t.ioctl =\tNULL,\n\t.send =\t\tpsend,\n\t.send_oam =\tNULL,\n\t.phy_put =\tNULL,\n\t.phy_get =\tNULL,\n\t.change_qos =\tNULL,\n\t.proc_read =\tNULL,\n\t.owner =\tTHIS_MODULE\n};\n\nstatic int fpga_probe(struct pci_dev *dev, const struct pci_device_id *id)\n{\n\tint err;\n\tuint16_t fpga_ver;\n\tuint8_t major_ver, minor_ver;\n\tuint32_t data32;\n\tstruct solos_card *card;\n\n\tcard = kzalloc(sizeof(*card), GFP_KERNEL);\n\tif (!card)\n\t\treturn -ENOMEM;\n\n\tcard->dev = dev;\n\tinit_waitqueue_head(&card->fw_wq);\n\tinit_waitqueue_head(&card->param_wq);\n\n\terr = pci_enable_device(dev);\n\tif (err) {\n\t\tdev_warn(&dev->dev,  \"Failed to enable PCI device\\n\");\n\t\tgoto out;\n\t}\n\n\terr = dma_set_mask_and_coherent(&dev->dev, DMA_BIT_MASK(32));\n\tif (err) {\n\t\tdev_warn(&dev->dev, \"Failed to set 32-bit DMA mask\\n\");\n\t\tgoto out;\n\t}\n\n\terr = pci_request_regions(dev, \"solos\");\n\tif (err) {\n\t\tdev_warn(&dev->dev, \"Failed to request regions\\n\");\n\t\tgoto out;\n\t}\n\n\tcard->config_regs = pci_iomap(dev, 0, CONFIG_RAM_SIZE);\n\tif (!card->config_regs) {\n\t\tdev_warn(&dev->dev, \"Failed to ioremap config registers\\n\");\n\t\terr = -ENOMEM;\n\t\tgoto out_release_regions;\n\t}\n\tcard->buffers = pci_iomap(dev, 1, DATA_RAM_SIZE);\n\tif (!card->buffers) {\n\t\tdev_warn(&dev->dev, \"Failed to ioremap data buffers\\n\");\n\t\terr = -ENOMEM;\n\t\tgoto out_unmap_config;\n\t}\n\n\tif (reset) {\n\t\tiowrite32(1, card->config_regs + FPGA_MODE);\n\t\tioread32(card->config_regs + FPGA_MODE);\n\n\t\tiowrite32(0, card->config_regs + FPGA_MODE);\n\t\tioread32(card->config_regs + FPGA_MODE);\n\t}\n\n\tdata32 = ioread32(card->config_regs + FPGA_VER);\n\tfpga_ver = (data32 & 0x0000FFFF);\n\tmajor_ver = ((data32 & 0xFF000000) >> 24);\n\tminor_ver = ((data32 & 0x00FF0000) >> 16);\n\tcard->fpga_version = FPGA_VERSION(major_ver,minor_ver);\n\tif (card->fpga_version > LEGACY_BUFFERS)\n\t\tcard->buffer_size = BUF_SIZE;\n\telse\n\t\tcard->buffer_size = OLD_BUF_SIZE;\n\tdev_info(&dev->dev, \"Solos FPGA Version %d.%02d svn-%d\\n\",\n\t\t major_ver, minor_ver, fpga_ver);\n\n\tif (fpga_ver < 37 && (fpga_upgrade || firmware_upgrade ||\n\t\t\t      db_fpga_upgrade || db_firmware_upgrade)) {\n\t\tdev_warn(&dev->dev,\n\t\t\t \"FPGA too old; cannot upgrade flash. Use JTAG.\\n\");\n\t\tfpga_upgrade = firmware_upgrade = 0;\n\t\tdb_fpga_upgrade = db_firmware_upgrade = 0;\n\t}\n\n\t \n\tif (fpga_ver < 39)\n\t\tcard->atmel_flash = 1;\n\telse\n\t\tcard->atmel_flash = 0;\n\n\tdata32 = ioread32(card->config_regs + PORTS);\n\tcard->nr_ports = (data32 & 0x000000FF);\n\n\tif (card->fpga_version >= DMA_SUPPORTED) {\n\t\tpci_set_master(dev);\n\t\tcard->using_dma = 1;\n\t\tif (1) {  \n\t\t\tcard->dma_alignment = 3;\n\t\t\tcard->dma_bounce = kmalloc_array(card->nr_ports,\n\t\t\t\t\t\t\t BUF_SIZE, GFP_KERNEL);\n\t\t\tif (!card->dma_bounce) {\n\t\t\t\tdev_warn(&card->dev->dev, \"Failed to allocate DMA bounce buffers\\n\");\n\t\t\t\terr = -ENOMEM;\n\t\t\t\t \n\t\t\t\tgoto out_unmap_both;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tcard->using_dma = 0;\n\t\t \n\t\tiowrite32(0xF0, card->config_regs + FLAGS_ADDR);\n\t}\n\n\tpci_set_drvdata(dev, card);\n\n\ttasklet_init(&card->tlet, solos_bh, (unsigned long)card);\n\tspin_lock_init(&card->tx_lock);\n\tspin_lock_init(&card->tx_queue_lock);\n\tspin_lock_init(&card->cli_queue_lock);\n\tspin_lock_init(&card->param_queue_lock);\n\tINIT_LIST_HEAD(&card->param_queue);\n\n\terr = request_irq(dev->irq, solos_irq, IRQF_SHARED,\n\t\t\t  \"solos-pci\", card);\n\tif (err) {\n\t\tdev_dbg(&card->dev->dev, \"Failed to request interrupt IRQ: %d\\n\", dev->irq);\n\t\tgoto out_unmap_both;\n\t}\n\n\tiowrite32(1, card->config_regs + IRQ_EN_ADDR);\n\n\tif (fpga_upgrade)\n\t\tflash_upgrade(card, 0);\n\n\tif (firmware_upgrade)\n\t\tflash_upgrade(card, 1);\n\n\tif (db_fpga_upgrade)\n\t\tflash_upgrade(card, 2);\n\n\tif (db_firmware_upgrade)\n\t\tflash_upgrade(card, 3);\n\n\terr = atm_init(card, &dev->dev);\n\tif (err)\n\t\tgoto out_free_irq;\n\n\tif (card->fpga_version >= DMA_SUPPORTED &&\n\t    sysfs_create_group(&card->dev->dev.kobj, &gpio_attr_group))\n\t\tdev_err(&card->dev->dev, \"Could not register parameter group for GPIOs\\n\");\n\n\treturn 0;\n\n out_free_irq:\n\tiowrite32(0, card->config_regs + IRQ_EN_ADDR);\n\tfree_irq(dev->irq, card);\n\ttasklet_kill(&card->tlet);\n\t\n out_unmap_both:\n\tkfree(card->dma_bounce);\n\tpci_iounmap(dev, card->buffers);\n out_unmap_config:\n\tpci_iounmap(dev, card->config_regs);\n out_release_regions:\n\tpci_release_regions(dev);\n out:\n\tkfree(card);\n\treturn err;\n}\n\nstatic int atm_init(struct solos_card *card, struct device *parent)\n{\n\tint i;\n\n\tfor (i = 0; i < card->nr_ports; i++) {\n\t\tstruct sk_buff *skb;\n\t\tstruct pkt_hdr *header;\n\n\t\tskb_queue_head_init(&card->tx_queue[i]);\n\t\tskb_queue_head_init(&card->cli_queue[i]);\n\n\t\tcard->atmdev[i] = atm_dev_register(\"solos-pci\", parent, &fpga_ops, -1, NULL);\n\t\tif (!card->atmdev[i]) {\n\t\t\tdev_err(&card->dev->dev, \"Could not register ATM device %d\\n\", i);\n\t\t\tatm_remove(card);\n\t\t\treturn -ENODEV;\n\t\t}\n\t\tif (device_create_file(&card->atmdev[i]->class_dev, &dev_attr_console))\n\t\t\tdev_err(&card->dev->dev, \"Could not register console for ATM device %d\\n\", i);\n\t\tif (sysfs_create_group(&card->atmdev[i]->class_dev.kobj, &solos_attr_group))\n\t\t\tdev_err(&card->dev->dev, \"Could not register parameter group for ATM device %d\\n\", i);\n\n\t\tdev_info(&card->dev->dev, \"Registered ATM device %d\\n\", card->atmdev[i]->number);\n\n\t\tcard->atmdev[i]->ci_range.vpi_bits = 8;\n\t\tcard->atmdev[i]->ci_range.vci_bits = 16;\n\t\tcard->atmdev[i]->dev_data = card;\n\t\tcard->atmdev[i]->phy_data = (void *)(unsigned long)i;\n\t\tatm_dev_signal_change(card->atmdev[i], ATM_PHY_SIG_FOUND);\n\n\t\tskb = alloc_skb(sizeof(*header), GFP_KERNEL);\n\t\tif (!skb) {\n\t\t\tdev_warn(&card->dev->dev, \"Failed to allocate sk_buff in atm_init()\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\theader = skb_put(skb, sizeof(*header));\n\n\t\theader->size = cpu_to_le16(0);\n\t\theader->vpi = cpu_to_le16(0);\n\t\theader->vci = cpu_to_le16(0);\n\t\theader->type = cpu_to_le16(PKT_STATUS);\n\n\t\tfpga_queue(card, i, skb, NULL);\n\t}\n\treturn 0;\n}\n\nstatic void atm_remove(struct solos_card *card)\n{\n\tint i;\n\n\tfor (i = 0; i < card->nr_ports; i++) {\n\t\tif (card->atmdev[i]) {\n\t\t\tstruct sk_buff *skb;\n\n\t\t\tdev_info(&card->dev->dev, \"Unregistering ATM device %d\\n\", card->atmdev[i]->number);\n\n\t\t\tsysfs_remove_group(&card->atmdev[i]->class_dev.kobj, &solos_attr_group);\n\t\t\tatm_dev_deregister(card->atmdev[i]);\n\n\t\t\tskb = card->rx_skb[i];\n\t\t\tif (skb) {\n\t\t\t\tdma_unmap_single(&card->dev->dev, SKB_CB(skb)->dma_addr,\n\t\t\t\t\t\t RX_DMA_SIZE, DMA_FROM_DEVICE);\n\t\t\t\tdev_kfree_skb(skb);\n\t\t\t}\n\t\t\tskb = card->tx_skb[i];\n\t\t\tif (skb) {\n\t\t\t\tdma_unmap_single(&card->dev->dev, SKB_CB(skb)->dma_addr,\n\t\t\t\t\t\t skb->len, DMA_TO_DEVICE);\n\t\t\t\tdev_kfree_skb(skb);\n\t\t\t}\n\t\t\twhile ((skb = skb_dequeue(&card->tx_queue[i])))\n\t\t\t\tdev_kfree_skb(skb);\n \n\t\t}\n\t}\n}\n\nstatic void fpga_remove(struct pci_dev *dev)\n{\n\tstruct solos_card *card = pci_get_drvdata(dev);\n\t\n\t \n\tiowrite32(0, card->config_regs + IRQ_EN_ADDR);\n\n\t \n\tiowrite32(1, card->config_regs + FPGA_MODE);\n\t(void)ioread32(card->config_regs + FPGA_MODE); \n\n\tif (card->fpga_version >= DMA_SUPPORTED)\n\t\tsysfs_remove_group(&card->dev->dev.kobj, &gpio_attr_group);\n\n\tatm_remove(card);\n\n\tfree_irq(dev->irq, card);\n\ttasklet_kill(&card->tlet);\n\n\tkfree(card->dma_bounce);\n\n\t \n\tiowrite32(0, card->config_regs + FPGA_MODE);\n\t(void)ioread32(card->config_regs + FPGA_MODE); \n\n\tpci_iounmap(dev, card->buffers);\n\tpci_iounmap(dev, card->config_regs);\n\n\tpci_release_regions(dev);\n\tpci_disable_device(dev);\n\n\tkfree(card);\n}\n\nstatic const struct pci_device_id fpga_pci_tbl[] = {\n\t{ 0x10ee, 0x0300, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },\n\t{ 0, }\n};\n\nMODULE_DEVICE_TABLE(pci,fpga_pci_tbl);\n\nstatic struct pci_driver fpga_driver = {\n\t.name =\t\t\"solos\",\n\t.id_table =\tfpga_pci_tbl,\n\t.probe =\tfpga_probe,\n\t.remove =\tfpga_remove,\n};\n\n\nstatic int __init solos_pci_init(void)\n{\n\tBUILD_BUG_ON(sizeof(struct solos_skb_cb) > sizeof(((struct sk_buff *)0)->cb));\n\n\tprintk(KERN_INFO \"Solos PCI Driver Version %s\\n\", VERSION);\n\treturn pci_register_driver(&fpga_driver);\n}\n\nstatic void __exit solos_pci_exit(void)\n{\n\tpci_unregister_driver(&fpga_driver);\n\tprintk(KERN_INFO \"Solos PCI Driver %s Unloaded\\n\", VERSION);\n}\n\nmodule_init(solos_pci_init);\nmodule_exit(solos_pci_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}