{
  "module_name": "nicstar.c",
  "hash_id": "503c894b9f8dcab5082244a414a1ca8fbd56b94934446b1504f62785195aab76",
  "original_prompt": "Ingested from linux-6.6.14/drivers/atm/nicstar.c",
  "human_readable_source": "\n \n\n \n\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/skbuff.h>\n#include <linux/atmdev.h>\n#include <linux/atm.h>\n#include <linux/pci.h>\n#include <linux/dma-mapping.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/timer.h>\n#include <linux/interrupt.h>\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/atomic.h>\n#include <linux/etherdevice.h>\n#include \"nicstar.h\"\n#ifdef CONFIG_ATM_NICSTAR_USE_SUNI\n#include \"suni.h\"\n#endif  \n#ifdef CONFIG_ATM_NICSTAR_USE_IDT77105\n#include \"idt77105.h\"\n#endif  \n\n \n\n#include \"nicstarmac.c\"\n\n \n\n#undef PHY_LOOPBACK\n#undef TX_DEBUG\n#undef RX_DEBUG\n#undef GENERAL_DEBUG\n#undef EXTRA_DEBUG\n\n \n\n#ifdef TX_DEBUG\n#define TXPRINTK(args...) printk(args)\n#else\n#define TXPRINTK(args...)\n#endif  \n\n#ifdef RX_DEBUG\n#define RXPRINTK(args...) printk(args)\n#else\n#define RXPRINTK(args...)\n#endif  \n\n#ifdef GENERAL_DEBUG\n#define PRINTK(args...) printk(args)\n#else\n#define PRINTK(args...) do {} while (0)\n#endif  \n\n#ifdef EXTRA_DEBUG\n#define XPRINTK(args...) printk(args)\n#else\n#define XPRINTK(args...)\n#endif  \n\n \n\n#define CMD_BUSY(card) (readl((card)->membase + STAT) & NS_STAT_CMDBZ)\n\n#define NS_DELAY mdelay(1)\n\n#define PTR_DIFF(a, b)\t((u32)((unsigned long)(a) - (unsigned long)(b)))\n\n#ifndef ATM_SKB\n#define ATM_SKB(s) (&(s)->atm)\n#endif\n\n#define scq_virt_to_bus(scq, p) \\\n\t\t(scq->dma + ((unsigned long)(p) - (unsigned long)(scq)->org))\n\n \n\nstatic u32 ns_read_sram(ns_dev * card, u32 sram_address);\nstatic void ns_write_sram(ns_dev * card, u32 sram_address, u32 * value,\n\t\t\t  int count);\nstatic int ns_init_card(int i, struct pci_dev *pcidev);\nstatic void ns_init_card_error(ns_dev * card, int error);\nstatic scq_info *get_scq(ns_dev *card, int size, u32 scd);\nstatic void free_scq(ns_dev *card, scq_info * scq, struct atm_vcc *vcc);\nstatic void push_rxbufs(ns_dev *, struct sk_buff *);\nstatic irqreturn_t ns_irq_handler(int irq, void *dev_id);\nstatic int ns_open(struct atm_vcc *vcc);\nstatic void ns_close(struct atm_vcc *vcc);\nstatic void fill_tst(ns_dev * card, int n, vc_map * vc);\nstatic int ns_send(struct atm_vcc *vcc, struct sk_buff *skb);\nstatic int ns_send_bh(struct atm_vcc *vcc, struct sk_buff *skb);\nstatic int push_scqe(ns_dev * card, vc_map * vc, scq_info * scq, ns_scqe * tbd,\n\t\t     struct sk_buff *skb, bool may_sleep);\nstatic void process_tsq(ns_dev * card);\nstatic void drain_scq(ns_dev * card, scq_info * scq, int pos);\nstatic void process_rsq(ns_dev * card);\nstatic void dequeue_rx(ns_dev * card, ns_rsqe * rsqe);\nstatic void recycle_rx_buf(ns_dev * card, struct sk_buff *skb);\nstatic void recycle_iovec_rx_bufs(ns_dev * card, struct iovec *iov, int count);\nstatic void recycle_iov_buf(ns_dev * card, struct sk_buff *iovb);\nstatic void dequeue_sm_buf(ns_dev * card, struct sk_buff *sb);\nstatic void dequeue_lg_buf(ns_dev * card, struct sk_buff *lb);\nstatic int ns_proc_read(struct atm_dev *dev, loff_t * pos, char *page);\nstatic int ns_ioctl(struct atm_dev *dev, unsigned int cmd, void __user * arg);\n#ifdef EXTRA_DEBUG\nstatic void which_list(ns_dev * card, struct sk_buff *skb);\n#endif\nstatic void ns_poll(struct timer_list *unused);\nstatic void ns_phy_put(struct atm_dev *dev, unsigned char value,\n\t\t       unsigned long addr);\nstatic unsigned char ns_phy_get(struct atm_dev *dev, unsigned long addr);\n\n \n\nstatic struct ns_dev *cards[NS_MAX_CARDS];\nstatic unsigned num_cards;\nstatic const struct atmdev_ops atm_ops = {\n\t.open = ns_open,\n\t.close = ns_close,\n\t.ioctl = ns_ioctl,\n\t.send = ns_send,\n\t.send_bh = ns_send_bh,\n\t.phy_put = ns_phy_put,\n\t.phy_get = ns_phy_get,\n\t.proc_read = ns_proc_read,\n\t.owner = THIS_MODULE,\n};\n\nstatic struct timer_list ns_timer;\nstatic char *mac[NS_MAX_CARDS];\nmodule_param_array(mac, charp, NULL, 0);\nMODULE_LICENSE(\"GPL\");\n\n \n\nstatic int nicstar_init_one(struct pci_dev *pcidev,\n\t\t\t    const struct pci_device_id *ent)\n{\n\tstatic int index = -1;\n\tunsigned int error;\n\n\tindex++;\n\tcards[index] = NULL;\n\n\terror = ns_init_card(index, pcidev);\n\tif (error) {\n\t\tcards[index--] = NULL;\t \n\t\tgoto err_out;\n\t}\n\n\treturn 0;\nerr_out:\n\treturn -ENODEV;\n}\n\nstatic void nicstar_remove_one(struct pci_dev *pcidev)\n{\n\tint i, j;\n\tns_dev *card = pci_get_drvdata(pcidev);\n\tstruct sk_buff *hb;\n\tstruct sk_buff *iovb;\n\tstruct sk_buff *lb;\n\tstruct sk_buff *sb;\n\n\ti = card->index;\n\n\tif (cards[i] == NULL)\n\t\treturn;\n\n\tif (card->atmdev->phy && card->atmdev->phy->stop)\n\t\tcard->atmdev->phy->stop(card->atmdev);\n\n\t \n\twritel(0x00000000, card->membase + CFG);\n\n\t \n\tatm_dev_deregister(card->atmdev);\n\n\t \n\tpci_disable_device(pcidev);\n\n\t \n\tj = 0;\n\tPRINTK(\"nicstar%d: freeing %d huge buffers.\\n\", i, card->hbpool.count);\n\twhile ((hb = skb_dequeue(&card->hbpool.queue)) != NULL) {\n\t\tdev_kfree_skb_any(hb);\n\t\tj++;\n\t}\n\tPRINTK(\"nicstar%d: %d huge buffers freed.\\n\", i, j);\n\tj = 0;\n\tPRINTK(\"nicstar%d: freeing %d iovec buffers.\\n\", i,\n\t       card->iovpool.count);\n\twhile ((iovb = skb_dequeue(&card->iovpool.queue)) != NULL) {\n\t\tdev_kfree_skb_any(iovb);\n\t\tj++;\n\t}\n\tPRINTK(\"nicstar%d: %d iovec buffers freed.\\n\", i, j);\n\twhile ((lb = skb_dequeue(&card->lbpool.queue)) != NULL)\n\t\tdev_kfree_skb_any(lb);\n\twhile ((sb = skb_dequeue(&card->sbpool.queue)) != NULL)\n\t\tdev_kfree_skb_any(sb);\n\tfree_scq(card, card->scq0, NULL);\n\tfor (j = 0; j < NS_FRSCD_NUM; j++) {\n\t\tif (card->scd2vc[j] != NULL)\n\t\t\tfree_scq(card, card->scd2vc[j]->scq, card->scd2vc[j]->tx_vcc);\n\t}\n\tidr_destroy(&card->idr);\n\tdma_free_coherent(&card->pcidev->dev, NS_RSQSIZE + NS_RSQ_ALIGNMENT,\n\t\t\t  card->rsq.org, card->rsq.dma);\n\tdma_free_coherent(&card->pcidev->dev, NS_TSQSIZE + NS_TSQ_ALIGNMENT,\n\t\t\t  card->tsq.org, card->tsq.dma);\n\tfree_irq(card->pcidev->irq, card);\n\tiounmap(card->membase);\n\tkfree(card);\n}\n\nstatic const struct pci_device_id nicstar_pci_tbl[] = {\n\t{ PCI_VDEVICE(IDT, PCI_DEVICE_ID_IDT_IDT77201), 0 },\n\t{0,}\t\t\t \n};\n\nMODULE_DEVICE_TABLE(pci, nicstar_pci_tbl);\n\nstatic struct pci_driver nicstar_driver = {\n\t.name = \"nicstar\",\n\t.id_table = nicstar_pci_tbl,\n\t.probe = nicstar_init_one,\n\t.remove = nicstar_remove_one,\n};\n\nstatic int __init nicstar_init(void)\n{\n\tunsigned error = 0;\t \n\n\tXPRINTK(\"nicstar: nicstar_init() called.\\n\");\n\n\terror = pci_register_driver(&nicstar_driver);\n\n\tTXPRINTK(\"nicstar: TX debug enabled.\\n\");\n\tRXPRINTK(\"nicstar: RX debug enabled.\\n\");\n\tPRINTK(\"nicstar: General debug enabled.\\n\");\n#ifdef PHY_LOOPBACK\n\tprintk(\"nicstar: using PHY loopback.\\n\");\n#endif  \n\tXPRINTK(\"nicstar: nicstar_init() returned.\\n\");\n\n\tif (!error) {\n\t\ttimer_setup(&ns_timer, ns_poll, 0);\n\t\tns_timer.expires = jiffies + NS_POLL_PERIOD;\n\t\tadd_timer(&ns_timer);\n\t}\n\n\treturn error;\n}\n\nstatic void __exit nicstar_cleanup(void)\n{\n\tXPRINTK(\"nicstar: nicstar_cleanup() called.\\n\");\n\n\tdel_timer_sync(&ns_timer);\n\n\tpci_unregister_driver(&nicstar_driver);\n\n\tXPRINTK(\"nicstar: nicstar_cleanup() returned.\\n\");\n}\n\nstatic u32 ns_read_sram(ns_dev * card, u32 sram_address)\n{\n\tunsigned long flags;\n\tu32 data;\n\tsram_address <<= 2;\n\tsram_address &= 0x0007FFFC;\t \n\tsram_address |= 0x50000000;\t \n\tspin_lock_irqsave(&card->res_lock, flags);\n\twhile (CMD_BUSY(card)) ;\n\twritel(sram_address, card->membase + CMD);\n\twhile (CMD_BUSY(card)) ;\n\tdata = readl(card->membase + DR0);\n\tspin_unlock_irqrestore(&card->res_lock, flags);\n\treturn data;\n}\n\nstatic void ns_write_sram(ns_dev * card, u32 sram_address, u32 * value,\n\t\t\t  int count)\n{\n\tunsigned long flags;\n\tint i, c;\n\tcount--;\t\t \n\tc = count;\n\tc <<= 2;\t\t \n\tspin_lock_irqsave(&card->res_lock, flags);\n\twhile (CMD_BUSY(card)) ;\n\tfor (i = 0; i <= c; i += 4)\n\t\twritel(*(value++), card->membase + i);\n\t \n\tsram_address <<= 2;\n\tsram_address &= 0x0007FFFC;\n\tsram_address |= (0x40000000 | count);\n\twritel(sram_address, card->membase + CMD);\n\tspin_unlock_irqrestore(&card->res_lock, flags);\n}\n\nstatic int ns_init_card(int i, struct pci_dev *pcidev)\n{\n\tint j;\n\tstruct ns_dev *card = NULL;\n\tunsigned char pci_latency;\n\tunsigned error;\n\tu32 data;\n\tu32 u32d[4];\n\tu32 ns_cfg_rctsize;\n\tint bcount;\n\tunsigned long membase;\n\n\terror = 0;\n\n\tif (pci_enable_device(pcidev)) {\n\t\tprintk(\"nicstar%d: can't enable PCI device\\n\", i);\n\t\terror = 2;\n\t\tns_init_card_error(card, error);\n\t\treturn error;\n\t}\n        if (dma_set_mask_and_coherent(&pcidev->dev, DMA_BIT_MASK(32)) != 0) {\n                printk(KERN_WARNING\n\t\t       \"nicstar%d: No suitable DMA available.\\n\", i);\n\t\terror = 2;\n\t\tns_init_card_error(card, error);\n\t\treturn error;\n        }\n\n\tcard = kmalloc(sizeof(*card), GFP_KERNEL);\n\tif (!card) {\n\t\tprintk\n\t\t    (\"nicstar%d: can't allocate memory for device structure.\\n\",\n\t\t     i);\n\t\terror = 2;\n\t\tns_init_card_error(card, error);\n\t\treturn error;\n\t}\n\tcards[i] = card;\n\tspin_lock_init(&card->int_lock);\n\tspin_lock_init(&card->res_lock);\n\n\tpci_set_drvdata(pcidev, card);\n\n\tcard->index = i;\n\tcard->atmdev = NULL;\n\tcard->pcidev = pcidev;\n\tmembase = pci_resource_start(pcidev, 1);\n\tcard->membase = ioremap(membase, NS_IOREMAP_SIZE);\n\tif (!card->membase) {\n\t\tprintk(\"nicstar%d: can't ioremap() membase.\\n\", i);\n\t\terror = 3;\n\t\tns_init_card_error(card, error);\n\t\treturn error;\n\t}\n\tPRINTK(\"nicstar%d: membase at 0x%p.\\n\", i, card->membase);\n\n\tpci_set_master(pcidev);\n\n\tif (pci_read_config_byte(pcidev, PCI_LATENCY_TIMER, &pci_latency) != 0) {\n\t\tprintk(\"nicstar%d: can't read PCI latency timer.\\n\", i);\n\t\terror = 6;\n\t\tns_init_card_error(card, error);\n\t\treturn error;\n\t}\n#ifdef NS_PCI_LATENCY\n\tif (pci_latency < NS_PCI_LATENCY) {\n\t\tPRINTK(\"nicstar%d: setting PCI latency timer to %d.\\n\", i,\n\t\t       NS_PCI_LATENCY);\n\t\tfor (j = 1; j < 4; j++) {\n\t\t\tif (pci_write_config_byte\n\t\t\t    (pcidev, PCI_LATENCY_TIMER, NS_PCI_LATENCY) != 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (j == 4) {\n\t\t\tprintk\n\t\t\t    (\"nicstar%d: can't set PCI latency timer to %d.\\n\",\n\t\t\t     i, NS_PCI_LATENCY);\n\t\t\terror = 7;\n\t\t\tns_init_card_error(card, error);\n\t\t\treturn error;\n\t\t}\n\t}\n#endif  \n\n\t \n\tdata = readl(card->membase + STAT);\n\tif (data & NS_STAT_TMROF)\n\t\twritel(NS_STAT_TMROF, card->membase + STAT);\n\n\t \n\twritel(NS_CFG_SWRST, card->membase + CFG);\n\tNS_DELAY;\n\twritel(0x00000000, card->membase + CFG);\n\n\t \n\twritel(0x00000008, card->membase + GP);\n\tNS_DELAY;\n\twritel(0x00000001, card->membase + GP);\n\tNS_DELAY;\n\twhile (CMD_BUSY(card)) ;\n\twritel(NS_CMD_WRITE_UTILITY | 0x00000100, card->membase + CMD);\t \n\tNS_DELAY;\n\n\t \n\twhile (CMD_BUSY(card)) ;\n\twritel(NS_CMD_READ_UTILITY | 0x00000200, card->membase + CMD);\n\twhile (CMD_BUSY(card)) ;\n\tdata = readl(card->membase + DR0);\n\tswitch (data) {\n\tcase 0x00000009:\n\t\tprintk(\"nicstar%d: PHY seems to be 25 Mbps.\\n\", i);\n\t\tcard->max_pcr = ATM_25_PCR;\n\t\twhile (CMD_BUSY(card)) ;\n\t\twritel(0x00000008, card->membase + DR0);\n\t\twritel(NS_CMD_WRITE_UTILITY | 0x00000200, card->membase + CMD);\n\t\t \n\t\twritel(NS_STAT_SFBQF, card->membase + STAT);\n#ifdef PHY_LOOPBACK\n\t\twhile (CMD_BUSY(card)) ;\n\t\twritel(0x00000022, card->membase + DR0);\n\t\twritel(NS_CMD_WRITE_UTILITY | 0x00000202, card->membase + CMD);\n#endif  \n\t\tbreak;\n\tcase 0x00000030:\n\tcase 0x00000031:\n\t\tprintk(\"nicstar%d: PHY seems to be 155 Mbps.\\n\", i);\n\t\tcard->max_pcr = ATM_OC3_PCR;\n#ifdef PHY_LOOPBACK\n\t\twhile (CMD_BUSY(card)) ;\n\t\twritel(0x00000002, card->membase + DR0);\n\t\twritel(NS_CMD_WRITE_UTILITY | 0x00000205, card->membase + CMD);\n#endif  \n\t\tbreak;\n\tdefault:\n\t\tprintk(\"nicstar%d: unknown PHY type (0x%08X).\\n\", i, data);\n\t\terror = 8;\n\t\tns_init_card_error(card, error);\n\t\treturn error;\n\t}\n\twritel(0x00000000, card->membase + GP);\n\n\t \n\tdata = 0x76543210;\n\tns_write_sram(card, 0x1C003, &data, 1);\n\tdata = 0x89ABCDEF;\n\tns_write_sram(card, 0x14003, &data, 1);\n\tif (ns_read_sram(card, 0x14003) == 0x89ABCDEF &&\n\t    ns_read_sram(card, 0x1C003) == 0x76543210)\n\t\tcard->sram_size = 128;\n\telse\n\t\tcard->sram_size = 32;\n\tPRINTK(\"nicstar%d: %dK x 32bit SRAM size.\\n\", i, card->sram_size);\n\n\tcard->rct_size = NS_MAX_RCTSIZE;\n\n#if (NS_MAX_RCTSIZE == 4096)\n\tif (card->sram_size == 128)\n\t\tprintk\n\t\t    (\"nicstar%d: limiting maximum VCI. See NS_MAX_RCTSIZE in nicstar.h\\n\",\n\t\t     i);\n#elif (NS_MAX_RCTSIZE == 16384)\n\tif (card->sram_size == 32) {\n\t\tprintk\n\t\t    (\"nicstar%d: wasting memory. See NS_MAX_RCTSIZE in nicstar.h\\n\",\n\t\t     i);\n\t\tcard->rct_size = 4096;\n\t}\n#else\n#error NS_MAX_RCTSIZE must be either 4096 or 16384 in nicstar.c\n#endif\n\n\tcard->vpibits = NS_VPIBITS;\n\tif (card->rct_size == 4096)\n\t\tcard->vcibits = 12 - NS_VPIBITS;\n\telse\t\t\t \n\t\tcard->vcibits = 14 - NS_VPIBITS;\n\n\t \n\tif (mac[i] == NULL)\n\t\tnicstar_init_eprom(card->membase);\n\n\t \n\twritel(0x00000000, card->membase + VPM);\n\n\tcard->intcnt = 0;\n\tif (request_irq\n\t    (pcidev->irq, &ns_irq_handler, IRQF_SHARED, \"nicstar\", card) != 0) {\n\t\tpr_err(\"nicstar%d: can't allocate IRQ %d.\\n\", i, pcidev->irq);\n\t\terror = 9;\n\t\tns_init_card_error(card, error);\n\t\treturn error;\n\t}\n\n\t \n\tcard->tsq.org = dma_alloc_coherent(&card->pcidev->dev,\n\t\t\t\t\t   NS_TSQSIZE + NS_TSQ_ALIGNMENT,\n\t\t\t\t\t   &card->tsq.dma, GFP_KERNEL);\n\tif (card->tsq.org == NULL) {\n\t\tprintk(\"nicstar%d: can't allocate TSQ.\\n\", i);\n\t\terror = 10;\n\t\tns_init_card_error(card, error);\n\t\treturn error;\n\t}\n\tcard->tsq.base = PTR_ALIGN(card->tsq.org, NS_TSQ_ALIGNMENT);\n\tcard->tsq.next = card->tsq.base;\n\tcard->tsq.last = card->tsq.base + (NS_TSQ_NUM_ENTRIES - 1);\n\tfor (j = 0; j < NS_TSQ_NUM_ENTRIES; j++)\n\t\tns_tsi_init(card->tsq.base + j);\n\twritel(0x00000000, card->membase + TSQH);\n\twritel(ALIGN(card->tsq.dma, NS_TSQ_ALIGNMENT), card->membase + TSQB);\n\tPRINTK(\"nicstar%d: TSQ base at 0x%p.\\n\", i, card->tsq.base);\n\n\t \n\tcard->rsq.org = dma_alloc_coherent(&card->pcidev->dev,\n\t\t\t\t\t   NS_RSQSIZE + NS_RSQ_ALIGNMENT,\n\t\t\t\t\t   &card->rsq.dma, GFP_KERNEL);\n\tif (card->rsq.org == NULL) {\n\t\tprintk(\"nicstar%d: can't allocate RSQ.\\n\", i);\n\t\terror = 11;\n\t\tns_init_card_error(card, error);\n\t\treturn error;\n\t}\n\tcard->rsq.base = PTR_ALIGN(card->rsq.org, NS_RSQ_ALIGNMENT);\n\tcard->rsq.next = card->rsq.base;\n\tcard->rsq.last = card->rsq.base + (NS_RSQ_NUM_ENTRIES - 1);\n\tfor (j = 0; j < NS_RSQ_NUM_ENTRIES; j++)\n\t\tns_rsqe_init(card->rsq.base + j);\n\twritel(0x00000000, card->membase + RSQH);\n\twritel(ALIGN(card->rsq.dma, NS_RSQ_ALIGNMENT), card->membase + RSQB);\n\tPRINTK(\"nicstar%d: RSQ base at 0x%p.\\n\", i, card->rsq.base);\n\n\t \n\tcard->scq1 = NULL;\n\tcard->scq2 = NULL;\n\tcard->scq0 = get_scq(card, VBR_SCQSIZE, NS_VRSCD0);\n\tif (card->scq0 == NULL) {\n\t\tprintk(\"nicstar%d: can't get SCQ0.\\n\", i);\n\t\terror = 12;\n\t\tns_init_card_error(card, error);\n\t\treturn error;\n\t}\n\tu32d[0] = scq_virt_to_bus(card->scq0, card->scq0->base);\n\tu32d[1] = (u32) 0x00000000;\n\tu32d[2] = (u32) 0xffffffff;\n\tu32d[3] = (u32) 0x00000000;\n\tns_write_sram(card, NS_VRSCD0, u32d, 4);\n\tns_write_sram(card, NS_VRSCD1, u32d, 4);\t \n\tns_write_sram(card, NS_VRSCD2, u32d, 4);\t \n\tcard->scq0->scd = NS_VRSCD0;\n\tPRINTK(\"nicstar%d: VBR-SCQ0 base at 0x%p.\\n\", i, card->scq0->base);\n\n\t \n\tcard->tst_addr = NS_TST0;\n\tcard->tst_free_entries = NS_TST_NUM_ENTRIES;\n\tdata = NS_TST_OPCODE_VARIABLE;\n\tfor (j = 0; j < NS_TST_NUM_ENTRIES; j++)\n\t\tns_write_sram(card, NS_TST0 + j, &data, 1);\n\tdata = ns_tste_make(NS_TST_OPCODE_END, NS_TST0);\n\tns_write_sram(card, NS_TST0 + NS_TST_NUM_ENTRIES, &data, 1);\n\tfor (j = 0; j < NS_TST_NUM_ENTRIES; j++)\n\t\tns_write_sram(card, NS_TST1 + j, &data, 1);\n\tdata = ns_tste_make(NS_TST_OPCODE_END, NS_TST1);\n\tns_write_sram(card, NS_TST1 + NS_TST_NUM_ENTRIES, &data, 1);\n\tfor (j = 0; j < NS_TST_NUM_ENTRIES; j++)\n\t\tcard->tste2vc[j] = NULL;\n\twritel(NS_TST0 << 2, card->membase + TSTB);\n\n\t \n#ifdef RCQ_SUPPORT\n\tu32d[0] = NS_RCTE_RAWCELLINTEN;\n#else\n\tu32d[0] = 0x00000000;\n#endif  \n\tu32d[1] = 0x00000000;\n\tu32d[2] = 0x00000000;\n\tu32d[3] = 0xFFFFFFFF;\n\tfor (j = 0; j < card->rct_size; j++)\n\t\tns_write_sram(card, j * 4, u32d, 4);\n\n\tmemset(card->vcmap, 0, sizeof(card->vcmap));\n\n\tfor (j = 0; j < NS_FRSCD_NUM; j++)\n\t\tcard->scd2vc[j] = NULL;\n\n\t \n\tcard->sbnr.min = MIN_SB;\n\tcard->sbnr.init = NUM_SB;\n\tcard->sbnr.max = MAX_SB;\n\tcard->lbnr.min = MIN_LB;\n\tcard->lbnr.init = NUM_LB;\n\tcard->lbnr.max = MAX_LB;\n\tcard->iovnr.min = MIN_IOVB;\n\tcard->iovnr.init = NUM_IOVB;\n\tcard->iovnr.max = MAX_IOVB;\n\tcard->hbnr.min = MIN_HB;\n\tcard->hbnr.init = NUM_HB;\n\tcard->hbnr.max = MAX_HB;\n\n\tcard->sm_handle = NULL;\n\tcard->sm_addr = 0x00000000;\n\tcard->lg_handle = NULL;\n\tcard->lg_addr = 0x00000000;\n\n\tcard->efbie = 1;\t \n\n\tidr_init(&card->idr);\n\n\t \n\tskb_queue_head_init(&card->hbpool.queue);\n\tcard->hbpool.count = 0;\n\tfor (j = 0; j < NUM_HB; j++) {\n\t\tstruct sk_buff *hb;\n\t\thb = __dev_alloc_skb(NS_HBUFSIZE, GFP_KERNEL);\n\t\tif (hb == NULL) {\n\t\t\tprintk\n\t\t\t    (\"nicstar%d: can't allocate %dth of %d huge buffers.\\n\",\n\t\t\t     i, j, NUM_HB);\n\t\t\terror = 13;\n\t\t\tns_init_card_error(card, error);\n\t\t\treturn error;\n\t\t}\n\t\tNS_PRV_BUFTYPE(hb) = BUF_NONE;\n\t\tskb_queue_tail(&card->hbpool.queue, hb);\n\t\tcard->hbpool.count++;\n\t}\n\n\t \n\tskb_queue_head_init(&card->lbpool.queue);\n\tcard->lbpool.count = 0;\t \n\tfor (j = 0; j < NUM_LB; j++) {\n\t\tstruct sk_buff *lb;\n\t\tlb = __dev_alloc_skb(NS_LGSKBSIZE, GFP_KERNEL);\n\t\tif (lb == NULL) {\n\t\t\tprintk\n\t\t\t    (\"nicstar%d: can't allocate %dth of %d large buffers.\\n\",\n\t\t\t     i, j, NUM_LB);\n\t\t\terror = 14;\n\t\t\tns_init_card_error(card, error);\n\t\t\treturn error;\n\t\t}\n\t\tNS_PRV_BUFTYPE(lb) = BUF_LG;\n\t\tskb_queue_tail(&card->lbpool.queue, lb);\n\t\tskb_reserve(lb, NS_SMBUFSIZE);\n\t\tpush_rxbufs(card, lb);\n\t\t \n\t\tif (j == 1) {\n\t\t\tcard->rcbuf = lb;\n\t\t\tcard->rawcell = (struct ns_rcqe *) lb->data;\n\t\t\tcard->rawch = NS_PRV_DMA(lb);\n\t\t}\n\t}\n\t \n\tif ((bcount =\n\t     ns_stat_lfbqc_get(readl(card->membase + STAT))) < card->lbnr.min) {\n\t\tprintk\n\t\t    (\"nicstar%d: Strange... Just allocated %d large buffers and lfbqc = %d.\\n\",\n\t\t     i, j, bcount);\n\t\terror = 14;\n\t\tns_init_card_error(card, error);\n\t\treturn error;\n\t}\n\n\t \n\tskb_queue_head_init(&card->sbpool.queue);\n\tcard->sbpool.count = 0;\t \n\tfor (j = 0; j < NUM_SB; j++) {\n\t\tstruct sk_buff *sb;\n\t\tsb = __dev_alloc_skb(NS_SMSKBSIZE, GFP_KERNEL);\n\t\tif (sb == NULL) {\n\t\t\tprintk\n\t\t\t    (\"nicstar%d: can't allocate %dth of %d small buffers.\\n\",\n\t\t\t     i, j, NUM_SB);\n\t\t\terror = 15;\n\t\t\tns_init_card_error(card, error);\n\t\t\treturn error;\n\t\t}\n\t\tNS_PRV_BUFTYPE(sb) = BUF_SM;\n\t\tskb_queue_tail(&card->sbpool.queue, sb);\n\t\tskb_reserve(sb, NS_AAL0_HEADER);\n\t\tpush_rxbufs(card, sb);\n\t}\n\t \n\tif ((bcount =\n\t     ns_stat_sfbqc_get(readl(card->membase + STAT))) < card->sbnr.min) {\n\t\tprintk\n\t\t    (\"nicstar%d: Strange... Just allocated %d small buffers and sfbqc = %d.\\n\",\n\t\t     i, j, bcount);\n\t\terror = 15;\n\t\tns_init_card_error(card, error);\n\t\treturn error;\n\t}\n\n\t \n\tskb_queue_head_init(&card->iovpool.queue);\n\tcard->iovpool.count = 0;\n\tfor (j = 0; j < NUM_IOVB; j++) {\n\t\tstruct sk_buff *iovb;\n\t\tiovb = alloc_skb(NS_IOVBUFSIZE, GFP_KERNEL);\n\t\tif (iovb == NULL) {\n\t\t\tprintk\n\t\t\t    (\"nicstar%d: can't allocate %dth of %d iovec buffers.\\n\",\n\t\t\t     i, j, NUM_IOVB);\n\t\t\terror = 16;\n\t\t\tns_init_card_error(card, error);\n\t\t\treturn error;\n\t\t}\n\t\tNS_PRV_BUFTYPE(iovb) = BUF_NONE;\n\t\tskb_queue_tail(&card->iovpool.queue, iovb);\n\t\tcard->iovpool.count++;\n\t}\n\n\t \n\tif (card->rct_size == 4096)\n\t\tns_cfg_rctsize = NS_CFG_RCTSIZE_4096_ENTRIES;\n\telse\t\t\t \n\t\tns_cfg_rctsize = NS_CFG_RCTSIZE_16384_ENTRIES;\n\n\tcard->efbie = 1;\n\n\t \n\tcard->atmdev = atm_dev_register(\"nicstar\", &card->pcidev->dev, &atm_ops,\n\t\t\t\t\t-1, NULL);\n\tif (card->atmdev == NULL) {\n\t\tprintk(\"nicstar%d: can't register device.\\n\", i);\n\t\terror = 17;\n\t\tns_init_card_error(card, error);\n\t\treturn error;\n\t}\n\n\tif (mac[i] == NULL || !mac_pton(mac[i], card->atmdev->esi)) {\n\t\tnicstar_read_eprom(card->membase, NICSTAR_EPROM_MAC_ADDR_OFFSET,\n\t\t\t\t   card->atmdev->esi, 6);\n\t\tif (ether_addr_equal(card->atmdev->esi, \"\\x00\\x00\\x00\\x00\\x00\\x00\")) {\n\t\t\tnicstar_read_eprom(card->membase,\n\t\t\t\t\t   NICSTAR_EPROM_MAC_ADDR_OFFSET_ALT,\n\t\t\t\t\t   card->atmdev->esi, 6);\n\t\t}\n\t}\n\n\tprintk(\"nicstar%d: MAC address %pM\\n\", i, card->atmdev->esi);\n\n\tcard->atmdev->dev_data = card;\n\tcard->atmdev->ci_range.vpi_bits = card->vpibits;\n\tcard->atmdev->ci_range.vci_bits = card->vcibits;\n\tcard->atmdev->link_rate = card->max_pcr;\n\tcard->atmdev->phy = NULL;\n\n#ifdef CONFIG_ATM_NICSTAR_USE_SUNI\n\tif (card->max_pcr == ATM_OC3_PCR)\n\t\tsuni_init(card->atmdev);\n#endif  \n\n#ifdef CONFIG_ATM_NICSTAR_USE_IDT77105\n\tif (card->max_pcr == ATM_25_PCR)\n\t\tidt77105_init(card->atmdev);\n#endif  \n\n\tif (card->atmdev->phy && card->atmdev->phy->start)\n\t\tcard->atmdev->phy->start(card->atmdev);\n\n\twritel(NS_CFG_RXPATH | NS_CFG_SMBUFSIZE | NS_CFG_LGBUFSIZE | NS_CFG_EFBIE | NS_CFG_RSQSIZE | NS_CFG_VPIBITS | ns_cfg_rctsize | NS_CFG_RXINT_NODELAY | NS_CFG_RAWIE |\t \n\t       NS_CFG_RSQAFIE | NS_CFG_TXEN | NS_CFG_TXIE | NS_CFG_TSQFIE_OPT |\t \n\t       NS_CFG_PHYIE, card->membase + CFG);\n\n\tnum_cards++;\n\n\treturn error;\n}\n\nstatic void ns_init_card_error(ns_dev *card, int error)\n{\n\tif (error >= 17) {\n\t\twritel(0x00000000, card->membase + CFG);\n\t}\n\tif (error >= 16) {\n\t\tstruct sk_buff *iovb;\n\t\twhile ((iovb = skb_dequeue(&card->iovpool.queue)) != NULL)\n\t\t\tdev_kfree_skb_any(iovb);\n\t}\n\tif (error >= 15) {\n\t\tstruct sk_buff *sb;\n\t\twhile ((sb = skb_dequeue(&card->sbpool.queue)) != NULL)\n\t\t\tdev_kfree_skb_any(sb);\n\t\tfree_scq(card, card->scq0, NULL);\n\t}\n\tif (error >= 14) {\n\t\tstruct sk_buff *lb;\n\t\twhile ((lb = skb_dequeue(&card->lbpool.queue)) != NULL)\n\t\t\tdev_kfree_skb_any(lb);\n\t}\n\tif (error >= 13) {\n\t\tstruct sk_buff *hb;\n\t\twhile ((hb = skb_dequeue(&card->hbpool.queue)) != NULL)\n\t\t\tdev_kfree_skb_any(hb);\n\t}\n\tif (error >= 12) {\n\t\tdma_free_coherent(&card->pcidev->dev, NS_RSQSIZE + NS_RSQ_ALIGNMENT,\n\t\t\t\tcard->rsq.org, card->rsq.dma);\n\t}\n\tif (error >= 11) {\n\t\tdma_free_coherent(&card->pcidev->dev, NS_TSQSIZE + NS_TSQ_ALIGNMENT,\n\t\t\t\tcard->tsq.org, card->tsq.dma);\n\t}\n\tif (error >= 10) {\n\t\tfree_irq(card->pcidev->irq, card);\n\t}\n\tif (error >= 4) {\n\t\tiounmap(card->membase);\n\t}\n\tif (error >= 3) {\n\t\tpci_disable_device(card->pcidev);\n\t\tkfree(card);\n\t}\n}\n\nstatic scq_info *get_scq(ns_dev *card, int size, u32 scd)\n{\n\tscq_info *scq;\n\n\tif (size != VBR_SCQSIZE && size != CBR_SCQSIZE)\n\t\treturn NULL;\n\n\tscq = kmalloc(sizeof(*scq), GFP_KERNEL);\n\tif (!scq)\n\t\treturn NULL;\n        scq->org = dma_alloc_coherent(&card->pcidev->dev,\n\t\t\t\t      2 * size,  &scq->dma, GFP_KERNEL);\n\tif (!scq->org) {\n\t\tkfree(scq);\n\t\treturn NULL;\n\t}\n\tscq->skb = kcalloc(size / NS_SCQE_SIZE, sizeof(*scq->skb),\n\t\t\t   GFP_KERNEL);\n\tif (!scq->skb) {\n\t\tdma_free_coherent(&card->pcidev->dev,\n\t\t\t\t  2 * size, scq->org, scq->dma);\n\t\tkfree(scq);\n\t\treturn NULL;\n\t}\n\tscq->num_entries = size / NS_SCQE_SIZE;\n\tscq->base = PTR_ALIGN(scq->org, size);\n\tscq->next = scq->base;\n\tscq->last = scq->base + (scq->num_entries - 1);\n\tscq->tail = scq->last;\n\tscq->scd = scd;\n\tscq->tbd_count = 0;\n\tinit_waitqueue_head(&scq->scqfull_waitq);\n\tscq->full = 0;\n\tspin_lock_init(&scq->lock);\n\n\treturn scq;\n}\n\n \nstatic void free_scq(ns_dev *card, scq_info *scq, struct atm_vcc *vcc)\n{\n\tint i;\n\n\tif (scq->num_entries == VBR_SCQ_NUM_ENTRIES)\n\t\tfor (i = 0; i < scq->num_entries; i++) {\n\t\t\tif (scq->skb[i] != NULL) {\n\t\t\t\tvcc = ATM_SKB(scq->skb[i])->vcc;\n\t\t\t\tif (vcc->pop != NULL)\n\t\t\t\t\tvcc->pop(vcc, scq->skb[i]);\n\t\t\t\telse\n\t\t\t\t\tdev_kfree_skb_any(scq->skb[i]);\n\t\t\t}\n\t} else {\t\t \n\n\t\tif (vcc == NULL) {\n\t\t\tprintk\n\t\t\t    (\"nicstar: free_scq() called with vcc == NULL for fixed rate scq.\");\n\t\t\tfor (i = 0; i < scq->num_entries; i++)\n\t\t\t\tdev_kfree_skb_any(scq->skb[i]);\n\t\t} else\n\t\t\tfor (i = 0; i < scq->num_entries; i++) {\n\t\t\t\tif (scq->skb[i] != NULL) {\n\t\t\t\t\tif (vcc->pop != NULL)\n\t\t\t\t\t\tvcc->pop(vcc, scq->skb[i]);\n\t\t\t\t\telse\n\t\t\t\t\t\tdev_kfree_skb_any(scq->skb[i]);\n\t\t\t\t}\n\t\t\t}\n\t}\n\tkfree(scq->skb);\n\tdma_free_coherent(&card->pcidev->dev,\n\t\t\t  2 * (scq->num_entries == VBR_SCQ_NUM_ENTRIES ?\n\t\t\t       VBR_SCQSIZE : CBR_SCQSIZE),\n\t\t\t  scq->org, scq->dma);\n\tkfree(scq);\n}\n\n \nstatic void push_rxbufs(ns_dev * card, struct sk_buff *skb)\n{\n\tstruct sk_buff *handle1, *handle2;\n\tint id1, id2;\n\tu32 addr1, addr2;\n\tu32 stat;\n\tunsigned long flags;\n\n\t \n\thandle2 = NULL;\n\taddr2 = 0;\n\thandle1 = skb;\n\taddr1 = dma_map_single(&card->pcidev->dev,\n\t\t\t       skb->data,\n\t\t\t       (NS_PRV_BUFTYPE(skb) == BUF_SM\n\t\t\t\t? NS_SMSKBSIZE : NS_LGSKBSIZE),\n\t\t\t       DMA_TO_DEVICE);\n\tNS_PRV_DMA(skb) = addr1;  \n\n#ifdef GENERAL_DEBUG\n\tif (!addr1)\n\t\tprintk(\"nicstar%d: push_rxbufs called with addr1 = 0.\\n\",\n\t\t       card->index);\n#endif  \n\n\tstat = readl(card->membase + STAT);\n\tcard->sbfqc = ns_stat_sfbqc_get(stat);\n\tcard->lbfqc = ns_stat_lfbqc_get(stat);\n\tif (NS_PRV_BUFTYPE(skb) == BUF_SM) {\n\t\tif (!addr2) {\n\t\t\tif (card->sm_addr) {\n\t\t\t\taddr2 = card->sm_addr;\n\t\t\t\thandle2 = card->sm_handle;\n\t\t\t\tcard->sm_addr = 0x00000000;\n\t\t\t\tcard->sm_handle = NULL;\n\t\t\t} else {\t \n\n\t\t\t\tcard->sm_addr = addr1;\n\t\t\t\tcard->sm_handle = handle1;\n\t\t\t}\n\t\t}\n\t} else {\t\t \n\n\t\tif (!addr2) {\n\t\t\tif (card->lg_addr) {\n\t\t\t\taddr2 = card->lg_addr;\n\t\t\t\thandle2 = card->lg_handle;\n\t\t\t\tcard->lg_addr = 0x00000000;\n\t\t\t\tcard->lg_handle = NULL;\n\t\t\t} else {\t \n\n\t\t\t\tcard->lg_addr = addr1;\n\t\t\t\tcard->lg_handle = handle1;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (addr2) {\n\t\tif (NS_PRV_BUFTYPE(skb) == BUF_SM) {\n\t\t\tif (card->sbfqc >= card->sbnr.max) {\n\t\t\t\tskb_unlink(handle1, &card->sbpool.queue);\n\t\t\t\tdev_kfree_skb_any(handle1);\n\t\t\t\tskb_unlink(handle2, &card->sbpool.queue);\n\t\t\t\tdev_kfree_skb_any(handle2);\n\t\t\t\treturn;\n\t\t\t} else\n\t\t\t\tcard->sbfqc += 2;\n\t\t} else {\t \n\n\t\t\tif (card->lbfqc >= card->lbnr.max) {\n\t\t\t\tskb_unlink(handle1, &card->lbpool.queue);\n\t\t\t\tdev_kfree_skb_any(handle1);\n\t\t\t\tskb_unlink(handle2, &card->lbpool.queue);\n\t\t\t\tdev_kfree_skb_any(handle2);\n\t\t\t\treturn;\n\t\t\t} else\n\t\t\t\tcard->lbfqc += 2;\n\t\t}\n\n\t\tid1 = idr_alloc(&card->idr, handle1, 0, 0, GFP_ATOMIC);\n\t\tif (id1 < 0)\n\t\t\tgoto out;\n\n\t\tid2 = idr_alloc(&card->idr, handle2, 0, 0, GFP_ATOMIC);\n\t\tif (id2 < 0)\n\t\t\tgoto out;\n\n\t\tspin_lock_irqsave(&card->res_lock, flags);\n\t\twhile (CMD_BUSY(card)) ;\n\t\twritel(addr2, card->membase + DR3);\n\t\twritel(id2, card->membase + DR2);\n\t\twritel(addr1, card->membase + DR1);\n\t\twritel(id1, card->membase + DR0);\n\t\twritel(NS_CMD_WRITE_FREEBUFQ | NS_PRV_BUFTYPE(skb),\n\t\t       card->membase + CMD);\n\t\tspin_unlock_irqrestore(&card->res_lock, flags);\n\n\t\tXPRINTK(\"nicstar%d: Pushing %s buffers at 0x%x and 0x%x.\\n\",\n\t\t\tcard->index,\n\t\t\t(NS_PRV_BUFTYPE(skb) == BUF_SM ? \"small\" : \"large\"),\n\t\t\taddr1, addr2);\n\t}\n\n\tif (!card->efbie && card->sbfqc >= card->sbnr.min &&\n\t    card->lbfqc >= card->lbnr.min) {\n\t\tcard->efbie = 1;\n\t\twritel((readl(card->membase + CFG) | NS_CFG_EFBIE),\n\t\t       card->membase + CFG);\n\t}\n\nout:\n\treturn;\n}\n\nstatic irqreturn_t ns_irq_handler(int irq, void *dev_id)\n{\n\tu32 stat_r;\n\tns_dev *card;\n\tstruct atm_dev *dev;\n\tunsigned long flags;\n\n\tcard = (ns_dev *) dev_id;\n\tdev = card->atmdev;\n\tcard->intcnt++;\n\n\tPRINTK(\"nicstar%d: NICStAR generated an interrupt\\n\", card->index);\n\n\tspin_lock_irqsave(&card->int_lock, flags);\n\n\tstat_r = readl(card->membase + STAT);\n\n\t \n\tif (stat_r & NS_STAT_TSIF) {\n\t\tTXPRINTK(\"nicstar%d: TSI interrupt\\n\", card->index);\n\t\tprocess_tsq(card);\n\t\twritel(NS_STAT_TSIF, card->membase + STAT);\n\t}\n\n\t \n\tif (stat_r & NS_STAT_TXICP) {\n\t\twritel(NS_STAT_TXICP, card->membase + STAT);\n\t\tTXPRINTK(\"nicstar%d: Incomplete CS-PDU transmitted.\\n\",\n\t\t\t card->index);\n\t}\n\n\t \n\tif (stat_r & NS_STAT_TSQF) {\n\t\twritel(NS_STAT_TSQF, card->membase + STAT);\n\t\tPRINTK(\"nicstar%d: TSQ full.\\n\", card->index);\n\t\tprocess_tsq(card);\n\t}\n\n\t \n\tif (stat_r & NS_STAT_TMROF) {\n\t\twritel(NS_STAT_TMROF, card->membase + STAT);\n\t\tPRINTK(\"nicstar%d: Timer overflow.\\n\", card->index);\n\t}\n\n\t \n\tif (stat_r & NS_STAT_PHYI) {\n\t\twritel(NS_STAT_PHYI, card->membase + STAT);\n\t\tPRINTK(\"nicstar%d: PHY interrupt.\\n\", card->index);\n\t\tif (dev->phy && dev->phy->interrupt) {\n\t\t\tdev->phy->interrupt(dev);\n\t\t}\n\t}\n\n\t \n\tif (stat_r & NS_STAT_SFBQF) {\n\t\twritel(NS_STAT_SFBQF, card->membase + STAT);\n\t\tprintk(\"nicstar%d: Small free buffer queue is full.\\n\",\n\t\t       card->index);\n\t}\n\n\t \n\tif (stat_r & NS_STAT_LFBQF) {\n\t\twritel(NS_STAT_LFBQF, card->membase + STAT);\n\t\tprintk(\"nicstar%d: Large free buffer queue is full.\\n\",\n\t\t       card->index);\n\t}\n\n\t \n\tif (stat_r & NS_STAT_RSQF) {\n\t\twritel(NS_STAT_RSQF, card->membase + STAT);\n\t\tprintk(\"nicstar%d: RSQ full.\\n\", card->index);\n\t\tprocess_rsq(card);\n\t}\n\n\t \n\tif (stat_r & NS_STAT_EOPDU) {\n\t\tRXPRINTK(\"nicstar%d: End of CS-PDU received.\\n\", card->index);\n\t\tprocess_rsq(card);\n\t\twritel(NS_STAT_EOPDU, card->membase + STAT);\n\t}\n\n\t \n\tif (stat_r & NS_STAT_RAWCF) {\n\t\twritel(NS_STAT_RAWCF, card->membase + STAT);\n#ifndef RCQ_SUPPORT\n\t\tprintk(\"nicstar%d: Raw cell received and no support yet...\\n\",\n\t\t       card->index);\n#endif  \n\t\t \n\t\twhile (readl(card->membase + RAWCT) != card->rawch) {\n\n\t\t\tif (ns_rcqe_islast(card->rawcell)) {\n\t\t\t\tstruct sk_buff *oldbuf;\n\n\t\t\t\toldbuf = card->rcbuf;\n\t\t\t\tcard->rcbuf = idr_find(&card->idr,\n\t\t\t\t\t\t       ns_rcqe_nextbufhandle(card->rawcell));\n\t\t\t\tcard->rawch = NS_PRV_DMA(card->rcbuf);\n\t\t\t\tcard->rawcell = (struct ns_rcqe *)\n\t\t\t\t\t\tcard->rcbuf->data;\n\t\t\t\trecycle_rx_buf(card, oldbuf);\n\t\t\t} else {\n\t\t\t\tcard->rawch += NS_RCQE_SIZE;\n\t\t\t\tcard->rawcell++;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tif (stat_r & NS_STAT_SFBQE) {\n\t\tint i;\n\t\tstruct sk_buff *sb;\n\n\t\twritel(NS_STAT_SFBQE, card->membase + STAT);\n\t\tprintk(\"nicstar%d: Small free buffer queue empty.\\n\",\n\t\t       card->index);\n\t\tfor (i = 0; i < card->sbnr.min; i++) {\n\t\t\tsb = dev_alloc_skb(NS_SMSKBSIZE);\n\t\t\tif (sb == NULL) {\n\t\t\t\twritel(readl(card->membase + CFG) &\n\t\t\t\t       ~NS_CFG_EFBIE, card->membase + CFG);\n\t\t\t\tcard->efbie = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tNS_PRV_BUFTYPE(sb) = BUF_SM;\n\t\t\tskb_queue_tail(&card->sbpool.queue, sb);\n\t\t\tskb_reserve(sb, NS_AAL0_HEADER);\n\t\t\tpush_rxbufs(card, sb);\n\t\t}\n\t\tcard->sbfqc = i;\n\t\tprocess_rsq(card);\n\t}\n\n\t \n\tif (stat_r & NS_STAT_LFBQE) {\n\t\tint i;\n\t\tstruct sk_buff *lb;\n\n\t\twritel(NS_STAT_LFBQE, card->membase + STAT);\n\t\tprintk(\"nicstar%d: Large free buffer queue empty.\\n\",\n\t\t       card->index);\n\t\tfor (i = 0; i < card->lbnr.min; i++) {\n\t\t\tlb = dev_alloc_skb(NS_LGSKBSIZE);\n\t\t\tif (lb == NULL) {\n\t\t\t\twritel(readl(card->membase + CFG) &\n\t\t\t\t       ~NS_CFG_EFBIE, card->membase + CFG);\n\t\t\t\tcard->efbie = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tNS_PRV_BUFTYPE(lb) = BUF_LG;\n\t\t\tskb_queue_tail(&card->lbpool.queue, lb);\n\t\t\tskb_reserve(lb, NS_SMBUFSIZE);\n\t\t\tpush_rxbufs(card, lb);\n\t\t}\n\t\tcard->lbfqc = i;\n\t\tprocess_rsq(card);\n\t}\n\n\t \n\tif (stat_r & NS_STAT_RSQAF) {\n\t\twritel(NS_STAT_RSQAF, card->membase + STAT);\n\t\tRXPRINTK(\"nicstar%d: RSQ almost full.\\n\", card->index);\n\t\tprocess_rsq(card);\n\t}\n\n\tspin_unlock_irqrestore(&card->int_lock, flags);\n\tPRINTK(\"nicstar%d: end of interrupt service\\n\", card->index);\n\treturn IRQ_HANDLED;\n}\n\nstatic int ns_open(struct atm_vcc *vcc)\n{\n\tns_dev *card;\n\tvc_map *vc;\n\tunsigned long tmpl, modl;\n\tint tcr, tcra;\t\t \n\tint n = 0;\t\t \n\tu32 u32d[4];\n\tint frscdi = 0;\t\t \n\tint inuse;\t\t \n\tshort vpi = vcc->vpi;\n\tint vci = vcc->vci;\n\n\tcard = (ns_dev *) vcc->dev->dev_data;\n\tPRINTK(\"nicstar%d: opening vpi.vci %d.%d \\n\", card->index, (int)vpi,\n\t       vci);\n\tif (vcc->qos.aal != ATM_AAL5 && vcc->qos.aal != ATM_AAL0) {\n\t\tPRINTK(\"nicstar%d: unsupported AAL.\\n\", card->index);\n\t\treturn -EINVAL;\n\t}\n\n\tvc = &(card->vcmap[vpi << card->vcibits | vci]);\n\tvcc->dev_data = vc;\n\n\tinuse = 0;\n\tif (vcc->qos.txtp.traffic_class != ATM_NONE && vc->tx)\n\t\tinuse = 1;\n\tif (vcc->qos.rxtp.traffic_class != ATM_NONE && vc->rx)\n\t\tinuse += 2;\n\tif (inuse) {\n\t\tprintk(\"nicstar%d: %s vci already in use.\\n\", card->index,\n\t\t       inuse == 1 ? \"tx\" : inuse == 2 ? \"rx\" : \"tx and rx\");\n\t\treturn -EINVAL;\n\t}\n\n\tset_bit(ATM_VF_ADDR, &vcc->flags);\n\n\t \n\tif (!test_bit(ATM_VF_PARTIAL, &vcc->flags)) {\n\t\tscq_info *scq;\n\n\t\tset_bit(ATM_VF_PARTIAL, &vcc->flags);\n\t\tif (vcc->qos.txtp.traffic_class == ATM_CBR) {\n\t\t\t \n\t\t\tif (vcc->qos.txtp.max_pcr == 0 && vcc->qos.txtp.pcr == 0\n\t\t\t    && vcc->qos.txtp.min_pcr == 0) {\n\t\t\t\tPRINTK\n\t\t\t\t    (\"nicstar%d: trying to open a CBR vc with cell rate = 0 \\n\",\n\t\t\t\t     card->index);\n\t\t\t\tclear_bit(ATM_VF_PARTIAL, &vcc->flags);\n\t\t\t\tclear_bit(ATM_VF_ADDR, &vcc->flags);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\ttcr = atm_pcr_goal(&(vcc->qos.txtp));\n\t\t\ttcra = tcr >= 0 ? tcr : -tcr;\n\n\t\t\tPRINTK(\"nicstar%d: target cell rate = %d.\\n\",\n\t\t\t       card->index, vcc->qos.txtp.max_pcr);\n\n\t\t\ttmpl =\n\t\t\t    (unsigned long)tcra *(unsigned long)\n\t\t\t    NS_TST_NUM_ENTRIES;\n\t\t\tmodl = tmpl % card->max_pcr;\n\n\t\t\tn = (int)(tmpl / card->max_pcr);\n\t\t\tif (tcr > 0) {\n\t\t\t\tif (modl > 0)\n\t\t\t\t\tn++;\n\t\t\t} else if (tcr == 0) {\n\t\t\t\tif ((n =\n\t\t\t\t     (card->tst_free_entries -\n\t\t\t\t      NS_TST_RESERVED)) <= 0) {\n\t\t\t\t\tPRINTK\n\t\t\t\t\t    (\"nicstar%d: no CBR bandwidth free.\\n\",\n\t\t\t\t\t     card->index);\n\t\t\t\t\tclear_bit(ATM_VF_PARTIAL, &vcc->flags);\n\t\t\t\t\tclear_bit(ATM_VF_ADDR, &vcc->flags);\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (n == 0) {\n\t\t\t\tprintk\n\t\t\t\t    (\"nicstar%d: selected bandwidth < granularity.\\n\",\n\t\t\t\t     card->index);\n\t\t\t\tclear_bit(ATM_VF_PARTIAL, &vcc->flags);\n\t\t\t\tclear_bit(ATM_VF_ADDR, &vcc->flags);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tif (n > (card->tst_free_entries - NS_TST_RESERVED)) {\n\t\t\t\tPRINTK\n\t\t\t\t    (\"nicstar%d: not enough free CBR bandwidth.\\n\",\n\t\t\t\t     card->index);\n\t\t\t\tclear_bit(ATM_VF_PARTIAL, &vcc->flags);\n\t\t\t\tclear_bit(ATM_VF_ADDR, &vcc->flags);\n\t\t\t\treturn -EINVAL;\n\t\t\t} else\n\t\t\t\tcard->tst_free_entries -= n;\n\n\t\t\tXPRINTK(\"nicstar%d: writing %d tst entries.\\n\",\n\t\t\t\tcard->index, n);\n\t\t\tfor (frscdi = 0; frscdi < NS_FRSCD_NUM; frscdi++) {\n\t\t\t\tif (card->scd2vc[frscdi] == NULL) {\n\t\t\t\t\tcard->scd2vc[frscdi] = vc;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (frscdi == NS_FRSCD_NUM) {\n\t\t\t\tPRINTK\n\t\t\t\t    (\"nicstar%d: no SCD available for CBR channel.\\n\",\n\t\t\t\t     card->index);\n\t\t\t\tcard->tst_free_entries += n;\n\t\t\t\tclear_bit(ATM_VF_PARTIAL, &vcc->flags);\n\t\t\t\tclear_bit(ATM_VF_ADDR, &vcc->flags);\n\t\t\t\treturn -EBUSY;\n\t\t\t}\n\n\t\t\tvc->cbr_scd = NS_FRSCD + frscdi * NS_FRSCD_SIZE;\n\n\t\t\tscq = get_scq(card, CBR_SCQSIZE, vc->cbr_scd);\n\t\t\tif (scq == NULL) {\n\t\t\t\tPRINTK(\"nicstar%d: can't get fixed rate SCQ.\\n\",\n\t\t\t\t       card->index);\n\t\t\t\tcard->scd2vc[frscdi] = NULL;\n\t\t\t\tcard->tst_free_entries += n;\n\t\t\t\tclear_bit(ATM_VF_PARTIAL, &vcc->flags);\n\t\t\t\tclear_bit(ATM_VF_ADDR, &vcc->flags);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t\tvc->scq = scq;\n\t\t\tu32d[0] = scq_virt_to_bus(scq, scq->base);\n\t\t\tu32d[1] = (u32) 0x00000000;\n\t\t\tu32d[2] = (u32) 0xffffffff;\n\t\t\tu32d[3] = (u32) 0x00000000;\n\t\t\tns_write_sram(card, vc->cbr_scd, u32d, 4);\n\n\t\t\tfill_tst(card, n, vc);\n\t\t} else if (vcc->qos.txtp.traffic_class == ATM_UBR) {\n\t\t\tvc->cbr_scd = 0x00000000;\n\t\t\tvc->scq = card->scq0;\n\t\t}\n\n\t\tif (vcc->qos.txtp.traffic_class != ATM_NONE) {\n\t\t\tvc->tx = 1;\n\t\t\tvc->tx_vcc = vcc;\n\t\t\tvc->tbd_count = 0;\n\t\t}\n\t\tif (vcc->qos.rxtp.traffic_class != ATM_NONE) {\n\t\t\tu32 status;\n\n\t\t\tvc->rx = 1;\n\t\t\tvc->rx_vcc = vcc;\n\t\t\tvc->rx_iov = NULL;\n\n\t\t\t \n\t\t\tif (vcc->qos.aal == ATM_AAL5)\n\t\t\t\tstatus = NS_RCTE_AAL5 | NS_RCTE_CONNECTOPEN;\n\t\t\telse\t \n\t\t\t\tstatus = NS_RCTE_AAL0 | NS_RCTE_CONNECTOPEN;\n#ifdef RCQ_SUPPORT\n\t\t\tstatus |= NS_RCTE_RAWCELLINTEN;\n#endif  \n\t\t\tns_write_sram(card,\n\t\t\t\t      NS_RCT +\n\t\t\t\t      (vpi << card->vcibits | vci) *\n\t\t\t\t      NS_RCT_ENTRY_SIZE, &status, 1);\n\t\t}\n\n\t}\n\n\tset_bit(ATM_VF_READY, &vcc->flags);\n\treturn 0;\n}\n\nstatic void ns_close(struct atm_vcc *vcc)\n{\n\tvc_map *vc;\n\tns_dev *card;\n\tu32 data;\n\tint i;\n\n\tvc = vcc->dev_data;\n\tcard = vcc->dev->dev_data;\n\tPRINTK(\"nicstar%d: closing vpi.vci %d.%d \\n\", card->index,\n\t       (int)vcc->vpi, vcc->vci);\n\n\tclear_bit(ATM_VF_READY, &vcc->flags);\n\n\tif (vcc->qos.rxtp.traffic_class != ATM_NONE) {\n\t\tu32 addr;\n\t\tunsigned long flags;\n\n\t\taddr =\n\t\t    NS_RCT +\n\t\t    (vcc->vpi << card->vcibits | vcc->vci) * NS_RCT_ENTRY_SIZE;\n\t\tspin_lock_irqsave(&card->res_lock, flags);\n\t\twhile (CMD_BUSY(card)) ;\n\t\twritel(NS_CMD_CLOSE_CONNECTION | addr << 2,\n\t\t       card->membase + CMD);\n\t\tspin_unlock_irqrestore(&card->res_lock, flags);\n\n\t\tvc->rx = 0;\n\t\tif (vc->rx_iov != NULL) {\n\t\t\tstruct sk_buff *iovb;\n\t\t\tu32 stat;\n\n\t\t\tstat = readl(card->membase + STAT);\n\t\t\tcard->sbfqc = ns_stat_sfbqc_get(stat);\n\t\t\tcard->lbfqc = ns_stat_lfbqc_get(stat);\n\n\t\t\tPRINTK\n\t\t\t    (\"nicstar%d: closing a VC with pending rx buffers.\\n\",\n\t\t\t     card->index);\n\t\t\tiovb = vc->rx_iov;\n\t\t\trecycle_iovec_rx_bufs(card, (struct iovec *)iovb->data,\n\t\t\t\t\t      NS_PRV_IOVCNT(iovb));\n\t\t\tNS_PRV_IOVCNT(iovb) = 0;\n\t\t\tspin_lock_irqsave(&card->int_lock, flags);\n\t\t\trecycle_iov_buf(card, iovb);\n\t\t\tspin_unlock_irqrestore(&card->int_lock, flags);\n\t\t\tvc->rx_iov = NULL;\n\t\t}\n\t}\n\n\tif (vcc->qos.txtp.traffic_class != ATM_NONE) {\n\t\tvc->tx = 0;\n\t}\n\n\tif (vcc->qos.txtp.traffic_class == ATM_CBR) {\n\t\tunsigned long flags;\n\t\tns_scqe *scqep;\n\t\tscq_info *scq;\n\n\t\tscq = vc->scq;\n\n\t\tfor (;;) {\n\t\t\tspin_lock_irqsave(&scq->lock, flags);\n\t\t\tscqep = scq->next;\n\t\t\tif (scqep == scq->base)\n\t\t\t\tscqep = scq->last;\n\t\t\telse\n\t\t\t\tscqep--;\n\t\t\tif (scqep == scq->tail) {\n\t\t\t\tspin_unlock_irqrestore(&scq->lock, flags);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t \n\t\t\tif (!ns_scqe_is_tsr(scqep) && scq->tail != scq->next) {\n\t\t\t\tns_scqe tsr;\n\t\t\t\tu32 scdi, scqi;\n\t\t\t\tu32 data;\n\t\t\t\tint index;\n\n\t\t\t\ttsr.word_1 = ns_tsr_mkword_1(NS_TSR_INTENABLE);\n\t\t\t\tscdi = (vc->cbr_scd - NS_FRSCD) / NS_FRSCD_SIZE;\n\t\t\t\tscqi = scq->next - scq->base;\n\t\t\t\ttsr.word_2 = ns_tsr_mkword_2(scdi, scqi);\n\t\t\t\ttsr.word_3 = 0x00000000;\n\t\t\t\ttsr.word_4 = 0x00000000;\n\t\t\t\t*scq->next = tsr;\n\t\t\t\tindex = (int)scqi;\n\t\t\t\tscq->skb[index] = NULL;\n\t\t\t\tif (scq->next == scq->last)\n\t\t\t\t\tscq->next = scq->base;\n\t\t\t\telse\n\t\t\t\t\tscq->next++;\n\t\t\t\tdata = scq_virt_to_bus(scq, scq->next);\n\t\t\t\tns_write_sram(card, scq->scd, &data, 1);\n\t\t\t}\n\t\t\tspin_unlock_irqrestore(&scq->lock, flags);\n\t\t\tschedule();\n\t\t}\n\n\t\t \n\t\tdata = NS_TST_OPCODE_VARIABLE;\n\t\tfor (i = 0; i < NS_TST_NUM_ENTRIES; i++) {\n\t\t\tif (card->tste2vc[i] == vc) {\n\t\t\t\tns_write_sram(card, card->tst_addr + i, &data,\n\t\t\t\t\t      1);\n\t\t\t\tcard->tste2vc[i] = NULL;\n\t\t\t\tcard->tst_free_entries++;\n\t\t\t}\n\t\t}\n\n\t\tcard->scd2vc[(vc->cbr_scd - NS_FRSCD) / NS_FRSCD_SIZE] = NULL;\n\t\tfree_scq(card, vc->scq, vcc);\n\t}\n\n\t \n\tif (vcc->qos.txtp.traffic_class != ATM_NONE) {\n\t\tunsigned long flags;\n\t\tscq_info *scq = card->scq0;\n\n\t\tspin_lock_irqsave(&scq->lock, flags);\n\n\t\tfor (i = 0; i < scq->num_entries; i++) {\n\t\t\tif (scq->skb[i] && ATM_SKB(scq->skb[i])->vcc == vcc) {\n\t\t\t\tATM_SKB(scq->skb[i])->vcc = NULL;\n\t\t\t\tatm_return(vcc, scq->skb[i]->truesize);\n\t\t\t\tPRINTK\n\t\t\t\t    (\"nicstar: deleted pending vcc mapping\\n\");\n\t\t\t}\n\t\t}\n\n\t\tspin_unlock_irqrestore(&scq->lock, flags);\n\t}\n\n\tvcc->dev_data = NULL;\n\tclear_bit(ATM_VF_PARTIAL, &vcc->flags);\n\tclear_bit(ATM_VF_ADDR, &vcc->flags);\n\n#ifdef RX_DEBUG\n\t{\n\t\tu32 stat, cfg;\n\t\tstat = readl(card->membase + STAT);\n\t\tcfg = readl(card->membase + CFG);\n\t\tprintk(\"STAT = 0x%08X  CFG = 0x%08X  \\n\", stat, cfg);\n\t\tprintk\n\t\t    (\"TSQ: base = 0x%p  next = 0x%p  last = 0x%p  TSQT = 0x%08X \\n\",\n\t\t     card->tsq.base, card->tsq.next,\n\t\t     card->tsq.last, readl(card->membase + TSQT));\n\t\tprintk\n\t\t    (\"RSQ: base = 0x%p  next = 0x%p  last = 0x%p  RSQT = 0x%08X \\n\",\n\t\t     card->rsq.base, card->rsq.next,\n\t\t     card->rsq.last, readl(card->membase + RSQT));\n\t\tprintk(\"Empty free buffer queue interrupt %s \\n\",\n\t\t       card->efbie ? \"enabled\" : \"disabled\");\n\t\tprintk(\"SBCNT = %d  count = %d   LBCNT = %d count = %d \\n\",\n\t\t       ns_stat_sfbqc_get(stat), card->sbpool.count,\n\t\t       ns_stat_lfbqc_get(stat), card->lbpool.count);\n\t\tprintk(\"hbpool.count = %d  iovpool.count = %d \\n\",\n\t\t       card->hbpool.count, card->iovpool.count);\n\t}\n#endif  \n}\n\nstatic void fill_tst(ns_dev * card, int n, vc_map * vc)\n{\n\tu32 new_tst;\n\tunsigned long cl;\n\tint e, r;\n\tu32 data;\n\n\t \n\n\tnew_tst = card->tst_addr;\n\n\t \n\n\tfor (e = 0; e < NS_TST_NUM_ENTRIES; e++) {\n\t\tif (card->tste2vc[e] == NULL)\n\t\t\tbreak;\n\t}\n\tif (e == NS_TST_NUM_ENTRIES) {\n\t\tprintk(\"nicstar%d: No free TST entries found. \\n\", card->index);\n\t\treturn;\n\t}\n\n\tr = n;\n\tcl = NS_TST_NUM_ENTRIES;\n\tdata = ns_tste_make(NS_TST_OPCODE_FIXED, vc->cbr_scd);\n\n\twhile (r > 0) {\n\t\tif (cl >= NS_TST_NUM_ENTRIES && card->tste2vc[e] == NULL) {\n\t\t\tcard->tste2vc[e] = vc;\n\t\t\tns_write_sram(card, new_tst + e, &data, 1);\n\t\t\tcl -= NS_TST_NUM_ENTRIES;\n\t\t\tr--;\n\t\t}\n\n\t\tif (++e == NS_TST_NUM_ENTRIES) {\n\t\t\te = 0;\n\t\t}\n\t\tcl += n;\n\t}\n\n\t \n\n\tdata = ns_tste_make(NS_TST_OPCODE_END, new_tst);\n\tns_write_sram(card, new_tst + NS_TST_NUM_ENTRIES, &data, 1);\n\tns_write_sram(card, card->tst_addr + NS_TST_NUM_ENTRIES, &data, 1);\n\tcard->tst_addr = new_tst;\n}\n\nstatic int _ns_send(struct atm_vcc *vcc, struct sk_buff *skb, bool may_sleep)\n{\n\tns_dev *card;\n\tvc_map *vc;\n\tscq_info *scq;\n\tunsigned long buflen;\n\tns_scqe scqe;\n\tu32 flags;\t\t \n\n\tcard = vcc->dev->dev_data;\n\tTXPRINTK(\"nicstar%d: ns_send() called.\\n\", card->index);\n\tif ((vc = (vc_map *) vcc->dev_data) == NULL) {\n\t\tprintk(\"nicstar%d: vcc->dev_data == NULL on ns_send().\\n\",\n\t\t       card->index);\n\t\tatomic_inc(&vcc->stats->tx_err);\n\t\tdev_kfree_skb_any(skb);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!vc->tx) {\n\t\tprintk(\"nicstar%d: Trying to transmit on a non-tx VC.\\n\",\n\t\t       card->index);\n\t\tatomic_inc(&vcc->stats->tx_err);\n\t\tdev_kfree_skb_any(skb);\n\t\treturn -EINVAL;\n\t}\n\n\tif (vcc->qos.aal != ATM_AAL5 && vcc->qos.aal != ATM_AAL0) {\n\t\tprintk(\"nicstar%d: Only AAL0 and AAL5 are supported.\\n\",\n\t\t       card->index);\n\t\tatomic_inc(&vcc->stats->tx_err);\n\t\tdev_kfree_skb_any(skb);\n\t\treturn -EINVAL;\n\t}\n\n\tif (skb_shinfo(skb)->nr_frags != 0) {\n\t\tprintk(\"nicstar%d: No scatter-gather yet.\\n\", card->index);\n\t\tatomic_inc(&vcc->stats->tx_err);\n\t\tdev_kfree_skb_any(skb);\n\t\treturn -EINVAL;\n\t}\n\n\tATM_SKB(skb)->vcc = vcc;\n\n\tNS_PRV_DMA(skb) = dma_map_single(&card->pcidev->dev, skb->data,\n\t\t\t\t\t skb->len, DMA_TO_DEVICE);\n\n\tif (vcc->qos.aal == ATM_AAL5) {\n\t\tbuflen = (skb->len + 47 + 8) / 48 * 48;\t \n\t\tflags = NS_TBD_AAL5;\n\t\tscqe.word_2 = cpu_to_le32(NS_PRV_DMA(skb));\n\t\tscqe.word_3 = cpu_to_le32(skb->len);\n\t\tscqe.word_4 =\n\t\t    ns_tbd_mkword_4(0, (u32) vcc->vpi, (u32) vcc->vci, 0,\n\t\t\t\t    ATM_SKB(skb)->\n\t\t\t\t    atm_options & ATM_ATMOPT_CLP ? 1 : 0);\n\t\tflags |= NS_TBD_EOPDU;\n\t} else {\t\t \n\n\t\tbuflen = ATM_CELL_PAYLOAD;\t \n\t\tflags = NS_TBD_AAL0;\n\t\tscqe.word_2 = cpu_to_le32(NS_PRV_DMA(skb) + NS_AAL0_HEADER);\n\t\tscqe.word_3 = cpu_to_le32(0x00000000);\n\t\tif (*skb->data & 0x02)\t \n\t\t\tflags |= NS_TBD_EOPDU;\n\t\tscqe.word_4 =\n\t\t    cpu_to_le32(*((u32 *) skb->data) & ~NS_TBD_VC_MASK);\n\t\t \n\t\tscqe.word_4 |=\n\t\t    cpu_to_le32((((u32) vcc->\n\t\t\t\t  vpi) << NS_TBD_VPI_SHIFT | ((u32) vcc->\n\t\t\t\t\t\t\t      vci) <<\n\t\t\t\t NS_TBD_VCI_SHIFT) & NS_TBD_VC_MASK);\n\t}\n\n\tif (vcc->qos.txtp.traffic_class == ATM_CBR) {\n\t\tscqe.word_1 = ns_tbd_mkword_1_novbr(flags, (u32) buflen);\n\t\tscq = ((vc_map *) vcc->dev_data)->scq;\n\t} else {\n\t\tscqe.word_1 =\n\t\t    ns_tbd_mkword_1(flags, (u32) 1, (u32) 1, (u32) buflen);\n\t\tscq = card->scq0;\n\t}\n\n\tif (push_scqe(card, vc, scq, &scqe, skb, may_sleep) != 0) {\n\t\tatomic_inc(&vcc->stats->tx_err);\n\t\tdma_unmap_single(&card->pcidev->dev, NS_PRV_DMA(skb), skb->len,\n\t\t\t\t DMA_TO_DEVICE);\n\t\tdev_kfree_skb_any(skb);\n\t\treturn -EIO;\n\t}\n\tatomic_inc(&vcc->stats->tx);\n\n\treturn 0;\n}\n\nstatic int ns_send(struct atm_vcc *vcc, struct sk_buff *skb)\n{\n\treturn _ns_send(vcc, skb, true);\n}\n\nstatic int ns_send_bh(struct atm_vcc *vcc, struct sk_buff *skb)\n{\n\treturn _ns_send(vcc, skb, false);\n}\n\nstatic int push_scqe(ns_dev * card, vc_map * vc, scq_info * scq, ns_scqe * tbd,\n\t\t     struct sk_buff *skb, bool may_sleep)\n{\n\tunsigned long flags;\n\tns_scqe tsr;\n\tu32 scdi, scqi;\n\tint scq_is_vbr;\n\tu32 data;\n\tint index;\n\n\tspin_lock_irqsave(&scq->lock, flags);\n\twhile (scq->tail == scq->next) {\n\t\tif (!may_sleep) {\n\t\t\tspin_unlock_irqrestore(&scq->lock, flags);\n\t\t\tprintk(\"nicstar%d: Error pushing TBD.\\n\", card->index);\n\t\t\treturn 1;\n\t\t}\n\n\t\tscq->full = 1;\n\t\twait_event_interruptible_lock_irq_timeout(scq->scqfull_waitq,\n\t\t\t\t\t\t\t  scq->tail != scq->next,\n\t\t\t\t\t\t\t  scq->lock,\n\t\t\t\t\t\t\t  SCQFULL_TIMEOUT);\n\n\t\tif (scq->full) {\n\t\t\tspin_unlock_irqrestore(&scq->lock, flags);\n\t\t\tprintk(\"nicstar%d: Timeout pushing TBD.\\n\",\n\t\t\t       card->index);\n\t\t\treturn 1;\n\t\t}\n\t}\n\t*scq->next = *tbd;\n\tindex = (int)(scq->next - scq->base);\n\tscq->skb[index] = skb;\n\tXPRINTK(\"nicstar%d: sending skb at 0x%p (pos %d).\\n\",\n\t\tcard->index, skb, index);\n\tXPRINTK(\"nicstar%d: TBD written:\\n0x%x\\n0x%x\\n0x%x\\n0x%x\\n at 0x%p.\\n\",\n\t\tcard->index, le32_to_cpu(tbd->word_1), le32_to_cpu(tbd->word_2),\n\t\tle32_to_cpu(tbd->word_3), le32_to_cpu(tbd->word_4),\n\t\tscq->next);\n\tif (scq->next == scq->last)\n\t\tscq->next = scq->base;\n\telse\n\t\tscq->next++;\n\n\tvc->tbd_count++;\n\tif (scq->num_entries == VBR_SCQ_NUM_ENTRIES) {\n\t\tscq->tbd_count++;\n\t\tscq_is_vbr = 1;\n\t} else\n\t\tscq_is_vbr = 0;\n\n\tif (vc->tbd_count >= MAX_TBD_PER_VC\n\t    || scq->tbd_count >= MAX_TBD_PER_SCQ) {\n\t\tint has_run = 0;\n\n\t\twhile (scq->tail == scq->next) {\n\t\t\tif (!may_sleep) {\n\t\t\t\tdata = scq_virt_to_bus(scq, scq->next);\n\t\t\t\tns_write_sram(card, scq->scd, &data, 1);\n\t\t\t\tspin_unlock_irqrestore(&scq->lock, flags);\n\t\t\t\tprintk(\"nicstar%d: Error pushing TSR.\\n\",\n\t\t\t\t       card->index);\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tscq->full = 1;\n\t\t\tif (has_run++)\n\t\t\t\tbreak;\n\t\t\twait_event_interruptible_lock_irq_timeout(scq->scqfull_waitq,\n\t\t\t\t\t\t\t\t  scq->tail != scq->next,\n\t\t\t\t\t\t\t\t  scq->lock,\n\t\t\t\t\t\t\t\t  SCQFULL_TIMEOUT);\n\t\t}\n\n\t\tif (!scq->full) {\n\t\t\ttsr.word_1 = ns_tsr_mkword_1(NS_TSR_INTENABLE);\n\t\t\tif (scq_is_vbr)\n\t\t\t\tscdi = NS_TSR_SCDISVBR;\n\t\t\telse\n\t\t\t\tscdi = (vc->cbr_scd - NS_FRSCD) / NS_FRSCD_SIZE;\n\t\t\tscqi = scq->next - scq->base;\n\t\t\ttsr.word_2 = ns_tsr_mkword_2(scdi, scqi);\n\t\t\ttsr.word_3 = 0x00000000;\n\t\t\ttsr.word_4 = 0x00000000;\n\n\t\t\t*scq->next = tsr;\n\t\t\tindex = (int)scqi;\n\t\t\tscq->skb[index] = NULL;\n\t\t\tXPRINTK\n\t\t\t    (\"nicstar%d: TSR written:\\n0x%x\\n0x%x\\n0x%x\\n0x%x\\n at 0x%p.\\n\",\n\t\t\t     card->index, le32_to_cpu(tsr.word_1),\n\t\t\t     le32_to_cpu(tsr.word_2), le32_to_cpu(tsr.word_3),\n\t\t\t     le32_to_cpu(tsr.word_4), scq->next);\n\t\t\tif (scq->next == scq->last)\n\t\t\t\tscq->next = scq->base;\n\t\t\telse\n\t\t\t\tscq->next++;\n\t\t\tvc->tbd_count = 0;\n\t\t\tscq->tbd_count = 0;\n\t\t} else\n\t\t\tPRINTK(\"nicstar%d: Timeout pushing TSR.\\n\",\n\t\t\t       card->index);\n\t}\n\tdata = scq_virt_to_bus(scq, scq->next);\n\tns_write_sram(card, scq->scd, &data, 1);\n\n\tspin_unlock_irqrestore(&scq->lock, flags);\n\n\treturn 0;\n}\n\nstatic void process_tsq(ns_dev * card)\n{\n\tu32 scdi;\n\tscq_info *scq;\n\tns_tsi *previous = NULL, *one_ahead, *two_ahead;\n\tint serviced_entries;\t \n\n\tserviced_entries = 0;\n\n\tif (card->tsq.next == card->tsq.last)\n\t\tone_ahead = card->tsq.base;\n\telse\n\t\tone_ahead = card->tsq.next + 1;\n\n\tif (one_ahead == card->tsq.last)\n\t\ttwo_ahead = card->tsq.base;\n\telse\n\t\ttwo_ahead = one_ahead + 1;\n\n\twhile (!ns_tsi_isempty(card->tsq.next) || !ns_tsi_isempty(one_ahead) ||\n\t       !ns_tsi_isempty(two_ahead))\n\t\t \n\t{\n\t\tserviced_entries = 1;\n\n\t\t \n\t\twhile (ns_tsi_isempty(card->tsq.next)) {\n\t\t\tif (card->tsq.next == card->tsq.last)\n\t\t\t\tcard->tsq.next = card->tsq.base;\n\t\t\telse\n\t\t\t\tcard->tsq.next++;\n\t\t}\n\n\t\tif (!ns_tsi_tmrof(card->tsq.next)) {\n\t\t\tscdi = ns_tsi_getscdindex(card->tsq.next);\n\t\t\tif (scdi == NS_TSI_SCDISVBR)\n\t\t\t\tscq = card->scq0;\n\t\t\telse {\n\t\t\t\tif (card->scd2vc[scdi] == NULL) {\n\t\t\t\t\tprintk\n\t\t\t\t\t    (\"nicstar%d: could not find VC from SCD index.\\n\",\n\t\t\t\t\t     card->index);\n\t\t\t\t\tns_tsi_init(card->tsq.next);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tscq = card->scd2vc[scdi]->scq;\n\t\t\t}\n\t\t\tdrain_scq(card, scq, ns_tsi_getscqpos(card->tsq.next));\n\t\t\tscq->full = 0;\n\t\t\twake_up_interruptible(&(scq->scqfull_waitq));\n\t\t}\n\n\t\tns_tsi_init(card->tsq.next);\n\t\tprevious = card->tsq.next;\n\t\tif (card->tsq.next == card->tsq.last)\n\t\t\tcard->tsq.next = card->tsq.base;\n\t\telse\n\t\t\tcard->tsq.next++;\n\n\t\tif (card->tsq.next == card->tsq.last)\n\t\t\tone_ahead = card->tsq.base;\n\t\telse\n\t\t\tone_ahead = card->tsq.next + 1;\n\n\t\tif (one_ahead == card->tsq.last)\n\t\t\ttwo_ahead = card->tsq.base;\n\t\telse\n\t\t\ttwo_ahead = one_ahead + 1;\n\t}\n\n\tif (serviced_entries)\n\t\twritel(PTR_DIFF(previous, card->tsq.base),\n\t\t       card->membase + TSQH);\n}\n\nstatic void drain_scq(ns_dev * card, scq_info * scq, int pos)\n{\n\tstruct atm_vcc *vcc;\n\tstruct sk_buff *skb;\n\tint i;\n\tunsigned long flags;\n\n\tXPRINTK(\"nicstar%d: drain_scq() called, scq at 0x%p, pos %d.\\n\",\n\t\tcard->index, scq, pos);\n\tif (pos >= scq->num_entries) {\n\t\tprintk(\"nicstar%d: Bad index on drain_scq().\\n\", card->index);\n\t\treturn;\n\t}\n\n\tspin_lock_irqsave(&scq->lock, flags);\n\ti = (int)(scq->tail - scq->base);\n\tif (++i == scq->num_entries)\n\t\ti = 0;\n\twhile (i != pos) {\n\t\tskb = scq->skb[i];\n\t\tXPRINTK(\"nicstar%d: freeing skb at 0x%p (index %d).\\n\",\n\t\t\tcard->index, skb, i);\n\t\tif (skb != NULL) {\n\t\t\tdma_unmap_single(&card->pcidev->dev,\n\t\t\t\t\t NS_PRV_DMA(skb),\n\t\t\t\t\t skb->len,\n\t\t\t\t\t DMA_TO_DEVICE);\n\t\t\tvcc = ATM_SKB(skb)->vcc;\n\t\t\tif (vcc && vcc->pop != NULL) {\n\t\t\t\tvcc->pop(vcc, skb);\n\t\t\t} else {\n\t\t\t\tdev_kfree_skb_irq(skb);\n\t\t\t}\n\t\t\tscq->skb[i] = NULL;\n\t\t}\n\t\tif (++i == scq->num_entries)\n\t\t\ti = 0;\n\t}\n\tscq->tail = scq->base + pos;\n\tspin_unlock_irqrestore(&scq->lock, flags);\n}\n\nstatic void process_rsq(ns_dev * card)\n{\n\tns_rsqe *previous;\n\n\tif (!ns_rsqe_valid(card->rsq.next))\n\t\treturn;\n\tdo {\n\t\tdequeue_rx(card, card->rsq.next);\n\t\tns_rsqe_init(card->rsq.next);\n\t\tprevious = card->rsq.next;\n\t\tif (card->rsq.next == card->rsq.last)\n\t\t\tcard->rsq.next = card->rsq.base;\n\t\telse\n\t\t\tcard->rsq.next++;\n\t} while (ns_rsqe_valid(card->rsq.next));\n\twritel(PTR_DIFF(previous, card->rsq.base), card->membase + RSQH);\n}\n\nstatic void dequeue_rx(ns_dev * card, ns_rsqe * rsqe)\n{\n\tu32 vpi, vci;\n\tvc_map *vc;\n\tstruct sk_buff *iovb;\n\tstruct iovec *iov;\n\tstruct atm_vcc *vcc;\n\tstruct sk_buff *skb;\n\tunsigned short aal5_len;\n\tint len;\n\tu32 stat;\n\tu32 id;\n\n\tstat = readl(card->membase + STAT);\n\tcard->sbfqc = ns_stat_sfbqc_get(stat);\n\tcard->lbfqc = ns_stat_lfbqc_get(stat);\n\n\tid = le32_to_cpu(rsqe->buffer_handle);\n\tskb = idr_remove(&card->idr, id);\n\tif (!skb) {\n\t\tRXPRINTK(KERN_ERR\n\t\t\t \"nicstar%d: skb not found!\\n\", card->index);\n\t\treturn;\n\t}\n\tdma_sync_single_for_cpu(&card->pcidev->dev,\n\t\t\t\tNS_PRV_DMA(skb),\n\t\t\t\t(NS_PRV_BUFTYPE(skb) == BUF_SM\n\t\t\t\t ? NS_SMSKBSIZE : NS_LGSKBSIZE),\n\t\t\t\tDMA_FROM_DEVICE);\n\tdma_unmap_single(&card->pcidev->dev,\n\t\t\t NS_PRV_DMA(skb),\n\t\t\t (NS_PRV_BUFTYPE(skb) == BUF_SM\n\t\t\t  ? NS_SMSKBSIZE : NS_LGSKBSIZE),\n\t\t\t DMA_FROM_DEVICE);\n\tvpi = ns_rsqe_vpi(rsqe);\n\tvci = ns_rsqe_vci(rsqe);\n\tif (vpi >= 1UL << card->vpibits || vci >= 1UL << card->vcibits) {\n\t\tprintk(\"nicstar%d: SDU received for out-of-range vc %d.%d.\\n\",\n\t\t       card->index, vpi, vci);\n\t\trecycle_rx_buf(card, skb);\n\t\treturn;\n\t}\n\n\tvc = &(card->vcmap[vpi << card->vcibits | vci]);\n\tif (!vc->rx) {\n\t\tRXPRINTK(\"nicstar%d: SDU received on non-rx vc %d.%d.\\n\",\n\t\t\t card->index, vpi, vci);\n\t\trecycle_rx_buf(card, skb);\n\t\treturn;\n\t}\n\n\tvcc = vc->rx_vcc;\n\n\tif (vcc->qos.aal == ATM_AAL0) {\n\t\tstruct sk_buff *sb;\n\t\tunsigned char *cell;\n\t\tint i;\n\n\t\tcell = skb->data;\n\t\tfor (i = ns_rsqe_cellcount(rsqe); i; i--) {\n\t\t\tsb = dev_alloc_skb(NS_SMSKBSIZE);\n\t\t\tif (!sb) {\n\t\t\t\tprintk\n\t\t\t\t    (\"nicstar%d: Can't allocate buffers for aal0.\\n\",\n\t\t\t\t     card->index);\n\t\t\t\tatomic_add(i, &vcc->stats->rx_drop);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!atm_charge(vcc, sb->truesize)) {\n\t\t\t\tRXPRINTK\n\t\t\t\t    (\"nicstar%d: atm_charge() dropped aal0 packets.\\n\",\n\t\t\t\t     card->index);\n\t\t\t\tatomic_add(i - 1, &vcc->stats->rx_drop);\t \n\t\t\t\tdev_kfree_skb_any(sb);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t \n\t\t\t*((u32 *) sb->data) = le32_to_cpu(rsqe->word_1) << 4 |\n\t\t\t    (ns_rsqe_clp(rsqe) ? 0x00000001 : 0x00000000);\n\t\t\tif (i == 1 && ns_rsqe_eopdu(rsqe))\n\t\t\t\t*((u32 *) sb->data) |= 0x00000002;\n\t\t\tskb_put(sb, NS_AAL0_HEADER);\n\t\t\tmemcpy(skb_tail_pointer(sb), cell, ATM_CELL_PAYLOAD);\n\t\t\tskb_put(sb, ATM_CELL_PAYLOAD);\n\t\t\tATM_SKB(sb)->vcc = vcc;\n\t\t\t__net_timestamp(sb);\n\t\t\tvcc->push(vcc, sb);\n\t\t\tatomic_inc(&vcc->stats->rx);\n\t\t\tcell += ATM_CELL_PAYLOAD;\n\t\t}\n\n\t\trecycle_rx_buf(card, skb);\n\t\treturn;\n\t}\n\n\t \n\n\tif ((iovb = vc->rx_iov) == NULL) {\n\t\tiovb = skb_dequeue(&(card->iovpool.queue));\n\t\tif (iovb == NULL) {\t \n\t\t\tiovb = alloc_skb(NS_IOVBUFSIZE, GFP_ATOMIC);\n\t\t\tif (iovb == NULL) {\n\t\t\t\tprintk(\"nicstar%d: Out of iovec buffers.\\n\",\n\t\t\t\t       card->index);\n\t\t\t\tatomic_inc(&vcc->stats->rx_drop);\n\t\t\t\trecycle_rx_buf(card, skb);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tNS_PRV_BUFTYPE(iovb) = BUF_NONE;\n\t\t} else if (--card->iovpool.count < card->iovnr.min) {\n\t\t\tstruct sk_buff *new_iovb;\n\t\t\tif ((new_iovb =\n\t\t\t     alloc_skb(NS_IOVBUFSIZE, GFP_ATOMIC)) != NULL) {\n\t\t\t\tNS_PRV_BUFTYPE(iovb) = BUF_NONE;\n\t\t\t\tskb_queue_tail(&card->iovpool.queue, new_iovb);\n\t\t\t\tcard->iovpool.count++;\n\t\t\t}\n\t\t}\n\t\tvc->rx_iov = iovb;\n\t\tNS_PRV_IOVCNT(iovb) = 0;\n\t\tiovb->len = 0;\n\t\tiovb->data = iovb->head;\n\t\tskb_reset_tail_pointer(iovb);\n\t\t \n\t} else if (NS_PRV_IOVCNT(iovb) >= NS_MAX_IOVECS) {\n\t\tprintk(\"nicstar%d: received too big AAL5 SDU.\\n\", card->index);\n\t\tatomic_inc(&vcc->stats->rx_err);\n\t\trecycle_iovec_rx_bufs(card, (struct iovec *)iovb->data,\n\t\t\t\t      NS_MAX_IOVECS);\n\t\tNS_PRV_IOVCNT(iovb) = 0;\n\t\tiovb->len = 0;\n\t\tiovb->data = iovb->head;\n\t\tskb_reset_tail_pointer(iovb);\n\t}\n\tiov = &((struct iovec *)iovb->data)[NS_PRV_IOVCNT(iovb)++];\n\tiov->iov_base = (void *)skb;\n\tiov->iov_len = ns_rsqe_cellcount(rsqe) * 48;\n\tiovb->len += iov->iov_len;\n\n#ifdef EXTRA_DEBUG\n\tif (NS_PRV_IOVCNT(iovb) == 1) {\n\t\tif (NS_PRV_BUFTYPE(skb) != BUF_SM) {\n\t\t\tprintk\n\t\t\t    (\"nicstar%d: Expected a small buffer, and this is not one.\\n\",\n\t\t\t     card->index);\n\t\t\twhich_list(card, skb);\n\t\t\tatomic_inc(&vcc->stats->rx_err);\n\t\t\trecycle_rx_buf(card, skb);\n\t\t\tvc->rx_iov = NULL;\n\t\t\trecycle_iov_buf(card, iovb);\n\t\t\treturn;\n\t\t}\n\t} else {\t\t \n\n\t\tif (NS_PRV_BUFTYPE(skb) != BUF_LG) {\n\t\t\tprintk\n\t\t\t    (\"nicstar%d: Expected a large buffer, and this is not one.\\n\",\n\t\t\t     card->index);\n\t\t\twhich_list(card, skb);\n\t\t\tatomic_inc(&vcc->stats->rx_err);\n\t\t\trecycle_iovec_rx_bufs(card, (struct iovec *)iovb->data,\n\t\t\t\t\t      NS_PRV_IOVCNT(iovb));\n\t\t\tvc->rx_iov = NULL;\n\t\t\trecycle_iov_buf(card, iovb);\n\t\t\treturn;\n\t\t}\n\t}\n#endif  \n\n\tif (ns_rsqe_eopdu(rsqe)) {\n\t\t \n\t\tunsigned char *L1L2 = (unsigned char *)\n\t\t\t\t\t\t(skb->data + iov->iov_len - 6);\n\t\taal5_len = L1L2[0] << 8 | L1L2[1];\n\t\tlen = (aal5_len == 0x0000) ? 0x10000 : aal5_len;\n\t\tif (ns_rsqe_crcerr(rsqe) ||\n\t\t    len + 8 > iovb->len || len + (47 + 8) < iovb->len) {\n\t\t\tprintk(\"nicstar%d: AAL5 CRC error\", card->index);\n\t\t\tif (len + 8 > iovb->len || len + (47 + 8) < iovb->len)\n\t\t\t\tprintk(\" - PDU size mismatch.\\n\");\n\t\t\telse\n\t\t\t\tprintk(\".\\n\");\n\t\t\tatomic_inc(&vcc->stats->rx_err);\n\t\t\trecycle_iovec_rx_bufs(card, (struct iovec *)iovb->data,\n\t\t\t\t\t      NS_PRV_IOVCNT(iovb));\n\t\t\tvc->rx_iov = NULL;\n\t\t\trecycle_iov_buf(card, iovb);\n\t\t\treturn;\n\t\t}\n\n\t\t \n\n\t\tif (NS_PRV_IOVCNT(iovb) == 1) {\t \n\t\t\t \n\t\t\tif (!atm_charge(vcc, skb->truesize)) {\n\t\t\t\tpush_rxbufs(card, skb);\n\t\t\t\tatomic_inc(&vcc->stats->rx_drop);\n\t\t\t} else {\n\t\t\t\tskb_put(skb, len);\n\t\t\t\tdequeue_sm_buf(card, skb);\n\t\t\t\tATM_SKB(skb)->vcc = vcc;\n\t\t\t\t__net_timestamp(skb);\n\t\t\t\tvcc->push(vcc, skb);\n\t\t\t\tatomic_inc(&vcc->stats->rx);\n\t\t\t}\n\t\t} else if (NS_PRV_IOVCNT(iovb) == 2) {\t \n\t\t\tstruct sk_buff *sb;\n\n\t\t\tsb = (struct sk_buff *)(iov - 1)->iov_base;\n\t\t\t \n\n\t\t\tif (len <= NS_SMBUFSIZE) {\n\t\t\t\tif (!atm_charge(vcc, sb->truesize)) {\n\t\t\t\t\tpush_rxbufs(card, sb);\n\t\t\t\t\tatomic_inc(&vcc->stats->rx_drop);\n\t\t\t\t} else {\n\t\t\t\t\tskb_put(sb, len);\n\t\t\t\t\tdequeue_sm_buf(card, sb);\n\t\t\t\t\tATM_SKB(sb)->vcc = vcc;\n\t\t\t\t\t__net_timestamp(sb);\n\t\t\t\t\tvcc->push(vcc, sb);\n\t\t\t\t\tatomic_inc(&vcc->stats->rx);\n\t\t\t\t}\n\n\t\t\t\tpush_rxbufs(card, skb);\n\n\t\t\t} else {\t \n\n\t\t\t\tif (!atm_charge(vcc, skb->truesize)) {\n\t\t\t\t\tpush_rxbufs(card, skb);\n\t\t\t\t\tatomic_inc(&vcc->stats->rx_drop);\n\t\t\t\t} else {\n\t\t\t\t\tdequeue_lg_buf(card, skb);\n\t\t\t\t\tskb_push(skb, NS_SMBUFSIZE);\n\t\t\t\t\tskb_copy_from_linear_data(sb, skb->data,\n\t\t\t\t\t\t\t\t  NS_SMBUFSIZE);\n\t\t\t\t\tskb_put(skb, len - NS_SMBUFSIZE);\n\t\t\t\t\tATM_SKB(skb)->vcc = vcc;\n\t\t\t\t\t__net_timestamp(skb);\n\t\t\t\t\tvcc->push(vcc, skb);\n\t\t\t\t\tatomic_inc(&vcc->stats->rx);\n\t\t\t\t}\n\n\t\t\t\tpush_rxbufs(card, sb);\n\n\t\t\t}\n\n\t\t} else {\t \n\n\t\t\tstruct sk_buff *hb, *sb, *lb;\n\t\t\tint remaining, tocopy;\n\t\t\tint j;\n\n\t\t\thb = skb_dequeue(&(card->hbpool.queue));\n\t\t\tif (hb == NULL) {\t \n\n\t\t\t\thb = dev_alloc_skb(NS_HBUFSIZE);\n\t\t\t\tif (hb == NULL) {\n\t\t\t\t\tprintk\n\t\t\t\t\t    (\"nicstar%d: Out of huge buffers.\\n\",\n\t\t\t\t\t     card->index);\n\t\t\t\t\tatomic_inc(&vcc->stats->rx_drop);\n\t\t\t\t\trecycle_iovec_rx_bufs(card,\n\t\t\t\t\t\t\t      (struct iovec *)\n\t\t\t\t\t\t\t      iovb->data,\n\t\t\t\t\t\t\t      NS_PRV_IOVCNT(iovb));\n\t\t\t\t\tvc->rx_iov = NULL;\n\t\t\t\t\trecycle_iov_buf(card, iovb);\n\t\t\t\t\treturn;\n\t\t\t\t} else if (card->hbpool.count < card->hbnr.min) {\n\t\t\t\t\tstruct sk_buff *new_hb;\n\t\t\t\t\tif ((new_hb =\n\t\t\t\t\t     dev_alloc_skb(NS_HBUFSIZE)) !=\n\t\t\t\t\t    NULL) {\n\t\t\t\t\t\tskb_queue_tail(&card->hbpool.\n\t\t\t\t\t\t\t       queue, new_hb);\n\t\t\t\t\t\tcard->hbpool.count++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tNS_PRV_BUFTYPE(hb) = BUF_NONE;\n\t\t\t} else if (--card->hbpool.count < card->hbnr.min) {\n\t\t\t\tstruct sk_buff *new_hb;\n\t\t\t\tif ((new_hb =\n\t\t\t\t     dev_alloc_skb(NS_HBUFSIZE)) != NULL) {\n\t\t\t\t\tNS_PRV_BUFTYPE(new_hb) = BUF_NONE;\n\t\t\t\t\tskb_queue_tail(&card->hbpool.queue,\n\t\t\t\t\t\t       new_hb);\n\t\t\t\t\tcard->hbpool.count++;\n\t\t\t\t}\n\t\t\t\tif (card->hbpool.count < card->hbnr.min) {\n\t\t\t\t\tif ((new_hb =\n\t\t\t\t\t     dev_alloc_skb(NS_HBUFSIZE)) !=\n\t\t\t\t\t    NULL) {\n\t\t\t\t\t\tNS_PRV_BUFTYPE(new_hb) =\n\t\t\t\t\t\t    BUF_NONE;\n\t\t\t\t\t\tskb_queue_tail(&card->hbpool.\n\t\t\t\t\t\t\t       queue, new_hb);\n\t\t\t\t\t\tcard->hbpool.count++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tiov = (struct iovec *)iovb->data;\n\n\t\t\tif (!atm_charge(vcc, hb->truesize)) {\n\t\t\t\trecycle_iovec_rx_bufs(card, iov,\n\t\t\t\t\t\t      NS_PRV_IOVCNT(iovb));\n\t\t\t\tif (card->hbpool.count < card->hbnr.max) {\n\t\t\t\t\tskb_queue_tail(&card->hbpool.queue, hb);\n\t\t\t\t\tcard->hbpool.count++;\n\t\t\t\t} else\n\t\t\t\t\tdev_kfree_skb_any(hb);\n\t\t\t\tatomic_inc(&vcc->stats->rx_drop);\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tsb = (struct sk_buff *)iov->iov_base;\n\t\t\t\tskb_copy_from_linear_data(sb, hb->data,\n\t\t\t\t\t\t\t  iov->iov_len);\n\t\t\t\tskb_put(hb, iov->iov_len);\n\t\t\t\tremaining = len - iov->iov_len;\n\t\t\t\tiov++;\n\t\t\t\t \n\t\t\t\tpush_rxbufs(card, sb);\n\n\t\t\t\t \n\t\t\t\tfor (j = 1; j < NS_PRV_IOVCNT(iovb); j++) {\n\t\t\t\t\tlb = (struct sk_buff *)iov->iov_base;\n\t\t\t\t\ttocopy =\n\t\t\t\t\t    min_t(int, remaining, iov->iov_len);\n\t\t\t\t\tskb_copy_from_linear_data(lb,\n\t\t\t\t\t\t\t\t  skb_tail_pointer\n\t\t\t\t\t\t\t\t  (hb), tocopy);\n\t\t\t\t\tskb_put(hb, tocopy);\n\t\t\t\t\tiov++;\n\t\t\t\t\tremaining -= tocopy;\n\t\t\t\t\tpush_rxbufs(card, lb);\n\t\t\t\t}\n#ifdef EXTRA_DEBUG\n\t\t\t\tif (remaining != 0 || hb->len != len)\n\t\t\t\t\tprintk\n\t\t\t\t\t    (\"nicstar%d: Huge buffer len mismatch.\\n\",\n\t\t\t\t\t     card->index);\n#endif  \n\t\t\t\tATM_SKB(hb)->vcc = vcc;\n\t\t\t\t__net_timestamp(hb);\n\t\t\t\tvcc->push(vcc, hb);\n\t\t\t\tatomic_inc(&vcc->stats->rx);\n\t\t\t}\n\t\t}\n\n\t\tvc->rx_iov = NULL;\n\t\trecycle_iov_buf(card, iovb);\n\t}\n\n}\n\nstatic void recycle_rx_buf(ns_dev * card, struct sk_buff *skb)\n{\n\tif (unlikely(NS_PRV_BUFTYPE(skb) == BUF_NONE)) {\n\t\tprintk(\"nicstar%d: What kind of rx buffer is this?\\n\",\n\t\t       card->index);\n\t\tdev_kfree_skb_any(skb);\n\t} else\n\t\tpush_rxbufs(card, skb);\n}\n\nstatic void recycle_iovec_rx_bufs(ns_dev * card, struct iovec *iov, int count)\n{\n\twhile (count-- > 0)\n\t\trecycle_rx_buf(card, (struct sk_buff *)(iov++)->iov_base);\n}\n\nstatic void recycle_iov_buf(ns_dev * card, struct sk_buff *iovb)\n{\n\tif (card->iovpool.count < card->iovnr.max) {\n\t\tskb_queue_tail(&card->iovpool.queue, iovb);\n\t\tcard->iovpool.count++;\n\t} else\n\t\tdev_kfree_skb_any(iovb);\n}\n\nstatic void dequeue_sm_buf(ns_dev * card, struct sk_buff *sb)\n{\n\tskb_unlink(sb, &card->sbpool.queue);\n\tif (card->sbfqc < card->sbnr.init) {\n\t\tstruct sk_buff *new_sb;\n\t\tif ((new_sb = dev_alloc_skb(NS_SMSKBSIZE)) != NULL) {\n\t\t\tNS_PRV_BUFTYPE(new_sb) = BUF_SM;\n\t\t\tskb_queue_tail(&card->sbpool.queue, new_sb);\n\t\t\tskb_reserve(new_sb, NS_AAL0_HEADER);\n\t\t\tpush_rxbufs(card, new_sb);\n\t\t}\n\t}\n\tif (card->sbfqc < card->sbnr.init)\n\t{\n\t\tstruct sk_buff *new_sb;\n\t\tif ((new_sb = dev_alloc_skb(NS_SMSKBSIZE)) != NULL) {\n\t\t\tNS_PRV_BUFTYPE(new_sb) = BUF_SM;\n\t\t\tskb_queue_tail(&card->sbpool.queue, new_sb);\n\t\t\tskb_reserve(new_sb, NS_AAL0_HEADER);\n\t\t\tpush_rxbufs(card, new_sb);\n\t\t}\n\t}\n}\n\nstatic void dequeue_lg_buf(ns_dev * card, struct sk_buff *lb)\n{\n\tskb_unlink(lb, &card->lbpool.queue);\n\tif (card->lbfqc < card->lbnr.init) {\n\t\tstruct sk_buff *new_lb;\n\t\tif ((new_lb = dev_alloc_skb(NS_LGSKBSIZE)) != NULL) {\n\t\t\tNS_PRV_BUFTYPE(new_lb) = BUF_LG;\n\t\t\tskb_queue_tail(&card->lbpool.queue, new_lb);\n\t\t\tskb_reserve(new_lb, NS_SMBUFSIZE);\n\t\t\tpush_rxbufs(card, new_lb);\n\t\t}\n\t}\n\tif (card->lbfqc < card->lbnr.init)\n\t{\n\t\tstruct sk_buff *new_lb;\n\t\tif ((new_lb = dev_alloc_skb(NS_LGSKBSIZE)) != NULL) {\n\t\t\tNS_PRV_BUFTYPE(new_lb) = BUF_LG;\n\t\t\tskb_queue_tail(&card->lbpool.queue, new_lb);\n\t\t\tskb_reserve(new_lb, NS_SMBUFSIZE);\n\t\t\tpush_rxbufs(card, new_lb);\n\t\t}\n\t}\n}\n\nstatic int ns_proc_read(struct atm_dev *dev, loff_t * pos, char *page)\n{\n\tu32 stat;\n\tns_dev *card;\n\tint left;\n\n\tleft = (int)*pos;\n\tcard = (ns_dev *) dev->dev_data;\n\tstat = readl(card->membase + STAT);\n\tif (!left--)\n\t\treturn sprintf(page, \"Pool   count    min   init    max \\n\");\n\tif (!left--)\n\t\treturn sprintf(page, \"Small  %5d  %5d  %5d  %5d \\n\",\n\t\t\t       ns_stat_sfbqc_get(stat), card->sbnr.min,\n\t\t\t       card->sbnr.init, card->sbnr.max);\n\tif (!left--)\n\t\treturn sprintf(page, \"Large  %5d  %5d  %5d  %5d \\n\",\n\t\t\t       ns_stat_lfbqc_get(stat), card->lbnr.min,\n\t\t\t       card->lbnr.init, card->lbnr.max);\n\tif (!left--)\n\t\treturn sprintf(page, \"Huge   %5d  %5d  %5d  %5d \\n\",\n\t\t\t       card->hbpool.count, card->hbnr.min,\n\t\t\t       card->hbnr.init, card->hbnr.max);\n\tif (!left--)\n\t\treturn sprintf(page, \"Iovec  %5d  %5d  %5d  %5d \\n\",\n\t\t\t       card->iovpool.count, card->iovnr.min,\n\t\t\t       card->iovnr.init, card->iovnr.max);\n\tif (!left--) {\n\t\tint retval;\n\t\tretval =\n\t\t    sprintf(page, \"Interrupt counter: %u \\n\", card->intcnt);\n\t\tcard->intcnt = 0;\n\t\treturn retval;\n\t}\n#if 0\n\t \n\t \n\tif (card->max_pcr == ATM_25_PCR && !left--) {\n\t\tu32 phy_regs[4];\n\t\tu32 i;\n\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\twhile (CMD_BUSY(card)) ;\n\t\t\twritel(NS_CMD_READ_UTILITY | 0x00000200 | i,\n\t\t\t       card->membase + CMD);\n\t\t\twhile (CMD_BUSY(card)) ;\n\t\t\tphy_regs[i] = readl(card->membase + DR0) & 0x000000FF;\n\t\t}\n\n\t\treturn sprintf(page, \"PHY regs: 0x%02X 0x%02X 0x%02X 0x%02X \\n\",\n\t\t\t       phy_regs[0], phy_regs[1], phy_regs[2],\n\t\t\t       phy_regs[3]);\n\t}\n#endif  \n#if 0\n\t \n\tif (left-- < NS_TST_NUM_ENTRIES) {\n\t\tif (card->tste2vc[left + 1] == NULL)\n\t\t\treturn sprintf(page, \"%5d - VBR/UBR \\n\", left + 1);\n\t\telse\n\t\t\treturn sprintf(page, \"%5d - %d %d \\n\", left + 1,\n\t\t\t\t       card->tste2vc[left + 1]->tx_vcc->vpi,\n\t\t\t\t       card->tste2vc[left + 1]->tx_vcc->vci);\n\t}\n#endif  \n\treturn 0;\n}\n\nstatic int ns_ioctl(struct atm_dev *dev, unsigned int cmd, void __user * arg)\n{\n\tns_dev *card;\n\tpool_levels pl;\n\tlong btype;\n\tunsigned long flags;\n\n\tcard = dev->dev_data;\n\tswitch (cmd) {\n\tcase NS_GETPSTAT:\n\t\tif (get_user\n\t\t    (pl.buftype, &((pool_levels __user *) arg)->buftype))\n\t\t\treturn -EFAULT;\n\t\tswitch (pl.buftype) {\n\t\tcase NS_BUFTYPE_SMALL:\n\t\t\tpl.count =\n\t\t\t    ns_stat_sfbqc_get(readl(card->membase + STAT));\n\t\t\tpl.level.min = card->sbnr.min;\n\t\t\tpl.level.init = card->sbnr.init;\n\t\t\tpl.level.max = card->sbnr.max;\n\t\t\tbreak;\n\n\t\tcase NS_BUFTYPE_LARGE:\n\t\t\tpl.count =\n\t\t\t    ns_stat_lfbqc_get(readl(card->membase + STAT));\n\t\t\tpl.level.min = card->lbnr.min;\n\t\t\tpl.level.init = card->lbnr.init;\n\t\t\tpl.level.max = card->lbnr.max;\n\t\t\tbreak;\n\n\t\tcase NS_BUFTYPE_HUGE:\n\t\t\tpl.count = card->hbpool.count;\n\t\t\tpl.level.min = card->hbnr.min;\n\t\t\tpl.level.init = card->hbnr.init;\n\t\t\tpl.level.max = card->hbnr.max;\n\t\t\tbreak;\n\n\t\tcase NS_BUFTYPE_IOVEC:\n\t\t\tpl.count = card->iovpool.count;\n\t\t\tpl.level.min = card->iovnr.min;\n\t\t\tpl.level.init = card->iovnr.init;\n\t\t\tpl.level.max = card->iovnr.max;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\treturn -ENOIOCTLCMD;\n\n\t\t}\n\t\tif (!copy_to_user((pool_levels __user *) arg, &pl, sizeof(pl)))\n\t\t\treturn (sizeof(pl));\n\t\telse\n\t\t\treturn -EFAULT;\n\n\tcase NS_SETBUFLEV:\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\treturn -EPERM;\n\t\tif (copy_from_user(&pl, (pool_levels __user *) arg, sizeof(pl)))\n\t\t\treturn -EFAULT;\n\t\tif (pl.level.min >= pl.level.init\n\t\t    || pl.level.init >= pl.level.max)\n\t\t\treturn -EINVAL;\n\t\tif (pl.level.min == 0)\n\t\t\treturn -EINVAL;\n\t\tswitch (pl.buftype) {\n\t\tcase NS_BUFTYPE_SMALL:\n\t\t\tif (pl.level.max > TOP_SB)\n\t\t\t\treturn -EINVAL;\n\t\t\tcard->sbnr.min = pl.level.min;\n\t\t\tcard->sbnr.init = pl.level.init;\n\t\t\tcard->sbnr.max = pl.level.max;\n\t\t\tbreak;\n\n\t\tcase NS_BUFTYPE_LARGE:\n\t\t\tif (pl.level.max > TOP_LB)\n\t\t\t\treturn -EINVAL;\n\t\t\tcard->lbnr.min = pl.level.min;\n\t\t\tcard->lbnr.init = pl.level.init;\n\t\t\tcard->lbnr.max = pl.level.max;\n\t\t\tbreak;\n\n\t\tcase NS_BUFTYPE_HUGE:\n\t\t\tif (pl.level.max > TOP_HB)\n\t\t\t\treturn -EINVAL;\n\t\t\tcard->hbnr.min = pl.level.min;\n\t\t\tcard->hbnr.init = pl.level.init;\n\t\t\tcard->hbnr.max = pl.level.max;\n\t\t\tbreak;\n\n\t\tcase NS_BUFTYPE_IOVEC:\n\t\t\tif (pl.level.max > TOP_IOVB)\n\t\t\t\treturn -EINVAL;\n\t\t\tcard->iovnr.min = pl.level.min;\n\t\t\tcard->iovnr.init = pl.level.init;\n\t\t\tcard->iovnr.max = pl.level.max;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\n\t\t}\n\t\treturn 0;\n\n\tcase NS_ADJBUFLEV:\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\treturn -EPERM;\n\t\tbtype = (long)arg;\t \n\t\tswitch (btype) {\n\t\tcase NS_BUFTYPE_SMALL:\n\t\t\twhile (card->sbfqc < card->sbnr.init) {\n\t\t\t\tstruct sk_buff *sb;\n\n\t\t\t\tsb = __dev_alloc_skb(NS_SMSKBSIZE, GFP_KERNEL);\n\t\t\t\tif (sb == NULL)\n\t\t\t\t\treturn -ENOMEM;\n\t\t\t\tNS_PRV_BUFTYPE(sb) = BUF_SM;\n\t\t\t\tskb_queue_tail(&card->sbpool.queue, sb);\n\t\t\t\tskb_reserve(sb, NS_AAL0_HEADER);\n\t\t\t\tpush_rxbufs(card, sb);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase NS_BUFTYPE_LARGE:\n\t\t\twhile (card->lbfqc < card->lbnr.init) {\n\t\t\t\tstruct sk_buff *lb;\n\n\t\t\t\tlb = __dev_alloc_skb(NS_LGSKBSIZE, GFP_KERNEL);\n\t\t\t\tif (lb == NULL)\n\t\t\t\t\treturn -ENOMEM;\n\t\t\t\tNS_PRV_BUFTYPE(lb) = BUF_LG;\n\t\t\t\tskb_queue_tail(&card->lbpool.queue, lb);\n\t\t\t\tskb_reserve(lb, NS_SMBUFSIZE);\n\t\t\t\tpush_rxbufs(card, lb);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase NS_BUFTYPE_HUGE:\n\t\t\twhile (card->hbpool.count > card->hbnr.init) {\n\t\t\t\tstruct sk_buff *hb;\n\n\t\t\t\tspin_lock_irqsave(&card->int_lock, flags);\n\t\t\t\thb = skb_dequeue(&card->hbpool.queue);\n\t\t\t\tcard->hbpool.count--;\n\t\t\t\tspin_unlock_irqrestore(&card->int_lock, flags);\n\t\t\t\tif (hb == NULL)\n\t\t\t\t\tprintk\n\t\t\t\t\t    (\"nicstar%d: huge buffer count inconsistent.\\n\",\n\t\t\t\t\t     card->index);\n\t\t\t\telse\n\t\t\t\t\tdev_kfree_skb_any(hb);\n\n\t\t\t}\n\t\t\twhile (card->hbpool.count < card->hbnr.init) {\n\t\t\t\tstruct sk_buff *hb;\n\n\t\t\t\thb = __dev_alloc_skb(NS_HBUFSIZE, GFP_KERNEL);\n\t\t\t\tif (hb == NULL)\n\t\t\t\t\treturn -ENOMEM;\n\t\t\t\tNS_PRV_BUFTYPE(hb) = BUF_NONE;\n\t\t\t\tspin_lock_irqsave(&card->int_lock, flags);\n\t\t\t\tskb_queue_tail(&card->hbpool.queue, hb);\n\t\t\t\tcard->hbpool.count++;\n\t\t\t\tspin_unlock_irqrestore(&card->int_lock, flags);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase NS_BUFTYPE_IOVEC:\n\t\t\twhile (card->iovpool.count > card->iovnr.init) {\n\t\t\t\tstruct sk_buff *iovb;\n\n\t\t\t\tspin_lock_irqsave(&card->int_lock, flags);\n\t\t\t\tiovb = skb_dequeue(&card->iovpool.queue);\n\t\t\t\tcard->iovpool.count--;\n\t\t\t\tspin_unlock_irqrestore(&card->int_lock, flags);\n\t\t\t\tif (iovb == NULL)\n\t\t\t\t\tprintk\n\t\t\t\t\t    (\"nicstar%d: iovec buffer count inconsistent.\\n\",\n\t\t\t\t\t     card->index);\n\t\t\t\telse\n\t\t\t\t\tdev_kfree_skb_any(iovb);\n\n\t\t\t}\n\t\t\twhile (card->iovpool.count < card->iovnr.init) {\n\t\t\t\tstruct sk_buff *iovb;\n\n\t\t\t\tiovb = alloc_skb(NS_IOVBUFSIZE, GFP_KERNEL);\n\t\t\t\tif (iovb == NULL)\n\t\t\t\t\treturn -ENOMEM;\n\t\t\t\tNS_PRV_BUFTYPE(iovb) = BUF_NONE;\n\t\t\t\tspin_lock_irqsave(&card->int_lock, flags);\n\t\t\t\tskb_queue_tail(&card->iovpool.queue, iovb);\n\t\t\t\tcard->iovpool.count++;\n\t\t\t\tspin_unlock_irqrestore(&card->int_lock, flags);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\n\t\t}\n\t\treturn 0;\n\n\tdefault:\n\t\tif (dev->phy && dev->phy->ioctl) {\n\t\t\treturn dev->phy->ioctl(dev, cmd, arg);\n\t\t} else {\n\t\t\tprintk(\"nicstar%d: %s == NULL \\n\", card->index,\n\t\t\t       dev->phy ? \"dev->phy->ioctl\" : \"dev->phy\");\n\t\t\treturn -ENOIOCTLCMD;\n\t\t}\n\t}\n}\n\n#ifdef EXTRA_DEBUG\nstatic void which_list(ns_dev * card, struct sk_buff *skb)\n{\n\tprintk(\"skb buf_type: 0x%08x\\n\", NS_PRV_BUFTYPE(skb));\n}\n#endif  \n\nstatic void ns_poll(struct timer_list *unused)\n{\n\tint i;\n\tns_dev *card;\n\tunsigned long flags;\n\tu32 stat_r, stat_w;\n\n\tPRINTK(\"nicstar: Entering ns_poll().\\n\");\n\tfor (i = 0; i < num_cards; i++) {\n\t\tcard = cards[i];\n\t\tif (!spin_trylock_irqsave(&card->int_lock, flags)) {\n\t\t\t \n\t\t\tcontinue;\n\t\t}\n\n\t\tstat_w = 0;\n\t\tstat_r = readl(card->membase + STAT);\n\t\tif (stat_r & NS_STAT_TSIF)\n\t\t\tstat_w |= NS_STAT_TSIF;\n\t\tif (stat_r & NS_STAT_EOPDU)\n\t\t\tstat_w |= NS_STAT_EOPDU;\n\n\t\tprocess_tsq(card);\n\t\tprocess_rsq(card);\n\n\t\twritel(stat_w, card->membase + STAT);\n\t\tspin_unlock_irqrestore(&card->int_lock, flags);\n\t}\n\tmod_timer(&ns_timer, jiffies + NS_POLL_PERIOD);\n\tPRINTK(\"nicstar: Leaving ns_poll().\\n\");\n}\n\nstatic void ns_phy_put(struct atm_dev *dev, unsigned char value,\n\t\t       unsigned long addr)\n{\n\tns_dev *card;\n\tunsigned long flags;\n\n\tcard = dev->dev_data;\n\tspin_lock_irqsave(&card->res_lock, flags);\n\twhile (CMD_BUSY(card)) ;\n\twritel((u32) value, card->membase + DR0);\n\twritel(NS_CMD_WRITE_UTILITY | 0x00000200 | (addr & 0x000000FF),\n\t       card->membase + CMD);\n\tspin_unlock_irqrestore(&card->res_lock, flags);\n}\n\nstatic unsigned char ns_phy_get(struct atm_dev *dev, unsigned long addr)\n{\n\tns_dev *card;\n\tunsigned long flags;\n\tu32 data;\n\n\tcard = dev->dev_data;\n\tspin_lock_irqsave(&card->res_lock, flags);\n\twhile (CMD_BUSY(card)) ;\n\twritel(NS_CMD_READ_UTILITY | 0x00000200 | (addr & 0x000000FF),\n\t       card->membase + CMD);\n\twhile (CMD_BUSY(card)) ;\n\tdata = readl(card->membase + DR0) & 0x000000FF;\n\tspin_unlock_irqrestore(&card->res_lock, flags);\n\treturn (unsigned char)data;\n}\n\nmodule_init(nicstar_init);\nmodule_exit(nicstar_cleanup);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}