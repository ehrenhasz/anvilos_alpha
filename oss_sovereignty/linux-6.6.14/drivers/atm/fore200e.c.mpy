{
  "module_name": "fore200e.c",
  "hash_id": "6454621e5dfb3b4c54029a2692f07ea1d54d316ce9e8a00a85029369be545807",
  "original_prompt": "Ingested from linux-6.6.14/drivers/atm/fore200e.c",
  "human_readable_source": "\n \n\n\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/capability.h>\n#include <linux/interrupt.h>\n#include <linux/bitops.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/atmdev.h>\n#include <linux/sonet.h>\n#include <linux/dma-mapping.h>\n#include <linux/delay.h>\n#include <linux/firmware.h>\n#include <linux/pgtable.h>\n#include <asm/io.h>\n#include <asm/string.h>\n#include <asm/page.h>\n#include <asm/irq.h>\n#include <asm/dma.h>\n#include <asm/byteorder.h>\n#include <linux/uaccess.h>\n#include <linux/atomic.h>\n\n#ifdef CONFIG_SBUS\n#include <linux/of.h>\n#include <linux/of_device.h>\n#include <asm/idprom.h>\n#include <asm/openprom.h>\n#include <asm/oplib.h>\n#endif\n\n#if defined(CONFIG_ATM_FORE200E_USE_TASKLET)  \n#define FORE200E_USE_TASKLET\n#endif\n\n#if 0  \n#define FORE200E_BSQ_DEBUG\n#endif\n\n#if 1  \n#define FORE200E_52BYTE_AAL0_SDU\n#endif\n\n#include \"fore200e.h\"\n#include \"suni.h\"\n\n#define FORE200E_VERSION \"0.3e\"\n\n#define FORE200E         \"fore200e: \"\n\n#if 0  \n#define CONFIG_ATM_FORE200E_DEBUG 1\n#endif\n#if defined(CONFIG_ATM_FORE200E_DEBUG) && (CONFIG_ATM_FORE200E_DEBUG > 0)\n#define DPRINTK(level, format, args...)  do { if (CONFIG_ATM_FORE200E_DEBUG >= (level)) \\\n                                                  printk(FORE200E format, ##args); } while (0)\n#else\n#define DPRINTK(level, format, args...)  do {} while (0)\n#endif\n\n\n#define FORE200E_ALIGN(addr, alignment) \\\n        ((((unsigned long)(addr) + (alignment - 1)) & ~(alignment - 1)) - (unsigned long)(addr))\n\n#define FORE200E_DMA_INDEX(dma_addr, type, index)  ((dma_addr) + (index) * sizeof(type))\n\n#define FORE200E_INDEX(virt_addr, type, index)     (&((type *)(virt_addr))[ index ])\n\n#define FORE200E_NEXT_ENTRY(index, modulo)         (index = ((index) + 1) % (modulo))\n\n#if 1\n#define ASSERT(expr)     if (!(expr)) { \\\n\t\t\t     printk(FORE200E \"assertion failed! %s[%d]: %s\\n\", \\\n\t\t\t\t    __func__, __LINE__, #expr); \\\n\t\t\t     panic(FORE200E \"%s\", __func__); \\\n\t\t\t }\n#else\n#define ASSERT(expr)     do {} while (0)\n#endif\n\n\nstatic const struct atmdev_ops   fore200e_ops;\n\nstatic LIST_HEAD(fore200e_boards);\n\n\nMODULE_AUTHOR(\"Christophe Lizzi - credits to Uwe Dannowski and Heikki Vatiainen\");\nMODULE_DESCRIPTION(\"FORE Systems 200E-series ATM driver - version \" FORE200E_VERSION);\n\nstatic const int fore200e_rx_buf_nbr[ BUFFER_SCHEME_NBR ][ BUFFER_MAGN_NBR ] = {\n    { BUFFER_S1_NBR, BUFFER_L1_NBR },\n    { BUFFER_S2_NBR, BUFFER_L2_NBR }\n};\n\nstatic const int fore200e_rx_buf_size[ BUFFER_SCHEME_NBR ][ BUFFER_MAGN_NBR ] = {\n    { BUFFER_S1_SIZE, BUFFER_L1_SIZE },\n    { BUFFER_S2_SIZE, BUFFER_L2_SIZE }\n};\n\n\n#if defined(CONFIG_ATM_FORE200E_DEBUG) && (CONFIG_ATM_FORE200E_DEBUG > 0)\nstatic const char* fore200e_traffic_class[] = { \"NONE\", \"UBR\", \"CBR\", \"VBR\", \"ABR\", \"ANY\" };\n#endif\n\n\n#if 0  \nstatic int \nfore200e_fore2atm_aal(enum fore200e_aal aal)\n{\n    switch(aal) {\n    case FORE200E_AAL0:  return ATM_AAL0;\n    case FORE200E_AAL34: return ATM_AAL34;\n    case FORE200E_AAL5:  return ATM_AAL5;\n    }\n\n    return -EINVAL;\n}\n#endif\n\n\nstatic enum fore200e_aal\nfore200e_atm2fore_aal(int aal)\n{\n    switch(aal) {\n    case ATM_AAL0:  return FORE200E_AAL0;\n    case ATM_AAL34: return FORE200E_AAL34;\n    case ATM_AAL1:\n    case ATM_AAL2:\n    case ATM_AAL5:  return FORE200E_AAL5;\n    }\n\n    return -EINVAL;\n}\n\n\nstatic char*\nfore200e_irq_itoa(int irq)\n{\n    static char str[8];\n    sprintf(str, \"%d\", irq);\n    return str;\n}\n\n\n \n\nstatic int\nfore200e_chunk_alloc(struct fore200e* fore200e, struct chunk* chunk, int size, int alignment, int direction)\n{\n    unsigned long offset = 0;\n\n    if (alignment <= sizeof(int))\n\talignment = 0;\n\n    chunk->alloc_size = size + alignment;\n    chunk->direction  = direction;\n\n    chunk->alloc_addr = kzalloc(chunk->alloc_size, GFP_KERNEL);\n    if (chunk->alloc_addr == NULL)\n\treturn -ENOMEM;\n\n    if (alignment > 0)\n\toffset = FORE200E_ALIGN(chunk->alloc_addr, alignment); \n    \n    chunk->align_addr = chunk->alloc_addr + offset;\n\n    chunk->dma_addr = dma_map_single(fore200e->dev, chunk->align_addr,\n\t\t\t\t     size, direction);\n    if (dma_mapping_error(fore200e->dev, chunk->dma_addr)) {\n\tkfree(chunk->alloc_addr);\n\treturn -ENOMEM;\n    }\n    return 0;\n}\n\n\n \n\nstatic void\nfore200e_chunk_free(struct fore200e* fore200e, struct chunk* chunk)\n{\n    dma_unmap_single(fore200e->dev, chunk->dma_addr, chunk->dma_size,\n\t\t     chunk->direction);\n    kfree(chunk->alloc_addr);\n}\n\n \nstatic int\nfore200e_dma_chunk_alloc(struct fore200e *fore200e, struct chunk *chunk,\n\t\tint size, int nbr, int alignment)\n{\n\t \n\tchunk->alloc_size = size * nbr;\n\tchunk->alloc_addr = dma_alloc_coherent(fore200e->dev, chunk->alloc_size,\n\t\t\t\t\t       &chunk->dma_addr, GFP_KERNEL);\n\tif (!chunk->alloc_addr)\n\t\treturn -ENOMEM;\n\tchunk->align_addr = chunk->alloc_addr;\n\treturn 0;\n}\n\n \nstatic void\nfore200e_dma_chunk_free(struct fore200e* fore200e, struct chunk* chunk)\n{\n\tdma_free_coherent(fore200e->dev, chunk->alloc_size, chunk->alloc_addr,\n\t\t\t  chunk->dma_addr);\n}\n\nstatic void\nfore200e_spin(int msecs)\n{\n    unsigned long timeout = jiffies + msecs_to_jiffies(msecs);\n    while (time_before(jiffies, timeout));\n}\n\n\nstatic int\nfore200e_poll(struct fore200e* fore200e, volatile u32* addr, u32 val, int msecs)\n{\n    unsigned long timeout = jiffies + msecs_to_jiffies(msecs);\n    int           ok;\n\n    mb();\n    do {\n\tif ((ok = (*addr == val)) || (*addr & STATUS_ERROR))\n\t    break;\n\n    } while (time_before(jiffies, timeout));\n\n#if 1\n    if (!ok) {\n\tprintk(FORE200E \"cmd polling failed, got status 0x%08x, expected 0x%08x\\n\",\n\t       *addr, val);\n    }\n#endif\n\n    return ok;\n}\n\n\nstatic int\nfore200e_io_poll(struct fore200e* fore200e, volatile u32 __iomem *addr, u32 val, int msecs)\n{\n    unsigned long timeout = jiffies + msecs_to_jiffies(msecs);\n    int           ok;\n\n    do {\n\tif ((ok = (fore200e->bus->read(addr) == val)))\n\t    break;\n\n    } while (time_before(jiffies, timeout));\n\n#if 1\n    if (!ok) {\n\tprintk(FORE200E \"I/O polling failed, got status 0x%08x, expected 0x%08x\\n\",\n\t       fore200e->bus->read(addr), val);\n    }\n#endif\n\n    return ok;\n}\n\n\nstatic void\nfore200e_free_rx_buf(struct fore200e* fore200e)\n{\n    int scheme, magn, nbr;\n    struct buffer* buffer;\n\n    for (scheme = 0; scheme < BUFFER_SCHEME_NBR; scheme++) {\n\tfor (magn = 0; magn < BUFFER_MAGN_NBR; magn++) {\n\n\t    if ((buffer = fore200e->host_bsq[ scheme ][ magn ].buffer) != NULL) {\n\n\t\tfor (nbr = 0; nbr < fore200e_rx_buf_nbr[ scheme ][ magn ]; nbr++) {\n\n\t\t    struct chunk* data = &buffer[ nbr ].data;\n\n\t\t    if (data->alloc_addr != NULL)\n\t\t\tfore200e_chunk_free(fore200e, data);\n\t\t}\n\t    }\n\t}\n    }\n}\n\n\nstatic void\nfore200e_uninit_bs_queue(struct fore200e* fore200e)\n{\n    int scheme, magn;\n    \n    for (scheme = 0; scheme < BUFFER_SCHEME_NBR; scheme++) {\n\tfor (magn = 0; magn < BUFFER_MAGN_NBR; magn++) {\n\n\t    struct chunk* status    = &fore200e->host_bsq[ scheme ][ magn ].status;\n\t    struct chunk* rbd_block = &fore200e->host_bsq[ scheme ][ magn ].rbd_block;\n\t    \n\t    if (status->alloc_addr)\n\t\tfore200e_dma_chunk_free(fore200e, status);\n\t    \n\t    if (rbd_block->alloc_addr)\n\t\tfore200e_dma_chunk_free(fore200e, rbd_block);\n\t}\n    }\n}\n\n\nstatic int\nfore200e_reset(struct fore200e* fore200e, int diag)\n{\n    int ok;\n\n    fore200e->cp_monitor = fore200e->virt_base + FORE200E_CP_MONITOR_OFFSET;\n    \n    fore200e->bus->write(BSTAT_COLD_START, &fore200e->cp_monitor->bstat);\n\n    fore200e->bus->reset(fore200e);\n\n    if (diag) {\n\tok = fore200e_io_poll(fore200e, &fore200e->cp_monitor->bstat, BSTAT_SELFTEST_OK, 1000);\n\tif (ok == 0) {\n\t    \n\t    printk(FORE200E \"device %s self-test failed\\n\", fore200e->name);\n\t    return -ENODEV;\n\t}\n\n\tprintk(FORE200E \"device %s self-test passed\\n\", fore200e->name);\n\t\n\tfore200e->state = FORE200E_STATE_RESET;\n    }\n\n    return 0;\n}\n\n\nstatic void\nfore200e_shutdown(struct fore200e* fore200e)\n{\n    printk(FORE200E \"removing device %s at 0x%lx, IRQ %s\\n\",\n\t   fore200e->name, fore200e->phys_base, \n\t   fore200e_irq_itoa(fore200e->irq));\n    \n    if (fore200e->state > FORE200E_STATE_RESET) {\n\t \n\tfore200e_reset(fore200e, 0);\n    }\n    \n     \n    switch(fore200e->state) {\n\n    case FORE200E_STATE_COMPLETE:\n\tkfree(fore200e->stats);\n\n\tfallthrough;\n    case FORE200E_STATE_IRQ:\n\tfree_irq(fore200e->irq, fore200e->atm_dev);\n\n\tfallthrough;\n    case FORE200E_STATE_ALLOC_BUF:\n\tfore200e_free_rx_buf(fore200e);\n\n\tfallthrough;\n    case FORE200E_STATE_INIT_BSQ:\n\tfore200e_uninit_bs_queue(fore200e);\n\n\tfallthrough;\n    case FORE200E_STATE_INIT_RXQ:\n\tfore200e_dma_chunk_free(fore200e, &fore200e->host_rxq.status);\n\tfore200e_dma_chunk_free(fore200e, &fore200e->host_rxq.rpd);\n\n\tfallthrough;\n    case FORE200E_STATE_INIT_TXQ:\n\tfore200e_dma_chunk_free(fore200e, &fore200e->host_txq.status);\n\tfore200e_dma_chunk_free(fore200e, &fore200e->host_txq.tpd);\n\n\tfallthrough;\n    case FORE200E_STATE_INIT_CMDQ:\n\tfore200e_dma_chunk_free(fore200e, &fore200e->host_cmdq.status);\n\n\tfallthrough;\n    case FORE200E_STATE_INITIALIZE:\n\t \n\n    case FORE200E_STATE_START_FW:\n\t \n\n    case FORE200E_STATE_RESET:\n\t \n\n    case FORE200E_STATE_MAP:\n\tfore200e->bus->unmap(fore200e);\n\n\tfallthrough;\n    case FORE200E_STATE_CONFIGURE:\n\t \n\n    case FORE200E_STATE_REGISTER:\n\t \n\tatm_dev_deregister(fore200e->atm_dev);\n\n\tfallthrough;\n    case FORE200E_STATE_BLANK:\n\t \n\tbreak;\n    }\n}\n\n\n#ifdef CONFIG_PCI\n\nstatic u32 fore200e_pca_read(volatile u32 __iomem *addr)\n{\n     \n    return le32_to_cpu(readl(addr));\n}\n\n\nstatic void fore200e_pca_write(u32 val, volatile u32 __iomem *addr)\n{\n     \n    writel(cpu_to_le32(val), addr);\n}\n\nstatic int\nfore200e_pca_irq_check(struct fore200e* fore200e)\n{\n     \n    int irq_posted = readl(fore200e->regs.pca.psr);\n\n#if defined(CONFIG_ATM_FORE200E_DEBUG) && (CONFIG_ATM_FORE200E_DEBUG == 2)\n    if (irq_posted && (readl(fore200e->regs.pca.hcr) & PCA200E_HCR_OUTFULL)) {\n\tDPRINTK(2,\"FIFO OUT full, device %d\\n\", fore200e->atm_dev->number);\n    }\n#endif\n\n    return irq_posted;\n}\n\n\nstatic void\nfore200e_pca_irq_ack(struct fore200e* fore200e)\n{\n    writel(PCA200E_HCR_CLRINTR, fore200e->regs.pca.hcr);\n}\n\n\nstatic void\nfore200e_pca_reset(struct fore200e* fore200e)\n{\n    writel(PCA200E_HCR_RESET, fore200e->regs.pca.hcr);\n    fore200e_spin(10);\n    writel(0, fore200e->regs.pca.hcr);\n}\n\n\nstatic int fore200e_pca_map(struct fore200e* fore200e)\n{\n    DPRINTK(2, \"device %s being mapped in memory\\n\", fore200e->name);\n\n    fore200e->virt_base = ioremap(fore200e->phys_base, PCA200E_IOSPACE_LENGTH);\n    \n    if (fore200e->virt_base == NULL) {\n\tprintk(FORE200E \"can't map device %s\\n\", fore200e->name);\n\treturn -EFAULT;\n    }\n\n    DPRINTK(1, \"device %s mapped to 0x%p\\n\", fore200e->name, fore200e->virt_base);\n\n     \n    fore200e->regs.pca.hcr = fore200e->virt_base + PCA200E_HCR_OFFSET;\n    fore200e->regs.pca.imr = fore200e->virt_base + PCA200E_IMR_OFFSET;\n    fore200e->regs.pca.psr = fore200e->virt_base + PCA200E_PSR_OFFSET;\n\n    fore200e->state = FORE200E_STATE_MAP;\n    return 0;\n}\n\n\nstatic void\nfore200e_pca_unmap(struct fore200e* fore200e)\n{\n    DPRINTK(2, \"device %s being unmapped from memory\\n\", fore200e->name);\n\n    if (fore200e->virt_base != NULL)\n\tiounmap(fore200e->virt_base);\n}\n\n\nstatic int fore200e_pca_configure(struct fore200e *fore200e)\n{\n    struct pci_dev *pci_dev = to_pci_dev(fore200e->dev);\n    u8              master_ctrl, latency;\n\n    DPRINTK(2, \"device %s being configured\\n\", fore200e->name);\n\n    if ((pci_dev->irq == 0) || (pci_dev->irq == 0xFF)) {\n\tprintk(FORE200E \"incorrect IRQ setting - misconfigured PCI-PCI bridge?\\n\");\n\treturn -EIO;\n    }\n\n    pci_read_config_byte(pci_dev, PCA200E_PCI_MASTER_CTRL, &master_ctrl);\n\n    master_ctrl = master_ctrl\n#if defined(__BIG_ENDIAN)\n\t \n\t| PCA200E_CTRL_CONVERT_ENDIAN\n#endif\n#if 0\n        | PCA200E_CTRL_DIS_CACHE_RD\n        | PCA200E_CTRL_DIS_WRT_INVAL\n        | PCA200E_CTRL_ENA_CONT_REQ_MODE\n        | PCA200E_CTRL_2_CACHE_WRT_INVAL\n#endif\n\t| PCA200E_CTRL_LARGE_PCI_BURSTS;\n    \n    pci_write_config_byte(pci_dev, PCA200E_PCI_MASTER_CTRL, master_ctrl);\n\n     \n    latency = 192;\n    pci_write_config_byte(pci_dev, PCI_LATENCY_TIMER, latency);\n\n    fore200e->state = FORE200E_STATE_CONFIGURE;\n    return 0;\n}\n\n\nstatic int __init\nfore200e_pca_prom_read(struct fore200e* fore200e, struct prom_data* prom)\n{\n    struct host_cmdq*       cmdq  = &fore200e->host_cmdq;\n    struct host_cmdq_entry* entry = &cmdq->host_entry[ cmdq->head ];\n    struct prom_opcode      opcode;\n    int                     ok;\n    u32                     prom_dma;\n\n    FORE200E_NEXT_ENTRY(cmdq->head, QUEUE_SIZE_CMD);\n\n    opcode.opcode = OPCODE_GET_PROM;\n    opcode.pad    = 0;\n\n    prom_dma = dma_map_single(fore200e->dev, prom, sizeof(struct prom_data),\n\t\t\t      DMA_FROM_DEVICE);\n    if (dma_mapping_error(fore200e->dev, prom_dma))\n\treturn -ENOMEM;\n\n    fore200e->bus->write(prom_dma, &entry->cp_entry->cmd.prom_block.prom_haddr);\n    \n    *entry->status = STATUS_PENDING;\n\n    fore200e->bus->write(*(u32*)&opcode, (u32 __iomem *)&entry->cp_entry->cmd.prom_block.opcode);\n\n    ok = fore200e_poll(fore200e, entry->status, STATUS_COMPLETE, 400);\n\n    *entry->status = STATUS_FREE;\n\n    dma_unmap_single(fore200e->dev, prom_dma, sizeof(struct prom_data), DMA_FROM_DEVICE);\n\n    if (ok == 0) {\n\tprintk(FORE200E \"unable to get PROM data from device %s\\n\", fore200e->name);\n\treturn -EIO;\n    }\n\n#if defined(__BIG_ENDIAN)\n    \n#define swap_here(addr) (*((u32*)(addr)) = swab32( *((u32*)(addr)) ))\n\n     \n    swap_here(&prom->mac_addr[0]);\n    swap_here(&prom->mac_addr[4]);\n#endif\n    \n    return 0;\n}\n\n\nstatic int\nfore200e_pca_proc_read(struct fore200e* fore200e, char *page)\n{\n    struct pci_dev *pci_dev = to_pci_dev(fore200e->dev);\n\n    return sprintf(page, \"   PCI bus/slot/function:\\t%d/%d/%d\\n\",\n\t\t   pci_dev->bus->number, PCI_SLOT(pci_dev->devfn), PCI_FUNC(pci_dev->devfn));\n}\n\nstatic const struct fore200e_bus fore200e_pci_ops = {\n\t.model_name\t\t= \"PCA-200E\",\n\t.proc_name\t\t= \"pca200e\",\n\t.descr_alignment\t= 32,\n\t.buffer_alignment\t= 4,\n\t.status_alignment\t= 32,\n\t.read\t\t\t= fore200e_pca_read,\n\t.write\t\t\t= fore200e_pca_write,\n\t.configure\t\t= fore200e_pca_configure,\n\t.map\t\t\t= fore200e_pca_map,\n\t.reset\t\t\t= fore200e_pca_reset,\n\t.prom_read\t\t= fore200e_pca_prom_read,\n\t.unmap\t\t\t= fore200e_pca_unmap,\n\t.irq_check\t\t= fore200e_pca_irq_check,\n\t.irq_ack\t\t= fore200e_pca_irq_ack,\n\t.proc_read\t\t= fore200e_pca_proc_read,\n};\n#endif  \n\n#ifdef CONFIG_SBUS\n\nstatic u32 fore200e_sba_read(volatile u32 __iomem *addr)\n{\n    return sbus_readl(addr);\n}\n\nstatic void fore200e_sba_write(u32 val, volatile u32 __iomem *addr)\n{\n    sbus_writel(val, addr);\n}\n\nstatic void fore200e_sba_irq_enable(struct fore200e *fore200e)\n{\n\tu32 hcr = fore200e->bus->read(fore200e->regs.sba.hcr) & SBA200E_HCR_STICKY;\n\tfore200e->bus->write(hcr | SBA200E_HCR_INTR_ENA, fore200e->regs.sba.hcr);\n}\n\nstatic int fore200e_sba_irq_check(struct fore200e *fore200e)\n{\n\treturn fore200e->bus->read(fore200e->regs.sba.hcr) & SBA200E_HCR_INTR_REQ;\n}\n\nstatic void fore200e_sba_irq_ack(struct fore200e *fore200e)\n{\n\tu32 hcr = fore200e->bus->read(fore200e->regs.sba.hcr) & SBA200E_HCR_STICKY;\n\tfore200e->bus->write(hcr | SBA200E_HCR_INTR_CLR, fore200e->regs.sba.hcr);\n}\n\nstatic void fore200e_sba_reset(struct fore200e *fore200e)\n{\n\tfore200e->bus->write(SBA200E_HCR_RESET, fore200e->regs.sba.hcr);\n\tfore200e_spin(10);\n\tfore200e->bus->write(0, fore200e->regs.sba.hcr);\n}\n\nstatic int __init fore200e_sba_map(struct fore200e *fore200e)\n{\n\tstruct platform_device *op = to_platform_device(fore200e->dev);\n\tunsigned int bursts;\n\n\t \n\tfore200e->regs.sba.hcr = of_ioremap(&op->resource[0], 0, SBA200E_HCR_LENGTH, \"SBA HCR\");\n\tfore200e->regs.sba.bsr = of_ioremap(&op->resource[1], 0, SBA200E_BSR_LENGTH, \"SBA BSR\");\n\tfore200e->regs.sba.isr = of_ioremap(&op->resource[2], 0, SBA200E_ISR_LENGTH, \"SBA ISR\");\n\tfore200e->virt_base    = of_ioremap(&op->resource[3], 0, SBA200E_RAM_LENGTH, \"SBA RAM\");\n\n\tif (!fore200e->virt_base) {\n\t\tprintk(FORE200E \"unable to map RAM of device %s\\n\", fore200e->name);\n\t\treturn -EFAULT;\n\t}\n\n\tDPRINTK(1, \"device %s mapped to 0x%p\\n\", fore200e->name, fore200e->virt_base);\n    \n\tfore200e->bus->write(0x02, fore200e->regs.sba.isr);  \n\n\t \n\tbursts = of_getintprop_default(op->dev.of_node->parent, \"burst-sizes\", 0x00);\n\n\tif (sbus_can_dma_64bit())\n\t\tsbus_set_sbus64(&op->dev, bursts);\n\n\tfore200e->state = FORE200E_STATE_MAP;\n\treturn 0;\n}\n\nstatic void fore200e_sba_unmap(struct fore200e *fore200e)\n{\n\tstruct platform_device *op = to_platform_device(fore200e->dev);\n\n\tof_iounmap(&op->resource[0], fore200e->regs.sba.hcr, SBA200E_HCR_LENGTH);\n\tof_iounmap(&op->resource[1], fore200e->regs.sba.bsr, SBA200E_BSR_LENGTH);\n\tof_iounmap(&op->resource[2], fore200e->regs.sba.isr, SBA200E_ISR_LENGTH);\n\tof_iounmap(&op->resource[3], fore200e->virt_base,    SBA200E_RAM_LENGTH);\n}\n\nstatic int __init fore200e_sba_configure(struct fore200e *fore200e)\n{\n\tfore200e->state = FORE200E_STATE_CONFIGURE;\n\treturn 0;\n}\n\nstatic int __init fore200e_sba_prom_read(struct fore200e *fore200e, struct prom_data *prom)\n{\n\tstruct platform_device *op = to_platform_device(fore200e->dev);\n\tconst u8 *prop;\n\tint len;\n\n\tprop = of_get_property(op->dev.of_node, \"madaddrlo2\", &len);\n\tif (!prop)\n\t\treturn -ENODEV;\n\tmemcpy(&prom->mac_addr[4], prop, 4);\n\n\tprop = of_get_property(op->dev.of_node, \"madaddrhi4\", &len);\n\tif (!prop)\n\t\treturn -ENODEV;\n\tmemcpy(&prom->mac_addr[2], prop, 4);\n\n\tprom->serial_number = of_getintprop_default(op->dev.of_node,\n\t\t\t\t\t\t    \"serialnumber\", 0);\n\tprom->hw_revision = of_getintprop_default(op->dev.of_node,\n\t\t\t\t\t\t  \"promversion\", 0);\n    \n\treturn 0;\n}\n\nstatic int fore200e_sba_proc_read(struct fore200e *fore200e, char *page)\n{\n\tstruct platform_device *op = to_platform_device(fore200e->dev);\n\tconst struct linux_prom_registers *regs;\n\n\tregs = of_get_property(op->dev.of_node, \"reg\", NULL);\n\n\treturn sprintf(page, \"   SBUS slot/device:\\t\\t%d/'%pOFn'\\n\",\n\t\t       (regs ? regs->which_io : 0), op->dev.of_node);\n}\n\nstatic const struct fore200e_bus fore200e_sbus_ops = {\n\t.model_name\t\t= \"SBA-200E\",\n\t.proc_name\t\t= \"sba200e\",\n\t.descr_alignment\t= 32,\n\t.buffer_alignment\t= 64,\n\t.status_alignment\t= 32,\n\t.read\t\t\t= fore200e_sba_read,\n\t.write\t\t\t= fore200e_sba_write,\n\t.configure\t\t= fore200e_sba_configure,\n\t.map\t\t\t= fore200e_sba_map,\n\t.reset\t\t\t= fore200e_sba_reset,\n\t.prom_read\t\t= fore200e_sba_prom_read,\n\t.unmap\t\t\t= fore200e_sba_unmap,\n\t.irq_enable\t\t= fore200e_sba_irq_enable,\n\t.irq_check\t\t= fore200e_sba_irq_check,\n\t.irq_ack\t\t= fore200e_sba_irq_ack,\n\t.proc_read\t\t= fore200e_sba_proc_read,\n};\n#endif  \n\nstatic void\nfore200e_tx_irq(struct fore200e* fore200e)\n{\n    struct host_txq*        txq = &fore200e->host_txq;\n    struct host_txq_entry*  entry;\n    struct atm_vcc*         vcc;\n    struct fore200e_vc_map* vc_map;\n\n    if (fore200e->host_txq.txing == 0)\n\treturn;\n\n    for (;;) {\n\t\n\tentry = &txq->host_entry[ txq->tail ];\n\n        if ((*entry->status & STATUS_COMPLETE) == 0) {\n\t    break;\n\t}\n\n\tDPRINTK(3, \"TX COMPLETED: entry = %p [tail = %d], vc_map = %p, skb = %p\\n\", \n\t\tentry, txq->tail, entry->vc_map, entry->skb);\n\n\t \n\tkfree(entry->data);\n\t\n\t \n\tdma_unmap_single(fore200e->dev, entry->tpd->tsd[ 0 ].buffer, entry->tpd->tsd[ 0 ].length,\n\t\t\t\t DMA_TO_DEVICE);\n\n\tvc_map = entry->vc_map;\n\n\t \n\tif ((vc_map->vcc == NULL) ||\n\t    (test_bit(ATM_VF_READY, &vc_map->vcc->flags) == 0)) {\n\n\t    DPRINTK(1, \"no ready vcc found for PDU sent on device %d\\n\",\n\t\t    fore200e->atm_dev->number);\n\n\t    dev_kfree_skb_any(entry->skb);\n\t}\n\telse {\n\t    ASSERT(vc_map->vcc);\n\n\t     \n\t    if (vc_map->incarn != entry->incarn) {\n\n\t\t \n\n\t\tDPRINTK(1, \"vcc closed-then-re-opened; dropping PDU sent on device %d\\n\",\n\t\t\tfore200e->atm_dev->number);\n\n\t\tdev_kfree_skb_any(entry->skb);\n\t    }\n\t    else {\n\t\tvcc = vc_map->vcc;\n\t\tASSERT(vcc);\n\n\t\t \n\t\tif (vcc->pop) {\n\t\t    vcc->pop(vcc, entry->skb);\n\t\t}\n\t\telse {\n\t\t    dev_kfree_skb_any(entry->skb);\n\t\t}\n\n\t\t \n\t\tif (*entry->status & STATUS_ERROR)\n\t\t    atomic_inc(&vcc->stats->tx_err);\n\t\telse\n\t\t    atomic_inc(&vcc->stats->tx);\n\t    }\n\t}\n\n\t*entry->status = STATUS_FREE;\n\n\tfore200e->host_txq.txing--;\n\n\tFORE200E_NEXT_ENTRY(txq->tail, QUEUE_SIZE_TX);\n    }\n}\n\n\n#ifdef FORE200E_BSQ_DEBUG\nint bsq_audit(int where, struct host_bsq* bsq, int scheme, int magn)\n{\n    struct buffer* buffer;\n    int count = 0;\n\n    buffer = bsq->freebuf;\n    while (buffer) {\n\n\tif (buffer->supplied) {\n\t    printk(FORE200E \"bsq_audit(%d): queue %d.%d, buffer %ld supplied but in free list!\\n\",\n\t\t   where, scheme, magn, buffer->index);\n\t}\n\n\tif (buffer->magn != magn) {\n\t    printk(FORE200E \"bsq_audit(%d): queue %d.%d, buffer %ld, unexpected magn = %d\\n\",\n\t\t   where, scheme, magn, buffer->index, buffer->magn);\n\t}\n\n\tif (buffer->scheme != scheme) {\n\t    printk(FORE200E \"bsq_audit(%d): queue %d.%d, buffer %ld, unexpected scheme = %d\\n\",\n\t\t   where, scheme, magn, buffer->index, buffer->scheme);\n\t}\n\n\tif ((buffer->index < 0) || (buffer->index >= fore200e_rx_buf_nbr[ scheme ][ magn ])) {\n\t    printk(FORE200E \"bsq_audit(%d): queue %d.%d, out of range buffer index = %ld !\\n\",\n\t\t   where, scheme, magn, buffer->index);\n\t}\n\n\tcount++;\n\tbuffer = buffer->next;\n    }\n\n    if (count != bsq->freebuf_count) {\n\tprintk(FORE200E \"bsq_audit(%d): queue %d.%d, %d bufs in free list, but freebuf_count = %d\\n\",\n\t       where, scheme, magn, count, bsq->freebuf_count);\n    }\n    return 0;\n}\n#endif\n\n\nstatic void\nfore200e_supply(struct fore200e* fore200e)\n{\n    int  scheme, magn, i;\n\n    struct host_bsq*       bsq;\n    struct host_bsq_entry* entry;\n    struct buffer*         buffer;\n\n    for (scheme = 0; scheme < BUFFER_SCHEME_NBR; scheme++) {\n\tfor (magn = 0; magn < BUFFER_MAGN_NBR; magn++) {\n\n\t    bsq = &fore200e->host_bsq[ scheme ][ magn ];\n\n#ifdef FORE200E_BSQ_DEBUG\n\t    bsq_audit(1, bsq, scheme, magn);\n#endif\n\t    while (bsq->freebuf_count >= RBD_BLK_SIZE) {\n\n\t\tDPRINTK(2, \"supplying %d rx buffers to queue %d / %d, freebuf_count = %d\\n\",\n\t\t\tRBD_BLK_SIZE, scheme, magn, bsq->freebuf_count);\n\n\t\tentry = &bsq->host_entry[ bsq->head ];\n\n\t\tfor (i = 0; i < RBD_BLK_SIZE; i++) {\n\n\t\t     \n\t\t    buffer = bsq->freebuf;\n\t\t    if (!buffer) {\n\t\t\tprintk(FORE200E \"no more free bufs in queue %d.%d, but freebuf_count = %d\\n\",\n\t\t\t       scheme, magn, bsq->freebuf_count);\n\t\t\treturn;\n\t\t    }\n\t\t    bsq->freebuf = buffer->next;\n\t\t    \n#ifdef FORE200E_BSQ_DEBUG\n\t\t    if (buffer->supplied)\n\t\t\tprintk(FORE200E \"queue %d.%d, buffer %lu already supplied\\n\",\n\t\t\t       scheme, magn, buffer->index);\n\t\t    buffer->supplied = 1;\n#endif\n\t\t    entry->rbd_block->rbd[ i ].buffer_haddr = buffer->data.dma_addr;\n\t\t    entry->rbd_block->rbd[ i ].handle       = FORE200E_BUF2HDL(buffer);\n\t\t}\n\n\t\tFORE200E_NEXT_ENTRY(bsq->head, QUEUE_SIZE_BS);\n\n \t\t \n\t\tbsq->freebuf_count -= RBD_BLK_SIZE;\n\n\t\t*entry->status = STATUS_PENDING;\n\t\tfore200e->bus->write(entry->rbd_block_dma, &entry->cp_entry->rbd_block_haddr);\n\t    }\n\t}\n    }\n}\n\n\nstatic int\nfore200e_push_rpd(struct fore200e* fore200e, struct atm_vcc* vcc, struct rpd* rpd)\n{\n    struct sk_buff*      skb;\n    struct buffer*       buffer;\n    struct fore200e_vcc* fore200e_vcc;\n    int                  i, pdu_len = 0;\n#ifdef FORE200E_52BYTE_AAL0_SDU\n    u32                  cell_header = 0;\n#endif\n\n    ASSERT(vcc);\n    \n    fore200e_vcc = FORE200E_VCC(vcc);\n    ASSERT(fore200e_vcc);\n\n#ifdef FORE200E_52BYTE_AAL0_SDU\n    if ((vcc->qos.aal == ATM_AAL0) && (vcc->qos.rxtp.max_sdu == ATM_AAL0_SDU)) {\n\n\tcell_header = (rpd->atm_header.gfc << ATM_HDR_GFC_SHIFT) |\n\t              (rpd->atm_header.vpi << ATM_HDR_VPI_SHIFT) |\n                      (rpd->atm_header.vci << ATM_HDR_VCI_SHIFT) |\n                      (rpd->atm_header.plt << ATM_HDR_PTI_SHIFT) | \n                       rpd->atm_header.clp;\n\tpdu_len = 4;\n    }\n#endif\n    \n     \n    for (i = 0; i < rpd->nseg; i++)\n\tpdu_len += rpd->rsd[ i ].length;\n    \n    skb = alloc_skb(pdu_len, GFP_ATOMIC);\n    if (skb == NULL) {\n\tDPRINTK(2, \"unable to alloc new skb, rx PDU length = %d\\n\", pdu_len);\n\n\tatomic_inc(&vcc->stats->rx_drop);\n\treturn -ENOMEM;\n    } \n\n    __net_timestamp(skb);\n    \n#ifdef FORE200E_52BYTE_AAL0_SDU\n    if (cell_header) {\n\t*((u32*)skb_put(skb, 4)) = cell_header;\n    }\n#endif\n\n     \n    for (i = 0; i < rpd->nseg; i++) {\n\t\n\t \n\tbuffer = FORE200E_HDL2BUF(rpd->rsd[ i ].handle);\n\t\n\t \n\tdma_sync_single_for_cpu(fore200e->dev, buffer->data.dma_addr,\n\t\t\t\trpd->rsd[i].length, DMA_FROM_DEVICE);\n\t\n\tskb_put_data(skb, buffer->data.align_addr, rpd->rsd[i].length);\n\n\t \n\tdma_sync_single_for_device(fore200e->dev, buffer->data.dma_addr,\n\t\t\t\t   rpd->rsd[i].length, DMA_FROM_DEVICE);\n    }\n\n    DPRINTK(3, \"rx skb: len = %d, truesize = %d\\n\", skb->len, skb->truesize);\n    \n    if (pdu_len < fore200e_vcc->rx_min_pdu)\n\tfore200e_vcc->rx_min_pdu = pdu_len;\n    if (pdu_len > fore200e_vcc->rx_max_pdu)\n\tfore200e_vcc->rx_max_pdu = pdu_len;\n    fore200e_vcc->rx_pdu++;\n\n     \n    if (atm_charge(vcc, skb->truesize) == 0) {\n\n\tDPRINTK(2, \"receive buffers saturated for %d.%d.%d - PDU dropped\\n\",\n\t\tvcc->itf, vcc->vpi, vcc->vci);\n\n\tdev_kfree_skb_any(skb);\n\n\tatomic_inc(&vcc->stats->rx_drop);\n\treturn -ENOMEM;\n    }\n\n    vcc->push(vcc, skb);\n    atomic_inc(&vcc->stats->rx);\n\n    return 0;\n}\n\n\nstatic void\nfore200e_collect_rpd(struct fore200e* fore200e, struct rpd* rpd)\n{\n    struct host_bsq* bsq;\n    struct buffer*   buffer;\n    int              i;\n    \n    for (i = 0; i < rpd->nseg; i++) {\n\n\t \n\tbuffer = FORE200E_HDL2BUF(rpd->rsd[ i ].handle);\n\n\tbsq = &fore200e->host_bsq[ buffer->scheme ][ buffer->magn ];\n\n#ifdef FORE200E_BSQ_DEBUG\n\tbsq_audit(2, bsq, buffer->scheme, buffer->magn);\n\n\tif (buffer->supplied == 0)\n\t    printk(FORE200E \"queue %d.%d, buffer %ld was not supplied\\n\",\n\t\t   buffer->scheme, buffer->magn, buffer->index);\n\tbuffer->supplied = 0;\n#endif\n\n\t \n\tbuffer->next = bsq->freebuf;\n\tbsq->freebuf = buffer;\n\n\t \n\tbsq->freebuf_count++;\n    }\n}\n\n\nstatic void\nfore200e_rx_irq(struct fore200e* fore200e)\n{\n    struct host_rxq*        rxq = &fore200e->host_rxq;\n    struct host_rxq_entry*  entry;\n    struct atm_vcc*         vcc;\n    struct fore200e_vc_map* vc_map;\n\n    for (;;) {\n\t\n\tentry = &rxq->host_entry[ rxq->head ];\n\n\t \n\tif ((*entry->status & STATUS_COMPLETE) == 0)\n\t    break;\n\n\tvc_map = FORE200E_VC_MAP(fore200e, entry->rpd->atm_header.vpi, entry->rpd->atm_header.vci);\n\n\tif ((vc_map->vcc == NULL) ||\n\t    (test_bit(ATM_VF_READY, &vc_map->vcc->flags) == 0)) {\n\n\t    DPRINTK(1, \"no ready VC found for PDU received on %d.%d.%d\\n\",\n\t\t    fore200e->atm_dev->number,\n\t\t    entry->rpd->atm_header.vpi, entry->rpd->atm_header.vci);\n\t}\n\telse {\n\t    vcc = vc_map->vcc;\n\t    ASSERT(vcc);\n\n\t    if ((*entry->status & STATUS_ERROR) == 0) {\n\n\t\tfore200e_push_rpd(fore200e, vcc, entry->rpd);\n\t    }\n\t    else {\n\t\tDPRINTK(2, \"damaged PDU on %d.%d.%d\\n\",\n\t\t\tfore200e->atm_dev->number,\n\t\t\tentry->rpd->atm_header.vpi, entry->rpd->atm_header.vci);\n\t\tatomic_inc(&vcc->stats->rx_err);\n\t    }\n\t}\n\n\tFORE200E_NEXT_ENTRY(rxq->head, QUEUE_SIZE_RX);\n\n\tfore200e_collect_rpd(fore200e, entry->rpd);\n\n\t \n\tfore200e->bus->write(entry->rpd_dma, &entry->cp_entry->rpd_haddr);\n\t*entry->status = STATUS_FREE;\n\n\tfore200e_supply(fore200e);\n    }\n}\n\n\n#ifndef FORE200E_USE_TASKLET\nstatic void\nfore200e_irq(struct fore200e* fore200e)\n{\n    unsigned long flags;\n\n    spin_lock_irqsave(&fore200e->q_lock, flags);\n    fore200e_rx_irq(fore200e);\n    spin_unlock_irqrestore(&fore200e->q_lock, flags);\n\n    spin_lock_irqsave(&fore200e->q_lock, flags);\n    fore200e_tx_irq(fore200e);\n    spin_unlock_irqrestore(&fore200e->q_lock, flags);\n}\n#endif\n\n\nstatic irqreturn_t\nfore200e_interrupt(int irq, void* dev)\n{\n    struct fore200e* fore200e = FORE200E_DEV((struct atm_dev*)dev);\n\n    if (fore200e->bus->irq_check(fore200e) == 0) {\n\t\n\tDPRINTK(3, \"interrupt NOT triggered by device %d\\n\", fore200e->atm_dev->number);\n\treturn IRQ_NONE;\n    }\n    DPRINTK(3, \"interrupt triggered by device %d\\n\", fore200e->atm_dev->number);\n\n#ifdef FORE200E_USE_TASKLET\n    tasklet_schedule(&fore200e->tx_tasklet);\n    tasklet_schedule(&fore200e->rx_tasklet);\n#else\n    fore200e_irq(fore200e);\n#endif\n    \n    fore200e->bus->irq_ack(fore200e);\n    return IRQ_HANDLED;\n}\n\n\n#ifdef FORE200E_USE_TASKLET\nstatic void\nfore200e_tx_tasklet(unsigned long data)\n{\n    struct fore200e* fore200e = (struct fore200e*) data;\n    unsigned long flags;\n\n    DPRINTK(3, \"tx tasklet scheduled for device %d\\n\", fore200e->atm_dev->number);\n\n    spin_lock_irqsave(&fore200e->q_lock, flags);\n    fore200e_tx_irq(fore200e);\n    spin_unlock_irqrestore(&fore200e->q_lock, flags);\n}\n\n\nstatic void\nfore200e_rx_tasklet(unsigned long data)\n{\n    struct fore200e* fore200e = (struct fore200e*) data;\n    unsigned long    flags;\n\n    DPRINTK(3, \"rx tasklet scheduled for device %d\\n\", fore200e->atm_dev->number);\n\n    spin_lock_irqsave(&fore200e->q_lock, flags);\n    fore200e_rx_irq((struct fore200e*) data);\n    spin_unlock_irqrestore(&fore200e->q_lock, flags);\n}\n#endif\n\n\nstatic int\nfore200e_select_scheme(struct atm_vcc* vcc)\n{\n     \n    int scheme = vcc->vci % 2 ? BUFFER_SCHEME_ONE : BUFFER_SCHEME_TWO;\n\n    DPRINTK(1, \"VC %d.%d.%d uses buffer scheme %d\\n\",\n\t    vcc->itf, vcc->vpi, vcc->vci, scheme);\n\n    return scheme;\n}\n\n\nstatic int \nfore200e_activate_vcin(struct fore200e* fore200e, int activate, struct atm_vcc* vcc, int mtu)\n{\n    struct host_cmdq*        cmdq  = &fore200e->host_cmdq;\n    struct host_cmdq_entry*  entry = &cmdq->host_entry[ cmdq->head ];\n    struct activate_opcode   activ_opcode;\n    struct deactivate_opcode deactiv_opcode;\n    struct vpvc              vpvc;\n    int                      ok;\n    enum fore200e_aal        aal = fore200e_atm2fore_aal(vcc->qos.aal);\n\n    FORE200E_NEXT_ENTRY(cmdq->head, QUEUE_SIZE_CMD);\n    \n    if (activate) {\n\tFORE200E_VCC(vcc)->scheme = fore200e_select_scheme(vcc);\n\t\n\tactiv_opcode.opcode = OPCODE_ACTIVATE_VCIN;\n\tactiv_opcode.aal    = aal;\n\tactiv_opcode.scheme = FORE200E_VCC(vcc)->scheme;\n\tactiv_opcode.pad    = 0;\n    }\n    else {\n\tdeactiv_opcode.opcode = OPCODE_DEACTIVATE_VCIN;\n\tdeactiv_opcode.pad    = 0;\n    }\n\n    vpvc.vci = vcc->vci;\n    vpvc.vpi = vcc->vpi;\n\n    *entry->status = STATUS_PENDING;\n\n    if (activate) {\n\n#ifdef FORE200E_52BYTE_AAL0_SDU\n\tmtu = 48;\n#endif\n\t \n\tfore200e->bus->write(mtu,                        &entry->cp_entry->cmd.activate_block.mtu);\n\tfore200e->bus->write(*(u32*)&vpvc,         (u32 __iomem *)&entry->cp_entry->cmd.activate_block.vpvc);\n\tfore200e->bus->write(*(u32*)&activ_opcode, (u32 __iomem *)&entry->cp_entry->cmd.activate_block.opcode);\n    }\n    else {\n\tfore200e->bus->write(*(u32*)&vpvc,         (u32 __iomem *)&entry->cp_entry->cmd.deactivate_block.vpvc);\n\tfore200e->bus->write(*(u32*)&deactiv_opcode, (u32 __iomem *)&entry->cp_entry->cmd.deactivate_block.opcode);\n    }\n\n    ok = fore200e_poll(fore200e, entry->status, STATUS_COMPLETE, 400);\n\n    *entry->status = STATUS_FREE;\n\n    if (ok == 0) {\n\tprintk(FORE200E \"unable to %s VC %d.%d.%d\\n\",\n\t       activate ? \"open\" : \"close\", vcc->itf, vcc->vpi, vcc->vci);\n\treturn -EIO;\n    }\n\n    DPRINTK(1, \"VC %d.%d.%d %sed\\n\", vcc->itf, vcc->vpi, vcc->vci, \n\t    activate ? \"open\" : \"clos\");\n\n    return 0;\n}\n\n\n#define FORE200E_MAX_BACK2BACK_CELLS 255     \n\nstatic void\nfore200e_rate_ctrl(struct atm_qos* qos, struct tpd_rate* rate)\n{\n    if (qos->txtp.max_pcr < ATM_OC3_PCR) {\n    \n\t \n\trate->data_cells = qos->txtp.max_pcr * FORE200E_MAX_BACK2BACK_CELLS / ATM_OC3_PCR;\n\trate->idle_cells = FORE200E_MAX_BACK2BACK_CELLS - rate->data_cells;\n    }\n    else {\n\t \n\trate->data_cells = rate->idle_cells = 0;\n    }\n}\n\n\nstatic int\nfore200e_open(struct atm_vcc *vcc)\n{\n    struct fore200e*        fore200e = FORE200E_DEV(vcc->dev);\n    struct fore200e_vcc*    fore200e_vcc;\n    struct fore200e_vc_map* vc_map;\n    unsigned long\t    flags;\n    int\t\t\t    vci = vcc->vci;\n    short\t\t    vpi = vcc->vpi;\n\n    ASSERT((vpi >= 0) && (vpi < 1<<FORE200E_VPI_BITS));\n    ASSERT((vci >= 0) && (vci < 1<<FORE200E_VCI_BITS));\n\n    spin_lock_irqsave(&fore200e->q_lock, flags);\n\n    vc_map = FORE200E_VC_MAP(fore200e, vpi, vci);\n    if (vc_map->vcc) {\n\n\tspin_unlock_irqrestore(&fore200e->q_lock, flags);\n\n\tprintk(FORE200E \"VC %d.%d.%d already in use\\n\",\n\t       fore200e->atm_dev->number, vpi, vci);\n\n\treturn -EINVAL;\n    }\n\n    vc_map->vcc = vcc;\n\n    spin_unlock_irqrestore(&fore200e->q_lock, flags);\n\n    fore200e_vcc = kzalloc(sizeof(struct fore200e_vcc), GFP_ATOMIC);\n    if (fore200e_vcc == NULL) {\n\tvc_map->vcc = NULL;\n\treturn -ENOMEM;\n    }\n\n    DPRINTK(2, \"opening %d.%d.%d:%d QoS = (tx: cl=%s, pcr=%d-%d, cdv=%d, max_sdu=%d; \"\n\t    \"rx: cl=%s, pcr=%d-%d, cdv=%d, max_sdu=%d)\\n\",\n\t    vcc->itf, vcc->vpi, vcc->vci, fore200e_atm2fore_aal(vcc->qos.aal),\n\t    fore200e_traffic_class[ vcc->qos.txtp.traffic_class ],\n\t    vcc->qos.txtp.min_pcr, vcc->qos.txtp.max_pcr, vcc->qos.txtp.max_cdv, vcc->qos.txtp.max_sdu,\n\t    fore200e_traffic_class[ vcc->qos.rxtp.traffic_class ],\n\t    vcc->qos.rxtp.min_pcr, vcc->qos.rxtp.max_pcr, vcc->qos.rxtp.max_cdv, vcc->qos.rxtp.max_sdu);\n    \n     \n    if ((vcc->qos.txtp.traffic_class == ATM_CBR) && (vcc->qos.txtp.max_pcr > 0)) {\n\t\n\tmutex_lock(&fore200e->rate_mtx);\n\tif (fore200e->available_cell_rate < vcc->qos.txtp.max_pcr) {\n\t    mutex_unlock(&fore200e->rate_mtx);\n\n\t    kfree(fore200e_vcc);\n\t    vc_map->vcc = NULL;\n\t    return -EAGAIN;\n\t}\n\n\t \n\tfore200e->available_cell_rate -= vcc->qos.txtp.max_pcr;\n\tmutex_unlock(&fore200e->rate_mtx);\n    }\n    \n    vcc->itf = vcc->dev->number;\n\n    set_bit(ATM_VF_PARTIAL,&vcc->flags);\n    set_bit(ATM_VF_ADDR, &vcc->flags);\n\n    vcc->dev_data = fore200e_vcc;\n    \n    if (fore200e_activate_vcin(fore200e, 1, vcc, vcc->qos.rxtp.max_sdu) < 0) {\n\n\tvc_map->vcc = NULL;\n\n\tclear_bit(ATM_VF_ADDR, &vcc->flags);\n\tclear_bit(ATM_VF_PARTIAL,&vcc->flags);\n\n\tvcc->dev_data = NULL;\n\n\tfore200e->available_cell_rate += vcc->qos.txtp.max_pcr;\n\n\tkfree(fore200e_vcc);\n\treturn -EINVAL;\n    }\n    \n     \n    if ((vcc->qos.txtp.traffic_class == ATM_CBR) && (vcc->qos.txtp.max_pcr > 0)) {\n\t\n\tfore200e_rate_ctrl(&vcc->qos, &fore200e_vcc->rate);\n\tset_bit(ATM_VF_HASQOS, &vcc->flags);\n\n\tDPRINTK(3, \"tx on %d.%d.%d:%d, tx PCR = %d, rx PCR = %d, data_cells = %u, idle_cells = %u\\n\",\n\t\tvcc->itf, vcc->vpi, vcc->vci, fore200e_atm2fore_aal(vcc->qos.aal),\n\t\tvcc->qos.txtp.max_pcr, vcc->qos.rxtp.max_pcr, \n\t\tfore200e_vcc->rate.data_cells, fore200e_vcc->rate.idle_cells);\n    }\n    \n    fore200e_vcc->tx_min_pdu = fore200e_vcc->rx_min_pdu = MAX_PDU_SIZE + 1;\n    fore200e_vcc->tx_max_pdu = fore200e_vcc->rx_max_pdu = 0;\n    fore200e_vcc->tx_pdu     = fore200e_vcc->rx_pdu     = 0;\n\n     \n    vc_map->incarn = ++fore200e->incarn_count;\n\n     \n    set_bit(ATM_VF_READY, &vcc->flags);\n\n    return 0;\n}\n\n\nstatic void\nfore200e_close(struct atm_vcc* vcc)\n{\n    struct fore200e_vcc*    fore200e_vcc;\n    struct fore200e*        fore200e;\n    struct fore200e_vc_map* vc_map;\n    unsigned long           flags;\n\n    ASSERT(vcc);\n    fore200e = FORE200E_DEV(vcc->dev);\n\n    ASSERT((vcc->vpi >= 0) && (vcc->vpi < 1<<FORE200E_VPI_BITS));\n    ASSERT((vcc->vci >= 0) && (vcc->vci < 1<<FORE200E_VCI_BITS));\n\n    DPRINTK(2, \"closing %d.%d.%d:%d\\n\", vcc->itf, vcc->vpi, vcc->vci, fore200e_atm2fore_aal(vcc->qos.aal));\n\n    clear_bit(ATM_VF_READY, &vcc->flags);\n\n    fore200e_activate_vcin(fore200e, 0, vcc, 0);\n\n    spin_lock_irqsave(&fore200e->q_lock, flags);\n\n    vc_map = FORE200E_VC_MAP(fore200e, vcc->vpi, vcc->vci);\n\n     \n    vc_map->vcc = NULL;\n\n    vcc->itf = vcc->vci = vcc->vpi = 0;\n\n    fore200e_vcc = FORE200E_VCC(vcc);\n    vcc->dev_data = NULL;\n\n    spin_unlock_irqrestore(&fore200e->q_lock, flags);\n\n     \n    if ((vcc->qos.txtp.traffic_class == ATM_CBR) && (vcc->qos.txtp.max_pcr > 0)) {\n\n\tmutex_lock(&fore200e->rate_mtx);\n\tfore200e->available_cell_rate += vcc->qos.txtp.max_pcr;\n\tmutex_unlock(&fore200e->rate_mtx);\n\n\tclear_bit(ATM_VF_HASQOS, &vcc->flags);\n    }\n\n    clear_bit(ATM_VF_ADDR, &vcc->flags);\n    clear_bit(ATM_VF_PARTIAL,&vcc->flags);\n\n    ASSERT(fore200e_vcc);\n    kfree(fore200e_vcc);\n}\n\n\nstatic int\nfore200e_send(struct atm_vcc *vcc, struct sk_buff *skb)\n{\n    struct fore200e*        fore200e;\n    struct fore200e_vcc*    fore200e_vcc;\n    struct fore200e_vc_map* vc_map;\n    struct host_txq*        txq;\n    struct host_txq_entry*  entry;\n    struct tpd*             tpd;\n    struct tpd_haddr        tpd_haddr;\n    int                     retry        = CONFIG_ATM_FORE200E_TX_RETRY;\n    int                     tx_copy      = 0;\n    int                     tx_len       = skb->len;\n    u32*                    cell_header  = NULL;\n    unsigned char*          skb_data;\n    int                     skb_len;\n    unsigned char*          data;\n    unsigned long           flags;\n\n    if (!vcc)\n        return -EINVAL;\n\n    fore200e = FORE200E_DEV(vcc->dev);\n    fore200e_vcc = FORE200E_VCC(vcc);\n\n    if (!fore200e)\n        return -EINVAL;\n\n    txq = &fore200e->host_txq;\n    if (!fore200e_vcc)\n        return -EINVAL;\n\n    if (!test_bit(ATM_VF_READY, &vcc->flags)) {\n\tDPRINTK(1, \"VC %d.%d.%d not ready for tx\\n\", vcc->itf, vcc->vpi, vcc->vpi);\n\tdev_kfree_skb_any(skb);\n\treturn -EINVAL;\n    }\n\n#ifdef FORE200E_52BYTE_AAL0_SDU\n    if ((vcc->qos.aal == ATM_AAL0) && (vcc->qos.txtp.max_sdu == ATM_AAL0_SDU)) {\n\tcell_header = (u32*) skb->data;\n\tskb_data    = skb->data + 4;     \n\tskb_len     = tx_len = skb->len  - 4;\n\n\tDPRINTK(3, \"user-supplied cell header = 0x%08x\\n\", *cell_header);\n    }\n    else \n#endif\n    {\n\tskb_data = skb->data;\n\tskb_len  = skb->len;\n    }\n    \n    if (((unsigned long)skb_data) & 0x3) {\n\n\tDPRINTK(2, \"misaligned tx PDU on device %s\\n\", fore200e->name);\n\ttx_copy = 1;\n\ttx_len  = skb_len;\n    }\n\n    if ((vcc->qos.aal == ATM_AAL0) && (skb_len % ATM_CELL_PAYLOAD)) {\n\n         \n\tDPRINTK(2, \"incomplete tx AAL0 PDU on device %s\\n\", fore200e->name);\n\ttx_copy = 1;\n\ttx_len  = ((skb_len / ATM_CELL_PAYLOAD) + 1) * ATM_CELL_PAYLOAD;\n    }\n    \n    if (tx_copy) {\n\tdata = kmalloc(tx_len, GFP_ATOMIC);\n\tif (data == NULL) {\n\t    if (vcc->pop) {\n\t\tvcc->pop(vcc, skb);\n\t    }\n\t    else {\n\t\tdev_kfree_skb_any(skb);\n\t    }\n\t    return -ENOMEM;\n\t}\n\n\tmemcpy(data, skb_data, skb_len);\n\tif (skb_len < tx_len)\n\t    memset(data + skb_len, 0x00, tx_len - skb_len);\n    }\n    else {\n\tdata = skb_data;\n    }\n\n    vc_map = FORE200E_VC_MAP(fore200e, vcc->vpi, vcc->vci);\n    ASSERT(vc_map->vcc == vcc);\n\n  retry_here:\n\n    spin_lock_irqsave(&fore200e->q_lock, flags);\n\n    entry = &txq->host_entry[ txq->head ];\n\n    if ((*entry->status != STATUS_FREE) || (txq->txing >= QUEUE_SIZE_TX - 2)) {\n\n\t \n\tfore200e_tx_irq(fore200e);\n\n\tif (*entry->status != STATUS_FREE) {\n\n\t    spin_unlock_irqrestore(&fore200e->q_lock, flags);\n\n\t     \n\t    if (--retry > 0) {\n\t\tudelay(50);\n\t\tgoto retry_here;\n\t    }\n\n\t    atomic_inc(&vcc->stats->tx_err);\n\n\t    fore200e->tx_sat++;\n\t    DPRINTK(2, \"tx queue of device %s is saturated, PDU dropped - heartbeat is %08x\\n\",\n\t\t    fore200e->name, fore200e->cp_queues->heartbeat);\n\t    if (vcc->pop) {\n\t\tvcc->pop(vcc, skb);\n\t    }\n\t    else {\n\t\tdev_kfree_skb_any(skb);\n\t    }\n\n\t    if (tx_copy)\n\t\tkfree(data);\n\n\t    return -ENOBUFS;\n\t}\n    }\n\n    entry->incarn = vc_map->incarn;\n    entry->vc_map = vc_map;\n    entry->skb    = skb;\n    entry->data   = tx_copy ? data : NULL;\n\n    tpd = entry->tpd;\n    tpd->tsd[ 0 ].buffer = dma_map_single(fore200e->dev, data, tx_len,\n\t\t\t\t\t  DMA_TO_DEVICE);\n    if (dma_mapping_error(fore200e->dev, tpd->tsd[0].buffer)) {\n\tif (tx_copy)\n\t    kfree(data);\n\tspin_unlock_irqrestore(&fore200e->q_lock, flags);\n\treturn -ENOMEM;\n    }\n    tpd->tsd[ 0 ].length = tx_len;\n\n    FORE200E_NEXT_ENTRY(txq->head, QUEUE_SIZE_TX);\n    txq->txing++;\n\n     \n    \n    DPRINTK(3, \"tx on %d.%d.%d:%d, len = %u (%u)\\n\", \n\t    vcc->itf, vcc->vpi, vcc->vci, fore200e_atm2fore_aal(vcc->qos.aal),\n\t    tpd->tsd[0].length, skb_len);\n\n    if (skb_len < fore200e_vcc->tx_min_pdu)\n\tfore200e_vcc->tx_min_pdu = skb_len;\n    if (skb_len > fore200e_vcc->tx_max_pdu)\n\tfore200e_vcc->tx_max_pdu = skb_len;\n    fore200e_vcc->tx_pdu++;\n\n     \n    tpd->rate.data_cells = fore200e_vcc->rate.data_cells;\n    tpd->rate.idle_cells = fore200e_vcc->rate.idle_cells;\n\n    if (cell_header) {\n\ttpd->atm_header.clp = (*cell_header & ATM_HDR_CLP);\n\ttpd->atm_header.plt = (*cell_header & ATM_HDR_PTI_MASK) >> ATM_HDR_PTI_SHIFT;\n\ttpd->atm_header.vci = (*cell_header & ATM_HDR_VCI_MASK) >> ATM_HDR_VCI_SHIFT;\n\ttpd->atm_header.vpi = (*cell_header & ATM_HDR_VPI_MASK) >> ATM_HDR_VPI_SHIFT;\n\ttpd->atm_header.gfc = (*cell_header & ATM_HDR_GFC_MASK) >> ATM_HDR_GFC_SHIFT;\n    }\n    else {\n\t \n\ttpd->atm_header.clp = 0;\n\ttpd->atm_header.plt = 0;\n\ttpd->atm_header.vci = vcc->vci;\n\ttpd->atm_header.vpi = vcc->vpi;\n\ttpd->atm_header.gfc = 0;\n    }\n\n    tpd->spec.length = tx_len;\n    tpd->spec.nseg   = 1;\n    tpd->spec.aal    = fore200e_atm2fore_aal(vcc->qos.aal);\n    tpd->spec.intr   = 1;\n\n    tpd_haddr.size  = sizeof(struct tpd) / (1<<TPD_HADDR_SHIFT);   \n    tpd_haddr.pad   = 0;\n    tpd_haddr.haddr = entry->tpd_dma >> TPD_HADDR_SHIFT;           \n\n    *entry->status = STATUS_PENDING;\n    fore200e->bus->write(*(u32*)&tpd_haddr, (u32 __iomem *)&entry->cp_entry->tpd_haddr);\n\n    spin_unlock_irqrestore(&fore200e->q_lock, flags);\n\n    return 0;\n}\n\n\nstatic int\nfore200e_getstats(struct fore200e* fore200e)\n{\n    struct host_cmdq*       cmdq  = &fore200e->host_cmdq;\n    struct host_cmdq_entry* entry = &cmdq->host_entry[ cmdq->head ];\n    struct stats_opcode     opcode;\n    int                     ok;\n    u32                     stats_dma_addr;\n\n    if (fore200e->stats == NULL) {\n\tfore200e->stats = kzalloc(sizeof(struct stats), GFP_KERNEL);\n\tif (fore200e->stats == NULL)\n\t    return -ENOMEM;\n    }\n    \n    stats_dma_addr = dma_map_single(fore200e->dev, fore200e->stats,\n\t\t\t\t    sizeof(struct stats), DMA_FROM_DEVICE);\n    if (dma_mapping_error(fore200e->dev, stats_dma_addr))\n    \treturn -ENOMEM;\n    \n    FORE200E_NEXT_ENTRY(cmdq->head, QUEUE_SIZE_CMD);\n\n    opcode.opcode = OPCODE_GET_STATS;\n    opcode.pad    = 0;\n\n    fore200e->bus->write(stats_dma_addr, &entry->cp_entry->cmd.stats_block.stats_haddr);\n    \n    *entry->status = STATUS_PENDING;\n\n    fore200e->bus->write(*(u32*)&opcode, (u32 __iomem *)&entry->cp_entry->cmd.stats_block.opcode);\n\n    ok = fore200e_poll(fore200e, entry->status, STATUS_COMPLETE, 400);\n\n    *entry->status = STATUS_FREE;\n\n    dma_unmap_single(fore200e->dev, stats_dma_addr, sizeof(struct stats), DMA_FROM_DEVICE);\n    \n    if (ok == 0) {\n\tprintk(FORE200E \"unable to get statistics from device %s\\n\", fore200e->name);\n\treturn -EIO;\n    }\n\n    return 0;\n}\n\n#if 0  \nstatic int\nfore200e_get_oc3(struct fore200e* fore200e, struct oc3_regs* regs)\n{\n    struct host_cmdq*       cmdq  = &fore200e->host_cmdq;\n    struct host_cmdq_entry* entry = &cmdq->host_entry[ cmdq->head ];\n    struct oc3_opcode       opcode;\n    int                     ok;\n    u32                     oc3_regs_dma_addr;\n\n    oc3_regs_dma_addr = fore200e->bus->dma_map(fore200e, regs, sizeof(struct oc3_regs), DMA_FROM_DEVICE);\n\n    FORE200E_NEXT_ENTRY(cmdq->head, QUEUE_SIZE_CMD);\n\n    opcode.opcode = OPCODE_GET_OC3;\n    opcode.reg    = 0;\n    opcode.value  = 0;\n    opcode.mask   = 0;\n\n    fore200e->bus->write(oc3_regs_dma_addr, &entry->cp_entry->cmd.oc3_block.regs_haddr);\n    \n    *entry->status = STATUS_PENDING;\n\n    fore200e->bus->write(*(u32*)&opcode, (u32*)&entry->cp_entry->cmd.oc3_block.opcode);\n\n    ok = fore200e_poll(fore200e, entry->status, STATUS_COMPLETE, 400);\n\n    *entry->status = STATUS_FREE;\n\n    fore200e->bus->dma_unmap(fore200e, oc3_regs_dma_addr, sizeof(struct oc3_regs), DMA_FROM_DEVICE);\n    \n    if (ok == 0) {\n\tprintk(FORE200E \"unable to get OC-3 regs of device %s\\n\", fore200e->name);\n\treturn -EIO;\n    }\n\n    return 0;\n}\n#endif\n\n\nstatic int\nfore200e_set_oc3(struct fore200e* fore200e, u32 reg, u32 value, u32 mask)\n{\n    struct host_cmdq*       cmdq  = &fore200e->host_cmdq;\n    struct host_cmdq_entry* entry = &cmdq->host_entry[ cmdq->head ];\n    struct oc3_opcode       opcode;\n    int                     ok;\n\n    DPRINTK(2, \"set OC-3 reg = 0x%02x, value = 0x%02x, mask = 0x%02x\\n\", reg, value, mask);\n\n    FORE200E_NEXT_ENTRY(cmdq->head, QUEUE_SIZE_CMD);\n\n    opcode.opcode = OPCODE_SET_OC3;\n    opcode.reg    = reg;\n    opcode.value  = value;\n    opcode.mask   = mask;\n\n    fore200e->bus->write(0, &entry->cp_entry->cmd.oc3_block.regs_haddr);\n    \n    *entry->status = STATUS_PENDING;\n\n    fore200e->bus->write(*(u32*)&opcode, (u32 __iomem *)&entry->cp_entry->cmd.oc3_block.opcode);\n\n    ok = fore200e_poll(fore200e, entry->status, STATUS_COMPLETE, 400);\n\n    *entry->status = STATUS_FREE;\n\n    if (ok == 0) {\n\tprintk(FORE200E \"unable to set OC-3 reg 0x%02x of device %s\\n\", reg, fore200e->name);\n\treturn -EIO;\n    }\n\n    return 0;\n}\n\n\nstatic int\nfore200e_setloop(struct fore200e* fore200e, int loop_mode)\n{\n    u32 mct_value, mct_mask;\n    int error;\n\n    if (!capable(CAP_NET_ADMIN))\n\treturn -EPERM;\n    \n    switch (loop_mode) {\n\n    case ATM_LM_NONE:\n\tmct_value = 0; \n\tmct_mask  = SUNI_MCT_DLE | SUNI_MCT_LLE;\n\tbreak;\n\t\n    case ATM_LM_LOC_PHY:\n\tmct_value = mct_mask = SUNI_MCT_DLE;\n\tbreak;\n\n    case ATM_LM_RMT_PHY:\n\tmct_value = mct_mask = SUNI_MCT_LLE;\n\tbreak;\n\n    default:\n\treturn -EINVAL;\n    }\n\n    error = fore200e_set_oc3(fore200e, SUNI_MCT, mct_value, mct_mask);\n    if (error == 0)\n\tfore200e->loop_mode = loop_mode;\n\n    return error;\n}\n\n\nstatic int\nfore200e_fetch_stats(struct fore200e* fore200e, struct sonet_stats __user *arg)\n{\n    struct sonet_stats tmp;\n\n    if (fore200e_getstats(fore200e) < 0)\n\treturn -EIO;\n\n    tmp.section_bip = be32_to_cpu(fore200e->stats->oc3.section_bip8_errors);\n    tmp.line_bip    = be32_to_cpu(fore200e->stats->oc3.line_bip24_errors);\n    tmp.path_bip    = be32_to_cpu(fore200e->stats->oc3.path_bip8_errors);\n    tmp.line_febe   = be32_to_cpu(fore200e->stats->oc3.line_febe_errors);\n    tmp.path_febe   = be32_to_cpu(fore200e->stats->oc3.path_febe_errors);\n    tmp.corr_hcs    = be32_to_cpu(fore200e->stats->oc3.corr_hcs_errors);\n    tmp.uncorr_hcs  = be32_to_cpu(fore200e->stats->oc3.ucorr_hcs_errors);\n    tmp.tx_cells    = be32_to_cpu(fore200e->stats->aal0.cells_transmitted)  +\n\t              be32_to_cpu(fore200e->stats->aal34.cells_transmitted) +\n\t              be32_to_cpu(fore200e->stats->aal5.cells_transmitted);\n    tmp.rx_cells    = be32_to_cpu(fore200e->stats->aal0.cells_received)     +\n\t              be32_to_cpu(fore200e->stats->aal34.cells_received)    +\n\t              be32_to_cpu(fore200e->stats->aal5.cells_received);\n\n    if (arg)\n\treturn copy_to_user(arg, &tmp, sizeof(struct sonet_stats)) ? -EFAULT : 0;\t\n    \n    return 0;\n}\n\n\nstatic int\nfore200e_ioctl(struct atm_dev* dev, unsigned int cmd, void __user * arg)\n{\n    struct fore200e* fore200e = FORE200E_DEV(dev);\n    \n    DPRINTK(2, \"ioctl cmd = 0x%x (%u), arg = 0x%p (%lu)\\n\", cmd, cmd, arg, (unsigned long)arg);\n\n    switch (cmd) {\n\n    case SONET_GETSTAT:\n\treturn fore200e_fetch_stats(fore200e, (struct sonet_stats __user *)arg);\n\n    case SONET_GETDIAG:\n\treturn put_user(0, (int __user *)arg) ? -EFAULT : 0;\n\n    case ATM_SETLOOP:\n\treturn fore200e_setloop(fore200e, (int)(unsigned long)arg);\n\n    case ATM_GETLOOP:\n\treturn put_user(fore200e->loop_mode, (int __user *)arg) ? -EFAULT : 0;\n\n    case ATM_QUERYLOOP:\n\treturn put_user(ATM_LM_LOC_PHY | ATM_LM_RMT_PHY, (int __user *)arg) ? -EFAULT : 0;\n    }\n\n    return -ENOSYS;  \n}\n\n\nstatic int\nfore200e_change_qos(struct atm_vcc* vcc,struct atm_qos* qos, int flags)\n{\n    struct fore200e_vcc* fore200e_vcc = FORE200E_VCC(vcc);\n    struct fore200e*     fore200e     = FORE200E_DEV(vcc->dev);\n\n    if (!test_bit(ATM_VF_READY, &vcc->flags)) {\n\tDPRINTK(1, \"VC %d.%d.%d not ready for QoS change\\n\", vcc->itf, vcc->vpi, vcc->vpi);\n\treturn -EINVAL;\n    }\n\n    DPRINTK(2, \"change_qos %d.%d.%d, \"\n\t    \"(tx: cl=%s, pcr=%d-%d, cdv=%d, max_sdu=%d; \"\n\t    \"rx: cl=%s, pcr=%d-%d, cdv=%d, max_sdu=%d), flags = 0x%x\\n\"\n\t    \"available_cell_rate = %u\",\n\t    vcc->itf, vcc->vpi, vcc->vci,\n\t    fore200e_traffic_class[ qos->txtp.traffic_class ],\n\t    qos->txtp.min_pcr, qos->txtp.max_pcr, qos->txtp.max_cdv, qos->txtp.max_sdu,\n\t    fore200e_traffic_class[ qos->rxtp.traffic_class ],\n\t    qos->rxtp.min_pcr, qos->rxtp.max_pcr, qos->rxtp.max_cdv, qos->rxtp.max_sdu,\n\t    flags, fore200e->available_cell_rate);\n\n    if ((qos->txtp.traffic_class == ATM_CBR) && (qos->txtp.max_pcr > 0)) {\n\n\tmutex_lock(&fore200e->rate_mtx);\n\tif (fore200e->available_cell_rate + vcc->qos.txtp.max_pcr < qos->txtp.max_pcr) {\n\t    mutex_unlock(&fore200e->rate_mtx);\n\t    return -EAGAIN;\n\t}\n\n\tfore200e->available_cell_rate += vcc->qos.txtp.max_pcr;\n\tfore200e->available_cell_rate -= qos->txtp.max_pcr;\n\n\tmutex_unlock(&fore200e->rate_mtx);\n\t\n\tmemcpy(&vcc->qos, qos, sizeof(struct atm_qos));\n\t\n\t \n\tfore200e_rate_ctrl(qos, &fore200e_vcc->rate);\n\n\tset_bit(ATM_VF_HASQOS, &vcc->flags);\n\n\treturn 0;\n    }\n    \n    return -EINVAL;\n}\n    \n\nstatic int fore200e_irq_request(struct fore200e *fore200e)\n{\n    if (request_irq(fore200e->irq, fore200e_interrupt, IRQF_SHARED, fore200e->name, fore200e->atm_dev) < 0) {\n\n\tprintk(FORE200E \"unable to reserve IRQ %s for device %s\\n\",\n\t       fore200e_irq_itoa(fore200e->irq), fore200e->name);\n\treturn -EBUSY;\n    }\n\n    printk(FORE200E \"IRQ %s reserved for device %s\\n\",\n\t   fore200e_irq_itoa(fore200e->irq), fore200e->name);\n\n#ifdef FORE200E_USE_TASKLET\n    tasklet_init(&fore200e->tx_tasklet, fore200e_tx_tasklet, (unsigned long)fore200e);\n    tasklet_init(&fore200e->rx_tasklet, fore200e_rx_tasklet, (unsigned long)fore200e);\n#endif\n\n    fore200e->state = FORE200E_STATE_IRQ;\n    return 0;\n}\n\n\nstatic int fore200e_get_esi(struct fore200e *fore200e)\n{\n    struct prom_data* prom = kzalloc(sizeof(struct prom_data), GFP_KERNEL);\n    int ok, i;\n\n    if (!prom)\n\treturn -ENOMEM;\n\n    ok = fore200e->bus->prom_read(fore200e, prom);\n    if (ok < 0) {\n\tkfree(prom);\n\treturn -EBUSY;\n    }\n\t\n    printk(FORE200E \"device %s, rev. %c, S/N: %d, ESI: %pM\\n\",\n\t   fore200e->name, \n\t   (prom->hw_revision & 0xFF) + '@',     \n\t   prom->serial_number & 0xFFFF, &prom->mac_addr[2]);\n\t\n    for (i = 0; i < ESI_LEN; i++) {\n\tfore200e->esi[ i ] = fore200e->atm_dev->esi[ i ] = prom->mac_addr[ i + 2 ];\n    }\n    \n    kfree(prom);\n\n    return 0;\n}\n\n\nstatic int fore200e_alloc_rx_buf(struct fore200e *fore200e)\n{\n    int scheme, magn, nbr, size, i;\n\n    struct host_bsq* bsq;\n    struct buffer*   buffer;\n\n    for (scheme = 0; scheme < BUFFER_SCHEME_NBR; scheme++) {\n\tfor (magn = 0; magn < BUFFER_MAGN_NBR; magn++) {\n\n\t    bsq = &fore200e->host_bsq[ scheme ][ magn ];\n\n\t    nbr  = fore200e_rx_buf_nbr[ scheme ][ magn ];\n\t    size = fore200e_rx_buf_size[ scheme ][ magn ];\n\n\t    DPRINTK(2, \"rx buffers %d / %d are being allocated\\n\", scheme, magn);\n\n\t     \n\t    buffer = bsq->buffer = kcalloc(nbr, sizeof(struct buffer),\n                                           GFP_KERNEL);\n\n\t    if (buffer == NULL)\n\t\treturn -ENOMEM;\n\n\t    bsq->freebuf = NULL;\n\n\t    for (i = 0; i < nbr; i++) {\n\n\t\tbuffer[ i ].scheme = scheme;\n\t\tbuffer[ i ].magn   = magn;\n#ifdef FORE200E_BSQ_DEBUG\n\t\tbuffer[ i ].index  = i;\n\t\tbuffer[ i ].supplied = 0;\n#endif\n\n\t\t \n\t\tif (fore200e_chunk_alloc(fore200e,\n\t\t\t\t\t &buffer[ i ].data, size, fore200e->bus->buffer_alignment,\n\t\t\t\t\t DMA_FROM_DEVICE) < 0) {\n\t\t    \n\t\t    while (i > 0)\n\t\t\tfore200e_chunk_free(fore200e, &buffer[ --i ].data);\n\t\t    kfree(buffer);\n\t\t    \n\t\t    return -ENOMEM;\n\t\t}\n\n\t\t \n\t\tbuffer[ i ].next = bsq->freebuf;\n\t\tbsq->freebuf = &buffer[ i ];\n\t    }\n\t     \n\t    bsq->freebuf_count = nbr;\n\n#ifdef FORE200E_BSQ_DEBUG\n\t    bsq_audit(3, bsq, scheme, magn);\n#endif\n\t}\n    }\n\n    fore200e->state = FORE200E_STATE_ALLOC_BUF;\n    return 0;\n}\n\n\nstatic int fore200e_init_bs_queue(struct fore200e *fore200e)\n{\n    int scheme, magn, i;\n\n    struct host_bsq*     bsq;\n    struct cp_bsq_entry __iomem * cp_entry;\n\n    for (scheme = 0; scheme < BUFFER_SCHEME_NBR; scheme++) {\n\tfor (magn = 0; magn < BUFFER_MAGN_NBR; magn++) {\n\n\t    DPRINTK(2, \"buffer supply queue %d / %d is being initialized\\n\", scheme, magn);\n\n\t    bsq = &fore200e->host_bsq[ scheme ][ magn ];\n\n\t     \n\t    if (fore200e_dma_chunk_alloc(fore200e,\n\t\t\t\t\t       &bsq->status,\n\t\t\t\t\t       sizeof(enum status), \n\t\t\t\t\t       QUEUE_SIZE_BS,\n\t\t\t\t\t       fore200e->bus->status_alignment) < 0) {\n\t\treturn -ENOMEM;\n\t    }\n\n\t     \n\t    if (fore200e_dma_chunk_alloc(fore200e,\n\t\t\t\t\t       &bsq->rbd_block,\n\t\t\t\t\t       sizeof(struct rbd_block),\n\t\t\t\t\t       QUEUE_SIZE_BS,\n\t\t\t\t\t       fore200e->bus->descr_alignment) < 0) {\n\t\t\n\t\tfore200e_dma_chunk_free(fore200e, &bsq->status);\n\t\treturn -ENOMEM;\n\t    }\n\t    \n\t     \n\t    cp_entry = fore200e->virt_base + \n\t\t       fore200e->bus->read(&fore200e->cp_queues->cp_bsq[ scheme ][ magn ]);\n\t    \n\t     \n\t    for (i = 0; i < QUEUE_SIZE_BS; i++) {\n\t\t\n\t\tbsq->host_entry[ i ].status = \n\t\t                     FORE200E_INDEX(bsq->status.align_addr, enum status, i);\n\t        bsq->host_entry[ i ].rbd_block =\n\t\t                     FORE200E_INDEX(bsq->rbd_block.align_addr, struct rbd_block, i);\n\t\tbsq->host_entry[ i ].rbd_block_dma =\n\t\t                     FORE200E_DMA_INDEX(bsq->rbd_block.dma_addr, struct rbd_block, i);\n\t\tbsq->host_entry[ i ].cp_entry = &cp_entry[ i ];\n\t\t\n\t\t*bsq->host_entry[ i ].status = STATUS_FREE;\n\t\t\n\t\tfore200e->bus->write(FORE200E_DMA_INDEX(bsq->status.dma_addr, enum status, i), \n\t\t\t\t     &cp_entry[ i ].status_haddr);\n\t    }\n\t}\n    }\n\n    fore200e->state = FORE200E_STATE_INIT_BSQ;\n    return 0;\n}\n\n\nstatic int fore200e_init_rx_queue(struct fore200e *fore200e)\n{\n    struct host_rxq*     rxq =  &fore200e->host_rxq;\n    struct cp_rxq_entry __iomem * cp_entry;\n    int i;\n\n    DPRINTK(2, \"receive queue is being initialized\\n\");\n\n     \n    if (fore200e_dma_chunk_alloc(fore200e,\n\t\t\t\t       &rxq->status,\n\t\t\t\t       sizeof(enum status), \n\t\t\t\t       QUEUE_SIZE_RX,\n\t\t\t\t       fore200e->bus->status_alignment) < 0) {\n\treturn -ENOMEM;\n    }\n\n     \n    if (fore200e_dma_chunk_alloc(fore200e,\n\t\t\t\t       &rxq->rpd,\n\t\t\t\t       sizeof(struct rpd), \n\t\t\t\t       QUEUE_SIZE_RX,\n\t\t\t\t       fore200e->bus->descr_alignment) < 0) {\n\t\n\tfore200e_dma_chunk_free(fore200e, &rxq->status);\n\treturn -ENOMEM;\n    }\n\n     \n    cp_entry = fore200e->virt_base + fore200e->bus->read(&fore200e->cp_queues->cp_rxq);\n\n     \n    for (i=0; i < QUEUE_SIZE_RX; i++) {\n\t\n\trxq->host_entry[ i ].status = \n\t                     FORE200E_INDEX(rxq->status.align_addr, enum status, i);\n\trxq->host_entry[ i ].rpd = \n\t                     FORE200E_INDEX(rxq->rpd.align_addr, struct rpd, i);\n\trxq->host_entry[ i ].rpd_dma = \n\t                     FORE200E_DMA_INDEX(rxq->rpd.dma_addr, struct rpd, i);\n\trxq->host_entry[ i ].cp_entry = &cp_entry[ i ];\n\n\t*rxq->host_entry[ i ].status = STATUS_FREE;\n\n\tfore200e->bus->write(FORE200E_DMA_INDEX(rxq->status.dma_addr, enum status, i), \n\t\t\t     &cp_entry[ i ].status_haddr);\n\n\tfore200e->bus->write(FORE200E_DMA_INDEX(rxq->rpd.dma_addr, struct rpd, i),\n\t\t\t     &cp_entry[ i ].rpd_haddr);\n    }\n\n     \n    rxq->head = 0;\n\n    fore200e->state = FORE200E_STATE_INIT_RXQ;\n    return 0;\n}\n\n\nstatic int fore200e_init_tx_queue(struct fore200e *fore200e)\n{\n    struct host_txq*     txq =  &fore200e->host_txq;\n    struct cp_txq_entry __iomem * cp_entry;\n    int i;\n\n    DPRINTK(2, \"transmit queue is being initialized\\n\");\n\n     \n    if (fore200e_dma_chunk_alloc(fore200e,\n\t\t\t\t       &txq->status,\n\t\t\t\t       sizeof(enum status), \n\t\t\t\t       QUEUE_SIZE_TX,\n\t\t\t\t       fore200e->bus->status_alignment) < 0) {\n\treturn -ENOMEM;\n    }\n\n     \n    if (fore200e_dma_chunk_alloc(fore200e,\n\t\t\t\t       &txq->tpd,\n\t\t\t\t       sizeof(struct tpd), \n\t\t\t\t       QUEUE_SIZE_TX,\n\t\t\t\t       fore200e->bus->descr_alignment) < 0) {\n\t\n\tfore200e_dma_chunk_free(fore200e, &txq->status);\n\treturn -ENOMEM;\n    }\n\n     \n    cp_entry = fore200e->virt_base + fore200e->bus->read(&fore200e->cp_queues->cp_txq);\n\n     \n    for (i=0; i < QUEUE_SIZE_TX; i++) {\n\t\n\ttxq->host_entry[ i ].status = \n\t                     FORE200E_INDEX(txq->status.align_addr, enum status, i);\n\ttxq->host_entry[ i ].tpd = \n\t                     FORE200E_INDEX(txq->tpd.align_addr, struct tpd, i);\n\ttxq->host_entry[ i ].tpd_dma  = \n                             FORE200E_DMA_INDEX(txq->tpd.dma_addr, struct tpd, i);\n\ttxq->host_entry[ i ].cp_entry = &cp_entry[ i ];\n\n\t*txq->host_entry[ i ].status = STATUS_FREE;\n\t\n\tfore200e->bus->write(FORE200E_DMA_INDEX(txq->status.dma_addr, enum status, i), \n\t\t\t     &cp_entry[ i ].status_haddr);\n\t\n         \n    }\n\n     \n    txq->head = 0;\n    txq->tail = 0;\n\n    fore200e->state = FORE200E_STATE_INIT_TXQ;\n    return 0;\n}\n\n\nstatic int fore200e_init_cmd_queue(struct fore200e *fore200e)\n{\n    struct host_cmdq*     cmdq =  &fore200e->host_cmdq;\n    struct cp_cmdq_entry __iomem * cp_entry;\n    int i;\n\n    DPRINTK(2, \"command queue is being initialized\\n\");\n\n     \n    if (fore200e_dma_chunk_alloc(fore200e,\n\t\t\t\t       &cmdq->status,\n\t\t\t\t       sizeof(enum status), \n\t\t\t\t       QUEUE_SIZE_CMD,\n\t\t\t\t       fore200e->bus->status_alignment) < 0) {\n\treturn -ENOMEM;\n    }\n    \n     \n    cp_entry = fore200e->virt_base + fore200e->bus->read(&fore200e->cp_queues->cp_cmdq);\n\n     \n    for (i=0; i < QUEUE_SIZE_CMD; i++) {\n\t\n\tcmdq->host_entry[ i ].status   = \n                              FORE200E_INDEX(cmdq->status.align_addr, enum status, i);\n\tcmdq->host_entry[ i ].cp_entry = &cp_entry[ i ];\n\n\t*cmdq->host_entry[ i ].status = STATUS_FREE;\n\n\tfore200e->bus->write(FORE200E_DMA_INDEX(cmdq->status.dma_addr, enum status, i), \n                             &cp_entry[ i ].status_haddr);\n    }\n\n     \n    cmdq->head = 0;\n\n    fore200e->state = FORE200E_STATE_INIT_CMDQ;\n    return 0;\n}\n\n\nstatic void fore200e_param_bs_queue(struct fore200e *fore200e,\n\t\t\t\t    enum buffer_scheme scheme,\n\t\t\t\t    enum buffer_magn magn, int queue_length,\n\t\t\t\t    int pool_size, int supply_blksize)\n{\n    struct bs_spec __iomem * bs_spec = &fore200e->cp_queues->init.bs_spec[ scheme ][ magn ];\n\n    fore200e->bus->write(queue_length,                           &bs_spec->queue_length);\n    fore200e->bus->write(fore200e_rx_buf_size[ scheme ][ magn ], &bs_spec->buffer_size);\n    fore200e->bus->write(pool_size,                              &bs_spec->pool_size);\n    fore200e->bus->write(supply_blksize,                         &bs_spec->supply_blksize);\n}\n\n\nstatic int fore200e_initialize(struct fore200e *fore200e)\n{\n    struct cp_queues __iomem * cpq;\n    int               ok, scheme, magn;\n\n    DPRINTK(2, \"device %s being initialized\\n\", fore200e->name);\n\n    mutex_init(&fore200e->rate_mtx);\n    spin_lock_init(&fore200e->q_lock);\n\n    cpq = fore200e->cp_queues = fore200e->virt_base + FORE200E_CP_QUEUES_OFFSET;\n\n     \n    fore200e->bus->write(1, &cpq->imask);\n\n    if (fore200e->bus->irq_enable)\n\tfore200e->bus->irq_enable(fore200e);\n    \n    fore200e->bus->write(NBR_CONNECT, &cpq->init.num_connect);\n\n    fore200e->bus->write(QUEUE_SIZE_CMD, &cpq->init.cmd_queue_len);\n    fore200e->bus->write(QUEUE_SIZE_RX,  &cpq->init.rx_queue_len);\n    fore200e->bus->write(QUEUE_SIZE_TX,  &cpq->init.tx_queue_len);\n\n    fore200e->bus->write(RSD_EXTENSION,  &cpq->init.rsd_extension);\n    fore200e->bus->write(TSD_EXTENSION,  &cpq->init.tsd_extension);\n\n    for (scheme = 0; scheme < BUFFER_SCHEME_NBR; scheme++)\n\tfor (magn = 0; magn < BUFFER_MAGN_NBR; magn++)\n\t    fore200e_param_bs_queue(fore200e, scheme, magn,\n\t\t\t\t    QUEUE_SIZE_BS, \n\t\t\t\t    fore200e_rx_buf_nbr[ scheme ][ magn ],\n\t\t\t\t    RBD_BLK_SIZE);\n\n     \n    fore200e->bus->write(STATUS_PENDING,    &cpq->init.status);\n    fore200e->bus->write(OPCODE_INITIALIZE, &cpq->init.opcode);\n\n    ok = fore200e_io_poll(fore200e, &cpq->init.status, STATUS_COMPLETE, 3000);\n    if (ok == 0) {\n\tprintk(FORE200E \"device %s initialization failed\\n\", fore200e->name);\n\treturn -ENODEV;\n    }\n\n    printk(FORE200E \"device %s initialized\\n\", fore200e->name);\n\n    fore200e->state = FORE200E_STATE_INITIALIZE;\n    return 0;\n}\n\n\nstatic void fore200e_monitor_putc(struct fore200e *fore200e, char c)\n{\n    struct cp_monitor __iomem * monitor = fore200e->cp_monitor;\n\n#if 0\n    printk(\"%c\", c);\n#endif\n    fore200e->bus->write(((u32) c) | FORE200E_CP_MONITOR_UART_AVAIL, &monitor->soft_uart.send);\n}\n\n\nstatic int fore200e_monitor_getc(struct fore200e *fore200e)\n{\n    struct cp_monitor __iomem * monitor = fore200e->cp_monitor;\n    unsigned long      timeout = jiffies + msecs_to_jiffies(50);\n    int                c;\n\n    while (time_before(jiffies, timeout)) {\n\n\tc = (int) fore200e->bus->read(&monitor->soft_uart.recv);\n\n\tif (c & FORE200E_CP_MONITOR_UART_AVAIL) {\n\n\t    fore200e->bus->write(FORE200E_CP_MONITOR_UART_FREE, &monitor->soft_uart.recv);\n#if 0\n\t    printk(\"%c\", c & 0xFF);\n#endif\n\t    return c & 0xFF;\n\t}\n    }\n\n    return -1;\n}\n\n\nstatic void fore200e_monitor_puts(struct fore200e *fore200e, char *str)\n{\n    while (*str) {\n\n\t \n\twhile (fore200e_monitor_getc(fore200e) >= 0);\n\t\n\tfore200e_monitor_putc(fore200e, *str++);\n    }\n\n    while (fore200e_monitor_getc(fore200e) >= 0);\n}\n\n#ifdef __LITTLE_ENDIAN\n#define FW_EXT \".bin\"\n#else\n#define FW_EXT \"_ecd.bin2\"\n#endif\n\nstatic int fore200e_load_and_start_fw(struct fore200e *fore200e)\n{\n    const struct firmware *firmware;\n    const struct fw_header *fw_header;\n    const __le32 *fw_data;\n    u32 fw_size;\n    u32 __iomem *load_addr;\n    char buf[48];\n    int err;\n\n    sprintf(buf, \"%s%s\", fore200e->bus->proc_name, FW_EXT);\n    if ((err = request_firmware(&firmware, buf, fore200e->dev)) < 0) {\n\tprintk(FORE200E \"problem loading firmware image %s\\n\", fore200e->bus->model_name);\n\treturn err;\n    }\n\n    fw_data = (const __le32 *)firmware->data;\n    fw_size = firmware->size / sizeof(u32);\n    fw_header = (const struct fw_header *)firmware->data;\n    load_addr = fore200e->virt_base + le32_to_cpu(fw_header->load_offset);\n\n    DPRINTK(2, \"device %s firmware being loaded at 0x%p (%d words)\\n\",\n\t    fore200e->name, load_addr, fw_size);\n\n    if (le32_to_cpu(fw_header->magic) != FW_HEADER_MAGIC) {\n\tprintk(FORE200E \"corrupted %s firmware image\\n\", fore200e->bus->model_name);\n\tgoto release;\n    }\n\n    for (; fw_size--; fw_data++, load_addr++)\n\tfore200e->bus->write(le32_to_cpu(*fw_data), load_addr);\n\n    DPRINTK(2, \"device %s firmware being started\\n\", fore200e->name);\n\n#if defined(__sparc_v9__)\n     \n    fore200e_spin(100);\n#endif\n\n    sprintf(buf, \"\\rgo %x\\r\", le32_to_cpu(fw_header->start_offset));\n    fore200e_monitor_puts(fore200e, buf);\n\n    if (fore200e_io_poll(fore200e, &fore200e->cp_monitor->bstat, BSTAT_CP_RUNNING, 1000) == 0) {\n\tprintk(FORE200E \"device %s firmware didn't start\\n\", fore200e->name);\n\tgoto release;\n    }\n\n    printk(FORE200E \"device %s firmware started\\n\", fore200e->name);\n\n    fore200e->state = FORE200E_STATE_START_FW;\n    err = 0;\n\nrelease:\n    release_firmware(firmware);\n    return err;\n}\n\n\nstatic int fore200e_register(struct fore200e *fore200e, struct device *parent)\n{\n    struct atm_dev* atm_dev;\n\n    DPRINTK(2, \"device %s being registered\\n\", fore200e->name);\n\n    atm_dev = atm_dev_register(fore200e->bus->proc_name, parent, &fore200e_ops,\n                               -1, NULL);\n    if (atm_dev == NULL) {\n\tprintk(FORE200E \"unable to register device %s\\n\", fore200e->name);\n\treturn -ENODEV;\n    }\n\n    atm_dev->dev_data = fore200e;\n    fore200e->atm_dev = atm_dev;\n\n    atm_dev->ci_range.vpi_bits = FORE200E_VPI_BITS;\n    atm_dev->ci_range.vci_bits = FORE200E_VCI_BITS;\n\n    fore200e->available_cell_rate = ATM_OC3_PCR;\n\n    fore200e->state = FORE200E_STATE_REGISTER;\n    return 0;\n}\n\n\nstatic int fore200e_init(struct fore200e *fore200e, struct device *parent)\n{\n    if (fore200e_register(fore200e, parent) < 0)\n\treturn -ENODEV;\n    \n    if (fore200e->bus->configure(fore200e) < 0)\n\treturn -ENODEV;\n\n    if (fore200e->bus->map(fore200e) < 0)\n\treturn -ENODEV;\n\n    if (fore200e_reset(fore200e, 1) < 0)\n\treturn -ENODEV;\n\n    if (fore200e_load_and_start_fw(fore200e) < 0)\n\treturn -ENODEV;\n\n    if (fore200e_initialize(fore200e) < 0)\n\treturn -ENODEV;\n\n    if (fore200e_init_cmd_queue(fore200e) < 0)\n\treturn -ENOMEM;\n\n    if (fore200e_init_tx_queue(fore200e) < 0)\n\treturn -ENOMEM;\n\n    if (fore200e_init_rx_queue(fore200e) < 0)\n\treturn -ENOMEM;\n\n    if (fore200e_init_bs_queue(fore200e) < 0)\n\treturn -ENOMEM;\n\n    if (fore200e_alloc_rx_buf(fore200e) < 0)\n\treturn -ENOMEM;\n\n    if (fore200e_get_esi(fore200e) < 0)\n\treturn -EIO;\n\n    if (fore200e_irq_request(fore200e) < 0)\n\treturn -EBUSY;\n\n    fore200e_supply(fore200e);\n\n     \n    fore200e->state = FORE200E_STATE_COMPLETE;\n    return 0;\n}\n\n#ifdef CONFIG_SBUS\nstatic const struct of_device_id fore200e_sba_match[];\nstatic int fore200e_sba_probe(struct platform_device *op)\n{\n\tconst struct of_device_id *match;\n\tstruct fore200e *fore200e;\n\tstatic int index = 0;\n\tint err;\n\n\tmatch = of_match_device(fore200e_sba_match, &op->dev);\n\tif (!match)\n\t\treturn -EINVAL;\n\n\tfore200e = kzalloc(sizeof(struct fore200e), GFP_KERNEL);\n\tif (!fore200e)\n\t\treturn -ENOMEM;\n\n\tfore200e->bus = &fore200e_sbus_ops;\n\tfore200e->dev = &op->dev;\n\tfore200e->irq = op->archdata.irqs[0];\n\tfore200e->phys_base = op->resource[0].start;\n\n\tsprintf(fore200e->name, \"SBA-200E-%d\", index);\n\n\terr = fore200e_init(fore200e, &op->dev);\n\tif (err < 0) {\n\t\tfore200e_shutdown(fore200e);\n\t\tkfree(fore200e);\n\t\treturn err;\n\t}\n\n\tindex++;\n\tdev_set_drvdata(&op->dev, fore200e);\n\n\treturn 0;\n}\n\nstatic int fore200e_sba_remove(struct platform_device *op)\n{\n\tstruct fore200e *fore200e = dev_get_drvdata(&op->dev);\n\n\tfore200e_shutdown(fore200e);\n\tkfree(fore200e);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id fore200e_sba_match[] = {\n\t{\n\t\t.name = SBA200E_PROM_NAME,\n\t},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, fore200e_sba_match);\n\nstatic struct platform_driver fore200e_sba_driver = {\n\t.driver = {\n\t\t.name = \"fore_200e\",\n\t\t.of_match_table = fore200e_sba_match,\n\t},\n\t.probe\t\t= fore200e_sba_probe,\n\t.remove\t\t= fore200e_sba_remove,\n};\n#endif\n\n#ifdef CONFIG_PCI\nstatic int fore200e_pca_detect(struct pci_dev *pci_dev,\n\t\t\t       const struct pci_device_id *pci_ent)\n{\n    struct fore200e* fore200e;\n    int err = 0;\n    static int index = 0;\n\n    if (pci_enable_device(pci_dev)) {\n\terr = -EINVAL;\n\tgoto out;\n    }\n\n    if (dma_set_mask_and_coherent(&pci_dev->dev, DMA_BIT_MASK(32))) {\n\terr = -EINVAL;\n\tgoto out;\n    }\n    \n    fore200e = kzalloc(sizeof(struct fore200e), GFP_KERNEL);\n    if (fore200e == NULL) {\n\terr = -ENOMEM;\n\tgoto out_disable;\n    }\n\n    fore200e->bus       = &fore200e_pci_ops;\n    fore200e->dev\t= &pci_dev->dev;\n    fore200e->irq       = pci_dev->irq;\n    fore200e->phys_base = pci_resource_start(pci_dev, 0);\n\n    sprintf(fore200e->name, \"PCA-200E-%d\", index - 1);\n\n    pci_set_master(pci_dev);\n\n    printk(FORE200E \"device PCA-200E found at 0x%lx, IRQ %s\\n\",\n\t   fore200e->phys_base, fore200e_irq_itoa(fore200e->irq));\n\n    sprintf(fore200e->name, \"PCA-200E-%d\", index);\n\n    err = fore200e_init(fore200e, &pci_dev->dev);\n    if (err < 0) {\n\tfore200e_shutdown(fore200e);\n\tgoto out_free;\n    }\n\n    ++index;\n    pci_set_drvdata(pci_dev, fore200e);\n\nout:\n    return err;\n\nout_free:\n    kfree(fore200e);\nout_disable:\n    pci_disable_device(pci_dev);\n    goto out;\n}\n\n\nstatic void fore200e_pca_remove_one(struct pci_dev *pci_dev)\n{\n    struct fore200e *fore200e;\n\n    fore200e = pci_get_drvdata(pci_dev);\n\n    fore200e_shutdown(fore200e);\n    kfree(fore200e);\n    pci_disable_device(pci_dev);\n}\n\n\nstatic const struct pci_device_id fore200e_pca_tbl[] = {\n    { PCI_VENDOR_ID_FORE, PCI_DEVICE_ID_FORE_PCA200E, PCI_ANY_ID, PCI_ANY_ID },\n    { 0, }\n};\n\nMODULE_DEVICE_TABLE(pci, fore200e_pca_tbl);\n\nstatic struct pci_driver fore200e_pca_driver = {\n    .name =     \"fore_200e\",\n    .probe =    fore200e_pca_detect,\n    .remove =   fore200e_pca_remove_one,\n    .id_table = fore200e_pca_tbl,\n};\n#endif\n\nstatic int __init fore200e_module_init(void)\n{\n\tint err = 0;\n\n\tprintk(FORE200E \"FORE Systems 200E-series ATM driver - version \" FORE200E_VERSION \"\\n\");\n\n#ifdef CONFIG_SBUS\n\terr = platform_driver_register(&fore200e_sba_driver);\n\tif (err)\n\t\treturn err;\n#endif\n\n#ifdef CONFIG_PCI\n\terr = pci_register_driver(&fore200e_pca_driver);\n#endif\n\n#ifdef CONFIG_SBUS\n\tif (err)\n\t\tplatform_driver_unregister(&fore200e_sba_driver);\n#endif\n\n\treturn err;\n}\n\nstatic void __exit fore200e_module_cleanup(void)\n{\n#ifdef CONFIG_PCI\n\tpci_unregister_driver(&fore200e_pca_driver);\n#endif\n#ifdef CONFIG_SBUS\n\tplatform_driver_unregister(&fore200e_sba_driver);\n#endif\n}\n\nstatic int\nfore200e_proc_read(struct atm_dev *dev, loff_t* pos, char* page)\n{\n    struct fore200e*     fore200e  = FORE200E_DEV(dev);\n    struct fore200e_vcc* fore200e_vcc;\n    struct atm_vcc*      vcc;\n    int                  i, len, left = *pos;\n    unsigned long        flags;\n\n    if (!left--) {\n\n\tif (fore200e_getstats(fore200e) < 0)\n\t    return -EIO;\n\n\tlen = sprintf(page,\"\\n\"\n\t\t       \" device:\\n\"\n\t\t       \"   internal name:\\t\\t%s\\n\", fore200e->name);\n\n\t \n\tif (fore200e->bus->proc_read)\n\t    len += fore200e->bus->proc_read(fore200e, page + len);\n\t\n\tlen += sprintf(page + len,\n\t\t\"   interrupt line:\\t\\t%s\\n\"\n\t\t\"   physical base address:\\t0x%p\\n\"\n\t\t\"   virtual base address:\\t0x%p\\n\"\n\t\t\"   factory address (ESI):\\t%pM\\n\"\n\t\t\"   board serial number:\\t\\t%d\\n\\n\",\n\t\tfore200e_irq_itoa(fore200e->irq),\n\t\t(void*)fore200e->phys_base,\n\t\tfore200e->virt_base,\n\t\tfore200e->esi,\n\t\tfore200e->esi[4] * 256 + fore200e->esi[5]);\n\n\treturn len;\n    }\n\n    if (!left--)\n\treturn sprintf(page,\n\t\t       \"   free small bufs, scheme 1:\\t%d\\n\"\n\t\t       \"   free large bufs, scheme 1:\\t%d\\n\"\n\t\t       \"   free small bufs, scheme 2:\\t%d\\n\"\n\t\t       \"   free large bufs, scheme 2:\\t%d\\n\",\n\t\t       fore200e->host_bsq[ BUFFER_SCHEME_ONE ][ BUFFER_MAGN_SMALL ].freebuf_count,\n\t\t       fore200e->host_bsq[ BUFFER_SCHEME_ONE ][ BUFFER_MAGN_LARGE ].freebuf_count,\n\t\t       fore200e->host_bsq[ BUFFER_SCHEME_TWO ][ BUFFER_MAGN_SMALL ].freebuf_count,\n\t\t       fore200e->host_bsq[ BUFFER_SCHEME_TWO ][ BUFFER_MAGN_LARGE ].freebuf_count);\n\n    if (!left--) {\n\tu32 hb = fore200e->bus->read(&fore200e->cp_queues->heartbeat);\n\n\tlen = sprintf(page,\"\\n\\n\"\n\t\t      \" cell processor:\\n\"\n\t\t      \"   heartbeat state:\\t\\t\");\n\t\n\tif (hb >> 16 != 0xDEAD)\n\t    len += sprintf(page + len, \"0x%08x\\n\", hb);\n\telse\n\t    len += sprintf(page + len, \"*** FATAL ERROR %04x ***\\n\", hb & 0xFFFF);\n\n\treturn len;\n    }\n\n    if (!left--) {\n\tstatic const char* media_name[] = {\n\t    \"unshielded twisted pair\",\n\t    \"multimode optical fiber ST\",\n\t    \"multimode optical fiber SC\",\n\t    \"single-mode optical fiber ST\",\n\t    \"single-mode optical fiber SC\",\n\t    \"unknown\"\n\t};\n\n\tstatic const char* oc3_mode[] = {\n\t    \"normal operation\",\n\t    \"diagnostic loopback\",\n\t    \"line loopback\",\n\t    \"unknown\"\n\t};\n\n\tu32 fw_release     = fore200e->bus->read(&fore200e->cp_queues->fw_release);\n\tu32 mon960_release = fore200e->bus->read(&fore200e->cp_queues->mon960_release);\n\tu32 oc3_revision   = fore200e->bus->read(&fore200e->cp_queues->oc3_revision);\n\tu32 media_index    = FORE200E_MEDIA_INDEX(fore200e->bus->read(&fore200e->cp_queues->media_type));\n\tu32 oc3_index;\n\n\tif (media_index > 4)\n\t\tmedia_index = 5;\n\t\n\tswitch (fore200e->loop_mode) {\n\t    case ATM_LM_NONE:    oc3_index = 0;\n\t\t                 break;\n\t    case ATM_LM_LOC_PHY: oc3_index = 1;\n\t\t                 break;\n\t    case ATM_LM_RMT_PHY: oc3_index = 2;\n\t\t                 break;\n\t    default:             oc3_index = 3;\n\t}\n\n\treturn sprintf(page,\n\t\t       \"   firmware release:\\t\\t%d.%d.%d\\n\"\n\t\t       \"   monitor release:\\t\\t%d.%d\\n\"\n\t\t       \"   media type:\\t\\t\\t%s\\n\"\n\t\t       \"   OC-3 revision:\\t\\t0x%x\\n\"\n                       \"   OC-3 mode:\\t\\t\\t%s\",\n\t\t       fw_release >> 16, fw_release << 16 >> 24,  fw_release << 24 >> 24,\n\t\t       mon960_release >> 16, mon960_release << 16 >> 16,\n\t\t       media_name[ media_index ],\n\t\t       oc3_revision,\n\t\t       oc3_mode[ oc3_index ]);\n    }\n\n    if (!left--) {\n\tstruct cp_monitor __iomem * cp_monitor = fore200e->cp_monitor;\n\n\treturn sprintf(page,\n\t\t       \"\\n\\n\"\n\t\t       \" monitor:\\n\"\n\t\t       \"   version number:\\t\\t%d\\n\"\n\t\t       \"   boot status word:\\t\\t0x%08x\\n\",\n\t\t       fore200e->bus->read(&cp_monitor->mon_version),\n\t\t       fore200e->bus->read(&cp_monitor->bstat));\n    }\n\n    if (!left--)\n\treturn sprintf(page,\n\t\t       \"\\n\"\n\t\t       \" device statistics:\\n\"\n\t\t       \"  4b5b:\\n\"\n\t\t       \"     crc_header_errors:\\t\\t%10u\\n\"\n\t\t       \"     framing_errors:\\t\\t%10u\\n\",\n\t\t       be32_to_cpu(fore200e->stats->phy.crc_header_errors),\n\t\t       be32_to_cpu(fore200e->stats->phy.framing_errors));\n    \n    if (!left--)\n\treturn sprintf(page, \"\\n\"\n\t\t       \"  OC-3:\\n\"\n\t\t       \"     section_bip8_errors:\\t%10u\\n\"\n\t\t       \"     path_bip8_errors:\\t\\t%10u\\n\"\n\t\t       \"     line_bip24_errors:\\t\\t%10u\\n\"\n\t\t       \"     line_febe_errors:\\t\\t%10u\\n\"\n\t\t       \"     path_febe_errors:\\t\\t%10u\\n\"\n\t\t       \"     corr_hcs_errors:\\t\\t%10u\\n\"\n\t\t       \"     ucorr_hcs_errors:\\t\\t%10u\\n\",\n\t\t       be32_to_cpu(fore200e->stats->oc3.section_bip8_errors),\n\t\t       be32_to_cpu(fore200e->stats->oc3.path_bip8_errors),\n\t\t       be32_to_cpu(fore200e->stats->oc3.line_bip24_errors),\n\t\t       be32_to_cpu(fore200e->stats->oc3.line_febe_errors),\n\t\t       be32_to_cpu(fore200e->stats->oc3.path_febe_errors),\n\t\t       be32_to_cpu(fore200e->stats->oc3.corr_hcs_errors),\n\t\t       be32_to_cpu(fore200e->stats->oc3.ucorr_hcs_errors));\n\n    if (!left--)\n\treturn sprintf(page,\"\\n\"\n\t\t       \"   ATM:\\t\\t\\t\\t     cells\\n\"\n\t\t       \"     TX:\\t\\t\\t%10u\\n\"\n\t\t       \"     RX:\\t\\t\\t%10u\\n\"\n\t\t       \"     vpi out of range:\\t\\t%10u\\n\"\n\t\t       \"     vpi no conn:\\t\\t%10u\\n\"\n\t\t       \"     vci out of range:\\t\\t%10u\\n\"\n\t\t       \"     vci no conn:\\t\\t%10u\\n\",\n\t\t       be32_to_cpu(fore200e->stats->atm.cells_transmitted),\n\t\t       be32_to_cpu(fore200e->stats->atm.cells_received),\n\t\t       be32_to_cpu(fore200e->stats->atm.vpi_bad_range),\n\t\t       be32_to_cpu(fore200e->stats->atm.vpi_no_conn),\n\t\t       be32_to_cpu(fore200e->stats->atm.vci_bad_range),\n\t\t       be32_to_cpu(fore200e->stats->atm.vci_no_conn));\n    \n    if (!left--)\n\treturn sprintf(page,\"\\n\"\n\t\t       \"   AAL0:\\t\\t\\t     cells\\n\"\n\t\t       \"     TX:\\t\\t\\t%10u\\n\"\n\t\t       \"     RX:\\t\\t\\t%10u\\n\"\n\t\t       \"     dropped:\\t\\t\\t%10u\\n\",\n\t\t       be32_to_cpu(fore200e->stats->aal0.cells_transmitted),\n\t\t       be32_to_cpu(fore200e->stats->aal0.cells_received),\n\t\t       be32_to_cpu(fore200e->stats->aal0.cells_dropped));\n    \n    if (!left--)\n\treturn sprintf(page,\"\\n\"\n\t\t       \"   AAL3/4:\\n\"\n\t\t       \"     SAR sublayer:\\t\\t     cells\\n\"\n\t\t       \"       TX:\\t\\t\\t%10u\\n\"\n\t\t       \"       RX:\\t\\t\\t%10u\\n\"\n\t\t       \"       dropped:\\t\\t\\t%10u\\n\"\n\t\t       \"       CRC errors:\\t\\t%10u\\n\"\n\t\t       \"       protocol errors:\\t\\t%10u\\n\\n\"\n\t\t       \"     CS  sublayer:\\t\\t      PDUs\\n\"\n\t\t       \"       TX:\\t\\t\\t%10u\\n\"\n\t\t       \"       RX:\\t\\t\\t%10u\\n\"\n\t\t       \"       dropped:\\t\\t\\t%10u\\n\"\n\t\t       \"       protocol errors:\\t\\t%10u\\n\",\n\t\t       be32_to_cpu(fore200e->stats->aal34.cells_transmitted),\n\t\t       be32_to_cpu(fore200e->stats->aal34.cells_received),\n\t\t       be32_to_cpu(fore200e->stats->aal34.cells_dropped),\n\t\t       be32_to_cpu(fore200e->stats->aal34.cells_crc_errors),\n\t\t       be32_to_cpu(fore200e->stats->aal34.cells_protocol_errors),\n\t\t       be32_to_cpu(fore200e->stats->aal34.cspdus_transmitted),\n\t\t       be32_to_cpu(fore200e->stats->aal34.cspdus_received),\n\t\t       be32_to_cpu(fore200e->stats->aal34.cspdus_dropped),\n\t\t       be32_to_cpu(fore200e->stats->aal34.cspdus_protocol_errors));\n    \n    if (!left--)\n\treturn sprintf(page,\"\\n\"\n\t\t       \"   AAL5:\\n\"\n\t\t       \"     SAR sublayer:\\t\\t     cells\\n\"\n\t\t       \"       TX:\\t\\t\\t%10u\\n\"\n\t\t       \"       RX:\\t\\t\\t%10u\\n\"\n\t\t       \"       dropped:\\t\\t\\t%10u\\n\"\n\t\t       \"       congestions:\\t\\t%10u\\n\\n\"\n\t\t       \"     CS  sublayer:\\t\\t      PDUs\\n\"\n\t\t       \"       TX:\\t\\t\\t%10u\\n\"\n\t\t       \"       RX:\\t\\t\\t%10u\\n\"\n\t\t       \"       dropped:\\t\\t\\t%10u\\n\"\n\t\t       \"       CRC errors:\\t\\t%10u\\n\"\n\t\t       \"       protocol errors:\\t\\t%10u\\n\",\n\t\t       be32_to_cpu(fore200e->stats->aal5.cells_transmitted),\n\t\t       be32_to_cpu(fore200e->stats->aal5.cells_received),\n\t\t       be32_to_cpu(fore200e->stats->aal5.cells_dropped),\n\t\t       be32_to_cpu(fore200e->stats->aal5.congestion_experienced),\n\t\t       be32_to_cpu(fore200e->stats->aal5.cspdus_transmitted),\n\t\t       be32_to_cpu(fore200e->stats->aal5.cspdus_received),\n\t\t       be32_to_cpu(fore200e->stats->aal5.cspdus_dropped),\n\t\t       be32_to_cpu(fore200e->stats->aal5.cspdus_crc_errors),\n\t\t       be32_to_cpu(fore200e->stats->aal5.cspdus_protocol_errors));\n    \n    if (!left--)\n\treturn sprintf(page,\"\\n\"\n\t\t       \"   AUX:\\t\\t       allocation failures\\n\"\n\t\t       \"     small b1:\\t\\t\\t%10u\\n\"\n\t\t       \"     large b1:\\t\\t\\t%10u\\n\"\n\t\t       \"     small b2:\\t\\t\\t%10u\\n\"\n\t\t       \"     large b2:\\t\\t\\t%10u\\n\"\n\t\t       \"     RX PDUs:\\t\\t\\t%10u\\n\"\n\t\t       \"     TX PDUs:\\t\\t\\t%10lu\\n\",\n\t\t       be32_to_cpu(fore200e->stats->aux.small_b1_failed),\n\t\t       be32_to_cpu(fore200e->stats->aux.large_b1_failed),\n\t\t       be32_to_cpu(fore200e->stats->aux.small_b2_failed),\n\t\t       be32_to_cpu(fore200e->stats->aux.large_b2_failed),\n\t\t       be32_to_cpu(fore200e->stats->aux.rpd_alloc_failed),\n\t\t       fore200e->tx_sat);\n    \n    if (!left--)\n\treturn sprintf(page,\"\\n\"\n\t\t       \" receive carrier:\\t\\t\\t%s\\n\",\n\t\t       fore200e->stats->aux.receive_carrier ? \"ON\" : \"OFF!\");\n    \n    if (!left--) {\n        return sprintf(page,\"\\n\"\n\t\t       \" VCCs:\\n  address   VPI VCI   AAL \"\n\t\t       \"TX PDUs   TX min/max size  RX PDUs   RX min/max size\\n\");\n    }\n\n    for (i = 0; i < NBR_CONNECT; i++) {\n\n\tvcc = fore200e->vc_map[i].vcc;\n\n\tif (vcc == NULL)\n\t    continue;\n\n\tspin_lock_irqsave(&fore200e->q_lock, flags);\n\n\tif (vcc && test_bit(ATM_VF_READY, &vcc->flags) && !left--) {\n\n\t    fore200e_vcc = FORE200E_VCC(vcc);\n\t    ASSERT(fore200e_vcc);\n\n\t    len = sprintf(page,\n\t\t\t  \"  %pK  %03d %05d %1d   %09lu %05d/%05d      %09lu %05d/%05d\\n\",\n\t\t\t  vcc,\n\t\t\t  vcc->vpi, vcc->vci, fore200e_atm2fore_aal(vcc->qos.aal),\n\t\t\t  fore200e_vcc->tx_pdu,\n\t\t\t  fore200e_vcc->tx_min_pdu > 0xFFFF ? 0 : fore200e_vcc->tx_min_pdu,\n\t\t\t  fore200e_vcc->tx_max_pdu,\n\t\t\t  fore200e_vcc->rx_pdu,\n\t\t\t  fore200e_vcc->rx_min_pdu > 0xFFFF ? 0 : fore200e_vcc->rx_min_pdu,\n\t\t\t  fore200e_vcc->rx_max_pdu);\n\n\t    spin_unlock_irqrestore(&fore200e->q_lock, flags);\n\t    return len;\n\t}\n\n\tspin_unlock_irqrestore(&fore200e->q_lock, flags);\n    }\n    \n    return 0;\n}\n\nmodule_init(fore200e_module_init);\nmodule_exit(fore200e_module_cleanup);\n\n\nstatic const struct atmdev_ops fore200e_ops = {\n\t.open       = fore200e_open,\n\t.close      = fore200e_close,\n\t.ioctl      = fore200e_ioctl,\n\t.send       = fore200e_send,\n\t.change_qos = fore200e_change_qos,\n\t.proc_read  = fore200e_proc_read,\n\t.owner      = THIS_MODULE\n};\n\nMODULE_LICENSE(\"GPL\");\n#ifdef CONFIG_PCI\n#ifdef __LITTLE_ENDIAN__\nMODULE_FIRMWARE(\"pca200e.bin\");\n#else\nMODULE_FIRMWARE(\"pca200e_ecd.bin2\");\n#endif\n#endif  \n#ifdef CONFIG_SBUS\nMODULE_FIRMWARE(\"sba200e_ecd.bin2\");\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}