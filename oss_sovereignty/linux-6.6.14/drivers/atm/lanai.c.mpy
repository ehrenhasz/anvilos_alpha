{
  "module_name": "lanai.c",
  "hash_id": "9f0d47ba6bbdbd74dc3e3beafd08cb791e772b25a0cd102a034326f9f82b966d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/atm/lanai.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/atmdev.h>\n#include <asm/io.h>\n#include <asm/byteorder.h>\n#include <linux/spinlock.h>\n#include <linux/pci.h>\n#include <linux/dma-mapping.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n\n \n\n \n#define NUM_VCI\t\t\t(1024)\n\n \n#define DEBUG\n \n#undef DEBUG_RW\n\n \n#define FULL_MEMORY_TEST\n\n \n#define SERVICE_ENTRIES\t\t(1024)\n \n\n \n   \n \n\n \n#define TX_FIFO_DEPTH\t\t(7)\n \n\n \n#define LANAI_POLL_PERIOD\t(10*HZ)\n \n\n \n#define AAL5_RX_MULTIPLIER\t(3)\n \n\n \n#define AAL5_TX_MULTIPLIER\t(3)\n \n\n \n#define AAL0_TX_MULTIPLIER\t(40)\n \n\n \n#define AAL0_RX_BUFFER_SIZE\t(PAGE_SIZE)\n \n\n \n \n \n\n \n\n#define DEV_LABEL \"lanai\"\n\n#ifdef DEBUG\n\n#define DPRINTK(format, args...) \\\n\tprintk(KERN_DEBUG DEV_LABEL \": \" format, ##args)\n#define APRINTK(truth, format, args...) \\\n\tdo { \\\n\t\tif (unlikely(!(truth))) \\\n\t\t\tprintk(KERN_ERR DEV_LABEL \": \" format, ##args); \\\n\t} while (0)\n\n#else  \n\n#define DPRINTK(format, args...)\n#define APRINTK(truth, format, args...)\n\n#endif  \n\n#ifdef DEBUG_RW\n#define RWDEBUG(format, args...) \\\n\tprintk(KERN_DEBUG DEV_LABEL \": \" format, ##args)\n#else  \n#define RWDEBUG(format, args...)\n#endif\n\n \n\n#define LANAI_MAPPING_SIZE\t(0x40000)\n#define LANAI_EEPROM_SIZE\t(128)\n\ntypedef int vci_t;\ntypedef void __iomem *bus_addr_t;\n\n \nstruct lanai_buffer {\n\tu32 *start;\t \n\tu32 *end;\t \n\tu32 *ptr;\t \n\tdma_addr_t dmaaddr;\n};\n\nstruct lanai_vcc_stats {\n\tunsigned rx_nomem;\n\tunion {\n\t\tstruct {\n\t\t\tunsigned rx_badlen;\n\t\t\tunsigned service_trash;\n\t\t\tunsigned service_stream;\n\t\t\tunsigned service_rxcrc;\n\t\t} aal5;\n\t\tstruct {\n\t\t} aal0;\n\t} x;\n};\n\nstruct lanai_dev;\t\t\t \n\n \nstruct lanai_vcc {\n\tbus_addr_t vbase;\t\t \n\tstruct lanai_vcc_stats stats;\n\tint nref;\t\t\t \n\tvci_t vci;\n\tstruct {\n\t\tstruct lanai_buffer buf;\n\t\tstruct atm_vcc *atmvcc;\t \n\t} rx;\n\tstruct {\n\t\tstruct lanai_buffer buf;\n\t\tstruct atm_vcc *atmvcc;\t \n\t\tint endptr;\t\t \n\t\tstruct sk_buff_head backlog;\n\t\tvoid (*unqueue)(struct lanai_dev *, struct lanai_vcc *, int);\n\t} tx;\n};\n\nenum lanai_type {\n\tlanai2\t= PCI_DEVICE_ID_EF_ATM_LANAI2,\n\tlanaihb\t= PCI_DEVICE_ID_EF_ATM_LANAIHB\n};\n\nstruct lanai_dev_stats {\n\tunsigned ovfl_trash;\t \n\tunsigned vci_trash;\t \n\tunsigned hec_err;\t \n\tunsigned atm_ovfl;\t \n\tunsigned pcierr_parity_detect;\n\tunsigned pcierr_serr_set;\n\tunsigned pcierr_master_abort;\n\tunsigned pcierr_m_target_abort;\n\tunsigned pcierr_s_target_abort;\n\tunsigned pcierr_master_parity;\n\tunsigned service_notx;\n\tunsigned service_norx;\n\tunsigned service_rxnotaal5;\n\tunsigned dma_reenable;\n\tunsigned card_reset;\n};\n\nstruct lanai_dev {\n\tbus_addr_t base;\n\tstruct lanai_dev_stats stats;\n\tstruct lanai_buffer service;\n\tstruct lanai_vcc **vccs;\n#ifdef USE_POWERDOWN\n\tint nbound;\t\t\t \n#endif\n\tenum lanai_type type;\n\tvci_t num_vci;\t\t\t \n\tu8 eeprom[LANAI_EEPROM_SIZE];\n\tu32 serialno, magicno;\n\tstruct pci_dev *pci;\n\tDECLARE_BITMAP(backlog_vccs, NUM_VCI);    \n\tDECLARE_BITMAP(transmit_ready, NUM_VCI);  \n\tstruct timer_list timer;\n\tint naal0;\n\tstruct lanai_buffer aal0buf;\t \n\tu32 conf1, conf2;\t\t \n\tu32 status;\t\t\t \n\tspinlock_t endtxlock;\n\tspinlock_t servicelock;\n\tstruct atm_vcc *cbrvcc;\n\tint number;\n\tint board_rev;\n \n \n \n};\n\n \nstatic void vci_bitfield_iterate(struct lanai_dev *lanai,\n\tconst unsigned long *lp,\n\tvoid (*func)(struct lanai_dev *,vci_t vci))\n{\n\tvci_t vci;\n\n\tfor_each_set_bit(vci, lp, NUM_VCI)\n\t\tfunc(lanai, vci);\n}\n\n \n\n \n#define LANAI_PAGE_SIZE   ((PAGE_SIZE >= 1024) ? PAGE_SIZE : 1024)\n\n \nstatic void lanai_buf_allocate(struct lanai_buffer *buf,\n\tsize_t bytes, size_t minbytes, struct pci_dev *pci)\n{\n\tint size;\n\n\tif (bytes > (128 * 1024))\t \n\t\tbytes = 128 * 1024;\n\tfor (size = LANAI_PAGE_SIZE; size < bytes; size *= 2)\n\t\t;\n\tif (minbytes < LANAI_PAGE_SIZE)\n\t\tminbytes = LANAI_PAGE_SIZE;\n\tdo {\n\t\t \n\t\tbuf->start = dma_alloc_coherent(&pci->dev,\n\t\t\t\t\t\tsize, &buf->dmaaddr, GFP_KERNEL);\n\t\tif (buf->start != NULL) {\t \n\t\t\t \n\t\t\tAPRINTK((buf->dmaaddr & ~0xFFFFFF00) == 0,\n\t\t\t    \"bad dmaaddr: 0x%lx\\n\",\n\t\t\t    (unsigned long) buf->dmaaddr);\n\t\t\tbuf->ptr = buf->start;\n\t\t\tbuf->end = (u32 *)\n\t\t\t    (&((unsigned char *) buf->start)[size]);\n\t\t\tmemset(buf->start, 0, size);\n\t\t\tbreak;\n\t\t}\n\t\tsize /= 2;\n\t} while (size >= minbytes);\n}\n\n \nstatic inline size_t lanai_buf_size(const struct lanai_buffer *buf)\n{\n\treturn ((unsigned long) buf->end) - ((unsigned long) buf->start);\n}\n\nstatic void lanai_buf_deallocate(struct lanai_buffer *buf,\n\tstruct pci_dev *pci)\n{\n\tif (buf->start != NULL) {\n\t\tdma_free_coherent(&pci->dev, lanai_buf_size(buf),\n\t\t\t\t  buf->start, buf->dmaaddr);\n\t\tbuf->start = buf->end = buf->ptr = NULL;\n\t}\n}\n\n \nstatic int lanai_buf_size_cardorder(const struct lanai_buffer *buf)\n{\n\tint order = get_order(lanai_buf_size(buf)) + (PAGE_SHIFT - 10);\n\n\t \n\tif (order > 7)\n\t\torder = 7;\n\treturn order;\n}\n\n \n\n \nenum lanai_register {\n\tReset_Reg\t\t= 0x00,\t \n#define   RESET_GET_BOARD_REV(x)    (((x)>> 0)&0x03)\t \n#define   RESET_GET_BOARD_ID(x)\t    (((x)>> 2)&0x03)\t \n#define     BOARD_ID_LANAI256\t\t(0)\t \n\tEndian_Reg\t\t= 0x04,\t \n\tIntStatus_Reg\t\t= 0x08,\t \n\tIntStatusMasked_Reg\t= 0x0C,\t \n\tIntAck_Reg\t\t= 0x10,\t \n\tIntAckMasked_Reg\t= 0x14,\t \n\tIntStatusSet_Reg\t= 0x18,\t \n\tIntStatusSetMasked_Reg\t= 0x1C,\t \n\tIntControlEna_Reg\t= 0x20,\t \n\tIntControlDis_Reg\t= 0x24,\t \n\tStatus_Reg\t\t= 0x28,\t \n#define   STATUS_PROMDATA\t (0x00000001)\t \n#define   STATUS_WAITING\t (0x00000002)\t \n#define\t  STATUS_SOOL\t\t (0x00000004)\t \n#define   STATUS_LOCD\t\t (0x00000008)\t \n#define\t  STATUS_LED\t\t (0x00000010)\t \n#define   STATUS_GPIN\t\t (0x00000020)\t \n#define   STATUS_BUTTBUSY\t (0x00000040)\t \n\tConfig1_Reg\t\t= 0x2C,\t \n#define   CONFIG1_PROMDATA\t (0x00000001)\t \n#define   CONFIG1_PROMCLK\t (0x00000002)\t \n#define   CONFIG1_SET_READMODE(x) ((x)*0x004)\t \n#define     READMODE_PLAIN\t    (0)\t\t \n#define     READMODE_LINE\t    (2)\t\t \n#define     READMODE_MULTIPLE\t    (3)\t\t \n#define   CONFIG1_DMA_ENABLE\t (0x00000010)\t \n#define   CONFIG1_POWERDOWN\t (0x00000020)\t \n#define   CONFIG1_SET_LOOPMODE(x) ((x)*0x080)\t \n#define     LOOPMODE_NORMAL\t    (0)\t\t \n#define     LOOPMODE_TIME\t    (1)\n#define     LOOPMODE_DIAG\t    (2)\n#define     LOOPMODE_LINE\t    (3)\n#define   CONFIG1_MASK_LOOPMODE  (0x00000180)\n#define   CONFIG1_SET_LEDMODE(x) ((x)*0x0200)\t \n#define     LEDMODE_NOT_SOOL\t    (0)\t\t \n#define\t    LEDMODE_OFF\t\t    (1)\t\t \n#define\t    LEDMODE_ON\t\t    (2)\t\t \n#define\t    LEDMODE_NOT_LOCD\t    (3)\t\t \n#define\t    LEDMORE_GPIN\t    (4)\t\t \n#define     LEDMODE_NOT_GPIN\t    (7)\t\t \n#define   CONFIG1_MASK_LEDMODE\t (0x00000E00)\n#define   CONFIG1_GPOUT1\t (0x00001000)\t \n#define   CONFIG1_GPOUT2\t (0x00002000)\t \n#define   CONFIG1_GPOUT3\t (0x00004000)\t \n\tConfig2_Reg\t\t= 0x30,\t \n#define   CONFIG2_HOWMANY\t (0x00000001)\t \n#define   CONFIG2_PTI7_MODE\t (0x00000002)\t \n#define   CONFIG2_VPI_CHK_DIS\t (0x00000004)\t \n#define   CONFIG2_HEC_DROP\t (0x00000008)\t \n#define   CONFIG2_VCI0_NORMAL\t (0x00000010)\t \n#define   CONFIG2_CBR_ENABLE\t (0x00000020)\t \n#define   CONFIG2_TRASH_ALL\t (0x00000040)\t \n#define   CONFIG2_TX_DISABLE\t (0x00000080)\t \n#define   CONFIG2_SET_TRASH\t (0x00000100)\t \n\tStatistics_Reg\t\t= 0x34,\t \n#define   STATS_GET_FIFO_OVFL(x)    (((x)>> 0)&0xFF)\t \n#define   STATS_GET_HEC_ERR(x)      (((x)>> 8)&0xFF)\t \n#define   STATS_GET_BAD_VCI(x)      (((x)>>16)&0xFF)\t \n#define   STATS_GET_BUF_OVFL(x)     (((x)>>24)&0xFF)\t \n\tServiceStuff_Reg\t= 0x38,\t \n#define   SSTUFF_SET_SIZE(x) ((x)*0x20000000)\t \n#define   SSTUFF_SET_ADDR(x)\t    ((x)>>8)\t \n\tServWrite_Reg\t\t= 0x3C,\t \n\tServRead_Reg\t\t= 0x40,\t \n\tTxDepth_Reg\t\t= 0x44,\t \n\tButt_Reg\t\t= 0x48,\t \n\tCBR_ICG_Reg\t\t= 0x50,\n\tCBR_PTR_Reg\t\t= 0x54,\n\tPingCount_Reg\t\t= 0x58,\t \n\tDMA_Addr_Reg\t\t= 0x5C\t \n};\n\nstatic inline bus_addr_t reg_addr(const struct lanai_dev *lanai,\n\tenum lanai_register reg)\n{\n\treturn lanai->base + reg;\n}\n\nstatic inline u32 reg_read(const struct lanai_dev *lanai,\n\tenum lanai_register reg)\n{\n\tu32 t;\n\tt = readl(reg_addr(lanai, reg));\n\tRWDEBUG(\"R [0x%08X] 0x%02X = 0x%08X\\n\", (unsigned int) lanai->base,\n\t    (int) reg, t);\n\treturn t;\n}\n\nstatic inline void reg_write(const struct lanai_dev *lanai, u32 val,\n\tenum lanai_register reg)\n{\n\tRWDEBUG(\"W [0x%08X] 0x%02X < 0x%08X\\n\", (unsigned int) lanai->base,\n\t    (int) reg, val);\n\twritel(val, reg_addr(lanai, reg));\n}\n\nstatic inline void conf1_write(const struct lanai_dev *lanai)\n{\n\treg_write(lanai, lanai->conf1, Config1_Reg);\n}\n\nstatic inline void conf2_write(const struct lanai_dev *lanai)\n{\n\treg_write(lanai, lanai->conf2, Config2_Reg);\n}\n\n \nstatic inline void conf2_write_if_powerup(const struct lanai_dev *lanai)\n{\n#ifdef USE_POWERDOWN\n\tif (unlikely((lanai->conf1 & CONFIG1_POWERDOWN) != 0))\n\t\treturn;\n#endif  \n\tconf2_write(lanai);\n}\n\nstatic inline void reset_board(const struct lanai_dev *lanai)\n{\n\tDPRINTK(\"about to reset board\\n\");\n\treg_write(lanai, 0, Reset_Reg);\n\t \n\tudelay(5);\n}\n\n \n\n \n#define SRAM_START (0x20000)\n#define SRAM_BYTES (0x20000)\t \n\nstatic inline bus_addr_t sram_addr(const struct lanai_dev *lanai, int offset)\n{\n\treturn lanai->base + SRAM_START + offset;\n}\n\nstatic inline u32 sram_read(const struct lanai_dev *lanai, int offset)\n{\n\treturn readl(sram_addr(lanai, offset));\n}\n\nstatic inline void sram_write(const struct lanai_dev *lanai,\n\tu32 val, int offset)\n{\n\twritel(val, sram_addr(lanai, offset));\n}\n\nstatic int sram_test_word(const struct lanai_dev *lanai, int offset,\n\t\t\t  u32 pattern)\n{\n\tu32 readback;\n\tsram_write(lanai, pattern, offset);\n\treadback = sram_read(lanai, offset);\n\tif (likely(readback == pattern))\n\t\treturn 0;\n\tprintk(KERN_ERR DEV_LABEL\n\t    \"(itf %d): SRAM word at %d bad: wrote 0x%X, read 0x%X\\n\",\n\t    lanai->number, offset,\n\t    (unsigned int) pattern, (unsigned int) readback);\n\treturn -EIO;\n}\n\nstatic int sram_test_pass(const struct lanai_dev *lanai, u32 pattern)\n{\n\tint offset, result = 0;\n\tfor (offset = 0; offset < SRAM_BYTES && result == 0; offset += 4)\n\t\tresult = sram_test_word(lanai, offset, pattern);\n\treturn result;\n}\n\nstatic int sram_test_and_clear(const struct lanai_dev *lanai)\n{\n#ifdef FULL_MEMORY_TEST\n\tint result;\n\tDPRINTK(\"testing SRAM\\n\");\n\tif ((result = sram_test_pass(lanai, 0x5555)) != 0)\n\t\treturn result;\n\tif ((result = sram_test_pass(lanai, 0xAAAA)) != 0)\n\t\treturn result;\n#endif\n\tDPRINTK(\"clearing SRAM\\n\");\n\treturn sram_test_pass(lanai, 0x0000);\n}\n\n \n\n \nenum lanai_vcc_offset {\n\tvcc_rxaddr1\t\t= 0x00,\t \n#define   RXADDR1_SET_SIZE(x) ((x)*0x0000100)\t \n#define   RXADDR1_SET_RMMODE(x) ((x)*0x00800)\t \n#define     RMMODE_TRASH\t  (0)\t\t \n#define     RMMODE_PRESERVE\t  (1)\t\t \n#define     RMMODE_PIPE\t\t  (2)\t\t \n#define     RMMODE_PIPEALL\t  (3)\t\t \n#define   RXADDR1_OAM_PRESERVE\t (0x00002000)\t \n#define   RXADDR1_SET_MODE(x) ((x)*0x0004000)\t \n#define     RXMODE_TRASH\t  (0)\t\t \n#define     RXMODE_AAL0\t\t  (1)\t\t \n#define     RXMODE_AAL5\t\t  (2)\t\t \n#define     RXMODE_AAL5_STREAM\t  (3)\t\t \n\tvcc_rxaddr2\t\t= 0x04,\t \n\tvcc_rxcrc1\t\t= 0x08,\t \n\tvcc_rxcrc2\t\t= 0x0C,\n\tvcc_rxwriteptr\t\t= 0x10,  \n#define   RXWRITEPTR_LASTEFCI\t (0x00002000)\t \n#define   RXWRITEPTR_DROPPING\t (0x00004000)\t \n#define   RXWRITEPTR_TRASHING\t (0x00008000)\t \n\tvcc_rxbufstart\t\t= 0x14,\t \n#define   RXBUFSTART_CLP\t (0x00004000)\n#define   RXBUFSTART_CI\t\t (0x00008000)\n\tvcc_rxreadptr\t\t= 0x18,\t \n\tvcc_txicg\t\t= 0x1C,  \n\tvcc_txaddr1\t\t= 0x20,\t \n#define   TXADDR1_SET_SIZE(x) ((x)*0x0000100)\t \n#define   TXADDR1_ABR\t\t (0x00008000)\t \n\tvcc_txaddr2\t\t= 0x24,\t \n\tvcc_txcrc1\t\t= 0x28,\t \n\tvcc_txcrc2\t\t= 0x2C,\n\tvcc_txreadptr\t\t= 0x30,  \n#define   TXREADPTR_GET_PTR(x) ((x)&0x01FFF)\n#define   TXREADPTR_MASK_DELTA\t(0x0000E000)\t \n\tvcc_txendptr\t\t= 0x34,  \n#define   TXENDPTR_CLP\t\t(0x00002000)\n#define   TXENDPTR_MASK_PDUMODE\t(0x0000C000)\t \n#define     PDUMODE_AAL0\t (0*0x04000)\n#define     PDUMODE_AAL5\t (2*0x04000)\n#define     PDUMODE_AAL5STREAM\t (3*0x04000)\n\tvcc_txwriteptr\t\t= 0x38,\t \n#define   TXWRITEPTR_GET_PTR(x) ((x)&0x1FFF)\n\tvcc_txcbr_next\t\t= 0x3C\t \n#define   TXCBR_NEXT_BOZO\t(0x00008000)\t \n};\n\n#define CARDVCC_SIZE\t(0x40)\n\nstatic inline bus_addr_t cardvcc_addr(const struct lanai_dev *lanai,\n\tvci_t vci)\n{\n\treturn sram_addr(lanai, vci * CARDVCC_SIZE);\n}\n\nstatic inline u32 cardvcc_read(const struct lanai_vcc *lvcc,\n\tenum lanai_vcc_offset offset)\n{\n\tu32 val;\n\tAPRINTK(lvcc->vbase != NULL, \"cardvcc_read: unbound vcc!\\n\");\n\tval= readl(lvcc->vbase + offset);\n\tRWDEBUG(\"VR vci=%04d 0x%02X = 0x%08X\\n\",\n\t    lvcc->vci, (int) offset, val);\n\treturn val;\n}\n\nstatic inline void cardvcc_write(const struct lanai_vcc *lvcc,\n\tu32 val, enum lanai_vcc_offset offset)\n{\n\tAPRINTK(lvcc->vbase != NULL, \"cardvcc_write: unbound vcc!\\n\");\n\tAPRINTK((val & ~0xFFFF) == 0,\n\t    \"cardvcc_write: bad val 0x%X (vci=%d, addr=0x%02X)\\n\",\n\t    (unsigned int) val, lvcc->vci, (unsigned int) offset);\n\tRWDEBUG(\"VW vci=%04d 0x%02X > 0x%08X\\n\",\n\t    lvcc->vci, (unsigned int) offset, (unsigned int) val);\n\twritel(val, lvcc->vbase + offset);\n}\n\n \n\n \nstatic inline int aal5_size(int size)\n{\n\tint cells = (size + 8 + 47) / 48;\n\treturn cells * 48;\n}\n\n \n\nstatic inline void lanai_free_skb(struct atm_vcc *atmvcc, struct sk_buff *skb)\n{\n\tif (atmvcc->pop != NULL)\n\t\tatmvcc->pop(atmvcc, skb);\n\telse\n\t\tdev_kfree_skb_any(skb);\n}\n\n \n\nstatic void host_vcc_start_rx(const struct lanai_vcc *lvcc)\n{\n\tu32 addr1;\n\tif (lvcc->rx.atmvcc->qos.aal == ATM_AAL5) {\n\t\tdma_addr_t dmaaddr = lvcc->rx.buf.dmaaddr;\n\t\tcardvcc_write(lvcc, 0xFFFF, vcc_rxcrc1);\n\t\tcardvcc_write(lvcc, 0xFFFF, vcc_rxcrc2);\n\t\tcardvcc_write(lvcc, 0, vcc_rxwriteptr);\n\t\tcardvcc_write(lvcc, 0, vcc_rxbufstart);\n\t\tcardvcc_write(lvcc, 0, vcc_rxreadptr);\n\t\tcardvcc_write(lvcc, (dmaaddr >> 16) & 0xFFFF, vcc_rxaddr2);\n\t\taddr1 = ((dmaaddr >> 8) & 0xFF) |\n\t\t    RXADDR1_SET_SIZE(lanai_buf_size_cardorder(&lvcc->rx.buf))|\n\t\t    RXADDR1_SET_RMMODE(RMMODE_TRASH) |\t \n\t\t  \n\t\t    RXADDR1_SET_MODE(RXMODE_AAL5);\n\t} else\n\t\taddr1 = RXADDR1_SET_RMMODE(RMMODE_PRESERVE) |  \n\t\t    RXADDR1_OAM_PRESERVE |\t\t       \n\t\t    RXADDR1_SET_MODE(RXMODE_AAL0);\n\t \n\tcardvcc_write(lvcc, addr1, vcc_rxaddr1);\n}\n\nstatic void host_vcc_start_tx(const struct lanai_vcc *lvcc)\n{\n\tdma_addr_t dmaaddr = lvcc->tx.buf.dmaaddr;\n\tcardvcc_write(lvcc, 0, vcc_txicg);\n\tcardvcc_write(lvcc, 0xFFFF, vcc_txcrc1);\n\tcardvcc_write(lvcc, 0xFFFF, vcc_txcrc2);\n\tcardvcc_write(lvcc, 0, vcc_txreadptr);\n\tcardvcc_write(lvcc, 0, vcc_txendptr);\n\tcardvcc_write(lvcc, 0, vcc_txwriteptr);\n\tcardvcc_write(lvcc,\n\t\t(lvcc->tx.atmvcc->qos.txtp.traffic_class == ATM_CBR) ?\n\t\tTXCBR_NEXT_BOZO | lvcc->vci : 0, vcc_txcbr_next);\n\tcardvcc_write(lvcc, (dmaaddr >> 16) & 0xFFFF, vcc_txaddr2);\n\tcardvcc_write(lvcc,\n\t    ((dmaaddr >> 8) & 0xFF) |\n\t    TXADDR1_SET_SIZE(lanai_buf_size_cardorder(&lvcc->tx.buf)),\n\t    vcc_txaddr1);\n}\n\n \nstatic void lanai_shutdown_rx_vci(const struct lanai_vcc *lvcc)\n{\n\tif (lvcc->vbase == NULL)\t \n\t\treturn;\n\t \n\tcardvcc_write(lvcc,\n\t    RXADDR1_SET_RMMODE(RMMODE_TRASH) |\n\t    RXADDR1_SET_MODE(RXMODE_TRASH), vcc_rxaddr1);\n\tudelay(15);\n\t \n\tcardvcc_write(lvcc, 0, vcc_rxaddr2);\n\tcardvcc_write(lvcc, 0, vcc_rxcrc1);\n\tcardvcc_write(lvcc, 0, vcc_rxcrc2);\n\tcardvcc_write(lvcc, 0, vcc_rxwriteptr);\n\tcardvcc_write(lvcc, 0, vcc_rxbufstart);\n\tcardvcc_write(lvcc, 0, vcc_rxreadptr);\n}\n\n \nstatic void lanai_shutdown_tx_vci(struct lanai_dev *lanai,\n\tstruct lanai_vcc *lvcc)\n{\n\tstruct sk_buff *skb;\n\tunsigned long flags, timeout;\n\tint read, write, lastread = -1;\n\n\tif (lvcc->vbase == NULL)\t \n\t\treturn;\n\t \n\twhile ((skb = skb_dequeue(&lvcc->tx.backlog)) != NULL)\n\t\tlanai_free_skb(lvcc->tx.atmvcc, skb);\n\tread_lock_irqsave(&vcc_sklist_lock, flags);\n\t__clear_bit(lvcc->vci, lanai->backlog_vccs);\n\tread_unlock_irqrestore(&vcc_sklist_lock, flags);\n\t \n\ttimeout = jiffies +\n\t    (((lanai_buf_size(&lvcc->tx.buf) / 1024) * HZ) >> 7);\n\twrite = TXWRITEPTR_GET_PTR(cardvcc_read(lvcc, vcc_txwriteptr));\n\tfor (;;) {\n\t\tread = TXREADPTR_GET_PTR(cardvcc_read(lvcc, vcc_txreadptr));\n\t\tif (read == write &&\t    \n\t\t    (lvcc->tx.atmvcc->qos.txtp.traffic_class != ATM_CBR ||\n\t\t    (cardvcc_read(lvcc, vcc_txcbr_next) &\n\t\t    TXCBR_NEXT_BOZO) == 0))\n\t\t\tbreak;\n\t\tif (read != lastread) {\t    \n\t\t\tlastread = read;\n\t\t\ttimeout += HZ / 10;\n\t\t}\n\t\tif (unlikely(time_after(jiffies, timeout))) {\n\t\t\tprintk(KERN_ERR DEV_LABEL \"(itf %d): Timed out on \"\n\t\t\t    \"backlog closing vci %d\\n\",\n\t\t\t    lvcc->tx.atmvcc->dev->number, lvcc->vci);\n\t\t\tDPRINTK(\"read, write = %d, %d\\n\", read, write);\n\t\t\tbreak;\n\t\t}\n\t\tmsleep(40);\n\t}\n\t \n\tcardvcc_write(lvcc, 0, vcc_txreadptr);\n\tcardvcc_write(lvcc, 0, vcc_txwriteptr);\n\tcardvcc_write(lvcc, 0, vcc_txendptr);\n\tcardvcc_write(lvcc, 0, vcc_txcrc1);\n\tcardvcc_write(lvcc, 0, vcc_txcrc2);\n\tcardvcc_write(lvcc, 0, vcc_txaddr2);\n\tcardvcc_write(lvcc, 0, vcc_txaddr1);\n}\n\n \n\nstatic inline int aal0_buffer_allocate(struct lanai_dev *lanai)\n{\n\tDPRINTK(\"aal0_buffer_allocate: allocating AAL0 RX buffer\\n\");\n\tlanai_buf_allocate(&lanai->aal0buf, AAL0_RX_BUFFER_SIZE, 80,\n\t\t\t   lanai->pci);\n\treturn (lanai->aal0buf.start == NULL) ? -ENOMEM : 0;\n}\n\nstatic inline void aal0_buffer_free(struct lanai_dev *lanai)\n{\n\tDPRINTK(\"aal0_buffer_allocate: freeing AAL0 RX buffer\\n\");\n\tlanai_buf_deallocate(&lanai->aal0buf, lanai->pci);\n}\n\n \n\n \n#define EEPROM_COPYRIGHT\t(0)\n#define EEPROM_COPYRIGHT_LEN\t(44)\n#define EEPROM_CHECKSUM\t\t(62)\n#define EEPROM_CHECKSUM_REV\t(63)\n#define EEPROM_MAC\t\t(64)\n#define EEPROM_MAC_REV\t\t(70)\n#define EEPROM_SERIAL\t\t(112)\n#define EEPROM_SERIAL_REV\t(116)\n#define EEPROM_MAGIC\t\t(120)\n#define EEPROM_MAGIC_REV\t(124)\n\n#define EEPROM_MAGIC_VALUE\t(0x5AB478D2)\n\n#ifndef READ_EEPROM\n\n \nstatic int eeprom_read(struct lanai_dev *lanai)\n{\n\tprintk(KERN_INFO DEV_LABEL \"(itf %d): *NOT* reading EEPROM\\n\",\n\t    lanai->number);\n\tmemset(&lanai->eeprom[EEPROM_MAC], 0, 6);\n\treturn 0;\n}\n\nstatic int eeprom_validate(struct lanai_dev *lanai)\n{\n\tlanai->serialno = 0;\n\tlanai->magicno = EEPROM_MAGIC_VALUE;\n\treturn 0;\n}\n\n#else  \n\nstatic int eeprom_read(struct lanai_dev *lanai)\n{\n\tint i, address;\n\tu8 data;\n\tu32 tmp;\n#define set_config1(x)   do { lanai->conf1 = x; conf1_write(lanai); \\\n\t\t\t    } while (0)\n#define clock_h()\t set_config1(lanai->conf1 | CONFIG1_PROMCLK)\n#define clock_l()\t set_config1(lanai->conf1 &~ CONFIG1_PROMCLK)\n#define data_h()\t set_config1(lanai->conf1 | CONFIG1_PROMDATA)\n#define data_l()\t set_config1(lanai->conf1 &~ CONFIG1_PROMDATA)\n#define pre_read()\t do { data_h(); clock_h(); udelay(5); } while (0)\n#define read_pin()\t (reg_read(lanai, Status_Reg) & STATUS_PROMDATA)\n#define send_stop()\t do { data_l(); udelay(5); clock_h(); udelay(5); \\\n\t\t\t      data_h(); udelay(5); } while (0)\n\t \n\tdata_h(); clock_h(); udelay(5);\n\tfor (address = 0; address < LANAI_EEPROM_SIZE; address++) {\n\t\tdata = (address << 1) | 1;\t \n\t\t \n\t\tdata_l(); udelay(5);\n\t\tclock_l(); udelay(5);\n\t\tfor (i = 128; i != 0; i >>= 1) {    \n\t\t\ttmp = (lanai->conf1 & ~CONFIG1_PROMDATA) |\n\t\t\t    ((data & i) ? CONFIG1_PROMDATA : 0);\n\t\t\tif (lanai->conf1 != tmp) {\n\t\t\t\tset_config1(tmp);\n\t\t\t\tudelay(5);\t \n\t\t\t}\n\t\t\tclock_h(); udelay(5); clock_l(); udelay(5);\n\t\t}\n\t\t \n\t\tdata_h(); clock_h(); udelay(5);\n\t\tif (read_pin() != 0)\n\t\t\tgoto error;\t \n\t\tclock_l(); udelay(5);\n\t\t \n\t\tfor (data = 0, i = 7; i >= 0; i--) {\n\t\t\tdata_h(); clock_h(); udelay(5);\n\t\t\tdata = (data << 1) | !!read_pin();\n\t\t\tclock_l(); udelay(5);\n\t\t}\n\t\t \n\t\tdata_h(); clock_h(); udelay(5);\n\t\tif (read_pin() == 0)\n\t\t\tgoto error;\t \n\t\tclock_l(); udelay(5);\n\t\tsend_stop();\n\t\tlanai->eeprom[address] = data;\n\t\tDPRINTK(\"EEPROM 0x%04X %02X\\n\",\n\t\t    (unsigned int) address, (unsigned int) data);\n\t}\n\treturn 0;\n    error:\n\tclock_l(); udelay(5);\t\t \n\tsend_stop();\n\tprintk(KERN_ERR DEV_LABEL \"(itf %d): error reading EEPROM byte %d\\n\",\n\t    lanai->number, address);\n\treturn -EIO;\n#undef set_config1\n#undef clock_h\n#undef clock_l\n#undef data_h\n#undef data_l\n#undef pre_read\n#undef read_pin\n#undef send_stop\n}\n\n \nstatic inline u32 eeprom_be4(const struct lanai_dev *lanai, int address)\n{\n\treturn be32_to_cpup((const u32 *) &lanai->eeprom[address]);\n}\n\n \nstatic int eeprom_validate(struct lanai_dev *lanai)\n{\n\tint i, s;\n\tu32 v;\n\tconst u8 *e = lanai->eeprom;\n#ifdef DEBUG\n\t \n\tfor (i = EEPROM_COPYRIGHT;\n\t    i < (EEPROM_COPYRIGHT + EEPROM_COPYRIGHT_LEN); i++)\n\t\tif (e[i] < 0x20 || e[i] > 0x7E)\n\t\t\tbreak;\n\tif ( i != EEPROM_COPYRIGHT &&\n\t    i != EEPROM_COPYRIGHT + EEPROM_COPYRIGHT_LEN && e[i] == '\\0')\n\t\tDPRINTK(\"eeprom: copyright = \\\"%s\\\"\\n\",\n\t\t    (char *) &e[EEPROM_COPYRIGHT]);\n\telse\n\t\tDPRINTK(\"eeprom: copyright not found\\n\");\n#endif\n\t \n\tfor (i = s = 0; i < EEPROM_CHECKSUM; i++)\n\t\ts += e[i];\n\ts &= 0xFF;\n\tif (s != e[EEPROM_CHECKSUM]) {\n\t\tprintk(KERN_ERR DEV_LABEL \"(itf %d): EEPROM checksum bad \"\n\t\t    \"(wanted 0x%02X, got 0x%02X)\\n\", lanai->number,\n\t\t    (unsigned int) s, (unsigned int) e[EEPROM_CHECKSUM]);\n\t\treturn -EIO;\n\t}\n\ts ^= 0xFF;\n\tif (s != e[EEPROM_CHECKSUM_REV]) {\n\t\tprintk(KERN_ERR DEV_LABEL \"(itf %d): EEPROM inverse checksum \"\n\t\t    \"bad (wanted 0x%02X, got 0x%02X)\\n\", lanai->number,\n\t\t    (unsigned int) s, (unsigned int) e[EEPROM_CHECKSUM_REV]);\n\t\treturn -EIO;\n\t}\n\t \n\tfor (i = 0; i < 6; i++)\n\t\tif ((e[EEPROM_MAC + i] ^ e[EEPROM_MAC_REV + i]) != 0xFF) {\n\t\t\tprintk(KERN_ERR DEV_LABEL\n\t\t\t    \"(itf %d) : EEPROM MAC addresses don't match \"\n\t\t\t    \"(0x%02X, inverse 0x%02X)\\n\", lanai->number,\n\t\t\t    (unsigned int) e[EEPROM_MAC + i],\n\t\t\t    (unsigned int) e[EEPROM_MAC_REV + i]);\n\t\t\treturn -EIO;\n\t\t}\n\tDPRINTK(\"eeprom: MAC address = %pM\\n\", &e[EEPROM_MAC]);\n\t \n\tlanai->serialno = eeprom_be4(lanai, EEPROM_SERIAL);\n\tv = eeprom_be4(lanai, EEPROM_SERIAL_REV);\n\tif ((lanai->serialno ^ v) != 0xFFFFFFFF) {\n\t\tprintk(KERN_ERR DEV_LABEL \"(itf %d): EEPROM serial numbers \"\n\t\t    \"don't match (0x%08X, inverse 0x%08X)\\n\", lanai->number,\n\t\t    (unsigned int) lanai->serialno, (unsigned int) v);\n\t\treturn -EIO;\n\t}\n\tDPRINTK(\"eeprom: Serial number = %d\\n\", (unsigned int) lanai->serialno);\n\t \n\tlanai->magicno = eeprom_be4(lanai, EEPROM_MAGIC);\n\tv = eeprom_be4(lanai, EEPROM_MAGIC_REV);\n\tif ((lanai->magicno ^ v) != 0xFFFFFFFF) {\n\t\tprintk(KERN_ERR DEV_LABEL \"(itf %d): EEPROM magic numbers \"\n\t\t    \"don't match (0x%08X, inverse 0x%08X)\\n\", lanai->number,\n\t\t    lanai->magicno, v);\n\t\treturn -EIO;\n\t}\n\tDPRINTK(\"eeprom: Magic number = 0x%08X\\n\", lanai->magicno);\n\tif (lanai->magicno != EEPROM_MAGIC_VALUE)\n\t\tprintk(KERN_WARNING DEV_LABEL \"(itf %d): warning - EEPROM \"\n\t\t    \"magic not what expected (got 0x%08X, not 0x%08X)\\n\",\n\t\t    lanai->number, (unsigned int) lanai->magicno,\n\t\t    (unsigned int) EEPROM_MAGIC_VALUE);\n\treturn 0;\n}\n\n#endif  \n\nstatic inline const u8 *eeprom_mac(const struct lanai_dev *lanai)\n{\n\treturn &lanai->eeprom[EEPROM_MAC];\n}\n\n \n\n \n#define INT_STATS\t(0x00000002)\t \n#define INT_SOOL\t(0x00000004)\t \n#define INT_LOCD\t(0x00000008)\t \n#define INT_LED\t\t(0x00000010)\t \n#define INT_GPIN\t(0x00000020)\t \n#define INT_PING\t(0x00000040)\t \n#define INT_WAKE\t(0x00000080)\t \n#define INT_CBR0\t(0x00000100)\t \n#define INT_LOCK\t(0x00000200)\t \n#define INT_MISMATCH\t(0x00000400)\t \n#define INT_AAL0_STR\t(0x00000800)\t \n#define INT_AAL0\t(0x00001000)\t \n#define INT_SERVICE\t(0x00002000)\t \n#define INT_TABORTSENT\t(0x00004000)\t \n#define INT_TABORTBM\t(0x00008000)\t \n#define INT_TIMEOUTBM\t(0x00010000)\t \n#define INT_PCIPARITY\t(0x00020000)\t \n\n \n#define INT_ALL\t\t(0x0003FFFE)\t \n#define INT_STATUS\t(0x0000003C)\t \n#define INT_DMASHUT\t(0x00038000)\t \n#define INT_SEGSHUT\t(0x00000700)\t \n\nstatic inline u32 intr_pending(const struct lanai_dev *lanai)\n{\n\treturn reg_read(lanai, IntStatusMasked_Reg);\n}\n\nstatic inline void intr_enable(const struct lanai_dev *lanai, u32 i)\n{\n\treg_write(lanai, i, IntControlEna_Reg);\n}\n\nstatic inline void intr_disable(const struct lanai_dev *lanai, u32 i)\n{\n\treg_write(lanai, i, IntControlDis_Reg);\n}\n\n \n\nstatic void status_message(int itf, const char *name, int status)\n{\n\tstatic const char *onoff[2] = { \"off to on\", \"on to off\" };\n\tprintk(KERN_INFO DEV_LABEL \"(itf %d): %s changed from %s\\n\",\n\t    itf, name, onoff[!status]);\n}\n\nstatic void lanai_check_status(struct lanai_dev *lanai)\n{\n\tu32 new = reg_read(lanai, Status_Reg);\n\tu32 changes = new ^ lanai->status;\n\tlanai->status = new;\n#define e(flag, name) \\\n\t\tif (changes & flag) \\\n\t\t\tstatus_message(lanai->number, name, new & flag)\n\te(STATUS_SOOL, \"SOOL\");\n\te(STATUS_LOCD, \"LOCD\");\n\te(STATUS_LED, \"LED\");\n\te(STATUS_GPIN, \"GPIN\");\n#undef e\n}\n\nstatic void pcistatus_got(int itf, const char *name)\n{\n\tprintk(KERN_INFO DEV_LABEL \"(itf %d): PCI got %s error\\n\", itf, name);\n}\n\nstatic void pcistatus_check(struct lanai_dev *lanai, int clearonly)\n{\n\tu16 s;\n\tint result;\n\tresult = pci_read_config_word(lanai->pci, PCI_STATUS, &s);\n\tif (result != PCIBIOS_SUCCESSFUL) {\n\t\tprintk(KERN_ERR DEV_LABEL \"(itf %d): can't read PCI_STATUS: \"\n\t\t    \"%d\\n\", lanai->number, result);\n\t\treturn;\n\t}\n\ts &= PCI_STATUS_DETECTED_PARITY | PCI_STATUS_SIG_SYSTEM_ERROR |\n\t    PCI_STATUS_REC_MASTER_ABORT | PCI_STATUS_REC_TARGET_ABORT |\n\t    PCI_STATUS_SIG_TARGET_ABORT | PCI_STATUS_PARITY;\n\tif (s == 0)\n\t\treturn;\n\tresult = pci_write_config_word(lanai->pci, PCI_STATUS, s);\n\tif (result != PCIBIOS_SUCCESSFUL)\n\t\tprintk(KERN_ERR DEV_LABEL \"(itf %d): can't write PCI_STATUS: \"\n\t\t    \"%d\\n\", lanai->number, result);\n\tif (clearonly)\n\t\treturn;\n#define e(flag, name, stat) \\\n\t\tif (s & flag) { \\\n\t\t\tpcistatus_got(lanai->number, name); \\\n\t\t\t++lanai->stats.pcierr_##stat; \\\n\t\t}\n\te(PCI_STATUS_DETECTED_PARITY, \"parity\", parity_detect);\n\te(PCI_STATUS_SIG_SYSTEM_ERROR, \"signalled system\", serr_set);\n\te(PCI_STATUS_REC_MASTER_ABORT, \"master\", master_abort);\n\te(PCI_STATUS_REC_TARGET_ABORT, \"master target\", m_target_abort);\n\te(PCI_STATUS_SIG_TARGET_ABORT, \"slave\", s_target_abort);\n\te(PCI_STATUS_PARITY, \"master parity\", master_parity);\n#undef e\n}\n\n \n\n \nstatic inline int vcc_tx_space(const struct lanai_vcc *lvcc, int endptr)\n{\n\tint r;\n\tr = endptr * 16;\n\tr -= ((unsigned long) lvcc->tx.buf.ptr) -\n\t    ((unsigned long) lvcc->tx.buf.start);\n\tr -= 16;\t \n\tif (r < 0)\n\t\tr += lanai_buf_size(&lvcc->tx.buf);\n\treturn r;\n}\n\n \nstatic inline int vcc_is_backlogged(const struct lanai_vcc *lvcc)\n{\n\treturn !skb_queue_empty(&lvcc->tx.backlog);\n}\n\n \n#define DESCRIPTOR_MAGIC\t(0xD0000000)\n#define DESCRIPTOR_AAL5\t\t(0x00008000)\n#define DESCRIPTOR_AAL5_STREAM\t(0x00004000)\n#define DESCRIPTOR_CLP\t\t(0x00002000)\n\n \nstatic inline void vcc_tx_add_aal5_descriptor(struct lanai_vcc *lvcc,\n\tu32 flags, int len)\n{\n\tint pos;\n\tAPRINTK((((unsigned long) lvcc->tx.buf.ptr) & 15) == 0,\n\t    \"vcc_tx_add_aal5_descriptor: bad ptr=%p\\n\", lvcc->tx.buf.ptr);\n\tlvcc->tx.buf.ptr += 4;\t \n\tpos = ((unsigned char *) lvcc->tx.buf.ptr) -\n\t    (unsigned char *) lvcc->tx.buf.start;\n\tAPRINTK((pos & ~0x0001FFF0) == 0,\n\t    \"vcc_tx_add_aal5_descriptor: bad pos (%d) before, vci=%d, \"\n\t    \"start,ptr,end=%p,%p,%p\\n\", pos, lvcc->vci,\n\t    lvcc->tx.buf.start, lvcc->tx.buf.ptr, lvcc->tx.buf.end);\n\tpos = (pos + len) & (lanai_buf_size(&lvcc->tx.buf) - 1);\n\tAPRINTK((pos & ~0x0001FFF0) == 0,\n\t    \"vcc_tx_add_aal5_descriptor: bad pos (%d) after, vci=%d, \"\n\t    \"start,ptr,end=%p,%p,%p\\n\", pos, lvcc->vci,\n\t    lvcc->tx.buf.start, lvcc->tx.buf.ptr, lvcc->tx.buf.end);\n\tlvcc->tx.buf.ptr[-1] =\n\t    cpu_to_le32(DESCRIPTOR_MAGIC | DESCRIPTOR_AAL5 |\n\t    ((lvcc->tx.atmvcc->atm_options & ATM_ATMOPT_CLP) ?\n\t    DESCRIPTOR_CLP : 0) | flags | pos >> 4);\n\tif (lvcc->tx.buf.ptr >= lvcc->tx.buf.end)\n\t\tlvcc->tx.buf.ptr = lvcc->tx.buf.start;\n}\n\n \nstatic inline void vcc_tx_add_aal5_trailer(struct lanai_vcc *lvcc,\n\tint len, int cpi, int uu)\n{\n\tAPRINTK((((unsigned long) lvcc->tx.buf.ptr) & 15) == 8,\n\t    \"vcc_tx_add_aal5_trailer: bad ptr=%p\\n\", lvcc->tx.buf.ptr);\n\tlvcc->tx.buf.ptr += 2;\n\tlvcc->tx.buf.ptr[-2] = cpu_to_be32((uu << 24) | (cpi << 16) | len);\n\tif (lvcc->tx.buf.ptr >= lvcc->tx.buf.end)\n\t\tlvcc->tx.buf.ptr = lvcc->tx.buf.start;\n}\n\nstatic inline void vcc_tx_memcpy(struct lanai_vcc *lvcc,\n\tconst unsigned char *src, int n)\n{\n\tunsigned char *e;\n\tint m;\n\te = ((unsigned char *) lvcc->tx.buf.ptr) + n;\n\tm = e - (unsigned char *) lvcc->tx.buf.end;\n\tif (m < 0)\n\t\tm = 0;\n\tmemcpy(lvcc->tx.buf.ptr, src, n - m);\n\tif (m != 0) {\n\t\tmemcpy(lvcc->tx.buf.start, src + n - m, m);\n\t\te = ((unsigned char *) lvcc->tx.buf.start) + m;\n\t}\n\tlvcc->tx.buf.ptr = (u32 *) e;\n}\n\nstatic inline void vcc_tx_memzero(struct lanai_vcc *lvcc, int n)\n{\n\tunsigned char *e;\n\tint m;\n\tif (n == 0)\n\t\treturn;\n\te = ((unsigned char *) lvcc->tx.buf.ptr) + n;\n\tm = e - (unsigned char *) lvcc->tx.buf.end;\n\tif (m < 0)\n\t\tm = 0;\n\tmemset(lvcc->tx.buf.ptr, 0, n - m);\n\tif (m != 0) {\n\t\tmemset(lvcc->tx.buf.start, 0, m);\n\t\te = ((unsigned char *) lvcc->tx.buf.start) + m;\n\t}\n\tlvcc->tx.buf.ptr = (u32 *) e;\n}\n\n \nstatic inline void lanai_endtx(struct lanai_dev *lanai,\n\tconst struct lanai_vcc *lvcc)\n{\n\tint i, ptr = ((unsigned char *) lvcc->tx.buf.ptr) -\n\t    (unsigned char *) lvcc->tx.buf.start;\n\tAPRINTK((ptr & ~0x0001FFF0) == 0,\n\t    \"lanai_endtx: bad ptr (%d), vci=%d, start,ptr,end=%p,%p,%p\\n\",\n\t    ptr, lvcc->vci, lvcc->tx.buf.start, lvcc->tx.buf.ptr,\n\t    lvcc->tx.buf.end);\n\n\t \n\tspin_lock(&lanai->endtxlock);\n\t \n\tfor (i = 0; reg_read(lanai, Status_Reg) & STATUS_BUTTBUSY; i++) {\n\t\tif (unlikely(i > 50)) {\n\t\t\tprintk(KERN_ERR DEV_LABEL \"(itf %d): butt register \"\n\t\t\t    \"always busy!\\n\", lanai->number);\n\t\t\tbreak;\n\t\t}\n\t\tudelay(5);\n\t}\n\t \n\twmb();\n\treg_write(lanai, (ptr << 12) | lvcc->vci, Butt_Reg);\n\tspin_unlock(&lanai->endtxlock);\n}\n\n \nstatic void lanai_send_one_aal5(struct lanai_dev *lanai,\n\tstruct lanai_vcc *lvcc, struct sk_buff *skb, int pdusize)\n{\n\tint pad;\n\tAPRINTK(pdusize == aal5_size(skb->len),\n\t    \"lanai_send_one_aal5: wrong size packet (%d != %d)\\n\",\n\t    pdusize, aal5_size(skb->len));\n\tvcc_tx_add_aal5_descriptor(lvcc, 0, pdusize);\n\tpad = pdusize - skb->len - 8;\n\tAPRINTK(pad >= 0, \"pad is negative (%d)\\n\", pad);\n\tAPRINTK(pad < 48, \"pad is too big (%d)\\n\", pad);\n\tvcc_tx_memcpy(lvcc, skb->data, skb->len);\n\tvcc_tx_memzero(lvcc, pad);\n\tvcc_tx_add_aal5_trailer(lvcc, skb->len, 0, 0);\n\tlanai_endtx(lanai, lvcc);\n\tlanai_free_skb(lvcc->tx.atmvcc, skb);\n\tatomic_inc(&lvcc->tx.atmvcc->stats->tx);\n}\n\n \nstatic void vcc_tx_unqueue_aal5(struct lanai_dev *lanai,\n\tstruct lanai_vcc *lvcc, int endptr)\n{\n\tint n;\n\tstruct sk_buff *skb;\n\tint space = vcc_tx_space(lvcc, endptr);\n\tAPRINTK(vcc_is_backlogged(lvcc),\n\t    \"vcc_tx_unqueue() called with empty backlog (vci=%d)\\n\",\n\t    lvcc->vci);\n\twhile (space >= 64) {\n\t\tskb = skb_dequeue(&lvcc->tx.backlog);\n\t\tif (skb == NULL)\n\t\t\tgoto no_backlog;\n\t\tn = aal5_size(skb->len);\n\t\tif (n + 16 > space) {\n\t\t\t \n\t\t\tskb_queue_head(&lvcc->tx.backlog, skb);\n\t\t\treturn;\n\t\t}\n\t\tlanai_send_one_aal5(lanai, lvcc, skb, n);\n\t\tspace -= n + 16;\n\t}\n\tif (!vcc_is_backlogged(lvcc)) {\n\t    no_backlog:\n\t\t__clear_bit(lvcc->vci, lanai->backlog_vccs);\n\t}\n}\n\n \nstatic void vcc_tx_aal5(struct lanai_dev *lanai, struct lanai_vcc *lvcc,\n\tstruct sk_buff *skb)\n{\n\tint space, n;\n\tif (vcc_is_backlogged(lvcc))\t\t \n\t\tgoto queue_it;\n\tspace = vcc_tx_space(lvcc,\n\t\t    TXREADPTR_GET_PTR(cardvcc_read(lvcc, vcc_txreadptr)));\n\tn = aal5_size(skb->len);\n\tAPRINTK(n + 16 >= 64, \"vcc_tx_aal5: n too small (%d)\\n\", n);\n\tif (space < n + 16) {\t\t\t \n\t\t__set_bit(lvcc->vci, lanai->backlog_vccs);\n\t    queue_it:\n\t\tskb_queue_tail(&lvcc->tx.backlog, skb);\n\t\treturn;\n\t}\n\tlanai_send_one_aal5(lanai, lvcc, skb, n);\n}\n\nstatic void vcc_tx_unqueue_aal0(struct lanai_dev *lanai,\n\tstruct lanai_vcc *lvcc, int endptr)\n{\n\tprintk(KERN_INFO DEV_LABEL\n\t    \": vcc_tx_unqueue_aal0: not implemented\\n\");\n}\n\nstatic void vcc_tx_aal0(struct lanai_dev *lanai, struct lanai_vcc *lvcc,\n\tstruct sk_buff *skb)\n{\n\tprintk(KERN_INFO DEV_LABEL \": vcc_tx_aal0: not implemented\\n\");\n\t \n\tlanai_free_skb(lvcc->tx.atmvcc, skb);\n}\n\n \n\n \nstatic inline void vcc_rx_memcpy(unsigned char *dest,\n\tconst struct lanai_vcc *lvcc, int n)\n{\n\tint m = ((const unsigned char *) lvcc->rx.buf.ptr) + n -\n\t    ((const unsigned char *) (lvcc->rx.buf.end));\n\tif (m < 0)\n\t\tm = 0;\n\tmemcpy(dest, lvcc->rx.buf.ptr, n - m);\n\tmemcpy(dest + n - m, lvcc->rx.buf.start, m);\n\t \n\tbarrier();\n}\n\n \nstatic void vcc_rx_aal5(struct lanai_vcc *lvcc, int endptr)\n{\n\tint size;\n\tstruct sk_buff *skb;\n\tconst u32 *x;\n\tu32 *end = &lvcc->rx.buf.start[endptr * 4];\n\tint n = ((unsigned long) end) - ((unsigned long) lvcc->rx.buf.ptr);\n\tif (n < 0)\n\t\tn += lanai_buf_size(&lvcc->rx.buf);\n\tAPRINTK(n >= 0 && n < lanai_buf_size(&lvcc->rx.buf) && !(n & 15),\n\t    \"vcc_rx_aal5: n out of range (%d/%zu)\\n\",\n\t    n, lanai_buf_size(&lvcc->rx.buf));\n\t \n\tif ((x = &end[-2]) < lvcc->rx.buf.start)\n\t\tx = &lvcc->rx.buf.end[-2];\n\t \n\trmb();\n\tsize = be32_to_cpup(x) & 0xffff;\n\tif (unlikely(n != aal5_size(size))) {\n\t\t \n\t\tprintk(KERN_INFO DEV_LABEL \"(itf %d): Got bad AAL5 length \"\n\t\t    \"on vci=%d - size=%d n=%d\\n\",\n\t\t    lvcc->rx.atmvcc->dev->number, lvcc->vci, size, n);\n\t\tlvcc->stats.x.aal5.rx_badlen++;\n\t\tgoto out;\n\t}\n\tskb = atm_alloc_charge(lvcc->rx.atmvcc, size, GFP_ATOMIC);\n\tif (unlikely(skb == NULL)) {\n\t\tlvcc->stats.rx_nomem++;\n\t\tgoto out;\n\t}\n\tskb_put(skb, size);\n\tvcc_rx_memcpy(skb->data, lvcc, size);\n\tATM_SKB(skb)->vcc = lvcc->rx.atmvcc;\n\t__net_timestamp(skb);\n\tlvcc->rx.atmvcc->push(lvcc->rx.atmvcc, skb);\n\tatomic_inc(&lvcc->rx.atmvcc->stats->rx);\n    out:\n\tlvcc->rx.buf.ptr = end;\n\tcardvcc_write(lvcc, endptr, vcc_rxreadptr);\n}\n\nstatic void vcc_rx_aal0(struct lanai_dev *lanai)\n{\n\tprintk(KERN_INFO DEV_LABEL \": vcc_rx_aal0: not implemented\\n\");\n\t \n\t \n}\n\n \n\n \n#if (NUM_VCI * BITS_PER_LONG) <= PAGE_SIZE\n#define VCCTABLE_GETFREEPAGE\n#else\n#include <linux/vmalloc.h>\n#endif\n\nstatic int vcc_table_allocate(struct lanai_dev *lanai)\n{\n#ifdef VCCTABLE_GETFREEPAGE\n\tAPRINTK((lanai->num_vci) * sizeof(struct lanai_vcc *) <= PAGE_SIZE,\n\t    \"vcc table > PAGE_SIZE!\");\n\tlanai->vccs = (struct lanai_vcc **) get_zeroed_page(GFP_KERNEL);\n\treturn (lanai->vccs == NULL) ? -ENOMEM : 0;\n#else\n\tint bytes = (lanai->num_vci) * sizeof(struct lanai_vcc *);\n\tlanai->vccs = vzalloc(bytes);\n\tif (unlikely(lanai->vccs == NULL))\n\t\treturn -ENOMEM;\n\treturn 0;\n#endif\n}\n\nstatic inline void vcc_table_deallocate(const struct lanai_dev *lanai)\n{\n#ifdef VCCTABLE_GETFREEPAGE\n\tfree_page((unsigned long) lanai->vccs);\n#else\n\tvfree(lanai->vccs);\n#endif\n}\n\n \nstatic inline struct lanai_vcc *new_lanai_vcc(void)\n{\n\tstruct lanai_vcc *lvcc;\n\tlvcc =  kzalloc(sizeof(*lvcc), GFP_KERNEL);\n\tif (likely(lvcc != NULL)) {\n\t\tskb_queue_head_init(&lvcc->tx.backlog);\n#ifdef DEBUG\n\t\tlvcc->vci = -1;\n#endif\n\t}\n\treturn lvcc;\n}\n\nstatic int lanai_get_sized_buffer(struct lanai_dev *lanai,\n\tstruct lanai_buffer *buf, int max_sdu, int multiplier,\n\tconst char *name)\n{\n\tint size;\n\tif (unlikely(max_sdu < 1))\n\t\tmax_sdu = 1;\n\tmax_sdu = aal5_size(max_sdu);\n\tsize = (max_sdu + 16) * multiplier + 16;\n\tlanai_buf_allocate(buf, size, max_sdu + 32, lanai->pci);\n\tif (unlikely(buf->start == NULL))\n\t\treturn -ENOMEM;\n\tif (unlikely(lanai_buf_size(buf) < size))\n\t\tprintk(KERN_WARNING DEV_LABEL \"(itf %d): wanted %d bytes \"\n\t\t    \"for %s buffer, got only %zu\\n\", lanai->number, size,\n\t\t    name, lanai_buf_size(buf));\n\tDPRINTK(\"Allocated %zu byte %s buffer\\n\", lanai_buf_size(buf), name);\n\treturn 0;\n}\n\n \nstatic inline int lanai_setup_rx_vci_aal5(struct lanai_dev *lanai,\n\tstruct lanai_vcc *lvcc, const struct atm_qos *qos)\n{\n\treturn lanai_get_sized_buffer(lanai, &lvcc->rx.buf,\n\t    qos->rxtp.max_sdu, AAL5_RX_MULTIPLIER, \"RX\");\n}\n\n \nstatic int lanai_setup_tx_vci(struct lanai_dev *lanai, struct lanai_vcc *lvcc,\n\tconst struct atm_qos *qos)\n{\n\tint max_sdu, multiplier;\n\tif (qos->aal == ATM_AAL0) {\n\t\tlvcc->tx.unqueue = vcc_tx_unqueue_aal0;\n\t\tmax_sdu = ATM_CELL_SIZE - 1;\n\t\tmultiplier = AAL0_TX_MULTIPLIER;\n\t} else {\n\t\tlvcc->tx.unqueue = vcc_tx_unqueue_aal5;\n\t\tmax_sdu = qos->txtp.max_sdu;\n\t\tmultiplier = AAL5_TX_MULTIPLIER;\n\t}\n\treturn lanai_get_sized_buffer(lanai, &lvcc->tx.buf, max_sdu,\n\t    multiplier, \"TX\");\n}\n\nstatic inline void host_vcc_bind(struct lanai_dev *lanai,\n\tstruct lanai_vcc *lvcc, vci_t vci)\n{\n\tif (lvcc->vbase != NULL)\n\t\treturn;     \n\tDPRINTK(\"Binding vci %d\\n\", vci);\n#ifdef USE_POWERDOWN\n\tif (lanai->nbound++ == 0) {\n\t\tDPRINTK(\"Coming out of powerdown\\n\");\n\t\tlanai->conf1 &= ~CONFIG1_POWERDOWN;\n\t\tconf1_write(lanai);\n\t\tconf2_write(lanai);\n\t}\n#endif\n\tlvcc->vbase = cardvcc_addr(lanai, vci);\n\tlanai->vccs[lvcc->vci = vci] = lvcc;\n}\n\nstatic inline void host_vcc_unbind(struct lanai_dev *lanai,\n\tstruct lanai_vcc *lvcc)\n{\n\tif (lvcc->vbase == NULL)\n\t\treturn;\t \n\tDPRINTK(\"Unbinding vci %d\\n\", lvcc->vci);\n\tlvcc->vbase = NULL;\n\tlanai->vccs[lvcc->vci] = NULL;\n#ifdef USE_POWERDOWN\n\tif (--lanai->nbound == 0) {\n\t\tDPRINTK(\"Going into powerdown\\n\");\n\t\tlanai->conf1 |= CONFIG1_POWERDOWN;\n\t\tconf1_write(lanai);\n\t}\n#endif\n}\n\n \n\nstatic void lanai_reset(struct lanai_dev *lanai)\n{\n\tprintk(KERN_CRIT DEV_LABEL \"(itf %d): *NOT* resetting - not \"\n\t    \"implemented\\n\", lanai->number);\n\t \n\t \n\treg_write(lanai, INT_ALL, IntAck_Reg);\n\tlanai->stats.card_reset++;\n}\n\n \n\n \nstatic int service_buffer_allocate(struct lanai_dev *lanai)\n{\n\tlanai_buf_allocate(&lanai->service, SERVICE_ENTRIES * 4, 8,\n\t    lanai->pci);\n\tif (unlikely(lanai->service.start == NULL))\n\t\treturn -ENOMEM;\n\tDPRINTK(\"allocated service buffer at %p, size %zu(%d)\\n\",\n\t    lanai->service.start,\n\t    lanai_buf_size(&lanai->service),\n\t    lanai_buf_size_cardorder(&lanai->service));\n\t \n\treg_write(lanai, 0, ServWrite_Reg);\n\t \n\treg_write(lanai,\n\t    SSTUFF_SET_SIZE(lanai_buf_size_cardorder(&lanai->service)) |\n\t    SSTUFF_SET_ADDR(lanai->service.dmaaddr),\n\t    ServiceStuff_Reg);\n\treturn 0;\n}\n\nstatic inline void service_buffer_deallocate(struct lanai_dev *lanai)\n{\n\tlanai_buf_deallocate(&lanai->service, lanai->pci);\n}\n\n \n#define SERVICE_TX\t(0x80000000)\t \n#define SERVICE_TRASH\t(0x40000000)\t \n#define SERVICE_CRCERR\t(0x20000000)\t \n#define SERVICE_CI\t(0x10000000)\t \n#define SERVICE_CLP\t(0x08000000)\t \n#define SERVICE_STREAM\t(0x04000000)\t \n#define SERVICE_GET_VCI(x) (((x)>>16)&0x3FF)\n#define SERVICE_GET_END(x) ((x)&0x1FFF)\n\n \nstatic int handle_service(struct lanai_dev *lanai, u32 s)\n{\n\tvci_t vci = SERVICE_GET_VCI(s);\n\tstruct lanai_vcc *lvcc;\n\tread_lock(&vcc_sklist_lock);\n\tlvcc = lanai->vccs[vci];\n\tif (unlikely(lvcc == NULL)) {\n\t\tread_unlock(&vcc_sklist_lock);\n\t\tDPRINTK(\"(itf %d) got service entry 0x%X for nonexistent \"\n\t\t    \"vcc %d\\n\", lanai->number, (unsigned int) s, vci);\n\t\tif (s & SERVICE_TX)\n\t\t\tlanai->stats.service_notx++;\n\t\telse\n\t\t\tlanai->stats.service_norx++;\n\t\treturn 0;\n\t}\n\tif (s & SERVICE_TX) {\t\t\t \n\t\tif (unlikely(lvcc->tx.atmvcc == NULL)) {\n\t\t\tread_unlock(&vcc_sklist_lock);\n\t\t\tDPRINTK(\"(itf %d) got service entry 0x%X for non-TX \"\n\t\t\t    \"vcc %d\\n\", lanai->number, (unsigned int) s, vci);\n\t\t\tlanai->stats.service_notx++;\n\t\t\treturn 0;\n\t\t}\n\t\t__set_bit(vci, lanai->transmit_ready);\n\t\tlvcc->tx.endptr = SERVICE_GET_END(s);\n\t\tread_unlock(&vcc_sklist_lock);\n\t\treturn 1;\n\t}\n\tif (unlikely(lvcc->rx.atmvcc == NULL)) {\n\t\tread_unlock(&vcc_sklist_lock);\n\t\tDPRINTK(\"(itf %d) got service entry 0x%X for non-RX \"\n\t\t    \"vcc %d\\n\", lanai->number, (unsigned int) s, vci);\n\t\tlanai->stats.service_norx++;\n\t\treturn 0;\n\t}\n\tif (unlikely(lvcc->rx.atmvcc->qos.aal != ATM_AAL5)) {\n\t\tread_unlock(&vcc_sklist_lock);\n\t\tDPRINTK(\"(itf %d) got RX service entry 0x%X for non-AAL5 \"\n\t\t    \"vcc %d\\n\", lanai->number, (unsigned int) s, vci);\n\t\tlanai->stats.service_rxnotaal5++;\n\t\tatomic_inc(&lvcc->rx.atmvcc->stats->rx_err);\n\t\treturn 0;\n\t}\n\tif (likely(!(s & (SERVICE_TRASH | SERVICE_STREAM | SERVICE_CRCERR)))) {\n\t\tvcc_rx_aal5(lvcc, SERVICE_GET_END(s));\n\t\tread_unlock(&vcc_sklist_lock);\n\t\treturn 0;\n\t}\n\tif (s & SERVICE_TRASH) {\n\t\tint bytes;\n\t\tread_unlock(&vcc_sklist_lock);\n\t\tDPRINTK(\"got trashed rx pdu on vci %d\\n\", vci);\n\t\tatomic_inc(&lvcc->rx.atmvcc->stats->rx_err);\n\t\tlvcc->stats.x.aal5.service_trash++;\n\t\tbytes = (SERVICE_GET_END(s) * 16) -\n\t\t    (((unsigned long) lvcc->rx.buf.ptr) -\n\t\t    ((unsigned long) lvcc->rx.buf.start)) + 47;\n\t\tif (bytes < 0)\n\t\t\tbytes += lanai_buf_size(&lvcc->rx.buf);\n\t\tlanai->stats.ovfl_trash += (bytes / 48);\n\t\treturn 0;\n\t}\n\tif (s & SERVICE_STREAM) {\n\t\tread_unlock(&vcc_sklist_lock);\n\t\tatomic_inc(&lvcc->rx.atmvcc->stats->rx_err);\n\t\tlvcc->stats.x.aal5.service_stream++;\n\t\tprintk(KERN_ERR DEV_LABEL \"(itf %d): Got AAL5 stream \"\n\t\t    \"PDU on VCI %d!\\n\", lanai->number, vci);\n\t\tlanai_reset(lanai);\n\t\treturn 0;\n\t}\n\tDPRINTK(\"got rx crc error on vci %d\\n\", vci);\n\tatomic_inc(&lvcc->rx.atmvcc->stats->rx_err);\n\tlvcc->stats.x.aal5.service_rxcrc++;\n\tlvcc->rx.buf.ptr = &lvcc->rx.buf.start[SERVICE_GET_END(s) * 4];\n\tcardvcc_write(lvcc, SERVICE_GET_END(s), vcc_rxreadptr);\n\tread_unlock(&vcc_sklist_lock);\n\treturn 0;\n}\n\n \nstatic void iter_transmit(struct lanai_dev *lanai, vci_t vci)\n{\n\tstruct lanai_vcc *lvcc = lanai->vccs[vci];\n\tif (vcc_is_backlogged(lvcc))\n\t\tlvcc->tx.unqueue(lanai, lvcc, lvcc->tx.endptr);\n}\n\n \nstatic void run_service(struct lanai_dev *lanai)\n{\n\tint ntx = 0;\n\tu32 wreg = reg_read(lanai, ServWrite_Reg);\n\tconst u32 *end = lanai->service.start + wreg;\n\twhile (lanai->service.ptr != end) {\n\t\tntx += handle_service(lanai,\n\t\t    le32_to_cpup(lanai->service.ptr++));\n\t\tif (lanai->service.ptr >= lanai->service.end)\n\t\t\tlanai->service.ptr = lanai->service.start;\n\t}\n\treg_write(lanai, wreg, ServRead_Reg);\n\tif (ntx != 0) {\n\t\tread_lock(&vcc_sklist_lock);\n\t\tvci_bitfield_iterate(lanai, lanai->transmit_ready,\n\t\t    iter_transmit);\n\t\tbitmap_zero(lanai->transmit_ready, NUM_VCI);\n\t\tread_unlock(&vcc_sklist_lock);\n\t}\n}\n\n \n\nstatic void get_statistics(struct lanai_dev *lanai)\n{\n\tu32 statreg = reg_read(lanai, Statistics_Reg);\n\tlanai->stats.atm_ovfl += STATS_GET_FIFO_OVFL(statreg);\n\tlanai->stats.hec_err += STATS_GET_HEC_ERR(statreg);\n\tlanai->stats.vci_trash += STATS_GET_BAD_VCI(statreg);\n\tlanai->stats.ovfl_trash += STATS_GET_BUF_OVFL(statreg);\n}\n\n \n\n#ifndef DEBUG_RW\n \nstatic void iter_dequeue(struct lanai_dev *lanai, vci_t vci)\n{\n\tstruct lanai_vcc *lvcc = lanai->vccs[vci];\n\tint endptr;\n\tif (lvcc == NULL || lvcc->tx.atmvcc == NULL ||\n\t    !vcc_is_backlogged(lvcc)) {\n\t\t__clear_bit(vci, lanai->backlog_vccs);\n\t\treturn;\n\t}\n\tendptr = TXREADPTR_GET_PTR(cardvcc_read(lvcc, vcc_txreadptr));\n\tlvcc->tx.unqueue(lanai, lvcc, endptr);\n}\n#endif  \n\nstatic void lanai_timed_poll(struct timer_list *t)\n{\n\tstruct lanai_dev *lanai = from_timer(lanai, t, timer);\n#ifndef DEBUG_RW\n\tunsigned long flags;\n#ifdef USE_POWERDOWN\n\tif (lanai->conf1 & CONFIG1_POWERDOWN)\n\t\treturn;\n#endif  \n\tlocal_irq_save(flags);\n\t \n\tif (spin_trylock(&lanai->servicelock)) {\n\t\trun_service(lanai);\n\t\tspin_unlock(&lanai->servicelock);\n\t}\n\t \n\t \n\tread_lock(&vcc_sklist_lock);\n\tvci_bitfield_iterate(lanai, lanai->backlog_vccs, iter_dequeue);\n\tread_unlock(&vcc_sklist_lock);\n\tlocal_irq_restore(flags);\n\n\tget_statistics(lanai);\n#endif  \n\tmod_timer(&lanai->timer, jiffies + LANAI_POLL_PERIOD);\n}\n\nstatic inline void lanai_timed_poll_start(struct lanai_dev *lanai)\n{\n\ttimer_setup(&lanai->timer, lanai_timed_poll, 0);\n\tlanai->timer.expires = jiffies + LANAI_POLL_PERIOD;\n\tadd_timer(&lanai->timer);\n}\n\nstatic inline void lanai_timed_poll_stop(struct lanai_dev *lanai)\n{\n\tdel_timer_sync(&lanai->timer);\n}\n\n \n\nstatic inline void lanai_int_1(struct lanai_dev *lanai, u32 reason)\n{\n\tu32 ack = 0;\n\tif (reason & INT_SERVICE) {\n\t\tack = INT_SERVICE;\n\t\tspin_lock(&lanai->servicelock);\n\t\trun_service(lanai);\n\t\tspin_unlock(&lanai->servicelock);\n\t}\n\tif (reason & (INT_AAL0_STR | INT_AAL0)) {\n\t\tack |= reason & (INT_AAL0_STR | INT_AAL0);\n\t\tvcc_rx_aal0(lanai);\n\t}\n\t \n\tif (ack == reason)\n\t\tgoto done;\n\tif (reason & INT_STATS) {\n\t\treason &= ~INT_STATS;\t \n\t\tget_statistics(lanai);\n\t}\n\tif (reason & INT_STATUS) {\n\t\tack |= reason & INT_STATUS;\n\t\tlanai_check_status(lanai);\n\t}\n\tif (unlikely(reason & INT_DMASHUT)) {\n\t\tprintk(KERN_ERR DEV_LABEL \"(itf %d): driver error - DMA \"\n\t\t    \"shutdown, reason=0x%08X, address=0x%08X\\n\",\n\t\t    lanai->number, (unsigned int) (reason & INT_DMASHUT),\n\t\t    (unsigned int) reg_read(lanai, DMA_Addr_Reg));\n\t\tif (reason & INT_TABORTBM) {\n\t\t\tlanai_reset(lanai);\n\t\t\treturn;\n\t\t}\n\t\tack |= (reason & INT_DMASHUT);\n\t\tprintk(KERN_ERR DEV_LABEL \"(itf %d): re-enabling DMA\\n\",\n\t\t    lanai->number);\n\t\tconf1_write(lanai);\n\t\tlanai->stats.dma_reenable++;\n\t\tpcistatus_check(lanai, 0);\n\t}\n\tif (unlikely(reason & INT_TABORTSENT)) {\n\t\tack |= (reason & INT_TABORTSENT);\n\t\tprintk(KERN_ERR DEV_LABEL \"(itf %d): sent PCI target abort\\n\",\n\t\t    lanai->number);\n\t\tpcistatus_check(lanai, 0);\n\t}\n\tif (unlikely(reason & INT_SEGSHUT)) {\n\t\tprintk(KERN_ERR DEV_LABEL \"(itf %d): driver error - \"\n\t\t    \"segmentation shutdown, reason=0x%08X\\n\", lanai->number,\n\t\t    (unsigned int) (reason & INT_SEGSHUT));\n\t\tlanai_reset(lanai);\n\t\treturn;\n\t}\n\tif (unlikely(reason & (INT_PING | INT_WAKE))) {\n\t\tprintk(KERN_ERR DEV_LABEL \"(itf %d): driver error - \"\n\t\t    \"unexpected interrupt 0x%08X, resetting\\n\",\n\t\t    lanai->number,\n\t\t    (unsigned int) (reason & (INT_PING | INT_WAKE)));\n\t\tlanai_reset(lanai);\n\t\treturn;\n\t}\n#ifdef DEBUG\n\tif (unlikely(ack != reason)) {\n\t\tDPRINTK(\"unacked ints: 0x%08X\\n\",\n\t\t    (unsigned int) (reason & ~ack));\n\t\tack = reason;\n\t}\n#endif\n   done:\n\tif (ack != 0)\n\t\treg_write(lanai, ack, IntAck_Reg);\n}\n\nstatic irqreturn_t lanai_int(int irq, void *devid)\n{\n\tstruct lanai_dev *lanai = devid;\n\tu32 reason;\n\n#ifdef USE_POWERDOWN\n\t \n\tif (unlikely(lanai->conf1 & CONFIG1_POWERDOWN))\n\t\treturn IRQ_NONE;\n#endif\n\n\treason = intr_pending(lanai);\n\tif (reason == 0)\n\t\treturn IRQ_NONE;\t \n\n\tdo {\n\t\tif (unlikely(reason == 0xFFFFFFFF))\n\t\t\tbreak;\t\t \n\t\tlanai_int_1(lanai, reason);\n\t\treason = intr_pending(lanai);\n\t} while (reason != 0);\n\n\treturn IRQ_HANDLED;\n}\n\n \n\n \n\n \nstatic int check_board_id_and_rev(const char *name, u32 val, int *revp)\n{\n\tDPRINTK(\"%s says board_id=%d, board_rev=%d\\n\", name,\n\t\t(int) RESET_GET_BOARD_ID(val),\n\t\t(int) RESET_GET_BOARD_REV(val));\n\tif (RESET_GET_BOARD_ID(val) != BOARD_ID_LANAI256) {\n\t\tprintk(KERN_ERR DEV_LABEL \": Found %s board-id %d -- not a \"\n\t\t    \"Lanai 25.6\\n\", name, (int) RESET_GET_BOARD_ID(val));\n\t\treturn -ENODEV;\n\t}\n\tif (revp != NULL)\n\t\t*revp = RESET_GET_BOARD_REV(val);\n\treturn 0;\n}\n\n \n\nstatic int lanai_pci_start(struct lanai_dev *lanai)\n{\n\tstruct pci_dev *pci = lanai->pci;\n\tint result;\n\n\tif (pci_enable_device(pci) != 0) {\n\t\tprintk(KERN_ERR DEV_LABEL \"(itf %d): can't enable \"\n\t\t    \"PCI device\", lanai->number);\n\t\treturn -ENXIO;\n\t}\n\tpci_set_master(pci);\n\tif (dma_set_mask_and_coherent(&pci->dev, DMA_BIT_MASK(32)) != 0) {\n\t\tprintk(KERN_WARNING DEV_LABEL\n\t\t    \"(itf %d): No suitable DMA available.\\n\", lanai->number);\n\t\treturn -EBUSY;\n\t}\n\tresult = check_board_id_and_rev(\"PCI\", pci->subsystem_device, NULL);\n\tif (result != 0)\n\t\treturn result;\n\t \n\tresult = pci_write_config_byte(pci, PCI_LATENCY_TIMER, 0);\n\tif (result != PCIBIOS_SUCCESSFUL) {\n\t\tprintk(KERN_ERR DEV_LABEL \"(itf %d): can't write \"\n\t\t    \"PCI_LATENCY_TIMER: %d\\n\", lanai->number, result);\n\t\treturn -EINVAL;\n\t}\n\tpcistatus_check(lanai, 1);\n\tpcistatus_check(lanai, 0);\n\treturn 0;\n}\n\n \n\n \nstatic inline int vci0_is_ok(struct lanai_dev *lanai,\n\tconst struct atm_qos *qos)\n{\n\tif (qos->txtp.traffic_class == ATM_CBR || qos->aal == ATM_AAL0)\n\t\treturn 0;\n\tif (qos->rxtp.traffic_class != ATM_NONE) {\n\t\tif (lanai->naal0 != 0)\n\t\t\treturn 0;\n\t\tlanai->conf2 |= CONFIG2_VCI0_NORMAL;\n\t\tconf2_write_if_powerup(lanai);\n\t}\n\treturn 1;\n}\n\n \nstatic int vci_is_ok(struct lanai_dev *lanai, vci_t vci,\n\tconst struct atm_vcc *atmvcc)\n{\n\tconst struct atm_qos *qos = &atmvcc->qos;\n\tconst struct lanai_vcc *lvcc = lanai->vccs[vci];\n\tif (vci == 0 && !vci0_is_ok(lanai, qos))\n\t\treturn 0;\n\tif (unlikely(lvcc != NULL)) {\n\t\tif (qos->rxtp.traffic_class != ATM_NONE &&\n\t\t    lvcc->rx.atmvcc != NULL && lvcc->rx.atmvcc != atmvcc)\n\t\t\treturn 0;\n\t\tif (qos->txtp.traffic_class != ATM_NONE &&\n\t\t    lvcc->tx.atmvcc != NULL && lvcc->tx.atmvcc != atmvcc)\n\t\t\treturn 0;\n\t\tif (qos->txtp.traffic_class == ATM_CBR &&\n\t\t    lanai->cbrvcc != NULL && lanai->cbrvcc != atmvcc)\n\t\t\treturn 0;\n\t}\n\tif (qos->aal == ATM_AAL0 && lanai->naal0 == 0 &&\n\t    qos->rxtp.traffic_class != ATM_NONE) {\n\t\tconst struct lanai_vcc *vci0 = lanai->vccs[0];\n\t\tif (vci0 != NULL && vci0->rx.atmvcc != NULL)\n\t\t\treturn 0;\n\t\tlanai->conf2 &= ~CONFIG2_VCI0_NORMAL;\n\t\tconf2_write_if_powerup(lanai);\n\t}\n\treturn 1;\n}\n\nstatic int lanai_normalize_ci(struct lanai_dev *lanai,\n\tconst struct atm_vcc *atmvcc, short *vpip, vci_t *vcip)\n{\n\tswitch (*vpip) {\n\t\tcase ATM_VPI_ANY:\n\t\t\t*vpip = 0;\n\t\t\tfallthrough;\n\t\tcase 0:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EADDRINUSE;\n\t}\n\tswitch (*vcip) {\n\t\tcase ATM_VCI_ANY:\n\t\t\tfor (*vcip = ATM_NOT_RSV_VCI; *vcip < lanai->num_vci;\n\t\t\t    (*vcip)++)\n\t\t\t\tif (vci_is_ok(lanai, *vcip, atmvcc))\n\t\t\t\t\treturn 0;\n\t\t\treturn -EADDRINUSE;\n\t\tdefault:\n\t\t\tif (*vcip >= lanai->num_vci || *vcip < 0 ||\n\t\t\t    !vci_is_ok(lanai, *vcip, atmvcc))\n\t\t\t\treturn -EADDRINUSE;\n\t}\n\treturn 0;\n}\n\n \n\n \n#define CBRICG_FRAC_BITS\t(4)\n#define CBRICG_MAX\t\t(2046 << CBRICG_FRAC_BITS)\n\n \nstatic int pcr_to_cbricg(const struct atm_qos *qos)\n{\n\tint rounddown = 0;\t \n\tint x, icg, pcr = atm_pcr_goal(&qos->txtp);\n\tif (pcr == 0)\t\t \n\t\treturn 0;\n\tif (pcr < 0) {\n\t\trounddown = 1;\n\t\tpcr = -pcr;\n\t}\n\tx = pcr * 27;\n\ticg = (3125 << (9 + CBRICG_FRAC_BITS)) - (x << CBRICG_FRAC_BITS);\n\tif (rounddown)\n\t\ticg += x - 1;\n\ticg /= x;\n\tif (icg > CBRICG_MAX)\n\t\ticg = CBRICG_MAX;\n\tDPRINTK(\"pcr_to_cbricg: pcr=%d rounddown=%c icg=%d\\n\",\n\t    pcr, rounddown ? 'Y' : 'N', icg);\n\treturn icg;\n}\n\nstatic inline void lanai_cbr_setup(struct lanai_dev *lanai)\n{\n\treg_write(lanai, pcr_to_cbricg(&lanai->cbrvcc->qos), CBR_ICG_Reg);\n\treg_write(lanai, lanai->cbrvcc->vci, CBR_PTR_Reg);\n\tlanai->conf2 |= CONFIG2_CBR_ENABLE;\n\tconf2_write(lanai);\n}\n\nstatic inline void lanai_cbr_shutdown(struct lanai_dev *lanai)\n{\n\tlanai->conf2 &= ~CONFIG2_CBR_ENABLE;\n\tconf2_write(lanai);\n}\n\n \n\n \nstatic int lanai_dev_open(struct atm_dev *atmdev)\n{\n\tstruct lanai_dev *lanai = (struct lanai_dev *) atmdev->dev_data;\n\tunsigned long raw_base;\n\tint result;\n\n\tDPRINTK(\"In lanai_dev_open()\\n\");\n\t \n\tlanai->number = atmdev->number;\n\tlanai->num_vci = NUM_VCI;\n\tbitmap_zero(lanai->backlog_vccs, NUM_VCI);\n\tbitmap_zero(lanai->transmit_ready, NUM_VCI);\n\tlanai->naal0 = 0;\n#ifdef USE_POWERDOWN\n\tlanai->nbound = 0;\n#endif\n\tlanai->cbrvcc = NULL;\n\tmemset(&lanai->stats, 0, sizeof lanai->stats);\n\tspin_lock_init(&lanai->endtxlock);\n\tspin_lock_init(&lanai->servicelock);\n\tatmdev->ci_range.vpi_bits = 0;\n\tatmdev->ci_range.vci_bits = 0;\n\twhile (1 << atmdev->ci_range.vci_bits < lanai->num_vci)\n\t\tatmdev->ci_range.vci_bits++;\n\tatmdev->link_rate = ATM_25_PCR;\n\n\t \n\tif ((result = lanai_pci_start(lanai)) != 0)\n\t\tgoto error;\n\traw_base = lanai->pci->resource[0].start;\n\tlanai->base = (bus_addr_t) ioremap(raw_base, LANAI_MAPPING_SIZE);\n\tif (lanai->base == NULL) {\n\t\tprintk(KERN_ERR DEV_LABEL \": couldn't remap I/O space\\n\");\n\t\tresult = -ENOMEM;\n\t\tgoto error_pci;\n\t}\n\t \n\treset_board(lanai);\n\tlanai->conf1 = reg_read(lanai, Config1_Reg);\n\tlanai->conf1 &= ~(CONFIG1_GPOUT1 | CONFIG1_POWERDOWN |\n\t    CONFIG1_MASK_LEDMODE);\n\tlanai->conf1 |= CONFIG1_SET_LEDMODE(LEDMODE_NOT_SOOL);\n\treg_write(lanai, lanai->conf1 | CONFIG1_GPOUT1, Config1_Reg);\n\tudelay(1000);\n\tconf1_write(lanai);\n\n\t \n\tresult = check_board_id_and_rev(\"register\",\n\t    reg_read(lanai, Reset_Reg), &lanai->board_rev);\n\tif (result != 0)\n\t\tgoto error_unmap;\n\n\t \n\tif ((result = eeprom_read(lanai)) != 0)\n\t\tgoto error_unmap;\n\tif ((result = eeprom_validate(lanai)) != 0)\n\t\tgoto error_unmap;\n\n\t \n\treg_write(lanai, lanai->conf1 | CONFIG1_GPOUT1, Config1_Reg);\n\tudelay(1000);\n\tconf1_write(lanai);\n\t \n\tlanai->conf1 |= (CONFIG1_GPOUT2 | CONFIG1_GPOUT3 | CONFIG1_DMA_ENABLE);\n\tconf1_write(lanai);\n\n\t \n\tif ((result = sram_test_and_clear(lanai)) != 0)\n\t\tgoto error_unmap;\n\n\t \n\tlanai->conf1 |= CONFIG1_DMA_ENABLE;\n\tconf1_write(lanai);\n\tif ((result = service_buffer_allocate(lanai)) != 0)\n\t\tgoto error_unmap;\n\tif ((result = vcc_table_allocate(lanai)) != 0)\n\t\tgoto error_service;\n\tlanai->conf2 = (lanai->num_vci >= 512 ? CONFIG2_HOWMANY : 0) |\n\t    CONFIG2_HEC_DROP |\t  CONFIG2_PTI7_MODE;\n\tconf2_write(lanai);\n\treg_write(lanai, TX_FIFO_DEPTH, TxDepth_Reg);\n\treg_write(lanai, 0, CBR_ICG_Reg);\t \n\tif ((result = request_irq(lanai->pci->irq, lanai_int, IRQF_SHARED,\n\t    DEV_LABEL, lanai)) != 0) {\n\t\tprintk(KERN_ERR DEV_LABEL \": can't allocate interrupt\\n\");\n\t\tgoto error_vcctable;\n\t}\n\tmb();\t\t\t\t \n\tintr_enable(lanai, INT_ALL & ~(INT_PING | INT_WAKE));\n\t \n\tlanai->conf1 = (lanai->conf1 & ~CONFIG1_MASK_LOOPMODE) |\n\t    CONFIG1_SET_LOOPMODE(LOOPMODE_NORMAL) |\n\t    CONFIG1_GPOUT2 | CONFIG1_GPOUT3;\n\tconf1_write(lanai);\n\tlanai->status = reg_read(lanai, Status_Reg);\n\t \n#ifdef USE_POWERDOWN\n\tlanai->conf1 |= CONFIG1_POWERDOWN;\n\tconf1_write(lanai);\n#endif\n\tmemcpy(atmdev->esi, eeprom_mac(lanai), ESI_LEN);\n\tlanai_timed_poll_start(lanai);\n\tprintk(KERN_NOTICE DEV_LABEL \"(itf %d): rev.%d, base=%p, irq=%u \"\n\t\t\"(%pMF)\\n\", lanai->number, (int) lanai->pci->revision,\n\t\tlanai->base, lanai->pci->irq, atmdev->esi);\n\tprintk(KERN_NOTICE DEV_LABEL \"(itf %d): LANAI%s, serialno=%u(0x%X), \"\n\t    \"board_rev=%d\\n\", lanai->number,\n\t    lanai->type==lanai2 ? \"2\" : \"HB\", (unsigned int) lanai->serialno,\n\t    (unsigned int) lanai->serialno, lanai->board_rev);\n\treturn 0;\n\n    error_vcctable:\n\tvcc_table_deallocate(lanai);\n    error_service:\n\tservice_buffer_deallocate(lanai);\n    error_unmap:\n\treset_board(lanai);\n#ifdef USE_POWERDOWN\n\tlanai->conf1 = reg_read(lanai, Config1_Reg) | CONFIG1_POWERDOWN;\n\tconf1_write(lanai);\n#endif\n\tiounmap(lanai->base);\n\tlanai->base = NULL;\n    error_pci:\n\tpci_disable_device(lanai->pci);\n    error:\n\treturn result;\n}\n\n \nstatic void lanai_dev_close(struct atm_dev *atmdev)\n{\n\tstruct lanai_dev *lanai = (struct lanai_dev *) atmdev->dev_data;\n\tif (lanai->base==NULL)\n\t\treturn;\n\tprintk(KERN_INFO DEV_LABEL \"(itf %d): shutting down interface\\n\",\n\t    lanai->number);\n\tlanai_timed_poll_stop(lanai);\n#ifdef USE_POWERDOWN\n\tlanai->conf1 = reg_read(lanai, Config1_Reg) & ~CONFIG1_POWERDOWN;\n\tconf1_write(lanai);\n#endif\n\tintr_disable(lanai, INT_ALL);\n\tfree_irq(lanai->pci->irq, lanai);\n\treset_board(lanai);\n#ifdef USE_POWERDOWN\n\tlanai->conf1 |= CONFIG1_POWERDOWN;\n\tconf1_write(lanai);\n#endif\n\tpci_disable_device(lanai->pci);\n\tvcc_table_deallocate(lanai);\n\tservice_buffer_deallocate(lanai);\n\tiounmap(lanai->base);\n\tkfree(lanai);\n}\n\n \nstatic void lanai_close(struct atm_vcc *atmvcc)\n{\n\tstruct lanai_vcc *lvcc = (struct lanai_vcc *) atmvcc->dev_data;\n\tstruct lanai_dev *lanai = (struct lanai_dev *) atmvcc->dev->dev_data;\n\tif (lvcc == NULL)\n\t\treturn;\n\tclear_bit(ATM_VF_READY, &atmvcc->flags);\n\tclear_bit(ATM_VF_PARTIAL, &atmvcc->flags);\n\tif (lvcc->rx.atmvcc == atmvcc) {\n\t\tlanai_shutdown_rx_vci(lvcc);\n\t\tif (atmvcc->qos.aal == ATM_AAL0) {\n\t\t\tif (--lanai->naal0 <= 0)\n\t\t\t\taal0_buffer_free(lanai);\n\t\t} else\n\t\t\tlanai_buf_deallocate(&lvcc->rx.buf, lanai->pci);\n\t\tlvcc->rx.atmvcc = NULL;\n\t}\n\tif (lvcc->tx.atmvcc == atmvcc) {\n\t\tif (atmvcc == lanai->cbrvcc) {\n\t\t\tif (lvcc->vbase != NULL)\n\t\t\t\tlanai_cbr_shutdown(lanai);\n\t\t\tlanai->cbrvcc = NULL;\n\t\t}\n\t\tlanai_shutdown_tx_vci(lanai, lvcc);\n\t\tlanai_buf_deallocate(&lvcc->tx.buf, lanai->pci);\n\t\tlvcc->tx.atmvcc = NULL;\n\t}\n\tif (--lvcc->nref == 0) {\n\t\thost_vcc_unbind(lanai, lvcc);\n\t\tkfree(lvcc);\n\t}\n\tatmvcc->dev_data = NULL;\n\tclear_bit(ATM_VF_ADDR, &atmvcc->flags);\n}\n\n \nstatic int lanai_open(struct atm_vcc *atmvcc)\n{\n\tstruct lanai_dev *lanai;\n\tstruct lanai_vcc *lvcc;\n\tint result = 0;\n\tint vci = atmvcc->vci;\n\tshort vpi = atmvcc->vpi;\n\t \n\tif ((test_bit(ATM_VF_PARTIAL, &atmvcc->flags)) ||\n\t    (vpi == ATM_VPI_UNSPEC) || (vci == ATM_VCI_UNSPEC))\n\t\treturn -EINVAL;\n\tlanai = (struct lanai_dev *) atmvcc->dev->dev_data;\n\tresult = lanai_normalize_ci(lanai, atmvcc, &vpi, &vci);\n\tif (unlikely(result != 0))\n\t\tgoto out;\n\tset_bit(ATM_VF_ADDR, &atmvcc->flags);\n\tif (atmvcc->qos.aal != ATM_AAL0 && atmvcc->qos.aal != ATM_AAL5)\n\t\treturn -EINVAL;\n\tDPRINTK(DEV_LABEL \"(itf %d): open %d.%d\\n\", lanai->number,\n\t    (int) vpi, vci);\n\tlvcc = lanai->vccs[vci];\n\tif (lvcc == NULL) {\n\t\tlvcc = new_lanai_vcc();\n\t\tif (unlikely(lvcc == NULL))\n\t\t\treturn -ENOMEM;\n\t\tatmvcc->dev_data = lvcc;\n\t}\n\tlvcc->nref++;\n\tif (atmvcc->qos.rxtp.traffic_class != ATM_NONE) {\n\t\tAPRINTK(lvcc->rx.atmvcc == NULL, \"rx.atmvcc!=NULL, vci=%d\\n\",\n\t\t    vci);\n\t\tif (atmvcc->qos.aal == ATM_AAL0) {\n\t\t\tif (lanai->naal0 == 0)\n\t\t\t\tresult = aal0_buffer_allocate(lanai);\n\t\t} else\n\t\t\tresult = lanai_setup_rx_vci_aal5(\n\t\t\t    lanai, lvcc, &atmvcc->qos);\n\t\tif (unlikely(result != 0))\n\t\t\tgoto out_free;\n\t\tlvcc->rx.atmvcc = atmvcc;\n\t\tlvcc->stats.rx_nomem = 0;\n\t\tlvcc->stats.x.aal5.rx_badlen = 0;\n\t\tlvcc->stats.x.aal5.service_trash = 0;\n\t\tlvcc->stats.x.aal5.service_stream = 0;\n\t\tlvcc->stats.x.aal5.service_rxcrc = 0;\n\t\tif (atmvcc->qos.aal == ATM_AAL0)\n\t\t\tlanai->naal0++;\n\t}\n\tif (atmvcc->qos.txtp.traffic_class != ATM_NONE) {\n\t\tAPRINTK(lvcc->tx.atmvcc == NULL, \"tx.atmvcc!=NULL, vci=%d\\n\",\n\t\t    vci);\n\t\tresult = lanai_setup_tx_vci(lanai, lvcc, &atmvcc->qos);\n\t\tif (unlikely(result != 0))\n\t\t\tgoto out_free;\n\t\tlvcc->tx.atmvcc = atmvcc;\n\t\tif (atmvcc->qos.txtp.traffic_class == ATM_CBR) {\n\t\t\tAPRINTK(lanai->cbrvcc == NULL,\n\t\t\t    \"cbrvcc!=NULL, vci=%d\\n\", vci);\n\t\t\tlanai->cbrvcc = atmvcc;\n\t\t}\n\t}\n\thost_vcc_bind(lanai, lvcc, vci);\n\t \n\twmb();\n\tif (atmvcc == lvcc->rx.atmvcc)\n\t\thost_vcc_start_rx(lvcc);\n\tif (atmvcc == lvcc->tx.atmvcc) {\n\t\thost_vcc_start_tx(lvcc);\n\t\tif (lanai->cbrvcc == atmvcc)\n\t\t\tlanai_cbr_setup(lanai);\n\t}\n\tset_bit(ATM_VF_READY, &atmvcc->flags);\n\treturn 0;\n    out_free:\n\tlanai_close(atmvcc);\n    out:\n\treturn result;\n}\n\nstatic int lanai_send(struct atm_vcc *atmvcc, struct sk_buff *skb)\n{\n\tstruct lanai_vcc *lvcc = (struct lanai_vcc *) atmvcc->dev_data;\n\tstruct lanai_dev *lanai = (struct lanai_dev *) atmvcc->dev->dev_data;\n\tunsigned long flags;\n\tif (unlikely(lvcc == NULL || lvcc->vbase == NULL ||\n\t      lvcc->tx.atmvcc != atmvcc))\n\t\tgoto einval;\n#ifdef DEBUG\n\tif (unlikely(skb == NULL)) {\n\t\tDPRINTK(\"lanai_send: skb==NULL for vci=%d\\n\", atmvcc->vci);\n\t\tgoto einval;\n\t}\n\tif (unlikely(lanai == NULL)) {\n\t\tDPRINTK(\"lanai_send: lanai==NULL for vci=%d\\n\", atmvcc->vci);\n\t\tgoto einval;\n\t}\n#endif\n\tATM_SKB(skb)->vcc = atmvcc;\n\tswitch (atmvcc->qos.aal) {\n\t\tcase ATM_AAL5:\n\t\t\tread_lock_irqsave(&vcc_sklist_lock, flags);\n\t\t\tvcc_tx_aal5(lanai, lvcc, skb);\n\t\t\tread_unlock_irqrestore(&vcc_sklist_lock, flags);\n\t\t\treturn 0;\n\t\tcase ATM_AAL0:\n\t\t\tif (unlikely(skb->len != ATM_CELL_SIZE-1))\n\t\t\t\tgoto einval;\n   \n\t\t\tcpu_to_be32s((u32 *) skb->data);\n\t\t\tread_lock_irqsave(&vcc_sklist_lock, flags);\n\t\t\tvcc_tx_aal0(lanai, lvcc, skb);\n\t\t\tread_unlock_irqrestore(&vcc_sklist_lock, flags);\n\t\t\treturn 0;\n\t}\n\tDPRINTK(\"lanai_send: bad aal=%d on vci=%d\\n\", (int) atmvcc->qos.aal,\n\t    atmvcc->vci);\n    einval:\n\tlanai_free_skb(atmvcc, skb);\n\treturn -EINVAL;\n}\n\nstatic int lanai_change_qos(struct atm_vcc *atmvcc,\n\t  struct atm_qos *qos, int flags)\n{\n\treturn -EBUSY;\t\t \n}\n\n#ifndef CONFIG_PROC_FS\n#define lanai_proc_read NULL\n#else\nstatic int lanai_proc_read(struct atm_dev *atmdev, loff_t *pos, char *page)\n{\n\tstruct lanai_dev *lanai = (struct lanai_dev *) atmdev->dev_data;\n\tloff_t left = *pos;\n\tstruct lanai_vcc *lvcc;\n\tif (left-- == 0)\n\t\treturn sprintf(page, DEV_LABEL \"(itf %d): chip=LANAI%s, \"\n\t\t    \"serial=%u, magic=0x%08X, num_vci=%d\\n\",\n\t\t    atmdev->number, lanai->type==lanai2 ? \"2\" : \"HB\",\n\t\t    (unsigned int) lanai->serialno,\n\t\t    (unsigned int) lanai->magicno, lanai->num_vci);\n\tif (left-- == 0)\n\t\treturn sprintf(page, \"revision: board=%d, pci_if=%d\\n\",\n\t\t    lanai->board_rev, (int) lanai->pci->revision);\n\tif (left-- == 0)\n\t\treturn sprintf(page, \"EEPROM ESI: %pM\\n\",\n\t\t    &lanai->eeprom[EEPROM_MAC]);\n\tif (left-- == 0)\n\t\treturn sprintf(page, \"status: SOOL=%d, LOCD=%d, LED=%d, \"\n\t\t    \"GPIN=%d\\n\", (lanai->status & STATUS_SOOL) ? 1 : 0,\n\t\t    (lanai->status & STATUS_LOCD) ? 1 : 0,\n\t\t    (lanai->status & STATUS_LED) ? 1 : 0,\n\t\t    (lanai->status & STATUS_GPIN) ? 1 : 0);\n\tif (left-- == 0)\n\t\treturn sprintf(page, \"global buffer sizes: service=%zu, \"\n\t\t    \"aal0_rx=%zu\\n\", lanai_buf_size(&lanai->service),\n\t\t    lanai->naal0 ? lanai_buf_size(&lanai->aal0buf) : 0);\n\tif (left-- == 0) {\n\t\tget_statistics(lanai);\n\t\treturn sprintf(page, \"cells in error: overflow=%u, \"\n\t\t    \"closed_vci=%u, bad_HEC=%u, rx_fifo=%u\\n\",\n\t\t    lanai->stats.ovfl_trash, lanai->stats.vci_trash,\n\t\t    lanai->stats.hec_err, lanai->stats.atm_ovfl);\n\t}\n\tif (left-- == 0)\n\t\treturn sprintf(page, \"PCI errors: parity_detect=%u, \"\n\t\t    \"master_abort=%u, master_target_abort=%u,\\n\",\n\t\t    lanai->stats.pcierr_parity_detect,\n\t\t    lanai->stats.pcierr_serr_set,\n\t\t    lanai->stats.pcierr_m_target_abort);\n\tif (left-- == 0)\n\t\treturn sprintf(page, \"            slave_target_abort=%u, \"\n\t\t    \"master_parity=%u\\n\", lanai->stats.pcierr_s_target_abort,\n\t\t    lanai->stats.pcierr_master_parity);\n\tif (left-- == 0)\n\t\treturn sprintf(page, \"                     no_tx=%u, \"\n\t\t    \"no_rx=%u, bad_rx_aal=%u\\n\", lanai->stats.service_norx,\n\t\t    lanai->stats.service_notx,\n\t\t    lanai->stats.service_rxnotaal5);\n\tif (left-- == 0)\n\t\treturn sprintf(page, \"resets: dma=%u, card=%u\\n\",\n\t\t    lanai->stats.dma_reenable, lanai->stats.card_reset);\n\t \n\tread_lock(&vcc_sklist_lock);\n\tfor (; ; left++) {\n\t\tif (left >= NUM_VCI) {\n\t\t\tleft = 0;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((lvcc = lanai->vccs[left]) != NULL)\n\t\t\tbreak;\n\t\t(*pos)++;\n\t}\n\t \n\tleft = sprintf(page, \"VCI %4d: nref=%d, rx_nomem=%u\",  (vci_t) left,\n\t    lvcc->nref, lvcc->stats.rx_nomem);\n\tif (lvcc->rx.atmvcc != NULL) {\n\t\tleft += sprintf(&page[left], \",\\n          rx_AAL=%d\",\n\t\t    lvcc->rx.atmvcc->qos.aal == ATM_AAL5 ? 5 : 0);\n\t\tif (lvcc->rx.atmvcc->qos.aal == ATM_AAL5)\n\t\t\tleft += sprintf(&page[left], \", rx_buf_size=%zu, \"\n\t\t\t    \"rx_bad_len=%u,\\n          rx_service_trash=%u, \"\n\t\t\t    \"rx_service_stream=%u, rx_bad_crc=%u\",\n\t\t\t    lanai_buf_size(&lvcc->rx.buf),\n\t\t\t    lvcc->stats.x.aal5.rx_badlen,\n\t\t\t    lvcc->stats.x.aal5.service_trash,\n\t\t\t    lvcc->stats.x.aal5.service_stream,\n\t\t\t    lvcc->stats.x.aal5.service_rxcrc);\n\t}\n\tif (lvcc->tx.atmvcc != NULL)\n\t\tleft += sprintf(&page[left], \",\\n          tx_AAL=%d, \"\n\t\t    \"tx_buf_size=%zu, tx_qos=%cBR, tx_backlogged=%c\",\n\t\t    lvcc->tx.atmvcc->qos.aal == ATM_AAL5 ? 5 : 0,\n\t\t    lanai_buf_size(&lvcc->tx.buf),\n\t\t    lvcc->tx.atmvcc == lanai->cbrvcc ? 'C' : 'U',\n\t\t    vcc_is_backlogged(lvcc) ? 'Y' : 'N');\n\tpage[left++] = '\\n';\n\tpage[left] = '\\0';\n    out:\n\tread_unlock(&vcc_sklist_lock);\n\treturn left;\n}\n#endif  \n\n \n\nstatic const struct atmdev_ops ops = {\n\t.dev_close\t= lanai_dev_close,\n\t.open\t\t= lanai_open,\n\t.close\t\t= lanai_close,\n\t.send\t\t= lanai_send,\n\t.phy_put\t= NULL,\n\t.phy_get\t= NULL,\n\t.change_qos\t= lanai_change_qos,\n\t.proc_read\t= lanai_proc_read,\n\t.owner\t\t= THIS_MODULE\n};\n\n \nstatic int lanai_init_one(struct pci_dev *pci,\n\t\t\t  const struct pci_device_id *ident)\n{\n\tstruct lanai_dev *lanai;\n\tstruct atm_dev *atmdev;\n\tint result;\n\n\tlanai = kzalloc(sizeof(*lanai), GFP_KERNEL);\n\tif (lanai == NULL) {\n\t\tprintk(KERN_ERR DEV_LABEL\n\t\t       \": couldn't allocate dev_data structure!\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tatmdev = atm_dev_register(DEV_LABEL, &pci->dev, &ops, -1, NULL);\n\tif (atmdev == NULL) {\n\t\tprintk(KERN_ERR DEV_LABEL\n\t\t    \": couldn't register atm device!\\n\");\n\t\tkfree(lanai);\n\t\treturn -EBUSY;\n\t}\n\n\tatmdev->dev_data = lanai;\n\tlanai->pci = pci;\n\tlanai->type = (enum lanai_type) ident->device;\n\n\tresult = lanai_dev_open(atmdev);\n\tif (result != 0) {\n\t\tDPRINTK(\"lanai_start() failed, err=%d\\n\", -result);\n\t\tatm_dev_deregister(atmdev);\n\t\tkfree(lanai);\n\t}\n\treturn result;\n}\n\nstatic const struct pci_device_id lanai_pci_tbl[] = {\n\t{ PCI_VDEVICE(EF, PCI_DEVICE_ID_EF_ATM_LANAI2) },\n\t{ PCI_VDEVICE(EF, PCI_DEVICE_ID_EF_ATM_LANAIHB) },\n\t{ 0, }\t \n};\nMODULE_DEVICE_TABLE(pci, lanai_pci_tbl);\n\nstatic struct pci_driver lanai_driver = {\n\t.name     = DEV_LABEL,\n\t.id_table = lanai_pci_tbl,\n\t.probe    = lanai_init_one,\n};\n\nmodule_pci_driver(lanai_driver);\n\nMODULE_AUTHOR(\"Mitchell Blank Jr <mitch@sfgoth.com>\");\nMODULE_DESCRIPTION(\"Efficient Networks Speedstream 3010 driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}