{
  "module_name": "nubus.c",
  "hash_id": "32d86f2f35e56721ffce24f8d02db13c1e380aaea36df44c93dc284d8176f49b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/nubus/nubus.c",
  "human_readable_source": "\n \n\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/nubus.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <asm/setup.h>\n#include <asm/page.h>\n#include <asm/hwtest.h>\n\n \n\n \n#define FORMAT_BLOCK_SIZE 20\n#define ROM_DIR_OFFSET 0x24\n\n#define NUBUS_TEST_PATTERN 0x5A932BC7\n\n \n\n \nbool nubus_populate_procfs;\nmodule_param_named(populate_procfs, nubus_populate_procfs, bool, 0);\n\nLIST_HEAD(nubus_func_rsrcs);\n\n \n\nstatic inline int not_useful(void *p, int map)\n{\n\tunsigned long pv = (unsigned long)p;\n\n\tpv &= 3;\n\tif (map & (1 << pv))\n\t\treturn 0;\n\treturn 1;\n}\n\nstatic unsigned long nubus_get_rom(unsigned char **ptr, int len, int map)\n{\n\t \n\tunsigned long v = 0;\n\tunsigned char *p = *ptr;\n\n\twhile (len) {\n\t\tv <<= 8;\n\t\twhile (not_useful(p, map))\n\t\t\tp++;\n\t\tv |= *p++;\n\t\tlen--;\n\t}\n\t*ptr = p;\n\treturn v;\n}\n\nstatic void nubus_rewind(unsigned char **ptr, int len, int map)\n{\n\tunsigned char *p = *ptr;\n\n\twhile (len) {\n\t\tdo {\n\t\t\tp--;\n\t\t} while (not_useful(p, map));\n\t\tlen--;\n\t}\n\t*ptr = p;\n}\n\nstatic void nubus_advance(unsigned char **ptr, int len, int map)\n{\n\tunsigned char *p = *ptr;\n\n\twhile (len) {\n\t\twhile (not_useful(p, map))\n\t\t\tp++;\n\t\tp++;\n\t\tlen--;\n\t}\n\t*ptr = p;\n}\n\nstatic void nubus_move(unsigned char **ptr, int len, int map)\n{\n\tunsigned long slot_space = (unsigned long)*ptr & 0xFF000000;\n\n\tif (len > 0)\n\t\tnubus_advance(ptr, len, map);\n\telse if (len < 0)\n\t\tnubus_rewind(ptr, -len, map);\n\n\tif (((unsigned long)*ptr & 0xFF000000) != slot_space)\n\t\tpr_err(\"%s: moved out of slot address space!\\n\", __func__);\n}\n\n \n\n \n\nstatic inline long nubus_expand32(long foo)\n{\n\tif (foo & 0x00800000)\t \n\t\tfoo |= 0xFF000000;\n\treturn foo;\n}\n\nstatic inline void *nubus_rom_addr(int slot)\n{\n\t \n\treturn (void *)(0xF1000000 + (slot << 24));\n}\n\nunsigned char *nubus_dirptr(const struct nubus_dirent *nd)\n{\n\tunsigned char *p = nd->base;\n\n\t \n\tnubus_move(&p, nubus_expand32(nd->data), nd->mask);\n\t \n\treturn p;\n}\n\n \n\nvoid nubus_get_rsrc_mem(void *dest, const struct nubus_dirent *dirent,\n\t\t\tunsigned int len)\n{\n\tunsigned char *t = dest;\n\tunsigned char *p = nubus_dirptr(dirent);\n\n\twhile (len) {\n\t\t*t++ = nubus_get_rom(&p, 1, dirent->mask);\n\t\tlen--;\n\t}\n}\nEXPORT_SYMBOL(nubus_get_rsrc_mem);\n\nunsigned int nubus_get_rsrc_str(char *dest, const struct nubus_dirent *dirent,\n\t\t\t\tunsigned int len)\n{\n\tchar *t = dest;\n\tunsigned char *p = nubus_dirptr(dirent);\n\n\twhile (len > 1) {\n\t\tunsigned char c = nubus_get_rom(&p, 1, dirent->mask);\n\n\t\tif (!c)\n\t\t\tbreak;\n\t\t*t++ = c;\n\t\tlen--;\n\t}\n\tif (len > 0)\n\t\t*t = '\\0';\n\treturn t - dest;\n}\nEXPORT_SYMBOL(nubus_get_rsrc_str);\n\nvoid nubus_seq_write_rsrc_mem(struct seq_file *m,\n\t\t\t      const struct nubus_dirent *dirent,\n\t\t\t      unsigned int len)\n{\n\tunsigned long buf[32];\n\tunsigned int buf_size = sizeof(buf);\n\tunsigned char *p = nubus_dirptr(dirent);\n\n\t \n\twhile (len >= buf_size) {\n\t\tunsigned int i;\n\n\t\tfor (i = 0; i < ARRAY_SIZE(buf); i++)\n\t\t\tbuf[i] = nubus_get_rom(&p, sizeof(buf[0]),\n\t\t\t\t\t       dirent->mask);\n\t\tseq_write(m, buf, buf_size);\n\t\tlen -= buf_size;\n\t}\n\t \n\twhile (len--)\n\t\tseq_putc(m, nubus_get_rom(&p, 1, dirent->mask));\n}\n\nint nubus_get_root_dir(const struct nubus_board *board,\n\t\t       struct nubus_dir *dir)\n{\n\tdir->ptr = dir->base = board->directory;\n\tdir->done = 0;\n\tdir->mask = board->lanes;\n\treturn 0;\n}\nEXPORT_SYMBOL(nubus_get_root_dir);\n\n \nint nubus_get_func_dir(const struct nubus_rsrc *fres, struct nubus_dir *dir)\n{\n\tdir->ptr = dir->base = fres->directory;\n\tdir->done = 0;\n\tdir->mask = fres->board->lanes;\n\treturn 0;\n}\nEXPORT_SYMBOL(nubus_get_func_dir);\n\nint nubus_get_board_dir(const struct nubus_board *board,\n\t\t\tstruct nubus_dir *dir)\n{\n\tstruct nubus_dirent ent;\n\n\tdir->ptr = dir->base = board->directory;\n\tdir->done = 0;\n\tdir->mask = board->lanes;\n\n\t \n\tif (nubus_readdir(dir, &ent) == -1)\n\t\treturn -1;\n\tif (nubus_get_subdir(&ent, dir) == -1)\n\t\treturn -1;\n\treturn 0;\n}\nEXPORT_SYMBOL(nubus_get_board_dir);\n\nint nubus_get_subdir(const struct nubus_dirent *ent,\n\t\t     struct nubus_dir *dir)\n{\n\tdir->ptr = dir->base = nubus_dirptr(ent);\n\tdir->done = 0;\n\tdir->mask = ent->mask;\n\treturn 0;\n}\nEXPORT_SYMBOL(nubus_get_subdir);\n\nint nubus_readdir(struct nubus_dir *nd, struct nubus_dirent *ent)\n{\n\tu32 resid;\n\n\tif (nd->done)\n\t\treturn -1;\n\n\t \n\tent->base = nd->ptr;\n\n\t \n\tresid = nubus_get_rom(&nd->ptr, 4, nd->mask);\n\n\t \n\tif ((resid & 0xff000000) == 0xff000000) {\n\t\t \n\t\tnd->done = 1;\n\t\treturn -1;\n\t}\n\n\t \n\tent->type = resid >> 24;\n\t \n\tent->data = resid & 0xffffff;\n\tent->mask = nd->mask;\n\treturn 0;\n}\nEXPORT_SYMBOL(nubus_readdir);\n\nint nubus_rewinddir(struct nubus_dir *dir)\n{\n\tdir->ptr = dir->base;\n\tdir->done = 0;\n\treturn 0;\n}\nEXPORT_SYMBOL(nubus_rewinddir);\n\n \n\nstruct nubus_rsrc *nubus_first_rsrc_or_null(void)\n{\n\treturn list_first_entry_or_null(&nubus_func_rsrcs, struct nubus_rsrc,\n\t\t\t\t\tlist);\n}\nEXPORT_SYMBOL(nubus_first_rsrc_or_null);\n\nstruct nubus_rsrc *nubus_next_rsrc_or_null(struct nubus_rsrc *from)\n{\n\tif (list_is_last(&from->list, &nubus_func_rsrcs))\n\t\treturn NULL;\n\treturn list_next_entry(from, list);\n}\nEXPORT_SYMBOL(nubus_next_rsrc_or_null);\n\nint\nnubus_find_rsrc(struct nubus_dir *dir, unsigned char rsrc_type,\n\t\tstruct nubus_dirent *ent)\n{\n\twhile (nubus_readdir(dir, ent) != -1) {\n\t\tif (ent->type == rsrc_type)\n\t\t\treturn 0;\n\t}\n\treturn -1;\n}\nEXPORT_SYMBOL(nubus_find_rsrc);\n\n \n\nstatic int __init nubus_get_block_rsrc_dir(struct nubus_board *board,\n\t\t\t\t\t   struct proc_dir_entry *procdir,\n\t\t\t\t\t   const struct nubus_dirent *parent)\n{\n\tstruct nubus_dir dir;\n\tstruct nubus_dirent ent;\n\n\tnubus_get_subdir(parent, &dir);\n\tdir.procdir = nubus_proc_add_rsrc_dir(procdir, parent, board);\n\n\twhile (nubus_readdir(&dir, &ent) != -1) {\n\t\tu32 size;\n\n\t\tnubus_get_rsrc_mem(&size, &ent, 4);\n\t\tpr_debug(\"        block (0x%x), size %d\\n\", ent.type, size);\n\t\tnubus_proc_add_rsrc_mem(dir.procdir, &ent, size);\n\t}\n\treturn 0;\n}\n\nstatic int __init nubus_get_display_vidmode(struct nubus_board *board,\n\t\t\t\t\t    struct proc_dir_entry *procdir,\n\t\t\t\t\t    const struct nubus_dirent *parent)\n{\n\tstruct nubus_dir dir;\n\tstruct nubus_dirent ent;\n\n\tnubus_get_subdir(parent, &dir);\n\tdir.procdir = nubus_proc_add_rsrc_dir(procdir, parent, board);\n\n\twhile (nubus_readdir(&dir, &ent) != -1) {\n\t\tswitch (ent.type) {\n\t\tcase 1:  \n\t\tcase 2:  \n\t\t{\n\t\t\tu32 size;\n\n\t\t\tnubus_get_rsrc_mem(&size, &ent, 4);\n\t\t\tpr_debug(\"        block (0x%x), size %d\\n\", ent.type,\n\t\t\t\tsize);\n\t\t\tnubus_proc_add_rsrc_mem(dir.procdir, &ent, size);\n\t\t\tbreak;\n\t\t}\n\t\tdefault:\n\t\t\tpr_debug(\"        unknown resource 0x%02x, data 0x%06x\\n\",\n\t\t\t\tent.type, ent.data);\n\t\t\tnubus_proc_add_rsrc_mem(dir.procdir, &ent, 0);\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int __init nubus_get_display_resource(struct nubus_rsrc *fres,\n\t\t\t\t\t     struct proc_dir_entry *procdir,\n\t\t\t\t\t     const struct nubus_dirent *ent)\n{\n\tswitch (ent->type) {\n\tcase NUBUS_RESID_GAMMADIR:\n\t\tpr_debug(\"    gamma directory offset: 0x%06x\\n\", ent->data);\n\t\tnubus_get_block_rsrc_dir(fres->board, procdir, ent);\n\t\tbreak;\n\tcase 0x0080 ... 0x0085:\n\t\tpr_debug(\"    mode 0x%02x info offset: 0x%06x\\n\",\n\t\t\tent->type, ent->data);\n\t\tnubus_get_display_vidmode(fres->board, procdir, ent);\n\t\tbreak;\n\tdefault:\n\t\tpr_debug(\"    unknown resource 0x%02x, data 0x%06x\\n\",\n\t\t\tent->type, ent->data);\n\t\tnubus_proc_add_rsrc_mem(procdir, ent, 0);\n\t}\n\treturn 0;\n}\n\nstatic int __init nubus_get_network_resource(struct nubus_rsrc *fres,\n\t\t\t\t\t     struct proc_dir_entry *procdir,\n\t\t\t\t\t     const struct nubus_dirent *ent)\n{\n\tswitch (ent->type) {\n\tcase NUBUS_RESID_MAC_ADDRESS:\n\t{\n\t\tchar addr[6];\n\n\t\tnubus_get_rsrc_mem(addr, ent, 6);\n\t\tpr_debug(\"    MAC address: %pM\\n\", addr);\n\t\tnubus_proc_add_rsrc_mem(procdir, ent, 6);\n\t\tbreak;\n\t}\n\tdefault:\n\t\tpr_debug(\"    unknown resource 0x%02x, data 0x%06x\\n\",\n\t\t\tent->type, ent->data);\n\t\tnubus_proc_add_rsrc_mem(procdir, ent, 0);\n\t}\n\treturn 0;\n}\n\nstatic int __init nubus_get_cpu_resource(struct nubus_rsrc *fres,\n\t\t\t\t\t struct proc_dir_entry *procdir,\n\t\t\t\t\t const struct nubus_dirent *ent)\n{\n\tswitch (ent->type) {\n\tcase NUBUS_RESID_MEMINFO:\n\t{\n\t\tunsigned long meminfo[2];\n\n\t\tnubus_get_rsrc_mem(&meminfo, ent, 8);\n\t\tpr_debug(\"    memory: [ 0x%08lx 0x%08lx ]\\n\",\n\t\t\tmeminfo[0], meminfo[1]);\n\t\tnubus_proc_add_rsrc_mem(procdir, ent, 8);\n\t\tbreak;\n\t}\n\tcase NUBUS_RESID_ROMINFO:\n\t{\n\t\tunsigned long rominfo[2];\n\n\t\tnubus_get_rsrc_mem(&rominfo, ent, 8);\n\t\tpr_debug(\"    ROM:    [ 0x%08lx 0x%08lx ]\\n\",\n\t\t\trominfo[0], rominfo[1]);\n\t\tnubus_proc_add_rsrc_mem(procdir, ent, 8);\n\t\tbreak;\n\t}\n\tdefault:\n\t\tpr_debug(\"    unknown resource 0x%02x, data 0x%06x\\n\",\n\t\t\tent->type, ent->data);\n\t\tnubus_proc_add_rsrc_mem(procdir, ent, 0);\n\t}\n\treturn 0;\n}\n\nstatic int __init nubus_get_private_resource(struct nubus_rsrc *fres,\n\t\t\t\t\t     struct proc_dir_entry *procdir,\n\t\t\t\t\t     const struct nubus_dirent *ent)\n{\n\tswitch (fres->category) {\n\tcase NUBUS_CAT_DISPLAY:\n\t\tnubus_get_display_resource(fres, procdir, ent);\n\t\tbreak;\n\tcase NUBUS_CAT_NETWORK:\n\t\tnubus_get_network_resource(fres, procdir, ent);\n\t\tbreak;\n\tcase NUBUS_CAT_CPU:\n\t\tnubus_get_cpu_resource(fres, procdir, ent);\n\t\tbreak;\n\tdefault:\n\t\tpr_debug(\"    unknown resource 0x%02x, data 0x%06x\\n\",\n\t\t\tent->type, ent->data);\n\t\tnubus_proc_add_rsrc_mem(procdir, ent, 0);\n\t}\n\treturn 0;\n}\n\nstatic struct nubus_rsrc * __init\nnubus_get_functional_resource(struct nubus_board *board, int slot,\n\t\t\t      const struct nubus_dirent *parent)\n{\n\tstruct nubus_dir dir;\n\tstruct nubus_dirent ent;\n\tstruct nubus_rsrc *fres;\n\n\tpr_debug(\"  Functional resource 0x%02x:\\n\", parent->type);\n\tnubus_get_subdir(parent, &dir);\n\tdir.procdir = nubus_proc_add_rsrc_dir(board->procdir, parent, board);\n\n\t \n\tfres = kzalloc(sizeof(*fres), GFP_ATOMIC);\n\tif (!fres)\n\t\treturn NULL;\n\tfres->resid = parent->type;\n\tfres->directory = dir.base;\n\tfres->board = board;\n\n\twhile (nubus_readdir(&dir, &ent) != -1) {\n\t\tswitch (ent.type) {\n\t\tcase NUBUS_RESID_TYPE:\n\t\t{\n\t\t\tunsigned short nbtdata[4];\n\n\t\t\tnubus_get_rsrc_mem(nbtdata, &ent, 8);\n\t\t\tfres->category = nbtdata[0];\n\t\t\tfres->type     = nbtdata[1];\n\t\t\tfres->dr_sw    = nbtdata[2];\n\t\t\tfres->dr_hw    = nbtdata[3];\n\t\t\tpr_debug(\"    type: [cat 0x%x type 0x%x sw 0x%x hw 0x%x]\\n\",\n\t\t\t\tnbtdata[0], nbtdata[1], nbtdata[2], nbtdata[3]);\n\t\t\tnubus_proc_add_rsrc_mem(dir.procdir, &ent, 8);\n\t\t\tbreak;\n\t\t}\n\t\tcase NUBUS_RESID_NAME:\n\t\t{\n\t\t\tchar name[64];\n\t\t\tunsigned int len;\n\n\t\t\tlen = nubus_get_rsrc_str(name, &ent, sizeof(name));\n\t\t\tpr_debug(\"    name: %s\\n\", name);\n\t\t\tnubus_proc_add_rsrc_mem(dir.procdir, &ent, len + 1);\n\t\t\tbreak;\n\t\t}\n\t\tcase NUBUS_RESID_DRVRDIR:\n\t\t{\n\t\t\t \n\t\t\tpr_debug(\"    driver directory offset: 0x%06x\\n\",\n\t\t\t\tent.data);\n\t\t\tnubus_get_block_rsrc_dir(board, dir.procdir, &ent);\n\t\t\tbreak;\n\t\t}\n\t\tcase NUBUS_RESID_MINOR_BASEOS:\n\t\t{\n\t\t\t \n\t\t\tu32 base_offset;\n\n\t\t\tnubus_get_rsrc_mem(&base_offset, &ent, 4);\n\t\t\tpr_debug(\"    memory offset: 0x%08x\\n\", base_offset);\n\t\t\tnubus_proc_add_rsrc_mem(dir.procdir, &ent, 4);\n\t\t\tbreak;\n\t\t}\n\t\tcase NUBUS_RESID_MINOR_LENGTH:\n\t\t{\n\t\t\t \n\t\t\tu32 length;\n\n\t\t\tnubus_get_rsrc_mem(&length, &ent, 4);\n\t\t\tpr_debug(\"    memory length: 0x%08x\\n\", length);\n\t\t\tnubus_proc_add_rsrc_mem(dir.procdir, &ent, 4);\n\t\t\tbreak;\n\t\t}\n\t\tcase NUBUS_RESID_FLAGS:\n\t\t\tpr_debug(\"    flags: 0x%06x\\n\", ent.data);\n\t\t\tnubus_proc_add_rsrc(dir.procdir, &ent);\n\t\t\tbreak;\n\t\tcase NUBUS_RESID_HWDEVID:\n\t\t\tpr_debug(\"    hwdevid: 0x%06x\\n\", ent.data);\n\t\t\tnubus_proc_add_rsrc(dir.procdir, &ent);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (nubus_populate_procfs)\n\t\t\t\tnubus_get_private_resource(fres, dir.procdir,\n\t\t\t\t\t\t\t   &ent);\n\t\t}\n\t}\n\n\treturn fres;\n}\n\n \nstatic int __init nubus_get_icon(struct nubus_board *board,\n\t\t\t\t struct proc_dir_entry *procdir,\n\t\t\t\t const struct nubus_dirent *ent)\n{\n\t \n\tu32 icon[32];\n\tint i;\n\n\tnubus_get_rsrc_mem(&icon, ent, 128);\n\tpr_debug(\"    icon:\\n\");\n\tfor (i = 0; i < 8; i++)\n\t\tpr_debug(\"        %08x %08x %08x %08x\\n\",\n\t\t\ticon[i * 4 + 0], icon[i * 4 + 1],\n\t\t\ticon[i * 4 + 2], icon[i * 4 + 3]);\n\tnubus_proc_add_rsrc_mem(procdir, ent, 128);\n\n\treturn 0;\n}\n\nstatic int __init nubus_get_vendorinfo(struct nubus_board *board,\n\t\t\t\t       struct proc_dir_entry *procdir,\n\t\t\t\t       const struct nubus_dirent *parent)\n{\n\tstruct nubus_dir dir;\n\tstruct nubus_dirent ent;\n\tstatic char *vendor_fields[6] = { \"ID\", \"serial\", \"revision\",\n\t                                  \"part\", \"date\", \"unknown field\" };\n\n\tpr_debug(\"    vendor info:\\n\");\n\tnubus_get_subdir(parent, &dir);\n\tdir.procdir = nubus_proc_add_rsrc_dir(procdir, parent, board);\n\n\twhile (nubus_readdir(&dir, &ent) != -1) {\n\t\tchar name[64];\n\t\tunsigned int len;\n\n\t\t \n\t\tlen = nubus_get_rsrc_str(name, &ent, sizeof(name));\n\t\tif (ent.type < 1 || ent.type > 5)\n\t\t\tent.type = 5;\n\t\tpr_debug(\"    %s: %s\\n\", vendor_fields[ent.type - 1], name);\n\t\tnubus_proc_add_rsrc_mem(dir.procdir, &ent, len + 1);\n\t}\n\treturn 0;\n}\n\nstatic int __init nubus_get_board_resource(struct nubus_board *board, int slot,\n\t\t\t\t\t   const struct nubus_dirent *parent)\n{\n\tstruct nubus_dir dir;\n\tstruct nubus_dirent ent;\n\n\tpr_debug(\"  Board resource 0x%02x:\\n\", parent->type);\n\tnubus_get_subdir(parent, &dir);\n\tdir.procdir = nubus_proc_add_rsrc_dir(board->procdir, parent, board);\n\n\twhile (nubus_readdir(&dir, &ent) != -1) {\n\t\tswitch (ent.type) {\n\t\tcase NUBUS_RESID_TYPE:\n\t\t{\n\t\t\tunsigned short nbtdata[4];\n\t\t\t \n\t\t\tnubus_get_rsrc_mem(nbtdata, &ent, 8);\n\t\t\tpr_debug(\"    type: [cat 0x%x type 0x%x sw 0x%x hw 0x%x]\\n\",\n\t\t\t\tnbtdata[0], nbtdata[1], nbtdata[2], nbtdata[3]);\n\t\t\tif (nbtdata[0] != 1 || nbtdata[1] != 0 ||\n\t\t\t    nbtdata[2] != 0 || nbtdata[3] != 0)\n\t\t\t\tpr_err(\"Slot %X: sResource is not a board resource!\\n\",\n\t\t\t\t       slot);\n\t\t\tnubus_proc_add_rsrc_mem(dir.procdir, &ent, 8);\n\t\t\tbreak;\n\t\t}\n\t\tcase NUBUS_RESID_NAME:\n\t\t{\n\t\t\tunsigned int len;\n\n\t\t\tlen = nubus_get_rsrc_str(board->name, &ent,\n\t\t\t\t\t\t sizeof(board->name));\n\t\t\tpr_debug(\"    name: %s\\n\", board->name);\n\t\t\tnubus_proc_add_rsrc_mem(dir.procdir, &ent, len + 1);\n\t\t\tbreak;\n\t\t}\n\t\tcase NUBUS_RESID_ICON:\n\t\t\tnubus_get_icon(board, dir.procdir, &ent);\n\t\t\tbreak;\n\t\tcase NUBUS_RESID_BOARDID:\n\t\t\tpr_debug(\"    board id: 0x%x\\n\", ent.data);\n\t\t\tnubus_proc_add_rsrc(dir.procdir, &ent);\n\t\t\tbreak;\n\t\tcase NUBUS_RESID_PRIMARYINIT:\n\t\t\tpr_debug(\"    primary init offset: 0x%06x\\n\", ent.data);\n\t\t\tnubus_proc_add_rsrc(dir.procdir, &ent);\n\t\t\tbreak;\n\t\tcase NUBUS_RESID_VENDORINFO:\n\t\t\tnubus_get_vendorinfo(board, dir.procdir, &ent);\n\t\t\tbreak;\n\t\tcase NUBUS_RESID_FLAGS:\n\t\t\tpr_debug(\"    flags: 0x%06x\\n\", ent.data);\n\t\t\tnubus_proc_add_rsrc(dir.procdir, &ent);\n\t\t\tbreak;\n\t\tcase NUBUS_RESID_HWDEVID:\n\t\t\tpr_debug(\"    hwdevid: 0x%06x\\n\", ent.data);\n\t\t\tnubus_proc_add_rsrc(dir.procdir, &ent);\n\t\t\tbreak;\n\t\tcase NUBUS_RESID_SECONDINIT:\n\t\t\tpr_debug(\"    secondary init offset: 0x%06x\\n\",\n\t\t\t\t ent.data);\n\t\t\tnubus_proc_add_rsrc(dir.procdir, &ent);\n\t\t\tbreak;\n\t\t\t \n\t\tcase NUBUS_RESID_VIDNAMES:\n\t\t\tpr_debug(\"    vidnames directory offset: 0x%06x\\n\",\n\t\t\t\tent.data);\n\t\t\tnubus_get_block_rsrc_dir(board, dir.procdir, &ent);\n\t\t\tbreak;\n\t\t\t \n\t\tcase NUBUS_RESID_VIDMODES:\n\t\t\tpr_debug(\"    video mode parameter directory offset: 0x%06x\\n\",\n\t\t\t\tent.data);\n\t\t\tnubus_proc_add_rsrc(dir.procdir, &ent);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_debug(\"    unknown resource 0x%02x, data 0x%06x\\n\",\n\t\t\t\tent.type, ent.data);\n\t\t\tnubus_proc_add_rsrc_mem(dir.procdir, &ent, 0);\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic void __init nubus_add_board(int slot, int bytelanes)\n{\n\tstruct nubus_board *board;\n\tunsigned char *rp;\n\tunsigned long dpat;\n\tstruct nubus_dir dir;\n\tstruct nubus_dirent ent;\n\tint prev_resid = -1;\n\n\t \n\trp = nubus_rom_addr(slot);\n\tnubus_rewind(&rp, FORMAT_BLOCK_SIZE, bytelanes);\n\n\t \n\tif ((board = kzalloc(sizeof(*board), GFP_ATOMIC)) == NULL)\n\t\treturn;\n\tboard->fblock = rp;\n\n\t \n\tpr_debug(\"Slot %X, format block at 0x%p:\\n\", slot, rp);\n\tpr_debug(\"%08lx\\n\", nubus_get_rom(&rp, 4, bytelanes));\n\tpr_debug(\"%08lx\\n\", nubus_get_rom(&rp, 4, bytelanes));\n\tpr_debug(\"%08lx\\n\", nubus_get_rom(&rp, 4, bytelanes));\n\tpr_debug(\"%02lx\\n\", nubus_get_rom(&rp, 1, bytelanes));\n\tpr_debug(\"%02lx\\n\", nubus_get_rom(&rp, 1, bytelanes));\n\tpr_debug(\"%08lx\\n\", nubus_get_rom(&rp, 4, bytelanes));\n\tpr_debug(\"%02lx\\n\", nubus_get_rom(&rp, 1, bytelanes));\n\tpr_debug(\"%02lx\\n\", nubus_get_rom(&rp, 1, bytelanes));\n\trp = board->fblock;\n\n\tboard->slot = slot;\n\tboard->slot_addr = (unsigned long)nubus_slot_addr(slot);\n\tboard->doffset = nubus_get_rom(&rp, 4, bytelanes);\n\t \n\tboard->rom_length = nubus_get_rom(&rp, 4, bytelanes);\n\tboard->crc = nubus_get_rom(&rp, 4, bytelanes);\n\tboard->rev = nubus_get_rom(&rp, 1, bytelanes);\n\tboard->format = nubus_get_rom(&rp, 1, bytelanes);\n\tboard->lanes = bytelanes;\n\n\t \n\tif (!(board->doffset & 0x00FF0000))\n\t\tpr_warn(\"Slot %X: Dodgy doffset!\\n\", slot);\n\tdpat = nubus_get_rom(&rp, 4, bytelanes);\n\tif (dpat != NUBUS_TEST_PATTERN)\n\t\tpr_warn(\"Slot %X: Wrong test pattern %08lx!\\n\", slot, dpat);\n\n\t \n\n\t \n\tboard->directory = board->fblock;\n\tnubus_move(&board->directory, nubus_expand32(board->doffset),\n\t           board->lanes);\n\n\tnubus_get_root_dir(board, &dir);\n\n\t \n\tpr_debug(\"Slot %X resources:\\n\", slot);\n\n\t \n\tif (nubus_readdir(&dir, &ent) == -1) {\n\t\t \n\t\tpr_err(\"Slot %X: Board resource not found!\\n\", slot);\n\t\tkfree(board);\n\t\treturn;\n\t}\n\n\tif (ent.type < 1 || ent.type > 127)\n\t\tpr_warn(\"Slot %X: Board resource ID is invalid!\\n\", slot);\n\n\tboard->procdir = nubus_proc_add_board(board);\n\n\tnubus_get_board_resource(board, slot, &ent);\n\n\twhile (nubus_readdir(&dir, &ent) != -1) {\n\t\tstruct nubus_rsrc *fres;\n\n\t\tfres = nubus_get_functional_resource(board, slot, &ent);\n\t\tif (fres == NULL)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (fres->resid <= prev_resid) {\n\t\t\tkfree(fres);\n\t\t\tcontinue;\n\t\t}\n\t\tprev_resid = fres->resid;\n\n\t\tlist_add_tail(&fres->list, &nubus_func_rsrcs);\n\t}\n\n\tif (nubus_device_register(board))\n\t\tput_device(&board->dev);\n}\n\nstatic void __init nubus_probe_slot(int slot)\n{\n\tunsigned char dp;\n\tunsigned char *rp;\n\tint i;\n\n\trp = nubus_rom_addr(slot);\n\tfor (i = 4; i; i--) {\n\t\trp--;\n\t\tif (!hwreg_present(rp))\n\t\t\tcontinue;\n\n\t\tdp = *rp;\n\n\t\t \n\t\tif ((((dp >> 4) ^ dp) & 0x0F) != 0x0F)\n\t\t\tcontinue;\n\t\t \n\t\tif (not_useful(rp, dp))\n\t\t\tcontinue;\n\n\t\t \n\t\tnubus_add_board(slot, dp);\n\n\t\treturn;\n\t}\n}\n\nstatic void __init nubus_scan_bus(void)\n{\n\tint slot;\n\n\tpr_info(\"NuBus: Scanning NuBus slots.\\n\");\n\tfor (slot = 9; slot < 15; slot++) {\n\t\tnubus_probe_slot(slot);\n\t}\n}\n\nstatic int __init nubus_init(void)\n{\n\tint err;\n\n\tif (!MACH_IS_MAC)\n\t\treturn 0;\n\n\tnubus_proc_init();\n\terr = nubus_parent_device_register();\n\tif (err)\n\t\treturn err;\n\tnubus_scan_bus();\n\treturn 0;\n}\n\nsubsys_initcall(nubus_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}