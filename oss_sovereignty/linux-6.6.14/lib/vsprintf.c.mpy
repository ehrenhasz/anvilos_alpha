{
  "module_name": "vsprintf.c",
  "hash_id": "7d8504f596d4481da61b6c523c2e7936432314a1f826b6360e8463d8bd12dc30",
  "original_prompt": "Ingested from linux-6.6.14/lib/vsprintf.c",
  "human_readable_source": "\n \n\n \n \n\n \n\n#include <linux/stdarg.h>\n#include <linux/build_bug.h>\n#include <linux/clk.h>\n#include <linux/clk-provider.h>\n#include <linux/errname.h>\n#include <linux/module.h>\t \n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/math64.h>\n#include <linux/uaccess.h>\n#include <linux/ioport.h>\n#include <linux/dcache.h>\n#include <linux/cred.h>\n#include <linux/rtc.h>\n#include <linux/sprintf.h>\n#include <linux/time.h>\n#include <linux/uuid.h>\n#include <linux/of.h>\n#include <net/addrconf.h>\n#include <linux/siphash.h>\n#include <linux/compiler.h>\n#include <linux/property.h>\n#include <linux/notifier.h>\n#ifdef CONFIG_BLOCK\n#include <linux/blkdev.h>\n#endif\n\n#include \"../mm/internal.h\"\t \n\n#include <asm/page.h>\t\t \n#include <asm/byteorder.h>\t \n#include <asm/unaligned.h>\n\n#include <linux/string_helpers.h>\n#include \"kstrtox.h\"\n\n \nbool no_hash_pointers __ro_after_init;\nEXPORT_SYMBOL_GPL(no_hash_pointers);\n\nstatic noinline unsigned long long simple_strntoull(const char *startp, size_t max_chars, char **endp, unsigned int base)\n{\n\tconst char *cp;\n\tunsigned long long result = 0ULL;\n\tsize_t prefix_chars;\n\tunsigned int rv;\n\n\tcp = _parse_integer_fixup_radix(startp, &base);\n\tprefix_chars = cp - startp;\n\tif (prefix_chars < max_chars) {\n\t\trv = _parse_integer_limit(cp, base, &result, max_chars - prefix_chars);\n\t\t \n\t\tcp += (rv & ~KSTRTOX_OVERFLOW);\n\t} else {\n\t\t \n\t\tcp = startp + max_chars;\n\t}\n\n\tif (endp)\n\t\t*endp = (char *)cp;\n\n\treturn result;\n}\n\n \nnoinline\nunsigned long long simple_strtoull(const char *cp, char **endp, unsigned int base)\n{\n\treturn simple_strntoull(cp, INT_MAX, endp, base);\n}\nEXPORT_SYMBOL(simple_strtoull);\n\n \nunsigned long simple_strtoul(const char *cp, char **endp, unsigned int base)\n{\n\treturn simple_strtoull(cp, endp, base);\n}\nEXPORT_SYMBOL(simple_strtoul);\n\n \nlong simple_strtol(const char *cp, char **endp, unsigned int base)\n{\n\tif (*cp == '-')\n\t\treturn -simple_strtoul(cp + 1, endp, base);\n\n\treturn simple_strtoul(cp, endp, base);\n}\nEXPORT_SYMBOL(simple_strtol);\n\nstatic long long simple_strntoll(const char *cp, size_t max_chars, char **endp,\n\t\t\t\t unsigned int base)\n{\n\t \n\tif (*cp == '-' && max_chars > 0)\n\t\treturn -simple_strntoull(cp + 1, max_chars - 1, endp, base);\n\n\treturn simple_strntoull(cp, max_chars, endp, base);\n}\n\n \nlong long simple_strtoll(const char *cp, char **endp, unsigned int base)\n{\n\treturn simple_strntoll(cp, INT_MAX, endp, base);\n}\nEXPORT_SYMBOL(simple_strtoll);\n\nstatic noinline_for_stack\nint skip_atoi(const char **s)\n{\n\tint i = 0;\n\n\tdo {\n\t\ti = i*10 + *((*s)++) - '0';\n\t} while (isdigit(**s));\n\n\treturn i;\n}\n\n \n\nstatic const u16 decpair[100] = {\n#define _(x) (__force u16) cpu_to_le16(((x % 10) | ((x / 10) << 8)) + 0x3030)\n\t_( 0), _( 1), _( 2), _( 3), _( 4), _( 5), _( 6), _( 7), _( 8), _( 9),\n\t_(10), _(11), _(12), _(13), _(14), _(15), _(16), _(17), _(18), _(19),\n\t_(20), _(21), _(22), _(23), _(24), _(25), _(26), _(27), _(28), _(29),\n\t_(30), _(31), _(32), _(33), _(34), _(35), _(36), _(37), _(38), _(39),\n\t_(40), _(41), _(42), _(43), _(44), _(45), _(46), _(47), _(48), _(49),\n\t_(50), _(51), _(52), _(53), _(54), _(55), _(56), _(57), _(58), _(59),\n\t_(60), _(61), _(62), _(63), _(64), _(65), _(66), _(67), _(68), _(69),\n\t_(70), _(71), _(72), _(73), _(74), _(75), _(76), _(77), _(78), _(79),\n\t_(80), _(81), _(82), _(83), _(84), _(85), _(86), _(87), _(88), _(89),\n\t_(90), _(91), _(92), _(93), _(94), _(95), _(96), _(97), _(98), _(99),\n#undef _\n};\n\n \nstatic noinline_for_stack\nchar *put_dec_trunc8(char *buf, unsigned r)\n{\n\tunsigned q;\n\n\t \n\tif (r < 100)\n\t\tgoto out_r;\n\n\t \n\tq = (r * (u64)0x28f5c29) >> 32;\n\t*((u16 *)buf) = decpair[r - 100*q];\n\tbuf += 2;\n\n\t \n\tif (q < 100)\n\t\tgoto out_q;\n\n\t \n\tr = (q * (u64)0x28f5c29) >> 32;\n\t*((u16 *)buf) = decpair[q - 100*r];\n\tbuf += 2;\n\n\t \n\tif (r < 100)\n\t\tgoto out_r;\n\n\t \n\tq = (r * 0x147b) >> 19;\n\t*((u16 *)buf) = decpair[r - 100*q];\n\tbuf += 2;\nout_q:\n\t \n\tr = q;\nout_r:\n\t \n\t*((u16 *)buf) = decpair[r];\n\tbuf += r < 10 ? 1 : 2;\n\treturn buf;\n}\n\n#if BITS_PER_LONG == 64 && BITS_PER_LONG_LONG == 64\nstatic noinline_for_stack\nchar *put_dec_full8(char *buf, unsigned r)\n{\n\tunsigned q;\n\n\t \n\tq = (r * (u64)0x28f5c29) >> 32;\n\t*((u16 *)buf) = decpair[r - 100*q];\n\tbuf += 2;\n\n\t \n\tr = (q * (u64)0x28f5c29) >> 32;\n\t*((u16 *)buf) = decpair[q - 100*r];\n\tbuf += 2;\n\n\t \n\tq = (r * 0x147b) >> 19;\n\t*((u16 *)buf) = decpair[r - 100*q];\n\tbuf += 2;\n\n\t \n\t*((u16 *)buf) = decpair[q];\n\tbuf += 2;\n\treturn buf;\n}\n\nstatic noinline_for_stack\nchar *put_dec(char *buf, unsigned long long n)\n{\n\tif (n >= 100*1000*1000)\n\t\tbuf = put_dec_full8(buf, do_div(n, 100*1000*1000));\n\t \n\tif (n >= 100*1000*1000)\n\t\tbuf = put_dec_full8(buf, do_div(n, 100*1000*1000));\n\t \n\treturn put_dec_trunc8(buf, n);\n}\n\n#elif BITS_PER_LONG == 32 && BITS_PER_LONG_LONG == 64\n\nstatic void\nput_dec_full4(char *buf, unsigned r)\n{\n\tunsigned q;\n\n\t \n\tq = (r * 0x147b) >> 19;\n\t*((u16 *)buf) = decpair[r - 100*q];\n\tbuf += 2;\n\t \n\t*((u16 *)buf) = decpair[q];\n}\n\n \nstatic noinline_for_stack\nunsigned put_dec_helper4(char *buf, unsigned x)\n{\n        uint32_t q = (x * (uint64_t)0x346DC5D7) >> 43;\n\n        put_dec_full4(buf, x - q * 10000);\n        return q;\n}\n\n \nstatic\nchar *put_dec(char *buf, unsigned long long n)\n{\n\tuint32_t d3, d2, d1, q, h;\n\n\tif (n < 100*1000*1000)\n\t\treturn put_dec_trunc8(buf, n);\n\n\td1  = ((uint32_t)n >> 16);  \n\th   = (n >> 32);\n\td2  = (h      ) & 0xffff;\n\td3  = (h >> 16);  \n\n\t \n\tq   = 656 * d3 + 7296 * d2 + 5536 * d1 + ((uint32_t)n & 0xffff);\n\tq = put_dec_helper4(buf, q);\n\n\tq += 7671 * d3 + 9496 * d2 + 6 * d1;\n\tq = put_dec_helper4(buf+4, q);\n\n\tq += 4749 * d3 + 42 * d2;\n\tq = put_dec_helper4(buf+8, q);\n\n\tq += 281 * d3;\n\tbuf += 12;\n\tif (q)\n\t\tbuf = put_dec_trunc8(buf, q);\n\telse while (buf[-1] == '0')\n\t\t--buf;\n\n\treturn buf;\n}\n\n#endif\n\n \nint num_to_str(char *buf, int size, unsigned long long num, unsigned int width)\n{\n\t \n\tchar tmp[sizeof(num) * 3] __aligned(2);\n\tint idx, len;\n\n\t \n\tif (num <= 9) {\n\t\ttmp[0] = '0' + num;\n\t\tlen = 1;\n\t} else {\n\t\tlen = put_dec(tmp, num) - tmp;\n\t}\n\n\tif (len > size || width > size)\n\t\treturn 0;\n\n\tif (width > len) {\n\t\twidth = width - len;\n\t\tfor (idx = 0; idx < width; idx++)\n\t\t\tbuf[idx] = ' ';\n\t} else {\n\t\twidth = 0;\n\t}\n\n\tfor (idx = 0; idx < len; ++idx)\n\t\tbuf[idx + width] = tmp[len - idx - 1];\n\n\treturn len + width;\n}\n\n#define SIGN\t1\t\t \n#define LEFT\t2\t\t \n#define PLUS\t4\t\t \n#define SPACE\t8\t\t \n#define ZEROPAD\t16\t\t \n#define SMALL\t32\t\t \n#define SPECIAL\t64\t\t \n\nstatic_assert(SIGN == 1);\nstatic_assert(ZEROPAD == ('0' - ' '));\nstatic_assert(SMALL == ('a' ^ 'A'));\n\nenum format_type {\n\tFORMAT_TYPE_NONE,  \n\tFORMAT_TYPE_WIDTH,\n\tFORMAT_TYPE_PRECISION,\n\tFORMAT_TYPE_CHAR,\n\tFORMAT_TYPE_STR,\n\tFORMAT_TYPE_PTR,\n\tFORMAT_TYPE_PERCENT_CHAR,\n\tFORMAT_TYPE_INVALID,\n\tFORMAT_TYPE_LONG_LONG,\n\tFORMAT_TYPE_ULONG,\n\tFORMAT_TYPE_LONG,\n\tFORMAT_TYPE_UBYTE,\n\tFORMAT_TYPE_BYTE,\n\tFORMAT_TYPE_USHORT,\n\tFORMAT_TYPE_SHORT,\n\tFORMAT_TYPE_UINT,\n\tFORMAT_TYPE_INT,\n\tFORMAT_TYPE_SIZE_T,\n\tFORMAT_TYPE_PTRDIFF\n};\n\nstruct printf_spec {\n\tunsigned int\ttype:8;\t\t \n\tsigned int\tfield_width:24;\t \n\tunsigned int\tflags:8;\t \n\tunsigned int\tbase:8;\t\t \n\tsigned int\tprecision:16;\t \n} __packed;\nstatic_assert(sizeof(struct printf_spec) == 8);\n\n#define FIELD_WIDTH_MAX ((1 << 23) - 1)\n#define PRECISION_MAX ((1 << 15) - 1)\n\nstatic noinline_for_stack\nchar *number(char *buf, char *end, unsigned long long num,\n\t     struct printf_spec spec)\n{\n\t \n\tchar tmp[3 * sizeof(num)] __aligned(2);\n\tchar sign;\n\tchar locase;\n\tint need_pfx = ((spec.flags & SPECIAL) && spec.base != 10);\n\tint i;\n\tbool is_zero = num == 0LL;\n\tint field_width = spec.field_width;\n\tint precision = spec.precision;\n\n\t \n\tlocase = (spec.flags & SMALL);\n\tif (spec.flags & LEFT)\n\t\tspec.flags &= ~ZEROPAD;\n\tsign = 0;\n\tif (spec.flags & SIGN) {\n\t\tif ((signed long long)num < 0) {\n\t\t\tsign = '-';\n\t\t\tnum = -(signed long long)num;\n\t\t\tfield_width--;\n\t\t} else if (spec.flags & PLUS) {\n\t\t\tsign = '+';\n\t\t\tfield_width--;\n\t\t} else if (spec.flags & SPACE) {\n\t\t\tsign = ' ';\n\t\t\tfield_width--;\n\t\t}\n\t}\n\tif (need_pfx) {\n\t\tif (spec.base == 16)\n\t\t\tfield_width -= 2;\n\t\telse if (!is_zero)\n\t\t\tfield_width--;\n\t}\n\n\t \n\ti = 0;\n\tif (num < spec.base)\n\t\ttmp[i++] = hex_asc_upper[num] | locase;\n\telse if (spec.base != 10) {  \n\t\tint mask = spec.base - 1;\n\t\tint shift = 3;\n\n\t\tif (spec.base == 16)\n\t\t\tshift = 4;\n\t\tdo {\n\t\t\ttmp[i++] = (hex_asc_upper[((unsigned char)num) & mask] | locase);\n\t\t\tnum >>= shift;\n\t\t} while (num);\n\t} else {  \n\t\ti = put_dec(tmp, num) - tmp;\n\t}\n\n\t \n\tif (i > precision)\n\t\tprecision = i;\n\t \n\tfield_width -= precision;\n\tif (!(spec.flags & (ZEROPAD | LEFT))) {\n\t\twhile (--field_width >= 0) {\n\t\t\tif (buf < end)\n\t\t\t\t*buf = ' ';\n\t\t\t++buf;\n\t\t}\n\t}\n\t \n\tif (sign) {\n\t\tif (buf < end)\n\t\t\t*buf = sign;\n\t\t++buf;\n\t}\n\t \n\tif (need_pfx) {\n\t\tif (spec.base == 16 || !is_zero) {\n\t\t\tif (buf < end)\n\t\t\t\t*buf = '0';\n\t\t\t++buf;\n\t\t}\n\t\tif (spec.base == 16) {\n\t\t\tif (buf < end)\n\t\t\t\t*buf = ('X' | locase);\n\t\t\t++buf;\n\t\t}\n\t}\n\t \n\tif (!(spec.flags & LEFT)) {\n\t\tchar c = ' ' + (spec.flags & ZEROPAD);\n\n\t\twhile (--field_width >= 0) {\n\t\t\tif (buf < end)\n\t\t\t\t*buf = c;\n\t\t\t++buf;\n\t\t}\n\t}\n\t \n\twhile (i <= --precision) {\n\t\tif (buf < end)\n\t\t\t*buf = '0';\n\t\t++buf;\n\t}\n\t \n\twhile (--i >= 0) {\n\t\tif (buf < end)\n\t\t\t*buf = tmp[i];\n\t\t++buf;\n\t}\n\t \n\twhile (--field_width >= 0) {\n\t\tif (buf < end)\n\t\t\t*buf = ' ';\n\t\t++buf;\n\t}\n\n\treturn buf;\n}\n\nstatic noinline_for_stack\nchar *special_hex_number(char *buf, char *end, unsigned long long num, int size)\n{\n\tstruct printf_spec spec;\n\n\tspec.type = FORMAT_TYPE_PTR;\n\tspec.field_width = 2 + 2 * size;\t \n\tspec.flags = SPECIAL | SMALL | ZEROPAD;\n\tspec.base = 16;\n\tspec.precision = -1;\n\n\treturn number(buf, end, num, spec);\n}\n\nstatic void move_right(char *buf, char *end, unsigned len, unsigned spaces)\n{\n\tsize_t size;\n\tif (buf >= end)\t \n\t\treturn;\n\tsize = end - buf;\n\tif (size <= spaces) {\n\t\tmemset(buf, ' ', size);\n\t\treturn;\n\t}\n\tif (len) {\n\t\tif (len > size - spaces)\n\t\t\tlen = size - spaces;\n\t\tmemmove(buf + spaces, buf, len);\n\t}\n\tmemset(buf, ' ', spaces);\n}\n\n \nstatic noinline_for_stack\nchar *widen_string(char *buf, int n, char *end, struct printf_spec spec)\n{\n\tunsigned spaces;\n\n\tif (likely(n >= spec.field_width))\n\t\treturn buf;\n\t \n\tspaces = spec.field_width - n;\n\tif (!(spec.flags & LEFT)) {\n\t\tmove_right(buf - n, end, n, spaces);\n\t\treturn buf + spaces;\n\t}\n\twhile (spaces--) {\n\t\tif (buf < end)\n\t\t\t*buf = ' ';\n\t\t++buf;\n\t}\n\treturn buf;\n}\n\n \nstatic char *string_nocheck(char *buf, char *end, const char *s,\n\t\t\t    struct printf_spec spec)\n{\n\tint len = 0;\n\tint lim = spec.precision;\n\n\twhile (lim--) {\n\t\tchar c = *s++;\n\t\tif (!c)\n\t\t\tbreak;\n\t\tif (buf < end)\n\t\t\t*buf = c;\n\t\t++buf;\n\t\t++len;\n\t}\n\treturn widen_string(buf, len, end, spec);\n}\n\nstatic char *err_ptr(char *buf, char *end, void *ptr,\n\t\t     struct printf_spec spec)\n{\n\tint err = PTR_ERR(ptr);\n\tconst char *sym = errname(err);\n\n\tif (sym)\n\t\treturn string_nocheck(buf, end, sym, spec);\n\n\t \n\tspec.flags |= SIGN;\n\tspec.base = 10;\n\treturn number(buf, end, err, spec);\n}\n\n \nstatic char *error_string(char *buf, char *end, const char *s,\n\t\t\t  struct printf_spec spec)\n{\n\t \n\tif (spec.precision == -1)\n\t\tspec.precision = 2 * sizeof(void *);\n\n\treturn string_nocheck(buf, end, s, spec);\n}\n\n \nstatic const char *check_pointer_msg(const void *ptr)\n{\n\tif (!ptr)\n\t\treturn \"(null)\";\n\n\tif ((unsigned long)ptr < PAGE_SIZE || IS_ERR_VALUE(ptr))\n\t\treturn \"(efault)\";\n\n\treturn NULL;\n}\n\nstatic int check_pointer(char **buf, char *end, const void *ptr,\n\t\t\t struct printf_spec spec)\n{\n\tconst char *err_msg;\n\n\terr_msg = check_pointer_msg(ptr);\n\tif (err_msg) {\n\t\t*buf = error_string(*buf, end, err_msg, spec);\n\t\treturn -EFAULT;\n\t}\n\n\treturn 0;\n}\n\nstatic noinline_for_stack\nchar *string(char *buf, char *end, const char *s,\n\t     struct printf_spec spec)\n{\n\tif (check_pointer(&buf, end, s, spec))\n\t\treturn buf;\n\n\treturn string_nocheck(buf, end, s, spec);\n}\n\nstatic char *pointer_string(char *buf, char *end,\n\t\t\t    const void *ptr,\n\t\t\t    struct printf_spec spec)\n{\n\tspec.base = 16;\n\tspec.flags |= SMALL;\n\tif (spec.field_width == -1) {\n\t\tspec.field_width = 2 * sizeof(ptr);\n\t\tspec.flags |= ZEROPAD;\n\t}\n\n\treturn number(buf, end, (unsigned long int)ptr, spec);\n}\n\n \nstatic int debug_boot_weak_hash __ro_after_init;\n\nstatic int __init debug_boot_weak_hash_enable(char *str)\n{\n\tdebug_boot_weak_hash = 1;\n\tpr_info(\"debug_boot_weak_hash enabled\\n\");\n\treturn 0;\n}\nearly_param(\"debug_boot_weak_hash\", debug_boot_weak_hash_enable);\n\nstatic bool filled_random_ptr_key __read_mostly;\nstatic siphash_key_t ptr_key __read_mostly;\n\nstatic int fill_ptr_key(struct notifier_block *nb, unsigned long action, void *data)\n{\n\tget_random_bytes(&ptr_key, sizeof(ptr_key));\n\n\t \n\tsmp_wmb();\n\tWRITE_ONCE(filled_random_ptr_key, true);\n\treturn NOTIFY_DONE;\n}\n\nstatic int __init vsprintf_init_hashval(void)\n{\n\tstatic struct notifier_block fill_ptr_key_nb = { .notifier_call = fill_ptr_key };\n\texecute_with_initialized_rng(&fill_ptr_key_nb);\n\treturn 0;\n}\nsubsys_initcall(vsprintf_init_hashval)\n\n \nstatic inline int __ptr_to_hashval(const void *ptr, unsigned long *hashval_out)\n{\n\tunsigned long hashval;\n\n\tif (!READ_ONCE(filled_random_ptr_key))\n\t\treturn -EBUSY;\n\n\t \n\tsmp_rmb();\n\n#ifdef CONFIG_64BIT\n\thashval = (unsigned long)siphash_1u64((u64)ptr, &ptr_key);\n\t \n\thashval = hashval & 0xffffffff;\n#else\n\thashval = (unsigned long)siphash_1u32((u32)ptr, &ptr_key);\n#endif\n\t*hashval_out = hashval;\n\treturn 0;\n}\n\nint ptr_to_hashval(const void *ptr, unsigned long *hashval_out)\n{\n\treturn __ptr_to_hashval(ptr, hashval_out);\n}\n\nstatic char *ptr_to_id(char *buf, char *end, const void *ptr,\n\t\t       struct printf_spec spec)\n{\n\tconst char *str = sizeof(ptr) == 8 ? \"(____ptrval____)\" : \"(ptrval)\";\n\tunsigned long hashval;\n\tint ret;\n\n\t \n\tif (IS_ERR_OR_NULL(ptr))\n\t\treturn pointer_string(buf, end, ptr, spec);\n\n\t \n\tif (unlikely(debug_boot_weak_hash)) {\n\t\thashval = hash_long((unsigned long)ptr, 32);\n\t\treturn pointer_string(buf, end, (const void *)hashval, spec);\n\t}\n\n\tret = __ptr_to_hashval(ptr, &hashval);\n\tif (ret) {\n\t\tspec.field_width = 2 * sizeof(ptr);\n\t\t \n\t\treturn error_string(buf, end, str, spec);\n\t}\n\n\treturn pointer_string(buf, end, (const void *)hashval, spec);\n}\n\nstatic char *default_pointer(char *buf, char *end, const void *ptr,\n\t\t\t     struct printf_spec spec)\n{\n\t \n\tif (unlikely(no_hash_pointers))\n\t\treturn pointer_string(buf, end, ptr, spec);\n\n\treturn ptr_to_id(buf, end, ptr, spec);\n}\n\nint kptr_restrict __read_mostly;\n\nstatic noinline_for_stack\nchar *restricted_pointer(char *buf, char *end, const void *ptr,\n\t\t\t struct printf_spec spec)\n{\n\tswitch (kptr_restrict) {\n\tcase 0:\n\t\t \n\t\treturn default_pointer(buf, end, ptr, spec);\n\tcase 1: {\n\t\tconst struct cred *cred;\n\n\t\t \n\t\tif (in_hardirq() || in_serving_softirq() || in_nmi()) {\n\t\t\tif (spec.field_width == -1)\n\t\t\t\tspec.field_width = 2 * sizeof(ptr);\n\t\t\treturn error_string(buf, end, \"pK-error\", spec);\n\t\t}\n\n\t\t \n\t\tcred = current_cred();\n\t\tif (!has_capability_noaudit(current, CAP_SYSLOG) ||\n\t\t    !uid_eq(cred->euid, cred->uid) ||\n\t\t    !gid_eq(cred->egid, cred->gid))\n\t\t\tptr = NULL;\n\t\tbreak;\n\t}\n\tcase 2:\n\tdefault:\n\t\t \n\t\tptr = NULL;\n\t\tbreak;\n\t}\n\n\treturn pointer_string(buf, end, ptr, spec);\n}\n\nstatic noinline_for_stack\nchar *dentry_name(char *buf, char *end, const struct dentry *d, struct printf_spec spec,\n\t\t  const char *fmt)\n{\n\tconst char *array[4], *s;\n\tconst struct dentry *p;\n\tint depth;\n\tint i, n;\n\n\tswitch (fmt[1]) {\n\t\tcase '2': case '3': case '4':\n\t\t\tdepth = fmt[1] - '0';\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdepth = 1;\n\t}\n\n\trcu_read_lock();\n\tfor (i = 0; i < depth; i++, d = p) {\n\t\tif (check_pointer(&buf, end, d, spec)) {\n\t\t\trcu_read_unlock();\n\t\t\treturn buf;\n\t\t}\n\n\t\tp = READ_ONCE(d->d_parent);\n\t\tarray[i] = READ_ONCE(d->d_name.name);\n\t\tif (p == d) {\n\t\t\tif (i)\n\t\t\t\tarray[i] = \"\";\n\t\t\ti++;\n\t\t\tbreak;\n\t\t}\n\t}\n\ts = array[--i];\n\tfor (n = 0; n != spec.precision; n++, buf++) {\n\t\tchar c = *s++;\n\t\tif (!c) {\n\t\t\tif (!i)\n\t\t\t\tbreak;\n\t\t\tc = '/';\n\t\t\ts = array[--i];\n\t\t}\n\t\tif (buf < end)\n\t\t\t*buf = c;\n\t}\n\trcu_read_unlock();\n\treturn widen_string(buf, n, end, spec);\n}\n\nstatic noinline_for_stack\nchar *file_dentry_name(char *buf, char *end, const struct file *f,\n\t\t\tstruct printf_spec spec, const char *fmt)\n{\n\tif (check_pointer(&buf, end, f, spec))\n\t\treturn buf;\n\n\treturn dentry_name(buf, end, f->f_path.dentry, spec, fmt);\n}\n#ifdef CONFIG_BLOCK\nstatic noinline_for_stack\nchar *bdev_name(char *buf, char *end, struct block_device *bdev,\n\t\tstruct printf_spec spec, const char *fmt)\n{\n\tstruct gendisk *hd;\n\n\tif (check_pointer(&buf, end, bdev, spec))\n\t\treturn buf;\n\n\thd = bdev->bd_disk;\n\tbuf = string(buf, end, hd->disk_name, spec);\n\tif (bdev->bd_partno) {\n\t\tif (isdigit(hd->disk_name[strlen(hd->disk_name)-1])) {\n\t\t\tif (buf < end)\n\t\t\t\t*buf = 'p';\n\t\t\tbuf++;\n\t\t}\n\t\tbuf = number(buf, end, bdev->bd_partno, spec);\n\t}\n\treturn buf;\n}\n#endif\n\nstatic noinline_for_stack\nchar *symbol_string(char *buf, char *end, void *ptr,\n\t\t    struct printf_spec spec, const char *fmt)\n{\n\tunsigned long value;\n#ifdef CONFIG_KALLSYMS\n\tchar sym[KSYM_SYMBOL_LEN];\n#endif\n\n\tif (fmt[1] == 'R')\n\t\tptr = __builtin_extract_return_addr(ptr);\n\tvalue = (unsigned long)ptr;\n\n#ifdef CONFIG_KALLSYMS\n\tif (*fmt == 'B' && fmt[1] == 'b')\n\t\tsprint_backtrace_build_id(sym, value);\n\telse if (*fmt == 'B')\n\t\tsprint_backtrace(sym, value);\n\telse if (*fmt == 'S' && (fmt[1] == 'b' || (fmt[1] == 'R' && fmt[2] == 'b')))\n\t\tsprint_symbol_build_id(sym, value);\n\telse if (*fmt != 's')\n\t\tsprint_symbol(sym, value);\n\telse\n\t\tsprint_symbol_no_offset(sym, value);\n\n\treturn string_nocheck(buf, end, sym, spec);\n#else\n\treturn special_hex_number(buf, end, value, sizeof(void *));\n#endif\n}\n\nstatic const struct printf_spec default_str_spec = {\n\t.field_width = -1,\n\t.precision = -1,\n};\n\nstatic const struct printf_spec default_flag_spec = {\n\t.base = 16,\n\t.precision = -1,\n\t.flags = SPECIAL | SMALL,\n};\n\nstatic const struct printf_spec default_dec_spec = {\n\t.base = 10,\n\t.precision = -1,\n};\n\nstatic const struct printf_spec default_dec02_spec = {\n\t.base = 10,\n\t.field_width = 2,\n\t.precision = -1,\n\t.flags = ZEROPAD,\n};\n\nstatic const struct printf_spec default_dec04_spec = {\n\t.base = 10,\n\t.field_width = 4,\n\t.precision = -1,\n\t.flags = ZEROPAD,\n};\n\nstatic noinline_for_stack\nchar *resource_string(char *buf, char *end, struct resource *res,\n\t\t      struct printf_spec spec, const char *fmt)\n{\n#ifndef IO_RSRC_PRINTK_SIZE\n#define IO_RSRC_PRINTK_SIZE\t6\n#endif\n\n#ifndef MEM_RSRC_PRINTK_SIZE\n#define MEM_RSRC_PRINTK_SIZE\t10\n#endif\n\tstatic const struct printf_spec io_spec = {\n\t\t.base = 16,\n\t\t.field_width = IO_RSRC_PRINTK_SIZE,\n\t\t.precision = -1,\n\t\t.flags = SPECIAL | SMALL | ZEROPAD,\n\t};\n\tstatic const struct printf_spec mem_spec = {\n\t\t.base = 16,\n\t\t.field_width = MEM_RSRC_PRINTK_SIZE,\n\t\t.precision = -1,\n\t\t.flags = SPECIAL | SMALL | ZEROPAD,\n\t};\n\tstatic const struct printf_spec bus_spec = {\n\t\t.base = 16,\n\t\t.field_width = 2,\n\t\t.precision = -1,\n\t\t.flags = SMALL | ZEROPAD,\n\t};\n\tstatic const struct printf_spec str_spec = {\n\t\t.field_width = -1,\n\t\t.precision = 10,\n\t\t.flags = LEFT,\n\t};\n\n\t \n#define RSRC_BUF_SIZE\t\t((2 * sizeof(resource_size_t)) + 4)\n#define FLAG_BUF_SIZE\t\t(2 * sizeof(res->flags))\n#define DECODED_BUF_SIZE\tsizeof(\"[mem - 64bit pref window disabled]\")\n#define RAW_BUF_SIZE\t\tsizeof(\"[mem - flags 0x]\")\n\tchar sym[max(2*RSRC_BUF_SIZE + DECODED_BUF_SIZE,\n\t\t     2*RSRC_BUF_SIZE + FLAG_BUF_SIZE + RAW_BUF_SIZE)];\n\n\tchar *p = sym, *pend = sym + sizeof(sym);\n\tint decode = (fmt[0] == 'R') ? 1 : 0;\n\tconst struct printf_spec *specp;\n\n\tif (check_pointer(&buf, end, res, spec))\n\t\treturn buf;\n\n\t*p++ = '[';\n\tif (res->flags & IORESOURCE_IO) {\n\t\tp = string_nocheck(p, pend, \"io  \", str_spec);\n\t\tspecp = &io_spec;\n\t} else if (res->flags & IORESOURCE_MEM) {\n\t\tp = string_nocheck(p, pend, \"mem \", str_spec);\n\t\tspecp = &mem_spec;\n\t} else if (res->flags & IORESOURCE_IRQ) {\n\t\tp = string_nocheck(p, pend, \"irq \", str_spec);\n\t\tspecp = &default_dec_spec;\n\t} else if (res->flags & IORESOURCE_DMA) {\n\t\tp = string_nocheck(p, pend, \"dma \", str_spec);\n\t\tspecp = &default_dec_spec;\n\t} else if (res->flags & IORESOURCE_BUS) {\n\t\tp = string_nocheck(p, pend, \"bus \", str_spec);\n\t\tspecp = &bus_spec;\n\t} else {\n\t\tp = string_nocheck(p, pend, \"??? \", str_spec);\n\t\tspecp = &mem_spec;\n\t\tdecode = 0;\n\t}\n\tif (decode && res->flags & IORESOURCE_UNSET) {\n\t\tp = string_nocheck(p, pend, \"size \", str_spec);\n\t\tp = number(p, pend, resource_size(res), *specp);\n\t} else {\n\t\tp = number(p, pend, res->start, *specp);\n\t\tif (res->start != res->end) {\n\t\t\t*p++ = '-';\n\t\t\tp = number(p, pend, res->end, *specp);\n\t\t}\n\t}\n\tif (decode) {\n\t\tif (res->flags & IORESOURCE_MEM_64)\n\t\t\tp = string_nocheck(p, pend, \" 64bit\", str_spec);\n\t\tif (res->flags & IORESOURCE_PREFETCH)\n\t\t\tp = string_nocheck(p, pend, \" pref\", str_spec);\n\t\tif (res->flags & IORESOURCE_WINDOW)\n\t\t\tp = string_nocheck(p, pend, \" window\", str_spec);\n\t\tif (res->flags & IORESOURCE_DISABLED)\n\t\t\tp = string_nocheck(p, pend, \" disabled\", str_spec);\n\t} else {\n\t\tp = string_nocheck(p, pend, \" flags \", str_spec);\n\t\tp = number(p, pend, res->flags, default_flag_spec);\n\t}\n\t*p++ = ']';\n\t*p = '\\0';\n\n\treturn string_nocheck(buf, end, sym, spec);\n}\n\nstatic noinline_for_stack\nchar *hex_string(char *buf, char *end, u8 *addr, struct printf_spec spec,\n\t\t const char *fmt)\n{\n\tint i, len = 1;\t\t \n\tchar separator;\n\n\tif (spec.field_width == 0)\n\t\t \n\t\treturn buf;\n\n\tif (check_pointer(&buf, end, addr, spec))\n\t\treturn buf;\n\n\tswitch (fmt[1]) {\n\tcase 'C':\n\t\tseparator = ':';\n\t\tbreak;\n\tcase 'D':\n\t\tseparator = '-';\n\t\tbreak;\n\tcase 'N':\n\t\tseparator = 0;\n\t\tbreak;\n\tdefault:\n\t\tseparator = ' ';\n\t\tbreak;\n\t}\n\n\tif (spec.field_width > 0)\n\t\tlen = min_t(int, spec.field_width, 64);\n\n\tfor (i = 0; i < len; ++i) {\n\t\tif (buf < end)\n\t\t\t*buf = hex_asc_hi(addr[i]);\n\t\t++buf;\n\t\tif (buf < end)\n\t\t\t*buf = hex_asc_lo(addr[i]);\n\t\t++buf;\n\n\t\tif (separator && i != len - 1) {\n\t\t\tif (buf < end)\n\t\t\t\t*buf = separator;\n\t\t\t++buf;\n\t\t}\n\t}\n\n\treturn buf;\n}\n\nstatic noinline_for_stack\nchar *bitmap_string(char *buf, char *end, const unsigned long *bitmap,\n\t\t    struct printf_spec spec, const char *fmt)\n{\n\tconst int CHUNKSZ = 32;\n\tint nr_bits = max_t(int, spec.field_width, 0);\n\tint i, chunksz;\n\tbool first = true;\n\n\tif (check_pointer(&buf, end, bitmap, spec))\n\t\treturn buf;\n\n\t \n\tspec = (struct printf_spec){ .flags = SMALL | ZEROPAD, .base = 16 };\n\n\tchunksz = nr_bits & (CHUNKSZ - 1);\n\tif (chunksz == 0)\n\t\tchunksz = CHUNKSZ;\n\n\ti = ALIGN(nr_bits, CHUNKSZ) - CHUNKSZ;\n\tfor (; i >= 0; i -= CHUNKSZ) {\n\t\tu32 chunkmask, val;\n\t\tint word, bit;\n\n\t\tchunkmask = ((1ULL << chunksz) - 1);\n\t\tword = i / BITS_PER_LONG;\n\t\tbit = i % BITS_PER_LONG;\n\t\tval = (bitmap[word] >> bit) & chunkmask;\n\n\t\tif (!first) {\n\t\t\tif (buf < end)\n\t\t\t\t*buf = ',';\n\t\t\tbuf++;\n\t\t}\n\t\tfirst = false;\n\n\t\tspec.field_width = DIV_ROUND_UP(chunksz, 4);\n\t\tbuf = number(buf, end, val, spec);\n\n\t\tchunksz = CHUNKSZ;\n\t}\n\treturn buf;\n}\n\nstatic noinline_for_stack\nchar *bitmap_list_string(char *buf, char *end, const unsigned long *bitmap,\n\t\t\t struct printf_spec spec, const char *fmt)\n{\n\tint nr_bits = max_t(int, spec.field_width, 0);\n\tbool first = true;\n\tint rbot, rtop;\n\n\tif (check_pointer(&buf, end, bitmap, spec))\n\t\treturn buf;\n\n\tfor_each_set_bitrange(rbot, rtop, bitmap, nr_bits) {\n\t\tif (!first) {\n\t\t\tif (buf < end)\n\t\t\t\t*buf = ',';\n\t\t\tbuf++;\n\t\t}\n\t\tfirst = false;\n\n\t\tbuf = number(buf, end, rbot, default_dec_spec);\n\t\tif (rtop == rbot + 1)\n\t\t\tcontinue;\n\n\t\tif (buf < end)\n\t\t\t*buf = '-';\n\t\tbuf = number(++buf, end, rtop - 1, default_dec_spec);\n\t}\n\treturn buf;\n}\n\nstatic noinline_for_stack\nchar *mac_address_string(char *buf, char *end, u8 *addr,\n\t\t\t struct printf_spec spec, const char *fmt)\n{\n\tchar mac_addr[sizeof(\"xx:xx:xx:xx:xx:xx\")];\n\tchar *p = mac_addr;\n\tint i;\n\tchar separator;\n\tbool reversed = false;\n\n\tif (check_pointer(&buf, end, addr, spec))\n\t\treturn buf;\n\n\tswitch (fmt[1]) {\n\tcase 'F':\n\t\tseparator = '-';\n\t\tbreak;\n\n\tcase 'R':\n\t\treversed = true;\n\t\tfallthrough;\n\n\tdefault:\n\t\tseparator = ':';\n\t\tbreak;\n\t}\n\n\tfor (i = 0; i < 6; i++) {\n\t\tif (reversed)\n\t\t\tp = hex_byte_pack(p, addr[5 - i]);\n\t\telse\n\t\t\tp = hex_byte_pack(p, addr[i]);\n\n\t\tif (fmt[0] == 'M' && i != 5)\n\t\t\t*p++ = separator;\n\t}\n\t*p = '\\0';\n\n\treturn string_nocheck(buf, end, mac_addr, spec);\n}\n\nstatic noinline_for_stack\nchar *ip4_string(char *p, const u8 *addr, const char *fmt)\n{\n\tint i;\n\tbool leading_zeros = (fmt[0] == 'i');\n\tint index;\n\tint step;\n\n\tswitch (fmt[2]) {\n\tcase 'h':\n#ifdef __BIG_ENDIAN\n\t\tindex = 0;\n\t\tstep = 1;\n#else\n\t\tindex = 3;\n\t\tstep = -1;\n#endif\n\t\tbreak;\n\tcase 'l':\n\t\tindex = 3;\n\t\tstep = -1;\n\t\tbreak;\n\tcase 'n':\n\tcase 'b':\n\tdefault:\n\t\tindex = 0;\n\t\tstep = 1;\n\t\tbreak;\n\t}\n\tfor (i = 0; i < 4; i++) {\n\t\tchar temp[4] __aligned(2);\t \n\t\tint digits = put_dec_trunc8(temp, addr[index]) - temp;\n\t\tif (leading_zeros) {\n\t\t\tif (digits < 3)\n\t\t\t\t*p++ = '0';\n\t\t\tif (digits < 2)\n\t\t\t\t*p++ = '0';\n\t\t}\n\t\t \n\t\twhile (digits--)\n\t\t\t*p++ = temp[digits];\n\t\tif (i < 3)\n\t\t\t*p++ = '.';\n\t\tindex += step;\n\t}\n\t*p = '\\0';\n\n\treturn p;\n}\n\nstatic noinline_for_stack\nchar *ip6_compressed_string(char *p, const char *addr)\n{\n\tint i, j, range;\n\tunsigned char zerolength[8];\n\tint longest = 1;\n\tint colonpos = -1;\n\tu16 word;\n\tu8 hi, lo;\n\tbool needcolon = false;\n\tbool useIPv4;\n\tstruct in6_addr in6;\n\n\tmemcpy(&in6, addr, sizeof(struct in6_addr));\n\n\tuseIPv4 = ipv6_addr_v4mapped(&in6) || ipv6_addr_is_isatap(&in6);\n\n\tmemset(zerolength, 0, sizeof(zerolength));\n\n\tif (useIPv4)\n\t\trange = 6;\n\telse\n\t\trange = 8;\n\n\t \n\tfor (i = 0; i < range; i++) {\n\t\tfor (j = i; j < range; j++) {\n\t\t\tif (in6.s6_addr16[j] != 0)\n\t\t\t\tbreak;\n\t\t\tzerolength[i]++;\n\t\t}\n\t}\n\tfor (i = 0; i < range; i++) {\n\t\tif (zerolength[i] > longest) {\n\t\t\tlongest = zerolength[i];\n\t\t\tcolonpos = i;\n\t\t}\n\t}\n\tif (longest == 1)\t\t \n\t\tcolonpos = -1;\n\n\t \n\tfor (i = 0; i < range; i++) {\n\t\tif (i == colonpos) {\n\t\t\tif (needcolon || i == 0)\n\t\t\t\t*p++ = ':';\n\t\t\t*p++ = ':';\n\t\t\tneedcolon = false;\n\t\t\ti += longest - 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (needcolon) {\n\t\t\t*p++ = ':';\n\t\t\tneedcolon = false;\n\t\t}\n\t\t \n\t\tword = ntohs(in6.s6_addr16[i]);\n\t\thi = word >> 8;\n\t\tlo = word & 0xff;\n\t\tif (hi) {\n\t\t\tif (hi > 0x0f)\n\t\t\t\tp = hex_byte_pack(p, hi);\n\t\t\telse\n\t\t\t\t*p++ = hex_asc_lo(hi);\n\t\t\tp = hex_byte_pack(p, lo);\n\t\t}\n\t\telse if (lo > 0x0f)\n\t\t\tp = hex_byte_pack(p, lo);\n\t\telse\n\t\t\t*p++ = hex_asc_lo(lo);\n\t\tneedcolon = true;\n\t}\n\n\tif (useIPv4) {\n\t\tif (needcolon)\n\t\t\t*p++ = ':';\n\t\tp = ip4_string(p, &in6.s6_addr[12], \"I4\");\n\t}\n\t*p = '\\0';\n\n\treturn p;\n}\n\nstatic noinline_for_stack\nchar *ip6_string(char *p, const char *addr, const char *fmt)\n{\n\tint i;\n\n\tfor (i = 0; i < 8; i++) {\n\t\tp = hex_byte_pack(p, *addr++);\n\t\tp = hex_byte_pack(p, *addr++);\n\t\tif (fmt[0] == 'I' && i != 7)\n\t\t\t*p++ = ':';\n\t}\n\t*p = '\\0';\n\n\treturn p;\n}\n\nstatic noinline_for_stack\nchar *ip6_addr_string(char *buf, char *end, const u8 *addr,\n\t\t      struct printf_spec spec, const char *fmt)\n{\n\tchar ip6_addr[sizeof(\"xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:255.255.255.255\")];\n\n\tif (fmt[0] == 'I' && fmt[2] == 'c')\n\t\tip6_compressed_string(ip6_addr, addr);\n\telse\n\t\tip6_string(ip6_addr, addr, fmt);\n\n\treturn string_nocheck(buf, end, ip6_addr, spec);\n}\n\nstatic noinline_for_stack\nchar *ip4_addr_string(char *buf, char *end, const u8 *addr,\n\t\t      struct printf_spec spec, const char *fmt)\n{\n\tchar ip4_addr[sizeof(\"255.255.255.255\")];\n\n\tip4_string(ip4_addr, addr, fmt);\n\n\treturn string_nocheck(buf, end, ip4_addr, spec);\n}\n\nstatic noinline_for_stack\nchar *ip6_addr_string_sa(char *buf, char *end, const struct sockaddr_in6 *sa,\n\t\t\t struct printf_spec spec, const char *fmt)\n{\n\tbool have_p = false, have_s = false, have_f = false, have_c = false;\n\tchar ip6_addr[sizeof(\"[xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:255.255.255.255]\") +\n\t\t      sizeof(\":12345\") + sizeof(\"/123456789\") +\n\t\t      sizeof(\"%1234567890\")];\n\tchar *p = ip6_addr, *pend = ip6_addr + sizeof(ip6_addr);\n\tconst u8 *addr = (const u8 *) &sa->sin6_addr;\n\tchar fmt6[2] = { fmt[0], '6' };\n\tu8 off = 0;\n\n\tfmt++;\n\twhile (isalpha(*++fmt)) {\n\t\tswitch (*fmt) {\n\t\tcase 'p':\n\t\t\thave_p = true;\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\thave_f = true;\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\thave_s = true;\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\thave_c = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (have_p || have_s || have_f) {\n\t\t*p = '[';\n\t\toff = 1;\n\t}\n\n\tif (fmt6[0] == 'I' && have_c)\n\t\tp = ip6_compressed_string(ip6_addr + off, addr);\n\telse\n\t\tp = ip6_string(ip6_addr + off, addr, fmt6);\n\n\tif (have_p || have_s || have_f)\n\t\t*p++ = ']';\n\n\tif (have_p) {\n\t\t*p++ = ':';\n\t\tp = number(p, pend, ntohs(sa->sin6_port), spec);\n\t}\n\tif (have_f) {\n\t\t*p++ = '/';\n\t\tp = number(p, pend, ntohl(sa->sin6_flowinfo &\n\t\t\t\t\t  IPV6_FLOWINFO_MASK), spec);\n\t}\n\tif (have_s) {\n\t\t*p++ = '%';\n\t\tp = number(p, pend, sa->sin6_scope_id, spec);\n\t}\n\t*p = '\\0';\n\n\treturn string_nocheck(buf, end, ip6_addr, spec);\n}\n\nstatic noinline_for_stack\nchar *ip4_addr_string_sa(char *buf, char *end, const struct sockaddr_in *sa,\n\t\t\t struct printf_spec spec, const char *fmt)\n{\n\tbool have_p = false;\n\tchar *p, ip4_addr[sizeof(\"255.255.255.255\") + sizeof(\":12345\")];\n\tchar *pend = ip4_addr + sizeof(ip4_addr);\n\tconst u8 *addr = (const u8 *) &sa->sin_addr.s_addr;\n\tchar fmt4[3] = { fmt[0], '4', 0 };\n\n\tfmt++;\n\twhile (isalpha(*++fmt)) {\n\t\tswitch (*fmt) {\n\t\tcase 'p':\n\t\t\thave_p = true;\n\t\t\tbreak;\n\t\tcase 'h':\n\t\tcase 'l':\n\t\tcase 'n':\n\t\tcase 'b':\n\t\t\tfmt4[2] = *fmt;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tp = ip4_string(ip4_addr, addr, fmt4);\n\tif (have_p) {\n\t\t*p++ = ':';\n\t\tp = number(p, pend, ntohs(sa->sin_port), spec);\n\t}\n\t*p = '\\0';\n\n\treturn string_nocheck(buf, end, ip4_addr, spec);\n}\n\nstatic noinline_for_stack\nchar *ip_addr_string(char *buf, char *end, const void *ptr,\n\t\t     struct printf_spec spec, const char *fmt)\n{\n\tchar *err_fmt_msg;\n\n\tif (check_pointer(&buf, end, ptr, spec))\n\t\treturn buf;\n\n\tswitch (fmt[1]) {\n\tcase '6':\n\t\treturn ip6_addr_string(buf, end, ptr, spec, fmt);\n\tcase '4':\n\t\treturn ip4_addr_string(buf, end, ptr, spec, fmt);\n\tcase 'S': {\n\t\tconst union {\n\t\t\tstruct sockaddr\t\traw;\n\t\t\tstruct sockaddr_in\tv4;\n\t\t\tstruct sockaddr_in6\tv6;\n\t\t} *sa = ptr;\n\n\t\tswitch (sa->raw.sa_family) {\n\t\tcase AF_INET:\n\t\t\treturn ip4_addr_string_sa(buf, end, &sa->v4, spec, fmt);\n\t\tcase AF_INET6:\n\t\t\treturn ip6_addr_string_sa(buf, end, &sa->v6, spec, fmt);\n\t\tdefault:\n\t\t\treturn error_string(buf, end, \"(einval)\", spec);\n\t\t}}\n\t}\n\n\terr_fmt_msg = fmt[0] == 'i' ? \"(%pi?)\" : \"(%pI?)\";\n\treturn error_string(buf, end, err_fmt_msg, spec);\n}\n\nstatic noinline_for_stack\nchar *escaped_string(char *buf, char *end, u8 *addr, struct printf_spec spec,\n\t\t     const char *fmt)\n{\n\tbool found = true;\n\tint count = 1;\n\tunsigned int flags = 0;\n\tint len;\n\n\tif (spec.field_width == 0)\n\t\treturn buf;\t\t\t\t \n\n\tif (check_pointer(&buf, end, addr, spec))\n\t\treturn buf;\n\n\tdo {\n\t\tswitch (fmt[count++]) {\n\t\tcase 'a':\n\t\t\tflags |= ESCAPE_ANY;\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\tflags |= ESCAPE_SPECIAL;\n\t\t\tbreak;\n\t\tcase 'h':\n\t\t\tflags |= ESCAPE_HEX;\n\t\t\tbreak;\n\t\tcase 'n':\n\t\t\tflags |= ESCAPE_NULL;\n\t\t\tbreak;\n\t\tcase 'o':\n\t\t\tflags |= ESCAPE_OCTAL;\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\tflags |= ESCAPE_NP;\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tflags |= ESCAPE_SPACE;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfound = false;\n\t\t\tbreak;\n\t\t}\n\t} while (found);\n\n\tif (!flags)\n\t\tflags = ESCAPE_ANY_NP;\n\n\tlen = spec.field_width < 0 ? 1 : spec.field_width;\n\n\t \n\tbuf += string_escape_mem(addr, len, buf, buf < end ? end - buf : 0, flags, NULL);\n\n\treturn buf;\n}\n\nstatic char *va_format(char *buf, char *end, struct va_format *va_fmt,\n\t\t       struct printf_spec spec, const char *fmt)\n{\n\tva_list va;\n\n\tif (check_pointer(&buf, end, va_fmt, spec))\n\t\treturn buf;\n\n\tva_copy(va, *va_fmt->va);\n\tbuf += vsnprintf(buf, end > buf ? end - buf : 0, va_fmt->fmt, va);\n\tva_end(va);\n\n\treturn buf;\n}\n\nstatic noinline_for_stack\nchar *uuid_string(char *buf, char *end, const u8 *addr,\n\t\t  struct printf_spec spec, const char *fmt)\n{\n\tchar uuid[UUID_STRING_LEN + 1];\n\tchar *p = uuid;\n\tint i;\n\tconst u8 *index = uuid_index;\n\tbool uc = false;\n\n\tif (check_pointer(&buf, end, addr, spec))\n\t\treturn buf;\n\n\tswitch (*(++fmt)) {\n\tcase 'L':\n\t\tuc = true;\n\t\tfallthrough;\n\tcase 'l':\n\t\tindex = guid_index;\n\t\tbreak;\n\tcase 'B':\n\t\tuc = true;\n\t\tbreak;\n\t}\n\n\tfor (i = 0; i < 16; i++) {\n\t\tif (uc)\n\t\t\tp = hex_byte_pack_upper(p, addr[index[i]]);\n\t\telse\n\t\t\tp = hex_byte_pack(p, addr[index[i]]);\n\t\tswitch (i) {\n\t\tcase 3:\n\t\tcase 5:\n\t\tcase 7:\n\t\tcase 9:\n\t\t\t*p++ = '-';\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t*p = 0;\n\n\treturn string_nocheck(buf, end, uuid, spec);\n}\n\nstatic noinline_for_stack\nchar *netdev_bits(char *buf, char *end, const void *addr,\n\t\t  struct printf_spec spec,  const char *fmt)\n{\n\tunsigned long long num;\n\tint size;\n\n\tif (check_pointer(&buf, end, addr, spec))\n\t\treturn buf;\n\n\tswitch (fmt[1]) {\n\tcase 'F':\n\t\tnum = *(const netdev_features_t *)addr;\n\t\tsize = sizeof(netdev_features_t);\n\t\tbreak;\n\tdefault:\n\t\treturn error_string(buf, end, \"(%pN?)\", spec);\n\t}\n\n\treturn special_hex_number(buf, end, num, size);\n}\n\nstatic noinline_for_stack\nchar *fourcc_string(char *buf, char *end, const u32 *fourcc,\n\t\t    struct printf_spec spec, const char *fmt)\n{\n\tchar output[sizeof(\"0123 little-endian (0x01234567)\")];\n\tchar *p = output;\n\tunsigned int i;\n\tu32 orig, val;\n\n\tif (fmt[1] != 'c' || fmt[2] != 'c')\n\t\treturn error_string(buf, end, \"(%p4?)\", spec);\n\n\tif (check_pointer(&buf, end, fourcc, spec))\n\t\treturn buf;\n\n\torig = get_unaligned(fourcc);\n\tval = orig & ~BIT(31);\n\n\tfor (i = 0; i < sizeof(u32); i++) {\n\t\tunsigned char c = val >> (i * 8);\n\n\t\t \n\t\t*p++ = isascii(c) && isprint(c) ? c : '.';\n\t}\n\n\t*p++ = ' ';\n\tstrcpy(p, orig & BIT(31) ? \"big-endian\" : \"little-endian\");\n\tp += strlen(p);\n\n\t*p++ = ' ';\n\t*p++ = '(';\n\tp = special_hex_number(p, output + sizeof(output) - 2, orig, sizeof(u32));\n\t*p++ = ')';\n\t*p = '\\0';\n\n\treturn string(buf, end, output, spec);\n}\n\nstatic noinline_for_stack\nchar *address_val(char *buf, char *end, const void *addr,\n\t\t  struct printf_spec spec, const char *fmt)\n{\n\tunsigned long long num;\n\tint size;\n\n\tif (check_pointer(&buf, end, addr, spec))\n\t\treturn buf;\n\n\tswitch (fmt[1]) {\n\tcase 'd':\n\t\tnum = *(const dma_addr_t *)addr;\n\t\tsize = sizeof(dma_addr_t);\n\t\tbreak;\n\tcase 'p':\n\tdefault:\n\t\tnum = *(const phys_addr_t *)addr;\n\t\tsize = sizeof(phys_addr_t);\n\t\tbreak;\n\t}\n\n\treturn special_hex_number(buf, end, num, size);\n}\n\nstatic noinline_for_stack\nchar *date_str(char *buf, char *end, const struct rtc_time *tm, bool r)\n{\n\tint year = tm->tm_year + (r ? 0 : 1900);\n\tint mon = tm->tm_mon + (r ? 0 : 1);\n\n\tbuf = number(buf, end, year, default_dec04_spec);\n\tif (buf < end)\n\t\t*buf = '-';\n\tbuf++;\n\n\tbuf = number(buf, end, mon, default_dec02_spec);\n\tif (buf < end)\n\t\t*buf = '-';\n\tbuf++;\n\n\treturn number(buf, end, tm->tm_mday, default_dec02_spec);\n}\n\nstatic noinline_for_stack\nchar *time_str(char *buf, char *end, const struct rtc_time *tm, bool r)\n{\n\tbuf = number(buf, end, tm->tm_hour, default_dec02_spec);\n\tif (buf < end)\n\t\t*buf = ':';\n\tbuf++;\n\n\tbuf = number(buf, end, tm->tm_min, default_dec02_spec);\n\tif (buf < end)\n\t\t*buf = ':';\n\tbuf++;\n\n\treturn number(buf, end, tm->tm_sec, default_dec02_spec);\n}\n\nstatic noinline_for_stack\nchar *rtc_str(char *buf, char *end, const struct rtc_time *tm,\n\t      struct printf_spec spec, const char *fmt)\n{\n\tbool have_t = true, have_d = true;\n\tbool raw = false, iso8601_separator = true;\n\tbool found = true;\n\tint count = 2;\n\n\tif (check_pointer(&buf, end, tm, spec))\n\t\treturn buf;\n\n\tswitch (fmt[count]) {\n\tcase 'd':\n\t\thave_t = false;\n\t\tcount++;\n\t\tbreak;\n\tcase 't':\n\t\thave_d = false;\n\t\tcount++;\n\t\tbreak;\n\t}\n\n\tdo {\n\t\tswitch (fmt[count++]) {\n\t\tcase 'r':\n\t\t\traw = true;\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tiso8601_separator = false;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfound = false;\n\t\t\tbreak;\n\t\t}\n\t} while (found);\n\n\tif (have_d)\n\t\tbuf = date_str(buf, end, tm, raw);\n\tif (have_d && have_t) {\n\t\tif (buf < end)\n\t\t\t*buf = iso8601_separator ? 'T' : ' ';\n\t\tbuf++;\n\t}\n\tif (have_t)\n\t\tbuf = time_str(buf, end, tm, raw);\n\n\treturn buf;\n}\n\nstatic noinline_for_stack\nchar *time64_str(char *buf, char *end, const time64_t time,\n\t\t struct printf_spec spec, const char *fmt)\n{\n\tstruct rtc_time rtc_time;\n\tstruct tm tm;\n\n\ttime64_to_tm(time, 0, &tm);\n\n\trtc_time.tm_sec = tm.tm_sec;\n\trtc_time.tm_min = tm.tm_min;\n\trtc_time.tm_hour = tm.tm_hour;\n\trtc_time.tm_mday = tm.tm_mday;\n\trtc_time.tm_mon = tm.tm_mon;\n\trtc_time.tm_year = tm.tm_year;\n\trtc_time.tm_wday = tm.tm_wday;\n\trtc_time.tm_yday = tm.tm_yday;\n\n\trtc_time.tm_isdst = 0;\n\n\treturn rtc_str(buf, end, &rtc_time, spec, fmt);\n}\n\nstatic noinline_for_stack\nchar *time_and_date(char *buf, char *end, void *ptr, struct printf_spec spec,\n\t\t    const char *fmt)\n{\n\tswitch (fmt[1]) {\n\tcase 'R':\n\t\treturn rtc_str(buf, end, (const struct rtc_time *)ptr, spec, fmt);\n\tcase 'T':\n\t\treturn time64_str(buf, end, *(const time64_t *)ptr, spec, fmt);\n\tdefault:\n\t\treturn error_string(buf, end, \"(%pt?)\", spec);\n\t}\n}\n\nstatic noinline_for_stack\nchar *clock(char *buf, char *end, struct clk *clk, struct printf_spec spec,\n\t    const char *fmt)\n{\n\tif (!IS_ENABLED(CONFIG_HAVE_CLK))\n\t\treturn error_string(buf, end, \"(%pC?)\", spec);\n\n\tif (check_pointer(&buf, end, clk, spec))\n\t\treturn buf;\n\n\tswitch (fmt[1]) {\n\tcase 'n':\n\tdefault:\n#ifdef CONFIG_COMMON_CLK\n\t\treturn string(buf, end, __clk_get_name(clk), spec);\n#else\n\t\treturn ptr_to_id(buf, end, clk, spec);\n#endif\n\t}\n}\n\nstatic\nchar *format_flags(char *buf, char *end, unsigned long flags,\n\t\t\t\t\tconst struct trace_print_flags *names)\n{\n\tunsigned long mask;\n\n\tfor ( ; flags && names->name; names++) {\n\t\tmask = names->mask;\n\t\tif ((flags & mask) != mask)\n\t\t\tcontinue;\n\n\t\tbuf = string(buf, end, names->name, default_str_spec);\n\n\t\tflags &= ~mask;\n\t\tif (flags) {\n\t\t\tif (buf < end)\n\t\t\t\t*buf = '|';\n\t\t\tbuf++;\n\t\t}\n\t}\n\n\tif (flags)\n\t\tbuf = number(buf, end, flags, default_flag_spec);\n\n\treturn buf;\n}\n\nstruct page_flags_fields {\n\tint width;\n\tint shift;\n\tint mask;\n\tconst struct printf_spec *spec;\n\tconst char *name;\n};\n\nstatic const struct page_flags_fields pff[] = {\n\t{SECTIONS_WIDTH, SECTIONS_PGSHIFT, SECTIONS_MASK,\n\t &default_dec_spec, \"section\"},\n\t{NODES_WIDTH, NODES_PGSHIFT, NODES_MASK,\n\t &default_dec_spec, \"node\"},\n\t{ZONES_WIDTH, ZONES_PGSHIFT, ZONES_MASK,\n\t &default_dec_spec, \"zone\"},\n\t{LAST_CPUPID_WIDTH, LAST_CPUPID_PGSHIFT, LAST_CPUPID_MASK,\n\t &default_flag_spec, \"lastcpupid\"},\n\t{KASAN_TAG_WIDTH, KASAN_TAG_PGSHIFT, KASAN_TAG_MASK,\n\t &default_flag_spec, \"kasantag\"},\n};\n\nstatic\nchar *format_page_flags(char *buf, char *end, unsigned long flags)\n{\n\tunsigned long main_flags = flags & PAGEFLAGS_MASK;\n\tbool append = false;\n\tint i;\n\n\tbuf = number(buf, end, flags, default_flag_spec);\n\tif (buf < end)\n\t\t*buf = '(';\n\tbuf++;\n\n\t \n\tif (main_flags) {\n\t\tbuf = format_flags(buf, end, main_flags, pageflag_names);\n\t\tappend = true;\n\t}\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(pff); i++) {\n\t\t \n\t\tif (!pff[i].width)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (append) {\n\t\t\tif (buf < end)\n\t\t\t\t*buf = '|';\n\t\t\tbuf++;\n\t\t}\n\n\t\tbuf = string(buf, end, pff[i].name, default_str_spec);\n\t\tif (buf < end)\n\t\t\t*buf = '=';\n\t\tbuf++;\n\t\tbuf = number(buf, end, (flags >> pff[i].shift) & pff[i].mask,\n\t\t\t     *pff[i].spec);\n\n\t\tappend = true;\n\t}\n\tif (buf < end)\n\t\t*buf = ')';\n\tbuf++;\n\n\treturn buf;\n}\n\nstatic\nchar *format_page_type(char *buf, char *end, unsigned int page_type)\n{\n\tbuf = number(buf, end, page_type, default_flag_spec);\n\n\tif (buf < end)\n\t\t*buf = '(';\n\tbuf++;\n\n\tif (page_type_has_type(page_type))\n\t\tbuf = format_flags(buf, end, ~page_type, pagetype_names);\n\n\tif (buf < end)\n\t\t*buf = ')';\n\tbuf++;\n\n\treturn buf;\n}\n\nstatic noinline_for_stack\nchar *flags_string(char *buf, char *end, void *flags_ptr,\n\t\t   struct printf_spec spec, const char *fmt)\n{\n\tunsigned long flags;\n\tconst struct trace_print_flags *names;\n\n\tif (check_pointer(&buf, end, flags_ptr, spec))\n\t\treturn buf;\n\n\tswitch (fmt[1]) {\n\tcase 'p':\n\t\treturn format_page_flags(buf, end, *(unsigned long *)flags_ptr);\n\tcase 't':\n\t\treturn format_page_type(buf, end, *(unsigned int *)flags_ptr);\n\tcase 'v':\n\t\tflags = *(unsigned long *)flags_ptr;\n\t\tnames = vmaflag_names;\n\t\tbreak;\n\tcase 'g':\n\t\tflags = (__force unsigned long)(*(gfp_t *)flags_ptr);\n\t\tnames = gfpflag_names;\n\t\tbreak;\n\tdefault:\n\t\treturn error_string(buf, end, \"(%pG?)\", spec);\n\t}\n\n\treturn format_flags(buf, end, flags, names);\n}\n\nstatic noinline_for_stack\nchar *fwnode_full_name_string(struct fwnode_handle *fwnode, char *buf,\n\t\t\t      char *end)\n{\n\tint depth;\n\n\t \n\tfor (depth = fwnode_count_parents(fwnode); depth >= 0; depth--) {\n\t\t \n\t\tstruct fwnode_handle *__fwnode = depth ?\n\t\t\tfwnode_get_nth_parent(fwnode, depth) : fwnode;\n\n\t\tbuf = string(buf, end, fwnode_get_name_prefix(__fwnode),\n\t\t\t     default_str_spec);\n\t\tbuf = string(buf, end, fwnode_get_name(__fwnode),\n\t\t\t     default_str_spec);\n\n\t\tif (depth)\n\t\t\tfwnode_handle_put(__fwnode);\n\t}\n\n\treturn buf;\n}\n\nstatic noinline_for_stack\nchar *device_node_string(char *buf, char *end, struct device_node *dn,\n\t\t\t struct printf_spec spec, const char *fmt)\n{\n\tchar tbuf[sizeof(\"xxxx\") + 1];\n\tconst char *p;\n\tint ret;\n\tchar *buf_start = buf;\n\tstruct property *prop;\n\tbool has_mult, pass;\n\n\tstruct printf_spec str_spec = spec;\n\tstr_spec.field_width = -1;\n\n\tif (fmt[0] != 'F')\n\t\treturn error_string(buf, end, \"(%pO?)\", spec);\n\n\tif (!IS_ENABLED(CONFIG_OF))\n\t\treturn error_string(buf, end, \"(%pOF?)\", spec);\n\n\tif (check_pointer(&buf, end, dn, spec))\n\t\treturn buf;\n\n\t \n\tfmt++;\n\tif (fmt[0] == '\\0' || strcspn(fmt,\"fnpPFcC\") > 0)\n\t\tfmt = \"f\";\n\n\tfor (pass = false; strspn(fmt,\"fnpPFcC\"); fmt++, pass = true) {\n\t\tint precision;\n\t\tif (pass) {\n\t\t\tif (buf < end)\n\t\t\t\t*buf = ':';\n\t\t\tbuf++;\n\t\t}\n\n\t\tswitch (*fmt) {\n\t\tcase 'f':\t \n\t\t\tbuf = fwnode_full_name_string(of_fwnode_handle(dn), buf,\n\t\t\t\t\t\t      end);\n\t\t\tbreak;\n\t\tcase 'n':\t \n\t\t\tp = fwnode_get_name(of_fwnode_handle(dn));\n\t\t\tprecision = str_spec.precision;\n\t\t\tstr_spec.precision = strchrnul(p, '@') - p;\n\t\t\tbuf = string(buf, end, p, str_spec);\n\t\t\tstr_spec.precision = precision;\n\t\t\tbreak;\n\t\tcase 'p':\t \n\t\t\tbuf = number(buf, end, (unsigned int)dn->phandle, default_dec_spec);\n\t\t\tbreak;\n\t\tcase 'P':\t \n\t\t\tp = fwnode_get_name(of_fwnode_handle(dn));\n\t\t\tif (!p[1])\n\t\t\t\tp = \"/\";\n\t\t\tbuf = string(buf, end, p, str_spec);\n\t\t\tbreak;\n\t\tcase 'F':\t \n\t\t\ttbuf[0] = of_node_check_flag(dn, OF_DYNAMIC) ? 'D' : '-';\n\t\t\ttbuf[1] = of_node_check_flag(dn, OF_DETACHED) ? 'd' : '-';\n\t\t\ttbuf[2] = of_node_check_flag(dn, OF_POPULATED) ? 'P' : '-';\n\t\t\ttbuf[3] = of_node_check_flag(dn, OF_POPULATED_BUS) ? 'B' : '-';\n\t\t\ttbuf[4] = 0;\n\t\t\tbuf = string_nocheck(buf, end, tbuf, str_spec);\n\t\t\tbreak;\n\t\tcase 'c':\t \n\t\t\tret = of_property_read_string(dn, \"compatible\", &p);\n\t\t\tif (!ret)\n\t\t\t\tbuf = string(buf, end, p, str_spec);\n\t\t\tbreak;\n\t\tcase 'C':\t \n\t\t\thas_mult = false;\n\t\t\tof_property_for_each_string(dn, \"compatible\", prop, p) {\n\t\t\t\tif (has_mult)\n\t\t\t\t\tbuf = string_nocheck(buf, end, \",\", str_spec);\n\t\t\t\tbuf = string_nocheck(buf, end, \"\\\"\", str_spec);\n\t\t\t\tbuf = string(buf, end, p, str_spec);\n\t\t\t\tbuf = string_nocheck(buf, end, \"\\\"\", str_spec);\n\n\t\t\t\thas_mult = true;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn widen_string(buf, buf - buf_start, end, spec);\n}\n\nstatic noinline_for_stack\nchar *fwnode_string(char *buf, char *end, struct fwnode_handle *fwnode,\n\t\t    struct printf_spec spec, const char *fmt)\n{\n\tstruct printf_spec str_spec = spec;\n\tchar *buf_start = buf;\n\n\tstr_spec.field_width = -1;\n\n\tif (*fmt != 'w')\n\t\treturn error_string(buf, end, \"(%pf?)\", spec);\n\n\tif (check_pointer(&buf, end, fwnode, spec))\n\t\treturn buf;\n\n\tfmt++;\n\n\tswitch (*fmt) {\n\tcase 'P':\t \n\t\tbuf = string(buf, end, fwnode_get_name(fwnode), str_spec);\n\t\tbreak;\n\tcase 'f':\t \n\tdefault:\n\t\tbuf = fwnode_full_name_string(fwnode, buf, end);\n\t\tbreak;\n\t}\n\n\treturn widen_string(buf, buf - buf_start, end, spec);\n}\n\nint __init no_hash_pointers_enable(char *str)\n{\n\tif (no_hash_pointers)\n\t\treturn 0;\n\n\tno_hash_pointers = true;\n\n\tpr_warn(\"**********************************************************\\n\");\n\tpr_warn(\"**   NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE   **\\n\");\n\tpr_warn(\"**                                                      **\\n\");\n\tpr_warn(\"** This system shows unhashed kernel memory addresses   **\\n\");\n\tpr_warn(\"** via the console, logs, and other interfaces. This    **\\n\");\n\tpr_warn(\"** might reduce the security of your system.            **\\n\");\n\tpr_warn(\"**                                                      **\\n\");\n\tpr_warn(\"** If you see this message and you are not debugging    **\\n\");\n\tpr_warn(\"** the kernel, report this immediately to your system   **\\n\");\n\tpr_warn(\"** administrator!                                       **\\n\");\n\tpr_warn(\"**                                                      **\\n\");\n\tpr_warn(\"**   NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE   **\\n\");\n\tpr_warn(\"**********************************************************\\n\");\n\n\treturn 0;\n}\nearly_param(\"no_hash_pointers\", no_hash_pointers_enable);\n\n \nchar *rust_fmt_argument(char *buf, char *end, void *ptr);\n\n \nstatic noinline_for_stack\nchar *pointer(const char *fmt, char *buf, char *end, void *ptr,\n\t      struct printf_spec spec)\n{\n\tswitch (*fmt) {\n\tcase 'S':\n\tcase 's':\n\t\tptr = dereference_symbol_descriptor(ptr);\n\t\tfallthrough;\n\tcase 'B':\n\t\treturn symbol_string(buf, end, ptr, spec, fmt);\n\tcase 'R':\n\tcase 'r':\n\t\treturn resource_string(buf, end, ptr, spec, fmt);\n\tcase 'h':\n\t\treturn hex_string(buf, end, ptr, spec, fmt);\n\tcase 'b':\n\t\tswitch (fmt[1]) {\n\t\tcase 'l':\n\t\t\treturn bitmap_list_string(buf, end, ptr, spec, fmt);\n\t\tdefault:\n\t\t\treturn bitmap_string(buf, end, ptr, spec, fmt);\n\t\t}\n\tcase 'M':\t\t\t \n\tcase 'm':\t\t\t \n\t\t\t\t\t \n\t\t\t\t\t \n\t\treturn mac_address_string(buf, end, ptr, spec, fmt);\n\tcase 'I':\t\t\t \n\tcase 'i':\t\t\t \n\t\treturn ip_addr_string(buf, end, ptr, spec, fmt);\n\tcase 'E':\n\t\treturn escaped_string(buf, end, ptr, spec, fmt);\n\tcase 'U':\n\t\treturn uuid_string(buf, end, ptr, spec, fmt);\n\tcase 'V':\n\t\treturn va_format(buf, end, ptr, spec, fmt);\n\tcase 'K':\n\t\treturn restricted_pointer(buf, end, ptr, spec);\n\tcase 'N':\n\t\treturn netdev_bits(buf, end, ptr, spec, fmt);\n\tcase '4':\n\t\treturn fourcc_string(buf, end, ptr, spec, fmt);\n\tcase 'a':\n\t\treturn address_val(buf, end, ptr, spec, fmt);\n\tcase 'd':\n\t\treturn dentry_name(buf, end, ptr, spec, fmt);\n\tcase 't':\n\t\treturn time_and_date(buf, end, ptr, spec, fmt);\n\tcase 'C':\n\t\treturn clock(buf, end, ptr, spec, fmt);\n\tcase 'D':\n\t\treturn file_dentry_name(buf, end, ptr, spec, fmt);\n#ifdef CONFIG_BLOCK\n\tcase 'g':\n\t\treturn bdev_name(buf, end, ptr, spec, fmt);\n#endif\n\n\tcase 'G':\n\t\treturn flags_string(buf, end, ptr, spec, fmt);\n\tcase 'O':\n\t\treturn device_node_string(buf, end, ptr, spec, fmt + 1);\n\tcase 'f':\n\t\treturn fwnode_string(buf, end, ptr, spec, fmt + 1);\n\tcase 'A':\n\t\tif (!IS_ENABLED(CONFIG_RUST)) {\n\t\t\tWARN_ONCE(1, \"Please remove %%pA from non-Rust code\\n\");\n\t\t\treturn error_string(buf, end, \"(%pA?)\", spec);\n\t\t}\n\t\treturn rust_fmt_argument(buf, end, ptr);\n\tcase 'x':\n\t\treturn pointer_string(buf, end, ptr, spec);\n\tcase 'e':\n\t\t \n\t\tif (!IS_ERR(ptr))\n\t\t\treturn default_pointer(buf, end, ptr, spec);\n\t\treturn err_ptr(buf, end, ptr, spec);\n\tcase 'u':\n\tcase 'k':\n\t\tswitch (fmt[1]) {\n\t\tcase 's':\n\t\t\treturn string(buf, end, ptr, spec);\n\t\tdefault:\n\t\t\treturn error_string(buf, end, \"(einval)\", spec);\n\t\t}\n\tdefault:\n\t\treturn default_pointer(buf, end, ptr, spec);\n\t}\n}\n\n \nstatic noinline_for_stack\nint format_decode(const char *fmt, struct printf_spec *spec)\n{\n\tconst char *start = fmt;\n\tchar qualifier;\n\n\t \n\tif (spec->type == FORMAT_TYPE_WIDTH) {\n\t\tif (spec->field_width < 0) {\n\t\t\tspec->field_width = -spec->field_width;\n\t\t\tspec->flags |= LEFT;\n\t\t}\n\t\tspec->type = FORMAT_TYPE_NONE;\n\t\tgoto precision;\n\t}\n\n\t \n\tif (spec->type == FORMAT_TYPE_PRECISION) {\n\t\tif (spec->precision < 0)\n\t\t\tspec->precision = 0;\n\n\t\tspec->type = FORMAT_TYPE_NONE;\n\t\tgoto qualifier;\n\t}\n\n\t \n\tspec->type = FORMAT_TYPE_NONE;\n\n\tfor (; *fmt ; ++fmt) {\n\t\tif (*fmt == '%')\n\t\t\tbreak;\n\t}\n\n\t \n\tif (fmt != start || !*fmt)\n\t\treturn fmt - start;\n\n\t \n\tspec->flags = 0;\n\n\twhile (1) {  \n\t\tbool found = true;\n\n\t\t++fmt;\n\n\t\tswitch (*fmt) {\n\t\tcase '-': spec->flags |= LEFT;    break;\n\t\tcase '+': spec->flags |= PLUS;    break;\n\t\tcase ' ': spec->flags |= SPACE;   break;\n\t\tcase '#': spec->flags |= SPECIAL; break;\n\t\tcase '0': spec->flags |= ZEROPAD; break;\n\t\tdefault:  found = false;\n\t\t}\n\n\t\tif (!found)\n\t\t\tbreak;\n\t}\n\n\t \n\tspec->field_width = -1;\n\n\tif (isdigit(*fmt))\n\t\tspec->field_width = skip_atoi(&fmt);\n\telse if (*fmt == '*') {\n\t\t \n\t\tspec->type = FORMAT_TYPE_WIDTH;\n\t\treturn ++fmt - start;\n\t}\n\nprecision:\n\t \n\tspec->precision = -1;\n\tif (*fmt == '.') {\n\t\t++fmt;\n\t\tif (isdigit(*fmt)) {\n\t\t\tspec->precision = skip_atoi(&fmt);\n\t\t\tif (spec->precision < 0)\n\t\t\t\tspec->precision = 0;\n\t\t} else if (*fmt == '*') {\n\t\t\t \n\t\t\tspec->type = FORMAT_TYPE_PRECISION;\n\t\t\treturn ++fmt - start;\n\t\t}\n\t}\n\nqualifier:\n\t \n\tqualifier = 0;\n\tif (*fmt == 'h' || _tolower(*fmt) == 'l' ||\n\t    *fmt == 'z' || *fmt == 't') {\n\t\tqualifier = *fmt++;\n\t\tif (unlikely(qualifier == *fmt)) {\n\t\t\tif (qualifier == 'l') {\n\t\t\t\tqualifier = 'L';\n\t\t\t\t++fmt;\n\t\t\t} else if (qualifier == 'h') {\n\t\t\t\tqualifier = 'H';\n\t\t\t\t++fmt;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tspec->base = 10;\n\tswitch (*fmt) {\n\tcase 'c':\n\t\tspec->type = FORMAT_TYPE_CHAR;\n\t\treturn ++fmt - start;\n\n\tcase 's':\n\t\tspec->type = FORMAT_TYPE_STR;\n\t\treturn ++fmt - start;\n\n\tcase 'p':\n\t\tspec->type = FORMAT_TYPE_PTR;\n\t\treturn ++fmt - start;\n\n\tcase '%':\n\t\tspec->type = FORMAT_TYPE_PERCENT_CHAR;\n\t\treturn ++fmt - start;\n\n\t \n\tcase 'o':\n\t\tspec->base = 8;\n\t\tbreak;\n\n\tcase 'x':\n\t\tspec->flags |= SMALL;\n\t\tfallthrough;\n\n\tcase 'X':\n\t\tspec->base = 16;\n\t\tbreak;\n\n\tcase 'd':\n\tcase 'i':\n\t\tspec->flags |= SIGN;\n\t\tbreak;\n\tcase 'u':\n\t\tbreak;\n\n\tcase 'n':\n\t\t \n\t\tfallthrough;\n\n\tdefault:\n\t\tWARN_ONCE(1, \"Please remove unsupported %%%c in format string\\n\", *fmt);\n\t\tspec->type = FORMAT_TYPE_INVALID;\n\t\treturn fmt - start;\n\t}\n\n\tif (qualifier == 'L')\n\t\tspec->type = FORMAT_TYPE_LONG_LONG;\n\telse if (qualifier == 'l') {\n\t\tBUILD_BUG_ON(FORMAT_TYPE_ULONG + SIGN != FORMAT_TYPE_LONG);\n\t\tspec->type = FORMAT_TYPE_ULONG + (spec->flags & SIGN);\n\t} else if (qualifier == 'z') {\n\t\tspec->type = FORMAT_TYPE_SIZE_T;\n\t} else if (qualifier == 't') {\n\t\tspec->type = FORMAT_TYPE_PTRDIFF;\n\t} else if (qualifier == 'H') {\n\t\tBUILD_BUG_ON(FORMAT_TYPE_UBYTE + SIGN != FORMAT_TYPE_BYTE);\n\t\tspec->type = FORMAT_TYPE_UBYTE + (spec->flags & SIGN);\n\t} else if (qualifier == 'h') {\n\t\tBUILD_BUG_ON(FORMAT_TYPE_USHORT + SIGN != FORMAT_TYPE_SHORT);\n\t\tspec->type = FORMAT_TYPE_USHORT + (spec->flags & SIGN);\n\t} else {\n\t\tBUILD_BUG_ON(FORMAT_TYPE_UINT + SIGN != FORMAT_TYPE_INT);\n\t\tspec->type = FORMAT_TYPE_UINT + (spec->flags & SIGN);\n\t}\n\n\treturn ++fmt - start;\n}\n\nstatic void\nset_field_width(struct printf_spec *spec, int width)\n{\n\tspec->field_width = width;\n\tif (WARN_ONCE(spec->field_width != width, \"field width %d too large\", width)) {\n\t\tspec->field_width = clamp(width, -FIELD_WIDTH_MAX, FIELD_WIDTH_MAX);\n\t}\n}\n\nstatic void\nset_precision(struct printf_spec *spec, int prec)\n{\n\tspec->precision = prec;\n\tif (WARN_ONCE(spec->precision != prec, \"precision %d too large\", prec)) {\n\t\tspec->precision = clamp(prec, 0, PRECISION_MAX);\n\t}\n}\n\n \nint vsnprintf(char *buf, size_t size, const char *fmt, va_list args)\n{\n\tunsigned long long num;\n\tchar *str, *end;\n\tstruct printf_spec spec = {0};\n\n\t \n\tif (WARN_ON_ONCE(size > INT_MAX))\n\t\treturn 0;\n\n\tstr = buf;\n\tend = buf + size;\n\n\t \n\tif (end < buf) {\n\t\tend = ((void *)-1);\n\t\tsize = end - buf;\n\t}\n\n\twhile (*fmt) {\n\t\tconst char *old_fmt = fmt;\n\t\tint read = format_decode(fmt, &spec);\n\n\t\tfmt += read;\n\n\t\tswitch (spec.type) {\n\t\tcase FORMAT_TYPE_NONE: {\n\t\t\tint copy = read;\n\t\t\tif (str < end) {\n\t\t\t\tif (copy > end - str)\n\t\t\t\t\tcopy = end - str;\n\t\t\t\tmemcpy(str, old_fmt, copy);\n\t\t\t}\n\t\t\tstr += read;\n\t\t\tbreak;\n\t\t}\n\n\t\tcase FORMAT_TYPE_WIDTH:\n\t\t\tset_field_width(&spec, va_arg(args, int));\n\t\t\tbreak;\n\n\t\tcase FORMAT_TYPE_PRECISION:\n\t\t\tset_precision(&spec, va_arg(args, int));\n\t\t\tbreak;\n\n\t\tcase FORMAT_TYPE_CHAR: {\n\t\t\tchar c;\n\n\t\t\tif (!(spec.flags & LEFT)) {\n\t\t\t\twhile (--spec.field_width > 0) {\n\t\t\t\t\tif (str < end)\n\t\t\t\t\t\t*str = ' ';\n\t\t\t\t\t++str;\n\n\t\t\t\t}\n\t\t\t}\n\t\t\tc = (unsigned char) va_arg(args, int);\n\t\t\tif (str < end)\n\t\t\t\t*str = c;\n\t\t\t++str;\n\t\t\twhile (--spec.field_width > 0) {\n\t\t\t\tif (str < end)\n\t\t\t\t\t*str = ' ';\n\t\t\t\t++str;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tcase FORMAT_TYPE_STR:\n\t\t\tstr = string(str, end, va_arg(args, char *), spec);\n\t\t\tbreak;\n\n\t\tcase FORMAT_TYPE_PTR:\n\t\t\tstr = pointer(fmt, str, end, va_arg(args, void *),\n\t\t\t\t      spec);\n\t\t\twhile (isalnum(*fmt))\n\t\t\t\tfmt++;\n\t\t\tbreak;\n\n\t\tcase FORMAT_TYPE_PERCENT_CHAR:\n\t\t\tif (str < end)\n\t\t\t\t*str = '%';\n\t\t\t++str;\n\t\t\tbreak;\n\n\t\tcase FORMAT_TYPE_INVALID:\n\t\t\t \n\t\t\tgoto out;\n\n\t\tdefault:\n\t\t\tswitch (spec.type) {\n\t\t\tcase FORMAT_TYPE_LONG_LONG:\n\t\t\t\tnum = va_arg(args, long long);\n\t\t\t\tbreak;\n\t\t\tcase FORMAT_TYPE_ULONG:\n\t\t\t\tnum = va_arg(args, unsigned long);\n\t\t\t\tbreak;\n\t\t\tcase FORMAT_TYPE_LONG:\n\t\t\t\tnum = va_arg(args, long);\n\t\t\t\tbreak;\n\t\t\tcase FORMAT_TYPE_SIZE_T:\n\t\t\t\tif (spec.flags & SIGN)\n\t\t\t\t\tnum = va_arg(args, ssize_t);\n\t\t\t\telse\n\t\t\t\t\tnum = va_arg(args, size_t);\n\t\t\t\tbreak;\n\t\t\tcase FORMAT_TYPE_PTRDIFF:\n\t\t\t\tnum = va_arg(args, ptrdiff_t);\n\t\t\t\tbreak;\n\t\t\tcase FORMAT_TYPE_UBYTE:\n\t\t\t\tnum = (unsigned char) va_arg(args, int);\n\t\t\t\tbreak;\n\t\t\tcase FORMAT_TYPE_BYTE:\n\t\t\t\tnum = (signed char) va_arg(args, int);\n\t\t\t\tbreak;\n\t\t\tcase FORMAT_TYPE_USHORT:\n\t\t\t\tnum = (unsigned short) va_arg(args, int);\n\t\t\t\tbreak;\n\t\t\tcase FORMAT_TYPE_SHORT:\n\t\t\t\tnum = (short) va_arg(args, int);\n\t\t\t\tbreak;\n\t\t\tcase FORMAT_TYPE_INT:\n\t\t\t\tnum = (int) va_arg(args, int);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tnum = va_arg(args, unsigned int);\n\t\t\t}\n\n\t\t\tstr = number(str, end, num, spec);\n\t\t}\n\t}\n\nout:\n\tif (size > 0) {\n\t\tif (str < end)\n\t\t\t*str = '\\0';\n\t\telse\n\t\t\tend[-1] = '\\0';\n\t}\n\n\t \n\treturn str-buf;\n\n}\nEXPORT_SYMBOL(vsnprintf);\n\n \nint vscnprintf(char *buf, size_t size, const char *fmt, va_list args)\n{\n\tint i;\n\n\tif (unlikely(!size))\n\t\treturn 0;\n\n\ti = vsnprintf(buf, size, fmt, args);\n\n\tif (likely(i < size))\n\t\treturn i;\n\n\treturn size - 1;\n}\nEXPORT_SYMBOL(vscnprintf);\n\n \nint snprintf(char *buf, size_t size, const char *fmt, ...)\n{\n\tva_list args;\n\tint i;\n\n\tva_start(args, fmt);\n\ti = vsnprintf(buf, size, fmt, args);\n\tva_end(args);\n\n\treturn i;\n}\nEXPORT_SYMBOL(snprintf);\n\n \n\nint scnprintf(char *buf, size_t size, const char *fmt, ...)\n{\n\tva_list args;\n\tint i;\n\n\tva_start(args, fmt);\n\ti = vscnprintf(buf, size, fmt, args);\n\tva_end(args);\n\n\treturn i;\n}\nEXPORT_SYMBOL(scnprintf);\n\n \nint vsprintf(char *buf, const char *fmt, va_list args)\n{\n\treturn vsnprintf(buf, INT_MAX, fmt, args);\n}\nEXPORT_SYMBOL(vsprintf);\n\n \nint sprintf(char *buf, const char *fmt, ...)\n{\n\tva_list args;\n\tint i;\n\n\tva_start(args, fmt);\n\ti = vsnprintf(buf, INT_MAX, fmt, args);\n\tva_end(args);\n\n\treturn i;\n}\nEXPORT_SYMBOL(sprintf);\n\n#ifdef CONFIG_BINARY_PRINTF\n \n\n \nint vbin_printf(u32 *bin_buf, size_t size, const char *fmt, va_list args)\n{\n\tstruct printf_spec spec = {0};\n\tchar *str, *end;\n\tint width;\n\n\tstr = (char *)bin_buf;\n\tend = (char *)(bin_buf + size);\n\n#define save_arg(type)\t\t\t\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\tunsigned long long value;\t\t\t\t\t\\\n\tif (sizeof(type) == 8) {\t\t\t\t\t\\\n\t\tunsigned long long val8;\t\t\t\t\\\n\t\tstr = PTR_ALIGN(str, sizeof(u32));\t\t\t\\\n\t\tval8 = va_arg(args, unsigned long long);\t\t\\\n\t\tif (str + sizeof(type) <= end) {\t\t\t\\\n\t\t\t*(u32 *)str = *(u32 *)&val8;\t\t\t\\\n\t\t\t*(u32 *)(str + 4) = *((u32 *)&val8 + 1);\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t\tvalue = val8;\t\t\t\t\t\t\\\n\t} else {\t\t\t\t\t\t\t\\\n\t\tunsigned int val4;\t\t\t\t\t\\\n\t\tstr = PTR_ALIGN(str, sizeof(type));\t\t\t\\\n\t\tval4 = va_arg(args, int);\t\t\t\t\\\n\t\tif (str + sizeof(type) <= end)\t\t\t\t\\\n\t\t\t*(typeof(type) *)str = (type)(long)val4;\t\\\n\t\tvalue = (unsigned long long)val4;\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\tstr += sizeof(type);\t\t\t\t\t\t\\\n\tvalue;\t\t\t\t\t\t\t\t\\\n})\n\n\twhile (*fmt) {\n\t\tint read = format_decode(fmt, &spec);\n\n\t\tfmt += read;\n\n\t\tswitch (spec.type) {\n\t\tcase FORMAT_TYPE_NONE:\n\t\tcase FORMAT_TYPE_PERCENT_CHAR:\n\t\t\tbreak;\n\t\tcase FORMAT_TYPE_INVALID:\n\t\t\tgoto out;\n\n\t\tcase FORMAT_TYPE_WIDTH:\n\t\tcase FORMAT_TYPE_PRECISION:\n\t\t\twidth = (int)save_arg(int);\n\t\t\t \n\t\t\tif (*fmt == 'p')\n\t\t\t\tset_field_width(&spec, width);\n\t\t\tbreak;\n\n\t\tcase FORMAT_TYPE_CHAR:\n\t\t\tsave_arg(char);\n\t\t\tbreak;\n\n\t\tcase FORMAT_TYPE_STR: {\n\t\t\tconst char *save_str = va_arg(args, char *);\n\t\t\tconst char *err_msg;\n\t\t\tsize_t len;\n\n\t\t\terr_msg = check_pointer_msg(save_str);\n\t\t\tif (err_msg)\n\t\t\t\tsave_str = err_msg;\n\n\t\t\tlen = strlen(save_str) + 1;\n\t\t\tif (str + len < end)\n\t\t\t\tmemcpy(str, save_str, len);\n\t\t\tstr += len;\n\t\t\tbreak;\n\t\t}\n\n\t\tcase FORMAT_TYPE_PTR:\n\t\t\t \n\t\t\tswitch (*fmt) {\n\t\t\t \n\t\t\tcase 'S':\n\t\t\tcase 's':\n\t\t\tcase 'x':\n\t\t\tcase 'K':\n\t\t\tcase 'e':\n\t\t\t\tsave_arg(void *);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (!isalnum(*fmt)) {\n\t\t\t\t\tsave_arg(void *);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tstr = pointer(fmt, str, end, va_arg(args, void *),\n\t\t\t\t\t      spec);\n\t\t\t\tif (str + 1 < end)\n\t\t\t\t\t*str++ = '\\0';\n\t\t\t\telse\n\t\t\t\t\tend[-1] = '\\0';  \n\t\t\t}\n\t\t\t \n\t\t\twhile (isalnum(*fmt))\n\t\t\t\tfmt++;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tswitch (spec.type) {\n\n\t\t\tcase FORMAT_TYPE_LONG_LONG:\n\t\t\t\tsave_arg(long long);\n\t\t\t\tbreak;\n\t\t\tcase FORMAT_TYPE_ULONG:\n\t\t\tcase FORMAT_TYPE_LONG:\n\t\t\t\tsave_arg(unsigned long);\n\t\t\t\tbreak;\n\t\t\tcase FORMAT_TYPE_SIZE_T:\n\t\t\t\tsave_arg(size_t);\n\t\t\t\tbreak;\n\t\t\tcase FORMAT_TYPE_PTRDIFF:\n\t\t\t\tsave_arg(ptrdiff_t);\n\t\t\t\tbreak;\n\t\t\tcase FORMAT_TYPE_UBYTE:\n\t\t\tcase FORMAT_TYPE_BYTE:\n\t\t\t\tsave_arg(char);\n\t\t\t\tbreak;\n\t\t\tcase FORMAT_TYPE_USHORT:\n\t\t\tcase FORMAT_TYPE_SHORT:\n\t\t\t\tsave_arg(short);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tsave_arg(int);\n\t\t\t}\n\t\t}\n\t}\n\nout:\n\treturn (u32 *)(PTR_ALIGN(str, sizeof(u32))) - bin_buf;\n#undef save_arg\n}\nEXPORT_SYMBOL_GPL(vbin_printf);\n\n \nint bstr_printf(char *buf, size_t size, const char *fmt, const u32 *bin_buf)\n{\n\tstruct printf_spec spec = {0};\n\tchar *str, *end;\n\tconst char *args = (const char *)bin_buf;\n\n\tif (WARN_ON_ONCE(size > INT_MAX))\n\t\treturn 0;\n\n\tstr = buf;\n\tend = buf + size;\n\n#define get_arg(type)\t\t\t\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\ttypeof(type) value;\t\t\t\t\t\t\\\n\tif (sizeof(type) == 8) {\t\t\t\t\t\\\n\t\targs = PTR_ALIGN(args, sizeof(u32));\t\t\t\\\n\t\t*(u32 *)&value = *(u32 *)args;\t\t\t\t\\\n\t\t*((u32 *)&value + 1) = *(u32 *)(args + 4);\t\t\\\n\t} else {\t\t\t\t\t\t\t\\\n\t\targs = PTR_ALIGN(args, sizeof(type));\t\t\t\\\n\t\tvalue = *(typeof(type) *)args;\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\targs += sizeof(type);\t\t\t\t\t\t\\\n\tvalue;\t\t\t\t\t\t\t\t\\\n})\n\n\t \n\tif (end < buf) {\n\t\tend = ((void *)-1);\n\t\tsize = end - buf;\n\t}\n\n\twhile (*fmt) {\n\t\tconst char *old_fmt = fmt;\n\t\tint read = format_decode(fmt, &spec);\n\n\t\tfmt += read;\n\n\t\tswitch (spec.type) {\n\t\tcase FORMAT_TYPE_NONE: {\n\t\t\tint copy = read;\n\t\t\tif (str < end) {\n\t\t\t\tif (copy > end - str)\n\t\t\t\t\tcopy = end - str;\n\t\t\t\tmemcpy(str, old_fmt, copy);\n\t\t\t}\n\t\t\tstr += read;\n\t\t\tbreak;\n\t\t}\n\n\t\tcase FORMAT_TYPE_WIDTH:\n\t\t\tset_field_width(&spec, get_arg(int));\n\t\t\tbreak;\n\n\t\tcase FORMAT_TYPE_PRECISION:\n\t\t\tset_precision(&spec, get_arg(int));\n\t\t\tbreak;\n\n\t\tcase FORMAT_TYPE_CHAR: {\n\t\t\tchar c;\n\n\t\t\tif (!(spec.flags & LEFT)) {\n\t\t\t\twhile (--spec.field_width > 0) {\n\t\t\t\t\tif (str < end)\n\t\t\t\t\t\t*str = ' ';\n\t\t\t\t\t++str;\n\t\t\t\t}\n\t\t\t}\n\t\t\tc = (unsigned char) get_arg(char);\n\t\t\tif (str < end)\n\t\t\t\t*str = c;\n\t\t\t++str;\n\t\t\twhile (--spec.field_width > 0) {\n\t\t\t\tif (str < end)\n\t\t\t\t\t*str = ' ';\n\t\t\t\t++str;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tcase FORMAT_TYPE_STR: {\n\t\t\tconst char *str_arg = args;\n\t\t\targs += strlen(str_arg) + 1;\n\t\t\tstr = string(str, end, (char *)str_arg, spec);\n\t\t\tbreak;\n\t\t}\n\n\t\tcase FORMAT_TYPE_PTR: {\n\t\t\tbool process = false;\n\t\t\tint copy, len;\n\t\t\t \n\t\t\tswitch (*fmt) {\n\t\t\tcase 'S':\n\t\t\tcase 's':\n\t\t\tcase 'x':\n\t\t\tcase 'K':\n\t\t\tcase 'e':\n\t\t\t\tprocess = true;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (!isalnum(*fmt)) {\n\t\t\t\t\tprocess = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t \n\t\t\t\tif (str < end) {\n\t\t\t\t\tlen = copy = strlen(args);\n\t\t\t\t\tif (copy > end - str)\n\t\t\t\t\t\tcopy = end - str;\n\t\t\t\t\tmemcpy(str, args, copy);\n\t\t\t\t\tstr += len;\n\t\t\t\t\targs += len + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (process)\n\t\t\t\tstr = pointer(fmt, str, end, get_arg(void *), spec);\n\n\t\t\twhile (isalnum(*fmt))\n\t\t\t\tfmt++;\n\t\t\tbreak;\n\t\t}\n\n\t\tcase FORMAT_TYPE_PERCENT_CHAR:\n\t\t\tif (str < end)\n\t\t\t\t*str = '%';\n\t\t\t++str;\n\t\t\tbreak;\n\n\t\tcase FORMAT_TYPE_INVALID:\n\t\t\tgoto out;\n\n\t\tdefault: {\n\t\t\tunsigned long long num;\n\n\t\t\tswitch (spec.type) {\n\n\t\t\tcase FORMAT_TYPE_LONG_LONG:\n\t\t\t\tnum = get_arg(long long);\n\t\t\t\tbreak;\n\t\t\tcase FORMAT_TYPE_ULONG:\n\t\t\tcase FORMAT_TYPE_LONG:\n\t\t\t\tnum = get_arg(unsigned long);\n\t\t\t\tbreak;\n\t\t\tcase FORMAT_TYPE_SIZE_T:\n\t\t\t\tnum = get_arg(size_t);\n\t\t\t\tbreak;\n\t\t\tcase FORMAT_TYPE_PTRDIFF:\n\t\t\t\tnum = get_arg(ptrdiff_t);\n\t\t\t\tbreak;\n\t\t\tcase FORMAT_TYPE_UBYTE:\n\t\t\t\tnum = get_arg(unsigned char);\n\t\t\t\tbreak;\n\t\t\tcase FORMAT_TYPE_BYTE:\n\t\t\t\tnum = get_arg(signed char);\n\t\t\t\tbreak;\n\t\t\tcase FORMAT_TYPE_USHORT:\n\t\t\t\tnum = get_arg(unsigned short);\n\t\t\t\tbreak;\n\t\t\tcase FORMAT_TYPE_SHORT:\n\t\t\t\tnum = get_arg(short);\n\t\t\t\tbreak;\n\t\t\tcase FORMAT_TYPE_UINT:\n\t\t\t\tnum = get_arg(unsigned int);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tnum = get_arg(int);\n\t\t\t}\n\n\t\t\tstr = number(str, end, num, spec);\n\t\t}  \n\t\t}  \n\t}  \n\nout:\n\tif (size > 0) {\n\t\tif (str < end)\n\t\t\t*str = '\\0';\n\t\telse\n\t\t\tend[-1] = '\\0';\n\t}\n\n#undef get_arg\n\n\t \n\treturn str - buf;\n}\nEXPORT_SYMBOL_GPL(bstr_printf);\n\n \nint bprintf(u32 *bin_buf, size_t size, const char *fmt, ...)\n{\n\tva_list args;\n\tint ret;\n\n\tva_start(args, fmt);\n\tret = vbin_printf(bin_buf, size, fmt, args);\n\tva_end(args);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(bprintf);\n\n#endif  \n\n \nint vsscanf(const char *buf, const char *fmt, va_list args)\n{\n\tconst char *str = buf;\n\tchar *next;\n\tchar digit;\n\tint num = 0;\n\tu8 qualifier;\n\tunsigned int base;\n\tunion {\n\t\tlong long s;\n\t\tunsigned long long u;\n\t} val;\n\ts16 field_width;\n\tbool is_sign;\n\n\twhile (*fmt) {\n\t\t \n\t\t \n\t\tif (isspace(*fmt)) {\n\t\t\tfmt = skip_spaces(++fmt);\n\t\t\tstr = skip_spaces(str);\n\t\t}\n\n\t\t \n\t\tif (*fmt != '%' && *fmt) {\n\t\t\tif (*fmt++ != *str++)\n\t\t\t\tbreak;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!*fmt)\n\t\t\tbreak;\n\t\t++fmt;\n\n\t\t \n\t\tif (*fmt == '*') {\n\t\t\tif (!*str)\n\t\t\t\tbreak;\n\t\t\twhile (!isspace(*fmt) && *fmt != '%' && *fmt) {\n\t\t\t\t \n\t\t\t\tif (*fmt == '[')\n\t\t\t\t\treturn num;\n\t\t\t\tfmt++;\n\t\t\t}\n\t\t\twhile (!isspace(*str) && *str)\n\t\t\t\tstr++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tfield_width = -1;\n\t\tif (isdigit(*fmt)) {\n\t\t\tfield_width = skip_atoi(&fmt);\n\t\t\tif (field_width <= 0)\n\t\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tqualifier = -1;\n\t\tif (*fmt == 'h' || _tolower(*fmt) == 'l' ||\n\t\t    *fmt == 'z') {\n\t\t\tqualifier = *fmt++;\n\t\t\tif (unlikely(qualifier == *fmt)) {\n\t\t\t\tif (qualifier == 'h') {\n\t\t\t\t\tqualifier = 'H';\n\t\t\t\t\tfmt++;\n\t\t\t\t} else if (qualifier == 'l') {\n\t\t\t\t\tqualifier = 'L';\n\t\t\t\t\tfmt++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!*fmt)\n\t\t\tbreak;\n\n\t\tif (*fmt == 'n') {\n\t\t\t \n\t\t\t*va_arg(args, int *) = str - buf;\n\t\t\t++fmt;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!*str)\n\t\t\tbreak;\n\n\t\tbase = 10;\n\t\tis_sign = false;\n\n\t\tswitch (*fmt++) {\n\t\tcase 'c':\n\t\t{\n\t\t\tchar *s = (char *)va_arg(args, char*);\n\t\t\tif (field_width == -1)\n\t\t\t\tfield_width = 1;\n\t\t\tdo {\n\t\t\t\t*s++ = *str++;\n\t\t\t} while (--field_width > 0 && *str);\n\t\t\tnum++;\n\t\t}\n\t\tcontinue;\n\t\tcase 's':\n\t\t{\n\t\t\tchar *s = (char *)va_arg(args, char *);\n\t\t\tif (field_width == -1)\n\t\t\t\tfield_width = SHRT_MAX;\n\t\t\t \n\t\t\tstr = skip_spaces(str);\n\n\t\t\t \n\t\t\twhile (*str && !isspace(*str) && field_width--)\n\t\t\t\t*s++ = *str++;\n\t\t\t*s = '\\0';\n\t\t\tnum++;\n\t\t}\n\t\tcontinue;\n\t\t \n\t\tcase '[':\n\t\t{\n\t\t\tchar *s = (char *)va_arg(args, char *);\n\t\t\tDECLARE_BITMAP(set, 256) = {0};\n\t\t\tunsigned int len = 0;\n\t\t\tbool negate = (*fmt == '^');\n\n\t\t\t \n\t\t\tif (field_width == -1)\n\t\t\t\treturn num;\n\n\t\t\tif (negate)\n\t\t\t\t++fmt;\n\n\t\t\tfor ( ; *fmt && *fmt != ']'; ++fmt, ++len)\n\t\t\t\t__set_bit((u8)*fmt, set);\n\n\t\t\t \n\t\t\tif (!*fmt || !len)\n\t\t\t\treturn num;\n\t\t\t++fmt;\n\n\t\t\tif (negate) {\n\t\t\t\tbitmap_complement(set, set, 256);\n\t\t\t\t \n\t\t\t\t__clear_bit(0, set);\n\t\t\t}\n\n\t\t\t \n\t\t\tif (!test_bit((u8)*str, set))\n\t\t\t\treturn num;\n\n\t\t\twhile (test_bit((u8)*str, set) && field_width--)\n\t\t\t\t*s++ = *str++;\n\t\t\t*s = '\\0';\n\t\t\t++num;\n\t\t}\n\t\tcontinue;\n\t\tcase 'o':\n\t\t\tbase = 8;\n\t\t\tbreak;\n\t\tcase 'x':\n\t\tcase 'X':\n\t\t\tbase = 16;\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\tbase = 0;\n\t\t\tfallthrough;\n\t\tcase 'd':\n\t\t\tis_sign = true;\n\t\t\tfallthrough;\n\t\tcase 'u':\n\t\t\tbreak;\n\t\tcase '%':\n\t\t\t \n\t\t\tif (*str++ != '%')\n\t\t\t\treturn num;\n\t\t\tcontinue;\n\t\tdefault:\n\t\t\t \n\t\t\treturn num;\n\t\t}\n\n\t\t \n\t\tstr = skip_spaces(str);\n\n\t\tdigit = *str;\n\t\tif (is_sign && digit == '-') {\n\t\t\tif (field_width == 1)\n\t\t\t\tbreak;\n\n\t\t\tdigit = *(str + 1);\n\t\t}\n\n\t\tif (!digit\n\t\t    || (base == 16 && !isxdigit(digit))\n\t\t    || (base == 10 && !isdigit(digit))\n\t\t    || (base == 8 && !isodigit(digit))\n\t\t    || (base == 0 && !isdigit(digit)))\n\t\t\tbreak;\n\n\t\tif (is_sign)\n\t\t\tval.s = simple_strntoll(str,\n\t\t\t\t\t\tfield_width >= 0 ? field_width : INT_MAX,\n\t\t\t\t\t\t&next, base);\n\t\telse\n\t\t\tval.u = simple_strntoull(str,\n\t\t\t\t\t\t field_width >= 0 ? field_width : INT_MAX,\n\t\t\t\t\t\t &next, base);\n\n\t\tswitch (qualifier) {\n\t\tcase 'H':\t \n\t\t\tif (is_sign)\n\t\t\t\t*va_arg(args, signed char *) = val.s;\n\t\t\telse\n\t\t\t\t*va_arg(args, unsigned char *) = val.u;\n\t\t\tbreak;\n\t\tcase 'h':\n\t\t\tif (is_sign)\n\t\t\t\t*va_arg(args, short *) = val.s;\n\t\t\telse\n\t\t\t\t*va_arg(args, unsigned short *) = val.u;\n\t\t\tbreak;\n\t\tcase 'l':\n\t\t\tif (is_sign)\n\t\t\t\t*va_arg(args, long *) = val.s;\n\t\t\telse\n\t\t\t\t*va_arg(args, unsigned long *) = val.u;\n\t\t\tbreak;\n\t\tcase 'L':\n\t\t\tif (is_sign)\n\t\t\t\t*va_arg(args, long long *) = val.s;\n\t\t\telse\n\t\t\t\t*va_arg(args, unsigned long long *) = val.u;\n\t\t\tbreak;\n\t\tcase 'z':\n\t\t\t*va_arg(args, size_t *) = val.u;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (is_sign)\n\t\t\t\t*va_arg(args, int *) = val.s;\n\t\t\telse\n\t\t\t\t*va_arg(args, unsigned int *) = val.u;\n\t\t\tbreak;\n\t\t}\n\t\tnum++;\n\n\t\tif (!next)\n\t\t\tbreak;\n\t\tstr = next;\n\t}\n\n\treturn num;\n}\nEXPORT_SYMBOL(vsscanf);\n\n \nint sscanf(const char *buf, const char *fmt, ...)\n{\n\tva_list args;\n\tint i;\n\n\tva_start(args, fmt);\n\ti = vsscanf(buf, fmt, args);\n\tva_end(args);\n\n\treturn i;\n}\nEXPORT_SYMBOL(sscanf);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}