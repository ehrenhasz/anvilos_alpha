{
  "module_name": "lockref.c",
  "hash_id": "defc185b25dfe45c2df4d2f0a39319d780bbea7f39a48805e75901009bfc16b8",
  "original_prompt": "Ingested from linux-6.6.14/lib/lockref.c",
  "human_readable_source": "\n#include <linux/export.h>\n#include <linux/lockref.h>\n\n#if USE_CMPXCHG_LOCKREF\n\n \n#define CMPXCHG_LOOP(CODE, SUCCESS) do {\t\t\t\t\t\\\n\tint retry = 100;\t\t\t\t\t\t\t\\\n\tstruct lockref old;\t\t\t\t\t\t\t\\\n\tBUILD_BUG_ON(sizeof(old) != 8);\t\t\t\t\t\t\\\n\told.lock_count = READ_ONCE(lockref->lock_count);\t\t\t\\\n\twhile (likely(arch_spin_value_unlocked(old.lock.rlock.raw_lock))) {  \t\\\n\t\tstruct lockref new = old;\t\t\t\t\t\\\n\t\tCODE\t\t\t\t\t\t\t\t\\\n\t\tif (likely(try_cmpxchg64_relaxed(&lockref->lock_count,\t\t\\\n\t\t\t\t\t\t &old.lock_count,\t\t\\\n\t\t\t\t\t\t new.lock_count))) {\t\t\\\n\t\t\tSUCCESS;\t\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\t\\\n\t\tif (!--retry)\t\t\t\t\t\t\t\\\n\t\t\tbreak;\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\t\\\n} while (0)\n\n#else\n\n#define CMPXCHG_LOOP(CODE, SUCCESS) do { } while (0)\n\n#endif\n\n \nvoid lockref_get(struct lockref *lockref)\n{\n\tCMPXCHG_LOOP(\n\t\tnew.count++;\n\t,\n\t\treturn;\n\t);\n\n\tspin_lock(&lockref->lock);\n\tlockref->count++;\n\tspin_unlock(&lockref->lock);\n}\nEXPORT_SYMBOL(lockref_get);\n\n \nint lockref_get_not_zero(struct lockref *lockref)\n{\n\tint retval;\n\n\tCMPXCHG_LOOP(\n\t\tnew.count++;\n\t\tif (old.count <= 0)\n\t\t\treturn 0;\n\t,\n\t\treturn 1;\n\t);\n\n\tspin_lock(&lockref->lock);\n\tretval = 0;\n\tif (lockref->count > 0) {\n\t\tlockref->count++;\n\t\tretval = 1;\n\t}\n\tspin_unlock(&lockref->lock);\n\treturn retval;\n}\nEXPORT_SYMBOL(lockref_get_not_zero);\n\n \nint lockref_put_not_zero(struct lockref *lockref)\n{\n\tint retval;\n\n\tCMPXCHG_LOOP(\n\t\tnew.count--;\n\t\tif (old.count <= 1)\n\t\t\treturn 0;\n\t,\n\t\treturn 1;\n\t);\n\n\tspin_lock(&lockref->lock);\n\tretval = 0;\n\tif (lockref->count > 1) {\n\t\tlockref->count--;\n\t\tretval = 1;\n\t}\n\tspin_unlock(&lockref->lock);\n\treturn retval;\n}\nEXPORT_SYMBOL(lockref_put_not_zero);\n\n \nint lockref_put_return(struct lockref *lockref)\n{\n\tCMPXCHG_LOOP(\n\t\tnew.count--;\n\t\tif (old.count <= 0)\n\t\t\treturn -1;\n\t,\n\t\treturn new.count;\n\t);\n\treturn -1;\n}\nEXPORT_SYMBOL(lockref_put_return);\n\n \nint lockref_put_or_lock(struct lockref *lockref)\n{\n\tCMPXCHG_LOOP(\n\t\tnew.count--;\n\t\tif (old.count <= 1)\n\t\t\tbreak;\n\t,\n\t\treturn 1;\n\t);\n\n\tspin_lock(&lockref->lock);\n\tif (lockref->count <= 1)\n\t\treturn 0;\n\tlockref->count--;\n\tspin_unlock(&lockref->lock);\n\treturn 1;\n}\nEXPORT_SYMBOL(lockref_put_or_lock);\n\n \nvoid lockref_mark_dead(struct lockref *lockref)\n{\n\tassert_spin_locked(&lockref->lock);\n\tlockref->count = -128;\n}\nEXPORT_SYMBOL(lockref_mark_dead);\n\n \nint lockref_get_not_dead(struct lockref *lockref)\n{\n\tint retval;\n\n\tCMPXCHG_LOOP(\n\t\tnew.count++;\n\t\tif (old.count < 0)\n\t\t\treturn 0;\n\t,\n\t\treturn 1;\n\t);\n\n\tspin_lock(&lockref->lock);\n\tretval = 0;\n\tif (lockref->count >= 0) {\n\t\tlockref->count++;\n\t\tretval = 1;\n\t}\n\tspin_unlock(&lockref->lock);\n\treturn retval;\n}\nEXPORT_SYMBOL(lockref_get_not_dead);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}