{
  "module_name": "test_fprobe.c",
  "hash_id": "81027d911df36fe6f2ea8bc812a96b4d9c7ca72cb1de69f4d3598adff73fc24d",
  "original_prompt": "Ingested from linux-6.6.14/lib/test_fprobe.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/fprobe.h>\n#include <linux/random.h>\n#include <kunit/test.h>\n\n#define div_factor 3\n\nstatic struct kunit *current_test;\n\nstatic u32 rand1, entry_val, exit_val;\n\n \nstatic u32 (*target)(u32 value);\nstatic u32 (*target2)(u32 value);\nstatic u32 (*target_nest)(u32 value, u32 (*nest)(u32));\nstatic unsigned long target_ip;\nstatic unsigned long target2_ip;\nstatic unsigned long target_nest_ip;\nstatic int entry_return_value;\n\nstatic noinline u32 fprobe_selftest_target(u32 value)\n{\n\treturn (value / div_factor);\n}\n\nstatic noinline u32 fprobe_selftest_target2(u32 value)\n{\n\treturn (value / div_factor) + 1;\n}\n\nstatic noinline u32 fprobe_selftest_nest_target(u32 value, u32 (*nest)(u32))\n{\n\treturn nest(value + 2);\n}\n\nstatic notrace int fp_entry_handler(struct fprobe *fp, unsigned long ip,\n\t\t\t\t    unsigned long ret_ip,\n\t\t\t\t    struct pt_regs *regs, void *data)\n{\n\tKUNIT_EXPECT_FALSE(current_test, preemptible());\n\t \n\tif (ip != target_ip)\n\t\tKUNIT_EXPECT_EQ(current_test, ip, target2_ip);\n\tentry_val = (rand1 / div_factor);\n\tif (fp->entry_data_size) {\n\t\tKUNIT_EXPECT_NOT_NULL(current_test, data);\n\t\tif (data)\n\t\t\t*(u32 *)data = entry_val;\n\t} else\n\t\tKUNIT_EXPECT_NULL(current_test, data);\n\n\treturn entry_return_value;\n}\n\nstatic notrace void fp_exit_handler(struct fprobe *fp, unsigned long ip,\n\t\t\t\t    unsigned long ret_ip,\n\t\t\t\t    struct pt_regs *regs, void *data)\n{\n\tunsigned long ret = regs_return_value(regs);\n\n\tKUNIT_EXPECT_FALSE(current_test, preemptible());\n\tif (ip != target_ip) {\n\t\tKUNIT_EXPECT_EQ(current_test, ip, target2_ip);\n\t\tKUNIT_EXPECT_EQ(current_test, ret, (rand1 / div_factor) + 1);\n\t} else\n\t\tKUNIT_EXPECT_EQ(current_test, ret, (rand1 / div_factor));\n\tKUNIT_EXPECT_EQ(current_test, entry_val, (rand1 / div_factor));\n\texit_val = entry_val + div_factor;\n\tif (fp->entry_data_size) {\n\t\tKUNIT_EXPECT_NOT_NULL(current_test, data);\n\t\tif (data)\n\t\t\tKUNIT_EXPECT_EQ(current_test, *(u32 *)data, entry_val);\n\t} else\n\t\tKUNIT_EXPECT_NULL(current_test, data);\n}\n\nstatic notrace int nest_entry_handler(struct fprobe *fp, unsigned long ip,\n\t\t\t\t      unsigned long ret_ip,\n\t\t\t\t      struct pt_regs *regs, void *data)\n{\n\tKUNIT_EXPECT_FALSE(current_test, preemptible());\n\treturn 0;\n}\n\nstatic notrace void nest_exit_handler(struct fprobe *fp, unsigned long ip,\n\t\t\t\t      unsigned long ret_ip,\n\t\t\t\t      struct pt_regs *regs, void *data)\n{\n\tKUNIT_EXPECT_FALSE(current_test, preemptible());\n\tKUNIT_EXPECT_EQ(current_test, ip, target_nest_ip);\n}\n\n \nstatic void test_fprobe_entry(struct kunit *test)\n{\n\tstruct fprobe fp_entry = {\n\t\t.entry_handler = fp_entry_handler,\n\t};\n\n\tcurrent_test = test;\n\n\t \n\tKUNIT_EXPECT_NE(test, 0, unregister_fprobe(&fp_entry));\n\tKUNIT_EXPECT_EQ(test, 0, register_fprobe(&fp_entry, \"fprobe_selftest_target*\", NULL));\n\n\tentry_val = 0;\n\texit_val = 0;\n\ttarget(rand1);\n\tKUNIT_EXPECT_NE(test, 0, entry_val);\n\tKUNIT_EXPECT_EQ(test, 0, exit_val);\n\n\tentry_val = 0;\n\texit_val = 0;\n\ttarget2(rand1);\n\tKUNIT_EXPECT_NE(test, 0, entry_val);\n\tKUNIT_EXPECT_EQ(test, 0, exit_val);\n\n\tKUNIT_EXPECT_EQ(test, 0, unregister_fprobe(&fp_entry));\n}\n\nstatic void test_fprobe(struct kunit *test)\n{\n\tstruct fprobe fp = {\n\t\t.entry_handler = fp_entry_handler,\n\t\t.exit_handler = fp_exit_handler,\n\t};\n\n\tcurrent_test = test;\n\tKUNIT_EXPECT_EQ(test, 0, register_fprobe(&fp, \"fprobe_selftest_target*\", NULL));\n\n\tentry_val = 0;\n\texit_val = 0;\n\ttarget(rand1);\n\tKUNIT_EXPECT_NE(test, 0, entry_val);\n\tKUNIT_EXPECT_EQ(test, entry_val + div_factor, exit_val);\n\n\tentry_val = 0;\n\texit_val = 0;\n\ttarget2(rand1);\n\tKUNIT_EXPECT_NE(test, 0, entry_val);\n\tKUNIT_EXPECT_EQ(test, entry_val + div_factor, exit_val);\n\n\tKUNIT_EXPECT_EQ(test, 0, unregister_fprobe(&fp));\n}\n\nstatic void test_fprobe_syms(struct kunit *test)\n{\n\tstatic const char *syms[] = {\"fprobe_selftest_target\", \"fprobe_selftest_target2\"};\n\tstruct fprobe fp = {\n\t\t.entry_handler = fp_entry_handler,\n\t\t.exit_handler = fp_exit_handler,\n\t};\n\n\tcurrent_test = test;\n\tKUNIT_EXPECT_EQ(test, 0, register_fprobe_syms(&fp, syms, 2));\n\n\tentry_val = 0;\n\texit_val = 0;\n\ttarget(rand1);\n\tKUNIT_EXPECT_NE(test, 0, entry_val);\n\tKUNIT_EXPECT_EQ(test, entry_val + div_factor, exit_val);\n\n\tentry_val = 0;\n\texit_val = 0;\n\ttarget2(rand1);\n\tKUNIT_EXPECT_NE(test, 0, entry_val);\n\tKUNIT_EXPECT_EQ(test, entry_val + div_factor, exit_val);\n\n\tKUNIT_EXPECT_EQ(test, 0, unregister_fprobe(&fp));\n}\n\n \nstatic void test_fprobe_data(struct kunit *test)\n{\n\tstruct fprobe fp = {\n\t\t.entry_handler = fp_entry_handler,\n\t\t.exit_handler = fp_exit_handler,\n\t\t.entry_data_size = sizeof(u32),\n\t};\n\n\tcurrent_test = test;\n\tKUNIT_EXPECT_EQ(test, 0, register_fprobe(&fp, \"fprobe_selftest_target\", NULL));\n\n\ttarget(rand1);\n\n\tKUNIT_EXPECT_EQ(test, 0, unregister_fprobe(&fp));\n}\n\n \nstatic void test_fprobe_nest(struct kunit *test)\n{\n\tstatic const char *syms[] = {\"fprobe_selftest_target\", \"fprobe_selftest_nest_target\"};\n\tstruct fprobe fp = {\n\t\t.entry_handler = nest_entry_handler,\n\t\t.exit_handler = nest_exit_handler,\n\t\t.nr_maxactive = 1,\n\t};\n\n\tcurrent_test = test;\n\tKUNIT_EXPECT_EQ(test, 0, register_fprobe_syms(&fp, syms, 2));\n\n\ttarget_nest(rand1, target);\n\tKUNIT_EXPECT_EQ(test, 1, fp.nmissed);\n\n\tKUNIT_EXPECT_EQ(test, 0, unregister_fprobe(&fp));\n}\n\nstatic void test_fprobe_skip(struct kunit *test)\n{\n\tstruct fprobe fp = {\n\t\t.entry_handler = fp_entry_handler,\n\t\t.exit_handler = fp_exit_handler,\n\t};\n\n\tcurrent_test = test;\n\tKUNIT_EXPECT_EQ(test, 0, register_fprobe(&fp, \"fprobe_selftest_target\", NULL));\n\n\tentry_return_value = 1;\n\tentry_val = 0;\n\texit_val = 0;\n\ttarget(rand1);\n\tKUNIT_EXPECT_NE(test, 0, entry_val);\n\tKUNIT_EXPECT_EQ(test, 0, exit_val);\n\tKUNIT_EXPECT_EQ(test, 0, fp.nmissed);\n\tentry_return_value = 0;\n\n\tKUNIT_EXPECT_EQ(test, 0, unregister_fprobe(&fp));\n}\n\nstatic unsigned long get_ftrace_location(void *func)\n{\n\tunsigned long size, addr = (unsigned long)func;\n\n\tif (!kallsyms_lookup_size_offset(addr, &size, NULL) || !size)\n\t\treturn 0;\n\n\treturn ftrace_location_range(addr, addr + size - 1);\n}\n\nstatic int fprobe_test_init(struct kunit *test)\n{\n\trand1 = get_random_u32_above(div_factor);\n\ttarget = fprobe_selftest_target;\n\ttarget2 = fprobe_selftest_target2;\n\ttarget_nest = fprobe_selftest_nest_target;\n\ttarget_ip = get_ftrace_location(target);\n\ttarget2_ip = get_ftrace_location(target2);\n\ttarget_nest_ip = get_ftrace_location(target_nest);\n\n\treturn 0;\n}\n\nstatic struct kunit_case fprobe_testcases[] = {\n\tKUNIT_CASE(test_fprobe_entry),\n\tKUNIT_CASE(test_fprobe),\n\tKUNIT_CASE(test_fprobe_syms),\n\tKUNIT_CASE(test_fprobe_data),\n\tKUNIT_CASE(test_fprobe_nest),\n\tKUNIT_CASE(test_fprobe_skip),\n\t{}\n};\n\nstatic struct kunit_suite fprobe_test_suite = {\n\t.name = \"fprobe_test\",\n\t.init = fprobe_test_init,\n\t.test_cases = fprobe_testcases,\n};\n\nkunit_test_suites(&fprobe_test_suite);\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}