{
  "module_name": "Kconfig.kasan",
  "hash_id": "8e64cf22988fde07c4fd80eb81d4f1f0438196c14ea54dc2edc189b627165a01",
  "original_prompt": "Ingested from linux-6.6.14/lib/Kconfig.kasan",
  "human_readable_source": "# SPDX-License-Identifier: GPL-2.0-only\n\n# This config refers to the generic KASAN mode.\nconfig HAVE_ARCH_KASAN\n\tbool\n\nconfig HAVE_ARCH_KASAN_SW_TAGS\n\tbool\n\nconfig HAVE_ARCH_KASAN_HW_TAGS\n\tbool\n\nconfig HAVE_ARCH_KASAN_VMALLOC\n\tbool\n\nconfig ARCH_DISABLE_KASAN_INLINE\n\tbool\n\thelp\n\t  Disables both inline and stack instrumentation. Selected by\n\t  architectures that do not support these instrumentation types.\n\nconfig CC_HAS_KASAN_GENERIC\n\tdef_bool $(cc-option, -fsanitize=kernel-address)\n\nconfig CC_HAS_KASAN_SW_TAGS\n\tdef_bool $(cc-option, -fsanitize=kernel-hwaddress)\n\n# This option is only required for software KASAN modes.\n# Old GCC versions do not have proper support for no_sanitize_address.\n# See https://gcc.gnu.org/bugzilla/show_bug.cgi?id=89124 for details.\nconfig CC_HAS_WORKING_NOSANITIZE_ADDRESS\n\tdef_bool !CC_IS_GCC || GCC_VERSION >= 80300\n\nmenuconfig KASAN\n\tbool \"KASAN: dynamic memory safety error detector\"\n\tdepends on (((HAVE_ARCH_KASAN && CC_HAS_KASAN_GENERIC) || \\\n\t\t     (HAVE_ARCH_KASAN_SW_TAGS && CC_HAS_KASAN_SW_TAGS)) && \\\n\t\t    CC_HAS_WORKING_NOSANITIZE_ADDRESS) || \\\n\t\t   HAVE_ARCH_KASAN_HW_TAGS\n\tdepends on (SLUB && SYSFS && !SLUB_TINY) || (SLAB && !DEBUG_SLAB)\n\tselect STACKDEPOT_ALWAYS_INIT\n\thelp\n\t  Enables KASAN (Kernel Address Sanitizer) - a dynamic memory safety\n\t  error detector designed to find out-of-bounds and use-after-free bugs.\n\n\t  See Documentation/dev-tools/kasan.rst for details.\n\n\t  For better error reports, also enable CONFIG_STACKTRACE.\n\nif KASAN\n\nconfig CC_HAS_KASAN_MEMINTRINSIC_PREFIX\n\tdef_bool (CC_IS_CLANG && $(cc-option,-fsanitize=kernel-address -mllvm -asan-kernel-mem-intrinsic-prefix=1)) || \\\n\t\t (CC_IS_GCC && $(cc-option,-fsanitize=kernel-address --param asan-kernel-mem-intrinsic-prefix=1))\n\t# Don't define it if we don't need it: compilation of the test uses\n\t# this variable to decide how the compiler should treat builtins.\n\tdepends on !KASAN_HW_TAGS\n\thelp\n\t  The compiler is able to prefix memintrinsics with __asan or __hwasan.\n\nchoice\n\tprompt \"KASAN mode\"\n\tdefault KASAN_GENERIC\n\thelp\n\t  KASAN has three modes:\n\n\t  1. Generic KASAN (supported by many architectures, enabled with\n\t     CONFIG_KASAN_GENERIC, similar to userspace ASan),\n\t  2. Software Tag-Based KASAN (arm64 only, based on software memory\n\t     tagging, enabled with CONFIG_KASAN_SW_TAGS, similar to userspace\n\t     HWASan), and\n\t  3. Hardware Tag-Based KASAN (arm64 only, based on hardware memory\n\t     tagging, enabled with CONFIG_KASAN_HW_TAGS).\n\n\t  See Documentation/dev-tools/kasan.rst for details about each mode.\n\nconfig KASAN_GENERIC\n\tbool \"Generic KASAN\"\n\tdepends on HAVE_ARCH_KASAN && CC_HAS_KASAN_GENERIC\n\tdepends on CC_HAS_WORKING_NOSANITIZE_ADDRESS\n\tselect SLUB_DEBUG if SLUB\n\tselect CONSTRUCTORS\n\thelp\n\t  Enables Generic KASAN.\n\n\t  Requires GCC 8.3.0+ or Clang.\n\n\t  Consumes about 1/8th of available memory at kernel start and adds an\n\t  overhead of ~50% for dynamic allocations.\n\t  The performance slowdown is ~x3.\n\n\t  (Incompatible with CONFIG_DEBUG_SLAB: the kernel does not boot.)\n\nconfig KASAN_SW_TAGS\n\tbool \"Software Tag-Based KASAN\"\n\tdepends on HAVE_ARCH_KASAN_SW_TAGS && CC_HAS_KASAN_SW_TAGS\n\tdepends on CC_HAS_WORKING_NOSANITIZE_ADDRESS\n\tselect SLUB_DEBUG if SLUB\n\tselect CONSTRUCTORS\n\thelp\n\t  Enables Software Tag-Based KASAN.\n\n\t  Requires GCC 11+ or Clang.\n\n\t  Supported only on arm64 CPUs and relies on Top Byte Ignore.\n\n\t  Consumes about 1/16th of available memory at kernel start and\n\t  add an overhead of ~20% for dynamic allocations.\n\n\t  May potentially introduce problems related to pointer casting and\n\t  comparison, as it embeds a tag into the top byte of each pointer.\n\n\t  (Incompatible with CONFIG_DEBUG_SLAB: the kernel does not boot.)\n\nconfig KASAN_HW_TAGS\n\tbool \"Hardware Tag-Based KASAN\"\n\tdepends on HAVE_ARCH_KASAN_HW_TAGS\n\tdepends on SLUB\n\thelp\n\t  Enables Hardware Tag-Based KASAN.\n\n\t  Requires GCC 10+ or Clang 12+.\n\n\t  Supported only on arm64 CPUs starting from ARMv8.5 and relies on\n\t  Memory Tagging Extension and Top Byte Ignore.\n\n\t  Consumes about 1/32nd of available memory.\n\n\t  May potentially introduce problems related to pointer casting and\n\t  comparison, as it embeds a tag into the top byte of each pointer.\n\nendchoice\n\nchoice\n\tprompt \"Instrumentation type\"\n\tdepends on KASAN_GENERIC || KASAN_SW_TAGS\n\tdefault KASAN_OUTLINE\n\nconfig KASAN_OUTLINE\n\tbool \"Outline instrumentation\"\n\thelp\n\t  Makes the compiler insert function calls that check whether the memory\n\t  is accessible before each memory access. Slower than KASAN_INLINE, but\n\t  does not bloat the size of the kernel's .text section so much.\n\nconfig KASAN_INLINE\n\tbool \"Inline instrumentation\"\n\tdepends on !ARCH_DISABLE_KASAN_INLINE\n\thelp\n\t  Makes the compiler directly insert memory accessibility checks before\n\t  each memory access. Faster than KASAN_OUTLINE (gives ~x2 boost for\n\t  some workloads), but makes the kernel's .text size much bigger.\n\nendchoice\n\nconfig KASAN_STACK\n\tbool \"Stack instrumentation (unsafe)\" if CC_IS_CLANG && !COMPILE_TEST\n\tdepends on KASAN_GENERIC || KASAN_SW_TAGS\n\tdepends on !ARCH_DISABLE_KASAN_INLINE\n\tdefault y if CC_IS_GCC\n\thelp\n\t  Disables stack instrumentation and thus KASAN's ability to detect\n\t  out-of-bounds bugs in stack variables.\n\n\t  With Clang, stack instrumentation has a problem that causes excessive\n\t  stack usage, see https://bugs.llvm.org/show_bug.cgi?id=38809. Thus,\n\t  with Clang, this option is deemed unsafe.\n\n\t  This option is always disabled when compile-testing with Clang to\n\t  avoid cluttering the log with stack overflow warnings.\n\n\t  With GCC, enabling stack instrumentation is assumed to be safe.\n\n\t  If the architecture disables inline instrumentation via\n\t  ARCH_DISABLE_KASAN_INLINE, stack instrumentation gets disabled\n\t  as well, as it adds inline-style instrumentation that is run\n\t  unconditionally.\n\nconfig KASAN_VMALLOC\n\tbool \"Check accesses to vmalloc allocations\"\n\tdepends on HAVE_ARCH_KASAN_VMALLOC\n\thelp\n\t  Makes KASAN check the validity of accesses to vmalloc allocations.\n\n\t  With software KASAN modes, all types vmalloc allocations are\n\t  checked. Enabling this option leads to higher memory usage.\n\n\t  With Hardware Tag-Based KASAN, only non-executable VM_ALLOC mappings\n\t  are checked. There is no additional memory usage.\n\nconfig KASAN_KUNIT_TEST\n\ttristate \"KUnit-compatible tests of KASAN bug detection capabilities\" if !KUNIT_ALL_TESTS\n\tdepends on KASAN && KUNIT && TRACEPOINTS\n\tdefault KUNIT_ALL_TESTS\n\thelp\n\t  A KUnit-based KASAN test suite. Triggers different kinds of\n\t  out-of-bounds and use-after-free accesses. Useful for testing whether\n\t  KASAN can detect certain bug types.\n\n\t  For more information on KUnit and unit tests in general, please refer\n\t  to the KUnit documentation in Documentation/dev-tools/kunit/.\n\nconfig KASAN_MODULE_TEST\n\ttristate \"KUnit-incompatible tests of KASAN bug detection capabilities\"\n\tdepends on m && KASAN && !KASAN_HW_TAGS\n\thelp\n\t  A part of the KASAN test suite that is not integrated with KUnit.\n\t  Incompatible with Hardware Tag-Based KASAN.\n\nendif # KASAN\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}