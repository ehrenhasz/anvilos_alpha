{
  "module_name": "ts_bm.c",
  "hash_id": "2a33a6168ae34206b91c651044dc545acc5ea2a1fca0b45f20401e39e338d65f",
  "original_prompt": "Ingested from linux-6.6.14/lib/ts_bm.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/textsearch.h>\n\n \n#define ASIZE 256\n\n#if 0\n#define DEBUGP printk\n#else\n#define DEBUGP(args, format...)\n#endif\n\nstruct ts_bm\n{\n\tu8 *\t\tpattern;\n\tunsigned int\tpatlen;\n\tunsigned int \tbad_shift[ASIZE];\n\tunsigned int\tgood_shift[];\n};\n\nstatic unsigned int matchpat(const u8 *pattern, unsigned int patlen,\n\t\t\t     const u8 *text, bool icase)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < patlen; i++) {\n\t\tu8 t = *(text-i);\n\n\t\tif (icase)\n\t\t\tt = toupper(t);\n\n\t\tif (t != *(pattern-i))\n\t\t\tbreak;\n\t}\n\n\treturn i;\n}\n\nstatic unsigned int bm_find(struct ts_config *conf, struct ts_state *state)\n{\n\tstruct ts_bm *bm = ts_config_priv(conf);\n\tunsigned int i, text_len, consumed = state->offset;\n\tconst u8 *text;\n\tint bs;\n\tconst u8 icase = conf->flags & TS_IGNORECASE;\n\n\tfor (;;) {\n\t\tint shift = bm->patlen - 1;\n\n\t\ttext_len = conf->get_next_block(consumed, &text, conf, state);\n\n\t\tif (unlikely(text_len == 0))\n\t\t\tbreak;\n\n\t\twhile (shift < text_len) {\n\t\t\tDEBUGP(\"Searching in position %d (%c)\\n\",\n\t\t\t       shift, text[shift]);\n\n\t\t\ti = matchpat(&bm->pattern[bm->patlen-1], bm->patlen,\n\t\t\t\t     &text[shift], icase);\n\t\t\tif (i == bm->patlen) {\n\t\t\t\t \n\t\t\t\tDEBUGP(\"found!\\n\");\n\t\t\t\treturn consumed + (shift-(bm->patlen-1));\n\t\t\t}\n\n\t\t\tbs = bm->bad_shift[text[shift-i]];\n\n\t\t\t \n\t\t\tshift = max_t(int, shift-i+bs, shift+bm->good_shift[i]);\n\t\t}\n\t\tconsumed += text_len;\n\t}\n\n\treturn UINT_MAX;\n}\n\nstatic int subpattern(u8 *pattern, int i, int j, int g)\n{\n\tint x = i+g-1, y = j+g-1, ret = 0;\n\n\twhile(pattern[x--] == pattern[y--]) {\n\t\tif (y < 0) {\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (--g == 0) {\n\t\t\tret = pattern[i-1] != pattern[j-1];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic void compute_prefix_tbl(struct ts_bm *bm, int flags)\n{\n\tint i, j, g;\n\n\tfor (i = 0; i < ASIZE; i++)\n\t\tbm->bad_shift[i] = bm->patlen;\n\tfor (i = 0; i < bm->patlen - 1; i++) {\n\t\tbm->bad_shift[bm->pattern[i]] = bm->patlen - 1 - i;\n\t\tif (flags & TS_IGNORECASE)\n\t\t\tbm->bad_shift[tolower(bm->pattern[i])]\n\t\t\t    = bm->patlen - 1 - i;\n\t}\n\n\t \n\tbm->good_shift[0] = 1;\n\tfor (i = 1; i < bm->patlen; i++)\n\t\tbm->good_shift[i] = bm->patlen;\n        for (i = bm->patlen-1, g = 1; i > 0; g++, i--) {\n\t\tfor (j = i-1; j >= 1-g ; j--)\n\t\t\tif (subpattern(bm->pattern, i, j, g)) {\n\t\t\t\tbm->good_shift[g] = bm->patlen-j-g;\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n}\n\nstatic struct ts_config *bm_init(const void *pattern, unsigned int len,\n\t\t\t\t gfp_t gfp_mask, int flags)\n{\n\tstruct ts_config *conf;\n\tstruct ts_bm *bm;\n\tint i;\n\tunsigned int prefix_tbl_len = len * sizeof(unsigned int);\n\tsize_t priv_size = sizeof(*bm) + len + prefix_tbl_len;\n\n\tconf = alloc_ts_config(priv_size, gfp_mask);\n\tif (IS_ERR(conf))\n\t\treturn conf;\n\n\tconf->flags = flags;\n\tbm = ts_config_priv(conf);\n\tbm->patlen = len;\n\tbm->pattern = (u8 *) bm->good_shift + prefix_tbl_len;\n\tif (flags & TS_IGNORECASE)\n\t\tfor (i = 0; i < len; i++)\n\t\t\tbm->pattern[i] = toupper(((u8 *)pattern)[i]);\n\telse\n\t\tmemcpy(bm->pattern, pattern, len);\n\tcompute_prefix_tbl(bm, flags);\n\n\treturn conf;\n}\n\nstatic void *bm_get_pattern(struct ts_config *conf)\n{\n\tstruct ts_bm *bm = ts_config_priv(conf);\n\treturn bm->pattern;\n}\n\nstatic unsigned int bm_get_pattern_len(struct ts_config *conf)\n{\n\tstruct ts_bm *bm = ts_config_priv(conf);\n\treturn bm->patlen;\n}\n\nstatic struct ts_ops bm_ops = {\n\t.name\t\t  = \"bm\",\n\t.find\t\t  = bm_find,\n\t.init\t\t  = bm_init,\n\t.get_pattern\t  = bm_get_pattern,\n\t.get_pattern_len  = bm_get_pattern_len,\n\t.owner\t\t  = THIS_MODULE,\n\t.list\t\t  = LIST_HEAD_INIT(bm_ops.list)\n};\n\nstatic int __init init_bm(void)\n{\n\treturn textsearch_register(&bm_ops);\n}\n\nstatic void __exit exit_bm(void)\n{\n\ttextsearch_unregister(&bm_ops);\n}\n\nMODULE_LICENSE(\"GPL\");\n\nmodule_init(init_bm);\nmodule_exit(exit_bm);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}