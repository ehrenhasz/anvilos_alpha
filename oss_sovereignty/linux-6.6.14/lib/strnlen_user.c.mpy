{
  "module_name": "strnlen_user.c",
  "hash_id": "3cc73b8241c335a3178439dbd2df69bbec4c6b530cbf12cad2f22d8704a74176",
  "original_prompt": "Ingested from linux-6.6.14/lib/strnlen_user.c",
  "human_readable_source": "\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/uaccess.h>\n#include <linux/mm.h>\n#include <linux/bitops.h>\n\n#include <asm/word-at-a-time.h>\n\n \nstatic __always_inline long do_strnlen_user(const char __user *src, unsigned long count, unsigned long max)\n{\n\tconst struct word_at_a_time constants = WORD_AT_A_TIME_CONSTANTS;\n\tunsigned long align, res = 0;\n\tunsigned long c;\n\n\t \n\talign = (sizeof(unsigned long) - 1) & (unsigned long)src;\n\tsrc -= align;\n\tmax += align;\n\n\tunsafe_get_user(c, (unsigned long __user *)src, efault);\n\tc |= aligned_byte_mask(align);\n\n\tfor (;;) {\n\t\tunsigned long data;\n\t\tif (has_zero(c, &data, &constants)) {\n\t\t\tdata = prep_zero_mask(c, data, &constants);\n\t\t\tdata = create_zero_mask(data);\n\t\t\treturn res + find_zero(data) + 1 - align;\n\t\t}\n\t\tres += sizeof(unsigned long);\n\t\t \n\t\tif (unlikely(max <= sizeof(unsigned long)))\n\t\t\tbreak;\n\t\tmax -= sizeof(unsigned long);\n\t\tunsafe_get_user(c, (unsigned long __user *)(src+res), efault);\n\t}\n\tres -= align;\n\n\t \n\tif (res >= count)\n\t\treturn count+1;\n\n\t \nefault:\n\treturn 0;\n}\n\n \nlong strnlen_user(const char __user *str, long count)\n{\n\tunsigned long max_addr, src_addr;\n\n\tif (unlikely(count <= 0))\n\t\treturn 0;\n\n\tmax_addr = TASK_SIZE_MAX;\n\tsrc_addr = (unsigned long)untagged_addr(str);\n\tif (likely(src_addr < max_addr)) {\n\t\tunsigned long max = max_addr - src_addr;\n\t\tlong retval;\n\n\t\t \n\t\tif (max > count)\n\t\t\tmax = count;\n\n\t\tif (user_read_access_begin(str, max)) {\n\t\t\tretval = do_strnlen_user(str, count, max);\n\t\t\tuser_read_access_end();\n\t\t\treturn retval;\n\t\t}\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL(strnlen_user);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}