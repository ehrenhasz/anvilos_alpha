{
  "module_name": "test_maple_tree.c",
  "hash_id": "2c29a95016d8581063ecdeb6fdaa19f167bc88ef4fb2ab5d5acae0b07314a538",
  "original_prompt": "Ingested from linux-6.6.14/lib/test_maple_tree.c",
  "human_readable_source": "\n \n\n#include <linux/maple_tree.h>\n#include <linux/module.h>\n#include <linux/rwsem.h>\n\n#define MTREE_ALLOC_MAX 0x2000000000000Ul\n#define CONFIG_MAPLE_SEARCH\n#define MAPLE_32BIT (MAPLE_NODE_SLOTS > 31)\n\n#ifndef CONFIG_DEBUG_MAPLE_TREE\n#define mt_dump(mt, fmt)\t\tdo {} while (0)\n#define mt_validate(mt)\t\t\tdo {} while (0)\n#define mt_cache_shrink()\t\tdo {} while (0)\n#define mas_dump(mas)\t\t\tdo {} while (0)\n#define mas_wr_dump(mas)\t\tdo {} while (0)\natomic_t maple_tree_tests_run;\natomic_t maple_tree_tests_passed;\n#undef MT_BUG_ON\n\n#define MT_BUG_ON(__tree, __x) do {\t\t\t\t\t\\\n\tatomic_inc(&maple_tree_tests_run);\t\t\t\t\\\n\tif (__x) {\t\t\t\t\t\t\t\\\n\t\tpr_info(\"BUG at %s:%d (%u)\\n\",\t\t\t\t\\\n\t\t__func__, __LINE__, __x);\t\t\t\t\\\n\t\tpr_info(\"Pass: %u Run:%u\\n\",\t\t\t\t\\\n\t\t\tatomic_read(&maple_tree_tests_passed),\t\t\\\n\t\t\tatomic_read(&maple_tree_tests_run));\t\t\\\n\t} else {\t\t\t\t\t\t\t\\\n\t\tatomic_inc(&maple_tree_tests_passed);\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n} while (0)\n#endif\n\n \n \n \n \n \n \n \n \n\n#ifdef __KERNEL__\n#define mt_set_non_kernel(x)\t\tdo {} while (0)\n#define mt_zero_nr_tallocated(x)\tdo {} while (0)\n#else\n#define cond_resched()\t\t\tdo {} while (0)\n#endif\nstatic int __init mtree_insert_index(struct maple_tree *mt,\n\t\t\t\t     unsigned long index, gfp_t gfp)\n{\n\treturn mtree_insert(mt, index, xa_mk_value(index & LONG_MAX), gfp);\n}\n\nstatic void __init mtree_erase_index(struct maple_tree *mt, unsigned long index)\n{\n\tMT_BUG_ON(mt, mtree_erase(mt, index) != xa_mk_value(index & LONG_MAX));\n\tMT_BUG_ON(mt, mtree_load(mt, index) != NULL);\n}\n\nstatic int __init mtree_test_insert(struct maple_tree *mt, unsigned long index,\n\t\t\t\tvoid *ptr)\n{\n\treturn mtree_insert(mt, index, ptr, GFP_KERNEL);\n}\n\nstatic int __init mtree_test_store_range(struct maple_tree *mt,\n\t\t\tunsigned long start, unsigned long end, void *ptr)\n{\n\treturn mtree_store_range(mt, start, end, ptr, GFP_KERNEL);\n}\n\nstatic int __init mtree_test_store(struct maple_tree *mt, unsigned long start,\n\t\t\t\tvoid *ptr)\n{\n\treturn mtree_test_store_range(mt, start, start, ptr);\n}\n\nstatic int __init mtree_test_insert_range(struct maple_tree *mt,\n\t\t\tunsigned long start, unsigned long end, void *ptr)\n{\n\treturn mtree_insert_range(mt, start, end, ptr, GFP_KERNEL);\n}\n\nstatic void __init *mtree_test_load(struct maple_tree *mt, unsigned long index)\n{\n\treturn mtree_load(mt, index);\n}\n\nstatic void __init *mtree_test_erase(struct maple_tree *mt, unsigned long index)\n{\n\treturn mtree_erase(mt, index);\n}\n\n#if defined(CONFIG_64BIT)\nstatic noinline void __init check_mtree_alloc_range(struct maple_tree *mt,\n\t\tunsigned long start, unsigned long end, unsigned long size,\n\t\tunsigned long expected, int eret, void *ptr)\n{\n\n\tunsigned long result = expected + 1;\n\tint ret;\n\n\tret = mtree_alloc_range(mt, &result, ptr, size, start, end,\n\t\t\tGFP_KERNEL);\n\tMT_BUG_ON(mt, ret != eret);\n\tif (ret)\n\t\treturn;\n\n\tMT_BUG_ON(mt, result != expected);\n}\n\nstatic noinline void __init check_mtree_alloc_rrange(struct maple_tree *mt,\n\t\tunsigned long start, unsigned long end, unsigned long size,\n\t\tunsigned long expected, int eret, void *ptr)\n{\n\n\tunsigned long result = expected + 1;\n\tint ret;\n\n\tret = mtree_alloc_rrange(mt, &result, ptr, size, start, end,\n\t\t\tGFP_KERNEL);\n\tMT_BUG_ON(mt, ret != eret);\n\tif (ret)\n\t\treturn;\n\n\tMT_BUG_ON(mt, result != expected);\n}\n#endif\n\nstatic noinline void __init check_load(struct maple_tree *mt,\n\t\t\t\t       unsigned long index, void *ptr)\n{\n\tvoid *ret = mtree_test_load(mt, index);\n\n\tif (ret != ptr)\n\t\tpr_err(\"Load %lu returned %p expect %p\\n\", index, ret, ptr);\n\tMT_BUG_ON(mt, ret != ptr);\n}\n\nstatic noinline void __init check_store_range(struct maple_tree *mt,\n\t\tunsigned long start, unsigned long end, void *ptr, int expected)\n{\n\tint ret = -EINVAL;\n\tunsigned long i;\n\n\tret = mtree_test_store_range(mt, start, end, ptr);\n\tMT_BUG_ON(mt, ret != expected);\n\n\tif (ret)\n\t\treturn;\n\n\tfor (i = start; i <= end; i++)\n\t\tcheck_load(mt, i, ptr);\n}\n\nstatic noinline void __init check_insert_range(struct maple_tree *mt,\n\t\tunsigned long start, unsigned long end, void *ptr, int expected)\n{\n\tint ret = -EINVAL;\n\tunsigned long i;\n\n\tret = mtree_test_insert_range(mt, start, end, ptr);\n\tMT_BUG_ON(mt, ret != expected);\n\n\tif (ret)\n\t\treturn;\n\n\tfor (i = start; i <= end; i++)\n\t\tcheck_load(mt, i, ptr);\n}\n\nstatic noinline void __init check_insert(struct maple_tree *mt,\n\t\t\t\t\t unsigned long index, void *ptr)\n{\n\tint ret = -EINVAL;\n\n\tret = mtree_test_insert(mt, index, ptr);\n\tMT_BUG_ON(mt, ret != 0);\n}\n\nstatic noinline void __init check_dup_insert(struct maple_tree *mt,\n\t\t\t\t      unsigned long index, void *ptr)\n{\n\tint ret = -EINVAL;\n\n\tret = mtree_test_insert(mt, index, ptr);\n\tMT_BUG_ON(mt, ret != -EEXIST);\n}\n\n\nstatic noinline void __init check_index_load(struct maple_tree *mt,\n\t\t\t\t\t     unsigned long index)\n{\n\treturn check_load(mt, index, xa_mk_value(index & LONG_MAX));\n}\n\nstatic inline __init int not_empty(struct maple_node *node)\n{\n\tint i;\n\n\tif (node->parent)\n\t\treturn 1;\n\n\tfor (i = 0; i < ARRAY_SIZE(node->slot); i++)\n\t\tif (node->slot[i])\n\t\t\treturn 1;\n\n\treturn 0;\n}\n\n\nstatic noinline void __init check_rev_seq(struct maple_tree *mt,\n\t\t\t\t\t  unsigned long max, bool verbose)\n{\n\tunsigned long i = max, j;\n\n\tMT_BUG_ON(mt, !mtree_empty(mt));\n\n\tmt_zero_nr_tallocated();\n\twhile (i) {\n\t\tMT_BUG_ON(mt, mtree_insert_index(mt, i, GFP_KERNEL));\n\t\tfor (j = i; j <= max; j++)\n\t\t\tcheck_index_load(mt, j);\n\n\t\tcheck_load(mt, i - 1, NULL);\n\t\tmt_set_in_rcu(mt);\n\t\tMT_BUG_ON(mt, !mt_height(mt));\n\t\tmt_clear_in_rcu(mt);\n\t\tMT_BUG_ON(mt, !mt_height(mt));\n\t\ti--;\n\t}\n\tcheck_load(mt, max + 1, NULL);\n\n#ifndef __KERNEL__\n\tif (verbose) {\n\t\trcu_barrier();\n\t\tmt_dump(mt, mt_dump_dec);\n\t\tpr_info(\" %s test of 0-%lu %luK in %d active (%d total)\\n\",\n\t\t\t__func__, max, mt_get_alloc_size()/1024, mt_nr_allocated(),\n\t\t\tmt_nr_tallocated());\n\t}\n#endif\n}\n\nstatic noinline void __init check_seq(struct maple_tree *mt, unsigned long max,\n\t\tbool verbose)\n{\n\tunsigned long i, j;\n\n\tMT_BUG_ON(mt, !mtree_empty(mt));\n\n\tmt_zero_nr_tallocated();\n\tfor (i = 0; i <= max; i++) {\n\t\tMT_BUG_ON(mt, mtree_insert_index(mt, i, GFP_KERNEL));\n\t\tfor (j = 0; j <= i; j++)\n\t\t\tcheck_index_load(mt, j);\n\n\t\tif (i)\n\t\t\tMT_BUG_ON(mt, !mt_height(mt));\n\t\tcheck_load(mt, i + 1, NULL);\n\t}\n\n#ifndef __KERNEL__\n\tif (verbose) {\n\t\trcu_barrier();\n\t\tmt_dump(mt, mt_dump_dec);\n\t\tpr_info(\" seq test of 0-%lu %luK in %d active (%d total)\\n\",\n\t\t\tmax, mt_get_alloc_size()/1024, mt_nr_allocated(),\n\t\t\tmt_nr_tallocated());\n\t}\n#endif\n}\n\nstatic noinline void __init check_lb_not_empty(struct maple_tree *mt)\n{\n\tunsigned long i, j;\n\tunsigned long huge = 4000UL * 1000 * 1000;\n\n\n\ti = huge;\n\twhile (i > 4096) {\n\t\tcheck_insert(mt, i, (void *) i);\n\t\tfor (j = huge; j >= i; j /= 2) {\n\t\t\tcheck_load(mt, j-1, NULL);\n\t\t\tcheck_load(mt, j, (void *) j);\n\t\t\tcheck_load(mt, j+1, NULL);\n\t\t}\n\t\ti /= 2;\n\t}\n\tmtree_destroy(mt);\n}\n\nstatic noinline void __init check_lower_bound_split(struct maple_tree *mt)\n{\n\tMT_BUG_ON(mt, !mtree_empty(mt));\n\tcheck_lb_not_empty(mt);\n}\n\nstatic noinline void __init check_upper_bound_split(struct maple_tree *mt)\n{\n\tunsigned long i, j;\n\tunsigned long huge;\n\n\tMT_BUG_ON(mt, !mtree_empty(mt));\n\n\tif (MAPLE_32BIT)\n\t\thuge = 2147483647UL;\n\telse\n\t\thuge = 4000UL * 1000 * 1000;\n\n\ti = 4096;\n\twhile (i < huge) {\n\t\tcheck_insert(mt, i, (void *) i);\n\t\tfor (j = i; j >= huge; j *= 2) {\n\t\t\tcheck_load(mt, j-1, NULL);\n\t\t\tcheck_load(mt, j, (void *) j);\n\t\t\tcheck_load(mt, j+1, NULL);\n\t\t}\n\t\ti *= 2;\n\t}\n\tmtree_destroy(mt);\n}\n\nstatic noinline void __init check_mid_split(struct maple_tree *mt)\n{\n\tunsigned long huge = 8000UL * 1000 * 1000;\n\n\tcheck_insert(mt, huge, (void *) huge);\n\tcheck_insert(mt, 0, xa_mk_value(0));\n\tcheck_lb_not_empty(mt);\n}\n\nstatic noinline void __init check_rev_find(struct maple_tree *mt)\n{\n\tint i, nr_entries = 200;\n\tvoid *val;\n\tMA_STATE(mas, mt, 0, 0);\n\n\tfor (i = 0; i <= nr_entries; i++)\n\t\tmtree_store_range(mt, i*10, i*10 + 5,\n\t\t\t\t  xa_mk_value(i), GFP_KERNEL);\n\n\trcu_read_lock();\n\tmas_set(&mas, 1000);\n\tval = mas_find_rev(&mas, 1000);\n\tMT_BUG_ON(mt, val != xa_mk_value(100));\n\tval = mas_find_rev(&mas, 1000);\n\tMT_BUG_ON(mt, val != NULL);\n\n\tmas_set(&mas, 999);\n\tval = mas_find_rev(&mas, 997);\n\tMT_BUG_ON(mt, val != NULL);\n\n\tmas_set(&mas, 1000);\n\tval = mas_find_rev(&mas, 900);\n\tMT_BUG_ON(mt, val != xa_mk_value(100));\n\tval = mas_find_rev(&mas, 900);\n\tMT_BUG_ON(mt, val != xa_mk_value(99));\n\n\tmas_set(&mas, 20);\n\tval = mas_find_rev(&mas, 0);\n\tMT_BUG_ON(mt, val != xa_mk_value(2));\n\tval = mas_find_rev(&mas, 0);\n\tMT_BUG_ON(mt, val != xa_mk_value(1));\n\tval = mas_find_rev(&mas, 0);\n\tMT_BUG_ON(mt, val != xa_mk_value(0));\n\tval = mas_find_rev(&mas, 0);\n\tMT_BUG_ON(mt, val != NULL);\n\trcu_read_unlock();\n}\n\nstatic noinline void __init check_find(struct maple_tree *mt)\n{\n\tunsigned long val = 0;\n\tunsigned long count;\n\tunsigned long max;\n\tunsigned long top;\n\tunsigned long last = 0, index = 0;\n\tvoid *entry, *entry2;\n\n\tMA_STATE(mas, mt, 0, 0);\n\n\t \n\tMT_BUG_ON(mt, mtree_insert_index(mt, val++, GFP_KERNEL));\n\n#if defined(CONFIG_64BIT)\n\ttop = 4398046511104UL;\n#else\n\ttop = ULONG_MAX;\n#endif\n\n\tif (MAPLE_32BIT) {\n\t\tcount = 15;\n\t} else {\n\t\tcount = 20;\n\t}\n\n\tfor (int i = 0; i <= count; i++) {\n\t\tif (val != 64)\n\t\t\tMT_BUG_ON(mt, mtree_insert_index(mt, val, GFP_KERNEL));\n\t\telse\n\t\t\tMT_BUG_ON(mt, mtree_insert(mt, val,\n\t\t\t\tXA_ZERO_ENTRY, GFP_KERNEL));\n\n\t\tval <<= 2;\n\t}\n\n\tval = 0;\n\tmas_set(&mas, val);\n\tmas_lock(&mas);\n\twhile ((entry = mas_find(&mas, 268435456)) != NULL) {\n\t\tif (val != 64)\n\t\t\tMT_BUG_ON(mt, xa_mk_value(val) != entry);\n\t\telse\n\t\t\tMT_BUG_ON(mt, entry != XA_ZERO_ENTRY);\n\n\t\tval <<= 2;\n\t\t \n\t\tif (!val)\n\t\t\tval = 1;\n\t}\n\tmas_unlock(&mas);\n\n\tval = 0;\n\tmas_set(&mas, val);\n\tmas_lock(&mas);\n\tmas_for_each(&mas, entry, ULONG_MAX) {\n\t\tif (val != 64)\n\t\t\tMT_BUG_ON(mt, xa_mk_value(val) != entry);\n\t\telse\n\t\t\tMT_BUG_ON(mt, entry != XA_ZERO_ENTRY);\n\t\tval <<= 2;\n\t\t \n\t\tif (!val)\n\t\t\tval = 1;\n\t}\n\tmas_unlock(&mas);\n\n\t \n\tval = 0;\n\tmas_set(&mas, val);\n\tmas_lock(&mas);\n\tmas_for_each(&mas, entry, ULONG_MAX) {\n\t\tif (val != 64)\n\t\t\tMT_BUG_ON(mt, xa_mk_value(val) != entry);\n\t\telse\n\t\t\tMT_BUG_ON(mt, entry != XA_ZERO_ENTRY);\n\t\tval <<= 2;\n\t\t \n\t\tif (!val)\n\t\t\tval = 1;\n\n\t\tmas_pause(&mas);\n\t\tmas_unlock(&mas);\n\t\tmas_lock(&mas);\n\t}\n\tmas_unlock(&mas);\n\n\tval = 0;\n\tmax = 300;  \n\tmt_for_each(mt, entry, index, max) {\n\t\tMT_BUG_ON(mt, xa_mk_value(val) != entry);\n\t\tval <<= 2;\n\t\tif (val == 64)  \n\t\t\tval <<= 2;\n\t\t \n\t\tif (!val)\n\t\t\tval = 1;\n\t}\n\n\tval = 0;\n\tmax = 0;\n\tindex = 0;\n\tMT_BUG_ON(mt, mtree_insert_index(mt, ULONG_MAX, GFP_KERNEL));\n\tmt_for_each(mt, entry, index, ULONG_MAX) {\n\t\tif (val == top)\n\t\t\tMT_BUG_ON(mt, entry != xa_mk_value(LONG_MAX));\n\t\telse\n\t\t\tMT_BUG_ON(mt, xa_mk_value(val) != entry);\n\n\t\t \n\t\tif ((val << 2) < val)\n\t\t\tval = ULONG_MAX;\n\t\telse\n\t\t\tval <<= 2;\n\n\t\tif (val == 64)  \n\t\t\tval <<= 2;\n\t\t \n\t\tif (!val)\n\t\t\tval = 1;\n\t\tmax++;\n\t\tMT_BUG_ON(mt, max > 25);\n\t}\n\tmtree_erase_index(mt, ULONG_MAX);\n\n\tmas_reset(&mas);\n\tindex = 17;\n\tentry = mt_find(mt, &index, 512);\n\tMT_BUG_ON(mt, xa_mk_value(256) != entry);\n\n\tmas_reset(&mas);\n\tindex = 17;\n\tentry = mt_find(mt, &index, 20);\n\tMT_BUG_ON(mt, entry != NULL);\n\n\n\t \n\t \n\tMT_BUG_ON(mt, mtree_insert_index(mt, ULONG_MAX, GFP_KERNEL));\n\n\tval = 0;\n\tmas_set(&mas, 0);\n\tmas_lock(&mas);\n\tmas_for_each(&mas, entry, ULONG_MAX) {\n\t\tif (val == 64)\n\t\t\tMT_BUG_ON(mt, entry != XA_ZERO_ENTRY);\n\t\telse if (val == top)\n\t\t\tMT_BUG_ON(mt, entry != xa_mk_value(LONG_MAX));\n\t\telse\n\t\t\tMT_BUG_ON(mt, xa_mk_value(val) != entry);\n\n\t\t \n\t\tif ((val << 2) < val)\n\t\t\tval = ULONG_MAX;\n\t\telse\n\t\t\tval <<= 2;\n\n\t\t \n\t\tif (!val)\n\t\t\tval = 1;\n\t\tmas_pause(&mas);\n\t\tmas_unlock(&mas);\n\t\tmas_lock(&mas);\n\t}\n\tmas_unlock(&mas);\n\n\tmas_set(&mas, 1048576);\n\tmas_lock(&mas);\n\tentry = mas_find(&mas, 1048576);\n\tmas_unlock(&mas);\n\tMT_BUG_ON(mas.tree, entry == NULL);\n\n\t \n\t \n\tmas_lock(&mas);\n\tmas_reset(&mas);\n\tmas.index = ULONG_MAX;  \n\tentry = mas_find(&mas, ULONG_MAX);\n\tentry = mas_prev(&mas, 0);\n\tindex = mas.index;\n\tlast = mas.last;\n\n\t \n\tmas_reset(&mas);\n\tmas.index = ULONG_MAX;\n\tmas.last = ULONG_MAX;\n\tmas_erase(&mas);\n\n\t \n\tmas_reset(&mas);\n\tentry2 = mas_prev(&mas, 0);\n\n\t \n\tMT_BUG_ON(mt, entry != entry2);\n\tMT_BUG_ON(mt, index != mas.index);\n\tMT_BUG_ON(mt, last != mas.last);\n\n\n\tmas.node = MAS_NONE;\n\tmas.index = ULONG_MAX;\n\tmas.last = ULONG_MAX;\n\tentry2 = mas_prev(&mas, 0);\n\tMT_BUG_ON(mt, entry != entry2);\n\n\tmas_set(&mas, 0);\n\tMT_BUG_ON(mt, mas_prev(&mas, 0) != NULL);\n\n\tmas_unlock(&mas);\n\tmtree_destroy(mt);\n}\n\nstatic noinline void __init check_find_2(struct maple_tree *mt)\n{\n\tunsigned long i, j;\n\tvoid *entry;\n\n\tMA_STATE(mas, mt, 0, 0);\n\trcu_read_lock();\n\tmas_for_each(&mas, entry, ULONG_MAX)\n\t\tMT_BUG_ON(mt, true);\n\trcu_read_unlock();\n\n\tfor (i = 0; i < 256; i++) {\n\t\tmtree_insert_index(mt, i, GFP_KERNEL);\n\t\tj = 0;\n\t\tmas_set(&mas, 0);\n\t\trcu_read_lock();\n\t\tmas_for_each(&mas, entry, ULONG_MAX) {\n\t\t\tMT_BUG_ON(mt, entry != xa_mk_value(j));\n\t\t\tj++;\n\t\t}\n\t\trcu_read_unlock();\n\t\tMT_BUG_ON(mt, j != i + 1);\n\t}\n\n\tfor (i = 0; i < 256; i++) {\n\t\tmtree_erase_index(mt, i);\n\t\tj = i + 1;\n\t\tmas_set(&mas, 0);\n\t\trcu_read_lock();\n\t\tmas_for_each(&mas, entry, ULONG_MAX) {\n\t\t\tif (xa_is_zero(entry))\n\t\t\t\tcontinue;\n\n\t\t\tMT_BUG_ON(mt, entry != xa_mk_value(j));\n\t\t\tj++;\n\t\t}\n\t\trcu_read_unlock();\n\t\tMT_BUG_ON(mt, j != 256);\n\t}\n\n\t \n}\n\n\n#if defined(CONFIG_64BIT)\nstatic noinline void __init check_alloc_rev_range(struct maple_tree *mt)\n{\n\t \n\n\tstatic const unsigned long range[] = {\n\t \n\t\t0x565234af2000, 0x565234af4000,\n\t\t0x565234af4000, 0x565234af9000,\n\t\t0x565234af9000, 0x565234afb000,\n\t\t0x565234afc000, 0x565234afd000,\n\t\t0x565234afd000, 0x565234afe000,\n\t\t0x565235def000, 0x565235e10000,\n\t\t0x7f36d4bfd000, 0x7f36d4ee2000,\n\t\t0x7f36d4ee2000, 0x7f36d4f04000,\n\t\t0x7f36d4f04000, 0x7f36d504c000,\n\t\t0x7f36d504c000, 0x7f36d5098000,\n\t\t0x7f36d5098000, 0x7f36d5099000,\n\t\t0x7f36d5099000, 0x7f36d509d000,\n\t\t0x7f36d509d000, 0x7f36d509f000,\n\t\t0x7f36d509f000, 0x7f36d50a5000,\n\t\t0x7f36d50b9000, 0x7f36d50db000,\n\t\t0x7f36d50db000, 0x7f36d50dc000,\n\t\t0x7f36d50dc000, 0x7f36d50fa000,\n\t\t0x7f36d50fa000, 0x7f36d5102000,\n\t\t0x7f36d5102000, 0x7f36d5103000,\n\t\t0x7f36d5103000, 0x7f36d5104000,\n\t\t0x7f36d5104000, 0x7f36d5105000,\n\t\t0x7fff5876b000, 0x7fff5878d000,\n\t\t0x7fff5878e000, 0x7fff58791000,\n\t\t0x7fff58791000, 0x7fff58793000,\n\t};\n\n\tstatic const unsigned long holes[] = {\n\t\t \n\t\t0x565234afb000, 0x565234afc000, 0x1000,\n\t\t0x565234afe000, 0x565235def000, 0x12F1000,\n\t\t0x565235e10000, 0x7f36d4bfd000, 0x28E49EDED000,\n\t};\n\n\t \n\tstatic const unsigned long req_range[] = {\n\t\t0x565234af9000,  \n\t\t0x7fff58791000,  \n\t\t0x1000,          \n\t\t0x7fff5878d << 12,   \n\t\t0,               \n\n\t\t0x0,             \n\t\t0x565234AF0 << 12,     \n\t\t0x3000,          \n\t\t0x565234AEE << 12,   \n\t\t0,               \n\n\t\t0x0,             \n\t\t-1,              \n\t\t0x1000,          \n\t\t562949953421311 << 12, \n\t\t0,               \n\n\t\t0x0,             \n\t\t0x7F36D5109 << 12,     \n\t\t0x4000,          \n\t\t0x7F36D5106 << 12,     \n\t\t0,               \n\n\t\t \n\t\t0x0,\n\t\t34148798628 << 12,\n\t\t19 << 12,\n\t\t34148797418 << 12,\n\t\t0x0,\n\n\t\t \n\t\t0x0,\n\t\t18446744073709551615UL,\n\t\t562915594369134UL << 12,\n\t\t0x0,\n\t\t-EBUSY,\n\n\t\t \n\t\t34148798725 << 12,\n\t\t34148798725 << 12,\n\t\t1 << 12,\n\t\t34148798725 << 12,\n\t\t0,\n\t};\n\n\tint i, range_count = ARRAY_SIZE(range);\n\tint req_range_count = ARRAY_SIZE(req_range);\n\tunsigned long min = 0;\n\n\tMA_STATE(mas, mt, 0, 0);\n\n\tmtree_store_range(mt, MTREE_ALLOC_MAX, ULONG_MAX, XA_ZERO_ENTRY,\n\t\t\t  GFP_KERNEL);\n#define DEBUG_REV_RANGE 0\n\tfor (i = 0; i < range_count; i += 2) {\n\t\t \n\n#if DEBUG_REV_RANGE\n\t\tpr_debug(\"\\t%s: Insert %lu-%lu\\n\", __func__, range[i] >> 12,\n\t\t\t\t(range[i + 1] >> 12) - 1);\n#endif\n\t\tcheck_insert_range(mt, range[i] >> 12, (range[i + 1] >> 12) - 1,\n\t\t\t\txa_mk_value(range[i] >> 12), 0);\n\t\tmt_validate(mt);\n\t}\n\n\n\tmas_lock(&mas);\n\tfor (i = 0; i < ARRAY_SIZE(holes); i += 3) {\n#if DEBUG_REV_RANGE\n\t\tpr_debug(\"Search from %lu-%lu for gap %lu should be at %lu\\n\",\n\t\t\t\tmin, holes[i+1]>>12, holes[i+2]>>12,\n\t\t\t\tholes[i] >> 12);\n#endif\n\t\tMT_BUG_ON(mt, mas_empty_area_rev(&mas, min,\n\t\t\t\t\tholes[i+1] >> 12,\n\t\t\t\t\tholes[i+2] >> 12));\n#if DEBUG_REV_RANGE\n\t\tpr_debug(\"Found %lu %lu\\n\", mas.index, mas.last);\n\t\tpr_debug(\"gap %lu %lu\\n\", (holes[i] >> 12),\n\t\t\t\t(holes[i+1] >> 12));\n#endif\n\t\tMT_BUG_ON(mt, mas.last + 1 != (holes[i+1] >> 12));\n\t\tMT_BUG_ON(mt, mas.index != (holes[i+1] >> 12) - (holes[i+2] >> 12));\n\t\tmin = holes[i+1] >> 12;\n\t\tmas_reset(&mas);\n\t}\n\n\tmas_unlock(&mas);\n\tfor (i = 0; i < req_range_count; i += 5) {\n#if DEBUG_REV_RANGE\n\t\tpr_debug(\"\\tReverse request %d between %lu-%lu size %lu, should get %lu\\n\",\n\t\t\t\ti, req_range[i] >> 12,\n\t\t\t\t(req_range[i + 1] >> 12),\n\t\t\t\treq_range[i+2] >> 12,\n\t\t\t\treq_range[i+3] >> 12);\n#endif\n\t\tcheck_mtree_alloc_rrange(mt,\n\t\t\t\treq_range[i]   >> 12,  \n\t\t\t\treq_range[i+1] >> 12,  \n\t\t\t\treq_range[i+2] >> 12,  \n\t\t\t\treq_range[i+3] >> 12,  \n\t\t\t\treq_range[i+4],        \n\t\t\t\txa_mk_value(req_range[i] >> 12));  \n\t\tmt_validate(mt);\n\t}\n\n\tmt_set_non_kernel(1);\n\tmtree_erase(mt, 34148798727);  \n\tmtree_erase(mt, 34148798725);\n\tcheck_mtree_alloc_rrange(mt, 0, 34359052173, 210253414,\n\t\t\t34148798725, 0, mt);\n\n\tmtree_destroy(mt);\n}\n\nstatic noinline void __init check_alloc_range(struct maple_tree *mt)\n{\n\t \n\n\tstatic const unsigned long range[] = {\n\t \n\t\t0x565234af2000, 0x565234af4000,\n\t\t0x565234af4000, 0x565234af9000,\n\t\t0x565234af9000, 0x565234afb000,\n\t\t0x565234afc000, 0x565234afd000,\n\t\t0x565234afd000, 0x565234afe000,\n\t\t0x565235def000, 0x565235e10000,\n\t\t0x7f36d4bfd000, 0x7f36d4ee2000,\n\t\t0x7f36d4ee2000, 0x7f36d4f04000,\n\t\t0x7f36d4f04000, 0x7f36d504c000,\n\t\t0x7f36d504c000, 0x7f36d5098000,\n\t\t0x7f36d5098000, 0x7f36d5099000,\n\t\t0x7f36d5099000, 0x7f36d509d000,\n\t\t0x7f36d509d000, 0x7f36d509f000,\n\t\t0x7f36d509f000, 0x7f36d50a5000,\n\t\t0x7f36d50b9000, 0x7f36d50db000,\n\t\t0x7f36d50db000, 0x7f36d50dc000,\n\t\t0x7f36d50dc000, 0x7f36d50fa000,\n\t\t0x7f36d50fa000, 0x7f36d5102000,\n\t\t0x7f36d5102000, 0x7f36d5103000,\n\t\t0x7f36d5103000, 0x7f36d5104000,\n\t\t0x7f36d5104000, 0x7f36d5105000,\n\t\t0x7fff5876b000, 0x7fff5878d000,\n\t\t0x7fff5878e000, 0x7fff58791000,\n\t\t0x7fff58791000, 0x7fff58793000,\n\t};\n\tstatic const unsigned long holes[] = {\n\t\t \n\t\t0x565234afb000, 0x565234afc000, 0x1000,\n\t\t0x565234afe000, 0x565235def000, 0x12F1000,\n\t\t0x565235e10000, 0x7f36d4bfd000, 0x28E49EDED000,\n\t};\n\n\t \n\tstatic const unsigned long req_range[] = {\n\t\t0x565234af9000,  \n\t\t0x7fff58791000,  \n\t\t0x1000,          \n\t\t0x565234afb000,  \n\t\t0,               \n\n\t\t0x0,             \n\t\t0x7fff58791000,  \n\t\t0x1F00,          \n\t\t0x0,             \n\t\t0,               \n\n\t\t \n\t\t34148797436 << 12,  \n\t\t0x7fff587AF000,     \n\t\t0x3000,          \n\t\t34148798629 << 12,              \n\t\t0,               \n\n\t\t \n\t\t34148798623 << 12,   \n\t\t34148798683 << 12,   \n\t\t0x15000,             \n\t\t0,              \n\t\t-EBUSY,               \n\n\t\t \n\t\t34148798623 << 12,   \n\t\t0x7fff587AF000,     \n\t\t0x10000,            \n\t\t34148798632 << 12,              \n\t\t0,               \n\n\t\t \n\t\t0,                   \n\t\t-1,                  \n\t\t-1,                  \n\t\t0,                   \n\t\t-EBUSY,              \n\n\t\t \n\t\t0,                   \n\t\t-1,                  \n\t\t4503599618982063UL << 12,   \n\t\t34359052178 << 12,   \n\t\t-EBUSY,              \n\n\t\t \n\t\t34148798648 << 12,\t\t \n\t\t34148798648 << 12,\t\t \n\t\t4096,\t\t\t \n\t\t34148798648 << 12,\t \n\t\t0,\t\t\t \n\t};\n\tint i, range_count = ARRAY_SIZE(range);\n\tint req_range_count = ARRAY_SIZE(req_range);\n\tunsigned long min = 0x565234af2000;\n\tMA_STATE(mas, mt, 0, 0);\n\n\tmtree_store_range(mt, MTREE_ALLOC_MAX, ULONG_MAX, XA_ZERO_ENTRY,\n\t\t\t  GFP_KERNEL);\n\tfor (i = 0; i < range_count; i += 2) {\n#define DEBUG_ALLOC_RANGE 0\n#if DEBUG_ALLOC_RANGE\n\t\tpr_debug(\"\\tInsert %lu-%lu\\n\", range[i] >> 12,\n\t\t\t (range[i + 1] >> 12) - 1);\n\t\tmt_dump(mt, mt_dump_hex);\n#endif\n\t\tcheck_insert_range(mt, range[i] >> 12, (range[i + 1] >> 12) - 1,\n\t\t\t\txa_mk_value(range[i] >> 12), 0);\n\t\tmt_validate(mt);\n\t}\n\n\n\n\tmas_lock(&mas);\n\tfor (i = 0; i < ARRAY_SIZE(holes); i += 3) {\n\n#if DEBUG_ALLOC_RANGE\n\t\tpr_debug(\"\\tGet empty %lu-%lu size %lu (%lx-%lx)\\n\", min >> 12,\n\t\t\tholes[i+1] >> 12, holes[i+2] >> 12,\n\t\t\tmin, holes[i+1]);\n#endif\n\t\tMT_BUG_ON(mt, mas_empty_area(&mas, min >> 12,\n\t\t\t\t\tholes[i+1] >> 12,\n\t\t\t\t\tholes[i+2] >> 12));\n\t\tMT_BUG_ON(mt, mas.index != holes[i] >> 12);\n\t\tmin = holes[i+1];\n\t\tmas_reset(&mas);\n\t}\n\tmas_unlock(&mas);\n\tfor (i = 0; i < req_range_count; i += 5) {\n#if DEBUG_ALLOC_RANGE\n\t\tpr_debug(\"\\tTest %d: %lu-%lu size %lu expected %lu (%lu-%lu)\\n\",\n\t\t\t i/5, req_range[i]   >> 12, req_range[i + 1]   >> 12,\n\t\t\t req_range[i + 2]   >> 12, req_range[i + 3]   >> 12,\n\t\t\t req_range[i], req_range[i+1]);\n#endif\n\t\tcheck_mtree_alloc_range(mt,\n\t\t\t\treq_range[i]   >> 12,  \n\t\t\t\treq_range[i+1] >> 12,  \n\t\t\t\treq_range[i+2] >> 12,  \n\t\t\t\treq_range[i+3] >> 12,  \n\t\t\t\treq_range[i+4],        \n\t\t\t\txa_mk_value(req_range[i] >> 12));  \n\t\tmt_validate(mt);\n#if DEBUG_ALLOC_RANGE\n\t\tmt_dump(mt, mt_dump_hex);\n#endif\n\t}\n\n\tmtree_destroy(mt);\n}\n#endif\n\nstatic noinline void __init check_ranges(struct maple_tree *mt)\n{\n\tint i, val, val2;\n\tstatic const unsigned long r[] = {\n\t\t10, 15,\n\t\t20, 25,\n\t\t17, 22,  \n\t\t9, 1000,  \n\t\t100, 200,\n\t\t45, 168,\n\t\t118, 128,\n\t\t\t};\n\n\tMT_BUG_ON(mt, !mtree_empty(mt));\n\tcheck_insert_range(mt, r[0], r[1], xa_mk_value(r[0]), 0);\n\tcheck_insert_range(mt, r[2], r[3], xa_mk_value(r[2]), 0);\n\tcheck_insert_range(mt, r[4], r[5], xa_mk_value(r[4]), -EEXIST);\n\tMT_BUG_ON(mt, !mt_height(mt));\n\t \n\tcheck_store_range(mt, r[4], r[5], xa_mk_value(r[4]), 0);\n\tcheck_store_range(mt, r[6], r[7], xa_mk_value(r[6]), 0);\n\tcheck_store_range(mt, r[8], r[9], xa_mk_value(r[8]), 0);\n\tMT_BUG_ON(mt, !mt_height(mt));\n\tmtree_destroy(mt);\n\tMT_BUG_ON(mt, mt_height(mt));\n\n\tcheck_seq(mt, 50, false);\n\tmt_set_non_kernel(4);\n\tcheck_store_range(mt, 5, 47,  xa_mk_value(47), 0);\n\tMT_BUG_ON(mt, !mt_height(mt));\n\tmtree_destroy(mt);\n\n\t \n\tcheck_seq(mt, 100, false);\n\t \n\tmt_set_non_kernel(10);\n\tcheck_store_range(mt, r[10], r[11], xa_mk_value(r[10]), 0);\n\tMT_BUG_ON(mt, !mt_height(mt));\n\tmtree_destroy(mt);\n\n\t \n\tcheck_seq(mt, 200, false);\n\t \n\tcheck_store_range(mt, r[10], r[11], xa_mk_value(r[10]), 0);\n\tMT_BUG_ON(mt, !mt_height(mt));\n\tmtree_destroy(mt);\n\n\tcheck_seq(mt, 30, false);\n\tcheck_store_range(mt, 6, 18, xa_mk_value(6), 0);\n\tMT_BUG_ON(mt, !mt_height(mt));\n\tmtree_destroy(mt);\n\n\t \n\t \n\tcheck_seq(mt, 400, false);\n\tmt_set_non_kernel(50);\n\t \n\tcheck_store_range(mt, r[12], r[13], xa_mk_value(r[12]), 0);\n\tmt_set_non_kernel(50);\n\tmtree_test_erase(mt, 140);\n\tmtree_test_erase(mt, 141);\n\tmtree_test_erase(mt, 142);\n\tmtree_test_erase(mt, 143);\n\tmtree_test_erase(mt, 130);\n\tmtree_test_erase(mt, 131);\n\tmtree_test_erase(mt, 132);\n\tmtree_test_erase(mt, 133);\n\tmtree_test_erase(mt, 134);\n\tmtree_test_erase(mt, 135);\n\tcheck_load(mt, r[12], xa_mk_value(r[12]));\n\tcheck_load(mt, r[13], xa_mk_value(r[12]));\n\tcheck_load(mt, r[13] - 1, xa_mk_value(r[12]));\n\tcheck_load(mt, r[13] + 1, xa_mk_value(r[13] + 1));\n\tcheck_load(mt, 135, NULL);\n\tcheck_load(mt, 140, NULL);\n\tmt_set_non_kernel(0);\n\tMT_BUG_ON(mt, !mt_height(mt));\n\tmtree_destroy(mt);\n\n\n\n\t \n\tmt_set_non_kernel(50);\n\tcheck_seq(mt, 400, false);\n\tcheck_store_range(mt, 353, 361, xa_mk_value(353), 0);\n\tcheck_store_range(mt, 347, 352, xa_mk_value(347), 0);\n\n\tcheck_load(mt, 346, xa_mk_value(346));\n\tfor (i = 347; i <= 352; i++)\n\t\tcheck_load(mt, i, xa_mk_value(347));\n\tfor (i = 353; i <= 361; i++)\n\t\tcheck_load(mt, i, xa_mk_value(353));\n\tcheck_load(mt, 362, xa_mk_value(362));\n\tmt_set_non_kernel(0);\n\tMT_BUG_ON(mt, !mt_height(mt));\n\tmtree_destroy(mt);\n\n\tmt_set_non_kernel(50);\n\tcheck_seq(mt, 400, false);\n\tcheck_store_range(mt, 352, 364, NULL, 0);\n\tcheck_store_range(mt, 351, 363, xa_mk_value(352), 0);\n\tcheck_load(mt, 350, xa_mk_value(350));\n\tcheck_load(mt, 351, xa_mk_value(352));\n\tfor (i = 352; i <= 363; i++)\n\t\tcheck_load(mt, i, xa_mk_value(352));\n\tcheck_load(mt, 364, NULL);\n\tcheck_load(mt, 365, xa_mk_value(365));\n\tmt_set_non_kernel(0);\n\tMT_BUG_ON(mt, !mt_height(mt));\n\tmtree_destroy(mt);\n\n\tmt_set_non_kernel(5);\n\tcheck_seq(mt, 400, false);\n\tcheck_store_range(mt, 352, 364, NULL, 0);\n\tcheck_store_range(mt, 351, 364, xa_mk_value(352), 0);\n\tcheck_load(mt, 350, xa_mk_value(350));\n\tcheck_load(mt, 351, xa_mk_value(352));\n\tfor (i = 352; i <= 364; i++)\n\t\tcheck_load(mt, i, xa_mk_value(352));\n\tcheck_load(mt, 365, xa_mk_value(365));\n\tmt_set_non_kernel(0);\n\tMT_BUG_ON(mt, !mt_height(mt));\n\tmtree_destroy(mt);\n\n\n\tmt_set_non_kernel(50);\n\tcheck_seq(mt, 400, false);\n\tcheck_store_range(mt, 362, 367, xa_mk_value(362), 0);\n\tcheck_store_range(mt, 353, 361, xa_mk_value(353), 0);\n\tmt_set_non_kernel(0);\n\tmt_validate(mt);\n\tMT_BUG_ON(mt, !mt_height(mt));\n\tmtree_destroy(mt);\n\t \n\n\tmt_set_non_kernel(50);\n\tfor (i = 0; i <= 500; i++) {\n\t\tval = i*5;\n\t\tval2 = (i+1)*5;\n\t\tcheck_store_range(mt, val, val2, xa_mk_value(val), 0);\n\t}\n\tcheck_store_range(mt, 2400, 2400, xa_mk_value(2400), 0);\n\tcheck_store_range(mt, 2411, 2411, xa_mk_value(2411), 0);\n\tcheck_store_range(mt, 2412, 2412, xa_mk_value(2412), 0);\n\tcheck_store_range(mt, 2396, 2400, xa_mk_value(4052020), 0);\n\tcheck_store_range(mt, 2402, 2402, xa_mk_value(2402), 0);\n\tmtree_destroy(mt);\n\tmt_set_non_kernel(0);\n\n\tmt_set_non_kernel(50);\n\tfor (i = 0; i <= 500; i++) {\n\t\tval = i*5;\n\t\tval2 = (i+1)*5;\n\t\tcheck_store_range(mt, val, val2, xa_mk_value(val), 0);\n\t}\n\tcheck_store_range(mt, 2422, 2422, xa_mk_value(2422), 0);\n\tcheck_store_range(mt, 2424, 2424, xa_mk_value(2424), 0);\n\tcheck_store_range(mt, 2425, 2425, xa_mk_value(2), 0);\n\tcheck_store_range(mt, 2460, 2470, NULL, 0);\n\tcheck_store_range(mt, 2435, 2460, xa_mk_value(2435), 0);\n\tcheck_store_range(mt, 2461, 2470, xa_mk_value(2461), 0);\n\tmt_set_non_kernel(0);\n\tMT_BUG_ON(mt, !mt_height(mt));\n\tmtree_destroy(mt);\n\n\t \n\tmt_init_flags(mt, MT_FLAGS_ALLOC_RANGE);\n\t \n\tmt_set_non_kernel(50);\n\tfor (i = 0; i <= 500; i++) {\n\t\tval = i * 5 + 1;\n\t\tval2 = val + 4;\n\t\tcheck_store_range(mt, val, val2, xa_mk_value(val), 0);\n\t}\n\n\t \n\tfor (i = 0; i < 10; i++) {\n\t\tval = val2 + 5;\n\t\tval2 = val + 4;\n\t\tcheck_store_range(mt, val, val2, xa_mk_value(val), 0);\n\t}\n\n\t \n\tval = val2;\n\tfor (i = 0; i < 10; i++) {\n\t\tval += 5;\n\t\tMT_BUG_ON(mt, mtree_test_store_range(mt, val, ULONG_MAX,\n\t\t\t\t\t\t     xa_mk_value(val)) != 0);\n\t}\n\n\t \n\tfor (i = 10; i < 30; i += 2) {\n\t\tval = i * 5 + 1;\n\t\tval2 = val + 5;\n\t\tcheck_store_range(mt, val, val2, xa_mk_value(val), 0);\n\t}\n\n\t \n\tfor (i = 50; i < 70; i += 2) {\n\t\tval2 = i * 5;\n\t\tval = val2 - 5;\n\t\tcheck_store_range(mt, val, val2, xa_mk_value(val), 0);\n\t}\n\n\t \n\tfor (i = 100; i < 130; i += 3) {\n\t\tval = i * 5 - 5;\n\t\tval2 = i * 5 + 1;\n\t\tcheck_store_range(mt, val, val2, xa_mk_value(val), 0);\n\t}\n\n\t \n\tmt_set_in_rcu(mt);\n\tfor (i = 150; i < 180; i += 3) {\n\t\tval = i * 5 - 5;\n\t\tval2 = i * 5 + 1;\n\t\tcheck_store_range(mt, val, val2, xa_mk_value(val), 0);\n\t}\n\n\tMT_BUG_ON(mt, !mt_height(mt));\n\tmt_validate(mt);\n\tmt_set_non_kernel(0);\n\tmtree_destroy(mt);\n\n\t \n\tmt_init_flags(mt, MT_FLAGS_ALLOC_RANGE);\n\tmt_set_non_kernel(50);\n\tfor (i = 0; i <= 50; i++) {\n\t\tval = i*10;\n\t\tval2 = (i+1)*10;\n\t\tcheck_store_range(mt, val, val2, xa_mk_value(val), 0);\n\t}\n\tcheck_store_range(mt, 161, 161, xa_mk_value(161), 0);\n\tcheck_store_range(mt, 162, 162, xa_mk_value(162), 0);\n\tcheck_store_range(mt, 163, 163, xa_mk_value(163), 0);\n\tcheck_store_range(mt, 240, 249, NULL, 0);\n\tmtree_erase(mt, 200);\n\tmtree_erase(mt, 210);\n\tmtree_erase(mt, 220);\n\tmtree_erase(mt, 230);\n\tmt_set_non_kernel(0);\n\tMT_BUG_ON(mt, !mt_height(mt));\n\tmtree_destroy(mt);\n\n\tmt_init_flags(mt, MT_FLAGS_ALLOC_RANGE);\n\tfor (i = 0; i <= 500; i++) {\n\t\tval = i*10;\n\t\tval2 = (i+1)*10;\n\t\tcheck_store_range(mt, val, val2, xa_mk_value(val), 0);\n\t}\n\tcheck_store_range(mt, 4600, 4959, xa_mk_value(1), 0);\n\tmt_validate(mt);\n\tMT_BUG_ON(mt, !mt_height(mt));\n\tmtree_destroy(mt);\n\n\tmt_init_flags(mt, MT_FLAGS_ALLOC_RANGE);\n\tfor (i = 0; i <= 500; i++) {\n\t\tval = i*10;\n\t\tval2 = (i+1)*10;\n\t\tcheck_store_range(mt, val, val2, xa_mk_value(val), 0);\n\t}\n\tcheck_store_range(mt, 4811, 4811, xa_mk_value(4811), 0);\n\tcheck_store_range(mt, 4812, 4812, xa_mk_value(4812), 0);\n\tcheck_store_range(mt, 4861, 4861, xa_mk_value(4861), 0);\n\tcheck_store_range(mt, 4862, 4862, xa_mk_value(4862), 0);\n\tcheck_store_range(mt, 4842, 4849, NULL, 0);\n\tmt_validate(mt);\n\tMT_BUG_ON(mt, !mt_height(mt));\n\tmtree_destroy(mt);\n\n\tmt_init_flags(mt, MT_FLAGS_ALLOC_RANGE);\n\tfor (i = 0; i <= 1300; i++) {\n\t\tval = i*10;\n\t\tval2 = (i+1)*10;\n\t\tcheck_store_range(mt, val, val2, xa_mk_value(val), 0);\n\t\tMT_BUG_ON(mt, mt_height(mt) >= 4);\n\t}\n\t \n\tfor (i = 5; i < 215; i += 10)\n\t\tcheck_store_range(mt, 11450 + i, 11450 + i + 1, NULL, 0);\n\tfor (i = 5; i < 65; i += 10)\n\t\tcheck_store_range(mt, 11770 + i, 11770 + i + 1, NULL, 0);\n\n\tMT_BUG_ON(mt, mt_height(mt) >= 4);\n\tfor (i = 5; i < 45; i += 10)\n\t\tcheck_store_range(mt, 11700 + i, 11700 + i + 1, NULL, 0);\n\tif (!MAPLE_32BIT)\n\t\tMT_BUG_ON(mt, mt_height(mt) < 4);\n\tmtree_destroy(mt);\n\n\n\tmt_init_flags(mt, MT_FLAGS_ALLOC_RANGE);\n\tfor (i = 0; i <= 1200; i++) {\n\t\tval = i*10;\n\t\tval2 = (i+1)*10;\n\t\tcheck_store_range(mt, val, val2, xa_mk_value(val), 0);\n\t\tMT_BUG_ON(mt, mt_height(mt) >= 4);\n\t}\n\t \n\tfor (i = 5; i < 455; i += 10)\n\t\tcheck_store_range(mt, 7800 + i, 7800 + i + 1, NULL, 0);\n\n\tfor (i = 1; i < 16; i++)\n\t\tcheck_store_range(mt, 8185 + i, 8185 + i + 1,\n\t\t\t\t  xa_mk_value(8185+i), 0);\n\tMT_BUG_ON(mt, mt_height(mt) >= 4);\n\t \n\tcheck_store_range(mt, 8184, 8184, xa_mk_value(8184), 0);\n\tif (!MAPLE_32BIT)\n\t\tMT_BUG_ON(mt, mt_height(mt) != 4);\n}\n\nstatic noinline void __init check_next_entry(struct maple_tree *mt)\n{\n\tvoid *entry = NULL;\n\tunsigned long limit = 30, i = 0;\n\tMA_STATE(mas, mt, i, i);\n\n\tMT_BUG_ON(mt, !mtree_empty(mt));\n\n\tcheck_seq(mt, limit, false);\n\trcu_read_lock();\n\n\t \n\tMT_BUG_ON(mt, mas_walk(&mas) != xa_mk_value(i++));\n\tfor ( ; i <= limit + 1; i++) {\n\t\tentry = mas_next(&mas, limit);\n\t\tif (i > limit)\n\t\t\tMT_BUG_ON(mt, entry != NULL);\n\t\telse\n\t\t\tMT_BUG_ON(mt, xa_mk_value(i) != entry);\n\t}\n\trcu_read_unlock();\n\tmtree_destroy(mt);\n}\n\nstatic noinline void __init check_prev_entry(struct maple_tree *mt)\n{\n\tunsigned long index = 16;\n\tvoid *value;\n\tint i;\n\n\tMA_STATE(mas, mt, index, index);\n\n\tMT_BUG_ON(mt, !mtree_empty(mt));\n\tcheck_seq(mt, 30, false);\n\n\trcu_read_lock();\n\tvalue = mas_find(&mas, ULONG_MAX);\n\tMT_BUG_ON(mt, value != xa_mk_value(index));\n\tvalue = mas_prev(&mas, 0);\n\tMT_BUG_ON(mt, value != xa_mk_value(index - 1));\n\trcu_read_unlock();\n\tmtree_destroy(mt);\n\n\t \n\tmt_init_flags(mt, MT_FLAGS_ALLOC_RANGE);\n\tmas_lock(&mas);\n\tfor (i = 0; i <= index; i++) {\n\t\tmas_set_range(&mas, i*10, i*10+5);\n\t\tmas_store_gfp(&mas, xa_mk_value(i), GFP_KERNEL);\n\t}\n\n\tmas_set(&mas, 20);\n\tvalue = mas_walk(&mas);\n\tMT_BUG_ON(mt, value != xa_mk_value(2));\n\n\tvalue = mas_prev(&mas, 19);\n\tMT_BUG_ON(mt, value != NULL);\n\n\tmas_set(&mas, 80);\n\tvalue = mas_walk(&mas);\n\tMT_BUG_ON(mt, value != xa_mk_value(8));\n\n\tvalue = mas_prev(&mas, 76);\n\tMT_BUG_ON(mt, value != NULL);\n\n\tmas_unlock(&mas);\n}\n\nstatic noinline void __init check_root_expand(struct maple_tree *mt)\n{\n\tMA_STATE(mas, mt, 0, 0);\n\tvoid *ptr;\n\n\n\tmas_lock(&mas);\n\tmas_set(&mas, 3);\n\tptr = mas_walk(&mas);\n\tMT_BUG_ON(mt, mas.index != 0);\n\tMT_BUG_ON(mt, ptr != NULL);\n\tMT_BUG_ON(mt, mas.index != 0);\n\tMT_BUG_ON(mt, mas.last != ULONG_MAX);\n\n\tptr = &check_prev_entry;\n\tmas_set(&mas, 1);\n\tmas_store_gfp(&mas, ptr, GFP_KERNEL);\n\n\tmas_set(&mas, 0);\n\tptr = mas_walk(&mas);\n\tMT_BUG_ON(mt, ptr != NULL);\n\n\tmas_set(&mas, 1);\n\tptr = mas_walk(&mas);\n\tMT_BUG_ON(mt, ptr != &check_prev_entry);\n\n\tmas_set(&mas, 2);\n\tptr = mas_walk(&mas);\n\tMT_BUG_ON(mt, ptr != NULL);\n\tmas_unlock(&mas);\n\tmtree_destroy(mt);\n\n\n\tmt_init_flags(mt, 0);\n\tmas_lock(&mas);\n\n\tmas_set(&mas, 0);\n\tptr = &check_prev_entry;\n\tmas_store_gfp(&mas, ptr, GFP_KERNEL);\n\n\tmas_set(&mas, 5);\n\tptr = mas_walk(&mas);\n\tMT_BUG_ON(mt, ptr != NULL);\n\tMT_BUG_ON(mt, mas.index != 1);\n\tMT_BUG_ON(mt, mas.last != ULONG_MAX);\n\n\tmas_set_range(&mas, 0, 100);\n\tptr = mas_walk(&mas);\n\tMT_BUG_ON(mt, ptr != &check_prev_entry);\n\tMT_BUG_ON(mt, mas.last != 0);\n\tmas_unlock(&mas);\n\tmtree_destroy(mt);\n\n\tmt_init_flags(mt, 0);\n\tmas_lock(&mas);\n\n\tmas_set(&mas, 0);\n\tptr = (void *)((unsigned long) check_prev_entry | 1UL);\n\tmas_store_gfp(&mas, ptr, GFP_KERNEL);\n\tptr = mas_next(&mas, ULONG_MAX);\n\tMT_BUG_ON(mt, ptr != NULL);\n\tMT_BUG_ON(mt, (mas.index != 1) && (mas.last != ULONG_MAX));\n\n\tmas_set(&mas, 1);\n\tptr = mas_prev(&mas, 0);\n\tMT_BUG_ON(mt, (mas.index != 0) && (mas.last != 0));\n\tMT_BUG_ON(mt, ptr != (void *)((unsigned long) check_prev_entry | 1UL));\n\n\tmas_unlock(&mas);\n\n\tmtree_destroy(mt);\n\n\tmt_init_flags(mt, 0);\n\tmas_lock(&mas);\n\tmas_set(&mas, 0);\n\tptr = (void *)((unsigned long) check_prev_entry | 2UL);\n\tmas_store_gfp(&mas, ptr, GFP_KERNEL);\n\tptr = mas_next(&mas, ULONG_MAX);\n\tMT_BUG_ON(mt, ptr != NULL);\n\tMT_BUG_ON(mt, (mas.index != ULONG_MAX) && (mas.last != ULONG_MAX));\n\n\tmas_set(&mas, 1);\n\tptr = mas_prev(&mas, 0);\n\tMT_BUG_ON(mt, (mas.index != 0) && (mas.last != 0));\n\tMT_BUG_ON(mt, ptr != (void *)((unsigned long) check_prev_entry | 2UL));\n\n\n\tmas_unlock(&mas);\n}\n\nstatic noinline void __init check_gap_combining(struct maple_tree *mt)\n{\n\tstruct maple_enode *mn1, *mn2;\n\tvoid *entry;\n\tunsigned long singletons = 100;\n\tstatic const unsigned long *seq100;\n\tstatic const unsigned long seq100_64[] = {\n\t\t \n\t\t74, 75, 76,\n\t\t50, 100, 2,\n\n\t\t \n\t\t44, 45, 46, 43,\n\t\t20, 50, 3,\n\n\t\t \n\t\t80, 81, 82,\n\t\t76, 2, 79, 85, 4,\n\t};\n\n\tstatic const unsigned long seq100_32[] = {\n\t\t \n\t\t61, 62, 63,\n\t\t50, 100, 2,\n\n\t\t \n\t\t31, 32, 33, 30,\n\t\t20, 50, 3,\n\n\t\t \n\t\t80, 81, 82,\n\t\t76, 2, 79, 85, 4,\n\t};\n\n\tstatic const unsigned long seq2000[] = {\n\t\t1152, 1151,\n\t\t1100, 1200, 2,\n\t};\n\tstatic const unsigned long seq400[] = {\n\t\t286, 318,\n\t\t256, 260, 266, 270, 275, 280, 290, 398,\n\t\t286, 310,\n\t};\n\n\tunsigned long index;\n\n\tMA_STATE(mas, mt, 0, 0);\n\n\tif (MAPLE_32BIT)\n\t\tseq100 = seq100_32;\n\telse\n\t\tseq100 = seq100_64;\n\n\tindex = seq100[0];\n\tmas_set(&mas, index);\n\tMT_BUG_ON(mt, !mtree_empty(mt));\n\tcheck_seq(mt, singletons, false);  \n\n\tmt_set_non_kernel(1);\n\tmtree_test_erase(mt, seq100[2]);\n\tcheck_load(mt, seq100[2], NULL);\n\tmtree_test_erase(mt, seq100[1]);\n\tcheck_load(mt, seq100[1], NULL);\n\n\trcu_read_lock();\n\tentry = mas_find(&mas, ULONG_MAX);\n\tMT_BUG_ON(mt, entry != xa_mk_value(index));\n\tmn1 = mas.node;\n\tmas_next(&mas, ULONG_MAX);\n\tentry = mas_next(&mas, ULONG_MAX);\n\tMT_BUG_ON(mt, entry != xa_mk_value(index + 4));\n\tmn2 = mas.node;\n\tMT_BUG_ON(mt, mn1 == mn2);  \n\n\t \n\tmt_set_non_kernel(1);\n\tmas_reset(&mas);\n\tMT_BUG_ON(mt, mas_empty_area_rev(&mas, seq100[3], seq100[4],\n\t\t\t\t\t     seq100[5]));\n\tMT_BUG_ON(mt, mas.index != index + 1);\n\trcu_read_unlock();\n\n\tmtree_test_erase(mt, seq100[6]);\n\tcheck_load(mt, seq100[6], NULL);\n\tmtree_test_erase(mt, seq100[7]);\n\tcheck_load(mt, seq100[7], NULL);\n\tmtree_test_erase(mt, seq100[8]);\n\tindex = seq100[9];\n\n\trcu_read_lock();\n\tmas.index = index;\n\tmas.last = index;\n\tmas_reset(&mas);\n\tentry = mas_find(&mas, ULONG_MAX);\n\tMT_BUG_ON(mt, entry != xa_mk_value(index));\n\tmn1 = mas.node;\n\tentry = mas_next(&mas, ULONG_MAX);\n\tMT_BUG_ON(mt, entry != xa_mk_value(index + 4));\n\tmas_next(&mas, ULONG_MAX);  \n\tmn2 = mas.node;\n\tMT_BUG_ON(mt, mn1 == mn2);  \n\n\t \n\tmas_reset(&mas);\n\tMT_BUG_ON(mt, mas_empty_area_rev(&mas, seq100[10], seq100[11],\n\t\t\t\t\t     seq100[12]));\n\tMT_BUG_ON(mt, mas.index != seq100[6]);\n\trcu_read_unlock();\n\n\tmt_set_non_kernel(1);\n\tmtree_store(mt, seq100[13], NULL, GFP_KERNEL);\n\tcheck_load(mt, seq100[13], NULL);\n\tcheck_load(mt, seq100[14], xa_mk_value(seq100[14]));\n\tmtree_store(mt, seq100[14], NULL, GFP_KERNEL);\n\tcheck_load(mt, seq100[13], NULL);\n\tcheck_load(mt, seq100[14], NULL);\n\n\tmas_reset(&mas);\n\trcu_read_lock();\n\tMT_BUG_ON(mt, mas_empty_area_rev(&mas, seq100[16], seq100[15],\n\t\t\t\t\t     seq100[17]));\n\tMT_BUG_ON(mt, mas.index != seq100[13]);\n\tmt_validate(mt);\n\trcu_read_unlock();\n\n\t \n\tmt_set_non_kernel(2);\n\tmtree_test_store_range(mt, seq100[18], seq100[14], NULL);\n\tmtree_test_erase(mt, seq100[15]);\n\tmas_reset(&mas);\n\trcu_read_lock();\n\tMT_BUG_ON(mt, mas_empty_area_rev(&mas, seq100[16], seq100[19],\n\t\t\t\t\t     seq100[20]));\n\trcu_read_unlock();\n\tMT_BUG_ON(mt, mas.index != seq100[18]);\n\tmt_validate(mt);\n\tmtree_destroy(mt);\n\n\t \n\tmt_init_flags(mt, MT_FLAGS_ALLOC_RANGE);\n\tcheck_seq(mt, 2000, false);\n\tmt_set_non_kernel(1);\n\tmtree_test_erase(mt, seq2000[0]);\n\tmtree_test_erase(mt, seq2000[1]);\n\n\tmt_set_non_kernel(2);\n\tmas_reset(&mas);\n\trcu_read_lock();\n\tMT_BUG_ON(mt, mas_empty_area_rev(&mas, seq2000[2], seq2000[3],\n\t\t\t\t\t     seq2000[4]));\n\tMT_BUG_ON(mt, mas.index != seq2000[1]);\n\trcu_read_unlock();\n\tmt_validate(mt);\n\tmtree_destroy(mt);\n\n\t \n\tmt_set_non_kernel(99);\n\tmt_init_flags(mt, MT_FLAGS_ALLOC_RANGE);\n\tcheck_seq(mt, 400, false);\n\tmtree_test_store_range(mt, seq400[0], seq400[1], NULL);\n\tmt_set_non_kernel(0);\n\tmtree_destroy(mt);\n\n\tmt_init_flags(mt, MT_FLAGS_ALLOC_RANGE);\n\tcheck_seq(mt, 400, false);\n\tmt_set_non_kernel(50);\n\tmtree_test_store_range(mt, seq400[2], seq400[9],\n\t\t\t       xa_mk_value(seq400[2]));\n\tmtree_test_store_range(mt, seq400[3], seq400[9],\n\t\t\t       xa_mk_value(seq400[3]));\n\tmtree_test_store_range(mt, seq400[4], seq400[9],\n\t\t\t       xa_mk_value(seq400[4]));\n\tmtree_test_store_range(mt, seq400[5], seq400[9],\n\t\t\t       xa_mk_value(seq400[5]));\n\tmtree_test_store_range(mt, seq400[0], seq400[9],\n\t\t\t       xa_mk_value(seq400[0]));\n\tmtree_test_store_range(mt, seq400[6], seq400[9],\n\t\t\t       xa_mk_value(seq400[6]));\n\tmtree_test_store_range(mt, seq400[7], seq400[9],\n\t\t\t       xa_mk_value(seq400[7]));\n\tmtree_test_store_range(mt, seq400[8], seq400[9],\n\t\t\t       xa_mk_value(seq400[8]));\n\tmtree_test_store_range(mt, seq400[10], seq400[11],\n\t\t\t       xa_mk_value(seq400[10]));\n\tmt_validate(mt);\n\tmt_set_non_kernel(0);\n\tmtree_destroy(mt);\n}\nstatic noinline void __init check_node_overwrite(struct maple_tree *mt)\n{\n\tint i, max = 4000;\n\n\tfor (i = 0; i < max; i++)\n\t\tmtree_test_store_range(mt, i*100, i*100 + 50, xa_mk_value(i*100));\n\n\tmtree_test_store_range(mt, 319951, 367950, NULL);\n\t \n\tmt_validate(mt);\n}\n\n#if defined(BENCH_SLOT_STORE)\nstatic noinline void __init bench_slot_store(struct maple_tree *mt)\n{\n\tint i, brk = 105, max = 1040, brk_start = 100, count = 20000000;\n\n\tfor (i = 0; i < max; i += 10)\n\t\tmtree_store_range(mt, i, i + 5, xa_mk_value(i), GFP_KERNEL);\n\n\tfor (i = 0; i < count; i++) {\n\t\tmtree_store_range(mt, brk, brk, NULL, GFP_KERNEL);\n\t\tmtree_store_range(mt, brk_start, brk, xa_mk_value(brk),\n\t\t\t\t  GFP_KERNEL);\n\t}\n}\n#endif\n\n#if defined(BENCH_NODE_STORE)\nstatic noinline void __init bench_node_store(struct maple_tree *mt)\n{\n\tint i, overwrite = 76, max = 240, count = 20000000;\n\n\tfor (i = 0; i < max; i += 10)\n\t\tmtree_store_range(mt, i, i + 5, xa_mk_value(i), GFP_KERNEL);\n\n\tfor (i = 0; i < count; i++) {\n\t\tmtree_store_range(mt, overwrite,  overwrite + 15,\n\t\t\t\t  xa_mk_value(overwrite), GFP_KERNEL);\n\n\t\toverwrite += 5;\n\t\tif (overwrite >= 135)\n\t\t\toverwrite = 76;\n\t}\n}\n#endif\n\n#if defined(BENCH_AWALK)\nstatic noinline void __init bench_awalk(struct maple_tree *mt)\n{\n\tint i, max = 2500, count = 50000000;\n\tMA_STATE(mas, mt, 1470, 1470);\n\n\tfor (i = 0; i < max; i += 10)\n\t\tmtree_store_range(mt, i, i + 5, xa_mk_value(i), GFP_KERNEL);\n\n\tmtree_store_range(mt, 1470, 1475, NULL, GFP_KERNEL);\n\n\tfor (i = 0; i < count; i++) {\n\t\tmas_empty_area_rev(&mas, 0, 2000, 10);\n\t\tmas_reset(&mas);\n\t}\n}\n#endif\n#if defined(BENCH_WALK)\nstatic noinline void __init bench_walk(struct maple_tree *mt)\n{\n\tint i, max = 2500, count = 550000000;\n\tMA_STATE(mas, mt, 1470, 1470);\n\n\tfor (i = 0; i < max; i += 10)\n\t\tmtree_store_range(mt, i, i + 5, xa_mk_value(i), GFP_KERNEL);\n\n\tfor (i = 0; i < count; i++) {\n\t\tmas_walk(&mas);\n\t\tmas_reset(&mas);\n\t}\n\n}\n#endif\n\n#if defined(BENCH_MT_FOR_EACH)\nstatic noinline void __init bench_mt_for_each(struct maple_tree *mt)\n{\n\tint i, count = 1000000;\n\tunsigned long max = 2500, index = 0;\n\tvoid *entry;\n\n\tfor (i = 0; i < max; i += 5)\n\t\tmtree_store_range(mt, i, i + 4, xa_mk_value(i), GFP_KERNEL);\n\n\tfor (i = 0; i < count; i++) {\n\t\tunsigned long j = 0;\n\n\t\tmt_for_each(mt, entry, index, max) {\n\t\t\tMT_BUG_ON(mt, entry != xa_mk_value(j));\n\t\t\tj += 5;\n\t\t}\n\n\t\tindex = 0;\n\t}\n\n}\n#endif\n\n#if defined(BENCH_MAS_FOR_EACH)\nstatic noinline void __init bench_mas_for_each(struct maple_tree *mt)\n{\n\tint i, count = 1000000;\n\tunsigned long max = 2500;\n\tvoid *entry;\n\tMA_STATE(mas, mt, 0, 0);\n\n\tfor (i = 0; i < max; i += 5) {\n\t\tint gap = 4;\n\n\t\tif (i % 30 == 0)\n\t\t\tgap = 3;\n\t\tmtree_store_range(mt, i, i + gap, xa_mk_value(i), GFP_KERNEL);\n\t}\n\n\trcu_read_lock();\n\tfor (i = 0; i < count; i++) {\n\t\tunsigned long j = 0;\n\n\t\tmas_for_each(&mas, entry, max) {\n\t\t\tMT_BUG_ON(mt, entry != xa_mk_value(j));\n\t\t\tj += 5;\n\t\t}\n\t\tmas_set(&mas, 0);\n\t}\n\trcu_read_unlock();\n\n}\n#endif\n#if defined(BENCH_MAS_PREV)\nstatic noinline void __init bench_mas_prev(struct maple_tree *mt)\n{\n\tint i, count = 1000000;\n\tunsigned long max = 2500;\n\tvoid *entry;\n\tMA_STATE(mas, mt, 0, 0);\n\n\tfor (i = 0; i < max; i += 5) {\n\t\tint gap = 4;\n\n\t\tif (i % 30 == 0)\n\t\t\tgap = 3;\n\t\tmtree_store_range(mt, i, i + gap, xa_mk_value(i), GFP_KERNEL);\n\t}\n\n\trcu_read_lock();\n\tfor (i = 0; i < count; i++) {\n\t\tunsigned long j = 2495;\n\n\t\tmas_set(&mas, ULONG_MAX);\n\t\twhile ((entry = mas_prev(&mas, 0)) != NULL) {\n\t\t\tMT_BUG_ON(mt, entry != xa_mk_value(j));\n\t\t\tj -= 5;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n}\n#endif\n \nstatic noinline void __init check_forking(struct maple_tree *mt)\n{\n\n\tstruct maple_tree newmt;\n\tint i, nr_entries = 134;\n\tvoid *val;\n\tMA_STATE(mas, mt, 0, 0);\n\tMA_STATE(newmas, mt, 0, 0);\n\tstruct rw_semaphore newmt_lock;\n\n\tinit_rwsem(&newmt_lock);\n\n\tfor (i = 0; i <= nr_entries; i++)\n\t\tmtree_store_range(mt, i*10, i*10 + 5,\n\t\t\t\t  xa_mk_value(i), GFP_KERNEL);\n\n\tmt_set_non_kernel(99999);\n\tmt_init_flags(&newmt, MT_FLAGS_ALLOC_RANGE | MT_FLAGS_LOCK_EXTERN);\n\tmt_set_external_lock(&newmt, &newmt_lock);\n\tnewmas.tree = &newmt;\n\tmas_reset(&newmas);\n\tmas_reset(&mas);\n\tdown_write(&newmt_lock);\n\tmas.index = 0;\n\tmas.last = 0;\n\tif (mas_expected_entries(&newmas, nr_entries)) {\n\t\tpr_err(\"OOM!\");\n\t\tBUG_ON(1);\n\t}\n\trcu_read_lock();\n\tmas_for_each(&mas, val, ULONG_MAX) {\n\t\tnewmas.index = mas.index;\n\t\tnewmas.last = mas.last;\n\t\tmas_store(&newmas, val);\n\t}\n\trcu_read_unlock();\n\tmas_destroy(&newmas);\n\tmt_validate(&newmt);\n\tmt_set_non_kernel(0);\n\t__mt_destroy(&newmt);\n\tup_write(&newmt_lock);\n}\n\nstatic noinline void __init check_iteration(struct maple_tree *mt)\n{\n\tint i, nr_entries = 125;\n\tvoid *val;\n\tMA_STATE(mas, mt, 0, 0);\n\n\tfor (i = 0; i <= nr_entries; i++)\n\t\tmtree_store_range(mt, i * 10, i * 10 + 9,\n\t\t\t\t  xa_mk_value(i), GFP_KERNEL);\n\n\tmt_set_non_kernel(99999);\n\n\ti = 0;\n\tmas_lock(&mas);\n\tmas_for_each(&mas, val, 925) {\n\t\tMT_BUG_ON(mt, mas.index != i * 10);\n\t\tMT_BUG_ON(mt, mas.last != i * 10 + 9);\n\t\t \n\t\tif (i == 92) {\n\t\t\tmas.index = 925;\n\t\t\tmas.last = 929;\n\t\t\tmas_store(&mas, val);\n\t\t}\n\t\ti++;\n\t}\n\t \n\tval = mas_find(&mas, ULONG_MAX);\n\tMT_BUG_ON(mt, val != xa_mk_value(i));\n\n\tmas_set(&mas, 0);\n\ti = 0;\n\tmas_for_each(&mas, val, 785) {\n\t\tMT_BUG_ON(mt, mas.index != i * 10);\n\t\tMT_BUG_ON(mt, mas.last != i * 10 + 9);\n\t\t \n\t\tif (i == 78) {\n\t\t\tmas.index = 780;\n\t\t\tmas.last = 785;\n\t\t\tmas_store(&mas, val);\n\t\t} else {\n\t\t\ti++;\n\t\t}\n\t}\n\tval = mas_find(&mas, ULONG_MAX);\n\tMT_BUG_ON(mt, val != xa_mk_value(i));\n\n\tmas_set(&mas, 0);\n\ti = 0;\n\tmas_for_each(&mas, val, 765) {\n\t\tMT_BUG_ON(mt, mas.index != i * 10);\n\t\tMT_BUG_ON(mt, mas.last != i * 10 + 9);\n\t\t \n\t\tif (i == 76) {\n\t\t\tmas.index = 760;\n\t\t\tmas.last = 765;\n\t\t\tmas_store(&mas, val);\n\t\t}\n\t\ti++;\n\t}\n\t \n\tval = mas_find(&mas, ULONG_MAX);\n\tMT_BUG_ON(mt, val != xa_mk_value(76));\n\tmas_unlock(&mas);\n\tmas_destroy(&mas);\n\tmt_set_non_kernel(0);\n}\n\nstatic noinline void __init check_mas_store_gfp(struct maple_tree *mt)\n{\n\n\tstruct maple_tree newmt;\n\tint i, nr_entries = 135;\n\tvoid *val;\n\tMA_STATE(mas, mt, 0, 0);\n\tMA_STATE(newmas, mt, 0, 0);\n\n\tfor (i = 0; i <= nr_entries; i++)\n\t\tmtree_store_range(mt, i*10, i*10 + 5,\n\t\t\t\t  xa_mk_value(i), GFP_KERNEL);\n\n\tmt_set_non_kernel(99999);\n\tmt_init_flags(&newmt, MT_FLAGS_ALLOC_RANGE);\n\tnewmas.tree = &newmt;\n\trcu_read_lock();\n\tmas_lock(&newmas);\n\tmas_reset(&newmas);\n\tmas_set(&mas, 0);\n\tmas_for_each(&mas, val, ULONG_MAX) {\n\t\tnewmas.index = mas.index;\n\t\tnewmas.last = mas.last;\n\t\tmas_store_gfp(&newmas, val, GFP_KERNEL);\n\t}\n\tmas_unlock(&newmas);\n\trcu_read_unlock();\n\tmt_validate(&newmt);\n\tmt_set_non_kernel(0);\n\tmtree_destroy(&newmt);\n}\n\n#if defined(BENCH_FORK)\nstatic noinline void __init bench_forking(struct maple_tree *mt)\n{\n\n\tstruct maple_tree newmt;\n\tint i, nr_entries = 134, nr_fork = 80000;\n\tvoid *val;\n\tMA_STATE(mas, mt, 0, 0);\n\tMA_STATE(newmas, mt, 0, 0);\n\tstruct rw_semaphore newmt_lock;\n\n\tinit_rwsem(&newmt_lock);\n\tmt_set_external_lock(&newmt, &newmt_lock);\n\n\tfor (i = 0; i <= nr_entries; i++)\n\t\tmtree_store_range(mt, i*10, i*10 + 5,\n\t\t\t\t  xa_mk_value(i), GFP_KERNEL);\n\n\tfor (i = 0; i < nr_fork; i++) {\n\t\tmt_set_non_kernel(99999);\n\t\tmt_init_flags(&newmt, MT_FLAGS_ALLOC_RANGE);\n\t\tnewmas.tree = &newmt;\n\t\tmas_reset(&newmas);\n\t\tmas_reset(&mas);\n\t\tmas.index = 0;\n\t\tmas.last = 0;\n\t\trcu_read_lock();\n\t\tdown_write(&newmt_lock);\n\t\tif (mas_expected_entries(&newmas, nr_entries)) {\n\t\t\tprintk(\"OOM!\");\n\t\t\tBUG_ON(1);\n\t\t}\n\t\tmas_for_each(&mas, val, ULONG_MAX) {\n\t\t\tnewmas.index = mas.index;\n\t\t\tnewmas.last = mas.last;\n\t\t\tmas_store(&newmas, val);\n\t\t}\n\t\tmas_destroy(&newmas);\n\t\trcu_read_unlock();\n\t\tmt_validate(&newmt);\n\t\tmt_set_non_kernel(0);\n\t\t__mt_destroy(&newmt);\n\t\tup_write(&newmt_lock);\n\t}\n}\n#endif\n\nstatic noinline void __init next_prev_test(struct maple_tree *mt)\n{\n\tint i, nr_entries;\n\tvoid *val;\n\tMA_STATE(mas, mt, 0, 0);\n\tstruct maple_enode *mn;\n\tstatic const unsigned long *level2;\n\tstatic const unsigned long level2_64[] = { 707, 1000, 710, 715, 720,\n\t\t\t\t\t\t   725};\n\tstatic const unsigned long level2_32[] = { 1747, 2000, 1750, 1755,\n\t\t\t\t\t\t   1760, 1765};\n\tunsigned long last_index;\n\n\tif (MAPLE_32BIT) {\n\t\tnr_entries = 500;\n\t\tlevel2 = level2_32;\n\t\tlast_index = 0x138e;\n\t} else {\n\t\tnr_entries = 200;\n\t\tlevel2 = level2_64;\n\t\tlast_index = 0x7d6;\n\t}\n\n\tfor (i = 0; i <= nr_entries; i++)\n\t\tmtree_store_range(mt, i*10, i*10 + 5,\n\t\t\t\t  xa_mk_value(i), GFP_KERNEL);\n\n\tmas_lock(&mas);\n\tfor (i = 0; i <= nr_entries / 2; i++) {\n\t\tmas_next(&mas, 1000);\n\t\tif (mas_is_none(&mas))\n\t\t\tbreak;\n\n\t}\n\tmas_reset(&mas);\n\tmas_set(&mas, 0);\n\ti = 0;\n\tmas_for_each(&mas, val, 1000) {\n\t\ti++;\n\t}\n\n\tmas_reset(&mas);\n\tmas_set(&mas, 0);\n\ti = 0;\n\tmas_for_each(&mas, val, 1000) {\n\t\tmas_pause(&mas);\n\t\ti++;\n\t}\n\n\t \n\tmas_set(&mas, 686);\n\tval = mas_walk(&mas);\n\tMT_BUG_ON(mt, val != NULL);\n\n\tval = mas_next(&mas, 1000);\n\tMT_BUG_ON(mt, val != xa_mk_value(690 / 10));\n\tMT_BUG_ON(mt, mas.index != 690);\n\tMT_BUG_ON(mt, mas.last != 695);\n\n\tval = mas_prev(&mas, 0);\n\tMT_BUG_ON(mt, val != xa_mk_value(680 / 10));\n\tMT_BUG_ON(mt, mas.index != 680);\n\tMT_BUG_ON(mt, mas.last != 685);\n\n\tval = mas_next(&mas, 1000);\n\tMT_BUG_ON(mt, val != xa_mk_value(690 / 10));\n\tMT_BUG_ON(mt, mas.index != 690);\n\tMT_BUG_ON(mt, mas.last != 695);\n\n\tval = mas_next(&mas, 1000);\n\tMT_BUG_ON(mt, val != xa_mk_value(700 / 10));\n\tMT_BUG_ON(mt, mas.index != 700);\n\tMT_BUG_ON(mt, mas.last != 705);\n\n\t \n\tmas_set(&mas, 70);\n\tval = mas_walk(&mas);\n\tMT_BUG_ON(mt, val != xa_mk_value(70 / 10));\n\tMT_BUG_ON(mt, mas.index != 70);\n\tMT_BUG_ON(mt, mas.last != 75);\n\n\tval = mas_next(&mas, 1000);\n\tMT_BUG_ON(mt, val != xa_mk_value(80 / 10));\n\tMT_BUG_ON(mt, mas.index != 80);\n\tMT_BUG_ON(mt, mas.last != 85);\n\n\tval = mas_prev(&mas, 70);\n\tMT_BUG_ON(mt, val != xa_mk_value(70 / 10));\n\tMT_BUG_ON(mt, mas.index != 70);\n\tMT_BUG_ON(mt, mas.last != 75);\n\n\t \n\tmas_reset(&mas);\n\tmas_set(&mas, level2[0]);\n\tval = mas_walk(&mas);\n\tMT_BUG_ON(mt, val != NULL);\n\tval = mas_next(&mas, level2[1]);\n\tMT_BUG_ON(mt, val != xa_mk_value(level2[2] / 10));\n\tMT_BUG_ON(mt, mas.index != level2[2]);\n\tMT_BUG_ON(mt, mas.last != level2[3]);\n\tmn = mas.node;\n\n\tval = mas_next(&mas, level2[1]);\n\tMT_BUG_ON(mt, val != xa_mk_value(level2[4] / 10));\n\tMT_BUG_ON(mt, mas.index != level2[4]);\n\tMT_BUG_ON(mt, mas.last != level2[5]);\n\tMT_BUG_ON(mt, mn == mas.node);\n\n\tval = mas_prev(&mas, 0);\n\tMT_BUG_ON(mt, val != xa_mk_value(level2[2] / 10));\n\tMT_BUG_ON(mt, mas.index != level2[2]);\n\tMT_BUG_ON(mt, mas.last != level2[3]);\n\n\t \n\tmas_set(&mas, nr_entries * 10);\n\tval = mas_walk(&mas);\n\tMT_BUG_ON(mt, val != xa_mk_value(nr_entries));\n\tMT_BUG_ON(mt, mas.index != (nr_entries * 10));\n\tMT_BUG_ON(mt, mas.last != (nr_entries * 10 + 5));\n\n\tval = mas_next(&mas, ULONG_MAX);\n\tMT_BUG_ON(mt, val != NULL);\n\tMT_BUG_ON(mt, mas.index != last_index);\n\tMT_BUG_ON(mt, mas.last != ULONG_MAX);\n\n\tval = mas_prev(&mas, 0);\n\tMT_BUG_ON(mt, val != xa_mk_value(nr_entries));\n\tMT_BUG_ON(mt, mas.index != (nr_entries * 10));\n\tMT_BUG_ON(mt, mas.last != (nr_entries * 10 + 5));\n\n\t \n\tmas_reset(&mas);\n\tmas_set(&mas, 10);\n\tval = mas_walk(&mas);\n\tMT_BUG_ON(mt, val != xa_mk_value(1));\n\tMT_BUG_ON(mt, mas.index != 10);\n\tMT_BUG_ON(mt, mas.last != 15);\n\n\tval = mas_prev(&mas, 0);\n\tMT_BUG_ON(mt, val != xa_mk_value(0));\n\tMT_BUG_ON(mt, mas.index != 0);\n\tMT_BUG_ON(mt, mas.last != 5);\n\n\tval = mas_prev(&mas, 0);\n\tMT_BUG_ON(mt, val != NULL);\n\tMT_BUG_ON(mt, mas.index != 0);\n\tMT_BUG_ON(mt, mas.last != 5);\n\tMT_BUG_ON(mt, mas.node != MAS_UNDERFLOW);\n\n\tmas.index = 0;\n\tmas.last = 5;\n\tmas_store(&mas, NULL);\n\tmas_reset(&mas);\n\tmas_set(&mas, 10);\n\tmas_walk(&mas);\n\n\tval = mas_prev(&mas, 0);\n\tMT_BUG_ON(mt, val != NULL);\n\tMT_BUG_ON(mt, mas.index != 0);\n\tMT_BUG_ON(mt, mas.last != 9);\n\tmas_unlock(&mas);\n\n\tmtree_destroy(mt);\n\n\tmt_init(mt);\n\tmtree_store_range(mt, 0, 0, xa_mk_value(0), GFP_KERNEL);\n\tmtree_store_range(mt, 5, 5, xa_mk_value(5), GFP_KERNEL);\n\trcu_read_lock();\n\tmas_set(&mas, 5);\n\tval = mas_prev(&mas, 4);\n\tMT_BUG_ON(mt, val != NULL);\n\trcu_read_unlock();\n}\n\n\n\n \nstatic noinline void __init check_spanning_relatives(struct maple_tree *mt)\n{\n\n\tunsigned long i, nr_entries = 1000;\n\n\tfor (i = 0; i <= nr_entries; i++)\n\t\tmtree_store_range(mt, i*10, i*10 + 5,\n\t\t\t\t  xa_mk_value(i), GFP_KERNEL);\n\n\n\tmtree_store_range(mt, 9365, 9955, NULL, GFP_KERNEL);\n}\n\nstatic noinline void __init check_fuzzer(struct maple_tree *mt)\n{\n\t \n\tmtree_test_insert(mt, 88, (void *)0xb1);\n\tmtree_test_insert(mt, 84, (void *)0xa9);\n\tmtree_test_insert(mt, 2,  (void *)0x5);\n\tmtree_test_insert(mt, 4,  (void *)0x9);\n\tmtree_test_insert(mt, 14, (void *)0x1d);\n\tmtree_test_insert(mt, 7,  (void *)0xf);\n\tmtree_test_insert(mt, 12, (void *)0x19);\n\tmtree_test_insert(mt, 18, (void *)0x25);\n\tmtree_test_store_range(mt, 8, 18, (void *)0x11);\n\tmtree_destroy(mt);\n\n\n\t \n\tmt_init_flags(mt, 0);\n\tmtree_test_store(mt, 87, (void *)0xaf);\n\tmtree_test_store(mt, 0, (void *)0x1);\n\tmtree_test_load(mt, 4);\n\tmtree_test_insert(mt, 4, (void *)0x9);\n\tmtree_test_store(mt, 8, (void *)0x11);\n\tmtree_test_store(mt, 44, (void *)0x59);\n\tmtree_test_store(mt, 68, (void *)0x89);\n\tmtree_test_store(mt, 2, (void *)0x5);\n\tmtree_test_insert(mt, 43, (void *)0x57);\n\tmtree_test_insert(mt, 24, (void *)0x31);\n\tmtree_test_insert(mt, 844, (void *)0x699);\n\tmtree_test_store(mt, 84, (void *)0xa9);\n\tmtree_test_store(mt, 4, (void *)0x9);\n\tmtree_test_erase(mt, 4);\n\tmtree_test_load(mt, 5);\n\tmtree_test_erase(mt, 0);\n\tmtree_destroy(mt);\n\n\t \n\tmt_init_flags(mt, 0);\n\tmtree_test_store_range(mt, 0, ULONG_MAX, (void *)0x1);\n\tmtree_test_store(mt, 4, (void *)0x9);\n\tmtree_test_erase(mt, 5);\n\tmtree_test_erase(mt, 0);\n\tmtree_test_erase(mt, 4);\n\tmtree_test_store(mt, 5, (void *)0xb);\n\tmtree_test_erase(mt, 5);\n\tmtree_test_store(mt, 5, (void *)0xb);\n\tmtree_test_erase(mt, 5);\n\tmtree_test_erase(mt, 4);\n\tmtree_test_store(mt, 4, (void *)0x9);\n\tmtree_test_store(mt, 444, (void *)0x379);\n\tmtree_test_store(mt, 0, (void *)0x1);\n\tmtree_test_load(mt, 0);\n\tmtree_test_store(mt, 5, (void *)0xb);\n\tmtree_test_erase(mt, 0);\n\tmtree_destroy(mt);\n\n\t \n\tmt_init_flags(mt, 0);\n\tmtree_test_insert(mt, 261, (void *)0x20b);\n\tmtree_test_store(mt, 516, (void *)0x409);\n\tmtree_test_store(mt, 6, (void *)0xd);\n\tmtree_test_insert(mt, 5, (void *)0xb);\n\tmtree_test_insert(mt, 1256, (void *)0x9d1);\n\tmtree_test_store(mt, 4, (void *)0x9);\n\tmtree_test_erase(mt, 1);\n\tmtree_test_store(mt, 56, (void *)0x71);\n\tmtree_test_insert(mt, 1, (void *)0x3);\n\tmtree_test_store(mt, 24, (void *)0x31);\n\tmtree_test_erase(mt, 1);\n\tmtree_test_insert(mt, 2263, (void *)0x11af);\n\tmtree_test_insert(mt, 446, (void *)0x37d);\n\tmtree_test_store_range(mt, 6, 45, (void *)0xd);\n\tmtree_test_store_range(mt, 3, 446, (void *)0x7);\n\tmtree_destroy(mt);\n\n\t \n\tmt_init_flags(mt, 0);\n\tmtree_test_store(mt, 48, (void *)0x61);\n\tmtree_test_store(mt, 3, (void *)0x7);\n\tmtree_test_load(mt, 0);\n\tmtree_test_store(mt, 88, (void *)0xb1);\n\tmtree_test_store(mt, 81, (void *)0xa3);\n\tmtree_test_insert(mt, 0, (void *)0x1);\n\tmtree_test_insert(mt, 8, (void *)0x11);\n\tmtree_test_insert(mt, 4, (void *)0x9);\n\tmtree_test_insert(mt, 2480, (void *)0x1361);\n\tmtree_test_insert(mt, ULONG_MAX,\n\t\t\t  (void *)0xffffffffffffffff);\n\tmtree_test_erase(mt, ULONG_MAX);\n\tmtree_destroy(mt);\n\n\t \n\tmt_init_flags(mt, 0);\n\tmtree_test_erase(mt, 3);\n\tmtree_test_insert(mt, 22, (void *)0x2d);\n\tmtree_test_insert(mt, 15, (void *)0x1f);\n\tmtree_test_load(mt, 2);\n\tmtree_test_insert(mt, 1, (void *)0x3);\n\tmtree_test_insert(mt, 1, (void *)0x3);\n\tmtree_test_insert(mt, 5, (void *)0xb);\n\tmtree_test_erase(mt, 1);\n\tmtree_test_insert(mt, 1, (void *)0x3);\n\tmtree_test_insert(mt, 4, (void *)0x9);\n\tmtree_test_insert(mt, 1, (void *)0x3);\n\tmtree_test_erase(mt, 1);\n\tmtree_test_insert(mt, 2, (void *)0x5);\n\tmtree_test_insert(mt, 1, (void *)0x3);\n\tmtree_test_erase(mt, 3);\n\tmtree_test_insert(mt, 22, (void *)0x2d);\n\tmtree_test_insert(mt, 15, (void *)0x1f);\n\tmtree_test_insert(mt, 2, (void *)0x5);\n\tmtree_test_insert(mt, 1, (void *)0x3);\n\tmtree_test_insert(mt, 8, (void *)0x11);\n\tmtree_test_load(mt, 2);\n\tmtree_test_insert(mt, 1, (void *)0x3);\n\tmtree_test_insert(mt, 1, (void *)0x3);\n\tmtree_test_store(mt, 1, (void *)0x3);\n\tmtree_test_insert(mt, 5, (void *)0xb);\n\tmtree_test_erase(mt, 1);\n\tmtree_test_insert(mt, 1, (void *)0x3);\n\tmtree_test_insert(mt, 4, (void *)0x9);\n\tmtree_test_insert(mt, 1, (void *)0x3);\n\tmtree_test_erase(mt, 1);\n\tmtree_test_insert(mt, 2, (void *)0x5);\n\tmtree_test_insert(mt, 1, (void *)0x3);\n\tmtree_test_erase(mt, 3);\n\tmtree_test_insert(mt, 22, (void *)0x2d);\n\tmtree_test_insert(mt, 15, (void *)0x1f);\n\tmtree_test_insert(mt, 2, (void *)0x5);\n\tmtree_test_insert(mt, 1, (void *)0x3);\n\tmtree_test_insert(mt, 8, (void *)0x11);\n\tmtree_test_insert(mt, 12, (void *)0x19);\n\tmtree_test_erase(mt, 1);\n\tmtree_test_store_range(mt, 4, 62, (void *)0x9);\n\tmtree_test_erase(mt, 62);\n\tmtree_test_store_range(mt, 1, 0, (void *)0x3);\n\tmtree_test_insert(mt, 11, (void *)0x17);\n\tmtree_test_insert(mt, 3, (void *)0x7);\n\tmtree_test_insert(mt, 3, (void *)0x7);\n\tmtree_test_store(mt, 62, (void *)0x7d);\n\tmtree_test_erase(mt, 62);\n\tmtree_test_store_range(mt, 1, 15, (void *)0x3);\n\tmtree_test_erase(mt, 1);\n\tmtree_test_insert(mt, 22, (void *)0x2d);\n\tmtree_test_insert(mt, 12, (void *)0x19);\n\tmtree_test_erase(mt, 1);\n\tmtree_test_insert(mt, 3, (void *)0x7);\n\tmtree_test_store(mt, 62, (void *)0x7d);\n\tmtree_test_erase(mt, 62);\n\tmtree_test_insert(mt, 122, (void *)0xf5);\n\tmtree_test_store(mt, 3, (void *)0x7);\n\tmtree_test_insert(mt, 0, (void *)0x1);\n\tmtree_test_store_range(mt, 0, 1, (void *)0x1);\n\tmtree_test_insert(mt, 85, (void *)0xab);\n\tmtree_test_insert(mt, 72, (void *)0x91);\n\tmtree_test_insert(mt, 81, (void *)0xa3);\n\tmtree_test_insert(mt, 726, (void *)0x5ad);\n\tmtree_test_insert(mt, 0, (void *)0x1);\n\tmtree_test_insert(mt, 1, (void *)0x3);\n\tmtree_test_store(mt, 51, (void *)0x67);\n\tmtree_test_insert(mt, 611, (void *)0x4c7);\n\tmtree_test_insert(mt, 485, (void *)0x3cb);\n\tmtree_test_insert(mt, 1, (void *)0x3);\n\tmtree_test_erase(mt, 1);\n\tmtree_test_insert(mt, 0, (void *)0x1);\n\tmtree_test_insert(mt, 1, (void *)0x3);\n\tmtree_test_insert_range(mt, 26, 1, (void *)0x35);\n\tmtree_test_load(mt, 1);\n\tmtree_test_store_range(mt, 1, 22, (void *)0x3);\n\tmtree_test_insert(mt, 1, (void *)0x3);\n\tmtree_test_erase(mt, 1);\n\tmtree_test_load(mt, 53);\n\tmtree_test_load(mt, 1);\n\tmtree_test_store_range(mt, 1, 1, (void *)0x3);\n\tmtree_test_insert(mt, 222, (void *)0x1bd);\n\tmtree_test_insert(mt, 485, (void *)0x3cb);\n\tmtree_test_insert(mt, 1, (void *)0x3);\n\tmtree_test_erase(mt, 1);\n\tmtree_test_load(mt, 0);\n\tmtree_test_insert(mt, 21, (void *)0x2b);\n\tmtree_test_insert(mt, 3, (void *)0x7);\n\tmtree_test_store(mt, 621, (void *)0x4db);\n\tmtree_test_insert(mt, 0, (void *)0x1);\n\tmtree_test_erase(mt, 5);\n\tmtree_test_insert(mt, 1, (void *)0x3);\n\tmtree_test_store(mt, 62, (void *)0x7d);\n\tmtree_test_erase(mt, 62);\n\tmtree_test_store_range(mt, 1, 0, (void *)0x3);\n\tmtree_test_insert(mt, 22, (void *)0x2d);\n\tmtree_test_insert(mt, 12, (void *)0x19);\n\tmtree_test_erase(mt, 1);\n\tmtree_test_insert(mt, 1, (void *)0x3);\n\tmtree_test_store_range(mt, 4, 62, (void *)0x9);\n\tmtree_test_erase(mt, 62);\n\tmtree_test_erase(mt, 1);\n\tmtree_test_load(mt, 1);\n\tmtree_test_store_range(mt, 1, 22, (void *)0x3);\n\tmtree_test_insert(mt, 1, (void *)0x3);\n\tmtree_test_erase(mt, 1);\n\tmtree_test_load(mt, 53);\n\tmtree_test_load(mt, 1);\n\tmtree_test_store_range(mt, 1, 1, (void *)0x3);\n\tmtree_test_insert(mt, 222, (void *)0x1bd);\n\tmtree_test_insert(mt, 485, (void *)0x3cb);\n\tmtree_test_insert(mt, 1, (void *)0x3);\n\tmtree_test_erase(mt, 1);\n\tmtree_test_insert(mt, 1, (void *)0x3);\n\tmtree_test_load(mt, 0);\n\tmtree_test_load(mt, 0);\n\tmtree_destroy(mt);\n\n\t \n\tmt_init_flags(mt, 0);\n\tmtree_test_load(mt, 1);\n\tmtree_test_insert(mt, 102, (void *)0xcd);\n\tmtree_test_erase(mt, 2);\n\tmtree_test_erase(mt, 0);\n\tmtree_test_load(mt, 0);\n\tmtree_test_insert(mt, 4, (void *)0x9);\n\tmtree_test_insert(mt, 2, (void *)0x5);\n\tmtree_test_insert(mt, 110, (void *)0xdd);\n\tmtree_test_insert(mt, 1, (void *)0x3);\n\tmtree_test_insert_range(mt, 5, 0, (void *)0xb);\n\tmtree_test_erase(mt, 2);\n\tmtree_test_store(mt, 0, (void *)0x1);\n\tmtree_test_store(mt, 112, (void *)0xe1);\n\tmtree_test_insert(mt, 21, (void *)0x2b);\n\tmtree_test_store(mt, 1, (void *)0x3);\n\tmtree_test_insert_range(mt, 110, 2, (void *)0xdd);\n\tmtree_test_store(mt, 2, (void *)0x5);\n\tmtree_test_load(mt, 22);\n\tmtree_test_erase(mt, 2);\n\tmtree_test_store(mt, 210, (void *)0x1a5);\n\tmtree_test_store_range(mt, 0, 2, (void *)0x1);\n\tmtree_test_store(mt, 2, (void *)0x5);\n\tmtree_test_erase(mt, 2);\n\tmtree_test_erase(mt, 22);\n\tmtree_test_erase(mt, 1);\n\tmtree_test_erase(mt, 2);\n\tmtree_test_store(mt, 0, (void *)0x1);\n\tmtree_test_load(mt, 112);\n\tmtree_test_insert(mt, 2, (void *)0x5);\n\tmtree_test_erase(mt, 2);\n\tmtree_test_store(mt, 1, (void *)0x3);\n\tmtree_test_insert_range(mt, 1, 2, (void *)0x3);\n\tmtree_test_erase(mt, 0);\n\tmtree_test_erase(mt, 2);\n\tmtree_test_store(mt, 2, (void *)0x5);\n\tmtree_test_erase(mt, 0);\n\tmtree_test_erase(mt, 2);\n\tmtree_test_store(mt, 0, (void *)0x1);\n\tmtree_test_store(mt, 0, (void *)0x1);\n\tmtree_test_erase(mt, 2);\n\tmtree_test_store(mt, 2, (void *)0x5);\n\tmtree_test_erase(mt, 2);\n\tmtree_test_insert(mt, 2, (void *)0x5);\n\tmtree_test_insert_range(mt, 1, 2, (void *)0x3);\n\tmtree_test_erase(mt, 0);\n\tmtree_test_erase(mt, 2);\n\tmtree_test_store(mt, 0, (void *)0x1);\n\tmtree_test_load(mt, 112);\n\tmtree_test_store_range(mt, 110, 12, (void *)0xdd);\n\tmtree_test_store(mt, 2, (void *)0x5);\n\tmtree_test_load(mt, 110);\n\tmtree_test_insert_range(mt, 4, 71, (void *)0x9);\n\tmtree_test_load(mt, 2);\n\tmtree_test_store(mt, 2, (void *)0x5);\n\tmtree_test_insert_range(mt, 11, 22, (void *)0x17);\n\tmtree_test_erase(mt, 12);\n\tmtree_test_store(mt, 2, (void *)0x5);\n\tmtree_test_load(mt, 22);\n\tmtree_destroy(mt);\n\n\n\t \n\tmt_init_flags(mt, 0);\n\tmtree_test_store(mt, 6, (void *)0xd);\n\tmtree_test_store(mt, 67, (void *)0x87);\n\tmtree_test_insert(mt, 15, (void *)0x1f);\n\tmtree_test_insert(mt, 6716, (void *)0x3479);\n\tmtree_test_store(mt, 61, (void *)0x7b);\n\tmtree_test_insert(mt, 13, (void *)0x1b);\n\tmtree_test_store(mt, 8, (void *)0x11);\n\tmtree_test_insert(mt, 1, (void *)0x3);\n\tmtree_test_load(mt, 0);\n\tmtree_test_erase(mt, 67167);\n\tmtree_test_insert_range(mt, 6, 7167, (void *)0xd);\n\tmtree_test_insert(mt, 6, (void *)0xd);\n\tmtree_test_erase(mt, 67);\n\tmtree_test_insert(mt, 1, (void *)0x3);\n\tmtree_test_erase(mt, 667167);\n\tmtree_test_insert(mt, 6, (void *)0xd);\n\tmtree_test_store(mt, 67, (void *)0x87);\n\tmtree_test_insert(mt, 5, (void *)0xb);\n\tmtree_test_erase(mt, 1);\n\tmtree_test_insert(mt, 6, (void *)0xd);\n\tmtree_test_erase(mt, 67);\n\tmtree_test_insert(mt, 15, (void *)0x1f);\n\tmtree_test_insert(mt, 67167, (void *)0x20cbf);\n\tmtree_test_insert(mt, 1, (void *)0x3);\n\tmtree_test_load(mt, 7);\n\tmtree_test_insert(mt, 16, (void *)0x21);\n\tmtree_test_insert(mt, 36, (void *)0x49);\n\tmtree_test_store(mt, 67, (void *)0x87);\n\tmtree_test_store(mt, 6, (void *)0xd);\n\tmtree_test_insert(mt, 367, (void *)0x2df);\n\tmtree_test_insert(mt, 115, (void *)0xe7);\n\tmtree_test_store(mt, 0, (void *)0x1);\n\tmtree_test_store_range(mt, 1, 3, (void *)0x3);\n\tmtree_test_store(mt, 1, (void *)0x3);\n\tmtree_test_erase(mt, 67167);\n\tmtree_test_insert_range(mt, 6, 47, (void *)0xd);\n\tmtree_test_store(mt, 1, (void *)0x3);\n\tmtree_test_insert_range(mt, 1, 67, (void *)0x3);\n\tmtree_test_load(mt, 67);\n\tmtree_test_insert(mt, 1, (void *)0x3);\n\tmtree_test_erase(mt, 67167);\n\tmtree_destroy(mt);\n\n\t \n\tmt_init_flags(mt, 0);\n\tmtree_test_insert(mt, 21, (void *)0x2b);\n\tmtree_test_insert(mt, 12, (void *)0x19);\n\tmtree_test_insert(mt, 6, (void *)0xd);\n\tmtree_test_insert(mt, 8, (void *)0x11);\n\tmtree_test_insert(mt, 2, (void *)0x5);\n\tmtree_test_insert(mt, 91, (void *)0xb7);\n\tmtree_test_insert(mt, 18, (void *)0x25);\n\tmtree_test_insert(mt, 81, (void *)0xa3);\n\tmtree_test_store_range(mt, 0, 128, (void *)0x1);\n\tmtree_test_store(mt, 1, (void *)0x3);\n\tmtree_test_erase(mt, 8);\n\tmtree_test_insert(mt, 11, (void *)0x17);\n\tmtree_test_insert(mt, 8, (void *)0x11);\n\tmtree_test_insert(mt, 21, (void *)0x2b);\n\tmtree_test_insert(mt, 2, (void *)0x5);\n\tmtree_test_insert(mt, ULONG_MAX - 10, (void *)0xffffffffffffffeb);\n\tmtree_test_erase(mt, ULONG_MAX - 10);\n\tmtree_test_store_range(mt, 0, 281, (void *)0x1);\n\tmtree_test_erase(mt, 2);\n\tmtree_test_insert(mt, 1211, (void *)0x977);\n\tmtree_test_insert(mt, 111, (void *)0xdf);\n\tmtree_test_insert(mt, 13, (void *)0x1b);\n\tmtree_test_insert(mt, 211, (void *)0x1a7);\n\tmtree_test_insert(mt, 11, (void *)0x17);\n\tmtree_test_insert(mt, 5, (void *)0xb);\n\tmtree_test_insert(mt, 1218, (void *)0x985);\n\tmtree_test_insert(mt, 61, (void *)0x7b);\n\tmtree_test_store(mt, 1, (void *)0x3);\n\tmtree_test_insert(mt, 121, (void *)0xf3);\n\tmtree_test_insert(mt, 8, (void *)0x11);\n\tmtree_test_insert(mt, 21, (void *)0x2b);\n\tmtree_test_insert(mt, 2, (void *)0x5);\n\tmtree_test_insert(mt, ULONG_MAX - 10, (void *)0xffffffffffffffeb);\n\tmtree_test_erase(mt, ULONG_MAX - 10);\n}\n\n \nstatic noinline void __init check_dup_gaps(struct maple_tree *mt,\n\t\t\t\t    unsigned long nr_entries, bool zero_start,\n\t\t\t\t    unsigned long gap)\n{\n\tunsigned long i = 0;\n\tstruct maple_tree newmt;\n\tint ret;\n\tvoid *tmp;\n\tMA_STATE(mas, mt, 0, 0);\n\tMA_STATE(newmas, &newmt, 0, 0);\n\tstruct rw_semaphore newmt_lock;\n\n\tinit_rwsem(&newmt_lock);\n\tmt_set_external_lock(&newmt, &newmt_lock);\n\n\tif (!zero_start)\n\t\ti = 1;\n\n\tmt_zero_nr_tallocated();\n\tfor (; i <= nr_entries; i++)\n\t\tmtree_store_range(mt, i*10, (i+1)*10 - gap,\n\t\t\t\t  xa_mk_value(i), GFP_KERNEL);\n\n\tmt_init_flags(&newmt, MT_FLAGS_ALLOC_RANGE | MT_FLAGS_LOCK_EXTERN);\n\tmt_set_non_kernel(99999);\n\tdown_write(&newmt_lock);\n\tret = mas_expected_entries(&newmas, nr_entries);\n\tmt_set_non_kernel(0);\n\tMT_BUG_ON(mt, ret != 0);\n\n\trcu_read_lock();\n\tmas_for_each(&mas, tmp, ULONG_MAX) {\n\t\tnewmas.index = mas.index;\n\t\tnewmas.last = mas.last;\n\t\tmas_store(&newmas, tmp);\n\t}\n\trcu_read_unlock();\n\tmas_destroy(&newmas);\n\n\t__mt_destroy(&newmt);\n\tup_write(&newmt_lock);\n}\n\n \nstatic noinline void __init check_dup(struct maple_tree *mt)\n{\n\tint i;\n\tint big_start = 100010;\n\n\t \n\tfor (i = 10; i < 1000; i++) {\n\t\tmt_init_flags(mt, MT_FLAGS_ALLOC_RANGE);\n\t\tcheck_dup_gaps(mt, i, true, 5);\n\t\tmtree_destroy(mt);\n\t\trcu_barrier();\n\t}\n\n\tcond_resched();\n\tmt_cache_shrink();\n\t \n\tfor (i = 1000; i < 2000; i++) {\n\t\tmt_init_flags(mt, MT_FLAGS_ALLOC_RANGE);\n\t\tcheck_dup_gaps(mt, i, true, 0);\n\t\tmtree_destroy(mt);\n\t\trcu_barrier();\n\t}\n\n\tcond_resched();\n\tmt_cache_shrink();\n\t \n\tfor (i = big_start; i < big_start + 10; i++) {\n\t\tmt_init_flags(mt, MT_FLAGS_ALLOC_RANGE);\n\t\tcheck_dup_gaps(mt, i, true, 5);\n\t\tmtree_destroy(mt);\n\t\trcu_barrier();\n\t}\n\n\tcond_resched();\n\tmt_cache_shrink();\n\t \n\tfor (i = 200; i < 1000; i++) {\n\t\tmt_init_flags(mt, MT_FLAGS_ALLOC_RANGE);\n\t\tcheck_dup_gaps(mt, i, false, 5);\n\t\tmtree_destroy(mt);\n\t\trcu_barrier();\n\t}\n\n\tcond_resched();\n\tmt_cache_shrink();\n\t \n\tfor (i = big_start; i < big_start + 10; i++) {\n\t\tmt_init_flags(mt, MT_FLAGS_ALLOC_RANGE);\n\t\tcheck_dup_gaps(mt, i, false, 5);\n\t\tmtree_destroy(mt);\n\t\trcu_barrier();\n\t\tcond_resched();\n\t\tmt_cache_shrink();\n\t}\n\n\t \n\tfor (i = 1500; i < 3000; i++) {\n\t\tmt_init_flags(mt, 0);\n\t\tcheck_dup_gaps(mt, i, false, 5);\n\t\tmtree_destroy(mt);\n\t\trcu_barrier();\n\t\tcond_resched();\n\t\tif (i % 2 == 0)\n\t\t\tmt_cache_shrink();\n\t}\n\n\tmt_cache_shrink();\n\t \n\tfor (i = 200; i < 1000; i++) {\n\t\tmt_init_flags(mt, 0);\n\t\tcheck_dup_gaps(mt, i, true, 5);\n\t\tmtree_destroy(mt);\n\t\trcu_barrier();\n\t\tcond_resched();\n\t}\n\n\tmt_cache_shrink();\n\t \n\tfor (i = big_start + 5; i < big_start + 10; i++) {\n\t\tmt_init_flags(mt, 0);\n\t\tcheck_dup_gaps(mt, i, true, 5);\n\t\tmtree_destroy(mt);\n\t\trcu_barrier();\n\t\tmt_cache_shrink();\n\t\tcond_resched();\n\t}\n}\n\nstatic noinline void __init check_bnode_min_spanning(struct maple_tree *mt)\n{\n\tint i = 50;\n\tMA_STATE(mas, mt, 0, 0);\n\n\tmt_set_non_kernel(9999);\n\tmas_lock(&mas);\n\tdo {\n\t\tmas_set_range(&mas, i*10, i*10+9);\n\t\tmas_store(&mas, check_bnode_min_spanning);\n\t} while (i--);\n\n\tmas_set_range(&mas, 240, 509);\n\tmas_store(&mas, NULL);\n\tmas_unlock(&mas);\n\tmas_destroy(&mas);\n\tmt_set_non_kernel(0);\n}\n\nstatic noinline void __init check_empty_area_window(struct maple_tree *mt)\n{\n\tunsigned long i, nr_entries = 20;\n\tMA_STATE(mas, mt, 0, 0);\n\n\tfor (i = 1; i <= nr_entries; i++)\n\t\tmtree_store_range(mt, i*10, i*10 + 9,\n\t\t\t\t  xa_mk_value(i), GFP_KERNEL);\n\n\t \n\tmtree_store_range(mt, 160, 169, NULL, GFP_KERNEL);\n\n\t \n\trcu_read_lock();\n\tMT_BUG_ON(mt, mas_empty_area_rev(&mas, 5, 90, 10) != -EBUSY);\n\n\tmas_reset(&mas);\n\tMT_BUG_ON(mt, mas_empty_area_rev(&mas, 6, 90, 5) != -EBUSY);\n\n\t \n\tmas_reset(&mas);\n\tMT_BUG_ON(mt, mas_empty_area_rev(&mas, 5, 90, 5) != 0);\n\tMT_BUG_ON(mt, mas.index != 5);\n\tMT_BUG_ON(mt, mas.last != 9);\n\trcu_read_unlock();\n\n\t \n\trcu_read_lock();\n\tmas_reset(&mas);\n\tMT_BUG_ON(mt, mas_empty_area_rev(&mas, 5, 217, 9) != 0);\n\tMT_BUG_ON(mt, mas.index != 161);\n\tMT_BUG_ON(mt, mas.last != 169);\n\n\t \n\tmas_reset(&mas);\n\tMT_BUG_ON(mt, mas_empty_area_rev(&mas, 100, 218, 3) != 0);\n\tMT_BUG_ON(mt, mas.index != 216);\n\tMT_BUG_ON(mt, mas.last != 218);\n\n\t \n\tmas_reset(&mas);\n\tMT_BUG_ON(mt, mas_empty_area_rev(&mas, 100, 218, 16) != -EBUSY);\n\n\t \n\tmas_reset(&mas);\n\tMT_BUG_ON(mt, mas_empty_area_rev(&mas, 167, 200, 4) != -EBUSY);\n\n\t \n\tmas_reset(&mas);\n\tMT_BUG_ON(mt, mas_empty_area_rev(&mas, 100, 162, 4) != -EBUSY);\n\n\t \n\tmas_reset(&mas);\n\tMT_BUG_ON(mt, mas_empty_area(&mas, 0, 100, 9) != 0);\n\tMT_BUG_ON(mt, mas.index != 0);\n\tMT_BUG_ON(mt, mas.last != 8);\n\n\tmas_reset(&mas);\n\tMT_BUG_ON(mt, mas_empty_area(&mas, 0, 100, 4) != 0);\n\tMT_BUG_ON(mt, mas.index != 0);\n\tMT_BUG_ON(mt, mas.last != 3);\n\n\tmas_reset(&mas);\n\tMT_BUG_ON(mt, mas_empty_area(&mas, 0, 100, 11) != -EBUSY);\n\n\tmas_reset(&mas);\n\tMT_BUG_ON(mt, mas_empty_area(&mas, 5, 100, 6) != -EBUSY);\n\n\tmas_reset(&mas);\n\tMT_BUG_ON(mt, mas_empty_area(&mas, 0, 8, 10) != -EINVAL);\n\n\tmas_reset(&mas);\n\tmas_empty_area(&mas, 100, 165, 3);\n\n\tmas_reset(&mas);\n\tMT_BUG_ON(mt, mas_empty_area(&mas, 100, 163, 6) != -EBUSY);\n\trcu_read_unlock();\n}\n\nstatic noinline void __init check_empty_area_fill(struct maple_tree *mt)\n{\n\tconst unsigned long max = 0x25D78000;\n\tunsigned long size;\n\tint loop, shift;\n\tMA_STATE(mas, mt, 0, 0);\n\n\tmt_set_non_kernel(99999);\n\tfor (shift = 12; shift <= 16; shift++) {\n\t\tloop = 5000;\n\t\tsize = 1 << shift;\n\t\twhile (loop--) {\n\t\t\tmas_set(&mas, 0);\n\t\t\tmas_lock(&mas);\n\t\t\tMT_BUG_ON(mt, mas_empty_area(&mas, 0, max, size) != 0);\n\t\t\tMT_BUG_ON(mt, mas.last != mas.index + size - 1);\n\t\t\tmas_store_gfp(&mas, (void *)size, GFP_KERNEL);\n\t\t\tmas_unlock(&mas);\n\t\t\tmas_reset(&mas);\n\t\t}\n\t}\n\n\t \n\tsize = 0x1000;\n\trcu_read_lock();\n\tMT_BUG_ON(mt, mas_empty_area(&mas, 0, max, size) != -EBUSY);\n\trcu_read_unlock();\n\n\t \n\tfor (unsigned long i = 629440511; i <= 629440800; i += 6)\n\t\tmtree_store_range(mt, i, i + 5, (void *)i, GFP_KERNEL);\n\t \n\tmtree_erase(mt, 631668735);\n\t \n\tmtree_erase(mt, 629506047);\n\tmas_reset(&mas);\n\t \n\trcu_read_lock();\n\tMT_BUG_ON(mt, mas_empty_area(&mas, 629506048, 690000000, 0x5000) != 0);\n\trcu_read_unlock();\n\tmt_set_non_kernel(0);\n}\n\n \n\n#define mas_active(x)\t\t(((x).node != MAS_ROOT) && \\\n\t\t\t\t ((x).node != MAS_START) && \\\n\t\t\t\t ((x).node != MAS_PAUSE) && \\\n\t\t\t\t ((x).node != MAS_NONE))\nstatic noinline void __init check_state_handling(struct maple_tree *mt)\n{\n\tMA_STATE(mas, mt, 0, 0);\n\tvoid *entry, *ptr = (void *) 0x1234500;\n\tvoid *ptr2 = &ptr;\n\tvoid *ptr3 = &ptr2;\n\n\t \n\tmtree_store_range(mt, 0, 0, ptr, GFP_KERNEL);\n\n\tmas_lock(&mas);\n\t \n\tentry = mas_prev(&mas, 0);\n\tMT_BUG_ON(mt, entry != NULL);\n\tMT_BUG_ON(mt, mas.node != MAS_UNDERFLOW);\n\n\t \n\tmas_set(&mas, 10);\n\tentry = mas_prev(&mas, 0);\n\tMT_BUG_ON(mt, entry != ptr);\n\tMT_BUG_ON(mt, mas.index != 0);\n\tMT_BUG_ON(mt, mas.last != 0);\n\tMT_BUG_ON(mt, mas.node != MAS_ROOT);\n\n\t \n\tmas_set(&mas, 10);\n\tmas_pause(&mas);\n\tentry = mas_prev(&mas, 0);\n\tMT_BUG_ON(mt, entry != ptr);\n\tMT_BUG_ON(mt, mas.index != 0);\n\tMT_BUG_ON(mt, mas.last != 0);\n\tMT_BUG_ON(mt, mas.node != MAS_ROOT);\n\n\t \n\tmas_set(&mas, 0);\n\tentry = mas_next(&mas, ULONG_MAX);\n\tMT_BUG_ON(mt, mas.index != 1);\n\tMT_BUG_ON(mt, mas.last != ULONG_MAX);\n\tMT_BUG_ON(mt, entry != NULL);\n\tMT_BUG_ON(mt, mas.node != MAS_NONE);\n\n\t \n\tmas_set(&mas, 10);\n\tentry = mas_next(&mas, ULONG_MAX);\n\tMT_BUG_ON(mt, mas.index != 1);\n\tMT_BUG_ON(mt, mas.last != ULONG_MAX);\n\tMT_BUG_ON(mt, entry != NULL);\n\tMT_BUG_ON(mt, mas.node != MAS_NONE);\n\n\t \n\tmas_set(&mas, 0);\n\tentry = mas_find(&mas, ULONG_MAX);\n\tMT_BUG_ON(mt, entry != ptr);\n\tMT_BUG_ON(mt, mas.index != 0);\n\tMT_BUG_ON(mt, mas.last != 0);\n\tMT_BUG_ON(mt, mas.node != MAS_ROOT);\n\n\t \n\tentry = mas_find(&mas, ULONG_MAX);\n\tMT_BUG_ON(mt, entry != NULL);\n\tMT_BUG_ON(mt, mas.index != 1);\n\tMT_BUG_ON(mt, mas.last != ULONG_MAX);\n\tMT_BUG_ON(mt, mas.node != MAS_NONE);\n\n\t \n\tentry = mas_find(&mas, ULONG_MAX);\n\tMT_BUG_ON(mt, entry != NULL);\n\tMT_BUG_ON(mt, mas.index != 1);\n\tMT_BUG_ON(mt, mas.last != ULONG_MAX);\n\tMT_BUG_ON(mt, mas.node != MAS_NONE);\n\n\t \n\tmas_set(&mas, 10);\n\tentry = mas_find(&mas, ULONG_MAX);\n\tMT_BUG_ON(mt, entry != NULL);\n\tMT_BUG_ON(mt, mas.index != 1);\n\tMT_BUG_ON(mt, mas.last != ULONG_MAX);\n\tMT_BUG_ON(mt, mas.node != MAS_NONE);\n\n\t \n\tentry = mas_find_rev(&mas, 0);\n\tMT_BUG_ON(mt, entry != ptr);\n\tMT_BUG_ON(mt, mas.index != 0);\n\tMT_BUG_ON(mt, mas.last != 0);\n\tMT_BUG_ON(mt, mas.node != MAS_ROOT);\n\n\t \n\tmas_set(&mas, 0);\n\tentry = mas_find_rev(&mas, 0);\n\tMT_BUG_ON(mt, entry != ptr);\n\tMT_BUG_ON(mt, mas.index != 0);\n\tMT_BUG_ON(mt, mas.last != 0);\n\tMT_BUG_ON(mt, mas.node != MAS_ROOT);\n\n\t \n\tentry = mas_find_rev(&mas, 0);\n\tMT_BUG_ON(mt, entry != NULL);\n\tMT_BUG_ON(mt, mas.index != 0);\n\tMT_BUG_ON(mt, mas.last != 0);\n\tMT_BUG_ON(mt, mas.node != MAS_NONE);\n\n\t \n\tentry = mas_find_rev(&mas, 0);\n\tMT_BUG_ON(mt, entry != NULL);\n\tMT_BUG_ON(mt, mas.index != 0);\n\tMT_BUG_ON(mt, mas.last != 0);\n\tMT_BUG_ON(mt, mas.node != MAS_NONE);\n\n\t \n\tmas_set(&mas, 10);\n\tentry = mas_find_rev(&mas, 0);\n\tMT_BUG_ON(mt, entry != ptr);\n\tMT_BUG_ON(mt, mas.index != 0);\n\tMT_BUG_ON(mt, mas.last != 0);\n\tMT_BUG_ON(mt, mas.node != MAS_ROOT);\n\n\t \n\tmas_set(&mas, 10);\n\tentry = mas_walk(&mas);\n\tMT_BUG_ON(mt, entry != NULL);\n\tMT_BUG_ON(mt, mas.index != 1);\n\tMT_BUG_ON(mt, mas.last != ULONG_MAX);\n\tMT_BUG_ON(mt, mas.node != MAS_NONE);\n\n\t \n\tmas_set(&mas, 10);\n\tmas_pause(&mas);\n\tentry = mas_walk(&mas);\n\tMT_BUG_ON(mt, entry != NULL);\n\tMT_BUG_ON(mt, mas.index != 1);\n\tMT_BUG_ON(mt, mas.last != ULONG_MAX);\n\tMT_BUG_ON(mt, mas.node != MAS_NONE);\n\n\t \n\tmas.index = mas.last = 10;\n\tentry = mas_walk(&mas);\n\tMT_BUG_ON(mt, entry != NULL);\n\tMT_BUG_ON(mt, mas.index != 1);\n\tMT_BUG_ON(mt, mas.last != ULONG_MAX);\n\tMT_BUG_ON(mt, mas.node != MAS_NONE);\n\n\t \n\tentry = mas_walk(&mas);\n\tMT_BUG_ON(mt, entry != NULL);\n\tMT_BUG_ON(mt, mas.index != 1);\n\tMT_BUG_ON(mt, mas.last != ULONG_MAX);\n\tMT_BUG_ON(mt, mas.node != MAS_NONE);\n\n\t \n\tmas_set(&mas, 0);\n\tentry = mas_walk(&mas);\n\tMT_BUG_ON(mt, entry != ptr);\n\tMT_BUG_ON(mt, mas.index != 0);\n\tMT_BUG_ON(mt, mas.last != 0);\n\tMT_BUG_ON(mt, mas.node != MAS_ROOT);\n\n\t \n\tmas_set(&mas, 0);\n\tmas_pause(&mas);\n\tentry = mas_walk(&mas);\n\tMT_BUG_ON(mt, entry != ptr);\n\tMT_BUG_ON(mt, mas.index != 0);\n\tMT_BUG_ON(mt, mas.last != 0);\n\tMT_BUG_ON(mt, mas.node != MAS_ROOT);\n\n\t \n\tmas.node = MAS_NONE;\n\tentry = mas_walk(&mas);\n\tMT_BUG_ON(mt, entry != ptr);\n\tMT_BUG_ON(mt, mas.index != 0);\n\tMT_BUG_ON(mt, mas.last != 0);\n\tMT_BUG_ON(mt, mas.node != MAS_ROOT);\n\n\t \n\tentry = mas_walk(&mas);\n\tMT_BUG_ON(mt, entry != ptr);\n\tMT_BUG_ON(mt, mas.index != 0);\n\tMT_BUG_ON(mt, mas.last != 0);\n\tMT_BUG_ON(mt, mas.node != MAS_ROOT);\n\n\t \n\tmas_set(&mas, 10);\n\tentry = mas_walk(&mas);\n\tMT_BUG_ON(mt, entry != NULL);\n\tMT_BUG_ON(mt, mas.index != 1);\n\tMT_BUG_ON(mt, mas.last != ULONG_MAX);\n\tMT_BUG_ON(mt, mas.node != MAS_NONE);\n\n\t \n\tmas.index = mas.last = 0;\n\tentry = mas_walk(&mas);\n\tMT_BUG_ON(mt, entry != ptr);\n\tMT_BUG_ON(mt, mas.index != 0);\n\tMT_BUG_ON(mt, mas.last != 0);\n\tMT_BUG_ON(mt, mas.node != MAS_ROOT);\n\n\tmas_unlock(&mas);\n\n\t \n\tmtree_store_range(mt, 0, 0, NULL, GFP_KERNEL);\n\tmtree_store_range(mt, 0x1000, 0x1500, ptr, GFP_KERNEL);\n\tmtree_store_range(mt, 0x2000, 0x2500, ptr2, GFP_KERNEL);\n\tmtree_store_range(mt, 0x3000, 0x3500, ptr3, GFP_KERNEL);\n\n\tmas_lock(&mas);\n\n\t \n\tmas_set(&mas, 0);\n\tentry = mas_next(&mas, ULONG_MAX);\n\tMT_BUG_ON(mt, entry != ptr);\n\tMT_BUG_ON(mt, mas.index != 0x1000);\n\tMT_BUG_ON(mt, mas.last != 0x1500);\n\tMT_BUG_ON(mt, !mas_active(mas));\n\n\t \n\tmas_set(&mas, 0);\n\tmas_pause(&mas);\n\tentry = mas_next(&mas, ULONG_MAX);\n\tMT_BUG_ON(mt, entry != ptr);\n\tMT_BUG_ON(mt, mas.index != 0x1000);\n\tMT_BUG_ON(mt, mas.last != 0x1500);\n\tMT_BUG_ON(mt, !mas_active(mas));\n\n\t \n\tmas.index = mas.last = 0;\n\tmas.offset = 0;\n\tmas.node = MAS_NONE;\n\tentry = mas_next(&mas, ULONG_MAX);\n\tMT_BUG_ON(mt, entry != ptr);\n\tMT_BUG_ON(mt, mas.index != 0x1000);\n\tMT_BUG_ON(mt, mas.last != 0x1500);\n\tMT_BUG_ON(mt, !mas_active(mas));\n\n\t \n\tentry = mas_next(&mas, ULONG_MAX);\n\tMT_BUG_ON(mt, entry != ptr2);\n\tMT_BUG_ON(mt, mas.index != 0x2000);\n\tMT_BUG_ON(mt, mas.last != 0x2500);\n\tMT_BUG_ON(mt, !mas_active(mas));\n\n\t \n\tentry = mas_next(&mas, 0x2999);\n\tMT_BUG_ON(mt, entry != NULL);\n\tMT_BUG_ON(mt, mas.index != 0x2501);\n\tMT_BUG_ON(mt, mas.last != 0x2fff);\n\tMT_BUG_ON(mt, !mas_active(mas));\n\n\t \n\tentry = mas_next(&mas, ULONG_MAX);\n\tMT_BUG_ON(mt, entry != ptr3);\n\tMT_BUG_ON(mt, mas.index != 0x3000);\n\tMT_BUG_ON(mt, mas.last != 0x3500);\n\tMT_BUG_ON(mt, !mas_active(mas));\n\n\t \n\tentry = mas_next(&mas, ULONG_MAX);\n\tMT_BUG_ON(mt, entry != NULL);\n\tMT_BUG_ON(mt, mas.index != 0x3501);\n\tMT_BUG_ON(mt, mas.last != ULONG_MAX);\n\tMT_BUG_ON(mt, !mas_active(mas));\n\n\t \n\tentry = mas_next(&mas, ULONG_MAX);\n\tMT_BUG_ON(mt, entry != NULL);\n\tMT_BUG_ON(mt, mas.index != 0x3501);\n\tMT_BUG_ON(mt, mas.last != ULONG_MAX);\n\tMT_BUG_ON(mt, mas.node != MAS_OVERFLOW);\n\n\t \n\tentry = mas_next(&mas, ULONG_MAX);\n\tMT_BUG_ON(mt, entry != NULL);\n\tMT_BUG_ON(mt, mas.index != 0x3501);\n\tMT_BUG_ON(mt, mas.last != ULONG_MAX);\n\tMT_BUG_ON(mt, mas.node != MAS_OVERFLOW);\n\n\t \n\tentry = mas_prev(&mas, 0);\n\tMT_BUG_ON(mt, entry != ptr3);\n\tMT_BUG_ON(mt, mas.index != 0x3000);\n\tMT_BUG_ON(mt, mas.last != 0x3500);\n\tMT_BUG_ON(mt, !mas_active(mas));\n\n\t \n\tmas_set(&mas, 0);\n\tentry = mas_next(&mas, ULONG_MAX);\n\tmas.node = MAS_NONE;\n\tmas.offset = 0;\n\tentry = mas_next(&mas, ULONG_MAX);\n\tMT_BUG_ON(mt, entry != ptr2);\n\tMT_BUG_ON(mt, mas.index != 0x2000);\n\tMT_BUG_ON(mt, mas.last != 0x2500);\n\tMT_BUG_ON(mt, !mas_active(mas));\n\n\t \n\tentry = mas_prev(&mas, 0);\n\tMT_BUG_ON(mt, entry != ptr);\n\tMT_BUG_ON(mt, mas.index != 0x1000);\n\tMT_BUG_ON(mt, mas.last != 0x1500);\n\tMT_BUG_ON(mt, !mas_active(mas));\n\n\t \n\tentry = mas_prev(&mas, 0x0100);\n\tMT_BUG_ON(mt, entry != NULL);\n\tMT_BUG_ON(mt, mas.index != 0);\n\tMT_BUG_ON(mt, mas.last != 0x0FFF);\n\tMT_BUG_ON(mt, !mas_active(mas));\n\n\t \n\tentry = mas_prev(&mas, 0);\n\tMT_BUG_ON(mt, entry != NULL);\n\tMT_BUG_ON(mt, mas.index != 0);\n\tMT_BUG_ON(mt, mas.last != 0x0FFF);\n\tMT_BUG_ON(mt, mas.node != MAS_UNDERFLOW);\n\n\t \n\tentry = mas_prev(&mas, 0);\n\tMT_BUG_ON(mt, entry != NULL);\n\tMT_BUG_ON(mt, mas.index != 0);\n\tMT_BUG_ON(mt, mas.last != 0x0FFF);\n\tMT_BUG_ON(mt, mas.node != MAS_UNDERFLOW);\n\n\t \n\tentry = mas_next(&mas, ULONG_MAX);\n\tMT_BUG_ON(mt, entry != ptr);\n\tMT_BUG_ON(mt, mas.index != 0x1000);\n\tMT_BUG_ON(mt, mas.last != 0x1500);\n\tMT_BUG_ON(mt, !mas_active(mas));\n\n\t \n\tentry = mas_prev(&mas, 0x1000);\n\tMT_BUG_ON(mt, entry != NULL);\n\tMT_BUG_ON(mt, mas.index != 0x1000);\n\tMT_BUG_ON(mt, mas.last != 0x1500);\n\tMT_BUG_ON(mt, mas.node != MAS_UNDERFLOW);\n\n\t \n\tentry = mas_find(&mas, ULONG_MAX);\n\tMT_BUG_ON(mt, entry != ptr);\n\tMT_BUG_ON(mt, mas.index != 0x1000);\n\tMT_BUG_ON(mt, mas.last != 0x1500);\n\tMT_BUG_ON(mt, !mas_active(mas));\n\n\t \n\tmas_set(&mas, 0x3600);\n\tentry = mas_prev(&mas, 0);\n\tMT_BUG_ON(mt, entry != ptr3);\n\tmas_pause(&mas);\n\tentry = mas_prev(&mas, 0);\n\tMT_BUG_ON(mt, entry != ptr2);\n\tMT_BUG_ON(mt, mas.index != 0x2000);\n\tMT_BUG_ON(mt, mas.last != 0x2500);\n\tMT_BUG_ON(mt, !mas_active(mas));\n\n\t \n\tentry = mas_prev(&mas, 0x1600);\n\tMT_BUG_ON(mt, entry != NULL);\n\tMT_BUG_ON(mt, mas.index != 0x1501);\n\tMT_BUG_ON(mt, mas.last != 0x1FFF);\n\tMT_BUG_ON(mt, !mas_active(mas));\n\n\t \n\tentry = mas_prev(&mas, 0);\n\tMT_BUG_ON(mt, entry != ptr);\n\tMT_BUG_ON(mt, mas.index != 0x1000);\n\tMT_BUG_ON(mt, mas.last != 0x1500);\n\tMT_BUG_ON(mt, !mas_active(mas));\n\n\t \n\tmas_set(&mas, 0);\n\tentry = mas_find(&mas, ULONG_MAX);\n\tMT_BUG_ON(mt, entry != ptr);\n\tMT_BUG_ON(mt, mas.index != 0x1000);\n\tMT_BUG_ON(mt, mas.last != 0x1500);\n\tMT_BUG_ON(mt, !mas_active(mas));\n\n\t \n\tmas_set(&mas, 0);\n\tmas_pause(&mas);\n\tentry = mas_find(&mas, ULONG_MAX);\n\tMT_BUG_ON(mt, entry != ptr);\n\tMT_BUG_ON(mt, mas.index != 0x1000);\n\tMT_BUG_ON(mt, mas.last != 0x1500);\n\tMT_BUG_ON(mt, !mas_active(mas));\n\n\t ;\n\tmas_set(&mas, 1200);\n\tentry = mas_find(&mas, ULONG_MAX);\n\tMT_BUG_ON(mt, entry != ptr);\n\tMT_BUG_ON(mt, mas.index != 0x1000);\n\tMT_BUG_ON(mt, mas.last != 0x1500);\n\tMT_BUG_ON(mt, !mas_active(mas));\n\n\t \n\tentry = mas_find(&mas, ULONG_MAX);\n\tMT_BUG_ON(mt, entry != ptr2);\n\tMT_BUG_ON(mt, mas.index != 0x2000);\n\tMT_BUG_ON(mt, mas.last != 0x2500);\n\tMT_BUG_ON(mt, !mas_active(mas));\n\n\n\t \n\tentry = mas_find(&mas, 0x2700);\n\tMT_BUG_ON(mt, entry != NULL);\n\tMT_BUG_ON(mt, mas.index != 0x2501);\n\tMT_BUG_ON(mt, mas.last != 0x2FFF);\n\tMT_BUG_ON(mt, !mas_active(mas));\n\n\t \n\tentry = mas_find(&mas, 0x5000);\n\tMT_BUG_ON(mt, entry != ptr3);\n\tMT_BUG_ON(mt, mas.index != 0x3000);\n\tMT_BUG_ON(mt, mas.last != 0x3500);\n\tMT_BUG_ON(mt, !mas_active(mas));\n\n\t \n\tentry = mas_find(&mas, ULONG_MAX);\n\tMT_BUG_ON(mt, entry != NULL);\n\tMT_BUG_ON(mt, mas.index != 0x3501);\n\tMT_BUG_ON(mt, mas.last != ULONG_MAX);\n\tMT_BUG_ON(mt, !mas_active(mas));\n\n\t \n\tentry = mas_find_rev(&mas, 0);\n\tMT_BUG_ON(mt, entry != ptr3);\n\tMT_BUG_ON(mt, mas.index != 0x3000);\n\tMT_BUG_ON(mt, mas.last != 0x3500);\n\tMT_BUG_ON(mt, !mas_active(mas));\n\n\t \n\tentry = mas_find_rev(&mas, 0);\n\tMT_BUG_ON(mt, entry != ptr2);\n\tMT_BUG_ON(mt, mas.index != 0x2000);\n\tMT_BUG_ON(mt, mas.last != 0x2500);\n\tMT_BUG_ON(mt, !mas_active(mas));\n\n\t \n\tmas_pause(&mas);\n\tentry = mas_find_rev(&mas, 0);\n\tMT_BUG_ON(mt, entry != ptr);\n\tMT_BUG_ON(mt, mas.index != 0x1000);\n\tMT_BUG_ON(mt, mas.last != 0x1500);\n\tMT_BUG_ON(mt, !mas_active(mas));\n\n\t \n\tentry = mas_find_rev(&mas, 0);\n\tMT_BUG_ON(mt, entry != NULL);\n\tMT_BUG_ON(mt, mas.index != 0);\n\tMT_BUG_ON(mt, mas.last != 0x0FFF);\n\tMT_BUG_ON(mt, !mas_active(mas));\n\n\t \n\tmas_set(&mas, 0x1200);\n\tentry = mas_find_rev(&mas, 0);\n\tMT_BUG_ON(mt, entry != ptr);\n\tMT_BUG_ON(mt, mas.index != 0x1000);\n\tMT_BUG_ON(mt, mas.last != 0x1500);\n\tMT_BUG_ON(mt, !mas_active(mas));\n\n\t \n\tmas_set(&mas, 0x1200);\n\tentry = mas_walk(&mas);\n\tMT_BUG_ON(mt, entry != ptr);\n\tMT_BUG_ON(mt, mas.index != 0x1000);\n\tMT_BUG_ON(mt, mas.last != 0x1500);\n\tMT_BUG_ON(mt, !mas_active(mas));\n\n\t \n\tmas_set(&mas, 0x1600);\n\tentry = mas_walk(&mas);\n\tMT_BUG_ON(mt, entry != NULL);\n\tMT_BUG_ON(mt, mas.index != 0x1501);\n\tMT_BUG_ON(mt, mas.last != 0x1fff);\n\tMT_BUG_ON(mt, !mas_active(mas));\n\n\t \n\tmas_set(&mas, 0x1200);\n\tmas_pause(&mas);\n\tentry = mas_walk(&mas);\n\tMT_BUG_ON(mt, entry != ptr);\n\tMT_BUG_ON(mt, mas.index != 0x1000);\n\tMT_BUG_ON(mt, mas.last != 0x1500);\n\tMT_BUG_ON(mt, !mas_active(mas));\n\n\t \n\tmas_set(&mas, 0x1600);\n\tmas_pause(&mas);\n\tentry = mas_walk(&mas);\n\tMT_BUG_ON(mt, entry != NULL);\n\tMT_BUG_ON(mt, mas.index != 0x1501);\n\tMT_BUG_ON(mt, mas.last != 0x1fff);\n\tMT_BUG_ON(mt, !mas_active(mas));\n\n\t \n\tmas_set(&mas, 0x1200);\n\tmas.node = MAS_NONE;\n\tentry = mas_walk(&mas);\n\tMT_BUG_ON(mt, entry != ptr);\n\tMT_BUG_ON(mt, mas.index != 0x1000);\n\tMT_BUG_ON(mt, mas.last != 0x1500);\n\tMT_BUG_ON(mt, !mas_active(mas));\n\n\t \n\tmas_set(&mas, 0x1600);\n\tmas.node = MAS_NONE;\n\tentry = mas_walk(&mas);\n\tMT_BUG_ON(mt, entry != NULL);\n\tMT_BUG_ON(mt, mas.index != 0x1501);\n\tMT_BUG_ON(mt, mas.last != 0x1fff);\n\tMT_BUG_ON(mt, !mas_active(mas));\n\n\t \n\tmas.index = 0x1200;\n\tmas.last = 0x1200;\n\tmas.offset = 0;\n\tentry = mas_walk(&mas);\n\tMT_BUG_ON(mt, entry != ptr);\n\tMT_BUG_ON(mt, mas.index != 0x1000);\n\tMT_BUG_ON(mt, mas.last != 0x1500);\n\tMT_BUG_ON(mt, !mas_active(mas));\n\n\t \n\tmas.index = 0x1600;\n\tmas.last = 0x1600;\n\tentry = mas_walk(&mas);\n\tMT_BUG_ON(mt, entry != NULL);\n\tMT_BUG_ON(mt, mas.index != 0x1501);\n\tMT_BUG_ON(mt, mas.last != 0x1fff);\n\tMT_BUG_ON(mt, !mas_active(mas));\n\n\tmas_unlock(&mas);\n}\n\nstatic DEFINE_MTREE(tree);\nstatic int __init maple_tree_seed(void)\n{\n\tunsigned long set[] = { 5015, 5014, 5017, 25, 1000,\n\t\t\t\t1001, 1002, 1003, 1005, 0,\n\t\t\t\t5003, 5002};\n\tvoid *ptr = &set;\n\n\tpr_info(\"\\nTEST STARTING\\n\\n\");\n\n\tmt_init_flags(&tree, MT_FLAGS_ALLOC_RANGE);\n\tcheck_root_expand(&tree);\n\tmtree_destroy(&tree);\n\n#if defined(BENCH_SLOT_STORE)\n#define BENCH\n\tmt_init_flags(&tree, MT_FLAGS_ALLOC_RANGE);\n\tbench_slot_store(&tree);\n\tmtree_destroy(&tree);\n\tgoto skip;\n#endif\n#if defined(BENCH_NODE_STORE)\n#define BENCH\n\tmt_init_flags(&tree, MT_FLAGS_ALLOC_RANGE);\n\tbench_node_store(&tree);\n\tmtree_destroy(&tree);\n\tgoto skip;\n#endif\n#if defined(BENCH_AWALK)\n#define BENCH\n\tmt_init_flags(&tree, MT_FLAGS_ALLOC_RANGE);\n\tbench_awalk(&tree);\n\tmtree_destroy(&tree);\n\tgoto skip;\n#endif\n#if defined(BENCH_WALK)\n#define BENCH\n\tmt_init_flags(&tree, MT_FLAGS_ALLOC_RANGE);\n\tbench_walk(&tree);\n\tmtree_destroy(&tree);\n\tgoto skip;\n#endif\n#if defined(BENCH_FORK)\n#define BENCH\n\tmt_init_flags(&tree, MT_FLAGS_ALLOC_RANGE);\n\tbench_forking(&tree);\n\tmtree_destroy(&tree);\n\tgoto skip;\n#endif\n#if defined(BENCH_MT_FOR_EACH)\n#define BENCH\n\tmt_init_flags(&tree, MT_FLAGS_ALLOC_RANGE);\n\tbench_mt_for_each(&tree);\n\tmtree_destroy(&tree);\n\tgoto skip;\n#endif\n#if defined(BENCH_MAS_FOR_EACH)\n#define BENCH\n\tmt_init_flags(&tree, MT_FLAGS_ALLOC_RANGE);\n\tbench_mas_for_each(&tree);\n\tmtree_destroy(&tree);\n\tgoto skip;\n#endif\n#if defined(BENCH_MAS_PREV)\n#define BENCH\n\tmt_init_flags(&tree, MT_FLAGS_ALLOC_RANGE);\n\tbench_mas_prev(&tree);\n\tmtree_destroy(&tree);\n\tgoto skip;\n#endif\n\n\tmt_init_flags(&tree, MT_FLAGS_ALLOC_RANGE);\n\tcheck_iteration(&tree);\n\tmtree_destroy(&tree);\n\n\tmt_init_flags(&tree, MT_FLAGS_ALLOC_RANGE);\n\tcheck_forking(&tree);\n\tmtree_destroy(&tree);\n\n\tmt_init_flags(&tree, MT_FLAGS_ALLOC_RANGE);\n\tcheck_mas_store_gfp(&tree);\n\tmtree_destroy(&tree);\n\n\t \n\tmt_init_flags(&tree, 0);\n\tcheck_ranges(&tree);\n\tmtree_destroy(&tree);\n\n#if defined(CONFIG_64BIT)\n\t \n\tmt_init_flags(&tree, MT_FLAGS_ALLOC_RANGE);\n\tcheck_alloc_range(&tree);\n\tmtree_destroy(&tree);\n\n\tmt_init_flags(&tree, MT_FLAGS_ALLOC_RANGE);\n\tcheck_alloc_rev_range(&tree);\n\tmtree_destroy(&tree);\n#endif\n\n\tmt_init_flags(&tree, 0);\n\n\tcheck_load(&tree, set[0], NULL);        \n\n\tcheck_insert(&tree, set[9], &tree);      \n\tcheck_load(&tree, set[9], &tree);        \n\tcheck_load(&tree, set[0], NULL);        \n\n\tcheck_insert(&tree, set[10], ptr);       \n\tcheck_load(&tree, set[9], &tree);        \n\tcheck_load(&tree, set[11], NULL);        \n\tcheck_load(&tree, set[10], ptr);        \n\n\t \n\tmtree_destroy(&tree);\n\n\t \n\tmt_init_flags(&tree, 0);\n\tcheck_insert(&tree, set[0], &tree);      \n\tcheck_dup_insert(&tree, set[0], &tree);  \n\tcheck_load(&tree, set[0], &tree);        \n\n\t \n\tcheck_load(&tree, set[1], NULL);         \n\tcheck_insert(&tree, set[1], ptr);        \n\tcheck_load(&tree, set[1], ptr);          \n\tcheck_load(&tree, set[0], &tree);        \n\t \n\tcheck_insert(&tree, set[6], ptr);        \n\tcheck_insert(&tree, set[7], &tree);        \n\n\tcheck_load(&tree, set[0], &tree);        \n\tcheck_load(&tree, set[1], ptr);          \n\tcheck_load(&tree, set[6], ptr);          \n\tcheck_load(&tree, set[7], &tree);        \n\n\t \n\tmtree_destroy(&tree);\n\n\tmt_init_flags(&tree, 0);\n\t \n\tcheck_insert(&tree, set[5], ptr);        \n\tcheck_insert(&tree, set[7], &tree);        \n\tcheck_insert(&tree, set[6], ptr);        \n\tcheck_load(&tree, set[5], ptr);          \n\tcheck_load(&tree, set[6], ptr);          \n\tcheck_load(&tree, set[7], &tree);        \n\n\t \n\tmtree_destroy(&tree);\n\n\tmt_init_flags(&tree, 0);\n\t \n\n\tcheck_insert(&tree, set[0], ptr);  \n\tcheck_insert(&tree, set[1], &tree);  \n\tcheck_insert(&tree, set[2], ptr);  \n\tcheck_insert(&tree, set[3], &tree);  \n\tcheck_load(&tree, set[0], ptr);\n\tcheck_load(&tree, set[1], &tree);\n\tcheck_load(&tree, set[2], ptr);\n\tcheck_load(&tree, set[3], &tree);\n\tcheck_insert(&tree, set[4], ptr);  \n\tcheck_load(&tree, set[0], ptr);\n\tcheck_load(&tree, set[1], &tree);\n\tcheck_load(&tree, set[2], ptr);\n\tcheck_load(&tree, set[3], &tree);  \n\tcheck_load(&tree, set[4], ptr);\n\tcheck_insert(&tree, set[5], &tree);  \n\tcheck_load(&tree, set[0], ptr);\n\tcheck_load(&tree, set[1], &tree);\n\tcheck_load(&tree, set[2], ptr);\n\tcheck_load(&tree, set[3], &tree);\n\tcheck_load(&tree, set[4], ptr);\n\tcheck_load(&tree, set[5], &tree);\n\tcheck_insert(&tree, set[6], ptr);\n\tcheck_load(&tree, set[0], ptr);\n\tcheck_load(&tree, set[1], &tree);\n\tcheck_load(&tree, set[2], ptr);\n\tcheck_load(&tree, set[3], &tree);\n\tcheck_load(&tree, set[4], ptr);\n\tcheck_load(&tree, set[5], &tree);\n\tcheck_load(&tree, set[6], ptr);\n\tcheck_insert(&tree, set[7], &tree);\n\tcheck_load(&tree, set[0], ptr);\n\tcheck_insert(&tree, set[8], ptr);\n\n\tcheck_insert(&tree, set[9], &tree);\n\n\tcheck_load(&tree, set[0], ptr);\n\tcheck_load(&tree, set[1], &tree);\n\tcheck_load(&tree, set[2], ptr);\n\tcheck_load(&tree, set[3], &tree);\n\tcheck_load(&tree, set[4], ptr);\n\tcheck_load(&tree, set[5], &tree);\n\tcheck_load(&tree, set[6], ptr);\n\tcheck_load(&tree, set[9], &tree);\n\tmtree_destroy(&tree);\n\n\tmt_init_flags(&tree, 0);\n\tcheck_seq(&tree, 16, false);\n\tmtree_destroy(&tree);\n\n\tmt_init_flags(&tree, 0);\n\tcheck_seq(&tree, 1000, true);\n\tmtree_destroy(&tree);\n\n\tmt_init_flags(&tree, MT_FLAGS_ALLOC_RANGE);\n\tcheck_rev_seq(&tree, 1000, true);\n\tmtree_destroy(&tree);\n\n\tcheck_lower_bound_split(&tree);\n\tcheck_upper_bound_split(&tree);\n\tcheck_mid_split(&tree);\n\n\tmt_init_flags(&tree, 0);\n\tcheck_next_entry(&tree);\n\tcheck_find(&tree);\n\tcheck_find_2(&tree);\n\tmtree_destroy(&tree);\n\n\tmt_init_flags(&tree, MT_FLAGS_ALLOC_RANGE);\n\tcheck_prev_entry(&tree);\n\tmtree_destroy(&tree);\n\n\tmt_init_flags(&tree, MT_FLAGS_ALLOC_RANGE);\n\tcheck_gap_combining(&tree);\n\tmtree_destroy(&tree);\n\n\tmt_init_flags(&tree, MT_FLAGS_ALLOC_RANGE);\n\tcheck_node_overwrite(&tree);\n\tmtree_destroy(&tree);\n\n\tmt_init_flags(&tree, MT_FLAGS_ALLOC_RANGE);\n\tnext_prev_test(&tree);\n\tmtree_destroy(&tree);\n\n\tmt_init_flags(&tree, MT_FLAGS_ALLOC_RANGE);\n\tcheck_spanning_relatives(&tree);\n\tmtree_destroy(&tree);\n\n\tmt_init_flags(&tree, MT_FLAGS_ALLOC_RANGE);\n\tcheck_rev_find(&tree);\n\tmtree_destroy(&tree);\n\n\tmt_init_flags(&tree, 0);\n\tcheck_fuzzer(&tree);\n\tmtree_destroy(&tree);\n\n\tmt_init_flags(&tree, MT_FLAGS_ALLOC_RANGE);\n\tcheck_dup(&tree);\n\tmtree_destroy(&tree);\n\n\tmt_init_flags(&tree, MT_FLAGS_ALLOC_RANGE);\n\tcheck_bnode_min_spanning(&tree);\n\tmtree_destroy(&tree);\n\n\tmt_init_flags(&tree, MT_FLAGS_ALLOC_RANGE);\n\tcheck_empty_area_window(&tree);\n\tmtree_destroy(&tree);\n\n\tmt_init_flags(&tree, MT_FLAGS_ALLOC_RANGE);\n\tcheck_empty_area_fill(&tree);\n\tmtree_destroy(&tree);\n\n\tmt_init_flags(&tree, MT_FLAGS_ALLOC_RANGE);\n\tcheck_state_handling(&tree);\n\tmtree_destroy(&tree);\n\n#if defined(BENCH)\nskip:\n#endif\n\trcu_barrier();\n\tpr_info(\"maple_tree: %u of %u tests passed\\n\",\n\t\t\tatomic_read(&maple_tree_tests_passed),\n\t\t\tatomic_read(&maple_tree_tests_run));\n\tif (atomic_read(&maple_tree_tests_run) ==\n\t    atomic_read(&maple_tree_tests_passed))\n\t\treturn 0;\n\n\treturn -EINVAL;\n}\n\nstatic void __exit maple_tree_harvest(void)\n{\n\n}\n\nmodule_init(maple_tree_seed);\nmodule_exit(maple_tree_harvest);\nMODULE_AUTHOR(\"Liam R. Howlett <Liam.Howlett@Oracle.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}