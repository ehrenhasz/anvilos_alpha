{
  "module_name": "xxhash.c",
  "hash_id": "92aa8bdbe0c057f68c1d09a337a4e17e80aee602df872ef95d9fa17b42367094",
  "original_prompt": "Ingested from linux-6.6.14/lib/xxhash.c",
  "human_readable_source": " \n\n#include <asm/unaligned.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/string.h>\n#include <linux/xxhash.h>\n\n \n#define xxh_rotl32(x, r) ((x << r) | (x >> (32 - r)))\n#define xxh_rotl64(x, r) ((x << r) | (x >> (64 - r)))\n\n#ifdef __LITTLE_ENDIAN\n# define XXH_CPU_LITTLE_ENDIAN 1\n#else\n# define XXH_CPU_LITTLE_ENDIAN 0\n#endif\n\n \nstatic const uint32_t PRIME32_1 = 2654435761U;\nstatic const uint32_t PRIME32_2 = 2246822519U;\nstatic const uint32_t PRIME32_3 = 3266489917U;\nstatic const uint32_t PRIME32_4 =  668265263U;\nstatic const uint32_t PRIME32_5 =  374761393U;\n\nstatic const uint64_t PRIME64_1 = 11400714785074694791ULL;\nstatic const uint64_t PRIME64_2 = 14029467366897019727ULL;\nstatic const uint64_t PRIME64_3 =  1609587929392839161ULL;\nstatic const uint64_t PRIME64_4 =  9650029242287828579ULL;\nstatic const uint64_t PRIME64_5 =  2870177450012600261ULL;\n\n \nvoid xxh32_copy_state(struct xxh32_state *dst, const struct xxh32_state *src)\n{\n\tmemcpy(dst, src, sizeof(*dst));\n}\nEXPORT_SYMBOL(xxh32_copy_state);\n\nvoid xxh64_copy_state(struct xxh64_state *dst, const struct xxh64_state *src)\n{\n\tmemcpy(dst, src, sizeof(*dst));\n}\nEXPORT_SYMBOL(xxh64_copy_state);\n\n \nstatic uint32_t xxh32_round(uint32_t seed, const uint32_t input)\n{\n\tseed += input * PRIME32_2;\n\tseed = xxh_rotl32(seed, 13);\n\tseed *= PRIME32_1;\n\treturn seed;\n}\n\nuint32_t xxh32(const void *input, const size_t len, const uint32_t seed)\n{\n\tconst uint8_t *p = (const uint8_t *)input;\n\tconst uint8_t *b_end = p + len;\n\tuint32_t h32;\n\n\tif (len >= 16) {\n\t\tconst uint8_t *const limit = b_end - 16;\n\t\tuint32_t v1 = seed + PRIME32_1 + PRIME32_2;\n\t\tuint32_t v2 = seed + PRIME32_2;\n\t\tuint32_t v3 = seed + 0;\n\t\tuint32_t v4 = seed - PRIME32_1;\n\n\t\tdo {\n\t\t\tv1 = xxh32_round(v1, get_unaligned_le32(p));\n\t\t\tp += 4;\n\t\t\tv2 = xxh32_round(v2, get_unaligned_le32(p));\n\t\t\tp += 4;\n\t\t\tv3 = xxh32_round(v3, get_unaligned_le32(p));\n\t\t\tp += 4;\n\t\t\tv4 = xxh32_round(v4, get_unaligned_le32(p));\n\t\t\tp += 4;\n\t\t} while (p <= limit);\n\n\t\th32 = xxh_rotl32(v1, 1) + xxh_rotl32(v2, 7) +\n\t\t\txxh_rotl32(v3, 12) + xxh_rotl32(v4, 18);\n\t} else {\n\t\th32 = seed + PRIME32_5;\n\t}\n\n\th32 += (uint32_t)len;\n\n\twhile (p + 4 <= b_end) {\n\t\th32 += get_unaligned_le32(p) * PRIME32_3;\n\t\th32 = xxh_rotl32(h32, 17) * PRIME32_4;\n\t\tp += 4;\n\t}\n\n\twhile (p < b_end) {\n\t\th32 += (*p) * PRIME32_5;\n\t\th32 = xxh_rotl32(h32, 11) * PRIME32_1;\n\t\tp++;\n\t}\n\n\th32 ^= h32 >> 15;\n\th32 *= PRIME32_2;\n\th32 ^= h32 >> 13;\n\th32 *= PRIME32_3;\n\th32 ^= h32 >> 16;\n\n\treturn h32;\n}\nEXPORT_SYMBOL(xxh32);\n\nstatic uint64_t xxh64_round(uint64_t acc, const uint64_t input)\n{\n\tacc += input * PRIME64_2;\n\tacc = xxh_rotl64(acc, 31);\n\tacc *= PRIME64_1;\n\treturn acc;\n}\n\nstatic uint64_t xxh64_merge_round(uint64_t acc, uint64_t val)\n{\n\tval = xxh64_round(0, val);\n\tacc ^= val;\n\tacc = acc * PRIME64_1 + PRIME64_4;\n\treturn acc;\n}\n\nuint64_t xxh64(const void *input, const size_t len, const uint64_t seed)\n{\n\tconst uint8_t *p = (const uint8_t *)input;\n\tconst uint8_t *const b_end = p + len;\n\tuint64_t h64;\n\n\tif (len >= 32) {\n\t\tconst uint8_t *const limit = b_end - 32;\n\t\tuint64_t v1 = seed + PRIME64_1 + PRIME64_2;\n\t\tuint64_t v2 = seed + PRIME64_2;\n\t\tuint64_t v3 = seed + 0;\n\t\tuint64_t v4 = seed - PRIME64_1;\n\n\t\tdo {\n\t\t\tv1 = xxh64_round(v1, get_unaligned_le64(p));\n\t\t\tp += 8;\n\t\t\tv2 = xxh64_round(v2, get_unaligned_le64(p));\n\t\t\tp += 8;\n\t\t\tv3 = xxh64_round(v3, get_unaligned_le64(p));\n\t\t\tp += 8;\n\t\t\tv4 = xxh64_round(v4, get_unaligned_le64(p));\n\t\t\tp += 8;\n\t\t} while (p <= limit);\n\n\t\th64 = xxh_rotl64(v1, 1) + xxh_rotl64(v2, 7) +\n\t\t\txxh_rotl64(v3, 12) + xxh_rotl64(v4, 18);\n\t\th64 = xxh64_merge_round(h64, v1);\n\t\th64 = xxh64_merge_round(h64, v2);\n\t\th64 = xxh64_merge_round(h64, v3);\n\t\th64 = xxh64_merge_round(h64, v4);\n\n\t} else {\n\t\th64  = seed + PRIME64_5;\n\t}\n\n\th64 += (uint64_t)len;\n\n\twhile (p + 8 <= b_end) {\n\t\tconst uint64_t k1 = xxh64_round(0, get_unaligned_le64(p));\n\n\t\th64 ^= k1;\n\t\th64 = xxh_rotl64(h64, 27) * PRIME64_1 + PRIME64_4;\n\t\tp += 8;\n\t}\n\n\tif (p + 4 <= b_end) {\n\t\th64 ^= (uint64_t)(get_unaligned_le32(p)) * PRIME64_1;\n\t\th64 = xxh_rotl64(h64, 23) * PRIME64_2 + PRIME64_3;\n\t\tp += 4;\n\t}\n\n\twhile (p < b_end) {\n\t\th64 ^= (*p) * PRIME64_5;\n\t\th64 = xxh_rotl64(h64, 11) * PRIME64_1;\n\t\tp++;\n\t}\n\n\th64 ^= h64 >> 33;\n\th64 *= PRIME64_2;\n\th64 ^= h64 >> 29;\n\th64 *= PRIME64_3;\n\th64 ^= h64 >> 32;\n\n\treturn h64;\n}\nEXPORT_SYMBOL(xxh64);\n\n \nvoid xxh32_reset(struct xxh32_state *statePtr, const uint32_t seed)\n{\n\t \n\tstruct xxh32_state state;\n\n\tmemset(&state, 0, sizeof(state));\n\tstate.v1 = seed + PRIME32_1 + PRIME32_2;\n\tstate.v2 = seed + PRIME32_2;\n\tstate.v3 = seed + 0;\n\tstate.v4 = seed - PRIME32_1;\n\tmemcpy(statePtr, &state, sizeof(state));\n}\nEXPORT_SYMBOL(xxh32_reset);\n\nvoid xxh64_reset(struct xxh64_state *statePtr, const uint64_t seed)\n{\n\t \n\tstruct xxh64_state state;\n\n\tmemset(&state, 0, sizeof(state));\n\tstate.v1 = seed + PRIME64_1 + PRIME64_2;\n\tstate.v2 = seed + PRIME64_2;\n\tstate.v3 = seed + 0;\n\tstate.v4 = seed - PRIME64_1;\n\tmemcpy(statePtr, &state, sizeof(state));\n}\nEXPORT_SYMBOL(xxh64_reset);\n\nint xxh32_update(struct xxh32_state *state, const void *input, const size_t len)\n{\n\tconst uint8_t *p = (const uint8_t *)input;\n\tconst uint8_t *const b_end = p + len;\n\n\tif (input == NULL)\n\t\treturn -EINVAL;\n\n\tstate->total_len_32 += (uint32_t)len;\n\tstate->large_len |= (len >= 16) | (state->total_len_32 >= 16);\n\n\tif (state->memsize + len < 16) {  \n\t\tmemcpy((uint8_t *)(state->mem32) + state->memsize, input, len);\n\t\tstate->memsize += (uint32_t)len;\n\t\treturn 0;\n\t}\n\n\tif (state->memsize) {  \n\t\tconst uint32_t *p32 = state->mem32;\n\n\t\tmemcpy((uint8_t *)(state->mem32) + state->memsize, input,\n\t\t\t16 - state->memsize);\n\n\t\tstate->v1 = xxh32_round(state->v1, get_unaligned_le32(p32));\n\t\tp32++;\n\t\tstate->v2 = xxh32_round(state->v2, get_unaligned_le32(p32));\n\t\tp32++;\n\t\tstate->v3 = xxh32_round(state->v3, get_unaligned_le32(p32));\n\t\tp32++;\n\t\tstate->v4 = xxh32_round(state->v4, get_unaligned_le32(p32));\n\t\tp32++;\n\n\t\tp += 16-state->memsize;\n\t\tstate->memsize = 0;\n\t}\n\n\tif (p <= b_end - 16) {\n\t\tconst uint8_t *const limit = b_end - 16;\n\t\tuint32_t v1 = state->v1;\n\t\tuint32_t v2 = state->v2;\n\t\tuint32_t v3 = state->v3;\n\t\tuint32_t v4 = state->v4;\n\n\t\tdo {\n\t\t\tv1 = xxh32_round(v1, get_unaligned_le32(p));\n\t\t\tp += 4;\n\t\t\tv2 = xxh32_round(v2, get_unaligned_le32(p));\n\t\t\tp += 4;\n\t\t\tv3 = xxh32_round(v3, get_unaligned_le32(p));\n\t\t\tp += 4;\n\t\t\tv4 = xxh32_round(v4, get_unaligned_le32(p));\n\t\t\tp += 4;\n\t\t} while (p <= limit);\n\n\t\tstate->v1 = v1;\n\t\tstate->v2 = v2;\n\t\tstate->v3 = v3;\n\t\tstate->v4 = v4;\n\t}\n\n\tif (p < b_end) {\n\t\tmemcpy(state->mem32, p, (size_t)(b_end-p));\n\t\tstate->memsize = (uint32_t)(b_end-p);\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(xxh32_update);\n\nuint32_t xxh32_digest(const struct xxh32_state *state)\n{\n\tconst uint8_t *p = (const uint8_t *)state->mem32;\n\tconst uint8_t *const b_end = (const uint8_t *)(state->mem32) +\n\t\tstate->memsize;\n\tuint32_t h32;\n\n\tif (state->large_len) {\n\t\th32 = xxh_rotl32(state->v1, 1) + xxh_rotl32(state->v2, 7) +\n\t\t\txxh_rotl32(state->v3, 12) + xxh_rotl32(state->v4, 18);\n\t} else {\n\t\th32 = state->v3   + PRIME32_5;\n\t}\n\n\th32 += state->total_len_32;\n\n\twhile (p + 4 <= b_end) {\n\t\th32 += get_unaligned_le32(p) * PRIME32_3;\n\t\th32 = xxh_rotl32(h32, 17) * PRIME32_4;\n\t\tp += 4;\n\t}\n\n\twhile (p < b_end) {\n\t\th32 += (*p) * PRIME32_5;\n\t\th32 = xxh_rotl32(h32, 11) * PRIME32_1;\n\t\tp++;\n\t}\n\n\th32 ^= h32 >> 15;\n\th32 *= PRIME32_2;\n\th32 ^= h32 >> 13;\n\th32 *= PRIME32_3;\n\th32 ^= h32 >> 16;\n\n\treturn h32;\n}\nEXPORT_SYMBOL(xxh32_digest);\n\nint xxh64_update(struct xxh64_state *state, const void *input, const size_t len)\n{\n\tconst uint8_t *p = (const uint8_t *)input;\n\tconst uint8_t *const b_end = p + len;\n\n\tif (input == NULL)\n\t\treturn -EINVAL;\n\n\tstate->total_len += len;\n\n\tif (state->memsize + len < 32) {  \n\t\tmemcpy(((uint8_t *)state->mem64) + state->memsize, input, len);\n\t\tstate->memsize += (uint32_t)len;\n\t\treturn 0;\n\t}\n\n\tif (state->memsize) {  \n\t\tuint64_t *p64 = state->mem64;\n\n\t\tmemcpy(((uint8_t *)p64) + state->memsize, input,\n\t\t\t32 - state->memsize);\n\n\t\tstate->v1 = xxh64_round(state->v1, get_unaligned_le64(p64));\n\t\tp64++;\n\t\tstate->v2 = xxh64_round(state->v2, get_unaligned_le64(p64));\n\t\tp64++;\n\t\tstate->v3 = xxh64_round(state->v3, get_unaligned_le64(p64));\n\t\tp64++;\n\t\tstate->v4 = xxh64_round(state->v4, get_unaligned_le64(p64));\n\n\t\tp += 32 - state->memsize;\n\t\tstate->memsize = 0;\n\t}\n\n\tif (p + 32 <= b_end) {\n\t\tconst uint8_t *const limit = b_end - 32;\n\t\tuint64_t v1 = state->v1;\n\t\tuint64_t v2 = state->v2;\n\t\tuint64_t v3 = state->v3;\n\t\tuint64_t v4 = state->v4;\n\n\t\tdo {\n\t\t\tv1 = xxh64_round(v1, get_unaligned_le64(p));\n\t\t\tp += 8;\n\t\t\tv2 = xxh64_round(v2, get_unaligned_le64(p));\n\t\t\tp += 8;\n\t\t\tv3 = xxh64_round(v3, get_unaligned_le64(p));\n\t\t\tp += 8;\n\t\t\tv4 = xxh64_round(v4, get_unaligned_le64(p));\n\t\t\tp += 8;\n\t\t} while (p <= limit);\n\n\t\tstate->v1 = v1;\n\t\tstate->v2 = v2;\n\t\tstate->v3 = v3;\n\t\tstate->v4 = v4;\n\t}\n\n\tif (p < b_end) {\n\t\tmemcpy(state->mem64, p, (size_t)(b_end-p));\n\t\tstate->memsize = (uint32_t)(b_end - p);\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(xxh64_update);\n\nuint64_t xxh64_digest(const struct xxh64_state *state)\n{\n\tconst uint8_t *p = (const uint8_t *)state->mem64;\n\tconst uint8_t *const b_end = (const uint8_t *)state->mem64 +\n\t\tstate->memsize;\n\tuint64_t h64;\n\n\tif (state->total_len >= 32) {\n\t\tconst uint64_t v1 = state->v1;\n\t\tconst uint64_t v2 = state->v2;\n\t\tconst uint64_t v3 = state->v3;\n\t\tconst uint64_t v4 = state->v4;\n\n\t\th64 = xxh_rotl64(v1, 1) + xxh_rotl64(v2, 7) +\n\t\t\txxh_rotl64(v3, 12) + xxh_rotl64(v4, 18);\n\t\th64 = xxh64_merge_round(h64, v1);\n\t\th64 = xxh64_merge_round(h64, v2);\n\t\th64 = xxh64_merge_round(h64, v3);\n\t\th64 = xxh64_merge_round(h64, v4);\n\t} else {\n\t\th64  = state->v3 + PRIME64_5;\n\t}\n\n\th64 += (uint64_t)state->total_len;\n\n\twhile (p + 8 <= b_end) {\n\t\tconst uint64_t k1 = xxh64_round(0, get_unaligned_le64(p));\n\n\t\th64 ^= k1;\n\t\th64 = xxh_rotl64(h64, 27) * PRIME64_1 + PRIME64_4;\n\t\tp += 8;\n\t}\n\n\tif (p + 4 <= b_end) {\n\t\th64 ^= (uint64_t)(get_unaligned_le32(p)) * PRIME64_1;\n\t\th64 = xxh_rotl64(h64, 23) * PRIME64_2 + PRIME64_3;\n\t\tp += 4;\n\t}\n\n\twhile (p < b_end) {\n\t\th64 ^= (*p) * PRIME64_5;\n\t\th64 = xxh_rotl64(h64, 11) * PRIME64_1;\n\t\tp++;\n\t}\n\n\th64 ^= h64 >> 33;\n\th64 *= PRIME64_2;\n\th64 ^= h64 >> 29;\n\th64 *= PRIME64_3;\n\th64 ^= h64 >> 32;\n\n\treturn h64;\n}\nEXPORT_SYMBOL(xxh64_digest);\n\nMODULE_LICENSE(\"Dual BSD/GPL\");\nMODULE_DESCRIPTION(\"xxHash\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}