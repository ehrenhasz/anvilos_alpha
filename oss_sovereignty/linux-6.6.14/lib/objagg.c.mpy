{
  "module_name": "objagg.c",
  "hash_id": "cf92b0563e5fb2dce8d73924aad5d1f230c75e8612254da50bcaae22571a821e",
  "original_prompt": "Ingested from linux-6.6.14/lib/objagg.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/rhashtable.h>\n#include <linux/idr.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/objagg.h>\n\n#define CREATE_TRACE_POINTS\n#include <trace/events/objagg.h>\n\nstruct objagg_hints {\n\tstruct rhashtable node_ht;\n\tstruct rhashtable_params ht_params;\n\tstruct list_head node_list;\n\tunsigned int node_count;\n\tunsigned int root_count;\n\tunsigned int refcount;\n\tconst struct objagg_ops *ops;\n};\n\nstruct objagg_hints_node {\n\tstruct rhash_head ht_node;  \n\tstruct list_head list;  \n\tstruct objagg_hints_node *parent;\n\tunsigned int root_id;\n\tstruct objagg_obj_stats_info stats_info;\n\tunsigned long obj[];\n};\n\nstatic struct objagg_hints_node *\nobjagg_hints_lookup(struct objagg_hints *objagg_hints, void *obj)\n{\n\tif (!objagg_hints)\n\t\treturn NULL;\n\treturn rhashtable_lookup_fast(&objagg_hints->node_ht, obj,\n\t\t\t\t      objagg_hints->ht_params);\n}\n\nstruct objagg {\n\tconst struct objagg_ops *ops;\n\tvoid *priv;\n\tstruct rhashtable obj_ht;\n\tstruct rhashtable_params ht_params;\n\tstruct list_head obj_list;\n\tunsigned int obj_count;\n\tstruct ida root_ida;\n\tstruct objagg_hints *hints;\n};\n\nstruct objagg_obj {\n\tstruct rhash_head ht_node;  \n\tstruct list_head list;  \n\tstruct objagg_obj *parent;  \n\tunion {\n\t\tvoid *delta_priv;  \n\t\tvoid *root_priv;  \n\t};\n\tunsigned int root_id;\n\tunsigned int refcount;  \n\tstruct objagg_obj_stats stats;\n\tunsigned long obj[];\n};\n\nstatic unsigned int objagg_obj_ref_inc(struct objagg_obj *objagg_obj)\n{\n\treturn ++objagg_obj->refcount;\n}\n\nstatic unsigned int objagg_obj_ref_dec(struct objagg_obj *objagg_obj)\n{\n\treturn --objagg_obj->refcount;\n}\n\nstatic void objagg_obj_stats_inc(struct objagg_obj *objagg_obj)\n{\n\tobjagg_obj->stats.user_count++;\n\tobjagg_obj->stats.delta_user_count++;\n\tif (objagg_obj->parent)\n\t\tobjagg_obj->parent->stats.delta_user_count++;\n}\n\nstatic void objagg_obj_stats_dec(struct objagg_obj *objagg_obj)\n{\n\tobjagg_obj->stats.user_count--;\n\tobjagg_obj->stats.delta_user_count--;\n\tif (objagg_obj->parent)\n\t\tobjagg_obj->parent->stats.delta_user_count--;\n}\n\nstatic bool objagg_obj_is_root(const struct objagg_obj *objagg_obj)\n{\n\t \n\treturn !objagg_obj->parent;\n}\n\n \nconst void *objagg_obj_root_priv(const struct objagg_obj *objagg_obj)\n{\n\tif (objagg_obj_is_root(objagg_obj))\n\t\treturn objagg_obj->root_priv;\n\tWARN_ON(!objagg_obj_is_root(objagg_obj->parent));\n\treturn objagg_obj->parent->root_priv;\n}\nEXPORT_SYMBOL(objagg_obj_root_priv);\n\n \nconst void *objagg_obj_delta_priv(const struct objagg_obj *objagg_obj)\n{\n\tif (objagg_obj_is_root(objagg_obj))\n\t\treturn NULL;\n\treturn objagg_obj->delta_priv;\n}\nEXPORT_SYMBOL(objagg_obj_delta_priv);\n\n \nconst void *objagg_obj_raw(const struct objagg_obj *objagg_obj)\n{\n\treturn objagg_obj->obj;\n}\nEXPORT_SYMBOL(objagg_obj_raw);\n\nstatic struct objagg_obj *objagg_obj_lookup(struct objagg *objagg, void *obj)\n{\n\treturn rhashtable_lookup_fast(&objagg->obj_ht, obj, objagg->ht_params);\n}\n\nstatic int objagg_obj_parent_assign(struct objagg *objagg,\n\t\t\t\t    struct objagg_obj *objagg_obj,\n\t\t\t\t    struct objagg_obj *parent,\n\t\t\t\t    bool take_parent_ref)\n{\n\tvoid *delta_priv;\n\n\tdelta_priv = objagg->ops->delta_create(objagg->priv, parent->obj,\n\t\t\t\t\t       objagg_obj->obj);\n\tif (IS_ERR(delta_priv))\n\t\treturn PTR_ERR(delta_priv);\n\n\t \n\tobjagg_obj->parent = parent;\n\tobjagg_obj->delta_priv = delta_priv;\n\tif (take_parent_ref)\n\t\tobjagg_obj_ref_inc(objagg_obj->parent);\n\ttrace_objagg_obj_parent_assign(objagg, objagg_obj,\n\t\t\t\t       parent,\n\t\t\t\t       parent->refcount);\n\treturn 0;\n}\n\nstatic int objagg_obj_parent_lookup_assign(struct objagg *objagg,\n\t\t\t\t\t   struct objagg_obj *objagg_obj)\n{\n\tstruct objagg_obj *objagg_obj_cur;\n\tint err;\n\n\tlist_for_each_entry(objagg_obj_cur, &objagg->obj_list, list) {\n\t\t \n\t\tif (!objagg_obj_is_root(objagg_obj_cur))\n\t\t\tcontinue;\n\t\terr = objagg_obj_parent_assign(objagg, objagg_obj,\n\t\t\t\t\t       objagg_obj_cur, true);\n\t\tif (!err)\n\t\t\treturn 0;\n\t}\n\treturn -ENOENT;\n}\n\nstatic void __objagg_obj_put(struct objagg *objagg,\n\t\t\t     struct objagg_obj *objagg_obj);\n\nstatic void objagg_obj_parent_unassign(struct objagg *objagg,\n\t\t\t\t       struct objagg_obj *objagg_obj)\n{\n\ttrace_objagg_obj_parent_unassign(objagg, objagg_obj,\n\t\t\t\t\t objagg_obj->parent,\n\t\t\t\t\t objagg_obj->parent->refcount);\n\tobjagg->ops->delta_destroy(objagg->priv, objagg_obj->delta_priv);\n\t__objagg_obj_put(objagg, objagg_obj->parent);\n}\n\nstatic int objagg_obj_root_id_alloc(struct objagg *objagg,\n\t\t\t\t    struct objagg_obj *objagg_obj,\n\t\t\t\t    struct objagg_hints_node *hnode)\n{\n\tunsigned int min, max;\n\tint root_id;\n\n\t \n\tif (!objagg->hints) {\n\t\tobjagg_obj->root_id = OBJAGG_OBJ_ROOT_ID_INVALID;\n\t\treturn 0;\n\t}\n\n\tif (hnode) {\n\t\tmin = hnode->root_id;\n\t\tmax = hnode->root_id;\n\t} else {\n\t\t \n\t\tmin = objagg->hints->root_count;\n\t\tmax = ~0;\n\t}\n\n\troot_id = ida_alloc_range(&objagg->root_ida, min, max, GFP_KERNEL);\n\n\tif (root_id < 0)\n\t\treturn root_id;\n\tobjagg_obj->root_id = root_id;\n\treturn 0;\n}\n\nstatic void objagg_obj_root_id_free(struct objagg *objagg,\n\t\t\t\t    struct objagg_obj *objagg_obj)\n{\n\tif (!objagg->hints)\n\t\treturn;\n\tida_free(&objagg->root_ida, objagg_obj->root_id);\n}\n\nstatic int objagg_obj_root_create(struct objagg *objagg,\n\t\t\t\t  struct objagg_obj *objagg_obj,\n\t\t\t\t  struct objagg_hints_node *hnode)\n{\n\tint err;\n\n\terr = objagg_obj_root_id_alloc(objagg, objagg_obj, hnode);\n\tif (err)\n\t\treturn err;\n\tobjagg_obj->root_priv = objagg->ops->root_create(objagg->priv,\n\t\t\t\t\t\t\t objagg_obj->obj,\n\t\t\t\t\t\t\t objagg_obj->root_id);\n\tif (IS_ERR(objagg_obj->root_priv)) {\n\t\terr = PTR_ERR(objagg_obj->root_priv);\n\t\tgoto err_root_create;\n\t}\n\ttrace_objagg_obj_root_create(objagg, objagg_obj);\n\treturn 0;\n\nerr_root_create:\n\tobjagg_obj_root_id_free(objagg, objagg_obj);\n\treturn err;\n}\n\nstatic void objagg_obj_root_destroy(struct objagg *objagg,\n\t\t\t\t    struct objagg_obj *objagg_obj)\n{\n\ttrace_objagg_obj_root_destroy(objagg, objagg_obj);\n\tobjagg->ops->root_destroy(objagg->priv, objagg_obj->root_priv);\n\tobjagg_obj_root_id_free(objagg, objagg_obj);\n}\n\nstatic struct objagg_obj *__objagg_obj_get(struct objagg *objagg, void *obj);\n\nstatic int objagg_obj_init_with_hints(struct objagg *objagg,\n\t\t\t\t      struct objagg_obj *objagg_obj,\n\t\t\t\t      bool *hint_found)\n{\n\tstruct objagg_hints_node *hnode;\n\tstruct objagg_obj *parent;\n\tint err;\n\n\thnode = objagg_hints_lookup(objagg->hints, objagg_obj->obj);\n\tif (!hnode) {\n\t\t*hint_found = false;\n\t\treturn 0;\n\t}\n\t*hint_found = true;\n\n\tif (!hnode->parent)\n\t\treturn objagg_obj_root_create(objagg, objagg_obj, hnode);\n\n\tparent = __objagg_obj_get(objagg, hnode->parent->obj);\n\tif (IS_ERR(parent))\n\t\treturn PTR_ERR(parent);\n\n\terr = objagg_obj_parent_assign(objagg, objagg_obj, parent, false);\n\tif (err) {\n\t\t*hint_found = false;\n\t\terr = 0;\n\t\tgoto err_parent_assign;\n\t}\n\n\treturn 0;\n\nerr_parent_assign:\n\tobjagg_obj_put(objagg, parent);\n\treturn err;\n}\n\nstatic int objagg_obj_init(struct objagg *objagg,\n\t\t\t   struct objagg_obj *objagg_obj)\n{\n\tbool hint_found;\n\tint err;\n\n\t \n\terr = objagg_obj_init_with_hints(objagg, objagg_obj, &hint_found);\n\tif (err)\n\t\treturn err;\n\n\tif (hint_found)\n\t\treturn 0;\n\n\t \n\terr = objagg_obj_parent_lookup_assign(objagg, objagg_obj);\n\tif (!err)\n\t\treturn 0;\n\t \n\treturn objagg_obj_root_create(objagg, objagg_obj, NULL);\n}\n\nstatic void objagg_obj_fini(struct objagg *objagg,\n\t\t\t    struct objagg_obj *objagg_obj)\n{\n\tif (!objagg_obj_is_root(objagg_obj))\n\t\tobjagg_obj_parent_unassign(objagg, objagg_obj);\n\telse\n\t\tobjagg_obj_root_destroy(objagg, objagg_obj);\n}\n\nstatic struct objagg_obj *objagg_obj_create(struct objagg *objagg, void *obj)\n{\n\tstruct objagg_obj *objagg_obj;\n\tint err;\n\n\tobjagg_obj = kzalloc(sizeof(*objagg_obj) + objagg->ops->obj_size,\n\t\t\t     GFP_KERNEL);\n\tif (!objagg_obj)\n\t\treturn ERR_PTR(-ENOMEM);\n\tobjagg_obj_ref_inc(objagg_obj);\n\tmemcpy(objagg_obj->obj, obj, objagg->ops->obj_size);\n\n\terr = objagg_obj_init(objagg, objagg_obj);\n\tif (err)\n\t\tgoto err_obj_init;\n\n\terr = rhashtable_insert_fast(&objagg->obj_ht, &objagg_obj->ht_node,\n\t\t\t\t     objagg->ht_params);\n\tif (err)\n\t\tgoto err_ht_insert;\n\tlist_add(&objagg_obj->list, &objagg->obj_list);\n\tobjagg->obj_count++;\n\ttrace_objagg_obj_create(objagg, objagg_obj);\n\n\treturn objagg_obj;\n\nerr_ht_insert:\n\tobjagg_obj_fini(objagg, objagg_obj);\nerr_obj_init:\n\tkfree(objagg_obj);\n\treturn ERR_PTR(err);\n}\n\nstatic struct objagg_obj *__objagg_obj_get(struct objagg *objagg, void *obj)\n{\n\tstruct objagg_obj *objagg_obj;\n\n\t \n\tobjagg_obj = objagg_obj_lookup(objagg, obj);\n\tif (objagg_obj) {\n\t\tobjagg_obj_ref_inc(objagg_obj);\n\t\treturn objagg_obj;\n\t}\n\n\treturn objagg_obj_create(objagg, obj);\n}\n\n \nstruct objagg_obj *objagg_obj_get(struct objagg *objagg, void *obj)\n{\n\tstruct objagg_obj *objagg_obj;\n\n\tobjagg_obj = __objagg_obj_get(objagg, obj);\n\tif (IS_ERR(objagg_obj))\n\t\treturn objagg_obj;\n\tobjagg_obj_stats_inc(objagg_obj);\n\ttrace_objagg_obj_get(objagg, objagg_obj, objagg_obj->refcount);\n\treturn objagg_obj;\n}\nEXPORT_SYMBOL(objagg_obj_get);\n\nstatic void objagg_obj_destroy(struct objagg *objagg,\n\t\t\t       struct objagg_obj *objagg_obj)\n{\n\ttrace_objagg_obj_destroy(objagg, objagg_obj);\n\t--objagg->obj_count;\n\tlist_del(&objagg_obj->list);\n\trhashtable_remove_fast(&objagg->obj_ht, &objagg_obj->ht_node,\n\t\t\t       objagg->ht_params);\n\tobjagg_obj_fini(objagg, objagg_obj);\n\tkfree(objagg_obj);\n}\n\nstatic void __objagg_obj_put(struct objagg *objagg,\n\t\t\t     struct objagg_obj *objagg_obj)\n{\n\tif (!objagg_obj_ref_dec(objagg_obj))\n\t\tobjagg_obj_destroy(objagg, objagg_obj);\n}\n\n \nvoid objagg_obj_put(struct objagg *objagg, struct objagg_obj *objagg_obj)\n{\n\ttrace_objagg_obj_put(objagg, objagg_obj, objagg_obj->refcount);\n\tobjagg_obj_stats_dec(objagg_obj);\n\t__objagg_obj_put(objagg, objagg_obj);\n}\nEXPORT_SYMBOL(objagg_obj_put);\n\n \nstruct objagg *objagg_create(const struct objagg_ops *ops,\n\t\t\t     struct objagg_hints *objagg_hints, void *priv)\n{\n\tstruct objagg *objagg;\n\tint err;\n\n\tif (WARN_ON(!ops || !ops->root_create || !ops->root_destroy ||\n\t\t    !ops->delta_check || !ops->delta_create ||\n\t\t    !ops->delta_destroy))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tobjagg = kzalloc(sizeof(*objagg), GFP_KERNEL);\n\tif (!objagg)\n\t\treturn ERR_PTR(-ENOMEM);\n\tobjagg->ops = ops;\n\tif (objagg_hints) {\n\t\tobjagg->hints = objagg_hints;\n\t\tobjagg_hints->refcount++;\n\t}\n\tobjagg->priv = priv;\n\tINIT_LIST_HEAD(&objagg->obj_list);\n\n\tobjagg->ht_params.key_len = ops->obj_size;\n\tobjagg->ht_params.key_offset = offsetof(struct objagg_obj, obj);\n\tobjagg->ht_params.head_offset = offsetof(struct objagg_obj, ht_node);\n\n\terr = rhashtable_init(&objagg->obj_ht, &objagg->ht_params);\n\tif (err)\n\t\tgoto err_rhashtable_init;\n\n\tida_init(&objagg->root_ida);\n\n\ttrace_objagg_create(objagg);\n\treturn objagg;\n\nerr_rhashtable_init:\n\tkfree(objagg);\n\treturn ERR_PTR(err);\n}\nEXPORT_SYMBOL(objagg_create);\n\n \nvoid objagg_destroy(struct objagg *objagg)\n{\n\ttrace_objagg_destroy(objagg);\n\tida_destroy(&objagg->root_ida);\n\tWARN_ON(!list_empty(&objagg->obj_list));\n\trhashtable_destroy(&objagg->obj_ht);\n\tif (objagg->hints)\n\t\tobjagg_hints_put(objagg->hints);\n\tkfree(objagg);\n}\nEXPORT_SYMBOL(objagg_destroy);\n\nstatic int objagg_stats_info_sort_cmp_func(const void *a, const void *b)\n{\n\tconst struct objagg_obj_stats_info *stats_info1 = a;\n\tconst struct objagg_obj_stats_info *stats_info2 = b;\n\n\tif (stats_info1->is_root != stats_info2->is_root)\n\t\treturn stats_info2->is_root - stats_info1->is_root;\n\tif (stats_info1->stats.delta_user_count !=\n\t    stats_info2->stats.delta_user_count)\n\t\treturn stats_info2->stats.delta_user_count -\n\t\t       stats_info1->stats.delta_user_count;\n\treturn stats_info2->stats.user_count - stats_info1->stats.user_count;\n}\n\n \nconst struct objagg_stats *objagg_stats_get(struct objagg *objagg)\n{\n\tstruct objagg_stats *objagg_stats;\n\tstruct objagg_obj *objagg_obj;\n\tint i;\n\n\tobjagg_stats = kzalloc(struct_size(objagg_stats, stats_info,\n\t\t\t\t\t   objagg->obj_count), GFP_KERNEL);\n\tif (!objagg_stats)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\ti = 0;\n\tlist_for_each_entry(objagg_obj, &objagg->obj_list, list) {\n\t\tmemcpy(&objagg_stats->stats_info[i].stats, &objagg_obj->stats,\n\t\t       sizeof(objagg_stats->stats_info[0].stats));\n\t\tobjagg_stats->stats_info[i].objagg_obj = objagg_obj;\n\t\tobjagg_stats->stats_info[i].is_root =\n\t\t\t\t\tobjagg_obj_is_root(objagg_obj);\n\t\tif (objagg_stats->stats_info[i].is_root)\n\t\t\tobjagg_stats->root_count++;\n\t\ti++;\n\t}\n\tobjagg_stats->stats_info_count = i;\n\n\tsort(objagg_stats->stats_info, objagg_stats->stats_info_count,\n\t     sizeof(struct objagg_obj_stats_info),\n\t     objagg_stats_info_sort_cmp_func, NULL);\n\n\treturn objagg_stats;\n}\nEXPORT_SYMBOL(objagg_stats_get);\n\n \nvoid objagg_stats_put(const struct objagg_stats *objagg_stats)\n{\n\tkfree(objagg_stats);\n}\nEXPORT_SYMBOL(objagg_stats_put);\n\nstatic struct objagg_hints_node *\nobjagg_hints_node_create(struct objagg_hints *objagg_hints,\n\t\t\t struct objagg_obj *objagg_obj, size_t obj_size,\n\t\t\t struct objagg_hints_node *parent_hnode)\n{\n\tunsigned int user_count = objagg_obj->stats.user_count;\n\tstruct objagg_hints_node *hnode;\n\tint err;\n\n\thnode = kzalloc(sizeof(*hnode) + obj_size, GFP_KERNEL);\n\tif (!hnode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tmemcpy(hnode->obj, &objagg_obj->obj, obj_size);\n\thnode->stats_info.stats.user_count = user_count;\n\thnode->stats_info.stats.delta_user_count = user_count;\n\tif (parent_hnode) {\n\t\tparent_hnode->stats_info.stats.delta_user_count += user_count;\n\t} else {\n\t\thnode->root_id = objagg_hints->root_count++;\n\t\thnode->stats_info.is_root = true;\n\t}\n\thnode->stats_info.objagg_obj = objagg_obj;\n\n\terr = rhashtable_insert_fast(&objagg_hints->node_ht, &hnode->ht_node,\n\t\t\t\t     objagg_hints->ht_params);\n\tif (err)\n\t\tgoto err_ht_insert;\n\n\tlist_add(&hnode->list, &objagg_hints->node_list);\n\thnode->parent = parent_hnode;\n\tobjagg_hints->node_count++;\n\n\treturn hnode;\n\nerr_ht_insert:\n\tkfree(hnode);\n\treturn ERR_PTR(err);\n}\n\nstatic void objagg_hints_flush(struct objagg_hints *objagg_hints)\n{\n\tstruct objagg_hints_node *hnode, *tmp;\n\n\tlist_for_each_entry_safe(hnode, tmp, &objagg_hints->node_list, list) {\n\t\tlist_del(&hnode->list);\n\t\trhashtable_remove_fast(&objagg_hints->node_ht, &hnode->ht_node,\n\t\t\t\t       objagg_hints->ht_params);\n\t\tkfree(hnode);\n\t}\n}\n\nstruct objagg_tmp_node {\n\tstruct objagg_obj *objagg_obj;\n\tbool crossed_out;\n};\n\nstruct objagg_tmp_graph {\n\tstruct objagg_tmp_node *nodes;\n\tunsigned long nodes_count;\n\tunsigned long *edges;\n};\n\nstatic int objagg_tmp_graph_edge_index(struct objagg_tmp_graph *graph,\n\t\t\t\t       int parent_index, int index)\n{\n\treturn index * graph->nodes_count + parent_index;\n}\n\nstatic void objagg_tmp_graph_edge_set(struct objagg_tmp_graph *graph,\n\t\t\t\t      int parent_index, int index)\n{\n\tint edge_index = objagg_tmp_graph_edge_index(graph, index,\n\t\t\t\t\t\t     parent_index);\n\n\t__set_bit(edge_index, graph->edges);\n}\n\nstatic bool objagg_tmp_graph_is_edge(struct objagg_tmp_graph *graph,\n\t\t\t\t     int parent_index, int index)\n{\n\tint edge_index = objagg_tmp_graph_edge_index(graph, index,\n\t\t\t\t\t\t     parent_index);\n\n\treturn test_bit(edge_index, graph->edges);\n}\n\nstatic unsigned int objagg_tmp_graph_node_weight(struct objagg_tmp_graph *graph,\n\t\t\t\t\t\t unsigned int index)\n{\n\tstruct objagg_tmp_node *node = &graph->nodes[index];\n\tunsigned int weight = node->objagg_obj->stats.user_count;\n\tint j;\n\n\t \n\n\tfor (j = 0; j < graph->nodes_count; j++) {\n\t\tif (!objagg_tmp_graph_is_edge(graph, index, j))\n\t\t\tcontinue;\n\t\tnode = &graph->nodes[j];\n\t\tif (node->crossed_out)\n\t\t\tcontinue;\n\t\tweight += node->objagg_obj->stats.user_count;\n\t}\n\treturn weight;\n}\n\nstatic int objagg_tmp_graph_node_max_weight(struct objagg_tmp_graph *graph)\n{\n\tstruct objagg_tmp_node *node;\n\tunsigned int max_weight = 0;\n\tunsigned int weight;\n\tint max_index = -1;\n\tint i;\n\n\tfor (i = 0; i < graph->nodes_count; i++) {\n\t\tnode = &graph->nodes[i];\n\t\tif (node->crossed_out)\n\t\t\tcontinue;\n\t\tweight = objagg_tmp_graph_node_weight(graph, i);\n\t\tif (weight >= max_weight) {\n\t\t\tmax_weight = weight;\n\t\t\tmax_index = i;\n\t\t}\n\t}\n\treturn max_index;\n}\n\nstatic struct objagg_tmp_graph *objagg_tmp_graph_create(struct objagg *objagg)\n{\n\tunsigned int nodes_count = objagg->obj_count;\n\tstruct objagg_tmp_graph *graph;\n\tstruct objagg_tmp_node *node;\n\tstruct objagg_tmp_node *pnode;\n\tstruct objagg_obj *objagg_obj;\n\tint i, j;\n\n\tgraph = kzalloc(sizeof(*graph), GFP_KERNEL);\n\tif (!graph)\n\t\treturn NULL;\n\n\tgraph->nodes = kcalloc(nodes_count, sizeof(*graph->nodes), GFP_KERNEL);\n\tif (!graph->nodes)\n\t\tgoto err_nodes_alloc;\n\tgraph->nodes_count = nodes_count;\n\n\tgraph->edges = bitmap_zalloc(nodes_count * nodes_count, GFP_KERNEL);\n\tif (!graph->edges)\n\t\tgoto err_edges_alloc;\n\n\ti = 0;\n\tlist_for_each_entry(objagg_obj, &objagg->obj_list, list) {\n\t\tnode = &graph->nodes[i++];\n\t\tnode->objagg_obj = objagg_obj;\n\t}\n\n\t \n\tfor (i = 0; i < nodes_count; i++) {\n\t\tfor (j = 0; j < nodes_count; j++) {\n\t\t\tif (i == j)\n\t\t\t\tcontinue;\n\t\t\tpnode = &graph->nodes[i];\n\t\t\tnode = &graph->nodes[j];\n\t\t\tif (objagg->ops->delta_check(objagg->priv,\n\t\t\t\t\t\t     pnode->objagg_obj->obj,\n\t\t\t\t\t\t     node->objagg_obj->obj)) {\n\t\t\t\tobjagg_tmp_graph_edge_set(graph, i, j);\n\n\t\t\t}\n\t\t}\n\t}\n\treturn graph;\n\nerr_edges_alloc:\n\tkfree(graph->nodes);\nerr_nodes_alloc:\n\tkfree(graph);\n\treturn NULL;\n}\n\nstatic void objagg_tmp_graph_destroy(struct objagg_tmp_graph *graph)\n{\n\tbitmap_free(graph->edges);\n\tkfree(graph->nodes);\n\tkfree(graph);\n}\n\nstatic int\nobjagg_opt_simple_greedy_fillup_hints(struct objagg_hints *objagg_hints,\n\t\t\t\t      struct objagg *objagg)\n{\n\tstruct objagg_hints_node *hnode, *parent_hnode;\n\tstruct objagg_tmp_graph *graph;\n\tstruct objagg_tmp_node *node;\n\tint index;\n\tint j;\n\tint err;\n\n\tgraph = objagg_tmp_graph_create(objagg);\n\tif (!graph)\n\t\treturn -ENOMEM;\n\n\t \n\twhile ((index = objagg_tmp_graph_node_max_weight(graph)) != -1) {\n\t\tnode = &graph->nodes[index];\n\t\tnode->crossed_out = true;\n\t\thnode = objagg_hints_node_create(objagg_hints,\n\t\t\t\t\t\t node->objagg_obj,\n\t\t\t\t\t\t objagg->ops->obj_size,\n\t\t\t\t\t\t NULL);\n\t\tif (IS_ERR(hnode)) {\n\t\t\terr = PTR_ERR(hnode);\n\t\t\tgoto out;\n\t\t}\n\t\tparent_hnode = hnode;\n\t\tfor (j = 0; j < graph->nodes_count; j++) {\n\t\t\tif (!objagg_tmp_graph_is_edge(graph, index, j))\n\t\t\t\tcontinue;\n\t\t\tnode = &graph->nodes[j];\n\t\t\tif (node->crossed_out)\n\t\t\t\tcontinue;\n\t\t\tnode->crossed_out = true;\n\t\t\thnode = objagg_hints_node_create(objagg_hints,\n\t\t\t\t\t\t\t node->objagg_obj,\n\t\t\t\t\t\t\t objagg->ops->obj_size,\n\t\t\t\t\t\t\t parent_hnode);\n\t\t\tif (IS_ERR(hnode)) {\n\t\t\t\terr = PTR_ERR(hnode);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\n\terr = 0;\nout:\n\tobjagg_tmp_graph_destroy(graph);\n\treturn err;\n}\n\nstruct objagg_opt_algo {\n\tint (*fillup_hints)(struct objagg_hints *objagg_hints,\n\t\t\t    struct objagg *objagg);\n};\n\nstatic const struct objagg_opt_algo objagg_opt_simple_greedy = {\n\t.fillup_hints = objagg_opt_simple_greedy_fillup_hints,\n};\n\n\nstatic const struct objagg_opt_algo *objagg_opt_algos[] = {\n\t[OBJAGG_OPT_ALGO_SIMPLE_GREEDY] = &objagg_opt_simple_greedy,\n};\n\nstatic int objagg_hints_obj_cmp(struct rhashtable_compare_arg *arg,\n\t\t\t\tconst void *obj)\n{\n\tstruct rhashtable *ht = arg->ht;\n\tstruct objagg_hints *objagg_hints =\n\t\t\tcontainer_of(ht, struct objagg_hints, node_ht);\n\tconst struct objagg_ops *ops = objagg_hints->ops;\n\tconst char *ptr = obj;\n\n\tptr += ht->p.key_offset;\n\treturn ops->hints_obj_cmp ? ops->hints_obj_cmp(ptr, arg->key) :\n\t\t\t\t    memcmp(ptr, arg->key, ht->p.key_len);\n}\n\n \nstruct objagg_hints *objagg_hints_get(struct objagg *objagg,\n\t\t\t\t      enum objagg_opt_algo_type opt_algo_type)\n{\n\tconst struct objagg_opt_algo *algo = objagg_opt_algos[opt_algo_type];\n\tstruct objagg_hints *objagg_hints;\n\tint err;\n\n\tobjagg_hints = kzalloc(sizeof(*objagg_hints), GFP_KERNEL);\n\tif (!objagg_hints)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tobjagg_hints->ops = objagg->ops;\n\tobjagg_hints->refcount = 1;\n\n\tINIT_LIST_HEAD(&objagg_hints->node_list);\n\n\tobjagg_hints->ht_params.key_len = objagg->ops->obj_size;\n\tobjagg_hints->ht_params.key_offset =\n\t\t\t\toffsetof(struct objagg_hints_node, obj);\n\tobjagg_hints->ht_params.head_offset =\n\t\t\t\toffsetof(struct objagg_hints_node, ht_node);\n\tobjagg_hints->ht_params.obj_cmpfn = objagg_hints_obj_cmp;\n\n\terr = rhashtable_init(&objagg_hints->node_ht, &objagg_hints->ht_params);\n\tif (err)\n\t\tgoto err_rhashtable_init;\n\n\terr = algo->fillup_hints(objagg_hints, objagg);\n\tif (err)\n\t\tgoto err_fillup_hints;\n\n\tif (WARN_ON(objagg_hints->node_count != objagg->obj_count)) {\n\t\terr = -EINVAL;\n\t\tgoto err_node_count_check;\n\t}\n\n\treturn objagg_hints;\n\nerr_node_count_check:\nerr_fillup_hints:\n\tobjagg_hints_flush(objagg_hints);\n\trhashtable_destroy(&objagg_hints->node_ht);\nerr_rhashtable_init:\n\tkfree(objagg_hints);\n\treturn ERR_PTR(err);\n}\nEXPORT_SYMBOL(objagg_hints_get);\n\n \nvoid objagg_hints_put(struct objagg_hints *objagg_hints)\n{\n\tif (--objagg_hints->refcount)\n\t\treturn;\n\tobjagg_hints_flush(objagg_hints);\n\trhashtable_destroy(&objagg_hints->node_ht);\n\tkfree(objagg_hints);\n}\nEXPORT_SYMBOL(objagg_hints_put);\n\n \nconst struct objagg_stats *\nobjagg_hints_stats_get(struct objagg_hints *objagg_hints)\n{\n\tstruct objagg_stats *objagg_stats;\n\tstruct objagg_hints_node *hnode;\n\tint i;\n\n\tobjagg_stats = kzalloc(struct_size(objagg_stats, stats_info,\n\t\t\t\t\t   objagg_hints->node_count),\n\t\t\t       GFP_KERNEL);\n\tif (!objagg_stats)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\ti = 0;\n\tlist_for_each_entry(hnode, &objagg_hints->node_list, list) {\n\t\tmemcpy(&objagg_stats->stats_info[i], &hnode->stats_info,\n\t\t       sizeof(objagg_stats->stats_info[0]));\n\t\tif (objagg_stats->stats_info[i].is_root)\n\t\t\tobjagg_stats->root_count++;\n\t\ti++;\n\t}\n\tobjagg_stats->stats_info_count = i;\n\n\tsort(objagg_stats->stats_info, objagg_stats->stats_info_count,\n\t     sizeof(struct objagg_obj_stats_info),\n\t     objagg_stats_info_sort_cmp_func, NULL);\n\n\treturn objagg_stats;\n}\nEXPORT_SYMBOL(objagg_hints_stats_get);\n\nMODULE_LICENSE(\"Dual BSD/GPL\");\nMODULE_AUTHOR(\"Jiri Pirko <jiri@mellanox.com>\");\nMODULE_DESCRIPTION(\"Object aggregation manager\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}