{
  "module_name": "logic_iomem.c",
  "hash_id": "a187e73ae1d733054b8084e26d2f041c6db7636a0aeaee0f3a8cb11abb6e988d",
  "original_prompt": "Ingested from linux-6.6.14/lib/logic_iomem.c",
  "human_readable_source": "\n \n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/logic_iomem.h>\n#include <asm/io.h>\n\nstruct logic_iomem_region {\n\tconst struct resource *res;\n\tconst struct logic_iomem_region_ops *ops;\n\tstruct list_head list;\n};\n\nstruct logic_iomem_area {\n\tconst struct logic_iomem_ops *ops;\n\tvoid *priv;\n};\n\n#define AREA_SHIFT\t24\n#define MAX_AREA_SIZE\t(1 << AREA_SHIFT)\n#define MAX_AREAS\t((1U << 31) / MAX_AREA_SIZE)\n#define AREA_BITS\t((MAX_AREAS - 1) << AREA_SHIFT)\n#define AREA_MASK\t(MAX_AREA_SIZE - 1)\n#ifdef CONFIG_64BIT\n#define IOREMAP_BIAS\t0xDEAD000000000000UL\n#define IOREMAP_MASK\t0xFFFFFFFF00000000UL\n#else\n#define IOREMAP_BIAS\t0x80000000UL\n#define IOREMAP_MASK\t0x80000000UL\n#endif\n\nstatic DEFINE_MUTEX(regions_mtx);\nstatic LIST_HEAD(regions_list);\nstatic struct logic_iomem_area mapped_areas[MAX_AREAS];\n\nint logic_iomem_add_region(struct resource *resource,\n\t\t\t   const struct logic_iomem_region_ops *ops)\n{\n\tstruct logic_iomem_region *rreg;\n\tint err;\n\n\tif (WARN_ON(!resource || !ops))\n\t\treturn -EINVAL;\n\n\tif (WARN_ON((resource->flags & IORESOURCE_TYPE_BITS) != IORESOURCE_MEM))\n\t\treturn -EINVAL;\n\n\trreg = kzalloc(sizeof(*rreg), GFP_KERNEL);\n\tif (!rreg)\n\t\treturn -ENOMEM;\n\n\terr = request_resource(&iomem_resource, resource);\n\tif (err) {\n\t\tkfree(rreg);\n\t\treturn -ENOMEM;\n\t}\n\n\tmutex_lock(&regions_mtx);\n\trreg->res = resource;\n\trreg->ops = ops;\n\tlist_add_tail(&rreg->list, &regions_list);\n\tmutex_unlock(&regions_mtx);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(logic_iomem_add_region);\n\n#ifndef CONFIG_INDIRECT_IOMEM_FALLBACK\nstatic void __iomem *real_ioremap(phys_addr_t offset, size_t size)\n{\n\tWARN(1, \"invalid ioremap(0x%llx, 0x%zx)\\n\",\n\t     (unsigned long long)offset, size);\n\treturn NULL;\n}\n\nstatic void real_iounmap(volatile void __iomem *addr)\n{\n\tWARN(1, \"invalid iounmap for addr 0x%llx\\n\",\n\t     (unsigned long long)(uintptr_t __force)addr);\n}\n#endif  \n\nvoid __iomem *ioremap(phys_addr_t offset, size_t size)\n{\n\tvoid __iomem *ret = NULL;\n\tstruct logic_iomem_region *rreg, *found = NULL;\n\tint i;\n\n\tmutex_lock(&regions_mtx);\n\tlist_for_each_entry(rreg, &regions_list, list) {\n\t\tif (rreg->res->start > offset)\n\t\t\tcontinue;\n\t\tif (rreg->res->end < offset + size - 1)\n\t\t\tcontinue;\n\t\tfound = rreg;\n\t\tbreak;\n\t}\n\n\tif (!found)\n\t\tgoto out;\n\n\tfor (i = 0; i < MAX_AREAS; i++) {\n\t\tlong offs;\n\n\t\tif (mapped_areas[i].ops)\n\t\t\tcontinue;\n\n\t\toffs = rreg->ops->map(offset - found->res->start,\n\t\t\t\t      size, &mapped_areas[i].ops,\n\t\t\t\t      &mapped_areas[i].priv);\n\t\tif (offs < 0) {\n\t\t\tmapped_areas[i].ops = NULL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (WARN_ON(!mapped_areas[i].ops)) {\n\t\t\tmapped_areas[i].ops = NULL;\n\t\t\tbreak;\n\t\t}\n\n\t\tret = (void __iomem *)(IOREMAP_BIAS + (i << AREA_SHIFT) + offs);\n\t\tbreak;\n\t}\nout:\n\tmutex_unlock(&regions_mtx);\n\tif (ret)\n\t\treturn ret;\n\treturn real_ioremap(offset, size);\n}\nEXPORT_SYMBOL(ioremap);\n\nstatic inline struct logic_iomem_area *\nget_area(const volatile void __iomem *addr)\n{\n\tunsigned long a = (unsigned long)addr;\n\tunsigned int idx;\n\n\tif (WARN_ON((a & IOREMAP_MASK) != IOREMAP_BIAS))\n\t\treturn NULL;\n\n\tidx = (a & AREA_BITS) >> AREA_SHIFT;\n\n\tif (mapped_areas[idx].ops)\n\t\treturn &mapped_areas[idx];\n\n\treturn NULL;\n}\n\nvoid iounmap(volatile void __iomem *addr)\n{\n\tstruct logic_iomem_area *area = get_area(addr);\n\n\tif (!area) {\n\t\treal_iounmap(addr);\n\t\treturn;\n\t}\n\n\tif (area->ops->unmap)\n\t\tarea->ops->unmap(area->priv);\n\n\tmutex_lock(&regions_mtx);\n\tarea->ops = NULL;\n\tarea->priv = NULL;\n\tmutex_unlock(&regions_mtx);\n}\nEXPORT_SYMBOL(iounmap);\n\n#ifndef CONFIG_INDIRECT_IOMEM_FALLBACK\n#define MAKE_FALLBACK(op, sz) \t\t\t\t\t\t\\\nstatic u##sz real_raw_read ## op(const volatile void __iomem *addr)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tWARN(1, \"Invalid read\" #op \" at address %llx\\n\",\t\t\\\n\t     (unsigned long long)(uintptr_t __force)addr);\t\t\\\n\treturn (u ## sz)~0ULL;\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\nstatic void real_raw_write ## op(u ## sz val,\t\t\t\t\\\n\t\t\t\t volatile void __iomem *addr)\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tWARN(1, \"Invalid writeq\" #op \" of 0x%llx at address %llx\\n\",\t\\\n\t     (unsigned long long)val,\t\t\t\t\t\\\n\t     (unsigned long long)(uintptr_t __force)addr);\\\n}\t\t\t\t\t\t\t\t\t\\\n\nMAKE_FALLBACK(b, 8);\nMAKE_FALLBACK(w, 16);\nMAKE_FALLBACK(l, 32);\n#ifdef CONFIG_64BIT\nMAKE_FALLBACK(q, 64);\n#endif\n\nstatic void real_memset_io(volatile void __iomem *addr, int value, size_t size)\n{\n\tWARN(1, \"Invalid memset_io at address 0x%llx\\n\",\n\t     (unsigned long long)(uintptr_t __force)addr);\n}\n\nstatic void real_memcpy_fromio(void *buffer, const volatile void __iomem *addr,\n\t\t\t       size_t size)\n{\n\tWARN(1, \"Invalid memcpy_fromio at address 0x%llx\\n\",\n\t     (unsigned long long)(uintptr_t __force)addr);\n\n\tmemset(buffer, 0xff, size);\n}\n\nstatic void real_memcpy_toio(volatile void __iomem *addr, const void *buffer,\n\t\t\t     size_t size)\n{\n\tWARN(1, \"Invalid memcpy_toio at address 0x%llx\\n\",\n\t     (unsigned long long)(uintptr_t __force)addr);\n}\n#endif  \n\n#define MAKE_OP(op, sz) \t\t\t\t\t\t\\\nu##sz __raw_read ## op(const volatile void __iomem *addr)\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct logic_iomem_area *area = get_area(addr);\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tif (!area)\t\t\t\t\t\t\t\\\n\t\treturn real_raw_read ## op(addr);\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\treturn (u ## sz) area->ops->read(area->priv,\t\t\t\\\n\t\t\t\t\t (unsigned long)addr & AREA_MASK,\\\n\t\t\t\t\t sz / 8);\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\nEXPORT_SYMBOL(__raw_read ## op);\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\nvoid __raw_write ## op(u ## sz val, volatile void __iomem *addr)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct logic_iomem_area *area = get_area(addr);\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tif (!area) {\t\t\t\t\t\t\t\\\n\t\treal_raw_write ## op(val, addr);\t\t\t\\\n\t\treturn;\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tarea->ops->write(area->priv,\t\t\t\t\t\\\n\t\t\t (unsigned long)addr & AREA_MASK,\t\t\\\n\t\t\t sz / 8, val);\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\nEXPORT_SYMBOL(__raw_write ## op)\n\nMAKE_OP(b, 8);\nMAKE_OP(w, 16);\nMAKE_OP(l, 32);\n#ifdef CONFIG_64BIT\nMAKE_OP(q, 64);\n#endif\n\nvoid memset_io(volatile void __iomem *addr, int value, size_t size)\n{\n\tstruct logic_iomem_area *area = get_area(addr);\n\tunsigned long offs, start;\n\n\tif (!area) {\n\t\treal_memset_io(addr, value, size);\n\t\treturn;\n\t}\n\n\tstart = (unsigned long)addr & AREA_MASK;\n\n\tif (area->ops->set) {\n\t\tarea->ops->set(area->priv, start, value, size);\n\t\treturn;\n\t}\n\n\tfor (offs = 0; offs < size; offs++)\n\t\tarea->ops->write(area->priv, start + offs, 1, value);\n}\nEXPORT_SYMBOL(memset_io);\n\nvoid memcpy_fromio(void *buffer, const volatile void __iomem *addr,\n                   size_t size)\n{\n\tstruct logic_iomem_area *area = get_area(addr);\n\tu8 *buf = buffer;\n\tunsigned long offs, start;\n\n\tif (!area) {\n\t\treal_memcpy_fromio(buffer, addr, size);\n\t\treturn;\n\t}\n\n\tstart = (unsigned long)addr & AREA_MASK;\n\n\tif (area->ops->copy_from) {\n\t\tarea->ops->copy_from(area->priv, buffer, start, size);\n\t\treturn;\n\t}\n\n\tfor (offs = 0; offs < size; offs++)\n\t\tbuf[offs] = area->ops->read(area->priv, start + offs, 1);\n}\nEXPORT_SYMBOL(memcpy_fromio);\n\nvoid memcpy_toio(volatile void __iomem *addr, const void *buffer, size_t size)\n{\n\tstruct logic_iomem_area *area = get_area(addr);\n\tconst u8 *buf = buffer;\n\tunsigned long offs, start;\n\n\tif (!area) {\n\t\treal_memcpy_toio(addr, buffer, size);\n\t\treturn;\n\t}\n\n\tstart = (unsigned long)addr & AREA_MASK;\n\n\tif (area->ops->copy_to) {\n\t\tarea->ops->copy_to(area->priv, start, buffer, size);\n\t\treturn;\n\t}\n\n\tfor (offs = 0; offs < size; offs++)\n\t\tarea->ops->write(area->priv, start + offs, 1, buf[offs]);\n}\nEXPORT_SYMBOL(memcpy_toio);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}