{
  "module_name": "decode_rs.c",
  "hash_id": "4e65beceb9482a2b8bbecc36593d4680e7966e2ae6bc79be773fbcc8822061a1",
  "original_prompt": "Ingested from linux-6.6.14/lib/reed_solomon/decode_rs.c",
  "human_readable_source": "\n \n{\n\tstruct rs_codec *rs = rsc->codec;\n\tint deg_lambda, el, deg_omega;\n\tint i, j, r, k, pad;\n\tint nn = rs->nn;\n\tint nroots = rs->nroots;\n\tint fcr = rs->fcr;\n\tint prim = rs->prim;\n\tint iprim = rs->iprim;\n\tuint16_t *alpha_to = rs->alpha_to;\n\tuint16_t *index_of = rs->index_of;\n\tuint16_t u, q, tmp, num1, num2, den, discr_r, syn_error;\n\tint count = 0;\n\tint num_corrected;\n\tuint16_t msk = (uint16_t) rs->nn;\n\n\t \n\tuint16_t *lambda = rsc->buffers + RS_DECODE_LAMBDA * (nroots + 1);\n\tuint16_t *syn = rsc->buffers + RS_DECODE_SYN * (nroots + 1);\n\tuint16_t *b = rsc->buffers + RS_DECODE_B * (nroots + 1);\n\tuint16_t *t = rsc->buffers + RS_DECODE_T * (nroots + 1);\n\tuint16_t *omega = rsc->buffers + RS_DECODE_OMEGA * (nroots + 1);\n\tuint16_t *root = rsc->buffers + RS_DECODE_ROOT * (nroots + 1);\n\tuint16_t *reg = rsc->buffers + RS_DECODE_REG * (nroots + 1);\n\tuint16_t *loc = rsc->buffers + RS_DECODE_LOC * (nroots + 1);\n\n\t \n\tpad = nn - nroots - len;\n\tBUG_ON(pad < 0 || pad >= nn - nroots);\n\n\t \n\tif (s != NULL) {\n\t\tfor (i = 0; i < nroots; i++) {\n\t\t\t \n\t\t\tif (s[i] != nn)\n\t\t\t\tgoto decode;\n\t\t}\n\n\t\t \n\t\treturn 0;\n\t}\n\n\t \n\tfor (i = 0; i < nroots; i++)\n\t\tsyn[i] = (((uint16_t) data[0]) ^ invmsk) & msk;\n\n\tfor (j = 1; j < len; j++) {\n\t\tfor (i = 0; i < nroots; i++) {\n\t\t\tif (syn[i] == 0) {\n\t\t\t\tsyn[i] = (((uint16_t) data[j]) ^\n\t\t\t\t\t  invmsk) & msk;\n\t\t\t} else {\n\t\t\t\tsyn[i] = ((((uint16_t) data[j]) ^\n\t\t\t\t\t   invmsk) & msk) ^\n\t\t\t\t\talpha_to[rs_modnn(rs, index_of[syn[i]] +\n\t\t\t\t\t\t       (fcr + i) * prim)];\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (j = 0; j < nroots; j++) {\n\t\tfor (i = 0; i < nroots; i++) {\n\t\t\tif (syn[i] == 0) {\n\t\t\t\tsyn[i] = ((uint16_t) par[j]) & msk;\n\t\t\t} else {\n\t\t\t\tsyn[i] = (((uint16_t) par[j]) & msk) ^\n\t\t\t\t\talpha_to[rs_modnn(rs, index_of[syn[i]] +\n\t\t\t\t\t\t       (fcr+i)*prim)];\n\t\t\t}\n\t\t}\n\t}\n\ts = syn;\n\n\t \n\tsyn_error = 0;\n\tfor (i = 0; i < nroots; i++) {\n\t\tsyn_error |= s[i];\n\t\ts[i] = index_of[s[i]];\n\t}\n\n\tif (!syn_error) {\n\t\t \n\t\treturn 0;\n\t}\n\n decode:\n\tmemset(&lambda[1], 0, nroots * sizeof(lambda[0]));\n\tlambda[0] = 1;\n\n\tif (no_eras > 0) {\n\t\t \n\t\tlambda[1] = alpha_to[rs_modnn(rs,\n\t\t\t\t\tprim * (nn - 1 - (eras_pos[0] + pad)))];\n\t\tfor (i = 1; i < no_eras; i++) {\n\t\t\tu = rs_modnn(rs, prim * (nn - 1 - (eras_pos[i] + pad)));\n\t\t\tfor (j = i + 1; j > 0; j--) {\n\t\t\t\ttmp = index_of[lambda[j - 1]];\n\t\t\t\tif (tmp != nn) {\n\t\t\t\t\tlambda[j] ^=\n\t\t\t\t\t\talpha_to[rs_modnn(rs, u + tmp)];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (i = 0; i < nroots + 1; i++)\n\t\tb[i] = index_of[lambda[i]];\n\n\t \n\tr = no_eras;\n\tel = no_eras;\n\twhile (++r <= nroots) {\t \n\t\t \n\t\tdiscr_r = 0;\n\t\tfor (i = 0; i < r; i++) {\n\t\t\tif ((lambda[i] != 0) && (s[r - i - 1] != nn)) {\n\t\t\t\tdiscr_r ^=\n\t\t\t\t\talpha_to[rs_modnn(rs,\n\t\t\t\t\t\t\t  index_of[lambda[i]] +\n\t\t\t\t\t\t\t  s[r - i - 1])];\n\t\t\t}\n\t\t}\n\t\tdiscr_r = index_of[discr_r];\t \n\t\tif (discr_r == nn) {\n\t\t\t \n\t\t\tmemmove (&b[1], b, nroots * sizeof (b[0]));\n\t\t\tb[0] = nn;\n\t\t} else {\n\t\t\t \n\t\t\tt[0] = lambda[0];\n\t\t\tfor (i = 0; i < nroots; i++) {\n\t\t\t\tif (b[i] != nn) {\n\t\t\t\t\tt[i + 1] = lambda[i + 1] ^\n\t\t\t\t\t\talpha_to[rs_modnn(rs, discr_r +\n\t\t\t\t\t\t\t\t  b[i])];\n\t\t\t\t} else\n\t\t\t\t\tt[i + 1] = lambda[i + 1];\n\t\t\t}\n\t\t\tif (2 * el <= r + no_eras - 1) {\n\t\t\t\tel = r + no_eras - el;\n\t\t\t\t \n\t\t\t\tfor (i = 0; i <= nroots; i++) {\n\t\t\t\t\tb[i] = (lambda[i] == 0) ? nn :\n\t\t\t\t\t\trs_modnn(rs, index_of[lambda[i]]\n\t\t\t\t\t\t\t - discr_r + nn);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tmemmove(&b[1], b, nroots * sizeof(b[0]));\n\t\t\t\tb[0] = nn;\n\t\t\t}\n\t\t\tmemcpy(lambda, t, (nroots + 1) * sizeof(t[0]));\n\t\t}\n\t}\n\n\t \n\tdeg_lambda = 0;\n\tfor (i = 0; i < nroots + 1; i++) {\n\t\tlambda[i] = index_of[lambda[i]];\n\t\tif (lambda[i] != nn)\n\t\t\tdeg_lambda = i;\n\t}\n\n\tif (deg_lambda == 0) {\n\t\t \n\t\treturn -EBADMSG;\n\t}\n\n\t \n\tmemcpy(&reg[1], &lambda[1], nroots * sizeof(reg[0]));\n\tcount = 0;\t\t \n\tfor (i = 1, k = iprim - 1; i <= nn; i++, k = rs_modnn(rs, k + iprim)) {\n\t\tq = 1;\t\t \n\t\tfor (j = deg_lambda; j > 0; j--) {\n\t\t\tif (reg[j] != nn) {\n\t\t\t\treg[j] = rs_modnn(rs, reg[j] + j);\n\t\t\t\tq ^= alpha_to[reg[j]];\n\t\t\t}\n\t\t}\n\t\tif (q != 0)\n\t\t\tcontinue;\t \n\n\t\tif (k < pad) {\n\t\t\t \n\t\t\treturn -EBADMSG;\n\t\t}\n\n\t\t \n\t\troot[count] = i;\n\t\tloc[count] = k;\n\t\t \n\t\tif (++count == deg_lambda)\n\t\t\tbreak;\n\t}\n\tif (deg_lambda != count) {\n\t\t \n\t\treturn -EBADMSG;\n\t}\n\t \n\tdeg_omega = deg_lambda - 1;\n\tfor (i = 0; i <= deg_omega; i++) {\n\t\ttmp = 0;\n\t\tfor (j = i; j >= 0; j--) {\n\t\t\tif ((s[i - j] != nn) && (lambda[j] != nn))\n\t\t\t\ttmp ^=\n\t\t\t\t    alpha_to[rs_modnn(rs, s[i - j] + lambda[j])];\n\t\t}\n\t\tomega[i] = index_of[tmp];\n\t}\n\n\t \n\tnum_corrected = 0;\n\tfor (j = count - 1; j >= 0; j--) {\n\t\tnum1 = 0;\n\t\tfor (i = deg_omega; i >= 0; i--) {\n\t\t\tif (omega[i] != nn)\n\t\t\t\tnum1 ^= alpha_to[rs_modnn(rs, omega[i] +\n\t\t\t\t\t\t\ti * root[j])];\n\t\t}\n\n\t\tif (num1 == 0) {\n\t\t\t \n\t\t\tb[j] = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tnum2 = alpha_to[rs_modnn(rs, root[j] * (fcr - 1) + nn)];\n\t\tden = 0;\n\n\t\t \n\t\tfor (i = min(deg_lambda, nroots - 1) & ~1; i >= 0; i -= 2) {\n\t\t\tif (lambda[i + 1] != nn) {\n\t\t\t\tden ^= alpha_to[rs_modnn(rs, lambda[i + 1] +\n\t\t\t\t\t\t       i * root[j])];\n\t\t\t}\n\t\t}\n\n\t\tb[j] = alpha_to[rs_modnn(rs, index_of[num1] +\n\t\t\t\t\t       index_of[num2] +\n\t\t\t\t\t       nn - index_of[den])];\n\t\tnum_corrected++;\n\t}\n\n\t \n\tfor (i = 0; i < nroots; i++) {\n\t\ttmp = 0;\n\t\tfor (j = 0; j < count; j++) {\n\t\t\tif (b[j] == 0)\n\t\t\t\tcontinue;\n\n\t\t\tk = (fcr + i) * prim * (nn-loc[j]-1);\n\t\t\ttmp ^= alpha_to[rs_modnn(rs, index_of[b[j]] + k)];\n\t\t}\n\n\t\tif (tmp != alpha_to[s[i]])\n\t\t\treturn -EBADMSG;\n\t}\n\n\t \n\tif (corr && eras_pos) {\n\t\tj = 0;\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tif (b[i]) {\n\t\t\t\tcorr[j] = b[i];\n\t\t\t\teras_pos[j++] = loc[i] - pad;\n\t\t\t}\n\t\t}\n\t} else if (data && par) {\n\t\t \n\t\tfor (i = 0; i < count; i++) {\n\t\t\tif (loc[i] < (nn - nroots))\n\t\t\t\tdata[loc[i] - pad] ^= b[i];\n\t\t\telse\n\t\t\t\tpar[loc[i] - pad - len] ^= b[i];\n\t\t}\n\t}\n\n\treturn  num_corrected;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}