{
  "module_name": "test_rslib.c",
  "hash_id": "681e12ed1ba26e4645dcb4252d28fb526e24d72121bb2304804eb83a8485fedb",
  "original_prompt": "Ingested from linux-6.6.14/lib/reed_solomon/test_rslib.c",
  "human_readable_source": "\n \n#include <linux/rslib.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/random.h>\n#include <linux/slab.h>\n\nenum verbosity {\n\tV_SILENT,\n\tV_PROGRESS,\n\tV_CSUMMARY\n};\n\nenum method {\n\tCORR_BUFFER,\n\tCALLER_SYNDROME,\n\tIN_PLACE\n};\n\n#define __param(type, name, init, msg)\t\t\\\n\tstatic type name = init;\t\t\\\n\tmodule_param(name, type, 0444);\t\t\\\n\tMODULE_PARM_DESC(name, msg)\n\n__param(int, v, V_PROGRESS, \"Verbosity level\");\n__param(int, ewsc, 1, \"Erasures without symbol corruption\");\n__param(int, bc, 1, \"Test for correct behaviour beyond error correction capacity\");\n\nstruct etab {\n\tint\tsymsize;\n\tint\tgenpoly;\n\tint\tfcs;\n\tint\tprim;\n\tint\tnroots;\n\tint\tntrials;\n};\n\n \nstatic struct etab Tab[] = {\n\t{2,\t0x7,\t1,\t1,\t1,\t100000\t},\n\t{3,\t0xb,\t1,\t1,\t2,\t100000\t},\n\t{3,\t0xb,\t1,\t1,\t3,\t100000\t},\n\t{3,\t0xb,\t2,\t1,\t4,\t100000\t},\n\t{4,\t0x13,\t1,\t1,\t4,\t10000\t},\n\t{5,\t0x25,\t1,\t1,\t6,\t1000\t},\n\t{6,\t0x43,\t3,\t1,\t8,\t1000\t},\n\t{7,\t0x89,\t1,\t1,\t14,\t500\t},\n\t{8,\t0x11d,\t1,\t1,\t30,\t100\t},\n\t{8,\t0x187,\t112,\t11,\t32,\t100\t},\n\t{9,\t0x211,\t1,\t1,\t33,\t80\t},\n\t{0, 0, 0, 0, 0, 0},\n};\n\n\nstruct estat {\n\tint\tdwrong;\n\tint\tirv;\n\tint\twepos;\n\tint\tnwords;\n};\n\nstruct bcstat {\n\tint\trfail;\n\tint\trsuccess;\n\tint\tnoncw;\n\tint\tnwords;\n};\n\nstruct wspace {\n\tuint16_t\t*c;\t\t \n\tuint16_t\t*r;\t\t \n\tuint16_t\t*s;\t\t \n\tuint16_t\t*corr;\t\t \n\tint\t\t*errlocs;\n\tint\t\t*derrlocs;\n};\n\nstruct pad {\n\tint\tmult;\n\tint\tshift;\n};\n\nstatic struct pad pad_coef[] = {\n\t{ 0, 0 },\n\t{ 1, 2 },\n\t{ 1, 1 },\n\t{ 3, 2 },\n\t{ 1, 0 },\n};\n\nstatic void free_ws(struct wspace *ws)\n{\n\tif (!ws)\n\t\treturn;\n\n\tkfree(ws->errlocs);\n\tkfree(ws->c);\n\tkfree(ws);\n}\n\nstatic struct wspace *alloc_ws(struct rs_codec *rs)\n{\n\tint nroots = rs->nroots;\n\tstruct wspace *ws;\n\tint nn = rs->nn;\n\n\tws = kzalloc(sizeof(*ws), GFP_KERNEL);\n\tif (!ws)\n\t\treturn NULL;\n\n\tws->c = kmalloc_array(2 * (nn + nroots),\n\t\t\t\tsizeof(uint16_t), GFP_KERNEL);\n\tif (!ws->c)\n\t\tgoto err;\n\n\tws->r = ws->c + nn;\n\tws->s = ws->r + nn;\n\tws->corr = ws->s + nroots;\n\n\tws->errlocs = kmalloc_array(nn + nroots, sizeof(int), GFP_KERNEL);\n\tif (!ws->errlocs)\n\t\tgoto err;\n\n\tws->derrlocs = ws->errlocs + nn;\n\treturn ws;\n\nerr:\n\tfree_ws(ws);\n\treturn NULL;\n}\n\n\n \nstatic int get_rcw_we(struct rs_control *rs, struct wspace *ws,\n\t\t\tint len, int errs, int eras)\n{\n\tint nroots = rs->codec->nroots;\n\tint *derrlocs = ws->derrlocs;\n\tint *errlocs = ws->errlocs;\n\tint dlen = len - nroots;\n\tint nn = rs->codec->nn;\n\tuint16_t *c = ws->c;\n\tuint16_t *r = ws->r;\n\tint errval;\n\tint errloc;\n\tint i;\n\n\t \n\tfor (i = 0; i < dlen; i++)\n\t\tc[i] = get_random_u32() & nn;\n\n\tmemset(c + dlen, 0, nroots * sizeof(*c));\n\tencode_rs16(rs, c, dlen, c + dlen, 0);\n\n\t \n\tmemcpy(r, c, len * sizeof(*r));\n\tmemset(errlocs, 0, len * sizeof(*errlocs));\n\tmemset(derrlocs, 0, nroots * sizeof(*derrlocs));\n\n\t \n\tfor (i = 0; i < errs; i++) {\n\t\tdo {\n\t\t\t \n\t\t\terrval = get_random_u32() & nn;\n\t\t} while (errval == 0);\n\n\t\tdo {\n\t\t\t \n\t\t\terrloc = get_random_u32_below(len);\n\t\t} while (errlocs[errloc] != 0);\n\n\t\terrlocs[errloc] = 1;\n\t\tr[errloc] ^= errval;\n\t}\n\n\t \n\tfor (i = 0; i < eras; i++) {\n\t\tdo {\n\t\t\t \n\t\t\terrloc = get_random_u32_below(len);\n\t\t} while (errlocs[errloc] != 0);\n\n\t\tderrlocs[i] = errloc;\n\n\t\tif (ewsc && get_random_u32_below(2)) {\n\t\t\t \n\t\t\terrlocs[errloc] = 2;\n\t\t} else {\n\t\t\t \n\t\t\tdo {\n\t\t\t\t \n\t\t\t\terrval = get_random_u32() & nn;\n\t\t\t} while (errval == 0);\n\n\t\t\terrlocs[errloc] = 1;\n\t\t\tr[errloc] ^= errval;\n\t\t\terrs++;\n\t\t}\n\t}\n\n\treturn errs;\n}\n\nstatic void fix_err(uint16_t *data, int nerrs, uint16_t *corr, int *errlocs)\n{\n\tint i;\n\n\tfor (i = 0; i < nerrs; i++)\n\t\tdata[errlocs[i]] ^= corr[i];\n}\n\nstatic void compute_syndrome(struct rs_control *rsc, uint16_t *data,\n\t\t\t\tint len, uint16_t *syn)\n{\n\tstruct rs_codec *rs = rsc->codec;\n\tuint16_t *alpha_to = rs->alpha_to;\n\tuint16_t *index_of = rs->index_of;\n\tint nroots = rs->nroots;\n\tint prim = rs->prim;\n\tint fcr = rs->fcr;\n\tint i, j;\n\n\t \n\tfor (i = 0; i < nroots; i++) {\n\t\tsyn[i] = data[0];\n\t\tfor (j = 1; j < len; j++) {\n\t\t\tif (syn[i] == 0) {\n\t\t\t\tsyn[i] = data[j];\n\t\t\t} else {\n\t\t\t\tsyn[i] = data[j] ^\n\t\t\t\t\talpha_to[rs_modnn(rs, index_of[syn[i]]\n\t\t\t\t\t\t+ (fcr + i) * prim)];\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < nroots; i++)\n\t\tsyn[i] = rs->index_of[syn[i]];\n}\n\n \nstatic void test_uc(struct rs_control *rs, int len, int errs,\n\t\tint eras, int trials, struct estat *stat,\n\t\tstruct wspace *ws, int method)\n{\n\tint dlen = len - rs->codec->nroots;\n\tint *derrlocs = ws->derrlocs;\n\tint *errlocs = ws->errlocs;\n\tuint16_t *corr = ws->corr;\n\tuint16_t *c = ws->c;\n\tuint16_t *r = ws->r;\n\tuint16_t *s = ws->s;\n\tint derrs, nerrs;\n\tint i, j;\n\n\tfor (j = 0; j < trials; j++) {\n\t\tnerrs = get_rcw_we(rs, ws, len, errs, eras);\n\n\t\tswitch (method) {\n\t\tcase CORR_BUFFER:\n\t\t\tderrs = decode_rs16(rs, r, r + dlen, dlen,\n\t\t\t\t\tNULL, eras, derrlocs, 0, corr);\n\t\t\tfix_err(r, derrs, corr, derrlocs);\n\t\t\tbreak;\n\t\tcase CALLER_SYNDROME:\n\t\t\tcompute_syndrome(rs, r, len, s);\n\t\t\tderrs = decode_rs16(rs, NULL, NULL, dlen,\n\t\t\t\t\ts, eras, derrlocs, 0, corr);\n\t\t\tfix_err(r, derrs, corr, derrlocs);\n\t\t\tbreak;\n\t\tcase IN_PLACE:\n\t\t\tderrs = decode_rs16(rs, r, r + dlen, dlen,\n\t\t\t\t\tNULL, eras, derrlocs, 0, NULL);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (derrs != nerrs)\n\t\t\tstat->irv++;\n\n\t\tif (method != IN_PLACE) {\n\t\t\tfor (i = 0; i < derrs; i++) {\n\t\t\t\tif (errlocs[derrlocs[i]] != 1)\n\t\t\t\t\tstat->wepos++;\n\t\t\t}\n\t\t}\n\n\t\tif (memcmp(r, c, len * sizeof(*r)))\n\t\t\tstat->dwrong++;\n\t}\n\tstat->nwords += trials;\n}\n\nstatic int ex_rs_helper(struct rs_control *rs, struct wspace *ws,\n\t\t\tint len, int trials, int method)\n{\n\tstatic const char * const desc[] = {\n\t\t\"Testing correction buffer interface...\",\n\t\t\"Testing with caller provided syndrome...\",\n\t\t\"Testing in-place interface...\"\n\t};\n\n\tstruct estat stat = {0, 0, 0, 0};\n\tint nroots = rs->codec->nroots;\n\tint errs, eras, retval;\n\n\tif (v >= V_PROGRESS)\n\t\tpr_info(\"  %s\\n\", desc[method]);\n\n\tfor (errs = 0; errs <= nroots / 2; errs++)\n\t\tfor (eras = 0; eras <= nroots - 2 * errs; eras++)\n\t\t\ttest_uc(rs, len, errs, eras, trials, &stat, ws, method);\n\n\tif (v >= V_CSUMMARY) {\n\t\tpr_info(\"    Decodes wrong:        %d / %d\\n\",\n\t\t\t\tstat.dwrong, stat.nwords);\n\t\tpr_info(\"    Wrong return value:   %d / %d\\n\",\n\t\t\t\tstat.irv, stat.nwords);\n\t\tif (method != IN_PLACE)\n\t\t\tpr_info(\"    Wrong error position: %d\\n\", stat.wepos);\n\t}\n\n\tretval = stat.dwrong + stat.wepos + stat.irv;\n\tif (retval && v >= V_PROGRESS)\n\t\tpr_warn(\"    FAIL: %d decoding failures!\\n\", retval);\n\n\treturn retval;\n}\n\nstatic int exercise_rs(struct rs_control *rs, struct wspace *ws,\n\t\t       int len, int trials)\n{\n\n\tint retval = 0;\n\tint i;\n\n\tif (v >= V_PROGRESS)\n\t\tpr_info(\"Testing up to error correction capacity...\\n\");\n\n\tfor (i = 0; i <= IN_PLACE; i++)\n\t\tretval |= ex_rs_helper(rs, ws, len, trials, i);\n\n\treturn retval;\n}\n\n \nstatic void test_bc(struct rs_control *rs, int len, int errs,\n\t\tint eras, int trials, struct bcstat *stat,\n\t\tstruct wspace *ws)\n{\n\tint nroots = rs->codec->nroots;\n\tint dlen = len - nroots;\n\tint *derrlocs = ws->derrlocs;\n\tuint16_t *corr = ws->corr;\n\tuint16_t *r = ws->r;\n\tint derrs, j;\n\n\tfor (j = 0; j < trials; j++) {\n\t\tget_rcw_we(rs, ws, len, errs, eras);\n\t\tderrs = decode_rs16(rs, r, r + dlen, dlen,\n\t\t\t\tNULL, eras, derrlocs, 0, corr);\n\t\tfix_err(r, derrs, corr, derrlocs);\n\n\t\tif (derrs >= 0) {\n\t\t\tstat->rsuccess++;\n\n\t\t\t \n\t\t\tmemset(corr, 0, nroots * sizeof(*corr));\n\t\t\tencode_rs16(rs, r, dlen, corr, 0);\n\n\t\t\tif (memcmp(r + dlen, corr, nroots * sizeof(*corr)))\n\t\t\t\tstat->noncw++;\n\t\t} else {\n\t\t\tstat->rfail++;\n\t\t}\n\t}\n\tstat->nwords += trials;\n}\n\nstatic int exercise_rs_bc(struct rs_control *rs, struct wspace *ws,\n\t\t\t  int len, int trials)\n{\n\tstruct bcstat stat = {0, 0, 0, 0};\n\tint nroots = rs->codec->nroots;\n\tint errs, eras, cutoff;\n\n\tif (v >= V_PROGRESS)\n\t\tpr_info(\"Testing beyond error correction capacity...\\n\");\n\n\tfor (errs = 1; errs <= nroots; errs++) {\n\t\teras = nroots - 2 * errs + 1;\n\t\tif (eras < 0)\n\t\t\teras = 0;\n\n\t\tcutoff = nroots <= len - errs ? nroots : len - errs;\n\t\tfor (; eras <= cutoff; eras++)\n\t\t\ttest_bc(rs, len, errs, eras, trials, &stat, ws);\n\t}\n\n\tif (v >= V_CSUMMARY) {\n\t\tpr_info(\"  decoder gives up:        %d / %d\\n\",\n\t\t\t\tstat.rfail, stat.nwords);\n\t\tpr_info(\"  decoder returns success: %d / %d\\n\",\n\t\t\t\tstat.rsuccess, stat.nwords);\n\t\tpr_info(\"    not a codeword:        %d / %d\\n\",\n\t\t\t\tstat.noncw, stat.rsuccess);\n\t}\n\n\tif (stat.noncw && v >= V_PROGRESS)\n\t\tpr_warn(\"    FAIL: %d silent failures!\\n\", stat.noncw);\n\n\treturn stat.noncw;\n}\n\nstatic int run_exercise(struct etab *e)\n{\n\tint nn = (1 << e->symsize) - 1;\n\tint kk = nn - e->nroots;\n\tstruct rs_control *rsc;\n\tint retval = -ENOMEM;\n\tint max_pad = kk - 1;\n\tint prev_pad = -1;\n\tstruct wspace *ws;\n\tint i;\n\n\trsc = init_rs(e->symsize, e->genpoly, e->fcs, e->prim, e->nroots);\n\tif (!rsc)\n\t\treturn retval;\n\n\tws = alloc_ws(rsc->codec);\n\tif (!ws)\n\t\tgoto err;\n\n\tretval = 0;\n\tfor (i = 0; i < ARRAY_SIZE(pad_coef); i++) {\n\t\tint pad = (pad_coef[i].mult * max_pad) >> pad_coef[i].shift;\n\t\tint len = nn - pad;\n\n\t\tif (pad == prev_pad)\n\t\t\tcontinue;\n\n\t\tprev_pad = pad;\n\t\tif (v >= V_PROGRESS) {\n\t\t\tpr_info(\"Testing (%d,%d)_%d code...\\n\",\n\t\t\t\t\tlen, kk - pad, nn + 1);\n\t\t}\n\n\t\tretval |= exercise_rs(rsc, ws, len, e->ntrials);\n\t\tif (bc)\n\t\t\tretval |= exercise_rs_bc(rsc, ws, len, e->ntrials);\n\t}\n\n\tfree_ws(ws);\n\nerr:\n\tfree_rs(rsc);\n\treturn retval;\n}\n\nstatic int __init test_rslib_init(void)\n{\n\tint i, fail = 0;\n\n\tfor (i = 0; Tab[i].symsize != 0 ; i++) {\n\t\tint retval;\n\n\t\tretval = run_exercise(Tab + i);\n\t\tif (retval < 0)\n\t\t\treturn -ENOMEM;\n\n\t\tfail |= retval;\n\t}\n\n\tif (fail)\n\t\tpr_warn(\"rslib: test failed\\n\");\n\telse\n\t\tpr_info(\"rslib: test ok\\n\");\n\n\treturn -EAGAIN;  \n}\n\nstatic void __exit test_rslib_exit(void)\n{\n}\n\nmodule_init(test_rslib_init)\nmodule_exit(test_rslib_exit)\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Ferdinand Blomqvist\");\nMODULE_DESCRIPTION(\"Reed-Solomon library test\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}