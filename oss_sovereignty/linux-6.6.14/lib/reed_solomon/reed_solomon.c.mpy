{
  "module_name": "reed_solomon.c",
  "hash_id": "eb346b3cd9295d01fd4ca5ab9d399c0a7079c3bded4112e67c757511b736383d",
  "original_prompt": "Ingested from linux-6.6.14/lib/reed_solomon/reed_solomon.c",
  "human_readable_source": "\n \n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/rslib.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n\nenum {\n\tRS_DECODE_LAMBDA,\n\tRS_DECODE_SYN,\n\tRS_DECODE_B,\n\tRS_DECODE_T,\n\tRS_DECODE_OMEGA,\n\tRS_DECODE_ROOT,\n\tRS_DECODE_REG,\n\tRS_DECODE_LOC,\n\tRS_DECODE_NUM_BUFFERS\n};\n\n \nstatic LIST_HEAD(codec_list);\n \nstatic DEFINE_MUTEX(rslistlock);\n\n \nstatic struct rs_codec *codec_init(int symsize, int gfpoly, int (*gffunc)(int),\n\t\t\t\t   int fcr, int prim, int nroots, gfp_t gfp)\n{\n\tint i, j, sr, root, iprim;\n\tstruct rs_codec *rs;\n\n\trs = kzalloc(sizeof(*rs), gfp);\n\tif (!rs)\n\t\treturn NULL;\n\n\tINIT_LIST_HEAD(&rs->list);\n\n\trs->mm = symsize;\n\trs->nn = (1 << symsize) - 1;\n\trs->fcr = fcr;\n\trs->prim = prim;\n\trs->nroots = nroots;\n\trs->gfpoly = gfpoly;\n\trs->gffunc = gffunc;\n\n\t \n\trs->alpha_to = kmalloc_array(rs->nn + 1, sizeof(uint16_t), gfp);\n\tif (rs->alpha_to == NULL)\n\t\tgoto err;\n\n\trs->index_of = kmalloc_array(rs->nn + 1, sizeof(uint16_t), gfp);\n\tif (rs->index_of == NULL)\n\t\tgoto err;\n\n\trs->genpoly = kmalloc_array(rs->nroots + 1, sizeof(uint16_t), gfp);\n\tif(rs->genpoly == NULL)\n\t\tgoto err;\n\n\t \n\trs->index_of[0] = rs->nn;\t \n\trs->alpha_to[rs->nn] = 0;\t \n\tif (gfpoly) {\n\t\tsr = 1;\n\t\tfor (i = 0; i < rs->nn; i++) {\n\t\t\trs->index_of[sr] = i;\n\t\t\trs->alpha_to[i] = sr;\n\t\t\tsr <<= 1;\n\t\t\tif (sr & (1 << symsize))\n\t\t\t\tsr ^= gfpoly;\n\t\t\tsr &= rs->nn;\n\t\t}\n\t} else {\n\t\tsr = gffunc(0);\n\t\tfor (i = 0; i < rs->nn; i++) {\n\t\t\trs->index_of[sr] = i;\n\t\t\trs->alpha_to[i] = sr;\n\t\t\tsr = gffunc(sr);\n\t\t}\n\t}\n\t \n\tif(sr != rs->alpha_to[0])\n\t\tgoto err;\n\n\t \n\tfor(iprim = 1; (iprim % prim) != 0; iprim += rs->nn);\n\t \n\trs->iprim = iprim / prim;\n\n\t \n\trs->genpoly[0] = 1;\n\tfor (i = 0, root = fcr * prim; i < nroots; i++, root += prim) {\n\t\trs->genpoly[i + 1] = 1;\n\t\t \n\t\tfor (j = i; j > 0; j--) {\n\t\t\tif (rs->genpoly[j] != 0) {\n\t\t\t\trs->genpoly[j] = rs->genpoly[j -1] ^\n\t\t\t\t\trs->alpha_to[rs_modnn(rs,\n\t\t\t\t\trs->index_of[rs->genpoly[j]] + root)];\n\t\t\t} else\n\t\t\t\trs->genpoly[j] = rs->genpoly[j - 1];\n\t\t}\n\t\t \n\t\trs->genpoly[0] =\n\t\t\trs->alpha_to[rs_modnn(rs,\n\t\t\t\trs->index_of[rs->genpoly[0]] + root)];\n\t}\n\t \n\tfor (i = 0; i <= nroots; i++)\n\t\trs->genpoly[i] = rs->index_of[rs->genpoly[i]];\n\n\trs->users = 1;\n\tlist_add(&rs->list, &codec_list);\n\treturn rs;\n\nerr:\n\tkfree(rs->genpoly);\n\tkfree(rs->index_of);\n\tkfree(rs->alpha_to);\n\tkfree(rs);\n\treturn NULL;\n}\n\n\n \nvoid free_rs(struct rs_control *rs)\n{\n\tstruct rs_codec *cd;\n\n\tif (!rs)\n\t\treturn;\n\n\tcd = rs->codec;\n\tmutex_lock(&rslistlock);\n\tcd->users--;\n\tif(!cd->users) {\n\t\tlist_del(&cd->list);\n\t\tkfree(cd->alpha_to);\n\t\tkfree(cd->index_of);\n\t\tkfree(cd->genpoly);\n\t\tkfree(cd);\n\t}\n\tmutex_unlock(&rslistlock);\n\tkfree(rs);\n}\nEXPORT_SYMBOL_GPL(free_rs);\n\n \nstatic struct rs_control *init_rs_internal(int symsize, int gfpoly,\n\t\t\t\t\t   int (*gffunc)(int), int fcr,\n\t\t\t\t\t   int prim, int nroots, gfp_t gfp)\n{\n\tstruct list_head *tmp;\n\tstruct rs_control *rs;\n\tunsigned int bsize;\n\n\t \n\tif (symsize < 1)\n\t\treturn NULL;\n\tif (fcr < 0 || fcr >= (1<<symsize))\n\t\treturn NULL;\n\tif (prim <= 0 || prim >= (1<<symsize))\n\t\treturn NULL;\n\tif (nroots < 0 || nroots >= (1<<symsize))\n\t\treturn NULL;\n\n\t \n\tbsize = sizeof(uint16_t) * RS_DECODE_NUM_BUFFERS * (nroots + 1);\n\trs = kzalloc(sizeof(*rs) + bsize, gfp);\n\tif (!rs)\n\t\treturn NULL;\n\n\tmutex_lock(&rslistlock);\n\n\t \n\tlist_for_each(tmp, &codec_list) {\n\t\tstruct rs_codec *cd = list_entry(tmp, struct rs_codec, list);\n\n\t\tif (symsize != cd->mm)\n\t\t\tcontinue;\n\t\tif (gfpoly != cd->gfpoly)\n\t\t\tcontinue;\n\t\tif (gffunc != cd->gffunc)\n\t\t\tcontinue;\n\t\tif (fcr != cd->fcr)\n\t\t\tcontinue;\n\t\tif (prim != cd->prim)\n\t\t\tcontinue;\n\t\tif (nroots != cd->nroots)\n\t\t\tcontinue;\n\t\t \n\t\tcd->users++;\n\t\trs->codec = cd;\n\t\tgoto out;\n\t}\n\n\t \n\trs->codec = codec_init(symsize, gfpoly, gffunc, fcr, prim, nroots, gfp);\n\tif (!rs->codec) {\n\t\tkfree(rs);\n\t\trs = NULL;\n\t}\nout:\n\tmutex_unlock(&rslistlock);\n\treturn rs;\n}\n\n \nstruct rs_control *init_rs_gfp(int symsize, int gfpoly, int fcr, int prim,\n\t\t\t       int nroots, gfp_t gfp)\n{\n\treturn init_rs_internal(symsize, gfpoly, NULL, fcr, prim, nroots, gfp);\n}\nEXPORT_SYMBOL_GPL(init_rs_gfp);\n\n \nstruct rs_control *init_rs_non_canonical(int symsize, int (*gffunc)(int),\n\t\t\t\t\t int fcr, int prim, int nroots)\n{\n\treturn init_rs_internal(symsize, 0, gffunc, fcr, prim, nroots,\n\t\t\t\tGFP_KERNEL);\n}\nEXPORT_SYMBOL_GPL(init_rs_non_canonical);\n\n#ifdef CONFIG_REED_SOLOMON_ENC8\n \nint encode_rs8(struct rs_control *rsc, uint8_t *data, int len, uint16_t *par,\n\t       uint16_t invmsk)\n{\n#include \"encode_rs.c\"\n}\nEXPORT_SYMBOL_GPL(encode_rs8);\n#endif\n\n#ifdef CONFIG_REED_SOLOMON_DEC8\n \nint decode_rs8(struct rs_control *rsc, uint8_t *data, uint16_t *par, int len,\n\t       uint16_t *s, int no_eras, int *eras_pos, uint16_t invmsk,\n\t       uint16_t *corr)\n{\n#include \"decode_rs.c\"\n}\nEXPORT_SYMBOL_GPL(decode_rs8);\n#endif\n\n#ifdef CONFIG_REED_SOLOMON_ENC16\n \nint encode_rs16(struct rs_control *rsc, uint16_t *data, int len, uint16_t *par,\n\tuint16_t invmsk)\n{\n#include \"encode_rs.c\"\n}\nEXPORT_SYMBOL_GPL(encode_rs16);\n#endif\n\n#ifdef CONFIG_REED_SOLOMON_DEC16\n \nint decode_rs16(struct rs_control *rsc, uint16_t *data, uint16_t *par, int len,\n\t\tuint16_t *s, int no_eras, int *eras_pos, uint16_t invmsk,\n\t\tuint16_t *corr)\n{\n#include \"decode_rs.c\"\n}\nEXPORT_SYMBOL_GPL(decode_rs16);\n#endif\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"Reed Solomon encoder/decoder\");\nMODULE_AUTHOR(\"Phil Karn, Thomas Gleixner\");\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}