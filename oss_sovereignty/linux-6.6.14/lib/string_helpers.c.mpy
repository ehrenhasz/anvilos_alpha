{
  "module_name": "string_helpers.c",
  "hash_id": "529724e7b68f0b78f7984b280fbf79aae3088443adafcb725cc34901afe987bb",
  "original_prompt": "Ingested from linux-6.6.14/lib/string_helpers.c",
  "human_readable_source": "\n \n#include <linux/bug.h>\n#include <linux/kernel.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/ctype.h>\n#include <linux/device.h>\n#include <linux/errno.h>\n#include <linux/fs.h>\n#include <linux/limits.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/string_helpers.h>\n\n \nvoid string_get_size(u64 size, u64 blk_size, const enum string_size_units units,\n\t\t     char *buf, int len)\n{\n\tstatic const char *const units_10[] = {\n\t\t\"B\", \"kB\", \"MB\", \"GB\", \"TB\", \"PB\", \"EB\", \"ZB\", \"YB\"\n\t};\n\tstatic const char *const units_2[] = {\n\t\t\"B\", \"KiB\", \"MiB\", \"GiB\", \"TiB\", \"PiB\", \"EiB\", \"ZiB\", \"YiB\"\n\t};\n\tstatic const char *const *const units_str[] = {\n\t\t[STRING_UNITS_10] = units_10,\n\t\t[STRING_UNITS_2] = units_2,\n\t};\n\tstatic const unsigned int divisor[] = {\n\t\t[STRING_UNITS_10] = 1000,\n\t\t[STRING_UNITS_2] = 1024,\n\t};\n\tstatic const unsigned int rounding[] = { 500, 50, 5 };\n\tint i = 0, j;\n\tu32 remainder = 0, sf_cap;\n\tchar tmp[8];\n\tconst char *unit;\n\n\ttmp[0] = '\\0';\n\n\tif (blk_size == 0)\n\t\tsize = 0;\n\tif (size == 0)\n\t\tgoto out;\n\n\t \n\twhile (blk_size >> 32) {\n\t\tdo_div(blk_size, divisor[units]);\n\t\ti++;\n\t}\n\n\twhile (size >> 32) {\n\t\tdo_div(size, divisor[units]);\n\t\ti++;\n\t}\n\n\t \n\tsize *= blk_size;\n\n\t \n\twhile (size >= divisor[units]) {\n\t\tremainder = do_div(size, divisor[units]);\n\t\ti++;\n\t}\n\n\t \n\tsf_cap = size;\n\tfor (j = 0; sf_cap*10 < 1000; j++)\n\t\tsf_cap *= 10;\n\n\tif (units == STRING_UNITS_2) {\n\t\t \n\t\tremainder *= 1000;\n\t\tremainder >>= 10;\n\t}\n\n\t \n\tremainder += rounding[j];\n\tif (remainder >= 1000) {\n\t\tremainder -= 1000;\n\t\tsize += 1;\n\t}\n\n\tif (j) {\n\t\tsnprintf(tmp, sizeof(tmp), \".%03u\", remainder);\n\t\ttmp[j+1] = '\\0';\n\t}\n\n out:\n\tif (i >= ARRAY_SIZE(units_2))\n\t\tunit = \"UNK\";\n\telse\n\t\tunit = units_str[units][i];\n\n\tsnprintf(buf, len, \"%u%s %s\", (u32)size,\n\t\t tmp, unit);\n}\nEXPORT_SYMBOL(string_get_size);\n\n \nint parse_int_array_user(const char __user *from, size_t count, int **array)\n{\n\tint *ints, nints;\n\tchar *buf;\n\tint ret = 0;\n\n\tbuf = memdup_user_nul(from, count);\n\tif (IS_ERR(buf))\n\t\treturn PTR_ERR(buf);\n\n\tget_options(buf, 0, &nints);\n\tif (!nints) {\n\t\tret = -ENOENT;\n\t\tgoto free_buf;\n\t}\n\n\tints = kcalloc(nints + 1, sizeof(*ints), GFP_KERNEL);\n\tif (!ints) {\n\t\tret = -ENOMEM;\n\t\tgoto free_buf;\n\t}\n\n\tget_options(buf, nints + 1, ints);\n\t*array = ints;\n\nfree_buf:\n\tkfree(buf);\n\treturn ret;\n}\nEXPORT_SYMBOL(parse_int_array_user);\n\nstatic bool unescape_space(char **src, char **dst)\n{\n\tchar *p = *dst, *q = *src;\n\n\tswitch (*q) {\n\tcase 'n':\n\t\t*p = '\\n';\n\t\tbreak;\n\tcase 'r':\n\t\t*p = '\\r';\n\t\tbreak;\n\tcase 't':\n\t\t*p = '\\t';\n\t\tbreak;\n\tcase 'v':\n\t\t*p = '\\v';\n\t\tbreak;\n\tcase 'f':\n\t\t*p = '\\f';\n\t\tbreak;\n\tdefault:\n\t\treturn false;\n\t}\n\t*dst += 1;\n\t*src += 1;\n\treturn true;\n}\n\nstatic bool unescape_octal(char **src, char **dst)\n{\n\tchar *p = *dst, *q = *src;\n\tu8 num;\n\n\tif (isodigit(*q) == 0)\n\t\treturn false;\n\n\tnum = (*q++) & 7;\n\twhile (num < 32 && isodigit(*q) && (q - *src < 3)) {\n\t\tnum <<= 3;\n\t\tnum += (*q++) & 7;\n\t}\n\t*p = num;\n\t*dst += 1;\n\t*src = q;\n\treturn true;\n}\n\nstatic bool unescape_hex(char **src, char **dst)\n{\n\tchar *p = *dst, *q = *src;\n\tint digit;\n\tu8 num;\n\n\tif (*q++ != 'x')\n\t\treturn false;\n\n\tnum = digit = hex_to_bin(*q++);\n\tif (digit < 0)\n\t\treturn false;\n\n\tdigit = hex_to_bin(*q);\n\tif (digit >= 0) {\n\t\tq++;\n\t\tnum = (num << 4) | digit;\n\t}\n\t*p = num;\n\t*dst += 1;\n\t*src = q;\n\treturn true;\n}\n\nstatic bool unescape_special(char **src, char **dst)\n{\n\tchar *p = *dst, *q = *src;\n\n\tswitch (*q) {\n\tcase '\\\"':\n\t\t*p = '\\\"';\n\t\tbreak;\n\tcase '\\\\':\n\t\t*p = '\\\\';\n\t\tbreak;\n\tcase 'a':\n\t\t*p = '\\a';\n\t\tbreak;\n\tcase 'e':\n\t\t*p = '\\e';\n\t\tbreak;\n\tdefault:\n\t\treturn false;\n\t}\n\t*dst += 1;\n\t*src += 1;\n\treturn true;\n}\n\n \nint string_unescape(char *src, char *dst, size_t size, unsigned int flags)\n{\n\tchar *out = dst;\n\n\twhile (*src && --size) {\n\t\tif (src[0] == '\\\\' && src[1] != '\\0' && size > 1) {\n\t\t\tsrc++;\n\t\t\tsize--;\n\n\t\t\tif (flags & UNESCAPE_SPACE &&\n\t\t\t\t\tunescape_space(&src, &out))\n\t\t\t\tcontinue;\n\n\t\t\tif (flags & UNESCAPE_OCTAL &&\n\t\t\t\t\tunescape_octal(&src, &out))\n\t\t\t\tcontinue;\n\n\t\t\tif (flags & UNESCAPE_HEX &&\n\t\t\t\t\tunescape_hex(&src, &out))\n\t\t\t\tcontinue;\n\n\t\t\tif (flags & UNESCAPE_SPECIAL &&\n\t\t\t\t\tunescape_special(&src, &out))\n\t\t\t\tcontinue;\n\n\t\t\t*out++ = '\\\\';\n\t\t}\n\t\t*out++ = *src++;\n\t}\n\t*out = '\\0';\n\n\treturn out - dst;\n}\nEXPORT_SYMBOL(string_unescape);\n\nstatic bool escape_passthrough(unsigned char c, char **dst, char *end)\n{\n\tchar *out = *dst;\n\n\tif (out < end)\n\t\t*out = c;\n\t*dst = out + 1;\n\treturn true;\n}\n\nstatic bool escape_space(unsigned char c, char **dst, char *end)\n{\n\tchar *out = *dst;\n\tunsigned char to;\n\n\tswitch (c) {\n\tcase '\\n':\n\t\tto = 'n';\n\t\tbreak;\n\tcase '\\r':\n\t\tto = 'r';\n\t\tbreak;\n\tcase '\\t':\n\t\tto = 't';\n\t\tbreak;\n\tcase '\\v':\n\t\tto = 'v';\n\t\tbreak;\n\tcase '\\f':\n\t\tto = 'f';\n\t\tbreak;\n\tdefault:\n\t\treturn false;\n\t}\n\n\tif (out < end)\n\t\t*out = '\\\\';\n\t++out;\n\tif (out < end)\n\t\t*out = to;\n\t++out;\n\n\t*dst = out;\n\treturn true;\n}\n\nstatic bool escape_special(unsigned char c, char **dst, char *end)\n{\n\tchar *out = *dst;\n\tunsigned char to;\n\n\tswitch (c) {\n\tcase '\\\\':\n\t\tto = '\\\\';\n\t\tbreak;\n\tcase '\\a':\n\t\tto = 'a';\n\t\tbreak;\n\tcase '\\e':\n\t\tto = 'e';\n\t\tbreak;\n\tcase '\"':\n\t\tto = '\"';\n\t\tbreak;\n\tdefault:\n\t\treturn false;\n\t}\n\n\tif (out < end)\n\t\t*out = '\\\\';\n\t++out;\n\tif (out < end)\n\t\t*out = to;\n\t++out;\n\n\t*dst = out;\n\treturn true;\n}\n\nstatic bool escape_null(unsigned char c, char **dst, char *end)\n{\n\tchar *out = *dst;\n\n\tif (c)\n\t\treturn false;\n\n\tif (out < end)\n\t\t*out = '\\\\';\n\t++out;\n\tif (out < end)\n\t\t*out = '0';\n\t++out;\n\n\t*dst = out;\n\treturn true;\n}\n\nstatic bool escape_octal(unsigned char c, char **dst, char *end)\n{\n\tchar *out = *dst;\n\n\tif (out < end)\n\t\t*out = '\\\\';\n\t++out;\n\tif (out < end)\n\t\t*out = ((c >> 6) & 0x07) + '0';\n\t++out;\n\tif (out < end)\n\t\t*out = ((c >> 3) & 0x07) + '0';\n\t++out;\n\tif (out < end)\n\t\t*out = ((c >> 0) & 0x07) + '0';\n\t++out;\n\n\t*dst = out;\n\treturn true;\n}\n\nstatic bool escape_hex(unsigned char c, char **dst, char *end)\n{\n\tchar *out = *dst;\n\n\tif (out < end)\n\t\t*out = '\\\\';\n\t++out;\n\tif (out < end)\n\t\t*out = 'x';\n\t++out;\n\tif (out < end)\n\t\t*out = hex_asc_hi(c);\n\t++out;\n\tif (out < end)\n\t\t*out = hex_asc_lo(c);\n\t++out;\n\n\t*dst = out;\n\treturn true;\n}\n\n \nint string_escape_mem(const char *src, size_t isz, char *dst, size_t osz,\n\t\t      unsigned int flags, const char *only)\n{\n\tchar *p = dst;\n\tchar *end = p + osz;\n\tbool is_dict = only && *only;\n\tbool is_append = flags & ESCAPE_APPEND;\n\n\twhile (isz--) {\n\t\tunsigned char c = *src++;\n\t\tbool in_dict = is_dict && strchr(only, c);\n\n\t\t \n\t\tif (!(is_append || in_dict) && is_dict &&\n\t\t\t\t\t  escape_passthrough(c, &p, end))\n\t\t\tcontinue;\n\n\t\tif (!(is_append && in_dict) && isascii(c) && isprint(c) &&\n\t\t    flags & ESCAPE_NAP && escape_passthrough(c, &p, end))\n\t\t\tcontinue;\n\n\t\tif (!(is_append && in_dict) && isprint(c) &&\n\t\t    flags & ESCAPE_NP && escape_passthrough(c, &p, end))\n\t\t\tcontinue;\n\n\t\tif (!(is_append && in_dict) && isascii(c) &&\n\t\t    flags & ESCAPE_NA && escape_passthrough(c, &p, end))\n\t\t\tcontinue;\n\n\t\tif (flags & ESCAPE_SPACE && escape_space(c, &p, end))\n\t\t\tcontinue;\n\n\t\tif (flags & ESCAPE_SPECIAL && escape_special(c, &p, end))\n\t\t\tcontinue;\n\n\t\tif (flags & ESCAPE_NULL && escape_null(c, &p, end))\n\t\t\tcontinue;\n\n\t\t \n\t\tif (flags & ESCAPE_OCTAL && escape_octal(c, &p, end))\n\t\t\tcontinue;\n\n\t\tif (flags & ESCAPE_HEX && escape_hex(c, &p, end))\n\t\t\tcontinue;\n\n\t\tescape_passthrough(c, &p, end);\n\t}\n\n\treturn p - dst;\n}\nEXPORT_SYMBOL(string_escape_mem);\n\n \nchar *kstrdup_quotable(const char *src, gfp_t gfp)\n{\n\tsize_t slen, dlen;\n\tchar *dst;\n\tconst int flags = ESCAPE_HEX;\n\tconst char esc[] = \"\\f\\n\\r\\t\\v\\a\\e\\\\\\\"\";\n\n\tif (!src)\n\t\treturn NULL;\n\tslen = strlen(src);\n\n\tdlen = string_escape_mem(src, slen, NULL, 0, flags, esc);\n\tdst = kmalloc(dlen + 1, gfp);\n\tif (!dst)\n\t\treturn NULL;\n\n\tWARN_ON(string_escape_mem(src, slen, dst, dlen, flags, esc) != dlen);\n\tdst[dlen] = '\\0';\n\n\treturn dst;\n}\nEXPORT_SYMBOL_GPL(kstrdup_quotable);\n\n \nchar *kstrdup_quotable_cmdline(struct task_struct *task, gfp_t gfp)\n{\n\tchar *buffer, *quoted;\n\tint i, res;\n\n\tbuffer = kmalloc(PAGE_SIZE, GFP_KERNEL);\n\tif (!buffer)\n\t\treturn NULL;\n\n\tres = get_cmdline(task, buffer, PAGE_SIZE - 1);\n\tbuffer[res] = '\\0';\n\n\t \n\twhile (--res >= 0 && buffer[res] == '\\0')\n\t\t;\n\n\t \n\tfor (i = 0; i <= res; i++)\n\t\tif (buffer[i] == '\\0')\n\t\t\tbuffer[i] = ' ';\n\n\t \n\tquoted = kstrdup_quotable(buffer, gfp);\n\tkfree(buffer);\n\treturn quoted;\n}\nEXPORT_SYMBOL_GPL(kstrdup_quotable_cmdline);\n\n \nchar *kstrdup_quotable_file(struct file *file, gfp_t gfp)\n{\n\tchar *temp, *pathname;\n\n\tif (!file)\n\t\treturn kstrdup(\"<unknown>\", gfp);\n\n\t \n\ttemp = kmalloc(PATH_MAX + 11, GFP_KERNEL);\n\tif (!temp)\n\t\treturn kstrdup(\"<no_memory>\", gfp);\n\n\tpathname = file_path(file, temp, PATH_MAX + 11);\n\tif (IS_ERR(pathname))\n\t\tpathname = kstrdup(\"<too_long>\", gfp);\n\telse\n\t\tpathname = kstrdup_quotable(pathname, gfp);\n\n\tkfree(temp);\n\treturn pathname;\n}\nEXPORT_SYMBOL_GPL(kstrdup_quotable_file);\n\n \nchar *kstrdup_and_replace(const char *src, char old, char new, gfp_t gfp)\n{\n\tchar *dst;\n\n\tdst = kstrdup(src, gfp);\n\tif (!dst)\n\t\treturn NULL;\n\n\treturn strreplace(dst, old, new);\n}\nEXPORT_SYMBOL_GPL(kstrdup_and_replace);\n\n \nchar **kasprintf_strarray(gfp_t gfp, const char *prefix, size_t n)\n{\n\tchar **names;\n\tsize_t i;\n\n\tnames = kcalloc(n + 1, sizeof(char *), gfp);\n\tif (!names)\n\t\treturn NULL;\n\n\tfor (i = 0; i < n; i++) {\n\t\tnames[i] = kasprintf(gfp, \"%s-%zu\", prefix, i);\n\t\tif (!names[i]) {\n\t\t\tkfree_strarray(names, i);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn names;\n}\nEXPORT_SYMBOL_GPL(kasprintf_strarray);\n\n \nvoid kfree_strarray(char **array, size_t n)\n{\n\tunsigned int i;\n\n\tif (!array)\n\t\treturn;\n\n\tfor (i = 0; i < n; i++)\n\t\tkfree(array[i]);\n\tkfree(array);\n}\nEXPORT_SYMBOL_GPL(kfree_strarray);\n\nstruct strarray {\n\tchar **array;\n\tsize_t n;\n};\n\nstatic void devm_kfree_strarray(struct device *dev, void *res)\n{\n\tstruct strarray *array = res;\n\n\tkfree_strarray(array->array, array->n);\n}\n\nchar **devm_kasprintf_strarray(struct device *dev, const char *prefix, size_t n)\n{\n\tstruct strarray *ptr;\n\n\tptr = devres_alloc(devm_kfree_strarray, sizeof(*ptr), GFP_KERNEL);\n\tif (!ptr)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tptr->array = kasprintf_strarray(GFP_KERNEL, prefix, n);\n\tif (!ptr->array) {\n\t\tdevres_free(ptr);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tptr->n = n;\n\tdevres_add(dev, ptr);\n\n\treturn ptr->array;\n}\nEXPORT_SYMBOL_GPL(devm_kasprintf_strarray);\n\n \nssize_t strscpy_pad(char *dest, const char *src, size_t count)\n{\n\tssize_t written;\n\n\twritten = strscpy(dest, src, count);\n\tif (written < 0 || written == count - 1)\n\t\treturn written;\n\n\tmemset(dest + written + 1, 0, count - written - 1);\n\n\treturn written;\n}\nEXPORT_SYMBOL(strscpy_pad);\n\n \nchar *skip_spaces(const char *str)\n{\n\twhile (isspace(*str))\n\t\t++str;\n\treturn (char *)str;\n}\nEXPORT_SYMBOL(skip_spaces);\n\n \nchar *strim(char *s)\n{\n\tsize_t size;\n\tchar *end;\n\n\tsize = strlen(s);\n\tif (!size)\n\t\treturn s;\n\n\tend = s + size - 1;\n\twhile (end >= s && isspace(*end))\n\t\tend--;\n\t*(end + 1) = '\\0';\n\n\treturn skip_spaces(s);\n}\nEXPORT_SYMBOL(strim);\n\n \nbool sysfs_streq(const char *s1, const char *s2)\n{\n\twhile (*s1 && *s1 == *s2) {\n\t\ts1++;\n\t\ts2++;\n\t}\n\n\tif (*s1 == *s2)\n\t\treturn true;\n\tif (!*s1 && *s2 == '\\n' && !s2[1])\n\t\treturn true;\n\tif (*s1 == '\\n' && !s1[1] && !*s2)\n\t\treturn true;\n\treturn false;\n}\nEXPORT_SYMBOL(sysfs_streq);\n\n \nint match_string(const char * const *array, size_t n, const char *string)\n{\n\tint index;\n\tconst char *item;\n\n\tfor (index = 0; index < n; index++) {\n\t\titem = array[index];\n\t\tif (!item)\n\t\t\tbreak;\n\t\tif (!strcmp(item, string))\n\t\t\treturn index;\n\t}\n\n\treturn -EINVAL;\n}\nEXPORT_SYMBOL(match_string);\n\n \nint __sysfs_match_string(const char * const *array, size_t n, const char *str)\n{\n\tconst char *item;\n\tint index;\n\n\tfor (index = 0; index < n; index++) {\n\t\titem = array[index];\n\t\tif (!item)\n\t\t\tbreak;\n\t\tif (sysfs_streq(item, str))\n\t\t\treturn index;\n\t}\n\n\treturn -EINVAL;\n}\nEXPORT_SYMBOL(__sysfs_match_string);\n\n \nchar *strreplace(char *str, char old, char new)\n{\n\tchar *s = str;\n\n\tfor (; *s; ++s)\n\t\tif (*s == old)\n\t\t\t*s = new;\n\treturn str;\n}\nEXPORT_SYMBOL(strreplace);\n\n \nvoid memcpy_and_pad(void *dest, size_t dest_len, const void *src, size_t count,\n\t\t    int pad)\n{\n\tif (dest_len > count) {\n\t\tmemcpy(dest, src, count);\n\t\tmemset(dest + count, pad,  dest_len - count);\n\t} else {\n\t\tmemcpy(dest, src, dest_len);\n\t}\n}\nEXPORT_SYMBOL(memcpy_and_pad);\n\n#ifdef CONFIG_FORTIFY_SOURCE\n \nvoid __read_overflow2_field(size_t avail, size_t wanted) { }\nEXPORT_SYMBOL(__read_overflow2_field);\nvoid __write_overflow_field(size_t avail, size_t wanted) { }\nEXPORT_SYMBOL(__write_overflow_field);\n\nvoid fortify_panic(const char *name)\n{\n\tpr_emerg(\"detected buffer overflow in %s\\n\", name);\n\tBUG();\n}\nEXPORT_SYMBOL(fortify_panic);\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}