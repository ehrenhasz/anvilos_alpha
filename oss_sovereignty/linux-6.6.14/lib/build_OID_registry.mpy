{
  "module_name": "build_OID_registry",
  "hash_id": "16d319140e546f003ea1741559271c584a5c74ac9d40dd6e145871272334e84d",
  "original_prompt": "Ingested from linux-6.6.14/lib/build_OID_registry",
  "human_readable_source": "#!/usr/bin/perl -w\n# SPDX-License-Identifier: GPL-2.0-or-later\n#\n# Build a static ASN.1 Object Identified (OID) registry\n#\n# Copyright (C) 2012 Red Hat, Inc. All Rights Reserved.\n# Written by David Howells (dhowells@redhat.com)\n#\n\nuse strict;\n\nmy @names = ();\nmy @oids = ();\n\nif ($#ARGV != 1) {\n    print STDERR \"Format: \", $0, \" <in-h-file> <out-c-file>\\n\";\n    exit(2);\n}\n\n#\n# Open the file to read from\n#\nopen IN_FILE, \"<$ARGV[0]\" || die;\nwhile (<IN_FILE>) {\n    chomp;\n    if (m!\\s+OID_([a-zA-z][a-zA-Z0-9_]+),\\s+/[*]\\s+([012][.0-9]*)\\s+[*]/!) {\n\tpush @names, $1;\n\tpush @oids, $2;\n    }\n}\nclose IN_FILE || die;\n\n#\n# Open the files to write into\n#\nopen C_FILE, \">$ARGV[1]\" or die;\nprint C_FILE \"/*\\n\";\nprint C_FILE \" * Automatically generated by \", $0, \".  Do not edit\\n\";\nprint C_FILE \" */\\n\";\n\n#\n# Split the data up into separate lists and also determine the lengths of the\n# encoded data arrays.\n#\nmy @indices = ();\nmy @lengths = ();\nmy $total_length = 0;\n\nfor (my $i = 0; $i <= $#names; $i++) {\n    my $name = $names[$i];\n    my $oid = $oids[$i];\n\n    my @components = split(/[.]/, $oid);\n\n    # Determine the encoded length of this OID\n    my $size = $#components;\n    for (my $loop = 2; $loop <= $#components; $loop++) {\n\tmy $c = $components[$loop];\n\n\t# We will base128 encode the number\n\tmy $tmp = ($c == 0) ? 0 : int(log($c)/log(2));\n\t$tmp = int($tmp / 7);\n\t$size += $tmp;\n    }\n    push @lengths, $size;\n    push @indices, $total_length;\n    $total_length += $size;\n}\n\n#\n# Emit the look-up-by-OID index table\n#\nprint C_FILE \"\\n\";\nif ($total_length <= 255) {\n    print C_FILE \"static const unsigned char oid_index[OID__NR + 1] = {\\n\";\n} else {\n    print C_FILE \"static const unsigned short oid_index[OID__NR + 1] = {\\n\";\n}\nfor (my $i = 0; $i <= $#names; $i++) {\n    print C_FILE \"\\t[OID_\", $names[$i], \"] = \", $indices[$i], \",\\n\"\n}\nprint C_FILE \"\\t[OID__NR] = \", $total_length, \"\\n\";\nprint C_FILE \"};\\n\";\n\n#\n# Encode the OIDs\n#\nmy @encoded_oids = ();\n\nfor (my $i = 0; $i <= $#names; $i++) {\n    my @octets = ();\n\n    my @components = split(/[.]/, $oids[$i]);\n\n    push @octets, $components[0] * 40 + $components[1];\n\n    for (my $loop = 2; $loop <= $#components; $loop++) {\n\tmy $c = $components[$loop];\n\n\t# Base128 encode the number\n\tmy $tmp = ($c == 0) ? 0 : int(log($c)/log(2));\n\t$tmp = int($tmp / 7);\n\n\tfor (; $tmp > 0; $tmp--) {\n\t    push @octets, (($c >> $tmp * 7) & 0x7f) | 0x80;\n\t}\n\tpush @octets, $c & 0x7f;\n    }\n\n    push @encoded_oids, \\@octets;\n}\n\n#\n# Create a hash value for each OID\n#\nmy @hash_values = ();\nfor (my $i = 0; $i <= $#names; $i++) {\n    my @octets = @{$encoded_oids[$i]};\n\n    my $hash = $#octets;\n    foreach (@octets) {\n\t$hash += $_ * 33;\n    }\n\n    $hash = ($hash >> 24) ^ ($hash >> 16) ^ ($hash >> 8) ^ ($hash);\n\n    push @hash_values, $hash & 0xff;\n}\n\n#\n# Emit the OID data\n#\nprint C_FILE \"\\n\";\nprint C_FILE \"static const unsigned char oid_data[\", $total_length, \"] = {\\n\";\nfor (my $i = 0; $i <= $#names; $i++) {\n    my @octets = @{$encoded_oids[$i]};\n    print C_FILE \"\\t\";\n    print C_FILE $_, \", \" foreach (@octets);\n    print C_FILE \"\\t// \", $names[$i];\n    print C_FILE \"\\n\";\n}\nprint C_FILE \"};\\n\";\n\n#\n# Build the search index table (ordered by length then hash then content)\n#\nmy @index_table = ( 0 .. $#names );\n\n@index_table = sort {\n    my @octets_a = @{$encoded_oids[$a]};\n    my @octets_b = @{$encoded_oids[$b]};\n\n    return $hash_values[$a] <=> $hash_values[$b]\n\tif ($hash_values[$a] != $hash_values[$b]);\n    return $#octets_a <=> $#octets_b\n\tif ($#octets_a != $#octets_b);\n    for (my $i = $#octets_a; $i >= 0; $i--) {\n\treturn $octets_a[$i] <=> $octets_b[$i]\n\t    if ($octets_a[$i] != $octets_b[$i]);\n    }\n    return 0;\n\n} @index_table;\n\n#\n# Emit the search index and hash value table\n#\nprint C_FILE \"\\n\";\nprint C_FILE \"static const struct {\\n\";\nprint C_FILE \"\\tunsigned char hash;\\n\";\nif ($#names <= 255) {\n    print C_FILE \"\\tenum OID oid : 8;\\n\";\n} else {\n    print C_FILE \"\\tenum OID oid : 16;\\n\";\n}\nprint C_FILE \"} oid_search_table[OID__NR] = {\\n\";\nfor (my $i = 0; $i <= $#names; $i++) {\n    my @octets = @{$encoded_oids[$index_table[$i]]};\n    printf(C_FILE \"\\t[%3u] = { %3u, OID_%-35s }, // \",\n\t   $i,\n\t   $hash_values[$index_table[$i]],\n\t   $names[$index_table[$i]]);\n    printf C_FILE \"%02x\", $_ foreach (@octets);\n    print C_FILE \"\\n\";\n}\nprint C_FILE \"};\\n\";\n\n#\n# Emit the OID debugging name table\n#\n#print C_FILE \"\\n\";\n#print C_FILE \"const char *const oid_name_table[OID__NR + 1] = {\\n\";\n#\n#for (my $i = 0; $i <= $#names; $i++) {\n#    print C_FILE \"\\t\\\"\", $names[$i], \"\\\",\\n\"\n#}\n#print C_FILE \"\\t\\\"Unknown-OID\\\"\\n\";\n#print C_FILE \"};\\n\";\n\n#\n# Polish off\n#\nclose C_FILE or die;\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}