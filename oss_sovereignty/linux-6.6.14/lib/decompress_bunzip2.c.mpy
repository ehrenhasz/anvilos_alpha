{
  "module_name": "decompress_bunzip2.c",
  "hash_id": "ae9b912fd514f7ba00a372203f618820a81047c35c5a0ca06f504c32e0d3c66f",
  "original_prompt": "Ingested from linux-6.6.14/lib/decompress_bunzip2.c",
  "human_readable_source": " \n\n \n\n \n\n\n#ifdef STATIC\n#define PREBOOT\n#else\n#include <linux/decompress/bunzip2.h>\n#endif  \n\n#include <linux/decompress/mm.h>\n#include <linux/crc32poly.h>\n\n#ifndef INT_MAX\n#define INT_MAX 0x7fffffff\n#endif\n\n \n#define MAX_GROUPS\t\t6\n#define GROUP_SIZE   \t\t50\t \n#define MAX_HUFCODE_BITS \t20\t \n#define MAX_SYMBOLS \t\t258\t \n#define SYMBOL_RUNA\t\t0\n#define SYMBOL_RUNB\t\t1\n\n \n#define RETVAL_OK\t\t\t0\n#define RETVAL_LAST_BLOCK\t\t(-1)\n#define RETVAL_NOT_BZIP_DATA\t\t(-2)\n#define RETVAL_UNEXPECTED_INPUT_EOF\t(-3)\n#define RETVAL_UNEXPECTED_OUTPUT_EOF\t(-4)\n#define RETVAL_DATA_ERROR\t\t(-5)\n#define RETVAL_OUT_OF_MEMORY\t\t(-6)\n#define RETVAL_OBSOLETE_INPUT\t\t(-7)\n\n \n#define BZIP2_IOBUF_SIZE\t\t4096\n\n \nstruct group_data {\n\t \n\tint limit[MAX_HUFCODE_BITS+1];\n\tint base[MAX_HUFCODE_BITS];\n\tint permute[MAX_SYMBOLS];\n\tint minLen, maxLen;\n};\n\n \nstruct bunzip_data {\n\t \n\tint writeCopies, writePos, writeRunCountdown, writeCount, writeCurrent;\n\t \n\tlong (*fill)(void*, unsigned long);\n\tlong inbufCount, inbufPos  ;\n\tunsigned char *inbuf  ;\n\tunsigned int inbufBitCount, inbufBits;\n\t \n\tunsigned int crc32Table[256], headerCRC, totalCRC, writeCRC;\n\t \n\tunsigned int *dbuf, dbufSize;\n\t \n\tunsigned char selectors[32768];\t\t \n\tstruct group_data groups[MAX_GROUPS];\t \n\tint io_error;\t\t\t \n\tint byteCount[256];\n\tunsigned char symToByte[256], mtfSymbol[256];\n};\n\n\n \nstatic unsigned int INIT get_bits(struct bunzip_data *bd, char bits_wanted)\n{\n\tunsigned int bits = 0;\n\n\t \n\twhile (bd->inbufBitCount < bits_wanted) {\n\t\t \n\t\tif (bd->inbufPos == bd->inbufCount) {\n\t\t\tif (bd->io_error)\n\t\t\t\treturn 0;\n\t\t\tbd->inbufCount = bd->fill(bd->inbuf, BZIP2_IOBUF_SIZE);\n\t\t\tif (bd->inbufCount <= 0) {\n\t\t\t\tbd->io_error = RETVAL_UNEXPECTED_INPUT_EOF;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbd->inbufPos = 0;\n\t\t}\n\t\t \n\t\tif (bd->inbufBitCount >= 24) {\n\t\t\tbits = bd->inbufBits&((1 << bd->inbufBitCount)-1);\n\t\t\tbits_wanted -= bd->inbufBitCount;\n\t\t\tbits <<= bits_wanted;\n\t\t\tbd->inbufBitCount = 0;\n\t\t}\n\t\t \n\t\tbd->inbufBits = (bd->inbufBits << 8)|bd->inbuf[bd->inbufPos++];\n\t\tbd->inbufBitCount += 8;\n\t}\n\t \n\tbd->inbufBitCount -= bits_wanted;\n\tbits |= (bd->inbufBits >> bd->inbufBitCount)&((1 << bits_wanted)-1);\n\n\treturn bits;\n}\n\n \n\nstatic int INIT get_next_block(struct bunzip_data *bd)\n{\n\tstruct group_data *hufGroup = NULL;\n\tint *base = NULL;\n\tint *limit = NULL;\n\tint dbufCount, nextSym, dbufSize, groupCount, selector,\n\t\ti, j, k, t, runPos, symCount, symTotal, nSelectors, *byteCount;\n\tunsigned char uc, *symToByte, *mtfSymbol, *selectors;\n\tunsigned int *dbuf, origPtr;\n\n\tdbuf = bd->dbuf;\n\tdbufSize = bd->dbufSize;\n\tselectors = bd->selectors;\n\tbyteCount = bd->byteCount;\n\tsymToByte = bd->symToByte;\n\tmtfSymbol = bd->mtfSymbol;\n\n\t \n\ti = get_bits(bd, 24);\n\tj = get_bits(bd, 24);\n\tbd->headerCRC = get_bits(bd, 32);\n\tif ((i == 0x177245) && (j == 0x385090))\n\t\treturn RETVAL_LAST_BLOCK;\n\tif ((i != 0x314159) || (j != 0x265359))\n\t\treturn RETVAL_NOT_BZIP_DATA;\n\t \n\tif (get_bits(bd, 1))\n\t\treturn RETVAL_OBSOLETE_INPUT;\n\torigPtr = get_bits(bd, 24);\n\tif (origPtr >= dbufSize)\n\t\treturn RETVAL_DATA_ERROR;\n\t \n\tt = get_bits(bd, 16);\n\tsymTotal = 0;\n\tfor (i = 0; i < 16; i++) {\n\t\tif (t&(1 << (15-i))) {\n\t\t\tk = get_bits(bd, 16);\n\t\t\tfor (j = 0; j < 16; j++)\n\t\t\t\tif (k&(1 << (15-j)))\n\t\t\t\t\tsymToByte[symTotal++] = (16*i)+j;\n\t\t}\n\t}\n\t \n\tgroupCount = get_bits(bd, 3);\n\tif (groupCount < 2 || groupCount > MAX_GROUPS)\n\t\treturn RETVAL_DATA_ERROR;\n\t \n\tnSelectors = get_bits(bd, 15);\n\tif (!nSelectors)\n\t\treturn RETVAL_DATA_ERROR;\n\tfor (i = 0; i < groupCount; i++)\n\t\tmtfSymbol[i] = i;\n\tfor (i = 0; i < nSelectors; i++) {\n\t\t \n\t\tfor (j = 0; get_bits(bd, 1); j++)\n\t\t\tif (j >= groupCount)\n\t\t\t\treturn RETVAL_DATA_ERROR;\n\t\t \n\t\tuc = mtfSymbol[j];\n\t\tfor (; j; j--)\n\t\t\tmtfSymbol[j] = mtfSymbol[j-1];\n\t\tmtfSymbol[0] = selectors[i] = uc;\n\t}\n\t \n\tsymCount = symTotal+2;\n\tfor (j = 0; j < groupCount; j++) {\n\t\tunsigned char length[MAX_SYMBOLS], temp[MAX_HUFCODE_BITS+1];\n\t\tint\tminLen,\tmaxLen, pp;\n\t\t \n\t\tt = get_bits(bd, 5)-1;\n\t\tfor (i = 0; i < symCount; i++) {\n\t\t\tfor (;;) {\n\t\t\t\tif (((unsigned)t) > (MAX_HUFCODE_BITS-1))\n\t\t\t\t\treturn RETVAL_DATA_ERROR;\n\n\t\t\t\t \n\n\t\t\t\tk = get_bits(bd, 2);\n\t\t\t\tif (k < 2) {\n\t\t\t\t\tbd->inbufBitCount++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t \n\t\t\t\tt += (((k+1)&2)-1);\n\t\t\t}\n\t\t\t \n\t\t\tlength[i] = t+1;\n\t\t}\n\t\t \n\t\tminLen = maxLen = length[0];\n\n\t\tfor (i = 1; i < symCount; i++) {\n\t\t\tif (length[i] > maxLen)\n\t\t\t\tmaxLen = length[i];\n\t\t\telse if (length[i] < minLen)\n\t\t\t\tminLen = length[i];\n\t\t}\n\n\t\t \n\t\thufGroup = bd->groups+j;\n\t\thufGroup->minLen = minLen;\n\t\thufGroup->maxLen = maxLen;\n\t\t \n\t\tbase = hufGroup->base-1;\n\t\tlimit = hufGroup->limit-1;\n\t\t \n\t\tpp = 0;\n\t\tfor (i = minLen; i <= maxLen; i++) {\n\t\t\ttemp[i] = limit[i] = 0;\n\t\t\tfor (t = 0; t < symCount; t++)\n\t\t\t\tif (length[t] == i)\n\t\t\t\t\thufGroup->permute[pp++] = t;\n\t\t}\n\t\t \n\t\tfor (i = 0; i < symCount; i++)\n\t\t\ttemp[length[i]]++;\n\t\t \n\t\tpp = t = 0;\n\t\tfor (i = minLen; i < maxLen; i++) {\n\t\t\tpp += temp[i];\n\t\t\t \n\t\t\tlimit[i] = (pp << (maxLen - i)) - 1;\n\t\t\tpp <<= 1;\n\t\t\tbase[i+1] = pp-(t += temp[i]);\n\t\t}\n\t\tlimit[maxLen+1] = INT_MAX;  \n\t\tlimit[maxLen] = pp+temp[maxLen]-1;\n\t\tbase[minLen] = 0;\n\t}\n\t \n\n\t \n\tfor (i = 0; i < 256; i++) {\n\t\tbyteCount[i] = 0;\n\t\tmtfSymbol[i] = (unsigned char)i;\n\t}\n\t \n\trunPos = dbufCount = symCount = selector = 0;\n\tfor (;;) {\n\t\t \n\t\tif (!(symCount--)) {\n\t\t\tsymCount = GROUP_SIZE-1;\n\t\t\tif (selector >= nSelectors)\n\t\t\t\treturn RETVAL_DATA_ERROR;\n\t\t\thufGroup = bd->groups+selectors[selector++];\n\t\t\tbase = hufGroup->base-1;\n\t\t\tlimit = hufGroup->limit-1;\n\t\t}\n\t\t \n\t\t \n\t\twhile (bd->inbufBitCount < hufGroup->maxLen) {\n\t\t\tif (bd->inbufPos == bd->inbufCount) {\n\t\t\t\tj = get_bits(bd, hufGroup->maxLen);\n\t\t\t\tgoto got_huff_bits;\n\t\t\t}\n\t\t\tbd->inbufBits =\n\t\t\t\t(bd->inbufBits << 8)|bd->inbuf[bd->inbufPos++];\n\t\t\tbd->inbufBitCount += 8;\n\t\t}\n\t\tbd->inbufBitCount -= hufGroup->maxLen;\n\t\tj = (bd->inbufBits >> bd->inbufBitCount)&\n\t\t\t((1 << hufGroup->maxLen)-1);\ngot_huff_bits:\n\t\t \n\t\ti = hufGroup->minLen;\n\t\twhile (j > limit[i])\n\t\t\t++i;\n\t\tbd->inbufBitCount += (hufGroup->maxLen - i);\n\t\t \n\t\tif ((i > hufGroup->maxLen)\n\t\t\t|| (((unsigned)(j = (j>>(hufGroup->maxLen-i))-base[i]))\n\t\t\t\t>= MAX_SYMBOLS))\n\t\t\treturn RETVAL_DATA_ERROR;\n\t\tnextSym = hufGroup->permute[j];\n\t\t \n\t\tif (((unsigned)nextSym) <= SYMBOL_RUNB) {  \n\t\t\t \n\t\t\tif (!runPos) {\n\t\t\t\trunPos = 1;\n\t\t\t\tt = 0;\n\t\t\t}\n\t\t\t \n\t\t\tt += (runPos << nextSym);\n\t\t\t \n\n\t\t\trunPos <<= 1;\n\t\t\tcontinue;\n\t\t}\n\t\t \n\t\tif (runPos) {\n\t\t\trunPos = 0;\n\t\t\tif (dbufCount+t >= dbufSize)\n\t\t\t\treturn RETVAL_DATA_ERROR;\n\n\t\t\tuc = symToByte[mtfSymbol[0]];\n\t\t\tbyteCount[uc] += t;\n\t\t\twhile (t--)\n\t\t\t\tdbuf[dbufCount++] = uc;\n\t\t}\n\t\t \n\t\tif (nextSym > symTotal)\n\t\t\tbreak;\n\t\t \n\t\tif (dbufCount >= dbufSize)\n\t\t\treturn RETVAL_DATA_ERROR;\n\t\ti = nextSym - 1;\n\t\tuc = mtfSymbol[i];\n\t\t \n\t\tdo {\n\t\t\tmtfSymbol[i] = mtfSymbol[i-1];\n\t\t} while (--i);\n\t\tmtfSymbol[0] = uc;\n\t\tuc = symToByte[uc];\n\t\t \n\t\tbyteCount[uc]++;\n\t\tdbuf[dbufCount++] = (unsigned int)uc;\n\t}\n\t \n\t \n\tj = 0;\n\tfor (i = 0; i < 256; i++) {\n\t\tk = j+byteCount[i];\n\t\tbyteCount[i] = j;\n\t\tj = k;\n\t}\n\t \n\tfor (i = 0; i < dbufCount; i++) {\n\t\tuc = (unsigned char)(dbuf[i] & 0xff);\n\t\tdbuf[byteCount[uc]] |= (i << 8);\n\t\tbyteCount[uc]++;\n\t}\n\t \n\tif (dbufCount) {\n\t\tif (origPtr >= dbufCount)\n\t\t\treturn RETVAL_DATA_ERROR;\n\t\tbd->writePos = dbuf[origPtr];\n\t\tbd->writeCurrent = (unsigned char)(bd->writePos&0xff);\n\t\tbd->writePos >>= 8;\n\t\tbd->writeRunCountdown = 5;\n\t}\n\tbd->writeCount = dbufCount;\n\n\treturn RETVAL_OK;\n}\n\n \n\nstatic int INIT read_bunzip(struct bunzip_data *bd, char *outbuf, int len)\n{\n\tconst unsigned int *dbuf;\n\tint pos, xcurrent, previous, gotcount;\n\n\t \n\tif (bd->writeCount < 0)\n\t\treturn bd->writeCount;\n\n\tgotcount = 0;\n\tdbuf = bd->dbuf;\n\tpos = bd->writePos;\n\txcurrent = bd->writeCurrent;\n\n\t \n\n\tif (bd->writeCopies) {\n\t\t \n\t\t--bd->writeCopies;\n\t\t \n\t\tfor (;;) {\n\t\t\t \n\t\t\tif (gotcount >= len) {\n\t\t\t\tbd->writePos = pos;\n\t\t\t\tbd->writeCurrent = xcurrent;\n\t\t\t\tbd->writeCopies++;\n\t\t\t\treturn len;\n\t\t\t}\n\t\t\t \n\t\t\toutbuf[gotcount++] = xcurrent;\n\t\t\tbd->writeCRC = (((bd->writeCRC) << 8)\n\t\t\t\t^bd->crc32Table[((bd->writeCRC) >> 24)\n\t\t\t\t^xcurrent]);\n\t\t\t \n\t\t\tif (bd->writeCopies) {\n\t\t\t\t--bd->writeCopies;\n\t\t\t\tcontinue;\n\t\t\t}\ndecode_next_byte:\n\t\t\tif (!bd->writeCount--)\n\t\t\t\tbreak;\n\t\t\t \n\t\t\tprevious = xcurrent;\n\t\t\tpos = dbuf[pos];\n\t\t\txcurrent = pos&0xff;\n\t\t\tpos >>= 8;\n\t\t\t \n\t\t\tif (--bd->writeRunCountdown) {\n\t\t\t\tif (xcurrent != previous)\n\t\t\t\t\tbd->writeRunCountdown = 4;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tbd->writeCopies = xcurrent;\n\t\t\t\txcurrent = previous;\n\t\t\t\tbd->writeRunCountdown = 5;\n\t\t\t\t \n\t\t\t\tif (!bd->writeCopies)\n\t\t\t\t\tgoto decode_next_byte;\n\t\t\t\t \n\t\t\t\t--bd->writeCopies;\n\t\t\t}\n\t\t}\n\t\t \n\t\tbd->writeCRC = ~bd->writeCRC;\n\t\tbd->totalCRC = ((bd->totalCRC << 1) |\n\t\t\t\t(bd->totalCRC >> 31)) ^ bd->writeCRC;\n\t\t \n\t\tif (bd->writeCRC != bd->headerCRC) {\n\t\t\tbd->totalCRC = bd->headerCRC+1;\n\t\t\treturn RETVAL_LAST_BLOCK;\n\t\t}\n\t}\n\n\t \n\t \n\tprevious = get_next_block(bd);\n\tif (previous) {\n\t\tbd->writeCount = previous;\n\t\treturn (previous != RETVAL_LAST_BLOCK) ? previous : gotcount;\n\t}\n\tbd->writeCRC = 0xffffffffUL;\n\tpos = bd->writePos;\n\txcurrent = bd->writeCurrent;\n\tgoto decode_next_byte;\n}\n\nstatic long INIT nofill(void *buf, unsigned long len)\n{\n\treturn -1;\n}\n\n \nstatic int INIT start_bunzip(struct bunzip_data **bdp, void *inbuf, long len,\n\t\t\t     long (*fill)(void*, unsigned long))\n{\n\tstruct bunzip_data *bd;\n\tunsigned int i, j, c;\n\tconst unsigned int BZh0 =\n\t\t(((unsigned int)'B') << 24)+(((unsigned int)'Z') << 16)\n\t\t+(((unsigned int)'h') << 8)+(unsigned int)'0';\n\n\t \n\ti = sizeof(struct bunzip_data);\n\n\t \n\tbd = *bdp = malloc(i);\n\tif (!bd)\n\t\treturn RETVAL_OUT_OF_MEMORY;\n\tmemset(bd, 0, sizeof(struct bunzip_data));\n\t \n\tbd->inbuf = inbuf;\n\tbd->inbufCount = len;\n\tif (fill != NULL)\n\t\tbd->fill = fill;\n\telse\n\t\tbd->fill = nofill;\n\n\t \n\tfor (i = 0; i < 256; i++) {\n\t\tc = i << 24;\n\t\tfor (j = 8; j; j--)\n\t\t\tc = c&0x80000000 ? (c << 1)^(CRC32_POLY_BE) : (c << 1);\n\t\tbd->crc32Table[i] = c;\n\t}\n\n\t \n\ti = get_bits(bd, 32);\n\tif (((unsigned int)(i-BZh0-1)) >= 9)\n\t\treturn RETVAL_NOT_BZIP_DATA;\n\n\t \n\tbd->dbufSize = 100000*(i-BZh0);\n\n\tbd->dbuf = large_malloc(bd->dbufSize * sizeof(int));\n\tif (!bd->dbuf)\n\t\treturn RETVAL_OUT_OF_MEMORY;\n\treturn RETVAL_OK;\n}\n\n \nSTATIC int INIT bunzip2(unsigned char *buf, long len,\n\t\t\tlong (*fill)(void*, unsigned long),\n\t\t\tlong (*flush)(void*, unsigned long),\n\t\t\tunsigned char *outbuf,\n\t\t\tlong *pos,\n\t\t\tvoid(*error)(char *x))\n{\n\tstruct bunzip_data *bd;\n\tint i = -1;\n\tunsigned char *inbuf;\n\n\tif (flush)\n\t\toutbuf = malloc(BZIP2_IOBUF_SIZE);\n\n\tif (!outbuf) {\n\t\terror(\"Could not allocate output buffer\");\n\t\treturn RETVAL_OUT_OF_MEMORY;\n\t}\n\tif (buf)\n\t\tinbuf = buf;\n\telse\n\t\tinbuf = malloc(BZIP2_IOBUF_SIZE);\n\tif (!inbuf) {\n\t\terror(\"Could not allocate input buffer\");\n\t\ti = RETVAL_OUT_OF_MEMORY;\n\t\tgoto exit_0;\n\t}\n\ti = start_bunzip(&bd, inbuf, len, fill);\n\tif (!i) {\n\t\tfor (;;) {\n\t\t\ti = read_bunzip(bd, outbuf, BZIP2_IOBUF_SIZE);\n\t\t\tif (i <= 0)\n\t\t\t\tbreak;\n\t\t\tif (!flush)\n\t\t\t\toutbuf += i;\n\t\t\telse\n\t\t\t\tif (i != flush(outbuf, i)) {\n\t\t\t\t\ti = RETVAL_UNEXPECTED_OUTPUT_EOF;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t}\n\t}\n\t \n\tif (i == RETVAL_LAST_BLOCK) {\n\t\tif (bd->headerCRC != bd->totalCRC)\n\t\t\terror(\"Data integrity error when decompressing.\");\n\t\telse\n\t\t\ti = RETVAL_OK;\n\t} else if (i == RETVAL_UNEXPECTED_OUTPUT_EOF) {\n\t\terror(\"Compressed file ends unexpectedly\");\n\t}\n\tif (!bd)\n\t\tgoto exit_1;\n\tif (bd->dbuf)\n\t\tlarge_free(bd->dbuf);\n\tif (pos)\n\t\t*pos = bd->inbufPos;\n\tfree(bd);\nexit_1:\n\tif (!buf)\n\t\tfree(inbuf);\nexit_0:\n\tif (flush)\n\t\tfree(outbuf);\n\treturn i;\n}\n\n#ifdef PREBOOT\nSTATIC int INIT __decompress(unsigned char *buf, long len,\n\t\t\tlong (*fill)(void*, unsigned long),\n\t\t\tlong (*flush)(void*, unsigned long),\n\t\t\tunsigned char *outbuf, long olen,\n\t\t\tlong *pos,\n\t\t\tvoid (*error)(char *x))\n{\n\treturn bunzip2(buf, len - 4, fill, flush, outbuf, pos, error);\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}