{
  "module_name": "test_static_keys.c",
  "hash_id": "1f986b1339c663d83aa3f008e5216d77107e01f402bffcdbc32b525c7960aef3",
  "original_prompt": "Ingested from linux-6.6.14/lib/test_static_keys.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/jump_label.h>\n\n \nstruct static_key old_true_key\t= STATIC_KEY_INIT_TRUE;\nstruct static_key old_false_key\t= STATIC_KEY_INIT_FALSE;\n\n \nDEFINE_STATIC_KEY_TRUE(true_key);\nDEFINE_STATIC_KEY_FALSE(false_key);\n\n \nextern struct static_key base_old_true_key;\nextern struct static_key base_inv_old_true_key;\nextern struct static_key base_old_false_key;\nextern struct static_key base_inv_old_false_key;\n\n \nextern struct static_key_true base_true_key;\nextern struct static_key_true base_inv_true_key;\nextern struct static_key_false base_false_key;\nextern struct static_key_false base_inv_false_key;\n\n\nstruct test_key {\n\tbool\t\t\tinit_state;\n\tstruct static_key\t*key;\n\tbool\t\t\t(*test_key)(void);\n};\n\n#define test_key_func(key, branch)\t\\\nstatic bool key ## _ ## branch(void)\t\\\n{\t\t\t\t\t\\\n\treturn branch(&key);\t\t\\\n}\n\nstatic void invert_key(struct static_key *key)\n{\n\tif (static_key_enabled(key))\n\t\tstatic_key_disable(key);\n\telse\n\t\tstatic_key_enable(key);\n}\n\nstatic void invert_keys(struct test_key *keys, int size)\n{\n\tstruct static_key *previous = NULL;\n\tint i;\n\n\tfor (i = 0; i < size; i++) {\n\t\tif (previous != keys[i].key) {\n\t\t\tinvert_key(keys[i].key);\n\t\t\tprevious = keys[i].key;\n\t\t}\n\t}\n}\n\nstatic int verify_keys(struct test_key *keys, int size, bool invert)\n{\n\tint i;\n\tbool ret, init;\n\n\tfor (i = 0; i < size; i++) {\n\t\tret = static_key_enabled(keys[i].key);\n\t\tinit = keys[i].init_state;\n\t\tif (ret != (invert ? !init : init))\n\t\t\treturn -EINVAL;\n\t\tret = keys[i].test_key();\n\t\tif (static_key_enabled(keys[i].key)) {\n\t\t\tif (!ret)\n\t\t\t\treturn -EINVAL;\n\t\t} else {\n\t\t\tif (ret)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\treturn 0;\n}\n\ntest_key_func(old_true_key, static_key_true)\ntest_key_func(old_false_key, static_key_false)\ntest_key_func(true_key, static_branch_likely)\ntest_key_func(true_key, static_branch_unlikely)\ntest_key_func(false_key, static_branch_likely)\ntest_key_func(false_key, static_branch_unlikely)\ntest_key_func(base_old_true_key, static_key_true)\ntest_key_func(base_inv_old_true_key, static_key_true)\ntest_key_func(base_old_false_key, static_key_false)\ntest_key_func(base_inv_old_false_key, static_key_false)\ntest_key_func(base_true_key, static_branch_likely)\ntest_key_func(base_true_key, static_branch_unlikely)\ntest_key_func(base_inv_true_key, static_branch_likely)\ntest_key_func(base_inv_true_key, static_branch_unlikely)\ntest_key_func(base_false_key, static_branch_likely)\ntest_key_func(base_false_key, static_branch_unlikely)\ntest_key_func(base_inv_false_key, static_branch_likely)\ntest_key_func(base_inv_false_key, static_branch_unlikely)\n\nstatic int __init test_static_key_init(void)\n{\n\tint ret;\n\tint size;\n\n\tstruct test_key static_key_tests[] = {\n\t\t \n\t\t{\n\t\t\t.init_state\t= true,\n\t\t\t.key\t\t= &old_true_key,\n\t\t\t.test_key\t= &old_true_key_static_key_true,\n\t\t},\n\t\t{\n\t\t\t.init_state\t= false,\n\t\t\t.key\t\t= &old_false_key,\n\t\t\t.test_key\t= &old_false_key_static_key_false,\n\t\t},\n\t\t \n\t\t{\n\t\t\t.init_state\t= true,\n\t\t\t.key\t\t= &true_key.key,\n\t\t\t.test_key\t= &true_key_static_branch_likely,\n\t\t},\n\t\t{\n\t\t\t.init_state\t= true,\n\t\t\t.key\t\t= &true_key.key,\n\t\t\t.test_key\t= &true_key_static_branch_unlikely,\n\t\t},\n\t\t{\n\t\t\t.init_state\t= false,\n\t\t\t.key\t\t= &false_key.key,\n\t\t\t.test_key\t= &false_key_static_branch_likely,\n\t\t},\n\t\t{\n\t\t\t.init_state\t= false,\n\t\t\t.key\t\t= &false_key.key,\n\t\t\t.test_key\t= &false_key_static_branch_unlikely,\n\t\t},\n\t\t \n\t\t{\n\t\t\t.init_state\t= true,\n\t\t\t.key\t\t= &base_old_true_key,\n\t\t\t.test_key\t= &base_old_true_key_static_key_true,\n\t\t},\n\t\t{\n\t\t\t.init_state\t= false,\n\t\t\t.key\t\t= &base_inv_old_true_key,\n\t\t\t.test_key\t= &base_inv_old_true_key_static_key_true,\n\t\t},\n\t\t{\n\t\t\t.init_state\t= false,\n\t\t\t.key\t\t= &base_old_false_key,\n\t\t\t.test_key\t= &base_old_false_key_static_key_false,\n\t\t},\n\t\t{\n\t\t\t.init_state\t= true,\n\t\t\t.key\t\t= &base_inv_old_false_key,\n\t\t\t.test_key\t= &base_inv_old_false_key_static_key_false,\n\t\t},\n\t\t \n\t\t{\n\t\t\t.init_state\t= true,\n\t\t\t.key\t\t= &base_true_key.key,\n\t\t\t.test_key\t= &base_true_key_static_branch_likely,\n\t\t},\n\t\t{\n\t\t\t.init_state\t= true,\n\t\t\t.key\t\t= &base_true_key.key,\n\t\t\t.test_key\t= &base_true_key_static_branch_unlikely,\n\t\t},\n\t\t{\n\t\t\t.init_state\t= false,\n\t\t\t.key\t\t= &base_inv_true_key.key,\n\t\t\t.test_key\t= &base_inv_true_key_static_branch_likely,\n\t\t},\n\t\t{\n\t\t\t.init_state\t= false,\n\t\t\t.key\t\t= &base_inv_true_key.key,\n\t\t\t.test_key\t= &base_inv_true_key_static_branch_unlikely,\n\t\t},\n\t\t{\n\t\t\t.init_state\t= false,\n\t\t\t.key\t\t= &base_false_key.key,\n\t\t\t.test_key\t= &base_false_key_static_branch_likely,\n\t\t},\n\t\t{\n\t\t\t.init_state\t= false,\n\t\t\t.key\t\t= &base_false_key.key,\n\t\t\t.test_key\t= &base_false_key_static_branch_unlikely,\n\t\t},\n\t\t{\n\t\t\t.init_state\t= true,\n\t\t\t.key\t\t= &base_inv_false_key.key,\n\t\t\t.test_key\t= &base_inv_false_key_static_branch_likely,\n\t\t},\n\t\t{\n\t\t\t.init_state\t= true,\n\t\t\t.key\t\t= &base_inv_false_key.key,\n\t\t\t.test_key\t= &base_inv_false_key_static_branch_unlikely,\n\t\t},\n\t};\n\n\tsize = ARRAY_SIZE(static_key_tests);\n\n\tret = verify_keys(static_key_tests, size, false);\n\tif (ret)\n\t\tgoto out;\n\n\tinvert_keys(static_key_tests, size);\n\tret = verify_keys(static_key_tests, size, true);\n\tif (ret)\n\t\tgoto out;\n\n\tinvert_keys(static_key_tests, size);\n\tret = verify_keys(static_key_tests, size, false);\n\tif (ret)\n\t\tgoto out;\n\treturn 0;\nout:\n\treturn ret;\n}\n\nstatic void __exit test_static_key_exit(void)\n{\n}\n\nmodule_init(test_static_key_init);\nmodule_exit(test_static_key_exit);\n\nMODULE_AUTHOR(\"Jason Baron <jbaron@akamai.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}