{
  "module_name": "sg_pool.c",
  "hash_id": "4e702c3d4efb297ffc817c298d4fca118532451c07dae0b68f864f6628560259",
  "original_prompt": "Ingested from linux-6.6.14/lib/sg_pool.c",
  "human_readable_source": "\n#include <linux/init.h>\n#include <linux/scatterlist.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n\n#define SG_MEMPOOL_NR\t\tARRAY_SIZE(sg_pools)\n#define SG_MEMPOOL_SIZE\t\t2\n\nstruct sg_pool {\n\tsize_t\t\tsize;\n\tchar\t\t*name;\n\tstruct kmem_cache\t*slab;\n\tmempool_t\t*pool;\n};\n\n#define SP(x) { .size = x, \"sgpool-\" __stringify(x) }\n#if (SG_CHUNK_SIZE < 32)\n#error SG_CHUNK_SIZE is too small (must be 32 or greater)\n#endif\nstatic struct sg_pool sg_pools[] = {\n\tSP(8),\n\tSP(16),\n#if (SG_CHUNK_SIZE > 32)\n\tSP(32),\n#if (SG_CHUNK_SIZE > 64)\n\tSP(64),\n#if (SG_CHUNK_SIZE > 128)\n\tSP(128),\n#if (SG_CHUNK_SIZE > 256)\n#error SG_CHUNK_SIZE is too large (256 MAX)\n#endif\n#endif\n#endif\n#endif\n\tSP(SG_CHUNK_SIZE)\n};\n#undef SP\n\nstatic inline unsigned int sg_pool_index(unsigned short nents)\n{\n\tunsigned int index;\n\n\tBUG_ON(nents > SG_CHUNK_SIZE);\n\n\tif (nents <= 8)\n\t\tindex = 0;\n\telse\n\t\tindex = get_count_order(nents) - 3;\n\n\treturn index;\n}\n\nstatic void sg_pool_free(struct scatterlist *sgl, unsigned int nents)\n{\n\tstruct sg_pool *sgp;\n\n\tsgp = sg_pools + sg_pool_index(nents);\n\tmempool_free(sgl, sgp->pool);\n}\n\nstatic struct scatterlist *sg_pool_alloc(unsigned int nents, gfp_t gfp_mask)\n{\n\tstruct sg_pool *sgp;\n\n\tsgp = sg_pools + sg_pool_index(nents);\n\treturn mempool_alloc(sgp->pool, gfp_mask);\n}\n\n \nvoid sg_free_table_chained(struct sg_table *table,\n\t\tunsigned nents_first_chunk)\n{\n\tif (table->orig_nents <= nents_first_chunk)\n\t\treturn;\n\n\tif (nents_first_chunk == 1)\n\t\tnents_first_chunk = 0;\n\n\t__sg_free_table(table, SG_CHUNK_SIZE, nents_first_chunk, sg_pool_free,\n\t\t\ttable->orig_nents);\n}\nEXPORT_SYMBOL_GPL(sg_free_table_chained);\n\n \nint sg_alloc_table_chained(struct sg_table *table, int nents,\n\t\tstruct scatterlist *first_chunk, unsigned nents_first_chunk)\n{\n\tint ret;\n\n\tBUG_ON(!nents);\n\n\tif (first_chunk && nents_first_chunk) {\n\t\tif (nents <= nents_first_chunk) {\n\t\t\ttable->nents = table->orig_nents = nents;\n\t\t\tsg_init_table(table->sgl, nents);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t \n\tif (nents_first_chunk <= 1) {\n\t\tfirst_chunk = NULL;\n\t\tnents_first_chunk = 0;\n\t}\n\n\tret = __sg_alloc_table(table, nents, SG_CHUNK_SIZE,\n\t\t\t       first_chunk, nents_first_chunk,\n\t\t\t       GFP_ATOMIC, sg_pool_alloc);\n\tif (unlikely(ret))\n\t\tsg_free_table_chained(table, nents_first_chunk);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(sg_alloc_table_chained);\n\nstatic __init int sg_pool_init(void)\n{\n\tint i;\n\n\tfor (i = 0; i < SG_MEMPOOL_NR; i++) {\n\t\tstruct sg_pool *sgp = sg_pools + i;\n\t\tint size = sgp->size * sizeof(struct scatterlist);\n\n\t\tsgp->slab = kmem_cache_create(sgp->name, size, 0,\n\t\t\t\tSLAB_HWCACHE_ALIGN, NULL);\n\t\tif (!sgp->slab) {\n\t\t\tprintk(KERN_ERR \"SG_POOL: can't init sg slab %s\\n\",\n\t\t\t\t\tsgp->name);\n\t\t\tgoto cleanup_sdb;\n\t\t}\n\n\t\tsgp->pool = mempool_create_slab_pool(SG_MEMPOOL_SIZE,\n\t\t\t\t\t\t     sgp->slab);\n\t\tif (!sgp->pool) {\n\t\t\tprintk(KERN_ERR \"SG_POOL: can't init sg mempool %s\\n\",\n\t\t\t\t\tsgp->name);\n\t\t\tgoto cleanup_sdb;\n\t\t}\n\t}\n\n\treturn 0;\n\ncleanup_sdb:\n\tfor (i = 0; i < SG_MEMPOOL_NR; i++) {\n\t\tstruct sg_pool *sgp = sg_pools + i;\n\n\t\tmempool_destroy(sgp->pool);\n\t\tkmem_cache_destroy(sgp->slab);\n\t}\n\n\treturn -ENOMEM;\n}\n\nsubsys_initcall(sg_pool_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}