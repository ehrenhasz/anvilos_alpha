{
  "module_name": "test_meminit.c",
  "hash_id": "f039fa05f9622896929e6327aa1dbd083bbd6ff09a9af00d7f2156d68ff1ba9c",
  "original_prompt": "Ingested from linux-6.6.14/lib/test_meminit.c",
  "human_readable_source": "\n \n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n\n#define GARBAGE_INT (0x09A7BA9E)\n#define GARBAGE_BYTE (0x9E)\n\n#define REPORT_FAILURES_IN_FN() \\\n\tdo {\t\\\n\t\tif (failures)\t\\\n\t\t\tpr_info(\"%s failed %d out of %d times\\n\",\t\\\n\t\t\t\t__func__, failures, num_tests);\t\t\\\n\t\telse\t\t\\\n\t\t\tpr_info(\"all %d tests in %s passed\\n\",\t\t\\\n\t\t\t\tnum_tests, __func__);\t\t\t\\\n\t} while (0)\n\n \nstatic int __init count_nonzero_bytes(void *ptr, size_t size)\n{\n\tint i, ret = 0;\n\tunsigned char *p = (unsigned char *)ptr;\n\n\tfor (i = 0; i < size; i++)\n\t\tif (p[i])\n\t\t\tret++;\n\treturn ret;\n}\n\n \nstatic void __init fill_with_garbage_skip(void *ptr, int size, size_t skip)\n{\n\tunsigned int *p = (unsigned int *)((char *)ptr + skip);\n\tint i = 0;\n\n\tWARN_ON(skip > size);\n\tsize -= skip;\n\n\twhile (size >= sizeof(*p)) {\n\t\tp[i] = GARBAGE_INT;\n\t\ti++;\n\t\tsize -= sizeof(*p);\n\t}\n\tif (size)\n\t\tmemset(&p[i], GARBAGE_BYTE, size);\n}\n\nstatic void __init fill_with_garbage(void *ptr, size_t size)\n{\n\tfill_with_garbage_skip(ptr, size, 0);\n}\n\nstatic int __init do_alloc_pages_order(int order, int *total_failures)\n{\n\tstruct page *page;\n\tvoid *buf;\n\tsize_t size = PAGE_SIZE << order;\n\n\tpage = alloc_pages(GFP_KERNEL, order);\n\tif (!page)\n\t\tgoto err;\n\tbuf = page_address(page);\n\tfill_with_garbage(buf, size);\n\t__free_pages(page, order);\n\n\tpage = alloc_pages(GFP_KERNEL, order);\n\tif (!page)\n\t\tgoto err;\n\tbuf = page_address(page);\n\tif (count_nonzero_bytes(buf, size))\n\t\t(*total_failures)++;\n\tfill_with_garbage(buf, size);\n\t__free_pages(page, order);\n\treturn 1;\nerr:\n\t(*total_failures)++;\n\treturn 1;\n}\n\n \nstatic int __init test_pages(int *total_failures)\n{\n\tint failures = 0, num_tests = 0;\n\tint i;\n\n\tfor (i = 0; i <= MAX_ORDER; i++)\n\t\tnum_tests += do_alloc_pages_order(i, &failures);\n\n\tREPORT_FAILURES_IN_FN();\n\t*total_failures += failures;\n\treturn num_tests;\n}\n\n \nstatic int __init do_kmalloc_size(size_t size, int *total_failures)\n{\n\tvoid *buf;\n\n\tbuf = kmalloc(size, GFP_KERNEL);\n\tif (!buf)\n\t\tgoto err;\n\tfill_with_garbage(buf, size);\n\tkfree(buf);\n\n\tbuf = kmalloc(size, GFP_KERNEL);\n\tif (!buf)\n\t\tgoto err;\n\tif (count_nonzero_bytes(buf, size))\n\t\t(*total_failures)++;\n\tfill_with_garbage(buf, size);\n\tkfree(buf);\n\treturn 1;\nerr:\n\t(*total_failures)++;\n\treturn 1;\n}\n\n \nstatic int __init do_vmalloc_size(size_t size, int *total_failures)\n{\n\tvoid *buf;\n\n\tbuf = vmalloc(size);\n\tif (!buf)\n\t\tgoto err;\n\tfill_with_garbage(buf, size);\n\tvfree(buf);\n\n\tbuf = vmalloc(size);\n\tif (!buf)\n\t\tgoto err;\n\tif (count_nonzero_bytes(buf, size))\n\t\t(*total_failures)++;\n\tfill_with_garbage(buf, size);\n\tvfree(buf);\n\treturn 1;\nerr:\n\t(*total_failures)++;\n\treturn 1;\n}\n\n \nstatic int __init test_kvmalloc(int *total_failures)\n{\n\tint failures = 0, num_tests = 0;\n\tint i, size;\n\n\tfor (i = 0; i < 20; i++) {\n\t\tsize = 1 << i;\n\t\tnum_tests += do_kmalloc_size(size, &failures);\n\t\tnum_tests += do_vmalloc_size(size, &failures);\n\t}\n\n\tREPORT_FAILURES_IN_FN();\n\t*total_failures += failures;\n\treturn num_tests;\n}\n\n#define CTOR_BYTES (sizeof(unsigned int))\n#define CTOR_PATTERN (0x41414141)\n \nstatic void test_ctor(void *obj)\n{\n\t*(unsigned int *)obj = CTOR_PATTERN;\n}\n\n \nstatic bool __init check_buf(void *buf, int size, bool want_ctor,\n\t\t\t     bool want_rcu, bool want_zero)\n{\n\tint bytes;\n\tbool fail = false;\n\n\tbytes = count_nonzero_bytes(buf, size);\n\tWARN_ON(want_ctor && want_zero);\n\tif (want_zero)\n\t\treturn bytes;\n\tif (want_ctor) {\n\t\tif (*(unsigned int *)buf != CTOR_PATTERN)\n\t\t\tfail = 1;\n\t} else {\n\t\tif (bytes)\n\t\t\tfail = !want_rcu;\n\t}\n\treturn fail;\n}\n\n#define BULK_SIZE 100\nstatic void *bulk_array[BULK_SIZE];\n\n \nstatic int __init do_kmem_cache_size(size_t size, bool want_ctor,\n\t\t\t\t     bool want_rcu, bool want_zero,\n\t\t\t\t     int *total_failures)\n{\n\tstruct kmem_cache *c;\n\tint iter;\n\tbool fail = false;\n\tgfp_t alloc_mask = GFP_KERNEL | (want_zero ? __GFP_ZERO : 0);\n\tvoid *buf, *buf_copy;\n\n\tc = kmem_cache_create(\"test_cache\", size, 1,\n\t\t\t      want_rcu ? SLAB_TYPESAFE_BY_RCU : 0,\n\t\t\t      want_ctor ? test_ctor : NULL);\n\tfor (iter = 0; iter < 10; iter++) {\n\t\t \n\t\tif (!want_rcu && !want_ctor) {\n\t\t\tint ret;\n\n\t\t\tret = kmem_cache_alloc_bulk(c, alloc_mask, BULK_SIZE, bulk_array);\n\t\t\tif (!ret) {\n\t\t\t\tfail = true;\n\t\t\t} else {\n\t\t\t\tint i;\n\t\t\t\tfor (i = 0; i < ret; i++)\n\t\t\t\t\tfail |= check_buf(bulk_array[i], size, want_ctor, want_rcu, want_zero);\n\t\t\t\tkmem_cache_free_bulk(c, ret, bulk_array);\n\t\t\t}\n\t\t}\n\n\t\tbuf = kmem_cache_alloc(c, alloc_mask);\n\t\t \n\t\tfail |= check_buf(buf, size, want_ctor, want_rcu, want_zero);\n\t\tfill_with_garbage_skip(buf, size, want_ctor ? CTOR_BYTES : 0);\n\n\t\tif (!want_rcu) {\n\t\t\tkmem_cache_free(c, buf);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\trcu_read_lock();\n\t\t \n\t\tbuf_copy = kmalloc(size, GFP_ATOMIC);\n\t\tif (buf_copy)\n\t\t\tmemcpy(buf_copy, buf, size);\n\n\t\tkmem_cache_free(c, buf);\n\t\t \n\t\tfail |= check_buf(buf, size, want_ctor, want_rcu,\n\t\t\t\t  false);\n\t\tif (buf_copy) {\n\t\t\tfail |= (bool)memcmp(buf, buf_copy, size);\n\t\t\tkfree(buf_copy);\n\t\t}\n\t\trcu_read_unlock();\n\t}\n\tkmem_cache_destroy(c);\n\n\t*total_failures += fail;\n\treturn 1;\n}\n\n \nstatic int __init do_kmem_cache_rcu_persistent(int size, int *total_failures)\n{\n\tstruct kmem_cache *c;\n\tvoid *buf, *buf_contents, *saved_ptr;\n\tvoid **used_objects;\n\tint i, iter, maxiter = 1024;\n\tbool fail = false;\n\n\tc = kmem_cache_create(\"test_cache\", size, size, SLAB_TYPESAFE_BY_RCU,\n\t\t\t      NULL);\n\tbuf = kmem_cache_alloc(c, GFP_KERNEL);\n\tif (!buf)\n\t\tgoto out;\n\tsaved_ptr = buf;\n\tfill_with_garbage(buf, size);\n\tbuf_contents = kmalloc(size, GFP_KERNEL);\n\tif (!buf_contents) {\n\t\tkmem_cache_free(c, buf);\n\t\tgoto out;\n\t}\n\tused_objects = kmalloc_array(maxiter, sizeof(void *), GFP_KERNEL);\n\tif (!used_objects) {\n\t\tkmem_cache_free(c, buf);\n\t\tkfree(buf_contents);\n\t\tgoto out;\n\t}\n\tmemcpy(buf_contents, buf, size);\n\tkmem_cache_free(c, buf);\n\t \n\tfor (iter = 0; iter < maxiter; iter++) {\n\t\tbuf = kmem_cache_alloc(c, GFP_KERNEL);\n\t\tused_objects[iter] = buf;\n\t\tif (buf == saved_ptr) {\n\t\t\tfail = memcmp(buf_contents, buf, size);\n\t\t\tfor (i = 0; i <= iter; i++)\n\t\t\t\tkmem_cache_free(c, used_objects[i]);\n\t\t\tgoto free_out;\n\t\t}\n\t}\n\n\tfor (iter = 0; iter < maxiter; iter++)\n\t\tkmem_cache_free(c, used_objects[iter]);\n\nfree_out:\n\tkfree(buf_contents);\n\tkfree(used_objects);\nout:\n\tkmem_cache_destroy(c);\n\t*total_failures += fail;\n\treturn 1;\n}\n\nstatic int __init do_kmem_cache_size_bulk(int size, int *total_failures)\n{\n\tstruct kmem_cache *c;\n\tint i, iter, maxiter = 1024;\n\tint num, bytes;\n\tbool fail = false;\n\tvoid *objects[10];\n\n\tc = kmem_cache_create(\"test_cache\", size, size, 0, NULL);\n\tfor (iter = 0; (iter < maxiter) && !fail; iter++) {\n\t\tnum = kmem_cache_alloc_bulk(c, GFP_KERNEL, ARRAY_SIZE(objects),\n\t\t\t\t\t    objects);\n\t\tfor (i = 0; i < num; i++) {\n\t\t\tbytes = count_nonzero_bytes(objects[i], size);\n\t\t\tif (bytes)\n\t\t\t\tfail = true;\n\t\t\tfill_with_garbage(objects[i], size);\n\t\t}\n\n\t\tif (num)\n\t\t\tkmem_cache_free_bulk(c, num, objects);\n\t}\n\tkmem_cache_destroy(c);\n\t*total_failures += fail;\n\treturn 1;\n}\n\n \nstatic int __init test_kmemcache(int *total_failures)\n{\n\tint failures = 0, num_tests = 0;\n\tint i, flags, size;\n\tbool ctor, rcu, zero;\n\n\tfor (i = 0; i < 10; i++) {\n\t\tsize = 8 << i;\n\t\tfor (flags = 0; flags < 8; flags++) {\n\t\t\tctor = flags & 1;\n\t\t\trcu = flags & 2;\n\t\t\tzero = flags & 4;\n\t\t\tif (ctor & zero)\n\t\t\t\tcontinue;\n\t\t\tnum_tests += do_kmem_cache_size(size, ctor, rcu, zero,\n\t\t\t\t\t\t\t&failures);\n\t\t}\n\t\tnum_tests += do_kmem_cache_size_bulk(size, &failures);\n\t}\n\tREPORT_FAILURES_IN_FN();\n\t*total_failures += failures;\n\treturn num_tests;\n}\n\n \nstatic int __init test_rcu_persistent(int *total_failures)\n{\n\tint failures = 0, num_tests = 0;\n\tint i, size;\n\n\tfor (i = 0; i < 10; i++) {\n\t\tsize = 8 << i;\n\t\tnum_tests += do_kmem_cache_rcu_persistent(size, &failures);\n\t}\n\tREPORT_FAILURES_IN_FN();\n\t*total_failures += failures;\n\treturn num_tests;\n}\n\n \nstatic int __init test_meminit_init(void)\n{\n\tint failures = 0, num_tests = 0;\n\n\tnum_tests += test_pages(&failures);\n\tnum_tests += test_kvmalloc(&failures);\n\tnum_tests += test_kmemcache(&failures);\n\tnum_tests += test_rcu_persistent(&failures);\n\n\tif (failures == 0)\n\t\tpr_info(\"all %d tests passed!\\n\", num_tests);\n\telse\n\t\tpr_info(\"failures: %d out of %d\\n\", failures, num_tests);\n\n\treturn failures ? -EINVAL : 0;\n}\nmodule_init(test_meminit_init);\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}