{
  "module_name": "executor.c",
  "hash_id": "ace66d1878f6bf4f70b89e70fbfaade57d632680b2d50142dc7913e030dcb8b2",
  "original_prompt": "Ingested from linux-6.6.14/lib/kunit/executor.c",
  "human_readable_source": "\n\n#include <linux/reboot.h>\n#include <kunit/test.h>\n#include <kunit/attributes.h>\n#include <linux/glob.h>\n#include <linux/moduleparam.h>\n\n \nextern struct kunit_suite * const __kunit_suites_start[];\nextern struct kunit_suite * const __kunit_suites_end[];\n\nstatic char *action_param;\n\nmodule_param_named(action, action_param, charp, 0400);\nMODULE_PARM_DESC(action,\n\t\t \"Changes KUnit executor behavior, valid values are:\\n\"\n\t\t \"<none>: run the tests like normal\\n\"\n\t\t \"'list' to list test names instead of running them.\\n\"\n\t\t \"'list_attr' to list test names and attributes instead of running them.\\n\");\n\nconst char *kunit_action(void)\n{\n\treturn action_param;\n}\n\nstatic char *filter_glob_param;\nstatic char *filter_param;\nstatic char *filter_action_param;\n\nmodule_param_named(filter_glob, filter_glob_param, charp, 0400);\nMODULE_PARM_DESC(filter_glob,\n\t\t\"Filter which KUnit test suites/tests run at boot-time, e.g. list* or list*.*del_test\");\nmodule_param_named(filter, filter_param, charp, 0400);\nMODULE_PARM_DESC(filter,\n\t\t\"Filter which KUnit test suites/tests run at boot-time using attributes, e.g. speed>slow\");\nmodule_param_named(filter_action, filter_action_param, charp, 0400);\nMODULE_PARM_DESC(filter_action,\n\t\t\"Changes behavior of filtered tests using attributes, valid values are:\\n\"\n\t\t\"<none>: do not run filtered tests as normal\\n\"\n\t\t\"'skip': skip all filtered tests instead so tests will appear in output\\n\");\n\nconst char *kunit_filter_glob(void)\n{\n\treturn filter_glob_param;\n}\n\nchar *kunit_filter(void)\n{\n\treturn filter_param;\n}\n\nchar *kunit_filter_action(void)\n{\n\treturn filter_action_param;\n}\n\n \nstruct kunit_glob_filter {\n\tchar *suite_glob;\n\tchar *test_glob;\n};\n\n \nstatic int kunit_parse_glob_filter(struct kunit_glob_filter *parsed,\n\t\t\t\t    const char *filter_glob)\n{\n\tconst int len = strlen(filter_glob);\n\tconst char *period = strchr(filter_glob, '.');\n\n\tif (!period) {\n\t\tparsed->suite_glob = kzalloc(len + 1, GFP_KERNEL);\n\t\tif (!parsed->suite_glob)\n\t\t\treturn -ENOMEM;\n\n\t\tparsed->test_glob = NULL;\n\t\tstrcpy(parsed->suite_glob, filter_glob);\n\t\treturn 0;\n\t}\n\n\tparsed->suite_glob = kzalloc(period - filter_glob + 1, GFP_KERNEL);\n\tif (!parsed->suite_glob)\n\t\treturn -ENOMEM;\n\n\tparsed->test_glob = kzalloc(len - (period - filter_glob) + 1, GFP_KERNEL);\n\tif (!parsed->test_glob) {\n\t\tkfree(parsed->suite_glob);\n\t\treturn -ENOMEM;\n\t}\n\n\tstrncpy(parsed->suite_glob, filter_glob, period - filter_glob);\n\tstrncpy(parsed->test_glob, period + 1, len - (period - filter_glob));\n\n\treturn 0;\n}\n\n \nstatic struct kunit_suite *\nkunit_filter_glob_tests(const struct kunit_suite *const suite, const char *test_glob)\n{\n\tint n = 0;\n\tstruct kunit_case *filtered, *test_case;\n\tstruct kunit_suite *copy;\n\n\tkunit_suite_for_each_test_case(suite, test_case) {\n\t\tif (!test_glob || glob_match(test_glob, test_case->name))\n\t\t\t++n;\n\t}\n\n\tif (n == 0)\n\t\treturn NULL;\n\n\tcopy = kmemdup(suite, sizeof(*copy), GFP_KERNEL);\n\tif (!copy)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tfiltered = kcalloc(n + 1, sizeof(*filtered), GFP_KERNEL);\n\tif (!filtered) {\n\t\tkfree(copy);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tn = 0;\n\tkunit_suite_for_each_test_case(suite, test_case) {\n\t\tif (!test_glob || glob_match(test_glob, test_case->name))\n\t\t\tfiltered[n++] = *test_case;\n\t}\n\n\tcopy->test_cases = filtered;\n\treturn copy;\n}\n\nvoid kunit_free_suite_set(struct kunit_suite_set suite_set)\n{\n\tstruct kunit_suite * const *suites;\n\n\tfor (suites = suite_set.start; suites < suite_set.end; suites++) {\n\t\tkfree((*suites)->test_cases);\n\t\tkfree(*suites);\n\t}\n\tkfree(suite_set.start);\n}\n\nstruct kunit_suite_set\nkunit_filter_suites(const struct kunit_suite_set *suite_set,\n\t\t    const char *filter_glob,\n\t\t    char *filters,\n\t\t    char *filter_action,\n\t\t    int *err)\n{\n\tint i, j, k;\n\tint filter_count = 0;\n\tstruct kunit_suite **copy, **copy_start, *filtered_suite, *new_filtered_suite;\n\tstruct kunit_suite_set filtered = {NULL, NULL};\n\tstruct kunit_glob_filter parsed_glob;\n\tstruct kunit_attr_filter *parsed_filters = NULL;\n\tstruct kunit_suite * const *suites;\n\n\tconst size_t max = suite_set->end - suite_set->start;\n\n\tcopy = kcalloc(max, sizeof(*filtered.start), GFP_KERNEL);\n\tif (!copy) {  \n\t\treturn filtered;\n\t}\n\tcopy_start = copy;\n\n\tif (filter_glob) {\n\t\t*err = kunit_parse_glob_filter(&parsed_glob, filter_glob);\n\t\tif (*err)\n\t\t\tgoto free_copy;\n\t}\n\n\t \n\tif (filters) {\n\t\tfilter_count = kunit_get_filter_count(filters);\n\t\tparsed_filters = kcalloc(filter_count, sizeof(*parsed_filters), GFP_KERNEL);\n\t\tif (!parsed_filters) {\n\t\t\t*err = -ENOMEM;\n\t\t\tgoto free_parsed_glob;\n\t\t}\n\t\tfor (j = 0; j < filter_count; j++)\n\t\t\tparsed_filters[j] = kunit_next_attr_filter(&filters, err);\n\t\tif (*err)\n\t\t\tgoto free_parsed_filters;\n\t}\n\n\tfor (i = 0; &suite_set->start[i] != suite_set->end; i++) {\n\t\tfiltered_suite = suite_set->start[i];\n\t\tif (filter_glob) {\n\t\t\tif (!glob_match(parsed_glob.suite_glob, filtered_suite->name))\n\t\t\t\tcontinue;\n\t\t\tfiltered_suite = kunit_filter_glob_tests(filtered_suite,\n\t\t\t\t\tparsed_glob.test_glob);\n\t\t\tif (IS_ERR(filtered_suite)) {\n\t\t\t\t*err = PTR_ERR(filtered_suite);\n\t\t\t\tgoto free_filtered_suite;\n\t\t\t}\n\t\t}\n\t\tif (filter_count > 0 && parsed_filters != NULL) {\n\t\t\tfor (k = 0; k < filter_count; k++) {\n\t\t\t\tnew_filtered_suite = kunit_filter_attr_tests(filtered_suite,\n\t\t\t\t\t\tparsed_filters[k], filter_action, err);\n\n\t\t\t\t \n\t\t\t\tif (k > 0 || filter_glob) {\n\t\t\t\t\tkfree(filtered_suite->test_cases);\n\t\t\t\t\tkfree(filtered_suite);\n\t\t\t\t}\n\n\t\t\t\tfiltered_suite = new_filtered_suite;\n\n\t\t\t\tif (*err)\n\t\t\t\t\tgoto free_filtered_suite;\n\n\t\t\t\tif (IS_ERR(filtered_suite)) {\n\t\t\t\t\t*err = PTR_ERR(filtered_suite);\n\t\t\t\t\tgoto free_filtered_suite;\n\t\t\t\t}\n\t\t\t\tif (!filtered_suite)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!filtered_suite)\n\t\t\tcontinue;\n\n\t\t*copy++ = filtered_suite;\n\t}\n\tfiltered.start = copy_start;\n\tfiltered.end = copy;\n\nfree_filtered_suite:\n\tif (*err) {\n\t\tfor (suites = copy_start; suites < copy; suites++) {\n\t\t\tkfree((*suites)->test_cases);\n\t\t\tkfree(*suites);\n\t\t}\n\t}\n\nfree_parsed_filters:\n\tif (filter_count)\n\t\tkfree(parsed_filters);\n\nfree_parsed_glob:\n\tif (filter_glob) {\n\t\tkfree(parsed_glob.suite_glob);\n\t\tkfree(parsed_glob.test_glob);\n\t}\n\nfree_copy:\n\tif (*err)\n\t\tkfree(copy_start);\n\n\treturn filtered;\n}\n\nvoid kunit_exec_run_tests(struct kunit_suite_set *suite_set, bool builtin)\n{\n\tsize_t num_suites = suite_set->end - suite_set->start;\n\n\tif (builtin || num_suites) {\n\t\tpr_info(\"KTAP version 1\\n\");\n\t\tpr_info(\"1..%zu\\n\", num_suites);\n\t}\n\n\t__kunit_test_suites_init(suite_set->start, num_suites);\n}\n\nvoid kunit_exec_list_tests(struct kunit_suite_set *suite_set, bool include_attr)\n{\n\tstruct kunit_suite * const *suites;\n\tstruct kunit_case *test_case;\n\n\t \n\tpr_info(\"KTAP version 1\\n\");\n\n\tfor (suites = suite_set->start; suites < suite_set->end; suites++) {\n\t\t \n\t\tpr_info(\"%s\\n\", (*suites)->name);\n\t\tif (include_attr)\n\t\t\tkunit_print_attr((void *)(*suites), false, 0);\n\n\t\t \n\t\tkunit_suite_for_each_test_case((*suites), test_case) {\n\t\t\tpr_info(\"%s.%s\\n\", (*suites)->name, test_case->name);\n\t\t\tif (include_attr)\n\t\t\t\tkunit_print_attr((void *)test_case, true, 0);\n\t\t}\n\t}\n}\n\n#if IS_BUILTIN(CONFIG_KUNIT)\n\nstatic char *kunit_shutdown;\ncore_param(kunit_shutdown, kunit_shutdown, charp, 0644);\n\nstatic void kunit_handle_shutdown(void)\n{\n\tif (!kunit_shutdown)\n\t\treturn;\n\n\tif (!strcmp(kunit_shutdown, \"poweroff\"))\n\t\tkernel_power_off();\n\telse if (!strcmp(kunit_shutdown, \"halt\"))\n\t\tkernel_halt();\n\telse if (!strcmp(kunit_shutdown, \"reboot\"))\n\t\tkernel_restart(NULL);\n\n}\n\nint kunit_run_all_tests(void)\n{\n\tstruct kunit_suite_set suite_set = {\n\t\t__kunit_suites_start, __kunit_suites_end,\n\t};\n\tint err = 0;\n\tif (!kunit_enabled()) {\n\t\tpr_info(\"kunit: disabled\\n\");\n\t\tgoto out;\n\t}\n\n\tif (filter_glob_param || filter_param) {\n\t\tsuite_set = kunit_filter_suites(&suite_set, filter_glob_param,\n\t\t\t\tfilter_param, filter_action_param, &err);\n\t\tif (err) {\n\t\t\tpr_err(\"kunit executor: error filtering suites: %d\\n\", err);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (!action_param)\n\t\tkunit_exec_run_tests(&suite_set, true);\n\telse if (strcmp(action_param, \"list\") == 0)\n\t\tkunit_exec_list_tests(&suite_set, false);\n\telse if (strcmp(action_param, \"list_attr\") == 0)\n\t\tkunit_exec_list_tests(&suite_set, true);\n\telse\n\t\tpr_err(\"kunit executor: unknown action '%s'\\n\", action_param);\n\n\tif (filter_glob_param || filter_param) {  \n\t\tkunit_free_suite_set(suite_set);\n\t}\n\nout:\n\tkunit_handle_shutdown();\n\treturn err;\n}\n\n#if IS_BUILTIN(CONFIG_KUNIT_TEST)\n#include \"executor_test.c\"\n#endif\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}