{
  "module_name": "executor_test.c",
  "hash_id": "e8cdd9f4009954a7c24b4b4feda8f0b2719c220fe62bd1c3292627aab16e6361",
  "original_prompt": "Ingested from linux-6.6.14/lib/kunit/executor_test.c",
  "human_readable_source": "\n \n\n#include <kunit/test.h>\n#include <kunit/attributes.h>\n\nstatic void free_suite_set_at_end(struct kunit *test, const void *to_free);\nstatic struct kunit_suite *alloc_fake_suite(struct kunit *test,\n\t\t\t\t\t    const char *suite_name,\n\t\t\t\t\t    struct kunit_case *test_cases);\n\nstatic void dummy_test(struct kunit *test) {}\n\nstatic struct kunit_case dummy_test_cases[] = {\n\t \n\t{ .name = \"test1\", .run_case = dummy_test },\n\t{ .name = \"test2\", .run_case = dummy_test },\n\t{},\n};\n\nstatic void parse_filter_test(struct kunit *test)\n{\n\tstruct kunit_glob_filter filter = {NULL, NULL};\n\n\tkunit_parse_glob_filter(&filter, \"suite\");\n\tKUNIT_EXPECT_STREQ(test, filter.suite_glob, \"suite\");\n\tKUNIT_EXPECT_FALSE(test, filter.test_glob);\n\tkfree(filter.suite_glob);\n\tkfree(filter.test_glob);\n\n\tkunit_parse_glob_filter(&filter, \"suite.test\");\n\tKUNIT_EXPECT_STREQ(test, filter.suite_glob, \"suite\");\n\tKUNIT_EXPECT_STREQ(test, filter.test_glob, \"test\");\n\tkfree(filter.suite_glob);\n\tkfree(filter.test_glob);\n}\n\nstatic void filter_suites_test(struct kunit *test)\n{\n\tstruct kunit_suite *subsuite[3] = {NULL, NULL};\n\tstruct kunit_suite_set suite_set = {\n\t\t.start = subsuite, .end = &subsuite[2],\n\t};\n\tstruct kunit_suite_set got;\n\tint err = 0;\n\n\tsubsuite[0] = alloc_fake_suite(test, \"suite1\", dummy_test_cases);\n\tsubsuite[1] = alloc_fake_suite(test, \"suite2\", dummy_test_cases);\n\n\t \n\tgot = kunit_filter_suites(&suite_set, \"suite2\", NULL, NULL, &err);\n\tKUNIT_ASSERT_NOT_ERR_OR_NULL(test, got.start);\n\tKUNIT_ASSERT_EQ(test, err, 0);\n\tfree_suite_set_at_end(test, &got);\n\n\t \n\tKUNIT_ASSERT_NOT_ERR_OR_NULL(test, got.start[0]);\n\tKUNIT_EXPECT_STREQ(test, (const char *)got.start[0]->name, \"suite2\");\n\n\t \n\tKUNIT_ASSERT_EQ(test, got.end - got.start, 1);\n}\n\nstatic void filter_suites_test_glob_test(struct kunit *test)\n{\n\tstruct kunit_suite *subsuite[3] = {NULL, NULL};\n\tstruct kunit_suite_set suite_set = {\n\t\t.start = subsuite, .end = &subsuite[2],\n\t};\n\tstruct kunit_suite_set got;\n\tint err = 0;\n\n\tsubsuite[0] = alloc_fake_suite(test, \"suite1\", dummy_test_cases);\n\tsubsuite[1] = alloc_fake_suite(test, \"suite2\", dummy_test_cases);\n\n\t \n\tgot = kunit_filter_suites(&suite_set, \"suite2.test2\", NULL, NULL, &err);\n\tKUNIT_ASSERT_NOT_ERR_OR_NULL(test, got.start);\n\tKUNIT_ASSERT_EQ(test, err, 0);\n\tfree_suite_set_at_end(test, &got);\n\n\t \n\tKUNIT_ASSERT_NOT_ERR_OR_NULL(test, got.start[0]);\n\tKUNIT_EXPECT_STREQ(test, (const char *)got.start[0]->name, \"suite2\");\n\tKUNIT_ASSERT_EQ(test, got.end - got.start, 1);\n\n\t \n\tKUNIT_ASSERT_NOT_ERR_OR_NULL(test, got.start[0]->test_cases);\n\tKUNIT_EXPECT_STREQ(test, (const char *)got.start[0]->test_cases[0].name, \"test2\");\n\tKUNIT_EXPECT_FALSE(test, got.start[0]->test_cases[1].name);\n}\n\nstatic void filter_suites_to_empty_test(struct kunit *test)\n{\n\tstruct kunit_suite *subsuite[3] = {NULL, NULL};\n\tstruct kunit_suite_set suite_set = {\n\t\t.start = subsuite, .end = &subsuite[2],\n\t};\n\tstruct kunit_suite_set got;\n\tint err = 0;\n\n\tsubsuite[0] = alloc_fake_suite(test, \"suite1\", dummy_test_cases);\n\tsubsuite[1] = alloc_fake_suite(test, \"suite2\", dummy_test_cases);\n\n\tgot = kunit_filter_suites(&suite_set, \"not_found\", NULL, NULL, &err);\n\tKUNIT_ASSERT_EQ(test, err, 0);\n\tfree_suite_set_at_end(test, &got);  \n\n\tKUNIT_EXPECT_PTR_EQ_MSG(test, got.start, got.end,\n\t\t\t\t\"should be empty to indicate no match\");\n}\n\nstatic void parse_filter_attr_test(struct kunit *test)\n{\n\tint j, filter_count;\n\tstruct kunit_attr_filter *parsed_filters;\n\tchar filters[] = \"speed>slow, module!=example\", *filter = filters;\n\tint err = 0;\n\n\tfilter_count = kunit_get_filter_count(filters);\n\tKUNIT_EXPECT_EQ(test, filter_count, 2);\n\n\tparsed_filters = kunit_kcalloc(test, filter_count, sizeof(*parsed_filters),\n\t\t\tGFP_KERNEL);\n\tfor (j = 0; j < filter_count; j++) {\n\t\tparsed_filters[j] = kunit_next_attr_filter(&filter, &err);\n\t\tKUNIT_ASSERT_EQ_MSG(test, err, 0, \"failed to parse filter '%s'\", filters[j]);\n\t}\n\n\tKUNIT_EXPECT_STREQ(test, kunit_attr_filter_name(parsed_filters[0]), \"speed\");\n\tKUNIT_EXPECT_STREQ(test, parsed_filters[0].input, \">slow\");\n\n\tKUNIT_EXPECT_STREQ(test, kunit_attr_filter_name(parsed_filters[1]), \"module\");\n\tKUNIT_EXPECT_STREQ(test, parsed_filters[1].input, \"!=example\");\n}\n\nstatic struct kunit_case dummy_attr_test_cases[] = {\n\t \n\t{ .name = \"slow\", .run_case = dummy_test, .module_name = \"dummy\",\n\t  .attr.speed = KUNIT_SPEED_SLOW },\n\t{ .name = \"normal\", .run_case = dummy_test, .module_name = \"dummy\" },\n\t{},\n};\n\nstatic void filter_attr_test(struct kunit *test)\n{\n\tstruct kunit_suite *subsuite[3] = {NULL, NULL};\n\tstruct kunit_suite_set suite_set = {\n\t\t.start = subsuite, .end = &subsuite[2],\n\t};\n\tstruct kunit_suite_set got;\n\tchar filter[] = \"speed>slow\";\n\tint err = 0;\n\n\tsubsuite[0] = alloc_fake_suite(test, \"normal_suite\", dummy_attr_test_cases);\n\tsubsuite[1] = alloc_fake_suite(test, \"slow_suite\", dummy_attr_test_cases);\n\tsubsuite[1]->attr.speed = KUNIT_SPEED_SLOW; \n\n\t \n\tgot = kunit_filter_suites(&suite_set, NULL, filter, NULL, &err);\n\tKUNIT_ASSERT_NOT_ERR_OR_NULL(test, got.start);\n\tKUNIT_ASSERT_EQ(test, err, 0);\n\tfree_suite_set_at_end(test, &got);\n\n\t \n\tKUNIT_ASSERT_NOT_ERR_OR_NULL(test, got.start[0]);\n\tKUNIT_EXPECT_STREQ(test, got.start[0]->name, \"normal_suite\");\n\tKUNIT_ASSERT_EQ(test, got.end - got.start, 1);\n\n\t \n\tKUNIT_ASSERT_NOT_ERR_OR_NULL(test, got.start[0]->test_cases);\n\tKUNIT_EXPECT_STREQ(test, got.start[0]->test_cases[0].name, \"normal\");\n\tKUNIT_EXPECT_FALSE(test, got.start[0]->test_cases[1].name);\n}\n\nstatic void filter_attr_empty_test(struct kunit *test)\n{\n\tstruct kunit_suite *subsuite[3] = {NULL, NULL};\n\tstruct kunit_suite_set suite_set = {\n\t\t.start = subsuite, .end = &subsuite[2],\n\t};\n\tstruct kunit_suite_set got;\n\tchar filter[] = \"module!=dummy\";\n\tint err = 0;\n\n\tsubsuite[0] = alloc_fake_suite(test, \"suite1\", dummy_attr_test_cases);\n\tsubsuite[1] = alloc_fake_suite(test, \"suite2\", dummy_attr_test_cases);\n\n\tgot = kunit_filter_suites(&suite_set, NULL, filter, NULL, &err);\n\tKUNIT_ASSERT_EQ(test, err, 0);\n\tfree_suite_set_at_end(test, &got);  \n\n\tKUNIT_EXPECT_PTR_EQ_MSG(test, got.start, got.end,\n\t\t\t\t\"should be empty to indicate no match\");\n}\n\nstatic void filter_attr_skip_test(struct kunit *test)\n{\n\tstruct kunit_suite *subsuite[2] = {NULL};\n\tstruct kunit_suite_set suite_set = {\n\t\t.start = subsuite, .end = &subsuite[1],\n\t};\n\tstruct kunit_suite_set got;\n\tchar filter[] = \"speed>slow\";\n\tint err = 0;\n\n\tsubsuite[0] = alloc_fake_suite(test, \"suite\", dummy_attr_test_cases);\n\n\t \n\tgot = kunit_filter_suites(&suite_set, NULL, filter, \"skip\", &err);\n\tKUNIT_ASSERT_NOT_ERR_OR_NULL(test, got.start);\n\tKUNIT_ASSERT_EQ(test, err, 0);\n\tfree_suite_set_at_end(test, &got);\n\n\t \n\tKUNIT_ASSERT_NOT_ERR_OR_NULL(test, got.start[0]->test_cases);\n\tKUNIT_ASSERT_EQ(test, kunit_suite_num_test_cases(got.start[0]), 2);\n\tKUNIT_EXPECT_STREQ(test, got.start[0]->test_cases[0].name, \"slow\");\n\tKUNIT_EXPECT_STREQ(test, got.start[0]->test_cases[1].name, \"normal\");\n\n\t \n\tKUNIT_EXPECT_EQ(test, got.start[0]->test_cases[0].status, KUNIT_SKIPPED);\n\tKUNIT_EXPECT_FALSE(test, got.start[0]->test_cases[1].status);\n}\n\nstatic struct kunit_case executor_test_cases[] = {\n\tKUNIT_CASE(parse_filter_test),\n\tKUNIT_CASE(filter_suites_test),\n\tKUNIT_CASE(filter_suites_test_glob_test),\n\tKUNIT_CASE(filter_suites_to_empty_test),\n\tKUNIT_CASE(parse_filter_attr_test),\n\tKUNIT_CASE(filter_attr_test),\n\tKUNIT_CASE(filter_attr_empty_test),\n\tKUNIT_CASE(filter_attr_skip_test),\n\t{}\n};\n\nstatic struct kunit_suite executor_test_suite = {\n\t.name = \"kunit_executor_test\",\n\t.test_cases = executor_test_cases,\n};\n\nkunit_test_suites(&executor_test_suite);\n\n \n\nstatic void free_suite_set(void *suite_set)\n{\n\tkunit_free_suite_set(*(struct kunit_suite_set *)suite_set);\n\tkfree(suite_set);\n}\n\n \nstatic void free_suite_set_at_end(struct kunit *test, const void *to_free)\n{\n\tstruct kunit_suite_set *free;\n\n\tif (!((struct kunit_suite_set *)to_free)->start)\n\t\treturn;\n\n\tfree = kzalloc(sizeof(struct kunit_suite_set), GFP_KERNEL);\n\t*free = *(struct kunit_suite_set *)to_free;\n\n\tkunit_add_action(test, free_suite_set, (void *)free);\n}\n\nstatic struct kunit_suite *alloc_fake_suite(struct kunit *test,\n\t\t\t\t\t    const char *suite_name,\n\t\t\t\t\t    struct kunit_case *test_cases)\n{\n\tstruct kunit_suite *suite;\n\n\t \n\tsuite = kunit_kzalloc(test, sizeof(*suite), GFP_KERNEL);\n\tstrncpy((char *)suite->name, suite_name, sizeof(suite->name) - 1);\n\tsuite->test_cases = test_cases;\n\n\treturn suite;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}