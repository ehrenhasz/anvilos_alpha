{
  "module_name": "kunit-test.c",
  "hash_id": "15f9cfbe223aafb207cd13b9f1724bd4ff3e24045351bbd2028202617f23d3cd",
  "original_prompt": "Ingested from linux-6.6.14/lib/kunit/kunit-test.c",
  "human_readable_source": "\n \n#include <kunit/test.h>\n#include <kunit/test-bug.h>\n\n#include \"try-catch-impl.h\"\n\nstruct kunit_try_catch_test_context {\n\tstruct kunit_try_catch *try_catch;\n\tbool function_called;\n};\n\nstatic void kunit_test_successful_try(void *data)\n{\n\tstruct kunit *test = data;\n\tstruct kunit_try_catch_test_context *ctx = test->priv;\n\n\tctx->function_called = true;\n}\n\nstatic void kunit_test_no_catch(void *data)\n{\n\tstruct kunit *test = data;\n\n\tKUNIT_FAIL(test, \"Catch should not be called\\n\");\n}\n\nstatic void kunit_test_try_catch_successful_try_no_catch(struct kunit *test)\n{\n\tstruct kunit_try_catch_test_context *ctx = test->priv;\n\tstruct kunit_try_catch *try_catch = ctx->try_catch;\n\n\tkunit_try_catch_init(try_catch,\n\t\t\t     test,\n\t\t\t     kunit_test_successful_try,\n\t\t\t     kunit_test_no_catch);\n\tkunit_try_catch_run(try_catch, test);\n\n\tKUNIT_EXPECT_TRUE(test, ctx->function_called);\n}\n\nstatic void kunit_test_unsuccessful_try(void *data)\n{\n\tstruct kunit *test = data;\n\tstruct kunit_try_catch_test_context *ctx = test->priv;\n\tstruct kunit_try_catch *try_catch = ctx->try_catch;\n\n\tkunit_try_catch_throw(try_catch);\n\tKUNIT_FAIL(test, \"This line should never be reached\\n\");\n}\n\nstatic void kunit_test_catch(void *data)\n{\n\tstruct kunit *test = data;\n\tstruct kunit_try_catch_test_context *ctx = test->priv;\n\n\tctx->function_called = true;\n}\n\nstatic void kunit_test_try_catch_unsuccessful_try_does_catch(struct kunit *test)\n{\n\tstruct kunit_try_catch_test_context *ctx = test->priv;\n\tstruct kunit_try_catch *try_catch = ctx->try_catch;\n\n\tkunit_try_catch_init(try_catch,\n\t\t\t     test,\n\t\t\t     kunit_test_unsuccessful_try,\n\t\t\t     kunit_test_catch);\n\tkunit_try_catch_run(try_catch, test);\n\n\tKUNIT_EXPECT_TRUE(test, ctx->function_called);\n}\n\nstatic int kunit_try_catch_test_init(struct kunit *test)\n{\n\tstruct kunit_try_catch_test_context *ctx;\n\n\tctx = kunit_kzalloc(test, sizeof(*ctx), GFP_KERNEL);\n\tKUNIT_ASSERT_NOT_ERR_OR_NULL(test, ctx);\n\ttest->priv = ctx;\n\n\tctx->try_catch = kunit_kmalloc(test,\n\t\t\t\t       sizeof(*ctx->try_catch),\n\t\t\t\t       GFP_KERNEL);\n\tKUNIT_ASSERT_NOT_ERR_OR_NULL(test, ctx->try_catch);\n\n\treturn 0;\n}\n\nstatic struct kunit_case kunit_try_catch_test_cases[] = {\n\tKUNIT_CASE(kunit_test_try_catch_successful_try_no_catch),\n\tKUNIT_CASE(kunit_test_try_catch_unsuccessful_try_does_catch),\n\t{}\n};\n\nstatic struct kunit_suite kunit_try_catch_test_suite = {\n\t.name = \"kunit-try-catch-test\",\n\t.init = kunit_try_catch_test_init,\n\t.test_cases = kunit_try_catch_test_cases,\n};\n\n \nstruct kunit_test_resource_context {\n\tstruct kunit test;\n\tbool is_resource_initialized;\n\tint allocate_order[2];\n\tint free_order[4];\n};\n\nstatic int fake_resource_init(struct kunit_resource *res, void *context)\n{\n\tstruct kunit_test_resource_context *ctx = context;\n\n\tres->data = &ctx->is_resource_initialized;\n\tctx->is_resource_initialized = true;\n\treturn 0;\n}\n\nstatic void fake_resource_free(struct kunit_resource *res)\n{\n\tbool *is_resource_initialized = res->data;\n\n\t*is_resource_initialized = false;\n}\n\nstatic void kunit_resource_test_init_resources(struct kunit *test)\n{\n\tstruct kunit_test_resource_context *ctx = test->priv;\n\n\tkunit_init_test(&ctx->test, \"testing_test_init_test\", NULL);\n\n\tKUNIT_EXPECT_TRUE(test, list_empty(&ctx->test.resources));\n}\n\nstatic void kunit_resource_test_alloc_resource(struct kunit *test)\n{\n\tstruct kunit_test_resource_context *ctx = test->priv;\n\tstruct kunit_resource *res;\n\tkunit_resource_free_t free = fake_resource_free;\n\n\tres = kunit_alloc_and_get_resource(&ctx->test,\n\t\t\t\t\t   fake_resource_init,\n\t\t\t\t\t   fake_resource_free,\n\t\t\t\t\t   GFP_KERNEL,\n\t\t\t\t\t   ctx);\n\n\tKUNIT_ASSERT_NOT_ERR_OR_NULL(test, res);\n\tKUNIT_EXPECT_PTR_EQ(test,\n\t\t\t    &ctx->is_resource_initialized,\n\t\t\t    (bool *)res->data);\n\tKUNIT_EXPECT_TRUE(test, list_is_last(&res->node, &ctx->test.resources));\n\tKUNIT_EXPECT_PTR_EQ(test, free, res->free);\n\n\tkunit_put_resource(res);\n}\n\nstatic inline bool kunit_resource_instance_match(struct kunit *test,\n\t\t\t\t\t\t struct kunit_resource *res,\n\t\t\t\t\t\t void *match_data)\n{\n\treturn res->data == match_data;\n}\n\n \nstatic void kunit_resource_test_destroy_resource(struct kunit *test)\n{\n\tstruct kunit_test_resource_context *ctx = test->priv;\n\tstruct kunit_resource *res = kunit_alloc_and_get_resource(\n\t\t\t&ctx->test,\n\t\t\tfake_resource_init,\n\t\t\tfake_resource_free,\n\t\t\tGFP_KERNEL,\n\t\t\tctx);\n\n\tkunit_put_resource(res);\n\n\tKUNIT_ASSERT_FALSE(test,\n\t\t\t   kunit_destroy_resource(&ctx->test,\n\t\t\t\t\t\t  kunit_resource_instance_match,\n\t\t\t\t\t\t  res->data));\n\n\tKUNIT_EXPECT_FALSE(test, ctx->is_resource_initialized);\n\tKUNIT_EXPECT_TRUE(test, list_empty(&ctx->test.resources));\n}\n\nstatic void kunit_resource_test_remove_resource(struct kunit *test)\n{\n\tstruct kunit_test_resource_context *ctx = test->priv;\n\tstruct kunit_resource *res = kunit_alloc_and_get_resource(\n\t\t\t&ctx->test,\n\t\t\tfake_resource_init,\n\t\t\tfake_resource_free,\n\t\t\tGFP_KERNEL,\n\t\t\tctx);\n\n\t \n\tKUNIT_EXPECT_FALSE(test, list_empty(&ctx->test.resources));\n\n\t \n\tkunit_remove_resource(test, res);\n\tKUNIT_EXPECT_TRUE(test, list_empty(&ctx->test.resources));\n\t \n\tKUNIT_EXPECT_TRUE(test, ctx->is_resource_initialized);\n\n\t \n\tkunit_remove_resource(test, res);\n\tKUNIT_EXPECT_TRUE(test, list_empty(&ctx->test.resources));\n\t \n\tKUNIT_EXPECT_TRUE(test, ctx->is_resource_initialized);\n\n\t \n\tkunit_put_resource(res);\n\tKUNIT_EXPECT_FALSE(test, ctx->is_resource_initialized);\n}\n\nstatic void kunit_resource_test_cleanup_resources(struct kunit *test)\n{\n\tint i;\n\tstruct kunit_test_resource_context *ctx = test->priv;\n\tstruct kunit_resource *resources[5];\n\n\tfor (i = 0; i < ARRAY_SIZE(resources); i++) {\n\t\tresources[i] = kunit_alloc_and_get_resource(&ctx->test,\n\t\t\t\t\t\t\t    fake_resource_init,\n\t\t\t\t\t\t\t    fake_resource_free,\n\t\t\t\t\t\t\t    GFP_KERNEL,\n\t\t\t\t\t\t\t    ctx);\n\t\tkunit_put_resource(resources[i]);\n\t}\n\n\tkunit_cleanup(&ctx->test);\n\n\tKUNIT_EXPECT_TRUE(test, list_empty(&ctx->test.resources));\n}\n\nstatic void kunit_resource_test_mark_order(int order_array[],\n\t\t\t\t\t   size_t order_size,\n\t\t\t\t\t   int key)\n{\n\tint i;\n\n\tfor (i = 0; i < order_size && order_array[i]; i++)\n\t\t;\n\n\torder_array[i] = key;\n}\n\n#define KUNIT_RESOURCE_TEST_MARK_ORDER(ctx, order_field, key)\t\t       \\\n\t\tkunit_resource_test_mark_order(ctx->order_field,\t       \\\n\t\t\t\t\t       ARRAY_SIZE(ctx->order_field),   \\\n\t\t\t\t\t       key)\n\nstatic int fake_resource_2_init(struct kunit_resource *res, void *context)\n{\n\tstruct kunit_test_resource_context *ctx = context;\n\n\tKUNIT_RESOURCE_TEST_MARK_ORDER(ctx, allocate_order, 2);\n\n\tres->data = ctx;\n\n\treturn 0;\n}\n\nstatic void fake_resource_2_free(struct kunit_resource *res)\n{\n\tstruct kunit_test_resource_context *ctx = res->data;\n\n\tKUNIT_RESOURCE_TEST_MARK_ORDER(ctx, free_order, 2);\n}\n\nstatic int fake_resource_1_init(struct kunit_resource *res, void *context)\n{\n\tstruct kunit_test_resource_context *ctx = context;\n\tstruct kunit_resource *res2;\n\n\tres2 = kunit_alloc_and_get_resource(&ctx->test,\n\t\t\t\t\t    fake_resource_2_init,\n\t\t\t\t\t    fake_resource_2_free,\n\t\t\t\t\t    GFP_KERNEL,\n\t\t\t\t\t    ctx);\n\n\tKUNIT_RESOURCE_TEST_MARK_ORDER(ctx, allocate_order, 1);\n\n\tres->data = ctx;\n\n\tkunit_put_resource(res2);\n\n\treturn 0;\n}\n\nstatic void fake_resource_1_free(struct kunit_resource *res)\n{\n\tstruct kunit_test_resource_context *ctx = res->data;\n\n\tKUNIT_RESOURCE_TEST_MARK_ORDER(ctx, free_order, 1);\n}\n\n \nstatic void kunit_resource_test_proper_free_ordering(struct kunit *test)\n{\n\tstruct kunit_test_resource_context *ctx = test->priv;\n\tstruct kunit_resource *res;\n\n\t \n\tres = kunit_alloc_and_get_resource(&ctx->test,\n\t\t\t\t\t   fake_resource_1_init,\n\t\t\t\t\t   fake_resource_1_free,\n\t\t\t\t\t   GFP_KERNEL,\n\t\t\t\t\t   ctx);\n\n\t \n\tKUNIT_EXPECT_EQ(test, ctx->allocate_order[0], 2);\n\tKUNIT_EXPECT_EQ(test, ctx->allocate_order[1], 1);\n\n\tkunit_put_resource(res);\n\n\tkunit_cleanup(&ctx->test);\n\n\t \n\tKUNIT_EXPECT_EQ(test, ctx->free_order[0], 1);\n\tKUNIT_EXPECT_EQ(test, ctx->free_order[1], 2);\n}\n\nstatic void kunit_resource_test_static(struct kunit *test)\n{\n\tstruct kunit_test_resource_context ctx;\n\tstruct kunit_resource res;\n\n\tKUNIT_EXPECT_EQ(test, kunit_add_resource(test, NULL, NULL, &res, &ctx),\n\t\t\t0);\n\n\tKUNIT_EXPECT_PTR_EQ(test, res.data, (void *)&ctx);\n\n\tkunit_cleanup(test);\n\n\tKUNIT_EXPECT_TRUE(test, list_empty(&test->resources));\n}\n\nstatic void kunit_resource_test_named(struct kunit *test)\n{\n\tstruct kunit_resource res1, res2, *found = NULL;\n\tstruct kunit_test_resource_context ctx;\n\n\tKUNIT_EXPECT_EQ(test,\n\t\t\tkunit_add_named_resource(test, NULL, NULL, &res1,\n\t\t\t\t\t\t \"resource_1\", &ctx),\n\t\t\t0);\n\tKUNIT_EXPECT_PTR_EQ(test, res1.data, (void *)&ctx);\n\n\tKUNIT_EXPECT_EQ(test,\n\t\t\tkunit_add_named_resource(test, NULL, NULL, &res1,\n\t\t\t\t\t\t \"resource_1\", &ctx),\n\t\t\t-EEXIST);\n\n\tKUNIT_EXPECT_EQ(test,\n\t\t\tkunit_add_named_resource(test, NULL, NULL, &res2,\n\t\t\t\t\t\t \"resource_2\", &ctx),\n\t\t\t0);\n\n\tfound = kunit_find_named_resource(test, \"resource_1\");\n\n\tKUNIT_EXPECT_PTR_EQ(test, found, &res1);\n\n\tif (found)\n\t\tkunit_put_resource(&res1);\n\n\tKUNIT_EXPECT_EQ(test, kunit_destroy_named_resource(test, \"resource_2\"),\n\t\t\t0);\n\n\tkunit_cleanup(test);\n\n\tKUNIT_EXPECT_TRUE(test, list_empty(&test->resources));\n}\n\nstatic void increment_int(void *ctx)\n{\n\tint *i = (int *)ctx;\n\t(*i)++;\n}\n\nstatic void kunit_resource_test_action(struct kunit *test)\n{\n\tint num_actions = 0;\n\n\tkunit_add_action(test, increment_int, &num_actions);\n\tKUNIT_EXPECT_EQ(test, num_actions, 0);\n\tkunit_cleanup(test);\n\tKUNIT_EXPECT_EQ(test, num_actions, 1);\n\n\t \n\tkunit_cleanup(test);\n\tKUNIT_EXPECT_EQ(test, num_actions, 1);\n\n\t \n\tkunit_add_action(test, increment_int, &num_actions);\n\tkunit_add_action(test, increment_int, &num_actions);\n\tkunit_cleanup(test);\n\tKUNIT_EXPECT_EQ(test, num_actions, 3);\n}\nstatic void kunit_resource_test_remove_action(struct kunit *test)\n{\n\tint num_actions = 0;\n\n\tkunit_add_action(test, increment_int, &num_actions);\n\tKUNIT_EXPECT_EQ(test, num_actions, 0);\n\n\tkunit_remove_action(test, increment_int, &num_actions);\n\tkunit_cleanup(test);\n\tKUNIT_EXPECT_EQ(test, num_actions, 0);\n}\nstatic void kunit_resource_test_release_action(struct kunit *test)\n{\n\tint num_actions = 0;\n\n\tkunit_add_action(test, increment_int, &num_actions);\n\tKUNIT_EXPECT_EQ(test, num_actions, 0);\n\t \n\tkunit_release_action(test, increment_int, &num_actions);\n\tKUNIT_EXPECT_EQ(test, num_actions, 1);\n\n\t \n\tkunit_cleanup(test);\n\tKUNIT_EXPECT_EQ(test, num_actions, 1);\n}\nstatic void action_order_1(void *ctx)\n{\n\tstruct kunit_test_resource_context *res_ctx = (struct kunit_test_resource_context *)ctx;\n\n\tKUNIT_RESOURCE_TEST_MARK_ORDER(res_ctx, free_order, 1);\n\tkunit_log(KERN_INFO, current->kunit_test, \"action_order_1\");\n}\nstatic void action_order_2(void *ctx)\n{\n\tstruct kunit_test_resource_context *res_ctx = (struct kunit_test_resource_context *)ctx;\n\n\tKUNIT_RESOURCE_TEST_MARK_ORDER(res_ctx, free_order, 2);\n\tkunit_log(KERN_INFO, current->kunit_test, \"action_order_2\");\n}\nstatic void kunit_resource_test_action_ordering(struct kunit *test)\n{\n\tstruct kunit_test_resource_context *ctx = test->priv;\n\n\tkunit_add_action(test, action_order_1, ctx);\n\tkunit_add_action(test, action_order_2, ctx);\n\tkunit_add_action(test, action_order_1, ctx);\n\tkunit_add_action(test, action_order_2, ctx);\n\tkunit_remove_action(test, action_order_1, ctx);\n\tkunit_release_action(test, action_order_2, ctx);\n\tkunit_cleanup(test);\n\n\t \n\tKUNIT_EXPECT_EQ(test, ctx->free_order[0], 2);\n\tKUNIT_EXPECT_EQ(test, ctx->free_order[1], 2);\n\tKUNIT_EXPECT_EQ(test, ctx->free_order[2], 1);\n}\n\nstatic int kunit_resource_test_init(struct kunit *test)\n{\n\tstruct kunit_test_resource_context *ctx =\n\t\t\tkzalloc(sizeof(*ctx), GFP_KERNEL);\n\n\tKUNIT_ASSERT_NOT_ERR_OR_NULL(test, ctx);\n\n\ttest->priv = ctx;\n\n\tkunit_init_test(&ctx->test, \"test_test_context\", NULL);\n\n\treturn 0;\n}\n\nstatic void kunit_resource_test_exit(struct kunit *test)\n{\n\tstruct kunit_test_resource_context *ctx = test->priv;\n\n\tkunit_cleanup(&ctx->test);\n\tkfree(ctx);\n}\n\nstatic struct kunit_case kunit_resource_test_cases[] = {\n\tKUNIT_CASE(kunit_resource_test_init_resources),\n\tKUNIT_CASE(kunit_resource_test_alloc_resource),\n\tKUNIT_CASE(kunit_resource_test_destroy_resource),\n\tKUNIT_CASE(kunit_resource_test_remove_resource),\n\tKUNIT_CASE(kunit_resource_test_cleanup_resources),\n\tKUNIT_CASE(kunit_resource_test_proper_free_ordering),\n\tKUNIT_CASE(kunit_resource_test_static),\n\tKUNIT_CASE(kunit_resource_test_named),\n\tKUNIT_CASE(kunit_resource_test_action),\n\tKUNIT_CASE(kunit_resource_test_remove_action),\n\tKUNIT_CASE(kunit_resource_test_release_action),\n\tKUNIT_CASE(kunit_resource_test_action_ordering),\n\t{}\n};\n\nstatic struct kunit_suite kunit_resource_test_suite = {\n\t.name = \"kunit-resource-test\",\n\t.init = kunit_resource_test_init,\n\t.exit = kunit_resource_test_exit,\n\t.test_cases = kunit_resource_test_cases,\n};\n\nstatic void kunit_log_test(struct kunit *test)\n{\n\tstruct kunit_suite suite;\n\n\tsuite.log = kunit_kzalloc(test, KUNIT_LOG_SIZE, GFP_KERNEL);\n\tKUNIT_ASSERT_NOT_ERR_OR_NULL(test, suite.log);\n\n\tkunit_log(KERN_INFO, test, \"put this in log.\");\n\tkunit_log(KERN_INFO, test, \"this too.\");\n\tkunit_log(KERN_INFO, &suite, \"add to suite log.\");\n\tkunit_log(KERN_INFO, &suite, \"along with this.\");\n\n#ifdef CONFIG_KUNIT_DEBUGFS\n\tKUNIT_EXPECT_NOT_ERR_OR_NULL(test,\n\t\t\t\t     strstr(test->log, \"put this in log.\"));\n\tKUNIT_EXPECT_NOT_ERR_OR_NULL(test,\n\t\t\t\t     strstr(test->log, \"this too.\"));\n\tKUNIT_EXPECT_NOT_ERR_OR_NULL(test,\n\t\t\t\t     strstr(suite.log, \"add to suite log.\"));\n\tKUNIT_EXPECT_NOT_ERR_OR_NULL(test,\n\t\t\t\t     strstr(suite.log, \"along with this.\"));\n#else\n\tKUNIT_EXPECT_NULL(test, test->log);\n#endif\n}\n\nstatic void kunit_log_newline_test(struct kunit *test)\n{\n\tkunit_info(test, \"Add newline\\n\");\n\tif (test->log) {\n\t\tKUNIT_ASSERT_NOT_NULL_MSG(test, strstr(test->log, \"Add newline\\n\"),\n\t\t\t\"Missing log line, full log:\\n%s\", test->log);\n\t\tKUNIT_EXPECT_NULL(test, strstr(test->log, \"Add newline\\n\\n\"));\n\t} else {\n\t\tkunit_skip(test, \"only useful when debugfs is enabled\");\n\t}\n}\n\nstatic struct kunit_case kunit_log_test_cases[] = {\n\tKUNIT_CASE(kunit_log_test),\n\tKUNIT_CASE(kunit_log_newline_test),\n\t{}\n};\n\nstatic struct kunit_suite kunit_log_test_suite = {\n\t.name = \"kunit-log-test\",\n\t.test_cases = kunit_log_test_cases,\n};\n\nstatic void kunit_status_set_failure_test(struct kunit *test)\n{\n\tstruct kunit fake;\n\n\tkunit_init_test(&fake, \"fake test\", NULL);\n\n\tKUNIT_EXPECT_EQ(test, fake.status, (enum kunit_status)KUNIT_SUCCESS);\n\tkunit_set_failure(&fake);\n\tKUNIT_EXPECT_EQ(test, fake.status, (enum kunit_status)KUNIT_FAILURE);\n}\n\nstatic void kunit_status_mark_skipped_test(struct kunit *test)\n{\n\tstruct kunit fake;\n\n\tkunit_init_test(&fake, \"fake test\", NULL);\n\n\t \n\tKUNIT_EXPECT_EQ(test, fake.status, KUNIT_SUCCESS);\n\tKUNIT_EXPECT_STREQ(test, fake.status_comment, \"\");\n\n\t \n\tkunit_mark_skipped(&fake, \"Accepts format string: %s\", \"YES\");\n\n\t \n\tKUNIT_EXPECT_EQ(test, fake.status, (enum kunit_status)KUNIT_SKIPPED);\n\tKUNIT_EXPECT_STREQ(test, fake.status_comment, \"Accepts format string: YES\");\n}\n\nstatic struct kunit_case kunit_status_test_cases[] = {\n\tKUNIT_CASE(kunit_status_set_failure_test),\n\tKUNIT_CASE(kunit_status_mark_skipped_test),\n\t{}\n};\n\nstatic struct kunit_suite kunit_status_test_suite = {\n\t.name = \"kunit_status\",\n\t.test_cases = kunit_status_test_cases,\n};\n\nstatic void kunit_current_test(struct kunit *test)\n{\n\t \n\tKUNIT_EXPECT_PTR_EQ(test, test, current->kunit_test);\n\tKUNIT_EXPECT_PTR_EQ(test, test, kunit_get_current_test());\n}\n\nstatic void kunit_current_fail_test(struct kunit *test)\n{\n\tstruct kunit fake;\n\n\tkunit_init_test(&fake, \"fake test\", NULL);\n\tKUNIT_EXPECT_EQ(test, fake.status, KUNIT_SUCCESS);\n\n\t \n\tcurrent->kunit_test = &fake;\n\n\tkunit_fail_current_test(\"This should make `fake` test fail.\");\n\tKUNIT_EXPECT_EQ(test, fake.status, (enum kunit_status)KUNIT_FAILURE);\n\tkunit_cleanup(&fake);\n\n\t \n\tcurrent->kunit_test = test;\n}\n\nstatic struct kunit_case kunit_current_test_cases[] = {\n\tKUNIT_CASE(kunit_current_test),\n\tKUNIT_CASE(kunit_current_fail_test),\n\t{}\n};\n\nstatic struct kunit_suite kunit_current_test_suite = {\n\t.name = \"kunit_current\",\n\t.test_cases = kunit_current_test_cases,\n};\n\nkunit_test_suites(&kunit_try_catch_test_suite, &kunit_resource_test_suite,\n\t\t  &kunit_log_test_suite, &kunit_status_test_suite,\n\t\t  &kunit_current_test_suite);\n\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}