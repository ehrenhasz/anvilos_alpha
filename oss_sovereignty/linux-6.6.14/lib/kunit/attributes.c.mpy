{
  "module_name": "attributes.c",
  "hash_id": "317c212498458bf0bafacc57d4f7031806936d72c149803ceb53d1e569bd8ca3",
  "original_prompt": "Ingested from linux-6.6.14/lib/kunit/attributes.c",
  "human_readable_source": "\n \n\n#include <kunit/test.h>\n#include <kunit/attributes.h>\n\n \nenum print_ops {\n\tPRINT_ALWAYS,\n\tPRINT_SUITE,\n\tPRINT_NEVER,\n};\n\n \nstruct kunit_attr {\n\tconst char *name;\n\tvoid *(*get_attr)(void *test_or_suite, bool is_test);\n\tconst char *(*to_string)(void *attr, bool *to_free);\n\tint (*filter)(void *attr, const char *input, int *err);\n\tvoid *attr_default;\n\tenum print_ops print;\n};\n\n \n\nstatic const char * const speed_str_list[] = {\"unset\", \"very_slow\", \"slow\", \"normal\"};\n\n \n\nstatic const char *attr_enum_to_string(void *attr, const char * const str_list[], bool *to_free)\n{\n\tlong val = (long)attr;\n\n\t*to_free = false;\n\tif (!val)\n\t\treturn NULL;\n\treturn str_list[val];\n}\n\nstatic const char *attr_speed_to_string(void *attr, bool *to_free)\n{\n\treturn attr_enum_to_string(attr, speed_str_list, to_free);\n}\n\nstatic const char *attr_string_to_string(void *attr, bool *to_free)\n{\n\t*to_free = false;\n\treturn (char *) attr;\n}\n\n \n\nstatic const char op_list[] = \"<>!=\";\n\n \nstatic int int_filter(long val, const char *op, int input, int *err)\n{\n\tif (!strncmp(op, \"<=\", 2))\n\t\treturn (val <= input);\n\telse if (!strncmp(op, \">=\", 2))\n\t\treturn (val >= input);\n\telse if (!strncmp(op, \"!=\", 2))\n\t\treturn (val != input);\n\telse if (!strncmp(op, \">\", 1))\n\t\treturn (val > input);\n\telse if (!strncmp(op, \"<\", 1))\n\t\treturn (val < input);\n\telse if (!strncmp(op, \"=\", 1))\n\t\treturn (val == input);\n\t*err = -EINVAL;\n\tpr_err(\"kunit executor: invalid filter operation: %s\\n\", op);\n\treturn false;\n}\n\n \nstatic int attr_enum_filter(void *attr, const char *input, int *err,\n\t\tconst char * const str_list[], int max)\n{\n\tint i, j, input_int = -1;\n\tlong test_val = (long)attr;\n\tconst char *input_val = NULL;\n\n\tfor (i = 0; input[i]; i++) {\n\t\tif (!strchr(op_list, input[i])) {\n\t\t\tinput_val = input + i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!input_val) {\n\t\t*err = -EINVAL;\n\t\tpr_err(\"kunit executor: filter value not found: %s\\n\", input);\n\t\treturn false;\n\t}\n\n\tfor (j = 0; j <= max; j++) {\n\t\tif (!strcmp(input_val, str_list[j]))\n\t\t\tinput_int = j;\n\t}\n\n\tif (input_int < 0) {\n\t\t*err = -EINVAL;\n\t\tpr_err(\"kunit executor: invalid filter input: %s\\n\", input);\n\t\treturn false;\n\t}\n\n\treturn int_filter(test_val, input, input_int, err);\n}\n\nstatic int attr_speed_filter(void *attr, const char *input, int *err)\n{\n\treturn attr_enum_filter(attr, input, err, speed_str_list, KUNIT_SPEED_MAX);\n}\n\n \nstatic int attr_string_filter(void *attr, const char *input, int *err)\n{\n\tchar *str = attr;\n\n\tif (!strncmp(input, \"<\", 1)) {\n\t\t*err = -EINVAL;\n\t\tpr_err(\"kunit executor: invalid filter input: %s\\n\", input);\n\t\treturn false;\n\t} else if (!strncmp(input, \">\", 1)) {\n\t\t*err = -EINVAL;\n\t\tpr_err(\"kunit executor: invalid filter input: %s\\n\", input);\n\t\treturn false;\n\t} else if (!strncmp(input, \"!=\", 2)) {\n\t\treturn (strcmp(input + 2, str) != 0);\n\t} else if (!strncmp(input, \"=\", 1)) {\n\t\treturn (strcmp(input + 1, str) == 0);\n\t}\n\t*err = -EINVAL;\n\tpr_err(\"kunit executor: invalid filter operation: %s\\n\", input);\n\treturn false;\n}\n\n\n \n\nstatic void *attr_speed_get(void *test_or_suite, bool is_test)\n{\n\tstruct kunit_suite *suite = is_test ? NULL : test_or_suite;\n\tstruct kunit_case *test = is_test ? test_or_suite : NULL;\n\n\tif (test)\n\t\treturn ((void *) test->attr.speed);\n\telse\n\t\treturn ((void *) suite->attr.speed);\n}\n\nstatic void *attr_module_get(void *test_or_suite, bool is_test)\n{\n\tstruct kunit_suite *suite = is_test ? NULL : test_or_suite;\n\tstruct kunit_case *test = is_test ? test_or_suite : NULL;\n\n\t\n\tif (test)\n\t\treturn ((void *) test->module_name);\n\telse if (kunit_suite_num_test_cases(suite) > 0)\n\t\treturn ((void *) suite->test_cases[0].module_name);\n\telse\n\t\treturn (void *) \"\";\n}\n\n \n\nstatic struct kunit_attr kunit_attr_list[] = {\n\t{\n\t\t.name = \"speed\",\n\t\t.get_attr = attr_speed_get,\n\t\t.to_string = attr_speed_to_string,\n\t\t.filter = attr_speed_filter,\n\t\t.attr_default = (void *)KUNIT_SPEED_NORMAL,\n\t\t.print = PRINT_ALWAYS,\n\t},\n\t{\n\t\t.name = \"module\",\n\t\t.get_attr = attr_module_get,\n\t\t.to_string = attr_string_to_string,\n\t\t.filter = attr_string_filter,\n\t\t.attr_default = (void *)\"\",\n\t\t.print = PRINT_SUITE,\n\t}\n};\n\n \n\nconst char *kunit_attr_filter_name(struct kunit_attr_filter filter)\n{\n\treturn filter.attr->name;\n}\n\nvoid kunit_print_attr(void *test_or_suite, bool is_test, unsigned int test_level)\n{\n\tint i;\n\tbool to_free = false;\n\tvoid *attr;\n\tconst char *attr_name, *attr_str;\n\tstruct kunit_suite *suite = is_test ? NULL : test_or_suite;\n\tstruct kunit_case *test = is_test ? test_or_suite : NULL;\n\n\tfor (i = 0; i < ARRAY_SIZE(kunit_attr_list); i++) {\n\t\tif (kunit_attr_list[i].print == PRINT_NEVER ||\n\t\t\t\t(test && kunit_attr_list[i].print == PRINT_SUITE))\n\t\t\tcontinue;\n\t\tattr = kunit_attr_list[i].get_attr(test_or_suite, is_test);\n\t\tif (attr) {\n\t\t\tattr_name = kunit_attr_list[i].name;\n\t\t\tattr_str = kunit_attr_list[i].to_string(attr, &to_free);\n\t\t\tif (test) {\n\t\t\t\tkunit_log(KERN_INFO, test, \"%*s# %s.%s: %s\",\n\t\t\t\t\tKUNIT_INDENT_LEN * test_level, \"\", test->name,\n\t\t\t\t\tattr_name, attr_str);\n\t\t\t} else {\n\t\t\t\tkunit_log(KERN_INFO, suite, \"%*s# %s: %s\",\n\t\t\t\t\tKUNIT_INDENT_LEN * test_level, \"\", attr_name, attr_str);\n\t\t\t}\n\n\t\t\t \n\t\t\tif (to_free)\n\t\t\t\tkfree(attr_str);\n\t\t}\n\t}\n}\n\n \n\nint kunit_get_filter_count(char *input)\n{\n\tint i, comma_index = 0, count = 0;\n\n\tfor (i = 0; input[i]; i++) {\n\t\tif (input[i] == ',') {\n\t\t\tif ((i - comma_index) > 1)\n\t\t\t\tcount++;\n\t\t\tcomma_index = i;\n\t\t}\n\t}\n\tif ((i - comma_index) > 0)\n\t\tcount++;\n\treturn count;\n}\n\nstruct kunit_attr_filter kunit_next_attr_filter(char **filters, int *err)\n{\n\tstruct kunit_attr_filter filter = {};\n\tint i, j, comma_index = 0, new_start_index = 0;\n\tint op_index = -1, attr_index = -1;\n\tchar op;\n\tchar *input = *filters;\n\n\t \n\tfor (i = 0; input[i]; i++) {\n\t\tif (op_index < 0 && strchr(op_list, input[i])) {\n\t\t\top_index = i;\n\t\t} else if (!comma_index && input[i] == ',') {\n\t\t\tcomma_index = i;\n\t\t} else if (comma_index && input[i] != ' ') {\n\t\t\tnew_start_index = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (op_index <= 0) {\n\t\t*err = -EINVAL;\n\t\tpr_err(\"kunit executor: filter operation not found: %s\\n\", input);\n\t\treturn filter;\n\t}\n\n\t \n\top = input[op_index];\n\tinput[op_index] = '\\0';\n\n\t \n\tfor (j = 0; j < ARRAY_SIZE(kunit_attr_list); j++) {\n\t\tif (!strcmp(input, kunit_attr_list[j].name)) {\n\t\t\tattr_index = j;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tinput[op_index] = op;\n\n\tif (attr_index < 0) {\n\t\t*err = -EINVAL;\n\t\tpr_err(\"kunit executor: attribute not found: %s\\n\", input);\n\t} else {\n\t\tfilter.attr = &kunit_attr_list[attr_index];\n\t}\n\n\tif (comma_index > 0) {\n\t\tinput[comma_index] = '\\0';\n\t\tfilter.input = input + op_index;\n\t\tinput = input + new_start_index;\n\t} else {\n\t\tfilter.input = input + op_index;\n\t\tinput = NULL;\n\t}\n\n\t*filters = input;\n\n\treturn filter;\n}\n\nstruct kunit_suite *kunit_filter_attr_tests(const struct kunit_suite *const suite,\n\t\tstruct kunit_attr_filter filter, char *action, int *err)\n{\n\tint n = 0;\n\tstruct kunit_case *filtered, *test_case;\n\tstruct kunit_suite *copy;\n\tvoid *suite_val, *test_val;\n\tbool suite_result, test_result, default_result, result;\n\n\t \n\tcopy = kmemdup(suite, sizeof(*copy), GFP_KERNEL);\n\tif (!copy)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tkunit_suite_for_each_test_case(suite, test_case) { n++; }\n\n\tfiltered = kcalloc(n + 1, sizeof(*filtered), GFP_KERNEL);\n\tif (!filtered) {\n\t\tkfree(copy);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tn = 0;\n\n\t \n\tdefault_result = filter.attr->filter(filter.attr->attr_default, filter.input, err);\n\tif (*err)\n\t\tgoto err;\n\n\t \n\tsuite_val = filter.attr->get_attr((void *)suite, false);\n\tsuite_result = filter.attr->filter(suite_val, filter.input, err);\n\tif (*err)\n\t\tgoto err;\n\n\t \n\tkunit_suite_for_each_test_case(suite, test_case) {\n\t\ttest_val = filter.attr->get_attr((void *) test_case, true);\n\t\ttest_result = filter.attr->filter(filter.attr->get_attr(test_case, true),\n\t\t\t\tfilter.input, err);\n\t\tif (*err)\n\t\t\tgoto err;\n\n\t\t \n\t\tresult = false;\n\t\tif (test_val) {\n\t\t\tif (test_result)\n\t\t\t\tresult = true;\n\t\t} else if (suite_val) {\n\t\t\tif (suite_result)\n\t\t\t\tresult = true;\n\t\t} else if (default_result) {\n\t\t\tresult = true;\n\t\t}\n\n\t\tif (result) {\n\t\t\tfiltered[n++] = *test_case;\n\t\t} else if (action && strcmp(action, \"skip\") == 0) {\n\t\t\ttest_case->status = KUNIT_SKIPPED;\n\t\t\tfiltered[n++] = *test_case;\n\t\t}\n\t}\n\nerr:\n\tif (n == 0 || *err) {\n\t\tkfree(copy);\n\t\tkfree(filtered);\n\t\treturn NULL;\n\t}\n\n\tcopy->test_cases = filtered;\n\n\treturn copy;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}