{
  "module_name": "test.c",
  "hash_id": "0011badf0e82938872de2f00695c3ba4caeb0f7f0643684de81a765368cd6bfc",
  "original_prompt": "Ingested from linux-6.6.14/lib/kunit/test.c",
  "human_readable_source": "\n \n\n#include <kunit/resource.h>\n#include <kunit/test.h>\n#include <kunit/test-bug.h>\n#include <kunit/attributes.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/panic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\n#include \"debugfs.h\"\n#include \"hooks-impl.h\"\n#include \"string-stream.h\"\n#include \"try-catch-impl.h\"\n\n \nvoid __printf(3, 4) __kunit_fail_current_test_impl(const char *file, int line, const char *fmt, ...)\n{\n\tva_list args;\n\tint len;\n\tchar *buffer;\n\n\tif (!current->kunit_test)\n\t\treturn;\n\n\tkunit_set_failure(current->kunit_test);\n\n\t \n\tva_start(args, fmt);\n\tlen = vsnprintf(NULL, 0, fmt, args) + 1;\n\tva_end(args);\n\n\tbuffer = kunit_kmalloc(current->kunit_test, len, GFP_KERNEL);\n\tif (!buffer)\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvsnprintf(buffer, len, fmt, args);\n\tva_end(args);\n\n\tkunit_err(current->kunit_test, \"%s:%d: %s\", file, line, buffer);\n\tkunit_kfree(current->kunit_test, buffer);\n}\n\n \n#ifdef CONFIG_KUNIT_DEFAULT_ENABLED\nstatic bool enable_param = true;\n#else\nstatic bool enable_param;\n#endif\nmodule_param_named(enable, enable_param, bool, 0);\nMODULE_PARM_DESC(enable, \"Enable KUnit tests\");\n\n \nstatic int kunit_stats_enabled = 1;\nmodule_param_named(stats_enabled, kunit_stats_enabled, int, 0644);\nMODULE_PARM_DESC(stats_enabled,\n\t\t  \"Print test stats: never (0), only for multiple subtests (1), or always (2)\");\n\nstruct kunit_result_stats {\n\tunsigned long passed;\n\tunsigned long skipped;\n\tunsigned long failed;\n\tunsigned long total;\n};\n\nstatic bool kunit_should_print_stats(struct kunit_result_stats stats)\n{\n\tif (kunit_stats_enabled == 0)\n\t\treturn false;\n\n\tif (kunit_stats_enabled == 2)\n\t\treturn true;\n\n\treturn (stats.total > 1);\n}\n\nstatic void kunit_print_test_stats(struct kunit *test,\n\t\t\t\t   struct kunit_result_stats stats)\n{\n\tif (!kunit_should_print_stats(stats))\n\t\treturn;\n\n\tkunit_log(KERN_INFO, test,\n\t\t  KUNIT_SUBTEST_INDENT\n\t\t  \"# %s: pass:%lu fail:%lu skip:%lu total:%lu\",\n\t\t  test->name,\n\t\t  stats.passed,\n\t\t  stats.failed,\n\t\t  stats.skipped,\n\t\t  stats.total);\n}\n\n \nstatic void kunit_log_newline(char *log)\n{\n\tint log_len, len_left;\n\n\tlog_len = strlen(log);\n\tlen_left = KUNIT_LOG_SIZE - log_len - 1;\n\n\tif (log_len > 0 && log[log_len - 1] != '\\n')\n\t\tstrncat(log, \"\\n\", len_left);\n}\n\n \nvoid kunit_log_append(char *log, const char *fmt, ...)\n{\n\tva_list args;\n\tint len, log_len, len_left;\n\n\tif (!log)\n\t\treturn;\n\n\tlog_len = strlen(log);\n\tlen_left = KUNIT_LOG_SIZE - log_len - 1;\n\tif (len_left <= 0)\n\t\treturn;\n\n\t \n\tva_start(args, fmt);\n\tlen = vsnprintf(NULL, 0, fmt, args) + 1;\n\tva_end(args);\n\n\t \n\tva_start(args, fmt);\n\tvsnprintf(log + log_len, min(len, len_left), fmt, args);\n\tva_end(args);\n\n\t \n\tkunit_log_newline(log);\n}\nEXPORT_SYMBOL_GPL(kunit_log_append);\n\nsize_t kunit_suite_num_test_cases(struct kunit_suite *suite)\n{\n\tstruct kunit_case *test_case;\n\tsize_t len = 0;\n\n\tkunit_suite_for_each_test_case(suite, test_case)\n\t\tlen++;\n\n\treturn len;\n}\nEXPORT_SYMBOL_GPL(kunit_suite_num_test_cases);\n\n \nenum {\n\tKUNIT_LEVEL_SUITE = 0,\n\tKUNIT_LEVEL_CASE,\n\tKUNIT_LEVEL_CASE_PARAM,\n};\n\nstatic void kunit_print_suite_start(struct kunit_suite *suite)\n{\n\t \n\tpr_info(KUNIT_SUBTEST_INDENT \"KTAP version 1\\n\");\n\tpr_info(KUNIT_SUBTEST_INDENT \"# Subtest: %s\\n\",\n\t\t  suite->name);\n\tkunit_print_attr((void *)suite, false, KUNIT_LEVEL_CASE);\n\tpr_info(KUNIT_SUBTEST_INDENT \"1..%zd\\n\",\n\t\t  kunit_suite_num_test_cases(suite));\n}\n\nstatic void kunit_print_ok_not_ok(struct kunit *test,\n\t\t\t\t  unsigned int test_level,\n\t\t\t\t  enum kunit_status status,\n\t\t\t\t  size_t test_number,\n\t\t\t\t  const char *description,\n\t\t\t\t  const char *directive)\n{\n\tconst char *directive_header = (status == KUNIT_SKIPPED) ? \" # SKIP \" : \"\";\n\tconst char *directive_body = (status == KUNIT_SKIPPED) ? directive : \"\";\n\n\t \n\tWARN(!test && test_level, \"suite test level can't be %u!\\n\", test_level);\n\n\t \n\tif (!test)\n\t\tpr_info(\"%s %zd %s%s%s\\n\",\n\t\t\tkunit_status_to_ok_not_ok(status),\n\t\t\ttest_number, description, directive_header,\n\t\t\tdirective_body);\n\telse\n\t\tkunit_log(KERN_INFO, test,\n\t\t\t  \"%*s%s %zd %s%s%s\",\n\t\t\t  KUNIT_INDENT_LEN * test_level, \"\",\n\t\t\t  kunit_status_to_ok_not_ok(status),\n\t\t\t  test_number, description, directive_header,\n\t\t\t  directive_body);\n}\n\nenum kunit_status kunit_suite_has_succeeded(struct kunit_suite *suite)\n{\n\tconst struct kunit_case *test_case;\n\tenum kunit_status status = KUNIT_SKIPPED;\n\n\tif (suite->suite_init_err)\n\t\treturn KUNIT_FAILURE;\n\n\tkunit_suite_for_each_test_case(suite, test_case) {\n\t\tif (test_case->status == KUNIT_FAILURE)\n\t\t\treturn KUNIT_FAILURE;\n\t\telse if (test_case->status == KUNIT_SUCCESS)\n\t\t\tstatus = KUNIT_SUCCESS;\n\t}\n\n\treturn status;\n}\nEXPORT_SYMBOL_GPL(kunit_suite_has_succeeded);\n\nstatic size_t kunit_suite_counter = 1;\n\nstatic void kunit_print_suite_end(struct kunit_suite *suite)\n{\n\tkunit_print_ok_not_ok(NULL, KUNIT_LEVEL_SUITE,\n\t\t\t      kunit_suite_has_succeeded(suite),\n\t\t\t      kunit_suite_counter++,\n\t\t\t      suite->name,\n\t\t\t      suite->status_comment);\n}\n\nunsigned int kunit_test_case_num(struct kunit_suite *suite,\n\t\t\t\t struct kunit_case *test_case)\n{\n\tstruct kunit_case *tc;\n\tunsigned int i = 1;\n\n\tkunit_suite_for_each_test_case(suite, tc) {\n\t\tif (tc == test_case)\n\t\t\treturn i;\n\t\ti++;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(kunit_test_case_num);\n\nstatic void kunit_print_string_stream(struct kunit *test,\n\t\t\t\t      struct string_stream *stream)\n{\n\tstruct string_stream_fragment *fragment;\n\tchar *buf;\n\n\tif (string_stream_is_empty(stream))\n\t\treturn;\n\n\tbuf = string_stream_get_string(stream);\n\tif (!buf) {\n\t\tkunit_err(test,\n\t\t\t  \"Could not allocate buffer, dumping stream:\\n\");\n\t\tlist_for_each_entry(fragment, &stream->fragments, node) {\n\t\t\tkunit_err(test, \"%s\", fragment->fragment);\n\t\t}\n\t\tkunit_err(test, \"\\n\");\n\t} else {\n\t\tkunit_err(test, \"%s\", buf);\n\t\tkunit_kfree(test, buf);\n\t}\n}\n\nstatic void kunit_fail(struct kunit *test, const struct kunit_loc *loc,\n\t\t       enum kunit_assert_type type, const struct kunit_assert *assert,\n\t\t       assert_format_t assert_format, const struct va_format *message)\n{\n\tstruct string_stream *stream;\n\n\tkunit_set_failure(test);\n\n\tstream = alloc_string_stream(test, GFP_KERNEL);\n\tif (IS_ERR(stream)) {\n\t\tWARN(true,\n\t\t     \"Could not allocate stream to print failed assertion in %s:%d\\n\",\n\t\t     loc->file,\n\t\t     loc->line);\n\t\treturn;\n\t}\n\n\tkunit_assert_prologue(loc, type, stream);\n\tassert_format(assert, message, stream);\n\n\tkunit_print_string_stream(test, stream);\n\n\tstring_stream_destroy(stream);\n}\n\nvoid __noreturn __kunit_abort(struct kunit *test)\n{\n\tkunit_try_catch_throw(&test->try_catch);  \n\n\t \n\tWARN_ONCE(true, \"Throw could not abort from test!\\n\");\n}\nEXPORT_SYMBOL_GPL(__kunit_abort);\n\nvoid __kunit_do_failed_assertion(struct kunit *test,\n\t\t\t       const struct kunit_loc *loc,\n\t\t\t       enum kunit_assert_type type,\n\t\t\t       const struct kunit_assert *assert,\n\t\t\t       assert_format_t assert_format,\n\t\t\t       const char *fmt, ...)\n{\n\tva_list args;\n\tstruct va_format message;\n\tva_start(args, fmt);\n\n\tmessage.fmt = fmt;\n\tmessage.va = &args;\n\n\tkunit_fail(test, loc, type, assert, assert_format, &message);\n\n\tva_end(args);\n}\nEXPORT_SYMBOL_GPL(__kunit_do_failed_assertion);\n\nvoid kunit_init_test(struct kunit *test, const char *name, char *log)\n{\n\tspin_lock_init(&test->lock);\n\tINIT_LIST_HEAD(&test->resources);\n\ttest->name = name;\n\ttest->log = log;\n\tif (test->log)\n\t\ttest->log[0] = '\\0';\n\ttest->status = KUNIT_SUCCESS;\n\ttest->status_comment[0] = '\\0';\n}\nEXPORT_SYMBOL_GPL(kunit_init_test);\n\n \n#define KUNIT_SPEED_WARNING_MULTIPLIER\t2\n\n \n#define KUNIT_SPEED_SLOW_THRESHOLD_S\t1\n\n#define KUNIT_SPEED_SLOW_WARNING_THRESHOLD_S\t\\\n\t(KUNIT_SPEED_WARNING_MULTIPLIER * KUNIT_SPEED_SLOW_THRESHOLD_S)\n\n#define s_to_timespec64(s) ns_to_timespec64((s) * NSEC_PER_SEC)\n\nstatic void kunit_run_case_check_speed(struct kunit *test,\n\t\t\t\t       struct kunit_case *test_case,\n\t\t\t\t       struct timespec64 duration)\n{\n\tstruct timespec64 slow_thr =\n\t\ts_to_timespec64(KUNIT_SPEED_SLOW_WARNING_THRESHOLD_S);\n\tenum kunit_speed speed = test_case->attr.speed;\n\n\tif (timespec64_compare(&duration, &slow_thr) < 0)\n\t\treturn;\n\n\tif (speed == KUNIT_SPEED_VERY_SLOW || speed == KUNIT_SPEED_SLOW)\n\t\treturn;\n\n\tkunit_warn(test,\n\t\t   \"Test should be marked slow (runtime: %lld.%09lds)\",\n\t\t   duration.tv_sec, duration.tv_nsec);\n}\n\n \nstatic void kunit_run_case_internal(struct kunit *test,\n\t\t\t\t    struct kunit_suite *suite,\n\t\t\t\t    struct kunit_case *test_case)\n{\n\tstruct timespec64 start, end;\n\n\tif (suite->init) {\n\t\tint ret;\n\n\t\tret = suite->init(test);\n\t\tif (ret) {\n\t\t\tkunit_err(test, \"failed to initialize: %d\\n\", ret);\n\t\t\tkunit_set_failure(test);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tktime_get_ts64(&start);\n\n\ttest_case->run_case(test);\n\n\tktime_get_ts64(&end);\n\n\tkunit_run_case_check_speed(test, test_case, timespec64_sub(end, start));\n}\n\nstatic void kunit_case_internal_cleanup(struct kunit *test)\n{\n\tkunit_cleanup(test);\n}\n\n \nstatic void kunit_run_case_cleanup(struct kunit *test,\n\t\t\t\t   struct kunit_suite *suite)\n{\n\tif (suite->exit)\n\t\tsuite->exit(test);\n\n\tkunit_case_internal_cleanup(test);\n}\n\nstruct kunit_try_catch_context {\n\tstruct kunit *test;\n\tstruct kunit_suite *suite;\n\tstruct kunit_case *test_case;\n};\n\nstatic void kunit_try_run_case(void *data)\n{\n\tstruct kunit_try_catch_context *ctx = data;\n\tstruct kunit *test = ctx->test;\n\tstruct kunit_suite *suite = ctx->suite;\n\tstruct kunit_case *test_case = ctx->test_case;\n\n\tcurrent->kunit_test = test;\n\n\t \n\tkunit_run_case_internal(test, suite, test_case);\n}\n\nstatic void kunit_try_run_case_cleanup(void *data)\n{\n\tstruct kunit_try_catch_context *ctx = data;\n\tstruct kunit *test = ctx->test;\n\tstruct kunit_suite *suite = ctx->suite;\n\n\tcurrent->kunit_test = test;\n\n\tkunit_run_case_cleanup(test, suite);\n}\n\nstatic void kunit_catch_run_case_cleanup(void *data)\n{\n\tstruct kunit_try_catch_context *ctx = data;\n\tstruct kunit *test = ctx->test;\n\tint try_exit_code = kunit_try_catch_get_result(&test->try_catch);\n\n\t \n\tkunit_set_failure(test);\n\n\tif (try_exit_code) {\n\t\t \n\t\tif (try_exit_code == -ETIMEDOUT) {\n\t\t\tkunit_err(test, \"test case cleanup timed out\\n\");\n\t\t \n\t\t} else {\n\t\t\tkunit_err(test, \"internal error occurred during test case cleanup: %d\\n\",\n\t\t\t\t  try_exit_code);\n\t\t}\n\t\treturn;\n\t}\n\n\tkunit_err(test, \"test aborted during cleanup. continuing without cleaning up\\n\");\n}\n\n\nstatic void kunit_catch_run_case(void *data)\n{\n\tstruct kunit_try_catch_context *ctx = data;\n\tstruct kunit *test = ctx->test;\n\tint try_exit_code = kunit_try_catch_get_result(&test->try_catch);\n\n\tif (try_exit_code) {\n\t\tkunit_set_failure(test);\n\t\t \n\t\tif (try_exit_code == -ETIMEDOUT) {\n\t\t\tkunit_err(test, \"test case timed out\\n\");\n\t\t \n\t\t} else {\n\t\t\tkunit_err(test, \"internal error occurred preventing test case from running: %d\\n\",\n\t\t\t\t  try_exit_code);\n\t\t}\n\t\treturn;\n\t}\n}\n\n \nstatic void kunit_run_case_catch_errors(struct kunit_suite *suite,\n\t\t\t\t\tstruct kunit_case *test_case,\n\t\t\t\t\tstruct kunit *test)\n{\n\tstruct kunit_try_catch_context context;\n\tstruct kunit_try_catch *try_catch;\n\n\ttry_catch = &test->try_catch;\n\n\tkunit_try_catch_init(try_catch,\n\t\t\t     test,\n\t\t\t     kunit_try_run_case,\n\t\t\t     kunit_catch_run_case);\n\tcontext.test = test;\n\tcontext.suite = suite;\n\tcontext.test_case = test_case;\n\tkunit_try_catch_run(try_catch, &context);\n\n\t \n\tkunit_try_catch_init(try_catch,\n\t\t\t     test,\n\t\t\t     kunit_try_run_case_cleanup,\n\t\t\t     kunit_catch_run_case_cleanup);\n\tkunit_try_catch_run(try_catch, &context);\n\n\t \n\tif (test->status == KUNIT_FAILURE)\n\t\ttest_case->status = KUNIT_FAILURE;\n\telse if (test_case->status != KUNIT_FAILURE && test->status == KUNIT_SUCCESS)\n\t\ttest_case->status = KUNIT_SUCCESS;\n}\n\nstatic void kunit_print_suite_stats(struct kunit_suite *suite,\n\t\t\t\t    struct kunit_result_stats suite_stats,\n\t\t\t\t    struct kunit_result_stats param_stats)\n{\n\tif (kunit_should_print_stats(suite_stats)) {\n\t\tkunit_log(KERN_INFO, suite,\n\t\t\t  \"# %s: pass:%lu fail:%lu skip:%lu total:%lu\",\n\t\t\t  suite->name,\n\t\t\t  suite_stats.passed,\n\t\t\t  suite_stats.failed,\n\t\t\t  suite_stats.skipped,\n\t\t\t  suite_stats.total);\n\t}\n\n\tif (kunit_should_print_stats(param_stats)) {\n\t\tkunit_log(KERN_INFO, suite,\n\t\t\t  \"# Totals: pass:%lu fail:%lu skip:%lu total:%lu\",\n\t\t\t  param_stats.passed,\n\t\t\t  param_stats.failed,\n\t\t\t  param_stats.skipped,\n\t\t\t  param_stats.total);\n\t}\n}\n\nstatic void kunit_update_stats(struct kunit_result_stats *stats,\n\t\t\t       enum kunit_status status)\n{\n\tswitch (status) {\n\tcase KUNIT_SUCCESS:\n\t\tstats->passed++;\n\t\tbreak;\n\tcase KUNIT_SKIPPED:\n\t\tstats->skipped++;\n\t\tbreak;\n\tcase KUNIT_FAILURE:\n\t\tstats->failed++;\n\t\tbreak;\n\t}\n\n\tstats->total++;\n}\n\nstatic void kunit_accumulate_stats(struct kunit_result_stats *total,\n\t\t\t\t   struct kunit_result_stats add)\n{\n\ttotal->passed += add.passed;\n\ttotal->skipped += add.skipped;\n\ttotal->failed += add.failed;\n\ttotal->total += add.total;\n}\n\nint kunit_run_tests(struct kunit_suite *suite)\n{\n\tchar param_desc[KUNIT_PARAM_DESC_SIZE];\n\tstruct kunit_case *test_case;\n\tstruct kunit_result_stats suite_stats = { 0 };\n\tstruct kunit_result_stats total_stats = { 0 };\n\n\t \n\tadd_taint(TAINT_TEST, LOCKDEP_STILL_OK);\n\n\tif (suite->suite_init) {\n\t\tsuite->suite_init_err = suite->suite_init(suite);\n\t\tif (suite->suite_init_err) {\n\t\t\tkunit_err(suite, KUNIT_SUBTEST_INDENT\n\t\t\t\t  \"# failed to initialize (%d)\", suite->suite_init_err);\n\t\t\tgoto suite_end;\n\t\t}\n\t}\n\n\tkunit_print_suite_start(suite);\n\n\tkunit_suite_for_each_test_case(suite, test_case) {\n\t\tstruct kunit test = { .param_value = NULL, .param_index = 0 };\n\t\tstruct kunit_result_stats param_stats = { 0 };\n\n\t\tkunit_init_test(&test, test_case->name, test_case->log);\n\t\tif (test_case->status == KUNIT_SKIPPED) {\n\t\t\t \n\t\t\ttest.status = KUNIT_SKIPPED;\n\t\t\tkunit_update_stats(&param_stats, test.status);\n\t\t} else if (!test_case->generate_params) {\n\t\t\t \n\t\t\ttest_case->status = KUNIT_SKIPPED;\n\t\t\tkunit_run_case_catch_errors(suite, test_case, &test);\n\t\t\tkunit_update_stats(&param_stats, test.status);\n\t\t} else {\n\t\t\t \n\t\t\tparam_desc[0] = '\\0';\n\t\t\ttest.param_value = test_case->generate_params(NULL, param_desc);\n\t\t\ttest_case->status = KUNIT_SKIPPED;\n\t\t\tkunit_log(KERN_INFO, &test, KUNIT_SUBTEST_INDENT KUNIT_SUBTEST_INDENT\n\t\t\t\t  \"KTAP version 1\\n\");\n\t\t\tkunit_log(KERN_INFO, &test, KUNIT_SUBTEST_INDENT KUNIT_SUBTEST_INDENT\n\t\t\t\t  \"# Subtest: %s\", test_case->name);\n\n\t\t\twhile (test.param_value) {\n\t\t\t\tkunit_run_case_catch_errors(suite, test_case, &test);\n\n\t\t\t\tif (param_desc[0] == '\\0') {\n\t\t\t\t\tsnprintf(param_desc, sizeof(param_desc),\n\t\t\t\t\t\t \"param-%d\", test.param_index);\n\t\t\t\t}\n\n\t\t\t\tkunit_print_ok_not_ok(&test, KUNIT_LEVEL_CASE_PARAM,\n\t\t\t\t\t\t      test.status,\n\t\t\t\t\t\t      test.param_index + 1,\n\t\t\t\t\t\t      param_desc,\n\t\t\t\t\t\t      test.status_comment);\n\n\t\t\t\t \n\t\t\t\tparam_desc[0] = '\\0';\n\t\t\t\ttest.param_value = test_case->generate_params(test.param_value, param_desc);\n\t\t\t\ttest.param_index++;\n\n\t\t\t\tkunit_update_stats(&param_stats, test.status);\n\t\t\t}\n\t\t}\n\n\t\tkunit_print_attr((void *)test_case, true, KUNIT_LEVEL_CASE);\n\n\t\tkunit_print_test_stats(&test, param_stats);\n\n\t\tkunit_print_ok_not_ok(&test, KUNIT_LEVEL_CASE, test_case->status,\n\t\t\t\t      kunit_test_case_num(suite, test_case),\n\t\t\t\t      test_case->name,\n\t\t\t\t      test.status_comment);\n\n\t\tkunit_update_stats(&suite_stats, test_case->status);\n\t\tkunit_accumulate_stats(&total_stats, param_stats);\n\t}\n\n\tif (suite->suite_exit)\n\t\tsuite->suite_exit(suite);\n\n\tkunit_print_suite_stats(suite, suite_stats, total_stats);\nsuite_end:\n\tkunit_print_suite_end(suite);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(kunit_run_tests);\n\nstatic void kunit_init_suite(struct kunit_suite *suite)\n{\n\tkunit_debugfs_create_suite(suite);\n\tsuite->status_comment[0] = '\\0';\n\tsuite->suite_init_err = 0;\n}\n\nbool kunit_enabled(void)\n{\n\treturn enable_param;\n}\n\nint __kunit_test_suites_init(struct kunit_suite * const * const suites, int num_suites)\n{\n\tunsigned int i;\n\n\tif (!kunit_enabled() && num_suites > 0) {\n\t\tpr_info(\"kunit: disabled\\n\");\n\t\treturn 0;\n\t}\n\n\tkunit_suite_counter = 1;\n\n\tstatic_branch_inc(&kunit_running);\n\n\tfor (i = 0; i < num_suites; i++) {\n\t\tkunit_init_suite(suites[i]);\n\t\tkunit_run_tests(suites[i]);\n\t}\n\n\tstatic_branch_dec(&kunit_running);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(__kunit_test_suites_init);\n\nstatic void kunit_exit_suite(struct kunit_suite *suite)\n{\n\tkunit_debugfs_destroy_suite(suite);\n}\n\nvoid __kunit_test_suites_exit(struct kunit_suite **suites, int num_suites)\n{\n\tunsigned int i;\n\n\tif (!kunit_enabled())\n\t\treturn;\n\n\tfor (i = 0; i < num_suites; i++)\n\t\tkunit_exit_suite(suites[i]);\n}\nEXPORT_SYMBOL_GPL(__kunit_test_suites_exit);\n\n#ifdef CONFIG_MODULES\nstatic void kunit_module_init(struct module *mod)\n{\n\tstruct kunit_suite_set suite_set = {\n\t\tmod->kunit_suites, mod->kunit_suites + mod->num_kunit_suites,\n\t};\n\tconst char *action = kunit_action();\n\tint err = 0;\n\n\tsuite_set = kunit_filter_suites(&suite_set,\n\t\t\t\t\tkunit_filter_glob() ?: \"*.*\",\n\t\t\t\t\tkunit_filter(), kunit_filter_action(),\n\t\t\t\t\t&err);\n\tif (err)\n\t\tpr_err(\"kunit module: error filtering suites: %d\\n\", err);\n\n\tmod->kunit_suites = (struct kunit_suite **)suite_set.start;\n\tmod->num_kunit_suites = suite_set.end - suite_set.start;\n\n\tif (!action)\n\t\tkunit_exec_run_tests(&suite_set, false);\n\telse if (!strcmp(action, \"list\"))\n\t\tkunit_exec_list_tests(&suite_set, false);\n\telse if (!strcmp(action, \"list_attr\"))\n\t\tkunit_exec_list_tests(&suite_set, true);\n\telse\n\t\tpr_err(\"kunit: unknown action '%s'\\n\", action);\n}\n\nstatic void kunit_module_exit(struct module *mod)\n{\n\tstruct kunit_suite_set suite_set = {\n\t\tmod->kunit_suites, mod->kunit_suites + mod->num_kunit_suites,\n\t};\n\tconst char *action = kunit_action();\n\n\tif (!action)\n\t\t__kunit_test_suites_exit(mod->kunit_suites,\n\t\t\t\t\t mod->num_kunit_suites);\n\n\tif (suite_set.start)\n\t\tkunit_free_suite_set(suite_set);\n}\n\nstatic int kunit_module_notify(struct notifier_block *nb, unsigned long val,\n\t\t\t       void *data)\n{\n\tstruct module *mod = data;\n\n\tswitch (val) {\n\tcase MODULE_STATE_LIVE:\n\t\tbreak;\n\tcase MODULE_STATE_GOING:\n\t\tkunit_module_exit(mod);\n\t\tbreak;\n\tcase MODULE_STATE_COMING:\n\t\tkunit_module_init(mod);\n\t\tbreak;\n\tcase MODULE_STATE_UNFORMED:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic struct notifier_block kunit_mod_nb = {\n\t.notifier_call = kunit_module_notify,\n\t.priority = 0,\n};\n#endif\n\nvoid *kunit_kmalloc_array(struct kunit *test, size_t n, size_t size, gfp_t gfp)\n{\n\tvoid *data;\n\n\tdata = kmalloc_array(n, size, gfp);\n\n\tif (!data)\n\t\treturn NULL;\n\n\tif (kunit_add_action_or_reset(test, (kunit_action_t *)kfree, data) != 0)\n\t\treturn NULL;\n\n\treturn data;\n}\nEXPORT_SYMBOL_GPL(kunit_kmalloc_array);\n\nvoid kunit_kfree(struct kunit *test, const void *ptr)\n{\n\tif (!ptr)\n\t\treturn;\n\n\tkunit_release_action(test, (kunit_action_t *)kfree, (void *)ptr);\n}\nEXPORT_SYMBOL_GPL(kunit_kfree);\n\nvoid kunit_cleanup(struct kunit *test)\n{\n\tstruct kunit_resource *res;\n\tunsigned long flags;\n\n\t \n\twhile (true) {\n\t\tspin_lock_irqsave(&test->lock, flags);\n\t\tif (list_empty(&test->resources)) {\n\t\t\tspin_unlock_irqrestore(&test->lock, flags);\n\t\t\tbreak;\n\t\t}\n\t\tres = list_last_entry(&test->resources,\n\t\t\t\t      struct kunit_resource,\n\t\t\t\t      node);\n\t\t \n\t\tspin_unlock_irqrestore(&test->lock, flags);\n\t\tkunit_remove_resource(test, res);\n\t}\n\tcurrent->kunit_test = NULL;\n}\nEXPORT_SYMBOL_GPL(kunit_cleanup);\n\nstatic int __init kunit_init(void)\n{\n\t \n\tkunit_install_hooks();\n\n\tkunit_debugfs_init();\n#ifdef CONFIG_MODULES\n\treturn register_module_notifier(&kunit_mod_nb);\n#else\n\treturn 0;\n#endif\n}\nlate_initcall(kunit_init);\n\nstatic void __exit kunit_exit(void)\n{\n\tmemset(&kunit_hooks, 0, sizeof(kunit_hooks));\n#ifdef CONFIG_MODULES\n\tunregister_module_notifier(&kunit_mod_nb);\n#endif\n\tkunit_debugfs_cleanup();\n}\nmodule_exit(kunit_exit);\n\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}