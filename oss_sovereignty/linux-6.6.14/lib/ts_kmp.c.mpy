{
  "module_name": "ts_kmp.c",
  "hash_id": "dd9bef068649ce4cb2fcd83268064e9b2c9f6901a4aaa7b16f8dfdbca97651b7",
  "original_prompt": "Ingested from linux-6.6.14/lib/ts_kmp.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/textsearch.h>\n\nstruct ts_kmp\n{\n\tu8 *\t\tpattern;\n\tunsigned int\tpattern_len;\n\tunsigned int\tprefix_tbl[];\n};\n\nstatic unsigned int kmp_find(struct ts_config *conf, struct ts_state *state)\n{\n\tstruct ts_kmp *kmp = ts_config_priv(conf);\n\tunsigned int i, q = 0, text_len, consumed = state->offset;\n\tconst u8 *text;\n\tconst int icase = conf->flags & TS_IGNORECASE;\n\n\tfor (;;) {\n\t\ttext_len = conf->get_next_block(consumed, &text, conf, state);\n\n\t\tif (unlikely(text_len == 0))\n\t\t\tbreak;\n\n\t\tfor (i = 0; i < text_len; i++) {\n\t\t\twhile (q > 0 && kmp->pattern[q]\n\t\t\t    != (icase ? toupper(text[i]) : text[i]))\n\t\t\t\tq = kmp->prefix_tbl[q - 1];\n\t\t\tif (kmp->pattern[q]\n\t\t\t    == (icase ? toupper(text[i]) : text[i]))\n\t\t\t\tq++;\n\t\t\tif (unlikely(q == kmp->pattern_len)) {\n\t\t\t\tstate->offset = consumed + i + 1;\n\t\t\t\treturn state->offset - kmp->pattern_len;\n\t\t\t}\n\t\t}\n\n\t\tconsumed += text_len;\n\t}\n\n\treturn UINT_MAX;\n}\n\nstatic inline void compute_prefix_tbl(const u8 *pattern, unsigned int len,\n\t\t\t\t      unsigned int *prefix_tbl, int flags)\n{\n\tunsigned int k, q;\n\tconst u8 icase = flags & TS_IGNORECASE;\n\n\tfor (k = 0, q = 1; q < len; q++) {\n\t\twhile (k > 0 && (icase ? toupper(pattern[k]) : pattern[k])\n\t\t    != (icase ? toupper(pattern[q]) : pattern[q]))\n\t\t\tk = prefix_tbl[k-1];\n\t\tif ((icase ? toupper(pattern[k]) : pattern[k])\n\t\t    == (icase ? toupper(pattern[q]) : pattern[q]))\n\t\t\tk++;\n\t\tprefix_tbl[q] = k;\n\t}\n}\n\nstatic struct ts_config *kmp_init(const void *pattern, unsigned int len,\n\t\t\t\t  gfp_t gfp_mask, int flags)\n{\n\tstruct ts_config *conf;\n\tstruct ts_kmp *kmp;\n\tint i;\n\tunsigned int prefix_tbl_len = len * sizeof(unsigned int);\n\tsize_t priv_size = sizeof(*kmp) + len + prefix_tbl_len;\n\n\tconf = alloc_ts_config(priv_size, gfp_mask);\n\tif (IS_ERR(conf))\n\t\treturn conf;\n\n\tconf->flags = flags;\n\tkmp = ts_config_priv(conf);\n\tkmp->pattern_len = len;\n\tcompute_prefix_tbl(pattern, len, kmp->prefix_tbl, flags);\n\tkmp->pattern = (u8 *) kmp->prefix_tbl + prefix_tbl_len;\n\tif (flags & TS_IGNORECASE)\n\t\tfor (i = 0; i < len; i++)\n\t\t\tkmp->pattern[i] = toupper(((u8 *)pattern)[i]);\n\telse\n\t\tmemcpy(kmp->pattern, pattern, len);\n\n\treturn conf;\n}\n\nstatic void *kmp_get_pattern(struct ts_config *conf)\n{\n\tstruct ts_kmp *kmp = ts_config_priv(conf);\n\treturn kmp->pattern;\n}\n\nstatic unsigned int kmp_get_pattern_len(struct ts_config *conf)\n{\n\tstruct ts_kmp *kmp = ts_config_priv(conf);\n\treturn kmp->pattern_len;\n}\n\nstatic struct ts_ops kmp_ops = {\n\t.name\t\t  = \"kmp\",\n\t.find\t\t  = kmp_find,\n\t.init\t\t  = kmp_init,\n\t.get_pattern\t  = kmp_get_pattern,\n\t.get_pattern_len  = kmp_get_pattern_len,\n\t.owner\t\t  = THIS_MODULE,\n\t.list\t\t  = LIST_HEAD_INIT(kmp_ops.list)\n};\n\nstatic int __init init_kmp(void)\n{\n\treturn textsearch_register(&kmp_ops);\n}\n\nstatic void __exit exit_kmp(void)\n{\n\ttextsearch_unregister(&kmp_ops);\n}\n\nMODULE_LICENSE(\"GPL\");\n\nmodule_init(init_kmp);\nmodule_exit(exit_kmp);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}