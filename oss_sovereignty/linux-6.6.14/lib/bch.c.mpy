{
  "module_name": "bch.c",
  "hash_id": "36457edf4890c0b37aad923a98ec4de8257a08588a5bbb6569839510ffc5e350",
  "original_prompt": "Ingested from linux-6.6.14/lib/bch.c",
  "human_readable_source": " \n\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/bitrev.h>\n#include <asm/byteorder.h>\n#include <linux/bch.h>\n\n#if defined(CONFIG_BCH_CONST_PARAMS)\n#define GF_M(_p)               (CONFIG_BCH_CONST_M)\n#define GF_T(_p)               (CONFIG_BCH_CONST_T)\n#define GF_N(_p)               ((1 << (CONFIG_BCH_CONST_M))-1)\n#define BCH_MAX_M              (CONFIG_BCH_CONST_M)\n#define BCH_MAX_T\t       (CONFIG_BCH_CONST_T)\n#else\n#define GF_M(_p)               ((_p)->m)\n#define GF_T(_p)               ((_p)->t)\n#define GF_N(_p)               ((_p)->n)\n#define BCH_MAX_M              15  \n#define BCH_MAX_T              64  \n#endif\n\n#define BCH_ECC_WORDS(_p)      DIV_ROUND_UP(GF_M(_p)*GF_T(_p), 32)\n#define BCH_ECC_BYTES(_p)      DIV_ROUND_UP(GF_M(_p)*GF_T(_p), 8)\n\n#define BCH_ECC_MAX_WORDS      DIV_ROUND_UP(BCH_MAX_M * BCH_MAX_T, 32)\n\n#ifndef dbg\n#define dbg(_fmt, args...)     do {} while (0)\n#endif\n\n \nstruct gf_poly {\n\tunsigned int deg;     \n\tunsigned int c[];    \n};\n\n \n#define GF_POLY_SZ(_d) (sizeof(struct gf_poly)+((_d)+1)*sizeof(unsigned int))\n\n \nstruct gf_poly_deg1 {\n\tstruct gf_poly poly;\n\tunsigned int   c[2];\n};\n\nstatic u8 swap_bits(struct bch_control *bch, u8 in)\n{\n\tif (!bch->swap_bits)\n\t\treturn in;\n\n\treturn bitrev8(in);\n}\n\n \nstatic void bch_encode_unaligned(struct bch_control *bch,\n\t\t\t\t const unsigned char *data, unsigned int len,\n\t\t\t\t uint32_t *ecc)\n{\n\tint i;\n\tconst uint32_t *p;\n\tconst int l = BCH_ECC_WORDS(bch)-1;\n\n\twhile (len--) {\n\t\tu8 tmp = swap_bits(bch, *data++);\n\n\t\tp = bch->mod8_tab + (l+1)*(((ecc[0] >> 24)^(tmp)) & 0xff);\n\n\t\tfor (i = 0; i < l; i++)\n\t\t\tecc[i] = ((ecc[i] << 8)|(ecc[i+1] >> 24))^(*p++);\n\n\t\tecc[l] = (ecc[l] << 8)^(*p);\n\t}\n}\n\n \nstatic void load_ecc8(struct bch_control *bch, uint32_t *dst,\n\t\t      const uint8_t *src)\n{\n\tuint8_t pad[4] = {0, 0, 0, 0};\n\tunsigned int i, nwords = BCH_ECC_WORDS(bch)-1;\n\n\tfor (i = 0; i < nwords; i++, src += 4)\n\t\tdst[i] = ((u32)swap_bits(bch, src[0]) << 24) |\n\t\t\t((u32)swap_bits(bch, src[1]) << 16) |\n\t\t\t((u32)swap_bits(bch, src[2]) << 8) |\n\t\t\tswap_bits(bch, src[3]);\n\n\tmemcpy(pad, src, BCH_ECC_BYTES(bch)-4*nwords);\n\tdst[nwords] = ((u32)swap_bits(bch, pad[0]) << 24) |\n\t\t((u32)swap_bits(bch, pad[1]) << 16) |\n\t\t((u32)swap_bits(bch, pad[2]) << 8) |\n\t\tswap_bits(bch, pad[3]);\n}\n\n \nstatic void store_ecc8(struct bch_control *bch, uint8_t *dst,\n\t\t       const uint32_t *src)\n{\n\tuint8_t pad[4];\n\tunsigned int i, nwords = BCH_ECC_WORDS(bch)-1;\n\n\tfor (i = 0; i < nwords; i++) {\n\t\t*dst++ = swap_bits(bch, src[i] >> 24);\n\t\t*dst++ = swap_bits(bch, src[i] >> 16);\n\t\t*dst++ = swap_bits(bch, src[i] >> 8);\n\t\t*dst++ = swap_bits(bch, src[i]);\n\t}\n\tpad[0] = swap_bits(bch, src[nwords] >> 24);\n\tpad[1] = swap_bits(bch, src[nwords] >> 16);\n\tpad[2] = swap_bits(bch, src[nwords] >> 8);\n\tpad[3] = swap_bits(bch, src[nwords]);\n\tmemcpy(dst, pad, BCH_ECC_BYTES(bch)-4*nwords);\n}\n\n \nvoid bch_encode(struct bch_control *bch, const uint8_t *data,\n\t\tunsigned int len, uint8_t *ecc)\n{\n\tconst unsigned int l = BCH_ECC_WORDS(bch)-1;\n\tunsigned int i, mlen;\n\tunsigned long m;\n\tuint32_t w, r[BCH_ECC_MAX_WORDS];\n\tconst size_t r_bytes = BCH_ECC_WORDS(bch) * sizeof(*r);\n\tconst uint32_t * const tab0 = bch->mod8_tab;\n\tconst uint32_t * const tab1 = tab0 + 256*(l+1);\n\tconst uint32_t * const tab2 = tab1 + 256*(l+1);\n\tconst uint32_t * const tab3 = tab2 + 256*(l+1);\n\tconst uint32_t *pdata, *p0, *p1, *p2, *p3;\n\n\tif (WARN_ON(r_bytes > sizeof(r)))\n\t\treturn;\n\n\tif (ecc) {\n\t\t \n\t\tload_ecc8(bch, bch->ecc_buf, ecc);\n\t} else {\n\t\tmemset(bch->ecc_buf, 0, r_bytes);\n\t}\n\n\t \n\tm = ((unsigned long)data) & 3;\n\tif (m) {\n\t\tmlen = (len < (4-m)) ? len : 4-m;\n\t\tbch_encode_unaligned(bch, data, mlen, bch->ecc_buf);\n\t\tdata += mlen;\n\t\tlen  -= mlen;\n\t}\n\n\t \n\tpdata = (uint32_t *)data;\n\tmlen  = len/4;\n\tdata += 4*mlen;\n\tlen  -= 4*mlen;\n\tmemcpy(r, bch->ecc_buf, r_bytes);\n\n\t \n\twhile (mlen--) {\n\t\t \n\t\tw = cpu_to_be32(*pdata++);\n\t\tif (bch->swap_bits)\n\t\t\tw = (u32)swap_bits(bch, w) |\n\t\t\t    ((u32)swap_bits(bch, w >> 8) << 8) |\n\t\t\t    ((u32)swap_bits(bch, w >> 16) << 16) |\n\t\t\t    ((u32)swap_bits(bch, w >> 24) << 24);\n\t\tw ^= r[0];\n\t\tp0 = tab0 + (l+1)*((w >>  0) & 0xff);\n\t\tp1 = tab1 + (l+1)*((w >>  8) & 0xff);\n\t\tp2 = tab2 + (l+1)*((w >> 16) & 0xff);\n\t\tp3 = tab3 + (l+1)*((w >> 24) & 0xff);\n\n\t\tfor (i = 0; i < l; i++)\n\t\t\tr[i] = r[i+1]^p0[i]^p1[i]^p2[i]^p3[i];\n\n\t\tr[l] = p0[l]^p1[l]^p2[l]^p3[l];\n\t}\n\tmemcpy(bch->ecc_buf, r, r_bytes);\n\n\t \n\tif (len)\n\t\tbch_encode_unaligned(bch, data, len, bch->ecc_buf);\n\n\t \n\tif (ecc)\n\t\tstore_ecc8(bch, ecc, bch->ecc_buf);\n}\nEXPORT_SYMBOL_GPL(bch_encode);\n\nstatic inline int modulo(struct bch_control *bch, unsigned int v)\n{\n\tconst unsigned int n = GF_N(bch);\n\twhile (v >= n) {\n\t\tv -= n;\n\t\tv = (v & n) + (v >> GF_M(bch));\n\t}\n\treturn v;\n}\n\n \nstatic inline int mod_s(struct bch_control *bch, unsigned int v)\n{\n\tconst unsigned int n = GF_N(bch);\n\treturn (v < n) ? v : v-n;\n}\n\nstatic inline int deg(unsigned int poly)\n{\n\t \n\treturn fls(poly)-1;\n}\n\nstatic inline int parity(unsigned int x)\n{\n\t \n\tx ^= x >> 1;\n\tx ^= x >> 2;\n\tx = (x & 0x11111111U) * 0x11111111U;\n\treturn (x >> 28) & 1;\n}\n\n \n\nstatic inline unsigned int gf_mul(struct bch_control *bch, unsigned int a,\n\t\t\t\t  unsigned int b)\n{\n\treturn (a && b) ? bch->a_pow_tab[mod_s(bch, bch->a_log_tab[a]+\n\t\t\t\t\t       bch->a_log_tab[b])] : 0;\n}\n\nstatic inline unsigned int gf_sqr(struct bch_control *bch, unsigned int a)\n{\n\treturn a ? bch->a_pow_tab[mod_s(bch, 2*bch->a_log_tab[a])] : 0;\n}\n\nstatic inline unsigned int gf_div(struct bch_control *bch, unsigned int a,\n\t\t\t\t  unsigned int b)\n{\n\treturn a ? bch->a_pow_tab[mod_s(bch, bch->a_log_tab[a]+\n\t\t\t\t\tGF_N(bch)-bch->a_log_tab[b])] : 0;\n}\n\nstatic inline unsigned int gf_inv(struct bch_control *bch, unsigned int a)\n{\n\treturn bch->a_pow_tab[GF_N(bch)-bch->a_log_tab[a]];\n}\n\nstatic inline unsigned int a_pow(struct bch_control *bch, int i)\n{\n\treturn bch->a_pow_tab[modulo(bch, i)];\n}\n\nstatic inline int a_log(struct bch_control *bch, unsigned int x)\n{\n\treturn bch->a_log_tab[x];\n}\n\nstatic inline int a_ilog(struct bch_control *bch, unsigned int x)\n{\n\treturn mod_s(bch, GF_N(bch)-bch->a_log_tab[x]);\n}\n\n \nstatic void compute_syndromes(struct bch_control *bch, uint32_t *ecc,\n\t\t\t      unsigned int *syn)\n{\n\tint i, j, s;\n\tunsigned int m;\n\tuint32_t poly;\n\tconst int t = GF_T(bch);\n\n\ts = bch->ecc_bits;\n\n\t \n\tm = ((unsigned int)s) & 31;\n\tif (m)\n\t\tecc[s/32] &= ~((1u << (32-m))-1);\n\tmemset(syn, 0, 2*t*sizeof(*syn));\n\n\t \n\tdo {\n\t\tpoly = *ecc++;\n\t\ts -= 32;\n\t\twhile (poly) {\n\t\t\ti = deg(poly);\n\t\t\tfor (j = 0; j < 2*t; j += 2)\n\t\t\t\tsyn[j] ^= a_pow(bch, (j+1)*(i+s));\n\n\t\t\tpoly ^= (1 << i);\n\t\t}\n\t} while (s > 0);\n\n\t \n\tfor (j = 0; j < t; j++)\n\t\tsyn[2*j+1] = gf_sqr(bch, syn[j]);\n}\n\nstatic void gf_poly_copy(struct gf_poly *dst, struct gf_poly *src)\n{\n\tmemcpy(dst, src, GF_POLY_SZ(src->deg));\n}\n\nstatic int compute_error_locator_polynomial(struct bch_control *bch,\n\t\t\t\t\t    const unsigned int *syn)\n{\n\tconst unsigned int t = GF_T(bch);\n\tconst unsigned int n = GF_N(bch);\n\tunsigned int i, j, tmp, l, pd = 1, d = syn[0];\n\tstruct gf_poly *elp = bch->elp;\n\tstruct gf_poly *pelp = bch->poly_2t[0];\n\tstruct gf_poly *elp_copy = bch->poly_2t[1];\n\tint k, pp = -1;\n\n\tmemset(pelp, 0, GF_POLY_SZ(2*t));\n\tmemset(elp, 0, GF_POLY_SZ(2*t));\n\n\tpelp->deg = 0;\n\tpelp->c[0] = 1;\n\telp->deg = 0;\n\telp->c[0] = 1;\n\n\t \n\tfor (i = 0; (i < t) && (elp->deg <= t); i++) {\n\t\tif (d) {\n\t\t\tk = 2*i-pp;\n\t\t\tgf_poly_copy(elp_copy, elp);\n\t\t\t \n\t\t\ttmp = a_log(bch, d)+n-a_log(bch, pd);\n\t\t\tfor (j = 0; j <= pelp->deg; j++) {\n\t\t\t\tif (pelp->c[j]) {\n\t\t\t\t\tl = a_log(bch, pelp->c[j]);\n\t\t\t\t\telp->c[j+k] ^= a_pow(bch, tmp+l);\n\t\t\t\t}\n\t\t\t}\n\t\t\t \n\t\t\ttmp = pelp->deg+k;\n\t\t\tif (tmp > elp->deg) {\n\t\t\t\telp->deg = tmp;\n\t\t\t\tgf_poly_copy(pelp, elp_copy);\n\t\t\t\tpd = d;\n\t\t\t\tpp = 2*i;\n\t\t\t}\n\t\t}\n\t\t \n\t\tif (i < t-1) {\n\t\t\td = syn[2*i+2];\n\t\t\tfor (j = 1; j <= elp->deg; j++)\n\t\t\t\td ^= gf_mul(bch, elp->c[j], syn[2*i+2-j]);\n\t\t}\n\t}\n\tdbg(\"elp=%s\\n\", gf_poly_str(elp));\n\treturn (elp->deg > t) ? -1 : (int)elp->deg;\n}\n\n \nstatic int solve_linear_system(struct bch_control *bch, unsigned int *rows,\n\t\t\t       unsigned int *sol, int nsol)\n{\n\tconst int m = GF_M(bch);\n\tunsigned int tmp, mask;\n\tint rem, c, r, p, k, param[BCH_MAX_M];\n\n\tk = 0;\n\tmask = 1 << m;\n\n\t \n\tfor (c = 0; c < m; c++) {\n\t\trem = 0;\n\t\tp = c-k;\n\t\t \n\t\tfor (r = p; r < m; r++) {\n\t\t\tif (rows[r] & mask) {\n\t\t\t\tif (r != p) {\n\t\t\t\t\ttmp = rows[r];\n\t\t\t\t\trows[r] = rows[p];\n\t\t\t\t\trows[p] = tmp;\n\t\t\t\t}\n\t\t\t\trem = r+1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (rem) {\n\t\t\t \n\t\t\ttmp = rows[p];\n\t\t\tfor (r = rem; r < m; r++) {\n\t\t\t\tif (rows[r] & mask)\n\t\t\t\t\trows[r] ^= tmp;\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tparam[k++] = c;\n\t\t}\n\t\tmask >>= 1;\n\t}\n\t \n\tif (k > 0) {\n\t\tp = k;\n\t\tfor (r = m-1; r >= 0; r--) {\n\t\t\tif ((r > m-1-k) && rows[r])\n\t\t\t\t \n\t\t\t\treturn 0;\n\n\t\t\trows[r] = (p && (r == param[p-1])) ?\n\t\t\t\tp--, 1u << (m-r) : rows[r-p];\n\t\t}\n\t}\n\n\tif (nsol != (1 << k))\n\t\t \n\t\treturn 0;\n\n\tfor (p = 0; p < nsol; p++) {\n\t\t \n\t\tfor (c = 0; c < k; c++)\n\t\t\trows[param[c]] = (rows[param[c]] & ~1)|((p >> c) & 1);\n\n\t\t \n\t\ttmp = 0;\n\t\tfor (r = m-1; r >= 0; r--) {\n\t\t\tmask = rows[r] & (tmp|1);\n\t\t\ttmp |= parity(mask) << (m-r);\n\t\t}\n\t\tsol[p] = tmp >> 1;\n\t}\n\treturn nsol;\n}\n\n \nstatic int find_affine4_roots(struct bch_control *bch, unsigned int a,\n\t\t\t      unsigned int b, unsigned int c,\n\t\t\t      unsigned int *roots)\n{\n\tint i, j, k;\n\tconst int m = GF_M(bch);\n\tunsigned int mask = 0xff, t, rows[16] = {0,};\n\n\tj = a_log(bch, b);\n\tk = a_log(bch, a);\n\trows[0] = c;\n\n\t \n\tfor (i = 0; i < m; i++) {\n\t\trows[i+1] = bch->a_pow_tab[4*i]^\n\t\t\t(a ? bch->a_pow_tab[mod_s(bch, k)] : 0)^\n\t\t\t(b ? bch->a_pow_tab[mod_s(bch, j)] : 0);\n\t\tj++;\n\t\tk += 2;\n\t}\n\t \n\tfor (j = 8; j != 0; j >>= 1, mask ^= (mask << j)) {\n\t\tfor (k = 0; k < 16; k = (k+j+1) & ~j) {\n\t\t\tt = ((rows[k] >> j)^rows[k+j]) & mask;\n\t\t\trows[k] ^= (t << j);\n\t\t\trows[k+j] ^= t;\n\t\t}\n\t}\n\treturn solve_linear_system(bch, rows, roots, 4);\n}\n\n \nstatic int find_poly_deg1_roots(struct bch_control *bch, struct gf_poly *poly,\n\t\t\t\tunsigned int *roots)\n{\n\tint n = 0;\n\n\tif (poly->c[0])\n\t\t \n\t\troots[n++] = mod_s(bch, GF_N(bch)-bch->a_log_tab[poly->c[0]]+\n\t\t\t\t   bch->a_log_tab[poly->c[1]]);\n\treturn n;\n}\n\n \nstatic int find_poly_deg2_roots(struct bch_control *bch, struct gf_poly *poly,\n\t\t\t\tunsigned int *roots)\n{\n\tint n = 0, i, l0, l1, l2;\n\tunsigned int u, v, r;\n\n\tif (poly->c[0] && poly->c[1]) {\n\n\t\tl0 = bch->a_log_tab[poly->c[0]];\n\t\tl1 = bch->a_log_tab[poly->c[1]];\n\t\tl2 = bch->a_log_tab[poly->c[2]];\n\n\t\t \n\t\tu = a_pow(bch, l0+l2+2*(GF_N(bch)-l1));\n\t\t \n\t\tr = 0;\n\t\tv = u;\n\t\twhile (v) {\n\t\t\ti = deg(v);\n\t\t\tr ^= bch->xi_tab[i];\n\t\t\tv ^= (1 << i);\n\t\t}\n\t\t \n\t\tif ((gf_sqr(bch, r)^r) == u) {\n\t\t\t \n\t\t\troots[n++] = modulo(bch, 2*GF_N(bch)-l1-\n\t\t\t\t\t    bch->a_log_tab[r]+l2);\n\t\t\troots[n++] = modulo(bch, 2*GF_N(bch)-l1-\n\t\t\t\t\t    bch->a_log_tab[r^1]+l2);\n\t\t}\n\t}\n\treturn n;\n}\n\n \nstatic int find_poly_deg3_roots(struct bch_control *bch, struct gf_poly *poly,\n\t\t\t\tunsigned int *roots)\n{\n\tint i, n = 0;\n\tunsigned int a, b, c, a2, b2, c2, e3, tmp[4];\n\n\tif (poly->c[0]) {\n\t\t \n\t\te3 = poly->c[3];\n\t\tc2 = gf_div(bch, poly->c[0], e3);\n\t\tb2 = gf_div(bch, poly->c[1], e3);\n\t\ta2 = gf_div(bch, poly->c[2], e3);\n\n\t\t \n\t\tc = gf_mul(bch, a2, c2);            \n\t\tb = gf_mul(bch, a2, b2)^c2;         \n\t\ta = gf_sqr(bch, a2)^b2;             \n\n\t\t \n\t\tif (find_affine4_roots(bch, a, b, c, tmp) == 4) {\n\t\t\t \n\t\t\tfor (i = 0; i < 4; i++) {\n\t\t\t\tif (tmp[i] != a2)\n\t\t\t\t\troots[n++] = a_ilog(bch, tmp[i]);\n\t\t\t}\n\t\t}\n\t}\n\treturn n;\n}\n\n \nstatic int find_poly_deg4_roots(struct bch_control *bch, struct gf_poly *poly,\n\t\t\t\tunsigned int *roots)\n{\n\tint i, l, n = 0;\n\tunsigned int a, b, c, d, e = 0, f, a2, b2, c2, e4;\n\n\tif (poly->c[0] == 0)\n\t\treturn 0;\n\n\t \n\te4 = poly->c[4];\n\td = gf_div(bch, poly->c[0], e4);\n\tc = gf_div(bch, poly->c[1], e4);\n\tb = gf_div(bch, poly->c[2], e4);\n\ta = gf_div(bch, poly->c[3], e4);\n\n\t \n\tif (a) {\n\t\t \n\t\tif (c) {\n\t\t\t \n\t\t\tf = gf_div(bch, c, a);\n\t\t\tl = a_log(bch, f);\n\t\t\tl += (l & 1) ? GF_N(bch) : 0;\n\t\t\te = a_pow(bch, l/2);\n\t\t\t \n\t\t\td = a_pow(bch, 2*l)^gf_mul(bch, b, f)^d;\n\t\t\tb = gf_mul(bch, a, e)^b;\n\t\t}\n\t\t \n\t\tif (d == 0)\n\t\t\t \n\t\t\treturn 0;\n\n\t\tc2 = gf_inv(bch, d);\n\t\tb2 = gf_div(bch, a, d);\n\t\ta2 = gf_div(bch, b, d);\n\t} else {\n\t\t \n\t\tc2 = d;\n\t\tb2 = c;\n\t\ta2 = b;\n\t}\n\t \n\tif (find_affine4_roots(bch, a2, b2, c2, roots) == 4) {\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\t \n\t\t\tf = a ? gf_inv(bch, roots[i]) : roots[i];\n\t\t\troots[i] = a_ilog(bch, f^e);\n\t\t}\n\t\tn = 4;\n\t}\n\treturn n;\n}\n\n \nstatic void gf_poly_logrep(struct bch_control *bch,\n\t\t\t   const struct gf_poly *a, int *rep)\n{\n\tint i, d = a->deg, l = GF_N(bch)-a_log(bch, a->c[a->deg]);\n\n\t \n\tfor (i = 0; i < d; i++)\n\t\trep[i] = a->c[i] ? mod_s(bch, a_log(bch, a->c[i])+l) : -1;\n}\n\n \nstatic void gf_poly_mod(struct bch_control *bch, struct gf_poly *a,\n\t\t\tconst struct gf_poly *b, int *rep)\n{\n\tint la, p, m;\n\tunsigned int i, j, *c = a->c;\n\tconst unsigned int d = b->deg;\n\n\tif (a->deg < d)\n\t\treturn;\n\n\t \n\tif (!rep) {\n\t\trep = bch->cache;\n\t\tgf_poly_logrep(bch, b, rep);\n\t}\n\n\tfor (j = a->deg; j >= d; j--) {\n\t\tif (c[j]) {\n\t\t\tla = a_log(bch, c[j]);\n\t\t\tp = j-d;\n\t\t\tfor (i = 0; i < d; i++, p++) {\n\t\t\t\tm = rep[i];\n\t\t\t\tif (m >= 0)\n\t\t\t\t\tc[p] ^= bch->a_pow_tab[mod_s(bch,\n\t\t\t\t\t\t\t\t     m+la)];\n\t\t\t}\n\t\t}\n\t}\n\ta->deg = d-1;\n\twhile (!c[a->deg] && a->deg)\n\t\ta->deg--;\n}\n\n \nstatic void gf_poly_div(struct bch_control *bch, struct gf_poly *a,\n\t\t\tconst struct gf_poly *b, struct gf_poly *q)\n{\n\tif (a->deg >= b->deg) {\n\t\tq->deg = a->deg-b->deg;\n\t\t \n\t\tgf_poly_mod(bch, a, b, NULL);\n\t\t \n\t\tmemcpy(q->c, &a->c[b->deg], (1+q->deg)*sizeof(unsigned int));\n\t} else {\n\t\tq->deg = 0;\n\t\tq->c[0] = 0;\n\t}\n}\n\n \nstatic struct gf_poly *gf_poly_gcd(struct bch_control *bch, struct gf_poly *a,\n\t\t\t\t   struct gf_poly *b)\n{\n\tstruct gf_poly *tmp;\n\n\tdbg(\"gcd(%s,%s)=\", gf_poly_str(a), gf_poly_str(b));\n\n\tif (a->deg < b->deg) {\n\t\ttmp = b;\n\t\tb = a;\n\t\ta = tmp;\n\t}\n\n\twhile (b->deg > 0) {\n\t\tgf_poly_mod(bch, a, b, NULL);\n\t\ttmp = b;\n\t\tb = a;\n\t\ta = tmp;\n\t}\n\n\tdbg(\"%s\\n\", gf_poly_str(a));\n\n\treturn a;\n}\n\n \nstatic void compute_trace_bk_mod(struct bch_control *bch, int k,\n\t\t\t\t const struct gf_poly *f, struct gf_poly *z,\n\t\t\t\t struct gf_poly *out)\n{\n\tconst int m = GF_M(bch);\n\tint i, j;\n\n\t \n\tz->deg = 1;\n\tz->c[0] = 0;\n\tz->c[1] = bch->a_pow_tab[k];\n\n\tout->deg = 0;\n\tmemset(out, 0, GF_POLY_SZ(f->deg));\n\n\t \n\tgf_poly_logrep(bch, f, bch->cache);\n\n\tfor (i = 0; i < m; i++) {\n\t\t \n\t\tfor (j = z->deg; j >= 0; j--) {\n\t\t\tout->c[j] ^= z->c[j];\n\t\t\tz->c[2*j] = gf_sqr(bch, z->c[j]);\n\t\t\tz->c[2*j+1] = 0;\n\t\t}\n\t\tif (z->deg > out->deg)\n\t\t\tout->deg = z->deg;\n\n\t\tif (i < m-1) {\n\t\t\tz->deg *= 2;\n\t\t\t \n\t\t\tgf_poly_mod(bch, z, f, bch->cache);\n\t\t}\n\t}\n\twhile (!out->c[out->deg] && out->deg)\n\t\tout->deg--;\n\n\tdbg(\"Tr(a^%d.X) mod f = %s\\n\", k, gf_poly_str(out));\n}\n\n \nstatic void factor_polynomial(struct bch_control *bch, int k, struct gf_poly *f,\n\t\t\t      struct gf_poly **g, struct gf_poly **h)\n{\n\tstruct gf_poly *f2 = bch->poly_2t[0];\n\tstruct gf_poly *q  = bch->poly_2t[1];\n\tstruct gf_poly *tk = bch->poly_2t[2];\n\tstruct gf_poly *z  = bch->poly_2t[3];\n\tstruct gf_poly *gcd;\n\n\tdbg(\"factoring %s...\\n\", gf_poly_str(f));\n\n\t*g = f;\n\t*h = NULL;\n\n\t \n\tcompute_trace_bk_mod(bch, k, f, z, tk);\n\n\tif (tk->deg > 0) {\n\t\t \n\t\tgf_poly_copy(f2, f);\n\t\tgcd = gf_poly_gcd(bch, f2, tk);\n\t\tif (gcd->deg < f->deg) {\n\t\t\t \n\t\t\tgf_poly_div(bch, f, gcd, q);\n\t\t\t \n\t\t\t*h = &((struct gf_poly_deg1 *)f)[gcd->deg].poly;\n\t\t\tgf_poly_copy(*g, gcd);\n\t\t\tgf_poly_copy(*h, q);\n\t\t}\n\t}\n}\n\n \nstatic int find_poly_roots(struct bch_control *bch, unsigned int k,\n\t\t\t   struct gf_poly *poly, unsigned int *roots)\n{\n\tint cnt;\n\tstruct gf_poly *f1, *f2;\n\n\tswitch (poly->deg) {\n\t\t \n\tcase 1:\n\t\tcnt = find_poly_deg1_roots(bch, poly, roots);\n\t\tbreak;\n\tcase 2:\n\t\tcnt = find_poly_deg2_roots(bch, poly, roots);\n\t\tbreak;\n\tcase 3:\n\t\tcnt = find_poly_deg3_roots(bch, poly, roots);\n\t\tbreak;\n\tcase 4:\n\t\tcnt = find_poly_deg4_roots(bch, poly, roots);\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tcnt = 0;\n\t\tif (poly->deg && (k <= GF_M(bch))) {\n\t\t\tfactor_polynomial(bch, k, poly, &f1, &f2);\n\t\t\tif (f1)\n\t\t\t\tcnt += find_poly_roots(bch, k+1, f1, roots);\n\t\t\tif (f2)\n\t\t\t\tcnt += find_poly_roots(bch, k+1, f2, roots+cnt);\n\t\t}\n\t\tbreak;\n\t}\n\treturn cnt;\n}\n\n#if defined(USE_CHIEN_SEARCH)\n \nstatic int chien_search(struct bch_control *bch, unsigned int len,\n\t\t\tstruct gf_poly *p, unsigned int *roots)\n{\n\tint m;\n\tunsigned int i, j, syn, syn0, count = 0;\n\tconst unsigned int k = 8*len+bch->ecc_bits;\n\n\t \n\tgf_poly_logrep(bch, p, bch->cache);\n\tbch->cache[p->deg] = 0;\n\tsyn0 = gf_div(bch, p->c[0], p->c[p->deg]);\n\n\tfor (i = GF_N(bch)-k+1; i <= GF_N(bch); i++) {\n\t\t \n\t\tfor (j = 1, syn = syn0; j <= p->deg; j++) {\n\t\t\tm = bch->cache[j];\n\t\t\tif (m >= 0)\n\t\t\t\tsyn ^= a_pow(bch, m+j*i);\n\t\t}\n\t\tif (syn == 0) {\n\t\t\troots[count++] = GF_N(bch)-i;\n\t\t\tif (count == p->deg)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\treturn (count == p->deg) ? count : 0;\n}\n#define find_poly_roots(_p, _k, _elp, _loc) chien_search(_p, len, _elp, _loc)\n#endif  \n\n \nint bch_decode(struct bch_control *bch, const uint8_t *data, unsigned int len,\n\t       const uint8_t *recv_ecc, const uint8_t *calc_ecc,\n\t       const unsigned int *syn, unsigned int *errloc)\n{\n\tconst unsigned int ecc_words = BCH_ECC_WORDS(bch);\n\tunsigned int nbits;\n\tint i, err, nroots;\n\tuint32_t sum;\n\n\t \n\tif (8*len > (bch->n-bch->ecc_bits))\n\t\treturn -EINVAL;\n\n\t \n\tif (!syn) {\n\t\tif (!calc_ecc) {\n\t\t\t \n\t\t\tif (!data || !recv_ecc)\n\t\t\t\treturn -EINVAL;\n\t\t\tbch_encode(bch, data, len, NULL);\n\t\t} else {\n\t\t\t \n\t\t\tload_ecc8(bch, bch->ecc_buf, calc_ecc);\n\t\t}\n\t\t \n\t\tif (recv_ecc) {\n\t\t\tload_ecc8(bch, bch->ecc_buf2, recv_ecc);\n\t\t\t \n\t\t\tfor (i = 0, sum = 0; i < (int)ecc_words; i++) {\n\t\t\t\tbch->ecc_buf[i] ^= bch->ecc_buf2[i];\n\t\t\t\tsum |= bch->ecc_buf[i];\n\t\t\t}\n\t\t\tif (!sum)\n\t\t\t\t \n\t\t\t\treturn 0;\n\t\t}\n\t\tcompute_syndromes(bch, bch->ecc_buf, bch->syn);\n\t\tsyn = bch->syn;\n\t}\n\n\terr = compute_error_locator_polynomial(bch, syn);\n\tif (err > 0) {\n\t\tnroots = find_poly_roots(bch, 1, bch->elp, errloc);\n\t\tif (err != nroots)\n\t\t\terr = -1;\n\t}\n\tif (err > 0) {\n\t\t \n\t\tnbits = (len*8)+bch->ecc_bits;\n\t\tfor (i = 0; i < err; i++) {\n\t\t\tif (errloc[i] >= nbits) {\n\t\t\t\terr = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\terrloc[i] = nbits-1-errloc[i];\n\t\t\tif (!bch->swap_bits)\n\t\t\t\terrloc[i] = (errloc[i] & ~7) |\n\t\t\t\t\t    (7-(errloc[i] & 7));\n\t\t}\n\t}\n\treturn (err >= 0) ? err : -EBADMSG;\n}\nEXPORT_SYMBOL_GPL(bch_decode);\n\n \nstatic int build_gf_tables(struct bch_control *bch, unsigned int poly)\n{\n\tunsigned int i, x = 1;\n\tconst unsigned int k = 1 << deg(poly);\n\n\t \n\tif (k != (1u << GF_M(bch)))\n\t\treturn -1;\n\n\tfor (i = 0; i < GF_N(bch); i++) {\n\t\tbch->a_pow_tab[i] = x;\n\t\tbch->a_log_tab[x] = i;\n\t\tif (i && (x == 1))\n\t\t\t \n\t\t\treturn -1;\n\t\tx <<= 1;\n\t\tif (x & k)\n\t\t\tx ^= poly;\n\t}\n\tbch->a_pow_tab[GF_N(bch)] = 1;\n\tbch->a_log_tab[0] = 0;\n\n\treturn 0;\n}\n\n \nstatic void build_mod8_tables(struct bch_control *bch, const uint32_t *g)\n{\n\tint i, j, b, d;\n\tuint32_t data, hi, lo, *tab;\n\tconst int l = BCH_ECC_WORDS(bch);\n\tconst int plen = DIV_ROUND_UP(bch->ecc_bits+1, 32);\n\tconst int ecclen = DIV_ROUND_UP(bch->ecc_bits, 32);\n\n\tmemset(bch->mod8_tab, 0, 4*256*l*sizeof(*bch->mod8_tab));\n\n\tfor (i = 0; i < 256; i++) {\n\t\t \n\t\tfor (b = 0; b < 4; b++) {\n\t\t\t \n\t\t\ttab = bch->mod8_tab + (b*256+i)*l;\n\t\t\tdata = i << (8*b);\n\t\t\twhile (data) {\n\t\t\t\td = deg(data);\n\t\t\t\t \n\t\t\t\tdata ^= g[0] >> (31-d);\n\t\t\t\tfor (j = 0; j < ecclen; j++) {\n\t\t\t\t\thi = (d < 31) ? g[j] << (d+1) : 0;\n\t\t\t\t\tlo = (j+1 < plen) ?\n\t\t\t\t\t\tg[j+1] >> (31-d) : 0;\n\t\t\t\t\ttab[j] ^= hi|lo;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n \nstatic int build_deg2_base(struct bch_control *bch)\n{\n\tconst int m = GF_M(bch);\n\tint i, j, r;\n\tunsigned int sum, x, y, remaining, ak = 0, xi[BCH_MAX_M];\n\n\t \n\tfor (i = 0; i < m; i++) {\n\t\tfor (j = 0, sum = 0; j < m; j++)\n\t\t\tsum ^= a_pow(bch, i*(1 << j));\n\n\t\tif (sum) {\n\t\t\tak = bch->a_pow_tab[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\t \n\tremaining = m;\n\tmemset(xi, 0, sizeof(xi));\n\n\tfor (x = 0; (x <= GF_N(bch)) && remaining; x++) {\n\t\ty = gf_sqr(bch, x)^x;\n\t\tfor (i = 0; i < 2; i++) {\n\t\t\tr = a_log(bch, y);\n\t\t\tif (y && (r < m) && !xi[r]) {\n\t\t\t\tbch->xi_tab[r] = x;\n\t\t\t\txi[r] = 1;\n\t\t\t\tremaining--;\n\t\t\t\tdbg(\"x%d = %x\\n\", r, x);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ty ^= ak;\n\t\t}\n\t}\n\t \n\treturn remaining ? -1 : 0;\n}\n\nstatic void *bch_alloc(size_t size, int *err)\n{\n\tvoid *ptr;\n\n\tptr = kmalloc(size, GFP_KERNEL);\n\tif (ptr == NULL)\n\t\t*err = 1;\n\treturn ptr;\n}\n\n \nstatic uint32_t *compute_generator_polynomial(struct bch_control *bch)\n{\n\tconst unsigned int m = GF_M(bch);\n\tconst unsigned int t = GF_T(bch);\n\tint n, err = 0;\n\tunsigned int i, j, nbits, r, word, *roots;\n\tstruct gf_poly *g;\n\tuint32_t *genpoly;\n\n\tg = bch_alloc(GF_POLY_SZ(m*t), &err);\n\troots = bch_alloc((bch->n+1)*sizeof(*roots), &err);\n\tgenpoly = bch_alloc(DIV_ROUND_UP(m*t+1, 32)*sizeof(*genpoly), &err);\n\n\tif (err) {\n\t\tkfree(genpoly);\n\t\tgenpoly = NULL;\n\t\tgoto finish;\n\t}\n\n\t \n\tmemset(roots , 0, (bch->n+1)*sizeof(*roots));\n\tfor (i = 0; i < t; i++) {\n\t\tfor (j = 0, r = 2*i+1; j < m; j++) {\n\t\t\troots[r] = 1;\n\t\t\tr = mod_s(bch, 2*r);\n\t\t}\n\t}\n\t \n\tg->deg = 0;\n\tg->c[0] = 1;\n\tfor (i = 0; i < GF_N(bch); i++) {\n\t\tif (roots[i]) {\n\t\t\t \n\t\t\tr = bch->a_pow_tab[i];\n\t\t\tg->c[g->deg+1] = 1;\n\t\t\tfor (j = g->deg; j > 0; j--)\n\t\t\t\tg->c[j] = gf_mul(bch, g->c[j], r)^g->c[j-1];\n\n\t\t\tg->c[0] = gf_mul(bch, g->c[0], r);\n\t\t\tg->deg++;\n\t\t}\n\t}\n\t \n\tn = g->deg+1;\n\ti = 0;\n\n\twhile (n > 0) {\n\t\tnbits = (n > 32) ? 32 : n;\n\t\tfor (j = 0, word = 0; j < nbits; j++) {\n\t\t\tif (g->c[n-1-j])\n\t\t\t\tword |= 1u << (31-j);\n\t\t}\n\t\tgenpoly[i++] = word;\n\t\tn -= nbits;\n\t}\n\tbch->ecc_bits = g->deg;\n\nfinish:\n\tkfree(g);\n\tkfree(roots);\n\n\treturn genpoly;\n}\n\n \nstruct bch_control *bch_init(int m, int t, unsigned int prim_poly,\n\t\t\t     bool swap_bits)\n{\n\tint err = 0;\n\tunsigned int i, words;\n\tuint32_t *genpoly;\n\tstruct bch_control *bch = NULL;\n\n\tconst int min_m = 5;\n\n\t \n\tstatic const unsigned int prim_poly_tab[] = {\n\t\t0x25, 0x43, 0x83, 0x11d, 0x211, 0x409, 0x805, 0x1053, 0x201b,\n\t\t0x402b, 0x8003,\n\t};\n\n#if defined(CONFIG_BCH_CONST_PARAMS)\n\tif ((m != (CONFIG_BCH_CONST_M)) || (t != (CONFIG_BCH_CONST_T))) {\n\t\tprintk(KERN_ERR \"bch encoder/decoder was configured to support \"\n\t\t       \"parameters m=%d, t=%d only!\\n\",\n\t\t       CONFIG_BCH_CONST_M, CONFIG_BCH_CONST_T);\n\t\tgoto fail;\n\t}\n#endif\n\tif ((m < min_m) || (m > BCH_MAX_M))\n\t\t \n\t\tgoto fail;\n\n\tif (t > BCH_MAX_T)\n\t\t \n\t\tgoto fail;\n\n\t \n\tif ((t < 1) || (m*t >= ((1 << m)-1)))\n\t\t \n\t\tgoto fail;\n\n\t \n\tif (prim_poly == 0)\n\t\tprim_poly = prim_poly_tab[m-min_m];\n\n\tbch = kzalloc(sizeof(*bch), GFP_KERNEL);\n\tif (bch == NULL)\n\t\tgoto fail;\n\n\tbch->m = m;\n\tbch->t = t;\n\tbch->n = (1 << m)-1;\n\twords  = DIV_ROUND_UP(m*t, 32);\n\tbch->ecc_bytes = DIV_ROUND_UP(m*t, 8);\n\tbch->a_pow_tab = bch_alloc((1+bch->n)*sizeof(*bch->a_pow_tab), &err);\n\tbch->a_log_tab = bch_alloc((1+bch->n)*sizeof(*bch->a_log_tab), &err);\n\tbch->mod8_tab  = bch_alloc(words*1024*sizeof(*bch->mod8_tab), &err);\n\tbch->ecc_buf   = bch_alloc(words*sizeof(*bch->ecc_buf), &err);\n\tbch->ecc_buf2  = bch_alloc(words*sizeof(*bch->ecc_buf2), &err);\n\tbch->xi_tab    = bch_alloc(m*sizeof(*bch->xi_tab), &err);\n\tbch->syn       = bch_alloc(2*t*sizeof(*bch->syn), &err);\n\tbch->cache     = bch_alloc(2*t*sizeof(*bch->cache), &err);\n\tbch->elp       = bch_alloc((t+1)*sizeof(struct gf_poly_deg1), &err);\n\tbch->swap_bits = swap_bits;\n\n\tfor (i = 0; i < ARRAY_SIZE(bch->poly_2t); i++)\n\t\tbch->poly_2t[i] = bch_alloc(GF_POLY_SZ(2*t), &err);\n\n\tif (err)\n\t\tgoto fail;\n\n\terr = build_gf_tables(bch, prim_poly);\n\tif (err)\n\t\tgoto fail;\n\n\t \n\tgenpoly = compute_generator_polynomial(bch);\n\tif (genpoly == NULL)\n\t\tgoto fail;\n\n\tbuild_mod8_tables(bch, genpoly);\n\tkfree(genpoly);\n\n\terr = build_deg2_base(bch);\n\tif (err)\n\t\tgoto fail;\n\n\treturn bch;\n\nfail:\n\tbch_free(bch);\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(bch_init);\n\n \nvoid bch_free(struct bch_control *bch)\n{\n\tunsigned int i;\n\n\tif (bch) {\n\t\tkfree(bch->a_pow_tab);\n\t\tkfree(bch->a_log_tab);\n\t\tkfree(bch->mod8_tab);\n\t\tkfree(bch->ecc_buf);\n\t\tkfree(bch->ecc_buf2);\n\t\tkfree(bch->xi_tab);\n\t\tkfree(bch->syn);\n\t\tkfree(bch->cache);\n\t\tkfree(bch->elp);\n\n\t\tfor (i = 0; i < ARRAY_SIZE(bch->poly_2t); i++)\n\t\t\tkfree(bch->poly_2t[i]);\n\n\t\tkfree(bch);\n\t}\n}\nEXPORT_SYMBOL_GPL(bch_free);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Ivan Djelic <ivan.djelic@parrot.com>\");\nMODULE_DESCRIPTION(\"Binary BCH encoder/decoder\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}