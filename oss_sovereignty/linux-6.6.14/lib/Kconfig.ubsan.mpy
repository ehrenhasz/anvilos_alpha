{
  "module_name": "Kconfig.ubsan",
  "hash_id": "79165b18b4cac2d848ed9764710436fa1283b838d06d41d43c7c5329fdcf4da1",
  "original_prompt": "Ingested from linux-6.6.14/lib/Kconfig.ubsan",
  "human_readable_source": "# SPDX-License-Identifier: GPL-2.0-only\nconfig ARCH_HAS_UBSAN_SANITIZE_ALL\n\tbool\n\nmenuconfig UBSAN\n\tbool \"Undefined behaviour sanity checker\"\n\thelp\n\t  This option enables the Undefined Behaviour sanity checker.\n\t  Compile-time instrumentation is used to detect various undefined\n\t  behaviours at runtime. For more details, see:\n\t  Documentation/dev-tools/ubsan.rst\n\nif UBSAN\n\nconfig UBSAN_TRAP\n\tbool \"Abort on Sanitizer warnings (smaller kernel but less verbose)\"\n\tdepends on !COMPILE_TEST\n\thelp\n\t  Building kernels with Sanitizer features enabled tends to grow\n\t  the kernel size by around 5%, due to adding all the debugging\n\t  text on failure paths. To avoid this, Sanitizer instrumentation\n\t  can just issue a trap. This reduces the kernel size overhead but\n\t  turns all warnings (including potentially harmless conditions)\n\t  into full exceptions that abort the running kernel code\n\t  (regardless of context, locks held, etc), which may destabilize\n\t  the system. For some system builders this is an acceptable\n\t  trade-off.\n\n\t  Also note that selecting Y will cause your kernel to Oops\n\t  with an \"illegal instruction\" error with no further details\n\t  when a UBSAN violation occurs. (Except on arm64, which will\n\t  report which Sanitizer failed.) This may make it hard to\n\t  determine whether an Oops was caused by UBSAN or to figure\n\t  out the details of a UBSAN violation. It makes the kernel log\n\t  output less useful for bug reports.\n\nconfig CC_HAS_UBSAN_BOUNDS_STRICT\n\tdef_bool $(cc-option,-fsanitize=bounds-strict)\n\thelp\n\t  The -fsanitize=bounds-strict option is only available on GCC,\n\t  but uses the more strict handling of arrays that includes knowledge\n\t  of flexible arrays, which is comparable to Clang's regular\n\t  -fsanitize=bounds.\n\nconfig CC_HAS_UBSAN_ARRAY_BOUNDS\n\tdef_bool $(cc-option,-fsanitize=array-bounds)\n\thelp\n\t  Under Clang, the -fsanitize=bounds option is actually composed\n\t  of two more specific options, -fsanitize=array-bounds and\n\t  -fsanitize=local-bounds. However, -fsanitize=local-bounds can\n\t  only be used when trap mode is enabled. (See also the help for\n\t  CONFIG_LOCAL_BOUNDS.) Explicitly check for -fsanitize=array-bounds\n\t  so that we can build up the options needed for UBSAN_BOUNDS\n\t  with or without UBSAN_TRAP.\n\nconfig UBSAN_BOUNDS\n\tbool \"Perform array index bounds checking\"\n\tdefault UBSAN\n\tdepends on CC_HAS_UBSAN_ARRAY_BOUNDS || CC_HAS_UBSAN_BOUNDS_STRICT\n\thelp\n\t  This option enables detection of directly indexed out of bounds\n\t  array accesses, where the array size is known at compile time.\n\t  Note that this does not protect array overflows via bad calls\n\t  to the {str,mem}*cpy() family of functions (that is addressed\n\t  by CONFIG_FORTIFY_SOURCE).\n\nconfig UBSAN_BOUNDS_STRICT\n\tdef_bool UBSAN_BOUNDS && CC_HAS_UBSAN_BOUNDS_STRICT\n\thelp\n\t  GCC's bounds sanitizer. This option is used to select the\n\t  correct options in Makefile.ubsan.\n\nconfig UBSAN_ARRAY_BOUNDS\n\tdef_bool UBSAN_BOUNDS && CC_HAS_UBSAN_ARRAY_BOUNDS\n\thelp\n\t  Clang's array bounds sanitizer. This option is used to select\n\t  the correct options in Makefile.ubsan.\n\nconfig UBSAN_LOCAL_BOUNDS\n\tdef_bool UBSAN_ARRAY_BOUNDS && UBSAN_TRAP\n\thelp\n\t  This option enables Clang's -fsanitize=local-bounds which traps\n\t  when an access through a pointer that is derived from an object\n\t  of a statically-known size, where an added offset (which may not\n\t  be known statically) is out-of-bounds. Since this option is\n\t  trap-only, it depends on CONFIG_UBSAN_TRAP.\n\nconfig UBSAN_SHIFT\n\tbool \"Perform checking for bit-shift overflows\"\n\tdefault UBSAN\n\tdepends on $(cc-option,-fsanitize=shift)\n\thelp\n\t  This option enables -fsanitize=shift which checks for bit-shift\n\t  operations that overflow to the left or go switch to negative\n\t  for signed types.\n\nconfig UBSAN_DIV_ZERO\n\tbool \"Perform checking for integer divide-by-zero\"\n\tdepends on $(cc-option,-fsanitize=integer-divide-by-zero)\n\t# https://github.com/ClangBuiltLinux/linux/issues/1657\n\t# https://github.com/llvm/llvm-project/issues/56289\n\tdepends on !CC_IS_CLANG\n\thelp\n\t  This option enables -fsanitize=integer-divide-by-zero which checks\n\t  for integer division by zero. This is effectively redundant with the\n\t  kernel's existing exception handling, though it can provide greater\n\t  debugging information under CONFIG_UBSAN_REPORT_FULL.\n\nconfig UBSAN_UNREACHABLE\n\tbool \"Perform checking for unreachable code\"\n\t# objtool already handles unreachable checking and gets angry about\n\t# seeing UBSan instrumentation located in unreachable places.\n\tdepends on !(OBJTOOL && (STACK_VALIDATION || UNWINDER_ORC || HAVE_UACCESS_VALIDATION))\n\tdepends on $(cc-option,-fsanitize=unreachable)\n\thelp\n\t  This option enables -fsanitize=unreachable which checks for control\n\t  flow reaching an expected-to-be-unreachable position.\n\nconfig UBSAN_BOOL\n\tbool \"Perform checking for non-boolean values used as boolean\"\n\tdefault UBSAN\n\tdepends on $(cc-option,-fsanitize=bool)\n\thelp\n\t  This option enables -fsanitize=bool which checks for boolean values being\n\t  loaded that are neither 0 nor 1.\n\nconfig UBSAN_ENUM\n\tbool \"Perform checking for out of bounds enum values\"\n\tdefault UBSAN\n\tdepends on $(cc-option,-fsanitize=enum)\n\thelp\n\t  This option enables -fsanitize=enum which checks for values being loaded\n\t  into an enum that are outside the range of given values for the given enum.\n\nconfig UBSAN_ALIGNMENT\n\tbool \"Perform checking for misaligned pointer usage\"\n\tdefault !HAVE_EFFICIENT_UNALIGNED_ACCESS\n\tdepends on !UBSAN_TRAP && !COMPILE_TEST\n\tdepends on $(cc-option,-fsanitize=alignment)\n\thelp\n\t  This option enables the check of unaligned memory accesses.\n\t  Enabling this option on architectures that support unaligned\n\t  accesses may produce a lot of false positives.\n\nconfig UBSAN_SANITIZE_ALL\n\tbool \"Enable instrumentation for the entire kernel\"\n\tdepends on ARCH_HAS_UBSAN_SANITIZE_ALL\n\tdefault y\n\thelp\n\t  This option activates instrumentation for the entire kernel.\n\t  If you don't enable this option, you have to explicitly specify\n\t  UBSAN_SANITIZE := y for the files/directories you want to check for UB.\n\t  Enabling this option will get kernel image size increased\n\t  significantly.\n\nconfig TEST_UBSAN\n\ttristate \"Module for testing for undefined behavior detection\"\n\tdepends on m\n\thelp\n\t  This is a test module for UBSAN.\n\t  It triggers various undefined behavior, and detect it.\n\nendif\t# if UBSAN\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}