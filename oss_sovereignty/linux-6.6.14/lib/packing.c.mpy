{
  "module_name": "packing.c",
  "hash_id": "04f7df0322408a9ec8657d77f6c9a0db180435801c0770f2f421f0ad8c567f38",
  "original_prompt": "Ingested from linux-6.6.14/lib/packing.c",
  "human_readable_source": "\n \n#include <linux/packing.h>\n#include <linux/module.h>\n#include <linux/bitops.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/bitrev.h>\n\nstatic int get_le_offset(int offset)\n{\n\tint closest_multiple_of_4;\n\n\tclosest_multiple_of_4 = (offset / 4) * 4;\n\toffset -= closest_multiple_of_4;\n\treturn closest_multiple_of_4 + (3 - offset);\n}\n\nstatic int get_reverse_lsw32_offset(int offset, size_t len)\n{\n\tint closest_multiple_of_4;\n\tint word_index;\n\n\tword_index = offset / 4;\n\tclosest_multiple_of_4 = word_index * 4;\n\toffset -= closest_multiple_of_4;\n\tword_index = (len / 4) - word_index - 1;\n\treturn word_index * 4 + offset;\n}\n\nstatic void adjust_for_msb_right_quirk(u64 *to_write, int *box_start_bit,\n\t\t\t\t       int *box_end_bit, u8 *box_mask)\n{\n\tint box_bit_width = *box_start_bit - *box_end_bit + 1;\n\tint new_box_start_bit, new_box_end_bit;\n\n\t*to_write >>= *box_end_bit;\n\t*to_write = bitrev8(*to_write) >> (8 - box_bit_width);\n\t*to_write <<= *box_end_bit;\n\n\tnew_box_end_bit   = box_bit_width - *box_start_bit - 1;\n\tnew_box_start_bit = box_bit_width - *box_end_bit - 1;\n\t*box_mask = GENMASK_ULL(new_box_start_bit, new_box_end_bit);\n\t*box_start_bit = new_box_start_bit;\n\t*box_end_bit   = new_box_end_bit;\n}\n\n \nint packing(void *pbuf, u64 *uval, int startbit, int endbit, size_t pbuflen,\n\t    enum packing_op op, u8 quirks)\n{\n\t \n\tu64 value_width;\n\t \n\tint plogical_first_u8, plogical_last_u8, box;\n\n\t \n\tif (startbit < endbit)\n\t\t \n\t\treturn -EINVAL;\n\n\tvalue_width = startbit - endbit + 1;\n\tif (value_width > 64)\n\t\treturn -ERANGE;\n\n\t \n\tif (op == PACK && value_width < 64 && (*uval >= (1ull << value_width)))\n\t\t \n\t\treturn -ERANGE;\n\n\t \n\tif (op == UNPACK)\n\t\t*uval = 0;\n\n\t \n\tplogical_first_u8 = startbit / 8;\n\tplogical_last_u8  = endbit / 8;\n\n\tfor (box = plogical_first_u8; box >= plogical_last_u8; box--) {\n\t\t \n\t\tint box_start_bit, box_end_bit, box_addr;\n\t\tu8  box_mask;\n\t\t \n\t\tint proj_start_bit, proj_end_bit;\n\t\tu64 proj_mask;\n\n\t\t \n\t\tif (box == plogical_first_u8)\n\t\t\tbox_start_bit = startbit % 8;\n\t\telse\n\t\t\tbox_start_bit = 7;\n\t\tif (box == plogical_last_u8)\n\t\t\tbox_end_bit = endbit % 8;\n\t\telse\n\t\t\tbox_end_bit = 0;\n\n\t\t \n\t\tproj_start_bit = ((box * 8) + box_start_bit) - endbit;\n\t\tproj_end_bit   = ((box * 8) + box_end_bit) - endbit;\n\t\tproj_mask = GENMASK_ULL(proj_start_bit, proj_end_bit);\n\t\tbox_mask  = GENMASK_ULL(box_start_bit, box_end_bit);\n\n\t\t \n\t\tbox_addr = pbuflen - box - 1;\n\t\tif (quirks & QUIRK_LITTLE_ENDIAN)\n\t\t\tbox_addr = get_le_offset(box_addr);\n\t\tif (quirks & QUIRK_LSW32_IS_FIRST)\n\t\t\tbox_addr = get_reverse_lsw32_offset(box_addr,\n\t\t\t\t\t\t\t    pbuflen);\n\n\t\tif (op == UNPACK) {\n\t\t\tu64 pval;\n\n\t\t\t \n\t\t\tpval = ((u8 *)pbuf)[box_addr] & box_mask;\n\t\t\tif (quirks & QUIRK_MSB_ON_THE_RIGHT)\n\t\t\t\tadjust_for_msb_right_quirk(&pval,\n\t\t\t\t\t\t\t   &box_start_bit,\n\t\t\t\t\t\t\t   &box_end_bit,\n\t\t\t\t\t\t\t   &box_mask);\n\n\t\t\tpval >>= box_end_bit;\n\t\t\tpval <<= proj_end_bit;\n\t\t\t*uval &= ~proj_mask;\n\t\t\t*uval |= pval;\n\t\t} else {\n\t\t\tu64 pval;\n\n\t\t\t \n\t\t\tpval = (*uval) & proj_mask;\n\t\t\tpval >>= proj_end_bit;\n\t\t\tif (quirks & QUIRK_MSB_ON_THE_RIGHT)\n\t\t\t\tadjust_for_msb_right_quirk(&pval,\n\t\t\t\t\t\t\t   &box_start_bit,\n\t\t\t\t\t\t\t   &box_end_bit,\n\t\t\t\t\t\t\t   &box_mask);\n\n\t\t\tpval <<= box_end_bit;\n\t\t\t((u8 *)pbuf)[box_addr] &= ~box_mask;\n\t\t\t((u8 *)pbuf)[box_addr] |= pval;\n\t\t}\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL(packing);\n\nMODULE_DESCRIPTION(\"Generic bitfield packing and unpacking\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}