{
  "module_name": "test_rhashtable.c",
  "hash_id": "b46f18bc0f72cbc2beb7942c7c4701addbcac695e290f28af2fbf5eca99961ea",
  "original_prompt": "Ingested from linux-6.6.14/lib/test_rhashtable.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/rcupdate.h>\n#include <linux/rhashtable.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/wait.h>\n\n#define MAX_ENTRIES\t1000000\n#define TEST_INSERT_FAIL INT_MAX\n\nstatic int parm_entries = 50000;\nmodule_param(parm_entries, int, 0);\nMODULE_PARM_DESC(parm_entries, \"Number of entries to add (default: 50000)\");\n\nstatic int runs = 4;\nmodule_param(runs, int, 0);\nMODULE_PARM_DESC(runs, \"Number of test runs per variant (default: 4)\");\n\nstatic int max_size = 0;\nmodule_param(max_size, int, 0);\nMODULE_PARM_DESC(max_size, \"Maximum table size (default: calculated)\");\n\nstatic bool shrinking = false;\nmodule_param(shrinking, bool, 0);\nMODULE_PARM_DESC(shrinking, \"Enable automatic shrinking (default: off)\");\n\nstatic int size = 8;\nmodule_param(size, int, 0);\nMODULE_PARM_DESC(size, \"Initial size hint of table (default: 8)\");\n\nstatic int tcount = 10;\nmodule_param(tcount, int, 0);\nMODULE_PARM_DESC(tcount, \"Number of threads to spawn (default: 10)\");\n\nstatic bool enomem_retry = false;\nmodule_param(enomem_retry, bool, 0);\nMODULE_PARM_DESC(enomem_retry, \"Retry insert even if -ENOMEM was returned (default: off)\");\n\nstruct test_obj_val {\n\tint\tid;\n\tint\ttid;\n};\n\nstruct test_obj {\n\tstruct test_obj_val\tvalue;\n\tstruct rhash_head\tnode;\n};\n\nstruct test_obj_rhl {\n\tstruct test_obj_val\tvalue;\n\tstruct rhlist_head\tlist_node;\n};\n\nstruct thread_data {\n\tunsigned int entries;\n\tint id;\n\tstruct task_struct *task;\n\tstruct test_obj *objs;\n};\n\nstatic u32 my_hashfn(const void *data, u32 len, u32 seed)\n{\n\tconst struct test_obj_rhl *obj = data;\n\n\treturn (obj->value.id % 10);\n}\n\nstatic int my_cmpfn(struct rhashtable_compare_arg *arg, const void *obj)\n{\n\tconst struct test_obj_rhl *test_obj = obj;\n\tconst struct test_obj_val *val = arg->key;\n\n\treturn test_obj->value.id - val->id;\n}\n\nstatic struct rhashtable_params test_rht_params = {\n\t.head_offset = offsetof(struct test_obj, node),\n\t.key_offset = offsetof(struct test_obj, value),\n\t.key_len = sizeof(struct test_obj_val),\n\t.hashfn = jhash,\n};\n\nstatic struct rhashtable_params test_rht_params_dup = {\n\t.head_offset = offsetof(struct test_obj_rhl, list_node),\n\t.key_offset = offsetof(struct test_obj_rhl, value),\n\t.key_len = sizeof(struct test_obj_val),\n\t.hashfn = jhash,\n\t.obj_hashfn = my_hashfn,\n\t.obj_cmpfn = my_cmpfn,\n\t.nelem_hint = 128,\n\t.automatic_shrinking = false,\n};\n\nstatic atomic_t startup_count;\nstatic DECLARE_WAIT_QUEUE_HEAD(startup_wait);\n\nstatic int insert_retry(struct rhashtable *ht, struct test_obj *obj,\n                        const struct rhashtable_params params)\n{\n\tint err, retries = -1, enomem_retries = 0;\n\n\tdo {\n\t\tretries++;\n\t\tcond_resched();\n\t\terr = rhashtable_insert_fast(ht, &obj->node, params);\n\t\tif (err == -ENOMEM && enomem_retry) {\n\t\t\tenomem_retries++;\n\t\t\terr = -EBUSY;\n\t\t}\n\t} while (err == -EBUSY);\n\n\tif (enomem_retries)\n\t\tpr_info(\" %u insertions retried after -ENOMEM\\n\",\n\t\t\tenomem_retries);\n\n\treturn err ? : retries;\n}\n\nstatic int __init test_rht_lookup(struct rhashtable *ht, struct test_obj *array,\n\t\t\t\t  unsigned int entries)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < entries; i++) {\n\t\tstruct test_obj *obj;\n\t\tbool expected = !(i % 2);\n\t\tstruct test_obj_val key = {\n\t\t\t.id = i,\n\t\t};\n\n\t\tif (array[i / 2].value.id == TEST_INSERT_FAIL)\n\t\t\texpected = false;\n\n\t\tobj = rhashtable_lookup_fast(ht, &key, test_rht_params);\n\n\t\tif (expected && !obj) {\n\t\t\tpr_warn(\"Test failed: Could not find key %u\\n\", key.id);\n\t\t\treturn -ENOENT;\n\t\t} else if (!expected && obj) {\n\t\t\tpr_warn(\"Test failed: Unexpected entry found for key %u\\n\",\n\t\t\t\tkey.id);\n\t\t\treturn -EEXIST;\n\t\t} else if (expected && obj) {\n\t\t\tif (obj->value.id != i) {\n\t\t\t\tpr_warn(\"Test failed: Lookup value mismatch %u!=%u\\n\",\n\t\t\t\t\tobj->value.id, i);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\n\t\tcond_resched_rcu();\n\t}\n\n\treturn 0;\n}\n\nstatic void test_bucket_stats(struct rhashtable *ht, unsigned int entries)\n{\n\tunsigned int total = 0, chain_len = 0;\n\tstruct rhashtable_iter hti;\n\tstruct rhash_head *pos;\n\n\trhashtable_walk_enter(ht, &hti);\n\trhashtable_walk_start(&hti);\n\n\twhile ((pos = rhashtable_walk_next(&hti))) {\n\t\tif (PTR_ERR(pos) == -EAGAIN) {\n\t\t\tpr_info(\"Info: encountered resize\\n\");\n\t\t\tchain_len++;\n\t\t\tcontinue;\n\t\t} else if (IS_ERR(pos)) {\n\t\t\tpr_warn(\"Test failed: rhashtable_walk_next() error: %ld\\n\",\n\t\t\t\tPTR_ERR(pos));\n\t\t\tbreak;\n\t\t}\n\n\t\ttotal++;\n\t}\n\n\trhashtable_walk_stop(&hti);\n\trhashtable_walk_exit(&hti);\n\n\tpr_info(\"  Traversal complete: counted=%u, nelems=%u, entries=%d, table-jumps=%u\\n\",\n\t\ttotal, atomic_read(&ht->nelems), entries, chain_len);\n\n\tif (total != atomic_read(&ht->nelems) || total != entries)\n\t\tpr_warn(\"Test failed: Total count mismatch ^^^\");\n}\n\nstatic s64 __init test_rhashtable(struct rhashtable *ht, struct test_obj *array,\n\t\t\t\t  unsigned int entries)\n{\n\tstruct test_obj *obj;\n\tint err;\n\tunsigned int i, insert_retries = 0;\n\ts64 start, end;\n\n\t \n\tpr_info(\"  Adding %d keys\\n\", entries);\n\tstart = ktime_get_ns();\n\tfor (i = 0; i < entries; i++) {\n\t\tstruct test_obj *obj = &array[i];\n\n\t\tobj->value.id = i * 2;\n\t\terr = insert_retry(ht, obj, test_rht_params);\n\t\tif (err > 0)\n\t\t\tinsert_retries += err;\n\t\telse if (err)\n\t\t\treturn err;\n\t}\n\n\tif (insert_retries)\n\t\tpr_info(\"  %u insertions retried due to memory pressure\\n\",\n\t\t\tinsert_retries);\n\n\ttest_bucket_stats(ht, entries);\n\trcu_read_lock();\n\ttest_rht_lookup(ht, array, entries);\n\trcu_read_unlock();\n\n\ttest_bucket_stats(ht, entries);\n\n\tpr_info(\"  Deleting %d keys\\n\", entries);\n\tfor (i = 0; i < entries; i++) {\n\t\tstruct test_obj_val key = {\n\t\t\t.id = i * 2,\n\t\t};\n\n\t\tif (array[i].value.id != TEST_INSERT_FAIL) {\n\t\t\tobj = rhashtable_lookup_fast(ht, &key, test_rht_params);\n\t\t\tBUG_ON(!obj);\n\n\t\t\trhashtable_remove_fast(ht, &obj->node, test_rht_params);\n\t\t}\n\n\t\tcond_resched();\n\t}\n\n\tend = ktime_get_ns();\n\tpr_info(\"  Duration of test: %lld ns\\n\", end - start);\n\n\treturn end - start;\n}\n\nstatic struct rhashtable ht;\nstatic struct rhltable rhlt;\n\nstatic int __init test_rhltable(unsigned int entries)\n{\n\tstruct test_obj_rhl *rhl_test_objects;\n\tunsigned long *obj_in_table;\n\tunsigned int i, j, k;\n\tint ret, err;\n\n\tif (entries == 0)\n\t\tentries = 1;\n\n\trhl_test_objects = vzalloc(array_size(entries,\n\t\t\t\t\t      sizeof(*rhl_test_objects)));\n\tif (!rhl_test_objects)\n\t\treturn -ENOMEM;\n\n\tret = -ENOMEM;\n\tobj_in_table = vzalloc(array_size(sizeof(unsigned long),\n\t\t\t\t\t  BITS_TO_LONGS(entries)));\n\tif (!obj_in_table)\n\t\tgoto out_free;\n\n\terr = rhltable_init(&rhlt, &test_rht_params);\n\tif (WARN_ON(err))\n\t\tgoto out_free;\n\n\tk = get_random_u32();\n\tret = 0;\n\tfor (i = 0; i < entries; i++) {\n\t\trhl_test_objects[i].value.id = k;\n\t\terr = rhltable_insert(&rhlt, &rhl_test_objects[i].list_node,\n\t\t\t\t      test_rht_params);\n\t\tif (WARN(err, \"error %d on element %d\\n\", err, i))\n\t\t\tbreak;\n\t\tif (err == 0)\n\t\t\tset_bit(i, obj_in_table);\n\t}\n\n\tif (err)\n\t\tret = err;\n\n\tpr_info(\"test %d add/delete pairs into rhlist\\n\", entries);\n\tfor (i = 0; i < entries; i++) {\n\t\tstruct rhlist_head *h, *pos;\n\t\tstruct test_obj_rhl *obj;\n\t\tstruct test_obj_val key = {\n\t\t\t.id = k,\n\t\t};\n\t\tbool found;\n\n\t\trcu_read_lock();\n\t\th = rhltable_lookup(&rhlt, &key, test_rht_params);\n\t\tif (WARN(!h, \"key not found during iteration %d of %d\", i, entries)) {\n\t\t\trcu_read_unlock();\n\t\t\tbreak;\n\t\t}\n\n\t\tif (i) {\n\t\t\tj = i - 1;\n\t\t\trhl_for_each_entry_rcu(obj, pos, h, list_node) {\n\t\t\t\tif (WARN(pos == &rhl_test_objects[j].list_node, \"old element found, should be gone\"))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tcond_resched_rcu();\n\n\t\tfound = false;\n\n\t\trhl_for_each_entry_rcu(obj, pos, h, list_node) {\n\t\t\tif (pos == &rhl_test_objects[i].list_node) {\n\t\t\t\tfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\trcu_read_unlock();\n\n\t\tif (WARN(!found, \"element %d not found\", i))\n\t\t\tbreak;\n\n\t\terr = rhltable_remove(&rhlt, &rhl_test_objects[i].list_node, test_rht_params);\n\t\tWARN(err, \"rhltable_remove: err %d for iteration %d\\n\", err, i);\n\t\tif (err == 0)\n\t\t\tclear_bit(i, obj_in_table);\n\t}\n\n\tif (ret == 0 && err)\n\t\tret = err;\n\n\tfor (i = 0; i < entries; i++) {\n\t\tWARN(test_bit(i, obj_in_table), \"elem %d allegedly still present\", i);\n\n\t\terr = rhltable_insert(&rhlt, &rhl_test_objects[i].list_node,\n\t\t\t\t      test_rht_params);\n\t\tif (WARN(err, \"error %d on element %d\\n\", err, i))\n\t\t\tbreak;\n\t\tif (err == 0)\n\t\t\tset_bit(i, obj_in_table);\n\t}\n\n\tpr_info(\"test %d random rhlist add/delete operations\\n\", entries);\n\tfor (j = 0; j < entries; j++) {\n\t\tu32 i = get_random_u32_below(entries);\n\t\tu32 prand = get_random_u32_below(4);\n\n\t\tcond_resched();\n\n\t\terr = rhltable_remove(&rhlt, &rhl_test_objects[i].list_node, test_rht_params);\n\t\tif (test_bit(i, obj_in_table)) {\n\t\t\tclear_bit(i, obj_in_table);\n\t\t\tif (WARN(err, \"cannot remove element at slot %d\", i))\n\t\t\t\tcontinue;\n\t\t} else {\n\t\t\tif (WARN(err != -ENOENT, \"removed non-existent element %d, error %d not %d\",\n\t\t\t     i, err, -ENOENT))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif (prand & 1) {\n\t\t\terr = rhltable_insert(&rhlt, &rhl_test_objects[i].list_node, test_rht_params);\n\t\t\tif (err == 0) {\n\t\t\t\tif (WARN(test_and_set_bit(i, obj_in_table), \"succeeded to insert same object %d\", i))\n\t\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tif (WARN(!test_bit(i, obj_in_table), \"failed to insert object %d\", i))\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tif (prand & 2) {\n\t\t\ti = get_random_u32_below(entries);\n\t\t\tif (test_bit(i, obj_in_table)) {\n\t\t\t\terr = rhltable_remove(&rhlt, &rhl_test_objects[i].list_node, test_rht_params);\n\t\t\t\tWARN(err, \"cannot remove element at slot %d\", i);\n\t\t\t\tif (err == 0)\n\t\t\t\t\tclear_bit(i, obj_in_table);\n\t\t\t} else {\n\t\t\t\terr = rhltable_insert(&rhlt, &rhl_test_objects[i].list_node, test_rht_params);\n\t\t\t\tWARN(err, \"failed to insert object %d\", i);\n\t\t\t\tif (err == 0)\n\t\t\t\t\tset_bit(i, obj_in_table);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (i = 0; i < entries; i++) {\n\t\tcond_resched();\n\t\terr = rhltable_remove(&rhlt, &rhl_test_objects[i].list_node, test_rht_params);\n\t\tif (test_bit(i, obj_in_table)) {\n\t\t\tif (WARN(err, \"cannot remove element at slot %d\", i))\n\t\t\t\tcontinue;\n\t\t} else {\n\t\t\tif (WARN(err != -ENOENT, \"removed non-existent element, error %d not %d\",\n\t\t\t\t err, -ENOENT))\n\t\t\t\tcontinue;\n\t\t}\n\t}\n\n\trhltable_destroy(&rhlt);\nout_free:\n\tvfree(rhl_test_objects);\n\tvfree(obj_in_table);\n\treturn ret;\n}\n\nstatic int __init test_rhashtable_max(struct test_obj *array,\n\t\t\t\t      unsigned int entries)\n{\n\tunsigned int i;\n\tint err;\n\n\ttest_rht_params.max_size = roundup_pow_of_two(entries / 8);\n\terr = rhashtable_init(&ht, &test_rht_params);\n\tif (err)\n\t\treturn err;\n\n\tfor (i = 0; i < ht.max_elems; i++) {\n\t\tstruct test_obj *obj = &array[i];\n\n\t\tobj->value.id = i * 2;\n\t\terr = insert_retry(&ht, obj, test_rht_params);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\terr = insert_retry(&ht, &array[ht.max_elems], test_rht_params);\n\tif (err == -E2BIG) {\n\t\terr = 0;\n\t} else {\n\t\tpr_info(\"insert element %u should have failed with %d, got %d\\n\",\n\t\t\t\tht.max_elems, -E2BIG, err);\n\t\tif (err == 0)\n\t\t\terr = -1;\n\t}\n\n\trhashtable_destroy(&ht);\n\n\treturn err;\n}\n\nstatic unsigned int __init print_ht(struct rhltable *rhlt)\n{\n\tstruct rhashtable *ht;\n\tconst struct bucket_table *tbl;\n\tchar buff[512] = \"\";\n\tint offset = 0;\n\tunsigned int i, cnt = 0;\n\n\tht = &rhlt->ht;\n\t \n\tmutex_lock(&ht->mutex);\n\ttbl = rht_dereference(ht->tbl, ht);\n\tfor (i = 0; i < tbl->size; i++) {\n\t\tstruct rhash_head *pos, *next;\n\t\tstruct test_obj_rhl *p;\n\n\t\tpos = rht_ptr_exclusive(tbl->buckets + i);\n\t\tnext = !rht_is_a_nulls(pos) ? rht_dereference(pos->next, ht) : NULL;\n\n\t\tif (!rht_is_a_nulls(pos)) {\n\t\t\toffset += sprintf(buff + offset, \"\\nbucket[%d] -> \", i);\n\t\t}\n\n\t\twhile (!rht_is_a_nulls(pos)) {\n\t\t\tstruct rhlist_head *list = container_of(pos, struct rhlist_head, rhead);\n\t\t\toffset += sprintf(buff + offset, \"[[\");\n\t\t\tdo {\n\t\t\t\tpos = &list->rhead;\n\t\t\t\tlist = rht_dereference(list->next, ht);\n\t\t\t\tp = rht_obj(ht, pos);\n\n\t\t\t\toffset += sprintf(buff + offset, \" val %d (tid=%d)%s\", p->value.id, p->value.tid,\n\t\t\t\t\tlist? \", \" : \" \");\n\t\t\t\tcnt++;\n\t\t\t} while (list);\n\n\t\t\tpos = next,\n\t\t\tnext = !rht_is_a_nulls(pos) ?\n\t\t\t\trht_dereference(pos->next, ht) : NULL;\n\n\t\t\toffset += sprintf(buff + offset, \"]]%s\", !rht_is_a_nulls(pos) ? \" -> \" : \"\");\n\t\t}\n\t}\n\tprintk(KERN_ERR \"\\n---- ht: ----%s\\n-------------\\n\", buff);\n\tmutex_unlock(&ht->mutex);\n\n\treturn cnt;\n}\n\nstatic int __init test_insert_dup(struct test_obj_rhl *rhl_test_objects,\n\t\t\t\t  int cnt, bool slow)\n{\n\tstruct rhltable *rhlt;\n\tunsigned int i, ret;\n\tconst char *key;\n\tint err = 0;\n\n\trhlt = kmalloc(sizeof(*rhlt), GFP_KERNEL);\n\tif (WARN_ON(!rhlt))\n\t\treturn -EINVAL;\n\n\terr = rhltable_init(rhlt, &test_rht_params_dup);\n\tif (WARN_ON(err)) {\n\t\tkfree(rhlt);\n\t\treturn err;\n\t}\n\n\tfor (i = 0; i < cnt; i++) {\n\t\trhl_test_objects[i].value.tid = i;\n\t\tkey = rht_obj(&rhlt->ht, &rhl_test_objects[i].list_node.rhead);\n\t\tkey += test_rht_params_dup.key_offset;\n\n\t\tif (slow) {\n\t\t\terr = PTR_ERR(rhashtable_insert_slow(&rhlt->ht, key,\n\t\t\t\t\t\t\t     &rhl_test_objects[i].list_node.rhead));\n\t\t\tif (err == -EAGAIN)\n\t\t\t\terr = 0;\n\t\t} else\n\t\t\terr = rhltable_insert(rhlt,\n\t\t\t\t\t      &rhl_test_objects[i].list_node,\n\t\t\t\t\t      test_rht_params_dup);\n\t\tif (WARN(err, \"error %d on element %d/%d (%s)\\n\", err, i, cnt, slow? \"slow\" : \"fast\"))\n\t\t\tgoto skip_print;\n\t}\n\n\tret = print_ht(rhlt);\n\tWARN(ret != cnt, \"missing rhltable elements (%d != %d, %s)\\n\", ret, cnt, slow? \"slow\" : \"fast\");\n\nskip_print:\n\trhltable_destroy(rhlt);\n\tkfree(rhlt);\n\n\treturn 0;\n}\n\nstatic int __init test_insert_duplicates_run(void)\n{\n\tstruct test_obj_rhl rhl_test_objects[3] = {};\n\n\tpr_info(\"test inserting duplicates\\n\");\n\n\t \n\trhl_test_objects[0].value.id = 1;\n\trhl_test_objects[1].value.id = 21;\n\n\t \n\trhl_test_objects[2].value.id = rhl_test_objects[0].value.id;\n\n\ttest_insert_dup(rhl_test_objects, 2, false);\n\ttest_insert_dup(rhl_test_objects, 3, false);\n\ttest_insert_dup(rhl_test_objects, 2, true);\n\ttest_insert_dup(rhl_test_objects, 3, true);\n\n\treturn 0;\n}\n\nstatic int thread_lookup_test(struct thread_data *tdata)\n{\n\tunsigned int entries = tdata->entries;\n\tint i, err = 0;\n\n\tfor (i = 0; i < entries; i++) {\n\t\tstruct test_obj *obj;\n\t\tstruct test_obj_val key = {\n\t\t\t.id = i,\n\t\t\t.tid = tdata->id,\n\t\t};\n\n\t\tobj = rhashtable_lookup_fast(&ht, &key, test_rht_params);\n\t\tif (obj && (tdata->objs[i].value.id == TEST_INSERT_FAIL)) {\n\t\t\tpr_err(\"  found unexpected object %d-%d\\n\", key.tid, key.id);\n\t\t\terr++;\n\t\t} else if (!obj && (tdata->objs[i].value.id != TEST_INSERT_FAIL)) {\n\t\t\tpr_err(\"  object %d-%d not found!\\n\", key.tid, key.id);\n\t\t\terr++;\n\t\t} else if (obj && memcmp(&obj->value, &key, sizeof(key))) {\n\t\t\tpr_err(\"  wrong object returned (got %d-%d, expected %d-%d)\\n\",\n\t\t\t       obj->value.tid, obj->value.id, key.tid, key.id);\n\t\t\terr++;\n\t\t}\n\n\t\tcond_resched();\n\t}\n\treturn err;\n}\n\nstatic int threadfunc(void *data)\n{\n\tint i, step, err = 0, insert_retries = 0;\n\tstruct thread_data *tdata = data;\n\n\tif (atomic_dec_and_test(&startup_count))\n\t\twake_up(&startup_wait);\n\tif (wait_event_interruptible(startup_wait, atomic_read(&startup_count) == -1)) {\n\t\tpr_err(\"  thread[%d]: interrupted\\n\", tdata->id);\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < tdata->entries; i++) {\n\t\ttdata->objs[i].value.id = i;\n\t\ttdata->objs[i].value.tid = tdata->id;\n\t\terr = insert_retry(&ht, &tdata->objs[i], test_rht_params);\n\t\tif (err > 0) {\n\t\t\tinsert_retries += err;\n\t\t} else if (err) {\n\t\t\tpr_err(\"  thread[%d]: rhashtable_insert_fast failed\\n\",\n\t\t\t       tdata->id);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tif (insert_retries)\n\t\tpr_info(\"  thread[%d]: %u insertions retried due to memory pressure\\n\",\n\t\t\ttdata->id, insert_retries);\n\n\terr = thread_lookup_test(tdata);\n\tif (err) {\n\t\tpr_err(\"  thread[%d]: rhashtable_lookup_test failed\\n\",\n\t\t       tdata->id);\n\t\tgoto out;\n\t}\n\n\tfor (step = 10; step > 0; step--) {\n\t\tfor (i = 0; i < tdata->entries; i += step) {\n\t\t\tif (tdata->objs[i].value.id == TEST_INSERT_FAIL)\n\t\t\t\tcontinue;\n\t\t\terr = rhashtable_remove_fast(&ht, &tdata->objs[i].node,\n\t\t\t                             test_rht_params);\n\t\t\tif (err) {\n\t\t\t\tpr_err(\"  thread[%d]: rhashtable_remove_fast failed\\n\",\n\t\t\t\t       tdata->id);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\ttdata->objs[i].value.id = TEST_INSERT_FAIL;\n\n\t\t\tcond_resched();\n\t\t}\n\t\terr = thread_lookup_test(tdata);\n\t\tif (err) {\n\t\t\tpr_err(\"  thread[%d]: rhashtable_lookup_test (2) failed\\n\",\n\t\t\t       tdata->id);\n\t\t\tgoto out;\n\t\t}\n\t}\nout:\n\twhile (!kthread_should_stop()) {\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\tschedule();\n\t}\n\treturn err;\n}\n\nstatic int __init test_rht_init(void)\n{\n\tunsigned int entries;\n\tint i, err, started_threads = 0, failed_threads = 0;\n\tu64 total_time = 0;\n\tstruct thread_data *tdata;\n\tstruct test_obj *objs;\n\n\tif (parm_entries < 0)\n\t\tparm_entries = 1;\n\n\tentries = min(parm_entries, MAX_ENTRIES);\n\n\ttest_rht_params.automatic_shrinking = shrinking;\n\ttest_rht_params.max_size = max_size ? : roundup_pow_of_two(entries);\n\ttest_rht_params.nelem_hint = size;\n\n\tobjs = vzalloc(array_size(sizeof(struct test_obj),\n\t\t\t\t  test_rht_params.max_size + 1));\n\tif (!objs)\n\t\treturn -ENOMEM;\n\n\tpr_info(\"Running rhashtable test nelem=%d, max_size=%d, shrinking=%d\\n\",\n\t\tsize, max_size, shrinking);\n\n\tfor (i = 0; i < runs; i++) {\n\t\ts64 time;\n\n\t\tpr_info(\"Test %02d:\\n\", i);\n\t\tmemset(objs, 0, test_rht_params.max_size * sizeof(struct test_obj));\n\n\t\terr = rhashtable_init(&ht, &test_rht_params);\n\t\tif (err < 0) {\n\t\t\tpr_warn(\"Test failed: Unable to initialize hashtable: %d\\n\",\n\t\t\t\terr);\n\t\t\tcontinue;\n\t\t}\n\n\t\ttime = test_rhashtable(&ht, objs, entries);\n\t\trhashtable_destroy(&ht);\n\t\tif (time < 0) {\n\t\t\tvfree(objs);\n\t\t\tpr_warn(\"Test failed: return code %lld\\n\", time);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\ttotal_time += time;\n\t}\n\n\tpr_info(\"test if its possible to exceed max_size %d: %s\\n\",\n\t\t\ttest_rht_params.max_size, test_rhashtable_max(objs, entries) == 0 ?\n\t\t\t\"no, ok\" : \"YES, failed\");\n\tvfree(objs);\n\n\tdo_div(total_time, runs);\n\tpr_info(\"Average test time: %llu\\n\", total_time);\n\n\ttest_insert_duplicates_run();\n\n\tif (!tcount)\n\t\treturn 0;\n\n\tpr_info(\"Testing concurrent rhashtable access from %d threads\\n\",\n\t        tcount);\n\tatomic_set(&startup_count, tcount);\n\ttdata = vzalloc(array_size(tcount, sizeof(struct thread_data)));\n\tif (!tdata)\n\t\treturn -ENOMEM;\n\tobjs  = vzalloc(array3_size(sizeof(struct test_obj), tcount, entries));\n\tif (!objs) {\n\t\tvfree(tdata);\n\t\treturn -ENOMEM;\n\t}\n\n\ttest_rht_params.max_size = max_size ? :\n\t                           roundup_pow_of_two(tcount * entries);\n\terr = rhashtable_init(&ht, &test_rht_params);\n\tif (err < 0) {\n\t\tpr_warn(\"Test failed: Unable to initialize hashtable: %d\\n\",\n\t\t\terr);\n\t\tvfree(tdata);\n\t\tvfree(objs);\n\t\treturn -EINVAL;\n\t}\n\tfor (i = 0; i < tcount; i++) {\n\t\ttdata[i].id = i;\n\t\ttdata[i].entries = entries;\n\t\ttdata[i].objs = objs + i * entries;\n\t\ttdata[i].task = kthread_run(threadfunc, &tdata[i],\n\t\t                            \"rhashtable_thrad[%d]\", i);\n\t\tif (IS_ERR(tdata[i].task)) {\n\t\t\tpr_err(\" kthread_run failed for thread %d\\n\", i);\n\t\t\tatomic_dec(&startup_count);\n\t\t} else {\n\t\t\tstarted_threads++;\n\t\t}\n\t}\n\tif (wait_event_interruptible(startup_wait, atomic_read(&startup_count) == 0))\n\t\tpr_err(\"  wait_event interruptible failed\\n\");\n\t \n\tatomic_dec(&startup_count);\n\twake_up_all(&startup_wait);\n\tfor (i = 0; i < tcount; i++) {\n\t\tif (IS_ERR(tdata[i].task))\n\t\t\tcontinue;\n\t\tif ((err = kthread_stop(tdata[i].task))) {\n\t\t\tpr_warn(\"Test failed: thread %d returned: %d\\n\",\n\t\t\t        i, err);\n\t\t\tfailed_threads++;\n\t\t}\n\t}\n\trhashtable_destroy(&ht);\n\tvfree(tdata);\n\tvfree(objs);\n\n\t \n\terr = test_rhltable(entries / 16);\n\tpr_info(\"Started %d threads, %d failed, rhltable test returns %d\\n\",\n\t        started_threads, failed_threads, err);\n\treturn 0;\n}\n\nstatic void __exit test_rht_exit(void)\n{\n}\n\nmodule_init(test_rht_init);\nmodule_exit(test_rht_exit);\n\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}