{
  "module_name": "decompress_unlzma.c",
  "hash_id": "a24d3a7eb0626956888aca3a55d00bb6022edccadba9c172ebbc3da31de1e184",
  "original_prompt": "Ingested from linux-6.6.14/lib/decompress_unlzma.c",
  "human_readable_source": " \n\n#ifdef STATIC\n#define PREBOOT\n#else\n#include <linux/decompress/unlzma.h>\n#endif  \n\n#include <linux/decompress/mm.h>\n\n#define\tMIN(a, b) (((a) < (b)) ? (a) : (b))\n\nstatic long long INIT read_int(unsigned char *ptr, int size)\n{\n\tint i;\n\tlong long ret = 0;\n\n\tfor (i = 0; i < size; i++)\n\t\tret = (ret << 8) | ptr[size-i-1];\n\treturn ret;\n}\n\n#define ENDIAN_CONVERT(x) \\\n  x = (typeof(x))read_int((unsigned char *)&x, sizeof(x))\n\n\n \n\n#include <linux/compiler.h>\n\n#define LZMA_IOBUF_SIZE\t0x10000\n\nstruct rc {\n\tlong (*fill)(void*, unsigned long);\n\tuint8_t *ptr;\n\tuint8_t *buffer;\n\tuint8_t *buffer_end;\n\tlong buffer_size;\n\tuint32_t code;\n\tuint32_t range;\n\tuint32_t bound;\n\tvoid (*error)(char *);\n};\n\n\n#define RC_TOP_BITS 24\n#define RC_MOVE_BITS 5\n#define RC_MODEL_TOTAL_BITS 11\n\n\nstatic long INIT nofill(void *buffer, unsigned long len)\n{\n\treturn -1;\n}\n\n \nstatic void INIT rc_read(struct rc *rc)\n{\n\trc->buffer_size = rc->fill((char *)rc->buffer, LZMA_IOBUF_SIZE);\n\tif (rc->buffer_size <= 0)\n\t\trc->error(\"unexpected EOF\");\n\trc->ptr = rc->buffer;\n\trc->buffer_end = rc->buffer + rc->buffer_size;\n}\n\n \nstatic inline void INIT rc_init(struct rc *rc,\n\t\t\t\t       long (*fill)(void*, unsigned long),\n\t\t\t\t       char *buffer, long buffer_size)\n{\n\tif (fill)\n\t\trc->fill = fill;\n\telse\n\t\trc->fill = nofill;\n\trc->buffer = (uint8_t *)buffer;\n\trc->buffer_size = buffer_size;\n\trc->buffer_end = rc->buffer + rc->buffer_size;\n\trc->ptr = rc->buffer;\n\n\trc->code = 0;\n\trc->range = 0xFFFFFFFF;\n}\n\nstatic inline void INIT rc_init_code(struct rc *rc)\n{\n\tint i;\n\n\tfor (i = 0; i < 5; i++) {\n\t\tif (rc->ptr >= rc->buffer_end)\n\t\t\trc_read(rc);\n\t\trc->code = (rc->code << 8) | *rc->ptr++;\n\t}\n}\n\n\n \nstatic void INIT rc_do_normalize(struct rc *rc)\n{\n\tif (rc->ptr >= rc->buffer_end)\n\t\trc_read(rc);\n\trc->range <<= 8;\n\trc->code = (rc->code << 8) | *rc->ptr++;\n}\nstatic inline void INIT rc_normalize(struct rc *rc)\n{\n\tif (rc->range < (1 << RC_TOP_BITS))\n\t\trc_do_normalize(rc);\n}\n\n \n \nstatic inline uint32_t INIT rc_is_bit_0_helper(struct rc *rc, uint16_t *p)\n{\n\trc_normalize(rc);\n\trc->bound = *p * (rc->range >> RC_MODEL_TOTAL_BITS);\n\treturn rc->bound;\n}\nstatic inline int INIT rc_is_bit_0(struct rc *rc, uint16_t *p)\n{\n\tuint32_t t = rc_is_bit_0_helper(rc, p);\n\treturn rc->code < t;\n}\n\n \nstatic inline void INIT rc_update_bit_0(struct rc *rc, uint16_t *p)\n{\n\trc->range = rc->bound;\n\t*p += ((1 << RC_MODEL_TOTAL_BITS) - *p) >> RC_MOVE_BITS;\n}\nstatic inline void INIT rc_update_bit_1(struct rc *rc, uint16_t *p)\n{\n\trc->range -= rc->bound;\n\trc->code -= rc->bound;\n\t*p -= *p >> RC_MOVE_BITS;\n}\n\n \nstatic int INIT rc_get_bit(struct rc *rc, uint16_t *p, int *symbol)\n{\n\tif (rc_is_bit_0(rc, p)) {\n\t\trc_update_bit_0(rc, p);\n\t\t*symbol *= 2;\n\t\treturn 0;\n\t} else {\n\t\trc_update_bit_1(rc, p);\n\t\t*symbol = *symbol * 2 + 1;\n\t\treturn 1;\n\t}\n}\n\n \nstatic inline int INIT rc_direct_bit(struct rc *rc)\n{\n\trc_normalize(rc);\n\trc->range >>= 1;\n\tif (rc->code >= rc->range) {\n\t\trc->code -= rc->range;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n \nstatic inline void INIT\nrc_bit_tree_decode(struct rc *rc, uint16_t *p, int num_levels, int *symbol)\n{\n\tint i = num_levels;\n\n\t*symbol = 1;\n\twhile (i--)\n\t\trc_get_bit(rc, p + *symbol, symbol);\n\t*symbol -= 1 << num_levels;\n}\n\n\n \n\n\nstruct lzma_header {\n\tuint8_t pos;\n\tuint32_t dict_size;\n\tuint64_t dst_size;\n} __attribute__ ((packed)) ;\n\n\n#define LZMA_BASE_SIZE 1846\n#define LZMA_LIT_SIZE 768\n\n#define LZMA_NUM_POS_BITS_MAX 4\n\n#define LZMA_LEN_NUM_LOW_BITS 3\n#define LZMA_LEN_NUM_MID_BITS 3\n#define LZMA_LEN_NUM_HIGH_BITS 8\n\n#define LZMA_LEN_CHOICE 0\n#define LZMA_LEN_CHOICE_2 (LZMA_LEN_CHOICE + 1)\n#define LZMA_LEN_LOW (LZMA_LEN_CHOICE_2 + 1)\n#define LZMA_LEN_MID (LZMA_LEN_LOW \\\n\t\t      + (1 << (LZMA_NUM_POS_BITS_MAX + LZMA_LEN_NUM_LOW_BITS)))\n#define LZMA_LEN_HIGH (LZMA_LEN_MID \\\n\t\t       +(1 << (LZMA_NUM_POS_BITS_MAX + LZMA_LEN_NUM_MID_BITS)))\n#define LZMA_NUM_LEN_PROBS (LZMA_LEN_HIGH + (1 << LZMA_LEN_NUM_HIGH_BITS))\n\n#define LZMA_NUM_STATES 12\n#define LZMA_NUM_LIT_STATES 7\n\n#define LZMA_START_POS_MODEL_INDEX 4\n#define LZMA_END_POS_MODEL_INDEX 14\n#define LZMA_NUM_FULL_DISTANCES (1 << (LZMA_END_POS_MODEL_INDEX >> 1))\n\n#define LZMA_NUM_POS_SLOT_BITS 6\n#define LZMA_NUM_LEN_TO_POS_STATES 4\n\n#define LZMA_NUM_ALIGN_BITS 4\n\n#define LZMA_MATCH_MIN_LEN 2\n\n#define LZMA_IS_MATCH 0\n#define LZMA_IS_REP (LZMA_IS_MATCH + (LZMA_NUM_STATES << LZMA_NUM_POS_BITS_MAX))\n#define LZMA_IS_REP_G0 (LZMA_IS_REP + LZMA_NUM_STATES)\n#define LZMA_IS_REP_G1 (LZMA_IS_REP_G0 + LZMA_NUM_STATES)\n#define LZMA_IS_REP_G2 (LZMA_IS_REP_G1 + LZMA_NUM_STATES)\n#define LZMA_IS_REP_0_LONG (LZMA_IS_REP_G2 + LZMA_NUM_STATES)\n#define LZMA_POS_SLOT (LZMA_IS_REP_0_LONG \\\n\t\t       + (LZMA_NUM_STATES << LZMA_NUM_POS_BITS_MAX))\n#define LZMA_SPEC_POS (LZMA_POS_SLOT \\\n\t\t       +(LZMA_NUM_LEN_TO_POS_STATES << LZMA_NUM_POS_SLOT_BITS))\n#define LZMA_ALIGN (LZMA_SPEC_POS \\\n\t\t    + LZMA_NUM_FULL_DISTANCES - LZMA_END_POS_MODEL_INDEX)\n#define LZMA_LEN_CODER (LZMA_ALIGN + (1 << LZMA_NUM_ALIGN_BITS))\n#define LZMA_REP_LEN_CODER (LZMA_LEN_CODER + LZMA_NUM_LEN_PROBS)\n#define LZMA_LITERAL (LZMA_REP_LEN_CODER + LZMA_NUM_LEN_PROBS)\n\n\nstruct writer {\n\tuint8_t *buffer;\n\tuint8_t previous_byte;\n\tsize_t buffer_pos;\n\tint bufsize;\n\tsize_t global_pos;\n\tlong (*flush)(void*, unsigned long);\n\tstruct lzma_header *header;\n};\n\nstruct cstate {\n\tint state;\n\tuint32_t rep0, rep1, rep2, rep3;\n};\n\nstatic inline size_t INIT get_pos(struct writer *wr)\n{\n\treturn\n\t\twr->global_pos + wr->buffer_pos;\n}\n\nstatic inline uint8_t INIT peek_old_byte(struct writer *wr,\n\t\t\t\t\t\tuint32_t offs)\n{\n\tif (!wr->flush) {\n\t\tint32_t pos;\n\t\twhile (offs > wr->header->dict_size)\n\t\t\toffs -= wr->header->dict_size;\n\t\tpos = wr->buffer_pos - offs;\n\t\treturn wr->buffer[pos];\n\t} else {\n\t\tuint32_t pos = wr->buffer_pos - offs;\n\t\twhile (pos >= wr->header->dict_size)\n\t\t\tpos += wr->header->dict_size;\n\t\treturn wr->buffer[pos];\n\t}\n\n}\n\nstatic inline int INIT write_byte(struct writer *wr, uint8_t byte)\n{\n\twr->buffer[wr->buffer_pos++] = wr->previous_byte = byte;\n\tif (wr->flush && wr->buffer_pos == wr->header->dict_size) {\n\t\twr->buffer_pos = 0;\n\t\twr->global_pos += wr->header->dict_size;\n\t\tif (wr->flush((char *)wr->buffer, wr->header->dict_size)\n\t\t\t\t!= wr->header->dict_size)\n\t\t\treturn -1;\n\t}\n\treturn 0;\n}\n\n\nstatic inline int INIT copy_byte(struct writer *wr, uint32_t offs)\n{\n\treturn write_byte(wr, peek_old_byte(wr, offs));\n}\n\nstatic inline int INIT copy_bytes(struct writer *wr,\n\t\t\t\t\t uint32_t rep0, int len)\n{\n\tdo {\n\t\tif (copy_byte(wr, rep0))\n\t\t\treturn -1;\n\t\tlen--;\n\t} while (len != 0 && wr->buffer_pos < wr->header->dst_size);\n\n\treturn len;\n}\n\nstatic inline int INIT process_bit0(struct writer *wr, struct rc *rc,\n\t\t\t\t     struct cstate *cst, uint16_t *p,\n\t\t\t\t     int pos_state, uint16_t *prob,\n\t\t\t\t     int lc, uint32_t literal_pos_mask) {\n\tint mi = 1;\n\trc_update_bit_0(rc, prob);\n\tprob = (p + LZMA_LITERAL +\n\t\t(LZMA_LIT_SIZE\n\t\t * (((get_pos(wr) & literal_pos_mask) << lc)\n\t\t    + (wr->previous_byte >> (8 - lc))))\n\t\t);\n\n\tif (cst->state >= LZMA_NUM_LIT_STATES) {\n\t\tint match_byte = peek_old_byte(wr, cst->rep0);\n\t\tdo {\n\t\t\tint bit;\n\t\t\tuint16_t *prob_lit;\n\n\t\t\tmatch_byte <<= 1;\n\t\t\tbit = match_byte & 0x100;\n\t\t\tprob_lit = prob + 0x100 + bit + mi;\n\t\t\tif (rc_get_bit(rc, prob_lit, &mi)) {\n\t\t\t\tif (!bit)\n\t\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tif (bit)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t} while (mi < 0x100);\n\t}\n\twhile (mi < 0x100) {\n\t\tuint16_t *prob_lit = prob + mi;\n\t\trc_get_bit(rc, prob_lit, &mi);\n\t}\n\tif (cst->state < 4)\n\t\tcst->state = 0;\n\telse if (cst->state < 10)\n\t\tcst->state -= 3;\n\telse\n\t\tcst->state -= 6;\n\n\treturn write_byte(wr, mi);\n}\n\nstatic inline int INIT process_bit1(struct writer *wr, struct rc *rc,\n\t\t\t\t\t    struct cstate *cst, uint16_t *p,\n\t\t\t\t\t    int pos_state, uint16_t *prob) {\n\tint offset;\n\tuint16_t *prob_len;\n\tint num_bits;\n\tint len;\n\n\trc_update_bit_1(rc, prob);\n\tprob = p + LZMA_IS_REP + cst->state;\n\tif (rc_is_bit_0(rc, prob)) {\n\t\trc_update_bit_0(rc, prob);\n\t\tcst->rep3 = cst->rep2;\n\t\tcst->rep2 = cst->rep1;\n\t\tcst->rep1 = cst->rep0;\n\t\tcst->state = cst->state < LZMA_NUM_LIT_STATES ? 0 : 3;\n\t\tprob = p + LZMA_LEN_CODER;\n\t} else {\n\t\trc_update_bit_1(rc, prob);\n\t\tprob = p + LZMA_IS_REP_G0 + cst->state;\n\t\tif (rc_is_bit_0(rc, prob)) {\n\t\t\trc_update_bit_0(rc, prob);\n\t\t\tprob = (p + LZMA_IS_REP_0_LONG\n\t\t\t\t+ (cst->state <<\n\t\t\t\t   LZMA_NUM_POS_BITS_MAX) +\n\t\t\t\tpos_state);\n\t\t\tif (rc_is_bit_0(rc, prob)) {\n\t\t\t\trc_update_bit_0(rc, prob);\n\n\t\t\t\tcst->state = cst->state < LZMA_NUM_LIT_STATES ?\n\t\t\t\t\t9 : 11;\n\t\t\t\treturn copy_byte(wr, cst->rep0);\n\t\t\t} else {\n\t\t\t\trc_update_bit_1(rc, prob);\n\t\t\t}\n\t\t} else {\n\t\t\tuint32_t distance;\n\n\t\t\trc_update_bit_1(rc, prob);\n\t\t\tprob = p + LZMA_IS_REP_G1 + cst->state;\n\t\t\tif (rc_is_bit_0(rc, prob)) {\n\t\t\t\trc_update_bit_0(rc, prob);\n\t\t\t\tdistance = cst->rep1;\n\t\t\t} else {\n\t\t\t\trc_update_bit_1(rc, prob);\n\t\t\t\tprob = p + LZMA_IS_REP_G2 + cst->state;\n\t\t\t\tif (rc_is_bit_0(rc, prob)) {\n\t\t\t\t\trc_update_bit_0(rc, prob);\n\t\t\t\t\tdistance = cst->rep2;\n\t\t\t\t} else {\n\t\t\t\t\trc_update_bit_1(rc, prob);\n\t\t\t\t\tdistance = cst->rep3;\n\t\t\t\t\tcst->rep3 = cst->rep2;\n\t\t\t\t}\n\t\t\t\tcst->rep2 = cst->rep1;\n\t\t\t}\n\t\t\tcst->rep1 = cst->rep0;\n\t\t\tcst->rep0 = distance;\n\t\t}\n\t\tcst->state = cst->state < LZMA_NUM_LIT_STATES ? 8 : 11;\n\t\tprob = p + LZMA_REP_LEN_CODER;\n\t}\n\n\tprob_len = prob + LZMA_LEN_CHOICE;\n\tif (rc_is_bit_0(rc, prob_len)) {\n\t\trc_update_bit_0(rc, prob_len);\n\t\tprob_len = (prob + LZMA_LEN_LOW\n\t\t\t    + (pos_state <<\n\t\t\t       LZMA_LEN_NUM_LOW_BITS));\n\t\toffset = 0;\n\t\tnum_bits = LZMA_LEN_NUM_LOW_BITS;\n\t} else {\n\t\trc_update_bit_1(rc, prob_len);\n\t\tprob_len = prob + LZMA_LEN_CHOICE_2;\n\t\tif (rc_is_bit_0(rc, prob_len)) {\n\t\t\trc_update_bit_0(rc, prob_len);\n\t\t\tprob_len = (prob + LZMA_LEN_MID\n\t\t\t\t    + (pos_state <<\n\t\t\t\t       LZMA_LEN_NUM_MID_BITS));\n\t\t\toffset = 1 << LZMA_LEN_NUM_LOW_BITS;\n\t\t\tnum_bits = LZMA_LEN_NUM_MID_BITS;\n\t\t} else {\n\t\t\trc_update_bit_1(rc, prob_len);\n\t\t\tprob_len = prob + LZMA_LEN_HIGH;\n\t\t\toffset = ((1 << LZMA_LEN_NUM_LOW_BITS)\n\t\t\t\t  + (1 << LZMA_LEN_NUM_MID_BITS));\n\t\t\tnum_bits = LZMA_LEN_NUM_HIGH_BITS;\n\t\t}\n\t}\n\n\trc_bit_tree_decode(rc, prob_len, num_bits, &len);\n\tlen += offset;\n\n\tif (cst->state < 4) {\n\t\tint pos_slot;\n\n\t\tcst->state += LZMA_NUM_LIT_STATES;\n\t\tprob =\n\t\t\tp + LZMA_POS_SLOT +\n\t\t\t((len <\n\t\t\t  LZMA_NUM_LEN_TO_POS_STATES ? len :\n\t\t\t  LZMA_NUM_LEN_TO_POS_STATES - 1)\n\t\t\t << LZMA_NUM_POS_SLOT_BITS);\n\t\trc_bit_tree_decode(rc, prob,\n\t\t\t\t   LZMA_NUM_POS_SLOT_BITS,\n\t\t\t\t   &pos_slot);\n\t\tif (pos_slot >= LZMA_START_POS_MODEL_INDEX) {\n\t\t\tint i, mi;\n\t\t\tnum_bits = (pos_slot >> 1) - 1;\n\t\t\tcst->rep0 = 2 | (pos_slot & 1);\n\t\t\tif (pos_slot < LZMA_END_POS_MODEL_INDEX) {\n\t\t\t\tcst->rep0 <<= num_bits;\n\t\t\t\tprob = p + LZMA_SPEC_POS +\n\t\t\t\t\tcst->rep0 - pos_slot - 1;\n\t\t\t} else {\n\t\t\t\tnum_bits -= LZMA_NUM_ALIGN_BITS;\n\t\t\t\twhile (num_bits--)\n\t\t\t\t\tcst->rep0 = (cst->rep0 << 1) |\n\t\t\t\t\t\trc_direct_bit(rc);\n\t\t\t\tprob = p + LZMA_ALIGN;\n\t\t\t\tcst->rep0 <<= LZMA_NUM_ALIGN_BITS;\n\t\t\t\tnum_bits = LZMA_NUM_ALIGN_BITS;\n\t\t\t}\n\t\t\ti = 1;\n\t\t\tmi = 1;\n\t\t\twhile (num_bits--) {\n\t\t\t\tif (rc_get_bit(rc, prob + mi, &mi))\n\t\t\t\t\tcst->rep0 |= i;\n\t\t\t\ti <<= 1;\n\t\t\t}\n\t\t} else\n\t\t\tcst->rep0 = pos_slot;\n\t\tif (++(cst->rep0) == 0)\n\t\t\treturn 0;\n\t\tif (cst->rep0 > wr->header->dict_size\n\t\t\t\t|| cst->rep0 > get_pos(wr))\n\t\t\treturn -1;\n\t}\n\n\tlen += LZMA_MATCH_MIN_LEN;\n\n\treturn copy_bytes(wr, cst->rep0, len);\n}\n\n\n\nSTATIC inline int INIT unlzma(unsigned char *buf, long in_len,\n\t\t\t      long (*fill)(void*, unsigned long),\n\t\t\t      long (*flush)(void*, unsigned long),\n\t\t\t      unsigned char *output,\n\t\t\t      long *posp,\n\t\t\t      void(*error)(char *x)\n\t)\n{\n\tstruct lzma_header header;\n\tint lc, pb, lp;\n\tuint32_t pos_state_mask;\n\tuint32_t literal_pos_mask;\n\tuint16_t *p;\n\tint num_probs;\n\tstruct rc rc;\n\tint i, mi;\n\tstruct writer wr;\n\tstruct cstate cst;\n\tunsigned char *inbuf;\n\tint ret = -1;\n\n\trc.error = error;\n\n\tif (buf)\n\t\tinbuf = buf;\n\telse\n\t\tinbuf = malloc(LZMA_IOBUF_SIZE);\n\tif (!inbuf) {\n\t\terror(\"Could not allocate input buffer\");\n\t\tgoto exit_0;\n\t}\n\n\tcst.state = 0;\n\tcst.rep0 = cst.rep1 = cst.rep2 = cst.rep3 = 1;\n\n\twr.header = &header;\n\twr.flush = flush;\n\twr.global_pos = 0;\n\twr.previous_byte = 0;\n\twr.buffer_pos = 0;\n\n\trc_init(&rc, fill, inbuf, in_len);\n\n\tfor (i = 0; i < sizeof(header); i++) {\n\t\tif (rc.ptr >= rc.buffer_end)\n\t\t\trc_read(&rc);\n\t\t((unsigned char *)&header)[i] = *rc.ptr++;\n\t}\n\n\tif (header.pos >= (9 * 5 * 5)) {\n\t\terror(\"bad header\");\n\t\tgoto exit_1;\n\t}\n\n\tmi = 0;\n\tlc = header.pos;\n\twhile (lc >= 9) {\n\t\tmi++;\n\t\tlc -= 9;\n\t}\n\tpb = 0;\n\tlp = mi;\n\twhile (lp >= 5) {\n\t\tpb++;\n\t\tlp -= 5;\n\t}\n\tpos_state_mask = (1 << pb) - 1;\n\tliteral_pos_mask = (1 << lp) - 1;\n\n\tENDIAN_CONVERT(header.dict_size);\n\tENDIAN_CONVERT(header.dst_size);\n\n\tif (header.dict_size == 0)\n\t\theader.dict_size = 1;\n\n\tif (output)\n\t\twr.buffer = output;\n\telse {\n\t\twr.bufsize = MIN(header.dst_size, header.dict_size);\n\t\twr.buffer = large_malloc(wr.bufsize);\n\t}\n\tif (wr.buffer == NULL)\n\t\tgoto exit_1;\n\n\tnum_probs = LZMA_BASE_SIZE + (LZMA_LIT_SIZE << (lc + lp));\n\tp = (uint16_t *) large_malloc(num_probs * sizeof(*p));\n\tif (p == NULL)\n\t\tgoto exit_2;\n\tnum_probs = LZMA_LITERAL + (LZMA_LIT_SIZE << (lc + lp));\n\tfor (i = 0; i < num_probs; i++)\n\t\tp[i] = (1 << RC_MODEL_TOTAL_BITS) >> 1;\n\n\trc_init_code(&rc);\n\n\twhile (get_pos(&wr) < header.dst_size) {\n\t\tint pos_state =\tget_pos(&wr) & pos_state_mask;\n\t\tuint16_t *prob = p + LZMA_IS_MATCH +\n\t\t\t(cst.state << LZMA_NUM_POS_BITS_MAX) + pos_state;\n\t\tif (rc_is_bit_0(&rc, prob)) {\n\t\t\tif (process_bit0(&wr, &rc, &cst, p, pos_state, prob,\n\t\t\t\t\tlc, literal_pos_mask)) {\n\t\t\t\terror(\"LZMA data is corrupt\");\n\t\t\t\tgoto exit_3;\n\t\t\t}\n\t\t} else {\n\t\t\tif (process_bit1(&wr, &rc, &cst, p, pos_state, prob)) {\n\t\t\t\terror(\"LZMA data is corrupt\");\n\t\t\t\tgoto exit_3;\n\t\t\t}\n\t\t\tif (cst.rep0 == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (rc.buffer_size <= 0)\n\t\t\tgoto exit_3;\n\t}\n\n\tif (posp)\n\t\t*posp = rc.ptr-rc.buffer;\n\tif (!wr.flush || wr.flush(wr.buffer, wr.buffer_pos) == wr.buffer_pos)\n\t\tret = 0;\nexit_3:\n\tlarge_free(p);\nexit_2:\n\tif (!output)\n\t\tlarge_free(wr.buffer);\nexit_1:\n\tif (!buf)\n\t\tfree(inbuf);\nexit_0:\n\treturn ret;\n}\n\n#ifdef PREBOOT\nSTATIC int INIT __decompress(unsigned char *buf, long in_len,\n\t\t\t      long (*fill)(void*, unsigned long),\n\t\t\t      long (*flush)(void*, unsigned long),\n\t\t\t      unsigned char *output, long out_len,\n\t\t\t      long *posp,\n\t\t\t      void (*error)(char *x))\n{\n\treturn unlzma(buf, in_len - 4, fill, flush, output, posp, error);\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}