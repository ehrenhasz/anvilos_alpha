{
  "module_name": "defutil.h",
  "hash_id": "e8d288e6eef0c54ffe25800aec8ddc357e363ae0f1197d0c5d6aff7ef497d6c8",
  "original_prompt": "Ingested from linux-6.6.14/lib/zlib_deflate/defutil.h",
  "human_readable_source": "#ifndef DEFUTIL_H\n#define DEFUTIL_H\n\n#include <linux/zutil.h>\n\n#define Assert(err, str) \n#define Trace(dummy) \n#define Tracev(dummy) \n#define Tracecv(err, dummy) \n#define Tracevv(dummy) \n\n\n\n#define LENGTH_CODES 29\n \n\n#define LITERALS  256\n \n\n#define L_CODES (LITERALS+1+LENGTH_CODES)\n \n\n#define D_CODES   30\n \n\n#define BL_CODES  19\n \n\n#define HEAP_SIZE (2*L_CODES+1)\n \n\n#define MAX_BITS 15\n \n\n#define INIT_STATE    42\n#define BUSY_STATE   113\n#define FINISH_STATE 666\n \n\n\n \ntypedef struct ct_data_s {\n    union {\n        ush  freq;        \n        ush  code;        \n    } fc;\n    union {\n        ush  dad;         \n        ush  len;         \n    } dl;\n} ct_data;\n\n#define Freq fc.freq\n#define Code fc.code\n#define Dad  dl.dad\n#define Len  dl.len\n\ntypedef struct static_tree_desc_s  static_tree_desc;\n\ntypedef struct tree_desc_s {\n    ct_data *dyn_tree;            \n    int     max_code;             \n    static_tree_desc *stat_desc;  \n} tree_desc;\n\ntypedef ush Pos;\ntypedef unsigned IPos;\n\n \n\ntypedef struct deflate_state {\n    z_streamp strm;       \n    int   status;         \n    Byte *pending_buf;    \n    ulg   pending_buf_size;  \n    Byte *pending_out;    \n    int   pending;        \n    int   noheader;       \n    Byte  data_type;      \n    Byte  method;         \n    int   last_flush;     \n\n                 \n\n    uInt  w_size;         \n    uInt  w_bits;         \n    uInt  w_mask;         \n\n    Byte *window;\n     \n\n    ulg window_size;\n     \n\n    Pos *prev;\n     \n\n    Pos *head;  \n\n    uInt  ins_h;           \n    uInt  hash_size;       \n    uInt  hash_bits;       \n    uInt  hash_mask;       \n\n    uInt  hash_shift;\n     \n\n    long block_start;\n     \n\n    uInt match_length;            \n    IPos prev_match;              \n    int match_available;          \n    uInt strstart;                \n    uInt match_start;             \n    uInt lookahead;               \n\n    uInt prev_length;\n     \n\n    uInt max_chain_length;\n     \n\n    uInt max_lazy_match;\n     \n#   define max_insert_length  max_lazy_match\n     \n\n    int level;     \n    int strategy;  \n\n    uInt good_match;\n     \n\n    int nice_match;  \n\n                 \n     \n    struct ct_data_s dyn_ltree[HEAP_SIZE];    \n    struct ct_data_s dyn_dtree[2*D_CODES+1];  \n    struct ct_data_s bl_tree[2*BL_CODES+1];   \n\n    struct tree_desc_s l_desc;                \n    struct tree_desc_s d_desc;                \n    struct tree_desc_s bl_desc;               \n\n    ush bl_count[MAX_BITS+1];\n     \n\n    int heap[2*L_CODES+1];       \n    int heap_len;                \n    int heap_max;                \n     \n\n    uch depth[2*L_CODES+1];\n     \n\n    uch *l_buf;           \n\n    uInt  lit_bufsize;\n     \n\n    uInt last_lit;       \n\n    ush *d_buf;\n     \n\n    ulg opt_len;         \n    ulg static_len;      \n    ulg compressed_len;  \n    uInt matches;        \n    int last_eob_len;    \n\n#ifdef DEBUG_ZLIB\n    ulg bits_sent;       \n#endif\n\n    ush bi_buf;\n     \n    int bi_valid;\n     \n\n} deflate_state;\n\n#ifdef CONFIG_ZLIB_DFLTCC\n#define zlib_deflate_window_memsize(windowBits) \\\n\t(2 * (1 << (windowBits)) * sizeof(Byte) + PAGE_SIZE)\n#else\n#define zlib_deflate_window_memsize(windowBits) \\\n\t(2 * (1 << (windowBits)) * sizeof(Byte))\n#endif\n#define zlib_deflate_prev_memsize(windowBits) \\\n\t((1 << (windowBits)) * sizeof(Pos))\n#define zlib_deflate_head_memsize(memLevel) \\\n\t((1 << ((memLevel)+7)) * sizeof(Pos))\n#define zlib_deflate_overlay_memsize(memLevel) \\\n\t((1 << ((memLevel)+6)) * (sizeof(ush)+2))\n\n \n#define put_byte(s, c) {s->pending_buf[s->pending++] = (c);}\n\n\n#define MIN_LOOKAHEAD (MAX_MATCH+MIN_MATCH+1)\n \n\n#define MAX_DIST(s)  ((s)->w_size-MIN_LOOKAHEAD)\n \n\n         \nvoid zlib_tr_init         (deflate_state *s);\nint  zlib_tr_tally        (deflate_state *s, unsigned dist, unsigned lc);\nulg  zlib_tr_flush_block  (deflate_state *s, char *buf, ulg stored_len,\n\t\t\t   int eof);\nvoid zlib_tr_align        (deflate_state *s);\nvoid zlib_tr_stored_block (deflate_state *s, char *buf, ulg stored_len,\n\t\t\t   int eof);\nvoid zlib_tr_stored_type_only (deflate_state *);\n\n\n \n#define put_short(s, w) { \\\n    put_byte(s, (uch)((w) & 0xff)); \\\n    put_byte(s, (uch)((ush)(w) >> 8)); \\\n}\n\n \nstatic inline unsigned  bi_reverse(\n    unsigned code,  \n    int len         \n)\n{\n    register unsigned res = 0;\n    do {\n        res |= code & 1;\n        code >>= 1, res <<= 1;\n    } while (--len > 0);\n    return res >> 1;\n}\n\n \nstatic inline void bi_flush(deflate_state *s)\n{\n    if (s->bi_valid == 16) {\n        put_short(s, s->bi_buf);\n        s->bi_buf = 0;\n        s->bi_valid = 0;\n    } else if (s->bi_valid >= 8) {\n        put_byte(s, (Byte)s->bi_buf);\n        s->bi_buf >>= 8;\n        s->bi_valid -= 8;\n    }\n}\n\n \nstatic inline void bi_windup(deflate_state *s)\n{\n    if (s->bi_valid > 8) {\n        put_short(s, s->bi_buf);\n    } else if (s->bi_valid > 0) {\n        put_byte(s, (Byte)s->bi_buf);\n    }\n    s->bi_buf = 0;\n    s->bi_valid = 0;\n#ifdef DEBUG_ZLIB\n    s->bits_sent = (s->bits_sent+7) & ~7;\n#endif\n}\n\ntypedef enum {\n    need_more,       \n    block_done,      \n    finish_started,  \n    finish_done      \n} block_state;\n\n#define Buf_size (8 * 2*sizeof(char))\n \n\n \n#ifdef DEBUG_ZLIB\nstatic void send_bits      (deflate_state *s, int value, int length);\n\nstatic void send_bits(\n    deflate_state *s,\n    int value,   \n    int length   \n)\n{\n    Tracevv((stderr,\" l %2d v %4x \", length, value));\n    Assert(length > 0 && length <= 15, \"invalid length\");\n    s->bits_sent += (ulg)length;\n\n     \n    if (s->bi_valid > (int)Buf_size - length) {\n        s->bi_buf |= (value << s->bi_valid);\n        put_short(s, s->bi_buf);\n        s->bi_buf = (ush)value >> (Buf_size - s->bi_valid);\n        s->bi_valid += length - Buf_size;\n    } else {\n        s->bi_buf |= value << s->bi_valid;\n        s->bi_valid += length;\n    }\n}\n#else  \n\n#define send_bits(s, value, length) \\\n{ int len = length;\\\n  if (s->bi_valid > (int)Buf_size - len) {\\\n    int val = value;\\\n    s->bi_buf |= (val << s->bi_valid);\\\n    put_short(s, s->bi_buf);\\\n    s->bi_buf = (ush)val >> (Buf_size - s->bi_valid);\\\n    s->bi_valid += len - Buf_size;\\\n  } else {\\\n    s->bi_buf |= (value) << s->bi_valid;\\\n    s->bi_valid += len;\\\n  }\\\n}\n#endif  \n\nstatic inline void zlib_tr_send_bits(\n    deflate_state *s,\n    int value,\n    int length\n)\n{\n    send_bits(s, value, length);\n}\n\n \nstatic inline void flush_pending(\n\tz_streamp strm\n)\n{\n    unsigned len;\n    deflate_state *s = (deflate_state *) strm->state;\n\n    bi_flush(s);\n    len = s->pending;\n    if (len > strm->avail_out) len = strm->avail_out;\n    if (len == 0) return;\n\n    if (strm->next_out != NULL) {\n\tmemcpy(strm->next_out, s->pending_out, len);\n\tstrm->next_out += len;\n    }\n    s->pending_out += len;\n    strm->total_out += len;\n    strm->avail_out  -= len;\n    s->pending -= len;\n    if (s->pending == 0) {\n        s->pending_out = s->pending_buf;\n    }\n}\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}