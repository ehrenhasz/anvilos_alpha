{
  "module_name": "deflate.c",
  "hash_id": "c6b362b949ba2fd92023804c90faffc54ffb9fe4c76576b80194a6bf146dee75",
  "original_prompt": "Ingested from linux-6.6.14/lib/zlib_deflate/deflate.c",
  "human_readable_source": " \n \n\n \n\n#include <linux/module.h>\n#include <linux/zutil.h>\n#include \"defutil.h\"\n\n \n#ifdef CONFIG_ZLIB_DFLTCC\n#  include \"../zlib_dfltcc/dfltcc_deflate.h\"\n#else\n#define DEFLATE_RESET_HOOK(strm) do {} while (0)\n#define DEFLATE_HOOK(strm, flush, bstate) 0\n#define DEFLATE_NEED_CHECKSUM(strm) 1\n#define DEFLATE_DFLTCC_ENABLED() 0\n#endif\n\n \n\ntypedef block_state (*compress_func) (deflate_state *s, int flush);\n \n\nstatic void fill_window    (deflate_state *s);\nstatic block_state deflate_stored (deflate_state *s, int flush);\nstatic block_state deflate_fast   (deflate_state *s, int flush);\nstatic block_state deflate_slow   (deflate_state *s, int flush);\nstatic void lm_init        (deflate_state *s);\nstatic void putShortMSB    (deflate_state *s, uInt b);\nstatic int read_buf        (z_streamp strm, Byte *buf, unsigned size);\nstatic uInt longest_match  (deflate_state *s, IPos cur_match);\n\n#ifdef DEBUG_ZLIB\nstatic  void check_match (deflate_state *s, IPos start, IPos match,\n                         int length);\n#endif\n\n \n\n#define NIL 0\n \n\n#ifndef TOO_FAR\n#  define TOO_FAR 4096\n#endif\n \n\n#define MIN_LOOKAHEAD (MAX_MATCH+MIN_MATCH+1)\n \n\n \ntypedef struct deflate_workspace {\n     \n    deflate_state deflate_memory;\n#ifdef CONFIG_ZLIB_DFLTCC\n     \n    struct dfltcc_deflate_state dfltcc_memory;\n#endif\n    Byte *window_memory;\n    Pos *prev_memory;\n    Pos *head_memory;\n    char *overlay_memory;\n} deflate_workspace;\n\n#ifdef CONFIG_ZLIB_DFLTCC\n \nstatic_assert(offsetof(struct deflate_workspace, dfltcc_memory) % 8 == 0);\n#endif\n\n \ntypedef struct config_s {\n   ush good_length;  \n   ush max_lazy;     \n   ush nice_length;  \n   ush max_chain;\n   compress_func func;\n} config;\n\nstatic const config configuration_table[10] = {\n \n  {0,    0,  0,    0, deflate_stored},   \n  {4,    4,  8,    4, deflate_fast},  \n  {4,    5, 16,    8, deflate_fast},\n  {4,    6, 32,   32, deflate_fast},\n\n  {4,    4, 16,   16, deflate_slow},   \n  {8,   16, 32,   32, deflate_slow},\n  {8,   16, 128, 128, deflate_slow},\n  {8,   32, 128, 256, deflate_slow},\n  {32, 128, 258, 1024, deflate_slow},\n  {32, 258, 258, 4096, deflate_slow}};  \n\n \n\n#define EQUAL 0\n \n\n \n#define UPDATE_HASH(s,h,c) (h = (((h)<<s->hash_shift) ^ (c)) & s->hash_mask)\n\n\n \n#define INSERT_STRING(s, str, match_head) \\\n   (UPDATE_HASH(s, s->ins_h, s->window[(str) + (MIN_MATCH-1)]), \\\n    s->prev[(str) & s->w_mask] = match_head = s->head[s->ins_h], \\\n    s->head[s->ins_h] = (Pos)(str))\n\n \n#define CLEAR_HASH(s) \\\n    s->head[s->hash_size-1] = NIL; \\\n    memset((char *)s->head, 0, (unsigned)(s->hash_size-1)*sizeof(*s->head));\n\n \nint zlib_deflateInit2(\n\tz_streamp strm,\n\tint  level,\n\tint  method,\n\tint  windowBits,\n\tint  memLevel,\n\tint  strategy\n)\n{\n    deflate_state *s;\n    int noheader = 0;\n    deflate_workspace *mem;\n    char *next;\n\n    ush *overlay;\n     \n\n    if (strm == NULL) return Z_STREAM_ERROR;\n\n    strm->msg = NULL;\n\n    if (level == Z_DEFAULT_COMPRESSION) level = 6;\n\n    mem = (deflate_workspace *) strm->workspace;\n\n    if (windowBits < 0) {  \n        noheader = 1;\n        windowBits = -windowBits;\n    }\n    if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method != Z_DEFLATED ||\n        windowBits < 9 || windowBits > 15 || level < 0 || level > 9 ||\n\tstrategy < 0 || strategy > Z_HUFFMAN_ONLY) {\n        return Z_STREAM_ERROR;\n    }\n\n     \n    next = (char *) mem;\n    next += sizeof(*mem);\n#ifdef CONFIG_ZLIB_DFLTCC\n     \n    mem->window_memory = (Byte *) PTR_ALIGN(next, PAGE_SIZE);\n#else\n    mem->window_memory = (Byte *) next;\n#endif\n    next += zlib_deflate_window_memsize(windowBits);\n    mem->prev_memory = (Pos *) next;\n    next += zlib_deflate_prev_memsize(windowBits);\n    mem->head_memory = (Pos *) next;\n    next += zlib_deflate_head_memsize(memLevel);\n    mem->overlay_memory = next;\n\n    s = (deflate_state *) &(mem->deflate_memory);\n    strm->state = (struct internal_state *)s;\n    s->strm = strm;\n\n    s->noheader = noheader;\n    s->w_bits = windowBits;\n    s->w_size = 1 << s->w_bits;\n    s->w_mask = s->w_size - 1;\n\n    s->hash_bits = memLevel + 7;\n    s->hash_size = 1 << s->hash_bits;\n    s->hash_mask = s->hash_size - 1;\n    s->hash_shift =  ((s->hash_bits+MIN_MATCH-1)/MIN_MATCH);\n\n    s->window = (Byte *) mem->window_memory;\n    s->prev   = (Pos *)  mem->prev_memory;\n    s->head   = (Pos *)  mem->head_memory;\n\n    s->lit_bufsize = 1 << (memLevel + 6);  \n\n    overlay = (ush *) mem->overlay_memory;\n    s->pending_buf = (uch *) overlay;\n    s->pending_buf_size = (ulg)s->lit_bufsize * (sizeof(ush)+2L);\n\n    s->d_buf = overlay + s->lit_bufsize/sizeof(ush);\n    s->l_buf = s->pending_buf + (1+sizeof(ush))*s->lit_bufsize;\n\n    s->level = level;\n    s->strategy = strategy;\n    s->method = (Byte)method;\n\n    return zlib_deflateReset(strm);\n}\n\n \nint zlib_deflateReset(\n\tz_streamp strm\n)\n{\n    deflate_state *s;\n    \n    if (strm == NULL || strm->state == NULL)\n        return Z_STREAM_ERROR;\n\n    strm->total_in = strm->total_out = 0;\n    strm->msg = NULL;\n    strm->data_type = Z_UNKNOWN;\n\n    s = (deflate_state *)strm->state;\n    s->pending = 0;\n    s->pending_out = s->pending_buf;\n\n    if (s->noheader < 0) {\n        s->noheader = 0;  \n    }\n    s->status = s->noheader ? BUSY_STATE : INIT_STATE;\n    strm->adler = 1;\n    s->last_flush = Z_NO_FLUSH;\n\n    zlib_tr_init(s);\n    lm_init(s);\n\n    DEFLATE_RESET_HOOK(strm);\n\n    return Z_OK;\n}\n\n \nstatic void putShortMSB(\n\tdeflate_state *s,\n\tuInt b\n)\n{\n    put_byte(s, (Byte)(b >> 8));\n    put_byte(s, (Byte)(b & 0xff));\n}   \n\n \nint zlib_deflate(\n\tz_streamp strm,\n\tint flush\n)\n{\n    int old_flush;  \n    deflate_state *s;\n\n    if (strm == NULL || strm->state == NULL ||\n\tflush > Z_FINISH || flush < 0) {\n        return Z_STREAM_ERROR;\n    }\n    s = (deflate_state *) strm->state;\n\n    if ((strm->next_in == NULL && strm->avail_in != 0) ||\n\t(s->status == FINISH_STATE && flush != Z_FINISH)) {\n        return Z_STREAM_ERROR;\n    }\n    if (strm->avail_out == 0) return Z_BUF_ERROR;\n\n    s->strm = strm;  \n    old_flush = s->last_flush;\n    s->last_flush = flush;\n\n     \n    if (s->status == INIT_STATE) {\n\n        uInt header = (Z_DEFLATED + ((s->w_bits-8)<<4)) << 8;\n        uInt level_flags = (s->level-1) >> 1;\n\n        if (level_flags > 3) level_flags = 3;\n        header |= (level_flags << 6);\n\tif (s->strstart != 0) header |= PRESET_DICT;\n        header += 31 - (header % 31);\n\n        s->status = BUSY_STATE;\n        putShortMSB(s, header);\n\n\t \n\tif (s->strstart != 0) {\n\t    putShortMSB(s, (uInt)(strm->adler >> 16));\n\t    putShortMSB(s, (uInt)(strm->adler & 0xffff));\n\t}\n\tstrm->adler = 1L;\n    }\n\n     \n    if (s->pending != 0) {\n        flush_pending(strm);\n        if (strm->avail_out == 0) {\n\t     \n\t    s->last_flush = -1;\n\t    return Z_OK;\n\t}\n\n     \n    } else if (strm->avail_in == 0 && flush <= old_flush &&\n\t       flush != Z_FINISH) {\n        return Z_BUF_ERROR;\n    }\n\n     \n    if (s->status == FINISH_STATE && strm->avail_in != 0) {\n        return Z_BUF_ERROR;\n    }\n\n     \n    if (strm->avail_in != 0 || s->lookahead != 0 ||\n        (flush != Z_NO_FLUSH && s->status != FINISH_STATE)) {\n        block_state bstate;\n\n\tbstate = DEFLATE_HOOK(strm, flush, &bstate) ? bstate :\n\t\t (*(configuration_table[s->level].func))(s, flush);\n\n        if (bstate == finish_started || bstate == finish_done) {\n            s->status = FINISH_STATE;\n        }\n        if (bstate == need_more || bstate == finish_started) {\n\t    if (strm->avail_out == 0) {\n\t        s->last_flush = -1;  \n\t    }\n\t    return Z_OK;\n\t     \n\t}\n        if (bstate == block_done) {\n            if (flush == Z_PARTIAL_FLUSH) {\n                zlib_tr_align(s);\n\t    } else if (flush == Z_PACKET_FLUSH) {\n\t\t \n\t\tzlib_tr_stored_type_only(s);\n            } else {  \n                zlib_tr_stored_block(s, (char*)0, 0L, 0);\n                 \n                if (flush == Z_FULL_FLUSH) {\n                    CLEAR_HASH(s);              \n                }\n            }\n            flush_pending(strm);\n\t    if (strm->avail_out == 0) {\n\t      s->last_flush = -1;  \n\t      return Z_OK;\n\t    }\n        }\n    }\n    Assert(strm->avail_out > 0, \"bug2\");\n\n    if (flush != Z_FINISH) return Z_OK;\n\n    if (!s->noheader) {\n\t \n\tputShortMSB(s, (uInt)(strm->adler >> 16));\n\tputShortMSB(s, (uInt)(strm->adler & 0xffff));\n    }\n    flush_pending(strm);\n     \n    if (!s->noheader) {\n\ts->noheader = -1;  \n    }\n    if (s->pending == 0) {\n\tAssert(s->bi_valid == 0, \"bi_buf not flushed\");\n\treturn Z_STREAM_END;\n    }\n    return Z_OK;\n}\n\n \nint zlib_deflateEnd(\n\tz_streamp strm\n)\n{\n    int status;\n    deflate_state *s;\n\n    if (strm == NULL || strm->state == NULL) return Z_STREAM_ERROR;\n    s = (deflate_state *) strm->state;\n\n    status = s->status;\n    if (status != INIT_STATE && status != BUSY_STATE &&\n\tstatus != FINISH_STATE) {\n      return Z_STREAM_ERROR;\n    }\n\n    strm->state = NULL;\n\n    return status == BUSY_STATE ? Z_DATA_ERROR : Z_OK;\n}\n\n \nstatic int read_buf(\n\tz_streamp strm,\n\tByte *buf,\n\tunsigned size\n)\n{\n    unsigned len = strm->avail_in;\n\n    if (len > size) len = size;\n    if (len == 0) return 0;\n\n    strm->avail_in  -= len;\n\n    if (!DEFLATE_NEED_CHECKSUM(strm)) {}\n    else if (!((deflate_state *)(strm->state))->noheader) {\n        strm->adler = zlib_adler32(strm->adler, strm->next_in, len);\n    }\n    memcpy(buf, strm->next_in, len);\n    strm->next_in  += len;\n    strm->total_in += len;\n\n    return (int)len;\n}\n\n \nstatic void lm_init(\n\tdeflate_state *s\n)\n{\n    s->window_size = (ulg)2L*s->w_size;\n\n    CLEAR_HASH(s);\n\n     \n    s->max_lazy_match   = configuration_table[s->level].max_lazy;\n    s->good_match       = configuration_table[s->level].good_length;\n    s->nice_match       = configuration_table[s->level].nice_length;\n    s->max_chain_length = configuration_table[s->level].max_chain;\n\n    s->strstart = 0;\n    s->block_start = 0L;\n    s->lookahead = 0;\n    s->match_length = s->prev_length = MIN_MATCH-1;\n    s->match_available = 0;\n    s->ins_h = 0;\n}\n\n \n \nstatic uInt longest_match(\n\tdeflate_state *s,\n\tIPos cur_match\t\t\t \n)\n{\n    unsigned chain_length = s->max_chain_length; \n    register Byte *scan = s->window + s->strstart;  \n    register Byte *match;                        \n    register int len;                            \n    int best_len = s->prev_length;               \n    int nice_match = s->nice_match;              \n    IPos limit = s->strstart > (IPos)MAX_DIST(s) ?\n        s->strstart - (IPos)MAX_DIST(s) : NIL;\n     \n    Pos *prev = s->prev;\n    uInt wmask = s->w_mask;\n\n#ifdef UNALIGNED_OK\n     \n    register Byte *strend = s->window + s->strstart + MAX_MATCH - 1;\n    register ush scan_start = *(ush*)scan;\n    register ush scan_end   = *(ush*)(scan+best_len-1);\n#else\n    register Byte *strend = s->window + s->strstart + MAX_MATCH;\n    register Byte scan_end1  = scan[best_len-1];\n    register Byte scan_end   = scan[best_len];\n#endif\n\n     \n    Assert(s->hash_bits >= 8 && MAX_MATCH == 258, \"Code too clever\");\n\n     \n    if (s->prev_length >= s->good_match) {\n        chain_length >>= 2;\n    }\n     \n    if ((uInt)nice_match > s->lookahead) nice_match = s->lookahead;\n\n    Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, \"need lookahead\");\n\n    do {\n        Assert(cur_match < s->strstart, \"no future\");\n        match = s->window + cur_match;\n\n         \n#if (defined(UNALIGNED_OK) && MAX_MATCH == 258)\n         \n        if (*(ush*)(match+best_len-1) != scan_end ||\n            *(ush*)match != scan_start) continue;\n\n         \n        Assert(scan[2] == match[2], \"scan[2]?\");\n        scan++, match++;\n        do {\n        } while (*(ush*)(scan+=2) == *(ush*)(match+=2) &&\n                 *(ush*)(scan+=2) == *(ush*)(match+=2) &&\n                 *(ush*)(scan+=2) == *(ush*)(match+=2) &&\n                 *(ush*)(scan+=2) == *(ush*)(match+=2) &&\n                 scan < strend);\n         \n\n         \n        Assert(scan <= s->window+(unsigned)(s->window_size-1), \"wild scan\");\n        if (*scan == *match) scan++;\n\n        len = (MAX_MATCH - 1) - (int)(strend-scan);\n        scan = strend - (MAX_MATCH-1);\n\n#else  \n\n        if (match[best_len]   != scan_end  ||\n            match[best_len-1] != scan_end1 ||\n            *match            != *scan     ||\n            *++match          != scan[1])      continue;\n\n         \n        scan += 2, match++;\n        Assert(*scan == *match, \"match[2]?\");\n\n         \n        do {\n        } while (*++scan == *++match && *++scan == *++match &&\n                 *++scan == *++match && *++scan == *++match &&\n                 *++scan == *++match && *++scan == *++match &&\n                 *++scan == *++match && *++scan == *++match &&\n                 scan < strend);\n\n        Assert(scan <= s->window+(unsigned)(s->window_size-1), \"wild scan\");\n\n        len = MAX_MATCH - (int)(strend - scan);\n        scan = strend - MAX_MATCH;\n\n#endif  \n\n        if (len > best_len) {\n            s->match_start = cur_match;\n            best_len = len;\n            if (len >= nice_match) break;\n#ifdef UNALIGNED_OK\n            scan_end = *(ush*)(scan+best_len-1);\n#else\n            scan_end1  = scan[best_len-1];\n            scan_end   = scan[best_len];\n#endif\n        }\n    } while ((cur_match = prev[cur_match & wmask]) > limit\n             && --chain_length != 0);\n\n    if ((uInt)best_len <= s->lookahead) return best_len;\n    return s->lookahead;\n}\n\n#ifdef DEBUG_ZLIB\n \nstatic void check_match(\n\tdeflate_state *s,\n\tIPos start,\n\tIPos match,\n\tint length\n)\n{\n     \n    if (memcmp((char *)s->window + match,\n                (char *)s->window + start, length) != EQUAL) {\n        fprintf(stderr, \" start %u, match %u, length %d\\n\",\n\t\tstart, match, length);\n        do {\n\t    fprintf(stderr, \"%c%c\", s->window[match++], s->window[start++]);\n\t} while (--length != 0);\n        z_error(\"invalid match\");\n    }\n    if (z_verbose > 1) {\n        fprintf(stderr,\"\\\\[%d,%d]\", start-match, length);\n        do { putc(s->window[start++], stderr); } while (--length != 0);\n    }\n}\n#else\n#  define check_match(s, start, match, length)\n#endif\n\n \nstatic void fill_window(\n\tdeflate_state *s\n)\n{\n    register unsigned n, m;\n    register Pos *p;\n    unsigned more;     \n    uInt wsize = s->w_size;\n\n    do {\n        more = (unsigned)(s->window_size -(ulg)s->lookahead -(ulg)s->strstart);\n\n         \n        if (more == 0 && s->strstart == 0 && s->lookahead == 0) {\n            more = wsize;\n\n        } else if (more == (unsigned)(-1)) {\n             \n            more--;\n\n         \n        } else if (s->strstart >= wsize+MAX_DIST(s)) {\n\n            memcpy((char *)s->window, (char *)s->window+wsize,\n                   (unsigned)wsize);\n            s->match_start -= wsize;\n            s->strstart    -= wsize;  \n            s->block_start -= (long) wsize;\n\n             \n            n = s->hash_size;\n            p = &s->head[n];\n            do {\n                m = *--p;\n                *p = (Pos)(m >= wsize ? m-wsize : NIL);\n            } while (--n);\n\n            n = wsize;\n            p = &s->prev[n];\n            do {\n                m = *--p;\n                *p = (Pos)(m >= wsize ? m-wsize : NIL);\n                 \n            } while (--n);\n            more += wsize;\n        }\n        if (s->strm->avail_in == 0) return;\n\n         \n        Assert(more >= 2, \"more < 2\");\n\n        n = read_buf(s->strm, s->window + s->strstart + s->lookahead, more);\n        s->lookahead += n;\n\n         \n        if (s->lookahead >= MIN_MATCH) {\n            s->ins_h = s->window[s->strstart];\n            UPDATE_HASH(s, s->ins_h, s->window[s->strstart+1]);\n#if MIN_MATCH != 3\n            Call UPDATE_HASH() MIN_MATCH-3 more times\n#endif\n        }\n         \n\n    } while (s->lookahead < MIN_LOOKAHEAD && s->strm->avail_in != 0);\n}\n\n \n#define FLUSH_BLOCK_ONLY(s, eof) { \\\n   zlib_tr_flush_block(s, (s->block_start >= 0L ? \\\n                   (char *)&s->window[(unsigned)s->block_start] : \\\n                   NULL), \\\n\t\t(ulg)((long)s->strstart - s->block_start), \\\n\t\t(eof)); \\\n   s->block_start = s->strstart; \\\n   flush_pending(s->strm); \\\n   Tracev((stderr,\"[FLUSH]\")); \\\n}\n\n \n#define FLUSH_BLOCK(s, eof) { \\\n   FLUSH_BLOCK_ONLY(s, eof); \\\n   if (s->strm->avail_out == 0) return (eof) ? finish_started : need_more; \\\n}\n\n \nstatic block_state deflate_stored(\n\tdeflate_state *s,\n\tint flush\n)\n{\n     \n    ulg max_block_size = 0xffff;\n    ulg max_start;\n\n    if (max_block_size > s->pending_buf_size - 5) {\n        max_block_size = s->pending_buf_size - 5;\n    }\n\n     \n    for (;;) {\n         \n        if (s->lookahead <= 1) {\n\n            Assert(s->strstart < s->w_size+MAX_DIST(s) ||\n\t\t   s->block_start >= (long)s->w_size, \"slide too late\");\n\n            fill_window(s);\n            if (s->lookahead == 0 && flush == Z_NO_FLUSH) return need_more;\n\n            if (s->lookahead == 0) break;  \n        }\n\tAssert(s->block_start >= 0L, \"block gone\");\n\n\ts->strstart += s->lookahead;\n\ts->lookahead = 0;\n\n\t \n \tmax_start = s->block_start + max_block_size;\n        if (s->strstart == 0 || (ulg)s->strstart >= max_start) {\n\t     \n\t    s->lookahead = (uInt)(s->strstart - max_start);\n\t    s->strstart = (uInt)max_start;\n            FLUSH_BLOCK(s, 0);\n\t}\n\t \n        if (s->strstart - (uInt)s->block_start >= MAX_DIST(s)) {\n            FLUSH_BLOCK(s, 0);\n\t}\n    }\n    FLUSH_BLOCK(s, flush == Z_FINISH);\n    return flush == Z_FINISH ? finish_done : block_done;\n}\n\n \nstatic block_state deflate_fast(\n\tdeflate_state *s,\n\tint flush\n)\n{\n    IPos hash_head = NIL;  \n    int bflush;            \n\n    for (;;) {\n         \n        if (s->lookahead < MIN_LOOKAHEAD) {\n            fill_window(s);\n            if (s->lookahead < MIN_LOOKAHEAD && flush == Z_NO_FLUSH) {\n\t        return need_more;\n\t    }\n            if (s->lookahead == 0) break;  \n        }\n\n         \n        if (s->lookahead >= MIN_MATCH) {\n            INSERT_STRING(s, s->strstart, hash_head);\n        }\n\n         \n        if (hash_head != NIL && s->strstart - hash_head <= MAX_DIST(s)) {\n             \n            if (s->strategy != Z_HUFFMAN_ONLY) {\n                s->match_length = longest_match (s, hash_head);\n            }\n             \n        }\n        if (s->match_length >= MIN_MATCH) {\n            check_match(s, s->strstart, s->match_start, s->match_length);\n\n            bflush = zlib_tr_tally(s, s->strstart - s->match_start,\n                               s->match_length - MIN_MATCH);\n\n            s->lookahead -= s->match_length;\n\n             \n            if (s->match_length <= s->max_insert_length &&\n                s->lookahead >= MIN_MATCH) {\n                s->match_length--;  \n                do {\n                    s->strstart++;\n                    INSERT_STRING(s, s->strstart, hash_head);\n                     \n                } while (--s->match_length != 0);\n                s->strstart++; \n            } else {\n                s->strstart += s->match_length;\n                s->match_length = 0;\n                s->ins_h = s->window[s->strstart];\n                UPDATE_HASH(s, s->ins_h, s->window[s->strstart+1]);\n#if MIN_MATCH != 3\n                Call UPDATE_HASH() MIN_MATCH-3 more times\n#endif\n                 \n            }\n        } else {\n             \n            Tracevv((stderr,\"%c\", s->window[s->strstart]));\n            bflush = zlib_tr_tally (s, 0, s->window[s->strstart]);\n            s->lookahead--;\n            s->strstart++; \n        }\n        if (bflush) FLUSH_BLOCK(s, 0);\n    }\n    FLUSH_BLOCK(s, flush == Z_FINISH);\n    return flush == Z_FINISH ? finish_done : block_done;\n}\n\n \nstatic block_state deflate_slow(\n\tdeflate_state *s,\n\tint flush\n)\n{\n    IPos hash_head = NIL;     \n    int bflush;               \n\n     \n    for (;;) {\n         \n        if (s->lookahead < MIN_LOOKAHEAD) {\n            fill_window(s);\n            if (s->lookahead < MIN_LOOKAHEAD && flush == Z_NO_FLUSH) {\n\t        return need_more;\n\t    }\n            if (s->lookahead == 0) break;  \n        }\n\n         \n        if (s->lookahead >= MIN_MATCH) {\n            INSERT_STRING(s, s->strstart, hash_head);\n        }\n\n         \n        s->prev_length = s->match_length, s->prev_match = s->match_start;\n        s->match_length = MIN_MATCH-1;\n\n        if (hash_head != NIL && s->prev_length < s->max_lazy_match &&\n            s->strstart - hash_head <= MAX_DIST(s)) {\n             \n            if (s->strategy != Z_HUFFMAN_ONLY) {\n                s->match_length = longest_match (s, hash_head);\n            }\n             \n\n            if (s->match_length <= 5 && (s->strategy == Z_FILTERED ||\n                 (s->match_length == MIN_MATCH &&\n                  s->strstart - s->match_start > TOO_FAR))) {\n\n                 \n                s->match_length = MIN_MATCH-1;\n            }\n        }\n         \n        if (s->prev_length >= MIN_MATCH && s->match_length <= s->prev_length) {\n            uInt max_insert = s->strstart + s->lookahead - MIN_MATCH;\n             \n\n            check_match(s, s->strstart-1, s->prev_match, s->prev_length);\n\n            bflush = zlib_tr_tally(s, s->strstart -1 - s->prev_match,\n\t\t\t\t   s->prev_length - MIN_MATCH);\n\n             \n            s->lookahead -= s->prev_length-1;\n            s->prev_length -= 2;\n            do {\n                if (++s->strstart <= max_insert) {\n                    INSERT_STRING(s, s->strstart, hash_head);\n                }\n            } while (--s->prev_length != 0);\n            s->match_available = 0;\n            s->match_length = MIN_MATCH-1;\n            s->strstart++;\n\n            if (bflush) FLUSH_BLOCK(s, 0);\n\n        } else if (s->match_available) {\n             \n            Tracevv((stderr,\"%c\", s->window[s->strstart-1]));\n            if (zlib_tr_tally (s, 0, s->window[s->strstart-1])) {\n                FLUSH_BLOCK_ONLY(s, 0);\n            }\n            s->strstart++;\n            s->lookahead--;\n            if (s->strm->avail_out == 0) return need_more;\n        } else {\n             \n            s->match_available = 1;\n            s->strstart++;\n            s->lookahead--;\n        }\n    }\n    Assert (flush != Z_NO_FLUSH, \"no flush?\");\n    if (s->match_available) {\n        Tracevv((stderr,\"%c\", s->window[s->strstart-1]));\n        zlib_tr_tally (s, 0, s->window[s->strstart-1]);\n        s->match_available = 0;\n    }\n    FLUSH_BLOCK(s, flush == Z_FINISH);\n    return flush == Z_FINISH ? finish_done : block_done;\n}\n\nint zlib_deflate_workspacesize(int windowBits, int memLevel)\n{\n    if (windowBits < 0)  \n        windowBits = -windowBits;\n\n     \n    BUG_ON(memLevel < 1 || memLevel > MAX_MEM_LEVEL || windowBits < 9 ||\n\t\t\t\t\t\t\twindowBits > 15);\n\n    return sizeof(deflate_workspace)\n        + zlib_deflate_window_memsize(windowBits)\n        + zlib_deflate_prev_memsize(windowBits)\n        + zlib_deflate_head_memsize(memLevel)\n        + zlib_deflate_overlay_memsize(memLevel);\n}\n\nint zlib_deflate_dfltcc_enabled(void)\n{\n\treturn DEFLATE_DFLTCC_ENABLED();\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}