{
  "module_name": "deftree.c",
  "hash_id": "d97bd79139a5b2c84a94ba1307b3072f7857a4d806096caec1010877b831a2a8",
  "original_prompt": "Ingested from linux-6.6.14/lib/zlib_deflate/deftree.c",
  "human_readable_source": " \n \n\n \n\n \n\n \n\n#include <linux/zutil.h>\n#include <linux/bitrev.h>\n#include \"defutil.h\"\n\n#ifdef DEBUG_ZLIB\n#  include <ctype.h>\n#endif\n\n \n\n#define MAX_BL_BITS 7\n \n\n#define END_BLOCK 256\n \n\n#define REP_3_6      16\n \n\n#define REPZ_3_10    17\n \n\n#define REPZ_11_138  18\n \n\nstatic const int extra_lbits[LENGTH_CODES]  \n   = {0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0};\n\nstatic const int extra_dbits[D_CODES]  \n   = {0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13};\n\nstatic const int extra_blbits[BL_CODES] \n   = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7};\n\nstatic const uch bl_order[BL_CODES]\n   = {16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15};\n \n\n \n\nstatic ct_data static_ltree[L_CODES+2];\n \n\nstatic ct_data static_dtree[D_CODES];\n \n\nstatic uch dist_code[512];\n \n\nstatic uch length_code[MAX_MATCH-MIN_MATCH+1];\n \n\nstatic int base_length[LENGTH_CODES];\n \n\nstatic int base_dist[D_CODES];\n \n\nstruct static_tree_desc_s {\n    const ct_data *static_tree;   \n    const int *extra_bits;        \n    int     extra_base;           \n    int     elems;                \n    int     max_length;           \n};\n\nstatic static_tree_desc  static_l_desc =\n{static_ltree, extra_lbits, LITERALS+1, L_CODES, MAX_BITS};\n\nstatic static_tree_desc  static_d_desc =\n{static_dtree, extra_dbits, 0,          D_CODES, MAX_BITS};\n\nstatic static_tree_desc  static_bl_desc =\n{(const ct_data *)0, extra_blbits, 0,   BL_CODES, MAX_BL_BITS};\n\n \n\nstatic void tr_static_init (void);\nstatic void init_block     (deflate_state *s);\nstatic void pqdownheap     (deflate_state *s, ct_data *tree, int k);\nstatic void gen_bitlen     (deflate_state *s, tree_desc *desc);\nstatic void gen_codes      (ct_data *tree, int max_code, ush *bl_count);\nstatic void build_tree     (deflate_state *s, tree_desc *desc);\nstatic void scan_tree      (deflate_state *s, ct_data *tree, int max_code);\nstatic void send_tree      (deflate_state *s, ct_data *tree, int max_code);\nstatic int  build_bl_tree  (deflate_state *s);\nstatic void send_all_trees (deflate_state *s, int lcodes, int dcodes,\n                           int blcodes);\nstatic void compress_block (deflate_state *s, ct_data *ltree,\n                           ct_data *dtree);\nstatic void set_data_type  (deflate_state *s);\nstatic void bi_flush       (deflate_state *s);\nstatic void copy_block     (deflate_state *s, char *buf, unsigned len,\n                           int header);\n\n#ifndef DEBUG_ZLIB\n#  define send_code(s, c, tree) send_bits(s, tree[c].Code, tree[c].Len)\n    \n\n#else  \n#  define send_code(s, c, tree) \\\n     { if (z_verbose>2) fprintf(stderr,\"\\ncd %3d \",(c)); \\\n       send_bits(s, tree[c].Code, tree[c].Len); }\n#endif\n\n#define d_code(dist) \\\n   ((dist) < 256 ? dist_code[dist] : dist_code[256+((dist)>>7)])\n \n\n \nstatic void tr_static_init(void)\n{\n    static int static_init_done;\n    int n;         \n    int bits;      \n    int length;    \n    int code;      \n    int dist;      \n    ush bl_count[MAX_BITS+1];\n     \n\n    if (static_init_done) return;\n\n     \n    length = 0;\n    for (code = 0; code < LENGTH_CODES-1; code++) {\n        base_length[code] = length;\n        for (n = 0; n < (1<<extra_lbits[code]); n++) {\n            length_code[length++] = (uch)code;\n        }\n    }\n    Assert (length == 256, \"tr_static_init: length != 256\");\n     \n    length_code[length-1] = (uch)code;\n\n     \n    dist = 0;\n    for (code = 0 ; code < 16; code++) {\n        base_dist[code] = dist;\n        for (n = 0; n < (1<<extra_dbits[code]); n++) {\n            dist_code[dist++] = (uch)code;\n        }\n    }\n    Assert (dist == 256, \"tr_static_init: dist != 256\");\n    dist >>= 7;  \n    for ( ; code < D_CODES; code++) {\n        base_dist[code] = dist << 7;\n        for (n = 0; n < (1<<(extra_dbits[code]-7)); n++) {\n            dist_code[256 + dist++] = (uch)code;\n        }\n    }\n    Assert (dist == 256, \"tr_static_init: 256+dist != 512\");\n\n     \n    for (bits = 0; bits <= MAX_BITS; bits++) bl_count[bits] = 0;\n    n = 0;\n    while (n <= 143) static_ltree[n++].Len = 8, bl_count[8]++;\n    while (n <= 255) static_ltree[n++].Len = 9, bl_count[9]++;\n    while (n <= 279) static_ltree[n++].Len = 7, bl_count[7]++;\n    while (n <= 287) static_ltree[n++].Len = 8, bl_count[8]++;\n     \n    gen_codes((ct_data *)static_ltree, L_CODES+1, bl_count);\n\n     \n    for (n = 0; n < D_CODES; n++) {\n        static_dtree[n].Len = 5;\n        static_dtree[n].Code = bitrev32((u32)n) >> (32 - 5);\n    }\n    static_init_done = 1;\n}\n\n \nvoid zlib_tr_init(\n\tdeflate_state *s\n)\n{\n    tr_static_init();\n\n    s->compressed_len = 0L;\n\n    s->l_desc.dyn_tree = s->dyn_ltree;\n    s->l_desc.stat_desc = &static_l_desc;\n\n    s->d_desc.dyn_tree = s->dyn_dtree;\n    s->d_desc.stat_desc = &static_d_desc;\n\n    s->bl_desc.dyn_tree = s->bl_tree;\n    s->bl_desc.stat_desc = &static_bl_desc;\n\n    s->bi_buf = 0;\n    s->bi_valid = 0;\n    s->last_eob_len = 8;  \n#ifdef DEBUG_ZLIB\n    s->bits_sent = 0L;\n#endif\n\n     \n    init_block(s);\n}\n\n \nstatic void init_block(\n\tdeflate_state *s\n)\n{\n    int n;  \n\n     \n    for (n = 0; n < L_CODES;  n++) s->dyn_ltree[n].Freq = 0;\n    for (n = 0; n < D_CODES;  n++) s->dyn_dtree[n].Freq = 0;\n    for (n = 0; n < BL_CODES; n++) s->bl_tree[n].Freq = 0;\n\n    s->dyn_ltree[END_BLOCK].Freq = 1;\n    s->opt_len = s->static_len = 0L;\n    s->last_lit = s->matches = 0;\n}\n\n#define SMALLEST 1\n \n\n\n \n#define pqremove(s, tree, top) \\\n{\\\n    top = s->heap[SMALLEST]; \\\n    s->heap[SMALLEST] = s->heap[s->heap_len--]; \\\n    pqdownheap(s, tree, SMALLEST); \\\n}\n\n \n#define smaller(tree, n, m, depth) \\\n   (tree[n].Freq < tree[m].Freq || \\\n   (tree[n].Freq == tree[m].Freq && depth[n] <= depth[m]))\n\n \nstatic void pqdownheap(\n\tdeflate_state *s,\n\tct_data *tree,   \n\tint k\t\t \n)\n{\n    int v = s->heap[k];\n    int j = k << 1;   \n    while (j <= s->heap_len) {\n         \n        if (j < s->heap_len &&\n            smaller(tree, s->heap[j+1], s->heap[j], s->depth)) {\n            j++;\n        }\n         \n        if (smaller(tree, v, s->heap[j], s->depth)) break;\n\n         \n        s->heap[k] = s->heap[j];  k = j;\n\n         \n        j <<= 1;\n    }\n    s->heap[k] = v;\n}\n\n \nstatic void gen_bitlen(\n\tdeflate_state *s,\n\ttree_desc *desc     \n)\n{\n    ct_data *tree        = desc->dyn_tree;\n    int max_code         = desc->max_code;\n    const ct_data *stree = desc->stat_desc->static_tree;\n    const int *extra     = desc->stat_desc->extra_bits;\n    int base             = desc->stat_desc->extra_base;\n    int max_length       = desc->stat_desc->max_length;\n    int h;               \n    int n, m;            \n    int bits;            \n    int xbits;           \n    ush f;               \n    int overflow = 0;    \n\n    for (bits = 0; bits <= MAX_BITS; bits++) s->bl_count[bits] = 0;\n\n     \n    tree[s->heap[s->heap_max]].Len = 0;  \n\n    for (h = s->heap_max+1; h < HEAP_SIZE; h++) {\n        n = s->heap[h];\n        bits = tree[tree[n].Dad].Len + 1;\n        if (bits > max_length) bits = max_length, overflow++;\n        tree[n].Len = (ush)bits;\n         \n\n        if (n > max_code) continue;  \n\n        s->bl_count[bits]++;\n        xbits = 0;\n        if (n >= base) xbits = extra[n-base];\n        f = tree[n].Freq;\n        s->opt_len += (ulg)f * (bits + xbits);\n        if (stree) s->static_len += (ulg)f * (stree[n].Len + xbits);\n    }\n    if (overflow == 0) return;\n\n    Trace((stderr,\"\\nbit length overflow\\n\"));\n     \n\n     \n    do {\n        bits = max_length-1;\n        while (s->bl_count[bits] == 0) bits--;\n        s->bl_count[bits]--;       \n        s->bl_count[bits+1] += 2;  \n        s->bl_count[max_length]--;\n         \n        overflow -= 2;\n    } while (overflow > 0);\n\n     \n    for (bits = max_length; bits != 0; bits--) {\n        n = s->bl_count[bits];\n        while (n != 0) {\n            m = s->heap[--h];\n            if (m > max_code) continue;\n            if (tree[m].Len != (unsigned) bits) {\n                Trace((stderr,\"code %d bits %d->%d\\n\", m, tree[m].Len, bits));\n                s->opt_len += ((long)bits - (long)tree[m].Len)\n                              *(long)tree[m].Freq;\n                tree[m].Len = (ush)bits;\n            }\n            n--;\n        }\n    }\n}\n\n \nstatic void gen_codes(\n\tct_data *tree,              \n\tint max_code,               \n\tush *bl_count              \n)\n{\n    ush next_code[MAX_BITS+1];  \n    ush code = 0;               \n    int bits;                   \n    int n;                      \n\n     \n    for (bits = 1; bits <= MAX_BITS; bits++) {\n        next_code[bits] = code = (code + bl_count[bits-1]) << 1;\n    }\n     \n    Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,\n            \"inconsistent bit counts\");\n    Tracev((stderr,\"\\ngen_codes: max_code %d \", max_code));\n\n    for (n = 0;  n <= max_code; n++) {\n        int len = tree[n].Len;\n        if (len == 0) continue;\n         \n        tree[n].Code = bitrev32((u32)(next_code[len]++)) >> (32 - len);\n\n        Tracecv(tree != static_ltree, (stderr,\"\\nn %3d %c l %2d c %4x (%x) \",\n             n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));\n    }\n}\n\n \nstatic void build_tree(\n\tdeflate_state *s,\n\ttree_desc *desc\t  \n)\n{\n    ct_data *tree         = desc->dyn_tree;\n    const ct_data *stree  = desc->stat_desc->static_tree;\n    int elems             = desc->stat_desc->elems;\n    int n, m;           \n    int max_code = -1;  \n    int node;           \n\n     \n    s->heap_len = 0, s->heap_max = HEAP_SIZE;\n\n    for (n = 0; n < elems; n++) {\n        if (tree[n].Freq != 0) {\n            s->heap[++(s->heap_len)] = max_code = n;\n            s->depth[n] = 0;\n        } else {\n            tree[n].Len = 0;\n        }\n    }\n\n     \n    while (s->heap_len < 2) {\n        node = s->heap[++(s->heap_len)] = (max_code < 2 ? ++max_code : 0);\n        tree[node].Freq = 1;\n        s->depth[node] = 0;\n        s->opt_len--; if (stree) s->static_len -= stree[node].Len;\n         \n    }\n    desc->max_code = max_code;\n\n     \n    for (n = s->heap_len/2; n >= 1; n--) pqdownheap(s, tree, n);\n\n     \n    node = elems;               \n    do {\n        pqremove(s, tree, n);   \n        m = s->heap[SMALLEST];  \n\n        s->heap[--(s->heap_max)] = n;  \n        s->heap[--(s->heap_max)] = m;\n\n         \n        tree[node].Freq = tree[n].Freq + tree[m].Freq;\n        s->depth[node] = (uch) (max(s->depth[n], s->depth[m]) + 1);\n        tree[n].Dad = tree[m].Dad = (ush)node;\n#ifdef DUMP_BL_TREE\n        if (tree == s->bl_tree) {\n            fprintf(stderr,\"\\nnode %d(%d), sons %d(%d) %d(%d)\",\n                    node, tree[node].Freq, n, tree[n].Freq, m, tree[m].Freq);\n        }\n#endif\n         \n        s->heap[SMALLEST] = node++;\n        pqdownheap(s, tree, SMALLEST);\n\n    } while (s->heap_len >= 2);\n\n    s->heap[--(s->heap_max)] = s->heap[SMALLEST];\n\n     \n    gen_bitlen(s, (tree_desc *)desc);\n\n     \n    gen_codes ((ct_data *)tree, max_code, s->bl_count);\n}\n\n \nstatic void scan_tree(\n\tdeflate_state *s,\n\tct_data *tree,    \n\tint max_code      \n)\n{\n    int n;                      \n    int prevlen = -1;           \n    int curlen;                 \n    int nextlen = tree[0].Len;  \n    int count = 0;              \n    int max_count = 7;          \n    int min_count = 4;          \n\n    if (nextlen == 0) max_count = 138, min_count = 3;\n    tree[max_code+1].Len = (ush)0xffff;  \n\n    for (n = 0; n <= max_code; n++) {\n        curlen = nextlen; nextlen = tree[n+1].Len;\n        if (++count < max_count && curlen == nextlen) {\n            continue;\n        } else if (count < min_count) {\n            s->bl_tree[curlen].Freq += count;\n        } else if (curlen != 0) {\n            if (curlen != prevlen) s->bl_tree[curlen].Freq++;\n            s->bl_tree[REP_3_6].Freq++;\n        } else if (count <= 10) {\n            s->bl_tree[REPZ_3_10].Freq++;\n        } else {\n            s->bl_tree[REPZ_11_138].Freq++;\n        }\n        count = 0; prevlen = curlen;\n        if (nextlen == 0) {\n            max_count = 138, min_count = 3;\n        } else if (curlen == nextlen) {\n            max_count = 6, min_count = 3;\n        } else {\n            max_count = 7, min_count = 4;\n        }\n    }\n}\n\n \nstatic void send_tree(\n\tdeflate_state *s,\n\tct_data *tree,  \n\tint max_code    \n)\n{\n    int n;                      \n    int prevlen = -1;           \n    int curlen;                 \n    int nextlen = tree[0].Len;  \n    int count = 0;              \n    int max_count = 7;          \n    int min_count = 4;          \n\n        \n    if (nextlen == 0) max_count = 138, min_count = 3;\n\n    for (n = 0; n <= max_code; n++) {\n        curlen = nextlen; nextlen = tree[n+1].Len;\n        if (++count < max_count && curlen == nextlen) {\n            continue;\n        } else if (count < min_count) {\n            do { send_code(s, curlen, s->bl_tree); } while (--count != 0);\n\n        } else if (curlen != 0) {\n            if (curlen != prevlen) {\n                send_code(s, curlen, s->bl_tree); count--;\n            }\n            Assert(count >= 3 && count <= 6, \" 3_6?\");\n            send_code(s, REP_3_6, s->bl_tree); send_bits(s, count-3, 2);\n\n        } else if (count <= 10) {\n            send_code(s, REPZ_3_10, s->bl_tree); send_bits(s, count-3, 3);\n\n        } else {\n            send_code(s, REPZ_11_138, s->bl_tree); send_bits(s, count-11, 7);\n        }\n        count = 0; prevlen = curlen;\n        if (nextlen == 0) {\n            max_count = 138, min_count = 3;\n        } else if (curlen == nextlen) {\n            max_count = 6, min_count = 3;\n        } else {\n            max_count = 7, min_count = 4;\n        }\n    }\n}\n\n \nstatic int build_bl_tree(\n\tdeflate_state *s\n)\n{\n    int max_blindex;   \n\n     \n    scan_tree(s, (ct_data *)s->dyn_ltree, s->l_desc.max_code);\n    scan_tree(s, (ct_data *)s->dyn_dtree, s->d_desc.max_code);\n\n     \n    build_tree(s, (tree_desc *)(&(s->bl_desc)));\n     \n\n     \n    for (max_blindex = BL_CODES-1; max_blindex >= 3; max_blindex--) {\n        if (s->bl_tree[bl_order[max_blindex]].Len != 0) break;\n    }\n     \n    s->opt_len += 3*(max_blindex+1) + 5+5+4;\n    Tracev((stderr, \"\\ndyn trees: dyn %ld, stat %ld\",\n            s->opt_len, s->static_len));\n\n    return max_blindex;\n}\n\n \nstatic void send_all_trees(\n\tdeflate_state *s,\n\tint lcodes,   \n\tint dcodes,   \n\tint blcodes   \n)\n{\n    int rank;                     \n\n    Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, \"not enough codes\");\n    Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,\n            \"too many codes\");\n    Tracev((stderr, \"\\nbl counts: \"));\n    send_bits(s, lcodes-257, 5);  \n    send_bits(s, dcodes-1,   5);\n    send_bits(s, blcodes-4,  4);  \n    for (rank = 0; rank < blcodes; rank++) {\n        Tracev((stderr, \"\\nbl code %2d \", bl_order[rank]));\n        send_bits(s, s->bl_tree[bl_order[rank]].Len, 3);\n    }\n    Tracev((stderr, \"\\nbl tree: sent %ld\", s->bits_sent));\n\n    send_tree(s, (ct_data *)s->dyn_ltree, lcodes-1);  \n    Tracev((stderr, \"\\nlit tree: sent %ld\", s->bits_sent));\n\n    send_tree(s, (ct_data *)s->dyn_dtree, dcodes-1);  \n    Tracev((stderr, \"\\ndist tree: sent %ld\", s->bits_sent));\n}\n\n \nvoid zlib_tr_stored_block(\n\tdeflate_state *s,\n\tchar *buf,         \n\tulg stored_len,    \n\tint eof            \n)\n{\n    send_bits(s, (STORED_BLOCK<<1)+eof, 3);   \n    s->compressed_len = (s->compressed_len + 3 + 7) & (ulg)~7L;\n    s->compressed_len += (stored_len + 4) << 3;\n\n    copy_block(s, buf, (unsigned)stored_len, 1);  \n}\n\n \nvoid zlib_tr_stored_type_only(\n\tdeflate_state *s\n)\n{\n    send_bits(s, (STORED_BLOCK << 1), 3);\n    bi_windup(s);\n    s->compressed_len = (s->compressed_len + 3) & ~7L;\n}\n\n\n \nvoid zlib_tr_align(\n\tdeflate_state *s\n)\n{\n    send_bits(s, STATIC_TREES<<1, 3);\n    send_code(s, END_BLOCK, static_ltree);\n    s->compressed_len += 10L;  \n    bi_flush(s);\n     \n    if (1 + s->last_eob_len + 10 - s->bi_valid < 9) {\n        send_bits(s, STATIC_TREES<<1, 3);\n        send_code(s, END_BLOCK, static_ltree);\n        s->compressed_len += 10L;\n        bi_flush(s);\n    }\n    s->last_eob_len = 7;\n}\n\n \nulg zlib_tr_flush_block(\n\tdeflate_state *s,\n\tchar *buf,         \n\tulg stored_len,    \n\tint eof            \n)\n{\n    ulg opt_lenb, static_lenb;  \n    int max_blindex = 0;   \n\n     \n    if (s->level > 0) {\n\n\t  \n\tif (s->data_type == Z_UNKNOWN) set_data_type(s);\n\n\t \n\tbuild_tree(s, (tree_desc *)(&(s->l_desc)));\n\tTracev((stderr, \"\\nlit data: dyn %ld, stat %ld\", s->opt_len,\n\t\ts->static_len));\n\n\tbuild_tree(s, (tree_desc *)(&(s->d_desc)));\n\tTracev((stderr, \"\\ndist data: dyn %ld, stat %ld\", s->opt_len,\n\t\ts->static_len));\n\t \n\n\t \n\tmax_blindex = build_bl_tree(s);\n\n\t \n\topt_lenb = (s->opt_len+3+7)>>3;\n\tstatic_lenb = (s->static_len+3+7)>>3;\n\n\tTracev((stderr, \"\\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u \",\n\t\topt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,\n\t\ts->last_lit));\n\n\tif (static_lenb <= opt_lenb) opt_lenb = static_lenb;\n\n    } else {\n        Assert(buf != (char*)0, \"lost buf\");\n\topt_lenb = static_lenb = stored_len + 5;  \n    }\n\n     \n#ifdef STORED_FILE_OK\n#  ifdef FORCE_STORED_FILE\n    if (eof && s->compressed_len == 0L) {  \n#  else\n    if (stored_len <= opt_lenb && eof && s->compressed_len==0L && seekable()) {\n#  endif\n         \n        if (buf == (char*)0) error (\"block vanished\");\n\n        copy_block(s, buf, (unsigned)stored_len, 0);  \n        s->compressed_len = stored_len << 3;\n        s->method = STORED;\n    } else\n#endif  \n\n#ifdef FORCE_STORED\n    if (buf != (char*)0) {  \n#else\n    if (stored_len+4 <= opt_lenb && buf != (char*)0) {\n                        \n#endif\n         \n        zlib_tr_stored_block(s, buf, stored_len, eof);\n\n#ifdef FORCE_STATIC\n    } else if (static_lenb >= 0) {  \n#else\n    } else if (static_lenb == opt_lenb) {\n#endif\n        send_bits(s, (STATIC_TREES<<1)+eof, 3);\n        compress_block(s, (ct_data *)static_ltree, (ct_data *)static_dtree);\n        s->compressed_len += 3 + s->static_len;\n    } else {\n        send_bits(s, (DYN_TREES<<1)+eof, 3);\n        send_all_trees(s, s->l_desc.max_code+1, s->d_desc.max_code+1,\n                       max_blindex+1);\n        compress_block(s, (ct_data *)s->dyn_ltree, (ct_data *)s->dyn_dtree);\n        s->compressed_len += 3 + s->opt_len;\n    }\n    Assert (s->compressed_len == s->bits_sent, \"bad compressed size\");\n    init_block(s);\n\n    if (eof) {\n        bi_windup(s);\n        s->compressed_len += 7;   \n    }\n    Tracev((stderr,\"\\ncomprlen %lu(%lu) \", s->compressed_len>>3,\n           s->compressed_len-7*eof));\n\n    return s->compressed_len >> 3;\n}\n\n \nint zlib_tr_tally(\n\tdeflate_state *s,\n\tunsigned dist,   \n\tunsigned lc      \n)\n{\n    s->d_buf[s->last_lit] = (ush)dist;\n    s->l_buf[s->last_lit++] = (uch)lc;\n    if (dist == 0) {\n         \n        s->dyn_ltree[lc].Freq++;\n    } else {\n        s->matches++;\n         \n        dist--;              \n        Assert((ush)dist < (ush)MAX_DIST(s) &&\n               (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&\n               (ush)d_code(dist) < (ush)D_CODES,  \"zlib_tr_tally: bad match\");\n\n        s->dyn_ltree[length_code[lc]+LITERALS+1].Freq++;\n        s->dyn_dtree[d_code(dist)].Freq++;\n    }\n\n     \n    if ((s->last_lit & 0xfff) == 0 && s->level > 2) {\n         \n        ulg out_length = (ulg)s->last_lit*8L;\n        ulg in_length = (ulg)((long)s->strstart - s->block_start);\n        int dcode;\n        for (dcode = 0; dcode < D_CODES; dcode++) {\n            out_length += (ulg)s->dyn_dtree[dcode].Freq *\n                (5L+extra_dbits[dcode]);\n        }\n        out_length >>= 3;\n        Tracev((stderr,\"\\nlast_lit %u, in %ld, out ~%ld(%ld%%) \",\n               s->last_lit, in_length, out_length,\n               100L - out_length*100L/in_length));\n        if (s->matches < s->last_lit/2 && out_length < in_length/2) return 1;\n    }\n    return (s->last_lit == s->lit_bufsize-1);\n     \n}\n\n \nstatic void compress_block(\n\tdeflate_state *s,\n\tct_data *ltree,  \n\tct_data *dtree   \n)\n{\n    unsigned dist;       \n    int lc;              \n    unsigned lx = 0;     \n    unsigned code;       \n    int extra;           \n\n    if (s->last_lit != 0) do {\n        dist = s->d_buf[lx];\n        lc = s->l_buf[lx++];\n        if (dist == 0) {\n            send_code(s, lc, ltree);  \n            Tracecv(isgraph(lc), (stderr,\" '%c' \", lc));\n        } else {\n             \n            code = length_code[lc];\n            send_code(s, code+LITERALS+1, ltree);  \n            extra = extra_lbits[code];\n            if (extra != 0) {\n                lc -= base_length[code];\n                send_bits(s, lc, extra);        \n            }\n            dist--;  \n            code = d_code(dist);\n            Assert (code < D_CODES, \"bad d_code\");\n\n            send_code(s, code, dtree);        \n            extra = extra_dbits[code];\n            if (extra != 0) {\n                dist -= base_dist[code];\n                send_bits(s, dist, extra);    \n            }\n        }  \n\n         \n        Assert(s->pending < s->lit_bufsize + 2*lx, \"pendingBuf overflow\");\n\n    } while (lx < s->last_lit);\n\n    send_code(s, END_BLOCK, ltree);\n    s->last_eob_len = ltree[END_BLOCK].Len;\n}\n\n \nstatic void set_data_type(\n\tdeflate_state *s\n)\n{\n    int n = 0;\n    unsigned ascii_freq = 0;\n    unsigned bin_freq = 0;\n    while (n < 7)        bin_freq += s->dyn_ltree[n++].Freq;\n    while (n < 128)    ascii_freq += s->dyn_ltree[n++].Freq;\n    while (n < LITERALS) bin_freq += s->dyn_ltree[n++].Freq;\n    s->data_type = (Byte)(bin_freq > (ascii_freq >> 2) ? Z_BINARY : Z_ASCII);\n}\n\n \nstatic void copy_block(\n\tdeflate_state *s,\n\tchar    *buf,      \n\tunsigned len,      \n\tint      header    \n)\n{\n    bi_windup(s);         \n    s->last_eob_len = 8;  \n\n    if (header) {\n        put_short(s, (ush)len);   \n        put_short(s, (ush)~len);\n#ifdef DEBUG_ZLIB\n        s->bits_sent += 2*16;\n#endif\n    }\n#ifdef DEBUG_ZLIB\n    s->bits_sent += (ulg)len<<3;\n#endif\n     \n    memcpy(&s->pending_buf[s->pending], buf, len);\n    s->pending += len;\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}