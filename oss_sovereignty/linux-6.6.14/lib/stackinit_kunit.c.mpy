{
  "module_name": "stackinit_kunit.c",
  "hash_id": "61402dd779e9b25dbb53835d7cf347e3706c407458a72493534adb75bd74c4db",
  "original_prompt": "Ingested from linux-6.6.14/lib/stackinit_kunit.c",
  "human_readable_source": "\n \n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <kunit/test.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/string.h>\n\n \n#define MAX_VAR_SIZE\t128\nstatic u8 check_buf[MAX_VAR_SIZE];\n\n \n#define VAR_BUFFER\t 32\n\n \nstatic volatile u8 forced_mask = 0xff;\n\n \nstatic void *fill_start, *target_start;\nstatic size_t fill_size, target_size;\n\nstatic bool stackinit_range_contains(char *haystack_start, size_t haystack_size,\n\t\t\t\t     char *needle_start, size_t needle_size)\n{\n\tif (needle_start >= haystack_start &&\n\t    needle_start + needle_size <= haystack_start + haystack_size)\n\t\treturn true;\n\treturn false;\n}\n\n \n#define WANT_SUCCESS\t\t\t\t0\n#define XFAIL\t\t\t\t\t1\n\n#define DO_NOTHING_TYPE_SCALAR(var_type)\tvar_type\n#define DO_NOTHING_TYPE_STRING(var_type)\tvoid\n#define DO_NOTHING_TYPE_STRUCT(var_type)\tvoid\n\n#define DO_NOTHING_RETURN_SCALAR(ptr)\t\t*(ptr)\n#define DO_NOTHING_RETURN_STRING(ptr)\t\t \n#define DO_NOTHING_RETURN_STRUCT(ptr)\t\t \n\n#define DO_NOTHING_CALL_SCALAR(var, name)\t\t\t\\\n\t\t(var) = do_nothing_ ## name(&(var))\n#define DO_NOTHING_CALL_STRING(var, name)\t\t\t\\\n\t\tdo_nothing_ ## name(var)\n#define DO_NOTHING_CALL_STRUCT(var, name)\t\t\t\\\n\t\tdo_nothing_ ## name(&(var))\n\n#define FETCH_ARG_SCALAR(var)\t\t&var\n#define FETCH_ARG_STRING(var)\t\tvar\n#define FETCH_ARG_STRUCT(var)\t\t&var\n\n#define FILL_SIZE_STRING\t\t16\n\n#define INIT_CLONE_SCALAR\t\t \n#define INIT_CLONE_STRING\t\t[FILL_SIZE_STRING]\n#define INIT_CLONE_STRUCT\t\t \n\n#define ZERO_CLONE_SCALAR(zero)\t\tmemset(&(zero), 0x00, sizeof(zero))\n#define ZERO_CLONE_STRING(zero)\t\tmemset(&(zero), 0x00, sizeof(zero))\n \n#define ZERO_CLONE_STRUCT(zero)\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\\\n\t\tmemset(&(zero), 0xFF, sizeof(zero));\t\\\n\t\tzero.one = 0;\t\t\t\t\\\n\t\tzero.two = 0;\t\t\t\t\\\n\t\tzero.three = 0;\t\t\t\t\\\n\t\tzero.four = 0;\t\t\t\t\\\n\t} while (0)\n\n#define INIT_SCALAR_none(var_type)\t \n#define INIT_SCALAR_zero(var_type)\t= 0\n\n#define INIT_STRING_none(var_type)\t[FILL_SIZE_STRING]  \n#define INIT_STRING_zero(var_type)\t[FILL_SIZE_STRING] = { }\n\n#define INIT_STRUCT_none(var_type)\t \n#define INIT_STRUCT_zero(var_type)\t= { }\n\n\n#define __static_partial\t\t{ .two = 0, }\n#define __static_all\t\t\t{ .one = 0,\t\t\t\\\n\t\t\t\t\t  .two = 0,\t\t\t\\\n\t\t\t\t\t  .three = 0,\t\t\t\\\n\t\t\t\t\t  .four = 0,\t\t\t\\\n\t\t\t\t\t}\n#define __dynamic_partial\t\t{ .two = arg->two, }\n#define __dynamic_all\t\t\t{ .one = arg->one,\t\t\\\n\t\t\t\t\t  .two = arg->two,\t\t\\\n\t\t\t\t\t  .three = arg->three,\t\t\\\n\t\t\t\t\t  .four = arg->four,\t\t\\\n\t\t\t\t\t}\n#define __runtime_partial\t\tvar.two = 0\n#define __runtime_all\t\t\tvar.one = 0;\t\t\t\\\n\t\t\t\t\tvar.two = 0;\t\t\t\\\n\t\t\t\t\tvar.three = 0;\t\t\t\\\n\t\t\t\t\tvar.four = 0\n\n#define INIT_STRUCT_static_partial(var_type)\t\t\t\t\\\n\t\t\t\t\t= __static_partial\n#define INIT_STRUCT_static_all(var_type)\t\t\t\t\\\n\t\t\t\t\t= __static_all\n#define INIT_STRUCT_dynamic_partial(var_type)\t\t\t\t\\\n\t\t\t\t\t= __dynamic_partial\n#define INIT_STRUCT_dynamic_all(var_type)\t\t\t\t\\\n\t\t\t\t\t= __dynamic_all\n#define INIT_STRUCT_runtime_partial(var_type)\t\t\t\t\\\n\t\t\t\t\t; __runtime_partial\n#define INIT_STRUCT_runtime_all(var_type)\t\t\t\t\\\n\t\t\t\t\t; __runtime_all\n\n#define INIT_STRUCT_assigned_static_partial(var_type)\t\t\t\\\n\t\t\t\t\t; var = (var_type)__static_partial\n#define INIT_STRUCT_assigned_static_all(var_type)\t\t\t\\\n\t\t\t\t\t; var = (var_type)__static_all\n#define INIT_STRUCT_assigned_dynamic_partial(var_type)\t\t\t\\\n\t\t\t\t\t; var = (var_type)__dynamic_partial\n#define INIT_STRUCT_assigned_dynamic_all(var_type)\t\t\t\\\n\t\t\t\t\t; var = (var_type)__dynamic_all\n\n#define INIT_STRUCT_assigned_copy(var_type)\t\t\t\t\\\n\t\t\t\t\t; var = *(arg)\n\n \n#define DEFINE_TEST_DRIVER(name, var_type, which, xfail)\t\\\n \t\t\t\\\nstatic noinline void test_ ## name (struct kunit *test)\t\t\\\n{\t\t\t\t\t\t\t\t\\\n\tvar_type zero INIT_CLONE_ ## which;\t\t\t\\\n\tint ignored;\t\t\t\t\t\t\\\n\tu8 sum = 0, i;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\\\n\t \t\\\n\tBUILD_BUG_ON(sizeof(zero) > MAX_VAR_SIZE);\t\t\\\n\t\t\t\t\t\t\t\t\\\n\t \t\\\n\tZERO_CLONE_ ## which(zero);\t\t\t\t\\\n\t \t\\\n\tmemset(check_buf, 0x00, sizeof(check_buf));\t\t\\\n\t \t\t\t\t\\\n\tignored = leaf_ ##name((unsigned long)&ignored, 1,\t\\\n\t\t\t\tFETCH_ARG_ ## which(zero));\t\\\n\t \t\t\\\n\tfor (sum = 0, i = 0; i < target_size; i++)\t\t\\\n\t\tsum += (check_buf[i] != 0xFF);\t\t\t\\\n\tKUNIT_ASSERT_EQ_MSG(test, sum, 0,\t\t\t\\\n\t\t\t    \"leaf fill was not 0xFF!?\\n\");\t\\\n\t \t\\\n\tmemset(check_buf, 0x00, sizeof(check_buf));\t\t\\\n\t \t\t\\\n\tignored = leaf_ ##name((unsigned long)&ignored, 0,\t\\\n\t\t\t\tFETCH_ARG_ ## which(zero));\t\\\n\t\t\t\t\t\t\t\t\\\n\t \t\\\n\tKUNIT_ASSERT_TRUE_MSG(test,\t\t\t\t\\\n\t\tstackinit_range_contains(fill_start, fill_size,\t\\\n\t\t\t    target_start, target_size),\t\t\\\n\t\t\"stack fill missed target!? \"\t\t\t\\\n\t\t\"(fill %zu wide, target offset by %d)\\n\",\t\\\n\t\tfill_size,\t\t\t\t\t\\\n\t\t(int)((ssize_t)(uintptr_t)fill_start -\t\t\\\n\t\t      (ssize_t)(uintptr_t)target_start));\t\\\n\t\t\t\t\t\t\t\t\\\n\t \t\\\n\tfor (sum = 0, i = 0; i < target_size; i++)\t\t\\\n\t\tsum += (check_buf[i] == 0xFF);\t\t\t\\\n\t\t\t\t\t\t\t\t\\\n\tif (sum != 0 && xfail)\t\t\t\t\t\\\n\t\tkunit_skip(test,\t\t\t\t\\\n\t\t\t   \"XFAIL uninit bytes: %d\\n\",\t\t\\\n\t\t\t   sum);\t\t\t\t\\\n\tKUNIT_ASSERT_EQ_MSG(test, sum, 0,\t\t\t\\\n\t\t\"uninit bytes: %d\\n\", sum);\t\t\t\\\n}\n#define DEFINE_TEST(name, var_type, which, init_level, xfail)\t\\\n \\\nstatic noinline DO_NOTHING_TYPE_ ## which(var_type)\t\t\\\ndo_nothing_ ## name(var_type *ptr)\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\\\n\t \t\\\n\tif ((unsigned long)ptr > 0x2)\t\t\t\t\\\n\t\treturn DO_NOTHING_RETURN_ ## which(ptr);\t\\\n\telse\t\t\t\t\t\t\t\\\n\t\treturn DO_NOTHING_RETURN_ ## which(ptr + 1);\t\\\n}\t\t\t\t\t\t\t\t\\\nstatic noinline int leaf_ ## name(unsigned long sp, bool fill,\t\\\n\t\t\t\t  var_type *arg)\t\t\\\n{\t\t\t\t\t\t\t\t\\\n\tchar buf[VAR_BUFFER];\t\t\t\t\t\\\n\tvar_type var\t\t\t\t\t\t\\\n\t\tINIT_ ## which ## _ ## init_level(var_type);\t\\\n\t\t\t\t\t\t\t\t\\\n\ttarget_start = &var;\t\t\t\t\t\\\n\ttarget_size = sizeof(var);\t\t\t\t\\\n\t \t\t\t\t\t\t\t\\\n\tmemset(buf, (char)(sp & 0xff), sizeof(buf));\t\t\\\n\t \t\t\t\t\\\n\tif (fill) {\t\t\t\t\t\t\\\n\t\tfill_start = &var;\t\t\t\t\\\n\t\tfill_size = sizeof(var);\t\t\t\\\n\t\tmemset(fill_start,\t\t\t\t\\\n\t\t       (char)((sp & 0xff) | forced_mask),\t\\\n\t\t       fill_size);\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\\\n\t \t\t\\\n\tDO_NOTHING_CALL_ ## which(var, name);\t\t\t\\\n\t\t\t\t\t\t\t\t\\\n\t \t\t\t\t\t\\\n\tmemcpy(check_buf, target_start, target_size);\t\t\\\n\t\t\t\t\t\t\t\t\\\n\treturn (int)buf[0] | (int)buf[sizeof(buf) - 1];\t\t\\\n}\t\t\t\t\t\t\t\t\\\nDEFINE_TEST_DRIVER(name, var_type, which, xfail)\n\n \nstruct test_packed {\n\tunsigned long one;\n\tunsigned long two;\n\tunsigned long three;\n\tunsigned long four;\n};\n\n \nstruct test_small_hole {\n\tsize_t one;\n\tchar two;\n\t \n\tint three;\n\tunsigned long four;\n};\n\n \nstruct test_big_hole {\n\tu8 one;\n\tu8 two;\n\tu8 three;\n\t \n\tu8 four __aligned(64);\n} __aligned(64);\n\nstruct test_trailing_hole {\n\tchar *one;\n\tchar *two;\n\tchar *three;\n\tchar four;\n\t \n};\n\n \nstruct test_user {\n\tu8 one;\n\tunsigned long two;\n\tchar __user *three;\n\tunsigned long four;\n};\n\n#define ALWAYS_PASS\tWANT_SUCCESS\n#define ALWAYS_FAIL\tXFAIL\n\n#ifdef CONFIG_INIT_STACK_NONE\n# define USER_PASS\tXFAIL\n# define BYREF_PASS\tXFAIL\n# define STRONG_PASS\tXFAIL\n#elif defined(CONFIG_GCC_PLUGIN_STRUCTLEAK_USER)\n# define USER_PASS\tWANT_SUCCESS\n# define BYREF_PASS\tXFAIL\n# define STRONG_PASS\tXFAIL\n#elif defined(CONFIG_GCC_PLUGIN_STRUCTLEAK_BYREF)\n# define USER_PASS\tWANT_SUCCESS\n# define BYREF_PASS\tWANT_SUCCESS\n# define STRONG_PASS\tXFAIL\n#else\n# define USER_PASS\tWANT_SUCCESS\n# define BYREF_PASS\tWANT_SUCCESS\n# define STRONG_PASS\tWANT_SUCCESS\n#endif\n\n#define DEFINE_SCALAR_TEST(name, init, xfail)\t\t\t\\\n\t\tDEFINE_TEST(name ## _ ## init, name, SCALAR,\t\\\n\t\t\t    init, xfail)\n\n#define DEFINE_SCALAR_TESTS(init, xfail)\t\t\t\\\n\t\tDEFINE_SCALAR_TEST(u8, init, xfail);\t\t\\\n\t\tDEFINE_SCALAR_TEST(u16, init, xfail);\t\t\\\n\t\tDEFINE_SCALAR_TEST(u32, init, xfail);\t\t\\\n\t\tDEFINE_SCALAR_TEST(u64, init, xfail);\t\t\\\n\t\tDEFINE_TEST(char_array_ ## init, unsigned char,\t\\\n\t\t\t    STRING, init, xfail)\n\n#define DEFINE_STRUCT_TEST(name, init, xfail)\t\t\t\\\n\t\tDEFINE_TEST(name ## _ ## init,\t\t\t\\\n\t\t\t    struct test_ ## name, STRUCT, init, \\\n\t\t\t    xfail)\n\n#define DEFINE_STRUCT_TESTS(init, xfail)\t\t\t\\\n\t\tDEFINE_STRUCT_TEST(small_hole, init, xfail);\t\\\n\t\tDEFINE_STRUCT_TEST(big_hole, init, xfail);\t\\\n\t\tDEFINE_STRUCT_TEST(trailing_hole, init, xfail);\t\\\n\t\tDEFINE_STRUCT_TEST(packed, init, xfail)\n\n#define DEFINE_STRUCT_INITIALIZER_TESTS(base, xfail)\t\t\\\n\t\tDEFINE_STRUCT_TESTS(base ## _ ## partial,\t\\\n\t\t\t\t    xfail);\t\t\t\\\n\t\tDEFINE_STRUCT_TESTS(base ## _ ## all, xfail)\n\n \nDEFINE_SCALAR_TESTS(zero, ALWAYS_PASS);\nDEFINE_STRUCT_TESTS(zero, ALWAYS_PASS);\n \nDEFINE_STRUCT_INITIALIZER_TESTS(static, STRONG_PASS);\nDEFINE_STRUCT_INITIALIZER_TESTS(dynamic, STRONG_PASS);\nDEFINE_STRUCT_INITIALIZER_TESTS(runtime, STRONG_PASS);\nDEFINE_STRUCT_INITIALIZER_TESTS(assigned_static, STRONG_PASS);\nDEFINE_STRUCT_INITIALIZER_TESTS(assigned_dynamic, STRONG_PASS);\nDEFINE_STRUCT_TESTS(assigned_copy, ALWAYS_FAIL);\n \nDEFINE_SCALAR_TESTS(none, STRONG_PASS);\nDEFINE_STRUCT_TESTS(none, BYREF_PASS);\n \nDEFINE_TEST(user, struct test_user, STRUCT, none, USER_PASS);\n\n \nstatic int noinline __leaf_switch_none(int path, bool fill)\n{\n\tswitch (path) {\n\t\t \n\t\tuint64_t var[10];\n\n\tcase 1:\n\t\ttarget_start = &var;\n\t\ttarget_size = sizeof(var);\n\t\tif (fill) {\n\t\t\tfill_start = &var;\n\t\t\tfill_size = sizeof(var);\n\n\t\t\tmemset(fill_start, forced_mask | 0x55, fill_size);\n\t\t}\n\t\tmemcpy(check_buf, target_start, target_size);\n\t\tbreak;\n\tcase 2:\n\t\ttarget_start = &var;\n\t\ttarget_size = sizeof(var);\n\t\tif (fill) {\n\t\t\tfill_start = &var;\n\t\t\tfill_size = sizeof(var);\n\n\t\t\tmemset(fill_start, forced_mask | 0xaa, fill_size);\n\t\t}\n\t\tmemcpy(check_buf, target_start, target_size);\n\t\tbreak;\n\tdefault:\n\t\tvar[1] = 5;\n\t\treturn var[1] & forced_mask;\n\t}\n\treturn 0;\n}\n\nstatic noinline int leaf_switch_1_none(unsigned long sp, bool fill,\n\t\t\t\t\t      uint64_t *arg)\n{\n\treturn __leaf_switch_none(1, fill);\n}\n\nstatic noinline int leaf_switch_2_none(unsigned long sp, bool fill,\n\t\t\t\t\t      uint64_t *arg)\n{\n\treturn __leaf_switch_none(2, fill);\n}\n\n \nDEFINE_TEST_DRIVER(switch_1_none, uint64_t, SCALAR, ALWAYS_FAIL);\nDEFINE_TEST_DRIVER(switch_2_none, uint64_t, SCALAR, ALWAYS_FAIL);\n\n#define KUNIT_test_scalars(init)\t\t\t\\\n\t\tKUNIT_CASE(test_u8_ ## init),\t\t\\\n\t\tKUNIT_CASE(test_u16_ ## init),\t\t\\\n\t\tKUNIT_CASE(test_u32_ ## init),\t\t\\\n\t\tKUNIT_CASE(test_u64_ ## init),\t\t\\\n\t\tKUNIT_CASE(test_char_array_ ## init)\n\n#define KUNIT_test_structs(init)\t\t\t\\\n\t\tKUNIT_CASE(test_small_hole_ ## init),\t\\\n\t\tKUNIT_CASE(test_big_hole_ ## init),\t\\\n\t\tKUNIT_CASE(test_trailing_hole_ ## init),\\\n\t\tKUNIT_CASE(test_packed_ ## init)\t\\\n\nstatic struct kunit_case stackinit_test_cases[] = {\n\t \n\tKUNIT_test_scalars(zero),\n\tKUNIT_test_structs(zero),\n\t \n\tKUNIT_test_structs(dynamic_partial),\n\tKUNIT_test_structs(assigned_dynamic_partial),\n\t \n\tKUNIT_test_structs(static_partial),\n\tKUNIT_test_structs(static_all),\n\tKUNIT_test_structs(dynamic_all),\n\tKUNIT_test_structs(runtime_partial),\n\tKUNIT_test_structs(runtime_all),\n\tKUNIT_test_structs(assigned_static_partial),\n\tKUNIT_test_structs(assigned_static_all),\n\tKUNIT_test_structs(assigned_dynamic_all),\n\t \n\tKUNIT_test_structs(assigned_copy),\n\t \n\tKUNIT_test_scalars(none),\n\tKUNIT_CASE(test_switch_1_none),\n\tKUNIT_CASE(test_switch_2_none),\n\t \n\tKUNIT_test_structs(none),\n\t \n\tKUNIT_CASE(test_user),\n\t{}\n};\n\nstatic struct kunit_suite stackinit_test_suite = {\n\t.name = \"stackinit\",\n\t.test_cases = stackinit_test_cases,\n};\n\nkunit_test_suites(&stackinit_test_suite);\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}