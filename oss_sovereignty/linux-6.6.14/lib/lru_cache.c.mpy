{
  "module_name": "lru_cache.c",
  "hash_id": "d8307eb44f47d2378999d52f8e0909840a6eae3a355c007b1fda2273735db15b",
  "original_prompt": "Ingested from linux-6.6.14/lib/lru_cache.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/string.h>  \n#include <linux/seq_file.h>  \n#include <linux/lru_cache.h>\n\nMODULE_AUTHOR(\"Philipp Reisner <phil@linbit.com>, \"\n\t      \"Lars Ellenberg <lars@linbit.com>\");\nMODULE_DESCRIPTION(\"lru_cache - Track sets of hot objects\");\nMODULE_LICENSE(\"GPL\");\n\n \n#define PARANOIA_ENTRY() do {\t\t\\\n\tBUG_ON(!lc);\t\t\t\\\n\tBUG_ON(!lc->nr_elements);\t\\\n\tBUG_ON(test_and_set_bit(__LC_PARANOIA, &lc->flags)); \\\n} while (0)\n\n#define RETURN(x...)     do { \\\n\tclear_bit_unlock(__LC_PARANOIA, &lc->flags); \\\n\treturn x ; } while (0)\n\n \n#define PARANOIA_LC_ELEMENT(lc, e) do {\t\\\n\tstruct lru_cache *lc_ = (lc);\t\\\n\tstruct lc_element *e_ = (e);\t\\\n\tunsigned i = e_->lc_index;\t\\\n\tBUG_ON(i >= lc_->nr_elements);\t\\\n\tBUG_ON(lc_->lc_element[i] != e_); } while (0)\n\n\n \nint lc_try_lock(struct lru_cache *lc)\n{\n\tunsigned long val;\n\tdo {\n\t\tval = cmpxchg(&lc->flags, 0, LC_LOCKED);\n\t} while (unlikely (val == LC_PARANOIA));\n\t \n\treturn 0 == val;\n}\n\n \nstruct lru_cache *lc_create(const char *name, struct kmem_cache *cache,\n\t\tunsigned max_pending_changes,\n\t\tunsigned e_count, size_t e_size, size_t e_off)\n{\n\tstruct hlist_head *slot = NULL;\n\tstruct lc_element **element = NULL;\n\tstruct lru_cache *lc;\n\tstruct lc_element *e;\n\tunsigned cache_obj_size = kmem_cache_size(cache);\n\tunsigned i;\n\n\tWARN_ON(cache_obj_size < e_size);\n\tif (cache_obj_size < e_size)\n\t\treturn NULL;\n\n\t \n\tif (e_count > LC_MAX_ACTIVE)\n\t\treturn NULL;\n\n\tslot = kcalloc(e_count, sizeof(struct hlist_head), GFP_KERNEL);\n\tif (!slot)\n\t\tgoto out_fail;\n\telement = kcalloc(e_count, sizeof(struct lc_element *), GFP_KERNEL);\n\tif (!element)\n\t\tgoto out_fail;\n\n\tlc = kzalloc(sizeof(*lc), GFP_KERNEL);\n\tif (!lc)\n\t\tgoto out_fail;\n\n\tINIT_LIST_HEAD(&lc->in_use);\n\tINIT_LIST_HEAD(&lc->lru);\n\tINIT_LIST_HEAD(&lc->free);\n\tINIT_LIST_HEAD(&lc->to_be_changed);\n\n\tlc->name = name;\n\tlc->element_size = e_size;\n\tlc->element_off = e_off;\n\tlc->nr_elements = e_count;\n\tlc->max_pending_changes = max_pending_changes;\n\tlc->lc_cache = cache;\n\tlc->lc_element = element;\n\tlc->lc_slot = slot;\n\n\t \n\tfor (i = 0; i < e_count; i++) {\n\t\tvoid *p = kmem_cache_alloc(cache, GFP_KERNEL);\n\t\tif (!p)\n\t\t\tbreak;\n\t\tmemset(p, 0, lc->element_size);\n\t\te = p + e_off;\n\t\te->lc_index = i;\n\t\te->lc_number = LC_FREE;\n\t\te->lc_new_number = LC_FREE;\n\t\tlist_add(&e->list, &lc->free);\n\t\telement[i] = e;\n\t}\n\tif (i == e_count)\n\t\treturn lc;\n\n\t \n\twhile (i) {\n\t\tvoid *p = element[--i];\n\t\tkmem_cache_free(cache, p - e_off);\n\t}\n\tkfree(lc);\nout_fail:\n\tkfree(element);\n\tkfree(slot);\n\treturn NULL;\n}\n\nstatic void lc_free_by_index(struct lru_cache *lc, unsigned i)\n{\n\tvoid *p = lc->lc_element[i];\n\tWARN_ON(!p);\n\tif (p) {\n\t\tp -= lc->element_off;\n\t\tkmem_cache_free(lc->lc_cache, p);\n\t}\n}\n\n \nvoid lc_destroy(struct lru_cache *lc)\n{\n\tunsigned i;\n\tif (!lc)\n\t\treturn;\n\tfor (i = 0; i < lc->nr_elements; i++)\n\t\tlc_free_by_index(lc, i);\n\tkfree(lc->lc_element);\n\tkfree(lc->lc_slot);\n\tkfree(lc);\n}\n\n \nvoid lc_reset(struct lru_cache *lc)\n{\n\tunsigned i;\n\n\tINIT_LIST_HEAD(&lc->in_use);\n\tINIT_LIST_HEAD(&lc->lru);\n\tINIT_LIST_HEAD(&lc->free);\n\tINIT_LIST_HEAD(&lc->to_be_changed);\n\tlc->used = 0;\n\tlc->hits = 0;\n\tlc->misses = 0;\n\tlc->starving = 0;\n\tlc->locked = 0;\n\tlc->changed = 0;\n\tlc->pending_changes = 0;\n\tlc->flags = 0;\n\tmemset(lc->lc_slot, 0, sizeof(struct hlist_head) * lc->nr_elements);\n\n\tfor (i = 0; i < lc->nr_elements; i++) {\n\t\tstruct lc_element *e = lc->lc_element[i];\n\t\tvoid *p = e;\n\t\tp -= lc->element_off;\n\t\tmemset(p, 0, lc->element_size);\n\t\t \n\t\te->lc_index = i;\n\t\te->lc_number = LC_FREE;\n\t\te->lc_new_number = LC_FREE;\n\t\tlist_add(&e->list, &lc->free);\n\t}\n}\n\n \nvoid lc_seq_printf_stats(struct seq_file *seq, struct lru_cache *lc)\n{\n\t \n\tseq_printf(seq, \"\\t%s: used:%u/%u hits:%lu misses:%lu starving:%lu locked:%lu changed:%lu\\n\",\n\t\t   lc->name, lc->used, lc->nr_elements,\n\t\t   lc->hits, lc->misses, lc->starving, lc->locked, lc->changed);\n}\n\nstatic struct hlist_head *lc_hash_slot(struct lru_cache *lc, unsigned int enr)\n{\n\treturn  lc->lc_slot + (enr % lc->nr_elements);\n}\n\n\nstatic struct lc_element *__lc_find(struct lru_cache *lc, unsigned int enr,\n\t\tbool include_changing)\n{\n\tstruct lc_element *e;\n\n\tBUG_ON(!lc);\n\tBUG_ON(!lc->nr_elements);\n\thlist_for_each_entry(e, lc_hash_slot(lc, enr), colision) {\n\t\t \n\t\tif (e->lc_new_number != enr)\n\t\t\tcontinue;\n\t\tif (e->lc_new_number == e->lc_number || include_changing)\n\t\t\treturn e;\n\t\tbreak;\n\t}\n\treturn NULL;\n}\n\n \nstruct lc_element *lc_find(struct lru_cache *lc, unsigned int enr)\n{\n\treturn __lc_find(lc, enr, 0);\n}\n\n \nbool lc_is_used(struct lru_cache *lc, unsigned int enr)\n{\n\tstruct lc_element *e = __lc_find(lc, enr, 1);\n\treturn e && e->refcnt;\n}\n\n \nvoid lc_del(struct lru_cache *lc, struct lc_element *e)\n{\n\tPARANOIA_ENTRY();\n\tPARANOIA_LC_ELEMENT(lc, e);\n\tBUG_ON(e->refcnt);\n\n\te->lc_number = e->lc_new_number = LC_FREE;\n\thlist_del_init(&e->colision);\n\tlist_move(&e->list, &lc->free);\n\tRETURN();\n}\n\nstatic struct lc_element *lc_prepare_for_change(struct lru_cache *lc, unsigned new_number)\n{\n\tstruct list_head *n;\n\tstruct lc_element *e;\n\n\tif (!list_empty(&lc->free))\n\t\tn = lc->free.next;\n\telse if (!list_empty(&lc->lru))\n\t\tn = lc->lru.prev;\n\telse\n\t\treturn NULL;\n\n\te = list_entry(n, struct lc_element, list);\n\tPARANOIA_LC_ELEMENT(lc, e);\n\n\te->lc_new_number = new_number;\n\tif (!hlist_unhashed(&e->colision))\n\t\t__hlist_del(&e->colision);\n\thlist_add_head(&e->colision, lc_hash_slot(lc, new_number));\n\tlist_move(&e->list, &lc->to_be_changed);\n\n\treturn e;\n}\n\nstatic int lc_unused_element_available(struct lru_cache *lc)\n{\n\tif (!list_empty(&lc->free))\n\t\treturn 1;  \n\tif (!list_empty(&lc->lru))\n\t\treturn 1;   \n\n\treturn 0;\n}\n\n \nenum {\n\tLC_GET_MAY_CHANGE = 1,\n\tLC_GET_MAY_USE_UNCOMMITTED = 2,\n};\n\nstatic struct lc_element *__lc_get(struct lru_cache *lc, unsigned int enr, unsigned int flags)\n{\n\tstruct lc_element *e;\n\n\tPARANOIA_ENTRY();\n\tif (test_bit(__LC_STARVING, &lc->flags)) {\n\t\t++lc->starving;\n\t\tRETURN(NULL);\n\t}\n\n\te = __lc_find(lc, enr, 1);\n\t \n\tif (e) {\n\t\tif (e->lc_new_number != e->lc_number) {\n\t\t\t \n\t\t\tif (!(flags & LC_GET_MAY_USE_UNCOMMITTED))\n\t\t\t\tRETURN(NULL);\n\t\t\t \n\t\t\t++e->refcnt;\n\t\t\t++lc->hits;\n\t\t\tRETURN(e);\n\t\t}\n\t\t \n\t\t++lc->hits;\n\t\tif (e->refcnt++ == 0)\n\t\t\tlc->used++;\n\t\tlist_move(&e->list, &lc->in_use);  \n\t\tRETURN(e);\n\t}\n\t \n\n\t++lc->misses;\n\tif (!(flags & LC_GET_MAY_CHANGE))\n\t\tRETURN(NULL);\n\n\t \n\ttest_and_set_bit(__LC_DIRTY, &lc->flags);\n\n\t \n\tif (test_bit(__LC_LOCKED, &lc->flags)) {\n\t\t++lc->locked;\n\t\tRETURN(NULL);\n\t}\n\n\t \n\tif (!lc_unused_element_available(lc)) {\n\t\tset_bit(__LC_STARVING, &lc->flags);\n\t\tRETURN(NULL);\n\t}\n\n\t \n\tif (lc->pending_changes >= lc->max_pending_changes)\n\t\tRETURN(NULL);\n\n\te = lc_prepare_for_change(lc, enr);\n\tBUG_ON(!e);\n\n\tclear_bit(__LC_STARVING, &lc->flags);\n\tBUG_ON(++e->refcnt != 1);\n\tlc->used++;\n\tlc->pending_changes++;\n\n\tRETURN(e);\n}\n\n \nstruct lc_element *lc_get(struct lru_cache *lc, unsigned int enr)\n{\n\treturn __lc_get(lc, enr, LC_GET_MAY_CHANGE);\n}\n\n \nstruct lc_element *lc_get_cumulative(struct lru_cache *lc, unsigned int enr)\n{\n\treturn __lc_get(lc, enr, LC_GET_MAY_CHANGE|LC_GET_MAY_USE_UNCOMMITTED);\n}\n\n \nstruct lc_element *lc_try_get(struct lru_cache *lc, unsigned int enr)\n{\n\treturn __lc_get(lc, enr, 0);\n}\n\n \nvoid lc_committed(struct lru_cache *lc)\n{\n\tstruct lc_element *e, *tmp;\n\n\tPARANOIA_ENTRY();\n\tlist_for_each_entry_safe(e, tmp, &lc->to_be_changed, list) {\n\t\t \n\t\t++lc->changed;\n\t\te->lc_number = e->lc_new_number;\n\t\tlist_move(&e->list, &lc->in_use);\n\t}\n\tlc->pending_changes = 0;\n\tRETURN();\n}\n\n\n \nunsigned int lc_put(struct lru_cache *lc, struct lc_element *e)\n{\n\tPARANOIA_ENTRY();\n\tPARANOIA_LC_ELEMENT(lc, e);\n\tBUG_ON(e->refcnt == 0);\n\tBUG_ON(e->lc_number != e->lc_new_number);\n\tif (--e->refcnt == 0) {\n\t\t \n\t\tlist_move(&e->list, &lc->lru);\n\t\tlc->used--;\n\t\tclear_bit_unlock(__LC_STARVING, &lc->flags);\n\t}\n\tRETURN(e->refcnt);\n}\n\n \nstruct lc_element *lc_element_by_index(struct lru_cache *lc, unsigned i)\n{\n\tBUG_ON(i >= lc->nr_elements);\n\tBUG_ON(lc->lc_element[i] == NULL);\n\tBUG_ON(lc->lc_element[i]->lc_index != i);\n\treturn lc->lc_element[i];\n}\n\n \nvoid lc_seq_dump_details(struct seq_file *seq, struct lru_cache *lc, char *utext,\n\t     void (*detail) (struct seq_file *, struct lc_element *))\n{\n\tunsigned int nr_elements = lc->nr_elements;\n\tstruct lc_element *e;\n\tint i;\n\n\tseq_printf(seq, \"\\tnn: lc_number (new nr) refcnt %s\\n \", utext);\n\tfor (i = 0; i < nr_elements; i++) {\n\t\te = lc_element_by_index(lc, i);\n\t\tif (e->lc_number != e->lc_new_number)\n\t\t\tseq_printf(seq, \"\\t%5d: %6d %8d %6d \",\n\t\t\t\ti, e->lc_number, e->lc_new_number, e->refcnt);\n\t\telse\n\t\t\tseq_printf(seq, \"\\t%5d: %6d %-8s %6d \",\n\t\t\t\ti, e->lc_number, \"-\\\"-\", e->refcnt);\n\t\tif (detail)\n\t\t\tdetail(seq, e);\n\t\tseq_putc(seq, '\\n');\n\t}\n}\n\nEXPORT_SYMBOL(lc_create);\nEXPORT_SYMBOL(lc_reset);\nEXPORT_SYMBOL(lc_destroy);\nEXPORT_SYMBOL(lc_del);\nEXPORT_SYMBOL(lc_try_get);\nEXPORT_SYMBOL(lc_find);\nEXPORT_SYMBOL(lc_get);\nEXPORT_SYMBOL(lc_put);\nEXPORT_SYMBOL(lc_committed);\nEXPORT_SYMBOL(lc_element_by_index);\nEXPORT_SYMBOL(lc_seq_printf_stats);\nEXPORT_SYMBOL(lc_seq_dump_details);\nEXPORT_SYMBOL(lc_try_lock);\nEXPORT_SYMBOL(lc_is_used);\nEXPORT_SYMBOL(lc_get_cumulative);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}