{
  "module_name": "locking-selftest.c",
  "hash_id": "5ce7cb43f9056b5153e296e73d30ceade4b18b9074142025093ccc9cd031d2a3",
  "original_prompt": "Ingested from linux-6.6.14/lib/locking-selftest.c",
  "human_readable_source": "\n \n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/ww_mutex.h>\n#include <linux/sched.h>\n#include <linux/sched/mm.h>\n#include <linux/delay.h>\n#include <linux/lockdep.h>\n#include <linux/spinlock.h>\n#include <linux/kallsyms.h>\n#include <linux/interrupt.h>\n#include <linux/debug_locks.h>\n#include <linux/irqflags.h>\n#include <linux/rtmutex.h>\n#include <linux/local_lock.h>\n\n#ifdef CONFIG_PREEMPT_RT\n# define NON_RT(...)\n#else\n# define NON_RT(...)\t__VA_ARGS__\n#endif\n\n \nstatic unsigned int debug_locks_verbose;\nunsigned int force_read_lock_recursive;\n\nstatic DEFINE_WD_CLASS(ww_lockdep);\n\nstatic int __init setup_debug_locks_verbose(char *str)\n{\n\tget_option(&str, &debug_locks_verbose);\n\n\treturn 1;\n}\n\n__setup(\"debug_locks_verbose=\", setup_debug_locks_verbose);\n\n#define FAILURE\t\t0\n#define SUCCESS\t\t1\n\n#define LOCKTYPE_SPIN\t0x1\n#define LOCKTYPE_RWLOCK\t0x2\n#define LOCKTYPE_MUTEX\t0x4\n#define LOCKTYPE_RWSEM\t0x8\n#define LOCKTYPE_WW\t0x10\n#define LOCKTYPE_RTMUTEX 0x20\n#define LOCKTYPE_LL\t0x40\n#define LOCKTYPE_SPECIAL 0x80\n\nstatic struct ww_acquire_ctx t, t2;\nstatic struct ww_mutex o, o2, o3;\n\n \nstatic DEFINE_SPINLOCK(lock_A);\nstatic DEFINE_SPINLOCK(lock_B);\nstatic DEFINE_SPINLOCK(lock_C);\nstatic DEFINE_SPINLOCK(lock_D);\n\nstatic DEFINE_RAW_SPINLOCK(raw_lock_A);\nstatic DEFINE_RAW_SPINLOCK(raw_lock_B);\n\nstatic DEFINE_RWLOCK(rwlock_A);\nstatic DEFINE_RWLOCK(rwlock_B);\nstatic DEFINE_RWLOCK(rwlock_C);\nstatic DEFINE_RWLOCK(rwlock_D);\n\nstatic DEFINE_MUTEX(mutex_A);\nstatic DEFINE_MUTEX(mutex_B);\nstatic DEFINE_MUTEX(mutex_C);\nstatic DEFINE_MUTEX(mutex_D);\n\nstatic DECLARE_RWSEM(rwsem_A);\nstatic DECLARE_RWSEM(rwsem_B);\nstatic DECLARE_RWSEM(rwsem_C);\nstatic DECLARE_RWSEM(rwsem_D);\n\n#ifdef CONFIG_RT_MUTEXES\n\nstatic DEFINE_RT_MUTEX(rtmutex_A);\nstatic DEFINE_RT_MUTEX(rtmutex_B);\nstatic DEFINE_RT_MUTEX(rtmutex_C);\nstatic DEFINE_RT_MUTEX(rtmutex_D);\n\n#endif\n\n \nstatic DEFINE_SPINLOCK(lock_X1);\nstatic DEFINE_SPINLOCK(lock_X2);\nstatic DEFINE_SPINLOCK(lock_Y1);\nstatic DEFINE_SPINLOCK(lock_Y2);\nstatic DEFINE_SPINLOCK(lock_Z1);\nstatic DEFINE_SPINLOCK(lock_Z2);\n\nstatic DEFINE_RWLOCK(rwlock_X1);\nstatic DEFINE_RWLOCK(rwlock_X2);\nstatic DEFINE_RWLOCK(rwlock_Y1);\nstatic DEFINE_RWLOCK(rwlock_Y2);\nstatic DEFINE_RWLOCK(rwlock_Z1);\nstatic DEFINE_RWLOCK(rwlock_Z2);\n\nstatic DEFINE_MUTEX(mutex_X1);\nstatic DEFINE_MUTEX(mutex_X2);\nstatic DEFINE_MUTEX(mutex_Y1);\nstatic DEFINE_MUTEX(mutex_Y2);\nstatic DEFINE_MUTEX(mutex_Z1);\nstatic DEFINE_MUTEX(mutex_Z2);\n\nstatic DECLARE_RWSEM(rwsem_X1);\nstatic DECLARE_RWSEM(rwsem_X2);\nstatic DECLARE_RWSEM(rwsem_Y1);\nstatic DECLARE_RWSEM(rwsem_Y2);\nstatic DECLARE_RWSEM(rwsem_Z1);\nstatic DECLARE_RWSEM(rwsem_Z2);\n\n#ifdef CONFIG_RT_MUTEXES\n\nstatic DEFINE_RT_MUTEX(rtmutex_X1);\nstatic DEFINE_RT_MUTEX(rtmutex_X2);\nstatic DEFINE_RT_MUTEX(rtmutex_Y1);\nstatic DEFINE_RT_MUTEX(rtmutex_Y2);\nstatic DEFINE_RT_MUTEX(rtmutex_Z1);\nstatic DEFINE_RT_MUTEX(rtmutex_Z2);\n\n#endif\n\nstatic DEFINE_PER_CPU(local_lock_t, local_A);\n\n \n#define INIT_CLASS_FUNC(class) \t\t\t\t\\\nstatic noinline void\t\t\t\t\t\\\ninit_class_##class(spinlock_t *lock, rwlock_t *rwlock, \\\n\tstruct mutex *mutex, struct rw_semaphore *rwsem)\\\n{\t\t\t\t\t\t\t\\\n\tspin_lock_init(lock);\t\t\t\\\n\trwlock_init(rwlock);\t\t\t\t\\\n\tmutex_init(mutex);\t\t\t\t\\\n\tinit_rwsem(rwsem);\t\t\t\t\\\n}\n\nINIT_CLASS_FUNC(X)\nINIT_CLASS_FUNC(Y)\nINIT_CLASS_FUNC(Z)\n\nstatic void init_shared_classes(void)\n{\n#ifdef CONFIG_RT_MUTEXES\n\tstatic struct lock_class_key rt_X, rt_Y, rt_Z;\n\n\t__rt_mutex_init(&rtmutex_X1, __func__, &rt_X);\n\t__rt_mutex_init(&rtmutex_X2, __func__, &rt_X);\n\t__rt_mutex_init(&rtmutex_Y1, __func__, &rt_Y);\n\t__rt_mutex_init(&rtmutex_Y2, __func__, &rt_Y);\n\t__rt_mutex_init(&rtmutex_Z1, __func__, &rt_Z);\n\t__rt_mutex_init(&rtmutex_Z2, __func__, &rt_Z);\n#endif\n\n\tinit_class_X(&lock_X1, &rwlock_X1, &mutex_X1, &rwsem_X1);\n\tinit_class_X(&lock_X2, &rwlock_X2, &mutex_X2, &rwsem_X2);\n\n\tinit_class_Y(&lock_Y1, &rwlock_Y1, &mutex_Y1, &rwsem_Y1);\n\tinit_class_Y(&lock_Y2, &rwlock_Y2, &mutex_Y2, &rwsem_Y2);\n\n\tinit_class_Z(&lock_Z1, &rwlock_Z1, &mutex_Z1, &rwsem_Z1);\n\tinit_class_Z(&lock_Z2, &rwlock_Z2, &mutex_Z2, &rwsem_Z2);\n}\n\n \n\n#define HARDIRQ_DISABLE\t\tlocal_irq_disable\n#define HARDIRQ_ENABLE\t\tlocal_irq_enable\n\n#define HARDIRQ_ENTER()\t\t\t\t\\\n\tlocal_irq_disable();\t\t\t\\\n\t__irq_enter();\t\t\t\t\\\n\tlockdep_hardirq_threaded();\t\t\\\n\tWARN_ON(!in_irq());\n\n#define HARDIRQ_EXIT()\t\t\t\t\\\n\t__irq_exit();\t\t\t\t\\\n\tlocal_irq_enable();\n\n#define SOFTIRQ_DISABLE\t\tlocal_bh_disable\n#define SOFTIRQ_ENABLE\t\tlocal_bh_enable\n\n#define SOFTIRQ_ENTER()\t\t\t\t\\\n\t\tlocal_bh_disable();\t\t\\\n\t\tlocal_irq_disable();\t\t\\\n\t\tlockdep_softirq_enter();\t\\\n\t\tWARN_ON(!in_softirq());\n\n#define SOFTIRQ_EXIT()\t\t\t\t\\\n\t\tlockdep_softirq_exit();\t\t\\\n\t\tlocal_irq_enable();\t\t\\\n\t\tlocal_bh_enable();\n\n \n#define L(x)\t\t\tspin_lock(&lock_##x)\n#define U(x)\t\t\tspin_unlock(&lock_##x)\n#define LU(x)\t\t\tL(x); U(x)\n#define SI(x)\t\t\tspin_lock_init(&lock_##x)\n\n#define WL(x)\t\t\twrite_lock(&rwlock_##x)\n#define WU(x)\t\t\twrite_unlock(&rwlock_##x)\n#define WLU(x)\t\t\tWL(x); WU(x)\n\n#define RL(x)\t\t\tread_lock(&rwlock_##x)\n#define RU(x)\t\t\tread_unlock(&rwlock_##x)\n#define RLU(x)\t\t\tRL(x); RU(x)\n#define RWI(x)\t\t\trwlock_init(&rwlock_##x)\n\n#define ML(x)\t\t\tmutex_lock(&mutex_##x)\n#define MU(x)\t\t\tmutex_unlock(&mutex_##x)\n#define MI(x)\t\t\tmutex_init(&mutex_##x)\n\n#define RTL(x)\t\t\trt_mutex_lock(&rtmutex_##x)\n#define RTU(x)\t\t\trt_mutex_unlock(&rtmutex_##x)\n#define RTI(x)\t\t\trt_mutex_init(&rtmutex_##x)\n\n#define WSL(x)\t\t\tdown_write(&rwsem_##x)\n#define WSU(x)\t\t\tup_write(&rwsem_##x)\n\n#define RSL(x)\t\t\tdown_read(&rwsem_##x)\n#define RSU(x)\t\t\tup_read(&rwsem_##x)\n#define RWSI(x)\t\t\tinit_rwsem(&rwsem_##x)\n\n#ifndef CONFIG_DEBUG_WW_MUTEX_SLOWPATH\n#define WWAI(x)\t\t\tww_acquire_init(x, &ww_lockdep)\n#else\n#define WWAI(x)\t\t\tdo { ww_acquire_init(x, &ww_lockdep); (x)->deadlock_inject_countdown = ~0U; } while (0)\n#endif\n#define WWAD(x)\t\t\tww_acquire_done(x)\n#define WWAF(x)\t\t\tww_acquire_fini(x)\n\n#define WWL(x, c)\t\tww_mutex_lock(x, c)\n#define WWT(x)\t\t\tww_mutex_trylock(x, NULL)\n#define WWL1(x)\t\t\tww_mutex_lock(x, NULL)\n#define WWU(x)\t\t\tww_mutex_unlock(x)\n\n\n#define LOCK_UNLOCK_2(x,y)\tLOCK(x); LOCK(y); UNLOCK(y); UNLOCK(x)\n\n \n\n#define GENERATE_TESTCASE(name)\t\t\t\\\n\t\t\t\t\t\t\\\nstatic void name(void) { E(); }\n\n#define GENERATE_PERMUTATIONS_2_EVENTS(name)\t\\\n\t\t\t\t\t\t\\\nstatic void name##_12(void) { E1(); E2(); }\t\\\nstatic void name##_21(void) { E2(); E1(); }\n\n#define GENERATE_PERMUTATIONS_3_EVENTS(name)\t\t\\\n\t\t\t\t\t\t\t\\\nstatic void name##_123(void) { E1(); E2(); E3(); }\t\\\nstatic void name##_132(void) { E1(); E3(); E2(); }\t\\\nstatic void name##_213(void) { E2(); E1(); E3(); }\t\\\nstatic void name##_231(void) { E2(); E3(); E1(); }\t\\\nstatic void name##_312(void) { E3(); E1(); E2(); }\t\\\nstatic void name##_321(void) { E3(); E2(); E1(); }\n\n \n\n#define E()\t\t\t\t\t\\\n\t\t\t\t\t\t\\\n\tLOCK(X1);\t\t\t\t\\\n\tLOCK(X2);  \n\n \n#include \"locking-selftest-spin.h\"\nGENERATE_TESTCASE(AA_spin)\n#include \"locking-selftest-wlock.h\"\nGENERATE_TESTCASE(AA_wlock)\n#include \"locking-selftest-rlock.h\"\nGENERATE_TESTCASE(AA_rlock)\n#include \"locking-selftest-mutex.h\"\nGENERATE_TESTCASE(AA_mutex)\n#include \"locking-selftest-wsem.h\"\nGENERATE_TESTCASE(AA_wsem)\n#include \"locking-selftest-rsem.h\"\nGENERATE_TESTCASE(AA_rsem)\n\n#ifdef CONFIG_RT_MUTEXES\n#include \"locking-selftest-rtmutex.h\"\nGENERATE_TESTCASE(AA_rtmutex);\n#endif\n\n#undef E\n\n \nstatic void rlock_AA1(void)\n{\n\tRL(X1);\n\tRL(X1); \n}\n\nstatic void rlock_AA1B(void)\n{\n\tRL(X1);\n\tRL(X2); \n}\n\nstatic void rsem_AA1(void)\n{\n\tRSL(X1);\n\tRSL(X1); \n}\n\nstatic void rsem_AA1B(void)\n{\n\tRSL(X1);\n\tRSL(X2); \n}\n \nstatic void rlock_AA2(void)\n{\n\tRL(X1);\n\tWL(X2); \n}\n\nstatic void rsem_AA2(void)\n{\n\tRSL(X1);\n\tWSL(X2); \n}\n\nstatic void rlock_AA3(void)\n{\n\tWL(X1);\n\tRL(X2); \n}\n\nstatic void rsem_AA3(void)\n{\n\tWSL(X1);\n\tRSL(X2); \n}\n\n \nstatic void rlock_ABBA1(void)\n{\n\tRL(X1);\n\tL(Y1);\n\tU(Y1);\n\tRU(X1);\n\n\tL(Y1);\n\tWL(X1);\n\tWU(X1);\n\tU(Y1); \n}\n\nstatic void rwsem_ABBA1(void)\n{\n\tRSL(X1);\n\tML(Y1);\n\tMU(Y1);\n\tRSU(X1);\n\n\tML(Y1);\n\tWSL(X1);\n\tWSU(X1);\n\tMU(Y1); \n}\n\n \nstatic void rlock_chaincache_ABBA1(void)\n{\n\tRL(X1);\n\tL(Y1);\n\tU(Y1);\n\tRU(X1);\n\n\tL(Y1);\n\tRL(X1);\n\tRU(X1);\n\tU(Y1);\n\n\tL(Y1);\n\tWL(X1);\n\tWU(X1);\n\tU(Y1); \n}\n\n \nstatic void rlock_ABBA2(void)\n{\n\tRL(X1);\n\tL(Y1);\n\tU(Y1);\n\tRU(X1);\n\n\tL(Y1);\n\tRL(X1);\n\tRU(X1);\n\tU(Y1); \n}\n\nstatic void rwsem_ABBA2(void)\n{\n\tRSL(X1);\n\tML(Y1);\n\tMU(Y1);\n\tRSU(X1);\n\n\tML(Y1);\n\tRSL(X1);\n\tRSU(X1);\n\tMU(Y1); \n}\n\n\n \nstatic void rlock_ABBA3(void)\n{\n\tWL(X1);\n\tL(Y1);\n\tU(Y1);\n\tWU(X1);\n\n\tL(Y1);\n\tWL(X1);\n\tWU(X1);\n\tU(Y1); \n}\n\nstatic void rwsem_ABBA3(void)\n{\n\tWSL(X1);\n\tML(Y1);\n\tMU(Y1);\n\tWSU(X1);\n\n\tML(Y1);\n\tWSL(X1);\n\tWSU(X1);\n\tMU(Y1); \n}\n\n \n\n#define E()\t\t\t\t\t\\\n\t\t\t\t\t\t\\\n\tLOCK_UNLOCK_2(A, B);\t\t\t\\\n\tLOCK_UNLOCK_2(B, A);  \n\n \n#include \"locking-selftest-spin.h\"\nGENERATE_TESTCASE(ABBA_spin)\n#include \"locking-selftest-wlock.h\"\nGENERATE_TESTCASE(ABBA_wlock)\n#include \"locking-selftest-rlock.h\"\nGENERATE_TESTCASE(ABBA_rlock)\n#include \"locking-selftest-mutex.h\"\nGENERATE_TESTCASE(ABBA_mutex)\n#include \"locking-selftest-wsem.h\"\nGENERATE_TESTCASE(ABBA_wsem)\n#include \"locking-selftest-rsem.h\"\nGENERATE_TESTCASE(ABBA_rsem)\n\n#ifdef CONFIG_RT_MUTEXES\n#include \"locking-selftest-rtmutex.h\"\nGENERATE_TESTCASE(ABBA_rtmutex);\n#endif\n\n#undef E\n\n \n\n#define E()\t\t\t\t\t\\\n\t\t\t\t\t\t\\\n\tLOCK_UNLOCK_2(A, B);\t\t\t\\\n\tLOCK_UNLOCK_2(B, C);\t\t\t\\\n\tLOCK_UNLOCK_2(C, A);  \n\n \n#include \"locking-selftest-spin.h\"\nGENERATE_TESTCASE(ABBCCA_spin)\n#include \"locking-selftest-wlock.h\"\nGENERATE_TESTCASE(ABBCCA_wlock)\n#include \"locking-selftest-rlock.h\"\nGENERATE_TESTCASE(ABBCCA_rlock)\n#include \"locking-selftest-mutex.h\"\nGENERATE_TESTCASE(ABBCCA_mutex)\n#include \"locking-selftest-wsem.h\"\nGENERATE_TESTCASE(ABBCCA_wsem)\n#include \"locking-selftest-rsem.h\"\nGENERATE_TESTCASE(ABBCCA_rsem)\n\n#ifdef CONFIG_RT_MUTEXES\n#include \"locking-selftest-rtmutex.h\"\nGENERATE_TESTCASE(ABBCCA_rtmutex);\n#endif\n\n#undef E\n\n \n\n#define E()\t\t\t\t\t\\\n\t\t\t\t\t\t\\\n\tLOCK_UNLOCK_2(A, B);\t\t\t\\\n\tLOCK_UNLOCK_2(C, A);\t\t\t\\\n\tLOCK_UNLOCK_2(B, C);  \n\n \n#include \"locking-selftest-spin.h\"\nGENERATE_TESTCASE(ABCABC_spin)\n#include \"locking-selftest-wlock.h\"\nGENERATE_TESTCASE(ABCABC_wlock)\n#include \"locking-selftest-rlock.h\"\nGENERATE_TESTCASE(ABCABC_rlock)\n#include \"locking-selftest-mutex.h\"\nGENERATE_TESTCASE(ABCABC_mutex)\n#include \"locking-selftest-wsem.h\"\nGENERATE_TESTCASE(ABCABC_wsem)\n#include \"locking-selftest-rsem.h\"\nGENERATE_TESTCASE(ABCABC_rsem)\n\n#ifdef CONFIG_RT_MUTEXES\n#include \"locking-selftest-rtmutex.h\"\nGENERATE_TESTCASE(ABCABC_rtmutex);\n#endif\n\n#undef E\n\n \n\n#define E()\t\t\t\t\t\\\n\t\t\t\t\t\t\\\n\tLOCK_UNLOCK_2(A, B);\t\t\t\\\n\tLOCK_UNLOCK_2(B, C);\t\t\t\\\n\tLOCK_UNLOCK_2(C, D);\t\t\t\\\n\tLOCK_UNLOCK_2(D, A);  \n\n \n#include \"locking-selftest-spin.h\"\nGENERATE_TESTCASE(ABBCCDDA_spin)\n#include \"locking-selftest-wlock.h\"\nGENERATE_TESTCASE(ABBCCDDA_wlock)\n#include \"locking-selftest-rlock.h\"\nGENERATE_TESTCASE(ABBCCDDA_rlock)\n#include \"locking-selftest-mutex.h\"\nGENERATE_TESTCASE(ABBCCDDA_mutex)\n#include \"locking-selftest-wsem.h\"\nGENERATE_TESTCASE(ABBCCDDA_wsem)\n#include \"locking-selftest-rsem.h\"\nGENERATE_TESTCASE(ABBCCDDA_rsem)\n\n#ifdef CONFIG_RT_MUTEXES\n#include \"locking-selftest-rtmutex.h\"\nGENERATE_TESTCASE(ABBCCDDA_rtmutex);\n#endif\n\n#undef E\n\n \n#define E()\t\t\t\t\t\\\n\t\t\t\t\t\t\\\n\tLOCK_UNLOCK_2(A, B);\t\t\t\\\n\tLOCK_UNLOCK_2(C, D);\t\t\t\\\n\tLOCK_UNLOCK_2(B, D);\t\t\t\\\n\tLOCK_UNLOCK_2(D, A);  \n\n \n#include \"locking-selftest-spin.h\"\nGENERATE_TESTCASE(ABCDBDDA_spin)\n#include \"locking-selftest-wlock.h\"\nGENERATE_TESTCASE(ABCDBDDA_wlock)\n#include \"locking-selftest-rlock.h\"\nGENERATE_TESTCASE(ABCDBDDA_rlock)\n#include \"locking-selftest-mutex.h\"\nGENERATE_TESTCASE(ABCDBDDA_mutex)\n#include \"locking-selftest-wsem.h\"\nGENERATE_TESTCASE(ABCDBDDA_wsem)\n#include \"locking-selftest-rsem.h\"\nGENERATE_TESTCASE(ABCDBDDA_rsem)\n\n#ifdef CONFIG_RT_MUTEXES\n#include \"locking-selftest-rtmutex.h\"\nGENERATE_TESTCASE(ABCDBDDA_rtmutex);\n#endif\n\n#undef E\n\n \n#define E()\t\t\t\t\t\\\n\t\t\t\t\t\t\\\n\tLOCK_UNLOCK_2(A, B);\t\t\t\\\n\tLOCK_UNLOCK_2(C, D);\t\t\t\\\n\tLOCK_UNLOCK_2(B, C);\t\t\t\\\n\tLOCK_UNLOCK_2(D, A);  \n\n \n#include \"locking-selftest-spin.h\"\nGENERATE_TESTCASE(ABCDBCDA_spin)\n#include \"locking-selftest-wlock.h\"\nGENERATE_TESTCASE(ABCDBCDA_wlock)\n#include \"locking-selftest-rlock.h\"\nGENERATE_TESTCASE(ABCDBCDA_rlock)\n#include \"locking-selftest-mutex.h\"\nGENERATE_TESTCASE(ABCDBCDA_mutex)\n#include \"locking-selftest-wsem.h\"\nGENERATE_TESTCASE(ABCDBCDA_wsem)\n#include \"locking-selftest-rsem.h\"\nGENERATE_TESTCASE(ABCDBCDA_rsem)\n\n#ifdef CONFIG_RT_MUTEXES\n#include \"locking-selftest-rtmutex.h\"\nGENERATE_TESTCASE(ABCDBCDA_rtmutex);\n#endif\n\n#undef E\n\n#ifdef CONFIG_PREEMPT_RT\n# define RT_PREPARE_DBL_UNLOCK()\t{ migrate_disable(); rcu_read_lock(); }\n#else\n# define RT_PREPARE_DBL_UNLOCK()\n#endif\n \n#define E()\t\t\t\t\t\\\n\t\t\t\t\t\t\\\n\tLOCK(A);\t\t\t\t\\\n\tRT_PREPARE_DBL_UNLOCK();\t\t\\\n\tUNLOCK(A);\t\t\t\t\\\n\tUNLOCK(A);  \n\n \n#include \"locking-selftest-spin.h\"\nGENERATE_TESTCASE(double_unlock_spin)\n#include \"locking-selftest-wlock.h\"\nGENERATE_TESTCASE(double_unlock_wlock)\n#include \"locking-selftest-rlock.h\"\nGENERATE_TESTCASE(double_unlock_rlock)\n#include \"locking-selftest-mutex.h\"\nGENERATE_TESTCASE(double_unlock_mutex)\n#include \"locking-selftest-wsem.h\"\nGENERATE_TESTCASE(double_unlock_wsem)\n#include \"locking-selftest-rsem.h\"\nGENERATE_TESTCASE(double_unlock_rsem)\n\n#ifdef CONFIG_RT_MUTEXES\n#include \"locking-selftest-rtmutex.h\"\nGENERATE_TESTCASE(double_unlock_rtmutex);\n#endif\n\n#undef E\n\n \n#define E()\t\t\t\t\t\\\n\t\t\t\t\t\t\\\n\tLOCK(A);\t\t\t\t\\\n\tINIT(A);  \n\n \n#include \"locking-selftest-spin.h\"\nGENERATE_TESTCASE(init_held_spin)\n#include \"locking-selftest-wlock.h\"\nGENERATE_TESTCASE(init_held_wlock)\n#include \"locking-selftest-rlock.h\"\nGENERATE_TESTCASE(init_held_rlock)\n#include \"locking-selftest-mutex.h\"\nGENERATE_TESTCASE(init_held_mutex)\n#include \"locking-selftest-wsem.h\"\nGENERATE_TESTCASE(init_held_wsem)\n#include \"locking-selftest-rsem.h\"\nGENERATE_TESTCASE(init_held_rsem)\n\n#ifdef CONFIG_RT_MUTEXES\n#include \"locking-selftest-rtmutex.h\"\nGENERATE_TESTCASE(init_held_rtmutex);\n#endif\n\n#undef E\n\n \n#define E1()\t\t\t\t\\\n\t\t\t\t\t\\\n\tIRQ_ENTER();\t\t\t\\\n\tLOCK(A);\t\t\t\\\n\tUNLOCK(A);\t\t\t\\\n\tIRQ_EXIT();\n\n#define E2()\t\t\t\t\\\n\t\t\t\t\t\\\n\tLOCK(A);\t\t\t\\\n\tUNLOCK(A);\n\n \n#include \"locking-selftest-spin-hardirq.h\"\nGENERATE_PERMUTATIONS_2_EVENTS(irqsafe1_hard_spin)\n\n#include \"locking-selftest-rlock-hardirq.h\"\nGENERATE_PERMUTATIONS_2_EVENTS(irqsafe1_hard_rlock)\n\n#include \"locking-selftest-wlock-hardirq.h\"\nGENERATE_PERMUTATIONS_2_EVENTS(irqsafe1_hard_wlock)\n\n#ifndef CONFIG_PREEMPT_RT\n#include \"locking-selftest-spin-softirq.h\"\nGENERATE_PERMUTATIONS_2_EVENTS(irqsafe1_soft_spin)\n\n#include \"locking-selftest-rlock-softirq.h\"\nGENERATE_PERMUTATIONS_2_EVENTS(irqsafe1_soft_rlock)\n\n#include \"locking-selftest-wlock-softirq.h\"\nGENERATE_PERMUTATIONS_2_EVENTS(irqsafe1_soft_wlock)\n#endif\n\n#undef E1\n#undef E2\n\n#ifndef CONFIG_PREEMPT_RT\n \n#define E1()\t\t\t\t\\\n\t\t\t\t\t\\\n\tSOFTIRQ_ENTER();\t\t\\\n\tLOCK(A);\t\t\t\\\n\tUNLOCK(A);\t\t\t\\\n\tSOFTIRQ_EXIT();\n\n#define E2()\t\t\t\t\\\n\t\t\t\t\t\\\n\tHARDIRQ_DISABLE();\t\t\\\n\tLOCK(A);\t\t\t\\\n\tHARDIRQ_ENABLE();\t\t\\\n\tUNLOCK(A);\n\n \n#include \"locking-selftest-spin.h\"\nGENERATE_PERMUTATIONS_2_EVENTS(irqsafe2A_spin)\n\n#include \"locking-selftest-wlock.h\"\nGENERATE_PERMUTATIONS_2_EVENTS(irqsafe2A_wlock)\n\n#include \"locking-selftest-rlock.h\"\nGENERATE_PERMUTATIONS_2_EVENTS(irqsafe2A_rlock)\n\n#undef E1\n#undef E2\n\n#endif\n\n \n#define E1()\t\t\t\t\\\n\t\t\t\t\t\\\n\tIRQ_ENTER();\t\t\t\\\n\tLOCK(A);\t\t\t\\\n\tUNLOCK(A);\t\t\t\\\n\tIRQ_EXIT();\n\n#define E2()\t\t\t\t\\\n\t\t\t\t\t\\\n\tIRQ_DISABLE();\t\t\t\\\n\tLOCK(A);\t\t\t\\\n\tIRQ_ENABLE();\t\t\t\\\n\tUNLOCK(A);\n\n \n#include \"locking-selftest-spin-hardirq.h\"\nGENERATE_PERMUTATIONS_2_EVENTS(irqsafe2B_hard_spin)\n\n#include \"locking-selftest-rlock-hardirq.h\"\nGENERATE_PERMUTATIONS_2_EVENTS(irqsafe2B_hard_rlock)\n\n#include \"locking-selftest-wlock-hardirq.h\"\nGENERATE_PERMUTATIONS_2_EVENTS(irqsafe2B_hard_wlock)\n\n#ifndef CONFIG_PREEMPT_RT\n#include \"locking-selftest-spin-softirq.h\"\nGENERATE_PERMUTATIONS_2_EVENTS(irqsafe2B_soft_spin)\n\n#include \"locking-selftest-rlock-softirq.h\"\nGENERATE_PERMUTATIONS_2_EVENTS(irqsafe2B_soft_rlock)\n\n#include \"locking-selftest-wlock-softirq.h\"\nGENERATE_PERMUTATIONS_2_EVENTS(irqsafe2B_soft_wlock)\n#endif\n\n#undef E1\n#undef E2\n\n \n#define E1()\t\t\t\t\\\n\t\t\t\t\t\\\n\tLOCK(A);\t\t\t\\\n\tLOCK(B);\t\t\t\\\n\tUNLOCK(B);\t\t\t\\\n\tUNLOCK(A);\t\t\t\\\n\n#define E2()\t\t\t\t\\\n\t\t\t\t\t\\\n\tLOCK(B);\t\t\t\\\n\tUNLOCK(B);\n\n#define E3()\t\t\t\t\\\n\t\t\t\t\t\\\n\tIRQ_ENTER();\t\t\t\\\n\tLOCK(A);\t\t\t\\\n\tUNLOCK(A);\t\t\t\\\n\tIRQ_EXIT();\n\n \n#include \"locking-selftest-spin-hardirq.h\"\nGENERATE_PERMUTATIONS_3_EVENTS(irqsafe3_hard_spin)\n\n#include \"locking-selftest-rlock-hardirq.h\"\nGENERATE_PERMUTATIONS_3_EVENTS(irqsafe3_hard_rlock)\n\n#include \"locking-selftest-wlock-hardirq.h\"\nGENERATE_PERMUTATIONS_3_EVENTS(irqsafe3_hard_wlock)\n\n#ifndef CONFIG_PREEMPT_RT\n#include \"locking-selftest-spin-softirq.h\"\nGENERATE_PERMUTATIONS_3_EVENTS(irqsafe3_soft_spin)\n\n#include \"locking-selftest-rlock-softirq.h\"\nGENERATE_PERMUTATIONS_3_EVENTS(irqsafe3_soft_rlock)\n\n#include \"locking-selftest-wlock-softirq.h\"\nGENERATE_PERMUTATIONS_3_EVENTS(irqsafe3_soft_wlock)\n#endif\n\n#undef E1\n#undef E2\n#undef E3\n\n \n\n#define E1()\t\t\t\t\\\n\tIRQ_DISABLE();\t\t\t\\\n\tLOCK(A);\t\t\t\\\n\tLOCK(B);\t\t\t\\\n\tUNLOCK(B);\t\t\t\\\n\tUNLOCK(A);\t\t\t\\\n\tIRQ_ENABLE();\n\n#define E2()\t\t\t\t\\\n\tLOCK(B);\t\t\t\\\n\tUNLOCK(B);\n\n#define E3()\t\t\t\t\\\n\tIRQ_ENTER();\t\t\t\\\n\tLOCK(A);\t\t\t\\\n\tUNLOCK(A);\t\t\t\\\n\tIRQ_EXIT();\n\n \n#include \"locking-selftest-spin-hardirq.h\"\nGENERATE_PERMUTATIONS_3_EVENTS(irqsafe4_hard_spin)\n\n#include \"locking-selftest-rlock-hardirq.h\"\nGENERATE_PERMUTATIONS_3_EVENTS(irqsafe4_hard_rlock)\n\n#include \"locking-selftest-wlock-hardirq.h\"\nGENERATE_PERMUTATIONS_3_EVENTS(irqsafe4_hard_wlock)\n\n#ifndef CONFIG_PREEMPT_RT\n#include \"locking-selftest-spin-softirq.h\"\nGENERATE_PERMUTATIONS_3_EVENTS(irqsafe4_soft_spin)\n\n#include \"locking-selftest-rlock-softirq.h\"\nGENERATE_PERMUTATIONS_3_EVENTS(irqsafe4_soft_rlock)\n\n#include \"locking-selftest-wlock-softirq.h\"\nGENERATE_PERMUTATIONS_3_EVENTS(irqsafe4_soft_wlock)\n#endif\n\n#undef E1\n#undef E2\n#undef E3\n\n \n\n#define E1()\t\t\t\t\\\n\t\t\t\t\t\\\n\tIRQ_DISABLE();\t\t\t\\\n\tWL(A);\t\t\t\t\\\n\tLOCK(B);\t\t\t\\\n\tUNLOCK(B);\t\t\t\\\n\tWU(A);\t\t\t\t\\\n\tIRQ_ENABLE();\n\n#define E2()\t\t\t\t\\\n\t\t\t\t\t\\\n\tLOCK(B);\t\t\t\\\n\tUNLOCK(B);\n\n#define E3()\t\t\t\t\\\n\t\t\t\t\t\\\n\tIRQ_ENTER();\t\t\t\\\n\tRL(A);\t\t\t\t\\\n\tRU(A);\t\t\t\t\\\n\tIRQ_EXIT();\n\n \n#include \"locking-selftest-spin-hardirq.h\"\nGENERATE_PERMUTATIONS_3_EVENTS(irq_inversion_hard_spin)\n\n#include \"locking-selftest-rlock-hardirq.h\"\nGENERATE_PERMUTATIONS_3_EVENTS(irq_inversion_hard_rlock)\n\n#include \"locking-selftest-wlock-hardirq.h\"\nGENERATE_PERMUTATIONS_3_EVENTS(irq_inversion_hard_wlock)\n\n#ifndef CONFIG_PREEMPT_RT\n#include \"locking-selftest-spin-softirq.h\"\nGENERATE_PERMUTATIONS_3_EVENTS(irq_inversion_soft_spin)\n\n#include \"locking-selftest-rlock-softirq.h\"\nGENERATE_PERMUTATIONS_3_EVENTS(irq_inversion_soft_rlock)\n\n#include \"locking-selftest-wlock-softirq.h\"\nGENERATE_PERMUTATIONS_3_EVENTS(irq_inversion_soft_wlock)\n#endif\n\n#undef E1\n#undef E2\n#undef E3\n\n \n\n#define E1()\t\t\t\t\\\n\t\t\t\t\t\\\n\tWL(X1);\t\t\t\t\\\n\tRL(Y1);\t\t\t\t\\\n\tRU(Y1);\t\t\t\t\\\n\tWU(X1);\n\n#define E2()\t\t\t\t\\\n\t\t\t\t\t\\\n\tWL(Y1);\t\t\t\t\\\n\tRL(Z1);\t\t\t\t\\\n\tRU(Z1);\t\t\t\t\\\n\tWU(Y1);\n\n#define E3()\t\t\t\t\\\n\t\t\t\t\t\\\n\tWL(Z1);\t\t\t\t\\\n\tRL(X1);\t\t\t\t\\\n\tRU(X1);\t\t\t\t\\\n\tWU(Z1);\n\n#include \"locking-selftest-rlock.h\"\nGENERATE_PERMUTATIONS_3_EVENTS(W1R2_W2R3_W3R1)\n\n#undef E1\n#undef E2\n#undef E3\n\n \n\n#define E1()\t\t\t\t\\\n\t\t\t\t\t\\\n\tWL(X1);\t\t\t\t\\\n\tWL(Y1);\t\t\t\t\\\n\tWU(Y1);\t\t\t\t\\\n\tWU(X1);\n\n#define E2()\t\t\t\t\\\n\t\t\t\t\t\\\n\tRL(Y1);\t\t\t\t\\\n\tRL(Z1);\t\t\t\t\\\n\tRU(Z1);\t\t\t\t\\\n\tRU(Y1);\n\n#define E3()\t\t\t\t\\\n\t\t\t\t\t\\\n\tWL(Z1);\t\t\t\t\\\n\tRL(X1);\t\t\t\t\\\n\tRU(X1);\t\t\t\t\\\n\tWU(Z1);\n\n#include \"locking-selftest-rlock.h\"\nGENERATE_PERMUTATIONS_3_EVENTS(W1W2_R2R3_W3R1)\n\n#undef E1\n#undef E2\n#undef E3\n\n \n\n#define E1()\t\t\t\t\\\n\t\t\t\t\t\\\n\tWL(X1);\t\t\t\t\\\n\tWL(Y1);\t\t\t\t\\\n\tWU(Y1);\t\t\t\t\\\n\tWU(X1);\n\n#define E2()\t\t\t\t\\\n\t\t\t\t\t\\\n\tRL(Y1);\t\t\t\t\\\n\tRL(Z1);\t\t\t\t\\\n\tRU(Z1);\t\t\t\t\\\n\tRU(Y1);\n\n#define E3()\t\t\t\t\\\n\t\t\t\t\t\\\n\tRL(Z1);\t\t\t\t\\\n\tWL(X1);\t\t\t\t\\\n\tWU(X1);\t\t\t\t\\\n\tRU(Z1);\n\n#include \"locking-selftest-rlock.h\"\nGENERATE_PERMUTATIONS_3_EVENTS(W1R2_R2R3_W3W1)\n\n#undef E1\n#undef E2\n#undef E3\n\n \n\n#define E1()\t\t\t\t\\\n\t\t\t\t\t\\\n\tWL(X1);\t\t\t\t\\\n\tRL(Y1);\t\t\t\t\\\n\tRU(Y1);\t\t\t\t\\\n\tWU(X1);\n\n#define E2()\t\t\t\t\\\n\t\t\t\t\t\\\n\tRL(Y1);\t\t\t\t\\\n\tRL(Z1);\t\t\t\t\\\n\tRU(Z1);\t\t\t\t\\\n\tRU(Y1);\n\n#define E3()\t\t\t\t\\\n\t\t\t\t\t\\\n\tWL(Z1);\t\t\t\t\\\n\tWL(X1);\t\t\t\t\\\n\tWU(X1);\t\t\t\t\\\n\tWU(Z1);\n\n#include \"locking-selftest-rlock.h\"\nGENERATE_PERMUTATIONS_3_EVENTS(W1W2_R2R3_R3W1)\n\n#undef E1\n#undef E2\n#undef E3\n \n\n#define E1()\t\t\t\t\\\n\t\t\t\t\t\\\n\tIRQ_DISABLE();\t\t\t\\\n\tWL(A);\t\t\t\t\\\n\tWU(A);\t\t\t\t\\\n\tIRQ_ENABLE();\n\n#define E2()\t\t\t\t\\\n\t\t\t\t\t\\\n\tRL(A);\t\t\t\t\\\n\tRU(A);\t\t\t\t\\\n\n#define E3()\t\t\t\t\\\n\t\t\t\t\t\\\n\tIRQ_ENTER();\t\t\t\\\n\tLOCK(A);\t\t\t\\\n\tL(B);\t\t\t\t\\\n\tU(B);\t\t\t\t\\\n\tUNLOCK(A);\t\t\t\\\n\tIRQ_EXIT();\n\n \n#include \"locking-selftest-hardirq.h\"\n#include \"locking-selftest-rlock.h\"\nGENERATE_PERMUTATIONS_3_EVENTS(irq_read_recursion_hard_rlock)\n\n#include \"locking-selftest-wlock.h\"\nGENERATE_PERMUTATIONS_3_EVENTS(irq_read_recursion_hard_wlock)\n\n#ifndef CONFIG_PREEMPT_RT\n#include \"locking-selftest-softirq.h\"\n#include \"locking-selftest-rlock.h\"\nGENERATE_PERMUTATIONS_3_EVENTS(irq_read_recursion_soft_rlock)\n\n#include \"locking-selftest-wlock.h\"\nGENERATE_PERMUTATIONS_3_EVENTS(irq_read_recursion_soft_wlock)\n#endif\n\n#undef E1\n#undef E2\n#undef E3\n\n \n\n#define E1()\t\t\t\t\\\n\t\t\t\t\t\\\n\tIRQ_DISABLE();\t\t\t\\\n\tL(B);\t\t\t\t\\\n\tLOCK(A);\t\t\t\\\n\tUNLOCK(A);\t\t\t\\\n\tU(B);\t\t\t\t\\\n\tIRQ_ENABLE();\n\n#define E2()\t\t\t\t\\\n\t\t\t\t\t\\\n\tRL(A);\t\t\t\t\\\n\tRU(A);\t\t\t\t\\\n\n#define E3()\t\t\t\t\\\n\t\t\t\t\t\\\n\tIRQ_ENTER();\t\t\t\\\n\tL(B);\t\t\t\t\\\n\tU(B);\t\t\t\t\\\n\tIRQ_EXIT();\n\n \n#include \"locking-selftest-hardirq.h\"\n#include \"locking-selftest-rlock.h\"\nGENERATE_PERMUTATIONS_3_EVENTS(irq_read_recursion2_hard_rlock)\n\n#include \"locking-selftest-wlock.h\"\nGENERATE_PERMUTATIONS_3_EVENTS(irq_read_recursion2_hard_wlock)\n\n#ifndef CONFIG_PREEMPT_RT\n#include \"locking-selftest-softirq.h\"\n#include \"locking-selftest-rlock.h\"\nGENERATE_PERMUTATIONS_3_EVENTS(irq_read_recursion2_soft_rlock)\n\n#include \"locking-selftest-wlock.h\"\nGENERATE_PERMUTATIONS_3_EVENTS(irq_read_recursion2_soft_wlock)\n#endif\n\n#undef E1\n#undef E2\n#undef E3\n \n\n#define E1()\t\t\t\t\\\n\t\t\t\t\t\\\n\tIRQ_DISABLE();\t\t\t\\\n\tWL(B);\t\t\t\t\\\n\tLOCK(A);\t\t\t\\\n\tUNLOCK(A);\t\t\t\\\n\tWU(B);\t\t\t\t\\\n\tIRQ_ENABLE();\n\n#define E2()\t\t\t\t\\\n\t\t\t\t\t\\\n\tRL(A);\t\t\t\t\\\n\tRU(A);\t\t\t\t\\\n\n#define E3()\t\t\t\t\\\n\t\t\t\t\t\\\n\tIRQ_ENTER();\t\t\t\\\n\tRL(B);\t\t\t\t\\\n\tRU(B);\t\t\t\t\\\n\tIRQ_EXIT();\n\n \n#include \"locking-selftest-hardirq.h\"\n#include \"locking-selftest-rlock.h\"\nGENERATE_PERMUTATIONS_3_EVENTS(irq_read_recursion3_hard_rlock)\n\n#include \"locking-selftest-wlock.h\"\nGENERATE_PERMUTATIONS_3_EVENTS(irq_read_recursion3_hard_wlock)\n\n#ifndef CONFIG_PREEMPT_RT\n#include \"locking-selftest-softirq.h\"\n#include \"locking-selftest-rlock.h\"\nGENERATE_PERMUTATIONS_3_EVENTS(irq_read_recursion3_soft_rlock)\n\n#include \"locking-selftest-wlock.h\"\nGENERATE_PERMUTATIONS_3_EVENTS(irq_read_recursion3_soft_wlock)\n#endif\n\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n# define I_SPINLOCK(x)\tlockdep_reset_lock(&lock_##x.dep_map)\n# define I_RAW_SPINLOCK(x)\tlockdep_reset_lock(&raw_lock_##x.dep_map)\n# define I_RWLOCK(x)\tlockdep_reset_lock(&rwlock_##x.dep_map)\n# define I_MUTEX(x)\tlockdep_reset_lock(&mutex_##x.dep_map)\n# define I_RWSEM(x)\tlockdep_reset_lock(&rwsem_##x.dep_map)\n# define I_WW(x)\tlockdep_reset_lock(&x.dep_map)\n# define I_LOCAL_LOCK(x) lockdep_reset_lock(this_cpu_ptr(&local_##x.dep_map))\n#ifdef CONFIG_RT_MUTEXES\n# define I_RTMUTEX(x)\tlockdep_reset_lock(&rtmutex_##x.dep_map)\n#endif\n#else\n# define I_SPINLOCK(x)\n# define I_RAW_SPINLOCK(x)\n# define I_RWLOCK(x)\n# define I_MUTEX(x)\n# define I_RWSEM(x)\n# define I_WW(x)\n# define I_LOCAL_LOCK(x)\n#endif\n\n#ifndef I_RTMUTEX\n# define I_RTMUTEX(x)\n#endif\n\n#ifdef CONFIG_RT_MUTEXES\n#define I2_RTMUTEX(x)\trt_mutex_init(&rtmutex_##x)\n#else\n#define I2_RTMUTEX(x)\n#endif\n\n#define I1(x)\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\\\n\t\tI_SPINLOCK(x);\t\t\t\\\n\t\tI_RWLOCK(x);\t\t\t\\\n\t\tI_MUTEX(x);\t\t\t\\\n\t\tI_RWSEM(x);\t\t\t\\\n\t\tI_RTMUTEX(x);\t\t\t\\\n\t} while (0)\n\n#define I2(x)\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\\\n\t\tspin_lock_init(&lock_##x);\t\\\n\t\trwlock_init(&rwlock_##x);\t\\\n\t\tmutex_init(&mutex_##x);\t\t\\\n\t\tinit_rwsem(&rwsem_##x);\t\t\\\n\t\tI2_RTMUTEX(x);\t\t\t\\\n\t} while (0)\n\nstatic void reset_locks(void)\n{\n\tlocal_irq_disable();\n\tlockdep_free_key_range(&ww_lockdep.acquire_key, 1);\n\tlockdep_free_key_range(&ww_lockdep.mutex_key, 1);\n\n\tI1(A); I1(B); I1(C); I1(D);\n\tI1(X1); I1(X2); I1(Y1); I1(Y2); I1(Z1); I1(Z2);\n\tI_WW(t); I_WW(t2); I_WW(o.base); I_WW(o2.base); I_WW(o3.base);\n\tI_RAW_SPINLOCK(A); I_RAW_SPINLOCK(B);\n\tI_LOCAL_LOCK(A);\n\n\tlockdep_reset();\n\n\tI2(A); I2(B); I2(C); I2(D);\n\tinit_shared_classes();\n\traw_spin_lock_init(&raw_lock_A);\n\traw_spin_lock_init(&raw_lock_B);\n\tlocal_lock_init(this_cpu_ptr(&local_A));\n\n\tww_mutex_init(&o, &ww_lockdep); ww_mutex_init(&o2, &ww_lockdep); ww_mutex_init(&o3, &ww_lockdep);\n\tmemset(&t, 0, sizeof(t)); memset(&t2, 0, sizeof(t2));\n\tmemset(&ww_lockdep.acquire_key, 0, sizeof(ww_lockdep.acquire_key));\n\tmemset(&ww_lockdep.mutex_key, 0, sizeof(ww_lockdep.mutex_key));\n\tlocal_irq_enable();\n}\n\n#undef I\n\nstatic int testcase_total;\nstatic int testcase_successes;\nstatic int expected_testcase_failures;\nstatic int unexpected_testcase_failures;\n\nstatic void dotest(void (*testcase_fn)(void), int expected, int lockclass_mask)\n{\n\tint saved_preempt_count = preempt_count();\n#ifdef CONFIG_PREEMPT_RT\n#ifdef CONFIG_SMP\n\tint saved_mgd_count = current->migration_disabled;\n#endif\n\tint saved_rcu_count = current->rcu_read_lock_nesting;\n#endif\n\n\tWARN_ON(irqs_disabled());\n\n\tdebug_locks_silent = !(debug_locks_verbose & lockclass_mask);\n\n\ttestcase_fn();\n\t \n#ifndef CONFIG_PROVE_LOCKING\n\tif (expected == FAILURE && debug_locks) {\n\t\texpected_testcase_failures++;\n\t\tpr_cont(\"failed|\");\n\t}\n\telse\n#endif\n\tif (debug_locks != expected) {\n\t\tunexpected_testcase_failures++;\n\t\tpr_cont(\"FAILED|\");\n\t} else {\n\t\ttestcase_successes++;\n\t\tpr_cont(\"  ok  |\");\n\t}\n\ttestcase_total++;\n\n\tif (debug_locks_verbose & lockclass_mask)\n\t\tpr_cont(\" lockclass mask: %x, debug_locks: %d, expected: %d\\n\",\n\t\t\tlockclass_mask, debug_locks, expected);\n\t \n\tpreempt_count_set(saved_preempt_count);\n\n#ifdef CONFIG_PREEMPT_RT\n#ifdef CONFIG_SMP\n\twhile (current->migration_disabled > saved_mgd_count)\n\t\tmigrate_enable();\n#endif\n\n\twhile (current->rcu_read_lock_nesting > saved_rcu_count)\n\t\trcu_read_unlock();\n\tWARN_ON_ONCE(current->rcu_read_lock_nesting < saved_rcu_count);\n#endif\n\n#ifdef CONFIG_TRACE_IRQFLAGS\n\tif (softirq_count())\n\t\tcurrent->softirqs_enabled = 0;\n\telse\n\t\tcurrent->softirqs_enabled = 1;\n#endif\n\n\treset_locks();\n}\n\n#ifdef CONFIG_RT_MUTEXES\n#define dotest_rt(fn, e, m)\tdotest((fn), (e), (m))\n#else\n#define dotest_rt(fn, e, m)\n#endif\n\nstatic inline void print_testname(const char *testname)\n{\n\tprintk(\"%33s:\", testname);\n}\n\n#define DO_TESTCASE_1(desc, name, nr)\t\t\t\t\\\n\tprint_testname(desc\"/\"#nr);\t\t\t\t\\\n\tdotest(name##_##nr, SUCCESS, LOCKTYPE_RWLOCK);\t\t\\\n\tpr_cont(\"\\n\");\n\n#define DO_TESTCASE_1B(desc, name, nr)\t\t\t\t\\\n\tprint_testname(desc\"/\"#nr);\t\t\t\t\\\n\tdotest(name##_##nr, FAILURE, LOCKTYPE_RWLOCK);\t\t\\\n\tpr_cont(\"\\n\");\n\n#define DO_TESTCASE_1RR(desc, name, nr)\t\t\t\t\\\n\tprint_testname(desc\"/\"#nr);\t\t\t\t\\\n\tpr_cont(\"             |\");\t\t\t\t\\\n\tdotest(name##_##nr, SUCCESS, LOCKTYPE_RWLOCK);\t\t\\\n\tpr_cont(\"\\n\");\n\n#define DO_TESTCASE_1RRB(desc, name, nr)\t\t\t\\\n\tprint_testname(desc\"/\"#nr);\t\t\t\t\\\n\tpr_cont(\"             |\");\t\t\t\t\\\n\tdotest(name##_##nr, FAILURE, LOCKTYPE_RWLOCK);\t\t\\\n\tpr_cont(\"\\n\");\n\n\n#define DO_TESTCASE_3(desc, name, nr)\t\t\t\t\\\n\tprint_testname(desc\"/\"#nr);\t\t\t\t\\\n\tdotest(name##_spin_##nr, FAILURE, LOCKTYPE_SPIN);\t\\\n\tdotest(name##_wlock_##nr, FAILURE, LOCKTYPE_RWLOCK);\t\\\n\tdotest(name##_rlock_##nr, SUCCESS, LOCKTYPE_RWLOCK);\t\\\n\tpr_cont(\"\\n\");\n\n#define DO_TESTCASE_3RW(desc, name, nr)\t\t\t\t\\\n\tprint_testname(desc\"/\"#nr);\t\t\t\t\\\n\tdotest(name##_spin_##nr, FAILURE, LOCKTYPE_SPIN|LOCKTYPE_RWLOCK);\\\n\tdotest(name##_wlock_##nr, FAILURE, LOCKTYPE_RWLOCK);\t\\\n\tdotest(name##_rlock_##nr, SUCCESS, LOCKTYPE_RWLOCK);\t\\\n\tpr_cont(\"\\n\");\n\n#define DO_TESTCASE_2RW(desc, name, nr)\t\t\t\t\\\n\tprint_testname(desc\"/\"#nr);\t\t\t\t\\\n\tpr_cont(\"      |\");\t\t\t\t\t\\\n\tdotest(name##_wlock_##nr, FAILURE, LOCKTYPE_RWLOCK);\t\\\n\tdotest(name##_rlock_##nr, SUCCESS, LOCKTYPE_RWLOCK);\t\\\n\tpr_cont(\"\\n\");\n\n#define DO_TESTCASE_2x2RW(desc, name, nr)\t\t\t\\\n\tDO_TESTCASE_2RW(\"hard-\"desc, name##_hard, nr)\t\t\\\n\tNON_RT(DO_TESTCASE_2RW(\"soft-\"desc, name##_soft, nr))\t\\\n\n#define DO_TESTCASE_6x2x2RW(desc, name)\t\t\t\t\\\n\tDO_TESTCASE_2x2RW(desc, name, 123);\t\t\t\\\n\tDO_TESTCASE_2x2RW(desc, name, 132);\t\t\t\\\n\tDO_TESTCASE_2x2RW(desc, name, 213);\t\t\t\\\n\tDO_TESTCASE_2x2RW(desc, name, 231);\t\t\t\\\n\tDO_TESTCASE_2x2RW(desc, name, 312);\t\t\t\\\n\tDO_TESTCASE_2x2RW(desc, name, 321);\n\n#define DO_TESTCASE_6(desc, name)\t\t\t\t\\\n\tprint_testname(desc);\t\t\t\t\t\\\n\tdotest(name##_spin, FAILURE, LOCKTYPE_SPIN);\t\t\\\n\tdotest(name##_wlock, FAILURE, LOCKTYPE_RWLOCK);\t\t\\\n\tdotest(name##_rlock, FAILURE, LOCKTYPE_RWLOCK);\t\t\\\n\tdotest(name##_mutex, FAILURE, LOCKTYPE_MUTEX);\t\t\\\n\tdotest(name##_wsem, FAILURE, LOCKTYPE_RWSEM);\t\t\\\n\tdotest(name##_rsem, FAILURE, LOCKTYPE_RWSEM);\t\t\\\n\tdotest_rt(name##_rtmutex, FAILURE, LOCKTYPE_RTMUTEX);\t\\\n\tpr_cont(\"\\n\");\n\n#define DO_TESTCASE_6_SUCCESS(desc, name)\t\t\t\\\n\tprint_testname(desc);\t\t\t\t\t\\\n\tdotest(name##_spin, SUCCESS, LOCKTYPE_SPIN);\t\t\\\n\tdotest(name##_wlock, SUCCESS, LOCKTYPE_RWLOCK);\t\t\\\n\tdotest(name##_rlock, SUCCESS, LOCKTYPE_RWLOCK);\t\t\\\n\tdotest(name##_mutex, SUCCESS, LOCKTYPE_MUTEX);\t\t\\\n\tdotest(name##_wsem, SUCCESS, LOCKTYPE_RWSEM);\t\t\\\n\tdotest(name##_rsem, SUCCESS, LOCKTYPE_RWSEM);\t\t\\\n\tdotest_rt(name##_rtmutex, SUCCESS, LOCKTYPE_RTMUTEX);\t\\\n\tpr_cont(\"\\n\");\n\n \n#define DO_TESTCASE_6R(desc, name)\t\t\t\t\\\n\tprint_testname(desc);\t\t\t\t\t\\\n\tdotest(name##_spin, FAILURE, LOCKTYPE_SPIN);\t\t\\\n\tdotest(name##_wlock, FAILURE, LOCKTYPE_RWLOCK);\t\t\\\n\tdotest(name##_rlock, SUCCESS, LOCKTYPE_RWLOCK);\t\t\\\n\tdotest(name##_mutex, FAILURE, LOCKTYPE_MUTEX);\t\t\\\n\tdotest(name##_wsem, FAILURE, LOCKTYPE_RWSEM);\t\t\\\n\tdotest(name##_rsem, FAILURE, LOCKTYPE_RWSEM);\t\t\\\n\tdotest_rt(name##_rtmutex, FAILURE, LOCKTYPE_RTMUTEX);\t\\\n\tpr_cont(\"\\n\");\n\n#define DO_TESTCASE_2I(desc, name, nr)\t\t\t\t\\\n\tDO_TESTCASE_1(\"hard-\"desc, name##_hard, nr);\t\t\\\n\tNON_RT(DO_TESTCASE_1(\"soft-\"desc, name##_soft, nr));\n\n#define DO_TESTCASE_2IB(desc, name, nr)\t\t\t\t\\\n\tDO_TESTCASE_1B(\"hard-\"desc, name##_hard, nr);\t\t\\\n\tNON_RT(DO_TESTCASE_1B(\"soft-\"desc, name##_soft, nr));\n\n#define DO_TESTCASE_6I(desc, name, nr)\t\t\t\t\\\n\tDO_TESTCASE_3(\"hard-\"desc, name##_hard, nr);\t\t\\\n\tNON_RT(DO_TESTCASE_3(\"soft-\"desc, name##_soft, nr));\n\n#define DO_TESTCASE_6IRW(desc, name, nr)\t\t\t\\\n\tDO_TESTCASE_3RW(\"hard-\"desc, name##_hard, nr);\t\t\\\n\tNON_RT(DO_TESTCASE_3RW(\"soft-\"desc, name##_soft, nr));\n\n#define DO_TESTCASE_2x3(desc, name)\t\t\t\t\\\n\tDO_TESTCASE_3(desc, name, 12);\t\t\t\t\\\n\tDO_TESTCASE_3(desc, name, 21);\n\n#define DO_TESTCASE_2x6(desc, name)\t\t\t\t\\\n\tDO_TESTCASE_6I(desc, name, 12);\t\t\t\t\\\n\tDO_TESTCASE_6I(desc, name, 21);\n\n#define DO_TESTCASE_6x2(desc, name)\t\t\t\t\\\n\tDO_TESTCASE_2I(desc, name, 123);\t\t\t\\\n\tDO_TESTCASE_2I(desc, name, 132);\t\t\t\\\n\tDO_TESTCASE_2I(desc, name, 213);\t\t\t\\\n\tDO_TESTCASE_2I(desc, name, 231);\t\t\t\\\n\tDO_TESTCASE_2I(desc, name, 312);\t\t\t\\\n\tDO_TESTCASE_2I(desc, name, 321);\n\n#define DO_TESTCASE_6x2B(desc, name)\t\t\t\t\\\n\tDO_TESTCASE_2IB(desc, name, 123);\t\t\t\\\n\tDO_TESTCASE_2IB(desc, name, 132);\t\t\t\\\n\tDO_TESTCASE_2IB(desc, name, 213);\t\t\t\\\n\tDO_TESTCASE_2IB(desc, name, 231);\t\t\t\\\n\tDO_TESTCASE_2IB(desc, name, 312);\t\t\t\\\n\tDO_TESTCASE_2IB(desc, name, 321);\n\n#define DO_TESTCASE_6x1RR(desc, name)\t\t\t\t\\\n\tDO_TESTCASE_1RR(desc, name, 123);\t\t\t\\\n\tDO_TESTCASE_1RR(desc, name, 132);\t\t\t\\\n\tDO_TESTCASE_1RR(desc, name, 213);\t\t\t\\\n\tDO_TESTCASE_1RR(desc, name, 231);\t\t\t\\\n\tDO_TESTCASE_1RR(desc, name, 312);\t\t\t\\\n\tDO_TESTCASE_1RR(desc, name, 321);\n\n#define DO_TESTCASE_6x1RRB(desc, name)\t\t\t\t\\\n\tDO_TESTCASE_1RRB(desc, name, 123);\t\t\t\\\n\tDO_TESTCASE_1RRB(desc, name, 132);\t\t\t\\\n\tDO_TESTCASE_1RRB(desc, name, 213);\t\t\t\\\n\tDO_TESTCASE_1RRB(desc, name, 231);\t\t\t\\\n\tDO_TESTCASE_1RRB(desc, name, 312);\t\t\t\\\n\tDO_TESTCASE_1RRB(desc, name, 321);\n\n#define DO_TESTCASE_6x6(desc, name)\t\t\t\t\\\n\tDO_TESTCASE_6I(desc, name, 123);\t\t\t\\\n\tDO_TESTCASE_6I(desc, name, 132);\t\t\t\\\n\tDO_TESTCASE_6I(desc, name, 213);\t\t\t\\\n\tDO_TESTCASE_6I(desc, name, 231);\t\t\t\\\n\tDO_TESTCASE_6I(desc, name, 312);\t\t\t\\\n\tDO_TESTCASE_6I(desc, name, 321);\n\n#define DO_TESTCASE_6x6RW(desc, name)\t\t\t\t\\\n\tDO_TESTCASE_6IRW(desc, name, 123);\t\t\t\\\n\tDO_TESTCASE_6IRW(desc, name, 132);\t\t\t\\\n\tDO_TESTCASE_6IRW(desc, name, 213);\t\t\t\\\n\tDO_TESTCASE_6IRW(desc, name, 231);\t\t\t\\\n\tDO_TESTCASE_6IRW(desc, name, 312);\t\t\t\\\n\tDO_TESTCASE_6IRW(desc, name, 321);\n\nstatic void ww_test_fail_acquire(void)\n{\n\tint ret;\n\n\tWWAI(&t);\n\tt.stamp++;\n\n\tret = WWL(&o, &t);\n\n\tif (WARN_ON(!o.ctx) ||\n\t    WARN_ON(ret))\n\t\treturn;\n\n\t \n\tret = WWL(&o, &t);\n\tWARN_ON(ret != -EALREADY);\n\n\tret = WWT(&o);\n\tWARN_ON(ret);\n\n\tt2 = t;\n\tt2.stamp++;\n\tret = WWL(&o, &t2);\n\tWARN_ON(ret != -EDEADLK);\n\tWWU(&o);\n\n\tif (WWT(&o))\n\t\tWWU(&o);\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\telse\n\t\tDEBUG_LOCKS_WARN_ON(1);\n#endif\n}\n\n#ifdef CONFIG_PREEMPT_RT\n#define ww_mutex_base_lock(b)\t\t\trt_mutex_lock(b)\n#define ww_mutex_base_trylock(b)\t\trt_mutex_trylock(b)\n#define ww_mutex_base_lock_nest_lock(b, b2)\trt_mutex_lock_nest_lock(b, b2)\n#define ww_mutex_base_lock_interruptible(b)\trt_mutex_lock_interruptible(b)\n#define ww_mutex_base_lock_killable(b)\t\trt_mutex_lock_killable(b)\n#define ww_mutex_base_unlock(b)\t\t\trt_mutex_unlock(b)\n#else\n#define ww_mutex_base_lock(b)\t\t\tmutex_lock(b)\n#define ww_mutex_base_trylock(b)\t\tmutex_trylock(b)\n#define ww_mutex_base_lock_nest_lock(b, b2)\tmutex_lock_nest_lock(b, b2)\n#define ww_mutex_base_lock_interruptible(b)\tmutex_lock_interruptible(b)\n#define ww_mutex_base_lock_killable(b)\t\tmutex_lock_killable(b)\n#define ww_mutex_base_unlock(b)\t\t\tmutex_unlock(b)\n#endif\n\nstatic void ww_test_normal(void)\n{\n\tint ret;\n\n\tWWAI(&t);\n\n\t \n\n\t \n\to.ctx = (void *)~0UL;\n\tww_mutex_base_lock(&o.base);\n\tww_mutex_base_unlock(&o.base);\n\tWARN_ON(o.ctx != (void *)~0UL);\n\n\t \n\to.ctx = (void *)~0UL;\n\tret = ww_mutex_base_lock_interruptible(&o.base);\n\tif (!ret)\n\t\tww_mutex_base_unlock(&o.base);\n\telse\n\t\tWARN_ON(1);\n\tWARN_ON(o.ctx != (void *)~0UL);\n\n\t \n\to.ctx = (void *)~0UL;\n\tret = ww_mutex_base_lock_killable(&o.base);\n\tif (!ret)\n\t\tww_mutex_base_unlock(&o.base);\n\telse\n\t\tWARN_ON(1);\n\tWARN_ON(o.ctx != (void *)~0UL);\n\n\t \n\to.ctx = (void *)~0UL;\n\tret = ww_mutex_base_trylock(&o.base);\n\tWARN_ON(!ret);\n\tif (ret)\n\t\tww_mutex_base_unlock(&o.base);\n\telse\n\t\tWARN_ON(1);\n\tWARN_ON(o.ctx != (void *)~0UL);\n\n\t \n\to.ctx = (void *)~0UL;\n\tww_mutex_base_lock(&o.base);\n\tret = ww_mutex_base_trylock(&o.base);\n\tWARN_ON(ret);\n\tww_mutex_base_unlock(&o.base);\n\tWARN_ON(o.ctx != (void *)~0UL);\n\n\t \n\to.ctx = (void *)~0UL;\n\tww_mutex_base_lock_nest_lock(&o.base, &t);\n\tww_mutex_base_unlock(&o.base);\n\tWARN_ON(o.ctx != (void *)~0UL);\n}\n\nstatic void ww_test_two_contexts(void)\n{\n\tWWAI(&t);\n\tWWAI(&t2);\n}\n\nstatic void ww_test_diff_class(void)\n{\n\tWWAI(&t);\n#ifdef DEBUG_WW_MUTEXES\n\tt.ww_class = NULL;\n#endif\n\tWWL(&o, &t);\n}\n\nstatic void ww_test_context_done_twice(void)\n{\n\tWWAI(&t);\n\tWWAD(&t);\n\tWWAD(&t);\n\tWWAF(&t);\n}\n\nstatic void ww_test_context_unlock_twice(void)\n{\n\tWWAI(&t);\n\tWWAD(&t);\n\tWWAF(&t);\n\tWWAF(&t);\n}\n\nstatic void ww_test_context_fini_early(void)\n{\n\tWWAI(&t);\n\tWWL(&o, &t);\n\tWWAD(&t);\n\tWWAF(&t);\n}\n\nstatic void ww_test_context_lock_after_done(void)\n{\n\tWWAI(&t);\n\tWWAD(&t);\n\tWWL(&o, &t);\n}\n\nstatic void ww_test_object_unlock_twice(void)\n{\n\tWWL1(&o);\n\tWWU(&o);\n\tWWU(&o);\n}\n\nstatic void ww_test_object_lock_unbalanced(void)\n{\n\tWWAI(&t);\n\tWWL(&o, &t);\n\tt.acquired = 0;\n\tWWU(&o);\n\tWWAF(&t);\n}\n\nstatic void ww_test_object_lock_stale_context(void)\n{\n\tWWAI(&t);\n\to.ctx = &t2;\n\tWWL(&o, &t);\n}\n\nstatic void ww_test_edeadlk_normal(void)\n{\n\tint ret;\n\n\tww_mutex_base_lock(&o2.base);\n\to2.ctx = &t2;\n\tmutex_release(&o2.base.dep_map, _THIS_IP_);\n\n\tWWAI(&t);\n\tt2 = t;\n\tt2.stamp--;\n\n\tret = WWL(&o, &t);\n\tWARN_ON(ret);\n\n\tret = WWL(&o2, &t);\n\tWARN_ON(ret != -EDEADLK);\n\n\to2.ctx = NULL;\n\tmutex_acquire(&o2.base.dep_map, 0, 1, _THIS_IP_);\n\tww_mutex_base_unlock(&o2.base);\n\tWWU(&o);\n\n\tWWL(&o2, &t);\n}\n\nstatic void ww_test_edeadlk_normal_slow(void)\n{\n\tint ret;\n\n\tww_mutex_base_lock(&o2.base);\n\tmutex_release(&o2.base.dep_map, _THIS_IP_);\n\to2.ctx = &t2;\n\n\tWWAI(&t);\n\tt2 = t;\n\tt2.stamp--;\n\n\tret = WWL(&o, &t);\n\tWARN_ON(ret);\n\n\tret = WWL(&o2, &t);\n\tWARN_ON(ret != -EDEADLK);\n\n\to2.ctx = NULL;\n\tmutex_acquire(&o2.base.dep_map, 0, 1, _THIS_IP_);\n\tww_mutex_base_unlock(&o2.base);\n\tWWU(&o);\n\n\tww_mutex_lock_slow(&o2, &t);\n}\n\nstatic void ww_test_edeadlk_no_unlock(void)\n{\n\tint ret;\n\n\tww_mutex_base_lock(&o2.base);\n\to2.ctx = &t2;\n\tmutex_release(&o2.base.dep_map, _THIS_IP_);\n\n\tWWAI(&t);\n\tt2 = t;\n\tt2.stamp--;\n\n\tret = WWL(&o, &t);\n\tWARN_ON(ret);\n\n\tret = WWL(&o2, &t);\n\tWARN_ON(ret != -EDEADLK);\n\n\to2.ctx = NULL;\n\tmutex_acquire(&o2.base.dep_map, 0, 1, _THIS_IP_);\n\tww_mutex_base_unlock(&o2.base);\n\n\tWWL(&o2, &t);\n}\n\nstatic void ww_test_edeadlk_no_unlock_slow(void)\n{\n\tint ret;\n\n\tww_mutex_base_lock(&o2.base);\n\tmutex_release(&o2.base.dep_map, _THIS_IP_);\n\to2.ctx = &t2;\n\n\tWWAI(&t);\n\tt2 = t;\n\tt2.stamp--;\n\n\tret = WWL(&o, &t);\n\tWARN_ON(ret);\n\n\tret = WWL(&o2, &t);\n\tWARN_ON(ret != -EDEADLK);\n\n\to2.ctx = NULL;\n\tmutex_acquire(&o2.base.dep_map, 0, 1, _THIS_IP_);\n\tww_mutex_base_unlock(&o2.base);\n\n\tww_mutex_lock_slow(&o2, &t);\n}\n\nstatic void ww_test_edeadlk_acquire_more(void)\n{\n\tint ret;\n\n\tww_mutex_base_lock(&o2.base);\n\tmutex_release(&o2.base.dep_map, _THIS_IP_);\n\to2.ctx = &t2;\n\n\tWWAI(&t);\n\tt2 = t;\n\tt2.stamp--;\n\n\tret = WWL(&o, &t);\n\tWARN_ON(ret);\n\n\tret = WWL(&o2, &t);\n\tWARN_ON(ret != -EDEADLK);\n\n\tret = WWL(&o3, &t);\n}\n\nstatic void ww_test_edeadlk_acquire_more_slow(void)\n{\n\tint ret;\n\n\tww_mutex_base_lock(&o2.base);\n\tmutex_release(&o2.base.dep_map, _THIS_IP_);\n\to2.ctx = &t2;\n\n\tWWAI(&t);\n\tt2 = t;\n\tt2.stamp--;\n\n\tret = WWL(&o, &t);\n\tWARN_ON(ret);\n\n\tret = WWL(&o2, &t);\n\tWARN_ON(ret != -EDEADLK);\n\n\tww_mutex_lock_slow(&o3, &t);\n}\n\nstatic void ww_test_edeadlk_acquire_more_edeadlk(void)\n{\n\tint ret;\n\n\tww_mutex_base_lock(&o2.base);\n\tmutex_release(&o2.base.dep_map, _THIS_IP_);\n\to2.ctx = &t2;\n\n\tww_mutex_base_lock(&o3.base);\n\tmutex_release(&o3.base.dep_map, _THIS_IP_);\n\to3.ctx = &t2;\n\n\tWWAI(&t);\n\tt2 = t;\n\tt2.stamp--;\n\n\tret = WWL(&o, &t);\n\tWARN_ON(ret);\n\n\tret = WWL(&o2, &t);\n\tWARN_ON(ret != -EDEADLK);\n\n\tret = WWL(&o3, &t);\n\tWARN_ON(ret != -EDEADLK);\n}\n\nstatic void ww_test_edeadlk_acquire_more_edeadlk_slow(void)\n{\n\tint ret;\n\n\tww_mutex_base_lock(&o2.base);\n\tmutex_release(&o2.base.dep_map, _THIS_IP_);\n\to2.ctx = &t2;\n\n\tww_mutex_base_lock(&o3.base);\n\tmutex_release(&o3.base.dep_map, _THIS_IP_);\n\to3.ctx = &t2;\n\n\tWWAI(&t);\n\tt2 = t;\n\tt2.stamp--;\n\n\tret = WWL(&o, &t);\n\tWARN_ON(ret);\n\n\tret = WWL(&o2, &t);\n\tWARN_ON(ret != -EDEADLK);\n\n\tww_mutex_lock_slow(&o3, &t);\n}\n\nstatic void ww_test_edeadlk_acquire_wrong(void)\n{\n\tint ret;\n\n\tww_mutex_base_lock(&o2.base);\n\tmutex_release(&o2.base.dep_map, _THIS_IP_);\n\to2.ctx = &t2;\n\n\tWWAI(&t);\n\tt2 = t;\n\tt2.stamp--;\n\n\tret = WWL(&o, &t);\n\tWARN_ON(ret);\n\n\tret = WWL(&o2, &t);\n\tWARN_ON(ret != -EDEADLK);\n\tif (!ret)\n\t\tWWU(&o2);\n\n\tWWU(&o);\n\n\tret = WWL(&o3, &t);\n}\n\nstatic void ww_test_edeadlk_acquire_wrong_slow(void)\n{\n\tint ret;\n\n\tww_mutex_base_lock(&o2.base);\n\tmutex_release(&o2.base.dep_map, _THIS_IP_);\n\to2.ctx = &t2;\n\n\tWWAI(&t);\n\tt2 = t;\n\tt2.stamp--;\n\n\tret = WWL(&o, &t);\n\tWARN_ON(ret);\n\n\tret = WWL(&o2, &t);\n\tWARN_ON(ret != -EDEADLK);\n\tif (!ret)\n\t\tWWU(&o2);\n\n\tWWU(&o);\n\n\tww_mutex_lock_slow(&o3, &t);\n}\n\nstatic void ww_test_spin_nest_unlocked(void)\n{\n\tspin_lock_nest_lock(&lock_A, &o.base);\n\tU(A);\n}\n\n \nstatic void ww_test_spin_nest_lock(void)\n{\n\tspin_lock(&lock_X1);\n\tspin_lock_nest_lock(&lock_Y1, &lock_X1);\n\tspin_lock(&lock_A);\n\tspin_lock_nest_lock(&lock_Y2, &lock_X1);\n\tspin_unlock(&lock_A);\n\tspin_unlock(&lock_Y2);\n\tspin_unlock(&lock_Y1);\n\tspin_unlock(&lock_X1);\n}\n\nstatic void ww_test_unneeded_slow(void)\n{\n\tWWAI(&t);\n\n\tww_mutex_lock_slow(&o, &t);\n}\n\nstatic void ww_test_context_block(void)\n{\n\tint ret;\n\n\tWWAI(&t);\n\n\tret = WWL(&o, &t);\n\tWARN_ON(ret);\n\tWWL1(&o2);\n}\n\nstatic void ww_test_context_try(void)\n{\n\tint ret;\n\n\tWWAI(&t);\n\n\tret = WWL(&o, &t);\n\tWARN_ON(ret);\n\n\tret = WWT(&o2);\n\tWARN_ON(!ret);\n\tWWU(&o2);\n\tWWU(&o);\n}\n\nstatic void ww_test_context_context(void)\n{\n\tint ret;\n\n\tWWAI(&t);\n\n\tret = WWL(&o, &t);\n\tWARN_ON(ret);\n\n\tret = WWL(&o2, &t);\n\tWARN_ON(ret);\n\n\tWWU(&o2);\n\tWWU(&o);\n}\n\nstatic void ww_test_try_block(void)\n{\n\tbool ret;\n\n\tret = WWT(&o);\n\tWARN_ON(!ret);\n\n\tWWL1(&o2);\n\tWWU(&o2);\n\tWWU(&o);\n}\n\nstatic void ww_test_try_try(void)\n{\n\tbool ret;\n\n\tret = WWT(&o);\n\tWARN_ON(!ret);\n\tret = WWT(&o2);\n\tWARN_ON(!ret);\n\tWWU(&o2);\n\tWWU(&o);\n}\n\nstatic void ww_test_try_context(void)\n{\n\tint ret;\n\n\tret = WWT(&o);\n\tWARN_ON(!ret);\n\n\tWWAI(&t);\n\n\tret = WWL(&o2, &t);\n\tWARN_ON(ret);\n}\n\nstatic void ww_test_block_block(void)\n{\n\tWWL1(&o);\n\tWWL1(&o2);\n}\n\nstatic void ww_test_block_try(void)\n{\n\tbool ret;\n\n\tWWL1(&o);\n\tret = WWT(&o2);\n\tWARN_ON(!ret);\n}\n\nstatic void ww_test_block_context(void)\n{\n\tint ret;\n\n\tWWL1(&o);\n\tWWAI(&t);\n\n\tret = WWL(&o2, &t);\n\tWARN_ON(ret);\n}\n\nstatic void ww_test_spin_block(void)\n{\n\tL(A);\n\tU(A);\n\n\tWWL1(&o);\n\tL(A);\n\tU(A);\n\tWWU(&o);\n\n\tL(A);\n\tWWL1(&o);\n\tWWU(&o);\n\tU(A);\n}\n\nstatic void ww_test_spin_try(void)\n{\n\tbool ret;\n\n\tL(A);\n\tU(A);\n\n\tret = WWT(&o);\n\tWARN_ON(!ret);\n\tL(A);\n\tU(A);\n\tWWU(&o);\n\n\tL(A);\n\tret = WWT(&o);\n\tWARN_ON(!ret);\n\tWWU(&o);\n\tU(A);\n}\n\nstatic void ww_test_spin_context(void)\n{\n\tint ret;\n\n\tL(A);\n\tU(A);\n\n\tWWAI(&t);\n\n\tret = WWL(&o, &t);\n\tWARN_ON(ret);\n\tL(A);\n\tU(A);\n\tWWU(&o);\n\n\tL(A);\n\tret = WWL(&o, &t);\n\tWARN_ON(ret);\n\tWWU(&o);\n\tU(A);\n}\n\nstatic void ww_tests(void)\n{\n\tprintk(\"  --------------------------------------------------------------------------\\n\");\n\tprintk(\"  | Wound/wait tests |\\n\");\n\tprintk(\"  ---------------------\\n\");\n\n\tprint_testname(\"ww api failures\");\n\tdotest(ww_test_fail_acquire, SUCCESS, LOCKTYPE_WW);\n\tdotest(ww_test_normal, SUCCESS, LOCKTYPE_WW);\n\tdotest(ww_test_unneeded_slow, FAILURE, LOCKTYPE_WW);\n\tpr_cont(\"\\n\");\n\n\tprint_testname(\"ww contexts mixing\");\n\tdotest(ww_test_two_contexts, FAILURE, LOCKTYPE_WW);\n\tdotest(ww_test_diff_class, FAILURE, LOCKTYPE_WW);\n\tpr_cont(\"\\n\");\n\n\tprint_testname(\"finishing ww context\");\n\tdotest(ww_test_context_done_twice, FAILURE, LOCKTYPE_WW);\n\tdotest(ww_test_context_unlock_twice, FAILURE, LOCKTYPE_WW);\n\tdotest(ww_test_context_fini_early, FAILURE, LOCKTYPE_WW);\n\tdotest(ww_test_context_lock_after_done, FAILURE, LOCKTYPE_WW);\n\tpr_cont(\"\\n\");\n\n\tprint_testname(\"locking mismatches\");\n\tdotest(ww_test_object_unlock_twice, FAILURE, LOCKTYPE_WW);\n\tdotest(ww_test_object_lock_unbalanced, FAILURE, LOCKTYPE_WW);\n\tdotest(ww_test_object_lock_stale_context, FAILURE, LOCKTYPE_WW);\n\tpr_cont(\"\\n\");\n\n\tprint_testname(\"EDEADLK handling\");\n\tdotest(ww_test_edeadlk_normal, SUCCESS, LOCKTYPE_WW);\n\tdotest(ww_test_edeadlk_normal_slow, SUCCESS, LOCKTYPE_WW);\n\tdotest(ww_test_edeadlk_no_unlock, FAILURE, LOCKTYPE_WW);\n\tdotest(ww_test_edeadlk_no_unlock_slow, FAILURE, LOCKTYPE_WW);\n\tdotest(ww_test_edeadlk_acquire_more, FAILURE, LOCKTYPE_WW);\n\tdotest(ww_test_edeadlk_acquire_more_slow, FAILURE, LOCKTYPE_WW);\n\tdotest(ww_test_edeadlk_acquire_more_edeadlk, FAILURE, LOCKTYPE_WW);\n\tdotest(ww_test_edeadlk_acquire_more_edeadlk_slow, FAILURE, LOCKTYPE_WW);\n\tdotest(ww_test_edeadlk_acquire_wrong, FAILURE, LOCKTYPE_WW);\n\tdotest(ww_test_edeadlk_acquire_wrong_slow, FAILURE, LOCKTYPE_WW);\n\tpr_cont(\"\\n\");\n\n\tprint_testname(\"spinlock nest unlocked\");\n\tdotest(ww_test_spin_nest_unlocked, FAILURE, LOCKTYPE_WW);\n\tpr_cont(\"\\n\");\n\n\tprint_testname(\"spinlock nest test\");\n\tdotest(ww_test_spin_nest_lock, SUCCESS, LOCKTYPE_WW);\n\tpr_cont(\"\\n\");\n\n\tprintk(\"  -----------------------------------------------------\\n\");\n\tprintk(\"                                 |block | try  |context|\\n\");\n\tprintk(\"  -----------------------------------------------------\\n\");\n\n\tprint_testname(\"context\");\n\tdotest(ww_test_context_block, FAILURE, LOCKTYPE_WW);\n\tdotest(ww_test_context_try, SUCCESS, LOCKTYPE_WW);\n\tdotest(ww_test_context_context, SUCCESS, LOCKTYPE_WW);\n\tpr_cont(\"\\n\");\n\n\tprint_testname(\"try\");\n\tdotest(ww_test_try_block, FAILURE, LOCKTYPE_WW);\n\tdotest(ww_test_try_try, SUCCESS, LOCKTYPE_WW);\n\tdotest(ww_test_try_context, FAILURE, LOCKTYPE_WW);\n\tpr_cont(\"\\n\");\n\n\tprint_testname(\"block\");\n\tdotest(ww_test_block_block, FAILURE, LOCKTYPE_WW);\n\tdotest(ww_test_block_try, SUCCESS, LOCKTYPE_WW);\n\tdotest(ww_test_block_context, FAILURE, LOCKTYPE_WW);\n\tpr_cont(\"\\n\");\n\n\tprint_testname(\"spinlock\");\n\tdotest(ww_test_spin_block, FAILURE, LOCKTYPE_WW);\n\tdotest(ww_test_spin_try, SUCCESS, LOCKTYPE_WW);\n\tdotest(ww_test_spin_context, FAILURE, LOCKTYPE_WW);\n\tpr_cont(\"\\n\");\n}\n\n\n \nstatic void queued_read_lock_hardirq_RE_Er(void)\n{\n\tHARDIRQ_ENTER();\n\tread_lock(&rwlock_A);\n\tLOCK(B);\n\tUNLOCK(B);\n\tread_unlock(&rwlock_A);\n\tHARDIRQ_EXIT();\n\n\tHARDIRQ_DISABLE();\n\tLOCK(B);\n\tread_lock(&rwlock_A);\n\tread_unlock(&rwlock_A);\n\tUNLOCK(B);\n\tHARDIRQ_ENABLE();\n}\n\n \nstatic void queued_read_lock_hardirq_ER_rE(void)\n{\n\tHARDIRQ_ENTER();\n\tLOCK(B);\n\tread_lock(&rwlock_A);\n\tread_unlock(&rwlock_A);\n\tUNLOCK(B);\n\tHARDIRQ_EXIT();\n\n\tHARDIRQ_DISABLE();\n\tread_lock(&rwlock_A);\n\tLOCK(B);\n\tUNLOCK(B);\n\tread_unlock(&rwlock_A);\n\tHARDIRQ_ENABLE();\n}\n\n \nstatic void queued_read_lock_hardirq_inversion(void)\n{\n\n\tHARDIRQ_ENTER();\n\tLOCK(B);\n\tUNLOCK(B);\n\tHARDIRQ_EXIT();\n\n\tHARDIRQ_DISABLE();\n\tLOCK(B);\n\tread_lock(&rwlock_A);\n\tread_unlock(&rwlock_A);\n\tUNLOCK(B);\n\tHARDIRQ_ENABLE();\n\n\tread_lock(&rwlock_A);\n\tread_unlock(&rwlock_A);\n}\n\nstatic void queued_read_lock_tests(void)\n{\n\tprintk(\"  --------------------------------------------------------------------------\\n\");\n\tprintk(\"  | queued read lock tests |\\n\");\n\tprintk(\"  ---------------------------\\n\");\n\tprint_testname(\"hardirq read-lock/lock-read\");\n\tdotest(queued_read_lock_hardirq_RE_Er, FAILURE, LOCKTYPE_RWLOCK);\n\tpr_cont(\"\\n\");\n\n\tprint_testname(\"hardirq lock-read/read-lock\");\n\tdotest(queued_read_lock_hardirq_ER_rE, SUCCESS, LOCKTYPE_RWLOCK);\n\tpr_cont(\"\\n\");\n\n\tprint_testname(\"hardirq inversion\");\n\tdotest(queued_read_lock_hardirq_inversion, FAILURE, LOCKTYPE_RWLOCK);\n\tpr_cont(\"\\n\");\n}\n\nstatic void fs_reclaim_correct_nesting(void)\n{\n\tfs_reclaim_acquire(GFP_KERNEL);\n\tmight_alloc(GFP_NOFS);\n\tfs_reclaim_release(GFP_KERNEL);\n}\n\nstatic void fs_reclaim_wrong_nesting(void)\n{\n\tfs_reclaim_acquire(GFP_KERNEL);\n\tmight_alloc(GFP_KERNEL);\n\tfs_reclaim_release(GFP_KERNEL);\n}\n\nstatic void fs_reclaim_protected_nesting(void)\n{\n\tunsigned int flags;\n\n\tfs_reclaim_acquire(GFP_KERNEL);\n\tflags = memalloc_nofs_save();\n\tmight_alloc(GFP_KERNEL);\n\tmemalloc_nofs_restore(flags);\n\tfs_reclaim_release(GFP_KERNEL);\n}\n\nstatic void fs_reclaim_tests(void)\n{\n\tprintk(\"  --------------------\\n\");\n\tprintk(\"  | fs_reclaim tests |\\n\");\n\tprintk(\"  --------------------\\n\");\n\n\tprint_testname(\"correct nesting\");\n\tdotest(fs_reclaim_correct_nesting, SUCCESS, 0);\n\tpr_cont(\"\\n\");\n\n\tprint_testname(\"wrong nesting\");\n\tdotest(fs_reclaim_wrong_nesting, FAILURE, 0);\n\tpr_cont(\"\\n\");\n\n\tprint_testname(\"protected nesting\");\n\tdotest(fs_reclaim_protected_nesting, SUCCESS, 0);\n\tpr_cont(\"\\n\");\n}\n\n \nDEFINE_LOCK_GUARD_0(HARDIRQ, HARDIRQ_ENTER(), HARDIRQ_EXIT())\nDEFINE_LOCK_GUARD_0(NOTTHREADED_HARDIRQ,\n\tdo {\n\t\tlocal_irq_disable();\n\t\t__irq_enter();\n\t\tWARN_ON(!in_irq());\n\t} while(0), HARDIRQ_EXIT())\nDEFINE_LOCK_GUARD_0(SOFTIRQ, SOFTIRQ_ENTER(), SOFTIRQ_EXIT())\n\n \nDEFINE_LOCK_GUARD_0(RCU, rcu_read_lock(), rcu_read_unlock())\nDEFINE_LOCK_GUARD_0(RCU_BH, rcu_read_lock_bh(), rcu_read_unlock_bh())\nDEFINE_LOCK_GUARD_0(RCU_SCHED, rcu_read_lock_sched(), rcu_read_unlock_sched())\n\n\n#define GENERATE_2_CONTEXT_TESTCASE(outer, outer_lock, inner, inner_lock)\t\\\n\t\t\t\t\t\t\t\t\t\t\\\nstatic void __maybe_unused inner##_in_##outer(void)\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\t\\\n\t \t\t\\\n\tguard(outer)(outer_lock);\t\t\t\t\t\t\\\n\tguard(inner)(inner_lock);\t\t\t\t\t\t\\\n}\n\n \n\n#define GENERATE_2_CONTEXT_TESTCASE_FOR_ALL_OUTER(inner, inner_lock)\t\t\\\nGENERATE_2_CONTEXT_TESTCASE(HARDIRQ, , inner, inner_lock)\t\t\t\\\nGENERATE_2_CONTEXT_TESTCASE(NOTTHREADED_HARDIRQ, , inner, inner_lock)\t\t\\\nGENERATE_2_CONTEXT_TESTCASE(SOFTIRQ, , inner, inner_lock)\t\t\t\\\nGENERATE_2_CONTEXT_TESTCASE(RCU, , inner, inner_lock)\t\t\t\t\\\nGENERATE_2_CONTEXT_TESTCASE(RCU_BH, , inner, inner_lock)\t\t\t\\\nGENERATE_2_CONTEXT_TESTCASE(RCU_SCHED, , inner, inner_lock)\t\t\t\\\nGENERATE_2_CONTEXT_TESTCASE(raw_spinlock, &raw_lock_A, inner, inner_lock)\t\\\nGENERATE_2_CONTEXT_TESTCASE(spinlock, &lock_A, inner, inner_lock)\t\t\\\nGENERATE_2_CONTEXT_TESTCASE(mutex, &mutex_A, inner, inner_lock)\n\nGENERATE_2_CONTEXT_TESTCASE_FOR_ALL_OUTER(RCU, )\nGENERATE_2_CONTEXT_TESTCASE_FOR_ALL_OUTER(raw_spinlock, &raw_lock_B)\nGENERATE_2_CONTEXT_TESTCASE_FOR_ALL_OUTER(spinlock, &lock_B)\nGENERATE_2_CONTEXT_TESTCASE_FOR_ALL_OUTER(mutex, &mutex_B)\n\n \n#define DO_CONTEXT_TESTCASE_OUTER_PREEMPTIBLE(outer)\t\t\t\\\n\tdotest(RCU_in_##outer, SUCCESS, LOCKTYPE_RWLOCK);\t\t\\\n\tdotest(raw_spinlock_in_##outer, SUCCESS, LOCKTYPE_SPIN);\t\\\n\tdotest(spinlock_in_##outer, SUCCESS, LOCKTYPE_SPIN);\t\t\\\n\tdotest(mutex_in_##outer, SUCCESS, LOCKTYPE_MUTEX);\t\t\\\n\n \n#define DO_CONTEXT_TESTCASE_OUTER_LIMITED_PREEMPTIBLE(outer)\t\t\\\n\tdotest(RCU_in_##outer, SUCCESS, LOCKTYPE_RWLOCK);\t\t\\\n\tdotest(raw_spinlock_in_##outer, SUCCESS, LOCKTYPE_SPIN);\t\\\n\tdotest(spinlock_in_##outer, SUCCESS, LOCKTYPE_SPIN);\t\t\\\n\tdotest(mutex_in_##outer, FAILURE, LOCKTYPE_MUTEX);\t\t\\\n\n \n#define DO_CONTEXT_TESTCASE_OUTER_NOT_PREEMPTIBLE(outer)\t\t\t\\\n\tdotest(RCU_in_##outer, SUCCESS, LOCKTYPE_RWLOCK);\t\t\\\n\tdotest(raw_spinlock_in_##outer, SUCCESS, LOCKTYPE_SPIN);\t\\\n\tdotest(spinlock_in_##outer, FAILURE, LOCKTYPE_SPIN);\t\t\\\n\tdotest(mutex_in_##outer, FAILURE, LOCKTYPE_MUTEX);\t\t\\\n\nstatic void wait_context_tests(void)\n{\n\tprintk(\"  --------------------------------------------------------------------------\\n\");\n\tprintk(\"  | wait context tests |\\n\");\n\tprintk(\"  --------------------------------------------------------------------------\\n\");\n\tprintk(\"                                 | rcu  | raw  | spin |mutex |\\n\");\n\tprintk(\"  --------------------------------------------------------------------------\\n\");\n\tprint_testname(\"in hardirq context\");\n\tDO_CONTEXT_TESTCASE_OUTER_LIMITED_PREEMPTIBLE(HARDIRQ);\n\tpr_cont(\"\\n\");\n\n\tprint_testname(\"in hardirq context (not threaded)\");\n\tDO_CONTEXT_TESTCASE_OUTER_NOT_PREEMPTIBLE(NOTTHREADED_HARDIRQ);\n\tpr_cont(\"\\n\");\n\n\tprint_testname(\"in softirq context\");\n\tDO_CONTEXT_TESTCASE_OUTER_LIMITED_PREEMPTIBLE(SOFTIRQ);\n\tpr_cont(\"\\n\");\n\n\tprint_testname(\"in RCU context\");\n\tDO_CONTEXT_TESTCASE_OUTER_LIMITED_PREEMPTIBLE(RCU);\n\tpr_cont(\"\\n\");\n\n\tprint_testname(\"in RCU-bh context\");\n\tDO_CONTEXT_TESTCASE_OUTER_LIMITED_PREEMPTIBLE(RCU_BH);\n\tpr_cont(\"\\n\");\n\n\tprint_testname(\"in RCU-sched context\");\n\tDO_CONTEXT_TESTCASE_OUTER_NOT_PREEMPTIBLE(RCU_SCHED);\n\tpr_cont(\"\\n\");\n\n\tprint_testname(\"in RAW_SPINLOCK context\");\n\tDO_CONTEXT_TESTCASE_OUTER_NOT_PREEMPTIBLE(raw_spinlock);\n\tpr_cont(\"\\n\");\n\n\tprint_testname(\"in SPINLOCK context\");\n\tDO_CONTEXT_TESTCASE_OUTER_LIMITED_PREEMPTIBLE(spinlock);\n\tpr_cont(\"\\n\");\n\n\tprint_testname(\"in MUTEX context\");\n\tDO_CONTEXT_TESTCASE_OUTER_PREEMPTIBLE(mutex);\n\tpr_cont(\"\\n\");\n}\n\nstatic void local_lock_2(void)\n{\n\tlocal_lock(&local_A);\t \n\tlocal_unlock(&local_A);\n\n\tHARDIRQ_ENTER();\n\tspin_lock(&lock_A);\t\t \n\tspin_unlock(&lock_A);\n\tHARDIRQ_EXIT()\n\n\tHARDIRQ_DISABLE();\n\tspin_lock(&lock_A);\n\tlocal_lock(&local_A);\t \n\tlocal_unlock(&local_A);\n\tspin_unlock(&lock_A);\n\tHARDIRQ_ENABLE();\n}\n\nstatic void local_lock_3A(void)\n{\n\tlocal_lock(&local_A);\t \n\tspin_lock(&lock_B);\t\t \n\tspin_unlock(&lock_B);\n\tlocal_unlock(&local_A);\n\n\tHARDIRQ_ENTER();\n\tspin_lock(&lock_A);\t\t \n\tspin_unlock(&lock_A);\n\tHARDIRQ_EXIT()\n\n\tHARDIRQ_DISABLE();\n\tspin_lock(&lock_A);\n\tlocal_lock(&local_A);\t \n\tlocal_unlock(&local_A);\n\tspin_unlock(&lock_A);\n\tHARDIRQ_ENABLE();\n}\n\nstatic void local_lock_3B(void)\n{\n\tlocal_lock(&local_A);\t \n\tspin_lock(&lock_B);\t\t \n\tspin_unlock(&lock_B);\n\tlocal_unlock(&local_A);\n\n\tHARDIRQ_ENTER();\n\tspin_lock(&lock_A);\t\t \n\tspin_unlock(&lock_A);\n\tHARDIRQ_EXIT()\n\n\tHARDIRQ_DISABLE();\n\tspin_lock(&lock_A);\n\tlocal_lock(&local_A);\t \n\tlocal_unlock(&local_A);\n\tspin_unlock(&lock_A);\n\tHARDIRQ_ENABLE();\n\n\tHARDIRQ_DISABLE();\n\tspin_lock(&lock_A);\n\tspin_lock(&lock_B);\t\t \n\tspin_unlock(&lock_B);\n\tspin_unlock(&lock_A);\n\tHARDIRQ_DISABLE();\n\n}\n\nstatic void local_lock_tests(void)\n{\n\tprintk(\"  --------------------------------------------------------------------------\\n\");\n\tprintk(\"  | local_lock tests |\\n\");\n\tprintk(\"  ---------------------\\n\");\n\n\tprint_testname(\"local_lock inversion  2\");\n\tdotest(local_lock_2, SUCCESS, LOCKTYPE_LL);\n\tpr_cont(\"\\n\");\n\n\tprint_testname(\"local_lock inversion 3A\");\n\tdotest(local_lock_3A, SUCCESS, LOCKTYPE_LL);\n\tpr_cont(\"\\n\");\n\n\tprint_testname(\"local_lock inversion 3B\");\n\tdotest(local_lock_3B, FAILURE, LOCKTYPE_LL);\n\tpr_cont(\"\\n\");\n}\n\nstatic void hardirq_deadlock_softirq_not_deadlock(void)\n{\n\t \n\t \n\tmutex_lock(&mutex_A);\n\tHARDIRQ_DISABLE();\n\tspin_lock(&lock_C);\n\tspin_unlock(&lock_C);\n\tHARDIRQ_ENABLE();\n\tmutex_unlock(&mutex_A);\n\n\t \n\tHARDIRQ_ENTER();\n\tspin_lock(&lock_A);\n\tspin_unlock(&lock_A);\n\tHARDIRQ_EXIT();\n\n\t \n\tHARDIRQ_DISABLE();\n\tspin_lock(&lock_A);\n\tspin_lock(&lock_B);\n\tspin_unlock(&lock_B);\n\tspin_unlock(&lock_A);\n\tHARDIRQ_ENABLE();\n\n\t \n\tHARDIRQ_DISABLE();\n\tspin_lock(&lock_B);\n\tspin_lock(&lock_C);\n\tspin_unlock(&lock_C);\n\tspin_unlock(&lock_B);\n\tHARDIRQ_ENABLE();\n\n\t \n\tSOFTIRQ_ENTER();\n\tspin_lock(&lock_D);\n\tspin_unlock(&lock_D);\n\tSOFTIRQ_EXIT();\n\n\t \n\tSOFTIRQ_DISABLE();\n\tspin_lock(&lock_D);\n\tspin_unlock(&lock_D);\n\tSOFTIRQ_ENABLE();\n\n\t \n\tHARDIRQ_DISABLE();\n\tspin_lock(&lock_C);\n\tspin_lock(&lock_D);\n\tspin_unlock(&lock_D);\n\tspin_unlock(&lock_C);\n\tHARDIRQ_ENABLE();\n}\n\nvoid locking_selftest(void)\n{\n\t \n\tif (!debug_locks) {\n\t\tprintk(\"----------------------------------\\n\");\n\t\tprintk(\"| Locking API testsuite disabled |\\n\");\n\t\tprintk(\"----------------------------------\\n\");\n\t\treturn;\n\t}\n\n\t \n\tforce_read_lock_recursive = 1;\n\n\t \n\tprintk(\"------------------------\\n\");\n\tprintk(\"| Locking API testsuite:\\n\");\n\tprintk(\"----------------------------------------------------------------------------\\n\");\n\tprintk(\"                                 | spin |wlock |rlock |mutex | wsem | rsem |rtmutex\\n\");\n\tprintk(\"  --------------------------------------------------------------------------\\n\");\n\n\tinit_shared_classes();\n\tlockdep_set_selftest_task(current);\n\n\tDO_TESTCASE_6R(\"A-A deadlock\", AA);\n\tDO_TESTCASE_6R(\"A-B-B-A deadlock\", ABBA);\n\tDO_TESTCASE_6R(\"A-B-B-C-C-A deadlock\", ABBCCA);\n\tDO_TESTCASE_6R(\"A-B-C-A-B-C deadlock\", ABCABC);\n\tDO_TESTCASE_6R(\"A-B-B-C-C-D-D-A deadlock\", ABBCCDDA);\n\tDO_TESTCASE_6R(\"A-B-C-D-B-D-D-A deadlock\", ABCDBDDA);\n\tDO_TESTCASE_6R(\"A-B-C-D-B-C-D-A deadlock\", ABCDBCDA);\n\tDO_TESTCASE_6(\"double unlock\", double_unlock);\n\tDO_TESTCASE_6(\"initialize held\", init_held);\n\n\tprintk(\"  --------------------------------------------------------------------------\\n\");\n\tprint_testname(\"recursive read-lock\");\n\tpr_cont(\"             |\");\n\tdotest(rlock_AA1, SUCCESS, LOCKTYPE_RWLOCK);\n\tpr_cont(\"             |\");\n\tdotest(rsem_AA1, FAILURE, LOCKTYPE_RWSEM);\n\tpr_cont(\"\\n\");\n\n\tprint_testname(\"recursive read-lock #2\");\n\tpr_cont(\"             |\");\n\tdotest(rlock_AA1B, SUCCESS, LOCKTYPE_RWLOCK);\n\tpr_cont(\"             |\");\n\tdotest(rsem_AA1B, FAILURE, LOCKTYPE_RWSEM);\n\tpr_cont(\"\\n\");\n\n\tprint_testname(\"mixed read-write-lock\");\n\tpr_cont(\"             |\");\n\tdotest(rlock_AA2, FAILURE, LOCKTYPE_RWLOCK);\n\tpr_cont(\"             |\");\n\tdotest(rsem_AA2, FAILURE, LOCKTYPE_RWSEM);\n\tpr_cont(\"\\n\");\n\n\tprint_testname(\"mixed write-read-lock\");\n\tpr_cont(\"             |\");\n\tdotest(rlock_AA3, FAILURE, LOCKTYPE_RWLOCK);\n\tpr_cont(\"             |\");\n\tdotest(rsem_AA3, FAILURE, LOCKTYPE_RWSEM);\n\tpr_cont(\"\\n\");\n\n\tprint_testname(\"mixed read-lock/lock-write ABBA\");\n\tpr_cont(\"             |\");\n\tdotest(rlock_ABBA1, FAILURE, LOCKTYPE_RWLOCK);\n\tpr_cont(\"             |\");\n\tdotest(rwsem_ABBA1, FAILURE, LOCKTYPE_RWSEM);\n\n\tprint_testname(\"mixed read-lock/lock-read ABBA\");\n\tpr_cont(\"             |\");\n\tdotest(rlock_ABBA2, SUCCESS, LOCKTYPE_RWLOCK);\n\tpr_cont(\"             |\");\n\tdotest(rwsem_ABBA2, FAILURE, LOCKTYPE_RWSEM);\n\n\tprint_testname(\"mixed write-lock/lock-write ABBA\");\n\tpr_cont(\"             |\");\n\tdotest(rlock_ABBA3, FAILURE, LOCKTYPE_RWLOCK);\n\tpr_cont(\"             |\");\n\tdotest(rwsem_ABBA3, FAILURE, LOCKTYPE_RWSEM);\n\n\tprint_testname(\"chain cached mixed R-L/L-W ABBA\");\n\tpr_cont(\"             |\");\n\tdotest(rlock_chaincache_ABBA1, FAILURE, LOCKTYPE_RWLOCK);\n\n\tDO_TESTCASE_6x1RRB(\"rlock W1R2/W2R3/W3R1\", W1R2_W2R3_W3R1);\n\tDO_TESTCASE_6x1RRB(\"rlock W1W2/R2R3/W3R1\", W1W2_R2R3_W3R1);\n\tDO_TESTCASE_6x1RR(\"rlock W1W2/R2R3/R3W1\", W1W2_R2R3_R3W1);\n\tDO_TESTCASE_6x1RR(\"rlock W1R2/R2R3/W3W1\", W1R2_R2R3_W3W1);\n\n\tprintk(\"  --------------------------------------------------------------------------\\n\");\n\t \n\tDO_TESTCASE_2x6(\"irqs-on + irq-safe-A\", irqsafe1);\n\tNON_RT(DO_TESTCASE_2x3(\"sirq-safe-A => hirqs-on\", irqsafe2A));\n\tDO_TESTCASE_2x6(\"safe-A + irqs-on\", irqsafe2B);\n\tDO_TESTCASE_6x6(\"safe-A + unsafe-B #1\", irqsafe3);\n\tDO_TESTCASE_6x6(\"safe-A + unsafe-B #2\", irqsafe4);\n\tDO_TESTCASE_6x6RW(\"irq lock-inversion\", irq_inversion);\n\n\tDO_TESTCASE_6x2x2RW(\"irq read-recursion\", irq_read_recursion);\n\tDO_TESTCASE_6x2x2RW(\"irq read-recursion #2\", irq_read_recursion2);\n\tDO_TESTCASE_6x2x2RW(\"irq read-recursion #3\", irq_read_recursion3);\n\n\tww_tests();\n\n\tforce_read_lock_recursive = 0;\n\t \n\tif (IS_ENABLED(CONFIG_QUEUED_RWLOCKS))\n\t\tqueued_read_lock_tests();\n\n\tfs_reclaim_tests();\n\n\t \n\tif (IS_ENABLED(CONFIG_PROVE_RAW_LOCK_NESTING))\n\t\twait_context_tests();\n\n\tlocal_lock_tests();\n\n\tprint_testname(\"hardirq_unsafe_softirq_safe\");\n\tdotest(hardirq_deadlock_softirq_not_deadlock, FAILURE, LOCKTYPE_SPECIAL);\n\tpr_cont(\"\\n\");\n\n\tif (unexpected_testcase_failures) {\n\t\tprintk(\"-----------------------------------------------------------------\\n\");\n\t\tdebug_locks = 0;\n\t\tprintk(\"BUG: %3d unexpected failures (out of %3d) - debugging disabled! |\\n\",\n\t\t\tunexpected_testcase_failures, testcase_total);\n\t\tprintk(\"-----------------------------------------------------------------\\n\");\n\t} else if (expected_testcase_failures && testcase_successes) {\n\t\tprintk(\"--------------------------------------------------------\\n\");\n\t\tprintk(\"%3d out of %3d testcases failed, as expected. |\\n\",\n\t\t\texpected_testcase_failures, testcase_total);\n\t\tprintk(\"----------------------------------------------------\\n\");\n\t\tdebug_locks = 1;\n\t} else if (expected_testcase_failures && !testcase_successes) {\n\t\tprintk(\"--------------------------------------------------------\\n\");\n\t\tprintk(\"All %3d testcases failed, as expected. |\\n\",\n\t\t\texpected_testcase_failures);\n\t\tprintk(\"----------------------------------------\\n\");\n\t\tdebug_locks = 1;\n\t} else {\n\t\tprintk(\"-------------------------------------------------------\\n\");\n\t\tprintk(\"Good, all %3d testcases passed! |\\n\",\n\t\t\ttestcase_successes);\n\t\tprintk(\"---------------------------------\\n\");\n\t\tdebug_locks = 1;\n\t}\n\tlockdep_set_selftest_task(NULL);\n\tdebug_locks_silent = 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}