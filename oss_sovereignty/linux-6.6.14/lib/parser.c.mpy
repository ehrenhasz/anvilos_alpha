{
  "module_name": "parser.c",
  "hash_id": "ea4a6b799ef6111847396a8e3b2aa8b4eb3dbc0c2fd49c4423321f95bf046b8e",
  "original_prompt": "Ingested from linux-6.6.14/lib/parser.c",
  "human_readable_source": "\n \n\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/export.h>\n#include <linux/kstrtox.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\n \n#define NUMBER_BUF_LEN 24\n\n \nstatic int match_one(char *s, const char *p, substring_t args[])\n{\n\tchar *meta;\n\tint argc = 0;\n\n\tif (!p)\n\t\treturn 1;\n\n\twhile(1) {\n\t\tint len = -1;\n\t\tmeta = strchr(p, '%');\n\t\tif (!meta)\n\t\t\treturn strcmp(p, s) == 0;\n\n\t\tif (strncmp(p, s, meta-p))\n\t\t\treturn 0;\n\n\t\ts += meta - p;\n\t\tp = meta + 1;\n\n\t\tif (isdigit(*p))\n\t\t\tlen = simple_strtoul(p, (char **) &p, 10);\n\t\telse if (*p == '%') {\n\t\t\tif (*s++ != '%')\n\t\t\t\treturn 0;\n\t\t\tp++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (argc >= MAX_OPT_ARGS)\n\t\t\treturn 0;\n\n\t\targs[argc].from = s;\n\t\tswitch (*p++) {\n\t\tcase 's': {\n\t\t\tsize_t str_len = strlen(s);\n\n\t\t\tif (str_len == 0)\n\t\t\t\treturn 0;\n\t\t\tif (len == -1 || len > str_len)\n\t\t\t\tlen = str_len;\n\t\t\targs[argc].to = s + len;\n\t\t\tbreak;\n\t\t}\n\t\tcase 'd':\n\t\t\tsimple_strtol(s, &args[argc].to, 0);\n\t\t\tgoto num;\n\t\tcase 'u':\n\t\t\tsimple_strtoul(s, &args[argc].to, 0);\n\t\t\tgoto num;\n\t\tcase 'o':\n\t\t\tsimple_strtoul(s, &args[argc].to, 8);\n\t\t\tgoto num;\n\t\tcase 'x':\n\t\t\tsimple_strtoul(s, &args[argc].to, 16);\n\t\tnum:\n\t\t\tif (args[argc].to == args[argc].from)\n\t\t\t\treturn 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\t\ts = args[argc].to;\n\t\targc++;\n\t}\n}\n\n \nint match_token(char *s, const match_table_t table, substring_t args[])\n{\n\tconst struct match_token *p;\n\n\tfor (p = table; !match_one(s, p->pattern, args) ; p++)\n\t\t;\n\n\treturn p->token;\n}\nEXPORT_SYMBOL(match_token);\n\n \nstatic int match_number(substring_t *s, int *result, int base)\n{\n\tchar *endp;\n\tchar buf[NUMBER_BUF_LEN];\n\tint ret;\n\tlong val;\n\n\tif (match_strlcpy(buf, s, NUMBER_BUF_LEN) >= NUMBER_BUF_LEN)\n\t\treturn -ERANGE;\n\tret = 0;\n\tval = simple_strtol(buf, &endp, base);\n\tif (endp == buf)\n\t\tret = -EINVAL;\n\telse if (val < (long)INT_MIN || val > (long)INT_MAX)\n\t\tret = -ERANGE;\n\telse\n\t\t*result = (int) val;\n\treturn ret;\n}\n\n \nstatic int match_u64int(substring_t *s, u64 *result, int base)\n{\n\tchar buf[NUMBER_BUF_LEN];\n\tint ret;\n\tu64 val;\n\n\tif (match_strlcpy(buf, s, NUMBER_BUF_LEN) >= NUMBER_BUF_LEN)\n\t\treturn -ERANGE;\n\tret = kstrtoull(buf, base, &val);\n\tif (!ret)\n\t\t*result = val;\n\treturn ret;\n}\n\n \nint match_int(substring_t *s, int *result)\n{\n\treturn match_number(s, result, 0);\n}\nEXPORT_SYMBOL(match_int);\n\n \nint match_uint(substring_t *s, unsigned int *result)\n{\n\tchar buf[NUMBER_BUF_LEN];\n\n\tif (match_strlcpy(buf, s, NUMBER_BUF_LEN) >= NUMBER_BUF_LEN)\n\t\treturn -ERANGE;\n\n\treturn kstrtouint(buf, 10, result);\n}\nEXPORT_SYMBOL(match_uint);\n\n \nint match_u64(substring_t *s, u64 *result)\n{\n\treturn match_u64int(s, result, 0);\n}\nEXPORT_SYMBOL(match_u64);\n\n \nint match_octal(substring_t *s, int *result)\n{\n\treturn match_number(s, result, 8);\n}\nEXPORT_SYMBOL(match_octal);\n\n \nint match_hex(substring_t *s, int *result)\n{\n\treturn match_number(s, result, 16);\n}\nEXPORT_SYMBOL(match_hex);\n\n \nbool match_wildcard(const char *pattern, const char *str)\n{\n\tconst char *s = str;\n\tconst char *p = pattern;\n\tbool star = false;\n\n\twhile (*s) {\n\t\tswitch (*p) {\n\t\tcase '?':\n\t\t\ts++;\n\t\t\tp++;\n\t\t\tbreak;\n\t\tcase '*':\n\t\t\tstar = true;\n\t\t\tstr = s;\n\t\t\tif (!*++p)\n\t\t\t\treturn true;\n\t\t\tpattern = p;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (*s == *p) {\n\t\t\t\ts++;\n\t\t\t\tp++;\n\t\t\t} else {\n\t\t\t\tif (!star)\n\t\t\t\t\treturn false;\n\t\t\t\tstr++;\n\t\t\t\ts = str;\n\t\t\t\tp = pattern;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (*p == '*')\n\t\t++p;\n\treturn !*p;\n}\nEXPORT_SYMBOL(match_wildcard);\n\n \nsize_t match_strlcpy(char *dest, const substring_t *src, size_t size)\n{\n\tsize_t ret = src->to - src->from;\n\n\tif (size) {\n\t\tsize_t len = ret >= size ? size - 1 : ret;\n\t\tmemcpy(dest, src->from, len);\n\t\tdest[len] = '\\0';\n\t}\n\treturn ret;\n}\nEXPORT_SYMBOL(match_strlcpy);\n\n \nchar *match_strdup(const substring_t *s)\n{\n\treturn kmemdup_nul(s->from, s->to - s->from, GFP_KERNEL);\n}\nEXPORT_SYMBOL(match_strdup);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}