{
  "module_name": "test_hash.c",
  "hash_id": "404a29b881b5c98ad5b89565388236d3f2ec79d2f15ab7fa099cd20a2d48a3db",
  "original_prompt": "Ingested from linux-6.6.14/lib/test_hash.c",
  "human_readable_source": "\n \n\n#include <linux/compiler.h>\n#include <linux/types.h>\n#include <linux/module.h>\n#include <linux/hash.h>\n#include <linux/stringhash.h>\n#include <kunit/test.h>\n\n \nstatic u32 __attribute_const__\nxorshift(u32 seed)\n{\n\tseed ^= seed << 13;\n\tseed ^= seed >> 17;\n\tseed ^= seed << 5;\n\treturn seed;\n}\n\n \nstatic u8 __attribute_const__\nmod255(u32 x)\n{\n\tx = (x & 0xffff) + (x >> 16);\t \n\tx = (x & 0xff) + (x >> 8);\t \n\tx = (x & 0xff) + (x >> 8);\t \n\tx = (x & 0xff) + (x >> 8);\t \n\treturn x;\n}\n\n \nstatic void fill_buf(char *buf, size_t len, u32 seed)\n{\n\tsize_t i;\n\n\tfor (i = 0; i < len; i++) {\n\t\tseed = xorshift(seed);\n\t\tbuf[i] = mod255(seed);\n\t}\n}\n\n \nstruct test_hash_params {\n         \n\tunsigned long long *h64;\n         \n\tu32 h0;\n         \n\tu32 h1;\n         \n\tu32 h2;\n         \n\tu32 (*hash_or)[33];\n};\n\n#ifdef HAVE_ARCH__HASH_32\nstatic void\ntest_int__hash_32(struct kunit *test, struct test_hash_params *params)\n{\n\tparams->hash_or[1][0] |= params->h2 = __hash_32_generic(params->h0);\n#if HAVE_ARCH__HASH_32 == 1\n\tKUNIT_EXPECT_EQ_MSG(test, params->h1, params->h2,\n\t\t\t    \"__hash_32(%#x) = %#x != __hash_32_generic() = %#x\",\n\t\t\t    params->h0, params->h1, params->h2);\n#endif\n}\n#endif\n\n#ifdef HAVE_ARCH_HASH_64\nstatic void\ntest_int_hash_64(struct kunit *test, struct test_hash_params *params, u32 const *m, int *k)\n{\n\tparams->h2 = hash_64_generic(*params->h64, *k);\n#if HAVE_ARCH_HASH_64 == 1\n\tKUNIT_EXPECT_EQ_MSG(test, params->h1, params->h2,\n\t\t\t    \"hash_64(%#llx, %d) = %#x != hash_64_generic() = %#x\",\n\t\t\t    *params->h64, *k, params->h1, params->h2);\n#else\n\tKUNIT_EXPECT_LE_MSG(test, params->h1, params->h2,\n\t\t\t    \"hash_64_generic(%#llx, %d) = %#x > %#x\",\n\t\t\t    *params->h64, *k, params->h1, *m);\n#endif\n}\n#endif\n\n \nstatic void\ntest_int_hash(struct kunit *test, unsigned long long h64, u32 hash_or[2][33])\n{\n\tint k;\n\tstruct test_hash_params params = { &h64, (u32)h64, 0, 0, hash_or };\n\n\t \n\thash_or[0][0] |= params.h1 = __hash_32(params.h0);\n#ifdef HAVE_ARCH__HASH_32\n\ttest_int__hash_32(test, &params);\n#endif\n\n\t \n\tfor (k = 1; k <= 32; k++) {\n\t\tu32 const m = ((u32)2 << (k-1)) - 1;\t \n\n\t\t \n\t\thash_or[0][k] |= params.h1 = hash_32(params.h0, k);\n\t\tKUNIT_EXPECT_LE_MSG(test, params.h1, m,\n\t\t\t\t    \"hash_32(%#x, %d) = %#x > %#x\",\n\t\t\t\t    params.h0, k, params.h1, m);\n\n\t\t \n\t\thash_or[1][k] |= params.h1 = hash_64(h64, k);\n\t\tKUNIT_EXPECT_LE_MSG(test, params.h1, m,\n\t\t\t\t    \"hash_64(%#llx, %d) = %#x > %#x\",\n\t\t\t\t    h64, k, params.h1, m);\n#ifdef HAVE_ARCH_HASH_64\n\t\ttest_int_hash_64(test, &params, &m, &k);\n#endif\n\t}\n}\n\n#define SIZE 256\t \n\nstatic void test_string_or(struct kunit *test)\n{\n\tchar buf[SIZE+1];\n\tu32 string_or = 0;\n\tint i, j;\n\n\tfill_buf(buf, SIZE, 1);\n\n\t \n\tfor (j = SIZE; j > 0; --j) {\n\t\tbuf[j] = '\\0';\n\n\t\tfor (i = 0; i <= j; i++) {\n\t\t\tu32 h0 = full_name_hash(buf+i, buf+i, j-i);\n\n\t\t\tstring_or |= h0;\n\t\t}  \n\t}  \n\n\t \n\tKUNIT_EXPECT_EQ_MSG(test, string_or, -1u,\n\t\t\t    \"OR of all string hash results = %#x != %#x\",\n\t\t\t    string_or, -1u);\n}\n\nstatic void test_hash_or(struct kunit *test)\n{\n\tchar buf[SIZE+1];\n\tu32 hash_or[2][33] = { { 0, } };\n\tunsigned long long h64 = 0;\n\tint i, j;\n\n\tfill_buf(buf, SIZE, 1);\n\n\t \n\tfor (j = SIZE; j > 0; --j) {\n\t\tbuf[j] = '\\0';\n\n\t\tfor (i = 0; i <= j; i++) {\n\t\t\tu64 hashlen = hashlen_string(buf+i, buf+i);\n\t\t\tu32 h0 = full_name_hash(buf+i, buf+i, j-i);\n\n\t\t\t \n\t\t\tKUNIT_EXPECT_EQ_MSG(test, hashlen_len(hashlen), j-i,\n\t\t\t\t\t    \"hashlen_string(%d..%d) returned length %u, expected %d\",\n\t\t\t\t\t    i, j, hashlen_len(hashlen), j-i);\n\t\t\t \n\t\t\tKUNIT_EXPECT_EQ_MSG(test, hashlen_hash(hashlen), h0,\n\t\t\t\t\t    \"hashlen_string(%d..%d) = %08x != full_name_hash() = %08x\",\n\t\t\t\t\t    i, j, hashlen_hash(hashlen), h0);\n\n\t\t\th64 = h64 << 32 | h0;\t \n\t\t\ttest_int_hash(test, h64, hash_or);\n\t\t}  \n\t}  \n\n\tKUNIT_EXPECT_EQ_MSG(test, hash_or[0][0], -1u,\n\t\t\t    \"OR of all __hash_32 results = %#x != %#x\",\n\t\t\t    hash_or[0][0], -1u);\n#ifdef HAVE_ARCH__HASH_32\n#if HAVE_ARCH__HASH_32 != 1\t \n\tKUNIT_EXPECT_EQ_MSG(test, hash_or[1][0], -1u,\n\t\t\t    \"OR of all __hash_32_generic results = %#x != %#x\",\n\t\t\t    hash_or[1][0], -1u);\n#endif\n#endif\n\n\t \n\tfor (i = 1; i <= 32; i++) {\n\t\tu32 const m = ((u32)2 << (i-1)) - 1;\t \n\n\t\tKUNIT_EXPECT_EQ_MSG(test, hash_or[0][i], m,\n\t\t\t\t    \"OR of all hash_32(%d) results = %#x (%#x expected)\",\n\t\t\t\t    i, hash_or[0][i], m);\n\t\tKUNIT_EXPECT_EQ_MSG(test, hash_or[1][i], m,\n\t\t\t\t    \"OR of all hash_64(%d) results = %#x (%#x expected)\",\n\t\t\t\t    i, hash_or[1][i], m);\n\t}\n}\n\nstatic struct kunit_case hash_test_cases[] __refdata = {\n\tKUNIT_CASE(test_string_or),\n\tKUNIT_CASE(test_hash_or),\n\t{}\n};\n\nstatic struct kunit_suite hash_test_suite = {\n\t.name = \"hash\",\n\t.test_cases = hash_test_cases,\n};\n\n\nkunit_test_suite(hash_test_suite);\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}