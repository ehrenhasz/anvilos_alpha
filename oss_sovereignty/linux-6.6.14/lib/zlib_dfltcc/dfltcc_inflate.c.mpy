{
  "module_name": "dfltcc_inflate.c",
  "hash_id": "a6b27817a80ea184450e0b8b742f99db06e9fde5d0318fe18faa00f527518f28",
  "original_prompt": "Ingested from linux-6.6.14/lib/zlib_dfltcc/dfltcc_inflate.c",
  "human_readable_source": "\n\n#include \"../zlib_inflate/inflate.h\"\n#include \"dfltcc_util.h\"\n#include \"dfltcc_inflate.h\"\n#include <asm/setup.h>\n#include <linux/export.h>\n#include <linux/zutil.h>\n\n \nint dfltcc_can_inflate(\n    z_streamp strm\n)\n{\n    struct inflate_state *state = (struct inflate_state *)strm->state;\n    struct dfltcc_state *dfltcc_state = GET_DFLTCC_STATE(state);\n\n     \n    if (zlib_dfltcc_support == ZLIB_DFLTCC_DISABLED ||\n            zlib_dfltcc_support == ZLIB_DFLTCC_DEFLATE_ONLY)\n        return 0;\n\n     \n    return is_bit_set(dfltcc_state->af.fns, DFLTCC_XPND) &&\n               is_bit_set(dfltcc_state->af.fmts, DFLTCC_FMT0);\n}\nEXPORT_SYMBOL(dfltcc_can_inflate);\n\nvoid dfltcc_reset_inflate_state(z_streamp strm) {\n    struct inflate_state *state = (struct inflate_state *)strm->state;\n    struct dfltcc_state *dfltcc_state = GET_DFLTCC_STATE(state);\n\n    dfltcc_reset_state(dfltcc_state);\n}\nEXPORT_SYMBOL(dfltcc_reset_inflate_state);\n\nstatic int dfltcc_was_inflate_used(\n    z_streamp strm\n)\n{\n    struct inflate_state *state = (struct inflate_state *)strm->state;\n    struct dfltcc_param_v0 *param = &GET_DFLTCC_STATE(state)->param;\n\n    return !param->nt;\n}\n\nstatic int dfltcc_inflate_disable(\n    z_streamp strm\n)\n{\n    struct inflate_state *state = (struct inflate_state *)strm->state;\n    struct dfltcc_state *dfltcc_state = GET_DFLTCC_STATE(state);\n\n    if (!dfltcc_can_inflate(strm))\n        return 0;\n    if (dfltcc_was_inflate_used(strm))\n         \n        return 1;\n     \n    memset(&dfltcc_state->af, 0, sizeof(dfltcc_state->af));\n    return 0;\n}\n\nstatic dfltcc_cc dfltcc_xpnd(\n    z_streamp strm\n)\n{\n    struct inflate_state *state = (struct inflate_state *)strm->state;\n    struct dfltcc_param_v0 *param = &GET_DFLTCC_STATE(state)->param;\n    size_t avail_in = strm->avail_in;\n    size_t avail_out = strm->avail_out;\n    dfltcc_cc cc;\n\n    cc = dfltcc(DFLTCC_XPND | HBT_CIRCULAR,\n                param, &strm->next_out, &avail_out,\n                &strm->next_in, &avail_in, state->window);\n    strm->avail_in = avail_in;\n    strm->avail_out = avail_out;\n    return cc;\n}\n\ndfltcc_inflate_action dfltcc_inflate(\n    z_streamp strm,\n    int flush,\n    int *ret\n)\n{\n    struct inflate_state *state = (struct inflate_state *)strm->state;\n    struct dfltcc_state *dfltcc_state = GET_DFLTCC_STATE(state);\n    struct dfltcc_param_v0 *param = &dfltcc_state->param;\n    dfltcc_cc cc;\n\n    if (flush == Z_BLOCK || flush == Z_PACKET_FLUSH) {\n         \n        if (dfltcc_inflate_disable(strm)) {\n            *ret = Z_STREAM_ERROR;\n            return DFLTCC_INFLATE_BREAK;\n        } else\n            return DFLTCC_INFLATE_SOFTWARE;\n    }\n\n    if (state->last) {\n        if (state->bits != 0) {\n            strm->next_in++;\n            strm->avail_in--;\n            state->bits = 0;\n        }\n        state->mode = CHECK;\n        return DFLTCC_INFLATE_CONTINUE;\n    }\n\n    if (strm->avail_in == 0 && !param->cf)\n        return DFLTCC_INFLATE_BREAK;\n\n    if (!state->window || state->wsize == 0) {\n        state->mode = MEM;\n        return DFLTCC_INFLATE_CONTINUE;\n    }\n\n     \n    param->cvt = CVT_ADLER32;\n    param->sbb = state->bits;\n    if (param->hl)\n        param->nt = 0;  \n    param->cv = state->check;\n\n     \n    do {\n        cc = dfltcc_xpnd(strm);\n    } while (cc == DFLTCC_CC_AGAIN);\n\n     \n    strm->msg = oesc_msg(dfltcc_state->msg, param->oesc);\n    state->last = cc == DFLTCC_CC_OK;\n    state->bits = param->sbb;\n    state->check = param->cv;\n    if (cc == DFLTCC_CC_OP2_CORRUPT && param->oesc != 0) {\n         \n        state->mode = BAD;\n        return DFLTCC_INFLATE_CONTINUE;\n    }\n    state->mode = TYPEDO;\n     \n    return (cc == DFLTCC_CC_OP1_TOO_SHORT || cc == DFLTCC_CC_OP2_TOO_SHORT) ?\n        DFLTCC_INFLATE_BREAK : DFLTCC_INFLATE_CONTINUE;\n}\nEXPORT_SYMBOL(dfltcc_inflate);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}