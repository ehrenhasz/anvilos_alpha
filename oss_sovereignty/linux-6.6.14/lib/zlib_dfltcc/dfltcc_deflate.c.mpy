{
  "module_name": "dfltcc_deflate.c",
  "hash_id": "a6963551b2325a5bbd9be90648f589adfc84399df61f512cb62c347f8e1fa3b9",
  "original_prompt": "Ingested from linux-6.6.14/lib/zlib_dfltcc/dfltcc_deflate.c",
  "human_readable_source": "\n\n#include \"../zlib_deflate/defutil.h\"\n#include \"dfltcc_util.h\"\n#include \"dfltcc_deflate.h\"\n#include <asm/setup.h>\n#include <linux/export.h>\n#include <linux/zutil.h>\n\n#define GET_DFLTCC_DEFLATE_STATE(state) ((struct dfltcc_deflate_state *)GET_DFLTCC_STATE(state))\n\n \nint dfltcc_can_deflate(\n    z_streamp strm\n)\n{\n    deflate_state *state = (deflate_state *)strm->state;\n    struct dfltcc_deflate_state *dfltcc_state = GET_DFLTCC_DEFLATE_STATE(state);\n\n     \n    if (zlib_dfltcc_support == ZLIB_DFLTCC_DISABLED ||\n            zlib_dfltcc_support == ZLIB_DFLTCC_INFLATE_ONLY)\n        return 0;\n\n     \n    if (!dfltcc_are_params_ok(state->level, state->w_bits, state->strategy,\n                              dfltcc_state->level_mask))\n        return 0;\n\n     \n    if (!is_bit_set(dfltcc_state->common.af.fns, DFLTCC_GDHT) ||\n            !is_bit_set(dfltcc_state->common.af.fns, DFLTCC_CMPR) ||\n            !is_bit_set(dfltcc_state->common.af.fmts, DFLTCC_FMT0))\n        return 0;\n\n    return 1;\n}\nEXPORT_SYMBOL(dfltcc_can_deflate);\n\nvoid dfltcc_reset_deflate_state(z_streamp strm) {\n    deflate_state *state = (deflate_state *)strm->state;\n    struct dfltcc_deflate_state *dfltcc_state = GET_DFLTCC_DEFLATE_STATE(state);\n\n    dfltcc_reset_state(&dfltcc_state->common);\n\n     \n    if (zlib_dfltcc_support == ZLIB_DFLTCC_FULL_DEBUG)\n        dfltcc_state->level_mask = DFLTCC_LEVEL_MASK_DEBUG;\n    else\n        dfltcc_state->level_mask = DFLTCC_LEVEL_MASK;\n    dfltcc_state->block_size = DFLTCC_BLOCK_SIZE;\n    dfltcc_state->block_threshold = DFLTCC_FIRST_FHT_BLOCK_SIZE;\n    dfltcc_state->dht_threshold = DFLTCC_DHT_MIN_SAMPLE_SIZE;\n}\nEXPORT_SYMBOL(dfltcc_reset_deflate_state);\n\nstatic void dfltcc_gdht(\n    z_streamp strm\n)\n{\n    deflate_state *state = (deflate_state *)strm->state;\n    struct dfltcc_param_v0 *param = &GET_DFLTCC_STATE(state)->param;\n    size_t avail_in = strm->avail_in;\n\n    dfltcc(DFLTCC_GDHT,\n           param, NULL, NULL,\n           &strm->next_in, &avail_in, NULL);\n}\n\nstatic dfltcc_cc dfltcc_cmpr(\n    z_streamp strm\n)\n{\n    deflate_state *state = (deflate_state *)strm->state;\n    struct dfltcc_param_v0 *param = &GET_DFLTCC_STATE(state)->param;\n    size_t avail_in = strm->avail_in;\n    size_t avail_out = strm->avail_out;\n    dfltcc_cc cc;\n\n    cc = dfltcc(DFLTCC_CMPR | HBT_CIRCULAR,\n                param, &strm->next_out, &avail_out,\n                &strm->next_in, &avail_in, state->window);\n    strm->total_in += (strm->avail_in - avail_in);\n    strm->total_out += (strm->avail_out - avail_out);\n    strm->avail_in = avail_in;\n    strm->avail_out = avail_out;\n    return cc;\n}\n\nstatic void send_eobs(\n    z_streamp strm,\n    const struct dfltcc_param_v0 *param\n)\n{\n    deflate_state *state = (deflate_state *)strm->state;\n\n    zlib_tr_send_bits(\n          state,\n          bi_reverse(param->eobs >> (15 - param->eobl), param->eobl),\n          param->eobl);\n    flush_pending(strm);\n    if (state->pending != 0) {\n         \n        memmove(state->pending_buf, state->pending_out, state->pending);\n        state->pending_out = state->pending_buf;\n    }\n#ifdef ZLIB_DEBUG\n    state->compressed_len += param->eobl;\n#endif\n}\n\nint dfltcc_deflate(\n    z_streamp strm,\n    int flush,\n    block_state *result\n)\n{\n    deflate_state *state = (deflate_state *)strm->state;\n    struct dfltcc_deflate_state *dfltcc_state = GET_DFLTCC_DEFLATE_STATE(state);\n    struct dfltcc_param_v0 *param = &dfltcc_state->common.param;\n    uInt masked_avail_in;\n    dfltcc_cc cc;\n    int need_empty_block;\n    int soft_bcc;\n    int no_flush;\n\n    if (!dfltcc_can_deflate(strm)) {\n         \n        if (flush == Z_FULL_FLUSH)\n            param->hl = 0;\n        return 0;\n    }\n\nagain:\n    masked_avail_in = 0;\n    soft_bcc = 0;\n    no_flush = flush == Z_NO_FLUSH;\n\n     \n    if (strm->avail_in == 0 && !param->cf) {\n         \n        if (!no_flush && param->bcf) {\n            send_eobs(strm, param);\n            param->bcf = 0;\n        }\n         \n        if (flush == Z_FINISH)\n            return 0;\n         \n        if (flush == Z_FULL_FLUSH)\n            param->hl = 0;\n         \n        *result = no_flush ? need_more : block_done;\n        return 1;\n    }\n\n     \n    if (param->bcf && no_flush &&\n            strm->total_in > dfltcc_state->block_threshold &&\n            strm->avail_in >= dfltcc_state->dht_threshold) {\n        if (param->cf) {\n             \n            masked_avail_in += strm->avail_in;\n            strm->avail_in = 0;\n            no_flush = 0;\n        } else {\n             \n            send_eobs(strm, param);\n            param->bcf = 0;\n            dfltcc_state->block_threshold =\n                strm->total_in + dfltcc_state->block_size;\n        }\n    }\n\n     \n    if (strm->avail_out == 0) {\n        *result = need_more;\n        return 1;\n    }\n\n     \n    if (no_flush && strm->avail_in > dfltcc_state->block_size) {\n        masked_avail_in += (strm->avail_in - dfltcc_state->block_size);\n        strm->avail_in = dfltcc_state->block_size;\n    }\n\n     \n    need_empty_block = flush == Z_FINISH && param->bcf && !param->bhf;\n\n     \n    param->cvt = CVT_ADLER32;\n    if (!no_flush)\n         \n        soft_bcc = 1;\n    if (flush == Z_FINISH && !param->bcf)\n         \n        param->bhf = 1;\n     \n    Assert(state->pending == 0, \"There must be no pending bytes\");\n    Assert(state->bi_valid < 8, \"There must be less than 8 pending bits\");\n    param->sbb = (unsigned int)state->bi_valid;\n    if (param->sbb > 0)\n        *strm->next_out = (Byte)state->bi_buf;\n     \n    param->nt = 0;\n    param->cv = strm->adler;\n\n     \n    if (!param->bcf) {\n        if (strm->total_in == 0 && dfltcc_state->block_threshold > 0) {\n            param->htt = HTT_FIXED;\n        }\n        else {\n            param->htt = HTT_DYNAMIC;\n            dfltcc_gdht(strm);\n        }\n    }\n\n     \n    do {\n        cc = dfltcc_cmpr(strm);\n        if (strm->avail_in < 4096 && masked_avail_in > 0)\n             \n            break;\n    } while (cc == DFLTCC_CC_AGAIN);\n\n     \n    strm->msg = oesc_msg(dfltcc_state->common.msg, param->oesc);\n    state->bi_valid = param->sbb;\n    if (state->bi_valid == 0)\n        state->bi_buf = 0;  \n    else\n        state->bi_buf = *strm->next_out & ((1 << state->bi_valid) - 1);\n    strm->adler = param->cv;\n\n     \n    strm->avail_in += masked_avail_in;\n    masked_avail_in = 0;\n\n     \n    Assert(cc != DFLTCC_CC_OP2_CORRUPT || param->oesc == 0, \"BUG\");\n\n     \n    if (cc == DFLTCC_CC_OK) {\n        if (soft_bcc) {\n            send_eobs(strm, param);\n            param->bcf = 0;\n            dfltcc_state->block_threshold =\n                strm->total_in + dfltcc_state->block_size;\n        } else\n            param->bcf = 1;\n        if (flush == Z_FINISH) {\n            if (need_empty_block)\n                 \n                return 0;\n            else {\n                bi_windup(state);\n                *result = finish_done;\n            }\n        } else {\n            if (flush == Z_FULL_FLUSH)\n                param->hl = 0;  \n            *result = flush == Z_NO_FLUSH ? need_more : block_done;\n        }\n    } else {\n        param->bcf = 1;\n        *result = need_more;\n    }\n    if (strm->avail_in != 0 && strm->avail_out != 0)\n        goto again;  \n    return 1;\n}\nEXPORT_SYMBOL(dfltcc_deflate);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}