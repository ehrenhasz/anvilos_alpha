{
  "module_name": "bug.c",
  "hash_id": "f8877972a17ad1e4e2ba71a2f5387a17620800245405c1738225b0d620aa19ce",
  "original_prompt": "Ingested from linux-6.6.14/lib/bug.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) fmt\n\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/rculist.h>\n#include <linux/ftrace.h>\n#include <linux/context_tracking.h>\n\nextern struct bug_entry __start___bug_table[], __stop___bug_table[];\n\nstatic inline unsigned long bug_addr(const struct bug_entry *bug)\n{\n#ifdef CONFIG_GENERIC_BUG_RELATIVE_POINTERS\n\treturn (unsigned long)&bug->bug_addr_disp + bug->bug_addr_disp;\n#else\n\treturn bug->bug_addr;\n#endif\n}\n\n#ifdef CONFIG_MODULES\n \nstatic LIST_HEAD(module_bug_list);\n\nstatic struct bug_entry *module_find_bug(unsigned long bugaddr)\n{\n\tstruct module *mod;\n\tstruct bug_entry *bug = NULL;\n\n\trcu_read_lock_sched();\n\tlist_for_each_entry_rcu(mod, &module_bug_list, bug_list) {\n\t\tunsigned i;\n\n\t\tbug = mod->bug_table;\n\t\tfor (i = 0; i < mod->num_bugs; ++i, ++bug)\n\t\t\tif (bugaddr == bug_addr(bug))\n\t\t\t\tgoto out;\n\t}\n\tbug = NULL;\nout:\n\trcu_read_unlock_sched();\n\n\treturn bug;\n}\n\nvoid module_bug_finalize(const Elf_Ehdr *hdr, const Elf_Shdr *sechdrs,\n\t\t\t struct module *mod)\n{\n\tchar *secstrings;\n\tunsigned int i;\n\n\tmod->bug_table = NULL;\n\tmod->num_bugs = 0;\n\n\t \n\tsecstrings = (char *)hdr + sechdrs[hdr->e_shstrndx].sh_offset;\n\tfor (i = 1; i < hdr->e_shnum; i++) {\n\t\tif (strcmp(secstrings+sechdrs[i].sh_name, \"__bug_table\"))\n\t\t\tcontinue;\n\t\tmod->bug_table = (void *) sechdrs[i].sh_addr;\n\t\tmod->num_bugs = sechdrs[i].sh_size / sizeof(struct bug_entry);\n\t\tbreak;\n\t}\n\n\t \n\tlist_add_rcu(&mod->bug_list, &module_bug_list);\n}\n\nvoid module_bug_cleanup(struct module *mod)\n{\n\tlist_del_rcu(&mod->bug_list);\n}\n\n#else\n\nstatic inline struct bug_entry *module_find_bug(unsigned long bugaddr)\n{\n\treturn NULL;\n}\n#endif\n\nvoid bug_get_file_line(struct bug_entry *bug, const char **file,\n\t\t       unsigned int *line)\n{\n#ifdef CONFIG_DEBUG_BUGVERBOSE\n#ifdef CONFIG_GENERIC_BUG_RELATIVE_POINTERS\n\t*file = (const char *)&bug->file_disp + bug->file_disp;\n#else\n\t*file = bug->file;\n#endif\n\t*line = bug->line;\n#else\n\t*file = NULL;\n\t*line = 0;\n#endif\n}\n\nstruct bug_entry *find_bug(unsigned long bugaddr)\n{\n\tstruct bug_entry *bug;\n\n\tfor (bug = __start___bug_table; bug < __stop___bug_table; ++bug)\n\t\tif (bugaddr == bug_addr(bug))\n\t\t\treturn bug;\n\n\treturn module_find_bug(bugaddr);\n}\n\nstatic enum bug_trap_type __report_bug(unsigned long bugaddr, struct pt_regs *regs)\n{\n\tstruct bug_entry *bug;\n\tconst char *file;\n\tunsigned line, warning, once, done;\n\n\tif (!is_valid_bugaddr(bugaddr))\n\t\treturn BUG_TRAP_TYPE_NONE;\n\n\tbug = find_bug(bugaddr);\n\tif (!bug)\n\t\treturn BUG_TRAP_TYPE_NONE;\n\n\tdisable_trace_on_warning();\n\n\tbug_get_file_line(bug, &file, &line);\n\n\twarning = (bug->flags & BUGFLAG_WARNING) != 0;\n\tonce = (bug->flags & BUGFLAG_ONCE) != 0;\n\tdone = (bug->flags & BUGFLAG_DONE) != 0;\n\n\tif (warning && once) {\n\t\tif (done)\n\t\t\treturn BUG_TRAP_TYPE_WARN;\n\n\t\t \n\t\tbug->flags |= BUGFLAG_DONE;\n\t}\n\n\t \n\tif ((bug->flags & BUGFLAG_NO_CUT_HERE) == 0)\n\t\tprintk(KERN_DEFAULT CUT_HERE);\n\n\tif (warning) {\n\t\t \n\t\t__warn(file, line, (void *)bugaddr, BUG_GET_TAINT(bug), regs,\n\t\t       NULL);\n\t\treturn BUG_TRAP_TYPE_WARN;\n\t}\n\n\tif (file)\n\t\tpr_crit(\"kernel BUG at %s:%u!\\n\", file, line);\n\telse\n\t\tpr_crit(\"Kernel BUG at %pB [verbose debug info unavailable]\\n\",\n\t\t\t(void *)bugaddr);\n\n\treturn BUG_TRAP_TYPE_BUG;\n}\n\nenum bug_trap_type report_bug(unsigned long bugaddr, struct pt_regs *regs)\n{\n\tenum bug_trap_type ret;\n\tbool rcu = false;\n\n\trcu = warn_rcu_enter();\n\tret = __report_bug(bugaddr, regs);\n\twarn_rcu_exit(rcu);\n\n\treturn ret;\n}\n\nstatic void clear_once_table(struct bug_entry *start, struct bug_entry *end)\n{\n\tstruct bug_entry *bug;\n\n\tfor (bug = start; bug < end; bug++)\n\t\tbug->flags &= ~BUGFLAG_DONE;\n}\n\nvoid generic_bug_clear_once(void)\n{\n#ifdef CONFIG_MODULES\n\tstruct module *mod;\n\n\trcu_read_lock_sched();\n\tlist_for_each_entry_rcu(mod, &module_bug_list, bug_list)\n\t\tclear_once_table(mod->bug_table,\n\t\t\t\t mod->bug_table + mod->num_bugs);\n\trcu_read_unlock_sched();\n#endif\n\n\tclear_once_table(__start___bug_table, __stop___bug_table);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}