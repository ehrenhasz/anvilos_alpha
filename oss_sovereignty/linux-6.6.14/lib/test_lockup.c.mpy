{
  "module_name": "test_lockup.c",
  "hash_id": "8dbf7d6459f4e48cac4866d7ebd3056f6cacdcec102608b45eae27d99af56d45",
  "original_prompt": "Ingested from linux-6.6.14/lib/test_lockup.c",
  "human_readable_source": "\n \n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/clock.h>\n#include <linux/cpu.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n\nstatic unsigned int time_secs;\nmodule_param(time_secs, uint, 0600);\nMODULE_PARM_DESC(time_secs, \"lockup time in seconds, default 0\");\n\nstatic unsigned int time_nsecs;\nmodule_param(time_nsecs, uint, 0600);\nMODULE_PARM_DESC(time_nsecs, \"nanoseconds part of lockup time, default 0\");\n\nstatic unsigned int cooldown_secs;\nmodule_param(cooldown_secs, uint, 0600);\nMODULE_PARM_DESC(cooldown_secs, \"cooldown time between iterations in seconds, default 0\");\n\nstatic unsigned int cooldown_nsecs;\nmodule_param(cooldown_nsecs, uint, 0600);\nMODULE_PARM_DESC(cooldown_nsecs, \"nanoseconds part of cooldown, default 0\");\n\nstatic unsigned int iterations = 1;\nmodule_param(iterations, uint, 0600);\nMODULE_PARM_DESC(iterations, \"lockup iterations, default 1\");\n\nstatic bool all_cpus;\nmodule_param(all_cpus, bool, 0400);\nMODULE_PARM_DESC(all_cpus, \"trigger lockup at all cpus at once\");\n\nstatic int wait_state;\nstatic char *state = \"R\";\nmodule_param(state, charp, 0400);\nMODULE_PARM_DESC(state, \"wait in 'R' running (default), 'D' uninterruptible, 'K' killable, 'S' interruptible state\");\n\nstatic bool use_hrtimer;\nmodule_param(use_hrtimer, bool, 0400);\nMODULE_PARM_DESC(use_hrtimer, \"use high-resolution timer for sleeping\");\n\nstatic bool iowait;\nmodule_param(iowait, bool, 0400);\nMODULE_PARM_DESC(iowait, \"account sleep time as iowait\");\n\nstatic bool lock_read;\nmodule_param(lock_read, bool, 0400);\nMODULE_PARM_DESC(lock_read, \"lock read-write locks for read\");\n\nstatic bool lock_single;\nmodule_param(lock_single, bool, 0400);\nMODULE_PARM_DESC(lock_single, \"acquire locks only at one cpu\");\n\nstatic bool reacquire_locks;\nmodule_param(reacquire_locks, bool, 0400);\nMODULE_PARM_DESC(reacquire_locks, \"release and reacquire locks/irq/preempt between iterations\");\n\nstatic bool touch_softlockup;\nmodule_param(touch_softlockup, bool, 0600);\nMODULE_PARM_DESC(touch_softlockup, \"touch soft-lockup watchdog between iterations\");\n\nstatic bool touch_hardlockup;\nmodule_param(touch_hardlockup, bool, 0600);\nMODULE_PARM_DESC(touch_hardlockup, \"touch hard-lockup watchdog between iterations\");\n\nstatic bool call_cond_resched;\nmodule_param(call_cond_resched, bool, 0600);\nMODULE_PARM_DESC(call_cond_resched, \"call cond_resched() between iterations\");\n\nstatic bool measure_lock_wait;\nmodule_param(measure_lock_wait, bool, 0400);\nMODULE_PARM_DESC(measure_lock_wait, \"measure lock wait time\");\n\nstatic unsigned long lock_wait_threshold = ULONG_MAX;\nmodule_param(lock_wait_threshold, ulong, 0400);\nMODULE_PARM_DESC(lock_wait_threshold, \"print lock wait time longer than this in nanoseconds, default off\");\n\nstatic bool test_disable_irq;\nmodule_param_named(disable_irq, test_disable_irq, bool, 0400);\nMODULE_PARM_DESC(disable_irq, \"disable interrupts: generate hard-lockups\");\n\nstatic bool disable_softirq;\nmodule_param(disable_softirq, bool, 0400);\nMODULE_PARM_DESC(disable_softirq, \"disable bottom-half irq handlers\");\n\nstatic bool disable_preempt;\nmodule_param(disable_preempt, bool, 0400);\nMODULE_PARM_DESC(disable_preempt, \"disable preemption: generate soft-lockups\");\n\nstatic bool lock_rcu;\nmodule_param(lock_rcu, bool, 0400);\nMODULE_PARM_DESC(lock_rcu, \"grab rcu_read_lock: generate rcu stalls\");\n\nstatic bool lock_mmap_sem;\nmodule_param(lock_mmap_sem, bool, 0400);\nMODULE_PARM_DESC(lock_mmap_sem, \"lock mm->mmap_lock: block procfs interfaces\");\n\nstatic unsigned long lock_rwsem_ptr;\nmodule_param_unsafe(lock_rwsem_ptr, ulong, 0400);\nMODULE_PARM_DESC(lock_rwsem_ptr, \"lock rw_semaphore at address\");\n\nstatic unsigned long lock_mutex_ptr;\nmodule_param_unsafe(lock_mutex_ptr, ulong, 0400);\nMODULE_PARM_DESC(lock_mutex_ptr, \"lock mutex at address\");\n\nstatic unsigned long lock_spinlock_ptr;\nmodule_param_unsafe(lock_spinlock_ptr, ulong, 0400);\nMODULE_PARM_DESC(lock_spinlock_ptr, \"lock spinlock at address\");\n\nstatic unsigned long lock_rwlock_ptr;\nmodule_param_unsafe(lock_rwlock_ptr, ulong, 0400);\nMODULE_PARM_DESC(lock_rwlock_ptr, \"lock rwlock at address\");\n\nstatic unsigned int alloc_pages_nr;\nmodule_param_unsafe(alloc_pages_nr, uint, 0600);\nMODULE_PARM_DESC(alloc_pages_nr, \"allocate and free pages under locks\");\n\nstatic unsigned int alloc_pages_order;\nmodule_param(alloc_pages_order, uint, 0400);\nMODULE_PARM_DESC(alloc_pages_order, \"page order to allocate\");\n\nstatic gfp_t alloc_pages_gfp = GFP_KERNEL;\nmodule_param_unsafe(alloc_pages_gfp, uint, 0400);\nMODULE_PARM_DESC(alloc_pages_gfp, \"allocate pages with this gfp_mask, default GFP_KERNEL\");\n\nstatic bool alloc_pages_atomic;\nmodule_param(alloc_pages_atomic, bool, 0400);\nMODULE_PARM_DESC(alloc_pages_atomic, \"allocate pages with GFP_ATOMIC\");\n\nstatic bool reallocate_pages;\nmodule_param(reallocate_pages, bool, 0400);\nMODULE_PARM_DESC(reallocate_pages, \"free and allocate pages between iterations\");\n\nstruct file *test_file;\nstatic struct inode *test_inode;\nstatic char test_file_path[256];\nmodule_param_string(file_path, test_file_path, sizeof(test_file_path), 0400);\nMODULE_PARM_DESC(file_path, \"file path to test\");\n\nstatic bool test_lock_inode;\nmodule_param_named(lock_inode, test_lock_inode, bool, 0400);\nMODULE_PARM_DESC(lock_inode, \"lock file -> inode -> i_rwsem\");\n\nstatic bool test_lock_mapping;\nmodule_param_named(lock_mapping, test_lock_mapping, bool, 0400);\nMODULE_PARM_DESC(lock_mapping, \"lock file -> mapping -> i_mmap_rwsem\");\n\nstatic bool test_lock_sb_umount;\nmodule_param_named(lock_sb_umount, test_lock_sb_umount, bool, 0400);\nMODULE_PARM_DESC(lock_sb_umount, \"lock file -> sb -> s_umount\");\n\nstatic atomic_t alloc_pages_failed = ATOMIC_INIT(0);\n\nstatic atomic64_t max_lock_wait = ATOMIC64_INIT(0);\n\nstatic struct task_struct *main_task;\nstatic int master_cpu;\n\nstatic void test_lock(bool master, bool verbose)\n{\n\tu64 wait_start;\n\n\tif (measure_lock_wait)\n\t\twait_start = local_clock();\n\n\tif (lock_mutex_ptr && master) {\n\t\tif (verbose)\n\t\t\tpr_notice(\"lock mutex %ps\\n\", (void *)lock_mutex_ptr);\n\t\tmutex_lock((struct mutex *)lock_mutex_ptr);\n\t}\n\n\tif (lock_rwsem_ptr && master) {\n\t\tif (verbose)\n\t\t\tpr_notice(\"lock rw_semaphore %ps\\n\",\n\t\t\t\t  (void *)lock_rwsem_ptr);\n\t\tif (lock_read)\n\t\t\tdown_read((struct rw_semaphore *)lock_rwsem_ptr);\n\t\telse\n\t\t\tdown_write((struct rw_semaphore *)lock_rwsem_ptr);\n\t}\n\n\tif (lock_mmap_sem && master) {\n\t\tif (verbose)\n\t\t\tpr_notice(\"lock mmap_lock pid=%d\\n\", main_task->pid);\n\t\tif (lock_read)\n\t\t\tmmap_read_lock(main_task->mm);\n\t\telse\n\t\t\tmmap_write_lock(main_task->mm);\n\t}\n\n\tif (test_disable_irq)\n\t\tlocal_irq_disable();\n\n\tif (disable_softirq)\n\t\tlocal_bh_disable();\n\n\tif (disable_preempt)\n\t\tpreempt_disable();\n\n\tif (lock_rcu)\n\t\trcu_read_lock();\n\n\tif (lock_spinlock_ptr && master) {\n\t\tif (verbose)\n\t\t\tpr_notice(\"lock spinlock %ps\\n\",\n\t\t\t\t  (void *)lock_spinlock_ptr);\n\t\tspin_lock((spinlock_t *)lock_spinlock_ptr);\n\t}\n\n\tif (lock_rwlock_ptr && master) {\n\t\tif (verbose)\n\t\t\tpr_notice(\"lock rwlock %ps\\n\",\n\t\t\t\t  (void *)lock_rwlock_ptr);\n\t\tif (lock_read)\n\t\t\tread_lock((rwlock_t *)lock_rwlock_ptr);\n\t\telse\n\t\t\twrite_lock((rwlock_t *)lock_rwlock_ptr);\n\t}\n\n\tif (measure_lock_wait) {\n\t\ts64 cur_wait = local_clock() - wait_start;\n\t\ts64 max_wait = atomic64_read(&max_lock_wait);\n\n\t\tdo {\n\t\t\tif (cur_wait < max_wait)\n\t\t\t\tbreak;\n\t\t\tmax_wait = atomic64_cmpxchg(&max_lock_wait,\n\t\t\t\t\t\t    max_wait, cur_wait);\n\t\t} while (max_wait != cur_wait);\n\n\t\tif (cur_wait > lock_wait_threshold)\n\t\t\tpr_notice_ratelimited(\"lock wait %lld ns\\n\", cur_wait);\n\t}\n}\n\nstatic void test_unlock(bool master, bool verbose)\n{\n\tif (lock_rwlock_ptr && master) {\n\t\tif (lock_read)\n\t\t\tread_unlock((rwlock_t *)lock_rwlock_ptr);\n\t\telse\n\t\t\twrite_unlock((rwlock_t *)lock_rwlock_ptr);\n\t\tif (verbose)\n\t\t\tpr_notice(\"unlock rwlock %ps\\n\",\n\t\t\t\t  (void *)lock_rwlock_ptr);\n\t}\n\n\tif (lock_spinlock_ptr && master) {\n\t\tspin_unlock((spinlock_t *)lock_spinlock_ptr);\n\t\tif (verbose)\n\t\t\tpr_notice(\"unlock spinlock %ps\\n\",\n\t\t\t\t  (void *)lock_spinlock_ptr);\n\t}\n\n\tif (lock_rcu)\n\t\trcu_read_unlock();\n\n\tif (disable_preempt)\n\t\tpreempt_enable();\n\n\tif (disable_softirq)\n\t\tlocal_bh_enable();\n\n\tif (test_disable_irq)\n\t\tlocal_irq_enable();\n\n\tif (lock_mmap_sem && master) {\n\t\tif (lock_read)\n\t\t\tmmap_read_unlock(main_task->mm);\n\t\telse\n\t\t\tmmap_write_unlock(main_task->mm);\n\t\tif (verbose)\n\t\t\tpr_notice(\"unlock mmap_lock pid=%d\\n\", main_task->pid);\n\t}\n\n\tif (lock_rwsem_ptr && master) {\n\t\tif (lock_read)\n\t\t\tup_read((struct rw_semaphore *)lock_rwsem_ptr);\n\t\telse\n\t\t\tup_write((struct rw_semaphore *)lock_rwsem_ptr);\n\t\tif (verbose)\n\t\t\tpr_notice(\"unlock rw_semaphore %ps\\n\",\n\t\t\t\t  (void *)lock_rwsem_ptr);\n\t}\n\n\tif (lock_mutex_ptr && master) {\n\t\tmutex_unlock((struct mutex *)lock_mutex_ptr);\n\t\tif (verbose)\n\t\t\tpr_notice(\"unlock mutex %ps\\n\",\n\t\t\t\t  (void *)lock_mutex_ptr);\n\t}\n}\n\nstatic void test_alloc_pages(struct list_head *pages)\n{\n\tstruct page *page;\n\tunsigned int i;\n\n\tfor (i = 0; i < alloc_pages_nr; i++) {\n\t\tpage = alloc_pages(alloc_pages_gfp, alloc_pages_order);\n\t\tif (!page) {\n\t\t\tatomic_inc(&alloc_pages_failed);\n\t\t\tbreak;\n\t\t}\n\t\tlist_add(&page->lru, pages);\n\t}\n}\n\nstatic void test_free_pages(struct list_head *pages)\n{\n\tstruct page *page, *next;\n\n\tlist_for_each_entry_safe(page, next, pages, lru)\n\t\t__free_pages(page, alloc_pages_order);\n\tINIT_LIST_HEAD(pages);\n}\n\nstatic void test_wait(unsigned int secs, unsigned int nsecs)\n{\n\tif (wait_state == TASK_RUNNING) {\n\t\tif (secs)\n\t\t\tmdelay(secs * MSEC_PER_SEC);\n\t\tif (nsecs)\n\t\t\tndelay(nsecs);\n\t\treturn;\n\t}\n\n\t__set_current_state(wait_state);\n\tif (use_hrtimer) {\n\t\tktime_t time;\n\n\t\ttime = ns_to_ktime((u64)secs * NSEC_PER_SEC + nsecs);\n\t\tschedule_hrtimeout(&time, HRTIMER_MODE_REL);\n\t} else {\n\t\tschedule_timeout(secs * HZ + nsecs_to_jiffies(nsecs));\n\t}\n}\n\nstatic void test_lockup(bool master)\n{\n\tu64 lockup_start = local_clock();\n\tunsigned int iter = 0;\n\tLIST_HEAD(pages);\n\n\tpr_notice(\"Start on CPU%d\\n\", raw_smp_processor_id());\n\n\ttest_lock(master, true);\n\n\ttest_alloc_pages(&pages);\n\n\twhile (iter++ < iterations && !signal_pending(main_task)) {\n\n\t\tif (iowait)\n\t\t\tcurrent->in_iowait = 1;\n\n\t\ttest_wait(time_secs, time_nsecs);\n\n\t\tif (iowait)\n\t\t\tcurrent->in_iowait = 0;\n\n\t\tif (reallocate_pages)\n\t\t\ttest_free_pages(&pages);\n\n\t\tif (reacquire_locks)\n\t\t\ttest_unlock(master, false);\n\n\t\tif (touch_softlockup)\n\t\t\ttouch_softlockup_watchdog();\n\n\t\tif (touch_hardlockup)\n\t\t\ttouch_nmi_watchdog();\n\n\t\tif (call_cond_resched)\n\t\t\tcond_resched();\n\n\t\ttest_wait(cooldown_secs, cooldown_nsecs);\n\n\t\tif (reacquire_locks)\n\t\t\ttest_lock(master, false);\n\n\t\tif (reallocate_pages)\n\t\t\ttest_alloc_pages(&pages);\n\t}\n\n\tpr_notice(\"Finish on CPU%d in %lld ns\\n\", raw_smp_processor_id(),\n\t\t  local_clock() - lockup_start);\n\n\ttest_free_pages(&pages);\n\n\ttest_unlock(master, true);\n}\n\nstatic DEFINE_PER_CPU(struct work_struct, test_works);\n\nstatic void test_work_fn(struct work_struct *work)\n{\n\ttest_lockup(!lock_single ||\n\t\t    work == per_cpu_ptr(&test_works, master_cpu));\n}\n\nstatic bool test_kernel_ptr(unsigned long addr, int size)\n{\n\tvoid *ptr = (void *)addr;\n\tchar buf;\n\n\tif (!addr)\n\t\treturn false;\n\n\t \n\tif (!IS_ENABLED(CONFIG_ALTERNATE_USER_ADDRESS_SPACE) &&\n\t    (access_ok((void __user *)ptr, 1) ||\n\t     access_ok((void __user *)ptr + size - 1, 1))) {\n\t\tpr_err(\"user space ptr invalid in kernel: %#lx\\n\", addr);\n\t\treturn true;\n\t}\n\n\tif (get_kernel_nofault(buf, ptr) ||\n\t    get_kernel_nofault(buf, ptr + size - 1)) {\n\t\tpr_err(\"invalid kernel ptr: %#lx\\n\", addr);\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic bool __maybe_unused test_magic(unsigned long addr, int offset,\n\t\t\t\t      unsigned int expected)\n{\n\tvoid *ptr = (void *)addr + offset;\n\tunsigned int magic = 0;\n\n\tif (!addr)\n\t\treturn false;\n\n\tif (get_kernel_nofault(magic, ptr) || magic != expected) {\n\t\tpr_err(\"invalid magic at %#lx + %#x = %#x, expected %#x\\n\",\n\t\t       addr, offset, magic, expected);\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic int __init test_lockup_init(void)\n{\n\tu64 test_start = local_clock();\n\n\tmain_task = current;\n\n\tswitch (state[0]) {\n\tcase 'S':\n\t\twait_state = TASK_INTERRUPTIBLE;\n\t\tbreak;\n\tcase 'D':\n\t\twait_state = TASK_UNINTERRUPTIBLE;\n\t\tbreak;\n\tcase 'K':\n\t\twait_state = TASK_KILLABLE;\n\t\tbreak;\n\tcase 'R':\n\t\twait_state = TASK_RUNNING;\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"unknown state=%s\\n\", state);\n\t\treturn -EINVAL;\n\t}\n\n\tif (alloc_pages_atomic)\n\t\talloc_pages_gfp = GFP_ATOMIC;\n\n\tif (test_kernel_ptr(lock_spinlock_ptr, sizeof(spinlock_t)) ||\n\t    test_kernel_ptr(lock_rwlock_ptr, sizeof(rwlock_t)) ||\n\t    test_kernel_ptr(lock_mutex_ptr, sizeof(struct mutex)) ||\n\t    test_kernel_ptr(lock_rwsem_ptr, sizeof(struct rw_semaphore)))\n\t\treturn -EINVAL;\n\n#ifdef CONFIG_DEBUG_SPINLOCK\n#ifdef CONFIG_PREEMPT_RT\n\tif (test_magic(lock_spinlock_ptr,\n\t\t       offsetof(spinlock_t, lock.wait_lock.magic),\n\t\t       SPINLOCK_MAGIC) ||\n\t    test_magic(lock_rwlock_ptr,\n\t\t       offsetof(rwlock_t, rwbase.rtmutex.wait_lock.magic),\n\t\t       SPINLOCK_MAGIC) ||\n\t    test_magic(lock_mutex_ptr,\n\t\t       offsetof(struct mutex, rtmutex.wait_lock.magic),\n\t\t       SPINLOCK_MAGIC) ||\n\t    test_magic(lock_rwsem_ptr,\n\t\t       offsetof(struct rw_semaphore, rwbase.rtmutex.wait_lock.magic),\n\t\t       SPINLOCK_MAGIC))\n\t\treturn -EINVAL;\n#else\n\tif (test_magic(lock_spinlock_ptr,\n\t\t       offsetof(spinlock_t, rlock.magic),\n\t\t       SPINLOCK_MAGIC) ||\n\t    test_magic(lock_rwlock_ptr,\n\t\t       offsetof(rwlock_t, magic),\n\t\t       RWLOCK_MAGIC) ||\n\t    test_magic(lock_mutex_ptr,\n\t\t       offsetof(struct mutex, wait_lock.magic),\n\t\t       SPINLOCK_MAGIC) ||\n\t    test_magic(lock_rwsem_ptr,\n\t\t       offsetof(struct rw_semaphore, wait_lock.magic),\n\t\t       SPINLOCK_MAGIC))\n\t\treturn -EINVAL;\n#endif\n#endif\n\n\tif ((wait_state != TASK_RUNNING ||\n\t     (call_cond_resched && !reacquire_locks) ||\n\t     (alloc_pages_nr && gfpflags_allow_blocking(alloc_pages_gfp))) &&\n\t    (test_disable_irq || disable_softirq || disable_preempt ||\n\t     lock_rcu || lock_spinlock_ptr || lock_rwlock_ptr)) {\n\t\tpr_err(\"refuse to sleep in atomic context\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (lock_mmap_sem && !main_task->mm) {\n\t\tpr_err(\"no mm to lock mmap_lock\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (test_file_path[0]) {\n\t\ttest_file = filp_open(test_file_path, O_RDONLY, 0);\n\t\tif (IS_ERR(test_file)) {\n\t\t\tpr_err(\"failed to open %s: %ld\\n\", test_file_path, PTR_ERR(test_file));\n\t\t\treturn PTR_ERR(test_file);\n\t\t}\n\t\ttest_inode = file_inode(test_file);\n\t} else if (test_lock_inode ||\n\t\t   test_lock_mapping ||\n\t\t   test_lock_sb_umount) {\n\t\tpr_err(\"no file to lock\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (test_lock_inode && test_inode)\n\t\tlock_rwsem_ptr = (unsigned long)&test_inode->i_rwsem;\n\n\tif (test_lock_mapping && test_file && test_file->f_mapping)\n\t\tlock_rwsem_ptr = (unsigned long)&test_file->f_mapping->i_mmap_rwsem;\n\n\tif (test_lock_sb_umount && test_inode)\n\t\tlock_rwsem_ptr = (unsigned long)&test_inode->i_sb->s_umount;\n\n\tpr_notice(\"START pid=%d time=%u +%u ns cooldown=%u +%u ns iterations=%u state=%s %s%s%s%s%s%s%s%s%s%s%s\\n\",\n\t\t  main_task->pid, time_secs, time_nsecs,\n\t\t  cooldown_secs, cooldown_nsecs, iterations, state,\n\t\t  all_cpus ? \"all_cpus \" : \"\",\n\t\t  iowait ? \"iowait \" : \"\",\n\t\t  test_disable_irq ? \"disable_irq \" : \"\",\n\t\t  disable_softirq ? \"disable_softirq \" : \"\",\n\t\t  disable_preempt ? \"disable_preempt \" : \"\",\n\t\t  lock_rcu ? \"lock_rcu \" : \"\",\n\t\t  lock_read ? \"lock_read \" : \"\",\n\t\t  touch_softlockup ? \"touch_softlockup \" : \"\",\n\t\t  touch_hardlockup ? \"touch_hardlockup \" : \"\",\n\t\t  call_cond_resched ? \"call_cond_resched \" : \"\",\n\t\t  reacquire_locks ? \"reacquire_locks \" : \"\");\n\n\tif (alloc_pages_nr)\n\t\tpr_notice(\"ALLOCATE PAGES nr=%u order=%u gfp=%pGg %s\\n\",\n\t\t\t  alloc_pages_nr, alloc_pages_order, &alloc_pages_gfp,\n\t\t\t  reallocate_pages ? \"reallocate_pages \" : \"\");\n\n\tif (all_cpus) {\n\t\tunsigned int cpu;\n\n\t\tcpus_read_lock();\n\n\t\tpreempt_disable();\n\t\tmaster_cpu = smp_processor_id();\n\t\tfor_each_online_cpu(cpu) {\n\t\t\tINIT_WORK(per_cpu_ptr(&test_works, cpu), test_work_fn);\n\t\t\tqueue_work_on(cpu, system_highpri_wq,\n\t\t\t\t      per_cpu_ptr(&test_works, cpu));\n\t\t}\n\t\tpreempt_enable();\n\n\t\tfor_each_online_cpu(cpu)\n\t\t\tflush_work(per_cpu_ptr(&test_works, cpu));\n\n\t\tcpus_read_unlock();\n\t} else {\n\t\ttest_lockup(true);\n\t}\n\n\tif (measure_lock_wait)\n\t\tpr_notice(\"Maximum lock wait: %lld ns\\n\",\n\t\t\t  atomic64_read(&max_lock_wait));\n\n\tif (alloc_pages_nr)\n\t\tpr_notice(\"Page allocation failed %u times\\n\",\n\t\t\t  atomic_read(&alloc_pages_failed));\n\n\tpr_notice(\"FINISH in %llu ns\\n\", local_clock() - test_start);\n\n\tif (test_file)\n\t\tfput(test_file);\n\n\tif (signal_pending(main_task))\n\t\treturn -EINTR;\n\n\treturn -EAGAIN;\n}\nmodule_init(test_lockup_init);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Konstantin Khlebnikov <khlebnikov@yandex-team.ru>\");\nMODULE_DESCRIPTION(\"Test module to generate lockups\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}