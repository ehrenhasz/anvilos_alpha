{
  "module_name": "decompress_inflate.c",
  "hash_id": "26a286b592bb40780e2f6fe65e169918c8daab80988e9543643eb0aed36e4376",
  "original_prompt": "Ingested from linux-6.6.14/lib/decompress_inflate.c",
  "human_readable_source": "\n#ifdef STATIC\n#define PREBOOT\n \n\n \n#define _LINUX_KERNEL_H\n\n#include \"zlib_inflate/inftrees.c\"\n#include \"zlib_inflate/inffast.c\"\n#include \"zlib_inflate/inflate.c\"\n#ifdef CONFIG_ZLIB_DFLTCC\n#include \"zlib_dfltcc/dfltcc.c\"\n#include \"zlib_dfltcc/dfltcc_inflate.c\"\n#endif\n\n#else  \n \n\n#include <linux/zutil.h>\n\n#include \"zlib_inflate/inftrees.h\"\n#include \"zlib_inflate/inffast.h\"\n#include \"zlib_inflate/inflate.h\"\n\n#include \"zlib_inflate/infutil.h\"\n#include <linux/decompress/inflate.h>\n\n#endif  \n\n#include <linux/decompress/mm.h>\n\n#define GZIP_IOBUF_SIZE (16*1024)\n\nstatic long INIT nofill(void *buffer, unsigned long len)\n{\n\treturn -1;\n}\n\n \nstatic int INIT __gunzip(unsigned char *buf, long len,\n\t\t       long (*fill)(void*, unsigned long),\n\t\t       long (*flush)(void*, unsigned long),\n\t\t       unsigned char *out_buf, long out_len,\n\t\t       long *pos,\n\t\t       void(*error)(char *x)) {\n\tu8 *zbuf;\n\tstruct z_stream_s *strm;\n\tint rc;\n\n\trc = -1;\n\tif (flush) {\n\t\tout_len = 0x8000;  \n\t\tout_buf = malloc(out_len);\n\t} else {\n\t\tif (!out_len)\n\t\t\tout_len = ((size_t)~0) - (size_t)out_buf;  \n\t}\n\tif (!out_buf) {\n\t\terror(\"Out of memory while allocating output buffer\");\n\t\tgoto gunzip_nomem1;\n\t}\n\n\tif (buf)\n\t\tzbuf = buf;\n\telse {\n\t\tzbuf = malloc(GZIP_IOBUF_SIZE);\n\t\tlen = 0;\n\t}\n\tif (!zbuf) {\n\t\terror(\"Out of memory while allocating input buffer\");\n\t\tgoto gunzip_nomem2;\n\t}\n\n\tstrm = malloc(sizeof(*strm));\n\tif (strm == NULL) {\n\t\terror(\"Out of memory while allocating z_stream\");\n\t\tgoto gunzip_nomem3;\n\t}\n\n\tstrm->workspace = malloc(flush ? zlib_inflate_workspacesize() :\n#ifdef CONFIG_ZLIB_DFLTCC\n\t \n\t\t\t\t zlib_inflate_workspacesize());\n#else\n\t\t\t\t sizeof(struct inflate_state));\n#endif\n\tif (strm->workspace == NULL) {\n\t\terror(\"Out of memory while allocating workspace\");\n\t\tgoto gunzip_nomem4;\n\t}\n\n\tif (!fill)\n\t\tfill = nofill;\n\n\tif (len == 0)\n\t\tlen = fill(zbuf, GZIP_IOBUF_SIZE);\n\n\t \n\tif (len < 10 ||\n\t   zbuf[0] != 0x1f || zbuf[1] != 0x8b || zbuf[2] != 0x08) {\n\t\tif (pos)\n\t\t\t*pos = 0;\n\t\terror(\"Not a gzip file\");\n\t\tgoto gunzip_5;\n\t}\n\n\t \n\tstrm->next_in = zbuf + 10;\n\tstrm->avail_in = len - 10;\n\t \n\tif (zbuf[3] & 0x8) {\n\t\tdo {\n\t\t\t \n\t\t\tif (strm->avail_in == 0) {\n\t\t\t\terror(\"header error\");\n\t\t\t\tgoto gunzip_5;\n\t\t\t}\n\t\t\t--strm->avail_in;\n\t\t} while (*strm->next_in++);\n\t}\n\n\tstrm->next_out = out_buf;\n\tstrm->avail_out = out_len;\n\n\trc = zlib_inflateInit2(strm, -MAX_WBITS);\n\n#ifdef CONFIG_ZLIB_DFLTCC\n\t \n#else\n\tif (!flush) {\n\t\tWS(strm)->inflate_state.wsize = 0;\n\t\tWS(strm)->inflate_state.window = NULL;\n\t}\n#endif\n\n\twhile (rc == Z_OK) {\n\t\tif (strm->avail_in == 0) {\n\t\t\t \n\t\t\tlen = fill(zbuf, GZIP_IOBUF_SIZE);\n\t\t\tif (len < 0) {\n\t\t\t\trc = -1;\n\t\t\t\terror(\"read error\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tstrm->next_in = zbuf;\n\t\t\tstrm->avail_in = len;\n\t\t}\n\t\trc = zlib_inflate(strm, 0);\n\n\t\t \n\t\tif (flush && strm->next_out > out_buf) {\n\t\t\tlong l = strm->next_out - out_buf;\n\t\t\tif (l != flush(out_buf, l)) {\n\t\t\t\trc = -1;\n\t\t\t\terror(\"write error\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tstrm->next_out = out_buf;\n\t\t\tstrm->avail_out = out_len;\n\t\t}\n\n\t\t \n\t\tif (rc == Z_STREAM_END) {\n\t\t\trc = 0;\n\t\t\tbreak;\n\t\t} else if (rc != Z_OK) {\n\t\t\terror(\"uncompression error\");\n\t\t\trc = -1;\n\t\t}\n\t}\n\n\tzlib_inflateEnd(strm);\n\tif (pos)\n\t\t \n\t\t*pos = strm->next_in - zbuf+8;\n\ngunzip_5:\n\tfree(strm->workspace);\ngunzip_nomem4:\n\tfree(strm);\ngunzip_nomem3:\n\tif (!buf)\n\t\tfree(zbuf);\ngunzip_nomem2:\n\tif (flush)\n\t\tfree(out_buf);\ngunzip_nomem1:\n\treturn rc;  \n}\n\n#ifndef PREBOOT\nSTATIC int INIT gunzip(unsigned char *buf, long len,\n\t\t       long (*fill)(void*, unsigned long),\n\t\t       long (*flush)(void*, unsigned long),\n\t\t       unsigned char *out_buf,\n\t\t       long *pos,\n\t\t       void (*error)(char *x))\n{\n\treturn __gunzip(buf, len, fill, flush, out_buf, 0, pos, error);\n}\n#else\nSTATIC int INIT __decompress(unsigned char *buf, long len,\n\t\t\t   long (*fill)(void*, unsigned long),\n\t\t\t   long (*flush)(void*, unsigned long),\n\t\t\t   unsigned char *out_buf, long out_len,\n\t\t\t   long *pos,\n\t\t\t   void (*error)(char *x))\n{\n\treturn __gunzip(buf, len, fill, flush, out_buf, out_len, pos, error);\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}