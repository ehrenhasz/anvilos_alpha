{
  "module_name": "logic_pio.c",
  "hash_id": "3ff25f2eadf495005eedd53f35cb32bca05934b32841e84910e71dcedea9d937",
  "original_prompt": "Ingested from linux-6.6.14/lib/logic_pio.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt)\t\"LOGIC PIO: \" fmt\n\n#include <linux/of.h>\n#include <linux/io.h>\n#include <linux/logic_pio.h>\n#include <linux/mm.h>\n#include <linux/rculist.h>\n#include <linux/sizes.h>\n#include <linux/slab.h>\n\n \nstatic LIST_HEAD(io_range_list);\nstatic DEFINE_MUTEX(io_range_mutex);\n\n \nint logic_pio_register_range(struct logic_pio_hwaddr *new_range)\n{\n\tstruct logic_pio_hwaddr *range;\n\tresource_size_t start;\n\tresource_size_t end;\n\tresource_size_t mmio_end = 0;\n\tresource_size_t iio_sz = MMIO_UPPER_LIMIT;\n\tint ret = 0;\n\n\tif (!new_range || !new_range->fwnode || !new_range->size ||\n\t    (new_range->flags == LOGIC_PIO_INDIRECT && !new_range->ops))\n\t\treturn -EINVAL;\n\n\tstart = new_range->hw_start;\n\tend = new_range->hw_start + new_range->size;\n\n\tmutex_lock(&io_range_mutex);\n\tlist_for_each_entry(range, &io_range_list, list) {\n\t\tif (range->fwnode == new_range->fwnode) {\n\t\t\t \n\t\t\tret = -EEXIST;\n\t\t\tgoto end_register;\n\t\t}\n\t\tif (range->flags == LOGIC_PIO_CPU_MMIO &&\n\t\t    new_range->flags == LOGIC_PIO_CPU_MMIO) {\n\t\t\t \n\t\t\tif (start >= range->hw_start + range->size ||\n\t\t\t    end < range->hw_start) {\n\t\t\t\tmmio_end = range->io_start + range->size;\n\t\t\t} else {\n\t\t\t\tret = -EFAULT;\n\t\t\t\tgoto end_register;\n\t\t\t}\n\t\t} else if (range->flags == LOGIC_PIO_INDIRECT &&\n\t\t\t   new_range->flags == LOGIC_PIO_INDIRECT) {\n\t\t\tiio_sz += range->size;\n\t\t}\n\t}\n\n\t \n\tif (new_range->flags == LOGIC_PIO_CPU_MMIO) {\n\t\tif (mmio_end + new_range->size - 1 > MMIO_UPPER_LIMIT) {\n\t\t\t \n\t\t\tif (mmio_end + SZ_64K - 1 > MMIO_UPPER_LIMIT) {\n\t\t\t\tret = -E2BIG;\n\t\t\t\tgoto end_register;\n\t\t\t}\n\t\t\tnew_range->size = SZ_64K;\n\t\t\tpr_warn(\"Requested IO range too big, new size set to 64K\\n\");\n\t\t}\n\t\tnew_range->io_start = mmio_end;\n\t} else if (new_range->flags == LOGIC_PIO_INDIRECT) {\n\t\tif (iio_sz + new_range->size - 1 > IO_SPACE_LIMIT) {\n\t\t\tret = -E2BIG;\n\t\t\tgoto end_register;\n\t\t}\n\t\tnew_range->io_start = iio_sz;\n\t} else {\n\t\t \n\t\tret = -EINVAL;\n\t\tgoto end_register;\n\t}\n\n\tlist_add_tail_rcu(&new_range->list, &io_range_list);\n\nend_register:\n\tmutex_unlock(&io_range_mutex);\n\treturn ret;\n}\n\n \nvoid logic_pio_unregister_range(struct logic_pio_hwaddr *range)\n{\n\tmutex_lock(&io_range_mutex);\n\tlist_del_rcu(&range->list);\n\tmutex_unlock(&io_range_mutex);\n\tsynchronize_rcu();\n}\n\n \nstruct logic_pio_hwaddr *find_io_range_by_fwnode(struct fwnode_handle *fwnode)\n{\n\tstruct logic_pio_hwaddr *range, *found_range = NULL;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(range, &io_range_list, list) {\n\t\tif (range->fwnode == fwnode) {\n\t\t\tfound_range = range;\n\t\t\tbreak;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\treturn found_range;\n}\n\n \nstatic struct logic_pio_hwaddr *find_io_range(unsigned long pio)\n{\n\tstruct logic_pio_hwaddr *range, *found_range = NULL;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(range, &io_range_list, list) {\n\t\tif (in_range(pio, range->io_start, range->size)) {\n\t\t\tfound_range = range;\n\t\t\tbreak;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\tif (!found_range)\n\t\tpr_err(\"PIO entry token 0x%lx invalid\\n\", pio);\n\n\treturn found_range;\n}\n\n \nresource_size_t logic_pio_to_hwaddr(unsigned long pio)\n{\n\tstruct logic_pio_hwaddr *range;\n\n\trange = find_io_range(pio);\n\tif (range)\n\t\treturn range->hw_start + pio - range->io_start;\n\n\treturn (resource_size_t)~0;\n}\n\n \nunsigned long logic_pio_trans_hwaddr(struct fwnode_handle *fwnode,\n\t\t\t\t     resource_size_t addr, resource_size_t size)\n{\n\tstruct logic_pio_hwaddr *range;\n\n\trange = find_io_range_by_fwnode(fwnode);\n\tif (!range || range->flags == LOGIC_PIO_CPU_MMIO) {\n\t\tpr_err(\"IO range not found or invalid\\n\");\n\t\treturn ~0UL;\n\t}\n\tif (range->size < size) {\n\t\tpr_err(\"resource size %pa cannot fit in IO range size %pa\\n\",\n\t\t       &size, &range->size);\n\t\treturn ~0UL;\n\t}\n\treturn addr - range->hw_start + range->io_start;\n}\n\nunsigned long logic_pio_trans_cpuaddr(resource_size_t addr)\n{\n\tstruct logic_pio_hwaddr *range;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(range, &io_range_list, list) {\n\t\tif (range->flags != LOGIC_PIO_CPU_MMIO)\n\t\t\tcontinue;\n\t\tif (in_range(addr, range->hw_start, range->size)) {\n\t\t\tunsigned long cpuaddr;\n\n\t\t\tcpuaddr = addr - range->hw_start + range->io_start;\n\n\t\t\trcu_read_unlock();\n\t\t\treturn cpuaddr;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\tpr_err(\"addr %pa not registered in io_range_list\\n\", &addr);\n\n\treturn ~0UL;\n}\n\n#if defined(CONFIG_INDIRECT_PIO) && defined(PCI_IOBASE)\n#define BUILD_LOGIC_IO(bwl, type)\t\t\t\t\t\\\ntype logic_in##bwl(unsigned long addr)\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\ttype ret = (type)~0;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tif (addr < MMIO_UPPER_LIMIT) {\t\t\t\t\t\\\n\t\tret = _in##bwl(addr);\t\t\t\t\t\\\n\t} else if (addr >= MMIO_UPPER_LIMIT && addr < IO_SPACE_LIMIT) { \\\n\t\tstruct logic_pio_hwaddr *entry = find_io_range(addr);\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t\tif (entry)\t\t\t\t\t\t\\\n\t\t\tret = entry->ops->in(entry->hostdata,\t\t\\\n\t\t\t\t\taddr, sizeof(type));\t\t\\\n\t\telse\t\t\t\t\t\t\t\\\n\t\t\tWARN_ON_ONCE(1);\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\treturn ret;\t\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\nvoid logic_out##bwl(type value, unsigned long addr)\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tif (addr < MMIO_UPPER_LIMIT) {\t\t\t\t\t\\\n\t\t_out##bwl(value, addr);\t\t\t\t\\\n\t} else if (addr >= MMIO_UPPER_LIMIT && addr < IO_SPACE_LIMIT) {\t\\\n\t\tstruct logic_pio_hwaddr *entry = find_io_range(addr);\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t\tif (entry)\t\t\t\t\t\t\\\n\t\t\tentry->ops->out(entry->hostdata,\t\t\\\n\t\t\t\t\taddr, value, sizeof(type));\t\\\n\t\telse\t\t\t\t\t\t\t\\\n\t\t\tWARN_ON_ONCE(1);\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\nvoid logic_ins##bwl(unsigned long addr, void *buffer,\t\t\t\\\n\t\t    unsigned int count)\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tif (addr < MMIO_UPPER_LIMIT) {\t\t\t\t\t\\\n\t\treads##bwl(PCI_IOBASE + addr, buffer, count);\t\t\\\n\t} else if (addr >= MMIO_UPPER_LIMIT && addr < IO_SPACE_LIMIT) {\t\\\n\t\tstruct logic_pio_hwaddr *entry = find_io_range(addr);\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t\tif (entry)\t\t\t\t\t\t\\\n\t\t\tentry->ops->ins(entry->hostdata,\t\t\\\n\t\t\t\taddr, buffer, sizeof(type), count);\t\\\n\t\telse\t\t\t\t\t\t\t\\\n\t\t\tWARN_ON_ONCE(1);\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\nvoid logic_outs##bwl(unsigned long addr, const void *buffer,\t\t\\\n\t\t     unsigned int count)\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tif (addr < MMIO_UPPER_LIMIT) {\t\t\t\t\t\\\n\t\twrites##bwl(PCI_IOBASE + addr, buffer, count);\t\t\\\n\t} else if (addr >= MMIO_UPPER_LIMIT && addr < IO_SPACE_LIMIT) {\t\\\n\t\tstruct logic_pio_hwaddr *entry = find_io_range(addr);\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t\tif (entry)\t\t\t\t\t\t\\\n\t\t\tentry->ops->outs(entry->hostdata,\t\t\\\n\t\t\t\taddr, buffer, sizeof(type), count);\t\\\n\t\telse\t\t\t\t\t\t\t\\\n\t\t\tWARN_ON_ONCE(1);\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n}\n\nBUILD_LOGIC_IO(b, u8)\nEXPORT_SYMBOL(logic_inb);\nEXPORT_SYMBOL(logic_insb);\nEXPORT_SYMBOL(logic_outb);\nEXPORT_SYMBOL(logic_outsb);\n\nBUILD_LOGIC_IO(w, u16)\nEXPORT_SYMBOL(logic_inw);\nEXPORT_SYMBOL(logic_insw);\nEXPORT_SYMBOL(logic_outw);\nEXPORT_SYMBOL(logic_outsw);\n\nBUILD_LOGIC_IO(l, u32)\nEXPORT_SYMBOL(logic_inl);\nEXPORT_SYMBOL(logic_insl);\nEXPORT_SYMBOL(logic_outl);\nEXPORT_SYMBOL(logic_outsl);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}