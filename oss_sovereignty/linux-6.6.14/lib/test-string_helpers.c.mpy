{
  "module_name": "test-string_helpers.c",
  "hash_id": "b2305665867ddc9a2a7ae7b77cfea320d1e9e582076cdf9b506912a459ab131d",
  "original_prompt": "Ingested from linux-6.6.14/lib/test-string_helpers.c",
  "human_readable_source": " \n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/random.h>\n#include <linux/string.h>\n#include <linux/string_helpers.h>\n\nstatic __init bool test_string_check_buf(const char *name, unsigned int flags,\n\t\t\t\t\t char *in, size_t p,\n\t\t\t\t\t char *out_real, size_t q_real,\n\t\t\t\t\t char *out_test, size_t q_test)\n{\n\tif (q_real == q_test && !memcmp(out_test, out_real, q_test))\n\t\treturn true;\n\n\tpr_warn(\"Test '%s' failed: flags = %#x\\n\", name, flags);\n\n\tprint_hex_dump(KERN_WARNING, \"Input: \", DUMP_PREFIX_NONE, 16, 1,\n\t\t       in, p, true);\n\tprint_hex_dump(KERN_WARNING, \"Expected: \", DUMP_PREFIX_NONE, 16, 1,\n\t\t       out_test, q_test, true);\n\tprint_hex_dump(KERN_WARNING, \"Got: \", DUMP_PREFIX_NONE, 16, 1,\n\t\t       out_real, q_real, true);\n\n\treturn false;\n}\n\nstruct test_string {\n\tconst char *in;\n\tconst char *out;\n\tunsigned int flags;\n};\n\nstatic const struct test_string strings[] __initconst = {\n\t{\n\t\t.in = \"\\\\f\\\\ \\\\n\\\\r\\\\t\\\\v\",\n\t\t.out = \"\\f\\\\ \\n\\r\\t\\v\",\n\t\t.flags = UNESCAPE_SPACE,\n\t},\n\t{\n\t\t.in = \"\\\\40\\\\1\\\\387\\\\0064\\\\05\\\\040\\\\8a\\\\110\\\\777\",\n\t\t.out = \" \\001\\00387\\0064\\005 \\\\8aH?7\",\n\t\t.flags = UNESCAPE_OCTAL,\n\t},\n\t{\n\t\t.in = \"\\\\xv\\\\xa\\\\x2c\\\\xD\\\\x6f2\",\n\t\t.out = \"\\\\xv\\n,\\ro2\",\n\t\t.flags = UNESCAPE_HEX,\n\t},\n\t{\n\t\t.in = \"\\\\h\\\\\\\\\\\\\\\"\\\\a\\\\e\\\\\",\n\t\t.out = \"\\\\h\\\\\\\"\\a\\e\\\\\",\n\t\t.flags = UNESCAPE_SPECIAL,\n\t},\n};\n\nstatic void __init test_string_unescape(const char *name, unsigned int flags,\n\t\t\t\t\tbool inplace)\n{\n\tint q_real = 256;\n\tchar *in = kmalloc(q_real, GFP_KERNEL);\n\tchar *out_test = kmalloc(q_real, GFP_KERNEL);\n\tchar *out_real = kmalloc(q_real, GFP_KERNEL);\n\tint i, p = 0, q_test = 0;\n\n\tif (!in || !out_test || !out_real)\n\t\tgoto out;\n\n\tfor (i = 0; i < ARRAY_SIZE(strings); i++) {\n\t\tconst char *s = strings[i].in;\n\t\tint len = strlen(strings[i].in);\n\n\t\t \n\t\tmemcpy(&in[p], s, len);\n\t\tp += len;\n\n\t\t \n\t\tif (flags & strings[i].flags) {\n\t\t\ts = strings[i].out;\n\t\t\tlen = strlen(strings[i].out);\n\t\t}\n\t\tmemcpy(&out_test[q_test], s, len);\n\t\tq_test += len;\n\t}\n\tin[p++] = '\\0';\n\n\t \n\tif (inplace) {\n\t\tmemcpy(out_real, in, p);\n\t\tif (flags == UNESCAPE_ANY)\n\t\t\tq_real = string_unescape_any_inplace(out_real);\n\t\telse\n\t\t\tq_real = string_unescape_inplace(out_real, flags);\n\t} else if (flags == UNESCAPE_ANY) {\n\t\tq_real = string_unescape_any(in, out_real, q_real);\n\t} else {\n\t\tq_real = string_unescape(in, out_real, q_real, flags);\n\t}\n\n\ttest_string_check_buf(name, flags, in, p - 1, out_real, q_real,\n\t\t\t      out_test, q_test);\nout:\n\tkfree(out_real);\n\tkfree(out_test);\n\tkfree(in);\n}\n\nstruct test_string_1 {\n\tconst char *out;\n\tunsigned int flags;\n};\n\n#define\tTEST_STRING_2_MAX_S1\t\t32\nstruct test_string_2 {\n\tconst char *in;\n\tstruct test_string_1 s1[TEST_STRING_2_MAX_S1];\n};\n\n#define\tTEST_STRING_2_DICT_0\t\tNULL\nstatic const struct test_string_2 escape0[] __initconst = {{\n\t.in = \"\\f\\\\ \\n\\r\\t\\v\",\n\t.s1 = {{\n\t\t.out = \"\\\\f\\\\ \\\\n\\\\r\\\\t\\\\v\",\n\t\t.flags = ESCAPE_SPACE,\n\t},{\n\t\t.out = \"\\\\f\\\\134\\\\040\\\\n\\\\r\\\\t\\\\v\",\n\t\t.flags = ESCAPE_SPACE | ESCAPE_OCTAL,\n\t},{\n\t\t.out = \"\\\\f\\\\x5c\\\\x20\\\\n\\\\r\\\\t\\\\v\",\n\t\t.flags = ESCAPE_SPACE | ESCAPE_HEX,\n\t},{\n\t\t \n\t}}\n},{\n\t.in = \"\\\\h\\\\\\\"\\a\\e\\\\\",\n\t.s1 = {{\n\t\t.out = \"\\\\\\\\h\\\\\\\\\\\\\\\"\\\\a\\\\e\\\\\\\\\",\n\t\t.flags = ESCAPE_SPECIAL,\n\t},{\n\t\t.out = \"\\\\\\\\\\\\150\\\\\\\\\\\\\\\"\\\\a\\\\e\\\\\\\\\",\n\t\t.flags = ESCAPE_SPECIAL | ESCAPE_OCTAL,\n\t},{\n\t\t.out = \"\\\\\\\\\\\\x68\\\\\\\\\\\\\\\"\\\\a\\\\e\\\\\\\\\",\n\t\t.flags = ESCAPE_SPECIAL | ESCAPE_HEX,\n\t},{\n\t\t \n\t}}\n},{\n\t.in = \"\\eb \\\\C\\007\\\"\\x90\\r]\",\n\t.s1 = {{\n\t\t.out = \"\\eb \\\\C\\007\\\"\\x90\\\\r]\",\n\t\t.flags = ESCAPE_SPACE,\n\t},{\n\t\t.out = \"\\\\eb \\\\\\\\C\\\\a\\\\\\\"\\x90\\r]\",\n\t\t.flags = ESCAPE_SPECIAL,\n\t},{\n\t\t.out = \"\\\\eb \\\\\\\\C\\\\a\\\\\\\"\\x90\\\\r]\",\n\t\t.flags = ESCAPE_SPACE | ESCAPE_SPECIAL,\n\t},{\n\t\t.out = \"\\\\033\\\\142\\\\040\\\\134\\\\103\\\\007\\\\042\\\\220\\\\015\\\\135\",\n\t\t.flags = ESCAPE_OCTAL,\n\t},{\n\t\t.out = \"\\\\033\\\\142\\\\040\\\\134\\\\103\\\\007\\\\042\\\\220\\\\r\\\\135\",\n\t\t.flags = ESCAPE_SPACE | ESCAPE_OCTAL,\n\t},{\n\t\t.out = \"\\\\e\\\\142\\\\040\\\\\\\\\\\\103\\\\a\\\\\\\"\\\\220\\\\015\\\\135\",\n\t\t.flags = ESCAPE_SPECIAL | ESCAPE_OCTAL,\n\t},{\n\t\t.out = \"\\\\e\\\\142\\\\040\\\\\\\\\\\\103\\\\a\\\\\\\"\\\\220\\\\r\\\\135\",\n\t\t.flags = ESCAPE_SPACE | ESCAPE_SPECIAL | ESCAPE_OCTAL,\n\t},{\n\t\t.out = \"\\eb \\\\C\\007\\\"\\x90\\r]\",\n\t\t.flags = ESCAPE_NP,\n\t},{\n\t\t.out = \"\\eb \\\\C\\007\\\"\\x90\\\\r]\",\n\t\t.flags = ESCAPE_SPACE | ESCAPE_NP,\n\t},{\n\t\t.out = \"\\\\eb \\\\C\\\\a\\\"\\x90\\r]\",\n\t\t.flags = ESCAPE_SPECIAL | ESCAPE_NP,\n\t},{\n\t\t.out = \"\\\\eb \\\\C\\\\a\\\"\\x90\\\\r]\",\n\t\t.flags = ESCAPE_SPACE | ESCAPE_SPECIAL | ESCAPE_NP,\n\t},{\n\t\t.out = \"\\\\033b \\\\C\\\\007\\\"\\\\220\\\\015]\",\n\t\t.flags = ESCAPE_OCTAL | ESCAPE_NP,\n\t},{\n\t\t.out = \"\\\\033b \\\\C\\\\007\\\"\\\\220\\\\r]\",\n\t\t.flags = ESCAPE_SPACE | ESCAPE_OCTAL | ESCAPE_NP,\n\t},{\n\t\t.out = \"\\\\eb \\\\C\\\\a\\\"\\\\220\\\\r]\",\n\t\t.flags = ESCAPE_SPECIAL | ESCAPE_SPACE | ESCAPE_OCTAL |\n\t\t\t ESCAPE_NP,\n\t},{\n\t\t.out = \"\\\\x1bb \\\\C\\\\x07\\\"\\\\x90\\\\x0d]\",\n\t\t.flags = ESCAPE_NP | ESCAPE_HEX,\n\t},{\n\t\t \n\t}}\n},{\n\t.in = \"\\007 \\eb\\\"\\x90\\xCF\\r\",\n\t.s1 = {{\n\t\t.out = \"\\007 \\eb\\\"\\\\220\\\\317\\r\",\n\t\t.flags = ESCAPE_OCTAL | ESCAPE_NA,\n\t},{\n\t\t.out = \"\\007 \\eb\\\"\\\\x90\\\\xcf\\r\",\n\t\t.flags = ESCAPE_HEX | ESCAPE_NA,\n\t},{\n\t\t.out = \"\\007 \\eb\\\"\\x90\\xCF\\r\",\n\t\t.flags = ESCAPE_NA,\n\t},{\n\t\t \n\t}}\n},{\n\t \n}};\n\n#define\tTEST_STRING_2_DICT_1\t\t\"b\\\\ \\t\\r\\xCF\"\nstatic const struct test_string_2 escape1[] __initconst = {{\n\t.in = \"\\f\\\\ \\n\\r\\t\\v\",\n\t.s1 = {{\n\t\t.out = \"\\f\\\\134\\\\040\\n\\\\015\\\\011\\v\",\n\t\t.flags = ESCAPE_OCTAL,\n\t},{\n\t\t.out = \"\\f\\\\x5c\\\\x20\\n\\\\x0d\\\\x09\\v\",\n\t\t.flags = ESCAPE_HEX,\n\t},{\n\t\t.out = \"\\f\\\\134\\\\040\\n\\\\015\\\\011\\v\",\n\t\t.flags = ESCAPE_ANY | ESCAPE_APPEND,\n\t},{\n\t\t.out = \"\\\\014\\\\134\\\\040\\\\012\\\\015\\\\011\\\\013\",\n\t\t.flags = ESCAPE_OCTAL | ESCAPE_APPEND | ESCAPE_NAP,\n\t},{\n\t\t.out = \"\\\\x0c\\\\x5c\\\\x20\\\\x0a\\\\x0d\\\\x09\\\\x0b\",\n\t\t.flags = ESCAPE_HEX | ESCAPE_APPEND | ESCAPE_NAP,\n\t},{\n\t\t.out = \"\\f\\\\134\\\\040\\n\\\\015\\\\011\\v\",\n\t\t.flags = ESCAPE_OCTAL | ESCAPE_APPEND | ESCAPE_NA,\n\t},{\n\t\t.out = \"\\f\\\\x5c\\\\x20\\n\\\\x0d\\\\x09\\v\",\n\t\t.flags = ESCAPE_HEX | ESCAPE_APPEND | ESCAPE_NA,\n\t},{\n\t\t \n\t}}\n},{\n\t.in = \"\\\\h\\\\\\\"\\a\\xCF\\e\\\\\",\n\t.s1 = {{\n\t\t.out = \"\\\\134h\\\\134\\\"\\a\\\\317\\e\\\\134\",\n\t\t.flags = ESCAPE_OCTAL,\n\t},{\n\t\t.out = \"\\\\134h\\\\134\\\"\\a\\\\317\\e\\\\134\",\n\t\t.flags = ESCAPE_ANY | ESCAPE_APPEND,\n\t},{\n\t\t.out = \"\\\\134h\\\\134\\\"\\\\007\\\\317\\\\033\\\\134\",\n\t\t.flags = ESCAPE_OCTAL | ESCAPE_APPEND | ESCAPE_NAP,\n\t},{\n\t\t.out = \"\\\\134h\\\\134\\\"\\a\\\\317\\e\\\\134\",\n\t\t.flags = ESCAPE_OCTAL | ESCAPE_APPEND | ESCAPE_NA,\n\t},{\n\t\t \n\t}}\n},{\n\t.in = \"\\eb \\\\C\\007\\\"\\x90\\r]\",\n\t.s1 = {{\n\t\t.out = \"\\e\\\\142\\\\040\\\\134C\\007\\\"\\x90\\\\015]\",\n\t\t.flags = ESCAPE_OCTAL,\n\t},{\n\t\t \n\t}}\n},{\n\t.in = \"\\007 \\eb\\\"\\x90\\xCF\\r\",\n\t.s1 = {{\n\t\t.out = \"\\007 \\eb\\\"\\x90\\xCF\\r\",\n\t\t.flags = ESCAPE_NA,\n\t},{\n\t\t.out = \"\\007 \\eb\\\"\\x90\\xCF\\r\",\n\t\t.flags = ESCAPE_SPACE | ESCAPE_NA,\n\t},{\n\t\t.out = \"\\007 \\eb\\\"\\x90\\xCF\\r\",\n\t\t.flags = ESCAPE_SPECIAL | ESCAPE_NA,\n\t},{\n\t\t.out = \"\\007 \\eb\\\"\\x90\\xCF\\r\",\n\t\t.flags = ESCAPE_SPACE | ESCAPE_SPECIAL | ESCAPE_NA,\n\t},{\n\t\t.out = \"\\007 \\eb\\\"\\x90\\\\317\\r\",\n\t\t.flags = ESCAPE_OCTAL | ESCAPE_NA,\n\t},{\n\t\t.out = \"\\007 \\eb\\\"\\x90\\\\317\\r\",\n\t\t.flags = ESCAPE_SPACE | ESCAPE_OCTAL | ESCAPE_NA,\n\t},{\n\t\t.out = \"\\007 \\eb\\\"\\x90\\\\317\\r\",\n\t\t.flags = ESCAPE_SPECIAL | ESCAPE_OCTAL | ESCAPE_NA,\n\t},{\n\t\t.out = \"\\007 \\eb\\\"\\x90\\\\317\\r\",\n\t\t.flags = ESCAPE_ANY | ESCAPE_NA,\n\t},{\n\t\t.out = \"\\007 \\eb\\\"\\x90\\\\xcf\\r\",\n\t\t.flags = ESCAPE_HEX | ESCAPE_NA,\n\t},{\n\t\t.out = \"\\007 \\eb\\\"\\x90\\\\xcf\\r\",\n\t\t.flags = ESCAPE_SPACE | ESCAPE_HEX | ESCAPE_NA,\n\t},{\n\t\t.out = \"\\007 \\eb\\\"\\x90\\\\xcf\\r\",\n\t\t.flags = ESCAPE_SPECIAL | ESCAPE_HEX | ESCAPE_NA,\n\t},{\n\t\t.out = \"\\007 \\eb\\\"\\x90\\\\xcf\\r\",\n\t\t.flags = ESCAPE_SPACE | ESCAPE_SPECIAL | ESCAPE_HEX | ESCAPE_NA,\n\t},{\n\t\t \n\t}}\n},{\n\t.in = \"\\007 \\eb\\\"\\x90\\xCF\\r\",\n\t.s1 = {{\n\t\t.out = \"\\007 \\eb\\\"\\x90\\xCF\\r\",\n\t\t.flags = ESCAPE_NAP,\n\t},{\n\t\t.out = \"\\007 \\eb\\\"\\x90\\xCF\\\\r\",\n\t\t.flags = ESCAPE_SPACE | ESCAPE_NAP,\n\t},{\n\t\t.out = \"\\007 \\eb\\\"\\x90\\xCF\\r\",\n\t\t.flags = ESCAPE_SPECIAL | ESCAPE_NAP,\n\t},{\n\t\t.out = \"\\007 \\eb\\\"\\x90\\xCF\\\\r\",\n\t\t.flags = ESCAPE_SPACE | ESCAPE_SPECIAL | ESCAPE_NAP,\n\t},{\n\t\t.out = \"\\007 \\eb\\\"\\x90\\\\317\\\\015\",\n\t\t.flags = ESCAPE_OCTAL | ESCAPE_NAP,\n\t},{\n\t\t.out = \"\\007 \\eb\\\"\\x90\\\\317\\\\r\",\n\t\t.flags = ESCAPE_SPACE | ESCAPE_OCTAL | ESCAPE_NAP,\n\t},{\n\t\t.out = \"\\007 \\eb\\\"\\x90\\\\317\\\\015\",\n\t\t.flags = ESCAPE_SPECIAL | ESCAPE_OCTAL | ESCAPE_NAP,\n\t},{\n\t\t.out = \"\\007 \\eb\\\"\\x90\\\\317\\r\",\n\t\t.flags = ESCAPE_ANY | ESCAPE_NAP,\n\t},{\n\t\t.out = \"\\007 \\eb\\\"\\x90\\\\xcf\\\\x0d\",\n\t\t.flags = ESCAPE_HEX | ESCAPE_NAP,\n\t},{\n\t\t.out = \"\\007 \\eb\\\"\\x90\\\\xcf\\\\r\",\n\t\t.flags = ESCAPE_SPACE | ESCAPE_HEX | ESCAPE_NAP,\n\t},{\n\t\t.out = \"\\007 \\eb\\\"\\x90\\\\xcf\\\\x0d\",\n\t\t.flags = ESCAPE_SPECIAL | ESCAPE_HEX | ESCAPE_NAP,\n\t},{\n\t\t.out = \"\\007 \\eb\\\"\\x90\\\\xcf\\\\r\",\n\t\t.flags = ESCAPE_SPACE | ESCAPE_SPECIAL | ESCAPE_HEX | ESCAPE_NAP,\n\t},{\n\t\t \n\t}}\n},{\n\t \n}};\n\nstatic const struct test_string strings_upper[] __initconst = {\n\t{\n\t\t.in = \"abcdefgh1234567890test\",\n\t\t.out = \"ABCDEFGH1234567890TEST\",\n\t},\n\t{\n\t\t.in = \"abCdeFgH1234567890TesT\",\n\t\t.out = \"ABCDEFGH1234567890TEST\",\n\t},\n};\n\nstatic const struct test_string strings_lower[] __initconst = {\n\t{\n\t\t.in = \"ABCDEFGH1234567890TEST\",\n\t\t.out = \"abcdefgh1234567890test\",\n\t},\n\t{\n\t\t.in = \"abCdeFgH1234567890TesT\",\n\t\t.out = \"abcdefgh1234567890test\",\n\t},\n};\n\nstatic __init const char *test_string_find_match(const struct test_string_2 *s2,\n\t\t\t\t\t\t unsigned int flags)\n{\n\tconst struct test_string_1 *s1 = s2->s1;\n\tunsigned int i;\n\n\tif (!flags)\n\t\treturn s2->in;\n\n\t \n\tflags &= ~ESCAPE_NULL;\n\n\t \n\tif (flags & ESCAPE_OCTAL)\n\t\tflags &= ~ESCAPE_HEX;\n\n\tfor (i = 0; i < TEST_STRING_2_MAX_S1 && s1->out; i++, s1++)\n\t\tif (s1->flags == flags)\n\t\t\treturn s1->out;\n\treturn NULL;\n}\n\nstatic __init void\ntest_string_escape_overflow(const char *in, int p, unsigned int flags, const char *esc,\n\t\t\t    int q_test, const char *name)\n{\n\tint q_real;\n\n\tq_real = string_escape_mem(in, p, NULL, 0, flags, esc);\n\tif (q_real != q_test)\n\t\tpr_warn(\"Test '%s' failed: flags = %#x, osz = 0, expected %d, got %d\\n\",\n\t\t\tname, flags, q_test, q_real);\n}\n\nstatic __init void test_string_escape(const char *name,\n\t\t\t\t      const struct test_string_2 *s2,\n\t\t\t\t      unsigned int flags, const char *esc)\n{\n\tsize_t out_size = 512;\n\tchar *out_test = kmalloc(out_size, GFP_KERNEL);\n\tchar *out_real = kmalloc(out_size, GFP_KERNEL);\n\tchar *in = kmalloc(256, GFP_KERNEL);\n\tint p = 0, q_test = 0;\n\tint q_real;\n\n\tif (!out_test || !out_real || !in)\n\t\tgoto out;\n\n\tfor (; s2->in; s2++) {\n\t\tconst char *out;\n\t\tint len;\n\n\t\t \n\t\tif (flags & ESCAPE_NULL) {\n\t\t\tin[p++] = '\\0';\n\t\t\t \n\t\t\tif (flags & ESCAPE_NA && !(flags & ESCAPE_APPEND && esc)) {\n\t\t\t\tout_test[q_test++] = '\\0';\n\t\t\t} else {\n\t\t\t\tout_test[q_test++] = '\\\\';\n\t\t\t\tout_test[q_test++] = '0';\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tout = test_string_find_match(s2, flags);\n\t\tif (!out)\n\t\t\tcontinue;\n\n\t\t \n\t\tlen = strlen(s2->in);\n\t\tmemcpy(&in[p], s2->in, len);\n\t\tp += len;\n\n\t\t \n\t\tlen = strlen(out);\n\t\tmemcpy(&out_test[q_test], out, len);\n\t\tq_test += len;\n\t}\n\n\tq_real = string_escape_mem(in, p, out_real, out_size, flags, esc);\n\n\ttest_string_check_buf(name, flags, in, p, out_real, q_real, out_test,\n\t\t\t      q_test);\n\n\ttest_string_escape_overflow(in, p, flags, esc, q_test, name);\n\nout:\n\tkfree(in);\n\tkfree(out_real);\n\tkfree(out_test);\n}\n\n#define string_get_size_maxbuf 16\n#define test_string_get_size_one(size, blk_size, exp_result10, exp_result2)    \\\n\tdo {                                                                   \\\n\t\tBUILD_BUG_ON(sizeof(exp_result10) >= string_get_size_maxbuf);  \\\n\t\tBUILD_BUG_ON(sizeof(exp_result2) >= string_get_size_maxbuf);   \\\n\t\t__test_string_get_size((size), (blk_size), (exp_result10),     \\\n\t\t\t\t       (exp_result2));                         \\\n\t} while (0)\n\n\nstatic __init void test_string_get_size_check(const char *units,\n\t\t\t\t\t      const char *exp,\n\t\t\t\t\t      char *res,\n\t\t\t\t\t      const u64 size,\n\t\t\t\t\t      const u64 blk_size)\n{\n\tif (!memcmp(res, exp, strlen(exp) + 1))\n\t\treturn;\n\n\tres[string_get_size_maxbuf - 1] = '\\0';\n\n\tpr_warn(\"Test 'test_string_get_size' failed!\\n\");\n\tpr_warn(\"string_get_size(size = %llu, blk_size = %llu, units = %s)\\n\",\n\t\tsize, blk_size, units);\n\tpr_warn(\"expected: '%s', got '%s'\\n\", exp, res);\n}\n\nstatic __init void __test_string_get_size(const u64 size, const u64 blk_size,\n\t\t\t\t\t  const char *exp_result10,\n\t\t\t\t\t  const char *exp_result2)\n{\n\tchar buf10[string_get_size_maxbuf];\n\tchar buf2[string_get_size_maxbuf];\n\n\tstring_get_size(size, blk_size, STRING_UNITS_10, buf10, sizeof(buf10));\n\tstring_get_size(size, blk_size, STRING_UNITS_2, buf2, sizeof(buf2));\n\n\ttest_string_get_size_check(\"STRING_UNITS_10\", exp_result10, buf10,\n\t\t\t\t   size, blk_size);\n\n\ttest_string_get_size_check(\"STRING_UNITS_2\", exp_result2, buf2,\n\t\t\t\t   size, blk_size);\n}\n\nstatic __init void test_string_get_size(void)\n{\n\t \n\ttest_string_get_size_one(0, 512, \"0 B\", \"0 B\");\n\ttest_string_get_size_one(1, 512, \"512 B\", \"512 B\");\n\ttest_string_get_size_one(1100, 1, \"1.10 kB\", \"1.07 KiB\");\n\n\t \n\ttest_string_get_size_one(16384, 512, \"8.39 MB\", \"8.00 MiB\");\n\ttest_string_get_size_one(500118192, 512, \"256 GB\", \"238 GiB\");\n\ttest_string_get_size_one(8192, 4096, \"33.6 MB\", \"32.0 MiB\");\n\n\t \n\ttest_string_get_size_one(3000, 1900, \"5.70 MB\", \"5.44 MiB\");\n\n\t \n\ttest_string_get_size_one(U64_MAX, 4096, \"75.6 ZB\", \"64.0 ZiB\");\n\ttest_string_get_size_one(4096, U64_MAX, \"75.6 ZB\", \"64.0 ZiB\");\n}\n\nstatic void __init test_string_upper_lower(void)\n{\n\tchar *dst;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(strings_upper); i++) {\n\t\tconst char *s = strings_upper[i].in;\n\t\tint len = strlen(strings_upper[i].in) + 1;\n\n\t\tdst = kmalloc(len, GFP_KERNEL);\n\t\tif (!dst)\n\t\t\treturn;\n\n\t\tstring_upper(dst, s);\n\t\tif (memcmp(dst, strings_upper[i].out, len)) {\n\t\t\tpr_warn(\"Test 'string_upper' failed : expected %s, got %s!\\n\",\n\t\t\t\tstrings_upper[i].out, dst);\n\t\t\tkfree(dst);\n\t\t\treturn;\n\t\t}\n\t\tkfree(dst);\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(strings_lower); i++) {\n\t\tconst char *s = strings_lower[i].in;\n\t\tint len = strlen(strings_lower[i].in) + 1;\n\n\t\tdst = kmalloc(len, GFP_KERNEL);\n\t\tif (!dst)\n\t\t\treturn;\n\n\t\tstring_lower(dst, s);\n\t\tif (memcmp(dst, strings_lower[i].out, len)) {\n\t\t\tpr_warn(\"Test 'string_lower failed : : expected %s, got %s!\\n\",\n\t\t\t\tstrings_lower[i].out, dst);\n\t\t\tkfree(dst);\n\t\t\treturn;\n\t\t}\n\t\tkfree(dst);\n\t}\n}\n\nstatic int __init test_string_helpers_init(void)\n{\n\tunsigned int i;\n\n\tpr_info(\"Running tests...\\n\");\n\tfor (i = 0; i < UNESCAPE_ALL_MASK + 1; i++)\n\t\ttest_string_unescape(\"unescape\", i, false);\n\ttest_string_unescape(\"unescape inplace\",\n\t\t\t     get_random_u32_below(UNESCAPE_ALL_MASK + 1), true);\n\n\t \n\tfor (i = 0; i < ESCAPE_ALL_MASK + 1; i++)\n\t\ttest_string_escape(\"escape 0\", escape0, i, TEST_STRING_2_DICT_0);\n\n\t \n\tfor (i = 0; i < ESCAPE_ALL_MASK + 1; i++)\n\t\ttest_string_escape(\"escape 1\", escape1, i, TEST_STRING_2_DICT_1);\n\n\t \n\ttest_string_get_size();\n\n\t \n\ttest_string_upper_lower();\n\n\treturn -EINVAL;\n}\nmodule_init(test_string_helpers_init);\nMODULE_LICENSE(\"Dual BSD/GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}