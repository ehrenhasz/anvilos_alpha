{
  "module_name": "test_vmalloc.c",
  "hash_id": "021e8d01d2698e27c48d25b06fdad0d4036c9903e1b2b6791f72c50a1c4c42b1",
  "original_prompt": "Ingested from linux-6.6.14/lib/test_vmalloc.c",
  "human_readable_source": "\n\n \n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/random.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/rwsem.h>\n#include <linux/mm.h>\n#include <linux/rcupdate.h>\n#include <linux/slab.h>\n\n#define __param(type, name, init, msg)\t\t\\\n\tstatic type name = init;\t\t\t\t\\\n\tmodule_param(name, type, 0444);\t\t\t\\\n\tMODULE_PARM_DESC(name, msg)\t\t\t\t\\\n\n__param(int, nr_threads, 0,\n\t\"Number of workers to perform tests(min: 1 max: USHRT_MAX)\");\n\n__param(bool, sequential_test_order, false,\n\t\"Use sequential stress tests order\");\n\n__param(int, test_repeat_count, 1,\n\t\"Set test repeat counter\");\n\n__param(int, test_loop_count, 1000000,\n\t\"Set test loop counter\");\n\n__param(int, nr_pages, 0,\n\t\"Set number of pages for fix_size_alloc_test(default: 1)\");\n\n__param(bool, use_huge, false,\n\t\"Use vmalloc_huge in fix_size_alloc_test\");\n\n__param(int, run_test_mask, INT_MAX,\n\t\"Set tests specified in the mask.\\n\\n\"\n\t\t\"\\t\\tid: 1,    name: fix_size_alloc_test\\n\"\n\t\t\"\\t\\tid: 2,    name: full_fit_alloc_test\\n\"\n\t\t\"\\t\\tid: 4,    name: long_busy_list_alloc_test\\n\"\n\t\t\"\\t\\tid: 8,    name: random_size_alloc_test\\n\"\n\t\t\"\\t\\tid: 16,   name: fix_align_alloc_test\\n\"\n\t\t\"\\t\\tid: 32,   name: random_size_align_alloc_test\\n\"\n\t\t\"\\t\\tid: 64,   name: align_shift_alloc_test\\n\"\n\t\t\"\\t\\tid: 128,  name: pcpu_alloc_test\\n\"\n\t\t\"\\t\\tid: 256,  name: kvfree_rcu_1_arg_vmalloc_test\\n\"\n\t\t\"\\t\\tid: 512,  name: kvfree_rcu_2_arg_vmalloc_test\\n\"\n\t\t\"\\t\\tid: 1024, name: vm_map_ram_test\\n\"\n\t\t \n);\n\n \nstatic DECLARE_RWSEM(prepare_for_test_rwsem);\n\n \nstatic DECLARE_COMPLETION(test_all_done_comp);\nstatic atomic_t test_n_undone = ATOMIC_INIT(0);\n\nstatic inline void\ntest_report_one_done(void)\n{\n\tif (atomic_dec_and_test(&test_n_undone))\n\t\tcomplete(&test_all_done_comp);\n}\n\nstatic int random_size_align_alloc_test(void)\n{\n\tunsigned long size, align;\n\tunsigned int rnd;\n\tvoid *ptr;\n\tint i;\n\n\tfor (i = 0; i < test_loop_count; i++) {\n\t\trnd = get_random_u8();\n\n\t\t \n\t\talign = 1 << (rnd % 23);\n\n\t\t \n\t\tsize = ((rnd % 10) + 1) * PAGE_SIZE;\n\n\t\tptr = __vmalloc_node(size, align, GFP_KERNEL | __GFP_ZERO, 0,\n\t\t\t\t__builtin_return_address(0));\n\t\tif (!ptr)\n\t\t\treturn -1;\n\n\t\tvfree(ptr);\n\t}\n\n\treturn 0;\n}\n\n \nstatic int align_shift_alloc_test(void)\n{\n\tunsigned long align;\n\tvoid *ptr;\n\tint i;\n\n\tfor (i = 0; i < BITS_PER_LONG; i++) {\n\t\talign = ((unsigned long) 1) << i;\n\n\t\tptr = __vmalloc_node(PAGE_SIZE, align, GFP_KERNEL|__GFP_ZERO, 0,\n\t\t\t\t__builtin_return_address(0));\n\t\tif (!ptr)\n\t\t\treturn -1;\n\n\t\tvfree(ptr);\n\t}\n\n\treturn 0;\n}\n\nstatic int fix_align_alloc_test(void)\n{\n\tvoid *ptr;\n\tint i;\n\n\tfor (i = 0; i < test_loop_count; i++) {\n\t\tptr = __vmalloc_node(5 * PAGE_SIZE, THREAD_ALIGN << 1,\n\t\t\t\tGFP_KERNEL | __GFP_ZERO, 0,\n\t\t\t\t__builtin_return_address(0));\n\t\tif (!ptr)\n\t\t\treturn -1;\n\n\t\tvfree(ptr);\n\t}\n\n\treturn 0;\n}\n\nstatic int random_size_alloc_test(void)\n{\n\tunsigned int n;\n\tvoid *p;\n\tint i;\n\n\tfor (i = 0; i < test_loop_count; i++) {\n\t\tn = get_random_u32_inclusive(1, 100);\n\t\tp = vmalloc(n * PAGE_SIZE);\n\n\t\tif (!p)\n\t\t\treturn -1;\n\n\t\t*((__u8 *)p) = 1;\n\t\tvfree(p);\n\t}\n\n\treturn 0;\n}\n\nstatic int long_busy_list_alloc_test(void)\n{\n\tvoid *ptr_1, *ptr_2;\n\tvoid **ptr;\n\tint rv = -1;\n\tint i;\n\n\tptr = vmalloc(sizeof(void *) * 15000);\n\tif (!ptr)\n\t\treturn rv;\n\n\tfor (i = 0; i < 15000; i++)\n\t\tptr[i] = vmalloc(1 * PAGE_SIZE);\n\n\tfor (i = 0; i < test_loop_count; i++) {\n\t\tptr_1 = vmalloc(100 * PAGE_SIZE);\n\t\tif (!ptr_1)\n\t\t\tgoto leave;\n\n\t\tptr_2 = vmalloc(1 * PAGE_SIZE);\n\t\tif (!ptr_2) {\n\t\t\tvfree(ptr_1);\n\t\t\tgoto leave;\n\t\t}\n\n\t\t*((__u8 *)ptr_1) = 0;\n\t\t*((__u8 *)ptr_2) = 1;\n\n\t\tvfree(ptr_1);\n\t\tvfree(ptr_2);\n\t}\n\n\t \n\trv = 0;\n\nleave:\n\tfor (i = 0; i < 15000; i++)\n\t\tvfree(ptr[i]);\n\n\tvfree(ptr);\n\treturn rv;\n}\n\nstatic int full_fit_alloc_test(void)\n{\n\tvoid **ptr, **junk_ptr, *tmp;\n\tint junk_length;\n\tint rv = -1;\n\tint i;\n\n\tjunk_length = fls(num_online_cpus());\n\tjunk_length *= (32 * 1024 * 1024 / PAGE_SIZE);\n\n\tptr = vmalloc(sizeof(void *) * junk_length);\n\tif (!ptr)\n\t\treturn rv;\n\n\tjunk_ptr = vmalloc(sizeof(void *) * junk_length);\n\tif (!junk_ptr) {\n\t\tvfree(ptr);\n\t\treturn rv;\n\t}\n\n\tfor (i = 0; i < junk_length; i++) {\n\t\tptr[i] = vmalloc(1 * PAGE_SIZE);\n\t\tjunk_ptr[i] = vmalloc(1 * PAGE_SIZE);\n\t}\n\n\tfor (i = 0; i < junk_length; i++)\n\t\tvfree(junk_ptr[i]);\n\n\tfor (i = 0; i < test_loop_count; i++) {\n\t\ttmp = vmalloc(1 * PAGE_SIZE);\n\n\t\tif (!tmp)\n\t\t\tgoto error;\n\n\t\t*((__u8 *)tmp) = 1;\n\t\tvfree(tmp);\n\t}\n\n\t \n\trv = 0;\n\nerror:\n\tfor (i = 0; i < junk_length; i++)\n\t\tvfree(ptr[i]);\n\n\tvfree(ptr);\n\tvfree(junk_ptr);\n\n\treturn rv;\n}\n\nstatic int fix_size_alloc_test(void)\n{\n\tvoid *ptr;\n\tint i;\n\n\tfor (i = 0; i < test_loop_count; i++) {\n\t\tif (use_huge)\n\t\t\tptr = vmalloc_huge((nr_pages > 0 ? nr_pages:1) * PAGE_SIZE, GFP_KERNEL);\n\t\telse\n\t\t\tptr = vmalloc((nr_pages > 0 ? nr_pages:1) * PAGE_SIZE);\n\n\t\tif (!ptr)\n\t\t\treturn -1;\n\n\t\t*((__u8 *)ptr) = 0;\n\n\t\tvfree(ptr);\n\t}\n\n\treturn 0;\n}\n\nstatic int\npcpu_alloc_test(void)\n{\n\tint rv = 0;\n#ifndef CONFIG_NEED_PER_CPU_KM\n\tvoid __percpu **pcpu;\n\tsize_t size, align;\n\tint i;\n\n\tpcpu = vmalloc(sizeof(void __percpu *) * 35000);\n\tif (!pcpu)\n\t\treturn -1;\n\n\tfor (i = 0; i < 35000; i++) {\n\t\tsize = get_random_u32_inclusive(1, PAGE_SIZE / 4);\n\n\t\t \n\t\talign = 1 << get_random_u32_inclusive(1, 11);\n\n\t\tpcpu[i] = __alloc_percpu(size, align);\n\t\tif (!pcpu[i])\n\t\t\trv = -1;\n\t}\n\n\tfor (i = 0; i < 35000; i++)\n\t\tfree_percpu(pcpu[i]);\n\n\tvfree(pcpu);\n#endif\n\treturn rv;\n}\n\nstruct test_kvfree_rcu {\n\tstruct rcu_head rcu;\n\tunsigned char array[20];\n};\n\nstatic int\nkvfree_rcu_1_arg_vmalloc_test(void)\n{\n\tstruct test_kvfree_rcu *p;\n\tint i;\n\n\tfor (i = 0; i < test_loop_count; i++) {\n\t\tp = vmalloc(1 * PAGE_SIZE);\n\t\tif (!p)\n\t\t\treturn -1;\n\n\t\tp->array[0] = 'a';\n\t\tkvfree_rcu_mightsleep(p);\n\t}\n\n\treturn 0;\n}\n\nstatic int\nkvfree_rcu_2_arg_vmalloc_test(void)\n{\n\tstruct test_kvfree_rcu *p;\n\tint i;\n\n\tfor (i = 0; i < test_loop_count; i++) {\n\t\tp = vmalloc(1 * PAGE_SIZE);\n\t\tif (!p)\n\t\t\treturn -1;\n\n\t\tp->array[0] = 'a';\n\t\tkvfree_rcu(p, rcu);\n\t}\n\n\treturn 0;\n}\n\nstatic int\nvm_map_ram_test(void)\n{\n\tunsigned long nr_allocated;\n\tunsigned int map_nr_pages;\n\tunsigned char *v_ptr;\n\tstruct page **pages;\n\tint i;\n\n\tmap_nr_pages = nr_pages > 0 ? nr_pages:1;\n\tpages = kcalloc(map_nr_pages, sizeof(struct page *), GFP_KERNEL);\n\tif (!pages)\n\t\treturn -1;\n\n\tnr_allocated = alloc_pages_bulk_array(GFP_KERNEL, map_nr_pages, pages);\n\tif (nr_allocated != map_nr_pages)\n\t\tgoto cleanup;\n\n\t \n\tfor (i = 0; i < test_loop_count; i++) {\n\t\tv_ptr = vm_map_ram(pages, map_nr_pages, NUMA_NO_NODE);\n\t\t*v_ptr = 'a';\n\t\tvm_unmap_ram(v_ptr, map_nr_pages);\n\t}\n\ncleanup:\n\tfor (i = 0; i < nr_allocated; i++)\n\t\t__free_page(pages[i]);\n\n\tkfree(pages);\n\n\t \n\treturn nr_allocated != map_nr_pages;\n}\n\nstruct test_case_desc {\n\tconst char *test_name;\n\tint (*test_func)(void);\n};\n\nstatic struct test_case_desc test_case_array[] = {\n\t{ \"fix_size_alloc_test\", fix_size_alloc_test },\n\t{ \"full_fit_alloc_test\", full_fit_alloc_test },\n\t{ \"long_busy_list_alloc_test\", long_busy_list_alloc_test },\n\t{ \"random_size_alloc_test\", random_size_alloc_test },\n\t{ \"fix_align_alloc_test\", fix_align_alloc_test },\n\t{ \"random_size_align_alloc_test\", random_size_align_alloc_test },\n\t{ \"align_shift_alloc_test\", align_shift_alloc_test },\n\t{ \"pcpu_alloc_test\", pcpu_alloc_test },\n\t{ \"kvfree_rcu_1_arg_vmalloc_test\", kvfree_rcu_1_arg_vmalloc_test },\n\t{ \"kvfree_rcu_2_arg_vmalloc_test\", kvfree_rcu_2_arg_vmalloc_test },\n\t{ \"vm_map_ram_test\", vm_map_ram_test },\n\t \n};\n\nstruct test_case_data {\n\tint test_failed;\n\tint test_passed;\n\tu64 time;\n};\n\nstatic struct test_driver {\n\tstruct task_struct *task;\n\tstruct test_case_data data[ARRAY_SIZE(test_case_array)];\n\n\tunsigned long start;\n\tunsigned long stop;\n} *tdriver;\n\nstatic void shuffle_array(int *arr, int n)\n{\n\tint i, j;\n\n\tfor (i = n - 1; i > 0; i--)  {\n\t\t \n\t\tj = get_random_u32_below(i);\n\n\t\t \n\t\tswap(arr[i], arr[j]);\n\t}\n}\n\nstatic int test_func(void *private)\n{\n\tstruct test_driver *t = private;\n\tint random_array[ARRAY_SIZE(test_case_array)];\n\tint index, i, j;\n\tktime_t kt;\n\tu64 delta;\n\n\tfor (i = 0; i < ARRAY_SIZE(test_case_array); i++)\n\t\trandom_array[i] = i;\n\n\tif (!sequential_test_order)\n\t\tshuffle_array(random_array, ARRAY_SIZE(test_case_array));\n\n\t \n\tdown_read(&prepare_for_test_rwsem);\n\n\tt->start = get_cycles();\n\tfor (i = 0; i < ARRAY_SIZE(test_case_array); i++) {\n\t\tindex = random_array[i];\n\n\t\t \n\t\tif (!((run_test_mask & (1 << index)) >> index))\n\t\t\tcontinue;\n\n\t\tkt = ktime_get();\n\t\tfor (j = 0; j < test_repeat_count; j++) {\n\t\t\tif (!test_case_array[index].test_func())\n\t\t\t\tt->data[index].test_passed++;\n\t\t\telse\n\t\t\t\tt->data[index].test_failed++;\n\t\t}\n\n\t\t \n\t\tdelta = (u64) ktime_us_delta(ktime_get(), kt);\n\t\tdo_div(delta, (u32) test_repeat_count);\n\n\t\tt->data[index].time = delta;\n\t}\n\tt->stop = get_cycles();\n\n\tup_read(&prepare_for_test_rwsem);\n\ttest_report_one_done();\n\n\t \n\twhile (!kthread_should_stop())\n\t\tmsleep(10);\n\n\treturn 0;\n}\n\nstatic int\ninit_test_configurtion(void)\n{\n\t \n\tnr_threads = clamp(nr_threads, 1, (int) USHRT_MAX);\n\n\t \n\ttdriver = kvcalloc(nr_threads, sizeof(*tdriver), GFP_KERNEL);\n\tif (tdriver == NULL)\n\t\treturn -1;\n\n\tif (test_repeat_count <= 0)\n\t\ttest_repeat_count = 1;\n\n\tif (test_loop_count <= 0)\n\t\ttest_loop_count = 1;\n\n\treturn 0;\n}\n\nstatic void do_concurrent_test(void)\n{\n\tint i, ret;\n\n\t \n\tret = init_test_configurtion();\n\tif (ret < 0)\n\t\treturn;\n\n\t \n\tdown_write(&prepare_for_test_rwsem);\n\n\tfor (i = 0; i < nr_threads; i++) {\n\t\tstruct test_driver *t = &tdriver[i];\n\n\t\tt->task = kthread_run(test_func, t, \"vmalloc_test/%d\", i);\n\n\t\tif (!IS_ERR(t->task))\n\t\t\t \n\t\t\tatomic_inc(&test_n_undone);\n\t\telse\n\t\t\tpr_err(\"Failed to start %d kthread\\n\", i);\n\t}\n\n\t \n\tup_write(&prepare_for_test_rwsem);\n\n\t \n\tdo {\n\t\tret = wait_for_completion_timeout(&test_all_done_comp, HZ);\n\t} while (!ret);\n\n\tfor (i = 0; i < nr_threads; i++) {\n\t\tstruct test_driver *t = &tdriver[i];\n\t\tint j;\n\n\t\tif (!IS_ERR(t->task))\n\t\t\tkthread_stop(t->task);\n\n\t\tfor (j = 0; j < ARRAY_SIZE(test_case_array); j++) {\n\t\t\tif (!((run_test_mask & (1 << j)) >> j))\n\t\t\t\tcontinue;\n\n\t\t\tpr_info(\n\t\t\t\t\"Summary: %s passed: %d failed: %d repeat: %d loops: %d avg: %llu usec\\n\",\n\t\t\t\ttest_case_array[j].test_name,\n\t\t\t\tt->data[j].test_passed,\n\t\t\t\tt->data[j].test_failed,\n\t\t\t\ttest_repeat_count, test_loop_count,\n\t\t\t\tt->data[j].time);\n\t\t}\n\n\t\tpr_info(\"All test took worker%d=%lu cycles\\n\",\n\t\t\ti, t->stop - t->start);\n\t}\n\n\tkvfree(tdriver);\n}\n\nstatic int vmalloc_test_init(void)\n{\n\tdo_concurrent_test();\n\treturn -EAGAIN;  \n}\n\nstatic void vmalloc_test_exit(void)\n{\n}\n\nmodule_init(vmalloc_test_init)\nmodule_exit(vmalloc_test_exit)\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Uladzislau Rezki\");\nMODULE_DESCRIPTION(\"vmalloc test module\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}