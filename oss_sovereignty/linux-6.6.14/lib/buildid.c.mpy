{
  "module_name": "buildid.c",
  "hash_id": "41590c7bce7c357339d01487897e1b9c09d8b75587743b2b82610735e657738b",
  "original_prompt": "Ingested from linux-6.6.14/lib/buildid.c",
  "human_readable_source": "\n\n#include <linux/buildid.h>\n#include <linux/cache.h>\n#include <linux/elf.h>\n#include <linux/kernel.h>\n#include <linux/pagemap.h>\n\n#define BUILD_ID 3\n\n \nstatic int parse_build_id_buf(unsigned char *build_id,\n\t\t\t      __u32 *size,\n\t\t\t      const void *note_start,\n\t\t\t      Elf32_Word note_size)\n{\n\tElf32_Word note_offs = 0, new_offs;\n\n\twhile (note_offs + sizeof(Elf32_Nhdr) < note_size) {\n\t\tElf32_Nhdr *nhdr = (Elf32_Nhdr *)(note_start + note_offs);\n\n\t\tif (nhdr->n_type == BUILD_ID &&\n\t\t    nhdr->n_namesz == sizeof(\"GNU\") &&\n\t\t    !strcmp((char *)(nhdr + 1), \"GNU\") &&\n\t\t    nhdr->n_descsz > 0 &&\n\t\t    nhdr->n_descsz <= BUILD_ID_SIZE_MAX) {\n\t\t\tmemcpy(build_id,\n\t\t\t       note_start + note_offs +\n\t\t\t       ALIGN(sizeof(\"GNU\"), 4) + sizeof(Elf32_Nhdr),\n\t\t\t       nhdr->n_descsz);\n\t\t\tmemset(build_id + nhdr->n_descsz, 0,\n\t\t\t       BUILD_ID_SIZE_MAX - nhdr->n_descsz);\n\t\t\tif (size)\n\t\t\t\t*size = nhdr->n_descsz;\n\t\t\treturn 0;\n\t\t}\n\t\tnew_offs = note_offs + sizeof(Elf32_Nhdr) +\n\t\t\tALIGN(nhdr->n_namesz, 4) + ALIGN(nhdr->n_descsz, 4);\n\t\tif (new_offs <= note_offs)   \n\t\t\tbreak;\n\t\tnote_offs = new_offs;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic inline int parse_build_id(const void *page_addr,\n\t\t\t\t unsigned char *build_id,\n\t\t\t\t __u32 *size,\n\t\t\t\t const void *note_start,\n\t\t\t\t Elf32_Word note_size)\n{\n\t \n\tif (note_start < page_addr || note_start + note_size < note_start)\n\t\treturn -EINVAL;\n\n\t \n\tif (note_start + note_size > page_addr + PAGE_SIZE)\n\t\treturn -EINVAL;\n\n\treturn parse_build_id_buf(build_id, size, note_start, note_size);\n}\n\n \nstatic int get_build_id_32(const void *page_addr, unsigned char *build_id,\n\t\t\t   __u32 *size)\n{\n\tElf32_Ehdr *ehdr = (Elf32_Ehdr *)page_addr;\n\tElf32_Phdr *phdr;\n\tint i;\n\n\t \n\tif (ehdr->e_phnum >\n\t    (PAGE_SIZE - sizeof(Elf32_Ehdr)) / sizeof(Elf32_Phdr))\n\t\treturn -EINVAL;\n\n\tphdr = (Elf32_Phdr *)(page_addr + sizeof(Elf32_Ehdr));\n\n\tfor (i = 0; i < ehdr->e_phnum; ++i) {\n\t\tif (phdr[i].p_type == PT_NOTE &&\n\t\t    !parse_build_id(page_addr, build_id, size,\n\t\t\t\t    page_addr + phdr[i].p_offset,\n\t\t\t\t    phdr[i].p_filesz))\n\t\t\treturn 0;\n\t}\n\treturn -EINVAL;\n}\n\n \nstatic int get_build_id_64(const void *page_addr, unsigned char *build_id,\n\t\t\t   __u32 *size)\n{\n\tElf64_Ehdr *ehdr = (Elf64_Ehdr *)page_addr;\n\tElf64_Phdr *phdr;\n\tint i;\n\n\t \n\tif (ehdr->e_phnum >\n\t    (PAGE_SIZE - sizeof(Elf64_Ehdr)) / sizeof(Elf64_Phdr))\n\t\treturn -EINVAL;\n\n\tphdr = (Elf64_Phdr *)(page_addr + sizeof(Elf64_Ehdr));\n\n\tfor (i = 0; i < ehdr->e_phnum; ++i) {\n\t\tif (phdr[i].p_type == PT_NOTE &&\n\t\t    !parse_build_id(page_addr, build_id, size,\n\t\t\t\t    page_addr + phdr[i].p_offset,\n\t\t\t\t    phdr[i].p_filesz))\n\t\t\treturn 0;\n\t}\n\treturn -EINVAL;\n}\n\n \nint build_id_parse(struct vm_area_struct *vma, unsigned char *build_id,\n\t\t   __u32 *size)\n{\n\tElf32_Ehdr *ehdr;\n\tstruct page *page;\n\tvoid *page_addr;\n\tint ret;\n\n\t \n\tif (!vma->vm_file)\n\t\treturn -EINVAL;\n\n\tpage = find_get_page(vma->vm_file->f_mapping, 0);\n\tif (!page)\n\t\treturn -EFAULT;\t \n\n\tret = -EINVAL;\n\tpage_addr = kmap_atomic(page);\n\tehdr = (Elf32_Ehdr *)page_addr;\n\n\t \n\tif (memcmp(ehdr->e_ident, ELFMAG, SELFMAG) != 0)\n\t\tgoto out;\n\n\t \n\tif (ehdr->e_type != ET_EXEC && ehdr->e_type != ET_DYN)\n\t\tgoto out;\n\n\tif (ehdr->e_ident[EI_CLASS] == ELFCLASS32)\n\t\tret = get_build_id_32(page_addr, build_id, size);\n\telse if (ehdr->e_ident[EI_CLASS] == ELFCLASS64)\n\t\tret = get_build_id_64(page_addr, build_id, size);\nout:\n\tkunmap_atomic(page_addr);\n\tput_page(page);\n\treturn ret;\n}\n\n \nint build_id_parse_buf(const void *buf, unsigned char *build_id, u32 buf_size)\n{\n\treturn parse_build_id_buf(build_id, NULL, buf, buf_size);\n}\n\n#if IS_ENABLED(CONFIG_STACKTRACE_BUILD_ID) || IS_ENABLED(CONFIG_CRASH_CORE)\nunsigned char vmlinux_build_id[BUILD_ID_SIZE_MAX] __ro_after_init;\n\n \nvoid __init init_vmlinux_build_id(void)\n{\n\textern const void __start_notes __weak;\n\textern const void __stop_notes __weak;\n\tunsigned int size = &__stop_notes - &__start_notes;\n\n\tbuild_id_parse_buf(&__start_notes, vmlinux_build_id, size);\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}