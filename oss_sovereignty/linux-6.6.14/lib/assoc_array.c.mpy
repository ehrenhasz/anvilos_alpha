{
  "module_name": "assoc_array.c",
  "hash_id": "5c58eefbb633447116dacad1c2afe583f51e0fb800f5d4881c2adc084b3d8fe5",
  "original_prompt": "Ingested from linux-6.6.14/lib/assoc_array.c",
  "human_readable_source": "\n \n\n#include <linux/rcupdate.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/assoc_array_priv.h>\n\n \nstatic int assoc_array_subtree_iterate(const struct assoc_array_ptr *root,\n\t\t\t\t       const struct assoc_array_ptr *stop,\n\t\t\t\t       int (*iterator)(const void *leaf,\n\t\t\t\t\t\t       void *iterator_data),\n\t\t\t\t       void *iterator_data)\n{\n\tconst struct assoc_array_shortcut *shortcut;\n\tconst struct assoc_array_node *node;\n\tconst struct assoc_array_ptr *cursor, *ptr, *parent;\n\tunsigned long has_meta;\n\tint slot, ret;\n\n\tcursor = root;\n\nbegin_node:\n\tif (assoc_array_ptr_is_shortcut(cursor)) {\n\t\t \n\t\tshortcut = assoc_array_ptr_to_shortcut(cursor);\n\t\tcursor = READ_ONCE(shortcut->next_node);  \n\t}\n\n\tnode = assoc_array_ptr_to_node(cursor);\n\tslot = 0;\n\n\t \n\thas_meta = 0;\n\tfor (; slot < ASSOC_ARRAY_FAN_OUT; slot++) {\n\t\tptr = READ_ONCE(node->slots[slot]);  \n\t\thas_meta |= (unsigned long)ptr;\n\t\tif (ptr && assoc_array_ptr_is_leaf(ptr)) {\n\t\t\t \n\t\t\t \n\t\t\tret = iterator(assoc_array_ptr_to_leaf(ptr),\n\t\t\t\t       iterator_data);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\t \n\tif (!(has_meta & ASSOC_ARRAY_PTR_META_TYPE))\n\t\tgoto finished_node;\n\tslot = 0;\n\ncontinue_node:\n\tnode = assoc_array_ptr_to_node(cursor);\n\tfor (; slot < ASSOC_ARRAY_FAN_OUT; slot++) {\n\t\tptr = READ_ONCE(node->slots[slot]);  \n\t\tif (assoc_array_ptr_is_meta(ptr)) {\n\t\t\tcursor = ptr;\n\t\t\tgoto begin_node;\n\t\t}\n\t}\n\nfinished_node:\n\t \n\tparent = READ_ONCE(node->back_pointer);  \n\tslot = node->parent_slot;\n\tif (parent == stop)\n\t\treturn 0;\n\n\tif (assoc_array_ptr_is_shortcut(parent)) {\n\t\tshortcut = assoc_array_ptr_to_shortcut(parent);\n\t\tcursor = parent;\n\t\tparent = READ_ONCE(shortcut->back_pointer);  \n\t\tslot = shortcut->parent_slot;\n\t\tif (parent == stop)\n\t\t\treturn 0;\n\t}\n\n\t \n\tcursor = parent;\n\tslot++;\n\tgoto continue_node;\n}\n\n \nint assoc_array_iterate(const struct assoc_array *array,\n\t\t\tint (*iterator)(const void *object,\n\t\t\t\t\tvoid *iterator_data),\n\t\t\tvoid *iterator_data)\n{\n\tstruct assoc_array_ptr *root = READ_ONCE(array->root);  \n\n\tif (!root)\n\t\treturn 0;\n\treturn assoc_array_subtree_iterate(root, NULL, iterator, iterator_data);\n}\n\nenum assoc_array_walk_status {\n\tassoc_array_walk_tree_empty,\n\tassoc_array_walk_found_terminal_node,\n\tassoc_array_walk_found_wrong_shortcut,\n};\n\nstruct assoc_array_walk_result {\n\tstruct {\n\t\tstruct assoc_array_node\t*node;\t \n\t\tint\t\tlevel;\n\t\tint\t\tslot;\n\t} terminal_node;\n\tstruct {\n\t\tstruct assoc_array_shortcut *shortcut;\n\t\tint\t\tlevel;\n\t\tint\t\tsc_level;\n\t\tunsigned long\tsc_segments;\n\t\tunsigned long\tdissimilarity;\n\t} wrong_shortcut;\n};\n\n \nstatic enum assoc_array_walk_status\nassoc_array_walk(const struct assoc_array *array,\n\t\t const struct assoc_array_ops *ops,\n\t\t const void *index_key,\n\t\t struct assoc_array_walk_result *result)\n{\n\tstruct assoc_array_shortcut *shortcut;\n\tstruct assoc_array_node *node;\n\tstruct assoc_array_ptr *cursor, *ptr;\n\tunsigned long sc_segments, dissimilarity;\n\tunsigned long segments;\n\tint level, sc_level, next_sc_level;\n\tint slot;\n\n\tpr_devel(\"-->%s()\\n\", __func__);\n\n\tcursor = READ_ONCE(array->root);   \n\tif (!cursor)\n\t\treturn assoc_array_walk_tree_empty;\n\n\tlevel = 0;\n\n\t \njumped:\n\tsegments = ops->get_key_chunk(index_key, level);\n\tpr_devel(\"segments[%d]: %lx\\n\", level, segments);\n\n\tif (assoc_array_ptr_is_shortcut(cursor))\n\t\tgoto follow_shortcut;\n\nconsider_node:\n\tnode = assoc_array_ptr_to_node(cursor);\n\tslot = segments >> (level & ASSOC_ARRAY_KEY_CHUNK_MASK);\n\tslot &= ASSOC_ARRAY_FAN_MASK;\n\tptr = READ_ONCE(node->slots[slot]);  \n\n\tpr_devel(\"consider slot %x [ix=%d type=%lu]\\n\",\n\t\t slot, level, (unsigned long)ptr & 3);\n\n\tif (!assoc_array_ptr_is_meta(ptr)) {\n\t\t \n\t\tresult->terminal_node.node = node;\n\t\tresult->terminal_node.level = level;\n\t\tresult->terminal_node.slot = slot;\n\t\tpr_devel(\"<--%s() = terminal_node\\n\", __func__);\n\t\treturn assoc_array_walk_found_terminal_node;\n\t}\n\n\tif (assoc_array_ptr_is_node(ptr)) {\n\t\t \n\t\tcursor = ptr;\n\t\tlevel += ASSOC_ARRAY_LEVEL_STEP;\n\t\tif ((level & ASSOC_ARRAY_KEY_CHUNK_MASK) != 0)\n\t\t\tgoto consider_node;\n\t\tgoto jumped;\n\t}\n\n\t \n\tcursor = ptr;\nfollow_shortcut:\n\tshortcut = assoc_array_ptr_to_shortcut(cursor);\n\tpr_devel(\"shortcut to %d\\n\", shortcut->skip_to_level);\n\tsc_level = level + ASSOC_ARRAY_LEVEL_STEP;\n\tBUG_ON(sc_level > shortcut->skip_to_level);\n\n\tdo {\n\t\t \n\t\tif ((sc_level & ASSOC_ARRAY_KEY_CHUNK_MASK) == 0)\n\t\t\tsegments = ops->get_key_chunk(index_key, sc_level);\n\n\t\tsc_segments = shortcut->index_key[sc_level >> ASSOC_ARRAY_KEY_CHUNK_SHIFT];\n\t\tdissimilarity = segments ^ sc_segments;\n\n\t\tif (round_up(sc_level, ASSOC_ARRAY_KEY_CHUNK_SIZE) > shortcut->skip_to_level) {\n\t\t\t \n\t\t\tint shift = shortcut->skip_to_level & ASSOC_ARRAY_KEY_CHUNK_MASK;\n\t\t\tdissimilarity &= ~(ULONG_MAX << shift);\n\t\t\tnext_sc_level = shortcut->skip_to_level;\n\t\t} else {\n\t\t\tnext_sc_level = sc_level + ASSOC_ARRAY_KEY_CHUNK_SIZE;\n\t\t\tnext_sc_level = round_down(next_sc_level, ASSOC_ARRAY_KEY_CHUNK_SIZE);\n\t\t}\n\n\t\tif (dissimilarity != 0) {\n\t\t\t \n\t\t\tresult->wrong_shortcut.shortcut = shortcut;\n\t\t\tresult->wrong_shortcut.level = level;\n\t\t\tresult->wrong_shortcut.sc_level = sc_level;\n\t\t\tresult->wrong_shortcut.sc_segments = sc_segments;\n\t\t\tresult->wrong_shortcut.dissimilarity = dissimilarity;\n\t\t\treturn assoc_array_walk_found_wrong_shortcut;\n\t\t}\n\n\t\tsc_level = next_sc_level;\n\t} while (sc_level < shortcut->skip_to_level);\n\n\t \n\tcursor = READ_ONCE(shortcut->next_node);  \n\tif (((level ^ sc_level) & ~ASSOC_ARRAY_KEY_CHUNK_MASK) != 0) {\n\t\tlevel = sc_level;\n\t\tgoto jumped;\n\t} else {\n\t\tlevel = sc_level;\n\t\tgoto consider_node;\n\t}\n}\n\n \nvoid *assoc_array_find(const struct assoc_array *array,\n\t\t       const struct assoc_array_ops *ops,\n\t\t       const void *index_key)\n{\n\tstruct assoc_array_walk_result result;\n\tconst struct assoc_array_node *node;\n\tconst struct assoc_array_ptr *ptr;\n\tconst void *leaf;\n\tint slot;\n\n\tif (assoc_array_walk(array, ops, index_key, &result) !=\n\t    assoc_array_walk_found_terminal_node)\n\t\treturn NULL;\n\n\tnode = result.terminal_node.node;\n\n\t \n\tfor (slot = 0; slot < ASSOC_ARRAY_FAN_OUT; slot++) {\n\t\tptr = READ_ONCE(node->slots[slot]);  \n\t\tif (ptr && assoc_array_ptr_is_leaf(ptr)) {\n\t\t\t \n\t\t\tleaf = assoc_array_ptr_to_leaf(ptr);\n\t\t\tif (ops->compare_object(leaf, index_key))\n\t\t\t\treturn (void *)leaf;\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\n \nstatic void assoc_array_destroy_subtree(struct assoc_array_ptr *root,\n\t\t\t\t\tconst struct assoc_array_ops *ops)\n{\n\tstruct assoc_array_shortcut *shortcut;\n\tstruct assoc_array_node *node;\n\tstruct assoc_array_ptr *cursor, *parent = NULL;\n\tint slot = -1;\n\n\tpr_devel(\"-->%s()\\n\", __func__);\n\n\tcursor = root;\n\tif (!cursor) {\n\t\tpr_devel(\"empty\\n\");\n\t\treturn;\n\t}\n\nmove_to_meta:\n\tif (assoc_array_ptr_is_shortcut(cursor)) {\n\t\t \n\t\tpr_devel(\"[%d] shortcut\\n\", slot);\n\t\tBUG_ON(!assoc_array_ptr_is_shortcut(cursor));\n\t\tshortcut = assoc_array_ptr_to_shortcut(cursor);\n\t\tBUG_ON(shortcut->back_pointer != parent);\n\t\tBUG_ON(slot != -1 && shortcut->parent_slot != slot);\n\t\tparent = cursor;\n\t\tcursor = shortcut->next_node;\n\t\tslot = -1;\n\t\tBUG_ON(!assoc_array_ptr_is_node(cursor));\n\t}\n\n\tpr_devel(\"[%d] node\\n\", slot);\n\tnode = assoc_array_ptr_to_node(cursor);\n\tBUG_ON(node->back_pointer != parent);\n\tBUG_ON(slot != -1 && node->parent_slot != slot);\n\tslot = 0;\n\ncontinue_node:\n\tpr_devel(\"Node %p [back=%p]\\n\", node, node->back_pointer);\n\tfor (; slot < ASSOC_ARRAY_FAN_OUT; slot++) {\n\t\tstruct assoc_array_ptr *ptr = node->slots[slot];\n\t\tif (!ptr)\n\t\t\tcontinue;\n\t\tif (assoc_array_ptr_is_meta(ptr)) {\n\t\t\tparent = cursor;\n\t\t\tcursor = ptr;\n\t\t\tgoto move_to_meta;\n\t\t}\n\n\t\tif (ops) {\n\t\t\tpr_devel(\"[%d] free leaf\\n\", slot);\n\t\t\tops->free_object(assoc_array_ptr_to_leaf(ptr));\n\t\t}\n\t}\n\n\tparent = node->back_pointer;\n\tslot = node->parent_slot;\n\tpr_devel(\"free node\\n\");\n\tkfree(node);\n\tif (!parent)\n\t\treturn;  \n\n\t \n\tif (assoc_array_ptr_is_shortcut(parent)) {\n\t\tshortcut = assoc_array_ptr_to_shortcut(parent);\n\t\tBUG_ON(shortcut->next_node != cursor);\n\t\tcursor = parent;\n\t\tparent = shortcut->back_pointer;\n\t\tslot = shortcut->parent_slot;\n\t\tpr_devel(\"free shortcut\\n\");\n\t\tkfree(shortcut);\n\t\tif (!parent)\n\t\t\treturn;\n\n\t\tBUG_ON(!assoc_array_ptr_is_node(parent));\n\t}\n\n\t \n\tpr_devel(\"ascend to %p[%d]\\n\", parent, slot);\n\tcursor = parent;\n\tnode = assoc_array_ptr_to_node(cursor);\n\tslot++;\n\tgoto continue_node;\n}\n\n \nvoid assoc_array_destroy(struct assoc_array *array,\n\t\t\t const struct assoc_array_ops *ops)\n{\n\tassoc_array_destroy_subtree(array->root, ops);\n\tarray->root = NULL;\n}\n\n \nstatic bool assoc_array_insert_in_empty_tree(struct assoc_array_edit *edit)\n{\n\tstruct assoc_array_node *new_n0;\n\n\tpr_devel(\"-->%s()\\n\", __func__);\n\n\tnew_n0 = kzalloc(sizeof(struct assoc_array_node), GFP_KERNEL);\n\tif (!new_n0)\n\t\treturn false;\n\n\tedit->new_meta[0] = assoc_array_node_to_ptr(new_n0);\n\tedit->leaf_p = &new_n0->slots[0];\n\tedit->adjust_count_on = new_n0;\n\tedit->set[0].ptr = &edit->array->root;\n\tedit->set[0].to = assoc_array_node_to_ptr(new_n0);\n\n\tpr_devel(\"<--%s() = ok [no root]\\n\", __func__);\n\treturn true;\n}\n\n \nstatic bool assoc_array_insert_into_terminal_node(struct assoc_array_edit *edit,\n\t\t\t\t\t\t  const struct assoc_array_ops *ops,\n\t\t\t\t\t\t  const void *index_key,\n\t\t\t\t\t\t  struct assoc_array_walk_result *result)\n{\n\tstruct assoc_array_shortcut *shortcut, *new_s0;\n\tstruct assoc_array_node *node, *new_n0, *new_n1, *side;\n\tstruct assoc_array_ptr *ptr;\n\tunsigned long dissimilarity, base_seg, blank;\n\tsize_t keylen;\n\tbool have_meta;\n\tint level, diff;\n\tint slot, next_slot, free_slot, i, j;\n\n\tnode\t= result->terminal_node.node;\n\tlevel\t= result->terminal_node.level;\n\tedit->segment_cache[ASSOC_ARRAY_FAN_OUT] = result->terminal_node.slot;\n\n\tpr_devel(\"-->%s()\\n\", __func__);\n\n\t \n\tfree_slot = -1;\n\n\t \n\tfor (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++) {\n\t\tptr = node->slots[i];\n\t\tif (!ptr) {\n\t\t\tfree_slot = i;\n\t\t\tcontinue;\n\t\t}\n\t\tif (assoc_array_ptr_is_leaf(ptr) &&\n\t\t    ops->compare_object(assoc_array_ptr_to_leaf(ptr),\n\t\t\t\t\tindex_key)) {\n\t\t\tpr_devel(\"replace in slot %d\\n\", i);\n\t\t\tedit->leaf_p = &node->slots[i];\n\t\t\tedit->dead_leaf = node->slots[i];\n\t\t\tpr_devel(\"<--%s() = ok [replace]\\n\", __func__);\n\t\t\treturn true;\n\t\t}\n\t}\n\n\t \n\tif (free_slot >= 0) {\n\t\tpr_devel(\"insert in free slot %d\\n\", free_slot);\n\t\tedit->leaf_p = &node->slots[free_slot];\n\t\tedit->adjust_count_on = node;\n\t\tpr_devel(\"<--%s() = ok [insert]\\n\", __func__);\n\t\treturn true;\n\t}\n\n\t \n\tnew_n0 = kzalloc(sizeof(struct assoc_array_node), GFP_KERNEL);\n\tif (!new_n0)\n\t\treturn false;\n\tedit->new_meta[0] = assoc_array_node_to_ptr(new_n0);\n\tnew_n1 = kzalloc(sizeof(struct assoc_array_node), GFP_KERNEL);\n\tif (!new_n1)\n\t\treturn false;\n\tedit->new_meta[1] = assoc_array_node_to_ptr(new_n1);\n\n\t \n\tpr_devel(\"no spare slots\\n\");\n\thave_meta = false;\n\tfor (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++) {\n\t\tptr = node->slots[i];\n\t\tif (assoc_array_ptr_is_meta(ptr)) {\n\t\t\tedit->segment_cache[i] = 0xff;\n\t\t\thave_meta = true;\n\t\t\tcontinue;\n\t\t}\n\t\tbase_seg = ops->get_object_key_chunk(\n\t\t\tassoc_array_ptr_to_leaf(ptr), level);\n\t\tbase_seg >>= level & ASSOC_ARRAY_KEY_CHUNK_MASK;\n\t\tedit->segment_cache[i] = base_seg & ASSOC_ARRAY_FAN_MASK;\n\t}\n\n\tif (have_meta) {\n\t\tpr_devel(\"have meta\\n\");\n\t\tgoto split_node;\n\t}\n\n\t \n\tdissimilarity = 0;\n\tbase_seg = edit->segment_cache[0];\n\tfor (i = 1; i < ASSOC_ARRAY_FAN_OUT; i++)\n\t\tdissimilarity |= edit->segment_cache[i] ^ base_seg;\n\n\tpr_devel(\"only leaves; dissimilarity=%lx\\n\", dissimilarity);\n\n\tif ((dissimilarity & ASSOC_ARRAY_FAN_MASK) == 0) {\n\t\t \n\t\tif ((edit->segment_cache[ASSOC_ARRAY_FAN_OUT] ^ base_seg) == 0)\n\t\t\tgoto all_leaves_cluster_together;\n\n\t\t \n\t\tpr_devel(\"present leaves cluster but not new leaf\\n\");\n\t}\n\nsplit_node:\n\tpr_devel(\"split node\\n\");\n\n\t \n\tedit->set[0].to = assoc_array_node_to_ptr(new_n0);\n\tnew_n0->back_pointer = node->back_pointer;\n\tnew_n0->parent_slot = node->parent_slot;\n\tnew_n1->back_pointer = assoc_array_node_to_ptr(new_n0);\n\tnew_n1->parent_slot = -1;  \n\ndo_split_node:\n\tpr_devel(\"do_split_node\\n\");\n\n\tnew_n0->nr_leaves_on_branch = node->nr_leaves_on_branch;\n\tnew_n1->nr_leaves_on_branch = 0;\n\n\t \n\tfor (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++) {\n\t\tslot = edit->segment_cache[i];\n\t\tif (slot != 0xff)\n\t\t\tfor (j = i + 1; j < ASSOC_ARRAY_FAN_OUT + 1; j++)\n\t\t\t\tif (edit->segment_cache[j] == slot)\n\t\t\t\t\tgoto found_slot_for_multiple_occupancy;\n\t}\nfound_slot_for_multiple_occupancy:\n\tpr_devel(\"same slot: %x %x [%02x]\\n\", i, j, slot);\n\tBUG_ON(i >= ASSOC_ARRAY_FAN_OUT);\n\tBUG_ON(j >= ASSOC_ARRAY_FAN_OUT + 1);\n\tBUG_ON(slot >= ASSOC_ARRAY_FAN_OUT);\n\n\tnew_n1->parent_slot = slot;\n\n\t \n\tfor (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++)\n\t\tif (assoc_array_ptr_is_meta(node->slots[i]))\n\t\t\tnew_n0->slots[i] = node->slots[i];\n\t\telse\n\t\t\tnew_n0->slots[i] = NULL;\n\tBUG_ON(new_n0->slots[slot] != NULL);\n\tnew_n0->slots[slot] = assoc_array_node_to_ptr(new_n1);\n\n\t \n\tfree_slot = -1;\n\tnext_slot = 0;\n\tfor (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++) {\n\t\tif (assoc_array_ptr_is_meta(node->slots[i]))\n\t\t\tcontinue;\n\t\tif (edit->segment_cache[i] == slot) {\n\t\t\tnew_n1->slots[next_slot++] = node->slots[i];\n\t\t\tnew_n1->nr_leaves_on_branch++;\n\t\t} else {\n\t\t\tdo {\n\t\t\t\tfree_slot++;\n\t\t\t} while (new_n0->slots[free_slot] != NULL);\n\t\t\tnew_n0->slots[free_slot] = node->slots[i];\n\t\t}\n\t}\n\n\tpr_devel(\"filtered: f=%x n=%x\\n\", free_slot, next_slot);\n\n\tif (edit->segment_cache[ASSOC_ARRAY_FAN_OUT] != slot) {\n\t\tdo {\n\t\t\tfree_slot++;\n\t\t} while (new_n0->slots[free_slot] != NULL);\n\t\tedit->leaf_p = &new_n0->slots[free_slot];\n\t\tedit->adjust_count_on = new_n0;\n\t} else {\n\t\tedit->leaf_p = &new_n1->slots[next_slot++];\n\t\tedit->adjust_count_on = new_n1;\n\t}\n\n\tBUG_ON(next_slot <= 1);\n\n\tedit->set_backpointers_to = assoc_array_node_to_ptr(new_n0);\n\tfor (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++) {\n\t\tif (edit->segment_cache[i] == 0xff) {\n\t\t\tptr = node->slots[i];\n\t\t\tBUG_ON(assoc_array_ptr_is_leaf(ptr));\n\t\t\tif (assoc_array_ptr_is_node(ptr)) {\n\t\t\t\tside = assoc_array_ptr_to_node(ptr);\n\t\t\t\tedit->set_backpointers[i] = &side->back_pointer;\n\t\t\t} else {\n\t\t\t\tshortcut = assoc_array_ptr_to_shortcut(ptr);\n\t\t\t\tedit->set_backpointers[i] = &shortcut->back_pointer;\n\t\t\t}\n\t\t}\n\t}\n\n\tptr = node->back_pointer;\n\tif (!ptr)\n\t\tedit->set[0].ptr = &edit->array->root;\n\telse if (assoc_array_ptr_is_node(ptr))\n\t\tedit->set[0].ptr = &assoc_array_ptr_to_node(ptr)->slots[node->parent_slot];\n\telse\n\t\tedit->set[0].ptr = &assoc_array_ptr_to_shortcut(ptr)->next_node;\n\tedit->excised_meta[0] = assoc_array_node_to_ptr(node);\n\tpr_devel(\"<--%s() = ok [split node]\\n\", __func__);\n\treturn true;\n\nall_leaves_cluster_together:\n\t \n\tpr_devel(\"all leaves cluster together\\n\");\n\tdiff = INT_MAX;\n\tfor (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++) {\n\t\tint x = ops->diff_objects(assoc_array_ptr_to_leaf(node->slots[i]),\n\t\t\t\t\t  index_key);\n\t\tif (x < diff) {\n\t\t\tBUG_ON(x < 0);\n\t\t\tdiff = x;\n\t\t}\n\t}\n\tBUG_ON(diff == INT_MAX);\n\tBUG_ON(diff < level + ASSOC_ARRAY_LEVEL_STEP);\n\n\tkeylen = round_up(diff, ASSOC_ARRAY_KEY_CHUNK_SIZE);\n\tkeylen >>= ASSOC_ARRAY_KEY_CHUNK_SHIFT;\n\n\tnew_s0 = kzalloc(struct_size(new_s0, index_key, keylen), GFP_KERNEL);\n\tif (!new_s0)\n\t\treturn false;\n\tedit->new_meta[2] = assoc_array_shortcut_to_ptr(new_s0);\n\n\tedit->set[0].to = assoc_array_shortcut_to_ptr(new_s0);\n\tnew_s0->back_pointer = node->back_pointer;\n\tnew_s0->parent_slot = node->parent_slot;\n\tnew_s0->next_node = assoc_array_node_to_ptr(new_n0);\n\tnew_n0->back_pointer = assoc_array_shortcut_to_ptr(new_s0);\n\tnew_n0->parent_slot = 0;\n\tnew_n1->back_pointer = assoc_array_node_to_ptr(new_n0);\n\tnew_n1->parent_slot = -1;  \n\n\tnew_s0->skip_to_level = level = diff & ~ASSOC_ARRAY_LEVEL_STEP_MASK;\n\tpr_devel(\"skip_to_level = %d [diff %d]\\n\", level, diff);\n\tBUG_ON(level <= 0);\n\n\tfor (i = 0; i < keylen; i++)\n\t\tnew_s0->index_key[i] =\n\t\t\tops->get_key_chunk(index_key, i * ASSOC_ARRAY_KEY_CHUNK_SIZE);\n\n\tif (level & ASSOC_ARRAY_KEY_CHUNK_MASK) {\n\t\tblank = ULONG_MAX << (level & ASSOC_ARRAY_KEY_CHUNK_MASK);\n\t\tpr_devel(\"blank off [%zu] %d: %lx\\n\", keylen - 1, level, blank);\n\t\tnew_s0->index_key[keylen - 1] &= ~blank;\n\t}\n\n\t \n\tfor (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++) {\n\t\tptr = node->slots[i];\n\t\tbase_seg = ops->get_object_key_chunk(assoc_array_ptr_to_leaf(ptr),\n\t\t\t\t\t\t     level);\n\t\tbase_seg >>= level & ASSOC_ARRAY_KEY_CHUNK_MASK;\n\t\tedit->segment_cache[i] = base_seg & ASSOC_ARRAY_FAN_MASK;\n\t}\n\n\tbase_seg = ops->get_key_chunk(index_key, level);\n\tbase_seg >>= level & ASSOC_ARRAY_KEY_CHUNK_MASK;\n\tedit->segment_cache[ASSOC_ARRAY_FAN_OUT] = base_seg & ASSOC_ARRAY_FAN_MASK;\n\tgoto do_split_node;\n}\n\n \nstatic bool assoc_array_insert_mid_shortcut(struct assoc_array_edit *edit,\n\t\t\t\t\t    const struct assoc_array_ops *ops,\n\t\t\t\t\t    struct assoc_array_walk_result *result)\n{\n\tstruct assoc_array_shortcut *shortcut, *new_s0, *new_s1;\n\tstruct assoc_array_node *node, *new_n0, *side;\n\tunsigned long sc_segments, dissimilarity, blank;\n\tsize_t keylen;\n\tint level, sc_level, diff;\n\tint sc_slot;\n\n\tshortcut\t= result->wrong_shortcut.shortcut;\n\tlevel\t\t= result->wrong_shortcut.level;\n\tsc_level\t= result->wrong_shortcut.sc_level;\n\tsc_segments\t= result->wrong_shortcut.sc_segments;\n\tdissimilarity\t= result->wrong_shortcut.dissimilarity;\n\n\tpr_devel(\"-->%s(ix=%d dis=%lx scix=%d)\\n\",\n\t\t __func__, level, dissimilarity, sc_level);\n\n\t \n\tdiff = __ffs(dissimilarity);\n\tdiff &= ~ASSOC_ARRAY_LEVEL_STEP_MASK;\n\tdiff += sc_level & ~ASSOC_ARRAY_KEY_CHUNK_MASK;\n\tpr_devel(\"diff=%d\\n\", diff);\n\n\tif (!shortcut->back_pointer) {\n\t\tedit->set[0].ptr = &edit->array->root;\n\t} else if (assoc_array_ptr_is_node(shortcut->back_pointer)) {\n\t\tnode = assoc_array_ptr_to_node(shortcut->back_pointer);\n\t\tedit->set[0].ptr = &node->slots[shortcut->parent_slot];\n\t} else {\n\t\tBUG();\n\t}\n\n\tedit->excised_meta[0] = assoc_array_shortcut_to_ptr(shortcut);\n\n\t \n\tnew_n0 = kzalloc(sizeof(struct assoc_array_node), GFP_KERNEL);\n\tif (!new_n0)\n\t\treturn false;\n\tedit->new_meta[0] = assoc_array_node_to_ptr(new_n0);\n\tedit->adjust_count_on = new_n0;\n\n\t \n\tlevel += ASSOC_ARRAY_LEVEL_STEP;\n\tif (diff > level) {\n\t\tpr_devel(\"pre-shortcut %d...%d\\n\", level, diff);\n\t\tkeylen = round_up(diff, ASSOC_ARRAY_KEY_CHUNK_SIZE);\n\t\tkeylen >>= ASSOC_ARRAY_KEY_CHUNK_SHIFT;\n\n\t\tnew_s0 = kzalloc(struct_size(new_s0, index_key, keylen),\n\t\t\t\t GFP_KERNEL);\n\t\tif (!new_s0)\n\t\t\treturn false;\n\t\tedit->new_meta[1] = assoc_array_shortcut_to_ptr(new_s0);\n\t\tedit->set[0].to = assoc_array_shortcut_to_ptr(new_s0);\n\t\tnew_s0->back_pointer = shortcut->back_pointer;\n\t\tnew_s0->parent_slot = shortcut->parent_slot;\n\t\tnew_s0->next_node = assoc_array_node_to_ptr(new_n0);\n\t\tnew_s0->skip_to_level = diff;\n\n\t\tnew_n0->back_pointer = assoc_array_shortcut_to_ptr(new_s0);\n\t\tnew_n0->parent_slot = 0;\n\n\t\tmemcpy(new_s0->index_key, shortcut->index_key,\n\t\t       flex_array_size(new_s0, index_key, keylen));\n\n\t\tblank = ULONG_MAX << (diff & ASSOC_ARRAY_KEY_CHUNK_MASK);\n\t\tpr_devel(\"blank off [%zu] %d: %lx\\n\", keylen - 1, diff, blank);\n\t\tnew_s0->index_key[keylen - 1] &= ~blank;\n\t} else {\n\t\tpr_devel(\"no pre-shortcut\\n\");\n\t\tedit->set[0].to = assoc_array_node_to_ptr(new_n0);\n\t\tnew_n0->back_pointer = shortcut->back_pointer;\n\t\tnew_n0->parent_slot = shortcut->parent_slot;\n\t}\n\n\tside = assoc_array_ptr_to_node(shortcut->next_node);\n\tnew_n0->nr_leaves_on_branch = side->nr_leaves_on_branch;\n\n\t \n\tsc_slot = sc_segments >> (diff & ASSOC_ARRAY_KEY_CHUNK_MASK);\n\tsc_slot &= ASSOC_ARRAY_FAN_MASK;\n\n\tpr_devel(\"new slot %lx >> %d -> %d\\n\",\n\t\t sc_segments, diff & ASSOC_ARRAY_KEY_CHUNK_MASK, sc_slot);\n\n\t \n\tlevel = diff + ASSOC_ARRAY_LEVEL_STEP;\n\tif (level < shortcut->skip_to_level) {\n\t\tpr_devel(\"post-shortcut %d...%d\\n\", level, shortcut->skip_to_level);\n\t\tkeylen = round_up(shortcut->skip_to_level, ASSOC_ARRAY_KEY_CHUNK_SIZE);\n\t\tkeylen >>= ASSOC_ARRAY_KEY_CHUNK_SHIFT;\n\n\t\tnew_s1 = kzalloc(struct_size(new_s1, index_key, keylen),\n\t\t\t\t GFP_KERNEL);\n\t\tif (!new_s1)\n\t\t\treturn false;\n\t\tedit->new_meta[2] = assoc_array_shortcut_to_ptr(new_s1);\n\n\t\tnew_s1->back_pointer = assoc_array_node_to_ptr(new_n0);\n\t\tnew_s1->parent_slot = sc_slot;\n\t\tnew_s1->next_node = shortcut->next_node;\n\t\tnew_s1->skip_to_level = shortcut->skip_to_level;\n\n\t\tnew_n0->slots[sc_slot] = assoc_array_shortcut_to_ptr(new_s1);\n\n\t\tmemcpy(new_s1->index_key, shortcut->index_key,\n\t\t       flex_array_size(new_s1, index_key, keylen));\n\n\t\tedit->set[1].ptr = &side->back_pointer;\n\t\tedit->set[1].to = assoc_array_shortcut_to_ptr(new_s1);\n\t} else {\n\t\tpr_devel(\"no post-shortcut\\n\");\n\n\t\t \n\t\tnew_n0->slots[sc_slot] = shortcut->next_node;\n\t\tedit->set_parent_slot[0].p = &side->parent_slot;\n\t\tedit->set_parent_slot[0].to = sc_slot;\n\t\tedit->set[1].ptr = &side->back_pointer;\n\t\tedit->set[1].to = assoc_array_node_to_ptr(new_n0);\n\t}\n\n\t \n\tif (sc_slot == 0)\n\t\tedit->leaf_p = &new_n0->slots[1];\n\telse\n\t\tedit->leaf_p = &new_n0->slots[0];\n\n\tpr_devel(\"<--%s() = ok [split shortcut]\\n\", __func__);\n\treturn edit;\n}\n\n \nstruct assoc_array_edit *assoc_array_insert(struct assoc_array *array,\n\t\t\t\t\t    const struct assoc_array_ops *ops,\n\t\t\t\t\t    const void *index_key,\n\t\t\t\t\t    void *object)\n{\n\tstruct assoc_array_walk_result result;\n\tstruct assoc_array_edit *edit;\n\n\tpr_devel(\"-->%s()\\n\", __func__);\n\n\t \n\tBUG_ON(assoc_array_ptr_is_meta(object));\n\n\tedit = kzalloc(sizeof(struct assoc_array_edit), GFP_KERNEL);\n\tif (!edit)\n\t\treturn ERR_PTR(-ENOMEM);\n\tedit->array = array;\n\tedit->ops = ops;\n\tedit->leaf = assoc_array_leaf_to_ptr(object);\n\tedit->adjust_count_by = 1;\n\n\tswitch (assoc_array_walk(array, ops, index_key, &result)) {\n\tcase assoc_array_walk_tree_empty:\n\t\t \n\t\tif (!assoc_array_insert_in_empty_tree(edit))\n\t\t\tgoto enomem;\n\t\treturn edit;\n\n\tcase assoc_array_walk_found_terminal_node:\n\t\t \n\t\tif (!assoc_array_insert_into_terminal_node(edit, ops, index_key,\n\t\t\t\t\t\t\t   &result))\n\t\t\tgoto enomem;\n\t\treturn edit;\n\n\tcase assoc_array_walk_found_wrong_shortcut:\n\t\t \n\t\tif (!assoc_array_insert_mid_shortcut(edit, ops, &result))\n\t\t\tgoto enomem;\n\t\treturn edit;\n\t}\n\nenomem:\n\t \n\tpr_devel(\"enomem\\n\");\n\tassoc_array_cancel_edit(edit);\n\treturn ERR_PTR(-ENOMEM);\n}\n\n \nvoid assoc_array_insert_set_object(struct assoc_array_edit *edit, void *object)\n{\n\tBUG_ON(!object);\n\tedit->leaf = assoc_array_leaf_to_ptr(object);\n}\n\nstruct assoc_array_delete_collapse_context {\n\tstruct assoc_array_node\t*node;\n\tconst void\t\t*skip_leaf;\n\tint\t\t\tslot;\n};\n\n \nstatic int assoc_array_delete_collapse_iterator(const void *leaf,\n\t\t\t\t\t\tvoid *iterator_data)\n{\n\tstruct assoc_array_delete_collapse_context *collapse = iterator_data;\n\n\tif (leaf == collapse->skip_leaf)\n\t\treturn 0;\n\n\tBUG_ON(collapse->slot >= ASSOC_ARRAY_FAN_OUT);\n\n\tcollapse->node->slots[collapse->slot++] = assoc_array_leaf_to_ptr(leaf);\n\treturn 0;\n}\n\n \nstruct assoc_array_edit *assoc_array_delete(struct assoc_array *array,\n\t\t\t\t\t    const struct assoc_array_ops *ops,\n\t\t\t\t\t    const void *index_key)\n{\n\tstruct assoc_array_delete_collapse_context collapse;\n\tstruct assoc_array_walk_result result;\n\tstruct assoc_array_node *node, *new_n0;\n\tstruct assoc_array_edit *edit;\n\tstruct assoc_array_ptr *ptr;\n\tbool has_meta;\n\tint slot, i;\n\n\tpr_devel(\"-->%s()\\n\", __func__);\n\n\tedit = kzalloc(sizeof(struct assoc_array_edit), GFP_KERNEL);\n\tif (!edit)\n\t\treturn ERR_PTR(-ENOMEM);\n\tedit->array = array;\n\tedit->ops = ops;\n\tedit->adjust_count_by = -1;\n\n\tswitch (assoc_array_walk(array, ops, index_key, &result)) {\n\tcase assoc_array_walk_found_terminal_node:\n\t\t \n\t\tpr_devel(\"terminal_node\\n\");\n\t\tnode = result.terminal_node.node;\n\n\t\tfor (slot = 0; slot < ASSOC_ARRAY_FAN_OUT; slot++) {\n\t\t\tptr = node->slots[slot];\n\t\t\tif (ptr &&\n\t\t\t    assoc_array_ptr_is_leaf(ptr) &&\n\t\t\t    ops->compare_object(assoc_array_ptr_to_leaf(ptr),\n\t\t\t\t\t\tindex_key))\n\t\t\t\tgoto found_leaf;\n\t\t}\n\t\tfallthrough;\n\tcase assoc_array_walk_tree_empty:\n\tcase assoc_array_walk_found_wrong_shortcut:\n\tdefault:\n\t\tassoc_array_cancel_edit(edit);\n\t\tpr_devel(\"not found\\n\");\n\t\treturn NULL;\n\t}\n\nfound_leaf:\n\tBUG_ON(array->nr_leaves_on_tree <= 0);\n\n\t \n\tedit->dead_leaf = node->slots[slot];\n\tedit->set[0].ptr = &node->slots[slot];\n\tedit->set[0].to = NULL;\n\tedit->adjust_count_on = node;\n\n\t \n\tif (array->nr_leaves_on_tree == 1) {\n\t\tedit->set[1].ptr = &array->root;\n\t\tedit->set[1].to = NULL;\n\t\tedit->adjust_count_on = NULL;\n\t\tedit->excised_subtree = array->root;\n\t\tpr_devel(\"all gone\\n\");\n\t\treturn edit;\n\t}\n\n\t \n\tif (node->nr_leaves_on_branch <= ASSOC_ARRAY_FAN_OUT + 1) {\n\t\tstruct assoc_array_node *parent, *grandparent;\n\t\tstruct assoc_array_ptr *ptr;\n\n\t\t \n\t\thas_meta = false;\n\t\tfor (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++) {\n\t\t\tptr = node->slots[i];\n\t\t\tif (assoc_array_ptr_is_meta(ptr)) {\n\t\t\t\thas_meta = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tpr_devel(\"leaves: %ld [m=%d]\\n\",\n\t\t\t node->nr_leaves_on_branch - 1, has_meta);\n\n\t\t \n\t\tparent = node;\n\tcollapse_up:\n\t\tpr_devel(\"collapse subtree: %ld\\n\", parent->nr_leaves_on_branch);\n\n\t\tptr = parent->back_pointer;\n\t\tif (!ptr)\n\t\t\tgoto do_collapse;\n\t\tif (assoc_array_ptr_is_shortcut(ptr)) {\n\t\t\tstruct assoc_array_shortcut *s = assoc_array_ptr_to_shortcut(ptr);\n\t\t\tptr = s->back_pointer;\n\t\t\tif (!ptr)\n\t\t\t\tgoto do_collapse;\n\t\t}\n\n\t\tgrandparent = assoc_array_ptr_to_node(ptr);\n\t\tif (grandparent->nr_leaves_on_branch <= ASSOC_ARRAY_FAN_OUT + 1) {\n\t\t\tparent = grandparent;\n\t\t\tgoto collapse_up;\n\t\t}\n\n\tdo_collapse:\n\t\t \n\t\tif (has_meta || parent != node) {\n\t\t\tnode = parent;\n\n\t\t\t \n\t\t\tnew_n0 = kzalloc(sizeof(struct assoc_array_node), GFP_KERNEL);\n\t\t\tif (!new_n0)\n\t\t\t\tgoto enomem;\n\t\t\tedit->new_meta[0] = assoc_array_node_to_ptr(new_n0);\n\n\t\t\tnew_n0->back_pointer = node->back_pointer;\n\t\t\tnew_n0->parent_slot = node->parent_slot;\n\t\t\tnew_n0->nr_leaves_on_branch = node->nr_leaves_on_branch;\n\t\t\tedit->adjust_count_on = new_n0;\n\n\t\t\tcollapse.node = new_n0;\n\t\t\tcollapse.skip_leaf = assoc_array_ptr_to_leaf(edit->dead_leaf);\n\t\t\tcollapse.slot = 0;\n\t\t\tassoc_array_subtree_iterate(assoc_array_node_to_ptr(node),\n\t\t\t\t\t\t    node->back_pointer,\n\t\t\t\t\t\t    assoc_array_delete_collapse_iterator,\n\t\t\t\t\t\t    &collapse);\n\t\t\tpr_devel(\"collapsed %d,%lu\\n\", collapse.slot, new_n0->nr_leaves_on_branch);\n\t\t\tBUG_ON(collapse.slot != new_n0->nr_leaves_on_branch - 1);\n\n\t\t\tif (!node->back_pointer) {\n\t\t\t\tedit->set[1].ptr = &array->root;\n\t\t\t} else if (assoc_array_ptr_is_leaf(node->back_pointer)) {\n\t\t\t\tBUG();\n\t\t\t} else if (assoc_array_ptr_is_node(node->back_pointer)) {\n\t\t\t\tstruct assoc_array_node *p =\n\t\t\t\t\tassoc_array_ptr_to_node(node->back_pointer);\n\t\t\t\tedit->set[1].ptr = &p->slots[node->parent_slot];\n\t\t\t} else if (assoc_array_ptr_is_shortcut(node->back_pointer)) {\n\t\t\t\tstruct assoc_array_shortcut *s =\n\t\t\t\t\tassoc_array_ptr_to_shortcut(node->back_pointer);\n\t\t\t\tedit->set[1].ptr = &s->next_node;\n\t\t\t}\n\t\t\tedit->set[1].to = assoc_array_node_to_ptr(new_n0);\n\t\t\tedit->excised_subtree = assoc_array_node_to_ptr(node);\n\t\t}\n\t}\n\n\treturn edit;\n\nenomem:\n\t \n\tpr_devel(\"enomem\\n\");\n\tassoc_array_cancel_edit(edit);\n\treturn ERR_PTR(-ENOMEM);\n}\n\n \nstruct assoc_array_edit *assoc_array_clear(struct assoc_array *array,\n\t\t\t\t\t   const struct assoc_array_ops *ops)\n{\n\tstruct assoc_array_edit *edit;\n\n\tpr_devel(\"-->%s()\\n\", __func__);\n\n\tif (!array->root)\n\t\treturn NULL;\n\n\tedit = kzalloc(sizeof(struct assoc_array_edit), GFP_KERNEL);\n\tif (!edit)\n\t\treturn ERR_PTR(-ENOMEM);\n\tedit->array = array;\n\tedit->ops = ops;\n\tedit->set[1].ptr = &array->root;\n\tedit->set[1].to = NULL;\n\tedit->excised_subtree = array->root;\n\tedit->ops_for_excised_subtree = ops;\n\tpr_devel(\"all gone\\n\");\n\treturn edit;\n}\n\n \nstatic void assoc_array_rcu_cleanup(struct rcu_head *head)\n{\n\tstruct assoc_array_edit *edit =\n\t\tcontainer_of(head, struct assoc_array_edit, rcu);\n\tint i;\n\n\tpr_devel(\"-->%s()\\n\", __func__);\n\n\tif (edit->dead_leaf)\n\t\tedit->ops->free_object(assoc_array_ptr_to_leaf(edit->dead_leaf));\n\tfor (i = 0; i < ARRAY_SIZE(edit->excised_meta); i++)\n\t\tif (edit->excised_meta[i])\n\t\t\tkfree(assoc_array_ptr_to_node(edit->excised_meta[i]));\n\n\tif (edit->excised_subtree) {\n\t\tBUG_ON(assoc_array_ptr_is_leaf(edit->excised_subtree));\n\t\tif (assoc_array_ptr_is_node(edit->excised_subtree)) {\n\t\t\tstruct assoc_array_node *n =\n\t\t\t\tassoc_array_ptr_to_node(edit->excised_subtree);\n\t\t\tn->back_pointer = NULL;\n\t\t} else {\n\t\t\tstruct assoc_array_shortcut *s =\n\t\t\t\tassoc_array_ptr_to_shortcut(edit->excised_subtree);\n\t\t\ts->back_pointer = NULL;\n\t\t}\n\t\tassoc_array_destroy_subtree(edit->excised_subtree,\n\t\t\t\t\t    edit->ops_for_excised_subtree);\n\t}\n\n\tkfree(edit);\n}\n\n \nvoid assoc_array_apply_edit(struct assoc_array_edit *edit)\n{\n\tstruct assoc_array_shortcut *shortcut;\n\tstruct assoc_array_node *node;\n\tstruct assoc_array_ptr *ptr;\n\tint i;\n\n\tpr_devel(\"-->%s()\\n\", __func__);\n\n\tsmp_wmb();\n\tif (edit->leaf_p)\n\t\t*edit->leaf_p = edit->leaf;\n\n\tsmp_wmb();\n\tfor (i = 0; i < ARRAY_SIZE(edit->set_parent_slot); i++)\n\t\tif (edit->set_parent_slot[i].p)\n\t\t\t*edit->set_parent_slot[i].p = edit->set_parent_slot[i].to;\n\n\tsmp_wmb();\n\tfor (i = 0; i < ARRAY_SIZE(edit->set_backpointers); i++)\n\t\tif (edit->set_backpointers[i])\n\t\t\t*edit->set_backpointers[i] = edit->set_backpointers_to;\n\n\tsmp_wmb();\n\tfor (i = 0; i < ARRAY_SIZE(edit->set); i++)\n\t\tif (edit->set[i].ptr)\n\t\t\t*edit->set[i].ptr = edit->set[i].to;\n\n\tif (edit->array->root == NULL) {\n\t\tedit->array->nr_leaves_on_tree = 0;\n\t} else if (edit->adjust_count_on) {\n\t\tnode = edit->adjust_count_on;\n\t\tfor (;;) {\n\t\t\tnode->nr_leaves_on_branch += edit->adjust_count_by;\n\n\t\t\tptr = node->back_pointer;\n\t\t\tif (!ptr)\n\t\t\t\tbreak;\n\t\t\tif (assoc_array_ptr_is_shortcut(ptr)) {\n\t\t\t\tshortcut = assoc_array_ptr_to_shortcut(ptr);\n\t\t\t\tptr = shortcut->back_pointer;\n\t\t\t\tif (!ptr)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tBUG_ON(!assoc_array_ptr_is_node(ptr));\n\t\t\tnode = assoc_array_ptr_to_node(ptr);\n\t\t}\n\n\t\tedit->array->nr_leaves_on_tree += edit->adjust_count_by;\n\t}\n\n\tcall_rcu(&edit->rcu, assoc_array_rcu_cleanup);\n}\n\n \nvoid assoc_array_cancel_edit(struct assoc_array_edit *edit)\n{\n\tstruct assoc_array_ptr *ptr;\n\tint i;\n\n\tpr_devel(\"-->%s()\\n\", __func__);\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(edit->new_meta); i++) {\n\t\tptr = edit->new_meta[i];\n\t\tif (ptr) {\n\t\t\tif (assoc_array_ptr_is_node(ptr))\n\t\t\t\tkfree(assoc_array_ptr_to_node(ptr));\n\t\t\telse\n\t\t\t\tkfree(assoc_array_ptr_to_shortcut(ptr));\n\t\t}\n\t}\n\tkfree(edit);\n}\n\n \nint assoc_array_gc(struct assoc_array *array,\n\t\t   const struct assoc_array_ops *ops,\n\t\t   bool (*iterator)(void *object, void *iterator_data),\n\t\t   void *iterator_data)\n{\n\tstruct assoc_array_shortcut *shortcut, *new_s;\n\tstruct assoc_array_node *node, *new_n;\n\tstruct assoc_array_edit *edit;\n\tstruct assoc_array_ptr *cursor, *ptr;\n\tstruct assoc_array_ptr *new_root, *new_parent, **new_ptr_pp;\n\tunsigned long nr_leaves_on_tree;\n\tbool retained;\n\tint keylen, slot, nr_free, next_slot, i;\n\n\tpr_devel(\"-->%s()\\n\", __func__);\n\n\tif (!array->root)\n\t\treturn 0;\n\n\tedit = kzalloc(sizeof(struct assoc_array_edit), GFP_KERNEL);\n\tif (!edit)\n\t\treturn -ENOMEM;\n\tedit->array = array;\n\tedit->ops = ops;\n\tedit->ops_for_excised_subtree = ops;\n\tedit->set[0].ptr = &array->root;\n\tedit->excised_subtree = array->root;\n\n\tnew_root = new_parent = NULL;\n\tnew_ptr_pp = &new_root;\n\tcursor = array->root;\n\ndescend:\n\t \n\tif (assoc_array_ptr_is_shortcut(cursor)) {\n\t\tshortcut = assoc_array_ptr_to_shortcut(cursor);\n\t\tkeylen = round_up(shortcut->skip_to_level, ASSOC_ARRAY_KEY_CHUNK_SIZE);\n\t\tkeylen >>= ASSOC_ARRAY_KEY_CHUNK_SHIFT;\n\t\tnew_s = kmalloc(struct_size(new_s, index_key, keylen),\n\t\t\t\tGFP_KERNEL);\n\t\tif (!new_s)\n\t\t\tgoto enomem;\n\t\tpr_devel(\"dup shortcut %p -> %p\\n\", shortcut, new_s);\n\t\tmemcpy(new_s, shortcut, struct_size(new_s, index_key, keylen));\n\t\tnew_s->back_pointer = new_parent;\n\t\tnew_s->parent_slot = shortcut->parent_slot;\n\t\t*new_ptr_pp = new_parent = assoc_array_shortcut_to_ptr(new_s);\n\t\tnew_ptr_pp = &new_s->next_node;\n\t\tcursor = shortcut->next_node;\n\t}\n\n\t \n\tnode = assoc_array_ptr_to_node(cursor);\n\tnew_n = kzalloc(sizeof(struct assoc_array_node), GFP_KERNEL);\n\tif (!new_n)\n\t\tgoto enomem;\n\tpr_devel(\"dup node %p -> %p\\n\", node, new_n);\n\tnew_n->back_pointer = new_parent;\n\tnew_n->parent_slot = node->parent_slot;\n\t*new_ptr_pp = new_parent = assoc_array_node_to_ptr(new_n);\n\tnew_ptr_pp = NULL;\n\tslot = 0;\n\ncontinue_node:\n\t \n\tfor (; slot < ASSOC_ARRAY_FAN_OUT; slot++) {\n\t\tptr = node->slots[slot];\n\t\tif (!ptr)\n\t\t\tcontinue;\n\n\t\tif (assoc_array_ptr_is_leaf(ptr)) {\n\t\t\tif (iterator(assoc_array_ptr_to_leaf(ptr),\n\t\t\t\t     iterator_data))\n\t\t\t\t \n\t\t\t\tnew_n->slots[slot] = ptr;\n\t\t\tcontinue;\n\t\t}\n\n\t\tnew_ptr_pp = &new_n->slots[slot];\n\t\tcursor = ptr;\n\t\tgoto descend;\n\t}\n\nretry_compress:\n\tpr_devel(\"-- compress node %p --\\n\", new_n);\n\n\t \n\tnew_n->nr_leaves_on_branch = 0;\n\tnr_free = 0;\n\tfor (slot = 0; slot < ASSOC_ARRAY_FAN_OUT; slot++) {\n\t\tptr = new_n->slots[slot];\n\t\tif (!ptr)\n\t\t\tnr_free++;\n\t\telse if (assoc_array_ptr_is_leaf(ptr))\n\t\t\tnew_n->nr_leaves_on_branch++;\n\t}\n\tpr_devel(\"free=%d, leaves=%lu\\n\", nr_free, new_n->nr_leaves_on_branch);\n\n\t \n\tretained = false;\n\tnext_slot = 0;\n\tfor (slot = 0; slot < ASSOC_ARRAY_FAN_OUT; slot++) {\n\t\tstruct assoc_array_shortcut *s;\n\t\tstruct assoc_array_node *child;\n\n\t\tptr = new_n->slots[slot];\n\t\tif (!ptr || assoc_array_ptr_is_leaf(ptr))\n\t\t\tcontinue;\n\n\t\ts = NULL;\n\t\tif (assoc_array_ptr_is_shortcut(ptr)) {\n\t\t\ts = assoc_array_ptr_to_shortcut(ptr);\n\t\t\tptr = s->next_node;\n\t\t}\n\n\t\tchild = assoc_array_ptr_to_node(ptr);\n\t\tnew_n->nr_leaves_on_branch += child->nr_leaves_on_branch;\n\n\t\tif (child->nr_leaves_on_branch <= nr_free + 1) {\n\t\t\t \n\t\t\tpr_devel(\"[%d] fold node %lu/%d [nx %d]\\n\",\n\t\t\t\t slot, child->nr_leaves_on_branch, nr_free + 1,\n\t\t\t\t next_slot);\n\n\t\t\t \n\t\t\tBUG_ON(s);\n\n\t\t\tnew_n->slots[slot] = NULL;\n\t\t\tnr_free++;\n\t\t\tif (slot < next_slot)\n\t\t\t\tnext_slot = slot;\n\t\t\tfor (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++) {\n\t\t\t\tstruct assoc_array_ptr *p = child->slots[i];\n\t\t\t\tif (!p)\n\t\t\t\t\tcontinue;\n\t\t\t\tBUG_ON(assoc_array_ptr_is_meta(p));\n\t\t\t\twhile (new_n->slots[next_slot])\n\t\t\t\t\tnext_slot++;\n\t\t\t\tBUG_ON(next_slot >= ASSOC_ARRAY_FAN_OUT);\n\t\t\t\tnew_n->slots[next_slot++] = p;\n\t\t\t\tnr_free--;\n\t\t\t}\n\t\t\tkfree(child);\n\t\t} else {\n\t\t\tpr_devel(\"[%d] retain node %lu/%d [nx %d]\\n\",\n\t\t\t\t slot, child->nr_leaves_on_branch, nr_free + 1,\n\t\t\t\t next_slot);\n\t\t\tretained = true;\n\t\t}\n\t}\n\n\tif (retained && new_n->nr_leaves_on_branch <= ASSOC_ARRAY_FAN_OUT) {\n\t\tpr_devel(\"internal nodes remain despite enough space, retrying\\n\");\n\t\tgoto retry_compress;\n\t}\n\tpr_devel(\"after: %lu\\n\", new_n->nr_leaves_on_branch);\n\n\tnr_leaves_on_tree = new_n->nr_leaves_on_branch;\n\n\t \n\tif (nr_free == ASSOC_ARRAY_FAN_OUT - 1) {\n\t\tfor (slot = 0; slot < ASSOC_ARRAY_FAN_OUT; slot++)\n\t\t\tif ((ptr = new_n->slots[slot]))\n\t\t\t\tbreak;\n\n\t\tif (assoc_array_ptr_is_meta(ptr) &&\n\t\t    assoc_array_ptr_is_shortcut(ptr)) {\n\t\t\tpr_devel(\"excise node %p with 1 shortcut\\n\", new_n);\n\t\t\tnew_s = assoc_array_ptr_to_shortcut(ptr);\n\t\t\tnew_parent = new_n->back_pointer;\n\t\t\tslot = new_n->parent_slot;\n\t\t\tkfree(new_n);\n\t\t\tif (!new_parent) {\n\t\t\t\tnew_s->back_pointer = NULL;\n\t\t\t\tnew_s->parent_slot = 0;\n\t\t\t\tnew_root = ptr;\n\t\t\t\tgoto gc_complete;\n\t\t\t}\n\n\t\t\tif (assoc_array_ptr_is_shortcut(new_parent)) {\n\t\t\t\t \n\t\t\t\tstruct assoc_array_shortcut *s =\n\t\t\t\t\tassoc_array_ptr_to_shortcut(new_parent);\n\n\t\t\t\tpr_devel(\"excise preceding shortcut\\n\");\n\n\t\t\t\tnew_parent = new_s->back_pointer = s->back_pointer;\n\t\t\t\tslot = new_s->parent_slot = s->parent_slot;\n\t\t\t\tkfree(s);\n\t\t\t\tif (!new_parent) {\n\t\t\t\t\tnew_s->back_pointer = NULL;\n\t\t\t\t\tnew_s->parent_slot = 0;\n\t\t\t\t\tnew_root = ptr;\n\t\t\t\t\tgoto gc_complete;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tnew_s->back_pointer = new_parent;\n\t\t\tnew_s->parent_slot = slot;\n\t\t\tnew_n = assoc_array_ptr_to_node(new_parent);\n\t\t\tnew_n->slots[slot] = ptr;\n\t\t\tgoto ascend_old_tree;\n\t\t}\n\t}\n\n\t \n\tptr = new_n->back_pointer;\n\tif (!ptr)\n\t\tgoto gc_complete;\n\n\tif (assoc_array_ptr_is_shortcut(ptr)) {\n\t\tnew_s = assoc_array_ptr_to_shortcut(ptr);\n\t\tnew_parent = new_s->back_pointer;\n\t\tslot = new_s->parent_slot;\n\n\t\tif (new_n->nr_leaves_on_branch <= ASSOC_ARRAY_FAN_OUT) {\n\t\t\tstruct assoc_array_node *n;\n\n\t\t\tpr_devel(\"excise shortcut\\n\");\n\t\t\tnew_n->back_pointer = new_parent;\n\t\t\tnew_n->parent_slot = slot;\n\t\t\tkfree(new_s);\n\t\t\tif (!new_parent) {\n\t\t\t\tnew_root = assoc_array_node_to_ptr(new_n);\n\t\t\t\tgoto gc_complete;\n\t\t\t}\n\n\t\t\tn = assoc_array_ptr_to_node(new_parent);\n\t\t\tn->slots[slot] = assoc_array_node_to_ptr(new_n);\n\t\t}\n\t} else {\n\t\tnew_parent = ptr;\n\t}\n\tnew_n = assoc_array_ptr_to_node(new_parent);\n\nascend_old_tree:\n\tptr = node->back_pointer;\n\tif (assoc_array_ptr_is_shortcut(ptr)) {\n\t\tshortcut = assoc_array_ptr_to_shortcut(ptr);\n\t\tslot = shortcut->parent_slot;\n\t\tcursor = shortcut->back_pointer;\n\t\tif (!cursor)\n\t\t\tgoto gc_complete;\n\t} else {\n\t\tslot = node->parent_slot;\n\t\tcursor = ptr;\n\t}\n\tBUG_ON(!cursor);\n\tnode = assoc_array_ptr_to_node(cursor);\n\tslot++;\n\tgoto continue_node;\n\ngc_complete:\n\tedit->set[0].to = new_root;\n\tassoc_array_apply_edit(edit);\n\tarray->nr_leaves_on_tree = nr_leaves_on_tree;\n\treturn 0;\n\nenomem:\n\tpr_devel(\"enomem\\n\");\n\tassoc_array_destroy_subtree(new_root, edit->ops);\n\tkfree(edit);\n\treturn -ENOMEM;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}