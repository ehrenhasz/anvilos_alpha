{
  "module_name": "pldmfw.c",
  "hash_id": "a3bcec8b9b94cdb5f9acdee42113dd2f4df9ac980154ddddae165f0ce5302471",
  "original_prompt": "Ingested from linux-6.6.14/lib/pldmfw/pldmfw.c",
  "human_readable_source": "\n \n\n#include <asm/unaligned.h>\n#include <linux/crc32.h>\n#include <linux/device.h>\n#include <linux/firmware.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/pldmfw.h>\n#include <linux/slab.h>\n#include <linux/uuid.h>\n\n#include \"pldmfw_private.h\"\n\n \nstruct pldmfw_priv {\n\tstruct pldmfw *context;\n\tconst struct firmware *fw;\n\n\t \n\tsize_t offset;\n\n\tstruct list_head records;\n\tstruct list_head components;\n\n\t \n\tconst struct __pldm_header *header;\n\tu16 total_header_size;\n\n\t \n\tu16 component_bitmap_len;\n\tu16 bitmap_size;\n\n\t \n\tu16 component_count;\n\tconst u8 *component_start;\n\n\t \n\tconst u8 *record_start;\n\tu8 record_count;\n\n\t \n\tu32 header_crc;\n\n\tstruct pldmfw_record *matching_record;\n};\n\n \nstatic int\npldm_check_fw_space(struct pldmfw_priv *data, size_t offset, size_t length)\n{\n\tsize_t expected_size = offset + length;\n\tstruct device *dev = data->context->dev;\n\n\tif (data->fw->size < expected_size) {\n\t\tdev_dbg(dev, \"Firmware file size smaller than expected. Got %zu bytes, needed %zu bytes\\n\",\n\t\t\tdata->fw->size, expected_size);\n\t\treturn -EFAULT;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int\npldm_move_fw_offset(struct pldmfw_priv *data, size_t bytes_to_move)\n{\n\tint err;\n\n\terr = pldm_check_fw_space(data, data->offset, bytes_to_move);\n\tif (err)\n\t\treturn err;\n\n\tdata->offset += bytes_to_move;\n\n\treturn 0;\n}\n\n \nstatic int pldm_parse_header(struct pldmfw_priv *data)\n{\n\tconst struct __pldmfw_record_area *record_area;\n\tstruct device *dev = data->context->dev;\n\tconst struct __pldm_header *header;\n\tsize_t header_size;\n\tint err;\n\n\terr = pldm_move_fw_offset(data, sizeof(*header));\n\tif (err)\n\t\treturn err;\n\n\theader = (const struct __pldm_header *)data->fw->data;\n\tdata->header = header;\n\n\tif (!uuid_equal(&header->id, &pldm_firmware_header_id)) {\n\t\tdev_dbg(dev, \"Invalid package header identifier. Expected UUID %pUB, but got %pUB\\n\",\n\t\t\t&pldm_firmware_header_id, &header->id);\n\t\treturn -EINVAL;\n\t}\n\n\tif (header->revision != PACKAGE_HEADER_FORMAT_REVISION) {\n\t\tdev_dbg(dev, \"Invalid package header revision. Expected revision %u but got %u\\n\",\n\t\t\tPACKAGE_HEADER_FORMAT_REVISION, header->revision);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tdata->total_header_size = get_unaligned_le16(&header->size);\n\theader_size = data->total_header_size - sizeof(*header);\n\n\terr = pldm_check_fw_space(data, data->offset, header_size);\n\tif (err)\n\t\treturn err;\n\n\tdata->component_bitmap_len =\n\t\tget_unaligned_le16(&header->component_bitmap_len);\n\n\tif (data->component_bitmap_len % 8 != 0) {\n\t\tdev_dbg(dev, \"Invalid component bitmap length. The length is %u, which is not a multiple of 8\\n\",\n\t\t\tdata->component_bitmap_len);\n\t\treturn -EINVAL;\n\t}\n\n\tdata->bitmap_size = data->component_bitmap_len / 8;\n\n\terr = pldm_move_fw_offset(data, header->version_len);\n\tif (err)\n\t\treturn err;\n\n\t \n\trecord_area = (const struct __pldmfw_record_area *)(data->fw->data +\n\t\t\t\t\t\t\t data->offset);\n\n\terr = pldm_move_fw_offset(data, sizeof(*record_area));\n\tif (err)\n\t\treturn err;\n\n\tdata->record_count = record_area->record_count;\n\tdata->record_start = record_area->records;\n\n\treturn 0;\n}\n\n \nstatic int\npldm_check_desc_tlv_len(struct pldmfw_priv *data, u16 type, u16 size)\n{\n\tstruct device *dev = data->context->dev;\n\tu16 expected_size;\n\n\tswitch (type) {\n\tcase PLDM_DESC_ID_PCI_VENDOR_ID:\n\tcase PLDM_DESC_ID_PCI_DEVICE_ID:\n\tcase PLDM_DESC_ID_PCI_SUBVENDOR_ID:\n\tcase PLDM_DESC_ID_PCI_SUBDEV_ID:\n\t\texpected_size = 2;\n\t\tbreak;\n\tcase PLDM_DESC_ID_PCI_REVISION_ID:\n\t\texpected_size = 1;\n\t\tbreak;\n\tcase PLDM_DESC_ID_PNP_VENDOR_ID:\n\t\texpected_size = 3;\n\t\tbreak;\n\tcase PLDM_DESC_ID_IANA_ENTERPRISE_ID:\n\tcase PLDM_DESC_ID_ACPI_VENDOR_ID:\n\tcase PLDM_DESC_ID_PNP_PRODUCT_ID:\n\tcase PLDM_DESC_ID_ACPI_PRODUCT_ID:\n\t\texpected_size = 4;\n\t\tbreak;\n\tcase PLDM_DESC_ID_UUID:\n\t\texpected_size = 16;\n\t\tbreak;\n\tcase PLDM_DESC_ID_VENDOR_DEFINED:\n\t\treturn 0;\n\tdefault:\n\t\t \n\t\tdev_dbg(dev, \"Found unrecognized TLV type 0x%04x\\n\", type);\n\t\treturn 0;\n\t}\n\n\tif (size != expected_size) {\n\t\tdev_dbg(dev, \"Found TLV type 0x%04x with unexpected length. Got %u bytes, but expected %u bytes\\n\",\n\t\t\ttype, size, expected_size);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int\npldm_parse_desc_tlvs(struct pldmfw_priv *data, struct pldmfw_record *record, u8 desc_count)\n{\n\tconst struct __pldmfw_desc_tlv *__desc;\n\tconst u8 *desc_start;\n\tu8 i;\n\n\tdesc_start = data->fw->data + data->offset;\n\n\tpldm_for_each_desc_tlv(i, __desc, desc_start, desc_count) {\n\t\tstruct pldmfw_desc_tlv *desc;\n\t\tint err;\n\t\tu16 type, size;\n\n\t\terr = pldm_move_fw_offset(data, sizeof(*__desc));\n\t\tif (err)\n\t\t\treturn err;\n\n\t\ttype = get_unaligned_le16(&__desc->type);\n\n\t\t \n\t\tsize = get_unaligned_le16(&__desc->size);\n\n\t\terr = pldm_check_desc_tlv_len(data, type, size);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\t \n\t\terr = pldm_move_fw_offset(data, size);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tdesc = kzalloc(sizeof(*desc), GFP_KERNEL);\n\t\tif (!desc)\n\t\t\treturn -ENOMEM;\n\n\t\tdesc->type = type;\n\t\tdesc->size = size;\n\t\tdesc->data = __desc->data;\n\n\t\tlist_add_tail(&desc->entry, &record->descs);\n\t}\n\n\treturn 0;\n}\n\n \nstatic int\npldm_parse_one_record(struct pldmfw_priv *data,\n\t\t      const struct __pldmfw_record_info *__record)\n{\n\tstruct pldmfw_record *record;\n\tsize_t measured_length;\n\tint err;\n\tconst u8 *bitmap_ptr;\n\tu16 record_len;\n\tint i;\n\n\t \n\trecord = kzalloc(sizeof(*record), GFP_KERNEL);\n\tif (!record)\n\t\treturn -ENOMEM;\n\n\tINIT_LIST_HEAD(&record->descs);\n\tlist_add_tail(&record->entry, &data->records);\n\n\t \n\terr = pldm_move_fw_offset(data, sizeof(*__record));\n\tif (err)\n\t\treturn err;\n\n\trecord_len = get_unaligned_le16(&__record->record_len);\n\trecord->package_data_len = get_unaligned_le16(&__record->package_data_len);\n\trecord->version_len = __record->version_len;\n\trecord->version_type = __record->version_type;\n\n\tbitmap_ptr = data->fw->data + data->offset;\n\n\t \n\terr = pldm_move_fw_offset(data, data->bitmap_size);\n\tif (err)\n\t\treturn err;\n\n\trecord->component_bitmap_len = data->component_bitmap_len;\n\trecord->component_bitmap = bitmap_zalloc(record->component_bitmap_len,\n\t\t\t\t\t\t GFP_KERNEL);\n\tif (!record->component_bitmap)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < data->bitmap_size; i++)\n\t\tbitmap_set_value8(record->component_bitmap, bitmap_ptr[i], i * 8);\n\n\trecord->version_string = data->fw->data + data->offset;\n\n\terr = pldm_move_fw_offset(data, record->version_len);\n\tif (err)\n\t\treturn err;\n\n\t \n\terr = pldm_parse_desc_tlvs(data, record, __record->descriptor_count);\n\tif (err)\n\t\treturn err;\n\n\trecord->package_data = data->fw->data + data->offset;\n\n\terr = pldm_move_fw_offset(data, record->package_data_len);\n\tif (err)\n\t\treturn err;\n\n\tmeasured_length = data->offset - ((const u8 *)__record - data->fw->data);\n\tif (measured_length != record_len) {\n\t\tdev_dbg(data->context->dev, \"Unexpected record length. Measured record length is %zu bytes, expected length is %u bytes\\n\",\n\t\t\tmeasured_length, record_len);\n\t\treturn -EFAULT;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int pldm_parse_records(struct pldmfw_priv *data)\n{\n\tconst struct __pldmfw_component_area *component_area;\n\tconst struct __pldmfw_record_info *record;\n\tint err;\n\tu8 i;\n\n\tpldm_for_each_record(i, record, data->record_start, data->record_count) {\n\t\terr = pldm_parse_one_record(data, record);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\t \n\tcomponent_area = (const struct __pldmfw_component_area *)(data->fw->data + data->offset);\n\n\terr = pldm_move_fw_offset(data, sizeof(*component_area));\n\tif (err)\n\t\treturn err;\n\n\tdata->component_count =\n\t\tget_unaligned_le16(&component_area->component_image_count);\n\tdata->component_start = component_area->components;\n\n\treturn 0;\n}\n\n \nstatic int pldm_parse_components(struct pldmfw_priv *data)\n{\n\tconst struct __pldmfw_component_info *__component;\n\tstruct device *dev = data->context->dev;\n\tconst u8 *header_crc_ptr;\n\tint err;\n\tu8 i;\n\n\tpldm_for_each_component(i, __component, data->component_start, data->component_count) {\n\t\tstruct pldmfw_component *component;\n\t\tu32 offset, size;\n\n\t\terr = pldm_move_fw_offset(data, sizeof(*__component));\n\t\tif (err)\n\t\t\treturn err;\n\n\t\terr = pldm_move_fw_offset(data, __component->version_len);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\toffset = get_unaligned_le32(&__component->location_offset);\n\t\tsize = get_unaligned_le32(&__component->size);\n\n\t\terr = pldm_check_fw_space(data, offset, size);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tcomponent = kzalloc(sizeof(*component), GFP_KERNEL);\n\t\tif (!component)\n\t\t\treturn -ENOMEM;\n\n\t\tcomponent->index = i;\n\t\tcomponent->classification = get_unaligned_le16(&__component->classification);\n\t\tcomponent->identifier = get_unaligned_le16(&__component->identifier);\n\t\tcomponent->comparison_stamp = get_unaligned_le32(&__component->comparison_stamp);\n\t\tcomponent->options = get_unaligned_le16(&__component->options);\n\t\tcomponent->activation_method = get_unaligned_le16(&__component->activation_method);\n\t\tcomponent->version_type = __component->version_type;\n\t\tcomponent->version_len = __component->version_len;\n\t\tcomponent->version_string = __component->version_string;\n\t\tcomponent->component_data = data->fw->data + offset;\n\t\tcomponent->component_size = size;\n\n\t\tlist_add_tail(&component->entry, &data->components);\n\t}\n\n\theader_crc_ptr = data->fw->data + data->offset;\n\n\terr = pldm_move_fw_offset(data, sizeof(data->header_crc));\n\tif (err)\n\t\treturn err;\n\n\t \n\tif (data->offset != data->total_header_size) {\n\t\tdev_dbg(dev, \"Invalid firmware header size. Expected %u but got %zu\\n\",\n\t\t\tdata->total_header_size, data->offset);\n\t\treturn -EFAULT;\n\t}\n\n\tdata->header_crc = get_unaligned_le32(header_crc_ptr);\n\n\treturn 0;\n}\n\n \nstatic int pldm_verify_header_crc(struct pldmfw_priv *data)\n{\n\tstruct device *dev = data->context->dev;\n\tu32 calculated_crc;\n\tsize_t length;\n\n\t \n\tlength = data->offset - sizeof(data->header_crc);\n\tcalculated_crc = crc32_le(~0, data->fw->data, length) ^ ~0;\n\n\tif (calculated_crc != data->header_crc) {\n\t\tdev_dbg(dev, \"Invalid CRC in firmware header. Got 0x%08x but expected 0x%08x\\n\",\n\t\t\tcalculated_crc, data->header_crc);\n\t\treturn -EBADMSG;\n\t}\n\n\treturn 0;\n}\n\n \nstatic void pldmfw_free_priv(struct pldmfw_priv *data)\n{\n\tstruct pldmfw_component *component, *c_safe;\n\tstruct pldmfw_record *record, *r_safe;\n\tstruct pldmfw_desc_tlv *desc, *d_safe;\n\n\tlist_for_each_entry_safe(component, c_safe, &data->components, entry) {\n\t\tlist_del(&component->entry);\n\t\tkfree(component);\n\t}\n\n\tlist_for_each_entry_safe(record, r_safe, &data->records, entry) {\n\t\tlist_for_each_entry_safe(desc, d_safe, &record->descs, entry) {\n\t\t\tlist_del(&desc->entry);\n\t\t\tkfree(desc);\n\t\t}\n\n\t\tif (record->component_bitmap) {\n\t\t\tbitmap_free(record->component_bitmap);\n\t\t\trecord->component_bitmap = NULL;\n\t\t}\n\n\t\tlist_del(&record->entry);\n\t\tkfree(record);\n\t}\n}\n\n \nstatic int pldm_parse_image(struct pldmfw_priv *data)\n{\n\tint err;\n\n\tif (WARN_ON(!(data->context->dev && data->fw->data && data->fw->size)))\n\t\treturn -EINVAL;\n\n\terr = pldm_parse_header(data);\n\tif (err)\n\t\treturn err;\n\n\terr = pldm_parse_records(data);\n\tif (err)\n\t\treturn err;\n\n\terr = pldm_parse_components(data);\n\tif (err)\n\t\treturn err;\n\n\treturn pldm_verify_header_crc(data);\n}\n\n \nstruct pldm_pci_record_id {\n\tint vendor;\n\tint device;\n\tint subsystem_vendor;\n\tint subsystem_device;\n};\n\n \nbool pldmfw_op_pci_match_record(struct pldmfw *context, struct pldmfw_record *record)\n{\n\tstruct pci_dev *pdev = to_pci_dev(context->dev);\n\tstruct pldm_pci_record_id id = {\n\t\t.vendor = PCI_ANY_ID,\n\t\t.device = PCI_ANY_ID,\n\t\t.subsystem_vendor = PCI_ANY_ID,\n\t\t.subsystem_device = PCI_ANY_ID,\n\t};\n\tstruct pldmfw_desc_tlv *desc;\n\n\tlist_for_each_entry(desc, &record->descs, entry) {\n\t\tu16 value;\n\t\tint *ptr;\n\n\t\tswitch (desc->type) {\n\t\tcase PLDM_DESC_ID_PCI_VENDOR_ID:\n\t\t\tptr = &id.vendor;\n\t\t\tbreak;\n\t\tcase PLDM_DESC_ID_PCI_DEVICE_ID:\n\t\t\tptr = &id.device;\n\t\t\tbreak;\n\t\tcase PLDM_DESC_ID_PCI_SUBVENDOR_ID:\n\t\t\tptr = &id.subsystem_vendor;\n\t\t\tbreak;\n\t\tcase PLDM_DESC_ID_PCI_SUBDEV_ID:\n\t\t\tptr = &id.subsystem_device;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t \n\t\t\tcontinue;\n\t\t}\n\n\t\tvalue = get_unaligned_le16(desc->data);\n\t\t \n\t\tif (value)\n\t\t\t*ptr = (int)value;\n\t\telse\n\t\t\t*ptr = PCI_ANY_ID;\n\t}\n\n\tif ((id.vendor == PCI_ANY_ID || id.vendor == pdev->vendor) &&\n\t    (id.device == PCI_ANY_ID || id.device == pdev->device) &&\n\t    (id.subsystem_vendor == PCI_ANY_ID || id.subsystem_vendor == pdev->subsystem_vendor) &&\n\t    (id.subsystem_device == PCI_ANY_ID || id.subsystem_device == pdev->subsystem_device))\n\t\treturn true;\n\telse\n\t\treturn false;\n}\nEXPORT_SYMBOL(pldmfw_op_pci_match_record);\n\n \nstatic int pldm_find_matching_record(struct pldmfw_priv *data)\n{\n\tstruct pldmfw_record *record;\n\n\tlist_for_each_entry(record, &data->records, entry) {\n\t\tif (data->context->ops->match_record(data->context, record)) {\n\t\t\tdata->matching_record = record;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -ENOENT;\n}\n\n \nstatic int\npldm_send_package_data(struct pldmfw_priv *data)\n{\n\tstruct pldmfw_record *record = data->matching_record;\n\tconst struct pldmfw_ops *ops = data->context->ops;\n\n\treturn ops->send_package_data(data->context, record->package_data,\n\t\t\t\t      record->package_data_len);\n}\n\n \nstatic int\npldm_send_component_tables(struct pldmfw_priv *data)\n{\n\tunsigned long *bitmap = data->matching_record->component_bitmap;\n\tstruct pldmfw_component *component;\n\tint err;\n\n\tlist_for_each_entry(component, &data->components, entry) {\n\t\tu8 index = component->index, transfer_flag = 0;\n\n\t\t \n\t\tif (!test_bit(index, bitmap))\n\t\t\tcontinue;\n\n\t\t \n\t\tif (index == find_first_bit(bitmap, data->component_bitmap_len))\n\t\t\ttransfer_flag |= PLDM_TRANSFER_FLAG_START;\n\t\tif (index == find_last_bit(bitmap, data->component_bitmap_len))\n\t\t\ttransfer_flag |= PLDM_TRANSFER_FLAG_END;\n\t\tif (!transfer_flag)\n\t\t\ttransfer_flag = PLDM_TRANSFER_FLAG_MIDDLE;\n\n\t\terr = data->context->ops->send_component_table(data->context,\n\t\t\t\t\t\t\t       component,\n\t\t\t\t\t\t\t       transfer_flag);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int pldm_flash_components(struct pldmfw_priv *data)\n{\n\tunsigned long *bitmap = data->matching_record->component_bitmap;\n\tstruct pldmfw_component *component;\n\tint err;\n\n\tlist_for_each_entry(component, &data->components, entry) {\n\t\tu8 index = component->index;\n\n\t\t \n\t\tif (!test_bit(index, bitmap))\n\t\t\tcontinue;\n\n\t\terr = data->context->ops->flash_component(data->context, component);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int pldm_finalize_update(struct pldmfw_priv *data)\n{\n\tif (data->context->ops->finalize_update)\n\t\treturn data->context->ops->finalize_update(data->context);\n\n\treturn 0;\n}\n\n \nint pldmfw_flash_image(struct pldmfw *context, const struct firmware *fw)\n{\n\tstruct pldmfw_priv *data;\n\tint err;\n\n\tdata = kzalloc(sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tINIT_LIST_HEAD(&data->records);\n\tINIT_LIST_HEAD(&data->components);\n\n\tdata->fw = fw;\n\tdata->context = context;\n\n\terr = pldm_parse_image(data);\n\tif (err)\n\t\tgoto out_release_data;\n\n\terr = pldm_find_matching_record(data);\n\tif (err)\n\t\tgoto out_release_data;\n\n\terr = pldm_send_package_data(data);\n\tif (err)\n\t\tgoto out_release_data;\n\n\terr = pldm_send_component_tables(data);\n\tif (err)\n\t\tgoto out_release_data;\n\n\terr = pldm_flash_components(data);\n\tif (err)\n\t\tgoto out_release_data;\n\n\terr = pldm_finalize_update(data);\n\nout_release_data:\n\tpldmfw_free_priv(data);\n\tkfree(data);\n\n\treturn err;\n}\nEXPORT_SYMBOL(pldmfw_flash_image);\n\nMODULE_AUTHOR(\"Jacob Keller <jacob.e.keller@intel.com>\");\nMODULE_DESCRIPTION(\"PLDM firmware flash update library\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}