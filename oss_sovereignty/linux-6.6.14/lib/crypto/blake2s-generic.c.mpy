{
  "module_name": "blake2s-generic.c",
  "hash_id": "e2d6da1d3f1e5f686bcd399ddb7f574443589faaf5da543957976870a6e343ee",
  "original_prompt": "Ingested from linux-6.6.14/lib/crypto/blake2s-generic.c",
  "human_readable_source": "\n \n\n#include <crypto/internal/blake2s.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/bug.h>\n#include <asm/unaligned.h>\n\nstatic const u8 blake2s_sigma[10][16] = {\n\t{ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 },\n\t{ 14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3 },\n\t{ 11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4 },\n\t{ 7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8 },\n\t{ 9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13 },\n\t{ 2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9 },\n\t{ 12, 5, 1, 15, 14, 13, 4, 10, 0, 7, 6, 3, 9, 2, 8, 11 },\n\t{ 13, 11, 7, 14, 12, 1, 3, 9, 5, 0, 15, 4, 8, 6, 2, 10 },\n\t{ 6, 15, 14, 9, 11, 3, 0, 8, 12, 2, 13, 7, 1, 4, 10, 5 },\n\t{ 10, 2, 8, 4, 7, 6, 1, 5, 15, 11, 9, 14, 3, 12, 13, 0 },\n};\n\nstatic inline void blake2s_increment_counter(struct blake2s_state *state,\n\t\t\t\t\t     const u32 inc)\n{\n\tstate->t[0] += inc;\n\tstate->t[1] += (state->t[0] < inc);\n}\n\nvoid blake2s_compress(struct blake2s_state *state, const u8 *block,\n\t\t      size_t nblocks, const u32 inc)\n\t\t      __weak __alias(blake2s_compress_generic);\n\nvoid blake2s_compress_generic(struct blake2s_state *state, const u8 *block,\n\t\t\t      size_t nblocks, const u32 inc)\n{\n\tu32 m[16];\n\tu32 v[16];\n\tint i;\n\n\tWARN_ON(IS_ENABLED(DEBUG) &&\n\t\t(nblocks > 1 && inc != BLAKE2S_BLOCK_SIZE));\n\n\twhile (nblocks > 0) {\n\t\tblake2s_increment_counter(state, inc);\n\t\tmemcpy(m, block, BLAKE2S_BLOCK_SIZE);\n\t\tle32_to_cpu_array(m, ARRAY_SIZE(m));\n\t\tmemcpy(v, state->h, 32);\n\t\tv[ 8] = BLAKE2S_IV0;\n\t\tv[ 9] = BLAKE2S_IV1;\n\t\tv[10] = BLAKE2S_IV2;\n\t\tv[11] = BLAKE2S_IV3;\n\t\tv[12] = BLAKE2S_IV4 ^ state->t[0];\n\t\tv[13] = BLAKE2S_IV5 ^ state->t[1];\n\t\tv[14] = BLAKE2S_IV6 ^ state->f[0];\n\t\tv[15] = BLAKE2S_IV7 ^ state->f[1];\n\n#define G(r, i, a, b, c, d) do { \\\n\ta += b + m[blake2s_sigma[r][2 * i + 0]]; \\\n\td = ror32(d ^ a, 16); \\\n\tc += d; \\\n\tb = ror32(b ^ c, 12); \\\n\ta += b + m[blake2s_sigma[r][2 * i + 1]]; \\\n\td = ror32(d ^ a, 8); \\\n\tc += d; \\\n\tb = ror32(b ^ c, 7); \\\n} while (0)\n\n#define ROUND(r) do { \\\n\tG(r, 0, v[0], v[ 4], v[ 8], v[12]); \\\n\tG(r, 1, v[1], v[ 5], v[ 9], v[13]); \\\n\tG(r, 2, v[2], v[ 6], v[10], v[14]); \\\n\tG(r, 3, v[3], v[ 7], v[11], v[15]); \\\n\tG(r, 4, v[0], v[ 5], v[10], v[15]); \\\n\tG(r, 5, v[1], v[ 6], v[11], v[12]); \\\n\tG(r, 6, v[2], v[ 7], v[ 8], v[13]); \\\n\tG(r, 7, v[3], v[ 4], v[ 9], v[14]); \\\n} while (0)\n\t\tROUND(0);\n\t\tROUND(1);\n\t\tROUND(2);\n\t\tROUND(3);\n\t\tROUND(4);\n\t\tROUND(5);\n\t\tROUND(6);\n\t\tROUND(7);\n\t\tROUND(8);\n\t\tROUND(9);\n\n#undef G\n#undef ROUND\n\n\t\tfor (i = 0; i < 8; ++i)\n\t\t\tstate->h[i] ^= v[i] ^ v[i + 8];\n\n\t\tblock += BLAKE2S_BLOCK_SIZE;\n\t\t--nblocks;\n\t}\n}\n\nEXPORT_SYMBOL(blake2s_compress_generic);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}