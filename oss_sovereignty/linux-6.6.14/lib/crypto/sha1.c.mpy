{
  "module_name": "sha1.c",
  "hash_id": "f6c6108f28bf34731ca1da18530fa702caa96f54784897085ab1ace2433efc2c",
  "original_prompt": "Ingested from linux-6.6.14/lib/crypto/sha1.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/module.h>\n#include <linux/bitops.h>\n#include <linux/string.h>\n#include <crypto/sha1.h>\n#include <asm/unaligned.h>\n\n \n\n#ifdef CONFIG_X86\n  #define setW(x, val) (*(volatile __u32 *)&W(x) = (val))\n#elif defined(CONFIG_ARM)\n  #define setW(x, val) do { W(x) = (val); __asm__(\"\":::\"memory\"); } while (0)\n#else\n  #define setW(x, val) (W(x) = (val))\n#endif\n\n \n#define W(x) (array[(x)&15])\n\n \n#define SHA_SRC(t) get_unaligned_be32((__u32 *)data + t)\n#define SHA_MIX(t) rol32(W(t+13) ^ W(t+8) ^ W(t+2) ^ W(t), 1)\n\n#define SHA_ROUND(t, input, fn, constant, A, B, C, D, E) do { \\\n\t__u32 TEMP = input(t); setW(t, TEMP); \\\n\tE += TEMP + rol32(A,5) + (fn) + (constant); \\\n\tB = ror32(B, 2); \\\n\tTEMP = E; E = D; D = C; C = B; B = A; A = TEMP; } while (0)\n\n#define T_0_15(t, A, B, C, D, E)  SHA_ROUND(t, SHA_SRC, (((C^D)&B)^D) , 0x5a827999, A, B, C, D, E )\n#define T_16_19(t, A, B, C, D, E) SHA_ROUND(t, SHA_MIX, (((C^D)&B)^D) , 0x5a827999, A, B, C, D, E )\n#define T_20_39(t, A, B, C, D, E) SHA_ROUND(t, SHA_MIX, (B^C^D) , 0x6ed9eba1, A, B, C, D, E )\n#define T_40_59(t, A, B, C, D, E) SHA_ROUND(t, SHA_MIX, ((B&C)+(D&(B^C))) , 0x8f1bbcdc, A, B, C, D, E )\n#define T_60_79(t, A, B, C, D, E) SHA_ROUND(t, SHA_MIX, (B^C^D) ,  0xca62c1d6, A, B, C, D, E )\n\n \nvoid sha1_transform(__u32 *digest, const char *data, __u32 *array)\n{\n\t__u32 A, B, C, D, E;\n\tunsigned int i = 0;\n\n\tA = digest[0];\n\tB = digest[1];\n\tC = digest[2];\n\tD = digest[3];\n\tE = digest[4];\n\n\t \n\tfor (; i < 16; ++i)\n\t\tT_0_15(i, A, B, C, D, E);\n\n\t \n\tfor (; i < 20; ++i)\n\t\tT_16_19(i, A, B, C, D, E);\n\n\t \n\tfor (; i < 40; ++i)\n\t\tT_20_39(i, A, B, C, D, E);\n\n\t \n\tfor (; i < 60; ++i)\n\t\tT_40_59(i, A, B, C, D, E);\n\n\t \n\tfor (; i < 80; ++i)\n\t\tT_60_79(i, A, B, C, D, E);\n\n\tdigest[0] += A;\n\tdigest[1] += B;\n\tdigest[2] += C;\n\tdigest[3] += D;\n\tdigest[4] += E;\n}\nEXPORT_SYMBOL(sha1_transform);\n\n \nvoid sha1_init(__u32 *buf)\n{\n\tbuf[0] = 0x67452301;\n\tbuf[1] = 0xefcdab89;\n\tbuf[2] = 0x98badcfe;\n\tbuf[3] = 0x10325476;\n\tbuf[4] = 0xc3d2e1f0;\n}\nEXPORT_SYMBOL(sha1_init);\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}