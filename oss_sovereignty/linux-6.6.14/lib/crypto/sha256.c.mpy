{
  "module_name": "sha256.c",
  "hash_id": "c8cc4b35bd2e2da1554800bd9b42556e628215316b9e67a3abf6cd66de96dc76",
  "original_prompt": "Ingested from linux-6.6.14/lib/crypto/sha256.c",
  "human_readable_source": "\n \n\n#include <asm/unaligned.h>\n#include <crypto/sha256_base.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/string.h>\n\nstatic const u32 SHA256_K[] = {\n\t0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,\n\t0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n\t0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,\n\t0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n\t0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,\n\t0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n\t0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,\n\t0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n\t0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,\n\t0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n\t0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,\n\t0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n\t0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,\n\t0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n\t0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,\n\t0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2,\n};\n\nstatic inline u32 Ch(u32 x, u32 y, u32 z)\n{\n\treturn z ^ (x & (y ^ z));\n}\n\nstatic inline u32 Maj(u32 x, u32 y, u32 z)\n{\n\treturn (x & y) | (z & (x | y));\n}\n\n#define e0(x)       (ror32(x, 2) ^ ror32(x, 13) ^ ror32(x, 22))\n#define e1(x)       (ror32(x, 6) ^ ror32(x, 11) ^ ror32(x, 25))\n#define s0(x)       (ror32(x, 7) ^ ror32(x, 18) ^ (x >> 3))\n#define s1(x)       (ror32(x, 17) ^ ror32(x, 19) ^ (x >> 10))\n\nstatic inline void LOAD_OP(int I, u32 *W, const u8 *input)\n{\n\tW[I] = get_unaligned_be32((__u32 *)input + I);\n}\n\nstatic inline void BLEND_OP(int I, u32 *W)\n{\n\tW[I] = s1(W[I-2]) + W[I-7] + s0(W[I-15]) + W[I-16];\n}\n\n#define SHA256_ROUND(i, a, b, c, d, e, f, g, h) do {\t\t\\\n\tu32 t1, t2;\t\t\t\t\t\t\\\n\tt1 = h + e1(e) + Ch(e, f, g) + SHA256_K[i] + W[i];\t\\\n\tt2 = e0(a) + Maj(a, b, c);\t\t\t\t\\\n\td += t1;\t\t\t\t\t\t\\\n\th = t1 + t2;\t\t\t\t\t\t\\\n} while (0)\n\nstatic void sha256_transform(u32 *state, const u8 *input, u32 *W)\n{\n\tu32 a, b, c, d, e, f, g, h;\n\tint i;\n\n\t \n\tfor (i = 0; i < 16; i += 8) {\n\t\tLOAD_OP(i + 0, W, input);\n\t\tLOAD_OP(i + 1, W, input);\n\t\tLOAD_OP(i + 2, W, input);\n\t\tLOAD_OP(i + 3, W, input);\n\t\tLOAD_OP(i + 4, W, input);\n\t\tLOAD_OP(i + 5, W, input);\n\t\tLOAD_OP(i + 6, W, input);\n\t\tLOAD_OP(i + 7, W, input);\n\t}\n\n\t \n\tfor (i = 16; i < 64; i += 8) {\n\t\tBLEND_OP(i + 0, W);\n\t\tBLEND_OP(i + 1, W);\n\t\tBLEND_OP(i + 2, W);\n\t\tBLEND_OP(i + 3, W);\n\t\tBLEND_OP(i + 4, W);\n\t\tBLEND_OP(i + 5, W);\n\t\tBLEND_OP(i + 6, W);\n\t\tBLEND_OP(i + 7, W);\n\t}\n\n\t \n\ta = state[0];  b = state[1];  c = state[2];  d = state[3];\n\te = state[4];  f = state[5];  g = state[6];  h = state[7];\n\n\t \n\tfor (i = 0; i < 64; i += 8) {\n\t\tSHA256_ROUND(i + 0, a, b, c, d, e, f, g, h);\n\t\tSHA256_ROUND(i + 1, h, a, b, c, d, e, f, g);\n\t\tSHA256_ROUND(i + 2, g, h, a, b, c, d, e, f);\n\t\tSHA256_ROUND(i + 3, f, g, h, a, b, c, d, e);\n\t\tSHA256_ROUND(i + 4, e, f, g, h, a, b, c, d);\n\t\tSHA256_ROUND(i + 5, d, e, f, g, h, a, b, c);\n\t\tSHA256_ROUND(i + 6, c, d, e, f, g, h, a, b);\n\t\tSHA256_ROUND(i + 7, b, c, d, e, f, g, h, a);\n\t}\n\n\tstate[0] += a; state[1] += b; state[2] += c; state[3] += d;\n\tstate[4] += e; state[5] += f; state[6] += g; state[7] += h;\n}\n\nstatic void sha256_transform_blocks(struct sha256_state *sctx,\n\t\t\t\t    const u8 *input, int blocks)\n{\n\tu32 W[64];\n\n\tdo {\n\t\tsha256_transform(sctx->state, input, W);\n\t\tinput += SHA256_BLOCK_SIZE;\n\t} while (--blocks);\n\n\tmemzero_explicit(W, sizeof(W));\n}\n\nvoid sha256_update(struct sha256_state *sctx, const u8 *data, unsigned int len)\n{\n\tlib_sha256_base_do_update(sctx, data, len, sha256_transform_blocks);\n}\nEXPORT_SYMBOL(sha256_update);\n\nstatic void __sha256_final(struct sha256_state *sctx, u8 *out, int digest_size)\n{\n\tlib_sha256_base_do_finalize(sctx, sha256_transform_blocks);\n\tlib_sha256_base_finish(sctx, out, digest_size);\n}\n\nvoid sha256_final(struct sha256_state *sctx, u8 *out)\n{\n\t__sha256_final(sctx, out, 32);\n}\nEXPORT_SYMBOL(sha256_final);\n\nvoid sha224_final(struct sha256_state *sctx, u8 *out)\n{\n\t__sha256_final(sctx, out, 28);\n}\nEXPORT_SYMBOL(sha224_final);\n\nvoid sha256(const u8 *data, unsigned int len, u8 *out)\n{\n\tstruct sha256_state sctx;\n\n\tsha256_init(&sctx);\n\tsha256_update(&sctx, data, len);\n\tsha256_final(&sctx, out);\n}\nEXPORT_SYMBOL(sha256);\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}