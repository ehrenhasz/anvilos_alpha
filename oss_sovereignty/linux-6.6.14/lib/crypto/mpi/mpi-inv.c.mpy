{
  "module_name": "mpi-inv.c",
  "hash_id": "d0d16c0dad5a0536f96dd8d502904d3ebd5dedc9c1499f60323c6052521895b0",
  "original_prompt": "Ingested from linux-6.6.14/lib/crypto/mpi/mpi-inv.c",
  "human_readable_source": " \n\n#include \"mpi-internal.h\"\n\n \nint mpi_invm(MPI x, MPI a, MPI n)\n{\n\t \n\tMPI u, v, u1, u2 = NULL, u3, v1, v2 = NULL, v3, t1, t2 = NULL, t3;\n\tunsigned int k;\n\tint sign;\n\tint odd;\n\n\tif (!mpi_cmp_ui(a, 0))\n\t\treturn 0;  \n\tif (!mpi_cmp_ui(n, 1))\n\t\treturn 0;  \n\n\tu = mpi_copy(a);\n\tv = mpi_copy(n);\n\n\tfor (k = 0; !mpi_test_bit(u, 0) && !mpi_test_bit(v, 0); k++) {\n\t\tmpi_rshift(u, u, 1);\n\t\tmpi_rshift(v, v, 1);\n\t}\n\todd = mpi_test_bit(v, 0);\n\n\tu1 = mpi_alloc_set_ui(1);\n\tif (!odd)\n\t\tu2 = mpi_alloc_set_ui(0);\n\tu3 = mpi_copy(u);\n\tv1 = mpi_copy(v);\n\tif (!odd) {\n\t\tv2 = mpi_alloc(mpi_get_nlimbs(u));\n\t\tmpi_sub(v2, u1, u);  \n\t}\n\tv3 = mpi_copy(v);\n\tif (mpi_test_bit(u, 0)) {  \n\t\tt1 = mpi_alloc_set_ui(0);\n\t\tif (!odd) {\n\t\t\tt2 = mpi_alloc_set_ui(1);\n\t\t\tt2->sign = 1;\n\t\t}\n\t\tt3 = mpi_copy(v);\n\t\tt3->sign = !t3->sign;\n\t\tgoto Y4;\n\t} else {\n\t\tt1 = mpi_alloc_set_ui(1);\n\t\tif (!odd)\n\t\t\tt2 = mpi_alloc_set_ui(0);\n\t\tt3 = mpi_copy(u);\n\t}\n\n\tdo {\n\t\tdo {\n\t\t\tif (!odd) {\n\t\t\t\tif (mpi_test_bit(t1, 0) || mpi_test_bit(t2, 0)) {\n\t\t\t\t\t \n\t\t\t\t\tmpi_add(t1, t1, v);\n\t\t\t\t\tmpi_sub(t2, t2, u);\n\t\t\t\t}\n\t\t\t\tmpi_rshift(t1, t1, 1);\n\t\t\t\tmpi_rshift(t2, t2, 1);\n\t\t\t\tmpi_rshift(t3, t3, 1);\n\t\t\t} else {\n\t\t\t\tif (mpi_test_bit(t1, 0))\n\t\t\t\t\tmpi_add(t1, t1, v);\n\t\t\t\tmpi_rshift(t1, t1, 1);\n\t\t\t\tmpi_rshift(t3, t3, 1);\n\t\t\t}\nY4:\n\t\t\t;\n\t\t} while (!mpi_test_bit(t3, 0));  \n\n\t\tif (!t3->sign) {\n\t\t\tmpi_set(u1, t1);\n\t\t\tif (!odd)\n\t\t\t\tmpi_set(u2, t2);\n\t\t\tmpi_set(u3, t3);\n\t\t} else {\n\t\t\tmpi_sub(v1, v, t1);\n\t\t\tsign = u->sign; u->sign = !u->sign;\n\t\t\tif (!odd)\n\t\t\t\tmpi_sub(v2, u, t2);\n\t\t\tu->sign = sign;\n\t\t\tsign = t3->sign; t3->sign = !t3->sign;\n\t\t\tmpi_set(v3, t3);\n\t\t\tt3->sign = sign;\n\t\t}\n\t\tmpi_sub(t1, u1, v1);\n\t\tif (!odd)\n\t\t\tmpi_sub(t2, u2, v2);\n\t\tmpi_sub(t3, u3, v3);\n\t\tif (t1->sign) {\n\t\t\tmpi_add(t1, t1, v);\n\t\t\tif (!odd)\n\t\t\t\tmpi_sub(t2, t2, u);\n\t\t}\n\t} while (mpi_cmp_ui(t3, 0));  \n\t \n\tmpi_set(x, u1);\n\n\tmpi_free(u1);\n\tmpi_free(v1);\n\tmpi_free(t1);\n\tif (!odd) {\n\t\tmpi_free(u2);\n\t\tmpi_free(v2);\n\t\tmpi_free(t2);\n\t}\n\tmpi_free(u3);\n\tmpi_free(v3);\n\tmpi_free(t3);\n\n\tmpi_free(u);\n\tmpi_free(v);\n\treturn 1;\n}\nEXPORT_SYMBOL_GPL(mpi_invm);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}