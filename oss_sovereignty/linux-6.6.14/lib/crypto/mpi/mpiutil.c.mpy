{
  "module_name": "mpiutil.c",
  "hash_id": "4663323fa674b1eb2e2fcb43d24c949a52369b9046028b15a8287a599e6fe847",
  "original_prompt": "Ingested from linux-6.6.14/lib/crypto/mpi/mpiutil.c",
  "human_readable_source": " \n\n#include \"mpi-internal.h\"\n\n \nstatic MPI constants[MPI_NUMBER_OF_CONSTANTS];\n\n \nstatic int __init mpi_init(void)\n{\n\tint idx;\n\tunsigned long value;\n\n\tfor (idx = 0; idx < MPI_NUMBER_OF_CONSTANTS; idx++) {\n\t\tswitch (idx) {\n\t\tcase MPI_C_ZERO:\n\t\t\tvalue = 0;\n\t\t\tbreak;\n\t\tcase MPI_C_ONE:\n\t\t\tvalue = 1;\n\t\t\tbreak;\n\t\tcase MPI_C_TWO:\n\t\t\tvalue = 2;\n\t\t\tbreak;\n\t\tcase MPI_C_THREE:\n\t\t\tvalue = 3;\n\t\t\tbreak;\n\t\tcase MPI_C_FOUR:\n\t\t\tvalue = 4;\n\t\t\tbreak;\n\t\tcase MPI_C_EIGHT:\n\t\t\tvalue = 8;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_err(\"MPI: invalid mpi_const selector %d\\n\", idx);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\tconstants[idx] = mpi_alloc_set_ui(value);\n\t\tconstants[idx]->flags = (16|32);\n\t}\n\n\treturn 0;\n}\npostcore_initcall(mpi_init);\n\n \nMPI mpi_const(enum gcry_mpi_constants no)\n{\n\tif ((int)no < 0 || no > MPI_NUMBER_OF_CONSTANTS)\n\t\tpr_err(\"MPI: invalid mpi_const selector %d\\n\", no);\n\tif (!constants[no])\n\t\tpr_err(\"MPI: MPI subsystem not initialized\\n\");\n\treturn constants[no];\n}\nEXPORT_SYMBOL_GPL(mpi_const);\n\n \nMPI mpi_alloc(unsigned nlimbs)\n{\n\tMPI a;\n\n\ta = kmalloc(sizeof *a, GFP_KERNEL);\n\tif (!a)\n\t\treturn a;\n\n\tif (nlimbs) {\n\t\ta->d = mpi_alloc_limb_space(nlimbs);\n\t\tif (!a->d) {\n\t\t\tkfree(a);\n\t\t\treturn NULL;\n\t\t}\n\t} else {\n\t\ta->d = NULL;\n\t}\n\n\ta->alloced = nlimbs;\n\ta->nlimbs = 0;\n\ta->sign = 0;\n\ta->flags = 0;\n\ta->nbits = 0;\n\treturn a;\n}\nEXPORT_SYMBOL_GPL(mpi_alloc);\n\nmpi_ptr_t mpi_alloc_limb_space(unsigned nlimbs)\n{\n\tsize_t len = nlimbs * sizeof(mpi_limb_t);\n\n\tif (!len)\n\t\treturn NULL;\n\n\treturn kmalloc(len, GFP_KERNEL);\n}\n\nvoid mpi_free_limb_space(mpi_ptr_t a)\n{\n\tif (!a)\n\t\treturn;\n\n\tkfree_sensitive(a);\n}\n\nvoid mpi_assign_limb_space(MPI a, mpi_ptr_t ap, unsigned nlimbs)\n{\n\tmpi_free_limb_space(a->d);\n\ta->d = ap;\n\ta->alloced = nlimbs;\n}\n\n \nint mpi_resize(MPI a, unsigned nlimbs)\n{\n\tvoid *p;\n\n\tif (nlimbs <= a->alloced)\n\t\treturn 0;\t \n\n\tif (a->d) {\n\t\tp = kcalloc(nlimbs, sizeof(mpi_limb_t), GFP_KERNEL);\n\t\tif (!p)\n\t\t\treturn -ENOMEM;\n\t\tmemcpy(p, a->d, a->alloced * sizeof(mpi_limb_t));\n\t\tkfree_sensitive(a->d);\n\t\ta->d = p;\n\t} else {\n\t\ta->d = kcalloc(nlimbs, sizeof(mpi_limb_t), GFP_KERNEL);\n\t\tif (!a->d)\n\t\t\treturn -ENOMEM;\n\t}\n\ta->alloced = nlimbs;\n\treturn 0;\n}\n\nvoid mpi_clear(MPI a)\n{\n\tif (!a)\n\t\treturn;\n\ta->nlimbs = 0;\n\ta->flags = 0;\n}\nEXPORT_SYMBOL_GPL(mpi_clear);\n\nvoid mpi_free(MPI a)\n{\n\tif (!a)\n\t\treturn;\n\n\tif (a->flags & 4)\n\t\tkfree_sensitive(a->d);\n\telse\n\t\tmpi_free_limb_space(a->d);\n\n\tif (a->flags & ~7)\n\t\tpr_info(\"invalid flag value in mpi\\n\");\n\tkfree(a);\n}\nEXPORT_SYMBOL_GPL(mpi_free);\n\n \nMPI mpi_copy(MPI a)\n{\n\tint i;\n\tMPI b;\n\n\tif (a) {\n\t\tb = mpi_alloc(a->nlimbs);\n\t\tb->nlimbs = a->nlimbs;\n\t\tb->sign = a->sign;\n\t\tb->flags = a->flags;\n\t\tb->flags &= ~(16|32);  \n\t\tfor (i = 0; i < b->nlimbs; i++)\n\t\t\tb->d[i] = a->d[i];\n\t} else\n\t\tb = NULL;\n\treturn b;\n}\n\n \nMPI mpi_alloc_like(MPI a)\n{\n\tMPI b;\n\n\tif (a) {\n\t\tb = mpi_alloc(a->nlimbs);\n\t\tb->nlimbs = 0;\n\t\tb->sign = 0;\n\t\tb->flags = a->flags;\n\t} else\n\t\tb = NULL;\n\n\treturn b;\n}\n\n\n \nvoid mpi_snatch(MPI w, MPI u)\n{\n\tif (w) {\n\t\tmpi_assign_limb_space(w, u->d, u->alloced);\n\t\tw->nlimbs = u->nlimbs;\n\t\tw->sign   = u->sign;\n\t\tw->flags  = u->flags;\n\t\tu->alloced = 0;\n\t\tu->nlimbs = 0;\n\t\tu->d = NULL;\n\t}\n\tmpi_free(u);\n}\n\n\nMPI mpi_set(MPI w, MPI u)\n{\n\tmpi_ptr_t wp, up;\n\tmpi_size_t usize = u->nlimbs;\n\tint usign = u->sign;\n\n\tif (!w)\n\t\tw = mpi_alloc(mpi_get_nlimbs(u));\n\tRESIZE_IF_NEEDED(w, usize);\n\twp = w->d;\n\tup = u->d;\n\tMPN_COPY(wp, up, usize);\n\tw->nlimbs = usize;\n\tw->flags = u->flags;\n\tw->flags &= ~(16|32);  \n\tw->sign = usign;\n\treturn w;\n}\nEXPORT_SYMBOL_GPL(mpi_set);\n\nMPI mpi_set_ui(MPI w, unsigned long u)\n{\n\tif (!w)\n\t\tw = mpi_alloc(1);\n\t \n\tRESIZE_IF_NEEDED(w, 1);\n\tw->d[0] = u;\n\tw->nlimbs = u ? 1 : 0;\n\tw->sign = 0;\n\tw->flags = 0;\n\treturn w;\n}\nEXPORT_SYMBOL_GPL(mpi_set_ui);\n\nMPI mpi_alloc_set_ui(unsigned long u)\n{\n\tMPI w = mpi_alloc(1);\n\tw->d[0] = u;\n\tw->nlimbs = u ? 1 : 0;\n\tw->sign = 0;\n\treturn w;\n}\n\n \nvoid mpi_swap_cond(MPI a, MPI b, unsigned long swap)\n{\n\tmpi_size_t i;\n\tmpi_size_t nlimbs;\n\tmpi_limb_t mask = ((mpi_limb_t)0) - swap;\n\tmpi_limb_t x;\n\n\tif (a->alloced > b->alloced)\n\t\tnlimbs = b->alloced;\n\telse\n\t\tnlimbs = a->alloced;\n\tif (a->nlimbs > nlimbs || b->nlimbs > nlimbs)\n\t\treturn;\n\n\tfor (i = 0; i < nlimbs; i++) {\n\t\tx = mask & (a->d[i] ^ b->d[i]);\n\t\ta->d[i] = a->d[i] ^ x;\n\t\tb->d[i] = b->d[i] ^ x;\n\t}\n\n\tx = mask & (a->nlimbs ^ b->nlimbs);\n\ta->nlimbs = a->nlimbs ^ x;\n\tb->nlimbs = b->nlimbs ^ x;\n\n\tx = mask & (a->sign ^ b->sign);\n\ta->sign = a->sign ^ x;\n\tb->sign = b->sign ^ x;\n}\n\nMODULE_DESCRIPTION(\"Multiprecision maths library\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}