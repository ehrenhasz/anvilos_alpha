{
  "module_name": "mpicoder.c",
  "hash_id": "713d1228f9ab19343861238609885da6ed60a94489fae0dccc312ab5d02a4a19",
  "original_prompt": "Ingested from linux-6.6.14/lib/crypto/mpi/mpicoder.c",
  "human_readable_source": " \n\n#include <linux/bitops.h>\n#include <linux/count_zeros.h>\n#include <linux/byteorder/generic.h>\n#include <linux/scatterlist.h>\n#include <linux/string.h>\n#include \"mpi-internal.h\"\n\n#define MAX_EXTERN_SCAN_BYTES (16*1024*1024)\n#define MAX_EXTERN_MPI_BITS 16384\n\n \nMPI mpi_read_raw_data(const void *xbuffer, size_t nbytes)\n{\n\tconst uint8_t *buffer = xbuffer;\n\tint i, j;\n\tunsigned nbits, nlimbs;\n\tmpi_limb_t a;\n\tMPI val = NULL;\n\n\twhile (nbytes > 0 && buffer[0] == 0) {\n\t\tbuffer++;\n\t\tnbytes--;\n\t}\n\n\tnbits = nbytes * 8;\n\tif (nbits > MAX_EXTERN_MPI_BITS) {\n\t\tpr_info(\"MPI: mpi too large (%u bits)\\n\", nbits);\n\t\treturn NULL;\n\t}\n\tif (nbytes > 0)\n\t\tnbits -= count_leading_zeros(buffer[0]) - (BITS_PER_LONG - 8);\n\n\tnlimbs = DIV_ROUND_UP(nbytes, BYTES_PER_MPI_LIMB);\n\tval = mpi_alloc(nlimbs);\n\tif (!val)\n\t\treturn NULL;\n\tval->nbits = nbits;\n\tval->sign = 0;\n\tval->nlimbs = nlimbs;\n\n\tif (nbytes > 0) {\n\t\ti = BYTES_PER_MPI_LIMB - nbytes % BYTES_PER_MPI_LIMB;\n\t\ti %= BYTES_PER_MPI_LIMB;\n\t\tfor (j = nlimbs; j > 0; j--) {\n\t\t\ta = 0;\n\t\t\tfor (; i < BYTES_PER_MPI_LIMB; i++) {\n\t\t\t\ta <<= 8;\n\t\t\t\ta |= *buffer++;\n\t\t\t}\n\t\t\ti = 0;\n\t\t\tval->d[j - 1] = a;\n\t\t}\n\t}\n\treturn val;\n}\nEXPORT_SYMBOL_GPL(mpi_read_raw_data);\n\nMPI mpi_read_from_buffer(const void *xbuffer, unsigned *ret_nread)\n{\n\tconst uint8_t *buffer = xbuffer;\n\tunsigned int nbits, nbytes;\n\tMPI val;\n\n\tif (*ret_nread < 2)\n\t\treturn ERR_PTR(-EINVAL);\n\tnbits = buffer[0] << 8 | buffer[1];\n\n\tif (nbits > MAX_EXTERN_MPI_BITS) {\n\t\tpr_info(\"MPI: mpi too large (%u bits)\\n\", nbits);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tnbytes = DIV_ROUND_UP(nbits, 8);\n\tif (nbytes + 2 > *ret_nread) {\n\t\tpr_info(\"MPI: mpi larger than buffer nbytes=%u ret_nread=%u\\n\",\n\t\t\t\tnbytes, *ret_nread);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tval = mpi_read_raw_data(buffer + 2, nbytes);\n\tif (!val)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t*ret_nread = nbytes + 2;\n\treturn val;\n}\nEXPORT_SYMBOL_GPL(mpi_read_from_buffer);\n\n \nint mpi_fromstr(MPI val, const char *str)\n{\n\tint sign = 0;\n\tint prepend_zero = 0;\n\tint i, j, c, c1, c2;\n\tunsigned int nbits, nbytes, nlimbs;\n\tmpi_limb_t a;\n\n\tif (*str == '-') {\n\t\tsign = 1;\n\t\tstr++;\n\t}\n\n\t \n\tif (*str == '0' && str[1] == 'x')\n\t\tstr += 2;\n\n\tnbits = strlen(str);\n\tif (nbits > MAX_EXTERN_SCAN_BYTES) {\n\t\tmpi_clear(val);\n\t\treturn -EINVAL;\n\t}\n\tnbits *= 4;\n\tif ((nbits % 8))\n\t\tprepend_zero = 1;\n\n\tnbytes = (nbits+7) / 8;\n\tnlimbs = (nbytes+BYTES_PER_MPI_LIMB-1) / BYTES_PER_MPI_LIMB;\n\n\tif (val->alloced < nlimbs)\n\t\tmpi_resize(val, nlimbs);\n\n\ti = BYTES_PER_MPI_LIMB - (nbytes % BYTES_PER_MPI_LIMB);\n\ti %= BYTES_PER_MPI_LIMB;\n\tj = val->nlimbs = nlimbs;\n\tval->sign = sign;\n\tfor (; j > 0; j--) {\n\t\ta = 0;\n\t\tfor (; i < BYTES_PER_MPI_LIMB; i++) {\n\t\t\tif (prepend_zero) {\n\t\t\t\tc1 = '0';\n\t\t\t\tprepend_zero = 0;\n\t\t\t} else\n\t\t\t\tc1 = *str++;\n\n\t\t\tif (!c1) {\n\t\t\t\tmpi_clear(val);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tc2 = *str++;\n\t\t\tif (!c2) {\n\t\t\t\tmpi_clear(val);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tif (c1 >= '0' && c1 <= '9')\n\t\t\t\tc = c1 - '0';\n\t\t\telse if (c1 >= 'a' && c1 <= 'f')\n\t\t\t\tc = c1 - 'a' + 10;\n\t\t\telse if (c1 >= 'A' && c1 <= 'F')\n\t\t\t\tc = c1 - 'A' + 10;\n\t\t\telse {\n\t\t\t\tmpi_clear(val);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tc <<= 4;\n\t\t\tif (c2 >= '0' && c2 <= '9')\n\t\t\t\tc |= c2 - '0';\n\t\t\telse if (c2 >= 'a' && c2 <= 'f')\n\t\t\t\tc |= c2 - 'a' + 10;\n\t\t\telse if (c2 >= 'A' && c2 <= 'F')\n\t\t\t\tc |= c2 - 'A' + 10;\n\t\t\telse {\n\t\t\t\tmpi_clear(val);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\ta <<= 8;\n\t\t\ta |= c;\n\t\t}\n\t\ti = 0;\n\t\tval->d[j-1] = a;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(mpi_fromstr);\n\nMPI mpi_scanval(const char *string)\n{\n\tMPI a;\n\n\ta = mpi_alloc(0);\n\tif (!a)\n\t\treturn NULL;\n\n\tif (mpi_fromstr(a, string)) {\n\t\tmpi_free(a);\n\t\treturn NULL;\n\t}\n\tmpi_normalize(a);\n\treturn a;\n}\nEXPORT_SYMBOL_GPL(mpi_scanval);\n\nstatic int count_lzeros(MPI a)\n{\n\tmpi_limb_t alimb;\n\tint i, lzeros = 0;\n\n\tfor (i = a->nlimbs - 1; i >= 0; i--) {\n\t\talimb = a->d[i];\n\t\tif (alimb == 0) {\n\t\t\tlzeros += sizeof(mpi_limb_t);\n\t\t} else {\n\t\t\tlzeros += count_leading_zeros(alimb) / 8;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn lzeros;\n}\n\n \nint mpi_read_buffer(MPI a, uint8_t *buf, unsigned buf_len, unsigned *nbytes,\n\t\t    int *sign)\n{\n\tuint8_t *p;\n#if BYTES_PER_MPI_LIMB == 4\n\t__be32 alimb;\n#elif BYTES_PER_MPI_LIMB == 8\n\t__be64 alimb;\n#else\n#error please implement for this limb size.\n#endif\n\tunsigned int n = mpi_get_size(a);\n\tint i, lzeros;\n\n\tif (!buf || !nbytes)\n\t\treturn -EINVAL;\n\n\tif (sign)\n\t\t*sign = a->sign;\n\n\tlzeros = count_lzeros(a);\n\n\tif (buf_len < n - lzeros) {\n\t\t*nbytes = n - lzeros;\n\t\treturn -EOVERFLOW;\n\t}\n\n\tp = buf;\n\t*nbytes = n - lzeros;\n\n\tfor (i = a->nlimbs - 1 - lzeros / BYTES_PER_MPI_LIMB,\n\t\t\tlzeros %= BYTES_PER_MPI_LIMB;\n\t\ti >= 0; i--) {\n#if BYTES_PER_MPI_LIMB == 4\n\t\talimb = cpu_to_be32(a->d[i]);\n#elif BYTES_PER_MPI_LIMB == 8\n\t\talimb = cpu_to_be64(a->d[i]);\n#else\n#error please implement for this limb size.\n#endif\n\t\tmemcpy(p, (u8 *)&alimb + lzeros, BYTES_PER_MPI_LIMB - lzeros);\n\t\tp += BYTES_PER_MPI_LIMB - lzeros;\n\t\tlzeros = 0;\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(mpi_read_buffer);\n\n \nvoid *mpi_get_buffer(MPI a, unsigned *nbytes, int *sign)\n{\n\tuint8_t *buf;\n\tunsigned int n;\n\tint ret;\n\n\tif (!nbytes)\n\t\treturn NULL;\n\n\tn = mpi_get_size(a);\n\n\tif (!n)\n\t\tn++;\n\n\tbuf = kmalloc(n, GFP_KERNEL);\n\n\tif (!buf)\n\t\treturn NULL;\n\n\tret = mpi_read_buffer(a, buf, n, nbytes, sign);\n\n\tif (ret) {\n\t\tkfree(buf);\n\t\treturn NULL;\n\t}\n\treturn buf;\n}\nEXPORT_SYMBOL_GPL(mpi_get_buffer);\n\n \nint mpi_write_to_sgl(MPI a, struct scatterlist *sgl, unsigned nbytes,\n\t\t     int *sign)\n{\n\tu8 *p, *p2;\n#if BYTES_PER_MPI_LIMB == 4\n\t__be32 alimb;\n#elif BYTES_PER_MPI_LIMB == 8\n\t__be64 alimb;\n#else\n#error please implement for this limb size.\n#endif\n\tunsigned int n = mpi_get_size(a);\n\tstruct sg_mapping_iter miter;\n\tint i, x, buf_len;\n\tint nents;\n\n\tif (sign)\n\t\t*sign = a->sign;\n\n\tif (nbytes < n)\n\t\treturn -EOVERFLOW;\n\n\tnents = sg_nents_for_len(sgl, nbytes);\n\tif (nents < 0)\n\t\treturn -EINVAL;\n\n\tsg_miter_start(&miter, sgl, nents, SG_MITER_ATOMIC | SG_MITER_TO_SG);\n\tsg_miter_next(&miter);\n\tbuf_len = miter.length;\n\tp2 = miter.addr;\n\n\twhile (nbytes > n) {\n\t\ti = min_t(unsigned, nbytes - n, buf_len);\n\t\tmemset(p2, 0, i);\n\t\tp2 += i;\n\t\tnbytes -= i;\n\n\t\tbuf_len -= i;\n\t\tif (!buf_len) {\n\t\t\tsg_miter_next(&miter);\n\t\t\tbuf_len = miter.length;\n\t\t\tp2 = miter.addr;\n\t\t}\n\t}\n\n\tfor (i = a->nlimbs - 1; i >= 0; i--) {\n#if BYTES_PER_MPI_LIMB == 4\n\t\talimb = a->d[i] ? cpu_to_be32(a->d[i]) : 0;\n#elif BYTES_PER_MPI_LIMB == 8\n\t\talimb = a->d[i] ? cpu_to_be64(a->d[i]) : 0;\n#else\n#error please implement for this limb size.\n#endif\n\t\tp = (u8 *)&alimb;\n\n\t\tfor (x = 0; x < sizeof(alimb); x++) {\n\t\t\t*p2++ = *p++;\n\t\t\tif (!--buf_len) {\n\t\t\t\tsg_miter_next(&miter);\n\t\t\t\tbuf_len = miter.length;\n\t\t\t\tp2 = miter.addr;\n\t\t\t}\n\t\t}\n\t}\n\n\tsg_miter_stop(&miter);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(mpi_write_to_sgl);\n\n \nMPI mpi_read_raw_from_sgl(struct scatterlist *sgl, unsigned int nbytes)\n{\n\tstruct sg_mapping_iter miter;\n\tunsigned int nbits, nlimbs;\n\tint x, j, z, lzeros, ents;\n\tunsigned int len;\n\tconst u8 *buff;\n\tmpi_limb_t a;\n\tMPI val = NULL;\n\n\tents = sg_nents_for_len(sgl, nbytes);\n\tif (ents < 0)\n\t\treturn NULL;\n\n\tsg_miter_start(&miter, sgl, ents, SG_MITER_ATOMIC | SG_MITER_FROM_SG);\n\n\tlzeros = 0;\n\tlen = 0;\n\twhile (nbytes > 0) {\n\t\twhile (len && !*buff) {\n\t\t\tlzeros++;\n\t\t\tlen--;\n\t\t\tbuff++;\n\t\t}\n\n\t\tif (len && *buff)\n\t\t\tbreak;\n\n\t\tsg_miter_next(&miter);\n\t\tbuff = miter.addr;\n\t\tlen = miter.length;\n\n\t\tnbytes -= lzeros;\n\t\tlzeros = 0;\n\t}\n\n\tmiter.consumed = lzeros;\n\n\tnbytes -= lzeros;\n\tnbits = nbytes * 8;\n\tif (nbits > MAX_EXTERN_MPI_BITS) {\n\t\tsg_miter_stop(&miter);\n\t\tpr_info(\"MPI: mpi too large (%u bits)\\n\", nbits);\n\t\treturn NULL;\n\t}\n\n\tif (nbytes > 0)\n\t\tnbits -= count_leading_zeros(*buff) - (BITS_PER_LONG - 8);\n\n\tsg_miter_stop(&miter);\n\n\tnlimbs = DIV_ROUND_UP(nbytes, BYTES_PER_MPI_LIMB);\n\tval = mpi_alloc(nlimbs);\n\tif (!val)\n\t\treturn NULL;\n\n\tval->nbits = nbits;\n\tval->sign = 0;\n\tval->nlimbs = nlimbs;\n\n\tif (nbytes == 0)\n\t\treturn val;\n\n\tj = nlimbs - 1;\n\ta = 0;\n\tz = BYTES_PER_MPI_LIMB - nbytes % BYTES_PER_MPI_LIMB;\n\tz %= BYTES_PER_MPI_LIMB;\n\n\twhile (sg_miter_next(&miter)) {\n\t\tbuff = miter.addr;\n\t\tlen = min_t(unsigned, miter.length, nbytes);\n\t\tnbytes -= len;\n\n\t\tfor (x = 0; x < len; x++) {\n\t\t\ta <<= 8;\n\t\t\ta |= *buff++;\n\t\t\tif (((z + x + 1) % BYTES_PER_MPI_LIMB) == 0) {\n\t\t\t\tval->d[j--] = a;\n\t\t\t\ta = 0;\n\t\t\t}\n\t\t}\n\t\tz += x;\n\t}\n\n\treturn val;\n}\nEXPORT_SYMBOL_GPL(mpi_read_raw_from_sgl);\n\n \nstatic void twocompl(unsigned char *p, unsigned int n)\n{\n\tint i;\n\n\tfor (i = n-1; i >= 0 && !p[i]; i--)\n\t\t;\n\tif (i >= 0) {\n\t\tif ((p[i] & 0x01))\n\t\t\tp[i] = (((p[i] ^ 0xfe) | 0x01) & 0xff);\n\t\telse if ((p[i] & 0x02))\n\t\t\tp[i] = (((p[i] ^ 0xfc) | 0x02) & 0xfe);\n\t\telse if ((p[i] & 0x04))\n\t\t\tp[i] = (((p[i] ^ 0xf8) | 0x04) & 0xfc);\n\t\telse if ((p[i] & 0x08))\n\t\t\tp[i] = (((p[i] ^ 0xf0) | 0x08) & 0xf8);\n\t\telse if ((p[i] & 0x10))\n\t\t\tp[i] = (((p[i] ^ 0xe0) | 0x10) & 0xf0);\n\t\telse if ((p[i] & 0x20))\n\t\t\tp[i] = (((p[i] ^ 0xc0) | 0x20) & 0xe0);\n\t\telse if ((p[i] & 0x40))\n\t\t\tp[i] = (((p[i] ^ 0x80) | 0x40) & 0xc0);\n\t\telse\n\t\t\tp[i] = 0x80;\n\n\t\tfor (i--; i >= 0; i--)\n\t\t\tp[i] ^= 0xff;\n\t}\n}\n\nint mpi_print(enum gcry_mpi_format format, unsigned char *buffer,\n\t\t\tsize_t buflen, size_t *nwritten, MPI a)\n{\n\tunsigned int nbits = mpi_get_nbits(a);\n\tsize_t len;\n\tsize_t dummy_nwritten;\n\tint negative;\n\n\tif (!nwritten)\n\t\tnwritten = &dummy_nwritten;\n\n\t \n\tif (a->sign && mpi_cmp_ui(a, 0))\n\t\tnegative = 1;\n\telse\n\t\tnegative = 0;\n\n\tlen = buflen;\n\t*nwritten = 0;\n\tif (format == GCRYMPI_FMT_STD) {\n\t\tunsigned char *tmp;\n\t\tint extra = 0;\n\t\tunsigned int n;\n\n\t\ttmp = mpi_get_buffer(a, &n, NULL);\n\t\tif (!tmp)\n\t\t\treturn -EINVAL;\n\n\t\tif (negative) {\n\t\t\ttwocompl(tmp, n);\n\t\t\tif (!(*tmp & 0x80)) {\n\t\t\t\t \n\t\t\t\tn++;\n\t\t\t\textra = 2;\n\t\t\t}\n\t\t} else if (n && (*tmp & 0x80)) {\n\t\t\t \n\t\t\tn++;\n\t\t\textra = 1;\n\t\t}\n\n\t\tif (buffer && n > len) {\n\t\t\t \n\t\t\tkfree(tmp);\n\t\t\treturn -E2BIG;\n\t\t}\n\t\tif (buffer) {\n\t\t\tunsigned char *s = buffer;\n\n\t\t\tif (extra == 1)\n\t\t\t\t*s++ = 0;\n\t\t\telse if (extra)\n\t\t\t\t*s++ = 0xff;\n\t\t\tmemcpy(s, tmp, n-!!extra);\n\t\t}\n\t\tkfree(tmp);\n\t\t*nwritten = n;\n\t\treturn 0;\n\t} else if (format == GCRYMPI_FMT_USG) {\n\t\tunsigned int n = (nbits + 7)/8;\n\n\t\t \n\t\t \n\n\t\tif (buffer && n > len)\n\t\t\treturn -E2BIG;\n\t\tif (buffer) {\n\t\t\tunsigned char *tmp;\n\n\t\t\ttmp = mpi_get_buffer(a, &n, NULL);\n\t\t\tif (!tmp)\n\t\t\t\treturn -EINVAL;\n\t\t\tmemcpy(buffer, tmp, n);\n\t\t\tkfree(tmp);\n\t\t}\n\t\t*nwritten = n;\n\t\treturn 0;\n\t} else if (format == GCRYMPI_FMT_PGP) {\n\t\tunsigned int n = (nbits + 7)/8;\n\n\t\t \n\t\tif (negative)\n\t\t\treturn -EINVAL;\n\n\t\tif (buffer && n+2 > len)\n\t\t\treturn -E2BIG;\n\n\t\tif (buffer) {\n\t\t\tunsigned char *tmp;\n\t\t\tunsigned char *s = buffer;\n\n\t\t\ts[0] = nbits >> 8;\n\t\t\ts[1] = nbits;\n\n\t\t\ttmp = mpi_get_buffer(a, &n, NULL);\n\t\t\tif (!tmp)\n\t\t\t\treturn -EINVAL;\n\t\t\tmemcpy(s+2, tmp, n);\n\t\t\tkfree(tmp);\n\t\t}\n\t\t*nwritten = n+2;\n\t\treturn 0;\n\t} else if (format == GCRYMPI_FMT_SSH) {\n\t\tunsigned char *tmp;\n\t\tint extra = 0;\n\t\tunsigned int n;\n\n\t\ttmp = mpi_get_buffer(a, &n, NULL);\n\t\tif (!tmp)\n\t\t\treturn -EINVAL;\n\n\t\tif (negative) {\n\t\t\ttwocompl(tmp, n);\n\t\t\tif (!(*tmp & 0x80)) {\n\t\t\t\t \n\t\t\t\tn++;\n\t\t\t\textra = 2;\n\t\t\t}\n\t\t} else if (n && (*tmp & 0x80)) {\n\t\t\tn++;\n\t\t\textra = 1;\n\t\t}\n\n\t\tif (buffer && n+4 > len) {\n\t\t\tkfree(tmp);\n\t\t\treturn -E2BIG;\n\t\t}\n\n\t\tif (buffer) {\n\t\t\tunsigned char *s = buffer;\n\n\t\t\t*s++ = n >> 24;\n\t\t\t*s++ = n >> 16;\n\t\t\t*s++ = n >> 8;\n\t\t\t*s++ = n;\n\t\t\tif (extra == 1)\n\t\t\t\t*s++ = 0;\n\t\t\telse if (extra)\n\t\t\t\t*s++ = 0xff;\n\t\t\tmemcpy(s, tmp, n-!!extra);\n\t\t}\n\t\tkfree(tmp);\n\t\t*nwritten = 4+n;\n\t\treturn 0;\n\t} else if (format == GCRYMPI_FMT_HEX) {\n\t\tunsigned char *tmp;\n\t\tint i;\n\t\tint extra = 0;\n\t\tunsigned int n = 0;\n\n\t\ttmp = mpi_get_buffer(a, &n, NULL);\n\t\tif (!tmp)\n\t\t\treturn -EINVAL;\n\t\tif (!n || (*tmp & 0x80))\n\t\t\textra = 2;\n\n\t\tif (buffer && 2*n + extra + negative + 1 > len) {\n\t\t\tkfree(tmp);\n\t\t\treturn -E2BIG;\n\t\t}\n\t\tif (buffer) {\n\t\t\tunsigned char *s = buffer;\n\n\t\t\tif (negative)\n\t\t\t\t*s++ = '-';\n\t\t\tif (extra) {\n\t\t\t\t*s++ = '0';\n\t\t\t\t*s++ = '0';\n\t\t\t}\n\n\t\t\tfor (i = 0; i < n; i++) {\n\t\t\t\tunsigned int c = tmp[i];\n\n\t\t\t\t*s++ = (c >> 4) < 10 ? '0'+(c>>4) : 'A'+(c>>4)-10;\n\t\t\t\tc &= 15;\n\t\t\t\t*s++ = c < 10 ? '0'+c : 'A'+c-10;\n\t\t\t}\n\t\t\t*s++ = 0;\n\t\t\t*nwritten = s - buffer;\n\t\t} else {\n\t\t\t*nwritten = 2*n + extra + negative + 1;\n\t\t}\n\t\tkfree(tmp);\n\t\treturn 0;\n\t} else\n\t\treturn -EINVAL;\n}\nEXPORT_SYMBOL_GPL(mpi_print);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}