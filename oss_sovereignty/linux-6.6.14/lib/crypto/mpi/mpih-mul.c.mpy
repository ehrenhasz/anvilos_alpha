{
  "module_name": "mpih-mul.c",
  "hash_id": "2498affc4f8a31cbca397e606b26563604f95df855ad3cbcd740fcd92ec034d1",
  "original_prompt": "Ingested from linux-6.6.14/lib/crypto/mpi/mpih-mul.c",
  "human_readable_source": "\n \n\n#include <linux/string.h>\n#include \"mpi-internal.h\"\n#include \"longlong.h\"\n\n#define MPN_MUL_N_RECURSE(prodp, up, vp, size, tspace)\t\t\\\n\tdo {\t\t\t\t\t\t\t\\\n\t\tif ((size) < KARATSUBA_THRESHOLD)\t\t\\\n\t\t\tmul_n_basecase(prodp, up, vp, size);\t\\\n\t\telse\t\t\t\t\t\t\\\n\t\t\tmul_n(prodp, up, vp, size, tspace);\t\\\n\t} while (0);\n\n#define MPN_SQR_N_RECURSE(prodp, up, size, tspace)\t\t\\\n\tdo {\t\t\t\t\t\t\t\\\n\t\tif ((size) < KARATSUBA_THRESHOLD)\t\t\\\n\t\t\tmpih_sqr_n_basecase(prodp, up, size);\t\\\n\t\telse\t\t\t\t\t\t\\\n\t\t\tmpih_sqr_n(prodp, up, size, tspace);\t\\\n\t} while (0);\n\n \n\nstatic mpi_limb_t\nmul_n_basecase(mpi_ptr_t prodp, mpi_ptr_t up, mpi_ptr_t vp, mpi_size_t size)\n{\n\tmpi_size_t i;\n\tmpi_limb_t cy;\n\tmpi_limb_t v_limb;\n\n\t \n\tv_limb = vp[0];\n\tif (v_limb <= 1) {\n\t\tif (v_limb == 1)\n\t\t\tMPN_COPY(prodp, up, size);\n\t\telse\n\t\t\tMPN_ZERO(prodp, size);\n\t\tcy = 0;\n\t} else\n\t\tcy = mpihelp_mul_1(prodp, up, size, v_limb);\n\n\tprodp[size] = cy;\n\tprodp++;\n\n\t \n\tfor (i = 1; i < size; i++) {\n\t\tv_limb = vp[i];\n\t\tif (v_limb <= 1) {\n\t\t\tcy = 0;\n\t\t\tif (v_limb == 1)\n\t\t\t\tcy = mpihelp_add_n(prodp, prodp, up, size);\n\t\t} else\n\t\t\tcy = mpihelp_addmul_1(prodp, up, size, v_limb);\n\n\t\tprodp[size] = cy;\n\t\tprodp++;\n\t}\n\n\treturn cy;\n}\n\nstatic void\nmul_n(mpi_ptr_t prodp, mpi_ptr_t up, mpi_ptr_t vp,\n\t\tmpi_size_t size, mpi_ptr_t tspace)\n{\n\tif (size & 1) {\n\t\t \n\t\tmpi_size_t esize = size - 1;\t \n\t\tmpi_limb_t cy_limb;\n\n\t\tMPN_MUL_N_RECURSE(prodp, up, vp, esize, tspace);\n\t\tcy_limb = mpihelp_addmul_1(prodp + esize, up, esize, vp[esize]);\n\t\tprodp[esize + esize] = cy_limb;\n\t\tcy_limb = mpihelp_addmul_1(prodp + esize, vp, size, up[esize]);\n\t\tprodp[esize + size] = cy_limb;\n\t} else {\n\t\t \n\t\tmpi_size_t hsize = size >> 1;\n\t\tmpi_limb_t cy;\n\t\tint negflg;\n\n\t\t \n\t\tMPN_MUL_N_RECURSE(prodp + size, up + hsize, vp + hsize, hsize,\n\t\t\t\t  tspace);\n\n\t\t \n\t\tif (mpihelp_cmp(up + hsize, up, hsize) >= 0) {\n\t\t\tmpihelp_sub_n(prodp, up + hsize, up, hsize);\n\t\t\tnegflg = 0;\n\t\t} else {\n\t\t\tmpihelp_sub_n(prodp, up, up + hsize, hsize);\n\t\t\tnegflg = 1;\n\t\t}\n\t\tif (mpihelp_cmp(vp + hsize, vp, hsize) >= 0) {\n\t\t\tmpihelp_sub_n(prodp + hsize, vp + hsize, vp, hsize);\n\t\t\tnegflg ^= 1;\n\t\t} else {\n\t\t\tmpihelp_sub_n(prodp + hsize, vp, vp + hsize, hsize);\n\t\t\t \n\t\t}\n\t\t \n\t\tMPN_MUL_N_RECURSE(tspace, prodp, prodp + hsize, hsize,\n\t\t\t\t  tspace + size);\n\n\t\t \n\t\tMPN_COPY(prodp + hsize, prodp + size, hsize);\n\t\tcy = mpihelp_add_n(prodp + size, prodp + size,\n\t\t\t\t   prodp + size + hsize, hsize);\n\n\t\t \n\t\tif (negflg)\n\t\t\tcy -=\n\t\t\t    mpihelp_sub_n(prodp + hsize, prodp + hsize, tspace,\n\t\t\t\t\t  size);\n\t\telse\n\t\t\tcy +=\n\t\t\t    mpihelp_add_n(prodp + hsize, prodp + hsize, tspace,\n\t\t\t\t\t  size);\n\n\t\t \n\t\tMPN_MUL_N_RECURSE(tspace, up, vp, hsize, tspace + size);\n\n\t\t \n\n\t\tcy += mpihelp_add_n(prodp + hsize, prodp + hsize, tspace, size);\n\t\tif (cy)\n\t\t\tmpihelp_add_1(prodp + hsize + size,\n\t\t\t\t      prodp + hsize + size, hsize, cy);\n\n\t\tMPN_COPY(prodp, tspace, hsize);\n\t\tcy = mpihelp_add_n(prodp + hsize, prodp + hsize, tspace + hsize,\n\t\t\t\t   hsize);\n\t\tif (cy)\n\t\t\tmpihelp_add_1(prodp + size, prodp + size, size, 1);\n\t}\n}\n\nvoid mpih_sqr_n_basecase(mpi_ptr_t prodp, mpi_ptr_t up, mpi_size_t size)\n{\n\tmpi_size_t i;\n\tmpi_limb_t cy_limb;\n\tmpi_limb_t v_limb;\n\n\t \n\tv_limb = up[0];\n\tif (v_limb <= 1) {\n\t\tif (v_limb == 1)\n\t\t\tMPN_COPY(prodp, up, size);\n\t\telse\n\t\t\tMPN_ZERO(prodp, size);\n\t\tcy_limb = 0;\n\t} else\n\t\tcy_limb = mpihelp_mul_1(prodp, up, size, v_limb);\n\n\tprodp[size] = cy_limb;\n\tprodp++;\n\n\t \n\tfor (i = 1; i < size; i++) {\n\t\tv_limb = up[i];\n\t\tif (v_limb <= 1) {\n\t\t\tcy_limb = 0;\n\t\t\tif (v_limb == 1)\n\t\t\t\tcy_limb = mpihelp_add_n(prodp, prodp, up, size);\n\t\t} else\n\t\t\tcy_limb = mpihelp_addmul_1(prodp, up, size, v_limb);\n\n\t\tprodp[size] = cy_limb;\n\t\tprodp++;\n\t}\n}\n\nvoid\nmpih_sqr_n(mpi_ptr_t prodp, mpi_ptr_t up, mpi_size_t size, mpi_ptr_t tspace)\n{\n\tif (size & 1) {\n\t\t \n\t\tmpi_size_t esize = size - 1;\t \n\t\tmpi_limb_t cy_limb;\n\n\t\tMPN_SQR_N_RECURSE(prodp, up, esize, tspace);\n\t\tcy_limb = mpihelp_addmul_1(prodp + esize, up, esize, up[esize]);\n\t\tprodp[esize + esize] = cy_limb;\n\t\tcy_limb = mpihelp_addmul_1(prodp + esize, up, size, up[esize]);\n\n\t\tprodp[esize + size] = cy_limb;\n\t} else {\n\t\tmpi_size_t hsize = size >> 1;\n\t\tmpi_limb_t cy;\n\n\t\t \n\t\tMPN_SQR_N_RECURSE(prodp + size, up + hsize, hsize, tspace);\n\n\t\t \n\t\tif (mpihelp_cmp(up + hsize, up, hsize) >= 0)\n\t\t\tmpihelp_sub_n(prodp, up + hsize, up, hsize);\n\t\telse\n\t\t\tmpihelp_sub_n(prodp, up, up + hsize, hsize);\n\n\t\t \n\t\tMPN_SQR_N_RECURSE(tspace, prodp, hsize, tspace + size);\n\n\t\t \n\t\tMPN_COPY(prodp + hsize, prodp + size, hsize);\n\t\tcy = mpihelp_add_n(prodp + size, prodp + size,\n\t\t\t\t   prodp + size + hsize, hsize);\n\n\t\t \n\t\tcy -= mpihelp_sub_n(prodp + hsize, prodp + hsize, tspace, size);\n\n\t\t \n\t\tMPN_SQR_N_RECURSE(tspace, up, hsize, tspace + size);\n\n\t\t \n\t\tcy += mpihelp_add_n(prodp + hsize, prodp + hsize, tspace, size);\n\t\tif (cy)\n\t\t\tmpihelp_add_1(prodp + hsize + size,\n\t\t\t\t      prodp + hsize + size, hsize, cy);\n\n\t\tMPN_COPY(prodp, tspace, hsize);\n\t\tcy = mpihelp_add_n(prodp + hsize, prodp + hsize, tspace + hsize,\n\t\t\t\t   hsize);\n\t\tif (cy)\n\t\t\tmpihelp_add_1(prodp + size, prodp + size, size, 1);\n\t}\n}\n\n\nvoid mpihelp_mul_n(mpi_ptr_t prodp,\n\t\tmpi_ptr_t up, mpi_ptr_t vp, mpi_size_t size)\n{\n\tif (up == vp) {\n\t\tif (size < KARATSUBA_THRESHOLD)\n\t\t\tmpih_sqr_n_basecase(prodp, up, size);\n\t\telse {\n\t\t\tmpi_ptr_t tspace;\n\t\t\ttspace = mpi_alloc_limb_space(2 * size);\n\t\t\tmpih_sqr_n(prodp, up, size, tspace);\n\t\t\tmpi_free_limb_space(tspace);\n\t\t}\n\t} else {\n\t\tif (size < KARATSUBA_THRESHOLD)\n\t\t\tmul_n_basecase(prodp, up, vp, size);\n\t\telse {\n\t\t\tmpi_ptr_t tspace;\n\t\t\ttspace = mpi_alloc_limb_space(2 * size);\n\t\t\tmul_n(prodp, up, vp, size, tspace);\n\t\t\tmpi_free_limb_space(tspace);\n\t\t}\n\t}\n}\n\nint\nmpihelp_mul_karatsuba_case(mpi_ptr_t prodp,\n\t\t\t   mpi_ptr_t up, mpi_size_t usize,\n\t\t\t   mpi_ptr_t vp, mpi_size_t vsize,\n\t\t\t   struct karatsuba_ctx *ctx)\n{\n\tmpi_limb_t cy;\n\n\tif (!ctx->tspace || ctx->tspace_size < vsize) {\n\t\tif (ctx->tspace)\n\t\t\tmpi_free_limb_space(ctx->tspace);\n\t\tctx->tspace = mpi_alloc_limb_space(2 * vsize);\n\t\tif (!ctx->tspace)\n\t\t\treturn -ENOMEM;\n\t\tctx->tspace_size = vsize;\n\t}\n\n\tMPN_MUL_N_RECURSE(prodp, up, vp, vsize, ctx->tspace);\n\n\tprodp += vsize;\n\tup += vsize;\n\tusize -= vsize;\n\tif (usize >= vsize) {\n\t\tif (!ctx->tp || ctx->tp_size < vsize) {\n\t\t\tif (ctx->tp)\n\t\t\t\tmpi_free_limb_space(ctx->tp);\n\t\t\tctx->tp = mpi_alloc_limb_space(2 * vsize);\n\t\t\tif (!ctx->tp) {\n\t\t\t\tif (ctx->tspace)\n\t\t\t\t\tmpi_free_limb_space(ctx->tspace);\n\t\t\t\tctx->tspace = NULL;\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t\tctx->tp_size = vsize;\n\t\t}\n\n\t\tdo {\n\t\t\tMPN_MUL_N_RECURSE(ctx->tp, up, vp, vsize, ctx->tspace);\n\t\t\tcy = mpihelp_add_n(prodp, prodp, ctx->tp, vsize);\n\t\t\tmpihelp_add_1(prodp + vsize, ctx->tp + vsize, vsize,\n\t\t\t\t      cy);\n\t\t\tprodp += vsize;\n\t\t\tup += vsize;\n\t\t\tusize -= vsize;\n\t\t} while (usize >= vsize);\n\t}\n\n\tif (usize) {\n\t\tif (usize < KARATSUBA_THRESHOLD) {\n\t\t\tmpi_limb_t tmp;\n\t\t\tif (mpihelp_mul(ctx->tspace, vp, vsize, up, usize, &tmp)\n\t\t\t    < 0)\n\t\t\t\treturn -ENOMEM;\n\t\t} else {\n\t\t\tif (!ctx->next) {\n\t\t\t\tctx->next = kzalloc(sizeof *ctx, GFP_KERNEL);\n\t\t\t\tif (!ctx->next)\n\t\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t\tif (mpihelp_mul_karatsuba_case(ctx->tspace,\n\t\t\t\t\t\t       vp, vsize,\n\t\t\t\t\t\t       up, usize,\n\t\t\t\t\t\t       ctx->next) < 0)\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tcy = mpihelp_add_n(prodp, prodp, ctx->tspace, vsize);\n\t\tmpihelp_add_1(prodp + vsize, ctx->tspace + vsize, usize, cy);\n\t}\n\n\treturn 0;\n}\n\nvoid mpihelp_release_karatsuba_ctx(struct karatsuba_ctx *ctx)\n{\n\tstruct karatsuba_ctx *ctx2;\n\n\tif (ctx->tp)\n\t\tmpi_free_limb_space(ctx->tp);\n\tif (ctx->tspace)\n\t\tmpi_free_limb_space(ctx->tspace);\n\tfor (ctx = ctx->next; ctx; ctx = ctx2) {\n\t\tctx2 = ctx->next;\n\t\tif (ctx->tp)\n\t\t\tmpi_free_limb_space(ctx->tp);\n\t\tif (ctx->tspace)\n\t\t\tmpi_free_limb_space(ctx->tspace);\n\t\tkfree(ctx);\n\t}\n}\n\n \n\nint\nmpihelp_mul(mpi_ptr_t prodp, mpi_ptr_t up, mpi_size_t usize,\n\t    mpi_ptr_t vp, mpi_size_t vsize, mpi_limb_t *_result)\n{\n\tmpi_ptr_t prod_endp = prodp + usize + vsize - 1;\n\tmpi_limb_t cy;\n\tstruct karatsuba_ctx ctx;\n\n\tif (vsize < KARATSUBA_THRESHOLD) {\n\t\tmpi_size_t i;\n\t\tmpi_limb_t v_limb;\n\n\t\tif (!vsize) {\n\t\t\t*_result = 0;\n\t\t\treturn 0;\n\t\t}\n\n\t\t \n\t\tv_limb = vp[0];\n\t\tif (v_limb <= 1) {\n\t\t\tif (v_limb == 1)\n\t\t\t\tMPN_COPY(prodp, up, usize);\n\t\t\telse\n\t\t\t\tMPN_ZERO(prodp, usize);\n\t\t\tcy = 0;\n\t\t} else\n\t\t\tcy = mpihelp_mul_1(prodp, up, usize, v_limb);\n\n\t\tprodp[usize] = cy;\n\t\tprodp++;\n\n\t\t \n\t\tfor (i = 1; i < vsize; i++) {\n\t\t\tv_limb = vp[i];\n\t\t\tif (v_limb <= 1) {\n\t\t\t\tcy = 0;\n\t\t\t\tif (v_limb == 1)\n\t\t\t\t\tcy = mpihelp_add_n(prodp, prodp, up,\n\t\t\t\t\t\t\t   usize);\n\t\t\t} else\n\t\t\t\tcy = mpihelp_addmul_1(prodp, up, usize, v_limb);\n\n\t\t\tprodp[usize] = cy;\n\t\t\tprodp++;\n\t\t}\n\n\t\t*_result = cy;\n\t\treturn 0;\n\t}\n\n\tmemset(&ctx, 0, sizeof ctx);\n\tif (mpihelp_mul_karatsuba_case(prodp, up, usize, vp, vsize, &ctx) < 0)\n\t\treturn -ENOMEM;\n\tmpihelp_release_karatsuba_ctx(&ctx);\n\t*_result = *prod_endp;\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}