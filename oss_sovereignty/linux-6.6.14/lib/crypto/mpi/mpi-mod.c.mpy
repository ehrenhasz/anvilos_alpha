{
  "module_name": "mpi-mod.c",
  "hash_id": "f097a85fe675583e851080467fcc062a0b1f665c1f3cf9a9a6c9ad626992aeae",
  "original_prompt": "Ingested from linux-6.6.14/lib/crypto/mpi/mpi-mod.c",
  "human_readable_source": " \n\n\n#include \"mpi-internal.h\"\n#include \"longlong.h\"\n\n \nstruct barrett_ctx_s {\n\tMPI m;    \n\tint m_copied;    \n\tint k;\n\tMPI y;\n\tMPI r1;   \n\tMPI r2;   \n\tMPI r3;   \n};\n\n\n\nvoid mpi_mod(MPI rem, MPI dividend, MPI divisor)\n{\n\tmpi_fdiv_r(rem, dividend, divisor);\n}\n\n \nmpi_barrett_t mpi_barrett_init(MPI m, int copy)\n{\n\tmpi_barrett_t ctx;\n\tMPI tmp;\n\n\tmpi_normalize(m);\n\tctx = kcalloc(1, sizeof(*ctx), GFP_KERNEL);\n\tif (!ctx)\n\t\treturn NULL;\n\n\tif (copy) {\n\t\tctx->m = mpi_copy(m);\n\t\tctx->m_copied = 1;\n\t} else\n\t\tctx->m = m;\n\n\tctx->k = mpi_get_nlimbs(m);\n\ttmp = mpi_alloc(ctx->k + 1);\n\n\t \n\tmpi_set_ui(tmp, 1);\n\tmpi_lshift_limbs(tmp, 2 * ctx->k);\n\tmpi_fdiv_q(tmp, tmp, m);\n\n\tctx->y  = tmp;\n\tctx->r1 = mpi_alloc(2 * ctx->k + 1);\n\tctx->r2 = mpi_alloc(2 * ctx->k + 1);\n\n\treturn ctx;\n}\n\nvoid mpi_barrett_free(mpi_barrett_t ctx)\n{\n\tif (ctx) {\n\t\tmpi_free(ctx->y);\n\t\tmpi_free(ctx->r1);\n\t\tmpi_free(ctx->r2);\n\t\tif (ctx->r3)\n\t\t\tmpi_free(ctx->r3);\n\t\tif (ctx->m_copied)\n\t\t\tmpi_free(ctx->m);\n\t\tkfree(ctx);\n\t}\n}\n\n\n \nvoid mpi_mod_barrett(MPI r, MPI x, mpi_barrett_t ctx)\n{\n\tMPI m = ctx->m;\n\tint k = ctx->k;\n\tMPI y = ctx->y;\n\tMPI r1 = ctx->r1;\n\tMPI r2 = ctx->r2;\n\tint sign;\n\n\tmpi_normalize(x);\n\tif (mpi_get_nlimbs(x) > 2*k) {\n\t\tmpi_mod(r, x, m);\n\t\treturn;\n\t}\n\n\tsign = x->sign;\n\tx->sign = 0;\n\n\t \n\tmpi_set(r2, x);\n\tmpi_rshift_limbs(r2, k-1);\n\tmpi_mul(r2, r2, y);\n\tmpi_rshift_limbs(r2, k+1);\n\n\t \n\tmpi_set(r1, x);\n\tif (r1->nlimbs > k+1)  \n\t\tr1->nlimbs = k+1;\n\tmpi_mul(r2, r2, m);\n\tif (r2->nlimbs > k+1)  \n\t\tr2->nlimbs = k+1;\n\tmpi_sub(r, r1, r2);\n\n\tif (mpi_has_sign(r)) {\n\t\tif (!ctx->r3) {\n\t\t\tctx->r3 = mpi_alloc(k + 2);\n\t\t\tmpi_set_ui(ctx->r3, 1);\n\t\t\tmpi_lshift_limbs(ctx->r3, k + 1);\n\t\t}\n\t\tmpi_add(r, r, ctx->r3);\n\t}\n\n\t \n\twhile (mpi_cmp(r, m) >= 0)\n\t\tmpi_sub(r, r, m);\n\n\tx->sign = sign;\n}\n\n\nvoid mpi_mul_barrett(MPI w, MPI u, MPI v, mpi_barrett_t ctx)\n{\n\tmpi_mul(w, u, v);\n\tmpi_mod_barrett(w, w, ctx);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}