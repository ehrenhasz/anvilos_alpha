{
  "module_name": "ec.c",
  "hash_id": "c8ca696cdb2909ea699c0d6f7541088e56e3e684a34cff25a4fdb08e0a1dd621",
  "original_prompt": "Ingested from linux-6.6.14/lib/crypto/mpi/ec.c",
  "human_readable_source": " \n\n#include \"mpi-internal.h\"\n#include \"longlong.h\"\n\n#define point_init(a)  mpi_point_init((a))\n#define point_free(a)  mpi_point_free_parts((a))\n\n#define log_error(fmt, ...) pr_err(fmt, ##__VA_ARGS__)\n#define log_fatal(fmt, ...) pr_err(fmt, ##__VA_ARGS__)\n\n#define DIM(v) (sizeof(v)/sizeof((v)[0]))\n\n\n \nMPI_POINT mpi_point_new(unsigned int nbits)\n{\n\tMPI_POINT p;\n\n\t(void)nbits;   \n\n\tp = kmalloc(sizeof(*p), GFP_KERNEL);\n\tif (p)\n\t\tmpi_point_init(p);\n\treturn p;\n}\nEXPORT_SYMBOL_GPL(mpi_point_new);\n\n \nvoid mpi_point_release(MPI_POINT p)\n{\n\tif (p) {\n\t\tmpi_point_free_parts(p);\n\t\tkfree(p);\n\t}\n}\nEXPORT_SYMBOL_GPL(mpi_point_release);\n\n \nvoid mpi_point_init(MPI_POINT p)\n{\n\tp->x = mpi_new(0);\n\tp->y = mpi_new(0);\n\tp->z = mpi_new(0);\n}\nEXPORT_SYMBOL_GPL(mpi_point_init);\n\n \nvoid mpi_point_free_parts(MPI_POINT p)\n{\n\tmpi_free(p->x); p->x = NULL;\n\tmpi_free(p->y); p->y = NULL;\n\tmpi_free(p->z); p->z = NULL;\n}\nEXPORT_SYMBOL_GPL(mpi_point_free_parts);\n\n \nstatic void point_set(MPI_POINT d, MPI_POINT s)\n{\n\tmpi_set(d->x, s->x);\n\tmpi_set(d->y, s->y);\n\tmpi_set(d->z, s->z);\n}\n\nstatic void point_resize(MPI_POINT p, struct mpi_ec_ctx *ctx)\n{\n\tsize_t nlimbs = ctx->p->nlimbs;\n\n\tmpi_resize(p->x, nlimbs);\n\tp->x->nlimbs = nlimbs;\n\tmpi_resize(p->z, nlimbs);\n\tp->z->nlimbs = nlimbs;\n\n\tif (ctx->model != MPI_EC_MONTGOMERY) {\n\t\tmpi_resize(p->y, nlimbs);\n\t\tp->y->nlimbs = nlimbs;\n\t}\n}\n\nstatic void point_swap_cond(MPI_POINT d, MPI_POINT s, unsigned long swap,\n\t\tstruct mpi_ec_ctx *ctx)\n{\n\tmpi_swap_cond(d->x, s->x, swap);\n\tif (ctx->model != MPI_EC_MONTGOMERY)\n\t\tmpi_swap_cond(d->y, s->y, swap);\n\tmpi_swap_cond(d->z, s->z, swap);\n}\n\n\n \nstatic void ec_mod(MPI w, struct mpi_ec_ctx *ec)\n{\n\tif (ec->t.p_barrett)\n\t\tmpi_mod_barrett(w, w, ec->t.p_barrett);\n\telse\n\t\tmpi_mod(w, w, ec->p);\n}\n\nstatic void ec_addm(MPI w, MPI u, MPI v, struct mpi_ec_ctx *ctx)\n{\n\tmpi_add(w, u, v);\n\tec_mod(w, ctx);\n}\n\nstatic void ec_subm(MPI w, MPI u, MPI v, struct mpi_ec_ctx *ec)\n{\n\tmpi_sub(w, u, v);\n\twhile (w->sign)\n\t\tmpi_add(w, w, ec->p);\n\t \n}\n\nstatic void ec_mulm(MPI w, MPI u, MPI v, struct mpi_ec_ctx *ctx)\n{\n\tmpi_mul(w, u, v);\n\tec_mod(w, ctx);\n}\n\n \nstatic void ec_mul2(MPI w, MPI u, struct mpi_ec_ctx *ctx)\n{\n\tmpi_lshift(w, u, 1);\n\tec_mod(w, ctx);\n}\n\nstatic void ec_powm(MPI w, const MPI b, const MPI e,\n\t\tstruct mpi_ec_ctx *ctx)\n{\n\tmpi_powm(w, b, e, ctx->p);\n\t \n}\n\n \nstatic void ec_pow2(MPI w, const MPI b, struct mpi_ec_ctx *ctx)\n{\n\t \n\t \n\tec_mulm(w, b, b, ctx);\n}\n\n \nstatic void ec_pow3(MPI w, const MPI b, struct mpi_ec_ctx *ctx)\n{\n\tmpi_powm(w, b, mpi_const(MPI_C_THREE), ctx->p);\n}\n\nstatic void ec_invm(MPI x, MPI a, struct mpi_ec_ctx *ctx)\n{\n\tif (!mpi_invm(x, a, ctx->p))\n\t\tlog_error(\"ec_invm: inverse does not exist:\\n\");\n}\n\nstatic void mpih_set_cond(mpi_ptr_t wp, mpi_ptr_t up,\n\t\tmpi_size_t usize, unsigned long set)\n{\n\tmpi_size_t i;\n\tmpi_limb_t mask = ((mpi_limb_t)0) - set;\n\tmpi_limb_t x;\n\n\tfor (i = 0; i < usize; i++) {\n\t\tx = mask & (wp[i] ^ up[i]);\n\t\twp[i] = wp[i] ^ x;\n\t}\n}\n\n \n\n#define LIMB_SIZE_25519 ((256+BITS_PER_MPI_LIMB-1)/BITS_PER_MPI_LIMB)\n\nstatic void ec_addm_25519(MPI w, MPI u, MPI v, struct mpi_ec_ctx *ctx)\n{\n\tmpi_ptr_t wp, up, vp;\n\tmpi_size_t wsize = LIMB_SIZE_25519;\n\tmpi_limb_t n[LIMB_SIZE_25519];\n\tmpi_limb_t borrow;\n\n\tif (w->nlimbs != wsize || u->nlimbs != wsize || v->nlimbs != wsize)\n\t\tlog_bug(\"addm_25519: different sizes\\n\");\n\n\tmemset(n, 0, sizeof(n));\n\tup = u->d;\n\tvp = v->d;\n\twp = w->d;\n\n\tmpihelp_add_n(wp, up, vp, wsize);\n\tborrow = mpihelp_sub_n(wp, wp, ctx->p->d, wsize);\n\tmpih_set_cond(n, ctx->p->d, wsize, (borrow != 0UL));\n\tmpihelp_add_n(wp, wp, n, wsize);\n\twp[LIMB_SIZE_25519-1] &= ~((mpi_limb_t)1 << (255 % BITS_PER_MPI_LIMB));\n}\n\nstatic void ec_subm_25519(MPI w, MPI u, MPI v, struct mpi_ec_ctx *ctx)\n{\n\tmpi_ptr_t wp, up, vp;\n\tmpi_size_t wsize = LIMB_SIZE_25519;\n\tmpi_limb_t n[LIMB_SIZE_25519];\n\tmpi_limb_t borrow;\n\n\tif (w->nlimbs != wsize || u->nlimbs != wsize || v->nlimbs != wsize)\n\t\tlog_bug(\"subm_25519: different sizes\\n\");\n\n\tmemset(n, 0, sizeof(n));\n\tup = u->d;\n\tvp = v->d;\n\twp = w->d;\n\n\tborrow = mpihelp_sub_n(wp, up, vp, wsize);\n\tmpih_set_cond(n, ctx->p->d, wsize, (borrow != 0UL));\n\tmpihelp_add_n(wp, wp, n, wsize);\n\twp[LIMB_SIZE_25519-1] &= ~((mpi_limb_t)1 << (255 % BITS_PER_MPI_LIMB));\n}\n\nstatic void ec_mulm_25519(MPI w, MPI u, MPI v, struct mpi_ec_ctx *ctx)\n{\n\tmpi_ptr_t wp, up, vp;\n\tmpi_size_t wsize = LIMB_SIZE_25519;\n\tmpi_limb_t n[LIMB_SIZE_25519*2];\n\tmpi_limb_t m[LIMB_SIZE_25519+1];\n\tmpi_limb_t cy;\n\tint msb;\n\n\t(void)ctx;\n\tif (w->nlimbs != wsize || u->nlimbs != wsize || v->nlimbs != wsize)\n\t\tlog_bug(\"mulm_25519: different sizes\\n\");\n\n\tup = u->d;\n\tvp = v->d;\n\twp = w->d;\n\n\tmpihelp_mul_n(n, up, vp, wsize);\n\tmemcpy(wp, n, wsize * BYTES_PER_MPI_LIMB);\n\twp[LIMB_SIZE_25519-1] &= ~((mpi_limb_t)1 << (255 % BITS_PER_MPI_LIMB));\n\n\tmemcpy(m, n+LIMB_SIZE_25519-1, (wsize+1) * BYTES_PER_MPI_LIMB);\n\tmpihelp_rshift(m, m, LIMB_SIZE_25519+1, (255 % BITS_PER_MPI_LIMB));\n\n\tmemcpy(n, m, wsize * BYTES_PER_MPI_LIMB);\n\tcy = mpihelp_lshift(m, m, LIMB_SIZE_25519, 4);\n\tm[LIMB_SIZE_25519] = cy;\n\tcy = mpihelp_add_n(m, m, n, wsize);\n\tm[LIMB_SIZE_25519] += cy;\n\tcy = mpihelp_add_n(m, m, n, wsize);\n\tm[LIMB_SIZE_25519] += cy;\n\tcy = mpihelp_add_n(m, m, n, wsize);\n\tm[LIMB_SIZE_25519] += cy;\n\n\tcy = mpihelp_add_n(wp, wp, m, wsize);\n\tm[LIMB_SIZE_25519] += cy;\n\n\tmemset(m, 0, wsize * BYTES_PER_MPI_LIMB);\n\tmsb = (wp[LIMB_SIZE_25519-1] >> (255 % BITS_PER_MPI_LIMB));\n\tm[0] = (m[LIMB_SIZE_25519] * 2 + msb) * 19;\n\twp[LIMB_SIZE_25519-1] &= ~((mpi_limb_t)1 << (255 % BITS_PER_MPI_LIMB));\n\tmpihelp_add_n(wp, wp, m, wsize);\n\n\tm[0] = 0;\n\tcy = mpihelp_sub_n(wp, wp, ctx->p->d, wsize);\n\tmpih_set_cond(m, ctx->p->d, wsize, (cy != 0UL));\n\tmpihelp_add_n(wp, wp, m, wsize);\n}\n\nstatic void ec_mul2_25519(MPI w, MPI u, struct mpi_ec_ctx *ctx)\n{\n\tec_addm_25519(w, u, u, ctx);\n}\n\nstatic void ec_pow2_25519(MPI w, const MPI b, struct mpi_ec_ctx *ctx)\n{\n\tec_mulm_25519(w, b, b, ctx);\n}\n\n \n\n#define LIMB_SIZE_448 ((448+BITS_PER_MPI_LIMB-1)/BITS_PER_MPI_LIMB)\n#define LIMB_SIZE_HALF_448 ((LIMB_SIZE_448+1)/2)\n\nstatic void ec_addm_448(MPI w, MPI u, MPI v, struct mpi_ec_ctx *ctx)\n{\n\tmpi_ptr_t wp, up, vp;\n\tmpi_size_t wsize = LIMB_SIZE_448;\n\tmpi_limb_t n[LIMB_SIZE_448];\n\tmpi_limb_t cy;\n\n\tif (w->nlimbs != wsize || u->nlimbs != wsize || v->nlimbs != wsize)\n\t\tlog_bug(\"addm_448: different sizes\\n\");\n\n\tmemset(n, 0, sizeof(n));\n\tup = u->d;\n\tvp = v->d;\n\twp = w->d;\n\n\tcy = mpihelp_add_n(wp, up, vp, wsize);\n\tmpih_set_cond(n, ctx->p->d, wsize, (cy != 0UL));\n\tmpihelp_sub_n(wp, wp, n, wsize);\n}\n\nstatic void ec_subm_448(MPI w, MPI u, MPI v, struct mpi_ec_ctx *ctx)\n{\n\tmpi_ptr_t wp, up, vp;\n\tmpi_size_t wsize = LIMB_SIZE_448;\n\tmpi_limb_t n[LIMB_SIZE_448];\n\tmpi_limb_t borrow;\n\n\tif (w->nlimbs != wsize || u->nlimbs != wsize || v->nlimbs != wsize)\n\t\tlog_bug(\"subm_448: different sizes\\n\");\n\n\tmemset(n, 0, sizeof(n));\n\tup = u->d;\n\tvp = v->d;\n\twp = w->d;\n\n\tborrow = mpihelp_sub_n(wp, up, vp, wsize);\n\tmpih_set_cond(n, ctx->p->d, wsize, (borrow != 0UL));\n\tmpihelp_add_n(wp, wp, n, wsize);\n}\n\nstatic void ec_mulm_448(MPI w, MPI u, MPI v, struct mpi_ec_ctx *ctx)\n{\n\tmpi_ptr_t wp, up, vp;\n\tmpi_size_t wsize = LIMB_SIZE_448;\n\tmpi_limb_t n[LIMB_SIZE_448*2];\n\tmpi_limb_t a2[LIMB_SIZE_HALF_448];\n\tmpi_limb_t a3[LIMB_SIZE_HALF_448];\n\tmpi_limb_t b0[LIMB_SIZE_HALF_448];\n\tmpi_limb_t b1[LIMB_SIZE_HALF_448];\n\tmpi_limb_t cy;\n\tint i;\n#if (LIMB_SIZE_HALF_448 > LIMB_SIZE_448/2)\n\tmpi_limb_t b1_rest, a3_rest;\n#endif\n\n\tif (w->nlimbs != wsize || u->nlimbs != wsize || v->nlimbs != wsize)\n\t\tlog_bug(\"mulm_448: different sizes\\n\");\n\n\tup = u->d;\n\tvp = v->d;\n\twp = w->d;\n\n\tmpihelp_mul_n(n, up, vp, wsize);\n\n\tfor (i = 0; i < (wsize + 1) / 2; i++) {\n\t\tb0[i] = n[i];\n\t\tb1[i] = n[i+wsize/2];\n\t\ta2[i] = n[i+wsize];\n\t\ta3[i] = n[i+wsize+wsize/2];\n\t}\n\n#if (LIMB_SIZE_HALF_448 > LIMB_SIZE_448/2)\n\tb0[LIMB_SIZE_HALF_448-1] &= ((mpi_limb_t)1UL << 32)-1;\n\ta2[LIMB_SIZE_HALF_448-1] &= ((mpi_limb_t)1UL << 32)-1;\n\n\tb1_rest = 0;\n\ta3_rest = 0;\n\n\tfor (i = (wsize + 1) / 2 - 1; i >= 0; i--) {\n\t\tmpi_limb_t b1v, a3v;\n\t\tb1v = b1[i];\n\t\ta3v = a3[i];\n\t\tb1[i] = (b1_rest << 32) | (b1v >> 32);\n\t\ta3[i] = (a3_rest << 32) | (a3v >> 32);\n\t\tb1_rest = b1v & (((mpi_limb_t)1UL << 32)-1);\n\t\ta3_rest = a3v & (((mpi_limb_t)1UL << 32)-1);\n\t}\n#endif\n\n\tcy = mpihelp_add_n(b0, b0, a2, LIMB_SIZE_HALF_448);\n\tcy += mpihelp_add_n(b0, b0, a3, LIMB_SIZE_HALF_448);\n\tfor (i = 0; i < (wsize + 1) / 2; i++)\n\t\twp[i] = b0[i];\n#if (LIMB_SIZE_HALF_448 > LIMB_SIZE_448/2)\n\twp[LIMB_SIZE_HALF_448-1] &= (((mpi_limb_t)1UL << 32)-1);\n#endif\n\n#if (LIMB_SIZE_HALF_448 > LIMB_SIZE_448/2)\n\tcy = b0[LIMB_SIZE_HALF_448-1] >> 32;\n#endif\n\n\tcy = mpihelp_add_1(b1, b1, LIMB_SIZE_HALF_448, cy);\n\tcy += mpihelp_add_n(b1, b1, a2, LIMB_SIZE_HALF_448);\n\tcy += mpihelp_add_n(b1, b1, a3, LIMB_SIZE_HALF_448);\n\tcy += mpihelp_add_n(b1, b1, a3, LIMB_SIZE_HALF_448);\n#if (LIMB_SIZE_HALF_448 > LIMB_SIZE_448/2)\n\tb1_rest = 0;\n\tfor (i = (wsize + 1) / 2 - 1; i >= 0; i--) {\n\t\tmpi_limb_t b1v = b1[i];\n\t\tb1[i] = (b1_rest << 32) | (b1v >> 32);\n\t\tb1_rest = b1v & (((mpi_limb_t)1UL << 32)-1);\n\t}\n\twp[LIMB_SIZE_HALF_448-1] |= (b1_rest << 32);\n#endif\n\tfor (i = 0; i < wsize / 2; i++)\n\t\twp[i+(wsize + 1) / 2] = b1[i];\n\n#if (LIMB_SIZE_HALF_448 > LIMB_SIZE_448/2)\n\tcy = b1[LIMB_SIZE_HALF_448-1];\n#endif\n\n\tmemset(n, 0, wsize * BYTES_PER_MPI_LIMB);\n\n#if (LIMB_SIZE_HALF_448 > LIMB_SIZE_448/2)\n\tn[LIMB_SIZE_HALF_448-1] = cy << 32;\n#else\n\tn[LIMB_SIZE_HALF_448] = cy;\n#endif\n\tn[0] = cy;\n\tmpihelp_add_n(wp, wp, n, wsize);\n\n\tmemset(n, 0, wsize * BYTES_PER_MPI_LIMB);\n\tcy = mpihelp_sub_n(wp, wp, ctx->p->d, wsize);\n\tmpih_set_cond(n, ctx->p->d, wsize, (cy != 0UL));\n\tmpihelp_add_n(wp, wp, n, wsize);\n}\n\nstatic void ec_mul2_448(MPI w, MPI u, struct mpi_ec_ctx *ctx)\n{\n\tec_addm_448(w, u, u, ctx);\n}\n\nstatic void ec_pow2_448(MPI w, const MPI b, struct mpi_ec_ctx *ctx)\n{\n\tec_mulm_448(w, b, b, ctx);\n}\n\nstruct field_table {\n\tconst char *p;\n\n\t \n\tvoid (*addm)(MPI w, MPI u, MPI v, struct mpi_ec_ctx *ctx);\n\tvoid (*subm)(MPI w, MPI u, MPI v, struct mpi_ec_ctx *ctx);\n\tvoid (*mulm)(MPI w, MPI u, MPI v, struct mpi_ec_ctx *ctx);\n\tvoid (*mul2)(MPI w, MPI u, struct mpi_ec_ctx *ctx);\n\tvoid (*pow2)(MPI w, const MPI b, struct mpi_ec_ctx *ctx);\n};\n\nstatic const struct field_table field_table[] = {\n\t{\n\t\t\"0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFED\",\n\t\tec_addm_25519,\n\t\tec_subm_25519,\n\t\tec_mulm_25519,\n\t\tec_mul2_25519,\n\t\tec_pow2_25519\n\t},\n\t{\n\t\t\"0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFE\"\n\t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\",\n\t\tec_addm_448,\n\t\tec_subm_448,\n\t\tec_mulm_448,\n\t\tec_mul2_448,\n\t\tec_pow2_448\n\t},\n\t{ NULL, NULL, NULL, NULL, NULL, NULL },\n};\n\n \nstatic void mpi_ec_get_reset(struct mpi_ec_ctx *ec)\n{\n\tec->t.valid.a_is_pminus3 = 0;\n\tec->t.valid.two_inv_p = 0;\n}\n\n \nstatic int ec_get_a_is_pminus3(struct mpi_ec_ctx *ec)\n{\n\tMPI tmp;\n\n\tif (!ec->t.valid.a_is_pminus3) {\n\t\tec->t.valid.a_is_pminus3 = 1;\n\t\ttmp = mpi_alloc_like(ec->p);\n\t\tmpi_sub_ui(tmp, ec->p, 3);\n\t\tec->t.a_is_pminus3 = !mpi_cmp(ec->a, tmp);\n\t\tmpi_free(tmp);\n\t}\n\n\treturn ec->t.a_is_pminus3;\n}\n\n \nstatic MPI ec_get_two_inv_p(struct mpi_ec_ctx *ec)\n{\n\tif (!ec->t.valid.two_inv_p) {\n\t\tec->t.valid.two_inv_p = 1;\n\t\tif (!ec->t.two_inv_p)\n\t\t\tec->t.two_inv_p = mpi_alloc(0);\n\t\tec_invm(ec->t.two_inv_p, mpi_const(MPI_C_TWO), ec);\n\t}\n\treturn ec->t.two_inv_p;\n}\n\nstatic const char *const curve25519_bad_points[] = {\n\t\"0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffed\",\n\t\"0x0000000000000000000000000000000000000000000000000000000000000000\",\n\t\"0x0000000000000000000000000000000000000000000000000000000000000001\",\n\t\"0x00b8495f16056286fdb1329ceb8d09da6ac49ff1fae35616aeb8413b7c7aebe0\",\n\t\"0x57119fd0dd4e22d8868e1c58c45c44045bef839c55b1d0b1248c50a3bc959c5f\",\n\t\"0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec\",\n\t\"0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffee\",\n\tNULL\n};\n\nstatic const char *const curve448_bad_points[] = {\n\t\"0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffe\"\n\t\"ffffffffffffffffffffffffffffffffffffffffffffffffffffffff\",\n\t\"0x00000000000000000000000000000000000000000000000000000000\"\n\t\"00000000000000000000000000000000000000000000000000000000\",\n\t\"0x00000000000000000000000000000000000000000000000000000000\"\n\t\"00000000000000000000000000000000000000000000000000000001\",\n\t\"0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffe\"\n\t\"fffffffffffffffffffffffffffffffffffffffffffffffffffffffe\",\n\t\"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff\"\n\t\"00000000000000000000000000000000000000000000000000000000\",\n\tNULL\n};\n\nstatic const char *const *bad_points_table[] = {\n\tcurve25519_bad_points,\n\tcurve448_bad_points,\n};\n\nstatic void mpi_ec_coefficient_normalize(MPI a, MPI p)\n{\n\tif (a->sign) {\n\t\tmpi_resize(a, p->nlimbs);\n\t\tmpihelp_sub_n(a->d, p->d, a->d, p->nlimbs);\n\t\ta->nlimbs = p->nlimbs;\n\t\ta->sign = 0;\n\t}\n}\n\n \nvoid mpi_ec_init(struct mpi_ec_ctx *ctx, enum gcry_mpi_ec_models model,\n\t\t\tenum ecc_dialects dialect,\n\t\t\tint flags, MPI p, MPI a, MPI b)\n{\n\tint i;\n\tstatic int use_barrett = -1  ;\n\n\tmpi_ec_coefficient_normalize(a, p);\n\tmpi_ec_coefficient_normalize(b, p);\n\n\t \n\n\tctx->model = model;\n\tctx->dialect = dialect;\n\tctx->flags = flags;\n\tif (dialect == ECC_DIALECT_ED25519)\n\t\tctx->nbits = 256;\n\telse\n\t\tctx->nbits = mpi_get_nbits(p);\n\tctx->p = mpi_copy(p);\n\tctx->a = mpi_copy(a);\n\tctx->b = mpi_copy(b);\n\n\tctx->t.p_barrett = use_barrett > 0 ? mpi_barrett_init(ctx->p, 0) : NULL;\n\n\tmpi_ec_get_reset(ctx);\n\n\tif (model == MPI_EC_MONTGOMERY) {\n\t\tfor (i = 0; i < DIM(bad_points_table); i++) {\n\t\t\tMPI p_candidate = mpi_scanval(bad_points_table[i][0]);\n\t\t\tint match_p = !mpi_cmp(ctx->p, p_candidate);\n\t\t\tint j;\n\n\t\t\tmpi_free(p_candidate);\n\t\t\tif (!match_p)\n\t\t\t\tcontinue;\n\n\t\t\tfor (j = 0; i < DIM(ctx->t.scratch) && bad_points_table[i][j]; j++)\n\t\t\t\tctx->t.scratch[j] = mpi_scanval(bad_points_table[i][j]);\n\t\t}\n\t} else {\n\t\t \n\t\tfor (i = 0; i < DIM(ctx->t.scratch); i++)\n\t\t\tctx->t.scratch[i] = mpi_alloc_like(ctx->p);\n\t}\n\n\tctx->addm = ec_addm;\n\tctx->subm = ec_subm;\n\tctx->mulm = ec_mulm;\n\tctx->mul2 = ec_mul2;\n\tctx->pow2 = ec_pow2;\n\n\tfor (i = 0; field_table[i].p; i++) {\n\t\tMPI f_p;\n\n\t\tf_p = mpi_scanval(field_table[i].p);\n\t\tif (!f_p)\n\t\t\tbreak;\n\n\t\tif (!mpi_cmp(p, f_p)) {\n\t\t\tctx->addm = field_table[i].addm;\n\t\t\tctx->subm = field_table[i].subm;\n\t\t\tctx->mulm = field_table[i].mulm;\n\t\t\tctx->mul2 = field_table[i].mul2;\n\t\t\tctx->pow2 = field_table[i].pow2;\n\t\t\tmpi_free(f_p);\n\n\t\t\tmpi_resize(ctx->a, ctx->p->nlimbs);\n\t\t\tctx->a->nlimbs = ctx->p->nlimbs;\n\n\t\t\tmpi_resize(ctx->b, ctx->p->nlimbs);\n\t\t\tctx->b->nlimbs = ctx->p->nlimbs;\n\n\t\t\tfor (i = 0; i < DIM(ctx->t.scratch) && ctx->t.scratch[i]; i++)\n\t\t\t\tctx->t.scratch[i]->nlimbs = ctx->p->nlimbs;\n\n\t\t\tbreak;\n\t\t}\n\n\t\tmpi_free(f_p);\n\t}\n}\nEXPORT_SYMBOL_GPL(mpi_ec_init);\n\nvoid mpi_ec_deinit(struct mpi_ec_ctx *ctx)\n{\n\tint i;\n\n\tmpi_barrett_free(ctx->t.p_barrett);\n\n\t \n\tmpi_free(ctx->p);\n\tmpi_free(ctx->a);\n\tmpi_free(ctx->b);\n\tmpi_point_release(ctx->G);\n\tmpi_free(ctx->n);\n\n\t \n\tmpi_point_release(ctx->Q);\n\tmpi_free(ctx->d);\n\n\t \n\tmpi_free(ctx->t.two_inv_p);\n\n\tfor (i = 0; i < DIM(ctx->t.scratch); i++)\n\t\tmpi_free(ctx->t.scratch[i]);\n}\nEXPORT_SYMBOL_GPL(mpi_ec_deinit);\n\n \nint mpi_ec_get_affine(MPI x, MPI y, MPI_POINT point, struct mpi_ec_ctx *ctx)\n{\n\tif (!mpi_cmp_ui(point->z, 0))\n\t\treturn -1;\n\n\tswitch (ctx->model) {\n\tcase MPI_EC_WEIERSTRASS:  \n\t\t{\n\t\t\tMPI z1, z2, z3;\n\n\t\t\tz1 = mpi_new(0);\n\t\t\tz2 = mpi_new(0);\n\t\t\tec_invm(z1, point->z, ctx);   \n\t\t\tec_mulm(z2, z1, z1, ctx);     \n\n\t\t\tif (x)\n\t\t\t\tec_mulm(x, point->x, z2, ctx);\n\n\t\t\tif (y) {\n\t\t\t\tz3 = mpi_new(0);\n\t\t\t\tec_mulm(z3, z2, z1, ctx);       \n\t\t\t\tec_mulm(y, point->y, z3, ctx);\n\t\t\t\tmpi_free(z3);\n\t\t\t}\n\n\t\t\tmpi_free(z2);\n\t\t\tmpi_free(z1);\n\t\t}\n\t\treturn 0;\n\n\tcase MPI_EC_MONTGOMERY:\n\t\t{\n\t\t\tif (x)\n\t\t\t\tmpi_set(x, point->x);\n\n\t\t\tif (y) {\n\t\t\t\tlog_fatal(\"%s: Getting Y-coordinate on %s is not supported\\n\",\n\t\t\t\t\t\t\"mpi_ec_get_affine\", \"Montgomery\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\n\tcase MPI_EC_EDWARDS:\n\t\t{\n\t\t\tMPI z;\n\n\t\t\tz = mpi_new(0);\n\t\t\tec_invm(z, point->z, ctx);\n\n\t\t\tmpi_resize(z, ctx->p->nlimbs);\n\t\t\tz->nlimbs = ctx->p->nlimbs;\n\n\t\t\tif (x) {\n\t\t\t\tmpi_resize(x, ctx->p->nlimbs);\n\t\t\t\tx->nlimbs = ctx->p->nlimbs;\n\t\t\t\tctx->mulm(x, point->x, z, ctx);\n\t\t\t}\n\t\t\tif (y) {\n\t\t\t\tmpi_resize(y, ctx->p->nlimbs);\n\t\t\t\ty->nlimbs = ctx->p->nlimbs;\n\t\t\t\tctx->mulm(y, point->y, z, ctx);\n\t\t\t}\n\n\t\t\tmpi_free(z);\n\t\t}\n\t\treturn 0;\n\n\tdefault:\n\t\treturn -1;\n\t}\n}\nEXPORT_SYMBOL_GPL(mpi_ec_get_affine);\n\n \nstatic void dup_point_weierstrass(MPI_POINT result,\n\t\tMPI_POINT point, struct mpi_ec_ctx *ctx)\n{\n#define x3 (result->x)\n#define y3 (result->y)\n#define z3 (result->z)\n#define t1 (ctx->t.scratch[0])\n#define t2 (ctx->t.scratch[1])\n#define t3 (ctx->t.scratch[2])\n#define l1 (ctx->t.scratch[3])\n#define l2 (ctx->t.scratch[4])\n#define l3 (ctx->t.scratch[5])\n\n\tif (!mpi_cmp_ui(point->y, 0) || !mpi_cmp_ui(point->z, 0)) {\n\t\t \n\t\tmpi_set_ui(x3, 1);\n\t\tmpi_set_ui(y3, 1);\n\t\tmpi_set_ui(z3, 0);\n\t} else {\n\t\tif (ec_get_a_is_pminus3(ctx)) {\n\t\t\t \n\t\t\t \n\t\t\t \n\t\t\t \n\t\t\tec_pow2(t1, point->z, ctx);\n\t\t\tec_subm(l1, point->x, t1, ctx);\n\t\t\tec_mulm(l1, l1, mpi_const(MPI_C_THREE), ctx);\n\t\t\tec_addm(t2, point->x, t1, ctx);\n\t\t\tec_mulm(l1, l1, t2, ctx);\n\t\t} else {\n\t\t\t \n\t\t\t \n\t\t\t \n\t\t\tec_pow2(l1, point->x, ctx);\n\t\t\tec_mulm(l1, l1, mpi_const(MPI_C_THREE), ctx);\n\t\t\tec_powm(t1, point->z, mpi_const(MPI_C_FOUR), ctx);\n\t\t\tec_mulm(t1, t1, ctx->a, ctx);\n\t\t\tec_addm(l1, l1, t1, ctx);\n\t\t}\n\t\t \n\t\tec_mulm(z3, point->y, point->z, ctx);\n\t\tec_mul2(z3, z3, ctx);\n\n\t\t \n\t\t \n\t\tec_pow2(t2, point->y, ctx);\n\t\tec_mulm(l2, t2, point->x, ctx);\n\t\tec_mulm(l2, l2, mpi_const(MPI_C_FOUR), ctx);\n\n\t\t \n\t\t \n\t\tec_pow2(x3, l1, ctx);\n\t\tec_mul2(t1, l2, ctx);\n\t\tec_subm(x3, x3, t1, ctx);\n\n\t\t \n\t\t \n\t\tec_pow2(t2, t2, ctx);\n\t\tec_mulm(l3, t2, mpi_const(MPI_C_EIGHT), ctx);\n\n\t\t \n\t\tec_subm(y3, l2, x3, ctx);\n\t\tec_mulm(y3, y3, l1, ctx);\n\t\tec_subm(y3, y3, l3, ctx);\n\t}\n\n#undef x3\n#undef y3\n#undef z3\n#undef t1\n#undef t2\n#undef t3\n#undef l1\n#undef l2\n#undef l3\n}\n\n \nstatic void dup_point_montgomery(MPI_POINT result,\n\t\t\t\tMPI_POINT point, struct mpi_ec_ctx *ctx)\n{\n\t(void)result;\n\t(void)point;\n\t(void)ctx;\n\tlog_fatal(\"%s: %s not yet supported\\n\",\n\t\t\t\"mpi_ec_dup_point\", \"Montgomery\");\n}\n\n \nstatic void dup_point_edwards(MPI_POINT result,\n\t\tMPI_POINT point, struct mpi_ec_ctx *ctx)\n{\n#define X1 (point->x)\n#define Y1 (point->y)\n#define Z1 (point->z)\n#define X3 (result->x)\n#define Y3 (result->y)\n#define Z3 (result->z)\n#define B (ctx->t.scratch[0])\n#define C (ctx->t.scratch[1])\n#define D (ctx->t.scratch[2])\n#define E (ctx->t.scratch[3])\n#define F (ctx->t.scratch[4])\n#define H (ctx->t.scratch[5])\n#define J (ctx->t.scratch[6])\n\n\t \n\n\t \n\tctx->addm(B, X1, Y1, ctx);\n\tctx->pow2(B, B, ctx);\n\n\t \n\t \n\tctx->pow2(C, X1, ctx);\n\tctx->pow2(D, Y1, ctx);\n\n\t \n\tif (ctx->dialect == ECC_DIALECT_ED25519)\n\t\tctx->subm(E, ctx->p, C, ctx);\n\telse\n\t\tctx->mulm(E, ctx->a, C, ctx);\n\n\t \n\tctx->addm(F, E, D, ctx);\n\n\t \n\tctx->pow2(H, Z1, ctx);\n\n\t \n\tctx->mul2(J, H, ctx);\n\tctx->subm(J, F, J, ctx);\n\n\t \n\tctx->subm(X3, B, C, ctx);\n\tctx->subm(X3, X3, D, ctx);\n\tctx->mulm(X3, X3, J, ctx);\n\n\t \n\tctx->subm(Y3, E, D, ctx);\n\tctx->mulm(Y3, Y3, F, ctx);\n\n\t \n\tctx->mulm(Z3, F, J, ctx);\n\n#undef X1\n#undef Y1\n#undef Z1\n#undef X3\n#undef Y3\n#undef Z3\n#undef B\n#undef C\n#undef D\n#undef E\n#undef F\n#undef H\n#undef J\n}\n\n \nstatic void\nmpi_ec_dup_point(MPI_POINT result, MPI_POINT point, struct mpi_ec_ctx *ctx)\n{\n\tswitch (ctx->model) {\n\tcase MPI_EC_WEIERSTRASS:\n\t\tdup_point_weierstrass(result, point, ctx);\n\t\tbreak;\n\tcase MPI_EC_MONTGOMERY:\n\t\tdup_point_montgomery(result, point, ctx);\n\t\tbreak;\n\tcase MPI_EC_EDWARDS:\n\t\tdup_point_edwards(result, point, ctx);\n\t\tbreak;\n\t}\n}\n\n \nstatic void add_points_weierstrass(MPI_POINT result,\n\t\tMPI_POINT p1, MPI_POINT p2,\n\t\tstruct mpi_ec_ctx *ctx)\n{\n#define x1 (p1->x)\n#define y1 (p1->y)\n#define z1 (p1->z)\n#define x2 (p2->x)\n#define y2 (p2->y)\n#define z2 (p2->z)\n#define x3 (result->x)\n#define y3 (result->y)\n#define z3 (result->z)\n#define l1 (ctx->t.scratch[0])\n#define l2 (ctx->t.scratch[1])\n#define l3 (ctx->t.scratch[2])\n#define l4 (ctx->t.scratch[3])\n#define l5 (ctx->t.scratch[4])\n#define l6 (ctx->t.scratch[5])\n#define l7 (ctx->t.scratch[6])\n#define l8 (ctx->t.scratch[7])\n#define l9 (ctx->t.scratch[8])\n#define t1 (ctx->t.scratch[9])\n#define t2 (ctx->t.scratch[10])\n\n\tif ((!mpi_cmp(x1, x2)) && (!mpi_cmp(y1, y2)) && (!mpi_cmp(z1, z2))) {\n\t\t \n\t\tmpi_ec_dup_point(result, p1, ctx);\n\t} else if (!mpi_cmp_ui(z1, 0)) {\n\t\t \n\t\tmpi_set(x3, p2->x);\n\t\tmpi_set(y3, p2->y);\n\t\tmpi_set(z3, p2->z);\n\t} else if (!mpi_cmp_ui(z2, 0)) {\n\t\t \n\t\tmpi_set(x3, p1->x);\n\t\tmpi_set(y3, p1->y);\n\t\tmpi_set(z3, p1->z);\n\t} else {\n\t\tint z1_is_one = !mpi_cmp_ui(z1, 1);\n\t\tint z2_is_one = !mpi_cmp_ui(z2, 1);\n\n\t\t \n\t\t \n\t\tif (z2_is_one)\n\t\t\tmpi_set(l1, x1);\n\t\telse {\n\t\t\tec_pow2(l1, z2, ctx);\n\t\t\tec_mulm(l1, l1, x1, ctx);\n\t\t}\n\t\tif (z1_is_one)\n\t\t\tmpi_set(l2, x2);\n\t\telse {\n\t\t\tec_pow2(l2, z1, ctx);\n\t\t\tec_mulm(l2, l2, x2, ctx);\n\t\t}\n\t\t \n\t\tec_subm(l3, l1, l2, ctx);\n\t\t \n\t\tec_powm(l4, z2, mpi_const(MPI_C_THREE), ctx);\n\t\tec_mulm(l4, l4, y1, ctx);\n\t\t \n\t\tec_powm(l5, z1, mpi_const(MPI_C_THREE), ctx);\n\t\tec_mulm(l5, l5, y2, ctx);\n\t\t \n\t\tec_subm(l6, l4, l5, ctx);\n\n\t\tif (!mpi_cmp_ui(l3, 0)) {\n\t\t\tif (!mpi_cmp_ui(l6, 0)) {\n\t\t\t\t \n\t\t\t\tmpi_ec_dup_point(result, p1, ctx);\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tmpi_set_ui(x3, 1);\n\t\t\t\tmpi_set_ui(y3, 1);\n\t\t\t\tmpi_set_ui(z3, 0);\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tec_addm(l7, l1, l2, ctx);\n\t\t\t \n\t\t\tec_addm(l8, l4, l5, ctx);\n\t\t\t \n\t\t\tec_mulm(z3, z1, z2, ctx);\n\t\t\tec_mulm(z3, z3, l3, ctx);\n\t\t\t \n\t\t\tec_pow2(t1, l6, ctx);\n\t\t\tec_pow2(t2, l3, ctx);\n\t\t\tec_mulm(t2, t2, l7, ctx);\n\t\t\tec_subm(x3, t1, t2, ctx);\n\t\t\t \n\t\t\tec_mul2(t1, x3, ctx);\n\t\t\tec_subm(l9, t2, t1, ctx);\n\t\t\t \n\t\t\tec_mulm(l9, l9, l6, ctx);\n\t\t\tec_powm(t1, l3, mpi_const(MPI_C_THREE), ctx);  \n\t\t\tec_mulm(t1, t1, l8, ctx);\n\t\t\tec_subm(y3, l9, t1, ctx);\n\t\t\tec_mulm(y3, y3, ec_get_two_inv_p(ctx), ctx);\n\t\t}\n\t}\n\n#undef x1\n#undef y1\n#undef z1\n#undef x2\n#undef y2\n#undef z2\n#undef x3\n#undef y3\n#undef z3\n#undef l1\n#undef l2\n#undef l3\n#undef l4\n#undef l5\n#undef l6\n#undef l7\n#undef l8\n#undef l9\n#undef t1\n#undef t2\n}\n\n \nstatic void add_points_montgomery(MPI_POINT result,\n\t\tMPI_POINT p1, MPI_POINT p2,\n\t\tstruct mpi_ec_ctx *ctx)\n{\n\t(void)result;\n\t(void)p1;\n\t(void)p2;\n\t(void)ctx;\n\tlog_fatal(\"%s: %s not yet supported\\n\",\n\t\t\t\"mpi_ec_add_points\", \"Montgomery\");\n}\n\n \nstatic void add_points_edwards(MPI_POINT result,\n\t\tMPI_POINT p1, MPI_POINT p2,\n\t\tstruct mpi_ec_ctx *ctx)\n{\n#define X1 (p1->x)\n#define Y1 (p1->y)\n#define Z1 (p1->z)\n#define X2 (p2->x)\n#define Y2 (p2->y)\n#define Z2 (p2->z)\n#define X3 (result->x)\n#define Y3 (result->y)\n#define Z3 (result->z)\n#define A (ctx->t.scratch[0])\n#define B (ctx->t.scratch[1])\n#define C (ctx->t.scratch[2])\n#define D (ctx->t.scratch[3])\n#define E (ctx->t.scratch[4])\n#define F (ctx->t.scratch[5])\n#define G (ctx->t.scratch[6])\n#define tmp (ctx->t.scratch[7])\n\n\tpoint_resize(result, ctx);\n\n\t \n\n\t \n\tctx->mulm(A, Z1, Z2, ctx);\n\n\t \n\tctx->pow2(B, A, ctx);\n\n\t \n\tctx->mulm(C, X1, X2, ctx);\n\n\t \n\tctx->mulm(D, Y1, Y2, ctx);\n\n\t \n\tctx->mulm(E, ctx->b, C, ctx);\n\tctx->mulm(E, E, D, ctx);\n\n\t \n\tctx->subm(F, B, E, ctx);\n\n\t \n\tctx->addm(G, B, E, ctx);\n\n\t \n\tctx->addm(tmp, X1, Y1, ctx);\n\tctx->addm(X3, X2, Y2, ctx);\n\tctx->mulm(X3, X3, tmp, ctx);\n\tctx->subm(X3, X3, C, ctx);\n\tctx->subm(X3, X3, D, ctx);\n\tctx->mulm(X3, X3, F, ctx);\n\tctx->mulm(X3, X3, A, ctx);\n\n\t \n\tif (ctx->dialect == ECC_DIALECT_ED25519) {\n\t\tctx->addm(Y3, D, C, ctx);\n\t} else {\n\t\tctx->mulm(Y3, ctx->a, C, ctx);\n\t\tctx->subm(Y3, D, Y3, ctx);\n\t}\n\tctx->mulm(Y3, Y3, G, ctx);\n\tctx->mulm(Y3, Y3, A, ctx);\n\n\t \n\tctx->mulm(Z3, F, G, ctx);\n\n\n#undef X1\n#undef Y1\n#undef Z1\n#undef X2\n#undef Y2\n#undef Z2\n#undef X3\n#undef Y3\n#undef Z3\n#undef A\n#undef B\n#undef C\n#undef D\n#undef E\n#undef F\n#undef G\n#undef tmp\n}\n\n \nstatic void montgomery_ladder(MPI_POINT prd, MPI_POINT sum,\n\t\tMPI_POINT p1, MPI_POINT p2, MPI dif_x,\n\t\tstruct mpi_ec_ctx *ctx)\n{\n\tctx->addm(sum->x, p2->x, p2->z, ctx);\n\tctx->subm(p2->z, p2->x, p2->z, ctx);\n\tctx->addm(prd->x, p1->x, p1->z, ctx);\n\tctx->subm(p1->z, p1->x, p1->z, ctx);\n\tctx->mulm(p2->x, p1->z, sum->x, ctx);\n\tctx->mulm(p2->z, prd->x, p2->z, ctx);\n\tctx->pow2(p1->x, prd->x, ctx);\n\tctx->pow2(p1->z, p1->z, ctx);\n\tctx->addm(sum->x, p2->x, p2->z, ctx);\n\tctx->subm(p2->z, p2->x, p2->z, ctx);\n\tctx->mulm(prd->x, p1->x, p1->z, ctx);\n\tctx->subm(p1->z, p1->x, p1->z, ctx);\n\tctx->pow2(sum->x, sum->x, ctx);\n\tctx->pow2(sum->z, p2->z, ctx);\n\tctx->mulm(prd->z, p1->z, ctx->a, ctx);  \n\tctx->mulm(sum->z, sum->z, dif_x, ctx);\n\tctx->addm(prd->z, p1->x, prd->z, ctx);\n\tctx->mulm(prd->z, prd->z, p1->z, ctx);\n}\n\n \nvoid mpi_ec_add_points(MPI_POINT result,\n\t\tMPI_POINT p1, MPI_POINT p2,\n\t\tstruct mpi_ec_ctx *ctx)\n{\n\tswitch (ctx->model) {\n\tcase MPI_EC_WEIERSTRASS:\n\t\tadd_points_weierstrass(result, p1, p2, ctx);\n\t\tbreak;\n\tcase MPI_EC_MONTGOMERY:\n\t\tadd_points_montgomery(result, p1, p2, ctx);\n\t\tbreak;\n\tcase MPI_EC_EDWARDS:\n\t\tadd_points_edwards(result, p1, p2, ctx);\n\t\tbreak;\n\t}\n}\nEXPORT_SYMBOL_GPL(mpi_ec_add_points);\n\n \nvoid mpi_ec_mul_point(MPI_POINT result,\n\t\t\tMPI scalar, MPI_POINT point,\n\t\t\tstruct mpi_ec_ctx *ctx)\n{\n\tMPI x1, y1, z1, k, h, yy;\n\tunsigned int i, loops;\n\tstruct gcry_mpi_point p1, p2, p1inv;\n\n\tif (ctx->model == MPI_EC_EDWARDS) {\n\t\t \n\t\tunsigned int nbits;\n\t\tint j;\n\n\t\tif (mpi_cmp(scalar, ctx->p) >= 0)\n\t\t\tnbits = mpi_get_nbits(scalar);\n\t\telse\n\t\t\tnbits = mpi_get_nbits(ctx->p);\n\n\t\tmpi_set_ui(result->x, 0);\n\t\tmpi_set_ui(result->y, 1);\n\t\tmpi_set_ui(result->z, 1);\n\t\tpoint_resize(point, ctx);\n\n\t\tpoint_resize(result, ctx);\n\t\tpoint_resize(point, ctx);\n\n\t\tfor (j = nbits-1; j >= 0; j--) {\n\t\t\tmpi_ec_dup_point(result, result, ctx);\n\t\t\tif (mpi_test_bit(scalar, j))\n\t\t\t\tmpi_ec_add_points(result, result, point, ctx);\n\t\t}\n\t\treturn;\n\t} else if (ctx->model == MPI_EC_MONTGOMERY) {\n\t\tunsigned int nbits;\n\t\tint j;\n\t\tstruct gcry_mpi_point p1_, p2_;\n\t\tMPI_POINT q1, q2, prd, sum;\n\t\tunsigned long sw;\n\t\tmpi_size_t rsize;\n\n\t\t \n\n\t\tnbits = mpi_get_nbits(scalar);\n\t\tpoint_init(&p1);\n\t\tpoint_init(&p2);\n\t\tpoint_init(&p1_);\n\t\tpoint_init(&p2_);\n\t\tmpi_set_ui(p1.x, 1);\n\t\tmpi_free(p2.x);\n\t\tp2.x = mpi_copy(point->x);\n\t\tmpi_set_ui(p2.z, 1);\n\n\t\tpoint_resize(&p1, ctx);\n\t\tpoint_resize(&p2, ctx);\n\t\tpoint_resize(&p1_, ctx);\n\t\tpoint_resize(&p2_, ctx);\n\n\t\tmpi_resize(point->x, ctx->p->nlimbs);\n\t\tpoint->x->nlimbs = ctx->p->nlimbs;\n\n\t\tq1 = &p1;\n\t\tq2 = &p2;\n\t\tprd = &p1_;\n\t\tsum = &p2_;\n\n\t\tfor (j = nbits-1; j >= 0; j--) {\n\t\t\tMPI_POINT t;\n\n\t\t\tsw = mpi_test_bit(scalar, j);\n\t\t\tpoint_swap_cond(q1, q2, sw, ctx);\n\t\t\tmontgomery_ladder(prd, sum, q1, q2, point->x, ctx);\n\t\t\tpoint_swap_cond(prd, sum, sw, ctx);\n\t\t\tt = q1;  q1 = prd;  prd = t;\n\t\t\tt = q2;  q2 = sum;  sum = t;\n\t\t}\n\n\t\tmpi_clear(result->y);\n\t\tsw = (nbits & 1);\n\t\tpoint_swap_cond(&p1, &p1_, sw, ctx);\n\n\t\trsize = p1.z->nlimbs;\n\t\tMPN_NORMALIZE(p1.z->d, rsize);\n\t\tif (rsize == 0) {\n\t\t\tmpi_set_ui(result->x, 1);\n\t\t\tmpi_set_ui(result->z, 0);\n\t\t} else {\n\t\t\tz1 = mpi_new(0);\n\t\t\tec_invm(z1, p1.z, ctx);\n\t\t\tec_mulm(result->x, p1.x, z1, ctx);\n\t\t\tmpi_set_ui(result->z, 1);\n\t\t\tmpi_free(z1);\n\t\t}\n\n\t\tpoint_free(&p1);\n\t\tpoint_free(&p2);\n\t\tpoint_free(&p1_);\n\t\tpoint_free(&p2_);\n\t\treturn;\n\t}\n\n\tx1 = mpi_alloc_like(ctx->p);\n\ty1 = mpi_alloc_like(ctx->p);\n\th  = mpi_alloc_like(ctx->p);\n\tk  = mpi_copy(scalar);\n\tyy = mpi_copy(point->y);\n\n\tif (mpi_has_sign(k)) {\n\t\tk->sign = 0;\n\t\tec_invm(yy, yy, ctx);\n\t}\n\n\tif (!mpi_cmp_ui(point->z, 1)) {\n\t\tmpi_set(x1, point->x);\n\t\tmpi_set(y1, yy);\n\t} else {\n\t\tMPI z2, z3;\n\n\t\tz2 = mpi_alloc_like(ctx->p);\n\t\tz3 = mpi_alloc_like(ctx->p);\n\t\tec_mulm(z2, point->z, point->z, ctx);\n\t\tec_mulm(z3, point->z, z2, ctx);\n\t\tec_invm(z2, z2, ctx);\n\t\tec_mulm(x1, point->x, z2, ctx);\n\t\tec_invm(z3, z3, ctx);\n\t\tec_mulm(y1, yy, z3, ctx);\n\t\tmpi_free(z2);\n\t\tmpi_free(z3);\n\t}\n\tz1 = mpi_copy(mpi_const(MPI_C_ONE));\n\n\tmpi_mul(h, k, mpi_const(MPI_C_THREE));  \n\tloops = mpi_get_nbits(h);\n\tif (loops < 2) {\n\t\t \n\t\tloops = 2;\n\t\tmpi_clear(result->x);\n\t\tmpi_clear(result->y);\n\t\tmpi_clear(result->z);\n\t} else {\n\t\tmpi_set(result->x, point->x);\n\t\tmpi_set(result->y, yy);\n\t\tmpi_set(result->z, point->z);\n\t}\n\tmpi_free(yy); yy = NULL;\n\n\tp1.x = x1; x1 = NULL;\n\tp1.y = y1; y1 = NULL;\n\tp1.z = z1; z1 = NULL;\n\tpoint_init(&p2);\n\tpoint_init(&p1inv);\n\n\t \n\tpoint_set(&p1inv, &p1);\n\tec_subm(p1inv.y, ctx->p, p1inv.y, ctx);\n\n\tfor (i = loops-2; i > 0; i--) {\n\t\tmpi_ec_dup_point(result, result, ctx);\n\t\tif (mpi_test_bit(h, i) == 1 && mpi_test_bit(k, i) == 0) {\n\t\t\tpoint_set(&p2, result);\n\t\t\tmpi_ec_add_points(result, &p2, &p1, ctx);\n\t\t}\n\t\tif (mpi_test_bit(h, i) == 0 && mpi_test_bit(k, i) == 1) {\n\t\t\tpoint_set(&p2, result);\n\t\t\tmpi_ec_add_points(result, &p2, &p1inv, ctx);\n\t\t}\n\t}\n\n\tpoint_free(&p1);\n\tpoint_free(&p2);\n\tpoint_free(&p1inv);\n\tmpi_free(h);\n\tmpi_free(k);\n}\nEXPORT_SYMBOL_GPL(mpi_ec_mul_point);\n\n \nint mpi_ec_curve_point(MPI_POINT point, struct mpi_ec_ctx *ctx)\n{\n\tint res = 0;\n\tMPI x, y, w;\n\n\tx = mpi_new(0);\n\ty = mpi_new(0);\n\tw = mpi_new(0);\n\n\t \n\tif (mpi_cmpabs(point->x, ctx->p) >= 0)\n\t\tgoto leave;\n\tif (mpi_cmpabs(point->y, ctx->p) >= 0)\n\t\tgoto leave;\n\tif (mpi_cmpabs(point->z, ctx->p) >= 0)\n\t\tgoto leave;\n\n\tswitch (ctx->model) {\n\tcase MPI_EC_WEIERSTRASS:\n\t\t{\n\t\t\tMPI xxx;\n\n\t\t\tif (mpi_ec_get_affine(x, y, point, ctx))\n\t\t\t\tgoto leave;\n\n\t\t\txxx = mpi_new(0);\n\n\t\t\t \n\t\t\tec_pow2(y, y, ctx);\n\n\t\t\tec_pow3(xxx, x, ctx);\n\t\t\tec_mulm(w, ctx->a, x, ctx);\n\t\t\tec_addm(w, w, ctx->b, ctx);\n\t\t\tec_addm(w, w, xxx, ctx);\n\n\t\t\tif (!mpi_cmp(y, w))\n\t\t\t\tres = 1;\n\n\t\t\tmpi_free(xxx);\n\t\t}\n\t\tbreak;\n\n\tcase MPI_EC_MONTGOMERY:\n\t\t{\n#define xx y\n\t\t\t \n\t\t\tif (mpi_ec_get_affine(x, NULL, point, ctx))\n\t\t\t\tgoto leave;\n\n\t\t\t \n\t\t\t \n\t\t\t \n\t\t\tec_mulm(w, ctx->a, mpi_const(MPI_C_FOUR), ctx);\n\t\t\tec_addm(w, w, mpi_const(MPI_C_TWO), ctx);\n\t\t\tec_mulm(w, w, x, ctx);\n\t\t\tec_pow2(xx, x, ctx);\n\t\t\tec_addm(w, w, xx, ctx);\n\t\t\tec_addm(w, w, mpi_const(MPI_C_ONE), ctx);\n\t\t\tec_mulm(w, w, x, ctx);\n\t\t\tec_mulm(w, w, ctx->b, ctx);\n#undef xx\n\t\t\t \n#define p_minus1 y\n\t\t\tec_subm(p_minus1, ctx->p, mpi_const(MPI_C_ONE), ctx);\n\t\t\tmpi_rshift(p_minus1, p_minus1, 1);\n\t\t\tec_powm(w, w, p_minus1, ctx);\n\n\t\t\tres = !mpi_cmp_ui(w, 1);\n#undef p_minus1\n\t\t}\n\t\tbreak;\n\n\tcase MPI_EC_EDWARDS:\n\t\t{\n\t\t\tif (mpi_ec_get_affine(x, y, point, ctx))\n\t\t\t\tgoto leave;\n\n\t\t\tmpi_resize(w, ctx->p->nlimbs);\n\t\t\tw->nlimbs = ctx->p->nlimbs;\n\n\t\t\t \n\t\t\tctx->pow2(x, x, ctx);\n\t\t\tctx->pow2(y, y, ctx);\n\t\t\tif (ctx->dialect == ECC_DIALECT_ED25519)\n\t\t\t\tctx->subm(w, ctx->p, x, ctx);\n\t\t\telse\n\t\t\t\tctx->mulm(w, ctx->a, x, ctx);\n\t\t\tctx->addm(w, w, y, ctx);\n\t\t\tctx->mulm(x, x, y, ctx);\n\t\t\tctx->mulm(x, x, ctx->b, ctx);\n\t\t\tctx->subm(w, w, x, ctx);\n\t\t\tif (!mpi_cmp_ui(w, 1))\n\t\t\t\tres = 1;\n\t\t}\n\t\tbreak;\n\t}\n\nleave:\n\tmpi_free(w);\n\tmpi_free(x);\n\tmpi_free(y);\n\n\treturn res;\n}\nEXPORT_SYMBOL_GPL(mpi_ec_curve_point);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}