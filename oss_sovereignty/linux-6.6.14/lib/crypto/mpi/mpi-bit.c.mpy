{
  "module_name": "mpi-bit.c",
  "hash_id": "30dcb4220f268b3eab7f005620ae6229c6ae7a20d03a5c300f56b55159a6aeb8",
  "original_prompt": "Ingested from linux-6.6.14/lib/crypto/mpi/mpi-bit.c",
  "human_readable_source": " \n\n#include \"mpi-internal.h\"\n#include \"longlong.h\"\n\n#define A_LIMB_1 ((mpi_limb_t) 1)\n\n \nvoid mpi_normalize(MPI a)\n{\n\tfor (; a->nlimbs && !a->d[a->nlimbs - 1]; a->nlimbs--)\n\t\t;\n}\nEXPORT_SYMBOL_GPL(mpi_normalize);\n\n \nunsigned mpi_get_nbits(MPI a)\n{\n\tunsigned n;\n\n\tmpi_normalize(a);\n\n\tif (a->nlimbs) {\n\t\tmpi_limb_t alimb = a->d[a->nlimbs - 1];\n\t\tif (alimb)\n\t\t\tn = count_leading_zeros(alimb);\n\t\telse\n\t\t\tn = BITS_PER_MPI_LIMB;\n\t\tn = BITS_PER_MPI_LIMB - n + (a->nlimbs - 1) * BITS_PER_MPI_LIMB;\n\t} else\n\t\tn = 0;\n\treturn n;\n}\nEXPORT_SYMBOL_GPL(mpi_get_nbits);\n\n \nint mpi_test_bit(MPI a, unsigned int n)\n{\n\tunsigned int limbno, bitno;\n\tmpi_limb_t limb;\n\n\tlimbno = n / BITS_PER_MPI_LIMB;\n\tbitno  = n % BITS_PER_MPI_LIMB;\n\n\tif (limbno >= a->nlimbs)\n\t\treturn 0;  \n\tlimb = a->d[limbno];\n\treturn (limb & (A_LIMB_1 << bitno)) ? 1 : 0;\n}\nEXPORT_SYMBOL_GPL(mpi_test_bit);\n\n \nvoid mpi_set_bit(MPI a, unsigned int n)\n{\n\tunsigned int i, limbno, bitno;\n\n\tlimbno = n / BITS_PER_MPI_LIMB;\n\tbitno  = n % BITS_PER_MPI_LIMB;\n\n\tif (limbno >= a->nlimbs) {\n\t\tfor (i = a->nlimbs; i < a->alloced; i++)\n\t\t\ta->d[i] = 0;\n\t\tmpi_resize(a, limbno+1);\n\t\ta->nlimbs = limbno+1;\n\t}\n\ta->d[limbno] |= (A_LIMB_1<<bitno);\n}\n\n \nvoid mpi_set_highbit(MPI a, unsigned int n)\n{\n\tunsigned int i, limbno, bitno;\n\n\tlimbno = n / BITS_PER_MPI_LIMB;\n\tbitno  = n % BITS_PER_MPI_LIMB;\n\n\tif (limbno >= a->nlimbs) {\n\t\tfor (i = a->nlimbs; i < a->alloced; i++)\n\t\t\ta->d[i] = 0;\n\t\tmpi_resize(a, limbno+1);\n\t\ta->nlimbs = limbno+1;\n\t}\n\ta->d[limbno] |= (A_LIMB_1<<bitno);\n\tfor (bitno++; bitno < BITS_PER_MPI_LIMB; bitno++)\n\t\ta->d[limbno] &= ~(A_LIMB_1 << bitno);\n\ta->nlimbs = limbno+1;\n}\nEXPORT_SYMBOL_GPL(mpi_set_highbit);\n\n \nvoid mpi_clear_highbit(MPI a, unsigned int n)\n{\n\tunsigned int limbno, bitno;\n\n\tlimbno = n / BITS_PER_MPI_LIMB;\n\tbitno  = n % BITS_PER_MPI_LIMB;\n\n\tif (limbno >= a->nlimbs)\n\t\treturn;  \n\n\tfor ( ; bitno < BITS_PER_MPI_LIMB; bitno++)\n\t\ta->d[limbno] &= ~(A_LIMB_1 << bitno);\n\ta->nlimbs = limbno+1;\n}\n\n \nvoid mpi_clear_bit(MPI a, unsigned int n)\n{\n\tunsigned int limbno, bitno;\n\n\tlimbno = n / BITS_PER_MPI_LIMB;\n\tbitno  = n % BITS_PER_MPI_LIMB;\n\n\tif (limbno >= a->nlimbs)\n\t\treturn;  \n\ta->d[limbno] &= ~(A_LIMB_1 << bitno);\n}\nEXPORT_SYMBOL_GPL(mpi_clear_bit);\n\n\n \nvoid mpi_rshift_limbs(MPI a, unsigned int count)\n{\n\tmpi_ptr_t ap = a->d;\n\tmpi_size_t n = a->nlimbs;\n\tunsigned int i;\n\n\tif (count >= n) {\n\t\ta->nlimbs = 0;\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < n - count; i++)\n\t\tap[i] = ap[i+count];\n\tap[i] = 0;\n\ta->nlimbs -= count;\n}\n\n \nvoid mpi_rshift(MPI x, MPI a, unsigned int n)\n{\n\tmpi_size_t xsize;\n\tunsigned int i;\n\tunsigned int nlimbs = (n/BITS_PER_MPI_LIMB);\n\tunsigned int nbits = (n%BITS_PER_MPI_LIMB);\n\n\tif (x == a) {\n\t\t \n\t\tif (nlimbs >= x->nlimbs) {\n\t\t\tx->nlimbs = 0;\n\t\t\treturn;\n\t\t}\n\n\t\tif (nlimbs) {\n\t\t\tfor (i = 0; i < x->nlimbs - nlimbs; i++)\n\t\t\t\tx->d[i] = x->d[i+nlimbs];\n\t\t\tx->d[i] = 0;\n\t\t\tx->nlimbs -= nlimbs;\n\t\t}\n\t\tif (x->nlimbs && nbits)\n\t\t\tmpihelp_rshift(x->d, x->d, x->nlimbs, nbits);\n\t} else if (nlimbs) {\n\t\t \n\t\txsize = a->nlimbs;\n\t\tx->sign = a->sign;\n\t\tRESIZE_IF_NEEDED(x, xsize);\n\t\tx->nlimbs = xsize;\n\t\tfor (i = 0; i < a->nlimbs; i++)\n\t\t\tx->d[i] = a->d[i];\n\t\tx->nlimbs = i;\n\n\t\tif (nlimbs >= x->nlimbs) {\n\t\t\tx->nlimbs = 0;\n\t\t\treturn;\n\t\t}\n\n\t\tif (nlimbs) {\n\t\t\tfor (i = 0; i < x->nlimbs - nlimbs; i++)\n\t\t\t\tx->d[i] = x->d[i+nlimbs];\n\t\t\tx->d[i] = 0;\n\t\t\tx->nlimbs -= nlimbs;\n\t\t}\n\n\t\tif (x->nlimbs && nbits)\n\t\t\tmpihelp_rshift(x->d, x->d, x->nlimbs, nbits);\n\t} else {\n\t\t \n\t\txsize = a->nlimbs;\n\t\tx->sign = a->sign;\n\t\tRESIZE_IF_NEEDED(x, xsize);\n\t\tx->nlimbs = xsize;\n\n\t\tif (xsize) {\n\t\t\tif (nbits)\n\t\t\t\tmpihelp_rshift(x->d, a->d, x->nlimbs, nbits);\n\t\t\telse {\n\t\t\t\t \n\t\t\t\tfor (i = 0; i < x->nlimbs; i++)\n\t\t\t\t\tx->d[i] = a->d[i];\n\t\t\t}\n\t\t}\n\t}\n\tMPN_NORMALIZE(x->d, x->nlimbs);\n}\nEXPORT_SYMBOL_GPL(mpi_rshift);\n\n \nvoid mpi_lshift_limbs(MPI a, unsigned int count)\n{\n\tmpi_ptr_t ap;\n\tint n = a->nlimbs;\n\tint i;\n\n\tif (!count || !n)\n\t\treturn;\n\n\tRESIZE_IF_NEEDED(a, n+count);\n\n\tap = a->d;\n\tfor (i = n-1; i >= 0; i--)\n\t\tap[i+count] = ap[i];\n\tfor (i = 0; i < count; i++)\n\t\tap[i] = 0;\n\ta->nlimbs += count;\n}\n\n \nvoid mpi_lshift(MPI x, MPI a, unsigned int n)\n{\n\tunsigned int nlimbs = (n/BITS_PER_MPI_LIMB);\n\tunsigned int nbits = (n%BITS_PER_MPI_LIMB);\n\n\tif (x == a && !n)\n\t\treturn;   \n\n\tif (x != a) {\n\t\t \n\t\tunsigned int alimbs = a->nlimbs;\n\t\tint asign = a->sign;\n\t\tmpi_ptr_t xp, ap;\n\n\t\tRESIZE_IF_NEEDED(x, alimbs+nlimbs+1);\n\t\txp = x->d;\n\t\tap = a->d;\n\t\tMPN_COPY(xp, ap, alimbs);\n\t\tx->nlimbs = alimbs;\n\t\tx->flags = a->flags;\n\t\tx->sign = asign;\n\t}\n\n\tif (nlimbs && !nbits) {\n\t\t \n\t\tmpi_lshift_limbs(x, nlimbs);\n\t} else if (n) {\n\t\t \n\t\tmpi_lshift_limbs(x, nlimbs+1);\n\t\tmpi_rshift(x, x, BITS_PER_MPI_LIMB - nbits);\n\t}\n\n\tMPN_NORMALIZE(x->d, x->nlimbs);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}