{
  "module_name": "chacha.c",
  "hash_id": "6e8c8a10b0c244b2749d187f6a6df1b2d190670bf5aadb5e59b68fa51a57c40a",
  "original_prompt": "Ingested from linux-6.6.14/lib/crypto/chacha.c",
  "human_readable_source": "\n \n\n#include <linux/bug.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/string.h>\n#include <asm/unaligned.h>\n#include <crypto/chacha.h>\n\nstatic void chacha_permute(u32 *x, int nrounds)\n{\n\tint i;\n\n\t \n\tWARN_ON_ONCE(nrounds != 20 && nrounds != 12);\n\n\tfor (i = 0; i < nrounds; i += 2) {\n\t\tx[0]  += x[4];    x[12] = rol32(x[12] ^ x[0],  16);\n\t\tx[1]  += x[5];    x[13] = rol32(x[13] ^ x[1],  16);\n\t\tx[2]  += x[6];    x[14] = rol32(x[14] ^ x[2],  16);\n\t\tx[3]  += x[7];    x[15] = rol32(x[15] ^ x[3],  16);\n\n\t\tx[8]  += x[12];   x[4]  = rol32(x[4]  ^ x[8],  12);\n\t\tx[9]  += x[13];   x[5]  = rol32(x[5]  ^ x[9],  12);\n\t\tx[10] += x[14];   x[6]  = rol32(x[6]  ^ x[10], 12);\n\t\tx[11] += x[15];   x[7]  = rol32(x[7]  ^ x[11], 12);\n\n\t\tx[0]  += x[4];    x[12] = rol32(x[12] ^ x[0],   8);\n\t\tx[1]  += x[5];    x[13] = rol32(x[13] ^ x[1],   8);\n\t\tx[2]  += x[6];    x[14] = rol32(x[14] ^ x[2],   8);\n\t\tx[3]  += x[7];    x[15] = rol32(x[15] ^ x[3],   8);\n\n\t\tx[8]  += x[12];   x[4]  = rol32(x[4]  ^ x[8],   7);\n\t\tx[9]  += x[13];   x[5]  = rol32(x[5]  ^ x[9],   7);\n\t\tx[10] += x[14];   x[6]  = rol32(x[6]  ^ x[10],  7);\n\t\tx[11] += x[15];   x[7]  = rol32(x[7]  ^ x[11],  7);\n\n\t\tx[0]  += x[5];    x[15] = rol32(x[15] ^ x[0],  16);\n\t\tx[1]  += x[6];    x[12] = rol32(x[12] ^ x[1],  16);\n\t\tx[2]  += x[7];    x[13] = rol32(x[13] ^ x[2],  16);\n\t\tx[3]  += x[4];    x[14] = rol32(x[14] ^ x[3],  16);\n\n\t\tx[10] += x[15];   x[5]  = rol32(x[5]  ^ x[10], 12);\n\t\tx[11] += x[12];   x[6]  = rol32(x[6]  ^ x[11], 12);\n\t\tx[8]  += x[13];   x[7]  = rol32(x[7]  ^ x[8],  12);\n\t\tx[9]  += x[14];   x[4]  = rol32(x[4]  ^ x[9],  12);\n\n\t\tx[0]  += x[5];    x[15] = rol32(x[15] ^ x[0],   8);\n\t\tx[1]  += x[6];    x[12] = rol32(x[12] ^ x[1],   8);\n\t\tx[2]  += x[7];    x[13] = rol32(x[13] ^ x[2],   8);\n\t\tx[3]  += x[4];    x[14] = rol32(x[14] ^ x[3],   8);\n\n\t\tx[10] += x[15];   x[5]  = rol32(x[5]  ^ x[10],  7);\n\t\tx[11] += x[12];   x[6]  = rol32(x[6]  ^ x[11],  7);\n\t\tx[8]  += x[13];   x[7]  = rol32(x[7]  ^ x[8],   7);\n\t\tx[9]  += x[14];   x[4]  = rol32(x[4]  ^ x[9],   7);\n\t}\n}\n\n \nvoid chacha_block_generic(u32 *state, u8 *stream, int nrounds)\n{\n\tu32 x[16];\n\tint i;\n\n\tmemcpy(x, state, 64);\n\n\tchacha_permute(x, nrounds);\n\n\tfor (i = 0; i < ARRAY_SIZE(x); i++)\n\t\tput_unaligned_le32(x[i] + state[i], &stream[i * sizeof(u32)]);\n\n\tstate[12]++;\n}\nEXPORT_SYMBOL(chacha_block_generic);\n\n \nvoid hchacha_block_generic(const u32 *state, u32 *stream, int nrounds)\n{\n\tu32 x[16];\n\n\tmemcpy(x, state, 64);\n\n\tchacha_permute(x, nrounds);\n\n\tmemcpy(&stream[0], &x[0], 16);\n\tmemcpy(&stream[4], &x[12], 16);\n}\nEXPORT_SYMBOL(hchacha_block_generic);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}