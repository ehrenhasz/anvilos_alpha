{
  "module_name": "gf128mul.c",
  "hash_id": "63c74ddb497a9fafdb330646435a7659d90c6e95e2100c72cbcaea131c92efd9",
  "original_prompt": "Ingested from linux-6.6.14/lib/crypto/gf128mul.c",
  "human_readable_source": " \n\n \n\n#include <crypto/gf128mul.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\n#define gf128mul_dat(q) { \\\n\tq(0x00), q(0x01), q(0x02), q(0x03), q(0x04), q(0x05), q(0x06), q(0x07),\\\n\tq(0x08), q(0x09), q(0x0a), q(0x0b), q(0x0c), q(0x0d), q(0x0e), q(0x0f),\\\n\tq(0x10), q(0x11), q(0x12), q(0x13), q(0x14), q(0x15), q(0x16), q(0x17),\\\n\tq(0x18), q(0x19), q(0x1a), q(0x1b), q(0x1c), q(0x1d), q(0x1e), q(0x1f),\\\n\tq(0x20), q(0x21), q(0x22), q(0x23), q(0x24), q(0x25), q(0x26), q(0x27),\\\n\tq(0x28), q(0x29), q(0x2a), q(0x2b), q(0x2c), q(0x2d), q(0x2e), q(0x2f),\\\n\tq(0x30), q(0x31), q(0x32), q(0x33), q(0x34), q(0x35), q(0x36), q(0x37),\\\n\tq(0x38), q(0x39), q(0x3a), q(0x3b), q(0x3c), q(0x3d), q(0x3e), q(0x3f),\\\n\tq(0x40), q(0x41), q(0x42), q(0x43), q(0x44), q(0x45), q(0x46), q(0x47),\\\n\tq(0x48), q(0x49), q(0x4a), q(0x4b), q(0x4c), q(0x4d), q(0x4e), q(0x4f),\\\n\tq(0x50), q(0x51), q(0x52), q(0x53), q(0x54), q(0x55), q(0x56), q(0x57),\\\n\tq(0x58), q(0x59), q(0x5a), q(0x5b), q(0x5c), q(0x5d), q(0x5e), q(0x5f),\\\n\tq(0x60), q(0x61), q(0x62), q(0x63), q(0x64), q(0x65), q(0x66), q(0x67),\\\n\tq(0x68), q(0x69), q(0x6a), q(0x6b), q(0x6c), q(0x6d), q(0x6e), q(0x6f),\\\n\tq(0x70), q(0x71), q(0x72), q(0x73), q(0x74), q(0x75), q(0x76), q(0x77),\\\n\tq(0x78), q(0x79), q(0x7a), q(0x7b), q(0x7c), q(0x7d), q(0x7e), q(0x7f),\\\n\tq(0x80), q(0x81), q(0x82), q(0x83), q(0x84), q(0x85), q(0x86), q(0x87),\\\n\tq(0x88), q(0x89), q(0x8a), q(0x8b), q(0x8c), q(0x8d), q(0x8e), q(0x8f),\\\n\tq(0x90), q(0x91), q(0x92), q(0x93), q(0x94), q(0x95), q(0x96), q(0x97),\\\n\tq(0x98), q(0x99), q(0x9a), q(0x9b), q(0x9c), q(0x9d), q(0x9e), q(0x9f),\\\n\tq(0xa0), q(0xa1), q(0xa2), q(0xa3), q(0xa4), q(0xa5), q(0xa6), q(0xa7),\\\n\tq(0xa8), q(0xa9), q(0xaa), q(0xab), q(0xac), q(0xad), q(0xae), q(0xaf),\\\n\tq(0xb0), q(0xb1), q(0xb2), q(0xb3), q(0xb4), q(0xb5), q(0xb6), q(0xb7),\\\n\tq(0xb8), q(0xb9), q(0xba), q(0xbb), q(0xbc), q(0xbd), q(0xbe), q(0xbf),\\\n\tq(0xc0), q(0xc1), q(0xc2), q(0xc3), q(0xc4), q(0xc5), q(0xc6), q(0xc7),\\\n\tq(0xc8), q(0xc9), q(0xca), q(0xcb), q(0xcc), q(0xcd), q(0xce), q(0xcf),\\\n\tq(0xd0), q(0xd1), q(0xd2), q(0xd3), q(0xd4), q(0xd5), q(0xd6), q(0xd7),\\\n\tq(0xd8), q(0xd9), q(0xda), q(0xdb), q(0xdc), q(0xdd), q(0xde), q(0xdf),\\\n\tq(0xe0), q(0xe1), q(0xe2), q(0xe3), q(0xe4), q(0xe5), q(0xe6), q(0xe7),\\\n\tq(0xe8), q(0xe9), q(0xea), q(0xeb), q(0xec), q(0xed), q(0xee), q(0xef),\\\n\tq(0xf0), q(0xf1), q(0xf2), q(0xf3), q(0xf4), q(0xf5), q(0xf6), q(0xf7),\\\n\tq(0xf8), q(0xf9), q(0xfa), q(0xfb), q(0xfc), q(0xfd), q(0xfe), q(0xff) \\\n}\n\n \n\n#define xda_be(i) ( \\\n\t(i & 0x80 ? 0x4380 : 0) ^ (i & 0x40 ? 0x21c0 : 0) ^ \\\n\t(i & 0x20 ? 0x10e0 : 0) ^ (i & 0x10 ? 0x0870 : 0) ^ \\\n\t(i & 0x08 ? 0x0438 : 0) ^ (i & 0x04 ? 0x021c : 0) ^ \\\n\t(i & 0x02 ? 0x010e : 0) ^ (i & 0x01 ? 0x0087 : 0) \\\n)\n\n#define xda_le(i) ( \\\n\t(i & 0x80 ? 0xe100 : 0) ^ (i & 0x40 ? 0x7080 : 0) ^ \\\n\t(i & 0x20 ? 0x3840 : 0) ^ (i & 0x10 ? 0x1c20 : 0) ^ \\\n\t(i & 0x08 ? 0x0e10 : 0) ^ (i & 0x04 ? 0x0708 : 0) ^ \\\n\t(i & 0x02 ? 0x0384 : 0) ^ (i & 0x01 ? 0x01c2 : 0) \\\n)\n\nstatic const u16 gf128mul_table_le[256] = gf128mul_dat(xda_le);\nstatic const u16 gf128mul_table_be[256] = gf128mul_dat(xda_be);\n\n \n\nstatic void gf128mul_x8_lle(be128 *x)\n{\n\tu64 a = be64_to_cpu(x->a);\n\tu64 b = be64_to_cpu(x->b);\n\tu64 _tt = gf128mul_table_le[b & 0xff];\n\n\tx->b = cpu_to_be64((b >> 8) | (a << 56));\n\tx->a = cpu_to_be64((a >> 8) ^ (_tt << 48));\n}\n\n \nstatic void gf128mul_x8_lle_ti(be128 *x)\n{\n\tu64 a = be64_to_cpu(x->a);\n\tu64 b = be64_to_cpu(x->b);\n\tu64 _tt = xda_le(b & 0xff);  \n\n\tx->b = cpu_to_be64((b >> 8) | (a << 56));\n\tx->a = cpu_to_be64((a >> 8) ^ (_tt << 48));\n}\n\nstatic void gf128mul_x8_bbe(be128 *x)\n{\n\tu64 a = be64_to_cpu(x->a);\n\tu64 b = be64_to_cpu(x->b);\n\tu64 _tt = gf128mul_table_be[a >> 56];\n\n\tx->a = cpu_to_be64((a << 8) | (b >> 56));\n\tx->b = cpu_to_be64((b << 8) ^ _tt);\n}\n\nvoid gf128mul_x8_ble(le128 *r, const le128 *x)\n{\n\tu64 a = le64_to_cpu(x->a);\n\tu64 b = le64_to_cpu(x->b);\n\tu64 _tt = gf128mul_table_be[a >> 56];\n\n\tr->a = cpu_to_le64((a << 8) | (b >> 56));\n\tr->b = cpu_to_le64((b << 8) ^ _tt);\n}\nEXPORT_SYMBOL(gf128mul_x8_ble);\n\nvoid gf128mul_lle(be128 *r, const be128 *b)\n{\n\t \n\tbe128 array[16 + 3] = {};\n\tbe128 *p = PTR_ALIGN(&array[0], 2 * sizeof(be128));\n\tint i;\n\n\tp[0] = *r;\n\tfor (i = 0; i < 7; ++i)\n\t\tgf128mul_x_lle(&p[2 * i + 2], &p[2 * i]);\n\n\tmemset(r, 0, sizeof(*r));\n\tfor (i = 0;;) {\n\t\tu8 ch = ((u8 *)b)[15 - i];\n\n\t\tbe128_xor(r, r, &p[ 0 + !(ch & 0x80)]);\n\t\tbe128_xor(r, r, &p[ 2 + !(ch & 0x40)]);\n\t\tbe128_xor(r, r, &p[ 4 + !(ch & 0x20)]);\n\t\tbe128_xor(r, r, &p[ 6 + !(ch & 0x10)]);\n\t\tbe128_xor(r, r, &p[ 8 + !(ch & 0x08)]);\n\t\tbe128_xor(r, r, &p[10 + !(ch & 0x04)]);\n\t\tbe128_xor(r, r, &p[12 + !(ch & 0x02)]);\n\t\tbe128_xor(r, r, &p[14 + !(ch & 0x01)]);\n\n\t\tif (++i >= 16)\n\t\t\tbreak;\n\n\t\tgf128mul_x8_lle_ti(r);  \n\t}\n}\nEXPORT_SYMBOL(gf128mul_lle);\n\nvoid gf128mul_bbe(be128 *r, const be128 *b)\n{\n\tbe128 p[8];\n\tint i;\n\n\tp[0] = *r;\n\tfor (i = 0; i < 7; ++i)\n\t\tgf128mul_x_bbe(&p[i + 1], &p[i]);\n\n\tmemset(r, 0, sizeof(*r));\n\tfor (i = 0;;) {\n\t\tu8 ch = ((u8 *)b)[i];\n\n\t\tif (ch & 0x80)\n\t\t\tbe128_xor(r, r, &p[7]);\n\t\tif (ch & 0x40)\n\t\t\tbe128_xor(r, r, &p[6]);\n\t\tif (ch & 0x20)\n\t\t\tbe128_xor(r, r, &p[5]);\n\t\tif (ch & 0x10)\n\t\t\tbe128_xor(r, r, &p[4]);\n\t\tif (ch & 0x08)\n\t\t\tbe128_xor(r, r, &p[3]);\n\t\tif (ch & 0x04)\n\t\t\tbe128_xor(r, r, &p[2]);\n\t\tif (ch & 0x02)\n\t\t\tbe128_xor(r, r, &p[1]);\n\t\tif (ch & 0x01)\n\t\t\tbe128_xor(r, r, &p[0]);\n\n\t\tif (++i >= 16)\n\t\t\tbreak;\n\n\t\tgf128mul_x8_bbe(r);\n\t}\n}\nEXPORT_SYMBOL(gf128mul_bbe);\n\n \n \nstruct gf128mul_64k *gf128mul_init_64k_bbe(const be128 *g)\n{\n\tstruct gf128mul_64k *t;\n\tint i, j, k;\n\n\tt = kzalloc(sizeof(*t), GFP_KERNEL);\n\tif (!t)\n\t\tgoto out;\n\n\tfor (i = 0; i < 16; i++) {\n\t\tt->t[i] = kzalloc(sizeof(*t->t[i]), GFP_KERNEL);\n\t\tif (!t->t[i]) {\n\t\t\tgf128mul_free_64k(t);\n\t\t\tt = NULL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tt->t[0]->t[1] = *g;\n\tfor (j = 1; j <= 64; j <<= 1)\n\t\tgf128mul_x_bbe(&t->t[0]->t[j + j], &t->t[0]->t[j]);\n\n\tfor (i = 0;;) {\n\t\tfor (j = 2; j < 256; j += j)\n\t\t\tfor (k = 1; k < j; ++k)\n\t\t\t\tbe128_xor(&t->t[i]->t[j + k],\n\t\t\t\t\t  &t->t[i]->t[j], &t->t[i]->t[k]);\n\n\t\tif (++i >= 16)\n\t\t\tbreak;\n\n\t\tfor (j = 128; j > 0; j >>= 1) {\n\t\t\tt->t[i]->t[j] = t->t[i - 1]->t[j];\n\t\t\tgf128mul_x8_bbe(&t->t[i]->t[j]);\n\t\t}\n\t}\n\nout:\n\treturn t;\n}\nEXPORT_SYMBOL(gf128mul_init_64k_bbe);\n\nvoid gf128mul_free_64k(struct gf128mul_64k *t)\n{\n\tint i;\n\n\tfor (i = 0; i < 16; i++)\n\t\tkfree_sensitive(t->t[i]);\n\tkfree_sensitive(t);\n}\nEXPORT_SYMBOL(gf128mul_free_64k);\n\nvoid gf128mul_64k_bbe(be128 *a, const struct gf128mul_64k *t)\n{\n\tu8 *ap = (u8 *)a;\n\tbe128 r[1];\n\tint i;\n\n\t*r = t->t[0]->t[ap[15]];\n\tfor (i = 1; i < 16; ++i)\n\t\tbe128_xor(r, r, &t->t[i]->t[ap[15 - i]]);\n\t*a = *r;\n}\nEXPORT_SYMBOL(gf128mul_64k_bbe);\n\n \nstruct gf128mul_4k *gf128mul_init_4k_lle(const be128 *g)\n{\n\tstruct gf128mul_4k *t;\n\tint j, k;\n\n\tt = kzalloc(sizeof(*t), GFP_KERNEL);\n\tif (!t)\n\t\tgoto out;\n\n\tt->t[128] = *g;\n\tfor (j = 64; j > 0; j >>= 1)\n\t\tgf128mul_x_lle(&t->t[j], &t->t[j+j]);\n\n\tfor (j = 2; j < 256; j += j)\n\t\tfor (k = 1; k < j; ++k)\n\t\t\tbe128_xor(&t->t[j + k], &t->t[j], &t->t[k]);\n\nout:\n\treturn t;\n}\nEXPORT_SYMBOL(gf128mul_init_4k_lle);\n\nstruct gf128mul_4k *gf128mul_init_4k_bbe(const be128 *g)\n{\n\tstruct gf128mul_4k *t;\n\tint j, k;\n\n\tt = kzalloc(sizeof(*t), GFP_KERNEL);\n\tif (!t)\n\t\tgoto out;\n\n\tt->t[1] = *g;\n\tfor (j = 1; j <= 64; j <<= 1)\n\t\tgf128mul_x_bbe(&t->t[j + j], &t->t[j]);\n\n\tfor (j = 2; j < 256; j += j)\n\t\tfor (k = 1; k < j; ++k)\n\t\t\tbe128_xor(&t->t[j + k], &t->t[j], &t->t[k]);\n\nout:\n\treturn t;\n}\nEXPORT_SYMBOL(gf128mul_init_4k_bbe);\n\nvoid gf128mul_4k_lle(be128 *a, const struct gf128mul_4k *t)\n{\n\tu8 *ap = (u8 *)a;\n\tbe128 r[1];\n\tint i = 15;\n\n\t*r = t->t[ap[15]];\n\twhile (i--) {\n\t\tgf128mul_x8_lle(r);\n\t\tbe128_xor(r, r, &t->t[ap[i]]);\n\t}\n\t*a = *r;\n}\nEXPORT_SYMBOL(gf128mul_4k_lle);\n\nvoid gf128mul_4k_bbe(be128 *a, const struct gf128mul_4k *t)\n{\n\tu8 *ap = (u8 *)a;\n\tbe128 r[1];\n\tint i = 0;\n\n\t*r = t->t[ap[0]];\n\twhile (++i < 16) {\n\t\tgf128mul_x8_bbe(r);\n\t\tbe128_xor(r, r, &t->t[ap[i]]);\n\t}\n\t*a = *r;\n}\nEXPORT_SYMBOL(gf128mul_4k_bbe);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"Functions for multiplying elements of GF(2^128)\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}