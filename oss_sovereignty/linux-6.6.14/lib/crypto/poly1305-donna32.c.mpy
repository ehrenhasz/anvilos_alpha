{
  "module_name": "poly1305-donna32.c",
  "hash_id": "726aeef99c223919cfdc839abba72674d3755c2bb1bccb435084466144838c32",
  "original_prompt": "Ingested from linux-6.6.14/lib/crypto/poly1305-donna32.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <asm/unaligned.h>\n#include <crypto/internal/poly1305.h>\n\nvoid poly1305_core_setkey(struct poly1305_core_key *key,\n\t\t\t  const u8 raw_key[POLY1305_BLOCK_SIZE])\n{\n\t \n\tkey->key.r[0] = (get_unaligned_le32(&raw_key[0])) & 0x3ffffff;\n\tkey->key.r[1] = (get_unaligned_le32(&raw_key[3]) >> 2) & 0x3ffff03;\n\tkey->key.r[2] = (get_unaligned_le32(&raw_key[6]) >> 4) & 0x3ffc0ff;\n\tkey->key.r[3] = (get_unaligned_le32(&raw_key[9]) >> 6) & 0x3f03fff;\n\tkey->key.r[4] = (get_unaligned_le32(&raw_key[12]) >> 8) & 0x00fffff;\n\n\t \n\tkey->precomputed_s.r[0] = key->key.r[1] * 5;\n\tkey->precomputed_s.r[1] = key->key.r[2] * 5;\n\tkey->precomputed_s.r[2] = key->key.r[3] * 5;\n\tkey->precomputed_s.r[3] = key->key.r[4] * 5;\n}\nEXPORT_SYMBOL(poly1305_core_setkey);\n\nvoid poly1305_core_blocks(struct poly1305_state *state,\n\t\t\t  const struct poly1305_core_key *key, const void *src,\n\t\t\t  unsigned int nblocks, u32 hibit)\n{\n\tconst u8 *input = src;\n\tu32 r0, r1, r2, r3, r4;\n\tu32 s1, s2, s3, s4;\n\tu32 h0, h1, h2, h3, h4;\n\tu64 d0, d1, d2, d3, d4;\n\tu32 c;\n\n\tif (!nblocks)\n\t\treturn;\n\n\thibit <<= 24;\n\n\tr0 = key->key.r[0];\n\tr1 = key->key.r[1];\n\tr2 = key->key.r[2];\n\tr3 = key->key.r[3];\n\tr4 = key->key.r[4];\n\n\ts1 = key->precomputed_s.r[0];\n\ts2 = key->precomputed_s.r[1];\n\ts3 = key->precomputed_s.r[2];\n\ts4 = key->precomputed_s.r[3];\n\n\th0 = state->h[0];\n\th1 = state->h[1];\n\th2 = state->h[2];\n\th3 = state->h[3];\n\th4 = state->h[4];\n\n\tdo {\n\t\t \n\t\th0 += (get_unaligned_le32(&input[0])) & 0x3ffffff;\n\t\th1 += (get_unaligned_le32(&input[3]) >> 2) & 0x3ffffff;\n\t\th2 += (get_unaligned_le32(&input[6]) >> 4) & 0x3ffffff;\n\t\th3 += (get_unaligned_le32(&input[9]) >> 6) & 0x3ffffff;\n\t\th4 += (get_unaligned_le32(&input[12]) >> 8) | hibit;\n\n\t\t \n\t\td0 = ((u64)h0 * r0) + ((u64)h1 * s4) +\n\t\t     ((u64)h2 * s3) + ((u64)h3 * s2) +\n\t\t     ((u64)h4 * s1);\n\t\td1 = ((u64)h0 * r1) + ((u64)h1 * r0) +\n\t\t     ((u64)h2 * s4) + ((u64)h3 * s3) +\n\t\t     ((u64)h4 * s2);\n\t\td2 = ((u64)h0 * r2) + ((u64)h1 * r1) +\n\t\t     ((u64)h2 * r0) + ((u64)h3 * s4) +\n\t\t     ((u64)h4 * s3);\n\t\td3 = ((u64)h0 * r3) + ((u64)h1 * r2) +\n\t\t     ((u64)h2 * r1) + ((u64)h3 * r0) +\n\t\t     ((u64)h4 * s4);\n\t\td4 = ((u64)h0 * r4) + ((u64)h1 * r3) +\n\t\t     ((u64)h2 * r2) + ((u64)h3 * r1) +\n\t\t     ((u64)h4 * r0);\n\n\t\t \n\t\tc = (u32)(d0 >> 26);\n\t\th0 = (u32)d0 & 0x3ffffff;\n\t\td1 += c;\n\t\tc = (u32)(d1 >> 26);\n\t\th1 = (u32)d1 & 0x3ffffff;\n\t\td2 += c;\n\t\tc = (u32)(d2 >> 26);\n\t\th2 = (u32)d2 & 0x3ffffff;\n\t\td3 += c;\n\t\tc = (u32)(d3 >> 26);\n\t\th3 = (u32)d3 & 0x3ffffff;\n\t\td4 += c;\n\t\tc = (u32)(d4 >> 26);\n\t\th4 = (u32)d4 & 0x3ffffff;\n\t\th0 += c * 5;\n\t\tc = (h0 >> 26);\n\t\th0 = h0 & 0x3ffffff;\n\t\th1 += c;\n\n\t\tinput += POLY1305_BLOCK_SIZE;\n\t} while (--nblocks);\n\n\tstate->h[0] = h0;\n\tstate->h[1] = h1;\n\tstate->h[2] = h2;\n\tstate->h[3] = h3;\n\tstate->h[4] = h4;\n}\nEXPORT_SYMBOL(poly1305_core_blocks);\n\nvoid poly1305_core_emit(const struct poly1305_state *state, const u32 nonce[4],\n\t\t\tvoid *dst)\n{\n\tu8 *mac = dst;\n\tu32 h0, h1, h2, h3, h4, c;\n\tu32 g0, g1, g2, g3, g4;\n\tu64 f;\n\tu32 mask;\n\n\t \n\th0 = state->h[0];\n\th1 = state->h[1];\n\th2 = state->h[2];\n\th3 = state->h[3];\n\th4 = state->h[4];\n\n\tc = h1 >> 26;\n\th1 = h1 & 0x3ffffff;\n\th2 += c;\n\tc = h2 >> 26;\n\th2 = h2 & 0x3ffffff;\n\th3 += c;\n\tc = h3 >> 26;\n\th3 = h3 & 0x3ffffff;\n\th4 += c;\n\tc = h4 >> 26;\n\th4 = h4 & 0x3ffffff;\n\th0 += c * 5;\n\tc = h0 >> 26;\n\th0 = h0 & 0x3ffffff;\n\th1 += c;\n\n\t \n\tg0 = h0 + 5;\n\tc = g0 >> 26;\n\tg0 &= 0x3ffffff;\n\tg1 = h1 + c;\n\tc = g1 >> 26;\n\tg1 &= 0x3ffffff;\n\tg2 = h2 + c;\n\tc = g2 >> 26;\n\tg2 &= 0x3ffffff;\n\tg3 = h3 + c;\n\tc = g3 >> 26;\n\tg3 &= 0x3ffffff;\n\tg4 = h4 + c - (1UL << 26);\n\n\t \n\tmask = (g4 >> ((sizeof(u32) * 8) - 1)) - 1;\n\tg0 &= mask;\n\tg1 &= mask;\n\tg2 &= mask;\n\tg3 &= mask;\n\tg4 &= mask;\n\tmask = ~mask;\n\n\th0 = (h0 & mask) | g0;\n\th1 = (h1 & mask) | g1;\n\th2 = (h2 & mask) | g2;\n\th3 = (h3 & mask) | g3;\n\th4 = (h4 & mask) | g4;\n\n\t \n\th0 = ((h0) | (h1 << 26)) & 0xffffffff;\n\th1 = ((h1 >> 6) | (h2 << 20)) & 0xffffffff;\n\th2 = ((h2 >> 12) | (h3 << 14)) & 0xffffffff;\n\th3 = ((h3 >> 18) | (h4 << 8)) & 0xffffffff;\n\n\tif (likely(nonce)) {\n\t\t \n\t\tf = (u64)h0 + nonce[0];\n\t\th0 = (u32)f;\n\t\tf = (u64)h1 + nonce[1] + (f >> 32);\n\t\th1 = (u32)f;\n\t\tf = (u64)h2 + nonce[2] + (f >> 32);\n\t\th2 = (u32)f;\n\t\tf = (u64)h3 + nonce[3] + (f >> 32);\n\t\th3 = (u32)f;\n\t}\n\n\tput_unaligned_le32(h0, &mac[0]);\n\tput_unaligned_le32(h1, &mac[4]);\n\tput_unaligned_le32(h2, &mac[8]);\n\tput_unaligned_le32(h3, &mac[12]);\n}\nEXPORT_SYMBOL(poly1305_core_emit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}