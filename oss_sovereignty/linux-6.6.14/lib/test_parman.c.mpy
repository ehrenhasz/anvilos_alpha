{
  "module_name": "test_parman.c",
  "hash_id": "aca7b74e3bbb926cb0fa100f42dec9279fd60b2f08f6eb63ed73733f7b2ce987",
  "original_prompt": "Ingested from linux-6.6.14/lib/test_parman.c",
  "human_readable_source": " \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/err.h>\n#include <linux/random.h>\n#include <linux/parman.h>\n\n#define TEST_PARMAN_PRIO_SHIFT 7  \n#define TEST_PARMAN_PRIO_COUNT BIT(TEST_PARMAN_PRIO_SHIFT)\n#define TEST_PARMAN_PRIO_MASK (TEST_PARMAN_PRIO_COUNT - 1)\n\n#define TEST_PARMAN_ITEM_SHIFT 13  \n#define TEST_PARMAN_ITEM_COUNT BIT(TEST_PARMAN_ITEM_SHIFT)\n#define TEST_PARMAN_ITEM_MASK (TEST_PARMAN_ITEM_COUNT - 1)\n\n#define TEST_PARMAN_BASE_SHIFT 8\n#define TEST_PARMAN_BASE_COUNT BIT(TEST_PARMAN_BASE_SHIFT)\n#define TEST_PARMAN_RESIZE_STEP_SHIFT 7\n#define TEST_PARMAN_RESIZE_STEP_COUNT BIT(TEST_PARMAN_RESIZE_STEP_SHIFT)\n\n#define TEST_PARMAN_BULK_MAX_SHIFT (2 + TEST_PARMAN_RESIZE_STEP_SHIFT)\n#define TEST_PARMAN_BULK_MAX_COUNT BIT(TEST_PARMAN_BULK_MAX_SHIFT)\n#define TEST_PARMAN_BULK_MAX_MASK (TEST_PARMAN_BULK_MAX_COUNT - 1)\n\n#define TEST_PARMAN_RUN_BUDGET (TEST_PARMAN_ITEM_COUNT * 256)\n\nstruct test_parman_prio {\n\tstruct parman_prio parman_prio;\n\tunsigned long priority;\n};\n\nstruct test_parman_item {\n\tstruct parman_item parman_item;\n\tstruct test_parman_prio *prio;\n\tbool used;\n};\n\nstruct test_parman {\n\tstruct parman *parman;\n\tstruct test_parman_item **prio_array;\n\tunsigned long prio_array_limit;\n\tstruct test_parman_prio prios[TEST_PARMAN_PRIO_COUNT];\n\tstruct test_parman_item items[TEST_PARMAN_ITEM_COUNT];\n\tstruct rnd_state rnd;\n\tunsigned long run_budget;\n\tunsigned long bulk_budget;\n\tbool bulk_noop;\n\tunsigned int used_items;\n};\n\n#define ITEM_PTRS_SIZE(count) (sizeof(struct test_parman_item *) * (count))\n\nstatic int test_parman_resize(void *priv, unsigned long new_count)\n{\n\tstruct test_parman *test_parman = priv;\n\tstruct test_parman_item **prio_array;\n\tunsigned long old_count;\n\n\tprio_array = krealloc(test_parman->prio_array,\n\t\t\t      ITEM_PTRS_SIZE(new_count), GFP_KERNEL);\n\tif (new_count == 0)\n\t\treturn 0;\n\tif (!prio_array)\n\t\treturn -ENOMEM;\n\told_count = test_parman->prio_array_limit;\n\tif (new_count > old_count)\n\t\tmemset(&prio_array[old_count], 0,\n\t\t       ITEM_PTRS_SIZE(new_count - old_count));\n\ttest_parman->prio_array = prio_array;\n\ttest_parman->prio_array_limit = new_count;\n\treturn 0;\n}\n\nstatic void test_parman_move(void *priv, unsigned long from_index,\n\t\t\t     unsigned long to_index, unsigned long count)\n{\n\tstruct test_parman *test_parman = priv;\n\tstruct test_parman_item **prio_array = test_parman->prio_array;\n\n\tmemmove(&prio_array[to_index], &prio_array[from_index],\n\t\tITEM_PTRS_SIZE(count));\n\tmemset(&prio_array[from_index], 0, ITEM_PTRS_SIZE(count));\n}\n\nstatic const struct parman_ops test_parman_lsort_ops = {\n\t.base_count\t= TEST_PARMAN_BASE_COUNT,\n\t.resize_step\t= TEST_PARMAN_RESIZE_STEP_COUNT,\n\t.resize\t\t= test_parman_resize,\n\t.move\t\t= test_parman_move,\n\t.algo\t\t= PARMAN_ALGO_TYPE_LSORT,\n};\n\nstatic void test_parman_rnd_init(struct test_parman *test_parman)\n{\n\tprandom_seed_state(&test_parman->rnd, 3141592653589793238ULL);\n}\n\nstatic u32 test_parman_rnd_get(struct test_parman *test_parman)\n{\n\treturn prandom_u32_state(&test_parman->rnd);\n}\n\nstatic unsigned long test_parman_priority_gen(struct test_parman *test_parman)\n{\n\tunsigned long priority;\n\tint i;\n\nagain:\n\tpriority = test_parman_rnd_get(test_parman);\n\tif (priority == 0)\n\t\tgoto again;\n\n\tfor (i = 0; i < TEST_PARMAN_PRIO_COUNT; i++) {\n\t\tstruct test_parman_prio *prio = &test_parman->prios[i];\n\n\t\tif (prio->priority == 0)\n\t\t\tbreak;\n\t\tif (prio->priority == priority)\n\t\t\tgoto again;\n\t}\n\treturn priority;\n}\n\nstatic void test_parman_prios_init(struct test_parman *test_parman)\n{\n\tint i;\n\n\tfor (i = 0; i < TEST_PARMAN_PRIO_COUNT; i++) {\n\t\tstruct test_parman_prio *prio = &test_parman->prios[i];\n\n\t\t \n\t\tprio->priority = test_parman_priority_gen(test_parman);\n\t\tparman_prio_init(test_parman->parman, &prio->parman_prio,\n\t\t\t\t prio->priority);\n\t}\n}\n\nstatic void test_parman_prios_fini(struct test_parman *test_parman)\n{\n\tint i;\n\n\tfor (i = 0; i < TEST_PARMAN_PRIO_COUNT; i++) {\n\t\tstruct test_parman_prio *prio = &test_parman->prios[i];\n\n\t\tparman_prio_fini(&prio->parman_prio);\n\t}\n}\n\nstatic void test_parman_items_init(struct test_parman *test_parman)\n{\n\tint i;\n\n\tfor (i = 0; i < TEST_PARMAN_ITEM_COUNT; i++) {\n\t\tstruct test_parman_item *item = &test_parman->items[i];\n\t\tunsigned int prio_index = test_parman_rnd_get(test_parman) &\n\t\t\t\t\t  TEST_PARMAN_PRIO_MASK;\n\n\t\t \n\t\titem->prio = &test_parman->prios[prio_index];\n\t}\n}\n\nstatic void test_parman_items_fini(struct test_parman *test_parman)\n{\n\tint i;\n\n\tfor (i = 0; i < TEST_PARMAN_ITEM_COUNT; i++) {\n\t\tstruct test_parman_item *item = &test_parman->items[i];\n\n\t\tif (!item->used)\n\t\t\tcontinue;\n\t\tparman_item_remove(test_parman->parman,\n\t\t\t\t   &item->prio->parman_prio,\n\t\t\t\t   &item->parman_item);\n\t}\n}\n\nstatic struct test_parman *test_parman_create(const struct parman_ops *ops)\n{\n\tstruct test_parman *test_parman;\n\tint err;\n\n\ttest_parman = kzalloc(sizeof(*test_parman), GFP_KERNEL);\n\tif (!test_parman)\n\t\treturn ERR_PTR(-ENOMEM);\n\terr = test_parman_resize(test_parman, TEST_PARMAN_BASE_COUNT);\n\tif (err)\n\t\tgoto err_resize;\n\ttest_parman->parman = parman_create(ops, test_parman);\n\tif (!test_parman->parman) {\n\t\terr = -ENOMEM;\n\t\tgoto err_parman_create;\n\t}\n\ttest_parman_rnd_init(test_parman);\n\ttest_parman_prios_init(test_parman);\n\ttest_parman_items_init(test_parman);\n\ttest_parman->run_budget = TEST_PARMAN_RUN_BUDGET;\n\treturn test_parman;\n\nerr_parman_create:\n\ttest_parman_resize(test_parman, 0);\nerr_resize:\n\tkfree(test_parman);\n\treturn ERR_PTR(err);\n}\n\nstatic void test_parman_destroy(struct test_parman *test_parman)\n{\n\ttest_parman_items_fini(test_parman);\n\ttest_parman_prios_fini(test_parman);\n\tparman_destroy(test_parman->parman);\n\ttest_parman_resize(test_parman, 0);\n\tkfree(test_parman);\n}\n\nstatic bool test_parman_run_check_budgets(struct test_parman *test_parman)\n{\n\tif (test_parman->run_budget-- == 0)\n\t\treturn false;\n\tif (test_parman->bulk_budget-- != 0)\n\t\treturn true;\n\n\ttest_parman->bulk_budget = test_parman_rnd_get(test_parman) &\n\t\t\t\t   TEST_PARMAN_BULK_MAX_MASK;\n\ttest_parman->bulk_noop = test_parman_rnd_get(test_parman) & 1;\n\treturn true;\n}\n\nstatic int test_parman_run(struct test_parman *test_parman)\n{\n\tunsigned int i = test_parman_rnd_get(test_parman);\n\tint err;\n\n\twhile (test_parman_run_check_budgets(test_parman)) {\n\t\tunsigned int item_index = i++ & TEST_PARMAN_ITEM_MASK;\n\t\tstruct test_parman_item *item = &test_parman->items[item_index];\n\n\t\tif (test_parman->bulk_noop)\n\t\t\tcontinue;\n\n\t\tif (!item->used) {\n\t\t\terr = parman_item_add(test_parman->parman,\n\t\t\t\t\t      &item->prio->parman_prio,\n\t\t\t\t\t      &item->parman_item);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\ttest_parman->prio_array[item->parman_item.index] = item;\n\t\t\ttest_parman->used_items++;\n\t\t} else {\n\t\t\ttest_parman->prio_array[item->parman_item.index] = NULL;\n\t\t\tparman_item_remove(test_parman->parman,\n\t\t\t\t\t   &item->prio->parman_prio,\n\t\t\t\t\t   &item->parman_item);\n\t\t\ttest_parman->used_items--;\n\t\t}\n\t\titem->used = !item->used;\n\t}\n\treturn 0;\n}\n\nstatic int test_parman_check_array(struct test_parman *test_parman,\n\t\t\t\t   bool gaps_allowed)\n{\n\tunsigned int last_unused_items = 0;\n\tunsigned long last_priority = 0;\n\tunsigned int used_items = 0;\n\tint i;\n\n\tif (test_parman->prio_array_limit < TEST_PARMAN_BASE_COUNT) {\n\t\tpr_err(\"Array limit is lower than the base count (%lu < %lu)\\n\",\n\t\t       test_parman->prio_array_limit, TEST_PARMAN_BASE_COUNT);\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < test_parman->prio_array_limit; i++) {\n\t\tstruct test_parman_item *item = test_parman->prio_array[i];\n\n\t\tif (!item) {\n\t\t\tlast_unused_items++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (last_unused_items && !gaps_allowed) {\n\t\t\tpr_err(\"Gap found in array even though they are forbidden\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tlast_unused_items = 0;\n\t\tused_items++;\n\n\t\tif (item->prio->priority < last_priority) {\n\t\t\tpr_err(\"Item belongs under higher priority then the last one (current: %lu, previous: %lu)\\n\",\n\t\t\t       item->prio->priority, last_priority);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tlast_priority = item->prio->priority;\n\n\t\tif (item->parman_item.index != i) {\n\t\t\tpr_err(\"Item has different index in compare to where it actually is (%lu != %d)\\n\",\n\t\t\t       item->parman_item.index, i);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (used_items != test_parman->used_items) {\n\t\tpr_err(\"Number of used items in array does not match (%u != %u)\\n\",\n\t\t       used_items, test_parman->used_items);\n\t\treturn -EINVAL;\n\t}\n\n\tif (last_unused_items >= TEST_PARMAN_RESIZE_STEP_COUNT) {\n\t\tpr_err(\"Number of unused item at the end of array is bigger than resize step (%u >= %lu)\\n\",\n\t\t       last_unused_items, TEST_PARMAN_RESIZE_STEP_COUNT);\n\t\treturn -EINVAL;\n\t}\n\n\tpr_info(\"Priority array check successful\\n\");\n\n\treturn 0;\n}\n\nstatic int test_parman_lsort(void)\n{\n\tstruct test_parman *test_parman;\n\tint err;\n\n\ttest_parman = test_parman_create(&test_parman_lsort_ops);\n\tif (IS_ERR(test_parman))\n\t\treturn PTR_ERR(test_parman);\n\n\terr = test_parman_run(test_parman);\n\tif (err)\n\t\tgoto out;\n\n\terr = test_parman_check_array(test_parman, false);\n\tif (err)\n\t\tgoto out;\nout:\n\ttest_parman_destroy(test_parman);\n\treturn err;\n}\n\nstatic int __init test_parman_init(void)\n{\n\treturn test_parman_lsort();\n}\n\nstatic void __exit test_parman_exit(void)\n{\n}\n\nmodule_init(test_parman_init);\nmodule_exit(test_parman_exit);\n\nMODULE_LICENSE(\"Dual BSD/GPL\");\nMODULE_AUTHOR(\"Jiri Pirko <jiri@mellanox.com>\");\nMODULE_DESCRIPTION(\"Test module for parman\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}