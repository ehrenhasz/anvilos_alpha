{
  "module_name": "devres.c",
  "hash_id": "fff54bc410082a4e4a48b9fda9762b622d330a10969ca2a2e38b4b670e9790f4",
  "original_prompt": "Ingested from linux-6.6.14/lib/devres.c",
  "human_readable_source": "\n#include <linux/err.h>\n#include <linux/pci.h>\n#include <linux/io.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/of_address.h>\n\nenum devm_ioremap_type {\n\tDEVM_IOREMAP = 0,\n\tDEVM_IOREMAP_UC,\n\tDEVM_IOREMAP_WC,\n\tDEVM_IOREMAP_NP,\n};\n\nvoid devm_ioremap_release(struct device *dev, void *res)\n{\n\tiounmap(*(void __iomem **)res);\n}\n\nstatic int devm_ioremap_match(struct device *dev, void *res, void *match_data)\n{\n\treturn *(void **)res == match_data;\n}\n\nstatic void __iomem *__devm_ioremap(struct device *dev, resource_size_t offset,\n\t\t\t\t    resource_size_t size,\n\t\t\t\t    enum devm_ioremap_type type)\n{\n\tvoid __iomem **ptr, *addr = NULL;\n\n\tptr = devres_alloc_node(devm_ioremap_release, sizeof(*ptr), GFP_KERNEL,\n\t\t\t\tdev_to_node(dev));\n\tif (!ptr)\n\t\treturn NULL;\n\n\tswitch (type) {\n\tcase DEVM_IOREMAP:\n\t\taddr = ioremap(offset, size);\n\t\tbreak;\n\tcase DEVM_IOREMAP_UC:\n\t\taddr = ioremap_uc(offset, size);\n\t\tbreak;\n\tcase DEVM_IOREMAP_WC:\n\t\taddr = ioremap_wc(offset, size);\n\t\tbreak;\n\tcase DEVM_IOREMAP_NP:\n\t\taddr = ioremap_np(offset, size);\n\t\tbreak;\n\t}\n\n\tif (addr) {\n\t\t*ptr = addr;\n\t\tdevres_add(dev, ptr);\n\t} else\n\t\tdevres_free(ptr);\n\n\treturn addr;\n}\n\n \nvoid __iomem *devm_ioremap(struct device *dev, resource_size_t offset,\n\t\t\t   resource_size_t size)\n{\n\treturn __devm_ioremap(dev, offset, size, DEVM_IOREMAP);\n}\nEXPORT_SYMBOL(devm_ioremap);\n\n \nvoid __iomem *devm_ioremap_uc(struct device *dev, resource_size_t offset,\n\t\t\t      resource_size_t size)\n{\n\treturn __devm_ioremap(dev, offset, size, DEVM_IOREMAP_UC);\n}\nEXPORT_SYMBOL_GPL(devm_ioremap_uc);\n\n \nvoid __iomem *devm_ioremap_wc(struct device *dev, resource_size_t offset,\n\t\t\t      resource_size_t size)\n{\n\treturn __devm_ioremap(dev, offset, size, DEVM_IOREMAP_WC);\n}\nEXPORT_SYMBOL(devm_ioremap_wc);\n\n \nvoid devm_iounmap(struct device *dev, void __iomem *addr)\n{\n\tWARN_ON(devres_destroy(dev, devm_ioremap_release, devm_ioremap_match,\n\t\t\t       (__force void *)addr));\n\tiounmap(addr);\n}\nEXPORT_SYMBOL(devm_iounmap);\n\nstatic void __iomem *\n__devm_ioremap_resource(struct device *dev, const struct resource *res,\n\t\t\tenum devm_ioremap_type type)\n{\n\tresource_size_t size;\n\tvoid __iomem *dest_ptr;\n\tchar *pretty_name;\n\n\tBUG_ON(!dev);\n\n\tif (!res || resource_type(res) != IORESOURCE_MEM) {\n\t\tdev_err(dev, \"invalid resource %pR\\n\", res);\n\t\treturn IOMEM_ERR_PTR(-EINVAL);\n\t}\n\n\tif (type == DEVM_IOREMAP && res->flags & IORESOURCE_MEM_NONPOSTED)\n\t\ttype = DEVM_IOREMAP_NP;\n\n\tsize = resource_size(res);\n\n\tif (res->name)\n\t\tpretty_name = devm_kasprintf(dev, GFP_KERNEL, \"%s %s\",\n\t\t\t\t\t     dev_name(dev), res->name);\n\telse\n\t\tpretty_name = devm_kstrdup(dev, dev_name(dev), GFP_KERNEL);\n\tif (!pretty_name) {\n\t\tdev_err(dev, \"can't generate pretty name for resource %pR\\n\", res);\n\t\treturn IOMEM_ERR_PTR(-ENOMEM);\n\t}\n\n\tif (!devm_request_mem_region(dev, res->start, size, pretty_name)) {\n\t\tdev_err(dev, \"can't request region for resource %pR\\n\", res);\n\t\treturn IOMEM_ERR_PTR(-EBUSY);\n\t}\n\n\tdest_ptr = __devm_ioremap(dev, res->start, size, type);\n\tif (!dest_ptr) {\n\t\tdev_err(dev, \"ioremap failed for resource %pR\\n\", res);\n\t\tdevm_release_mem_region(dev, res->start, size);\n\t\tdest_ptr = IOMEM_ERR_PTR(-ENOMEM);\n\t}\n\n\treturn dest_ptr;\n}\n\n \nvoid __iomem *devm_ioremap_resource(struct device *dev,\n\t\t\t\t    const struct resource *res)\n{\n\treturn __devm_ioremap_resource(dev, res, DEVM_IOREMAP);\n}\nEXPORT_SYMBOL(devm_ioremap_resource);\n\n \nvoid __iomem *devm_ioremap_resource_wc(struct device *dev,\n\t\t\t\t       const struct resource *res)\n{\n\treturn __devm_ioremap_resource(dev, res, DEVM_IOREMAP_WC);\n}\n\n \nvoid __iomem *devm_of_iomap(struct device *dev, struct device_node *node, int index,\n\t\t\t    resource_size_t *size)\n{\n\tstruct resource res;\n\n\tif (of_address_to_resource(node, index, &res))\n\t\treturn IOMEM_ERR_PTR(-EINVAL);\n\tif (size)\n\t\t*size = resource_size(&res);\n\treturn devm_ioremap_resource(dev, &res);\n}\nEXPORT_SYMBOL(devm_of_iomap);\n\n#ifdef CONFIG_HAS_IOPORT_MAP\n \nstatic void devm_ioport_map_release(struct device *dev, void *res)\n{\n\tioport_unmap(*(void __iomem **)res);\n}\n\nstatic int devm_ioport_map_match(struct device *dev, void *res,\n\t\t\t\t void *match_data)\n{\n\treturn *(void **)res == match_data;\n}\n\n \nvoid __iomem *devm_ioport_map(struct device *dev, unsigned long port,\n\t\t\t       unsigned int nr)\n{\n\tvoid __iomem **ptr, *addr;\n\n\tptr = devres_alloc_node(devm_ioport_map_release, sizeof(*ptr), GFP_KERNEL,\n\t\t\t\tdev_to_node(dev));\n\tif (!ptr)\n\t\treturn NULL;\n\n\taddr = ioport_map(port, nr);\n\tif (addr) {\n\t\t*ptr = addr;\n\t\tdevres_add(dev, ptr);\n\t} else\n\t\tdevres_free(ptr);\n\n\treturn addr;\n}\nEXPORT_SYMBOL(devm_ioport_map);\n\n \nvoid devm_ioport_unmap(struct device *dev, void __iomem *addr)\n{\n\tioport_unmap(addr);\n\tWARN_ON(devres_destroy(dev, devm_ioport_map_release,\n\t\t\t       devm_ioport_map_match, (__force void *)addr));\n}\nEXPORT_SYMBOL(devm_ioport_unmap);\n#endif  \n\n#ifdef CONFIG_PCI\n \n#define PCIM_IOMAP_MAX\tPCI_STD_NUM_BARS\n\nstruct pcim_iomap_devres {\n\tvoid __iomem *table[PCIM_IOMAP_MAX];\n};\n\nstatic void pcim_iomap_release(struct device *gendev, void *res)\n{\n\tstruct pci_dev *dev = to_pci_dev(gendev);\n\tstruct pcim_iomap_devres *this = res;\n\tint i;\n\n\tfor (i = 0; i < PCIM_IOMAP_MAX; i++)\n\t\tif (this->table[i])\n\t\t\tpci_iounmap(dev, this->table[i]);\n}\n\n \nvoid __iomem * const *pcim_iomap_table(struct pci_dev *pdev)\n{\n\tstruct pcim_iomap_devres *dr, *new_dr;\n\n\tdr = devres_find(&pdev->dev, pcim_iomap_release, NULL, NULL);\n\tif (dr)\n\t\treturn dr->table;\n\n\tnew_dr = devres_alloc_node(pcim_iomap_release, sizeof(*new_dr), GFP_KERNEL,\n\t\t\t\t   dev_to_node(&pdev->dev));\n\tif (!new_dr)\n\t\treturn NULL;\n\tdr = devres_get(&pdev->dev, new_dr, NULL, NULL);\n\treturn dr->table;\n}\nEXPORT_SYMBOL(pcim_iomap_table);\n\n \nvoid __iomem *pcim_iomap(struct pci_dev *pdev, int bar, unsigned long maxlen)\n{\n\tvoid __iomem **tbl;\n\n\tBUG_ON(bar >= PCIM_IOMAP_MAX);\n\n\ttbl = (void __iomem **)pcim_iomap_table(pdev);\n\tif (!tbl || tbl[bar])\t \n\t\treturn NULL;\n\n\ttbl[bar] = pci_iomap(pdev, bar, maxlen);\n\treturn tbl[bar];\n}\nEXPORT_SYMBOL(pcim_iomap);\n\n \nvoid pcim_iounmap(struct pci_dev *pdev, void __iomem *addr)\n{\n\tvoid __iomem **tbl;\n\tint i;\n\n\tpci_iounmap(pdev, addr);\n\n\ttbl = (void __iomem **)pcim_iomap_table(pdev);\n\tBUG_ON(!tbl);\n\n\tfor (i = 0; i < PCIM_IOMAP_MAX; i++)\n\t\tif (tbl[i] == addr) {\n\t\t\ttbl[i] = NULL;\n\t\t\treturn;\n\t\t}\n\tWARN_ON(1);\n}\nEXPORT_SYMBOL(pcim_iounmap);\n\n \nint pcim_iomap_regions(struct pci_dev *pdev, int mask, const char *name)\n{\n\tvoid __iomem * const *iomap;\n\tint i, rc;\n\n\tiomap = pcim_iomap_table(pdev);\n\tif (!iomap)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < DEVICE_COUNT_RESOURCE; i++) {\n\t\tunsigned long len;\n\n\t\tif (!(mask & (1 << i)))\n\t\t\tcontinue;\n\n\t\trc = -EINVAL;\n\t\tlen = pci_resource_len(pdev, i);\n\t\tif (!len)\n\t\t\tgoto err_inval;\n\n\t\trc = pci_request_region(pdev, i, name);\n\t\tif (rc)\n\t\t\tgoto err_inval;\n\n\t\trc = -ENOMEM;\n\t\tif (!pcim_iomap(pdev, i, 0))\n\t\t\tgoto err_region;\n\t}\n\n\treturn 0;\n\n err_region:\n\tpci_release_region(pdev, i);\n err_inval:\n\twhile (--i >= 0) {\n\t\tif (!(mask & (1 << i)))\n\t\t\tcontinue;\n\t\tpcim_iounmap(pdev, iomap[i]);\n\t\tpci_release_region(pdev, i);\n\t}\n\n\treturn rc;\n}\nEXPORT_SYMBOL(pcim_iomap_regions);\n\n \nint pcim_iomap_regions_request_all(struct pci_dev *pdev, int mask,\n\t\t\t\t   const char *name)\n{\n\tint request_mask = ((1 << 6) - 1) & ~mask;\n\tint rc;\n\n\trc = pci_request_selected_regions(pdev, request_mask, name);\n\tif (rc)\n\t\treturn rc;\n\n\trc = pcim_iomap_regions(pdev, mask, name);\n\tif (rc)\n\t\tpci_release_selected_regions(pdev, request_mask);\n\treturn rc;\n}\nEXPORT_SYMBOL(pcim_iomap_regions_request_all);\n\n \nvoid pcim_iounmap_regions(struct pci_dev *pdev, int mask)\n{\n\tvoid __iomem * const *iomap;\n\tint i;\n\n\tiomap = pcim_iomap_table(pdev);\n\tif (!iomap)\n\t\treturn;\n\n\tfor (i = 0; i < PCIM_IOMAP_MAX; i++) {\n\t\tif (!(mask & (1 << i)))\n\t\t\tcontinue;\n\n\t\tpcim_iounmap(pdev, iomap[i]);\n\t\tpci_release_region(pdev, i);\n\t}\n}\nEXPORT_SYMBOL(pcim_iounmap_regions);\n#endif  \n\nstatic void devm_arch_phys_ac_add_release(struct device *dev, void *res)\n{\n\tarch_phys_wc_del(*((int *)res));\n}\n\n \nint devm_arch_phys_wc_add(struct device *dev, unsigned long base, unsigned long size)\n{\n\tint *mtrr;\n\tint ret;\n\n\tmtrr = devres_alloc_node(devm_arch_phys_ac_add_release, sizeof(*mtrr), GFP_KERNEL,\n\t\t\t\t dev_to_node(dev));\n\tif (!mtrr)\n\t\treturn -ENOMEM;\n\n\tret = arch_phys_wc_add(base, size);\n\tif (ret < 0) {\n\t\tdevres_free(mtrr);\n\t\treturn ret;\n\t}\n\n\t*mtrr = ret;\n\tdevres_add(dev, mtrr);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(devm_arch_phys_wc_add);\n\nstruct arch_io_reserve_memtype_wc_devres {\n\tresource_size_t start;\n\tresource_size_t size;\n};\n\nstatic void devm_arch_io_free_memtype_wc_release(struct device *dev, void *res)\n{\n\tconst struct arch_io_reserve_memtype_wc_devres *this = res;\n\n\tarch_io_free_memtype_wc(this->start, this->size);\n}\n\n \nint devm_arch_io_reserve_memtype_wc(struct device *dev, resource_size_t start,\n\t\t\t\t    resource_size_t size)\n{\n\tstruct arch_io_reserve_memtype_wc_devres *dr;\n\tint ret;\n\n\tdr = devres_alloc_node(devm_arch_io_free_memtype_wc_release, sizeof(*dr), GFP_KERNEL,\n\t\t\t       dev_to_node(dev));\n\tif (!dr)\n\t\treturn -ENOMEM;\n\n\tret = arch_io_reserve_memtype_wc(start, size);\n\tif (ret < 0) {\n\t\tdevres_free(dr);\n\t\treturn ret;\n\t}\n\n\tdr->start = start;\n\tdr->size = size;\n\tdevres_add(dev, dr);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(devm_arch_io_reserve_memtype_wc);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}