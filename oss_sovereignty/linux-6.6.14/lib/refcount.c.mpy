{
  "module_name": "refcount.c",
  "hash_id": "cf32b43e203ad859c0fece6318fab4b15ba4ec225a9d67d556b54b9908888284",
  "original_prompt": "Ingested from linux-6.6.14/lib/refcount.c",
  "human_readable_source": "\n \n\n#include <linux/mutex.h>\n#include <linux/refcount.h>\n#include <linux/spinlock.h>\n#include <linux/bug.h>\n\n#define REFCOUNT_WARN(str)\tWARN_ONCE(1, \"refcount_t: \" str \".\\n\")\n\nvoid refcount_warn_saturate(refcount_t *r, enum refcount_saturation_type t)\n{\n\trefcount_set(r, REFCOUNT_SATURATED);\n\n\tswitch (t) {\n\tcase REFCOUNT_ADD_NOT_ZERO_OVF:\n\t\tREFCOUNT_WARN(\"saturated; leaking memory\");\n\t\tbreak;\n\tcase REFCOUNT_ADD_OVF:\n\t\tREFCOUNT_WARN(\"saturated; leaking memory\");\n\t\tbreak;\n\tcase REFCOUNT_ADD_UAF:\n\t\tREFCOUNT_WARN(\"addition on 0; use-after-free\");\n\t\tbreak;\n\tcase REFCOUNT_SUB_UAF:\n\t\tREFCOUNT_WARN(\"underflow; use-after-free\");\n\t\tbreak;\n\tcase REFCOUNT_DEC_LEAK:\n\t\tREFCOUNT_WARN(\"decrement hit 0; leaking memory\");\n\t\tbreak;\n\tdefault:\n\t\tREFCOUNT_WARN(\"unknown saturation event!?\");\n\t}\n}\nEXPORT_SYMBOL(refcount_warn_saturate);\n\n \nbool refcount_dec_if_one(refcount_t *r)\n{\n\tint val = 1;\n\n\treturn atomic_try_cmpxchg_release(&r->refs, &val, 0);\n}\nEXPORT_SYMBOL(refcount_dec_if_one);\n\n \nbool refcount_dec_not_one(refcount_t *r)\n{\n\tunsigned int new, val = atomic_read(&r->refs);\n\n\tdo {\n\t\tif (unlikely(val == REFCOUNT_SATURATED))\n\t\t\treturn true;\n\n\t\tif (val == 1)\n\t\t\treturn false;\n\n\t\tnew = val - 1;\n\t\tif (new > val) {\n\t\t\tWARN_ONCE(new > val, \"refcount_t: underflow; use-after-free.\\n\");\n\t\t\treturn true;\n\t\t}\n\n\t} while (!atomic_try_cmpxchg_release(&r->refs, &val, new));\n\n\treturn true;\n}\nEXPORT_SYMBOL(refcount_dec_not_one);\n\n \nbool refcount_dec_and_mutex_lock(refcount_t *r, struct mutex *lock)\n{\n\tif (refcount_dec_not_one(r))\n\t\treturn false;\n\n\tmutex_lock(lock);\n\tif (!refcount_dec_and_test(r)) {\n\t\tmutex_unlock(lock);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\nEXPORT_SYMBOL(refcount_dec_and_mutex_lock);\n\n \nbool refcount_dec_and_lock(refcount_t *r, spinlock_t *lock)\n{\n\tif (refcount_dec_not_one(r))\n\t\treturn false;\n\n\tspin_lock(lock);\n\tif (!refcount_dec_and_test(r)) {\n\t\tspin_unlock(lock);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\nEXPORT_SYMBOL(refcount_dec_and_lock);\n\n \nbool refcount_dec_and_lock_irqsave(refcount_t *r, spinlock_t *lock,\n\t\t\t\t   unsigned long *flags)\n{\n\tif (refcount_dec_not_one(r))\n\t\treturn false;\n\n\tspin_lock_irqsave(lock, *flags);\n\tif (!refcount_dec_and_test(r)) {\n\t\tspin_unlock_irqrestore(lock, *flags);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\nEXPORT_SYMBOL(refcount_dec_and_lock_irqsave);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}