{
  "module_name": "cmdline.c",
  "hash_id": "a95f28298cc4836ed58d4098de8051804f11f3678fd0cbca5d313ea3b8ec2adf",
  "original_prompt": "Ingested from linux-6.6.14/lib/cmdline.c",
  "human_readable_source": "\n \n\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n\n \n\nstatic int get_range(char **str, int *pint, int n)\n{\n\tint x, inc_counter, upper_range;\n\n\t(*str)++;\n\tupper_range = simple_strtol((*str), NULL, 0);\n\tinc_counter = upper_range - *pint;\n\tfor (x = *pint; n && x < upper_range; x++, n--)\n\t\t*pint++ = x;\n\treturn inc_counter;\n}\n\n \n\nint get_option(char **str, int *pint)\n{\n\tchar *cur = *str;\n\tint value;\n\n\tif (!cur || !(*cur))\n\t\treturn 0;\n\tif (*cur == '-')\n\t\tvalue = -simple_strtoull(++cur, str, 0);\n\telse\n\t\tvalue = simple_strtoull(cur, str, 0);\n\tif (pint)\n\t\t*pint = value;\n\tif (cur == *str)\n\t\treturn 0;\n\tif (**str == ',') {\n\t\t(*str)++;\n\t\treturn 2;\n\t}\n\tif (**str == '-')\n\t\treturn 3;\n\n\treturn 1;\n}\nEXPORT_SYMBOL(get_option);\n\n \n\nchar *get_options(const char *str, int nints, int *ints)\n{\n\tbool validate = (nints == 0);\n\tint res, i = 1;\n\n\twhile (i < nints || validate) {\n\t\tint *pint = validate ? ints : ints + i;\n\n\t\tres = get_option((char **)&str, pint);\n\t\tif (res == 0)\n\t\t\tbreak;\n\t\tif (res == 3) {\n\t\t\tint n = validate ? 0 : nints - i;\n\t\t\tint range_nums;\n\n\t\t\trange_nums = get_range((char **)&str, pint, n);\n\t\t\tif (range_nums < 0)\n\t\t\t\tbreak;\n\t\t\t \n\t\t\ti += (range_nums - 1);\n\t\t}\n\t\ti++;\n\t\tif (res == 1)\n\t\t\tbreak;\n\t}\n\tints[0] = i - 1;\n\treturn (char *)str;\n}\nEXPORT_SYMBOL(get_options);\n\n \n\nunsigned long long memparse(const char *ptr, char **retptr)\n{\n\tchar *endptr;\t \n\n\tunsigned long long ret = simple_strtoull(ptr, &endptr, 0);\n\n\tswitch (*endptr) {\n\tcase 'E':\n\tcase 'e':\n\t\tret <<= 10;\n\t\tfallthrough;\n\tcase 'P':\n\tcase 'p':\n\t\tret <<= 10;\n\t\tfallthrough;\n\tcase 'T':\n\tcase 't':\n\t\tret <<= 10;\n\t\tfallthrough;\n\tcase 'G':\n\tcase 'g':\n\t\tret <<= 10;\n\t\tfallthrough;\n\tcase 'M':\n\tcase 'm':\n\t\tret <<= 10;\n\t\tfallthrough;\n\tcase 'K':\n\tcase 'k':\n\t\tret <<= 10;\n\t\tendptr++;\n\t\tfallthrough;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (retptr)\n\t\t*retptr = endptr;\n\n\treturn ret;\n}\nEXPORT_SYMBOL(memparse);\n\n \nbool parse_option_str(const char *str, const char *option)\n{\n\twhile (*str) {\n\t\tif (!strncmp(str, option, strlen(option))) {\n\t\t\tstr += strlen(option);\n\t\t\tif (!*str || *str == ',')\n\t\t\t\treturn true;\n\t\t}\n\n\t\twhile (*str && *str != ',')\n\t\t\tstr++;\n\n\t\tif (*str == ',')\n\t\t\tstr++;\n\t}\n\n\treturn false;\n}\n\n \nchar *next_arg(char *args, char **param, char **val)\n{\n\tunsigned int i, equals = 0;\n\tint in_quote = 0, quoted = 0;\n\n\tif (*args == '\"') {\n\t\targs++;\n\t\tin_quote = 1;\n\t\tquoted = 1;\n\t}\n\n\tfor (i = 0; args[i]; i++) {\n\t\tif (isspace(args[i]) && !in_quote)\n\t\t\tbreak;\n\t\tif (equals == 0) {\n\t\t\tif (args[i] == '=')\n\t\t\t\tequals = i;\n\t\t}\n\t\tif (args[i] == '\"')\n\t\t\tin_quote = !in_quote;\n\t}\n\n\t*param = args;\n\tif (!equals)\n\t\t*val = NULL;\n\telse {\n\t\targs[equals] = '\\0';\n\t\t*val = args + equals + 1;\n\n\t\t \n\t\tif (**val == '\"') {\n\t\t\t(*val)++;\n\t\t\tif (args[i-1] == '\"')\n\t\t\t\targs[i-1] = '\\0';\n\t\t}\n\t}\n\tif (quoted && i > 0 && args[i-1] == '\"')\n\t\targs[i-1] = '\\0';\n\n\tif (args[i]) {\n\t\targs[i] = '\\0';\n\t\targs += i + 1;\n\t} else\n\t\targs += i;\n\n\t \n\treturn skip_spaces(args);\n}\nEXPORT_SYMBOL(next_arg);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}