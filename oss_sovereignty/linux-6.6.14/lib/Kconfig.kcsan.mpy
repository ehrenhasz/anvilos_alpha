{
  "module_name": "Kconfig.kcsan",
  "hash_id": "7ce61e5ce4f44b70cf29c3d56c82466e16c1aff91fc7e37c2f4eacad7500f9ca",
  "original_prompt": "Ingested from linux-6.6.14/lib/Kconfig.kcsan",
  "human_readable_source": "# SPDX-License-Identifier: GPL-2.0-only\n\nconfig HAVE_ARCH_KCSAN\n\tbool\n\nconfig HAVE_KCSAN_COMPILER\n\tdef_bool (CC_IS_CLANG && $(cc-option,-fsanitize=thread -mllvm -tsan-distinguish-volatile=1)) || \\\n\t\t (CC_IS_GCC && $(cc-option,-fsanitize=thread --param tsan-distinguish-volatile=1))\n\thelp\n\t  For the list of compilers that support KCSAN, please see\n\t  <file:Documentation/dev-tools/kcsan.rst>.\n\nmenuconfig KCSAN\n\tbool \"KCSAN: dynamic data race detector\"\n\tdepends on HAVE_ARCH_KCSAN && HAVE_KCSAN_COMPILER\n\tdepends on DEBUG_KERNEL && !KASAN\n\tselect CONSTRUCTORS\n\tselect STACKTRACE\n\thelp\n\t  The Kernel Concurrency Sanitizer (KCSAN) is a dynamic\n\t  data-race detector that relies on compile-time instrumentation.\n\t  KCSAN uses a watchpoint-based sampling approach to detect races.\n\n\t  While KCSAN's primary purpose is to detect data races, it\n\t  also provides assertions to check data access constraints.\n\t  These assertions can expose bugs that do not manifest as\n\t  data races.\n\n\t  See <file:Documentation/dev-tools/kcsan.rst> for more details.\n\nif KCSAN\n\nconfig CC_HAS_TSAN_COMPOUND_READ_BEFORE_WRITE\n\tdef_bool (CC_IS_CLANG && $(cc-option,-fsanitize=thread -mllvm -tsan-compound-read-before-write=1)) || \\\n\t\t (CC_IS_GCC && $(cc-option,-fsanitize=thread --param tsan-compound-read-before-write=1))\n\thelp\n\t  The compiler instruments plain compound read-write operations\n\t  differently (++, --, +=, -=, |=, &=, etc.), which allows KCSAN to\n\t  distinguish them from other plain accesses. This is currently\n\t  supported by Clang 12 or later.\n\nconfig KCSAN_VERBOSE\n\tbool \"Show verbose reports with more information about system state\"\n\tdepends on PROVE_LOCKING\n\thelp\n\t  If enabled, reports show more information about the system state that\n\t  may help better analyze and debug races. This includes held locks and\n\t  IRQ trace events.\n\n\t  While this option should generally be benign, we call into more\n\t  external functions on report generation; if a race report is\n\t  generated from any one of them, system stability may suffer due to\n\t  deadlocks or recursion.  If in doubt, say N.\n\nconfig KCSAN_SELFTEST\n\tbool \"Perform short selftests on boot\"\n\tdefault y\n\thelp\n\t  Run KCSAN selftests on boot. On test failure, causes the kernel to\n\t  panic. Recommended to be enabled, ensuring critical functionality\n\t  works as intended.\n\nconfig KCSAN_KUNIT_TEST\n\ttristate \"KCSAN test for integrated runtime behaviour\" if !KUNIT_ALL_TESTS\n\tdefault KUNIT_ALL_TESTS\n\tdepends on TRACEPOINTS && KUNIT\n\tselect TORTURE_TEST\n\thelp\n\t  KCSAN test focusing on behaviour of the integrated runtime. Tests\n\t  various race scenarios, and verifies the reports generated to\n\t  console. Makes use of KUnit for test organization, and the Torture\n\t  framework for test thread control.\n\n\t  Each test case may run at least up to KCSAN_REPORT_ONCE_IN_MS\n\t  milliseconds. Test run duration may be optimized by building the\n\t  kernel and KCSAN test with KCSAN_REPORT_ONCE_IN_MS set to a lower\n\t  than default value.\n\n\t  Say Y here if you want the test to be built into the kernel and run\n\t  during boot; say M if you want the test to build as a module; say N\n\t  if you are unsure.\n\nconfig KCSAN_EARLY_ENABLE\n\tbool \"Early enable during boot\"\n\tdefault y\n\thelp\n\t  If KCSAN should be enabled globally as soon as possible. KCSAN can\n\t  later be enabled/disabled via debugfs.\n\nconfig KCSAN_NUM_WATCHPOINTS\n\tint \"Number of available watchpoints\"\n\tdefault 64\n\thelp\n\t  Total number of available watchpoints. An address range maps into a\n\t  specific watchpoint slot as specified in kernel/kcsan/encoding.h.\n\t  Although larger number of watchpoints may not be usable due to\n\t  limited number of CPUs, a larger value helps to improve performance\n\t  due to reducing cache-line contention. The chosen default is a\n\t  conservative value; we should almost never observe \"no_capacity\"\n\t  events (see /sys/kernel/debug/kcsan).\n\nconfig KCSAN_UDELAY_TASK\n\tint \"Delay in microseconds (for tasks)\"\n\tdefault 80\n\thelp\n\t  For tasks, the microsecond delay after setting up a watchpoint.\n\nconfig KCSAN_UDELAY_INTERRUPT\n\tint \"Delay in microseconds (for interrupts)\"\n\tdefault 20\n\thelp\n\t  For interrupts, the microsecond delay after setting up a watchpoint.\n\t  Interrupts have tighter latency requirements, and their delay should\n\t  be lower than for tasks.\n\nconfig KCSAN_DELAY_RANDOMIZE\n\tbool \"Randomize above delays\"\n\tdefault y\n\thelp\n\t  If delays should be randomized, where the maximum is KCSAN_UDELAY_*.\n\t  If false, the chosen delays are always the KCSAN_UDELAY_* values\n\t  as defined above.\n\nconfig KCSAN_SKIP_WATCH\n\tint \"Skip instructions before setting up watchpoint\"\n\tdefault 4000\n\thelp\n\t  The number of per-CPU memory operations to skip, before another\n\t  watchpoint is set up, i.e. one in KCSAN_SKIP_WATCH per-CPU\n\t  memory operations are used to set up a watchpoint. A smaller value\n\t  results in more aggressive race detection, whereas a larger value\n\t  improves system performance at the cost of missing some races.\n\nconfig KCSAN_SKIP_WATCH_RANDOMIZE\n\tbool \"Randomize watchpoint instruction skip count\"\n\tdefault y\n\thelp\n\t  If instruction skip count should be randomized, where the maximum is\n\t  KCSAN_SKIP_WATCH. If false, the chosen value is always\n\t  KCSAN_SKIP_WATCH.\n\nconfig KCSAN_INTERRUPT_WATCHER\n\tbool \"Interruptible watchers\" if !KCSAN_STRICT\n\tdefault KCSAN_STRICT\n\thelp\n\t  If enabled, a task that set up a watchpoint may be interrupted while\n\t  delayed. This option will allow KCSAN to detect races between\n\t  interrupted tasks and other threads of execution on the same CPU.\n\n\t  Currently disabled by default, because not all safe per-CPU access\n\t  primitives and patterns may be accounted for, and therefore could\n\t  result in false positives.\n\nconfig KCSAN_REPORT_ONCE_IN_MS\n\tint \"Duration in milliseconds, in which any given race is only reported once\"\n\tdefault 3000\n\thelp\n\t  Any given race is only reported once in the defined time window.\n\t  Different races may still generate reports within a duration that is\n\t  smaller than the duration defined here. This allows rate limiting\n\t  reporting to avoid flooding the console with reports.  Setting this\n\t  to 0 disables rate limiting.\n\n# The main purpose of the below options is to control reported data races, and\n# are not expected to be switched frequently by non-testers or at runtime.\n# The defaults are chosen to be conservative, and can miss certain bugs.\n\nconfig KCSAN_REPORT_RACE_UNKNOWN_ORIGIN\n\tbool \"Report races of unknown origin\"\n\tdefault y\n\thelp\n\t  If KCSAN should report races where only one access is known, and the\n\t  conflicting access is of unknown origin. This type of race is\n\t  reported if it was only possible to infer a race due to a data value\n\t  change while an access is being delayed on a watchpoint.\n\nconfig KCSAN_STRICT\n\tbool \"Strict data-race checking\"\n\thelp\n\t  KCSAN will report data races with the strictest possible rules, which\n\t  closely aligns with the rules defined by the Linux-kernel memory\n\t  consistency model (LKMM).\n\nconfig KCSAN_WEAK_MEMORY\n\tbool \"Enable weak memory modeling to detect missing memory barriers\"\n\tdefault y\n\tdepends on KCSAN_STRICT\n\t# We can either let objtool nop __tsan_func_{entry,exit}() and builtin\n\t# atomics instrumentation in .noinstr.text, or use a compiler that can\n\t# implement __no_kcsan to really remove all instrumentation.\n\tdepends on !ARCH_WANTS_NO_INSTR || HAVE_NOINSTR_HACK || \\\n\t\t   CC_IS_GCC || CLANG_VERSION >= 140000\n\tselect OBJTOOL if HAVE_NOINSTR_HACK\n\thelp\n\t  Enable support for modeling a subset of weak memory, which allows\n\t  detecting a subset of data races due to missing memory barriers.\n\n\t  Depends on KCSAN_STRICT, because the options strengthening certain\n\t  plain accesses by default (depending on !KCSAN_STRICT) reduce the\n\t  ability to detect any data races invoving reordered accesses, in\n\t  particular reordered writes.\n\n\t  Weak memory modeling relies on additional instrumentation and may\n\t  affect performance.\n\nconfig KCSAN_REPORT_VALUE_CHANGE_ONLY\n\tbool \"Only report races where watcher observed a data value change\"\n\tdefault y\n\tdepends on !KCSAN_STRICT\n\thelp\n\t  If enabled and a conflicting write is observed via a watchpoint, but\n\t  the data value of the memory location was observed to remain\n\t  unchanged, do not report the data race.\n\nconfig KCSAN_ASSUME_PLAIN_WRITES_ATOMIC\n\tbool \"Assume that plain aligned writes up to word size are atomic\"\n\tdefault y\n\tdepends on !KCSAN_STRICT\n\thelp\n\t  Assume that plain aligned writes up to word size are atomic by\n\t  default, and also not subject to other unsafe compiler optimizations\n\t  resulting in data races. This will cause KCSAN to not report data\n\t  races due to conflicts where the only plain accesses are aligned\n\t  writes up to word size: conflicts between marked reads and plain\n\t  aligned writes up to word size will not be reported as data races;\n\t  notice that data races between two conflicting plain aligned writes\n\t  will also not be reported.\n\nconfig KCSAN_IGNORE_ATOMICS\n\tbool \"Do not instrument marked atomic accesses\"\n\tdepends on !KCSAN_STRICT\n\thelp\n\t  Never instrument marked atomic accesses. This option can be used for\n\t  additional filtering. Conflicting marked atomic reads and plain\n\t  writes will never be reported as a data race, however, will cause\n\t  plain reads and marked writes to result in \"unknown origin\" reports.\n\t  If combined with CONFIG_KCSAN_REPORT_RACE_UNKNOWN_ORIGIN=n, data\n\t  races where at least one access is marked atomic will never be\n\t  reported.\n\n\t  Similar to KCSAN_ASSUME_PLAIN_WRITES_ATOMIC, but including unaligned\n\t  accesses, conflicting marked atomic reads and plain writes will not\n\t  be reported as data races; however, unlike that option, data races\n\t  due to two conflicting plain writes will be reported (aligned and\n\t  unaligned, if CONFIG_KCSAN_ASSUME_PLAIN_WRITES_ATOMIC=n).\n\nconfig KCSAN_PERMISSIVE\n\tbool \"Enable all additional permissive rules\"\n\tdepends on KCSAN_REPORT_VALUE_CHANGE_ONLY\n\thelp\n\t  Enable additional permissive rules to ignore certain classes of data\n\t  races (also see kernel/kcsan/permissive.h). None of the permissive\n\t  rules imply that such data races are generally safe, but can be used\n\t  to further reduce reported data races due to data-racy patterns\n\t  common across the kernel.\n\nendif # KCSAN\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}