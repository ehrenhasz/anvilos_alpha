{
  "module_name": "test_hexdump.c",
  "hash_id": "e4df22f77284bf6f0001b4e2720c8435e84de0e5cd088ae959b2bb0f3b461563",
  "original_prompt": "Ingested from linux-6.6.14/lib/test_hexdump.c",
  "human_readable_source": " \n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/random.h>\n#include <linux/string.h>\n\nstatic const unsigned char data_b[] = {\n\t'\\xbe', '\\x32', '\\xdb', '\\x7b', '\\x0a', '\\x18', '\\x93', '\\xb2',\t \n\t'\\x70', '\\xba', '\\xc4', '\\x24', '\\x7d', '\\x83', '\\x34', '\\x9b',\t \n\t'\\xa6', '\\x9c', '\\x31', '\\xad', '\\x9c', '\\x0f', '\\xac', '\\xe9',\t \n\t'\\x4c', '\\xd1', '\\x19', '\\x99', '\\x43', '\\xb1', '\\xaf', '\\x0c',\t \n};\n\nstatic const unsigned char data_a[] = \".2.{....p..$}.4...1.....L...C...\";\n\nstatic const char * const test_data_1[] __initconst = {\n\t\"be\", \"32\", \"db\", \"7b\", \"0a\", \"18\", \"93\", \"b2\",\n\t\"70\", \"ba\", \"c4\", \"24\", \"7d\", \"83\", \"34\", \"9b\",\n\t\"a6\", \"9c\", \"31\", \"ad\", \"9c\", \"0f\", \"ac\", \"e9\",\n\t\"4c\", \"d1\", \"19\", \"99\", \"43\", \"b1\", \"af\", \"0c\",\n};\n\nstatic const char * const test_data_2_le[] __initconst = {\n\t\"32be\", \"7bdb\", \"180a\", \"b293\",\n\t\"ba70\", \"24c4\", \"837d\", \"9b34\",\n\t\"9ca6\", \"ad31\", \"0f9c\", \"e9ac\",\n\t\"d14c\", \"9919\", \"b143\", \"0caf\",\n};\n\nstatic const char * const test_data_2_be[] __initconst = {\n\t\"be32\", \"db7b\", \"0a18\", \"93b2\",\n\t\"70ba\", \"c424\", \"7d83\", \"349b\",\n\t\"a69c\", \"31ad\", \"9c0f\", \"ace9\",\n\t\"4cd1\", \"1999\", \"43b1\", \"af0c\",\n};\n\nstatic const char * const test_data_4_le[] __initconst = {\n\t\"7bdb32be\", \"b293180a\", \"24c4ba70\", \"9b34837d\",\n\t\"ad319ca6\", \"e9ac0f9c\", \"9919d14c\", \"0cafb143\",\n};\n\nstatic const char * const test_data_4_be[] __initconst = {\n\t\"be32db7b\", \"0a1893b2\", \"70bac424\", \"7d83349b\",\n\t\"a69c31ad\", \"9c0face9\", \"4cd11999\", \"43b1af0c\",\n};\n\nstatic const char * const test_data_8_le[] __initconst = {\n\t\"b293180a7bdb32be\", \"9b34837d24c4ba70\",\n\t\"e9ac0f9cad319ca6\", \"0cafb1439919d14c\",\n};\n\nstatic const char * const test_data_8_be[] __initconst = {\n\t\"be32db7b0a1893b2\", \"70bac4247d83349b\",\n\t\"a69c31ad9c0face9\", \"4cd1199943b1af0c\",\n};\n\n#define FILL_CHAR\t'#'\n\nstatic unsigned total_tests __initdata;\nstatic unsigned failed_tests __initdata;\n\nstatic void __init test_hexdump_prepare_test(size_t len, int rowsize,\n\t\t\t\t\t     int groupsize, char *test,\n\t\t\t\t\t     size_t testlen, bool ascii)\n{\n\tchar *p;\n\tconst char * const *result;\n\tsize_t l = len;\n\tint gs = groupsize, rs = rowsize;\n\tunsigned int i;\n\tconst bool is_be = IS_ENABLED(CONFIG_CPU_BIG_ENDIAN);\n\n\tif (rs != 16 && rs != 32)\n\t\trs = 16;\n\n\tif (l > rs)\n\t\tl = rs;\n\n\tif (!is_power_of_2(gs) || gs > 8 || (len % gs != 0))\n\t\tgs = 1;\n\n\tif (gs == 8)\n\t\tresult = is_be ? test_data_8_be : test_data_8_le;\n\telse if (gs == 4)\n\t\tresult = is_be ? test_data_4_be : test_data_4_le;\n\telse if (gs == 2)\n\t\tresult = is_be ? test_data_2_be : test_data_2_le;\n\telse\n\t\tresult = test_data_1;\n\n\t \n\tp = test;\n\tfor (i = 0; i < l / gs; i++) {\n\t\tconst char *q = *result++;\n\t\tsize_t amount = strlen(q);\n\n\t\tmemcpy(p, q, amount);\n\t\tp += amount;\n\n\t\t*p++ = ' ';\n\t}\n\tif (i)\n\t\tp--;\n\n\t \n\tif (ascii) {\n\t\tdo {\n\t\t\t*p++ = ' ';\n\t\t} while (p < test + rs * 2 + rs / gs + 1);\n\n\t\tstrncpy(p, data_a, l);\n\t\tp += l;\n\t}\n\n\t*p = '\\0';\n}\n\n#define TEST_HEXDUMP_BUF_SIZE\t\t(32 * 3 + 2 + 32 + 1)\n\nstatic void __init test_hexdump(size_t len, int rowsize, int groupsize,\n\t\t\t\tbool ascii)\n{\n\tchar test[TEST_HEXDUMP_BUF_SIZE];\n\tchar real[TEST_HEXDUMP_BUF_SIZE];\n\n\ttotal_tests++;\n\n\tmemset(real, FILL_CHAR, sizeof(real));\n\thex_dump_to_buffer(data_b, len, rowsize, groupsize, real, sizeof(real),\n\t\t\t   ascii);\n\n\tmemset(test, FILL_CHAR, sizeof(test));\n\ttest_hexdump_prepare_test(len, rowsize, groupsize, test, sizeof(test),\n\t\t\t\t  ascii);\n\n\tif (memcmp(test, real, TEST_HEXDUMP_BUF_SIZE)) {\n\t\tpr_err(\"Len: %zu row: %d group: %d\\n\", len, rowsize, groupsize);\n\t\tpr_err(\"Result: '%s'\\n\", real);\n\t\tpr_err(\"Expect: '%s'\\n\", test);\n\t\tfailed_tests++;\n\t}\n}\n\nstatic void __init test_hexdump_set(int rowsize, bool ascii)\n{\n\tsize_t d = min_t(size_t, sizeof(data_b), rowsize);\n\tsize_t len = get_random_u32_inclusive(1, d);\n\n\ttest_hexdump(len, rowsize, 4, ascii);\n\ttest_hexdump(len, rowsize, 2, ascii);\n\ttest_hexdump(len, rowsize, 8, ascii);\n\ttest_hexdump(len, rowsize, 1, ascii);\n}\n\nstatic void __init test_hexdump_overflow(size_t buflen, size_t len,\n\t\t\t\t\t int rowsize, int groupsize,\n\t\t\t\t\t bool ascii)\n{\n\tchar test[TEST_HEXDUMP_BUF_SIZE];\n\tchar buf[TEST_HEXDUMP_BUF_SIZE];\n\tint rs = rowsize, gs = groupsize;\n\tint ae, he, e, f, r;\n\tbool a;\n\n\ttotal_tests++;\n\n\tmemset(buf, FILL_CHAR, sizeof(buf));\n\n\tr = hex_dump_to_buffer(data_b, len, rs, gs, buf, buflen, ascii);\n\n\t \n\tae = rs * 2   + rs / gs   + 1   + len  ;\n\the = (gs * 2   + 1  ) * len / gs - 1  ;\n\n\tif (ascii)\n\t\te = ae;\n\telse\n\t\te = he;\n\n\tf = min_t(int, e + 1, buflen);\n\tif (buflen) {\n\t\ttest_hexdump_prepare_test(len, rs, gs, test, sizeof(test), ascii);\n\t\ttest[f - 1] = '\\0';\n\t}\n\tmemset(test + f, FILL_CHAR, sizeof(test) - f);\n\n\ta = r == e && !memcmp(test, buf, TEST_HEXDUMP_BUF_SIZE);\n\n\tbuf[sizeof(buf) - 1] = '\\0';\n\n\tif (!a) {\n\t\tpr_err(\"Len: %zu buflen: %zu strlen: %zu\\n\",\n\t\t\tlen, buflen, strnlen(buf, sizeof(buf)));\n\t\tpr_err(\"Result: %d '%s'\\n\", r, buf);\n\t\tpr_err(\"Expect: %d '%s'\\n\", e, test);\n\t\tfailed_tests++;\n\t}\n}\n\nstatic void __init test_hexdump_overflow_set(size_t buflen, bool ascii)\n{\n\tunsigned int i = 0;\n\tint rs = get_random_u32_inclusive(1, 2) * 16;\n\n\tdo {\n\t\tint gs = 1 << i;\n\t\tsize_t len = get_random_u32_below(rs) + gs;\n\n\t\ttest_hexdump_overflow(buflen, rounddown(len, gs), rs, gs, ascii);\n\t} while (i++ < 3);\n}\n\nstatic int __init test_hexdump_init(void)\n{\n\tunsigned int i;\n\tint rowsize;\n\n\trowsize = get_random_u32_inclusive(1, 2) * 16;\n\tfor (i = 0; i < 16; i++)\n\t\ttest_hexdump_set(rowsize, false);\n\n\trowsize = get_random_u32_inclusive(1, 2) * 16;\n\tfor (i = 0; i < 16; i++)\n\t\ttest_hexdump_set(rowsize, true);\n\n\tfor (i = 0; i <= TEST_HEXDUMP_BUF_SIZE; i++)\n\t\ttest_hexdump_overflow_set(i, false);\n\n\tfor (i = 0; i <= TEST_HEXDUMP_BUF_SIZE; i++)\n\t\ttest_hexdump_overflow_set(i, true);\n\n\tif (failed_tests == 0)\n\t\tpr_info(\"all %u tests passed\\n\", total_tests);\n\telse\n\t\tpr_err(\"failed %u out of %u tests\\n\", failed_tests, total_tests);\n\n\treturn failed_tests ? -EINVAL : 0;\n}\nmodule_init(test_hexdump_init);\n\nstatic void __exit test_hexdump_exit(void)\n{\n\t \n}\nmodule_exit(test_hexdump_exit);\n\nMODULE_AUTHOR(\"Andy Shevchenko <andriy.shevchenko@linux.intel.com>\");\nMODULE_LICENSE(\"Dual BSD/GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}