{
  "module_name": "test_kmod.c",
  "hash_id": "e142f2ace15f5bc9d068f5e0527ab4786c5a54c1784a41fa86c104e1afc00b1f",
  "original_prompt": "Ingested from linux-6.6.14/lib/test_kmod.c",
  "human_readable_source": "\n \n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/kmod.h>\n#include <linux/printk.h>\n#include <linux/kthread.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/miscdevice.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/device.h>\n\n#define TEST_START_NUM_THREADS\t50\n#define TEST_START_DRIVER\t\"test_module\"\n#define TEST_START_TEST_FS\t\"xfs\"\n#define TEST_START_TEST_CASE\tTEST_KMOD_DRIVER\n\n\nstatic bool force_init_test = false;\nmodule_param(force_init_test, bool_enable_only, 0644);\nMODULE_PARM_DESC(force_init_test,\n\t\t \"Force kicking a test immediately after driver loads\");\n\n \nstatic DEFINE_MUTEX(reg_dev_mutex);\nstatic LIST_HEAD(reg_test_devs);\n\n \nstatic int num_test_devs;\n\n \nenum kmod_test_case {\n\t__TEST_KMOD_INVALID = 0,\n\n\tTEST_KMOD_DRIVER,\n\tTEST_KMOD_FS_TYPE,\n\n\t__TEST_KMOD_MAX,\n};\n\nstruct test_config {\n\tchar *test_driver;\n\tchar *test_fs;\n\tunsigned int num_threads;\n\tenum kmod_test_case test_case;\n\tint test_result;\n};\n\nstruct kmod_test_device;\n\n \nstruct kmod_test_device_info {\n\tint ret_sync;\n\tstruct file_system_type *fs_sync;\n\tstruct task_struct *task_sync;\n\tunsigned int thread_idx;\n\tstruct kmod_test_device *test_dev;\n\tbool need_mod_put;\n};\n\n \nstruct kmod_test_device {\n\tint dev_idx;\n\tstruct test_config config;\n\tstruct miscdevice misc_dev;\n\tstruct device *dev;\n\tstruct mutex config_mutex;\n\tstruct mutex trigger_mutex;\n\tstruct mutex thread_mutex;\n\n\tunsigned int done;\n\n\tbool test_is_oom;\n\tstruct completion kthreads_done;\n\tstruct list_head list;\n\n\tstruct kmod_test_device_info *info;\n};\n\nstatic const char *test_case_str(enum kmod_test_case test_case)\n{\n\tswitch (test_case) {\n\tcase TEST_KMOD_DRIVER:\n\t\treturn \"TEST_KMOD_DRIVER\";\n\tcase TEST_KMOD_FS_TYPE:\n\t\treturn \"TEST_KMOD_FS_TYPE\";\n\tdefault:\n\t\treturn \"invalid\";\n\t}\n}\n\nstatic struct miscdevice *dev_to_misc_dev(struct device *dev)\n{\n\treturn dev_get_drvdata(dev);\n}\n\nstatic struct kmod_test_device *misc_dev_to_test_dev(struct miscdevice *misc_dev)\n{\n\treturn container_of(misc_dev, struct kmod_test_device, misc_dev);\n}\n\nstatic struct kmod_test_device *dev_to_test_dev(struct device *dev)\n{\n\tstruct miscdevice *misc_dev;\n\n\tmisc_dev = dev_to_misc_dev(dev);\n\n\treturn misc_dev_to_test_dev(misc_dev);\n}\n\n \nstatic void kmod_test_done_check(struct kmod_test_device *test_dev,\n\t\t\t\t unsigned int idx)\n{\n\tstruct test_config *config = &test_dev->config;\n\n\ttest_dev->done++;\n\tdev_dbg(test_dev->dev, \"Done thread count: %u\\n\", test_dev->done);\n\n\tif (test_dev->done == config->num_threads) {\n\t\tdev_info(test_dev->dev, \"Done: %u threads have all run now\\n\",\n\t\t\t test_dev->done);\n\t\tdev_info(test_dev->dev, \"Last thread to run: %u\\n\", idx);\n\t\tcomplete(&test_dev->kthreads_done);\n\t}\n}\n\nstatic void test_kmod_put_module(struct kmod_test_device_info *info)\n{\n\tstruct kmod_test_device *test_dev = info->test_dev;\n\tstruct test_config *config = &test_dev->config;\n\n\tif (!info->need_mod_put)\n\t\treturn;\n\n\tswitch (config->test_case) {\n\tcase TEST_KMOD_DRIVER:\n\t\tbreak;\n\tcase TEST_KMOD_FS_TYPE:\n\t\tif (info->fs_sync && info->fs_sync->owner)\n\t\t\tmodule_put(info->fs_sync->owner);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\tinfo->need_mod_put = true;\n}\n\nstatic int run_request(void *data)\n{\n\tstruct kmod_test_device_info *info = data;\n\tstruct kmod_test_device *test_dev = info->test_dev;\n\tstruct test_config *config = &test_dev->config;\n\n\tswitch (config->test_case) {\n\tcase TEST_KMOD_DRIVER:\n\t\tinfo->ret_sync = request_module(\"%s\", config->test_driver);\n\t\tbreak;\n\tcase TEST_KMOD_FS_TYPE:\n\t\tinfo->fs_sync = get_fs_type(config->test_fs);\n\t\tinfo->need_mod_put = true;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tBUG();\n\t\treturn -EINVAL;\n\t}\n\n\tdev_dbg(test_dev->dev, \"Ran thread %u\\n\", info->thread_idx);\n\n\ttest_kmod_put_module(info);\n\n\tmutex_lock(&test_dev->thread_mutex);\n\tinfo->task_sync = NULL;\n\tkmod_test_done_check(test_dev, info->thread_idx);\n\tmutex_unlock(&test_dev->thread_mutex);\n\n\treturn 0;\n}\n\nstatic int tally_work_test(struct kmod_test_device_info *info)\n{\n\tstruct kmod_test_device *test_dev = info->test_dev;\n\tstruct test_config *config = &test_dev->config;\n\tint err_ret = 0;\n\n\tswitch (config->test_case) {\n\tcase TEST_KMOD_DRIVER:\n\t\t \n\t\tif (info->ret_sync != 0)\n\t\t\terr_ret = info->ret_sync;\n\t\tdev_info(test_dev->dev,\n\t\t\t \"Sync thread %d return status: %d\\n\",\n\t\t\t info->thread_idx, info->ret_sync);\n\t\tbreak;\n\tcase TEST_KMOD_FS_TYPE:\n\t\t \n\t\tif (!info->fs_sync)\n\t\t\terr_ret = -EINVAL;\n\t\tdev_info(test_dev->dev, \"Sync thread %u fs: %s\\n\",\n\t\t\t info->thread_idx, info->fs_sync ? config->test_fs :\n\t\t\t \"NULL\");\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\treturn err_ret;\n}\n\n \nstatic void tally_up_work(struct kmod_test_device *test_dev)\n{\n\tstruct test_config *config = &test_dev->config;\n\tstruct kmod_test_device_info *info;\n\tunsigned int idx;\n\tint err_ret = 0;\n\tint ret = 0;\n\n\tmutex_lock(&test_dev->thread_mutex);\n\n\tdev_info(test_dev->dev, \"Results:\\n\");\n\n\tfor (idx=0; idx < config->num_threads; idx++) {\n\t\tinfo = &test_dev->info[idx];\n\t\tret = tally_work_test(info);\n\t\tif (ret)\n\t\t\terr_ret = ret;\n\t}\n\n\t \n\tconfig->test_result = err_ret;\n\n\tmutex_unlock(&test_dev->thread_mutex);\n}\n\nstatic int try_one_request(struct kmod_test_device *test_dev, unsigned int idx)\n{\n\tstruct kmod_test_device_info *info = &test_dev->info[idx];\n\tint fail_ret = -ENOMEM;\n\n\tmutex_lock(&test_dev->thread_mutex);\n\n\tinfo->thread_idx = idx;\n\tinfo->test_dev = test_dev;\n\tinfo->task_sync = kthread_run(run_request, info, \"%s-%u\",\n\t\t\t\t      KBUILD_MODNAME, idx);\n\n\tif (!info->task_sync || IS_ERR(info->task_sync)) {\n\t\ttest_dev->test_is_oom = true;\n\t\tdev_err(test_dev->dev, \"Setting up thread %u failed\\n\", idx);\n\t\tinfo->task_sync = NULL;\n\t\tgoto err_out;\n\t} else\n\t\tdev_dbg(test_dev->dev, \"Kicked off thread %u\\n\", idx);\n\n\tmutex_unlock(&test_dev->thread_mutex);\n\n\treturn 0;\n\nerr_out:\n\tinfo->ret_sync = fail_ret;\n\tmutex_unlock(&test_dev->thread_mutex);\n\n\treturn fail_ret;\n}\n\nstatic void test_dev_kmod_stop_tests(struct kmod_test_device *test_dev)\n{\n\tstruct test_config *config = &test_dev->config;\n\tstruct kmod_test_device_info *info;\n\tunsigned int i;\n\n\tdev_info(test_dev->dev, \"Ending request_module() tests\\n\");\n\n\tmutex_lock(&test_dev->thread_mutex);\n\n\tfor (i=0; i < config->num_threads; i++) {\n\t\tinfo = &test_dev->info[i];\n\t\tif (info->task_sync && !IS_ERR(info->task_sync)) {\n\t\t\tdev_info(test_dev->dev,\n\t\t\t\t \"Stopping still-running thread %i\\n\", i);\n\t\t\tkthread_stop(info->task_sync);\n\t\t}\n\n\t\t \n\t\tif (info->task_sync && info->need_mod_put)\n\t\t\ttest_kmod_put_module(info);\n\t}\n\n\tmutex_unlock(&test_dev->thread_mutex);\n}\n\n \nstatic int try_requests(struct kmod_test_device *test_dev)\n{\n\tstruct test_config *config = &test_dev->config;\n\tunsigned int idx;\n\tint ret;\n\tbool any_error = false;\n\n\tfor (idx=0; idx < config->num_threads; idx++) {\n\t\tif (test_dev->test_is_oom) {\n\t\t\tany_error = true;\n\t\t\tbreak;\n\t\t}\n\n\t\tret = try_one_request(test_dev, idx);\n\t\tif (ret) {\n\t\t\tany_error = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!any_error) {\n\t\ttest_dev->test_is_oom = false;\n\t\tdev_info(test_dev->dev,\n\t\t\t \"No errors were found while initializing threads\\n\");\n\t\twait_for_completion(&test_dev->kthreads_done);\n\t\ttally_up_work(test_dev);\n\t} else {\n\t\ttest_dev->test_is_oom = true;\n\t\tdev_info(test_dev->dev,\n\t\t\t \"At least one thread failed to start, stop all work\\n\");\n\t\ttest_dev_kmod_stop_tests(test_dev);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\nstatic int run_test_driver(struct kmod_test_device *test_dev)\n{\n\tstruct test_config *config = &test_dev->config;\n\n\tdev_info(test_dev->dev, \"Test case: %s (%u)\\n\",\n\t\t test_case_str(config->test_case),\n\t\t config->test_case);\n\tdev_info(test_dev->dev, \"Test driver to load: %s\\n\",\n\t\t config->test_driver);\n\tdev_info(test_dev->dev, \"Number of threads to run: %u\\n\",\n\t\t config->num_threads);\n\tdev_info(test_dev->dev, \"Thread IDs will range from 0 - %u\\n\",\n\t\t config->num_threads - 1);\n\n\treturn try_requests(test_dev);\n}\n\nstatic int run_test_fs_type(struct kmod_test_device *test_dev)\n{\n\tstruct test_config *config = &test_dev->config;\n\n\tdev_info(test_dev->dev, \"Test case: %s (%u)\\n\",\n\t\t test_case_str(config->test_case),\n\t\t config->test_case);\n\tdev_info(test_dev->dev, \"Test filesystem to load: %s\\n\",\n\t\t config->test_fs);\n\tdev_info(test_dev->dev, \"Number of threads to run: %u\\n\",\n\t\t config->num_threads);\n\tdev_info(test_dev->dev, \"Thread IDs will range from 0 - %u\\n\",\n\t\t config->num_threads - 1);\n\n\treturn try_requests(test_dev);\n}\n\nstatic ssize_t config_show(struct device *dev,\n\t\t\t   struct device_attribute *attr,\n\t\t\t   char *buf)\n{\n\tstruct kmod_test_device *test_dev = dev_to_test_dev(dev);\n\tstruct test_config *config = &test_dev->config;\n\tint len = 0;\n\n\tmutex_lock(&test_dev->config_mutex);\n\n\tlen += snprintf(buf, PAGE_SIZE,\n\t\t\t\"Custom trigger configuration for: %s\\n\",\n\t\t\tdev_name(dev));\n\n\tlen += snprintf(buf+len, PAGE_SIZE - len,\n\t\t\t\"Number of threads:\\t%u\\n\",\n\t\t\tconfig->num_threads);\n\n\tlen += snprintf(buf+len, PAGE_SIZE - len,\n\t\t\t\"Test_case:\\t%s (%u)\\n\",\n\t\t\ttest_case_str(config->test_case),\n\t\t\tconfig->test_case);\n\n\tif (config->test_driver)\n\t\tlen += snprintf(buf+len, PAGE_SIZE - len,\n\t\t\t\t\"driver:\\t%s\\n\",\n\t\t\t\tconfig->test_driver);\n\telse\n\t\tlen += snprintf(buf+len, PAGE_SIZE - len,\n\t\t\t\t\"driver:\\tEMPTY\\n\");\n\n\tif (config->test_fs)\n\t\tlen += snprintf(buf+len, PAGE_SIZE - len,\n\t\t\t\t\"fs:\\t%s\\n\",\n\t\t\t\tconfig->test_fs);\n\telse\n\t\tlen += snprintf(buf+len, PAGE_SIZE - len,\n\t\t\t\t\"fs:\\tEMPTY\\n\");\n\n\tmutex_unlock(&test_dev->config_mutex);\n\n\treturn len;\n}\nstatic DEVICE_ATTR_RO(config);\n\n \nstatic int __trigger_config_run(struct kmod_test_device *test_dev)\n{\n\tstruct test_config *config = &test_dev->config;\n\n\ttest_dev->done = 0;\n\n\tswitch (config->test_case) {\n\tcase TEST_KMOD_DRIVER:\n\t\treturn run_test_driver(test_dev);\n\tcase TEST_KMOD_FS_TYPE:\n\t\treturn run_test_fs_type(test_dev);\n\tdefault:\n\t\tdev_warn(test_dev->dev,\n\t\t\t \"Invalid test case requested: %u\\n\",\n\t\t\t config->test_case);\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int trigger_config_run(struct kmod_test_device *test_dev)\n{\n\tstruct test_config *config = &test_dev->config;\n\tint ret;\n\n\tmutex_lock(&test_dev->trigger_mutex);\n\tmutex_lock(&test_dev->config_mutex);\n\n\tret = __trigger_config_run(test_dev);\n\tif (ret < 0)\n\t\tgoto out;\n\tdev_info(test_dev->dev, \"General test result: %d\\n\",\n\t\t config->test_result);\n\n\t \n\tret = 0;\n\nout:\n\tmutex_unlock(&test_dev->config_mutex);\n\tmutex_unlock(&test_dev->trigger_mutex);\n\n\treturn ret;\n}\n\nstatic ssize_t\ntrigger_config_store(struct device *dev,\n\t\t     struct device_attribute *attr,\n\t\t     const char *buf, size_t count)\n{\n\tstruct kmod_test_device *test_dev = dev_to_test_dev(dev);\n\tint ret;\n\n\tif (test_dev->test_is_oom)\n\t\treturn -ENOMEM;\n\n\t \n\tret = trigger_config_run(test_dev);\n\tif (unlikely(ret < 0))\n\t\tgoto out;\n\n\t \n\tif (WARN_ON(ret > 0))\n\t\treturn -EINVAL;\n\n\tret = count;\nout:\n\treturn ret;\n}\nstatic DEVICE_ATTR_WO(trigger_config);\n\n \nstatic int __kstrncpy(char **dst, const char *name, size_t count, gfp_t gfp)\n{\n\t*dst = kstrndup(name, count, gfp);\n\tif (!*dst)\n\t\treturn -ENOSPC;\n\treturn count;\n}\n\nstatic int config_copy_test_driver_name(struct test_config *config,\n\t\t\t\t    const char *name,\n\t\t\t\t    size_t count)\n{\n\treturn __kstrncpy(&config->test_driver, name, count, GFP_KERNEL);\n}\n\n\nstatic int config_copy_test_fs(struct test_config *config, const char *name,\n\t\t\t       size_t count)\n{\n\treturn __kstrncpy(&config->test_fs, name, count, GFP_KERNEL);\n}\n\nstatic void __kmod_config_free(struct test_config *config)\n{\n\tif (!config)\n\t\treturn;\n\n\tkfree_const(config->test_driver);\n\tconfig->test_driver = NULL;\n\n\tkfree_const(config->test_fs);\n\tconfig->test_fs = NULL;\n}\n\nstatic void kmod_config_free(struct kmod_test_device *test_dev)\n{\n\tstruct test_config *config;\n\n\tif (!test_dev)\n\t\treturn;\n\n\tconfig = &test_dev->config;\n\n\tmutex_lock(&test_dev->config_mutex);\n\t__kmod_config_free(config);\n\tmutex_unlock(&test_dev->config_mutex);\n}\n\nstatic ssize_t config_test_driver_store(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tconst char *buf, size_t count)\n{\n\tstruct kmod_test_device *test_dev = dev_to_test_dev(dev);\n\tstruct test_config *config = &test_dev->config;\n\tint copied;\n\n\tmutex_lock(&test_dev->config_mutex);\n\n\tkfree_const(config->test_driver);\n\tconfig->test_driver = NULL;\n\n\tcopied = config_copy_test_driver_name(config, buf, count);\n\tmutex_unlock(&test_dev->config_mutex);\n\n\treturn copied;\n}\n\n \nstatic ssize_t config_test_show_str(struct mutex *config_mutex,\n\t\t\t\t    char *dst,\n\t\t\t\t    char *src)\n{\n\tint len;\n\n\tmutex_lock(config_mutex);\n\tlen = snprintf(dst, PAGE_SIZE, \"%s\\n\", src);\n\tmutex_unlock(config_mutex);\n\n\treturn len;\n}\n\nstatic ssize_t config_test_driver_show(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tchar *buf)\n{\n\tstruct kmod_test_device *test_dev = dev_to_test_dev(dev);\n\tstruct test_config *config = &test_dev->config;\n\n\treturn config_test_show_str(&test_dev->config_mutex, buf,\n\t\t\t\t    config->test_driver);\n}\nstatic DEVICE_ATTR_RW(config_test_driver);\n\nstatic ssize_t config_test_fs_store(struct device *dev,\n\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t    const char *buf, size_t count)\n{\n\tstruct kmod_test_device *test_dev = dev_to_test_dev(dev);\n\tstruct test_config *config = &test_dev->config;\n\tint copied;\n\n\tmutex_lock(&test_dev->config_mutex);\n\n\tkfree_const(config->test_fs);\n\tconfig->test_fs = NULL;\n\n\tcopied = config_copy_test_fs(config, buf, count);\n\tmutex_unlock(&test_dev->config_mutex);\n\n\treturn copied;\n}\n\nstatic ssize_t config_test_fs_show(struct device *dev,\n\t\t\t\t   struct device_attribute *attr,\n\t\t\t\t   char *buf)\n{\n\tstruct kmod_test_device *test_dev = dev_to_test_dev(dev);\n\tstruct test_config *config = &test_dev->config;\n\n\treturn config_test_show_str(&test_dev->config_mutex, buf,\n\t\t\t\t    config->test_fs);\n}\nstatic DEVICE_ATTR_RW(config_test_fs);\n\nstatic int trigger_config_run_type(struct kmod_test_device *test_dev,\n\t\t\t\t   enum kmod_test_case test_case,\n\t\t\t\t   const char *test_str)\n{\n\tint copied = 0;\n\tstruct test_config *config = &test_dev->config;\n\n\tmutex_lock(&test_dev->config_mutex);\n\n\tswitch (test_case) {\n\tcase TEST_KMOD_DRIVER:\n\t\tkfree_const(config->test_driver);\n\t\tconfig->test_driver = NULL;\n\t\tcopied = config_copy_test_driver_name(config, test_str,\n\t\t\t\t\t\t      strlen(test_str));\n\t\tbreak;\n\tcase TEST_KMOD_FS_TYPE:\n\t\tkfree_const(config->test_fs);\n\t\tconfig->test_fs = NULL;\n\t\tcopied = config_copy_test_fs(config, test_str,\n\t\t\t\t\t     strlen(test_str));\n\t\tbreak;\n\tdefault:\n\t\tmutex_unlock(&test_dev->config_mutex);\n\t\treturn -EINVAL;\n\t}\n\n\tconfig->test_case = test_case;\n\n\tmutex_unlock(&test_dev->config_mutex);\n\n\tif (copied <= 0 || copied != strlen(test_str)) {\n\t\ttest_dev->test_is_oom = true;\n\t\treturn -ENOMEM;\n\t}\n\n\ttest_dev->test_is_oom = false;\n\n\treturn trigger_config_run(test_dev);\n}\n\nstatic void free_test_dev_info(struct kmod_test_device *test_dev)\n{\n\tvfree(test_dev->info);\n\ttest_dev->info = NULL;\n}\n\nstatic int kmod_config_sync_info(struct kmod_test_device *test_dev)\n{\n\tstruct test_config *config = &test_dev->config;\n\n\tfree_test_dev_info(test_dev);\n\ttest_dev->info =\n\t\tvzalloc(array_size(sizeof(struct kmod_test_device_info),\n\t\t\t\t   config->num_threads));\n\tif (!test_dev->info)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\n \n#ifdef get_kmod_umh_limit\nstatic unsigned int kmod_init_test_thread_limit(void)\n{\n\treturn get_kmod_umh_limit();\n}\n#else\nstatic unsigned int kmod_init_test_thread_limit(void)\n{\n\treturn TEST_START_NUM_THREADS;\n}\n#endif\n\nstatic int __kmod_config_init(struct kmod_test_device *test_dev)\n{\n\tstruct test_config *config = &test_dev->config;\n\tint ret = -ENOMEM, copied;\n\n\t__kmod_config_free(config);\n\n\tcopied = config_copy_test_driver_name(config, TEST_START_DRIVER,\n\t\t\t\t\t      strlen(TEST_START_DRIVER));\n\tif (copied != strlen(TEST_START_DRIVER))\n\t\tgoto err_out;\n\n\tcopied = config_copy_test_fs(config, TEST_START_TEST_FS,\n\t\t\t\t     strlen(TEST_START_TEST_FS));\n\tif (copied != strlen(TEST_START_TEST_FS))\n\t\tgoto err_out;\n\n\tconfig->num_threads = kmod_init_test_thread_limit();\n\tconfig->test_result = 0;\n\tconfig->test_case = TEST_START_TEST_CASE;\n\n\tret = kmod_config_sync_info(test_dev);\n\tif (ret)\n\t\tgoto err_out;\n\n\ttest_dev->test_is_oom = false;\n\n\treturn 0;\n\nerr_out:\n\ttest_dev->test_is_oom = true;\n\tWARN_ON(test_dev->test_is_oom);\n\n\t__kmod_config_free(config);\n\n\treturn ret;\n}\n\nstatic ssize_t reset_store(struct device *dev,\n\t\t\t   struct device_attribute *attr,\n\t\t\t   const char *buf, size_t count)\n{\n\tstruct kmod_test_device *test_dev = dev_to_test_dev(dev);\n\tint ret;\n\n\tmutex_lock(&test_dev->trigger_mutex);\n\tmutex_lock(&test_dev->config_mutex);\n\n\tret = __kmod_config_init(test_dev);\n\tif (ret < 0) {\n\t\tret = -ENOMEM;\n\t\tdev_err(dev, \"could not alloc settings for config trigger: %d\\n\",\n\t\t       ret);\n\t\tgoto out;\n\t}\n\n\tdev_info(dev, \"reset\\n\");\n\tret = count;\n\nout:\n\tmutex_unlock(&test_dev->config_mutex);\n\tmutex_unlock(&test_dev->trigger_mutex);\n\n\treturn ret;\n}\nstatic DEVICE_ATTR_WO(reset);\n\nstatic int test_dev_config_update_uint_sync(struct kmod_test_device *test_dev,\n\t\t\t\t\t    const char *buf, size_t size,\n\t\t\t\t\t    unsigned int *config,\n\t\t\t\t\t    int (*test_sync)(struct kmod_test_device *test_dev))\n{\n\tint ret;\n\tunsigned int val;\n\tunsigned int old_val;\n\n\tret = kstrtouint(buf, 10, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_lock(&test_dev->config_mutex);\n\n\told_val = *config;\n\t*(unsigned int *)config = val;\n\n\tret = test_sync(test_dev);\n\tif (ret) {\n\t\t*(unsigned int *)config = old_val;\n\n\t\tret = test_sync(test_dev);\n\t\tWARN_ON(ret);\n\n\t\tmutex_unlock(&test_dev->config_mutex);\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_unlock(&test_dev->config_mutex);\n\t \n\treturn size;\n}\n\nstatic int test_dev_config_update_uint_range(struct kmod_test_device *test_dev,\n\t\t\t\t\t     const char *buf, size_t size,\n\t\t\t\t\t     unsigned int *config,\n\t\t\t\t\t     unsigned int min,\n\t\t\t\t\t     unsigned int max)\n{\n\tunsigned int val;\n\tint ret;\n\n\tret = kstrtouint(buf, 10, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tif (val < min || val > max)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&test_dev->config_mutex);\n\t*config = val;\n\tmutex_unlock(&test_dev->config_mutex);\n\n\t \n\treturn size;\n}\n\nstatic int test_dev_config_update_int(struct kmod_test_device *test_dev,\n\t\t\t\t      const char *buf, size_t size,\n\t\t\t\t      int *config)\n{\n\tint val;\n\tint ret;\n\n\tret = kstrtoint(buf, 10, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_lock(&test_dev->config_mutex);\n\t*config = val;\n\tmutex_unlock(&test_dev->config_mutex);\n\t \n\treturn size;\n}\n\nstatic ssize_t test_dev_config_show_int(struct kmod_test_device *test_dev,\n\t\t\t\t\tchar *buf,\n\t\t\t\t\tint config)\n{\n\tint val;\n\n\tmutex_lock(&test_dev->config_mutex);\n\tval = config;\n\tmutex_unlock(&test_dev->config_mutex);\n\n\treturn snprintf(buf, PAGE_SIZE, \"%d\\n\", val);\n}\n\nstatic ssize_t test_dev_config_show_uint(struct kmod_test_device *test_dev,\n\t\t\t\t\t char *buf,\n\t\t\t\t\t unsigned int config)\n{\n\tunsigned int val;\n\n\tmutex_lock(&test_dev->config_mutex);\n\tval = config;\n\tmutex_unlock(&test_dev->config_mutex);\n\n\treturn snprintf(buf, PAGE_SIZE, \"%u\\n\", val);\n}\n\nstatic ssize_t test_result_store(struct device *dev,\n\t\t\t\t struct device_attribute *attr,\n\t\t\t\t const char *buf, size_t count)\n{\n\tstruct kmod_test_device *test_dev = dev_to_test_dev(dev);\n\tstruct test_config *config = &test_dev->config;\n\n\treturn test_dev_config_update_int(test_dev, buf, count,\n\t\t\t\t\t  &config->test_result);\n}\n\nstatic ssize_t config_num_threads_store(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tconst char *buf, size_t count)\n{\n\tstruct kmod_test_device *test_dev = dev_to_test_dev(dev);\n\tstruct test_config *config = &test_dev->config;\n\n\treturn test_dev_config_update_uint_sync(test_dev, buf, count,\n\t\t\t\t\t\t&config->num_threads,\n\t\t\t\t\t\tkmod_config_sync_info);\n}\n\nstatic ssize_t config_num_threads_show(struct device *dev,\n\t\t\t\t       struct device_attribute *attr,\n\t\t\t\t       char *buf)\n{\n\tstruct kmod_test_device *test_dev = dev_to_test_dev(dev);\n\tstruct test_config *config = &test_dev->config;\n\n\treturn test_dev_config_show_int(test_dev, buf, config->num_threads);\n}\nstatic DEVICE_ATTR_RW(config_num_threads);\n\nstatic ssize_t config_test_case_store(struct device *dev,\n\t\t\t\t      struct device_attribute *attr,\n\t\t\t\t      const char *buf, size_t count)\n{\n\tstruct kmod_test_device *test_dev = dev_to_test_dev(dev);\n\tstruct test_config *config = &test_dev->config;\n\n\treturn test_dev_config_update_uint_range(test_dev, buf, count,\n\t\t\t\t\t\t &config->test_case,\n\t\t\t\t\t\t __TEST_KMOD_INVALID + 1,\n\t\t\t\t\t\t __TEST_KMOD_MAX - 1);\n}\n\nstatic ssize_t config_test_case_show(struct device *dev,\n\t\t\t\t     struct device_attribute *attr,\n\t\t\t\t     char *buf)\n{\n\tstruct kmod_test_device *test_dev = dev_to_test_dev(dev);\n\tstruct test_config *config = &test_dev->config;\n\n\treturn test_dev_config_show_uint(test_dev, buf, config->test_case);\n}\nstatic DEVICE_ATTR_RW(config_test_case);\n\nstatic ssize_t test_result_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr,\n\t\t\t\tchar *buf)\n{\n\tstruct kmod_test_device *test_dev = dev_to_test_dev(dev);\n\tstruct test_config *config = &test_dev->config;\n\n\treturn test_dev_config_show_int(test_dev, buf, config->test_result);\n}\nstatic DEVICE_ATTR_RW(test_result);\n\n#define TEST_KMOD_DEV_ATTR(name)\t\t&dev_attr_##name.attr\n\nstatic struct attribute *test_dev_attrs[] = {\n\tTEST_KMOD_DEV_ATTR(trigger_config),\n\tTEST_KMOD_DEV_ATTR(config),\n\tTEST_KMOD_DEV_ATTR(reset),\n\n\tTEST_KMOD_DEV_ATTR(config_test_driver),\n\tTEST_KMOD_DEV_ATTR(config_test_fs),\n\tTEST_KMOD_DEV_ATTR(config_num_threads),\n\tTEST_KMOD_DEV_ATTR(config_test_case),\n\tTEST_KMOD_DEV_ATTR(test_result),\n\n\tNULL,\n};\n\nATTRIBUTE_GROUPS(test_dev);\n\nstatic int kmod_config_init(struct kmod_test_device *test_dev)\n{\n\tint ret;\n\n\tmutex_lock(&test_dev->config_mutex);\n\tret = __kmod_config_init(test_dev);\n\tmutex_unlock(&test_dev->config_mutex);\n\n\treturn ret;\n}\n\nstatic struct kmod_test_device *alloc_test_dev_kmod(int idx)\n{\n\tint ret;\n\tstruct kmod_test_device *test_dev;\n\tstruct miscdevice *misc_dev;\n\n\ttest_dev = vzalloc(sizeof(struct kmod_test_device));\n\tif (!test_dev)\n\t\tgoto err_out;\n\n\tmutex_init(&test_dev->config_mutex);\n\tmutex_init(&test_dev->trigger_mutex);\n\tmutex_init(&test_dev->thread_mutex);\n\n\tinit_completion(&test_dev->kthreads_done);\n\n\tret = kmod_config_init(test_dev);\n\tif (ret < 0) {\n\t\tpr_err(\"Cannot alloc kmod_config_init()\\n\");\n\t\tgoto err_out_free;\n\t}\n\n\ttest_dev->dev_idx = idx;\n\tmisc_dev = &test_dev->misc_dev;\n\n\tmisc_dev->minor = MISC_DYNAMIC_MINOR;\n\tmisc_dev->name = kasprintf(GFP_KERNEL, \"test_kmod%d\", idx);\n\tif (!misc_dev->name) {\n\t\tpr_err(\"Cannot alloc misc_dev->name\\n\");\n\t\tgoto err_out_free_config;\n\t}\n\tmisc_dev->groups = test_dev_groups;\n\n\treturn test_dev;\n\nerr_out_free_config:\n\tfree_test_dev_info(test_dev);\n\tkmod_config_free(test_dev);\nerr_out_free:\n\tvfree(test_dev);\n\ttest_dev = NULL;\nerr_out:\n\treturn NULL;\n}\n\nstatic void free_test_dev_kmod(struct kmod_test_device *test_dev)\n{\n\tif (test_dev) {\n\t\tkfree_const(test_dev->misc_dev.name);\n\t\ttest_dev->misc_dev.name = NULL;\n\t\tfree_test_dev_info(test_dev);\n\t\tkmod_config_free(test_dev);\n\t\tvfree(test_dev);\n\t\ttest_dev = NULL;\n\t}\n}\n\nstatic struct kmod_test_device *register_test_dev_kmod(void)\n{\n\tstruct kmod_test_device *test_dev = NULL;\n\tint ret;\n\n\tmutex_lock(&reg_dev_mutex);\n\n\t \n\tif (num_test_devs + 1 == INT_MAX) {\n\t\tpr_err(\"reached limit of number of test devices\\n\");\n\t\tgoto out;\n\t}\n\n\ttest_dev = alloc_test_dev_kmod(num_test_devs);\n\tif (!test_dev)\n\t\tgoto out;\n\n\tret = misc_register(&test_dev->misc_dev);\n\tif (ret) {\n\t\tpr_err(\"could not register misc device: %d\\n\", ret);\n\t\tfree_test_dev_kmod(test_dev);\n\t\ttest_dev = NULL;\n\t\tgoto out;\n\t}\n\n\ttest_dev->dev = test_dev->misc_dev.this_device;\n\tlist_add_tail(&test_dev->list, &reg_test_devs);\n\tdev_info(test_dev->dev, \"interface ready\\n\");\n\n\tnum_test_devs++;\n\nout:\n\tmutex_unlock(&reg_dev_mutex);\n\n\treturn test_dev;\n\n}\n\nstatic int __init test_kmod_init(void)\n{\n\tstruct kmod_test_device *test_dev;\n\tint ret;\n\n\ttest_dev = register_test_dev_kmod();\n\tif (!test_dev) {\n\t\tpr_err(\"Cannot add first test kmod device\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tif (force_init_test) {\n\t\tret = trigger_config_run_type(test_dev,\n\t\t\t\t\t      TEST_KMOD_DRIVER, \"tun\");\n\t\tif (WARN_ON(ret))\n\t\t\treturn ret;\n\t\tret = trigger_config_run_type(test_dev,\n\t\t\t\t\t      TEST_KMOD_FS_TYPE, \"btrfs\");\n\t\tif (WARN_ON(ret))\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\nlate_initcall(test_kmod_init);\n\nstatic\nvoid unregister_test_dev_kmod(struct kmod_test_device *test_dev)\n{\n\tmutex_lock(&test_dev->trigger_mutex);\n\tmutex_lock(&test_dev->config_mutex);\n\n\ttest_dev_kmod_stop_tests(test_dev);\n\n\tdev_info(test_dev->dev, \"removing interface\\n\");\n\tmisc_deregister(&test_dev->misc_dev);\n\n\tmutex_unlock(&test_dev->config_mutex);\n\tmutex_unlock(&test_dev->trigger_mutex);\n\n\tfree_test_dev_kmod(test_dev);\n}\n\nstatic void __exit test_kmod_exit(void)\n{\n\tstruct kmod_test_device *test_dev, *tmp;\n\n\tmutex_lock(&reg_dev_mutex);\n\tlist_for_each_entry_safe(test_dev, tmp, &reg_test_devs, list) {\n\t\tlist_del(&test_dev->list);\n\t\tunregister_test_dev_kmod(test_dev);\n\t}\n\tmutex_unlock(&reg_dev_mutex);\n}\nmodule_exit(test_kmod_exit);\n\nMODULE_AUTHOR(\"Luis R. Rodriguez <mcgrof@kernel.org>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}