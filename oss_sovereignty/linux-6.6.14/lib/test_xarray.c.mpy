{
  "module_name": "test_xarray.c",
  "hash_id": "ab50581e0aa024ee73c229027f9786c536c2d20826397b2a38907e51dce29019",
  "original_prompt": "Ingested from linux-6.6.14/lib/test_xarray.c",
  "human_readable_source": "\n \n\n#include <linux/xarray.h>\n#include <linux/module.h>\n\nstatic unsigned int tests_run;\nstatic unsigned int tests_passed;\n\nstatic const unsigned int order_limit =\n\t\tIS_ENABLED(CONFIG_XARRAY_MULTI) ? BITS_PER_LONG : 1;\n\n#ifndef XA_DEBUG\n# ifdef __KERNEL__\nvoid xa_dump(const struct xarray *xa) { }\n# endif\n#undef XA_BUG_ON\n#define XA_BUG_ON(xa, x) do {\t\t\t\t\t\\\n\ttests_run++;\t\t\t\t\t\t\\\n\tif (x) {\t\t\t\t\t\t\\\n\t\tprintk(\"BUG at %s:%d\\n\", __func__, __LINE__);\t\\\n\t\txa_dump(xa);\t\t\t\t\t\\\n\t\tdump_stack();\t\t\t\t\t\\\n\t} else {\t\t\t\t\t\t\\\n\t\ttests_passed++;\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\\\n} while (0)\n#endif\n\nstatic void *xa_mk_index(unsigned long index)\n{\n\treturn xa_mk_value(index & LONG_MAX);\n}\n\nstatic void *xa_store_index(struct xarray *xa, unsigned long index, gfp_t gfp)\n{\n\treturn xa_store(xa, index, xa_mk_index(index), gfp);\n}\n\nstatic void xa_insert_index(struct xarray *xa, unsigned long index)\n{\n\tXA_BUG_ON(xa, xa_insert(xa, index, xa_mk_index(index),\n\t\t\t\tGFP_KERNEL) != 0);\n}\n\nstatic void xa_alloc_index(struct xarray *xa, unsigned long index, gfp_t gfp)\n{\n\tu32 id;\n\n\tXA_BUG_ON(xa, xa_alloc(xa, &id, xa_mk_index(index), xa_limit_32b,\n\t\t\t\tgfp) != 0);\n\tXA_BUG_ON(xa, id != index);\n}\n\nstatic void xa_erase_index(struct xarray *xa, unsigned long index)\n{\n\tXA_BUG_ON(xa, xa_erase(xa, index) != xa_mk_index(index));\n\tXA_BUG_ON(xa, xa_load(xa, index) != NULL);\n}\n\n \nstatic void *xa_store_order(struct xarray *xa, unsigned long index,\n\t\tunsigned order, void *entry, gfp_t gfp)\n{\n\tXA_STATE_ORDER(xas, xa, index, order);\n\tvoid *curr;\n\n\tdo {\n\t\txas_lock(&xas);\n\t\tcurr = xas_store(&xas, entry);\n\t\txas_unlock(&xas);\n\t} while (xas_nomem(&xas, gfp));\n\n\treturn curr;\n}\n\nstatic noinline void check_xa_err(struct xarray *xa)\n{\n\tXA_BUG_ON(xa, xa_err(xa_store_index(xa, 0, GFP_NOWAIT)) != 0);\n\tXA_BUG_ON(xa, xa_err(xa_erase(xa, 0)) != 0);\n#ifndef __KERNEL__\n\t \n\tXA_BUG_ON(xa, xa_err(xa_store_index(xa, 1, GFP_NOWAIT)) != -ENOMEM);\n\tXA_BUG_ON(xa, xa_err(xa_store_index(xa, 1, GFP_NOWAIT)) != -ENOMEM);\n#endif\n\tXA_BUG_ON(xa, xa_err(xa_store_index(xa, 1, GFP_KERNEL)) != 0);\n\tXA_BUG_ON(xa, xa_err(xa_store(xa, 1, xa_mk_value(0), GFP_KERNEL)) != 0);\n\tXA_BUG_ON(xa, xa_err(xa_erase(xa, 1)) != 0);\n\n\n}\n\nstatic noinline void check_xas_retry(struct xarray *xa)\n{\n\tXA_STATE(xas, xa, 0);\n\tvoid *entry;\n\n\txa_store_index(xa, 0, GFP_KERNEL);\n\txa_store_index(xa, 1, GFP_KERNEL);\n\n\trcu_read_lock();\n\tXA_BUG_ON(xa, xas_find(&xas, ULONG_MAX) != xa_mk_value(0));\n\txa_erase_index(xa, 1);\n\tXA_BUG_ON(xa, !xa_is_retry(xas_reload(&xas)));\n\tXA_BUG_ON(xa, xas_retry(&xas, NULL));\n\tXA_BUG_ON(xa, xas_retry(&xas, xa_mk_value(0)));\n\txas_reset(&xas);\n\tXA_BUG_ON(xa, xas.xa_node != XAS_RESTART);\n\tXA_BUG_ON(xa, xas_next_entry(&xas, ULONG_MAX) != xa_mk_value(0));\n\tXA_BUG_ON(xa, xas.xa_node != NULL);\n\trcu_read_unlock();\n\n\tXA_BUG_ON(xa, xa_store_index(xa, 1, GFP_KERNEL) != NULL);\n\n\trcu_read_lock();\n\tXA_BUG_ON(xa, !xa_is_internal(xas_reload(&xas)));\n\txas.xa_node = XAS_RESTART;\n\tXA_BUG_ON(xa, xas_next_entry(&xas, ULONG_MAX) != xa_mk_value(0));\n\trcu_read_unlock();\n\n\t \n\txas_lock(&xas);\n\txas_set(&xas, 0);\n\txas_store(&xas, XA_RETRY_ENTRY);\n\txas_set(&xas, 1);\n\txas_store(&xas, XA_RETRY_ENTRY);\n\n\txas_set(&xas, 0);\n\txas_for_each(&xas, entry, ULONG_MAX) {\n\t\txas_store(&xas, xa_mk_index(xas.xa_index));\n\t}\n\txas_unlock(&xas);\n\n\txa_erase_index(xa, 0);\n\txa_erase_index(xa, 1);\n}\n\nstatic noinline void check_xa_load(struct xarray *xa)\n{\n\tunsigned long i, j;\n\n\tfor (i = 0; i < 1024; i++) {\n\t\tfor (j = 0; j < 1024; j++) {\n\t\t\tvoid *entry = xa_load(xa, j);\n\t\t\tif (j < i)\n\t\t\t\tXA_BUG_ON(xa, xa_to_value(entry) != j);\n\t\t\telse\n\t\t\t\tXA_BUG_ON(xa, entry);\n\t\t}\n\t\tXA_BUG_ON(xa, xa_store_index(xa, i, GFP_KERNEL) != NULL);\n\t}\n\n\tfor (i = 0; i < 1024; i++) {\n\t\tfor (j = 0; j < 1024; j++) {\n\t\t\tvoid *entry = xa_load(xa, j);\n\t\t\tif (j >= i)\n\t\t\t\tXA_BUG_ON(xa, xa_to_value(entry) != j);\n\t\t\telse\n\t\t\t\tXA_BUG_ON(xa, entry);\n\t\t}\n\t\txa_erase_index(xa, i);\n\t}\n\tXA_BUG_ON(xa, !xa_empty(xa));\n}\n\nstatic noinline void check_xa_mark_1(struct xarray *xa, unsigned long index)\n{\n\tunsigned int order;\n\tunsigned int max_order = IS_ENABLED(CONFIG_XARRAY_MULTI) ? 8 : 1;\n\n\t \n\tXA_BUG_ON(xa, xa_get_mark(xa, index, XA_MARK_0));\n\txa_set_mark(xa, index, XA_MARK_0);\n\tXA_BUG_ON(xa, xa_get_mark(xa, index, XA_MARK_0));\n\n\t \n\tXA_BUG_ON(xa, xa_store_index(xa, index, GFP_KERNEL) != NULL);\n\tXA_BUG_ON(xa, xa_get_mark(xa, index, XA_MARK_0));\n\txa_set_mark(xa, index, XA_MARK_0);\n\tXA_BUG_ON(xa, !xa_get_mark(xa, index, XA_MARK_0));\n\n\t \n\tXA_BUG_ON(xa, xa_get_mark(xa, index + 1, XA_MARK_0));\n\tXA_BUG_ON(xa, xa_get_mark(xa, index, XA_MARK_1));\n\n\t \n\txa_erase_index(xa, index);\n\tXA_BUG_ON(xa, !xa_empty(xa));\n\tXA_BUG_ON(xa, xa_get_mark(xa, index, XA_MARK_0));\n\txa_set_mark(xa, index, XA_MARK_0);\n\tXA_BUG_ON(xa, xa_get_mark(xa, index, XA_MARK_0));\n\n\t \n\tBUG_ON((index % 4) != 0);\n\tfor (order = 2; order < max_order; order++) {\n\t\tunsigned long base = round_down(index, 1UL << order);\n\t\tunsigned long next = base + (1UL << order);\n\t\tunsigned long i;\n\n\t\tXA_BUG_ON(xa, xa_store_index(xa, index + 1, GFP_KERNEL));\n\t\txa_set_mark(xa, index + 1, XA_MARK_0);\n\t\tXA_BUG_ON(xa, xa_store_index(xa, index + 2, GFP_KERNEL));\n\t\txa_set_mark(xa, index + 2, XA_MARK_2);\n\t\tXA_BUG_ON(xa, xa_store_index(xa, next, GFP_KERNEL));\n\t\txa_store_order(xa, index, order, xa_mk_index(index),\n\t\t\t\tGFP_KERNEL);\n\t\tfor (i = base; i < next; i++) {\n\t\t\tXA_STATE(xas, xa, i);\n\t\t\tunsigned int seen = 0;\n\t\t\tvoid *entry;\n\n\t\t\tXA_BUG_ON(xa, !xa_get_mark(xa, i, XA_MARK_0));\n\t\t\tXA_BUG_ON(xa, xa_get_mark(xa, i, XA_MARK_1));\n\t\t\tXA_BUG_ON(xa, !xa_get_mark(xa, i, XA_MARK_2));\n\n\t\t\t \n\t\t\trcu_read_lock();\n\t\t\txas_for_each(&xas, entry, ULONG_MAX)\n\t\t\t\tseen++;\n\t\t\trcu_read_unlock();\n\t\t\tXA_BUG_ON(xa, seen != 2);\n\n\t\t\t \n\t\t\txas_set(&xas, 0);\n\t\t\tseen = 0;\n\t\t\trcu_read_lock();\n\t\t\txas_for_each_marked(&xas, entry, ULONG_MAX, XA_MARK_0)\n\t\t\t\tseen++;\n\t\t\trcu_read_unlock();\n\t\t\tXA_BUG_ON(xa, seen != 1);\n\t\t}\n\t\tXA_BUG_ON(xa, xa_get_mark(xa, next, XA_MARK_0));\n\t\tXA_BUG_ON(xa, xa_get_mark(xa, next, XA_MARK_1));\n\t\tXA_BUG_ON(xa, xa_get_mark(xa, next, XA_MARK_2));\n\t\txa_erase_index(xa, index);\n\t\txa_erase_index(xa, next);\n\t\tXA_BUG_ON(xa, !xa_empty(xa));\n\t}\n\tXA_BUG_ON(xa, !xa_empty(xa));\n}\n\nstatic noinline void check_xa_mark_2(struct xarray *xa)\n{\n\tXA_STATE(xas, xa, 0);\n\tunsigned long index;\n\tunsigned int count = 0;\n\tvoid *entry;\n\n\txa_store_index(xa, 0, GFP_KERNEL);\n\txa_set_mark(xa, 0, XA_MARK_0);\n\txas_lock(&xas);\n\txas_load(&xas);\n\txas_init_marks(&xas);\n\txas_unlock(&xas);\n\tXA_BUG_ON(xa, !xa_get_mark(xa, 0, XA_MARK_0) == 0);\n\n\tfor (index = 3500; index < 4500; index++) {\n\t\txa_store_index(xa, index, GFP_KERNEL);\n\t\txa_set_mark(xa, index, XA_MARK_0);\n\t}\n\n\txas_reset(&xas);\n\trcu_read_lock();\n\txas_for_each_marked(&xas, entry, ULONG_MAX, XA_MARK_0)\n\t\tcount++;\n\trcu_read_unlock();\n\tXA_BUG_ON(xa, count != 1000);\n\n\txas_lock(&xas);\n\txas_for_each(&xas, entry, ULONG_MAX) {\n\t\txas_init_marks(&xas);\n\t\tXA_BUG_ON(xa, !xa_get_mark(xa, xas.xa_index, XA_MARK_0));\n\t\tXA_BUG_ON(xa, !xas_get_mark(&xas, XA_MARK_0));\n\t}\n\txas_unlock(&xas);\n\n\txa_destroy(xa);\n}\n\nstatic noinline void check_xa_mark_3(struct xarray *xa)\n{\n#ifdef CONFIG_XARRAY_MULTI\n\tXA_STATE(xas, xa, 0x41);\n\tvoid *entry;\n\tint count = 0;\n\n\txa_store_order(xa, 0x40, 2, xa_mk_index(0x40), GFP_KERNEL);\n\txa_set_mark(xa, 0x41, XA_MARK_0);\n\n\trcu_read_lock();\n\txas_for_each_marked(&xas, entry, ULONG_MAX, XA_MARK_0) {\n\t\tcount++;\n\t\tXA_BUG_ON(xa, entry != xa_mk_index(0x40));\n\t}\n\tXA_BUG_ON(xa, count != 1);\n\trcu_read_unlock();\n\txa_destroy(xa);\n#endif\n}\n\nstatic noinline void check_xa_mark(struct xarray *xa)\n{\n\tunsigned long index;\n\n\tfor (index = 0; index < 16384; index += 4)\n\t\tcheck_xa_mark_1(xa, index);\n\n\tcheck_xa_mark_2(xa);\n\tcheck_xa_mark_3(xa);\n}\n\nstatic noinline void check_xa_shrink(struct xarray *xa)\n{\n\tXA_STATE(xas, xa, 1);\n\tstruct xa_node *node;\n\tunsigned int order;\n\tunsigned int max_order = IS_ENABLED(CONFIG_XARRAY_MULTI) ? 15 : 1;\n\n\tXA_BUG_ON(xa, !xa_empty(xa));\n\tXA_BUG_ON(xa, xa_store_index(xa, 0, GFP_KERNEL) != NULL);\n\tXA_BUG_ON(xa, xa_store_index(xa, 1, GFP_KERNEL) != NULL);\n\n\t \n\txas_lock(&xas);\n\tXA_BUG_ON(xa, xas_load(&xas) != xa_mk_value(1));\n\tnode = xas.xa_node;\n\tXA_BUG_ON(xa, xa_entry_locked(xa, node, 0) != xa_mk_value(0));\n\tXA_BUG_ON(xa, xas_store(&xas, NULL) != xa_mk_value(1));\n\tXA_BUG_ON(xa, xa_load(xa, 1) != NULL);\n\tXA_BUG_ON(xa, xas.xa_node != XAS_BOUNDS);\n\tXA_BUG_ON(xa, xa_entry_locked(xa, node, 0) != XA_RETRY_ENTRY);\n\tXA_BUG_ON(xa, xas_load(&xas) != NULL);\n\txas_unlock(&xas);\n\tXA_BUG_ON(xa, xa_load(xa, 0) != xa_mk_value(0));\n\txa_erase_index(xa, 0);\n\tXA_BUG_ON(xa, !xa_empty(xa));\n\n\tfor (order = 0; order < max_order; order++) {\n\t\tunsigned long max = (1UL << order) - 1;\n\t\txa_store_order(xa, 0, order, xa_mk_value(0), GFP_KERNEL);\n\t\tXA_BUG_ON(xa, xa_load(xa, max) != xa_mk_value(0));\n\t\tXA_BUG_ON(xa, xa_load(xa, max + 1) != NULL);\n\t\trcu_read_lock();\n\t\tnode = xa_head(xa);\n\t\trcu_read_unlock();\n\t\tXA_BUG_ON(xa, xa_store_index(xa, ULONG_MAX, GFP_KERNEL) !=\n\t\t\t\tNULL);\n\t\trcu_read_lock();\n\t\tXA_BUG_ON(xa, xa_head(xa) == node);\n\t\trcu_read_unlock();\n\t\tXA_BUG_ON(xa, xa_load(xa, max + 1) != NULL);\n\t\txa_erase_index(xa, ULONG_MAX);\n\t\tXA_BUG_ON(xa, xa->xa_head != node);\n\t\txa_erase_index(xa, 0);\n\t}\n}\n\nstatic noinline void check_insert(struct xarray *xa)\n{\n\tunsigned long i;\n\n\tfor (i = 0; i < 1024; i++) {\n\t\txa_insert_index(xa, i);\n\t\tXA_BUG_ON(xa, xa_load(xa, i - 1) != NULL);\n\t\tXA_BUG_ON(xa, xa_load(xa, i + 1) != NULL);\n\t\txa_erase_index(xa, i);\n\t}\n\n\tfor (i = 10; i < BITS_PER_LONG; i++) {\n\t\txa_insert_index(xa, 1UL << i);\n\t\tXA_BUG_ON(xa, xa_load(xa, (1UL << i) - 1) != NULL);\n\t\tXA_BUG_ON(xa, xa_load(xa, (1UL << i) + 1) != NULL);\n\t\txa_erase_index(xa, 1UL << i);\n\n\t\txa_insert_index(xa, (1UL << i) - 1);\n\t\tXA_BUG_ON(xa, xa_load(xa, (1UL << i) - 2) != NULL);\n\t\tXA_BUG_ON(xa, xa_load(xa, 1UL << i) != NULL);\n\t\txa_erase_index(xa, (1UL << i) - 1);\n\t}\n\n\txa_insert_index(xa, ~0UL);\n\tXA_BUG_ON(xa, xa_load(xa, 0UL) != NULL);\n\tXA_BUG_ON(xa, xa_load(xa, ~1UL) != NULL);\n\txa_erase_index(xa, ~0UL);\n\n\tXA_BUG_ON(xa, !xa_empty(xa));\n}\n\nstatic noinline void check_cmpxchg(struct xarray *xa)\n{\n\tvoid *FIVE = xa_mk_value(5);\n\tvoid *SIX = xa_mk_value(6);\n\tvoid *LOTS = xa_mk_value(12345678);\n\n\tXA_BUG_ON(xa, !xa_empty(xa));\n\tXA_BUG_ON(xa, xa_store_index(xa, 12345678, GFP_KERNEL) != NULL);\n\tXA_BUG_ON(xa, xa_insert(xa, 12345678, xa, GFP_KERNEL) != -EBUSY);\n\tXA_BUG_ON(xa, xa_cmpxchg(xa, 12345678, SIX, FIVE, GFP_KERNEL) != LOTS);\n\tXA_BUG_ON(xa, xa_cmpxchg(xa, 12345678, LOTS, FIVE, GFP_KERNEL) != LOTS);\n\tXA_BUG_ON(xa, xa_cmpxchg(xa, 12345678, FIVE, LOTS, GFP_KERNEL) != FIVE);\n\tXA_BUG_ON(xa, xa_cmpxchg(xa, 5, FIVE, NULL, GFP_KERNEL) != NULL);\n\tXA_BUG_ON(xa, xa_cmpxchg(xa, 5, NULL, FIVE, GFP_KERNEL) != NULL);\n\tXA_BUG_ON(xa, xa_insert(xa, 5, FIVE, GFP_KERNEL) != -EBUSY);\n\tXA_BUG_ON(xa, xa_cmpxchg(xa, 5, FIVE, NULL, GFP_KERNEL) != FIVE);\n\tXA_BUG_ON(xa, xa_insert(xa, 5, FIVE, GFP_KERNEL) == -EBUSY);\n\txa_erase_index(xa, 12345678);\n\txa_erase_index(xa, 5);\n\tXA_BUG_ON(xa, !xa_empty(xa));\n}\n\nstatic noinline void check_reserve(struct xarray *xa)\n{\n\tvoid *entry;\n\tunsigned long index;\n\tint count;\n\n\t \n\tXA_BUG_ON(xa, !xa_empty(xa));\n\tXA_BUG_ON(xa, xa_reserve(xa, 12345678, GFP_KERNEL) != 0);\n\tXA_BUG_ON(xa, xa_empty(xa));\n\tXA_BUG_ON(xa, xa_load(xa, 12345678));\n\txa_release(xa, 12345678);\n\tXA_BUG_ON(xa, !xa_empty(xa));\n\n\t \n\tXA_BUG_ON(xa, xa_reserve(xa, 12345678, GFP_KERNEL) != 0);\n\tXA_BUG_ON(xa, xa_store_index(xa, 12345678, GFP_NOWAIT) != NULL);\n\txa_release(xa, 12345678);\n\txa_erase_index(xa, 12345678);\n\tXA_BUG_ON(xa, !xa_empty(xa));\n\n\t \n\tXA_BUG_ON(xa, xa_reserve(xa, 12345678, GFP_KERNEL) != 0);\n\tXA_BUG_ON(xa, xa_cmpxchg(xa, 12345678, XA_ZERO_ENTRY,\n\t\t\t\txa_mk_value(12345678), GFP_NOWAIT) != NULL);\n\txa_release(xa, 12345678);\n\txa_erase_index(xa, 12345678);\n\tXA_BUG_ON(xa, !xa_empty(xa));\n\n\t \n\tXA_BUG_ON(xa, xa_reserve(xa, 12345678, GFP_KERNEL) != 0);\n\tXA_BUG_ON(xa, xa_insert(xa, 12345678, xa_mk_value(12345678), 0) !=\n\t\t\t-EBUSY);\n\tXA_BUG_ON(xa, xa_empty(xa));\n\tXA_BUG_ON(xa, xa_erase(xa, 12345678) != NULL);\n\tXA_BUG_ON(xa, !xa_empty(xa));\n\n\t \n\txa_store_index(xa, 5, GFP_KERNEL);\n\tXA_BUG_ON(xa, xa_reserve(xa, 6, GFP_KERNEL) != 0);\n\txa_store_index(xa, 7, GFP_KERNEL);\n\n\tcount = 0;\n\txa_for_each(xa, index, entry) {\n\t\tXA_BUG_ON(xa, index != 5 && index != 7);\n\t\tcount++;\n\t}\n\tXA_BUG_ON(xa, count != 2);\n\n\t \n\tif (xa->xa_flags & XA_FLAGS_ALLOC) {\n\t\tu32 id;\n\n\t\tXA_BUG_ON(xa, xa_alloc(xa, &id, xa_mk_value(8),\n\t\t\t\t\tXA_LIMIT(5, 10), GFP_KERNEL) != 0);\n\t\tXA_BUG_ON(xa, id != 8);\n\n\t\txa_release(xa, 6);\n\t\tXA_BUG_ON(xa, xa_alloc(xa, &id, xa_mk_value(6),\n\t\t\t\t\tXA_LIMIT(5, 10), GFP_KERNEL) != 0);\n\t\tXA_BUG_ON(xa, id != 6);\n\t}\n\n\txa_destroy(xa);\n}\n\nstatic noinline void check_xas_erase(struct xarray *xa)\n{\n\tXA_STATE(xas, xa, 0);\n\tvoid *entry;\n\tunsigned long i, j;\n\n\tfor (i = 0; i < 200; i++) {\n\t\tfor (j = i; j < 2 * i + 17; j++) {\n\t\t\txas_set(&xas, j);\n\t\t\tdo {\n\t\t\t\txas_lock(&xas);\n\t\t\t\txas_store(&xas, xa_mk_index(j));\n\t\t\t\txas_unlock(&xas);\n\t\t\t} while (xas_nomem(&xas, GFP_KERNEL));\n\t\t}\n\n\t\txas_set(&xas, ULONG_MAX);\n\t\tdo {\n\t\t\txas_lock(&xas);\n\t\t\txas_store(&xas, xa_mk_value(0));\n\t\t\txas_unlock(&xas);\n\t\t} while (xas_nomem(&xas, GFP_KERNEL));\n\n\t\txas_lock(&xas);\n\t\txas_store(&xas, NULL);\n\n\t\txas_set(&xas, 0);\n\t\tj = i;\n\t\txas_for_each(&xas, entry, ULONG_MAX) {\n\t\t\tXA_BUG_ON(xa, entry != xa_mk_index(j));\n\t\t\txas_store(&xas, NULL);\n\t\t\tj++;\n\t\t}\n\t\txas_unlock(&xas);\n\t\tXA_BUG_ON(xa, !xa_empty(xa));\n\t}\n}\n\n#ifdef CONFIG_XARRAY_MULTI\nstatic noinline void check_multi_store_1(struct xarray *xa, unsigned long index,\n\t\tunsigned int order)\n{\n\tXA_STATE(xas, xa, index);\n\tunsigned long min = index & ~((1UL << order) - 1);\n\tunsigned long max = min + (1UL << order);\n\n\txa_store_order(xa, index, order, xa_mk_index(index), GFP_KERNEL);\n\tXA_BUG_ON(xa, xa_load(xa, min) != xa_mk_index(index));\n\tXA_BUG_ON(xa, xa_load(xa, max - 1) != xa_mk_index(index));\n\tXA_BUG_ON(xa, xa_load(xa, max) != NULL);\n\tXA_BUG_ON(xa, xa_load(xa, min - 1) != NULL);\n\n\txas_lock(&xas);\n\tXA_BUG_ON(xa, xas_store(&xas, xa_mk_index(min)) != xa_mk_index(index));\n\txas_unlock(&xas);\n\tXA_BUG_ON(xa, xa_load(xa, min) != xa_mk_index(min));\n\tXA_BUG_ON(xa, xa_load(xa, max - 1) != xa_mk_index(min));\n\tXA_BUG_ON(xa, xa_load(xa, max) != NULL);\n\tXA_BUG_ON(xa, xa_load(xa, min - 1) != NULL);\n\n\txa_erase_index(xa, min);\n\tXA_BUG_ON(xa, !xa_empty(xa));\n}\n\nstatic noinline void check_multi_store_2(struct xarray *xa, unsigned long index,\n\t\tunsigned int order)\n{\n\tXA_STATE(xas, xa, index);\n\txa_store_order(xa, index, order, xa_mk_value(0), GFP_KERNEL);\n\n\txas_lock(&xas);\n\tXA_BUG_ON(xa, xas_store(&xas, xa_mk_value(1)) != xa_mk_value(0));\n\tXA_BUG_ON(xa, xas.xa_index != index);\n\tXA_BUG_ON(xa, xas_store(&xas, NULL) != xa_mk_value(1));\n\txas_unlock(&xas);\n\tXA_BUG_ON(xa, !xa_empty(xa));\n}\n\nstatic noinline void check_multi_store_3(struct xarray *xa, unsigned long index,\n\t\tunsigned int order)\n{\n\tXA_STATE(xas, xa, 0);\n\tvoid *entry;\n\tint n = 0;\n\n\txa_store_order(xa, index, order, xa_mk_index(index), GFP_KERNEL);\n\n\txas_lock(&xas);\n\txas_for_each(&xas, entry, ULONG_MAX) {\n\t\tXA_BUG_ON(xa, entry != xa_mk_index(index));\n\t\tn++;\n\t}\n\tXA_BUG_ON(xa, n != 1);\n\txas_set(&xas, index + 1);\n\txas_for_each(&xas, entry, ULONG_MAX) {\n\t\tXA_BUG_ON(xa, entry != xa_mk_index(index));\n\t\tn++;\n\t}\n\tXA_BUG_ON(xa, n != 2);\n\txas_unlock(&xas);\n\n\txa_destroy(xa);\n}\n#endif\n\nstatic noinline void check_multi_store(struct xarray *xa)\n{\n#ifdef CONFIG_XARRAY_MULTI\n\tunsigned long i, j, k;\n\tunsigned int max_order = (sizeof(long) == 4) ? 30 : 60;\n\n\t \n\txa_store_order(xa, 0, 1, xa_mk_value(0), GFP_KERNEL);\n\tXA_BUG_ON(xa, xa_load(xa, 0) != xa_mk_value(0));\n\tXA_BUG_ON(xa, xa_load(xa, 1) != xa_mk_value(0));\n\tXA_BUG_ON(xa, xa_load(xa, 2) != NULL);\n\trcu_read_lock();\n\tXA_BUG_ON(xa, xa_to_node(xa_head(xa))->count != 2);\n\tXA_BUG_ON(xa, xa_to_node(xa_head(xa))->nr_values != 2);\n\trcu_read_unlock();\n\n\t \n\txa_store(xa, 3, xa, GFP_KERNEL);\n\tXA_BUG_ON(xa, xa_load(xa, 0) != xa_mk_value(0));\n\tXA_BUG_ON(xa, xa_load(xa, 1) != xa_mk_value(0));\n\tXA_BUG_ON(xa, xa_load(xa, 2) != NULL);\n\trcu_read_lock();\n\tXA_BUG_ON(xa, xa_to_node(xa_head(xa))->count != 3);\n\tXA_BUG_ON(xa, xa_to_node(xa_head(xa))->nr_values != 2);\n\trcu_read_unlock();\n\n\t \n\txa_store_order(xa, 0, 2, xa_mk_value(1), GFP_KERNEL);\n\tXA_BUG_ON(xa, xa_load(xa, 0) != xa_mk_value(1));\n\tXA_BUG_ON(xa, xa_load(xa, 1) != xa_mk_value(1));\n\tXA_BUG_ON(xa, xa_load(xa, 2) != xa_mk_value(1));\n\tXA_BUG_ON(xa, xa_load(xa, 3) != xa_mk_value(1));\n\tXA_BUG_ON(xa, xa_load(xa, 4) != NULL);\n\trcu_read_lock();\n\tXA_BUG_ON(xa, xa_to_node(xa_head(xa))->count != 4);\n\tXA_BUG_ON(xa, xa_to_node(xa_head(xa))->nr_values != 4);\n\trcu_read_unlock();\n\n\t \n\txa_store_order(xa, 0, BITS_PER_LONG - 1, NULL, GFP_KERNEL);\n\tXA_BUG_ON(xa, !xa_empty(xa));\n\n\t \n\txa_store_index(xa, 1, GFP_KERNEL);\n\txa_store_index(xa, 2, GFP_KERNEL);\n\txa_store_order(xa, 0, 2, NULL, GFP_KERNEL);\n\tXA_BUG_ON(xa, !xa_empty(xa));\n\n\tfor (i = 0; i < max_order; i++) {\n\t\tfor (j = 0; j < max_order; j++) {\n\t\t\txa_store_order(xa, 0, i, xa_mk_index(i), GFP_KERNEL);\n\t\t\txa_store_order(xa, 0, j, xa_mk_index(j), GFP_KERNEL);\n\n\t\t\tfor (k = 0; k < max_order; k++) {\n\t\t\t\tvoid *entry = xa_load(xa, (1UL << k) - 1);\n\t\t\t\tif ((i < k) && (j < k))\n\t\t\t\t\tXA_BUG_ON(xa, entry != NULL);\n\t\t\t\telse\n\t\t\t\t\tXA_BUG_ON(xa, entry != xa_mk_index(j));\n\t\t\t}\n\n\t\t\txa_erase(xa, 0);\n\t\t\tXA_BUG_ON(xa, !xa_empty(xa));\n\t\t}\n\t}\n\n\tfor (i = 0; i < 20; i++) {\n\t\tcheck_multi_store_1(xa, 200, i);\n\t\tcheck_multi_store_1(xa, 0, i);\n\t\tcheck_multi_store_1(xa, (1UL << i) + 1, i);\n\t}\n\tcheck_multi_store_2(xa, 4095, 9);\n\n\tfor (i = 1; i < 20; i++) {\n\t\tcheck_multi_store_3(xa, 0, i);\n\t\tcheck_multi_store_3(xa, 1UL << i, i);\n\t}\n#endif\n}\n\nstatic noinline void check_xa_alloc_1(struct xarray *xa, unsigned int base)\n{\n\tint i;\n\tu32 id;\n\n\tXA_BUG_ON(xa, !xa_empty(xa));\n\t \n\txa_alloc_index(xa, base, GFP_KERNEL);\n\n\t \n\txa_erase_index(xa, base);\n\tXA_BUG_ON(xa, !xa_empty(xa));\n\n\t \n\txa_alloc_index(xa, base, GFP_KERNEL);\n\n\t \n\tfor (i = base + 1; i < 2 * XA_CHUNK_SIZE; i++)\n\t\txa_alloc_index(xa, i, GFP_KERNEL);\n\tfor (i = base; i < 2 * XA_CHUNK_SIZE; i++)\n\t\txa_erase_index(xa, i);\n\txa_alloc_index(xa, base, GFP_KERNEL);\n\n\t \n\txa_destroy(xa);\n\n\t \n\txa_alloc_index(xa, base, GFP_KERNEL);\n\n\t \n\txa_alloc_index(xa, base + 1, GFP_KERNEL);\n\txa_erase_index(xa, base + 1);\n\n\t \n\txa_store_index(xa, base + 1, GFP_KERNEL);\n\txa_alloc_index(xa, base + 2, GFP_KERNEL);\n\n\t \n\txa_erase_index(xa, base);\n\txa_alloc_index(xa, base, GFP_KERNEL);\n\n\txa_erase_index(xa, base + 1);\n\txa_erase_index(xa, base + 2);\n\n\tfor (i = 1; i < 5000; i++) {\n\t\txa_alloc_index(xa, base + i, GFP_KERNEL);\n\t}\n\n\txa_destroy(xa);\n\n\t \n\tXA_BUG_ON(xa, xa_alloc(xa, &id, xa_mk_index(UINT_MAX - 1),\n\t\t\t\tXA_LIMIT(UINT_MAX - 1, UINT_MAX),\n\t\t\t\tGFP_KERNEL) != 0);\n\tXA_BUG_ON(xa, id != 0xfffffffeU);\n\tXA_BUG_ON(xa, xa_alloc(xa, &id, xa_mk_index(UINT_MAX),\n\t\t\t\tXA_LIMIT(UINT_MAX - 1, UINT_MAX),\n\t\t\t\tGFP_KERNEL) != 0);\n\tXA_BUG_ON(xa, id != 0xffffffffU);\n\tid = 3;\n\tXA_BUG_ON(xa, xa_alloc(xa, &id, xa_mk_index(0),\n\t\t\t\tXA_LIMIT(UINT_MAX - 1, UINT_MAX),\n\t\t\t\tGFP_KERNEL) != -EBUSY);\n\tXA_BUG_ON(xa, id != 3);\n\txa_destroy(xa);\n\n\tXA_BUG_ON(xa, xa_alloc(xa, &id, xa_mk_index(10), XA_LIMIT(10, 5),\n\t\t\t\tGFP_KERNEL) != -EBUSY);\n\tXA_BUG_ON(xa, xa_store_index(xa, 3, GFP_KERNEL) != 0);\n\tXA_BUG_ON(xa, xa_alloc(xa, &id, xa_mk_index(10), XA_LIMIT(10, 5),\n\t\t\t\tGFP_KERNEL) != -EBUSY);\n\txa_erase_index(xa, 3);\n\tXA_BUG_ON(xa, !xa_empty(xa));\n}\n\nstatic noinline void check_xa_alloc_2(struct xarray *xa, unsigned int base)\n{\n\tunsigned int i, id;\n\tunsigned long index;\n\tvoid *entry;\n\n\t \n\tXA_BUG_ON(xa, !xa_empty(xa));\n\tXA_BUG_ON(xa, xa_alloc(xa, &id, NULL, xa_limit_32b, GFP_KERNEL) != 0);\n\tXA_BUG_ON(xa, id != base);\n\tXA_BUG_ON(xa, xa_empty(xa));\n\tXA_BUG_ON(xa, xa_erase(xa, id) != NULL);\n\tXA_BUG_ON(xa, !xa_empty(xa));\n\n\t \n\tXA_BUG_ON(xa, !xa_empty(xa));\n\tXA_BUG_ON(xa, xa_alloc(xa, &id, NULL, xa_limit_32b, GFP_KERNEL) != 0);\n\tXA_BUG_ON(xa, id != base);\n\tXA_BUG_ON(xa, xa_empty(xa));\n\txa_destroy(xa);\n\tXA_BUG_ON(xa, !xa_empty(xa));\n\n\tfor (i = base; i < base + 10; i++) {\n\t\tXA_BUG_ON(xa, xa_alloc(xa, &id, NULL, xa_limit_32b,\n\t\t\t\t\tGFP_KERNEL) != 0);\n\t\tXA_BUG_ON(xa, id != i);\n\t}\n\n\tXA_BUG_ON(xa, xa_store(xa, 3, xa_mk_index(3), GFP_KERNEL) != NULL);\n\tXA_BUG_ON(xa, xa_store(xa, 4, xa_mk_index(4), GFP_KERNEL) != NULL);\n\tXA_BUG_ON(xa, xa_store(xa, 4, NULL, GFP_KERNEL) != xa_mk_index(4));\n\tXA_BUG_ON(xa, xa_erase(xa, 5) != NULL);\n\tXA_BUG_ON(xa, xa_alloc(xa, &id, NULL, xa_limit_32b, GFP_KERNEL) != 0);\n\tXA_BUG_ON(xa, id != 5);\n\n\txa_for_each(xa, index, entry) {\n\t\txa_erase_index(xa, index);\n\t}\n\n\tfor (i = base; i < base + 9; i++) {\n\t\tXA_BUG_ON(xa, xa_erase(xa, i) != NULL);\n\t\tXA_BUG_ON(xa, xa_empty(xa));\n\t}\n\tXA_BUG_ON(xa, xa_erase(xa, 8) != NULL);\n\tXA_BUG_ON(xa, xa_empty(xa));\n\tXA_BUG_ON(xa, xa_erase(xa, base + 9) != NULL);\n\tXA_BUG_ON(xa, !xa_empty(xa));\n\n\txa_destroy(xa);\n}\n\nstatic noinline void check_xa_alloc_3(struct xarray *xa, unsigned int base)\n{\n\tstruct xa_limit limit = XA_LIMIT(1, 0x3fff);\n\tu32 next = 0;\n\tunsigned int i, id;\n\tunsigned long index;\n\tvoid *entry;\n\n\tXA_BUG_ON(xa, xa_alloc_cyclic(xa, &id, xa_mk_index(1), limit,\n\t\t\t\t&next, GFP_KERNEL) != 0);\n\tXA_BUG_ON(xa, id != 1);\n\n\tnext = 0x3ffd;\n\tXA_BUG_ON(xa, xa_alloc_cyclic(xa, &id, xa_mk_index(0x3ffd), limit,\n\t\t\t\t&next, GFP_KERNEL) != 0);\n\tXA_BUG_ON(xa, id != 0x3ffd);\n\txa_erase_index(xa, 0x3ffd);\n\txa_erase_index(xa, 1);\n\tXA_BUG_ON(xa, !xa_empty(xa));\n\n\tfor (i = 0x3ffe; i < 0x4003; i++) {\n\t\tif (i < 0x4000)\n\t\t\tentry = xa_mk_index(i);\n\t\telse\n\t\t\tentry = xa_mk_index(i - 0x3fff);\n\t\tXA_BUG_ON(xa, xa_alloc_cyclic(xa, &id, entry, limit,\n\t\t\t\t\t&next, GFP_KERNEL) != (id == 1));\n\t\tXA_BUG_ON(xa, xa_mk_index(id) != entry);\n\t}\n\n\t \n\tif (base != 0)\n\t\txa_erase_index(xa, base);\n\txa_erase_index(xa, base + 1);\n\tnext = UINT_MAX;\n\tXA_BUG_ON(xa, xa_alloc_cyclic(xa, &id, xa_mk_index(UINT_MAX),\n\t\t\t\txa_limit_32b, &next, GFP_KERNEL) != 0);\n\tXA_BUG_ON(xa, id != UINT_MAX);\n\tXA_BUG_ON(xa, xa_alloc_cyclic(xa, &id, xa_mk_index(base),\n\t\t\t\txa_limit_32b, &next, GFP_KERNEL) != 1);\n\tXA_BUG_ON(xa, id != base);\n\tXA_BUG_ON(xa, xa_alloc_cyclic(xa, &id, xa_mk_index(base + 1),\n\t\t\t\txa_limit_32b, &next, GFP_KERNEL) != 0);\n\tXA_BUG_ON(xa, id != base + 1);\n\n\txa_for_each(xa, index, entry)\n\t\txa_erase_index(xa, index);\n\n\tXA_BUG_ON(xa, !xa_empty(xa));\n}\n\nstatic DEFINE_XARRAY_ALLOC(xa0);\nstatic DEFINE_XARRAY_ALLOC1(xa1);\n\nstatic noinline void check_xa_alloc(void)\n{\n\tcheck_xa_alloc_1(&xa0, 0);\n\tcheck_xa_alloc_1(&xa1, 1);\n\tcheck_xa_alloc_2(&xa0, 0);\n\tcheck_xa_alloc_2(&xa1, 1);\n\tcheck_xa_alloc_3(&xa0, 0);\n\tcheck_xa_alloc_3(&xa1, 1);\n}\n\nstatic noinline void __check_store_iter(struct xarray *xa, unsigned long start,\n\t\t\tunsigned int order, unsigned int present)\n{\n\tXA_STATE_ORDER(xas, xa, start, order);\n\tvoid *entry;\n\tunsigned int count = 0;\n\nretry:\n\txas_lock(&xas);\n\txas_for_each_conflict(&xas, entry) {\n\t\tXA_BUG_ON(xa, !xa_is_value(entry));\n\t\tXA_BUG_ON(xa, entry < xa_mk_index(start));\n\t\tXA_BUG_ON(xa, entry > xa_mk_index(start + (1UL << order) - 1));\n\t\tcount++;\n\t}\n\txas_store(&xas, xa_mk_index(start));\n\txas_unlock(&xas);\n\tif (xas_nomem(&xas, GFP_KERNEL)) {\n\t\tcount = 0;\n\t\tgoto retry;\n\t}\n\tXA_BUG_ON(xa, xas_error(&xas));\n\tXA_BUG_ON(xa, count != present);\n\tXA_BUG_ON(xa, xa_load(xa, start) != xa_mk_index(start));\n\tXA_BUG_ON(xa, xa_load(xa, start + (1UL << order) - 1) !=\n\t\t\txa_mk_index(start));\n\txa_erase_index(xa, start);\n}\n\nstatic noinline void check_store_iter(struct xarray *xa)\n{\n\tunsigned int i, j;\n\tunsigned int max_order = IS_ENABLED(CONFIG_XARRAY_MULTI) ? 20 : 1;\n\n\tfor (i = 0; i < max_order; i++) {\n\t\tunsigned int min = 1 << i;\n\t\tunsigned int max = (2 << i) - 1;\n\t\t__check_store_iter(xa, 0, i, 0);\n\t\tXA_BUG_ON(xa, !xa_empty(xa));\n\t\t__check_store_iter(xa, min, i, 0);\n\t\tXA_BUG_ON(xa, !xa_empty(xa));\n\n\t\txa_store_index(xa, min, GFP_KERNEL);\n\t\t__check_store_iter(xa, min, i, 1);\n\t\tXA_BUG_ON(xa, !xa_empty(xa));\n\t\txa_store_index(xa, max, GFP_KERNEL);\n\t\t__check_store_iter(xa, min, i, 1);\n\t\tXA_BUG_ON(xa, !xa_empty(xa));\n\n\t\tfor (j = 0; j < min; j++)\n\t\t\txa_store_index(xa, j, GFP_KERNEL);\n\t\t__check_store_iter(xa, 0, i, min);\n\t\tXA_BUG_ON(xa, !xa_empty(xa));\n\t\tfor (j = 0; j < min; j++)\n\t\t\txa_store_index(xa, min + j, GFP_KERNEL);\n\t\t__check_store_iter(xa, min, i, min);\n\t\tXA_BUG_ON(xa, !xa_empty(xa));\n\t}\n#ifdef CONFIG_XARRAY_MULTI\n\txa_store_index(xa, 63, GFP_KERNEL);\n\txa_store_index(xa, 65, GFP_KERNEL);\n\t__check_store_iter(xa, 64, 2, 1);\n\txa_erase_index(xa, 63);\n#endif\n\tXA_BUG_ON(xa, !xa_empty(xa));\n}\n\nstatic noinline void check_multi_find_1(struct xarray *xa, unsigned order)\n{\n#ifdef CONFIG_XARRAY_MULTI\n\tunsigned long multi = 3 << order;\n\tunsigned long next = 4 << order;\n\tunsigned long index;\n\n\txa_store_order(xa, multi, order, xa_mk_value(multi), GFP_KERNEL);\n\tXA_BUG_ON(xa, xa_store_index(xa, next, GFP_KERNEL) != NULL);\n\tXA_BUG_ON(xa, xa_store_index(xa, next + 1, GFP_KERNEL) != NULL);\n\n\tindex = 0;\n\tXA_BUG_ON(xa, xa_find(xa, &index, ULONG_MAX, XA_PRESENT) !=\n\t\t\txa_mk_value(multi));\n\tXA_BUG_ON(xa, index != multi);\n\tindex = multi + 1;\n\tXA_BUG_ON(xa, xa_find(xa, &index, ULONG_MAX, XA_PRESENT) !=\n\t\t\txa_mk_value(multi));\n\tXA_BUG_ON(xa, (index < multi) || (index >= next));\n\tXA_BUG_ON(xa, xa_find_after(xa, &index, ULONG_MAX, XA_PRESENT) !=\n\t\t\txa_mk_value(next));\n\tXA_BUG_ON(xa, index != next);\n\tXA_BUG_ON(xa, xa_find_after(xa, &index, next, XA_PRESENT) != NULL);\n\tXA_BUG_ON(xa, index != next);\n\n\txa_erase_index(xa, multi);\n\txa_erase_index(xa, next);\n\txa_erase_index(xa, next + 1);\n\tXA_BUG_ON(xa, !xa_empty(xa));\n#endif\n}\n\nstatic noinline void check_multi_find_2(struct xarray *xa)\n{\n\tunsigned int max_order = IS_ENABLED(CONFIG_XARRAY_MULTI) ? 10 : 1;\n\tunsigned int i, j;\n\tvoid *entry;\n\n\tfor (i = 0; i < max_order; i++) {\n\t\tunsigned long index = 1UL << i;\n\t\tfor (j = 0; j < index; j++) {\n\t\t\tXA_STATE(xas, xa, j + index);\n\t\t\txa_store_index(xa, index - 1, GFP_KERNEL);\n\t\t\txa_store_order(xa, index, i, xa_mk_index(index),\n\t\t\t\t\tGFP_KERNEL);\n\t\t\trcu_read_lock();\n\t\t\txas_for_each(&xas, entry, ULONG_MAX) {\n\t\t\t\txa_erase_index(xa, index);\n\t\t\t}\n\t\t\trcu_read_unlock();\n\t\t\txa_erase_index(xa, index - 1);\n\t\t\tXA_BUG_ON(xa, !xa_empty(xa));\n\t\t}\n\t}\n}\n\nstatic noinline void check_multi_find_3(struct xarray *xa)\n{\n\tunsigned int order;\n\n\tfor (order = 5; order < order_limit; order++) {\n\t\tunsigned long index = 1UL << (order - 5);\n\n\t\tXA_BUG_ON(xa, !xa_empty(xa));\n\t\txa_store_order(xa, 0, order - 4, xa_mk_index(0), GFP_KERNEL);\n\t\tXA_BUG_ON(xa, xa_find_after(xa, &index, ULONG_MAX, XA_PRESENT));\n\t\txa_erase_index(xa, 0);\n\t}\n}\n\nstatic noinline void check_find_1(struct xarray *xa)\n{\n\tunsigned long i, j, k;\n\n\tXA_BUG_ON(xa, !xa_empty(xa));\n\n\t \n\tfor (i = 0; i < 100; i++) {\n\t\tXA_BUG_ON(xa, xa_store_index(xa, i, GFP_KERNEL) != NULL);\n\t\txa_set_mark(xa, i, XA_MARK_0);\n\t\tfor (j = 0; j < i; j++) {\n\t\t\tXA_BUG_ON(xa, xa_store_index(xa, j, GFP_KERNEL) !=\n\t\t\t\t\tNULL);\n\t\t\txa_set_mark(xa, j, XA_MARK_0);\n\t\t\tfor (k = 0; k < 100; k++) {\n\t\t\t\tunsigned long index = k;\n\t\t\t\tvoid *entry = xa_find(xa, &index, ULONG_MAX,\n\t\t\t\t\t\t\t\tXA_PRESENT);\n\t\t\t\tif (k <= j)\n\t\t\t\t\tXA_BUG_ON(xa, index != j);\n\t\t\t\telse if (k <= i)\n\t\t\t\t\tXA_BUG_ON(xa, index != i);\n\t\t\t\telse\n\t\t\t\t\tXA_BUG_ON(xa, entry != NULL);\n\n\t\t\t\tindex = k;\n\t\t\t\tentry = xa_find(xa, &index, ULONG_MAX,\n\t\t\t\t\t\t\t\tXA_MARK_0);\n\t\t\t\tif (k <= j)\n\t\t\t\t\tXA_BUG_ON(xa, index != j);\n\t\t\t\telse if (k <= i)\n\t\t\t\t\tXA_BUG_ON(xa, index != i);\n\t\t\t\telse\n\t\t\t\t\tXA_BUG_ON(xa, entry != NULL);\n\t\t\t}\n\t\t\txa_erase_index(xa, j);\n\t\t\tXA_BUG_ON(xa, xa_get_mark(xa, j, XA_MARK_0));\n\t\t\tXA_BUG_ON(xa, !xa_get_mark(xa, i, XA_MARK_0));\n\t\t}\n\t\txa_erase_index(xa, i);\n\t\tXA_BUG_ON(xa, xa_get_mark(xa, i, XA_MARK_0));\n\t}\n\tXA_BUG_ON(xa, !xa_empty(xa));\n}\n\nstatic noinline void check_find_2(struct xarray *xa)\n{\n\tvoid *entry;\n\tunsigned long i, j, index;\n\n\txa_for_each(xa, index, entry) {\n\t\tXA_BUG_ON(xa, true);\n\t}\n\n\tfor (i = 0; i < 1024; i++) {\n\t\txa_store_index(xa, index, GFP_KERNEL);\n\t\tj = 0;\n\t\txa_for_each(xa, index, entry) {\n\t\t\tXA_BUG_ON(xa, xa_mk_index(index) != entry);\n\t\t\tXA_BUG_ON(xa, index != j++);\n\t\t}\n\t}\n\n\txa_destroy(xa);\n}\n\nstatic noinline void check_find_3(struct xarray *xa)\n{\n\tXA_STATE(xas, xa, 0);\n\tunsigned long i, j, k;\n\tvoid *entry;\n\n\tfor (i = 0; i < 100; i++) {\n\t\tfor (j = 0; j < 100; j++) {\n\t\t\trcu_read_lock();\n\t\t\tfor (k = 0; k < 100; k++) {\n\t\t\t\txas_set(&xas, j);\n\t\t\t\txas_for_each_marked(&xas, entry, k, XA_MARK_0)\n\t\t\t\t\t;\n\t\t\t\tif (j > k)\n\t\t\t\t\tXA_BUG_ON(xa,\n\t\t\t\t\t\txas.xa_node != XAS_RESTART);\n\t\t\t}\n\t\t\trcu_read_unlock();\n\t\t}\n\t\txa_store_index(xa, i, GFP_KERNEL);\n\t\txa_set_mark(xa, i, XA_MARK_0);\n\t}\n\txa_destroy(xa);\n}\n\nstatic noinline void check_find_4(struct xarray *xa)\n{\n\tunsigned long index = 0;\n\tvoid *entry;\n\n\txa_store_index(xa, ULONG_MAX, GFP_KERNEL);\n\n\tentry = xa_find_after(xa, &index, ULONG_MAX, XA_PRESENT);\n\tXA_BUG_ON(xa, entry != xa_mk_index(ULONG_MAX));\n\n\tentry = xa_find_after(xa, &index, ULONG_MAX, XA_PRESENT);\n\tXA_BUG_ON(xa, entry);\n\n\txa_erase_index(xa, ULONG_MAX);\n}\n\nstatic noinline void check_find(struct xarray *xa)\n{\n\tunsigned i;\n\n\tcheck_find_1(xa);\n\tcheck_find_2(xa);\n\tcheck_find_3(xa);\n\tcheck_find_4(xa);\n\n\tfor (i = 2; i < 10; i++)\n\t\tcheck_multi_find_1(xa, i);\n\tcheck_multi_find_2(xa);\n\tcheck_multi_find_3(xa);\n}\n\n \nstatic noinline unsigned long xa_find_entry(struct xarray *xa, void *item)\n{\n\tXA_STATE(xas, xa, 0);\n\tunsigned int checked = 0;\n\tvoid *entry;\n\n\trcu_read_lock();\n\txas_for_each(&xas, entry, ULONG_MAX) {\n\t\tif (xas_retry(&xas, entry))\n\t\t\tcontinue;\n\t\tif (entry == item)\n\t\t\tbreak;\n\t\tchecked++;\n\t\tif ((checked % 4) != 0)\n\t\t\tcontinue;\n\t\txas_pause(&xas);\n\t}\n\trcu_read_unlock();\n\n\treturn entry ? xas.xa_index : -1;\n}\n\nstatic noinline void check_find_entry(struct xarray *xa)\n{\n#ifdef CONFIG_XARRAY_MULTI\n\tunsigned int order;\n\tunsigned long offset, index;\n\n\tfor (order = 0; order < 20; order++) {\n\t\tfor (offset = 0; offset < (1UL << (order + 3));\n\t\t     offset += (1UL << order)) {\n\t\t\tfor (index = 0; index < (1UL << (order + 5));\n\t\t\t     index += (1UL << order)) {\n\t\t\t\txa_store_order(xa, index, order,\n\t\t\t\t\t\txa_mk_index(index), GFP_KERNEL);\n\t\t\t\tXA_BUG_ON(xa, xa_load(xa, index) !=\n\t\t\t\t\t\txa_mk_index(index));\n\t\t\t\tXA_BUG_ON(xa, xa_find_entry(xa,\n\t\t\t\t\t\txa_mk_index(index)) != index);\n\t\t\t}\n\t\t\tXA_BUG_ON(xa, xa_find_entry(xa, xa) != -1);\n\t\t\txa_destroy(xa);\n\t\t}\n\t}\n#endif\n\n\tXA_BUG_ON(xa, xa_find_entry(xa, xa) != -1);\n\txa_store_index(xa, ULONG_MAX, GFP_KERNEL);\n\tXA_BUG_ON(xa, xa_find_entry(xa, xa) != -1);\n\tXA_BUG_ON(xa, xa_find_entry(xa, xa_mk_index(ULONG_MAX)) != -1);\n\txa_erase_index(xa, ULONG_MAX);\n\tXA_BUG_ON(xa, !xa_empty(xa));\n}\n\nstatic noinline void check_pause(struct xarray *xa)\n{\n\tXA_STATE(xas, xa, 0);\n\tvoid *entry;\n\tunsigned int order;\n\tunsigned long index = 1;\n\tunsigned int count = 0;\n\n\tfor (order = 0; order < order_limit; order++) {\n\t\tXA_BUG_ON(xa, xa_store_order(xa, index, order,\n\t\t\t\t\txa_mk_index(index), GFP_KERNEL));\n\t\tindex += 1UL << order;\n\t}\n\n\trcu_read_lock();\n\txas_for_each(&xas, entry, ULONG_MAX) {\n\t\tXA_BUG_ON(xa, entry != xa_mk_index(1UL << count));\n\t\tcount++;\n\t}\n\trcu_read_unlock();\n\tXA_BUG_ON(xa, count != order_limit);\n\n\tcount = 0;\n\txas_set(&xas, 0);\n\trcu_read_lock();\n\txas_for_each(&xas, entry, ULONG_MAX) {\n\t\tXA_BUG_ON(xa, entry != xa_mk_index(1UL << count));\n\t\tcount++;\n\t\txas_pause(&xas);\n\t}\n\trcu_read_unlock();\n\tXA_BUG_ON(xa, count != order_limit);\n\n\txa_destroy(xa);\n}\n\nstatic noinline void check_move_tiny(struct xarray *xa)\n{\n\tXA_STATE(xas, xa, 0);\n\n\tXA_BUG_ON(xa, !xa_empty(xa));\n\trcu_read_lock();\n\tXA_BUG_ON(xa, xas_next(&xas) != NULL);\n\tXA_BUG_ON(xa, xas_next(&xas) != NULL);\n\trcu_read_unlock();\n\txa_store_index(xa, 0, GFP_KERNEL);\n\trcu_read_lock();\n\txas_set(&xas, 0);\n\tXA_BUG_ON(xa, xas_next(&xas) != xa_mk_index(0));\n\tXA_BUG_ON(xa, xas_next(&xas) != NULL);\n\txas_set(&xas, 0);\n\tXA_BUG_ON(xa, xas_prev(&xas) != xa_mk_index(0));\n\tXA_BUG_ON(xa, xas_prev(&xas) != NULL);\n\trcu_read_unlock();\n\txa_erase_index(xa, 0);\n\tXA_BUG_ON(xa, !xa_empty(xa));\n}\n\nstatic noinline void check_move_max(struct xarray *xa)\n{\n\tXA_STATE(xas, xa, 0);\n\n\txa_store_index(xa, ULONG_MAX, GFP_KERNEL);\n\trcu_read_lock();\n\tXA_BUG_ON(xa, xas_find(&xas, ULONG_MAX) != xa_mk_index(ULONG_MAX));\n\tXA_BUG_ON(xa, xas_find(&xas, ULONG_MAX) != NULL);\n\trcu_read_unlock();\n\n\txas_set(&xas, 0);\n\trcu_read_lock();\n\tXA_BUG_ON(xa, xas_find(&xas, ULONG_MAX) != xa_mk_index(ULONG_MAX));\n\txas_pause(&xas);\n\tXA_BUG_ON(xa, xas_find(&xas, ULONG_MAX) != NULL);\n\trcu_read_unlock();\n\n\txa_erase_index(xa, ULONG_MAX);\n\tXA_BUG_ON(xa, !xa_empty(xa));\n}\n\nstatic noinline void check_move_small(struct xarray *xa, unsigned long idx)\n{\n\tXA_STATE(xas, xa, 0);\n\tunsigned long i;\n\n\txa_store_index(xa, 0, GFP_KERNEL);\n\txa_store_index(xa, idx, GFP_KERNEL);\n\n\trcu_read_lock();\n\tfor (i = 0; i < idx * 4; i++) {\n\t\tvoid *entry = xas_next(&xas);\n\t\tif (i <= idx)\n\t\t\tXA_BUG_ON(xa, xas.xa_node == XAS_RESTART);\n\t\tXA_BUG_ON(xa, xas.xa_index != i);\n\t\tif (i == 0 || i == idx)\n\t\t\tXA_BUG_ON(xa, entry != xa_mk_index(i));\n\t\telse\n\t\t\tXA_BUG_ON(xa, entry != NULL);\n\t}\n\txas_next(&xas);\n\tXA_BUG_ON(xa, xas.xa_index != i);\n\n\tdo {\n\t\tvoid *entry = xas_prev(&xas);\n\t\ti--;\n\t\tif (i <= idx)\n\t\t\tXA_BUG_ON(xa, xas.xa_node == XAS_RESTART);\n\t\tXA_BUG_ON(xa, xas.xa_index != i);\n\t\tif (i == 0 || i == idx)\n\t\t\tXA_BUG_ON(xa, entry != xa_mk_index(i));\n\t\telse\n\t\t\tXA_BUG_ON(xa, entry != NULL);\n\t} while (i > 0);\n\n\txas_set(&xas, ULONG_MAX);\n\tXA_BUG_ON(xa, xas_next(&xas) != NULL);\n\tXA_BUG_ON(xa, xas.xa_index != ULONG_MAX);\n\tXA_BUG_ON(xa, xas_next(&xas) != xa_mk_value(0));\n\tXA_BUG_ON(xa, xas.xa_index != 0);\n\tXA_BUG_ON(xa, xas_prev(&xas) != NULL);\n\tXA_BUG_ON(xa, xas.xa_index != ULONG_MAX);\n\trcu_read_unlock();\n\n\txa_erase_index(xa, 0);\n\txa_erase_index(xa, idx);\n\tXA_BUG_ON(xa, !xa_empty(xa));\n}\n\nstatic noinline void check_move(struct xarray *xa)\n{\n\tXA_STATE(xas, xa, (1 << 16) - 1);\n\tunsigned long i;\n\n\tfor (i = 0; i < (1 << 16); i++)\n\t\tXA_BUG_ON(xa, xa_store_index(xa, i, GFP_KERNEL) != NULL);\n\n\trcu_read_lock();\n\tdo {\n\t\tvoid *entry = xas_prev(&xas);\n\t\ti--;\n\t\tXA_BUG_ON(xa, entry != xa_mk_index(i));\n\t\tXA_BUG_ON(xa, i != xas.xa_index);\n\t} while (i != 0);\n\n\tXA_BUG_ON(xa, xas_prev(&xas) != NULL);\n\tXA_BUG_ON(xa, xas.xa_index != ULONG_MAX);\n\n\tdo {\n\t\tvoid *entry = xas_next(&xas);\n\t\tXA_BUG_ON(xa, entry != xa_mk_index(i));\n\t\tXA_BUG_ON(xa, i != xas.xa_index);\n\t\ti++;\n\t} while (i < (1 << 16));\n\trcu_read_unlock();\n\n\tfor (i = (1 << 8); i < (1 << 15); i++)\n\t\txa_erase_index(xa, i);\n\n\ti = xas.xa_index;\n\n\trcu_read_lock();\n\tdo {\n\t\tvoid *entry = xas_prev(&xas);\n\t\ti--;\n\t\tif ((i < (1 << 8)) || (i >= (1 << 15)))\n\t\t\tXA_BUG_ON(xa, entry != xa_mk_index(i));\n\t\telse\n\t\t\tXA_BUG_ON(xa, entry != NULL);\n\t\tXA_BUG_ON(xa, i != xas.xa_index);\n\t} while (i != 0);\n\n\tXA_BUG_ON(xa, xas_prev(&xas) != NULL);\n\tXA_BUG_ON(xa, xas.xa_index != ULONG_MAX);\n\n\tdo {\n\t\tvoid *entry = xas_next(&xas);\n\t\tif ((i < (1 << 8)) || (i >= (1 << 15)))\n\t\t\tXA_BUG_ON(xa, entry != xa_mk_index(i));\n\t\telse\n\t\t\tXA_BUG_ON(xa, entry != NULL);\n\t\tXA_BUG_ON(xa, i != xas.xa_index);\n\t\ti++;\n\t} while (i < (1 << 16));\n\trcu_read_unlock();\n\n\txa_destroy(xa);\n\n\tcheck_move_tiny(xa);\n\tcheck_move_max(xa);\n\n\tfor (i = 0; i < 16; i++)\n\t\tcheck_move_small(xa, 1UL << i);\n\n\tfor (i = 2; i < 16; i++)\n\t\tcheck_move_small(xa, (1UL << i) - 1);\n}\n\nstatic noinline void xa_store_many_order(struct xarray *xa,\n\t\tunsigned long index, unsigned order)\n{\n\tXA_STATE_ORDER(xas, xa, index, order);\n\tunsigned int i = 0;\n\n\tdo {\n\t\txas_lock(&xas);\n\t\tXA_BUG_ON(xa, xas_find_conflict(&xas));\n\t\txas_create_range(&xas);\n\t\tif (xas_error(&xas))\n\t\t\tgoto unlock;\n\t\tfor (i = 0; i < (1U << order); i++) {\n\t\t\tXA_BUG_ON(xa, xas_store(&xas, xa_mk_index(index + i)));\n\t\t\txas_next(&xas);\n\t\t}\nunlock:\n\t\txas_unlock(&xas);\n\t} while (xas_nomem(&xas, GFP_KERNEL));\n\n\tXA_BUG_ON(xa, xas_error(&xas));\n}\n\nstatic noinline void check_create_range_1(struct xarray *xa,\n\t\tunsigned long index, unsigned order)\n{\n\tunsigned long i;\n\n\txa_store_many_order(xa, index, order);\n\tfor (i = index; i < index + (1UL << order); i++)\n\t\txa_erase_index(xa, i);\n\tXA_BUG_ON(xa, !xa_empty(xa));\n}\n\nstatic noinline void check_create_range_2(struct xarray *xa, unsigned order)\n{\n\tunsigned long i;\n\tunsigned long nr = 1UL << order;\n\n\tfor (i = 0; i < nr * nr; i += nr)\n\t\txa_store_many_order(xa, i, order);\n\tfor (i = 0; i < nr * nr; i++)\n\t\txa_erase_index(xa, i);\n\tXA_BUG_ON(xa, !xa_empty(xa));\n}\n\nstatic noinline void check_create_range_3(void)\n{\n\tXA_STATE(xas, NULL, 0);\n\txas_set_err(&xas, -EEXIST);\n\txas_create_range(&xas);\n\tXA_BUG_ON(NULL, xas_error(&xas) != -EEXIST);\n}\n\nstatic noinline void check_create_range_4(struct xarray *xa,\n\t\tunsigned long index, unsigned order)\n{\n\tXA_STATE_ORDER(xas, xa, index, order);\n\tunsigned long base = xas.xa_index;\n\tunsigned long i = 0;\n\n\txa_store_index(xa, index, GFP_KERNEL);\n\tdo {\n\t\txas_lock(&xas);\n\t\txas_create_range(&xas);\n\t\tif (xas_error(&xas))\n\t\t\tgoto unlock;\n\t\tfor (i = 0; i < (1UL << order); i++) {\n\t\t\tvoid *old = xas_store(&xas, xa_mk_index(base + i));\n\t\t\tif (xas.xa_index == index)\n\t\t\t\tXA_BUG_ON(xa, old != xa_mk_index(base + i));\n\t\t\telse\n\t\t\t\tXA_BUG_ON(xa, old != NULL);\n\t\t\txas_next(&xas);\n\t\t}\nunlock:\n\t\txas_unlock(&xas);\n\t} while (xas_nomem(&xas, GFP_KERNEL));\n\n\tXA_BUG_ON(xa, xas_error(&xas));\n\n\tfor (i = base; i < base + (1UL << order); i++)\n\t\txa_erase_index(xa, i);\n\tXA_BUG_ON(xa, !xa_empty(xa));\n}\n\nstatic noinline void check_create_range_5(struct xarray *xa,\n\t\tunsigned long index, unsigned int order)\n{\n\tXA_STATE_ORDER(xas, xa, index, order);\n\tunsigned int i;\n\n\txa_store_order(xa, index, order, xa_mk_index(index), GFP_KERNEL);\n\n\tfor (i = 0; i < order + 10; i++) {\n\t\tdo {\n\t\t\txas_lock(&xas);\n\t\t\txas_create_range(&xas);\n\t\t\txas_unlock(&xas);\n\t\t} while (xas_nomem(&xas, GFP_KERNEL));\n\t}\n\n\txa_destroy(xa);\n}\n\nstatic noinline void check_create_range(struct xarray *xa)\n{\n\tunsigned int order;\n\tunsigned int max_order = IS_ENABLED(CONFIG_XARRAY_MULTI) ? 12 : 1;\n\n\tfor (order = 0; order < max_order; order++) {\n\t\tcheck_create_range_1(xa, 0, order);\n\t\tcheck_create_range_1(xa, 1U << order, order);\n\t\tcheck_create_range_1(xa, 2U << order, order);\n\t\tcheck_create_range_1(xa, 3U << order, order);\n\t\tcheck_create_range_1(xa, 1U << 24, order);\n\t\tif (order < 10)\n\t\t\tcheck_create_range_2(xa, order);\n\n\t\tcheck_create_range_4(xa, 0, order);\n\t\tcheck_create_range_4(xa, 1U << order, order);\n\t\tcheck_create_range_4(xa, 2U << order, order);\n\t\tcheck_create_range_4(xa, 3U << order, order);\n\t\tcheck_create_range_4(xa, 1U << 24, order);\n\n\t\tcheck_create_range_4(xa, 1, order);\n\t\tcheck_create_range_4(xa, (1U << order) + 1, order);\n\t\tcheck_create_range_4(xa, (2U << order) + 1, order);\n\t\tcheck_create_range_4(xa, (2U << order) - 1, order);\n\t\tcheck_create_range_4(xa, (3U << order) + 1, order);\n\t\tcheck_create_range_4(xa, (3U << order) - 1, order);\n\t\tcheck_create_range_4(xa, (1U << 24) + 1, order);\n\n\t\tcheck_create_range_5(xa, 0, order);\n\t\tcheck_create_range_5(xa, (1U << order), order);\n\t}\n\n\tcheck_create_range_3();\n}\n\nstatic noinline void __check_store_range(struct xarray *xa, unsigned long first,\n\t\tunsigned long last)\n{\n#ifdef CONFIG_XARRAY_MULTI\n\txa_store_range(xa, first, last, xa_mk_index(first), GFP_KERNEL);\n\n\tXA_BUG_ON(xa, xa_load(xa, first) != xa_mk_index(first));\n\tXA_BUG_ON(xa, xa_load(xa, last) != xa_mk_index(first));\n\tXA_BUG_ON(xa, xa_load(xa, first - 1) != NULL);\n\tXA_BUG_ON(xa, xa_load(xa, last + 1) != NULL);\n\n\txa_store_range(xa, first, last, NULL, GFP_KERNEL);\n#endif\n\n\tXA_BUG_ON(xa, !xa_empty(xa));\n}\n\nstatic noinline void check_store_range(struct xarray *xa)\n{\n\tunsigned long i, j;\n\n\tfor (i = 0; i < 128; i++) {\n\t\tfor (j = i; j < 128; j++) {\n\t\t\t__check_store_range(xa, i, j);\n\t\t\t__check_store_range(xa, 128 + i, 128 + j);\n\t\t\t__check_store_range(xa, 4095 + i, 4095 + j);\n\t\t\t__check_store_range(xa, 4096 + i, 4096 + j);\n\t\t\t__check_store_range(xa, 123456 + i, 123456 + j);\n\t\t\t__check_store_range(xa, (1 << 24) + i, (1 << 24) + j);\n\t\t}\n\t}\n}\n\n#ifdef CONFIG_XARRAY_MULTI\nstatic void check_split_1(struct xarray *xa, unsigned long index,\n\t\t\t\tunsigned int order, unsigned int new_order)\n{\n\tXA_STATE_ORDER(xas, xa, index, new_order);\n\tunsigned int i;\n\n\txa_store_order(xa, index, order, xa, GFP_KERNEL);\n\n\txas_split_alloc(&xas, xa, order, GFP_KERNEL);\n\txas_lock(&xas);\n\txas_split(&xas, xa, order);\n\tfor (i = 0; i < (1 << order); i += (1 << new_order))\n\t\t__xa_store(xa, index + i, xa_mk_index(index + i), 0);\n\txas_unlock(&xas);\n\n\tfor (i = 0; i < (1 << order); i++) {\n\t\tunsigned int val = index + (i & ~((1 << new_order) - 1));\n\t\tXA_BUG_ON(xa, xa_load(xa, index + i) != xa_mk_index(val));\n\t}\n\n\txa_set_mark(xa, index, XA_MARK_0);\n\tXA_BUG_ON(xa, !xa_get_mark(xa, index, XA_MARK_0));\n\n\txa_destroy(xa);\n}\n\nstatic noinline void check_split(struct xarray *xa)\n{\n\tunsigned int order, new_order;\n\n\tXA_BUG_ON(xa, !xa_empty(xa));\n\n\tfor (order = 1; order < 2 * XA_CHUNK_SHIFT; order++) {\n\t\tfor (new_order = 0; new_order < order; new_order++) {\n\t\t\tcheck_split_1(xa, 0, order, new_order);\n\t\t\tcheck_split_1(xa, 1UL << order, order, new_order);\n\t\t\tcheck_split_1(xa, 3UL << order, order, new_order);\n\t\t}\n\t}\n}\n#else\nstatic void check_split(struct xarray *xa) { }\n#endif\n\nstatic void check_align_1(struct xarray *xa, char *name)\n{\n\tint i;\n\tunsigned int id;\n\tunsigned long index;\n\tvoid *entry;\n\n\tfor (i = 0; i < 8; i++) {\n\t\tXA_BUG_ON(xa, xa_alloc(xa, &id, name + i, xa_limit_32b,\n\t\t\t\t\tGFP_KERNEL) != 0);\n\t\tXA_BUG_ON(xa, id != i);\n\t}\n\txa_for_each(xa, index, entry)\n\t\tXA_BUG_ON(xa, xa_is_err(entry));\n\txa_destroy(xa);\n}\n\n \nstatic void check_align_2(struct xarray *xa, char *name)\n{\n\tint i;\n\n\tXA_BUG_ON(xa, !xa_empty(xa));\n\n\tfor (i = 0; i < 8; i++) {\n\t\tXA_BUG_ON(xa, xa_store(xa, 0, name + i, GFP_KERNEL) != NULL);\n\t\txa_erase(xa, 0);\n\t}\n\n\tfor (i = 0; i < 8; i++) {\n\t\tXA_BUG_ON(xa, xa_reserve(xa, 0, GFP_KERNEL) != 0);\n\t\tXA_BUG_ON(xa, xa_store(xa, 0, name + i, 0) != NULL);\n\t\txa_erase(xa, 0);\n\t}\n\n\tXA_BUG_ON(xa, !xa_empty(xa));\n}\n\nstatic noinline void check_align(struct xarray *xa)\n{\n\tchar name[] = \"Motorola 68000\";\n\n\tcheck_align_1(xa, name);\n\tcheck_align_1(xa, name + 1);\n\tcheck_align_1(xa, name + 2);\n\tcheck_align_1(xa, name + 3);\n\tcheck_align_2(xa, name);\n}\n\nstatic LIST_HEAD(shadow_nodes);\n\nstatic void test_update_node(struct xa_node *node)\n{\n\tif (node->count && node->count == node->nr_values) {\n\t\tif (list_empty(&node->private_list))\n\t\t\tlist_add(&shadow_nodes, &node->private_list);\n\t} else {\n\t\tif (!list_empty(&node->private_list))\n\t\t\tlist_del_init(&node->private_list);\n\t}\n}\n\nstatic noinline void shadow_remove(struct xarray *xa)\n{\n\tstruct xa_node *node;\n\n\txa_lock(xa);\n\twhile ((node = list_first_entry_or_null(&shadow_nodes,\n\t\t\t\t\tstruct xa_node, private_list))) {\n\t\tXA_BUG_ON(xa, node->array != xa);\n\t\tlist_del_init(&node->private_list);\n\t\txa_delete_node(node, test_update_node);\n\t}\n\txa_unlock(xa);\n}\n\nstatic noinline void check_workingset(struct xarray *xa, unsigned long index)\n{\n\tXA_STATE(xas, xa, index);\n\txas_set_update(&xas, test_update_node);\n\n\tdo {\n\t\txas_lock(&xas);\n\t\txas_store(&xas, xa_mk_value(0));\n\t\txas_next(&xas);\n\t\txas_store(&xas, xa_mk_value(1));\n\t\txas_unlock(&xas);\n\t} while (xas_nomem(&xas, GFP_KERNEL));\n\n\tXA_BUG_ON(xa, list_empty(&shadow_nodes));\n\n\txas_lock(&xas);\n\txas_next(&xas);\n\txas_store(&xas, &xas);\n\tXA_BUG_ON(xa, !list_empty(&shadow_nodes));\n\n\txas_store(&xas, xa_mk_value(2));\n\txas_unlock(&xas);\n\tXA_BUG_ON(xa, list_empty(&shadow_nodes));\n\n\tshadow_remove(xa);\n\tXA_BUG_ON(xa, !list_empty(&shadow_nodes));\n\tXA_BUG_ON(xa, !xa_empty(xa));\n}\n\n \nstatic noinline void check_account(struct xarray *xa)\n{\n#ifdef CONFIG_XARRAY_MULTI\n\tunsigned int order;\n\n\tfor (order = 1; order < 12; order++) {\n\t\tXA_STATE(xas, xa, 1 << order);\n\n\t\txa_store_order(xa, 0, order, xa, GFP_KERNEL);\n\t\trcu_read_lock();\n\t\txas_load(&xas);\n\t\tXA_BUG_ON(xa, xas.xa_node->count == 0);\n\t\tXA_BUG_ON(xa, xas.xa_node->count > (1 << order));\n\t\tXA_BUG_ON(xa, xas.xa_node->nr_values != 0);\n\t\trcu_read_unlock();\n\n\t\txa_store_order(xa, 1 << order, order, xa_mk_index(1UL << order),\n\t\t\t\tGFP_KERNEL);\n\t\tXA_BUG_ON(xa, xas.xa_node->count != xas.xa_node->nr_values * 2);\n\n\t\txa_erase(xa, 1 << order);\n\t\tXA_BUG_ON(xa, xas.xa_node->nr_values != 0);\n\n\t\txa_erase(xa, 0);\n\t\tXA_BUG_ON(xa, !xa_empty(xa));\n\t}\n#endif\n}\n\nstatic noinline void check_get_order(struct xarray *xa)\n{\n\tunsigned int max_order = IS_ENABLED(CONFIG_XARRAY_MULTI) ? 20 : 1;\n\tunsigned int order;\n\tunsigned long i, j;\n\n\tfor (i = 0; i < 3; i++)\n\t\tXA_BUG_ON(xa, xa_get_order(xa, i) != 0);\n\n\tfor (order = 0; order < max_order; order++) {\n\t\tfor (i = 0; i < 10; i++) {\n\t\t\txa_store_order(xa, i << order, order,\n\t\t\t\t\txa_mk_index(i << order), GFP_KERNEL);\n\t\t\tfor (j = i << order; j < (i + 1) << order; j++)\n\t\t\t\tXA_BUG_ON(xa, xa_get_order(xa, j) != order);\n\t\t\txa_erase(xa, i << order);\n\t\t}\n\t}\n}\n\nstatic noinline void check_destroy(struct xarray *xa)\n{\n\tunsigned long index;\n\n\tXA_BUG_ON(xa, !xa_empty(xa));\n\n\t \n\txa_destroy(xa);\n\tXA_BUG_ON(xa, !xa_empty(xa));\n\n\t \n\tfor (index = 0; index < 1000; index++) {\n\t\txa_store_index(xa, index, GFP_KERNEL);\n\t\tXA_BUG_ON(xa, xa_empty(xa));\n\t\txa_destroy(xa);\n\t\tXA_BUG_ON(xa, !xa_empty(xa));\n\t}\n\n\t \n\txa_store(xa, ULONG_MAX, xa, GFP_KERNEL);\n\tXA_BUG_ON(xa, xa_empty(xa));\n\txa_destroy(xa);\n\tXA_BUG_ON(xa, !xa_empty(xa));\n\n#ifdef CONFIG_XARRAY_MULTI\n\t \n\txa_store_order(xa, 1 << 11, 11, xa, GFP_KERNEL);\n\tXA_BUG_ON(xa, xa_empty(xa));\n\txa_destroy(xa);\n\tXA_BUG_ON(xa, !xa_empty(xa));\n#endif\n}\n\nstatic DEFINE_XARRAY(array);\n\nstatic int xarray_checks(void)\n{\n\tcheck_xa_err(&array);\n\tcheck_xas_retry(&array);\n\tcheck_xa_load(&array);\n\tcheck_xa_mark(&array);\n\tcheck_xa_shrink(&array);\n\tcheck_xas_erase(&array);\n\tcheck_insert(&array);\n\tcheck_cmpxchg(&array);\n\tcheck_reserve(&array);\n\tcheck_reserve(&xa0);\n\tcheck_multi_store(&array);\n\tcheck_get_order(&array);\n\tcheck_xa_alloc();\n\tcheck_find(&array);\n\tcheck_find_entry(&array);\n\tcheck_pause(&array);\n\tcheck_account(&array);\n\tcheck_destroy(&array);\n\tcheck_move(&array);\n\tcheck_create_range(&array);\n\tcheck_store_range(&array);\n\tcheck_store_iter(&array);\n\tcheck_align(&xa0);\n\tcheck_split(&array);\n\n\tcheck_workingset(&array, 0);\n\tcheck_workingset(&array, 64);\n\tcheck_workingset(&array, 4096);\n\n\tprintk(\"XArray: %u of %u tests passed\\n\", tests_passed, tests_run);\n\treturn (tests_run == tests_passed) ? 0 : -EINVAL;\n}\n\nstatic void xarray_exit(void)\n{\n}\n\nmodule_init(xarray_checks);\nmodule_exit(xarray_exit);\nMODULE_AUTHOR(\"Matthew Wilcox <willy@infradead.org>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}