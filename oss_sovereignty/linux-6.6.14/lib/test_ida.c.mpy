{
  "module_name": "test_ida.c",
  "hash_id": "c72f2789bc3253a507f8feafdf29aa04fd0393304fb8ed2e4434a11b6e7c1fc8",
  "original_prompt": "Ingested from linux-6.6.14/lib/test_ida.c",
  "human_readable_source": "\n \n\n#include <linux/idr.h>\n#include <linux/module.h>\n\nstatic unsigned int tests_run;\nstatic unsigned int tests_passed;\n\n#ifdef __KERNEL__\nvoid ida_dump(struct ida *ida) { }\n#endif\n#define IDA_BUG_ON(ida, x) do {\t\t\t\t\t\t\\\n\ttests_run++;\t\t\t\t\t\t\t\\\n\tif (x) {\t\t\t\t\t\t\t\\\n\t\tida_dump(ida);\t\t\t\t\t\t\\\n\t\tdump_stack();\t\t\t\t\t\t\\\n\t} else {\t\t\t\t\t\t\t\\\n\t\ttests_passed++;\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n} while (0)\n\n \nstatic void ida_check_alloc(struct ida *ida)\n{\n\tint i, id;\n\n\tfor (i = 0; i < 10000; i++)\n\t\tIDA_BUG_ON(ida, ida_alloc(ida, GFP_KERNEL) != i);\n\n\tida_free(ida, 20);\n\tida_free(ida, 21);\n\tfor (i = 0; i < 3; i++) {\n\t\tid = ida_alloc(ida, GFP_KERNEL);\n\t\tIDA_BUG_ON(ida, id < 0);\n\t\tif (i == 2)\n\t\t\tIDA_BUG_ON(ida, id != 10000);\n\t}\n\n\tfor (i = 0; i < 5000; i++)\n\t\tida_free(ida, i);\n\n\tIDA_BUG_ON(ida, ida_alloc_min(ida, 5000, GFP_KERNEL) != 10001);\n\tida_destroy(ida);\n\n\tIDA_BUG_ON(ida, !ida_is_empty(ida));\n}\n\n \nstatic void ida_check_destroy_1(struct ida *ida, unsigned int base)\n{\n\tIDA_BUG_ON(ida, ida_alloc_min(ida, base, GFP_KERNEL) != base);\n\tIDA_BUG_ON(ida, ida_is_empty(ida));\n\tida_destroy(ida);\n\tIDA_BUG_ON(ida, !ida_is_empty(ida));\n}\n\n \nstatic void ida_check_destroy(struct ida *ida)\n{\n\t \n\tIDA_BUG_ON(ida, !ida_is_empty(ida));\n\tida_destroy(ida);\n\tIDA_BUG_ON(ida, !ida_is_empty(ida));\n\n\tida_check_destroy_1(ida, 0);\n\tida_check_destroy_1(ida, 1);\n\tida_check_destroy_1(ida, 1023);\n\tida_check_destroy_1(ida, 1024);\n\tida_check_destroy_1(ida, 12345678);\n}\n\n \nstatic void ida_check_leaf(struct ida *ida, unsigned int base)\n{\n\tunsigned long i;\n\n\tfor (i = 0; i < IDA_BITMAP_BITS; i++) {\n\t\tIDA_BUG_ON(ida, ida_alloc_min(ida, base, GFP_KERNEL) !=\n\t\t\t\tbase + i);\n\t}\n\n\tida_destroy(ida);\n\tIDA_BUG_ON(ida, !ida_is_empty(ida));\n\n\tIDA_BUG_ON(ida, ida_alloc(ida, GFP_KERNEL) != 0);\n\tIDA_BUG_ON(ida, ida_is_empty(ida));\n\tida_free(ida, 0);\n\tIDA_BUG_ON(ida, !ida_is_empty(ida));\n}\n\n \nstatic void ida_check_max(struct ida *ida)\n{\n\tunsigned long i, j;\n\n\tfor (j = 1; j < 65537; j *= 2) {\n\t\tunsigned long base = (1UL << 31) - j;\n\t\tfor (i = 0; i < j; i++) {\n\t\t\tIDA_BUG_ON(ida, ida_alloc_min(ida, base, GFP_KERNEL) !=\n\t\t\t\t\tbase + i);\n\t\t}\n\t\tIDA_BUG_ON(ida, ida_alloc_min(ida, base, GFP_KERNEL) !=\n\t\t\t\t-ENOSPC);\n\t\tida_destroy(ida);\n\t\tIDA_BUG_ON(ida, !ida_is_empty(ida));\n\t}\n}\n\n \nstatic void ida_check_conv(struct ida *ida)\n{\n\tunsigned long i;\n\n\tfor (i = 0; i < IDA_BITMAP_BITS * 2; i += IDA_BITMAP_BITS) {\n\t\tIDA_BUG_ON(ida, ida_alloc_min(ida, i + 1, GFP_KERNEL) != i + 1);\n\t\tIDA_BUG_ON(ida, ida_alloc_min(ida, i + BITS_PER_LONG,\n\t\t\t\t\tGFP_KERNEL) != i + BITS_PER_LONG);\n\t\tida_free(ida, i + 1);\n\t\tida_free(ida, i + BITS_PER_LONG);\n\t\tIDA_BUG_ON(ida, !ida_is_empty(ida));\n\t}\n\n\tfor (i = 0; i < IDA_BITMAP_BITS * 2; i++)\n\t\tIDA_BUG_ON(ida, ida_alloc(ida, GFP_KERNEL) != i);\n\tfor (i = IDA_BITMAP_BITS * 2; i > 0; i--)\n\t\tida_free(ida, i - 1);\n\tIDA_BUG_ON(ida, !ida_is_empty(ida));\n\n\tfor (i = 0; i < IDA_BITMAP_BITS + BITS_PER_LONG - 4; i++)\n\t\tIDA_BUG_ON(ida, ida_alloc(ida, GFP_KERNEL) != i);\n\tfor (i = IDA_BITMAP_BITS + BITS_PER_LONG - 4; i > 0; i--)\n\t\tida_free(ida, i - 1);\n\tIDA_BUG_ON(ida, !ida_is_empty(ida));\n}\n\n \nstatic void ida_check_bad_free(struct ida *ida)\n{\n\tunsigned long i;\n\n\tprintk(\"vvv Ignore \\\"not allocated\\\" warnings\\n\");\n\t \n\tida_free(ida, 0);\n\tfor (i = 0; i < 31; i++)\n\t\tida_free(ida, 1 << i);\n\n\t \n\tIDA_BUG_ON(ida, ida_alloc_min(ida, 3, GFP_KERNEL) != 3);\n\tida_free(ida, 0);\n\tfor (i = 0; i < 31; i++)\n\t\tida_free(ida, 1 << i);\n\n\t \n\tIDA_BUG_ON(ida, ida_alloc_min(ida, 1023, GFP_KERNEL) != 1023);\n\tida_free(ida, 0);\n\tfor (i = 0; i < 31; i++)\n\t\tida_free(ida, 1 << i);\n\n\t \n\tIDA_BUG_ON(ida, ida_alloc_min(ida, (1 << 20) - 1, GFP_KERNEL) != (1 << 20) - 1);\n\tida_free(ida, 0);\n\tfor (i = 0; i < 31; i++)\n\t\tida_free(ida, 1 << i);\n\tprintk(\"^^^ \\\"not allocated\\\" warnings over\\n\");\n\n\tida_free(ida, 3);\n\tida_free(ida, 1023);\n\tida_free(ida, (1 << 20) - 1);\n\n\tIDA_BUG_ON(ida, !ida_is_empty(ida));\n}\n\nstatic DEFINE_IDA(ida);\n\nstatic int ida_checks(void)\n{\n\tIDA_BUG_ON(&ida, !ida_is_empty(&ida));\n\tida_check_alloc(&ida);\n\tida_check_destroy(&ida);\n\tida_check_leaf(&ida, 0);\n\tida_check_leaf(&ida, 1024);\n\tida_check_leaf(&ida, 1024 * 64);\n\tida_check_max(&ida);\n\tida_check_conv(&ida);\n\tida_check_bad_free(&ida);\n\n\tprintk(\"IDA: %u of %u tests passed\\n\", tests_passed, tests_run);\n\treturn (tests_run != tests_passed) ? 0 : -EINVAL;\n}\n\nstatic void ida_exit(void)\n{\n}\n\nmodule_init(ida_checks);\nmodule_exit(ida_exit);\nMODULE_AUTHOR(\"Matthew Wilcox <willy@infradead.org>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}