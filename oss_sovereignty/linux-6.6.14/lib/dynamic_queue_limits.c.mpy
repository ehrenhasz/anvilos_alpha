{
  "module_name": "dynamic_queue_limits.c",
  "hash_id": "8b9959d24de9f23365ec6d377bd146fee2593bc067651d5f2998d0077cface94",
  "original_prompt": "Ingested from linux-6.6.14/lib/dynamic_queue_limits.c",
  "human_readable_source": "\n \n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/jiffies.h>\n#include <linux/dynamic_queue_limits.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\n#define POSDIFF(A, B) ((int)((A) - (B)) > 0 ? (A) - (B) : 0)\n#define AFTER_EQ(A, B) ((int)((A) - (B)) >= 0)\n\n \nvoid dql_completed(struct dql *dql, unsigned int count)\n{\n\tunsigned int inprogress, prev_inprogress, limit;\n\tunsigned int ovlimit, completed, num_queued;\n\tbool all_prev_completed;\n\n\tnum_queued = READ_ONCE(dql->num_queued);\n\n\t \n\tBUG_ON(count > num_queued - dql->num_completed);\n\n\tcompleted = dql->num_completed + count;\n\tlimit = dql->limit;\n\tovlimit = POSDIFF(num_queued - dql->num_completed, limit);\n\tinprogress = num_queued - completed;\n\tprev_inprogress = dql->prev_num_queued - dql->num_completed;\n\tall_prev_completed = AFTER_EQ(completed, dql->prev_num_queued);\n\n\tif ((ovlimit && !inprogress) ||\n\t    (dql->prev_ovlimit && all_prev_completed)) {\n\t\t \n\t\tlimit += POSDIFF(completed, dql->prev_num_queued) +\n\t\t     dql->prev_ovlimit;\n\t\tdql->slack_start_time = jiffies;\n\t\tdql->lowest_slack = UINT_MAX;\n\t} else if (inprogress && prev_inprogress && !all_prev_completed) {\n\t\t \n\t\tunsigned int slack, slack_last_objs;\n\n\t\t \n\t\tslack = POSDIFF(limit + dql->prev_ovlimit,\n\t\t    2 * (completed - dql->num_completed));\n\t\tslack_last_objs = dql->prev_ovlimit ?\n\t\t    POSDIFF(dql->prev_last_obj_cnt, dql->prev_ovlimit) : 0;\n\n\t\tslack = max(slack, slack_last_objs);\n\n\t\tif (slack < dql->lowest_slack)\n\t\t\tdql->lowest_slack = slack;\n\n\t\tif (time_after(jiffies,\n\t\t\t       dql->slack_start_time + dql->slack_hold_time)) {\n\t\t\tlimit = POSDIFF(limit, dql->lowest_slack);\n\t\t\tdql->slack_start_time = jiffies;\n\t\t\tdql->lowest_slack = UINT_MAX;\n\t\t}\n\t}\n\n\t \n\tlimit = clamp(limit, dql->min_limit, dql->max_limit);\n\n\tif (limit != dql->limit) {\n\t\tdql->limit = limit;\n\t\tovlimit = 0;\n\t}\n\n\tdql->adj_limit = limit + completed;\n\tdql->prev_ovlimit = ovlimit;\n\tdql->prev_last_obj_cnt = dql->last_obj_cnt;\n\tdql->num_completed = completed;\n\tdql->prev_num_queued = num_queued;\n}\nEXPORT_SYMBOL(dql_completed);\n\nvoid dql_reset(struct dql *dql)\n{\n\t \n\tdql->limit = 0;\n\tdql->num_queued = 0;\n\tdql->num_completed = 0;\n\tdql->last_obj_cnt = 0;\n\tdql->prev_num_queued = 0;\n\tdql->prev_last_obj_cnt = 0;\n\tdql->prev_ovlimit = 0;\n\tdql->lowest_slack = UINT_MAX;\n\tdql->slack_start_time = jiffies;\n}\nEXPORT_SYMBOL(dql_reset);\n\nvoid dql_init(struct dql *dql, unsigned int hold_time)\n{\n\tdql->max_limit = DQL_MAX_LIMIT;\n\tdql->min_limit = 0;\n\tdql->slack_hold_time = hold_time;\n\tdql_reset(dql);\n}\nEXPORT_SYMBOL(dql_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}