{
  "module_name": "decompress_unxz.c",
  "hash_id": "554b8d6489a15035fe6fe3cbaeb3eb504d6ada12e849dc89f9bc8f1bbed2254b",
  "original_prompt": "Ingested from linux-6.6.14/lib/decompress_unxz.c",
  "human_readable_source": " \n\n \n\n \n#ifdef STATIC\n#\tdefine XZ_PREBOOT\n#else\n#include <linux/decompress/unxz.h>\n#endif\n#ifdef __KERNEL__\n#\tinclude <linux/decompress/mm.h>\n#endif\n#define XZ_EXTERN STATIC\n\n#ifndef XZ_PREBOOT\n#\tinclude <linux/slab.h>\n#\tinclude <linux/xz.h>\n#else\n \n#define XZ_INTERNAL_CRC32 1\n\n \n#ifdef CONFIG_X86\n#\tdefine XZ_DEC_X86\n#endif\n#ifdef CONFIG_PPC\n#\tdefine XZ_DEC_POWERPC\n#endif\n#ifdef CONFIG_ARM\n#\tdefine XZ_DEC_ARM\n#endif\n#ifdef CONFIG_IA64\n#\tdefine XZ_DEC_IA64\n#endif\n#ifdef CONFIG_SPARC\n#\tdefine XZ_DEC_SPARC\n#endif\n\n \n#include \"xz/xz_private.h\"\n\n \n#undef kmalloc\n#undef kfree\n#undef vmalloc\n#undef vfree\n#define kmalloc(size, flags) malloc(size)\n#define kfree(ptr) free(ptr)\n#define vmalloc(size) malloc(size)\n#define vfree(ptr) do { if (ptr != NULL) free(ptr); } while (0)\n\n \n\n#ifndef memeq\nstatic bool memeq(const void *a, const void *b, size_t size)\n{\n\tconst uint8_t *x = a;\n\tconst uint8_t *y = b;\n\tsize_t i;\n\n\tfor (i = 0; i < size; ++i)\n\t\tif (x[i] != y[i])\n\t\t\treturn false;\n\n\treturn true;\n}\n#endif\n\n#ifndef memzero\nstatic void memzero(void *buf, size_t size)\n{\n\tuint8_t *b = buf;\n\tuint8_t *e = b + size;\n\n\twhile (b != e)\n\t\t*b++ = '\\0';\n}\n#endif\n\n#ifndef memmove\n \nvoid *memmove(void *dest, const void *src, size_t size)\n{\n\tuint8_t *d = dest;\n\tconst uint8_t *s = src;\n\tsize_t i;\n\n\tif (d < s) {\n\t\tfor (i = 0; i < size; ++i)\n\t\t\td[i] = s[i];\n\t} else if (d > s) {\n\t\ti = size;\n\t\twhile (i-- > 0)\n\t\t\td[i] = s[i];\n\t}\n\n\treturn dest;\n}\n#endif\n\n \n \n\n#include \"xz/xz_crc32.c\"\n#include \"xz/xz_dec_stream.c\"\n#include \"xz/xz_dec_lzma2.c\"\n#include \"xz/xz_dec_bcj.c\"\n\n#endif  \n\n \n#define XZ_IOBUF_SIZE 4096\n\n \nSTATIC int INIT unxz(unsigned char *in, long in_size,\n\t\t     long (*fill)(void *dest, unsigned long size),\n\t\t     long (*flush)(void *src, unsigned long size),\n\t\t     unsigned char *out, long *in_used,\n\t\t     void (*error)(char *x))\n{\n\tstruct xz_buf b;\n\tstruct xz_dec *s;\n\tenum xz_ret ret;\n\tbool must_free_in = false;\n\n#if XZ_INTERNAL_CRC32\n\txz_crc32_init();\n#endif\n\n\tif (in_used != NULL)\n\t\t*in_used = 0;\n\n\tif (fill == NULL && flush == NULL)\n\t\ts = xz_dec_init(XZ_SINGLE, 0);\n\telse\n\t\ts = xz_dec_init(XZ_DYNALLOC, (uint32_t)-1);\n\n\tif (s == NULL)\n\t\tgoto error_alloc_state;\n\n\tif (flush == NULL) {\n\t\tb.out = out;\n\t\tb.out_size = (size_t)-1;\n\t} else {\n\t\tb.out_size = XZ_IOBUF_SIZE;\n\t\tb.out = malloc(XZ_IOBUF_SIZE);\n\t\tif (b.out == NULL)\n\t\t\tgoto error_alloc_out;\n\t}\n\n\tif (in == NULL) {\n\t\tmust_free_in = true;\n\t\tin = malloc(XZ_IOBUF_SIZE);\n\t\tif (in == NULL)\n\t\t\tgoto error_alloc_in;\n\t}\n\n\tb.in = in;\n\tb.in_pos = 0;\n\tb.in_size = in_size;\n\tb.out_pos = 0;\n\n\tif (fill == NULL && flush == NULL) {\n\t\tret = xz_dec_run(s, &b);\n\t} else {\n\t\tdo {\n\t\t\tif (b.in_pos == b.in_size && fill != NULL) {\n\t\t\t\tif (in_used != NULL)\n\t\t\t\t\t*in_used += b.in_pos;\n\n\t\t\t\tb.in_pos = 0;\n\n\t\t\t\tin_size = fill(in, XZ_IOBUF_SIZE);\n\t\t\t\tif (in_size < 0) {\n\t\t\t\t\t \n\t\t\t\t\tret = XZ_BUF_ERROR;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tb.in_size = in_size;\n\t\t\t}\n\n\t\t\tret = xz_dec_run(s, &b);\n\n\t\t\tif (flush != NULL && (b.out_pos == b.out_size\n\t\t\t\t\t|| (ret != XZ_OK && b.out_pos > 0))) {\n\t\t\t\t \n\t\t\t\tif (flush(b.out, b.out_pos) != (long)b.out_pos)\n\t\t\t\t\tret = XZ_BUF_ERROR;\n\n\t\t\t\tb.out_pos = 0;\n\t\t\t}\n\t\t} while (ret == XZ_OK);\n\n\t\tif (must_free_in)\n\t\t\tfree(in);\n\n\t\tif (flush != NULL)\n\t\t\tfree(b.out);\n\t}\n\n\tif (in_used != NULL)\n\t\t*in_used += b.in_pos;\n\n\txz_dec_end(s);\n\n\tswitch (ret) {\n\tcase XZ_STREAM_END:\n\t\treturn 0;\n\n\tcase XZ_MEM_ERROR:\n\t\t \n\t\terror(\"XZ decompressor ran out of memory\");\n\t\tbreak;\n\n\tcase XZ_FORMAT_ERROR:\n\t\terror(\"Input is not in the XZ format (wrong magic bytes)\");\n\t\tbreak;\n\n\tcase XZ_OPTIONS_ERROR:\n\t\terror(\"Input was encoded with settings that are not \"\n\t\t\t\t\"supported by this XZ decoder\");\n\t\tbreak;\n\n\tcase XZ_DATA_ERROR:\n\tcase XZ_BUF_ERROR:\n\t\terror(\"XZ-compressed data is corrupt\");\n\t\tbreak;\n\n\tdefault:\n\t\terror(\"Bug in the XZ decompressor\");\n\t\tbreak;\n\t}\n\n\treturn -1;\n\nerror_alloc_in:\n\tif (flush != NULL)\n\t\tfree(b.out);\n\nerror_alloc_out:\n\txz_dec_end(s);\n\nerror_alloc_state:\n\terror(\"XZ decompressor ran out of memory\");\n\treturn -1;\n}\n\n \n#ifdef XZ_PREBOOT\nSTATIC int INIT __decompress(unsigned char *buf, long len,\n\t\t\t   long (*fill)(void*, unsigned long),\n\t\t\t   long (*flush)(void*, unsigned long),\n\t\t\t   unsigned char *out_buf, long olen,\n\t\t\t   long *pos,\n\t\t\t   void (*error)(char *x))\n{\n\treturn unxz(buf, len, fill, flush, out_buf, pos, error);\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}