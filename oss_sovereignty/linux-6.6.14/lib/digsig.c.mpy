{
  "module_name": "digsig.c",
  "hash_id": "c9ca71b3c89287c499db9d71622069c6b47b1d67bc30ce77fb5bf9f6d41692ad",
  "original_prompt": "Ingested from linux-6.6.14/lib/digsig.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/err.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/key.h>\n#include <linux/crypto.h>\n#include <crypto/hash.h>\n#include <crypto/sha1.h>\n#include <keys/user-type.h>\n#include <linux/mpi.h>\n#include <linux/digsig.h>\n\nstatic struct crypto_shash *shash;\n\nstatic const char *pkcs_1_v1_5_decode_emsa(const unsigned char *msg,\n\t\t\t\t\t\tunsigned long  msglen,\n\t\t\t\t\t\tunsigned long  modulus_bitlen,\n\t\t\t\t\t\tunsigned long *outlen)\n{\n\tunsigned long modulus_len, ps_len, i;\n\n\tmodulus_len = (modulus_bitlen >> 3) + (modulus_bitlen & 7 ? 1 : 0);\n\n\t \n\tif ((msglen > modulus_len) || (modulus_len < 11))\n\t\treturn NULL;\n\n\t \n\tif (msg[0] != 0x00 || msg[1] != 0x01)\n\t\treturn NULL;\n\n\tfor (i = 2; i < modulus_len - 1; i++)\n\t\tif (msg[i] != 0xFF)\n\t\t\tbreak;\n\n\t \n\tif (msg[i] != 0)\n\t\t \n\t\treturn NULL;\n\n\tps_len = i - 2;\n\n\t*outlen = (msglen - (2 + ps_len + 1));\n\n\treturn msg + 2 + ps_len + 1;\n}\n\n \nstatic int digsig_verify_rsa(struct key *key,\n\t\t    const char *sig, int siglen,\n\t\t       const char *h, int hlen)\n{\n\tint err = -EINVAL;\n\tunsigned long len;\n\tunsigned long mlen, mblen;\n\tunsigned nret, l;\n\tint head, i;\n\tunsigned char *out1 = NULL;\n\tconst char *m;\n\tMPI in = NULL, res = NULL, pkey[2];\n\tuint8_t *p, *datap;\n\tconst uint8_t *endp;\n\tconst struct user_key_payload *ukp;\n\tstruct pubkey_hdr *pkh;\n\n\tdown_read(&key->sem);\n\tukp = user_key_payload_locked(key);\n\n\tif (!ukp) {\n\t\t \n\t\terr = -EKEYREVOKED;\n\t\tgoto err1;\n\t}\n\n\tif (ukp->datalen < sizeof(*pkh))\n\t\tgoto err1;\n\n\tpkh = (struct pubkey_hdr *)ukp->data;\n\n\tif (pkh->version != 1)\n\t\tgoto err1;\n\n\tif (pkh->algo != PUBKEY_ALGO_RSA)\n\t\tgoto err1;\n\n\tif (pkh->nmpi != 2)\n\t\tgoto err1;\n\n\tdatap = pkh->mpi;\n\tendp = ukp->data + ukp->datalen;\n\n\tfor (i = 0; i < pkh->nmpi; i++) {\n\t\tunsigned int remaining = endp - datap;\n\t\tpkey[i] = mpi_read_from_buffer(datap, &remaining);\n\t\tif (IS_ERR(pkey[i])) {\n\t\t\terr = PTR_ERR(pkey[i]);\n\t\t\tgoto err;\n\t\t}\n\t\tdatap += remaining;\n\t}\n\n\tmblen = mpi_get_nbits(pkey[0]);\n\tmlen = DIV_ROUND_UP(mblen, 8);\n\n\tif (mlen == 0) {\n\t\terr = -EINVAL;\n\t\tgoto err;\n\t}\n\n\terr = -ENOMEM;\n\n\tout1 = kzalloc(mlen, GFP_KERNEL);\n\tif (!out1)\n\t\tgoto err;\n\n\tnret = siglen;\n\tin = mpi_read_from_buffer(sig, &nret);\n\tif (IS_ERR(in)) {\n\t\terr = PTR_ERR(in);\n\t\tgoto err;\n\t}\n\n\tres = mpi_alloc(mpi_get_nlimbs(in) * 2);\n\tif (!res)\n\t\tgoto err;\n\n\terr = mpi_powm(res, in, pkey[1], pkey[0]);\n\tif (err)\n\t\tgoto err;\n\n\tif (mpi_get_nlimbs(res) * BYTES_PER_MPI_LIMB > mlen) {\n\t\terr = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tp = mpi_get_buffer(res, &l, NULL);\n\tif (!p) {\n\t\terr = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tlen = mlen;\n\thead = len - l;\n\tmemset(out1, 0, head);\n\tmemcpy(out1 + head, p, l);\n\n\tkfree(p);\n\n\tm = pkcs_1_v1_5_decode_emsa(out1, len, mblen, &len);\n\n\tif (!m || len != hlen || memcmp(m, h, hlen))\n\t\terr = -EINVAL;\n\nerr:\n\tmpi_free(in);\n\tmpi_free(res);\n\tkfree(out1);\n\twhile (--i >= 0)\n\t\tmpi_free(pkey[i]);\nerr1:\n\tup_read(&key->sem);\n\n\treturn err;\n}\n\n \nint digsig_verify(struct key *keyring, const char *sig, int siglen,\n\t\t\t\t\t\tconst char *data, int datalen)\n{\n\tint err = -ENOMEM;\n\tstruct signature_hdr *sh = (struct signature_hdr *)sig;\n\tstruct shash_desc *desc = NULL;\n\tunsigned char hash[SHA1_DIGEST_SIZE];\n\tstruct key *key;\n\tchar name[20];\n\n\tif (siglen < sizeof(*sh) + 2)\n\t\treturn -EINVAL;\n\n\tif (sh->algo != PUBKEY_ALGO_RSA)\n\t\treturn -ENOTSUPP;\n\n\tsprintf(name, \"%llX\", __be64_to_cpup((uint64_t *)sh->keyid));\n\n\tif (keyring) {\n\t\t \n\t\tkey_ref_t kref;\n\t\tkref = keyring_search(make_key_ref(keyring, 1UL),\n\t\t\t\t      &key_type_user, name, true);\n\t\tif (IS_ERR(kref))\n\t\t\tkey = ERR_CAST(kref);\n\t\telse\n\t\t\tkey = key_ref_to_ptr(kref);\n\t} else {\n\t\tkey = request_key(&key_type_user, name, NULL);\n\t}\n\tif (IS_ERR(key)) {\n\t\tpr_err(\"key not found, id: %s\\n\", name);\n\t\treturn PTR_ERR(key);\n\t}\n\n\tdesc = kzalloc(sizeof(*desc) + crypto_shash_descsize(shash),\n\t\t       GFP_KERNEL);\n\tif (!desc)\n\t\tgoto err;\n\n\tdesc->tfm = shash;\n\n\tcrypto_shash_init(desc);\n\tcrypto_shash_update(desc, data, datalen);\n\tcrypto_shash_update(desc, sig, sizeof(*sh));\n\tcrypto_shash_final(desc, hash);\n\n\tkfree(desc);\n\n\t \n\terr = digsig_verify_rsa(key, sig + sizeof(*sh), siglen - sizeof(*sh),\n\t\t\t     hash, sizeof(hash));\n\nerr:\n\tkey_put(key);\n\n\treturn err ? -EINVAL : 0;\n}\nEXPORT_SYMBOL_GPL(digsig_verify);\n\nstatic int __init digsig_init(void)\n{\n\tshash = crypto_alloc_shash(\"sha1\", 0, 0);\n\tif (IS_ERR(shash)) {\n\t\tpr_err(\"shash allocation failed\\n\");\n\t\treturn  PTR_ERR(shash);\n\t}\n\n\treturn 0;\n\n}\n\nstatic void __exit digsig_cleanup(void)\n{\n\tcrypto_free_shash(shash);\n}\n\nmodule_init(digsig_init);\nmodule_exit(digsig_cleanup);\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}