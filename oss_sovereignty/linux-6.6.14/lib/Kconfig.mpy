{
  "module_name": "Kconfig",
  "hash_id": "b703b3cc4fce84f9afe61dee4805f1e19fe27333d95f31768d83b78a2eb96a3b",
  "original_prompt": "Ingested from linux-6.6.14/lib/Kconfig",
  "human_readable_source": "# SPDX-License-Identifier: GPL-2.0-only\n#\n# Library configuration\n#\n\nconfig BINARY_PRINTF\n\tdef_bool n\n\nmenu \"Library routines\"\n\nconfig RAID6_PQ\n\ttristate\n\nconfig RAID6_PQ_BENCHMARK\n\tbool \"Automatically choose fastest RAID6 PQ functions\"\n\tdepends on RAID6_PQ\n\tdefault y\n\thelp\n\t  Benchmark all available RAID6 PQ functions on init and choose the\n\t  fastest one.\n\nconfig LINEAR_RANGES\n\ttristate\n\nconfig PACKING\n\tbool \"Generic bitfield packing and unpacking\"\n\tselect BITREVERSE\n\tdefault n\n\thelp\n\t  This option provides the packing() helper function, which permits\n\t  converting bitfields between a CPU-usable representation and a\n\t  memory representation that can have any combination of these quirks:\n\t    - Is little endian (bytes are reversed within a 32-bit group)\n\t    - The least-significant 32-bit word comes first (within a 64-bit\n\t      group)\n\t    - The most significant bit of a byte is at its right (bit 0 of a\n\t      register description is numerically 2^7).\n\t  Drivers may use these helpers to match the bit indices as described\n\t  in the data sheets of the peripherals they are in control of.\n\n\t  When in doubt, say N.\n\nconfig BITREVERSE\n\ttristate\n\nconfig HAVE_ARCH_BITREVERSE\n\tbool\n\tdefault n\n\thelp\n\t  This option enables the use of hardware bit-reversal instructions on\n\t  architectures which support such operations.\n\nconfig ARCH_HAS_STRNCPY_FROM_USER\n\tbool\n\nconfig ARCH_HAS_STRNLEN_USER\n\tbool\n\nconfig GENERIC_STRNCPY_FROM_USER\n\tdef_bool !ARCH_HAS_STRNCPY_FROM_USER\n\nconfig GENERIC_STRNLEN_USER\n\tdef_bool !ARCH_HAS_STRNLEN_USER\n\nconfig GENERIC_NET_UTILS\n\tbool\n\nsource \"lib/math/Kconfig\"\n\nconfig NO_GENERIC_PCI_IOPORT_MAP\n\tbool\n\nconfig GENERIC_PCI_IOMAP\n\tbool\n\nconfig GENERIC_IOMAP\n\tbool\n\tselect GENERIC_PCI_IOMAP\n\nconfig STMP_DEVICE\n\tbool\n\nconfig ARCH_USE_CMPXCHG_LOCKREF\n\tbool\n\nconfig ARCH_HAS_FAST_MULTIPLIER\n\tbool\n\nconfig ARCH_USE_SYM_ANNOTATIONS\n\tbool\n\nconfig INDIRECT_PIO\n\tbool \"Access I/O in non-MMIO mode\"\n\tdepends on ARM64\n\tdepends on HAS_IOPORT\n\thelp\n\t  On some platforms where no separate I/O space exists, there are I/O\n\t  hosts which can not be accessed in MMIO mode. Using the logical PIO\n\t  mechanism, the host-local I/O resource can be mapped into system\n\t  logic PIO space shared with MMIO hosts, such as PCI/PCIe, then the\n\t  system can access the I/O devices with the mapped-logic PIO through\n\t  I/O accessors.\n\n\t  This way has relatively little I/O performance cost. Please make\n\t  sure your devices really need this configure item enabled.\n\n\t  When in doubt, say N.\n\nconfig INDIRECT_IOMEM\n\tbool\n\thelp\n\t  This is selected by other options/architectures to provide the\n\t  emulated iomem accessors.\n\nconfig INDIRECT_IOMEM_FALLBACK\n\tbool\n\tdepends on INDIRECT_IOMEM\n\thelp\n\t  If INDIRECT_IOMEM is selected, this enables falling back to plain\n\t  mmio accesses when the IO memory address is not a registered\n\t  emulated region.\n\nconfig TRACE_MMIO_ACCESS\n\tbool \"Register read/write tracing\"\n\tdepends on TRACING && ARCH_HAVE_TRACE_MMIO_ACCESS\n\thelp\n\t  Create tracepoints for MMIO read/write operations. These trace events\n\t  can be used for logging all MMIO read/write operations.\n\nsource \"lib/crypto/Kconfig\"\n\nconfig CRC_CCITT\n\ttristate \"CRC-CCITT functions\"\n\thelp\n\t  This option is provided for the case where no in-kernel-tree\n\t  modules require CRC-CCITT functions, but a module built outside\n\t  the kernel tree does. Such modules that use library CRC-CCITT\n\t  functions require M here.\n\nconfig CRC16\n\ttristate \"CRC16 functions\"\n\thelp\n\t  This option is provided for the case where no in-kernel-tree\n\t  modules require CRC16 functions, but a module built outside\n\t  the kernel tree does. Such modules that use library CRC16\n\t  functions require M here.\n\nconfig CRC_T10DIF\n\ttristate \"CRC calculation for the T10 Data Integrity Field\"\n\tselect CRYPTO\n\tselect CRYPTO_CRCT10DIF\n\thelp\n\t  This option is only needed if a module that's not in the\n\t  kernel tree needs to calculate CRC checks for use with the\n\t  SCSI data integrity subsystem.\n\nconfig CRC64_ROCKSOFT\n\ttristate \"CRC calculation for the Rocksoft model CRC64\"\n\tselect CRC64\n\tselect CRYPTO\n\tselect CRYPTO_CRC64_ROCKSOFT\n\thelp\n\t  This option provides a CRC64 API to a registered crypto driver.\n\t  This is used with the block layer's data integrity subsystem.\n\nconfig CRC_ITU_T\n\ttristate \"CRC ITU-T V.41 functions\"\n\thelp\n\t  This option is provided for the case where no in-kernel-tree\n\t  modules require CRC ITU-T V.41 functions, but a module built outside\n\t  the kernel tree does. Such modules that use library CRC ITU-T V.41\n\t  functions require M here.\n\nconfig CRC32\n\ttristate \"CRC32/CRC32c functions\"\n\tdefault y\n\tselect BITREVERSE\n\thelp\n\t  This option is provided for the case where no in-kernel-tree\n\t  modules require CRC32/CRC32c functions, but a module built outside\n\t  the kernel tree does. Such modules that use library CRC32/CRC32c\n\t  functions require M here.\n\nconfig CRC32_SELFTEST\n\ttristate \"CRC32 perform self test on init\"\n\tdepends on CRC32\n\thelp\n\t  This option enables the CRC32 library functions to perform a\n\t  self test on initialization. The self test computes crc32_le\n\t  and crc32_be over byte strings with random alignment and length\n\t  and computes the total elapsed time and number of bytes processed.\n\nchoice\n\tprompt \"CRC32 implementation\"\n\tdepends on CRC32\n\tdefault CRC32_SLICEBY8\n\thelp\n\t  This option allows a kernel builder to override the default choice\n\t  of CRC32 algorithm.  Choose the default (\"slice by 8\") unless you\n\t  know that you need one of the others.\n\nconfig CRC32_SLICEBY8\n\tbool \"Slice by 8 bytes\"\n\thelp\n\t  Calculate checksum 8 bytes at a time with a clever slicing algorithm.\n\t  This is the fastest algorithm, but comes with a 8KiB lookup table.\n\t  Most modern processors have enough cache to hold this table without\n\t  thrashing the cache.\n\n\t  This is the default implementation choice.  Choose this one unless\n\t  you have a good reason not to.\n\nconfig CRC32_SLICEBY4\n\tbool \"Slice by 4 bytes\"\n\thelp\n\t  Calculate checksum 4 bytes at a time with a clever slicing algorithm.\n\t  This is a bit slower than slice by 8, but has a smaller 4KiB lookup\n\t  table.\n\n\t  Only choose this option if you know what you are doing.\n\nconfig CRC32_SARWATE\n\tbool \"Sarwate's Algorithm (one byte at a time)\"\n\thelp\n\t  Calculate checksum a byte at a time using Sarwate's algorithm.  This\n\t  is not particularly fast, but has a small 256 byte lookup table.\n\n\t  Only choose this option if you know what you are doing.\n\nconfig CRC32_BIT\n\tbool \"Classic Algorithm (one bit at a time)\"\n\thelp\n\t  Calculate checksum one bit at a time.  This is VERY slow, but has\n\t  no lookup table.  This is provided as a debugging option.\n\n\t  Only choose this option if you are debugging crc32.\n\nendchoice\n\nconfig CRC64\n\ttristate \"CRC64 functions\"\n\thelp\n\t  This option is provided for the case where no in-kernel-tree\n\t  modules require CRC64 functions, but a module built outside\n\t  the kernel tree does. Such modules that use library CRC64\n\t  functions require M here.\n\nconfig CRC4\n\ttristate \"CRC4 functions\"\n\thelp\n\t  This option is provided for the case where no in-kernel-tree\n\t  modules require CRC4 functions, but a module built outside\n\t  the kernel tree does. Such modules that use library CRC4\n\t  functions require M here.\n\nconfig CRC7\n\ttristate \"CRC7 functions\"\n\thelp\n\t  This option is provided for the case where no in-kernel-tree\n\t  modules require CRC7 functions, but a module built outside\n\t  the kernel tree does. Such modules that use library CRC7\n\t  functions require M here.\n\nconfig LIBCRC32C\n\ttristate \"CRC32c (Castagnoli, et al) Cyclic Redundancy-Check\"\n\tselect CRYPTO\n\tselect CRYPTO_CRC32C\n\thelp\n\t  This option is provided for the case where no in-kernel-tree\n\t  modules require CRC32c functions, but a module built outside the\n\t  kernel tree does. Such modules that use library CRC32c functions\n\t  require M here.  See Castagnoli93.\n\t  Module will be libcrc32c.\n\nconfig CRC8\n\ttristate \"CRC8 function\"\n\thelp\n\t  This option provides CRC8 function. Drivers may select this\n\t  when they need to do cyclic redundancy check according CRC8\n\t  algorithm. Module will be called crc8.\n\nconfig XXHASH\n\ttristate\n\nconfig AUDIT_GENERIC\n\tbool\n\tdepends on AUDIT && !AUDIT_ARCH\n\tdefault y\n\nconfig AUDIT_ARCH_COMPAT_GENERIC\n\tbool\n\tdefault n\n\nconfig AUDIT_COMPAT_GENERIC\n\tbool\n\tdepends on AUDIT_GENERIC && AUDIT_ARCH_COMPAT_GENERIC && COMPAT\n\tdefault y\n\nconfig RANDOM32_SELFTEST\n\tbool \"PRNG perform self test on init\"\n\thelp\n\t  This option enables the 32 bit PRNG library functions to perform a\n\t  self test on initialization.\n\n#\n# compression support is select'ed if needed\n#\nconfig 842_COMPRESS\n\tselect CRC32\n\ttristate\n\nconfig 842_DECOMPRESS\n\tselect CRC32\n\ttristate\n\nconfig ZLIB_INFLATE\n\ttristate\n\nconfig ZLIB_DEFLATE\n\ttristate\n\tselect BITREVERSE\n\nconfig ZLIB_DFLTCC\n\tdef_bool y\n\tdepends on S390\n\tprompt \"Enable s390x DEFLATE CONVERSION CALL support for kernel zlib\"\n\thelp\n\t Enable s390x hardware support for zlib in the kernel.\n\nconfig LZO_COMPRESS\n\ttristate\n\nconfig LZO_DECOMPRESS\n\ttristate\n\nconfig LZ4_COMPRESS\n\ttristate\n\nconfig LZ4HC_COMPRESS\n\ttristate\n\nconfig LZ4_DECOMPRESS\n\ttristate\n\nconfig ZSTD_COMMON\n\tselect XXHASH\n\ttristate\n\nconfig ZSTD_COMPRESS\n\tselect ZSTD_COMMON\n\ttristate\n\nconfig ZSTD_DECOMPRESS\n\tselect ZSTD_COMMON\n\ttristate\n\nsource \"lib/xz/Kconfig\"\n\n#\n# These all provide a common interface (hence the apparent duplication with\n# ZLIB_INFLATE; DECOMPRESS_GZIP is just a wrapper.)\n#\nconfig DECOMPRESS_GZIP\n\tselect ZLIB_INFLATE\n\ttristate\n\nconfig DECOMPRESS_BZIP2\n\ttristate\n\nconfig DECOMPRESS_LZMA\n\ttristate\n\nconfig DECOMPRESS_XZ\n\tselect XZ_DEC\n\ttristate\n\nconfig DECOMPRESS_LZO\n\tselect LZO_DECOMPRESS\n\ttristate\n\nconfig DECOMPRESS_LZ4\n\tselect LZ4_DECOMPRESS\n\ttristate\n\nconfig DECOMPRESS_ZSTD\n\tselect ZSTD_DECOMPRESS\n\ttristate\n\n#\n# Generic allocator support is selected if needed\n#\nconfig GENERIC_ALLOCATOR\n\tbool\n\n#\n# reed solomon support is select'ed if needed\n#\nconfig REED_SOLOMON\n\ttristate\n\t\nconfig REED_SOLOMON_ENC8\n\tbool\n\nconfig REED_SOLOMON_DEC8\n\tbool\n\nconfig REED_SOLOMON_ENC16\n\tbool\n\nconfig REED_SOLOMON_DEC16\n\tbool\n\n#\n# BCH support is selected if needed\n#\nconfig BCH\n\ttristate\n\tselect BITREVERSE\n\nconfig BCH_CONST_PARAMS\n\tbool\n\thelp\n\t  Drivers may select this option to force specific constant\n\t  values for parameters 'm' (Galois field order) and 't'\n\t  (error correction capability). Those specific values must\n\t  be set by declaring default values for symbols BCH_CONST_M\n\t  and BCH_CONST_T.\n\t  Doing so will enable extra compiler optimizations,\n\t  improving encoding and decoding performance up to 2x for\n\t  usual (m,t) values (typically such that m*t < 200).\n\t  When this option is selected, the BCH library supports\n\t  only a single (m,t) configuration. This is mainly useful\n\t  for NAND flash board drivers requiring known, fixed BCH\n\t  parameters.\n\nconfig BCH_CONST_M\n\tint\n\trange 5 15\n\thelp\n\t  Constant value for Galois field order 'm'. If 'k' is the\n\t  number of data bits to protect, 'm' should be chosen such\n\t  that (k + m*t) <= 2**m - 1.\n\t  Drivers should declare a default value for this symbol if\n\t  they select option BCH_CONST_PARAMS.\n\nconfig BCH_CONST_T\n\tint\n\thelp\n\t  Constant value for error correction capability in bits 't'.\n\t  Drivers should declare a default value for this symbol if\n\t  they select option BCH_CONST_PARAMS.\n\n#\n# Textsearch support is select'ed if needed\n#\nconfig TEXTSEARCH\n\tbool\n\nconfig TEXTSEARCH_KMP\n\ttristate\n\nconfig TEXTSEARCH_BM\n\ttristate\n\nconfig TEXTSEARCH_FSM\n\ttristate\n\nconfig BTREE\n\tbool\n\nconfig INTERVAL_TREE\n\tbool\n\thelp\n\t  Simple, embeddable, interval-tree. Can find the start of an\n\t  overlapping range in log(n) time and then iterate over all\n\t  overlapping nodes. The algorithm is implemented as an\n\t  augmented rbtree.\n\n\t  See:\n\n\t\tDocumentation/core-api/rbtree.rst\n\n\t  for more information.\n\nconfig INTERVAL_TREE_SPAN_ITER\n\tbool\n\tdepends on INTERVAL_TREE\n\nconfig XARRAY_MULTI\n\tbool\n\thelp\n\t  Support entries which occupy multiple consecutive indices in the\n\t  XArray.\n\nconfig ASSOCIATIVE_ARRAY\n\tbool\n\thelp\n\t  Generic associative array.  Can be searched and iterated over whilst\n\t  it is being modified.  It is also reasonably quick to search and\n\t  modify.  The algorithms are non-recursive, and the trees are highly\n\t  capacious.\n\n\t  See:\n\n\t\tDocumentation/core-api/assoc_array.rst\n\n\t  for more information.\n\nconfig HAS_IOMEM\n\tbool\n\tdepends on !NO_IOMEM\n\tdefault y\n\nconfig HAS_IOPORT\n\tbool\n\nconfig HAS_IOPORT_MAP\n\tbool\n\tdepends on HAS_IOMEM && !NO_IOPORT_MAP\n\tdefault y\n\nsource \"kernel/dma/Kconfig\"\n\nconfig SGL_ALLOC\n\tbool\n\tdefault n\n\nconfig IOMMU_HELPER\n\tbool\n\nconfig CHECK_SIGNATURE\n\tbool\n\nconfig CPUMASK_OFFSTACK\n\tbool \"Force CPU masks off stack\" if DEBUG_PER_CPU_MAPS\n\thelp\n\t  Use dynamic allocation for cpumask_var_t, instead of putting\n\t  them on the stack.  This is a bit more expensive, but avoids\n\t  stack overflow.\n\nconfig FORCE_NR_CPUS\n       bool \"Set number of CPUs at compile time\"\n       depends on SMP && EXPERT && !COMPILE_TEST\n       help\n         Say Yes if you have NR_CPUS set to an actual number of possible\n         CPUs in your system, not to a default value. This forces the core\n         code to rely on compile-time value and optimize kernel routines\n         better.\n\nconfig CPU_RMAP\n\tbool\n\tdepends on SMP\n\nconfig DQL\n\tbool\n\nconfig GLOB\n\tbool\n#\tThis actually supports modular compilation, but the module overhead\n#\tis ridiculous for the amount of code involved.\tUntil an out-of-tree\n#\tdriver asks for it, we'll just link it directly it into the kernel\n#\twhen required.  Since we're ignoring out-of-tree users,\tthere's also\n#\tno need bother prompting for a manual decision:\n#\tprompt \"glob_match() function\"\n\thelp\n\t  This option provides a glob_match function for performing\n\t  simple text pattern matching.  It originated in the ATA code\n\t  to blacklist particular drive models, but other device drivers\n\t  may need similar functionality.\n\n\t  All drivers in the Linux kernel tree that require this function\n\t  should automatically select this option.  Say N unless you\n\t  are compiling an out-of tree driver which tells you that it\n\t  depends on this.\n\nconfig GLOB_SELFTEST\n\ttristate \"glob self-test on init\"\n\tdepends on GLOB\n\thelp\n\t  This option enables a simple self-test of the glob_match\n\t  function on startup.\tIt is primarily useful for people\n\t  working on the code to ensure they haven't introduced any\n\t  regressions.\n\n\t  It only adds a little bit of code and slows kernel boot (or\n\t  module load) by a small amount, so you're welcome to play with\n\t  it, but you probably don't need it.\n\n#\n# Netlink attribute parsing support is select'ed if needed\n#\nconfig NLATTR\n\tbool\n\n#\n# Generic 64-bit atomic support is selected if needed\n#\nconfig GENERIC_ATOMIC64\n       bool\n\nconfig LRU_CACHE\n\ttristate\n\nconfig CLZ_TAB\n\tbool\n\nconfig IRQ_POLL\n\tbool \"IRQ polling library\"\n\thelp\n\t  Helper library to poll interrupt mitigation using polling.\n\nconfig MPILIB\n\ttristate\n\tselect CLZ_TAB\n\thelp\n\t  Multiprecision maths library from GnuPG.\n\t  It is used to implement RSA digital signature verification,\n\t  which is used by IMA/EVM digital signature extension.\n\nconfig SIGNATURE\n\ttristate\n\tdepends on KEYS\n\tselect CRYPTO\n\tselect CRYPTO_SHA1\n\tselect MPILIB\n\thelp\n\t  Digital signature verification. Currently only RSA is supported.\n\t  Implementation is done using GnuPG MPI library\n\nconfig DIMLIB\n\tbool\n\thelp\n\t  Dynamic Interrupt Moderation library.\n\t  Implements an algorithm for dynamically changing CQ moderation values\n\t  according to run time performance.\n\n#\n# libfdt files, only selected if needed.\n#\nconfig LIBFDT\n\tbool\n\nconfig OID_REGISTRY\n\ttristate\n\thelp\n\t  Enable fast lookup object identifier registry.\n\nconfig UCS2_STRING\n\ttristate\n\n#\n# generic vdso\n#\nsource \"lib/vdso/Kconfig\"\n\nsource \"lib/fonts/Kconfig\"\n\nconfig SG_SPLIT\n\tdef_bool n\n\thelp\n\t Provides a helper to split scatterlists into chunks, each chunk being\n\t a scatterlist. This should be selected by a driver or an API which\n\t whishes to split a scatterlist amongst multiple DMA channels.\n\nconfig SG_POOL\n\tdef_bool n\n\thelp\n\t Provides a helper to allocate chained scatterlists. This should be\n\t selected by a driver or an API which whishes to allocate chained\n\t scatterlist.\n\n#\n# sg chaining option\n#\n\nconfig ARCH_NO_SG_CHAIN\n\tdef_bool n\n\nconfig ARCH_HAS_PMEM_API\n\tbool\n\nconfig MEMREGION\n\tbool\n\nconfig ARCH_HAS_CPU_CACHE_INVALIDATE_MEMREGION\n\tbool\n\nconfig ARCH_HAS_MEMREMAP_COMPAT_ALIGN\n\tbool\n\n# use memcpy to implement user copies for nommu architectures\nconfig UACCESS_MEMCPY\n\tbool\n\nconfig ARCH_HAS_UACCESS_FLUSHCACHE\n\tbool\n\n# arch has a concept of a recoverable synchronous exception due to a\n# memory-read error like x86 machine-check or ARM data-abort, and\n# implements copy_mc_to_{user,kernel} to abort and report\n# 'bytes-transferred' if that exception fires when accessing the source\n# buffer.\nconfig ARCH_HAS_COPY_MC\n\tbool\n\n# Temporary. Goes away when all archs are cleaned up\nconfig ARCH_STACKWALK\n       bool\n\nconfig STACKDEPOT\n\tbool\n\tselect STACKTRACE\n\nconfig STACKDEPOT_ALWAYS_INIT\n\tbool\n\tselect STACKDEPOT\n\nconfig REF_TRACKER\n\tbool\n\tdepends on STACKTRACE_SUPPORT\n\tselect STACKDEPOT\n\nconfig SBITMAP\n\tbool\n\nconfig PARMAN\n\ttristate \"parman\" if COMPILE_TEST\n\nconfig OBJAGG\n\ttristate \"objagg\" if COMPILE_TEST\n\nendmenu\n\nconfig GENERIC_IOREMAP\n\tbool\n\nconfig GENERIC_LIB_ASHLDI3\n\tbool\n\nconfig GENERIC_LIB_ASHRDI3\n\tbool\n\nconfig GENERIC_LIB_LSHRDI3\n\tbool\n\nconfig GENERIC_LIB_MULDI3\n\tbool\n\nconfig GENERIC_LIB_CMPDI2\n\tbool\n\nconfig GENERIC_LIB_UCMPDI2\n\tbool\n\nconfig GENERIC_LIB_DEVMEM_IS_ALLOWED\n\tbool\n\nconfig PLDMFW\n\tbool\n\tdefault n\n\nconfig ASN1_ENCODER\n       tristate\n\nconfig POLYNOMIAL\n       tristate\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}