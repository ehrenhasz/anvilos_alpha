{
  "module_name": "lzo1x_compress.c",
  "hash_id": "179333dd8b951cb734b06f047136370b4fddaf66e162890e23f4d652ab10bd13",
  "original_prompt": "Ingested from linux-6.6.14/lib/lzo/lzo1x_compress.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <asm/unaligned.h>\n#include <linux/lzo.h>\n#include \"lzodefs.h\"\n\nstatic noinline size_t\nlzo1x_1_do_compress(const unsigned char *in, size_t in_len,\n\t\t    unsigned char *out, size_t *out_len,\n\t\t    size_t ti, void *wrkmem, signed char *state_offset,\n\t\t    const unsigned char bitstream_version)\n{\n\tconst unsigned char *ip;\n\tunsigned char *op;\n\tconst unsigned char * const in_end = in + in_len;\n\tconst unsigned char * const ip_end = in + in_len - 20;\n\tconst unsigned char *ii;\n\tlzo_dict_t * const dict = (lzo_dict_t *) wrkmem;\n\n\top = out;\n\tip = in;\n\tii = ip;\n\tip += ti < 4 ? 4 - ti : 0;\n\n\tfor (;;) {\n\t\tconst unsigned char *m_pos = NULL;\n\t\tsize_t t, m_len, m_off;\n\t\tu32 dv;\n\t\tu32 run_length = 0;\nliteral:\n\t\tip += 1 + ((ip - ii) >> 5);\nnext:\n\t\tif (unlikely(ip >= ip_end))\n\t\t\tbreak;\n\t\tdv = get_unaligned_le32(ip);\n\n\t\tif (dv == 0 && bitstream_version) {\n\t\t\tconst unsigned char *ir = ip + 4;\n\t\t\tconst unsigned char *limit = min(ip_end, ip + MAX_ZERO_RUN_LENGTH + 1);\n#if defined(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS) && \\\n\tdefined(LZO_FAST_64BIT_MEMORY_ACCESS)\n\t\t\tu64 dv64;\n\n\t\t\tfor (; (ir + 32) <= limit; ir += 32) {\n\t\t\t\tdv64 = get_unaligned((u64 *)ir);\n\t\t\t\tdv64 |= get_unaligned((u64 *)ir + 1);\n\t\t\t\tdv64 |= get_unaligned((u64 *)ir + 2);\n\t\t\t\tdv64 |= get_unaligned((u64 *)ir + 3);\n\t\t\t\tif (dv64)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor (; (ir + 8) <= limit; ir += 8) {\n\t\t\t\tdv64 = get_unaligned((u64 *)ir);\n\t\t\t\tif (dv64) {\n#  if defined(__LITTLE_ENDIAN)\n\t\t\t\t\tir += __builtin_ctzll(dv64) >> 3;\n#  elif defined(__BIG_ENDIAN)\n\t\t\t\t\tir += __builtin_clzll(dv64) >> 3;\n#  else\n#    error \"missing endian definition\"\n#  endif\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n#else\n\t\t\twhile ((ir < (const unsigned char *)\n\t\t\t\t\tALIGN((uintptr_t)ir, 4)) &&\n\t\t\t\t\t(ir < limit) && (*ir == 0))\n\t\t\t\tir++;\n\t\t\tif (IS_ALIGNED((uintptr_t)ir, 4)) {\n\t\t\t\tfor (; (ir + 4) <= limit; ir += 4) {\n\t\t\t\t\tdv = *((u32 *)ir);\n\t\t\t\t\tif (dv) {\n#  if defined(__LITTLE_ENDIAN)\n\t\t\t\t\t\tir += __builtin_ctz(dv) >> 3;\n#  elif defined(__BIG_ENDIAN)\n\t\t\t\t\t\tir += __builtin_clz(dv) >> 3;\n#  else\n#    error \"missing endian definition\"\n#  endif\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n#endif\n\t\t\twhile (likely(ir < limit) && unlikely(*ir == 0))\n\t\t\t\tir++;\n\t\t\trun_length = ir - ip;\n\t\t\tif (run_length > MAX_ZERO_RUN_LENGTH)\n\t\t\t\trun_length = MAX_ZERO_RUN_LENGTH;\n\t\t} else {\n\t\t\tt = ((dv * 0x1824429d) >> (32 - D_BITS)) & D_MASK;\n\t\t\tm_pos = in + dict[t];\n\t\t\tdict[t] = (lzo_dict_t) (ip - in);\n\t\t\tif (unlikely(dv != get_unaligned_le32(m_pos)))\n\t\t\t\tgoto literal;\n\t\t}\n\n\t\tii -= ti;\n\t\tti = 0;\n\t\tt = ip - ii;\n\t\tif (t != 0) {\n\t\t\tif (t <= 3) {\n\t\t\t\top[*state_offset] |= t;\n\t\t\t\tCOPY4(op, ii);\n\t\t\t\top += t;\n\t\t\t} else if (t <= 16) {\n\t\t\t\t*op++ = (t - 3);\n\t\t\t\tCOPY8(op, ii);\n\t\t\t\tCOPY8(op + 8, ii + 8);\n\t\t\t\top += t;\n\t\t\t} else {\n\t\t\t\tif (t <= 18) {\n\t\t\t\t\t*op++ = (t - 3);\n\t\t\t\t} else {\n\t\t\t\t\tsize_t tt = t - 18;\n\t\t\t\t\t*op++ = 0;\n\t\t\t\t\twhile (unlikely(tt > 255)) {\n\t\t\t\t\t\ttt -= 255;\n\t\t\t\t\t\t*op++ = 0;\n\t\t\t\t\t}\n\t\t\t\t\t*op++ = tt;\n\t\t\t\t}\n\t\t\t\tdo {\n\t\t\t\t\tCOPY8(op, ii);\n\t\t\t\t\tCOPY8(op + 8, ii + 8);\n\t\t\t\t\top += 16;\n\t\t\t\t\tii += 16;\n\t\t\t\t\tt -= 16;\n\t\t\t\t} while (t >= 16);\n\t\t\t\tif (t > 0) do {\n\t\t\t\t\t*op++ = *ii++;\n\t\t\t\t} while (--t > 0);\n\t\t\t}\n\t\t}\n\n\t\tif (unlikely(run_length)) {\n\t\t\tip += run_length;\n\t\t\trun_length -= MIN_ZERO_RUN_LENGTH;\n\t\t\tput_unaligned_le32((run_length << 21) | 0xfffc18\n\t\t\t\t\t   | (run_length & 0x7), op);\n\t\t\top += 4;\n\t\t\trun_length = 0;\n\t\t\t*state_offset = -3;\n\t\t\tgoto finished_writing_instruction;\n\t\t}\n\n\t\tm_len = 4;\n\t\t{\n#if defined(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS) && defined(LZO_USE_CTZ64)\n\t\tu64 v;\n\t\tv = get_unaligned((const u64 *) (ip + m_len)) ^\n\t\t    get_unaligned((const u64 *) (m_pos + m_len));\n\t\tif (unlikely(v == 0)) {\n\t\t\tdo {\n\t\t\t\tm_len += 8;\n\t\t\t\tv = get_unaligned((const u64 *) (ip + m_len)) ^\n\t\t\t\t    get_unaligned((const u64 *) (m_pos + m_len));\n\t\t\t\tif (unlikely(ip + m_len >= ip_end))\n\t\t\t\t\tgoto m_len_done;\n\t\t\t} while (v == 0);\n\t\t}\n#  if defined(__LITTLE_ENDIAN)\n\t\tm_len += (unsigned) __builtin_ctzll(v) / 8;\n#  elif defined(__BIG_ENDIAN)\n\t\tm_len += (unsigned) __builtin_clzll(v) / 8;\n#  else\n#    error \"missing endian definition\"\n#  endif\n#elif defined(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS) && defined(LZO_USE_CTZ32)\n\t\tu32 v;\n\t\tv = get_unaligned((const u32 *) (ip + m_len)) ^\n\t\t    get_unaligned((const u32 *) (m_pos + m_len));\n\t\tif (unlikely(v == 0)) {\n\t\t\tdo {\n\t\t\t\tm_len += 4;\n\t\t\t\tv = get_unaligned((const u32 *) (ip + m_len)) ^\n\t\t\t\t    get_unaligned((const u32 *) (m_pos + m_len));\n\t\t\t\tif (v != 0)\n\t\t\t\t\tbreak;\n\t\t\t\tm_len += 4;\n\t\t\t\tv = get_unaligned((const u32 *) (ip + m_len)) ^\n\t\t\t\t    get_unaligned((const u32 *) (m_pos + m_len));\n\t\t\t\tif (unlikely(ip + m_len >= ip_end))\n\t\t\t\t\tgoto m_len_done;\n\t\t\t} while (v == 0);\n\t\t}\n#  if defined(__LITTLE_ENDIAN)\n\t\tm_len += (unsigned) __builtin_ctz(v) / 8;\n#  elif defined(__BIG_ENDIAN)\n\t\tm_len += (unsigned) __builtin_clz(v) / 8;\n#  else\n#    error \"missing endian definition\"\n#  endif\n#else\n\t\tif (unlikely(ip[m_len] == m_pos[m_len])) {\n\t\t\tdo {\n\t\t\t\tm_len += 1;\n\t\t\t\tif (ip[m_len] != m_pos[m_len])\n\t\t\t\t\tbreak;\n\t\t\t\tm_len += 1;\n\t\t\t\tif (ip[m_len] != m_pos[m_len])\n\t\t\t\t\tbreak;\n\t\t\t\tm_len += 1;\n\t\t\t\tif (ip[m_len] != m_pos[m_len])\n\t\t\t\t\tbreak;\n\t\t\t\tm_len += 1;\n\t\t\t\tif (ip[m_len] != m_pos[m_len])\n\t\t\t\t\tbreak;\n\t\t\t\tm_len += 1;\n\t\t\t\tif (ip[m_len] != m_pos[m_len])\n\t\t\t\t\tbreak;\n\t\t\t\tm_len += 1;\n\t\t\t\tif (ip[m_len] != m_pos[m_len])\n\t\t\t\t\tbreak;\n\t\t\t\tm_len += 1;\n\t\t\t\tif (ip[m_len] != m_pos[m_len])\n\t\t\t\t\tbreak;\n\t\t\t\tm_len += 1;\n\t\t\t\tif (unlikely(ip + m_len >= ip_end))\n\t\t\t\t\tgoto m_len_done;\n\t\t\t} while (ip[m_len] == m_pos[m_len]);\n\t\t}\n#endif\n\t\t}\nm_len_done:\n\n\t\tm_off = ip - m_pos;\n\t\tip += m_len;\n\t\tif (m_len <= M2_MAX_LEN && m_off <= M2_MAX_OFFSET) {\n\t\t\tm_off -= 1;\n\t\t\t*op++ = (((m_len - 1) << 5) | ((m_off & 7) << 2));\n\t\t\t*op++ = (m_off >> 3);\n\t\t} else if (m_off <= M3_MAX_OFFSET) {\n\t\t\tm_off -= 1;\n\t\t\tif (m_len <= M3_MAX_LEN)\n\t\t\t\t*op++ = (M3_MARKER | (m_len - 2));\n\t\t\telse {\n\t\t\t\tm_len -= M3_MAX_LEN;\n\t\t\t\t*op++ = M3_MARKER | 0;\n\t\t\t\twhile (unlikely(m_len > 255)) {\n\t\t\t\t\tm_len -= 255;\n\t\t\t\t\t*op++ = 0;\n\t\t\t\t}\n\t\t\t\t*op++ = (m_len);\n\t\t\t}\n\t\t\t*op++ = (m_off << 2);\n\t\t\t*op++ = (m_off >> 6);\n\t\t} else {\n\t\t\tm_off -= 0x4000;\n\t\t\tif (m_len <= M4_MAX_LEN)\n\t\t\t\t*op++ = (M4_MARKER | ((m_off >> 11) & 8)\n\t\t\t\t\t\t| (m_len - 2));\n\t\t\telse {\n\t\t\t\tif (unlikely(((m_off & 0x403f) == 0x403f)\n\t\t\t\t\t\t&& (m_len >= 261)\n\t\t\t\t\t\t&& (m_len <= 264))\n\t\t\t\t\t\t&& likely(bitstream_version)) {\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\tip -= m_len - 260;\n\t\t\t\t\tm_len = 260;\n\t\t\t\t}\n\t\t\t\tm_len -= M4_MAX_LEN;\n\t\t\t\t*op++ = (M4_MARKER | ((m_off >> 11) & 8));\n\t\t\t\twhile (unlikely(m_len > 255)) {\n\t\t\t\t\tm_len -= 255;\n\t\t\t\t\t*op++ = 0;\n\t\t\t\t}\n\t\t\t\t*op++ = (m_len);\n\t\t\t}\n\t\t\t*op++ = (m_off << 2);\n\t\t\t*op++ = (m_off >> 6);\n\t\t}\n\t\t*state_offset = -2;\nfinished_writing_instruction:\n\t\tii = ip;\n\t\tgoto next;\n\t}\n\t*out_len = op - out;\n\treturn in_end - (ii - ti);\n}\n\nstatic int lzogeneric1x_1_compress(const unsigned char *in, size_t in_len,\n\t\t     unsigned char *out, size_t *out_len,\n\t\t     void *wrkmem, const unsigned char bitstream_version)\n{\n\tconst unsigned char *ip = in;\n\tunsigned char *op = out;\n\tunsigned char *data_start;\n\tsize_t l = in_len;\n\tsize_t t = 0;\n\tsigned char state_offset = -2;\n\tunsigned int m4_max_offset;\n\n\t\n\t\n\tif (bitstream_version > 0) {\n\t\t*op++ = 17;\n\t\t*op++ = bitstream_version;\n\t\tm4_max_offset = M4_MAX_OFFSET_V1;\n\t} else {\n\t\tm4_max_offset = M4_MAX_OFFSET_V0;\n\t}\n\n\tdata_start = op;\n\n\twhile (l > 20) {\n\t\tsize_t ll = min_t(size_t, l, m4_max_offset + 1);\n\t\tuintptr_t ll_end = (uintptr_t) ip + ll;\n\t\tif ((ll_end + ((t + ll) >> 5)) <= ll_end)\n\t\t\tbreak;\n\t\tBUILD_BUG_ON(D_SIZE * sizeof(lzo_dict_t) > LZO1X_1_MEM_COMPRESS);\n\t\tmemset(wrkmem, 0, D_SIZE * sizeof(lzo_dict_t));\n\t\tt = lzo1x_1_do_compress(ip, ll, op, out_len, t, wrkmem,\n\t\t\t\t\t&state_offset, bitstream_version);\n\t\tip += ll;\n\t\top += *out_len;\n\t\tl  -= ll;\n\t}\n\tt += l;\n\n\tif (t > 0) {\n\t\tconst unsigned char *ii = in + in_len - t;\n\n\t\tif (op == data_start && t <= 238) {\n\t\t\t*op++ = (17 + t);\n\t\t} else if (t <= 3) {\n\t\t\top[state_offset] |= t;\n\t\t} else if (t <= 18) {\n\t\t\t*op++ = (t - 3);\n\t\t} else {\n\t\t\tsize_t tt = t - 18;\n\t\t\t*op++ = 0;\n\t\t\twhile (tt > 255) {\n\t\t\t\ttt -= 255;\n\t\t\t\t*op++ = 0;\n\t\t\t}\n\t\t\t*op++ = tt;\n\t\t}\n\t\tif (t >= 16) do {\n\t\t\tCOPY8(op, ii);\n\t\t\tCOPY8(op + 8, ii + 8);\n\t\t\top += 16;\n\t\t\tii += 16;\n\t\t\tt -= 16;\n\t\t} while (t >= 16);\n\t\tif (t > 0) do {\n\t\t\t*op++ = *ii++;\n\t\t} while (--t > 0);\n\t}\n\n\t*op++ = M4_MARKER | 1;\n\t*op++ = 0;\n\t*op++ = 0;\n\n\t*out_len = op - out;\n\treturn LZO_E_OK;\n}\n\nint lzo1x_1_compress(const unsigned char *in, size_t in_len,\n\t\t     unsigned char *out, size_t *out_len,\n\t\t     void *wrkmem)\n{\n\treturn lzogeneric1x_1_compress(in, in_len, out, out_len, wrkmem, 0);\n}\n\nint lzorle1x_1_compress(const unsigned char *in, size_t in_len,\n\t\t     unsigned char *out, size_t *out_len,\n\t\t     void *wrkmem)\n{\n\treturn lzogeneric1x_1_compress(in, in_len, out, out_len,\n\t\t\t\t       wrkmem, LZO_VERSION);\n}\n\nEXPORT_SYMBOL_GPL(lzo1x_1_compress);\nEXPORT_SYMBOL_GPL(lzorle1x_1_compress);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"LZO1X-1 Compressor\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}