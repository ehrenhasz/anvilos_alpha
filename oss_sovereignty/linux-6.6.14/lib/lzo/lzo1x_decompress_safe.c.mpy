{
  "module_name": "lzo1x_decompress_safe.c",
  "hash_id": "2f1d166d163e34549f730aa11291222e65b9a41c2fdd4b049322c4b1d60a525f",
  "original_prompt": "Ingested from linux-6.6.14/lib/lzo/lzo1x_decompress_safe.c",
  "human_readable_source": "\n \n\n#ifndef STATIC\n#include <linux/module.h>\n#include <linux/kernel.h>\n#endif\n#include <asm/unaligned.h>\n#include <linux/lzo.h>\n#include \"lzodefs.h\"\n\n#define HAVE_IP(x)      ((size_t)(ip_end - ip) >= (size_t)(x))\n#define HAVE_OP(x)      ((size_t)(op_end - op) >= (size_t)(x))\n#define NEED_IP(x)      if (!HAVE_IP(x)) goto input_overrun\n#define NEED_OP(x)      if (!HAVE_OP(x)) goto output_overrun\n#define TEST_LB(m_pos)  if ((m_pos) < out) goto lookbehind_overrun\n\n \n#define MAX_255_COUNT      ((((size_t)~0) / 255) - 2)\n\nint lzo1x_decompress_safe(const unsigned char *in, size_t in_len,\n\t\t\t  unsigned char *out, size_t *out_len)\n{\n\tunsigned char *op;\n\tconst unsigned char *ip;\n\tsize_t t, next;\n\tsize_t state = 0;\n\tconst unsigned char *m_pos;\n\tconst unsigned char * const ip_end = in + in_len;\n\tunsigned char * const op_end = out + *out_len;\n\n\tunsigned char bitstream_version;\n\n\top = out;\n\tip = in;\n\n\tif (unlikely(in_len < 3))\n\t\tgoto input_overrun;\n\n\tif (likely(in_len >= 5) && likely(*ip == 17)) {\n\t\tbitstream_version = ip[1];\n\t\tip += 2;\n\t} else {\n\t\tbitstream_version = 0;\n\t}\n\n\tif (*ip > 17) {\n\t\tt = *ip++ - 17;\n\t\tif (t < 4) {\n\t\t\tnext = t;\n\t\t\tgoto match_next;\n\t\t}\n\t\tgoto copy_literal_run;\n\t}\n\n\tfor (;;) {\n\t\tt = *ip++;\n\t\tif (t < 16) {\n\t\t\tif (likely(state == 0)) {\n\t\t\t\tif (unlikely(t == 0)) {\n\t\t\t\t\tsize_t offset;\n\t\t\t\t\tconst unsigned char *ip_last = ip;\n\n\t\t\t\t\twhile (unlikely(*ip == 0)) {\n\t\t\t\t\t\tip++;\n\t\t\t\t\t\tNEED_IP(1);\n\t\t\t\t\t}\n\t\t\t\t\toffset = ip - ip_last;\n\t\t\t\t\tif (unlikely(offset > MAX_255_COUNT))\n\t\t\t\t\t\treturn LZO_E_ERROR;\n\n\t\t\t\t\toffset = (offset << 8) - offset;\n\t\t\t\t\tt += offset + 15 + *ip++;\n\t\t\t\t}\n\t\t\t\tt += 3;\ncopy_literal_run:\n#if defined(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS)\n\t\t\t\tif (likely(HAVE_IP(t + 15) && HAVE_OP(t + 15))) {\n\t\t\t\t\tconst unsigned char *ie = ip + t;\n\t\t\t\t\tunsigned char *oe = op + t;\n\t\t\t\t\tdo {\n\t\t\t\t\t\tCOPY8(op, ip);\n\t\t\t\t\t\top += 8;\n\t\t\t\t\t\tip += 8;\n\t\t\t\t\t\tCOPY8(op, ip);\n\t\t\t\t\t\top += 8;\n\t\t\t\t\t\tip += 8;\n\t\t\t\t\t} while (ip < ie);\n\t\t\t\t\tip = ie;\n\t\t\t\t\top = oe;\n\t\t\t\t} else\n#endif\n\t\t\t\t{\n\t\t\t\t\tNEED_OP(t);\n\t\t\t\t\tNEED_IP(t + 3);\n\t\t\t\t\tdo {\n\t\t\t\t\t\t*op++ = *ip++;\n\t\t\t\t\t} while (--t > 0);\n\t\t\t\t}\n\t\t\t\tstate = 4;\n\t\t\t\tcontinue;\n\t\t\t} else if (state != 4) {\n\t\t\t\tnext = t & 3;\n\t\t\t\tm_pos = op - 1;\n\t\t\t\tm_pos -= t >> 2;\n\t\t\t\tm_pos -= *ip++ << 2;\n\t\t\t\tTEST_LB(m_pos);\n\t\t\t\tNEED_OP(2);\n\t\t\t\top[0] = m_pos[0];\n\t\t\t\top[1] = m_pos[1];\n\t\t\t\top += 2;\n\t\t\t\tgoto match_next;\n\t\t\t} else {\n\t\t\t\tnext = t & 3;\n\t\t\t\tm_pos = op - (1 + M2_MAX_OFFSET);\n\t\t\t\tm_pos -= t >> 2;\n\t\t\t\tm_pos -= *ip++ << 2;\n\t\t\t\tt = 3;\n\t\t\t}\n\t\t} else if (t >= 64) {\n\t\t\tnext = t & 3;\n\t\t\tm_pos = op - 1;\n\t\t\tm_pos -= (t >> 2) & 7;\n\t\t\tm_pos -= *ip++ << 3;\n\t\t\tt = (t >> 5) - 1 + (3 - 1);\n\t\t} else if (t >= 32) {\n\t\t\tt = (t & 31) + (3 - 1);\n\t\t\tif (unlikely(t == 2)) {\n\t\t\t\tsize_t offset;\n\t\t\t\tconst unsigned char *ip_last = ip;\n\n\t\t\t\twhile (unlikely(*ip == 0)) {\n\t\t\t\t\tip++;\n\t\t\t\t\tNEED_IP(1);\n\t\t\t\t}\n\t\t\t\toffset = ip - ip_last;\n\t\t\t\tif (unlikely(offset > MAX_255_COUNT))\n\t\t\t\t\treturn LZO_E_ERROR;\n\n\t\t\t\toffset = (offset << 8) - offset;\n\t\t\t\tt += offset + 31 + *ip++;\n\t\t\t\tNEED_IP(2);\n\t\t\t}\n\t\t\tm_pos = op - 1;\n\t\t\tnext = get_unaligned_le16(ip);\n\t\t\tip += 2;\n\t\t\tm_pos -= next >> 2;\n\t\t\tnext &= 3;\n\t\t} else {\n\t\t\tNEED_IP(2);\n\t\t\tnext = get_unaligned_le16(ip);\n\t\t\tif (((next & 0xfffc) == 0xfffc) &&\n\t\t\t    ((t & 0xf8) == 0x18) &&\n\t\t\t    likely(bitstream_version)) {\n\t\t\t\tNEED_IP(3);\n\t\t\t\tt &= 7;\n\t\t\t\tt |= ip[2] << 3;\n\t\t\t\tt += MIN_ZERO_RUN_LENGTH;\n\t\t\t\tNEED_OP(t);\n\t\t\t\tmemset(op, 0, t);\n\t\t\t\top += t;\n\t\t\t\tnext &= 3;\n\t\t\t\tip += 3;\n\t\t\t\tgoto match_next;\n\t\t\t} else {\n\t\t\t\tm_pos = op;\n\t\t\t\tm_pos -= (t & 8) << 11;\n\t\t\t\tt = (t & 7) + (3 - 1);\n\t\t\t\tif (unlikely(t == 2)) {\n\t\t\t\t\tsize_t offset;\n\t\t\t\t\tconst unsigned char *ip_last = ip;\n\n\t\t\t\t\twhile (unlikely(*ip == 0)) {\n\t\t\t\t\t\tip++;\n\t\t\t\t\t\tNEED_IP(1);\n\t\t\t\t\t}\n\t\t\t\t\toffset = ip - ip_last;\n\t\t\t\t\tif (unlikely(offset > MAX_255_COUNT))\n\t\t\t\t\t\treturn LZO_E_ERROR;\n\n\t\t\t\t\toffset = (offset << 8) - offset;\n\t\t\t\t\tt += offset + 7 + *ip++;\n\t\t\t\t\tNEED_IP(2);\n\t\t\t\t\tnext = get_unaligned_le16(ip);\n\t\t\t\t}\n\t\t\t\tip += 2;\n\t\t\t\tm_pos -= next >> 2;\n\t\t\t\tnext &= 3;\n\t\t\t\tif (m_pos == op)\n\t\t\t\t\tgoto eof_found;\n\t\t\t\tm_pos -= 0x4000;\n\t\t\t}\n\t\t}\n\t\tTEST_LB(m_pos);\n#if defined(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS)\n\t\tif (op - m_pos >= 8) {\n\t\t\tunsigned char *oe = op + t;\n\t\t\tif (likely(HAVE_OP(t + 15))) {\n\t\t\t\tdo {\n\t\t\t\t\tCOPY8(op, m_pos);\n\t\t\t\t\top += 8;\n\t\t\t\t\tm_pos += 8;\n\t\t\t\t\tCOPY8(op, m_pos);\n\t\t\t\t\top += 8;\n\t\t\t\t\tm_pos += 8;\n\t\t\t\t} while (op < oe);\n\t\t\t\top = oe;\n\t\t\t\tif (HAVE_IP(6)) {\n\t\t\t\t\tstate = next;\n\t\t\t\t\tCOPY4(op, ip);\n\t\t\t\t\top += next;\n\t\t\t\t\tip += next;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tNEED_OP(t);\n\t\t\t\tdo {\n\t\t\t\t\t*op++ = *m_pos++;\n\t\t\t\t} while (op < oe);\n\t\t\t}\n\t\t} else\n#endif\n\t\t{\n\t\t\tunsigned char *oe = op + t;\n\t\t\tNEED_OP(t);\n\t\t\top[0] = m_pos[0];\n\t\t\top[1] = m_pos[1];\n\t\t\top += 2;\n\t\t\tm_pos += 2;\n\t\t\tdo {\n\t\t\t\t*op++ = *m_pos++;\n\t\t\t} while (op < oe);\n\t\t}\nmatch_next:\n\t\tstate = next;\n\t\tt = next;\n#if defined(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS)\n\t\tif (likely(HAVE_IP(6) && HAVE_OP(4))) {\n\t\t\tCOPY4(op, ip);\n\t\t\top += t;\n\t\t\tip += t;\n\t\t} else\n#endif\n\t\t{\n\t\t\tNEED_IP(t + 3);\n\t\t\tNEED_OP(t);\n\t\t\twhile (t > 0) {\n\t\t\t\t*op++ = *ip++;\n\t\t\t\tt--;\n\t\t\t}\n\t\t}\n\t}\n\neof_found:\n\t*out_len = op - out;\n\treturn (t != 3       ? LZO_E_ERROR :\n\t\tip == ip_end ? LZO_E_OK :\n\t\tip <  ip_end ? LZO_E_INPUT_NOT_CONSUMED : LZO_E_INPUT_OVERRUN);\n\ninput_overrun:\n\t*out_len = op - out;\n\treturn LZO_E_INPUT_OVERRUN;\n\noutput_overrun:\n\t*out_len = op - out;\n\treturn LZO_E_OUTPUT_OVERRUN;\n\nlookbehind_overrun:\n\t*out_len = op - out;\n\treturn LZO_E_LOOKBEHIND_OVERRUN;\n}\n#ifndef STATIC\nEXPORT_SYMBOL_GPL(lzo1x_decompress_safe);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"LZO1X Decompressor\");\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}