{
  "module_name": "kstrtox.c",
  "hash_id": "5f4cae9c94185e471f7a1e09e91c21208d6b6580c63c49c712565f49af31e4f1",
  "original_prompt": "Ingested from linux-6.6.14/lib/kstrtox.c",
  "human_readable_source": "\n \n#include <linux/ctype.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n#include <linux/kstrtox.h>\n#include <linux/math64.h>\n#include <linux/types.h>\n#include <linux/uaccess.h>\n\n#include \"kstrtox.h\"\n\nnoinline\nconst char *_parse_integer_fixup_radix(const char *s, unsigned int *base)\n{\n\tif (*base == 0) {\n\t\tif (s[0] == '0') {\n\t\t\tif (_tolower(s[1]) == 'x' && isxdigit(s[2]))\n\t\t\t\t*base = 16;\n\t\t\telse\n\t\t\t\t*base = 8;\n\t\t} else\n\t\t\t*base = 10;\n\t}\n\tif (*base == 16 && s[0] == '0' && _tolower(s[1]) == 'x')\n\t\ts += 2;\n\treturn s;\n}\n\n \nnoinline\nunsigned int _parse_integer_limit(const char *s, unsigned int base, unsigned long long *p,\n\t\t\t\t  size_t max_chars)\n{\n\tunsigned long long res;\n\tunsigned int rv;\n\n\tres = 0;\n\trv = 0;\n\twhile (max_chars--) {\n\t\tunsigned int c = *s;\n\t\tunsigned int lc = _tolower(c);\n\t\tunsigned int val;\n\n\t\tif ('0' <= c && c <= '9')\n\t\t\tval = c - '0';\n\t\telse if ('a' <= lc && lc <= 'f')\n\t\t\tval = lc - 'a' + 10;\n\t\telse\n\t\t\tbreak;\n\n\t\tif (val >= base)\n\t\t\tbreak;\n\t\t \n\t\tif (unlikely(res & (~0ull << 60))) {\n\t\t\tif (res > div_u64(ULLONG_MAX - val, base))\n\t\t\t\trv |= KSTRTOX_OVERFLOW;\n\t\t}\n\t\tres = res * base + val;\n\t\trv++;\n\t\ts++;\n\t}\n\t*p = res;\n\treturn rv;\n}\n\nnoinline\nunsigned int _parse_integer(const char *s, unsigned int base, unsigned long long *p)\n{\n\treturn _parse_integer_limit(s, base, p, INT_MAX);\n}\n\nstatic int _kstrtoull(const char *s, unsigned int base, unsigned long long *res)\n{\n\tunsigned long long _res;\n\tunsigned int rv;\n\n\ts = _parse_integer_fixup_radix(s, &base);\n\trv = _parse_integer(s, base, &_res);\n\tif (rv & KSTRTOX_OVERFLOW)\n\t\treturn -ERANGE;\n\tif (rv == 0)\n\t\treturn -EINVAL;\n\ts += rv;\n\tif (*s == '\\n')\n\t\ts++;\n\tif (*s)\n\t\treturn -EINVAL;\n\t*res = _res;\n\treturn 0;\n}\n\n \nnoinline\nint kstrtoull(const char *s, unsigned int base, unsigned long long *res)\n{\n\tif (s[0] == '+')\n\t\ts++;\n\treturn _kstrtoull(s, base, res);\n}\nEXPORT_SYMBOL(kstrtoull);\n\n \nnoinline\nint kstrtoll(const char *s, unsigned int base, long long *res)\n{\n\tunsigned long long tmp;\n\tint rv;\n\n\tif (s[0] == '-') {\n\t\trv = _kstrtoull(s + 1, base, &tmp);\n\t\tif (rv < 0)\n\t\t\treturn rv;\n\t\tif ((long long)-tmp > 0)\n\t\t\treturn -ERANGE;\n\t\t*res = -tmp;\n\t} else {\n\t\trv = kstrtoull(s, base, &tmp);\n\t\tif (rv < 0)\n\t\t\treturn rv;\n\t\tif ((long long)tmp < 0)\n\t\t\treturn -ERANGE;\n\t\t*res = tmp;\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL(kstrtoll);\n\n \nint _kstrtoul(const char *s, unsigned int base, unsigned long *res)\n{\n\tunsigned long long tmp;\n\tint rv;\n\n\trv = kstrtoull(s, base, &tmp);\n\tif (rv < 0)\n\t\treturn rv;\n\tif (tmp != (unsigned long)tmp)\n\t\treturn -ERANGE;\n\t*res = tmp;\n\treturn 0;\n}\nEXPORT_SYMBOL(_kstrtoul);\n\n \nint _kstrtol(const char *s, unsigned int base, long *res)\n{\n\tlong long tmp;\n\tint rv;\n\n\trv = kstrtoll(s, base, &tmp);\n\tif (rv < 0)\n\t\treturn rv;\n\tif (tmp != (long)tmp)\n\t\treturn -ERANGE;\n\t*res = tmp;\n\treturn 0;\n}\nEXPORT_SYMBOL(_kstrtol);\n\n \nnoinline\nint kstrtouint(const char *s, unsigned int base, unsigned int *res)\n{\n\tunsigned long long tmp;\n\tint rv;\n\n\trv = kstrtoull(s, base, &tmp);\n\tif (rv < 0)\n\t\treturn rv;\n\tif (tmp != (unsigned int)tmp)\n\t\treturn -ERANGE;\n\t*res = tmp;\n\treturn 0;\n}\nEXPORT_SYMBOL(kstrtouint);\n\n \nnoinline\nint kstrtoint(const char *s, unsigned int base, int *res)\n{\n\tlong long tmp;\n\tint rv;\n\n\trv = kstrtoll(s, base, &tmp);\n\tif (rv < 0)\n\t\treturn rv;\n\tif (tmp != (int)tmp)\n\t\treturn -ERANGE;\n\t*res = tmp;\n\treturn 0;\n}\nEXPORT_SYMBOL(kstrtoint);\n\nnoinline\nint kstrtou16(const char *s, unsigned int base, u16 *res)\n{\n\tunsigned long long tmp;\n\tint rv;\n\n\trv = kstrtoull(s, base, &tmp);\n\tif (rv < 0)\n\t\treturn rv;\n\tif (tmp != (u16)tmp)\n\t\treturn -ERANGE;\n\t*res = tmp;\n\treturn 0;\n}\nEXPORT_SYMBOL(kstrtou16);\n\nnoinline\nint kstrtos16(const char *s, unsigned int base, s16 *res)\n{\n\tlong long tmp;\n\tint rv;\n\n\trv = kstrtoll(s, base, &tmp);\n\tif (rv < 0)\n\t\treturn rv;\n\tif (tmp != (s16)tmp)\n\t\treturn -ERANGE;\n\t*res = tmp;\n\treturn 0;\n}\nEXPORT_SYMBOL(kstrtos16);\n\nnoinline\nint kstrtou8(const char *s, unsigned int base, u8 *res)\n{\n\tunsigned long long tmp;\n\tint rv;\n\n\trv = kstrtoull(s, base, &tmp);\n\tif (rv < 0)\n\t\treturn rv;\n\tif (tmp != (u8)tmp)\n\t\treturn -ERANGE;\n\t*res = tmp;\n\treturn 0;\n}\nEXPORT_SYMBOL(kstrtou8);\n\nnoinline\nint kstrtos8(const char *s, unsigned int base, s8 *res)\n{\n\tlong long tmp;\n\tint rv;\n\n\trv = kstrtoll(s, base, &tmp);\n\tif (rv < 0)\n\t\treturn rv;\n\tif (tmp != (s8)tmp)\n\t\treturn -ERANGE;\n\t*res = tmp;\n\treturn 0;\n}\nEXPORT_SYMBOL(kstrtos8);\n\n \nnoinline\nint kstrtobool(const char *s, bool *res)\n{\n\tif (!s)\n\t\treturn -EINVAL;\n\n\tswitch (s[0]) {\n\tcase 'y':\n\tcase 'Y':\n\tcase 't':\n\tcase 'T':\n\tcase '1':\n\t\t*res = true;\n\t\treturn 0;\n\tcase 'n':\n\tcase 'N':\n\tcase 'f':\n\tcase 'F':\n\tcase '0':\n\t\t*res = false;\n\t\treturn 0;\n\tcase 'o':\n\tcase 'O':\n\t\tswitch (s[1]) {\n\t\tcase 'n':\n\t\tcase 'N':\n\t\t\t*res = true;\n\t\t\treturn 0;\n\t\tcase 'f':\n\t\tcase 'F':\n\t\t\t*res = false;\n\t\t\treturn 0;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn -EINVAL;\n}\nEXPORT_SYMBOL(kstrtobool);\n\n \nint kstrtobool_from_user(const char __user *s, size_t count, bool *res)\n{\n\t \n\tchar buf[4];\n\n\tcount = min(count, sizeof(buf) - 1);\n\tif (copy_from_user(buf, s, count))\n\t\treturn -EFAULT;\n\tbuf[count] = '\\0';\n\treturn kstrtobool(buf, res);\n}\nEXPORT_SYMBOL(kstrtobool_from_user);\n\n#define kstrto_from_user(f, g, type)\t\t\t\t\t\\\nint f(const char __user *s, size_t count, unsigned int base, type *res)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\t \t\t\\\n\tchar buf[1 + sizeof(type) * 8 + 1 + 1];\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tcount = min(count, sizeof(buf) - 1);\t\t\t\t\\\n\tif (copy_from_user(buf, s, count))\t\t\t\t\\\n\t\treturn -EFAULT;\t\t\t\t\t\t\\\n\tbuf[count] = '\\0';\t\t\t\t\t\t\\\n\treturn g(buf, base, res);\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\nEXPORT_SYMBOL(f)\n\nkstrto_from_user(kstrtoull_from_user,\tkstrtoull,\tunsigned long long);\nkstrto_from_user(kstrtoll_from_user,\tkstrtoll,\tlong long);\nkstrto_from_user(kstrtoul_from_user,\tkstrtoul,\tunsigned long);\nkstrto_from_user(kstrtol_from_user,\tkstrtol,\tlong);\nkstrto_from_user(kstrtouint_from_user,\tkstrtouint,\tunsigned int);\nkstrto_from_user(kstrtoint_from_user,\tkstrtoint,\tint);\nkstrto_from_user(kstrtou16_from_user,\tkstrtou16,\tu16);\nkstrto_from_user(kstrtos16_from_user,\tkstrtos16,\ts16);\nkstrto_from_user(kstrtou8_from_user,\tkstrtou8,\tu8);\nkstrto_from_user(kstrtos8_from_user,\tkstrtos8,\ts8);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}