{
  "module_name": "seq_buf.c",
  "hash_id": "c42a55e7ad01490a92e61c8c1f3ea60a35cc66c906f9dabbb92888f54022bf6a",
  "original_prompt": "Ingested from linux-6.6.14/lib/seq_buf.c",
  "human_readable_source": "\n \n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/seq_buf.h>\n\n \nstatic bool seq_buf_can_fit(struct seq_buf *s, size_t len)\n{\n\treturn s->len + len <= s->size;\n}\n\n \nint seq_buf_print_seq(struct seq_file *m, struct seq_buf *s)\n{\n\tunsigned int len = seq_buf_used(s);\n\n\treturn seq_write(m, s->buffer, len);\n}\n\n \nint seq_buf_vprintf(struct seq_buf *s, const char *fmt, va_list args)\n{\n\tint len;\n\n\tWARN_ON(s->size == 0);\n\n\tif (s->len < s->size) {\n\t\tlen = vsnprintf(s->buffer + s->len, s->size - s->len, fmt, args);\n\t\tif (s->len + len < s->size) {\n\t\t\ts->len += len;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tseq_buf_set_overflow(s);\n\treturn -1;\n}\n\n \nint seq_buf_printf(struct seq_buf *s, const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\n\tva_start(ap, fmt);\n\tret = seq_buf_vprintf(s, fmt, ap);\n\tva_end(ap);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(seq_buf_printf);\n\n \nvoid seq_buf_do_printk(struct seq_buf *s, const char *lvl)\n{\n\tconst char *start, *lf;\n\n\tif (s->size == 0 || s->len == 0)\n\t\treturn;\n\n\tseq_buf_terminate(s);\n\n\tstart = s->buffer;\n\twhile ((lf = strchr(start, '\\n'))) {\n\t\tint len = lf - start + 1;\n\n\t\tprintk(\"%s%.*s\", lvl, len, start);\n\t\tstart = ++lf;\n\t}\n\n\t \n\tif (start < s->buffer + s->len)\n\t\tprintk(\"%s%s\\n\", lvl, start);\n}\nEXPORT_SYMBOL_GPL(seq_buf_do_printk);\n\n#ifdef CONFIG_BINARY_PRINTF\n \nint seq_buf_bprintf(struct seq_buf *s, const char *fmt, const u32 *binary)\n{\n\tunsigned int len = seq_buf_buffer_left(s);\n\tint ret;\n\n\tWARN_ON(s->size == 0);\n\n\tif (s->len < s->size) {\n\t\tret = bstr_printf(s->buffer + s->len, len, fmt, binary);\n\t\tif (s->len + ret < s->size) {\n\t\t\ts->len += ret;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tseq_buf_set_overflow(s);\n\treturn -1;\n}\n#endif  \n\n \nint seq_buf_puts(struct seq_buf *s, const char *str)\n{\n\tsize_t len = strlen(str);\n\n\tWARN_ON(s->size == 0);\n\n\t \n\tlen += 1;\n\n\tif (seq_buf_can_fit(s, len)) {\n\t\tmemcpy(s->buffer + s->len, str, len);\n\t\t \n\t\ts->len += len - 1;\n\t\treturn 0;\n\t}\n\tseq_buf_set_overflow(s);\n\treturn -1;\n}\n\n \nint seq_buf_putc(struct seq_buf *s, unsigned char c)\n{\n\tWARN_ON(s->size == 0);\n\n\tif (seq_buf_can_fit(s, 1)) {\n\t\ts->buffer[s->len++] = c;\n\t\treturn 0;\n\t}\n\tseq_buf_set_overflow(s);\n\treturn -1;\n}\n\n \nint seq_buf_putmem(struct seq_buf *s, const void *mem, unsigned int len)\n{\n\tWARN_ON(s->size == 0);\n\n\tif (seq_buf_can_fit(s, len)) {\n\t\tmemcpy(s->buffer + s->len, mem, len);\n\t\ts->len += len;\n\t\treturn 0;\n\t}\n\tseq_buf_set_overflow(s);\n\treturn -1;\n}\n\n#define MAX_MEMHEX_BYTES\t8U\n#define HEX_CHARS\t\t(MAX_MEMHEX_BYTES*2 + 1)\n\n \nint seq_buf_putmem_hex(struct seq_buf *s, const void *mem,\n\t\t       unsigned int len)\n{\n\tunsigned char hex[HEX_CHARS];\n\tconst unsigned char *data = mem;\n\tunsigned int start_len;\n\tint i, j;\n\n\tWARN_ON(s->size == 0);\n\n\tBUILD_BUG_ON(MAX_MEMHEX_BYTES * 2 >= HEX_CHARS);\n\n\twhile (len) {\n\t\tstart_len = min(len, MAX_MEMHEX_BYTES);\n#ifdef __BIG_ENDIAN\n\t\tfor (i = 0, j = 0; i < start_len; i++) {\n#else\n\t\tfor (i = start_len-1, j = 0; i >= 0; i--) {\n#endif\n\t\t\thex[j++] = hex_asc_hi(data[i]);\n\t\t\thex[j++] = hex_asc_lo(data[i]);\n\t\t}\n\t\tif (WARN_ON_ONCE(j == 0 || j/2 > len))\n\t\t\tbreak;\n\n\t\t \n\t\thex[j++] = ' ';\n\n\t\tseq_buf_putmem(s, hex, j);\n\t\tif (seq_buf_has_overflowed(s))\n\t\t\treturn -1;\n\n\t\tlen -= start_len;\n\t\tdata += start_len;\n\t}\n\treturn 0;\n}\n\n \nint seq_buf_path(struct seq_buf *s, const struct path *path, const char *esc)\n{\n\tchar *buf;\n\tsize_t size = seq_buf_get_buf(s, &buf);\n\tint res = -1;\n\n\tWARN_ON(s->size == 0);\n\n\tif (size) {\n\t\tchar *p = d_path(path, buf, size);\n\t\tif (!IS_ERR(p)) {\n\t\t\tchar *end = mangle_path(buf, p, esc);\n\t\t\tif (end)\n\t\t\t\tres = end - buf;\n\t\t}\n\t}\n\tseq_buf_commit(s, res);\n\n\treturn res;\n}\n\n \nint seq_buf_to_user(struct seq_buf *s, char __user *ubuf, int cnt)\n{\n\tint len;\n\tint ret;\n\n\tif (!cnt)\n\t\treturn 0;\n\n\tlen = seq_buf_used(s);\n\n\tif (len <= s->readpos)\n\t\treturn -EBUSY;\n\n\tlen -= s->readpos;\n\tif (cnt > len)\n\t\tcnt = len;\n\tret = copy_to_user(ubuf, s->buffer + s->readpos, cnt);\n\tif (ret == cnt)\n\t\treturn -EFAULT;\n\n\tcnt -= ret;\n\n\ts->readpos += cnt;\n\treturn cnt;\n}\n\n \nint seq_buf_hex_dump(struct seq_buf *s, const char *prefix_str, int prefix_type,\n\t\t     int rowsize, int groupsize,\n\t\t     const void *buf, size_t len, bool ascii)\n{\n\tconst u8 *ptr = buf;\n\tint i, linelen, remaining = len;\n\tunsigned char linebuf[32 * 3 + 2 + 32 + 1];\n\tint ret;\n\n\tif (rowsize != 16 && rowsize != 32)\n\t\trowsize = 16;\n\n\tfor (i = 0; i < len; i += rowsize) {\n\t\tlinelen = min(remaining, rowsize);\n\t\tremaining -= rowsize;\n\n\t\thex_dump_to_buffer(ptr + i, linelen, rowsize, groupsize,\n\t\t\t\t   linebuf, sizeof(linebuf), ascii);\n\n\t\tswitch (prefix_type) {\n\t\tcase DUMP_PREFIX_ADDRESS:\n\t\t\tret = seq_buf_printf(s, \"%s%p: %s\\n\",\n\t\t\t       prefix_str, ptr + i, linebuf);\n\t\t\tbreak;\n\t\tcase DUMP_PREFIX_OFFSET:\n\t\t\tret = seq_buf_printf(s, \"%s%.8x: %s\\n\",\n\t\t\t\t\t     prefix_str, i, linebuf);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = seq_buf_printf(s, \"%s%s\\n\", prefix_str, linebuf);\n\t\t\tbreak;\n\t\t}\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}