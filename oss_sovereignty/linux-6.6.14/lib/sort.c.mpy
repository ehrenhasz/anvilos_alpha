{
  "module_name": "sort.c",
  "hash_id": "6af58c164d20dd12b7c7b98a0321b966ee30913379bbd350716c51db6fa84223",
  "original_prompt": "Ingested from linux-6.6.14/lib/sort.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/types.h>\n#include <linux/export.h>\n#include <linux/sort.h>\n\n \n__attribute_const__ __always_inline\nstatic bool is_aligned(const void *base, size_t size, unsigned char align)\n{\n\tunsigned char lsbits = (unsigned char)size;\n\n\t(void)base;\n#ifndef CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS\n\tlsbits |= (unsigned char)(uintptr_t)base;\n#endif\n\treturn (lsbits & (align - 1)) == 0;\n}\n\n \nstatic void swap_words_32(void *a, void *b, size_t n)\n{\n\tdo {\n\t\tu32 t = *(u32 *)(a + (n -= 4));\n\t\t*(u32 *)(a + n) = *(u32 *)(b + n);\n\t\t*(u32 *)(b + n) = t;\n\t} while (n);\n}\n\n \nstatic void swap_words_64(void *a, void *b, size_t n)\n{\n\tdo {\n#ifdef CONFIG_64BIT\n\t\tu64 t = *(u64 *)(a + (n -= 8));\n\t\t*(u64 *)(a + n) = *(u64 *)(b + n);\n\t\t*(u64 *)(b + n) = t;\n#else\n\t\t \n\t\tu32 t = *(u32 *)(a + (n -= 4));\n\t\t*(u32 *)(a + n) = *(u32 *)(b + n);\n\t\t*(u32 *)(b + n) = t;\n\n\t\tt = *(u32 *)(a + (n -= 4));\n\t\t*(u32 *)(a + n) = *(u32 *)(b + n);\n\t\t*(u32 *)(b + n) = t;\n#endif\n\t} while (n);\n}\n\n \nstatic void swap_bytes(void *a, void *b, size_t n)\n{\n\tdo {\n\t\tchar t = ((char *)a)[--n];\n\t\t((char *)a)[n] = ((char *)b)[n];\n\t\t((char *)b)[n] = t;\n\t} while (n);\n}\n\n \n#define SWAP_WORDS_64 (swap_r_func_t)0\n#define SWAP_WORDS_32 (swap_r_func_t)1\n#define SWAP_BYTES    (swap_r_func_t)2\n#define SWAP_WRAPPER  (swap_r_func_t)3\n\nstruct wrapper {\n\tcmp_func_t cmp;\n\tswap_func_t swap;\n};\n\n \nstatic void do_swap(void *a, void *b, size_t size, swap_r_func_t swap_func, const void *priv)\n{\n\tif (swap_func == SWAP_WRAPPER) {\n\t\t((const struct wrapper *)priv)->swap(a, b, (int)size);\n\t\treturn;\n\t}\n\n\tif (swap_func == SWAP_WORDS_64)\n\t\tswap_words_64(a, b, size);\n\telse if (swap_func == SWAP_WORDS_32)\n\t\tswap_words_32(a, b, size);\n\telse if (swap_func == SWAP_BYTES)\n\t\tswap_bytes(a, b, size);\n\telse\n\t\tswap_func(a, b, (int)size, priv);\n}\n\n#define _CMP_WRAPPER ((cmp_r_func_t)0L)\n\nstatic int do_cmp(const void *a, const void *b, cmp_r_func_t cmp, const void *priv)\n{\n\tif (cmp == _CMP_WRAPPER)\n\t\treturn ((const struct wrapper *)priv)->cmp(a, b);\n\treturn cmp(a, b, priv);\n}\n\n \n__attribute_const__ __always_inline\nstatic size_t parent(size_t i, unsigned int lsbit, size_t size)\n{\n\ti -= size;\n\ti -= size & -(i & lsbit);\n\treturn i / 2;\n}\n\n \nvoid sort_r(void *base, size_t num, size_t size,\n\t    cmp_r_func_t cmp_func,\n\t    swap_r_func_t swap_func,\n\t    const void *priv)\n{\n\t \n\tsize_t n = num * size, a = (num/2) * size;\n\tconst unsigned int lsbit = size & -size;   \n\n\tif (!a)\t\t \n\t\treturn;\n\n\t \n\tif (swap_func == SWAP_WRAPPER && !((struct wrapper *)priv)->swap)\n\t\tswap_func = NULL;\n\n\tif (!swap_func) {\n\t\tif (is_aligned(base, size, 8))\n\t\t\tswap_func = SWAP_WORDS_64;\n\t\telse if (is_aligned(base, size, 4))\n\t\t\tswap_func = SWAP_WORDS_32;\n\t\telse\n\t\t\tswap_func = SWAP_BYTES;\n\t}\n\n\t \n\tfor (;;) {\n\t\tsize_t b, c, d;\n\n\t\tif (a)\t\t\t \n\t\t\ta -= size;\n\t\telse if (n -= size)\t \n\t\t\tdo_swap(base, base + n, size, swap_func, priv);\n\t\telse\t\t\t \n\t\t\tbreak;\n\n\t\t \n\t\tfor (b = a; c = 2*b + size, (d = c + size) < n;)\n\t\t\tb = do_cmp(base + c, base + d, cmp_func, priv) >= 0 ? c : d;\n\t\tif (d == n)\t \n\t\t\tb = c;\n\n\t\t \n\t\twhile (b != a && do_cmp(base + a, base + b, cmp_func, priv) >= 0)\n\t\t\tb = parent(b, lsbit, size);\n\t\tc = b;\t\t\t \n\t\twhile (b != a) {\t \n\t\t\tb = parent(b, lsbit, size);\n\t\t\tdo_swap(base + b, base + c, size, swap_func, priv);\n\t\t}\n\t}\n}\nEXPORT_SYMBOL(sort_r);\n\nvoid sort(void *base, size_t num, size_t size,\n\t  cmp_func_t cmp_func,\n\t  swap_func_t swap_func)\n{\n\tstruct wrapper w = {\n\t\t.cmp  = cmp_func,\n\t\t.swap = swap_func,\n\t};\n\n\treturn sort_r(base, num, size, _CMP_WRAPPER, SWAP_WRAPPER, &w);\n}\nEXPORT_SYMBOL(sort);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}