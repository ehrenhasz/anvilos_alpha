{
  "module_name": "klist.c",
  "hash_id": "148964962d757e08586e7beabfd14ede9539e6de541f7463632b81853a1cb395",
  "original_prompt": "Ingested from linux-6.6.14/lib/klist.c",
  "human_readable_source": "\n \n\n#include <linux/klist.h>\n#include <linux/export.h>\n#include <linux/sched.h>\n\n \n#define KNODE_DEAD\t\t1LU\n#define KNODE_KLIST_MASK\t~KNODE_DEAD\n\nstatic struct klist *knode_klist(struct klist_node *knode)\n{\n\treturn (struct klist *)\n\t\t((unsigned long)knode->n_klist & KNODE_KLIST_MASK);\n}\n\nstatic bool knode_dead(struct klist_node *knode)\n{\n\treturn (unsigned long)knode->n_klist & KNODE_DEAD;\n}\n\nstatic void knode_set_klist(struct klist_node *knode, struct klist *klist)\n{\n\tknode->n_klist = klist;\n\t \n\tWARN_ON(knode_dead(knode));\n}\n\nstatic void knode_kill(struct klist_node *knode)\n{\n\t \n\tWARN_ON(knode_dead(knode));\n\t*(unsigned long *)&knode->n_klist |= KNODE_DEAD;\n}\n\n \nvoid klist_init(struct klist *k, void (*get)(struct klist_node *),\n\t\tvoid (*put)(struct klist_node *))\n{\n\tINIT_LIST_HEAD(&k->k_list);\n\tspin_lock_init(&k->k_lock);\n\tk->get = get;\n\tk->put = put;\n}\nEXPORT_SYMBOL_GPL(klist_init);\n\nstatic void add_head(struct klist *k, struct klist_node *n)\n{\n\tspin_lock(&k->k_lock);\n\tlist_add(&n->n_node, &k->k_list);\n\tspin_unlock(&k->k_lock);\n}\n\nstatic void add_tail(struct klist *k, struct klist_node *n)\n{\n\tspin_lock(&k->k_lock);\n\tlist_add_tail(&n->n_node, &k->k_list);\n\tspin_unlock(&k->k_lock);\n}\n\nstatic void klist_node_init(struct klist *k, struct klist_node *n)\n{\n\tINIT_LIST_HEAD(&n->n_node);\n\tkref_init(&n->n_ref);\n\tknode_set_klist(n, k);\n\tif (k->get)\n\t\tk->get(n);\n}\n\n \nvoid klist_add_head(struct klist_node *n, struct klist *k)\n{\n\tklist_node_init(k, n);\n\tadd_head(k, n);\n}\nEXPORT_SYMBOL_GPL(klist_add_head);\n\n \nvoid klist_add_tail(struct klist_node *n, struct klist *k)\n{\n\tklist_node_init(k, n);\n\tadd_tail(k, n);\n}\nEXPORT_SYMBOL_GPL(klist_add_tail);\n\n \nvoid klist_add_behind(struct klist_node *n, struct klist_node *pos)\n{\n\tstruct klist *k = knode_klist(pos);\n\n\tklist_node_init(k, n);\n\tspin_lock(&k->k_lock);\n\tlist_add(&n->n_node, &pos->n_node);\n\tspin_unlock(&k->k_lock);\n}\nEXPORT_SYMBOL_GPL(klist_add_behind);\n\n \nvoid klist_add_before(struct klist_node *n, struct klist_node *pos)\n{\n\tstruct klist *k = knode_klist(pos);\n\n\tklist_node_init(k, n);\n\tspin_lock(&k->k_lock);\n\tlist_add_tail(&n->n_node, &pos->n_node);\n\tspin_unlock(&k->k_lock);\n}\nEXPORT_SYMBOL_GPL(klist_add_before);\n\nstruct klist_waiter {\n\tstruct list_head list;\n\tstruct klist_node *node;\n\tstruct task_struct *process;\n\tint woken;\n};\n\nstatic DEFINE_SPINLOCK(klist_remove_lock);\nstatic LIST_HEAD(klist_remove_waiters);\n\nstatic void klist_release(struct kref *kref)\n{\n\tstruct klist_waiter *waiter, *tmp;\n\tstruct klist_node *n = container_of(kref, struct klist_node, n_ref);\n\n\tWARN_ON(!knode_dead(n));\n\tlist_del(&n->n_node);\n\tspin_lock(&klist_remove_lock);\n\tlist_for_each_entry_safe(waiter, tmp, &klist_remove_waiters, list) {\n\t\tif (waiter->node != n)\n\t\t\tcontinue;\n\n\t\tlist_del(&waiter->list);\n\t\twaiter->woken = 1;\n\t\tmb();\n\t\twake_up_process(waiter->process);\n\t}\n\tspin_unlock(&klist_remove_lock);\n\tknode_set_klist(n, NULL);\n}\n\nstatic int klist_dec_and_del(struct klist_node *n)\n{\n\treturn kref_put(&n->n_ref, klist_release);\n}\n\nstatic void klist_put(struct klist_node *n, bool kill)\n{\n\tstruct klist *k = knode_klist(n);\n\tvoid (*put)(struct klist_node *) = k->put;\n\n\tspin_lock(&k->k_lock);\n\tif (kill)\n\t\tknode_kill(n);\n\tif (!klist_dec_and_del(n))\n\t\tput = NULL;\n\tspin_unlock(&k->k_lock);\n\tif (put)\n\t\tput(n);\n}\n\n \nvoid klist_del(struct klist_node *n)\n{\n\tklist_put(n, true);\n}\nEXPORT_SYMBOL_GPL(klist_del);\n\n \nvoid klist_remove(struct klist_node *n)\n{\n\tstruct klist_waiter waiter;\n\n\twaiter.node = n;\n\twaiter.process = current;\n\twaiter.woken = 0;\n\tspin_lock(&klist_remove_lock);\n\tlist_add(&waiter.list, &klist_remove_waiters);\n\tspin_unlock(&klist_remove_lock);\n\n\tklist_del(n);\n\n\tfor (;;) {\n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\tif (waiter.woken)\n\t\t\tbreak;\n\t\tschedule();\n\t}\n\t__set_current_state(TASK_RUNNING);\n}\nEXPORT_SYMBOL_GPL(klist_remove);\n\n \nint klist_node_attached(struct klist_node *n)\n{\n\treturn (n->n_klist != NULL);\n}\nEXPORT_SYMBOL_GPL(klist_node_attached);\n\n \nvoid klist_iter_init_node(struct klist *k, struct klist_iter *i,\n\t\t\t  struct klist_node *n)\n{\n\ti->i_klist = k;\n\ti->i_cur = NULL;\n\tif (n && kref_get_unless_zero(&n->n_ref))\n\t\ti->i_cur = n;\n}\nEXPORT_SYMBOL_GPL(klist_iter_init_node);\n\n \nvoid klist_iter_init(struct klist *k, struct klist_iter *i)\n{\n\tklist_iter_init_node(k, i, NULL);\n}\nEXPORT_SYMBOL_GPL(klist_iter_init);\n\n \nvoid klist_iter_exit(struct klist_iter *i)\n{\n\tif (i->i_cur) {\n\t\tklist_put(i->i_cur, false);\n\t\ti->i_cur = NULL;\n\t}\n}\nEXPORT_SYMBOL_GPL(klist_iter_exit);\n\nstatic struct klist_node *to_klist_node(struct list_head *n)\n{\n\treturn container_of(n, struct klist_node, n_node);\n}\n\n \nstruct klist_node *klist_prev(struct klist_iter *i)\n{\n\tvoid (*put)(struct klist_node *) = i->i_klist->put;\n\tstruct klist_node *last = i->i_cur;\n\tstruct klist_node *prev;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&i->i_klist->k_lock, flags);\n\n\tif (last) {\n\t\tprev = to_klist_node(last->n_node.prev);\n\t\tif (!klist_dec_and_del(last))\n\t\t\tput = NULL;\n\t} else\n\t\tprev = to_klist_node(i->i_klist->k_list.prev);\n\n\ti->i_cur = NULL;\n\twhile (prev != to_klist_node(&i->i_klist->k_list)) {\n\t\tif (likely(!knode_dead(prev))) {\n\t\t\tkref_get(&prev->n_ref);\n\t\t\ti->i_cur = prev;\n\t\t\tbreak;\n\t\t}\n\t\tprev = to_klist_node(prev->n_node.prev);\n\t}\n\n\tspin_unlock_irqrestore(&i->i_klist->k_lock, flags);\n\n\tif (put && last)\n\t\tput(last);\n\treturn i->i_cur;\n}\nEXPORT_SYMBOL_GPL(klist_prev);\n\n \nstruct klist_node *klist_next(struct klist_iter *i)\n{\n\tvoid (*put)(struct klist_node *) = i->i_klist->put;\n\tstruct klist_node *last = i->i_cur;\n\tstruct klist_node *next;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&i->i_klist->k_lock, flags);\n\n\tif (last) {\n\t\tnext = to_klist_node(last->n_node.next);\n\t\tif (!klist_dec_and_del(last))\n\t\t\tput = NULL;\n\t} else\n\t\tnext = to_klist_node(i->i_klist->k_list.next);\n\n\ti->i_cur = NULL;\n\twhile (next != to_klist_node(&i->i_klist->k_list)) {\n\t\tif (likely(!knode_dead(next))) {\n\t\t\tkref_get(&next->n_ref);\n\t\t\ti->i_cur = next;\n\t\t\tbreak;\n\t\t}\n\t\tnext = to_klist_node(next->n_node.next);\n\t}\n\n\tspin_unlock_irqrestore(&i->i_klist->k_lock, flags);\n\n\tif (put && last)\n\t\tput(last);\n\treturn i->i_cur;\n}\nEXPORT_SYMBOL_GPL(klist_next);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}