{
  "module_name": "nlattr.c",
  "hash_id": "e6696cef4e517594112c3754e1aa2de98d6f58601fbf2533ee5877cedc5597ea",
  "original_prompt": "Ingested from linux-6.6.14/lib/nlattr.c",
  "human_readable_source": "\n \n\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/jiffies.h>\n#include <linux/nospec.h>\n#include <linux/skbuff.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <net/netlink.h>\n\n \nstatic const u8 nla_attr_len[NLA_TYPE_MAX+1] = {\n\t[NLA_U8]\t= sizeof(u8),\n\t[NLA_U16]\t= sizeof(u16),\n\t[NLA_U32]\t= sizeof(u32),\n\t[NLA_U64]\t= sizeof(u64),\n\t[NLA_S8]\t= sizeof(s8),\n\t[NLA_S16]\t= sizeof(s16),\n\t[NLA_S32]\t= sizeof(s32),\n\t[NLA_S64]\t= sizeof(s64),\n};\n\nstatic const u8 nla_attr_minlen[NLA_TYPE_MAX+1] = {\n\t[NLA_U8]\t= sizeof(u8),\n\t[NLA_U16]\t= sizeof(u16),\n\t[NLA_U32]\t= sizeof(u32),\n\t[NLA_U64]\t= sizeof(u64),\n\t[NLA_MSECS]\t= sizeof(u64),\n\t[NLA_NESTED]\t= NLA_HDRLEN,\n\t[NLA_S8]\t= sizeof(s8),\n\t[NLA_S16]\t= sizeof(s16),\n\t[NLA_S32]\t= sizeof(s32),\n\t[NLA_S64]\t= sizeof(s64),\n};\n\n \n#define MAX_POLICY_RECURSION_DEPTH\t10\n\nstatic int __nla_validate_parse(const struct nlattr *head, int len, int maxtype,\n\t\t\t\tconst struct nla_policy *policy,\n\t\t\t\tunsigned int validate,\n\t\t\t\tstruct netlink_ext_ack *extack,\n\t\t\t\tstruct nlattr **tb, unsigned int depth);\n\nstatic int validate_nla_bitfield32(const struct nlattr *nla,\n\t\t\t\t   const u32 valid_flags_mask)\n{\n\tconst struct nla_bitfield32 *bf = nla_data(nla);\n\n\tif (!valid_flags_mask)\n\t\treturn -EINVAL;\n\n\t \n\tif (bf->selector & ~valid_flags_mask)\n\t\treturn -EINVAL;\n\n\t \n\tif (bf->value & ~valid_flags_mask)\n\t\treturn -EINVAL;\n\n\t \n\tif (bf->value & ~bf->selector)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int nla_validate_array(const struct nlattr *head, int len, int maxtype,\n\t\t\t      const struct nla_policy *policy,\n\t\t\t      struct netlink_ext_ack *extack,\n\t\t\t      unsigned int validate, unsigned int depth)\n{\n\tconst struct nlattr *entry;\n\tint rem;\n\n\tnla_for_each_attr(entry, head, len, rem) {\n\t\tint ret;\n\n\t\tif (nla_len(entry) == 0)\n\t\t\tcontinue;\n\n\t\tif (nla_len(entry) < NLA_HDRLEN) {\n\t\t\tNL_SET_ERR_MSG_ATTR_POL(extack, entry, policy,\n\t\t\t\t\t\t\"Array element too short\");\n\t\t\treturn -ERANGE;\n\t\t}\n\n\t\tret = __nla_validate_parse(nla_data(entry), nla_len(entry),\n\t\t\t\t\t   maxtype, policy, validate, extack,\n\t\t\t\t\t   NULL, depth + 1);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nvoid nla_get_range_unsigned(const struct nla_policy *pt,\n\t\t\t    struct netlink_range_validation *range)\n{\n\tWARN_ON_ONCE(pt->validation_type != NLA_VALIDATE_RANGE_PTR &&\n\t\t     (pt->min < 0 || pt->max < 0));\n\n\trange->min = 0;\n\n\tswitch (pt->type) {\n\tcase NLA_U8:\n\t\trange->max = U8_MAX;\n\t\tbreak;\n\tcase NLA_U16:\n\tcase NLA_BE16:\n\tcase NLA_BINARY:\n\t\trange->max = U16_MAX;\n\t\tbreak;\n\tcase NLA_U32:\n\tcase NLA_BE32:\n\t\trange->max = U32_MAX;\n\t\tbreak;\n\tcase NLA_U64:\n\tcase NLA_MSECS:\n\t\trange->max = U64_MAX;\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\treturn;\n\t}\n\n\tswitch (pt->validation_type) {\n\tcase NLA_VALIDATE_RANGE:\n\tcase NLA_VALIDATE_RANGE_WARN_TOO_LONG:\n\t\trange->min = pt->min;\n\t\trange->max = pt->max;\n\t\tbreak;\n\tcase NLA_VALIDATE_RANGE_PTR:\n\t\t*range = *pt->range;\n\t\tbreak;\n\tcase NLA_VALIDATE_MIN:\n\t\trange->min = pt->min;\n\t\tbreak;\n\tcase NLA_VALIDATE_MAX:\n\t\trange->max = pt->max;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic int nla_validate_range_unsigned(const struct nla_policy *pt,\n\t\t\t\t       const struct nlattr *nla,\n\t\t\t\t       struct netlink_ext_ack *extack,\n\t\t\t\t       unsigned int validate)\n{\n\tstruct netlink_range_validation range;\n\tu64 value;\n\n\tswitch (pt->type) {\n\tcase NLA_U8:\n\t\tvalue = nla_get_u8(nla);\n\t\tbreak;\n\tcase NLA_U16:\n\t\tvalue = nla_get_u16(nla);\n\t\tbreak;\n\tcase NLA_U32:\n\t\tvalue = nla_get_u32(nla);\n\t\tbreak;\n\tcase NLA_U64:\n\t\tvalue = nla_get_u64(nla);\n\t\tbreak;\n\tcase NLA_MSECS:\n\t\tvalue = nla_get_u64(nla);\n\t\tbreak;\n\tcase NLA_BINARY:\n\t\tvalue = nla_len(nla);\n\t\tbreak;\n\tcase NLA_BE16:\n\t\tvalue = ntohs(nla_get_be16(nla));\n\t\tbreak;\n\tcase NLA_BE32:\n\t\tvalue = ntohl(nla_get_be32(nla));\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tnla_get_range_unsigned(pt, &range);\n\n\tif (pt->validation_type == NLA_VALIDATE_RANGE_WARN_TOO_LONG &&\n\t    pt->type == NLA_BINARY && value > range.max) {\n\t\tpr_warn_ratelimited(\"netlink: '%s': attribute type %d has an invalid length.\\n\",\n\t\t\t\t    current->comm, pt->type);\n\t\tif (validate & NL_VALIDATE_STRICT_ATTRS) {\n\t\t\tNL_SET_ERR_MSG_ATTR_POL(extack, nla, pt,\n\t\t\t\t\t\t\"invalid attribute length\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\treturn 0;\n\t}\n\n\tif (value < range.min || value > range.max) {\n\t\tbool binary = pt->type == NLA_BINARY;\n\n\t\tif (binary)\n\t\t\tNL_SET_ERR_MSG_ATTR_POL(extack, nla, pt,\n\t\t\t\t\t\t\"binary attribute size out of range\");\n\t\telse\n\t\t\tNL_SET_ERR_MSG_ATTR_POL(extack, nla, pt,\n\t\t\t\t\t\t\"integer out of range\");\n\n\t\treturn -ERANGE;\n\t}\n\n\treturn 0;\n}\n\nvoid nla_get_range_signed(const struct nla_policy *pt,\n\t\t\t  struct netlink_range_validation_signed *range)\n{\n\tswitch (pt->type) {\n\tcase NLA_S8:\n\t\trange->min = S8_MIN;\n\t\trange->max = S8_MAX;\n\t\tbreak;\n\tcase NLA_S16:\n\t\trange->min = S16_MIN;\n\t\trange->max = S16_MAX;\n\t\tbreak;\n\tcase NLA_S32:\n\t\trange->min = S32_MIN;\n\t\trange->max = S32_MAX;\n\t\tbreak;\n\tcase NLA_S64:\n\t\trange->min = S64_MIN;\n\t\trange->max = S64_MAX;\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\treturn;\n\t}\n\n\tswitch (pt->validation_type) {\n\tcase NLA_VALIDATE_RANGE:\n\t\trange->min = pt->min;\n\t\trange->max = pt->max;\n\t\tbreak;\n\tcase NLA_VALIDATE_RANGE_PTR:\n\t\t*range = *pt->range_signed;\n\t\tbreak;\n\tcase NLA_VALIDATE_MIN:\n\t\trange->min = pt->min;\n\t\tbreak;\n\tcase NLA_VALIDATE_MAX:\n\t\trange->max = pt->max;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic int nla_validate_int_range_signed(const struct nla_policy *pt,\n\t\t\t\t\t const struct nlattr *nla,\n\t\t\t\t\t struct netlink_ext_ack *extack)\n{\n\tstruct netlink_range_validation_signed range;\n\ts64 value;\n\n\tswitch (pt->type) {\n\tcase NLA_S8:\n\t\tvalue = nla_get_s8(nla);\n\t\tbreak;\n\tcase NLA_S16:\n\t\tvalue = nla_get_s16(nla);\n\t\tbreak;\n\tcase NLA_S32:\n\t\tvalue = nla_get_s32(nla);\n\t\tbreak;\n\tcase NLA_S64:\n\t\tvalue = nla_get_s64(nla);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tnla_get_range_signed(pt, &range);\n\n\tif (value < range.min || value > range.max) {\n\t\tNL_SET_ERR_MSG_ATTR_POL(extack, nla, pt,\n\t\t\t\t\t\"integer out of range\");\n\t\treturn -ERANGE;\n\t}\n\n\treturn 0;\n}\n\nstatic int nla_validate_int_range(const struct nla_policy *pt,\n\t\t\t\t  const struct nlattr *nla,\n\t\t\t\t  struct netlink_ext_ack *extack,\n\t\t\t\t  unsigned int validate)\n{\n\tswitch (pt->type) {\n\tcase NLA_U8:\n\tcase NLA_U16:\n\tcase NLA_U32:\n\tcase NLA_U64:\n\tcase NLA_MSECS:\n\tcase NLA_BINARY:\n\tcase NLA_BE16:\n\tcase NLA_BE32:\n\t\treturn nla_validate_range_unsigned(pt, nla, extack, validate);\n\tcase NLA_S8:\n\tcase NLA_S16:\n\tcase NLA_S32:\n\tcase NLA_S64:\n\t\treturn nla_validate_int_range_signed(pt, nla, extack);\n\tdefault:\n\t\tWARN_ON(1);\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int nla_validate_mask(const struct nla_policy *pt,\n\t\t\t     const struct nlattr *nla,\n\t\t\t     struct netlink_ext_ack *extack)\n{\n\tu64 value;\n\n\tswitch (pt->type) {\n\tcase NLA_U8:\n\t\tvalue = nla_get_u8(nla);\n\t\tbreak;\n\tcase NLA_U16:\n\t\tvalue = nla_get_u16(nla);\n\t\tbreak;\n\tcase NLA_U32:\n\t\tvalue = nla_get_u32(nla);\n\t\tbreak;\n\tcase NLA_U64:\n\t\tvalue = nla_get_u64(nla);\n\t\tbreak;\n\tcase NLA_BE16:\n\t\tvalue = ntohs(nla_get_be16(nla));\n\t\tbreak;\n\tcase NLA_BE32:\n\t\tvalue = ntohl(nla_get_be32(nla));\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (value & ~(u64)pt->mask) {\n\t\tNL_SET_ERR_MSG_ATTR(extack, nla, \"reserved bit set\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int validate_nla(const struct nlattr *nla, int maxtype,\n\t\t\tconst struct nla_policy *policy, unsigned int validate,\n\t\t\tstruct netlink_ext_ack *extack, unsigned int depth)\n{\n\tu16 strict_start_type = policy[0].strict_start_type;\n\tconst struct nla_policy *pt;\n\tint minlen = 0, attrlen = nla_len(nla), type = nla_type(nla);\n\tint err = -ERANGE;\n\n\tif (strict_start_type && type >= strict_start_type)\n\t\tvalidate |= NL_VALIDATE_STRICT;\n\n\tif (type <= 0 || type > maxtype)\n\t\treturn 0;\n\n\ttype = array_index_nospec(type, maxtype + 1);\n\tpt = &policy[type];\n\n\tBUG_ON(pt->type > NLA_TYPE_MAX);\n\n\tif (nla_attr_len[pt->type] && attrlen != nla_attr_len[pt->type]) {\n\t\tpr_warn_ratelimited(\"netlink: '%s': attribute type %d has an invalid length.\\n\",\n\t\t\t\t    current->comm, type);\n\t\tif (validate & NL_VALIDATE_STRICT_ATTRS) {\n\t\t\tNL_SET_ERR_MSG_ATTR_POL(extack, nla, pt,\n\t\t\t\t\t\t\"invalid attribute length\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (validate & NL_VALIDATE_NESTED) {\n\t\tif ((pt->type == NLA_NESTED || pt->type == NLA_NESTED_ARRAY) &&\n\t\t    !(nla->nla_type & NLA_F_NESTED)) {\n\t\t\tNL_SET_ERR_MSG_ATTR_POL(extack, nla, pt,\n\t\t\t\t\t\t\"NLA_F_NESTED is missing\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (pt->type != NLA_NESTED && pt->type != NLA_NESTED_ARRAY &&\n\t\t    pt->type != NLA_UNSPEC && (nla->nla_type & NLA_F_NESTED)) {\n\t\t\tNL_SET_ERR_MSG_ATTR_POL(extack, nla, pt,\n\t\t\t\t\t\t\"NLA_F_NESTED not expected\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tswitch (pt->type) {\n\tcase NLA_REJECT:\n\t\tif (extack && pt->reject_message) {\n\t\t\tNL_SET_BAD_ATTR(extack, nla);\n\t\t\textack->_msg = pt->reject_message;\n\t\t\treturn -EINVAL;\n\t\t}\n\t\terr = -EINVAL;\n\t\tgoto out_err;\n\n\tcase NLA_FLAG:\n\t\tif (attrlen > 0)\n\t\t\tgoto out_err;\n\t\tbreak;\n\n\tcase NLA_BITFIELD32:\n\t\tif (attrlen != sizeof(struct nla_bitfield32))\n\t\t\tgoto out_err;\n\n\t\terr = validate_nla_bitfield32(nla, pt->bitfield32_valid);\n\t\tif (err)\n\t\t\tgoto out_err;\n\t\tbreak;\n\n\tcase NLA_NUL_STRING:\n\t\tif (pt->len)\n\t\t\tminlen = min_t(int, attrlen, pt->len + 1);\n\t\telse\n\t\t\tminlen = attrlen;\n\n\t\tif (!minlen || memchr(nla_data(nla), '\\0', minlen) == NULL) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out_err;\n\t\t}\n\t\tfallthrough;\n\n\tcase NLA_STRING:\n\t\tif (attrlen < 1)\n\t\t\tgoto out_err;\n\n\t\tif (pt->len) {\n\t\t\tchar *buf = nla_data(nla);\n\n\t\t\tif (buf[attrlen - 1] == '\\0')\n\t\t\t\tattrlen--;\n\n\t\t\tif (attrlen > pt->len)\n\t\t\t\tgoto out_err;\n\t\t}\n\t\tbreak;\n\n\tcase NLA_BINARY:\n\t\tif (pt->len && attrlen > pt->len)\n\t\t\tgoto out_err;\n\t\tbreak;\n\n\tcase NLA_NESTED:\n\t\t \n\t\tif (attrlen == 0)\n\t\t\tbreak;\n\t\tif (attrlen < NLA_HDRLEN)\n\t\t\tgoto out_err;\n\t\tif (pt->nested_policy) {\n\t\t\terr = __nla_validate_parse(nla_data(nla), nla_len(nla),\n\t\t\t\t\t\t   pt->len, pt->nested_policy,\n\t\t\t\t\t\t   validate, extack, NULL,\n\t\t\t\t\t\t   depth + 1);\n\t\t\tif (err < 0) {\n\t\t\t\t \n\t\t\t\treturn err;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase NLA_NESTED_ARRAY:\n\t\t \n\t\tif (attrlen == 0)\n\t\t\tbreak;\n\t\tif (attrlen < NLA_HDRLEN)\n\t\t\tgoto out_err;\n\t\tif (pt->nested_policy) {\n\t\t\tint err;\n\n\t\t\terr = nla_validate_array(nla_data(nla), nla_len(nla),\n\t\t\t\t\t\t pt->len, pt->nested_policy,\n\t\t\t\t\t\t extack, validate, depth);\n\t\t\tif (err < 0) {\n\t\t\t\t \n\t\t\t\treturn err;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase NLA_UNSPEC:\n\t\tif (validate & NL_VALIDATE_UNSPEC) {\n\t\t\tNL_SET_ERR_MSG_ATTR(extack, nla,\n\t\t\t\t\t    \"Unsupported attribute\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (attrlen < pt->len)\n\t\t\tgoto out_err;\n\t\tbreak;\n\n\tdefault:\n\t\tif (pt->len)\n\t\t\tminlen = pt->len;\n\t\telse\n\t\t\tminlen = nla_attr_minlen[pt->type];\n\n\t\tif (attrlen < minlen)\n\t\t\tgoto out_err;\n\t}\n\n\t \n\tswitch (pt->validation_type) {\n\tcase NLA_VALIDATE_NONE:\n\t\t \n\t\tbreak;\n\tcase NLA_VALIDATE_RANGE_PTR:\n\tcase NLA_VALIDATE_RANGE:\n\tcase NLA_VALIDATE_RANGE_WARN_TOO_LONG:\n\tcase NLA_VALIDATE_MIN:\n\tcase NLA_VALIDATE_MAX:\n\t\terr = nla_validate_int_range(pt, nla, extack, validate);\n\t\tif (err)\n\t\t\treturn err;\n\t\tbreak;\n\tcase NLA_VALIDATE_MASK:\n\t\terr = nla_validate_mask(pt, nla, extack);\n\t\tif (err)\n\t\t\treturn err;\n\t\tbreak;\n\tcase NLA_VALIDATE_FUNCTION:\n\t\tif (pt->validate) {\n\t\t\terr = pt->validate(nla, extack);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn 0;\nout_err:\n\tNL_SET_ERR_MSG_ATTR_POL(extack, nla, pt,\n\t\t\t\t\"Attribute failed policy validation\");\n\treturn err;\n}\n\nstatic int __nla_validate_parse(const struct nlattr *head, int len, int maxtype,\n\t\t\t\tconst struct nla_policy *policy,\n\t\t\t\tunsigned int validate,\n\t\t\t\tstruct netlink_ext_ack *extack,\n\t\t\t\tstruct nlattr **tb, unsigned int depth)\n{\n\tconst struct nlattr *nla;\n\tint rem;\n\n\tif (depth >= MAX_POLICY_RECURSION_DEPTH) {\n\t\tNL_SET_ERR_MSG(extack,\n\t\t\t       \"allowed policy recursion depth exceeded\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (tb)\n\t\tmemset(tb, 0, sizeof(struct nlattr *) * (maxtype + 1));\n\n\tnla_for_each_attr(nla, head, len, rem) {\n\t\tu16 type = nla_type(nla);\n\n\t\tif (type == 0 || type > maxtype) {\n\t\t\tif (validate & NL_VALIDATE_MAXTYPE) {\n\t\t\t\tNL_SET_ERR_MSG_ATTR(extack, nla,\n\t\t\t\t\t\t    \"Unknown attribute type\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\ttype = array_index_nospec(type, maxtype + 1);\n\t\tif (policy) {\n\t\t\tint err = validate_nla(nla, maxtype, policy,\n\t\t\t\t\t       validate, extack, depth);\n\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\n\t\tif (tb)\n\t\t\ttb[type] = (struct nlattr *)nla;\n\t}\n\n\tif (unlikely(rem > 0)) {\n\t\tpr_warn_ratelimited(\"netlink: %d bytes leftover after parsing attributes in process `%s'.\\n\",\n\t\t\t\t    rem, current->comm);\n\t\tNL_SET_ERR_MSG(extack, \"bytes leftover after parsing attributes\");\n\t\tif (validate & NL_VALIDATE_TRAILING)\n\t\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \nint __nla_validate(const struct nlattr *head, int len, int maxtype,\n\t\t   const struct nla_policy *policy, unsigned int validate,\n\t\t   struct netlink_ext_ack *extack)\n{\n\treturn __nla_validate_parse(head, len, maxtype, policy, validate,\n\t\t\t\t    extack, NULL, 0);\n}\nEXPORT_SYMBOL(__nla_validate);\n\n \nint\nnla_policy_len(const struct nla_policy *p, int n)\n{\n\tint i, len = 0;\n\n\tfor (i = 0; i < n; i++, p++) {\n\t\tif (p->len)\n\t\t\tlen += nla_total_size(p->len);\n\t\telse if (nla_attr_len[p->type])\n\t\t\tlen += nla_total_size(nla_attr_len[p->type]);\n\t\telse if (nla_attr_minlen[p->type])\n\t\t\tlen += nla_total_size(nla_attr_minlen[p->type]);\n\t}\n\n\treturn len;\n}\nEXPORT_SYMBOL(nla_policy_len);\n\n \nint __nla_parse(struct nlattr **tb, int maxtype,\n\t\tconst struct nlattr *head, int len,\n\t\tconst struct nla_policy *policy, unsigned int validate,\n\t\tstruct netlink_ext_ack *extack)\n{\n\treturn __nla_validate_parse(head, len, maxtype, policy, validate,\n\t\t\t\t    extack, tb, 0);\n}\nEXPORT_SYMBOL(__nla_parse);\n\n \nstruct nlattr *nla_find(const struct nlattr *head, int len, int attrtype)\n{\n\tconst struct nlattr *nla;\n\tint rem;\n\n\tnla_for_each_attr(nla, head, len, rem)\n\t\tif (nla_type(nla) == attrtype)\n\t\t\treturn (struct nlattr *)nla;\n\n\treturn NULL;\n}\nEXPORT_SYMBOL(nla_find);\n\n \nssize_t nla_strscpy(char *dst, const struct nlattr *nla, size_t dstsize)\n{\n\tsize_t srclen = nla_len(nla);\n\tchar *src = nla_data(nla);\n\tssize_t ret;\n\tsize_t len;\n\n\tif (dstsize == 0 || WARN_ON_ONCE(dstsize > U16_MAX))\n\t\treturn -E2BIG;\n\n\tif (srclen > 0 && src[srclen - 1] == '\\0')\n\t\tsrclen--;\n\n\tif (srclen >= dstsize) {\n\t\tlen = dstsize - 1;\n\t\tret = -E2BIG;\n\t} else {\n\t\tlen = srclen;\n\t\tret = len;\n\t}\n\n\tmemcpy(dst, src, len);\n\t \n\tmemset(dst + len, 0, dstsize - len);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(nla_strscpy);\n\n \nchar *nla_strdup(const struct nlattr *nla, gfp_t flags)\n{\n\tsize_t srclen = nla_len(nla);\n\tchar *src = nla_data(nla), *dst;\n\n\tif (srclen > 0 && src[srclen - 1] == '\\0')\n\t\tsrclen--;\n\n\tdst = kmalloc(srclen + 1, flags);\n\tif (dst != NULL) {\n\t\tmemcpy(dst, src, srclen);\n\t\tdst[srclen] = '\\0';\n\t}\n\treturn dst;\n}\nEXPORT_SYMBOL(nla_strdup);\n\n \nint nla_memcpy(void *dest, const struct nlattr *src, int count)\n{\n\tint minlen = min_t(int, count, nla_len(src));\n\n\tmemcpy(dest, nla_data(src), minlen);\n\tif (count > minlen)\n\t\tmemset(dest + minlen, 0, count - minlen);\n\n\treturn minlen;\n}\nEXPORT_SYMBOL(nla_memcpy);\n\n \nint nla_memcmp(const struct nlattr *nla, const void *data,\n\t\t\t     size_t size)\n{\n\tint d = nla_len(nla) - size;\n\n\tif (d == 0)\n\t\td = memcmp(nla_data(nla), data, size);\n\n\treturn d;\n}\nEXPORT_SYMBOL(nla_memcmp);\n\n \nint nla_strcmp(const struct nlattr *nla, const char *str)\n{\n\tint len = strlen(str);\n\tchar *buf = nla_data(nla);\n\tint attrlen = nla_len(nla);\n\tint d;\n\n\twhile (attrlen > 0 && buf[attrlen - 1] == '\\0')\n\t\tattrlen--;\n\n\td = attrlen - len;\n\tif (d == 0)\n\t\td = memcmp(nla_data(nla), str, len);\n\n\treturn d;\n}\nEXPORT_SYMBOL(nla_strcmp);\n\n#ifdef CONFIG_NET\n \nstruct nlattr *__nla_reserve(struct sk_buff *skb, int attrtype, int attrlen)\n{\n\tstruct nlattr *nla;\n\n\tnla = skb_put(skb, nla_total_size(attrlen));\n\tnla->nla_type = attrtype;\n\tnla->nla_len = nla_attr_size(attrlen);\n\n\tmemset((unsigned char *) nla + nla->nla_len, 0, nla_padlen(attrlen));\n\n\treturn nla;\n}\nEXPORT_SYMBOL(__nla_reserve);\n\n \nstruct nlattr *__nla_reserve_64bit(struct sk_buff *skb, int attrtype,\n\t\t\t\t   int attrlen, int padattr)\n{\n\tnla_align_64bit(skb, padattr);\n\n\treturn __nla_reserve(skb, attrtype, attrlen);\n}\nEXPORT_SYMBOL(__nla_reserve_64bit);\n\n \nvoid *__nla_reserve_nohdr(struct sk_buff *skb, int attrlen)\n{\n\treturn skb_put_zero(skb, NLA_ALIGN(attrlen));\n}\nEXPORT_SYMBOL(__nla_reserve_nohdr);\n\n \nstruct nlattr *nla_reserve(struct sk_buff *skb, int attrtype, int attrlen)\n{\n\tif (unlikely(skb_tailroom(skb) < nla_total_size(attrlen)))\n\t\treturn NULL;\n\n\treturn __nla_reserve(skb, attrtype, attrlen);\n}\nEXPORT_SYMBOL(nla_reserve);\n\n \nstruct nlattr *nla_reserve_64bit(struct sk_buff *skb, int attrtype, int attrlen,\n\t\t\t\t int padattr)\n{\n\tsize_t len;\n\n\tif (nla_need_padding_for_64bit(skb))\n\t\tlen = nla_total_size_64bit(attrlen);\n\telse\n\t\tlen = nla_total_size(attrlen);\n\tif (unlikely(skb_tailroom(skb) < len))\n\t\treturn NULL;\n\n\treturn __nla_reserve_64bit(skb, attrtype, attrlen, padattr);\n}\nEXPORT_SYMBOL(nla_reserve_64bit);\n\n \nvoid *nla_reserve_nohdr(struct sk_buff *skb, int attrlen)\n{\n\tif (unlikely(skb_tailroom(skb) < NLA_ALIGN(attrlen)))\n\t\treturn NULL;\n\n\treturn __nla_reserve_nohdr(skb, attrlen);\n}\nEXPORT_SYMBOL(nla_reserve_nohdr);\n\n \nvoid __nla_put(struct sk_buff *skb, int attrtype, int attrlen,\n\t\t\t     const void *data)\n{\n\tstruct nlattr *nla;\n\n\tnla = __nla_reserve(skb, attrtype, attrlen);\n\tmemcpy(nla_data(nla), data, attrlen);\n}\nEXPORT_SYMBOL(__nla_put);\n\n \nvoid __nla_put_64bit(struct sk_buff *skb, int attrtype, int attrlen,\n\t\t     const void *data, int padattr)\n{\n\tstruct nlattr *nla;\n\n\tnla = __nla_reserve_64bit(skb, attrtype, attrlen, padattr);\n\tmemcpy(nla_data(nla), data, attrlen);\n}\nEXPORT_SYMBOL(__nla_put_64bit);\n\n \nvoid __nla_put_nohdr(struct sk_buff *skb, int attrlen, const void *data)\n{\n\tvoid *start;\n\n\tstart = __nla_reserve_nohdr(skb, attrlen);\n\tmemcpy(start, data, attrlen);\n}\nEXPORT_SYMBOL(__nla_put_nohdr);\n\n \nint nla_put(struct sk_buff *skb, int attrtype, int attrlen, const void *data)\n{\n\tif (unlikely(skb_tailroom(skb) < nla_total_size(attrlen)))\n\t\treturn -EMSGSIZE;\n\n\t__nla_put(skb, attrtype, attrlen, data);\n\treturn 0;\n}\nEXPORT_SYMBOL(nla_put);\n\n \nint nla_put_64bit(struct sk_buff *skb, int attrtype, int attrlen,\n\t\t  const void *data, int padattr)\n{\n\tsize_t len;\n\n\tif (nla_need_padding_for_64bit(skb))\n\t\tlen = nla_total_size_64bit(attrlen);\n\telse\n\t\tlen = nla_total_size(attrlen);\n\tif (unlikely(skb_tailroom(skb) < len))\n\t\treturn -EMSGSIZE;\n\n\t__nla_put_64bit(skb, attrtype, attrlen, data, padattr);\n\treturn 0;\n}\nEXPORT_SYMBOL(nla_put_64bit);\n\n \nint nla_put_nohdr(struct sk_buff *skb, int attrlen, const void *data)\n{\n\tif (unlikely(skb_tailroom(skb) < NLA_ALIGN(attrlen)))\n\t\treturn -EMSGSIZE;\n\n\t__nla_put_nohdr(skb, attrlen, data);\n\treturn 0;\n}\nEXPORT_SYMBOL(nla_put_nohdr);\n\n \nint nla_append(struct sk_buff *skb, int attrlen, const void *data)\n{\n\tif (unlikely(skb_tailroom(skb) < NLA_ALIGN(attrlen)))\n\t\treturn -EMSGSIZE;\n\n\tskb_put_data(skb, data, attrlen);\n\treturn 0;\n}\nEXPORT_SYMBOL(nla_append);\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}