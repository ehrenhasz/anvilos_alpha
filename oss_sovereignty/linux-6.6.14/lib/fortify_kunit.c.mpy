{
  "module_name": "fortify_kunit.c",
  "hash_id": "bbe00f21f79809e5638ae7f2afc67636f109b2f2eef21206576c969c01b9864f",
  "original_prompt": "Ingested from linux-6.6.14/lib/fortify_kunit.c",
  "human_readable_source": "\n \n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <kunit/test.h>\n#include <linux/device.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n\nstatic const char array_of_10[] = \"this is 10\";\nstatic const char *ptr_of_11 = \"this is 11!\";\nstatic char array_unknown[] = \"compiler thinks I might change\";\n\nstatic void known_sizes_test(struct kunit *test)\n{\n\tKUNIT_EXPECT_EQ(test, __compiletime_strlen(\"88888888\"), 8);\n\tKUNIT_EXPECT_EQ(test, __compiletime_strlen(array_of_10), 10);\n\tKUNIT_EXPECT_EQ(test, __compiletime_strlen(ptr_of_11), 11);\n\n\tKUNIT_EXPECT_EQ(test, __compiletime_strlen(array_unknown), SIZE_MAX);\n\t \n\tKUNIT_EXPECT_EQ(test, __compiletime_strlen(test->name), SIZE_MAX);\n}\n\n \nstatic volatile int pick;\n\n \nstatic noinline size_t want_minus_one(int pick)\n{\n\tconst char *str;\n\n\tswitch (pick) {\n\tcase 1:\n\t\tstr = \"4444\";\n\t\tbreak;\n\tcase 2:\n\t\tstr = \"333\";\n\t\tbreak;\n\tdefault:\n\t\tstr = \"1\";\n\t\tbreak;\n\t}\n\treturn __compiletime_strlen(str);\n}\n\nstatic void control_flow_split_test(struct kunit *test)\n{\n\tKUNIT_EXPECT_EQ(test, want_minus_one(pick), SIZE_MAX);\n}\n\n#define KUNIT_EXPECT_BOS(test, p, expected, name)\t\t\t\\\n\tKUNIT_EXPECT_EQ_MSG(test, __builtin_object_size(p, 1),\t\t\\\n\t\texpected,\t\t\t\t\t\t\\\n\t\t\"__alloc_size() not working with __bos on \" name \"\\n\")\n\n#if !__has_builtin(__builtin_dynamic_object_size)\n#define KUNIT_EXPECT_BDOS(test, p, expected, name)\t\t\t\\\n\t \t\t\\\n\tKUNIT_EXPECT_EQ(test, expected, expected)\n#else\n#define KUNIT_EXPECT_BDOS(test, p, expected, name)\t\t\t\\\n\tKUNIT_EXPECT_EQ_MSG(test, __builtin_dynamic_object_size(p, 1),\t\\\n\t\texpected,\t\t\t\t\t\t\\\n\t\t\"__alloc_size() not working with __bdos on \" name \"\\n\")\n#endif\n\n \n#define check_const(_expected, alloc, free)\t\tdo {\t\t\\\n\tsize_t expected = (_expected);\t\t\t\t\t\\\n\tvoid *p = alloc;\t\t\t\t\t\t\\\n\tKUNIT_EXPECT_TRUE_MSG(test, p != NULL, #alloc \" failed?!\\n\");\t\\\n\tKUNIT_EXPECT_BOS(test, p, expected, #alloc);\t\t\t\\\n\tKUNIT_EXPECT_BDOS(test, p, expected, #alloc);\t\t\t\\\n\tfree;\t\t\t\t\t\t\t\t\\\n} while (0)\n\n \n#define check_dynamic(_expected, alloc, free)\t\tdo {\t\t\\\n\tsize_t expected = (_expected);\t\t\t\t\t\\\n\tvoid *p = alloc;\t\t\t\t\t\t\\\n\tKUNIT_EXPECT_TRUE_MSG(test, p != NULL, #alloc \" failed?!\\n\");\t\\\n\tKUNIT_EXPECT_BOS(test, p, SIZE_MAX, #alloc);\t\t\t\\\n\tKUNIT_EXPECT_BDOS(test, p, expected, #alloc);\t\t\t\\\n\tfree;\t\t\t\t\t\t\t\t\\\n} while (0)\n\n \n#define CONST_TEST_BODY(TEST_alloc)\tdo {\t\t\t\t\\\n\t \t\\\n\tif (strcmp(#TEST_alloc, \"TEST_vmalloc\") != 0)\t\t\t\\\n\t\tTEST_alloc(check_const, 0, 0);\t\t\t\t\\\n\tTEST_alloc(check_const, 1, 1);\t\t\t\t\t\\\n\tTEST_alloc(check_const, 128, 128);\t\t\t\t\\\n\tTEST_alloc(check_const, 1023, 1023);\t\t\t\t\\\n\tTEST_alloc(check_const, 1025, 1025);\t\t\t\t\\\n\tTEST_alloc(check_const, 4096, 4096);\t\t\t\t\\\n\tTEST_alloc(check_const, 4097, 4097);\t\t\t\t\\\n} while (0)\n\nstatic volatile size_t zero_size;\nstatic volatile size_t unknown_size = 50;\n\n#if !__has_builtin(__builtin_dynamic_object_size)\n#define DYNAMIC_TEST_BODY(TEST_alloc)\t\t\t\t\t\\\n\tkunit_skip(test, \"Compiler is missing __builtin_dynamic_object_size() support\\n\")\n#else\n#define DYNAMIC_TEST_BODY(TEST_alloc)\tdo {\t\t\t\t\\\n\tsize_t size = unknown_size;\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t \t\t\t\t\t\t\t\t\\\n\tTEST_alloc(check_dynamic, size, size++);\t\t\t\\\n\t \t\t\t\\\n\tKUNIT_EXPECT_NE(test, size, unknown_size);\t\t\t\\\n} while (0)\n#endif\n\n#define DEFINE_ALLOC_SIZE_TEST_PAIR(allocator)\t\t\t\t\\\nstatic void alloc_size_##allocator##_const_test(struct kunit *test)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tCONST_TEST_BODY(TEST_##allocator);\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\nstatic void alloc_size_##allocator##_dynamic_test(struct kunit *test)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tDYNAMIC_TEST_BODY(TEST_##allocator);\t\t\t\t\\\n}\n\n#define TEST_kmalloc(checker, expected_size, alloc_size)\tdo {\t\\\n\tgfp_t gfp = GFP_KERNEL | __GFP_NOWARN;\t\t\t\t\\\n\tvoid *orig;\t\t\t\t\t\t\t\\\n\tsize_t len;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tchecker(expected_size, kmalloc(alloc_size, gfp),\t\t\\\n\t\tkfree(p));\t\t\t\t\t\t\\\n\tchecker(expected_size,\t\t\t\t\t\t\\\n\t\tkmalloc_node(alloc_size, gfp, NUMA_NO_NODE),\t\t\\\n\t\tkfree(p));\t\t\t\t\t\t\\\n\tchecker(expected_size, kzalloc(alloc_size, gfp),\t\t\\\n\t\tkfree(p));\t\t\t\t\t\t\\\n\tchecker(expected_size,\t\t\t\t\t\t\\\n\t\tkzalloc_node(alloc_size, gfp, NUMA_NO_NODE),\t\t\\\n\t\tkfree(p));\t\t\t\t\t\t\\\n\tchecker(expected_size, kcalloc(1, alloc_size, gfp),\t\t\\\n\t\tkfree(p));\t\t\t\t\t\t\\\n\tchecker(expected_size, kcalloc(alloc_size, 1, gfp),\t\t\\\n\t\tkfree(p));\t\t\t\t\t\t\\\n\tchecker(expected_size,\t\t\t\t\t\t\\\n\t\tkcalloc_node(1, alloc_size, gfp, NUMA_NO_NODE),\t\t\\\n\t\tkfree(p));\t\t\t\t\t\t\\\n\tchecker(expected_size,\t\t\t\t\t\t\\\n\t\tkcalloc_node(alloc_size, 1, gfp, NUMA_NO_NODE),\t\t\\\n\t\tkfree(p));\t\t\t\t\t\t\\\n\tchecker(expected_size, kmalloc_array(1, alloc_size, gfp),\t\\\n\t\tkfree(p));\t\t\t\t\t\t\\\n\tchecker(expected_size, kmalloc_array(alloc_size, 1, gfp),\t\\\n\t\tkfree(p));\t\t\t\t\t\t\\\n\tchecker(expected_size,\t\t\t\t\t\t\\\n\t\tkmalloc_array_node(1, alloc_size, gfp, NUMA_NO_NODE),\t\\\n\t\tkfree(p));\t\t\t\t\t\t\\\n\tchecker(expected_size,\t\t\t\t\t\t\\\n\t\tkmalloc_array_node(alloc_size, 1, gfp, NUMA_NO_NODE),\t\\\n\t\tkfree(p));\t\t\t\t\t\t\\\n\tchecker(expected_size, __kmalloc(alloc_size, gfp),\t\t\\\n\t\tkfree(p));\t\t\t\t\t\t\\\n\tchecker(expected_size,\t\t\t\t\t\t\\\n\t\t__kmalloc_node(alloc_size, gfp, NUMA_NO_NODE),\t\t\\\n\t\tkfree(p));\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\torig = kmalloc(alloc_size, gfp);\t\t\t\t\\\n\tKUNIT_EXPECT_TRUE(test, orig != NULL);\t\t\t\t\\\n\tchecker((expected_size) * 2,\t\t\t\t\t\\\n\t\tkrealloc(orig, (alloc_size) * 2, gfp),\t\t\t\\\n\t\tkfree(p));\t\t\t\t\t\t\\\n\torig = kmalloc(alloc_size, gfp);\t\t\t\t\\\n\tKUNIT_EXPECT_TRUE(test, orig != NULL);\t\t\t\t\\\n\tchecker((expected_size) * 2,\t\t\t\t\t\\\n\t\tkrealloc_array(orig, 1, (alloc_size) * 2, gfp),\t\t\\\n\t\tkfree(p));\t\t\t\t\t\t\\\n\torig = kmalloc(alloc_size, gfp);\t\t\t\t\\\n\tKUNIT_EXPECT_TRUE(test, orig != NULL);\t\t\t\t\\\n\tchecker((expected_size) * 2,\t\t\t\t\t\\\n\t\tkrealloc_array(orig, (alloc_size) * 2, 1, gfp),\t\t\\\n\t\tkfree(p));\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tlen = 11;\t\t\t\t\t\t\t\\\n\t \t\\\n\tif (!__builtin_constant_p(expected_size))\t\t\t\\\n\t\tlen += zero_size;\t\t\t\t\t\\\n\tchecker(len, kmemdup(\"hello there\", len, gfp), kfree(p));\t\\\n} while (0)\nDEFINE_ALLOC_SIZE_TEST_PAIR(kmalloc)\n\n \n#define TEST_vmalloc(checker, expected_pages, alloc_pages)\tdo {\t\\\n\tgfp_t gfp = GFP_KERNEL | __GFP_NOWARN;\t\t\t\t\\\n\tchecker((expected_pages) * PAGE_SIZE,\t\t\t\t\\\n\t\tvmalloc((alloc_pages) * PAGE_SIZE),\t   vfree(p));\t\\\n\tchecker((expected_pages) * PAGE_SIZE,\t\t\t\t\\\n\t\tvzalloc((alloc_pages) * PAGE_SIZE),\t   vfree(p));\t\\\n\tchecker((expected_pages) * PAGE_SIZE,\t\t\t\t\\\n\t\t__vmalloc((alloc_pages) * PAGE_SIZE, gfp), vfree(p));\t\\\n} while (0)\nDEFINE_ALLOC_SIZE_TEST_PAIR(vmalloc)\n\n \n#define TEST_kvmalloc(checker, expected_pages, alloc_pages)\tdo {\t\\\n\tgfp_t gfp = GFP_KERNEL | __GFP_NOWARN;\t\t\t\t\\\n\tsize_t prev_size;\t\t\t\t\t\t\\\n\tvoid *orig;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tchecker((expected_pages) * PAGE_SIZE,\t\t\t\t\\\n\t\tkvmalloc((alloc_pages) * PAGE_SIZE, gfp),\t\t\\\n\t\tvfree(p));\t\t\t\t\t\t\\\n\tchecker((expected_pages) * PAGE_SIZE,\t\t\t\t\\\n\t\tkvmalloc_node((alloc_pages) * PAGE_SIZE, gfp, NUMA_NO_NODE), \\\n\t\tvfree(p));\t\t\t\t\t\t\\\n\tchecker((expected_pages) * PAGE_SIZE,\t\t\t\t\\\n\t\tkvzalloc((alloc_pages) * PAGE_SIZE, gfp),\t\t\\\n\t\tvfree(p));\t\t\t\t\t\t\\\n\tchecker((expected_pages) * PAGE_SIZE,\t\t\t\t\\\n\t\tkvzalloc_node((alloc_pages) * PAGE_SIZE, gfp, NUMA_NO_NODE), \\\n\t\tvfree(p));\t\t\t\t\t\t\\\n\tchecker((expected_pages) * PAGE_SIZE,\t\t\t\t\\\n\t\tkvcalloc(1, (alloc_pages) * PAGE_SIZE, gfp),\t\t\\\n\t\tvfree(p));\t\t\t\t\t\t\\\n\tchecker((expected_pages) * PAGE_SIZE,\t\t\t\t\\\n\t\tkvcalloc((alloc_pages) * PAGE_SIZE, 1, gfp),\t\t\\\n\t\tvfree(p));\t\t\t\t\t\t\\\n\tchecker((expected_pages) * PAGE_SIZE,\t\t\t\t\\\n\t\tkvmalloc_array(1, (alloc_pages) * PAGE_SIZE, gfp),\t\\\n\t\tvfree(p));\t\t\t\t\t\t\\\n\tchecker((expected_pages) * PAGE_SIZE,\t\t\t\t\\\n\t\tkvmalloc_array((alloc_pages) * PAGE_SIZE, 1, gfp),\t\\\n\t\tvfree(p));\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tprev_size = (expected_pages) * PAGE_SIZE;\t\t\t\\\n\torig = kvmalloc(prev_size, gfp);\t\t\t\t\\\n\tKUNIT_EXPECT_TRUE(test, orig != NULL);\t\t\t\t\\\n\tchecker(((expected_pages) * PAGE_SIZE) * 2,\t\t\t\\\n\t\tkvrealloc(orig, prev_size,\t\t\t\t\\\n\t\t\t  ((alloc_pages) * PAGE_SIZE) * 2, gfp),\t\\\n\t\tkvfree(p));\t\t\t\t\t\t\\\n} while (0)\nDEFINE_ALLOC_SIZE_TEST_PAIR(kvmalloc)\n\n#define TEST_devm_kmalloc(checker, expected_size, alloc_size)\tdo {\t\\\n\tgfp_t gfp = GFP_KERNEL | __GFP_NOWARN;\t\t\t\t\\\n\tconst char dev_name[] = \"fortify-test\";\t\t\t\t\\\n\tstruct device *dev;\t\t\t\t\t\t\\\n\tvoid *orig;\t\t\t\t\t\t\t\\\n\tsize_t len;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t \t\\\n\tdev = root_device_register(dev_name);\t\t\t\t\\\n\tKUNIT_ASSERT_FALSE_MSG(test, IS_ERR(dev),\t\t\t\\\n\t\t\t       \"Cannot register test device\\n\");\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tchecker(expected_size, devm_kmalloc(dev, alloc_size, gfp),\t\\\n\t\tdevm_kfree(dev, p));\t\t\t\t\t\\\n\tchecker(expected_size, devm_kzalloc(dev, alloc_size, gfp),\t\\\n\t\tdevm_kfree(dev, p));\t\t\t\t\t\\\n\tchecker(expected_size,\t\t\t\t\t\t\\\n\t\tdevm_kmalloc_array(dev, 1, alloc_size, gfp),\t\t\\\n\t\tdevm_kfree(dev, p));\t\t\t\t\t\\\n\tchecker(expected_size,\t\t\t\t\t\t\\\n\t\tdevm_kmalloc_array(dev, alloc_size, 1, gfp),\t\t\\\n\t\tdevm_kfree(dev, p));\t\t\t\t\t\\\n\tchecker(expected_size,\t\t\t\t\t\t\\\n\t\tdevm_kcalloc(dev, 1, alloc_size, gfp),\t\t\t\\\n\t\tdevm_kfree(dev, p));\t\t\t\t\t\\\n\tchecker(expected_size,\t\t\t\t\t\t\\\n\t\tdevm_kcalloc(dev, alloc_size, 1, gfp),\t\t\t\\\n\t\tdevm_kfree(dev, p));\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\torig = devm_kmalloc(dev, alloc_size, gfp);\t\t\t\\\n\tKUNIT_EXPECT_TRUE(test, orig != NULL);\t\t\t\t\\\n\tchecker((expected_size) * 2,\t\t\t\t\t\\\n\t\tdevm_krealloc(dev, orig, (alloc_size) * 2, gfp),\t\\\n\t\tdevm_kfree(dev, p));\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tlen = 4;\t\t\t\t\t\t\t\\\n\t \t\\\n\tif (!__builtin_constant_p(expected_size))\t\t\t\\\n\t\tlen += zero_size;\t\t\t\t\t\\\n\tchecker(len, devm_kmemdup(dev, \"Ohai\", len, gfp),\t\t\\\n\t\tdevm_kfree(dev, p));\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tdevice_unregister(dev);\t\t\t\t\t\t\\\n} while (0)\nDEFINE_ALLOC_SIZE_TEST_PAIR(devm_kmalloc)\n\nstatic struct kunit_case fortify_test_cases[] = {\n\tKUNIT_CASE(known_sizes_test),\n\tKUNIT_CASE(control_flow_split_test),\n\tKUNIT_CASE(alloc_size_kmalloc_const_test),\n\tKUNIT_CASE(alloc_size_kmalloc_dynamic_test),\n\tKUNIT_CASE(alloc_size_vmalloc_const_test),\n\tKUNIT_CASE(alloc_size_vmalloc_dynamic_test),\n\tKUNIT_CASE(alloc_size_kvmalloc_const_test),\n\tKUNIT_CASE(alloc_size_kvmalloc_dynamic_test),\n\tKUNIT_CASE(alloc_size_devm_kmalloc_const_test),\n\tKUNIT_CASE(alloc_size_devm_kmalloc_dynamic_test),\n\t{}\n};\n\nstatic struct kunit_suite fortify_test_suite = {\n\t.name = \"fortify\",\n\t.test_cases = fortify_test_cases,\n};\n\nkunit_test_suite(fortify_test_suite);\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}