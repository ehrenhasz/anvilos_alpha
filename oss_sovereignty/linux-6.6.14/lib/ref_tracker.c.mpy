{
  "module_name": "ref_tracker.c",
  "hash_id": "8732214ff479be1faac3608f2daaa743718acae7129c90fc3556135db1a995bb",
  "original_prompt": "Ingested from linux-6.6.14/lib/ref_tracker.c",
  "human_readable_source": "\n\n#define pr_fmt(fmt) \"ref_tracker: \" fmt\n\n#include <linux/export.h>\n#include <linux/list_sort.h>\n#include <linux/ref_tracker.h>\n#include <linux/slab.h>\n#include <linux/stacktrace.h>\n#include <linux/stackdepot.h>\n\n#define REF_TRACKER_STACK_ENTRIES 16\n#define STACK_BUF_SIZE 1024\n\nstruct ref_tracker {\n\tstruct list_head\thead;    \n\tbool\t\t\tdead;\n\tdepot_stack_handle_t\talloc_stack_handle;\n\tdepot_stack_handle_t\tfree_stack_handle;\n};\n\nstruct ref_tracker_dir_stats {\n\tint total;\n\tint count;\n\tstruct {\n\t\tdepot_stack_handle_t stack_handle;\n\t\tunsigned int count;\n\t} stacks[];\n};\n\nstatic struct ref_tracker_dir_stats *\nref_tracker_get_stats(struct ref_tracker_dir *dir, unsigned int limit)\n{\n\tstruct ref_tracker_dir_stats *stats;\n\tstruct ref_tracker *tracker;\n\n\tstats = kmalloc(struct_size(stats, stacks, limit),\n\t\t\tGFP_NOWAIT | __GFP_NOWARN);\n\tif (!stats)\n\t\treturn ERR_PTR(-ENOMEM);\n\tstats->total = 0;\n\tstats->count = 0;\n\n\tlist_for_each_entry(tracker, &dir->list, head) {\n\t\tdepot_stack_handle_t stack = tracker->alloc_stack_handle;\n\t\tint i;\n\n\t\t++stats->total;\n\t\tfor (i = 0; i < stats->count; ++i)\n\t\t\tif (stats->stacks[i].stack_handle == stack)\n\t\t\t\tbreak;\n\t\tif (i >= limit)\n\t\t\tcontinue;\n\t\tif (i >= stats->count) {\n\t\t\tstats->stacks[i].stack_handle = stack;\n\t\t\tstats->stacks[i].count = 0;\n\t\t\t++stats->count;\n\t\t}\n\t\t++stats->stacks[i].count;\n\t}\n\n\treturn stats;\n}\n\nstruct ostream {\n\tchar *buf;\n\tint size, used;\n};\n\n#define pr_ostream(stream, fmt, args...) \\\n({ \\\n\tstruct ostream *_s = (stream); \\\n\\\n\tif (!_s->buf) { \\\n\t\tpr_err(fmt, ##args); \\\n\t} else { \\\n\t\tint ret, len = _s->size - _s->used; \\\n\t\tret = snprintf(_s->buf + _s->used, len, pr_fmt(fmt), ##args); \\\n\t\t_s->used += min(ret, len); \\\n\t} \\\n})\n\nstatic void\n__ref_tracker_dir_pr_ostream(struct ref_tracker_dir *dir,\n\t\t\t     unsigned int display_limit, struct ostream *s)\n{\n\tstruct ref_tracker_dir_stats *stats;\n\tunsigned int i = 0, skipped;\n\tdepot_stack_handle_t stack;\n\tchar *sbuf;\n\n\tlockdep_assert_held(&dir->lock);\n\n\tif (list_empty(&dir->list))\n\t\treturn;\n\n\tstats = ref_tracker_get_stats(dir, display_limit);\n\tif (IS_ERR(stats)) {\n\t\tpr_ostream(s, \"%s@%pK: couldn't get stats, error %pe\\n\",\n\t\t\t   dir->name, dir, stats);\n\t\treturn;\n\t}\n\n\tsbuf = kmalloc(STACK_BUF_SIZE, GFP_NOWAIT | __GFP_NOWARN);\n\n\tfor (i = 0, skipped = stats->total; i < stats->count; ++i) {\n\t\tstack = stats->stacks[i].stack_handle;\n\t\tif (sbuf && !stack_depot_snprint(stack, sbuf, STACK_BUF_SIZE, 4))\n\t\t\tsbuf[0] = 0;\n\t\tpr_ostream(s, \"%s@%pK has %d/%d users at\\n%s\\n\", dir->name, dir,\n\t\t\t   stats->stacks[i].count, stats->total, sbuf);\n\t\tskipped -= stats->stacks[i].count;\n\t}\n\n\tif (skipped)\n\t\tpr_ostream(s, \"%s@%pK skipped reports about %d/%d users.\\n\",\n\t\t\t   dir->name, dir, skipped, stats->total);\n\n\tkfree(sbuf);\n\n\tkfree(stats);\n}\n\nvoid ref_tracker_dir_print_locked(struct ref_tracker_dir *dir,\n\t\t\t\t  unsigned int display_limit)\n{\n\tstruct ostream os = {};\n\n\t__ref_tracker_dir_pr_ostream(dir, display_limit, &os);\n}\nEXPORT_SYMBOL(ref_tracker_dir_print_locked);\n\nvoid ref_tracker_dir_print(struct ref_tracker_dir *dir,\n\t\t\t   unsigned int display_limit)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&dir->lock, flags);\n\tref_tracker_dir_print_locked(dir, display_limit);\n\tspin_unlock_irqrestore(&dir->lock, flags);\n}\nEXPORT_SYMBOL(ref_tracker_dir_print);\n\nint ref_tracker_dir_snprint(struct ref_tracker_dir *dir, char *buf, size_t size)\n{\n\tstruct ostream os = { .buf = buf, .size = size };\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&dir->lock, flags);\n\t__ref_tracker_dir_pr_ostream(dir, 16, &os);\n\tspin_unlock_irqrestore(&dir->lock, flags);\n\n\treturn os.used;\n}\nEXPORT_SYMBOL(ref_tracker_dir_snprint);\n\nvoid ref_tracker_dir_exit(struct ref_tracker_dir *dir)\n{\n\tstruct ref_tracker *tracker, *n;\n\tunsigned long flags;\n\tbool leak = false;\n\n\tdir->dead = true;\n\tspin_lock_irqsave(&dir->lock, flags);\n\tlist_for_each_entry_safe(tracker, n, &dir->quarantine, head) {\n\t\tlist_del(&tracker->head);\n\t\tkfree(tracker);\n\t\tdir->quarantine_avail++;\n\t}\n\tif (!list_empty(&dir->list)) {\n\t\tref_tracker_dir_print_locked(dir, 16);\n\t\tleak = true;\n\t\tlist_for_each_entry_safe(tracker, n, &dir->list, head) {\n\t\t\tlist_del(&tracker->head);\n\t\t\tkfree(tracker);\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&dir->lock, flags);\n\tWARN_ON_ONCE(leak);\n\tWARN_ON_ONCE(refcount_read(&dir->untracked) != 1);\n\tWARN_ON_ONCE(refcount_read(&dir->no_tracker) != 1);\n}\nEXPORT_SYMBOL(ref_tracker_dir_exit);\n\nint ref_tracker_alloc(struct ref_tracker_dir *dir,\n\t\t      struct ref_tracker **trackerp,\n\t\t      gfp_t gfp)\n{\n\tunsigned long entries[REF_TRACKER_STACK_ENTRIES];\n\tstruct ref_tracker *tracker;\n\tunsigned int nr_entries;\n\tgfp_t gfp_mask = gfp | __GFP_NOWARN;\n\tunsigned long flags;\n\n\tWARN_ON_ONCE(dir->dead);\n\n\tif (!trackerp) {\n\t\trefcount_inc(&dir->no_tracker);\n\t\treturn 0;\n\t}\n\tif (gfp & __GFP_DIRECT_RECLAIM)\n\t\tgfp_mask |= __GFP_NOFAIL;\n\t*trackerp = tracker = kzalloc(sizeof(*tracker), gfp_mask);\n\tif (unlikely(!tracker)) {\n\t\tpr_err_once(\"memory allocation failure, unreliable refcount tracker.\\n\");\n\t\trefcount_inc(&dir->untracked);\n\t\treturn -ENOMEM;\n\t}\n\tnr_entries = stack_trace_save(entries, ARRAY_SIZE(entries), 1);\n\ttracker->alloc_stack_handle = stack_depot_save(entries, nr_entries, gfp);\n\n\tspin_lock_irqsave(&dir->lock, flags);\n\tlist_add(&tracker->head, &dir->list);\n\tspin_unlock_irqrestore(&dir->lock, flags);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(ref_tracker_alloc);\n\nint ref_tracker_free(struct ref_tracker_dir *dir,\n\t\t     struct ref_tracker **trackerp)\n{\n\tunsigned long entries[REF_TRACKER_STACK_ENTRIES];\n\tdepot_stack_handle_t stack_handle;\n\tstruct ref_tracker *tracker;\n\tunsigned int nr_entries;\n\tunsigned long flags;\n\n\tWARN_ON_ONCE(dir->dead);\n\n\tif (!trackerp) {\n\t\trefcount_dec(&dir->no_tracker);\n\t\treturn 0;\n\t}\n\ttracker = *trackerp;\n\tif (!tracker) {\n\t\trefcount_dec(&dir->untracked);\n\t\treturn -EEXIST;\n\t}\n\tnr_entries = stack_trace_save(entries, ARRAY_SIZE(entries), 1);\n\tstack_handle = stack_depot_save(entries, nr_entries,\n\t\t\t\t\tGFP_NOWAIT | __GFP_NOWARN);\n\n\tspin_lock_irqsave(&dir->lock, flags);\n\tif (tracker->dead) {\n\t\tpr_err(\"reference already released.\\n\");\n\t\tif (tracker->alloc_stack_handle) {\n\t\t\tpr_err(\"allocated in:\\n\");\n\t\t\tstack_depot_print(tracker->alloc_stack_handle);\n\t\t}\n\t\tif (tracker->free_stack_handle) {\n\t\t\tpr_err(\"freed in:\\n\");\n\t\t\tstack_depot_print(tracker->free_stack_handle);\n\t\t}\n\t\tspin_unlock_irqrestore(&dir->lock, flags);\n\t\tWARN_ON_ONCE(1);\n\t\treturn -EINVAL;\n\t}\n\ttracker->dead = true;\n\n\ttracker->free_stack_handle = stack_handle;\n\n\tlist_move_tail(&tracker->head, &dir->quarantine);\n\tif (!dir->quarantine_avail) {\n\t\ttracker = list_first_entry(&dir->quarantine, struct ref_tracker, head);\n\t\tlist_del(&tracker->head);\n\t} else {\n\t\tdir->quarantine_avail--;\n\t\ttracker = NULL;\n\t}\n\tspin_unlock_irqrestore(&dir->lock, flags);\n\n\tkfree(tracker);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(ref_tracker_free);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}