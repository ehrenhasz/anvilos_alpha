{
  "module_name": "bootconfig.c",
  "hash_id": "f2d698a4aff3b94363c29ba0de3e5edb0cb2a3038159628ba8eae0fabad5aa21",
  "original_prompt": "Ingested from linux-6.6.14/lib/bootconfig.c",
  "human_readable_source": "\n \n\n#ifdef __KERNEL__\n#include <linux/bootconfig.h>\n#include <linux/bug.h>\n#include <linux/ctype.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\n#ifdef CONFIG_BOOT_CONFIG_EMBED\n \nextern __visible const char embedded_bootconfig_data[];\nextern __visible const char embedded_bootconfig_data_end[];\n\nconst char * __init xbc_get_embedded_bootconfig(size_t *size)\n{\n\t*size = embedded_bootconfig_data_end - embedded_bootconfig_data;\n\treturn (*size) ? embedded_bootconfig_data : NULL;\n}\n#endif\n\n#else  \n \n#include <linux/bootconfig.h>\n#endif\n\n \n\nstatic struct xbc_node *xbc_nodes __initdata;\nstatic int xbc_node_num __initdata;\nstatic char *xbc_data __initdata;\nstatic size_t xbc_data_size __initdata;\nstatic struct xbc_node *last_parent __initdata;\nstatic const char *xbc_err_msg __initdata;\nstatic int xbc_err_pos __initdata;\nstatic int open_brace[XBC_DEPTH_MAX] __initdata;\nstatic int brace_index __initdata;\n\n#ifdef __KERNEL__\nstatic inline void * __init xbc_alloc_mem(size_t size)\n{\n\treturn memblock_alloc(size, SMP_CACHE_BYTES);\n}\n\nstatic inline void __init xbc_free_mem(void *addr, size_t size)\n{\n\tmemblock_free(addr, size);\n}\n\n#else  \n\nstatic inline void *xbc_alloc_mem(size_t size)\n{\n\treturn malloc(size);\n}\n\nstatic inline void xbc_free_mem(void *addr, size_t size)\n{\n\tfree(addr);\n}\n#endif\n \nint __init xbc_get_info(int *node_size, size_t *data_size)\n{\n\tif (!xbc_data)\n\t\treturn -ENODEV;\n\n\tif (node_size)\n\t\t*node_size = xbc_node_num;\n\tif (data_size)\n\t\t*data_size = xbc_data_size;\n\treturn 0;\n}\n\nstatic int __init xbc_parse_error(const char *msg, const char *p)\n{\n\txbc_err_msg = msg;\n\txbc_err_pos = (int)(p - xbc_data);\n\n\treturn -EINVAL;\n}\n\n \nstruct xbc_node * __init xbc_root_node(void)\n{\n\tif (unlikely(!xbc_data))\n\t\treturn NULL;\n\n\treturn xbc_nodes;\n}\n\n \nint __init xbc_node_index(struct xbc_node *node)\n{\n\treturn node - &xbc_nodes[0];\n}\n\n \nstruct xbc_node * __init xbc_node_get_parent(struct xbc_node *node)\n{\n\treturn node->parent == XBC_NODE_MAX ? NULL : &xbc_nodes[node->parent];\n}\n\n \nstruct xbc_node * __init xbc_node_get_child(struct xbc_node *node)\n{\n\treturn node->child ? &xbc_nodes[node->child] : NULL;\n}\n\n \nstruct xbc_node * __init xbc_node_get_next(struct xbc_node *node)\n{\n\treturn node->next ? &xbc_nodes[node->next] : NULL;\n}\n\n \nconst char * __init xbc_node_get_data(struct xbc_node *node)\n{\n\tint offset = node->data & ~XBC_VALUE;\n\n\tif (WARN_ON(offset >= xbc_data_size))\n\t\treturn NULL;\n\n\treturn xbc_data + offset;\n}\n\nstatic bool __init\nxbc_node_match_prefix(struct xbc_node *node, const char **prefix)\n{\n\tconst char *p = xbc_node_get_data(node);\n\tint len = strlen(p);\n\n\tif (strncmp(*prefix, p, len))\n\t\treturn false;\n\n\tp = *prefix + len;\n\tif (*p == '.')\n\t\tp++;\n\telse if (*p != '\\0')\n\t\treturn false;\n\t*prefix = p;\n\n\treturn true;\n}\n\n \nstruct xbc_node * __init\nxbc_node_find_subkey(struct xbc_node *parent, const char *key)\n{\n\tstruct xbc_node *node;\n\n\tif (parent)\n\t\tnode = xbc_node_get_subkey(parent);\n\telse\n\t\tnode = xbc_root_node();\n\n\twhile (node && xbc_node_is_key(node)) {\n\t\tif (!xbc_node_match_prefix(node, &key))\n\t\t\tnode = xbc_node_get_next(node);\n\t\telse if (*key != '\\0')\n\t\t\tnode = xbc_node_get_subkey(node);\n\t\telse\n\t\t\tbreak;\n\t}\n\n\treturn node;\n}\n\n \nconst char * __init\nxbc_node_find_value(struct xbc_node *parent, const char *key,\n\t\t    struct xbc_node **vnode)\n{\n\tstruct xbc_node *node = xbc_node_find_subkey(parent, key);\n\n\tif (!node || !xbc_node_is_key(node))\n\t\treturn NULL;\n\n\tnode = xbc_node_get_child(node);\n\tif (node && !xbc_node_is_value(node))\n\t\treturn NULL;\n\n\tif (vnode)\n\t\t*vnode = node;\n\n\treturn node ? xbc_node_get_data(node) : \"\";\n}\n\n \nint __init xbc_node_compose_key_after(struct xbc_node *root,\n\t\t\t\t      struct xbc_node *node,\n\t\t\t\t      char *buf, size_t size)\n{\n\tuint16_t keys[XBC_DEPTH_MAX];\n\tint depth = 0, ret = 0, total = 0;\n\n\tif (!node || node == root)\n\t\treturn -EINVAL;\n\n\tif (xbc_node_is_value(node))\n\t\tnode = xbc_node_get_parent(node);\n\n\twhile (node && node != root) {\n\t\tkeys[depth++] = xbc_node_index(node);\n\t\tif (depth == XBC_DEPTH_MAX)\n\t\t\treturn -ERANGE;\n\t\tnode = xbc_node_get_parent(node);\n\t}\n\tif (!node && root)\n\t\treturn -EINVAL;\n\n\twhile (--depth >= 0) {\n\t\tnode = xbc_nodes + keys[depth];\n\t\tret = snprintf(buf, size, \"%s%s\", xbc_node_get_data(node),\n\t\t\t       depth ? \".\" : \"\");\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tif (ret > size) {\n\t\t\tsize = 0;\n\t\t} else {\n\t\t\tsize -= ret;\n\t\t\tbuf += ret;\n\t\t}\n\t\ttotal += ret;\n\t}\n\n\treturn total;\n}\n\n \nstruct xbc_node * __init xbc_node_find_next_leaf(struct xbc_node *root,\n\t\t\t\t\t\t struct xbc_node *node)\n{\n\tstruct xbc_node *next;\n\n\tif (unlikely(!xbc_data))\n\t\treturn NULL;\n\n\tif (!node) {\t \n\t\tnode = root;\n\t\tif (!node)\n\t\t\tnode = xbc_nodes;\n\t} else {\n\t\t \n\t\tnext = xbc_node_get_subkey(node);\n\t\tif (next) {\n\t\t\tnode = next;\n\t\t\tgoto found;\n\t\t}\n\n\t\tif (node == root)\t \n\t\t\treturn NULL;\n\n\t\twhile (!node->next) {\n\t\t\tnode = xbc_node_get_parent(node);\n\t\t\tif (node == root)\n\t\t\t\treturn NULL;\n\t\t\t \n\t\t\tif (WARN_ON(!node))\n\t\t\t\treturn NULL;\n\t\t}\n\t\tnode = xbc_node_get_next(node);\n\t}\n\nfound:\n\twhile (node && !xbc_node_is_leaf(node))\n\t\tnode = xbc_node_get_child(node);\n\n\treturn node;\n}\n\n \nconst char * __init xbc_node_find_next_key_value(struct xbc_node *root,\n\t\t\t\t\t\t struct xbc_node **leaf)\n{\n\t \n\tif (WARN_ON(!leaf))\n\t\treturn NULL;\n\n\t*leaf = xbc_node_find_next_leaf(root, *leaf);\n\tif (!*leaf)\n\t\treturn NULL;\n\tif ((*leaf)->child)\n\t\treturn xbc_node_get_data(xbc_node_get_child(*leaf));\n\telse\n\t\treturn \"\";\t \n}\n\n \n\nstatic int __init xbc_init_node(struct xbc_node *node, char *data, uint32_t flag)\n{\n\tunsigned long offset = data - xbc_data;\n\n\tif (WARN_ON(offset >= XBC_DATA_MAX))\n\t\treturn -EINVAL;\n\n\tnode->data = (uint16_t)offset | flag;\n\tnode->child = 0;\n\tnode->next = 0;\n\n\treturn 0;\n}\n\nstatic struct xbc_node * __init xbc_add_node(char *data, uint32_t flag)\n{\n\tstruct xbc_node *node;\n\n\tif (xbc_node_num == XBC_NODE_MAX)\n\t\treturn NULL;\n\n\tnode = &xbc_nodes[xbc_node_num++];\n\tif (xbc_init_node(node, data, flag) < 0)\n\t\treturn NULL;\n\n\treturn node;\n}\n\nstatic inline __init struct xbc_node *xbc_last_sibling(struct xbc_node *node)\n{\n\twhile (node->next)\n\t\tnode = xbc_node_get_next(node);\n\n\treturn node;\n}\n\nstatic inline __init struct xbc_node *xbc_last_child(struct xbc_node *node)\n{\n\twhile (node->child)\n\t\tnode = xbc_node_get_child(node);\n\n\treturn node;\n}\n\nstatic struct xbc_node * __init __xbc_add_sibling(char *data, uint32_t flag, bool head)\n{\n\tstruct xbc_node *sib, *node = xbc_add_node(data, flag);\n\n\tif (node) {\n\t\tif (!last_parent) {\n\t\t\t \n\t\t\tnode->parent = XBC_NODE_MAX;\n\t\t\tsib = xbc_last_sibling(xbc_nodes);\n\t\t\tsib->next = xbc_node_index(node);\n\t\t} else {\n\t\t\tnode->parent = xbc_node_index(last_parent);\n\t\t\tif (!last_parent->child || head) {\n\t\t\t\tnode->next = last_parent->child;\n\t\t\t\tlast_parent->child = xbc_node_index(node);\n\t\t\t} else {\n\t\t\t\tsib = xbc_node_get_child(last_parent);\n\t\t\t\tsib = xbc_last_sibling(sib);\n\t\t\t\tsib->next = xbc_node_index(node);\n\t\t\t}\n\t\t}\n\t} else\n\t\txbc_parse_error(\"Too many nodes\", data);\n\n\treturn node;\n}\n\nstatic inline struct xbc_node * __init xbc_add_sibling(char *data, uint32_t flag)\n{\n\treturn __xbc_add_sibling(data, flag, false);\n}\n\nstatic inline struct xbc_node * __init xbc_add_head_sibling(char *data, uint32_t flag)\n{\n\treturn __xbc_add_sibling(data, flag, true);\n}\n\nstatic inline __init struct xbc_node *xbc_add_child(char *data, uint32_t flag)\n{\n\tstruct xbc_node *node = xbc_add_sibling(data, flag);\n\n\tif (node)\n\t\tlast_parent = node;\n\n\treturn node;\n}\n\nstatic inline __init bool xbc_valid_keyword(char *key)\n{\n\tif (key[0] == '\\0')\n\t\treturn false;\n\n\twhile (isalnum(*key) || *key == '-' || *key == '_')\n\t\tkey++;\n\n\treturn *key == '\\0';\n}\n\nstatic char *skip_comment(char *p)\n{\n\tchar *ret;\n\n\tret = strchr(p, '\\n');\n\tif (!ret)\n\t\tret = p + strlen(p);\n\telse\n\t\tret++;\n\n\treturn ret;\n}\n\nstatic char *skip_spaces_until_newline(char *p)\n{\n\twhile (isspace(*p) && *p != '\\n')\n\t\tp++;\n\treturn p;\n}\n\nstatic int __init __xbc_open_brace(char *p)\n{\n\t \n\topen_brace[brace_index++] = xbc_node_index(last_parent);\n\tif (brace_index >= XBC_DEPTH_MAX)\n\t\treturn xbc_parse_error(\"Exceed max depth of braces\", p);\n\n\treturn 0;\n}\n\nstatic int __init __xbc_close_brace(char *p)\n{\n\tbrace_index--;\n\tif (!last_parent || brace_index < 0 ||\n\t    (open_brace[brace_index] != xbc_node_index(last_parent)))\n\t\treturn xbc_parse_error(\"Unexpected closing brace\", p);\n\n\tif (brace_index == 0)\n\t\tlast_parent = NULL;\n\telse\n\t\tlast_parent = &xbc_nodes[open_brace[brace_index - 1]];\n\n\treturn 0;\n}\n\n \nstatic int __init __xbc_parse_value(char **__v, char **__n)\n{\n\tchar *p, *v = *__v;\n\tint c, quotes = 0;\n\n\tv = skip_spaces(v);\n\twhile (*v == '#') {\n\t\tv = skip_comment(v);\n\t\tv = skip_spaces(v);\n\t}\n\tif (*v == '\"' || *v == '\\'') {\n\t\tquotes = *v;\n\t\tv++;\n\t}\n\tp = v - 1;\n\twhile ((c = *++p)) {\n\t\tif (!isprint(c) && !isspace(c))\n\t\t\treturn xbc_parse_error(\"Non printable value\", p);\n\t\tif (quotes) {\n\t\t\tif (c != quotes)\n\t\t\t\tcontinue;\n\t\t\tquotes = 0;\n\t\t\t*p++ = '\\0';\n\t\t\tp = skip_spaces_until_newline(p);\n\t\t\tc = *p;\n\t\t\tif (c && !strchr(\",;\\n#}\", c))\n\t\t\t\treturn xbc_parse_error(\"No value delimiter\", p);\n\t\t\tif (*p)\n\t\t\t\tp++;\n\t\t\tbreak;\n\t\t}\n\t\tif (strchr(\",;\\n#}\", c)) {\n\t\t\t*p++ = '\\0';\n\t\t\tv = strim(v);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (quotes)\n\t\treturn xbc_parse_error(\"No closing quotes\", p);\n\tif (c == '#') {\n\t\tp = skip_comment(p);\n\t\tc = '\\n';\t \n\t}\n\t*__n = p;\n\t*__v = v;\n\n\treturn c;\n}\n\nstatic int __init xbc_parse_array(char **__v)\n{\n\tstruct xbc_node *node;\n\tchar *next;\n\tint c = 0;\n\n\tif (last_parent->child)\n\t\tlast_parent = xbc_node_get_child(last_parent);\n\n\tdo {\n\t\tc = __xbc_parse_value(__v, &next);\n\t\tif (c < 0)\n\t\t\treturn c;\n\n\t\tnode = xbc_add_child(*__v, XBC_VALUE);\n\t\tif (!node)\n\t\t\treturn -ENOMEM;\n\t\t*__v = next;\n\t} while (c == ',');\n\tnode->child = 0;\n\n\treturn c;\n}\n\nstatic inline __init\nstruct xbc_node *find_match_node(struct xbc_node *node, char *k)\n{\n\twhile (node) {\n\t\tif (!strcmp(xbc_node_get_data(node), k))\n\t\t\tbreak;\n\t\tnode = xbc_node_get_next(node);\n\t}\n\treturn node;\n}\n\nstatic int __init __xbc_add_key(char *k)\n{\n\tstruct xbc_node *node, *child;\n\n\tif (!xbc_valid_keyword(k))\n\t\treturn xbc_parse_error(\"Invalid keyword\", k);\n\n\tif (unlikely(xbc_node_num == 0))\n\t\tgoto add_node;\n\n\tif (!last_parent)\t \n\t\tnode = find_match_node(xbc_nodes, k);\n\telse {\n\t\tchild = xbc_node_get_child(last_parent);\n\t\t \n\t\tif (child && xbc_node_is_value(child))\n\t\t\tchild = xbc_node_get_next(child);\n\t\tnode = find_match_node(child, k);\n\t}\n\n\tif (node)\n\t\tlast_parent = node;\n\telse {\nadd_node:\n\t\tnode = xbc_add_child(k, XBC_KEY);\n\t\tif (!node)\n\t\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}\n\nstatic int __init __xbc_parse_keys(char *k)\n{\n\tchar *p;\n\tint ret;\n\n\tk = strim(k);\n\twhile ((p = strchr(k, '.'))) {\n\t\t*p++ = '\\0';\n\t\tret = __xbc_add_key(k);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tk = p;\n\t}\n\n\treturn __xbc_add_key(k);\n}\n\nstatic int __init xbc_parse_kv(char **k, char *v, int op)\n{\n\tstruct xbc_node *prev_parent = last_parent;\n\tstruct xbc_node *child;\n\tchar *next;\n\tint c, ret;\n\n\tret = __xbc_parse_keys(*k);\n\tif (ret)\n\t\treturn ret;\n\n\tc = __xbc_parse_value(&v, &next);\n\tif (c < 0)\n\t\treturn c;\n\n\tchild = xbc_node_get_child(last_parent);\n\tif (child && xbc_node_is_value(child)) {\n\t\tif (op == '=')\n\t\t\treturn xbc_parse_error(\"Value is redefined\", v);\n\t\tif (op == ':') {\n\t\t\tunsigned short nidx = child->next;\n\n\t\t\txbc_init_node(child, v, XBC_VALUE);\n\t\t\tchild->next = nidx;\t \n\t\t\tgoto array;\n\t\t}\n\t\t \n\t\tlast_parent = xbc_last_child(child);\n\t}\n\t \n\tif (!xbc_add_head_sibling(v, XBC_VALUE))\n\t\treturn -ENOMEM;\n\narray:\n\tif (c == ',') {\t \n\t\tc = xbc_parse_array(&next);\n\t\tif (c < 0)\n\t\t\treturn c;\n\t}\n\n\tlast_parent = prev_parent;\n\n\tif (c == '}') {\n\t\tret = __xbc_close_brace(next - 1);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\t*k = next;\n\n\treturn 0;\n}\n\nstatic int __init xbc_parse_key(char **k, char *n)\n{\n\tstruct xbc_node *prev_parent = last_parent;\n\tint ret;\n\n\t*k = strim(*k);\n\tif (**k != '\\0') {\n\t\tret = __xbc_parse_keys(*k);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tlast_parent = prev_parent;\n\t}\n\t*k = n;\n\n\treturn 0;\n}\n\nstatic int __init xbc_open_brace(char **k, char *n)\n{\n\tint ret;\n\n\tret = __xbc_parse_keys(*k);\n\tif (ret)\n\t\treturn ret;\n\t*k = n;\n\n\treturn __xbc_open_brace(n - 1);\n}\n\nstatic int __init xbc_close_brace(char **k, char *n)\n{\n\tint ret;\n\n\tret = xbc_parse_key(k, n);\n\tif (ret)\n\t\treturn ret;\n\t \n\n\treturn __xbc_close_brace(n - 1);\n}\n\nstatic int __init xbc_verify_tree(void)\n{\n\tint i, depth, len, wlen;\n\tstruct xbc_node *n, *m;\n\n\t \n\tif (brace_index) {\n\t\tn = &xbc_nodes[open_brace[brace_index]];\n\t\treturn xbc_parse_error(\"Brace is not closed\",\n\t\t\t\t\txbc_node_get_data(n));\n\t}\n\n\t \n\tif (xbc_node_num == 0) {\n\t\txbc_parse_error(\"Empty config\", xbc_data);\n\t\treturn -ENOENT;\n\t}\n\n\tfor (i = 0; i < xbc_node_num; i++) {\n\t\tif (xbc_nodes[i].next > xbc_node_num) {\n\t\t\treturn xbc_parse_error(\"No closing brace\",\n\t\t\t\txbc_node_get_data(xbc_nodes + i));\n\t\t}\n\t}\n\n\t \n\tn = &xbc_nodes[0];\n\tdepth = 1;\n\tlen = 0;\n\n\twhile (n) {\n\t\twlen = strlen(xbc_node_get_data(n)) + 1;\n\t\tlen += wlen;\n\t\tif (len > XBC_KEYLEN_MAX)\n\t\t\treturn xbc_parse_error(\"Too long key length\",\n\t\t\t\txbc_node_get_data(n));\n\n\t\tm = xbc_node_get_child(n);\n\t\tif (m && xbc_node_is_key(m)) {\n\t\t\tn = m;\n\t\t\tdepth++;\n\t\t\tif (depth > XBC_DEPTH_MAX)\n\t\t\t\treturn xbc_parse_error(\"Too many key words\",\n\t\t\t\t\t\txbc_node_get_data(n));\n\t\t\tcontinue;\n\t\t}\n\t\tlen -= wlen;\n\t\tm = xbc_node_get_next(n);\n\t\twhile (!m) {\n\t\t\tn = xbc_node_get_parent(n);\n\t\t\tif (!n)\n\t\t\t\tbreak;\n\t\t\tlen -= strlen(xbc_node_get_data(n)) + 1;\n\t\t\tdepth--;\n\t\t\tm = xbc_node_get_next(n);\n\t\t}\n\t\tn = m;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int __init xbc_parse_tree(void)\n{\n\tchar *p, *q;\n\tint ret = 0, c;\n\n\tlast_parent = NULL;\n\tp = xbc_data;\n\tdo {\n\t\tq = strpbrk(p, \"{}=+;:\\n#\");\n\t\tif (!q) {\n\t\t\tp = skip_spaces(p);\n\t\t\tif (*p != '\\0')\n\t\t\t\tret = xbc_parse_error(\"No delimiter\", p);\n\t\t\tbreak;\n\t\t}\n\n\t\tc = *q;\n\t\t*q++ = '\\0';\n\t\tswitch (c) {\n\t\tcase ':':\n\t\tcase '+':\n\t\t\tif (*q++ != '=') {\n\t\t\t\tret = xbc_parse_error(c == '+' ?\n\t\t\t\t\t\t\"Wrong '+' operator\" :\n\t\t\t\t\t\t\"Wrong ':' operator\",\n\t\t\t\t\t\t\tq - 2);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfallthrough;\n\t\tcase '=':\n\t\t\tret = xbc_parse_kv(&p, q, c);\n\t\t\tbreak;\n\t\tcase '{':\n\t\t\tret = xbc_open_brace(&p, q);\n\t\t\tbreak;\n\t\tcase '#':\n\t\t\tq = skip_comment(q);\n\t\t\tfallthrough;\n\t\tcase ';':\n\t\tcase '\\n':\n\t\t\tret = xbc_parse_key(&p, q);\n\t\t\tbreak;\n\t\tcase '}':\n\t\t\tret = xbc_close_brace(&p, q);\n\t\t\tbreak;\n\t\t}\n\t} while (!ret);\n\n\treturn ret;\n}\n\n \nvoid __init xbc_exit(void)\n{\n\txbc_free_mem(xbc_data, xbc_data_size);\n\txbc_data = NULL;\n\txbc_data_size = 0;\n\txbc_node_num = 0;\n\txbc_free_mem(xbc_nodes, sizeof(struct xbc_node) * XBC_NODE_MAX);\n\txbc_nodes = NULL;\n\tbrace_index = 0;\n}\n\n \nint __init xbc_init(const char *data, size_t size, const char **emsg, int *epos)\n{\n\tint ret;\n\n\tif (epos)\n\t\t*epos = -1;\n\n\tif (xbc_data) {\n\t\tif (emsg)\n\t\t\t*emsg = \"Bootconfig is already initialized\";\n\t\treturn -EBUSY;\n\t}\n\tif (size > XBC_DATA_MAX || size == 0) {\n\t\tif (emsg)\n\t\t\t*emsg = size ? \"Config data is too big\" :\n\t\t\t\t\"Config data is empty\";\n\t\treturn -ERANGE;\n\t}\n\n\txbc_data = xbc_alloc_mem(size + 1);\n\tif (!xbc_data) {\n\t\tif (emsg)\n\t\t\t*emsg = \"Failed to allocate bootconfig data\";\n\t\treturn -ENOMEM;\n\t}\n\tmemcpy(xbc_data, data, size);\n\txbc_data[size] = '\\0';\n\txbc_data_size = size + 1;\n\n\txbc_nodes = xbc_alloc_mem(sizeof(struct xbc_node) * XBC_NODE_MAX);\n\tif (!xbc_nodes) {\n\t\tif (emsg)\n\t\t\t*emsg = \"Failed to allocate bootconfig nodes\";\n\t\txbc_exit();\n\t\treturn -ENOMEM;\n\t}\n\tmemset(xbc_nodes, 0, sizeof(struct xbc_node) * XBC_NODE_MAX);\n\n\tret = xbc_parse_tree();\n\tif (!ret)\n\t\tret = xbc_verify_tree();\n\n\tif (ret < 0) {\n\t\tif (epos)\n\t\t\t*epos = xbc_err_pos;\n\t\tif (emsg)\n\t\t\t*emsg = xbc_err_msg;\n\t\txbc_exit();\n\t} else\n\t\tret = xbc_node_num;\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}