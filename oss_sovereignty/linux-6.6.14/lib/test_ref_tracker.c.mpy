{
  "module_name": "test_ref_tracker.c",
  "hash_id": "8c5f505507bccd72e175c1b0647e34e1a5376e462ebbda0905c7b3ea2d0e51fd",
  "original_prompt": "Ingested from linux-6.6.14/lib/test_ref_tracker.c",
  "human_readable_source": "\n \n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/ref_tracker.h>\n#include <linux/slab.h>\n#include <linux/timer.h>\n\nstatic struct ref_tracker_dir ref_dir;\nstatic struct ref_tracker *tracker[20];\n\n#define TRT_ALLOC(X) static noinline void \t\t\t\t\\\n\talloctest_ref_tracker_alloc##X(struct ref_tracker_dir *dir, \t\\\n\t\t\t\t    struct ref_tracker **trackerp)\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\tref_tracker_alloc(dir, trackerp, GFP_KERNEL);\t\t\\\n\t}\n\nTRT_ALLOC(1)\nTRT_ALLOC(2)\nTRT_ALLOC(3)\nTRT_ALLOC(4)\nTRT_ALLOC(5)\nTRT_ALLOC(6)\nTRT_ALLOC(7)\nTRT_ALLOC(8)\nTRT_ALLOC(9)\nTRT_ALLOC(10)\nTRT_ALLOC(11)\nTRT_ALLOC(12)\nTRT_ALLOC(13)\nTRT_ALLOC(14)\nTRT_ALLOC(15)\nTRT_ALLOC(16)\nTRT_ALLOC(17)\nTRT_ALLOC(18)\nTRT_ALLOC(19)\n\n#undef TRT_ALLOC\n\nstatic noinline void\nalloctest_ref_tracker_free(struct ref_tracker_dir *dir,\n\t\t\t   struct ref_tracker **trackerp)\n{\n\tref_tracker_free(dir, trackerp);\n}\n\n\nstatic struct timer_list test_ref_tracker_timer;\nstatic atomic_t test_ref_timer_done = ATOMIC_INIT(0);\n\nstatic void test_ref_tracker_timer_func(struct timer_list *t)\n{\n\tref_tracker_alloc(&ref_dir, &tracker[0], GFP_ATOMIC);\n\tatomic_set(&test_ref_timer_done, 1);\n}\n\nstatic int __init test_ref_tracker_init(void)\n{\n\tint i;\n\n\tref_tracker_dir_init(&ref_dir, 100, \"selftest\");\n\n\ttimer_setup(&test_ref_tracker_timer, test_ref_tracker_timer_func, 0);\n\tmod_timer(&test_ref_tracker_timer, jiffies + 1);\n\n\talloctest_ref_tracker_alloc1(&ref_dir, &tracker[1]);\n\talloctest_ref_tracker_alloc2(&ref_dir, &tracker[2]);\n\talloctest_ref_tracker_alloc3(&ref_dir, &tracker[3]);\n\talloctest_ref_tracker_alloc4(&ref_dir, &tracker[4]);\n\talloctest_ref_tracker_alloc5(&ref_dir, &tracker[5]);\n\talloctest_ref_tracker_alloc6(&ref_dir, &tracker[6]);\n\talloctest_ref_tracker_alloc7(&ref_dir, &tracker[7]);\n\talloctest_ref_tracker_alloc8(&ref_dir, &tracker[8]);\n\talloctest_ref_tracker_alloc9(&ref_dir, &tracker[9]);\n\talloctest_ref_tracker_alloc10(&ref_dir, &tracker[10]);\n\talloctest_ref_tracker_alloc11(&ref_dir, &tracker[11]);\n\talloctest_ref_tracker_alloc12(&ref_dir, &tracker[12]);\n\talloctest_ref_tracker_alloc13(&ref_dir, &tracker[13]);\n\talloctest_ref_tracker_alloc14(&ref_dir, &tracker[14]);\n\talloctest_ref_tracker_alloc15(&ref_dir, &tracker[15]);\n\talloctest_ref_tracker_alloc16(&ref_dir, &tracker[16]);\n\talloctest_ref_tracker_alloc17(&ref_dir, &tracker[17]);\n\talloctest_ref_tracker_alloc18(&ref_dir, &tracker[18]);\n\talloctest_ref_tracker_alloc19(&ref_dir, &tracker[19]);\n\n\t \n\tfor (i = 2; i < ARRAY_SIZE(tracker); i++)\n\t\talloctest_ref_tracker_free(&ref_dir, &tracker[i]);\n\n\t \n\talloctest_ref_tracker_free(&ref_dir, &tracker[2]);\n\n\twhile (!atomic_read(&test_ref_timer_done))\n\t\tmsleep(1);\n\n\t \n\tref_tracker_dir_exit(&ref_dir);\n\n\treturn 0;\n}\n\nstatic void __exit test_ref_tracker_exit(void)\n{\n}\n\nmodule_init(test_ref_tracker_init);\nmodule_exit(test_ref_tracker_exit);\n\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}