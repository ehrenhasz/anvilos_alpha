{
  "module_name": "crc64-rocksoft.c",
  "hash_id": "533fdb0aa95669cd197c1254534d3c8c221123e5114e846135b9f28347c632b2",
  "original_prompt": "Ingested from linux-6.6.14/lib/crc64-rocksoft.c",
  "human_readable_source": "\n\n#include <linux/types.h>\n#include <linux/module.h>\n#include <linux/crc64.h>\n#include <linux/err.h>\n#include <linux/init.h>\n#include <crypto/hash.h>\n#include <crypto/algapi.h>\n#include <linux/static_key.h>\n#include <linux/notifier.h>\n\nstatic struct crypto_shash __rcu *crc64_rocksoft_tfm;\nstatic DEFINE_STATIC_KEY_TRUE(crc64_rocksoft_fallback);\nstatic DEFINE_MUTEX(crc64_rocksoft_mutex);\nstatic struct work_struct crc64_rocksoft_rehash_work;\n\nstatic int crc64_rocksoft_notify(struct notifier_block *self, unsigned long val, void *data)\n{\n\tstruct crypto_alg *alg = data;\n\n\tif (val != CRYPTO_MSG_ALG_LOADED ||\n\t    strcmp(alg->cra_name, CRC64_ROCKSOFT_STRING))\n\t\treturn NOTIFY_DONE;\n\n\tschedule_work(&crc64_rocksoft_rehash_work);\n\treturn NOTIFY_OK;\n}\n\nstatic void crc64_rocksoft_rehash(struct work_struct *work)\n{\n\tstruct crypto_shash *new, *old;\n\n\tmutex_lock(&crc64_rocksoft_mutex);\n\told = rcu_dereference_protected(crc64_rocksoft_tfm,\n\t\t\t\t\tlockdep_is_held(&crc64_rocksoft_mutex));\n\tnew = crypto_alloc_shash(CRC64_ROCKSOFT_STRING, 0, 0);\n\tif (IS_ERR(new)) {\n\t\tmutex_unlock(&crc64_rocksoft_mutex);\n\t\treturn;\n\t}\n\trcu_assign_pointer(crc64_rocksoft_tfm, new);\n\tmutex_unlock(&crc64_rocksoft_mutex);\n\n\tif (old) {\n\t\tsynchronize_rcu();\n\t\tcrypto_free_shash(old);\n\t} else {\n\t\tstatic_branch_disable(&crc64_rocksoft_fallback);\n\t}\n}\n\nstatic struct notifier_block crc64_rocksoft_nb = {\n\t.notifier_call = crc64_rocksoft_notify,\n};\n\nu64 crc64_rocksoft_update(u64 crc, const unsigned char *buffer, size_t len)\n{\n\tstruct {\n\t\tstruct shash_desc shash;\n\t\tu64 crc;\n\t} desc;\n\tint err;\n\n\tif (static_branch_unlikely(&crc64_rocksoft_fallback))\n\t\treturn crc64_rocksoft_generic(crc, buffer, len);\n\n\trcu_read_lock();\n\tdesc.shash.tfm = rcu_dereference(crc64_rocksoft_tfm);\n\tdesc.crc = crc;\n\terr = crypto_shash_update(&desc.shash, buffer, len);\n\trcu_read_unlock();\n\n\tBUG_ON(err);\n\n\treturn desc.crc;\n}\nEXPORT_SYMBOL_GPL(crc64_rocksoft_update);\n\nu64 crc64_rocksoft(const unsigned char *buffer, size_t len)\n{\n\treturn crc64_rocksoft_update(0, buffer, len);\n}\nEXPORT_SYMBOL_GPL(crc64_rocksoft);\n\nstatic int __init crc64_rocksoft_mod_init(void)\n{\n\tINIT_WORK(&crc64_rocksoft_rehash_work, crc64_rocksoft_rehash);\n\tcrypto_register_notifier(&crc64_rocksoft_nb);\n\tcrc64_rocksoft_rehash(&crc64_rocksoft_rehash_work);\n\treturn 0;\n}\n\nstatic void __exit crc64_rocksoft_mod_fini(void)\n{\n\tcrypto_unregister_notifier(&crc64_rocksoft_nb);\n\tcancel_work_sync(&crc64_rocksoft_rehash_work);\n\tcrypto_free_shash(rcu_dereference_protected(crc64_rocksoft_tfm, 1));\n}\n\nmodule_init(crc64_rocksoft_mod_init);\nmodule_exit(crc64_rocksoft_mod_fini);\n\nstatic int crc64_rocksoft_transform_show(char *buffer, const struct kernel_param *kp)\n{\n\tstruct crypto_shash *tfm;\n\tint len;\n\n\tif (static_branch_unlikely(&crc64_rocksoft_fallback))\n\t\treturn sprintf(buffer, \"fallback\\n\");\n\n\trcu_read_lock();\n\ttfm = rcu_dereference(crc64_rocksoft_tfm);\n\tlen = snprintf(buffer, PAGE_SIZE, \"%s\\n\",\n\t\t       crypto_shash_driver_name(tfm));\n\trcu_read_unlock();\n\n\treturn len;\n}\n\nmodule_param_call(transform, NULL, crc64_rocksoft_transform_show, NULL, 0444);\n\nMODULE_AUTHOR(\"Keith Busch <kbusch@kernel.org>\");\nMODULE_DESCRIPTION(\"Rocksoft model CRC64 calculation (library API)\");\nMODULE_LICENSE(\"GPL\");\nMODULE_SOFTDEP(\"pre: crc64\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}