{
  "module_name": "kunit_iov_iter.c",
  "hash_id": "358e8de00dee8823b4f0ac2fd8e6cbc16c8f4302208006996305f9eba695b7a4",
  "original_prompt": "Ingested from linux-6.6.14/lib/kunit_iov_iter.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/uio.h>\n#include <linux/bvec.h>\n#include <kunit/test.h>\n\nMODULE_DESCRIPTION(\"iov_iter testing\");\nMODULE_AUTHOR(\"David Howells <dhowells@redhat.com>\");\nMODULE_LICENSE(\"GPL\");\n\nstruct kvec_test_range {\n\tint\tfrom, to;\n};\n\nstatic const struct kvec_test_range kvec_test_ranges[] = {\n\t{ 0x00002, 0x00002 },\n\t{ 0x00027, 0x03000 },\n\t{ 0x05193, 0x18794 },\n\t{ 0x20000, 0x20000 },\n\t{ 0x20000, 0x24000 },\n\t{ 0x24000, 0x27001 },\n\t{ 0x29000, 0xffffb },\n\t{ 0xffffd, 0xffffe },\n\t{ -1 }\n};\n\nstatic inline u8 pattern(unsigned long x)\n{\n\treturn x & 0xff;\n}\n\nstatic void iov_kunit_unmap(void *data)\n{\n\tvunmap(data);\n}\n\nstatic void *__init iov_kunit_create_buffer(struct kunit *test,\n\t\t\t\t\t    struct page ***ppages,\n\t\t\t\t\t    size_t npages)\n{\n\tstruct page **pages;\n\tunsigned long got;\n\tvoid *buffer;\n\n\tpages = kunit_kcalloc(test, npages, sizeof(struct page *), GFP_KERNEL);\n        KUNIT_ASSERT_NOT_ERR_OR_NULL(test, pages);\n\t*ppages = pages;\n\n\tgot = alloc_pages_bulk_array(GFP_KERNEL, npages, pages);\n\tif (got != npages) {\n\t\trelease_pages(pages, got);\n\t\tKUNIT_ASSERT_EQ(test, got, npages);\n\t}\n\n\tbuffer = vmap(pages, npages, VM_MAP | VM_MAP_PUT_PAGES, PAGE_KERNEL);\n        KUNIT_ASSERT_NOT_ERR_OR_NULL(test, buffer);\n\n\tkunit_add_action_or_reset(test, iov_kunit_unmap, buffer);\n\treturn buffer;\n}\n\nstatic void __init iov_kunit_load_kvec(struct kunit *test,\n\t\t\t\t       struct iov_iter *iter, int dir,\n\t\t\t\t       struct kvec *kvec, unsigned int kvmax,\n\t\t\t\t       void *buffer, size_t bufsize,\n\t\t\t\t       const struct kvec_test_range *pr)\n{\n\tsize_t size = 0;\n\tint i;\n\n\tfor (i = 0; i < kvmax; i++, pr++) {\n\t\tif (pr->from < 0)\n\t\t\tbreak;\n\t\tKUNIT_ASSERT_GE(test, pr->to, pr->from);\n\t\tKUNIT_ASSERT_LE(test, pr->to, bufsize);\n\t\tkvec[i].iov_base = buffer + pr->from;\n\t\tkvec[i].iov_len = pr->to - pr->from;\n\t\tsize += pr->to - pr->from;\n\t}\n\tKUNIT_ASSERT_LE(test, size, bufsize);\n\n\tiov_iter_kvec(iter, dir, kvec, i, size);\n}\n\n \nstatic void __init iov_kunit_copy_to_kvec(struct kunit *test)\n{\n\tconst struct kvec_test_range *pr;\n\tstruct iov_iter iter;\n\tstruct page **spages, **bpages;\n\tstruct kvec kvec[8];\n\tu8 *scratch, *buffer;\n\tsize_t bufsize, npages, size, copied;\n\tint i, patt;\n\n\tbufsize = 0x100000;\n\tnpages = bufsize / PAGE_SIZE;\n\n\tscratch = iov_kunit_create_buffer(test, &spages, npages);\n\tfor (i = 0; i < bufsize; i++)\n\t\tscratch[i] = pattern(i);\n\n\tbuffer = iov_kunit_create_buffer(test, &bpages, npages);\n\tmemset(buffer, 0, bufsize);\n\n\tiov_kunit_load_kvec(test, &iter, READ, kvec, ARRAY_SIZE(kvec),\n\t\t\t    buffer, bufsize, kvec_test_ranges);\n\tsize = iter.count;\n\n\tcopied = copy_to_iter(scratch, size, &iter);\n\n\tKUNIT_EXPECT_EQ(test, copied, size);\n\tKUNIT_EXPECT_EQ(test, iter.count, 0);\n\tKUNIT_EXPECT_EQ(test, iter.nr_segs, 0);\n\n\t \n\tpatt = 0;\n\tmemset(scratch, 0, bufsize);\n\tfor (pr = kvec_test_ranges; pr->from >= 0; pr++)\n\t\tfor (i = pr->from; i < pr->to; i++)\n\t\t\tscratch[i] = pattern(patt++);\n\n\t \n\tfor (i = 0; i < bufsize; i++) {\n\t\tKUNIT_EXPECT_EQ_MSG(test, buffer[i], scratch[i], \"at i=%x\", i);\n\t\tif (buffer[i] != scratch[i])\n\t\t\treturn;\n\t}\n\n\tKUNIT_SUCCEED();\n}\n\n \nstatic void __init iov_kunit_copy_from_kvec(struct kunit *test)\n{\n\tconst struct kvec_test_range *pr;\n\tstruct iov_iter iter;\n\tstruct page **spages, **bpages;\n\tstruct kvec kvec[8];\n\tu8 *scratch, *buffer;\n\tsize_t bufsize, npages, size, copied;\n\tint i, j;\n\n\tbufsize = 0x100000;\n\tnpages = bufsize / PAGE_SIZE;\n\n\tbuffer = iov_kunit_create_buffer(test, &bpages, npages);\n\tfor (i = 0; i < bufsize; i++)\n\t\tbuffer[i] = pattern(i);\n\n\tscratch = iov_kunit_create_buffer(test, &spages, npages);\n\tmemset(scratch, 0, bufsize);\n\n\tiov_kunit_load_kvec(test, &iter, WRITE, kvec, ARRAY_SIZE(kvec),\n\t\t\t    buffer, bufsize, kvec_test_ranges);\n\tsize = min(iter.count, bufsize);\n\n\tcopied = copy_from_iter(scratch, size, &iter);\n\n\tKUNIT_EXPECT_EQ(test, copied, size);\n\tKUNIT_EXPECT_EQ(test, iter.count, 0);\n\tKUNIT_EXPECT_EQ(test, iter.nr_segs, 0);\n\n\t \n\ti = 0;\n\tmemset(buffer, 0, bufsize);\n\tfor (pr = kvec_test_ranges; pr->from >= 0; pr++) {\n\t\tfor (j = pr->from; j < pr->to; j++) {\n\t\t\tbuffer[i++] = pattern(j);\n\t\t\tif (i >= bufsize)\n\t\t\t\tgoto stop;\n\t\t}\n\t}\nstop:\n\n\t \n\tfor (i = 0; i < bufsize; i++) {\n\t\tKUNIT_EXPECT_EQ_MSG(test, scratch[i], buffer[i], \"at i=%x\", i);\n\t\tif (scratch[i] != buffer[i])\n\t\t\treturn;\n\t}\n\n\tKUNIT_SUCCEED();\n}\n\nstruct bvec_test_range {\n\tint\tpage, from, to;\n};\n\nstatic const struct bvec_test_range bvec_test_ranges[] = {\n\t{ 0, 0x0002, 0x0002 },\n\t{ 1, 0x0027, 0x0893 },\n\t{ 2, 0x0193, 0x0794 },\n\t{ 3, 0x0000, 0x1000 },\n\t{ 4, 0x0000, 0x1000 },\n\t{ 5, 0x0000, 0x1000 },\n\t{ 6, 0x0000, 0x0ffb },\n\t{ 6, 0x0ffd, 0x0ffe },\n\t{ -1, -1, -1 }\n};\n\nstatic void __init iov_kunit_load_bvec(struct kunit *test,\n\t\t\t\t       struct iov_iter *iter, int dir,\n\t\t\t\t       struct bio_vec *bvec, unsigned int bvmax,\n\t\t\t\t       struct page **pages, size_t npages,\n\t\t\t\t       size_t bufsize,\n\t\t\t\t       const struct bvec_test_range *pr)\n{\n\tstruct page *can_merge = NULL, *page;\n\tsize_t size = 0;\n\tint i;\n\n\tfor (i = 0; i < bvmax; i++, pr++) {\n\t\tif (pr->from < 0)\n\t\t\tbreak;\n\t\tKUNIT_ASSERT_LT(test, pr->page, npages);\n\t\tKUNIT_ASSERT_LT(test, pr->page * PAGE_SIZE, bufsize);\n\t\tKUNIT_ASSERT_GE(test, pr->from, 0);\n\t\tKUNIT_ASSERT_GE(test, pr->to, pr->from);\n\t\tKUNIT_ASSERT_LE(test, pr->to, PAGE_SIZE);\n\n\t\tpage = pages[pr->page];\n\t\tif (pr->from == 0 && pr->from != pr->to && page == can_merge) {\n\t\t\ti--;\n\t\t\tbvec[i].bv_len += pr->to;\n\t\t} else {\n\t\t\tbvec_set_page(&bvec[i], page, pr->to - pr->from, pr->from);\n\t\t}\n\n\t\tsize += pr->to - pr->from;\n\t\tif ((pr->to & ~PAGE_MASK) == 0)\n\t\t\tcan_merge = page + pr->to / PAGE_SIZE;\n\t\telse\n\t\t\tcan_merge = NULL;\n\t}\n\n\tiov_iter_bvec(iter, dir, bvec, i, size);\n}\n\n \nstatic void __init iov_kunit_copy_to_bvec(struct kunit *test)\n{\n\tconst struct bvec_test_range *pr;\n\tstruct iov_iter iter;\n\tstruct bio_vec bvec[8];\n\tstruct page **spages, **bpages;\n\tu8 *scratch, *buffer;\n\tsize_t bufsize, npages, size, copied;\n\tint i, b, patt;\n\n\tbufsize = 0x100000;\n\tnpages = bufsize / PAGE_SIZE;\n\n\tscratch = iov_kunit_create_buffer(test, &spages, npages);\n\tfor (i = 0; i < bufsize; i++)\n\t\tscratch[i] = pattern(i);\n\n\tbuffer = iov_kunit_create_buffer(test, &bpages, npages);\n\tmemset(buffer, 0, bufsize);\n\n\tiov_kunit_load_bvec(test, &iter, READ, bvec, ARRAY_SIZE(bvec),\n\t\t\t    bpages, npages, bufsize, bvec_test_ranges);\n\tsize = iter.count;\n\n\tcopied = copy_to_iter(scratch, size, &iter);\n\n\tKUNIT_EXPECT_EQ(test, copied, size);\n\tKUNIT_EXPECT_EQ(test, iter.count, 0);\n\tKUNIT_EXPECT_EQ(test, iter.nr_segs, 0);\n\n\t \n\tb = 0;\n\tpatt = 0;\n\tmemset(scratch, 0, bufsize);\n\tfor (pr = bvec_test_ranges; pr->from >= 0; pr++, b++) {\n\t\tu8 *p = scratch + pr->page * PAGE_SIZE;\n\n\t\tfor (i = pr->from; i < pr->to; i++)\n\t\t\tp[i] = pattern(patt++);\n\t}\n\n\t \n\tfor (i = 0; i < bufsize; i++) {\n\t\tKUNIT_EXPECT_EQ_MSG(test, buffer[i], scratch[i], \"at i=%x\", i);\n\t\tif (buffer[i] != scratch[i])\n\t\t\treturn;\n\t}\n\n\tKUNIT_SUCCEED();\n}\n\n \nstatic void __init iov_kunit_copy_from_bvec(struct kunit *test)\n{\n\tconst struct bvec_test_range *pr;\n\tstruct iov_iter iter;\n\tstruct bio_vec bvec[8];\n\tstruct page **spages, **bpages;\n\tu8 *scratch, *buffer;\n\tsize_t bufsize, npages, size, copied;\n\tint i, j;\n\n\tbufsize = 0x100000;\n\tnpages = bufsize / PAGE_SIZE;\n\n\tbuffer = iov_kunit_create_buffer(test, &bpages, npages);\n\tfor (i = 0; i < bufsize; i++)\n\t\tbuffer[i] = pattern(i);\n\n\tscratch = iov_kunit_create_buffer(test, &spages, npages);\n\tmemset(scratch, 0, bufsize);\n\n\tiov_kunit_load_bvec(test, &iter, WRITE, bvec, ARRAY_SIZE(bvec),\n\t\t\t    bpages, npages, bufsize, bvec_test_ranges);\n\tsize = iter.count;\n\n\tcopied = copy_from_iter(scratch, size, &iter);\n\n\tKUNIT_EXPECT_EQ(test, copied, size);\n\tKUNIT_EXPECT_EQ(test, iter.count, 0);\n\tKUNIT_EXPECT_EQ(test, iter.nr_segs, 0);\n\n\t \n\ti = 0;\n\tmemset(buffer, 0, bufsize);\n\tfor (pr = bvec_test_ranges; pr->from >= 0; pr++) {\n\t\tsize_t patt = pr->page * PAGE_SIZE;\n\n\t\tfor (j = pr->from; j < pr->to; j++) {\n\t\t\tbuffer[i++] = pattern(patt + j);\n\t\t\tif (i >= bufsize)\n\t\t\t\tgoto stop;\n\t\t}\n\t}\nstop:\n\n\t \n\tfor (i = 0; i < bufsize; i++) {\n\t\tKUNIT_EXPECT_EQ_MSG(test, scratch[i], buffer[i], \"at i=%x\", i);\n\t\tif (scratch[i] != buffer[i])\n\t\t\treturn;\n\t}\n\n\tKUNIT_SUCCEED();\n}\n\nstatic void iov_kunit_destroy_xarray(void *data)\n{\n\tstruct xarray *xarray = data;\n\n\txa_destroy(xarray);\n\tkfree(xarray);\n}\n\nstatic void __init iov_kunit_load_xarray(struct kunit *test,\n\t\t\t\t\t struct iov_iter *iter, int dir,\n\t\t\t\t\t struct xarray *xarray,\n\t\t\t\t\t struct page **pages, size_t npages)\n{\n\tsize_t size = 0;\n\tint i;\n\n\tfor (i = 0; i < npages; i++) {\n\t\tvoid *x = xa_store(xarray, i, pages[i], GFP_KERNEL);\n\n\t\tKUNIT_ASSERT_FALSE(test, xa_is_err(x));\n\t\tsize += PAGE_SIZE;\n\t}\n\tiov_iter_xarray(iter, dir, xarray, 0, size);\n}\n\nstatic struct xarray *iov_kunit_create_xarray(struct kunit *test)\n{\n\tstruct xarray *xarray;\n\n\txarray = kzalloc(sizeof(struct xarray), GFP_KERNEL);\n\txa_init(xarray);\n\tKUNIT_ASSERT_NOT_ERR_OR_NULL(test, xarray);\n\tkunit_add_action_or_reset(test, iov_kunit_destroy_xarray, xarray);\n\treturn xarray;\n}\n\n \nstatic void __init iov_kunit_copy_to_xarray(struct kunit *test)\n{\n\tconst struct kvec_test_range *pr;\n\tstruct iov_iter iter;\n\tstruct xarray *xarray;\n\tstruct page **spages, **bpages;\n\tu8 *scratch, *buffer;\n\tsize_t bufsize, npages, size, copied;\n\tint i, patt;\n\n\tbufsize = 0x100000;\n\tnpages = bufsize / PAGE_SIZE;\n\n\txarray = iov_kunit_create_xarray(test);\n\n\tscratch = iov_kunit_create_buffer(test, &spages, npages);\n\tfor (i = 0; i < bufsize; i++)\n\t\tscratch[i] = pattern(i);\n\n\tbuffer = iov_kunit_create_buffer(test, &bpages, npages);\n\tmemset(buffer, 0, bufsize);\n\n\tiov_kunit_load_xarray(test, &iter, READ, xarray, bpages, npages);\n\n\ti = 0;\n\tfor (pr = kvec_test_ranges; pr->from >= 0; pr++) {\n\t\tsize = pr->to - pr->from;\n\t\tKUNIT_ASSERT_LE(test, pr->to, bufsize);\n\n\t\tiov_iter_xarray(&iter, READ, xarray, pr->from, size);\n\t\tcopied = copy_to_iter(scratch + i, size, &iter);\n\n\t\tKUNIT_EXPECT_EQ(test, copied, size);\n\t\tKUNIT_EXPECT_EQ(test, iter.count, 0);\n\t\tKUNIT_EXPECT_EQ(test, iter.iov_offset, size);\n\t\ti += size;\n\t}\n\n\t \n\tpatt = 0;\n\tmemset(scratch, 0, bufsize);\n\tfor (pr = kvec_test_ranges; pr->from >= 0; pr++)\n\t\tfor (i = pr->from; i < pr->to; i++)\n\t\t\tscratch[i] = pattern(patt++);\n\n\t \n\tfor (i = 0; i < bufsize; i++) {\n\t\tKUNIT_EXPECT_EQ_MSG(test, buffer[i], scratch[i], \"at i=%x\", i);\n\t\tif (buffer[i] != scratch[i])\n\t\t\treturn;\n\t}\n\n\tKUNIT_SUCCEED();\n}\n\n \nstatic void __init iov_kunit_copy_from_xarray(struct kunit *test)\n{\n\tconst struct kvec_test_range *pr;\n\tstruct iov_iter iter;\n\tstruct xarray *xarray;\n\tstruct page **spages, **bpages;\n\tu8 *scratch, *buffer;\n\tsize_t bufsize, npages, size, copied;\n\tint i, j;\n\n\tbufsize = 0x100000;\n\tnpages = bufsize / PAGE_SIZE;\n\n\txarray = iov_kunit_create_xarray(test);\n\n\tbuffer = iov_kunit_create_buffer(test, &bpages, npages);\n\tfor (i = 0; i < bufsize; i++)\n\t\tbuffer[i] = pattern(i);\n\n\tscratch = iov_kunit_create_buffer(test, &spages, npages);\n\tmemset(scratch, 0, bufsize);\n\n\tiov_kunit_load_xarray(test, &iter, READ, xarray, bpages, npages);\n\n\ti = 0;\n\tfor (pr = kvec_test_ranges; pr->from >= 0; pr++) {\n\t\tsize = pr->to - pr->from;\n\t\tKUNIT_ASSERT_LE(test, pr->to, bufsize);\n\n\t\tiov_iter_xarray(&iter, WRITE, xarray, pr->from, size);\n\t\tcopied = copy_from_iter(scratch + i, size, &iter);\n\n\t\tKUNIT_EXPECT_EQ(test, copied, size);\n\t\tKUNIT_EXPECT_EQ(test, iter.count, 0);\n\t\tKUNIT_EXPECT_EQ(test, iter.iov_offset, size);\n\t\ti += size;\n\t}\n\n\t \n\ti = 0;\n\tmemset(buffer, 0, bufsize);\n\tfor (pr = kvec_test_ranges; pr->from >= 0; pr++) {\n\t\tfor (j = pr->from; j < pr->to; j++) {\n\t\t\tbuffer[i++] = pattern(j);\n\t\t\tif (i >= bufsize)\n\t\t\t\tgoto stop;\n\t\t}\n\t}\nstop:\n\n\t \n\tfor (i = 0; i < bufsize; i++) {\n\t\tKUNIT_EXPECT_EQ_MSG(test, scratch[i], buffer[i], \"at i=%x\", i);\n\t\tif (scratch[i] != buffer[i])\n\t\t\treturn;\n\t}\n\n\tKUNIT_SUCCEED();\n}\n\n \nstatic void __init iov_kunit_extract_pages_kvec(struct kunit *test)\n{\n\tconst struct kvec_test_range *pr;\n\tstruct iov_iter iter;\n\tstruct page **bpages, *pagelist[8], **pages = pagelist;\n\tstruct kvec kvec[8];\n\tu8 *buffer;\n\tssize_t len;\n\tsize_t bufsize, size = 0, npages;\n\tint i, from;\n\n\tbufsize = 0x100000;\n\tnpages = bufsize / PAGE_SIZE;\n\n\tbuffer = iov_kunit_create_buffer(test, &bpages, npages);\n\n\tiov_kunit_load_kvec(test, &iter, READ, kvec, ARRAY_SIZE(kvec),\n\t\t\t    buffer, bufsize, kvec_test_ranges);\n\tsize = iter.count;\n\n\tpr = kvec_test_ranges;\n\tfrom = pr->from;\n\tdo {\n\t\tsize_t offset0 = LONG_MAX;\n\n\t\tfor (i = 0; i < ARRAY_SIZE(pagelist); i++)\n\t\t\tpagelist[i] = (void *)(unsigned long)0xaa55aa55aa55aa55ULL;\n\n\t\tlen = iov_iter_extract_pages(&iter, &pages, 100 * 1024,\n\t\t\t\t\t     ARRAY_SIZE(pagelist), 0, &offset0);\n\t\tKUNIT_EXPECT_GE(test, len, 0);\n\t\tif (len < 0)\n\t\t\tbreak;\n\t\tKUNIT_EXPECT_GE(test, (ssize_t)offset0, 0);\n\t\tKUNIT_EXPECT_LT(test, offset0, PAGE_SIZE);\n\t\tKUNIT_EXPECT_LE(test, len, size);\n\t\tKUNIT_EXPECT_EQ(test, iter.count, size - len);\n\t\tsize -= len;\n\n\t\tif (len == 0)\n\t\t\tbreak;\n\n\t\tfor (i = 0; i < ARRAY_SIZE(pagelist); i++) {\n\t\t\tstruct page *p;\n\t\t\tssize_t part = min_t(ssize_t, len, PAGE_SIZE - offset0);\n\t\t\tint ix;\n\n\t\t\tKUNIT_ASSERT_GE(test, part, 0);\n\t\t\twhile (from == pr->to) {\n\t\t\t\tpr++;\n\t\t\t\tfrom = pr->from;\n\t\t\t\tif (from < 0)\n\t\t\t\t\tgoto stop;\n\t\t\t}\n\t\t\tix = from / PAGE_SIZE;\n\t\t\tKUNIT_ASSERT_LT(test, ix, npages);\n\t\t\tp = bpages[ix];\n\t\t\tKUNIT_EXPECT_PTR_EQ(test, pagelist[i], p);\n\t\t\tKUNIT_EXPECT_EQ(test, offset0, from % PAGE_SIZE);\n\t\t\tfrom += part;\n\t\t\tlen -= part;\n\t\t\tKUNIT_ASSERT_GE(test, len, 0);\n\t\t\tif (len == 0)\n\t\t\t\tbreak;\n\t\t\toffset0 = 0;\n\t\t}\n\n\t\tif (test->status == KUNIT_FAILURE)\n\t\t\tbreak;\n\t} while (iov_iter_count(&iter) > 0);\n\nstop:\n\tKUNIT_EXPECT_EQ(test, size, 0);\n\tKUNIT_EXPECT_EQ(test, iter.count, 0);\n\tKUNIT_SUCCEED();\n}\n\n \nstatic void __init iov_kunit_extract_pages_bvec(struct kunit *test)\n{\n\tconst struct bvec_test_range *pr;\n\tstruct iov_iter iter;\n\tstruct page **bpages, *pagelist[8], **pages = pagelist;\n\tstruct bio_vec bvec[8];\n\tssize_t len;\n\tsize_t bufsize, size = 0, npages;\n\tint i, from;\n\n\tbufsize = 0x100000;\n\tnpages = bufsize / PAGE_SIZE;\n\n\tiov_kunit_create_buffer(test, &bpages, npages);\n\tiov_kunit_load_bvec(test, &iter, READ, bvec, ARRAY_SIZE(bvec),\n\t\t\t    bpages, npages, bufsize, bvec_test_ranges);\n\tsize = iter.count;\n\n\tpr = bvec_test_ranges;\n\tfrom = pr->from;\n\tdo {\n\t\tsize_t offset0 = LONG_MAX;\n\n\t\tfor (i = 0; i < ARRAY_SIZE(pagelist); i++)\n\t\t\tpagelist[i] = (void *)(unsigned long)0xaa55aa55aa55aa55ULL;\n\n\t\tlen = iov_iter_extract_pages(&iter, &pages, 100 * 1024,\n\t\t\t\t\t     ARRAY_SIZE(pagelist), 0, &offset0);\n\t\tKUNIT_EXPECT_GE(test, len, 0);\n\t\tif (len < 0)\n\t\t\tbreak;\n\t\tKUNIT_EXPECT_GE(test, (ssize_t)offset0, 0);\n\t\tKUNIT_EXPECT_LT(test, offset0, PAGE_SIZE);\n\t\tKUNIT_EXPECT_LE(test, len, size);\n\t\tKUNIT_EXPECT_EQ(test, iter.count, size - len);\n\t\tsize -= len;\n\n\t\tif (len == 0)\n\t\t\tbreak;\n\n\t\tfor (i = 0; i < ARRAY_SIZE(pagelist); i++) {\n\t\t\tstruct page *p;\n\t\t\tssize_t part = min_t(ssize_t, len, PAGE_SIZE - offset0);\n\t\t\tint ix;\n\n\t\t\tKUNIT_ASSERT_GE(test, part, 0);\n\t\t\twhile (from == pr->to) {\n\t\t\t\tpr++;\n\t\t\t\tfrom = pr->from;\n\t\t\t\tif (from < 0)\n\t\t\t\t\tgoto stop;\n\t\t\t}\n\t\t\tix = pr->page + from / PAGE_SIZE;\n\t\t\tKUNIT_ASSERT_LT(test, ix, npages);\n\t\t\tp = bpages[ix];\n\t\t\tKUNIT_EXPECT_PTR_EQ(test, pagelist[i], p);\n\t\t\tKUNIT_EXPECT_EQ(test, offset0, from % PAGE_SIZE);\n\t\t\tfrom += part;\n\t\t\tlen -= part;\n\t\t\tKUNIT_ASSERT_GE(test, len, 0);\n\t\t\tif (len == 0)\n\t\t\t\tbreak;\n\t\t\toffset0 = 0;\n\t\t}\n\n\t\tif (test->status == KUNIT_FAILURE)\n\t\t\tbreak;\n\t} while (iov_iter_count(&iter) > 0);\n\nstop:\n\tKUNIT_EXPECT_EQ(test, size, 0);\n\tKUNIT_EXPECT_EQ(test, iter.count, 0);\n\tKUNIT_SUCCEED();\n}\n\n \nstatic void __init iov_kunit_extract_pages_xarray(struct kunit *test)\n{\n\tconst struct kvec_test_range *pr;\n\tstruct iov_iter iter;\n\tstruct xarray *xarray;\n\tstruct page **bpages, *pagelist[8], **pages = pagelist;\n\tssize_t len;\n\tsize_t bufsize, size = 0, npages;\n\tint i, from;\n\n\tbufsize = 0x100000;\n\tnpages = bufsize / PAGE_SIZE;\n\n\txarray = iov_kunit_create_xarray(test);\n\n\tiov_kunit_create_buffer(test, &bpages, npages);\n\tiov_kunit_load_xarray(test, &iter, READ, xarray, bpages, npages);\n\n\tfor (pr = kvec_test_ranges; pr->from >= 0; pr++) {\n\t\tfrom = pr->from;\n\t\tsize = pr->to - from;\n\t\tKUNIT_ASSERT_LE(test, pr->to, bufsize);\n\n\t\tiov_iter_xarray(&iter, WRITE, xarray, from, size);\n\n\t\tdo {\n\t\t\tsize_t offset0 = LONG_MAX;\n\n\t\t\tfor (i = 0; i < ARRAY_SIZE(pagelist); i++)\n\t\t\t\tpagelist[i] = (void *)(unsigned long)0xaa55aa55aa55aa55ULL;\n\n\t\t\tlen = iov_iter_extract_pages(&iter, &pages, 100 * 1024,\n\t\t\t\t\t\t     ARRAY_SIZE(pagelist), 0, &offset0);\n\t\t\tKUNIT_EXPECT_GE(test, len, 0);\n\t\t\tif (len < 0)\n\t\t\t\tbreak;\n\t\t\tKUNIT_EXPECT_LE(test, len, size);\n\t\t\tKUNIT_EXPECT_EQ(test, iter.count, size - len);\n\t\t\tif (len == 0)\n\t\t\t\tbreak;\n\t\t\tsize -= len;\n\t\t\tKUNIT_EXPECT_GE(test, (ssize_t)offset0, 0);\n\t\t\tKUNIT_EXPECT_LT(test, offset0, PAGE_SIZE);\n\n\t\t\tfor (i = 0; i < ARRAY_SIZE(pagelist); i++) {\n\t\t\t\tstruct page *p;\n\t\t\t\tssize_t part = min_t(ssize_t, len, PAGE_SIZE - offset0);\n\t\t\t\tint ix;\n\n\t\t\t\tKUNIT_ASSERT_GE(test, part, 0);\n\t\t\t\tix = from / PAGE_SIZE;\n\t\t\t\tKUNIT_ASSERT_LT(test, ix, npages);\n\t\t\t\tp = bpages[ix];\n\t\t\t\tKUNIT_EXPECT_PTR_EQ(test, pagelist[i], p);\n\t\t\t\tKUNIT_EXPECT_EQ(test, offset0, from % PAGE_SIZE);\n\t\t\t\tfrom += part;\n\t\t\t\tlen -= part;\n\t\t\t\tKUNIT_ASSERT_GE(test, len, 0);\n\t\t\t\tif (len == 0)\n\t\t\t\t\tbreak;\n\t\t\t\toffset0 = 0;\n\t\t\t}\n\n\t\t\tif (test->status == KUNIT_FAILURE)\n\t\t\t\tgoto stop;\n\t\t} while (iov_iter_count(&iter) > 0);\n\n\t\tKUNIT_EXPECT_EQ(test, size, 0);\n\t\tKUNIT_EXPECT_EQ(test, iter.count, 0);\n\t\tKUNIT_EXPECT_EQ(test, iter.iov_offset, pr->to - pr->from);\n\t}\n\nstop:\n\tKUNIT_SUCCEED();\n}\n\nstatic struct kunit_case __refdata iov_kunit_cases[] = {\n\tKUNIT_CASE(iov_kunit_copy_to_kvec),\n\tKUNIT_CASE(iov_kunit_copy_from_kvec),\n\tKUNIT_CASE(iov_kunit_copy_to_bvec),\n\tKUNIT_CASE(iov_kunit_copy_from_bvec),\n\tKUNIT_CASE(iov_kunit_copy_to_xarray),\n\tKUNIT_CASE(iov_kunit_copy_from_xarray),\n\tKUNIT_CASE(iov_kunit_extract_pages_kvec),\n\tKUNIT_CASE(iov_kunit_extract_pages_bvec),\n\tKUNIT_CASE(iov_kunit_extract_pages_xarray),\n\t{}\n};\n\nstatic struct kunit_suite iov_kunit_suite = {\n\t.name = \"iov_iter\",\n\t.test_cases = iov_kunit_cases,\n};\n\nkunit_test_suites(&iov_kunit_suite);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}