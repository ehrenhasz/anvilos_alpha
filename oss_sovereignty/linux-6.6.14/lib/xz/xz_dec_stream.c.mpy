{
  "module_name": "xz_dec_stream.c",
  "hash_id": "867eccaaf9818a547d2eaba29aa7f360375b96b8f142efcd756a24c82836364b",
  "original_prompt": "Ingested from linux-6.6.14/lib/xz/xz_dec_stream.c",
  "human_readable_source": " \n\n#include \"xz_private.h\"\n#include \"xz_stream.h\"\n\n \nstruct xz_dec_hash {\n\tvli_type unpadded;\n\tvli_type uncompressed;\n\tuint32_t crc32;\n};\n\nstruct xz_dec {\n\t \n\tenum {\n\t\tSEQ_STREAM_HEADER,\n\t\tSEQ_BLOCK_START,\n\t\tSEQ_BLOCK_HEADER,\n\t\tSEQ_BLOCK_UNCOMPRESS,\n\t\tSEQ_BLOCK_PADDING,\n\t\tSEQ_BLOCK_CHECK,\n\t\tSEQ_INDEX,\n\t\tSEQ_INDEX_PADDING,\n\t\tSEQ_INDEX_CRC32,\n\t\tSEQ_STREAM_FOOTER\n\t} sequence;\n\n\t \n\tuint32_t pos;\n\n\t \n\tvli_type vli;\n\n\t \n\tsize_t in_start;\n\tsize_t out_start;\n\n\t \n\tuint32_t crc32;\n\n\t \n\tenum xz_check check_type;\n\n\t \n\tenum xz_mode mode;\n\n\t \n\tbool allow_buf_error;\n\n\t \n\tstruct {\n\t\t \n\t\tvli_type compressed;\n\n\t\t \n\t\tvli_type uncompressed;\n\n\t\t \n\t\tuint32_t size;\n\t} block_header;\n\n\t \n\tstruct {\n\t\t \n\t\tvli_type compressed;\n\n\t\t \n\t\tvli_type uncompressed;\n\n\t\t \n\t\tvli_type count;\n\n\t\t \n\t\tstruct xz_dec_hash hash;\n\t} block;\n\n\t \n\tstruct {\n\t\t \n\t\tenum {\n\t\t\tSEQ_INDEX_COUNT,\n\t\t\tSEQ_INDEX_UNPADDED,\n\t\t\tSEQ_INDEX_UNCOMPRESSED\n\t\t} sequence;\n\n\t\t \n\t\tvli_type size;\n\n\t\t \n\t\tvli_type count;\n\n\t\t \n\t\tstruct xz_dec_hash hash;\n\t} index;\n\n\t \n\tstruct {\n\t\tsize_t pos;\n\t\tsize_t size;\n\t\tuint8_t buf[1024];\n\t} temp;\n\n\tstruct xz_dec_lzma2 *lzma2;\n\n#ifdef XZ_DEC_BCJ\n\tstruct xz_dec_bcj *bcj;\n\tbool bcj_active;\n#endif\n};\n\n#ifdef XZ_DEC_ANY_CHECK\n \nstatic const uint8_t check_sizes[16] = {\n\t0,\n\t4, 4, 4,\n\t8, 8, 8,\n\t16, 16, 16,\n\t32, 32, 32,\n\t64, 64, 64\n};\n#endif\n\n \nstatic bool fill_temp(struct xz_dec *s, struct xz_buf *b)\n{\n\tsize_t copy_size = min_t(size_t,\n\t\t\tb->in_size - b->in_pos, s->temp.size - s->temp.pos);\n\n\tmemcpy(s->temp.buf + s->temp.pos, b->in + b->in_pos, copy_size);\n\tb->in_pos += copy_size;\n\ts->temp.pos += copy_size;\n\n\tif (s->temp.pos == s->temp.size) {\n\t\ts->temp.pos = 0;\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n \nstatic enum xz_ret dec_vli(struct xz_dec *s, const uint8_t *in,\n\t\t\t   size_t *in_pos, size_t in_size)\n{\n\tuint8_t byte;\n\n\tif (s->pos == 0)\n\t\ts->vli = 0;\n\n\twhile (*in_pos < in_size) {\n\t\tbyte = in[*in_pos];\n\t\t++*in_pos;\n\n\t\ts->vli |= (vli_type)(byte & 0x7F) << s->pos;\n\n\t\tif ((byte & 0x80) == 0) {\n\t\t\t \n\t\t\tif (byte == 0 && s->pos != 0)\n\t\t\t\treturn XZ_DATA_ERROR;\n\n\t\t\ts->pos = 0;\n\t\t\treturn XZ_STREAM_END;\n\t\t}\n\n\t\ts->pos += 7;\n\t\tif (s->pos == 7 * VLI_BYTES_MAX)\n\t\t\treturn XZ_DATA_ERROR;\n\t}\n\n\treturn XZ_OK;\n}\n\n \nstatic enum xz_ret dec_block(struct xz_dec *s, struct xz_buf *b)\n{\n\tenum xz_ret ret;\n\n\ts->in_start = b->in_pos;\n\ts->out_start = b->out_pos;\n\n#ifdef XZ_DEC_BCJ\n\tif (s->bcj_active)\n\t\tret = xz_dec_bcj_run(s->bcj, s->lzma2, b);\n\telse\n#endif\n\t\tret = xz_dec_lzma2_run(s->lzma2, b);\n\n\ts->block.compressed += b->in_pos - s->in_start;\n\ts->block.uncompressed += b->out_pos - s->out_start;\n\n\t \n\tif (s->block.compressed > s->block_header.compressed\n\t\t\t|| s->block.uncompressed\n\t\t\t\t> s->block_header.uncompressed)\n\t\treturn XZ_DATA_ERROR;\n\n\tif (s->check_type == XZ_CHECK_CRC32)\n\t\ts->crc32 = xz_crc32(b->out + s->out_start,\n\t\t\t\tb->out_pos - s->out_start, s->crc32);\n\n\tif (ret == XZ_STREAM_END) {\n\t\tif (s->block_header.compressed != VLI_UNKNOWN\n\t\t\t\t&& s->block_header.compressed\n\t\t\t\t\t!= s->block.compressed)\n\t\t\treturn XZ_DATA_ERROR;\n\n\t\tif (s->block_header.uncompressed != VLI_UNKNOWN\n\t\t\t\t&& s->block_header.uncompressed\n\t\t\t\t\t!= s->block.uncompressed)\n\t\t\treturn XZ_DATA_ERROR;\n\n\t\ts->block.hash.unpadded += s->block_header.size\n\t\t\t\t+ s->block.compressed;\n\n#ifdef XZ_DEC_ANY_CHECK\n\t\ts->block.hash.unpadded += check_sizes[s->check_type];\n#else\n\t\tif (s->check_type == XZ_CHECK_CRC32)\n\t\t\ts->block.hash.unpadded += 4;\n#endif\n\n\t\ts->block.hash.uncompressed += s->block.uncompressed;\n\t\ts->block.hash.crc32 = xz_crc32(\n\t\t\t\t(const uint8_t *)&s->block.hash,\n\t\t\t\tsizeof(s->block.hash), s->block.hash.crc32);\n\n\t\t++s->block.count;\n\t}\n\n\treturn ret;\n}\n\n \nstatic void index_update(struct xz_dec *s, const struct xz_buf *b)\n{\n\tsize_t in_used = b->in_pos - s->in_start;\n\ts->index.size += in_used;\n\ts->crc32 = xz_crc32(b->in + s->in_start, in_used, s->crc32);\n}\n\n \nstatic enum xz_ret dec_index(struct xz_dec *s, struct xz_buf *b)\n{\n\tenum xz_ret ret;\n\n\tdo {\n\t\tret = dec_vli(s, b->in, &b->in_pos, b->in_size);\n\t\tif (ret != XZ_STREAM_END) {\n\t\t\tindex_update(s, b);\n\t\t\treturn ret;\n\t\t}\n\n\t\tswitch (s->index.sequence) {\n\t\tcase SEQ_INDEX_COUNT:\n\t\t\ts->index.count = s->vli;\n\n\t\t\t \n\t\t\tif (s->index.count != s->block.count)\n\t\t\t\treturn XZ_DATA_ERROR;\n\n\t\t\ts->index.sequence = SEQ_INDEX_UNPADDED;\n\t\t\tbreak;\n\n\t\tcase SEQ_INDEX_UNPADDED:\n\t\t\ts->index.hash.unpadded += s->vli;\n\t\t\ts->index.sequence = SEQ_INDEX_UNCOMPRESSED;\n\t\t\tbreak;\n\n\t\tcase SEQ_INDEX_UNCOMPRESSED:\n\t\t\ts->index.hash.uncompressed += s->vli;\n\t\t\ts->index.hash.crc32 = xz_crc32(\n\t\t\t\t\t(const uint8_t *)&s->index.hash,\n\t\t\t\t\tsizeof(s->index.hash),\n\t\t\t\t\ts->index.hash.crc32);\n\t\t\t--s->index.count;\n\t\t\ts->index.sequence = SEQ_INDEX_UNPADDED;\n\t\t\tbreak;\n\t\t}\n\t} while (s->index.count > 0);\n\n\treturn XZ_STREAM_END;\n}\n\n \nstatic enum xz_ret crc32_validate(struct xz_dec *s, struct xz_buf *b)\n{\n\tdo {\n\t\tif (b->in_pos == b->in_size)\n\t\t\treturn XZ_OK;\n\n\t\tif (((s->crc32 >> s->pos) & 0xFF) != b->in[b->in_pos++])\n\t\t\treturn XZ_DATA_ERROR;\n\n\t\ts->pos += 8;\n\n\t} while (s->pos < 32);\n\n\ts->crc32 = 0;\n\ts->pos = 0;\n\n\treturn XZ_STREAM_END;\n}\n\n#ifdef XZ_DEC_ANY_CHECK\n \nstatic bool check_skip(struct xz_dec *s, struct xz_buf *b)\n{\n\twhile (s->pos < check_sizes[s->check_type]) {\n\t\tif (b->in_pos == b->in_size)\n\t\t\treturn false;\n\n\t\t++b->in_pos;\n\t\t++s->pos;\n\t}\n\n\ts->pos = 0;\n\n\treturn true;\n}\n#endif\n\n \nstatic enum xz_ret dec_stream_header(struct xz_dec *s)\n{\n\tif (!memeq(s->temp.buf, HEADER_MAGIC, HEADER_MAGIC_SIZE))\n\t\treturn XZ_FORMAT_ERROR;\n\n\tif (xz_crc32(s->temp.buf + HEADER_MAGIC_SIZE, 2, 0)\n\t\t\t!= get_le32(s->temp.buf + HEADER_MAGIC_SIZE + 2))\n\t\treturn XZ_DATA_ERROR;\n\n\tif (s->temp.buf[HEADER_MAGIC_SIZE] != 0)\n\t\treturn XZ_OPTIONS_ERROR;\n\n\t \n\tif (s->temp.buf[HEADER_MAGIC_SIZE + 1] > XZ_CHECK_MAX)\n\t\treturn XZ_OPTIONS_ERROR;\n\n\ts->check_type = s->temp.buf[HEADER_MAGIC_SIZE + 1];\n\n#ifdef XZ_DEC_ANY_CHECK\n\tif (s->check_type > XZ_CHECK_CRC32)\n\t\treturn XZ_UNSUPPORTED_CHECK;\n#else\n\tif (s->check_type > XZ_CHECK_CRC32)\n\t\treturn XZ_OPTIONS_ERROR;\n#endif\n\n\treturn XZ_OK;\n}\n\n \nstatic enum xz_ret dec_stream_footer(struct xz_dec *s)\n{\n\tif (!memeq(s->temp.buf + 10, FOOTER_MAGIC, FOOTER_MAGIC_SIZE))\n\t\treturn XZ_DATA_ERROR;\n\n\tif (xz_crc32(s->temp.buf + 4, 6, 0) != get_le32(s->temp.buf))\n\t\treturn XZ_DATA_ERROR;\n\n\t \n\tif ((s->index.size >> 2) != get_le32(s->temp.buf + 4))\n\t\treturn XZ_DATA_ERROR;\n\n\tif (s->temp.buf[8] != 0 || s->temp.buf[9] != s->check_type)\n\t\treturn XZ_DATA_ERROR;\n\n\t \n\treturn XZ_STREAM_END;\n}\n\n \nstatic enum xz_ret dec_block_header(struct xz_dec *s)\n{\n\tenum xz_ret ret;\n\n\t \n\ts->temp.size -= 4;\n\tif (xz_crc32(s->temp.buf, s->temp.size, 0)\n\t\t\t!= get_le32(s->temp.buf + s->temp.size))\n\t\treturn XZ_DATA_ERROR;\n\n\ts->temp.pos = 2;\n\n\t \n#ifdef XZ_DEC_BCJ\n\tif (s->temp.buf[1] & 0x3E)\n#else\n\tif (s->temp.buf[1] & 0x3F)\n#endif\n\t\treturn XZ_OPTIONS_ERROR;\n\n\t \n\tif (s->temp.buf[1] & 0x40) {\n\t\tif (dec_vli(s, s->temp.buf, &s->temp.pos, s->temp.size)\n\t\t\t\t\t!= XZ_STREAM_END)\n\t\t\treturn XZ_DATA_ERROR;\n\n\t\ts->block_header.compressed = s->vli;\n\t} else {\n\t\ts->block_header.compressed = VLI_UNKNOWN;\n\t}\n\n\t \n\tif (s->temp.buf[1] & 0x80) {\n\t\tif (dec_vli(s, s->temp.buf, &s->temp.pos, s->temp.size)\n\t\t\t\t!= XZ_STREAM_END)\n\t\t\treturn XZ_DATA_ERROR;\n\n\t\ts->block_header.uncompressed = s->vli;\n\t} else {\n\t\ts->block_header.uncompressed = VLI_UNKNOWN;\n\t}\n\n#ifdef XZ_DEC_BCJ\n\t \n\ts->bcj_active = s->temp.buf[1] & 0x01;\n\tif (s->bcj_active) {\n\t\tif (s->temp.size - s->temp.pos < 2)\n\t\t\treturn XZ_OPTIONS_ERROR;\n\n\t\tret = xz_dec_bcj_reset(s->bcj, s->temp.buf[s->temp.pos++]);\n\t\tif (ret != XZ_OK)\n\t\t\treturn ret;\n\n\t\t \n\t\tif (s->temp.buf[s->temp.pos++] != 0x00)\n\t\t\treturn XZ_OPTIONS_ERROR;\n\t}\n#endif\n\n\t \n\tif (s->temp.size - s->temp.pos < 2)\n\t\treturn XZ_DATA_ERROR;\n\n\t \n\tif (s->temp.buf[s->temp.pos++] != 0x21)\n\t\treturn XZ_OPTIONS_ERROR;\n\n\t \n\tif (s->temp.buf[s->temp.pos++] != 0x01)\n\t\treturn XZ_OPTIONS_ERROR;\n\n\t \n\tif (s->temp.size - s->temp.pos < 1)\n\t\treturn XZ_DATA_ERROR;\n\n\tret = xz_dec_lzma2_reset(s->lzma2, s->temp.buf[s->temp.pos++]);\n\tif (ret != XZ_OK)\n\t\treturn ret;\n\n\t \n\twhile (s->temp.pos < s->temp.size)\n\t\tif (s->temp.buf[s->temp.pos++] != 0x00)\n\t\t\treturn XZ_OPTIONS_ERROR;\n\n\ts->temp.pos = 0;\n\ts->block.compressed = 0;\n\ts->block.uncompressed = 0;\n\n\treturn XZ_OK;\n}\n\nstatic enum xz_ret dec_main(struct xz_dec *s, struct xz_buf *b)\n{\n\tenum xz_ret ret;\n\n\t \n\ts->in_start = b->in_pos;\n\n\twhile (true) {\n\t\tswitch (s->sequence) {\n\t\tcase SEQ_STREAM_HEADER:\n\t\t\t \n\t\t\tif (!fill_temp(s, b))\n\t\t\t\treturn XZ_OK;\n\n\t\t\t \n\t\t\ts->sequence = SEQ_BLOCK_START;\n\n\t\t\tret = dec_stream_header(s);\n\t\t\tif (ret != XZ_OK)\n\t\t\t\treturn ret;\n\n\t\t\tfallthrough;\n\n\t\tcase SEQ_BLOCK_START:\n\t\t\t \n\t\t\tif (b->in_pos == b->in_size)\n\t\t\t\treturn XZ_OK;\n\n\t\t\t \n\t\t\tif (b->in[b->in_pos] == 0) {\n\t\t\t\ts->in_start = b->in_pos++;\n\t\t\t\ts->sequence = SEQ_INDEX;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t \n\t\t\ts->block_header.size\n\t\t\t\t= ((uint32_t)b->in[b->in_pos] + 1) * 4;\n\n\t\t\ts->temp.size = s->block_header.size;\n\t\t\ts->temp.pos = 0;\n\t\t\ts->sequence = SEQ_BLOCK_HEADER;\n\n\t\t\tfallthrough;\n\n\t\tcase SEQ_BLOCK_HEADER:\n\t\t\tif (!fill_temp(s, b))\n\t\t\t\treturn XZ_OK;\n\n\t\t\tret = dec_block_header(s);\n\t\t\tif (ret != XZ_OK)\n\t\t\t\treturn ret;\n\n\t\t\ts->sequence = SEQ_BLOCK_UNCOMPRESS;\n\n\t\t\tfallthrough;\n\n\t\tcase SEQ_BLOCK_UNCOMPRESS:\n\t\t\tret = dec_block(s, b);\n\t\t\tif (ret != XZ_STREAM_END)\n\t\t\t\treturn ret;\n\n\t\t\ts->sequence = SEQ_BLOCK_PADDING;\n\n\t\t\tfallthrough;\n\n\t\tcase SEQ_BLOCK_PADDING:\n\t\t\t \n\t\t\twhile (s->block.compressed & 3) {\n\t\t\t\tif (b->in_pos == b->in_size)\n\t\t\t\t\treturn XZ_OK;\n\n\t\t\t\tif (b->in[b->in_pos++] != 0)\n\t\t\t\t\treturn XZ_DATA_ERROR;\n\n\t\t\t\t++s->block.compressed;\n\t\t\t}\n\n\t\t\ts->sequence = SEQ_BLOCK_CHECK;\n\n\t\t\tfallthrough;\n\n\t\tcase SEQ_BLOCK_CHECK:\n\t\t\tif (s->check_type == XZ_CHECK_CRC32) {\n\t\t\t\tret = crc32_validate(s, b);\n\t\t\t\tif (ret != XZ_STREAM_END)\n\t\t\t\t\treturn ret;\n\t\t\t}\n#ifdef XZ_DEC_ANY_CHECK\n\t\t\telse if (!check_skip(s, b)) {\n\t\t\t\treturn XZ_OK;\n\t\t\t}\n#endif\n\n\t\t\ts->sequence = SEQ_BLOCK_START;\n\t\t\tbreak;\n\n\t\tcase SEQ_INDEX:\n\t\t\tret = dec_index(s, b);\n\t\t\tif (ret != XZ_STREAM_END)\n\t\t\t\treturn ret;\n\n\t\t\ts->sequence = SEQ_INDEX_PADDING;\n\n\t\t\tfallthrough;\n\n\t\tcase SEQ_INDEX_PADDING:\n\t\t\twhile ((s->index.size + (b->in_pos - s->in_start))\n\t\t\t\t\t& 3) {\n\t\t\t\tif (b->in_pos == b->in_size) {\n\t\t\t\t\tindex_update(s, b);\n\t\t\t\t\treturn XZ_OK;\n\t\t\t\t}\n\n\t\t\t\tif (b->in[b->in_pos++] != 0)\n\t\t\t\t\treturn XZ_DATA_ERROR;\n\t\t\t}\n\n\t\t\t \n\t\t\tindex_update(s, b);\n\n\t\t\t \n\t\t\tif (!memeq(&s->block.hash, &s->index.hash,\n\t\t\t\t\tsizeof(s->block.hash)))\n\t\t\t\treturn XZ_DATA_ERROR;\n\n\t\t\ts->sequence = SEQ_INDEX_CRC32;\n\n\t\t\tfallthrough;\n\n\t\tcase SEQ_INDEX_CRC32:\n\t\t\tret = crc32_validate(s, b);\n\t\t\tif (ret != XZ_STREAM_END)\n\t\t\t\treturn ret;\n\n\t\t\ts->temp.size = STREAM_HEADER_SIZE;\n\t\t\ts->sequence = SEQ_STREAM_FOOTER;\n\n\t\t\tfallthrough;\n\n\t\tcase SEQ_STREAM_FOOTER:\n\t\t\tif (!fill_temp(s, b))\n\t\t\t\treturn XZ_OK;\n\n\t\t\treturn dec_stream_footer(s);\n\t\t}\n\t}\n\n\t \n}\n\n \nXZ_EXTERN enum xz_ret xz_dec_run(struct xz_dec *s, struct xz_buf *b)\n{\n\tsize_t in_start;\n\tsize_t out_start;\n\tenum xz_ret ret;\n\n\tif (DEC_IS_SINGLE(s->mode))\n\t\txz_dec_reset(s);\n\n\tin_start = b->in_pos;\n\tout_start = b->out_pos;\n\tret = dec_main(s, b);\n\n\tif (DEC_IS_SINGLE(s->mode)) {\n\t\tif (ret == XZ_OK)\n\t\t\tret = b->in_pos == b->in_size\n\t\t\t\t\t? XZ_DATA_ERROR : XZ_BUF_ERROR;\n\n\t\tif (ret != XZ_STREAM_END) {\n\t\t\tb->in_pos = in_start;\n\t\t\tb->out_pos = out_start;\n\t\t}\n\n\t} else if (ret == XZ_OK && in_start == b->in_pos\n\t\t\t&& out_start == b->out_pos) {\n\t\tif (s->allow_buf_error)\n\t\t\tret = XZ_BUF_ERROR;\n\n\t\ts->allow_buf_error = true;\n\t} else {\n\t\ts->allow_buf_error = false;\n\t}\n\n\treturn ret;\n}\n\nXZ_EXTERN struct xz_dec *xz_dec_init(enum xz_mode mode, uint32_t dict_max)\n{\n\tstruct xz_dec *s = kmalloc(sizeof(*s), GFP_KERNEL);\n\tif (s == NULL)\n\t\treturn NULL;\n\n\ts->mode = mode;\n\n#ifdef XZ_DEC_BCJ\n\ts->bcj = xz_dec_bcj_create(DEC_IS_SINGLE(mode));\n\tif (s->bcj == NULL)\n\t\tgoto error_bcj;\n#endif\n\n\ts->lzma2 = xz_dec_lzma2_create(mode, dict_max);\n\tif (s->lzma2 == NULL)\n\t\tgoto error_lzma2;\n\n\txz_dec_reset(s);\n\treturn s;\n\nerror_lzma2:\n#ifdef XZ_DEC_BCJ\n\txz_dec_bcj_end(s->bcj);\nerror_bcj:\n#endif\n\tkfree(s);\n\treturn NULL;\n}\n\nXZ_EXTERN void xz_dec_reset(struct xz_dec *s)\n{\n\ts->sequence = SEQ_STREAM_HEADER;\n\ts->allow_buf_error = false;\n\ts->pos = 0;\n\ts->crc32 = 0;\n\tmemzero(&s->block, sizeof(s->block));\n\tmemzero(&s->index, sizeof(s->index));\n\ts->temp.pos = 0;\n\ts->temp.size = STREAM_HEADER_SIZE;\n}\n\nXZ_EXTERN void xz_dec_end(struct xz_dec *s)\n{\n\tif (s != NULL) {\n\t\txz_dec_lzma2_end(s->lzma2);\n#ifdef XZ_DEC_BCJ\n\t\txz_dec_bcj_end(s->bcj);\n#endif\n\t\tkfree(s);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}