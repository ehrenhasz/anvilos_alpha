{
  "module_name": "xz_dec_lzma2.c",
  "hash_id": "b7a599aa22dacd706fa8d00940c315ed63f4b2fad164dd3549d7d1667a838206",
  "original_prompt": "Ingested from linux-6.6.14/lib/xz/xz_dec_lzma2.c",
  "human_readable_source": " \n\n#include \"xz_private.h\"\n#include \"xz_lzma2.h\"\n\n \n#define RC_INIT_BYTES 5\n\n \n#define LZMA_IN_REQUIRED 21\n\n \nstruct dictionary {\n\t \n\tuint8_t *buf;\n\n\t \n\tsize_t start;\n\n\t \n\tsize_t pos;\n\n\t \n\tsize_t full;\n\n\t \n\tsize_t limit;\n\n\t \n\tsize_t end;\n\n\t \n\tuint32_t size;\n\n\t \n\tuint32_t size_max;\n\n\t \n\tuint32_t allocated;\n\n\t \n\tenum xz_mode mode;\n};\n\n \nstruct rc_dec {\n\tuint32_t range;\n\tuint32_t code;\n\n\t \n\tuint32_t init_bytes_left;\n\n\t \n\tconst uint8_t *in;\n\tsize_t in_pos;\n\tsize_t in_limit;\n};\n\n \nstruct lzma_len_dec {\n\t \n\tuint16_t choice;\n\n\t \n\tuint16_t choice2;\n\n\t \n\tuint16_t low[POS_STATES_MAX][LEN_LOW_SYMBOLS];\n\n\t \n\tuint16_t mid[POS_STATES_MAX][LEN_MID_SYMBOLS];\n\n\t \n\tuint16_t high[LEN_HIGH_SYMBOLS];\n};\n\nstruct lzma_dec {\n\t \n\tuint32_t rep0;\n\tuint32_t rep1;\n\tuint32_t rep2;\n\tuint32_t rep3;\n\n\t \n\tenum lzma_state state;\n\n\t \n\tuint32_t len;\n\n\t \n\tuint32_t lc;\n\tuint32_t literal_pos_mask;  \n\tuint32_t pos_mask;          \n\n\t \n\tuint16_t is_match[STATES][POS_STATES_MAX];\n\n\t \n\tuint16_t is_rep[STATES];\n\n\t \n\tuint16_t is_rep0[STATES];\n\n\t \n\tuint16_t is_rep1[STATES];\n\n\t \n\tuint16_t is_rep2[STATES];\n\n\t \n\tuint16_t is_rep0_long[STATES][POS_STATES_MAX];\n\n\t \n\tuint16_t dist_slot[DIST_STATES][DIST_SLOTS];\n\n\t \n\tuint16_t dist_special[FULL_DISTANCES - DIST_MODEL_END];\n\n\t \n\tuint16_t dist_align[ALIGN_SIZE];\n\n\t \n\tstruct lzma_len_dec match_len_dec;\n\n\t \n\tstruct lzma_len_dec rep_len_dec;\n\n\t \n\tuint16_t literal[LITERAL_CODERS_MAX][LITERAL_CODER_SIZE];\n};\n\nstruct lzma2_dec {\n\t \n\tenum lzma2_seq {\n\t\tSEQ_CONTROL,\n\t\tSEQ_UNCOMPRESSED_1,\n\t\tSEQ_UNCOMPRESSED_2,\n\t\tSEQ_COMPRESSED_0,\n\t\tSEQ_COMPRESSED_1,\n\t\tSEQ_PROPERTIES,\n\t\tSEQ_LZMA_PREPARE,\n\t\tSEQ_LZMA_RUN,\n\t\tSEQ_COPY\n\t} sequence;\n\n\t \n\tenum lzma2_seq next_sequence;\n\n\t \n\tuint32_t uncompressed;\n\n\t \n\tuint32_t compressed;\n\n\t \n\tbool need_dict_reset;\n\n\t \n\tbool need_props;\n\n#ifdef XZ_DEC_MICROLZMA\n\tbool pedantic_microlzma;\n#endif\n};\n\nstruct xz_dec_lzma2 {\n\t \n\tstruct rc_dec rc;\n\tstruct dictionary dict;\n\tstruct lzma2_dec lzma2;\n\tstruct lzma_dec lzma;\n\n\t \n\tstruct {\n\t\tuint32_t size;\n\t\tuint8_t buf[3 * LZMA_IN_REQUIRED];\n\t} temp;\n};\n\n \n\n \nstatic void dict_reset(struct dictionary *dict, struct xz_buf *b)\n{\n\tif (DEC_IS_SINGLE(dict->mode)) {\n\t\tdict->buf = b->out + b->out_pos;\n\t\tdict->end = b->out_size - b->out_pos;\n\t}\n\n\tdict->start = 0;\n\tdict->pos = 0;\n\tdict->limit = 0;\n\tdict->full = 0;\n}\n\n \nstatic void dict_limit(struct dictionary *dict, size_t out_max)\n{\n\tif (dict->end - dict->pos <= out_max)\n\t\tdict->limit = dict->end;\n\telse\n\t\tdict->limit = dict->pos + out_max;\n}\n\n \nstatic inline bool dict_has_space(const struct dictionary *dict)\n{\n\treturn dict->pos < dict->limit;\n}\n\n \nstatic inline uint32_t dict_get(const struct dictionary *dict, uint32_t dist)\n{\n\tsize_t offset = dict->pos - dist - 1;\n\n\tif (dist >= dict->pos)\n\t\toffset += dict->end;\n\n\treturn dict->full > 0 ? dict->buf[offset] : 0;\n}\n\n \nstatic inline void dict_put(struct dictionary *dict, uint8_t byte)\n{\n\tdict->buf[dict->pos++] = byte;\n\n\tif (dict->full < dict->pos)\n\t\tdict->full = dict->pos;\n}\n\n \nstatic bool dict_repeat(struct dictionary *dict, uint32_t *len, uint32_t dist)\n{\n\tsize_t back;\n\tuint32_t left;\n\n\tif (dist >= dict->full || dist >= dict->size)\n\t\treturn false;\n\n\tleft = min_t(size_t, dict->limit - dict->pos, *len);\n\t*len -= left;\n\n\tback = dict->pos - dist - 1;\n\tif (dist >= dict->pos)\n\t\tback += dict->end;\n\n\tdo {\n\t\tdict->buf[dict->pos++] = dict->buf[back++];\n\t\tif (back == dict->end)\n\t\t\tback = 0;\n\t} while (--left > 0);\n\n\tif (dict->full < dict->pos)\n\t\tdict->full = dict->pos;\n\n\treturn true;\n}\n\n \nstatic void dict_uncompressed(struct dictionary *dict, struct xz_buf *b,\n\t\t\t      uint32_t *left)\n{\n\tsize_t copy_size;\n\n\twhile (*left > 0 && b->in_pos < b->in_size\n\t\t\t&& b->out_pos < b->out_size) {\n\t\tcopy_size = min(b->in_size - b->in_pos,\n\t\t\t\tb->out_size - b->out_pos);\n\t\tif (copy_size > dict->end - dict->pos)\n\t\t\tcopy_size = dict->end - dict->pos;\n\t\tif (copy_size > *left)\n\t\t\tcopy_size = *left;\n\n\t\t*left -= copy_size;\n\n\t\t \n\t\tmemmove(dict->buf + dict->pos, b->in + b->in_pos, copy_size);\n\t\tdict->pos += copy_size;\n\n\t\tif (dict->full < dict->pos)\n\t\t\tdict->full = dict->pos;\n\n\t\tif (DEC_IS_MULTI(dict->mode)) {\n\t\t\tif (dict->pos == dict->end)\n\t\t\t\tdict->pos = 0;\n\n\t\t\t \n\t\t\tmemmove(b->out + b->out_pos, b->in + b->in_pos,\n\t\t\t\t\tcopy_size);\n\t\t}\n\n\t\tdict->start = dict->pos;\n\n\t\tb->out_pos += copy_size;\n\t\tb->in_pos += copy_size;\n\t}\n}\n\n#ifdef XZ_DEC_MICROLZMA\n#\tdefine DICT_FLUSH_SUPPORTS_SKIPPING true\n#else\n#\tdefine DICT_FLUSH_SUPPORTS_SKIPPING false\n#endif\n\n \nstatic uint32_t dict_flush(struct dictionary *dict, struct xz_buf *b)\n{\n\tsize_t copy_size = dict->pos - dict->start;\n\n\tif (DEC_IS_MULTI(dict->mode)) {\n\t\tif (dict->pos == dict->end)\n\t\t\tdict->pos = 0;\n\n\t\t \n\t\tif (!DICT_FLUSH_SUPPORTS_SKIPPING || b->out != NULL)\n\t\t\tmemcpy(b->out + b->out_pos, dict->buf + dict->start,\n\t\t\t\t\tcopy_size);\n\t}\n\n\tdict->start = dict->pos;\n\tb->out_pos += copy_size;\n\treturn copy_size;\n}\n\n \n\n \nstatic void rc_reset(struct rc_dec *rc)\n{\n\trc->range = (uint32_t)-1;\n\trc->code = 0;\n\trc->init_bytes_left = RC_INIT_BYTES;\n}\n\n \nstatic bool rc_read_init(struct rc_dec *rc, struct xz_buf *b)\n{\n\twhile (rc->init_bytes_left > 0) {\n\t\tif (b->in_pos == b->in_size)\n\t\t\treturn false;\n\n\t\trc->code = (rc->code << 8) + b->in[b->in_pos++];\n\t\t--rc->init_bytes_left;\n\t}\n\n\treturn true;\n}\n\n \nstatic inline bool rc_limit_exceeded(const struct rc_dec *rc)\n{\n\treturn rc->in_pos > rc->in_limit;\n}\n\n \nstatic inline bool rc_is_finished(const struct rc_dec *rc)\n{\n\treturn rc->code == 0;\n}\n\n \nstatic __always_inline void rc_normalize(struct rc_dec *rc)\n{\n\tif (rc->range < RC_TOP_VALUE) {\n\t\trc->range <<= RC_SHIFT_BITS;\n\t\trc->code = (rc->code << RC_SHIFT_BITS) + rc->in[rc->in_pos++];\n\t}\n}\n\n \nstatic __always_inline int rc_bit(struct rc_dec *rc, uint16_t *prob)\n{\n\tuint32_t bound;\n\tint bit;\n\n\trc_normalize(rc);\n\tbound = (rc->range >> RC_BIT_MODEL_TOTAL_BITS) * *prob;\n\tif (rc->code < bound) {\n\t\trc->range = bound;\n\t\t*prob += (RC_BIT_MODEL_TOTAL - *prob) >> RC_MOVE_BITS;\n\t\tbit = 0;\n\t} else {\n\t\trc->range -= bound;\n\t\trc->code -= bound;\n\t\t*prob -= *prob >> RC_MOVE_BITS;\n\t\tbit = 1;\n\t}\n\n\treturn bit;\n}\n\n \nstatic __always_inline uint32_t rc_bittree(struct rc_dec *rc,\n\t\t\t\t\t   uint16_t *probs, uint32_t limit)\n{\n\tuint32_t symbol = 1;\n\n\tdo {\n\t\tif (rc_bit(rc, &probs[symbol]))\n\t\t\tsymbol = (symbol << 1) + 1;\n\t\telse\n\t\t\tsymbol <<= 1;\n\t} while (symbol < limit);\n\n\treturn symbol;\n}\n\n \nstatic __always_inline void rc_bittree_reverse(struct rc_dec *rc,\n\t\t\t\t\t       uint16_t *probs,\n\t\t\t\t\t       uint32_t *dest, uint32_t limit)\n{\n\tuint32_t symbol = 1;\n\tuint32_t i = 0;\n\n\tdo {\n\t\tif (rc_bit(rc, &probs[symbol])) {\n\t\t\tsymbol = (symbol << 1) + 1;\n\t\t\t*dest += 1 << i;\n\t\t} else {\n\t\t\tsymbol <<= 1;\n\t\t}\n\t} while (++i < limit);\n}\n\n \nstatic inline void rc_direct(struct rc_dec *rc, uint32_t *dest, uint32_t limit)\n{\n\tuint32_t mask;\n\n\tdo {\n\t\trc_normalize(rc);\n\t\trc->range >>= 1;\n\t\trc->code -= rc->range;\n\t\tmask = (uint32_t)0 - (rc->code >> 31);\n\t\trc->code += rc->range & mask;\n\t\t*dest = (*dest << 1) + (mask + 1);\n\t} while (--limit > 0);\n}\n\n \n\n \nstatic uint16_t *lzma_literal_probs(struct xz_dec_lzma2 *s)\n{\n\tuint32_t prev_byte = dict_get(&s->dict, 0);\n\tuint32_t low = prev_byte >> (8 - s->lzma.lc);\n\tuint32_t high = (s->dict.pos & s->lzma.literal_pos_mask) << s->lzma.lc;\n\treturn s->lzma.literal[low + high];\n}\n\n \nstatic void lzma_literal(struct xz_dec_lzma2 *s)\n{\n\tuint16_t *probs;\n\tuint32_t symbol;\n\tuint32_t match_byte;\n\tuint32_t match_bit;\n\tuint32_t offset;\n\tuint32_t i;\n\n\tprobs = lzma_literal_probs(s);\n\n\tif (lzma_state_is_literal(s->lzma.state)) {\n\t\tsymbol = rc_bittree(&s->rc, probs, 0x100);\n\t} else {\n\t\tsymbol = 1;\n\t\tmatch_byte = dict_get(&s->dict, s->lzma.rep0) << 1;\n\t\toffset = 0x100;\n\n\t\tdo {\n\t\t\tmatch_bit = match_byte & offset;\n\t\t\tmatch_byte <<= 1;\n\t\t\ti = offset + match_bit + symbol;\n\n\t\t\tif (rc_bit(&s->rc, &probs[i])) {\n\t\t\t\tsymbol = (symbol << 1) + 1;\n\t\t\t\toffset &= match_bit;\n\t\t\t} else {\n\t\t\t\tsymbol <<= 1;\n\t\t\t\toffset &= ~match_bit;\n\t\t\t}\n\t\t} while (symbol < 0x100);\n\t}\n\n\tdict_put(&s->dict, (uint8_t)symbol);\n\tlzma_state_literal(&s->lzma.state);\n}\n\n \nstatic void lzma_len(struct xz_dec_lzma2 *s, struct lzma_len_dec *l,\n\t\t     uint32_t pos_state)\n{\n\tuint16_t *probs;\n\tuint32_t limit;\n\n\tif (!rc_bit(&s->rc, &l->choice)) {\n\t\tprobs = l->low[pos_state];\n\t\tlimit = LEN_LOW_SYMBOLS;\n\t\ts->lzma.len = MATCH_LEN_MIN;\n\t} else {\n\t\tif (!rc_bit(&s->rc, &l->choice2)) {\n\t\t\tprobs = l->mid[pos_state];\n\t\t\tlimit = LEN_MID_SYMBOLS;\n\t\t\ts->lzma.len = MATCH_LEN_MIN + LEN_LOW_SYMBOLS;\n\t\t} else {\n\t\t\tprobs = l->high;\n\t\t\tlimit = LEN_HIGH_SYMBOLS;\n\t\t\ts->lzma.len = MATCH_LEN_MIN + LEN_LOW_SYMBOLS\n\t\t\t\t\t+ LEN_MID_SYMBOLS;\n\t\t}\n\t}\n\n\ts->lzma.len += rc_bittree(&s->rc, probs, limit) - limit;\n}\n\n \nstatic void lzma_match(struct xz_dec_lzma2 *s, uint32_t pos_state)\n{\n\tuint16_t *probs;\n\tuint32_t dist_slot;\n\tuint32_t limit;\n\n\tlzma_state_match(&s->lzma.state);\n\n\ts->lzma.rep3 = s->lzma.rep2;\n\ts->lzma.rep2 = s->lzma.rep1;\n\ts->lzma.rep1 = s->lzma.rep0;\n\n\tlzma_len(s, &s->lzma.match_len_dec, pos_state);\n\n\tprobs = s->lzma.dist_slot[lzma_get_dist_state(s->lzma.len)];\n\tdist_slot = rc_bittree(&s->rc, probs, DIST_SLOTS) - DIST_SLOTS;\n\n\tif (dist_slot < DIST_MODEL_START) {\n\t\ts->lzma.rep0 = dist_slot;\n\t} else {\n\t\tlimit = (dist_slot >> 1) - 1;\n\t\ts->lzma.rep0 = 2 + (dist_slot & 1);\n\n\t\tif (dist_slot < DIST_MODEL_END) {\n\t\t\ts->lzma.rep0 <<= limit;\n\t\t\tprobs = s->lzma.dist_special + s->lzma.rep0\n\t\t\t\t\t- dist_slot - 1;\n\t\t\trc_bittree_reverse(&s->rc, probs,\n\t\t\t\t\t&s->lzma.rep0, limit);\n\t\t} else {\n\t\t\trc_direct(&s->rc, &s->lzma.rep0, limit - ALIGN_BITS);\n\t\t\ts->lzma.rep0 <<= ALIGN_BITS;\n\t\t\trc_bittree_reverse(&s->rc, s->lzma.dist_align,\n\t\t\t\t\t&s->lzma.rep0, ALIGN_BITS);\n\t\t}\n\t}\n}\n\n \nstatic void lzma_rep_match(struct xz_dec_lzma2 *s, uint32_t pos_state)\n{\n\tuint32_t tmp;\n\n\tif (!rc_bit(&s->rc, &s->lzma.is_rep0[s->lzma.state])) {\n\t\tif (!rc_bit(&s->rc, &s->lzma.is_rep0_long[\n\t\t\t\ts->lzma.state][pos_state])) {\n\t\t\tlzma_state_short_rep(&s->lzma.state);\n\t\t\ts->lzma.len = 1;\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tif (!rc_bit(&s->rc, &s->lzma.is_rep1[s->lzma.state])) {\n\t\t\ttmp = s->lzma.rep1;\n\t\t} else {\n\t\t\tif (!rc_bit(&s->rc, &s->lzma.is_rep2[s->lzma.state])) {\n\t\t\t\ttmp = s->lzma.rep2;\n\t\t\t} else {\n\t\t\t\ttmp = s->lzma.rep3;\n\t\t\t\ts->lzma.rep3 = s->lzma.rep2;\n\t\t\t}\n\n\t\t\ts->lzma.rep2 = s->lzma.rep1;\n\t\t}\n\n\t\ts->lzma.rep1 = s->lzma.rep0;\n\t\ts->lzma.rep0 = tmp;\n\t}\n\n\tlzma_state_long_rep(&s->lzma.state);\n\tlzma_len(s, &s->lzma.rep_len_dec, pos_state);\n}\n\n \nstatic bool lzma_main(struct xz_dec_lzma2 *s)\n{\n\tuint32_t pos_state;\n\n\t \n\tif (dict_has_space(&s->dict) && s->lzma.len > 0)\n\t\tdict_repeat(&s->dict, &s->lzma.len, s->lzma.rep0);\n\n\t \n\twhile (dict_has_space(&s->dict) && !rc_limit_exceeded(&s->rc)) {\n\t\tpos_state = s->dict.pos & s->lzma.pos_mask;\n\n\t\tif (!rc_bit(&s->rc, &s->lzma.is_match[\n\t\t\t\ts->lzma.state][pos_state])) {\n\t\t\tlzma_literal(s);\n\t\t} else {\n\t\t\tif (rc_bit(&s->rc, &s->lzma.is_rep[s->lzma.state]))\n\t\t\t\tlzma_rep_match(s, pos_state);\n\t\t\telse\n\t\t\t\tlzma_match(s, pos_state);\n\n\t\t\tif (!dict_repeat(&s->dict, &s->lzma.len, s->lzma.rep0))\n\t\t\t\treturn false;\n\t\t}\n\t}\n\n\t \n\trc_normalize(&s->rc);\n\n\treturn true;\n}\n\n \nstatic void lzma_reset(struct xz_dec_lzma2 *s)\n{\n\tuint16_t *probs;\n\tsize_t i;\n\n\ts->lzma.state = STATE_LIT_LIT;\n\ts->lzma.rep0 = 0;\n\ts->lzma.rep1 = 0;\n\ts->lzma.rep2 = 0;\n\ts->lzma.rep3 = 0;\n\ts->lzma.len = 0;\n\n\t \n\tprobs = s->lzma.is_match[0];\n\tfor (i = 0; i < PROBS_TOTAL; ++i)\n\t\tprobs[i] = RC_BIT_MODEL_TOTAL / 2;\n\n\trc_reset(&s->rc);\n}\n\n \nstatic bool lzma_props(struct xz_dec_lzma2 *s, uint8_t props)\n{\n\tif (props > (4 * 5 + 4) * 9 + 8)\n\t\treturn false;\n\n\ts->lzma.pos_mask = 0;\n\twhile (props >= 9 * 5) {\n\t\tprops -= 9 * 5;\n\t\t++s->lzma.pos_mask;\n\t}\n\n\ts->lzma.pos_mask = (1 << s->lzma.pos_mask) - 1;\n\n\ts->lzma.literal_pos_mask = 0;\n\twhile (props >= 9) {\n\t\tprops -= 9;\n\t\t++s->lzma.literal_pos_mask;\n\t}\n\n\ts->lzma.lc = props;\n\n\tif (s->lzma.lc + s->lzma.literal_pos_mask > 4)\n\t\treturn false;\n\n\ts->lzma.literal_pos_mask = (1 << s->lzma.literal_pos_mask) - 1;\n\n\tlzma_reset(s);\n\n\treturn true;\n}\n\n \n\n \nstatic bool lzma2_lzma(struct xz_dec_lzma2 *s, struct xz_buf *b)\n{\n\tsize_t in_avail;\n\tuint32_t tmp;\n\n\tin_avail = b->in_size - b->in_pos;\n\tif (s->temp.size > 0 || s->lzma2.compressed == 0) {\n\t\ttmp = 2 * LZMA_IN_REQUIRED - s->temp.size;\n\t\tif (tmp > s->lzma2.compressed - s->temp.size)\n\t\t\ttmp = s->lzma2.compressed - s->temp.size;\n\t\tif (tmp > in_avail)\n\t\t\ttmp = in_avail;\n\n\t\tmemcpy(s->temp.buf + s->temp.size, b->in + b->in_pos, tmp);\n\n\t\tif (s->temp.size + tmp == s->lzma2.compressed) {\n\t\t\tmemzero(s->temp.buf + s->temp.size + tmp,\n\t\t\t\t\tsizeof(s->temp.buf)\n\t\t\t\t\t\t- s->temp.size - tmp);\n\t\t\ts->rc.in_limit = s->temp.size + tmp;\n\t\t} else if (s->temp.size + tmp < LZMA_IN_REQUIRED) {\n\t\t\ts->temp.size += tmp;\n\t\t\tb->in_pos += tmp;\n\t\t\treturn true;\n\t\t} else {\n\t\t\ts->rc.in_limit = s->temp.size + tmp - LZMA_IN_REQUIRED;\n\t\t}\n\n\t\ts->rc.in = s->temp.buf;\n\t\ts->rc.in_pos = 0;\n\n\t\tif (!lzma_main(s) || s->rc.in_pos > s->temp.size + tmp)\n\t\t\treturn false;\n\n\t\ts->lzma2.compressed -= s->rc.in_pos;\n\n\t\tif (s->rc.in_pos < s->temp.size) {\n\t\t\ts->temp.size -= s->rc.in_pos;\n\t\t\tmemmove(s->temp.buf, s->temp.buf + s->rc.in_pos,\n\t\t\t\t\ts->temp.size);\n\t\t\treturn true;\n\t\t}\n\n\t\tb->in_pos += s->rc.in_pos - s->temp.size;\n\t\ts->temp.size = 0;\n\t}\n\n\tin_avail = b->in_size - b->in_pos;\n\tif (in_avail >= LZMA_IN_REQUIRED) {\n\t\ts->rc.in = b->in;\n\t\ts->rc.in_pos = b->in_pos;\n\n\t\tif (in_avail >= s->lzma2.compressed + LZMA_IN_REQUIRED)\n\t\t\ts->rc.in_limit = b->in_pos + s->lzma2.compressed;\n\t\telse\n\t\t\ts->rc.in_limit = b->in_size - LZMA_IN_REQUIRED;\n\n\t\tif (!lzma_main(s))\n\t\t\treturn false;\n\n\t\tin_avail = s->rc.in_pos - b->in_pos;\n\t\tif (in_avail > s->lzma2.compressed)\n\t\t\treturn false;\n\n\t\ts->lzma2.compressed -= in_avail;\n\t\tb->in_pos = s->rc.in_pos;\n\t}\n\n\tin_avail = b->in_size - b->in_pos;\n\tif (in_avail < LZMA_IN_REQUIRED) {\n\t\tif (in_avail > s->lzma2.compressed)\n\t\t\tin_avail = s->lzma2.compressed;\n\n\t\tmemcpy(s->temp.buf, b->in + b->in_pos, in_avail);\n\t\ts->temp.size = in_avail;\n\t\tb->in_pos += in_avail;\n\t}\n\n\treturn true;\n}\n\n \nXZ_EXTERN enum xz_ret xz_dec_lzma2_run(struct xz_dec_lzma2 *s,\n\t\t\t\t       struct xz_buf *b)\n{\n\tuint32_t tmp;\n\n\twhile (b->in_pos < b->in_size || s->lzma2.sequence == SEQ_LZMA_RUN) {\n\t\tswitch (s->lzma2.sequence) {\n\t\tcase SEQ_CONTROL:\n\t\t\t \n\t\t\ttmp = b->in[b->in_pos++];\n\n\t\t\tif (tmp == 0x00)\n\t\t\t\treturn XZ_STREAM_END;\n\n\t\t\tif (tmp >= 0xE0 || tmp == 0x01) {\n\t\t\t\ts->lzma2.need_props = true;\n\t\t\t\ts->lzma2.need_dict_reset = false;\n\t\t\t\tdict_reset(&s->dict, b);\n\t\t\t} else if (s->lzma2.need_dict_reset) {\n\t\t\t\treturn XZ_DATA_ERROR;\n\t\t\t}\n\n\t\t\tif (tmp >= 0x80) {\n\t\t\t\ts->lzma2.uncompressed = (tmp & 0x1F) << 16;\n\t\t\t\ts->lzma2.sequence = SEQ_UNCOMPRESSED_1;\n\n\t\t\t\tif (tmp >= 0xC0) {\n\t\t\t\t\t \n\t\t\t\t\ts->lzma2.need_props = false;\n\t\t\t\t\ts->lzma2.next_sequence\n\t\t\t\t\t\t\t= SEQ_PROPERTIES;\n\n\t\t\t\t} else if (s->lzma2.need_props) {\n\t\t\t\t\treturn XZ_DATA_ERROR;\n\n\t\t\t\t} else {\n\t\t\t\t\ts->lzma2.next_sequence\n\t\t\t\t\t\t\t= SEQ_LZMA_PREPARE;\n\t\t\t\t\tif (tmp >= 0xA0)\n\t\t\t\t\t\tlzma_reset(s);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (tmp > 0x02)\n\t\t\t\t\treturn XZ_DATA_ERROR;\n\n\t\t\t\ts->lzma2.sequence = SEQ_COMPRESSED_0;\n\t\t\t\ts->lzma2.next_sequence = SEQ_COPY;\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase SEQ_UNCOMPRESSED_1:\n\t\t\ts->lzma2.uncompressed\n\t\t\t\t\t+= (uint32_t)b->in[b->in_pos++] << 8;\n\t\t\ts->lzma2.sequence = SEQ_UNCOMPRESSED_2;\n\t\t\tbreak;\n\n\t\tcase SEQ_UNCOMPRESSED_2:\n\t\t\ts->lzma2.uncompressed\n\t\t\t\t\t+= (uint32_t)b->in[b->in_pos++] + 1;\n\t\t\ts->lzma2.sequence = SEQ_COMPRESSED_0;\n\t\t\tbreak;\n\n\t\tcase SEQ_COMPRESSED_0:\n\t\t\ts->lzma2.compressed\n\t\t\t\t\t= (uint32_t)b->in[b->in_pos++] << 8;\n\t\t\ts->lzma2.sequence = SEQ_COMPRESSED_1;\n\t\t\tbreak;\n\n\t\tcase SEQ_COMPRESSED_1:\n\t\t\ts->lzma2.compressed\n\t\t\t\t\t+= (uint32_t)b->in[b->in_pos++] + 1;\n\t\t\ts->lzma2.sequence = s->lzma2.next_sequence;\n\t\t\tbreak;\n\n\t\tcase SEQ_PROPERTIES:\n\t\t\tif (!lzma_props(s, b->in[b->in_pos++]))\n\t\t\t\treturn XZ_DATA_ERROR;\n\n\t\t\ts->lzma2.sequence = SEQ_LZMA_PREPARE;\n\n\t\t\tfallthrough;\n\n\t\tcase SEQ_LZMA_PREPARE:\n\t\t\tif (s->lzma2.compressed < RC_INIT_BYTES)\n\t\t\t\treturn XZ_DATA_ERROR;\n\n\t\t\tif (!rc_read_init(&s->rc, b))\n\t\t\t\treturn XZ_OK;\n\n\t\t\ts->lzma2.compressed -= RC_INIT_BYTES;\n\t\t\ts->lzma2.sequence = SEQ_LZMA_RUN;\n\n\t\t\tfallthrough;\n\n\t\tcase SEQ_LZMA_RUN:\n\t\t\t \n\t\t\tdict_limit(&s->dict, min_t(size_t,\n\t\t\t\t\tb->out_size - b->out_pos,\n\t\t\t\t\ts->lzma2.uncompressed));\n\t\t\tif (!lzma2_lzma(s, b))\n\t\t\t\treturn XZ_DATA_ERROR;\n\n\t\t\ts->lzma2.uncompressed -= dict_flush(&s->dict, b);\n\n\t\t\tif (s->lzma2.uncompressed == 0) {\n\t\t\t\tif (s->lzma2.compressed > 0 || s->lzma.len > 0\n\t\t\t\t\t\t|| !rc_is_finished(&s->rc))\n\t\t\t\t\treturn XZ_DATA_ERROR;\n\n\t\t\t\trc_reset(&s->rc);\n\t\t\t\ts->lzma2.sequence = SEQ_CONTROL;\n\n\t\t\t} else if (b->out_pos == b->out_size\n\t\t\t\t\t|| (b->in_pos == b->in_size\n\t\t\t\t\t\t&& s->temp.size\n\t\t\t\t\t\t< s->lzma2.compressed)) {\n\t\t\t\treturn XZ_OK;\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase SEQ_COPY:\n\t\t\tdict_uncompressed(&s->dict, b, &s->lzma2.compressed);\n\t\t\tif (s->lzma2.compressed > 0)\n\t\t\t\treturn XZ_OK;\n\n\t\t\ts->lzma2.sequence = SEQ_CONTROL;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn XZ_OK;\n}\n\nXZ_EXTERN struct xz_dec_lzma2 *xz_dec_lzma2_create(enum xz_mode mode,\n\t\t\t\t\t\t   uint32_t dict_max)\n{\n\tstruct xz_dec_lzma2 *s = kmalloc(sizeof(*s), GFP_KERNEL);\n\tif (s == NULL)\n\t\treturn NULL;\n\n\ts->dict.mode = mode;\n\ts->dict.size_max = dict_max;\n\n\tif (DEC_IS_PREALLOC(mode)) {\n\t\ts->dict.buf = vmalloc(dict_max);\n\t\tif (s->dict.buf == NULL) {\n\t\t\tkfree(s);\n\t\t\treturn NULL;\n\t\t}\n\t} else if (DEC_IS_DYNALLOC(mode)) {\n\t\ts->dict.buf = NULL;\n\t\ts->dict.allocated = 0;\n\t}\n\n\treturn s;\n}\n\nXZ_EXTERN enum xz_ret xz_dec_lzma2_reset(struct xz_dec_lzma2 *s, uint8_t props)\n{\n\t \n\tif (props > 39)\n\t\treturn XZ_OPTIONS_ERROR;\n\n\ts->dict.size = 2 + (props & 1);\n\ts->dict.size <<= (props >> 1) + 11;\n\n\tif (DEC_IS_MULTI(s->dict.mode)) {\n\t\tif (s->dict.size > s->dict.size_max)\n\t\t\treturn XZ_MEMLIMIT_ERROR;\n\n\t\ts->dict.end = s->dict.size;\n\n\t\tif (DEC_IS_DYNALLOC(s->dict.mode)) {\n\t\t\tif (s->dict.allocated < s->dict.size) {\n\t\t\t\ts->dict.allocated = s->dict.size;\n\t\t\t\tvfree(s->dict.buf);\n\t\t\t\ts->dict.buf = vmalloc(s->dict.size);\n\t\t\t\tif (s->dict.buf == NULL) {\n\t\t\t\t\ts->dict.allocated = 0;\n\t\t\t\t\treturn XZ_MEM_ERROR;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\ts->lzma2.sequence = SEQ_CONTROL;\n\ts->lzma2.need_dict_reset = true;\n\n\ts->temp.size = 0;\n\n\treturn XZ_OK;\n}\n\nXZ_EXTERN void xz_dec_lzma2_end(struct xz_dec_lzma2 *s)\n{\n\tif (DEC_IS_MULTI(s->dict.mode))\n\t\tvfree(s->dict.buf);\n\n\tkfree(s);\n}\n\n#ifdef XZ_DEC_MICROLZMA\n \nstruct xz_dec_microlzma {\n\tstruct xz_dec_lzma2 s;\n};\n\nenum xz_ret xz_dec_microlzma_run(struct xz_dec_microlzma *s_ptr,\n\t\t\t\t struct xz_buf *b)\n{\n\tstruct xz_dec_lzma2 *s = &s_ptr->s;\n\n\t \n\tif (s->lzma2.sequence != SEQ_LZMA_RUN) {\n\t\tif (s->lzma2.sequence == SEQ_PROPERTIES) {\n\t\t\t \n\t\t\tif (b->in_pos >= b->in_size)\n\t\t\t\treturn XZ_OK;\n\n\t\t\t \n\t\t\tif (!lzma_props(s, ~b->in[b->in_pos]))\n\t\t\t\treturn XZ_DATA_ERROR;\n\n\t\t\ts->lzma2.sequence = SEQ_LZMA_PREPARE;\n\t\t}\n\n\t\t \n\t\tif (s->lzma2.compressed < RC_INIT_BYTES\n\t\t\t\t|| s->lzma2.compressed > (3U << 30))\n\t\t\treturn XZ_DATA_ERROR;\n\n\t\tif (!rc_read_init(&s->rc, b))\n\t\t\treturn XZ_OK;\n\n\t\ts->lzma2.compressed -= RC_INIT_BYTES;\n\t\ts->lzma2.sequence = SEQ_LZMA_RUN;\n\n\t\tdict_reset(&s->dict, b);\n\t}\n\n\t \n\tif (DEC_IS_SINGLE(s->dict.mode))\n\t\ts->dict.end = b->out_size - b->out_pos;\n\n\twhile (true) {\n\t\tdict_limit(&s->dict, min_t(size_t, b->out_size - b->out_pos,\n\t\t\t\t\t   s->lzma2.uncompressed));\n\n\t\tif (!lzma2_lzma(s, b))\n\t\t\treturn XZ_DATA_ERROR;\n\n\t\ts->lzma2.uncompressed -= dict_flush(&s->dict, b);\n\n\t\tif (s->lzma2.uncompressed == 0) {\n\t\t\tif (s->lzma2.pedantic_microlzma) {\n\t\t\t\tif (s->lzma2.compressed > 0 || s->lzma.len > 0\n\t\t\t\t\t\t|| !rc_is_finished(&s->rc))\n\t\t\t\t\treturn XZ_DATA_ERROR;\n\t\t\t}\n\n\t\t\treturn XZ_STREAM_END;\n\t\t}\n\n\t\tif (b->out_pos == b->out_size)\n\t\t\treturn XZ_OK;\n\n\t\tif (b->in_pos == b->in_size\n\t\t\t\t&& s->temp.size < s->lzma2.compressed)\n\t\t\treturn XZ_OK;\n\t}\n}\n\nstruct xz_dec_microlzma *xz_dec_microlzma_alloc(enum xz_mode mode,\n\t\t\t\t\t\tuint32_t dict_size)\n{\n\tstruct xz_dec_microlzma *s;\n\n\t \n\tif (dict_size < 4096 || dict_size > (3U << 30))\n\t\treturn NULL;\n\n\ts = kmalloc(sizeof(*s), GFP_KERNEL);\n\tif (s == NULL)\n\t\treturn NULL;\n\n\ts->s.dict.mode = mode;\n\ts->s.dict.size = dict_size;\n\n\tif (DEC_IS_MULTI(mode)) {\n\t\ts->s.dict.end = dict_size;\n\n\t\ts->s.dict.buf = vmalloc(dict_size);\n\t\tif (s->s.dict.buf == NULL) {\n\t\t\tkfree(s);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn s;\n}\n\nvoid xz_dec_microlzma_reset(struct xz_dec_microlzma *s, uint32_t comp_size,\n\t\t\t    uint32_t uncomp_size, int uncomp_size_is_exact)\n{\n\t \n\ts->s.lzma2.compressed = comp_size;\n\ts->s.lzma2.uncompressed = uncomp_size;\n\ts->s.lzma2.pedantic_microlzma = uncomp_size_is_exact;\n\n\ts->s.lzma2.sequence = SEQ_PROPERTIES;\n\ts->s.temp.size = 0;\n}\n\nvoid xz_dec_microlzma_end(struct xz_dec_microlzma *s)\n{\n\tif (DEC_IS_MULTI(s->s.dict.mode))\n\t\tvfree(s->s.dict.buf);\n\n\tkfree(s);\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}