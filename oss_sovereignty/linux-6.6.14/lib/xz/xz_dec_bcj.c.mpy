{
  "module_name": "xz_dec_bcj.c",
  "hash_id": "047be921556707a59ed1ab68224644b6ba6484c66d604adc07771cf3b33cf444",
  "original_prompt": "Ingested from linux-6.6.14/lib/xz/xz_dec_bcj.c",
  "human_readable_source": " \n\n#include \"xz_private.h\"\n\n \n#ifdef XZ_DEC_BCJ\n\nstruct xz_dec_bcj {\n\t \n\tenum {\n\t\tBCJ_X86 = 4,         \n\t\tBCJ_POWERPC = 5,     \n\t\tBCJ_IA64 = 6,        \n\t\tBCJ_ARM = 7,         \n\t\tBCJ_ARMTHUMB = 8,    \n\t\tBCJ_SPARC = 9        \n\t} type;\n\n\t \n\tenum xz_ret ret;\n\n\t \n\tbool single_call;\n\n\t \n\tuint32_t pos;\n\n\t \n\tuint32_t x86_prev_mask;\n\n\t \n\tuint8_t *out;\n\tsize_t out_pos;\n\tsize_t out_size;\n\n\tstruct {\n\t\t \n\t\tsize_t filtered;\n\n\t\t \n\t\tsize_t size;\n\n\t\t \n\t\tuint8_t buf[16];\n\t} temp;\n};\n\n#ifdef XZ_DEC_X86\n \nstatic inline int bcj_x86_test_msbyte(uint8_t b)\n{\n\treturn b == 0x00 || b == 0xFF;\n}\n\nstatic size_t bcj_x86(struct xz_dec_bcj *s, uint8_t *buf, size_t size)\n{\n\tstatic const bool mask_to_allowed_status[8]\n\t\t= { true, true, true, false, true, false, false, false };\n\n\tstatic const uint8_t mask_to_bit_num[8] = { 0, 1, 2, 2, 3, 3, 3, 3 };\n\n\tsize_t i;\n\tsize_t prev_pos = (size_t)-1;\n\tuint32_t prev_mask = s->x86_prev_mask;\n\tuint32_t src;\n\tuint32_t dest;\n\tuint32_t j;\n\tuint8_t b;\n\n\tif (size <= 4)\n\t\treturn 0;\n\n\tsize -= 4;\n\tfor (i = 0; i < size; ++i) {\n\t\tif ((buf[i] & 0xFE) != 0xE8)\n\t\t\tcontinue;\n\n\t\tprev_pos = i - prev_pos;\n\t\tif (prev_pos > 3) {\n\t\t\tprev_mask = 0;\n\t\t} else {\n\t\t\tprev_mask = (prev_mask << (prev_pos - 1)) & 7;\n\t\t\tif (prev_mask != 0) {\n\t\t\t\tb = buf[i + 4 - mask_to_bit_num[prev_mask]];\n\t\t\t\tif (!mask_to_allowed_status[prev_mask]\n\t\t\t\t\t\t|| bcj_x86_test_msbyte(b)) {\n\t\t\t\t\tprev_pos = i;\n\t\t\t\t\tprev_mask = (prev_mask << 1) | 1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprev_pos = i;\n\n\t\tif (bcj_x86_test_msbyte(buf[i + 4])) {\n\t\t\tsrc = get_unaligned_le32(buf + i + 1);\n\t\t\twhile (true) {\n\t\t\t\tdest = src - (s->pos + (uint32_t)i + 5);\n\t\t\t\tif (prev_mask == 0)\n\t\t\t\t\tbreak;\n\n\t\t\t\tj = mask_to_bit_num[prev_mask] * 8;\n\t\t\t\tb = (uint8_t)(dest >> (24 - j));\n\t\t\t\tif (!bcj_x86_test_msbyte(b))\n\t\t\t\t\tbreak;\n\n\t\t\t\tsrc = dest ^ (((uint32_t)1 << (32 - j)) - 1);\n\t\t\t}\n\n\t\t\tdest &= 0x01FFFFFF;\n\t\t\tdest |= (uint32_t)0 - (dest & 0x01000000);\n\t\t\tput_unaligned_le32(dest, buf + i + 1);\n\t\t\ti += 4;\n\t\t} else {\n\t\t\tprev_mask = (prev_mask << 1) | 1;\n\t\t}\n\t}\n\n\tprev_pos = i - prev_pos;\n\ts->x86_prev_mask = prev_pos > 3 ? 0 : prev_mask << (prev_pos - 1);\n\treturn i;\n}\n#endif\n\n#ifdef XZ_DEC_POWERPC\nstatic size_t bcj_powerpc(struct xz_dec_bcj *s, uint8_t *buf, size_t size)\n{\n\tsize_t i;\n\tuint32_t instr;\n\n\tfor (i = 0; i + 4 <= size; i += 4) {\n\t\tinstr = get_unaligned_be32(buf + i);\n\t\tif ((instr & 0xFC000003) == 0x48000001) {\n\t\t\tinstr &= 0x03FFFFFC;\n\t\t\tinstr -= s->pos + (uint32_t)i;\n\t\t\tinstr &= 0x03FFFFFC;\n\t\t\tinstr |= 0x48000001;\n\t\t\tput_unaligned_be32(instr, buf + i);\n\t\t}\n\t}\n\n\treturn i;\n}\n#endif\n\n#ifdef XZ_DEC_IA64\nstatic size_t bcj_ia64(struct xz_dec_bcj *s, uint8_t *buf, size_t size)\n{\n\tstatic const uint8_t branch_table[32] = {\n\t\t0, 0, 0, 0, 0, 0, 0, 0,\n\t\t0, 0, 0, 0, 0, 0, 0, 0,\n\t\t4, 4, 6, 6, 0, 0, 7, 7,\n\t\t4, 4, 0, 0, 4, 4, 0, 0\n\t};\n\n\t \n\n\t \n\tsize_t i;\n\tsize_t j;\n\n\t \n\tuint32_t slot;\n\n\t \n\tuint32_t bit_pos;\n\n\t \n\tuint32_t byte_pos;\n\tuint32_t bit_res;\n\n\t \n\tuint32_t addr;\n\n\t \n\tuint32_t mask;\n\n\t \n\tuint64_t instr;\n\n\t \n\tuint64_t norm;\n\n\tfor (i = 0; i + 16 <= size; i += 16) {\n\t\tmask = branch_table[buf[i] & 0x1F];\n\t\tfor (slot = 0, bit_pos = 5; slot < 3; ++slot, bit_pos += 41) {\n\t\t\tif (((mask >> slot) & 1) == 0)\n\t\t\t\tcontinue;\n\n\t\t\tbyte_pos = bit_pos >> 3;\n\t\t\tbit_res = bit_pos & 7;\n\t\t\tinstr = 0;\n\t\t\tfor (j = 0; j < 6; ++j)\n\t\t\t\tinstr |= (uint64_t)(buf[i + j + byte_pos])\n\t\t\t\t\t\t<< (8 * j);\n\n\t\t\tnorm = instr >> bit_res;\n\n\t\t\tif (((norm >> 37) & 0x0F) == 0x05\n\t\t\t\t\t&& ((norm >> 9) & 0x07) == 0) {\n\t\t\t\taddr = (norm >> 13) & 0x0FFFFF;\n\t\t\t\taddr |= ((uint32_t)(norm >> 36) & 1) << 20;\n\t\t\t\taddr <<= 4;\n\t\t\t\taddr -= s->pos + (uint32_t)i;\n\t\t\t\taddr >>= 4;\n\n\t\t\t\tnorm &= ~((uint64_t)0x8FFFFF << 13);\n\t\t\t\tnorm |= (uint64_t)(addr & 0x0FFFFF) << 13;\n\t\t\t\tnorm |= (uint64_t)(addr & 0x100000)\n\t\t\t\t\t\t<< (36 - 20);\n\n\t\t\t\tinstr &= (1 << bit_res) - 1;\n\t\t\t\tinstr |= norm << bit_res;\n\n\t\t\t\tfor (j = 0; j < 6; j++)\n\t\t\t\t\tbuf[i + j + byte_pos]\n\t\t\t\t\t\t= (uint8_t)(instr >> (8 * j));\n\t\t\t}\n\t\t}\n\t}\n\n\treturn i;\n}\n#endif\n\n#ifdef XZ_DEC_ARM\nstatic size_t bcj_arm(struct xz_dec_bcj *s, uint8_t *buf, size_t size)\n{\n\tsize_t i;\n\tuint32_t addr;\n\n\tfor (i = 0; i + 4 <= size; i += 4) {\n\t\tif (buf[i + 3] == 0xEB) {\n\t\t\taddr = (uint32_t)buf[i] | ((uint32_t)buf[i + 1] << 8)\n\t\t\t\t\t| ((uint32_t)buf[i + 2] << 16);\n\t\t\taddr <<= 2;\n\t\t\taddr -= s->pos + (uint32_t)i + 8;\n\t\t\taddr >>= 2;\n\t\t\tbuf[i] = (uint8_t)addr;\n\t\t\tbuf[i + 1] = (uint8_t)(addr >> 8);\n\t\t\tbuf[i + 2] = (uint8_t)(addr >> 16);\n\t\t}\n\t}\n\n\treturn i;\n}\n#endif\n\n#ifdef XZ_DEC_ARMTHUMB\nstatic size_t bcj_armthumb(struct xz_dec_bcj *s, uint8_t *buf, size_t size)\n{\n\tsize_t i;\n\tuint32_t addr;\n\n\tfor (i = 0; i + 4 <= size; i += 2) {\n\t\tif ((buf[i + 1] & 0xF8) == 0xF0\n\t\t\t\t&& (buf[i + 3] & 0xF8) == 0xF8) {\n\t\t\taddr = (((uint32_t)buf[i + 1] & 0x07) << 19)\n\t\t\t\t\t| ((uint32_t)buf[i] << 11)\n\t\t\t\t\t| (((uint32_t)buf[i + 3] & 0x07) << 8)\n\t\t\t\t\t| (uint32_t)buf[i + 2];\n\t\t\taddr <<= 1;\n\t\t\taddr -= s->pos + (uint32_t)i + 4;\n\t\t\taddr >>= 1;\n\t\t\tbuf[i + 1] = (uint8_t)(0xF0 | ((addr >> 19) & 0x07));\n\t\t\tbuf[i] = (uint8_t)(addr >> 11);\n\t\t\tbuf[i + 3] = (uint8_t)(0xF8 | ((addr >> 8) & 0x07));\n\t\t\tbuf[i + 2] = (uint8_t)addr;\n\t\t\ti += 2;\n\t\t}\n\t}\n\n\treturn i;\n}\n#endif\n\n#ifdef XZ_DEC_SPARC\nstatic size_t bcj_sparc(struct xz_dec_bcj *s, uint8_t *buf, size_t size)\n{\n\tsize_t i;\n\tuint32_t instr;\n\n\tfor (i = 0; i + 4 <= size; i += 4) {\n\t\tinstr = get_unaligned_be32(buf + i);\n\t\tif ((instr >> 22) == 0x100 || (instr >> 22) == 0x1FF) {\n\t\t\tinstr <<= 2;\n\t\t\tinstr -= s->pos + (uint32_t)i;\n\t\t\tinstr >>= 2;\n\t\t\tinstr = ((uint32_t)0x40000000 - (instr & 0x400000))\n\t\t\t\t\t| 0x40000000 | (instr & 0x3FFFFF);\n\t\t\tput_unaligned_be32(instr, buf + i);\n\t\t}\n\t}\n\n\treturn i;\n}\n#endif\n\n \nstatic void bcj_apply(struct xz_dec_bcj *s,\n\t\t      uint8_t *buf, size_t *pos, size_t size)\n{\n\tsize_t filtered;\n\n\tbuf += *pos;\n\tsize -= *pos;\n\n\tswitch (s->type) {\n#ifdef XZ_DEC_X86\n\tcase BCJ_X86:\n\t\tfiltered = bcj_x86(s, buf, size);\n\t\tbreak;\n#endif\n#ifdef XZ_DEC_POWERPC\n\tcase BCJ_POWERPC:\n\t\tfiltered = bcj_powerpc(s, buf, size);\n\t\tbreak;\n#endif\n#ifdef XZ_DEC_IA64\n\tcase BCJ_IA64:\n\t\tfiltered = bcj_ia64(s, buf, size);\n\t\tbreak;\n#endif\n#ifdef XZ_DEC_ARM\n\tcase BCJ_ARM:\n\t\tfiltered = bcj_arm(s, buf, size);\n\t\tbreak;\n#endif\n#ifdef XZ_DEC_ARMTHUMB\n\tcase BCJ_ARMTHUMB:\n\t\tfiltered = bcj_armthumb(s, buf, size);\n\t\tbreak;\n#endif\n#ifdef XZ_DEC_SPARC\n\tcase BCJ_SPARC:\n\t\tfiltered = bcj_sparc(s, buf, size);\n\t\tbreak;\n#endif\n\tdefault:\n\t\t \n\t\tfiltered = 0;\n\t\tbreak;\n\t}\n\n\t*pos += filtered;\n\ts->pos += filtered;\n}\n\n \nstatic void bcj_flush(struct xz_dec_bcj *s, struct xz_buf *b)\n{\n\tsize_t copy_size;\n\n\tcopy_size = min_t(size_t, s->temp.filtered, b->out_size - b->out_pos);\n\tmemcpy(b->out + b->out_pos, s->temp.buf, copy_size);\n\tb->out_pos += copy_size;\n\n\ts->temp.filtered -= copy_size;\n\ts->temp.size -= copy_size;\n\tmemmove(s->temp.buf, s->temp.buf + copy_size, s->temp.size);\n}\n\n \nXZ_EXTERN enum xz_ret xz_dec_bcj_run(struct xz_dec_bcj *s,\n\t\t\t\t     struct xz_dec_lzma2 *lzma2,\n\t\t\t\t     struct xz_buf *b)\n{\n\tsize_t out_start;\n\n\t \n\tif (s->temp.filtered > 0) {\n\t\tbcj_flush(s, b);\n\t\tif (s->temp.filtered > 0)\n\t\t\treturn XZ_OK;\n\n\t\tif (s->ret == XZ_STREAM_END)\n\t\t\treturn XZ_STREAM_END;\n\t}\n\n\t \n\tif (s->temp.size < b->out_size - b->out_pos || s->temp.size == 0) {\n\t\tout_start = b->out_pos;\n\t\tmemcpy(b->out + b->out_pos, s->temp.buf, s->temp.size);\n\t\tb->out_pos += s->temp.size;\n\n\t\ts->ret = xz_dec_lzma2_run(lzma2, b);\n\t\tif (s->ret != XZ_STREAM_END\n\t\t\t\t&& (s->ret != XZ_OK || s->single_call))\n\t\t\treturn s->ret;\n\n\t\tbcj_apply(s, b->out, &out_start, b->out_pos);\n\n\t\t \n\t\tif (s->ret == XZ_STREAM_END)\n\t\t\treturn XZ_STREAM_END;\n\n\t\ts->temp.size = b->out_pos - out_start;\n\t\tb->out_pos -= s->temp.size;\n\t\tmemcpy(s->temp.buf, b->out + b->out_pos, s->temp.size);\n\n\t\t \n\t\tif (b->out_pos + s->temp.size < b->out_size)\n\t\t\treturn XZ_OK;\n\t}\n\n\t \n\tif (b->out_pos < b->out_size) {\n\t\t \n\t\ts->out = b->out;\n\t\ts->out_pos = b->out_pos;\n\t\ts->out_size = b->out_size;\n\t\tb->out = s->temp.buf;\n\t\tb->out_pos = s->temp.size;\n\t\tb->out_size = sizeof(s->temp.buf);\n\n\t\ts->ret = xz_dec_lzma2_run(lzma2, b);\n\n\t\ts->temp.size = b->out_pos;\n\t\tb->out = s->out;\n\t\tb->out_pos = s->out_pos;\n\t\tb->out_size = s->out_size;\n\n\t\tif (s->ret != XZ_OK && s->ret != XZ_STREAM_END)\n\t\t\treturn s->ret;\n\n\t\tbcj_apply(s, s->temp.buf, &s->temp.filtered, s->temp.size);\n\n\t\t \n\t\tif (s->ret == XZ_STREAM_END)\n\t\t\ts->temp.filtered = s->temp.size;\n\n\t\tbcj_flush(s, b);\n\t\tif (s->temp.filtered > 0)\n\t\t\treturn XZ_OK;\n\t}\n\n\treturn s->ret;\n}\n\nXZ_EXTERN struct xz_dec_bcj *xz_dec_bcj_create(bool single_call)\n{\n\tstruct xz_dec_bcj *s = kmalloc(sizeof(*s), GFP_KERNEL);\n\tif (s != NULL)\n\t\ts->single_call = single_call;\n\n\treturn s;\n}\n\nXZ_EXTERN enum xz_ret xz_dec_bcj_reset(struct xz_dec_bcj *s, uint8_t id)\n{\n\tswitch (id) {\n#ifdef XZ_DEC_X86\n\tcase BCJ_X86:\n#endif\n#ifdef XZ_DEC_POWERPC\n\tcase BCJ_POWERPC:\n#endif\n#ifdef XZ_DEC_IA64\n\tcase BCJ_IA64:\n#endif\n#ifdef XZ_DEC_ARM\n\tcase BCJ_ARM:\n#endif\n#ifdef XZ_DEC_ARMTHUMB\n\tcase BCJ_ARMTHUMB:\n#endif\n#ifdef XZ_DEC_SPARC\n\tcase BCJ_SPARC:\n#endif\n\t\tbreak;\n\n\tdefault:\n\t\t \n\t\treturn XZ_OPTIONS_ERROR;\n\t}\n\n\ts->type = id;\n\ts->ret = XZ_OK;\n\ts->pos = 0;\n\ts->x86_prev_mask = 0;\n\ts->temp.filtered = 0;\n\ts->temp.size = 0;\n\n\treturn XZ_OK;\n}\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}