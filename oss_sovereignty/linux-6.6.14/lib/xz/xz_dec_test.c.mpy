{
  "module_name": "xz_dec_test.c",
  "hash_id": "f0ea68db40df75a836409b076017c95f5b287d95e6844aaeb32a06ea18f81691",
  "original_prompt": "Ingested from linux-6.6.14/lib/xz/xz_dec_test.c",
  "human_readable_source": " \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/uaccess.h>\n#include <linux/crc32.h>\n#include <linux/xz.h>\n\n \n#define DICT_MAX (1 << 20)\n\n \n#define DEVICE_NAME \"xz_dec_test\"\n\n \nstatic int device_major;\n\n \nstatic bool device_is_open;\n\n \nstatic struct xz_dec *state;\n\n \nstatic enum xz_ret ret;\n\n \nstatic uint8_t buffer_in[1024];\nstatic uint8_t buffer_out[1024];\n\n \nstatic struct xz_buf buffers = {\n\t.in = buffer_in,\n\t.out = buffer_out,\n\t.out_size = sizeof(buffer_out)\n};\n\n \nstatic uint32_t crc;\n\nstatic int xz_dec_test_open(struct inode *i, struct file *f)\n{\n\tif (device_is_open)\n\t\treturn -EBUSY;\n\n\tdevice_is_open = true;\n\n\txz_dec_reset(state);\n\tret = XZ_OK;\n\tcrc = 0xFFFFFFFF;\n\n\tbuffers.in_pos = 0;\n\tbuffers.in_size = 0;\n\tbuffers.out_pos = 0;\n\n\tprintk(KERN_INFO DEVICE_NAME \": opened\\n\");\n\treturn 0;\n}\n\nstatic int xz_dec_test_release(struct inode *i, struct file *f)\n{\n\tdevice_is_open = false;\n\n\tif (ret == XZ_OK)\n\t\tprintk(KERN_INFO DEVICE_NAME \": input was truncated\\n\");\n\n\tprintk(KERN_INFO DEVICE_NAME \": closed\\n\");\n\treturn 0;\n}\n\n \nstatic ssize_t xz_dec_test_write(struct file *file, const char __user *buf,\n\t\t\t\t size_t size, loff_t *pos)\n{\n\tsize_t remaining;\n\n\tif (ret != XZ_OK) {\n\t\tif (size > 0)\n\t\t\tprintk(KERN_INFO DEVICE_NAME \": %zu bytes of \"\n\t\t\t\t\t\"garbage at the end of the file\\n\",\n\t\t\t\t\tsize);\n\n\t\treturn -ENOSPC;\n\t}\n\n\tprintk(KERN_INFO DEVICE_NAME \": decoding %zu bytes of input\\n\",\n\t\t\tsize);\n\n\tremaining = size;\n\twhile ((remaining > 0 || buffers.out_pos == buffers.out_size)\n\t\t\t&& ret == XZ_OK) {\n\t\tif (buffers.in_pos == buffers.in_size) {\n\t\t\tbuffers.in_pos = 0;\n\t\t\tbuffers.in_size = min(remaining, sizeof(buffer_in));\n\t\t\tif (copy_from_user(buffer_in, buf, buffers.in_size))\n\t\t\t\treturn -EFAULT;\n\n\t\t\tbuf += buffers.in_size;\n\t\t\tremaining -= buffers.in_size;\n\t\t}\n\n\t\tbuffers.out_pos = 0;\n\t\tret = xz_dec_run(state, &buffers);\n\t\tcrc = crc32(crc, buffer_out, buffers.out_pos);\n\t}\n\n\tswitch (ret) {\n\tcase XZ_OK:\n\t\tprintk(KERN_INFO DEVICE_NAME \": XZ_OK\\n\");\n\t\treturn size;\n\n\tcase XZ_STREAM_END:\n\t\tprintk(KERN_INFO DEVICE_NAME \": XZ_STREAM_END, \"\n\t\t\t\t\"CRC32 = 0x%08X\\n\", ~crc);\n\t\treturn size - remaining - (buffers.in_size - buffers.in_pos);\n\n\tcase XZ_MEMLIMIT_ERROR:\n\t\tprintk(KERN_INFO DEVICE_NAME \": XZ_MEMLIMIT_ERROR\\n\");\n\t\tbreak;\n\n\tcase XZ_FORMAT_ERROR:\n\t\tprintk(KERN_INFO DEVICE_NAME \": XZ_FORMAT_ERROR\\n\");\n\t\tbreak;\n\n\tcase XZ_OPTIONS_ERROR:\n\t\tprintk(KERN_INFO DEVICE_NAME \": XZ_OPTIONS_ERROR\\n\");\n\t\tbreak;\n\n\tcase XZ_DATA_ERROR:\n\t\tprintk(KERN_INFO DEVICE_NAME \": XZ_DATA_ERROR\\n\");\n\t\tbreak;\n\n\tcase XZ_BUF_ERROR:\n\t\tprintk(KERN_INFO DEVICE_NAME \": XZ_BUF_ERROR\\n\");\n\t\tbreak;\n\n\tdefault:\n\t\tprintk(KERN_INFO DEVICE_NAME \": Bug detected!\\n\");\n\t\tbreak;\n\t}\n\n\treturn -EIO;\n}\n\n \nstatic int __init xz_dec_test_init(void)\n{\n\tstatic const struct file_operations fileops = {\n\t\t.owner = THIS_MODULE,\n\t\t.open = &xz_dec_test_open,\n\t\t.release = &xz_dec_test_release,\n\t\t.write = &xz_dec_test_write\n\t};\n\n\tstate = xz_dec_init(XZ_PREALLOC, DICT_MAX);\n\tif (state == NULL)\n\t\treturn -ENOMEM;\n\n\tdevice_major = register_chrdev(0, DEVICE_NAME, &fileops);\n\tif (device_major < 0) {\n\t\txz_dec_end(state);\n\t\treturn device_major;\n\t}\n\n\tprintk(KERN_INFO DEVICE_NAME \": module loaded\\n\");\n\tprintk(KERN_INFO DEVICE_NAME \": Create a device node with \"\n\t\t\t\"'mknod \" DEVICE_NAME \" c %d 0' and write .xz files \"\n\t\t\t\"to it.\\n\", device_major);\n\treturn 0;\n}\n\nstatic void __exit xz_dec_test_exit(void)\n{\n\tunregister_chrdev(device_major, DEVICE_NAME);\n\txz_dec_end(state);\n\tprintk(KERN_INFO DEVICE_NAME \": module unloaded\\n\");\n}\n\nmodule_init(xz_dec_test_init);\nmodule_exit(xz_dec_test_exit);\n\nMODULE_DESCRIPTION(\"XZ decompressor tester\");\nMODULE_VERSION(\"1.0\");\nMODULE_AUTHOR(\"Lasse Collin <lasse.collin@tukaani.org>\");\n\n \nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}