{
  "module_name": "huf_decompress.c",
  "hash_id": "8f11ed84ccf4847ff6ec3aa1c8cb7733ff72ce0fa58568098d317d6f8d2c15b6",
  "original_prompt": "Ingested from linux-6.6.14/lib/zstd/decompress/huf_decompress.c",
  "human_readable_source": " \n\n \n#include \"../common/zstd_deps.h\"   \n#include \"../common/compiler.h\"\n#include \"../common/bitstream.h\"   \n#include \"../common/fse.h\"         \n#define HUF_STATIC_LINKING_ONLY\n#include \"../common/huf.h\"\n#include \"../common/error_private.h\"\n#include \"../common/zstd_internal.h\"\n\n \n\n#define HUF_DECODER_FAST_TABLELOG 11\n\n \n\n \n#if defined(HUF_FORCE_DECOMPRESS_X1) && \\\n    defined(HUF_FORCE_DECOMPRESS_X2)\n#error \"Cannot force the use of the X1 and X2 decoders at the same time!\"\n#endif\n\n#if ZSTD_ENABLE_ASM_X86_64_BMI2 && DYNAMIC_BMI2\n# define HUF_ASM_X86_64_BMI2_ATTRS BMI2_TARGET_ATTRIBUTE\n#else\n# define HUF_ASM_X86_64_BMI2_ATTRS\n#endif\n\n#define HUF_EXTERN_C\n#define HUF_ASM_DECL HUF_EXTERN_C\n\n#if DYNAMIC_BMI2 || (ZSTD_ENABLE_ASM_X86_64_BMI2 && defined(__BMI2__))\n# define HUF_NEED_BMI2_FUNCTION 1\n#else\n# define HUF_NEED_BMI2_FUNCTION 0\n#endif\n\n#if !(ZSTD_ENABLE_ASM_X86_64_BMI2 && defined(__BMI2__))\n# define HUF_NEED_DEFAULT_FUNCTION 1\n#else\n# define HUF_NEED_DEFAULT_FUNCTION 0\n#endif\n\n \n#define HUF_isError ERR_isError\n\n\n \n#define HUF_ALIGN(x, a)         HUF_ALIGN_MASK((x), (a) - 1)\n#define HUF_ALIGN_MASK(x, mask) (((x) + (mask)) & ~(mask))\n\n\n \n#if DYNAMIC_BMI2\n\n#define HUF_DGEN(fn)                                                        \\\n                                                                            \\\n    static size_t fn##_default(                                             \\\n                  void* dst,  size_t dstSize,                               \\\n            const void* cSrc, size_t cSrcSize,                              \\\n            const HUF_DTable* DTable)                                       \\\n    {                                                                       \\\n        return fn##_body(dst, dstSize, cSrc, cSrcSize, DTable);             \\\n    }                                                                       \\\n                                                                            \\\n    static BMI2_TARGET_ATTRIBUTE size_t fn##_bmi2(                          \\\n                  void* dst,  size_t dstSize,                               \\\n            const void* cSrc, size_t cSrcSize,                              \\\n            const HUF_DTable* DTable)                                       \\\n    {                                                                       \\\n        return fn##_body(dst, dstSize, cSrc, cSrcSize, DTable);             \\\n    }                                                                       \\\n                                                                            \\\n    static size_t fn(void* dst, size_t dstSize, void const* cSrc,           \\\n                     size_t cSrcSize, HUF_DTable const* DTable, int bmi2)   \\\n    {                                                                       \\\n        if (bmi2) {                                                         \\\n            return fn##_bmi2(dst, dstSize, cSrc, cSrcSize, DTable);         \\\n        }                                                                   \\\n        return fn##_default(dst, dstSize, cSrc, cSrcSize, DTable);          \\\n    }\n\n#else\n\n#define HUF_DGEN(fn)                                                        \\\n    static size_t fn(void* dst, size_t dstSize, void const* cSrc,           \\\n                     size_t cSrcSize, HUF_DTable const* DTable, int bmi2)   \\\n    {                                                                       \\\n        (void)bmi2;                                                         \\\n        return fn##_body(dst, dstSize, cSrc, cSrcSize, DTable);             \\\n    }\n\n#endif\n\n\n \n \n \ntypedef struct { BYTE maxTableLog; BYTE tableType; BYTE tableLog; BYTE reserved; } DTableDesc;\n\nstatic DTableDesc HUF_getDTableDesc(const HUF_DTable* table)\n{\n    DTableDesc dtd;\n    ZSTD_memcpy(&dtd, table, sizeof(dtd));\n    return dtd;\n}\n\n#if ZSTD_ENABLE_ASM_X86_64_BMI2\n\nstatic size_t HUF_initDStream(BYTE const* ip) {\n    BYTE const lastByte = ip[7];\n    size_t const bitsConsumed = lastByte ? 8 - BIT_highbit32(lastByte) : 0;\n    size_t const value = MEM_readLEST(ip) | 1;\n    assert(bitsConsumed <= 8);\n    return value << bitsConsumed;\n}\ntypedef struct {\n    BYTE const* ip[4];\n    BYTE* op[4];\n    U64 bits[4];\n    void const* dt;\n    BYTE const* ilimit;\n    BYTE* oend;\n    BYTE const* iend[4];\n} HUF_DecompressAsmArgs;\n\n \nstatic size_t HUF_DecompressAsmArgs_init(HUF_DecompressAsmArgs* args, void* dst, size_t dstSize, void const* src, size_t srcSize, const HUF_DTable* DTable)\n{\n    void const* dt = DTable + 1;\n    U32 const dtLog = HUF_getDTableDesc(DTable).tableLog;\n\n    const BYTE* const ilimit = (const BYTE*)src + 6 + 8;\n\n    BYTE* const oend = (BYTE*)dst + dstSize;\n\n     \n    if (!(MEM_isLittleEndian() && !MEM_32bits())) return 1;\n\n     \n    if (srcSize < 10)\n        return ERROR(corruption_detected);\n\n     \n    if (dtLog != HUF_DECODER_FAST_TABLELOG)\n        return 1;\n\n     \n    {\n        const BYTE* const istart = (const BYTE*)src;\n        size_t const length1 = MEM_readLE16(istart);\n        size_t const length2 = MEM_readLE16(istart+2);\n        size_t const length3 = MEM_readLE16(istart+4);\n        size_t const length4 = srcSize - (length1 + length2 + length3 + 6);\n        args->iend[0] = istart + 6;   \n        args->iend[1] = args->iend[0] + length1;\n        args->iend[2] = args->iend[1] + length2;\n        args->iend[3] = args->iend[2] + length3;\n\n         \n        if (length1 < 16 || length2 < 8 || length3 < 8 || length4 < 8)\n            return 1;\n        if (length4 > srcSize) return ERROR(corruption_detected);    \n    }\n     \n    args->ip[0] = args->iend[1] - sizeof(U64);\n    args->ip[1] = args->iend[2] - sizeof(U64);\n    args->ip[2] = args->iend[3] - sizeof(U64);\n    args->ip[3] = (BYTE const*)src + srcSize - sizeof(U64);\n\n     \n    args->op[0] = (BYTE*)dst;\n    args->op[1] = args->op[0] + (dstSize+3)/4;\n    args->op[2] = args->op[1] + (dstSize+3)/4;\n    args->op[3] = args->op[2] + (dstSize+3)/4;\n\n     \n    if (args->op[3] >= oend)\n        return 1;\n\n     \n    args->bits[0] = HUF_initDStream(args->ip[0]);\n    args->bits[1] = HUF_initDStream(args->ip[1]);\n    args->bits[2] = HUF_initDStream(args->ip[2]);\n    args->bits[3] = HUF_initDStream(args->ip[3]);\n\n     \n    args->ilimit = ilimit;\n\n    args->oend = oend;\n    args->dt = dt;\n\n    return 0;\n}\n\nstatic size_t HUF_initRemainingDStream(BIT_DStream_t* bit, HUF_DecompressAsmArgs const* args, int stream, BYTE* segmentEnd)\n{\n     \n    if (args->op[stream] > segmentEnd)\n        return ERROR(corruption_detected);\n     \n    if (args->ip[stream] < args->iend[stream] - 8)\n        return ERROR(corruption_detected);\n\n     \n    bit->bitContainer = MEM_readLE64(args->ip[stream]);\n    bit->bitsConsumed = ZSTD_countTrailingZeros((size_t)args->bits[stream]);\n    bit->start = (const char*)args->iend[0];\n    bit->limitPtr = bit->start + sizeof(size_t);\n    bit->ptr = (const char*)args->ip[stream];\n\n    return 0;\n}\n#endif\n\n\n#ifndef HUF_FORCE_DECOMPRESS_X2\n\n \n \n \ntypedef struct { BYTE nbBits; BYTE byte; } HUF_DEltX1;    \n\n \nstatic U64 HUF_DEltX1_set4(BYTE symbol, BYTE nbBits) {\n    U64 D4;\n    if (MEM_isLittleEndian()) {\n        D4 = (symbol << 8) + nbBits;\n    } else {\n        D4 = symbol + (nbBits << 8);\n    }\n    D4 *= 0x0001000100010001ULL;\n    return D4;\n}\n\n \nstatic U32 HUF_rescaleStats(BYTE* huffWeight, U32* rankVal, U32 nbSymbols, U32 tableLog, U32 targetTableLog)\n{\n    if (tableLog > targetTableLog)\n        return tableLog;\n    if (tableLog < targetTableLog) {\n        U32 const scale = targetTableLog - tableLog;\n        U32 s;\n         \n        for (s = 0; s < nbSymbols; ++s) {\n            huffWeight[s] += (BYTE)((huffWeight[s] == 0) ? 0 : scale);\n        }\n         \n        for (s = targetTableLog; s > scale; --s) {\n            rankVal[s] = rankVal[s - scale];\n        }\n        for (s = scale; s > 0; --s) {\n            rankVal[s] = 0;\n        }\n    }\n    return targetTableLog;\n}\n\ntypedef struct {\n        U32 rankVal[HUF_TABLELOG_ABSOLUTEMAX + 1];\n        U32 rankStart[HUF_TABLELOG_ABSOLUTEMAX + 1];\n        U32 statsWksp[HUF_READ_STATS_WORKSPACE_SIZE_U32];\n        BYTE symbols[HUF_SYMBOLVALUE_MAX + 1];\n        BYTE huffWeight[HUF_SYMBOLVALUE_MAX + 1];\n} HUF_ReadDTableX1_Workspace;\n\n\nsize_t HUF_readDTableX1_wksp(HUF_DTable* DTable, const void* src, size_t srcSize, void* workSpace, size_t wkspSize)\n{\n    return HUF_readDTableX1_wksp_bmi2(DTable, src, srcSize, workSpace, wkspSize,   0);\n}\n\nsize_t HUF_readDTableX1_wksp_bmi2(HUF_DTable* DTable, const void* src, size_t srcSize, void* workSpace, size_t wkspSize, int bmi2)\n{\n    U32 tableLog = 0;\n    U32 nbSymbols = 0;\n    size_t iSize;\n    void* const dtPtr = DTable + 1;\n    HUF_DEltX1* const dt = (HUF_DEltX1*)dtPtr;\n    HUF_ReadDTableX1_Workspace* wksp = (HUF_ReadDTableX1_Workspace*)workSpace;\n\n    DEBUG_STATIC_ASSERT(HUF_DECOMPRESS_WORKSPACE_SIZE >= sizeof(*wksp));\n    if (sizeof(*wksp) > wkspSize) return ERROR(tableLog_tooLarge);\n\n    DEBUG_STATIC_ASSERT(sizeof(DTableDesc) == sizeof(HUF_DTable));\n         \n\n    iSize = HUF_readStats_wksp(wksp->huffWeight, HUF_SYMBOLVALUE_MAX + 1, wksp->rankVal, &nbSymbols, &tableLog, src, srcSize, wksp->statsWksp, sizeof(wksp->statsWksp), bmi2);\n    if (HUF_isError(iSize)) return iSize;\n\n\n     \n    {   DTableDesc dtd = HUF_getDTableDesc(DTable);\n        U32 const maxTableLog = dtd.maxTableLog + 1;\n        U32 const targetTableLog = MIN(maxTableLog, HUF_DECODER_FAST_TABLELOG);\n        tableLog = HUF_rescaleStats(wksp->huffWeight, wksp->rankVal, nbSymbols, tableLog, targetTableLog);\n        if (tableLog > (U32)(dtd.maxTableLog+1)) return ERROR(tableLog_tooLarge);    \n        dtd.tableType = 0;\n        dtd.tableLog = (BYTE)tableLog;\n        ZSTD_memcpy(DTable, &dtd, sizeof(dtd));\n    }\n\n     \n    {\n        int n;\n        int nextRankStart = 0;\n        int const unroll = 4;\n        int const nLimit = (int)nbSymbols - unroll + 1;\n        for (n=0; n<(int)tableLog+1; n++) {\n            U32 const curr = nextRankStart;\n            nextRankStart += wksp->rankVal[n];\n            wksp->rankStart[n] = curr;\n        }\n        for (n=0; n < nLimit; n += unroll) {\n            int u;\n            for (u=0; u < unroll; ++u) {\n                size_t const w = wksp->huffWeight[n+u];\n                wksp->symbols[wksp->rankStart[w]++] = (BYTE)(n+u);\n            }\n        }\n        for (; n < (int)nbSymbols; ++n) {\n            size_t const w = wksp->huffWeight[n];\n            wksp->symbols[wksp->rankStart[w]++] = (BYTE)n;\n        }\n    }\n\n     \n    {\n        U32 w;\n        int symbol=wksp->rankVal[0];\n        int rankStart=0;\n        for (w=1; w<tableLog+1; ++w) {\n            int const symbolCount = wksp->rankVal[w];\n            int const length = (1 << w) >> 1;\n            int uStart = rankStart;\n            BYTE const nbBits = (BYTE)(tableLog + 1 - w);\n            int s;\n            int u;\n            switch (length) {\n            case 1:\n                for (s=0; s<symbolCount; ++s) {\n                    HUF_DEltX1 D;\n                    D.byte = wksp->symbols[symbol + s];\n                    D.nbBits = nbBits;\n                    dt[uStart] = D;\n                    uStart += 1;\n                }\n                break;\n            case 2:\n                for (s=0; s<symbolCount; ++s) {\n                    HUF_DEltX1 D;\n                    D.byte = wksp->symbols[symbol + s];\n                    D.nbBits = nbBits;\n                    dt[uStart+0] = D;\n                    dt[uStart+1] = D;\n                    uStart += 2;\n                }\n                break;\n            case 4:\n                for (s=0; s<symbolCount; ++s) {\n                    U64 const D4 = HUF_DEltX1_set4(wksp->symbols[symbol + s], nbBits);\n                    MEM_write64(dt + uStart, D4);\n                    uStart += 4;\n                }\n                break;\n            case 8:\n                for (s=0; s<symbolCount; ++s) {\n                    U64 const D4 = HUF_DEltX1_set4(wksp->symbols[symbol + s], nbBits);\n                    MEM_write64(dt + uStart, D4);\n                    MEM_write64(dt + uStart + 4, D4);\n                    uStart += 8;\n                }\n                break;\n            default:\n                for (s=0; s<symbolCount; ++s) {\n                    U64 const D4 = HUF_DEltX1_set4(wksp->symbols[symbol + s], nbBits);\n                    for (u=0; u < length; u += 16) {\n                        MEM_write64(dt + uStart + u + 0, D4);\n                        MEM_write64(dt + uStart + u + 4, D4);\n                        MEM_write64(dt + uStart + u + 8, D4);\n                        MEM_write64(dt + uStart + u + 12, D4);\n                    }\n                    assert(u == length);\n                    uStart += length;\n                }\n                break;\n            }\n            symbol += symbolCount;\n            rankStart += symbolCount * length;\n        }\n    }\n    return iSize;\n}\n\nFORCE_INLINE_TEMPLATE BYTE\nHUF_decodeSymbolX1(BIT_DStream_t* Dstream, const HUF_DEltX1* dt, const U32 dtLog)\n{\n    size_t const val = BIT_lookBitsFast(Dstream, dtLog);  \n    BYTE const c = dt[val].byte;\n    BIT_skipBits(Dstream, dt[val].nbBits);\n    return c;\n}\n\n#define HUF_DECODE_SYMBOLX1_0(ptr, DStreamPtr) \\\n    *ptr++ = HUF_decodeSymbolX1(DStreamPtr, dt, dtLog)\n\n#define HUF_DECODE_SYMBOLX1_1(ptr, DStreamPtr)  \\\n    if (MEM_64bits() || (HUF_TABLELOG_MAX<=12)) \\\n        HUF_DECODE_SYMBOLX1_0(ptr, DStreamPtr)\n\n#define HUF_DECODE_SYMBOLX1_2(ptr, DStreamPtr) \\\n    if (MEM_64bits()) \\\n        HUF_DECODE_SYMBOLX1_0(ptr, DStreamPtr)\n\nHINT_INLINE size_t\nHUF_decodeStreamX1(BYTE* p, BIT_DStream_t* const bitDPtr, BYTE* const pEnd, const HUF_DEltX1* const dt, const U32 dtLog)\n{\n    BYTE* const pStart = p;\n\n     \n    if ((pEnd - p) > 3) {\n        while ((BIT_reloadDStream(bitDPtr) == BIT_DStream_unfinished) & (p < pEnd-3)) {\n            HUF_DECODE_SYMBOLX1_2(p, bitDPtr);\n            HUF_DECODE_SYMBOLX1_1(p, bitDPtr);\n            HUF_DECODE_SYMBOLX1_2(p, bitDPtr);\n            HUF_DECODE_SYMBOLX1_0(p, bitDPtr);\n        }\n    } else {\n        BIT_reloadDStream(bitDPtr);\n    }\n\n     \n    if (MEM_32bits())\n        while ((BIT_reloadDStream(bitDPtr) == BIT_DStream_unfinished) & (p < pEnd))\n            HUF_DECODE_SYMBOLX1_0(p, bitDPtr);\n\n     \n    while (p < pEnd)\n        HUF_DECODE_SYMBOLX1_0(p, bitDPtr);\n\n    return pEnd-pStart;\n}\n\nFORCE_INLINE_TEMPLATE size_t\nHUF_decompress1X1_usingDTable_internal_body(\n          void* dst,  size_t dstSize,\n    const void* cSrc, size_t cSrcSize,\n    const HUF_DTable* DTable)\n{\n    BYTE* op = (BYTE*)dst;\n    BYTE* const oend = op + dstSize;\n    const void* dtPtr = DTable + 1;\n    const HUF_DEltX1* const dt = (const HUF_DEltX1*)dtPtr;\n    BIT_DStream_t bitD;\n    DTableDesc const dtd = HUF_getDTableDesc(DTable);\n    U32 const dtLog = dtd.tableLog;\n\n    CHECK_F( BIT_initDStream(&bitD, cSrc, cSrcSize) );\n\n    HUF_decodeStreamX1(op, &bitD, oend, dt, dtLog);\n\n    if (!BIT_endOfDStream(&bitD)) return ERROR(corruption_detected);\n\n    return dstSize;\n}\n\nFORCE_INLINE_TEMPLATE size_t\nHUF_decompress4X1_usingDTable_internal_body(\n          void* dst,  size_t dstSize,\n    const void* cSrc, size_t cSrcSize,\n    const HUF_DTable* DTable)\n{\n     \n    if (cSrcSize < 10) return ERROR(corruption_detected);   \n\n    {   const BYTE* const istart = (const BYTE*) cSrc;\n        BYTE* const ostart = (BYTE*) dst;\n        BYTE* const oend = ostart + dstSize;\n        BYTE* const olimit = oend - 3;\n        const void* const dtPtr = DTable + 1;\n        const HUF_DEltX1* const dt = (const HUF_DEltX1*)dtPtr;\n\n         \n        BIT_DStream_t bitD1;\n        BIT_DStream_t bitD2;\n        BIT_DStream_t bitD3;\n        BIT_DStream_t bitD4;\n        size_t const length1 = MEM_readLE16(istart);\n        size_t const length2 = MEM_readLE16(istart+2);\n        size_t const length3 = MEM_readLE16(istart+4);\n        size_t const length4 = cSrcSize - (length1 + length2 + length3 + 6);\n        const BYTE* const istart1 = istart + 6;   \n        const BYTE* const istart2 = istart1 + length1;\n        const BYTE* const istart3 = istart2 + length2;\n        const BYTE* const istart4 = istart3 + length3;\n        const size_t segmentSize = (dstSize+3) / 4;\n        BYTE* const opStart2 = ostart + segmentSize;\n        BYTE* const opStart3 = opStart2 + segmentSize;\n        BYTE* const opStart4 = opStart3 + segmentSize;\n        BYTE* op1 = ostart;\n        BYTE* op2 = opStart2;\n        BYTE* op3 = opStart3;\n        BYTE* op4 = opStart4;\n        DTableDesc const dtd = HUF_getDTableDesc(DTable);\n        U32 const dtLog = dtd.tableLog;\n        U32 endSignal = 1;\n\n        if (length4 > cSrcSize) return ERROR(corruption_detected);    \n        if (opStart4 > oend) return ERROR(corruption_detected);       \n        CHECK_F( BIT_initDStream(&bitD1, istart1, length1) );\n        CHECK_F( BIT_initDStream(&bitD2, istart2, length2) );\n        CHECK_F( BIT_initDStream(&bitD3, istart3, length3) );\n        CHECK_F( BIT_initDStream(&bitD4, istart4, length4) );\n\n         \n        if ((size_t)(oend - op4) >= sizeof(size_t)) {\n            for ( ; (endSignal) & (op4 < olimit) ; ) {\n                HUF_DECODE_SYMBOLX1_2(op1, &bitD1);\n                HUF_DECODE_SYMBOLX1_2(op2, &bitD2);\n                HUF_DECODE_SYMBOLX1_2(op3, &bitD3);\n                HUF_DECODE_SYMBOLX1_2(op4, &bitD4);\n                HUF_DECODE_SYMBOLX1_1(op1, &bitD1);\n                HUF_DECODE_SYMBOLX1_1(op2, &bitD2);\n                HUF_DECODE_SYMBOLX1_1(op3, &bitD3);\n                HUF_DECODE_SYMBOLX1_1(op4, &bitD4);\n                HUF_DECODE_SYMBOLX1_2(op1, &bitD1);\n                HUF_DECODE_SYMBOLX1_2(op2, &bitD2);\n                HUF_DECODE_SYMBOLX1_2(op3, &bitD3);\n                HUF_DECODE_SYMBOLX1_2(op4, &bitD4);\n                HUF_DECODE_SYMBOLX1_0(op1, &bitD1);\n                HUF_DECODE_SYMBOLX1_0(op2, &bitD2);\n                HUF_DECODE_SYMBOLX1_0(op3, &bitD3);\n                HUF_DECODE_SYMBOLX1_0(op4, &bitD4);\n                endSignal &= BIT_reloadDStreamFast(&bitD1) == BIT_DStream_unfinished;\n                endSignal &= BIT_reloadDStreamFast(&bitD2) == BIT_DStream_unfinished;\n                endSignal &= BIT_reloadDStreamFast(&bitD3) == BIT_DStream_unfinished;\n                endSignal &= BIT_reloadDStreamFast(&bitD4) == BIT_DStream_unfinished;\n            }\n        }\n\n         \n         \n        if (op1 > opStart2) return ERROR(corruption_detected);\n        if (op2 > opStart3) return ERROR(corruption_detected);\n        if (op3 > opStart4) return ERROR(corruption_detected);\n         \n\n         \n        HUF_decodeStreamX1(op1, &bitD1, opStart2, dt, dtLog);\n        HUF_decodeStreamX1(op2, &bitD2, opStart3, dt, dtLog);\n        HUF_decodeStreamX1(op3, &bitD3, opStart4, dt, dtLog);\n        HUF_decodeStreamX1(op4, &bitD4, oend,     dt, dtLog);\n\n         \n        { U32 const endCheck = BIT_endOfDStream(&bitD1) & BIT_endOfDStream(&bitD2) & BIT_endOfDStream(&bitD3) & BIT_endOfDStream(&bitD4);\n          if (!endCheck) return ERROR(corruption_detected); }\n\n         \n        return dstSize;\n    }\n}\n\n#if HUF_NEED_BMI2_FUNCTION\nstatic BMI2_TARGET_ATTRIBUTE\nsize_t HUF_decompress4X1_usingDTable_internal_bmi2(void* dst, size_t dstSize, void const* cSrc,\n                    size_t cSrcSize, HUF_DTable const* DTable) {\n    return HUF_decompress4X1_usingDTable_internal_body(dst, dstSize, cSrc, cSrcSize, DTable);\n}\n#endif\n\n#if HUF_NEED_DEFAULT_FUNCTION\nstatic\nsize_t HUF_decompress4X1_usingDTable_internal_default(void* dst, size_t dstSize, void const* cSrc,\n                    size_t cSrcSize, HUF_DTable const* DTable) {\n    return HUF_decompress4X1_usingDTable_internal_body(dst, dstSize, cSrc, cSrcSize, DTable);\n}\n#endif\n\n#if ZSTD_ENABLE_ASM_X86_64_BMI2\n\nHUF_ASM_DECL void HUF_decompress4X1_usingDTable_internal_bmi2_asm_loop(HUF_DecompressAsmArgs* args) ZSTDLIB_HIDDEN;\n\nstatic HUF_ASM_X86_64_BMI2_ATTRS\nsize_t\nHUF_decompress4X1_usingDTable_internal_bmi2_asm(\n          void* dst,  size_t dstSize,\n    const void* cSrc, size_t cSrcSize,\n    const HUF_DTable* DTable)\n{\n    void const* dt = DTable + 1;\n    const BYTE* const iend = (const BYTE*)cSrc + 6;\n    BYTE* const oend = (BYTE*)dst + dstSize;\n    HUF_DecompressAsmArgs args;\n    {\n        size_t const ret = HUF_DecompressAsmArgs_init(&args, dst, dstSize, cSrc, cSrcSize, DTable);\n        FORWARD_IF_ERROR(ret, \"Failed to init asm args\");\n        if (ret != 0)\n            return HUF_decompress4X1_usingDTable_internal_bmi2(dst, dstSize, cSrc, cSrcSize, DTable);\n    }\n\n    assert(args.ip[0] >= args.ilimit);\n    HUF_decompress4X1_usingDTable_internal_bmi2_asm_loop(&args);\n\n     \n    assert(args.ip[0] >= iend);\n    assert(args.ip[1] >= iend);\n    assert(args.ip[2] >= iend);\n    assert(args.ip[3] >= iend);\n    assert(args.op[3] <= oend);\n    (void)iend;\n\n     \n    {\n        size_t const segmentSize = (dstSize+3) / 4;\n        BYTE* segmentEnd = (BYTE*)dst;\n        int i;\n        for (i = 0; i < 4; ++i) {\n            BIT_DStream_t bit;\n            if (segmentSize <= (size_t)(oend - segmentEnd))\n                segmentEnd += segmentSize;\n            else\n                segmentEnd = oend;\n            FORWARD_IF_ERROR(HUF_initRemainingDStream(&bit, &args, i, segmentEnd), \"corruption\");\n             \n            args.op[i] += HUF_decodeStreamX1(args.op[i], &bit, segmentEnd, (HUF_DEltX1 const*)dt, HUF_DECODER_FAST_TABLELOG);\n            if (args.op[i] != segmentEnd) return ERROR(corruption_detected);\n        }\n    }\n\n     \n    return dstSize;\n}\n#endif  \n\ntypedef size_t (*HUF_decompress_usingDTable_t)(void *dst, size_t dstSize,\n                                               const void *cSrc,\n                                               size_t cSrcSize,\n                                               const HUF_DTable *DTable);\n\nHUF_DGEN(HUF_decompress1X1_usingDTable_internal)\n\nstatic size_t HUF_decompress4X1_usingDTable_internal(void* dst, size_t dstSize, void const* cSrc,\n                    size_t cSrcSize, HUF_DTable const* DTable, int bmi2)\n{\n#if DYNAMIC_BMI2\n    if (bmi2) {\n# if ZSTD_ENABLE_ASM_X86_64_BMI2\n        return HUF_decompress4X1_usingDTable_internal_bmi2_asm(dst, dstSize, cSrc, cSrcSize, DTable);\n# else\n        return HUF_decompress4X1_usingDTable_internal_bmi2(dst, dstSize, cSrc, cSrcSize, DTable);\n# endif\n    }\n#else\n    (void)bmi2;\n#endif\n\n#if ZSTD_ENABLE_ASM_X86_64_BMI2 && defined(__BMI2__)\n    return HUF_decompress4X1_usingDTable_internal_bmi2_asm(dst, dstSize, cSrc, cSrcSize, DTable);\n#else\n    return HUF_decompress4X1_usingDTable_internal_default(dst, dstSize, cSrc, cSrcSize, DTable);\n#endif\n}\n\n\nsize_t HUF_decompress1X1_usingDTable(\n          void* dst,  size_t dstSize,\n    const void* cSrc, size_t cSrcSize,\n    const HUF_DTable* DTable)\n{\n    DTableDesc dtd = HUF_getDTableDesc(DTable);\n    if (dtd.tableType != 0) return ERROR(GENERIC);\n    return HUF_decompress1X1_usingDTable_internal(dst, dstSize, cSrc, cSrcSize, DTable,   0);\n}\n\nsize_t HUF_decompress1X1_DCtx_wksp(HUF_DTable* DCtx, void* dst, size_t dstSize,\n                                   const void* cSrc, size_t cSrcSize,\n                                   void* workSpace, size_t wkspSize)\n{\n    const BYTE* ip = (const BYTE*) cSrc;\n\n    size_t const hSize = HUF_readDTableX1_wksp(DCtx, cSrc, cSrcSize, workSpace, wkspSize);\n    if (HUF_isError(hSize)) return hSize;\n    if (hSize >= cSrcSize) return ERROR(srcSize_wrong);\n    ip += hSize; cSrcSize -= hSize;\n\n    return HUF_decompress1X1_usingDTable_internal(dst, dstSize, ip, cSrcSize, DCtx,   0);\n}\n\n\nsize_t HUF_decompress4X1_usingDTable(\n          void* dst,  size_t dstSize,\n    const void* cSrc, size_t cSrcSize,\n    const HUF_DTable* DTable)\n{\n    DTableDesc dtd = HUF_getDTableDesc(DTable);\n    if (dtd.tableType != 0) return ERROR(GENERIC);\n    return HUF_decompress4X1_usingDTable_internal(dst, dstSize, cSrc, cSrcSize, DTable,   0);\n}\n\nstatic size_t HUF_decompress4X1_DCtx_wksp_bmi2(HUF_DTable* dctx, void* dst, size_t dstSize,\n                                   const void* cSrc, size_t cSrcSize,\n                                   void* workSpace, size_t wkspSize, int bmi2)\n{\n    const BYTE* ip = (const BYTE*) cSrc;\n\n    size_t const hSize = HUF_readDTableX1_wksp_bmi2(dctx, cSrc, cSrcSize, workSpace, wkspSize, bmi2);\n    if (HUF_isError(hSize)) return hSize;\n    if (hSize >= cSrcSize) return ERROR(srcSize_wrong);\n    ip += hSize; cSrcSize -= hSize;\n\n    return HUF_decompress4X1_usingDTable_internal(dst, dstSize, ip, cSrcSize, dctx, bmi2);\n}\n\nsize_t HUF_decompress4X1_DCtx_wksp(HUF_DTable* dctx, void* dst, size_t dstSize,\n                                   const void* cSrc, size_t cSrcSize,\n                                   void* workSpace, size_t wkspSize)\n{\n    return HUF_decompress4X1_DCtx_wksp_bmi2(dctx, dst, dstSize, cSrc, cSrcSize, workSpace, wkspSize, 0);\n}\n\n\n#endif  \n\n\n#ifndef HUF_FORCE_DECOMPRESS_X1\n\n \n \n \n\ntypedef struct { U16 sequence; BYTE nbBits; BYTE length; } HUF_DEltX2;   \ntypedef struct { BYTE symbol; } sortedSymbol_t;\ntypedef U32 rankValCol_t[HUF_TABLELOG_MAX + 1];\ntypedef rankValCol_t rankVal_t[HUF_TABLELOG_MAX];\n\n \nstatic U32 HUF_buildDEltX2U32(U32 symbol, U32 nbBits, U32 baseSeq, int level)\n{\n    U32 seq;\n    DEBUG_STATIC_ASSERT(offsetof(HUF_DEltX2, sequence) == 0);\n    DEBUG_STATIC_ASSERT(offsetof(HUF_DEltX2, nbBits) == 2);\n    DEBUG_STATIC_ASSERT(offsetof(HUF_DEltX2, length) == 3);\n    DEBUG_STATIC_ASSERT(sizeof(HUF_DEltX2) == sizeof(U32));\n    if (MEM_isLittleEndian()) {\n        seq = level == 1 ? symbol : (baseSeq + (symbol << 8));\n        return seq + (nbBits << 16) + ((U32)level << 24);\n    } else {\n        seq = level == 1 ? (symbol << 8) : ((baseSeq << 8) + symbol);\n        return (seq << 16) + (nbBits << 8) + (U32)level;\n    }\n}\n\n \nstatic HUF_DEltX2 HUF_buildDEltX2(U32 symbol, U32 nbBits, U32 baseSeq, int level)\n{\n    HUF_DEltX2 DElt;\n    U32 const val = HUF_buildDEltX2U32(symbol, nbBits, baseSeq, level);\n    DEBUG_STATIC_ASSERT(sizeof(DElt) == sizeof(val));\n    ZSTD_memcpy(&DElt, &val, sizeof(val));\n    return DElt;\n}\n\n \nstatic U64 HUF_buildDEltX2U64(U32 symbol, U32 nbBits, U16 baseSeq, int level)\n{\n    U32 DElt = HUF_buildDEltX2U32(symbol, nbBits, baseSeq, level);\n    return (U64)DElt + ((U64)DElt << 32);\n}\n\n \nstatic void HUF_fillDTableX2ForWeight(\n    HUF_DEltX2* DTableRank,\n    sortedSymbol_t const* begin, sortedSymbol_t const* end,\n    U32 nbBits, U32 tableLog,\n    U16 baseSeq, int const level)\n{\n    U32 const length = 1U << ((tableLog - nbBits) & 0x1F  );\n    const sortedSymbol_t* ptr;\n    assert(level >= 1 && level <= 2);\n    switch (length) {\n    case 1:\n        for (ptr = begin; ptr != end; ++ptr) {\n            HUF_DEltX2 const DElt = HUF_buildDEltX2(ptr->symbol, nbBits, baseSeq, level);\n            *DTableRank++ = DElt;\n        }\n        break;\n    case 2:\n        for (ptr = begin; ptr != end; ++ptr) {\n            HUF_DEltX2 const DElt = HUF_buildDEltX2(ptr->symbol, nbBits, baseSeq, level);\n            DTableRank[0] = DElt;\n            DTableRank[1] = DElt;\n            DTableRank += 2;\n        }\n        break;\n    case 4:\n        for (ptr = begin; ptr != end; ++ptr) {\n            U64 const DEltX2 = HUF_buildDEltX2U64(ptr->symbol, nbBits, baseSeq, level);\n            ZSTD_memcpy(DTableRank + 0, &DEltX2, sizeof(DEltX2));\n            ZSTD_memcpy(DTableRank + 2, &DEltX2, sizeof(DEltX2));\n            DTableRank += 4;\n        }\n        break;\n    case 8:\n        for (ptr = begin; ptr != end; ++ptr) {\n            U64 const DEltX2 = HUF_buildDEltX2U64(ptr->symbol, nbBits, baseSeq, level);\n            ZSTD_memcpy(DTableRank + 0, &DEltX2, sizeof(DEltX2));\n            ZSTD_memcpy(DTableRank + 2, &DEltX2, sizeof(DEltX2));\n            ZSTD_memcpy(DTableRank + 4, &DEltX2, sizeof(DEltX2));\n            ZSTD_memcpy(DTableRank + 6, &DEltX2, sizeof(DEltX2));\n            DTableRank += 8;\n        }\n        break;\n    default:\n        for (ptr = begin; ptr != end; ++ptr) {\n            U64 const DEltX2 = HUF_buildDEltX2U64(ptr->symbol, nbBits, baseSeq, level);\n            HUF_DEltX2* const DTableRankEnd = DTableRank + length;\n            for (; DTableRank != DTableRankEnd; DTableRank += 8) {\n                ZSTD_memcpy(DTableRank + 0, &DEltX2, sizeof(DEltX2));\n                ZSTD_memcpy(DTableRank + 2, &DEltX2, sizeof(DEltX2));\n                ZSTD_memcpy(DTableRank + 4, &DEltX2, sizeof(DEltX2));\n                ZSTD_memcpy(DTableRank + 6, &DEltX2, sizeof(DEltX2));\n            }\n        }\n        break;\n    }\n}\n\n \nstatic void HUF_fillDTableX2Level2(HUF_DEltX2* DTable, U32 targetLog, const U32 consumedBits,\n                           const U32* rankVal, const int minWeight, const int maxWeight1,\n                           const sortedSymbol_t* sortedSymbols, U32 const* rankStart,\n                           U32 nbBitsBaseline, U16 baseSeq)\n{\n     \n    if (minWeight>1) {\n        U32 const length = 1U << ((targetLog - consumedBits) & 0x1F  );\n        U64 const DEltX2 = HUF_buildDEltX2U64(baseSeq, consumedBits,   0,   1);\n        int const skipSize = rankVal[minWeight];\n        assert(length > 1);\n        assert((U32)skipSize < length);\n        switch (length) {\n        case 2:\n            assert(skipSize == 1);\n            ZSTD_memcpy(DTable, &DEltX2, sizeof(DEltX2));\n            break;\n        case 4:\n            assert(skipSize <= 4);\n            ZSTD_memcpy(DTable + 0, &DEltX2, sizeof(DEltX2));\n            ZSTD_memcpy(DTable + 2, &DEltX2, sizeof(DEltX2));\n            break;\n        default:\n            {\n                int i;\n                for (i = 0; i < skipSize; i += 8) {\n                    ZSTD_memcpy(DTable + i + 0, &DEltX2, sizeof(DEltX2));\n                    ZSTD_memcpy(DTable + i + 2, &DEltX2, sizeof(DEltX2));\n                    ZSTD_memcpy(DTable + i + 4, &DEltX2, sizeof(DEltX2));\n                    ZSTD_memcpy(DTable + i + 6, &DEltX2, sizeof(DEltX2));\n                }\n            }\n        }\n    }\n\n     \n    {\n        int w;\n        for (w = minWeight; w < maxWeight1; ++w) {\n            int const begin = rankStart[w];\n            int const end = rankStart[w+1];\n            U32 const nbBits = nbBitsBaseline - w;\n            U32 const totalBits = nbBits + consumedBits;\n            HUF_fillDTableX2ForWeight(\n                DTable + rankVal[w],\n                sortedSymbols + begin, sortedSymbols + end,\n                totalBits, targetLog,\n                baseSeq,   2);\n        }\n    }\n}\n\nstatic void HUF_fillDTableX2(HUF_DEltX2* DTable, const U32 targetLog,\n                           const sortedSymbol_t* sortedList,\n                           const U32* rankStart, rankValCol_t *rankValOrigin, const U32 maxWeight,\n                           const U32 nbBitsBaseline)\n{\n    U32* const rankVal = rankValOrigin[0];\n    const int scaleLog = nbBitsBaseline - targetLog;    \n    const U32 minBits  = nbBitsBaseline - maxWeight;\n    int w;\n    int const wEnd = (int)maxWeight + 1;\n\n     \n    for (w = 1; w < wEnd; ++w) {\n        int const begin = (int)rankStart[w];\n        int const end = (int)rankStart[w+1];\n        U32 const nbBits = nbBitsBaseline - w;\n\n        if (targetLog-nbBits >= minBits) {\n             \n            int start = rankVal[w];\n            U32 const length = 1U << ((targetLog - nbBits) & 0x1F  );\n            int minWeight = nbBits + scaleLog;\n            int s;\n            if (minWeight < 1) minWeight = 1;\n             \n            for (s = begin; s != end; ++s) {\n                HUF_fillDTableX2Level2(\n                    DTable + start, targetLog, nbBits,\n                    rankValOrigin[nbBits], minWeight, wEnd,\n                    sortedList, rankStart,\n                    nbBitsBaseline, sortedList[s].symbol);\n                start += length;\n            }\n        } else {\n             \n            HUF_fillDTableX2ForWeight(\n                DTable + rankVal[w],\n                sortedList + begin, sortedList + end,\n                nbBits, targetLog,\n                  0,   1);\n        }\n    }\n}\n\ntypedef struct {\n    rankValCol_t rankVal[HUF_TABLELOG_MAX];\n    U32 rankStats[HUF_TABLELOG_MAX + 1];\n    U32 rankStart0[HUF_TABLELOG_MAX + 3];\n    sortedSymbol_t sortedSymbol[HUF_SYMBOLVALUE_MAX + 1];\n    BYTE weightList[HUF_SYMBOLVALUE_MAX + 1];\n    U32 calleeWksp[HUF_READ_STATS_WORKSPACE_SIZE_U32];\n} HUF_ReadDTableX2_Workspace;\n\nsize_t HUF_readDTableX2_wksp(HUF_DTable* DTable,\n                       const void* src, size_t srcSize,\n                             void* workSpace, size_t wkspSize)\n{\n    return HUF_readDTableX2_wksp_bmi2(DTable, src, srcSize, workSpace, wkspSize,   0);\n}\n\nsize_t HUF_readDTableX2_wksp_bmi2(HUF_DTable* DTable,\n                       const void* src, size_t srcSize,\n                             void* workSpace, size_t wkspSize, int bmi2)\n{\n    U32 tableLog, maxW, nbSymbols;\n    DTableDesc dtd = HUF_getDTableDesc(DTable);\n    U32 maxTableLog = dtd.maxTableLog;\n    size_t iSize;\n    void* dtPtr = DTable+1;    \n    HUF_DEltX2* const dt = (HUF_DEltX2*)dtPtr;\n    U32 *rankStart;\n\n    HUF_ReadDTableX2_Workspace* const wksp = (HUF_ReadDTableX2_Workspace*)workSpace;\n\n    if (sizeof(*wksp) > wkspSize) return ERROR(GENERIC);\n\n    rankStart = wksp->rankStart0 + 1;\n    ZSTD_memset(wksp->rankStats, 0, sizeof(wksp->rankStats));\n    ZSTD_memset(wksp->rankStart0, 0, sizeof(wksp->rankStart0));\n\n    DEBUG_STATIC_ASSERT(sizeof(HUF_DEltX2) == sizeof(HUF_DTable));    \n    if (maxTableLog > HUF_TABLELOG_MAX) return ERROR(tableLog_tooLarge);\n        \n\n    iSize = HUF_readStats_wksp(wksp->weightList, HUF_SYMBOLVALUE_MAX + 1, wksp->rankStats, &nbSymbols, &tableLog, src, srcSize, wksp->calleeWksp, sizeof(wksp->calleeWksp), bmi2);\n    if (HUF_isError(iSize)) return iSize;\n\n     \n    if (tableLog > maxTableLog) return ERROR(tableLog_tooLarge);    \n    if (tableLog <= HUF_DECODER_FAST_TABLELOG && maxTableLog > HUF_DECODER_FAST_TABLELOG) maxTableLog = HUF_DECODER_FAST_TABLELOG;\n\n     \n    for (maxW = tableLog; wksp->rankStats[maxW]==0; maxW--) {}   \n\n     \n    {   U32 w, nextRankStart = 0;\n        for (w=1; w<maxW+1; w++) {\n            U32 curr = nextRankStart;\n            nextRankStart += wksp->rankStats[w];\n            rankStart[w] = curr;\n        }\n        rankStart[0] = nextRankStart;    \n        rankStart[maxW+1] = nextRankStart;\n    }\n\n     \n    {   U32 s;\n        for (s=0; s<nbSymbols; s++) {\n            U32 const w = wksp->weightList[s];\n            U32 const r = rankStart[w]++;\n            wksp->sortedSymbol[r].symbol = (BYTE)s;\n        }\n        rankStart[0] = 0;    \n    }\n\n     \n    {   U32* const rankVal0 = wksp->rankVal[0];\n        {   int const rescale = (maxTableLog-tableLog) - 1;    \n            U32 nextRankVal = 0;\n            U32 w;\n            for (w=1; w<maxW+1; w++) {\n                U32 curr = nextRankVal;\n                nextRankVal += wksp->rankStats[w] << (w+rescale);\n                rankVal0[w] = curr;\n        }   }\n        {   U32 const minBits = tableLog+1 - maxW;\n            U32 consumed;\n            for (consumed = minBits; consumed < maxTableLog - minBits + 1; consumed++) {\n                U32* const rankValPtr = wksp->rankVal[consumed];\n                U32 w;\n                for (w = 1; w < maxW+1; w++) {\n                    rankValPtr[w] = rankVal0[w] >> consumed;\n    }   }   }   }\n\n    HUF_fillDTableX2(dt, maxTableLog,\n                   wksp->sortedSymbol,\n                   wksp->rankStart0, wksp->rankVal, maxW,\n                   tableLog+1);\n\n    dtd.tableLog = (BYTE)maxTableLog;\n    dtd.tableType = 1;\n    ZSTD_memcpy(DTable, &dtd, sizeof(dtd));\n    return iSize;\n}\n\n\nFORCE_INLINE_TEMPLATE U32\nHUF_decodeSymbolX2(void* op, BIT_DStream_t* DStream, const HUF_DEltX2* dt, const U32 dtLog)\n{\n    size_t const val = BIT_lookBitsFast(DStream, dtLog);    \n    ZSTD_memcpy(op, &dt[val].sequence, 2);\n    BIT_skipBits(DStream, dt[val].nbBits);\n    return dt[val].length;\n}\n\nFORCE_INLINE_TEMPLATE U32\nHUF_decodeLastSymbolX2(void* op, BIT_DStream_t* DStream, const HUF_DEltX2* dt, const U32 dtLog)\n{\n    size_t const val = BIT_lookBitsFast(DStream, dtLog);    \n    ZSTD_memcpy(op, &dt[val].sequence, 1);\n    if (dt[val].length==1) {\n        BIT_skipBits(DStream, dt[val].nbBits);\n    } else {\n        if (DStream->bitsConsumed < (sizeof(DStream->bitContainer)*8)) {\n            BIT_skipBits(DStream, dt[val].nbBits);\n            if (DStream->bitsConsumed > (sizeof(DStream->bitContainer)*8))\n                 \n                DStream->bitsConsumed = (sizeof(DStream->bitContainer)*8);\n        }\n    }\n    return 1;\n}\n\n#define HUF_DECODE_SYMBOLX2_0(ptr, DStreamPtr) \\\n    ptr += HUF_decodeSymbolX2(ptr, DStreamPtr, dt, dtLog)\n\n#define HUF_DECODE_SYMBOLX2_1(ptr, DStreamPtr) \\\n    if (MEM_64bits() || (HUF_TABLELOG_MAX<=12)) \\\n        ptr += HUF_decodeSymbolX2(ptr, DStreamPtr, dt, dtLog)\n\n#define HUF_DECODE_SYMBOLX2_2(ptr, DStreamPtr) \\\n    if (MEM_64bits()) \\\n        ptr += HUF_decodeSymbolX2(ptr, DStreamPtr, dt, dtLog)\n\nHINT_INLINE size_t\nHUF_decodeStreamX2(BYTE* p, BIT_DStream_t* bitDPtr, BYTE* const pEnd,\n                const HUF_DEltX2* const dt, const U32 dtLog)\n{\n    BYTE* const pStart = p;\n\n     \n    if ((size_t)(pEnd - p) >= sizeof(bitDPtr->bitContainer)) {\n        if (dtLog <= 11 && MEM_64bits()) {\n             \n            while ((BIT_reloadDStream(bitDPtr) == BIT_DStream_unfinished) & (p < pEnd-9)) {\n                HUF_DECODE_SYMBOLX2_0(p, bitDPtr);\n                HUF_DECODE_SYMBOLX2_0(p, bitDPtr);\n                HUF_DECODE_SYMBOLX2_0(p, bitDPtr);\n                HUF_DECODE_SYMBOLX2_0(p, bitDPtr);\n                HUF_DECODE_SYMBOLX2_0(p, bitDPtr);\n            }\n        } else {\n             \n            while ((BIT_reloadDStream(bitDPtr) == BIT_DStream_unfinished) & (p < pEnd-(sizeof(bitDPtr->bitContainer)-1))) {\n                HUF_DECODE_SYMBOLX2_2(p, bitDPtr);\n                HUF_DECODE_SYMBOLX2_1(p, bitDPtr);\n                HUF_DECODE_SYMBOLX2_2(p, bitDPtr);\n                HUF_DECODE_SYMBOLX2_0(p, bitDPtr);\n            }\n        }\n    } else {\n        BIT_reloadDStream(bitDPtr);\n    }\n\n     \n    if ((size_t)(pEnd - p) >= 2) {\n        while ((BIT_reloadDStream(bitDPtr) == BIT_DStream_unfinished) & (p <= pEnd-2))\n            HUF_DECODE_SYMBOLX2_0(p, bitDPtr);\n\n        while (p <= pEnd-2)\n            HUF_DECODE_SYMBOLX2_0(p, bitDPtr);    \n    }\n\n    if (p < pEnd)\n        p += HUF_decodeLastSymbolX2(p, bitDPtr, dt, dtLog);\n\n    return p-pStart;\n}\n\nFORCE_INLINE_TEMPLATE size_t\nHUF_decompress1X2_usingDTable_internal_body(\n          void* dst,  size_t dstSize,\n    const void* cSrc, size_t cSrcSize,\n    const HUF_DTable* DTable)\n{\n    BIT_DStream_t bitD;\n\n     \n    CHECK_F( BIT_initDStream(&bitD, cSrc, cSrcSize) );\n\n     \n    {   BYTE* const ostart = (BYTE*) dst;\n        BYTE* const oend = ostart + dstSize;\n        const void* const dtPtr = DTable+1;    \n        const HUF_DEltX2* const dt = (const HUF_DEltX2*)dtPtr;\n        DTableDesc const dtd = HUF_getDTableDesc(DTable);\n        HUF_decodeStreamX2(ostart, &bitD, oend, dt, dtd.tableLog);\n    }\n\n     \n    if (!BIT_endOfDStream(&bitD)) return ERROR(corruption_detected);\n\n     \n    return dstSize;\n}\nFORCE_INLINE_TEMPLATE size_t\nHUF_decompress4X2_usingDTable_internal_body(\n          void* dst,  size_t dstSize,\n    const void* cSrc, size_t cSrcSize,\n    const HUF_DTable* DTable)\n{\n    if (cSrcSize < 10) return ERROR(corruption_detected);    \n\n    {   const BYTE* const istart = (const BYTE*) cSrc;\n        BYTE* const ostart = (BYTE*) dst;\n        BYTE* const oend = ostart + dstSize;\n        BYTE* const olimit = oend - (sizeof(size_t)-1);\n        const void* const dtPtr = DTable+1;\n        const HUF_DEltX2* const dt = (const HUF_DEltX2*)dtPtr;\n\n         \n        BIT_DStream_t bitD1;\n        BIT_DStream_t bitD2;\n        BIT_DStream_t bitD3;\n        BIT_DStream_t bitD4;\n        size_t const length1 = MEM_readLE16(istart);\n        size_t const length2 = MEM_readLE16(istart+2);\n        size_t const length3 = MEM_readLE16(istart+4);\n        size_t const length4 = cSrcSize - (length1 + length2 + length3 + 6);\n        const BYTE* const istart1 = istart + 6;   \n        const BYTE* const istart2 = istart1 + length1;\n        const BYTE* const istart3 = istart2 + length2;\n        const BYTE* const istart4 = istart3 + length3;\n        size_t const segmentSize = (dstSize+3) / 4;\n        BYTE* const opStart2 = ostart + segmentSize;\n        BYTE* const opStart3 = opStart2 + segmentSize;\n        BYTE* const opStart4 = opStart3 + segmentSize;\n        BYTE* op1 = ostart;\n        BYTE* op2 = opStart2;\n        BYTE* op3 = opStart3;\n        BYTE* op4 = opStart4;\n        U32 endSignal = 1;\n        DTableDesc const dtd = HUF_getDTableDesc(DTable);\n        U32 const dtLog = dtd.tableLog;\n\n        if (length4 > cSrcSize) return ERROR(corruption_detected);    \n        if (opStart4 > oend) return ERROR(corruption_detected);       \n        CHECK_F( BIT_initDStream(&bitD1, istart1, length1) );\n        CHECK_F( BIT_initDStream(&bitD2, istart2, length2) );\n        CHECK_F( BIT_initDStream(&bitD3, istart3, length3) );\n        CHECK_F( BIT_initDStream(&bitD4, istart4, length4) );\n\n         \n        if ((size_t)(oend - op4) >= sizeof(size_t)) {\n            for ( ; (endSignal) & (op4 < olimit); ) {\n#if defined(__clang__) && (defined(__x86_64__) || defined(__i386__))\n                HUF_DECODE_SYMBOLX2_2(op1, &bitD1);\n                HUF_DECODE_SYMBOLX2_1(op1, &bitD1);\n                HUF_DECODE_SYMBOLX2_2(op1, &bitD1);\n                HUF_DECODE_SYMBOLX2_0(op1, &bitD1);\n                HUF_DECODE_SYMBOLX2_2(op2, &bitD2);\n                HUF_DECODE_SYMBOLX2_1(op2, &bitD2);\n                HUF_DECODE_SYMBOLX2_2(op2, &bitD2);\n                HUF_DECODE_SYMBOLX2_0(op2, &bitD2);\n                endSignal &= BIT_reloadDStreamFast(&bitD1) == BIT_DStream_unfinished;\n                endSignal &= BIT_reloadDStreamFast(&bitD2) == BIT_DStream_unfinished;\n                HUF_DECODE_SYMBOLX2_2(op3, &bitD3);\n                HUF_DECODE_SYMBOLX2_1(op3, &bitD3);\n                HUF_DECODE_SYMBOLX2_2(op3, &bitD3);\n                HUF_DECODE_SYMBOLX2_0(op3, &bitD3);\n                HUF_DECODE_SYMBOLX2_2(op4, &bitD4);\n                HUF_DECODE_SYMBOLX2_1(op4, &bitD4);\n                HUF_DECODE_SYMBOLX2_2(op4, &bitD4);\n                HUF_DECODE_SYMBOLX2_0(op4, &bitD4);\n                endSignal &= BIT_reloadDStreamFast(&bitD3) == BIT_DStream_unfinished;\n                endSignal &= BIT_reloadDStreamFast(&bitD4) == BIT_DStream_unfinished;\n#else\n                HUF_DECODE_SYMBOLX2_2(op1, &bitD1);\n                HUF_DECODE_SYMBOLX2_2(op2, &bitD2);\n                HUF_DECODE_SYMBOLX2_2(op3, &bitD3);\n                HUF_DECODE_SYMBOLX2_2(op4, &bitD4);\n                HUF_DECODE_SYMBOLX2_1(op1, &bitD1);\n                HUF_DECODE_SYMBOLX2_1(op2, &bitD2);\n                HUF_DECODE_SYMBOLX2_1(op3, &bitD3);\n                HUF_DECODE_SYMBOLX2_1(op4, &bitD4);\n                HUF_DECODE_SYMBOLX2_2(op1, &bitD1);\n                HUF_DECODE_SYMBOLX2_2(op2, &bitD2);\n                HUF_DECODE_SYMBOLX2_2(op3, &bitD3);\n                HUF_DECODE_SYMBOLX2_2(op4, &bitD4);\n                HUF_DECODE_SYMBOLX2_0(op1, &bitD1);\n                HUF_DECODE_SYMBOLX2_0(op2, &bitD2);\n                HUF_DECODE_SYMBOLX2_0(op3, &bitD3);\n                HUF_DECODE_SYMBOLX2_0(op4, &bitD4);\n                endSignal = (U32)LIKELY((U32)\n                            (BIT_reloadDStreamFast(&bitD1) == BIT_DStream_unfinished)\n                        & (BIT_reloadDStreamFast(&bitD2) == BIT_DStream_unfinished)\n                        & (BIT_reloadDStreamFast(&bitD3) == BIT_DStream_unfinished)\n                        & (BIT_reloadDStreamFast(&bitD4) == BIT_DStream_unfinished));\n#endif\n            }\n        }\n\n         \n        if (op1 > opStart2) return ERROR(corruption_detected);\n        if (op2 > opStart3) return ERROR(corruption_detected);\n        if (op3 > opStart4) return ERROR(corruption_detected);\n         \n\n         \n        HUF_decodeStreamX2(op1, &bitD1, opStart2, dt, dtLog);\n        HUF_decodeStreamX2(op2, &bitD2, opStart3, dt, dtLog);\n        HUF_decodeStreamX2(op3, &bitD3, opStart4, dt, dtLog);\n        HUF_decodeStreamX2(op4, &bitD4, oend,     dt, dtLog);\n\n         \n        { U32 const endCheck = BIT_endOfDStream(&bitD1) & BIT_endOfDStream(&bitD2) & BIT_endOfDStream(&bitD3) & BIT_endOfDStream(&bitD4);\n          if (!endCheck) return ERROR(corruption_detected); }\n\n         \n        return dstSize;\n    }\n}\n\n#if HUF_NEED_BMI2_FUNCTION\nstatic BMI2_TARGET_ATTRIBUTE\nsize_t HUF_decompress4X2_usingDTable_internal_bmi2(void* dst, size_t dstSize, void const* cSrc,\n                    size_t cSrcSize, HUF_DTable const* DTable) {\n    return HUF_decompress4X2_usingDTable_internal_body(dst, dstSize, cSrc, cSrcSize, DTable);\n}\n#endif\n\n#if HUF_NEED_DEFAULT_FUNCTION\nstatic\nsize_t HUF_decompress4X2_usingDTable_internal_default(void* dst, size_t dstSize, void const* cSrc,\n                    size_t cSrcSize, HUF_DTable const* DTable) {\n    return HUF_decompress4X2_usingDTable_internal_body(dst, dstSize, cSrc, cSrcSize, DTable);\n}\n#endif\n\n#if ZSTD_ENABLE_ASM_X86_64_BMI2\n\nHUF_ASM_DECL void HUF_decompress4X2_usingDTable_internal_bmi2_asm_loop(HUF_DecompressAsmArgs* args) ZSTDLIB_HIDDEN;\n\nstatic HUF_ASM_X86_64_BMI2_ATTRS size_t\nHUF_decompress4X2_usingDTable_internal_bmi2_asm(\n          void* dst,  size_t dstSize,\n    const void* cSrc, size_t cSrcSize,\n    const HUF_DTable* DTable) {\n    void const* dt = DTable + 1;\n    const BYTE* const iend = (const BYTE*)cSrc + 6;\n    BYTE* const oend = (BYTE*)dst + dstSize;\n    HUF_DecompressAsmArgs args;\n    {\n        size_t const ret = HUF_DecompressAsmArgs_init(&args, dst, dstSize, cSrc, cSrcSize, DTable);\n        FORWARD_IF_ERROR(ret, \"Failed to init asm args\");\n        if (ret != 0)\n            return HUF_decompress4X2_usingDTable_internal_bmi2(dst, dstSize, cSrc, cSrcSize, DTable);\n    }\n\n    assert(args.ip[0] >= args.ilimit);\n    HUF_decompress4X2_usingDTable_internal_bmi2_asm_loop(&args);\n\n     \n    assert(args.ip[0] >= iend);\n    assert(args.ip[1] >= iend);\n    assert(args.ip[2] >= iend);\n    assert(args.ip[3] >= iend);\n    assert(args.op[3] <= oend);\n    (void)iend;\n\n     \n    {\n        size_t const segmentSize = (dstSize+3) / 4;\n        BYTE* segmentEnd = (BYTE*)dst;\n        int i;\n        for (i = 0; i < 4; ++i) {\n            BIT_DStream_t bit;\n            if (segmentSize <= (size_t)(oend - segmentEnd))\n                segmentEnd += segmentSize;\n            else\n                segmentEnd = oend;\n            FORWARD_IF_ERROR(HUF_initRemainingDStream(&bit, &args, i, segmentEnd), \"corruption\");\n            args.op[i] += HUF_decodeStreamX2(args.op[i], &bit, segmentEnd, (HUF_DEltX2 const*)dt, HUF_DECODER_FAST_TABLELOG);\n            if (args.op[i] != segmentEnd)\n                return ERROR(corruption_detected);\n        }\n    }\n\n     \n    return dstSize;\n}\n#endif  \n\nstatic size_t HUF_decompress4X2_usingDTable_internal(void* dst, size_t dstSize, void const* cSrc,\n                    size_t cSrcSize, HUF_DTable const* DTable, int bmi2)\n{\n#if DYNAMIC_BMI2\n    if (bmi2) {\n# if ZSTD_ENABLE_ASM_X86_64_BMI2\n        return HUF_decompress4X2_usingDTable_internal_bmi2_asm(dst, dstSize, cSrc, cSrcSize, DTable);\n# else\n        return HUF_decompress4X2_usingDTable_internal_bmi2(dst, dstSize, cSrc, cSrcSize, DTable);\n# endif\n    }\n#else\n    (void)bmi2;\n#endif\n\n#if ZSTD_ENABLE_ASM_X86_64_BMI2 && defined(__BMI2__)\n    return HUF_decompress4X2_usingDTable_internal_bmi2_asm(dst, dstSize, cSrc, cSrcSize, DTable);\n#else\n    return HUF_decompress4X2_usingDTable_internal_default(dst, dstSize, cSrc, cSrcSize, DTable);\n#endif\n}\n\nHUF_DGEN(HUF_decompress1X2_usingDTable_internal)\n\nsize_t HUF_decompress1X2_usingDTable(\n          void* dst,  size_t dstSize,\n    const void* cSrc, size_t cSrcSize,\n    const HUF_DTable* DTable)\n{\n    DTableDesc dtd = HUF_getDTableDesc(DTable);\n    if (dtd.tableType != 1) return ERROR(GENERIC);\n    return HUF_decompress1X2_usingDTable_internal(dst, dstSize, cSrc, cSrcSize, DTable,   0);\n}\n\nsize_t HUF_decompress1X2_DCtx_wksp(HUF_DTable* DCtx, void* dst, size_t dstSize,\n                                   const void* cSrc, size_t cSrcSize,\n                                   void* workSpace, size_t wkspSize)\n{\n    const BYTE* ip = (const BYTE*) cSrc;\n\n    size_t const hSize = HUF_readDTableX2_wksp(DCtx, cSrc, cSrcSize,\n                                               workSpace, wkspSize);\n    if (HUF_isError(hSize)) return hSize;\n    if (hSize >= cSrcSize) return ERROR(srcSize_wrong);\n    ip += hSize; cSrcSize -= hSize;\n\n    return HUF_decompress1X2_usingDTable_internal(dst, dstSize, ip, cSrcSize, DCtx,   0);\n}\n\n\nsize_t HUF_decompress4X2_usingDTable(\n          void* dst,  size_t dstSize,\n    const void* cSrc, size_t cSrcSize,\n    const HUF_DTable* DTable)\n{\n    DTableDesc dtd = HUF_getDTableDesc(DTable);\n    if (dtd.tableType != 1) return ERROR(GENERIC);\n    return HUF_decompress4X2_usingDTable_internal(dst, dstSize, cSrc, cSrcSize, DTable,   0);\n}\n\nstatic size_t HUF_decompress4X2_DCtx_wksp_bmi2(HUF_DTable* dctx, void* dst, size_t dstSize,\n                                   const void* cSrc, size_t cSrcSize,\n                                   void* workSpace, size_t wkspSize, int bmi2)\n{\n    const BYTE* ip = (const BYTE*) cSrc;\n\n    size_t hSize = HUF_readDTableX2_wksp(dctx, cSrc, cSrcSize,\n                                         workSpace, wkspSize);\n    if (HUF_isError(hSize)) return hSize;\n    if (hSize >= cSrcSize) return ERROR(srcSize_wrong);\n    ip += hSize; cSrcSize -= hSize;\n\n    return HUF_decompress4X2_usingDTable_internal(dst, dstSize, ip, cSrcSize, dctx, bmi2);\n}\n\nsize_t HUF_decompress4X2_DCtx_wksp(HUF_DTable* dctx, void* dst, size_t dstSize,\n                                   const void* cSrc, size_t cSrcSize,\n                                   void* workSpace, size_t wkspSize)\n{\n    return HUF_decompress4X2_DCtx_wksp_bmi2(dctx, dst, dstSize, cSrc, cSrcSize, workSpace, wkspSize,   0);\n}\n\n\n#endif  \n\n\n \n \n \n\nsize_t HUF_decompress1X_usingDTable(void* dst, size_t maxDstSize,\n                                    const void* cSrc, size_t cSrcSize,\n                                    const HUF_DTable* DTable)\n{\n    DTableDesc const dtd = HUF_getDTableDesc(DTable);\n#if defined(HUF_FORCE_DECOMPRESS_X1)\n    (void)dtd;\n    assert(dtd.tableType == 0);\n    return HUF_decompress1X1_usingDTable_internal(dst, maxDstSize, cSrc, cSrcSize, DTable,   0);\n#elif defined(HUF_FORCE_DECOMPRESS_X2)\n    (void)dtd;\n    assert(dtd.tableType == 1);\n    return HUF_decompress1X2_usingDTable_internal(dst, maxDstSize, cSrc, cSrcSize, DTable,   0);\n#else\n    return dtd.tableType ? HUF_decompress1X2_usingDTable_internal(dst, maxDstSize, cSrc, cSrcSize, DTable,   0) :\n                           HUF_decompress1X1_usingDTable_internal(dst, maxDstSize, cSrc, cSrcSize, DTable,   0);\n#endif\n}\n\nsize_t HUF_decompress4X_usingDTable(void* dst, size_t maxDstSize,\n                                    const void* cSrc, size_t cSrcSize,\n                                    const HUF_DTable* DTable)\n{\n    DTableDesc const dtd = HUF_getDTableDesc(DTable);\n#if defined(HUF_FORCE_DECOMPRESS_X1)\n    (void)dtd;\n    assert(dtd.tableType == 0);\n    return HUF_decompress4X1_usingDTable_internal(dst, maxDstSize, cSrc, cSrcSize, DTable,   0);\n#elif defined(HUF_FORCE_DECOMPRESS_X2)\n    (void)dtd;\n    assert(dtd.tableType == 1);\n    return HUF_decompress4X2_usingDTable_internal(dst, maxDstSize, cSrc, cSrcSize, DTable,   0);\n#else\n    return dtd.tableType ? HUF_decompress4X2_usingDTable_internal(dst, maxDstSize, cSrc, cSrcSize, DTable,   0) :\n                           HUF_decompress4X1_usingDTable_internal(dst, maxDstSize, cSrc, cSrcSize, DTable,   0);\n#endif\n}\n\n\n#if !defined(HUF_FORCE_DECOMPRESS_X1) && !defined(HUF_FORCE_DECOMPRESS_X2)\ntypedef struct { U32 tableTime; U32 decode256Time; } algo_time_t;\nstatic const algo_time_t algoTime[16  ][2  ] =\n{\n     \n    {{0,0}, {1,1}},   \n    {{0,0}, {1,1}},   \n    {{ 150,216}, { 381,119}},    \n    {{ 170,205}, { 514,112}},    \n    {{ 177,199}, { 539,110}},    \n    {{ 197,194}, { 644,107}},    \n    {{ 221,192}, { 735,107}},    \n    {{ 256,189}, { 881,106}},    \n    {{ 359,188}, {1167,109}},    \n    {{ 582,187}, {1570,114}},    \n    {{ 688,187}, {1712,122}},    \n    {{ 825,186}, {1965,136}},    \n    {{ 976,185}, {2131,150}},    \n    {{1180,186}, {2070,175}},    \n    {{1377,185}, {1731,202}},    \n    {{1412,185}, {1695,202}},    \n};\n#endif\n\n \nU32 HUF_selectDecoder (size_t dstSize, size_t cSrcSize)\n{\n    assert(dstSize > 0);\n    assert(dstSize <= 128*1024);\n#if defined(HUF_FORCE_DECOMPRESS_X1)\n    (void)dstSize;\n    (void)cSrcSize;\n    return 0;\n#elif defined(HUF_FORCE_DECOMPRESS_X2)\n    (void)dstSize;\n    (void)cSrcSize;\n    return 1;\n#else\n     \n    {   U32 const Q = (cSrcSize >= dstSize) ? 15 : (U32)(cSrcSize * 16 / dstSize);    \n        U32 const D256 = (U32)(dstSize >> 8);\n        U32 const DTime0 = algoTime[Q][0].tableTime + (algoTime[Q][0].decode256Time * D256);\n        U32 DTime1 = algoTime[Q][1].tableTime + (algoTime[Q][1].decode256Time * D256);\n        DTime1 += DTime1 >> 5;   \n        return DTime1 < DTime0;\n    }\n#endif\n}\n\n\nsize_t HUF_decompress4X_hufOnly_wksp(HUF_DTable* dctx, void* dst,\n                                     size_t dstSize, const void* cSrc,\n                                     size_t cSrcSize, void* workSpace,\n                                     size_t wkspSize)\n{\n     \n    if (dstSize == 0) return ERROR(dstSize_tooSmall);\n    if (cSrcSize == 0) return ERROR(corruption_detected);\n\n    {   U32 const algoNb = HUF_selectDecoder(dstSize, cSrcSize);\n#if defined(HUF_FORCE_DECOMPRESS_X1)\n        (void)algoNb;\n        assert(algoNb == 0);\n        return HUF_decompress4X1_DCtx_wksp(dctx, dst, dstSize, cSrc, cSrcSize, workSpace, wkspSize);\n#elif defined(HUF_FORCE_DECOMPRESS_X2)\n        (void)algoNb;\n        assert(algoNb == 1);\n        return HUF_decompress4X2_DCtx_wksp(dctx, dst, dstSize, cSrc, cSrcSize, workSpace, wkspSize);\n#else\n        return algoNb ? HUF_decompress4X2_DCtx_wksp(dctx, dst, dstSize, cSrc,\n                            cSrcSize, workSpace, wkspSize):\n                        HUF_decompress4X1_DCtx_wksp(dctx, dst, dstSize, cSrc, cSrcSize, workSpace, wkspSize);\n#endif\n    }\n}\n\nsize_t HUF_decompress1X_DCtx_wksp(HUF_DTable* dctx, void* dst, size_t dstSize,\n                                  const void* cSrc, size_t cSrcSize,\n                                  void* workSpace, size_t wkspSize)\n{\n     \n    if (dstSize == 0) return ERROR(dstSize_tooSmall);\n    if (cSrcSize > dstSize) return ERROR(corruption_detected);    \n    if (cSrcSize == dstSize) { ZSTD_memcpy(dst, cSrc, dstSize); return dstSize; }    \n    if (cSrcSize == 1) { ZSTD_memset(dst, *(const BYTE*)cSrc, dstSize); return dstSize; }    \n\n    {   U32 const algoNb = HUF_selectDecoder(dstSize, cSrcSize);\n#if defined(HUF_FORCE_DECOMPRESS_X1)\n        (void)algoNb;\n        assert(algoNb == 0);\n        return HUF_decompress1X1_DCtx_wksp(dctx, dst, dstSize, cSrc,\n                                cSrcSize, workSpace, wkspSize);\n#elif defined(HUF_FORCE_DECOMPRESS_X2)\n        (void)algoNb;\n        assert(algoNb == 1);\n        return HUF_decompress1X2_DCtx_wksp(dctx, dst, dstSize, cSrc,\n                                cSrcSize, workSpace, wkspSize);\n#else\n        return algoNb ? HUF_decompress1X2_DCtx_wksp(dctx, dst, dstSize, cSrc,\n                                cSrcSize, workSpace, wkspSize):\n                        HUF_decompress1X1_DCtx_wksp(dctx, dst, dstSize, cSrc,\n                                cSrcSize, workSpace, wkspSize);\n#endif\n    }\n}\n\n\nsize_t HUF_decompress1X_usingDTable_bmi2(void* dst, size_t maxDstSize, const void* cSrc, size_t cSrcSize, const HUF_DTable* DTable, int bmi2)\n{\n    DTableDesc const dtd = HUF_getDTableDesc(DTable);\n#if defined(HUF_FORCE_DECOMPRESS_X1)\n    (void)dtd;\n    assert(dtd.tableType == 0);\n    return HUF_decompress1X1_usingDTable_internal(dst, maxDstSize, cSrc, cSrcSize, DTable, bmi2);\n#elif defined(HUF_FORCE_DECOMPRESS_X2)\n    (void)dtd;\n    assert(dtd.tableType == 1);\n    return HUF_decompress1X2_usingDTable_internal(dst, maxDstSize, cSrc, cSrcSize, DTable, bmi2);\n#else\n    return dtd.tableType ? HUF_decompress1X2_usingDTable_internal(dst, maxDstSize, cSrc, cSrcSize, DTable, bmi2) :\n                           HUF_decompress1X1_usingDTable_internal(dst, maxDstSize, cSrc, cSrcSize, DTable, bmi2);\n#endif\n}\n\n#ifndef HUF_FORCE_DECOMPRESS_X2\nsize_t HUF_decompress1X1_DCtx_wksp_bmi2(HUF_DTable* dctx, void* dst, size_t dstSize, const void* cSrc, size_t cSrcSize, void* workSpace, size_t wkspSize, int bmi2)\n{\n    const BYTE* ip = (const BYTE*) cSrc;\n\n    size_t const hSize = HUF_readDTableX1_wksp_bmi2(dctx, cSrc, cSrcSize, workSpace, wkspSize, bmi2);\n    if (HUF_isError(hSize)) return hSize;\n    if (hSize >= cSrcSize) return ERROR(srcSize_wrong);\n    ip += hSize; cSrcSize -= hSize;\n\n    return HUF_decompress1X1_usingDTable_internal(dst, dstSize, ip, cSrcSize, dctx, bmi2);\n}\n#endif\n\nsize_t HUF_decompress4X_usingDTable_bmi2(void* dst, size_t maxDstSize, const void* cSrc, size_t cSrcSize, const HUF_DTable* DTable, int bmi2)\n{\n    DTableDesc const dtd = HUF_getDTableDesc(DTable);\n#if defined(HUF_FORCE_DECOMPRESS_X1)\n    (void)dtd;\n    assert(dtd.tableType == 0);\n    return HUF_decompress4X1_usingDTable_internal(dst, maxDstSize, cSrc, cSrcSize, DTable, bmi2);\n#elif defined(HUF_FORCE_DECOMPRESS_X2)\n    (void)dtd;\n    assert(dtd.tableType == 1);\n    return HUF_decompress4X2_usingDTable_internal(dst, maxDstSize, cSrc, cSrcSize, DTable, bmi2);\n#else\n    return dtd.tableType ? HUF_decompress4X2_usingDTable_internal(dst, maxDstSize, cSrc, cSrcSize, DTable, bmi2) :\n                           HUF_decompress4X1_usingDTable_internal(dst, maxDstSize, cSrc, cSrcSize, DTable, bmi2);\n#endif\n}\n\nsize_t HUF_decompress4X_hufOnly_wksp_bmi2(HUF_DTable* dctx, void* dst, size_t dstSize, const void* cSrc, size_t cSrcSize, void* workSpace, size_t wkspSize, int bmi2)\n{\n     \n    if (dstSize == 0) return ERROR(dstSize_tooSmall);\n    if (cSrcSize == 0) return ERROR(corruption_detected);\n\n    {   U32 const algoNb = HUF_selectDecoder(dstSize, cSrcSize);\n#if defined(HUF_FORCE_DECOMPRESS_X1)\n        (void)algoNb;\n        assert(algoNb == 0);\n        return HUF_decompress4X1_DCtx_wksp_bmi2(dctx, dst, dstSize, cSrc, cSrcSize, workSpace, wkspSize, bmi2);\n#elif defined(HUF_FORCE_DECOMPRESS_X2)\n        (void)algoNb;\n        assert(algoNb == 1);\n        return HUF_decompress4X2_DCtx_wksp_bmi2(dctx, dst, dstSize, cSrc, cSrcSize, workSpace, wkspSize, bmi2);\n#else\n        return algoNb ? HUF_decompress4X2_DCtx_wksp_bmi2(dctx, dst, dstSize, cSrc, cSrcSize, workSpace, wkspSize, bmi2) :\n                        HUF_decompress4X1_DCtx_wksp_bmi2(dctx, dst, dstSize, cSrc, cSrcSize, workSpace, wkspSize, bmi2);\n#endif\n    }\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}