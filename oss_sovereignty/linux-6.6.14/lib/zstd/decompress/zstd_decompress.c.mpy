{
  "module_name": "zstd_decompress.c",
  "hash_id": "071484ddc0ee771538d6dc66edcca32e773e4e730149ecbfc98dcbc8dedd5703",
  "original_prompt": "Ingested from linux-6.6.14/lib/zstd/decompress/zstd_decompress.c",
  "human_readable_source": " \n\n\n \n \n#ifndef ZSTD_HEAPMODE\n#  define ZSTD_HEAPMODE 1\n#endif\n\n \n\n \n#ifndef ZSTD_MAXWINDOWSIZE_DEFAULT\n#  define ZSTD_MAXWINDOWSIZE_DEFAULT (((U32)1 << ZSTD_WINDOWLOG_LIMIT_DEFAULT) + 1)\n#endif\n\n \n#ifndef ZSTD_NO_FORWARD_PROGRESS_MAX\n#  define ZSTD_NO_FORWARD_PROGRESS_MAX 16\n#endif\n\n\n \n#include \"../common/zstd_deps.h\"    \n#include \"../common/mem.h\"          \n#define FSE_STATIC_LINKING_ONLY\n#include \"../common/fse.h\"\n#define HUF_STATIC_LINKING_ONLY\n#include \"../common/huf.h\"\n#include <linux/xxhash.h>  \n#include \"../common/zstd_internal.h\"   \n#include \"zstd_decompress_internal.h\"    \n#include \"zstd_ddict.h\"   \n#include \"zstd_decompress_block.h\"    \n\n\n\n\n \n\n#define DDICT_HASHSET_MAX_LOAD_FACTOR_COUNT_MULT 4\n#define DDICT_HASHSET_MAX_LOAD_FACTOR_SIZE_MULT 3    \n\n#define DDICT_HASHSET_TABLE_BASE_SIZE 64\n#define DDICT_HASHSET_RESIZE_FACTOR 2\n\n \nstatic size_t ZSTD_DDictHashSet_getIndex(const ZSTD_DDictHashSet* hashSet, U32 dictID) {\n    const U64 hash = xxh64(&dictID, sizeof(U32), 0);\n     \n    return hash & (hashSet->ddictPtrTableSize - 1);\n}\n\n \nstatic size_t ZSTD_DDictHashSet_emplaceDDict(ZSTD_DDictHashSet* hashSet, const ZSTD_DDict* ddict) {\n    const U32 dictID = ZSTD_getDictID_fromDDict(ddict);\n    size_t idx = ZSTD_DDictHashSet_getIndex(hashSet, dictID);\n    const size_t idxRangeMask = hashSet->ddictPtrTableSize - 1;\n    RETURN_ERROR_IF(hashSet->ddictPtrCount == hashSet->ddictPtrTableSize, GENERIC, \"Hash set is full!\");\n    DEBUGLOG(4, \"Hashed index: for dictID: %u is %zu\", dictID, idx);\n    while (hashSet->ddictPtrTable[idx] != NULL) {\n         \n        if (ZSTD_getDictID_fromDDict(hashSet->ddictPtrTable[idx]) == dictID) {\n            DEBUGLOG(4, \"DictID already exists, replacing rather than adding\");\n            hashSet->ddictPtrTable[idx] = ddict;\n            return 0;\n        }\n        idx &= idxRangeMask;\n        idx++;\n    }\n    DEBUGLOG(4, \"Final idx after probing for dictID %u is: %zu\", dictID, idx);\n    hashSet->ddictPtrTable[idx] = ddict;\n    hashSet->ddictPtrCount++;\n    return 0;\n}\n\n \nstatic size_t ZSTD_DDictHashSet_expand(ZSTD_DDictHashSet* hashSet, ZSTD_customMem customMem) {\n    size_t newTableSize = hashSet->ddictPtrTableSize * DDICT_HASHSET_RESIZE_FACTOR;\n    const ZSTD_DDict** newTable = (const ZSTD_DDict**)ZSTD_customCalloc(sizeof(ZSTD_DDict*) * newTableSize, customMem);\n    const ZSTD_DDict** oldTable = hashSet->ddictPtrTable;\n    size_t oldTableSize = hashSet->ddictPtrTableSize;\n    size_t i;\n\n    DEBUGLOG(4, \"Expanding DDict hash table! Old size: %zu new size: %zu\", oldTableSize, newTableSize);\n    RETURN_ERROR_IF(!newTable, memory_allocation, \"Expanded hashset allocation failed!\");\n    hashSet->ddictPtrTable = newTable;\n    hashSet->ddictPtrTableSize = newTableSize;\n    hashSet->ddictPtrCount = 0;\n    for (i = 0; i < oldTableSize; ++i) {\n        if (oldTable[i] != NULL) {\n            FORWARD_IF_ERROR(ZSTD_DDictHashSet_emplaceDDict(hashSet, oldTable[i]), \"\");\n        }\n    }\n    ZSTD_customFree((void*)oldTable, customMem);\n    DEBUGLOG(4, \"Finished re-hash\");\n    return 0;\n}\n\n \nstatic const ZSTD_DDict* ZSTD_DDictHashSet_getDDict(ZSTD_DDictHashSet* hashSet, U32 dictID) {\n    size_t idx = ZSTD_DDictHashSet_getIndex(hashSet, dictID);\n    const size_t idxRangeMask = hashSet->ddictPtrTableSize - 1;\n    DEBUGLOG(4, \"Hashed index: for dictID: %u is %zu\", dictID, idx);\n    for (;;) {\n        size_t currDictID = ZSTD_getDictID_fromDDict(hashSet->ddictPtrTable[idx]);\n        if (currDictID == dictID || currDictID == 0) {\n             \n            break;\n        } else {\n            idx &= idxRangeMask;     \n            idx++;\n        }\n    }\n    DEBUGLOG(4, \"Final idx after probing for dictID %u is: %zu\", dictID, idx);\n    return hashSet->ddictPtrTable[idx];\n}\n\n \nstatic ZSTD_DDictHashSet* ZSTD_createDDictHashSet(ZSTD_customMem customMem) {\n    ZSTD_DDictHashSet* ret = (ZSTD_DDictHashSet*)ZSTD_customMalloc(sizeof(ZSTD_DDictHashSet), customMem);\n    DEBUGLOG(4, \"Allocating new hash set\");\n    if (!ret)\n        return NULL;\n    ret->ddictPtrTable = (const ZSTD_DDict**)ZSTD_customCalloc(DDICT_HASHSET_TABLE_BASE_SIZE * sizeof(ZSTD_DDict*), customMem);\n    if (!ret->ddictPtrTable) {\n        ZSTD_customFree(ret, customMem);\n        return NULL;\n    }\n    ret->ddictPtrTableSize = DDICT_HASHSET_TABLE_BASE_SIZE;\n    ret->ddictPtrCount = 0;\n    return ret;\n}\n\n \nstatic void ZSTD_freeDDictHashSet(ZSTD_DDictHashSet* hashSet, ZSTD_customMem customMem) {\n    DEBUGLOG(4, \"Freeing ddict hash set\");\n    if (hashSet && hashSet->ddictPtrTable) {\n        ZSTD_customFree((void*)hashSet->ddictPtrTable, customMem);\n    }\n    if (hashSet) {\n        ZSTD_customFree(hashSet, customMem);\n    }\n}\n\n \nstatic size_t ZSTD_DDictHashSet_addDDict(ZSTD_DDictHashSet* hashSet, const ZSTD_DDict* ddict, ZSTD_customMem customMem) {\n    DEBUGLOG(4, \"Adding dict ID: %u to hashset with - Count: %zu Tablesize: %zu\", ZSTD_getDictID_fromDDict(ddict), hashSet->ddictPtrCount, hashSet->ddictPtrTableSize);\n    if (hashSet->ddictPtrCount * DDICT_HASHSET_MAX_LOAD_FACTOR_COUNT_MULT / hashSet->ddictPtrTableSize * DDICT_HASHSET_MAX_LOAD_FACTOR_SIZE_MULT != 0) {\n        FORWARD_IF_ERROR(ZSTD_DDictHashSet_expand(hashSet, customMem), \"\");\n    }\n    FORWARD_IF_ERROR(ZSTD_DDictHashSet_emplaceDDict(hashSet, ddict), \"\");\n    return 0;\n}\n\n \nsize_t ZSTD_sizeof_DCtx (const ZSTD_DCtx* dctx)\n{\n    if (dctx==NULL) return 0;    \n    return sizeof(*dctx)\n           + ZSTD_sizeof_DDict(dctx->ddictLocal)\n           + dctx->inBuffSize + dctx->outBuffSize;\n}\n\nsize_t ZSTD_estimateDCtxSize(void) { return sizeof(ZSTD_DCtx); }\n\n\nstatic size_t ZSTD_startingInputLength(ZSTD_format_e format)\n{\n    size_t const startingInputLength = ZSTD_FRAMEHEADERSIZE_PREFIX(format);\n     \n    assert( (format == ZSTD_f_zstd1) || (format == ZSTD_f_zstd1_magicless) );\n    return startingInputLength;\n}\n\nstatic void ZSTD_DCtx_resetParameters(ZSTD_DCtx* dctx)\n{\n    assert(dctx->streamStage == zdss_init);\n    dctx->format = ZSTD_f_zstd1;\n    dctx->maxWindowSize = ZSTD_MAXWINDOWSIZE_DEFAULT;\n    dctx->outBufferMode = ZSTD_bm_buffered;\n    dctx->forceIgnoreChecksum = ZSTD_d_validateChecksum;\n    dctx->refMultipleDDicts = ZSTD_rmd_refSingleDDict;\n}\n\nstatic void ZSTD_initDCtx_internal(ZSTD_DCtx* dctx)\n{\n    dctx->staticSize  = 0;\n    dctx->ddict       = NULL;\n    dctx->ddictLocal  = NULL;\n    dctx->dictEnd     = NULL;\n    dctx->ddictIsCold = 0;\n    dctx->dictUses = ZSTD_dont_use;\n    dctx->inBuff      = NULL;\n    dctx->inBuffSize  = 0;\n    dctx->outBuffSize = 0;\n    dctx->streamStage = zdss_init;\n    dctx->noForwardProgress = 0;\n    dctx->oversizedDuration = 0;\n#if DYNAMIC_BMI2\n    dctx->bmi2 = ZSTD_cpuSupportsBmi2();\n#endif\n    dctx->ddictSet = NULL;\n    ZSTD_DCtx_resetParameters(dctx);\n#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION\n    dctx->dictContentEndForFuzzing = NULL;\n#endif\n}\n\nZSTD_DCtx* ZSTD_initStaticDCtx(void *workspace, size_t workspaceSize)\n{\n    ZSTD_DCtx* const dctx = (ZSTD_DCtx*) workspace;\n\n    if ((size_t)workspace & 7) return NULL;   \n    if (workspaceSize < sizeof(ZSTD_DCtx)) return NULL;   \n\n    ZSTD_initDCtx_internal(dctx);\n    dctx->staticSize = workspaceSize;\n    dctx->inBuff = (char*)(dctx+1);\n    return dctx;\n}\n\nstatic ZSTD_DCtx* ZSTD_createDCtx_internal(ZSTD_customMem customMem) {\n    if ((!customMem.customAlloc) ^ (!customMem.customFree)) return NULL;\n\n    {   ZSTD_DCtx* const dctx = (ZSTD_DCtx*)ZSTD_customMalloc(sizeof(*dctx), customMem);\n        if (!dctx) return NULL;\n        dctx->customMem = customMem;\n        ZSTD_initDCtx_internal(dctx);\n        return dctx;\n    }\n}\n\nZSTD_DCtx* ZSTD_createDCtx_advanced(ZSTD_customMem customMem)\n{\n    return ZSTD_createDCtx_internal(customMem);\n}\n\nZSTD_DCtx* ZSTD_createDCtx(void)\n{\n    DEBUGLOG(3, \"ZSTD_createDCtx\");\n    return ZSTD_createDCtx_internal(ZSTD_defaultCMem);\n}\n\nstatic void ZSTD_clearDict(ZSTD_DCtx* dctx)\n{\n    ZSTD_freeDDict(dctx->ddictLocal);\n    dctx->ddictLocal = NULL;\n    dctx->ddict = NULL;\n    dctx->dictUses = ZSTD_dont_use;\n}\n\nsize_t ZSTD_freeDCtx(ZSTD_DCtx* dctx)\n{\n    if (dctx==NULL) return 0;    \n    RETURN_ERROR_IF(dctx->staticSize, memory_allocation, \"not compatible with static DCtx\");\n    {   ZSTD_customMem const cMem = dctx->customMem;\n        ZSTD_clearDict(dctx);\n        ZSTD_customFree(dctx->inBuff, cMem);\n        dctx->inBuff = NULL;\n        if (dctx->ddictSet) {\n            ZSTD_freeDDictHashSet(dctx->ddictSet, cMem);\n            dctx->ddictSet = NULL;\n        }\n        ZSTD_customFree(dctx, cMem);\n        return 0;\n    }\n}\n\n \nvoid ZSTD_copyDCtx(ZSTD_DCtx* dstDCtx, const ZSTD_DCtx* srcDCtx)\n{\n    size_t const toCopy = (size_t)((char*)(&dstDCtx->inBuff) - (char*)dstDCtx);\n    ZSTD_memcpy(dstDCtx, srcDCtx, toCopy);   \n}\n\n \nstatic void ZSTD_DCtx_selectFrameDDict(ZSTD_DCtx* dctx) {\n    assert(dctx->refMultipleDDicts && dctx->ddictSet);\n    DEBUGLOG(4, \"Adjusting DDict based on requested dict ID from frame\");\n    if (dctx->ddict) {\n        const ZSTD_DDict* frameDDict = ZSTD_DDictHashSet_getDDict(dctx->ddictSet, dctx->fParams.dictID);\n        if (frameDDict) {\n            DEBUGLOG(4, \"DDict found!\");\n            ZSTD_clearDict(dctx);\n            dctx->dictID = dctx->fParams.dictID;\n            dctx->ddict = frameDDict;\n            dctx->dictUses = ZSTD_use_indefinitely;\n        }\n    }\n}\n\n\n \n\n \nunsigned ZSTD_isFrame(const void* buffer, size_t size)\n{\n    if (size < ZSTD_FRAMEIDSIZE) return 0;\n    {   U32 const magic = MEM_readLE32(buffer);\n        if (magic == ZSTD_MAGICNUMBER) return 1;\n        if ((magic & ZSTD_MAGIC_SKIPPABLE_MASK) == ZSTD_MAGIC_SKIPPABLE_START) return 1;\n    }\n    return 0;\n}\n\n \nunsigned ZSTD_isSkippableFrame(const void* buffer, size_t size)\n{\n    if (size < ZSTD_FRAMEIDSIZE) return 0;\n    {   U32 const magic = MEM_readLE32(buffer);\n        if ((magic & ZSTD_MAGIC_SKIPPABLE_MASK) == ZSTD_MAGIC_SKIPPABLE_START) return 1;\n    }\n    return 0;\n}\n\n \nstatic size_t ZSTD_frameHeaderSize_internal(const void* src, size_t srcSize, ZSTD_format_e format)\n{\n    size_t const minInputSize = ZSTD_startingInputLength(format);\n    RETURN_ERROR_IF(srcSize < minInputSize, srcSize_wrong, \"\");\n\n    {   BYTE const fhd = ((const BYTE*)src)[minInputSize-1];\n        U32 const dictID= fhd & 3;\n        U32 const singleSegment = (fhd >> 5) & 1;\n        U32 const fcsId = fhd >> 6;\n        return minInputSize + !singleSegment\n             + ZSTD_did_fieldSize[dictID] + ZSTD_fcs_fieldSize[fcsId]\n             + (singleSegment && !fcsId);\n    }\n}\n\n \nsize_t ZSTD_frameHeaderSize(const void* src, size_t srcSize)\n{\n    return ZSTD_frameHeaderSize_internal(src, srcSize, ZSTD_f_zstd1);\n}\n\n\n \nsize_t ZSTD_getFrameHeader_advanced(ZSTD_frameHeader* zfhPtr, const void* src, size_t srcSize, ZSTD_format_e format)\n{\n    const BYTE* ip = (const BYTE*)src;\n    size_t const minInputSize = ZSTD_startingInputLength(format);\n\n    ZSTD_memset(zfhPtr, 0, sizeof(*zfhPtr));    \n    if (srcSize < minInputSize) return minInputSize;\n    RETURN_ERROR_IF(src==NULL, GENERIC, \"invalid parameter\");\n\n    if ( (format != ZSTD_f_zstd1_magicless)\n      && (MEM_readLE32(src) != ZSTD_MAGICNUMBER) ) {\n        if ((MEM_readLE32(src) & ZSTD_MAGIC_SKIPPABLE_MASK) == ZSTD_MAGIC_SKIPPABLE_START) {\n             \n            if (srcSize < ZSTD_SKIPPABLEHEADERSIZE)\n                return ZSTD_SKIPPABLEHEADERSIZE;  \n            ZSTD_memset(zfhPtr, 0, sizeof(*zfhPtr));\n            zfhPtr->frameContentSize = MEM_readLE32((const char *)src + ZSTD_FRAMEIDSIZE);\n            zfhPtr->frameType = ZSTD_skippableFrame;\n            return 0;\n        }\n        RETURN_ERROR(prefix_unknown, \"\");\n    }\n\n     \n    {   size_t const fhsize = ZSTD_frameHeaderSize_internal(src, srcSize, format);\n        if (srcSize < fhsize) return fhsize;\n        zfhPtr->headerSize = (U32)fhsize;\n    }\n\n    {   BYTE const fhdByte = ip[minInputSize-1];\n        size_t pos = minInputSize;\n        U32 const dictIDSizeCode = fhdByte&3;\n        U32 const checksumFlag = (fhdByte>>2)&1;\n        U32 const singleSegment = (fhdByte>>5)&1;\n        U32 const fcsID = fhdByte>>6;\n        U64 windowSize = 0;\n        U32 dictID = 0;\n        U64 frameContentSize = ZSTD_CONTENTSIZE_UNKNOWN;\n        RETURN_ERROR_IF((fhdByte & 0x08) != 0, frameParameter_unsupported,\n                        \"reserved bits, must be zero\");\n\n        if (!singleSegment) {\n            BYTE const wlByte = ip[pos++];\n            U32 const windowLog = (wlByte >> 3) + ZSTD_WINDOWLOG_ABSOLUTEMIN;\n            RETURN_ERROR_IF(windowLog > ZSTD_WINDOWLOG_MAX, frameParameter_windowTooLarge, \"\");\n            windowSize = (1ULL << windowLog);\n            windowSize += (windowSize >> 3) * (wlByte&7);\n        }\n        switch(dictIDSizeCode)\n        {\n            default:\n                assert(0);   \n                ZSTD_FALLTHROUGH;\n            case 0 : break;\n            case 1 : dictID = ip[pos]; pos++; break;\n            case 2 : dictID = MEM_readLE16(ip+pos); pos+=2; break;\n            case 3 : dictID = MEM_readLE32(ip+pos); pos+=4; break;\n        }\n        switch(fcsID)\n        {\n            default:\n                assert(0);   \n                ZSTD_FALLTHROUGH;\n            case 0 : if (singleSegment) frameContentSize = ip[pos]; break;\n            case 1 : frameContentSize = MEM_readLE16(ip+pos)+256; break;\n            case 2 : frameContentSize = MEM_readLE32(ip+pos); break;\n            case 3 : frameContentSize = MEM_readLE64(ip+pos); break;\n        }\n        if (singleSegment) windowSize = frameContentSize;\n\n        zfhPtr->frameType = ZSTD_frame;\n        zfhPtr->frameContentSize = frameContentSize;\n        zfhPtr->windowSize = windowSize;\n        zfhPtr->blockSizeMax = (unsigned) MIN(windowSize, ZSTD_BLOCKSIZE_MAX);\n        zfhPtr->dictID = dictID;\n        zfhPtr->checksumFlag = checksumFlag;\n    }\n    return 0;\n}\n\n \nsize_t ZSTD_getFrameHeader(ZSTD_frameHeader* zfhPtr, const void* src, size_t srcSize)\n{\n    return ZSTD_getFrameHeader_advanced(zfhPtr, src, srcSize, ZSTD_f_zstd1);\n}\n\n \nunsigned long long ZSTD_getFrameContentSize(const void *src, size_t srcSize)\n{\n    {   ZSTD_frameHeader zfh;\n        if (ZSTD_getFrameHeader(&zfh, src, srcSize) != 0)\n            return ZSTD_CONTENTSIZE_ERROR;\n        if (zfh.frameType == ZSTD_skippableFrame) {\n            return 0;\n        } else {\n            return zfh.frameContentSize;\n    }   }\n}\n\nstatic size_t readSkippableFrameSize(void const* src, size_t srcSize)\n{\n    size_t const skippableHeaderSize = ZSTD_SKIPPABLEHEADERSIZE;\n    U32 sizeU32;\n\n    RETURN_ERROR_IF(srcSize < ZSTD_SKIPPABLEHEADERSIZE, srcSize_wrong, \"\");\n\n    sizeU32 = MEM_readLE32((BYTE const*)src + ZSTD_FRAMEIDSIZE);\n    RETURN_ERROR_IF((U32)(sizeU32 + ZSTD_SKIPPABLEHEADERSIZE) < sizeU32,\n                    frameParameter_unsupported, \"\");\n    {\n        size_t const skippableSize = skippableHeaderSize + sizeU32;\n        RETURN_ERROR_IF(skippableSize > srcSize, srcSize_wrong, \"\");\n        return skippableSize;\n    }\n}\n\n \nZSTDLIB_API size_t ZSTD_readSkippableFrame(void* dst, size_t dstCapacity, unsigned* magicVariant,\n                                            const void* src, size_t srcSize)\n{\n    U32 const magicNumber = MEM_readLE32(src);\n    size_t skippableFrameSize = readSkippableFrameSize(src, srcSize);\n    size_t skippableContentSize = skippableFrameSize - ZSTD_SKIPPABLEHEADERSIZE;\n\n     \n    RETURN_ERROR_IF(!ZSTD_isSkippableFrame(src, srcSize), frameParameter_unsupported, \"\");\n    RETURN_ERROR_IF(skippableFrameSize < ZSTD_SKIPPABLEHEADERSIZE || skippableFrameSize > srcSize, srcSize_wrong, \"\");\n    RETURN_ERROR_IF(skippableContentSize > dstCapacity, dstSize_tooSmall, \"\");\n\n     \n    if (skippableContentSize > 0  && dst != NULL)\n        ZSTD_memcpy(dst, (const BYTE *)src + ZSTD_SKIPPABLEHEADERSIZE, skippableContentSize);\n    if (magicVariant != NULL)\n        *magicVariant = magicNumber - ZSTD_MAGIC_SKIPPABLE_START;\n    return skippableContentSize;\n}\n\n \nunsigned long long ZSTD_findDecompressedSize(const void* src, size_t srcSize)\n{\n    unsigned long long totalDstSize = 0;\n\n    while (srcSize >= ZSTD_startingInputLength(ZSTD_f_zstd1)) {\n        U32 const magicNumber = MEM_readLE32(src);\n\n        if ((magicNumber & ZSTD_MAGIC_SKIPPABLE_MASK) == ZSTD_MAGIC_SKIPPABLE_START) {\n            size_t const skippableSize = readSkippableFrameSize(src, srcSize);\n            if (ZSTD_isError(skippableSize)) {\n                return ZSTD_CONTENTSIZE_ERROR;\n            }\n            assert(skippableSize <= srcSize);\n\n            src = (const BYTE *)src + skippableSize;\n            srcSize -= skippableSize;\n            continue;\n        }\n\n        {   unsigned long long const ret = ZSTD_getFrameContentSize(src, srcSize);\n            if (ret >= ZSTD_CONTENTSIZE_ERROR) return ret;\n\n             \n            if (totalDstSize + ret < totalDstSize) return ZSTD_CONTENTSIZE_ERROR;\n            totalDstSize += ret;\n        }\n        {   size_t const frameSrcSize = ZSTD_findFrameCompressedSize(src, srcSize);\n            if (ZSTD_isError(frameSrcSize)) {\n                return ZSTD_CONTENTSIZE_ERROR;\n            }\n\n            src = (const BYTE *)src + frameSrcSize;\n            srcSize -= frameSrcSize;\n        }\n    }   \n\n    if (srcSize) return ZSTD_CONTENTSIZE_ERROR;\n\n    return totalDstSize;\n}\n\n \nunsigned long long ZSTD_getDecompressedSize(const void* src, size_t srcSize)\n{\n    unsigned long long const ret = ZSTD_getFrameContentSize(src, srcSize);\n    ZSTD_STATIC_ASSERT(ZSTD_CONTENTSIZE_ERROR < ZSTD_CONTENTSIZE_UNKNOWN);\n    return (ret >= ZSTD_CONTENTSIZE_ERROR) ? 0 : ret;\n}\n\n\n \nstatic size_t ZSTD_decodeFrameHeader(ZSTD_DCtx* dctx, const void* src, size_t headerSize)\n{\n    size_t const result = ZSTD_getFrameHeader_advanced(&(dctx->fParams), src, headerSize, dctx->format);\n    if (ZSTD_isError(result)) return result;     \n    RETURN_ERROR_IF(result>0, srcSize_wrong, \"headerSize too small\");\n\n     \n    if (dctx->refMultipleDDicts == ZSTD_rmd_refMultipleDDicts && dctx->ddictSet) {\n        ZSTD_DCtx_selectFrameDDict(dctx);\n    }\n\n#ifndef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION\n     \n    RETURN_ERROR_IF(dctx->fParams.dictID && (dctx->dictID != dctx->fParams.dictID),\n                    dictionary_wrong, \"\");\n#endif\n    dctx->validateChecksum = (dctx->fParams.checksumFlag && !dctx->forceIgnoreChecksum) ? 1 : 0;\n    if (dctx->validateChecksum) xxh64_reset(&dctx->xxhState, 0);\n    dctx->processedCSize += headerSize;\n    return 0;\n}\n\nstatic ZSTD_frameSizeInfo ZSTD_errorFrameSizeInfo(size_t ret)\n{\n    ZSTD_frameSizeInfo frameSizeInfo;\n    frameSizeInfo.compressedSize = ret;\n    frameSizeInfo.decompressedBound = ZSTD_CONTENTSIZE_ERROR;\n    return frameSizeInfo;\n}\n\nstatic ZSTD_frameSizeInfo ZSTD_findFrameSizeInfo(const void* src, size_t srcSize)\n{\n    ZSTD_frameSizeInfo frameSizeInfo;\n    ZSTD_memset(&frameSizeInfo, 0, sizeof(ZSTD_frameSizeInfo));\n\n\n    if ((srcSize >= ZSTD_SKIPPABLEHEADERSIZE)\n        && (MEM_readLE32(src) & ZSTD_MAGIC_SKIPPABLE_MASK) == ZSTD_MAGIC_SKIPPABLE_START) {\n        frameSizeInfo.compressedSize = readSkippableFrameSize(src, srcSize);\n        assert(ZSTD_isError(frameSizeInfo.compressedSize) ||\n               frameSizeInfo.compressedSize <= srcSize);\n        return frameSizeInfo;\n    } else {\n        const BYTE* ip = (const BYTE*)src;\n        const BYTE* const ipstart = ip;\n        size_t remainingSize = srcSize;\n        size_t nbBlocks = 0;\n        ZSTD_frameHeader zfh;\n\n         \n        {   size_t const ret = ZSTD_getFrameHeader(&zfh, src, srcSize);\n            if (ZSTD_isError(ret))\n                return ZSTD_errorFrameSizeInfo(ret);\n            if (ret > 0)\n                return ZSTD_errorFrameSizeInfo(ERROR(srcSize_wrong));\n        }\n\n        ip += zfh.headerSize;\n        remainingSize -= zfh.headerSize;\n\n         \n        while (1) {\n            blockProperties_t blockProperties;\n            size_t const cBlockSize = ZSTD_getcBlockSize(ip, remainingSize, &blockProperties);\n            if (ZSTD_isError(cBlockSize))\n                return ZSTD_errorFrameSizeInfo(cBlockSize);\n\n            if (ZSTD_blockHeaderSize + cBlockSize > remainingSize)\n                return ZSTD_errorFrameSizeInfo(ERROR(srcSize_wrong));\n\n            ip += ZSTD_blockHeaderSize + cBlockSize;\n            remainingSize -= ZSTD_blockHeaderSize + cBlockSize;\n            nbBlocks++;\n\n            if (blockProperties.lastBlock) break;\n        }\n\n         \n        if (zfh.checksumFlag) {\n            if (remainingSize < 4)\n                return ZSTD_errorFrameSizeInfo(ERROR(srcSize_wrong));\n            ip += 4;\n        }\n\n        frameSizeInfo.compressedSize = (size_t)(ip - ipstart);\n        frameSizeInfo.decompressedBound = (zfh.frameContentSize != ZSTD_CONTENTSIZE_UNKNOWN)\n                                        ? zfh.frameContentSize\n                                        : nbBlocks * zfh.blockSizeMax;\n        return frameSizeInfo;\n    }\n}\n\n \nsize_t ZSTD_findFrameCompressedSize(const void *src, size_t srcSize)\n{\n    ZSTD_frameSizeInfo const frameSizeInfo = ZSTD_findFrameSizeInfo(src, srcSize);\n    return frameSizeInfo.compressedSize;\n}\n\n \nunsigned long long ZSTD_decompressBound(const void* src, size_t srcSize)\n{\n    unsigned long long bound = 0;\n     \n    while (srcSize > 0) {\n        ZSTD_frameSizeInfo const frameSizeInfo = ZSTD_findFrameSizeInfo(src, srcSize);\n        size_t const compressedSize = frameSizeInfo.compressedSize;\n        unsigned long long const decompressedBound = frameSizeInfo.decompressedBound;\n        if (ZSTD_isError(compressedSize) || decompressedBound == ZSTD_CONTENTSIZE_ERROR)\n            return ZSTD_CONTENTSIZE_ERROR;\n        assert(srcSize >= compressedSize);\n        src = (const BYTE*)src + compressedSize;\n        srcSize -= compressedSize;\n        bound += decompressedBound;\n    }\n    return bound;\n}\n\n\n \n\n \nsize_t ZSTD_insertBlock(ZSTD_DCtx* dctx, const void* blockStart, size_t blockSize)\n{\n    DEBUGLOG(5, \"ZSTD_insertBlock: %u bytes\", (unsigned)blockSize);\n    ZSTD_checkContinuity(dctx, blockStart, blockSize);\n    dctx->previousDstEnd = (const char*)blockStart + blockSize;\n    return blockSize;\n}\n\n\nstatic size_t ZSTD_copyRawBlock(void* dst, size_t dstCapacity,\n                          const void* src, size_t srcSize)\n{\n    DEBUGLOG(5, \"ZSTD_copyRawBlock\");\n    RETURN_ERROR_IF(srcSize > dstCapacity, dstSize_tooSmall, \"\");\n    if (dst == NULL) {\n        if (srcSize == 0) return 0;\n        RETURN_ERROR(dstBuffer_null, \"\");\n    }\n    ZSTD_memmove(dst, src, srcSize);\n    return srcSize;\n}\n\nstatic size_t ZSTD_setRleBlock(void* dst, size_t dstCapacity,\n                               BYTE b,\n                               size_t regenSize)\n{\n    RETURN_ERROR_IF(regenSize > dstCapacity, dstSize_tooSmall, \"\");\n    if (dst == NULL) {\n        if (regenSize == 0) return 0;\n        RETURN_ERROR(dstBuffer_null, \"\");\n    }\n    ZSTD_memset(dst, b, regenSize);\n    return regenSize;\n}\n\nstatic void ZSTD_DCtx_trace_end(ZSTD_DCtx const* dctx, U64 uncompressedSize, U64 compressedSize, unsigned streaming)\n{\n    (void)dctx;\n    (void)uncompressedSize;\n    (void)compressedSize;\n    (void)streaming;\n}\n\n\n \nstatic size_t ZSTD_decompressFrame(ZSTD_DCtx* dctx,\n                                   void* dst, size_t dstCapacity,\n                             const void** srcPtr, size_t *srcSizePtr)\n{\n    const BYTE* const istart = (const BYTE*)(*srcPtr);\n    const BYTE* ip = istart;\n    BYTE* const ostart = (BYTE*)dst;\n    BYTE* const oend = dstCapacity != 0 ? ostart + dstCapacity : ostart;\n    BYTE* op = ostart;\n    size_t remainingSrcSize = *srcSizePtr;\n\n    DEBUGLOG(4, \"ZSTD_decompressFrame (srcSize:%i)\", (int)*srcSizePtr);\n\n     \n    RETURN_ERROR_IF(\n        remainingSrcSize < ZSTD_FRAMEHEADERSIZE_MIN(dctx->format)+ZSTD_blockHeaderSize,\n        srcSize_wrong, \"\");\n\n     \n    {   size_t const frameHeaderSize = ZSTD_frameHeaderSize_internal(\n                ip, ZSTD_FRAMEHEADERSIZE_PREFIX(dctx->format), dctx->format);\n        if (ZSTD_isError(frameHeaderSize)) return frameHeaderSize;\n        RETURN_ERROR_IF(remainingSrcSize < frameHeaderSize+ZSTD_blockHeaderSize,\n                        srcSize_wrong, \"\");\n        FORWARD_IF_ERROR( ZSTD_decodeFrameHeader(dctx, ip, frameHeaderSize) , \"\");\n        ip += frameHeaderSize; remainingSrcSize -= frameHeaderSize;\n    }\n\n     \n    while (1) {\n        BYTE* oBlockEnd = oend;\n        size_t decodedSize;\n        blockProperties_t blockProperties;\n        size_t const cBlockSize = ZSTD_getcBlockSize(ip, remainingSrcSize, &blockProperties);\n        if (ZSTD_isError(cBlockSize)) return cBlockSize;\n\n        ip += ZSTD_blockHeaderSize;\n        remainingSrcSize -= ZSTD_blockHeaderSize;\n        RETURN_ERROR_IF(cBlockSize > remainingSrcSize, srcSize_wrong, \"\");\n\n        if (ip >= op && ip < oBlockEnd) {\n             \n            oBlockEnd = op + (ip - op);\n        }\n\n        switch(blockProperties.blockType)\n        {\n        case bt_compressed:\n            decodedSize = ZSTD_decompressBlock_internal(dctx, op, (size_t)(oBlockEnd-op), ip, cBlockSize,   1, not_streaming);\n            break;\n        case bt_raw :\n             \n            decodedSize = ZSTD_copyRawBlock(op, (size_t)(oend-op), ip, cBlockSize);\n            break;\n        case bt_rle :\n            decodedSize = ZSTD_setRleBlock(op, (size_t)(oBlockEnd-op), *ip, blockProperties.origSize);\n            break;\n        case bt_reserved :\n        default:\n            RETURN_ERROR(corruption_detected, \"invalid block type\");\n        }\n\n        if (ZSTD_isError(decodedSize)) return decodedSize;\n        if (dctx->validateChecksum)\n            xxh64_update(&dctx->xxhState, op, decodedSize);\n        if (decodedSize != 0)\n            op += decodedSize;\n        assert(ip != NULL);\n        ip += cBlockSize;\n        remainingSrcSize -= cBlockSize;\n        if (blockProperties.lastBlock) break;\n    }\n\n    if (dctx->fParams.frameContentSize != ZSTD_CONTENTSIZE_UNKNOWN) {\n        RETURN_ERROR_IF((U64)(op-ostart) != dctx->fParams.frameContentSize,\n                        corruption_detected, \"\");\n    }\n    if (dctx->fParams.checksumFlag) {  \n        RETURN_ERROR_IF(remainingSrcSize<4, checksum_wrong, \"\");\n        if (!dctx->forceIgnoreChecksum) {\n            U32 const checkCalc = (U32)xxh64_digest(&dctx->xxhState);\n            U32 checkRead;\n            checkRead = MEM_readLE32(ip);\n            RETURN_ERROR_IF(checkRead != checkCalc, checksum_wrong, \"\");\n        }\n        ip += 4;\n        remainingSrcSize -= 4;\n    }\n    ZSTD_DCtx_trace_end(dctx, (U64)(op-ostart), (U64)(ip-istart),   0);\n     \n    *srcPtr = ip;\n    *srcSizePtr = remainingSrcSize;\n    return (size_t)(op-ostart);\n}\n\nstatic size_t ZSTD_decompressMultiFrame(ZSTD_DCtx* dctx,\n                                        void* dst, size_t dstCapacity,\n                                  const void* src, size_t srcSize,\n                                  const void* dict, size_t dictSize,\n                                  const ZSTD_DDict* ddict)\n{\n    void* const dststart = dst;\n    int moreThan1Frame = 0;\n\n    DEBUGLOG(5, \"ZSTD_decompressMultiFrame\");\n    assert(dict==NULL || ddict==NULL);   \n\n    if (ddict) {\n        dict = ZSTD_DDict_dictContent(ddict);\n        dictSize = ZSTD_DDict_dictSize(ddict);\n    }\n\n    while (srcSize >= ZSTD_startingInputLength(dctx->format)) {\n\n\n        {   U32 const magicNumber = MEM_readLE32(src);\n            DEBUGLOG(4, \"reading magic number %08X (expecting %08X)\",\n                        (unsigned)magicNumber, ZSTD_MAGICNUMBER);\n            if ((magicNumber & ZSTD_MAGIC_SKIPPABLE_MASK) == ZSTD_MAGIC_SKIPPABLE_START) {\n                size_t const skippableSize = readSkippableFrameSize(src, srcSize);\n                FORWARD_IF_ERROR(skippableSize, \"readSkippableFrameSize failed\");\n                assert(skippableSize <= srcSize);\n\n                src = (const BYTE *)src + skippableSize;\n                srcSize -= skippableSize;\n                continue;\n        }   }\n\n        if (ddict) {\n             \n            FORWARD_IF_ERROR(ZSTD_decompressBegin_usingDDict(dctx, ddict), \"\");\n        } else {\n             \n            FORWARD_IF_ERROR(ZSTD_decompressBegin_usingDict(dctx, dict, dictSize), \"\");\n        }\n        ZSTD_checkContinuity(dctx, dst, dstCapacity);\n\n        {   const size_t res = ZSTD_decompressFrame(dctx, dst, dstCapacity,\n                                                    &src, &srcSize);\n            RETURN_ERROR_IF(\n                (ZSTD_getErrorCode(res) == ZSTD_error_prefix_unknown)\n             && (moreThan1Frame==1),\n                srcSize_wrong,\n                \"At least one frame successfully completed, \"\n                \"but following bytes are garbage: \"\n                \"it's more likely to be a srcSize error, \"\n                \"specifying more input bytes than size of frame(s). \"\n                \"Note: one could be unlucky, it might be a corruption error instead, \"\n                \"happening right at the place where we expect zstd magic bytes. \"\n                \"But this is _much_ less likely than a srcSize field error.\");\n            if (ZSTD_isError(res)) return res;\n            assert(res <= dstCapacity);\n            if (res != 0)\n                dst = (BYTE*)dst + res;\n            dstCapacity -= res;\n        }\n        moreThan1Frame = 1;\n    }   \n\n    RETURN_ERROR_IF(srcSize, srcSize_wrong, \"input not entirely consumed\");\n\n    return (size_t)((BYTE*)dst - (BYTE*)dststart);\n}\n\nsize_t ZSTD_decompress_usingDict(ZSTD_DCtx* dctx,\n                                 void* dst, size_t dstCapacity,\n                           const void* src, size_t srcSize,\n                           const void* dict, size_t dictSize)\n{\n    return ZSTD_decompressMultiFrame(dctx, dst, dstCapacity, src, srcSize, dict, dictSize, NULL);\n}\n\n\nstatic ZSTD_DDict const* ZSTD_getDDict(ZSTD_DCtx* dctx)\n{\n    switch (dctx->dictUses) {\n    default:\n        assert(0  );\n        ZSTD_FALLTHROUGH;\n    case ZSTD_dont_use:\n        ZSTD_clearDict(dctx);\n        return NULL;\n    case ZSTD_use_indefinitely:\n        return dctx->ddict;\n    case ZSTD_use_once:\n        dctx->dictUses = ZSTD_dont_use;\n        return dctx->ddict;\n    }\n}\n\nsize_t ZSTD_decompressDCtx(ZSTD_DCtx* dctx, void* dst, size_t dstCapacity, const void* src, size_t srcSize)\n{\n    return ZSTD_decompress_usingDDict(dctx, dst, dstCapacity, src, srcSize, ZSTD_getDDict(dctx));\n}\n\n\nsize_t ZSTD_decompress(void* dst, size_t dstCapacity, const void* src, size_t srcSize)\n{\n#if defined(ZSTD_HEAPMODE) && (ZSTD_HEAPMODE>=1)\n    size_t regenSize;\n    ZSTD_DCtx* const dctx =  ZSTD_createDCtx_internal(ZSTD_defaultCMem);\n    RETURN_ERROR_IF(dctx==NULL, memory_allocation, \"NULL pointer!\");\n    regenSize = ZSTD_decompressDCtx(dctx, dst, dstCapacity, src, srcSize);\n    ZSTD_freeDCtx(dctx);\n    return regenSize;\n#else    \n    ZSTD_DCtx dctx;\n    ZSTD_initDCtx_internal(&dctx);\n    return ZSTD_decompressDCtx(&dctx, dst, dstCapacity, src, srcSize);\n#endif\n}\n\n\n \nsize_t ZSTD_nextSrcSizeToDecompress(ZSTD_DCtx* dctx) { return dctx->expected; }\n\n \nstatic size_t ZSTD_nextSrcSizeToDecompressWithInputSize(ZSTD_DCtx* dctx, size_t inputSize) {\n    if (!(dctx->stage == ZSTDds_decompressBlock || dctx->stage == ZSTDds_decompressLastBlock))\n        return dctx->expected;\n    if (dctx->bType != bt_raw)\n        return dctx->expected;\n    return BOUNDED(1, inputSize, dctx->expected);\n}\n\nZSTD_nextInputType_e ZSTD_nextInputType(ZSTD_DCtx* dctx) {\n    switch(dctx->stage)\n    {\n    default:    \n        assert(0);\n        ZSTD_FALLTHROUGH;\n    case ZSTDds_getFrameHeaderSize:\n        ZSTD_FALLTHROUGH;\n    case ZSTDds_decodeFrameHeader:\n        return ZSTDnit_frameHeader;\n    case ZSTDds_decodeBlockHeader:\n        return ZSTDnit_blockHeader;\n    case ZSTDds_decompressBlock:\n        return ZSTDnit_block;\n    case ZSTDds_decompressLastBlock:\n        return ZSTDnit_lastBlock;\n    case ZSTDds_checkChecksum:\n        return ZSTDnit_checksum;\n    case ZSTDds_decodeSkippableHeader:\n        ZSTD_FALLTHROUGH;\n    case ZSTDds_skipFrame:\n        return ZSTDnit_skippableFrame;\n    }\n}\n\nstatic int ZSTD_isSkipFrame(ZSTD_DCtx* dctx) { return dctx->stage == ZSTDds_skipFrame; }\n\n \nsize_t ZSTD_decompressContinue(ZSTD_DCtx* dctx, void* dst, size_t dstCapacity, const void* src, size_t srcSize)\n{\n    DEBUGLOG(5, \"ZSTD_decompressContinue (srcSize:%u)\", (unsigned)srcSize);\n     \n    RETURN_ERROR_IF(srcSize != ZSTD_nextSrcSizeToDecompressWithInputSize(dctx, srcSize), srcSize_wrong, \"not allowed\");\n    ZSTD_checkContinuity(dctx, dst, dstCapacity);\n\n    dctx->processedCSize += srcSize;\n\n    switch (dctx->stage)\n    {\n    case ZSTDds_getFrameHeaderSize :\n        assert(src != NULL);\n        if (dctx->format == ZSTD_f_zstd1) {   \n            assert(srcSize >= ZSTD_FRAMEIDSIZE);   \n            if ((MEM_readLE32(src) & ZSTD_MAGIC_SKIPPABLE_MASK) == ZSTD_MAGIC_SKIPPABLE_START) {         \n                ZSTD_memcpy(dctx->headerBuffer, src, srcSize);\n                dctx->expected = ZSTD_SKIPPABLEHEADERSIZE - srcSize;   \n                dctx->stage = ZSTDds_decodeSkippableHeader;\n                return 0;\n        }   }\n        dctx->headerSize = ZSTD_frameHeaderSize_internal(src, srcSize, dctx->format);\n        if (ZSTD_isError(dctx->headerSize)) return dctx->headerSize;\n        ZSTD_memcpy(dctx->headerBuffer, src, srcSize);\n        dctx->expected = dctx->headerSize - srcSize;\n        dctx->stage = ZSTDds_decodeFrameHeader;\n        return 0;\n\n    case ZSTDds_decodeFrameHeader:\n        assert(src != NULL);\n        ZSTD_memcpy(dctx->headerBuffer + (dctx->headerSize - srcSize), src, srcSize);\n        FORWARD_IF_ERROR(ZSTD_decodeFrameHeader(dctx, dctx->headerBuffer, dctx->headerSize), \"\");\n        dctx->expected = ZSTD_blockHeaderSize;\n        dctx->stage = ZSTDds_decodeBlockHeader;\n        return 0;\n\n    case ZSTDds_decodeBlockHeader:\n        {   blockProperties_t bp;\n            size_t const cBlockSize = ZSTD_getcBlockSize(src, ZSTD_blockHeaderSize, &bp);\n            if (ZSTD_isError(cBlockSize)) return cBlockSize;\n            RETURN_ERROR_IF(cBlockSize > dctx->fParams.blockSizeMax, corruption_detected, \"Block Size Exceeds Maximum\");\n            dctx->expected = cBlockSize;\n            dctx->bType = bp.blockType;\n            dctx->rleSize = bp.origSize;\n            if (cBlockSize) {\n                dctx->stage = bp.lastBlock ? ZSTDds_decompressLastBlock : ZSTDds_decompressBlock;\n                return 0;\n            }\n             \n            if (bp.lastBlock) {\n                if (dctx->fParams.checksumFlag) {\n                    dctx->expected = 4;\n                    dctx->stage = ZSTDds_checkChecksum;\n                } else {\n                    dctx->expected = 0;  \n                    dctx->stage = ZSTDds_getFrameHeaderSize;\n                }\n            } else {\n                dctx->expected = ZSTD_blockHeaderSize;   \n                dctx->stage = ZSTDds_decodeBlockHeader;\n            }\n            return 0;\n        }\n\n    case ZSTDds_decompressLastBlock:\n    case ZSTDds_decompressBlock:\n        DEBUGLOG(5, \"ZSTD_decompressContinue: case ZSTDds_decompressBlock\");\n        {   size_t rSize;\n            switch(dctx->bType)\n            {\n            case bt_compressed:\n                DEBUGLOG(5, \"ZSTD_decompressContinue: case bt_compressed\");\n                rSize = ZSTD_decompressBlock_internal(dctx, dst, dstCapacity, src, srcSize,   1, is_streaming);\n                dctx->expected = 0;   \n                break;\n            case bt_raw :\n                assert(srcSize <= dctx->expected);\n                rSize = ZSTD_copyRawBlock(dst, dstCapacity, src, srcSize);\n                FORWARD_IF_ERROR(rSize, \"ZSTD_copyRawBlock failed\");\n                assert(rSize == srcSize);\n                dctx->expected -= rSize;\n                break;\n            case bt_rle :\n                rSize = ZSTD_setRleBlock(dst, dstCapacity, *(const BYTE*)src, dctx->rleSize);\n                dctx->expected = 0;   \n                break;\n            case bt_reserved :    \n            default:\n                RETURN_ERROR(corruption_detected, \"invalid block type\");\n            }\n            FORWARD_IF_ERROR(rSize, \"\");\n            RETURN_ERROR_IF(rSize > dctx->fParams.blockSizeMax, corruption_detected, \"Decompressed Block Size Exceeds Maximum\");\n            DEBUGLOG(5, \"ZSTD_decompressContinue: decoded size from block : %u\", (unsigned)rSize);\n            dctx->decodedSize += rSize;\n            if (dctx->validateChecksum) xxh64_update(&dctx->xxhState, dst, rSize);\n            dctx->previousDstEnd = (char*)dst + rSize;\n\n             \n            if (dctx->expected > 0) {\n                return rSize;\n            }\n\n            if (dctx->stage == ZSTDds_decompressLastBlock) {    \n                DEBUGLOG(4, \"ZSTD_decompressContinue: decoded size from frame : %u\", (unsigned)dctx->decodedSize);\n                RETURN_ERROR_IF(\n                    dctx->fParams.frameContentSize != ZSTD_CONTENTSIZE_UNKNOWN\n                 && dctx->decodedSize != dctx->fParams.frameContentSize,\n                    corruption_detected, \"\");\n                if (dctx->fParams.checksumFlag) {   \n                    dctx->expected = 4;\n                    dctx->stage = ZSTDds_checkChecksum;\n                } else {\n                    ZSTD_DCtx_trace_end(dctx, dctx->decodedSize, dctx->processedCSize,   1);\n                    dctx->expected = 0;    \n                    dctx->stage = ZSTDds_getFrameHeaderSize;\n                }\n            } else {\n                dctx->stage = ZSTDds_decodeBlockHeader;\n                dctx->expected = ZSTD_blockHeaderSize;\n            }\n            return rSize;\n        }\n\n    case ZSTDds_checkChecksum:\n        assert(srcSize == 4);   \n        {\n            if (dctx->validateChecksum) {\n                U32 const h32 = (U32)xxh64_digest(&dctx->xxhState);\n                U32 const check32 = MEM_readLE32(src);\n                DEBUGLOG(4, \"ZSTD_decompressContinue: checksum : calculated %08X :: %08X read\", (unsigned)h32, (unsigned)check32);\n                RETURN_ERROR_IF(check32 != h32, checksum_wrong, \"\");\n            }\n            ZSTD_DCtx_trace_end(dctx, dctx->decodedSize, dctx->processedCSize,   1);\n            dctx->expected = 0;\n            dctx->stage = ZSTDds_getFrameHeaderSize;\n            return 0;\n        }\n\n    case ZSTDds_decodeSkippableHeader:\n        assert(src != NULL);\n        assert(srcSize <= ZSTD_SKIPPABLEHEADERSIZE);\n        ZSTD_memcpy(dctx->headerBuffer + (ZSTD_SKIPPABLEHEADERSIZE - srcSize), src, srcSize);    \n        dctx->expected = MEM_readLE32(dctx->headerBuffer + ZSTD_FRAMEIDSIZE);    \n        dctx->stage = ZSTDds_skipFrame;\n        return 0;\n\n    case ZSTDds_skipFrame:\n        dctx->expected = 0;\n        dctx->stage = ZSTDds_getFrameHeaderSize;\n        return 0;\n\n    default:\n        assert(0);    \n        RETURN_ERROR(GENERIC, \"impossible to reach\");    \n    }\n}\n\n\nstatic size_t ZSTD_refDictContent(ZSTD_DCtx* dctx, const void* dict, size_t dictSize)\n{\n    dctx->dictEnd = dctx->previousDstEnd;\n    dctx->virtualStart = (const char*)dict - ((const char*)(dctx->previousDstEnd) - (const char*)(dctx->prefixStart));\n    dctx->prefixStart = dict;\n    dctx->previousDstEnd = (const char*)dict + dictSize;\n#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION\n    dctx->dictContentBeginForFuzzing = dctx->prefixStart;\n    dctx->dictContentEndForFuzzing = dctx->previousDstEnd;\n#endif\n    return 0;\n}\n\n \nsize_t\nZSTD_loadDEntropy(ZSTD_entropyDTables_t* entropy,\n                  const void* const dict, size_t const dictSize)\n{\n    const BYTE* dictPtr = (const BYTE*)dict;\n    const BYTE* const dictEnd = dictPtr + dictSize;\n\n    RETURN_ERROR_IF(dictSize <= 8, dictionary_corrupted, \"dict is too small\");\n    assert(MEM_readLE32(dict) == ZSTD_MAGIC_DICTIONARY);    \n    dictPtr += 8;    \n\n    ZSTD_STATIC_ASSERT(offsetof(ZSTD_entropyDTables_t, OFTable) == offsetof(ZSTD_entropyDTables_t, LLTable) + sizeof(entropy->LLTable));\n    ZSTD_STATIC_ASSERT(offsetof(ZSTD_entropyDTables_t, MLTable) == offsetof(ZSTD_entropyDTables_t, OFTable) + sizeof(entropy->OFTable));\n    ZSTD_STATIC_ASSERT(sizeof(entropy->LLTable) + sizeof(entropy->OFTable) + sizeof(entropy->MLTable) >= HUF_DECOMPRESS_WORKSPACE_SIZE);\n    {   void* const workspace = &entropy->LLTable;    \n        size_t const workspaceSize = sizeof(entropy->LLTable) + sizeof(entropy->OFTable) + sizeof(entropy->MLTable);\n#ifdef HUF_FORCE_DECOMPRESS_X1\n         \n        size_t const hSize = HUF_readDTableX1_wksp(entropy->hufTable,\n                                                dictPtr, dictEnd - dictPtr,\n                                                workspace, workspaceSize);\n#else\n        size_t const hSize = HUF_readDTableX2_wksp(entropy->hufTable,\n                                                dictPtr, (size_t)(dictEnd - dictPtr),\n                                                workspace, workspaceSize);\n#endif\n        RETURN_ERROR_IF(HUF_isError(hSize), dictionary_corrupted, \"\");\n        dictPtr += hSize;\n    }\n\n    {   short offcodeNCount[MaxOff+1];\n        unsigned offcodeMaxValue = MaxOff, offcodeLog;\n        size_t const offcodeHeaderSize = FSE_readNCount(offcodeNCount, &offcodeMaxValue, &offcodeLog, dictPtr, (size_t)(dictEnd-dictPtr));\n        RETURN_ERROR_IF(FSE_isError(offcodeHeaderSize), dictionary_corrupted, \"\");\n        RETURN_ERROR_IF(offcodeMaxValue > MaxOff, dictionary_corrupted, \"\");\n        RETURN_ERROR_IF(offcodeLog > OffFSELog, dictionary_corrupted, \"\");\n        ZSTD_buildFSETable( entropy->OFTable,\n                            offcodeNCount, offcodeMaxValue,\n                            OF_base, OF_bits,\n                            offcodeLog,\n                            entropy->workspace, sizeof(entropy->workspace),\n                             0);\n        dictPtr += offcodeHeaderSize;\n    }\n\n    {   short matchlengthNCount[MaxML+1];\n        unsigned matchlengthMaxValue = MaxML, matchlengthLog;\n        size_t const matchlengthHeaderSize = FSE_readNCount(matchlengthNCount, &matchlengthMaxValue, &matchlengthLog, dictPtr, (size_t)(dictEnd-dictPtr));\n        RETURN_ERROR_IF(FSE_isError(matchlengthHeaderSize), dictionary_corrupted, \"\");\n        RETURN_ERROR_IF(matchlengthMaxValue > MaxML, dictionary_corrupted, \"\");\n        RETURN_ERROR_IF(matchlengthLog > MLFSELog, dictionary_corrupted, \"\");\n        ZSTD_buildFSETable( entropy->MLTable,\n                            matchlengthNCount, matchlengthMaxValue,\n                            ML_base, ML_bits,\n                            matchlengthLog,\n                            entropy->workspace, sizeof(entropy->workspace),\n                              0);\n        dictPtr += matchlengthHeaderSize;\n    }\n\n    {   short litlengthNCount[MaxLL+1];\n        unsigned litlengthMaxValue = MaxLL, litlengthLog;\n        size_t const litlengthHeaderSize = FSE_readNCount(litlengthNCount, &litlengthMaxValue, &litlengthLog, dictPtr, (size_t)(dictEnd-dictPtr));\n        RETURN_ERROR_IF(FSE_isError(litlengthHeaderSize), dictionary_corrupted, \"\");\n        RETURN_ERROR_IF(litlengthMaxValue > MaxLL, dictionary_corrupted, \"\");\n        RETURN_ERROR_IF(litlengthLog > LLFSELog, dictionary_corrupted, \"\");\n        ZSTD_buildFSETable( entropy->LLTable,\n                            litlengthNCount, litlengthMaxValue,\n                            LL_base, LL_bits,\n                            litlengthLog,\n                            entropy->workspace, sizeof(entropy->workspace),\n                              0);\n        dictPtr += litlengthHeaderSize;\n    }\n\n    RETURN_ERROR_IF(dictPtr+12 > dictEnd, dictionary_corrupted, \"\");\n    {   int i;\n        size_t const dictContentSize = (size_t)(dictEnd - (dictPtr+12));\n        for (i=0; i<3; i++) {\n            U32 const rep = MEM_readLE32(dictPtr); dictPtr += 4;\n            RETURN_ERROR_IF(rep==0 || rep > dictContentSize,\n                            dictionary_corrupted, \"\");\n            entropy->rep[i] = rep;\n    }   }\n\n    return (size_t)(dictPtr - (const BYTE*)dict);\n}\n\nstatic size_t ZSTD_decompress_insertDictionary(ZSTD_DCtx* dctx, const void* dict, size_t dictSize)\n{\n    if (dictSize < 8) return ZSTD_refDictContent(dctx, dict, dictSize);\n    {   U32 const magic = MEM_readLE32(dict);\n        if (magic != ZSTD_MAGIC_DICTIONARY) {\n            return ZSTD_refDictContent(dctx, dict, dictSize);    \n    }   }\n    dctx->dictID = MEM_readLE32((const char*)dict + ZSTD_FRAMEIDSIZE);\n\n     \n    {   size_t const eSize = ZSTD_loadDEntropy(&dctx->entropy, dict, dictSize);\n        RETURN_ERROR_IF(ZSTD_isError(eSize), dictionary_corrupted, \"\");\n        dict = (const char*)dict + eSize;\n        dictSize -= eSize;\n    }\n    dctx->litEntropy = dctx->fseEntropy = 1;\n\n     \n    return ZSTD_refDictContent(dctx, dict, dictSize);\n}\n\nsize_t ZSTD_decompressBegin(ZSTD_DCtx* dctx)\n{\n    assert(dctx != NULL);\n    dctx->expected = ZSTD_startingInputLength(dctx->format);   \n    dctx->stage = ZSTDds_getFrameHeaderSize;\n    dctx->processedCSize = 0;\n    dctx->decodedSize = 0;\n    dctx->previousDstEnd = NULL;\n    dctx->prefixStart = NULL;\n    dctx->virtualStart = NULL;\n    dctx->dictEnd = NULL;\n    dctx->entropy.hufTable[0] = (HUF_DTable)((HufLog)*0x1000001);   \n    dctx->litEntropy = dctx->fseEntropy = 0;\n    dctx->dictID = 0;\n    dctx->bType = bt_reserved;\n    ZSTD_STATIC_ASSERT(sizeof(dctx->entropy.rep) == sizeof(repStartValue));\n    ZSTD_memcpy(dctx->entropy.rep, repStartValue, sizeof(repStartValue));   \n    dctx->LLTptr = dctx->entropy.LLTable;\n    dctx->MLTptr = dctx->entropy.MLTable;\n    dctx->OFTptr = dctx->entropy.OFTable;\n    dctx->HUFptr = dctx->entropy.hufTable;\n    return 0;\n}\n\nsize_t ZSTD_decompressBegin_usingDict(ZSTD_DCtx* dctx, const void* dict, size_t dictSize)\n{\n    FORWARD_IF_ERROR( ZSTD_decompressBegin(dctx) , \"\");\n    if (dict && dictSize)\n        RETURN_ERROR_IF(\n            ZSTD_isError(ZSTD_decompress_insertDictionary(dctx, dict, dictSize)),\n            dictionary_corrupted, \"\");\n    return 0;\n}\n\n\n \n\nsize_t ZSTD_decompressBegin_usingDDict(ZSTD_DCtx* dctx, const ZSTD_DDict* ddict)\n{\n    DEBUGLOG(4, \"ZSTD_decompressBegin_usingDDict\");\n    assert(dctx != NULL);\n    if (ddict) {\n        const char* const dictStart = (const char*)ZSTD_DDict_dictContent(ddict);\n        size_t const dictSize = ZSTD_DDict_dictSize(ddict);\n        const void* const dictEnd = dictStart + dictSize;\n        dctx->ddictIsCold = (dctx->dictEnd != dictEnd);\n        DEBUGLOG(4, \"DDict is %s\",\n                    dctx->ddictIsCold ? \"~cold~\" : \"hot!\");\n    }\n    FORWARD_IF_ERROR( ZSTD_decompressBegin(dctx) , \"\");\n    if (ddict) {    \n        ZSTD_copyDDictParameters(dctx, ddict);\n    }\n    return 0;\n}\n\n \nunsigned ZSTD_getDictID_fromDict(const void* dict, size_t dictSize)\n{\n    if (dictSize < 8) return 0;\n    if (MEM_readLE32(dict) != ZSTD_MAGIC_DICTIONARY) return 0;\n    return MEM_readLE32((const char*)dict + ZSTD_FRAMEIDSIZE);\n}\n\n \nunsigned ZSTD_getDictID_fromFrame(const void* src, size_t srcSize)\n{\n    ZSTD_frameHeader zfp = { 0, 0, 0, ZSTD_frame, 0, 0, 0 };\n    size_t const hError = ZSTD_getFrameHeader(&zfp, src, srcSize);\n    if (ZSTD_isError(hError)) return 0;\n    return zfp.dictID;\n}\n\n\n \nsize_t ZSTD_decompress_usingDDict(ZSTD_DCtx* dctx,\n                                  void* dst, size_t dstCapacity,\n                            const void* src, size_t srcSize,\n                            const ZSTD_DDict* ddict)\n{\n     \n    return ZSTD_decompressMultiFrame(dctx, dst, dstCapacity, src, srcSize,\n                                     NULL, 0,\n                                     ddict);\n}\n\n\n \n\nZSTD_DStream* ZSTD_createDStream(void)\n{\n    DEBUGLOG(3, \"ZSTD_createDStream\");\n    return ZSTD_createDCtx_internal(ZSTD_defaultCMem);\n}\n\nZSTD_DStream* ZSTD_initStaticDStream(void *workspace, size_t workspaceSize)\n{\n    return ZSTD_initStaticDCtx(workspace, workspaceSize);\n}\n\nZSTD_DStream* ZSTD_createDStream_advanced(ZSTD_customMem customMem)\n{\n    return ZSTD_createDCtx_internal(customMem);\n}\n\nsize_t ZSTD_freeDStream(ZSTD_DStream* zds)\n{\n    return ZSTD_freeDCtx(zds);\n}\n\n\n \n\nsize_t ZSTD_DStreamInSize(void)  { return ZSTD_BLOCKSIZE_MAX + ZSTD_blockHeaderSize; }\nsize_t ZSTD_DStreamOutSize(void) { return ZSTD_BLOCKSIZE_MAX; }\n\nsize_t ZSTD_DCtx_loadDictionary_advanced(ZSTD_DCtx* dctx,\n                                   const void* dict, size_t dictSize,\n                                         ZSTD_dictLoadMethod_e dictLoadMethod,\n                                         ZSTD_dictContentType_e dictContentType)\n{\n    RETURN_ERROR_IF(dctx->streamStage != zdss_init, stage_wrong, \"\");\n    ZSTD_clearDict(dctx);\n    if (dict && dictSize != 0) {\n        dctx->ddictLocal = ZSTD_createDDict_advanced(dict, dictSize, dictLoadMethod, dictContentType, dctx->customMem);\n        RETURN_ERROR_IF(dctx->ddictLocal == NULL, memory_allocation, \"NULL pointer!\");\n        dctx->ddict = dctx->ddictLocal;\n        dctx->dictUses = ZSTD_use_indefinitely;\n    }\n    return 0;\n}\n\nsize_t ZSTD_DCtx_loadDictionary_byReference(ZSTD_DCtx* dctx, const void* dict, size_t dictSize)\n{\n    return ZSTD_DCtx_loadDictionary_advanced(dctx, dict, dictSize, ZSTD_dlm_byRef, ZSTD_dct_auto);\n}\n\nsize_t ZSTD_DCtx_loadDictionary(ZSTD_DCtx* dctx, const void* dict, size_t dictSize)\n{\n    return ZSTD_DCtx_loadDictionary_advanced(dctx, dict, dictSize, ZSTD_dlm_byCopy, ZSTD_dct_auto);\n}\n\nsize_t ZSTD_DCtx_refPrefix_advanced(ZSTD_DCtx* dctx, const void* prefix, size_t prefixSize, ZSTD_dictContentType_e dictContentType)\n{\n    FORWARD_IF_ERROR(ZSTD_DCtx_loadDictionary_advanced(dctx, prefix, prefixSize, ZSTD_dlm_byRef, dictContentType), \"\");\n    dctx->dictUses = ZSTD_use_once;\n    return 0;\n}\n\nsize_t ZSTD_DCtx_refPrefix(ZSTD_DCtx* dctx, const void* prefix, size_t prefixSize)\n{\n    return ZSTD_DCtx_refPrefix_advanced(dctx, prefix, prefixSize, ZSTD_dct_rawContent);\n}\n\n\n \nsize_t ZSTD_initDStream_usingDict(ZSTD_DStream* zds, const void* dict, size_t dictSize)\n{\n    DEBUGLOG(4, \"ZSTD_initDStream_usingDict\");\n    FORWARD_IF_ERROR( ZSTD_DCtx_reset(zds, ZSTD_reset_session_only) , \"\");\n    FORWARD_IF_ERROR( ZSTD_DCtx_loadDictionary(zds, dict, dictSize) , \"\");\n    return ZSTD_startingInputLength(zds->format);\n}\n\n \nsize_t ZSTD_initDStream(ZSTD_DStream* zds)\n{\n    DEBUGLOG(4, \"ZSTD_initDStream\");\n    return ZSTD_initDStream_usingDDict(zds, NULL);\n}\n\n \nsize_t ZSTD_initDStream_usingDDict(ZSTD_DStream* dctx, const ZSTD_DDict* ddict)\n{\n    FORWARD_IF_ERROR( ZSTD_DCtx_reset(dctx, ZSTD_reset_session_only) , \"\");\n    FORWARD_IF_ERROR( ZSTD_DCtx_refDDict(dctx, ddict) , \"\");\n    return ZSTD_startingInputLength(dctx->format);\n}\n\n \nsize_t ZSTD_resetDStream(ZSTD_DStream* dctx)\n{\n    FORWARD_IF_ERROR(ZSTD_DCtx_reset(dctx, ZSTD_reset_session_only), \"\");\n    return ZSTD_startingInputLength(dctx->format);\n}\n\n\nsize_t ZSTD_DCtx_refDDict(ZSTD_DCtx* dctx, const ZSTD_DDict* ddict)\n{\n    RETURN_ERROR_IF(dctx->streamStage != zdss_init, stage_wrong, \"\");\n    ZSTD_clearDict(dctx);\n    if (ddict) {\n        dctx->ddict = ddict;\n        dctx->dictUses = ZSTD_use_indefinitely;\n        if (dctx->refMultipleDDicts == ZSTD_rmd_refMultipleDDicts) {\n            if (dctx->ddictSet == NULL) {\n                dctx->ddictSet = ZSTD_createDDictHashSet(dctx->customMem);\n                if (!dctx->ddictSet) {\n                    RETURN_ERROR(memory_allocation, \"Failed to allocate memory for hash set!\");\n                }\n            }\n            assert(!dctx->staticSize);   \n            FORWARD_IF_ERROR(ZSTD_DDictHashSet_addDDict(dctx->ddictSet, ddict, dctx->customMem), \"\");\n        }\n    }\n    return 0;\n}\n\n \nsize_t ZSTD_DCtx_setMaxWindowSize(ZSTD_DCtx* dctx, size_t maxWindowSize)\n{\n    ZSTD_bounds const bounds = ZSTD_dParam_getBounds(ZSTD_d_windowLogMax);\n    size_t const min = (size_t)1 << bounds.lowerBound;\n    size_t const max = (size_t)1 << bounds.upperBound;\n    RETURN_ERROR_IF(dctx->streamStage != zdss_init, stage_wrong, \"\");\n    RETURN_ERROR_IF(maxWindowSize < min, parameter_outOfBound, \"\");\n    RETURN_ERROR_IF(maxWindowSize > max, parameter_outOfBound, \"\");\n    dctx->maxWindowSize = maxWindowSize;\n    return 0;\n}\n\nsize_t ZSTD_DCtx_setFormat(ZSTD_DCtx* dctx, ZSTD_format_e format)\n{\n    return ZSTD_DCtx_setParameter(dctx, ZSTD_d_format, (int)format);\n}\n\nZSTD_bounds ZSTD_dParam_getBounds(ZSTD_dParameter dParam)\n{\n    ZSTD_bounds bounds = { 0, 0, 0 };\n    switch(dParam) {\n        case ZSTD_d_windowLogMax:\n            bounds.lowerBound = ZSTD_WINDOWLOG_ABSOLUTEMIN;\n            bounds.upperBound = ZSTD_WINDOWLOG_MAX;\n            return bounds;\n        case ZSTD_d_format:\n            bounds.lowerBound = (int)ZSTD_f_zstd1;\n            bounds.upperBound = (int)ZSTD_f_zstd1_magicless;\n            ZSTD_STATIC_ASSERT(ZSTD_f_zstd1 < ZSTD_f_zstd1_magicless);\n            return bounds;\n        case ZSTD_d_stableOutBuffer:\n            bounds.lowerBound = (int)ZSTD_bm_buffered;\n            bounds.upperBound = (int)ZSTD_bm_stable;\n            return bounds;\n        case ZSTD_d_forceIgnoreChecksum:\n            bounds.lowerBound = (int)ZSTD_d_validateChecksum;\n            bounds.upperBound = (int)ZSTD_d_ignoreChecksum;\n            return bounds;\n        case ZSTD_d_refMultipleDDicts:\n            bounds.lowerBound = (int)ZSTD_rmd_refSingleDDict;\n            bounds.upperBound = (int)ZSTD_rmd_refMultipleDDicts;\n            return bounds;\n        default:;\n    }\n    bounds.error = ERROR(parameter_unsupported);\n    return bounds;\n}\n\n \nstatic int ZSTD_dParam_withinBounds(ZSTD_dParameter dParam, int value)\n{\n    ZSTD_bounds const bounds = ZSTD_dParam_getBounds(dParam);\n    if (ZSTD_isError(bounds.error)) return 0;\n    if (value < bounds.lowerBound) return 0;\n    if (value > bounds.upperBound) return 0;\n    return 1;\n}\n\n#define CHECK_DBOUNDS(p,v) {                \\\n    RETURN_ERROR_IF(!ZSTD_dParam_withinBounds(p, v), parameter_outOfBound, \"\"); \\\n}\n\nsize_t ZSTD_DCtx_getParameter(ZSTD_DCtx* dctx, ZSTD_dParameter param, int* value)\n{\n    switch (param) {\n        case ZSTD_d_windowLogMax:\n            *value = (int)ZSTD_highbit32((U32)dctx->maxWindowSize);\n            return 0;\n        case ZSTD_d_format:\n            *value = (int)dctx->format;\n            return 0;\n        case ZSTD_d_stableOutBuffer:\n            *value = (int)dctx->outBufferMode;\n            return 0;\n        case ZSTD_d_forceIgnoreChecksum:\n            *value = (int)dctx->forceIgnoreChecksum;\n            return 0;\n        case ZSTD_d_refMultipleDDicts:\n            *value = (int)dctx->refMultipleDDicts;\n            return 0;\n        default:;\n    }\n    RETURN_ERROR(parameter_unsupported, \"\");\n}\n\nsize_t ZSTD_DCtx_setParameter(ZSTD_DCtx* dctx, ZSTD_dParameter dParam, int value)\n{\n    RETURN_ERROR_IF(dctx->streamStage != zdss_init, stage_wrong, \"\");\n    switch(dParam) {\n        case ZSTD_d_windowLogMax:\n            if (value == 0) value = ZSTD_WINDOWLOG_LIMIT_DEFAULT;\n            CHECK_DBOUNDS(ZSTD_d_windowLogMax, value);\n            dctx->maxWindowSize = ((size_t)1) << value;\n            return 0;\n        case ZSTD_d_format:\n            CHECK_DBOUNDS(ZSTD_d_format, value);\n            dctx->format = (ZSTD_format_e)value;\n            return 0;\n        case ZSTD_d_stableOutBuffer:\n            CHECK_DBOUNDS(ZSTD_d_stableOutBuffer, value);\n            dctx->outBufferMode = (ZSTD_bufferMode_e)value;\n            return 0;\n        case ZSTD_d_forceIgnoreChecksum:\n            CHECK_DBOUNDS(ZSTD_d_forceIgnoreChecksum, value);\n            dctx->forceIgnoreChecksum = (ZSTD_forceIgnoreChecksum_e)value;\n            return 0;\n        case ZSTD_d_refMultipleDDicts:\n            CHECK_DBOUNDS(ZSTD_d_refMultipleDDicts, value);\n            if (dctx->staticSize != 0) {\n                RETURN_ERROR(parameter_unsupported, \"Static dctx does not support multiple DDicts!\");\n            }\n            dctx->refMultipleDDicts = (ZSTD_refMultipleDDicts_e)value;\n            return 0;\n        default:;\n    }\n    RETURN_ERROR(parameter_unsupported, \"\");\n}\n\nsize_t ZSTD_DCtx_reset(ZSTD_DCtx* dctx, ZSTD_ResetDirective reset)\n{\n    if ( (reset == ZSTD_reset_session_only)\n      || (reset == ZSTD_reset_session_and_parameters) ) {\n        dctx->streamStage = zdss_init;\n        dctx->noForwardProgress = 0;\n    }\n    if ( (reset == ZSTD_reset_parameters)\n      || (reset == ZSTD_reset_session_and_parameters) ) {\n        RETURN_ERROR_IF(dctx->streamStage != zdss_init, stage_wrong, \"\");\n        ZSTD_clearDict(dctx);\n        ZSTD_DCtx_resetParameters(dctx);\n    }\n    return 0;\n}\n\n\nsize_t ZSTD_sizeof_DStream(const ZSTD_DStream* dctx)\n{\n    return ZSTD_sizeof_DCtx(dctx);\n}\n\nsize_t ZSTD_decodingBufferSize_min(unsigned long long windowSize, unsigned long long frameContentSize)\n{\n    size_t const blockSize = (size_t) MIN(windowSize, ZSTD_BLOCKSIZE_MAX);\n     \n    unsigned long long const neededRBSize = windowSize + blockSize + ZSTD_BLOCKSIZE_MAX + (WILDCOPY_OVERLENGTH * 2);\n    unsigned long long const neededSize = MIN(frameContentSize, neededRBSize);\n    size_t const minRBSize = (size_t) neededSize;\n    RETURN_ERROR_IF((unsigned long long)minRBSize != neededSize,\n                    frameParameter_windowTooLarge, \"\");\n    return minRBSize;\n}\n\nsize_t ZSTD_estimateDStreamSize(size_t windowSize)\n{\n    size_t const blockSize = MIN(windowSize, ZSTD_BLOCKSIZE_MAX);\n    size_t const inBuffSize = blockSize;   \n    size_t const outBuffSize = ZSTD_decodingBufferSize_min(windowSize, ZSTD_CONTENTSIZE_UNKNOWN);\n    return ZSTD_estimateDCtxSize() + inBuffSize + outBuffSize;\n}\n\nsize_t ZSTD_estimateDStreamSize_fromFrame(const void* src, size_t srcSize)\n{\n    U32 const windowSizeMax = 1U << ZSTD_WINDOWLOG_MAX;    \n    ZSTD_frameHeader zfh;\n    size_t const err = ZSTD_getFrameHeader(&zfh, src, srcSize);\n    if (ZSTD_isError(err)) return err;\n    RETURN_ERROR_IF(err>0, srcSize_wrong, \"\");\n    RETURN_ERROR_IF(zfh.windowSize > windowSizeMax,\n                    frameParameter_windowTooLarge, \"\");\n    return ZSTD_estimateDStreamSize((size_t)zfh.windowSize);\n}\n\n\n \n\nstatic int ZSTD_DCtx_isOverflow(ZSTD_DStream* zds, size_t const neededInBuffSize, size_t const neededOutBuffSize)\n{\n    return (zds->inBuffSize + zds->outBuffSize) >= (neededInBuffSize + neededOutBuffSize) * ZSTD_WORKSPACETOOLARGE_FACTOR;\n}\n\nstatic void ZSTD_DCtx_updateOversizedDuration(ZSTD_DStream* zds, size_t const neededInBuffSize, size_t const neededOutBuffSize)\n{\n    if (ZSTD_DCtx_isOverflow(zds, neededInBuffSize, neededOutBuffSize))\n        zds->oversizedDuration++;\n    else\n        zds->oversizedDuration = 0;\n}\n\nstatic int ZSTD_DCtx_isOversizedTooLong(ZSTD_DStream* zds)\n{\n    return zds->oversizedDuration >= ZSTD_WORKSPACETOOLARGE_MAXDURATION;\n}\n\n \nstatic size_t ZSTD_checkOutBuffer(ZSTD_DStream const* zds, ZSTD_outBuffer const* output)\n{\n    ZSTD_outBuffer const expect = zds->expectedOutBuffer;\n     \n    if (zds->outBufferMode != ZSTD_bm_stable)\n        return 0;\n     \n    if (zds->streamStage == zdss_init)\n        return 0;\n     \n    if (expect.dst == output->dst && expect.pos == output->pos && expect.size == output->size)\n        return 0;\n    RETURN_ERROR(dstBuffer_wrong, \"ZSTD_d_stableOutBuffer enabled but output differs!\");\n}\n\n \nstatic size_t ZSTD_decompressContinueStream(\n            ZSTD_DStream* zds, char** op, char* oend,\n            void const* src, size_t srcSize) {\n    int const isSkipFrame = ZSTD_isSkipFrame(zds);\n    if (zds->outBufferMode == ZSTD_bm_buffered) {\n        size_t const dstSize = isSkipFrame ? 0 : zds->outBuffSize - zds->outStart;\n        size_t const decodedSize = ZSTD_decompressContinue(zds,\n                zds->outBuff + zds->outStart, dstSize, src, srcSize);\n        FORWARD_IF_ERROR(decodedSize, \"\");\n        if (!decodedSize && !isSkipFrame) {\n            zds->streamStage = zdss_read;\n        } else {\n            zds->outEnd = zds->outStart + decodedSize;\n            zds->streamStage = zdss_flush;\n        }\n    } else {\n         \n        size_t const dstSize = isSkipFrame ? 0 : (size_t)(oend - *op);\n        size_t const decodedSize = ZSTD_decompressContinue(zds, *op, dstSize, src, srcSize);\n        FORWARD_IF_ERROR(decodedSize, \"\");\n        *op += decodedSize;\n         \n        zds->streamStage = zdss_read;\n        assert(*op <= oend);\n        assert(zds->outBufferMode == ZSTD_bm_stable);\n    }\n    return 0;\n}\n\nsize_t ZSTD_decompressStream(ZSTD_DStream* zds, ZSTD_outBuffer* output, ZSTD_inBuffer* input)\n{\n    const char* const src = (const char*)input->src;\n    const char* const istart = input->pos != 0 ? src + input->pos : src;\n    const char* const iend = input->size != 0 ? src + input->size : src;\n    const char* ip = istart;\n    char* const dst = (char*)output->dst;\n    char* const ostart = output->pos != 0 ? dst + output->pos : dst;\n    char* const oend = output->size != 0 ? dst + output->size : dst;\n    char* op = ostart;\n    U32 someMoreWork = 1;\n\n    DEBUGLOG(5, \"ZSTD_decompressStream\");\n    RETURN_ERROR_IF(\n        input->pos > input->size,\n        srcSize_wrong,\n        \"forbidden. in: pos: %u   vs size: %u\",\n        (U32)input->pos, (U32)input->size);\n    RETURN_ERROR_IF(\n        output->pos > output->size,\n        dstSize_tooSmall,\n        \"forbidden. out: pos: %u   vs size: %u\",\n        (U32)output->pos, (U32)output->size);\n    DEBUGLOG(5, \"input size : %u\", (U32)(input->size - input->pos));\n    FORWARD_IF_ERROR(ZSTD_checkOutBuffer(zds, output), \"\");\n\n    while (someMoreWork) {\n        switch(zds->streamStage)\n        {\n        case zdss_init :\n            DEBUGLOG(5, \"stage zdss_init => transparent reset \");\n            zds->streamStage = zdss_loadHeader;\n            zds->lhSize = zds->inPos = zds->outStart = zds->outEnd = 0;\n            zds->hostageByte = 0;\n            zds->expectedOutBuffer = *output;\n            ZSTD_FALLTHROUGH;\n\n        case zdss_loadHeader :\n            DEBUGLOG(5, \"stage zdss_loadHeader (srcSize : %u)\", (U32)(iend - ip));\n            {   size_t const hSize = ZSTD_getFrameHeader_advanced(&zds->fParams, zds->headerBuffer, zds->lhSize, zds->format);\n                if (zds->refMultipleDDicts && zds->ddictSet) {\n                    ZSTD_DCtx_selectFrameDDict(zds);\n                }\n                DEBUGLOG(5, \"header size : %u\", (U32)hSize);\n                if (ZSTD_isError(hSize)) {\n                    return hSize;    \n                }\n                if (hSize != 0) {    \n                    size_t const toLoad = hSize - zds->lhSize;    \n                    size_t const remainingInput = (size_t)(iend-ip);\n                    assert(iend >= ip);\n                    if (toLoad > remainingInput) {    \n                        if (remainingInput > 0) {\n                            ZSTD_memcpy(zds->headerBuffer + zds->lhSize, ip, remainingInput);\n                            zds->lhSize += remainingInput;\n                        }\n                        input->pos = input->size;\n                        return (MAX((size_t)ZSTD_FRAMEHEADERSIZE_MIN(zds->format), hSize) - zds->lhSize) + ZSTD_blockHeaderSize;    \n                    }\n                    assert(ip != NULL);\n                    ZSTD_memcpy(zds->headerBuffer + zds->lhSize, ip, toLoad); zds->lhSize = hSize; ip += toLoad;\n                    break;\n            }   }\n\n             \n            if (zds->fParams.frameContentSize != ZSTD_CONTENTSIZE_UNKNOWN\n                && zds->fParams.frameType != ZSTD_skippableFrame\n                && (U64)(size_t)(oend-op) >= zds->fParams.frameContentSize) {\n                size_t const cSize = ZSTD_findFrameCompressedSize(istart, (size_t)(iend-istart));\n                if (cSize <= (size_t)(iend-istart)) {\n                     \n                    size_t const decompressedSize = ZSTD_decompress_usingDDict(zds, op, (size_t)(oend-op), istart, cSize, ZSTD_getDDict(zds));\n                    if (ZSTD_isError(decompressedSize)) return decompressedSize;\n                    DEBUGLOG(4, \"shortcut to single-pass ZSTD_decompress_usingDDict()\")\n                    ip = istart + cSize;\n                    op += decompressedSize;\n                    zds->expected = 0;\n                    zds->streamStage = zdss_init;\n                    someMoreWork = 0;\n                    break;\n            }   }\n\n             \n            if (zds->outBufferMode == ZSTD_bm_stable\n                && zds->fParams.frameType != ZSTD_skippableFrame\n                && zds->fParams.frameContentSize != ZSTD_CONTENTSIZE_UNKNOWN\n                && (U64)(size_t)(oend-op) < zds->fParams.frameContentSize) {\n                RETURN_ERROR(dstSize_tooSmall, \"ZSTD_obm_stable passed but ZSTD_outBuffer is too small\");\n            }\n\n             \n            DEBUGLOG(4, \"Consume header\");\n            FORWARD_IF_ERROR(ZSTD_decompressBegin_usingDDict(zds, ZSTD_getDDict(zds)), \"\");\n\n            if ((MEM_readLE32(zds->headerBuffer) & ZSTD_MAGIC_SKIPPABLE_MASK) == ZSTD_MAGIC_SKIPPABLE_START) {   \n                zds->expected = MEM_readLE32(zds->headerBuffer + ZSTD_FRAMEIDSIZE);\n                zds->stage = ZSTDds_skipFrame;\n            } else {\n                FORWARD_IF_ERROR(ZSTD_decodeFrameHeader(zds, zds->headerBuffer, zds->lhSize), \"\");\n                zds->expected = ZSTD_blockHeaderSize;\n                zds->stage = ZSTDds_decodeBlockHeader;\n            }\n\n             \n            DEBUGLOG(4, \"Control max memory usage (%u KB <= max %u KB)\",\n                        (U32)(zds->fParams.windowSize >>10),\n                        (U32)(zds->maxWindowSize >> 10) );\n            zds->fParams.windowSize = MAX(zds->fParams.windowSize, 1U << ZSTD_WINDOWLOG_ABSOLUTEMIN);\n            RETURN_ERROR_IF(zds->fParams.windowSize > zds->maxWindowSize,\n                            frameParameter_windowTooLarge, \"\");\n\n             \n            {   size_t const neededInBuffSize = MAX(zds->fParams.blockSizeMax, 4  );\n                size_t const neededOutBuffSize = zds->outBufferMode == ZSTD_bm_buffered\n                        ? ZSTD_decodingBufferSize_min(zds->fParams.windowSize, zds->fParams.frameContentSize)\n                        : 0;\n\n                ZSTD_DCtx_updateOversizedDuration(zds, neededInBuffSize, neededOutBuffSize);\n\n                {   int const tooSmall = (zds->inBuffSize < neededInBuffSize) || (zds->outBuffSize < neededOutBuffSize);\n                    int const tooLarge = ZSTD_DCtx_isOversizedTooLong(zds);\n\n                    if (tooSmall || tooLarge) {\n                        size_t const bufferSize = neededInBuffSize + neededOutBuffSize;\n                        DEBUGLOG(4, \"inBuff  : from %u to %u\",\n                                    (U32)zds->inBuffSize, (U32)neededInBuffSize);\n                        DEBUGLOG(4, \"outBuff : from %u to %u\",\n                                    (U32)zds->outBuffSize, (U32)neededOutBuffSize);\n                        if (zds->staticSize) {   \n                            DEBUGLOG(4, \"staticSize : %u\", (U32)zds->staticSize);\n                            assert(zds->staticSize >= sizeof(ZSTD_DCtx));   \n                            RETURN_ERROR_IF(\n                                bufferSize > zds->staticSize - sizeof(ZSTD_DCtx),\n                                memory_allocation, \"\");\n                        } else {\n                            ZSTD_customFree(zds->inBuff, zds->customMem);\n                            zds->inBuffSize = 0;\n                            zds->outBuffSize = 0;\n                            zds->inBuff = (char*)ZSTD_customMalloc(bufferSize, zds->customMem);\n                            RETURN_ERROR_IF(zds->inBuff == NULL, memory_allocation, \"\");\n                        }\n                        zds->inBuffSize = neededInBuffSize;\n                        zds->outBuff = zds->inBuff + zds->inBuffSize;\n                        zds->outBuffSize = neededOutBuffSize;\n            }   }   }\n            zds->streamStage = zdss_read;\n            ZSTD_FALLTHROUGH;\n\n        case zdss_read:\n            DEBUGLOG(5, \"stage zdss_read\");\n            {   size_t const neededInSize = ZSTD_nextSrcSizeToDecompressWithInputSize(zds, (size_t)(iend - ip));\n                DEBUGLOG(5, \"neededInSize = %u\", (U32)neededInSize);\n                if (neededInSize==0) {   \n                    zds->streamStage = zdss_init;\n                    someMoreWork = 0;\n                    break;\n                }\n                if ((size_t)(iend-ip) >= neededInSize) {   \n                    FORWARD_IF_ERROR(ZSTD_decompressContinueStream(zds, &op, oend, ip, neededInSize), \"\");\n                    ip += neededInSize;\n                     \n                    break;\n            }   }\n            if (ip==iend) { someMoreWork = 0; break; }    \n            zds->streamStage = zdss_load;\n            ZSTD_FALLTHROUGH;\n\n        case zdss_load:\n            {   size_t const neededInSize = ZSTD_nextSrcSizeToDecompress(zds);\n                size_t const toLoad = neededInSize - zds->inPos;\n                int const isSkipFrame = ZSTD_isSkipFrame(zds);\n                size_t loadedSize;\n                 \n                assert(neededInSize == ZSTD_nextSrcSizeToDecompressWithInputSize(zds, iend - ip));\n                if (isSkipFrame) {\n                    loadedSize = MIN(toLoad, (size_t)(iend-ip));\n                } else {\n                    RETURN_ERROR_IF(toLoad > zds->inBuffSize - zds->inPos,\n                                    corruption_detected,\n                                    \"should never happen\");\n                    loadedSize = ZSTD_limitCopy(zds->inBuff + zds->inPos, toLoad, ip, (size_t)(iend-ip));\n                }\n                ip += loadedSize;\n                zds->inPos += loadedSize;\n                if (loadedSize < toLoad) { someMoreWork = 0; break; }    \n\n                 \n                zds->inPos = 0;    \n                FORWARD_IF_ERROR(ZSTD_decompressContinueStream(zds, &op, oend, zds->inBuff, neededInSize), \"\");\n                 \n                break;\n            }\n        case zdss_flush:\n            {   size_t const toFlushSize = zds->outEnd - zds->outStart;\n                size_t const flushedSize = ZSTD_limitCopy(op, (size_t)(oend-op), zds->outBuff + zds->outStart, toFlushSize);\n                op += flushedSize;\n                zds->outStart += flushedSize;\n                if (flushedSize == toFlushSize) {   \n                    zds->streamStage = zdss_read;\n                    if ( (zds->outBuffSize < zds->fParams.frameContentSize)\n                      && (zds->outStart + zds->fParams.blockSizeMax > zds->outBuffSize) ) {\n                        DEBUGLOG(5, \"restart filling outBuff from beginning (left:%i, needed:%u)\",\n                                (int)(zds->outBuffSize - zds->outStart),\n                                (U32)zds->fParams.blockSizeMax);\n                        zds->outStart = zds->outEnd = 0;\n                    }\n                    break;\n            }   }\n             \n            someMoreWork = 0;\n            break;\n\n        default:\n            assert(0);     \n            RETURN_ERROR(GENERIC, \"impossible to reach\");    \n    }   }\n\n     \n    input->pos = (size_t)(ip - (const char*)(input->src));\n    output->pos = (size_t)(op - (char*)(output->dst));\n\n     \n    zds->expectedOutBuffer = *output;\n\n    if ((ip==istart) && (op==ostart)) {   \n        zds->noForwardProgress ++;\n        if (zds->noForwardProgress >= ZSTD_NO_FORWARD_PROGRESS_MAX) {\n            RETURN_ERROR_IF(op==oend, dstSize_tooSmall, \"\");\n            RETURN_ERROR_IF(ip==iend, srcSize_wrong, \"\");\n            assert(0);\n        }\n    } else {\n        zds->noForwardProgress = 0;\n    }\n    {   size_t nextSrcSizeHint = ZSTD_nextSrcSizeToDecompress(zds);\n        if (!nextSrcSizeHint) {    \n            if (zds->outEnd == zds->outStart) {   \n                if (zds->hostageByte) {\n                    if (input->pos >= input->size) {\n                         \n                        zds->streamStage = zdss_read;\n                        return 1;\n                    }\n                    input->pos++;   \n                }    \n                return 0;\n            }   \n            if (!zds->hostageByte) {  \n                input->pos--;    \n                zds->hostageByte=1;\n            }\n            return 1;\n        }   \n        nextSrcSizeHint += ZSTD_blockHeaderSize * (ZSTD_nextInputType(zds) == ZSTDnit_block);    \n        assert(zds->inPos <= nextSrcSizeHint);\n        nextSrcSizeHint -= zds->inPos;    \n        return nextSrcSizeHint;\n    }\n}\n\nsize_t ZSTD_decompressStream_simpleArgs (\n                            ZSTD_DCtx* dctx,\n                            void* dst, size_t dstCapacity, size_t* dstPos,\n                      const void* src, size_t srcSize, size_t* srcPos)\n{\n    ZSTD_outBuffer output = { dst, dstCapacity, *dstPos };\n    ZSTD_inBuffer  input  = { src, srcSize, *srcPos };\n     \n    size_t const cErr = ZSTD_decompressStream(dctx, &output, &input);\n    *dstPos = output.pos;\n    *srcPos = input.pos;\n    return cErr;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}