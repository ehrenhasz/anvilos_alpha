{
  "module_name": "zstd_ddict.c",
  "hash_id": "8f4b71e997e643f897535ae76b5fdfad94a7ec418cc86e33eaa6b0227ff437b5",
  "original_prompt": "Ingested from linux-6.6.14/lib/zstd/decompress/zstd_ddict.c",
  "human_readable_source": " \n\n \n\n \n#include \"../common/zstd_deps.h\"    \n#include \"../common/cpu.h\"          \n#include \"../common/mem.h\"          \n#define FSE_STATIC_LINKING_ONLY\n#include \"../common/fse.h\"\n#define HUF_STATIC_LINKING_ONLY\n#include \"../common/huf.h\"\n#include \"zstd_decompress_internal.h\"\n#include \"zstd_ddict.h\"\n\n\n\n\n \nstruct ZSTD_DDict_s {\n    void* dictBuffer;\n    const void* dictContent;\n    size_t dictSize;\n    ZSTD_entropyDTables_t entropy;\n    U32 dictID;\n    U32 entropyPresent;\n    ZSTD_customMem cMem;\n};   \n\nconst void* ZSTD_DDict_dictContent(const ZSTD_DDict* ddict)\n{\n    assert(ddict != NULL);\n    return ddict->dictContent;\n}\n\nsize_t ZSTD_DDict_dictSize(const ZSTD_DDict* ddict)\n{\n    assert(ddict != NULL);\n    return ddict->dictSize;\n}\n\nvoid ZSTD_copyDDictParameters(ZSTD_DCtx* dctx, const ZSTD_DDict* ddict)\n{\n    DEBUGLOG(4, \"ZSTD_copyDDictParameters\");\n    assert(dctx != NULL);\n    assert(ddict != NULL);\n    dctx->dictID = ddict->dictID;\n    dctx->prefixStart = ddict->dictContent;\n    dctx->virtualStart = ddict->dictContent;\n    dctx->dictEnd = (const BYTE*)ddict->dictContent + ddict->dictSize;\n    dctx->previousDstEnd = dctx->dictEnd;\n#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION\n    dctx->dictContentBeginForFuzzing = dctx->prefixStart;\n    dctx->dictContentEndForFuzzing = dctx->previousDstEnd;\n#endif\n    if (ddict->entropyPresent) {\n        dctx->litEntropy = 1;\n        dctx->fseEntropy = 1;\n        dctx->LLTptr = ddict->entropy.LLTable;\n        dctx->MLTptr = ddict->entropy.MLTable;\n        dctx->OFTptr = ddict->entropy.OFTable;\n        dctx->HUFptr = ddict->entropy.hufTable;\n        dctx->entropy.rep[0] = ddict->entropy.rep[0];\n        dctx->entropy.rep[1] = ddict->entropy.rep[1];\n        dctx->entropy.rep[2] = ddict->entropy.rep[2];\n    } else {\n        dctx->litEntropy = 0;\n        dctx->fseEntropy = 0;\n    }\n}\n\n\nstatic size_t\nZSTD_loadEntropy_intoDDict(ZSTD_DDict* ddict,\n                           ZSTD_dictContentType_e dictContentType)\n{\n    ddict->dictID = 0;\n    ddict->entropyPresent = 0;\n    if (dictContentType == ZSTD_dct_rawContent) return 0;\n\n    if (ddict->dictSize < 8) {\n        if (dictContentType == ZSTD_dct_fullDict)\n            return ERROR(dictionary_corrupted);    \n        return 0;    \n    }\n    {   U32 const magic = MEM_readLE32(ddict->dictContent);\n        if (magic != ZSTD_MAGIC_DICTIONARY) {\n            if (dictContentType == ZSTD_dct_fullDict)\n                return ERROR(dictionary_corrupted);    \n            return 0;    \n        }\n    }\n    ddict->dictID = MEM_readLE32((const char*)ddict->dictContent + ZSTD_FRAMEIDSIZE);\n\n     \n    RETURN_ERROR_IF(ZSTD_isError(ZSTD_loadDEntropy(\n            &ddict->entropy, ddict->dictContent, ddict->dictSize)),\n        dictionary_corrupted, \"\");\n    ddict->entropyPresent = 1;\n    return 0;\n}\n\n\nstatic size_t ZSTD_initDDict_internal(ZSTD_DDict* ddict,\n                                      const void* dict, size_t dictSize,\n                                      ZSTD_dictLoadMethod_e dictLoadMethod,\n                                      ZSTD_dictContentType_e dictContentType)\n{\n    if ((dictLoadMethod == ZSTD_dlm_byRef) || (!dict) || (!dictSize)) {\n        ddict->dictBuffer = NULL;\n        ddict->dictContent = dict;\n        if (!dict) dictSize = 0;\n    } else {\n        void* const internalBuffer = ZSTD_customMalloc(dictSize, ddict->cMem);\n        ddict->dictBuffer = internalBuffer;\n        ddict->dictContent = internalBuffer;\n        if (!internalBuffer) return ERROR(memory_allocation);\n        ZSTD_memcpy(internalBuffer, dict, dictSize);\n    }\n    ddict->dictSize = dictSize;\n    ddict->entropy.hufTable[0] = (HUF_DTable)((HufLog)*0x1000001);   \n\n     \n    FORWARD_IF_ERROR( ZSTD_loadEntropy_intoDDict(ddict, dictContentType) , \"\");\n\n    return 0;\n}\n\nZSTD_DDict* ZSTD_createDDict_advanced(const void* dict, size_t dictSize,\n                                      ZSTD_dictLoadMethod_e dictLoadMethod,\n                                      ZSTD_dictContentType_e dictContentType,\n                                      ZSTD_customMem customMem)\n{\n    if ((!customMem.customAlloc) ^ (!customMem.customFree)) return NULL;\n\n    {   ZSTD_DDict* const ddict = (ZSTD_DDict*) ZSTD_customMalloc(sizeof(ZSTD_DDict), customMem);\n        if (ddict == NULL) return NULL;\n        ddict->cMem = customMem;\n        {   size_t const initResult = ZSTD_initDDict_internal(ddict,\n                                            dict, dictSize,\n                                            dictLoadMethod, dictContentType);\n            if (ZSTD_isError(initResult)) {\n                ZSTD_freeDDict(ddict);\n                return NULL;\n        }   }\n        return ddict;\n    }\n}\n\n \nZSTD_DDict* ZSTD_createDDict(const void* dict, size_t dictSize)\n{\n    ZSTD_customMem const allocator = { NULL, NULL, NULL };\n    return ZSTD_createDDict_advanced(dict, dictSize, ZSTD_dlm_byCopy, ZSTD_dct_auto, allocator);\n}\n\n \nZSTD_DDict* ZSTD_createDDict_byReference(const void* dictBuffer, size_t dictSize)\n{\n    ZSTD_customMem const allocator = { NULL, NULL, NULL };\n    return ZSTD_createDDict_advanced(dictBuffer, dictSize, ZSTD_dlm_byRef, ZSTD_dct_auto, allocator);\n}\n\n\nconst ZSTD_DDict* ZSTD_initStaticDDict(\n                                void* sBuffer, size_t sBufferSize,\n                                const void* dict, size_t dictSize,\n                                ZSTD_dictLoadMethod_e dictLoadMethod,\n                                ZSTD_dictContentType_e dictContentType)\n{\n    size_t const neededSpace = sizeof(ZSTD_DDict)\n                             + (dictLoadMethod == ZSTD_dlm_byRef ? 0 : dictSize);\n    ZSTD_DDict* const ddict = (ZSTD_DDict*)sBuffer;\n    assert(sBuffer != NULL);\n    assert(dict != NULL);\n    if ((size_t)sBuffer & 7) return NULL;    \n    if (sBufferSize < neededSpace) return NULL;\n    if (dictLoadMethod == ZSTD_dlm_byCopy) {\n        ZSTD_memcpy(ddict+1, dict, dictSize);   \n        dict = ddict+1;\n    }\n    if (ZSTD_isError( ZSTD_initDDict_internal(ddict,\n                                              dict, dictSize,\n                                              ZSTD_dlm_byRef, dictContentType) ))\n        return NULL;\n    return ddict;\n}\n\n\nsize_t ZSTD_freeDDict(ZSTD_DDict* ddict)\n{\n    if (ddict==NULL) return 0;    \n    {   ZSTD_customMem const cMem = ddict->cMem;\n        ZSTD_customFree(ddict->dictBuffer, cMem);\n        ZSTD_customFree(ddict, cMem);\n        return 0;\n    }\n}\n\n \nsize_t ZSTD_estimateDDictSize(size_t dictSize, ZSTD_dictLoadMethod_e dictLoadMethod)\n{\n    return sizeof(ZSTD_DDict) + (dictLoadMethod == ZSTD_dlm_byRef ? 0 : dictSize);\n}\n\nsize_t ZSTD_sizeof_DDict(const ZSTD_DDict* ddict)\n{\n    if (ddict==NULL) return 0;    \n    return sizeof(*ddict) + (ddict->dictBuffer ? ddict->dictSize : 0) ;\n}\n\n \nunsigned ZSTD_getDictID_fromDDict(const ZSTD_DDict* ddict)\n{\n    if (ddict==NULL) return 0;\n    return ZSTD_getDictID_fromDict(ddict->dictContent, ddict->dictSize);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}