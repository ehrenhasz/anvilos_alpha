{
  "module_name": "zstd_decompress_block.c",
  "hash_id": "dcc4cba0d5d97c482f185eebd7f4e6bf8a0e6b0a6d5d8a3f55abfecc868d0087",
  "original_prompt": "Ingested from linux-6.6.14/lib/zstd/decompress/zstd_decompress_block.c",
  "human_readable_source": " \n\n \n\n \n#include \"../common/zstd_deps.h\"    \n#include \"../common/compiler.h\"     \n#include \"../common/cpu.h\"          \n#include \"../common/mem.h\"          \n#define FSE_STATIC_LINKING_ONLY\n#include \"../common/fse.h\"\n#define HUF_STATIC_LINKING_ONLY\n#include \"../common/huf.h\"\n#include \"../common/zstd_internal.h\"\n#include \"zstd_decompress_internal.h\"    \n#include \"zstd_ddict.h\"   \n#include \"zstd_decompress_block.h\"\n\n \n\n \n#if defined(ZSTD_FORCE_DECOMPRESS_SEQUENCES_SHORT) && \\\n    defined(ZSTD_FORCE_DECOMPRESS_SEQUENCES_LONG)\n#error \"Cannot force the use of the short and the long ZSTD_decompressSequences variants!\"\n#endif\n\n\n \nstatic void ZSTD_copy4(void* dst, const void* src) { ZSTD_memcpy(dst, src, 4); }\n\n\n \n\n \nsize_t ZSTD_getcBlockSize(const void* src, size_t srcSize,\n                          blockProperties_t* bpPtr)\n{\n    RETURN_ERROR_IF(srcSize < ZSTD_blockHeaderSize, srcSize_wrong, \"\");\n\n    {   U32 const cBlockHeader = MEM_readLE24(src);\n        U32 const cSize = cBlockHeader >> 3;\n        bpPtr->lastBlock = cBlockHeader & 1;\n        bpPtr->blockType = (blockType_e)((cBlockHeader >> 1) & 3);\n        bpPtr->origSize = cSize;    \n        if (bpPtr->blockType == bt_rle) return 1;\n        RETURN_ERROR_IF(bpPtr->blockType == bt_reserved, corruption_detected, \"\");\n        return cSize;\n    }\n}\n\n \nstatic void ZSTD_allocateLiteralsBuffer(ZSTD_DCtx* dctx, void* const dst, const size_t dstCapacity, const size_t litSize,\n    const streaming_operation streaming, const size_t expectedWriteSize, const unsigned splitImmediately)\n{\n    if (streaming == not_streaming && dstCapacity > ZSTD_BLOCKSIZE_MAX + WILDCOPY_OVERLENGTH + litSize + WILDCOPY_OVERLENGTH)\n    {\n         \n        dctx->litBuffer = (BYTE*)dst + ZSTD_BLOCKSIZE_MAX + WILDCOPY_OVERLENGTH;\n        dctx->litBufferEnd = dctx->litBuffer + litSize;\n        dctx->litBufferLocation = ZSTD_in_dst;\n    }\n    else if (litSize > ZSTD_LITBUFFEREXTRASIZE)\n    {\n         \n        if (splitImmediately) {\n             \n            dctx->litBuffer = (BYTE*)dst + expectedWriteSize - litSize + ZSTD_LITBUFFEREXTRASIZE - WILDCOPY_OVERLENGTH;\n            dctx->litBufferEnd = dctx->litBuffer + litSize - ZSTD_LITBUFFEREXTRASIZE;\n        }\n        else {\n             \n            dctx->litBuffer = (BYTE*)dst + expectedWriteSize - litSize;\n            dctx->litBufferEnd = (BYTE*)dst + expectedWriteSize;\n        }\n        dctx->litBufferLocation = ZSTD_split;\n    }\n    else\n    {\n         \n        dctx->litBuffer = dctx->litExtraBuffer;\n        dctx->litBufferEnd = dctx->litBuffer + litSize;\n        dctx->litBufferLocation = ZSTD_not_in_dst;\n    }\n}\n\n \nsize_t ZSTD_decodeLiteralsBlock(ZSTD_DCtx* dctx,\n                          const void* src, size_t srcSize,\n                          void* dst, size_t dstCapacity, const streaming_operation streaming);\n \nsize_t ZSTD_decodeLiteralsBlock(ZSTD_DCtx* dctx,\n                          const void* src, size_t srcSize,    \n                          void* dst, size_t dstCapacity, const streaming_operation streaming)\n{\n    DEBUGLOG(5, \"ZSTD_decodeLiteralsBlock\");\n    RETURN_ERROR_IF(srcSize < MIN_CBLOCK_SIZE, corruption_detected, \"\");\n\n    {   const BYTE* const istart = (const BYTE*) src;\n        symbolEncodingType_e const litEncType = (symbolEncodingType_e)(istart[0] & 3);\n\n        switch(litEncType)\n        {\n        case set_repeat:\n            DEBUGLOG(5, \"set_repeat flag : re-using stats from previous compressed literals block\");\n            RETURN_ERROR_IF(dctx->litEntropy==0, dictionary_corrupted, \"\");\n            ZSTD_FALLTHROUGH;\n\n        case set_compressed:\n            RETURN_ERROR_IF(srcSize < 5, corruption_detected, \"srcSize >= MIN_CBLOCK_SIZE == 3; here we need up to 5 for case 3\");\n            {   size_t lhSize, litSize, litCSize;\n                U32 singleStream=0;\n                U32 const lhlCode = (istart[0] >> 2) & 3;\n                U32 const lhc = MEM_readLE32(istart);\n                size_t hufSuccess;\n                size_t expectedWriteSize = MIN(ZSTD_BLOCKSIZE_MAX, dstCapacity);\n                switch(lhlCode)\n                {\n                case 0: case 1: default:    \n                     \n                    singleStream = !lhlCode;\n                    lhSize = 3;\n                    litSize  = (lhc >> 4) & 0x3FF;\n                    litCSize = (lhc >> 14) & 0x3FF;\n                    break;\n                case 2:\n                     \n                    lhSize = 4;\n                    litSize  = (lhc >> 4) & 0x3FFF;\n                    litCSize = lhc >> 18;\n                    break;\n                case 3:\n                     \n                    lhSize = 5;\n                    litSize  = (lhc >> 4) & 0x3FFFF;\n                    litCSize = (lhc >> 22) + ((size_t)istart[4] << 10);\n                    break;\n                }\n                RETURN_ERROR_IF(litSize > 0 && dst == NULL, dstSize_tooSmall, \"NULL not handled\");\n                RETURN_ERROR_IF(litSize > ZSTD_BLOCKSIZE_MAX, corruption_detected, \"\");\n                RETURN_ERROR_IF(litCSize + lhSize > srcSize, corruption_detected, \"\");\n                RETURN_ERROR_IF(expectedWriteSize < litSize , dstSize_tooSmall, \"\");\n                ZSTD_allocateLiteralsBuffer(dctx, dst, dstCapacity, litSize, streaming, expectedWriteSize, 0);\n\n                 \n                if (dctx->ddictIsCold && (litSize > 768  )) {\n                    PREFETCH_AREA(dctx->HUFptr, sizeof(dctx->entropy.hufTable));\n                }\n\n                if (litEncType==set_repeat) {\n                    if (singleStream) {\n                        hufSuccess = HUF_decompress1X_usingDTable_bmi2(\n                            dctx->litBuffer, litSize, istart+lhSize, litCSize,\n                            dctx->HUFptr, ZSTD_DCtx_get_bmi2(dctx));\n                    } else {\n                        hufSuccess = HUF_decompress4X_usingDTable_bmi2(\n                            dctx->litBuffer, litSize, istart+lhSize, litCSize,\n                            dctx->HUFptr, ZSTD_DCtx_get_bmi2(dctx));\n                    }\n                } else {\n                    if (singleStream) {\n#if defined(HUF_FORCE_DECOMPRESS_X2)\n                        hufSuccess = HUF_decompress1X_DCtx_wksp(\n                            dctx->entropy.hufTable, dctx->litBuffer, litSize,\n                            istart+lhSize, litCSize, dctx->workspace,\n                            sizeof(dctx->workspace));\n#else\n                        hufSuccess = HUF_decompress1X1_DCtx_wksp_bmi2(\n                            dctx->entropy.hufTable, dctx->litBuffer, litSize,\n                            istart+lhSize, litCSize, dctx->workspace,\n                            sizeof(dctx->workspace), ZSTD_DCtx_get_bmi2(dctx));\n#endif\n                    } else {\n                        hufSuccess = HUF_decompress4X_hufOnly_wksp_bmi2(\n                            dctx->entropy.hufTable, dctx->litBuffer, litSize,\n                            istart+lhSize, litCSize, dctx->workspace,\n                            sizeof(dctx->workspace), ZSTD_DCtx_get_bmi2(dctx));\n                    }\n                }\n                if (dctx->litBufferLocation == ZSTD_split)\n                {\n                    ZSTD_memcpy(dctx->litExtraBuffer, dctx->litBufferEnd - ZSTD_LITBUFFEREXTRASIZE, ZSTD_LITBUFFEREXTRASIZE);\n                    ZSTD_memmove(dctx->litBuffer + ZSTD_LITBUFFEREXTRASIZE - WILDCOPY_OVERLENGTH, dctx->litBuffer, litSize - ZSTD_LITBUFFEREXTRASIZE);\n                    dctx->litBuffer += ZSTD_LITBUFFEREXTRASIZE - WILDCOPY_OVERLENGTH;\n                    dctx->litBufferEnd -= WILDCOPY_OVERLENGTH;\n                }\n\n                RETURN_ERROR_IF(HUF_isError(hufSuccess), corruption_detected, \"\");\n\n                dctx->litPtr = dctx->litBuffer;\n                dctx->litSize = litSize;\n                dctx->litEntropy = 1;\n                if (litEncType==set_compressed) dctx->HUFptr = dctx->entropy.hufTable;\n                return litCSize + lhSize;\n            }\n\n        case set_basic:\n            {   size_t litSize, lhSize;\n                U32 const lhlCode = ((istart[0]) >> 2) & 3;\n                size_t expectedWriteSize = MIN(ZSTD_BLOCKSIZE_MAX, dstCapacity);\n                switch(lhlCode)\n                {\n                case 0: case 2: default:    \n                    lhSize = 1;\n                    litSize = istart[0] >> 3;\n                    break;\n                case 1:\n                    lhSize = 2;\n                    litSize = MEM_readLE16(istart) >> 4;\n                    break;\n                case 3:\n                    lhSize = 3;\n                    litSize = MEM_readLE24(istart) >> 4;\n                    break;\n                }\n\n                RETURN_ERROR_IF(litSize > 0 && dst == NULL, dstSize_tooSmall, \"NULL not handled\");\n                RETURN_ERROR_IF(expectedWriteSize < litSize, dstSize_tooSmall, \"\");\n                ZSTD_allocateLiteralsBuffer(dctx, dst, dstCapacity, litSize, streaming, expectedWriteSize, 1);\n                if (lhSize+litSize+WILDCOPY_OVERLENGTH > srcSize) {   \n                    RETURN_ERROR_IF(litSize+lhSize > srcSize, corruption_detected, \"\");\n                    if (dctx->litBufferLocation == ZSTD_split)\n                    {\n                        ZSTD_memcpy(dctx->litBuffer, istart + lhSize, litSize - ZSTD_LITBUFFEREXTRASIZE);\n                        ZSTD_memcpy(dctx->litExtraBuffer, istart + lhSize + litSize - ZSTD_LITBUFFEREXTRASIZE, ZSTD_LITBUFFEREXTRASIZE);\n                    }\n                    else\n                    {\n                        ZSTD_memcpy(dctx->litBuffer, istart + lhSize, litSize);\n                    }\n                    dctx->litPtr = dctx->litBuffer;\n                    dctx->litSize = litSize;\n                    return lhSize+litSize;\n                }\n                 \n                dctx->litPtr = istart+lhSize;\n                dctx->litSize = litSize;\n                dctx->litBufferEnd = dctx->litPtr + litSize;\n                dctx->litBufferLocation = ZSTD_not_in_dst;\n                return lhSize+litSize;\n            }\n\n        case set_rle:\n            {   U32 const lhlCode = ((istart[0]) >> 2) & 3;\n                size_t litSize, lhSize;\n                size_t expectedWriteSize = MIN(ZSTD_BLOCKSIZE_MAX, dstCapacity);\n                switch(lhlCode)\n                {\n                case 0: case 2: default:    \n                    lhSize = 1;\n                    litSize = istart[0] >> 3;\n                    break;\n                case 1:\n                    lhSize = 2;\n                    litSize = MEM_readLE16(istart) >> 4;\n                    break;\n                case 3:\n                    lhSize = 3;\n                    litSize = MEM_readLE24(istart) >> 4;\n                    RETURN_ERROR_IF(srcSize<4, corruption_detected, \"srcSize >= MIN_CBLOCK_SIZE == 3; here we need lhSize+1 = 4\");\n                    break;\n                }\n                RETURN_ERROR_IF(litSize > 0 && dst == NULL, dstSize_tooSmall, \"NULL not handled\");\n                RETURN_ERROR_IF(litSize > ZSTD_BLOCKSIZE_MAX, corruption_detected, \"\");\n                RETURN_ERROR_IF(expectedWriteSize < litSize, dstSize_tooSmall, \"\");\n                ZSTD_allocateLiteralsBuffer(dctx, dst, dstCapacity, litSize, streaming, expectedWriteSize, 1);\n                if (dctx->litBufferLocation == ZSTD_split)\n                {\n                    ZSTD_memset(dctx->litBuffer, istart[lhSize], litSize - ZSTD_LITBUFFEREXTRASIZE);\n                    ZSTD_memset(dctx->litExtraBuffer, istart[lhSize], ZSTD_LITBUFFEREXTRASIZE);\n                }\n                else\n                {\n                    ZSTD_memset(dctx->litBuffer, istart[lhSize], litSize);\n                }\n                dctx->litPtr = dctx->litBuffer;\n                dctx->litSize = litSize;\n                return lhSize+1;\n            }\n        default:\n            RETURN_ERROR(corruption_detected, \"impossible\");\n        }\n    }\n}\n\n \n\n \nstatic const ZSTD_seqSymbol LL_defaultDTable[(1<<LL_DEFAULTNORMLOG)+1] = {\n     {  1,  1,  1, LL_DEFAULTNORMLOG},   \n      \n     {  0,  0,  4,    0},  { 16,  0,  4,    0},\n     { 32,  0,  5,    1},  {  0,  0,  5,    3},\n     {  0,  0,  5,    4},  {  0,  0,  5,    6},\n     {  0,  0,  5,    7},  {  0,  0,  5,    9},\n     {  0,  0,  5,   10},  {  0,  0,  5,   12},\n     {  0,  0,  6,   14},  {  0,  1,  5,   16},\n     {  0,  1,  5,   20},  {  0,  1,  5,   22},\n     {  0,  2,  5,   28},  {  0,  3,  5,   32},\n     {  0,  4,  5,   48},  { 32,  6,  5,   64},\n     {  0,  7,  5,  128},  {  0,  8,  6,  256},\n     {  0, 10,  6, 1024},  {  0, 12,  6, 4096},\n     { 32,  0,  4,    0},  {  0,  0,  4,    1},\n     {  0,  0,  5,    2},  { 32,  0,  5,    4},\n     {  0,  0,  5,    5},  { 32,  0,  5,    7},\n     {  0,  0,  5,    8},  { 32,  0,  5,   10},\n     {  0,  0,  5,   11},  {  0,  0,  6,   13},\n     { 32,  1,  5,   16},  {  0,  1,  5,   18},\n     { 32,  1,  5,   22},  {  0,  2,  5,   24},\n     { 32,  3,  5,   32},  {  0,  3,  5,   40},\n     {  0,  6,  4,   64},  { 16,  6,  4,   64},\n     { 32,  7,  5,  128},  {  0,  9,  6,  512},\n     {  0, 11,  6, 2048},  { 48,  0,  4,    0},\n     { 16,  0,  4,    1},  { 32,  0,  5,    2},\n     { 32,  0,  5,    3},  { 32,  0,  5,    5},\n     { 32,  0,  5,    6},  { 32,  0,  5,    8},\n     { 32,  0,  5,    9},  { 32,  0,  5,   11},\n     { 32,  0,  5,   12},  {  0,  0,  6,   15},\n     { 32,  1,  5,   18},  { 32,  1,  5,   20},\n     { 32,  2,  5,   24},  { 32,  2,  5,   28},\n     { 32,  3,  5,   40},  { 32,  4,  5,   48},\n     {  0, 16,  6,65536},  {  0, 15,  6,32768},\n     {  0, 14,  6,16384},  {  0, 13,  6, 8192},\n};    \n\n \nstatic const ZSTD_seqSymbol OF_defaultDTable[(1<<OF_DEFAULTNORMLOG)+1] = {\n    {  1,  1,  1, OF_DEFAULTNORMLOG},   \n     \n    {  0,  0,  5,    0},     {  0,  6,  4,   61},\n    {  0,  9,  5,  509},     {  0, 15,  5,32765},\n    {  0, 21,  5,2097149},   {  0,  3,  5,    5},\n    {  0,  7,  4,  125},     {  0, 12,  5, 4093},\n    {  0, 18,  5,262141},    {  0, 23,  5,8388605},\n    {  0,  5,  5,   29},     {  0,  8,  4,  253},\n    {  0, 14,  5,16381},     {  0, 20,  5,1048573},\n    {  0,  2,  5,    1},     { 16,  7,  4,  125},\n    {  0, 11,  5, 2045},     {  0, 17,  5,131069},\n    {  0, 22,  5,4194301},   {  0,  4,  5,   13},\n    { 16,  8,  4,  253},     {  0, 13,  5, 8189},\n    {  0, 19,  5,524285},    {  0,  1,  5,    1},\n    { 16,  6,  4,   61},     {  0, 10,  5, 1021},\n    {  0, 16,  5,65533},     {  0, 28,  5,268435453},\n    {  0, 27,  5,134217725}, {  0, 26,  5,67108861},\n    {  0, 25,  5,33554429},  {  0, 24,  5,16777213},\n};    \n\n\n \nstatic const ZSTD_seqSymbol ML_defaultDTable[(1<<ML_DEFAULTNORMLOG)+1] = {\n    {  1,  1,  1, ML_DEFAULTNORMLOG},   \n     \n    {  0,  0,  6,    3},  {  0,  0,  4,    4},\n    { 32,  0,  5,    5},  {  0,  0,  5,    6},\n    {  0,  0,  5,    8},  {  0,  0,  5,    9},\n    {  0,  0,  5,   11},  {  0,  0,  6,   13},\n    {  0,  0,  6,   16},  {  0,  0,  6,   19},\n    {  0,  0,  6,   22},  {  0,  0,  6,   25},\n    {  0,  0,  6,   28},  {  0,  0,  6,   31},\n    {  0,  0,  6,   34},  {  0,  1,  6,   37},\n    {  0,  1,  6,   41},  {  0,  2,  6,   47},\n    {  0,  3,  6,   59},  {  0,  4,  6,   83},\n    {  0,  7,  6,  131},  {  0,  9,  6,  515},\n    { 16,  0,  4,    4},  {  0,  0,  4,    5},\n    { 32,  0,  5,    6},  {  0,  0,  5,    7},\n    { 32,  0,  5,    9},  {  0,  0,  5,   10},\n    {  0,  0,  6,   12},  {  0,  0,  6,   15},\n    {  0,  0,  6,   18},  {  0,  0,  6,   21},\n    {  0,  0,  6,   24},  {  0,  0,  6,   27},\n    {  0,  0,  6,   30},  {  0,  0,  6,   33},\n    {  0,  1,  6,   35},  {  0,  1,  6,   39},\n    {  0,  2,  6,   43},  {  0,  3,  6,   51},\n    {  0,  4,  6,   67},  {  0,  5,  6,   99},\n    {  0,  8,  6,  259},  { 32,  0,  4,    4},\n    { 48,  0,  4,    4},  { 16,  0,  4,    5},\n    { 32,  0,  5,    7},  { 32,  0,  5,    8},\n    { 32,  0,  5,   10},  { 32,  0,  5,   11},\n    {  0,  0,  6,   14},  {  0,  0,  6,   17},\n    {  0,  0,  6,   20},  {  0,  0,  6,   23},\n    {  0,  0,  6,   26},  {  0,  0,  6,   29},\n    {  0,  0,  6,   32},  {  0, 16,  6,65539},\n    {  0, 15,  6,32771},  {  0, 14,  6,16387},\n    {  0, 13,  6, 8195},  {  0, 12,  6, 4099},\n    {  0, 11,  6, 2051},  {  0, 10,  6, 1027},\n};    \n\n\nstatic void ZSTD_buildSeqTable_rle(ZSTD_seqSymbol* dt, U32 baseValue, U8 nbAddBits)\n{\n    void* ptr = dt;\n    ZSTD_seqSymbol_header* const DTableH = (ZSTD_seqSymbol_header*)ptr;\n    ZSTD_seqSymbol* const cell = dt + 1;\n\n    DTableH->tableLog = 0;\n    DTableH->fastMode = 0;\n\n    cell->nbBits = 0;\n    cell->nextState = 0;\n    assert(nbAddBits < 255);\n    cell->nbAdditionalBits = nbAddBits;\n    cell->baseValue = baseValue;\n}\n\n\n \nFORCE_INLINE_TEMPLATE\nvoid ZSTD_buildFSETable_body(ZSTD_seqSymbol* dt,\n            const short* normalizedCounter, unsigned maxSymbolValue,\n            const U32* baseValue, const U8* nbAdditionalBits,\n            unsigned tableLog, void* wksp, size_t wkspSize)\n{\n    ZSTD_seqSymbol* const tableDecode = dt+1;\n    U32 const maxSV1 = maxSymbolValue + 1;\n    U32 const tableSize = 1 << tableLog;\n\n    U16* symbolNext = (U16*)wksp;\n    BYTE* spread = (BYTE*)(symbolNext + MaxSeq + 1);\n    U32 highThreshold = tableSize - 1;\n\n\n     \n    assert(maxSymbolValue <= MaxSeq);\n    assert(tableLog <= MaxFSELog);\n    assert(wkspSize >= ZSTD_BUILD_FSE_TABLE_WKSP_SIZE);\n    (void)wkspSize;\n     \n    {   ZSTD_seqSymbol_header DTableH;\n        DTableH.tableLog = tableLog;\n        DTableH.fastMode = 1;\n        {   S16 const largeLimit= (S16)(1 << (tableLog-1));\n            U32 s;\n            for (s=0; s<maxSV1; s++) {\n                if (normalizedCounter[s]==-1) {\n                    tableDecode[highThreshold--].baseValue = s;\n                    symbolNext[s] = 1;\n                } else {\n                    if (normalizedCounter[s] >= largeLimit) DTableH.fastMode=0;\n                    assert(normalizedCounter[s]>=0);\n                    symbolNext[s] = (U16)normalizedCounter[s];\n        }   }   }\n        ZSTD_memcpy(dt, &DTableH, sizeof(DTableH));\n    }\n\n     \n    assert(tableSize <= 512);\n     \n    if (highThreshold == tableSize - 1) {\n        size_t const tableMask = tableSize-1;\n        size_t const step = FSE_TABLESTEP(tableSize);\n         \n        {\n            U64 const add = 0x0101010101010101ull;\n            size_t pos = 0;\n            U64 sv = 0;\n            U32 s;\n            for (s=0; s<maxSV1; ++s, sv += add) {\n                int i;\n                int const n = normalizedCounter[s];\n                MEM_write64(spread + pos, sv);\n                for (i = 8; i < n; i += 8) {\n                    MEM_write64(spread + pos + i, sv);\n                }\n                pos += n;\n            }\n        }\n         \n        {\n            size_t position = 0;\n            size_t s;\n            size_t const unroll = 2;\n            assert(tableSize % unroll == 0);  \n            for (s = 0; s < (size_t)tableSize; s += unroll) {\n                size_t u;\n                for (u = 0; u < unroll; ++u) {\n                    size_t const uPosition = (position + (u * step)) & tableMask;\n                    tableDecode[uPosition].baseValue = spread[s + u];\n                }\n                position = (position + (unroll * step)) & tableMask;\n            }\n            assert(position == 0);\n        }\n    } else {\n        U32 const tableMask = tableSize-1;\n        U32 const step = FSE_TABLESTEP(tableSize);\n        U32 s, position = 0;\n        for (s=0; s<maxSV1; s++) {\n            int i;\n            int const n = normalizedCounter[s];\n            for (i=0; i<n; i++) {\n                tableDecode[position].baseValue = s;\n                position = (position + step) & tableMask;\n                while (position > highThreshold) position = (position + step) & tableMask;    \n        }   }\n        assert(position == 0);  \n    }\n\n     \n    {\n        U32 u;\n        for (u=0; u<tableSize; u++) {\n            U32 const symbol = tableDecode[u].baseValue;\n            U32 const nextState = symbolNext[symbol]++;\n            tableDecode[u].nbBits = (BYTE) (tableLog - BIT_highbit32(nextState) );\n            tableDecode[u].nextState = (U16) ( (nextState << tableDecode[u].nbBits) - tableSize);\n            assert(nbAdditionalBits[symbol] < 255);\n            tableDecode[u].nbAdditionalBits = nbAdditionalBits[symbol];\n            tableDecode[u].baseValue = baseValue[symbol];\n        }\n    }\n}\n\n \nstatic void ZSTD_buildFSETable_body_default(ZSTD_seqSymbol* dt,\n            const short* normalizedCounter, unsigned maxSymbolValue,\n            const U32* baseValue, const U8* nbAdditionalBits,\n            unsigned tableLog, void* wksp, size_t wkspSize)\n{\n    ZSTD_buildFSETable_body(dt, normalizedCounter, maxSymbolValue,\n            baseValue, nbAdditionalBits, tableLog, wksp, wkspSize);\n}\n\n#if DYNAMIC_BMI2\nBMI2_TARGET_ATTRIBUTE static void ZSTD_buildFSETable_body_bmi2(ZSTD_seqSymbol* dt,\n            const short* normalizedCounter, unsigned maxSymbolValue,\n            const U32* baseValue, const U8* nbAdditionalBits,\n            unsigned tableLog, void* wksp, size_t wkspSize)\n{\n    ZSTD_buildFSETable_body(dt, normalizedCounter, maxSymbolValue,\n            baseValue, nbAdditionalBits, tableLog, wksp, wkspSize);\n}\n#endif\n\nvoid ZSTD_buildFSETable(ZSTD_seqSymbol* dt,\n            const short* normalizedCounter, unsigned maxSymbolValue,\n            const U32* baseValue, const U8* nbAdditionalBits,\n            unsigned tableLog, void* wksp, size_t wkspSize, int bmi2)\n{\n#if DYNAMIC_BMI2\n    if (bmi2) {\n        ZSTD_buildFSETable_body_bmi2(dt, normalizedCounter, maxSymbolValue,\n                baseValue, nbAdditionalBits, tableLog, wksp, wkspSize);\n        return;\n    }\n#endif\n    (void)bmi2;\n    ZSTD_buildFSETable_body_default(dt, normalizedCounter, maxSymbolValue,\n            baseValue, nbAdditionalBits, tableLog, wksp, wkspSize);\n}\n\n\n \nstatic size_t ZSTD_buildSeqTable(ZSTD_seqSymbol* DTableSpace, const ZSTD_seqSymbol** DTablePtr,\n                                 symbolEncodingType_e type, unsigned max, U32 maxLog,\n                                 const void* src, size_t srcSize,\n                                 const U32* baseValue, const U8* nbAdditionalBits,\n                                 const ZSTD_seqSymbol* defaultTable, U32 flagRepeatTable,\n                                 int ddictIsCold, int nbSeq, U32* wksp, size_t wkspSize,\n                                 int bmi2)\n{\n    switch(type)\n    {\n    case set_rle :\n        RETURN_ERROR_IF(!srcSize, srcSize_wrong, \"\");\n        RETURN_ERROR_IF((*(const BYTE*)src) > max, corruption_detected, \"\");\n        {   U32 const symbol = *(const BYTE*)src;\n            U32 const baseline = baseValue[symbol];\n            U8 const nbBits = nbAdditionalBits[symbol];\n            ZSTD_buildSeqTable_rle(DTableSpace, baseline, nbBits);\n        }\n        *DTablePtr = DTableSpace;\n        return 1;\n    case set_basic :\n        *DTablePtr = defaultTable;\n        return 0;\n    case set_repeat:\n        RETURN_ERROR_IF(!flagRepeatTable, corruption_detected, \"\");\n         \n        if (ddictIsCold && (nbSeq > 24  )) {\n            const void* const pStart = *DTablePtr;\n            size_t const pSize = sizeof(ZSTD_seqSymbol) * (SEQSYMBOL_TABLE_SIZE(maxLog));\n            PREFETCH_AREA(pStart, pSize);\n        }\n        return 0;\n    case set_compressed :\n        {   unsigned tableLog;\n            S16 norm[MaxSeq+1];\n            size_t const headerSize = FSE_readNCount(norm, &max, &tableLog, src, srcSize);\n            RETURN_ERROR_IF(FSE_isError(headerSize), corruption_detected, \"\");\n            RETURN_ERROR_IF(tableLog > maxLog, corruption_detected, \"\");\n            ZSTD_buildFSETable(DTableSpace, norm, max, baseValue, nbAdditionalBits, tableLog, wksp, wkspSize, bmi2);\n            *DTablePtr = DTableSpace;\n            return headerSize;\n        }\n    default :\n        assert(0);\n        RETURN_ERROR(GENERIC, \"impossible\");\n    }\n}\n\nsize_t ZSTD_decodeSeqHeaders(ZSTD_DCtx* dctx, int* nbSeqPtr,\n                             const void* src, size_t srcSize)\n{\n    const BYTE* const istart = (const BYTE*)src;\n    const BYTE* const iend = istart + srcSize;\n    const BYTE* ip = istart;\n    int nbSeq;\n    DEBUGLOG(5, \"ZSTD_decodeSeqHeaders\");\n\n     \n    RETURN_ERROR_IF(srcSize < MIN_SEQUENCES_SIZE, srcSize_wrong, \"\");\n\n     \n    nbSeq = *ip++;\n    if (!nbSeq) {\n        *nbSeqPtr=0;\n        RETURN_ERROR_IF(srcSize != 1, srcSize_wrong, \"\");\n        return 1;\n    }\n    if (nbSeq > 0x7F) {\n        if (nbSeq == 0xFF) {\n            RETURN_ERROR_IF(ip+2 > iend, srcSize_wrong, \"\");\n            nbSeq = MEM_readLE16(ip) + LONGNBSEQ;\n            ip+=2;\n        } else {\n            RETURN_ERROR_IF(ip >= iend, srcSize_wrong, \"\");\n            nbSeq = ((nbSeq-0x80)<<8) + *ip++;\n        }\n    }\n    *nbSeqPtr = nbSeq;\n\n     \n    RETURN_ERROR_IF(ip+1 > iend, srcSize_wrong, \"\");  \n    {   symbolEncodingType_e const LLtype = (symbolEncodingType_e)(*ip >> 6);\n        symbolEncodingType_e const OFtype = (symbolEncodingType_e)((*ip >> 4) & 3);\n        symbolEncodingType_e const MLtype = (symbolEncodingType_e)((*ip >> 2) & 3);\n        ip++;\n\n         \n        {   size_t const llhSize = ZSTD_buildSeqTable(dctx->entropy.LLTable, &dctx->LLTptr,\n                                                      LLtype, MaxLL, LLFSELog,\n                                                      ip, iend-ip,\n                                                      LL_base, LL_bits,\n                                                      LL_defaultDTable, dctx->fseEntropy,\n                                                      dctx->ddictIsCold, nbSeq,\n                                                      dctx->workspace, sizeof(dctx->workspace),\n                                                      ZSTD_DCtx_get_bmi2(dctx));\n            RETURN_ERROR_IF(ZSTD_isError(llhSize), corruption_detected, \"ZSTD_buildSeqTable failed\");\n            ip += llhSize;\n        }\n\n        {   size_t const ofhSize = ZSTD_buildSeqTable(dctx->entropy.OFTable, &dctx->OFTptr,\n                                                      OFtype, MaxOff, OffFSELog,\n                                                      ip, iend-ip,\n                                                      OF_base, OF_bits,\n                                                      OF_defaultDTable, dctx->fseEntropy,\n                                                      dctx->ddictIsCold, nbSeq,\n                                                      dctx->workspace, sizeof(dctx->workspace),\n                                                      ZSTD_DCtx_get_bmi2(dctx));\n            RETURN_ERROR_IF(ZSTD_isError(ofhSize), corruption_detected, \"ZSTD_buildSeqTable failed\");\n            ip += ofhSize;\n        }\n\n        {   size_t const mlhSize = ZSTD_buildSeqTable(dctx->entropy.MLTable, &dctx->MLTptr,\n                                                      MLtype, MaxML, MLFSELog,\n                                                      ip, iend-ip,\n                                                      ML_base, ML_bits,\n                                                      ML_defaultDTable, dctx->fseEntropy,\n                                                      dctx->ddictIsCold, nbSeq,\n                                                      dctx->workspace, sizeof(dctx->workspace),\n                                                      ZSTD_DCtx_get_bmi2(dctx));\n            RETURN_ERROR_IF(ZSTD_isError(mlhSize), corruption_detected, \"ZSTD_buildSeqTable failed\");\n            ip += mlhSize;\n        }\n    }\n\n    return ip-istart;\n}\n\n\ntypedef struct {\n    size_t litLength;\n    size_t matchLength;\n    size_t offset;\n} seq_t;\n\ntypedef struct {\n    size_t state;\n    const ZSTD_seqSymbol* table;\n} ZSTD_fseState;\n\ntypedef struct {\n    BIT_DStream_t DStream;\n    ZSTD_fseState stateLL;\n    ZSTD_fseState stateOffb;\n    ZSTD_fseState stateML;\n    size_t prevOffset[ZSTD_REP_NUM];\n} seqState_t;\n\n \nHINT_INLINE void ZSTD_overlapCopy8(BYTE** op, BYTE const** ip, size_t offset) {\n    assert(*ip <= *op);\n    if (offset < 8) {\n         \n        static const U32 dec32table[] = { 0, 1, 2, 1, 4, 4, 4, 4 };    \n        static const int dec64table[] = { 8, 8, 8, 7, 8, 9,10,11 };    \n        int const sub2 = dec64table[offset];\n        (*op)[0] = (*ip)[0];\n        (*op)[1] = (*ip)[1];\n        (*op)[2] = (*ip)[2];\n        (*op)[3] = (*ip)[3];\n        *ip += dec32table[offset];\n        ZSTD_copy4(*op+4, *ip);\n        *ip -= sub2;\n    } else {\n        ZSTD_copy8(*op, *ip);\n    }\n    *ip += 8;\n    *op += 8;\n    assert(*op - *ip >= 8);\n}\n\n \nstatic void ZSTD_safecopy(BYTE* op, const BYTE* const oend_w, BYTE const* ip, ptrdiff_t length, ZSTD_overlap_e ovtype) {\n    ptrdiff_t const diff = op - ip;\n    BYTE* const oend = op + length;\n\n    assert((ovtype == ZSTD_no_overlap && (diff <= -8 || diff >= 8 || op >= oend_w)) ||\n           (ovtype == ZSTD_overlap_src_before_dst && diff >= 0));\n\n    if (length < 8) {\n         \n        while (op < oend) *op++ = *ip++;\n        return;\n    }\n    if (ovtype == ZSTD_overlap_src_before_dst) {\n         \n        assert(length >= 8);\n        ZSTD_overlapCopy8(&op, &ip, diff);\n        length -= 8;\n        assert(op - ip >= 8);\n        assert(op <= oend);\n    }\n\n    if (oend <= oend_w) {\n         \n        ZSTD_wildcopy(op, ip, length, ovtype);\n        return;\n    }\n    if (op <= oend_w) {\n         \n        assert(oend > oend_w);\n        ZSTD_wildcopy(op, ip, oend_w - op, ovtype);\n        ip += oend_w - op;\n        op += oend_w - op;\n    }\n     \n    while (op < oend) *op++ = *ip++;\n}\n\n \nstatic void ZSTD_safecopyDstBeforeSrc(BYTE* op, BYTE const* ip, ptrdiff_t length) {\n    ptrdiff_t const diff = op - ip;\n    BYTE* const oend = op + length;\n\n    if (length < 8 || diff > -8) {\n         \n        while (op < oend) *op++ = *ip++;\n        return;\n    }\n\n    if (op <= oend - WILDCOPY_OVERLENGTH && diff < -WILDCOPY_VECLEN) {\n        ZSTD_wildcopy(op, ip, oend - WILDCOPY_OVERLENGTH - op, ZSTD_no_overlap);\n        ip += oend - WILDCOPY_OVERLENGTH - op;\n        op += oend - WILDCOPY_OVERLENGTH - op;\n    }\n\n     \n    while (op < oend) *op++ = *ip++;\n}\n\n \nFORCE_NOINLINE\nsize_t ZSTD_execSequenceEnd(BYTE* op,\n    BYTE* const oend, seq_t sequence,\n    const BYTE** litPtr, const BYTE* const litLimit,\n    const BYTE* const prefixStart, const BYTE* const virtualStart, const BYTE* const dictEnd)\n{\n    BYTE* const oLitEnd = op + sequence.litLength;\n    size_t const sequenceLength = sequence.litLength + sequence.matchLength;\n    const BYTE* const iLitEnd = *litPtr + sequence.litLength;\n    const BYTE* match = oLitEnd - sequence.offset;\n    BYTE* const oend_w = oend - WILDCOPY_OVERLENGTH;\n\n     \n    RETURN_ERROR_IF(sequenceLength > (size_t)(oend - op), dstSize_tooSmall, \"last match must fit within dstBuffer\");\n    RETURN_ERROR_IF(sequence.litLength > (size_t)(litLimit - *litPtr), corruption_detected, \"try to read beyond literal buffer\");\n    assert(op < op + sequenceLength);\n    assert(oLitEnd < op + sequenceLength);\n\n     \n    ZSTD_safecopy(op, oend_w, *litPtr, sequence.litLength, ZSTD_no_overlap);\n    op = oLitEnd;\n    *litPtr = iLitEnd;\n\n     \n    if (sequence.offset > (size_t)(oLitEnd - prefixStart)) {\n         \n        RETURN_ERROR_IF(sequence.offset > (size_t)(oLitEnd - virtualStart), corruption_detected, \"\");\n        match = dictEnd - (prefixStart - match);\n        if (match + sequence.matchLength <= dictEnd) {\n            ZSTD_memmove(oLitEnd, match, sequence.matchLength);\n            return sequenceLength;\n        }\n         \n        {   size_t const length1 = dictEnd - match;\n        ZSTD_memmove(oLitEnd, match, length1);\n        op = oLitEnd + length1;\n        sequence.matchLength -= length1;\n        match = prefixStart;\n        }\n    }\n    ZSTD_safecopy(op, oend_w, match, sequence.matchLength, ZSTD_overlap_src_before_dst);\n    return sequenceLength;\n}\n\n \nFORCE_NOINLINE\nsize_t ZSTD_execSequenceEndSplitLitBuffer(BYTE* op,\n    BYTE* const oend, const BYTE* const oend_w, seq_t sequence,\n    const BYTE** litPtr, const BYTE* const litLimit,\n    const BYTE* const prefixStart, const BYTE* const virtualStart, const BYTE* const dictEnd)\n{\n    BYTE* const oLitEnd = op + sequence.litLength;\n    size_t const sequenceLength = sequence.litLength + sequence.matchLength;\n    const BYTE* const iLitEnd = *litPtr + sequence.litLength;\n    const BYTE* match = oLitEnd - sequence.offset;\n\n\n     \n    RETURN_ERROR_IF(sequenceLength > (size_t)(oend - op), dstSize_tooSmall, \"last match must fit within dstBuffer\");\n    RETURN_ERROR_IF(sequence.litLength > (size_t)(litLimit - *litPtr), corruption_detected, \"try to read beyond literal buffer\");\n    assert(op < op + sequenceLength);\n    assert(oLitEnd < op + sequenceLength);\n\n     \n    RETURN_ERROR_IF(op > *litPtr && op < *litPtr + sequence.litLength, dstSize_tooSmall, \"output should not catch up to and overwrite literal buffer\");\n    ZSTD_safecopyDstBeforeSrc(op, *litPtr, sequence.litLength);\n    op = oLitEnd;\n    *litPtr = iLitEnd;\n\n     \n    if (sequence.offset > (size_t)(oLitEnd - prefixStart)) {\n         \n        RETURN_ERROR_IF(sequence.offset > (size_t)(oLitEnd - virtualStart), corruption_detected, \"\");\n        match = dictEnd - (prefixStart - match);\n        if (match + sequence.matchLength <= dictEnd) {\n            ZSTD_memmove(oLitEnd, match, sequence.matchLength);\n            return sequenceLength;\n        }\n         \n        {   size_t const length1 = dictEnd - match;\n        ZSTD_memmove(oLitEnd, match, length1);\n        op = oLitEnd + length1;\n        sequence.matchLength -= length1;\n        match = prefixStart;\n        }\n    }\n    ZSTD_safecopy(op, oend_w, match, sequence.matchLength, ZSTD_overlap_src_before_dst);\n    return sequenceLength;\n}\n\nHINT_INLINE\nsize_t ZSTD_execSequence(BYTE* op,\n    BYTE* const oend, seq_t sequence,\n    const BYTE** litPtr, const BYTE* const litLimit,\n    const BYTE* const prefixStart, const BYTE* const virtualStart, const BYTE* const dictEnd)\n{\n    BYTE* const oLitEnd = op + sequence.litLength;\n    size_t const sequenceLength = sequence.litLength + sequence.matchLength;\n    BYTE* const oMatchEnd = op + sequenceLength;    \n    BYTE* const oend_w = oend - WILDCOPY_OVERLENGTH;    \n    const BYTE* const iLitEnd = *litPtr + sequence.litLength;\n    const BYTE* match = oLitEnd - sequence.offset;\n\n    assert(op != NULL  );\n    assert(oend_w < oend  );\n     \n    if (UNLIKELY(\n        iLitEnd > litLimit ||\n        oMatchEnd > oend_w ||\n        (MEM_32bits() && (size_t)(oend - op) < sequenceLength + WILDCOPY_OVERLENGTH)))\n        return ZSTD_execSequenceEnd(op, oend, sequence, litPtr, litLimit, prefixStart, virtualStart, dictEnd);\n\n     \n    assert(op <= oLitEnd  );\n    assert(oLitEnd < oMatchEnd  );\n    assert(oMatchEnd <= oend  );\n    assert(iLitEnd <= litLimit  );\n    assert(oLitEnd <= oend_w  );\n    assert(oMatchEnd <= oend_w  );\n\n     \n    assert(WILDCOPY_OVERLENGTH >= 16);\n    ZSTD_copy16(op, (*litPtr));\n    if (UNLIKELY(sequence.litLength > 16)) {\n        ZSTD_wildcopy(op + 16, (*litPtr) + 16, sequence.litLength - 16, ZSTD_no_overlap);\n    }\n    op = oLitEnd;\n    *litPtr = iLitEnd;    \n\n     \n    if (sequence.offset > (size_t)(oLitEnd - prefixStart)) {\n         \n        RETURN_ERROR_IF(UNLIKELY(sequence.offset > (size_t)(oLitEnd - virtualStart)), corruption_detected, \"\");\n        match = dictEnd + (match - prefixStart);\n        if (match + sequence.matchLength <= dictEnd) {\n            ZSTD_memmove(oLitEnd, match, sequence.matchLength);\n            return sequenceLength;\n        }\n         \n        {   size_t const length1 = dictEnd - match;\n        ZSTD_memmove(oLitEnd, match, length1);\n        op = oLitEnd + length1;\n        sequence.matchLength -= length1;\n        match = prefixStart;\n        }\n    }\n     \n    assert(op <= oMatchEnd);\n    assert(oMatchEnd <= oend_w);\n    assert(match >= prefixStart);\n    assert(sequence.matchLength >= 1);\n\n     \n    if (LIKELY(sequence.offset >= WILDCOPY_VECLEN)) {\n         \n        ZSTD_wildcopy(op, match, (ptrdiff_t)sequence.matchLength, ZSTD_no_overlap);\n        return sequenceLength;\n    }\n    assert(sequence.offset < WILDCOPY_VECLEN);\n\n     \n    ZSTD_overlapCopy8(&op, &match, sequence.offset);\n\n     \n    if (sequence.matchLength > 8) {\n        assert(op < oMatchEnd);\n        ZSTD_wildcopy(op, match, (ptrdiff_t)sequence.matchLength - 8, ZSTD_overlap_src_before_dst);\n    }\n    return sequenceLength;\n}\n\nHINT_INLINE\nsize_t ZSTD_execSequenceSplitLitBuffer(BYTE* op,\n    BYTE* const oend, const BYTE* const oend_w, seq_t sequence,\n    const BYTE** litPtr, const BYTE* const litLimit,\n    const BYTE* const prefixStart, const BYTE* const virtualStart, const BYTE* const dictEnd)\n{\n    BYTE* const oLitEnd = op + sequence.litLength;\n    size_t const sequenceLength = sequence.litLength + sequence.matchLength;\n    BYTE* const oMatchEnd = op + sequenceLength;    \n    const BYTE* const iLitEnd = *litPtr + sequence.litLength;\n    const BYTE* match = oLitEnd - sequence.offset;\n\n    assert(op != NULL  );\n    assert(oend_w < oend  );\n     \n    if (UNLIKELY(\n            iLitEnd > litLimit ||\n            oMatchEnd > oend_w ||\n            (MEM_32bits() && (size_t)(oend - op) < sequenceLength + WILDCOPY_OVERLENGTH)))\n        return ZSTD_execSequenceEndSplitLitBuffer(op, oend, oend_w, sequence, litPtr, litLimit, prefixStart, virtualStart, dictEnd);\n\n     \n    assert(op <= oLitEnd  );\n    assert(oLitEnd < oMatchEnd  );\n    assert(oMatchEnd <= oend  );\n    assert(iLitEnd <= litLimit  );\n    assert(oLitEnd <= oend_w  );\n    assert(oMatchEnd <= oend_w  );\n\n     \n    assert(WILDCOPY_OVERLENGTH >= 16);\n    ZSTD_copy16(op, (*litPtr));\n    if (UNLIKELY(sequence.litLength > 16)) {\n        ZSTD_wildcopy(op+16, (*litPtr)+16, sequence.litLength-16, ZSTD_no_overlap);\n    }\n    op = oLitEnd;\n    *litPtr = iLitEnd;    \n\n     \n    if (sequence.offset > (size_t)(oLitEnd - prefixStart)) {\n         \n        RETURN_ERROR_IF(UNLIKELY(sequence.offset > (size_t)(oLitEnd - virtualStart)), corruption_detected, \"\");\n        match = dictEnd + (match - prefixStart);\n        if (match + sequence.matchLength <= dictEnd) {\n            ZSTD_memmove(oLitEnd, match, sequence.matchLength);\n            return sequenceLength;\n        }\n         \n        {   size_t const length1 = dictEnd - match;\n            ZSTD_memmove(oLitEnd, match, length1);\n            op = oLitEnd + length1;\n            sequence.matchLength -= length1;\n            match = prefixStart;\n    }   }\n     \n    assert(op <= oMatchEnd);\n    assert(oMatchEnd <= oend_w);\n    assert(match >= prefixStart);\n    assert(sequence.matchLength >= 1);\n\n     \n    if (LIKELY(sequence.offset >= WILDCOPY_VECLEN)) {\n         \n        ZSTD_wildcopy(op, match, (ptrdiff_t)sequence.matchLength, ZSTD_no_overlap);\n        return sequenceLength;\n    }\n    assert(sequence.offset < WILDCOPY_VECLEN);\n\n     \n    ZSTD_overlapCopy8(&op, &match, sequence.offset);\n\n     \n    if (sequence.matchLength > 8) {\n        assert(op < oMatchEnd);\n        ZSTD_wildcopy(op, match, (ptrdiff_t)sequence.matchLength-8, ZSTD_overlap_src_before_dst);\n    }\n    return sequenceLength;\n}\n\n\nstatic void\nZSTD_initFseState(ZSTD_fseState* DStatePtr, BIT_DStream_t* bitD, const ZSTD_seqSymbol* dt)\n{\n    const void* ptr = dt;\n    const ZSTD_seqSymbol_header* const DTableH = (const ZSTD_seqSymbol_header*)ptr;\n    DStatePtr->state = BIT_readBits(bitD, DTableH->tableLog);\n    DEBUGLOG(6, \"ZSTD_initFseState : val=%u using %u bits\",\n                (U32)DStatePtr->state, DTableH->tableLog);\n    BIT_reloadDStream(bitD);\n    DStatePtr->table = dt + 1;\n}\n\nFORCE_INLINE_TEMPLATE void\nZSTD_updateFseStateWithDInfo(ZSTD_fseState* DStatePtr, BIT_DStream_t* bitD, U16 nextState, U32 nbBits)\n{\n    size_t const lowBits = BIT_readBits(bitD, nbBits);\n    DStatePtr->state = nextState + lowBits;\n}\n\n \n#define LONG_OFFSETS_MAX_EXTRA_BITS_32                       \\\n    (ZSTD_WINDOWLOG_MAX_32 > STREAM_ACCUMULATOR_MIN_32       \\\n        ? ZSTD_WINDOWLOG_MAX_32 - STREAM_ACCUMULATOR_MIN_32  \\\n        : 0)\n\ntypedef enum { ZSTD_lo_isRegularOffset, ZSTD_lo_isLongOffset=1 } ZSTD_longOffset_e;\n\nFORCE_INLINE_TEMPLATE seq_t\nZSTD_decodeSequence(seqState_t* seqState, const ZSTD_longOffset_e longOffsets)\n{\n    seq_t seq;\n    const ZSTD_seqSymbol* const llDInfo = seqState->stateLL.table + seqState->stateLL.state;\n    const ZSTD_seqSymbol* const mlDInfo = seqState->stateML.table + seqState->stateML.state;\n    const ZSTD_seqSymbol* const ofDInfo = seqState->stateOffb.table + seqState->stateOffb.state;\n    seq.matchLength = mlDInfo->baseValue;\n    seq.litLength = llDInfo->baseValue;\n    {   U32 const ofBase = ofDInfo->baseValue;\n        BYTE const llBits = llDInfo->nbAdditionalBits;\n        BYTE const mlBits = mlDInfo->nbAdditionalBits;\n        BYTE const ofBits = ofDInfo->nbAdditionalBits;\n        BYTE const totalBits = llBits+mlBits+ofBits;\n\n        U16 const llNext = llDInfo->nextState;\n        U16 const mlNext = mlDInfo->nextState;\n        U16 const ofNext = ofDInfo->nextState;\n        U32 const llnbBits = llDInfo->nbBits;\n        U32 const mlnbBits = mlDInfo->nbBits;\n        U32 const ofnbBits = ofDInfo->nbBits;\n         \n\n         \n        {   size_t offset;\n    #if defined(__clang__)\n            if (LIKELY(ofBits > 1)) {\n    #else\n            if (ofBits > 1) {\n    #endif\n                ZSTD_STATIC_ASSERT(ZSTD_lo_isLongOffset == 1);\n                ZSTD_STATIC_ASSERT(LONG_OFFSETS_MAX_EXTRA_BITS_32 == 5);\n                assert(ofBits <= MaxOff);\n                if (MEM_32bits() && longOffsets && (ofBits >= STREAM_ACCUMULATOR_MIN_32)) {\n                    U32 const extraBits = ofBits - MIN(ofBits, 32 - seqState->DStream.bitsConsumed);\n                    offset = ofBase + (BIT_readBitsFast(&seqState->DStream, ofBits - extraBits) << extraBits);\n                    BIT_reloadDStream(&seqState->DStream);\n                    if (extraBits) offset += BIT_readBitsFast(&seqState->DStream, extraBits);\n                    assert(extraBits <= LONG_OFFSETS_MAX_EXTRA_BITS_32);    \n                } else {\n                    offset = ofBase + BIT_readBitsFast(&seqState->DStream, ofBits );    \n                    if (MEM_32bits()) BIT_reloadDStream(&seqState->DStream);\n                }\n                seqState->prevOffset[2] = seqState->prevOffset[1];\n                seqState->prevOffset[1] = seqState->prevOffset[0];\n                seqState->prevOffset[0] = offset;\n            } else {\n                U32 const ll0 = (llDInfo->baseValue == 0);\n                if (LIKELY((ofBits == 0))) {\n                    offset = seqState->prevOffset[ll0];\n                    seqState->prevOffset[1] = seqState->prevOffset[!ll0];\n                    seqState->prevOffset[0] = offset;\n                } else {\n                    offset = ofBase + ll0 + BIT_readBitsFast(&seqState->DStream, 1);\n                    {   size_t temp = (offset==3) ? seqState->prevOffset[0] - 1 : seqState->prevOffset[offset];\n                        temp += !temp;    \n                        if (offset != 1) seqState->prevOffset[2] = seqState->prevOffset[1];\n                        seqState->prevOffset[1] = seqState->prevOffset[0];\n                        seqState->prevOffset[0] = offset = temp;\n            }   }   }\n            seq.offset = offset;\n        }\n\n    #if defined(__clang__)\n        if (UNLIKELY(mlBits > 0))\n    #else\n        if (mlBits > 0)\n    #endif\n            seq.matchLength += BIT_readBitsFast(&seqState->DStream, mlBits );\n\n        if (MEM_32bits() && (mlBits+llBits >= STREAM_ACCUMULATOR_MIN_32-LONG_OFFSETS_MAX_EXTRA_BITS_32))\n            BIT_reloadDStream(&seqState->DStream);\n        if (MEM_64bits() && UNLIKELY(totalBits >= STREAM_ACCUMULATOR_MIN_64-(LLFSELog+MLFSELog+OffFSELog)))\n            BIT_reloadDStream(&seqState->DStream);\n         \n        ZSTD_STATIC_ASSERT(16+LLFSELog+MLFSELog+OffFSELog < STREAM_ACCUMULATOR_MIN_64);\n\n    #if defined(__clang__)\n        if (UNLIKELY(llBits > 0))\n    #else\n        if (llBits > 0)\n    #endif\n            seq.litLength += BIT_readBitsFast(&seqState->DStream, llBits );\n\n        if (MEM_32bits())\n            BIT_reloadDStream(&seqState->DStream);\n\n        DEBUGLOG(6, \"seq: litL=%u, matchL=%u, offset=%u\",\n                    (U32)seq.litLength, (U32)seq.matchLength, (U32)seq.offset);\n\n        ZSTD_updateFseStateWithDInfo(&seqState->stateLL, &seqState->DStream, llNext, llnbBits);     \n        ZSTD_updateFseStateWithDInfo(&seqState->stateML, &seqState->DStream, mlNext, mlnbBits);     \n        if (MEM_32bits()) BIT_reloadDStream(&seqState->DStream);     \n        ZSTD_updateFseStateWithDInfo(&seqState->stateOffb, &seqState->DStream, ofNext, ofnbBits);   \n    }\n\n    return seq;\n}\n\n#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION\nMEM_STATIC int ZSTD_dictionaryIsActive(ZSTD_DCtx const* dctx, BYTE const* prefixStart, BYTE const* oLitEnd)\n{\n    size_t const windowSize = dctx->fParams.windowSize;\n     \n    if (dctx->dictContentEndForFuzzing == NULL) return 0;\n     \n    if (prefixStart == dctx->dictContentBeginForFuzzing) return 1;\n     \n    if (dctx->dictEnd != dctx->dictContentEndForFuzzing) return 0;\n     \n    if ((size_t)(oLitEnd - prefixStart) >= windowSize) return 0;\n     \n    return 1;\n}\n\nMEM_STATIC void ZSTD_assertValidSequence(\n        ZSTD_DCtx const* dctx,\n        BYTE const* op, BYTE const* oend,\n        seq_t const seq,\n        BYTE const* prefixStart, BYTE const* virtualStart)\n{\n#if DEBUGLEVEL >= 1\n    size_t const windowSize = dctx->fParams.windowSize;\n    size_t const sequenceSize = seq.litLength + seq.matchLength;\n    BYTE const* const oLitEnd = op + seq.litLength;\n    DEBUGLOG(6, \"Checking sequence: litL=%u matchL=%u offset=%u\",\n            (U32)seq.litLength, (U32)seq.matchLength, (U32)seq.offset);\n    assert(op <= oend);\n    assert((size_t)(oend - op) >= sequenceSize);\n    assert(sequenceSize <= ZSTD_BLOCKSIZE_MAX);\n    if (ZSTD_dictionaryIsActive(dctx, prefixStart, oLitEnd)) {\n        size_t const dictSize = (size_t)((char const*)dctx->dictContentEndForFuzzing - (char const*)dctx->dictContentBeginForFuzzing);\n         \n        assert(seq.offset <= (size_t)(oLitEnd - virtualStart));\n        assert(seq.offset <= windowSize + dictSize);\n    } else {\n         \n        assert(seq.offset <= windowSize);\n    }\n#else\n    (void)dctx, (void)op, (void)oend, (void)seq, (void)prefixStart, (void)virtualStart;\n#endif\n}\n#endif\n\n#ifndef ZSTD_FORCE_DECOMPRESS_SEQUENCES_LONG\n\n\nFORCE_INLINE_TEMPLATE size_t\nDONT_VECTORIZE\nZSTD_decompressSequences_bodySplitLitBuffer( ZSTD_DCtx* dctx,\n                               void* dst, size_t maxDstSize,\n                         const void* seqStart, size_t seqSize, int nbSeq,\n                         const ZSTD_longOffset_e isLongOffset,\n                         const int frame)\n{\n    const BYTE* ip = (const BYTE*)seqStart;\n    const BYTE* const iend = ip + seqSize;\n    BYTE* const ostart = (BYTE*)dst;\n    BYTE* const oend = ostart + maxDstSize;\n    BYTE* op = ostart;\n    const BYTE* litPtr = dctx->litPtr;\n    const BYTE* litBufferEnd = dctx->litBufferEnd;\n    const BYTE* const prefixStart = (const BYTE*) (dctx->prefixStart);\n    const BYTE* const vBase = (const BYTE*) (dctx->virtualStart);\n    const BYTE* const dictEnd = (const BYTE*) (dctx->dictEnd);\n    DEBUGLOG(5, \"ZSTD_decompressSequences_bodySplitLitBuffer\");\n    (void)frame;\n\n     \n    if (nbSeq) {\n        seqState_t seqState;\n        dctx->fseEntropy = 1;\n        { U32 i; for (i=0; i<ZSTD_REP_NUM; i++) seqState.prevOffset[i] = dctx->entropy.rep[i]; }\n        RETURN_ERROR_IF(\n            ERR_isError(BIT_initDStream(&seqState.DStream, ip, iend-ip)),\n            corruption_detected, \"\");\n        ZSTD_initFseState(&seqState.stateLL, &seqState.DStream, dctx->LLTptr);\n        ZSTD_initFseState(&seqState.stateOffb, &seqState.DStream, dctx->OFTptr);\n        ZSTD_initFseState(&seqState.stateML, &seqState.DStream, dctx->MLTptr);\n        assert(dst != NULL);\n\n        ZSTD_STATIC_ASSERT(\n                BIT_DStream_unfinished < BIT_DStream_completed &&\n                BIT_DStream_endOfBuffer < BIT_DStream_completed &&\n                BIT_DStream_completed < BIT_DStream_overflow);\n\n         \n        {\n            seq_t sequence = ZSTD_decodeSequence(&seqState, isLongOffset);\n             \n#if defined(__x86_64__)\n            __asm__(\".p2align 6\");\n#  if __GNUC__ >= 7\n\t     \n            __asm__(\"nop\");\n            __asm__(\".p2align 5\");\n            __asm__(\"nop\");\n            __asm__(\".p2align 4\");\n#    if __GNUC__ == 8 || __GNUC__ == 10\n\t     \n            __asm__(\"nop\");\n            __asm__(\".p2align 3\");\n#    endif\n#  endif\n#endif\n\n             \n            for (; litPtr + sequence.litLength <= dctx->litBufferEnd; ) {\n                size_t const oneSeqSize = ZSTD_execSequenceSplitLitBuffer(op, oend, litPtr + sequence.litLength - WILDCOPY_OVERLENGTH, sequence, &litPtr, litBufferEnd, prefixStart, vBase, dictEnd);\n#if defined(FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION) && defined(FUZZING_ASSERT_VALID_SEQUENCE)\n                assert(!ZSTD_isError(oneSeqSize));\n                if (frame) ZSTD_assertValidSequence(dctx, op, oend, sequence, prefixStart, vBase);\n#endif\n                if (UNLIKELY(ZSTD_isError(oneSeqSize)))\n                    return oneSeqSize;\n                DEBUGLOG(6, \"regenerated sequence size : %u\", (U32)oneSeqSize);\n                op += oneSeqSize;\n                if (UNLIKELY(!--nbSeq))\n                    break;\n                BIT_reloadDStream(&(seqState.DStream));\n                sequence = ZSTD_decodeSequence(&seqState, isLongOffset);\n            }\n\n             \n            if (nbSeq > 0) {\n                const size_t leftoverLit = dctx->litBufferEnd - litPtr;\n                if (leftoverLit)\n                {\n                    RETURN_ERROR_IF(leftoverLit > (size_t)(oend - op), dstSize_tooSmall, \"remaining lit must fit within dstBuffer\");\n                    ZSTD_safecopyDstBeforeSrc(op, litPtr, leftoverLit);\n                    sequence.litLength -= leftoverLit;\n                    op += leftoverLit;\n                }\n                litPtr = dctx->litExtraBuffer;\n                litBufferEnd = dctx->litExtraBuffer + ZSTD_LITBUFFEREXTRASIZE;\n                dctx->litBufferLocation = ZSTD_not_in_dst;\n                {\n                    size_t const oneSeqSize = ZSTD_execSequence(op, oend, sequence, &litPtr, litBufferEnd, prefixStart, vBase, dictEnd);\n#if defined(FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION) && defined(FUZZING_ASSERT_VALID_SEQUENCE)\n                    assert(!ZSTD_isError(oneSeqSize));\n                    if (frame) ZSTD_assertValidSequence(dctx, op, oend, sequence, prefixStart, vBase);\n#endif\n                    if (UNLIKELY(ZSTD_isError(oneSeqSize)))\n                        return oneSeqSize;\n                    DEBUGLOG(6, \"regenerated sequence size : %u\", (U32)oneSeqSize);\n                    op += oneSeqSize;\n                    if (--nbSeq)\n                        BIT_reloadDStream(&(seqState.DStream));\n                }\n            }\n        }\n\n        if (nbSeq > 0)  \n        {\n\n#if defined(__x86_64__)\n            __asm__(\".p2align 6\");\n            __asm__(\"nop\");\n#  if __GNUC__ != 7\n             \n            __asm__(\".p2align 4\");\n            __asm__(\"nop\");\n            __asm__(\".p2align 3\");\n#  elif __GNUC__ >= 11\n            __asm__(\".p2align 3\");\n#  else\n            __asm__(\".p2align 5\");\n            __asm__(\"nop\");\n            __asm__(\".p2align 3\");\n#  endif\n#endif\n\n            for (; ; ) {\n                seq_t const sequence = ZSTD_decodeSequence(&seqState, isLongOffset);\n                size_t const oneSeqSize = ZSTD_execSequence(op, oend, sequence, &litPtr, litBufferEnd, prefixStart, vBase, dictEnd);\n#if defined(FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION) && defined(FUZZING_ASSERT_VALID_SEQUENCE)\n                assert(!ZSTD_isError(oneSeqSize));\n                if (frame) ZSTD_assertValidSequence(dctx, op, oend, sequence, prefixStart, vBase);\n#endif\n                if (UNLIKELY(ZSTD_isError(oneSeqSize)))\n                    return oneSeqSize;\n                DEBUGLOG(6, \"regenerated sequence size : %u\", (U32)oneSeqSize);\n                op += oneSeqSize;\n                if (UNLIKELY(!--nbSeq))\n                    break;\n                BIT_reloadDStream(&(seqState.DStream));\n            }\n        }\n\n         \n        DEBUGLOG(5, \"ZSTD_decompressSequences_bodySplitLitBuffer: after decode loop, remaining nbSeq : %i\", nbSeq);\n        RETURN_ERROR_IF(nbSeq, corruption_detected, \"\");\n        RETURN_ERROR_IF(BIT_reloadDStream(&seqState.DStream) < BIT_DStream_completed, corruption_detected, \"\");\n         \n        { U32 i; for (i=0; i<ZSTD_REP_NUM; i++) dctx->entropy.rep[i] = (U32)(seqState.prevOffset[i]); }\n    }\n\n     \n    if (dctx->litBufferLocation == ZSTD_split)   \n    {\n        size_t const lastLLSize = litBufferEnd - litPtr;\n        RETURN_ERROR_IF(lastLLSize > (size_t)(oend - op), dstSize_tooSmall, \"\");\n        if (op != NULL) {\n            ZSTD_memmove(op, litPtr, lastLLSize);\n            op += lastLLSize;\n        }\n        litPtr = dctx->litExtraBuffer;\n        litBufferEnd = dctx->litExtraBuffer + ZSTD_LITBUFFEREXTRASIZE;\n        dctx->litBufferLocation = ZSTD_not_in_dst;\n    }\n    {   size_t const lastLLSize = litBufferEnd - litPtr;\n        RETURN_ERROR_IF(lastLLSize > (size_t)(oend-op), dstSize_tooSmall, \"\");\n        if (op != NULL) {\n            ZSTD_memcpy(op, litPtr, lastLLSize);\n            op += lastLLSize;\n        }\n    }\n\n    return op-ostart;\n}\n\nFORCE_INLINE_TEMPLATE size_t\nDONT_VECTORIZE\nZSTD_decompressSequences_body(ZSTD_DCtx* dctx,\n    void* dst, size_t maxDstSize,\n    const void* seqStart, size_t seqSize, int nbSeq,\n    const ZSTD_longOffset_e isLongOffset,\n    const int frame)\n{\n    const BYTE* ip = (const BYTE*)seqStart;\n    const BYTE* const iend = ip + seqSize;\n    BYTE* const ostart = (BYTE*)dst;\n    BYTE* const oend = dctx->litBufferLocation == ZSTD_not_in_dst ? ostart + maxDstSize : dctx->litBuffer;\n    BYTE* op = ostart;\n    const BYTE* litPtr = dctx->litPtr;\n    const BYTE* const litEnd = litPtr + dctx->litSize;\n    const BYTE* const prefixStart = (const BYTE*)(dctx->prefixStart);\n    const BYTE* const vBase = (const BYTE*)(dctx->virtualStart);\n    const BYTE* const dictEnd = (const BYTE*)(dctx->dictEnd);\n    DEBUGLOG(5, \"ZSTD_decompressSequences_body\");\n    (void)frame;\n\n     \n    if (nbSeq) {\n        seqState_t seqState;\n        dctx->fseEntropy = 1;\n        { U32 i; for (i = 0; i < ZSTD_REP_NUM; i++) seqState.prevOffset[i] = dctx->entropy.rep[i]; }\n        RETURN_ERROR_IF(\n            ERR_isError(BIT_initDStream(&seqState.DStream, ip, iend - ip)),\n            corruption_detected, \"\");\n        ZSTD_initFseState(&seqState.stateLL, &seqState.DStream, dctx->LLTptr);\n        ZSTD_initFseState(&seqState.stateOffb, &seqState.DStream, dctx->OFTptr);\n        ZSTD_initFseState(&seqState.stateML, &seqState.DStream, dctx->MLTptr);\n        assert(dst != NULL);\n\n        ZSTD_STATIC_ASSERT(\n            BIT_DStream_unfinished < BIT_DStream_completed &&\n            BIT_DStream_endOfBuffer < BIT_DStream_completed &&\n            BIT_DStream_completed < BIT_DStream_overflow);\n\n#if defined(__x86_64__)\n            __asm__(\".p2align 6\");\n            __asm__(\"nop\");\n#  if __GNUC__ >= 7\n            __asm__(\".p2align 5\");\n            __asm__(\"nop\");\n            __asm__(\".p2align 3\");\n#  else\n            __asm__(\".p2align 4\");\n            __asm__(\"nop\");\n            __asm__(\".p2align 3\");\n#  endif\n#endif\n\n        for ( ; ; ) {\n            seq_t const sequence = ZSTD_decodeSequence(&seqState, isLongOffset);\n            size_t const oneSeqSize = ZSTD_execSequence(op, oend, sequence, &litPtr, litEnd, prefixStart, vBase, dictEnd);\n#if defined(FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION) && defined(FUZZING_ASSERT_VALID_SEQUENCE)\n            assert(!ZSTD_isError(oneSeqSize));\n            if (frame) ZSTD_assertValidSequence(dctx, op, oend, sequence, prefixStart, vBase);\n#endif\n            if (UNLIKELY(ZSTD_isError(oneSeqSize)))\n                return oneSeqSize;\n            DEBUGLOG(6, \"regenerated sequence size : %u\", (U32)oneSeqSize);\n            op += oneSeqSize;\n            if (UNLIKELY(!--nbSeq))\n                break;\n            BIT_reloadDStream(&(seqState.DStream));\n        }\n\n         \n        DEBUGLOG(5, \"ZSTD_decompressSequences_body: after decode loop, remaining nbSeq : %i\", nbSeq);\n        RETURN_ERROR_IF(nbSeq, corruption_detected, \"\");\n        RETURN_ERROR_IF(BIT_reloadDStream(&seqState.DStream) < BIT_DStream_completed, corruption_detected, \"\");\n         \n        { U32 i; for (i=0; i<ZSTD_REP_NUM; i++) dctx->entropy.rep[i] = (U32)(seqState.prevOffset[i]); }\n    }\n\n     \n    {   size_t const lastLLSize = litEnd - litPtr;\n        RETURN_ERROR_IF(lastLLSize > (size_t)(oend-op), dstSize_tooSmall, \"\");\n        if (op != NULL) {\n            ZSTD_memcpy(op, litPtr, lastLLSize);\n            op += lastLLSize;\n        }\n    }\n\n    return op-ostart;\n}\n\nstatic size_t\nZSTD_decompressSequences_default(ZSTD_DCtx* dctx,\n                                 void* dst, size_t maxDstSize,\n                           const void* seqStart, size_t seqSize, int nbSeq,\n                           const ZSTD_longOffset_e isLongOffset,\n                           const int frame)\n{\n    return ZSTD_decompressSequences_body(dctx, dst, maxDstSize, seqStart, seqSize, nbSeq, isLongOffset, frame);\n}\n\nstatic size_t\nZSTD_decompressSequencesSplitLitBuffer_default(ZSTD_DCtx* dctx,\n                                               void* dst, size_t maxDstSize,\n                                         const void* seqStart, size_t seqSize, int nbSeq,\n                                         const ZSTD_longOffset_e isLongOffset,\n                                         const int frame)\n{\n    return ZSTD_decompressSequences_bodySplitLitBuffer(dctx, dst, maxDstSize, seqStart, seqSize, nbSeq, isLongOffset, frame);\n}\n#endif  \n\n#ifndef ZSTD_FORCE_DECOMPRESS_SEQUENCES_SHORT\n\nFORCE_INLINE_TEMPLATE size_t\nZSTD_prefetchMatch(size_t prefetchPos, seq_t const sequence,\n                   const BYTE* const prefixStart, const BYTE* const dictEnd)\n{\n    prefetchPos += sequence.litLength;\n    {   const BYTE* const matchBase = (sequence.offset > prefetchPos) ? dictEnd : prefixStart;\n        const BYTE* const match = matchBase + prefetchPos - sequence.offset;  \n        PREFETCH_L1(match); PREFETCH_L1(match+CACHELINE_SIZE);    \n    }\n    return prefetchPos + sequence.matchLength;\n}\n\n \nFORCE_INLINE_TEMPLATE size_t\nZSTD_decompressSequencesLong_body(\n                               ZSTD_DCtx* dctx,\n                               void* dst, size_t maxDstSize,\n                         const void* seqStart, size_t seqSize, int nbSeq,\n                         const ZSTD_longOffset_e isLongOffset,\n                         const int frame)\n{\n    const BYTE* ip = (const BYTE*)seqStart;\n    const BYTE* const iend = ip + seqSize;\n    BYTE* const ostart = (BYTE*)dst;\n    BYTE* const oend = dctx->litBufferLocation == ZSTD_in_dst ? dctx->litBuffer : ostart + maxDstSize;\n    BYTE* op = ostart;\n    const BYTE* litPtr = dctx->litPtr;\n    const BYTE* litBufferEnd = dctx->litBufferEnd;\n    const BYTE* const prefixStart = (const BYTE*) (dctx->prefixStart);\n    const BYTE* const dictStart = (const BYTE*) (dctx->virtualStart);\n    const BYTE* const dictEnd = (const BYTE*) (dctx->dictEnd);\n    (void)frame;\n\n     \n    if (nbSeq) {\n#define STORED_SEQS 8\n#define STORED_SEQS_MASK (STORED_SEQS-1)\n#define ADVANCED_SEQS STORED_SEQS\n        seq_t sequences[STORED_SEQS];\n        int const seqAdvance = MIN(nbSeq, ADVANCED_SEQS);\n        seqState_t seqState;\n        int seqNb;\n        size_t prefetchPos = (size_t)(op-prefixStart);  \n\n        dctx->fseEntropy = 1;\n        { int i; for (i=0; i<ZSTD_REP_NUM; i++) seqState.prevOffset[i] = dctx->entropy.rep[i]; }\n        assert(dst != NULL);\n        assert(iend >= ip);\n        RETURN_ERROR_IF(\n            ERR_isError(BIT_initDStream(&seqState.DStream, ip, iend-ip)),\n            corruption_detected, \"\");\n        ZSTD_initFseState(&seqState.stateLL, &seqState.DStream, dctx->LLTptr);\n        ZSTD_initFseState(&seqState.stateOffb, &seqState.DStream, dctx->OFTptr);\n        ZSTD_initFseState(&seqState.stateML, &seqState.DStream, dctx->MLTptr);\n\n         \n        for (seqNb=0; (BIT_reloadDStream(&seqState.DStream) <= BIT_DStream_completed) && (seqNb<seqAdvance); seqNb++) {\n            seq_t const sequence = ZSTD_decodeSequence(&seqState, isLongOffset);\n            prefetchPos = ZSTD_prefetchMatch(prefetchPos, sequence, prefixStart, dictEnd);\n            sequences[seqNb] = sequence;\n        }\n        RETURN_ERROR_IF(seqNb<seqAdvance, corruption_detected, \"\");\n\n         \n        for (; (BIT_reloadDStream(&(seqState.DStream)) <= BIT_DStream_completed) && (seqNb < nbSeq); seqNb++) {\n            seq_t sequence = ZSTD_decodeSequence(&seqState, isLongOffset);\n            size_t oneSeqSize;\n\n            if (dctx->litBufferLocation == ZSTD_split && litPtr + sequences[(seqNb - ADVANCED_SEQS) & STORED_SEQS_MASK].litLength > dctx->litBufferEnd)\n            {\n                 \n                const size_t leftoverLit = dctx->litBufferEnd - litPtr;\n                if (leftoverLit)\n                {\n                    RETURN_ERROR_IF(leftoverLit > (size_t)(oend - op), dstSize_tooSmall, \"remaining lit must fit within dstBuffer\");\n                    ZSTD_safecopyDstBeforeSrc(op, litPtr, leftoverLit);\n                    sequences[(seqNb - ADVANCED_SEQS) & STORED_SEQS_MASK].litLength -= leftoverLit;\n                    op += leftoverLit;\n                }\n                litPtr = dctx->litExtraBuffer;\n                litBufferEnd = dctx->litExtraBuffer + ZSTD_LITBUFFEREXTRASIZE;\n                dctx->litBufferLocation = ZSTD_not_in_dst;\n                oneSeqSize = ZSTD_execSequence(op, oend, sequences[(seqNb - ADVANCED_SEQS) & STORED_SEQS_MASK], &litPtr, litBufferEnd, prefixStart, dictStart, dictEnd);\n#if defined(FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION) && defined(FUZZING_ASSERT_VALID_SEQUENCE)\n                assert(!ZSTD_isError(oneSeqSize));\n                if (frame) ZSTD_assertValidSequence(dctx, op, oend, sequences[(seqNb - ADVANCED_SEQS) & STORED_SEQS_MASK], prefixStart, dictStart);\n#endif\n                if (ZSTD_isError(oneSeqSize)) return oneSeqSize;\n\n                prefetchPos = ZSTD_prefetchMatch(prefetchPos, sequence, prefixStart, dictEnd);\n                sequences[seqNb & STORED_SEQS_MASK] = sequence;\n                op += oneSeqSize;\n            }\n            else\n            {\n                 \n                oneSeqSize = dctx->litBufferLocation == ZSTD_split ?\n                    ZSTD_execSequenceSplitLitBuffer(op, oend, litPtr + sequences[(seqNb - ADVANCED_SEQS) & STORED_SEQS_MASK].litLength - WILDCOPY_OVERLENGTH, sequences[(seqNb - ADVANCED_SEQS) & STORED_SEQS_MASK], &litPtr, litBufferEnd, prefixStart, dictStart, dictEnd) :\n                    ZSTD_execSequence(op, oend, sequences[(seqNb - ADVANCED_SEQS) & STORED_SEQS_MASK], &litPtr, litBufferEnd, prefixStart, dictStart, dictEnd);\n#if defined(FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION) && defined(FUZZING_ASSERT_VALID_SEQUENCE)\n                assert(!ZSTD_isError(oneSeqSize));\n                if (frame) ZSTD_assertValidSequence(dctx, op, oend, sequences[(seqNb - ADVANCED_SEQS) & STORED_SEQS_MASK], prefixStart, dictStart);\n#endif\n                if (ZSTD_isError(oneSeqSize)) return oneSeqSize;\n\n                prefetchPos = ZSTD_prefetchMatch(prefetchPos, sequence, prefixStart, dictEnd);\n                sequences[seqNb & STORED_SEQS_MASK] = sequence;\n                op += oneSeqSize;\n            }\n        }\n        RETURN_ERROR_IF(seqNb<nbSeq, corruption_detected, \"\");\n\n         \n        seqNb -= seqAdvance;\n        for ( ; seqNb<nbSeq ; seqNb++) {\n            seq_t *sequence = &(sequences[seqNb&STORED_SEQS_MASK]);\n            if (dctx->litBufferLocation == ZSTD_split && litPtr + sequence->litLength > dctx->litBufferEnd)\n            {\n                const size_t leftoverLit = dctx->litBufferEnd - litPtr;\n                if (leftoverLit)\n                {\n                    RETURN_ERROR_IF(leftoverLit > (size_t)(oend - op), dstSize_tooSmall, \"remaining lit must fit within dstBuffer\");\n                    ZSTD_safecopyDstBeforeSrc(op, litPtr, leftoverLit);\n                    sequence->litLength -= leftoverLit;\n                    op += leftoverLit;\n                }\n                litPtr = dctx->litExtraBuffer;\n                litBufferEnd = dctx->litExtraBuffer + ZSTD_LITBUFFEREXTRASIZE;\n                dctx->litBufferLocation = ZSTD_not_in_dst;\n                {\n                    size_t const oneSeqSize = ZSTD_execSequence(op, oend, *sequence, &litPtr, litBufferEnd, prefixStart, dictStart, dictEnd);\n#if defined(FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION) && defined(FUZZING_ASSERT_VALID_SEQUENCE)\n                    assert(!ZSTD_isError(oneSeqSize));\n                    if (frame) ZSTD_assertValidSequence(dctx, op, oend, sequences[seqNb&STORED_SEQS_MASK], prefixStart, dictStart);\n#endif\n                    if (ZSTD_isError(oneSeqSize)) return oneSeqSize;\n                    op += oneSeqSize;\n                }\n            }\n            else\n            {\n                size_t const oneSeqSize = dctx->litBufferLocation == ZSTD_split ?\n                    ZSTD_execSequenceSplitLitBuffer(op, oend, litPtr + sequence->litLength - WILDCOPY_OVERLENGTH, *sequence, &litPtr, litBufferEnd, prefixStart, dictStart, dictEnd) :\n                    ZSTD_execSequence(op, oend, *sequence, &litPtr, litBufferEnd, prefixStart, dictStart, dictEnd);\n#if defined(FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION) && defined(FUZZING_ASSERT_VALID_SEQUENCE)\n                assert(!ZSTD_isError(oneSeqSize));\n                if (frame) ZSTD_assertValidSequence(dctx, op, oend, sequences[seqNb&STORED_SEQS_MASK], prefixStart, dictStart);\n#endif\n                if (ZSTD_isError(oneSeqSize)) return oneSeqSize;\n                op += oneSeqSize;\n            }\n        }\n\n         \n        { U32 i; for (i=0; i<ZSTD_REP_NUM; i++) dctx->entropy.rep[i] = (U32)(seqState.prevOffset[i]); }\n    }\n\n     \n    if (dctx->litBufferLocation == ZSTD_split)   \n    {\n        size_t const lastLLSize = litBufferEnd - litPtr;\n        RETURN_ERROR_IF(lastLLSize > (size_t)(oend - op), dstSize_tooSmall, \"\");\n        if (op != NULL) {\n            ZSTD_memmove(op, litPtr, lastLLSize);\n            op += lastLLSize;\n        }\n        litPtr = dctx->litExtraBuffer;\n        litBufferEnd = dctx->litExtraBuffer + ZSTD_LITBUFFEREXTRASIZE;\n    }\n    {   size_t const lastLLSize = litBufferEnd - litPtr;\n        RETURN_ERROR_IF(lastLLSize > (size_t)(oend-op), dstSize_tooSmall, \"\");\n        if (op != NULL) {\n            ZSTD_memmove(op, litPtr, lastLLSize);\n            op += lastLLSize;\n        }\n    }\n\n    return op-ostart;\n}\n\nstatic size_t\nZSTD_decompressSequencesLong_default(ZSTD_DCtx* dctx,\n                                 void* dst, size_t maxDstSize,\n                           const void* seqStart, size_t seqSize, int nbSeq,\n                           const ZSTD_longOffset_e isLongOffset,\n                           const int frame)\n{\n    return ZSTD_decompressSequencesLong_body(dctx, dst, maxDstSize, seqStart, seqSize, nbSeq, isLongOffset, frame);\n}\n#endif  \n\n\n\n#if DYNAMIC_BMI2\n\n#ifndef ZSTD_FORCE_DECOMPRESS_SEQUENCES_LONG\nstatic BMI2_TARGET_ATTRIBUTE size_t\nDONT_VECTORIZE\nZSTD_decompressSequences_bmi2(ZSTD_DCtx* dctx,\n                                 void* dst, size_t maxDstSize,\n                           const void* seqStart, size_t seqSize, int nbSeq,\n                           const ZSTD_longOffset_e isLongOffset,\n                           const int frame)\n{\n    return ZSTD_decompressSequences_body(dctx, dst, maxDstSize, seqStart, seqSize, nbSeq, isLongOffset, frame);\n}\nstatic BMI2_TARGET_ATTRIBUTE size_t\nDONT_VECTORIZE\nZSTD_decompressSequencesSplitLitBuffer_bmi2(ZSTD_DCtx* dctx,\n                                 void* dst, size_t maxDstSize,\n                           const void* seqStart, size_t seqSize, int nbSeq,\n                           const ZSTD_longOffset_e isLongOffset,\n                           const int frame)\n{\n    return ZSTD_decompressSequences_bodySplitLitBuffer(dctx, dst, maxDstSize, seqStart, seqSize, nbSeq, isLongOffset, frame);\n}\n#endif  \n\n#ifndef ZSTD_FORCE_DECOMPRESS_SEQUENCES_SHORT\nstatic BMI2_TARGET_ATTRIBUTE size_t\nZSTD_decompressSequencesLong_bmi2(ZSTD_DCtx* dctx,\n                                 void* dst, size_t maxDstSize,\n                           const void* seqStart, size_t seqSize, int nbSeq,\n                           const ZSTD_longOffset_e isLongOffset,\n                           const int frame)\n{\n    return ZSTD_decompressSequencesLong_body(dctx, dst, maxDstSize, seqStart, seqSize, nbSeq, isLongOffset, frame);\n}\n#endif  \n\n#endif  \n\ntypedef size_t (*ZSTD_decompressSequences_t)(\n                            ZSTD_DCtx* dctx,\n                            void* dst, size_t maxDstSize,\n                            const void* seqStart, size_t seqSize, int nbSeq,\n                            const ZSTD_longOffset_e isLongOffset,\n                            const int frame);\n\n#ifndef ZSTD_FORCE_DECOMPRESS_SEQUENCES_LONG\nstatic size_t\nZSTD_decompressSequences(ZSTD_DCtx* dctx, void* dst, size_t maxDstSize,\n                   const void* seqStart, size_t seqSize, int nbSeq,\n                   const ZSTD_longOffset_e isLongOffset,\n                   const int frame)\n{\n    DEBUGLOG(5, \"ZSTD_decompressSequences\");\n#if DYNAMIC_BMI2\n    if (ZSTD_DCtx_get_bmi2(dctx)) {\n        return ZSTD_decompressSequences_bmi2(dctx, dst, maxDstSize, seqStart, seqSize, nbSeq, isLongOffset, frame);\n    }\n#endif\n    return ZSTD_decompressSequences_default(dctx, dst, maxDstSize, seqStart, seqSize, nbSeq, isLongOffset, frame);\n}\nstatic size_t\nZSTD_decompressSequencesSplitLitBuffer(ZSTD_DCtx* dctx, void* dst, size_t maxDstSize,\n                                 const void* seqStart, size_t seqSize, int nbSeq,\n                                 const ZSTD_longOffset_e isLongOffset,\n                                 const int frame)\n{\n    DEBUGLOG(5, \"ZSTD_decompressSequencesSplitLitBuffer\");\n#if DYNAMIC_BMI2\n    if (ZSTD_DCtx_get_bmi2(dctx)) {\n        return ZSTD_decompressSequencesSplitLitBuffer_bmi2(dctx, dst, maxDstSize, seqStart, seqSize, nbSeq, isLongOffset, frame);\n    }\n#endif\n    return ZSTD_decompressSequencesSplitLitBuffer_default(dctx, dst, maxDstSize, seqStart, seqSize, nbSeq, isLongOffset, frame);\n}\n#endif  \n\n\n#ifndef ZSTD_FORCE_DECOMPRESS_SEQUENCES_SHORT\n \nstatic size_t\nZSTD_decompressSequencesLong(ZSTD_DCtx* dctx,\n                             void* dst, size_t maxDstSize,\n                             const void* seqStart, size_t seqSize, int nbSeq,\n                             const ZSTD_longOffset_e isLongOffset,\n                             const int frame)\n{\n    DEBUGLOG(5, \"ZSTD_decompressSequencesLong\");\n#if DYNAMIC_BMI2\n    if (ZSTD_DCtx_get_bmi2(dctx)) {\n        return ZSTD_decompressSequencesLong_bmi2(dctx, dst, maxDstSize, seqStart, seqSize, nbSeq, isLongOffset, frame);\n    }\n#endif\n  return ZSTD_decompressSequencesLong_default(dctx, dst, maxDstSize, seqStart, seqSize, nbSeq, isLongOffset, frame);\n}\n#endif  \n\n\n\n#if !defined(ZSTD_FORCE_DECOMPRESS_SEQUENCES_SHORT) && \\\n    !defined(ZSTD_FORCE_DECOMPRESS_SEQUENCES_LONG)\n \nstatic unsigned\nZSTD_getLongOffsetsShare(const ZSTD_seqSymbol* offTable)\n{\n    const void* ptr = offTable;\n    U32 const tableLog = ((const ZSTD_seqSymbol_header*)ptr)[0].tableLog;\n    const ZSTD_seqSymbol* table = offTable + 1;\n    U32 const max = 1 << tableLog;\n    U32 u, total = 0;\n    DEBUGLOG(5, \"ZSTD_getLongOffsetsShare: (tableLog=%u)\", tableLog);\n\n    assert(max <= (1 << OffFSELog));   \n    for (u=0; u<max; u++) {\n        if (table[u].nbAdditionalBits > 22) total += 1;\n    }\n\n    assert(tableLog <= OffFSELog);\n    total <<= (OffFSELog - tableLog);   \n\n    return total;\n}\n#endif\n\nsize_t\nZSTD_decompressBlock_internal(ZSTD_DCtx* dctx,\n                              void* dst, size_t dstCapacity,\n                        const void* src, size_t srcSize, const int frame, const streaming_operation streaming)\n{    \n    const BYTE* ip = (const BYTE*)src;\n     \n    ZSTD_longOffset_e const isLongOffset = (ZSTD_longOffset_e)(MEM_32bits() && (!frame || (dctx->fParams.windowSize > (1ULL << STREAM_ACCUMULATOR_MIN))));\n    DEBUGLOG(5, \"ZSTD_decompressBlock_internal (size : %u)\", (U32)srcSize);\n\n    RETURN_ERROR_IF(srcSize >= ZSTD_BLOCKSIZE_MAX, srcSize_wrong, \"\");\n\n     \n    {   size_t const litCSize = ZSTD_decodeLiteralsBlock(dctx, src, srcSize, dst, dstCapacity, streaming);\n        DEBUGLOG(5, \"ZSTD_decodeLiteralsBlock : %u\", (U32)litCSize);\n        if (ZSTD_isError(litCSize)) return litCSize;\n        ip += litCSize;\n        srcSize -= litCSize;\n    }\n\n     \n    {\n         \n#if !defined(ZSTD_FORCE_DECOMPRESS_SEQUENCES_SHORT) && \\\n    !defined(ZSTD_FORCE_DECOMPRESS_SEQUENCES_LONG)\n        int usePrefetchDecoder = dctx->ddictIsCold;\n#endif\n        int nbSeq;\n        size_t const seqHSize = ZSTD_decodeSeqHeaders(dctx, &nbSeq, ip, srcSize);\n        if (ZSTD_isError(seqHSize)) return seqHSize;\n        ip += seqHSize;\n        srcSize -= seqHSize;\n\n        RETURN_ERROR_IF(dst == NULL && nbSeq > 0, dstSize_tooSmall, \"NULL not handled\");\n\n#if !defined(ZSTD_FORCE_DECOMPRESS_SEQUENCES_SHORT) && \\\n    !defined(ZSTD_FORCE_DECOMPRESS_SEQUENCES_LONG)\n        if ( !usePrefetchDecoder\n          && (!frame || (dctx->fParams.windowSize > (1<<24)))\n          && (nbSeq>ADVANCED_SEQS) ) {   \n            U32 const shareLongOffsets = ZSTD_getLongOffsetsShare(dctx->OFTptr);\n            U32 const minShare = MEM_64bits() ? 7 : 20;  \n            usePrefetchDecoder = (shareLongOffsets >= minShare);\n        }\n#endif\n\n        dctx->ddictIsCold = 0;\n\n#if !defined(ZSTD_FORCE_DECOMPRESS_SEQUENCES_SHORT) && \\\n    !defined(ZSTD_FORCE_DECOMPRESS_SEQUENCES_LONG)\n        if (usePrefetchDecoder)\n#endif\n#ifndef ZSTD_FORCE_DECOMPRESS_SEQUENCES_SHORT\n            return ZSTD_decompressSequencesLong(dctx, dst, dstCapacity, ip, srcSize, nbSeq, isLongOffset, frame);\n#endif\n\n#ifndef ZSTD_FORCE_DECOMPRESS_SEQUENCES_LONG\n         \n        if (dctx->litBufferLocation == ZSTD_split)\n            return ZSTD_decompressSequencesSplitLitBuffer(dctx, dst, dstCapacity, ip, srcSize, nbSeq, isLongOffset, frame);\n        else\n            return ZSTD_decompressSequences(dctx, dst, dstCapacity, ip, srcSize, nbSeq, isLongOffset, frame);\n#endif\n    }\n}\n\n\nvoid ZSTD_checkContinuity(ZSTD_DCtx* dctx, const void* dst, size_t dstSize)\n{\n    if (dst != dctx->previousDstEnd && dstSize > 0) {    \n        dctx->dictEnd = dctx->previousDstEnd;\n        dctx->virtualStart = (const char*)dst - ((const char*)(dctx->previousDstEnd) - (const char*)(dctx->prefixStart));\n        dctx->prefixStart = dst;\n        dctx->previousDstEnd = dst;\n    }\n}\n\n\nsize_t ZSTD_decompressBlock(ZSTD_DCtx* dctx,\n                            void* dst, size_t dstCapacity,\n                      const void* src, size_t srcSize)\n{\n    size_t dSize;\n    ZSTD_checkContinuity(dctx, dst, dstCapacity);\n    dSize = ZSTD_decompressBlock_internal(dctx, dst, dstCapacity, src, srcSize,   0, not_streaming);\n    dctx->previousDstEnd = (char*)dst + dSize;\n    return dSize;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}