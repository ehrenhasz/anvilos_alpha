{
  "module_name": "bitstream.h",
  "hash_id": "ea5e1c6c38655dfe175e207e6e37104ec11c12d3eb8fb08e02d08c45154eb6ef",
  "original_prompt": "Ingested from linux-6.6.14/lib/zstd/common/bitstream.h",
  "human_readable_source": " \n#ifndef BITSTREAM_H_MODULE\n#define BITSTREAM_H_MODULE\n\n \n\n \n#include \"mem.h\"             \n#include \"compiler.h\"        \n#include \"debug.h\"           \n#include \"error_private.h\"   \n\n\n \n\n#define STREAM_ACCUMULATOR_MIN_32  25\n#define STREAM_ACCUMULATOR_MIN_64  57\n#define STREAM_ACCUMULATOR_MIN    ((U32)(MEM_32bits() ? STREAM_ACCUMULATOR_MIN_32 : STREAM_ACCUMULATOR_MIN_64))\n\n\n \n \ntypedef struct {\n    size_t bitContainer;\n    unsigned bitPos;\n    char*  startPtr;\n    char*  ptr;\n    char*  endPtr;\n} BIT_CStream_t;\n\nMEM_STATIC size_t BIT_initCStream(BIT_CStream_t* bitC, void* dstBuffer, size_t dstCapacity);\nMEM_STATIC void   BIT_addBits(BIT_CStream_t* bitC, size_t value, unsigned nbBits);\nMEM_STATIC void   BIT_flushBits(BIT_CStream_t* bitC);\nMEM_STATIC size_t BIT_closeCStream(BIT_CStream_t* bitC);\n\n \n\n\n \ntypedef struct {\n    size_t   bitContainer;\n    unsigned bitsConsumed;\n    const char* ptr;\n    const char* start;\n    const char* limitPtr;\n} BIT_DStream_t;\n\ntypedef enum { BIT_DStream_unfinished = 0,\n               BIT_DStream_endOfBuffer = 1,\n               BIT_DStream_completed = 2,\n               BIT_DStream_overflow = 3 } BIT_DStream_status;   \n                \n\nMEM_STATIC size_t   BIT_initDStream(BIT_DStream_t* bitD, const void* srcBuffer, size_t srcSize);\nMEM_STATIC size_t   BIT_readBits(BIT_DStream_t* bitD, unsigned nbBits);\nMEM_STATIC BIT_DStream_status BIT_reloadDStream(BIT_DStream_t* bitD);\nMEM_STATIC unsigned BIT_endOfDStream(const BIT_DStream_t* bitD);\n\n\n \n\n\n \nMEM_STATIC void BIT_addBitsFast(BIT_CStream_t* bitC, size_t value, unsigned nbBits);\n \n\nMEM_STATIC void BIT_flushBitsFast(BIT_CStream_t* bitC);\n \n\nMEM_STATIC size_t BIT_readBitsFast(BIT_DStream_t* bitD, unsigned nbBits);\n \n\n\n\n \nMEM_STATIC unsigned BIT_highbit32 (U32 val)\n{\n    assert(val != 0);\n    {\n#   if (__GNUC__ >= 3)    \n        return __builtin_clz (val) ^ 31;\n#   else    \n        static const unsigned DeBruijnClz[32] = { 0,  9,  1, 10, 13, 21,  2, 29,\n                                                 11, 14, 16, 18, 22, 25,  3, 30,\n                                                  8, 12, 20, 28, 15, 17, 24,  7,\n                                                 19, 27, 23,  6, 26,  5,  4, 31 };\n        U32 v = val;\n        v |= v >> 1;\n        v |= v >> 2;\n        v |= v >> 4;\n        v |= v >> 8;\n        v |= v >> 16;\n        return DeBruijnClz[ (U32) (v * 0x07C4ACDDU) >> 27];\n#   endif\n    }\n}\n\n \nstatic const unsigned BIT_mask[] = {\n    0,          1,         3,         7,         0xF,       0x1F,\n    0x3F,       0x7F,      0xFF,      0x1FF,     0x3FF,     0x7FF,\n    0xFFF,      0x1FFF,    0x3FFF,    0x7FFF,    0xFFFF,    0x1FFFF,\n    0x3FFFF,    0x7FFFF,   0xFFFFF,   0x1FFFFF,  0x3FFFFF,  0x7FFFFF,\n    0xFFFFFF,   0x1FFFFFF, 0x3FFFFFF, 0x7FFFFFF, 0xFFFFFFF, 0x1FFFFFFF,\n    0x3FFFFFFF, 0x7FFFFFFF};  \n#define BIT_MASK_SIZE (sizeof(BIT_mask) / sizeof(BIT_mask[0]))\n\n \n \nMEM_STATIC size_t BIT_initCStream(BIT_CStream_t* bitC,\n                                  void* startPtr, size_t dstCapacity)\n{\n    bitC->bitContainer = 0;\n    bitC->bitPos = 0;\n    bitC->startPtr = (char*)startPtr;\n    bitC->ptr = bitC->startPtr;\n    bitC->endPtr = bitC->startPtr + dstCapacity - sizeof(bitC->bitContainer);\n    if (dstCapacity <= sizeof(bitC->bitContainer)) return ERROR(dstSize_tooSmall);\n    return 0;\n}\n\n \nMEM_STATIC void BIT_addBits(BIT_CStream_t* bitC,\n                            size_t value, unsigned nbBits)\n{\n    DEBUG_STATIC_ASSERT(BIT_MASK_SIZE == 32);\n    assert(nbBits < BIT_MASK_SIZE);\n    assert(nbBits + bitC->bitPos < sizeof(bitC->bitContainer) * 8);\n    bitC->bitContainer |= (value & BIT_mask[nbBits]) << bitC->bitPos;\n    bitC->bitPos += nbBits;\n}\n\n \nMEM_STATIC void BIT_addBitsFast(BIT_CStream_t* bitC,\n                                size_t value, unsigned nbBits)\n{\n    assert((value>>nbBits) == 0);\n    assert(nbBits + bitC->bitPos < sizeof(bitC->bitContainer) * 8);\n    bitC->bitContainer |= value << bitC->bitPos;\n    bitC->bitPos += nbBits;\n}\n\n \nMEM_STATIC void BIT_flushBitsFast(BIT_CStream_t* bitC)\n{\n    size_t const nbBytes = bitC->bitPos >> 3;\n    assert(bitC->bitPos < sizeof(bitC->bitContainer) * 8);\n    assert(bitC->ptr <= bitC->endPtr);\n    MEM_writeLEST(bitC->ptr, bitC->bitContainer);\n    bitC->ptr += nbBytes;\n    bitC->bitPos &= 7;\n    bitC->bitContainer >>= nbBytes*8;\n}\n\n \nMEM_STATIC void BIT_flushBits(BIT_CStream_t* bitC)\n{\n    size_t const nbBytes = bitC->bitPos >> 3;\n    assert(bitC->bitPos < sizeof(bitC->bitContainer) * 8);\n    assert(bitC->ptr <= bitC->endPtr);\n    MEM_writeLEST(bitC->ptr, bitC->bitContainer);\n    bitC->ptr += nbBytes;\n    if (bitC->ptr > bitC->endPtr) bitC->ptr = bitC->endPtr;\n    bitC->bitPos &= 7;\n    bitC->bitContainer >>= nbBytes*8;\n}\n\n \nMEM_STATIC size_t BIT_closeCStream(BIT_CStream_t* bitC)\n{\n    BIT_addBitsFast(bitC, 1, 1);    \n    BIT_flushBits(bitC);\n    if (bitC->ptr >= bitC->endPtr) return 0;  \n    return (bitC->ptr - bitC->startPtr) + (bitC->bitPos > 0);\n}\n\n\n \n \nMEM_STATIC size_t BIT_initDStream(BIT_DStream_t* bitD, const void* srcBuffer, size_t srcSize)\n{\n    if (srcSize < 1) { ZSTD_memset(bitD, 0, sizeof(*bitD)); return ERROR(srcSize_wrong); }\n\n    bitD->start = (const char*)srcBuffer;\n    bitD->limitPtr = bitD->start + sizeof(bitD->bitContainer);\n\n    if (srcSize >=  sizeof(bitD->bitContainer)) {   \n        bitD->ptr   = (const char*)srcBuffer + srcSize - sizeof(bitD->bitContainer);\n        bitD->bitContainer = MEM_readLEST(bitD->ptr);\n        { BYTE const lastByte = ((const BYTE*)srcBuffer)[srcSize-1];\n          bitD->bitsConsumed = lastByte ? 8 - BIT_highbit32(lastByte) : 0;   \n          if (lastByte == 0) return ERROR(GENERIC);   }\n    } else {\n        bitD->ptr   = bitD->start;\n        bitD->bitContainer = *(const BYTE*)(bitD->start);\n        switch(srcSize)\n        {\n        case 7: bitD->bitContainer += (size_t)(((const BYTE*)(srcBuffer))[6]) << (sizeof(bitD->bitContainer)*8 - 16);\n                ZSTD_FALLTHROUGH;\n\n        case 6: bitD->bitContainer += (size_t)(((const BYTE*)(srcBuffer))[5]) << (sizeof(bitD->bitContainer)*8 - 24);\n                ZSTD_FALLTHROUGH;\n\n        case 5: bitD->bitContainer += (size_t)(((const BYTE*)(srcBuffer))[4]) << (sizeof(bitD->bitContainer)*8 - 32);\n                ZSTD_FALLTHROUGH;\n\n        case 4: bitD->bitContainer += (size_t)(((const BYTE*)(srcBuffer))[3]) << 24;\n                ZSTD_FALLTHROUGH;\n\n        case 3: bitD->bitContainer += (size_t)(((const BYTE*)(srcBuffer))[2]) << 16;\n                ZSTD_FALLTHROUGH;\n\n        case 2: bitD->bitContainer += (size_t)(((const BYTE*)(srcBuffer))[1]) <<  8;\n                ZSTD_FALLTHROUGH;\n\n        default: break;\n        }\n        {   BYTE const lastByte = ((const BYTE*)srcBuffer)[srcSize-1];\n            bitD->bitsConsumed = lastByte ? 8 - BIT_highbit32(lastByte) : 0;\n            if (lastByte == 0) return ERROR(corruption_detected);   \n        }\n        bitD->bitsConsumed += (U32)(sizeof(bitD->bitContainer) - srcSize)*8;\n    }\n\n    return srcSize;\n}\n\nMEM_STATIC FORCE_INLINE_ATTR size_t BIT_getUpperBits(size_t bitContainer, U32 const start)\n{\n    return bitContainer >> start;\n}\n\nMEM_STATIC FORCE_INLINE_ATTR size_t BIT_getMiddleBits(size_t bitContainer, U32 const start, U32 const nbBits)\n{\n    U32 const regMask = sizeof(bitContainer)*8 - 1;\n     \n    assert(nbBits < BIT_MASK_SIZE);\n     \n#if defined(__x86_64__) || defined(_M_X86)\n    return (bitContainer >> (start & regMask)) & ((((U64)1) << nbBits) - 1);\n#else\n    return (bitContainer >> (start & regMask)) & BIT_mask[nbBits];\n#endif\n}\n\nMEM_STATIC FORCE_INLINE_ATTR size_t BIT_getLowerBits(size_t bitContainer, U32 const nbBits)\n{\n    assert(nbBits < BIT_MASK_SIZE);\n    return bitContainer & BIT_mask[nbBits];\n}\n\n \nMEM_STATIC  FORCE_INLINE_ATTR size_t BIT_lookBits(const BIT_DStream_t*  bitD, U32 nbBits)\n{\n     \n#if 1\n     \n    return BIT_getMiddleBits(bitD->bitContainer, (sizeof(bitD->bitContainer)*8) - bitD->bitsConsumed - nbBits, nbBits);\n#else\n     \n    U32 const regMask = sizeof(bitD->bitContainer)*8 - 1;\n    return ((bitD->bitContainer << (bitD->bitsConsumed & regMask)) >> 1) >> ((regMask-nbBits) & regMask);\n#endif\n}\n\n \nMEM_STATIC size_t BIT_lookBitsFast(const BIT_DStream_t* bitD, U32 nbBits)\n{\n    U32 const regMask = sizeof(bitD->bitContainer)*8 - 1;\n    assert(nbBits >= 1);\n    return (bitD->bitContainer << (bitD->bitsConsumed & regMask)) >> (((regMask+1)-nbBits) & regMask);\n}\n\nMEM_STATIC FORCE_INLINE_ATTR void BIT_skipBits(BIT_DStream_t* bitD, U32 nbBits)\n{\n    bitD->bitsConsumed += nbBits;\n}\n\n \nMEM_STATIC FORCE_INLINE_ATTR size_t BIT_readBits(BIT_DStream_t* bitD, unsigned nbBits)\n{\n    size_t const value = BIT_lookBits(bitD, nbBits);\n    BIT_skipBits(bitD, nbBits);\n    return value;\n}\n\n \nMEM_STATIC size_t BIT_readBitsFast(BIT_DStream_t* bitD, unsigned nbBits)\n{\n    size_t const value = BIT_lookBitsFast(bitD, nbBits);\n    assert(nbBits >= 1);\n    BIT_skipBits(bitD, nbBits);\n    return value;\n}\n\n \nMEM_STATIC BIT_DStream_status BIT_reloadDStreamFast(BIT_DStream_t* bitD)\n{\n    if (UNLIKELY(bitD->ptr < bitD->limitPtr))\n        return BIT_DStream_overflow;\n    assert(bitD->bitsConsumed <= sizeof(bitD->bitContainer)*8);\n    bitD->ptr -= bitD->bitsConsumed >> 3;\n    bitD->bitsConsumed &= 7;\n    bitD->bitContainer = MEM_readLEST(bitD->ptr);\n    return BIT_DStream_unfinished;\n}\n\n \nMEM_STATIC BIT_DStream_status BIT_reloadDStream(BIT_DStream_t* bitD)\n{\n    if (bitD->bitsConsumed > (sizeof(bitD->bitContainer)*8))   \n        return BIT_DStream_overflow;\n\n    if (bitD->ptr >= bitD->limitPtr) {\n        return BIT_reloadDStreamFast(bitD);\n    }\n    if (bitD->ptr == bitD->start) {\n        if (bitD->bitsConsumed < sizeof(bitD->bitContainer)*8) return BIT_DStream_endOfBuffer;\n        return BIT_DStream_completed;\n    }\n     \n    {   U32 nbBytes = bitD->bitsConsumed >> 3;\n        BIT_DStream_status result = BIT_DStream_unfinished;\n        if (bitD->ptr - nbBytes < bitD->start) {\n            nbBytes = (U32)(bitD->ptr - bitD->start);   \n            result = BIT_DStream_endOfBuffer;\n        }\n        bitD->ptr -= nbBytes;\n        bitD->bitsConsumed -= nbBytes*8;\n        bitD->bitContainer = MEM_readLEST(bitD->ptr);    \n        return result;\n    }\n}\n\n \nMEM_STATIC unsigned BIT_endOfDStream(const BIT_DStream_t* DStream)\n{\n    return ((DStream->ptr == DStream->start) && (DStream->bitsConsumed == sizeof(DStream->bitContainer)*8));\n}\n\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}