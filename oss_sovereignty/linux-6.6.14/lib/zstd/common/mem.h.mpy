{
  "module_name": "mem.h",
  "hash_id": "806f7300b69b4050079834e02fa5bb90631fab27d0247429714fcb061d3f213f",
  "original_prompt": "Ingested from linux-6.6.14/lib/zstd/common/mem.h",
  "human_readable_source": " \n \n\n#ifndef MEM_H_MODULE\n#define MEM_H_MODULE\n\n \n#include <asm/unaligned.h>   \n#include <linux/compiler.h>   \n#include <linux/swab.h>   \n#include <linux/types.h>   \n#include \"debug.h\"   \n\n \n#define MEM_STATIC static inline\n\n \ntypedef uint8_t  BYTE;\ntypedef uint8_t  U8;\ntypedef int8_t   S8;\ntypedef uint16_t U16;\ntypedef int16_t  S16;\ntypedef uint32_t U32;\ntypedef int32_t  S32;\ntypedef uint64_t U64;\ntypedef int64_t  S64;\n\n \n \nMEM_STATIC unsigned MEM_32bits(void);\nMEM_STATIC unsigned MEM_64bits(void);\nMEM_STATIC unsigned MEM_isLittleEndian(void);\n\n \nMEM_STATIC U16 MEM_read16(const void* memPtr);\nMEM_STATIC U32 MEM_read32(const void* memPtr);\nMEM_STATIC U64 MEM_read64(const void* memPtr);\nMEM_STATIC size_t MEM_readST(const void* memPtr);\n\nMEM_STATIC void MEM_write16(void* memPtr, U16 value);\nMEM_STATIC void MEM_write32(void* memPtr, U32 value);\nMEM_STATIC void MEM_write64(void* memPtr, U64 value);\n\n \nMEM_STATIC U16 MEM_readLE16(const void* memPtr);\nMEM_STATIC U32 MEM_readLE24(const void* memPtr);\nMEM_STATIC U32 MEM_readLE32(const void* memPtr);\nMEM_STATIC U64 MEM_readLE64(const void* memPtr);\nMEM_STATIC size_t MEM_readLEST(const void* memPtr);\n\nMEM_STATIC void MEM_writeLE16(void* memPtr, U16 val);\nMEM_STATIC void MEM_writeLE24(void* memPtr, U32 val);\nMEM_STATIC void MEM_writeLE32(void* memPtr, U32 val32);\nMEM_STATIC void MEM_writeLE64(void* memPtr, U64 val64);\nMEM_STATIC void MEM_writeLEST(void* memPtr, size_t val);\n\n \nMEM_STATIC U32 MEM_readBE32(const void* memPtr);\nMEM_STATIC U64 MEM_readBE64(const void* memPtr);\nMEM_STATIC size_t MEM_readBEST(const void* memPtr);\n\nMEM_STATIC void MEM_writeBE32(void* memPtr, U32 val32);\nMEM_STATIC void MEM_writeBE64(void* memPtr, U64 val64);\nMEM_STATIC void MEM_writeBEST(void* memPtr, size_t val);\n\n \nMEM_STATIC U32 MEM_swap32(U32 in);\nMEM_STATIC U64 MEM_swap64(U64 in);\nMEM_STATIC size_t MEM_swapST(size_t in);\n\n \nMEM_STATIC unsigned MEM_32bits(void)\n{\n    return sizeof(size_t) == 4;\n}\n\nMEM_STATIC unsigned MEM_64bits(void)\n{\n    return sizeof(size_t) == 8;\n}\n\n#if defined(__LITTLE_ENDIAN)\n#define MEM_LITTLE_ENDIAN 1\n#else\n#define MEM_LITTLE_ENDIAN 0\n#endif\n\nMEM_STATIC unsigned MEM_isLittleEndian(void)\n{\n    return MEM_LITTLE_ENDIAN;\n}\n\nMEM_STATIC U16 MEM_read16(const void *memPtr)\n{\n    return get_unaligned((const U16 *)memPtr);\n}\n\nMEM_STATIC U32 MEM_read32(const void *memPtr)\n{\n    return get_unaligned((const U32 *)memPtr);\n}\n\nMEM_STATIC U64 MEM_read64(const void *memPtr)\n{\n    return get_unaligned((const U64 *)memPtr);\n}\n\nMEM_STATIC size_t MEM_readST(const void *memPtr)\n{\n    return get_unaligned((const size_t *)memPtr);\n}\n\nMEM_STATIC void MEM_write16(void *memPtr, U16 value)\n{\n    put_unaligned(value, (U16 *)memPtr);\n}\n\nMEM_STATIC void MEM_write32(void *memPtr, U32 value)\n{\n    put_unaligned(value, (U32 *)memPtr);\n}\n\nMEM_STATIC void MEM_write64(void *memPtr, U64 value)\n{\n    put_unaligned(value, (U64 *)memPtr);\n}\n\n \n\nMEM_STATIC U16 MEM_readLE16(const void *memPtr)\n{\n    return get_unaligned_le16(memPtr);\n}\n\nMEM_STATIC void MEM_writeLE16(void *memPtr, U16 val)\n{\n    put_unaligned_le16(val, memPtr);\n}\n\nMEM_STATIC U32 MEM_readLE24(const void *memPtr)\n{\n    return MEM_readLE16(memPtr) + (((const BYTE *)memPtr)[2] << 16);\n}\n\nMEM_STATIC void MEM_writeLE24(void *memPtr, U32 val)\n{\n\tMEM_writeLE16(memPtr, (U16)val);\n\t((BYTE *)memPtr)[2] = (BYTE)(val >> 16);\n}\n\nMEM_STATIC U32 MEM_readLE32(const void *memPtr)\n{\n    return get_unaligned_le32(memPtr);\n}\n\nMEM_STATIC void MEM_writeLE32(void *memPtr, U32 val32)\n{\n    put_unaligned_le32(val32, memPtr);\n}\n\nMEM_STATIC U64 MEM_readLE64(const void *memPtr)\n{\n    return get_unaligned_le64(memPtr);\n}\n\nMEM_STATIC void MEM_writeLE64(void *memPtr, U64 val64)\n{\n    put_unaligned_le64(val64, memPtr);\n}\n\nMEM_STATIC size_t MEM_readLEST(const void *memPtr)\n{\n\tif (MEM_32bits())\n\t\treturn (size_t)MEM_readLE32(memPtr);\n\telse\n\t\treturn (size_t)MEM_readLE64(memPtr);\n}\n\nMEM_STATIC void MEM_writeLEST(void *memPtr, size_t val)\n{\n\tif (MEM_32bits())\n\t\tMEM_writeLE32(memPtr, (U32)val);\n\telse\n\t\tMEM_writeLE64(memPtr, (U64)val);\n}\n\n \n\nMEM_STATIC U32 MEM_readBE32(const void *memPtr)\n{\n    return get_unaligned_be32(memPtr);\n}\n\nMEM_STATIC void MEM_writeBE32(void *memPtr, U32 val32)\n{\n    put_unaligned_be32(val32, memPtr);\n}\n\nMEM_STATIC U64 MEM_readBE64(const void *memPtr)\n{\n    return get_unaligned_be64(memPtr);\n}\n\nMEM_STATIC void MEM_writeBE64(void *memPtr, U64 val64)\n{\n    put_unaligned_be64(val64, memPtr);\n}\n\nMEM_STATIC size_t MEM_readBEST(const void *memPtr)\n{\n\tif (MEM_32bits())\n\t\treturn (size_t)MEM_readBE32(memPtr);\n\telse\n\t\treturn (size_t)MEM_readBE64(memPtr);\n}\n\nMEM_STATIC void MEM_writeBEST(void *memPtr, size_t val)\n{\n\tif (MEM_32bits())\n\t\tMEM_writeBE32(memPtr, (U32)val);\n\telse\n\t\tMEM_writeBE64(memPtr, (U64)val);\n}\n\nMEM_STATIC U32 MEM_swap32(U32 in)\n{\n    return swab32(in);\n}\n\nMEM_STATIC U64 MEM_swap64(U64 in)\n{\n    return swab64(in);\n}\n\nMEM_STATIC size_t MEM_swapST(size_t in)\n{\n    if (MEM_32bits())\n        return (size_t)MEM_swap32((U32)in);\n    else\n        return (size_t)MEM_swap64((U64)in);\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}