{
  "module_name": "entropy_common.c",
  "hash_id": "43dccd56f4c13d165651e80ba560781fafbe69790c095950ebad2a24fc6e7f97",
  "original_prompt": "Ingested from linux-6.6.14/lib/zstd/common/entropy_common.c",
  "human_readable_source": " \n\n \n#include \"mem.h\"\n#include \"error_private.h\"        \n#define FSE_STATIC_LINKING_ONLY   \n#include \"fse.h\"\n#define HUF_STATIC_LINKING_ONLY   \n#include \"huf.h\"\n\n\n \nunsigned FSE_versionNumber(void) { return FSE_VERSION_NUMBER; }\n\n\n \nunsigned FSE_isError(size_t code) { return ERR_isError(code); }\nconst char* FSE_getErrorName(size_t code) { return ERR_getErrorName(code); }\n\nunsigned HUF_isError(size_t code) { return ERR_isError(code); }\nconst char* HUF_getErrorName(size_t code) { return ERR_getErrorName(code); }\n\n\n \nstatic U32 FSE_ctz(U32 val)\n{\n    assert(val != 0);\n    {\n#   if (__GNUC__ >= 3)    \n        return __builtin_ctz(val);\n#   else    \n        U32 count = 0;\n        while ((val & 1) == 0) {\n            val >>= 1;\n            ++count;\n        }\n        return count;\n#   endif\n    }\n}\n\nFORCE_INLINE_TEMPLATE\nsize_t FSE_readNCount_body(short* normalizedCounter, unsigned* maxSVPtr, unsigned* tableLogPtr,\n                           const void* headerBuffer, size_t hbSize)\n{\n    const BYTE* const istart = (const BYTE*) headerBuffer;\n    const BYTE* const iend = istart + hbSize;\n    const BYTE* ip = istart;\n    int nbBits;\n    int remaining;\n    int threshold;\n    U32 bitStream;\n    int bitCount;\n    unsigned charnum = 0;\n    unsigned const maxSV1 = *maxSVPtr + 1;\n    int previous0 = 0;\n\n    if (hbSize < 8) {\n         \n        char buffer[8] = {0};\n        ZSTD_memcpy(buffer, headerBuffer, hbSize);\n        {   size_t const countSize = FSE_readNCount(normalizedCounter, maxSVPtr, tableLogPtr,\n                                                    buffer, sizeof(buffer));\n            if (FSE_isError(countSize)) return countSize;\n            if (countSize > hbSize) return ERROR(corruption_detected);\n            return countSize;\n    }   }\n    assert(hbSize >= 8);\n\n     \n    ZSTD_memset(normalizedCounter, 0, (*maxSVPtr+1) * sizeof(normalizedCounter[0]));    \n    bitStream = MEM_readLE32(ip);\n    nbBits = (bitStream & 0xF) + FSE_MIN_TABLELOG;    \n    if (nbBits > FSE_TABLELOG_ABSOLUTE_MAX) return ERROR(tableLog_tooLarge);\n    bitStream >>= 4;\n    bitCount = 4;\n    *tableLogPtr = nbBits;\n    remaining = (1<<nbBits)+1;\n    threshold = 1<<nbBits;\n    nbBits++;\n\n    for (;;) {\n        if (previous0) {\n             \n            int repeats = FSE_ctz(~bitStream | 0x80000000) >> 1;\n            while (repeats >= 12) {\n                charnum += 3 * 12;\n                if (LIKELY(ip <= iend-7)) {\n                    ip += 3;\n                } else {\n                    bitCount -= (int)(8 * (iend - 7 - ip));\n                    bitCount &= 31;\n                    ip = iend - 4;\n                }\n                bitStream = MEM_readLE32(ip) >> bitCount;\n                repeats = FSE_ctz(~bitStream | 0x80000000) >> 1;\n            }\n            charnum += 3 * repeats;\n            bitStream >>= 2 * repeats;\n            bitCount += 2 * repeats;\n\n             \n            assert((bitStream & 3) < 3);\n            charnum += bitStream & 3;\n            bitCount += 2;\n\n             \n            if (charnum >= maxSV1) break;\n\n             \n\n            if (LIKELY(ip <= iend-7) || (ip + (bitCount>>3) <= iend-4)) {\n                assert((bitCount >> 3) <= 3);  \n                ip += bitCount>>3;\n                bitCount &= 7;\n            } else {\n                bitCount -= (int)(8 * (iend - 4 - ip));\n                bitCount &= 31;\n                ip = iend - 4;\n            }\n            bitStream = MEM_readLE32(ip) >> bitCount;\n        }\n        {\n            int const max = (2*threshold-1) - remaining;\n            int count;\n\n            if ((bitStream & (threshold-1)) < (U32)max) {\n                count = bitStream & (threshold-1);\n                bitCount += nbBits-1;\n            } else {\n                count = bitStream & (2*threshold-1);\n                if (count >= threshold) count -= max;\n                bitCount += nbBits;\n            }\n\n            count--;    \n             \n            if (count >= 0) {\n                remaining -= count;\n            } else {\n                assert(count == -1);\n                remaining += count;\n            }\n            normalizedCounter[charnum++] = (short)count;\n            previous0 = !count;\n\n            assert(threshold > 1);\n            if (remaining < threshold) {\n                 \n                if (remaining <= 1) break;\n                nbBits = BIT_highbit32(remaining) + 1;\n                threshold = 1 << (nbBits - 1);\n            }\n            if (charnum >= maxSV1) break;\n\n            if (LIKELY(ip <= iend-7) || (ip + (bitCount>>3) <= iend-4)) {\n                ip += bitCount>>3;\n                bitCount &= 7;\n            } else {\n                bitCount -= (int)(8 * (iend - 4 - ip));\n                bitCount &= 31;\n                ip = iend - 4;\n            }\n            bitStream = MEM_readLE32(ip) >> bitCount;\n    }   }\n    if (remaining != 1) return ERROR(corruption_detected);\n     \n    if (charnum > maxSV1) return ERROR(maxSymbolValue_tooSmall);\n    if (bitCount > 32) return ERROR(corruption_detected);\n    *maxSVPtr = charnum-1;\n\n    ip += (bitCount+7)>>3;\n    return ip-istart;\n}\n\n \nstatic size_t FSE_readNCount_body_default(\n        short* normalizedCounter, unsigned* maxSVPtr, unsigned* tableLogPtr,\n        const void* headerBuffer, size_t hbSize)\n{\n    return FSE_readNCount_body(normalizedCounter, maxSVPtr, tableLogPtr, headerBuffer, hbSize);\n}\n\n#if DYNAMIC_BMI2\nBMI2_TARGET_ATTRIBUTE static size_t FSE_readNCount_body_bmi2(\n        short* normalizedCounter, unsigned* maxSVPtr, unsigned* tableLogPtr,\n        const void* headerBuffer, size_t hbSize)\n{\n    return FSE_readNCount_body(normalizedCounter, maxSVPtr, tableLogPtr, headerBuffer, hbSize);\n}\n#endif\n\nsize_t FSE_readNCount_bmi2(\n        short* normalizedCounter, unsigned* maxSVPtr, unsigned* tableLogPtr,\n        const void* headerBuffer, size_t hbSize, int bmi2)\n{\n#if DYNAMIC_BMI2\n    if (bmi2) {\n        return FSE_readNCount_body_bmi2(normalizedCounter, maxSVPtr, tableLogPtr, headerBuffer, hbSize);\n    }\n#endif\n    (void)bmi2;\n    return FSE_readNCount_body_default(normalizedCounter, maxSVPtr, tableLogPtr, headerBuffer, hbSize);\n}\n\nsize_t FSE_readNCount(\n        short* normalizedCounter, unsigned* maxSVPtr, unsigned* tableLogPtr,\n        const void* headerBuffer, size_t hbSize)\n{\n    return FSE_readNCount_bmi2(normalizedCounter, maxSVPtr, tableLogPtr, headerBuffer, hbSize,   0);\n}\n\n\n \nsize_t HUF_readStats(BYTE* huffWeight, size_t hwSize, U32* rankStats,\n                     U32* nbSymbolsPtr, U32* tableLogPtr,\n                     const void* src, size_t srcSize)\n{\n    U32 wksp[HUF_READ_STATS_WORKSPACE_SIZE_U32];\n    return HUF_readStats_wksp(huffWeight, hwSize, rankStats, nbSymbolsPtr, tableLogPtr, src, srcSize, wksp, sizeof(wksp),   0);\n}\n\nFORCE_INLINE_TEMPLATE size_t\nHUF_readStats_body(BYTE* huffWeight, size_t hwSize, U32* rankStats,\n                   U32* nbSymbolsPtr, U32* tableLogPtr,\n                   const void* src, size_t srcSize,\n                   void* workSpace, size_t wkspSize,\n                   int bmi2)\n{\n    U32 weightTotal;\n    const BYTE* ip = (const BYTE*) src;\n    size_t iSize;\n    size_t oSize;\n\n    if (!srcSize) return ERROR(srcSize_wrong);\n    iSize = ip[0];\n     \n        oSize = iSize - 127;\n        iSize = ((oSize+1)/2);\n        if (iSize+1 > srcSize) return ERROR(srcSize_wrong);\n        if (oSize >= hwSize) return ERROR(corruption_detected);\n        ip += 1;\n        {   U32 n;\n            for (n=0; n<oSize; n+=2) {\n                huffWeight[n]   = ip[n/2] >> 4;\n                huffWeight[n+1] = ip[n/2] & 15;\n    }   }   }\n    else  {    \n        if (iSize+1 > srcSize) return ERROR(srcSize_wrong);\n         \n        oSize = FSE_decompress_wksp_bmi2(huffWeight, hwSize-1, ip+1, iSize, 6, workSpace, wkspSize, bmi2);\n        if (FSE_isError(oSize)) return oSize;\n    }\n\n     \n    ZSTD_memset(rankStats, 0, (HUF_TABLELOG_MAX + 1) * sizeof(U32));\n    weightTotal = 0;\n    {   U32 n; for (n=0; n<oSize; n++) {\n            if (huffWeight[n] > HUF_TABLELOG_MAX) return ERROR(corruption_detected);\n            rankStats[huffWeight[n]]++;\n            weightTotal += (1 << huffWeight[n]) >> 1;\n    }   }\n    if (weightTotal == 0) return ERROR(corruption_detected);\n\n     \n    {   U32 const tableLog = BIT_highbit32(weightTotal) + 1;\n        if (tableLog > HUF_TABLELOG_MAX) return ERROR(corruption_detected);\n        *tableLogPtr = tableLog;\n         \n        {   U32 const total = 1 << tableLog;\n            U32 const rest = total - weightTotal;\n            U32 const verif = 1 << BIT_highbit32(rest);\n            U32 const lastWeight = BIT_highbit32(rest) + 1;\n            if (verif != rest) return ERROR(corruption_detected);     \n            huffWeight[oSize] = (BYTE)lastWeight;\n            rankStats[lastWeight]++;\n    }   }\n\n     \n    if ((rankStats[1] < 2) || (rankStats[1] & 1)) return ERROR(corruption_detected);    \n\n     \n    *nbSymbolsPtr = (U32)(oSize+1);\n    return iSize+1;\n}\n\n \nstatic size_t HUF_readStats_body_default(BYTE* huffWeight, size_t hwSize, U32* rankStats,\n                     U32* nbSymbolsPtr, U32* tableLogPtr,\n                     const void* src, size_t srcSize,\n                     void* workSpace, size_t wkspSize)\n{\n    return HUF_readStats_body(huffWeight, hwSize, rankStats, nbSymbolsPtr, tableLogPtr, src, srcSize, workSpace, wkspSize, 0);\n}\n\n#if DYNAMIC_BMI2\nstatic BMI2_TARGET_ATTRIBUTE size_t HUF_readStats_body_bmi2(BYTE* huffWeight, size_t hwSize, U32* rankStats,\n                     U32* nbSymbolsPtr, U32* tableLogPtr,\n                     const void* src, size_t srcSize,\n                     void* workSpace, size_t wkspSize)\n{\n    return HUF_readStats_body(huffWeight, hwSize, rankStats, nbSymbolsPtr, tableLogPtr, src, srcSize, workSpace, wkspSize, 1);\n}\n#endif\n\nsize_t HUF_readStats_wksp(BYTE* huffWeight, size_t hwSize, U32* rankStats,\n                     U32* nbSymbolsPtr, U32* tableLogPtr,\n                     const void* src, size_t srcSize,\n                     void* workSpace, size_t wkspSize,\n                     int bmi2)\n{\n#if DYNAMIC_BMI2\n    if (bmi2) {\n        return HUF_readStats_body_bmi2(huffWeight, hwSize, rankStats, nbSymbolsPtr, tableLogPtr, src, srcSize, workSpace, wkspSize);\n    }\n#endif\n    (void)bmi2;\n    return HUF_readStats_body_default(huffWeight, hwSize, rankStats, nbSymbolsPtr, tableLogPtr, src, srcSize, workSpace, wkspSize);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}