{
  "module_name": "zstd_internal.h",
  "hash_id": "5a2d52c22cb88269f5c54e468b78abf7b3292e519ce0b1b4d312f0ba6abb3a81",
  "original_prompt": "Ingested from linux-6.6.14/lib/zstd/common/zstd_internal.h",
  "human_readable_source": " \n\n#ifndef ZSTD_CCOMMON_H_MODULE\n#define ZSTD_CCOMMON_H_MODULE\n\n \n\n \n#include \"compiler.h\"\n#include \"cpu.h\"\n#include \"mem.h\"\n#include \"debug.h\"                  \n#include \"error_private.h\"\n#define ZSTD_STATIC_LINKING_ONLY\n#include <linux/zstd.h>\n#define FSE_STATIC_LINKING_ONLY\n#include \"fse.h\"\n#define HUF_STATIC_LINKING_ONLY\n#include \"huf.h\"\n#include <linux/xxhash.h>                 \n#define ZSTD_TRACE 0\n\n\n \n#define ZSTD_STATIC_ASSERT(c) DEBUG_STATIC_ASSERT(c)\n#define ZSTD_isError ERR_isError    \n#define FSE_isError  ERR_isError\n#define HUF_isError  ERR_isError\n\n\n \n#undef MIN\n#undef MAX\n#define MIN(a,b) ((a)<(b) ? (a) : (b))\n#define MAX(a,b) ((a)>(b) ? (a) : (b))\n#define BOUNDED(min,val,max) (MAX(min,MIN(val,max)))\n\n\n \n#define ZSTD_OPT_NUM    (1<<12)\n\n#define ZSTD_REP_NUM      3                  \nstatic UNUSED_ATTR const U32 repStartValue[ZSTD_REP_NUM] = { 1, 4, 8 };\n\n#define KB *(1 <<10)\n#define MB *(1 <<20)\n#define GB *(1U<<30)\n\n#define BIT7 128\n#define BIT6  64\n#define BIT5  32\n#define BIT4  16\n#define BIT1   2\n#define BIT0   1\n\n#define ZSTD_WINDOWLOG_ABSOLUTEMIN 10\nstatic UNUSED_ATTR const size_t ZSTD_fcs_fieldSize[4] = { 0, 2, 4, 8 };\nstatic UNUSED_ATTR const size_t ZSTD_did_fieldSize[4] = { 0, 1, 2, 4 };\n\n#define ZSTD_FRAMEIDSIZE 4    \n\n#define ZSTD_BLOCKHEADERSIZE 3    \nstatic UNUSED_ATTR const size_t ZSTD_blockHeaderSize = ZSTD_BLOCKHEADERSIZE;\ntypedef enum { bt_raw, bt_rle, bt_compressed, bt_reserved } blockType_e;\n\n#define ZSTD_FRAMECHECKSUMSIZE 4\n\n#define MIN_SEQUENCES_SIZE 1  \n#define MIN_CBLOCK_SIZE (1   + 1   + MIN_SEQUENCES_SIZE  )    \n\n#define HufLog 12\ntypedef enum { set_basic, set_rle, set_compressed, set_repeat } symbolEncodingType_e;\n\n#define LONGNBSEQ 0x7F00\n\n#define MINMATCH 3\n\n#define Litbits  8\n#define MaxLit ((1<<Litbits) - 1)\n#define MaxML   52\n#define MaxLL   35\n#define DefaultMaxOff 28\n#define MaxOff  31\n#define MaxSeq MAX(MaxLL, MaxML)    \n#define MLFSELog    9\n#define LLFSELog    9\n#define OffFSELog   8\n#define MaxFSELog  MAX(MAX(MLFSELog, LLFSELog), OffFSELog)\n\n#define ZSTD_MAX_HUF_HEADER_SIZE 128  \n \n#define ZSTD_MAX_FSE_HEADERS_SIZE (((MaxML + 1) * MLFSELog + (MaxLL + 1) * LLFSELog + (MaxOff + 1) * OffFSELog + 7) / 8)\n\nstatic UNUSED_ATTR const U8 LL_bits[MaxLL+1] = {\n     0, 0, 0, 0, 0, 0, 0, 0,\n     0, 0, 0, 0, 0, 0, 0, 0,\n     1, 1, 1, 1, 2, 2, 3, 3,\n     4, 6, 7, 8, 9,10,11,12,\n    13,14,15,16\n};\nstatic UNUSED_ATTR const S16 LL_defaultNorm[MaxLL+1] = {\n     4, 3, 2, 2, 2, 2, 2, 2,\n     2, 2, 2, 2, 2, 1, 1, 1,\n     2, 2, 2, 2, 2, 2, 2, 2,\n     2, 3, 2, 1, 1, 1, 1, 1,\n    -1,-1,-1,-1\n};\n#define LL_DEFAULTNORMLOG 6   \nstatic UNUSED_ATTR const U32 LL_defaultNormLog = LL_DEFAULTNORMLOG;\n\nstatic UNUSED_ATTR const U8 ML_bits[MaxML+1] = {\n     0, 0, 0, 0, 0, 0, 0, 0,\n     0, 0, 0, 0, 0, 0, 0, 0,\n     0, 0, 0, 0, 0, 0, 0, 0,\n     0, 0, 0, 0, 0, 0, 0, 0,\n     1, 1, 1, 1, 2, 2, 3, 3,\n     4, 4, 5, 7, 8, 9,10,11,\n    12,13,14,15,16\n};\nstatic UNUSED_ATTR const S16 ML_defaultNorm[MaxML+1] = {\n     1, 4, 3, 2, 2, 2, 2, 2,\n     2, 1, 1, 1, 1, 1, 1, 1,\n     1, 1, 1, 1, 1, 1, 1, 1,\n     1, 1, 1, 1, 1, 1, 1, 1,\n     1, 1, 1, 1, 1, 1, 1, 1,\n     1, 1, 1, 1, 1, 1,-1,-1,\n    -1,-1,-1,-1,-1\n};\n#define ML_DEFAULTNORMLOG 6   \nstatic UNUSED_ATTR const U32 ML_defaultNormLog = ML_DEFAULTNORMLOG;\n\nstatic UNUSED_ATTR const S16 OF_defaultNorm[DefaultMaxOff+1] = {\n     1, 1, 1, 1, 1, 1, 2, 2,\n     2, 1, 1, 1, 1, 1, 1, 1,\n     1, 1, 1, 1, 1, 1, 1, 1,\n    -1,-1,-1,-1,-1\n};\n#define OF_DEFAULTNORMLOG 5   \nstatic UNUSED_ATTR const U32 OF_defaultNormLog = OF_DEFAULTNORMLOG;\n\n\n \nstatic void ZSTD_copy8(void* dst, const void* src) {\n#if defined(ZSTD_ARCH_ARM_NEON)\n    vst1_u8((uint8_t*)dst, vld1_u8((const uint8_t*)src));\n#else\n    ZSTD_memcpy(dst, src, 8);\n#endif\n}\n#define COPY8(d,s) { ZSTD_copy8(d,s); d+=8; s+=8; }\n\n \nstatic void ZSTD_copy16(void* dst, const void* src) {\n#if defined(ZSTD_ARCH_ARM_NEON)\n    vst1q_u8((uint8_t*)dst, vld1q_u8((const uint8_t*)src));\n#elif defined(ZSTD_ARCH_X86_SSE2)\n    _mm_storeu_si128((__m128i*)dst, _mm_loadu_si128((const __m128i*)src));\n#elif defined(__clang__)\n    ZSTD_memmove(dst, src, 16);\n#else\n     \n    BYTE copy16_buf[16];\n    ZSTD_memcpy(copy16_buf, src, 16);\n    ZSTD_memcpy(dst, copy16_buf, 16);\n#endif\n}\n#define COPY16(d,s) { ZSTD_copy16(d,s); d+=16; s+=16; }\n\n#define WILDCOPY_OVERLENGTH 32\n#define WILDCOPY_VECLEN 16\n\ntypedef enum {\n    ZSTD_no_overlap,\n    ZSTD_overlap_src_before_dst\n     \n} ZSTD_overlap_e;\n\n \nMEM_STATIC FORCE_INLINE_ATTR\nvoid ZSTD_wildcopy(void* dst, const void* src, ptrdiff_t length, ZSTD_overlap_e const ovtype)\n{\n    ptrdiff_t diff = (BYTE*)dst - (const BYTE*)src;\n    const BYTE* ip = (const BYTE*)src;\n    BYTE* op = (BYTE*)dst;\n    BYTE* const oend = op + length;\n\n    if (ovtype == ZSTD_overlap_src_before_dst && diff < WILDCOPY_VECLEN) {\n         \n        do {\n            COPY8(op, ip)\n        } while (op < oend);\n    } else {\n        assert(diff >= WILDCOPY_VECLEN || diff <= -WILDCOPY_VECLEN);\n         \n#ifdef __aarch64__\n        do {\n            COPY16(op, ip);\n        }\n        while (op < oend);\n#else\n        ZSTD_copy16(op, ip);\n        if (16 >= length) return;\n        op += 16;\n        ip += 16;\n        do {\n            COPY16(op, ip);\n            COPY16(op, ip);\n        }\n        while (op < oend);\n#endif\n    }\n}\n\nMEM_STATIC size_t ZSTD_limitCopy(void* dst, size_t dstCapacity, const void* src, size_t srcSize)\n{\n    size_t const length = MIN(dstCapacity, srcSize);\n    if (length > 0) {\n        ZSTD_memcpy(dst, src, length);\n    }\n    return length;\n}\n\n \n#define ZSTD_WORKSPACETOOLARGE_FACTOR 3\n\n \n#define ZSTD_WORKSPACETOOLARGE_MAXDURATION 128\n\n \ntypedef enum {\n    ZSTD_bm_buffered = 0,   \n    ZSTD_bm_stable = 1      \n} ZSTD_bufferMode_e;\n\n\n \ntypedef struct seqDef_s {\n    U32 offBase;    \n    U16 litLength;\n    U16 mlBase;     \n} seqDef;\n\n \ntypedef enum {\n    ZSTD_llt_none = 0,              \n    ZSTD_llt_literalLength = 1,     \n    ZSTD_llt_matchLength = 2        \n} ZSTD_longLengthType_e;\n\ntypedef struct {\n    seqDef* sequencesStart;\n    seqDef* sequences;       \n    BYTE* litStart;\n    BYTE* lit;               \n    BYTE* llCode;\n    BYTE* mlCode;\n    BYTE* ofCode;\n    size_t maxNbSeq;\n    size_t maxNbLit;\n\n     \n    ZSTD_longLengthType_e   longLengthType;\n    U32                     longLengthPos;   \n} seqStore_t;\n\ntypedef struct {\n    U32 litLength;\n    U32 matchLength;\n} ZSTD_sequenceLength;\n\n \nMEM_STATIC ZSTD_sequenceLength ZSTD_getSequenceLength(seqStore_t const* seqStore, seqDef const* seq)\n{\n    ZSTD_sequenceLength seqLen;\n    seqLen.litLength = seq->litLength;\n    seqLen.matchLength = seq->mlBase + MINMATCH;\n    if (seqStore->longLengthPos == (U32)(seq - seqStore->sequencesStart)) {\n        if (seqStore->longLengthType == ZSTD_llt_literalLength) {\n            seqLen.litLength += 0xFFFF;\n        }\n        if (seqStore->longLengthType == ZSTD_llt_matchLength) {\n            seqLen.matchLength += 0xFFFF;\n        }\n    }\n    return seqLen;\n}\n\n \ntypedef struct {\n    size_t compressedSize;\n    unsigned long long decompressedBound;\n} ZSTD_frameSizeInfo;    \n\nconst seqStore_t* ZSTD_getSeqStore(const ZSTD_CCtx* ctx);    \nvoid ZSTD_seqToCodes(const seqStore_t* seqStorePtr);    \n\n \nvoid* ZSTD_customMalloc(size_t size, ZSTD_customMem customMem);\nvoid* ZSTD_customCalloc(size_t size, ZSTD_customMem customMem);\nvoid ZSTD_customFree(void* ptr, ZSTD_customMem customMem);\n\n\nMEM_STATIC U32 ZSTD_highbit32(U32 val)    \n{\n    assert(val != 0);\n    {\n#   if (__GNUC__ >= 3)    \n        return __builtin_clz (val) ^ 31;\n#   else    \n        static const U32 DeBruijnClz[32] = { 0, 9, 1, 10, 13, 21, 2, 29, 11, 14, 16, 18, 22, 25, 3, 30, 8, 12, 20, 28, 15, 17, 24, 7, 19, 27, 23, 6, 26, 5, 4, 31 };\n        U32 v = val;\n        v |= v >> 1;\n        v |= v >> 2;\n        v |= v >> 4;\n        v |= v >> 8;\n        v |= v >> 16;\n        return DeBruijnClz[(v * 0x07C4ACDDU) >> 27];\n#   endif\n    }\n}\n\n \nMEM_STATIC unsigned ZSTD_countTrailingZeros(size_t val)\n{\n    if (MEM_64bits()) {\n#       if (__GNUC__ >= 4)\n            return __builtin_ctzll((U64)val);\n#       else\n            static const int DeBruijnBytePos[64] = {  0,  1,  2,  7,  3, 13,  8, 19,\n                                                      4, 25, 14, 28,  9, 34, 20, 56,\n                                                      5, 17, 26, 54, 15, 41, 29, 43,\n                                                      10, 31, 38, 35, 21, 45, 49, 57,\n                                                      63,  6, 12, 18, 24, 27, 33, 55,\n                                                      16, 53, 40, 42, 30, 37, 44, 48,\n                                                      62, 11, 23, 32, 52, 39, 36, 47,\n                                                      61, 22, 51, 46, 60, 50, 59, 58 };\n            return DeBruijnBytePos[((U64)((val & -(long long)val) * 0x0218A392CDABBD3FULL)) >> 58];\n#       endif\n    } else {  \n#       if (__GNUC__ >= 3)\n            return __builtin_ctz((U32)val);\n#       else\n            static const int DeBruijnBytePos[32] = {  0,  1, 28,  2, 29, 14, 24,  3,\n                                                     30, 22, 20, 15, 25, 17,  4,  8,\n                                                     31, 27, 13, 23, 21, 19, 16,  7,\n                                                     26, 12, 18,  6, 11,  5, 10,  9 };\n            return DeBruijnBytePos[((U32)((val & -(S32)val) * 0x077CB531U)) >> 27];\n#       endif\n    }\n}\n\n\n \nvoid ZSTD_invalidateRepCodes(ZSTD_CCtx* cctx);    \n\n\ntypedef struct {\n    blockType_e blockType;\n    U32 lastBlock;\n    U32 origSize;\n} blockProperties_t;    \n\n \n \nsize_t ZSTD_getcBlockSize(const void* src, size_t srcSize,\n                          blockProperties_t* bpPtr);\n\n \n \nsize_t ZSTD_decodeSeqHeaders(ZSTD_DCtx* dctx, int* nbSeqPtr,\n                       const void* src, size_t srcSize);\n\n \nMEM_STATIC int ZSTD_cpuSupportsBmi2(void)\n{\n    ZSTD_cpuid_t cpuid = ZSTD_cpuid();\n    return ZSTD_cpuid_bmi1(cpuid) && ZSTD_cpuid_bmi2(cpuid);\n}\n\n\n#endif    \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}