{
  "module_name": "zstd_compress_internal.h",
  "hash_id": "90a639e564720ffcb6234c543826b396541ed56416ad062ce4058ca05cc2cb08",
  "original_prompt": "Ingested from linux-6.6.14/lib/zstd/compress/zstd_compress_internal.h",
  "human_readable_source": " \n\n \n\n#ifndef ZSTD_COMPRESS_H\n#define ZSTD_COMPRESS_H\n\n \n#include \"../common/zstd_internal.h\"\n#include \"zstd_cwksp.h\"\n\n\n \n#define kSearchStrength      8\n#define HASH_READ_SIZE       8\n#define ZSTD_DUBT_UNSORTED_MARK 1    \n\n\n \ntypedef enum { ZSTDcs_created=0, ZSTDcs_init, ZSTDcs_ongoing, ZSTDcs_ending } ZSTD_compressionStage_e;\ntypedef enum { zcss_init=0, zcss_load, zcss_flush } ZSTD_cStreamStage;\n\ntypedef struct ZSTD_prefixDict_s {\n    const void* dict;\n    size_t dictSize;\n    ZSTD_dictContentType_e dictContentType;\n} ZSTD_prefixDict;\n\ntypedef struct {\n    void* dictBuffer;\n    void const* dict;\n    size_t dictSize;\n    ZSTD_dictContentType_e dictContentType;\n    ZSTD_CDict* cdict;\n} ZSTD_localDict;\n\ntypedef struct {\n    HUF_CElt CTable[HUF_CTABLE_SIZE_ST(255)];\n    HUF_repeat repeatMode;\n} ZSTD_hufCTables_t;\n\ntypedef struct {\n    FSE_CTable offcodeCTable[FSE_CTABLE_SIZE_U32(OffFSELog, MaxOff)];\n    FSE_CTable matchlengthCTable[FSE_CTABLE_SIZE_U32(MLFSELog, MaxML)];\n    FSE_CTable litlengthCTable[FSE_CTABLE_SIZE_U32(LLFSELog, MaxLL)];\n    FSE_repeat offcode_repeatMode;\n    FSE_repeat matchlength_repeatMode;\n    FSE_repeat litlength_repeatMode;\n} ZSTD_fseCTables_t;\n\ntypedef struct {\n    ZSTD_hufCTables_t huf;\n    ZSTD_fseCTables_t fse;\n} ZSTD_entropyCTables_t;\n\n \n \ntypedef struct {\n    symbolEncodingType_e hType;\n    BYTE hufDesBuffer[ZSTD_MAX_HUF_HEADER_SIZE];\n    size_t hufDesSize;\n} ZSTD_hufCTablesMetadata_t;\n\n \ntypedef struct {\n    symbolEncodingType_e llType;\n    symbolEncodingType_e ofType;\n    symbolEncodingType_e mlType;\n    BYTE fseTablesBuffer[ZSTD_MAX_FSE_HEADERS_SIZE];\n    size_t fseTablesSize;\n    size_t lastCountSize;  \n} ZSTD_fseCTablesMetadata_t;\n\ntypedef struct {\n    ZSTD_hufCTablesMetadata_t hufMetadata;\n    ZSTD_fseCTablesMetadata_t fseMetadata;\n} ZSTD_entropyCTablesMetadata_t;\n\n \nsize_t ZSTD_buildBlockEntropyStats(seqStore_t* seqStorePtr,\n                             const ZSTD_entropyCTables_t* prevEntropy,\n                                   ZSTD_entropyCTables_t* nextEntropy,\n                             const ZSTD_CCtx_params* cctxParams,\n                                   ZSTD_entropyCTablesMetadata_t* entropyMetadata,\n                                   void* workspace, size_t wkspSize);\n\n \n\ntypedef struct {\n    U32 off;             \n    U32 len;             \n} ZSTD_match_t;\n\ntypedef struct {\n    U32 offset;          \n    U32 litLength;       \n    U32 matchLength;     \n} rawSeq;\n\ntypedef struct {\n  rawSeq* seq;           \n  size_t pos;            \n  size_t posInSequence;  \n  size_t size;           \n  size_t capacity;       \n} rawSeqStore_t;\n\nUNUSED_ATTR static const rawSeqStore_t kNullRawSeqStore = {NULL, 0, 0, 0, 0};\n\ntypedef struct {\n    int price;\n    U32 off;\n    U32 mlen;\n    U32 litlen;\n    U32 rep[ZSTD_REP_NUM];\n} ZSTD_optimal_t;\n\ntypedef enum { zop_dynamic=0, zop_predef } ZSTD_OptPrice_e;\n\ntypedef struct {\n     \n    unsigned* litFreq;            \n    unsigned* litLengthFreq;      \n    unsigned* matchLengthFreq;    \n    unsigned* offCodeFreq;        \n    ZSTD_match_t* matchTable;     \n    ZSTD_optimal_t* priceTable;   \n\n    U32  litSum;                  \n    U32  litLengthSum;            \n    U32  matchLengthSum;          \n    U32  offCodeSum;              \n    U32  litSumBasePrice;         \n    U32  litLengthSumBasePrice;   \n    U32  matchLengthSumBasePrice; \n    U32  offCodeSumBasePrice;     \n    ZSTD_OptPrice_e priceType;    \n    const ZSTD_entropyCTables_t* symbolCosts;   \n    ZSTD_paramSwitch_e literalCompressionMode;\n} optState_t;\n\ntypedef struct {\n  ZSTD_entropyCTables_t entropy;\n  U32 rep[ZSTD_REP_NUM];\n} ZSTD_compressedBlockState_t;\n\ntypedef struct {\n    BYTE const* nextSrc;        \n    BYTE const* base;           \n    BYTE const* dictBase;       \n    U32 dictLimit;              \n    U32 lowLimit;               \n    U32 nbOverflowCorrections;  \n} ZSTD_window_t;\n\n#define ZSTD_WINDOW_START_INDEX 2\n\ntypedef struct ZSTD_matchState_t ZSTD_matchState_t;\n\n#define ZSTD_ROW_HASH_CACHE_SIZE 8        \n\nstruct ZSTD_matchState_t {\n    ZSTD_window_t window;    \n    U32 loadedDictEnd;       \n    U32 nextToUpdate;        \n    U32 hashLog3;            \n\n    U32 rowHashLog;                           \n    U16* tagTable;                            \n    U32 hashCache[ZSTD_ROW_HASH_CACHE_SIZE];  \n\n    U32* hashTable;\n    U32* hashTable3;\n    U32* chainTable;\n\n    U32 forceNonContiguous;  \n\n    int dedicatedDictSearch;   \n    optState_t opt;          \n    const ZSTD_matchState_t* dictMatchState;\n    ZSTD_compressionParameters cParams;\n    const rawSeqStore_t* ldmSeqStore;\n};\n\ntypedef struct {\n    ZSTD_compressedBlockState_t* prevCBlock;\n    ZSTD_compressedBlockState_t* nextCBlock;\n    ZSTD_matchState_t matchState;\n} ZSTD_blockState_t;\n\ntypedef struct {\n    U32 offset;\n    U32 checksum;\n} ldmEntry_t;\n\ntypedef struct {\n    BYTE const* split;\n    U32 hash;\n    U32 checksum;\n    ldmEntry_t* bucket;\n} ldmMatchCandidate_t;\n\n#define LDM_BATCH_SIZE 64\n\ntypedef struct {\n    ZSTD_window_t window;    \n    ldmEntry_t* hashTable;\n    U32 loadedDictEnd;\n    BYTE* bucketOffsets;     \n    size_t splitIndices[LDM_BATCH_SIZE];\n    ldmMatchCandidate_t matchCandidates[LDM_BATCH_SIZE];\n} ldmState_t;\n\ntypedef struct {\n    ZSTD_paramSwitch_e enableLdm;  \n    U32 hashLog;             \n    U32 bucketSizeLog;       \n    U32 minMatchLength;      \n    U32 hashRateLog;        \n    U32 windowLog;           \n} ldmParams_t;\n\ntypedef struct {\n    int collectSequences;\n    ZSTD_Sequence* seqStart;\n    size_t seqIndex;\n    size_t maxSequences;\n} SeqCollector;\n\nstruct ZSTD_CCtx_params_s {\n    ZSTD_format_e format;\n    ZSTD_compressionParameters cParams;\n    ZSTD_frameParameters fParams;\n\n    int compressionLevel;\n    int forceWindow;            \n    size_t targetCBlockSize;    \n    int srcSizeHint;            \n\n    ZSTD_dictAttachPref_e attachDictPref;\n    ZSTD_paramSwitch_e literalCompressionMode;\n\n     \n    int nbWorkers;\n    size_t jobSize;\n    int overlapLog;\n    int rsyncable;\n\n     \n    ldmParams_t ldmParams;\n\n     \n    int enableDedicatedDictSearch;\n\n     \n    ZSTD_bufferMode_e inBufferMode;\n    ZSTD_bufferMode_e outBufferMode;\n\n     \n    ZSTD_sequenceFormat_e blockDelimiters;\n    int validateSequences;\n\n     \n    ZSTD_paramSwitch_e useBlockSplitter;\n\n     \n    ZSTD_paramSwitch_e useRowMatchFinder;\n\n     \n    int deterministicRefPrefix;\n\n     \n    ZSTD_customMem customMem;\n};   \n\n#define COMPRESS_SEQUENCES_WORKSPACE_SIZE (sizeof(unsigned) * (MaxSeq + 2))\n#define ENTROPY_WORKSPACE_SIZE (HUF_WORKSPACE_SIZE + COMPRESS_SEQUENCES_WORKSPACE_SIZE)\n\n \ntypedef enum {\n    ZSTDb_not_buffered,\n    ZSTDb_buffered\n} ZSTD_buffered_policy_e;\n\n \n#define ZSTD_MAX_NB_BLOCK_SPLITS 196\ntypedef struct {\n    seqStore_t fullSeqStoreChunk;\n    seqStore_t firstHalfSeqStore;\n    seqStore_t secondHalfSeqStore;\n    seqStore_t currSeqStore;\n    seqStore_t nextSeqStore;\n\n    U32 partitions[ZSTD_MAX_NB_BLOCK_SPLITS];\n    ZSTD_entropyCTablesMetadata_t entropyMetadata;\n} ZSTD_blockSplitCtx;\n\nstruct ZSTD_CCtx_s {\n    ZSTD_compressionStage_e stage;\n    int cParamsChanged;                   \n    int bmi2;                             \n    ZSTD_CCtx_params requestedParams;\n    ZSTD_CCtx_params appliedParams;\n    ZSTD_CCtx_params simpleApiParams;     \n    U32   dictID;\n    size_t dictContentSize;\n\n    ZSTD_cwksp workspace;  \n    size_t blockSize;\n    unsigned long long pledgedSrcSizePlusOne;   \n    unsigned long long consumedSrcSize;\n    unsigned long long producedCSize;\n    struct xxh64_state xxhState;\n    ZSTD_customMem customMem;\n    ZSTD_threadPool* pool;\n    size_t staticSize;\n    SeqCollector seqCollector;\n    int isFirstBlock;\n    int initialized;\n\n    seqStore_t seqStore;       \n    ldmState_t ldmState;       \n    rawSeq* ldmSequences;      \n    size_t maxNbLdmSequences;\n    rawSeqStore_t externSeqStore;  \n    ZSTD_blockState_t blockState;\n    U32* entropyWorkspace;   \n\n     \n    ZSTD_buffered_policy_e bufferedPolicy;\n\n     \n    char*  inBuff;\n    size_t inBuffSize;\n    size_t inToCompress;\n    size_t inBuffPos;\n    size_t inBuffTarget;\n    char*  outBuff;\n    size_t outBuffSize;\n    size_t outBuffContentSize;\n    size_t outBuffFlushedSize;\n    ZSTD_cStreamStage streamStage;\n    U32    frameEnded;\n\n     \n    ZSTD_inBuffer expectedInBuffer;\n    size_t expectedOutBufferSize;\n\n     \n    ZSTD_localDict localDict;\n    const ZSTD_CDict* cdict;\n    ZSTD_prefixDict prefixDict;    \n\n     \n\n     \n\n     \n    ZSTD_blockSplitCtx blockSplitCtx;\n};\n\ntypedef enum { ZSTD_dtlm_fast, ZSTD_dtlm_full } ZSTD_dictTableLoadMethod_e;\n\ntypedef enum {\n    ZSTD_noDict = 0,\n    ZSTD_extDict = 1,\n    ZSTD_dictMatchState = 2,\n    ZSTD_dedicatedDictSearch = 3\n} ZSTD_dictMode_e;\n\ntypedef enum {\n    ZSTD_cpm_noAttachDict = 0,   \n    ZSTD_cpm_attachDict = 1,     \n    ZSTD_cpm_createCDict = 2,    \n    ZSTD_cpm_unknown = 3,        \n} ZSTD_cParamMode_e;\n\ntypedef size_t (*ZSTD_blockCompressor) (\n        ZSTD_matchState_t* bs, seqStore_t* seqStore, U32 rep[ZSTD_REP_NUM],\n        void const* src, size_t srcSize);\nZSTD_blockCompressor ZSTD_selectBlockCompressor(ZSTD_strategy strat, ZSTD_paramSwitch_e rowMatchfinderMode, ZSTD_dictMode_e dictMode);\n\n\nMEM_STATIC U32 ZSTD_LLcode(U32 litLength)\n{\n    static const BYTE LL_Code[64] = {  0,  1,  2,  3,  4,  5,  6,  7,\n                                       8,  9, 10, 11, 12, 13, 14, 15,\n                                      16, 16, 17, 17, 18, 18, 19, 19,\n                                      20, 20, 20, 20, 21, 21, 21, 21,\n                                      22, 22, 22, 22, 22, 22, 22, 22,\n                                      23, 23, 23, 23, 23, 23, 23, 23,\n                                      24, 24, 24, 24, 24, 24, 24, 24,\n                                      24, 24, 24, 24, 24, 24, 24, 24 };\n    static const U32 LL_deltaCode = 19;\n    return (litLength > 63) ? ZSTD_highbit32(litLength) + LL_deltaCode : LL_Code[litLength];\n}\n\n \nMEM_STATIC U32 ZSTD_MLcode(U32 mlBase)\n{\n    static const BYTE ML_Code[128] = { 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,\n                                      16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,\n                                      32, 32, 33, 33, 34, 34, 35, 35, 36, 36, 36, 36, 37, 37, 37, 37,\n                                      38, 38, 38, 38, 38, 38, 38, 38, 39, 39, 39, 39, 39, 39, 39, 39,\n                                      40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40,\n                                      41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41,\n                                      42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42,\n                                      42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42 };\n    static const U32 ML_deltaCode = 36;\n    return (mlBase > 127) ? ZSTD_highbit32(mlBase) + ML_deltaCode : ML_Code[mlBase];\n}\n\n \nMEM_STATIC int ZSTD_cParam_withinBounds(ZSTD_cParameter cParam, int value)\n{\n    ZSTD_bounds const bounds = ZSTD_cParam_getBounds(cParam);\n    if (ZSTD_isError(bounds.error)) return 0;\n    if (value < bounds.lowerBound) return 0;\n    if (value > bounds.upperBound) return 0;\n    return 1;\n}\n\n \nMEM_STATIC size_t ZSTD_noCompressBlock (void* dst, size_t dstCapacity, const void* src, size_t srcSize, U32 lastBlock)\n{\n    U32 const cBlockHeader24 = lastBlock + (((U32)bt_raw)<<1) + (U32)(srcSize << 3);\n    RETURN_ERROR_IF(srcSize + ZSTD_blockHeaderSize > dstCapacity,\n                    dstSize_tooSmall, \"dst buf too small for uncompressed block\");\n    MEM_writeLE24(dst, cBlockHeader24);\n    ZSTD_memcpy((BYTE*)dst + ZSTD_blockHeaderSize, src, srcSize);\n    return ZSTD_blockHeaderSize + srcSize;\n}\n\nMEM_STATIC size_t ZSTD_rleCompressBlock (void* dst, size_t dstCapacity, BYTE src, size_t srcSize, U32 lastBlock)\n{\n    BYTE* const op = (BYTE*)dst;\n    U32 const cBlockHeader = lastBlock + (((U32)bt_rle)<<1) + (U32)(srcSize << 3);\n    RETURN_ERROR_IF(dstCapacity < 4, dstSize_tooSmall, \"\");\n    MEM_writeLE24(op, cBlockHeader);\n    op[3] = src;\n    return 4;\n}\n\n\n \nMEM_STATIC size_t ZSTD_minGain(size_t srcSize, ZSTD_strategy strat)\n{\n    U32 const minlog = (strat>=ZSTD_btultra) ? (U32)(strat) - 1 : 6;\n    ZSTD_STATIC_ASSERT(ZSTD_btultra == 8);\n    assert(ZSTD_cParam_withinBounds(ZSTD_c_strategy, strat));\n    return (srcSize >> minlog) + 2;\n}\n\nMEM_STATIC int ZSTD_literalsCompressionIsDisabled(const ZSTD_CCtx_params* cctxParams)\n{\n    switch (cctxParams->literalCompressionMode) {\n    case ZSTD_ps_enable:\n        return 0;\n    case ZSTD_ps_disable:\n        return 1;\n    default:\n        assert(0  );\n        ZSTD_FALLTHROUGH;\n    case ZSTD_ps_auto:\n        return (cctxParams->cParams.strategy == ZSTD_fast) && (cctxParams->cParams.targetLength > 0);\n    }\n}\n\n \nstatic void\nZSTD_safecopyLiterals(BYTE* op, BYTE const* ip, BYTE const* const iend, BYTE const* ilimit_w)\n{\n    assert(iend > ilimit_w);\n    if (ip <= ilimit_w) {\n        ZSTD_wildcopy(op, ip, ilimit_w - ip, ZSTD_no_overlap);\n        op += ilimit_w - ip;\n        ip = ilimit_w;\n    }\n    while (ip < iend) *op++ = *ip++;\n}\n\n#define ZSTD_REP_MOVE     (ZSTD_REP_NUM-1)\n#define STORE_REPCODE_1 STORE_REPCODE(1)\n#define STORE_REPCODE_2 STORE_REPCODE(2)\n#define STORE_REPCODE_3 STORE_REPCODE(3)\n#define STORE_REPCODE(r) (assert((r)>=1), assert((r)<=3), (r)-1)\n#define STORE_OFFSET(o)  (assert((o)>0), o + ZSTD_REP_MOVE)\n#define STORED_IS_OFFSET(o)  ((o) > ZSTD_REP_MOVE)\n#define STORED_IS_REPCODE(o) ((o) <= ZSTD_REP_MOVE)\n#define STORED_OFFSET(o)  (assert(STORED_IS_OFFSET(o)), (o)-ZSTD_REP_MOVE)\n#define STORED_REPCODE(o) (assert(STORED_IS_REPCODE(o)), (o)+1)   \n#define STORED_TO_OFFBASE(o) ((o)+1)\n#define OFFBASE_TO_STORED(o) ((o)-1)\n\n \nHINT_INLINE UNUSED_ATTR void\nZSTD_storeSeq(seqStore_t* seqStorePtr,\n              size_t litLength, const BYTE* literals, const BYTE* litLimit,\n              U32 offBase_minus1,\n              size_t matchLength)\n{\n    BYTE const* const litLimit_w = litLimit - WILDCOPY_OVERLENGTH;\n    BYTE const* const litEnd = literals + litLength;\n#if defined(DEBUGLEVEL) && (DEBUGLEVEL >= 6)\n    static const BYTE* g_start = NULL;\n    if (g_start==NULL) g_start = (const BYTE*)literals;   \n    {   U32 const pos = (U32)((const BYTE*)literals - g_start);\n        DEBUGLOG(6, \"Cpos%7u :%3u literals, match%4u bytes at offCode%7u\",\n               pos, (U32)litLength, (U32)matchLength, (U32)offBase_minus1);\n    }\n#endif\n    assert((size_t)(seqStorePtr->sequences - seqStorePtr->sequencesStart) < seqStorePtr->maxNbSeq);\n     \n    assert(seqStorePtr->maxNbLit <= 128 KB);\n    assert(seqStorePtr->lit + litLength <= seqStorePtr->litStart + seqStorePtr->maxNbLit);\n    assert(literals + litLength <= litLimit);\n    if (litEnd <= litLimit_w) {\n         \n        assert(WILDCOPY_OVERLENGTH >= 16);\n        ZSTD_copy16(seqStorePtr->lit, literals);\n        if (litLength > 16) {\n            ZSTD_wildcopy(seqStorePtr->lit+16, literals+16, (ptrdiff_t)litLength-16, ZSTD_no_overlap);\n        }\n    } else {\n        ZSTD_safecopyLiterals(seqStorePtr->lit, literals, litEnd, litLimit_w);\n    }\n    seqStorePtr->lit += litLength;\n\n     \n    if (litLength>0xFFFF) {\n        assert(seqStorePtr->longLengthType == ZSTD_llt_none);  \n        seqStorePtr->longLengthType = ZSTD_llt_literalLength;\n        seqStorePtr->longLengthPos = (U32)(seqStorePtr->sequences - seqStorePtr->sequencesStart);\n    }\n    seqStorePtr->sequences[0].litLength = (U16)litLength;\n\n     \n    seqStorePtr->sequences[0].offBase = STORED_TO_OFFBASE(offBase_minus1);\n\n     \n    assert(matchLength >= MINMATCH);\n    {   size_t const mlBase = matchLength - MINMATCH;\n        if (mlBase>0xFFFF) {\n            assert(seqStorePtr->longLengthType == ZSTD_llt_none);  \n            seqStorePtr->longLengthType = ZSTD_llt_matchLength;\n            seqStorePtr->longLengthPos = (U32)(seqStorePtr->sequences - seqStorePtr->sequencesStart);\n        }\n        seqStorePtr->sequences[0].mlBase = (U16)mlBase;\n    }\n\n    seqStorePtr->sequences++;\n}\n\n \nMEM_STATIC void\nZSTD_updateRep(U32 rep[ZSTD_REP_NUM], U32 const offBase_minus1, U32 const ll0)\n{\n    if (STORED_IS_OFFSET(offBase_minus1)) {   \n        rep[2] = rep[1];\n        rep[1] = rep[0];\n        rep[0] = STORED_OFFSET(offBase_minus1);\n    } else {    \n        U32 const repCode = STORED_REPCODE(offBase_minus1) - 1 + ll0;\n        if (repCode > 0) {   \n            U32 const currentOffset = (repCode==ZSTD_REP_NUM) ? (rep[0] - 1) : rep[repCode];\n            rep[2] = (repCode >= 2) ? rep[1] : rep[2];\n            rep[1] = rep[0];\n            rep[0] = currentOffset;\n        } else {    \n             \n        }\n    }\n}\n\ntypedef struct repcodes_s {\n    U32 rep[3];\n} repcodes_t;\n\nMEM_STATIC repcodes_t\nZSTD_newRep(U32 const rep[ZSTD_REP_NUM], U32 const offBase_minus1, U32 const ll0)\n{\n    repcodes_t newReps;\n    ZSTD_memcpy(&newReps, rep, sizeof(newReps));\n    ZSTD_updateRep(newReps.rep, offBase_minus1, ll0);\n    return newReps;\n}\n\n\n \nstatic unsigned ZSTD_NbCommonBytes (size_t val)\n{\n    if (MEM_isLittleEndian()) {\n        if (MEM_64bits()) {\n#       if (__GNUC__ >= 4)\n            return (__builtin_ctzll((U64)val) >> 3);\n#       else\n            static const int DeBruijnBytePos[64] = { 0, 0, 0, 0, 0, 1, 1, 2,\n                                                     0, 3, 1, 3, 1, 4, 2, 7,\n                                                     0, 2, 3, 6, 1, 5, 3, 5,\n                                                     1, 3, 4, 4, 2, 5, 6, 7,\n                                                     7, 0, 1, 2, 3, 3, 4, 6,\n                                                     2, 6, 5, 5, 3, 4, 5, 6,\n                                                     7, 1, 2, 4, 6, 4, 4, 5,\n                                                     7, 2, 6, 5, 7, 6, 7, 7 };\n            return DeBruijnBytePos[((U64)((val & -(long long)val) * 0x0218A392CDABBD3FULL)) >> 58];\n#       endif\n        } else {  \n#       if (__GNUC__ >= 3)\n            return (__builtin_ctz((U32)val) >> 3);\n#       else\n            static const int DeBruijnBytePos[32] = { 0, 0, 3, 0, 3, 1, 3, 0,\n                                                     3, 2, 2, 1, 3, 2, 0, 1,\n                                                     3, 3, 1, 2, 2, 2, 2, 0,\n                                                     3, 1, 2, 0, 1, 0, 1, 1 };\n            return DeBruijnBytePos[((U32)((val & -(S32)val) * 0x077CB531U)) >> 27];\n#       endif\n        }\n    } else {   \n        if (MEM_64bits()) {\n#       if (__GNUC__ >= 4)\n            return (__builtin_clzll(val) >> 3);\n#       else\n            unsigned r;\n            const unsigned n32 = sizeof(size_t)*4;    \n            if (!(val>>n32)) { r=4; } else { r=0; val>>=n32; }\n            if (!(val>>16)) { r+=2; val>>=8; } else { val>>=24; }\n            r += (!val);\n            return r;\n#       endif\n        } else {  \n#       if (__GNUC__ >= 3)\n            return (__builtin_clz((U32)val) >> 3);\n#       else\n            unsigned r;\n            if (!(val>>16)) { r=2; val>>=8; } else { r=0; val>>=24; }\n            r += (!val);\n            return r;\n#       endif\n    }   }\n}\n\n\nMEM_STATIC size_t ZSTD_count(const BYTE* pIn, const BYTE* pMatch, const BYTE* const pInLimit)\n{\n    const BYTE* const pStart = pIn;\n    const BYTE* const pInLoopLimit = pInLimit - (sizeof(size_t)-1);\n\n    if (pIn < pInLoopLimit) {\n        { size_t const diff = MEM_readST(pMatch) ^ MEM_readST(pIn);\n          if (diff) return ZSTD_NbCommonBytes(diff); }\n        pIn+=sizeof(size_t); pMatch+=sizeof(size_t);\n        while (pIn < pInLoopLimit) {\n            size_t const diff = MEM_readST(pMatch) ^ MEM_readST(pIn);\n            if (!diff) { pIn+=sizeof(size_t); pMatch+=sizeof(size_t); continue; }\n            pIn += ZSTD_NbCommonBytes(diff);\n            return (size_t)(pIn - pStart);\n    }   }\n    if (MEM_64bits() && (pIn<(pInLimit-3)) && (MEM_read32(pMatch) == MEM_read32(pIn))) { pIn+=4; pMatch+=4; }\n    if ((pIn<(pInLimit-1)) && (MEM_read16(pMatch) == MEM_read16(pIn))) { pIn+=2; pMatch+=2; }\n    if ((pIn<pInLimit) && (*pMatch == *pIn)) pIn++;\n    return (size_t)(pIn - pStart);\n}\n\n \nMEM_STATIC size_t\nZSTD_count_2segments(const BYTE* ip, const BYTE* match,\n                     const BYTE* iEnd, const BYTE* mEnd, const BYTE* iStart)\n{\n    const BYTE* const vEnd = MIN( ip + (mEnd - match), iEnd);\n    size_t const matchLength = ZSTD_count(ip, match, vEnd);\n    if (match + matchLength != mEnd) return matchLength;\n    DEBUGLOG(7, \"ZSTD_count_2segments: found a 2-parts match (current length==%zu)\", matchLength);\n    DEBUGLOG(7, \"distance from match beginning to end dictionary = %zi\", mEnd - match);\n    DEBUGLOG(7, \"distance from current pos to end buffer = %zi\", iEnd - ip);\n    DEBUGLOG(7, \"next byte : ip==%02X, istart==%02X\", ip[matchLength], *iStart);\n    DEBUGLOG(7, \"final match length = %zu\", matchLength + ZSTD_count(ip+matchLength, iStart, iEnd));\n    return matchLength + ZSTD_count(ip+matchLength, iStart, iEnd);\n}\n\n\n \nstatic const U32 prime3bytes = 506832829U;\nstatic U32    ZSTD_hash3(U32 u, U32 h) { return ((u << (32-24)) * prime3bytes)  >> (32-h) ; }\nMEM_STATIC size_t ZSTD_hash3Ptr(const void* ptr, U32 h) { return ZSTD_hash3(MEM_readLE32(ptr), h); }  \n\nstatic const U32 prime4bytes = 2654435761U;\nstatic U32    ZSTD_hash4(U32 u, U32 h) { return (u * prime4bytes) >> (32-h) ; }\nstatic size_t ZSTD_hash4Ptr(const void* ptr, U32 h) { return ZSTD_hash4(MEM_read32(ptr), h); }\n\nstatic const U64 prime5bytes = 889523592379ULL;\nstatic size_t ZSTD_hash5(U64 u, U32 h) { return (size_t)(((u  << (64-40)) * prime5bytes) >> (64-h)) ; }\nstatic size_t ZSTD_hash5Ptr(const void* p, U32 h) { return ZSTD_hash5(MEM_readLE64(p), h); }\n\nstatic const U64 prime6bytes = 227718039650203ULL;\nstatic size_t ZSTD_hash6(U64 u, U32 h) { return (size_t)(((u  << (64-48)) * prime6bytes) >> (64-h)) ; }\nstatic size_t ZSTD_hash6Ptr(const void* p, U32 h) { return ZSTD_hash6(MEM_readLE64(p), h); }\n\nstatic const U64 prime7bytes = 58295818150454627ULL;\nstatic size_t ZSTD_hash7(U64 u, U32 h) { return (size_t)(((u  << (64-56)) * prime7bytes) >> (64-h)) ; }\nstatic size_t ZSTD_hash7Ptr(const void* p, U32 h) { return ZSTD_hash7(MEM_readLE64(p), h); }\n\nstatic const U64 prime8bytes = 0xCF1BBCDCB7A56463ULL;\nstatic size_t ZSTD_hash8(U64 u, U32 h) { return (size_t)(((u) * prime8bytes) >> (64-h)) ; }\nstatic size_t ZSTD_hash8Ptr(const void* p, U32 h) { return ZSTD_hash8(MEM_readLE64(p), h); }\n\nMEM_STATIC FORCE_INLINE_ATTR\nsize_t ZSTD_hashPtr(const void* p, U32 hBits, U32 mls)\n{\n    switch(mls)\n    {\n    default:\n    case 4: return ZSTD_hash4Ptr(p, hBits);\n    case 5: return ZSTD_hash5Ptr(p, hBits);\n    case 6: return ZSTD_hash6Ptr(p, hBits);\n    case 7: return ZSTD_hash7Ptr(p, hBits);\n    case 8: return ZSTD_hash8Ptr(p, hBits);\n    }\n}\n\n \nstatic U64 ZSTD_ipow(U64 base, U64 exponent)\n{\n    U64 power = 1;\n    while (exponent) {\n      if (exponent & 1) power *= base;\n      exponent >>= 1;\n      base *= base;\n    }\n    return power;\n}\n\n#define ZSTD_ROLL_HASH_CHAR_OFFSET 10\n\n \nstatic U64 ZSTD_rollingHash_append(U64 hash, void const* buf, size_t size)\n{\n    BYTE const* istart = (BYTE const*)buf;\n    size_t pos;\n    for (pos = 0; pos < size; ++pos) {\n        hash *= prime8bytes;\n        hash += istart[pos] + ZSTD_ROLL_HASH_CHAR_OFFSET;\n    }\n    return hash;\n}\n\n \nMEM_STATIC U64 ZSTD_rollingHash_compute(void const* buf, size_t size)\n{\n    return ZSTD_rollingHash_append(0, buf, size);\n}\n\n \nMEM_STATIC U64 ZSTD_rollingHash_primePower(U32 length)\n{\n    return ZSTD_ipow(prime8bytes, length - 1);\n}\n\n \nMEM_STATIC U64 ZSTD_rollingHash_rotate(U64 hash, BYTE toRemove, BYTE toAdd, U64 primePower)\n{\n    hash -= (toRemove + ZSTD_ROLL_HASH_CHAR_OFFSET) * primePower;\n    hash *= prime8bytes;\n    hash += toAdd + ZSTD_ROLL_HASH_CHAR_OFFSET;\n    return hash;\n}\n\n \n#if (ZSTD_WINDOWLOG_MAX_64 > 31)\n# error \"ZSTD_WINDOWLOG_MAX is too large : would overflow ZSTD_CURRENT_MAX\"\n#endif\n \n#define ZSTD_CURRENT_MAX ((3U << 29) + (1U << ZSTD_WINDOWLOG_MAX))\n \n#define ZSTD_CHUNKSIZE_MAX                                                     \\\n    ( ((U32)-1)                               \\\n    - ZSTD_CURRENT_MAX)           \n\n \nMEM_STATIC void ZSTD_window_clear(ZSTD_window_t* window)\n{\n    size_t const endT = (size_t)(window->nextSrc - window->base);\n    U32 const end = (U32)endT;\n\n    window->lowLimit = end;\n    window->dictLimit = end;\n}\n\nMEM_STATIC U32 ZSTD_window_isEmpty(ZSTD_window_t const window)\n{\n    return window.dictLimit == ZSTD_WINDOW_START_INDEX &&\n           window.lowLimit == ZSTD_WINDOW_START_INDEX &&\n           (window.nextSrc - window.base) == ZSTD_WINDOW_START_INDEX;\n}\n\n \nMEM_STATIC U32 ZSTD_window_hasExtDict(ZSTD_window_t const window)\n{\n    return window.lowLimit < window.dictLimit;\n}\n\n \nMEM_STATIC ZSTD_dictMode_e ZSTD_matchState_dictMode(const ZSTD_matchState_t *ms)\n{\n    return ZSTD_window_hasExtDict(ms->window) ?\n        ZSTD_extDict :\n        ms->dictMatchState != NULL ?\n            (ms->dictMatchState->dedicatedDictSearch ? ZSTD_dedicatedDictSearch : ZSTD_dictMatchState) :\n            ZSTD_noDict;\n}\n\n \n#ifndef ZSTD_WINDOW_OVERFLOW_CORRECT_FREQUENTLY\n#  ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION\n#    define ZSTD_WINDOW_OVERFLOW_CORRECT_FREQUENTLY 1\n#  else\n#    define ZSTD_WINDOW_OVERFLOW_CORRECT_FREQUENTLY 0\n#  endif\n#endif\n\n \nMEM_STATIC U32 ZSTD_window_canOverflowCorrect(ZSTD_window_t const window,\n                                              U32 cycleLog,\n                                              U32 maxDist,\n                                              U32 loadedDictEnd,\n                                              void const* src)\n{\n    U32 const cycleSize = 1u << cycleLog;\n    U32 const curr = (U32)((BYTE const*)src - window.base);\n    U32 const minIndexToOverflowCorrect = cycleSize\n                                        + MAX(maxDist, cycleSize)\n                                        + ZSTD_WINDOW_START_INDEX;\n\n     \n    U32 const adjustment = window.nbOverflowCorrections + 1;\n    U32 const adjustedIndex = MAX(minIndexToOverflowCorrect * adjustment,\n                                  minIndexToOverflowCorrect);\n    U32 const indexLargeEnough = curr > adjustedIndex;\n\n     \n    U32 const dictionaryInvalidated = curr > maxDist + loadedDictEnd;\n\n    return indexLargeEnough && dictionaryInvalidated;\n}\n\n \nMEM_STATIC U32 ZSTD_window_needOverflowCorrection(ZSTD_window_t const window,\n                                                  U32 cycleLog,\n                                                  U32 maxDist,\n                                                  U32 loadedDictEnd,\n                                                  void const* src,\n                                                  void const* srcEnd)\n{\n    U32 const curr = (U32)((BYTE const*)srcEnd - window.base);\n    if (ZSTD_WINDOW_OVERFLOW_CORRECT_FREQUENTLY) {\n        if (ZSTD_window_canOverflowCorrect(window, cycleLog, maxDist, loadedDictEnd, src)) {\n            return 1;\n        }\n    }\n    return curr > ZSTD_CURRENT_MAX;\n}\n\n \nMEM_STATIC U32 ZSTD_window_correctOverflow(ZSTD_window_t* window, U32 cycleLog,\n                                           U32 maxDist, void const* src)\n{\n     \n    U32 const cycleSize = 1u << cycleLog;\n    U32 const cycleMask = cycleSize - 1;\n    U32 const curr = (U32)((BYTE const*)src - window->base);\n    U32 const currentCycle = curr & cycleMask;\n     \n    U32 const currentCycleCorrection = currentCycle < ZSTD_WINDOW_START_INDEX\n                                     ? MAX(cycleSize, ZSTD_WINDOW_START_INDEX)\n                                     : 0;\n    U32 const newCurrent = currentCycle\n                         + currentCycleCorrection\n                         + MAX(maxDist, cycleSize);\n    U32 const correction = curr - newCurrent;\n     \n    assert((maxDist & (maxDist - 1)) == 0);\n    assert((curr & cycleMask) == (newCurrent & cycleMask));\n    assert(curr > newCurrent);\n    if (!ZSTD_WINDOW_OVERFLOW_CORRECT_FREQUENTLY) {\n         \n        assert(correction > 1<<28);\n    }\n\n    window->base += correction;\n    window->dictBase += correction;\n    if (window->lowLimit < correction + ZSTD_WINDOW_START_INDEX) {\n        window->lowLimit = ZSTD_WINDOW_START_INDEX;\n    } else {\n        window->lowLimit -= correction;\n    }\n    if (window->dictLimit < correction + ZSTD_WINDOW_START_INDEX) {\n        window->dictLimit = ZSTD_WINDOW_START_INDEX;\n    } else {\n        window->dictLimit -= correction;\n    }\n\n     \n    assert(newCurrent >= maxDist);\n    assert(newCurrent - maxDist >= ZSTD_WINDOW_START_INDEX);\n     \n    assert(window->lowLimit <= newCurrent);\n    assert(window->dictLimit <= newCurrent);\n\n    ++window->nbOverflowCorrections;\n\n    DEBUGLOG(4, \"Correction of 0x%x bytes to lowLimit=0x%x\", correction,\n             window->lowLimit);\n    return correction;\n}\n\n \nMEM_STATIC void\nZSTD_window_enforceMaxDist(ZSTD_window_t* window,\n                     const void* blockEnd,\n                           U32   maxDist,\n                           U32*  loadedDictEndPtr,\n                     const ZSTD_matchState_t** dictMatchStatePtr)\n{\n    U32 const blockEndIdx = (U32)((BYTE const*)blockEnd - window->base);\n    U32 const loadedDictEnd = (loadedDictEndPtr != NULL) ? *loadedDictEndPtr : 0;\n    DEBUGLOG(5, \"ZSTD_window_enforceMaxDist: blockEndIdx=%u, maxDist=%u, loadedDictEnd=%u\",\n                (unsigned)blockEndIdx, (unsigned)maxDist, (unsigned)loadedDictEnd);\n\n     \n    if (blockEndIdx > maxDist + loadedDictEnd) {\n        U32 const newLowLimit = blockEndIdx - maxDist;\n        if (window->lowLimit < newLowLimit) window->lowLimit = newLowLimit;\n        if (window->dictLimit < window->lowLimit) {\n            DEBUGLOG(5, \"Update dictLimit to match lowLimit, from %u to %u\",\n                        (unsigned)window->dictLimit, (unsigned)window->lowLimit);\n            window->dictLimit = window->lowLimit;\n        }\n         \n        if (loadedDictEndPtr) *loadedDictEndPtr = 0;\n        if (dictMatchStatePtr) *dictMatchStatePtr = NULL;\n    }\n}\n\n \nMEM_STATIC void\nZSTD_checkDictValidity(const ZSTD_window_t* window,\n                       const void* blockEnd,\n                             U32   maxDist,\n                             U32*  loadedDictEndPtr,\n                       const ZSTD_matchState_t** dictMatchStatePtr)\n{\n    assert(loadedDictEndPtr != NULL);\n    assert(dictMatchStatePtr != NULL);\n    {   U32 const blockEndIdx = (U32)((BYTE const*)blockEnd - window->base);\n        U32 const loadedDictEnd = *loadedDictEndPtr;\n        DEBUGLOG(5, \"ZSTD_checkDictValidity: blockEndIdx=%u, maxDist=%u, loadedDictEnd=%u\",\n                    (unsigned)blockEndIdx, (unsigned)maxDist, (unsigned)loadedDictEnd);\n        assert(blockEndIdx >= loadedDictEnd);\n\n        if (blockEndIdx > loadedDictEnd + maxDist) {\n             \n            DEBUGLOG(6, \"invalidating dictionary for current block (distance > windowSize)\");\n            *loadedDictEndPtr = 0;\n            *dictMatchStatePtr = NULL;\n        } else {\n            if (*loadedDictEndPtr != 0) {\n                DEBUGLOG(6, \"dictionary considered valid for current block\");\n    }   }   }\n}\n\nMEM_STATIC void ZSTD_window_init(ZSTD_window_t* window) {\n    ZSTD_memset(window, 0, sizeof(*window));\n    window->base = (BYTE const*)\" \";\n    window->dictBase = (BYTE const*)\" \";\n    ZSTD_STATIC_ASSERT(ZSTD_DUBT_UNSORTED_MARK < ZSTD_WINDOW_START_INDEX);  \n    window->dictLimit = ZSTD_WINDOW_START_INDEX;     \n    window->lowLimit = ZSTD_WINDOW_START_INDEX;      \n    window->nextSrc = window->base + ZSTD_WINDOW_START_INDEX;    \n    window->nbOverflowCorrections = 0;\n}\n\n \nMEM_STATIC U32 ZSTD_window_update(ZSTD_window_t* window,\n                                  void const* src, size_t srcSize,\n                                  int forceNonContiguous)\n{\n    BYTE const* const ip = (BYTE const*)src;\n    U32 contiguous = 1;\n    DEBUGLOG(5, \"ZSTD_window_update\");\n    if (srcSize == 0)\n        return contiguous;\n    assert(window->base != NULL);\n    assert(window->dictBase != NULL);\n     \n    if (src != window->nextSrc || forceNonContiguous) {\n         \n        size_t const distanceFromBase = (size_t)(window->nextSrc - window->base);\n        DEBUGLOG(5, \"Non contiguous blocks, new segment starts at %u\", window->dictLimit);\n        window->lowLimit = window->dictLimit;\n        assert(distanceFromBase == (size_t)(U32)distanceFromBase);   \n        window->dictLimit = (U32)distanceFromBase;\n        window->dictBase = window->base;\n        window->base = ip - distanceFromBase;\n         \n        if (window->dictLimit - window->lowLimit < HASH_READ_SIZE) window->lowLimit = window->dictLimit;    \n        contiguous = 0;\n    }\n    window->nextSrc = ip + srcSize;\n     \n    if ( (ip+srcSize > window->dictBase + window->lowLimit)\n       & (ip < window->dictBase + window->dictLimit)) {\n        ptrdiff_t const highInputIdx = (ip + srcSize) - window->dictBase;\n        U32 const lowLimitMax = (highInputIdx > (ptrdiff_t)window->dictLimit) ? window->dictLimit : (U32)highInputIdx;\n        window->lowLimit = lowLimitMax;\n        DEBUGLOG(5, \"Overlapping extDict and input : new lowLimit = %u\", window->lowLimit);\n    }\n    return contiguous;\n}\n\n \nMEM_STATIC U32 ZSTD_getLowestMatchIndex(const ZSTD_matchState_t* ms, U32 curr, unsigned windowLog)\n{\n    U32 const maxDistance = 1U << windowLog;\n    U32 const lowestValid = ms->window.lowLimit;\n    U32 const withinWindow = (curr - lowestValid > maxDistance) ? curr - maxDistance : lowestValid;\n    U32 const isDictionary = (ms->loadedDictEnd != 0);\n     \n    U32 const matchLowest = isDictionary ? lowestValid : withinWindow;\n    return matchLowest;\n}\n\n \nMEM_STATIC U32 ZSTD_getLowestPrefixIndex(const ZSTD_matchState_t* ms, U32 curr, unsigned windowLog)\n{\n    U32    const maxDistance = 1U << windowLog;\n    U32    const lowestValid = ms->window.dictLimit;\n    U32    const withinWindow = (curr - lowestValid > maxDistance) ? curr - maxDistance : lowestValid;\n    U32    const isDictionary = (ms->loadedDictEnd != 0);\n     \n    U32    const matchLowest = isDictionary ? lowestValid : withinWindow;\n    return matchLowest;\n}\n\n\n\n \n#if (DEBUGLEVEL>=2)\n\nMEM_STATIC double ZSTD_fWeight(U32 rawStat)\n{\n    U32 const fp_accuracy = 8;\n    U32 const fp_multiplier = (1 << fp_accuracy);\n    U32 const newStat = rawStat + 1;\n    U32 const hb = ZSTD_highbit32(newStat);\n    U32 const BWeight = hb * fp_multiplier;\n    U32 const FWeight = (newStat << fp_accuracy) >> hb;\n    U32 const weight = BWeight + FWeight;\n    assert(hb + fp_accuracy < 31);\n    return (double)weight / fp_multiplier;\n}\n\n \nMEM_STATIC void ZSTD_debugTable(const U32* table, U32 max)\n{\n    unsigned u, sum;\n    for (u=0, sum=0; u<=max; u++) sum += table[u];\n    DEBUGLOG(2, \"total nb elts: %u\", sum);\n    for (u=0; u<=max; u++) {\n        DEBUGLOG(2, \"%2u: %5u  (%.2f)\",\n                u, table[u], ZSTD_fWeight(sum) - ZSTD_fWeight(table[u]) );\n    }\n}\n\n#endif\n\n\n\n \n\n \nsize_t ZSTD_loadCEntropy(ZSTD_compressedBlockState_t* bs, void* workspace,\n                         const void* const dict, size_t dictSize);\n\nvoid ZSTD_reset_compressedBlockState(ZSTD_compressedBlockState_t* bs);\n\n \n\n \nZSTD_compressionParameters ZSTD_getCParamsFromCCtxParams(\n        const ZSTD_CCtx_params* CCtxParams, U64 srcSizeHint, size_t dictSize, ZSTD_cParamMode_e mode);\n\n \nsize_t ZSTD_initCStream_internal(ZSTD_CStream* zcs,\n                     const void* dict, size_t dictSize,\n                     const ZSTD_CDict* cdict,\n                     const ZSTD_CCtx_params* params, unsigned long long pledgedSrcSize);\n\nvoid ZSTD_resetSeqStore(seqStore_t* ssPtr);\n\n \nZSTD_compressionParameters ZSTD_getCParamsFromCDict(const ZSTD_CDict* cdict);\n\n \nsize_t ZSTD_compressBegin_advanced_internal(ZSTD_CCtx* cctx,\n                                    const void* dict, size_t dictSize,\n                                    ZSTD_dictContentType_e dictContentType,\n                                    ZSTD_dictTableLoadMethod_e dtlm,\n                                    const ZSTD_CDict* cdict,\n                                    const ZSTD_CCtx_params* params,\n                                    unsigned long long pledgedSrcSize);\n\n \nsize_t ZSTD_compress_advanced_internal(ZSTD_CCtx* cctx,\n                                       void* dst, size_t dstCapacity,\n                                 const void* src, size_t srcSize,\n                                 const void* dict,size_t dictSize,\n                                 const ZSTD_CCtx_params* params);\n\n\n \nsize_t ZSTD_writeLastEmptyBlock(void* dst, size_t dstCapacity);\n\n\n \nsize_t ZSTD_referenceExternalSequences(ZSTD_CCtx* cctx, rawSeq* seq, size_t nbSeq);\n\n \nU32 ZSTD_cycleLog(U32 hashLog, ZSTD_strategy strat);\n\n \nvoid ZSTD_CCtx_trace(ZSTD_CCtx* cctx, size_t extraCSize);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}