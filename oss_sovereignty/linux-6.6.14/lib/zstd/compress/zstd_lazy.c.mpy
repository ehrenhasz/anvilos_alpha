{
  "module_name": "zstd_lazy.c",
  "hash_id": "2eaa6ad726d3964b089a50f3a1bbe63a7de5eb266f369e89ddaed8105ca8207e",
  "original_prompt": "Ingested from linux-6.6.14/lib/zstd/compress/zstd_lazy.c",
  "human_readable_source": " \n\n#include \"zstd_compress_internal.h\"\n#include \"zstd_lazy.h\"\n\n\n \n\nstatic void\nZSTD_updateDUBT(ZSTD_matchState_t* ms,\n                const BYTE* ip, const BYTE* iend,\n                U32 mls)\n{\n    const ZSTD_compressionParameters* const cParams = &ms->cParams;\n    U32* const hashTable = ms->hashTable;\n    U32  const hashLog = cParams->hashLog;\n\n    U32* const bt = ms->chainTable;\n    U32  const btLog  = cParams->chainLog - 1;\n    U32  const btMask = (1 << btLog) - 1;\n\n    const BYTE* const base = ms->window.base;\n    U32 const target = (U32)(ip - base);\n    U32 idx = ms->nextToUpdate;\n\n    if (idx != target)\n        DEBUGLOG(7, \"ZSTD_updateDUBT, from %u to %u (dictLimit:%u)\",\n                    idx, target, ms->window.dictLimit);\n    assert(ip + 8 <= iend);    \n    (void)iend;\n\n    assert(idx >= ms->window.dictLimit);    \n    for ( ; idx < target ; idx++) {\n        size_t const h  = ZSTD_hashPtr(base + idx, hashLog, mls);    \n        U32    const matchIndex = hashTable[h];\n\n        U32*   const nextCandidatePtr = bt + 2*(idx&btMask);\n        U32*   const sortMarkPtr  = nextCandidatePtr + 1;\n\n        DEBUGLOG(8, \"ZSTD_updateDUBT: insert %u\", idx);\n        hashTable[h] = idx;    \n        *nextCandidatePtr = matchIndex;    \n        *sortMarkPtr = ZSTD_DUBT_UNSORTED_MARK;\n    }\n    ms->nextToUpdate = target;\n}\n\n\n \nstatic void\nZSTD_insertDUBT1(const ZSTD_matchState_t* ms,\n                 U32 curr, const BYTE* inputEnd,\n                 U32 nbCompares, U32 btLow,\n                 const ZSTD_dictMode_e dictMode)\n{\n    const ZSTD_compressionParameters* const cParams = &ms->cParams;\n    U32* const bt = ms->chainTable;\n    U32  const btLog  = cParams->chainLog - 1;\n    U32  const btMask = (1 << btLog) - 1;\n    size_t commonLengthSmaller=0, commonLengthLarger=0;\n    const BYTE* const base = ms->window.base;\n    const BYTE* const dictBase = ms->window.dictBase;\n    const U32 dictLimit = ms->window.dictLimit;\n    const BYTE* const ip = (curr>=dictLimit) ? base + curr : dictBase + curr;\n    const BYTE* const iend = (curr>=dictLimit) ? inputEnd : dictBase + dictLimit;\n    const BYTE* const dictEnd = dictBase + dictLimit;\n    const BYTE* const prefixStart = base + dictLimit;\n    const BYTE* match;\n    U32* smallerPtr = bt + 2*(curr&btMask);\n    U32* largerPtr  = smallerPtr + 1;\n    U32 matchIndex = *smallerPtr;    \n    U32 dummy32;    \n    U32 const windowValid = ms->window.lowLimit;\n    U32 const maxDistance = 1U << cParams->windowLog;\n    U32 const windowLow = (curr - windowValid > maxDistance) ? curr - maxDistance : windowValid;\n\n\n    DEBUGLOG(8, \"ZSTD_insertDUBT1(%u) (dictLimit=%u, lowLimit=%u)\",\n                curr, dictLimit, windowLow);\n    assert(curr >= btLow);\n    assert(ip < iend);    \n\n    for (; nbCompares && (matchIndex > windowLow); --nbCompares) {\n        U32* const nextPtr = bt + 2*(matchIndex & btMask);\n        size_t matchLength = MIN(commonLengthSmaller, commonLengthLarger);    \n        assert(matchIndex < curr);\n         \n\n        if ( (dictMode != ZSTD_extDict)\n          || (matchIndex+matchLength >= dictLimit)   \n          || (curr < dictLimit)  ) {\n            const BYTE* const mBase = ( (dictMode != ZSTD_extDict)\n                                     || (matchIndex+matchLength >= dictLimit)) ?\n                                        base : dictBase;\n            assert( (matchIndex+matchLength >= dictLimit)    \n                 || (curr < dictLimit) );\n            match = mBase + matchIndex;\n            matchLength += ZSTD_count(ip+matchLength, match+matchLength, iend);\n        } else {\n            match = dictBase + matchIndex;\n            matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iend, dictEnd, prefixStart);\n            if (matchIndex+matchLength >= dictLimit)\n                match = base + matchIndex;    \n        }\n\n        DEBUGLOG(8, \"ZSTD_insertDUBT1: comparing %u with %u : found %u common bytes \",\n                    curr, matchIndex, (U32)matchLength);\n\n        if (ip+matchLength == iend) {    \n            break;    \n        }\n\n        if (match[matchLength] < ip[matchLength]) {   \n             \n            *smallerPtr = matchIndex;              \n            commonLengthSmaller = matchLength;     \n            if (matchIndex <= btLow) { smallerPtr=&dummy32; break; }    \n            DEBUGLOG(8, \"ZSTD_insertDUBT1: %u (>btLow=%u) is smaller : next => %u\",\n                        matchIndex, btLow, nextPtr[1]);\n            smallerPtr = nextPtr+1;                \n            matchIndex = nextPtr[1];               \n        } else {\n             \n            *largerPtr = matchIndex;\n            commonLengthLarger = matchLength;\n            if (matchIndex <= btLow) { largerPtr=&dummy32; break; }    \n            DEBUGLOG(8, \"ZSTD_insertDUBT1: %u (>btLow=%u) is larger => %u\",\n                        matchIndex, btLow, nextPtr[0]);\n            largerPtr = nextPtr;\n            matchIndex = nextPtr[0];\n    }   }\n\n    *smallerPtr = *largerPtr = 0;\n}\n\n\nstatic size_t\nZSTD_DUBT_findBetterDictMatch (\n        const ZSTD_matchState_t* ms,\n        const BYTE* const ip, const BYTE* const iend,\n        size_t* offsetPtr,\n        size_t bestLength,\n        U32 nbCompares,\n        U32 const mls,\n        const ZSTD_dictMode_e dictMode)\n{\n    const ZSTD_matchState_t * const dms = ms->dictMatchState;\n    const ZSTD_compressionParameters* const dmsCParams = &dms->cParams;\n    const U32 * const dictHashTable = dms->hashTable;\n    U32         const hashLog = dmsCParams->hashLog;\n    size_t      const h  = ZSTD_hashPtr(ip, hashLog, mls);\n    U32               dictMatchIndex = dictHashTable[h];\n\n    const BYTE* const base = ms->window.base;\n    const BYTE* const prefixStart = base + ms->window.dictLimit;\n    U32         const curr = (U32)(ip-base);\n    const BYTE* const dictBase = dms->window.base;\n    const BYTE* const dictEnd = dms->window.nextSrc;\n    U32         const dictHighLimit = (U32)(dms->window.nextSrc - dms->window.base);\n    U32         const dictLowLimit = dms->window.lowLimit;\n    U32         const dictIndexDelta = ms->window.lowLimit - dictHighLimit;\n\n    U32*        const dictBt = dms->chainTable;\n    U32         const btLog  = dmsCParams->chainLog - 1;\n    U32         const btMask = (1 << btLog) - 1;\n    U32         const btLow = (btMask >= dictHighLimit - dictLowLimit) ? dictLowLimit : dictHighLimit - btMask;\n\n    size_t commonLengthSmaller=0, commonLengthLarger=0;\n\n    (void)dictMode;\n    assert(dictMode == ZSTD_dictMatchState);\n\n    for (; nbCompares && (dictMatchIndex > dictLowLimit); --nbCompares) {\n        U32* const nextPtr = dictBt + 2*(dictMatchIndex & btMask);\n        size_t matchLength = MIN(commonLengthSmaller, commonLengthLarger);    \n        const BYTE* match = dictBase + dictMatchIndex;\n        matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iend, dictEnd, prefixStart);\n        if (dictMatchIndex+matchLength >= dictHighLimit)\n            match = base + dictMatchIndex + dictIndexDelta;    \n\n        if (matchLength > bestLength) {\n            U32 matchIndex = dictMatchIndex + dictIndexDelta;\n            if ( (4*(int)(matchLength-bestLength)) > (int)(ZSTD_highbit32(curr-matchIndex+1) - ZSTD_highbit32((U32)offsetPtr[0]+1)) ) {\n                DEBUGLOG(9, \"ZSTD_DUBT_findBetterDictMatch(%u) : found better match length %u -> %u and offsetCode %u -> %u (dictMatchIndex %u, matchIndex %u)\",\n                    curr, (U32)bestLength, (U32)matchLength, (U32)*offsetPtr, STORE_OFFSET(curr - matchIndex), dictMatchIndex, matchIndex);\n                bestLength = matchLength, *offsetPtr = STORE_OFFSET(curr - matchIndex);\n            }\n            if (ip+matchLength == iend) {    \n                break;    \n            }\n        }\n\n        if (match[matchLength] < ip[matchLength]) {\n            if (dictMatchIndex <= btLow) { break; }    \n            commonLengthSmaller = matchLength;     \n            dictMatchIndex = nextPtr[1];               \n        } else {\n             \n            if (dictMatchIndex <= btLow) { break; }    \n            commonLengthLarger = matchLength;\n            dictMatchIndex = nextPtr[0];\n        }\n    }\n\n    if (bestLength >= MINMATCH) {\n        U32 const mIndex = curr - (U32)STORED_OFFSET(*offsetPtr); (void)mIndex;\n        DEBUGLOG(8, \"ZSTD_DUBT_findBetterDictMatch(%u) : found match of length %u and offsetCode %u (pos %u)\",\n                    curr, (U32)bestLength, (U32)*offsetPtr, mIndex);\n    }\n    return bestLength;\n\n}\n\n\nstatic size_t\nZSTD_DUBT_findBestMatch(ZSTD_matchState_t* ms,\n                        const BYTE* const ip, const BYTE* const iend,\n                        size_t* offsetPtr,\n                        U32 const mls,\n                        const ZSTD_dictMode_e dictMode)\n{\n    const ZSTD_compressionParameters* const cParams = &ms->cParams;\n    U32*   const hashTable = ms->hashTable;\n    U32    const hashLog = cParams->hashLog;\n    size_t const h  = ZSTD_hashPtr(ip, hashLog, mls);\n    U32          matchIndex  = hashTable[h];\n\n    const BYTE* const base = ms->window.base;\n    U32    const curr = (U32)(ip-base);\n    U32    const windowLow = ZSTD_getLowestMatchIndex(ms, curr, cParams->windowLog);\n\n    U32*   const bt = ms->chainTable;\n    U32    const btLog  = cParams->chainLog - 1;\n    U32    const btMask = (1 << btLog) - 1;\n    U32    const btLow = (btMask >= curr) ? 0 : curr - btMask;\n    U32    const unsortLimit = MAX(btLow, windowLow);\n\n    U32*         nextCandidate = bt + 2*(matchIndex&btMask);\n    U32*         unsortedMark = bt + 2*(matchIndex&btMask) + 1;\n    U32          nbCompares = 1U << cParams->searchLog;\n    U32          nbCandidates = nbCompares;\n    U32          previousCandidate = 0;\n\n    DEBUGLOG(7, \"ZSTD_DUBT_findBestMatch (%u) \", curr);\n    assert(ip <= iend-8);    \n    assert(dictMode != ZSTD_dedicatedDictSearch);\n\n     \n    while ( (matchIndex > unsortLimit)\n         && (*unsortedMark == ZSTD_DUBT_UNSORTED_MARK)\n         && (nbCandidates > 1) ) {\n        DEBUGLOG(8, \"ZSTD_DUBT_findBestMatch: candidate %u is unsorted\",\n                    matchIndex);\n        *unsortedMark = previousCandidate;   \n        previousCandidate = matchIndex;\n        matchIndex = *nextCandidate;\n        nextCandidate = bt + 2*(matchIndex&btMask);\n        unsortedMark = bt + 2*(matchIndex&btMask) + 1;\n        nbCandidates --;\n    }\n\n     \n    if ( (matchIndex > unsortLimit)\n      && (*unsortedMark==ZSTD_DUBT_UNSORTED_MARK) ) {\n        DEBUGLOG(7, \"ZSTD_DUBT_findBestMatch: nullify last unsorted candidate %u\",\n                    matchIndex);\n        *nextCandidate = *unsortedMark = 0;\n    }\n\n     \n    matchIndex = previousCandidate;\n    while (matchIndex) {   \n        U32* const nextCandidateIdxPtr = bt + 2*(matchIndex&btMask) + 1;\n        U32 const nextCandidateIdx = *nextCandidateIdxPtr;\n        ZSTD_insertDUBT1(ms, matchIndex, iend,\n                         nbCandidates, unsortLimit, dictMode);\n        matchIndex = nextCandidateIdx;\n        nbCandidates++;\n    }\n\n     \n    {   size_t commonLengthSmaller = 0, commonLengthLarger = 0;\n        const BYTE* const dictBase = ms->window.dictBase;\n        const U32 dictLimit = ms->window.dictLimit;\n        const BYTE* const dictEnd = dictBase + dictLimit;\n        const BYTE* const prefixStart = base + dictLimit;\n        U32* smallerPtr = bt + 2*(curr&btMask);\n        U32* largerPtr  = bt + 2*(curr&btMask) + 1;\n        U32 matchEndIdx = curr + 8 + 1;\n        U32 dummy32;    \n        size_t bestLength = 0;\n\n        matchIndex  = hashTable[h];\n        hashTable[h] = curr;    \n\n        for (; nbCompares && (matchIndex > windowLow); --nbCompares) {\n            U32* const nextPtr = bt + 2*(matchIndex & btMask);\n            size_t matchLength = MIN(commonLengthSmaller, commonLengthLarger);    \n            const BYTE* match;\n\n            if ((dictMode != ZSTD_extDict) || (matchIndex+matchLength >= dictLimit)) {\n                match = base + matchIndex;\n                matchLength += ZSTD_count(ip+matchLength, match+matchLength, iend);\n            } else {\n                match = dictBase + matchIndex;\n                matchLength += ZSTD_count_2segments(ip+matchLength, match+matchLength, iend, dictEnd, prefixStart);\n                if (matchIndex+matchLength >= dictLimit)\n                    match = base + matchIndex;    \n            }\n\n            if (matchLength > bestLength) {\n                if (matchLength > matchEndIdx - matchIndex)\n                    matchEndIdx = matchIndex + (U32)matchLength;\n                if ( (4*(int)(matchLength-bestLength)) > (int)(ZSTD_highbit32(curr-matchIndex+1) - ZSTD_highbit32((U32)offsetPtr[0]+1)) )\n                    bestLength = matchLength, *offsetPtr = STORE_OFFSET(curr - matchIndex);\n                if (ip+matchLength == iend) {    \n                    if (dictMode == ZSTD_dictMatchState) {\n                        nbCompares = 0;  \n                    }\n                    break;    \n                }\n            }\n\n            if (match[matchLength] < ip[matchLength]) {\n                 \n                *smallerPtr = matchIndex;              \n                commonLengthSmaller = matchLength;     \n                if (matchIndex <= btLow) { smallerPtr=&dummy32; break; }    \n                smallerPtr = nextPtr+1;                \n                matchIndex = nextPtr[1];               \n            } else {\n                 \n                *largerPtr = matchIndex;\n                commonLengthLarger = matchLength;\n                if (matchIndex <= btLow) { largerPtr=&dummy32; break; }    \n                largerPtr = nextPtr;\n                matchIndex = nextPtr[0];\n        }   }\n\n        *smallerPtr = *largerPtr = 0;\n\n        assert(nbCompares <= (1U << ZSTD_SEARCHLOG_MAX));  \n        if (dictMode == ZSTD_dictMatchState && nbCompares) {\n            bestLength = ZSTD_DUBT_findBetterDictMatch(\n                    ms, ip, iend,\n                    offsetPtr, bestLength, nbCompares,\n                    mls, dictMode);\n        }\n\n        assert(matchEndIdx > curr+8);  \n        ms->nextToUpdate = matchEndIdx - 8;    \n        if (bestLength >= MINMATCH) {\n            U32 const mIndex = curr - (U32)STORED_OFFSET(*offsetPtr); (void)mIndex;\n            DEBUGLOG(8, \"ZSTD_DUBT_findBestMatch(%u) : found match of length %u and offsetCode %u (pos %u)\",\n                        curr, (U32)bestLength, (U32)*offsetPtr, mIndex);\n        }\n        return bestLength;\n    }\n}\n\n\n \nFORCE_INLINE_TEMPLATE size_t\nZSTD_BtFindBestMatch( ZSTD_matchState_t* ms,\n                const BYTE* const ip, const BYTE* const iLimit,\n                      size_t* offsetPtr,\n                const U32 mls  ,\n                const ZSTD_dictMode_e dictMode)\n{\n    DEBUGLOG(7, \"ZSTD_BtFindBestMatch\");\n    if (ip < ms->window.base + ms->nextToUpdate) return 0;    \n    ZSTD_updateDUBT(ms, ip, iLimit, mls);\n    return ZSTD_DUBT_findBestMatch(ms, ip, iLimit, offsetPtr, mls, dictMode);\n}\n\n \n\nvoid ZSTD_dedicatedDictSearch_lazy_loadDictionary(ZSTD_matchState_t* ms, const BYTE* const ip)\n{\n    const BYTE* const base = ms->window.base;\n    U32 const target = (U32)(ip - base);\n    U32* const hashTable = ms->hashTable;\n    U32* const chainTable = ms->chainTable;\n    U32 const chainSize = 1 << ms->cParams.chainLog;\n    U32 idx = ms->nextToUpdate;\n    U32 const minChain = chainSize < target - idx ? target - chainSize : idx;\n    U32 const bucketSize = 1 << ZSTD_LAZY_DDSS_BUCKET_LOG;\n    U32 const cacheSize = bucketSize - 1;\n    U32 const chainAttempts = (1 << ms->cParams.searchLog) - cacheSize;\n    U32 const chainLimit = chainAttempts > 255 ? 255 : chainAttempts;\n\n     \n    U32 const hashLog = ms->cParams.hashLog - ZSTD_LAZY_DDSS_BUCKET_LOG;\n    U32* const tmpHashTable = hashTable;\n    U32* const tmpChainTable = hashTable + ((size_t)1 << hashLog);\n    U32 const tmpChainSize = (U32)((1 << ZSTD_LAZY_DDSS_BUCKET_LOG) - 1) << hashLog;\n    U32 const tmpMinChain = tmpChainSize < target ? target - tmpChainSize : idx;\n    U32 hashIdx;\n\n    assert(ms->cParams.chainLog <= 24);\n    assert(ms->cParams.hashLog > ms->cParams.chainLog);\n    assert(idx != 0);\n    assert(tmpMinChain <= minChain);\n\n     \n    for ( ; idx < target; idx++) {\n        U32 const h = (U32)ZSTD_hashPtr(base + idx, hashLog, ms->cParams.minMatch);\n        if (idx >= tmpMinChain) {\n            tmpChainTable[idx - tmpMinChain] = hashTable[h];\n        }\n        tmpHashTable[h] = idx;\n    }\n\n     \n    {\n        U32 chainPos = 0;\n        for (hashIdx = 0; hashIdx < (1U << hashLog); hashIdx++) {\n            U32 count;\n            U32 countBeyondMinChain = 0;\n            U32 i = tmpHashTable[hashIdx];\n            for (count = 0; i >= tmpMinChain && count < cacheSize; count++) {\n                 \n                if (i < minChain) {\n                    countBeyondMinChain++;\n                }\n                i = tmpChainTable[i - tmpMinChain];\n            }\n            if (count == cacheSize) {\n                for (count = 0; count < chainLimit;) {\n                    if (i < minChain) {\n                        if (!i || ++countBeyondMinChain > cacheSize) {\n                             \n                            break;\n                        }\n                    }\n                    chainTable[chainPos++] = i;\n                    count++;\n                    if (i < tmpMinChain) {\n                        break;\n                    }\n                    i = tmpChainTable[i - tmpMinChain];\n                }\n            } else {\n                count = 0;\n            }\n            if (count) {\n                tmpHashTable[hashIdx] = ((chainPos - count) << 8) + count;\n            } else {\n                tmpHashTable[hashIdx] = 0;\n            }\n        }\n        assert(chainPos <= chainSize);  \n    }\n\n     \n    for (hashIdx = (1 << hashLog); hashIdx; ) {\n        U32 const bucketIdx = --hashIdx << ZSTD_LAZY_DDSS_BUCKET_LOG;\n        U32 const chainPackedPointer = tmpHashTable[hashIdx];\n        U32 i;\n        for (i = 0; i < cacheSize; i++) {\n            hashTable[bucketIdx + i] = 0;\n        }\n        hashTable[bucketIdx + bucketSize - 1] = chainPackedPointer;\n    }\n\n     \n    for (idx = ms->nextToUpdate; idx < target; idx++) {\n        U32 const h = (U32)ZSTD_hashPtr(base + idx, hashLog, ms->cParams.minMatch)\n                   << ZSTD_LAZY_DDSS_BUCKET_LOG;\n        U32 i;\n         \n        for (i = cacheSize - 1; i; i--)\n            hashTable[h + i] = hashTable[h + i - 1];\n        hashTable[h] = idx;\n    }\n\n    ms->nextToUpdate = target;\n}\n\n \nFORCE_INLINE_TEMPLATE\nsize_t ZSTD_dedicatedDictSearch_lazy_search(size_t* offsetPtr, size_t ml, U32 nbAttempts,\n                                            const ZSTD_matchState_t* const dms,\n                                            const BYTE* const ip, const BYTE* const iLimit,\n                                            const BYTE* const prefixStart, const U32 curr,\n                                            const U32 dictLimit, const size_t ddsIdx) {\n    const U32 ddsLowestIndex  = dms->window.dictLimit;\n    const BYTE* const ddsBase = dms->window.base;\n    const BYTE* const ddsEnd  = dms->window.nextSrc;\n    const U32 ddsSize         = (U32)(ddsEnd - ddsBase);\n    const U32 ddsIndexDelta   = dictLimit - ddsSize;\n    const U32 bucketSize      = (1 << ZSTD_LAZY_DDSS_BUCKET_LOG);\n    const U32 bucketLimit     = nbAttempts < bucketSize - 1 ? nbAttempts : bucketSize - 1;\n    U32 ddsAttempt;\n    U32 matchIndex;\n\n    for (ddsAttempt = 0; ddsAttempt < bucketSize - 1; ddsAttempt++) {\n        PREFETCH_L1(ddsBase + dms->hashTable[ddsIdx + ddsAttempt]);\n    }\n\n    {\n        U32 const chainPackedPointer = dms->hashTable[ddsIdx + bucketSize - 1];\n        U32 const chainIndex = chainPackedPointer >> 8;\n\n        PREFETCH_L1(&dms->chainTable[chainIndex]);\n    }\n\n    for (ddsAttempt = 0; ddsAttempt < bucketLimit; ddsAttempt++) {\n        size_t currentMl=0;\n        const BYTE* match;\n        matchIndex = dms->hashTable[ddsIdx + ddsAttempt];\n        match = ddsBase + matchIndex;\n\n        if (!matchIndex) {\n            return ml;\n        }\n\n         \n        (void)ddsLowestIndex;\n        assert(matchIndex >= ddsLowestIndex);\n        assert(match+4 <= ddsEnd);\n        if (MEM_read32(match) == MEM_read32(ip)) {\n             \n            currentMl = ZSTD_count_2segments(ip+4, match+4, iLimit, ddsEnd, prefixStart) + 4;\n        }\n\n         \n        if (currentMl > ml) {\n            ml = currentMl;\n            *offsetPtr = STORE_OFFSET(curr - (matchIndex + ddsIndexDelta));\n            if (ip+currentMl == iLimit) {\n                 \n                return ml;\n            }\n        }\n    }\n\n    {\n        U32 const chainPackedPointer = dms->hashTable[ddsIdx + bucketSize - 1];\n        U32 chainIndex = chainPackedPointer >> 8;\n        U32 const chainLength = chainPackedPointer & 0xFF;\n        U32 const chainAttempts = nbAttempts - ddsAttempt;\n        U32 const chainLimit = chainAttempts > chainLength ? chainLength : chainAttempts;\n        U32 chainAttempt;\n\n        for (chainAttempt = 0 ; chainAttempt < chainLimit; chainAttempt++) {\n            PREFETCH_L1(ddsBase + dms->chainTable[chainIndex + chainAttempt]);\n        }\n\n        for (chainAttempt = 0 ; chainAttempt < chainLimit; chainAttempt++, chainIndex++) {\n            size_t currentMl=0;\n            const BYTE* match;\n            matchIndex = dms->chainTable[chainIndex];\n            match = ddsBase + matchIndex;\n\n             \n            assert(matchIndex >= ddsLowestIndex);\n            assert(match+4 <= ddsEnd);\n            if (MEM_read32(match) == MEM_read32(ip)) {\n                 \n                currentMl = ZSTD_count_2segments(ip+4, match+4, iLimit, ddsEnd, prefixStart) + 4;\n            }\n\n             \n            if (currentMl > ml) {\n                ml = currentMl;\n                *offsetPtr = STORE_OFFSET(curr - (matchIndex + ddsIndexDelta));\n                if (ip+currentMl == iLimit) break;  \n            }\n        }\n    }\n    return ml;\n}\n\n\n \n#define NEXT_IN_CHAIN(d, mask)   chainTable[(d) & (mask)]\n\n \nFORCE_INLINE_TEMPLATE U32 ZSTD_insertAndFindFirstIndex_internal(\n                        ZSTD_matchState_t* ms,\n                        const ZSTD_compressionParameters* const cParams,\n                        const BYTE* ip, U32 const mls)\n{\n    U32* const hashTable  = ms->hashTable;\n    const U32 hashLog = cParams->hashLog;\n    U32* const chainTable = ms->chainTable;\n    const U32 chainMask = (1 << cParams->chainLog) - 1;\n    const BYTE* const base = ms->window.base;\n    const U32 target = (U32)(ip - base);\n    U32 idx = ms->nextToUpdate;\n\n    while(idx < target) {  \n        size_t const h = ZSTD_hashPtr(base+idx, hashLog, mls);\n        NEXT_IN_CHAIN(idx, chainMask) = hashTable[h];\n        hashTable[h] = idx;\n        idx++;\n    }\n\n    ms->nextToUpdate = target;\n    return hashTable[ZSTD_hashPtr(ip, hashLog, mls)];\n}\n\nU32 ZSTD_insertAndFindFirstIndex(ZSTD_matchState_t* ms, const BYTE* ip) {\n    const ZSTD_compressionParameters* const cParams = &ms->cParams;\n    return ZSTD_insertAndFindFirstIndex_internal(ms, cParams, ip, ms->cParams.minMatch);\n}\n\n \nFORCE_INLINE_TEMPLATE\nsize_t ZSTD_HcFindBestMatch(\n                        ZSTD_matchState_t* ms,\n                        const BYTE* const ip, const BYTE* const iLimit,\n                        size_t* offsetPtr,\n                        const U32 mls, const ZSTD_dictMode_e dictMode)\n{\n    const ZSTD_compressionParameters* const cParams = &ms->cParams;\n    U32* const chainTable = ms->chainTable;\n    const U32 chainSize = (1 << cParams->chainLog);\n    const U32 chainMask = chainSize-1;\n    const BYTE* const base = ms->window.base;\n    const BYTE* const dictBase = ms->window.dictBase;\n    const U32 dictLimit = ms->window.dictLimit;\n    const BYTE* const prefixStart = base + dictLimit;\n    const BYTE* const dictEnd = dictBase + dictLimit;\n    const U32 curr = (U32)(ip-base);\n    const U32 maxDistance = 1U << cParams->windowLog;\n    const U32 lowestValid = ms->window.lowLimit;\n    const U32 withinMaxDistance = (curr - lowestValid > maxDistance) ? curr - maxDistance : lowestValid;\n    const U32 isDictionary = (ms->loadedDictEnd != 0);\n    const U32 lowLimit = isDictionary ? lowestValid : withinMaxDistance;\n    const U32 minChain = curr > chainSize ? curr - chainSize : 0;\n    U32 nbAttempts = 1U << cParams->searchLog;\n    size_t ml=4-1;\n\n    const ZSTD_matchState_t* const dms = ms->dictMatchState;\n    const U32 ddsHashLog = dictMode == ZSTD_dedicatedDictSearch\n                         ? dms->cParams.hashLog - ZSTD_LAZY_DDSS_BUCKET_LOG : 0;\n    const size_t ddsIdx = dictMode == ZSTD_dedicatedDictSearch\n                        ? ZSTD_hashPtr(ip, ddsHashLog, mls) << ZSTD_LAZY_DDSS_BUCKET_LOG : 0;\n\n    U32 matchIndex;\n\n    if (dictMode == ZSTD_dedicatedDictSearch) {\n        const U32* entry = &dms->hashTable[ddsIdx];\n        PREFETCH_L1(entry);\n    }\n\n     \n    matchIndex = ZSTD_insertAndFindFirstIndex_internal(ms, cParams, ip, mls);\n\n    for ( ; (matchIndex>=lowLimit) & (nbAttempts>0) ; nbAttempts--) {\n        size_t currentMl=0;\n        if ((dictMode != ZSTD_extDict) || matchIndex >= dictLimit) {\n            const BYTE* const match = base + matchIndex;\n            assert(matchIndex >= dictLimit);    \n            if (match[ml] == ip[ml])    \n                currentMl = ZSTD_count(ip, match, iLimit);\n        } else {\n            const BYTE* const match = dictBase + matchIndex;\n            assert(match+4 <= dictEnd);\n            if (MEM_read32(match) == MEM_read32(ip))    \n                currentMl = ZSTD_count_2segments(ip+4, match+4, iLimit, dictEnd, prefixStart) + 4;\n        }\n\n         \n        if (currentMl > ml) {\n            ml = currentMl;\n            *offsetPtr = STORE_OFFSET(curr - matchIndex);\n            if (ip+currentMl == iLimit) break;  \n        }\n\n        if (matchIndex <= minChain) break;\n        matchIndex = NEXT_IN_CHAIN(matchIndex, chainMask);\n    }\n\n    assert(nbAttempts <= (1U << ZSTD_SEARCHLOG_MAX));  \n    if (dictMode == ZSTD_dedicatedDictSearch) {\n        ml = ZSTD_dedicatedDictSearch_lazy_search(offsetPtr, ml, nbAttempts, dms,\n                                                  ip, iLimit, prefixStart, curr, dictLimit, ddsIdx);\n    } else if (dictMode == ZSTD_dictMatchState) {\n        const U32* const dmsChainTable = dms->chainTable;\n        const U32 dmsChainSize         = (1 << dms->cParams.chainLog);\n        const U32 dmsChainMask         = dmsChainSize - 1;\n        const U32 dmsLowestIndex       = dms->window.dictLimit;\n        const BYTE* const dmsBase      = dms->window.base;\n        const BYTE* const dmsEnd       = dms->window.nextSrc;\n        const U32 dmsSize              = (U32)(dmsEnd - dmsBase);\n        const U32 dmsIndexDelta        = dictLimit - dmsSize;\n        const U32 dmsMinChain = dmsSize > dmsChainSize ? dmsSize - dmsChainSize : 0;\n\n        matchIndex = dms->hashTable[ZSTD_hashPtr(ip, dms->cParams.hashLog, mls)];\n\n        for ( ; (matchIndex>=dmsLowestIndex) & (nbAttempts>0) ; nbAttempts--) {\n            size_t currentMl=0;\n            const BYTE* const match = dmsBase + matchIndex;\n            assert(match+4 <= dmsEnd);\n            if (MEM_read32(match) == MEM_read32(ip))    \n                currentMl = ZSTD_count_2segments(ip+4, match+4, iLimit, dmsEnd, prefixStart) + 4;\n\n             \n            if (currentMl > ml) {\n                ml = currentMl;\n                assert(curr > matchIndex + dmsIndexDelta);\n                *offsetPtr = STORE_OFFSET(curr - (matchIndex + dmsIndexDelta));\n                if (ip+currentMl == iLimit) break;  \n            }\n\n            if (matchIndex <= dmsMinChain) break;\n\n            matchIndex = dmsChainTable[matchIndex & dmsChainMask];\n        }\n    }\n\n    return ml;\n}\n\n \n \n#define ZSTD_ROW_HASH_TAG_OFFSET 16      \n#define ZSTD_ROW_HASH_TAG_BITS 8         \n#define ZSTD_ROW_HASH_TAG_MASK ((1u << ZSTD_ROW_HASH_TAG_BITS) - 1)\n#define ZSTD_ROW_HASH_MAX_ENTRIES 64     \n\n#define ZSTD_ROW_HASH_CACHE_MASK (ZSTD_ROW_HASH_CACHE_SIZE - 1)\n\ntypedef U64 ZSTD_VecMask;    \n\n \nstatic U32 ZSTD_VecMask_next(ZSTD_VecMask val) {\n    assert(val != 0);\n#   if (defined(__GNUC__) && ((__GNUC__ > 3) || ((__GNUC__ == 3) && (__GNUC_MINOR__ >= 4))))\n    if (sizeof(size_t) == 4) {\n        U32 mostSignificantWord = (U32)(val >> 32);\n        U32 leastSignificantWord = (U32)val;\n        if (leastSignificantWord == 0) {\n            return 32 + (U32)__builtin_ctz(mostSignificantWord);\n        } else {\n            return (U32)__builtin_ctz(leastSignificantWord);\n        }\n    } else {\n        return (U32)__builtin_ctzll(val);\n    }\n#   else\n     \n    val = ~val & (val - 1ULL);  \n    val = val - ((val >> 1) & 0x5555555555555555);\n    val = (val & 0x3333333333333333ULL) + ((val >> 2) & 0x3333333333333333ULL);\n    return (U32)((((val + (val >> 4)) & 0xF0F0F0F0F0F0F0FULL) * 0x101010101010101ULL) >> 56);\n#   endif\n}\n\n \nFORCE_INLINE_TEMPLATE\nU64 ZSTD_rotateRight_U64(U64 const value, U32 count) {\n    assert(count < 64);\n    count &= 0x3F;  \n    return (value >> count) | (U64)(value << ((0U - count) & 0x3F));\n}\n\nFORCE_INLINE_TEMPLATE\nU32 ZSTD_rotateRight_U32(U32 const value, U32 count) {\n    assert(count < 32);\n    count &= 0x1F;  \n    return (value >> count) | (U32)(value << ((0U - count) & 0x1F));\n}\n\nFORCE_INLINE_TEMPLATE\nU16 ZSTD_rotateRight_U16(U16 const value, U32 count) {\n    assert(count < 16);\n    count &= 0x0F;  \n    return (value >> count) | (U16)(value << ((0U - count) & 0x0F));\n}\n\n \nFORCE_INLINE_TEMPLATE U32 ZSTD_row_nextIndex(BYTE* const tagRow, U32 const rowMask) {\n  U32 const next = (*tagRow - 1) & rowMask;\n  *tagRow = (BYTE)next;\n  return next;\n}\n\n \nMEM_STATIC int ZSTD_isAligned(void const* ptr, size_t align) {\n    assert((align & (align - 1)) == 0);\n    return (((size_t)ptr) & (align - 1)) == 0;\n}\n\n \nFORCE_INLINE_TEMPLATE void ZSTD_row_prefetch(U32 const* hashTable, U16 const* tagTable, U32 const relRow, U32 const rowLog) {\n    PREFETCH_L1(hashTable + relRow);\n    if (rowLog >= 5) {\n        PREFETCH_L1(hashTable + relRow + 16);\n         \n    }\n    PREFETCH_L1(tagTable + relRow);\n    if (rowLog == 6) {\n        PREFETCH_L1(tagTable + relRow + 32);\n    }\n    assert(rowLog == 4 || rowLog == 5 || rowLog == 6);\n    assert(ZSTD_isAligned(hashTable + relRow, 64));                  \n    assert(ZSTD_isAligned(tagTable + relRow, (size_t)1 << rowLog));  \n}\n\n \nFORCE_INLINE_TEMPLATE void ZSTD_row_fillHashCache(ZSTD_matchState_t* ms, const BYTE* base,\n                                   U32 const rowLog, U32 const mls,\n                                   U32 idx, const BYTE* const iLimit)\n{\n    U32 const* const hashTable = ms->hashTable;\n    U16 const* const tagTable = ms->tagTable;\n    U32 const hashLog = ms->rowHashLog;\n    U32 const maxElemsToPrefetch = (base + idx) > iLimit ? 0 : (U32)(iLimit - (base + idx) + 1);\n    U32 const lim = idx + MIN(ZSTD_ROW_HASH_CACHE_SIZE, maxElemsToPrefetch);\n\n    for (; idx < lim; ++idx) {\n        U32 const hash = (U32)ZSTD_hashPtr(base + idx, hashLog + ZSTD_ROW_HASH_TAG_BITS, mls);\n        U32 const row = (hash >> ZSTD_ROW_HASH_TAG_BITS) << rowLog;\n        ZSTD_row_prefetch(hashTable, tagTable, row, rowLog);\n        ms->hashCache[idx & ZSTD_ROW_HASH_CACHE_MASK] = hash;\n    }\n\n    DEBUGLOG(6, \"ZSTD_row_fillHashCache(): [%u %u %u %u %u %u %u %u]\", ms->hashCache[0], ms->hashCache[1],\n                                                     ms->hashCache[2], ms->hashCache[3], ms->hashCache[4],\n                                                     ms->hashCache[5], ms->hashCache[6], ms->hashCache[7]);\n}\n\n \nFORCE_INLINE_TEMPLATE U32 ZSTD_row_nextCachedHash(U32* cache, U32 const* hashTable,\n                                                  U16 const* tagTable, BYTE const* base,\n                                                  U32 idx, U32 const hashLog,\n                                                  U32 const rowLog, U32 const mls)\n{\n    U32 const newHash = (U32)ZSTD_hashPtr(base+idx+ZSTD_ROW_HASH_CACHE_SIZE, hashLog + ZSTD_ROW_HASH_TAG_BITS, mls);\n    U32 const row = (newHash >> ZSTD_ROW_HASH_TAG_BITS) << rowLog;\n    ZSTD_row_prefetch(hashTable, tagTable, row, rowLog);\n    {   U32 const hash = cache[idx & ZSTD_ROW_HASH_CACHE_MASK];\n        cache[idx & ZSTD_ROW_HASH_CACHE_MASK] = newHash;\n        return hash;\n    }\n}\n\n \nFORCE_INLINE_TEMPLATE void ZSTD_row_update_internalImpl(ZSTD_matchState_t* ms,\n                                                        U32 updateStartIdx, U32 const updateEndIdx,\n                                                        U32 const mls, U32 const rowLog,\n                                                        U32 const rowMask, U32 const useCache)\n{\n    U32* const hashTable = ms->hashTable;\n    U16* const tagTable = ms->tagTable;\n    U32 const hashLog = ms->rowHashLog;\n    const BYTE* const base = ms->window.base;\n\n    DEBUGLOG(6, \"ZSTD_row_update_internalImpl(): updateStartIdx=%u, updateEndIdx=%u\", updateStartIdx, updateEndIdx);\n    for (; updateStartIdx < updateEndIdx; ++updateStartIdx) {\n        U32 const hash = useCache ? ZSTD_row_nextCachedHash(ms->hashCache, hashTable, tagTable, base, updateStartIdx, hashLog, rowLog, mls)\n                                  : (U32)ZSTD_hashPtr(base + updateStartIdx, hashLog + ZSTD_ROW_HASH_TAG_BITS, mls);\n        U32 const relRow = (hash >> ZSTD_ROW_HASH_TAG_BITS) << rowLog;\n        U32* const row = hashTable + relRow;\n        BYTE* tagRow = (BYTE*)(tagTable + relRow);   \n        U32 const pos = ZSTD_row_nextIndex(tagRow, rowMask);\n\n        assert(hash == ZSTD_hashPtr(base + updateStartIdx, hashLog + ZSTD_ROW_HASH_TAG_BITS, mls));\n        ((BYTE*)tagRow)[pos + ZSTD_ROW_HASH_TAG_OFFSET] = hash & ZSTD_ROW_HASH_TAG_MASK;\n        row[pos] = updateStartIdx;\n    }\n}\n\n \nFORCE_INLINE_TEMPLATE void ZSTD_row_update_internal(ZSTD_matchState_t* ms, const BYTE* ip,\n                                                    U32 const mls, U32 const rowLog,\n                                                    U32 const rowMask, U32 const useCache)\n{\n    U32 idx = ms->nextToUpdate;\n    const BYTE* const base = ms->window.base;\n    const U32 target = (U32)(ip - base);\n    const U32 kSkipThreshold = 384;\n    const U32 kMaxMatchStartPositionsToUpdate = 96;\n    const U32 kMaxMatchEndPositionsToUpdate = 32;\n\n    if (useCache) {\n         \n        if (UNLIKELY(target - idx > kSkipThreshold)) {\n            U32 const bound = idx + kMaxMatchStartPositionsToUpdate;\n            ZSTD_row_update_internalImpl(ms, idx, bound, mls, rowLog, rowMask, useCache);\n            idx = target - kMaxMatchEndPositionsToUpdate;\n            ZSTD_row_fillHashCache(ms, base, rowLog, mls, idx, ip+1);\n        }\n    }\n    assert(target >= idx);\n    ZSTD_row_update_internalImpl(ms, idx, target, mls, rowLog, rowMask, useCache);\n    ms->nextToUpdate = target;\n}\n\n \nvoid ZSTD_row_update(ZSTD_matchState_t* const ms, const BYTE* ip) {\n    const U32 rowLog = BOUNDED(4, ms->cParams.searchLog, 6);\n    const U32 rowMask = (1u << rowLog) - 1;\n    const U32 mls = MIN(ms->cParams.minMatch, 6  );\n\n    DEBUGLOG(5, \"ZSTD_row_update(), rowLog=%u\", rowLog);\n    ZSTD_row_update_internal(ms, ip, mls, rowLog, rowMask, 0  );\n}\n\n#if defined(ZSTD_ARCH_X86_SSE2)\nFORCE_INLINE_TEMPLATE ZSTD_VecMask\nZSTD_row_getSSEMask(int nbChunks, const BYTE* const src, const BYTE tag, const U32 head)\n{\n    const __m128i comparisonMask = _mm_set1_epi8((char)tag);\n    int matches[4] = {0};\n    int i;\n    assert(nbChunks == 1 || nbChunks == 2 || nbChunks == 4);\n    for (i=0; i<nbChunks; i++) {\n        const __m128i chunk = _mm_loadu_si128((const __m128i*)(const void*)(src + 16*i));\n        const __m128i equalMask = _mm_cmpeq_epi8(chunk, comparisonMask);\n        matches[i] = _mm_movemask_epi8(equalMask);\n    }\n    if (nbChunks == 1) return ZSTD_rotateRight_U16((U16)matches[0], head);\n    if (nbChunks == 2) return ZSTD_rotateRight_U32((U32)matches[1] << 16 | (U32)matches[0], head);\n    assert(nbChunks == 4);\n    return ZSTD_rotateRight_U64((U64)matches[3] << 48 | (U64)matches[2] << 32 | (U64)matches[1] << 16 | (U64)matches[0], head);\n}\n#endif\n\n \nFORCE_INLINE_TEMPLATE ZSTD_VecMask\nZSTD_row_getMatchMask(const BYTE* const tagRow, const BYTE tag, const U32 head, const U32 rowEntries)\n{\n    const BYTE* const src = tagRow + ZSTD_ROW_HASH_TAG_OFFSET;\n    assert((rowEntries == 16) || (rowEntries == 32) || rowEntries == 64);\n    assert(rowEntries <= ZSTD_ROW_HASH_MAX_ENTRIES);\n\n#if defined(ZSTD_ARCH_X86_SSE2)\n\n    return ZSTD_row_getSSEMask(rowEntries / 16, src, tag, head);\n\n#else  \n\n# if defined(ZSTD_ARCH_ARM_NEON)\n   \n    if (MEM_isLittleEndian()) {\n        if (rowEntries == 16) {\n            const uint8x16_t chunk = vld1q_u8(src);\n            const uint16x8_t equalMask = vreinterpretq_u16_u8(vceqq_u8(chunk, vdupq_n_u8(tag)));\n            const uint16x8_t t0 = vshlq_n_u16(equalMask, 7);\n            const uint32x4_t t1 = vreinterpretq_u32_u16(vsriq_n_u16(t0, t0, 14));\n            const uint64x2_t t2 = vreinterpretq_u64_u32(vshrq_n_u32(t1, 14));\n            const uint8x16_t t3 = vreinterpretq_u8_u64(vsraq_n_u64(t2, t2, 28));\n            const U16 hi = (U16)vgetq_lane_u8(t3, 8);\n            const U16 lo = (U16)vgetq_lane_u8(t3, 0);\n            return ZSTD_rotateRight_U16((hi << 8) | lo, head);\n        } else if (rowEntries == 32) {\n            const uint16x8x2_t chunk = vld2q_u16((const U16*)(const void*)src);\n            const uint8x16_t chunk0 = vreinterpretq_u8_u16(chunk.val[0]);\n            const uint8x16_t chunk1 = vreinterpretq_u8_u16(chunk.val[1]);\n            const uint8x16_t equalMask0 = vceqq_u8(chunk0, vdupq_n_u8(tag));\n            const uint8x16_t equalMask1 = vceqq_u8(chunk1, vdupq_n_u8(tag));\n            const int8x8_t pack0 = vqmovn_s16(vreinterpretq_s16_u8(equalMask0));\n            const int8x8_t pack1 = vqmovn_s16(vreinterpretq_s16_u8(equalMask1));\n            const uint8x8_t t0 = vreinterpret_u8_s8(pack0);\n            const uint8x8_t t1 = vreinterpret_u8_s8(pack1);\n            const uint8x8_t t2 = vsri_n_u8(t1, t0, 2);\n            const uint8x8x2_t t3 = vuzp_u8(t2, t0);\n            const uint8x8_t t4 = vsri_n_u8(t3.val[1], t3.val[0], 4);\n            const U32 matches = vget_lane_u32(vreinterpret_u32_u8(t4), 0);\n            return ZSTD_rotateRight_U32(matches, head);\n        } else {  \n            const uint8x16x4_t chunk = vld4q_u8(src);\n            const uint8x16_t dup = vdupq_n_u8(tag);\n            const uint8x16_t cmp0 = vceqq_u8(chunk.val[0], dup);\n            const uint8x16_t cmp1 = vceqq_u8(chunk.val[1], dup);\n            const uint8x16_t cmp2 = vceqq_u8(chunk.val[2], dup);\n            const uint8x16_t cmp3 = vceqq_u8(chunk.val[3], dup);\n\n            const uint8x16_t t0 = vsriq_n_u8(cmp1, cmp0, 1);\n            const uint8x16_t t1 = vsriq_n_u8(cmp3, cmp2, 1);\n            const uint8x16_t t2 = vsriq_n_u8(t1, t0, 2);\n            const uint8x16_t t3 = vsriq_n_u8(t2, t2, 4);\n            const uint8x8_t t4 = vshrn_n_u16(vreinterpretq_u16_u8(t3), 4);\n            const U64 matches = vget_lane_u64(vreinterpret_u64_u8(t4), 0);\n            return ZSTD_rotateRight_U64(matches, head);\n        }\n    }\n# endif  \n     \n    {   const size_t chunkSize = sizeof(size_t);\n        const size_t shiftAmount = ((chunkSize * 8) - chunkSize);\n        const size_t xFF = ~((size_t)0);\n        const size_t x01 = xFF / 0xFF;\n        const size_t x80 = x01 << 7;\n        const size_t splatChar = tag * x01;\n        ZSTD_VecMask matches = 0;\n        int i = rowEntries - chunkSize;\n        assert((sizeof(size_t) == 4) || (sizeof(size_t) == 8));\n        if (MEM_isLittleEndian()) {  \n            const size_t extractMagic = (xFF / 0x7F) >> chunkSize;\n            do {\n                size_t chunk = MEM_readST(&src[i]);\n                chunk ^= splatChar;\n                chunk = (((chunk | x80) - x01) | chunk) & x80;\n                matches <<= chunkSize;\n                matches |= (chunk * extractMagic) >> shiftAmount;\n                i -= chunkSize;\n            } while (i >= 0);\n        } else {  \n            const size_t msb = xFF ^ (xFF >> 1);\n            const size_t extractMagic = (msb / 0x1FF) | msb;\n            do {\n                size_t chunk = MEM_readST(&src[i]);\n                chunk ^= splatChar;\n                chunk = (((chunk | x80) - x01) | chunk) & x80;\n                matches <<= chunkSize;\n                matches |= ((chunk >> 7) * extractMagic) >> shiftAmount;\n                i -= chunkSize;\n            } while (i >= 0);\n        }\n        matches = ~matches;\n        if (rowEntries == 16) {\n            return ZSTD_rotateRight_U16((U16)matches, head);\n        } else if (rowEntries == 32) {\n            return ZSTD_rotateRight_U32((U32)matches, head);\n        } else {\n            return ZSTD_rotateRight_U64((U64)matches, head);\n        }\n    }\n#endif\n}\n\n \nFORCE_INLINE_TEMPLATE\nsize_t ZSTD_RowFindBestMatch(\n                        ZSTD_matchState_t* ms,\n                        const BYTE* const ip, const BYTE* const iLimit,\n                        size_t* offsetPtr,\n                        const U32 mls, const ZSTD_dictMode_e dictMode,\n                        const U32 rowLog)\n{\n    U32* const hashTable = ms->hashTable;\n    U16* const tagTable = ms->tagTable;\n    U32* const hashCache = ms->hashCache;\n    const U32 hashLog = ms->rowHashLog;\n    const ZSTD_compressionParameters* const cParams = &ms->cParams;\n    const BYTE* const base = ms->window.base;\n    const BYTE* const dictBase = ms->window.dictBase;\n    const U32 dictLimit = ms->window.dictLimit;\n    const BYTE* const prefixStart = base + dictLimit;\n    const BYTE* const dictEnd = dictBase + dictLimit;\n    const U32 curr = (U32)(ip-base);\n    const U32 maxDistance = 1U << cParams->windowLog;\n    const U32 lowestValid = ms->window.lowLimit;\n    const U32 withinMaxDistance = (curr - lowestValid > maxDistance) ? curr - maxDistance : lowestValid;\n    const U32 isDictionary = (ms->loadedDictEnd != 0);\n    const U32 lowLimit = isDictionary ? lowestValid : withinMaxDistance;\n    const U32 rowEntries = (1U << rowLog);\n    const U32 rowMask = rowEntries - 1;\n    const U32 cappedSearchLog = MIN(cParams->searchLog, rowLog);  \n    U32 nbAttempts = 1U << cappedSearchLog;\n    size_t ml=4-1;\n\n     \n    const ZSTD_matchState_t* const dms = ms->dictMatchState;\n\n     \n    size_t ddsIdx = 0;\n    U32 ddsExtraAttempts = 0;  \n    U32 dmsTag = 0;\n    U32* dmsRow = NULL;\n    BYTE* dmsTagRow = NULL;\n\n    if (dictMode == ZSTD_dedicatedDictSearch) {\n        const U32 ddsHashLog = dms->cParams.hashLog - ZSTD_LAZY_DDSS_BUCKET_LOG;\n        {    \n            ddsIdx = ZSTD_hashPtr(ip, ddsHashLog, mls) << ZSTD_LAZY_DDSS_BUCKET_LOG;\n            PREFETCH_L1(&dms->hashTable[ddsIdx]);\n        }\n        ddsExtraAttempts = cParams->searchLog > rowLog ? 1U << (cParams->searchLog - rowLog) : 0;\n    }\n\n    if (dictMode == ZSTD_dictMatchState) {\n         \n        U32* const dmsHashTable = dms->hashTable;\n        U16* const dmsTagTable = dms->tagTable;\n        U32 const dmsHash = (U32)ZSTD_hashPtr(ip, dms->rowHashLog + ZSTD_ROW_HASH_TAG_BITS, mls);\n        U32 const dmsRelRow = (dmsHash >> ZSTD_ROW_HASH_TAG_BITS) << rowLog;\n        dmsTag = dmsHash & ZSTD_ROW_HASH_TAG_MASK;\n        dmsTagRow = (BYTE*)(dmsTagTable + dmsRelRow);\n        dmsRow = dmsHashTable + dmsRelRow;\n        ZSTD_row_prefetch(dmsHashTable, dmsTagTable, dmsRelRow, rowLog);\n    }\n\n     \n    ZSTD_row_update_internal(ms, ip, mls, rowLog, rowMask, 1  );\n    {    \n        U32 const hash = ZSTD_row_nextCachedHash(hashCache, hashTable, tagTable, base, curr, hashLog, rowLog, mls);\n        U32 const relRow = (hash >> ZSTD_ROW_HASH_TAG_BITS) << rowLog;\n        U32 const tag = hash & ZSTD_ROW_HASH_TAG_MASK;\n        U32* const row = hashTable + relRow;\n        BYTE* tagRow = (BYTE*)(tagTable + relRow);\n        U32 const head = *tagRow & rowMask;\n        U32 matchBuffer[ZSTD_ROW_HASH_MAX_ENTRIES];\n        size_t numMatches = 0;\n        size_t currMatch = 0;\n        ZSTD_VecMask matches = ZSTD_row_getMatchMask(tagRow, (BYTE)tag, head, rowEntries);\n\n         \n        for (; (matches > 0) && (nbAttempts > 0); --nbAttempts, matches &= (matches - 1)) {\n            U32 const matchPos = (head + ZSTD_VecMask_next(matches)) & rowMask;\n            U32 const matchIndex = row[matchPos];\n            assert(numMatches < rowEntries);\n            if (matchIndex < lowLimit)\n                break;\n            if ((dictMode != ZSTD_extDict) || matchIndex >= dictLimit) {\n                PREFETCH_L1(base + matchIndex);\n            } else {\n                PREFETCH_L1(dictBase + matchIndex);\n            }\n            matchBuffer[numMatches++] = matchIndex;\n        }\n\n         \n        {\n            U32 const pos = ZSTD_row_nextIndex(tagRow, rowMask);\n            tagRow[pos + ZSTD_ROW_HASH_TAG_OFFSET] = (BYTE)tag;\n            row[pos] = ms->nextToUpdate++;\n        }\n\n         \n        for (; currMatch < numMatches; ++currMatch) {\n            U32 const matchIndex = matchBuffer[currMatch];\n            size_t currentMl=0;\n            assert(matchIndex < curr);\n            assert(matchIndex >= lowLimit);\n\n            if ((dictMode != ZSTD_extDict) || matchIndex >= dictLimit) {\n                const BYTE* const match = base + matchIndex;\n                assert(matchIndex >= dictLimit);    \n                if (match[ml] == ip[ml])    \n                    currentMl = ZSTD_count(ip, match, iLimit);\n            } else {\n                const BYTE* const match = dictBase + matchIndex;\n                assert(match+4 <= dictEnd);\n                if (MEM_read32(match) == MEM_read32(ip))    \n                    currentMl = ZSTD_count_2segments(ip+4, match+4, iLimit, dictEnd, prefixStart) + 4;\n            }\n\n             \n            if (currentMl > ml) {\n                ml = currentMl;\n                *offsetPtr = STORE_OFFSET(curr - matchIndex);\n                if (ip+currentMl == iLimit) break;  \n            }\n        }\n    }\n\n    assert(nbAttempts <= (1U << ZSTD_SEARCHLOG_MAX));  \n    if (dictMode == ZSTD_dedicatedDictSearch) {\n        ml = ZSTD_dedicatedDictSearch_lazy_search(offsetPtr, ml, nbAttempts + ddsExtraAttempts, dms,\n                                                  ip, iLimit, prefixStart, curr, dictLimit, ddsIdx);\n    } else if (dictMode == ZSTD_dictMatchState) {\n         \n        const U32 dmsLowestIndex       = dms->window.dictLimit;\n        const BYTE* const dmsBase      = dms->window.base;\n        const BYTE* const dmsEnd       = dms->window.nextSrc;\n        const U32 dmsSize              = (U32)(dmsEnd - dmsBase);\n        const U32 dmsIndexDelta        = dictLimit - dmsSize;\n\n        {   U32 const head = *dmsTagRow & rowMask;\n            U32 matchBuffer[ZSTD_ROW_HASH_MAX_ENTRIES];\n            size_t numMatches = 0;\n            size_t currMatch = 0;\n            ZSTD_VecMask matches = ZSTD_row_getMatchMask(dmsTagRow, (BYTE)dmsTag, head, rowEntries);\n\n            for (; (matches > 0) && (nbAttempts > 0); --nbAttempts, matches &= (matches - 1)) {\n                U32 const matchPos = (head + ZSTD_VecMask_next(matches)) & rowMask;\n                U32 const matchIndex = dmsRow[matchPos];\n                if (matchIndex < dmsLowestIndex)\n                    break;\n                PREFETCH_L1(dmsBase + matchIndex);\n                matchBuffer[numMatches++] = matchIndex;\n            }\n\n             \n            for (; currMatch < numMatches; ++currMatch) {\n                U32 const matchIndex = matchBuffer[currMatch];\n                size_t currentMl=0;\n                assert(matchIndex >= dmsLowestIndex);\n                assert(matchIndex < curr);\n\n                {   const BYTE* const match = dmsBase + matchIndex;\n                    assert(match+4 <= dmsEnd);\n                    if (MEM_read32(match) == MEM_read32(ip))\n                        currentMl = ZSTD_count_2segments(ip+4, match+4, iLimit, dmsEnd, prefixStart) + 4;\n                }\n\n                if (currentMl > ml) {\n                    ml = currentMl;\n                    assert(curr > matchIndex + dmsIndexDelta);\n                    *offsetPtr = STORE_OFFSET(curr - (matchIndex + dmsIndexDelta));\n                    if (ip+currentMl == iLimit) break;\n                }\n            }\n        }\n    }\n    return ml;\n}\n\n\n \n\n#define ZSTD_BT_SEARCH_FN(dictMode, mls) ZSTD_BtFindBestMatch_##dictMode##_##mls\n#define ZSTD_HC_SEARCH_FN(dictMode, mls) ZSTD_HcFindBestMatch_##dictMode##_##mls\n#define ZSTD_ROW_SEARCH_FN(dictMode, mls, rowLog) ZSTD_RowFindBestMatch_##dictMode##_##mls##_##rowLog\n\n#define ZSTD_SEARCH_FN_ATTRS FORCE_NOINLINE\n\n#define GEN_ZSTD_BT_SEARCH_FN(dictMode, mls)                                           \\\n    ZSTD_SEARCH_FN_ATTRS size_t ZSTD_BT_SEARCH_FN(dictMode, mls)(                      \\\n            ZSTD_matchState_t* ms,                                                     \\\n            const BYTE* ip, const BYTE* const iLimit,                                  \\\n            size_t* offBasePtr)                                                        \\\n    {                                                                                  \\\n        assert(MAX(4, MIN(6, ms->cParams.minMatch)) == mls);                           \\\n        return ZSTD_BtFindBestMatch(ms, ip, iLimit, offBasePtr, mls, ZSTD_##dictMode); \\\n    }                                                                                  \\\n\n#define GEN_ZSTD_HC_SEARCH_FN(dictMode, mls)                                          \\\n    ZSTD_SEARCH_FN_ATTRS size_t ZSTD_HC_SEARCH_FN(dictMode, mls)(                     \\\n            ZSTD_matchState_t* ms,                                                    \\\n            const BYTE* ip, const BYTE* const iLimit,                                 \\\n            size_t* offsetPtr)                                                        \\\n    {                                                                                 \\\n        assert(MAX(4, MIN(6, ms->cParams.minMatch)) == mls);                          \\\n        return ZSTD_HcFindBestMatch(ms, ip, iLimit, offsetPtr, mls, ZSTD_##dictMode); \\\n    }                                                                                 \\\n\n#define GEN_ZSTD_ROW_SEARCH_FN(dictMode, mls, rowLog)                                          \\\n    ZSTD_SEARCH_FN_ATTRS size_t ZSTD_ROW_SEARCH_FN(dictMode, mls, rowLog)(                     \\\n            ZSTD_matchState_t* ms,                                                             \\\n            const BYTE* ip, const BYTE* const iLimit,                                          \\\n            size_t* offsetPtr)                                                                 \\\n    {                                                                                          \\\n        assert(MAX(4, MIN(6, ms->cParams.minMatch)) == mls);                                   \\\n        assert(MAX(4, MIN(6, ms->cParams.searchLog)) == rowLog);                               \\\n        return ZSTD_RowFindBestMatch(ms, ip, iLimit, offsetPtr, mls, ZSTD_##dictMode, rowLog); \\\n    }                                                                                          \\\n\n#define ZSTD_FOR_EACH_ROWLOG(X, dictMode, mls) \\\n    X(dictMode, mls, 4)                        \\\n    X(dictMode, mls, 5)                        \\\n    X(dictMode, mls, 6)\n\n#define ZSTD_FOR_EACH_MLS_ROWLOG(X, dictMode) \\\n    ZSTD_FOR_EACH_ROWLOG(X, dictMode, 4)      \\\n    ZSTD_FOR_EACH_ROWLOG(X, dictMode, 5)      \\\n    ZSTD_FOR_EACH_ROWLOG(X, dictMode, 6)\n\n#define ZSTD_FOR_EACH_MLS(X, dictMode) \\\n    X(dictMode, 4)                     \\\n    X(dictMode, 5)                     \\\n    X(dictMode, 6)\n\n#define ZSTD_FOR_EACH_DICT_MODE(X, ...) \\\n    X(__VA_ARGS__, noDict)              \\\n    X(__VA_ARGS__, extDict)             \\\n    X(__VA_ARGS__, dictMatchState)      \\\n    X(__VA_ARGS__, dedicatedDictSearch)\n\n \nZSTD_FOR_EACH_DICT_MODE(ZSTD_FOR_EACH_MLS_ROWLOG, GEN_ZSTD_ROW_SEARCH_FN)\n \nZSTD_FOR_EACH_DICT_MODE(ZSTD_FOR_EACH_MLS, GEN_ZSTD_BT_SEARCH_FN)\n \nZSTD_FOR_EACH_DICT_MODE(ZSTD_FOR_EACH_MLS, GEN_ZSTD_HC_SEARCH_FN)\n\ntypedef enum { search_hashChain=0, search_binaryTree=1, search_rowHash=2 } searchMethod_e;\n\n#define GEN_ZSTD_CALL_BT_SEARCH_FN(dictMode, mls)                         \\\n    case mls:                                                             \\\n        return ZSTD_BT_SEARCH_FN(dictMode, mls)(ms, ip, iend, offsetPtr);\n#define GEN_ZSTD_CALL_HC_SEARCH_FN(dictMode, mls)                         \\\n    case mls:                                                             \\\n        return ZSTD_HC_SEARCH_FN(dictMode, mls)(ms, ip, iend, offsetPtr);\n#define GEN_ZSTD_CALL_ROW_SEARCH_FN(dictMode, mls, rowLog)                         \\\n    case rowLog:                                                                   \\\n        return ZSTD_ROW_SEARCH_FN(dictMode, mls, rowLog)(ms, ip, iend, offsetPtr);\n\n#define ZSTD_SWITCH_MLS(X, dictMode)   \\\n    switch (mls) {                     \\\n        ZSTD_FOR_EACH_MLS(X, dictMode) \\\n    }\n\n#define ZSTD_SWITCH_ROWLOG(dictMode, mls)                                    \\\n    case mls:                                                                \\\n        switch (rowLog) {                                                    \\\n            ZSTD_FOR_EACH_ROWLOG(GEN_ZSTD_CALL_ROW_SEARCH_FN, dictMode, mls) \\\n        }                                                                    \\\n        ZSTD_UNREACHABLE;                                                    \\\n        break;\n\n#define ZSTD_SWITCH_SEARCH_METHOD(dictMode)                       \\\n    switch (searchMethod) {                                       \\\n        case search_hashChain:                                    \\\n            ZSTD_SWITCH_MLS(GEN_ZSTD_CALL_HC_SEARCH_FN, dictMode) \\\n            break;                                                \\\n        case search_binaryTree:                                   \\\n            ZSTD_SWITCH_MLS(GEN_ZSTD_CALL_BT_SEARCH_FN, dictMode) \\\n            break;                                                \\\n        case search_rowHash:                                      \\\n            ZSTD_SWITCH_MLS(ZSTD_SWITCH_ROWLOG, dictMode)         \\\n            break;                                                \\\n    }                                                             \\\n    ZSTD_UNREACHABLE;\n\n \nFORCE_INLINE_TEMPLATE size_t ZSTD_searchMax(\n    ZSTD_matchState_t* ms,\n    const BYTE* ip,\n    const BYTE* iend,\n    size_t* offsetPtr,\n    U32 const mls,\n    U32 const rowLog,\n    searchMethod_e const searchMethod,\n    ZSTD_dictMode_e const dictMode)\n{\n    if (dictMode == ZSTD_noDict) {\n        ZSTD_SWITCH_SEARCH_METHOD(noDict)\n    } else if (dictMode == ZSTD_extDict) {\n        ZSTD_SWITCH_SEARCH_METHOD(extDict)\n    } else if (dictMode == ZSTD_dictMatchState) {\n        ZSTD_SWITCH_SEARCH_METHOD(dictMatchState)\n    } else if (dictMode == ZSTD_dedicatedDictSearch) {\n        ZSTD_SWITCH_SEARCH_METHOD(dedicatedDictSearch)\n    }\n    ZSTD_UNREACHABLE;\n    return 0;\n}\n\n \n\nFORCE_INLINE_TEMPLATE size_t\nZSTD_compressBlock_lazy_generic(\n                        ZSTD_matchState_t* ms, seqStore_t* seqStore,\n                        U32 rep[ZSTD_REP_NUM],\n                        const void* src, size_t srcSize,\n                        const searchMethod_e searchMethod, const U32 depth,\n                        ZSTD_dictMode_e const dictMode)\n{\n    const BYTE* const istart = (const BYTE*)src;\n    const BYTE* ip = istart;\n    const BYTE* anchor = istart;\n    const BYTE* const iend = istart + srcSize;\n    const BYTE* const ilimit = (searchMethod == search_rowHash) ? iend - 8 - ZSTD_ROW_HASH_CACHE_SIZE : iend - 8;\n    const BYTE* const base = ms->window.base;\n    const U32 prefixLowestIndex = ms->window.dictLimit;\n    const BYTE* const prefixLowest = base + prefixLowestIndex;\n    const U32 mls = BOUNDED(4, ms->cParams.minMatch, 6);\n    const U32 rowLog = BOUNDED(4, ms->cParams.searchLog, 6);\n\n    U32 offset_1 = rep[0], offset_2 = rep[1], savedOffset=0;\n\n    const int isDMS = dictMode == ZSTD_dictMatchState;\n    const int isDDS = dictMode == ZSTD_dedicatedDictSearch;\n    const int isDxS = isDMS || isDDS;\n    const ZSTD_matchState_t* const dms = ms->dictMatchState;\n    const U32 dictLowestIndex      = isDxS ? dms->window.dictLimit : 0;\n    const BYTE* const dictBase     = isDxS ? dms->window.base : NULL;\n    const BYTE* const dictLowest   = isDxS ? dictBase + dictLowestIndex : NULL;\n    const BYTE* const dictEnd      = isDxS ? dms->window.nextSrc : NULL;\n    const U32 dictIndexDelta       = isDxS ?\n                                     prefixLowestIndex - (U32)(dictEnd - dictBase) :\n                                     0;\n    const U32 dictAndPrefixLength = (U32)((ip - prefixLowest) + (dictEnd - dictLowest));\n\n    DEBUGLOG(5, \"ZSTD_compressBlock_lazy_generic (dictMode=%u) (searchFunc=%u)\", (U32)dictMode, (U32)searchMethod);\n    ip += (dictAndPrefixLength == 0);\n    if (dictMode == ZSTD_noDict) {\n        U32 const curr = (U32)(ip - base);\n        U32 const windowLow = ZSTD_getLowestPrefixIndex(ms, curr, ms->cParams.windowLog);\n        U32 const maxRep = curr - windowLow;\n        if (offset_2 > maxRep) savedOffset = offset_2, offset_2 = 0;\n        if (offset_1 > maxRep) savedOffset = offset_1, offset_1 = 0;\n    }\n    if (isDxS) {\n         \n        assert(offset_1 <= dictAndPrefixLength);\n        assert(offset_2 <= dictAndPrefixLength);\n    }\n\n    if (searchMethod == search_rowHash) {\n        ZSTD_row_fillHashCache(ms, base, rowLog,\n                            MIN(ms->cParams.minMatch, 6  ),\n                            ms->nextToUpdate, ilimit);\n    }\n\n     \n#if defined(__x86_64__)\n     \n    __asm__(\".p2align 5\");\n#endif\n    while (ip < ilimit) {\n        size_t matchLength=0;\n        size_t offcode=STORE_REPCODE_1;\n        const BYTE* start=ip+1;\n        DEBUGLOG(7, \"search baseline (depth 0)\");\n\n         \n        if (isDxS) {\n            const U32 repIndex = (U32)(ip - base) + 1 - offset_1;\n            const BYTE* repMatch = ((dictMode == ZSTD_dictMatchState || dictMode == ZSTD_dedicatedDictSearch)\n                                && repIndex < prefixLowestIndex) ?\n                                   dictBase + (repIndex - dictIndexDelta) :\n                                   base + repIndex;\n            if (((U32)((prefixLowestIndex-1) - repIndex) >= 3  )\n                && (MEM_read32(repMatch) == MEM_read32(ip+1)) ) {\n                const BYTE* repMatchEnd = repIndex < prefixLowestIndex ? dictEnd : iend;\n                matchLength = ZSTD_count_2segments(ip+1+4, repMatch+4, iend, repMatchEnd, prefixLowest) + 4;\n                if (depth==0) goto _storeSequence;\n            }\n        }\n        if ( dictMode == ZSTD_noDict\n          && ((offset_1 > 0) & (MEM_read32(ip+1-offset_1) == MEM_read32(ip+1)))) {\n            matchLength = ZSTD_count(ip+1+4, ip+1+4-offset_1, iend) + 4;\n            if (depth==0) goto _storeSequence;\n        }\n\n         \n        {   size_t offsetFound = 999999999;\n            size_t const ml2 = ZSTD_searchMax(ms, ip, iend, &offsetFound, mls, rowLog, searchMethod, dictMode);\n            if (ml2 > matchLength)\n                matchLength = ml2, start = ip, offcode=offsetFound;\n        }\n\n        if (matchLength < 4) {\n            ip += ((ip-anchor) >> kSearchStrength) + 1;    \n            continue;\n        }\n\n         \n        if (depth>=1)\n        while (ip<ilimit) {\n            DEBUGLOG(7, \"search depth 1\");\n            ip ++;\n            if ( (dictMode == ZSTD_noDict)\n              && (offcode) && ((offset_1>0) & (MEM_read32(ip) == MEM_read32(ip - offset_1)))) {\n                size_t const mlRep = ZSTD_count(ip+4, ip+4-offset_1, iend) + 4;\n                int const gain2 = (int)(mlRep * 3);\n                int const gain1 = (int)(matchLength*3 - ZSTD_highbit32((U32)STORED_TO_OFFBASE(offcode)) + 1);\n                if ((mlRep >= 4) && (gain2 > gain1))\n                    matchLength = mlRep, offcode = STORE_REPCODE_1, start = ip;\n            }\n            if (isDxS) {\n                const U32 repIndex = (U32)(ip - base) - offset_1;\n                const BYTE* repMatch = repIndex < prefixLowestIndex ?\n                               dictBase + (repIndex - dictIndexDelta) :\n                               base + repIndex;\n                if (((U32)((prefixLowestIndex-1) - repIndex) >= 3  )\n                    && (MEM_read32(repMatch) == MEM_read32(ip)) ) {\n                    const BYTE* repMatchEnd = repIndex < prefixLowestIndex ? dictEnd : iend;\n                    size_t const mlRep = ZSTD_count_2segments(ip+4, repMatch+4, iend, repMatchEnd, prefixLowest) + 4;\n                    int const gain2 = (int)(mlRep * 3);\n                    int const gain1 = (int)(matchLength*3 - ZSTD_highbit32((U32)STORED_TO_OFFBASE(offcode)) + 1);\n                    if ((mlRep >= 4) && (gain2 > gain1))\n                        matchLength = mlRep, offcode = STORE_REPCODE_1, start = ip;\n                }\n            }\n            {   size_t offset2=999999999;\n                size_t const ml2 = ZSTD_searchMax(ms, ip, iend, &offset2, mls, rowLog, searchMethod, dictMode);\n                int const gain2 = (int)(ml2*4 - ZSTD_highbit32((U32)STORED_TO_OFFBASE(offset2)));    \n                int const gain1 = (int)(matchLength*4 - ZSTD_highbit32((U32)STORED_TO_OFFBASE(offcode)) + 4);\n                if ((ml2 >= 4) && (gain2 > gain1)) {\n                    matchLength = ml2, offcode = offset2, start = ip;\n                    continue;    \n            }   }\n\n             \n            if ((depth==2) && (ip<ilimit)) {\n                DEBUGLOG(7, \"search depth 2\");\n                ip ++;\n                if ( (dictMode == ZSTD_noDict)\n                  && (offcode) && ((offset_1>0) & (MEM_read32(ip) == MEM_read32(ip - offset_1)))) {\n                    size_t const mlRep = ZSTD_count(ip+4, ip+4-offset_1, iend) + 4;\n                    int const gain2 = (int)(mlRep * 4);\n                    int const gain1 = (int)(matchLength*4 - ZSTD_highbit32((U32)STORED_TO_OFFBASE(offcode)) + 1);\n                    if ((mlRep >= 4) && (gain2 > gain1))\n                        matchLength = mlRep, offcode = STORE_REPCODE_1, start = ip;\n                }\n                if (isDxS) {\n                    const U32 repIndex = (U32)(ip - base) - offset_1;\n                    const BYTE* repMatch = repIndex < prefixLowestIndex ?\n                                   dictBase + (repIndex - dictIndexDelta) :\n                                   base + repIndex;\n                    if (((U32)((prefixLowestIndex-1) - repIndex) >= 3  )\n                        && (MEM_read32(repMatch) == MEM_read32(ip)) ) {\n                        const BYTE* repMatchEnd = repIndex < prefixLowestIndex ? dictEnd : iend;\n                        size_t const mlRep = ZSTD_count_2segments(ip+4, repMatch+4, iend, repMatchEnd, prefixLowest) + 4;\n                        int const gain2 = (int)(mlRep * 4);\n                        int const gain1 = (int)(matchLength*4 - ZSTD_highbit32((U32)STORED_TO_OFFBASE(offcode)) + 1);\n                        if ((mlRep >= 4) && (gain2 > gain1))\n                            matchLength = mlRep, offcode = STORE_REPCODE_1, start = ip;\n                    }\n                }\n                {   size_t offset2=999999999;\n                    size_t const ml2 = ZSTD_searchMax(ms, ip, iend, &offset2, mls, rowLog, searchMethod, dictMode);\n                    int const gain2 = (int)(ml2*4 - ZSTD_highbit32((U32)STORED_TO_OFFBASE(offset2)));    \n                    int const gain1 = (int)(matchLength*4 - ZSTD_highbit32((U32)STORED_TO_OFFBASE(offcode)) + 7);\n                    if ((ml2 >= 4) && (gain2 > gain1)) {\n                        matchLength = ml2, offcode = offset2, start = ip;\n                        continue;\n            }   }   }\n            break;   \n        }\n\n         \n         \n        if (STORED_IS_OFFSET(offcode)) {\n            if (dictMode == ZSTD_noDict) {\n                while ( ((start > anchor) & (start - STORED_OFFSET(offcode) > prefixLowest))\n                     && (start[-1] == (start-STORED_OFFSET(offcode))[-1]) )   \n                    { start--; matchLength++; }\n            }\n            if (isDxS) {\n                U32 const matchIndex = (U32)((size_t)(start-base) - STORED_OFFSET(offcode));\n                const BYTE* match = (matchIndex < prefixLowestIndex) ? dictBase + matchIndex - dictIndexDelta : base + matchIndex;\n                const BYTE* const mStart = (matchIndex < prefixLowestIndex) ? dictLowest : prefixLowest;\n                while ((start>anchor) && (match>mStart) && (start[-1] == match[-1])) { start--; match--; matchLength++; }   \n            }\n            offset_2 = offset_1; offset_1 = (U32)STORED_OFFSET(offcode);\n        }\n         \n_storeSequence:\n        {   size_t const litLength = (size_t)(start - anchor);\n            ZSTD_storeSeq(seqStore, litLength, anchor, iend, (U32)offcode, matchLength);\n            anchor = ip = start + matchLength;\n        }\n\n         \n        if (isDxS) {\n            while (ip <= ilimit) {\n                U32 const current2 = (U32)(ip-base);\n                U32 const repIndex = current2 - offset_2;\n                const BYTE* repMatch = repIndex < prefixLowestIndex ?\n                        dictBase - dictIndexDelta + repIndex :\n                        base + repIndex;\n                if ( ((U32)((prefixLowestIndex-1) - (U32)repIndex) >= 3  )\n                   && (MEM_read32(repMatch) == MEM_read32(ip)) ) {\n                    const BYTE* const repEnd2 = repIndex < prefixLowestIndex ? dictEnd : iend;\n                    matchLength = ZSTD_count_2segments(ip+4, repMatch+4, iend, repEnd2, prefixLowest) + 4;\n                    offcode = offset_2; offset_2 = offset_1; offset_1 = (U32)offcode;    \n                    ZSTD_storeSeq(seqStore, 0, anchor, iend, STORE_REPCODE_1, matchLength);\n                    ip += matchLength;\n                    anchor = ip;\n                    continue;\n                }\n                break;\n            }\n        }\n\n        if (dictMode == ZSTD_noDict) {\n            while ( ((ip <= ilimit) & (offset_2>0))\n                 && (MEM_read32(ip) == MEM_read32(ip - offset_2)) ) {\n                 \n                matchLength = ZSTD_count(ip+4, ip+4-offset_2, iend) + 4;\n                offcode = offset_2; offset_2 = offset_1; offset_1 = (U32)offcode;  \n                ZSTD_storeSeq(seqStore, 0, anchor, iend, STORE_REPCODE_1, matchLength);\n                ip += matchLength;\n                anchor = ip;\n                continue;    \n    }   }   }\n\n     \n    rep[0] = offset_1 ? offset_1 : savedOffset;\n    rep[1] = offset_2 ? offset_2 : savedOffset;\n\n     \n    return (size_t)(iend - anchor);\n}\n\n\nsize_t ZSTD_compressBlock_btlazy2(\n        ZSTD_matchState_t* ms, seqStore_t* seqStore, U32 rep[ZSTD_REP_NUM],\n        void const* src, size_t srcSize)\n{\n    return ZSTD_compressBlock_lazy_generic(ms, seqStore, rep, src, srcSize, search_binaryTree, 2, ZSTD_noDict);\n}\n\nsize_t ZSTD_compressBlock_lazy2(\n        ZSTD_matchState_t* ms, seqStore_t* seqStore, U32 rep[ZSTD_REP_NUM],\n        void const* src, size_t srcSize)\n{\n    return ZSTD_compressBlock_lazy_generic(ms, seqStore, rep, src, srcSize, search_hashChain, 2, ZSTD_noDict);\n}\n\nsize_t ZSTD_compressBlock_lazy(\n        ZSTD_matchState_t* ms, seqStore_t* seqStore, U32 rep[ZSTD_REP_NUM],\n        void const* src, size_t srcSize)\n{\n    return ZSTD_compressBlock_lazy_generic(ms, seqStore, rep, src, srcSize, search_hashChain, 1, ZSTD_noDict);\n}\n\nsize_t ZSTD_compressBlock_greedy(\n        ZSTD_matchState_t* ms, seqStore_t* seqStore, U32 rep[ZSTD_REP_NUM],\n        void const* src, size_t srcSize)\n{\n    return ZSTD_compressBlock_lazy_generic(ms, seqStore, rep, src, srcSize, search_hashChain, 0, ZSTD_noDict);\n}\n\nsize_t ZSTD_compressBlock_btlazy2_dictMatchState(\n        ZSTD_matchState_t* ms, seqStore_t* seqStore, U32 rep[ZSTD_REP_NUM],\n        void const* src, size_t srcSize)\n{\n    return ZSTD_compressBlock_lazy_generic(ms, seqStore, rep, src, srcSize, search_binaryTree, 2, ZSTD_dictMatchState);\n}\n\nsize_t ZSTD_compressBlock_lazy2_dictMatchState(\n        ZSTD_matchState_t* ms, seqStore_t* seqStore, U32 rep[ZSTD_REP_NUM],\n        void const* src, size_t srcSize)\n{\n    return ZSTD_compressBlock_lazy_generic(ms, seqStore, rep, src, srcSize, search_hashChain, 2, ZSTD_dictMatchState);\n}\n\nsize_t ZSTD_compressBlock_lazy_dictMatchState(\n        ZSTD_matchState_t* ms, seqStore_t* seqStore, U32 rep[ZSTD_REP_NUM],\n        void const* src, size_t srcSize)\n{\n    return ZSTD_compressBlock_lazy_generic(ms, seqStore, rep, src, srcSize, search_hashChain, 1, ZSTD_dictMatchState);\n}\n\nsize_t ZSTD_compressBlock_greedy_dictMatchState(\n        ZSTD_matchState_t* ms, seqStore_t* seqStore, U32 rep[ZSTD_REP_NUM],\n        void const* src, size_t srcSize)\n{\n    return ZSTD_compressBlock_lazy_generic(ms, seqStore, rep, src, srcSize, search_hashChain, 0, ZSTD_dictMatchState);\n}\n\n\nsize_t ZSTD_compressBlock_lazy2_dedicatedDictSearch(\n        ZSTD_matchState_t* ms, seqStore_t* seqStore, U32 rep[ZSTD_REP_NUM],\n        void const* src, size_t srcSize)\n{\n    return ZSTD_compressBlock_lazy_generic(ms, seqStore, rep, src, srcSize, search_hashChain, 2, ZSTD_dedicatedDictSearch);\n}\n\nsize_t ZSTD_compressBlock_lazy_dedicatedDictSearch(\n        ZSTD_matchState_t* ms, seqStore_t* seqStore, U32 rep[ZSTD_REP_NUM],\n        void const* src, size_t srcSize)\n{\n    return ZSTD_compressBlock_lazy_generic(ms, seqStore, rep, src, srcSize, search_hashChain, 1, ZSTD_dedicatedDictSearch);\n}\n\nsize_t ZSTD_compressBlock_greedy_dedicatedDictSearch(\n        ZSTD_matchState_t* ms, seqStore_t* seqStore, U32 rep[ZSTD_REP_NUM],\n        void const* src, size_t srcSize)\n{\n    return ZSTD_compressBlock_lazy_generic(ms, seqStore, rep, src, srcSize, search_hashChain, 0, ZSTD_dedicatedDictSearch);\n}\n\n \nsize_t ZSTD_compressBlock_lazy2_row(\n        ZSTD_matchState_t* ms, seqStore_t* seqStore, U32 rep[ZSTD_REP_NUM],\n        void const* src, size_t srcSize)\n{\n    return ZSTD_compressBlock_lazy_generic(ms, seqStore, rep, src, srcSize, search_rowHash, 2, ZSTD_noDict);\n}\n\nsize_t ZSTD_compressBlock_lazy_row(\n        ZSTD_matchState_t* ms, seqStore_t* seqStore, U32 rep[ZSTD_REP_NUM],\n        void const* src, size_t srcSize)\n{\n    return ZSTD_compressBlock_lazy_generic(ms, seqStore, rep, src, srcSize, search_rowHash, 1, ZSTD_noDict);\n}\n\nsize_t ZSTD_compressBlock_greedy_row(\n        ZSTD_matchState_t* ms, seqStore_t* seqStore, U32 rep[ZSTD_REP_NUM],\n        void const* src, size_t srcSize)\n{\n    return ZSTD_compressBlock_lazy_generic(ms, seqStore, rep, src, srcSize, search_rowHash, 0, ZSTD_noDict);\n}\n\nsize_t ZSTD_compressBlock_lazy2_dictMatchState_row(\n        ZSTD_matchState_t* ms, seqStore_t* seqStore, U32 rep[ZSTD_REP_NUM],\n        void const* src, size_t srcSize)\n{\n    return ZSTD_compressBlock_lazy_generic(ms, seqStore, rep, src, srcSize, search_rowHash, 2, ZSTD_dictMatchState);\n}\n\nsize_t ZSTD_compressBlock_lazy_dictMatchState_row(\n        ZSTD_matchState_t* ms, seqStore_t* seqStore, U32 rep[ZSTD_REP_NUM],\n        void const* src, size_t srcSize)\n{\n    return ZSTD_compressBlock_lazy_generic(ms, seqStore, rep, src, srcSize, search_rowHash, 1, ZSTD_dictMatchState);\n}\n\nsize_t ZSTD_compressBlock_greedy_dictMatchState_row(\n        ZSTD_matchState_t* ms, seqStore_t* seqStore, U32 rep[ZSTD_REP_NUM],\n        void const* src, size_t srcSize)\n{\n    return ZSTD_compressBlock_lazy_generic(ms, seqStore, rep, src, srcSize, search_rowHash, 0, ZSTD_dictMatchState);\n}\n\n\nsize_t ZSTD_compressBlock_lazy2_dedicatedDictSearch_row(\n        ZSTD_matchState_t* ms, seqStore_t* seqStore, U32 rep[ZSTD_REP_NUM],\n        void const* src, size_t srcSize)\n{\n    return ZSTD_compressBlock_lazy_generic(ms, seqStore, rep, src, srcSize, search_rowHash, 2, ZSTD_dedicatedDictSearch);\n}\n\nsize_t ZSTD_compressBlock_lazy_dedicatedDictSearch_row(\n        ZSTD_matchState_t* ms, seqStore_t* seqStore, U32 rep[ZSTD_REP_NUM],\n        void const* src, size_t srcSize)\n{\n    return ZSTD_compressBlock_lazy_generic(ms, seqStore, rep, src, srcSize, search_rowHash, 1, ZSTD_dedicatedDictSearch);\n}\n\nsize_t ZSTD_compressBlock_greedy_dedicatedDictSearch_row(\n        ZSTD_matchState_t* ms, seqStore_t* seqStore, U32 rep[ZSTD_REP_NUM],\n        void const* src, size_t srcSize)\n{\n    return ZSTD_compressBlock_lazy_generic(ms, seqStore, rep, src, srcSize, search_rowHash, 0, ZSTD_dedicatedDictSearch);\n}\n\nFORCE_INLINE_TEMPLATE\nsize_t ZSTD_compressBlock_lazy_extDict_generic(\n                        ZSTD_matchState_t* ms, seqStore_t* seqStore,\n                        U32 rep[ZSTD_REP_NUM],\n                        const void* src, size_t srcSize,\n                        const searchMethod_e searchMethod, const U32 depth)\n{\n    const BYTE* const istart = (const BYTE*)src;\n    const BYTE* ip = istart;\n    const BYTE* anchor = istart;\n    const BYTE* const iend = istart + srcSize;\n    const BYTE* const ilimit = searchMethod == search_rowHash ? iend - 8 - ZSTD_ROW_HASH_CACHE_SIZE : iend - 8;\n    const BYTE* const base = ms->window.base;\n    const U32 dictLimit = ms->window.dictLimit;\n    const BYTE* const prefixStart = base + dictLimit;\n    const BYTE* const dictBase = ms->window.dictBase;\n    const BYTE* const dictEnd  = dictBase + dictLimit;\n    const BYTE* const dictStart  = dictBase + ms->window.lowLimit;\n    const U32 windowLog = ms->cParams.windowLog;\n    const U32 mls = BOUNDED(4, ms->cParams.minMatch, 6);\n    const U32 rowLog = BOUNDED(4, ms->cParams.searchLog, 6);\n\n    U32 offset_1 = rep[0], offset_2 = rep[1];\n\n    DEBUGLOG(5, \"ZSTD_compressBlock_lazy_extDict_generic (searchFunc=%u)\", (U32)searchMethod);\n\n     \n    ip += (ip == prefixStart);\n    if (searchMethod == search_rowHash) {\n        ZSTD_row_fillHashCache(ms, base, rowLog,\n                               MIN(ms->cParams.minMatch, 6  ),\n                               ms->nextToUpdate, ilimit);\n    }\n\n     \n#if defined(__x86_64__)\n     \n    __asm__(\".p2align 5\");\n#endif\n    while (ip < ilimit) {\n        size_t matchLength=0;\n        size_t offcode=STORE_REPCODE_1;\n        const BYTE* start=ip+1;\n        U32 curr = (U32)(ip-base);\n\n         \n        {   const U32 windowLow = ZSTD_getLowestMatchIndex(ms, curr+1, windowLog);\n            const U32 repIndex = (U32)(curr+1 - offset_1);\n            const BYTE* const repBase = repIndex < dictLimit ? dictBase : base;\n            const BYTE* const repMatch = repBase + repIndex;\n            if ( ((U32)((dictLimit-1) - repIndex) >= 3)  \n               & (offset_1 <= curr+1 - windowLow) )  \n            if (MEM_read32(ip+1) == MEM_read32(repMatch)) {\n                 \n                const BYTE* const repEnd = repIndex < dictLimit ? dictEnd : iend;\n                matchLength = ZSTD_count_2segments(ip+1+4, repMatch+4, iend, repEnd, prefixStart) + 4;\n                if (depth==0) goto _storeSequence;\n        }   }\n\n         \n        {   size_t offsetFound = 999999999;\n            size_t const ml2 = ZSTD_searchMax(ms, ip, iend, &offsetFound, mls, rowLog, searchMethod, ZSTD_extDict);\n            if (ml2 > matchLength)\n                matchLength = ml2, start = ip, offcode=offsetFound;\n        }\n\n        if (matchLength < 4) {\n            ip += ((ip-anchor) >> kSearchStrength) + 1;    \n            continue;\n        }\n\n         \n        if (depth>=1)\n        while (ip<ilimit) {\n            ip ++;\n            curr++;\n             \n            if (offcode) {\n                const U32 windowLow = ZSTD_getLowestMatchIndex(ms, curr, windowLog);\n                const U32 repIndex = (U32)(curr - offset_1);\n                const BYTE* const repBase = repIndex < dictLimit ? dictBase : base;\n                const BYTE* const repMatch = repBase + repIndex;\n                if ( ((U32)((dictLimit-1) - repIndex) >= 3)  \n                   & (offset_1 <= curr - windowLow) )  \n                if (MEM_read32(ip) == MEM_read32(repMatch)) {\n                     \n                    const BYTE* const repEnd = repIndex < dictLimit ? dictEnd : iend;\n                    size_t const repLength = ZSTD_count_2segments(ip+4, repMatch+4, iend, repEnd, prefixStart) + 4;\n                    int const gain2 = (int)(repLength * 3);\n                    int const gain1 = (int)(matchLength*3 - ZSTD_highbit32((U32)STORED_TO_OFFBASE(offcode)) + 1);\n                    if ((repLength >= 4) && (gain2 > gain1))\n                        matchLength = repLength, offcode = STORE_REPCODE_1, start = ip;\n            }   }\n\n             \n            {   size_t offset2=999999999;\n                size_t const ml2 = ZSTD_searchMax(ms, ip, iend, &offset2, mls, rowLog, searchMethod, ZSTD_extDict);\n                int const gain2 = (int)(ml2*4 - ZSTD_highbit32((U32)STORED_TO_OFFBASE(offset2)));    \n                int const gain1 = (int)(matchLength*4 - ZSTD_highbit32((U32)STORED_TO_OFFBASE(offcode)) + 4);\n                if ((ml2 >= 4) && (gain2 > gain1)) {\n                    matchLength = ml2, offcode = offset2, start = ip;\n                    continue;    \n            }   }\n\n             \n            if ((depth==2) && (ip<ilimit)) {\n                ip ++;\n                curr++;\n                 \n                if (offcode) {\n                    const U32 windowLow = ZSTD_getLowestMatchIndex(ms, curr, windowLog);\n                    const U32 repIndex = (U32)(curr - offset_1);\n                    const BYTE* const repBase = repIndex < dictLimit ? dictBase : base;\n                    const BYTE* const repMatch = repBase + repIndex;\n                    if ( ((U32)((dictLimit-1) - repIndex) >= 3)  \n                       & (offset_1 <= curr - windowLow) )  \n                    if (MEM_read32(ip) == MEM_read32(repMatch)) {\n                         \n                        const BYTE* const repEnd = repIndex < dictLimit ? dictEnd : iend;\n                        size_t const repLength = ZSTD_count_2segments(ip+4, repMatch+4, iend, repEnd, prefixStart) + 4;\n                        int const gain2 = (int)(repLength * 4);\n                        int const gain1 = (int)(matchLength*4 - ZSTD_highbit32((U32)STORED_TO_OFFBASE(offcode)) + 1);\n                        if ((repLength >= 4) && (gain2 > gain1))\n                            matchLength = repLength, offcode = STORE_REPCODE_1, start = ip;\n                }   }\n\n                 \n                {   size_t offset2=999999999;\n                    size_t const ml2 = ZSTD_searchMax(ms, ip, iend, &offset2, mls, rowLog, searchMethod, ZSTD_extDict);\n                    int const gain2 = (int)(ml2*4 - ZSTD_highbit32((U32)STORED_TO_OFFBASE(offset2)));    \n                    int const gain1 = (int)(matchLength*4 - ZSTD_highbit32((U32)STORED_TO_OFFBASE(offcode)) + 7);\n                    if ((ml2 >= 4) && (gain2 > gain1)) {\n                        matchLength = ml2, offcode = offset2, start = ip;\n                        continue;\n            }   }   }\n            break;   \n        }\n\n         \n        if (STORED_IS_OFFSET(offcode)) {\n            U32 const matchIndex = (U32)((size_t)(start-base) - STORED_OFFSET(offcode));\n            const BYTE* match = (matchIndex < dictLimit) ? dictBase + matchIndex : base + matchIndex;\n            const BYTE* const mStart = (matchIndex < dictLimit) ? dictStart : prefixStart;\n            while ((start>anchor) && (match>mStart) && (start[-1] == match[-1])) { start--; match--; matchLength++; }   \n            offset_2 = offset_1; offset_1 = (U32)STORED_OFFSET(offcode);\n        }\n\n         \n_storeSequence:\n        {   size_t const litLength = (size_t)(start - anchor);\n            ZSTD_storeSeq(seqStore, litLength, anchor, iend, (U32)offcode, matchLength);\n            anchor = ip = start + matchLength;\n        }\n\n         \n        while (ip <= ilimit) {\n            const U32 repCurrent = (U32)(ip-base);\n            const U32 windowLow = ZSTD_getLowestMatchIndex(ms, repCurrent, windowLog);\n            const U32 repIndex = repCurrent - offset_2;\n            const BYTE* const repBase = repIndex < dictLimit ? dictBase : base;\n            const BYTE* const repMatch = repBase + repIndex;\n            if ( ((U32)((dictLimit-1) - repIndex) >= 3)  \n               & (offset_2 <= repCurrent - windowLow) )  \n            if (MEM_read32(ip) == MEM_read32(repMatch)) {\n                 \n                const BYTE* const repEnd = repIndex < dictLimit ? dictEnd : iend;\n                matchLength = ZSTD_count_2segments(ip+4, repMatch+4, iend, repEnd, prefixStart) + 4;\n                offcode = offset_2; offset_2 = offset_1; offset_1 = (U32)offcode;    \n                ZSTD_storeSeq(seqStore, 0, anchor, iend, STORE_REPCODE_1, matchLength);\n                ip += matchLength;\n                anchor = ip;\n                continue;    \n            }\n            break;\n    }   }\n\n     \n    rep[0] = offset_1;\n    rep[1] = offset_2;\n\n     \n    return (size_t)(iend - anchor);\n}\n\n\nsize_t ZSTD_compressBlock_greedy_extDict(\n        ZSTD_matchState_t* ms, seqStore_t* seqStore, U32 rep[ZSTD_REP_NUM],\n        void const* src, size_t srcSize)\n{\n    return ZSTD_compressBlock_lazy_extDict_generic(ms, seqStore, rep, src, srcSize, search_hashChain, 0);\n}\n\nsize_t ZSTD_compressBlock_lazy_extDict(\n        ZSTD_matchState_t* ms, seqStore_t* seqStore, U32 rep[ZSTD_REP_NUM],\n        void const* src, size_t srcSize)\n\n{\n    return ZSTD_compressBlock_lazy_extDict_generic(ms, seqStore, rep, src, srcSize, search_hashChain, 1);\n}\n\nsize_t ZSTD_compressBlock_lazy2_extDict(\n        ZSTD_matchState_t* ms, seqStore_t* seqStore, U32 rep[ZSTD_REP_NUM],\n        void const* src, size_t srcSize)\n\n{\n    return ZSTD_compressBlock_lazy_extDict_generic(ms, seqStore, rep, src, srcSize, search_hashChain, 2);\n}\n\nsize_t ZSTD_compressBlock_btlazy2_extDict(\n        ZSTD_matchState_t* ms, seqStore_t* seqStore, U32 rep[ZSTD_REP_NUM],\n        void const* src, size_t srcSize)\n\n{\n    return ZSTD_compressBlock_lazy_extDict_generic(ms, seqStore, rep, src, srcSize, search_binaryTree, 2);\n}\n\nsize_t ZSTD_compressBlock_greedy_extDict_row(\n        ZSTD_matchState_t* ms, seqStore_t* seqStore, U32 rep[ZSTD_REP_NUM],\n        void const* src, size_t srcSize)\n{\n    return ZSTD_compressBlock_lazy_extDict_generic(ms, seqStore, rep, src, srcSize, search_rowHash, 0);\n}\n\nsize_t ZSTD_compressBlock_lazy_extDict_row(\n        ZSTD_matchState_t* ms, seqStore_t* seqStore, U32 rep[ZSTD_REP_NUM],\n        void const* src, size_t srcSize)\n\n{\n    return ZSTD_compressBlock_lazy_extDict_generic(ms, seqStore, rep, src, srcSize, search_rowHash, 1);\n}\n\nsize_t ZSTD_compressBlock_lazy2_extDict_row(\n        ZSTD_matchState_t* ms, seqStore_t* seqStore, U32 rep[ZSTD_REP_NUM],\n        void const* src, size_t srcSize)\n\n{\n    return ZSTD_compressBlock_lazy_extDict_generic(ms, seqStore, rep, src, srcSize, search_rowHash, 2);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}