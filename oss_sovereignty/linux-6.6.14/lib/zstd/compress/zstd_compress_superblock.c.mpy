{
  "module_name": "zstd_compress_superblock.c",
  "hash_id": "39b7a0c1b44fedf355a382a2607f5cf5cbc2923f53e6dfa7c43777fb33771101",
  "original_prompt": "Ingested from linux-6.6.14/lib/zstd/compress/zstd_compress_superblock.c",
  "human_readable_source": " \n\n  \n#include \"zstd_compress_superblock.h\"\n\n#include \"../common/zstd_internal.h\"   \n#include \"hist.h\"                      \n#include \"zstd_compress_internal.h\"    \n#include \"zstd_compress_sequences.h\"\n#include \"zstd_compress_literals.h\"\n\n \nstatic size_t ZSTD_compressSubBlock_literal(const HUF_CElt* hufTable,\n                                    const ZSTD_hufCTablesMetadata_t* hufMetadata,\n                                    const BYTE* literals, size_t litSize,\n                                    void* dst, size_t dstSize,\n                                    const int bmi2, int writeEntropy, int* entropyWritten)\n{\n    size_t const header = writeEntropy ? 200 : 0;\n    size_t const lhSize = 3 + (litSize >= (1 KB - header)) + (litSize >= (16 KB - header));\n    BYTE* const ostart = (BYTE*)dst;\n    BYTE* const oend = ostart + dstSize;\n    BYTE* op = ostart + lhSize;\n    U32 const singleStream = lhSize == 3;\n    symbolEncodingType_e hType = writeEntropy ? hufMetadata->hType : set_repeat;\n    size_t cLitSize = 0;\n\n    (void)bmi2;  \n\n    DEBUGLOG(5, \"ZSTD_compressSubBlock_literal (litSize=%zu, lhSize=%zu, writeEntropy=%d)\", litSize, lhSize, writeEntropy);\n\n    *entropyWritten = 0;\n    if (litSize == 0 || hufMetadata->hType == set_basic) {\n      DEBUGLOG(5, \"ZSTD_compressSubBlock_literal using raw literal\");\n      return ZSTD_noCompressLiterals(dst, dstSize, literals, litSize);\n    } else if (hufMetadata->hType == set_rle) {\n      DEBUGLOG(5, \"ZSTD_compressSubBlock_literal using rle literal\");\n      return ZSTD_compressRleLiteralsBlock(dst, dstSize, literals, litSize);\n    }\n\n    assert(litSize > 0);\n    assert(hufMetadata->hType == set_compressed || hufMetadata->hType == set_repeat);\n\n    if (writeEntropy && hufMetadata->hType == set_compressed) {\n        ZSTD_memcpy(op, hufMetadata->hufDesBuffer, hufMetadata->hufDesSize);\n        op += hufMetadata->hufDesSize;\n        cLitSize += hufMetadata->hufDesSize;\n        DEBUGLOG(5, \"ZSTD_compressSubBlock_literal (hSize=%zu)\", hufMetadata->hufDesSize);\n    }\n\n     \n    {   const size_t cSize = singleStream ? HUF_compress1X_usingCTable(op, oend-op, literals, litSize, hufTable)\n                                          : HUF_compress4X_usingCTable(op, oend-op, literals, litSize, hufTable);\n        op += cSize;\n        cLitSize += cSize;\n        if (cSize == 0 || ERR_isError(cSize)) {\n            DEBUGLOG(5, \"Failed to write entropy tables %s\", ZSTD_getErrorName(cSize));\n            return 0;\n        }\n         \n        if (!writeEntropy && cLitSize >= litSize) {\n            DEBUGLOG(5, \"ZSTD_compressSubBlock_literal using raw literal because uncompressible\");\n            return ZSTD_noCompressLiterals(dst, dstSize, literals, litSize);\n        }\n         \n        if (lhSize < (size_t)(3 + (cLitSize >= 1 KB) + (cLitSize >= 16 KB))) {\n            assert(cLitSize > litSize);\n            DEBUGLOG(5, \"Literals expanded beyond allowed header size\");\n            return ZSTD_noCompressLiterals(dst, dstSize, literals, litSize);\n        }\n        DEBUGLOG(5, \"ZSTD_compressSubBlock_literal (cSize=%zu)\", cSize);\n    }\n\n     \n    switch(lhSize)\n    {\n    case 3:  \n        {   U32 const lhc = hType + ((!singleStream) << 2) + ((U32)litSize<<4) + ((U32)cLitSize<<14);\n            MEM_writeLE24(ostart, lhc);\n            break;\n        }\n    case 4:  \n        {   U32 const lhc = hType + (2 << 2) + ((U32)litSize<<4) + ((U32)cLitSize<<18);\n            MEM_writeLE32(ostart, lhc);\n            break;\n        }\n    case 5:  \n        {   U32 const lhc = hType + (3 << 2) + ((U32)litSize<<4) + ((U32)cLitSize<<22);\n            MEM_writeLE32(ostart, lhc);\n            ostart[4] = (BYTE)(cLitSize >> 10);\n            break;\n        }\n    default:   \n        assert(0);\n    }\n    *entropyWritten = 1;\n    DEBUGLOG(5, \"Compressed literals: %u -> %u\", (U32)litSize, (U32)(op-ostart));\n    return op-ostart;\n}\n\nstatic size_t ZSTD_seqDecompressedSize(seqStore_t const* seqStore, const seqDef* sequences, size_t nbSeq, size_t litSize, int lastSequence) {\n    const seqDef* const sstart = sequences;\n    const seqDef* const send = sequences + nbSeq;\n    const seqDef* sp = sstart;\n    size_t matchLengthSum = 0;\n    size_t litLengthSum = 0;\n    (void)(litLengthSum);  \n    while (send-sp > 0) {\n        ZSTD_sequenceLength const seqLen = ZSTD_getSequenceLength(seqStore, sp);\n        litLengthSum += seqLen.litLength;\n        matchLengthSum += seqLen.matchLength;\n        sp++;\n    }\n    assert(litLengthSum <= litSize);\n    if (!lastSequence) {\n        assert(litLengthSum == litSize);\n    }\n    return matchLengthSum + litSize;\n}\n\n \nstatic size_t ZSTD_compressSubBlock_sequences(const ZSTD_fseCTables_t* fseTables,\n                                              const ZSTD_fseCTablesMetadata_t* fseMetadata,\n                                              const seqDef* sequences, size_t nbSeq,\n                                              const BYTE* llCode, const BYTE* mlCode, const BYTE* ofCode,\n                                              const ZSTD_CCtx_params* cctxParams,\n                                              void* dst, size_t dstCapacity,\n                                              const int bmi2, int writeEntropy, int* entropyWritten)\n{\n    const int longOffsets = cctxParams->cParams.windowLog > STREAM_ACCUMULATOR_MIN;\n    BYTE* const ostart = (BYTE*)dst;\n    BYTE* const oend = ostart + dstCapacity;\n    BYTE* op = ostart;\n    BYTE* seqHead;\n\n    DEBUGLOG(5, \"ZSTD_compressSubBlock_sequences (nbSeq=%zu, writeEntropy=%d, longOffsets=%d)\", nbSeq, writeEntropy, longOffsets);\n\n    *entropyWritten = 0;\n     \n    RETURN_ERROR_IF((oend-op) < 3   + 1  ,\n                    dstSize_tooSmall, \"\");\n    if (nbSeq < 0x7F)\n        *op++ = (BYTE)nbSeq;\n    else if (nbSeq < LONGNBSEQ)\n        op[0] = (BYTE)((nbSeq>>8) + 0x80), op[1] = (BYTE)nbSeq, op+=2;\n    else\n        op[0]=0xFF, MEM_writeLE16(op+1, (U16)(nbSeq - LONGNBSEQ)), op+=3;\n    if (nbSeq==0) {\n        return op - ostart;\n    }\n\n     \n    seqHead = op++;\n\n    DEBUGLOG(5, \"ZSTD_compressSubBlock_sequences (seqHeadSize=%u)\", (unsigned)(op-ostart));\n\n    if (writeEntropy) {\n        const U32 LLtype = fseMetadata->llType;\n        const U32 Offtype = fseMetadata->ofType;\n        const U32 MLtype = fseMetadata->mlType;\n        DEBUGLOG(5, \"ZSTD_compressSubBlock_sequences (fseTablesSize=%zu)\", fseMetadata->fseTablesSize);\n        *seqHead = (BYTE)((LLtype<<6) + (Offtype<<4) + (MLtype<<2));\n        ZSTD_memcpy(op, fseMetadata->fseTablesBuffer, fseMetadata->fseTablesSize);\n        op += fseMetadata->fseTablesSize;\n    } else {\n        const U32 repeat = set_repeat;\n        *seqHead = (BYTE)((repeat<<6) + (repeat<<4) + (repeat<<2));\n    }\n\n    {   size_t const bitstreamSize = ZSTD_encodeSequences(\n                                        op, oend - op,\n                                        fseTables->matchlengthCTable, mlCode,\n                                        fseTables->offcodeCTable, ofCode,\n                                        fseTables->litlengthCTable, llCode,\n                                        sequences, nbSeq,\n                                        longOffsets, bmi2);\n        FORWARD_IF_ERROR(bitstreamSize, \"ZSTD_encodeSequences failed\");\n        op += bitstreamSize;\n         \n#ifndef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION\n        if (writeEntropy && fseMetadata->lastCountSize && fseMetadata->lastCountSize + bitstreamSize < 4) {\n             \n            assert(fseMetadata->lastCountSize + bitstreamSize == 3);\n            DEBUGLOG(5, \"Avoiding bug in zstd decoder in versions <= 1.3.4 by \"\n                        \"emitting an uncompressed block.\");\n            return 0;\n        }\n#endif\n        DEBUGLOG(5, \"ZSTD_compressSubBlock_sequences (bitstreamSize=%zu)\", bitstreamSize);\n    }\n\n     \n#ifndef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION\n    if (op-seqHead < 4) {\n        DEBUGLOG(5, \"Avoiding bug in zstd decoder in versions <= 1.4.0 by emitting \"\n                    \"an uncompressed block when sequences are < 4 bytes\");\n        return 0;\n    }\n#endif\n\n    *entropyWritten = 1;\n    return op - ostart;\n}\n\n \nstatic size_t ZSTD_compressSubBlock(const ZSTD_entropyCTables_t* entropy,\n                                    const ZSTD_entropyCTablesMetadata_t* entropyMetadata,\n                                    const seqDef* sequences, size_t nbSeq,\n                                    const BYTE* literals, size_t litSize,\n                                    const BYTE* llCode, const BYTE* mlCode, const BYTE* ofCode,\n                                    const ZSTD_CCtx_params* cctxParams,\n                                    void* dst, size_t dstCapacity,\n                                    const int bmi2,\n                                    int writeLitEntropy, int writeSeqEntropy,\n                                    int* litEntropyWritten, int* seqEntropyWritten,\n                                    U32 lastBlock)\n{\n    BYTE* const ostart = (BYTE*)dst;\n    BYTE* const oend = ostart + dstCapacity;\n    BYTE* op = ostart + ZSTD_blockHeaderSize;\n    DEBUGLOG(5, \"ZSTD_compressSubBlock (litSize=%zu, nbSeq=%zu, writeLitEntropy=%d, writeSeqEntropy=%d, lastBlock=%d)\",\n                litSize, nbSeq, writeLitEntropy, writeSeqEntropy, lastBlock);\n    {   size_t cLitSize = ZSTD_compressSubBlock_literal((const HUF_CElt*)entropy->huf.CTable,\n                                                        &entropyMetadata->hufMetadata, literals, litSize,\n                                                        op, oend-op, bmi2, writeLitEntropy, litEntropyWritten);\n        FORWARD_IF_ERROR(cLitSize, \"ZSTD_compressSubBlock_literal failed\");\n        if (cLitSize == 0) return 0;\n        op += cLitSize;\n    }\n    {   size_t cSeqSize = ZSTD_compressSubBlock_sequences(&entropy->fse,\n                                                  &entropyMetadata->fseMetadata,\n                                                  sequences, nbSeq,\n                                                  llCode, mlCode, ofCode,\n                                                  cctxParams,\n                                                  op, oend-op,\n                                                  bmi2, writeSeqEntropy, seqEntropyWritten);\n        FORWARD_IF_ERROR(cSeqSize, \"ZSTD_compressSubBlock_sequences failed\");\n        if (cSeqSize == 0) return 0;\n        op += cSeqSize;\n    }\n     \n    {   size_t cSize = (op-ostart)-ZSTD_blockHeaderSize;\n        U32 const cBlockHeader24 = lastBlock + (((U32)bt_compressed)<<1) + (U32)(cSize << 3);\n        MEM_writeLE24(ostart, cBlockHeader24);\n    }\n    return op-ostart;\n}\n\nstatic size_t ZSTD_estimateSubBlockSize_literal(const BYTE* literals, size_t litSize,\n                                                const ZSTD_hufCTables_t* huf,\n                                                const ZSTD_hufCTablesMetadata_t* hufMetadata,\n                                                void* workspace, size_t wkspSize,\n                                                int writeEntropy)\n{\n    unsigned* const countWksp = (unsigned*)workspace;\n    unsigned maxSymbolValue = 255;\n    size_t literalSectionHeaderSize = 3;  \n\n    if (hufMetadata->hType == set_basic) return litSize;\n    else if (hufMetadata->hType == set_rle) return 1;\n    else if (hufMetadata->hType == set_compressed || hufMetadata->hType == set_repeat) {\n        size_t const largest = HIST_count_wksp (countWksp, &maxSymbolValue, (const BYTE*)literals, litSize, workspace, wkspSize);\n        if (ZSTD_isError(largest)) return litSize;\n        {   size_t cLitSizeEstimate = HUF_estimateCompressedSize((const HUF_CElt*)huf->CTable, countWksp, maxSymbolValue);\n            if (writeEntropy) cLitSizeEstimate += hufMetadata->hufDesSize;\n            return cLitSizeEstimate + literalSectionHeaderSize;\n    }   }\n    assert(0);  \n    return 0;\n}\n\nstatic size_t ZSTD_estimateSubBlockSize_symbolType(symbolEncodingType_e type,\n                        const BYTE* codeTable, unsigned maxCode,\n                        size_t nbSeq, const FSE_CTable* fseCTable,\n                        const U8* additionalBits,\n                        short const* defaultNorm, U32 defaultNormLog, U32 defaultMax,\n                        void* workspace, size_t wkspSize)\n{\n    unsigned* const countWksp = (unsigned*)workspace;\n    const BYTE* ctp = codeTable;\n    const BYTE* const ctStart = ctp;\n    const BYTE* const ctEnd = ctStart + nbSeq;\n    size_t cSymbolTypeSizeEstimateInBits = 0;\n    unsigned max = maxCode;\n\n    HIST_countFast_wksp(countWksp, &max, codeTable, nbSeq, workspace, wkspSize);   \n    if (type == set_basic) {\n         \n        assert(max <= defaultMax);\n        cSymbolTypeSizeEstimateInBits = max <= defaultMax\n                ? ZSTD_crossEntropyCost(defaultNorm, defaultNormLog, countWksp, max)\n                : ERROR(GENERIC);\n    } else if (type == set_rle) {\n        cSymbolTypeSizeEstimateInBits = 0;\n    } else if (type == set_compressed || type == set_repeat) {\n        cSymbolTypeSizeEstimateInBits = ZSTD_fseBitCost(fseCTable, countWksp, max);\n    }\n    if (ZSTD_isError(cSymbolTypeSizeEstimateInBits)) return nbSeq * 10;\n    while (ctp < ctEnd) {\n        if (additionalBits) cSymbolTypeSizeEstimateInBits += additionalBits[*ctp];\n        else cSymbolTypeSizeEstimateInBits += *ctp;  \n        ctp++;\n    }\n    return cSymbolTypeSizeEstimateInBits / 8;\n}\n\nstatic size_t ZSTD_estimateSubBlockSize_sequences(const BYTE* ofCodeTable,\n                                                  const BYTE* llCodeTable,\n                                                  const BYTE* mlCodeTable,\n                                                  size_t nbSeq,\n                                                  const ZSTD_fseCTables_t* fseTables,\n                                                  const ZSTD_fseCTablesMetadata_t* fseMetadata,\n                                                  void* workspace, size_t wkspSize,\n                                                  int writeEntropy)\n{\n    size_t const sequencesSectionHeaderSize = 3;  \n    size_t cSeqSizeEstimate = 0;\n    if (nbSeq == 0) return sequencesSectionHeaderSize;\n    cSeqSizeEstimate += ZSTD_estimateSubBlockSize_symbolType(fseMetadata->ofType, ofCodeTable, MaxOff,\n                                         nbSeq, fseTables->offcodeCTable, NULL,\n                                         OF_defaultNorm, OF_defaultNormLog, DefaultMaxOff,\n                                         workspace, wkspSize);\n    cSeqSizeEstimate += ZSTD_estimateSubBlockSize_symbolType(fseMetadata->llType, llCodeTable, MaxLL,\n                                         nbSeq, fseTables->litlengthCTable, LL_bits,\n                                         LL_defaultNorm, LL_defaultNormLog, MaxLL,\n                                         workspace, wkspSize);\n    cSeqSizeEstimate += ZSTD_estimateSubBlockSize_symbolType(fseMetadata->mlType, mlCodeTable, MaxML,\n                                         nbSeq, fseTables->matchlengthCTable, ML_bits,\n                                         ML_defaultNorm, ML_defaultNormLog, MaxML,\n                                         workspace, wkspSize);\n    if (writeEntropy) cSeqSizeEstimate += fseMetadata->fseTablesSize;\n    return cSeqSizeEstimate + sequencesSectionHeaderSize;\n}\n\nstatic size_t ZSTD_estimateSubBlockSize(const BYTE* literals, size_t litSize,\n                                        const BYTE* ofCodeTable,\n                                        const BYTE* llCodeTable,\n                                        const BYTE* mlCodeTable,\n                                        size_t nbSeq,\n                                        const ZSTD_entropyCTables_t* entropy,\n                                        const ZSTD_entropyCTablesMetadata_t* entropyMetadata,\n                                        void* workspace, size_t wkspSize,\n                                        int writeLitEntropy, int writeSeqEntropy) {\n    size_t cSizeEstimate = 0;\n    cSizeEstimate += ZSTD_estimateSubBlockSize_literal(literals, litSize,\n                                                         &entropy->huf, &entropyMetadata->hufMetadata,\n                                                         workspace, wkspSize, writeLitEntropy);\n    cSizeEstimate += ZSTD_estimateSubBlockSize_sequences(ofCodeTable, llCodeTable, mlCodeTable,\n                                                         nbSeq, &entropy->fse, &entropyMetadata->fseMetadata,\n                                                         workspace, wkspSize, writeSeqEntropy);\n    return cSizeEstimate + ZSTD_blockHeaderSize;\n}\n\nstatic int ZSTD_needSequenceEntropyTables(ZSTD_fseCTablesMetadata_t const* fseMetadata)\n{\n    if (fseMetadata->llType == set_compressed || fseMetadata->llType == set_rle)\n        return 1;\n    if (fseMetadata->mlType == set_compressed || fseMetadata->mlType == set_rle)\n        return 1;\n    if (fseMetadata->ofType == set_compressed || fseMetadata->ofType == set_rle)\n        return 1;\n    return 0;\n}\n\n \nstatic size_t ZSTD_compressSubBlock_multi(const seqStore_t* seqStorePtr,\n                            const ZSTD_compressedBlockState_t* prevCBlock,\n                            ZSTD_compressedBlockState_t* nextCBlock,\n                            const ZSTD_entropyCTablesMetadata_t* entropyMetadata,\n                            const ZSTD_CCtx_params* cctxParams,\n                                  void* dst, size_t dstCapacity,\n                            const void* src, size_t srcSize,\n                            const int bmi2, U32 lastBlock,\n                            void* workspace, size_t wkspSize)\n{\n    const seqDef* const sstart = seqStorePtr->sequencesStart;\n    const seqDef* const send = seqStorePtr->sequences;\n    const seqDef* sp = sstart;\n    const BYTE* const lstart = seqStorePtr->litStart;\n    const BYTE* const lend = seqStorePtr->lit;\n    const BYTE* lp = lstart;\n    BYTE const* ip = (BYTE const*)src;\n    BYTE const* const iend = ip + srcSize;\n    BYTE* const ostart = (BYTE*)dst;\n    BYTE* const oend = ostart + dstCapacity;\n    BYTE* op = ostart;\n    const BYTE* llCodePtr = seqStorePtr->llCode;\n    const BYTE* mlCodePtr = seqStorePtr->mlCode;\n    const BYTE* ofCodePtr = seqStorePtr->ofCode;\n    size_t targetCBlockSize = cctxParams->targetCBlockSize;\n    size_t litSize, seqCount;\n    int writeLitEntropy = entropyMetadata->hufMetadata.hType == set_compressed;\n    int writeSeqEntropy = 1;\n    int lastSequence = 0;\n\n    DEBUGLOG(5, \"ZSTD_compressSubBlock_multi (litSize=%u, nbSeq=%u)\",\n                (unsigned)(lend-lp), (unsigned)(send-sstart));\n\n    litSize = 0;\n    seqCount = 0;\n    do {\n        size_t cBlockSizeEstimate = 0;\n        if (sstart == send) {\n            lastSequence = 1;\n        } else {\n            const seqDef* const sequence = sp + seqCount;\n            lastSequence = sequence == send - 1;\n            litSize += ZSTD_getSequenceLength(seqStorePtr, sequence).litLength;\n            seqCount++;\n        }\n        if (lastSequence) {\n            assert(lp <= lend);\n            assert(litSize <= (size_t)(lend - lp));\n            litSize = (size_t)(lend - lp);\n        }\n         \n        cBlockSizeEstimate = ZSTD_estimateSubBlockSize(lp, litSize, ofCodePtr, llCodePtr, mlCodePtr, seqCount,\n                                                       &nextCBlock->entropy, entropyMetadata,\n                                                       workspace, wkspSize, writeLitEntropy, writeSeqEntropy);\n        if (cBlockSizeEstimate > targetCBlockSize || lastSequence) {\n            int litEntropyWritten = 0;\n            int seqEntropyWritten = 0;\n            const size_t decompressedSize = ZSTD_seqDecompressedSize(seqStorePtr, sp, seqCount, litSize, lastSequence);\n            const size_t cSize = ZSTD_compressSubBlock(&nextCBlock->entropy, entropyMetadata,\n                                                       sp, seqCount,\n                                                       lp, litSize,\n                                                       llCodePtr, mlCodePtr, ofCodePtr,\n                                                       cctxParams,\n                                                       op, oend-op,\n                                                       bmi2, writeLitEntropy, writeSeqEntropy,\n                                                       &litEntropyWritten, &seqEntropyWritten,\n                                                       lastBlock && lastSequence);\n            FORWARD_IF_ERROR(cSize, \"ZSTD_compressSubBlock failed\");\n            if (cSize > 0 && cSize < decompressedSize) {\n                DEBUGLOG(5, \"Committed the sub-block\");\n                assert(ip + decompressedSize <= iend);\n                ip += decompressedSize;\n                sp += seqCount;\n                lp += litSize;\n                op += cSize;\n                llCodePtr += seqCount;\n                mlCodePtr += seqCount;\n                ofCodePtr += seqCount;\n                litSize = 0;\n                seqCount = 0;\n                 \n                if (litEntropyWritten) {\n                    writeLitEntropy = 0;\n                }\n                if (seqEntropyWritten) {\n                    writeSeqEntropy = 0;\n                }\n            }\n        }\n    } while (!lastSequence);\n    if (writeLitEntropy) {\n        DEBUGLOG(5, \"ZSTD_compressSubBlock_multi has literal entropy tables unwritten\");\n        ZSTD_memcpy(&nextCBlock->entropy.huf, &prevCBlock->entropy.huf, sizeof(prevCBlock->entropy.huf));\n    }\n    if (writeSeqEntropy && ZSTD_needSequenceEntropyTables(&entropyMetadata->fseMetadata)) {\n         \n        DEBUGLOG(5, \"ZSTD_compressSubBlock_multi has sequence entropy tables unwritten\");\n        return 0;\n    }\n    if (ip < iend) {\n        size_t const cSize = ZSTD_noCompressBlock(op, oend - op, ip, iend - ip, lastBlock);\n        DEBUGLOG(5, \"ZSTD_compressSubBlock_multi last sub-block uncompressed, %zu bytes\", (size_t)(iend - ip));\n        FORWARD_IF_ERROR(cSize, \"ZSTD_noCompressBlock failed\");\n        assert(cSize != 0);\n        op += cSize;\n         \n        if (sp < send) {\n            seqDef const* seq;\n            repcodes_t rep;\n            ZSTD_memcpy(&rep, prevCBlock->rep, sizeof(rep));\n            for (seq = sstart; seq < sp; ++seq) {\n                ZSTD_updateRep(rep.rep, seq->offBase - 1, ZSTD_getSequenceLength(seqStorePtr, seq).litLength == 0);\n            }\n            ZSTD_memcpy(nextCBlock->rep, &rep, sizeof(rep));\n        }\n    }\n    DEBUGLOG(5, \"ZSTD_compressSubBlock_multi compressed\");\n    return op-ostart;\n}\n\nsize_t ZSTD_compressSuperBlock(ZSTD_CCtx* zc,\n                               void* dst, size_t dstCapacity,\n                               void const* src, size_t srcSize,\n                               unsigned lastBlock) {\n    ZSTD_entropyCTablesMetadata_t entropyMetadata;\n\n    FORWARD_IF_ERROR(ZSTD_buildBlockEntropyStats(&zc->seqStore,\n          &zc->blockState.prevCBlock->entropy,\n          &zc->blockState.nextCBlock->entropy,\n          &zc->appliedParams,\n          &entropyMetadata,\n          zc->entropyWorkspace, ENTROPY_WORKSPACE_SIZE  ), \"\");\n\n    return ZSTD_compressSubBlock_multi(&zc->seqStore,\n            zc->blockState.prevCBlock,\n            zc->blockState.nextCBlock,\n            &entropyMetadata,\n            &zc->appliedParams,\n            dst, dstCapacity,\n            src, srcSize,\n            zc->bmi2, lastBlock,\n            zc->entropyWorkspace, ENTROPY_WORKSPACE_SIZE  );\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}