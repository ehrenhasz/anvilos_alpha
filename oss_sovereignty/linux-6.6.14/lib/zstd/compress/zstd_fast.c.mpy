{
  "module_name": "zstd_fast.c",
  "hash_id": "978399e9b403537abe324c6fdfa76a2259281368a7f4fa59c7ce73321762108e",
  "original_prompt": "Ingested from linux-6.6.14/lib/zstd/compress/zstd_fast.c",
  "human_readable_source": " \n\n#include \"zstd_compress_internal.h\"   \n#include \"zstd_fast.h\"\n\n\nvoid ZSTD_fillHashTable(ZSTD_matchState_t* ms,\n                        const void* const end,\n                        ZSTD_dictTableLoadMethod_e dtlm)\n{\n    const ZSTD_compressionParameters* const cParams = &ms->cParams;\n    U32* const hashTable = ms->hashTable;\n    U32  const hBits = cParams->hashLog;\n    U32  const mls = cParams->minMatch;\n    const BYTE* const base = ms->window.base;\n    const BYTE* ip = base + ms->nextToUpdate;\n    const BYTE* const iend = ((const BYTE*)end) - HASH_READ_SIZE;\n    const U32 fastHashFillStep = 3;\n\n     \n    for ( ; ip + fastHashFillStep < iend + 2; ip += fastHashFillStep) {\n        U32 const curr = (U32)(ip - base);\n        size_t const hash0 = ZSTD_hashPtr(ip, hBits, mls);\n        hashTable[hash0] = curr;\n        if (dtlm == ZSTD_dtlm_fast) continue;\n         \n        {   U32 p;\n            for (p = 1; p < fastHashFillStep; ++p) {\n                size_t const hash = ZSTD_hashPtr(ip + p, hBits, mls);\n                if (hashTable[hash] == 0) {   \n                    hashTable[hash] = curr + p;\n    }   }   }   }\n}\n\n\n \nFORCE_INLINE_TEMPLATE size_t\nZSTD_compressBlock_fast_noDict_generic(\n        ZSTD_matchState_t* ms, seqStore_t* seqStore, U32 rep[ZSTD_REP_NUM],\n        void const* src, size_t srcSize,\n        U32 const mls, U32 const hasStep)\n{\n    const ZSTD_compressionParameters* const cParams = &ms->cParams;\n    U32* const hashTable = ms->hashTable;\n    U32 const hlog = cParams->hashLog;\n     \n    size_t const stepSize = hasStep ? (cParams->targetLength + !(cParams->targetLength) + 1) : 2;\n    const BYTE* const base = ms->window.base;\n    const BYTE* const istart = (const BYTE*)src;\n    const U32   endIndex = (U32)((size_t)(istart - base) + srcSize);\n    const U32   prefixStartIndex = ZSTD_getLowestPrefixIndex(ms, endIndex, cParams->windowLog);\n    const BYTE* const prefixStart = base + prefixStartIndex;\n    const BYTE* const iend = istart + srcSize;\n    const BYTE* const ilimit = iend - HASH_READ_SIZE;\n\n    const BYTE* anchor = istart;\n    const BYTE* ip0 = istart;\n    const BYTE* ip1;\n    const BYTE* ip2;\n    const BYTE* ip3;\n    U32 current0;\n\n    U32 rep_offset1 = rep[0];\n    U32 rep_offset2 = rep[1];\n    U32 offsetSaved = 0;\n\n    size_t hash0;  \n    size_t hash1;  \n    U32 idx;  \n    U32 mval;  \n\n    U32 offcode;\n    const BYTE* match0;\n    size_t mLength;\n\n     \n    size_t step;\n    const BYTE* nextStep;\n    const size_t kStepIncr = (1 << (kSearchStrength - 1));\n\n    DEBUGLOG(5, \"ZSTD_compressBlock_fast_generic\");\n    ip0 += (ip0 == prefixStart);\n    {   U32 const curr = (U32)(ip0 - base);\n        U32 const windowLow = ZSTD_getLowestPrefixIndex(ms, curr, cParams->windowLog);\n        U32 const maxRep = curr - windowLow;\n        if (rep_offset2 > maxRep) offsetSaved = rep_offset2, rep_offset2 = 0;\n        if (rep_offset1 > maxRep) offsetSaved = rep_offset1, rep_offset1 = 0;\n    }\n\n     \n_start:  \n\n    step = stepSize;\n    nextStep = ip0 + kStepIncr;\n\n     \n    ip1 = ip0 + 1;\n    ip2 = ip0 + step;\n    ip3 = ip2 + 1;\n\n    if (ip3 >= ilimit) {\n        goto _cleanup;\n    }\n\n    hash0 = ZSTD_hashPtr(ip0, hlog, mls);\n    hash1 = ZSTD_hashPtr(ip1, hlog, mls);\n\n    idx = hashTable[hash0];\n\n    do {\n         \n        const U32 rval = MEM_read32(ip2 - rep_offset1);\n\n         \n        current0 = (U32)(ip0 - base);\n        hashTable[hash0] = current0;\n\n         \n        if ((MEM_read32(ip2) == rval) & (rep_offset1 > 0)) {\n            ip0 = ip2;\n            match0 = ip0 - rep_offset1;\n            mLength = ip0[-1] == match0[-1];\n            ip0 -= mLength;\n            match0 -= mLength;\n            offcode = STORE_REPCODE_1;\n            mLength += 4;\n            goto _match;\n        }\n\n         \n        if (idx >= prefixStartIndex) {\n            mval = MEM_read32(base + idx);\n        } else {\n            mval = MEM_read32(ip0) ^ 1;  \n        }\n\n         \n        if (MEM_read32(ip0) == mval) {\n             \n            goto _offset;\n        }\n\n         \n        idx = hashTable[hash1];\n\n         \n        hash0 = hash1;\n        hash1 = ZSTD_hashPtr(ip2, hlog, mls);\n\n         \n        ip0 = ip1;\n        ip1 = ip2;\n        ip2 = ip3;\n\n         \n        current0 = (U32)(ip0 - base);\n        hashTable[hash0] = current0;\n\n         \n        if (idx >= prefixStartIndex) {\n            mval = MEM_read32(base + idx);\n        } else {\n            mval = MEM_read32(ip0) ^ 1;  \n        }\n\n         \n        if (MEM_read32(ip0) == mval) {\n             \n            goto _offset;\n        }\n\n         \n        idx = hashTable[hash1];\n\n         \n        hash0 = hash1;\n        hash1 = ZSTD_hashPtr(ip2, hlog, mls);\n\n         \n        ip0 = ip1;\n        ip1 = ip2;\n        ip2 = ip0 + step;\n        ip3 = ip1 + step;\n\n         \n        if (ip2 >= nextStep) {\n            step++;\n            PREFETCH_L1(ip1 + 64);\n            PREFETCH_L1(ip1 + 128);\n            nextStep += kStepIncr;\n        }\n    } while (ip3 < ilimit);\n\n_cleanup:\n     \n\n     \n    rep[0] = rep_offset1 ? rep_offset1 : offsetSaved;\n    rep[1] = rep_offset2 ? rep_offset2 : offsetSaved;\n\n     \n    return (size_t)(iend - anchor);\n\n_offset:  \n\n     \n    match0 = base + idx;\n    rep_offset2 = rep_offset1;\n    rep_offset1 = (U32)(ip0-match0);\n    offcode = STORE_OFFSET(rep_offset1);\n    mLength = 4;\n\n     \n    while (((ip0>anchor) & (match0>prefixStart)) && (ip0[-1] == match0[-1])) {\n        ip0--;\n        match0--;\n        mLength++;\n    }\n\n_match:  \n\n     \n    mLength += ZSTD_count(ip0 + mLength, match0 + mLength, iend);\n\n    ZSTD_storeSeq(seqStore, (size_t)(ip0 - anchor), anchor, iend, offcode, mLength);\n\n    ip0 += mLength;\n    anchor = ip0;\n\n     \n    if (ip1 < ip0) {\n        hashTable[hash1] = (U32)(ip1 - base);\n    }\n\n     \n    if (ip0 <= ilimit) {\n         \n        assert(base+current0+2 > istart);   \n        hashTable[ZSTD_hashPtr(base+current0+2, hlog, mls)] = current0+2;   \n        hashTable[ZSTD_hashPtr(ip0-2, hlog, mls)] = (U32)(ip0-2-base);\n\n        if (rep_offset2 > 0) {  \n            while ( (ip0 <= ilimit) && (MEM_read32(ip0) == MEM_read32(ip0 - rep_offset2)) ) {\n                 \n                size_t const rLength = ZSTD_count(ip0+4, ip0+4-rep_offset2, iend) + 4;\n                { U32 const tmpOff = rep_offset2; rep_offset2 = rep_offset1; rep_offset1 = tmpOff; }  \n                hashTable[ZSTD_hashPtr(ip0, hlog, mls)] = (U32)(ip0-base);\n                ip0 += rLength;\n                ZSTD_storeSeq(seqStore, 0  , anchor, iend, STORE_REPCODE_1, rLength);\n                anchor = ip0;\n                continue;    \n    }   }   }\n\n    goto _start;\n}\n\n#define ZSTD_GEN_FAST_FN(dictMode, mls, step)                                                            \\\n    static size_t ZSTD_compressBlock_fast_##dictMode##_##mls##_##step(                                      \\\n            ZSTD_matchState_t* ms, seqStore_t* seqStore, U32 rep[ZSTD_REP_NUM],                    \\\n            void const* src, size_t srcSize)                                                       \\\n    {                                                                                              \\\n        return ZSTD_compressBlock_fast_##dictMode##_generic(ms, seqStore, rep, src, srcSize, mls, step); \\\n    }\n\nZSTD_GEN_FAST_FN(noDict, 4, 1)\nZSTD_GEN_FAST_FN(noDict, 5, 1)\nZSTD_GEN_FAST_FN(noDict, 6, 1)\nZSTD_GEN_FAST_FN(noDict, 7, 1)\n\nZSTD_GEN_FAST_FN(noDict, 4, 0)\nZSTD_GEN_FAST_FN(noDict, 5, 0)\nZSTD_GEN_FAST_FN(noDict, 6, 0)\nZSTD_GEN_FAST_FN(noDict, 7, 0)\n\nsize_t ZSTD_compressBlock_fast(\n        ZSTD_matchState_t* ms, seqStore_t* seqStore, U32 rep[ZSTD_REP_NUM],\n        void const* src, size_t srcSize)\n{\n    U32 const mls = ms->cParams.minMatch;\n    assert(ms->dictMatchState == NULL);\n    if (ms->cParams.targetLength > 1) {\n        switch(mls)\n        {\n        default:  \n        case 4 :\n            return ZSTD_compressBlock_fast_noDict_4_1(ms, seqStore, rep, src, srcSize);\n        case 5 :\n            return ZSTD_compressBlock_fast_noDict_5_1(ms, seqStore, rep, src, srcSize);\n        case 6 :\n            return ZSTD_compressBlock_fast_noDict_6_1(ms, seqStore, rep, src, srcSize);\n        case 7 :\n            return ZSTD_compressBlock_fast_noDict_7_1(ms, seqStore, rep, src, srcSize);\n        }\n    } else {\n        switch(mls)\n        {\n        default:  \n        case 4 :\n            return ZSTD_compressBlock_fast_noDict_4_0(ms, seqStore, rep, src, srcSize);\n        case 5 :\n            return ZSTD_compressBlock_fast_noDict_5_0(ms, seqStore, rep, src, srcSize);\n        case 6 :\n            return ZSTD_compressBlock_fast_noDict_6_0(ms, seqStore, rep, src, srcSize);\n        case 7 :\n            return ZSTD_compressBlock_fast_noDict_7_0(ms, seqStore, rep, src, srcSize);\n        }\n\n    }\n}\n\nFORCE_INLINE_TEMPLATE\nsize_t ZSTD_compressBlock_fast_dictMatchState_generic(\n        ZSTD_matchState_t* ms, seqStore_t* seqStore, U32 rep[ZSTD_REP_NUM],\n        void const* src, size_t srcSize, U32 const mls, U32 const hasStep)\n{\n    const ZSTD_compressionParameters* const cParams = &ms->cParams;\n    U32* const hashTable = ms->hashTable;\n    U32 const hlog = cParams->hashLog;\n     \n    U32 const stepSize = cParams->targetLength + !(cParams->targetLength);\n    const BYTE* const base = ms->window.base;\n    const BYTE* const istart = (const BYTE*)src;\n    const BYTE* ip = istart;\n    const BYTE* anchor = istart;\n    const U32   prefixStartIndex = ms->window.dictLimit;\n    const BYTE* const prefixStart = base + prefixStartIndex;\n    const BYTE* const iend = istart + srcSize;\n    const BYTE* const ilimit = iend - HASH_READ_SIZE;\n    U32 offset_1=rep[0], offset_2=rep[1];\n    U32 offsetSaved = 0;\n\n    const ZSTD_matchState_t* const dms = ms->dictMatchState;\n    const ZSTD_compressionParameters* const dictCParams = &dms->cParams ;\n    const U32* const dictHashTable = dms->hashTable;\n    const U32 dictStartIndex       = dms->window.dictLimit;\n    const BYTE* const dictBase     = dms->window.base;\n    const BYTE* const dictStart    = dictBase + dictStartIndex;\n    const BYTE* const dictEnd      = dms->window.nextSrc;\n    const U32 dictIndexDelta       = prefixStartIndex - (U32)(dictEnd - dictBase);\n    const U32 dictAndPrefixLength  = (U32)(ip - prefixStart + dictEnd - dictStart);\n    const U32 dictHLog             = dictCParams->hashLog;\n\n     \n    const U32 maxDistance = 1U << cParams->windowLog;\n    const U32 endIndex = (U32)((size_t)(ip - base) + srcSize);\n    assert(endIndex - prefixStartIndex <= maxDistance);\n    (void)maxDistance; (void)endIndex;    \n\n    (void)hasStep;  \n\n     \n    assert(prefixStartIndex >= (U32)(dictEnd - dictBase));\n\n     \n    DEBUGLOG(5, \"ZSTD_compressBlock_fast_dictMatchState_generic\");\n    ip += (dictAndPrefixLength == 0);\n     \n    assert(offset_1 <= dictAndPrefixLength);\n    assert(offset_2 <= dictAndPrefixLength);\n\n     \n    while (ip < ilimit) {    \n        size_t mLength;\n        size_t const h = ZSTD_hashPtr(ip, hlog, mls);\n        U32 const curr = (U32)(ip-base);\n        U32 const matchIndex = hashTable[h];\n        const BYTE* match = base + matchIndex;\n        const U32 repIndex = curr + 1 - offset_1;\n        const BYTE* repMatch = (repIndex < prefixStartIndex) ?\n                               dictBase + (repIndex - dictIndexDelta) :\n                               base + repIndex;\n        hashTable[h] = curr;    \n\n        if ( ((U32)((prefixStartIndex-1) - repIndex) >= 3)  \n          && (MEM_read32(repMatch) == MEM_read32(ip+1)) ) {\n            const BYTE* const repMatchEnd = repIndex < prefixStartIndex ? dictEnd : iend;\n            mLength = ZSTD_count_2segments(ip+1+4, repMatch+4, iend, repMatchEnd, prefixStart) + 4;\n            ip++;\n            ZSTD_storeSeq(seqStore, (size_t)(ip-anchor), anchor, iend, STORE_REPCODE_1, mLength);\n        } else if ( (matchIndex <= prefixStartIndex) ) {\n            size_t const dictHash = ZSTD_hashPtr(ip, dictHLog, mls);\n            U32 const dictMatchIndex = dictHashTable[dictHash];\n            const BYTE* dictMatch = dictBase + dictMatchIndex;\n            if (dictMatchIndex <= dictStartIndex ||\n                MEM_read32(dictMatch) != MEM_read32(ip)) {\n                assert(stepSize >= 1);\n                ip += ((ip-anchor) >> kSearchStrength) + stepSize;\n                continue;\n            } else {\n                 \n                U32 const offset = (U32)(curr-dictMatchIndex-dictIndexDelta);\n                mLength = ZSTD_count_2segments(ip+4, dictMatch+4, iend, dictEnd, prefixStart) + 4;\n                while (((ip>anchor) & (dictMatch>dictStart))\n                     && (ip[-1] == dictMatch[-1])) {\n                    ip--; dictMatch--; mLength++;\n                }  \n                offset_2 = offset_1;\n                offset_1 = offset;\n                ZSTD_storeSeq(seqStore, (size_t)(ip-anchor), anchor, iend, STORE_OFFSET(offset), mLength);\n            }\n        } else if (MEM_read32(match) != MEM_read32(ip)) {\n             \n            assert(stepSize >= 1);\n            ip += ((ip-anchor) >> kSearchStrength) + stepSize;\n            continue;\n        } else {\n             \n            U32 const offset = (U32)(ip-match);\n            mLength = ZSTD_count(ip+4, match+4, iend) + 4;\n            while (((ip>anchor) & (match>prefixStart))\n                 && (ip[-1] == match[-1])) { ip--; match--; mLength++; }  \n            offset_2 = offset_1;\n            offset_1 = offset;\n            ZSTD_storeSeq(seqStore, (size_t)(ip-anchor), anchor, iend, STORE_OFFSET(offset), mLength);\n        }\n\n         \n        ip += mLength;\n        anchor = ip;\n\n        if (ip <= ilimit) {\n             \n            assert(base+curr+2 > istart);   \n            hashTable[ZSTD_hashPtr(base+curr+2, hlog, mls)] = curr+2;   \n            hashTable[ZSTD_hashPtr(ip-2, hlog, mls)] = (U32)(ip-2-base);\n\n             \n            while (ip <= ilimit) {\n                U32 const current2 = (U32)(ip-base);\n                U32 const repIndex2 = current2 - offset_2;\n                const BYTE* repMatch2 = repIndex2 < prefixStartIndex ?\n                        dictBase - dictIndexDelta + repIndex2 :\n                        base + repIndex2;\n                if ( ((U32)((prefixStartIndex-1) - (U32)repIndex2) >= 3  )\n                   && (MEM_read32(repMatch2) == MEM_read32(ip)) ) {\n                    const BYTE* const repEnd2 = repIndex2 < prefixStartIndex ? dictEnd : iend;\n                    size_t const repLength2 = ZSTD_count_2segments(ip+4, repMatch2+4, iend, repEnd2, prefixStart) + 4;\n                    U32 tmpOffset = offset_2; offset_2 = offset_1; offset_1 = tmpOffset;    \n                    ZSTD_storeSeq(seqStore, 0, anchor, iend, STORE_REPCODE_1, repLength2);\n                    hashTable[ZSTD_hashPtr(ip, hlog, mls)] = current2;\n                    ip += repLength2;\n                    anchor = ip;\n                    continue;\n                }\n                break;\n            }\n        }\n    }\n\n     \n    rep[0] = offset_1 ? offset_1 : offsetSaved;\n    rep[1] = offset_2 ? offset_2 : offsetSaved;\n\n     \n    return (size_t)(iend - anchor);\n}\n\n\nZSTD_GEN_FAST_FN(dictMatchState, 4, 0)\nZSTD_GEN_FAST_FN(dictMatchState, 5, 0)\nZSTD_GEN_FAST_FN(dictMatchState, 6, 0)\nZSTD_GEN_FAST_FN(dictMatchState, 7, 0)\n\nsize_t ZSTD_compressBlock_fast_dictMatchState(\n        ZSTD_matchState_t* ms, seqStore_t* seqStore, U32 rep[ZSTD_REP_NUM],\n        void const* src, size_t srcSize)\n{\n    U32 const mls = ms->cParams.minMatch;\n    assert(ms->dictMatchState != NULL);\n    switch(mls)\n    {\n    default:  \n    case 4 :\n        return ZSTD_compressBlock_fast_dictMatchState_4_0(ms, seqStore, rep, src, srcSize);\n    case 5 :\n        return ZSTD_compressBlock_fast_dictMatchState_5_0(ms, seqStore, rep, src, srcSize);\n    case 6 :\n        return ZSTD_compressBlock_fast_dictMatchState_6_0(ms, seqStore, rep, src, srcSize);\n    case 7 :\n        return ZSTD_compressBlock_fast_dictMatchState_7_0(ms, seqStore, rep, src, srcSize);\n    }\n}\n\n\nstatic size_t ZSTD_compressBlock_fast_extDict_generic(\n        ZSTD_matchState_t* ms, seqStore_t* seqStore, U32 rep[ZSTD_REP_NUM],\n        void const* src, size_t srcSize, U32 const mls, U32 const hasStep)\n{\n    const ZSTD_compressionParameters* const cParams = &ms->cParams;\n    U32* const hashTable = ms->hashTable;\n    U32 const hlog = cParams->hashLog;\n     \n    U32 const stepSize = cParams->targetLength + !(cParams->targetLength);\n    const BYTE* const base = ms->window.base;\n    const BYTE* const dictBase = ms->window.dictBase;\n    const BYTE* const istart = (const BYTE*)src;\n    const BYTE* ip = istart;\n    const BYTE* anchor = istart;\n    const U32   endIndex = (U32)((size_t)(istart - base) + srcSize);\n    const U32   lowLimit = ZSTD_getLowestMatchIndex(ms, endIndex, cParams->windowLog);\n    const U32   dictStartIndex = lowLimit;\n    const BYTE* const dictStart = dictBase + dictStartIndex;\n    const U32   dictLimit = ms->window.dictLimit;\n    const U32   prefixStartIndex = dictLimit < lowLimit ? lowLimit : dictLimit;\n    const BYTE* const prefixStart = base + prefixStartIndex;\n    const BYTE* const dictEnd = dictBase + prefixStartIndex;\n    const BYTE* const iend = istart + srcSize;\n    const BYTE* const ilimit = iend - 8;\n    U32 offset_1=rep[0], offset_2=rep[1];\n\n    (void)hasStep;  \n\n    DEBUGLOG(5, \"ZSTD_compressBlock_fast_extDict_generic (offset_1=%u)\", offset_1);\n\n     \n    if (prefixStartIndex == dictStartIndex)\n        return ZSTD_compressBlock_fast(ms, seqStore, rep, src, srcSize);\n\n     \n    while (ip < ilimit) {   \n        const size_t h = ZSTD_hashPtr(ip, hlog, mls);\n        const U32    matchIndex = hashTable[h];\n        const BYTE* const matchBase = matchIndex < prefixStartIndex ? dictBase : base;\n        const BYTE*  match = matchBase + matchIndex;\n        const U32    curr = (U32)(ip-base);\n        const U32    repIndex = curr + 1 - offset_1;\n        const BYTE* const repBase = repIndex < prefixStartIndex ? dictBase : base;\n        const BYTE* const repMatch = repBase + repIndex;\n        hashTable[h] = curr;    \n        DEBUGLOG(7, \"offset_1 = %u , curr = %u\", offset_1, curr);\n\n        if ( ( ((U32)((prefixStartIndex-1) - repIndex) >= 3)  \n             & (offset_1 <= curr+1 - dictStartIndex) )  \n           && (MEM_read32(repMatch) == MEM_read32(ip+1)) ) {\n            const BYTE* const repMatchEnd = repIndex < prefixStartIndex ? dictEnd : iend;\n            size_t const rLength = ZSTD_count_2segments(ip+1 +4, repMatch +4, iend, repMatchEnd, prefixStart) + 4;\n            ip++;\n            ZSTD_storeSeq(seqStore, (size_t)(ip-anchor), anchor, iend, STORE_REPCODE_1, rLength);\n            ip += rLength;\n            anchor = ip;\n        } else {\n            if ( (matchIndex < dictStartIndex) ||\n                 (MEM_read32(match) != MEM_read32(ip)) ) {\n                assert(stepSize >= 1);\n                ip += ((ip-anchor) >> kSearchStrength) + stepSize;\n                continue;\n            }\n            {   const BYTE* const matchEnd = matchIndex < prefixStartIndex ? dictEnd : iend;\n                const BYTE* const lowMatchPtr = matchIndex < prefixStartIndex ? dictStart : prefixStart;\n                U32 const offset = curr - matchIndex;\n                size_t mLength = ZSTD_count_2segments(ip+4, match+4, iend, matchEnd, prefixStart) + 4;\n                while (((ip>anchor) & (match>lowMatchPtr)) && (ip[-1] == match[-1])) { ip--; match--; mLength++; }    \n                offset_2 = offset_1; offset_1 = offset;   \n                ZSTD_storeSeq(seqStore, (size_t)(ip-anchor), anchor, iend, STORE_OFFSET(offset), mLength);\n                ip += mLength;\n                anchor = ip;\n        }   }\n\n        if (ip <= ilimit) {\n             \n            hashTable[ZSTD_hashPtr(base+curr+2, hlog, mls)] = curr+2;\n            hashTable[ZSTD_hashPtr(ip-2, hlog, mls)] = (U32)(ip-2-base);\n             \n            while (ip <= ilimit) {\n                U32 const current2 = (U32)(ip-base);\n                U32 const repIndex2 = current2 - offset_2;\n                const BYTE* const repMatch2 = repIndex2 < prefixStartIndex ? dictBase + repIndex2 : base + repIndex2;\n                if ( (((U32)((prefixStartIndex-1) - repIndex2) >= 3) & (offset_2 <= curr - dictStartIndex))   \n                   && (MEM_read32(repMatch2) == MEM_read32(ip)) ) {\n                    const BYTE* const repEnd2 = repIndex2 < prefixStartIndex ? dictEnd : iend;\n                    size_t const repLength2 = ZSTD_count_2segments(ip+4, repMatch2+4, iend, repEnd2, prefixStart) + 4;\n                    { U32 const tmpOffset = offset_2; offset_2 = offset_1; offset_1 = tmpOffset; }   \n                    ZSTD_storeSeq(seqStore, 0  , anchor, iend, STORE_REPCODE_1, repLength2);\n                    hashTable[ZSTD_hashPtr(ip, hlog, mls)] = current2;\n                    ip += repLength2;\n                    anchor = ip;\n                    continue;\n                }\n                break;\n    }   }   }\n\n     \n    rep[0] = offset_1;\n    rep[1] = offset_2;\n\n     \n    return (size_t)(iend - anchor);\n}\n\nZSTD_GEN_FAST_FN(extDict, 4, 0)\nZSTD_GEN_FAST_FN(extDict, 5, 0)\nZSTD_GEN_FAST_FN(extDict, 6, 0)\nZSTD_GEN_FAST_FN(extDict, 7, 0)\n\nsize_t ZSTD_compressBlock_fast_extDict(\n        ZSTD_matchState_t* ms, seqStore_t* seqStore, U32 rep[ZSTD_REP_NUM],\n        void const* src, size_t srcSize)\n{\n    U32 const mls = ms->cParams.minMatch;\n    switch(mls)\n    {\n    default:  \n    case 4 :\n        return ZSTD_compressBlock_fast_extDict_4_0(ms, seqStore, rep, src, srcSize);\n    case 5 :\n        return ZSTD_compressBlock_fast_extDict_5_0(ms, seqStore, rep, src, srcSize);\n    case 6 :\n        return ZSTD_compressBlock_fast_extDict_6_0(ms, seqStore, rep, src, srcSize);\n    case 7 :\n        return ZSTD_compressBlock_fast_extDict_7_0(ms, seqStore, rep, src, srcSize);\n    }\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}