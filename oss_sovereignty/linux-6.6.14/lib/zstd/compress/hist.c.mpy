{
  "module_name": "hist.c",
  "hash_id": "a497b0efe2109672c42b21cc9d9f4f15ba79728359b6b0432444afac24173b4c",
  "original_prompt": "Ingested from linux-6.6.14/lib/zstd/compress/hist.c",
  "human_readable_source": " \n\n \n#include \"../common/mem.h\"              \n#include \"../common/debug.h\"            \n#include \"../common/error_private.h\"    \n#include \"hist.h\"\n\n\n \nunsigned HIST_isError(size_t code) { return ERR_isError(code); }\n\n \nunsigned HIST_count_simple(unsigned* count, unsigned* maxSymbolValuePtr,\n                           const void* src, size_t srcSize)\n{\n    const BYTE* ip = (const BYTE*)src;\n    const BYTE* const end = ip + srcSize;\n    unsigned maxSymbolValue = *maxSymbolValuePtr;\n    unsigned largestCount=0;\n\n    ZSTD_memset(count, 0, (maxSymbolValue+1) * sizeof(*count));\n    if (srcSize==0) { *maxSymbolValuePtr = 0; return 0; }\n\n    while (ip<end) {\n        assert(*ip <= maxSymbolValue);\n        count[*ip++]++;\n    }\n\n    while (!count[maxSymbolValue]) maxSymbolValue--;\n    *maxSymbolValuePtr = maxSymbolValue;\n\n    {   U32 s;\n        for (s=0; s<=maxSymbolValue; s++)\n            if (count[s] > largestCount) largestCount = count[s];\n    }\n\n    return largestCount;\n}\n\ntypedef enum { trustInput, checkMaxSymbolValue } HIST_checkInput_e;\n\n \nstatic size_t HIST_count_parallel_wksp(\n                                unsigned* count, unsigned* maxSymbolValuePtr,\n                                const void* source, size_t sourceSize,\n                                HIST_checkInput_e check,\n                                U32* const workSpace)\n{\n    const BYTE* ip = (const BYTE*)source;\n    const BYTE* const iend = ip+sourceSize;\n    size_t const countSize = (*maxSymbolValuePtr + 1) * sizeof(*count);\n    unsigned max=0;\n    U32* const Counting1 = workSpace;\n    U32* const Counting2 = Counting1 + 256;\n    U32* const Counting3 = Counting2 + 256;\n    U32* const Counting4 = Counting3 + 256;\n\n     \n    assert(*maxSymbolValuePtr <= 255);\n    if (!sourceSize) {\n        ZSTD_memset(count, 0, countSize);\n        *maxSymbolValuePtr = 0;\n        return 0;\n    }\n    ZSTD_memset(workSpace, 0, 4*256*sizeof(unsigned));\n\n     \n    {   U32 cached = MEM_read32(ip); ip += 4;\n        while (ip < iend-15) {\n            U32 c = cached; cached = MEM_read32(ip); ip += 4;\n            Counting1[(BYTE) c     ]++;\n            Counting2[(BYTE)(c>>8) ]++;\n            Counting3[(BYTE)(c>>16)]++;\n            Counting4[       c>>24 ]++;\n            c = cached; cached = MEM_read32(ip); ip += 4;\n            Counting1[(BYTE) c     ]++;\n            Counting2[(BYTE)(c>>8) ]++;\n            Counting3[(BYTE)(c>>16)]++;\n            Counting4[       c>>24 ]++;\n            c = cached; cached = MEM_read32(ip); ip += 4;\n            Counting1[(BYTE) c     ]++;\n            Counting2[(BYTE)(c>>8) ]++;\n            Counting3[(BYTE)(c>>16)]++;\n            Counting4[       c>>24 ]++;\n            c = cached; cached = MEM_read32(ip); ip += 4;\n            Counting1[(BYTE) c     ]++;\n            Counting2[(BYTE)(c>>8) ]++;\n            Counting3[(BYTE)(c>>16)]++;\n            Counting4[       c>>24 ]++;\n        }\n        ip-=4;\n    }\n\n     \n    while (ip<iend) Counting1[*ip++]++;\n\n    {   U32 s;\n        for (s=0; s<256; s++) {\n            Counting1[s] += Counting2[s] + Counting3[s] + Counting4[s];\n            if (Counting1[s] > max) max = Counting1[s];\n    }   }\n\n    {   unsigned maxSymbolValue = 255;\n        while (!Counting1[maxSymbolValue]) maxSymbolValue--;\n        if (check && maxSymbolValue > *maxSymbolValuePtr) return ERROR(maxSymbolValue_tooSmall);\n        *maxSymbolValuePtr = maxSymbolValue;\n        ZSTD_memmove(count, Counting1, countSize);    \n    }\n    return (size_t)max;\n}\n\n \nsize_t HIST_countFast_wksp(unsigned* count, unsigned* maxSymbolValuePtr,\n                          const void* source, size_t sourceSize,\n                          void* workSpace, size_t workSpaceSize)\n{\n    if (sourceSize < 1500)  \n        return HIST_count_simple(count, maxSymbolValuePtr, source, sourceSize);\n    if ((size_t)workSpace & 3) return ERROR(GENERIC);   \n    if (workSpaceSize < HIST_WKSP_SIZE) return ERROR(workSpace_tooSmall);\n    return HIST_count_parallel_wksp(count, maxSymbolValuePtr, source, sourceSize, trustInput, (U32*)workSpace);\n}\n\n \nsize_t HIST_count_wksp(unsigned* count, unsigned* maxSymbolValuePtr,\n                       const void* source, size_t sourceSize,\n                       void* workSpace, size_t workSpaceSize)\n{\n    if ((size_t)workSpace & 3) return ERROR(GENERIC);   \n    if (workSpaceSize < HIST_WKSP_SIZE) return ERROR(workSpace_tooSmall);\n    if (*maxSymbolValuePtr < 255)\n        return HIST_count_parallel_wksp(count, maxSymbolValuePtr, source, sourceSize, checkMaxSymbolValue, (U32*)workSpace);\n    *maxSymbolValuePtr = 255;\n    return HIST_countFast_wksp(count, maxSymbolValuePtr, source, sourceSize, workSpace, workSpaceSize);\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}