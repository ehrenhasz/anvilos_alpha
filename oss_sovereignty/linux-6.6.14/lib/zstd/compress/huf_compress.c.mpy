{
  "module_name": "huf_compress.c",
  "hash_id": "65484039e955892a08681bc3bded458f584ed482db41251d9e78ffd268adfc28",
  "original_prompt": "Ingested from linux-6.6.14/lib/zstd/compress/huf_compress.c",
  "human_readable_source": " \n\n \n\n\n \n#include \"../common/zstd_deps.h\"      \n#include \"../common/compiler.h\"\n#include \"../common/bitstream.h\"\n#include \"hist.h\"\n#define FSE_STATIC_LINKING_ONLY    \n#include \"../common/fse.h\"         \n#define HUF_STATIC_LINKING_ONLY\n#include \"../common/huf.h\"\n#include \"../common/error_private.h\"\n\n\n \n#define HUF_isError ERR_isError\n#define HUF_STATIC_ASSERT(c) DEBUG_STATIC_ASSERT(c)    \n\n\n \nunsigned HUF_optimalTableLog(unsigned maxTableLog, size_t srcSize, unsigned maxSymbolValue)\n{\n    return FSE_optimalTableLog_internal(maxTableLog, srcSize, maxSymbolValue, 1);\n}\n\n\n \n#define HUF_WORKSPACE_MAX_ALIGNMENT 8\n\nstatic void* HUF_alignUpWorkspace(void* workspace, size_t* workspaceSizePtr, size_t align)\n{\n    size_t const mask = align - 1;\n    size_t const rem = (size_t)workspace & mask;\n    size_t const add = (align - rem) & mask;\n    BYTE* const aligned = (BYTE*)workspace + add;\n    assert((align & (align - 1)) == 0);  \n    assert(align <= HUF_WORKSPACE_MAX_ALIGNMENT);\n    if (*workspaceSizePtr >= add) {\n        assert(add < align);\n        assert(((size_t)aligned & mask) == 0);\n        *workspaceSizePtr -= add;\n        return aligned;\n    } else {\n        *workspaceSizePtr = 0;\n        return NULL;\n    }\n}\n\n\n \n#define MAX_FSE_TABLELOG_FOR_HUFF_HEADER 6\n\ntypedef struct {\n    FSE_CTable CTable[FSE_CTABLE_SIZE_U32(MAX_FSE_TABLELOG_FOR_HUFF_HEADER, HUF_TABLELOG_MAX)];\n    U32 scratchBuffer[FSE_BUILD_CTABLE_WORKSPACE_SIZE_U32(HUF_TABLELOG_MAX, MAX_FSE_TABLELOG_FOR_HUFF_HEADER)];\n    unsigned count[HUF_TABLELOG_MAX+1];\n    S16 norm[HUF_TABLELOG_MAX+1];\n} HUF_CompressWeightsWksp;\n\nstatic size_t HUF_compressWeights(void* dst, size_t dstSize, const void* weightTable, size_t wtSize, void* workspace, size_t workspaceSize)\n{\n    BYTE* const ostart = (BYTE*) dst;\n    BYTE* op = ostart;\n    BYTE* const oend = ostart + dstSize;\n\n    unsigned maxSymbolValue = HUF_TABLELOG_MAX;\n    U32 tableLog = MAX_FSE_TABLELOG_FOR_HUFF_HEADER;\n    HUF_CompressWeightsWksp* wksp = (HUF_CompressWeightsWksp*)HUF_alignUpWorkspace(workspace, &workspaceSize, ZSTD_ALIGNOF(U32));\n\n    if (workspaceSize < sizeof(HUF_CompressWeightsWksp)) return ERROR(GENERIC);\n\n     \n    if (wtSize <= 1) return 0;   \n\n     \n    {   unsigned const maxCount = HIST_count_simple(wksp->count, &maxSymbolValue, weightTable, wtSize);    \n        if (maxCount == wtSize) return 1;    \n        if (maxCount == 1) return 0;         \n    }\n\n    tableLog = FSE_optimalTableLog(tableLog, wtSize, maxSymbolValue);\n    CHECK_F( FSE_normalizeCount(wksp->norm, tableLog, wksp->count, wtSize, maxSymbolValue,   0) );\n\n     \n    {   CHECK_V_F(hSize, FSE_writeNCount(op, (size_t)(oend-op), wksp->norm, maxSymbolValue, tableLog) );\n        op += hSize;\n    }\n\n     \n    CHECK_F( FSE_buildCTable_wksp(wksp->CTable, wksp->norm, maxSymbolValue, tableLog, wksp->scratchBuffer, sizeof(wksp->scratchBuffer)) );\n    {   CHECK_V_F(cSize, FSE_compress_usingCTable(op, (size_t)(oend - op), weightTable, wtSize, wksp->CTable) );\n        if (cSize == 0) return 0;    \n        op += cSize;\n    }\n\n    return (size_t)(op-ostart);\n}\n\nstatic size_t HUF_getNbBits(HUF_CElt elt)\n{\n    return elt & 0xFF;\n}\n\nstatic size_t HUF_getNbBitsFast(HUF_CElt elt)\n{\n    return elt;\n}\n\nstatic size_t HUF_getValue(HUF_CElt elt)\n{\n    return elt & ~0xFF;\n}\n\nstatic size_t HUF_getValueFast(HUF_CElt elt)\n{\n    return elt;\n}\n\nstatic void HUF_setNbBits(HUF_CElt* elt, size_t nbBits)\n{\n    assert(nbBits <= HUF_TABLELOG_ABSOLUTEMAX);\n    *elt = nbBits;\n}\n\nstatic void HUF_setValue(HUF_CElt* elt, size_t value)\n{\n    size_t const nbBits = HUF_getNbBits(*elt);\n    if (nbBits > 0) {\n        assert((value >> nbBits) == 0);\n        *elt |= value << (sizeof(HUF_CElt) * 8 - nbBits);\n    }\n}\n\ntypedef struct {\n    HUF_CompressWeightsWksp wksp;\n    BYTE bitsToWeight[HUF_TABLELOG_MAX + 1];    \n    BYTE huffWeight[HUF_SYMBOLVALUE_MAX];\n} HUF_WriteCTableWksp;\n\nsize_t HUF_writeCTable_wksp(void* dst, size_t maxDstSize,\n                            const HUF_CElt* CTable, unsigned maxSymbolValue, unsigned huffLog,\n                            void* workspace, size_t workspaceSize)\n{\n    HUF_CElt const* const ct = CTable + 1;\n    BYTE* op = (BYTE*)dst;\n    U32 n;\n    HUF_WriteCTableWksp* wksp = (HUF_WriteCTableWksp*)HUF_alignUpWorkspace(workspace, &workspaceSize, ZSTD_ALIGNOF(U32));\n\n     \n    if (workspaceSize < sizeof(HUF_WriteCTableWksp)) return ERROR(GENERIC);\n    if (maxSymbolValue > HUF_SYMBOLVALUE_MAX) return ERROR(maxSymbolValue_tooLarge);\n\n     \n    wksp->bitsToWeight[0] = 0;\n    for (n=1; n<huffLog+1; n++)\n        wksp->bitsToWeight[n] = (BYTE)(huffLog + 1 - n);\n    for (n=0; n<maxSymbolValue; n++)\n        wksp->huffWeight[n] = wksp->bitsToWeight[HUF_getNbBits(ct[n])];\n\n     \n    if (maxDstSize < 1) return ERROR(dstSize_tooSmall);\n    {   CHECK_V_F(hSize, HUF_compressWeights(op+1, maxDstSize-1, wksp->huffWeight, maxSymbolValue, &wksp->wksp, sizeof(wksp->wksp)) );\n        if ((hSize>1) & (hSize < maxSymbolValue/2)) {    \n            op[0] = (BYTE)hSize;\n            return hSize+1;\n    }   }\n\n     \n    if (maxSymbolValue > (256-128)) return ERROR(GENERIC);    \n    if (((maxSymbolValue+1)/2) + 1 > maxDstSize) return ERROR(dstSize_tooSmall);    \n    op[0] = (BYTE)(128   + (maxSymbolValue-1));\n    wksp->huffWeight[maxSymbolValue] = 0;    \n    for (n=0; n<maxSymbolValue; n+=2)\n        op[(n/2)+1] = (BYTE)((wksp->huffWeight[n] << 4) + wksp->huffWeight[n+1]);\n    return ((maxSymbolValue+1)/2) + 1;\n}\n\n \nsize_t HUF_writeCTable (void* dst, size_t maxDstSize,\n                        const HUF_CElt* CTable, unsigned maxSymbolValue, unsigned huffLog)\n{\n    HUF_WriteCTableWksp wksp;\n    return HUF_writeCTable_wksp(dst, maxDstSize, CTable, maxSymbolValue, huffLog, &wksp, sizeof(wksp));\n}\n\n\nsize_t HUF_readCTable (HUF_CElt* CTable, unsigned* maxSymbolValuePtr, const void* src, size_t srcSize, unsigned* hasZeroWeights)\n{\n    BYTE huffWeight[HUF_SYMBOLVALUE_MAX + 1];    \n    U32 rankVal[HUF_TABLELOG_ABSOLUTEMAX + 1];    \n    U32 tableLog = 0;\n    U32 nbSymbols = 0;\n    HUF_CElt* const ct = CTable + 1;\n\n     \n    CHECK_V_F(readSize, HUF_readStats(huffWeight, HUF_SYMBOLVALUE_MAX+1, rankVal, &nbSymbols, &tableLog, src, srcSize));\n    *hasZeroWeights = (rankVal[0] > 0);\n\n     \n    if (tableLog > HUF_TABLELOG_MAX) return ERROR(tableLog_tooLarge);\n    if (nbSymbols > *maxSymbolValuePtr+1) return ERROR(maxSymbolValue_tooSmall);\n\n    CTable[0] = tableLog;\n\n     \n    {   U32 n, nextRankStart = 0;\n        for (n=1; n<=tableLog; n++) {\n            U32 curr = nextRankStart;\n            nextRankStart += (rankVal[n] << (n-1));\n            rankVal[n] = curr;\n    }   }\n\n     \n    {   U32 n; for (n=0; n<nbSymbols; n++) {\n            const U32 w = huffWeight[n];\n            HUF_setNbBits(ct + n, (BYTE)(tableLog + 1 - w) & -(w != 0));\n    }   }\n\n     \n    {   U16 nbPerRank[HUF_TABLELOG_MAX+2]  = {0};   \n        U16 valPerRank[HUF_TABLELOG_MAX+2] = {0};\n        { U32 n; for (n=0; n<nbSymbols; n++) nbPerRank[HUF_getNbBits(ct[n])]++; }\n         \n        valPerRank[tableLog+1] = 0;    \n        {   U16 min = 0;\n            U32 n; for (n=tableLog; n>0; n--) {   \n                valPerRank[n] = min;      \n                min += nbPerRank[n];\n                min >>= 1;\n        }   }\n         \n        { U32 n; for (n=0; n<nbSymbols; n++) HUF_setValue(ct + n, valPerRank[HUF_getNbBits(ct[n])]++); }\n    }\n\n    *maxSymbolValuePtr = nbSymbols - 1;\n    return readSize;\n}\n\nU32 HUF_getNbBitsFromCTable(HUF_CElt const* CTable, U32 symbolValue)\n{\n    const HUF_CElt* ct = CTable + 1;\n    assert(symbolValue <= HUF_SYMBOLVALUE_MAX);\n    return (U32)HUF_getNbBits(ct[symbolValue]);\n}\n\n\ntypedef struct nodeElt_s {\n    U32 count;\n    U16 parent;\n    BYTE byte;\n    BYTE nbBits;\n} nodeElt;\n\n \nstatic U32 HUF_setMaxHeight(nodeElt* huffNode, U32 lastNonNull, U32 maxNbBits)\n{\n    const U32 largestBits = huffNode[lastNonNull].nbBits;\n     \n    if (largestBits <= maxNbBits) return largestBits;\n\n     \n    {   int totalCost = 0;\n        const U32 baseCost = 1 << (largestBits - maxNbBits);\n        int n = (int)lastNonNull;\n\n         \n        while (huffNode[n].nbBits > maxNbBits) {\n            totalCost += baseCost - (1 << (largestBits - huffNode[n].nbBits));\n            huffNode[n].nbBits = (BYTE)maxNbBits;\n            n--;\n        }\n         \n        assert(huffNode[n].nbBits <= maxNbBits);\n         \n        while (huffNode[n].nbBits == maxNbBits) --n;\n\n         \n        assert((totalCost & (baseCost - 1)) == 0);\n        totalCost >>= (largestBits - maxNbBits);\n        assert(totalCost > 0);\n\n         \n        {   U32 const noSymbol = 0xF0F0F0F0;\n            U32 rankLast[HUF_TABLELOG_MAX+2];\n\n             \n            ZSTD_memset(rankLast, 0xF0, sizeof(rankLast));\n            {   U32 currentNbBits = maxNbBits;\n                int pos;\n                for (pos=n ; pos >= 0; pos--) {\n                    if (huffNode[pos].nbBits >= currentNbBits) continue;\n                    currentNbBits = huffNode[pos].nbBits;    \n                    rankLast[maxNbBits-currentNbBits] = (U32)pos;\n            }   }\n\n            while (totalCost > 0) {\n                 \n                U32 nBitsToDecrease = BIT_highbit32((U32)totalCost) + 1;\n                for ( ; nBitsToDecrease > 1; nBitsToDecrease--) {\n                    U32 const highPos = rankLast[nBitsToDecrease];\n                    U32 const lowPos = rankLast[nBitsToDecrease-1];\n                    if (highPos == noSymbol) continue;\n                     \n                    if (lowPos == noSymbol) break;\n                    {   U32 const highTotal = huffNode[highPos].count;\n                        U32 const lowTotal = 2 * huffNode[lowPos].count;\n                        if (highTotal <= lowTotal) break;\n                }   }\n                 \n                assert(rankLast[nBitsToDecrease] != noSymbol || nBitsToDecrease == 1);\n                 \n                while ((nBitsToDecrease<=HUF_TABLELOG_MAX) && (rankLast[nBitsToDecrease] == noSymbol))\n                    nBitsToDecrease++;\n                assert(rankLast[nBitsToDecrease] != noSymbol);\n                 \n                totalCost -= 1 << (nBitsToDecrease-1);\n                huffNode[rankLast[nBitsToDecrease]].nbBits++;\n\n                 \n                if (rankLast[nBitsToDecrease-1] == noSymbol)\n                    rankLast[nBitsToDecrease-1] = rankLast[nBitsToDecrease];\n                 \n                if (rankLast[nBitsToDecrease] == 0)     \n                    rankLast[nBitsToDecrease] = noSymbol;\n                else {\n                    rankLast[nBitsToDecrease]--;\n                    if (huffNode[rankLast[nBitsToDecrease]].nbBits != maxNbBits-nBitsToDecrease)\n                        rankLast[nBitsToDecrease] = noSymbol;    \n                }\n            }    \n\n             \n            while (totalCost < 0) {   \n                 \n                if (rankLast[1] == noSymbol) {\n                    while (huffNode[n].nbBits == maxNbBits) n--;\n                    huffNode[n+1].nbBits--;\n                    assert(n >= 0);\n                    rankLast[1] = (U32)(n+1);\n                    totalCost++;\n                    continue;\n                }\n                huffNode[ rankLast[1] + 1 ].nbBits--;\n                rankLast[1]++;\n                totalCost ++;\n            }\n        }    \n    }    \n\n    return maxNbBits;\n}\n\ntypedef struct {\n    U16 base;\n    U16 curr;\n} rankPos;\n\ntypedef nodeElt huffNodeTable[HUF_CTABLE_WORKSPACE_SIZE_U32];\n\n \n#define RANK_POSITION_TABLE_SIZE 192\n\ntypedef struct {\n  huffNodeTable huffNodeTbl;\n  rankPos rankPosition[RANK_POSITION_TABLE_SIZE];\n} HUF_buildCTable_wksp_tables;\n\n \n#define RANK_POSITION_MAX_COUNT_LOG 32\n#define RANK_POSITION_LOG_BUCKETS_BEGIN (RANK_POSITION_TABLE_SIZE - 1) - RANK_POSITION_MAX_COUNT_LOG - 1  \n#define RANK_POSITION_DISTINCT_COUNT_CUTOFF RANK_POSITION_LOG_BUCKETS_BEGIN + BIT_highbit32(RANK_POSITION_LOG_BUCKETS_BEGIN)  \n\n \nstatic U32 HUF_getIndex(U32 const count) {\n    return (count < RANK_POSITION_DISTINCT_COUNT_CUTOFF)\n        ? count\n        : BIT_highbit32(count) + RANK_POSITION_LOG_BUCKETS_BEGIN;\n}\n\n \nstatic void HUF_swapNodes(nodeElt* a, nodeElt* b) {\n\tnodeElt tmp = *a;\n\t*a = *b;\n\t*b = tmp;\n}\n\n \nMEM_STATIC int HUF_isSorted(nodeElt huffNode[], U32 const maxSymbolValue1) {\n    U32 i;\n    for (i = 1; i < maxSymbolValue1; ++i) {\n        if (huffNode[i].count > huffNode[i-1].count) {\n            return 0;\n        }\n    }\n    return 1;\n}\n\n \nHINT_INLINE void HUF_insertionSort(nodeElt huffNode[], int const low, int const high) {\n    int i;\n    int const size = high-low+1;\n    huffNode += low;\n    for (i = 1; i < size; ++i) {\n        nodeElt const key = huffNode[i];\n        int j = i - 1;\n        while (j >= 0 && huffNode[j].count < key.count) {\n            huffNode[j + 1] = huffNode[j];\n            j--;\n        }\n        huffNode[j + 1] = key;\n    }\n}\n\n \nstatic int HUF_quickSortPartition(nodeElt arr[], int const low, int const high) {\n     \n    U32 const pivot = arr[high].count;\n    int i = low - 1;\n    int j = low;\n    for ( ; j < high; j++) {\n        if (arr[j].count > pivot) {\n            i++;\n            HUF_swapNodes(&arr[i], &arr[j]);\n        }\n    }\n    HUF_swapNodes(&arr[i + 1], &arr[high]);\n    return i + 1;\n}\n\n \nstatic void HUF_simpleQuickSort(nodeElt arr[], int low, int high) {\n    int const kInsertionSortThreshold = 8;\n    if (high - low < kInsertionSortThreshold) {\n        HUF_insertionSort(arr, low, high);\n        return;\n    }\n    while (low < high) {\n        int const idx = HUF_quickSortPartition(arr, low, high);\n        if (idx - low < high - idx) {\n            HUF_simpleQuickSort(arr, low, idx - 1);\n            low = idx + 1;\n        } else {\n            HUF_simpleQuickSort(arr, idx + 1, high);\n            high = idx - 1;\n        }\n    }\n}\n\n \nstatic void HUF_sort(nodeElt huffNode[], const unsigned count[], U32 const maxSymbolValue, rankPos rankPosition[]) {\n    U32 n;\n    U32 const maxSymbolValue1 = maxSymbolValue+1;\n\n     \n    ZSTD_memset(rankPosition, 0, sizeof(*rankPosition) * RANK_POSITION_TABLE_SIZE);\n    for (n = 0; n < maxSymbolValue1; ++n) {\n        U32 lowerRank = HUF_getIndex(count[n]);\n        assert(lowerRank < RANK_POSITION_TABLE_SIZE - 1);\n        rankPosition[lowerRank].base++;\n    }\n\n    assert(rankPosition[RANK_POSITION_TABLE_SIZE - 1].base == 0);\n     \n    for (n = RANK_POSITION_TABLE_SIZE - 1; n > 0; --n) {\n        rankPosition[n-1].base += rankPosition[n].base;\n        rankPosition[n-1].curr = rankPosition[n-1].base;\n    }\n\n     \n    for (n = 0; n < maxSymbolValue1; ++n) {\n        U32 const c = count[n];\n        U32 const r = HUF_getIndex(c) + 1;\n        U32 const pos = rankPosition[r].curr++;\n        assert(pos < maxSymbolValue1);\n        huffNode[pos].count = c;\n        huffNode[pos].byte  = (BYTE)n;\n    }\n\n     \n    for (n = RANK_POSITION_DISTINCT_COUNT_CUTOFF; n < RANK_POSITION_TABLE_SIZE - 1; ++n) {\n        U32 const bucketSize = rankPosition[n].curr-rankPosition[n].base;\n        U32 const bucketStartIdx = rankPosition[n].base;\n        if (bucketSize > 1) {\n            assert(bucketStartIdx < maxSymbolValue1);\n            HUF_simpleQuickSort(huffNode + bucketStartIdx, 0, bucketSize-1);\n        }\n    }\n\n    assert(HUF_isSorted(huffNode, maxSymbolValue1));\n}\n\n \n#define STARTNODE (HUF_SYMBOLVALUE_MAX+1)\n\n \nstatic int HUF_buildTree(nodeElt* huffNode, U32 maxSymbolValue)\n{\n    nodeElt* const huffNode0 = huffNode - 1;\n    int nonNullRank;\n    int lowS, lowN;\n    int nodeNb = STARTNODE;\n    int n, nodeRoot;\n     \n    nonNullRank = (int)maxSymbolValue;\n    while(huffNode[nonNullRank].count == 0) nonNullRank--;\n    lowS = nonNullRank; nodeRoot = nodeNb + lowS - 1; lowN = nodeNb;\n    huffNode[nodeNb].count = huffNode[lowS].count + huffNode[lowS-1].count;\n    huffNode[lowS].parent = huffNode[lowS-1].parent = (U16)nodeNb;\n    nodeNb++; lowS-=2;\n    for (n=nodeNb; n<=nodeRoot; n++) huffNode[n].count = (U32)(1U<<30);\n    huffNode0[0].count = (U32)(1U<<31);   \n\n     \n    while (nodeNb <= nodeRoot) {\n        int const n1 = (huffNode[lowS].count < huffNode[lowN].count) ? lowS-- : lowN++;\n        int const n2 = (huffNode[lowS].count < huffNode[lowN].count) ? lowS-- : lowN++;\n        huffNode[nodeNb].count = huffNode[n1].count + huffNode[n2].count;\n        huffNode[n1].parent = huffNode[n2].parent = (U16)nodeNb;\n        nodeNb++;\n    }\n\n     \n    huffNode[nodeRoot].nbBits = 0;\n    for (n=nodeRoot-1; n>=STARTNODE; n--)\n        huffNode[n].nbBits = huffNode[ huffNode[n].parent ].nbBits + 1;\n    for (n=0; n<=nonNullRank; n++)\n        huffNode[n].nbBits = huffNode[ huffNode[n].parent ].nbBits + 1;\n\n    return nonNullRank;\n}\n\n \nstatic void HUF_buildCTableFromTree(HUF_CElt* CTable, nodeElt const* huffNode, int nonNullRank, U32 maxSymbolValue, U32 maxNbBits)\n{\n    HUF_CElt* const ct = CTable + 1;\n     \n    int n;\n    U16 nbPerRank[HUF_TABLELOG_MAX+1] = {0};\n    U16 valPerRank[HUF_TABLELOG_MAX+1] = {0};\n    int const alphabetSize = (int)(maxSymbolValue + 1);\n    for (n=0; n<=nonNullRank; n++)\n        nbPerRank[huffNode[n].nbBits]++;\n     \n    {   U16 min = 0;\n        for (n=(int)maxNbBits; n>0; n--) {\n            valPerRank[n] = min;       \n            min += nbPerRank[n];\n            min >>= 1;\n    }   }\n    for (n=0; n<alphabetSize; n++)\n        HUF_setNbBits(ct + huffNode[n].byte, huffNode[n].nbBits);    \n    for (n=0; n<alphabetSize; n++)\n        HUF_setValue(ct + n, valPerRank[HUF_getNbBits(ct[n])]++);    \n    CTable[0] = maxNbBits;\n}\n\nsize_t HUF_buildCTable_wksp (HUF_CElt* CTable, const unsigned* count, U32 maxSymbolValue, U32 maxNbBits, void* workSpace, size_t wkspSize)\n{\n    HUF_buildCTable_wksp_tables* const wksp_tables = (HUF_buildCTable_wksp_tables*)HUF_alignUpWorkspace(workSpace, &wkspSize, ZSTD_ALIGNOF(U32));\n    nodeElt* const huffNode0 = wksp_tables->huffNodeTbl;\n    nodeElt* const huffNode = huffNode0+1;\n    int nonNullRank;\n\n     \n    if (wkspSize < sizeof(HUF_buildCTable_wksp_tables))\n      return ERROR(workSpace_tooSmall);\n    if (maxNbBits == 0) maxNbBits = HUF_TABLELOG_DEFAULT;\n    if (maxSymbolValue > HUF_SYMBOLVALUE_MAX)\n      return ERROR(maxSymbolValue_tooLarge);\n    ZSTD_memset(huffNode0, 0, sizeof(huffNodeTable));\n\n     \n    HUF_sort(huffNode, count, maxSymbolValue, wksp_tables->rankPosition);\n\n     \n    nonNullRank = HUF_buildTree(huffNode, maxSymbolValue);\n\n     \n    maxNbBits = HUF_setMaxHeight(huffNode, (U32)nonNullRank, maxNbBits);\n    if (maxNbBits > HUF_TABLELOG_MAX) return ERROR(GENERIC);    \n\n    HUF_buildCTableFromTree(CTable, huffNode, nonNullRank, maxSymbolValue, maxNbBits);\n\n    return maxNbBits;\n}\n\nsize_t HUF_estimateCompressedSize(const HUF_CElt* CTable, const unsigned* count, unsigned maxSymbolValue)\n{\n    HUF_CElt const* ct = CTable + 1;\n    size_t nbBits = 0;\n    int s;\n    for (s = 0; s <= (int)maxSymbolValue; ++s) {\n        nbBits += HUF_getNbBits(ct[s]) * count[s];\n    }\n    return nbBits >> 3;\n}\n\nint HUF_validateCTable(const HUF_CElt* CTable, const unsigned* count, unsigned maxSymbolValue) {\n  HUF_CElt const* ct = CTable + 1;\n  int bad = 0;\n  int s;\n  for (s = 0; s <= (int)maxSymbolValue; ++s) {\n    bad |= (count[s] != 0) & (HUF_getNbBits(ct[s]) == 0);\n  }\n  return !bad;\n}\n\nsize_t HUF_compressBound(size_t size) { return HUF_COMPRESSBOUND(size); }\n\n \n\n#define HUF_BITS_IN_CONTAINER (sizeof(size_t) * 8)\n\ntypedef struct {\n    size_t bitContainer[2];\n    size_t bitPos[2];\n\n    BYTE* startPtr;\n    BYTE* ptr;\n    BYTE* endPtr;\n} HUF_CStream_t;\n\n \nstatic size_t HUF_initCStream(HUF_CStream_t* bitC,\n                                  void* startPtr, size_t dstCapacity)\n{\n    ZSTD_memset(bitC, 0, sizeof(*bitC));\n    bitC->startPtr = (BYTE*)startPtr;\n    bitC->ptr = bitC->startPtr;\n    bitC->endPtr = bitC->startPtr + dstCapacity - sizeof(bitC->bitContainer[0]);\n    if (dstCapacity <= sizeof(bitC->bitContainer[0])) return ERROR(dstSize_tooSmall);\n    return 0;\n}\n\n \nFORCE_INLINE_TEMPLATE void HUF_addBits(HUF_CStream_t* bitC, HUF_CElt elt, int idx, int kFast)\n{\n    assert(idx <= 1);\n    assert(HUF_getNbBits(elt) <= HUF_TABLELOG_ABSOLUTEMAX);\n     \n    bitC->bitContainer[idx] >>= HUF_getNbBits(elt);\n    bitC->bitContainer[idx] |= kFast ? HUF_getValueFast(elt) : HUF_getValue(elt);\n     \n    bitC->bitPos[idx] += HUF_getNbBitsFast(elt);\n    assert((bitC->bitPos[idx] & 0xFF) <= HUF_BITS_IN_CONTAINER);\n     \n#if DEBUGLEVEL >= 1\n    {\n        size_t const nbBits = HUF_getNbBits(elt);\n        size_t const dirtyBits = nbBits == 0 ? 0 : BIT_highbit32((U32)nbBits) + 1;\n        (void)dirtyBits;\n         \n        assert(((elt >> dirtyBits) << (dirtyBits + nbBits)) == 0);\n         \n        assert(!kFast || (bitC->bitPos[idx] & 0xFF) <= HUF_BITS_IN_CONTAINER);\n        (void)dirtyBits;\n    }\n#endif\n}\n\nFORCE_INLINE_TEMPLATE void HUF_zeroIndex1(HUF_CStream_t* bitC)\n{\n    bitC->bitContainer[1] = 0;\n    bitC->bitPos[1] = 0;\n}\n\n \nFORCE_INLINE_TEMPLATE void HUF_mergeIndex1(HUF_CStream_t* bitC)\n{\n    assert((bitC->bitPos[1] & 0xFF) < HUF_BITS_IN_CONTAINER);\n    bitC->bitContainer[0] >>= (bitC->bitPos[1] & 0xFF);\n    bitC->bitContainer[0] |= bitC->bitContainer[1];\n    bitC->bitPos[0] += bitC->bitPos[1];\n    assert((bitC->bitPos[0] & 0xFF) <= HUF_BITS_IN_CONTAINER);\n}\n\n \nFORCE_INLINE_TEMPLATE void HUF_flushBits(HUF_CStream_t* bitC, int kFast)\n{\n     \n    size_t const nbBits = bitC->bitPos[0] & 0xFF;\n    size_t const nbBytes = nbBits >> 3;\n     \n    size_t const bitContainer = bitC->bitContainer[0] >> (HUF_BITS_IN_CONTAINER - nbBits);\n     \n    bitC->bitPos[0] &= 7;\n    assert(nbBits > 0);\n    assert(nbBits <= sizeof(bitC->bitContainer[0]) * 8);\n    assert(bitC->ptr <= bitC->endPtr);\n    MEM_writeLEST(bitC->ptr, bitContainer);\n    bitC->ptr += nbBytes;\n    assert(!kFast || bitC->ptr <= bitC->endPtr);\n    if (!kFast && bitC->ptr > bitC->endPtr) bitC->ptr = bitC->endPtr;\n     \n}\n\n \nstatic HUF_CElt HUF_endMark(void)\n{\n    HUF_CElt endMark;\n    HUF_setNbBits(&endMark, 1);\n    HUF_setValue(&endMark, 1);\n    return endMark;\n}\n\n \nstatic size_t HUF_closeCStream(HUF_CStream_t* bitC)\n{\n    HUF_addBits(bitC, HUF_endMark(),   0,   0);\n    HUF_flushBits(bitC,   0);\n    {\n        size_t const nbBits = bitC->bitPos[0] & 0xFF;\n        if (bitC->ptr >= bitC->endPtr) return 0;  \n        return (bitC->ptr - bitC->startPtr) + (nbBits > 0);\n    }\n}\n\nFORCE_INLINE_TEMPLATE void\nHUF_encodeSymbol(HUF_CStream_t* bitCPtr, U32 symbol, const HUF_CElt* CTable, int idx, int fast)\n{\n    HUF_addBits(bitCPtr, CTable[symbol], idx, fast);\n}\n\nFORCE_INLINE_TEMPLATE void\nHUF_compress1X_usingCTable_internal_body_loop(HUF_CStream_t* bitC,\n                                   const BYTE* ip, size_t srcSize,\n                                   const HUF_CElt* ct,\n                                   int kUnroll, int kFastFlush, int kLastFast)\n{\n     \n    int n = (int)srcSize;\n    int rem = n % kUnroll;\n    if (rem > 0) {\n        for (; rem > 0; --rem) {\n            HUF_encodeSymbol(bitC, ip[--n], ct, 0,   0);\n        }\n        HUF_flushBits(bitC, kFastFlush);\n    }\n    assert(n % kUnroll == 0);\n\n     \n    if (n % (2 * kUnroll)) {\n        int u;\n        for (u = 1; u < kUnroll; ++u) {\n            HUF_encodeSymbol(bitC, ip[n - u], ct, 0, 1);\n        }\n        HUF_encodeSymbol(bitC, ip[n - kUnroll], ct, 0, kLastFast);\n        HUF_flushBits(bitC, kFastFlush);\n        n -= kUnroll;\n    }\n    assert(n % (2 * kUnroll) == 0);\n\n    for (; n>0; n-= 2 * kUnroll) {\n         \n        int u;\n        for (u = 1; u < kUnroll; ++u) {\n            HUF_encodeSymbol(bitC, ip[n - u], ct,   0,   1);\n        }\n        HUF_encodeSymbol(bitC, ip[n - kUnroll], ct,   0,   kLastFast);\n        HUF_flushBits(bitC, kFastFlush);\n         \n        HUF_zeroIndex1(bitC);\n        for (u = 1; u < kUnroll; ++u) {\n            HUF_encodeSymbol(bitC, ip[n - kUnroll - u], ct,   1,   1);\n        }\n        HUF_encodeSymbol(bitC, ip[n - kUnroll - kUnroll], ct,   1,   kLastFast);\n         \n        HUF_mergeIndex1(bitC);\n        HUF_flushBits(bitC, kFastFlush);\n    }\n    assert(n == 0);\n\n}\n\n \nstatic size_t HUF_tightCompressBound(size_t srcSize, size_t tableLog)\n{\n    return ((srcSize * tableLog) >> 3) + 8;\n}\n\n\nFORCE_INLINE_TEMPLATE size_t\nHUF_compress1X_usingCTable_internal_body(void* dst, size_t dstSize,\n                                   const void* src, size_t srcSize,\n                                   const HUF_CElt* CTable)\n{\n    U32 const tableLog = (U32)CTable[0];\n    HUF_CElt const* ct = CTable + 1;\n    const BYTE* ip = (const BYTE*) src;\n    BYTE* const ostart = (BYTE*)dst;\n    BYTE* const oend = ostart + dstSize;\n    BYTE* op = ostart;\n    HUF_CStream_t bitC;\n\n     \n    if (dstSize < 8) return 0;    \n    { size_t const initErr = HUF_initCStream(&bitC, op, (size_t)(oend-op));\n      if (HUF_isError(initErr)) return 0; }\n\n    if (dstSize < HUF_tightCompressBound(srcSize, (size_t)tableLog) || tableLog > 11)\n        HUF_compress1X_usingCTable_internal_body_loop(&bitC, ip, srcSize, ct,   MEM_32bits() ? 2 : 4,   0,   0);\n    else {\n        if (MEM_32bits()) {\n            switch (tableLog) {\n            case 11:\n                HUF_compress1X_usingCTable_internal_body_loop(&bitC, ip, srcSize, ct,   2,   1,   0);\n                break;\n            case 10: ZSTD_FALLTHROUGH;\n            case 9: ZSTD_FALLTHROUGH;\n            case 8:\n                HUF_compress1X_usingCTable_internal_body_loop(&bitC, ip, srcSize, ct,   2,   1,   1);\n                break;\n            case 7: ZSTD_FALLTHROUGH;\n            default:\n                HUF_compress1X_usingCTable_internal_body_loop(&bitC, ip, srcSize, ct,   3,   1,   1);\n                break;\n            }\n        } else {\n            switch (tableLog) {\n            case 11:\n                HUF_compress1X_usingCTable_internal_body_loop(&bitC, ip, srcSize, ct,   5,   1,   0);\n                break;\n            case 10:\n                HUF_compress1X_usingCTable_internal_body_loop(&bitC, ip, srcSize, ct,   5,   1,   1);\n                break;\n            case 9:\n                HUF_compress1X_usingCTable_internal_body_loop(&bitC, ip, srcSize, ct,   6,   1,   0);\n                break;\n            case 8:\n                HUF_compress1X_usingCTable_internal_body_loop(&bitC, ip, srcSize, ct,   7,   1,   0);\n                break;\n            case 7:\n                HUF_compress1X_usingCTable_internal_body_loop(&bitC, ip, srcSize, ct,   8,   1,   0);\n                break;\n            case 6: ZSTD_FALLTHROUGH;\n            default:\n                HUF_compress1X_usingCTable_internal_body_loop(&bitC, ip, srcSize, ct,   9,   1,   1);\n                break;\n            }\n        }\n    }\n    assert(bitC.ptr <= bitC.endPtr);\n\n    return HUF_closeCStream(&bitC);\n}\n\n#if DYNAMIC_BMI2\n\nstatic BMI2_TARGET_ATTRIBUTE size_t\nHUF_compress1X_usingCTable_internal_bmi2(void* dst, size_t dstSize,\n                                   const void* src, size_t srcSize,\n                                   const HUF_CElt* CTable)\n{\n    return HUF_compress1X_usingCTable_internal_body(dst, dstSize, src, srcSize, CTable);\n}\n\nstatic size_t\nHUF_compress1X_usingCTable_internal_default(void* dst, size_t dstSize,\n                                      const void* src, size_t srcSize,\n                                      const HUF_CElt* CTable)\n{\n    return HUF_compress1X_usingCTable_internal_body(dst, dstSize, src, srcSize, CTable);\n}\n\nstatic size_t\nHUF_compress1X_usingCTable_internal(void* dst, size_t dstSize,\n                              const void* src, size_t srcSize,\n                              const HUF_CElt* CTable, const int bmi2)\n{\n    if (bmi2) {\n        return HUF_compress1X_usingCTable_internal_bmi2(dst, dstSize, src, srcSize, CTable);\n    }\n    return HUF_compress1X_usingCTable_internal_default(dst, dstSize, src, srcSize, CTable);\n}\n\n#else\n\nstatic size_t\nHUF_compress1X_usingCTable_internal(void* dst, size_t dstSize,\n                              const void* src, size_t srcSize,\n                              const HUF_CElt* CTable, const int bmi2)\n{\n    (void)bmi2;\n    return HUF_compress1X_usingCTable_internal_body(dst, dstSize, src, srcSize, CTable);\n}\n\n#endif\n\nsize_t HUF_compress1X_usingCTable(void* dst, size_t dstSize, const void* src, size_t srcSize, const HUF_CElt* CTable)\n{\n    return HUF_compress1X_usingCTable_bmi2(dst, dstSize, src, srcSize, CTable,   0);\n}\n\nsize_t HUF_compress1X_usingCTable_bmi2(void* dst, size_t dstSize, const void* src, size_t srcSize, const HUF_CElt* CTable, int bmi2)\n{\n    return HUF_compress1X_usingCTable_internal(dst, dstSize, src, srcSize, CTable, bmi2);\n}\n\nstatic size_t\nHUF_compress4X_usingCTable_internal(void* dst, size_t dstSize,\n                              const void* src, size_t srcSize,\n                              const HUF_CElt* CTable, int bmi2)\n{\n    size_t const segmentSize = (srcSize+3)/4;    \n    const BYTE* ip = (const BYTE*) src;\n    const BYTE* const iend = ip + srcSize;\n    BYTE* const ostart = (BYTE*) dst;\n    BYTE* const oend = ostart + dstSize;\n    BYTE* op = ostart;\n\n    if (dstSize < 6 + 1 + 1 + 1 + 8) return 0;    \n    if (srcSize < 12) return 0;    \n    op += 6;    \n\n    assert(op <= oend);\n    {   CHECK_V_F(cSize, HUF_compress1X_usingCTable_internal(op, (size_t)(oend-op), ip, segmentSize, CTable, bmi2) );\n        if (cSize == 0 || cSize > 65535) return 0;\n        MEM_writeLE16(ostart, (U16)cSize);\n        op += cSize;\n    }\n\n    ip += segmentSize;\n    assert(op <= oend);\n    {   CHECK_V_F(cSize, HUF_compress1X_usingCTable_internal(op, (size_t)(oend-op), ip, segmentSize, CTable, bmi2) );\n        if (cSize == 0 || cSize > 65535) return 0;\n        MEM_writeLE16(ostart+2, (U16)cSize);\n        op += cSize;\n    }\n\n    ip += segmentSize;\n    assert(op <= oend);\n    {   CHECK_V_F(cSize, HUF_compress1X_usingCTable_internal(op, (size_t)(oend-op), ip, segmentSize, CTable, bmi2) );\n        if (cSize == 0 || cSize > 65535) return 0;\n        MEM_writeLE16(ostart+4, (U16)cSize);\n        op += cSize;\n    }\n\n    ip += segmentSize;\n    assert(op <= oend);\n    assert(ip <= iend);\n    {   CHECK_V_F(cSize, HUF_compress1X_usingCTable_internal(op, (size_t)(oend-op), ip, (size_t)(iend-ip), CTable, bmi2) );\n        if (cSize == 0 || cSize > 65535) return 0;\n        op += cSize;\n    }\n\n    return (size_t)(op-ostart);\n}\n\nsize_t HUF_compress4X_usingCTable(void* dst, size_t dstSize, const void* src, size_t srcSize, const HUF_CElt* CTable)\n{\n    return HUF_compress4X_usingCTable_bmi2(dst, dstSize, src, srcSize, CTable,   0);\n}\n\nsize_t HUF_compress4X_usingCTable_bmi2(void* dst, size_t dstSize, const void* src, size_t srcSize, const HUF_CElt* CTable, int bmi2)\n{\n    return HUF_compress4X_usingCTable_internal(dst, dstSize, src, srcSize, CTable, bmi2);\n}\n\ntypedef enum { HUF_singleStream, HUF_fourStreams } HUF_nbStreams_e;\n\nstatic size_t HUF_compressCTable_internal(\n                BYTE* const ostart, BYTE* op, BYTE* const oend,\n                const void* src, size_t srcSize,\n                HUF_nbStreams_e nbStreams, const HUF_CElt* CTable, const int bmi2)\n{\n    size_t const cSize = (nbStreams==HUF_singleStream) ?\n                         HUF_compress1X_usingCTable_internal(op, (size_t)(oend - op), src, srcSize, CTable, bmi2) :\n                         HUF_compress4X_usingCTable_internal(op, (size_t)(oend - op), src, srcSize, CTable, bmi2);\n    if (HUF_isError(cSize)) { return cSize; }\n    if (cSize==0) { return 0; }    \n    op += cSize;\n     \n    assert(op >= ostart);\n    if ((size_t)(op-ostart) >= srcSize-1) { return 0; }\n    return (size_t)(op-ostart);\n}\n\ntypedef struct {\n    unsigned count[HUF_SYMBOLVALUE_MAX + 1];\n    HUF_CElt CTable[HUF_CTABLE_SIZE_ST(HUF_SYMBOLVALUE_MAX)];\n    union {\n        HUF_buildCTable_wksp_tables buildCTable_wksp;\n        HUF_WriteCTableWksp writeCTable_wksp;\n        U32 hist_wksp[HIST_WKSP_SIZE_U32];\n    } wksps;\n} HUF_compress_tables_t;\n\n#define SUSPECT_INCOMPRESSIBLE_SAMPLE_SIZE 4096\n#define SUSPECT_INCOMPRESSIBLE_SAMPLE_RATIO 10   \n\n \nstatic size_t\nHUF_compress_internal (void* dst, size_t dstSize,\n                 const void* src, size_t srcSize,\n                       unsigned maxSymbolValue, unsigned huffLog,\n                       HUF_nbStreams_e nbStreams,\n                       void* workSpace, size_t wkspSize,\n                       HUF_CElt* oldHufTable, HUF_repeat* repeat, int preferRepeat,\n                 const int bmi2, unsigned suspectUncompressible)\n{\n    HUF_compress_tables_t* const table = (HUF_compress_tables_t*)HUF_alignUpWorkspace(workSpace, &wkspSize, ZSTD_ALIGNOF(size_t));\n    BYTE* const ostart = (BYTE*)dst;\n    BYTE* const oend = ostart + dstSize;\n    BYTE* op = ostart;\n\n    HUF_STATIC_ASSERT(sizeof(*table) + HUF_WORKSPACE_MAX_ALIGNMENT <= HUF_WORKSPACE_SIZE);\n\n     \n    if (wkspSize < sizeof(*table)) return ERROR(workSpace_tooSmall);\n    if (!srcSize) return 0;   \n    if (!dstSize) return 0;   \n    if (srcSize > HUF_BLOCKSIZE_MAX) return ERROR(srcSize_wrong);    \n    if (huffLog > HUF_TABLELOG_MAX) return ERROR(tableLog_tooLarge);\n    if (maxSymbolValue > HUF_SYMBOLVALUE_MAX) return ERROR(maxSymbolValue_tooLarge);\n    if (!maxSymbolValue) maxSymbolValue = HUF_SYMBOLVALUE_MAX;\n    if (!huffLog) huffLog = HUF_TABLELOG_DEFAULT;\n\n     \n    if (preferRepeat && repeat && *repeat == HUF_repeat_valid) {\n        return HUF_compressCTable_internal(ostart, op, oend,\n                                           src, srcSize,\n                                           nbStreams, oldHufTable, bmi2);\n    }\n\n     \n    DEBUG_STATIC_ASSERT(SUSPECT_INCOMPRESSIBLE_SAMPLE_RATIO >= 2);\n    if (suspectUncompressible && srcSize >= (SUSPECT_INCOMPRESSIBLE_SAMPLE_SIZE * SUSPECT_INCOMPRESSIBLE_SAMPLE_RATIO)) {\n        size_t largestTotal = 0;\n        {   unsigned maxSymbolValueBegin = maxSymbolValue;\n            CHECK_V_F(largestBegin, HIST_count_simple (table->count, &maxSymbolValueBegin, (const BYTE*)src, SUSPECT_INCOMPRESSIBLE_SAMPLE_SIZE) );\n            largestTotal += largestBegin;\n        }\n        {   unsigned maxSymbolValueEnd = maxSymbolValue;\n            CHECK_V_F(largestEnd, HIST_count_simple (table->count, &maxSymbolValueEnd, (const BYTE*)src + srcSize - SUSPECT_INCOMPRESSIBLE_SAMPLE_SIZE, SUSPECT_INCOMPRESSIBLE_SAMPLE_SIZE) );\n            largestTotal += largestEnd;\n        }\n        if (largestTotal <= ((2 * SUSPECT_INCOMPRESSIBLE_SAMPLE_SIZE) >> 7)+4) return 0;    \n    }\n\n     \n    {   CHECK_V_F(largest, HIST_count_wksp (table->count, &maxSymbolValue, (const BYTE*)src, srcSize, table->wksps.hist_wksp, sizeof(table->wksps.hist_wksp)) );\n        if (largest == srcSize) { *ostart = ((const BYTE*)src)[0]; return 1; }    \n        if (largest <= (srcSize >> 7)+4) return 0;    \n    }\n\n     \n    if ( repeat\n      && *repeat == HUF_repeat_check\n      && !HUF_validateCTable(oldHufTable, table->count, maxSymbolValue)) {\n        *repeat = HUF_repeat_none;\n    }\n     \n    if (preferRepeat && repeat && *repeat != HUF_repeat_none) {\n        return HUF_compressCTable_internal(ostart, op, oend,\n                                           src, srcSize,\n                                           nbStreams, oldHufTable, bmi2);\n    }\n\n     \n    huffLog = HUF_optimalTableLog(huffLog, srcSize, maxSymbolValue);\n    {   size_t const maxBits = HUF_buildCTable_wksp(table->CTable, table->count,\n                                            maxSymbolValue, huffLog,\n                                            &table->wksps.buildCTable_wksp, sizeof(table->wksps.buildCTable_wksp));\n        CHECK_F(maxBits);\n        huffLog = (U32)maxBits;\n    }\n     \n    {\n        size_t const ctableSize = HUF_CTABLE_SIZE_ST(maxSymbolValue);\n        size_t const unusedSize = sizeof(table->CTable) - ctableSize * sizeof(HUF_CElt);\n        ZSTD_memset(table->CTable + ctableSize, 0, unusedSize);\n    }\n\n     \n    {   CHECK_V_F(hSize, HUF_writeCTable_wksp(op, dstSize, table->CTable, maxSymbolValue, huffLog,\n                                              &table->wksps.writeCTable_wksp, sizeof(table->wksps.writeCTable_wksp)) );\n         \n        if (repeat && *repeat != HUF_repeat_none) {\n            size_t const oldSize = HUF_estimateCompressedSize(oldHufTable, table->count, maxSymbolValue);\n            size_t const newSize = HUF_estimateCompressedSize(table->CTable, table->count, maxSymbolValue);\n            if (oldSize <= hSize + newSize || hSize + 12 >= srcSize) {\n                return HUF_compressCTable_internal(ostart, op, oend,\n                                                   src, srcSize,\n                                                   nbStreams, oldHufTable, bmi2);\n        }   }\n\n         \n        if (hSize + 12ul >= srcSize) { return 0; }\n        op += hSize;\n        if (repeat) { *repeat = HUF_repeat_none; }\n        if (oldHufTable)\n            ZSTD_memcpy(oldHufTable, table->CTable, sizeof(table->CTable));   \n    }\n    return HUF_compressCTable_internal(ostart, op, oend,\n                                       src, srcSize,\n                                       nbStreams, table->CTable, bmi2);\n}\n\n\nsize_t HUF_compress1X_wksp (void* dst, size_t dstSize,\n                      const void* src, size_t srcSize,\n                      unsigned maxSymbolValue, unsigned huffLog,\n                      void* workSpace, size_t wkspSize)\n{\n    return HUF_compress_internal(dst, dstSize, src, srcSize,\n                                 maxSymbolValue, huffLog, HUF_singleStream,\n                                 workSpace, wkspSize,\n                                 NULL, NULL, 0, 0  , 0);\n}\n\nsize_t HUF_compress1X_repeat (void* dst, size_t dstSize,\n                      const void* src, size_t srcSize,\n                      unsigned maxSymbolValue, unsigned huffLog,\n                      void* workSpace, size_t wkspSize,\n                      HUF_CElt* hufTable, HUF_repeat* repeat, int preferRepeat,\n                      int bmi2, unsigned suspectUncompressible)\n{\n    return HUF_compress_internal(dst, dstSize, src, srcSize,\n                                 maxSymbolValue, huffLog, HUF_singleStream,\n                                 workSpace, wkspSize, hufTable,\n                                 repeat, preferRepeat, bmi2, suspectUncompressible);\n}\n\n \nsize_t HUF_compress4X_wksp (void* dst, size_t dstSize,\n                      const void* src, size_t srcSize,\n                      unsigned maxSymbolValue, unsigned huffLog,\n                      void* workSpace, size_t wkspSize)\n{\n    return HUF_compress_internal(dst, dstSize, src, srcSize,\n                                 maxSymbolValue, huffLog, HUF_fourStreams,\n                                 workSpace, wkspSize,\n                                 NULL, NULL, 0, 0  , 0);\n}\n\n \nsize_t HUF_compress4X_repeat (void* dst, size_t dstSize,\n                      const void* src, size_t srcSize,\n                      unsigned maxSymbolValue, unsigned huffLog,\n                      void* workSpace, size_t wkspSize,\n                      HUF_CElt* hufTable, HUF_repeat* repeat, int preferRepeat, int bmi2, unsigned suspectUncompressible)\n{\n    return HUF_compress_internal(dst, dstSize, src, srcSize,\n                                 maxSymbolValue, huffLog, HUF_fourStreams,\n                                 workSpace, wkspSize,\n                                 hufTable, repeat, preferRepeat, bmi2, suspectUncompressible);\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}