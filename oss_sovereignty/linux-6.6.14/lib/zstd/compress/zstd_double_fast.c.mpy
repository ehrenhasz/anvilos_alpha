{
  "module_name": "zstd_double_fast.c",
  "hash_id": "4bd7a7b416ab17322b506c6fe421bf2e865b752410fe0d19f2cc47ab792bee19",
  "original_prompt": "Ingested from linux-6.6.14/lib/zstd/compress/zstd_double_fast.c",
  "human_readable_source": " \n\n#include \"zstd_compress_internal.h\"\n#include \"zstd_double_fast.h\"\n\n\nvoid ZSTD_fillDoubleHashTable(ZSTD_matchState_t* ms,\n                              void const* end, ZSTD_dictTableLoadMethod_e dtlm)\n{\n    const ZSTD_compressionParameters* const cParams = &ms->cParams;\n    U32* const hashLarge = ms->hashTable;\n    U32  const hBitsL = cParams->hashLog;\n    U32  const mls = cParams->minMatch;\n    U32* const hashSmall = ms->chainTable;\n    U32  const hBitsS = cParams->chainLog;\n    const BYTE* const base = ms->window.base;\n    const BYTE* ip = base + ms->nextToUpdate;\n    const BYTE* const iend = ((const BYTE*)end) - HASH_READ_SIZE;\n    const U32 fastHashFillStep = 3;\n\n     \n    for (; ip + fastHashFillStep - 1 <= iend; ip += fastHashFillStep) {\n        U32 const curr = (U32)(ip - base);\n        U32 i;\n        for (i = 0; i < fastHashFillStep; ++i) {\n            size_t const smHash = ZSTD_hashPtr(ip + i, hBitsS, mls);\n            size_t const lgHash = ZSTD_hashPtr(ip + i, hBitsL, 8);\n            if (i == 0)\n                hashSmall[smHash] = curr + i;\n            if (i == 0 || hashLarge[lgHash] == 0)\n                hashLarge[lgHash] = curr + i;\n             \n            if (dtlm == ZSTD_dtlm_fast)\n                break;\n    }   }\n}\n\n\nFORCE_INLINE_TEMPLATE\nsize_t ZSTD_compressBlock_doubleFast_noDict_generic(\n        ZSTD_matchState_t* ms, seqStore_t* seqStore, U32 rep[ZSTD_REP_NUM],\n        void const* src, size_t srcSize, U32 const mls  )\n{\n    ZSTD_compressionParameters const* cParams = &ms->cParams;\n    U32* const hashLong = ms->hashTable;\n    const U32 hBitsL = cParams->hashLog;\n    U32* const hashSmall = ms->chainTable;\n    const U32 hBitsS = cParams->chainLog;\n    const BYTE* const base = ms->window.base;\n    const BYTE* const istart = (const BYTE*)src;\n    const BYTE* anchor = istart;\n    const U32 endIndex = (U32)((size_t)(istart - base) + srcSize);\n     \n    const U32 prefixLowestIndex = ZSTD_getLowestPrefixIndex(ms, endIndex, cParams->windowLog);\n    const BYTE* const prefixLowest = base + prefixLowestIndex;\n    const BYTE* const iend = istart + srcSize;\n    const BYTE* const ilimit = iend - HASH_READ_SIZE;\n    U32 offset_1=rep[0], offset_2=rep[1];\n    U32 offsetSaved = 0;\n\n    size_t mLength;\n    U32 offset;\n    U32 curr;\n\n     \n    const size_t kStepIncr = 1 << kSearchStrength;\n     \n    const BYTE* nextStep;\n    size_t step;  \n\n    size_t hl0;  \n    size_t hl1;  \n\n    U32 idxl0;  \n    U32 idxl1;  \n\n    const BYTE* matchl0;  \n    const BYTE* matchs0;  \n    const BYTE* matchl1;  \n\n    const BYTE* ip = istart;  \n    const BYTE* ip1;  \n\n    DEBUGLOG(5, \"ZSTD_compressBlock_doubleFast_noDict_generic\");\n\n     \n    ip += ((ip - prefixLowest) == 0);\n    {\n        U32 const current = (U32)(ip - base);\n        U32 const windowLow = ZSTD_getLowestPrefixIndex(ms, current, cParams->windowLog);\n        U32 const maxRep = current - windowLow;\n        if (offset_2 > maxRep) offsetSaved = offset_2, offset_2 = 0;\n        if (offset_1 > maxRep) offsetSaved = offset_1, offset_1 = 0;\n    }\n\n     \n    while (1) {\n        step = 1;\n        nextStep = ip + kStepIncr;\n        ip1 = ip + step;\n\n        if (ip1 > ilimit) {\n            goto _cleanup;\n        }\n\n        hl0 = ZSTD_hashPtr(ip, hBitsL, 8);\n        idxl0 = hashLong[hl0];\n        matchl0 = base + idxl0;\n\n         \n        do {\n            const size_t hs0 = ZSTD_hashPtr(ip, hBitsS, mls);\n            const U32 idxs0 = hashSmall[hs0];\n            curr = (U32)(ip-base);\n            matchs0 = base + idxs0;\n\n            hashLong[hl0] = hashSmall[hs0] = curr;    \n\n             \n            if ((offset_1 > 0) & (MEM_read32(ip+1-offset_1) == MEM_read32(ip+1))) {\n                mLength = ZSTD_count(ip+1+4, ip+1+4-offset_1, iend) + 4;\n                ip++;\n                ZSTD_storeSeq(seqStore, (size_t)(ip-anchor), anchor, iend, STORE_REPCODE_1, mLength);\n                goto _match_stored;\n            }\n\n            hl1 = ZSTD_hashPtr(ip1, hBitsL, 8);\n\n            if (idxl0 > prefixLowestIndex) {\n                 \n                if (MEM_read64(matchl0) == MEM_read64(ip)) {\n                    mLength = ZSTD_count(ip+8, matchl0+8, iend) + 8;\n                    offset = (U32)(ip-matchl0);\n                    while (((ip>anchor) & (matchl0>prefixLowest)) && (ip[-1] == matchl0[-1])) { ip--; matchl0--; mLength++; }  \n                    goto _match_found;\n                }\n            }\n\n            idxl1 = hashLong[hl1];\n            matchl1 = base + idxl1;\n\n            if (idxs0 > prefixLowestIndex) {\n                 \n                if (MEM_read32(matchs0) == MEM_read32(ip)) {\n                    goto _search_next_long;\n                }\n            }\n\n            if (ip1 >= nextStep) {\n                PREFETCH_L1(ip1 + 64);\n                PREFETCH_L1(ip1 + 128);\n                step++;\n                nextStep += kStepIncr;\n            }\n            ip = ip1;\n            ip1 += step;\n\n            hl0 = hl1;\n            idxl0 = idxl1;\n            matchl0 = matchl1;\n    #if defined(__aarch64__)\n            PREFETCH_L1(ip+256);\n    #endif\n        } while (ip1 <= ilimit);\n\n_cleanup:\n         \n        rep[0] = offset_1 ? offset_1 : offsetSaved;\n        rep[1] = offset_2 ? offset_2 : offsetSaved;\n\n         \n        return (size_t)(iend - anchor);\n\n_search_next_long:\n\n         \n        if (idxl1 > prefixLowestIndex) {\n            if (MEM_read64(matchl1) == MEM_read64(ip1)) {\n                ip = ip1;\n                mLength = ZSTD_count(ip+8, matchl1+8, iend) + 8;\n                offset = (U32)(ip-matchl1);\n                while (((ip>anchor) & (matchl1>prefixLowest)) && (ip[-1] == matchl1[-1])) { ip--; matchl1--; mLength++; }  \n                goto _match_found;\n            }\n        }\n\n         \n        mLength = ZSTD_count(ip+4, matchs0+4, iend) + 4;\n        offset = (U32)(ip - matchs0);\n        while (((ip>anchor) & (matchs0>prefixLowest)) && (ip[-1] == matchs0[-1])) { ip--; matchs0--; mLength++; }  \n\n         \n\n_match_found:  \n        offset_2 = offset_1;\n        offset_1 = offset;\n\n        if (step < 4) {\n             \n            hashLong[hl1] = (U32)(ip1 - base);\n        }\n\n        ZSTD_storeSeq(seqStore, (size_t)(ip-anchor), anchor, iend, STORE_OFFSET(offset), mLength);\n\n_match_stored:\n         \n        ip += mLength;\n        anchor = ip;\n\n        if (ip <= ilimit) {\n             \n             \n            {   U32 const indexToInsert = curr+2;\n                hashLong[ZSTD_hashPtr(base+indexToInsert, hBitsL, 8)] = indexToInsert;\n                hashLong[ZSTD_hashPtr(ip-2, hBitsL, 8)] = (U32)(ip-2-base);\n                hashSmall[ZSTD_hashPtr(base+indexToInsert, hBitsS, mls)] = indexToInsert;\n                hashSmall[ZSTD_hashPtr(ip-1, hBitsS, mls)] = (U32)(ip-1-base);\n            }\n\n             \n            while ( (ip <= ilimit)\n                 && ( (offset_2>0)\n                    & (MEM_read32(ip) == MEM_read32(ip - offset_2)) )) {\n                 \n                size_t const rLength = ZSTD_count(ip+4, ip+4-offset_2, iend) + 4;\n                U32 const tmpOff = offset_2; offset_2 = offset_1; offset_1 = tmpOff;   \n                hashSmall[ZSTD_hashPtr(ip, hBitsS, mls)] = (U32)(ip-base);\n                hashLong[ZSTD_hashPtr(ip, hBitsL, 8)] = (U32)(ip-base);\n                ZSTD_storeSeq(seqStore, 0, anchor, iend, STORE_REPCODE_1, rLength);\n                ip += rLength;\n                anchor = ip;\n                continue;    \n            }\n        }\n    }\n}\n\n\nFORCE_INLINE_TEMPLATE\nsize_t ZSTD_compressBlock_doubleFast_dictMatchState_generic(\n        ZSTD_matchState_t* ms, seqStore_t* seqStore, U32 rep[ZSTD_REP_NUM],\n        void const* src, size_t srcSize,\n        U32 const mls  )\n{\n    ZSTD_compressionParameters const* cParams = &ms->cParams;\n    U32* const hashLong = ms->hashTable;\n    const U32 hBitsL = cParams->hashLog;\n    U32* const hashSmall = ms->chainTable;\n    const U32 hBitsS = cParams->chainLog;\n    const BYTE* const base = ms->window.base;\n    const BYTE* const istart = (const BYTE*)src;\n    const BYTE* ip = istart;\n    const BYTE* anchor = istart;\n    const U32 endIndex = (U32)((size_t)(istart - base) + srcSize);\n     \n    const U32 prefixLowestIndex = ZSTD_getLowestPrefixIndex(ms, endIndex, cParams->windowLog);\n    const BYTE* const prefixLowest = base + prefixLowestIndex;\n    const BYTE* const iend = istart + srcSize;\n    const BYTE* const ilimit = iend - HASH_READ_SIZE;\n    U32 offset_1=rep[0], offset_2=rep[1];\n    U32 offsetSaved = 0;\n\n    const ZSTD_matchState_t* const dms = ms->dictMatchState;\n    const ZSTD_compressionParameters* const dictCParams = &dms->cParams;\n    const U32* const dictHashLong  = dms->hashTable;\n    const U32* const dictHashSmall = dms->chainTable;\n    const U32 dictStartIndex       = dms->window.dictLimit;\n    const BYTE* const dictBase     = dms->window.base;\n    const BYTE* const dictStart    = dictBase + dictStartIndex;\n    const BYTE* const dictEnd      = dms->window.nextSrc;\n    const U32 dictIndexDelta       = prefixLowestIndex - (U32)(dictEnd - dictBase);\n    const U32 dictHBitsL           = dictCParams->hashLog;\n    const U32 dictHBitsS           = dictCParams->chainLog;\n    const U32 dictAndPrefixLength  = (U32)((ip - prefixLowest) + (dictEnd - dictStart));\n\n    DEBUGLOG(5, \"ZSTD_compressBlock_doubleFast_dictMatchState_generic\");\n\n     \n    assert(ms->window.dictLimit + (1U << cParams->windowLog) >= endIndex);\n\n     \n    ip += (dictAndPrefixLength == 0);\n\n     \n    assert(offset_1 <= dictAndPrefixLength);\n    assert(offset_2 <= dictAndPrefixLength);\n\n     \n    while (ip < ilimit) {    \n        size_t mLength;\n        U32 offset;\n        size_t const h2 = ZSTD_hashPtr(ip, hBitsL, 8);\n        size_t const h = ZSTD_hashPtr(ip, hBitsS, mls);\n        size_t const dictHL = ZSTD_hashPtr(ip, dictHBitsL, 8);\n        size_t const dictHS = ZSTD_hashPtr(ip, dictHBitsS, mls);\n        U32 const curr = (U32)(ip-base);\n        U32 const matchIndexL = hashLong[h2];\n        U32 matchIndexS = hashSmall[h];\n        const BYTE* matchLong = base + matchIndexL;\n        const BYTE* match = base + matchIndexS;\n        const U32 repIndex = curr + 1 - offset_1;\n        const BYTE* repMatch = (repIndex < prefixLowestIndex) ?\n                               dictBase + (repIndex - dictIndexDelta) :\n                               base + repIndex;\n        hashLong[h2] = hashSmall[h] = curr;    \n\n         \n        if (((U32)((prefixLowestIndex-1) - repIndex) >= 3  )\n            && (MEM_read32(repMatch) == MEM_read32(ip+1)) ) {\n            const BYTE* repMatchEnd = repIndex < prefixLowestIndex ? dictEnd : iend;\n            mLength = ZSTD_count_2segments(ip+1+4, repMatch+4, iend, repMatchEnd, prefixLowest) + 4;\n            ip++;\n            ZSTD_storeSeq(seqStore, (size_t)(ip-anchor), anchor, iend, STORE_REPCODE_1, mLength);\n            goto _match_stored;\n        }\n\n        if (matchIndexL > prefixLowestIndex) {\n             \n            if (MEM_read64(matchLong) == MEM_read64(ip)) {\n                mLength = ZSTD_count(ip+8, matchLong+8, iend) + 8;\n                offset = (U32)(ip-matchLong);\n                while (((ip>anchor) & (matchLong>prefixLowest)) && (ip[-1] == matchLong[-1])) { ip--; matchLong--; mLength++; }  \n                goto _match_found;\n            }\n        } else {\n             \n            U32 const dictMatchIndexL = dictHashLong[dictHL];\n            const BYTE* dictMatchL = dictBase + dictMatchIndexL;\n            assert(dictMatchL < dictEnd);\n\n            if (dictMatchL > dictStart && MEM_read64(dictMatchL) == MEM_read64(ip)) {\n                mLength = ZSTD_count_2segments(ip+8, dictMatchL+8, iend, dictEnd, prefixLowest) + 8;\n                offset = (U32)(curr - dictMatchIndexL - dictIndexDelta);\n                while (((ip>anchor) & (dictMatchL>dictStart)) && (ip[-1] == dictMatchL[-1])) { ip--; dictMatchL--; mLength++; }  \n                goto _match_found;\n        }   }\n\n        if (matchIndexS > prefixLowestIndex) {\n             \n            if (MEM_read32(match) == MEM_read32(ip)) {\n                goto _search_next_long;\n            }\n        } else {\n             \n            U32 const dictMatchIndexS = dictHashSmall[dictHS];\n            match = dictBase + dictMatchIndexS;\n            matchIndexS = dictMatchIndexS + dictIndexDelta;\n\n            if (match > dictStart && MEM_read32(match) == MEM_read32(ip)) {\n                goto _search_next_long;\n        }   }\n\n        ip += ((ip-anchor) >> kSearchStrength) + 1;\n#if defined(__aarch64__)\n        PREFETCH_L1(ip+256);\n#endif\n        continue;\n\n_search_next_long:\n\n        {   size_t const hl3 = ZSTD_hashPtr(ip+1, hBitsL, 8);\n            size_t const dictHLNext = ZSTD_hashPtr(ip+1, dictHBitsL, 8);\n            U32 const matchIndexL3 = hashLong[hl3];\n            const BYTE* matchL3 = base + matchIndexL3;\n            hashLong[hl3] = curr + 1;\n\n             \n            if (matchIndexL3 > prefixLowestIndex) {\n                if (MEM_read64(matchL3) == MEM_read64(ip+1)) {\n                    mLength = ZSTD_count(ip+9, matchL3+8, iend) + 8;\n                    ip++;\n                    offset = (U32)(ip-matchL3);\n                    while (((ip>anchor) & (matchL3>prefixLowest)) && (ip[-1] == matchL3[-1])) { ip--; matchL3--; mLength++; }  \n                    goto _match_found;\n                }\n            } else {\n                 \n                U32 const dictMatchIndexL3 = dictHashLong[dictHLNext];\n                const BYTE* dictMatchL3 = dictBase + dictMatchIndexL3;\n                assert(dictMatchL3 < dictEnd);\n                if (dictMatchL3 > dictStart && MEM_read64(dictMatchL3) == MEM_read64(ip+1)) {\n                    mLength = ZSTD_count_2segments(ip+1+8, dictMatchL3+8, iend, dictEnd, prefixLowest) + 8;\n                    ip++;\n                    offset = (U32)(curr + 1 - dictMatchIndexL3 - dictIndexDelta);\n                    while (((ip>anchor) & (dictMatchL3>dictStart)) && (ip[-1] == dictMatchL3[-1])) { ip--; dictMatchL3--; mLength++; }  \n                    goto _match_found;\n        }   }   }\n\n         \n        if (matchIndexS < prefixLowestIndex) {\n            mLength = ZSTD_count_2segments(ip+4, match+4, iend, dictEnd, prefixLowest) + 4;\n            offset = (U32)(curr - matchIndexS);\n            while (((ip>anchor) & (match>dictStart)) && (ip[-1] == match[-1])) { ip--; match--; mLength++; }  \n        } else {\n            mLength = ZSTD_count(ip+4, match+4, iend) + 4;\n            offset = (U32)(ip - match);\n            while (((ip>anchor) & (match>prefixLowest)) && (ip[-1] == match[-1])) { ip--; match--; mLength++; }  \n        }\n\n_match_found:\n        offset_2 = offset_1;\n        offset_1 = offset;\n\n        ZSTD_storeSeq(seqStore, (size_t)(ip-anchor), anchor, iend, STORE_OFFSET(offset), mLength);\n\n_match_stored:\n         \n        ip += mLength;\n        anchor = ip;\n\n        if (ip <= ilimit) {\n             \n             \n            {   U32 const indexToInsert = curr+2;\n                hashLong[ZSTD_hashPtr(base+indexToInsert, hBitsL, 8)] = indexToInsert;\n                hashLong[ZSTD_hashPtr(ip-2, hBitsL, 8)] = (U32)(ip-2-base);\n                hashSmall[ZSTD_hashPtr(base+indexToInsert, hBitsS, mls)] = indexToInsert;\n                hashSmall[ZSTD_hashPtr(ip-1, hBitsS, mls)] = (U32)(ip-1-base);\n            }\n\n             \n            while (ip <= ilimit) {\n                U32 const current2 = (U32)(ip-base);\n                U32 const repIndex2 = current2 - offset_2;\n                const BYTE* repMatch2 = repIndex2 < prefixLowestIndex ?\n                        dictBase + repIndex2 - dictIndexDelta :\n                        base + repIndex2;\n                if ( ((U32)((prefixLowestIndex-1) - (U32)repIndex2) >= 3  )\n                   && (MEM_read32(repMatch2) == MEM_read32(ip)) ) {\n                    const BYTE* const repEnd2 = repIndex2 < prefixLowestIndex ? dictEnd : iend;\n                    size_t const repLength2 = ZSTD_count_2segments(ip+4, repMatch2+4, iend, repEnd2, prefixLowest) + 4;\n                    U32 tmpOffset = offset_2; offset_2 = offset_1; offset_1 = tmpOffset;    \n                    ZSTD_storeSeq(seqStore, 0, anchor, iend, STORE_REPCODE_1, repLength2);\n                    hashSmall[ZSTD_hashPtr(ip, hBitsS, mls)] = current2;\n                    hashLong[ZSTD_hashPtr(ip, hBitsL, 8)] = current2;\n                    ip += repLength2;\n                    anchor = ip;\n                    continue;\n                }\n                break;\n            }\n        }\n    }    \n\n     \n    rep[0] = offset_1 ? offset_1 : offsetSaved;\n    rep[1] = offset_2 ? offset_2 : offsetSaved;\n\n     \n    return (size_t)(iend - anchor);\n}\n\n#define ZSTD_GEN_DFAST_FN(dictMode, mls)                                                                 \\\n    static size_t ZSTD_compressBlock_doubleFast_##dictMode##_##mls(                                      \\\n            ZSTD_matchState_t* ms, seqStore_t* seqStore, U32 rep[ZSTD_REP_NUM],                          \\\n            void const* src, size_t srcSize)                                                             \\\n    {                                                                                                    \\\n        return ZSTD_compressBlock_doubleFast_##dictMode##_generic(ms, seqStore, rep, src, srcSize, mls); \\\n    }\n\nZSTD_GEN_DFAST_FN(noDict, 4)\nZSTD_GEN_DFAST_FN(noDict, 5)\nZSTD_GEN_DFAST_FN(noDict, 6)\nZSTD_GEN_DFAST_FN(noDict, 7)\n\nZSTD_GEN_DFAST_FN(dictMatchState, 4)\nZSTD_GEN_DFAST_FN(dictMatchState, 5)\nZSTD_GEN_DFAST_FN(dictMatchState, 6)\nZSTD_GEN_DFAST_FN(dictMatchState, 7)\n\n\nsize_t ZSTD_compressBlock_doubleFast(\n        ZSTD_matchState_t* ms, seqStore_t* seqStore, U32 rep[ZSTD_REP_NUM],\n        void const* src, size_t srcSize)\n{\n    const U32 mls = ms->cParams.minMatch;\n    switch(mls)\n    {\n    default:  \n    case 4 :\n        return ZSTD_compressBlock_doubleFast_noDict_4(ms, seqStore, rep, src, srcSize);\n    case 5 :\n        return ZSTD_compressBlock_doubleFast_noDict_5(ms, seqStore, rep, src, srcSize);\n    case 6 :\n        return ZSTD_compressBlock_doubleFast_noDict_6(ms, seqStore, rep, src, srcSize);\n    case 7 :\n        return ZSTD_compressBlock_doubleFast_noDict_7(ms, seqStore, rep, src, srcSize);\n    }\n}\n\n\nsize_t ZSTD_compressBlock_doubleFast_dictMatchState(\n        ZSTD_matchState_t* ms, seqStore_t* seqStore, U32 rep[ZSTD_REP_NUM],\n        void const* src, size_t srcSize)\n{\n    const U32 mls = ms->cParams.minMatch;\n    switch(mls)\n    {\n    default:  \n    case 4 :\n        return ZSTD_compressBlock_doubleFast_dictMatchState_4(ms, seqStore, rep, src, srcSize);\n    case 5 :\n        return ZSTD_compressBlock_doubleFast_dictMatchState_5(ms, seqStore, rep, src, srcSize);\n    case 6 :\n        return ZSTD_compressBlock_doubleFast_dictMatchState_6(ms, seqStore, rep, src, srcSize);\n    case 7 :\n        return ZSTD_compressBlock_doubleFast_dictMatchState_7(ms, seqStore, rep, src, srcSize);\n    }\n}\n\n\nstatic size_t ZSTD_compressBlock_doubleFast_extDict_generic(\n        ZSTD_matchState_t* ms, seqStore_t* seqStore, U32 rep[ZSTD_REP_NUM],\n        void const* src, size_t srcSize,\n        U32 const mls  )\n{\n    ZSTD_compressionParameters const* cParams = &ms->cParams;\n    U32* const hashLong = ms->hashTable;\n    U32  const hBitsL = cParams->hashLog;\n    U32* const hashSmall = ms->chainTable;\n    U32  const hBitsS = cParams->chainLog;\n    const BYTE* const istart = (const BYTE*)src;\n    const BYTE* ip = istart;\n    const BYTE* anchor = istart;\n    const BYTE* const iend = istart + srcSize;\n    const BYTE* const ilimit = iend - 8;\n    const BYTE* const base = ms->window.base;\n    const U32   endIndex = (U32)((size_t)(istart - base) + srcSize);\n    const U32   lowLimit = ZSTD_getLowestMatchIndex(ms, endIndex, cParams->windowLog);\n    const U32   dictStartIndex = lowLimit;\n    const U32   dictLimit = ms->window.dictLimit;\n    const U32   prefixStartIndex = (dictLimit > lowLimit) ? dictLimit : lowLimit;\n    const BYTE* const prefixStart = base + prefixStartIndex;\n    const BYTE* const dictBase = ms->window.dictBase;\n    const BYTE* const dictStart = dictBase + dictStartIndex;\n    const BYTE* const dictEnd = dictBase + prefixStartIndex;\n    U32 offset_1=rep[0], offset_2=rep[1];\n\n    DEBUGLOG(5, \"ZSTD_compressBlock_doubleFast_extDict_generic (srcSize=%zu)\", srcSize);\n\n     \n    if (prefixStartIndex == dictStartIndex)\n        return ZSTD_compressBlock_doubleFast(ms, seqStore, rep, src, srcSize);\n\n     \n    while (ip < ilimit) {   \n        const size_t hSmall = ZSTD_hashPtr(ip, hBitsS, mls);\n        const U32 matchIndex = hashSmall[hSmall];\n        const BYTE* const matchBase = matchIndex < prefixStartIndex ? dictBase : base;\n        const BYTE* match = matchBase + matchIndex;\n\n        const size_t hLong = ZSTD_hashPtr(ip, hBitsL, 8);\n        const U32 matchLongIndex = hashLong[hLong];\n        const BYTE* const matchLongBase = matchLongIndex < prefixStartIndex ? dictBase : base;\n        const BYTE* matchLong = matchLongBase + matchLongIndex;\n\n        const U32 curr = (U32)(ip-base);\n        const U32 repIndex = curr + 1 - offset_1;    \n        const BYTE* const repBase = repIndex < prefixStartIndex ? dictBase : base;\n        const BYTE* const repMatch = repBase + repIndex;\n        size_t mLength;\n        hashSmall[hSmall] = hashLong[hLong] = curr;    \n\n        if ((((U32)((prefixStartIndex-1) - repIndex) >= 3)  \n            & (offset_1 <= curr+1 - dictStartIndex))  \n          && (MEM_read32(repMatch) == MEM_read32(ip+1)) ) {\n            const BYTE* repMatchEnd = repIndex < prefixStartIndex ? dictEnd : iend;\n            mLength = ZSTD_count_2segments(ip+1+4, repMatch+4, iend, repMatchEnd, prefixStart) + 4;\n            ip++;\n            ZSTD_storeSeq(seqStore, (size_t)(ip-anchor), anchor, iend, STORE_REPCODE_1, mLength);\n        } else {\n            if ((matchLongIndex > dictStartIndex) && (MEM_read64(matchLong) == MEM_read64(ip))) {\n                const BYTE* const matchEnd = matchLongIndex < prefixStartIndex ? dictEnd : iend;\n                const BYTE* const lowMatchPtr = matchLongIndex < prefixStartIndex ? dictStart : prefixStart;\n                U32 offset;\n                mLength = ZSTD_count_2segments(ip+8, matchLong+8, iend, matchEnd, prefixStart) + 8;\n                offset = curr - matchLongIndex;\n                while (((ip>anchor) & (matchLong>lowMatchPtr)) && (ip[-1] == matchLong[-1])) { ip--; matchLong--; mLength++; }    \n                offset_2 = offset_1;\n                offset_1 = offset;\n                ZSTD_storeSeq(seqStore, (size_t)(ip-anchor), anchor, iend, STORE_OFFSET(offset), mLength);\n\n            } else if ((matchIndex > dictStartIndex) && (MEM_read32(match) == MEM_read32(ip))) {\n                size_t const h3 = ZSTD_hashPtr(ip+1, hBitsL, 8);\n                U32 const matchIndex3 = hashLong[h3];\n                const BYTE* const match3Base = matchIndex3 < prefixStartIndex ? dictBase : base;\n                const BYTE* match3 = match3Base + matchIndex3;\n                U32 offset;\n                hashLong[h3] = curr + 1;\n                if ( (matchIndex3 > dictStartIndex) && (MEM_read64(match3) == MEM_read64(ip+1)) ) {\n                    const BYTE* const matchEnd = matchIndex3 < prefixStartIndex ? dictEnd : iend;\n                    const BYTE* const lowMatchPtr = matchIndex3 < prefixStartIndex ? dictStart : prefixStart;\n                    mLength = ZSTD_count_2segments(ip+9, match3+8, iend, matchEnd, prefixStart) + 8;\n                    ip++;\n                    offset = curr+1 - matchIndex3;\n                    while (((ip>anchor) & (match3>lowMatchPtr)) && (ip[-1] == match3[-1])) { ip--; match3--; mLength++; }  \n                } else {\n                    const BYTE* const matchEnd = matchIndex < prefixStartIndex ? dictEnd : iend;\n                    const BYTE* const lowMatchPtr = matchIndex < prefixStartIndex ? dictStart : prefixStart;\n                    mLength = ZSTD_count_2segments(ip+4, match+4, iend, matchEnd, prefixStart) + 4;\n                    offset = curr - matchIndex;\n                    while (((ip>anchor) & (match>lowMatchPtr)) && (ip[-1] == match[-1])) { ip--; match--; mLength++; }    \n                }\n                offset_2 = offset_1;\n                offset_1 = offset;\n                ZSTD_storeSeq(seqStore, (size_t)(ip-anchor), anchor, iend, STORE_OFFSET(offset), mLength);\n\n            } else {\n                ip += ((ip-anchor) >> kSearchStrength) + 1;\n                continue;\n        }   }\n\n         \n        ip += mLength;\n        anchor = ip;\n\n        if (ip <= ilimit) {\n             \n             \n            {   U32 const indexToInsert = curr+2;\n                hashLong[ZSTD_hashPtr(base+indexToInsert, hBitsL, 8)] = indexToInsert;\n                hashLong[ZSTD_hashPtr(ip-2, hBitsL, 8)] = (U32)(ip-2-base);\n                hashSmall[ZSTD_hashPtr(base+indexToInsert, hBitsS, mls)] = indexToInsert;\n                hashSmall[ZSTD_hashPtr(ip-1, hBitsS, mls)] = (U32)(ip-1-base);\n            }\n\n             \n            while (ip <= ilimit) {\n                U32 const current2 = (U32)(ip-base);\n                U32 const repIndex2 = current2 - offset_2;\n                const BYTE* repMatch2 = repIndex2 < prefixStartIndex ? dictBase + repIndex2 : base + repIndex2;\n                if ( (((U32)((prefixStartIndex-1) - repIndex2) >= 3)    \n                    & (offset_2 <= current2 - dictStartIndex))\n                  && (MEM_read32(repMatch2) == MEM_read32(ip)) ) {\n                    const BYTE* const repEnd2 = repIndex2 < prefixStartIndex ? dictEnd : iend;\n                    size_t const repLength2 = ZSTD_count_2segments(ip+4, repMatch2+4, iend, repEnd2, prefixStart) + 4;\n                    U32 const tmpOffset = offset_2; offset_2 = offset_1; offset_1 = tmpOffset;    \n                    ZSTD_storeSeq(seqStore, 0, anchor, iend, STORE_REPCODE_1, repLength2);\n                    hashSmall[ZSTD_hashPtr(ip, hBitsS, mls)] = current2;\n                    hashLong[ZSTD_hashPtr(ip, hBitsL, 8)] = current2;\n                    ip += repLength2;\n                    anchor = ip;\n                    continue;\n                }\n                break;\n    }   }   }\n\n     \n    rep[0] = offset_1;\n    rep[1] = offset_2;\n\n     \n    return (size_t)(iend - anchor);\n}\n\nZSTD_GEN_DFAST_FN(extDict, 4)\nZSTD_GEN_DFAST_FN(extDict, 5)\nZSTD_GEN_DFAST_FN(extDict, 6)\nZSTD_GEN_DFAST_FN(extDict, 7)\n\nsize_t ZSTD_compressBlock_doubleFast_extDict(\n        ZSTD_matchState_t* ms, seqStore_t* seqStore, U32 rep[ZSTD_REP_NUM],\n        void const* src, size_t srcSize)\n{\n    U32 const mls = ms->cParams.minMatch;\n    switch(mls)\n    {\n    default:  \n    case 4 :\n        return ZSTD_compressBlock_doubleFast_extDict_4(ms, seqStore, rep, src, srcSize);\n    case 5 :\n        return ZSTD_compressBlock_doubleFast_extDict_5(ms, seqStore, rep, src, srcSize);\n    case 6 :\n        return ZSTD_compressBlock_doubleFast_extDict_6(ms, seqStore, rep, src, srcSize);\n    case 7 :\n        return ZSTD_compressBlock_doubleFast_extDict_7(ms, seqStore, rep, src, srcSize);\n    }\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}