{
  "module_name": "linear_ranges.c",
  "hash_id": "ebc4ff89f53a44608629fac14f64555c671af213ac3d60a88d0e5b1b02a2126a",
  "original_prompt": "Ingested from linux-6.6.14/lib/linear_ranges.c",
  "human_readable_source": "\n \n\n#include <linux/errno.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/linear_range.h>\n#include <linux/module.h>\n\n \nunsigned int linear_range_values_in_range(const struct linear_range *r)\n{\n\tif (!r)\n\t\treturn 0;\n\treturn r->max_sel - r->min_sel + 1;\n}\nEXPORT_SYMBOL_GPL(linear_range_values_in_range);\n\n \nunsigned int linear_range_values_in_range_array(const struct linear_range *r,\n\t\t\t\t\t\tint ranges)\n{\n\tint i, values_in_range = 0;\n\n\tfor (i = 0; i < ranges; i++) {\n\t\tint values;\n\n\t\tvalues = linear_range_values_in_range(&r[i]);\n\t\tif (!values)\n\t\t\treturn values;\n\n\t\tvalues_in_range += values;\n\t}\n\treturn values_in_range;\n}\nEXPORT_SYMBOL_GPL(linear_range_values_in_range_array);\n\n \nunsigned int linear_range_get_max_value(const struct linear_range *r)\n{\n\treturn r->min + (r->max_sel - r->min_sel) * r->step;\n}\nEXPORT_SYMBOL_GPL(linear_range_get_max_value);\n\n \nint linear_range_get_value(const struct linear_range *r, unsigned int selector,\n\t\t\t   unsigned int *val)\n{\n\tif (r->min_sel > selector || r->max_sel < selector)\n\t\treturn -EINVAL;\n\n\t*val = r->min + (selector - r->min_sel) * r->step;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(linear_range_get_value);\n\n \nint linear_range_get_value_array(const struct linear_range *r, int ranges,\n\t\t\t\t unsigned int selector, unsigned int *val)\n{\n\tint i;\n\n\tfor (i = 0; i < ranges; i++)\n\t\tif (r[i].min_sel <= selector && r[i].max_sel >= selector)\n\t\t\treturn linear_range_get_value(&r[i], selector, val);\n\n\treturn -EINVAL;\n}\nEXPORT_SYMBOL_GPL(linear_range_get_value_array);\n\n \nint linear_range_get_selector_low(const struct linear_range *r,\n\t\t\t\t  unsigned int val, unsigned int *selector,\n\t\t\t\t  bool *found)\n{\n\t*found = false;\n\n\tif (r->min > val)\n\t\treturn -EINVAL;\n\n\tif (linear_range_get_max_value(r) < val) {\n\t\t*selector = r->max_sel;\n\t\treturn 0;\n\t}\n\n\t*found = true;\n\n\tif (r->step == 0)\n\t\t*selector = r->min_sel;\n\telse\n\t\t*selector = (val - r->min) / r->step + r->min_sel;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(linear_range_get_selector_low);\n\n \nint linear_range_get_selector_low_array(const struct linear_range *r,\n\t\t\t\t\tint ranges, unsigned int val,\n\t\t\t\t\tunsigned int *selector, bool *found)\n{\n\tint i;\n\tint ret = -EINVAL;\n\n\tfor (i = 0; i < ranges; i++) {\n\t\tint tmpret;\n\n\t\ttmpret = linear_range_get_selector_low(&r[i], val, selector,\n\t\t\t\t\t\t       found);\n\t\tif (!tmpret)\n\t\t\tret = 0;\n\n\t\tif (*found)\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(linear_range_get_selector_low_array);\n\n \nint linear_range_get_selector_high(const struct linear_range *r,\n\t\t\t\t   unsigned int val, unsigned int *selector,\n\t\t\t\t   bool *found)\n{\n\t*found = false;\n\n\tif (linear_range_get_max_value(r) < val)\n\t\treturn -EINVAL;\n\n\tif (r->min > val) {\n\t\t*selector = r->min_sel;\n\t\treturn 0;\n\t}\n\n\t*found = true;\n\n\tif (r->step == 0)\n\t\t*selector = r->max_sel;\n\telse\n\t\t*selector = DIV_ROUND_UP(val - r->min, r->step) + r->min_sel;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(linear_range_get_selector_high);\n\n \nvoid linear_range_get_selector_within(const struct linear_range *r,\n\t\t\t\t      unsigned int val, unsigned int *selector)\n{\n\tif (r->min > val) {\n\t\t*selector = r->min_sel;\n\t\treturn;\n\t}\n\n\tif (linear_range_get_max_value(r) < val) {\n\t\t*selector = r->max_sel;\n\t\treturn;\n\t}\n\n\tif (r->step == 0)\n\t\t*selector = r->min_sel;\n\telse\n\t\t*selector = (val - r->min) / r->step + r->min_sel;\n}\nEXPORT_SYMBOL_GPL(linear_range_get_selector_within);\n\nMODULE_DESCRIPTION(\"linear-ranges helper\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}