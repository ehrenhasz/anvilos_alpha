{
  "module_name": "crc32.c",
  "hash_id": "a1019244a3e0c2e32286073cf7f3272cd7056d8a8706cba1b2feb67a246dcc4d",
  "original_prompt": "Ingested from linux-6.6.14/lib/crc32.c",
  "human_readable_source": " \n\n \n\n#include <linux/crc32.h>\n#include <linux/crc32poly.h>\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/sched.h>\n#include \"crc32defs.h\"\n\n#if CRC_LE_BITS > 8\n# define tole(x) ((__force u32) cpu_to_le32(x))\n#else\n# define tole(x) (x)\n#endif\n\n#if CRC_BE_BITS > 8\n# define tobe(x) ((__force u32) cpu_to_be32(x))\n#else\n# define tobe(x) (x)\n#endif\n\n#include \"crc32table.h\"\n\nMODULE_AUTHOR(\"Matt Domsch <Matt_Domsch@dell.com>\");\nMODULE_DESCRIPTION(\"Various CRC32 calculations\");\nMODULE_LICENSE(\"GPL\");\n\n#if CRC_LE_BITS > 8 || CRC_BE_BITS > 8\n\n \nstatic inline u32 __pure\ncrc32_body(u32 crc, unsigned char const *buf, size_t len, const u32 (*tab)[256])\n{\n# ifdef __LITTLE_ENDIAN\n#  define DO_CRC(x) crc = t0[(crc ^ (x)) & 255] ^ (crc >> 8)\n#  define DO_CRC4 (t3[(q) & 255] ^ t2[(q >> 8) & 255] ^ \\\n\t\t   t1[(q >> 16) & 255] ^ t0[(q >> 24) & 255])\n#  define DO_CRC8 (t7[(q) & 255] ^ t6[(q >> 8) & 255] ^ \\\n\t\t   t5[(q >> 16) & 255] ^ t4[(q >> 24) & 255])\n# else\n#  define DO_CRC(x) crc = t0[((crc >> 24) ^ (x)) & 255] ^ (crc << 8)\n#  define DO_CRC4 (t0[(q) & 255] ^ t1[(q >> 8) & 255] ^ \\\n\t\t   t2[(q >> 16) & 255] ^ t3[(q >> 24) & 255])\n#  define DO_CRC8 (t4[(q) & 255] ^ t5[(q >> 8) & 255] ^ \\\n\t\t   t6[(q >> 16) & 255] ^ t7[(q >> 24) & 255])\n# endif\n\tconst u32 *b;\n\tsize_t    rem_len;\n# ifdef CONFIG_X86\n\tsize_t i;\n# endif\n\tconst u32 *t0=tab[0], *t1=tab[1], *t2=tab[2], *t3=tab[3];\n# if CRC_LE_BITS != 32\n\tconst u32 *t4 = tab[4], *t5 = tab[5], *t6 = tab[6], *t7 = tab[7];\n# endif\n\tu32 q;\n\n\t \n\tif (unlikely((long)buf & 3 && len)) {\n\t\tdo {\n\t\t\tDO_CRC(*buf++);\n\t\t} while ((--len) && ((long)buf)&3);\n\t}\n\n# if CRC_LE_BITS == 32\n\trem_len = len & 3;\n\tlen = len >> 2;\n# else\n\trem_len = len & 7;\n\tlen = len >> 3;\n# endif\n\n\tb = (const u32 *)buf;\n# ifdef CONFIG_X86\n\t--b;\n\tfor (i = 0; i < len; i++) {\n# else\n\tfor (--b; len; --len) {\n# endif\n\t\tq = crc ^ *++b;  \n# if CRC_LE_BITS == 32\n\t\tcrc = DO_CRC4;\n# else\n\t\tcrc = DO_CRC8;\n\t\tq = *++b;\n\t\tcrc ^= DO_CRC4;\n# endif\n\t}\n\tlen = rem_len;\n\t \n\tif (len) {\n\t\tu8 *p = (u8 *)(b + 1) - 1;\n# ifdef CONFIG_X86\n\t\tfor (i = 0; i < len; i++)\n\t\t\tDO_CRC(*++p);  \n# else\n\t\tdo {\n\t\t\tDO_CRC(*++p);  \n\t\t} while (--len);\n# endif\n\t}\n\treturn crc;\n#undef DO_CRC\n#undef DO_CRC4\n#undef DO_CRC8\n}\n#endif\n\n\n \nstatic inline u32 __pure crc32_le_generic(u32 crc, unsigned char const *p,\n\t\t\t\t\t  size_t len, const u32 (*tab)[256],\n\t\t\t\t\t  u32 polynomial)\n{\n#if CRC_LE_BITS == 1\n\tint i;\n\twhile (len--) {\n\t\tcrc ^= *p++;\n\t\tfor (i = 0; i < 8; i++)\n\t\t\tcrc = (crc >> 1) ^ ((crc & 1) ? polynomial : 0);\n\t}\n# elif CRC_LE_BITS == 2\n\twhile (len--) {\n\t\tcrc ^= *p++;\n\t\tcrc = (crc >> 2) ^ tab[0][crc & 3];\n\t\tcrc = (crc >> 2) ^ tab[0][crc & 3];\n\t\tcrc = (crc >> 2) ^ tab[0][crc & 3];\n\t\tcrc = (crc >> 2) ^ tab[0][crc & 3];\n\t}\n# elif CRC_LE_BITS == 4\n\twhile (len--) {\n\t\tcrc ^= *p++;\n\t\tcrc = (crc >> 4) ^ tab[0][crc & 15];\n\t\tcrc = (crc >> 4) ^ tab[0][crc & 15];\n\t}\n# elif CRC_LE_BITS == 8\n\t \n\twhile (len--) {\n\t\tcrc ^= *p++;\n\t\tcrc = (crc >> 8) ^ tab[0][crc & 255];\n\t}\n# else\n\tcrc = (__force u32) __cpu_to_le32(crc);\n\tcrc = crc32_body(crc, p, len, tab);\n\tcrc = __le32_to_cpu((__force __le32)crc);\n#endif\n\treturn crc;\n}\n\n#if CRC_LE_BITS == 1\nu32 __pure __weak crc32_le(u32 crc, unsigned char const *p, size_t len)\n{\n\treturn crc32_le_generic(crc, p, len, NULL, CRC32_POLY_LE);\n}\nu32 __pure __weak __crc32c_le(u32 crc, unsigned char const *p, size_t len)\n{\n\treturn crc32_le_generic(crc, p, len, NULL, CRC32C_POLY_LE);\n}\n#else\nu32 __pure __weak crc32_le(u32 crc, unsigned char const *p, size_t len)\n{\n\treturn crc32_le_generic(crc, p, len, crc32table_le, CRC32_POLY_LE);\n}\nu32 __pure __weak __crc32c_le(u32 crc, unsigned char const *p, size_t len)\n{\n\treturn crc32_le_generic(crc, p, len, crc32ctable_le, CRC32C_POLY_LE);\n}\n#endif\nEXPORT_SYMBOL(crc32_le);\nEXPORT_SYMBOL(__crc32c_le);\n\nu32 __pure crc32_le_base(u32, unsigned char const *, size_t) __alias(crc32_le);\nu32 __pure __crc32c_le_base(u32, unsigned char const *, size_t) __alias(__crc32c_le);\nu32 __pure crc32_be_base(u32, unsigned char const *, size_t) __alias(crc32_be);\n\n \nstatic u32 __attribute_const__ gf2_multiply(u32 x, u32 y, u32 modulus)\n{\n\tu32 product = x & 1 ? y : 0;\n\tint i;\n\n\tfor (i = 0; i < 31; i++) {\n\t\tproduct = (product >> 1) ^ (product & 1 ? modulus : 0);\n\t\tx >>= 1;\n\t\tproduct ^= x & 1 ? y : 0;\n\t}\n\n\treturn product;\n}\n\n \nstatic u32 __attribute_const__ crc32_generic_shift(u32 crc, size_t len,\n\t\t\t\t\t\t   u32 polynomial)\n{\n\tu32 power = polynomial;\t \n\tint i;\n\n\t \n\tfor (i = 0; i < 8 * (int)(len & 3); i++)\n\t\tcrc = (crc >> 1) ^ (crc & 1 ? polynomial : 0);\n\n\tlen >>= 2;\n\tif (!len)\n\t\treturn crc;\n\n\tfor (;;) {\n\t\t \n\t\tif (len & 1)\n\t\t\tcrc = gf2_multiply(crc, power, polynomial);\n\n\t\tlen >>= 1;\n\t\tif (!len)\n\t\t\tbreak;\n\n\t\t \n\t\tpower = gf2_multiply(power, power, polynomial);\n\t}\n\n\treturn crc;\n}\n\nu32 __attribute_const__ crc32_le_shift(u32 crc, size_t len)\n{\n\treturn crc32_generic_shift(crc, len, CRC32_POLY_LE);\n}\n\nu32 __attribute_const__ __crc32c_le_shift(u32 crc, size_t len)\n{\n\treturn crc32_generic_shift(crc, len, CRC32C_POLY_LE);\n}\nEXPORT_SYMBOL(crc32_le_shift);\nEXPORT_SYMBOL(__crc32c_le_shift);\n\n \nstatic inline u32 __pure crc32_be_generic(u32 crc, unsigned char const *p,\n\t\t\t\t\t  size_t len, const u32 (*tab)[256],\n\t\t\t\t\t  u32 polynomial)\n{\n#if CRC_BE_BITS == 1\n\tint i;\n\twhile (len--) {\n\t\tcrc ^= *p++ << 24;\n\t\tfor (i = 0; i < 8; i++)\n\t\t\tcrc =\n\t\t\t    (crc << 1) ^ ((crc & 0x80000000) ? polynomial :\n\t\t\t\t\t  0);\n\t}\n# elif CRC_BE_BITS == 2\n\twhile (len--) {\n\t\tcrc ^= *p++ << 24;\n\t\tcrc = (crc << 2) ^ tab[0][crc >> 30];\n\t\tcrc = (crc << 2) ^ tab[0][crc >> 30];\n\t\tcrc = (crc << 2) ^ tab[0][crc >> 30];\n\t\tcrc = (crc << 2) ^ tab[0][crc >> 30];\n\t}\n# elif CRC_BE_BITS == 4\n\twhile (len--) {\n\t\tcrc ^= *p++ << 24;\n\t\tcrc = (crc << 4) ^ tab[0][crc >> 28];\n\t\tcrc = (crc << 4) ^ tab[0][crc >> 28];\n\t}\n# elif CRC_BE_BITS == 8\n\twhile (len--) {\n\t\tcrc ^= *p++ << 24;\n\t\tcrc = (crc << 8) ^ tab[0][crc >> 24];\n\t}\n# else\n\tcrc = (__force u32) __cpu_to_be32(crc);\n\tcrc = crc32_body(crc, p, len, tab);\n\tcrc = __be32_to_cpu((__force __be32)crc);\n# endif\n\treturn crc;\n}\n\n#if CRC_BE_BITS == 1\nu32 __pure __weak crc32_be(u32 crc, unsigned char const *p, size_t len)\n{\n\treturn crc32_be_generic(crc, p, len, NULL, CRC32_POLY_BE);\n}\n#else\nu32 __pure __weak crc32_be(u32 crc, unsigned char const *p, size_t len)\n{\n\treturn crc32_be_generic(crc, p, len, crc32table_be, CRC32_POLY_BE);\n}\n#endif\nEXPORT_SYMBOL(crc32_be);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}