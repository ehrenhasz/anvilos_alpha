{
  "module_name": "oid_registry.c",
  "hash_id": "3821f822d82d9c51a641ff786777baaeca9a7ec6d0f9ea031a568df295991f53",
  "original_prompt": "Ingested from linux-6.6.14/lib/oid_registry.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/export.h>\n#include <linux/oid_registry.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/bug.h>\n#include <linux/asn1.h>\n#include \"oid_registry_data.c\"\n\nMODULE_DESCRIPTION(\"OID Registry\");\nMODULE_AUTHOR(\"Red Hat, Inc.\");\nMODULE_LICENSE(\"GPL\");\n\n \nenum OID look_up_OID(const void *data, size_t datasize)\n{\n\tconst unsigned char *octets = data;\n\tenum OID oid;\n\tunsigned char xhash;\n\tunsigned i, j, k, hash;\n\tsize_t len;\n\n\t \n\thash = datasize - 1;\n\n\tfor (i = 0; i < datasize; i++)\n\t\thash += octets[i] * 33;\n\thash = (hash >> 24) ^ (hash >> 16) ^ (hash >> 8) ^ hash;\n\thash &= 0xff;\n\n\t \n\ti = 0;\n\tk = OID__NR;\n\twhile (i < k) {\n\t\tj = (i + k) / 2;\n\n\t\txhash = oid_search_table[j].hash;\n\t\tif (xhash > hash) {\n\t\t\tk = j;\n\t\t\tcontinue;\n\t\t}\n\t\tif (xhash < hash) {\n\t\t\ti = j + 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\toid = oid_search_table[j].oid;\n\t\tlen = oid_index[oid + 1] - oid_index[oid];\n\t\tif (len > datasize) {\n\t\t\tk = j;\n\t\t\tcontinue;\n\t\t}\n\t\tif (len < datasize) {\n\t\t\ti = j + 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\twhile (len > 0) {\n\t\t\tunsigned char a = oid_data[oid_index[oid] + --len];\n\t\t\tunsigned char b = octets[len];\n\t\t\tif (a > b) {\n\t\t\t\tk = j;\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t\tif (a < b) {\n\t\t\t\ti = j + 1;\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t}\n\t\treturn oid;\n\tnext:\n\t\t;\n\t}\n\n\treturn OID__NR;\n}\nEXPORT_SYMBOL_GPL(look_up_OID);\n\n \nint parse_OID(const void *data, size_t datasize, enum OID *oid)\n{\n\tconst unsigned char *v = data;\n\n\t \n\tif (datasize < 3 || v[0] != ASN1_OID || v[1] != datasize - 2)\n\t\treturn -EBADMSG;\n\n\t*oid = look_up_OID(data + 2, datasize - 2);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(parse_OID);\n\n \nint sprint_oid(const void *data, size_t datasize, char *buffer, size_t bufsize)\n{\n\tconst unsigned char *v = data, *end = v + datasize;\n\tunsigned long num;\n\tunsigned char n;\n\tsize_t ret;\n\tint count;\n\n\tif (v >= end)\n\t\tgoto bad;\n\n\tn = *v++;\n\tret = count = snprintf(buffer, bufsize, \"%u.%u\", n / 40, n % 40);\n\tif (count >= bufsize)\n\t\treturn -ENOBUFS;\n\tbuffer += count;\n\tbufsize -= count;\n\n\twhile (v < end) {\n\t\tn = *v++;\n\t\tif (!(n & 0x80)) {\n\t\t\tnum = n;\n\t\t} else {\n\t\t\tnum = n & 0x7f;\n\t\t\tdo {\n\t\t\t\tif (v >= end)\n\t\t\t\t\tgoto bad;\n\t\t\t\tn = *v++;\n\t\t\t\tnum <<= 7;\n\t\t\t\tnum |= n & 0x7f;\n\t\t\t} while (n & 0x80);\n\t\t}\n\t\tret += count = snprintf(buffer, bufsize, \".%lu\", num);\n\t\tif (count >= bufsize)\n\t\t\treturn -ENOBUFS;\n\t\tbuffer += count;\n\t\tbufsize -= count;\n\t}\n\n\treturn ret;\n\nbad:\n\tsnprintf(buffer, bufsize, \"(bad)\");\n\treturn -EBADMSG;\n}\nEXPORT_SYMBOL_GPL(sprint_oid);\n\n \nint sprint_OID(enum OID oid, char *buffer, size_t bufsize)\n{\n\tint ret;\n\n\tBUG_ON(oid >= OID__NR);\n\n\tret = sprint_oid(oid_data + oid_index[oid],\n\t\t\t oid_index[oid + 1] - oid_index[oid],\n\t\t\t buffer, bufsize);\n\tBUG_ON(ret == -EBADMSG);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(sprint_OID);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}