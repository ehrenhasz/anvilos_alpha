{
  "module_name": "interval_tree_test.c",
  "hash_id": "cfdc109cdcdadcb683504fde200c589ef0e38065ec31d81672e475354e443d86",
  "original_prompt": "Ingested from linux-6.6.14/lib/interval_tree_test.c",
  "human_readable_source": "\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/interval_tree.h>\n#include <linux/random.h>\n#include <linux/slab.h>\n#include <asm/timex.h>\n\n#define __param(type, name, init, msg)\t\t\\\n\tstatic type name = init;\t\t\\\n\tmodule_param(name, type, 0444);\t\t\\\n\tMODULE_PARM_DESC(name, msg);\n\n__param(int, nnodes, 100, \"Number of nodes in the interval tree\");\n__param(int, perf_loops, 1000, \"Number of iterations modifying the tree\");\n\n__param(int, nsearches, 100, \"Number of searches to the interval tree\");\n__param(int, search_loops, 1000, \"Number of iterations searching the tree\");\n__param(bool, search_all, false, \"Searches will iterate all nodes in the tree\");\n\n__param(uint, max_endpoint, ~0, \"Largest value for the interval's endpoint\");\n\nstatic struct rb_root_cached root = RB_ROOT_CACHED;\nstatic struct interval_tree_node *nodes = NULL;\nstatic u32 *queries = NULL;\n\nstatic struct rnd_state rnd;\n\nstatic inline unsigned long\nsearch(struct rb_root_cached *root, unsigned long start, unsigned long last)\n{\n\tstruct interval_tree_node *node;\n\tunsigned long results = 0;\n\n\tfor (node = interval_tree_iter_first(root, start, last); node;\n\t     node = interval_tree_iter_next(node, start, last))\n\t\tresults++;\n\treturn results;\n}\n\nstatic void init(void)\n{\n\tint i;\n\n\tfor (i = 0; i < nnodes; i++) {\n\t\tu32 b = (prandom_u32_state(&rnd) >> 4) % max_endpoint;\n\t\tu32 a = (prandom_u32_state(&rnd) >> 4) % b;\n\n\t\tnodes[i].start = a;\n\t\tnodes[i].last = b;\n\t}\n\n\t \n\tfor (i = 0; i < nsearches; i++)\n\t\tqueries[i] = (prandom_u32_state(&rnd) >> 4) % max_endpoint;\n}\n\nstatic int interval_tree_test_init(void)\n{\n\tint i, j;\n\tunsigned long results;\n\tcycles_t time1, time2, time;\n\n\tnodes = kmalloc_array(nnodes, sizeof(struct interval_tree_node),\n\t\t\t      GFP_KERNEL);\n\tif (!nodes)\n\t\treturn -ENOMEM;\n\n\tqueries = kmalloc_array(nsearches, sizeof(int), GFP_KERNEL);\n\tif (!queries) {\n\t\tkfree(nodes);\n\t\treturn -ENOMEM;\n\t}\n\n\tprintk(KERN_ALERT \"interval tree insert/remove\");\n\n\tprandom_seed_state(&rnd, 3141592653589793238ULL);\n\tinit();\n\n\ttime1 = get_cycles();\n\n\tfor (i = 0; i < perf_loops; i++) {\n\t\tfor (j = 0; j < nnodes; j++)\n\t\t\tinterval_tree_insert(nodes + j, &root);\n\t\tfor (j = 0; j < nnodes; j++)\n\t\t\tinterval_tree_remove(nodes + j, &root);\n\t}\n\n\ttime2 = get_cycles();\n\ttime = time2 - time1;\n\n\ttime = div_u64(time, perf_loops);\n\tprintk(\" -> %llu cycles\\n\", (unsigned long long)time);\n\n\tprintk(KERN_ALERT \"interval tree search\");\n\n\tfor (j = 0; j < nnodes; j++)\n\t\tinterval_tree_insert(nodes + j, &root);\n\n\ttime1 = get_cycles();\n\n\tresults = 0;\n\tfor (i = 0; i < search_loops; i++)\n\t\tfor (j = 0; j < nsearches; j++) {\n\t\t\tunsigned long start = search_all ? 0 : queries[j];\n\t\t\tunsigned long last = search_all ? max_endpoint : queries[j];\n\n\t\t\tresults += search(&root, start, last);\n\t\t}\n\n\ttime2 = get_cycles();\n\ttime = time2 - time1;\n\n\ttime = div_u64(time, search_loops);\n\tresults = div_u64(results, search_loops);\n\tprintk(\" -> %llu cycles (%lu results)\\n\",\n\t       (unsigned long long)time, results);\n\n\tkfree(queries);\n\tkfree(nodes);\n\n\treturn -EAGAIN;  \n}\n\nstatic void interval_tree_test_exit(void)\n{\n\tprintk(KERN_ALERT \"test exit\\n\");\n}\n\nmodule_init(interval_tree_test_init)\nmodule_exit(interval_tree_test_exit)\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Michel Lespinasse\");\nMODULE_DESCRIPTION(\"Interval Tree test\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}