{
  "module_name": "rdma_dim.c",
  "hash_id": "8900da0737a6aa56c304b854a76c19687f5662b911678a9a014d847ea1bf6def",
  "original_prompt": "Ingested from linux-6.6.14/lib/dim/rdma_dim.c",
  "human_readable_source": "\n \n\n#include <linux/dim.h>\n\nstatic int rdma_dim_step(struct dim *dim)\n{\n\tif (dim->tune_state == DIM_GOING_RIGHT) {\n\t\tif (dim->profile_ix == (RDMA_DIM_PARAMS_NUM_PROFILES - 1))\n\t\t\treturn DIM_ON_EDGE;\n\t\tdim->profile_ix++;\n\t\tdim->steps_right++;\n\t}\n\tif (dim->tune_state == DIM_GOING_LEFT) {\n\t\tif (dim->profile_ix == 0)\n\t\t\treturn DIM_ON_EDGE;\n\t\tdim->profile_ix--;\n\t\tdim->steps_left++;\n\t}\n\n\treturn DIM_STEPPED;\n}\n\nstatic int rdma_dim_stats_compare(struct dim_stats *curr,\n\t\t\t\t  struct dim_stats *prev)\n{\n\t \n\tif (!prev->cpms)\n\t\treturn DIM_STATS_SAME;\n\n\tif (IS_SIGNIFICANT_DIFF(curr->cpms, prev->cpms))\n\t\treturn (curr->cpms > prev->cpms) ? DIM_STATS_BETTER :\n\t\t\t\t\t\tDIM_STATS_WORSE;\n\n\tif (IS_SIGNIFICANT_DIFF(curr->cpe_ratio, prev->cpe_ratio))\n\t\treturn (curr->cpe_ratio > prev->cpe_ratio) ? DIM_STATS_BETTER :\n\t\t\t\t\t\tDIM_STATS_WORSE;\n\n\treturn DIM_STATS_SAME;\n}\n\nstatic bool rdma_dim_decision(struct dim_stats *curr_stats, struct dim *dim)\n{\n\tint prev_ix = dim->profile_ix;\n\tu8 state = dim->tune_state;\n\tint stats_res;\n\tint step_res;\n\n\tif (state != DIM_PARKING_ON_TOP && state != DIM_PARKING_TIRED) {\n\t\tstats_res = rdma_dim_stats_compare(curr_stats,\n\t\t\t\t\t\t   &dim->prev_stats);\n\n\t\tswitch (stats_res) {\n\t\tcase DIM_STATS_SAME:\n\t\t\tif (curr_stats->cpe_ratio <= 50 * prev_ix)\n\t\t\t\tdim->profile_ix = 0;\n\t\t\tbreak;\n\t\tcase DIM_STATS_WORSE:\n\t\t\tdim_turn(dim);\n\t\t\tfallthrough;\n\t\tcase DIM_STATS_BETTER:\n\t\t\tstep_res = rdma_dim_step(dim);\n\t\t\tif (step_res == DIM_ON_EDGE)\n\t\t\t\tdim_turn(dim);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tdim->prev_stats = *curr_stats;\n\n\treturn dim->profile_ix != prev_ix;\n}\n\nvoid rdma_dim(struct dim *dim, u64 completions)\n{\n\tstruct dim_sample *curr_sample = &dim->measuring_sample;\n\tstruct dim_stats curr_stats;\n\tu32 nevents;\n\n\tdim_update_sample_with_comps(curr_sample->event_ctr + 1, 0, 0,\n\t\t\t\t     curr_sample->comp_ctr + completions,\n\t\t\t\t     &dim->measuring_sample);\n\n\tswitch (dim->state) {\n\tcase DIM_MEASURE_IN_PROGRESS:\n\t\tnevents = curr_sample->event_ctr - dim->start_sample.event_ctr;\n\t\tif (nevents < DIM_NEVENTS)\n\t\t\tbreak;\n\t\tif (!dim_calc_stats(&dim->start_sample, curr_sample, &curr_stats))\n\t\t\tbreak;\n\t\tif (rdma_dim_decision(&curr_stats, dim)) {\n\t\t\tdim->state = DIM_APPLY_NEW_PROFILE;\n\t\t\tschedule_work(&dim->work);\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n\tcase DIM_START_MEASURE:\n\t\tdim->state = DIM_MEASURE_IN_PROGRESS;\n\t\tdim_update_sample_with_comps(curr_sample->event_ctr, 0, 0,\n\t\t\t\t\t     curr_sample->comp_ctr,\n\t\t\t\t\t     &dim->start_sample);\n\t\tbreak;\n\tcase DIM_APPLY_NEW_PROFILE:\n\t\tbreak;\n\t}\n}\nEXPORT_SYMBOL(rdma_dim);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}