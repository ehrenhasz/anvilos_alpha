{
  "module_name": "dynamic_debug.c",
  "hash_id": "f94d709f088e6f43f1bec02f6284ac88bfe61594682bed30272bdcab60df393c",
  "original_prompt": "Ingested from linux-6.6.14/lib/dynamic_debug.c",
  "human_readable_source": " \n\n#define pr_fmt(fmt) \"dyndbg: \" fmt\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/kallsyms.h>\n#include <linux/types.h>\n#include <linux/mutex.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/list.h>\n#include <linux/sysctl.h>\n#include <linux/ctype.h>\n#include <linux/string.h>\n#include <linux/parser.h>\n#include <linux/string_helpers.h>\n#include <linux/uaccess.h>\n#include <linux/dynamic_debug.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/jump_label.h>\n#include <linux/hardirq.h>\n#include <linux/sched.h>\n#include <linux/device.h>\n#include <linux/netdevice.h>\n\n#include <rdma/ib_verbs.h>\n\nextern struct _ddebug __start___dyndbg[];\nextern struct _ddebug __stop___dyndbg[];\nextern struct ddebug_class_map __start___dyndbg_classes[];\nextern struct ddebug_class_map __stop___dyndbg_classes[];\n\nstruct ddebug_table {\n\tstruct list_head link, maps;\n\tconst char *mod_name;\n\tunsigned int num_ddebugs;\n\tstruct _ddebug *ddebugs;\n};\n\nstruct ddebug_query {\n\tconst char *filename;\n\tconst char *module;\n\tconst char *function;\n\tconst char *format;\n\tconst char *class_string;\n\tunsigned int first_lineno, last_lineno;\n};\n\nstruct ddebug_iter {\n\tstruct ddebug_table *table;\n\tint idx;\n};\n\nstruct flag_settings {\n\tunsigned int flags;\n\tunsigned int mask;\n};\n\nstatic DEFINE_MUTEX(ddebug_lock);\nstatic LIST_HEAD(ddebug_tables);\nstatic int verbose;\nmodule_param(verbose, int, 0644);\nMODULE_PARM_DESC(verbose, \" dynamic_debug/control processing \"\n\t\t \"( 0 = off (default), 1 = module add/rm, 2 = >control summary, 3 = parsing, 4 = per-site changes)\");\n\n \nstatic inline const char *trim_prefix(const char *path)\n{\n\tint skip = strlen(__FILE__) - strlen(\"lib/dynamic_debug.c\");\n\n\tif (strncmp(path, __FILE__, skip))\n\t\tskip = 0;  \n\n\treturn path + skip;\n}\n\nstatic const struct { unsigned flag:8; char opt_char; } opt_array[] = {\n\t{ _DPRINTK_FLAGS_PRINT, 'p' },\n\t{ _DPRINTK_FLAGS_INCL_MODNAME, 'm' },\n\t{ _DPRINTK_FLAGS_INCL_FUNCNAME, 'f' },\n\t{ _DPRINTK_FLAGS_INCL_SOURCENAME, 's' },\n\t{ _DPRINTK_FLAGS_INCL_LINENO, 'l' },\n\t{ _DPRINTK_FLAGS_INCL_TID, 't' },\n\t{ _DPRINTK_FLAGS_NONE, '_' },\n};\n\nstruct flagsbuf { char buf[ARRAY_SIZE(opt_array)+1]; };\n\n \nstatic char *ddebug_describe_flags(unsigned int flags, struct flagsbuf *fb)\n{\n\tchar *p = fb->buf;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(opt_array); ++i)\n\t\tif (flags & opt_array[i].flag)\n\t\t\t*p++ = opt_array[i].opt_char;\n\tif (p == fb->buf)\n\t\t*p++ = '_';\n\t*p = '\\0';\n\n\treturn fb->buf;\n}\n\n#define vnpr_info(lvl, fmt, ...)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\\\n\tif (verbose >= lvl)\t\t\t\t\t\\\n\t\tpr_info(fmt, ##__VA_ARGS__);\t\t\t\\\n} while (0)\n\n#define vpr_info(fmt, ...)\tvnpr_info(1, fmt, ##__VA_ARGS__)\n#define v2pr_info(fmt, ...)\tvnpr_info(2, fmt, ##__VA_ARGS__)\n#define v3pr_info(fmt, ...)\tvnpr_info(3, fmt, ##__VA_ARGS__)\n#define v4pr_info(fmt, ...)\tvnpr_info(4, fmt, ##__VA_ARGS__)\n\nstatic void vpr_info_dq(const struct ddebug_query *query, const char *msg)\n{\n\t \n\tint fmtlen = 0;\n\n\tif (query->format) {\n\t\tfmtlen = strlen(query->format);\n\t\twhile (fmtlen && query->format[fmtlen - 1] == '\\n')\n\t\t\tfmtlen--;\n\t}\n\n\tv3pr_info(\"%s: func=\\\"%s\\\" file=\\\"%s\\\" module=\\\"%s\\\" format=\\\"%.*s\\\" lineno=%u-%u class=%s\\n\",\n\t\t  msg,\n\t\t  query->function ?: \"\",\n\t\t  query->filename ?: \"\",\n\t\t  query->module ?: \"\",\n\t\t  fmtlen, query->format ?: \"\",\n\t\t  query->first_lineno, query->last_lineno, query->class_string);\n}\n\nstatic struct ddebug_class_map *ddebug_find_valid_class(struct ddebug_table const *dt,\n\t\t\t\t\t\t\t  const char *class_string, int *class_id)\n{\n\tstruct ddebug_class_map *map;\n\tint idx;\n\n\tlist_for_each_entry(map, &dt->maps, link) {\n\t\tidx = match_string(map->class_names, map->length, class_string);\n\t\tif (idx >= 0) {\n\t\t\t*class_id = idx + map->base;\n\t\t\treturn map;\n\t\t}\n\t}\n\t*class_id = -ENOENT;\n\treturn NULL;\n}\n\n#define __outvar  \n \nstatic int ddebug_change(const struct ddebug_query *query,\n\t\t\t struct flag_settings *modifiers)\n{\n\tint i;\n\tstruct ddebug_table *dt;\n\tunsigned int newflags;\n\tunsigned int nfound = 0;\n\tstruct flagsbuf fbuf, nbuf;\n\tstruct ddebug_class_map *map = NULL;\n\tint __outvar valid_class;\n\n\t \n\tmutex_lock(&ddebug_lock);\n\tlist_for_each_entry(dt, &ddebug_tables, link) {\n\n\t\t \n\t\tif (query->module &&\n\t\t    !match_wildcard(query->module, dt->mod_name))\n\t\t\tcontinue;\n\n\t\tif (query->class_string) {\n\t\t\tmap = ddebug_find_valid_class(dt, query->class_string, &valid_class);\n\t\t\tif (!map)\n\t\t\t\tcontinue;\n\t\t} else {\n\t\t\t \n\t\t\tvalid_class = _DPRINTK_CLASS_DFLT;\n\t\t}\n\n\t\tfor (i = 0; i < dt->num_ddebugs; i++) {\n\t\t\tstruct _ddebug *dp = &dt->ddebugs[i];\n\n\t\t\t \n\t\t\tif (dp->class_id != valid_class)\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tif (query->filename &&\n\t\t\t    !match_wildcard(query->filename, dp->filename) &&\n\t\t\t    !match_wildcard(query->filename,\n\t\t\t\t\t   kbasename(dp->filename)) &&\n\t\t\t    !match_wildcard(query->filename,\n\t\t\t\t\t   trim_prefix(dp->filename)))\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tif (query->function &&\n\t\t\t    !match_wildcard(query->function, dp->function))\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tif (query->format) {\n\t\t\t\tif (*query->format == '^') {\n\t\t\t\t\tchar *p;\n\t\t\t\t\t \n\t\t\t\t\tp = strstr(dp->format, query->format+1);\n\t\t\t\t\tif (p != dp->format)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t} else if (!strstr(dp->format, query->format))\n\t\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (query->first_lineno &&\n\t\t\t    dp->lineno < query->first_lineno)\n\t\t\t\tcontinue;\n\t\t\tif (query->last_lineno &&\n\t\t\t    dp->lineno > query->last_lineno)\n\t\t\t\tcontinue;\n\n\t\t\tnfound++;\n\n\t\t\tnewflags = (dp->flags & modifiers->mask) | modifiers->flags;\n\t\t\tif (newflags == dp->flags)\n\t\t\t\tcontinue;\n#ifdef CONFIG_JUMP_LABEL\n\t\t\tif (dp->flags & _DPRINTK_FLAGS_PRINT) {\n\t\t\t\tif (!(newflags & _DPRINTK_FLAGS_PRINT))\n\t\t\t\t\tstatic_branch_disable(&dp->key.dd_key_true);\n\t\t\t} else if (newflags & _DPRINTK_FLAGS_PRINT) {\n\t\t\t\tstatic_branch_enable(&dp->key.dd_key_true);\n\t\t\t}\n#endif\n\t\t\tv4pr_info(\"changed %s:%d [%s]%s %s => %s\\n\",\n\t\t\t\t  trim_prefix(dp->filename), dp->lineno,\n\t\t\t\t  dt->mod_name, dp->function,\n\t\t\t\t  ddebug_describe_flags(dp->flags, &fbuf),\n\t\t\t\t  ddebug_describe_flags(newflags, &nbuf));\n\t\t\tdp->flags = newflags;\n\t\t}\n\t}\n\tmutex_unlock(&ddebug_lock);\n\n\tif (!nfound && verbose)\n\t\tpr_info(\"no matches for query\\n\");\n\n\treturn nfound;\n}\n\n \nstatic int ddebug_tokenize(char *buf, char *words[], int maxwords)\n{\n\tint nwords = 0;\n\n\twhile (*buf) {\n\t\tchar *end;\n\n\t\t \n\t\tbuf = skip_spaces(buf);\n\t\tif (!*buf)\n\t\t\tbreak;\t \n\t\tif (*buf == '#')\n\t\t\tbreak;\t \n\n\t\t \n\t\tif (*buf == '\"' || *buf == '\\'') {\n\t\t\tint quote = *buf++;\n\t\t\tfor (end = buf; *end && *end != quote; end++)\n\t\t\t\t;\n\t\t\tif (!*end) {\n\t\t\t\tpr_err(\"unclosed quote: %s\\n\", buf);\n\t\t\t\treturn -EINVAL;\t \n\t\t\t}\n\t\t} else {\n\t\t\tfor (end = buf; *end && !isspace(*end); end++)\n\t\t\t\t;\n\t\t\tBUG_ON(end == buf);\n\t\t}\n\n\t\t \n\t\tif (nwords == maxwords) {\n\t\t\tpr_err(\"too many words, legal max <=%d\\n\", maxwords);\n\t\t\treturn -EINVAL;\t \n\t\t}\n\t\tif (*end)\n\t\t\t*end++ = '\\0';\t \n\t\twords[nwords++] = buf;\n\t\tbuf = end;\n\t}\n\n\tif (verbose >= 3) {\n\t\tint i;\n\t\tpr_info(\"split into words:\");\n\t\tfor (i = 0; i < nwords; i++)\n\t\t\tpr_cont(\" \\\"%s\\\"\", words[i]);\n\t\tpr_cont(\"\\n\");\n\t}\n\n\treturn nwords;\n}\n\n \nstatic inline int parse_lineno(const char *str, unsigned int *val)\n{\n\tBUG_ON(str == NULL);\n\tif (*str == '\\0') {\n\t\t*val = 0;\n\t\treturn 0;\n\t}\n\tif (kstrtouint(str, 10, val) < 0) {\n\t\tpr_err(\"bad line-number: %s\\n\", str);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int parse_linerange(struct ddebug_query *query, const char *first)\n{\n\tchar *last = strchr(first, '-');\n\n\tif (query->first_lineno || query->last_lineno) {\n\t\tpr_err(\"match-spec: line used 2x\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (last)\n\t\t*last++ = '\\0';\n\tif (parse_lineno(first, &query->first_lineno) < 0)\n\t\treturn -EINVAL;\n\tif (last) {\n\t\t \n\t\tif (parse_lineno(last, &query->last_lineno) < 0)\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\tif (query->last_lineno == 0)\n\t\t\tquery->last_lineno = UINT_MAX;\n\n\t\tif (query->last_lineno < query->first_lineno) {\n\t\t\tpr_err(\"last-line:%d < 1st-line:%d\\n\",\n\t\t\t       query->last_lineno,\n\t\t\t       query->first_lineno);\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else {\n\t\tquery->last_lineno = query->first_lineno;\n\t}\n\tv3pr_info(\"parsed line %d-%d\\n\", query->first_lineno,\n\t\t query->last_lineno);\n\treturn 0;\n}\n\nstatic int check_set(const char **dest, char *src, char *name)\n{\n\tint rc = 0;\n\n\tif (*dest) {\n\t\trc = -EINVAL;\n\t\tpr_err(\"match-spec:%s val:%s overridden by %s\\n\",\n\t\t       name, *dest, src);\n\t}\n\t*dest = src;\n\treturn rc;\n}\n\n \nstatic int ddebug_parse_query(char *words[], int nwords,\n\t\t\tstruct ddebug_query *query, const char *modname)\n{\n\tunsigned int i;\n\tint rc = 0;\n\tchar *fline;\n\n\t \n\tif (nwords % 2 != 0) {\n\t\tpr_err(\"expecting pairs of match-spec <value>\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < nwords; i += 2) {\n\t\tchar *keyword = words[i];\n\t\tchar *arg = words[i+1];\n\n\t\tif (!strcmp(keyword, \"func\")) {\n\t\t\trc = check_set(&query->function, arg, \"func\");\n\t\t} else if (!strcmp(keyword, \"file\")) {\n\t\t\tif (check_set(&query->filename, arg, \"file\"))\n\t\t\t\treturn -EINVAL;\n\n\t\t\t \n\t\t\tfline = strchr(query->filename, ':');\n\t\t\tif (!fline)\n\t\t\t\tcontinue;\n\t\t\t*fline++ = '\\0';\n\t\t\tif (isalpha(*fline) || *fline == '*' || *fline == '?') {\n\t\t\t\t \n\t\t\t\tif (check_set(&query->function, fline, \"func\"))\n\t\t\t\t\treturn -EINVAL;\n\t\t\t} else {\n\t\t\t\tif (parse_linerange(query, fline))\n\t\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t} else if (!strcmp(keyword, \"module\")) {\n\t\t\trc = check_set(&query->module, arg, \"module\");\n\t\t} else if (!strcmp(keyword, \"format\")) {\n\t\t\tstring_unescape_inplace(arg, UNESCAPE_SPACE |\n\t\t\t\t\t\t\t    UNESCAPE_OCTAL |\n\t\t\t\t\t\t\t    UNESCAPE_SPECIAL);\n\t\t\trc = check_set(&query->format, arg, \"format\");\n\t\t} else if (!strcmp(keyword, \"line\")) {\n\t\t\tif (parse_linerange(query, arg))\n\t\t\t\treturn -EINVAL;\n\t\t} else if (!strcmp(keyword, \"class\")) {\n\t\t\trc = check_set(&query->class_string, arg, \"class\");\n\t\t} else {\n\t\t\tpr_err(\"unknown keyword \\\"%s\\\"\\n\", keyword);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\tif (!query->module && modname)\n\t\t \n\t\tquery->module = modname;\n\n\tvpr_info_dq(query, \"parsed\");\n\treturn 0;\n}\n\n \nstatic int ddebug_parse_flags(const char *str, struct flag_settings *modifiers)\n{\n\tint op, i;\n\n\tswitch (*str) {\n\tcase '+':\n\tcase '-':\n\tcase '=':\n\t\top = *str++;\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"bad flag-op %c, at start of %s\\n\", *str, str);\n\t\treturn -EINVAL;\n\t}\n\tv3pr_info(\"op='%c'\\n\", op);\n\n\tfor (; *str ; ++str) {\n\t\tfor (i = ARRAY_SIZE(opt_array) - 1; i >= 0; i--) {\n\t\t\tif (*str == opt_array[i].opt_char) {\n\t\t\t\tmodifiers->flags |= opt_array[i].flag;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (i < 0) {\n\t\t\tpr_err(\"unknown flag '%c'\\n\", *str);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\tv3pr_info(\"flags=0x%x\\n\", modifiers->flags);\n\n\t \n\tswitch (op) {\n\tcase '=':\n\t\t \n\t\tmodifiers->mask = 0;\n\t\tbreak;\n\tcase '+':\n\t\tmodifiers->mask = ~0U;\n\t\tbreak;\n\tcase '-':\n\t\tmodifiers->mask = ~modifiers->flags;\n\t\tmodifiers->flags = 0;\n\t\tbreak;\n\t}\n\tv3pr_info(\"*flagsp=0x%x *maskp=0x%x\\n\", modifiers->flags, modifiers->mask);\n\n\treturn 0;\n}\n\nstatic int ddebug_exec_query(char *query_string, const char *modname)\n{\n\tstruct flag_settings modifiers = {};\n\tstruct ddebug_query query = {};\n#define MAXWORDS 9\n\tint nwords, nfound;\n\tchar *words[MAXWORDS];\n\n\tnwords = ddebug_tokenize(query_string, words, MAXWORDS);\n\tif (nwords <= 0) {\n\t\tpr_err(\"tokenize failed\\n\");\n\t\treturn -EINVAL;\n\t}\n\t \n\tif (ddebug_parse_flags(words[nwords-1], &modifiers)) {\n\t\tpr_err(\"flags parse failed\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (ddebug_parse_query(words, nwords-1, &query, modname)) {\n\t\tpr_err(\"query parse failed\\n\");\n\t\treturn -EINVAL;\n\t}\n\t \n\tnfound = ddebug_change(&query, &modifiers);\n\tvpr_info_dq(&query, nfound ? \"applied\" : \"no-match\");\n\n\treturn nfound;\n}\n\n \nstatic int ddebug_exec_queries(char *query, const char *modname)\n{\n\tchar *split;\n\tint i, errs = 0, exitcode = 0, rc, nfound = 0;\n\n\tfor (i = 0; query; query = split) {\n\t\tsplit = strpbrk(query, \";\\n\");\n\t\tif (split)\n\t\t\t*split++ = '\\0';\n\n\t\tquery = skip_spaces(query);\n\t\tif (!query || !*query || *query == '#')\n\t\t\tcontinue;\n\n\t\tvpr_info(\"query %d: \\\"%s\\\" mod:%s\\n\", i, query, modname ?: \"*\");\n\n\t\trc = ddebug_exec_query(query, modname);\n\t\tif (rc < 0) {\n\t\t\terrs++;\n\t\t\texitcode = rc;\n\t\t} else {\n\t\t\tnfound += rc;\n\t\t}\n\t\ti++;\n\t}\n\tif (i)\n\t\tv2pr_info(\"processed %d queries, with %d matches, %d errs\\n\",\n\t\t\t i, nfound, errs);\n\n\tif (exitcode)\n\t\treturn exitcode;\n\treturn nfound;\n}\n\n \nstatic int ddebug_apply_class_bitmap(const struct ddebug_class_param *dcp,\n\t\t\t\t     unsigned long *new_bits, unsigned long *old_bits)\n{\n#define QUERY_SIZE 128\n\tchar query[QUERY_SIZE];\n\tconst struct ddebug_class_map *map = dcp->map;\n\tint matches = 0;\n\tint bi, ct;\n\n\tv2pr_info(\"apply: 0x%lx to: 0x%lx\\n\", *new_bits, *old_bits);\n\n\tfor (bi = 0; bi < map->length; bi++) {\n\t\tif (test_bit(bi, new_bits) == test_bit(bi, old_bits))\n\t\t\tcontinue;\n\n\t\tsnprintf(query, QUERY_SIZE, \"class %s %c%s\", map->class_names[bi],\n\t\t\t test_bit(bi, new_bits) ? '+' : '-', dcp->flags);\n\n\t\tct = ddebug_exec_queries(query, NULL);\n\t\tmatches += ct;\n\n\t\tv2pr_info(\"bit_%d: %d matches on class: %s -> 0x%lx\\n\", bi,\n\t\t\t  ct, map->class_names[bi], *new_bits);\n\t}\n\treturn matches;\n}\n\n \n#define KP_NAME(kp)\tkp->name\n\n#define CLASSMAP_BITMASK(width) ((1UL << (width)) - 1)\n\n \nstatic int param_set_dyndbg_classnames(const char *instr, const struct kernel_param *kp)\n{\n\tconst struct ddebug_class_param *dcp = kp->arg;\n\tconst struct ddebug_class_map *map = dcp->map;\n\tunsigned long curr_bits, old_bits;\n\tchar *cl_str, *p, *tmp;\n\tint cls_id, totct = 0;\n\tbool wanted;\n\n\tcl_str = tmp = kstrdup(instr, GFP_KERNEL);\n\tp = strchr(cl_str, '\\n');\n\tif (p)\n\t\t*p = '\\0';\n\n\t \n\tcurr_bits = old_bits = *dcp->bits;\n\tvpr_info(\"\\\"%s\\\" > %s:0x%lx\\n\", cl_str, KP_NAME(kp), curr_bits);\n\n\tfor (; cl_str; cl_str = p) {\n\t\tp = strchr(cl_str, ',');\n\t\tif (p)\n\t\t\t*p++ = '\\0';\n\n\t\tif (*cl_str == '-') {\n\t\t\twanted = false;\n\t\t\tcl_str++;\n\t\t} else {\n\t\t\twanted = true;\n\t\t\tif (*cl_str == '+')\n\t\t\t\tcl_str++;\n\t\t}\n\t\tcls_id = match_string(map->class_names, map->length, cl_str);\n\t\tif (cls_id < 0) {\n\t\t\tpr_err(\"%s unknown to %s\\n\", cl_str, KP_NAME(kp));\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tswitch (map->map_type) {\n\t\tcase DD_CLASS_TYPE_DISJOINT_NAMES:\n\t\t\t \n\t\t\tif (test_bit(cls_id, &curr_bits) == wanted) {\n\t\t\t\tv3pr_info(\"no change on %s\\n\", cl_str);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tcurr_bits ^= BIT(cls_id);\n\t\t\ttotct += ddebug_apply_class_bitmap(dcp, &curr_bits, dcp->bits);\n\t\t\t*dcp->bits = curr_bits;\n\t\t\tv2pr_info(\"%s: changed bit %d:%s\\n\", KP_NAME(kp), cls_id,\n\t\t\t\t  map->class_names[cls_id]);\n\t\t\tbreak;\n\t\tcase DD_CLASS_TYPE_LEVEL_NAMES:\n\t\t\t \n\t\t\told_bits = CLASSMAP_BITMASK(*dcp->lvl);\n\t\t\tcurr_bits = CLASSMAP_BITMASK(cls_id + (wanted ? 1 : 0 ));\n\n\t\t\ttotct += ddebug_apply_class_bitmap(dcp, &curr_bits, &old_bits);\n\t\t\t*dcp->lvl = (cls_id + (wanted ? 1 : 0));\n\t\t\tv2pr_info(\"%s: changed bit-%d: \\\"%s\\\" %lx->%lx\\n\", KP_NAME(kp), cls_id,\n\t\t\t\t  map->class_names[cls_id], old_bits, curr_bits);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_err(\"illegal map-type value %d\\n\", map->map_type);\n\t\t}\n\t}\n\tkfree(tmp);\n\tvpr_info(\"total matches: %d\\n\", totct);\n\treturn 0;\n}\n\n \nint param_set_dyndbg_classes(const char *instr, const struct kernel_param *kp)\n{\n\tconst struct ddebug_class_param *dcp = kp->arg;\n\tconst struct ddebug_class_map *map = dcp->map;\n\tunsigned long inrep, new_bits, old_bits;\n\tint rc, totct = 0;\n\n\tswitch (map->map_type) {\n\n\tcase DD_CLASS_TYPE_DISJOINT_NAMES:\n\tcase DD_CLASS_TYPE_LEVEL_NAMES:\n\t\t \n\t\treturn param_set_dyndbg_classnames(instr, kp);\n\n\tcase DD_CLASS_TYPE_DISJOINT_BITS:\n\tcase DD_CLASS_TYPE_LEVEL_NUM:\n\t\t \n\t\trc = kstrtoul(instr, 0, &inrep);\n\t\tif (rc) {\n\t\t\tpr_err(\"expecting numeric input: %s > %s\\n\", instr, KP_NAME(kp));\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"%s: bad map type: %d\\n\", KP_NAME(kp), map->map_type);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tswitch (map->map_type) {\n\tcase DD_CLASS_TYPE_DISJOINT_BITS:\n\t\t \n\t\tif (inrep & ~CLASSMAP_BITMASK(map->length)) {\n\t\t\tpr_warn(\"%s: input: 0x%lx exceeds mask: 0x%lx, masking\\n\",\n\t\t\t\tKP_NAME(kp), inrep, CLASSMAP_BITMASK(map->length));\n\t\t\tinrep &= CLASSMAP_BITMASK(map->length);\n\t\t}\n\t\tv2pr_info(\"bits:%lx > %s\\n\", inrep, KP_NAME(kp));\n\t\ttotct += ddebug_apply_class_bitmap(dcp, &inrep, dcp->bits);\n\t\t*dcp->bits = inrep;\n\t\tbreak;\n\tcase DD_CLASS_TYPE_LEVEL_NUM:\n\t\t \n\t\tif (inrep > map->length) {\n\t\t\tpr_warn(\"%s: level:%ld exceeds max:%d, clamping\\n\",\n\t\t\t\tKP_NAME(kp), inrep, map->length);\n\t\t\tinrep = map->length;\n\t\t}\n\t\told_bits = CLASSMAP_BITMASK(*dcp->lvl);\n\t\tnew_bits = CLASSMAP_BITMASK(inrep);\n\t\tv2pr_info(\"lvl:%ld bits:0x%lx > %s\\n\", inrep, new_bits, KP_NAME(kp));\n\t\ttotct += ddebug_apply_class_bitmap(dcp, &new_bits, &old_bits);\n\t\t*dcp->lvl = inrep;\n\t\tbreak;\n\tdefault:\n\t\tpr_warn(\"%s: bad map type: %d\\n\", KP_NAME(kp), map->map_type);\n\t}\n\tvpr_info(\"%s: total matches: %d\\n\", KP_NAME(kp), totct);\n\treturn 0;\n}\nEXPORT_SYMBOL(param_set_dyndbg_classes);\n\n \nint param_get_dyndbg_classes(char *buffer, const struct kernel_param *kp)\n{\n\tconst struct ddebug_class_param *dcp = kp->arg;\n\tconst struct ddebug_class_map *map = dcp->map;\n\n\tswitch (map->map_type) {\n\n\tcase DD_CLASS_TYPE_DISJOINT_NAMES:\n\tcase DD_CLASS_TYPE_DISJOINT_BITS:\n\t\treturn scnprintf(buffer, PAGE_SIZE, \"0x%lx\\n\", *dcp->bits);\n\n\tcase DD_CLASS_TYPE_LEVEL_NAMES:\n\tcase DD_CLASS_TYPE_LEVEL_NUM:\n\t\treturn scnprintf(buffer, PAGE_SIZE, \"%d\\n\", *dcp->lvl);\n\tdefault:\n\t\treturn -1;\n\t}\n}\nEXPORT_SYMBOL(param_get_dyndbg_classes);\n\nconst struct kernel_param_ops param_ops_dyndbg_classes = {\n\t.set = param_set_dyndbg_classes,\n\t.get = param_get_dyndbg_classes,\n};\nEXPORT_SYMBOL(param_ops_dyndbg_classes);\n\n#define PREFIX_SIZE 128\n\nstatic int remaining(int wrote)\n{\n\tif (PREFIX_SIZE - wrote > 0)\n\t\treturn PREFIX_SIZE - wrote;\n\treturn 0;\n}\n\nstatic char *__dynamic_emit_prefix(const struct _ddebug *desc, char *buf)\n{\n\tint pos_after_tid;\n\tint pos = 0;\n\n\tif (desc->flags & _DPRINTK_FLAGS_INCL_TID) {\n\t\tif (in_interrupt())\n\t\t\tpos += snprintf(buf + pos, remaining(pos), \"<intr> \");\n\t\telse\n\t\t\tpos += snprintf(buf + pos, remaining(pos), \"[%d] \",\n\t\t\t\t\ttask_pid_vnr(current));\n\t}\n\tpos_after_tid = pos;\n\tif (desc->flags & _DPRINTK_FLAGS_INCL_MODNAME)\n\t\tpos += snprintf(buf + pos, remaining(pos), \"%s:\",\n\t\t\t\tdesc->modname);\n\tif (desc->flags & _DPRINTK_FLAGS_INCL_FUNCNAME)\n\t\tpos += snprintf(buf + pos, remaining(pos), \"%s:\",\n\t\t\t\tdesc->function);\n\tif (desc->flags & _DPRINTK_FLAGS_INCL_SOURCENAME)\n\t\tpos += snprintf(buf + pos, remaining(pos), \"%s:\",\n\t\t\t\ttrim_prefix(desc->filename));\n\tif (desc->flags & _DPRINTK_FLAGS_INCL_LINENO)\n\t\tpos += snprintf(buf + pos, remaining(pos), \"%d:\",\n\t\t\t\tdesc->lineno);\n\tif (pos - pos_after_tid)\n\t\tpos += snprintf(buf + pos, remaining(pos), \" \");\n\tif (pos >= PREFIX_SIZE)\n\t\tbuf[PREFIX_SIZE - 1] = '\\0';\n\n\treturn buf;\n}\n\nstatic inline char *dynamic_emit_prefix(struct _ddebug *desc, char *buf)\n{\n\tif (unlikely(desc->flags & _DPRINTK_FLAGS_INCL_ANY))\n\t\treturn __dynamic_emit_prefix(desc, buf);\n\treturn buf;\n}\n\nvoid __dynamic_pr_debug(struct _ddebug *descriptor, const char *fmt, ...)\n{\n\tva_list args;\n\tstruct va_format vaf;\n\tchar buf[PREFIX_SIZE] = \"\";\n\n\tBUG_ON(!descriptor);\n\tBUG_ON(!fmt);\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_DEBUG \"%s%pV\", dynamic_emit_prefix(descriptor, buf), &vaf);\n\n\tva_end(args);\n}\nEXPORT_SYMBOL(__dynamic_pr_debug);\n\nvoid __dynamic_dev_dbg(struct _ddebug *descriptor,\n\t\t      const struct device *dev, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tBUG_ON(!descriptor);\n\tBUG_ON(!fmt);\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tif (!dev) {\n\t\tprintk(KERN_DEBUG \"(NULL device *): %pV\", &vaf);\n\t} else {\n\t\tchar buf[PREFIX_SIZE] = \"\";\n\n\t\tdev_printk_emit(LOGLEVEL_DEBUG, dev, \"%s%s %s: %pV\",\n\t\t\t\tdynamic_emit_prefix(descriptor, buf),\n\t\t\t\tdev_driver_string(dev), dev_name(dev),\n\t\t\t\t&vaf);\n\t}\n\n\tva_end(args);\n}\nEXPORT_SYMBOL(__dynamic_dev_dbg);\n\n#ifdef CONFIG_NET\n\nvoid __dynamic_netdev_dbg(struct _ddebug *descriptor,\n\t\t\t  const struct net_device *dev, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tBUG_ON(!descriptor);\n\tBUG_ON(!fmt);\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tif (dev && dev->dev.parent) {\n\t\tchar buf[PREFIX_SIZE] = \"\";\n\n\t\tdev_printk_emit(LOGLEVEL_DEBUG, dev->dev.parent,\n\t\t\t\t\"%s%s %s %s%s: %pV\",\n\t\t\t\tdynamic_emit_prefix(descriptor, buf),\n\t\t\t\tdev_driver_string(dev->dev.parent),\n\t\t\t\tdev_name(dev->dev.parent),\n\t\t\t\tnetdev_name(dev), netdev_reg_state(dev),\n\t\t\t\t&vaf);\n\t} else if (dev) {\n\t\tprintk(KERN_DEBUG \"%s%s: %pV\", netdev_name(dev),\n\t\t       netdev_reg_state(dev), &vaf);\n\t} else {\n\t\tprintk(KERN_DEBUG \"(NULL net_device): %pV\", &vaf);\n\t}\n\n\tva_end(args);\n}\nEXPORT_SYMBOL(__dynamic_netdev_dbg);\n\n#endif\n\n#if IS_ENABLED(CONFIG_INFINIBAND)\n\nvoid __dynamic_ibdev_dbg(struct _ddebug *descriptor,\n\t\t\t const struct ib_device *ibdev, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tif (ibdev && ibdev->dev.parent) {\n\t\tchar buf[PREFIX_SIZE] = \"\";\n\n\t\tdev_printk_emit(LOGLEVEL_DEBUG, ibdev->dev.parent,\n\t\t\t\t\"%s%s %s %s: %pV\",\n\t\t\t\tdynamic_emit_prefix(descriptor, buf),\n\t\t\t\tdev_driver_string(ibdev->dev.parent),\n\t\t\t\tdev_name(ibdev->dev.parent),\n\t\t\t\tdev_name(&ibdev->dev),\n\t\t\t\t&vaf);\n\t} else if (ibdev) {\n\t\tprintk(KERN_DEBUG \"%s: %pV\", dev_name(&ibdev->dev), &vaf);\n\t} else {\n\t\tprintk(KERN_DEBUG \"(NULL ib_device): %pV\", &vaf);\n\t}\n\n\tva_end(args);\n}\nEXPORT_SYMBOL(__dynamic_ibdev_dbg);\n\n#endif\n\n \nstatic __init int dyndbg_setup(char *str)\n{\n\treturn 1;\n}\n\n__setup(\"dyndbg=\", dyndbg_setup);\n\n \n#define USER_BUF_PAGE 4096\nstatic ssize_t ddebug_proc_write(struct file *file, const char __user *ubuf,\n\t\t\t\t  size_t len, loff_t *offp)\n{\n\tchar *tmpbuf;\n\tint ret;\n\n\tif (len == 0)\n\t\treturn 0;\n\tif (len > USER_BUF_PAGE - 1) {\n\t\tpr_warn(\"expected <%d bytes into control\\n\", USER_BUF_PAGE);\n\t\treturn -E2BIG;\n\t}\n\ttmpbuf = memdup_user_nul(ubuf, len);\n\tif (IS_ERR(tmpbuf))\n\t\treturn PTR_ERR(tmpbuf);\n\tv2pr_info(\"read %zu bytes from userspace\\n\", len);\n\n\tret = ddebug_exec_queries(tmpbuf, NULL);\n\tkfree(tmpbuf);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t*offp += len;\n\treturn len;\n}\n\n \nstatic struct _ddebug *ddebug_iter_first(struct ddebug_iter *iter)\n{\n\tif (list_empty(&ddebug_tables)) {\n\t\titer->table = NULL;\n\t\treturn NULL;\n\t}\n\titer->table = list_entry(ddebug_tables.next,\n\t\t\t\t struct ddebug_table, link);\n\titer->idx = iter->table->num_ddebugs;\n\treturn &iter->table->ddebugs[--iter->idx];\n}\n\n \nstatic struct _ddebug *ddebug_iter_next(struct ddebug_iter *iter)\n{\n\tif (iter->table == NULL)\n\t\treturn NULL;\n\tif (--iter->idx < 0) {\n\t\t \n\t\tif (list_is_last(&iter->table->link, &ddebug_tables)) {\n\t\t\titer->table = NULL;\n\t\t\treturn NULL;\n\t\t}\n\t\titer->table = list_entry(iter->table->link.next,\n\t\t\t\t\t struct ddebug_table, link);\n\t\titer->idx = iter->table->num_ddebugs;\n\t\t--iter->idx;\n\t}\n\treturn &iter->table->ddebugs[iter->idx];\n}\n\n \nstatic void *ddebug_proc_start(struct seq_file *m, loff_t *pos)\n{\n\tstruct ddebug_iter *iter = m->private;\n\tstruct _ddebug *dp;\n\tint n = *pos;\n\n\tmutex_lock(&ddebug_lock);\n\n\tif (!n)\n\t\treturn SEQ_START_TOKEN;\n\tif (n < 0)\n\t\treturn NULL;\n\tdp = ddebug_iter_first(iter);\n\twhile (dp != NULL && --n > 0)\n\t\tdp = ddebug_iter_next(iter);\n\treturn dp;\n}\n\n \nstatic void *ddebug_proc_next(struct seq_file *m, void *p, loff_t *pos)\n{\n\tstruct ddebug_iter *iter = m->private;\n\tstruct _ddebug *dp;\n\n\tif (p == SEQ_START_TOKEN)\n\t\tdp = ddebug_iter_first(iter);\n\telse\n\t\tdp = ddebug_iter_next(iter);\n\t++*pos;\n\treturn dp;\n}\n\n#define class_in_range(class_id, map)\t\t\t\t\t\\\n\t(class_id >= map->base && class_id < map->base + map->length)\n\nstatic const char *ddebug_class_name(struct ddebug_iter *iter, struct _ddebug *dp)\n{\n\tstruct ddebug_class_map *map;\n\n\tlist_for_each_entry(map, &iter->table->maps, link)\n\t\tif (class_in_range(dp->class_id, map))\n\t\t\treturn map->class_names[dp->class_id - map->base];\n\n\treturn NULL;\n}\n\n \nstatic int ddebug_proc_show(struct seq_file *m, void *p)\n{\n\tstruct ddebug_iter *iter = m->private;\n\tstruct _ddebug *dp = p;\n\tstruct flagsbuf flags;\n\tchar const *class;\n\n\tif (p == SEQ_START_TOKEN) {\n\t\tseq_puts(m,\n\t\t\t \"# filename:lineno [module]function flags format\\n\");\n\t\treturn 0;\n\t}\n\n\tseq_printf(m, \"%s:%u [%s]%s =%s \\\"\",\n\t\t   trim_prefix(dp->filename), dp->lineno,\n\t\t   iter->table->mod_name, dp->function,\n\t\t   ddebug_describe_flags(dp->flags, &flags));\n\tseq_escape_str(m, dp->format, ESCAPE_SPACE, \"\\t\\r\\n\\\"\");\n\tseq_puts(m, \"\\\"\");\n\n\tif (dp->class_id != _DPRINTK_CLASS_DFLT) {\n\t\tclass = ddebug_class_name(iter, dp);\n\t\tif (class)\n\t\t\tseq_printf(m, \" class:%s\", class);\n\t\telse\n\t\t\tseq_printf(m, \" class unknown, _id:%d\", dp->class_id);\n\t}\n\tseq_puts(m, \"\\n\");\n\n\treturn 0;\n}\n\n \nstatic void ddebug_proc_stop(struct seq_file *m, void *p)\n{\n\tmutex_unlock(&ddebug_lock);\n}\n\nstatic const struct seq_operations ddebug_proc_seqops = {\n\t.start = ddebug_proc_start,\n\t.next = ddebug_proc_next,\n\t.show = ddebug_proc_show,\n\t.stop = ddebug_proc_stop\n};\n\nstatic int ddebug_proc_open(struct inode *inode, struct file *file)\n{\n\treturn seq_open_private(file, &ddebug_proc_seqops,\n\t\t\t\tsizeof(struct ddebug_iter));\n}\n\nstatic const struct file_operations ddebug_proc_fops = {\n\t.owner = THIS_MODULE,\n\t.open = ddebug_proc_open,\n\t.read = seq_read,\n\t.llseek = seq_lseek,\n\t.release = seq_release_private,\n\t.write = ddebug_proc_write\n};\n\nstatic const struct proc_ops proc_fops = {\n\t.proc_open = ddebug_proc_open,\n\t.proc_read = seq_read,\n\t.proc_lseek = seq_lseek,\n\t.proc_release = seq_release_private,\n\t.proc_write = ddebug_proc_write\n};\n\nstatic void ddebug_attach_module_classes(struct ddebug_table *dt,\n\t\t\t\t\t struct ddebug_class_map *classes,\n\t\t\t\t\t int num_classes)\n{\n\tstruct ddebug_class_map *cm;\n\tint i, j, ct = 0;\n\n\tfor (cm = classes, i = 0; i < num_classes; i++, cm++) {\n\n\t\tif (!strcmp(cm->mod_name, dt->mod_name)) {\n\n\t\t\tv2pr_info(\"class[%d]: module:%s base:%d len:%d ty:%d\\n\", i,\n\t\t\t\t  cm->mod_name, cm->base, cm->length, cm->map_type);\n\n\t\t\tfor (j = 0; j < cm->length; j++)\n\t\t\t\tv3pr_info(\" %d: %d %s\\n\", j + cm->base, j,\n\t\t\t\t\t  cm->class_names[j]);\n\n\t\t\tlist_add(&cm->link, &dt->maps);\n\t\t\tct++;\n\t\t}\n\t}\n\tif (ct)\n\t\tvpr_info(\"module:%s attached %d classes\\n\", dt->mod_name, ct);\n}\n\n \nstatic int ddebug_add_module(struct _ddebug_info *di, const char *modname)\n{\n\tstruct ddebug_table *dt;\n\n\tv3pr_info(\"add-module: %s.%d sites\\n\", modname, di->num_descs);\n\tif (!di->num_descs) {\n\t\tv3pr_info(\" skip %s\\n\", modname);\n\t\treturn 0;\n\t}\n\n\tdt = kzalloc(sizeof(*dt), GFP_KERNEL);\n\tif (dt == NULL) {\n\t\tpr_err(\"error adding module: %s\\n\", modname);\n\t\treturn -ENOMEM;\n\t}\n\t \n\tdt->mod_name = modname;\n\tdt->ddebugs = di->descs;\n\tdt->num_ddebugs = di->num_descs;\n\n\tINIT_LIST_HEAD(&dt->link);\n\tINIT_LIST_HEAD(&dt->maps);\n\n\tif (di->classes && di->num_classes)\n\t\tddebug_attach_module_classes(dt, di->classes, di->num_classes);\n\n\tmutex_lock(&ddebug_lock);\n\tlist_add_tail(&dt->link, &ddebug_tables);\n\tmutex_unlock(&ddebug_lock);\n\n\tvpr_info(\"%3u debug prints in module %s\\n\", di->num_descs, modname);\n\treturn 0;\n}\n\n \nstatic int ddebug_dyndbg_param_cb(char *param, char *val,\n\t\t\t\tconst char *modname, int on_err)\n{\n\tchar *sep;\n\n\tsep = strchr(param, '.');\n\tif (sep) {\n\t\t \n\t\t*sep = '\\0';\n\t\tmodname = param;\n\t\tparam = sep + 1;\n\t}\n\tif (strcmp(param, \"dyndbg\"))\n\t\treturn on_err;  \n\n\tddebug_exec_queries((val ? val : \"+p\"), modname);\n\n\treturn 0;  \n}\n\n \nstatic int ddebug_dyndbg_boot_param_cb(char *param, char *val,\n\t\t\t\tconst char *unused, void *arg)\n{\n\tvpr_info(\"%s=\\\"%s\\\"\\n\", param, val);\n\treturn ddebug_dyndbg_param_cb(param, val, NULL, 0);\n}\n\n \nint ddebug_dyndbg_module_param_cb(char *param, char *val, const char *module)\n{\n\tvpr_info(\"module: %s %s=\\\"%s\\\"\\n\", module, param, val);\n\treturn ddebug_dyndbg_param_cb(param, val, module, -ENOENT);\n}\n\nstatic void ddebug_table_free(struct ddebug_table *dt)\n{\n\tlist_del_init(&dt->link);\n\tkfree(dt);\n}\n\n#ifdef CONFIG_MODULES\n\n \nstatic int ddebug_remove_module(const char *mod_name)\n{\n\tstruct ddebug_table *dt, *nextdt;\n\tint ret = -ENOENT;\n\n\tmutex_lock(&ddebug_lock);\n\tlist_for_each_entry_safe(dt, nextdt, &ddebug_tables, link) {\n\t\tif (dt->mod_name == mod_name) {\n\t\t\tddebug_table_free(dt);\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&ddebug_lock);\n\tif (!ret)\n\t\tv2pr_info(\"removed module \\\"%s\\\"\\n\", mod_name);\n\treturn ret;\n}\n\nstatic int ddebug_module_notify(struct notifier_block *self, unsigned long val,\n\t\t\t\tvoid *data)\n{\n\tstruct module *mod = data;\n\tint ret = 0;\n\n\tswitch (val) {\n\tcase MODULE_STATE_COMING:\n\t\tret = ddebug_add_module(&mod->dyndbg_info, mod->name);\n\t\tif (ret)\n\t\t\tWARN(1, \"Failed to allocate memory: dyndbg may not work properly.\\n\");\n\t\tbreak;\n\tcase MODULE_STATE_GOING:\n\t\tddebug_remove_module(mod->name);\n\t\tbreak;\n\t}\n\n\treturn notifier_from_errno(ret);\n}\n\nstatic struct notifier_block ddebug_module_nb = {\n\t.notifier_call = ddebug_module_notify,\n\t.priority = 0,  \n};\n\n#endif  \n\nstatic void ddebug_remove_all_tables(void)\n{\n\tmutex_lock(&ddebug_lock);\n\twhile (!list_empty(&ddebug_tables)) {\n\t\tstruct ddebug_table *dt = list_entry(ddebug_tables.next,\n\t\t\t\t\t\t      struct ddebug_table,\n\t\t\t\t\t\t      link);\n\t\tddebug_table_free(dt);\n\t}\n\tmutex_unlock(&ddebug_lock);\n}\n\nstatic __initdata int ddebug_init_success;\n\nstatic int __init dynamic_debug_init_control(void)\n{\n\tstruct proc_dir_entry *procfs_dir;\n\tstruct dentry *debugfs_dir;\n\n\tif (!ddebug_init_success)\n\t\treturn -ENODEV;\n\n\t \n\tif (debugfs_initialized()) {\n\t\tdebugfs_dir = debugfs_create_dir(\"dynamic_debug\", NULL);\n\t\tdebugfs_create_file(\"control\", 0644, debugfs_dir, NULL,\n\t\t\t\t    &ddebug_proc_fops);\n\t}\n\n\t \n\tprocfs_dir = proc_mkdir(\"dynamic_debug\", NULL);\n\tif (procfs_dir)\n\t\tproc_create(\"control\", 0644, procfs_dir, &proc_fops);\n\n\treturn 0;\n}\n\nstatic int __init dynamic_debug_init(void)\n{\n\tstruct _ddebug *iter, *iter_mod_start;\n\tint ret, i, mod_sites, mod_ct;\n\tconst char *modname;\n\tchar *cmdline;\n\n\tstruct _ddebug_info di = {\n\t\t.descs = __start___dyndbg,\n\t\t.classes = __start___dyndbg_classes,\n\t\t.num_descs = __stop___dyndbg - __start___dyndbg,\n\t\t.num_classes = __stop___dyndbg_classes - __start___dyndbg_classes,\n\t};\n\n#ifdef CONFIG_MODULES\n\tret = register_module_notifier(&ddebug_module_nb);\n\tif (ret) {\n\t\tpr_warn(\"Failed to register dynamic debug module notifier\\n\");\n\t\treturn ret;\n\t}\n#endif  \n\n\tif (&__start___dyndbg == &__stop___dyndbg) {\n\t\tif (IS_ENABLED(CONFIG_DYNAMIC_DEBUG)) {\n\t\t\tpr_warn(\"_ddebug table is empty in a CONFIG_DYNAMIC_DEBUG build\\n\");\n\t\t\treturn 1;\n\t\t}\n\t\tpr_info(\"Ignore empty _ddebug table in a CONFIG_DYNAMIC_DEBUG_CORE build\\n\");\n\t\tddebug_init_success = 1;\n\t\treturn 0;\n\t}\n\n\titer = iter_mod_start = __start___dyndbg;\n\tmodname = iter->modname;\n\ti = mod_sites = mod_ct = 0;\n\n\tfor (; iter < __stop___dyndbg; iter++, i++, mod_sites++) {\n\n\t\tif (strcmp(modname, iter->modname)) {\n\t\t\tmod_ct++;\n\t\t\tdi.num_descs = mod_sites;\n\t\t\tdi.descs = iter_mod_start;\n\t\t\tret = ddebug_add_module(&di, modname);\n\t\t\tif (ret)\n\t\t\t\tgoto out_err;\n\n\t\t\tmod_sites = 0;\n\t\t\tmodname = iter->modname;\n\t\t\titer_mod_start = iter;\n\t\t}\n\t}\n\tdi.num_descs = mod_sites;\n\tdi.descs = iter_mod_start;\n\tret = ddebug_add_module(&di, modname);\n\tif (ret)\n\t\tgoto out_err;\n\n\tddebug_init_success = 1;\n\tvpr_info(\"%d prdebugs in %d modules, %d KiB in ddebug tables, %d kiB in __dyndbg section\\n\",\n\t\t i, mod_ct, (int)((mod_ct * sizeof(struct ddebug_table)) >> 10),\n\t\t (int)((i * sizeof(struct _ddebug)) >> 10));\n\n\tif (di.num_classes)\n\t\tv2pr_info(\"  %d builtin ddebug class-maps\\n\", di.num_classes);\n\n\t \n\tcmdline = kstrdup(saved_command_line, GFP_KERNEL);\n\tparse_args(\"dyndbg params\", cmdline, NULL,\n\t\t   0, 0, 0, NULL, &ddebug_dyndbg_boot_param_cb);\n\tkfree(cmdline);\n\treturn 0;\n\nout_err:\n\tddebug_remove_all_tables();\n\treturn 0;\n}\n \nearly_initcall(dynamic_debug_init);\n\n \nfs_initcall(dynamic_debug_init_control);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}