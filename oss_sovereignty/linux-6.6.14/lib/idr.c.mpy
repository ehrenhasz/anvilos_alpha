{
  "module_name": "idr.c",
  "hash_id": "6e54f284687bb69dd4f205cbd5cb385347aa0e375808a0412bedd763eba6b7c7",
  "original_prompt": "Ingested from linux-6.6.14/lib/idr.c",
  "human_readable_source": "\n#include <linux/bitmap.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/xarray.h>\n\n \nint idr_alloc_u32(struct idr *idr, void *ptr, u32 *nextid,\n\t\t\tunsigned long max, gfp_t gfp)\n{\n\tstruct radix_tree_iter iter;\n\tvoid __rcu **slot;\n\tunsigned int base = idr->idr_base;\n\tunsigned int id = *nextid;\n\n\tif (WARN_ON_ONCE(!(idr->idr_rt.xa_flags & ROOT_IS_IDR)))\n\t\tidr->idr_rt.xa_flags |= IDR_RT_MARKER;\n\n\tid = (id < base) ? 0 : id - base;\n\tradix_tree_iter_init(&iter, id);\n\tslot = idr_get_free(&idr->idr_rt, &iter, gfp, max - base);\n\tif (IS_ERR(slot))\n\t\treturn PTR_ERR(slot);\n\n\t*nextid = iter.index + base;\n\t \n\tradix_tree_iter_replace(&idr->idr_rt, &iter, slot, ptr);\n\tradix_tree_iter_tag_clear(&idr->idr_rt, &iter, IDR_FREE);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(idr_alloc_u32);\n\n \nint idr_alloc(struct idr *idr, void *ptr, int start, int end, gfp_t gfp)\n{\n\tu32 id = start;\n\tint ret;\n\n\tif (WARN_ON_ONCE(start < 0))\n\t\treturn -EINVAL;\n\n\tret = idr_alloc_u32(idr, ptr, &id, end > 0 ? end - 1 : INT_MAX, gfp);\n\tif (ret)\n\t\treturn ret;\n\n\treturn id;\n}\nEXPORT_SYMBOL_GPL(idr_alloc);\n\n \nint idr_alloc_cyclic(struct idr *idr, void *ptr, int start, int end, gfp_t gfp)\n{\n\tu32 id = idr->idr_next;\n\tint err, max = end > 0 ? end - 1 : INT_MAX;\n\n\tif ((int)id < start)\n\t\tid = start;\n\n\terr = idr_alloc_u32(idr, ptr, &id, max, gfp);\n\tif ((err == -ENOSPC) && (id > start)) {\n\t\tid = start;\n\t\terr = idr_alloc_u32(idr, ptr, &id, max, gfp);\n\t}\n\tif (err)\n\t\treturn err;\n\n\tidr->idr_next = id + 1;\n\treturn id;\n}\nEXPORT_SYMBOL(idr_alloc_cyclic);\n\n \nvoid *idr_remove(struct idr *idr, unsigned long id)\n{\n\treturn radix_tree_delete_item(&idr->idr_rt, id - idr->idr_base, NULL);\n}\nEXPORT_SYMBOL_GPL(idr_remove);\n\n \nvoid *idr_find(const struct idr *idr, unsigned long id)\n{\n\treturn radix_tree_lookup(&idr->idr_rt, id - idr->idr_base);\n}\nEXPORT_SYMBOL_GPL(idr_find);\n\n \nint idr_for_each(const struct idr *idr,\n\t\tint (*fn)(int id, void *p, void *data), void *data)\n{\n\tstruct radix_tree_iter iter;\n\tvoid __rcu **slot;\n\tint base = idr->idr_base;\n\n\tradix_tree_for_each_slot(slot, &idr->idr_rt, &iter, 0) {\n\t\tint ret;\n\t\tunsigned long id = iter.index + base;\n\n\t\tif (WARN_ON_ONCE(id > INT_MAX))\n\t\t\tbreak;\n\t\tret = fn(id, rcu_dereference_raw(*slot), data);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(idr_for_each);\n\n \nvoid *idr_get_next_ul(struct idr *idr, unsigned long *nextid)\n{\n\tstruct radix_tree_iter iter;\n\tvoid __rcu **slot;\n\tvoid *entry = NULL;\n\tunsigned long base = idr->idr_base;\n\tunsigned long id = *nextid;\n\n\tid = (id < base) ? 0 : id - base;\n\tradix_tree_for_each_slot(slot, &idr->idr_rt, &iter, id) {\n\t\tentry = rcu_dereference_raw(*slot);\n\t\tif (!entry)\n\t\t\tcontinue;\n\t\tif (!xa_is_internal(entry))\n\t\t\tbreak;\n\t\tif (slot != &idr->idr_rt.xa_head && !xa_is_retry(entry))\n\t\t\tbreak;\n\t\tslot = radix_tree_iter_retry(&iter);\n\t}\n\tif (!slot)\n\t\treturn NULL;\n\n\t*nextid = iter.index + base;\n\treturn entry;\n}\nEXPORT_SYMBOL(idr_get_next_ul);\n\n \nvoid *idr_get_next(struct idr *idr, int *nextid)\n{\n\tunsigned long id = *nextid;\n\tvoid *entry = idr_get_next_ul(idr, &id);\n\n\tif (WARN_ON_ONCE(id > INT_MAX))\n\t\treturn NULL;\n\t*nextid = id;\n\treturn entry;\n}\nEXPORT_SYMBOL(idr_get_next);\n\n \nvoid *idr_replace(struct idr *idr, void *ptr, unsigned long id)\n{\n\tstruct radix_tree_node *node;\n\tvoid __rcu **slot = NULL;\n\tvoid *entry;\n\n\tid -= idr->idr_base;\n\n\tentry = __radix_tree_lookup(&idr->idr_rt, id, &node, &slot);\n\tif (!slot || radix_tree_tag_get(&idr->idr_rt, id, IDR_FREE))\n\t\treturn ERR_PTR(-ENOENT);\n\n\t__radix_tree_replace(&idr->idr_rt, node, slot, ptr);\n\n\treturn entry;\n}\nEXPORT_SYMBOL(idr_replace);\n\n \n\n \n\n \nint ida_alloc_range(struct ida *ida, unsigned int min, unsigned int max,\n\t\t\tgfp_t gfp)\n{\n\tXA_STATE(xas, &ida->xa, min / IDA_BITMAP_BITS);\n\tunsigned bit = min % IDA_BITMAP_BITS;\n\tunsigned long flags;\n\tstruct ida_bitmap *bitmap, *alloc = NULL;\n\n\tif ((int)min < 0)\n\t\treturn -ENOSPC;\n\n\tif ((int)max < 0)\n\t\tmax = INT_MAX;\n\nretry:\n\txas_lock_irqsave(&xas, flags);\nnext:\n\tbitmap = xas_find_marked(&xas, max / IDA_BITMAP_BITS, XA_FREE_MARK);\n\tif (xas.xa_index > min / IDA_BITMAP_BITS)\n\t\tbit = 0;\n\tif (xas.xa_index * IDA_BITMAP_BITS + bit > max)\n\t\tgoto nospc;\n\n\tif (xa_is_value(bitmap)) {\n\t\tunsigned long tmp = xa_to_value(bitmap);\n\n\t\tif (bit < BITS_PER_XA_VALUE) {\n\t\t\tbit = find_next_zero_bit(&tmp, BITS_PER_XA_VALUE, bit);\n\t\t\tif (xas.xa_index * IDA_BITMAP_BITS + bit > max)\n\t\t\t\tgoto nospc;\n\t\t\tif (bit < BITS_PER_XA_VALUE) {\n\t\t\t\ttmp |= 1UL << bit;\n\t\t\t\txas_store(&xas, xa_mk_value(tmp));\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tbitmap = alloc;\n\t\tif (!bitmap)\n\t\t\tbitmap = kzalloc(sizeof(*bitmap), GFP_NOWAIT);\n\t\tif (!bitmap)\n\t\t\tgoto alloc;\n\t\tbitmap->bitmap[0] = tmp;\n\t\txas_store(&xas, bitmap);\n\t\tif (xas_error(&xas)) {\n\t\t\tbitmap->bitmap[0] = 0;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (bitmap) {\n\t\tbit = find_next_zero_bit(bitmap->bitmap, IDA_BITMAP_BITS, bit);\n\t\tif (xas.xa_index * IDA_BITMAP_BITS + bit > max)\n\t\t\tgoto nospc;\n\t\tif (bit == IDA_BITMAP_BITS)\n\t\t\tgoto next;\n\n\t\t__set_bit(bit, bitmap->bitmap);\n\t\tif (bitmap_full(bitmap->bitmap, IDA_BITMAP_BITS))\n\t\t\txas_clear_mark(&xas, XA_FREE_MARK);\n\t} else {\n\t\tif (bit < BITS_PER_XA_VALUE) {\n\t\t\tbitmap = xa_mk_value(1UL << bit);\n\t\t} else {\n\t\t\tbitmap = alloc;\n\t\t\tif (!bitmap)\n\t\t\t\tbitmap = kzalloc(sizeof(*bitmap), GFP_NOWAIT);\n\t\t\tif (!bitmap)\n\t\t\t\tgoto alloc;\n\t\t\t__set_bit(bit, bitmap->bitmap);\n\t\t}\n\t\txas_store(&xas, bitmap);\n\t}\nout:\n\txas_unlock_irqrestore(&xas, flags);\n\tif (xas_nomem(&xas, gfp)) {\n\t\txas.xa_index = min / IDA_BITMAP_BITS;\n\t\tbit = min % IDA_BITMAP_BITS;\n\t\tgoto retry;\n\t}\n\tif (bitmap != alloc)\n\t\tkfree(alloc);\n\tif (xas_error(&xas))\n\t\treturn xas_error(&xas);\n\treturn xas.xa_index * IDA_BITMAP_BITS + bit;\nalloc:\n\txas_unlock_irqrestore(&xas, flags);\n\talloc = kzalloc(sizeof(*bitmap), gfp);\n\tif (!alloc)\n\t\treturn -ENOMEM;\n\txas_set(&xas, min / IDA_BITMAP_BITS);\n\tbit = min % IDA_BITMAP_BITS;\n\tgoto retry;\nnospc:\n\txas_unlock_irqrestore(&xas, flags);\n\tkfree(alloc);\n\treturn -ENOSPC;\n}\nEXPORT_SYMBOL(ida_alloc_range);\n\n \nvoid ida_free(struct ida *ida, unsigned int id)\n{\n\tXA_STATE(xas, &ida->xa, id / IDA_BITMAP_BITS);\n\tunsigned bit = id % IDA_BITMAP_BITS;\n\tstruct ida_bitmap *bitmap;\n\tunsigned long flags;\n\n\tif ((int)id < 0)\n\t\treturn;\n\n\txas_lock_irqsave(&xas, flags);\n\tbitmap = xas_load(&xas);\n\n\tif (xa_is_value(bitmap)) {\n\t\tunsigned long v = xa_to_value(bitmap);\n\t\tif (bit >= BITS_PER_XA_VALUE)\n\t\t\tgoto err;\n\t\tif (!(v & (1UL << bit)))\n\t\t\tgoto err;\n\t\tv &= ~(1UL << bit);\n\t\tif (!v)\n\t\t\tgoto delete;\n\t\txas_store(&xas, xa_mk_value(v));\n\t} else {\n\t\tif (!bitmap || !test_bit(bit, bitmap->bitmap))\n\t\t\tgoto err;\n\t\t__clear_bit(bit, bitmap->bitmap);\n\t\txas_set_mark(&xas, XA_FREE_MARK);\n\t\tif (bitmap_empty(bitmap->bitmap, IDA_BITMAP_BITS)) {\n\t\t\tkfree(bitmap);\ndelete:\n\t\t\txas_store(&xas, NULL);\n\t\t}\n\t}\n\txas_unlock_irqrestore(&xas, flags);\n\treturn;\n err:\n\txas_unlock_irqrestore(&xas, flags);\n\tWARN(1, \"ida_free called for id=%d which is not allocated.\\n\", id);\n}\nEXPORT_SYMBOL(ida_free);\n\n \nvoid ida_destroy(struct ida *ida)\n{\n\tXA_STATE(xas, &ida->xa, 0);\n\tstruct ida_bitmap *bitmap;\n\tunsigned long flags;\n\n\txas_lock_irqsave(&xas, flags);\n\txas_for_each(&xas, bitmap, ULONG_MAX) {\n\t\tif (!xa_is_value(bitmap))\n\t\t\tkfree(bitmap);\n\t\txas_store(&xas, NULL);\n\t}\n\txas_unlock_irqrestore(&xas, flags);\n}\nEXPORT_SYMBOL(ida_destroy);\n\n#ifndef __KERNEL__\nextern void xa_dump_index(unsigned long index, unsigned int shift);\n#define IDA_CHUNK_SHIFT\t\tilog2(IDA_BITMAP_BITS)\n\nstatic void ida_dump_entry(void *entry, unsigned long index)\n{\n\tunsigned long i;\n\n\tif (!entry)\n\t\treturn;\n\n\tif (xa_is_node(entry)) {\n\t\tstruct xa_node *node = xa_to_node(entry);\n\t\tunsigned int shift = node->shift + IDA_CHUNK_SHIFT +\n\t\t\tXA_CHUNK_SHIFT;\n\n\t\txa_dump_index(index * IDA_BITMAP_BITS, shift);\n\t\txa_dump_node(node);\n\t\tfor (i = 0; i < XA_CHUNK_SIZE; i++)\n\t\t\tida_dump_entry(node->slots[i],\n\t\t\t\t\tindex | (i << node->shift));\n\t} else if (xa_is_value(entry)) {\n\t\txa_dump_index(index * IDA_BITMAP_BITS, ilog2(BITS_PER_LONG));\n\t\tpr_cont(\"value: data %lx [%px]\\n\", xa_to_value(entry), entry);\n\t} else {\n\t\tstruct ida_bitmap *bitmap = entry;\n\n\t\txa_dump_index(index * IDA_BITMAP_BITS, IDA_CHUNK_SHIFT);\n\t\tpr_cont(\"bitmap: %p data\", bitmap);\n\t\tfor (i = 0; i < IDA_BITMAP_LONGS; i++)\n\t\t\tpr_cont(\" %lx\", bitmap->bitmap[i]);\n\t\tpr_cont(\"\\n\");\n\t}\n}\n\nstatic void ida_dump(struct ida *ida)\n{\n\tstruct xarray *xa = &ida->xa;\n\tpr_debug(\"ida: %p node %p free %d\\n\", ida, xa->xa_head,\n\t\t\t\txa->xa_flags >> ROOT_TAG_SHIFT);\n\tida_dump_entry(xa->xa_head, 0);\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}