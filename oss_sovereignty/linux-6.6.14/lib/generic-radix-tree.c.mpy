{
  "module_name": "generic-radix-tree.c",
  "hash_id": "b603bdfc1a494f33e185ee762386a9b4f9f637d5b6a20072e8f93d22a3663afc",
  "original_prompt": "Ingested from linux-6.6.14/lib/generic-radix-tree.c",
  "human_readable_source": "\n#include <linux/export.h>\n#include <linux/generic-radix-tree.h>\n#include <linux/gfp.h>\n#include <linux/kmemleak.h>\n\n#define GENRADIX_ARY\t\t(PAGE_SIZE / sizeof(struct genradix_node *))\n#define GENRADIX_ARY_SHIFT\tilog2(GENRADIX_ARY)\n\nstruct genradix_node {\n\tunion {\n\t\t \n\t\tstruct genradix_node\t*children[GENRADIX_ARY];\n\n\t\t \n\t\tu8\t\t\tdata[PAGE_SIZE];\n\t};\n};\n\nstatic inline int genradix_depth_shift(unsigned depth)\n{\n\treturn PAGE_SHIFT + GENRADIX_ARY_SHIFT * depth;\n}\n\n \nstatic inline size_t genradix_depth_size(unsigned depth)\n{\n\treturn 1UL << genradix_depth_shift(depth);\n}\n\n \n#define GENRADIX_MAX_DEPTH\t\\\n\tDIV_ROUND_UP(BITS_PER_LONG - PAGE_SHIFT, GENRADIX_ARY_SHIFT)\n\n#define GENRADIX_DEPTH_MASK\t\t\t\t\\\n\t((unsigned long) (roundup_pow_of_two(GENRADIX_MAX_DEPTH + 1) - 1))\n\nstatic inline unsigned genradix_root_to_depth(struct genradix_root *r)\n{\n\treturn (unsigned long) r & GENRADIX_DEPTH_MASK;\n}\n\nstatic inline struct genradix_node *genradix_root_to_node(struct genradix_root *r)\n{\n\treturn (void *) ((unsigned long) r & ~GENRADIX_DEPTH_MASK);\n}\n\n \nvoid *__genradix_ptr(struct __genradix *radix, size_t offset)\n{\n\tstruct genradix_root *r = READ_ONCE(radix->root);\n\tstruct genradix_node *n = genradix_root_to_node(r);\n\tunsigned level\t\t= genradix_root_to_depth(r);\n\n\tif (ilog2(offset) >= genradix_depth_shift(level))\n\t\treturn NULL;\n\n\twhile (1) {\n\t\tif (!n)\n\t\t\treturn NULL;\n\t\tif (!level)\n\t\t\tbreak;\n\n\t\tlevel--;\n\n\t\tn = n->children[offset >> genradix_depth_shift(level)];\n\t\toffset &= genradix_depth_size(level) - 1;\n\t}\n\n\treturn &n->data[offset];\n}\nEXPORT_SYMBOL(__genradix_ptr);\n\nstatic inline struct genradix_node *genradix_alloc_node(gfp_t gfp_mask)\n{\n\tstruct genradix_node *node;\n\n\tnode = (struct genradix_node *)__get_free_page(gfp_mask|__GFP_ZERO);\n\n\t \n\tkmemleak_alloc(node, PAGE_SIZE, 1, gfp_mask);\n\treturn node;\n}\n\nstatic inline void genradix_free_node(struct genradix_node *node)\n{\n\tkmemleak_free(node);\n\tfree_page((unsigned long)node);\n}\n\n \nvoid *__genradix_ptr_alloc(struct __genradix *radix, size_t offset,\n\t\t\t   gfp_t gfp_mask)\n{\n\tstruct genradix_root *v = READ_ONCE(radix->root);\n\tstruct genradix_node *n, *new_node = NULL;\n\tunsigned level;\n\n\t \n\twhile (1) {\n\t\tstruct genradix_root *r = v, *new_root;\n\n\t\tn\t= genradix_root_to_node(r);\n\t\tlevel\t= genradix_root_to_depth(r);\n\n\t\tif (n && ilog2(offset) < genradix_depth_shift(level))\n\t\t\tbreak;\n\n\t\tif (!new_node) {\n\t\t\tnew_node = genradix_alloc_node(gfp_mask);\n\t\t\tif (!new_node)\n\t\t\t\treturn NULL;\n\t\t}\n\n\t\tnew_node->children[0] = n;\n\t\tnew_root = ((struct genradix_root *)\n\t\t\t    ((unsigned long) new_node | (n ? level + 1 : 0)));\n\n\t\tif ((v = cmpxchg_release(&radix->root, r, new_root)) == r) {\n\t\t\tv = new_root;\n\t\t\tnew_node = NULL;\n\t\t}\n\t}\n\n\twhile (level--) {\n\t\tstruct genradix_node **p =\n\t\t\t&n->children[offset >> genradix_depth_shift(level)];\n\t\toffset &= genradix_depth_size(level) - 1;\n\n\t\tn = READ_ONCE(*p);\n\t\tif (!n) {\n\t\t\tif (!new_node) {\n\t\t\t\tnew_node = genradix_alloc_node(gfp_mask);\n\t\t\t\tif (!new_node)\n\t\t\t\t\treturn NULL;\n\t\t\t}\n\n\t\t\tif (!(n = cmpxchg_release(p, NULL, new_node)))\n\t\t\t\tswap(n, new_node);\n\t\t}\n\t}\n\n\tif (new_node)\n\t\tgenradix_free_node(new_node);\n\n\treturn &n->data[offset];\n}\nEXPORT_SYMBOL(__genradix_ptr_alloc);\n\nvoid *__genradix_iter_peek(struct genradix_iter *iter,\n\t\t\t   struct __genradix *radix,\n\t\t\t   size_t objs_per_page)\n{\n\tstruct genradix_root *r;\n\tstruct genradix_node *n;\n\tunsigned level, i;\n\n\tif (iter->offset == SIZE_MAX)\n\t\treturn NULL;\n\nrestart:\n\tr = READ_ONCE(radix->root);\n\tif (!r)\n\t\treturn NULL;\n\n\tn\t= genradix_root_to_node(r);\n\tlevel\t= genradix_root_to_depth(r);\n\n\tif (ilog2(iter->offset) >= genradix_depth_shift(level))\n\t\treturn NULL;\n\n\twhile (level) {\n\t\tlevel--;\n\n\t\ti = (iter->offset >> genradix_depth_shift(level)) &\n\t\t\t(GENRADIX_ARY - 1);\n\n\t\twhile (!n->children[i]) {\n\t\t\tsize_t objs_per_ptr = genradix_depth_size(level);\n\n\t\t\tif (iter->offset + objs_per_ptr < iter->offset) {\n\t\t\t\titer->offset\t= SIZE_MAX;\n\t\t\t\titer->pos\t= SIZE_MAX;\n\t\t\t\treturn NULL;\n\t\t\t}\n\n\t\t\ti++;\n\t\t\titer->offset = round_down(iter->offset + objs_per_ptr,\n\t\t\t\t\t\t  objs_per_ptr);\n\t\t\titer->pos = (iter->offset >> PAGE_SHIFT) *\n\t\t\t\tobjs_per_page;\n\t\t\tif (i == GENRADIX_ARY)\n\t\t\t\tgoto restart;\n\t\t}\n\n\t\tn = n->children[i];\n\t}\n\n\treturn &n->data[iter->offset & (PAGE_SIZE - 1)];\n}\nEXPORT_SYMBOL(__genradix_iter_peek);\n\nstatic void genradix_free_recurse(struct genradix_node *n, unsigned level)\n{\n\tif (level) {\n\t\tunsigned i;\n\n\t\tfor (i = 0; i < GENRADIX_ARY; i++)\n\t\t\tif (n->children[i])\n\t\t\t\tgenradix_free_recurse(n->children[i], level - 1);\n\t}\n\n\tgenradix_free_node(n);\n}\n\nint __genradix_prealloc(struct __genradix *radix, size_t size,\n\t\t\tgfp_t gfp_mask)\n{\n\tsize_t offset;\n\n\tfor (offset = 0; offset < size; offset += PAGE_SIZE)\n\t\tif (!__genradix_ptr_alloc(radix, offset, gfp_mask))\n\t\t\treturn -ENOMEM;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(__genradix_prealloc);\n\nvoid __genradix_free(struct __genradix *radix)\n{\n\tstruct genradix_root *r = xchg(&radix->root, NULL);\n\n\tgenradix_free_recurse(genradix_root_to_node(r),\n\t\t\t      genradix_root_to_depth(r));\n}\nEXPORT_SYMBOL(__genradix_free);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}