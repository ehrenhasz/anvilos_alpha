{
  "module_name": "atomic64.c",
  "hash_id": "9e88e2f4b1d4383429b8d96fcf161066091f10b5b5e554d9993c697f084824eb",
  "original_prompt": "Ingested from linux-6.6.14/lib/atomic64.c",
  "human_readable_source": "\n \n#include <linux/types.h>\n#include <linux/cache.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/atomic.h>\n\n \n#define NR_LOCKS\t16\n\n \nstatic union {\n\traw_spinlock_t lock;\n\tchar pad[L1_CACHE_BYTES];\n} atomic64_lock[NR_LOCKS] __cacheline_aligned_in_smp = {\n\t[0 ... (NR_LOCKS - 1)] = {\n\t\t.lock =  __RAW_SPIN_LOCK_UNLOCKED(atomic64_lock.lock),\n\t},\n};\n\nstatic inline raw_spinlock_t *lock_addr(const atomic64_t *v)\n{\n\tunsigned long addr = (unsigned long) v;\n\n\taddr >>= L1_CACHE_SHIFT;\n\taddr ^= (addr >> 8) ^ (addr >> 16);\n\treturn &atomic64_lock[addr & (NR_LOCKS - 1)].lock;\n}\n\ns64 generic_atomic64_read(const atomic64_t *v)\n{\n\tunsigned long flags;\n\traw_spinlock_t *lock = lock_addr(v);\n\ts64 val;\n\n\traw_spin_lock_irqsave(lock, flags);\n\tval = v->counter;\n\traw_spin_unlock_irqrestore(lock, flags);\n\treturn val;\n}\nEXPORT_SYMBOL(generic_atomic64_read);\n\nvoid generic_atomic64_set(atomic64_t *v, s64 i)\n{\n\tunsigned long flags;\n\traw_spinlock_t *lock = lock_addr(v);\n\n\traw_spin_lock_irqsave(lock, flags);\n\tv->counter = i;\n\traw_spin_unlock_irqrestore(lock, flags);\n}\nEXPORT_SYMBOL(generic_atomic64_set);\n\n#define ATOMIC64_OP(op, c_op)\t\t\t\t\t\t\\\nvoid generic_atomic64_##op(s64 a, atomic64_t *v)\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tunsigned long flags;\t\t\t\t\t\t\\\n\traw_spinlock_t *lock = lock_addr(v);\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\traw_spin_lock_irqsave(lock, flags);\t\t\t\t\\\n\tv->counter c_op a;\t\t\t\t\t\t\\\n\traw_spin_unlock_irqrestore(lock, flags);\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\nEXPORT_SYMBOL(generic_atomic64_##op);\n\n#define ATOMIC64_OP_RETURN(op, c_op)\t\t\t\t\t\\\ns64 generic_atomic64_##op##_return(s64 a, atomic64_t *v)\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tunsigned long flags;\t\t\t\t\t\t\\\n\traw_spinlock_t *lock = lock_addr(v);\t\t\t\t\\\n\ts64 val;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\traw_spin_lock_irqsave(lock, flags);\t\t\t\t\\\n\tval = (v->counter c_op a);\t\t\t\t\t\\\n\traw_spin_unlock_irqrestore(lock, flags);\t\t\t\\\n\treturn val;\t\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\nEXPORT_SYMBOL(generic_atomic64_##op##_return);\n\n#define ATOMIC64_FETCH_OP(op, c_op)\t\t\t\t\t\\\ns64 generic_atomic64_fetch_##op(s64 a, atomic64_t *v)\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tunsigned long flags;\t\t\t\t\t\t\\\n\traw_spinlock_t *lock = lock_addr(v);\t\t\t\t\\\n\ts64 val;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\traw_spin_lock_irqsave(lock, flags);\t\t\t\t\\\n\tval = v->counter;\t\t\t\t\t\t\\\n\tv->counter c_op a;\t\t\t\t\t\t\\\n\traw_spin_unlock_irqrestore(lock, flags);\t\t\t\\\n\treturn val;\t\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\nEXPORT_SYMBOL(generic_atomic64_fetch_##op);\n\n#define ATOMIC64_OPS(op, c_op)\t\t\t\t\t\t\\\n\tATOMIC64_OP(op, c_op)\t\t\t\t\t\t\\\n\tATOMIC64_OP_RETURN(op, c_op)\t\t\t\t\t\\\n\tATOMIC64_FETCH_OP(op, c_op)\n\nATOMIC64_OPS(add, +=)\nATOMIC64_OPS(sub, -=)\n\n#undef ATOMIC64_OPS\n#define ATOMIC64_OPS(op, c_op)\t\t\t\t\t\t\\\n\tATOMIC64_OP(op, c_op)\t\t\t\t\t\t\\\n\tATOMIC64_FETCH_OP(op, c_op)\n\nATOMIC64_OPS(and, &=)\nATOMIC64_OPS(or, |=)\nATOMIC64_OPS(xor, ^=)\n\n#undef ATOMIC64_OPS\n#undef ATOMIC64_FETCH_OP\n#undef ATOMIC64_OP\n\ns64 generic_atomic64_dec_if_positive(atomic64_t *v)\n{\n\tunsigned long flags;\n\traw_spinlock_t *lock = lock_addr(v);\n\ts64 val;\n\n\traw_spin_lock_irqsave(lock, flags);\n\tval = v->counter - 1;\n\tif (val >= 0)\n\t\tv->counter = val;\n\traw_spin_unlock_irqrestore(lock, flags);\n\treturn val;\n}\nEXPORT_SYMBOL(generic_atomic64_dec_if_positive);\n\ns64 generic_atomic64_cmpxchg(atomic64_t *v, s64 o, s64 n)\n{\n\tunsigned long flags;\n\traw_spinlock_t *lock = lock_addr(v);\n\ts64 val;\n\n\traw_spin_lock_irqsave(lock, flags);\n\tval = v->counter;\n\tif (val == o)\n\t\tv->counter = n;\n\traw_spin_unlock_irqrestore(lock, flags);\n\treturn val;\n}\nEXPORT_SYMBOL(generic_atomic64_cmpxchg);\n\ns64 generic_atomic64_xchg(atomic64_t *v, s64 new)\n{\n\tunsigned long flags;\n\traw_spinlock_t *lock = lock_addr(v);\n\ts64 val;\n\n\traw_spin_lock_irqsave(lock, flags);\n\tval = v->counter;\n\tv->counter = new;\n\traw_spin_unlock_irqrestore(lock, flags);\n\treturn val;\n}\nEXPORT_SYMBOL(generic_atomic64_xchg);\n\ns64 generic_atomic64_fetch_add_unless(atomic64_t *v, s64 a, s64 u)\n{\n\tunsigned long flags;\n\traw_spinlock_t *lock = lock_addr(v);\n\ts64 val;\n\n\traw_spin_lock_irqsave(lock, flags);\n\tval = v->counter;\n\tif (val != u)\n\t\tv->counter += a;\n\traw_spin_unlock_irqrestore(lock, flags);\n\n\treturn val;\n}\nEXPORT_SYMBOL(generic_atomic64_fetch_add_unless);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}