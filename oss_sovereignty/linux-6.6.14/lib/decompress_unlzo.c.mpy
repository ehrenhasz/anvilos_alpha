{
  "module_name": "decompress_unlzo.c",
  "hash_id": "3171e465fcb28d1828a3de2c3e2628e99f00b92298205ec7695e2a7ce561e7f3",
  "original_prompt": "Ingested from linux-6.6.14/lib/decompress_unlzo.c",
  "human_readable_source": "\n \n\n#ifdef STATIC\n#define PREBOOT\n#include \"lzo/lzo1x_decompress_safe.c\"\n#else\n#include <linux/decompress/unlzo.h>\n#endif\n\n#include <linux/types.h>\n#include <linux/lzo.h>\n#include <linux/decompress/mm.h>\n\n#include <linux/compiler.h>\n#include <asm/unaligned.h>\n\nstatic const unsigned char lzop_magic[] = {\n\t0x89, 0x4c, 0x5a, 0x4f, 0x00, 0x0d, 0x0a, 0x1a, 0x0a };\n\n#define LZO_BLOCK_SIZE        (256*1024l)\n#define HEADER_HAS_FILTER      0x00000800L\n#define HEADER_SIZE_MIN       (9 + 7     + 4 + 8     + 1       + 4)\n#define HEADER_SIZE_MAX       (9 + 7 + 1 + 8 + 8 + 4 + 1 + 255 + 4)\n\nSTATIC inline long INIT parse_header(u8 *input, long *skip, long in_len)\n{\n\tint l;\n\tu8 *parse = input;\n\tu8 *end = input + in_len;\n\tu16 version;\n\n\t \n\tif (in_len < HEADER_SIZE_MIN)\n\t\treturn 0;\n\n\t \n\tfor (l = 0; l < 9; l++) {\n\t\tif (*parse++ != lzop_magic[l])\n\t\t\treturn 0;\n\t}\n\t \n\tversion = get_unaligned_be16(parse);\n\tparse += 7;\n\tif (version >= 0x0940)\n\t\tparse++;\n\tif (get_unaligned_be32(parse) & HEADER_HAS_FILTER)\n\t\tparse += 8;  \n\telse\n\t\tparse += 4;  \n\n\t \n\tif (end - parse < 8 + 1 + 4)\n\t\treturn 0;\n\n\t \n\tparse += 8;\n\tif (version >= 0x0940)\n\t\tparse += 4;\t \n\n\tl = *parse++;\n\t \n\tif (end - parse < l + 4)\n\t\treturn 0;\n\tparse += l + 4;\n\n\t*skip = parse - input;\n\treturn 1;\n}\n\nSTATIC int INIT unlzo(u8 *input, long in_len,\n\t\t\t\tlong (*fill)(void *, unsigned long),\n\t\t\t\tlong (*flush)(void *, unsigned long),\n\t\t\t\tu8 *output, long *posp,\n\t\t\t\tvoid (*error) (char *x))\n{\n\tu8 r = 0;\n\tlong skip = 0;\n\tu32 src_len, dst_len;\n\tsize_t tmp;\n\tu8 *in_buf, *in_buf_save, *out_buf;\n\tint ret = -1;\n\n\tif (output) {\n\t\tout_buf = output;\n\t} else if (!flush) {\n\t\terror(\"NULL output pointer and no flush function provided\");\n\t\tgoto exit;\n\t} else {\n\t\tout_buf = malloc(LZO_BLOCK_SIZE);\n\t\tif (!out_buf) {\n\t\t\terror(\"Could not allocate output buffer\");\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\tif (input && fill) {\n\t\terror(\"Both input pointer and fill function provided, don't know what to do\");\n\t\tgoto exit_1;\n\t} else if (input) {\n\t\tin_buf = input;\n\t} else if (!fill) {\n\t\terror(\"NULL input pointer and missing fill function\");\n\t\tgoto exit_1;\n\t} else {\n\t\tin_buf = malloc(lzo1x_worst_compress(LZO_BLOCK_SIZE));\n\t\tif (!in_buf) {\n\t\t\terror(\"Could not allocate input buffer\");\n\t\t\tgoto exit_1;\n\t\t}\n\t}\n\tin_buf_save = in_buf;\n\n\tif (posp)\n\t\t*posp = 0;\n\n\tif (fill) {\n\t\t \n\t\tin_buf += HEADER_SIZE_MAX;\n\t\tin_len = fill(in_buf, HEADER_SIZE_MAX);\n\t}\n\n\tif (!parse_header(in_buf, &skip, in_len)) {\n\t\terror(\"invalid header\");\n\t\tgoto exit_2;\n\t}\n\tin_buf += skip;\n\tin_len -= skip;\n\n\tif (fill) {\n\t\t \n\t\tmemcpy(in_buf_save, in_buf, in_len);\n\t\tin_buf = in_buf_save;\n\t}\n\n\tif (posp)\n\t\t*posp = skip;\n\n\tfor (;;) {\n\t\t \n\t\tif (fill && in_len < 4) {\n\t\t\tskip = fill(in_buf + in_len, 4 - in_len);\n\t\t\tif (skip > 0)\n\t\t\t\tin_len += skip;\n\t\t}\n\t\tif (in_len < 4) {\n\t\t\terror(\"file corrupted\");\n\t\t\tgoto exit_2;\n\t\t}\n\t\tdst_len = get_unaligned_be32(in_buf);\n\t\tin_buf += 4;\n\t\tin_len -= 4;\n\n\t\t \n\t\tif (dst_len == 0) {\n\t\t\tif (posp)\n\t\t\t\t*posp += 4;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (dst_len > LZO_BLOCK_SIZE) {\n\t\t\terror(\"dest len longer than block size\");\n\t\t\tgoto exit_2;\n\t\t}\n\n\t\t \n\t\tif (fill && in_len < 8) {\n\t\t\tskip = fill(in_buf + in_len, 8 - in_len);\n\t\t\tif (skip > 0)\n\t\t\t\tin_len += skip;\n\t\t}\n\t\tif (in_len < 8) {\n\t\t\terror(\"file corrupted\");\n\t\t\tgoto exit_2;\n\t\t}\n\t\tsrc_len = get_unaligned_be32(in_buf);\n\t\tin_buf += 8;\n\t\tin_len -= 8;\n\n\t\tif (src_len <= 0 || src_len > dst_len) {\n\t\t\terror(\"file corrupted\");\n\t\t\tgoto exit_2;\n\t\t}\n\n\t\t \n\t\tif (fill && in_len < src_len) {\n\t\t\tskip = fill(in_buf + in_len, src_len - in_len);\n\t\t\tif (skip > 0)\n\t\t\t\tin_len += skip;\n\t\t}\n\t\tif (in_len < src_len) {\n\t\t\terror(\"file corrupted\");\n\t\t\tgoto exit_2;\n\t\t}\n\t\ttmp = dst_len;\n\n\t\t \n\t\tif (unlikely(dst_len == src_len))\n\t\t\tmemcpy(out_buf, in_buf, src_len);\n\t\telse {\n\t\t\tr = lzo1x_decompress_safe((u8 *) in_buf, src_len,\n\t\t\t\t\t\tout_buf, &tmp);\n\n\t\t\tif (r != LZO_E_OK || dst_len != tmp) {\n\t\t\t\terror(\"Compressed data violation\");\n\t\t\t\tgoto exit_2;\n\t\t\t}\n\t\t}\n\n\t\tif (flush && flush(out_buf, dst_len) != dst_len)\n\t\t\tgoto exit_2;\n\t\tif (output)\n\t\t\tout_buf += dst_len;\n\t\tif (posp)\n\t\t\t*posp += src_len + 12;\n\n\t\tin_buf += src_len;\n\t\tin_len -= src_len;\n\t\tif (fill) {\n\t\t\t \n\t\t\tif (in_len > 0)\n\t\t\t\tfor (skip = 0; skip < in_len; ++skip)\n\t\t\t\t\tin_buf_save[skip] = in_buf[skip];\n\t\t\tin_buf = in_buf_save;\n\t\t}\n\t}\n\n\tret = 0;\nexit_2:\n\tif (!input)\n\t\tfree(in_buf_save);\nexit_1:\n\tif (!output)\n\t\tfree(out_buf);\nexit:\n\treturn ret;\n}\n\n#ifdef PREBOOT\nSTATIC int INIT __decompress(unsigned char *buf, long len,\n\t\t\t   long (*fill)(void*, unsigned long),\n\t\t\t   long (*flush)(void*, unsigned long),\n\t\t\t   unsigned char *out_buf, long olen,\n\t\t\t   long *pos,\n\t\t\t   void (*error)(char *x))\n{\n\treturn unlzo(buf, len, fill, flush, out_buf, pos, error);\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}