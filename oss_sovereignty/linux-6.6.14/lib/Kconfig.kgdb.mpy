{
  "module_name": "Kconfig.kgdb",
  "hash_id": "1ffa7436f14dae78e3d448d0000f4f38dd9d654ab92e3f425a53cead3092e958",
  "original_prompt": "Ingested from linux-6.6.14/lib/Kconfig.kgdb",
  "human_readable_source": "# SPDX-License-Identifier: GPL-2.0-only\n\nconfig HAVE_ARCH_KGDB\n\tbool\n\n# set if architecture has the its kgdb_arch_handle_qxfer_pkt\n# function to enable gdb stub to address XML packet sent from GDB.\nconfig HAVE_ARCH_KGDB_QXFER_PKT\n\tbool\n\nmenuconfig KGDB\n\tbool \"KGDB: kernel debugger\"\n\tdepends on HAVE_ARCH_KGDB\n\tdepends on DEBUG_KERNEL\n\thelp\n\t  If you say Y here, it will be possible to remotely debug the\n\t  kernel using gdb.  It is recommended but not required, that\n\t  you also turn on the kernel config option\n\t  CONFIG_FRAME_POINTER to aid in producing more reliable stack\n\t  backtraces in the external debugger.  Documentation of\n\t  kernel debugger is available at http://kgdb.sourceforge.net\n\t  as well as in Documentation/dev-tools/kgdb.rst.  If\n\t  unsure, say N.\n\nif KGDB\n\nconfig KGDB_HONOUR_BLOCKLIST\n\tbool \"KGDB: use kprobe blocklist to prohibit unsafe breakpoints\"\n\tdepends on HAVE_KPROBES\n\tdepends on MODULES\n\tselect KPROBES\n\tdefault y\n\thelp\n\t  If set to Y the debug core will use the kprobe blocklist to\n\t  identify symbols where it is unsafe to set breakpoints.\n\t  In particular this disallows instrumentation of functions\n\t  called during debug trap handling and thus makes it very\n\t  difficult to inadvertently provoke recursive trap handling.\n\n\t  If unsure, say Y.\n\nconfig KGDB_SERIAL_CONSOLE\n\ttristate \"KGDB: use kgdb over the serial console\"\n\tselect CONSOLE_POLL\n\tselect MAGIC_SYSRQ\n\tdepends on TTY && HW_CONSOLE\n\tdefault y\n\thelp\n\t  Share a serial console with kgdb. Sysrq-g must be used\n\t  to break in initially.\n\nconfig KGDB_TESTS\n\tbool \"KGDB: internal test suite\"\n\tdefault n\n\thelp\n\t  This is a kgdb I/O module specifically designed to test\n\t  kgdb's internal functions.  This kgdb I/O module is\n\t  intended to for the development of new kgdb stubs\n\t  as well as regression testing the kgdb internals.\n\t  See the drivers/misc/kgdbts.c for the details about\n\t  the tests.  The most basic of this I/O module is to boot\n\t  a kernel boot arguments \"kgdbwait kgdbts=V1F100\"\n\nconfig KGDB_TESTS_ON_BOOT\n\tbool \"KGDB: Run tests on boot\"\n\tdepends on KGDB_TESTS\n\tdefault n\n\thelp\n\t  Run the kgdb tests on boot up automatically without the need\n\t  to pass in a kernel parameter\n\nconfig KGDB_TESTS_BOOT_STRING\n\tstring \"KGDB: which internal kgdb tests to run\"\n\tdepends on KGDB_TESTS_ON_BOOT\n\tdefault \"V1F100\"\n\thelp\n\t  This is the command string to send the kgdb test suite on\n\t  boot.  See the drivers/misc/kgdbts.c for detailed\n\t  information about other strings you could use beyond the\n\t  default of V1F100.\n\nconfig KGDB_LOW_LEVEL_TRAP\n       bool \"KGDB: Allow debugging with traps in notifiers\"\n       depends on X86 || MIPS\n       default n\n       help\n\t This will add an extra call back to kgdb for the breakpoint\n\t exception handler which will allow kgdb to step through a\n\t notify handler.\n\nconfig KGDB_KDB\n\tbool \"KGDB_KDB: include kdb frontend for kgdb\"\n\tdefault n\n\thelp\n\t  KDB frontend for kernel\n\nconfig KDB_DEFAULT_ENABLE\n\thex \"KDB: Select kdb command functions to be enabled by default\"\n\tdepends on KGDB_KDB\n\tdefault 0x1\n\thelp\n\t  Specifiers which kdb commands are enabled by default. This may\n\t  be set to 1 or 0 to enable all commands or disable almost all\n\t  commands.\n\n\t  Alternatively the following bitmask applies:\n\n\t    0x0002 - allow arbitrary reads from memory and symbol lookup\n\t    0x0004 - allow arbitrary writes to memory\n\t    0x0008 - allow current register state to be inspected\n\t    0x0010 - allow current register state to be modified\n\t    0x0020 - allow passive inspection (backtrace, process list, lsmod)\n\t    0x0040 - allow flow control management (breakpoint, single step)\n\t    0x0080 - enable signalling of processes\n\t    0x0100 - allow machine to be rebooted\n\n\t  The config option merely sets the default at boot time. Both\n\t  issuing 'echo X > /sys/module/kdb/parameters/cmd_enable' or\n\t  setting with kdb.cmd_enable=X kernel command line option will\n\t  override the default settings.\n\nconfig KDB_KEYBOARD\n\tbool \"KGDB_KDB: keyboard as input device\"\n\tdepends on VT && KGDB_KDB && !PARISC\n\tdefault n\n\thelp\n\t  KDB can use a PS/2 type keyboard for an input device\n\nconfig KDB_CONTINUE_CATASTROPHIC\n\tint \"KDB: continue after catastrophic errors\"\n\tdepends on KGDB_KDB\n\tdefault \"0\"\n\thelp\n\t  This integer controls the behaviour of kdb when the kernel gets a\n\t  catastrophic error, i.e. for a panic or oops.\n\t  When KDB is active and a catastrophic error occurs, nothing extra\n\t  will happen until you type 'go'.\n\t  CONFIG_KDB_CONTINUE_CATASTROPHIC == 0 (default). The first time\n\t  you type 'go', you will be warned by kdb. The secend time you type\n\t  'go', KDB tries to continue. No guarantees that the\n\t  kernel is still usable in this situation.\n\t  CONFIG_KDB_CONTINUE_CATASTROPHIC == 1. KDB tries to continue.\n\t  No guarantees that the kernel is still usable in this situation.\n\t  CONFIG_KDB_CONTINUE_CATASTROPHIC == 2. KDB forces a reboot.\n\t  If you are not sure, say 0.\n\nconfig ARCH_HAS_EARLY_DEBUG\n\tbool\n\tdefault n\n\thelp\n\t  If an architecture can definitely handle entering the debugger\n\t  when early_param's are parsed then it select this config.\n\t  Otherwise, if \"kgdbwait\" is passed on the kernel command line it\n\t  won't actually be processed until dbg_late_init() just after the\n\t  call to kgdb_arch_late() is made.\n\n\t  NOTE: Even if this isn't selected by an architecture we will\n\t  still try to register kgdb to handle breakpoints and crashes\n\t  when early_param's are parsed, we just won't act on the\n\t  \"kgdbwait\" parameter until dbg_late_init().  If you get a\n\t  crash and try to drop into kgdb somewhere between these two\n\t  places you might or might not end up being able to use kgdb\n\t  depending on exactly how far along the architecture has initted.\n\nendif # KGDB\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}