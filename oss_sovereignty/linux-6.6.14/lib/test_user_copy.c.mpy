{
  "module_name": "test_user_copy.c",
  "hash_id": "393388d9c7ac2551e961a112a037c4c87f221565a96fb936850e234d03aa9151",
  "original_prompt": "Ingested from linux-6.6.14/lib/test_user_copy.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n\n \n#if BITS_PER_LONG == 64 || (!(defined(CONFIG_ARM) && !defined(MMU)) && \\\n\t\t\t    !defined(CONFIG_M68K) &&\t\t\\\n\t\t\t    !defined(CONFIG_MICROBLAZE) &&\t\\\n\t\t\t    !defined(CONFIG_NIOS2) &&\t\t\\\n\t\t\t    !defined(CONFIG_PPC32) &&\t\t\\\n\t\t\t    !defined(CONFIG_SUPERH))\n# define TEST_U64\n#endif\n\n#define test(condition, msg, ...)\t\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\tint cond = (condition);\t\t\t\t\t\t\\\n\tif (cond)\t\t\t\t\t\t\t\\\n\t\tpr_warn(\"[%d] \" msg \"\\n\", __LINE__, ##__VA_ARGS__);\t\\\n\tcond;\t\t\t\t\t\t\t\t\\\n})\n\nstatic bool is_zeroed(void *from, size_t size)\n{\n\treturn memchr_inv(from, 0x0, size) == NULL;\n}\n\nstatic int test_check_nonzero_user(char *kmem, char __user *umem, size_t size)\n{\n\tint ret = 0;\n\tsize_t start, end, i, zero_start, zero_end;\n\n\tif (test(size < 2 * PAGE_SIZE, \"buffer too small\"))\n\t\treturn -EINVAL;\n\n\t \n\tsize = 1024;\n\tstart = PAGE_SIZE - (size / 2);\n\n\tkmem += start;\n\tumem += start;\n\n\tzero_start = size / 4;\n\tzero_end = size - zero_start;\n\n\t \n\n\tmemset(kmem, 0x0, size);\n\tfor (i = 1; i < zero_start; i += 2)\n\t\tkmem[i] = 0xff;\n\tfor (i = zero_end; i < size; i += 2)\n\t\tkmem[i] = 0xff;\n\n\tret |= test(copy_to_user(umem, kmem, size),\n\t\t    \"legitimate copy_to_user failed\");\n\n\tfor (start = 0; start <= size; start++) {\n\t\tfor (end = start; end <= size; end++) {\n\t\t\tsize_t len = end - start;\n\t\t\tint retval = check_zeroed_user(umem + start, len);\n\t\t\tint expected = is_zeroed(kmem + start, len);\n\n\t\t\tret |= test(retval != expected,\n\t\t\t\t    \"check_nonzero_user(=%d) != memchr_inv(=%d) mismatch (start=%zu, end=%zu)\",\n\t\t\t\t    retval, expected, start, end);\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic int test_copy_struct_from_user(char *kmem, char __user *umem,\n\t\t\t\t      size_t size)\n{\n\tint ret = 0;\n\tchar *umem_src = NULL, *expected = NULL;\n\tsize_t ksize, usize;\n\n\tumem_src = kmalloc(size, GFP_KERNEL);\n\tret = test(umem_src == NULL, \"kmalloc failed\");\n\tif (ret)\n\t\tgoto out_free;\n\n\texpected = kmalloc(size, GFP_KERNEL);\n\tret = test(expected == NULL, \"kmalloc failed\");\n\tif (ret)\n\t\tgoto out_free;\n\n\t \n\tmemset(umem_src, 0x3e, size);\n\tret |= test(copy_to_user(umem, umem_src, size),\n\t\t    \"legitimate copy_to_user failed\");\n\n\t \n\tksize = size;\n\tusize = size;\n\n\tmemcpy(expected, umem_src, ksize);\n\n\tmemset(kmem, 0x0, size);\n\tret |= test(copy_struct_from_user(kmem, ksize, umem, usize),\n\t\t    \"copy_struct_from_user(usize == ksize) failed\");\n\tret |= test(memcmp(kmem, expected, ksize),\n\t\t    \"copy_struct_from_user(usize == ksize) gives unexpected copy\");\n\n\t \n\tksize = size;\n\tusize = size / 2;\n\n\tmemcpy(expected, umem_src, usize);\n\tmemset(expected + usize, 0x0, ksize - usize);\n\n\tmemset(kmem, 0x0, size);\n\tret |= test(copy_struct_from_user(kmem, ksize, umem, usize),\n\t\t    \"copy_struct_from_user(usize < ksize) failed\");\n\tret |= test(memcmp(kmem, expected, ksize),\n\t\t    \"copy_struct_from_user(usize < ksize) gives unexpected copy\");\n\n\t \n\tksize = size / 2;\n\tusize = size;\n\n\tmemset(kmem, 0x0, size);\n\tret |= test(copy_struct_from_user(kmem, ksize, umem, usize) != -E2BIG,\n\t\t    \"copy_struct_from_user(usize > ksize) didn't give E2BIG\");\n\n\t \n\tksize = size / 2;\n\tusize = size;\n\n\tmemcpy(expected, umem_src, ksize);\n\tret |= test(clear_user(umem + ksize, usize - ksize),\n\t\t    \"legitimate clear_user failed\");\n\n\tmemset(kmem, 0x0, size);\n\tret |= test(copy_struct_from_user(kmem, ksize, umem, usize),\n\t\t    \"copy_struct_from_user(usize > ksize) failed\");\n\tret |= test(memcmp(kmem, expected, ksize),\n\t\t    \"copy_struct_from_user(usize > ksize) gives unexpected copy\");\n\nout_free:\n\tkfree(expected);\n\tkfree(umem_src);\n\treturn ret;\n}\n\nstatic int __init test_user_copy_init(void)\n{\n\tint ret = 0;\n\tchar *kmem;\n\tchar __user *usermem;\n\tchar *bad_usermem;\n\tunsigned long user_addr;\n\tu8 val_u8;\n\tu16 val_u16;\n\tu32 val_u32;\n#ifdef TEST_U64\n\tu64 val_u64;\n#endif\n\n\tkmem = kmalloc(PAGE_SIZE * 2, GFP_KERNEL);\n\tif (!kmem)\n\t\treturn -ENOMEM;\n\n\tuser_addr = vm_mmap(NULL, 0, PAGE_SIZE * 2,\n\t\t\t    PROT_READ | PROT_WRITE | PROT_EXEC,\n\t\t\t    MAP_ANONYMOUS | MAP_PRIVATE, 0);\n\tif (user_addr >= (unsigned long)(TASK_SIZE)) {\n\t\tpr_warn(\"Failed to allocate user memory\\n\");\n\t\tkfree(kmem);\n\t\treturn -ENOMEM;\n\t}\n\n\tusermem = (char __user *)user_addr;\n\tbad_usermem = (char *)user_addr;\n\n\t \n\tmemset(kmem, 0x3a, PAGE_SIZE * 2);\n\tret |= test(copy_to_user(usermem, kmem, PAGE_SIZE),\n\t\t    \"legitimate copy_to_user failed\");\n\tmemset(kmem, 0x0, PAGE_SIZE);\n\tret |= test(copy_from_user(kmem, usermem, PAGE_SIZE),\n\t\t    \"legitimate copy_from_user failed\");\n\tret |= test(memcmp(kmem, kmem + PAGE_SIZE, PAGE_SIZE),\n\t\t    \"legitimate usercopy failed to copy data\");\n\n#define test_legit(size, check)\t\t\t\t\t\t  \\\n\tdo {\t\t\t\t\t\t\t\t  \\\n\t\tval_##size = check;\t\t\t\t\t  \\\n\t\tret |= test(put_user(val_##size, (size __user *)usermem), \\\n\t\t    \"legitimate put_user (\" #size \") failed\");\t\t  \\\n\t\tval_##size = 0;\t\t\t\t\t\t  \\\n\t\tret |= test(get_user(val_##size, (size __user *)usermem), \\\n\t\t    \"legitimate get_user (\" #size \") failed\");\t\t  \\\n\t\tret |= test(val_##size != check,\t\t\t  \\\n\t\t    \"legitimate get_user (\" #size \") failed to do copy\"); \\\n\t\tif (val_##size != check) {\t\t\t\t  \\\n\t\t\tpr_info(\"0x%llx != 0x%llx\\n\",\t\t\t  \\\n\t\t\t\t(unsigned long long)val_##size,\t\t  \\\n\t\t\t\t(unsigned long long)check);\t\t  \\\n\t\t}\t\t\t\t\t\t\t  \\\n\t} while (0)\n\n\ttest_legit(u8,  0x5a);\n\ttest_legit(u16, 0x5a5b);\n\ttest_legit(u32, 0x5a5b5c5d);\n#ifdef TEST_U64\n\ttest_legit(u64, 0x5a5b5c5d6a6b6c6d);\n#endif\n#undef test_legit\n\n\t \n\tret |= test_check_nonzero_user(kmem, usermem, 2 * PAGE_SIZE);\n\t \n\tret |= test_copy_struct_from_user(kmem, usermem, 2 * PAGE_SIZE);\n\n\t \n\n\t \n\tmemset(kmem, 0x5a, PAGE_SIZE);\n\tmemset(kmem + PAGE_SIZE, 0, PAGE_SIZE);\n\n\t \n\tret |= test(!copy_from_user(kmem, (char __user *)(kmem + PAGE_SIZE),\n\t\t\t\t    PAGE_SIZE),\n\t\t    \"illegal all-kernel copy_from_user passed\");\n\n\t \n\tret |= test(memcmp(kmem + PAGE_SIZE, kmem, PAGE_SIZE),\n\t\t    \"zeroing failure for illegal all-kernel copy_from_user\");\n\n#if 0\n\t \n\tret |= test(!copy_from_user(bad_usermem, (char __user *)kmem,\n\t\t\t\t    PAGE_SIZE),\n\t\t    \"illegal reversed copy_from_user passed\");\n#endif\n\tret |= test(!copy_to_user((char __user *)kmem, kmem + PAGE_SIZE,\n\t\t\t\t  PAGE_SIZE),\n\t\t    \"illegal all-kernel copy_to_user passed\");\n\tret |= test(!copy_to_user((char __user *)kmem, bad_usermem,\n\t\t\t\t  PAGE_SIZE),\n\t\t    \"illegal reversed copy_to_user passed\");\n\n#define test_illegal(size, check)\t\t\t\t\t    \\\n\tdo {\t\t\t\t\t\t\t\t    \\\n\t\tval_##size = (check);\t\t\t\t\t    \\\n\t\tret |= test(!get_user(val_##size, (size __user *)kmem),\t    \\\n\t\t    \"illegal get_user (\" #size \") passed\");\t\t    \\\n\t\tret |= test(val_##size != (size)0,\t\t\t    \\\n\t\t    \"zeroing failure for illegal get_user (\" #size \")\");    \\\n\t\tif (val_##size != (size)0) {\t\t\t\t    \\\n\t\t\tpr_info(\"0x%llx != 0\\n\",\t\t\t    \\\n\t\t\t\t(unsigned long long)val_##size);\t    \\\n\t\t}\t\t\t\t\t\t\t    \\\n\t\tret |= test(!put_user(val_##size, (size __user *)kmem),\t    \\\n\t\t    \"illegal put_user (\" #size \") passed\");\t\t    \\\n\t} while (0)\n\n\ttest_illegal(u8,  0x5a);\n\ttest_illegal(u16, 0x5a5b);\n\ttest_illegal(u32, 0x5a5b5c5d);\n#ifdef TEST_U64\n\ttest_illegal(u64, 0x5a5b5c5d6a6b6c6d);\n#endif\n#undef test_illegal\n\n\tvm_munmap(user_addr, PAGE_SIZE * 2);\n\tkfree(kmem);\n\n\tif (ret == 0) {\n\t\tpr_info(\"tests passed.\\n\");\n\t\treturn 0;\n\t}\n\n\treturn -EINVAL;\n}\n\nmodule_init(test_user_copy_init);\n\nstatic void __exit test_user_copy_exit(void)\n{\n\tpr_info(\"unloaded.\\n\");\n}\n\nmodule_exit(test_user_copy_exit);\n\nMODULE_AUTHOR(\"Kees Cook <keescook@chromium.org>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}