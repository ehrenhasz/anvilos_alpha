{
  "module_name": "inflate.c",
  "hash_id": "2b9e17f96b535fbac9b17037000923a698b61bee22dbf92de0d7196e6fef013f",
  "original_prompt": "Ingested from linux-6.6.14/lib/inflate.c",
  "human_readable_source": "\n#define DEBG(x)\n#define DEBG1(x)\n \n\n \n\n \n\n\n \n#include <linux/compiler.h>\n#ifdef NO_INFLATE_MALLOC\n#include <linux/slab.h>\n#endif\n\n#ifdef RCSID\nstatic char rcsid[] = \"#Id: inflate.c,v 0.14 1993/06/10 13:27:04 jloup Exp #\";\n#endif\n\n#ifndef STATIC\n\n#if defined(STDC_HEADERS) || defined(HAVE_STDLIB_H)\n#  include <sys/types.h>\n#  include <stdlib.h>\n#endif\n\n#include \"gzip.h\"\n#define STATIC\n#endif  \n\n#ifndef INIT\n#define INIT\n#endif\n\t\n#define slide window\n\n \nstruct huft {\n  uch e;                 \n  uch b;                 \n  union {\n    ush n;               \n    struct huft *t;      \n  } v;\n};\n\n\n \nSTATIC int INIT huft_build OF((unsigned *, unsigned, unsigned, \n\t\tconst ush *, const ush *, struct huft **, int *));\nSTATIC int INIT huft_free OF((struct huft *));\nSTATIC int INIT inflate_codes OF((struct huft *, struct huft *, int, int));\nSTATIC int INIT inflate_stored OF((void));\nSTATIC int INIT inflate_fixed OF((void));\nSTATIC int INIT inflate_dynamic OF((void));\nSTATIC int INIT inflate_block OF((int *));\nSTATIC int INIT inflate OF((void));\n\n\n \n \n \n#define wp outcnt\n#define flush_output(w) (wp=(w),flush_window())\n\n \nstatic const unsigned border[] = {     \n        16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};\nstatic const ush cplens[] = {          \n        3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,\n        35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0};\n         \nstatic const ush cplext[] = {          \n        0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2,\n        3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 99, 99};  \nstatic const ush cpdist[] = {          \n        1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,\n        257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,\n        8193, 12289, 16385, 24577};\nstatic const ush cpdext[] = {          \n        0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6,\n        7, 7, 8, 8, 9, 9, 10, 10, 11, 11,\n        12, 12, 13, 13};\n\n\n\n \n\nSTATIC ulg bb;                          \nSTATIC unsigned bk;                     \n\nSTATIC const ush mask_bits[] = {\n    0x0000,\n    0x0001, 0x0003, 0x0007, 0x000f, 0x001f, 0x003f, 0x007f, 0x00ff,\n    0x01ff, 0x03ff, 0x07ff, 0x0fff, 0x1fff, 0x3fff, 0x7fff, 0xffff\n};\n\n#define NEXTBYTE()  ({ int v = get_byte(); if (v < 0) goto underrun; (uch)v; })\n#define NEEDBITS(n) {while(k<(n)){b|=((ulg)NEXTBYTE())<<k;k+=8;}}\n#define DUMPBITS(n) {b>>=(n);k-=(n);}\n\n#ifndef NO_INFLATE_MALLOC\n \n\nstatic unsigned long malloc_ptr;\nstatic int malloc_count;\n\nstatic void *malloc(int size)\n{\n       void *p;\n\n       if (size < 0)\n\t\terror(\"Malloc error\");\n       if (!malloc_ptr)\n\t\tmalloc_ptr = free_mem_ptr;\n\n       malloc_ptr = (malloc_ptr + 3) & ~3;      \n\n       p = (void *)malloc_ptr;\n       malloc_ptr += size;\n\n       if (free_mem_end_ptr && malloc_ptr >= free_mem_end_ptr)\n\t\terror(\"Out of memory\");\n\n       malloc_count++;\n       return p;\n}\n\nstatic void free(void *where)\n{\n       malloc_count--;\n       if (!malloc_count)\n\t\tmalloc_ptr = free_mem_ptr;\n}\n#else\n#define malloc(a) kmalloc(a, GFP_KERNEL)\n#define free(a) kfree(a)\n#endif\n\n \n\n\nSTATIC const int lbits = 9;           \nSTATIC const int dbits = 6;           \n\n\n \n#define BMAX 16          \n#define N_MAX 288        \n\n\nSTATIC unsigned hufts;          \n\n\nSTATIC int INIT huft_build(\n\tunsigned *b,             \n\tunsigned n,              \n\tunsigned s,              \n\tconst ush *d,            \n\tconst ush *e,            \n\tstruct huft **t,         \n\tint *m                   \n\t)\n \n{\n  unsigned a;                    \n  unsigned f;                    \n  int g;                         \n  int h;                         \n  register unsigned i;           \n  register unsigned j;           \n  register int k;                \n  int l;                         \n  register unsigned *p;          \n  register struct huft *q;       \n  struct huft r;                 \n  register int w;                \n  unsigned *xp;                  \n  int y;                         \n  unsigned z;                    \n  struct {\n    unsigned c[BMAX+1];            \n    struct huft *u[BMAX];          \n    unsigned v[N_MAX];             \n    unsigned x[BMAX+1];            \n  } *stk;\n  unsigned *c, *v, *x;\n  struct huft **u;\n  int ret;\n\nDEBG(\"huft1 \");\n\n  stk = malloc(sizeof(*stk));\n  if (stk == NULL)\n    return 3;\t\t\t \n\n  c = stk->c;\n  v = stk->v;\n  x = stk->x;\n  u = stk->u;\n\n   \n  memzero(stk->c, sizeof(stk->c));\n  p = b;  i = n;\n  do {\n    Tracecv(*p, (stderr, (n-i >= ' ' && n-i <= '~' ? \"%c %d\\n\" : \"0x%x %d\\n\"), \n\t    n-i, *p));\n    c[*p]++;                     \n    p++;                       \n  } while (--i);\n  if (c[0] == n)                 \n  {\n    *t = (struct huft *)NULL;\n    *m = 0;\n    ret = 2;\n    goto out;\n  }\n\nDEBG(\"huft2 \");\n\n   \n  l = *m;\n  for (j = 1; j <= BMAX; j++)\n    if (c[j])\n      break;\n  k = j;                         \n  if ((unsigned)l < j)\n    l = j;\n  for (i = BMAX; i; i--)\n    if (c[i])\n      break;\n  g = i;                         \n  if ((unsigned)l > i)\n    l = i;\n  *m = l;\n\nDEBG(\"huft3 \");\n\n   \n  for (y = 1 << j; j < i; j++, y <<= 1)\n    if ((y -= c[j]) < 0) {\n      ret = 2;                  \n      goto out;\n    }\n  if ((y -= c[i]) < 0) {\n    ret = 2;\n    goto out;\n  }\n  c[i] += y;\n\nDEBG(\"huft4 \");\n\n   \n  x[1] = j = 0;\n  p = c + 1;  xp = x + 2;\n  while (--i) {                  \n    *xp++ = (j += *p++);\n  }\n\nDEBG(\"huft5 \");\n\n   \n  p = b;  i = 0;\n  do {\n    if ((j = *p++) != 0)\n      v[x[j]++] = i;\n  } while (++i < n);\n  n = x[g];                    \n\nDEBG(\"h6 \");\n\n   \n  x[0] = i = 0;                  \n  p = v;                         \n  h = -1;                        \n  w = -l;                        \n  u[0] = (struct huft *)NULL;    \n  q = (struct huft *)NULL;       \n  z = 0;                         \nDEBG(\"h6a \");\n\n   \n  for (; k <= g; k++)\n  {\nDEBG(\"h6b \");\n    a = c[k];\n    while (a--)\n    {\nDEBG(\"h6b1 \");\n       \n       \n      while (k > w + l)\n      {\nDEBG1(\"1 \");\n        h++;\n        w += l;                  \n\n         \n        z = (z = g - w) > (unsigned)l ? l : z;   \n        if ((f = 1 << (j = k - w)) > a + 1)      \n        {                        \nDEBG1(\"2 \");\n          f -= a + 1;            \n          xp = c + k;\n          if (j < z)\n            while (++j < z)        \n            {\n              if ((f <<= 1) <= *++xp)\n                break;             \n              f -= *xp;            \n            }\n        }\nDEBG1(\"3 \");\n        z = 1 << j;              \n\n         \n        if ((q = (struct huft *)malloc((z + 1)*sizeof(struct huft))) ==\n            (struct huft *)NULL)\n        {\n          if (h)\n            huft_free(u[0]);\n          ret = 3;              \n\t  goto out;\n        }\nDEBG1(\"4 \");\n        hufts += z + 1;          \n        *t = q + 1;              \n        *(t = &(q->v.t)) = (struct huft *)NULL;\n        u[h] = ++q;              \n\nDEBG1(\"5 \");\n         \n        if (h)\n        {\n          x[h] = i;              \n          r.b = (uch)l;          \n          r.e = (uch)(16 + j);   \n          r.v.t = q;             \n          j = i >> (w - l);      \n          u[h-1][j] = r;         \n        }\nDEBG1(\"6 \");\n      }\nDEBG(\"h6c \");\n\n       \n      r.b = (uch)(k - w);\n      if (p >= v + n)\n        r.e = 99;                \n      else if (*p < s)\n      {\n        r.e = (uch)(*p < 256 ? 16 : 15);     \n        r.v.n = (ush)(*p);              \n\tp++;                            \n      }\n      else\n      {\n        r.e = (uch)e[*p - s];    \n        r.v.n = d[*p++ - s];\n      }\nDEBG(\"h6d \");\n\n       \n      f = 1 << (k - w);\n      for (j = i >> w; j < z; j += f)\n        q[j] = r;\n\n       \n      for (j = 1 << (k - 1); i & j; j >>= 1)\n        i ^= j;\n      i ^= j;\n\n       \n      while ((i & ((1 << w) - 1)) != x[h])\n      {\n        h--;                     \n        w -= l;\n      }\nDEBG(\"h6e \");\n    }\nDEBG(\"h6f \");\n  }\n\nDEBG(\"huft7 \");\n\n   \n  ret = y != 0 && g != 1;\n\n  out:\n  free(stk);\n  return ret;\n}\n\n\n\nSTATIC int INIT huft_free(\n\tstruct huft *t          \n\t)\n \n{\n  register struct huft *p, *q;\n\n\n   \n  p = t;\n  while (p != (struct huft *)NULL)\n  {\n    q = (--p)->v.t;\n    free((char*)p);\n    p = q;\n  } \n  return 0;\n}\n\n\nSTATIC int INIT inflate_codes(\n\tstruct huft *tl,     \n\tstruct huft *td,     \n\tint bl,              \n\tint bd               \n\t)\n \n{\n  register unsigned e;   \n  unsigned n, d;         \n  unsigned w;            \n  struct huft *t;        \n  unsigned ml, md;       \n  register ulg b;        \n  register unsigned k;   \n\n\n   \n  b = bb;                        \n  k = bk;\n  w = wp;                        \n\n   \n  ml = mask_bits[bl];            \n  md = mask_bits[bd];\n  for (;;)                       \n  {\n    NEEDBITS((unsigned)bl)\n    if ((e = (t = tl + ((unsigned)b & ml))->e) > 16)\n      do {\n        if (e == 99)\n          return 1;\n        DUMPBITS(t->b)\n        e -= 16;\n        NEEDBITS(e)\n      } while ((e = (t = t->v.t + ((unsigned)b & mask_bits[e]))->e) > 16);\n    DUMPBITS(t->b)\n    if (e == 16)                 \n    {\n      slide[w++] = (uch)t->v.n;\n      Tracevv((stderr, \"%c\", slide[w-1]));\n      if (w == WSIZE)\n      {\n        flush_output(w);\n        w = 0;\n      }\n    }\n    else                         \n    {\n       \n      if (e == 15)\n        break;\n\n       \n      NEEDBITS(e)\n      n = t->v.n + ((unsigned)b & mask_bits[e]);\n      DUMPBITS(e);\n\n       \n      NEEDBITS((unsigned)bd)\n      if ((e = (t = td + ((unsigned)b & md))->e) > 16)\n        do {\n          if (e == 99)\n            return 1;\n          DUMPBITS(t->b)\n          e -= 16;\n          NEEDBITS(e)\n        } while ((e = (t = t->v.t + ((unsigned)b & mask_bits[e]))->e) > 16);\n      DUMPBITS(t->b)\n      NEEDBITS(e)\n      d = w - t->v.n - ((unsigned)b & mask_bits[e]);\n      DUMPBITS(e)\n      Tracevv((stderr,\"\\\\[%d,%d]\", w-d, n));\n\n       \n      do {\n        n -= (e = (e = WSIZE - ((d &= WSIZE-1) > w ? d : w)) > n ? n : e);\n#if !defined(NOMEMCPY) && !defined(DEBUG)\n        if (w - d >= e)          \n        {\n          memcpy(slide + w, slide + d, e);\n          w += e;\n          d += e;\n        }\n        else                       \n#endif  \n          do {\n            slide[w++] = slide[d++];\n\t    Tracevv((stderr, \"%c\", slide[w-1]));\n          } while (--e);\n        if (w == WSIZE)\n        {\n          flush_output(w);\n          w = 0;\n        }\n      } while (n);\n    }\n  }\n\n\n   \n  wp = w;                        \n  bb = b;                        \n  bk = k;\n\n   \n  return 0;\n\n underrun:\n  return 4;\t\t\t \n}\n\n\n\nSTATIC int INIT inflate_stored(void)\n \n{\n  unsigned n;            \n  unsigned w;            \n  register ulg b;        \n  register unsigned k;   \n\nDEBG(\"<stor\");\n\n   \n  b = bb;                        \n  k = bk;\n  w = wp;                        \n\n\n   \n  n = k & 7;\n  DUMPBITS(n);\n\n\n   \n  NEEDBITS(16)\n  n = ((unsigned)b & 0xffff);\n  DUMPBITS(16)\n  NEEDBITS(16)\n  if (n != (unsigned)((~b) & 0xffff))\n    return 1;                    \n  DUMPBITS(16)\n\n\n   \n  while (n--)\n  {\n    NEEDBITS(8)\n    slide[w++] = (uch)b;\n    if (w == WSIZE)\n    {\n      flush_output(w);\n      w = 0;\n    }\n    DUMPBITS(8)\n  }\n\n\n   \n  wp = w;                        \n  bb = b;                        \n  bk = k;\n\n  DEBG(\">\");\n  return 0;\n\n underrun:\n  return 4;\t\t\t \n}\n\n\n \nSTATIC int noinline INIT inflate_fixed(void)\n \n{\n  int i;                 \n  struct huft *tl;       \n  struct huft *td;       \n  int bl;                \n  int bd;                \n  unsigned *l;           \n\nDEBG(\"<fix\");\n\n  l = malloc(sizeof(*l) * 288);\n  if (l == NULL)\n    return 3;\t\t\t \n\n   \n  for (i = 0; i < 144; i++)\n    l[i] = 8;\n  for (; i < 256; i++)\n    l[i] = 9;\n  for (; i < 280; i++)\n    l[i] = 7;\n  for (; i < 288; i++)           \n    l[i] = 8;\n  bl = 7;\n  if ((i = huft_build(l, 288, 257, cplens, cplext, &tl, &bl)) != 0) {\n    free(l);\n    return i;\n  }\n\n   \n  for (i = 0; i < 30; i++)       \n    l[i] = 5;\n  bd = 5;\n  if ((i = huft_build(l, 30, 0, cpdist, cpdext, &td, &bd)) > 1)\n  {\n    huft_free(tl);\n    free(l);\n\n    DEBG(\">\");\n    return i;\n  }\n\n\n   \n  if (inflate_codes(tl, td, bl, bd)) {\n    free(l);\n    return 1;\n  }\n\n   \n  free(l);\n  huft_free(tl);\n  huft_free(td);\n  return 0;\n}\n\n\n \nSTATIC int noinline INIT inflate_dynamic(void)\n \n{\n  int i;                 \n  unsigned j;\n  unsigned l;            \n  unsigned m;            \n  unsigned n;            \n  struct huft *tl;       \n  struct huft *td;       \n  int bl;                \n  int bd;                \n  unsigned nb;           \n  unsigned nl;           \n  unsigned nd;           \n  unsigned *ll;          \n  register ulg b;        \n  register unsigned k;   \n  int ret;\n\nDEBG(\"<dyn\");\n\n#ifdef PKZIP_BUG_WORKAROUND\n  ll = malloc(sizeof(*ll) * (288+32));   \n#else\n  ll = malloc(sizeof(*ll) * (286+30));   \n#endif\n\n  if (ll == NULL)\n    return 1;\n\n   \n  b = bb;\n  k = bk;\n\n\n   \n  NEEDBITS(5)\n  nl = 257 + ((unsigned)b & 0x1f);       \n  DUMPBITS(5)\n  NEEDBITS(5)\n  nd = 1 + ((unsigned)b & 0x1f);         \n  DUMPBITS(5)\n  NEEDBITS(4)\n  nb = 4 + ((unsigned)b & 0xf);          \n  DUMPBITS(4)\n#ifdef PKZIP_BUG_WORKAROUND\n  if (nl > 288 || nd > 32)\n#else\n  if (nl > 286 || nd > 30)\n#endif\n  {\n    ret = 1;              \n    goto out;\n  }\n\nDEBG(\"dyn1 \");\n\n   \n  for (j = 0; j < nb; j++)\n  {\n    NEEDBITS(3)\n    ll[border[j]] = (unsigned)b & 7;\n    DUMPBITS(3)\n  }\n  for (; j < 19; j++)\n    ll[border[j]] = 0;\n\nDEBG(\"dyn2 \");\n\n   \n  bl = 7;\n  if ((i = huft_build(ll, 19, 19, NULL, NULL, &tl, &bl)) != 0)\n  {\n    if (i == 1)\n      huft_free(tl);\n    ret = i;                    \n    goto out;\n  }\n\nDEBG(\"dyn3 \");\n\n   \n  n = nl + nd;\n  m = mask_bits[bl];\n  i = l = 0;\n  while ((unsigned)i < n)\n  {\n    NEEDBITS((unsigned)bl)\n    j = (td = tl + ((unsigned)b & m))->b;\n    DUMPBITS(j)\n    j = td->v.n;\n    if (j < 16)                  \n      ll[i++] = l = j;           \n    else if (j == 16)            \n    {\n      NEEDBITS(2)\n      j = 3 + ((unsigned)b & 3);\n      DUMPBITS(2)\n      if ((unsigned)i + j > n) {\n        ret = 1;\n\tgoto out;\n      }\n      while (j--)\n        ll[i++] = l;\n    }\n    else if (j == 17)            \n    {\n      NEEDBITS(3)\n      j = 3 + ((unsigned)b & 7);\n      DUMPBITS(3)\n      if ((unsigned)i + j > n) {\n        ret = 1;\n\tgoto out;\n      }\n      while (j--)\n        ll[i++] = 0;\n      l = 0;\n    }\n    else                         \n    {\n      NEEDBITS(7)\n      j = 11 + ((unsigned)b & 0x7f);\n      DUMPBITS(7)\n      if ((unsigned)i + j > n) {\n        ret = 1;\n\tgoto out;\n      }\n      while (j--)\n        ll[i++] = 0;\n      l = 0;\n    }\n  }\n\nDEBG(\"dyn4 \");\n\n   \n  huft_free(tl);\n\nDEBG(\"dyn5 \");\n\n   \n  bb = b;\n  bk = k;\n\nDEBG(\"dyn5a \");\n\n   \n  bl = lbits;\n  if ((i = huft_build(ll, nl, 257, cplens, cplext, &tl, &bl)) != 0)\n  {\nDEBG(\"dyn5b \");\n    if (i == 1) {\n      error(\"incomplete literal tree\");\n      huft_free(tl);\n    }\n    ret = i;                    \n    goto out;\n  }\nDEBG(\"dyn5c \");\n  bd = dbits;\n  if ((i = huft_build(ll + nl, nd, 0, cpdist, cpdext, &td, &bd)) != 0)\n  {\nDEBG(\"dyn5d \");\n    if (i == 1) {\n      error(\"incomplete distance tree\");\n#ifdef PKZIP_BUG_WORKAROUND\n      i = 0;\n    }\n#else\n      huft_free(td);\n    }\n    huft_free(tl);\n    ret = i;                    \n    goto out;\n#endif\n  }\n\nDEBG(\"dyn6 \");\n\n   \n  if (inflate_codes(tl, td, bl, bd)) {\n    ret = 1;\n    goto out;\n  }\n\nDEBG(\"dyn7 \");\n\n   \n  huft_free(tl);\n  huft_free(td);\n\n  DEBG(\">\");\n  ret = 0;\nout:\n  free(ll);\n  return ret;\n\nunderrun:\n  ret = 4;\t\t\t \n  goto out;\n}\n\n\n\nSTATIC int INIT inflate_block(\n\tint *e                   \n\t)\n \n{\n  unsigned t;            \n  register ulg b;        \n  register unsigned k;   \n\n  DEBG(\"<blk\");\n\n   \n  b = bb;\n  k = bk;\n\n\n   \n  NEEDBITS(1)\n  *e = (int)b & 1;\n  DUMPBITS(1)\n\n\n   \n  NEEDBITS(2)\n  t = (unsigned)b & 3;\n  DUMPBITS(2)\n\n\n   \n  bb = b;\n  bk = k;\n\n   \n  if (t == 2)\n    return inflate_dynamic();\n  if (t == 0)\n    return inflate_stored();\n  if (t == 1)\n    return inflate_fixed();\n\n  DEBG(\">\");\n\n   \n  return 2;\n\n underrun:\n  return 4;\t\t\t \n}\n\n\n\nSTATIC int INIT inflate(void)\n \n{\n  int e;                 \n  int r;                 \n  unsigned h;            \n\n   \n  wp = 0;\n  bk = 0;\n  bb = 0;\n\n\n   \n  h = 0;\n  do {\n    hufts = 0;\n#ifdef ARCH_HAS_DECOMP_WDOG\n    arch_decomp_wdog();\n#endif\n    r = inflate_block(&e);\n    if (r)\n\t    return r;\n    if (hufts > h)\n      h = hufts;\n  } while (!e);\n\n   \n  while (bk >= 8) {\n    bk -= 8;\n    inptr--;\n  }\n\n   \n  flush_output(wp);\n\n\n   \n#ifdef DEBUG\n  fprintf(stderr, \"<%u> \", h);\n#endif  \n  return 0;\n}\n\n \n\nstatic ulg crc_32_tab[256];\nstatic ulg crc;\t\t \n#define CRC_VALUE (crc ^ 0xffffffffUL)\n\n \n\nstatic void INIT\nmakecrc(void)\n{\n \n\n  unsigned long c;       \n  unsigned long e;       \n  int i;                 \n  int k;                 \n\n   \n  static const int p[] = {0,1,2,4,5,7,8,10,11,12,16,22,23,26};\n\n   \n  e = 0;\n  for (i = 0; i < sizeof(p)/sizeof(int); i++)\n    e |= 1L << (31 - p[i]);\n\n  crc_32_tab[0] = 0;\n\n  for (i = 1; i < 256; i++)\n  {\n    c = 0;\n    for (k = i | 256; k != 1; k >>= 1)\n    {\n      c = c & 1 ? (c >> 1) ^ e : c >> 1;\n      if (k & 1)\n        c ^= e;\n    }\n    crc_32_tab[i] = c;\n  }\n\n   \n  crc = (ulg)0xffffffffUL;  \n}\n\n \n#define ASCII_FLAG   0x01  \n#define CONTINUATION 0x02  \n#define EXTRA_FIELD  0x04  \n#define ORIG_NAME    0x08  \n#define COMMENT      0x10  \n#define ENCRYPTED    0x20  \n#define RESERVED     0xC0  \n\n \nstatic int INIT gunzip(void)\n{\n    uch flags;\n    unsigned char magic[2];  \n    char method;\n    ulg orig_crc = 0;        \n    ulg orig_len = 0;        \n    int res;\n\n    magic[0] = NEXTBYTE();\n    magic[1] = NEXTBYTE();\n    method   = NEXTBYTE();\n\n    if (magic[0] != 037 ||\n\t((magic[1] != 0213) && (magic[1] != 0236))) {\n\t    error(\"bad gzip magic numbers\");\n\t    return -1;\n    }\n\n     \n    if (method != 8)  {\n\t    error(\"internal error, invalid method\");\n\t    return -1;\n    }\n\n    flags  = (uch)get_byte();\n    if ((flags & ENCRYPTED) != 0) {\n\t    error(\"Input is encrypted\");\n\t    return -1;\n    }\n    if ((flags & CONTINUATION) != 0) {\n\t    error(\"Multi part input\");\n\t    return -1;\n    }\n    if ((flags & RESERVED) != 0) {\n\t    error(\"Input has invalid flags\");\n\t    return -1;\n    }\n    NEXTBYTE();\t \n    NEXTBYTE();\n    NEXTBYTE();\n    NEXTBYTE();\n\n    (void)NEXTBYTE();   \n    (void)NEXTBYTE();   \n\n    if ((flags & EXTRA_FIELD) != 0) {\n\t    unsigned len = (unsigned)NEXTBYTE();\n\t    len |= ((unsigned)NEXTBYTE())<<8;\n\t    while (len--) (void)NEXTBYTE();\n    }\n\n     \n    if ((flags & ORIG_NAME) != 0) {\n\t     \n\t    while (NEXTBYTE() != 0)   ;\n    } \n\n     \n    if ((flags & COMMENT) != 0) {\n\t    while (NEXTBYTE() != 0)   ;\n    }\n\n     \n    if ((res = inflate())) {\n\t    switch (res) {\n\t    case 0:\n\t\t    break;\n\t    case 1:\n\t\t    error(\"invalid compressed format (err=1)\");\n\t\t    break;\n\t    case 2:\n\t\t    error(\"invalid compressed format (err=2)\");\n\t\t    break;\n\t    case 3:\n\t\t    error(\"out of memory\");\n\t\t    break;\n\t    case 4:\n\t\t    error(\"out of input data\");\n\t\t    break;\n\t    default:\n\t\t    error(\"invalid compressed format (other)\");\n\t    }\n\t    return -1;\n    }\n\t    \n     \n     \n    orig_crc = (ulg) NEXTBYTE();\n    orig_crc |= (ulg) NEXTBYTE() << 8;\n    orig_crc |= (ulg) NEXTBYTE() << 16;\n    orig_crc |= (ulg) NEXTBYTE() << 24;\n    \n    orig_len = (ulg) NEXTBYTE();\n    orig_len |= (ulg) NEXTBYTE() << 8;\n    orig_len |= (ulg) NEXTBYTE() << 16;\n    orig_len |= (ulg) NEXTBYTE() << 24;\n    \n     \n    if (orig_crc != CRC_VALUE) {\n\t    error(\"crc error\");\n\t    return -1;\n    }\n    if (orig_len != bytes_out) {\n\t    error(\"length error\");\n\t    return -1;\n    }\n    return 0;\n\n underrun:\t\t\t \n    error(\"out of input data\");\n    return -1;\n}\n\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}