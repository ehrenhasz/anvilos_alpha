{
  "module_name": "test_min_heap.c",
  "hash_id": "7d68f9d7de61ed94684a1c47b6973fef0dd8be0bf8aa10070e0633f02beaec4e",
  "original_prompt": "Ingested from linux-6.6.14/lib/test_min_heap.c",
  "human_readable_source": "\n#define pr_fmt(fmt) \"min_heap_test: \" fmt\n\n \n\n#include <linux/log2.h>\n#include <linux/min_heap.h>\n#include <linux/module.h>\n#include <linux/printk.h>\n#include <linux/random.h>\n\nstatic __init bool less_than(const void *lhs, const void *rhs)\n{\n\treturn *(int *)lhs < *(int *)rhs;\n}\n\nstatic __init bool greater_than(const void *lhs, const void *rhs)\n{\n\treturn *(int *)lhs > *(int *)rhs;\n}\n\nstatic __init void swap_ints(void *lhs, void *rhs)\n{\n\tint temp = *(int *)lhs;\n\n\t*(int *)lhs = *(int *)rhs;\n\t*(int *)rhs = temp;\n}\n\nstatic __init int pop_verify_heap(bool min_heap,\n\t\t\t\tstruct min_heap *heap,\n\t\t\t\tconst struct min_heap_callbacks *funcs)\n{\n\tint *values = heap->data;\n\tint err = 0;\n\tint last;\n\n\tlast = values[0];\n\tmin_heap_pop(heap, funcs);\n\twhile (heap->nr > 0) {\n\t\tif (min_heap) {\n\t\t\tif (last > values[0]) {\n\t\t\t\tpr_err(\"error: expected %d <= %d\\n\", last,\n\t\t\t\t\tvalues[0]);\n\t\t\t\terr++;\n\t\t\t}\n\t\t} else {\n\t\t\tif (last < values[0]) {\n\t\t\t\tpr_err(\"error: expected %d >= %d\\n\", last,\n\t\t\t\t\tvalues[0]);\n\t\t\t\terr++;\n\t\t\t}\n\t\t}\n\t\tlast = values[0];\n\t\tmin_heap_pop(heap, funcs);\n\t}\n\treturn err;\n}\n\nstatic __init int test_heapify_all(bool min_heap)\n{\n\tint values[] = { 3, 1, 2, 4, 0x8000000, 0x7FFFFFF, 0,\n\t\t\t -3, -1, -2, -4, 0x8000000, 0x7FFFFFF };\n\tstruct min_heap heap = {\n\t\t.data = values,\n\t\t.nr = ARRAY_SIZE(values),\n\t\t.size =  ARRAY_SIZE(values),\n\t};\n\tstruct min_heap_callbacks funcs = {\n\t\t.elem_size = sizeof(int),\n\t\t.less = min_heap ? less_than : greater_than,\n\t\t.swp = swap_ints,\n\t};\n\tint i, err;\n\n\t \n\tmin_heapify_all(&heap, &funcs);\n\terr = pop_verify_heap(min_heap, &heap, &funcs);\n\n\n\t \n\theap.nr = ARRAY_SIZE(values);\n\tfor (i = 0; i < heap.nr; i++)\n\t\tvalues[i] = get_random_u32();\n\n\tmin_heapify_all(&heap, &funcs);\n\terr += pop_verify_heap(min_heap, &heap, &funcs);\n\n\treturn err;\n}\n\nstatic __init int test_heap_push(bool min_heap)\n{\n\tconst int data[] = { 3, 1, 2, 4, 0x80000000, 0x7FFFFFFF, 0,\n\t\t\t     -3, -1, -2, -4, 0x80000000, 0x7FFFFFFF };\n\tint values[ARRAY_SIZE(data)];\n\tstruct min_heap heap = {\n\t\t.data = values,\n\t\t.nr = 0,\n\t\t.size =  ARRAY_SIZE(values),\n\t};\n\tstruct min_heap_callbacks funcs = {\n\t\t.elem_size = sizeof(int),\n\t\t.less = min_heap ? less_than : greater_than,\n\t\t.swp = swap_ints,\n\t};\n\tint i, temp, err;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(data); i++)\n\t\tmin_heap_push(&heap, &data[i], &funcs);\n\n\terr = pop_verify_heap(min_heap, &heap, &funcs);\n\n\t \n\twhile (heap.nr < heap.size) {\n\t\ttemp = get_random_u32();\n\t\tmin_heap_push(&heap, &temp, &funcs);\n\t}\n\terr += pop_verify_heap(min_heap, &heap, &funcs);\n\n\treturn err;\n}\n\nstatic __init int test_heap_pop_push(bool min_heap)\n{\n\tconst int data[] = { 3, 1, 2, 4, 0x80000000, 0x7FFFFFFF, 0,\n\t\t\t     -3, -1, -2, -4, 0x80000000, 0x7FFFFFFF };\n\tint values[ARRAY_SIZE(data)];\n\tstruct min_heap heap = {\n\t\t.data = values,\n\t\t.nr = 0,\n\t\t.size =  ARRAY_SIZE(values),\n\t};\n\tstruct min_heap_callbacks funcs = {\n\t\t.elem_size = sizeof(int),\n\t\t.less = min_heap ? less_than : greater_than,\n\t\t.swp = swap_ints,\n\t};\n\tint i, temp, err;\n\n\t \n\ttemp = min_heap ? 0x80000000 : 0x7FFFFFFF;\n\tfor (i = 0; i < ARRAY_SIZE(data); i++)\n\t\tmin_heap_push(&heap, &temp, &funcs);\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(data); i++)\n\t\tmin_heap_pop_push(&heap, &data[i], &funcs);\n\n\terr = pop_verify_heap(min_heap, &heap, &funcs);\n\n\theap.nr = 0;\n\tfor (i = 0; i < ARRAY_SIZE(data); i++)\n\t\tmin_heap_push(&heap, &temp, &funcs);\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(data); i++) {\n\t\ttemp = get_random_u32();\n\t\tmin_heap_pop_push(&heap, &temp, &funcs);\n\t}\n\terr += pop_verify_heap(min_heap, &heap, &funcs);\n\n\treturn err;\n}\n\nstatic int __init test_min_heap_init(void)\n{\n\tint err = 0;\n\n\terr += test_heapify_all(true);\n\terr += test_heapify_all(false);\n\terr += test_heap_push(true);\n\terr += test_heap_push(false);\n\terr += test_heap_pop_push(true);\n\terr += test_heap_pop_push(false);\n\tif (err) {\n\t\tpr_err(\"test failed with %d errors\\n\", err);\n\t\treturn -EINVAL;\n\t}\n\tpr_info(\"test passed\\n\");\n\treturn 0;\n}\nmodule_init(test_min_heap_init);\n\nstatic void __exit test_min_heap_exit(void)\n{\n\t \n}\nmodule_exit(test_min_heap_exit);\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}