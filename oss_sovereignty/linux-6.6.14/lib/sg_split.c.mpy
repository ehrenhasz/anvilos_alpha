{
  "module_name": "sg_split.c",
  "hash_id": "0e4eaaa9cf273b0a4847cc90c733cbad91c284b83faaed6a6e59f2cfaabc2ecc",
  "original_prompt": "Ingested from linux-6.6.14/lib/sg_split.c",
  "human_readable_source": "\n \n\n#include <linux/scatterlist.h>\n#include <linux/slab.h>\n\nstruct sg_splitter {\n\tstruct scatterlist *in_sg0;\n\tint nents;\n\toff_t skip_sg0;\n\tunsigned int length_last_sg;\n\n\tstruct scatterlist *out_sg;\n};\n\nstatic int sg_calculate_split(struct scatterlist *in, int nents, int nb_splits,\n\t\t\t      off_t skip, const size_t *sizes,\n\t\t\t      struct sg_splitter *splitters, bool mapped)\n{\n\tint i;\n\tunsigned int sglen;\n\tsize_t size = sizes[0], len;\n\tstruct sg_splitter *curr = splitters;\n\tstruct scatterlist *sg;\n\n\tfor (i = 0; i < nb_splits; i++) {\n\t\tsplitters[i].in_sg0 = NULL;\n\t\tsplitters[i].nents = 0;\n\t}\n\n\tfor_each_sg(in, sg, nents, i) {\n\t\tsglen = mapped ? sg_dma_len(sg) : sg->length;\n\t\tif (skip > sglen) {\n\t\t\tskip -= sglen;\n\t\t\tcontinue;\n\t\t}\n\n\t\tlen = min_t(size_t, size, sglen - skip);\n\t\tif (!curr->in_sg0) {\n\t\t\tcurr->in_sg0 = sg;\n\t\t\tcurr->skip_sg0 = skip;\n\t\t}\n\t\tsize -= len;\n\t\tcurr->nents++;\n\t\tcurr->length_last_sg = len;\n\n\t\twhile (!size && (skip + len < sglen) && (--nb_splits > 0)) {\n\t\t\tcurr++;\n\t\t\tsize = *(++sizes);\n\t\t\tskip += len;\n\t\t\tlen = min_t(size_t, size, sglen - skip);\n\n\t\t\tcurr->in_sg0 = sg;\n\t\t\tcurr->skip_sg0 = skip;\n\t\t\tcurr->nents = 1;\n\t\t\tcurr->length_last_sg = len;\n\t\t\tsize -= len;\n\t\t}\n\t\tskip = 0;\n\n\t\tif (!size && --nb_splits > 0) {\n\t\t\tcurr++;\n\t\t\tsize = *(++sizes);\n\t\t}\n\n\t\tif (!nb_splits)\n\t\t\tbreak;\n\t}\n\n\treturn (size || !splitters[0].in_sg0) ? -EINVAL : 0;\n}\n\nstatic void sg_split_phys(struct sg_splitter *splitters, const int nb_splits)\n{\n\tint i, j;\n\tstruct scatterlist *in_sg, *out_sg;\n\tstruct sg_splitter *split;\n\n\tfor (i = 0, split = splitters; i < nb_splits; i++, split++) {\n\t\tin_sg = split->in_sg0;\n\t\tout_sg = split->out_sg;\n\t\tfor (j = 0; j < split->nents; j++, out_sg++) {\n\t\t\t*out_sg = *in_sg;\n\t\t\tif (!j) {\n\t\t\t\tout_sg->offset += split->skip_sg0;\n\t\t\t\tout_sg->length -= split->skip_sg0;\n\t\t\t} else {\n\t\t\t\tout_sg->offset = 0;\n\t\t\t}\n\t\t\tsg_dma_address(out_sg) = 0;\n\t\t\tsg_dma_len(out_sg) = 0;\n\t\t\tin_sg = sg_next(in_sg);\n\t\t}\n\t\tout_sg[-1].length = split->length_last_sg;\n\t\tsg_mark_end(out_sg - 1);\n\t}\n}\n\nstatic void sg_split_mapped(struct sg_splitter *splitters, const int nb_splits)\n{\n\tint i, j;\n\tstruct scatterlist *in_sg, *out_sg;\n\tstruct sg_splitter *split;\n\n\tfor (i = 0, split = splitters; i < nb_splits; i++, split++) {\n\t\tin_sg = split->in_sg0;\n\t\tout_sg = split->out_sg;\n\t\tfor (j = 0; j < split->nents; j++, out_sg++) {\n\t\t\tsg_dma_address(out_sg) = sg_dma_address(in_sg);\n\t\t\tsg_dma_len(out_sg) = sg_dma_len(in_sg);\n\t\t\tif (!j) {\n\t\t\t\tsg_dma_address(out_sg) += split->skip_sg0;\n\t\t\t\tsg_dma_len(out_sg) -= split->skip_sg0;\n\t\t\t}\n\t\t\tin_sg = sg_next(in_sg);\n\t\t}\n\t\tsg_dma_len(--out_sg) = split->length_last_sg;\n\t}\n}\n\n \nint sg_split(struct scatterlist *in, const int in_mapped_nents,\n\t     const off_t skip, const int nb_splits,\n\t     const size_t *split_sizes,\n\t     struct scatterlist **out, int *out_mapped_nents,\n\t     gfp_t gfp_mask)\n{\n\tint i, ret;\n\tstruct sg_splitter *splitters;\n\n\tsplitters = kcalloc(nb_splits, sizeof(*splitters), gfp_mask);\n\tif (!splitters)\n\t\treturn -ENOMEM;\n\n\tret = sg_calculate_split(in, sg_nents(in), nb_splits, skip, split_sizes,\n\t\t\t   splitters, false);\n\tif (ret < 0)\n\t\tgoto err;\n\n\tret = -ENOMEM;\n\tfor (i = 0; i < nb_splits; i++) {\n\t\tsplitters[i].out_sg = kmalloc_array(splitters[i].nents,\n\t\t\t\t\t\t    sizeof(struct scatterlist),\n\t\t\t\t\t\t    gfp_mask);\n\t\tif (!splitters[i].out_sg)\n\t\t\tgoto err;\n\t}\n\n\t \n\tsg_split_phys(splitters, nb_splits);\n\tif (in_mapped_nents) {\n\t\tret = sg_calculate_split(in, in_mapped_nents, nb_splits, skip,\n\t\t\t\t\t split_sizes, splitters, true);\n\t\tif (ret < 0)\n\t\t\tgoto err;\n\t\tsg_split_mapped(splitters, nb_splits);\n\t}\n\n\tfor (i = 0; i < nb_splits; i++) {\n\t\tout[i] = splitters[i].out_sg;\n\t\tif (out_mapped_nents)\n\t\t\tout_mapped_nents[i] = splitters[i].nents;\n\t}\n\n\tkfree(splitters);\n\treturn 0;\n\nerr:\n\tfor (i = 0; i < nb_splits; i++)\n\t\tkfree(splitters[i].out_sg);\n\tkfree(splitters);\n\treturn ret;\n}\nEXPORT_SYMBOL(sg_split);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}