{
  "module_name": "hexdump.c",
  "hash_id": "c9fc77b07db9c8f6dfe14d23cf06d580772545bb44ab37fbf2ccb48363a235fa",
  "original_prompt": "Ingested from linux-6.6.14/lib/hexdump.c",
  "human_readable_source": "\n \n\n#include <linux/types.h>\n#include <linux/ctype.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/minmax.h>\n#include <linux/export.h>\n#include <asm/unaligned.h>\n\nconst char hex_asc[] = \"0123456789abcdef\";\nEXPORT_SYMBOL(hex_asc);\nconst char hex_asc_upper[] = \"0123456789ABCDEF\";\nEXPORT_SYMBOL(hex_asc_upper);\n\n \nint hex_to_bin(unsigned char ch)\n{\n\tunsigned char cu = ch & 0xdf;\n\treturn -1 +\n\t\t((ch - '0' +  1) & (unsigned)((ch - '9' - 1) & ('0' - 1 - ch)) >> 8) +\n\t\t((cu - 'A' + 11) & (unsigned)((cu - 'F' - 1) & ('A' - 1 - cu)) >> 8);\n}\nEXPORT_SYMBOL(hex_to_bin);\n\n \nint hex2bin(u8 *dst, const char *src, size_t count)\n{\n\twhile (count--) {\n\t\tint hi, lo;\n\n\t\thi = hex_to_bin(*src++);\n\t\tif (unlikely(hi < 0))\n\t\t\treturn -EINVAL;\n\t\tlo = hex_to_bin(*src++);\n\t\tif (unlikely(lo < 0))\n\t\t\treturn -EINVAL;\n\n\t\t*dst++ = (hi << 4) | lo;\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL(hex2bin);\n\n \nchar *bin2hex(char *dst, const void *src, size_t count)\n{\n\tconst unsigned char *_src = src;\n\n\twhile (count--)\n\t\tdst = hex_byte_pack(dst, *_src++);\n\treturn dst;\n}\nEXPORT_SYMBOL(bin2hex);\n\n \nint hex_dump_to_buffer(const void *buf, size_t len, int rowsize, int groupsize,\n\t\t       char *linebuf, size_t linebuflen, bool ascii)\n{\n\tconst u8 *ptr = buf;\n\tint ngroups;\n\tu8 ch;\n\tint j, lx = 0;\n\tint ascii_column;\n\tint ret;\n\n\tif (rowsize != 16 && rowsize != 32)\n\t\trowsize = 16;\n\n\tif (len > rowsize)\t\t \n\t\tlen = rowsize;\n\tif (!is_power_of_2(groupsize) || groupsize > 8)\n\t\tgroupsize = 1;\n\tif ((len % groupsize) != 0)\t \n\t\tgroupsize = 1;\n\n\tngroups = len / groupsize;\n\tascii_column = rowsize * 2 + rowsize / groupsize + 1;\n\n\tif (!linebuflen)\n\t\tgoto overflow1;\n\n\tif (!len)\n\t\tgoto nil;\n\n\tif (groupsize == 8) {\n\t\tconst u64 *ptr8 = buf;\n\n\t\tfor (j = 0; j < ngroups; j++) {\n\t\t\tret = snprintf(linebuf + lx, linebuflen - lx,\n\t\t\t\t       \"%s%16.16llx\", j ? \" \" : \"\",\n\t\t\t\t       get_unaligned(ptr8 + j));\n\t\t\tif (ret >= linebuflen - lx)\n\t\t\t\tgoto overflow1;\n\t\t\tlx += ret;\n\t\t}\n\t} else if (groupsize == 4) {\n\t\tconst u32 *ptr4 = buf;\n\n\t\tfor (j = 0; j < ngroups; j++) {\n\t\t\tret = snprintf(linebuf + lx, linebuflen - lx,\n\t\t\t\t       \"%s%8.8x\", j ? \" \" : \"\",\n\t\t\t\t       get_unaligned(ptr4 + j));\n\t\t\tif (ret >= linebuflen - lx)\n\t\t\t\tgoto overflow1;\n\t\t\tlx += ret;\n\t\t}\n\t} else if (groupsize == 2) {\n\t\tconst u16 *ptr2 = buf;\n\n\t\tfor (j = 0; j < ngroups; j++) {\n\t\t\tret = snprintf(linebuf + lx, linebuflen - lx,\n\t\t\t\t       \"%s%4.4x\", j ? \" \" : \"\",\n\t\t\t\t       get_unaligned(ptr2 + j));\n\t\t\tif (ret >= linebuflen - lx)\n\t\t\t\tgoto overflow1;\n\t\t\tlx += ret;\n\t\t}\n\t} else {\n\t\tfor (j = 0; j < len; j++) {\n\t\t\tif (linebuflen < lx + 2)\n\t\t\t\tgoto overflow2;\n\t\t\tch = ptr[j];\n\t\t\tlinebuf[lx++] = hex_asc_hi(ch);\n\t\t\tif (linebuflen < lx + 2)\n\t\t\t\tgoto overflow2;\n\t\t\tlinebuf[lx++] = hex_asc_lo(ch);\n\t\t\tif (linebuflen < lx + 2)\n\t\t\t\tgoto overflow2;\n\t\t\tlinebuf[lx++] = ' ';\n\t\t}\n\t\tif (j)\n\t\t\tlx--;\n\t}\n\tif (!ascii)\n\t\tgoto nil;\n\n\twhile (lx < ascii_column) {\n\t\tif (linebuflen < lx + 2)\n\t\t\tgoto overflow2;\n\t\tlinebuf[lx++] = ' ';\n\t}\n\tfor (j = 0; j < len; j++) {\n\t\tif (linebuflen < lx + 2)\n\t\t\tgoto overflow2;\n\t\tch = ptr[j];\n\t\tlinebuf[lx++] = (isascii(ch) && isprint(ch)) ? ch : '.';\n\t}\nnil:\n\tlinebuf[lx] = '\\0';\n\treturn lx;\noverflow2:\n\tlinebuf[lx++] = '\\0';\noverflow1:\n\treturn ascii ? ascii_column + len : (groupsize * 2 + 1) * ngroups - 1;\n}\nEXPORT_SYMBOL(hex_dump_to_buffer);\n\n#ifdef CONFIG_PRINTK\n \nvoid print_hex_dump(const char *level, const char *prefix_str, int prefix_type,\n\t\t    int rowsize, int groupsize,\n\t\t    const void *buf, size_t len, bool ascii)\n{\n\tconst u8 *ptr = buf;\n\tint i, linelen, remaining = len;\n\tunsigned char linebuf[32 * 3 + 2 + 32 + 1];\n\n\tif (rowsize != 16 && rowsize != 32)\n\t\trowsize = 16;\n\n\tfor (i = 0; i < len; i += rowsize) {\n\t\tlinelen = min(remaining, rowsize);\n\t\tremaining -= rowsize;\n\n\t\thex_dump_to_buffer(ptr + i, linelen, rowsize, groupsize,\n\t\t\t\t   linebuf, sizeof(linebuf), ascii);\n\n\t\tswitch (prefix_type) {\n\t\tcase DUMP_PREFIX_ADDRESS:\n\t\t\tprintk(\"%s%s%p: %s\\n\",\n\t\t\t       level, prefix_str, ptr + i, linebuf);\n\t\t\tbreak;\n\t\tcase DUMP_PREFIX_OFFSET:\n\t\t\tprintk(\"%s%s%.8x: %s\\n\", level, prefix_str, i, linebuf);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintk(\"%s%s%s\\n\", level, prefix_str, linebuf);\n\t\t\tbreak;\n\t\t}\n\t}\n}\nEXPORT_SYMBOL(print_hex_dump);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}