{
  "module_name": "hashtable_test.c",
  "hash_id": "6d8dc3cb0b1aa65d343c22e23d9e6e880747b819ee3cd7afa8d157d363010a1a",
  "original_prompt": "Ingested from linux-6.6.14/lib/hashtable_test.c",
  "human_readable_source": "\n \n#include <kunit/test.h>\n\n#include <linux/hashtable.h>\n\nstruct hashtable_test_entry {\n\tint key;\n\tint data;\n\tstruct hlist_node node;\n\tint visited;\n};\n\nstatic void hashtable_test_hash_init(struct kunit *test)\n{\n\t \n\tDEFINE_HASHTABLE(hash1, 2);\n\tDECLARE_HASHTABLE(hash2, 3);\n\n\t \n\thash_init(hash2);\n\n\tKUNIT_EXPECT_TRUE(test, hash_empty(hash1));\n\tKUNIT_EXPECT_TRUE(test, hash_empty(hash2));\n}\n\nstatic void hashtable_test_hash_empty(struct kunit *test)\n{\n\tstruct hashtable_test_entry a;\n\tDEFINE_HASHTABLE(hash, 1);\n\n\tKUNIT_EXPECT_TRUE(test, hash_empty(hash));\n\n\ta.key = 1;\n\ta.data = 13;\n\thash_add(hash, &a.node, a.key);\n\n\t \n\tKUNIT_EXPECT_FALSE(test, hash_empty(hash));\n}\n\nstatic void hashtable_test_hash_hashed(struct kunit *test)\n{\n\tstruct hashtable_test_entry a, b;\n\tDEFINE_HASHTABLE(hash, 4);\n\n\ta.key = 1;\n\ta.data = 13;\n\thash_add(hash, &a.node, a.key);\n\tb.key = 1;\n\tb.data = 2;\n\thash_add(hash, &b.node, b.key);\n\n\tKUNIT_EXPECT_TRUE(test, hash_hashed(&a.node));\n\tKUNIT_EXPECT_TRUE(test, hash_hashed(&b.node));\n}\n\nstatic void hashtable_test_hash_add(struct kunit *test)\n{\n\tstruct hashtable_test_entry a, b, *x;\n\tint bkt;\n\tDEFINE_HASHTABLE(hash, 3);\n\n\ta.key = 1;\n\ta.data = 13;\n\ta.visited = 0;\n\thash_add(hash, &a.node, a.key);\n\tb.key = 2;\n\tb.data = 10;\n\tb.visited = 0;\n\thash_add(hash, &b.node, b.key);\n\n\thash_for_each(hash, bkt, x, node) {\n\t\tx->visited++;\n\t\tif (x->key == a.key)\n\t\t\tKUNIT_EXPECT_EQ(test, x->data, 13);\n\t\telse if (x->key == b.key)\n\t\t\tKUNIT_EXPECT_EQ(test, x->data, 10);\n\t\telse\n\t\t\tKUNIT_FAIL(test, \"Unexpected key in hashtable.\");\n\t}\n\n\t \n\tKUNIT_EXPECT_EQ(test, a.visited, 1);\n\tKUNIT_EXPECT_EQ(test, b.visited, 1);\n}\n\nstatic void hashtable_test_hash_del(struct kunit *test)\n{\n\tstruct hashtable_test_entry a, b, *x;\n\tDEFINE_HASHTABLE(hash, 6);\n\n\ta.key = 1;\n\ta.data = 13;\n\thash_add(hash, &a.node, a.key);\n\tb.key = 2;\n\tb.data = 10;\n\tb.visited = 0;\n\thash_add(hash, &b.node, b.key);\n\n\thash_del(&b.node);\n\thash_for_each_possible(hash, x, node, b.key) {\n\t\tx->visited++;\n\t\tKUNIT_EXPECT_NE(test, x->key, b.key);\n\t}\n\n\t \n\tKUNIT_EXPECT_EQ(test, b.visited, 0);\n\n\thash_del(&a.node);\n\n\t \n\tKUNIT_EXPECT_TRUE(test, hash_empty(hash));\n}\n\nstatic void hashtable_test_hash_for_each(struct kunit *test)\n{\n\tstruct hashtable_test_entry entries[3];\n\tstruct hashtable_test_entry *x;\n\tint bkt, i, j, count;\n\tDEFINE_HASHTABLE(hash, 3);\n\n\t \n\tfor (i = 0; i < 3; i++) {\n\t\tentries[i].key = i;\n\t\tentries[i].data = i + 10;\n\t\tentries[i].visited = 0;\n\t\thash_add(hash, &entries[i].node, entries[i].key);\n\t}\n\n\tcount = 0;\n\thash_for_each(hash, bkt, x, node) {\n\t\tx->visited += 1;\n\t\tKUNIT_ASSERT_GE_MSG(test, x->key, 0, \"Unexpected key in hashtable.\");\n\t\tKUNIT_ASSERT_LT_MSG(test, x->key, 3, \"Unexpected key in hashtable.\");\n\t\tcount++;\n\t}\n\n\t \n\tKUNIT_EXPECT_EQ(test, count, 3);\n\tfor (j = 0; j < 3; j++)\n\t\tKUNIT_EXPECT_EQ(test, entries[j].visited, 1);\n}\n\nstatic void hashtable_test_hash_for_each_safe(struct kunit *test)\n{\n\tstruct hashtable_test_entry entries[3];\n\tstruct hashtable_test_entry *x;\n\tstruct hlist_node *tmp;\n\tint bkt, i, j, count;\n\tDEFINE_HASHTABLE(hash, 3);\n\n\t \n\tfor (i = 0; i < 3; i++) {\n\t\tentries[i].key = i;\n\t\tentries[i].data = i + 10;\n\t\tentries[i].visited = 0;\n\t\thash_add(hash, &entries[i].node, entries[i].key);\n\t}\n\n\tcount = 0;\n\thash_for_each_safe(hash, bkt, tmp, x, node) {\n\t\tx->visited += 1;\n\t\tKUNIT_ASSERT_GE_MSG(test, x->key, 0, \"Unexpected key in hashtable.\");\n\t\tKUNIT_ASSERT_LT_MSG(test, x->key, 3, \"Unexpected key in hashtable.\");\n\t\tcount++;\n\n\t\t \n\t\thash_del(&x->node);\n\t}\n\n\t \n\tKUNIT_EXPECT_EQ(test, count, 3);\n\tfor (j = 0; j < 3; j++)\n\t\tKUNIT_EXPECT_EQ(test, entries[j].visited, 1);\n}\n\nstatic void hashtable_test_hash_for_each_possible(struct kunit *test)\n{\n\tstruct hashtable_test_entry entries[4];\n\tstruct hashtable_test_entry *x, *y;\n\tint buckets[2];\n\tint bkt, i, j, count;\n\tDEFINE_HASHTABLE(hash, 5);\n\n\t \n\tfor (i = 0; i < 3; i++) {\n\t\tentries[i].key = 0;\n\t\tentries[i].data = i;\n\t\tentries[i].visited = 0;\n\t\thash_add(hash, &entries[i].node, entries[i].key);\n\t}\n\n\t \n\tentries[3].key = 1;\n\tentries[3].data = 3;\n\tentries[3].visited = 0;\n\thash_add(hash, &entries[3].node, entries[3].key);\n\n\tcount = 0;\n\thash_for_each_possible(hash, x, node, 0) {\n\t\tx->visited += 1;\n\t\tKUNIT_ASSERT_GE_MSG(test, x->data, 0, \"Unexpected data in hashtable.\");\n\t\tKUNIT_ASSERT_LT_MSG(test, x->data, 4, \"Unexpected data in hashtable.\");\n\t\tcount++;\n\t}\n\n\t \n\tfor (j = 0; j < 3; j++)\n\t\tKUNIT_EXPECT_EQ(test, entries[j].visited, 1);\n\n\t \n\thash_for_each(hash, bkt, y, node) {\n\t\tKUNIT_ASSERT_GE_MSG(test, y->key, 0, \"Unexpected key in hashtable.\");\n\t\tKUNIT_ASSERT_LE_MSG(test, y->key, 1, \"Unexpected key in hashtable.\");\n\t\tbuckets[y->key] = bkt;\n\t}\n\n\t \n\tif (buckets[0] == buckets[1]) {\n\t\tKUNIT_EXPECT_EQ(test, count, 4);\n\t\tKUNIT_EXPECT_EQ(test, entries[3].visited, 1);\n\t} else {\n\t\tKUNIT_EXPECT_EQ(test, count, 3);\n\t\tKUNIT_EXPECT_EQ(test, entries[3].visited, 0);\n\t}\n}\n\nstatic void hashtable_test_hash_for_each_possible_safe(struct kunit *test)\n{\n\tstruct hashtable_test_entry entries[4];\n\tstruct hashtable_test_entry *x, *y;\n\tstruct hlist_node *tmp;\n\tint buckets[2];\n\tint bkt, i, j, count;\n\tDEFINE_HASHTABLE(hash, 5);\n\n\t \n\tfor (i = 0; i < 3; i++) {\n\t\tentries[i].key = 0;\n\t\tentries[i].data = i;\n\t\tentries[i].visited = 0;\n\t\thash_add(hash, &entries[i].node, entries[i].key);\n\t}\n\n\t \n\tentries[3].key = 1;\n\tentries[3].data = 3;\n\tentries[3].visited = 0;\n\thash_add(hash, &entries[3].node, entries[3].key);\n\n\tcount = 0;\n\thash_for_each_possible_safe(hash, x, tmp, node, 0) {\n\t\tx->visited += 1;\n\t\tKUNIT_ASSERT_GE_MSG(test, x->data, 0, \"Unexpected data in hashtable.\");\n\t\tKUNIT_ASSERT_LT_MSG(test, x->data, 4, \"Unexpected data in hashtable.\");\n\t\tcount++;\n\n\t\t \n\t\thash_del(&x->node);\n\t}\n\n\t \n\tfor (j = 0; j < 3; j++)\n\t\tKUNIT_EXPECT_EQ(test, entries[j].visited, 1);\n\n\t \n\thash_for_each(hash, bkt, y, node) {\n\t\tKUNIT_ASSERT_GE_MSG(test, y->key, 0, \"Unexpected key in hashtable.\");\n\t\tKUNIT_ASSERT_LE_MSG(test, y->key, 1, \"Unexpected key in hashtable.\");\n\t\tbuckets[y->key] = bkt;\n\t}\n\n\t \n\tif (buckets[0] == buckets[1]) {\n\t\tKUNIT_EXPECT_EQ(test, count, 4);\n\t\tKUNIT_EXPECT_EQ(test, entries[3].visited, 1);\n\t} else {\n\t\tKUNIT_EXPECT_EQ(test, count, 3);\n\t\tKUNIT_EXPECT_EQ(test, entries[3].visited, 0);\n\t}\n}\n\nstatic struct kunit_case hashtable_test_cases[] = {\n\tKUNIT_CASE(hashtable_test_hash_init),\n\tKUNIT_CASE(hashtable_test_hash_empty),\n\tKUNIT_CASE(hashtable_test_hash_hashed),\n\tKUNIT_CASE(hashtable_test_hash_add),\n\tKUNIT_CASE(hashtable_test_hash_del),\n\tKUNIT_CASE(hashtable_test_hash_for_each),\n\tKUNIT_CASE(hashtable_test_hash_for_each_safe),\n\tKUNIT_CASE(hashtable_test_hash_for_each_possible),\n\tKUNIT_CASE(hashtable_test_hash_for_each_possible_safe),\n\t{},\n};\n\nstatic struct kunit_suite hashtable_test_module = {\n\t.name = \"hashtable\",\n\t.test_cases = hashtable_test_cases,\n};\n\nkunit_test_suites(&hashtable_test_module);\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}