{
  "module_name": "error-inject.c",
  "hash_id": "aa7f6672dd636b31050b810fcbe4641f26b5ab70aa56871513595c9fd6903cb1",
  "original_prompt": "Ingested from linux-6.6.14/lib/error-inject.c",
  "human_readable_source": "\n\n#include <linux/error-injection.h>\n#include <linux/debugfs.h>\n#include <linux/kallsyms.h>\n#include <linux/kprobes.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <asm/sections.h>\n\n \nstatic LIST_HEAD(error_injection_list);\nstatic DEFINE_MUTEX(ei_mutex);\nstruct ei_entry {\n\tstruct list_head list;\n\tunsigned long start_addr;\n\tunsigned long end_addr;\n\tint etype;\n\tvoid *priv;\n};\n\nbool within_error_injection_list(unsigned long addr)\n{\n\tstruct ei_entry *ent;\n\tbool ret = false;\n\n\tmutex_lock(&ei_mutex);\n\tlist_for_each_entry(ent, &error_injection_list, list) {\n\t\tif (addr >= ent->start_addr && addr < ent->end_addr) {\n\t\t\tret = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&ei_mutex);\n\treturn ret;\n}\n\nint get_injectable_error_type(unsigned long addr)\n{\n\tstruct ei_entry *ent;\n\tint ei_type = -EINVAL;\n\n\tmutex_lock(&ei_mutex);\n\tlist_for_each_entry(ent, &error_injection_list, list) {\n\t\tif (addr >= ent->start_addr && addr < ent->end_addr) {\n\t\t\tei_type = ent->etype;\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&ei_mutex);\n\n\treturn ei_type;\n}\n\n \nstatic void populate_error_injection_list(struct error_injection_entry *start,\n\t\t\t\t\t  struct error_injection_entry *end,\n\t\t\t\t\t  void *priv)\n{\n\tstruct error_injection_entry *iter;\n\tstruct ei_entry *ent;\n\tunsigned long entry, offset = 0, size = 0;\n\n\tmutex_lock(&ei_mutex);\n\tfor (iter = start; iter < end; iter++) {\n\t\tentry = (unsigned long)dereference_symbol_descriptor((void *)iter->addr);\n\n\t\tif (!kernel_text_address(entry) ||\n\t\t    !kallsyms_lookup_size_offset(entry, &size, &offset)) {\n\t\t\tpr_err(\"Failed to find error inject entry at %p\\n\",\n\t\t\t\t(void *)entry);\n\t\t\tcontinue;\n\t\t}\n\n\t\tent = kmalloc(sizeof(*ent), GFP_KERNEL);\n\t\tif (!ent)\n\t\t\tbreak;\n\t\tent->start_addr = entry;\n\t\tent->end_addr = entry + size;\n\t\tent->etype = iter->etype;\n\t\tent->priv = priv;\n\t\tINIT_LIST_HEAD(&ent->list);\n\t\tlist_add_tail(&ent->list, &error_injection_list);\n\t}\n\tmutex_unlock(&ei_mutex);\n}\n\n \nextern struct error_injection_entry __start_error_injection_whitelist[];\nextern struct error_injection_entry __stop_error_injection_whitelist[];\n\nstatic void __init populate_kernel_ei_list(void)\n{\n\tpopulate_error_injection_list(__start_error_injection_whitelist,\n\t\t\t\t      __stop_error_injection_whitelist,\n\t\t\t\t      NULL);\n}\n\n#ifdef CONFIG_MODULES\nstatic void module_load_ei_list(struct module *mod)\n{\n\tif (!mod->num_ei_funcs)\n\t\treturn;\n\n\tpopulate_error_injection_list(mod->ei_funcs,\n\t\t\t\t      mod->ei_funcs + mod->num_ei_funcs, mod);\n}\n\nstatic void module_unload_ei_list(struct module *mod)\n{\n\tstruct ei_entry *ent, *n;\n\n\tif (!mod->num_ei_funcs)\n\t\treturn;\n\n\tmutex_lock(&ei_mutex);\n\tlist_for_each_entry_safe(ent, n, &error_injection_list, list) {\n\t\tif (ent->priv == mod) {\n\t\t\tlist_del_init(&ent->list);\n\t\t\tkfree(ent);\n\t\t}\n\t}\n\tmutex_unlock(&ei_mutex);\n}\n\n \nstatic int ei_module_callback(struct notifier_block *nb,\n\t\t\t      unsigned long val, void *data)\n{\n\tstruct module *mod = data;\n\n\tif (val == MODULE_STATE_COMING)\n\t\tmodule_load_ei_list(mod);\n\telse if (val == MODULE_STATE_GOING)\n\t\tmodule_unload_ei_list(mod);\n\n\treturn NOTIFY_DONE;\n}\n\nstatic struct notifier_block ei_module_nb = {\n\t.notifier_call = ei_module_callback,\n\t.priority = 0\n};\n\nstatic __init int module_ei_init(void)\n{\n\treturn register_module_notifier(&ei_module_nb);\n}\n#else  \n#define module_ei_init()\t(0)\n#endif\n\n \nstatic void *ei_seq_start(struct seq_file *m, loff_t *pos)\n{\n\tmutex_lock(&ei_mutex);\n\treturn seq_list_start(&error_injection_list, *pos);\n}\n\nstatic void ei_seq_stop(struct seq_file *m, void *v)\n{\n\tmutex_unlock(&ei_mutex);\n}\n\nstatic void *ei_seq_next(struct seq_file *m, void *v, loff_t *pos)\n{\n\treturn seq_list_next(v, &error_injection_list, pos);\n}\n\nstatic const char *error_type_string(int etype)\n{\n\tswitch (etype) {\n\tcase EI_ETYPE_NULL:\n\t\treturn \"NULL\";\n\tcase EI_ETYPE_ERRNO:\n\t\treturn \"ERRNO\";\n\tcase EI_ETYPE_ERRNO_NULL:\n\t\treturn \"ERRNO_NULL\";\n\tcase EI_ETYPE_TRUE:\n\t\treturn \"TRUE\";\n\tdefault:\n\t\treturn \"(unknown)\";\n\t}\n}\n\nstatic int ei_seq_show(struct seq_file *m, void *v)\n{\n\tstruct ei_entry *ent = list_entry(v, struct ei_entry, list);\n\n\tseq_printf(m, \"%ps\\t%s\\n\", (void *)ent->start_addr,\n\t\t   error_type_string(ent->etype));\n\treturn 0;\n}\n\nstatic const struct seq_operations ei_sops = {\n\t.start = ei_seq_start,\n\t.next  = ei_seq_next,\n\t.stop  = ei_seq_stop,\n\t.show  = ei_seq_show,\n};\n\nDEFINE_SEQ_ATTRIBUTE(ei);\n\nstatic int __init ei_debugfs_init(void)\n{\n\tstruct dentry *dir, *file;\n\n\tdir = debugfs_create_dir(\"error_injection\", NULL);\n\n\tfile = debugfs_create_file(\"list\", 0444, dir, NULL, &ei_fops);\n\tif (!file) {\n\t\tdebugfs_remove(dir);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\nstatic int __init init_error_injection(void)\n{\n\tpopulate_kernel_ei_list();\n\n\tif (!module_ei_init())\n\t\tei_debugfs_init();\n\n\treturn 0;\n}\nlate_initcall(init_error_injection);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}