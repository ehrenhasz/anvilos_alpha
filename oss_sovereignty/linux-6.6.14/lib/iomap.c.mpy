{
  "module_name": "iomap.c",
  "hash_id": "102e3801b897aaa0d57b5090cd08ed5da63058a7be58489e03a4fd5750ac3c94",
  "original_prompt": "Ingested from linux-6.6.14/lib/iomap.c",
  "human_readable_source": "\n \n#include <linux/pci.h>\n#include <linux/io.h>\n#include <linux/kmsan-checks.h>\n\n#include <linux/export.h>\n\n \n\n#ifndef HAVE_ARCH_PIO_SIZE\n \n#define PIO_OFFSET\t0x10000UL\n#define PIO_MASK\t0x0ffffUL\n#define PIO_RESERVED\t0x40000UL\n#endif\n\nstatic void bad_io_access(unsigned long port, const char *access)\n{\n\tstatic int count = 10;\n\tif (count) {\n\t\tcount--;\n\t\tWARN(1, KERN_ERR \"Bad IO access at port %#lx (%s)\\n\", port, access);\n\t}\n}\n\n \n#define IO_COND(addr, is_pio, is_mmio) do {\t\t\t\\\n\tunsigned long port = (unsigned long __force)addr;\t\\\n\tif (port >= PIO_RESERVED) {\t\t\t\t\\\n\t\tis_mmio;\t\t\t\t\t\\\n\t} else if (port > PIO_OFFSET) {\t\t\t\t\\\n\t\tport &= PIO_MASK;\t\t\t\t\\\n\t\tis_pio;\t\t\t\t\t\t\\\n\t} else\t\t\t\t\t\t\t\\\n\t\tbad_io_access(port, #is_pio );\t\t\t\\\n} while (0)\n\n#ifndef pio_read16be\n#define pio_read16be(port) swab16(inw(port))\n#define pio_read32be(port) swab32(inl(port))\n#endif\n\n#ifndef mmio_read16be\n#define mmio_read16be(addr) swab16(readw(addr))\n#define mmio_read32be(addr) swab32(readl(addr))\n#define mmio_read64be(addr) swab64(readq(addr))\n#endif\n\n \n__no_kmsan_checks\nunsigned int ioread8(const void __iomem *addr)\n{\n\tIO_COND(addr, return inb(port), return readb(addr));\n\treturn 0xff;\n}\n__no_kmsan_checks\nunsigned int ioread16(const void __iomem *addr)\n{\n\tIO_COND(addr, return inw(port), return readw(addr));\n\treturn 0xffff;\n}\n__no_kmsan_checks\nunsigned int ioread16be(const void __iomem *addr)\n{\n\tIO_COND(addr, return pio_read16be(port), return mmio_read16be(addr));\n\treturn 0xffff;\n}\n__no_kmsan_checks\nunsigned int ioread32(const void __iomem *addr)\n{\n\tIO_COND(addr, return inl(port), return readl(addr));\n\treturn 0xffffffff;\n}\n__no_kmsan_checks\nunsigned int ioread32be(const void __iomem *addr)\n{\n\tIO_COND(addr, return pio_read32be(port), return mmio_read32be(addr));\n\treturn 0xffffffff;\n}\nEXPORT_SYMBOL(ioread8);\nEXPORT_SYMBOL(ioread16);\nEXPORT_SYMBOL(ioread16be);\nEXPORT_SYMBOL(ioread32);\nEXPORT_SYMBOL(ioread32be);\n\n#ifdef readq\nstatic u64 pio_read64_lo_hi(unsigned long port)\n{\n\tu64 lo, hi;\n\n\tlo = inl(port);\n\thi = inl(port + sizeof(u32));\n\n\treturn lo | (hi << 32);\n}\n\nstatic u64 pio_read64_hi_lo(unsigned long port)\n{\n\tu64 lo, hi;\n\n\thi = inl(port + sizeof(u32));\n\tlo = inl(port);\n\n\treturn lo | (hi << 32);\n}\n\nstatic u64 pio_read64be_lo_hi(unsigned long port)\n{\n\tu64 lo, hi;\n\n\tlo = pio_read32be(port + sizeof(u32));\n\thi = pio_read32be(port);\n\n\treturn lo | (hi << 32);\n}\n\nstatic u64 pio_read64be_hi_lo(unsigned long port)\n{\n\tu64 lo, hi;\n\n\thi = pio_read32be(port);\n\tlo = pio_read32be(port + sizeof(u32));\n\n\treturn lo | (hi << 32);\n}\n\n__no_kmsan_checks\nu64 ioread64_lo_hi(const void __iomem *addr)\n{\n\tIO_COND(addr, return pio_read64_lo_hi(port), return readq(addr));\n\treturn 0xffffffffffffffffULL;\n}\n\n__no_kmsan_checks\nu64 ioread64_hi_lo(const void __iomem *addr)\n{\n\tIO_COND(addr, return pio_read64_hi_lo(port), return readq(addr));\n\treturn 0xffffffffffffffffULL;\n}\n\n__no_kmsan_checks\nu64 ioread64be_lo_hi(const void __iomem *addr)\n{\n\tIO_COND(addr, return pio_read64be_lo_hi(port),\n\t\treturn mmio_read64be(addr));\n\treturn 0xffffffffffffffffULL;\n}\n\n__no_kmsan_checks\nu64 ioread64be_hi_lo(const void __iomem *addr)\n{\n\tIO_COND(addr, return pio_read64be_hi_lo(port),\n\t\treturn mmio_read64be(addr));\n\treturn 0xffffffffffffffffULL;\n}\n\nEXPORT_SYMBOL(ioread64_lo_hi);\nEXPORT_SYMBOL(ioread64_hi_lo);\nEXPORT_SYMBOL(ioread64be_lo_hi);\nEXPORT_SYMBOL(ioread64be_hi_lo);\n\n#endif  \n\n#ifndef pio_write16be\n#define pio_write16be(val,port) outw(swab16(val),port)\n#define pio_write32be(val,port) outl(swab32(val),port)\n#endif\n\n#ifndef mmio_write16be\n#define mmio_write16be(val,port) writew(swab16(val),port)\n#define mmio_write32be(val,port) writel(swab32(val),port)\n#define mmio_write64be(val,port) writeq(swab64(val),port)\n#endif\n\nvoid iowrite8(u8 val, void __iomem *addr)\n{\n\t \n\tkmsan_check_memory(&val, sizeof(val));\n\tIO_COND(addr, outb(val,port), writeb(val, addr));\n}\nvoid iowrite16(u16 val, void __iomem *addr)\n{\n\t \n\tkmsan_check_memory(&val, sizeof(val));\n\tIO_COND(addr, outw(val,port), writew(val, addr));\n}\nvoid iowrite16be(u16 val, void __iomem *addr)\n{\n\t \n\tkmsan_check_memory(&val, sizeof(val));\n\tIO_COND(addr, pio_write16be(val,port), mmio_write16be(val, addr));\n}\nvoid iowrite32(u32 val, void __iomem *addr)\n{\n\t \n\tkmsan_check_memory(&val, sizeof(val));\n\tIO_COND(addr, outl(val,port), writel(val, addr));\n}\nvoid iowrite32be(u32 val, void __iomem *addr)\n{\n\t \n\tkmsan_check_memory(&val, sizeof(val));\n\tIO_COND(addr, pio_write32be(val,port), mmio_write32be(val, addr));\n}\nEXPORT_SYMBOL(iowrite8);\nEXPORT_SYMBOL(iowrite16);\nEXPORT_SYMBOL(iowrite16be);\nEXPORT_SYMBOL(iowrite32);\nEXPORT_SYMBOL(iowrite32be);\n\n#ifdef writeq\nstatic void pio_write64_lo_hi(u64 val, unsigned long port)\n{\n\toutl(val, port);\n\toutl(val >> 32, port + sizeof(u32));\n}\n\nstatic void pio_write64_hi_lo(u64 val, unsigned long port)\n{\n\toutl(val >> 32, port + sizeof(u32));\n\toutl(val, port);\n}\n\nstatic void pio_write64be_lo_hi(u64 val, unsigned long port)\n{\n\tpio_write32be(val, port + sizeof(u32));\n\tpio_write32be(val >> 32, port);\n}\n\nstatic void pio_write64be_hi_lo(u64 val, unsigned long port)\n{\n\tpio_write32be(val >> 32, port);\n\tpio_write32be(val, port + sizeof(u32));\n}\n\nvoid iowrite64_lo_hi(u64 val, void __iomem *addr)\n{\n\t \n\tkmsan_check_memory(&val, sizeof(val));\n\tIO_COND(addr, pio_write64_lo_hi(val, port),\n\t\twriteq(val, addr));\n}\n\nvoid iowrite64_hi_lo(u64 val, void __iomem *addr)\n{\n\t \n\tkmsan_check_memory(&val, sizeof(val));\n\tIO_COND(addr, pio_write64_hi_lo(val, port),\n\t\twriteq(val, addr));\n}\n\nvoid iowrite64be_lo_hi(u64 val, void __iomem *addr)\n{\n\t \n\tkmsan_check_memory(&val, sizeof(val));\n\tIO_COND(addr, pio_write64be_lo_hi(val, port),\n\t\tmmio_write64be(val, addr));\n}\n\nvoid iowrite64be_hi_lo(u64 val, void __iomem *addr)\n{\n\t \n\tkmsan_check_memory(&val, sizeof(val));\n\tIO_COND(addr, pio_write64be_hi_lo(val, port),\n\t\tmmio_write64be(val, addr));\n}\n\nEXPORT_SYMBOL(iowrite64_lo_hi);\nEXPORT_SYMBOL(iowrite64_hi_lo);\nEXPORT_SYMBOL(iowrite64be_lo_hi);\nEXPORT_SYMBOL(iowrite64be_hi_lo);\n\n#endif  \n\n \n#ifndef mmio_insb\nstatic inline void mmio_insb(const void __iomem *addr, u8 *dst, int count)\n{\n\twhile (--count >= 0) {\n\t\tu8 data = __raw_readb(addr);\n\t\t*dst = data;\n\t\tdst++;\n\t}\n}\nstatic inline void mmio_insw(const void __iomem *addr, u16 *dst, int count)\n{\n\twhile (--count >= 0) {\n\t\tu16 data = __raw_readw(addr);\n\t\t*dst = data;\n\t\tdst++;\n\t}\n}\nstatic inline void mmio_insl(const void __iomem *addr, u32 *dst, int count)\n{\n\twhile (--count >= 0) {\n\t\tu32 data = __raw_readl(addr);\n\t\t*dst = data;\n\t\tdst++;\n\t}\n}\n#endif\n\n#ifndef mmio_outsb\nstatic inline void mmio_outsb(void __iomem *addr, const u8 *src, int count)\n{\n\twhile (--count >= 0) {\n\t\t__raw_writeb(*src, addr);\n\t\tsrc++;\n\t}\n}\nstatic inline void mmio_outsw(void __iomem *addr, const u16 *src, int count)\n{\n\twhile (--count >= 0) {\n\t\t__raw_writew(*src, addr);\n\t\tsrc++;\n\t}\n}\nstatic inline void mmio_outsl(void __iomem *addr, const u32 *src, int count)\n{\n\twhile (--count >= 0) {\n\t\t__raw_writel(*src, addr);\n\t\tsrc++;\n\t}\n}\n#endif\n\nvoid ioread8_rep(const void __iomem *addr, void *dst, unsigned long count)\n{\n\tIO_COND(addr, insb(port,dst,count), mmio_insb(addr, dst, count));\n\t \n\tkmsan_unpoison_memory(dst, count);\n}\nvoid ioread16_rep(const void __iomem *addr, void *dst, unsigned long count)\n{\n\tIO_COND(addr, insw(port,dst,count), mmio_insw(addr, dst, count));\n\t \n\tkmsan_unpoison_memory(dst, count * 2);\n}\nvoid ioread32_rep(const void __iomem *addr, void *dst, unsigned long count)\n{\n\tIO_COND(addr, insl(port,dst,count), mmio_insl(addr, dst, count));\n\t \n\tkmsan_unpoison_memory(dst, count * 4);\n}\nEXPORT_SYMBOL(ioread8_rep);\nEXPORT_SYMBOL(ioread16_rep);\nEXPORT_SYMBOL(ioread32_rep);\n\nvoid iowrite8_rep(void __iomem *addr, const void *src, unsigned long count)\n{\n\t \n\tkmsan_check_memory(src, count);\n\tIO_COND(addr, outsb(port, src, count), mmio_outsb(addr, src, count));\n}\nvoid iowrite16_rep(void __iomem *addr, const void *src, unsigned long count)\n{\n\t \n\tkmsan_check_memory(src, count * 2);\n\tIO_COND(addr, outsw(port, src, count), mmio_outsw(addr, src, count));\n}\nvoid iowrite32_rep(void __iomem *addr, const void *src, unsigned long count)\n{\n\t \n\tkmsan_check_memory(src, count * 4);\n\tIO_COND(addr, outsl(port, src,count), mmio_outsl(addr, src, count));\n}\nEXPORT_SYMBOL(iowrite8_rep);\nEXPORT_SYMBOL(iowrite16_rep);\nEXPORT_SYMBOL(iowrite32_rep);\n\n#ifdef CONFIG_HAS_IOPORT_MAP\n \nvoid __iomem *ioport_map(unsigned long port, unsigned int nr)\n{\n\tif (port > PIO_MASK)\n\t\treturn NULL;\n\treturn (void __iomem *) (unsigned long) (port + PIO_OFFSET);\n}\n\nvoid ioport_unmap(void __iomem *addr)\n{\n\t \n}\nEXPORT_SYMBOL(ioport_map);\nEXPORT_SYMBOL(ioport_unmap);\n#endif  \n\n#ifdef CONFIG_PCI\n \nvoid pci_iounmap(struct pci_dev *dev, void __iomem * addr)\n{\n\tIO_COND(addr,  , iounmap(addr));\n}\nEXPORT_SYMBOL(pci_iounmap);\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}