{
  "module_name": "btree.c",
  "hash_id": "bf19348fc73663dbd43cf886df49ee465f0770e7088e4c0535d33dacfccab7bd",
  "original_prompt": "Ingested from linux-6.6.14/lib/btree.c",
  "human_readable_source": "\n \n\n#include <linux/btree.h>\n#include <linux/cache.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\n#define MAX(a, b) ((a) > (b) ? (a) : (b))\n#define NODESIZE MAX(L1_CACHE_BYTES, 128)\n\nstruct btree_geo {\n\tint keylen;\n\tint no_pairs;\n\tint no_longs;\n};\n\nstruct btree_geo btree_geo32 = {\n\t.keylen = 1,\n\t.no_pairs = NODESIZE / sizeof(long) / 2,\n\t.no_longs = NODESIZE / sizeof(long) / 2,\n};\nEXPORT_SYMBOL_GPL(btree_geo32);\n\n#define LONG_PER_U64 (64 / BITS_PER_LONG)\nstruct btree_geo btree_geo64 = {\n\t.keylen = LONG_PER_U64,\n\t.no_pairs = NODESIZE / sizeof(long) / (1 + LONG_PER_U64),\n\t.no_longs = LONG_PER_U64 * (NODESIZE / sizeof(long) / (1 + LONG_PER_U64)),\n};\nEXPORT_SYMBOL_GPL(btree_geo64);\n\nstruct btree_geo btree_geo128 = {\n\t.keylen = 2 * LONG_PER_U64,\n\t.no_pairs = NODESIZE / sizeof(long) / (1 + 2 * LONG_PER_U64),\n\t.no_longs = 2 * LONG_PER_U64 * (NODESIZE / sizeof(long) / (1 + 2 * LONG_PER_U64)),\n};\nEXPORT_SYMBOL_GPL(btree_geo128);\n\n#define MAX_KEYLEN\t(2 * LONG_PER_U64)\n\nstatic struct kmem_cache *btree_cachep;\n\nvoid *btree_alloc(gfp_t gfp_mask, void *pool_data)\n{\n\treturn kmem_cache_alloc(btree_cachep, gfp_mask);\n}\nEXPORT_SYMBOL_GPL(btree_alloc);\n\nvoid btree_free(void *element, void *pool_data)\n{\n\tkmem_cache_free(btree_cachep, element);\n}\nEXPORT_SYMBOL_GPL(btree_free);\n\nstatic unsigned long *btree_node_alloc(struct btree_head *head, gfp_t gfp)\n{\n\tunsigned long *node;\n\n\tnode = mempool_alloc(head->mempool, gfp);\n\tif (likely(node))\n\t\tmemset(node, 0, NODESIZE);\n\treturn node;\n}\n\nstatic int longcmp(const unsigned long *l1, const unsigned long *l2, size_t n)\n{\n\tsize_t i;\n\n\tfor (i = 0; i < n; i++) {\n\t\tif (l1[i] < l2[i])\n\t\t\treturn -1;\n\t\tif (l1[i] > l2[i])\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic unsigned long *longcpy(unsigned long *dest, const unsigned long *src,\n\t\tsize_t n)\n{\n\tsize_t i;\n\n\tfor (i = 0; i < n; i++)\n\t\tdest[i] = src[i];\n\treturn dest;\n}\n\nstatic unsigned long *longset(unsigned long *s, unsigned long c, size_t n)\n{\n\tsize_t i;\n\n\tfor (i = 0; i < n; i++)\n\t\ts[i] = c;\n\treturn s;\n}\n\nstatic void dec_key(struct btree_geo *geo, unsigned long *key)\n{\n\tunsigned long val;\n\tint i;\n\n\tfor (i = geo->keylen - 1; i >= 0; i--) {\n\t\tval = key[i];\n\t\tkey[i] = val - 1;\n\t\tif (val)\n\t\t\tbreak;\n\t}\n}\n\nstatic unsigned long *bkey(struct btree_geo *geo, unsigned long *node, int n)\n{\n\treturn &node[n * geo->keylen];\n}\n\nstatic void *bval(struct btree_geo *geo, unsigned long *node, int n)\n{\n\treturn (void *)node[geo->no_longs + n];\n}\n\nstatic void setkey(struct btree_geo *geo, unsigned long *node, int n,\n\t\t   unsigned long *key)\n{\n\tlongcpy(bkey(geo, node, n), key, geo->keylen);\n}\n\nstatic void setval(struct btree_geo *geo, unsigned long *node, int n,\n\t\t   void *val)\n{\n\tnode[geo->no_longs + n] = (unsigned long) val;\n}\n\nstatic void clearpair(struct btree_geo *geo, unsigned long *node, int n)\n{\n\tlongset(bkey(geo, node, n), 0, geo->keylen);\n\tnode[geo->no_longs + n] = 0;\n}\n\nstatic inline void __btree_init(struct btree_head *head)\n{\n\thead->node = NULL;\n\thead->height = 0;\n}\n\nvoid btree_init_mempool(struct btree_head *head, mempool_t *mempool)\n{\n\t__btree_init(head);\n\thead->mempool = mempool;\n}\nEXPORT_SYMBOL_GPL(btree_init_mempool);\n\nint btree_init(struct btree_head *head)\n{\n\t__btree_init(head);\n\thead->mempool = mempool_create(0, btree_alloc, btree_free, NULL);\n\tif (!head->mempool)\n\t\treturn -ENOMEM;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(btree_init);\n\nvoid btree_destroy(struct btree_head *head)\n{\n\tmempool_free(head->node, head->mempool);\n\tmempool_destroy(head->mempool);\n\thead->mempool = NULL;\n}\nEXPORT_SYMBOL_GPL(btree_destroy);\n\nvoid *btree_last(struct btree_head *head, struct btree_geo *geo,\n\t\t unsigned long *key)\n{\n\tint height = head->height;\n\tunsigned long *node = head->node;\n\n\tif (height == 0)\n\t\treturn NULL;\n\n\tfor ( ; height > 1; height--)\n\t\tnode = bval(geo, node, 0);\n\n\tlongcpy(key, bkey(geo, node, 0), geo->keylen);\n\treturn bval(geo, node, 0);\n}\nEXPORT_SYMBOL_GPL(btree_last);\n\nstatic int keycmp(struct btree_geo *geo, unsigned long *node, int pos,\n\t\t  unsigned long *key)\n{\n\treturn longcmp(bkey(geo, node, pos), key, geo->keylen);\n}\n\nstatic int keyzero(struct btree_geo *geo, unsigned long *key)\n{\n\tint i;\n\n\tfor (i = 0; i < geo->keylen; i++)\n\t\tif (key[i])\n\t\t\treturn 0;\n\n\treturn 1;\n}\n\nstatic void *btree_lookup_node(struct btree_head *head, struct btree_geo *geo,\n\t\tunsigned long *key)\n{\n\tint i, height = head->height;\n\tunsigned long *node = head->node;\n\n\tif (height == 0)\n\t\treturn NULL;\n\n\tfor ( ; height > 1; height--) {\n\t\tfor (i = 0; i < geo->no_pairs; i++)\n\t\t\tif (keycmp(geo, node, i, key) <= 0)\n\t\t\t\tbreak;\n\t\tif (i == geo->no_pairs)\n\t\t\treturn NULL;\n\t\tnode = bval(geo, node, i);\n\t\tif (!node)\n\t\t\treturn NULL;\n\t}\n\treturn node;\n}\n\nvoid *btree_lookup(struct btree_head *head, struct btree_geo *geo,\n\t\tunsigned long *key)\n{\n\tint i;\n\tunsigned long *node;\n\n\tnode = btree_lookup_node(head, geo, key);\n\tif (!node)\n\t\treturn NULL;\n\n\tfor (i = 0; i < geo->no_pairs; i++)\n\t\tif (keycmp(geo, node, i, key) == 0)\n\t\t\treturn bval(geo, node, i);\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(btree_lookup);\n\nint btree_update(struct btree_head *head, struct btree_geo *geo,\n\t\t unsigned long *key, void *val)\n{\n\tint i;\n\tunsigned long *node;\n\n\tnode = btree_lookup_node(head, geo, key);\n\tif (!node)\n\t\treturn -ENOENT;\n\n\tfor (i = 0; i < geo->no_pairs; i++)\n\t\tif (keycmp(geo, node, i, key) == 0) {\n\t\t\tsetval(geo, node, i, val);\n\t\t\treturn 0;\n\t\t}\n\treturn -ENOENT;\n}\nEXPORT_SYMBOL_GPL(btree_update);\n\n \nvoid *btree_get_prev(struct btree_head *head, struct btree_geo *geo,\n\t\t     unsigned long *__key)\n{\n\tint i, height;\n\tunsigned long *node, *oldnode;\n\tunsigned long *retry_key = NULL, key[MAX_KEYLEN];\n\n\tif (keyzero(geo, __key))\n\t\treturn NULL;\n\n\tif (head->height == 0)\n\t\treturn NULL;\n\tlongcpy(key, __key, geo->keylen);\nretry:\n\tdec_key(geo, key);\n\n\tnode = head->node;\n\tfor (height = head->height ; height > 1; height--) {\n\t\tfor (i = 0; i < geo->no_pairs; i++)\n\t\t\tif (keycmp(geo, node, i, key) <= 0)\n\t\t\t\tbreak;\n\t\tif (i == geo->no_pairs)\n\t\t\tgoto miss;\n\t\toldnode = node;\n\t\tnode = bval(geo, node, i);\n\t\tif (!node)\n\t\t\tgoto miss;\n\t\tretry_key = bkey(geo, oldnode, i);\n\t}\n\n\tif (!node)\n\t\tgoto miss;\n\n\tfor (i = 0; i < geo->no_pairs; i++) {\n\t\tif (keycmp(geo, node, i, key) <= 0) {\n\t\t\tif (bval(geo, node, i)) {\n\t\t\t\tlongcpy(__key, bkey(geo, node, i), geo->keylen);\n\t\t\t\treturn bval(geo, node, i);\n\t\t\t} else\n\t\t\t\tgoto miss;\n\t\t}\n\t}\nmiss:\n\tif (retry_key) {\n\t\tlongcpy(key, retry_key, geo->keylen);\n\t\tretry_key = NULL;\n\t\tgoto retry;\n\t}\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(btree_get_prev);\n\nstatic int getpos(struct btree_geo *geo, unsigned long *node,\n\t\tunsigned long *key)\n{\n\tint i;\n\n\tfor (i = 0; i < geo->no_pairs; i++) {\n\t\tif (keycmp(geo, node, i, key) <= 0)\n\t\t\tbreak;\n\t}\n\treturn i;\n}\n\nstatic int getfill(struct btree_geo *geo, unsigned long *node, int start)\n{\n\tint i;\n\n\tfor (i = start; i < geo->no_pairs; i++)\n\t\tif (!bval(geo, node, i))\n\t\t\tbreak;\n\treturn i;\n}\n\n \nstatic unsigned long *find_level(struct btree_head *head, struct btree_geo *geo,\n\t\tunsigned long *key, int level)\n{\n\tunsigned long *node = head->node;\n\tint i, height;\n\n\tfor (height = head->height; height > level; height--) {\n\t\tfor (i = 0; i < geo->no_pairs; i++)\n\t\t\tif (keycmp(geo, node, i, key) <= 0)\n\t\t\t\tbreak;\n\n\t\tif ((i == geo->no_pairs) || !bval(geo, node, i)) {\n\t\t\t \n\t\t\t \n\t\t\ti--;\n\t\t\tsetkey(geo, node, i, key);\n\t\t}\n\t\tBUG_ON(i < 0);\n\t\tnode = bval(geo, node, i);\n\t}\n\tBUG_ON(!node);\n\treturn node;\n}\n\nstatic int btree_grow(struct btree_head *head, struct btree_geo *geo,\n\t\t      gfp_t gfp)\n{\n\tunsigned long *node;\n\tint fill;\n\n\tnode = btree_node_alloc(head, gfp);\n\tif (!node)\n\t\treturn -ENOMEM;\n\tif (head->node) {\n\t\tfill = getfill(geo, head->node, 0);\n\t\tsetkey(geo, node, 0, bkey(geo, head->node, fill - 1));\n\t\tsetval(geo, node, 0, head->node);\n\t}\n\thead->node = node;\n\thead->height++;\n\treturn 0;\n}\n\nstatic void btree_shrink(struct btree_head *head, struct btree_geo *geo)\n{\n\tunsigned long *node;\n\tint fill;\n\n\tif (head->height <= 1)\n\t\treturn;\n\n\tnode = head->node;\n\tfill = getfill(geo, node, 0);\n\tBUG_ON(fill > 1);\n\thead->node = bval(geo, node, 0);\n\thead->height--;\n\tmempool_free(node, head->mempool);\n}\n\nstatic int btree_insert_level(struct btree_head *head, struct btree_geo *geo,\n\t\t\t      unsigned long *key, void *val, int level,\n\t\t\t      gfp_t gfp)\n{\n\tunsigned long *node;\n\tint i, pos, fill, err;\n\n\tBUG_ON(!val);\n\tif (head->height < level) {\n\t\terr = btree_grow(head, geo, gfp);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\nretry:\n\tnode = find_level(head, geo, key, level);\n\tpos = getpos(geo, node, key);\n\tfill = getfill(geo, node, pos);\n\t \n\tBUG_ON(pos < fill && keycmp(geo, node, pos, key) == 0);\n\n\tif (fill == geo->no_pairs) {\n\t\t \n\t\tunsigned long *new;\n\n\t\tnew = btree_node_alloc(head, gfp);\n\t\tif (!new)\n\t\t\treturn -ENOMEM;\n\t\terr = btree_insert_level(head, geo,\n\t\t\t\tbkey(geo, node, fill / 2 - 1),\n\t\t\t\tnew, level + 1, gfp);\n\t\tif (err) {\n\t\t\tmempool_free(new, head->mempool);\n\t\t\treturn err;\n\t\t}\n\t\tfor (i = 0; i < fill / 2; i++) {\n\t\t\tsetkey(geo, new, i, bkey(geo, node, i));\n\t\t\tsetval(geo, new, i, bval(geo, node, i));\n\t\t\tsetkey(geo, node, i, bkey(geo, node, i + fill / 2));\n\t\t\tsetval(geo, node, i, bval(geo, node, i + fill / 2));\n\t\t\tclearpair(geo, node, i + fill / 2);\n\t\t}\n\t\tif (fill & 1) {\n\t\t\tsetkey(geo, node, i, bkey(geo, node, fill - 1));\n\t\t\tsetval(geo, node, i, bval(geo, node, fill - 1));\n\t\t\tclearpair(geo, node, fill - 1);\n\t\t}\n\t\tgoto retry;\n\t}\n\tBUG_ON(fill >= geo->no_pairs);\n\n\t \n\tfor (i = fill; i > pos; i--) {\n\t\tsetkey(geo, node, i, bkey(geo, node, i - 1));\n\t\tsetval(geo, node, i, bval(geo, node, i - 1));\n\t}\n\tsetkey(geo, node, pos, key);\n\tsetval(geo, node, pos, val);\n\n\treturn 0;\n}\n\nint btree_insert(struct btree_head *head, struct btree_geo *geo,\n\t\tunsigned long *key, void *val, gfp_t gfp)\n{\n\tBUG_ON(!val);\n\treturn btree_insert_level(head, geo, key, val, 1, gfp);\n}\nEXPORT_SYMBOL_GPL(btree_insert);\n\nstatic void *btree_remove_level(struct btree_head *head, struct btree_geo *geo,\n\t\tunsigned long *key, int level);\nstatic void merge(struct btree_head *head, struct btree_geo *geo, int level,\n\t\tunsigned long *left, int lfill,\n\t\tunsigned long *right, int rfill,\n\t\tunsigned long *parent, int lpos)\n{\n\tint i;\n\n\tfor (i = 0; i < rfill; i++) {\n\t\t \n\t\tsetkey(geo, left, lfill + i, bkey(geo, right, i));\n\t\tsetval(geo, left, lfill + i, bval(geo, right, i));\n\t}\n\t \n\tsetval(geo, parent, lpos, right);\n\tsetval(geo, parent, lpos + 1, left);\n\t \n\tbtree_remove_level(head, geo, bkey(geo, parent, lpos), level + 1);\n\tmempool_free(right, head->mempool);\n}\n\nstatic void rebalance(struct btree_head *head, struct btree_geo *geo,\n\t\tunsigned long *key, int level, unsigned long *child, int fill)\n{\n\tunsigned long *parent, *left = NULL, *right = NULL;\n\tint i, no_left, no_right;\n\n\tif (fill == 0) {\n\t\t \n\t\tbtree_remove_level(head, geo, key, level + 1);\n\t\tmempool_free(child, head->mempool);\n\t\treturn;\n\t}\n\n\tparent = find_level(head, geo, key, level + 1);\n\ti = getpos(geo, parent, key);\n\tBUG_ON(bval(geo, parent, i) != child);\n\n\tif (i > 0) {\n\t\tleft = bval(geo, parent, i - 1);\n\t\tno_left = getfill(geo, left, 0);\n\t\tif (fill + no_left <= geo->no_pairs) {\n\t\t\tmerge(head, geo, level,\n\t\t\t\t\tleft, no_left,\n\t\t\t\t\tchild, fill,\n\t\t\t\t\tparent, i - 1);\n\t\t\treturn;\n\t\t}\n\t}\n\tif (i + 1 < getfill(geo, parent, i)) {\n\t\tright = bval(geo, parent, i + 1);\n\t\tno_right = getfill(geo, right, 0);\n\t\tif (fill + no_right <= geo->no_pairs) {\n\t\t\tmerge(head, geo, level,\n\t\t\t\t\tchild, fill,\n\t\t\t\t\tright, no_right,\n\t\t\t\t\tparent, i);\n\t\t\treturn;\n\t\t}\n\t}\n\t \n}\n\nstatic void *btree_remove_level(struct btree_head *head, struct btree_geo *geo,\n\t\tunsigned long *key, int level)\n{\n\tunsigned long *node;\n\tint i, pos, fill;\n\tvoid *ret;\n\n\tif (level > head->height) {\n\t\t \n\t\thead->height = 0;\n\t\thead->node = NULL;\n\t\treturn NULL;\n\t}\n\n\tnode = find_level(head, geo, key, level);\n\tpos = getpos(geo, node, key);\n\tfill = getfill(geo, node, pos);\n\tif ((level == 1) && (keycmp(geo, node, pos, key) != 0))\n\t\treturn NULL;\n\tret = bval(geo, node, pos);\n\n\t \n\tfor (i = pos; i < fill - 1; i++) {\n\t\tsetkey(geo, node, i, bkey(geo, node, i + 1));\n\t\tsetval(geo, node, i, bval(geo, node, i + 1));\n\t}\n\tclearpair(geo, node, fill - 1);\n\n\tif (fill - 1 < geo->no_pairs / 2) {\n\t\tif (level < head->height)\n\t\t\trebalance(head, geo, key, level, node, fill - 1);\n\t\telse if (fill - 1 == 1)\n\t\t\tbtree_shrink(head, geo);\n\t}\n\n\treturn ret;\n}\n\nvoid *btree_remove(struct btree_head *head, struct btree_geo *geo,\n\t\tunsigned long *key)\n{\n\tif (head->height == 0)\n\t\treturn NULL;\n\n\treturn btree_remove_level(head, geo, key, 1);\n}\nEXPORT_SYMBOL_GPL(btree_remove);\n\nint btree_merge(struct btree_head *target, struct btree_head *victim,\n\t\tstruct btree_geo *geo, gfp_t gfp)\n{\n\tunsigned long key[MAX_KEYLEN];\n\tunsigned long dup[MAX_KEYLEN];\n\tvoid *val;\n\tint err;\n\n\tBUG_ON(target == victim);\n\n\tif (!(target->node)) {\n\t\t \n\t\ttarget->node = victim->node;\n\t\ttarget->height = victim->height;\n\t\t__btree_init(victim);\n\t\treturn 0;\n\t}\n\n\t \n\tfor (;;) {\n\t\tif (!btree_last(victim, geo, key))\n\t\t\tbreak;\n\t\tval = btree_lookup(victim, geo, key);\n\t\terr = btree_insert(target, geo, key, val, gfp);\n\t\tif (err)\n\t\t\treturn err;\n\t\t \n\t\tlongcpy(dup, key, geo->keylen);\n\t\tbtree_remove(victim, geo, dup);\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(btree_merge);\n\nstatic size_t __btree_for_each(struct btree_head *head, struct btree_geo *geo,\n\t\t\t       unsigned long *node, unsigned long opaque,\n\t\t\t       void (*func)(void *elem, unsigned long opaque,\n\t\t\t\t\t    unsigned long *key, size_t index,\n\t\t\t\t\t    void *func2),\n\t\t\t       void *func2, int reap, int height, size_t count)\n{\n\tint i;\n\tunsigned long *child;\n\n\tfor (i = 0; i < geo->no_pairs; i++) {\n\t\tchild = bval(geo, node, i);\n\t\tif (!child)\n\t\t\tbreak;\n\t\tif (height > 1)\n\t\t\tcount = __btree_for_each(head, geo, child, opaque,\n\t\t\t\t\tfunc, func2, reap, height - 1, count);\n\t\telse\n\t\t\tfunc(child, opaque, bkey(geo, node, i), count++,\n\t\t\t\t\tfunc2);\n\t}\n\tif (reap)\n\t\tmempool_free(node, head->mempool);\n\treturn count;\n}\n\nstatic void empty(void *elem, unsigned long opaque, unsigned long *key,\n\t\t  size_t index, void *func2)\n{\n}\n\nvoid visitorl(void *elem, unsigned long opaque, unsigned long *key,\n\t      size_t index, void *__func)\n{\n\tvisitorl_t func = __func;\n\n\tfunc(elem, opaque, *key, index);\n}\nEXPORT_SYMBOL_GPL(visitorl);\n\nvoid visitor32(void *elem, unsigned long opaque, unsigned long *__key,\n\t       size_t index, void *__func)\n{\n\tvisitor32_t func = __func;\n\tu32 *key = (void *)__key;\n\n\tfunc(elem, opaque, *key, index);\n}\nEXPORT_SYMBOL_GPL(visitor32);\n\nvoid visitor64(void *elem, unsigned long opaque, unsigned long *__key,\n\t       size_t index, void *__func)\n{\n\tvisitor64_t func = __func;\n\tu64 *key = (void *)__key;\n\n\tfunc(elem, opaque, *key, index);\n}\nEXPORT_SYMBOL_GPL(visitor64);\n\nvoid visitor128(void *elem, unsigned long opaque, unsigned long *__key,\n\t\tsize_t index, void *__func)\n{\n\tvisitor128_t func = __func;\n\tu64 *key = (void *)__key;\n\n\tfunc(elem, opaque, key[0], key[1], index);\n}\nEXPORT_SYMBOL_GPL(visitor128);\n\nsize_t btree_visitor(struct btree_head *head, struct btree_geo *geo,\n\t\t     unsigned long opaque,\n\t\t     void (*func)(void *elem, unsigned long opaque,\n\t\t     \t\t  unsigned long *key,\n\t\t     \t\t  size_t index, void *func2),\n\t\t     void *func2)\n{\n\tsize_t count = 0;\n\n\tif (!func2)\n\t\tfunc = empty;\n\tif (head->node)\n\t\tcount = __btree_for_each(head, geo, head->node, opaque, func,\n\t\t\t\tfunc2, 0, head->height, 0);\n\treturn count;\n}\nEXPORT_SYMBOL_GPL(btree_visitor);\n\nsize_t btree_grim_visitor(struct btree_head *head, struct btree_geo *geo,\n\t\t\t  unsigned long opaque,\n\t\t\t  void (*func)(void *elem, unsigned long opaque,\n\t\t\t\t       unsigned long *key,\n\t\t\t\t       size_t index, void *func2),\n\t\t\t  void *func2)\n{\n\tsize_t count = 0;\n\n\tif (!func2)\n\t\tfunc = empty;\n\tif (head->node)\n\t\tcount = __btree_for_each(head, geo, head->node, opaque, func,\n\t\t\t\tfunc2, 1, head->height, 0);\n\t__btree_init(head);\n\treturn count;\n}\nEXPORT_SYMBOL_GPL(btree_grim_visitor);\n\nstatic int __init btree_module_init(void)\n{\n\tbtree_cachep = kmem_cache_create(\"btree_node\", NODESIZE, 0,\n\t\t\tSLAB_HWCACHE_ALIGN, NULL);\n\treturn 0;\n}\n\nstatic void __exit btree_module_exit(void)\n{\n\tkmem_cache_destroy(btree_cachep);\n}\n\n \nmodule_init(btree_module_init);\nmodule_exit(btree_module_exit);\n\nMODULE_AUTHOR(\"Joern Engel <joern@logfs.org>\");\nMODULE_AUTHOR(\"Johannes Berg <johannes@sipsolutions.net>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}