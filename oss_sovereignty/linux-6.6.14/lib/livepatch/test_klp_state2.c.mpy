{
  "module_name": "test_klp_state2.c",
  "hash_id": "36a61c76941f13f7ed189808c16dae6d411ced598f6c7732efe89d10497e22ab",
  "original_prompt": "Ingested from linux-6.6.14/lib/livepatch/test_klp_state2.c",
  "human_readable_source": "\n\n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/printk.h>\n#include <linux/livepatch.h>\n\n#define CONSOLE_LOGLEVEL_STATE 1\n \n#define CONSOLE_LOGLEVEL_STATE_VERSION 2\n\nstatic const char *const module_state[] = {\n\t[MODULE_STATE_LIVE]\t= \"[MODULE_STATE_LIVE] Normal state\",\n\t[MODULE_STATE_COMING]\t= \"[MODULE_STATE_COMING] Full formed, running module_init\",\n\t[MODULE_STATE_GOING]\t= \"[MODULE_STATE_GOING] Going away\",\n\t[MODULE_STATE_UNFORMED]\t= \"[MODULE_STATE_UNFORMED] Still setting it up\",\n};\n\nstatic void callback_info(const char *callback, struct klp_object *obj)\n{\n\tif (obj->mod)\n\t\tpr_info(\"%s: %s -> %s\\n\", callback, obj->mod->name,\n\t\t\tmodule_state[obj->mod->state]);\n\telse\n\t\tpr_info(\"%s: vmlinux\\n\", callback);\n}\n\nstatic struct klp_patch patch;\n\nstatic int allocate_loglevel_state(void)\n{\n\tstruct klp_state *loglevel_state, *prev_loglevel_state;\n\n\tprev_loglevel_state = klp_get_prev_state(CONSOLE_LOGLEVEL_STATE);\n\tif (prev_loglevel_state) {\n\t\tpr_info(\"%s: space to store console_loglevel already allocated\\n\",\n\t\t__func__);\n\t\treturn 0;\n\t}\n\n\tloglevel_state = klp_get_state(&patch, CONSOLE_LOGLEVEL_STATE);\n\tif (!loglevel_state)\n\t\treturn -EINVAL;\n\n\tloglevel_state->data = kzalloc(sizeof(console_loglevel), GFP_KERNEL);\n\tif (!loglevel_state->data)\n\t\treturn -ENOMEM;\n\n\tpr_info(\"%s: allocating space to store console_loglevel\\n\",\n\t\t__func__);\n\treturn 0;\n}\n\nstatic void fix_console_loglevel(void)\n{\n\tstruct klp_state *loglevel_state, *prev_loglevel_state;\n\n\tloglevel_state = klp_get_state(&patch, CONSOLE_LOGLEVEL_STATE);\n\tif (!loglevel_state)\n\t\treturn;\n\n\tprev_loglevel_state = klp_get_prev_state(CONSOLE_LOGLEVEL_STATE);\n\tif (prev_loglevel_state) {\n\t\tpr_info(\"%s: taking over the console_loglevel change\\n\",\n\t\t__func__);\n\t\tloglevel_state->data = prev_loglevel_state->data;\n\t\treturn;\n\t}\n\n\tpr_info(\"%s: fixing console_loglevel\\n\", __func__);\n\t*(int *)loglevel_state->data = console_loglevel;\n\tconsole_loglevel = CONSOLE_LOGLEVEL_MOTORMOUTH;\n}\n\nstatic void restore_console_loglevel(void)\n{\n\tstruct klp_state *loglevel_state, *prev_loglevel_state;\n\n\tprev_loglevel_state = klp_get_prev_state(CONSOLE_LOGLEVEL_STATE);\n\tif (prev_loglevel_state) {\n\t\tpr_info(\"%s: passing the console_loglevel change back to the old livepatch\\n\",\n\t\t__func__);\n\t\treturn;\n\t}\n\n\tloglevel_state = klp_get_state(&patch, CONSOLE_LOGLEVEL_STATE);\n\tif (!loglevel_state)\n\t\treturn;\n\n\tpr_info(\"%s: restoring console_loglevel\\n\", __func__);\n\tconsole_loglevel = *(int *)loglevel_state->data;\n}\n\nstatic void free_loglevel_state(void)\n{\n\tstruct klp_state *loglevel_state, *prev_loglevel_state;\n\n\tprev_loglevel_state = klp_get_prev_state(CONSOLE_LOGLEVEL_STATE);\n\tif (prev_loglevel_state) {\n\t\tpr_info(\"%s: keeping space to store console_loglevel\\n\",\n\t\t__func__);\n\t\treturn;\n\t}\n\n\tloglevel_state = klp_get_state(&patch, CONSOLE_LOGLEVEL_STATE);\n\tif (!loglevel_state)\n\t\treturn;\n\n\tpr_info(\"%s: freeing space for the stored console_loglevel\\n\",\n\t\t__func__);\n\tkfree(loglevel_state->data);\n}\n\n \nstatic int pre_patch_callback(struct klp_object *obj)\n{\n\tcallback_info(__func__, obj);\n\treturn allocate_loglevel_state();\n}\n\n \nstatic void post_patch_callback(struct klp_object *obj)\n{\n\tcallback_info(__func__, obj);\n\tfix_console_loglevel();\n}\n\n \nstatic void pre_unpatch_callback(struct klp_object *obj)\n{\n\tcallback_info(__func__, obj);\n\trestore_console_loglevel();\n}\n\n \nstatic void post_unpatch_callback(struct klp_object *obj)\n{\n\tcallback_info(__func__, obj);\n\tfree_loglevel_state();\n}\n\nstatic struct klp_func no_funcs[] = {\n\t{}\n};\n\nstatic struct klp_object objs[] = {\n\t{\n\t\t.name = NULL,\t \n\t\t.funcs = no_funcs,\n\t\t.callbacks = {\n\t\t\t.pre_patch = pre_patch_callback,\n\t\t\t.post_patch = post_patch_callback,\n\t\t\t.pre_unpatch = pre_unpatch_callback,\n\t\t\t.post_unpatch = post_unpatch_callback,\n\t\t},\n\t}, { }\n};\n\nstatic struct klp_state states[] = {\n\t{\n\t\t.id = CONSOLE_LOGLEVEL_STATE,\n\t\t.version = CONSOLE_LOGLEVEL_STATE_VERSION,\n\t}, { }\n};\n\nstatic struct klp_patch patch = {\n\t.mod = THIS_MODULE,\n\t.objs = objs,\n\t.states = states,\n\t.replace = true,\n};\n\nstatic int test_klp_callbacks_demo_init(void)\n{\n\treturn klp_enable_patch(&patch);\n}\n\nstatic void test_klp_callbacks_demo_exit(void)\n{\n}\n\nmodule_init(test_klp_callbacks_demo_init);\nmodule_exit(test_klp_callbacks_demo_exit);\nMODULE_LICENSE(\"GPL\");\nMODULE_INFO(livepatch, \"Y\");\nMODULE_AUTHOR(\"Petr Mladek <pmladek@suse.com>\");\nMODULE_DESCRIPTION(\"Livepatch test: system state modification\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}