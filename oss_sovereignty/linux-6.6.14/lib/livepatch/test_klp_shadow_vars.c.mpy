{
  "module_name": "test_klp_shadow_vars.c",
  "hash_id": "32265bb86fbba5a3bca1004b271d097e1c8478ffc236f7db0af4a6dcdfd4a03d",
  "original_prompt": "Ingested from linux-6.6.14/lib/livepatch/test_klp_shadow_vars.c",
  "human_readable_source": "\n\n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/livepatch.h>\n#include <linux/slab.h>\n\n \nstatic LIST_HEAD(ptr_list);\nstruct shadow_ptr {\n\tvoid *ptr;\n\tint id;\n\tstruct list_head list;\n};\n\nstatic void free_ptr_list(void)\n{\n\tstruct shadow_ptr *sp, *tmp_sp;\n\n\tlist_for_each_entry_safe(sp, tmp_sp, &ptr_list, list) {\n\t\tlist_del(&sp->list);\n\t\tkfree(sp);\n\t}\n}\n\nstatic int ptr_id(void *ptr)\n{\n\tstruct shadow_ptr *sp;\n\tstatic int count;\n\n\tlist_for_each_entry(sp, &ptr_list, list) {\n\t\tif (sp->ptr == ptr)\n\t\t\treturn sp->id;\n\t}\n\n\tsp = kmalloc(sizeof(*sp), GFP_ATOMIC);\n\tif (!sp)\n\t\treturn -ENOMEM;\n\tsp->ptr = ptr;\n\tsp->id = count++;\n\n\tlist_add(&sp->list, &ptr_list);\n\n\treturn sp->id;\n}\n\n \nstatic void *shadow_get(void *obj, unsigned long id)\n{\n\tint **sv;\n\n\tsv = klp_shadow_get(obj, id);\n\tpr_info(\"klp_%s(obj=PTR%d, id=0x%lx) = PTR%d\\n\",\n\t\t__func__, ptr_id(obj), id, ptr_id(sv));\n\n\treturn sv;\n}\n\nstatic void *shadow_alloc(void *obj, unsigned long id, size_t size,\n\t\t\t  gfp_t gfp_flags, klp_shadow_ctor_t ctor,\n\t\t\t  void *ctor_data)\n{\n\tint **var = ctor_data;\n\tint **sv;\n\n\tsv = klp_shadow_alloc(obj, id, size, gfp_flags, ctor, var);\n\tpr_info(\"klp_%s(obj=PTR%d, id=0x%lx, size=%zx, gfp_flags=%pGg), ctor=PTR%d, ctor_data=PTR%d = PTR%d\\n\",\n\t\t__func__, ptr_id(obj), id, size, &gfp_flags, ptr_id(ctor),\n\t\tptr_id(*var), ptr_id(sv));\n\n\treturn sv;\n}\n\nstatic void *shadow_get_or_alloc(void *obj, unsigned long id, size_t size,\n\t\t\t\t gfp_t gfp_flags, klp_shadow_ctor_t ctor,\n\t\t\t\t void *ctor_data)\n{\n\tint **var = ctor_data;\n\tint **sv;\n\n\tsv = klp_shadow_get_or_alloc(obj, id, size, gfp_flags, ctor, var);\n\tpr_info(\"klp_%s(obj=PTR%d, id=0x%lx, size=%zx, gfp_flags=%pGg), ctor=PTR%d, ctor_data=PTR%d = PTR%d\\n\",\n\t\t__func__, ptr_id(obj), id, size, &gfp_flags, ptr_id(ctor),\n\t\tptr_id(*var), ptr_id(sv));\n\n\treturn sv;\n}\n\nstatic void shadow_free(void *obj, unsigned long id, klp_shadow_dtor_t dtor)\n{\n\tklp_shadow_free(obj, id, dtor);\n\tpr_info(\"klp_%s(obj=PTR%d, id=0x%lx, dtor=PTR%d)\\n\",\n\t\t__func__, ptr_id(obj), id, ptr_id(dtor));\n}\n\nstatic void shadow_free_all(unsigned long id, klp_shadow_dtor_t dtor)\n{\n\tklp_shadow_free_all(id, dtor);\n\tpr_info(\"klp_%s(id=0x%lx, dtor=PTR%d)\\n\", __func__, id, ptr_id(dtor));\n}\n\n\n \nstatic int shadow_ctor(void *obj, void *shadow_data, void *ctor_data)\n{\n\tint **sv = shadow_data;\n\tint **var = ctor_data;\n\n\tif (!var)\n\t\treturn -EINVAL;\n\n\t*sv = *var;\n\tpr_info(\"%s: PTR%d -> PTR%d\\n\", __func__, ptr_id(sv), ptr_id(*var));\n\n\treturn 0;\n}\n\n \nstatic void shadow_dtor(void *obj, void *shadow_data)\n{\n\tint **sv = shadow_data;\n\n\tpr_info(\"%s(obj=PTR%d, shadow_data=PTR%d)\\n\",\n\t\t__func__, ptr_id(obj), ptr_id(sv));\n}\n\n \n#define NUM_OBJS 3\n\n \n#define SV_ID1 0x1234\n#define SV_ID2 0x1235\n\n \nstruct test_object {\n\t  \n\tstruct shadow_ptr sp;\n\n\t \n\t \n\t \n};\n\nstatic int test_klp_shadow_vars_init(void)\n{\n\tstruct test_object objs[NUM_OBJS];\n\tchar nfields1[NUM_OBJS], *pnfields1[NUM_OBJS], **sv1[NUM_OBJS];\n\tchar *pndup[NUM_OBJS];\n\tint nfields2[NUM_OBJS], *pnfields2[NUM_OBJS], **sv2[NUM_OBJS];\n\tvoid **sv;\n\tint ret;\n\tint i;\n\n\tptr_id(NULL);\n\n\t \n\tsv = shadow_get(&objs[0], SV_ID1);\n\tif (!sv)\n\t\tpr_info(\"  got expected NULL result\\n\");\n\n\t \n\tfor (i = 0; i < NUM_OBJS; i++) {\n\t\tpnfields1[i] = &nfields1[i];\n\t\tptr_id(pnfields1[i]);\n\n\t\tif (i % 2) {\n\t\t\tsv1[i] = shadow_alloc(&objs[i], SV_ID1,\n\t\t\t\t\tsizeof(pnfields1[i]), GFP_KERNEL,\n\t\t\t\t\tshadow_ctor, &pnfields1[i]);\n\t\t} else {\n\t\t\tsv1[i] = shadow_get_or_alloc(&objs[i], SV_ID1,\n\t\t\t\t\tsizeof(pnfields1[i]), GFP_KERNEL,\n\t\t\t\t\tshadow_ctor, &pnfields1[i]);\n\t\t}\n\t\tif (!sv1[i]) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\tpnfields2[i] = &nfields2[i];\n\t\tptr_id(pnfields2[i]);\n\t\tsv2[i] = shadow_alloc(&objs[i], SV_ID2, sizeof(pnfields2[i]),\n\t\t\t\t\tGFP_KERNEL, shadow_ctor, &pnfields2[i]);\n\t\tif (!sv2[i]) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < NUM_OBJS; i++) {\n\t\t \n\t\tsv = shadow_get(&objs[i], SV_ID1);\n\t\tif (!sv) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((char **)sv == sv1[i] && *sv1[i] == pnfields1[i])\n\t\t\tpr_info(\"  got expected PTR%d -> PTR%d result\\n\",\n\t\t\t\tptr_id(sv1[i]), ptr_id(*sv1[i]));\n\n\t\t \n\t\tsv = shadow_get(&objs[i], SV_ID2);\n\t\tif (!sv) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((int **)sv == sv2[i] && *sv2[i] == pnfields2[i])\n\t\t\tpr_info(\"  got expected PTR%d -> PTR%d result\\n\",\n\t\t\t\tptr_id(sv2[i]), ptr_id(*sv2[i]));\n\t}\n\n\t \n\tfor (i = 0; i < NUM_OBJS; i++) {\n\t\tpndup[i] = &nfields1[i];\n\t\tptr_id(pndup[i]);\n\n\t\tsv = shadow_get_or_alloc(&objs[i], SV_ID1, sizeof(pndup[i]),\n\t\t\t\t\tGFP_KERNEL, shadow_ctor, &pndup[i]);\n\t\tif (!sv) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((char **)sv == sv1[i] && *sv1[i] == pnfields1[i])\n\t\t\tpr_info(\"  got expected PTR%d -> PTR%d result\\n\",\n\t\t\t\t\tptr_id(sv1[i]), ptr_id(*sv1[i]));\n\t}\n\n\t \n\tfor (i = 0; i < NUM_OBJS; i++) {\n\t\tshadow_free(&objs[i], SV_ID1, shadow_dtor);  \n\t\tsv = shadow_get(&objs[i], SV_ID1);\n\t\tif (!sv)\n\t\t\tpr_info(\"  got expected NULL result\\n\");\n\t}\n\n\t \n\tfor (i = 0; i < NUM_OBJS; i++) {\n\t\tsv = shadow_get(&objs[i], SV_ID2);\t \n\t\tif (!sv) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((int **)sv == sv2[i] && *sv2[i] == pnfields2[i])\n\t\t\tpr_info(\"  got expected PTR%d -> PTR%d result\\n\",\n\t\t\t\t\tptr_id(sv2[i]), ptr_id(*sv2[i]));\n\t}\n\n\t \n\tshadow_free_all(SV_ID2, NULL);\t\t \n\tfor (i = 0; i < NUM_OBJS; i++) {\n\t\tsv = shadow_get(&objs[i], SV_ID2);\n\t\tif (!sv)\n\t\t\tpr_info(\"  got expected NULL result\\n\");\n\t}\n\n\tfree_ptr_list();\n\n\treturn 0;\nout:\n\tshadow_free_all(SV_ID1, NULL);\t\t \n\tshadow_free_all(SV_ID2, NULL);\t\t \n\tfree_ptr_list();\n\n\treturn ret;\n}\n\nstatic void test_klp_shadow_vars_exit(void)\n{\n}\n\nmodule_init(test_klp_shadow_vars_init);\nmodule_exit(test_klp_shadow_vars_exit);\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Joe Lawrence <joe.lawrence@redhat.com>\");\nMODULE_DESCRIPTION(\"Livepatch test: shadow variables\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}