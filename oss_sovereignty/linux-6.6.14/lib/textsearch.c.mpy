{
  "module_name": "textsearch.c",
  "hash_id": "54097e3dc54e419a57cddec9b80fe6ee3d2fb374c0ff60e6bb95f1225cec76b4",
  "original_prompt": "Ingested from linux-6.6.14/lib/textsearch.c",
  "human_readable_source": "\n \n\n \n \n\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/rculist.h>\n#include <linux/rcupdate.h>\n#include <linux/err.h>\n#include <linux/textsearch.h>\n#include <linux/slab.h>\n\nstatic LIST_HEAD(ts_ops);\nstatic DEFINE_SPINLOCK(ts_mod_lock);\n\nstatic inline struct ts_ops *lookup_ts_algo(const char *name)\n{\n\tstruct ts_ops *o;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(o, &ts_ops, list) {\n\t\tif (!strcmp(name, o->name)) {\n\t\t\tif (!try_module_get(o->owner))\n\t\t\t\to = NULL;\n\t\t\trcu_read_unlock();\n\t\t\treturn o;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\treturn NULL;\n}\n\n \nint textsearch_register(struct ts_ops *ops)\n{\n\tint err = -EEXIST;\n\tstruct ts_ops *o;\n\n\tif (ops->name == NULL || ops->find == NULL || ops->init == NULL ||\n\t    ops->get_pattern == NULL || ops->get_pattern_len == NULL)\n\t\treturn -EINVAL;\n\n\tspin_lock(&ts_mod_lock);\n\tlist_for_each_entry(o, &ts_ops, list) {\n\t\tif (!strcmp(ops->name, o->name))\n\t\t\tgoto errout;\n\t}\n\n\tlist_add_tail_rcu(&ops->list, &ts_ops);\n\terr = 0;\nerrout:\n\tspin_unlock(&ts_mod_lock);\n\treturn err;\n}\nEXPORT_SYMBOL(textsearch_register);\n\n \nint textsearch_unregister(struct ts_ops *ops)\n{\n\tint err = 0;\n\tstruct ts_ops *o;\n\n\tspin_lock(&ts_mod_lock);\n\tlist_for_each_entry(o, &ts_ops, list) {\n\t\tif (o == ops) {\n\t\t\tlist_del_rcu(&o->list);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\terr = -ENOENT;\nout:\n\tspin_unlock(&ts_mod_lock);\n\treturn err;\n}\nEXPORT_SYMBOL(textsearch_unregister);\n\nstruct ts_linear_state\n{\n\tunsigned int\tlen;\n\tconst void\t*data;\n};\n\nstatic unsigned int get_linear_data(unsigned int consumed, const u8 **dst,\n\t\t\t\t    struct ts_config *conf,\n\t\t\t\t    struct ts_state *state)\n{\n\tstruct ts_linear_state *st = (struct ts_linear_state *) state->cb;\n\n\tif (likely(consumed < st->len)) {\n\t\t*dst = st->data + consumed;\n\t\treturn st->len - consumed;\n\t}\n\n\treturn 0;\n}\n\n \nunsigned int textsearch_find_continuous(struct ts_config *conf,\n\t\t\t\t\tstruct ts_state *state,\n\t\t\t\t\tconst void *data, unsigned int len)\n{\n\tstruct ts_linear_state *st = (struct ts_linear_state *) state->cb;\n\n\tconf->get_next_block = get_linear_data;\n\tst->data = data;\n\tst->len = len;\n\n\treturn textsearch_find(conf, state);\n}\nEXPORT_SYMBOL(textsearch_find_continuous);\n\n \nstruct ts_config *textsearch_prepare(const char *algo, const void *pattern,\n\t\t\t\t     unsigned int len, gfp_t gfp_mask, int flags)\n{\n\tint err = -ENOENT;\n\tstruct ts_config *conf;\n\tstruct ts_ops *ops;\n\t\n\tif (len == 0)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tops = lookup_ts_algo(algo);\n#ifdef CONFIG_MODULES\n\t \n\tif (ops == NULL && flags & TS_AUTOLOAD) {\n\t\trequest_module(\"ts_%s\", algo);\n\t\tops = lookup_ts_algo(algo);\n\t}\n#endif\n\n\tif (ops == NULL)\n\t\tgoto errout;\n\n\tconf = ops->init(pattern, len, gfp_mask, flags);\n\tif (IS_ERR(conf)) {\n\t\terr = PTR_ERR(conf);\n\t\tgoto errout;\n\t}\n\n\tconf->ops = ops;\n\treturn conf;\n\nerrout:\n\tif (ops)\n\t\tmodule_put(ops->owner);\n\t\t\n\treturn ERR_PTR(err);\n}\nEXPORT_SYMBOL(textsearch_prepare);\n\n \nvoid textsearch_destroy(struct ts_config *conf)\n{\n\tif (conf->ops) {\n\t\tif (conf->ops->destroy)\n\t\t\tconf->ops->destroy(conf);\n\t\tmodule_put(conf->ops->owner);\n\t}\n\n\tkfree(conf);\n}\nEXPORT_SYMBOL(textsearch_destroy);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}