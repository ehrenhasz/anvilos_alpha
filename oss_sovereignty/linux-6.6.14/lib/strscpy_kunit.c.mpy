{
  "module_name": "strscpy_kunit.c",
  "hash_id": "f8853fd27a57fe8eed4c849a3a91c074e4efa703e088deb39a2ec5a07dcf93e2",
  "original_prompt": "Ingested from linux-6.6.14/lib/strscpy_kunit.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <kunit/test.h>\n#include <linux/string.h>\n\n \nstatic void tc(struct kunit *test, char *src, int count, int expected,\n\t       int chars, int terminator, int pad)\n{\n\tint nr_bytes_poison;\n\tint max_expected;\n\tint max_count;\n\tint written;\n\tchar buf[6];\n\tint index, i;\n\tconst char POISON = 'z';\n\n\tKUNIT_ASSERT_TRUE_MSG(test, src != NULL,\n\t\t\t      \"null source string not supported\");\n\n\tmemset(buf, POISON, sizeof(buf));\n\t \n\tmax_count = sizeof(buf) - 2;  \n\tmax_expected = count - 1;     \n\n\tKUNIT_ASSERT_LE_MSG(test, count, max_count,\n\t\t\"count (%d) is too big (%d) ... aborting\", count, max_count);\n\tKUNIT_EXPECT_LE_MSG(test, expected, max_expected,\n\t\t\"expected (%d) is bigger than can possibly be returned (%d)\",\n\t\texpected, max_expected);\n\n\twritten = strscpy_pad(buf, src, count);\n\tKUNIT_ASSERT_EQ(test, written, expected);\n\n\tif (count && written == -E2BIG) {\n\t\tKUNIT_ASSERT_EQ_MSG(test, 0, strncmp(buf, src, count - 1),\n\t\t\t\"buffer state invalid for -E2BIG\");\n\t\tKUNIT_ASSERT_EQ_MSG(test, buf[count - 1], '\\0',\n\t\t\t\"too big string is not null terminated correctly\");\n\t}\n\n\tfor (i = 0; i < chars; i++)\n\t\tKUNIT_ASSERT_EQ_MSG(test, buf[i], src[i],\n\t\t\t\"buf[i]==%c != src[i]==%c\", buf[i], src[i]);\n\n\tif (terminator)\n\t\tKUNIT_ASSERT_EQ_MSG(test, buf[count - 1], '\\0',\n\t\t\t\"string is not null terminated correctly\");\n\n\tfor (i = 0; i < pad; i++) {\n\t\tindex = chars + terminator + i;\n\t\tKUNIT_ASSERT_EQ_MSG(test, buf[index], '\\0',\n\t\t\t\"padding missing at index: %d\", i);\n\t}\n\n\tnr_bytes_poison = sizeof(buf) - chars - terminator - pad;\n\tfor (i = 0; i < nr_bytes_poison; i++) {\n\t\tindex = sizeof(buf) - 1 - i;  \n\t\tKUNIT_ASSERT_EQ_MSG(test, buf[index], POISON,\n\t\t\t\"poison value missing at index: %d\", i);\n\t}\n}\n\nstatic void strscpy_test(struct kunit *test)\n{\n\tchar dest[8];\n\n\t \n\n\t \n\ttc(test, \"a\", 0, -E2BIG, 0, 0, 0);\n\ttc(test, \"\",  0, -E2BIG, 0, 0, 0);\n\n\ttc(test, \"a\", 1, -E2BIG, 0, 1, 0);\n\ttc(test, \"\",  1, 0,\t 0, 1, 0);\n\n\ttc(test, \"ab\", 2, -E2BIG, 1, 1, 0);\n\ttc(test, \"a\",  2, 1,\t  1, 1, 0);\n\ttc(test, \"\",   2, 0,\t  0, 1, 1);\n\n\ttc(test, \"abc\", 3, -E2BIG, 2, 1, 0);\n\ttc(test, \"ab\",  3, 2,\t   2, 1, 0);\n\ttc(test, \"a\",   3, 1,\t   1, 1, 1);\n\ttc(test, \"\",    3, 0,\t   0, 1, 2);\n\n\ttc(test, \"abcd\", 4, -E2BIG, 3, 1, 0);\n\ttc(test, \"abc\",  4, 3,\t    3, 1, 0);\n\ttc(test, \"ab\",   4, 2,\t    2, 1, 1);\n\ttc(test, \"a\",    4, 1,\t    1, 1, 2);\n\ttc(test, \"\",     4, 0,\t    0, 1, 3);\n\n\t \n\tKUNIT_EXPECT_EQ(test, strscpy(dest, \"\", ARRAY_SIZE(dest)), 0);\n\tKUNIT_EXPECT_EQ(test, strscpy(dest, \"\", 3), 0);\n\tKUNIT_EXPECT_EQ(test, strscpy(dest, \"\", 1), 0);\n\tKUNIT_EXPECT_EQ(test, strscpy(dest, \"\", 0), -E2BIG);\n\tKUNIT_EXPECT_EQ(test, strscpy(dest, \"Fixed\", ARRAY_SIZE(dest)), 5);\n\tKUNIT_EXPECT_EQ(test, strscpy(dest, \"Fixed\", 3), -E2BIG);\n\tKUNIT_EXPECT_EQ(test, strscpy(dest, \"Fixed\", 1), -E2BIG);\n\tKUNIT_EXPECT_EQ(test, strscpy(dest, \"Fixed\", 0), -E2BIG);\n\tKUNIT_EXPECT_EQ(test, strscpy(dest, \"This is too long\", ARRAY_SIZE(dest)), -E2BIG);\n}\n\nstatic struct kunit_case strscpy_test_cases[] = {\n\tKUNIT_CASE(strscpy_test),\n\t{}\n};\n\nstatic struct kunit_suite strscpy_test_suite = {\n\t.name = \"strscpy\",\n\t.test_cases = strscpy_test_cases,\n};\n\nkunit_test_suite(strscpy_test_suite);\n\nMODULE_AUTHOR(\"Tobin C. Harding <tobin@kernel.org>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}