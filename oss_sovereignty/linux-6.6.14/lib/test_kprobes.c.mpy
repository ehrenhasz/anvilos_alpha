{
  "module_name": "test_kprobes.c",
  "hash_id": "cb175930442e4d3f1b565ee2cfa13e71e964abbda2004b724b736db631d17400",
  "original_prompt": "Ingested from linux-6.6.14/lib/test_kprobes.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/kprobes.h>\n#include <linux/random.h>\n#include <kunit/test.h>\n\n#define div_factor 3\n\nstatic u32 rand1, preh_val, posth_val;\nstatic u32 (*target)(u32 value);\nstatic u32 (*recursed_target)(u32 value);\nstatic u32 (*target2)(u32 value);\nstatic struct kunit *current_test;\n\nstatic unsigned long (*internal_target)(void);\nstatic unsigned long (*stacktrace_target)(void);\nstatic unsigned long (*stacktrace_driver)(void);\nstatic unsigned long target_return_address[2];\n\nstatic noinline u32 kprobe_target(u32 value)\n{\n\treturn (value / div_factor);\n}\n\nstatic noinline u32 kprobe_recursed_target(u32 value)\n{\n\treturn (value / div_factor);\n}\n\nstatic int kp_pre_handler(struct kprobe *p, struct pt_regs *regs)\n{\n\tKUNIT_EXPECT_FALSE(current_test, preemptible());\n\n\tpreh_val = recursed_target(rand1);\n\treturn 0;\n}\n\nstatic void kp_post_handler(struct kprobe *p, struct pt_regs *regs,\n\t\tunsigned long flags)\n{\n\tu32 expval = recursed_target(rand1);\n\n\tKUNIT_EXPECT_FALSE(current_test, preemptible());\n\tKUNIT_EXPECT_EQ(current_test, preh_val, expval);\n\n\tposth_val = preh_val + div_factor;\n}\n\nstatic struct kprobe kp = {\n\t.symbol_name = \"kprobe_target\",\n\t.pre_handler = kp_pre_handler,\n\t.post_handler = kp_post_handler\n};\n\nstatic void test_kprobe(struct kunit *test)\n{\n\tcurrent_test = test;\n\tKUNIT_EXPECT_EQ(test, 0, register_kprobe(&kp));\n\ttarget(rand1);\n\tunregister_kprobe(&kp);\n\tKUNIT_EXPECT_NE(test, 0, preh_val);\n\tKUNIT_EXPECT_NE(test, 0, posth_val);\n}\n\nstatic noinline u32 kprobe_target2(u32 value)\n{\n\treturn (value / div_factor) + 1;\n}\n\nstatic noinline unsigned long kprobe_stacktrace_internal_target(void)\n{\n\tif (!target_return_address[0])\n\t\ttarget_return_address[0] = (unsigned long)__builtin_return_address(0);\n\treturn target_return_address[0];\n}\n\nstatic noinline unsigned long kprobe_stacktrace_target(void)\n{\n\tif (!target_return_address[1])\n\t\ttarget_return_address[1] = (unsigned long)__builtin_return_address(0);\n\n\tif (internal_target)\n\t\tinternal_target();\n\n\treturn target_return_address[1];\n}\n\nstatic noinline unsigned long kprobe_stacktrace_driver(void)\n{\n\tif (stacktrace_target)\n\t\tstacktrace_target();\n\n\t \n\treturn (unsigned long)__builtin_return_address(0);\n}\n\nstatic int kp_pre_handler2(struct kprobe *p, struct pt_regs *regs)\n{\n\tpreh_val = (rand1 / div_factor) + 1;\n\treturn 0;\n}\n\nstatic void kp_post_handler2(struct kprobe *p, struct pt_regs *regs,\n\t\tunsigned long flags)\n{\n\tKUNIT_EXPECT_EQ(current_test, preh_val, (rand1 / div_factor) + 1);\n\tposth_val = preh_val + div_factor;\n}\n\nstatic struct kprobe kp2 = {\n\t.symbol_name = \"kprobe_target2\",\n\t.pre_handler = kp_pre_handler2,\n\t.post_handler = kp_post_handler2\n};\n\nstatic void test_kprobes(struct kunit *test)\n{\n\tstruct kprobe *kps[2] = {&kp, &kp2};\n\n\tcurrent_test = test;\n\n\t \n\tkp.addr = NULL;\n\tkp.flags = 0;\n\n\tKUNIT_EXPECT_EQ(test, 0, register_kprobes(kps, 2));\n\tpreh_val = 0;\n\tposth_val = 0;\n\ttarget(rand1);\n\n\tKUNIT_EXPECT_NE(test, 0, preh_val);\n\tKUNIT_EXPECT_NE(test, 0, posth_val);\n\n\tpreh_val = 0;\n\tposth_val = 0;\n\ttarget2(rand1);\n\n\tKUNIT_EXPECT_NE(test, 0, preh_val);\n\tKUNIT_EXPECT_NE(test, 0, posth_val);\n\tunregister_kprobes(kps, 2);\n}\n\nstatic struct kprobe kp_missed = {\n\t.symbol_name = \"kprobe_recursed_target\",\n\t.pre_handler = kp_pre_handler,\n\t.post_handler = kp_post_handler,\n};\n\nstatic void test_kprobe_missed(struct kunit *test)\n{\n\tcurrent_test = test;\n\tpreh_val = 0;\n\tposth_val = 0;\n\n\tKUNIT_EXPECT_EQ(test, 0, register_kprobe(&kp_missed));\n\n\trecursed_target(rand1);\n\n\tKUNIT_EXPECT_EQ(test, 2, kp_missed.nmissed);\n\tKUNIT_EXPECT_NE(test, 0, preh_val);\n\tKUNIT_EXPECT_NE(test, 0, posth_val);\n\n\tunregister_kprobe(&kp_missed);\n}\n\n#ifdef CONFIG_KRETPROBES\nstatic u32 krph_val;\n\nstatic int entry_handler(struct kretprobe_instance *ri, struct pt_regs *regs)\n{\n\tKUNIT_EXPECT_FALSE(current_test, preemptible());\n\tkrph_val = (rand1 / div_factor);\n\treturn 0;\n}\n\nstatic int return_handler(struct kretprobe_instance *ri, struct pt_regs *regs)\n{\n\tunsigned long ret = regs_return_value(regs);\n\n\tKUNIT_EXPECT_FALSE(current_test, preemptible());\n\tKUNIT_EXPECT_EQ(current_test, ret, rand1 / div_factor);\n\tKUNIT_EXPECT_NE(current_test, krph_val, 0);\n\tkrph_val = rand1;\n\treturn 0;\n}\n\nstatic struct kretprobe rp = {\n\t.handler\t= return_handler,\n\t.entry_handler  = entry_handler,\n\t.kp.symbol_name = \"kprobe_target\"\n};\n\nstatic void test_kretprobe(struct kunit *test)\n{\n\tcurrent_test = test;\n\tKUNIT_EXPECT_EQ(test, 0, register_kretprobe(&rp));\n\ttarget(rand1);\n\tunregister_kretprobe(&rp);\n\tKUNIT_EXPECT_EQ(test, krph_val, rand1);\n}\n\nstatic int return_handler2(struct kretprobe_instance *ri, struct pt_regs *regs)\n{\n\tunsigned long ret = regs_return_value(regs);\n\n\tKUNIT_EXPECT_EQ(current_test, ret, (rand1 / div_factor) + 1);\n\tKUNIT_EXPECT_NE(current_test, krph_val, 0);\n\tkrph_val = rand1;\n\treturn 0;\n}\n\nstatic struct kretprobe rp2 = {\n\t.handler\t= return_handler2,\n\t.entry_handler  = entry_handler,\n\t.kp.symbol_name = \"kprobe_target2\"\n};\n\nstatic void test_kretprobes(struct kunit *test)\n{\n\tstruct kretprobe *rps[2] = {&rp, &rp2};\n\n\tcurrent_test = test;\n\t \n\trp.kp.addr = NULL;\n\trp.kp.flags = 0;\n\tKUNIT_EXPECT_EQ(test, 0, register_kretprobes(rps, 2));\n\n\tkrph_val = 0;\n\ttarget(rand1);\n\tKUNIT_EXPECT_EQ(test, krph_val, rand1);\n\n\tkrph_val = 0;\n\ttarget2(rand1);\n\tKUNIT_EXPECT_EQ(test, krph_val, rand1);\n\tunregister_kretprobes(rps, 2);\n}\n\n#ifdef CONFIG_ARCH_CORRECT_STACKTRACE_ON_KRETPROBE\n#define STACK_BUF_SIZE 16\nstatic unsigned long stack_buf[STACK_BUF_SIZE];\n\nstatic int stacktrace_return_handler(struct kretprobe_instance *ri, struct pt_regs *regs)\n{\n\tunsigned long retval = regs_return_value(regs);\n\tint i, ret;\n\n\tKUNIT_EXPECT_FALSE(current_test, preemptible());\n\tKUNIT_EXPECT_EQ(current_test, retval, target_return_address[1]);\n\n\t \n\tret = stack_trace_save(stack_buf, STACK_BUF_SIZE, 0);\n\tKUNIT_EXPECT_NE(current_test, ret, 0);\n\n\tfor (i = 0; i < ret; i++) {\n\t\tif (stack_buf[i] == target_return_address[1])\n\t\t\tbreak;\n\t}\n\tKUNIT_EXPECT_NE(current_test, i, ret);\n\n#if !IS_MODULE(CONFIG_KPROBES_SANITY_TEST)\n\t \n\tret = stack_trace_save_regs(regs, stack_buf, STACK_BUF_SIZE, 0);\n\tKUNIT_EXPECT_NE(current_test, ret, 0);\n\tKUNIT_EXPECT_EQ(current_test, stack_buf[0], target_return_address[1]);\n#endif\n\n\treturn 0;\n}\n\nstatic struct kretprobe rp3 = {\n\t.handler\t= stacktrace_return_handler,\n\t.kp.symbol_name = \"kprobe_stacktrace_target\"\n};\n\nstatic void test_stacktrace_on_kretprobe(struct kunit *test)\n{\n\tunsigned long myretaddr = (unsigned long)__builtin_return_address(0);\n\n\tcurrent_test = test;\n\trp3.kp.addr = NULL;\n\trp3.kp.flags = 0;\n\n\t \n\tKUNIT_ASSERT_NE(test, myretaddr, stacktrace_driver());\n\n\tKUNIT_ASSERT_EQ(test, 0, register_kretprobe(&rp3));\n\tKUNIT_ASSERT_NE(test, myretaddr, stacktrace_driver());\n\tunregister_kretprobe(&rp3);\n}\n\nstatic int stacktrace_internal_return_handler(struct kretprobe_instance *ri, struct pt_regs *regs)\n{\n\tunsigned long retval = regs_return_value(regs);\n\tint i, ret;\n\n\tKUNIT_EXPECT_FALSE(current_test, preemptible());\n\tKUNIT_EXPECT_EQ(current_test, retval, target_return_address[0]);\n\n\t \n\tret = stack_trace_save(stack_buf, STACK_BUF_SIZE, 0);\n\tKUNIT_EXPECT_NE(current_test, ret, 0);\n\n\tfor (i = 0; i < ret - 1; i++) {\n\t\tif (stack_buf[i] == target_return_address[0]) {\n\t\t\tKUNIT_EXPECT_EQ(current_test, stack_buf[i + 1], target_return_address[1]);\n\t\t\tbreak;\n\t\t}\n\t}\n\tKUNIT_EXPECT_NE(current_test, i, ret);\n\n#if !IS_MODULE(CONFIG_KPROBES_SANITY_TEST)\n\t \n\tret = stack_trace_save_regs(regs, stack_buf, STACK_BUF_SIZE, 0);\n\tKUNIT_EXPECT_NE(current_test, ret, 0);\n\tKUNIT_EXPECT_EQ(current_test, stack_buf[0], target_return_address[0]);\n\tKUNIT_EXPECT_EQ(current_test, stack_buf[1], target_return_address[1]);\n#endif\n\n\treturn 0;\n}\n\nstatic struct kretprobe rp4 = {\n\t.handler\t= stacktrace_internal_return_handler,\n\t.kp.symbol_name = \"kprobe_stacktrace_internal_target\"\n};\n\nstatic void test_stacktrace_on_nested_kretprobe(struct kunit *test)\n{\n\tunsigned long myretaddr = (unsigned long)__builtin_return_address(0);\n\tstruct kretprobe *rps[2] = {&rp3, &rp4};\n\n\tcurrent_test = test;\n\trp3.kp.addr = NULL;\n\trp3.kp.flags = 0;\n\n\t\n\n\tKUNIT_ASSERT_EQ(test, 0, register_kretprobes(rps, 2));\n\tKUNIT_ASSERT_NE(test, myretaddr, stacktrace_driver());\n\tunregister_kretprobes(rps, 2);\n}\n#endif  \n\n#endif  \n\nstatic int kprobes_test_init(struct kunit *test)\n{\n\ttarget = kprobe_target;\n\ttarget2 = kprobe_target2;\n\trecursed_target = kprobe_recursed_target;\n\tstacktrace_target = kprobe_stacktrace_target;\n\tinternal_target = kprobe_stacktrace_internal_target;\n\tstacktrace_driver = kprobe_stacktrace_driver;\n\trand1 = get_random_u32_above(div_factor);\n\treturn 0;\n}\n\nstatic struct kunit_case kprobes_testcases[] = {\n\tKUNIT_CASE(test_kprobe),\n\tKUNIT_CASE(test_kprobes),\n\tKUNIT_CASE(test_kprobe_missed),\n#ifdef CONFIG_KRETPROBES\n\tKUNIT_CASE(test_kretprobe),\n\tKUNIT_CASE(test_kretprobes),\n#ifdef CONFIG_ARCH_CORRECT_STACKTRACE_ON_KRETPROBE\n\tKUNIT_CASE(test_stacktrace_on_kretprobe),\n\tKUNIT_CASE(test_stacktrace_on_nested_kretprobe),\n#endif\n#endif\n\t{}\n};\n\nstatic struct kunit_suite kprobes_test_suite = {\n\t.name = \"kprobes_test\",\n\t.init = kprobes_test_init,\n\t.test_cases = kprobes_testcases,\n};\n\nkunit_test_suites(&kprobes_test_suite);\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}