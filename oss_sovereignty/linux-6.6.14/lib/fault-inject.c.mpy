{
  "module_name": "fault-inject.c",
  "hash_id": "7048bc988ae2cf93da4568a70dec7870873feed7aac7c929555abee65d2e04ba",
  "original_prompt": "Ingested from linux-6.6.14/lib/fault-inject.c",
  "human_readable_source": "\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/random.h>\n#include <linux/sched.h>\n#include <linux/stat.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/interrupt.h>\n#include <linux/stacktrace.h>\n#include <linux/fault-inject.h>\n\n \nint setup_fault_attr(struct fault_attr *attr, char *str)\n{\n\tunsigned long probability;\n\tunsigned long interval;\n\tint times;\n\tint space;\n\n\t \n\tif (sscanf(str, \"%lu,%lu,%d,%d\",\n\t\t\t&interval, &probability, &space, &times) < 4) {\n\t\tprintk(KERN_WARNING\n\t\t\t\"FAULT_INJECTION: failed to parse arguments\\n\");\n\t\treturn 0;\n\t}\n\n\tattr->probability = probability;\n\tattr->interval = interval;\n\tatomic_set(&attr->times, times);\n\tatomic_set(&attr->space, space);\n\n\treturn 1;\n}\nEXPORT_SYMBOL_GPL(setup_fault_attr);\n\nstatic void fail_dump(struct fault_attr *attr)\n{\n\tif (attr->verbose > 0 && __ratelimit(&attr->ratelimit_state)) {\n\t\tprintk(KERN_NOTICE \"FAULT_INJECTION: forcing a failure.\\n\"\n\t\t       \"name %pd, interval %lu, probability %lu, \"\n\t\t       \"space %d, times %d\\n\", attr->dname,\n\t\t       attr->interval, attr->probability,\n\t\t       atomic_read(&attr->space),\n\t\t       atomic_read(&attr->times));\n\t\tif (attr->verbose > 1)\n\t\t\tdump_stack();\n\t}\n}\n\n#define atomic_dec_not_zero(v)\t\tatomic_add_unless((v), -1, 0)\n\nstatic bool fail_task(struct fault_attr *attr, struct task_struct *task)\n{\n\treturn in_task() && task->make_it_fail;\n}\n\n#define MAX_STACK_TRACE_DEPTH 32\n\n#ifdef CONFIG_FAULT_INJECTION_STACKTRACE_FILTER\n\nstatic bool fail_stacktrace(struct fault_attr *attr)\n{\n\tint depth = attr->stacktrace_depth;\n\tunsigned long entries[MAX_STACK_TRACE_DEPTH];\n\tint n, nr_entries;\n\tbool found = (attr->require_start == 0 && attr->require_end == ULONG_MAX);\n\n\tif (depth == 0 || (found && !attr->reject_start && !attr->reject_end))\n\t\treturn found;\n\n\tnr_entries = stack_trace_save(entries, depth, 1);\n\tfor (n = 0; n < nr_entries; n++) {\n\t\tif (attr->reject_start <= entries[n] &&\n\t\t\t       entries[n] < attr->reject_end)\n\t\t\treturn false;\n\t\tif (attr->require_start <= entries[n] &&\n\t\t\t       entries[n] < attr->require_end)\n\t\t\tfound = true;\n\t}\n\treturn found;\n}\n\n#else\n\nstatic inline bool fail_stacktrace(struct fault_attr *attr)\n{\n\treturn true;\n}\n\n#endif  \n\n \n\nbool should_fail_ex(struct fault_attr *attr, ssize_t size, int flags)\n{\n\tbool stack_checked = false;\n\n\tif (in_task()) {\n\t\tunsigned int fail_nth = READ_ONCE(current->fail_nth);\n\n\t\tif (fail_nth) {\n\t\t\tif (!fail_stacktrace(attr))\n\t\t\t\treturn false;\n\n\t\t\tstack_checked = true;\n\t\t\tfail_nth--;\n\t\t\tWRITE_ONCE(current->fail_nth, fail_nth);\n\t\t\tif (!fail_nth)\n\t\t\t\tgoto fail;\n\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t \n\tif (attr->probability == 0)\n\t\treturn false;\n\n\tif (attr->task_filter && !fail_task(attr, current))\n\t\treturn false;\n\n\tif (atomic_read(&attr->times) == 0)\n\t\treturn false;\n\n\tif (!stack_checked && !fail_stacktrace(attr))\n\t\treturn false;\n\n\tif (atomic_read(&attr->space) > size) {\n\t\tatomic_sub(size, &attr->space);\n\t\treturn false;\n\t}\n\n\tif (attr->interval > 1) {\n\t\tattr->count++;\n\t\tif (attr->count % attr->interval)\n\t\t\treturn false;\n\t}\n\n\tif (attr->probability <= get_random_u32_below(100))\n\t\treturn false;\n\nfail:\n\tif (!(flags & FAULT_NOWARN))\n\t\tfail_dump(attr);\n\n\tif (atomic_read(&attr->times) != -1)\n\t\tatomic_dec_not_zero(&attr->times);\n\n\treturn true;\n}\n\nbool should_fail(struct fault_attr *attr, ssize_t size)\n{\n\treturn should_fail_ex(attr, size, 0);\n}\nEXPORT_SYMBOL_GPL(should_fail);\n\n#ifdef CONFIG_FAULT_INJECTION_DEBUG_FS\n\nstatic int debugfs_ul_set(void *data, u64 val)\n{\n\t*(unsigned long *)data = val;\n\treturn 0;\n}\n\nstatic int debugfs_ul_get(void *data, u64 *val)\n{\n\t*val = *(unsigned long *)data;\n\treturn 0;\n}\n\nDEFINE_SIMPLE_ATTRIBUTE(fops_ul, debugfs_ul_get, debugfs_ul_set, \"%llu\\n\");\n\nstatic void debugfs_create_ul(const char *name, umode_t mode,\n\t\t\t      struct dentry *parent, unsigned long *value)\n{\n\tdebugfs_create_file(name, mode, parent, value, &fops_ul);\n}\n\n#ifdef CONFIG_FAULT_INJECTION_STACKTRACE_FILTER\n\nstatic int debugfs_stacktrace_depth_set(void *data, u64 val)\n{\n\t*(unsigned long *)data =\n\t\tmin_t(unsigned long, val, MAX_STACK_TRACE_DEPTH);\n\n\treturn 0;\n}\n\nDEFINE_SIMPLE_ATTRIBUTE(fops_stacktrace_depth, debugfs_ul_get,\n\t\t\tdebugfs_stacktrace_depth_set, \"%llu\\n\");\n\nstatic void debugfs_create_stacktrace_depth(const char *name, umode_t mode,\n\t\t\t\t\t    struct dentry *parent,\n\t\t\t\t\t    unsigned long *value)\n{\n\tdebugfs_create_file(name, mode, parent, value, &fops_stacktrace_depth);\n}\n\n#endif  \n\nstruct dentry *fault_create_debugfs_attr(const char *name,\n\t\t\tstruct dentry *parent, struct fault_attr *attr)\n{\n\tumode_t mode = S_IFREG | S_IRUSR | S_IWUSR;\n\tstruct dentry *dir;\n\n\tdir = debugfs_create_dir(name, parent);\n\tif (IS_ERR(dir))\n\t\treturn dir;\n\n\tdebugfs_create_ul(\"probability\", mode, dir, &attr->probability);\n\tdebugfs_create_ul(\"interval\", mode, dir, &attr->interval);\n\tdebugfs_create_atomic_t(\"times\", mode, dir, &attr->times);\n\tdebugfs_create_atomic_t(\"space\", mode, dir, &attr->space);\n\tdebugfs_create_ul(\"verbose\", mode, dir, &attr->verbose);\n\tdebugfs_create_u32(\"verbose_ratelimit_interval_ms\", mode, dir,\n\t\t\t   &attr->ratelimit_state.interval);\n\tdebugfs_create_u32(\"verbose_ratelimit_burst\", mode, dir,\n\t\t\t   &attr->ratelimit_state.burst);\n\tdebugfs_create_bool(\"task-filter\", mode, dir, &attr->task_filter);\n\n#ifdef CONFIG_FAULT_INJECTION_STACKTRACE_FILTER\n\tdebugfs_create_stacktrace_depth(\"stacktrace-depth\", mode, dir,\n\t\t\t\t\t&attr->stacktrace_depth);\n\tdebugfs_create_xul(\"require-start\", mode, dir, &attr->require_start);\n\tdebugfs_create_xul(\"require-end\", mode, dir, &attr->require_end);\n\tdebugfs_create_xul(\"reject-start\", mode, dir, &attr->reject_start);\n\tdebugfs_create_xul(\"reject-end\", mode, dir, &attr->reject_end);\n#endif  \n\n\tattr->dname = dget(dir);\n\treturn dir;\n}\nEXPORT_SYMBOL_GPL(fault_create_debugfs_attr);\n\n#endif  \n\n#ifdef CONFIG_FAULT_INJECTION_CONFIGFS\n\n \n\nstatic ssize_t fault_uint_attr_show(unsigned int val, char *page)\n{\n\treturn snprintf(page, PAGE_SIZE, \"%u\\n\", val);\n}\n\nstatic ssize_t fault_ulong_attr_show(unsigned long val, char *page)\n{\n\treturn snprintf(page, PAGE_SIZE, \"%lu\\n\", val);\n}\n\nstatic ssize_t fault_bool_attr_show(bool val, char *page)\n{\n\treturn snprintf(page, PAGE_SIZE, \"%u\\n\", val);\n}\n\nstatic ssize_t fault_atomic_t_attr_show(atomic_t val, char *page)\n{\n\treturn snprintf(page, PAGE_SIZE, \"%d\\n\", atomic_read(&val));\n}\n\nstatic ssize_t fault_uint_attr_store(unsigned int *val, const char *page, size_t count)\n{\n\tunsigned int tmp;\n\tint result;\n\n\tresult = kstrtouint(page, 0, &tmp);\n\tif (result < 0)\n\t\treturn result;\n\n\t*val = tmp;\n\treturn count;\n}\n\nstatic ssize_t fault_ulong_attr_store(unsigned long *val, const char *page, size_t count)\n{\n\tint result;\n\tunsigned long tmp;\n\n\tresult = kstrtoul(page, 0, &tmp);\n\tif (result < 0)\n\t\treturn result;\n\n\t*val = tmp;\n\treturn count;\n}\n\nstatic ssize_t fault_bool_attr_store(bool *val, const char *page, size_t count)\n{\n\tbool tmp;\n\tint result;\n\n\tresult = kstrtobool(page, &tmp);\n\tif (result < 0)\n\t\treturn result;\n\n\t*val = tmp;\n\treturn count;\n}\n\nstatic ssize_t fault_atomic_t_attr_store(atomic_t *val, const char *page, size_t count)\n{\n\tint tmp;\n\tint result;\n\n\tresult = kstrtoint(page, 0, &tmp);\n\tif (result < 0)\n\t\treturn result;\n\n\tatomic_set(val, tmp);\n\treturn count;\n}\n\n#define CONFIGFS_ATTR_NAMED(_pfx, _name, _attr_name)\t\\\nstatic struct configfs_attribute _pfx##attr_##_name = {\t\\\n\t.ca_name\t= _attr_name,\t\t\t\\\n\t.ca_mode\t= 0644,\t\t\t\t\\\n\t.ca_owner\t= THIS_MODULE,\t\t\t\\\n\t.show\t\t= _pfx##_name##_show,\t\t\\\n\t.store\t\t= _pfx##_name##_store,\t\t\\\n}\n\nstatic struct fault_config *to_fault_config(struct config_item *item)\n{\n\treturn container_of(to_config_group(item), struct fault_config, group);\n}\n\n#define FAULT_CONFIGFS_ATTR_NAMED(NAME, ATTR_NAME, MEMBER, TYPE)\t\t\t\t\\\nstatic ssize_t fault_##NAME##_show(struct config_item *item, char *page)\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\t\t\t\\\n\treturn fault_##TYPE##_attr_show(to_fault_config(item)->attr.MEMBER, page);\t\t\\\n}\t\t\t\t\t\t\t\t\t\t\t\t\\\nstatic ssize_t fault_##NAME##_store(struct config_item *item, const char *page, size_t count)\t\\\n{\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tstruct fault_config *config = to_fault_config(item);\t\t\t\t\t\\\n\treturn fault_##TYPE##_attr_store(&config->attr.MEMBER, page, count);\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\t\t\t\\\nCONFIGFS_ATTR_NAMED(fault_, NAME, ATTR_NAME)\n\n#define FAULT_CONFIGFS_ATTR(NAME, TYPE)\t\\\n\tFAULT_CONFIGFS_ATTR_NAMED(NAME, __stringify(NAME), NAME, TYPE)\n\nFAULT_CONFIGFS_ATTR(probability, ulong);\nFAULT_CONFIGFS_ATTR(interval, ulong);\nFAULT_CONFIGFS_ATTR(times, atomic_t);\nFAULT_CONFIGFS_ATTR(space, atomic_t);\nFAULT_CONFIGFS_ATTR(verbose, ulong);\nFAULT_CONFIGFS_ATTR_NAMED(ratelimit_interval, \"verbose_ratelimit_interval_ms\",\n\t\tratelimit_state.interval, uint);\nFAULT_CONFIGFS_ATTR_NAMED(ratelimit_burst, \"verbose_ratelimit_burst\",\n\t\tratelimit_state.burst, uint);\nFAULT_CONFIGFS_ATTR_NAMED(task_filter, \"task-filter\", task_filter, bool);\n\n#ifdef CONFIG_FAULT_INJECTION_STACKTRACE_FILTER\n\nstatic ssize_t fault_stacktrace_depth_show(struct config_item *item, char *page)\n{\n\treturn fault_ulong_attr_show(to_fault_config(item)->attr.stacktrace_depth, page);\n}\n\nstatic ssize_t fault_stacktrace_depth_store(struct config_item *item, const char *page,\n\t\tsize_t count)\n{\n\tint result;\n\tunsigned long tmp;\n\n\tresult = kstrtoul(page, 0, &tmp);\n\tif (result < 0)\n\t\treturn result;\n\n\tto_fault_config(item)->attr.stacktrace_depth =\n\t\tmin_t(unsigned long, tmp, MAX_STACK_TRACE_DEPTH);\n\n\treturn count;\n}\n\nCONFIGFS_ATTR_NAMED(fault_, stacktrace_depth, \"stacktrace-depth\");\n\nstatic ssize_t fault_xul_attr_show(unsigned long val, char *page)\n{\n\treturn snprintf(page, PAGE_SIZE,\n\t\t\tsizeof(val) == sizeof(u32) ? \"0x%08lx\\n\" : \"0x%016lx\\n\", val);\n}\n\nstatic ssize_t fault_xul_attr_store(unsigned long *val, const char *page, size_t count)\n{\n\treturn fault_ulong_attr_store(val, page, count);\n}\n\nFAULT_CONFIGFS_ATTR_NAMED(require_start, \"require-start\", require_start, xul);\nFAULT_CONFIGFS_ATTR_NAMED(require_end, \"require-end\", require_end, xul);\nFAULT_CONFIGFS_ATTR_NAMED(reject_start, \"reject-start\", reject_start, xul);\nFAULT_CONFIGFS_ATTR_NAMED(reject_end, \"reject-end\", reject_end, xul);\n\n#endif  \n\nstatic struct configfs_attribute *fault_config_attrs[] = {\n\t&fault_attr_probability,\n\t&fault_attr_interval,\n\t&fault_attr_times,\n\t&fault_attr_space,\n\t&fault_attr_verbose,\n\t&fault_attr_ratelimit_interval,\n\t&fault_attr_ratelimit_burst,\n\t&fault_attr_task_filter,\n#ifdef CONFIG_FAULT_INJECTION_STACKTRACE_FILTER\n\t&fault_attr_stacktrace_depth,\n\t&fault_attr_require_start,\n\t&fault_attr_require_end,\n\t&fault_attr_reject_start,\n\t&fault_attr_reject_end,\n#endif  \n\tNULL,\n};\n\nstatic const struct config_item_type fault_config_type = {\n\t.ct_attrs\t= fault_config_attrs,\n\t.ct_owner\t= THIS_MODULE,\n};\n\nvoid fault_config_init(struct fault_config *config, const char *name)\n{\n\tconfig_group_init_type_name(&config->group, name, &fault_config_type);\n}\nEXPORT_SYMBOL_GPL(fault_config_init);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}