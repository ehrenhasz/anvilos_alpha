{
  "module_name": "list-test.c",
  "hash_id": "1821db14ebd87d32e40dc58a0b3b418e4014f95865012faf2270268d85d91a6d",
  "original_prompt": "Ingested from linux-6.6.14/lib/list-test.c",
  "human_readable_source": "\n \n#include <kunit/test.h>\n\n#include <linux/list.h>\n#include <linux/klist.h>\n\nstruct list_test_struct {\n\tint data;\n\tstruct list_head list;\n};\n\nstatic void list_test_list_init(struct kunit *test)\n{\n\t \n\tstruct list_head list1 = LIST_HEAD_INIT(list1);\n\tstruct list_head list2;\n\tLIST_HEAD(list3);\n\tstruct list_head *list4;\n\tstruct list_head *list5;\n\n\tINIT_LIST_HEAD(&list2);\n\n\tlist4 = kzalloc(sizeof(*list4), GFP_KERNEL | __GFP_NOFAIL);\n\tINIT_LIST_HEAD(list4);\n\n\tlist5 = kmalloc(sizeof(*list5), GFP_KERNEL | __GFP_NOFAIL);\n\tmemset(list5, 0xFF, sizeof(*list5));\n\tINIT_LIST_HEAD(list5);\n\n\t \n\tKUNIT_EXPECT_TRUE(test, list_empty_careful(&list1));\n\tKUNIT_EXPECT_TRUE(test, list_empty_careful(&list2));\n\tKUNIT_EXPECT_TRUE(test, list_empty_careful(&list3));\n\tKUNIT_EXPECT_TRUE(test, list_empty_careful(list4));\n\tKUNIT_EXPECT_TRUE(test, list_empty_careful(list5));\n\n\tkfree(list4);\n\tkfree(list5);\n}\n\nstatic void list_test_list_add(struct kunit *test)\n{\n\tstruct list_head a, b;\n\tLIST_HEAD(list);\n\n\tlist_add(&a, &list);\n\tlist_add(&b, &list);\n\n\t \n\tKUNIT_EXPECT_PTR_EQ(test, list.next, &b);\n\tKUNIT_EXPECT_PTR_EQ(test, b.prev, &list);\n\tKUNIT_EXPECT_PTR_EQ(test, b.next, &a);\n}\n\nstatic void list_test_list_add_tail(struct kunit *test)\n{\n\tstruct list_head a, b;\n\tLIST_HEAD(list);\n\n\tlist_add_tail(&a, &list);\n\tlist_add_tail(&b, &list);\n\n\t \n\tKUNIT_EXPECT_PTR_EQ(test, list.next, &a);\n\tKUNIT_EXPECT_PTR_EQ(test, a.prev, &list);\n\tKUNIT_EXPECT_PTR_EQ(test, a.next, &b);\n}\n\nstatic void list_test_list_del(struct kunit *test)\n{\n\tstruct list_head a, b;\n\tLIST_HEAD(list);\n\n\tlist_add_tail(&a, &list);\n\tlist_add_tail(&b, &list);\n\n\t \n\tlist_del(&a);\n\n\t \n\tKUNIT_EXPECT_PTR_EQ(test, list.next, &b);\n\tKUNIT_EXPECT_PTR_EQ(test, b.prev, &list);\n}\n\nstatic void list_test_list_replace(struct kunit *test)\n{\n\tstruct list_head a_old, a_new, b;\n\tLIST_HEAD(list);\n\n\tlist_add_tail(&a_old, &list);\n\tlist_add_tail(&b, &list);\n\n\t \n\tlist_replace(&a_old, &a_new);\n\n\t \n\tKUNIT_EXPECT_PTR_EQ(test, list.next, &a_new);\n\tKUNIT_EXPECT_PTR_EQ(test, b.prev, &a_new);\n}\n\nstatic void list_test_list_replace_init(struct kunit *test)\n{\n\tstruct list_head a_old, a_new, b;\n\tLIST_HEAD(list);\n\n\tlist_add_tail(&a_old, &list);\n\tlist_add_tail(&b, &list);\n\n\t \n\tlist_replace_init(&a_old, &a_new);\n\n\t \n\tKUNIT_EXPECT_PTR_EQ(test, list.next, &a_new);\n\tKUNIT_EXPECT_PTR_EQ(test, b.prev, &a_new);\n\n\t \n\tKUNIT_EXPECT_TRUE(test, list_empty_careful(&a_old));\n}\n\nstatic void list_test_list_swap(struct kunit *test)\n{\n\tstruct list_head a, b;\n\tLIST_HEAD(list);\n\n\tlist_add_tail(&a, &list);\n\tlist_add_tail(&b, &list);\n\n\t \n\tlist_swap(&a, &b);\n\n\t \n\tKUNIT_EXPECT_PTR_EQ(test, &b, list.next);\n\tKUNIT_EXPECT_PTR_EQ(test, &a, list.prev);\n\n\tKUNIT_EXPECT_PTR_EQ(test, &a, b.next);\n\tKUNIT_EXPECT_PTR_EQ(test, &list, b.prev);\n\n\tKUNIT_EXPECT_PTR_EQ(test, &list, a.next);\n\tKUNIT_EXPECT_PTR_EQ(test, &b, a.prev);\n}\n\nstatic void list_test_list_del_init(struct kunit *test)\n{\n\tstruct list_head a, b;\n\tLIST_HEAD(list);\n\n\tlist_add_tail(&a, &list);\n\tlist_add_tail(&b, &list);\n\n\t \n\tlist_del_init(&a);\n\t \n\n\tKUNIT_EXPECT_PTR_EQ(test, list.next, &b);\n\tKUNIT_EXPECT_PTR_EQ(test, b.prev, &list);\n\tKUNIT_EXPECT_TRUE(test, list_empty_careful(&a));\n}\n\nstatic void list_test_list_del_init_careful(struct kunit *test)\n{\n\t \n\tstruct list_head a, b;\n\tLIST_HEAD(list);\n\n\tlist_add_tail(&a, &list);\n\tlist_add_tail(&b, &list);\n\n\t \n\tlist_del_init_careful(&a);\n\t \n\n\tKUNIT_EXPECT_PTR_EQ(test, list.next, &b);\n\tKUNIT_EXPECT_PTR_EQ(test, b.prev, &list);\n\tKUNIT_EXPECT_TRUE(test, list_empty_careful(&a));\n}\n\nstatic void list_test_list_move(struct kunit *test)\n{\n\tstruct list_head a, b;\n\tLIST_HEAD(list1);\n\tLIST_HEAD(list2);\n\n\tlist_add_tail(&a, &list1);\n\tlist_add_tail(&b, &list2);\n\n\t \n\tlist_move(&a, &list2);\n\t \n\n\tKUNIT_EXPECT_TRUE(test, list_empty(&list1));\n\n\tKUNIT_EXPECT_PTR_EQ(test, &a, list2.next);\n\tKUNIT_EXPECT_PTR_EQ(test, &b, a.next);\n}\n\nstatic void list_test_list_move_tail(struct kunit *test)\n{\n\tstruct list_head a, b;\n\tLIST_HEAD(list1);\n\tLIST_HEAD(list2);\n\n\tlist_add_tail(&a, &list1);\n\tlist_add_tail(&b, &list2);\n\n\t \n\tlist_move_tail(&a, &list2);\n\t \n\n\tKUNIT_EXPECT_TRUE(test, list_empty(&list1));\n\n\tKUNIT_EXPECT_PTR_EQ(test, &b, list2.next);\n\tKUNIT_EXPECT_PTR_EQ(test, &a, b.next);\n}\n\nstatic void list_test_list_bulk_move_tail(struct kunit *test)\n{\n\tstruct list_head a, b, c, d, x, y;\n\tstruct list_head *list1_values[] = { &x, &b, &c, &y };\n\tstruct list_head *list2_values[] = { &a, &d };\n\tstruct list_head *ptr;\n\tLIST_HEAD(list1);\n\tLIST_HEAD(list2);\n\tint i = 0;\n\n\tlist_add_tail(&x, &list1);\n\tlist_add_tail(&y, &list1);\n\n\tlist_add_tail(&a, &list2);\n\tlist_add_tail(&b, &list2);\n\tlist_add_tail(&c, &list2);\n\tlist_add_tail(&d, &list2);\n\n\t \n\tlist_bulk_move_tail(&y, &b, &c);\n\t \n\n\tlist_for_each(ptr, &list1) {\n\t\tKUNIT_EXPECT_PTR_EQ(test, ptr, list1_values[i]);\n\t\ti++;\n\t}\n\tKUNIT_EXPECT_EQ(test, i, 4);\n\ti = 0;\n\tlist_for_each(ptr, &list2) {\n\t\tKUNIT_EXPECT_PTR_EQ(test, ptr, list2_values[i]);\n\t\ti++;\n\t}\n\tKUNIT_EXPECT_EQ(test, i, 2);\n}\n\nstatic void list_test_list_is_head(struct kunit *test)\n{\n\tstruct list_head a, b, c;\n\n\t \n\tINIT_LIST_HEAD(&a);\n\tINIT_LIST_HEAD(&c);\n\tlist_add_tail(&b, &a);\n\n\tKUNIT_EXPECT_TRUE_MSG(test, list_is_head(&a, &a),\n\t\t\"Head element of same list\");\n\tKUNIT_EXPECT_FALSE_MSG(test, list_is_head(&a, &b),\n\t\t\"Non-head element of same list\");\n\tKUNIT_EXPECT_FALSE_MSG(test, list_is_head(&a, &c),\n\t\t\"Head element of different list\");\n}\n\n\nstatic void list_test_list_is_first(struct kunit *test)\n{\n\tstruct list_head a, b;\n\tLIST_HEAD(list);\n\n\tlist_add_tail(&a, &list);\n\tlist_add_tail(&b, &list);\n\n\tKUNIT_EXPECT_TRUE(test, list_is_first(&a, &list));\n\tKUNIT_EXPECT_FALSE(test, list_is_first(&b, &list));\n}\n\nstatic void list_test_list_is_last(struct kunit *test)\n{\n\tstruct list_head a, b;\n\tLIST_HEAD(list);\n\n\tlist_add_tail(&a, &list);\n\tlist_add_tail(&b, &list);\n\n\tKUNIT_EXPECT_FALSE(test, list_is_last(&a, &list));\n\tKUNIT_EXPECT_TRUE(test, list_is_last(&b, &list));\n}\n\nstatic void list_test_list_empty(struct kunit *test)\n{\n\tstruct list_head a;\n\tLIST_HEAD(list1);\n\tLIST_HEAD(list2);\n\n\tlist_add_tail(&a, &list1);\n\n\tKUNIT_EXPECT_FALSE(test, list_empty(&list1));\n\tKUNIT_EXPECT_TRUE(test, list_empty(&list2));\n}\n\nstatic void list_test_list_empty_careful(struct kunit *test)\n{\n\t \n\tstruct list_head a;\n\tLIST_HEAD(list1);\n\tLIST_HEAD(list2);\n\n\tlist_add_tail(&a, &list1);\n\n\tKUNIT_EXPECT_FALSE(test, list_empty_careful(&list1));\n\tKUNIT_EXPECT_TRUE(test, list_empty_careful(&list2));\n}\n\nstatic void list_test_list_rotate_left(struct kunit *test)\n{\n\tstruct list_head a, b;\n\tLIST_HEAD(list);\n\n\tlist_add_tail(&a, &list);\n\tlist_add_tail(&b, &list);\n\n\t \n\tlist_rotate_left(&list);\n\t \n\n\tKUNIT_EXPECT_PTR_EQ(test, list.next, &b);\n\tKUNIT_EXPECT_PTR_EQ(test, b.prev, &list);\n\tKUNIT_EXPECT_PTR_EQ(test, b.next, &a);\n}\n\nstatic void list_test_list_rotate_to_front(struct kunit *test)\n{\n\tstruct list_head a, b, c, d;\n\tstruct list_head *list_values[] = { &c, &d, &a, &b };\n\tstruct list_head *ptr;\n\tLIST_HEAD(list);\n\tint i = 0;\n\n\tlist_add_tail(&a, &list);\n\tlist_add_tail(&b, &list);\n\tlist_add_tail(&c, &list);\n\tlist_add_tail(&d, &list);\n\n\t \n\tlist_rotate_to_front(&c, &list);\n\t \n\n\tlist_for_each(ptr, &list) {\n\t\tKUNIT_EXPECT_PTR_EQ(test, ptr, list_values[i]);\n\t\ti++;\n\t}\n\tKUNIT_EXPECT_EQ(test, i, 4);\n}\n\nstatic void list_test_list_is_singular(struct kunit *test)\n{\n\tstruct list_head a, b;\n\tLIST_HEAD(list);\n\n\t \n\tKUNIT_EXPECT_FALSE(test, list_is_singular(&list));\n\n\tlist_add_tail(&a, &list);\n\n\t \n\tKUNIT_EXPECT_TRUE(test, list_is_singular(&list));\n\n\tlist_add_tail(&b, &list);\n\n\t \n\tKUNIT_EXPECT_FALSE(test, list_is_singular(&list));\n}\n\nstatic void list_test_list_cut_position(struct kunit *test)\n{\n\tstruct list_head entries[3], *cur;\n\tLIST_HEAD(list1);\n\tLIST_HEAD(list2);\n\tint i = 0;\n\n\tlist_add_tail(&entries[0], &list1);\n\tlist_add_tail(&entries[1], &list1);\n\tlist_add_tail(&entries[2], &list1);\n\n\t \n\tlist_cut_position(&list2, &list1, &entries[1]);\n\t \n\n\tlist_for_each(cur, &list2) {\n\t\tKUNIT_EXPECT_PTR_EQ(test, cur, &entries[i]);\n\t\ti++;\n\t}\n\n\tKUNIT_EXPECT_EQ(test, i, 2);\n\n\tlist_for_each(cur, &list1) {\n\t\tKUNIT_EXPECT_PTR_EQ(test, cur, &entries[i]);\n\t\ti++;\n\t}\n}\n\nstatic void list_test_list_cut_before(struct kunit *test)\n{\n\tstruct list_head entries[3], *cur;\n\tLIST_HEAD(list1);\n\tLIST_HEAD(list2);\n\tint i = 0;\n\n\tlist_add_tail(&entries[0], &list1);\n\tlist_add_tail(&entries[1], &list1);\n\tlist_add_tail(&entries[2], &list1);\n\n\t \n\tlist_cut_before(&list2, &list1, &entries[1]);\n\t \n\n\tlist_for_each(cur, &list2) {\n\t\tKUNIT_EXPECT_PTR_EQ(test, cur, &entries[i]);\n\t\ti++;\n\t}\n\n\tKUNIT_EXPECT_EQ(test, i, 1);\n\n\tlist_for_each(cur, &list1) {\n\t\tKUNIT_EXPECT_PTR_EQ(test, cur, &entries[i]);\n\t\ti++;\n\t}\n}\n\nstatic void list_test_list_splice(struct kunit *test)\n{\n\tstruct list_head entries[5], *cur;\n\tLIST_HEAD(list1);\n\tLIST_HEAD(list2);\n\tint i = 0;\n\n\tlist_add_tail(&entries[0], &list1);\n\tlist_add_tail(&entries[1], &list1);\n\tlist_add_tail(&entries[2], &list2);\n\tlist_add_tail(&entries[3], &list2);\n\tlist_add_tail(&entries[4], &list1);\n\n\t \n\tlist_splice(&list2, &entries[1]);\n\t \n\n\tlist_for_each(cur, &list1) {\n\t\tKUNIT_EXPECT_PTR_EQ(test, cur, &entries[i]);\n\t\ti++;\n\t}\n\n\tKUNIT_EXPECT_EQ(test, i, 5);\n}\n\nstatic void list_test_list_splice_tail(struct kunit *test)\n{\n\tstruct list_head entries[5], *cur;\n\tLIST_HEAD(list1);\n\tLIST_HEAD(list2);\n\tint i = 0;\n\n\tlist_add_tail(&entries[0], &list1);\n\tlist_add_tail(&entries[1], &list1);\n\tlist_add_tail(&entries[2], &list2);\n\tlist_add_tail(&entries[3], &list2);\n\tlist_add_tail(&entries[4], &list1);\n\n\t \n\tlist_splice_tail(&list2, &entries[4]);\n\t \n\n\tlist_for_each(cur, &list1) {\n\t\tKUNIT_EXPECT_PTR_EQ(test, cur, &entries[i]);\n\t\ti++;\n\t}\n\n\tKUNIT_EXPECT_EQ(test, i, 5);\n}\n\nstatic void list_test_list_splice_init(struct kunit *test)\n{\n\tstruct list_head entries[5], *cur;\n\tLIST_HEAD(list1);\n\tLIST_HEAD(list2);\n\tint i = 0;\n\n\tlist_add_tail(&entries[0], &list1);\n\tlist_add_tail(&entries[1], &list1);\n\tlist_add_tail(&entries[2], &list2);\n\tlist_add_tail(&entries[3], &list2);\n\tlist_add_tail(&entries[4], &list1);\n\n\t \n\tlist_splice_init(&list2, &entries[1]);\n\t \n\n\tlist_for_each(cur, &list1) {\n\t\tKUNIT_EXPECT_PTR_EQ(test, cur, &entries[i]);\n\t\ti++;\n\t}\n\n\tKUNIT_EXPECT_EQ(test, i, 5);\n\n\tKUNIT_EXPECT_TRUE(test, list_empty_careful(&list2));\n}\n\nstatic void list_test_list_splice_tail_init(struct kunit *test)\n{\n\tstruct list_head entries[5], *cur;\n\tLIST_HEAD(list1);\n\tLIST_HEAD(list2);\n\tint i = 0;\n\n\tlist_add_tail(&entries[0], &list1);\n\tlist_add_tail(&entries[1], &list1);\n\tlist_add_tail(&entries[2], &list2);\n\tlist_add_tail(&entries[3], &list2);\n\tlist_add_tail(&entries[4], &list1);\n\n\t \n\tlist_splice_tail_init(&list2, &entries[4]);\n\t \n\n\tlist_for_each(cur, &list1) {\n\t\tKUNIT_EXPECT_PTR_EQ(test, cur, &entries[i]);\n\t\ti++;\n\t}\n\n\tKUNIT_EXPECT_EQ(test, i, 5);\n\n\tKUNIT_EXPECT_TRUE(test, list_empty_careful(&list2));\n}\n\nstatic void list_test_list_entry(struct kunit *test)\n{\n\tstruct list_test_struct test_struct;\n\n\tKUNIT_EXPECT_PTR_EQ(test, &test_struct, list_entry(&(test_struct.list),\n\t\t\t\tstruct list_test_struct, list));\n}\n\nstatic void list_test_list_entry_is_head(struct kunit *test)\n{\n\tstruct list_test_struct test_struct1, test_struct2, test_struct3;\n\n\tINIT_LIST_HEAD(&test_struct1.list);\n\tINIT_LIST_HEAD(&test_struct3.list);\n\n\tlist_add_tail(&test_struct2.list, &test_struct1.list);\n\n\tKUNIT_EXPECT_TRUE_MSG(test,\n\t\tlist_entry_is_head((&test_struct1), &test_struct1.list, list),\n\t\t\"Head element of same list\");\n\tKUNIT_EXPECT_FALSE_MSG(test,\n\t\tlist_entry_is_head((&test_struct2), &test_struct1.list, list),\n\t\t\"Non-head element of same list\");\n\tKUNIT_EXPECT_FALSE_MSG(test,\n\t\tlist_entry_is_head((&test_struct3), &test_struct1.list, list),\n\t\t\"Head element of different list\");\n}\n\nstatic void list_test_list_first_entry(struct kunit *test)\n{\n\tstruct list_test_struct test_struct1, test_struct2;\n\tLIST_HEAD(list);\n\n\tlist_add_tail(&test_struct1.list, &list);\n\tlist_add_tail(&test_struct2.list, &list);\n\n\n\tKUNIT_EXPECT_PTR_EQ(test, &test_struct1, list_first_entry(&list,\n\t\t\t\tstruct list_test_struct, list));\n}\n\nstatic void list_test_list_last_entry(struct kunit *test)\n{\n\tstruct list_test_struct test_struct1, test_struct2;\n\tLIST_HEAD(list);\n\n\tlist_add_tail(&test_struct1.list, &list);\n\tlist_add_tail(&test_struct2.list, &list);\n\n\n\tKUNIT_EXPECT_PTR_EQ(test, &test_struct2, list_last_entry(&list,\n\t\t\t\tstruct list_test_struct, list));\n}\n\nstatic void list_test_list_first_entry_or_null(struct kunit *test)\n{\n\tstruct list_test_struct test_struct1, test_struct2;\n\tLIST_HEAD(list);\n\n\tKUNIT_EXPECT_FALSE(test, list_first_entry_or_null(&list,\n\t\t\t\tstruct list_test_struct, list));\n\n\tlist_add_tail(&test_struct1.list, &list);\n\tlist_add_tail(&test_struct2.list, &list);\n\n\tKUNIT_EXPECT_PTR_EQ(test, &test_struct1,\n\t\t\tlist_first_entry_or_null(&list,\n\t\t\t\tstruct list_test_struct, list));\n}\n\nstatic void list_test_list_next_entry(struct kunit *test)\n{\n\tstruct list_test_struct test_struct1, test_struct2;\n\tLIST_HEAD(list);\n\n\tlist_add_tail(&test_struct1.list, &list);\n\tlist_add_tail(&test_struct2.list, &list);\n\n\n\tKUNIT_EXPECT_PTR_EQ(test, &test_struct2, list_next_entry(&test_struct1,\n\t\t\t\tlist));\n}\n\nstatic void list_test_list_prev_entry(struct kunit *test)\n{\n\tstruct list_test_struct test_struct1, test_struct2;\n\tLIST_HEAD(list);\n\n\tlist_add_tail(&test_struct1.list, &list);\n\tlist_add_tail(&test_struct2.list, &list);\n\n\n\tKUNIT_EXPECT_PTR_EQ(test, &test_struct1, list_prev_entry(&test_struct2,\n\t\t\t\tlist));\n}\n\nstatic void list_test_list_for_each(struct kunit *test)\n{\n\tstruct list_head entries[3], *cur;\n\tLIST_HEAD(list);\n\tint i = 0;\n\n\tlist_add_tail(&entries[0], &list);\n\tlist_add_tail(&entries[1], &list);\n\tlist_add_tail(&entries[2], &list);\n\n\tlist_for_each(cur, &list) {\n\t\tKUNIT_EXPECT_PTR_EQ(test, cur, &entries[i]);\n\t\ti++;\n\t}\n\n\tKUNIT_EXPECT_EQ(test, i, 3);\n}\n\nstatic void list_test_list_for_each_prev(struct kunit *test)\n{\n\tstruct list_head entries[3], *cur;\n\tLIST_HEAD(list);\n\tint i = 2;\n\n\tlist_add_tail(&entries[0], &list);\n\tlist_add_tail(&entries[1], &list);\n\tlist_add_tail(&entries[2], &list);\n\n\tlist_for_each_prev(cur, &list) {\n\t\tKUNIT_EXPECT_PTR_EQ(test, cur, &entries[i]);\n\t\ti--;\n\t}\n\n\tKUNIT_EXPECT_EQ(test, i, -1);\n}\n\nstatic void list_test_list_for_each_safe(struct kunit *test)\n{\n\tstruct list_head entries[3], *cur, *n;\n\tLIST_HEAD(list);\n\tint i = 0;\n\n\n\tlist_add_tail(&entries[0], &list);\n\tlist_add_tail(&entries[1], &list);\n\tlist_add_tail(&entries[2], &list);\n\n\tlist_for_each_safe(cur, n, &list) {\n\t\tKUNIT_EXPECT_PTR_EQ(test, cur, &entries[i]);\n\t\tlist_del(&entries[i]);\n\t\ti++;\n\t}\n\n\tKUNIT_EXPECT_EQ(test, i, 3);\n\tKUNIT_EXPECT_TRUE(test, list_empty(&list));\n}\n\nstatic void list_test_list_for_each_prev_safe(struct kunit *test)\n{\n\tstruct list_head entries[3], *cur, *n;\n\tLIST_HEAD(list);\n\tint i = 2;\n\n\tlist_add_tail(&entries[0], &list);\n\tlist_add_tail(&entries[1], &list);\n\tlist_add_tail(&entries[2], &list);\n\n\tlist_for_each_prev_safe(cur, n, &list) {\n\t\tKUNIT_EXPECT_PTR_EQ(test, cur, &entries[i]);\n\t\tlist_del(&entries[i]);\n\t\ti--;\n\t}\n\n\tKUNIT_EXPECT_EQ(test, i, -1);\n\tKUNIT_EXPECT_TRUE(test, list_empty(&list));\n}\n\nstatic void list_test_list_for_each_entry(struct kunit *test)\n{\n\tstruct list_test_struct entries[5], *cur;\n\tLIST_HEAD(list);\n\tint i = 0;\n\n\tfor (i = 0; i < 5; ++i) {\n\t\tentries[i].data = i;\n\t\tlist_add_tail(&entries[i].list, &list);\n\t}\n\n\ti = 0;\n\n\tlist_for_each_entry(cur, &list, list) {\n\t\tKUNIT_EXPECT_EQ(test, cur->data, i);\n\t\ti++;\n\t}\n\n\tKUNIT_EXPECT_EQ(test, i, 5);\n}\n\nstatic void list_test_list_for_each_entry_reverse(struct kunit *test)\n{\n\tstruct list_test_struct entries[5], *cur;\n\tLIST_HEAD(list);\n\tint i = 0;\n\n\tfor (i = 0; i < 5; ++i) {\n\t\tentries[i].data = i;\n\t\tlist_add_tail(&entries[i].list, &list);\n\t}\n\n\ti = 4;\n\n\tlist_for_each_entry_reverse(cur, &list, list) {\n\t\tKUNIT_EXPECT_EQ(test, cur->data, i);\n\t\ti--;\n\t}\n\n\tKUNIT_EXPECT_EQ(test, i, -1);\n}\n\nstatic struct kunit_case list_test_cases[] = {\n\tKUNIT_CASE(list_test_list_init),\n\tKUNIT_CASE(list_test_list_add),\n\tKUNIT_CASE(list_test_list_add_tail),\n\tKUNIT_CASE(list_test_list_del),\n\tKUNIT_CASE(list_test_list_replace),\n\tKUNIT_CASE(list_test_list_replace_init),\n\tKUNIT_CASE(list_test_list_swap),\n\tKUNIT_CASE(list_test_list_del_init),\n\tKUNIT_CASE(list_test_list_del_init_careful),\n\tKUNIT_CASE(list_test_list_move),\n\tKUNIT_CASE(list_test_list_move_tail),\n\tKUNIT_CASE(list_test_list_bulk_move_tail),\n\tKUNIT_CASE(list_test_list_is_head),\n\tKUNIT_CASE(list_test_list_is_first),\n\tKUNIT_CASE(list_test_list_is_last),\n\tKUNIT_CASE(list_test_list_empty),\n\tKUNIT_CASE(list_test_list_empty_careful),\n\tKUNIT_CASE(list_test_list_rotate_left),\n\tKUNIT_CASE(list_test_list_rotate_to_front),\n\tKUNIT_CASE(list_test_list_is_singular),\n\tKUNIT_CASE(list_test_list_cut_position),\n\tKUNIT_CASE(list_test_list_cut_before),\n\tKUNIT_CASE(list_test_list_splice),\n\tKUNIT_CASE(list_test_list_splice_tail),\n\tKUNIT_CASE(list_test_list_splice_init),\n\tKUNIT_CASE(list_test_list_splice_tail_init),\n\tKUNIT_CASE(list_test_list_entry),\n\tKUNIT_CASE(list_test_list_entry_is_head),\n\tKUNIT_CASE(list_test_list_first_entry),\n\tKUNIT_CASE(list_test_list_last_entry),\n\tKUNIT_CASE(list_test_list_first_entry_or_null),\n\tKUNIT_CASE(list_test_list_next_entry),\n\tKUNIT_CASE(list_test_list_prev_entry),\n\tKUNIT_CASE(list_test_list_for_each),\n\tKUNIT_CASE(list_test_list_for_each_prev),\n\tKUNIT_CASE(list_test_list_for_each_safe),\n\tKUNIT_CASE(list_test_list_for_each_prev_safe),\n\tKUNIT_CASE(list_test_list_for_each_entry),\n\tKUNIT_CASE(list_test_list_for_each_entry_reverse),\n\t{},\n};\n\nstatic struct kunit_suite list_test_module = {\n\t.name = \"list-kunit-test\",\n\t.test_cases = list_test_cases,\n};\n\nstruct hlist_test_struct {\n\tint data;\n\tstruct hlist_node list;\n};\n\nstatic void hlist_test_init(struct kunit *test)\n{\n\t \n\tstruct hlist_head list1 = HLIST_HEAD_INIT;\n\tstruct hlist_head list2;\n\tHLIST_HEAD(list3);\n\tstruct hlist_head *list4;\n\tstruct hlist_head *list5;\n\n\tINIT_HLIST_HEAD(&list2);\n\n\tlist4 = kzalloc(sizeof(*list4), GFP_KERNEL | __GFP_NOFAIL);\n\tINIT_HLIST_HEAD(list4);\n\n\tlist5 = kmalloc(sizeof(*list5), GFP_KERNEL | __GFP_NOFAIL);\n\tmemset(list5, 0xFF, sizeof(*list5));\n\tINIT_HLIST_HEAD(list5);\n\n\tKUNIT_EXPECT_TRUE(test, hlist_empty(&list1));\n\tKUNIT_EXPECT_TRUE(test, hlist_empty(&list2));\n\tKUNIT_EXPECT_TRUE(test, hlist_empty(&list3));\n\tKUNIT_EXPECT_TRUE(test, hlist_empty(list4));\n\tKUNIT_EXPECT_TRUE(test, hlist_empty(list5));\n\n\tkfree(list4);\n\tkfree(list5);\n}\n\nstatic void hlist_test_unhashed(struct kunit *test)\n{\n\tstruct hlist_node a;\n\tHLIST_HEAD(list);\n\n\tINIT_HLIST_NODE(&a);\n\n\t \n\tKUNIT_EXPECT_TRUE(test, hlist_unhashed(&a));\n\n\thlist_add_head(&a, &list);\n\n\t \n\tKUNIT_EXPECT_FALSE(test, hlist_unhashed(&a));\n\n\thlist_del_init(&a);\n\n\t \n\tKUNIT_EXPECT_TRUE(test, hlist_unhashed(&a));\n}\n\n \nstatic void hlist_test_unhashed_lockless(struct kunit *test)\n{\n\tstruct hlist_node a;\n\tHLIST_HEAD(list);\n\n\tINIT_HLIST_NODE(&a);\n\n\t \n\tKUNIT_EXPECT_TRUE(test, hlist_unhashed_lockless(&a));\n\n\thlist_add_head(&a, &list);\n\n\t \n\tKUNIT_EXPECT_FALSE(test, hlist_unhashed_lockless(&a));\n\n\thlist_del_init(&a);\n\n\t \n\tKUNIT_EXPECT_TRUE(test, hlist_unhashed_lockless(&a));\n}\n\nstatic void hlist_test_del(struct kunit *test)\n{\n\tstruct hlist_node a, b;\n\tHLIST_HEAD(list);\n\n\thlist_add_head(&a, &list);\n\thlist_add_behind(&b, &a);\n\n\t \n\thlist_del(&a);\n\n\t \n\tKUNIT_EXPECT_PTR_EQ(test, list.first, &b);\n\tKUNIT_EXPECT_PTR_EQ(test, b.pprev, &list.first);\n}\n\nstatic void hlist_test_del_init(struct kunit *test)\n{\n\tstruct hlist_node a, b;\n\tHLIST_HEAD(list);\n\n\thlist_add_head(&a, &list);\n\thlist_add_behind(&b, &a);\n\n\t \n\thlist_del_init(&a);\n\n\t \n\tKUNIT_EXPECT_PTR_EQ(test, list.first, &b);\n\tKUNIT_EXPECT_PTR_EQ(test, b.pprev, &list.first);\n\n\t \n\tKUNIT_EXPECT_PTR_EQ(test, a.next, NULL);\n\tKUNIT_EXPECT_PTR_EQ(test, a.pprev, NULL);\n}\n\n \nstatic void hlist_test_add(struct kunit *test)\n{\n\tstruct hlist_node a, b, c, d;\n\tHLIST_HEAD(list);\n\n\thlist_add_head(&a, &list);\n\thlist_add_head(&b, &list);\n\thlist_add_before(&c, &a);\n\thlist_add_behind(&d, &a);\n\n\t \n\tKUNIT_EXPECT_PTR_EQ(test, list.first, &b);\n\n\tKUNIT_EXPECT_PTR_EQ(test, c.pprev, &(b.next));\n\tKUNIT_EXPECT_PTR_EQ(test, b.next, &c);\n\n\tKUNIT_EXPECT_PTR_EQ(test, a.pprev, &(c.next));\n\tKUNIT_EXPECT_PTR_EQ(test, c.next, &a);\n\n\tKUNIT_EXPECT_PTR_EQ(test, d.pprev, &(a.next));\n\tKUNIT_EXPECT_PTR_EQ(test, a.next, &d);\n}\n\n \nstatic void hlist_test_fake(struct kunit *test)\n{\n\tstruct hlist_node a;\n\n\tINIT_HLIST_NODE(&a);\n\n\t \n\tKUNIT_EXPECT_FALSE(test, hlist_fake(&a));\n\n\thlist_add_fake(&a);\n\n\t \n\tKUNIT_EXPECT_TRUE(test, hlist_fake(&a));\n}\n\nstatic void hlist_test_is_singular_node(struct kunit *test)\n{\n\tstruct hlist_node a, b;\n\tHLIST_HEAD(list);\n\n\tINIT_HLIST_NODE(&a);\n\tKUNIT_EXPECT_FALSE(test, hlist_is_singular_node(&a, &list));\n\n\thlist_add_head(&a, &list);\n\tKUNIT_EXPECT_TRUE(test, hlist_is_singular_node(&a, &list));\n\n\thlist_add_head(&b, &list);\n\tKUNIT_EXPECT_FALSE(test, hlist_is_singular_node(&a, &list));\n\tKUNIT_EXPECT_FALSE(test, hlist_is_singular_node(&b, &list));\n}\n\nstatic void hlist_test_empty(struct kunit *test)\n{\n\tstruct hlist_node a;\n\tHLIST_HEAD(list);\n\n\t \n\tKUNIT_EXPECT_TRUE(test, hlist_empty(&list));\n\n\thlist_add_head(&a, &list);\n\n\t \n\tKUNIT_EXPECT_FALSE(test, hlist_empty(&list));\n}\n\nstatic void hlist_test_move_list(struct kunit *test)\n{\n\tstruct hlist_node a;\n\tHLIST_HEAD(list1);\n\tHLIST_HEAD(list2);\n\n\thlist_add_head(&a, &list1);\n\n\tKUNIT_EXPECT_FALSE(test, hlist_empty(&list1));\n\tKUNIT_EXPECT_TRUE(test, hlist_empty(&list2));\n\thlist_move_list(&list1, &list2);\n\tKUNIT_EXPECT_TRUE(test, hlist_empty(&list1));\n\tKUNIT_EXPECT_FALSE(test, hlist_empty(&list2));\n\n}\n\nstatic void hlist_test_entry(struct kunit *test)\n{\n\tstruct hlist_test_struct test_struct;\n\n\tKUNIT_EXPECT_PTR_EQ(test, &test_struct,\n\t\t\t    hlist_entry(&(test_struct.list),\n\t\t\t\tstruct hlist_test_struct, list));\n}\n\nstatic void hlist_test_entry_safe(struct kunit *test)\n{\n\tstruct hlist_test_struct test_struct;\n\n\tKUNIT_EXPECT_PTR_EQ(test, &test_struct,\n\t\t\t    hlist_entry_safe(&(test_struct.list),\n\t\t\t\tstruct hlist_test_struct, list));\n\n\tKUNIT_EXPECT_PTR_EQ(test, NULL,\n\t\t\t    hlist_entry_safe((struct hlist_node *)NULL,\n\t\t\t\tstruct hlist_test_struct, list));\n}\n\nstatic void hlist_test_for_each(struct kunit *test)\n{\n\tstruct hlist_node entries[3], *cur;\n\tHLIST_HEAD(list);\n\tint i = 0;\n\n\thlist_add_head(&entries[0], &list);\n\thlist_add_behind(&entries[1], &entries[0]);\n\thlist_add_behind(&entries[2], &entries[1]);\n\n\thlist_for_each(cur, &list) {\n\t\tKUNIT_EXPECT_PTR_EQ(test, cur, &entries[i]);\n\t\ti++;\n\t}\n\n\tKUNIT_EXPECT_EQ(test, i, 3);\n}\n\n\nstatic void hlist_test_for_each_safe(struct kunit *test)\n{\n\tstruct hlist_node entries[3], *cur, *n;\n\tHLIST_HEAD(list);\n\tint i = 0;\n\n\thlist_add_head(&entries[0], &list);\n\thlist_add_behind(&entries[1], &entries[0]);\n\thlist_add_behind(&entries[2], &entries[1]);\n\n\thlist_for_each_safe(cur, n, &list) {\n\t\tKUNIT_EXPECT_PTR_EQ(test, cur, &entries[i]);\n\t\thlist_del(&entries[i]);\n\t\ti++;\n\t}\n\n\tKUNIT_EXPECT_EQ(test, i, 3);\n\tKUNIT_EXPECT_TRUE(test, hlist_empty(&list));\n}\n\nstatic void hlist_test_for_each_entry(struct kunit *test)\n{\n\tstruct hlist_test_struct entries[5], *cur;\n\tHLIST_HEAD(list);\n\tint i = 0;\n\n\tentries[0].data = 0;\n\thlist_add_head(&entries[0].list, &list);\n\tfor (i = 1; i < 5; ++i) {\n\t\tentries[i].data = i;\n\t\thlist_add_behind(&entries[i].list, &entries[i-1].list);\n\t}\n\n\ti = 0;\n\n\thlist_for_each_entry(cur, &list, list) {\n\t\tKUNIT_EXPECT_EQ(test, cur->data, i);\n\t\ti++;\n\t}\n\n\tKUNIT_EXPECT_EQ(test, i, 5);\n}\n\nstatic void hlist_test_for_each_entry_continue(struct kunit *test)\n{\n\tstruct hlist_test_struct entries[5], *cur;\n\tHLIST_HEAD(list);\n\tint i = 0;\n\n\tentries[0].data = 0;\n\thlist_add_head(&entries[0].list, &list);\n\tfor (i = 1; i < 5; ++i) {\n\t\tentries[i].data = i;\n\t\thlist_add_behind(&entries[i].list, &entries[i-1].list);\n\t}\n\n\t \n\ti = 1;\n\n\tcur = &entries[0];\n\thlist_for_each_entry_continue(cur, list) {\n\t\tKUNIT_EXPECT_EQ(test, cur->data, i);\n\t\t \n\t\tcur->data = 42;\n\t\ti++;\n\t}\n\n\tKUNIT_EXPECT_EQ(test, i, 5);\n\t \n\tKUNIT_EXPECT_EQ(test, entries[0].data, 0);\n\t \n\tKUNIT_EXPECT_EQ(test, entries[1].data, 42);\n}\n\nstatic void hlist_test_for_each_entry_from(struct kunit *test)\n{\n\tstruct hlist_test_struct entries[5], *cur;\n\tHLIST_HEAD(list);\n\tint i = 0;\n\n\tentries[0].data = 0;\n\thlist_add_head(&entries[0].list, &list);\n\tfor (i = 1; i < 5; ++i) {\n\t\tentries[i].data = i;\n\t\thlist_add_behind(&entries[i].list, &entries[i-1].list);\n\t}\n\n\ti = 0;\n\n\tcur = &entries[0];\n\thlist_for_each_entry_from(cur, list) {\n\t\tKUNIT_EXPECT_EQ(test, cur->data, i);\n\t\t \n\t\tcur->data = 42;\n\t\ti++;\n\t}\n\n\tKUNIT_EXPECT_EQ(test, i, 5);\n\t \n\tKUNIT_EXPECT_EQ(test, entries[0].data, 42);\n}\n\nstatic void hlist_test_for_each_entry_safe(struct kunit *test)\n{\n\tstruct hlist_test_struct entries[5], *cur;\n\tstruct hlist_node *tmp_node;\n\tHLIST_HEAD(list);\n\tint i = 0;\n\n\tentries[0].data = 0;\n\thlist_add_head(&entries[0].list, &list);\n\tfor (i = 1; i < 5; ++i) {\n\t\tentries[i].data = i;\n\t\thlist_add_behind(&entries[i].list, &entries[i-1].list);\n\t}\n\n\ti = 0;\n\n\thlist_for_each_entry_safe(cur, tmp_node, &list, list) {\n\t\tKUNIT_EXPECT_EQ(test, cur->data, i);\n\t\thlist_del(&cur->list);\n\t\ti++;\n\t}\n\n\tKUNIT_EXPECT_EQ(test, i, 5);\n\tKUNIT_EXPECT_TRUE(test, hlist_empty(&list));\n}\n\n\nstatic struct kunit_case hlist_test_cases[] = {\n\tKUNIT_CASE(hlist_test_init),\n\tKUNIT_CASE(hlist_test_unhashed),\n\tKUNIT_CASE(hlist_test_unhashed_lockless),\n\tKUNIT_CASE(hlist_test_del),\n\tKUNIT_CASE(hlist_test_del_init),\n\tKUNIT_CASE(hlist_test_add),\n\tKUNIT_CASE(hlist_test_fake),\n\tKUNIT_CASE(hlist_test_is_singular_node),\n\tKUNIT_CASE(hlist_test_empty),\n\tKUNIT_CASE(hlist_test_move_list),\n\tKUNIT_CASE(hlist_test_entry),\n\tKUNIT_CASE(hlist_test_entry_safe),\n\tKUNIT_CASE(hlist_test_for_each),\n\tKUNIT_CASE(hlist_test_for_each_safe),\n\tKUNIT_CASE(hlist_test_for_each_entry),\n\tKUNIT_CASE(hlist_test_for_each_entry_continue),\n\tKUNIT_CASE(hlist_test_for_each_entry_from),\n\tKUNIT_CASE(hlist_test_for_each_entry_safe),\n\t{},\n};\n\nstatic struct kunit_suite hlist_test_module = {\n\t.name = \"hlist\",\n\t.test_cases = hlist_test_cases,\n};\n\n\nstruct klist_test_struct {\n\tint data;\n\tstruct klist klist;\n\tstruct klist_node klist_node;\n};\n\nstatic int node_count;\nstatic struct klist_node *last_node;\n\nstatic void check_node(struct klist_node *node_ptr)\n{\n\tnode_count++;\n\tlast_node = node_ptr;\n}\n\nstatic void check_delete_node(struct klist_node *node_ptr)\n{\n\tnode_count--;\n\tlast_node = node_ptr;\n}\n\nstatic void klist_test_add_tail(struct kunit *test)\n{\n\tstruct klist_node a, b;\n\tstruct klist mylist;\n\tstruct klist_iter i;\n\n\tnode_count = 0;\n\tklist_init(&mylist, &check_node, NULL);\n\n\tklist_add_tail(&a, &mylist);\n\tKUNIT_EXPECT_EQ(test, node_count, 1);\n\tKUNIT_EXPECT_PTR_EQ(test, last_node, &a);\n\n\tklist_add_tail(&b, &mylist);\n\tKUNIT_EXPECT_EQ(test, node_count, 2);\n\tKUNIT_EXPECT_PTR_EQ(test, last_node, &b);\n\n\t \n\tklist_iter_init(&mylist, &i);\n\n\tKUNIT_EXPECT_PTR_EQ(test, klist_next(&i), &a);\n\tKUNIT_EXPECT_PTR_EQ(test, klist_next(&i), &b);\n\tKUNIT_EXPECT_NULL(test, klist_next(&i));\n\n\tklist_iter_exit(&i);\n\n}\n\nstatic void klist_test_add_head(struct kunit *test)\n{\n\tstruct klist_node a, b;\n\tstruct klist mylist;\n\tstruct klist_iter i;\n\n\tnode_count = 0;\n\tklist_init(&mylist, &check_node, NULL);\n\n\tklist_add_head(&a, &mylist);\n\tKUNIT_EXPECT_EQ(test, node_count, 1);\n\tKUNIT_EXPECT_PTR_EQ(test, last_node, &a);\n\n\tklist_add_head(&b, &mylist);\n\tKUNIT_EXPECT_EQ(test, node_count, 2);\n\tKUNIT_EXPECT_PTR_EQ(test, last_node, &b);\n\n\t \n\tklist_iter_init(&mylist, &i);\n\n\tKUNIT_EXPECT_PTR_EQ(test, klist_next(&i), &b);\n\tKUNIT_EXPECT_PTR_EQ(test, klist_next(&i), &a);\n\tKUNIT_EXPECT_NULL(test, klist_next(&i));\n\n\tklist_iter_exit(&i);\n\n}\n\nstatic void klist_test_add_behind(struct kunit *test)\n{\n\tstruct klist_node a, b, c, d;\n\tstruct klist mylist;\n\tstruct klist_iter i;\n\n\tnode_count = 0;\n\tklist_init(&mylist, &check_node, NULL);\n\n\tklist_add_head(&a, &mylist);\n\tklist_add_head(&b, &mylist);\n\n\tklist_add_behind(&c, &a);\n\tKUNIT_EXPECT_EQ(test, node_count, 3);\n\tKUNIT_EXPECT_PTR_EQ(test, last_node, &c);\n\n\tklist_add_behind(&d, &b);\n\tKUNIT_EXPECT_EQ(test, node_count, 4);\n\tKUNIT_EXPECT_PTR_EQ(test, last_node, &d);\n\n\tklist_iter_init(&mylist, &i);\n\n\t \n\tKUNIT_EXPECT_PTR_EQ(test, klist_next(&i), &b);\n\tKUNIT_EXPECT_PTR_EQ(test, klist_next(&i), &d);\n\tKUNIT_EXPECT_PTR_EQ(test, klist_next(&i), &a);\n\tKUNIT_EXPECT_PTR_EQ(test, klist_next(&i), &c);\n\tKUNIT_EXPECT_NULL(test, klist_next(&i));\n\n\tklist_iter_exit(&i);\n\n}\n\nstatic void klist_test_add_before(struct kunit *test)\n{\n\tstruct klist_node a, b, c, d;\n\tstruct klist mylist;\n\tstruct klist_iter i;\n\n\tnode_count = 0;\n\tklist_init(&mylist, &check_node, NULL);\n\n\tklist_add_head(&a, &mylist);\n\tklist_add_head(&b, &mylist);\n\tklist_add_before(&c, &a);\n\tKUNIT_EXPECT_EQ(test, node_count, 3);\n\tKUNIT_EXPECT_PTR_EQ(test, last_node, &c);\n\n\tklist_add_before(&d, &b);\n\tKUNIT_EXPECT_EQ(test, node_count, 4);\n\tKUNIT_EXPECT_PTR_EQ(test, last_node, &d);\n\n\tklist_iter_init(&mylist, &i);\n\n\t \n\tKUNIT_EXPECT_PTR_EQ(test, klist_next(&i), &d);\n\tKUNIT_EXPECT_PTR_EQ(test, klist_next(&i), &b);\n\tKUNIT_EXPECT_PTR_EQ(test, klist_next(&i), &c);\n\tKUNIT_EXPECT_PTR_EQ(test, klist_next(&i), &a);\n\tKUNIT_EXPECT_NULL(test, klist_next(&i));\n\n\tklist_iter_exit(&i);\n\n}\n\n \nstatic void klist_test_del_refcount_greater_than_zero(struct kunit *test)\n{\n\tstruct klist_node a, b, c, d;\n\tstruct klist mylist;\n\tstruct klist_iter i;\n\n\tnode_count = 0;\n\tklist_init(&mylist, &check_node, &check_delete_node);\n\n\t \n\tklist_add_tail(&a, &mylist);\n\tklist_add_tail(&b, &mylist);\n\tklist_add_tail(&c, &mylist);\n\tklist_add_tail(&d, &mylist);\n\n\tklist_iter_init(&mylist, &i);\n\n\tKUNIT_EXPECT_PTR_EQ(test, klist_next(&i), &a);\n\tKUNIT_EXPECT_PTR_EQ(test, klist_next(&i), &b);\n\t \n\tKUNIT_EXPECT_PTR_EQ(test, klist_next(&i), &c);\n\n\t \n\tklist_del(&c);\n\n\t \n\tKUNIT_EXPECT_TRUE(test, klist_node_attached(&c));\n\n\t \n\tKUNIT_EXPECT_EQ(test, node_count, 4);\n\tKUNIT_EXPECT_PTR_EQ(test, last_node, &d);\n\n\tklist_iter_exit(&i);\n\n\t \n\tKUNIT_EXPECT_EQ(test, node_count, 3);\n\tKUNIT_EXPECT_PTR_EQ(test, last_node, &c);\n\n}\n\n \nstatic void klist_test_del_refcount_zero(struct kunit *test)\n{\n\tstruct klist_node a, b, c, d;\n\tstruct klist mylist;\n\tstruct klist_iter i;\n\n\tnode_count = 0;\n\tklist_init(&mylist, &check_node, &check_delete_node);\n\n\t \n\tklist_add_tail(&a, &mylist);\n\tklist_add_tail(&b, &mylist);\n\tklist_add_tail(&c, &mylist);\n\tklist_add_tail(&d, &mylist);\n\t \n\tklist_del(&c);\n\n\t \n\tKUNIT_EXPECT_EQ(test, node_count, 3);\n\tKUNIT_EXPECT_PTR_EQ(test, last_node, &c);\n\n\t \n\tklist_iter_init(&mylist, &i);\n\n\tKUNIT_EXPECT_PTR_EQ(test, klist_next(&i), &a);\n\tKUNIT_EXPECT_PTR_EQ(test, klist_next(&i), &b);\n\tKUNIT_EXPECT_PTR_EQ(test, klist_next(&i), &d);\n\tKUNIT_EXPECT_NULL(test, klist_next(&i));\n\n\tklist_iter_exit(&i);\n\n}\n\nstatic void klist_test_remove(struct kunit *test)\n{\n\t \n\tstruct klist_node a, b, c, d;\n\tstruct klist mylist;\n\tstruct klist_iter i;\n\n\tnode_count = 0;\n\tklist_init(&mylist, &check_node, &check_delete_node);\n\n\t \n\tklist_add_tail(&a, &mylist);\n\tklist_add_tail(&b, &mylist);\n\tklist_add_tail(&c, &mylist);\n\tklist_add_tail(&d, &mylist);\n\t \n\tklist_remove(&c);\n\n\t \n\tKUNIT_EXPECT_EQ(test, node_count, 3);\n\tKUNIT_EXPECT_PTR_EQ(test, last_node, &c);\n\n\t \n\tklist_iter_init(&mylist, &i);\n\n\tKUNIT_EXPECT_PTR_EQ(test, klist_next(&i), &a);\n\tKUNIT_EXPECT_PTR_EQ(test, klist_next(&i), &b);\n\tKUNIT_EXPECT_PTR_EQ(test, klist_next(&i), &d);\n\tKUNIT_EXPECT_NULL(test, klist_next(&i));\n\n\tklist_iter_exit(&i);\n\n}\n\nstatic void klist_test_node_attached(struct kunit *test)\n{\n\tstruct klist_node a = {};\n\tstruct klist mylist;\n\n\tklist_init(&mylist, NULL, NULL);\n\n\tKUNIT_EXPECT_FALSE(test, klist_node_attached(&a));\n\tklist_add_head(&a, &mylist);\n\tKUNIT_EXPECT_TRUE(test, klist_node_attached(&a));\n\tklist_del(&a);\n\tKUNIT_EXPECT_FALSE(test, klist_node_attached(&a));\n\n}\n\nstatic struct kunit_case klist_test_cases[] = {\n\tKUNIT_CASE(klist_test_add_tail),\n\tKUNIT_CASE(klist_test_add_head),\n\tKUNIT_CASE(klist_test_add_behind),\n\tKUNIT_CASE(klist_test_add_before),\n\tKUNIT_CASE(klist_test_del_refcount_greater_than_zero),\n\tKUNIT_CASE(klist_test_del_refcount_zero),\n\tKUNIT_CASE(klist_test_remove),\n\tKUNIT_CASE(klist_test_node_attached),\n\t{},\n};\n\nstatic struct kunit_suite klist_test_module = {\n\t.name = \"klist\",\n\t.test_cases = klist_test_cases,\n};\n\nkunit_test_suites(&list_test_module, &hlist_test_module, &klist_test_module);\n\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}