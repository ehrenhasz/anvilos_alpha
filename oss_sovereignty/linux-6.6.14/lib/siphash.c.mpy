{
  "module_name": "siphash.c",
  "hash_id": "c09df58c22ca81f72780abccc8f001ba6e0d946b07e62607459a84219df339be",
  "original_prompt": "Ingested from linux-6.6.14/lib/siphash.c",
  "human_readable_source": "\n \n\n#include <linux/siphash.h>\n#include <asm/unaligned.h>\n\n#if defined(CONFIG_DCACHE_WORD_ACCESS) && BITS_PER_LONG == 64\n#include <linux/dcache.h>\n#include <asm/word-at-a-time.h>\n#endif\n\n#define SIPROUND SIPHASH_PERMUTATION(v0, v1, v2, v3)\n\n#define PREAMBLE(len) \\\n\tu64 v0 = SIPHASH_CONST_0; \\\n\tu64 v1 = SIPHASH_CONST_1; \\\n\tu64 v2 = SIPHASH_CONST_2; \\\n\tu64 v3 = SIPHASH_CONST_3; \\\n\tu64 b = ((u64)(len)) << 56; \\\n\tv3 ^= key->key[1]; \\\n\tv2 ^= key->key[0]; \\\n\tv1 ^= key->key[1]; \\\n\tv0 ^= key->key[0];\n\n#define POSTAMBLE \\\n\tv3 ^= b; \\\n\tSIPROUND; \\\n\tSIPROUND; \\\n\tv0 ^= b; \\\n\tv2 ^= 0xff; \\\n\tSIPROUND; \\\n\tSIPROUND; \\\n\tSIPROUND; \\\n\tSIPROUND; \\\n\treturn (v0 ^ v1) ^ (v2 ^ v3);\n\n#ifndef CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS\nu64 __siphash_aligned(const void *data, size_t len, const siphash_key_t *key)\n{\n\tconst u8 *end = data + len - (len % sizeof(u64));\n\tconst u8 left = len & (sizeof(u64) - 1);\n\tu64 m;\n\tPREAMBLE(len)\n\tfor (; data != end; data += sizeof(u64)) {\n\t\tm = le64_to_cpup(data);\n\t\tv3 ^= m;\n\t\tSIPROUND;\n\t\tSIPROUND;\n\t\tv0 ^= m;\n\t}\n#if defined(CONFIG_DCACHE_WORD_ACCESS) && BITS_PER_LONG == 64\n\tif (left)\n\t\tb |= le64_to_cpu((__force __le64)(load_unaligned_zeropad(data) &\n\t\t\t\t\t\t  bytemask_from_count(left)));\n#else\n\tswitch (left) {\n\tcase 7: b |= ((u64)end[6]) << 48; fallthrough;\n\tcase 6: b |= ((u64)end[5]) << 40; fallthrough;\n\tcase 5: b |= ((u64)end[4]) << 32; fallthrough;\n\tcase 4: b |= le32_to_cpup(data); break;\n\tcase 3: b |= ((u64)end[2]) << 16; fallthrough;\n\tcase 2: b |= le16_to_cpup(data); break;\n\tcase 1: b |= end[0];\n\t}\n#endif\n\tPOSTAMBLE\n}\nEXPORT_SYMBOL(__siphash_aligned);\n#endif\n\nu64 __siphash_unaligned(const void *data, size_t len, const siphash_key_t *key)\n{\n\tconst u8 *end = data + len - (len % sizeof(u64));\n\tconst u8 left = len & (sizeof(u64) - 1);\n\tu64 m;\n\tPREAMBLE(len)\n\tfor (; data != end; data += sizeof(u64)) {\n\t\tm = get_unaligned_le64(data);\n\t\tv3 ^= m;\n\t\tSIPROUND;\n\t\tSIPROUND;\n\t\tv0 ^= m;\n\t}\n#if defined(CONFIG_DCACHE_WORD_ACCESS) && BITS_PER_LONG == 64\n\tif (left)\n\t\tb |= le64_to_cpu((__force __le64)(load_unaligned_zeropad(data) &\n\t\t\t\t\t\t  bytemask_from_count(left)));\n#else\n\tswitch (left) {\n\tcase 7: b |= ((u64)end[6]) << 48; fallthrough;\n\tcase 6: b |= ((u64)end[5]) << 40; fallthrough;\n\tcase 5: b |= ((u64)end[4]) << 32; fallthrough;\n\tcase 4: b |= get_unaligned_le32(end); break;\n\tcase 3: b |= ((u64)end[2]) << 16; fallthrough;\n\tcase 2: b |= get_unaligned_le16(end); break;\n\tcase 1: b |= end[0];\n\t}\n#endif\n\tPOSTAMBLE\n}\nEXPORT_SYMBOL(__siphash_unaligned);\n\n \nu64 siphash_1u64(const u64 first, const siphash_key_t *key)\n{\n\tPREAMBLE(8)\n\tv3 ^= first;\n\tSIPROUND;\n\tSIPROUND;\n\tv0 ^= first;\n\tPOSTAMBLE\n}\nEXPORT_SYMBOL(siphash_1u64);\n\n \nu64 siphash_2u64(const u64 first, const u64 second, const siphash_key_t *key)\n{\n\tPREAMBLE(16)\n\tv3 ^= first;\n\tSIPROUND;\n\tSIPROUND;\n\tv0 ^= first;\n\tv3 ^= second;\n\tSIPROUND;\n\tSIPROUND;\n\tv0 ^= second;\n\tPOSTAMBLE\n}\nEXPORT_SYMBOL(siphash_2u64);\n\n \nu64 siphash_3u64(const u64 first, const u64 second, const u64 third,\n\t\t const siphash_key_t *key)\n{\n\tPREAMBLE(24)\n\tv3 ^= first;\n\tSIPROUND;\n\tSIPROUND;\n\tv0 ^= first;\n\tv3 ^= second;\n\tSIPROUND;\n\tSIPROUND;\n\tv0 ^= second;\n\tv3 ^= third;\n\tSIPROUND;\n\tSIPROUND;\n\tv0 ^= third;\n\tPOSTAMBLE\n}\nEXPORT_SYMBOL(siphash_3u64);\n\n \nu64 siphash_4u64(const u64 first, const u64 second, const u64 third,\n\t\t const u64 forth, const siphash_key_t *key)\n{\n\tPREAMBLE(32)\n\tv3 ^= first;\n\tSIPROUND;\n\tSIPROUND;\n\tv0 ^= first;\n\tv3 ^= second;\n\tSIPROUND;\n\tSIPROUND;\n\tv0 ^= second;\n\tv3 ^= third;\n\tSIPROUND;\n\tSIPROUND;\n\tv0 ^= third;\n\tv3 ^= forth;\n\tSIPROUND;\n\tSIPROUND;\n\tv0 ^= forth;\n\tPOSTAMBLE\n}\nEXPORT_SYMBOL(siphash_4u64);\n\nu64 siphash_1u32(const u32 first, const siphash_key_t *key)\n{\n\tPREAMBLE(4)\n\tb |= first;\n\tPOSTAMBLE\n}\nEXPORT_SYMBOL(siphash_1u32);\n\nu64 siphash_3u32(const u32 first, const u32 second, const u32 third,\n\t\t const siphash_key_t *key)\n{\n\tu64 combined = (u64)second << 32 | first;\n\tPREAMBLE(12)\n\tv3 ^= combined;\n\tSIPROUND;\n\tSIPROUND;\n\tv0 ^= combined;\n\tb |= third;\n\tPOSTAMBLE\n}\nEXPORT_SYMBOL(siphash_3u32);\n\n#if BITS_PER_LONG == 64\n \n\n#define HSIPROUND SIPROUND\n#define HPREAMBLE(len) PREAMBLE(len)\n#define HPOSTAMBLE \\\n\tv3 ^= b; \\\n\tHSIPROUND; \\\n\tv0 ^= b; \\\n\tv2 ^= 0xff; \\\n\tHSIPROUND; \\\n\tHSIPROUND; \\\n\tHSIPROUND; \\\n\treturn (v0 ^ v1) ^ (v2 ^ v3);\n\n#ifndef CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS\nu32 __hsiphash_aligned(const void *data, size_t len, const hsiphash_key_t *key)\n{\n\tconst u8 *end = data + len - (len % sizeof(u64));\n\tconst u8 left = len & (sizeof(u64) - 1);\n\tu64 m;\n\tHPREAMBLE(len)\n\tfor (; data != end; data += sizeof(u64)) {\n\t\tm = le64_to_cpup(data);\n\t\tv3 ^= m;\n\t\tHSIPROUND;\n\t\tv0 ^= m;\n\t}\n#if defined(CONFIG_DCACHE_WORD_ACCESS) && BITS_PER_LONG == 64\n\tif (left)\n\t\tb |= le64_to_cpu((__force __le64)(load_unaligned_zeropad(data) &\n\t\t\t\t\t\t  bytemask_from_count(left)));\n#else\n\tswitch (left) {\n\tcase 7: b |= ((u64)end[6]) << 48; fallthrough;\n\tcase 6: b |= ((u64)end[5]) << 40; fallthrough;\n\tcase 5: b |= ((u64)end[4]) << 32; fallthrough;\n\tcase 4: b |= le32_to_cpup(data); break;\n\tcase 3: b |= ((u64)end[2]) << 16; fallthrough;\n\tcase 2: b |= le16_to_cpup(data); break;\n\tcase 1: b |= end[0];\n\t}\n#endif\n\tHPOSTAMBLE\n}\nEXPORT_SYMBOL(__hsiphash_aligned);\n#endif\n\nu32 __hsiphash_unaligned(const void *data, size_t len,\n\t\t\t const hsiphash_key_t *key)\n{\n\tconst u8 *end = data + len - (len % sizeof(u64));\n\tconst u8 left = len & (sizeof(u64) - 1);\n\tu64 m;\n\tHPREAMBLE(len)\n\tfor (; data != end; data += sizeof(u64)) {\n\t\tm = get_unaligned_le64(data);\n\t\tv3 ^= m;\n\t\tHSIPROUND;\n\t\tv0 ^= m;\n\t}\n#if defined(CONFIG_DCACHE_WORD_ACCESS) && BITS_PER_LONG == 64\n\tif (left)\n\t\tb |= le64_to_cpu((__force __le64)(load_unaligned_zeropad(data) &\n\t\t\t\t\t\t  bytemask_from_count(left)));\n#else\n\tswitch (left) {\n\tcase 7: b |= ((u64)end[6]) << 48; fallthrough;\n\tcase 6: b |= ((u64)end[5]) << 40; fallthrough;\n\tcase 5: b |= ((u64)end[4]) << 32; fallthrough;\n\tcase 4: b |= get_unaligned_le32(end); break;\n\tcase 3: b |= ((u64)end[2]) << 16; fallthrough;\n\tcase 2: b |= get_unaligned_le16(end); break;\n\tcase 1: b |= end[0];\n\t}\n#endif\n\tHPOSTAMBLE\n}\nEXPORT_SYMBOL(__hsiphash_unaligned);\n\n \nu32 hsiphash_1u32(const u32 first, const hsiphash_key_t *key)\n{\n\tHPREAMBLE(4)\n\tb |= first;\n\tHPOSTAMBLE\n}\nEXPORT_SYMBOL(hsiphash_1u32);\n\n \nu32 hsiphash_2u32(const u32 first, const u32 second, const hsiphash_key_t *key)\n{\n\tu64 combined = (u64)second << 32 | first;\n\tHPREAMBLE(8)\n\tv3 ^= combined;\n\tHSIPROUND;\n\tv0 ^= combined;\n\tHPOSTAMBLE\n}\nEXPORT_SYMBOL(hsiphash_2u32);\n\n \nu32 hsiphash_3u32(const u32 first, const u32 second, const u32 third,\n\t\t  const hsiphash_key_t *key)\n{\n\tu64 combined = (u64)second << 32 | first;\n\tHPREAMBLE(12)\n\tv3 ^= combined;\n\tHSIPROUND;\n\tv0 ^= combined;\n\tb |= third;\n\tHPOSTAMBLE\n}\nEXPORT_SYMBOL(hsiphash_3u32);\n\n \nu32 hsiphash_4u32(const u32 first, const u32 second, const u32 third,\n\t\t  const u32 forth, const hsiphash_key_t *key)\n{\n\tu64 combined = (u64)second << 32 | first;\n\tHPREAMBLE(16)\n\tv3 ^= combined;\n\tHSIPROUND;\n\tv0 ^= combined;\n\tcombined = (u64)forth << 32 | third;\n\tv3 ^= combined;\n\tHSIPROUND;\n\tv0 ^= combined;\n\tHPOSTAMBLE\n}\nEXPORT_SYMBOL(hsiphash_4u32);\n#else\n#define HSIPROUND HSIPHASH_PERMUTATION(v0, v1, v2, v3)\n\n#define HPREAMBLE(len) \\\n\tu32 v0 = HSIPHASH_CONST_0; \\\n\tu32 v1 = HSIPHASH_CONST_1; \\\n\tu32 v2 = HSIPHASH_CONST_2; \\\n\tu32 v3 = HSIPHASH_CONST_3; \\\n\tu32 b = ((u32)(len)) << 24; \\\n\tv3 ^= key->key[1]; \\\n\tv2 ^= key->key[0]; \\\n\tv1 ^= key->key[1]; \\\n\tv0 ^= key->key[0];\n\n#define HPOSTAMBLE \\\n\tv3 ^= b; \\\n\tHSIPROUND; \\\n\tv0 ^= b; \\\n\tv2 ^= 0xff; \\\n\tHSIPROUND; \\\n\tHSIPROUND; \\\n\tHSIPROUND; \\\n\treturn v1 ^ v3;\n\n#ifndef CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS\nu32 __hsiphash_aligned(const void *data, size_t len, const hsiphash_key_t *key)\n{\n\tconst u8 *end = data + len - (len % sizeof(u32));\n\tconst u8 left = len & (sizeof(u32) - 1);\n\tu32 m;\n\tHPREAMBLE(len)\n\tfor (; data != end; data += sizeof(u32)) {\n\t\tm = le32_to_cpup(data);\n\t\tv3 ^= m;\n\t\tHSIPROUND;\n\t\tv0 ^= m;\n\t}\n\tswitch (left) {\n\tcase 3: b |= ((u32)end[2]) << 16; fallthrough;\n\tcase 2: b |= le16_to_cpup(data); break;\n\tcase 1: b |= end[0];\n\t}\n\tHPOSTAMBLE\n}\nEXPORT_SYMBOL(__hsiphash_aligned);\n#endif\n\nu32 __hsiphash_unaligned(const void *data, size_t len,\n\t\t\t const hsiphash_key_t *key)\n{\n\tconst u8 *end = data + len - (len % sizeof(u32));\n\tconst u8 left = len & (sizeof(u32) - 1);\n\tu32 m;\n\tHPREAMBLE(len)\n\tfor (; data != end; data += sizeof(u32)) {\n\t\tm = get_unaligned_le32(data);\n\t\tv3 ^= m;\n\t\tHSIPROUND;\n\t\tv0 ^= m;\n\t}\n\tswitch (left) {\n\tcase 3: b |= ((u32)end[2]) << 16; fallthrough;\n\tcase 2: b |= get_unaligned_le16(end); break;\n\tcase 1: b |= end[0];\n\t}\n\tHPOSTAMBLE\n}\nEXPORT_SYMBOL(__hsiphash_unaligned);\n\n \nu32 hsiphash_1u32(const u32 first, const hsiphash_key_t *key)\n{\n\tHPREAMBLE(4)\n\tv3 ^= first;\n\tHSIPROUND;\n\tv0 ^= first;\n\tHPOSTAMBLE\n}\nEXPORT_SYMBOL(hsiphash_1u32);\n\n \nu32 hsiphash_2u32(const u32 first, const u32 second, const hsiphash_key_t *key)\n{\n\tHPREAMBLE(8)\n\tv3 ^= first;\n\tHSIPROUND;\n\tv0 ^= first;\n\tv3 ^= second;\n\tHSIPROUND;\n\tv0 ^= second;\n\tHPOSTAMBLE\n}\nEXPORT_SYMBOL(hsiphash_2u32);\n\n \nu32 hsiphash_3u32(const u32 first, const u32 second, const u32 third,\n\t\t  const hsiphash_key_t *key)\n{\n\tHPREAMBLE(12)\n\tv3 ^= first;\n\tHSIPROUND;\n\tv0 ^= first;\n\tv3 ^= second;\n\tHSIPROUND;\n\tv0 ^= second;\n\tv3 ^= third;\n\tHSIPROUND;\n\tv0 ^= third;\n\tHPOSTAMBLE\n}\nEXPORT_SYMBOL(hsiphash_3u32);\n\n \nu32 hsiphash_4u32(const u32 first, const u32 second, const u32 third,\n\t\t  const u32 forth, const hsiphash_key_t *key)\n{\n\tHPREAMBLE(16)\n\tv3 ^= first;\n\tHSIPROUND;\n\tv0 ^= first;\n\tv3 ^= second;\n\tHSIPROUND;\n\tv0 ^= second;\n\tv3 ^= third;\n\tHSIPROUND;\n\tv0 ^= third;\n\tv3 ^= forth;\n\tHSIPROUND;\n\tv0 ^= forth;\n\tHPOSTAMBLE\n}\nEXPORT_SYMBOL(hsiphash_4u32);\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}