{
  "module_name": "ts_fsm.c",
  "hash_id": "8374f4441d24cf7710e1a29c5117e4791b2a03bf4fc4286d02d0b5f80c0deaac",
  "original_prompt": "Ingested from linux-6.6.14/lib/ts_fsm.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/textsearch.h>\n#include <linux/textsearch_fsm.h>\n\nstruct ts_fsm\n{\n\tunsigned int\t\tntokens;\n\tstruct ts_fsm_token\ttokens[];\n};\n\n \n#define _A\t\t0x100  \n#define _W\t\t0x200  \n\n \nstatic const u16 token_map[TS_FSM_TYPE_MAX+1] = {\n\t[TS_FSM_SPECIFIC] = 0,\n\t[TS_FSM_WILDCARD] = _W,\n\t[TS_FSM_CNTRL]\t  = _C,\n\t[TS_FSM_LOWER]\t  = _L,\n\t[TS_FSM_UPPER]\t  = _U,\n\t[TS_FSM_PUNCT]\t  = _P,\n\t[TS_FSM_SPACE]\t  = _S,\n\t[TS_FSM_DIGIT]\t  = _D,\n\t[TS_FSM_XDIGIT]\t  = _D | _X,\n\t[TS_FSM_ALPHA]\t  = _U | _L,\n\t[TS_FSM_ALNUM]\t  = _U | _L | _D,\n\t[TS_FSM_PRINT]\t  = _P | _U | _L | _D | _SP,\n\t[TS_FSM_GRAPH]\t  = _P | _U | _L | _D,\n\t[TS_FSM_ASCII]\t  = _A,\n};\n\nstatic const u16 token_lookup_tbl[256] = {\n_W|_A|_C,      _W|_A|_C,     _W|_A|_C,     _W|_A|_C,\t\t \n_W|_A|_C,      _W|_A|_C,     _W|_A|_C,     _W|_A|_C,\t\t \n_W|_A|_C,      _W|_A|_C|_S,  _W|_A|_C|_S,  _W|_A|_C|_S,\t\t \n_W|_A|_C|_S,   _W|_A|_C|_S,  _W|_A|_C,     _W|_A|_C,\t\t \n_W|_A|_C,      _W|_A|_C,     _W|_A|_C,     _W|_A|_C,\t\t \n_W|_A|_C,      _W|_A|_C,     _W|_A|_C,     _W|_A|_C,\t\t \n_W|_A|_C,      _W|_A|_C,     _W|_A|_C,     _W|_A|_C,\t\t \n_W|_A|_C,      _W|_A|_C,     _W|_A|_C,     _W|_A|_C,\t\t \n_W|_A|_S|_SP,  _W|_A|_P,     _W|_A|_P,     _W|_A|_P,\t\t \n_W|_A|_P,      _W|_A|_P,     _W|_A|_P,     _W|_A|_P,\t\t \n_W|_A|_P,      _W|_A|_P,     _W|_A|_P,     _W|_A|_P,\t\t \n_W|_A|_P,      _W|_A|_P,     _W|_A|_P,     _W|_A|_P,\t\t \n_W|_A|_D,      _W|_A|_D,     _W|_A|_D,     _W|_A|_D,\t\t \n_W|_A|_D,      _W|_A|_D,     _W|_A|_D,     _W|_A|_D,\t\t \n_W|_A|_D,      _W|_A|_D,     _W|_A|_P,     _W|_A|_P,\t\t \n_W|_A|_P,      _W|_A|_P,     _W|_A|_P,     _W|_A|_P,\t\t \n_W|_A|_P,      _W|_A|_U|_X,  _W|_A|_U|_X,  _W|_A|_U|_X,\t\t \n_W|_A|_U|_X,   _W|_A|_U|_X,  _W|_A|_U|_X,  _W|_A|_U,\t\t \n_W|_A|_U,      _W|_A|_U,     _W|_A|_U,     _W|_A|_U,\t\t \n_W|_A|_U,      _W|_A|_U,     _W|_A|_U,     _W|_A|_U,\t\t \n_W|_A|_U,      _W|_A|_U,     _W|_A|_U,     _W|_A|_U,\t\t \n_W|_A|_U,      _W|_A|_U,     _W|_A|_U,     _W|_A|_U,\t\t \n_W|_A|_U,      _W|_A|_U,     _W|_A|_U,     _W|_A|_P,\t\t \n_W|_A|_P,      _W|_A|_P,     _W|_A|_P,     _W|_A|_P,\t\t \n_W|_A|_P,      _W|_A|_L|_X,  _W|_A|_L|_X,  _W|_A|_L|_X,\t\t \n_W|_A|_L|_X,   _W|_A|_L|_X,  _W|_A|_L|_X,  _W|_A|_L,\t\t \n_W|_A|_L,      _W|_A|_L,     _W|_A|_L,     _W|_A|_L,\t\t \n_W|_A|_L,      _W|_A|_L,     _W|_A|_L,     _W|_A|_L,\t\t \n_W|_A|_L,      _W|_A|_L,     _W|_A|_L,     _W|_A|_L,\t\t \n_W|_A|_L,      _W|_A|_L,     _W|_A|_L,     _W|_A|_L,\t\t \n_W|_A|_L,      _W|_A|_L,     _W|_A|_L,     _W|_A|_P,\t\t \n_W|_A|_P,      _W|_A|_P,     _W|_A|_P,     _W|_A|_C,\t\t \n_W,            _W,           _W,           _W,\t\t\t \n_W,            _W,           _W,           _W,\t\t\t \n_W,            _W,           _W,           _W,\t\t\t \n_W,            _W,           _W,           _W,\t\t\t \n_W,            _W,           _W,           _W,\t\t\t \n_W,            _W,           _W,           _W,\t\t\t \n_W,            _W,           _W,           _W,\t\t\t \n_W,            _W,           _W,           _W,\t\t\t \n_W|_S|_SP,     _W|_P,        _W|_P,        _W|_P,\t\t \n_W|_P,         _W|_P,        _W|_P,        _W|_P,\t\t \n_W|_P,         _W|_P,        _W|_P,        _W|_P,\t\t \n_W|_P,         _W|_P,        _W|_P,        _W|_P,\t\t \n_W|_P,         _W|_P,        _W|_P,        _W|_P,\t\t \n_W|_P,         _W|_P,        _W|_P,        _W|_P,\t\t \n_W|_P,         _W|_P,        _W|_P,        _W|_P,\t\t \n_W|_P,         _W|_P,        _W|_P,        _W|_P,\t\t \n_W|_U,         _W|_U,        _W|_U,        _W|_U,\t\t \n_W|_U,         _W|_U,        _W|_U,        _W|_U,\t\t \n_W|_U,         _W|_U,        _W|_U,        _W|_U,\t\t \n_W|_U,         _W|_U,        _W|_U,        _W|_U,\t\t \n_W|_U,         _W|_U,        _W|_U,        _W|_U,\t\t \n_W|_U,         _W|_U,        _W|_U,        _W|_P,\t\t \n_W|_U,         _W|_U,        _W|_U,        _W|_U,\t\t \n_W|_U,         _W|_U,        _W|_U,        _W|_L,\t\t \n_W|_L,         _W|_L,        _W|_L,        _W|_L,\t\t \n_W|_L,         _W|_L,        _W|_L,        _W|_L,\t\t \n_W|_L,         _W|_L,        _W|_L,        _W|_L,\t\t \n_W|_L,         _W|_L,        _W|_L,        _W|_L,\t\t \n_W|_L,         _W|_L,        _W|_L,        _W|_L,\t\t \n_W|_L,         _W|_L,        _W|_L,        _W|_P,\t\t \n_W|_L,         _W|_L,        _W|_L,        _W|_L,\t\t \n_W|_L,         _W|_L,        _W|_L,        _W|_L};\t\t \n\nstatic inline int match_token(struct ts_fsm_token *t, u8 d)\n{\n\tif (t->type)\n\t\treturn (token_lookup_tbl[d] & t->type) != 0;\n\telse\n\t\treturn t->value == d;\n}\n\nstatic unsigned int fsm_find(struct ts_config *conf, struct ts_state *state)\n{\n\tstruct ts_fsm *fsm = ts_config_priv(conf);\n\tstruct ts_fsm_token *cur = NULL, *next;\n\tunsigned int match_start, block_idx = 0, tok_idx;\n\tunsigned block_len = 0, strict, consumed = state->offset;\n\tconst u8 *data;\n\n#define GET_NEXT_BLOCK()\t\t\\\n({\tconsumed += block_idx;\t\t\\\n\tblock_idx = 0;\t\t\t\\\n\tblock_len = conf->get_next_block(consumed, &data, conf, state); })\n\n#define TOKEN_MISMATCH()\t\t\\\n\tdo {\t\t\t\t\\\n\t\tif (strict)\t\t\\\n\t\t\tgoto no_match;\t\\\n\t\tblock_idx++;\t\t\\\n\t\tgoto startover;\t\t\\\n\t} while(0)\n\n#define end_of_data() unlikely(block_idx >= block_len && !GET_NEXT_BLOCK())\n\n\tif (end_of_data())\n\t\tgoto no_match;\n\n\tstrict = fsm->tokens[0].recur != TS_FSM_HEAD_IGNORE;\n\nstartover:\n\tmatch_start = consumed + block_idx;\n\n\tfor (tok_idx = 0; tok_idx < fsm->ntokens; tok_idx++) {\n\t\tcur = &fsm->tokens[tok_idx];\n\n\t\tif (likely(tok_idx < (fsm->ntokens - 1)))\n\t\t\tnext = &fsm->tokens[tok_idx + 1];\n\t\telse\n\t\t\tnext = NULL;\n\n\t\tswitch (cur->recur) {\n\t\tcase TS_FSM_SINGLE:\n\t\t\tif (end_of_data())\n\t\t\t\tgoto no_match;\n\n\t\t\tif (!match_token(cur, data[block_idx]))\n\t\t\t\tTOKEN_MISMATCH();\n\t\t\tbreak;\n\n\t\tcase TS_FSM_PERHAPS:\n\t\t\tif (end_of_data() ||\n\t\t\t    !match_token(cur, data[block_idx]))\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\n\t\tcase TS_FSM_MULTI:\n\t\t\tif (end_of_data())\n\t\t\t\tgoto no_match;\n\n\t\t\tif (!match_token(cur, data[block_idx]))\n\t\t\t\tTOKEN_MISMATCH();\n\n\t\t\tblock_idx++;\n\t\t\tfallthrough;\n\n\t\tcase TS_FSM_ANY:\n\t\t\tif (next == NULL)\n\t\t\t\tgoto found_match;\n\n\t\t\tif (end_of_data())\n\t\t\t\tcontinue;\n\n\t\t\twhile (!match_token(next, data[block_idx])) {\n\t\t\t\tif (!match_token(cur, data[block_idx]))\n\t\t\t\t\tTOKEN_MISMATCH();\n\t\t\t\tblock_idx++;\n\t\t\t\tif (end_of_data())\n\t\t\t\t\tgoto no_match;\n\t\t\t}\n\t\t\tcontinue;\n\n\t\t \n\t\tcase TS_FSM_HEAD_IGNORE:\n\t\t\tif (end_of_data())\n\t\t\t\tcontinue;\n\n\t\t\twhile (!match_token(next, data[block_idx])) {\n\t\t\t\t \n\t\t\t\tif (!match_token(cur, data[block_idx]))\n\t\t\t\t\tgoto no_match;\n\n\t\t\t\tblock_idx++;\n\t\t\t\tif (end_of_data())\n\t\t\t\t\tgoto no_match;\n\t\t\t}\n\n\t\t\tmatch_start = consumed + block_idx;\n\t\t\tcontinue;\n\t\t}\n\n\t\tblock_idx++;\n\t}\n\n\tif (end_of_data())\n\t\tgoto found_match;\n\nno_match:\n\treturn UINT_MAX;\n\nfound_match:\n\tstate->offset = consumed + block_idx;\n\treturn match_start;\n}\n\nstatic struct ts_config *fsm_init(const void *pattern, unsigned int len,\n\t\t\t\t    gfp_t gfp_mask, int flags)\n{\n\tint i, err = -EINVAL;\n\tstruct ts_config *conf;\n\tstruct ts_fsm *fsm;\n\tstruct ts_fsm_token *tokens = (struct ts_fsm_token *) pattern;\n\tunsigned int ntokens = len / sizeof(*tokens);\n\tsize_t priv_size = sizeof(*fsm) + len;\n\n\tif (len  % sizeof(struct ts_fsm_token) || ntokens < 1)\n\t\tgoto errout;\n\n\tif (flags & TS_IGNORECASE)\n\t\tgoto errout;\n\n\tfor (i = 0; i < ntokens; i++) {\n\t\tstruct ts_fsm_token *t = &tokens[i];\n\n\t\tif (t->type > TS_FSM_TYPE_MAX || t->recur > TS_FSM_RECUR_MAX)\n\t\t\tgoto errout;\n\n\t\tif (t->recur == TS_FSM_HEAD_IGNORE &&\n\t\t    (i != 0 || i == (ntokens - 1)))\n\t\t\tgoto errout;\n\t}\n\n\tconf = alloc_ts_config(priv_size, gfp_mask);\n\tif (IS_ERR(conf))\n\t\treturn conf;\n\n\tconf->flags = flags;\n\tfsm = ts_config_priv(conf);\n\tfsm->ntokens = ntokens;\n\tmemcpy(fsm->tokens, pattern, len);\n\n\tfor (i = 0; i < fsm->ntokens; i++) {\n\t\tstruct ts_fsm_token *t = &fsm->tokens[i];\n\t\tt->type = token_map[t->type];\n\t}\n\n\treturn conf;\n\nerrout:\n\treturn ERR_PTR(err);\n}\n\nstatic void *fsm_get_pattern(struct ts_config *conf)\n{\n\tstruct ts_fsm *fsm = ts_config_priv(conf);\n\treturn fsm->tokens;\n}\n\nstatic unsigned int fsm_get_pattern_len(struct ts_config *conf)\n{\n\tstruct ts_fsm *fsm = ts_config_priv(conf);\n\treturn fsm->ntokens * sizeof(struct ts_fsm_token);\n}\n\nstatic struct ts_ops fsm_ops = {\n\t.name\t\t  = \"fsm\",\n\t.find\t\t  = fsm_find,\n\t.init\t\t  = fsm_init,\n\t.get_pattern\t  = fsm_get_pattern,\n\t.get_pattern_len  = fsm_get_pattern_len,\n\t.owner\t\t  = THIS_MODULE,\n\t.list\t\t  = LIST_HEAD_INIT(fsm_ops.list)\n};\n\nstatic int __init init_fsm(void)\n{\n\treturn textsearch_register(&fsm_ops);\n}\n\nstatic void __exit exit_fsm(void)\n{\n\ttextsearch_unregister(&fsm_ops);\n}\n\nMODULE_LICENSE(\"GPL\");\n\nmodule_init(init_fsm);\nmodule_exit(exit_fsm);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}