{
  "module_name": "ubsan.c",
  "hash_id": "582cc0e41f2d8bba5efd8c42d5c02d51126db44bef6d5c92487f74f13781cf3d",
  "original_prompt": "Ingested from linux-6.6.14/lib/ubsan.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/bug.h>\n#include <linux/ctype.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/sched.h>\n#include <linux/uaccess.h>\n#include <linux/ubsan.h>\n#include <kunit/test-bug.h>\n\n#include \"ubsan.h\"\n\n#ifdef CONFIG_UBSAN_TRAP\n \nconst char *report_ubsan_failure(struct pt_regs *regs, u32 check_type)\n{\n\tswitch (check_type) {\n#ifdef CONFIG_UBSAN_BOUNDS\n\t \n\tcase ubsan_out_of_bounds:\n\t\treturn \"UBSAN: array index out of bounds\";\n#endif\n#ifdef CONFIG_UBSAN_SHIFT\n\t \n\tcase ubsan_shift_out_of_bounds:\n\t\treturn \"UBSAN: shift out of bounds\";\n#endif\n#ifdef CONFIG_UBSAN_DIV_ZERO\n\t \n\tcase ubsan_divrem_overflow:\n\t\treturn \"UBSAN: divide/remainder overflow\";\n#endif\n#ifdef CONFIG_UBSAN_UNREACHABLE\n\t \n\tcase ubsan_builtin_unreachable:\n\t\treturn \"UBSAN: unreachable code\";\n#endif\n#if defined(CONFIG_UBSAN_BOOL) || defined(CONFIG_UBSAN_ENUM)\n\t \n\tcase ubsan_load_invalid_value:\n\t\treturn \"UBSAN: loading invalid value\";\n#endif\n#ifdef CONFIG_UBSAN_ALIGNMENT\n\t \n\tcase ubsan_alignment_assumption:\n\t\treturn \"UBSAN: alignment assumption\";\n\tcase ubsan_type_mismatch:\n\t\treturn \"UBSAN: type mismatch\";\n#endif\n\tdefault:\n\t\treturn \"UBSAN: unrecognized failure code\";\n\t}\n}\n\n#else\nstatic const char * const type_check_kinds[] = {\n\t\"load of\",\n\t\"store to\",\n\t\"reference binding to\",\n\t\"member access within\",\n\t\"member call on\",\n\t\"constructor call on\",\n\t\"downcast of\",\n\t\"downcast of\"\n};\n\n#define REPORTED_BIT 31\n\n#if (BITS_PER_LONG == 64) && defined(__BIG_ENDIAN)\n#define COLUMN_MASK (~(1U << REPORTED_BIT))\n#define LINE_MASK   (~0U)\n#else\n#define COLUMN_MASK   (~0U)\n#define LINE_MASK (~(1U << REPORTED_BIT))\n#endif\n\n#define VALUE_LENGTH 40\n\nstatic bool was_reported(struct source_location *location)\n{\n\treturn test_and_set_bit(REPORTED_BIT, &location->reported);\n}\n\nstatic bool suppress_report(struct source_location *loc)\n{\n\treturn current->in_ubsan || was_reported(loc);\n}\n\nstatic bool type_is_int(struct type_descriptor *type)\n{\n\treturn type->type_kind == type_kind_int;\n}\n\nstatic bool type_is_signed(struct type_descriptor *type)\n{\n\tWARN_ON(!type_is_int(type));\n\treturn  type->type_info & 1;\n}\n\nstatic unsigned type_bit_width(struct type_descriptor *type)\n{\n\treturn 1 << (type->type_info >> 1);\n}\n\nstatic bool is_inline_int(struct type_descriptor *type)\n{\n\tunsigned inline_bits = sizeof(unsigned long)*8;\n\tunsigned bits = type_bit_width(type);\n\n\tWARN_ON(!type_is_int(type));\n\n\treturn bits <= inline_bits;\n}\n\nstatic s_max get_signed_val(struct type_descriptor *type, void *val)\n{\n\tif (is_inline_int(type)) {\n\t\tunsigned extra_bits = sizeof(s_max)*8 - type_bit_width(type);\n\t\tunsigned long ulong_val = (unsigned long)val;\n\n\t\treturn ((s_max)ulong_val) << extra_bits >> extra_bits;\n\t}\n\n\tif (type_bit_width(type) == 64)\n\t\treturn *(s64 *)val;\n\n\treturn *(s_max *)val;\n}\n\nstatic bool val_is_negative(struct type_descriptor *type, void *val)\n{\n\treturn type_is_signed(type) && get_signed_val(type, val) < 0;\n}\n\nstatic u_max get_unsigned_val(struct type_descriptor *type, void *val)\n{\n\tif (is_inline_int(type))\n\t\treturn (unsigned long)val;\n\n\tif (type_bit_width(type) == 64)\n\t\treturn *(u64 *)val;\n\n\treturn *(u_max *)val;\n}\n\nstatic void val_to_string(char *str, size_t size, struct type_descriptor *type,\n\t\t\tvoid *value)\n{\n\tif (type_is_int(type)) {\n\t\tif (type_bit_width(type) == 128) {\n#if defined(CONFIG_ARCH_SUPPORTS_INT128)\n\t\t\tu_max val = get_unsigned_val(type, value);\n\n\t\t\tscnprintf(str, size, \"0x%08x%08x%08x%08x\",\n\t\t\t\t(u32)(val >> 96),\n\t\t\t\t(u32)(val >> 64),\n\t\t\t\t(u32)(val >> 32),\n\t\t\t\t(u32)(val));\n#else\n\t\t\tWARN_ON(1);\n#endif\n\t\t} else if (type_is_signed(type)) {\n\t\t\tscnprintf(str, size, \"%lld\",\n\t\t\t\t(s64)get_signed_val(type, value));\n\t\t} else {\n\t\t\tscnprintf(str, size, \"%llu\",\n\t\t\t\t(u64)get_unsigned_val(type, value));\n\t\t}\n\t}\n}\n\nstatic void ubsan_prologue(struct source_location *loc, const char *reason)\n{\n\tcurrent->in_ubsan++;\n\n\tpr_err(\"========================================\"\n\t\t\"========================================\\n\");\n\tpr_err(\"UBSAN: %s in %s:%d:%d\\n\", reason, loc->file_name,\n\t\tloc->line & LINE_MASK, loc->column & COLUMN_MASK);\n\n\tkunit_fail_current_test(\"%s in %s\", reason, loc->file_name);\n}\n\nstatic void ubsan_epilogue(void)\n{\n\tdump_stack();\n\tpr_err(\"========================================\"\n\t\t\"========================================\\n\");\n\n\tcurrent->in_ubsan--;\n\n\tcheck_panic_on_warn(\"UBSAN\");\n}\n\nvoid __ubsan_handle_divrem_overflow(void *_data, void *lhs, void *rhs)\n{\n\tstruct overflow_data *data = _data;\n\tchar rhs_val_str[VALUE_LENGTH];\n\n\tif (suppress_report(&data->location))\n\t\treturn;\n\n\tubsan_prologue(&data->location, \"division-overflow\");\n\n\tval_to_string(rhs_val_str, sizeof(rhs_val_str), data->type, rhs);\n\n\tif (type_is_signed(data->type) && get_signed_val(data->type, rhs) == -1)\n\t\tpr_err(\"division of %s by -1 cannot be represented in type %s\\n\",\n\t\t\trhs_val_str, data->type->type_name);\n\telse\n\t\tpr_err(\"division by zero\\n\");\n\n\tubsan_epilogue();\n}\nEXPORT_SYMBOL(__ubsan_handle_divrem_overflow);\n\nstatic void handle_null_ptr_deref(struct type_mismatch_data_common *data)\n{\n\tif (suppress_report(data->location))\n\t\treturn;\n\n\tubsan_prologue(data->location, \"null-ptr-deref\");\n\n\tpr_err(\"%s null pointer of type %s\\n\",\n\t\ttype_check_kinds[data->type_check_kind],\n\t\tdata->type->type_name);\n\n\tubsan_epilogue();\n}\n\nstatic void handle_misaligned_access(struct type_mismatch_data_common *data,\n\t\t\t\tunsigned long ptr)\n{\n\tif (suppress_report(data->location))\n\t\treturn;\n\n\tubsan_prologue(data->location, \"misaligned-access\");\n\n\tpr_err(\"%s misaligned address %p for type %s\\n\",\n\t\ttype_check_kinds[data->type_check_kind],\n\t\t(void *)ptr, data->type->type_name);\n\tpr_err(\"which requires %ld byte alignment\\n\", data->alignment);\n\n\tubsan_epilogue();\n}\n\nstatic void handle_object_size_mismatch(struct type_mismatch_data_common *data,\n\t\t\t\t\tunsigned long ptr)\n{\n\tif (suppress_report(data->location))\n\t\treturn;\n\n\tubsan_prologue(data->location, \"object-size-mismatch\");\n\tpr_err(\"%s address %p with insufficient space\\n\",\n\t\ttype_check_kinds[data->type_check_kind],\n\t\t(void *) ptr);\n\tpr_err(\"for an object of type %s\\n\", data->type->type_name);\n\tubsan_epilogue();\n}\n\nstatic void ubsan_type_mismatch_common(struct type_mismatch_data_common *data,\n\t\t\t\tunsigned long ptr)\n{\n\tunsigned long flags = user_access_save();\n\n\tif (!ptr)\n\t\thandle_null_ptr_deref(data);\n\telse if (data->alignment && !IS_ALIGNED(ptr, data->alignment))\n\t\thandle_misaligned_access(data, ptr);\n\telse\n\t\thandle_object_size_mismatch(data, ptr);\n\n\tuser_access_restore(flags);\n}\n\nvoid __ubsan_handle_type_mismatch(struct type_mismatch_data *data,\n\t\t\t\tvoid *ptr)\n{\n\tstruct type_mismatch_data_common common_data = {\n\t\t.location = &data->location,\n\t\t.type = data->type,\n\t\t.alignment = data->alignment,\n\t\t.type_check_kind = data->type_check_kind\n\t};\n\n\tubsan_type_mismatch_common(&common_data, (unsigned long)ptr);\n}\nEXPORT_SYMBOL(__ubsan_handle_type_mismatch);\n\nvoid __ubsan_handle_type_mismatch_v1(void *_data, void *ptr)\n{\n\tstruct type_mismatch_data_v1 *data = _data;\n\tstruct type_mismatch_data_common common_data = {\n\t\t.location = &data->location,\n\t\t.type = data->type,\n\t\t.alignment = 1UL << data->log_alignment,\n\t\t.type_check_kind = data->type_check_kind\n\t};\n\n\tubsan_type_mismatch_common(&common_data, (unsigned long)ptr);\n}\nEXPORT_SYMBOL(__ubsan_handle_type_mismatch_v1);\n\nvoid __ubsan_handle_out_of_bounds(void *_data, void *index)\n{\n\tstruct out_of_bounds_data *data = _data;\n\tchar index_str[VALUE_LENGTH];\n\n\tif (suppress_report(&data->location))\n\t\treturn;\n\n\tubsan_prologue(&data->location, \"array-index-out-of-bounds\");\n\n\tval_to_string(index_str, sizeof(index_str), data->index_type, index);\n\tpr_err(\"index %s is out of range for type %s\\n\", index_str,\n\t\tdata->array_type->type_name);\n\tubsan_epilogue();\n}\nEXPORT_SYMBOL(__ubsan_handle_out_of_bounds);\n\nvoid __ubsan_handle_shift_out_of_bounds(void *_data, void *lhs, void *rhs)\n{\n\tstruct shift_out_of_bounds_data *data = _data;\n\tstruct type_descriptor *rhs_type = data->rhs_type;\n\tstruct type_descriptor *lhs_type = data->lhs_type;\n\tchar rhs_str[VALUE_LENGTH];\n\tchar lhs_str[VALUE_LENGTH];\n\tunsigned long ua_flags = user_access_save();\n\n\tif (suppress_report(&data->location))\n\t\tgoto out;\n\n\tubsan_prologue(&data->location, \"shift-out-of-bounds\");\n\n\tval_to_string(rhs_str, sizeof(rhs_str), rhs_type, rhs);\n\tval_to_string(lhs_str, sizeof(lhs_str), lhs_type, lhs);\n\n\tif (val_is_negative(rhs_type, rhs))\n\t\tpr_err(\"shift exponent %s is negative\\n\", rhs_str);\n\n\telse if (get_unsigned_val(rhs_type, rhs) >=\n\t\ttype_bit_width(lhs_type))\n\t\tpr_err(\"shift exponent %s is too large for %u-bit type %s\\n\",\n\t\t\trhs_str,\n\t\t\ttype_bit_width(lhs_type),\n\t\t\tlhs_type->type_name);\n\telse if (val_is_negative(lhs_type, lhs))\n\t\tpr_err(\"left shift of negative value %s\\n\",\n\t\t\tlhs_str);\n\telse\n\t\tpr_err(\"left shift of %s by %s places cannot be\"\n\t\t\t\" represented in type %s\\n\",\n\t\t\tlhs_str, rhs_str,\n\t\t\tlhs_type->type_name);\n\n\tubsan_epilogue();\nout:\n\tuser_access_restore(ua_flags);\n}\nEXPORT_SYMBOL(__ubsan_handle_shift_out_of_bounds);\n\n\nvoid __ubsan_handle_builtin_unreachable(void *_data)\n{\n\tstruct unreachable_data *data = _data;\n\tubsan_prologue(&data->location, \"unreachable\");\n\tpr_err(\"calling __builtin_unreachable()\\n\");\n\tubsan_epilogue();\n\tpanic(\"can't return from __builtin_unreachable()\");\n}\nEXPORT_SYMBOL(__ubsan_handle_builtin_unreachable);\n\nvoid __ubsan_handle_load_invalid_value(void *_data, void *val)\n{\n\tstruct invalid_value_data *data = _data;\n\tchar val_str[VALUE_LENGTH];\n\tunsigned long ua_flags = user_access_save();\n\n\tif (suppress_report(&data->location))\n\t\tgoto out;\n\n\tubsan_prologue(&data->location, \"invalid-load\");\n\n\tval_to_string(val_str, sizeof(val_str), data->type, val);\n\n\tpr_err(\"load of value %s is not a valid value for type %s\\n\",\n\t\tval_str, data->type->type_name);\n\n\tubsan_epilogue();\nout:\n\tuser_access_restore(ua_flags);\n}\nEXPORT_SYMBOL(__ubsan_handle_load_invalid_value);\n\nvoid __ubsan_handle_alignment_assumption(void *_data, unsigned long ptr,\n\t\t\t\t\t unsigned long align,\n\t\t\t\t\t unsigned long offset)\n{\n\tstruct alignment_assumption_data *data = _data;\n\tunsigned long real_ptr;\n\n\tif (suppress_report(&data->location))\n\t\treturn;\n\n\tubsan_prologue(&data->location, \"alignment-assumption\");\n\n\tif (offset)\n\t\tpr_err(\"assumption of %lu byte alignment (with offset of %lu byte) for pointer of type %s failed\",\n\t\t       align, offset, data->type->type_name);\n\telse\n\t\tpr_err(\"assumption of %lu byte alignment for pointer of type %s failed\",\n\t\t       align, data->type->type_name);\n\n\treal_ptr = ptr - offset;\n\tpr_err(\"%saddress is %lu aligned, misalignment offset is %lu bytes\",\n\t       offset ? \"offset \" : \"\", BIT(real_ptr ? __ffs(real_ptr) : 0),\n\t       real_ptr & (align - 1));\n\n\tubsan_epilogue();\n}\nEXPORT_SYMBOL(__ubsan_handle_alignment_assumption);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}