{
  "module_name": "altivec.uc",
  "hash_id": "44d9dc920067ee053df29f02b1c5822848ab929b7d54b45f77d86f2cde984038",
  "original_prompt": "Ingested from linux-6.6.14/lib/raid6/altivec.uc",
  "human_readable_source": "/* -*- linux-c -*- ------------------------------------------------------- *\n *\n *   Copyright 2002-2004 H. Peter Anvin - All Rights Reserved\n *\n *   This program is free software; you can redistribute it and/or modify\n *   it under the terms of the GNU General Public License as published by\n *   the Free Software Foundation, Inc., 53 Temple Place Ste 330,\n *   Boston MA 02111-1307, USA; either version 2 of the License, or\n *   (at your option) any later version; incorporated herein by reference.\n *\n * ----------------------------------------------------------------------- */\n\n/*\n * raid6altivec$#.c\n *\n * $#-way unrolled portable integer math RAID-6 instruction set\n *\n * This file is postprocessed using unroll.awk\n *\n * <benh> hpa: in process,\n * you can just \"steal\" the vec unit with enable_kernel_altivec() (but\n * bracked this with preempt_disable/enable or in a lock)\n */\n\n#include <linux/raid/pq.h>\n\n#ifdef CONFIG_ALTIVEC\n\n#include <altivec.h>\n#ifdef __KERNEL__\n# include <asm/cputable.h>\n# include <asm/switch_to.h>\n#endif /* __KERNEL__ */\n\n/*\n * This is the C data type to use.  We use a vector of\n * signed char so vec_cmpgt() will generate the right\n * instruction.\n */\n\ntypedef vector signed char unative_t;\n\n#define NBYTES(x) ((vector signed char) {x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x})\n#define NSIZE\tsizeof(unative_t)\n\n/*\n * The SHLBYTE() operation shifts each byte left by 1, *not*\n * rolling over into the next byte\n */\nstatic inline __attribute_const__ unative_t SHLBYTE(unative_t v)\n{\n\treturn vec_add(v,v);\n}\n\n/*\n * The MASK() operation returns 0xFF in any byte for which the high\n * bit is 1, 0x00 for any byte for which the high bit is 0.\n */\nstatic inline __attribute_const__ unative_t MASK(unative_t v)\n{\n\tunative_t zv = NBYTES(0);\n\n\t/* vec_cmpgt returns a vector bool char; thus the need for the cast */\n\treturn (unative_t)vec_cmpgt(zv, v);\n}\n\n\n/* This is noinline to make damned sure that gcc doesn't move any of the\n   Altivec code around the enable/disable code */\nstatic void noinline\nraid6_altivec$#_gen_syndrome_real(int disks, size_t bytes, void **ptrs)\n{\n\tu8 **dptr = (u8 **)ptrs;\n\tu8 *p, *q;\n\tint d, z, z0;\n\n\tunative_t wd$$, wq$$, wp$$, w1$$, w2$$;\n\tunative_t x1d = NBYTES(0x1d);\n\n\tz0 = disks - 3;\t\t/* Highest data disk */\n\tp = dptr[z0+1];\t\t/* XOR parity */\n\tq = dptr[z0+2];\t\t/* RS syndrome */\n\n\tfor ( d = 0 ; d < bytes ; d += NSIZE*$# ) {\n\t\twq$$ = wp$$ = *(unative_t *)&dptr[z0][d+$$*NSIZE];\n\t\tfor ( z = z0-1 ; z >= 0 ; z-- ) {\n\t\t\twd$$ = *(unative_t *)&dptr[z][d+$$*NSIZE];\n\t\t\twp$$ = vec_xor(wp$$, wd$$);\n\t\t\tw2$$ = MASK(wq$$);\n\t\t\tw1$$ = SHLBYTE(wq$$);\n\t\t\tw2$$ = vec_and(w2$$, x1d);\n\t\t\tw1$$ = vec_xor(w1$$, w2$$);\n\t\t\twq$$ = vec_xor(w1$$, wd$$);\n\t\t}\n\t\t*(unative_t *)&p[d+NSIZE*$$] = wp$$;\n\t\t*(unative_t *)&q[d+NSIZE*$$] = wq$$;\n\t}\n}\n\nstatic void raid6_altivec$#_gen_syndrome(int disks, size_t bytes, void **ptrs)\n{\n\tpreempt_disable();\n\tenable_kernel_altivec();\n\n\traid6_altivec$#_gen_syndrome_real(disks, bytes, ptrs);\n\n\tdisable_kernel_altivec();\n\tpreempt_enable();\n}\n\nint raid6_have_altivec(void);\n#if $# == 1\nint raid6_have_altivec(void)\n{\n\t/* This assumes either all CPUs have Altivec or none does */\n# ifdef __KERNEL__\n\treturn cpu_has_feature(CPU_FTR_ALTIVEC);\n# else\n\treturn 1;\n# endif\n}\n#endif\n\nconst struct raid6_calls raid6_altivec$# = {\n\traid6_altivec$#_gen_syndrome,\n\tNULL,\t\t\t/* XOR not yet implemented */\n\traid6_have_altivec,\n\t\"altivecx$#\",\n\t0\n};\n\n#endif /* CONFIG_ALTIVEC */\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}