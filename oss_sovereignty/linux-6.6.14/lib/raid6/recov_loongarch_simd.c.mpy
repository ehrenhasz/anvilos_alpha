{
  "module_name": "recov_loongarch_simd.c",
  "hash_id": "bd60bea033a616cec0c2c1ba067a9cc0f2914f0a5991c0ec7a7f2d3fb3fa08b2",
  "original_prompt": "Ingested from linux-6.6.14/lib/raid6/recov_loongarch_simd.c",
  "human_readable_source": "\n \n\n#include <linux/raid/pq.h>\n#include \"loongarch.h\"\n\n \n\n#ifdef CONFIG_CPU_HAS_LSX\nstatic int raid6_has_lsx(void)\n{\n\treturn cpu_has_lsx;\n}\n\nstatic void raid6_2data_recov_lsx(int disks, size_t bytes, int faila,\n\t\t\t\t  int failb, void **ptrs)\n{\n\tu8 *p, *q, *dp, *dq;\n\tconst u8 *pbmul;\t \n\tconst u8 *qmul;\t\t \n\n\tp = (u8 *)ptrs[disks - 2];\n\tq = (u8 *)ptrs[disks - 1];\n\n\t \n\tdp = (u8 *)ptrs[faila];\n\tptrs[faila] = (void *)raid6_empty_zero_page;\n\tptrs[disks - 2] = dp;\n\tdq = (u8 *)ptrs[failb];\n\tptrs[failb] = (void *)raid6_empty_zero_page;\n\tptrs[disks - 1] = dq;\n\n\traid6_call.gen_syndrome(disks, bytes, ptrs);\n\n\t \n\tptrs[faila] = dp;\n\tptrs[failb] = dq;\n\tptrs[disks - 2] = p;\n\tptrs[disks - 1] = q;\n\n\t \n\tpbmul = raid6_vgfmul[raid6_gfexi[failb - faila]];\n\tqmul  = raid6_vgfmul[raid6_gfinv[raid6_gfexp[faila] ^ raid6_gfexp[failb]]];\n\n\tkernel_fpu_begin();\n\n\t \n\tasm volatile(\"vld $vr20, %0\" : : \"m\" (qmul[0]));\n\tasm volatile(\"vld $vr21, %0\" : : \"m\" (qmul[16]));\n\tasm volatile(\"vld $vr22, %0\" : : \"m\" (pbmul[0]));\n\tasm volatile(\"vld $vr23, %0\" : : \"m\" (pbmul[16]));\n\n\twhile (bytes) {\n\t\t \n\t\tasm volatile(\"vld $vr4, %0\" : : \"m\" (q[0]));\n\t\tasm volatile(\"vld $vr5, %0\" : : \"m\" (q[16]));\n\t\tasm volatile(\"vld $vr6, %0\" : : \"m\" (q[32]));\n\t\tasm volatile(\"vld $vr7, %0\" : : \"m\" (q[48]));\n\t\t \n\t\tasm volatile(\"vld $vr8, %0\" : : \"m\" (dq[0]));\n\t\tasm volatile(\"vld $vr9, %0\" : : \"m\" (dq[16]));\n\t\tasm volatile(\"vld $vr10, %0\" : : \"m\" (dq[32]));\n\t\tasm volatile(\"vld $vr11, %0\" : : \"m\" (dq[48]));\n\t\tasm volatile(\"vxor.v $vr4, $vr4, $vr8\");\n\t\tasm volatile(\"vxor.v $vr5, $vr5, $vr9\");\n\t\tasm volatile(\"vxor.v $vr6, $vr6, $vr10\");\n\t\tasm volatile(\"vxor.v $vr7, $vr7, $vr11\");\n\t\t \n\t\tasm volatile(\"vld $vr0, %0\" : : \"m\" (p[0]));\n\t\tasm volatile(\"vld $vr1, %0\" : : \"m\" (p[16]));\n\t\tasm volatile(\"vld $vr2, %0\" : : \"m\" (p[32]));\n\t\tasm volatile(\"vld $vr3, %0\" : : \"m\" (p[48]));\n\t\t \n\t\tasm volatile(\"vld $vr8, %0\" : : \"m\" (dp[0]));\n\t\tasm volatile(\"vld $vr9, %0\" : : \"m\" (dp[16]));\n\t\tasm volatile(\"vld $vr10, %0\" : : \"m\" (dp[32]));\n\t\tasm volatile(\"vld $vr11, %0\" : : \"m\" (dp[48]));\n\t\tasm volatile(\"vxor.v $vr0, $vr0, $vr8\");\n\t\tasm volatile(\"vxor.v $vr1, $vr1, $vr9\");\n\t\tasm volatile(\"vxor.v $vr2, $vr2, $vr10\");\n\t\tasm volatile(\"vxor.v $vr3, $vr3, $vr11\");\n\n\t\t \n\t\tasm volatile(\"vsrli.b $vr8, $vr4, 4\");\n\t\tasm volatile(\"vsrli.b $vr9, $vr5, 4\");\n\t\tasm volatile(\"vsrli.b $vr10, $vr6, 4\");\n\t\tasm volatile(\"vsrli.b $vr11, $vr7, 4\");\n\t\t \n\t\tasm volatile(\"vandi.b $vr4, $vr4, 0x0f\");\n\t\tasm volatile(\"vandi.b $vr5, $vr5, 0x0f\");\n\t\tasm volatile(\"vandi.b $vr6, $vr6, 0x0f\");\n\t\tasm volatile(\"vandi.b $vr7, $vr7, 0x0f\");\n\t\t \n\t\tasm volatile(\"vshuf.b $vr4, $vr20, $vr20, $vr4\");\n\t\tasm volatile(\"vshuf.b $vr5, $vr20, $vr20, $vr5\");\n\t\tasm volatile(\"vshuf.b $vr6, $vr20, $vr20, $vr6\");\n\t\tasm volatile(\"vshuf.b $vr7, $vr20, $vr20, $vr7\");\n\t\t \n\t\tasm volatile(\"vshuf.b $vr8, $vr21, $vr21, $vr8\");\n\t\tasm volatile(\"vshuf.b $vr9, $vr21, $vr21, $vr9\");\n\t\tasm volatile(\"vshuf.b $vr10, $vr21, $vr21, $vr10\");\n\t\tasm volatile(\"vshuf.b $vr11, $vr21, $vr21, $vr11\");\n\t\t \n\t\tasm volatile(\"vxor.v $vr16, $vr8, $vr4\");\n\t\tasm volatile(\"vxor.v $vr17, $vr9, $vr5\");\n\t\tasm volatile(\"vxor.v $vr18, $vr10, $vr6\");\n\t\tasm volatile(\"vxor.v $vr19, $vr11, $vr7\");\n\n\t\t \n\t\tasm volatile(\"vsrli.b $vr4, $vr0, 4\");\n\t\tasm volatile(\"vsrli.b $vr5, $vr1, 4\");\n\t\tasm volatile(\"vsrli.b $vr6, $vr2, 4\");\n\t\tasm volatile(\"vsrli.b $vr7, $vr3, 4\");\n\t\t \n\t\tasm volatile(\"vandi.b $vr12, $vr0, 0x0f\");\n\t\tasm volatile(\"vandi.b $vr13, $vr1, 0x0f\");\n\t\tasm volatile(\"vandi.b $vr14, $vr2, 0x0f\");\n\t\tasm volatile(\"vandi.b $vr15, $vr3, 0x0f\");\n\t\t \n\t\tasm volatile(\"vshuf.b $vr12, $vr22, $vr22, $vr12\");\n\t\tasm volatile(\"vshuf.b $vr13, $vr22, $vr22, $vr13\");\n\t\tasm volatile(\"vshuf.b $vr14, $vr22, $vr22, $vr14\");\n\t\tasm volatile(\"vshuf.b $vr15, $vr22, $vr22, $vr15\");\n\t\t \n\t\tasm volatile(\"vshuf.b $vr4, $vr23, $vr23, $vr4\");\n\t\tasm volatile(\"vshuf.b $vr5, $vr23, $vr23, $vr5\");\n\t\tasm volatile(\"vshuf.b $vr6, $vr23, $vr23, $vr6\");\n\t\tasm volatile(\"vshuf.b $vr7, $vr23, $vr23, $vr7\");\n\t\t \n\t\tasm volatile(\"vxor.v $vr4, $vr4, $vr12\");\n\t\tasm volatile(\"vxor.v $vr5, $vr5, $vr13\");\n\t\tasm volatile(\"vxor.v $vr6, $vr6, $vr14\");\n\t\tasm volatile(\"vxor.v $vr7, $vr7, $vr15\");\n\n\t\t \n\t\tasm volatile(\"vxor.v $vr4, $vr4, $vr16\");\n\t\tasm volatile(\"vxor.v $vr5, $vr5, $vr17\");\n\t\tasm volatile(\"vxor.v $vr6, $vr6, $vr18\");\n\t\tasm volatile(\"vxor.v $vr7, $vr7, $vr19\");\n\t\tasm volatile(\"vst $vr4, %0\" : \"=m\" (dq[0]));\n\t\tasm volatile(\"vst $vr5, %0\" : \"=m\" (dq[16]));\n\t\tasm volatile(\"vst $vr6, %0\" : \"=m\" (dq[32]));\n\t\tasm volatile(\"vst $vr7, %0\" : \"=m\" (dq[48]));\n\n\t\t \n\t\tasm volatile(\"vxor.v $vr0, $vr0, $vr4\");\n\t\tasm volatile(\"vxor.v $vr1, $vr1, $vr5\");\n\t\tasm volatile(\"vxor.v $vr2, $vr2, $vr6\");\n\t\tasm volatile(\"vxor.v $vr3, $vr3, $vr7\");\n\t\tasm volatile(\"vst $vr0, %0\" : \"=m\" (dp[0]));\n\t\tasm volatile(\"vst $vr1, %0\" : \"=m\" (dp[16]));\n\t\tasm volatile(\"vst $vr2, %0\" : \"=m\" (dp[32]));\n\t\tasm volatile(\"vst $vr3, %0\" : \"=m\" (dp[48]));\n\n\t\tbytes -= 64;\n\t\tp += 64;\n\t\tq += 64;\n\t\tdp += 64;\n\t\tdq += 64;\n\t}\n\n\tkernel_fpu_end();\n}\n\nstatic void raid6_datap_recov_lsx(int disks, size_t bytes, int faila,\n\t\t\t\t  void **ptrs)\n{\n\tu8 *p, *q, *dq;\n\tconst u8 *qmul;\t\t \n\n\tp = (u8 *)ptrs[disks - 2];\n\tq = (u8 *)ptrs[disks - 1];\n\n\t \n\tdq = (u8 *)ptrs[faila];\n\tptrs[faila] = (void *)raid6_empty_zero_page;\n\tptrs[disks - 1] = dq;\n\n\traid6_call.gen_syndrome(disks, bytes, ptrs);\n\n\t \n\tptrs[faila] = dq;\n\tptrs[disks - 1] = q;\n\n\t \n\tqmul  = raid6_vgfmul[raid6_gfinv[raid6_gfexp[faila]]];\n\n\tkernel_fpu_begin();\n\n\t \n\tasm volatile(\"vld $vr22, %0\" : : \"m\" (qmul[0]));\n\tasm volatile(\"vld $vr23, %0\" : : \"m\" (qmul[16]));\n\n\twhile (bytes) {\n\t\t \n\t\tasm volatile(\"vld $vr0, %0\" : : \"m\" (p[0]));\n\t\tasm volatile(\"vld $vr1, %0\" : : \"m\" (p[16]));\n\t\tasm volatile(\"vld $vr2, %0\" : : \"m\" (p[32]));\n\t\tasm volatile(\"vld $vr3, %0\" : : \"m\" (p[48]));\n\t\t \n\t\tasm volatile(\"vld $vr4, %0\" : : \"m\" (dq[0]));\n\t\tasm volatile(\"vld $vr5, %0\" : : \"m\" (dq[16]));\n\t\tasm volatile(\"vld $vr6, %0\" : : \"m\" (dq[32]));\n\t\tasm volatile(\"vld $vr7, %0\" : : \"m\" (dq[48]));\n\t\t \n\t\tasm volatile(\"vld $vr8, %0\" : : \"m\" (q[0]));\n\t\tasm volatile(\"vld $vr9, %0\" : : \"m\" (q[16]));\n\t\tasm volatile(\"vld $vr10, %0\" : : \"m\" (q[32]));\n\t\tasm volatile(\"vld $vr11, %0\" : : \"m\" (q[48]));\n\t\tasm volatile(\"vxor.v $vr4, $vr4, $vr8\");\n\t\tasm volatile(\"vxor.v $vr5, $vr5, $vr9\");\n\t\tasm volatile(\"vxor.v $vr6, $vr6, $vr10\");\n\t\tasm volatile(\"vxor.v $vr7, $vr7, $vr11\");\n\n\t\t \n\t\tasm volatile(\"vsrli.b $vr8, $vr4, 4\");\n\t\tasm volatile(\"vsrli.b $vr9, $vr5, 4\");\n\t\tasm volatile(\"vsrli.b $vr10, $vr6, 4\");\n\t\tasm volatile(\"vsrli.b $vr11, $vr7, 4\");\n\t\t \n\t\tasm volatile(\"vandi.b $vr4, $vr4, 0x0f\");\n\t\tasm volatile(\"vandi.b $vr5, $vr5, 0x0f\");\n\t\tasm volatile(\"vandi.b $vr6, $vr6, 0x0f\");\n\t\tasm volatile(\"vandi.b $vr7, $vr7, 0x0f\");\n\t\t \n\t\tasm volatile(\"vshuf.b $vr4, $vr22, $vr22, $vr4\");\n\t\tasm volatile(\"vshuf.b $vr5, $vr22, $vr22, $vr5\");\n\t\tasm volatile(\"vshuf.b $vr6, $vr22, $vr22, $vr6\");\n\t\tasm volatile(\"vshuf.b $vr7, $vr22, $vr22, $vr7\");\n\t\t \n\t\tasm volatile(\"vshuf.b $vr8, $vr23, $vr23, $vr8\");\n\t\tasm volatile(\"vshuf.b $vr9, $vr23, $vr23, $vr9\");\n\t\tasm volatile(\"vshuf.b $vr10, $vr23, $vr23, $vr10\");\n\t\tasm volatile(\"vshuf.b $vr11, $vr23, $vr23, $vr11\");\n\t\t \n\t\tasm volatile(\"vxor.v $vr4, $vr4, $vr8\");\n\t\tasm volatile(\"vxor.v $vr5, $vr5, $vr9\");\n\t\tasm volatile(\"vxor.v $vr6, $vr6, $vr10\");\n\t\tasm volatile(\"vxor.v $vr7, $vr7, $vr11\");\n\t\tasm volatile(\"vst $vr4, %0\" : \"=m\" (dq[0]));\n\t\tasm volatile(\"vst $vr5, %0\" : \"=m\" (dq[16]));\n\t\tasm volatile(\"vst $vr6, %0\" : \"=m\" (dq[32]));\n\t\tasm volatile(\"vst $vr7, %0\" : \"=m\" (dq[48]));\n\n\t\t \n\t\tasm volatile(\"vxor.v $vr0, $vr0, $vr4\");\n\t\tasm volatile(\"vxor.v $vr1, $vr1, $vr5\");\n\t\tasm volatile(\"vxor.v $vr2, $vr2, $vr6\");\n\t\tasm volatile(\"vxor.v $vr3, $vr3, $vr7\");\n\t\tasm volatile(\"vst $vr0, %0\" : \"=m\" (p[0]));\n\t\tasm volatile(\"vst $vr1, %0\" : \"=m\" (p[16]));\n\t\tasm volatile(\"vst $vr2, %0\" : \"=m\" (p[32]));\n\t\tasm volatile(\"vst $vr3, %0\" : \"=m\" (p[48]));\n\n\t\tbytes -= 64;\n\t\tp += 64;\n\t\tq += 64;\n\t\tdq += 64;\n\t}\n\n\tkernel_fpu_end();\n}\n\nconst struct raid6_recov_calls raid6_recov_lsx = {\n\t.data2 = raid6_2data_recov_lsx,\n\t.datap = raid6_datap_recov_lsx,\n\t.valid = raid6_has_lsx,\n\t.name = \"lsx\",\n\t.priority = 1,\n};\n#endif  \n\n#ifdef CONFIG_CPU_HAS_LASX\nstatic int raid6_has_lasx(void)\n{\n\treturn cpu_has_lasx;\n}\n\nstatic void raid6_2data_recov_lasx(int disks, size_t bytes, int faila,\n\t\t\t\t   int failb, void **ptrs)\n{\n\tu8 *p, *q, *dp, *dq;\n\tconst u8 *pbmul;\t \n\tconst u8 *qmul;\t\t \n\n\tp = (u8 *)ptrs[disks - 2];\n\tq = (u8 *)ptrs[disks - 1];\n\n\t \n\tdp = (u8 *)ptrs[faila];\n\tptrs[faila] = (void *)raid6_empty_zero_page;\n\tptrs[disks - 2] = dp;\n\tdq = (u8 *)ptrs[failb];\n\tptrs[failb] = (void *)raid6_empty_zero_page;\n\tptrs[disks - 1] = dq;\n\n\traid6_call.gen_syndrome(disks, bytes, ptrs);\n\n\t \n\tptrs[faila] = dp;\n\tptrs[failb] = dq;\n\tptrs[disks - 2] = p;\n\tptrs[disks - 1] = q;\n\n\t \n\tpbmul = raid6_vgfmul[raid6_gfexi[failb - faila]];\n\tqmul  = raid6_vgfmul[raid6_gfinv[raid6_gfexp[faila] ^ raid6_gfexp[failb]]];\n\n\tkernel_fpu_begin();\n\n\t \n\tasm volatile(\"vld $vr20, %0\" : : \"m\" (qmul[0]));\n\tasm volatile(\"vld $vr21, %0\" : : \"m\" (qmul[16]));\n\tasm volatile(\"vld $vr22, %0\" : : \"m\" (pbmul[0]));\n\tasm volatile(\"vld $vr23, %0\" : : \"m\" (pbmul[16]));\n\tasm volatile(\"xvreplve0.q $xr20, $xr20\");\n\tasm volatile(\"xvreplve0.q $xr21, $xr21\");\n\tasm volatile(\"xvreplve0.q $xr22, $xr22\");\n\tasm volatile(\"xvreplve0.q $xr23, $xr23\");\n\n\twhile (bytes) {\n\t\t \n\t\tasm volatile(\"xvld $xr0, %0\" : : \"m\" (q[0]));\n\t\tasm volatile(\"xvld $xr1, %0\" : : \"m\" (q[32]));\n\t\t \n\t\tasm volatile(\"xvld $xr4, %0\" : : \"m\" (dq[0]));\n\t\tasm volatile(\"xvld $xr5, %0\" : : \"m\" (dq[32]));\n\t\tasm volatile(\"xvxor.v $xr0, $xr0, $xr4\");\n\t\tasm volatile(\"xvxor.v $xr1, $xr1, $xr5\");\n\t\t \n\t\tasm volatile(\"xvld $xr2, %0\" : : \"m\" (p[0]));\n\t\tasm volatile(\"xvld $xr3, %0\" : : \"m\" (p[32]));\n\t\t \n\t\tasm volatile(\"xvld $xr4, %0\" : : \"m\" (dp[0]));\n\t\tasm volatile(\"xvld $xr5, %0\" : : \"m\" (dp[32]));\n\t\tasm volatile(\"xvxor.v $xr2, $xr2, $xr4\");\n\t\tasm volatile(\"xvxor.v $xr3, $xr3, $xr5\");\n\n\t\t \n\t\tasm volatile(\"xvsrli.b $xr4, $xr0, 4\");\n\t\tasm volatile(\"xvsrli.b $xr5, $xr1, 4\");\n\t\t \n\t\tasm volatile(\"xvandi.b $xr0, $xr0, 0x0f\");\n\t\tasm volatile(\"xvandi.b $xr1, $xr1, 0x0f\");\n\t\t \n\t\tasm volatile(\"xvshuf.b $xr0, $xr20, $xr20, $xr0\");\n\t\tasm volatile(\"xvshuf.b $xr1, $xr20, $xr20, $xr1\");\n\t\t \n\t\tasm volatile(\"xvshuf.b $xr4, $xr21, $xr21, $xr4\");\n\t\tasm volatile(\"xvshuf.b $xr5, $xr21, $xr21, $xr5\");\n\t\t \n\t\tasm volatile(\"xvxor.v $xr6, $xr4, $xr0\");\n\t\tasm volatile(\"xvxor.v $xr7, $xr5, $xr1\");\n\n\t\t \n\t\tasm volatile(\"xvsrli.b $xr4, $xr2, 4\");\n\t\tasm volatile(\"xvsrli.b $xr5, $xr3, 4\");\n\t\t \n\t\tasm volatile(\"xvandi.b $xr0, $xr2, 0x0f\");\n\t\tasm volatile(\"xvandi.b $xr1, $xr3, 0x0f\");\n\t\t \n\t\tasm volatile(\"xvshuf.b $xr0, $xr22, $xr22, $xr0\");\n\t\tasm volatile(\"xvshuf.b $xr1, $xr22, $xr22, $xr1\");\n\t\t \n\t\tasm volatile(\"xvshuf.b $xr4, $xr23, $xr23, $xr4\");\n\t\tasm volatile(\"xvshuf.b $xr5, $xr23, $xr23, $xr5\");\n\t\t \n\t\tasm volatile(\"xvxor.v $xr0, $xr0, $xr4\");\n\t\tasm volatile(\"xvxor.v $xr1, $xr1, $xr5\");\n\n\t\t \n\t\tasm volatile(\"xvxor.v $xr0, $xr0, $xr6\");\n\t\tasm volatile(\"xvxor.v $xr1, $xr1, $xr7\");\n\n\t\t \n\t\tasm volatile(\"xvxor.v $xr2, $xr2, $xr0\");\n\t\tasm volatile(\"xvxor.v $xr3, $xr3, $xr1\");\n\n\t\tasm volatile(\"xvst $xr0, %0\" : \"=m\" (dq[0]));\n\t\tasm volatile(\"xvst $xr1, %0\" : \"=m\" (dq[32]));\n\t\tasm volatile(\"xvst $xr2, %0\" : \"=m\" (dp[0]));\n\t\tasm volatile(\"xvst $xr3, %0\" : \"=m\" (dp[32]));\n\n\t\tbytes -= 64;\n\t\tp += 64;\n\t\tq += 64;\n\t\tdp += 64;\n\t\tdq += 64;\n\t}\n\n\tkernel_fpu_end();\n}\n\nstatic void raid6_datap_recov_lasx(int disks, size_t bytes, int faila,\n\t\t\t\t   void **ptrs)\n{\n\tu8 *p, *q, *dq;\n\tconst u8 *qmul;\t\t \n\n\tp = (u8 *)ptrs[disks - 2];\n\tq = (u8 *)ptrs[disks - 1];\n\n\t \n\tdq = (u8 *)ptrs[faila];\n\tptrs[faila] = (void *)raid6_empty_zero_page;\n\tptrs[disks - 1] = dq;\n\n\traid6_call.gen_syndrome(disks, bytes, ptrs);\n\n\t \n\tptrs[faila] = dq;\n\tptrs[disks - 1] = q;\n\n\t \n\tqmul  = raid6_vgfmul[raid6_gfinv[raid6_gfexp[faila]]];\n\n\tkernel_fpu_begin();\n\n\t \n\tasm volatile(\"vld $vr22, %0\" : : \"m\" (qmul[0]));\n\tasm volatile(\"xvreplve0.q $xr22, $xr22\");\n\tasm volatile(\"vld $vr23, %0\" : : \"m\" (qmul[16]));\n\tasm volatile(\"xvreplve0.q $xr23, $xr23\");\n\n\twhile (bytes) {\n\t\t \n\t\tasm volatile(\"xvld $xr0, %0\" : : \"m\" (p[0]));\n\t\tasm volatile(\"xvld $xr1, %0\" : : \"m\" (p[32]));\n\t\t \n\t\tasm volatile(\"xvld $xr2, %0\" : : \"m\" (dq[0]));\n\t\tasm volatile(\"xvld $xr3, %0\" : : \"m\" (dq[32]));\n\t\t \n\t\tasm volatile(\"xvld $xr4, %0\" : : \"m\" (q[0]));\n\t\tasm volatile(\"xvld $xr5, %0\" : : \"m\" (q[32]));\n\t\tasm volatile(\"xvxor.v $xr2, $xr2, $xr4\");\n\t\tasm volatile(\"xvxor.v $xr3, $xr3, $xr5\");\n\n\t\t \n\t\tasm volatile(\"xvsrli.b $xr4, $xr2, 4\");\n\t\tasm volatile(\"xvsrli.b $xr5, $xr3, 4\");\n\t\t \n\t\tasm volatile(\"xvandi.b $xr2, $xr2, 0x0f\");\n\t\tasm volatile(\"xvandi.b $xr3, $xr3, 0x0f\");\n\t\t \n\t\tasm volatile(\"xvshuf.b $xr2, $xr22, $xr22, $xr2\");\n\t\tasm volatile(\"xvshuf.b $xr3, $xr22, $xr22, $xr3\");\n\t\t \n\t\tasm volatile(\"xvshuf.b $xr4, $xr23, $xr23, $xr4\");\n\t\tasm volatile(\"xvshuf.b $xr5, $xr23, $xr23, $xr5\");\n\t\t \n\t\tasm volatile(\"xvxor.v $xr2, $xr2, $xr4\");\n\t\tasm volatile(\"xvxor.v $xr3, $xr3, $xr5\");\n\n\t\t \n\t\tasm volatile(\"xvxor.v $xr0, $xr0, $xr2\");\n\t\tasm volatile(\"xvxor.v $xr1, $xr1, $xr3\");\n\n\t\tasm volatile(\"xvst $xr2, %0\" : \"=m\" (dq[0]));\n\t\tasm volatile(\"xvst $xr3, %0\" : \"=m\" (dq[32]));\n\t\tasm volatile(\"xvst $xr0, %0\" : \"=m\" (p[0]));\n\t\tasm volatile(\"xvst $xr1, %0\" : \"=m\" (p[32]));\n\n\t\tbytes -= 64;\n\t\tp += 64;\n\t\tq += 64;\n\t\tdq += 64;\n\t}\n\n\tkernel_fpu_end();\n}\n\nconst struct raid6_recov_calls raid6_recov_lasx = {\n\t.data2 = raid6_2data_recov_lasx,\n\t.datap = raid6_datap_recov_lasx,\n\t.valid = raid6_has_lasx,\n\t.name = \"lasx\",\n\t.priority = 2,\n};\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}