{
  "module_name": "int.uc",
  "hash_id": "5575f29ea4391e40f9cc2ee13ce45a9f32ad40a5e3aaee0bc2434c5d487e4efe",
  "original_prompt": "Ingested from linux-6.6.14/lib/raid6/int.uc",
  "human_readable_source": "/* -*- linux-c -*- ------------------------------------------------------- *\n *\n *   Copyright 2002-2004 H. Peter Anvin - All Rights Reserved\n *\n *   This program is free software; you can redistribute it and/or modify\n *   it under the terms of the GNU General Public License as published by\n *   the Free Software Foundation, Inc., 53 Temple Place Ste 330,\n *   Boston MA 02111-1307, USA; either version 2 of the License, or\n *   (at your option) any later version; incorporated herein by reference.\n *\n * ----------------------------------------------------------------------- */\n\n/*\n * int$#.c\n *\n * $#-way unrolled portable integer math RAID-6 instruction set\n *\n * This file is postprocessed using unroll.awk\n */\n\n#include <linux/raid/pq.h>\n\n/*\n * This is the C data type to use\n */\n\n/* Change this from BITS_PER_LONG if there is something better... */\n#if BITS_PER_LONG == 64\n# define NBYTES(x) ((x) * 0x0101010101010101UL)\n# define NSIZE  8\n# define NSHIFT 3\n# define NSTRING \"64\"\ntypedef u64 unative_t;\n#else\n# define NBYTES(x) ((x) * 0x01010101U)\n# define NSIZE  4\n# define NSHIFT 2\n# define NSTRING \"32\"\ntypedef u32 unative_t;\n#endif\n\n\n\n/*\n * IA-64 wants insane amounts of unrolling.  On other architectures that\n * is just a waste of space.\n */\n#if ($# <= 8) || defined(__ia64__)\n\n\n/*\n * These sub-operations are separate inlines since they can sometimes be\n * specially optimized using architecture-specific hacks.\n */\n\n/*\n * The SHLBYTE() operation shifts each byte left by 1, *not*\n * rolling over into the next byte\n */\nstatic inline __attribute_const__ unative_t SHLBYTE(unative_t v)\n{\n\tunative_t vv;\n\n\tvv = (v << 1) & NBYTES(0xfe);\n\treturn vv;\n}\n\n/*\n * The MASK() operation returns 0xFF in any byte for which the high\n * bit is 1, 0x00 for any byte for which the high bit is 0.\n */\nstatic inline __attribute_const__ unative_t MASK(unative_t v)\n{\n\tunative_t vv;\n\n\tvv = v & NBYTES(0x80);\n\tvv = (vv << 1) - (vv >> 7); /* Overflow on the top bit is OK */\n\treturn vv;\n}\n\n\nstatic void raid6_int$#_gen_syndrome(int disks, size_t bytes, void **ptrs)\n{\n\tu8 **dptr = (u8 **)ptrs;\n\tu8 *p, *q;\n\tint d, z, z0;\n\n\tunative_t wd$$, wq$$, wp$$, w1$$, w2$$;\n\n\tz0 = disks - 3;\t\t/* Highest data disk */\n\tp = dptr[z0+1];\t\t/* XOR parity */\n\tq = dptr[z0+2];\t\t/* RS syndrome */\n\n\tfor ( d = 0 ; d < bytes ; d += NSIZE*$# ) {\n\t\twq$$ = wp$$ = *(unative_t *)&dptr[z0][d+$$*NSIZE];\n\t\tfor ( z = z0-1 ; z >= 0 ; z-- ) {\n\t\t\twd$$ = *(unative_t *)&dptr[z][d+$$*NSIZE];\n\t\t\twp$$ ^= wd$$;\n\t\t\tw2$$ = MASK(wq$$);\n\t\t\tw1$$ = SHLBYTE(wq$$);\n\t\t\tw2$$ &= NBYTES(0x1d);\n\t\t\tw1$$ ^= w2$$;\n\t\t\twq$$ = w1$$ ^ wd$$;\n\t\t}\n\t\t*(unative_t *)&p[d+NSIZE*$$] = wp$$;\n\t\t*(unative_t *)&q[d+NSIZE*$$] = wq$$;\n\t}\n}\n\nstatic void raid6_int$#_xor_syndrome(int disks, int start, int stop,\n\t\t\t\t     size_t bytes, void **ptrs)\n{\n\tu8 **dptr = (u8 **)ptrs;\n\tu8 *p, *q;\n\tint d, z, z0;\n\n\tunative_t wd$$, wq$$, wp$$, w1$$, w2$$;\n\n\tz0 = stop;\t\t/* P/Q right side optimization */\n\tp = dptr[disks-2];\t/* XOR parity */\n\tq = dptr[disks-1];\t/* RS syndrome */\n\n\tfor ( d = 0 ; d < bytes ; d += NSIZE*$# ) {\n\t\t/* P/Q data pages */\n\t\twq$$ = wp$$ = *(unative_t *)&dptr[z0][d+$$*NSIZE];\n\t\tfor ( z = z0-1 ; z >= start ; z-- ) {\n\t\t\twd$$ = *(unative_t *)&dptr[z][d+$$*NSIZE];\n\t\t\twp$$ ^= wd$$;\n\t\t\tw2$$ = MASK(wq$$);\n\t\t\tw1$$ = SHLBYTE(wq$$);\n\t\t\tw2$$ &= NBYTES(0x1d);\n\t\t\tw1$$ ^= w2$$;\n\t\t\twq$$ = w1$$ ^ wd$$;\n\t\t}\n\t\t/* P/Q left side optimization */\n\t\tfor ( z = start-1 ; z >= 0 ; z-- ) {\n\t\t\tw2$$ = MASK(wq$$);\n\t\t\tw1$$ = SHLBYTE(wq$$);\n\t\t\tw2$$ &= NBYTES(0x1d);\n\t\t\twq$$ = w1$$ ^ w2$$;\n\t\t}\n\t\t*(unative_t *)&p[d+NSIZE*$$] ^= wp$$;\n\t\t*(unative_t *)&q[d+NSIZE*$$] ^= wq$$;\n\t}\n\n}\n\nconst struct raid6_calls raid6_intx$# = {\n\traid6_int$#_gen_syndrome,\n\traid6_int$#_xor_syndrome,\n\tNULL,\t\t\t/* always valid */\n\t\"int\" NSTRING \"x$#\",\n\t0\n};\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}