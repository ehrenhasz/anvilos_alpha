{
  "module_name": "s390vx.uc",
  "hash_id": "b10b9e4c5d7495918697d19761f45a2d2e7ba8d202f7d580353844dc114cc46d",
  "original_prompt": "Ingested from linux-6.6.14/lib/raid6/s390vx.uc",
  "human_readable_source": "// SPDX-License-Identifier: GPL-2.0\n/*\n * raid6_vx$#.c\n *\n * $#-way unrolled RAID6 gen/xor functions for s390\n * based on the vector facility\n *\n * Copyright IBM Corp. 2016\n * Author(s): Martin Schwidefsky <schwidefsky@de.ibm.com>\n *\n * This file is postprocessed using unroll.awk.\n */\n\n#include <linux/raid/pq.h>\n#include <asm/fpu/api.h>\n#include <asm/vx-insn.h>\n\n#define NSIZE 16\n\nstatic inline void LOAD_CONST(void)\n{\n\tasm volatile(\"VREPIB %v24,7\");\n\tasm volatile(\"VREPIB %v25,0x1d\");\n}\n\n/*\n * The SHLBYTE() operation shifts each of the 16 bytes in\n * vector register y left by 1 bit and stores the result in\n * vector register x.\n */\nstatic inline void SHLBYTE(int x, int y)\n{\n\tasm volatile (\"VAB %0,%1,%1\" : : \"i\" (x), \"i\" (y));\n}\n\n/*\n * For each of the 16 bytes in the vector register y the MASK()\n * operation returns 0xFF if the high bit of the byte is 1,\n * or 0x00 if the high bit is 0. The result is stored in vector\n * register x.\n */\nstatic inline void MASK(int x, int y)\n{\n\tasm volatile (\"VESRAVB\t%0,%1,24\" : : \"i\" (x), \"i\" (y));\n}\n\nstatic inline void AND(int x, int y, int z)\n{\n\tasm volatile (\"VN %0,%1,%2\" : : \"i\" (x), \"i\" (y), \"i\" (z));\n}\n\nstatic inline void XOR(int x, int y, int z)\n{\n\tasm volatile (\"VX %0,%1,%2\" : : \"i\" (x), \"i\" (y), \"i\" (z));\n}\n\nstatic inline void LOAD_DATA(int x, u8 *ptr)\n{\n\ttypedef struct { u8 _[16 * $#]; } addrtype;\n\tregister addrtype *__ptr asm(\"1\") = (addrtype *) ptr;\n\n\tasm volatile (\"VLM %2,%3,0,%1\"\n\t\t      : : \"m\" (*__ptr), \"a\" (__ptr), \"i\" (x),\n\t\t\t  \"i\" (x + $# - 1));\n}\n\nstatic inline void STORE_DATA(int x, u8 *ptr)\n{\n\ttypedef struct { u8 _[16 * $#]; } addrtype;\n\tregister addrtype *__ptr asm(\"1\") = (addrtype *) ptr;\n\n\tasm volatile (\"VSTM %2,%3,0,1\"\n\t\t      : \"=m\" (*__ptr) : \"a\" (__ptr), \"i\" (x),\n\t\t\t\"i\" (x + $# - 1));\n}\n\nstatic inline void COPY_VEC(int x, int y)\n{\n\tasm volatile (\"VLR %0,%1\" : : \"i\" (x), \"i\" (y));\n}\n\nstatic void raid6_s390vx$#_gen_syndrome(int disks, size_t bytes, void **ptrs)\n{\n\tstruct kernel_fpu vxstate;\n\tu8 **dptr, *p, *q;\n\tint d, z, z0;\n\n\tkernel_fpu_begin(&vxstate, KERNEL_VXR);\n\tLOAD_CONST();\n\n\tdptr = (u8 **) ptrs;\n\tz0 = disks - 3;\t\t/* Highest data disk */\n\tp = dptr[z0 + 1];\t/* XOR parity */\n\tq = dptr[z0 + 2];\t/* RS syndrome */\n\n\tfor (d = 0; d < bytes; d += $#*NSIZE) {\n\t\tLOAD_DATA(0,&dptr[z0][d]);\n\t\tCOPY_VEC(8+$$,0+$$);\n\t\tfor (z = z0 - 1; z >= 0; z--) {\n\t\t\tMASK(16+$$,8+$$);\n\t\t\tAND(16+$$,16+$$,25);\n\t\t\tSHLBYTE(8+$$,8+$$);\n\t\t\tXOR(8+$$,8+$$,16+$$);\n\t\t\tLOAD_DATA(16,&dptr[z][d]);\n\t\t\tXOR(0+$$,0+$$,16+$$);\n\t\t\tXOR(8+$$,8+$$,16+$$);\n\t\t}\n\t\tSTORE_DATA(0,&p[d]);\n\t\tSTORE_DATA(8,&q[d]);\n\t}\n\tkernel_fpu_end(&vxstate, KERNEL_VXR);\n}\n\nstatic void raid6_s390vx$#_xor_syndrome(int disks, int start, int stop,\n\t\t\t\t\tsize_t bytes, void **ptrs)\n{\n\tstruct kernel_fpu vxstate;\n\tu8 **dptr, *p, *q;\n\tint d, z, z0;\n\n\tdptr = (u8 **) ptrs;\n\tz0 = stop;\t\t/* P/Q right side optimization */\n\tp = dptr[disks - 2];\t/* XOR parity */\n\tq = dptr[disks - 1];\t/* RS syndrome */\n\n\tkernel_fpu_begin(&vxstate, KERNEL_VXR);\n\tLOAD_CONST();\n\n\tfor (d = 0; d < bytes; d += $#*NSIZE) {\n\t\t/* P/Q data pages */\n\t\tLOAD_DATA(0,&dptr[z0][d]);\n\t\tCOPY_VEC(8+$$,0+$$);\n\t\tfor (z = z0 - 1; z >= start; z--) {\n\t\t\tMASK(16+$$,8+$$);\n\t\t\tAND(16+$$,16+$$,25);\n\t\t\tSHLBYTE(8+$$,8+$$);\n\t\t\tXOR(8+$$,8+$$,16+$$);\n\t\t\tLOAD_DATA(16,&dptr[z][d]);\n\t\t\tXOR(0+$$,0+$$,16+$$);\n\t\t\tXOR(8+$$,8+$$,16+$$);\n\t\t}\n\t\t/* P/Q left side optimization */\n\t\tfor (z = start - 1; z >= 0; z--) {\n\t\t\tMASK(16+$$,8+$$);\n\t\t\tAND(16+$$,16+$$,25);\n\t\t\tSHLBYTE(8+$$,8+$$);\n\t\t\tXOR(8+$$,8+$$,16+$$);\n\t\t}\n\t\tLOAD_DATA(16,&p[d]);\n\t\tXOR(16+$$,16+$$,0+$$);\n\t\tSTORE_DATA(16,&p[d]);\n\t\tLOAD_DATA(16,&q[d]);\n\t\tXOR(16+$$,16+$$,8+$$);\n\t\tSTORE_DATA(16,&q[d]);\n\t}\n\tkernel_fpu_end(&vxstate, KERNEL_VXR);\n}\n\nstatic int raid6_s390vx$#_valid(void)\n{\n\treturn MACHINE_HAS_VX;\n}\n\nconst struct raid6_calls raid6_s390vx$# = {\n\traid6_s390vx$#_gen_syndrome,\n\traid6_s390vx$#_xor_syndrome,\n\traid6_s390vx$#_valid,\n\t\"vx128x$#\",\n\t1\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}