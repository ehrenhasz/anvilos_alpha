{
  "module_name": "neon.uc",
  "hash_id": "3a9565edf1fba353588e532a3f929112ab84d2fc14f166f33a2c06dd121eeb5f",
  "original_prompt": "Ingested from linux-6.6.14/lib/raid6/neon.uc",
  "human_readable_source": "/* -----------------------------------------------------------------------\n *\n *   neon.uc - RAID-6 syndrome calculation using ARM NEON instructions\n *\n *   Copyright (C) 2012 Rob Herring\n *   Copyright (C) 2015 Linaro Ltd. <ard.biesheuvel@linaro.org>\n *\n *   Based on altivec.uc:\n *     Copyright 2002-2004 H. Peter Anvin - All Rights Reserved\n *\n *   This program is free software; you can redistribute it and/or modify\n *   it under the terms of the GNU General Public License as published by\n *   the Free Software Foundation, Inc., 53 Temple Place Ste 330,\n *   Boston MA 02111-1307, USA; either version 2 of the License, or\n *   (at your option) any later version; incorporated herein by reference.\n *\n * ----------------------------------------------------------------------- */\n\n/*\n * neon$#.c\n *\n * $#-way unrolled NEON intrinsics math RAID-6 instruction set\n *\n * This file is postprocessed using unroll.awk\n */\n\n#include <arm_neon.h>\n#include \"neon.h\"\n\ntypedef uint8x16_t unative_t;\n\n#define NSIZE\tsizeof(unative_t)\n\n/*\n * The SHLBYTE() operation shifts each byte left by 1, *not*\n * rolling over into the next byte\n */\nstatic inline unative_t SHLBYTE(unative_t v)\n{\n\treturn vshlq_n_u8(v, 1);\n}\n\n/*\n * The MASK() operation returns 0xFF in any byte for which the high\n * bit is 1, 0x00 for any byte for which the high bit is 0.\n */\nstatic inline unative_t MASK(unative_t v)\n{\n\treturn (unative_t)vshrq_n_s8((int8x16_t)v, 7);\n}\n\nstatic inline unative_t PMUL(unative_t v, unative_t u)\n{\n\treturn (unative_t)vmulq_p8((poly8x16_t)v, (poly8x16_t)u);\n}\n\nvoid raid6_neon$#_gen_syndrome_real(int disks, unsigned long bytes, void **ptrs)\n{\n\tuint8_t **dptr = (uint8_t **)ptrs;\n\tuint8_t *p, *q;\n\tint d, z, z0;\n\n\tregister unative_t wd$$, wq$$, wp$$, w1$$, w2$$;\n\tconst unative_t x1d = vdupq_n_u8(0x1d);\n\n\tz0 = disks - 3;\t\t/* Highest data disk */\n\tp = dptr[z0+1];\t\t/* XOR parity */\n\tq = dptr[z0+2];\t\t/* RS syndrome */\n\n\tfor ( d = 0 ; d < bytes ; d += NSIZE*$# ) {\n\t\twq$$ = wp$$ = vld1q_u8(&dptr[z0][d+$$*NSIZE]);\n\t\tfor ( z = z0-1 ; z >= 0 ; z-- ) {\n\t\t\twd$$ = vld1q_u8(&dptr[z][d+$$*NSIZE]);\n\t\t\twp$$ = veorq_u8(wp$$, wd$$);\n\t\t\tw2$$ = MASK(wq$$);\n\t\t\tw1$$ = SHLBYTE(wq$$);\n\n\t\t\tw2$$ = vandq_u8(w2$$, x1d);\n\t\t\tw1$$ = veorq_u8(w1$$, w2$$);\n\t\t\twq$$ = veorq_u8(w1$$, wd$$);\n\t\t}\n\t\tvst1q_u8(&p[d+NSIZE*$$], wp$$);\n\t\tvst1q_u8(&q[d+NSIZE*$$], wq$$);\n\t}\n}\n\nvoid raid6_neon$#_xor_syndrome_real(int disks, int start, int stop,\n\t\t\t\t    unsigned long bytes, void **ptrs)\n{\n\tuint8_t **dptr = (uint8_t **)ptrs;\n\tuint8_t *p, *q;\n\tint d, z, z0;\n\n\tregister unative_t wd$$, wq$$, wp$$, w1$$, w2$$;\n\tconst unative_t x1d = vdupq_n_u8(0x1d);\n\n\tz0 = stop;\t\t/* P/Q right side optimization */\n\tp = dptr[disks-2];\t/* XOR parity */\n\tq = dptr[disks-1];\t/* RS syndrome */\n\n\tfor ( d = 0 ; d < bytes ; d += NSIZE*$# ) {\n\t\twq$$ = vld1q_u8(&dptr[z0][d+$$*NSIZE]);\n\t\twp$$ = veorq_u8(vld1q_u8(&p[d+$$*NSIZE]), wq$$);\n\n\t\t/* P/Q data pages */\n\t\tfor ( z = z0-1 ; z >= start ; z-- ) {\n\t\t\twd$$ = vld1q_u8(&dptr[z][d+$$*NSIZE]);\n\t\t\twp$$ = veorq_u8(wp$$, wd$$);\n\t\t\tw2$$ = MASK(wq$$);\n\t\t\tw1$$ = SHLBYTE(wq$$);\n\n\t\t\tw2$$ = vandq_u8(w2$$, x1d);\n\t\t\tw1$$ = veorq_u8(w1$$, w2$$);\n\t\t\twq$$ = veorq_u8(w1$$, wd$$);\n\t\t}\n\t\t/* P/Q left side optimization */\n\t\tfor ( z = start-1 ; z >= 3 ; z -= 4 ) {\n\t\t\tw2$$ = vshrq_n_u8(wq$$, 4);\n\t\t\tw1$$ = vshlq_n_u8(wq$$, 4);\n\n\t\t\tw2$$ = PMUL(w2$$, x1d);\n\t\t\twq$$ = veorq_u8(w1$$, w2$$);\n\t\t}\n\n\t\tswitch (z) {\n\t\tcase 2:\n\t\t\tw2$$ = vshrq_n_u8(wq$$, 5);\n\t\t\tw1$$ = vshlq_n_u8(wq$$, 3);\n\n\t\t\tw2$$ = PMUL(w2$$, x1d);\n\t\t\twq$$ = veorq_u8(w1$$, w2$$);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tw2$$ = vshrq_n_u8(wq$$, 6);\n\t\t\tw1$$ = vshlq_n_u8(wq$$, 2);\n\n\t\t\tw2$$ = PMUL(w2$$, x1d);\n\t\t\twq$$ = veorq_u8(w1$$, w2$$);\n\t\t\tbreak;\n\t\tcase 0:\n\t\t\tw2$$ = MASK(wq$$);\n\t\t\tw1$$ = SHLBYTE(wq$$);\n\n\t\t\tw2$$ = vandq_u8(w2$$, x1d);\n\t\t\twq$$ = veorq_u8(w1$$, w2$$);\n\t\t}\n\t\tw1$$ = vld1q_u8(&q[d+NSIZE*$$]);\n\t\twq$$ = veorq_u8(wq$$, w1$$);\n\n\t\tvst1q_u8(&p[d+NSIZE*$$], wp$$);\n\t\tvst1q_u8(&q[d+NSIZE*$$], wq$$);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}