{
  "module_name": "mmx.c",
  "hash_id": "a4df52afc71ec503f8c4ef49d04bb33bcd31e1a8f145e4c973273cfe2fd9ad19",
  "original_prompt": "Ingested from linux-6.6.14/lib/raid6/mmx.c",
  "human_readable_source": "\n \n\n \n\n#ifdef CONFIG_X86_32\n\n#include <linux/raid/pq.h>\n#include \"x86.h\"\n\n \nconst struct raid6_mmx_constants {\n\tu64 x1d;\n} raid6_mmx_constants = {\n\t0x1d1d1d1d1d1d1d1dULL,\n};\n\nstatic int raid6_have_mmx(void)\n{\n\t \n\treturn boot_cpu_has(X86_FEATURE_MMX);\n}\n\n \nstatic void raid6_mmx1_gen_syndrome(int disks, size_t bytes, void **ptrs)\n{\n\tu8 **dptr = (u8 **)ptrs;\n\tu8 *p, *q;\n\tint d, z, z0;\n\n\tz0 = disks - 3;\t\t \n\tp = dptr[z0+1];\t\t \n\tq = dptr[z0+2];\t\t \n\n\tkernel_fpu_begin();\n\n\tasm volatile(\"movq %0,%%mm0\" : : \"m\" (raid6_mmx_constants.x1d));\n\tasm volatile(\"pxor %mm5,%mm5\");\t \n\n\tfor ( d = 0 ; d < bytes ; d += 8 ) {\n\t\tasm volatile(\"movq %0,%%mm2\" : : \"m\" (dptr[z0][d]));  \n\t\tasm volatile(\"movq %mm2,%mm4\");\t \n\t\tfor ( z = z0-1 ; z >= 0 ; z-- ) {\n\t\t\tasm volatile(\"movq %0,%%mm6\" : : \"m\" (dptr[z][d]));\n\t\t\tasm volatile(\"pcmpgtb %mm4,%mm5\");\n\t\t\tasm volatile(\"paddb %mm4,%mm4\");\n\t\t\tasm volatile(\"pand %mm0,%mm5\");\n\t\t\tasm volatile(\"pxor %mm5,%mm4\");\n\t\t\tasm volatile(\"pxor %mm5,%mm5\");\n\t\t\tasm volatile(\"pxor %mm6,%mm2\");\n\t\t\tasm volatile(\"pxor %mm6,%mm4\");\n\t\t}\n\t\tasm volatile(\"movq %%mm2,%0\" : \"=m\" (p[d]));\n\t\tasm volatile(\"pxor %mm2,%mm2\");\n\t\tasm volatile(\"movq %%mm4,%0\" : \"=m\" (q[d]));\n\t\tasm volatile(\"pxor %mm4,%mm4\");\n\t}\n\n\tkernel_fpu_end();\n}\n\nconst struct raid6_calls raid6_mmxx1 = {\n\traid6_mmx1_gen_syndrome,\n\tNULL,\t\t\t \n\traid6_have_mmx,\n\t\"mmxx1\",\n\t0\n};\n\n \nstatic void raid6_mmx2_gen_syndrome(int disks, size_t bytes, void **ptrs)\n{\n\tu8 **dptr = (u8 **)ptrs;\n\tu8 *p, *q;\n\tint d, z, z0;\n\n\tz0 = disks - 3;\t\t \n\tp = dptr[z0+1];\t\t \n\tq = dptr[z0+2];\t\t \n\n\tkernel_fpu_begin();\n\n\tasm volatile(\"movq %0,%%mm0\" : : \"m\" (raid6_mmx_constants.x1d));\n\tasm volatile(\"pxor %mm5,%mm5\");\t \n\tasm volatile(\"pxor %mm7,%mm7\");  \n\n\tfor ( d = 0 ; d < bytes ; d += 16 ) {\n\t\tasm volatile(\"movq %0,%%mm2\" : : \"m\" (dptr[z0][d]));  \n\t\tasm volatile(\"movq %0,%%mm3\" : : \"m\" (dptr[z0][d+8]));\n\t\tasm volatile(\"movq %mm2,%mm4\");  \n\t\tasm volatile(\"movq %mm3,%mm6\");  \n\t\tfor ( z = z0-1 ; z >= 0 ; z-- ) {\n\t\t\tasm volatile(\"pcmpgtb %mm4,%mm5\");\n\t\t\tasm volatile(\"pcmpgtb %mm6,%mm7\");\n\t\t\tasm volatile(\"paddb %mm4,%mm4\");\n\t\t\tasm volatile(\"paddb %mm6,%mm6\");\n\t\t\tasm volatile(\"pand %mm0,%mm5\");\n\t\t\tasm volatile(\"pand %mm0,%mm7\");\n\t\t\tasm volatile(\"pxor %mm5,%mm4\");\n\t\t\tasm volatile(\"pxor %mm7,%mm6\");\n\t\t\tasm volatile(\"movq %0,%%mm5\" : : \"m\" (dptr[z][d]));\n\t\t\tasm volatile(\"movq %0,%%mm7\" : : \"m\" (dptr[z][d+8]));\n\t\t\tasm volatile(\"pxor %mm5,%mm2\");\n\t\t\tasm volatile(\"pxor %mm7,%mm3\");\n\t\t\tasm volatile(\"pxor %mm5,%mm4\");\n\t\t\tasm volatile(\"pxor %mm7,%mm6\");\n\t\t\tasm volatile(\"pxor %mm5,%mm5\");\n\t\t\tasm volatile(\"pxor %mm7,%mm7\");\n\t\t}\n\t\tasm volatile(\"movq %%mm2,%0\" : \"=m\" (p[d]));\n\t\tasm volatile(\"movq %%mm3,%0\" : \"=m\" (p[d+8]));\n\t\tasm volatile(\"movq %%mm4,%0\" : \"=m\" (q[d]));\n\t\tasm volatile(\"movq %%mm6,%0\" : \"=m\" (q[d+8]));\n\t}\n\n\tkernel_fpu_end();\n}\n\nconst struct raid6_calls raid6_mmxx2 = {\n\traid6_mmx2_gen_syndrome,\n\tNULL,\t\t\t \n\traid6_have_mmx,\n\t\"mmxx2\",\n\t0\n};\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}