{
  "module_name": "vpermxor.uc",
  "hash_id": "46ee2f7a63999743ee89f15870ceca2e295c1695f046b5c7338b46fb2235eefa",
  "original_prompt": "Ingested from linux-6.6.14/lib/raid6/vpermxor.uc",
  "human_readable_source": "/*\n * Copyright 2017, Matt Brown, IBM Corp.\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version\n * 2 of the License, or (at your option) any later version.\n *\n * vpermxor$#.c\n *\n * Based on H. Peter Anvin's paper - The mathematics of RAID-6\n *\n * $#-way unrolled portable integer math RAID-6 instruction set\n * This file is postprocessed using unroll.awk\n *\n * vpermxor$#.c makes use of the vpermxor instruction to optimise the RAID6 Q\n * syndrome calculations.\n * This can be run on systems which have both Altivec and vpermxor instruction.\n *\n * This instruction was introduced in POWER8 - ISA v2.07.\n */\n\n#include <linux/raid/pq.h>\n#ifdef CONFIG_ALTIVEC\n\n#include <altivec.h>\n#include <asm/ppc-opcode.h>\n#ifdef __KERNEL__\n#include <asm/cputable.h>\n#include <asm/switch_to.h>\n#endif\n\ntypedef vector unsigned char unative_t;\n#define NSIZE sizeof(unative_t)\n\nstatic const vector unsigned char gf_low = {0x1e, 0x1c, 0x1a, 0x18, 0x16, 0x14,\n\t\t\t\t\t    0x12, 0x10, 0x0e, 0x0c, 0x0a, 0x08,\n\t\t\t\t\t    0x06, 0x04, 0x02,0x00};\nstatic const vector unsigned char gf_high = {0xfd, 0xdd, 0xbd, 0x9d, 0x7d, 0x5d,\n\t\t\t\t\t     0x3d, 0x1d, 0xe0, 0xc0, 0xa0, 0x80,\n\t\t\t\t\t     0x60, 0x40, 0x20, 0x00};\n\nstatic void noinline raid6_vpermxor$#_gen_syndrome_real(int disks, size_t bytes,\n\t\t\t\t\t\t\tvoid **ptrs)\n{\n\tu8 **dptr = (u8 **)ptrs;\n\tu8 *p, *q;\n\tint d, z, z0;\n\tunative_t wp$$, wq$$, wd$$;\n\n\tz0 = disks - 3;\t\t/* Highest data disk */\n\tp = dptr[z0+1];\t\t/* XOR parity */\n\tq = dptr[z0+2];\t\t/* RS syndrome */\n\n\tfor (d = 0; d < bytes; d += NSIZE*$#) {\n\t\twp$$ = wq$$ = *(unative_t *)&dptr[z0][d+$$*NSIZE];\n\n\t\tfor (z = z0-1; z>=0; z--) {\n\t\t\twd$$ = *(unative_t *)&dptr[z][d+$$*NSIZE];\n\t\t\t/* P syndrome */\n\t\t\twp$$ = vec_xor(wp$$, wd$$);\n\n\t\t\t/* Q syndrome */\n\t\t\tasm(VPERMXOR(%0,%1,%2,%3):\"=v\"(wq$$):\"v\"(gf_high), \"v\"(gf_low), \"v\"(wq$$));\n\t\t\twq$$ = vec_xor(wq$$, wd$$);\n\t\t}\n\t\t*(unative_t *)&p[d+NSIZE*$$] = wp$$;\n\t\t*(unative_t *)&q[d+NSIZE*$$] = wq$$;\n\t}\n}\n\nstatic void raid6_vpermxor$#_gen_syndrome(int disks, size_t bytes, void **ptrs)\n{\n\tpreempt_disable();\n\tenable_kernel_altivec();\n\n\traid6_vpermxor$#_gen_syndrome_real(disks, bytes, ptrs);\n\n\tdisable_kernel_altivec();\n\tpreempt_enable();\n}\n\nint raid6_have_altivec_vpermxor(void);\n#if $# == 1\nint raid6_have_altivec_vpermxor(void)\n{\n\t/* Check if arch has both altivec and the vpermxor instructions */\n# ifdef __KERNEL__\n\treturn (cpu_has_feature(CPU_FTR_ALTIVEC_COMP) &&\n\t\tcpu_has_feature(CPU_FTR_ARCH_207S));\n# else\n\treturn 1;\n#endif\n\n}\n#endif\n\nconst struct raid6_calls raid6_vpermxor$# = {\n\traid6_vpermxor$#_gen_syndrome,\n\tNULL,\n\traid6_have_altivec_vpermxor,\n\t\"vpermxor$#\",\n\t0\n};\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}