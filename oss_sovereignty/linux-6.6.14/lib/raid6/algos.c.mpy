{
  "module_name": "algos.c",
  "hash_id": "97cf6fe18cced41c56186cd39233a588bee6f1e165a8d85ac5a481b545dc317e",
  "original_prompt": "Ingested from linux-6.6.14/lib/raid6/algos.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/raid/pq.h>\n#ifndef __KERNEL__\n#include <sys/mman.h>\n#include <stdio.h>\n#else\n#include <linux/module.h>\n#include <linux/gfp.h>\n \nconst char raid6_empty_zero_page[PAGE_SIZE] __attribute__((aligned(256)));\nEXPORT_SYMBOL(raid6_empty_zero_page);\n#endif\n\nstruct raid6_calls raid6_call;\nEXPORT_SYMBOL_GPL(raid6_call);\n\nconst struct raid6_calls * const raid6_algos[] = {\n#if defined(__i386__) && !defined(__arch_um__)\n#ifdef CONFIG_AS_AVX512\n\t&raid6_avx512x2,\n\t&raid6_avx512x1,\n#endif\n\t&raid6_avx2x2,\n\t&raid6_avx2x1,\n\t&raid6_sse2x2,\n\t&raid6_sse2x1,\n\t&raid6_sse1x2,\n\t&raid6_sse1x1,\n\t&raid6_mmxx2,\n\t&raid6_mmxx1,\n#endif\n#if defined(__x86_64__) && !defined(__arch_um__)\n#ifdef CONFIG_AS_AVX512\n\t&raid6_avx512x4,\n\t&raid6_avx512x2,\n\t&raid6_avx512x1,\n#endif\n\t&raid6_avx2x4,\n\t&raid6_avx2x2,\n\t&raid6_avx2x1,\n\t&raid6_sse2x4,\n\t&raid6_sse2x2,\n\t&raid6_sse2x1,\n#endif\n#ifdef CONFIG_ALTIVEC\n\t&raid6_vpermxor8,\n\t&raid6_vpermxor4,\n\t&raid6_vpermxor2,\n\t&raid6_vpermxor1,\n\t&raid6_altivec8,\n\t&raid6_altivec4,\n\t&raid6_altivec2,\n\t&raid6_altivec1,\n#endif\n#if defined(CONFIG_S390)\n\t&raid6_s390vx8,\n#endif\n#ifdef CONFIG_KERNEL_MODE_NEON\n\t&raid6_neonx8,\n\t&raid6_neonx4,\n\t&raid6_neonx2,\n\t&raid6_neonx1,\n#endif\n#ifdef CONFIG_LOONGARCH\n#ifdef CONFIG_CPU_HAS_LASX\n\t&raid6_lasx,\n#endif\n#ifdef CONFIG_CPU_HAS_LSX\n\t&raid6_lsx,\n#endif\n#endif\n#if defined(__ia64__)\n\t&raid6_intx32,\n\t&raid6_intx16,\n#endif\n\t&raid6_intx8,\n\t&raid6_intx4,\n\t&raid6_intx2,\n\t&raid6_intx1,\n\tNULL\n};\n\nvoid (*raid6_2data_recov)(int, size_t, int, int, void **);\nEXPORT_SYMBOL_GPL(raid6_2data_recov);\n\nvoid (*raid6_datap_recov)(int, size_t, int, void **);\nEXPORT_SYMBOL_GPL(raid6_datap_recov);\n\nconst struct raid6_recov_calls *const raid6_recov_algos[] = {\n#ifdef CONFIG_X86\n#ifdef CONFIG_AS_AVX512\n\t&raid6_recov_avx512,\n#endif\n\t&raid6_recov_avx2,\n\t&raid6_recov_ssse3,\n#endif\n#ifdef CONFIG_S390\n\t&raid6_recov_s390xc,\n#endif\n#if defined(CONFIG_KERNEL_MODE_NEON)\n\t&raid6_recov_neon,\n#endif\n#ifdef CONFIG_LOONGARCH\n#ifdef CONFIG_CPU_HAS_LASX\n\t&raid6_recov_lasx,\n#endif\n#ifdef CONFIG_CPU_HAS_LSX\n\t&raid6_recov_lsx,\n#endif\n#endif\n\t&raid6_recov_intx1,\n\tNULL\n};\n\n#ifdef __KERNEL__\n#define RAID6_TIME_JIFFIES_LG2\t4\n#else\n \n#define RAID6_TIME_JIFFIES_LG2\t9\n#define time_before(x, y) ((x) < (y))\n#endif\n\n#define RAID6_TEST_DISKS\t8\n#define RAID6_TEST_DISKS_ORDER\t3\n\nstatic inline const struct raid6_recov_calls *raid6_choose_recov(void)\n{\n\tconst struct raid6_recov_calls *const *algo;\n\tconst struct raid6_recov_calls *best;\n\n\tfor (best = NULL, algo = raid6_recov_algos; *algo; algo++)\n\t\tif (!best || (*algo)->priority > best->priority)\n\t\t\tif (!(*algo)->valid || (*algo)->valid())\n\t\t\t\tbest = *algo;\n\n\tif (best) {\n\t\traid6_2data_recov = best->data2;\n\t\traid6_datap_recov = best->datap;\n\n\t\tpr_info(\"raid6: using %s recovery algorithm\\n\", best->name);\n\t} else\n\t\tpr_err(\"raid6: Yikes! No recovery algorithm found!\\n\");\n\n\treturn best;\n}\n\nstatic inline const struct raid6_calls *raid6_choose_gen(\n\tvoid *(*const dptrs)[RAID6_TEST_DISKS], const int disks)\n{\n\tunsigned long perf, bestgenperf, j0, j1;\n\tint start = (disks>>1)-1, stop = disks-3;\t \n\tconst struct raid6_calls *const *algo;\n\tconst struct raid6_calls *best;\n\n\tfor (bestgenperf = 0, best = NULL, algo = raid6_algos; *algo; algo++) {\n\t\tif (!best || (*algo)->priority >= best->priority) {\n\t\t\tif ((*algo)->valid && !(*algo)->valid())\n\t\t\t\tcontinue;\n\n\t\t\tif (!IS_ENABLED(CONFIG_RAID6_PQ_BENCHMARK)) {\n\t\t\t\tbest = *algo;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tperf = 0;\n\n\t\t\tpreempt_disable();\n\t\t\tj0 = jiffies;\n\t\t\twhile ((j1 = jiffies) == j0)\n\t\t\t\tcpu_relax();\n\t\t\twhile (time_before(jiffies,\n\t\t\t\t\t    j1 + (1<<RAID6_TIME_JIFFIES_LG2))) {\n\t\t\t\t(*algo)->gen_syndrome(disks, PAGE_SIZE, *dptrs);\n\t\t\t\tperf++;\n\t\t\t}\n\t\t\tpreempt_enable();\n\n\t\t\tif (perf > bestgenperf) {\n\t\t\t\tbestgenperf = perf;\n\t\t\t\tbest = *algo;\n\t\t\t}\n\t\t\tpr_info(\"raid6: %-8s gen() %5ld MB/s\\n\", (*algo)->name,\n\t\t\t\t(perf * HZ * (disks-2)) >>\n\t\t\t\t(20 - PAGE_SHIFT + RAID6_TIME_JIFFIES_LG2));\n\t\t}\n\t}\n\n\tif (!best) {\n\t\tpr_err(\"raid6: Yikes! No algorithm found!\\n\");\n\t\tgoto out;\n\t}\n\n\traid6_call = *best;\n\n\tif (!IS_ENABLED(CONFIG_RAID6_PQ_BENCHMARK)) {\n\t\tpr_info(\"raid6: skipped pq benchmark and selected %s\\n\",\n\t\t\tbest->name);\n\t\tgoto out;\n\t}\n\n\tpr_info(\"raid6: using algorithm %s gen() %ld MB/s\\n\",\n\t\tbest->name,\n\t\t(bestgenperf * HZ * (disks - 2)) >>\n\t\t(20 - PAGE_SHIFT + RAID6_TIME_JIFFIES_LG2));\n\n\tif (best->xor_syndrome) {\n\t\tperf = 0;\n\n\t\tpreempt_disable();\n\t\tj0 = jiffies;\n\t\twhile ((j1 = jiffies) == j0)\n\t\t\tcpu_relax();\n\t\twhile (time_before(jiffies,\n\t\t\t\t   j1 + (1 << RAID6_TIME_JIFFIES_LG2))) {\n\t\t\tbest->xor_syndrome(disks, start, stop,\n\t\t\t\t\t   PAGE_SIZE, *dptrs);\n\t\t\tperf++;\n\t\t}\n\t\tpreempt_enable();\n\n\t\tpr_info(\"raid6: .... xor() %ld MB/s, rmw enabled\\n\",\n\t\t\t(perf * HZ * (disks - 2)) >>\n\t\t\t(20 - PAGE_SHIFT + RAID6_TIME_JIFFIES_LG2 + 1));\n\t}\n\nout:\n\treturn best;\n}\n\n\n \n \n\nint __init raid6_select_algo(void)\n{\n\tconst int disks = RAID6_TEST_DISKS;\n\n\tconst struct raid6_calls *gen_best;\n\tconst struct raid6_recov_calls *rec_best;\n\tchar *disk_ptr, *p;\n\tvoid *dptrs[RAID6_TEST_DISKS];\n\tint i, cycle;\n\n\t \n\tdisk_ptr = (char *)__get_free_pages(GFP_KERNEL, RAID6_TEST_DISKS_ORDER);\n\tif (!disk_ptr) {\n\t\tpr_err(\"raid6: Yikes!  No memory available.\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tp = disk_ptr;\n\tfor (i = 0; i < disks; i++)\n\t\tdptrs[i] = p + PAGE_SIZE * i;\n\n\tcycle = ((disks - 2) * PAGE_SIZE) / 65536;\n\tfor (i = 0; i < cycle; i++) {\n\t\tmemcpy(p, raid6_gfmul, 65536);\n\t\tp += 65536;\n\t}\n\n\tif ((disks - 2) * PAGE_SIZE % 65536)\n\t\tmemcpy(p, raid6_gfmul, (disks - 2) * PAGE_SIZE % 65536);\n\n\t \n\tgen_best = raid6_choose_gen(&dptrs, disks);\n\n\t \n\trec_best = raid6_choose_recov();\n\n\tfree_pages((unsigned long)disk_ptr, RAID6_TEST_DISKS_ORDER);\n\n\treturn gen_best && rec_best ? 0 : -EINVAL;\n}\n\nstatic void raid6_exit(void)\n{\n\tdo { } while (0);\n}\n\nsubsys_initcall(raid6_select_algo);\nmodule_exit(raid6_exit);\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"RAID6 Q-syndrome calculations\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}