{
  "module_name": "find_bit.c",
  "hash_id": "402ea209e7320646b0c57af3820ee3de24bf76dcde56579fe48c6ed0d4351dc8",
  "original_prompt": "Ingested from linux-6.6.14/lib/find_bit.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/export.h>\n#include <linux/math.h>\n#include <linux/minmax.h>\n#include <linux/swab.h>\n\n \n#define FIND_FIRST_BIT(FETCH, MUNGE, size)\t\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\t\\\n\tunsigned long idx, val, sz = (size);\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\t\\\n\tfor (idx = 0; idx * BITS_PER_LONG < sz; idx++) {\t\t\t\\\n\t\tval = (FETCH);\t\t\t\t\t\t\t\\\n\t\tif (val) {\t\t\t\t\t\t\t\\\n\t\t\tsz = min(idx * BITS_PER_LONG + __ffs(MUNGE(val)), sz);\t\\\n\t\t\tbreak;\t\t\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\t\\\n\tsz;\t\t\t\t\t\t\t\t\t\\\n})\n\n \n#define FIND_NEXT_BIT(FETCH, MUNGE, size, start)\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\t\\\n\tunsigned long mask, idx, tmp, sz = (size), __start = (start);\t\t\\\n\t\t\t\t\t\t\t\t\t\t\\\n\tif (unlikely(__start >= sz))\t\t\t\t\t\t\\\n\t\tgoto out;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\t\\\n\tmask = MUNGE(BITMAP_FIRST_WORD_MASK(__start));\t\t\t\t\\\n\tidx = __start / BITS_PER_LONG;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\t\\\n\tfor (tmp = (FETCH) & mask; !tmp; tmp = (FETCH)) {\t\t\t\\\n\t\tif ((idx + 1) * BITS_PER_LONG >= sz)\t\t\t\t\\\n\t\t\tgoto out;\t\t\t\t\t\t\\\n\t\tidx++;\t\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\t\\\n\tsz = min(idx * BITS_PER_LONG + __ffs(MUNGE(tmp)), sz);\t\t\t\\\nout:\t\t\t\t\t\t\t\t\t\t\\\n\tsz;\t\t\t\t\t\t\t\t\t\\\n})\n\n#define FIND_NTH_BIT(FETCH, size, num)\t\t\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\t\\\n\tunsigned long sz = (size), nr = (num), idx, w, tmp;\t\t\t\\\n\t\t\t\t\t\t\t\t\t\t\\\n\tfor (idx = 0; (idx + 1) * BITS_PER_LONG <= sz; idx++) {\t\t\t\\\n\t\tif (idx * BITS_PER_LONG + nr >= sz)\t\t\t\t\\\n\t\t\tgoto out;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\t\\\n\t\ttmp = (FETCH);\t\t\t\t\t\t\t\\\n\t\tw = hweight_long(tmp);\t\t\t\t\t\t\\\n\t\tif (w > nr)\t\t\t\t\t\t\t\\\n\t\t\tgoto found;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\t\\\n\t\tnr -= w;\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\t\\\n\tif (sz % BITS_PER_LONG)\t\t\t\t\t\t\t\\\n\t\ttmp = (FETCH) & BITMAP_LAST_WORD_MASK(sz);\t\t\t\\\nfound:\t\t\t\t\t\t\t\t\t\t\\\n\tsz = min(idx * BITS_PER_LONG + fns(tmp, nr), sz);\t\t\t\\\nout:\t\t\t\t\t\t\t\t\t\t\\\n\tsz;\t\t\t\t\t\t\t\t\t\\\n})\n\n#ifndef find_first_bit\n \nunsigned long _find_first_bit(const unsigned long *addr, unsigned long size)\n{\n\treturn FIND_FIRST_BIT(addr[idx],  , size);\n}\nEXPORT_SYMBOL(_find_first_bit);\n#endif\n\n#ifndef find_first_and_bit\n \nunsigned long _find_first_and_bit(const unsigned long *addr1,\n\t\t\t\t  const unsigned long *addr2,\n\t\t\t\t  unsigned long size)\n{\n\treturn FIND_FIRST_BIT(addr1[idx] & addr2[idx],  , size);\n}\nEXPORT_SYMBOL(_find_first_and_bit);\n#endif\n\n#ifndef find_first_zero_bit\n \nunsigned long _find_first_zero_bit(const unsigned long *addr, unsigned long size)\n{\n\treturn FIND_FIRST_BIT(~addr[idx],  , size);\n}\nEXPORT_SYMBOL(_find_first_zero_bit);\n#endif\n\n#ifndef find_next_bit\nunsigned long _find_next_bit(const unsigned long *addr, unsigned long nbits, unsigned long start)\n{\n\treturn FIND_NEXT_BIT(addr[idx],  , nbits, start);\n}\nEXPORT_SYMBOL(_find_next_bit);\n#endif\n\nunsigned long __find_nth_bit(const unsigned long *addr, unsigned long size, unsigned long n)\n{\n\treturn FIND_NTH_BIT(addr[idx], size, n);\n}\nEXPORT_SYMBOL(__find_nth_bit);\n\nunsigned long __find_nth_and_bit(const unsigned long *addr1, const unsigned long *addr2,\n\t\t\t\t unsigned long size, unsigned long n)\n{\n\treturn FIND_NTH_BIT(addr1[idx] & addr2[idx], size, n);\n}\nEXPORT_SYMBOL(__find_nth_and_bit);\n\nunsigned long __find_nth_andnot_bit(const unsigned long *addr1, const unsigned long *addr2,\n\t\t\t\t unsigned long size, unsigned long n)\n{\n\treturn FIND_NTH_BIT(addr1[idx] & ~addr2[idx], size, n);\n}\nEXPORT_SYMBOL(__find_nth_andnot_bit);\n\nunsigned long __find_nth_and_andnot_bit(const unsigned long *addr1,\n\t\t\t\t\tconst unsigned long *addr2,\n\t\t\t\t\tconst unsigned long *addr3,\n\t\t\t\t\tunsigned long size, unsigned long n)\n{\n\treturn FIND_NTH_BIT(addr1[idx] & addr2[idx] & ~addr3[idx], size, n);\n}\nEXPORT_SYMBOL(__find_nth_and_andnot_bit);\n\n#ifndef find_next_and_bit\nunsigned long _find_next_and_bit(const unsigned long *addr1, const unsigned long *addr2,\n\t\t\t\t\tunsigned long nbits, unsigned long start)\n{\n\treturn FIND_NEXT_BIT(addr1[idx] & addr2[idx],  , nbits, start);\n}\nEXPORT_SYMBOL(_find_next_and_bit);\n#endif\n\n#ifndef find_next_andnot_bit\nunsigned long _find_next_andnot_bit(const unsigned long *addr1, const unsigned long *addr2,\n\t\t\t\t\tunsigned long nbits, unsigned long start)\n{\n\treturn FIND_NEXT_BIT(addr1[idx] & ~addr2[idx],  , nbits, start);\n}\nEXPORT_SYMBOL(_find_next_andnot_bit);\n#endif\n\n#ifndef find_next_or_bit\nunsigned long _find_next_or_bit(const unsigned long *addr1, const unsigned long *addr2,\n\t\t\t\t\tunsigned long nbits, unsigned long start)\n{\n\treturn FIND_NEXT_BIT(addr1[idx] | addr2[idx],  , nbits, start);\n}\nEXPORT_SYMBOL(_find_next_or_bit);\n#endif\n\n#ifndef find_next_zero_bit\nunsigned long _find_next_zero_bit(const unsigned long *addr, unsigned long nbits,\n\t\t\t\t\t unsigned long start)\n{\n\treturn FIND_NEXT_BIT(~addr[idx],  , nbits, start);\n}\nEXPORT_SYMBOL(_find_next_zero_bit);\n#endif\n\n#ifndef find_last_bit\nunsigned long _find_last_bit(const unsigned long *addr, unsigned long size)\n{\n\tif (size) {\n\t\tunsigned long val = BITMAP_LAST_WORD_MASK(size);\n\t\tunsigned long idx = (size-1) / BITS_PER_LONG;\n\n\t\tdo {\n\t\t\tval &= addr[idx];\n\t\t\tif (val)\n\t\t\t\treturn idx * BITS_PER_LONG + __fls(val);\n\n\t\t\tval = ~0ul;\n\t\t} while (idx--);\n\t}\n\treturn size;\n}\nEXPORT_SYMBOL(_find_last_bit);\n#endif\n\nunsigned long find_next_clump8(unsigned long *clump, const unsigned long *addr,\n\t\t\t       unsigned long size, unsigned long offset)\n{\n\toffset = find_next_bit(addr, size, offset);\n\tif (offset == size)\n\t\treturn size;\n\n\toffset = round_down(offset, 8);\n\t*clump = bitmap_get_value8(addr, offset);\n\n\treturn offset;\n}\nEXPORT_SYMBOL(find_next_clump8);\n\n#ifdef __BIG_ENDIAN\n\n#ifndef find_first_zero_bit_le\n \nunsigned long _find_first_zero_bit_le(const unsigned long *addr, unsigned long size)\n{\n\treturn FIND_FIRST_BIT(~addr[idx], swab, size);\n}\nEXPORT_SYMBOL(_find_first_zero_bit_le);\n\n#endif\n\n#ifndef find_next_zero_bit_le\nunsigned long _find_next_zero_bit_le(const unsigned long *addr,\n\t\t\t\t\tunsigned long size, unsigned long offset)\n{\n\treturn FIND_NEXT_BIT(~addr[idx], swab, size, offset);\n}\nEXPORT_SYMBOL(_find_next_zero_bit_le);\n#endif\n\n#ifndef find_next_bit_le\nunsigned long _find_next_bit_le(const unsigned long *addr,\n\t\t\t\tunsigned long size, unsigned long offset)\n{\n\treturn FIND_NEXT_BIT(addr[idx], swab, size, offset);\n}\nEXPORT_SYMBOL(_find_next_bit_le);\n\n#endif\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}