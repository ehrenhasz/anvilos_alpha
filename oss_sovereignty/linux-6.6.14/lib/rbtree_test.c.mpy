{
  "module_name": "rbtree_test.c",
  "hash_id": "d4a0ab896e5cf6fe0f3ac5b88cb891129a1723ee3d16a484d13445a14f95051a",
  "original_prompt": "Ingested from linux-6.6.14/lib/rbtree_test.c",
  "human_readable_source": "\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/rbtree_augmented.h>\n#include <linux/random.h>\n#include <linux/slab.h>\n#include <asm/timex.h>\n\n#define __param(type, name, init, msg)\t\t\\\n\tstatic type name = init;\t\t\\\n\tmodule_param(name, type, 0444);\t\t\\\n\tMODULE_PARM_DESC(name, msg);\n\n__param(int, nnodes, 100, \"Number of nodes in the rb-tree\");\n__param(int, perf_loops, 1000, \"Number of iterations modifying the rb-tree\");\n__param(int, check_loops, 100, \"Number of iterations modifying and verifying the rb-tree\");\n\nstruct test_node {\n\tu32 key;\n\tstruct rb_node rb;\n\n\t \n\tu32 val;\n\tu32 augmented;\n};\n\nstatic struct rb_root_cached root = RB_ROOT_CACHED;\nstatic struct test_node *nodes = NULL;\n\nstatic struct rnd_state rnd;\n\nstatic void insert(struct test_node *node, struct rb_root_cached *root)\n{\n\tstruct rb_node **new = &root->rb_root.rb_node, *parent = NULL;\n\tu32 key = node->key;\n\n\twhile (*new) {\n\t\tparent = *new;\n\t\tif (key < rb_entry(parent, struct test_node, rb)->key)\n\t\t\tnew = &parent->rb_left;\n\t\telse\n\t\t\tnew = &parent->rb_right;\n\t}\n\n\trb_link_node(&node->rb, parent, new);\n\trb_insert_color(&node->rb, &root->rb_root);\n}\n\nstatic void insert_cached(struct test_node *node, struct rb_root_cached *root)\n{\n\tstruct rb_node **new = &root->rb_root.rb_node, *parent = NULL;\n\tu32 key = node->key;\n\tbool leftmost = true;\n\n\twhile (*new) {\n\t\tparent = *new;\n\t\tif (key < rb_entry(parent, struct test_node, rb)->key)\n\t\t\tnew = &parent->rb_left;\n\t\telse {\n\t\t\tnew = &parent->rb_right;\n\t\t\tleftmost = false;\n\t\t}\n\t}\n\n\trb_link_node(&node->rb, parent, new);\n\trb_insert_color_cached(&node->rb, root, leftmost);\n}\n\nstatic inline void erase(struct test_node *node, struct rb_root_cached *root)\n{\n\trb_erase(&node->rb, &root->rb_root);\n}\n\nstatic inline void erase_cached(struct test_node *node, struct rb_root_cached *root)\n{\n\trb_erase_cached(&node->rb, root);\n}\n\n\n#define NODE_VAL(node) ((node)->val)\n\nRB_DECLARE_CALLBACKS_MAX(static, augment_callbacks,\n\t\t\t struct test_node, rb, u32, augmented, NODE_VAL)\n\nstatic void insert_augmented(struct test_node *node,\n\t\t\t     struct rb_root_cached *root)\n{\n\tstruct rb_node **new = &root->rb_root.rb_node, *rb_parent = NULL;\n\tu32 key = node->key;\n\tu32 val = node->val;\n\tstruct test_node *parent;\n\n\twhile (*new) {\n\t\trb_parent = *new;\n\t\tparent = rb_entry(rb_parent, struct test_node, rb);\n\t\tif (parent->augmented < val)\n\t\t\tparent->augmented = val;\n\t\tif (key < parent->key)\n\t\t\tnew = &parent->rb.rb_left;\n\t\telse\n\t\t\tnew = &parent->rb.rb_right;\n\t}\n\n\tnode->augmented = val;\n\trb_link_node(&node->rb, rb_parent, new);\n\trb_insert_augmented(&node->rb, &root->rb_root, &augment_callbacks);\n}\n\nstatic void insert_augmented_cached(struct test_node *node,\n\t\t\t\t    struct rb_root_cached *root)\n{\n\tstruct rb_node **new = &root->rb_root.rb_node, *rb_parent = NULL;\n\tu32 key = node->key;\n\tu32 val = node->val;\n\tstruct test_node *parent;\n\tbool leftmost = true;\n\n\twhile (*new) {\n\t\trb_parent = *new;\n\t\tparent = rb_entry(rb_parent, struct test_node, rb);\n\t\tif (parent->augmented < val)\n\t\t\tparent->augmented = val;\n\t\tif (key < parent->key)\n\t\t\tnew = &parent->rb.rb_left;\n\t\telse {\n\t\t\tnew = &parent->rb.rb_right;\n\t\t\tleftmost = false;\n\t\t}\n\t}\n\n\tnode->augmented = val;\n\trb_link_node(&node->rb, rb_parent, new);\n\trb_insert_augmented_cached(&node->rb, root,\n\t\t\t\t   leftmost, &augment_callbacks);\n}\n\n\nstatic void erase_augmented(struct test_node *node, struct rb_root_cached *root)\n{\n\trb_erase_augmented(&node->rb, &root->rb_root, &augment_callbacks);\n}\n\nstatic void erase_augmented_cached(struct test_node *node,\n\t\t\t\t   struct rb_root_cached *root)\n{\n\trb_erase_augmented_cached(&node->rb, root, &augment_callbacks);\n}\n\nstatic void init(void)\n{\n\tint i;\n\tfor (i = 0; i < nnodes; i++) {\n\t\tnodes[i].key = prandom_u32_state(&rnd);\n\t\tnodes[i].val = prandom_u32_state(&rnd);\n\t}\n}\n\nstatic bool is_red(struct rb_node *rb)\n{\n\treturn !(rb->__rb_parent_color & 1);\n}\n\nstatic int black_path_count(struct rb_node *rb)\n{\n\tint count;\n\tfor (count = 0; rb; rb = rb_parent(rb))\n\t\tcount += !is_red(rb);\n\treturn count;\n}\n\nstatic void check_postorder_foreach(int nr_nodes)\n{\n\tstruct test_node *cur, *n;\n\tint count = 0;\n\trbtree_postorder_for_each_entry_safe(cur, n, &root.rb_root, rb)\n\t\tcount++;\n\n\tWARN_ON_ONCE(count != nr_nodes);\n}\n\nstatic void check_postorder(int nr_nodes)\n{\n\tstruct rb_node *rb;\n\tint count = 0;\n\tfor (rb = rb_first_postorder(&root.rb_root); rb; rb = rb_next_postorder(rb))\n\t\tcount++;\n\n\tWARN_ON_ONCE(count != nr_nodes);\n}\n\nstatic void check(int nr_nodes)\n{\n\tstruct rb_node *rb;\n\tint count = 0, blacks = 0;\n\tu32 prev_key = 0;\n\n\tfor (rb = rb_first(&root.rb_root); rb; rb = rb_next(rb)) {\n\t\tstruct test_node *node = rb_entry(rb, struct test_node, rb);\n\t\tWARN_ON_ONCE(node->key < prev_key);\n\t\tWARN_ON_ONCE(is_red(rb) &&\n\t\t\t     (!rb_parent(rb) || is_red(rb_parent(rb))));\n\t\tif (!count)\n\t\t\tblacks = black_path_count(rb);\n\t\telse\n\t\t\tWARN_ON_ONCE((!rb->rb_left || !rb->rb_right) &&\n\t\t\t\t     blacks != black_path_count(rb));\n\t\tprev_key = node->key;\n\t\tcount++;\n\t}\n\n\tWARN_ON_ONCE(count != nr_nodes);\n\tWARN_ON_ONCE(count < (1 << black_path_count(rb_last(&root.rb_root))) - 1);\n\n\tcheck_postorder(nr_nodes);\n\tcheck_postorder_foreach(nr_nodes);\n}\n\nstatic void check_augmented(int nr_nodes)\n{\n\tstruct rb_node *rb;\n\n\tcheck(nr_nodes);\n\tfor (rb = rb_first(&root.rb_root); rb; rb = rb_next(rb)) {\n\t\tstruct test_node *node = rb_entry(rb, struct test_node, rb);\n\t\tu32 subtree, max = node->val;\n\t\tif (node->rb.rb_left) {\n\t\t\tsubtree = rb_entry(node->rb.rb_left, struct test_node,\n\t\t\t\t\t   rb)->augmented;\n\t\t\tif (max < subtree)\n\t\t\t\tmax = subtree;\n\t\t}\n\t\tif (node->rb.rb_right) {\n\t\t\tsubtree = rb_entry(node->rb.rb_right, struct test_node,\n\t\t\t\t\t   rb)->augmented;\n\t\t\tif (max < subtree)\n\t\t\t\tmax = subtree;\n\t\t}\n\t\tWARN_ON_ONCE(node->augmented != max);\n\t}\n}\n\nstatic int __init rbtree_test_init(void)\n{\n\tint i, j;\n\tcycles_t time1, time2, time;\n\tstruct rb_node *node;\n\n\tnodes = kmalloc_array(nnodes, sizeof(*nodes), GFP_KERNEL);\n\tif (!nodes)\n\t\treturn -ENOMEM;\n\n\tprintk(KERN_ALERT \"rbtree testing\");\n\n\tprandom_seed_state(&rnd, 3141592653589793238ULL);\n\tinit();\n\n\ttime1 = get_cycles();\n\n\tfor (i = 0; i < perf_loops; i++) {\n\t\tfor (j = 0; j < nnodes; j++)\n\t\t\tinsert(nodes + j, &root);\n\t\tfor (j = 0; j < nnodes; j++)\n\t\t\terase(nodes + j, &root);\n\t}\n\n\ttime2 = get_cycles();\n\ttime = time2 - time1;\n\n\ttime = div_u64(time, perf_loops);\n\tprintk(\" -> test 1 (latency of nnodes insert+delete): %llu cycles\\n\",\n\t       (unsigned long long)time);\n\n\ttime1 = get_cycles();\n\n\tfor (i = 0; i < perf_loops; i++) {\n\t\tfor (j = 0; j < nnodes; j++)\n\t\t\tinsert_cached(nodes + j, &root);\n\t\tfor (j = 0; j < nnodes; j++)\n\t\t\terase_cached(nodes + j, &root);\n\t}\n\n\ttime2 = get_cycles();\n\ttime = time2 - time1;\n\n\ttime = div_u64(time, perf_loops);\n\tprintk(\" -> test 2 (latency of nnodes cached insert+delete): %llu cycles\\n\",\n\t       (unsigned long long)time);\n\n\tfor (i = 0; i < nnodes; i++)\n\t\tinsert(nodes + i, &root);\n\n\ttime1 = get_cycles();\n\n\tfor (i = 0; i < perf_loops; i++) {\n\t\tfor (node = rb_first(&root.rb_root); node; node = rb_next(node))\n\t\t\t;\n\t}\n\n\ttime2 = get_cycles();\n\ttime = time2 - time1;\n\n\ttime = div_u64(time, perf_loops);\n\tprintk(\" -> test 3 (latency of inorder traversal): %llu cycles\\n\",\n\t       (unsigned long long)time);\n\n\ttime1 = get_cycles();\n\n\tfor (i = 0; i < perf_loops; i++)\n\t\tnode = rb_first(&root.rb_root);\n\n\ttime2 = get_cycles();\n\ttime = time2 - time1;\n\n\ttime = div_u64(time, perf_loops);\n\tprintk(\" -> test 4 (latency to fetch first node)\\n\");\n\tprintk(\"        non-cached: %llu cycles\\n\", (unsigned long long)time);\n\n\ttime1 = get_cycles();\n\n\tfor (i = 0; i < perf_loops; i++)\n\t\tnode = rb_first_cached(&root);\n\n\ttime2 = get_cycles();\n\ttime = time2 - time1;\n\n\ttime = div_u64(time, perf_loops);\n\tprintk(\"        cached: %llu cycles\\n\", (unsigned long long)time);\n\n\tfor (i = 0; i < nnodes; i++)\n\t\terase(nodes + i, &root);\n\n\t \n\tfor (i = 0; i < check_loops; i++) {\n\t\tinit();\n\t\tfor (j = 0; j < nnodes; j++) {\n\t\t\tcheck(j);\n\t\t\tinsert(nodes + j, &root);\n\t\t}\n\t\tfor (j = 0; j < nnodes; j++) {\n\t\t\tcheck(nnodes - j);\n\t\t\terase(nodes + j, &root);\n\t\t}\n\t\tcheck(0);\n\t}\n\n\tprintk(KERN_ALERT \"augmented rbtree testing\");\n\n\tinit();\n\n\ttime1 = get_cycles();\n\n\tfor (i = 0; i < perf_loops; i++) {\n\t\tfor (j = 0; j < nnodes; j++)\n\t\t\tinsert_augmented(nodes + j, &root);\n\t\tfor (j = 0; j < nnodes; j++)\n\t\t\terase_augmented(nodes + j, &root);\n\t}\n\n\ttime2 = get_cycles();\n\ttime = time2 - time1;\n\n\ttime = div_u64(time, perf_loops);\n\tprintk(\" -> test 1 (latency of nnodes insert+delete): %llu cycles\\n\", (unsigned long long)time);\n\n\ttime1 = get_cycles();\n\n\tfor (i = 0; i < perf_loops; i++) {\n\t\tfor (j = 0; j < nnodes; j++)\n\t\t\tinsert_augmented_cached(nodes + j, &root);\n\t\tfor (j = 0; j < nnodes; j++)\n\t\t\terase_augmented_cached(nodes + j, &root);\n\t}\n\n\ttime2 = get_cycles();\n\ttime = time2 - time1;\n\n\ttime = div_u64(time, perf_loops);\n\tprintk(\" -> test 2 (latency of nnodes cached insert+delete): %llu cycles\\n\", (unsigned long long)time);\n\n\tfor (i = 0; i < check_loops; i++) {\n\t\tinit();\n\t\tfor (j = 0; j < nnodes; j++) {\n\t\t\tcheck_augmented(j);\n\t\t\tinsert_augmented(nodes + j, &root);\n\t\t}\n\t\tfor (j = 0; j < nnodes; j++) {\n\t\t\tcheck_augmented(nnodes - j);\n\t\t\terase_augmented(nodes + j, &root);\n\t\t}\n\t\tcheck_augmented(0);\n\t}\n\n\tkfree(nodes);\n\n\treturn -EAGAIN;  \n}\n\nstatic void __exit rbtree_test_exit(void)\n{\n\tprintk(KERN_ALERT \"test exit\\n\");\n}\n\nmodule_init(rbtree_test_init)\nmodule_exit(rbtree_test_exit)\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Michel Lespinasse\");\nMODULE_DESCRIPTION(\"Red Black Tree test\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}