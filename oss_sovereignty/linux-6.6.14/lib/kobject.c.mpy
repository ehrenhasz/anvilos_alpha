{
  "module_name": "kobject.c",
  "hash_id": "bf4377a32b2995ab6861e8e24e8fba658bcd00ed9554f245f446366250edc8c4",
  "original_prompt": "Ingested from linux-6.6.14/lib/kobject.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/kobject.h>\n#include <linux/string.h>\n#include <linux/export.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n#include <linux/random.h>\n\n \nconst void *kobject_namespace(const struct kobject *kobj)\n{\n\tconst struct kobj_ns_type_operations *ns_ops = kobj_ns_ops(kobj);\n\n\tif (!ns_ops || ns_ops->type == KOBJ_NS_TYPE_NONE)\n\t\treturn NULL;\n\n\treturn kobj->ktype->namespace(kobj);\n}\n\n \nvoid kobject_get_ownership(const struct kobject *kobj, kuid_t *uid, kgid_t *gid)\n{\n\t*uid = GLOBAL_ROOT_UID;\n\t*gid = GLOBAL_ROOT_GID;\n\n\tif (kobj->ktype->get_ownership)\n\t\tkobj->ktype->get_ownership(kobj, uid, gid);\n}\n\nstatic bool kobj_ns_type_is_valid(enum kobj_ns_type type)\n{\n\tif ((type <= KOBJ_NS_TYPE_NONE) || (type >= KOBJ_NS_TYPES))\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic int create_dir(struct kobject *kobj)\n{\n\tconst struct kobj_type *ktype = get_ktype(kobj);\n\tconst struct kobj_ns_type_operations *ops;\n\tint error;\n\n\terror = sysfs_create_dir_ns(kobj, kobject_namespace(kobj));\n\tif (error)\n\t\treturn error;\n\n\terror = sysfs_create_groups(kobj, ktype->default_groups);\n\tif (error) {\n\t\tsysfs_remove_dir(kobj);\n\t\treturn error;\n\t}\n\n\t \n\tsysfs_get(kobj->sd);\n\n\t \n\tops = kobj_child_ns_ops(kobj);\n\tif (ops) {\n\t\tBUG_ON(!kobj_ns_type_is_valid(ops->type));\n\t\tBUG_ON(!kobj_ns_type_registered(ops->type));\n\n\t\tsysfs_enable_ns(kobj->sd);\n\t}\n\n\treturn 0;\n}\n\nstatic int get_kobj_path_length(const struct kobject *kobj)\n{\n\tint length = 1;\n\tconst struct kobject *parent = kobj;\n\n\t \n\tdo {\n\t\tif (kobject_name(parent) == NULL)\n\t\t\treturn 0;\n\t\tlength += strlen(kobject_name(parent)) + 1;\n\t\tparent = parent->parent;\n\t} while (parent);\n\treturn length;\n}\n\nstatic int fill_kobj_path(const struct kobject *kobj, char *path, int length)\n{\n\tconst struct kobject *parent;\n\n\t--length;\n\tfor (parent = kobj; parent; parent = parent->parent) {\n\t\tint cur = strlen(kobject_name(parent));\n\t\t \n\t\tlength -= cur;\n\t\tif (length <= 0)\n\t\t\treturn -EINVAL;\n\t\tmemcpy(path + length, kobject_name(parent), cur);\n\t\t*(path + --length) = '/';\n\t}\n\n\tpr_debug(\"'%s' (%p): %s: path = '%s'\\n\", kobject_name(kobj),\n\t\t kobj, __func__, path);\n\n\treturn 0;\n}\n\n \nchar *kobject_get_path(const struct kobject *kobj, gfp_t gfp_mask)\n{\n\tchar *path;\n\tint len;\n\nretry:\n\tlen = get_kobj_path_length(kobj);\n\tif (len == 0)\n\t\treturn NULL;\n\tpath = kzalloc(len, gfp_mask);\n\tif (!path)\n\t\treturn NULL;\n\tif (fill_kobj_path(kobj, path, len)) {\n\t\tkfree(path);\n\t\tgoto retry;\n\t}\n\n\treturn path;\n}\nEXPORT_SYMBOL_GPL(kobject_get_path);\n\n \nstatic void kobj_kset_join(struct kobject *kobj)\n{\n\tif (!kobj->kset)\n\t\treturn;\n\n\tkset_get(kobj->kset);\n\tspin_lock(&kobj->kset->list_lock);\n\tlist_add_tail(&kobj->entry, &kobj->kset->list);\n\tspin_unlock(&kobj->kset->list_lock);\n}\n\n \nstatic void kobj_kset_leave(struct kobject *kobj)\n{\n\tif (!kobj->kset)\n\t\treturn;\n\n\tspin_lock(&kobj->kset->list_lock);\n\tlist_del_init(&kobj->entry);\n\tspin_unlock(&kobj->kset->list_lock);\n\tkset_put(kobj->kset);\n}\n\nstatic void kobject_init_internal(struct kobject *kobj)\n{\n\tif (!kobj)\n\t\treturn;\n\tkref_init(&kobj->kref);\n\tINIT_LIST_HEAD(&kobj->entry);\n\tkobj->state_in_sysfs = 0;\n\tkobj->state_add_uevent_sent = 0;\n\tkobj->state_remove_uevent_sent = 0;\n\tkobj->state_initialized = 1;\n}\n\n\nstatic int kobject_add_internal(struct kobject *kobj)\n{\n\tint error = 0;\n\tstruct kobject *parent;\n\n\tif (!kobj)\n\t\treturn -ENOENT;\n\n\tif (!kobj->name || !kobj->name[0]) {\n\t\tWARN(1,\n\t\t     \"kobject: (%p): attempted to be registered with empty name!\\n\",\n\t\t     kobj);\n\t\treturn -EINVAL;\n\t}\n\n\tparent = kobject_get(kobj->parent);\n\n\t \n\tif (kobj->kset) {\n\t\tif (!parent)\n\t\t\tparent = kobject_get(&kobj->kset->kobj);\n\t\tkobj_kset_join(kobj);\n\t\tkobj->parent = parent;\n\t}\n\n\tpr_debug(\"'%s' (%p): %s: parent: '%s', set: '%s'\\n\",\n\t\t kobject_name(kobj), kobj, __func__,\n\t\t parent ? kobject_name(parent) : \"<NULL>\",\n\t\t kobj->kset ? kobject_name(&kobj->kset->kobj) : \"<NULL>\");\n\n\terror = create_dir(kobj);\n\tif (error) {\n\t\tkobj_kset_leave(kobj);\n\t\tkobject_put(parent);\n\t\tkobj->parent = NULL;\n\n\t\t \n\t\tif (error == -EEXIST)\n\t\t\tpr_err(\"%s failed for %s with -EEXIST, don't try to register things with the same name in the same directory.\\n\",\n\t\t\t       __func__, kobject_name(kobj));\n\t\telse\n\t\t\tpr_err(\"%s failed for %s (error: %d parent: %s)\\n\",\n\t\t\t       __func__, kobject_name(kobj), error,\n\t\t\t       parent ? kobject_name(parent) : \"'none'\");\n\t} else\n\t\tkobj->state_in_sysfs = 1;\n\n\treturn error;\n}\n\n \nint kobject_set_name_vargs(struct kobject *kobj, const char *fmt,\n\t\t\t\t  va_list vargs)\n{\n\tconst char *s;\n\n\tif (kobj->name && !fmt)\n\t\treturn 0;\n\n\ts = kvasprintf_const(GFP_KERNEL, fmt, vargs);\n\tif (!s)\n\t\treturn -ENOMEM;\n\n\t \n\tif (strchr(s, '/')) {\n\t\tchar *t;\n\n\t\tt = kstrdup(s, GFP_KERNEL);\n\t\tkfree_const(s);\n\t\tif (!t)\n\t\t\treturn -ENOMEM;\n\t\ts = strreplace(t, '/', '!');\n\t}\n\tkfree_const(kobj->name);\n\tkobj->name = s;\n\n\treturn 0;\n}\n\n \nint kobject_set_name(struct kobject *kobj, const char *fmt, ...)\n{\n\tva_list vargs;\n\tint retval;\n\n\tva_start(vargs, fmt);\n\tretval = kobject_set_name_vargs(kobj, fmt, vargs);\n\tva_end(vargs);\n\n\treturn retval;\n}\nEXPORT_SYMBOL(kobject_set_name);\n\n \nvoid kobject_init(struct kobject *kobj, const struct kobj_type *ktype)\n{\n\tchar *err_str;\n\n\tif (!kobj) {\n\t\terr_str = \"invalid kobject pointer!\";\n\t\tgoto error;\n\t}\n\tif (!ktype) {\n\t\terr_str = \"must have a ktype to be initialized properly!\\n\";\n\t\tgoto error;\n\t}\n\tif (kobj->state_initialized) {\n\t\t \n\t\tpr_err(\"kobject (%p): tried to init an initialized object, something is seriously wrong.\\n\",\n\t\t       kobj);\n\t\tdump_stack_lvl(KERN_ERR);\n\t}\n\n\tkobject_init_internal(kobj);\n\tkobj->ktype = ktype;\n\treturn;\n\nerror:\n\tpr_err(\"kobject (%p): %s\\n\", kobj, err_str);\n\tdump_stack_lvl(KERN_ERR);\n}\nEXPORT_SYMBOL(kobject_init);\n\nstatic __printf(3, 0) int kobject_add_varg(struct kobject *kobj,\n\t\t\t\t\t   struct kobject *parent,\n\t\t\t\t\t   const char *fmt, va_list vargs)\n{\n\tint retval;\n\n\tretval = kobject_set_name_vargs(kobj, fmt, vargs);\n\tif (retval) {\n\t\tpr_err(\"can not set name properly!\\n\");\n\t\treturn retval;\n\t}\n\tkobj->parent = parent;\n\treturn kobject_add_internal(kobj);\n}\n\n \nint kobject_add(struct kobject *kobj, struct kobject *parent,\n\t\tconst char *fmt, ...)\n{\n\tva_list args;\n\tint retval;\n\n\tif (!kobj)\n\t\treturn -EINVAL;\n\n\tif (!kobj->state_initialized) {\n\t\tpr_err(\"kobject '%s' (%p): tried to add an uninitialized object, something is seriously wrong.\\n\",\n\t\t       kobject_name(kobj), kobj);\n\t\tdump_stack_lvl(KERN_ERR);\n\t\treturn -EINVAL;\n\t}\n\tva_start(args, fmt);\n\tretval = kobject_add_varg(kobj, parent, fmt, args);\n\tva_end(args);\n\n\treturn retval;\n}\nEXPORT_SYMBOL(kobject_add);\n\n \nint kobject_init_and_add(struct kobject *kobj, const struct kobj_type *ktype,\n\t\t\t struct kobject *parent, const char *fmt, ...)\n{\n\tva_list args;\n\tint retval;\n\n\tkobject_init(kobj, ktype);\n\n\tva_start(args, fmt);\n\tretval = kobject_add_varg(kobj, parent, fmt, args);\n\tva_end(args);\n\n\treturn retval;\n}\nEXPORT_SYMBOL_GPL(kobject_init_and_add);\n\n \nint kobject_rename(struct kobject *kobj, const char *new_name)\n{\n\tint error = 0;\n\tconst char *devpath = NULL;\n\tconst char *dup_name = NULL, *name;\n\tchar *devpath_string = NULL;\n\tchar *envp[2];\n\n\tkobj = kobject_get(kobj);\n\tif (!kobj)\n\t\treturn -EINVAL;\n\tif (!kobj->parent) {\n\t\tkobject_put(kobj);\n\t\treturn -EINVAL;\n\t}\n\n\tdevpath = kobject_get_path(kobj, GFP_KERNEL);\n\tif (!devpath) {\n\t\terror = -ENOMEM;\n\t\tgoto out;\n\t}\n\tdevpath_string = kmalloc(strlen(devpath) + 15, GFP_KERNEL);\n\tif (!devpath_string) {\n\t\terror = -ENOMEM;\n\t\tgoto out;\n\t}\n\tsprintf(devpath_string, \"DEVPATH_OLD=%s\", devpath);\n\tenvp[0] = devpath_string;\n\tenvp[1] = NULL;\n\n\tname = dup_name = kstrdup_const(new_name, GFP_KERNEL);\n\tif (!name) {\n\t\terror = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\terror = sysfs_rename_dir_ns(kobj, new_name, kobject_namespace(kobj));\n\tif (error)\n\t\tgoto out;\n\n\t \n\tdup_name = kobj->name;\n\tkobj->name = name;\n\n\t \n\tkobject_uevent_env(kobj, KOBJ_MOVE, envp);\n\nout:\n\tkfree_const(dup_name);\n\tkfree(devpath_string);\n\tkfree(devpath);\n\tkobject_put(kobj);\n\n\treturn error;\n}\nEXPORT_SYMBOL_GPL(kobject_rename);\n\n \nint kobject_move(struct kobject *kobj, struct kobject *new_parent)\n{\n\tint error;\n\tstruct kobject *old_parent;\n\tconst char *devpath = NULL;\n\tchar *devpath_string = NULL;\n\tchar *envp[2];\n\n\tkobj = kobject_get(kobj);\n\tif (!kobj)\n\t\treturn -EINVAL;\n\tnew_parent = kobject_get(new_parent);\n\tif (!new_parent) {\n\t\tif (kobj->kset)\n\t\t\tnew_parent = kobject_get(&kobj->kset->kobj);\n\t}\n\n\t \n\tdevpath = kobject_get_path(kobj, GFP_KERNEL);\n\tif (!devpath) {\n\t\terror = -ENOMEM;\n\t\tgoto out;\n\t}\n\tdevpath_string = kmalloc(strlen(devpath) + 15, GFP_KERNEL);\n\tif (!devpath_string) {\n\t\terror = -ENOMEM;\n\t\tgoto out;\n\t}\n\tsprintf(devpath_string, \"DEVPATH_OLD=%s\", devpath);\n\tenvp[0] = devpath_string;\n\tenvp[1] = NULL;\n\terror = sysfs_move_dir_ns(kobj, new_parent, kobject_namespace(kobj));\n\tif (error)\n\t\tgoto out;\n\told_parent = kobj->parent;\n\tkobj->parent = new_parent;\n\tnew_parent = NULL;\n\tkobject_put(old_parent);\n\tkobject_uevent_env(kobj, KOBJ_MOVE, envp);\nout:\n\tkobject_put(new_parent);\n\tkobject_put(kobj);\n\tkfree(devpath_string);\n\tkfree(devpath);\n\treturn error;\n}\nEXPORT_SYMBOL_GPL(kobject_move);\n\nstatic void __kobject_del(struct kobject *kobj)\n{\n\tstruct kernfs_node *sd;\n\tconst struct kobj_type *ktype;\n\n\tsd = kobj->sd;\n\tktype = get_ktype(kobj);\n\n\tsysfs_remove_groups(kobj, ktype->default_groups);\n\n\t \n\tif (kobj->state_add_uevent_sent && !kobj->state_remove_uevent_sent) {\n\t\tpr_debug(\"'%s' (%p): auto cleanup 'remove' event\\n\",\n\t\t\t kobject_name(kobj), kobj);\n\t\tkobject_uevent(kobj, KOBJ_REMOVE);\n\t}\n\n\tsysfs_remove_dir(kobj);\n\tsysfs_put(sd);\n\n\tkobj->state_in_sysfs = 0;\n\tkobj_kset_leave(kobj);\n\tkobj->parent = NULL;\n}\n\n \nvoid kobject_del(struct kobject *kobj)\n{\n\tstruct kobject *parent;\n\n\tif (!kobj)\n\t\treturn;\n\n\tparent = kobj->parent;\n\t__kobject_del(kobj);\n\tkobject_put(parent);\n}\nEXPORT_SYMBOL(kobject_del);\n\n \nstruct kobject *kobject_get(struct kobject *kobj)\n{\n\tif (kobj) {\n\t\tif (!kobj->state_initialized)\n\t\t\tWARN(1, KERN_WARNING\n\t\t\t\t\"kobject: '%s' (%p): is not initialized, yet kobject_get() is being called.\\n\",\n\t\t\t     kobject_name(kobj), kobj);\n\t\tkref_get(&kobj->kref);\n\t}\n\treturn kobj;\n}\nEXPORT_SYMBOL(kobject_get);\n\nstruct kobject * __must_check kobject_get_unless_zero(struct kobject *kobj)\n{\n\tif (!kobj)\n\t\treturn NULL;\n\tif (!kref_get_unless_zero(&kobj->kref))\n\t\tkobj = NULL;\n\treturn kobj;\n}\nEXPORT_SYMBOL(kobject_get_unless_zero);\n\n \nstatic void kobject_cleanup(struct kobject *kobj)\n{\n\tstruct kobject *parent = kobj->parent;\n\tconst struct kobj_type *t = get_ktype(kobj);\n\tconst char *name = kobj->name;\n\n\tpr_debug(\"'%s' (%p): %s, parent %p\\n\",\n\t\t kobject_name(kobj), kobj, __func__, kobj->parent);\n\n\t \n\tif (kobj->state_in_sysfs) {\n\t\tpr_debug(\"'%s' (%p): auto cleanup kobject_del\\n\",\n\t\t\t kobject_name(kobj), kobj);\n\t\t__kobject_del(kobj);\n\t} else {\n\t\t \n\t\tparent = NULL;\n\t}\n\n\tif (t->release) {\n\t\tpr_debug(\"'%s' (%p): calling ktype release\\n\",\n\t\t\t kobject_name(kobj), kobj);\n\t\tt->release(kobj);\n\t} else {\n\t\tpr_debug(\"'%s' (%p): does not have a release() function, it is broken and must be fixed. See Documentation/core-api/kobject.rst.\\n\",\n\t\t\t kobject_name(kobj), kobj);\n\t}\n\n\t \n\tif (name) {\n\t\tpr_debug(\"'%s': free name\\n\", name);\n\t\tkfree_const(name);\n\t}\n\n\tkobject_put(parent);\n}\n\n#ifdef CONFIG_DEBUG_KOBJECT_RELEASE\nstatic void kobject_delayed_cleanup(struct work_struct *work)\n{\n\tkobject_cleanup(container_of(to_delayed_work(work),\n\t\t\t\t     struct kobject, release));\n}\n#endif\n\nstatic void kobject_release(struct kref *kref)\n{\n\tstruct kobject *kobj = container_of(kref, struct kobject, kref);\n#ifdef CONFIG_DEBUG_KOBJECT_RELEASE\n\tunsigned long delay = HZ + HZ * get_random_u32_below(4);\n\tpr_info(\"'%s' (%p): %s, parent %p (delayed %ld)\\n\",\n\t\tkobject_name(kobj), kobj, __func__, kobj->parent, delay);\n\tINIT_DELAYED_WORK(&kobj->release, kobject_delayed_cleanup);\n\n\tschedule_delayed_work(&kobj->release, delay);\n#else\n\tkobject_cleanup(kobj);\n#endif\n}\n\n \nvoid kobject_put(struct kobject *kobj)\n{\n\tif (kobj) {\n\t\tif (!kobj->state_initialized)\n\t\t\tWARN(1, KERN_WARNING\n\t\t\t\t\"kobject: '%s' (%p): is not initialized, yet kobject_put() is being called.\\n\",\n\t\t\t     kobject_name(kobj), kobj);\n\t\tkref_put(&kobj->kref, kobject_release);\n\t}\n}\nEXPORT_SYMBOL(kobject_put);\n\nstatic void dynamic_kobj_release(struct kobject *kobj)\n{\n\tpr_debug(\"(%p): %s\\n\", kobj, __func__);\n\tkfree(kobj);\n}\n\nstatic const struct kobj_type dynamic_kobj_ktype = {\n\t.release\t= dynamic_kobj_release,\n\t.sysfs_ops\t= &kobj_sysfs_ops,\n};\n\n \nstatic struct kobject *kobject_create(void)\n{\n\tstruct kobject *kobj;\n\n\tkobj = kzalloc(sizeof(*kobj), GFP_KERNEL);\n\tif (!kobj)\n\t\treturn NULL;\n\n\tkobject_init(kobj, &dynamic_kobj_ktype);\n\treturn kobj;\n}\n\n \nstruct kobject *kobject_create_and_add(const char *name, struct kobject *parent)\n{\n\tstruct kobject *kobj;\n\tint retval;\n\n\tkobj = kobject_create();\n\tif (!kobj)\n\t\treturn NULL;\n\n\tretval = kobject_add(kobj, parent, \"%s\", name);\n\tif (retval) {\n\t\tpr_warn(\"%s: kobject_add error: %d\\n\", __func__, retval);\n\t\tkobject_put(kobj);\n\t\tkobj = NULL;\n\t}\n\treturn kobj;\n}\nEXPORT_SYMBOL_GPL(kobject_create_and_add);\n\n \nvoid kset_init(struct kset *k)\n{\n\tkobject_init_internal(&k->kobj);\n\tINIT_LIST_HEAD(&k->list);\n\tspin_lock_init(&k->list_lock);\n}\n\n \nstatic ssize_t kobj_attr_show(struct kobject *kobj, struct attribute *attr,\n\t\t\t      char *buf)\n{\n\tstruct kobj_attribute *kattr;\n\tssize_t ret = -EIO;\n\n\tkattr = container_of(attr, struct kobj_attribute, attr);\n\tif (kattr->show)\n\t\tret = kattr->show(kobj, kattr, buf);\n\treturn ret;\n}\n\nstatic ssize_t kobj_attr_store(struct kobject *kobj, struct attribute *attr,\n\t\t\t       const char *buf, size_t count)\n{\n\tstruct kobj_attribute *kattr;\n\tssize_t ret = -EIO;\n\n\tkattr = container_of(attr, struct kobj_attribute, attr);\n\tif (kattr->store)\n\t\tret = kattr->store(kobj, kattr, buf, count);\n\treturn ret;\n}\n\nconst struct sysfs_ops kobj_sysfs_ops = {\n\t.show\t= kobj_attr_show,\n\t.store\t= kobj_attr_store,\n};\nEXPORT_SYMBOL_GPL(kobj_sysfs_ops);\n\n \nint kset_register(struct kset *k)\n{\n\tint err;\n\n\tif (!k)\n\t\treturn -EINVAL;\n\n\tif (!k->kobj.ktype) {\n\t\tpr_err(\"must have a ktype to be initialized properly!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tkset_init(k);\n\terr = kobject_add_internal(&k->kobj);\n\tif (err) {\n\t\tkfree_const(k->kobj.name);\n\t\t \n\t\tk->kobj.name = NULL;\n\t\treturn err;\n\t}\n\tkobject_uevent(&k->kobj, KOBJ_ADD);\n\treturn 0;\n}\nEXPORT_SYMBOL(kset_register);\n\n \nvoid kset_unregister(struct kset *k)\n{\n\tif (!k)\n\t\treturn;\n\tkobject_del(&k->kobj);\n\tkobject_put(&k->kobj);\n}\nEXPORT_SYMBOL(kset_unregister);\n\n \nstruct kobject *kset_find_obj(struct kset *kset, const char *name)\n{\n\tstruct kobject *k;\n\tstruct kobject *ret = NULL;\n\n\tspin_lock(&kset->list_lock);\n\n\tlist_for_each_entry(k, &kset->list, entry) {\n\t\tif (kobject_name(k) && !strcmp(kobject_name(k), name)) {\n\t\t\tret = kobject_get_unless_zero(k);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tspin_unlock(&kset->list_lock);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(kset_find_obj);\n\nstatic void kset_release(struct kobject *kobj)\n{\n\tstruct kset *kset = container_of(kobj, struct kset, kobj);\n\tpr_debug(\"'%s' (%p): %s\\n\",\n\t\t kobject_name(kobj), kobj, __func__);\n\tkfree(kset);\n}\n\nstatic void kset_get_ownership(const struct kobject *kobj, kuid_t *uid, kgid_t *gid)\n{\n\tif (kobj->parent)\n\t\tkobject_get_ownership(kobj->parent, uid, gid);\n}\n\nstatic const struct kobj_type kset_ktype = {\n\t.sysfs_ops\t= &kobj_sysfs_ops,\n\t.release\t= kset_release,\n\t.get_ownership\t= kset_get_ownership,\n};\n\n \nstatic struct kset *kset_create(const char *name,\n\t\t\t\tconst struct kset_uevent_ops *uevent_ops,\n\t\t\t\tstruct kobject *parent_kobj)\n{\n\tstruct kset *kset;\n\tint retval;\n\n\tkset = kzalloc(sizeof(*kset), GFP_KERNEL);\n\tif (!kset)\n\t\treturn NULL;\n\tretval = kobject_set_name(&kset->kobj, \"%s\", name);\n\tif (retval) {\n\t\tkfree(kset);\n\t\treturn NULL;\n\t}\n\tkset->uevent_ops = uevent_ops;\n\tkset->kobj.parent = parent_kobj;\n\n\t \n\tkset->kobj.ktype = &kset_ktype;\n\tkset->kobj.kset = NULL;\n\n\treturn kset;\n}\n\n \nstruct kset *kset_create_and_add(const char *name,\n\t\t\t\t const struct kset_uevent_ops *uevent_ops,\n\t\t\t\t struct kobject *parent_kobj)\n{\n\tstruct kset *kset;\n\tint error;\n\n\tkset = kset_create(name, uevent_ops, parent_kobj);\n\tif (!kset)\n\t\treturn NULL;\n\terror = kset_register(kset);\n\tif (error) {\n\t\tkfree(kset);\n\t\treturn NULL;\n\t}\n\treturn kset;\n}\nEXPORT_SYMBOL_GPL(kset_create_and_add);\n\n\nstatic DEFINE_SPINLOCK(kobj_ns_type_lock);\nstatic const struct kobj_ns_type_operations *kobj_ns_ops_tbl[KOBJ_NS_TYPES];\n\nint kobj_ns_type_register(const struct kobj_ns_type_operations *ops)\n{\n\tenum kobj_ns_type type = ops->type;\n\tint error;\n\n\tspin_lock(&kobj_ns_type_lock);\n\n\terror = -EINVAL;\n\tif (!kobj_ns_type_is_valid(type))\n\t\tgoto out;\n\n\terror = -EBUSY;\n\tif (kobj_ns_ops_tbl[type])\n\t\tgoto out;\n\n\terror = 0;\n\tkobj_ns_ops_tbl[type] = ops;\n\nout:\n\tspin_unlock(&kobj_ns_type_lock);\n\treturn error;\n}\n\nint kobj_ns_type_registered(enum kobj_ns_type type)\n{\n\tint registered = 0;\n\n\tspin_lock(&kobj_ns_type_lock);\n\tif (kobj_ns_type_is_valid(type))\n\t\tregistered = kobj_ns_ops_tbl[type] != NULL;\n\tspin_unlock(&kobj_ns_type_lock);\n\n\treturn registered;\n}\n\nconst struct kobj_ns_type_operations *kobj_child_ns_ops(const struct kobject *parent)\n{\n\tconst struct kobj_ns_type_operations *ops = NULL;\n\n\tif (parent && parent->ktype->child_ns_type)\n\t\tops = parent->ktype->child_ns_type(parent);\n\n\treturn ops;\n}\n\nconst struct kobj_ns_type_operations *kobj_ns_ops(const struct kobject *kobj)\n{\n\treturn kobj_child_ns_ops(kobj->parent);\n}\n\nbool kobj_ns_current_may_mount(enum kobj_ns_type type)\n{\n\tbool may_mount = true;\n\n\tspin_lock(&kobj_ns_type_lock);\n\tif (kobj_ns_type_is_valid(type) && kobj_ns_ops_tbl[type])\n\t\tmay_mount = kobj_ns_ops_tbl[type]->current_may_mount();\n\tspin_unlock(&kobj_ns_type_lock);\n\n\treturn may_mount;\n}\n\nvoid *kobj_ns_grab_current(enum kobj_ns_type type)\n{\n\tvoid *ns = NULL;\n\n\tspin_lock(&kobj_ns_type_lock);\n\tif (kobj_ns_type_is_valid(type) && kobj_ns_ops_tbl[type])\n\t\tns = kobj_ns_ops_tbl[type]->grab_current_ns();\n\tspin_unlock(&kobj_ns_type_lock);\n\n\treturn ns;\n}\nEXPORT_SYMBOL_GPL(kobj_ns_grab_current);\n\nconst void *kobj_ns_netlink(enum kobj_ns_type type, struct sock *sk)\n{\n\tconst void *ns = NULL;\n\n\tspin_lock(&kobj_ns_type_lock);\n\tif (kobj_ns_type_is_valid(type) && kobj_ns_ops_tbl[type])\n\t\tns = kobj_ns_ops_tbl[type]->netlink_ns(sk);\n\tspin_unlock(&kobj_ns_type_lock);\n\n\treturn ns;\n}\n\nconst void *kobj_ns_initial(enum kobj_ns_type type)\n{\n\tconst void *ns = NULL;\n\n\tspin_lock(&kobj_ns_type_lock);\n\tif (kobj_ns_type_is_valid(type) && kobj_ns_ops_tbl[type])\n\t\tns = kobj_ns_ops_tbl[type]->initial_ns();\n\tspin_unlock(&kobj_ns_type_lock);\n\n\treturn ns;\n}\n\nvoid kobj_ns_drop(enum kobj_ns_type type, void *ns)\n{\n\tspin_lock(&kobj_ns_type_lock);\n\tif (kobj_ns_type_is_valid(type) &&\n\t    kobj_ns_ops_tbl[type] && kobj_ns_ops_tbl[type]->drop_ns)\n\t\tkobj_ns_ops_tbl[type]->drop_ns(ns);\n\tspin_unlock(&kobj_ns_type_lock);\n}\nEXPORT_SYMBOL_GPL(kobj_ns_drop);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}