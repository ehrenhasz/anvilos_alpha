{
  "module_name": "asn1_decoder.c",
  "hash_id": "8396d09f428968217acbc6644f12ba087eefaad9b12bef680ee83a03f0782dd5",
  "original_prompt": "Ingested from linux-6.6.14/lib/asn1_decoder.c",
  "human_readable_source": "\n \n\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n#include <linux/asn1_decoder.h>\n#include <linux/asn1_ber_bytecode.h>\n\nstatic const unsigned char asn1_op_lengths[ASN1_OP__NR] = {\n\t \n\t[ASN1_OP_MATCH]\t\t\t\t= 1 + 1,\n\t[ASN1_OP_MATCH_OR_SKIP]\t\t\t= 1 + 1,\n\t[ASN1_OP_MATCH_ACT]\t\t\t= 1 + 1     + 1,\n\t[ASN1_OP_MATCH_ACT_OR_SKIP]\t\t= 1 + 1     + 1,\n\t[ASN1_OP_MATCH_JUMP]\t\t\t= 1 + 1 + 1,\n\t[ASN1_OP_MATCH_JUMP_OR_SKIP]\t\t= 1 + 1 + 1,\n\t[ASN1_OP_MATCH_ANY]\t\t\t= 1,\n\t[ASN1_OP_MATCH_ANY_OR_SKIP]\t\t= 1,\n\t[ASN1_OP_MATCH_ANY_ACT]\t\t\t= 1         + 1,\n\t[ASN1_OP_MATCH_ANY_ACT_OR_SKIP]\t\t= 1         + 1,\n\t[ASN1_OP_COND_MATCH_OR_SKIP]\t\t= 1 + 1,\n\t[ASN1_OP_COND_MATCH_ACT_OR_SKIP]\t= 1 + 1     + 1,\n\t[ASN1_OP_COND_MATCH_JUMP_OR_SKIP]\t= 1 + 1 + 1,\n\t[ASN1_OP_COND_MATCH_ANY]\t\t= 1,\n\t[ASN1_OP_COND_MATCH_ANY_OR_SKIP]\t= 1,\n\t[ASN1_OP_COND_MATCH_ANY_ACT]\t\t= 1         + 1,\n\t[ASN1_OP_COND_MATCH_ANY_ACT_OR_SKIP]\t= 1         + 1,\n\t[ASN1_OP_COND_FAIL]\t\t\t= 1,\n\t[ASN1_OP_COMPLETE]\t\t\t= 1,\n\t[ASN1_OP_ACT]\t\t\t\t= 1         + 1,\n\t[ASN1_OP_MAYBE_ACT]\t\t\t= 1         + 1,\n\t[ASN1_OP_RETURN]\t\t\t= 1,\n\t[ASN1_OP_END_SEQ]\t\t\t= 1,\n\t[ASN1_OP_END_SEQ_OF]\t\t\t= 1     + 1,\n\t[ASN1_OP_END_SET]\t\t\t= 1,\n\t[ASN1_OP_END_SET_OF]\t\t\t= 1     + 1,\n\t[ASN1_OP_END_SEQ_ACT]\t\t\t= 1         + 1,\n\t[ASN1_OP_END_SEQ_OF_ACT]\t\t= 1     + 1 + 1,\n\t[ASN1_OP_END_SET_ACT]\t\t\t= 1         + 1,\n\t[ASN1_OP_END_SET_OF_ACT]\t\t= 1     + 1 + 1,\n};\n\n \nstatic int asn1_find_indefinite_length(const unsigned char *data, size_t datalen,\n\t\t\t\t       size_t *_dp, size_t *_len,\n\t\t\t\t       const char **_errmsg)\n{\n\tunsigned char tag, tmp;\n\tsize_t dp = *_dp, len, n;\n\tint indef_level = 1;\n\nnext_tag:\n\tif (unlikely(datalen - dp < 2)) {\n\t\tif (datalen == dp)\n\t\t\tgoto missing_eoc;\n\t\tgoto data_overrun_error;\n\t}\n\n\t \n\ttag = data[dp++];\n\tif (tag == ASN1_EOC) {\n\t\t \n\t\tif (data[dp++] != 0)\n\t\t\tgoto invalid_eoc;\n\t\tif (--indef_level <= 0) {\n\t\t\t*_len = dp - *_dp;\n\t\t\t*_dp = dp;\n\t\t\treturn 0;\n\t\t}\n\t\tgoto next_tag;\n\t}\n\n\tif (unlikely((tag & 0x1f) == ASN1_LONG_TAG)) {\n\t\tdo {\n\t\t\tif (unlikely(datalen - dp < 2))\n\t\t\t\tgoto data_overrun_error;\n\t\t\ttmp = data[dp++];\n\t\t} while (tmp & 0x80);\n\t}\n\n\t \n\tlen = data[dp++];\n\tif (len <= 0x7f)\n\t\tgoto check_length;\n\n\tif (unlikely(len == ASN1_INDEFINITE_LENGTH)) {\n\t\t \n\t\tif (unlikely((tag & ASN1_CONS_BIT) == ASN1_PRIM << 5))\n\t\t\tgoto indefinite_len_primitive;\n\t\tindef_level++;\n\t\tgoto next_tag;\n\t}\n\n\tn = len - 0x80;\n\tif (unlikely(n > sizeof(len) - 1))\n\t\tgoto length_too_long;\n\tif (unlikely(n > datalen - dp))\n\t\tgoto data_overrun_error;\n\tlen = 0;\n\tfor (; n > 0; n--) {\n\t\tlen <<= 8;\n\t\tlen |= data[dp++];\n\t}\ncheck_length:\n\tif (len > datalen - dp)\n\t\tgoto data_overrun_error;\n\tdp += len;\n\tgoto next_tag;\n\nlength_too_long:\n\t*_errmsg = \"Unsupported length\";\n\tgoto error;\nindefinite_len_primitive:\n\t*_errmsg = \"Indefinite len primitive not permitted\";\n\tgoto error;\ninvalid_eoc:\n\t*_errmsg = \"Invalid length EOC\";\n\tgoto error;\ndata_overrun_error:\n\t*_errmsg = \"Data overrun error\";\n\tgoto error;\nmissing_eoc:\n\t*_errmsg = \"Missing EOC in indefinite len cons\";\nerror:\n\t*_dp = dp;\n\treturn -1;\n}\n\n \nint asn1_ber_decoder(const struct asn1_decoder *decoder,\n\t\t     void *context,\n\t\t     const unsigned char *data,\n\t\t     size_t datalen)\n{\n\tconst unsigned char *machine = decoder->machine;\n\tconst asn1_action_t *actions = decoder->actions;\n\tsize_t machlen = decoder->machlen;\n\tenum asn1_opcode op;\n\tunsigned char tag = 0, csp = 0, jsp = 0, optag = 0, hdr = 0;\n\tconst char *errmsg;\n\tsize_t pc = 0, dp = 0, tdp = 0, len = 0;\n\tint ret;\n\n\tunsigned char flags = 0;\n#define FLAG_INDEFINITE_LENGTH\t0x01\n#define FLAG_MATCHED\t\t0x02\n#define FLAG_LAST_MATCHED\t0x04  \n#define FLAG_CONS\t\t0x20  \n\n#define NR_CONS_STACK 10\n\tunsigned short cons_dp_stack[NR_CONS_STACK];\n\tunsigned short cons_datalen_stack[NR_CONS_STACK];\n\tunsigned char cons_hdrlen_stack[NR_CONS_STACK];\n#define NR_JUMP_STACK 10\n\tunsigned char jump_stack[NR_JUMP_STACK];\n\n\tif (datalen > 65535)\n\t\treturn -EMSGSIZE;\n\nnext_op:\n\tpr_debug(\"next_op: pc=\\e[32m%zu\\e[m/%zu dp=\\e[33m%zu\\e[m/%zu C=%d J=%d\\n\",\n\t\t pc, machlen, dp, datalen, csp, jsp);\n\tif (unlikely(pc >= machlen))\n\t\tgoto machine_overrun_error;\n\top = machine[pc];\n\tif (unlikely(pc + asn1_op_lengths[op] > machlen))\n\t\tgoto machine_overrun_error;\n\n\t \n\tif (op <= ASN1_OP__MATCHES_TAG) {\n\t\tunsigned char tmp;\n\n\t\t \n\t\tif ((op & ASN1_OP_MATCH__COND && flags & FLAG_MATCHED) ||\n\t\t    (op & ASN1_OP_MATCH__SKIP && dp == datalen)) {\n\t\t\tflags &= ~FLAG_LAST_MATCHED;\n\t\t\tpc += asn1_op_lengths[op];\n\t\t\tgoto next_op;\n\t\t}\n\n\t\tflags = 0;\n\t\thdr = 2;\n\n\t\t \n\t\tif (unlikely(datalen - dp < 2))\n\t\t\tgoto data_overrun_error;\n\t\ttag = data[dp++];\n\t\tif (unlikely((tag & 0x1f) == ASN1_LONG_TAG))\n\t\t\tgoto long_tag_not_supported;\n\n\t\tif (op & ASN1_OP_MATCH__ANY) {\n\t\t\tpr_debug(\"- any %02x\\n\", tag);\n\t\t} else {\n\t\t\t \n\t\t\toptag = machine[pc + 1];\n\t\t\tflags |= optag & FLAG_CONS;\n\n\t\t\t \n\t\t\ttmp = optag ^ tag;\n\t\t\ttmp &= ~(optag & ASN1_CONS_BIT);\n\t\t\tpr_debug(\"- match? %02x %02x %02x\\n\", tag, optag, tmp);\n\t\t\tif (tmp != 0) {\n\t\t\t\t \n\t\t\t\tif (op & ASN1_OP_MATCH__SKIP) {\n\t\t\t\t\tpc += asn1_op_lengths[op];\n\t\t\t\t\tdp--;\n\t\t\t\t\tgoto next_op;\n\t\t\t\t}\n\t\t\t\tgoto tag_mismatch;\n\t\t\t}\n\t\t}\n\t\tflags |= FLAG_MATCHED;\n\n\t\tlen = data[dp++];\n\t\tif (len > 0x7f) {\n\t\t\tif (unlikely(len == ASN1_INDEFINITE_LENGTH)) {\n\t\t\t\t \n\t\t\t\tif (unlikely(!(tag & ASN1_CONS_BIT)))\n\t\t\t\t\tgoto indefinite_len_primitive;\n\t\t\t\tflags |= FLAG_INDEFINITE_LENGTH;\n\t\t\t\tif (unlikely(2 > datalen - dp))\n\t\t\t\t\tgoto data_overrun_error;\n\t\t\t} else {\n\t\t\t\tint n = len - 0x80;\n\t\t\t\tif (unlikely(n > 2))\n\t\t\t\t\tgoto length_too_long;\n\t\t\t\tif (unlikely(n > datalen - dp))\n\t\t\t\t\tgoto data_overrun_error;\n\t\t\t\thdr += n;\n\t\t\t\tfor (len = 0; n > 0; n--) {\n\t\t\t\t\tlen <<= 8;\n\t\t\t\t\tlen |= data[dp++];\n\t\t\t\t}\n\t\t\t\tif (unlikely(len > datalen - dp))\n\t\t\t\t\tgoto data_overrun_error;\n\t\t\t}\n\t\t} else {\n\t\t\tif (unlikely(len > datalen - dp))\n\t\t\t\tgoto data_overrun_error;\n\t\t}\n\n\t\tif (flags & FLAG_CONS) {\n\t\t\t \n\t\t\tif (unlikely(csp >= NR_CONS_STACK))\n\t\t\t\tgoto cons_stack_overflow;\n\t\t\tcons_dp_stack[csp] = dp;\n\t\t\tcons_hdrlen_stack[csp] = hdr;\n\t\t\tif (!(flags & FLAG_INDEFINITE_LENGTH)) {\n\t\t\t\tcons_datalen_stack[csp] = datalen;\n\t\t\t\tdatalen = dp + len;\n\t\t\t} else {\n\t\t\t\tcons_datalen_stack[csp] = 0;\n\t\t\t}\n\t\t\tcsp++;\n\t\t}\n\n\t\tpr_debug(\"- TAG: %02x %zu%s\\n\",\n\t\t\t tag, len, flags & FLAG_CONS ? \" CONS\" : \"\");\n\t\ttdp = dp;\n\t}\n\n\t \n\tswitch (op) {\n\tcase ASN1_OP_MATCH:\n\tcase ASN1_OP_MATCH_OR_SKIP:\n\tcase ASN1_OP_MATCH_ACT:\n\tcase ASN1_OP_MATCH_ACT_OR_SKIP:\n\tcase ASN1_OP_MATCH_ANY:\n\tcase ASN1_OP_MATCH_ANY_OR_SKIP:\n\tcase ASN1_OP_MATCH_ANY_ACT:\n\tcase ASN1_OP_MATCH_ANY_ACT_OR_SKIP:\n\tcase ASN1_OP_COND_MATCH_OR_SKIP:\n\tcase ASN1_OP_COND_MATCH_ACT_OR_SKIP:\n\tcase ASN1_OP_COND_MATCH_ANY:\n\tcase ASN1_OP_COND_MATCH_ANY_OR_SKIP:\n\tcase ASN1_OP_COND_MATCH_ANY_ACT:\n\tcase ASN1_OP_COND_MATCH_ANY_ACT_OR_SKIP:\n\n\t\tif (!(flags & FLAG_CONS)) {\n\t\t\tif (flags & FLAG_INDEFINITE_LENGTH) {\n\t\t\t\tsize_t tmp = dp;\n\n\t\t\t\tret = asn1_find_indefinite_length(\n\t\t\t\t\tdata, datalen, &tmp, &len, &errmsg);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tpr_debug(\"- LEAF: %zu\\n\", len);\n\t\t}\n\n\t\tif (op & ASN1_OP_MATCH__ACT) {\n\t\t\tunsigned char act;\n\n\t\t\tif (op & ASN1_OP_MATCH__ANY)\n\t\t\t\tact = machine[pc + 1];\n\t\t\telse\n\t\t\t\tact = machine[pc + 2];\n\t\t\tret = actions[act](context, hdr, tag, data + dp, len);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t}\n\n\t\tif (!(flags & FLAG_CONS))\n\t\t\tdp += len;\n\t\tpc += asn1_op_lengths[op];\n\t\tgoto next_op;\n\n\tcase ASN1_OP_MATCH_JUMP:\n\tcase ASN1_OP_MATCH_JUMP_OR_SKIP:\n\tcase ASN1_OP_COND_MATCH_JUMP_OR_SKIP:\n\t\tpr_debug(\"- MATCH_JUMP\\n\");\n\t\tif (unlikely(jsp == NR_JUMP_STACK))\n\t\t\tgoto jump_stack_overflow;\n\t\tjump_stack[jsp++] = pc + asn1_op_lengths[op];\n\t\tpc = machine[pc + 2];\n\t\tgoto next_op;\n\n\tcase ASN1_OP_COND_FAIL:\n\t\tif (unlikely(!(flags & FLAG_MATCHED)))\n\t\t\tgoto tag_mismatch;\n\t\tpc += asn1_op_lengths[op];\n\t\tgoto next_op;\n\n\tcase ASN1_OP_COMPLETE:\n\t\tif (unlikely(jsp != 0 || csp != 0)) {\n\t\t\tpr_err(\"ASN.1 decoder error: Stacks not empty at completion (%u, %u)\\n\",\n\t\t\t       jsp, csp);\n\t\t\treturn -EBADMSG;\n\t\t}\n\t\treturn 0;\n\n\tcase ASN1_OP_END_SET:\n\tcase ASN1_OP_END_SET_ACT:\n\t\tif (unlikely(!(flags & FLAG_MATCHED)))\n\t\t\tgoto tag_mismatch;\n\t\tfallthrough;\n\n\tcase ASN1_OP_END_SEQ:\n\tcase ASN1_OP_END_SET_OF:\n\tcase ASN1_OP_END_SEQ_OF:\n\tcase ASN1_OP_END_SEQ_ACT:\n\tcase ASN1_OP_END_SET_OF_ACT:\n\tcase ASN1_OP_END_SEQ_OF_ACT:\n\t\tif (unlikely(csp <= 0))\n\t\t\tgoto cons_stack_underflow;\n\t\tcsp--;\n\t\ttdp = cons_dp_stack[csp];\n\t\thdr = cons_hdrlen_stack[csp];\n\t\tlen = datalen;\n\t\tdatalen = cons_datalen_stack[csp];\n\t\tpr_debug(\"- end cons t=%zu dp=%zu l=%zu/%zu\\n\",\n\t\t\t tdp, dp, len, datalen);\n\t\tif (datalen == 0) {\n\t\t\t \n\t\t\tdatalen = len;\n\t\t\tif (unlikely(datalen - dp < 2))\n\t\t\t\tgoto data_overrun_error;\n\t\t\tif (data[dp++] != 0) {\n\t\t\t\tif (op & ASN1_OP_END__OF) {\n\t\t\t\t\tdp--;\n\t\t\t\t\tcsp++;\n\t\t\t\t\tpc = machine[pc + 1];\n\t\t\t\t\tpr_debug(\"- continue\\n\");\n\t\t\t\t\tgoto next_op;\n\t\t\t\t}\n\t\t\t\tgoto missing_eoc;\n\t\t\t}\n\t\t\tif (data[dp++] != 0)\n\t\t\t\tgoto invalid_eoc;\n\t\t\tlen = dp - tdp - 2;\n\t\t} else {\n\t\t\tif (dp < len && (op & ASN1_OP_END__OF)) {\n\t\t\t\tdatalen = len;\n\t\t\t\tcsp++;\n\t\t\t\tpc = machine[pc + 1];\n\t\t\t\tpr_debug(\"- continue\\n\");\n\t\t\t\tgoto next_op;\n\t\t\t}\n\t\t\tif (dp != len)\n\t\t\t\tgoto cons_length_error;\n\t\t\tlen -= tdp;\n\t\t\tpr_debug(\"- cons len l=%zu d=%zu\\n\", len, dp - tdp);\n\t\t}\n\n\t\tif (op & ASN1_OP_END__ACT) {\n\t\t\tunsigned char act;\n\t\t\tif (op & ASN1_OP_END__OF)\n\t\t\t\tact = machine[pc + 2];\n\t\t\telse\n\t\t\t\tact = machine[pc + 1];\n\t\t\tret = actions[act](context, hdr, 0, data + tdp, len);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t}\n\t\tpc += asn1_op_lengths[op];\n\t\tgoto next_op;\n\n\tcase ASN1_OP_MAYBE_ACT:\n\t\tif (!(flags & FLAG_LAST_MATCHED)) {\n\t\t\tpc += asn1_op_lengths[op];\n\t\t\tgoto next_op;\n\t\t}\n\t\tfallthrough;\n\n\tcase ASN1_OP_ACT:\n\t\tret = actions[machine[pc + 1]](context, hdr, tag, data + tdp, len);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tpc += asn1_op_lengths[op];\n\t\tgoto next_op;\n\n\tcase ASN1_OP_RETURN:\n\t\tif (unlikely(jsp <= 0))\n\t\t\tgoto jump_stack_underflow;\n\t\tpc = jump_stack[--jsp];\n\t\tflags |= FLAG_MATCHED | FLAG_LAST_MATCHED;\n\t\tgoto next_op;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\t \n\tpr_err(\"ASN.1 decoder error: Found reserved opcode (%u) pc=%zu\\n\",\n\t       op, pc);\n\treturn -EBADMSG;\n\ndata_overrun_error:\n\terrmsg = \"Data overrun error\";\n\tgoto error;\nmachine_overrun_error:\n\terrmsg = \"Machine overrun error\";\n\tgoto error;\njump_stack_underflow:\n\terrmsg = \"Jump stack underflow\";\n\tgoto error;\njump_stack_overflow:\n\terrmsg = \"Jump stack overflow\";\n\tgoto error;\ncons_stack_underflow:\n\terrmsg = \"Cons stack underflow\";\n\tgoto error;\ncons_stack_overflow:\n\terrmsg = \"Cons stack overflow\";\n\tgoto error;\ncons_length_error:\n\terrmsg = \"Cons length error\";\n\tgoto error;\nmissing_eoc:\n\terrmsg = \"Missing EOC in indefinite len cons\";\n\tgoto error;\ninvalid_eoc:\n\terrmsg = \"Invalid length EOC\";\n\tgoto error;\nlength_too_long:\n\terrmsg = \"Unsupported length\";\n\tgoto error;\nindefinite_len_primitive:\n\terrmsg = \"Indefinite len primitive not permitted\";\n\tgoto error;\ntag_mismatch:\n\terrmsg = \"Unexpected tag\";\n\tgoto error;\nlong_tag_not_supported:\n\terrmsg = \"Long tag not supported\";\nerror:\n\tpr_debug(\"\\nASN1: %s [m=%zu d=%zu ot=%02x t=%02x l=%zu]\\n\",\n\t\t errmsg, pc, dp, optag, tag, len);\n\treturn -EBADMSG;\n}\nEXPORT_SYMBOL_GPL(asn1_ber_decoder);\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}