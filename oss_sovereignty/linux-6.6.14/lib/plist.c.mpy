{
  "module_name": "plist.c",
  "hash_id": "16eeb21e978160ab8d38466a8938fd666124ff634b273b83d4d31e7b982d98b0",
  "original_prompt": "Ingested from linux-6.6.14/lib/plist.c",
  "human_readable_source": "\n \n\n#include <linux/bug.h>\n#include <linux/plist.h>\n\n#ifdef CONFIG_DEBUG_PLIST\n\nstatic struct plist_head test_head;\n\nstatic void plist_check_prev_next(struct list_head *t, struct list_head *p,\n\t\t\t\t  struct list_head *n)\n{\n\tWARN(n->prev != p || p->next != n,\n\t\t\t\"top: %p, n: %p, p: %p\\n\"\n\t\t\t\"prev: %p, n: %p, p: %p\\n\"\n\t\t\t\"next: %p, n: %p, p: %p\\n\",\n\t\t\t t, t->next, t->prev,\n\t\t\tp, p->next, p->prev,\n\t\t\tn, n->next, n->prev);\n}\n\nstatic void plist_check_list(struct list_head *top)\n{\n\tstruct list_head *prev = top, *next = top->next;\n\n\tplist_check_prev_next(top, prev, next);\n\twhile (next != top) {\n\t\tprev = next;\n\t\tnext = prev->next;\n\t\tplist_check_prev_next(top, prev, next);\n\t}\n}\n\nstatic void plist_check_head(struct plist_head *head)\n{\n\tif (!plist_head_empty(head))\n\t\tplist_check_list(&plist_first(head)->prio_list);\n\tplist_check_list(&head->node_list);\n}\n\n#else\n# define plist_check_head(h)\tdo { } while (0)\n#endif\n\n \nvoid plist_add(struct plist_node *node, struct plist_head *head)\n{\n\tstruct plist_node *first, *iter, *prev = NULL;\n\tstruct list_head *node_next = &head->node_list;\n\n\tplist_check_head(head);\n\tWARN_ON(!plist_node_empty(node));\n\tWARN_ON(!list_empty(&node->prio_list));\n\n\tif (plist_head_empty(head))\n\t\tgoto ins_node;\n\n\tfirst = iter = plist_first(head);\n\n\tdo {\n\t\tif (node->prio < iter->prio) {\n\t\t\tnode_next = &iter->node_list;\n\t\t\tbreak;\n\t\t}\n\n\t\tprev = iter;\n\t\titer = list_entry(iter->prio_list.next,\n\t\t\t\tstruct plist_node, prio_list);\n\t} while (iter != first);\n\n\tif (!prev || prev->prio != node->prio)\n\t\tlist_add_tail(&node->prio_list, &iter->prio_list);\nins_node:\n\tlist_add_tail(&node->node_list, node_next);\n\n\tplist_check_head(head);\n}\n\n \nvoid plist_del(struct plist_node *node, struct plist_head *head)\n{\n\tplist_check_head(head);\n\n\tif (!list_empty(&node->prio_list)) {\n\t\tif (node->node_list.next != &head->node_list) {\n\t\t\tstruct plist_node *next;\n\n\t\t\tnext = list_entry(node->node_list.next,\n\t\t\t\t\tstruct plist_node, node_list);\n\n\t\t\t \n\t\t\tif (list_empty(&next->prio_list))\n\t\t\t\tlist_add(&next->prio_list, &node->prio_list);\n\t\t}\n\t\tlist_del_init(&node->prio_list);\n\t}\n\n\tlist_del_init(&node->node_list);\n\n\tplist_check_head(head);\n}\n\n \nvoid plist_requeue(struct plist_node *node, struct plist_head *head)\n{\n\tstruct plist_node *iter;\n\tstruct list_head *node_next = &head->node_list;\n\n\tplist_check_head(head);\n\tBUG_ON(plist_head_empty(head));\n\tBUG_ON(plist_node_empty(node));\n\n\tif (node == plist_last(head))\n\t\treturn;\n\n\titer = plist_next(node);\n\n\tif (node->prio != iter->prio)\n\t\treturn;\n\n\tplist_del(node, head);\n\n\tplist_for_each_continue(iter, head) {\n\t\tif (node->prio != iter->prio) {\n\t\t\tnode_next = &iter->node_list;\n\t\t\tbreak;\n\t\t}\n\t}\n\tlist_add_tail(&node->node_list, node_next);\n\n\tplist_check_head(head);\n}\n\n#ifdef CONFIG_DEBUG_PLIST\n#include <linux/sched.h>\n#include <linux/sched/clock.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic struct plist_node __initdata test_node[241];\n\nstatic void __init plist_test_check(int nr_expect)\n{\n\tstruct plist_node *first, *prio_pos, *node_pos;\n\n\tif (plist_head_empty(&test_head)) {\n\t\tBUG_ON(nr_expect != 0);\n\t\treturn;\n\t}\n\n\tprio_pos = first = plist_first(&test_head);\n\tplist_for_each(node_pos, &test_head) {\n\t\tif (nr_expect-- < 0)\n\t\t\tbreak;\n\t\tif (node_pos == first)\n\t\t\tcontinue;\n\t\tif (node_pos->prio == prio_pos->prio) {\n\t\t\tBUG_ON(!list_empty(&node_pos->prio_list));\n\t\t\tcontinue;\n\t\t}\n\n\t\tBUG_ON(prio_pos->prio > node_pos->prio);\n\t\tBUG_ON(prio_pos->prio_list.next != &node_pos->prio_list);\n\t\tprio_pos = node_pos;\n\t}\n\n\tBUG_ON(nr_expect != 0);\n\tBUG_ON(prio_pos->prio_list.next != &first->prio_list);\n}\n\nstatic void __init plist_test_requeue(struct plist_node *node)\n{\n\tplist_requeue(node, &test_head);\n\n\tif (node != plist_last(&test_head))\n\t\tBUG_ON(node->prio == plist_next(node)->prio);\n}\n\nstatic int  __init plist_test(void)\n{\n\tint nr_expect = 0, i, loop;\n\tunsigned int r = local_clock();\n\n\tprintk(KERN_DEBUG \"start plist test\\n\");\n\tplist_head_init(&test_head);\n\tfor (i = 0; i < ARRAY_SIZE(test_node); i++)\n\t\tplist_node_init(test_node + i, 0);\n\n\tfor (loop = 0; loop < 1000; loop++) {\n\t\tr = r * 193939 % 47629;\n\t\ti = r % ARRAY_SIZE(test_node);\n\t\tif (plist_node_empty(test_node + i)) {\n\t\t\tr = r * 193939 % 47629;\n\t\t\ttest_node[i].prio = r % 99;\n\t\t\tplist_add(test_node + i, &test_head);\n\t\t\tnr_expect++;\n\t\t} else {\n\t\t\tplist_del(test_node + i, &test_head);\n\t\t\tnr_expect--;\n\t\t}\n\t\tplist_test_check(nr_expect);\n\t\tif (!plist_node_empty(test_node + i)) {\n\t\t\tplist_test_requeue(test_node + i);\n\t\t\tplist_test_check(nr_expect);\n\t\t}\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(test_node); i++) {\n\t\tif (plist_node_empty(test_node + i))\n\t\t\tcontinue;\n\t\tplist_del(test_node + i, &test_head);\n\t\tnr_expect--;\n\t\tplist_test_check(nr_expect);\n\t}\n\n\tprintk(KERN_DEBUG \"end plist test\\n\");\n\treturn 0;\n}\n\nmodule_init(plist_test);\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}