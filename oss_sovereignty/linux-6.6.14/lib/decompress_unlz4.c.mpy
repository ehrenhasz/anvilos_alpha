{
  "module_name": "decompress_unlz4.c",
  "hash_id": "4b9b773b939d86bb0e15d20e1e744145d8fa86cbd365a459d52f970c17794347",
  "original_prompt": "Ingested from linux-6.6.14/lib/decompress_unlz4.c",
  "human_readable_source": "\n \n\n#ifdef STATIC\n#define PREBOOT\n#include \"lz4/lz4_decompress.c\"\n#else\n#include <linux/decompress/unlz4.h>\n#endif\n#include <linux/types.h>\n#include <linux/lz4.h>\n#include <linux/decompress/mm.h>\n#include <linux/compiler.h>\n\n#include <asm/unaligned.h>\n\n \n#define LZ4_DEFAULT_UNCOMPRESSED_CHUNK_SIZE (8 << 20)\n#define ARCHIVE_MAGICNUMBER 0x184C2102\n\nSTATIC inline int INIT unlz4(u8 *input, long in_len,\n\t\t\t\tlong (*fill)(void *, unsigned long),\n\t\t\t\tlong (*flush)(void *, unsigned long),\n\t\t\t\tu8 *output, long *posp,\n\t\t\t\tvoid (*error) (char *x))\n{\n\tint ret = -1;\n\tsize_t chunksize = 0;\n\tsize_t uncomp_chunksize = LZ4_DEFAULT_UNCOMPRESSED_CHUNK_SIZE;\n\tu8 *inp;\n\tu8 *inp_start;\n\tu8 *outp;\n\tlong size = in_len;\n#ifdef PREBOOT\n\tsize_t out_len = get_unaligned_le32(input + in_len);\n#endif\n\tsize_t dest_len;\n\n\n\tif (output) {\n\t\toutp = output;\n\t} else if (!flush) {\n\t\terror(\"NULL output pointer and no flush function provided\");\n\t\tgoto exit_0;\n\t} else {\n\t\toutp = large_malloc(uncomp_chunksize);\n\t\tif (!outp) {\n\t\t\terror(\"Could not allocate output buffer\");\n\t\t\tgoto exit_0;\n\t\t}\n\t}\n\n\tif (input && fill) {\n\t\terror(\"Both input pointer and fill function provided,\");\n\t\tgoto exit_1;\n\t} else if (input) {\n\t\tinp = input;\n\t} else if (!fill) {\n\t\terror(\"NULL input pointer and missing fill function\");\n\t\tgoto exit_1;\n\t} else {\n\t\tinp = large_malloc(LZ4_compressBound(uncomp_chunksize));\n\t\tif (!inp) {\n\t\t\terror(\"Could not allocate input buffer\");\n\t\t\tgoto exit_1;\n\t\t}\n\t}\n\tinp_start = inp;\n\n\tif (posp)\n\t\t*posp = 0;\n\n\tif (fill) {\n\t\tsize = fill(inp, 4);\n\t\tif (size < 4) {\n\t\t\terror(\"data corrupted\");\n\t\t\tgoto exit_2;\n\t\t}\n\t}\n\n\tchunksize = get_unaligned_le32(inp);\n\tif (chunksize == ARCHIVE_MAGICNUMBER) {\n\t\tif (!fill) {\n\t\t\tinp += 4;\n\t\t\tsize -= 4;\n\t\t}\n\t} else {\n\t\terror(\"invalid header\");\n\t\tgoto exit_2;\n\t}\n\n\tif (posp)\n\t\t*posp += 4;\n\n\tfor (;;) {\n\n\t\tif (fill) {\n\t\t\tsize = fill(inp, 4);\n\t\t\tif (size == 0)\n\t\t\t\tbreak;\n\t\t\tif (size < 4) {\n\t\t\t\terror(\"data corrupted\");\n\t\t\t\tgoto exit_2;\n\t\t\t}\n\t\t} else if (size < 4) {\n\t\t\t \n\t\t\tgoto exit_3;\n\t\t}\n\n\t\tchunksize = get_unaligned_le32(inp);\n\t\tif (chunksize == ARCHIVE_MAGICNUMBER) {\n\t\t\tif (!fill) {\n\t\t\t\tinp += 4;\n\t\t\t\tsize -= 4;\n\t\t\t}\n\t\t\tif (posp)\n\t\t\t\t*posp += 4;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!fill && chunksize == 0) {\n\t\t\t \n\t\t\tgoto exit_3;\n\t\t}\n\n\t\tif (posp)\n\t\t\t*posp += 4;\n\n\t\tif (!fill) {\n\t\t\tinp += 4;\n\t\t\tsize -= 4;\n\t\t} else {\n\t\t\tif (chunksize > LZ4_compressBound(uncomp_chunksize)) {\n\t\t\t\terror(\"chunk length is longer than allocated\");\n\t\t\t\tgoto exit_2;\n\t\t\t}\n\t\t\tsize = fill(inp, chunksize);\n\t\t\tif (size < chunksize) {\n\t\t\t\terror(\"data corrupted\");\n\t\t\t\tgoto exit_2;\n\t\t\t}\n\t\t}\n#ifdef PREBOOT\n\t\tif (out_len >= uncomp_chunksize) {\n\t\t\tdest_len = uncomp_chunksize;\n\t\t\tout_len -= dest_len;\n\t\t} else\n\t\t\tdest_len = out_len;\n\n\t\tret = LZ4_decompress_fast(inp, outp, dest_len);\n\t\tchunksize = ret;\n#else\n\t\tdest_len = uncomp_chunksize;\n\n\t\tret = LZ4_decompress_safe(inp, outp, chunksize, dest_len);\n\t\tdest_len = ret;\n#endif\n\t\tif (ret < 0) {\n\t\t\terror(\"Decoding failed\");\n\t\t\tgoto exit_2;\n\t\t}\n\n\t\tret = -1;\n\t\tif (flush && flush(outp, dest_len) != dest_len)\n\t\t\tgoto exit_2;\n\t\tif (output)\n\t\t\toutp += dest_len;\n\t\tif (posp)\n\t\t\t*posp += chunksize;\n\n\t\tif (!fill) {\n\t\t\tsize -= chunksize;\n\n\t\t\tif (size == 0)\n\t\t\t\tbreak;\n\t\t\telse if (size < 0) {\n\t\t\t\terror(\"data corrupted\");\n\t\t\t\tgoto exit_2;\n\t\t\t}\n\t\t\tinp += chunksize;\n\t\t}\n\t}\n\nexit_3:\n\tret = 0;\nexit_2:\n\tif (!input)\n\t\tlarge_free(inp_start);\nexit_1:\n\tif (!output)\n\t\tlarge_free(outp);\nexit_0:\n\treturn ret;\n}\n\n#ifdef PREBOOT\nSTATIC int INIT __decompress(unsigned char *buf, long in_len,\n\t\t\t      long (*fill)(void*, unsigned long),\n\t\t\t      long (*flush)(void*, unsigned long),\n\t\t\t      unsigned char *output, long out_len,\n\t\t\t      long *posp,\n\t\t\t      void (*error)(char *x)\n\t)\n{\n\treturn unlz4(buf, in_len - 4, fill, flush, output, posp, error);\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}