{
  "module_name": "842_decompress.c",
  "hash_id": "b1e64896043e237f9512608173a268117d5dffb5376f30b30aa009ef82aacb9d",
  "original_prompt": "Ingested from linux-6.6.14/lib/842/842_decompress.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n#define MODULE_NAME \"842_decompress\"\n\n#include \"842.h\"\n#include \"842_debugfs.h\"\n\n \n#define I2_FIFO_SIZE\t(2 * (1 << I2_BITS))\n#define I4_FIFO_SIZE\t(4 * (1 << I4_BITS))\n#define I8_FIFO_SIZE\t(8 * (1 << I8_BITS))\n\nstatic u8 decomp_ops[OPS_MAX][4] = {\n\t{ D8, N0, N0, N0 },\n\t{ D4, D2, I2, N0 },\n\t{ D4, I2, D2, N0 },\n\t{ D4, I2, I2, N0 },\n\t{ D4, I4, N0, N0 },\n\t{ D2, I2, D4, N0 },\n\t{ D2, I2, D2, I2 },\n\t{ D2, I2, I2, D2 },\n\t{ D2, I2, I2, I2 },\n\t{ D2, I2, I4, N0 },\n\t{ I2, D2, D4, N0 },\n\t{ I2, D4, I2, N0 },\n\t{ I2, D2, I2, D2 },\n\t{ I2, D2, I2, I2 },\n\t{ I2, D2, I4, N0 },\n\t{ I2, I2, D4, N0 },\n\t{ I2, I2, D2, I2 },\n\t{ I2, I2, I2, D2 },\n\t{ I2, I2, I2, I2 },\n\t{ I2, I2, I4, N0 },\n\t{ I4, D4, N0, N0 },\n\t{ I4, D2, I2, N0 },\n\t{ I4, I2, D2, N0 },\n\t{ I4, I2, I2, N0 },\n\t{ I4, I4, N0, N0 },\n\t{ I8, N0, N0, N0 }\n};\n\nstruct sw842_param {\n\tu8 *in;\n\tu8 bit;\n\tu64 ilen;\n\tu8 *out;\n\tu8 *ostart;\n\tu64 olen;\n};\n\n#define beN_to_cpu(d, s)\t\t\t\t\t\\\n\t((s) == 2 ? be16_to_cpu(get_unaligned((__be16 *)d)) :\t\\\n\t (s) == 4 ? be32_to_cpu(get_unaligned((__be32 *)d)) :\t\\\n\t (s) == 8 ? be64_to_cpu(get_unaligned((__be64 *)d)) :\t\\\n\t 0)\n\nstatic int next_bits(struct sw842_param *p, u64 *d, u8 n);\n\nstatic int __split_next_bits(struct sw842_param *p, u64 *d, u8 n, u8 s)\n{\n\tu64 tmp = 0;\n\tint ret;\n\n\tif (n <= s) {\n\t\tpr_debug(\"split_next_bits invalid n %u s %u\\n\", n, s);\n\t\treturn -EINVAL;\n\t}\n\n\tret = next_bits(p, &tmp, n - s);\n\tif (ret)\n\t\treturn ret;\n\tret = next_bits(p, d, s);\n\tif (ret)\n\t\treturn ret;\n\t*d |= tmp << s;\n\treturn 0;\n}\n\nstatic int next_bits(struct sw842_param *p, u64 *d, u8 n)\n{\n\tu8 *in = p->in, b = p->bit, bits = b + n;\n\n\tif (n > 64) {\n\t\tpr_debug(\"next_bits invalid n %u\\n\", n);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (bits > 64)\n\t\treturn __split_next_bits(p, d, n, 32);\n\telse if (p->ilen < 8 && bits > 32 && bits <= 56)\n\t\treturn __split_next_bits(p, d, n, 16);\n\telse if (p->ilen < 4 && bits > 16 && bits <= 24)\n\t\treturn __split_next_bits(p, d, n, 8);\n\n\tif (DIV_ROUND_UP(bits, 8) > p->ilen)\n\t\treturn -EOVERFLOW;\n\n\tif (bits <= 8)\n\t\t*d = *in >> (8 - bits);\n\telse if (bits <= 16)\n\t\t*d = be16_to_cpu(get_unaligned((__be16 *)in)) >> (16 - bits);\n\telse if (bits <= 32)\n\t\t*d = be32_to_cpu(get_unaligned((__be32 *)in)) >> (32 - bits);\n\telse\n\t\t*d = be64_to_cpu(get_unaligned((__be64 *)in)) >> (64 - bits);\n\n\t*d &= GENMASK_ULL(n - 1, 0);\n\n\tp->bit += n;\n\n\tif (p->bit > 7) {\n\t\tp->in += p->bit / 8;\n\t\tp->ilen -= p->bit / 8;\n\t\tp->bit %= 8;\n\t}\n\n\treturn 0;\n}\n\nstatic int do_data(struct sw842_param *p, u8 n)\n{\n\tu64 v;\n\tint ret;\n\n\tif (n > p->olen)\n\t\treturn -ENOSPC;\n\n\tret = next_bits(p, &v, n * 8);\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (n) {\n\tcase 2:\n\t\tput_unaligned(cpu_to_be16((u16)v), (__be16 *)p->out);\n\t\tbreak;\n\tcase 4:\n\t\tput_unaligned(cpu_to_be32((u32)v), (__be32 *)p->out);\n\t\tbreak;\n\tcase 8:\n\t\tput_unaligned(cpu_to_be64((u64)v), (__be64 *)p->out);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tp->out += n;\n\tp->olen -= n;\n\n\treturn 0;\n}\n\nstatic int __do_index(struct sw842_param *p, u8 size, u8 bits, u64 fsize)\n{\n\tu64 index, offset, total = round_down(p->out - p->ostart, 8);\n\tint ret;\n\n\tret = next_bits(p, &index, bits);\n\tif (ret)\n\t\treturn ret;\n\n\toffset = index * size;\n\n\t \n\tif (total > fsize) {\n\t\t \n\t\tu64 section = round_down(total, fsize);\n\t\t \n\t\tu64 pos = total - section;\n\n\t\t \n\t\tif (offset >= pos)\n\t\t\tsection -= fsize;\n\n\t\toffset += section;\n\t}\n\n\tif (offset + size > total) {\n\t\tpr_debug(\"index%x %lx points past end %lx\\n\", size,\n\t\t\t (unsigned long)offset, (unsigned long)total);\n\t\treturn -EINVAL;\n\t}\n\n\tif (size != 2 && size != 4 && size != 8)\n\t\tWARN(1, \"__do_index invalid size %x\\n\", size);\n\telse\n\t\tpr_debug(\"index%x to %lx off %lx adjoff %lx tot %lx data %lx\\n\",\n\t\t\t size, (unsigned long)index,\n\t\t\t (unsigned long)(index * size), (unsigned long)offset,\n\t\t\t (unsigned long)total,\n\t\t\t (unsigned long)beN_to_cpu(&p->ostart[offset], size));\n\n\tmemcpy(p->out, &p->ostart[offset], size);\n\tp->out += size;\n\tp->olen -= size;\n\n\treturn 0;\n}\n\nstatic int do_index(struct sw842_param *p, u8 n)\n{\n\tswitch (n) {\n\tcase 2:\n\t\treturn __do_index(p, 2, I2_BITS, I2_FIFO_SIZE);\n\tcase 4:\n\t\treturn __do_index(p, 4, I4_BITS, I4_FIFO_SIZE);\n\tcase 8:\n\t\treturn __do_index(p, 8, I8_BITS, I8_FIFO_SIZE);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int do_op(struct sw842_param *p, u8 o)\n{\n\tint i, ret = 0;\n\n\tif (o >= OPS_MAX)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < 4; i++) {\n\t\tu8 op = decomp_ops[o][i];\n\n\t\tpr_debug(\"op is %x\\n\", op);\n\n\t\tswitch (op & OP_ACTION) {\n\t\tcase OP_ACTION_DATA:\n\t\t\tret = do_data(p, op & OP_AMOUNT);\n\t\t\tbreak;\n\t\tcase OP_ACTION_INDEX:\n\t\t\tret = do_index(p, op & OP_AMOUNT);\n\t\t\tbreak;\n\t\tcase OP_ACTION_NOOP:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_err(\"Internal error, invalid op %x\\n\", op);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (sw842_template_counts)\n\t\tatomic_inc(&template_count[o]);\n\n\treturn 0;\n}\n\n \nint sw842_decompress(const u8 *in, unsigned int ilen,\n\t\t     u8 *out, unsigned int *olen)\n{\n\tstruct sw842_param p;\n\tint ret;\n\tu64 op, rep, tmp, bytes, total;\n\tu64 crc;\n\n\tp.in = (u8 *)in;\n\tp.bit = 0;\n\tp.ilen = ilen;\n\tp.out = out;\n\tp.ostart = out;\n\tp.olen = *olen;\n\n\ttotal = p.olen;\n\n\t*olen = 0;\n\n\tdo {\n\t\tret = next_bits(&p, &op, OP_BITS);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tpr_debug(\"template is %lx\\n\", (unsigned long)op);\n\n\t\tswitch (op) {\n\t\tcase OP_REPEAT:\n\t\t\tret = next_bits(&p, &rep, REPEAT_BITS);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\tif (p.out == out)  \n\t\t\t\treturn -EINVAL;\n\n\t\t\t \n\t\t\trep++;\n\n\t\t\tif (rep * 8 > p.olen)\n\t\t\t\treturn -ENOSPC;\n\n\t\t\twhile (rep-- > 0) {\n\t\t\t\tmemcpy(p.out, p.out - 8, 8);\n\t\t\t\tp.out += 8;\n\t\t\t\tp.olen -= 8;\n\t\t\t}\n\n\t\t\tif (sw842_template_counts)\n\t\t\t\tatomic_inc(&template_repeat_count);\n\n\t\t\tbreak;\n\t\tcase OP_ZEROS:\n\t\t\tif (8 > p.olen)\n\t\t\t\treturn -ENOSPC;\n\n\t\t\tmemset(p.out, 0, 8);\n\t\t\tp.out += 8;\n\t\t\tp.olen -= 8;\n\n\t\t\tif (sw842_template_counts)\n\t\t\t\tatomic_inc(&template_zeros_count);\n\n\t\t\tbreak;\n\t\tcase OP_SHORT_DATA:\n\t\t\tret = next_bits(&p, &bytes, SHORT_DATA_BITS);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\tif (!bytes || bytes > SHORT_DATA_BITS_MAX)\n\t\t\t\treturn -EINVAL;\n\n\t\t\twhile (bytes-- > 0) {\n\t\t\t\tret = next_bits(&p, &tmp, 8);\n\t\t\t\tif (ret)\n\t\t\t\t\treturn ret;\n\t\t\t\t*p.out = (u8)tmp;\n\t\t\t\tp.out++;\n\t\t\t\tp.olen--;\n\t\t\t}\n\n\t\t\tif (sw842_template_counts)\n\t\t\t\tatomic_inc(&template_short_data_count);\n\n\t\t\tbreak;\n\t\tcase OP_END:\n\t\t\tif (sw842_template_counts)\n\t\t\t\tatomic_inc(&template_end_count);\n\n\t\t\tbreak;\n\t\tdefault:  \n\t\t\tret = do_op(&p, op);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tbreak;\n\t\t}\n\t} while (op != OP_END);\n\n\t \n\tret = next_bits(&p, &crc, CRC_BITS);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (crc != (u64)crc32_be(0, out, total - p.olen)) {\n\t\tpr_debug(\"CRC mismatch for decompression\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (unlikely((total - p.olen) > UINT_MAX))\n\t\treturn -ENOSPC;\n\n\t*olen = total - p.olen;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(sw842_decompress);\n\nstatic int __init sw842_init(void)\n{\n\tif (sw842_template_counts)\n\t\tsw842_debugfs_create();\n\n\treturn 0;\n}\nmodule_init(sw842_init);\n\nstatic void __exit sw842_exit(void)\n{\n\tif (sw842_template_counts)\n\t\tsw842_debugfs_remove();\n}\nmodule_exit(sw842_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"Software 842 Decompressor\");\nMODULE_AUTHOR(\"Dan Streetman <ddstreet@ieee.org>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}