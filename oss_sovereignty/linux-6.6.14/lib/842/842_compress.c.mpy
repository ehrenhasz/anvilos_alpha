{
  "module_name": "842_compress.c",
  "hash_id": "7ae19aa46b37a03d8c229457da7816af2ee142145b324cc2ecfca1535638e870",
  "original_prompt": "Ingested from linux-6.6.14/lib/842/842_compress.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n#define MODULE_NAME \"842_compress\"\n\n#include <linux/hashtable.h>\n\n#include \"842.h\"\n#include \"842_debugfs.h\"\n\n#define SW842_HASHTABLE8_BITS\t(10)\n#define SW842_HASHTABLE4_BITS\t(11)\n#define SW842_HASHTABLE2_BITS\t(10)\n\n \nstatic bool sw842_strict;\nmodule_param_named(strict, sw842_strict, bool, 0644);\n\nstatic u8 comp_ops[OPS_MAX][5] = {  \n\t{ I8, N0, N0, N0, 0x19 },  \n\t{ I4, I4, N0, N0, 0x18 },  \n\t{ I4, I2, I2, N0, 0x17 },  \n\t{ I2, I2, I4, N0, 0x13 },  \n\t{ I2, I2, I2, I2, 0x12 },  \n\t{ I4, I2, D2, N0, 0x16 },  \n\t{ I4, D2, I2, N0, 0x15 },  \n\t{ I2, D2, I4, N0, 0x0e },  \n\t{ D2, I2, I4, N0, 0x09 },  \n\t{ I2, I2, I2, D2, 0x11 },  \n\t{ I2, I2, D2, I2, 0x10 },  \n\t{ I2, D2, I2, I2, 0x0d },  \n\t{ D2, I2, I2, I2, 0x08 },  \n\t{ I4, D4, N0, N0, 0x14 },  \n\t{ D4, I4, N0, N0, 0x04 },  \n\t{ I2, I2, D4, N0, 0x0f },  \n\t{ I2, D2, I2, D2, 0x0c },  \n\t{ I2, D4, I2, N0, 0x0b },  \n\t{ D2, I2, I2, D2, 0x07 },  \n\t{ D2, I2, D2, I2, 0x06 },  \n\t{ D4, I2, I2, N0, 0x03 },  \n\t{ I2, D2, D4, N0, 0x0a },  \n\t{ D2, I2, D4, N0, 0x05 },  \n\t{ D4, I2, D2, N0, 0x02 },  \n\t{ D4, D2, I2, N0, 0x01 },  \n\t{ D8, N0, N0, N0, 0x00 },  \n};\n\nstruct sw842_hlist_node8 {\n\tstruct hlist_node node;\n\tu64 data;\n\tu8 index;\n};\n\nstruct sw842_hlist_node4 {\n\tstruct hlist_node node;\n\tu32 data;\n\tu16 index;\n};\n\nstruct sw842_hlist_node2 {\n\tstruct hlist_node node;\n\tu16 data;\n\tu8 index;\n};\n\n#define INDEX_NOT_FOUND\t\t(-1)\n#define INDEX_NOT_CHECKED\t(-2)\n\nstruct sw842_param {\n\tu8 *in;\n\tu8 *instart;\n\tu64 ilen;\n\tu8 *out;\n\tu64 olen;\n\tu8 bit;\n\tu64 data8[1];\n\tu32 data4[2];\n\tu16 data2[4];\n\tint index8[1];\n\tint index4[2];\n\tint index2[4];\n\tDECLARE_HASHTABLE(htable8, SW842_HASHTABLE8_BITS);\n\tDECLARE_HASHTABLE(htable4, SW842_HASHTABLE4_BITS);\n\tDECLARE_HASHTABLE(htable2, SW842_HASHTABLE2_BITS);\n\tstruct sw842_hlist_node8 node8[1 << I8_BITS];\n\tstruct sw842_hlist_node4 node4[1 << I4_BITS];\n\tstruct sw842_hlist_node2 node2[1 << I2_BITS];\n};\n\n#define get_input_data(p, o, b)\t\t\t\t\t\t\\\n\tbe##b##_to_cpu(get_unaligned((__be##b *)((p)->in + (o))))\n\n#define init_hashtable_nodes(p, b)\tdo {\t\t\t\\\n\tint _i;\t\t\t\t\t\t\t\\\n\thash_init((p)->htable##b);\t\t\t\t\\\n\tfor (_i = 0; _i < ARRAY_SIZE((p)->node##b); _i++) {\t\\\n\t\t(p)->node##b[_i].index = _i;\t\t\t\\\n\t\t(p)->node##b[_i].data = 0;\t\t\t\\\n\t\tINIT_HLIST_NODE(&(p)->node##b[_i].node);\t\\\n\t}\t\t\t\t\t\t\t\\\n} while (0)\n\n#define find_index(p, b, n)\t({\t\t\t\t\t\\\n\tstruct sw842_hlist_node##b *_n;\t\t\t\t\t\\\n\tp->index##b[n] = INDEX_NOT_FOUND;\t\t\t\t\\\n\thash_for_each_possible(p->htable##b, _n, node, p->data##b[n]) {\t\\\n\t\tif (p->data##b[n] == _n->data) {\t\t\t\\\n\t\t\tp->index##b[n] = _n->index;\t\t\t\\\n\t\t\tbreak;\t\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\tp->index##b[n] >= 0;\t\t\t\t\t\t\\\n})\n\n#define check_index(p, b, n)\t\t\t\\\n\t((p)->index##b[n] == INDEX_NOT_CHECKED\t\\\n\t ? find_index(p, b, n)\t\t\t\\\n\t : (p)->index##b[n] >= 0)\n\n#define replace_hash(p, b, i, d)\tdo {\t\t\t\t\\\n\tstruct sw842_hlist_node##b *_n = &(p)->node##b[(i)+(d)];\t\\\n\thash_del(&_n->node);\t\t\t\t\t\t\\\n\t_n->data = (p)->data##b[d];\t\t\t\t\t\\\n\tpr_debug(\"add hash index%x %x pos %x data %lx\\n\", b,\t\t\\\n\t\t (unsigned int)_n->index,\t\t\t\t\\\n\t\t (unsigned int)((p)->in - (p)->instart),\t\t\\\n\t\t (unsigned long)_n->data);\t\t\t\t\\\n\thash_add((p)->htable##b, &_n->node, _n->data);\t\t\t\\\n} while (0)\n\nstatic u8 bmask[8] = { 0x00, 0x80, 0xc0, 0xe0, 0xf0, 0xf8, 0xfc, 0xfe };\n\nstatic int add_bits(struct sw842_param *p, u64 d, u8 n);\n\nstatic int __split_add_bits(struct sw842_param *p, u64 d, u8 n, u8 s)\n{\n\tint ret;\n\n\tif (n <= s)\n\t\treturn -EINVAL;\n\n\tret = add_bits(p, d >> s, n - s);\n\tif (ret)\n\t\treturn ret;\n\treturn add_bits(p, d & GENMASK_ULL(s - 1, 0), s);\n}\n\nstatic int add_bits(struct sw842_param *p, u64 d, u8 n)\n{\n\tint b = p->bit, bits = b + n, s = round_up(bits, 8) - bits;\n\tu64 o;\n\tu8 *out = p->out;\n\n\tpr_debug(\"add %u bits %lx\\n\", (unsigned char)n, (unsigned long)d);\n\n\tif (n > 64)\n\t\treturn -EINVAL;\n\n\t \n\tif (bits > 64)\n\t\treturn __split_add_bits(p, d, n, 32);\n\telse if (p->olen < 8 && bits > 32 && bits <= 56)\n\t\treturn __split_add_bits(p, d, n, 16);\n\telse if (p->olen < 4 && bits > 16 && bits <= 24)\n\t\treturn __split_add_bits(p, d, n, 8);\n\n\tif (DIV_ROUND_UP(bits, 8) > p->olen)\n\t\treturn -ENOSPC;\n\n\to = *out & bmask[b];\n\td <<= s;\n\n\tif (bits <= 8)\n\t\t*out = o | d;\n\telse if (bits <= 16)\n\t\tput_unaligned(cpu_to_be16(o << 8 | d), (__be16 *)out);\n\telse if (bits <= 24)\n\t\tput_unaligned(cpu_to_be32(o << 24 | d << 8), (__be32 *)out);\n\telse if (bits <= 32)\n\t\tput_unaligned(cpu_to_be32(o << 24 | d), (__be32 *)out);\n\telse if (bits <= 40)\n\t\tput_unaligned(cpu_to_be64(o << 56 | d << 24), (__be64 *)out);\n\telse if (bits <= 48)\n\t\tput_unaligned(cpu_to_be64(o << 56 | d << 16), (__be64 *)out);\n\telse if (bits <= 56)\n\t\tput_unaligned(cpu_to_be64(o << 56 | d << 8), (__be64 *)out);\n\telse\n\t\tput_unaligned(cpu_to_be64(o << 56 | d), (__be64 *)out);\n\n\tp->bit += n;\n\n\tif (p->bit > 7) {\n\t\tp->out += p->bit / 8;\n\t\tp->olen -= p->bit / 8;\n\t\tp->bit %= 8;\n\t}\n\n\treturn 0;\n}\n\nstatic int add_template(struct sw842_param *p, u8 c)\n{\n\tint ret, i, b = 0;\n\tu8 *t = comp_ops[c];\n\tbool inv = false;\n\n\tif (c >= OPS_MAX)\n\t\treturn -EINVAL;\n\n\tpr_debug(\"template %x\\n\", t[4]);\n\n\tret = add_bits(p, t[4], OP_BITS);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < 4; i++) {\n\t\tpr_debug(\"op %x\\n\", t[i]);\n\n\t\tswitch (t[i] & OP_AMOUNT) {\n\t\tcase OP_AMOUNT_8:\n\t\t\tif (b)\n\t\t\t\tinv = true;\n\t\t\telse if (t[i] & OP_ACTION_INDEX)\n\t\t\t\tret = add_bits(p, p->index8[0], I8_BITS);\n\t\t\telse if (t[i] & OP_ACTION_DATA)\n\t\t\t\tret = add_bits(p, p->data8[0], 64);\n\t\t\telse\n\t\t\t\tinv = true;\n\t\t\tbreak;\n\t\tcase OP_AMOUNT_4:\n\t\t\tif (b == 2 && t[i] & OP_ACTION_DATA)\n\t\t\t\tret = add_bits(p, get_input_data(p, 2, 32), 32);\n\t\t\telse if (b != 0 && b != 4)\n\t\t\t\tinv = true;\n\t\t\telse if (t[i] & OP_ACTION_INDEX)\n\t\t\t\tret = add_bits(p, p->index4[b >> 2], I4_BITS);\n\t\t\telse if (t[i] & OP_ACTION_DATA)\n\t\t\t\tret = add_bits(p, p->data4[b >> 2], 32);\n\t\t\telse\n\t\t\t\tinv = true;\n\t\t\tbreak;\n\t\tcase OP_AMOUNT_2:\n\t\t\tif (b != 0 && b != 2 && b != 4 && b != 6)\n\t\t\t\tinv = true;\n\t\t\tif (t[i] & OP_ACTION_INDEX)\n\t\t\t\tret = add_bits(p, p->index2[b >> 1], I2_BITS);\n\t\t\telse if (t[i] & OP_ACTION_DATA)\n\t\t\t\tret = add_bits(p, p->data2[b >> 1], 16);\n\t\t\telse\n\t\t\t\tinv = true;\n\t\t\tbreak;\n\t\tcase OP_AMOUNT_0:\n\t\t\tinv = (b != 8) || !(t[i] & OP_ACTION_NOOP);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tinv = true;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (inv) {\n\t\t\tpr_err(\"Invalid templ %x op %d : %x %x %x %x\\n\",\n\t\t\t       c, i, t[0], t[1], t[2], t[3]);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tb += t[i] & OP_AMOUNT;\n\t}\n\n\tif (b != 8) {\n\t\tpr_err(\"Invalid template %x len %x : %x %x %x %x\\n\",\n\t\t       c, b, t[0], t[1], t[2], t[3]);\n\t\treturn -EINVAL;\n\t}\n\n\tif (sw842_template_counts)\n\t\tatomic_inc(&template_count[t[4]]);\n\n\treturn 0;\n}\n\nstatic int add_repeat_template(struct sw842_param *p, u8 r)\n{\n\tint ret;\n\n\t \n\tif (!r || --r > REPEAT_BITS_MAX)\n\t\treturn -EINVAL;\n\n\tret = add_bits(p, OP_REPEAT, OP_BITS);\n\tif (ret)\n\t\treturn ret;\n\n\tret = add_bits(p, r, REPEAT_BITS);\n\tif (ret)\n\t\treturn ret;\n\n\tif (sw842_template_counts)\n\t\tatomic_inc(&template_repeat_count);\n\n\treturn 0;\n}\n\nstatic int add_short_data_template(struct sw842_param *p, u8 b)\n{\n\tint ret, i;\n\n\tif (!b || b > SHORT_DATA_BITS_MAX)\n\t\treturn -EINVAL;\n\n\tret = add_bits(p, OP_SHORT_DATA, OP_BITS);\n\tif (ret)\n\t\treturn ret;\n\n\tret = add_bits(p, b, SHORT_DATA_BITS);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < b; i++) {\n\t\tret = add_bits(p, p->in[i], 8);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (sw842_template_counts)\n\t\tatomic_inc(&template_short_data_count);\n\n\treturn 0;\n}\n\nstatic int add_zeros_template(struct sw842_param *p)\n{\n\tint ret = add_bits(p, OP_ZEROS, OP_BITS);\n\n\tif (ret)\n\t\treturn ret;\n\n\tif (sw842_template_counts)\n\t\tatomic_inc(&template_zeros_count);\n\n\treturn 0;\n}\n\nstatic int add_end_template(struct sw842_param *p)\n{\n\tint ret = add_bits(p, OP_END, OP_BITS);\n\n\tif (ret)\n\t\treturn ret;\n\n\tif (sw842_template_counts)\n\t\tatomic_inc(&template_end_count);\n\n\treturn 0;\n}\n\nstatic bool check_template(struct sw842_param *p, u8 c)\n{\n\tu8 *t = comp_ops[c];\n\tint i, match, b = 0;\n\n\tif (c >= OPS_MAX)\n\t\treturn false;\n\n\tfor (i = 0; i < 4; i++) {\n\t\tif (t[i] & OP_ACTION_INDEX) {\n\t\t\tif (t[i] & OP_AMOUNT_2)\n\t\t\t\tmatch = check_index(p, 2, b >> 1);\n\t\t\telse if (t[i] & OP_AMOUNT_4)\n\t\t\t\tmatch = check_index(p, 4, b >> 2);\n\t\t\telse if (t[i] & OP_AMOUNT_8)\n\t\t\t\tmatch = check_index(p, 8, 0);\n\t\t\telse\n\t\t\t\treturn false;\n\t\t\tif (!match)\n\t\t\t\treturn false;\n\t\t}\n\n\t\tb += t[i] & OP_AMOUNT;\n\t}\n\n\treturn true;\n}\n\nstatic void get_next_data(struct sw842_param *p)\n{\n\tp->data8[0] = get_input_data(p, 0, 64);\n\tp->data4[0] = get_input_data(p, 0, 32);\n\tp->data4[1] = get_input_data(p, 4, 32);\n\tp->data2[0] = get_input_data(p, 0, 16);\n\tp->data2[1] = get_input_data(p, 2, 16);\n\tp->data2[2] = get_input_data(p, 4, 16);\n\tp->data2[3] = get_input_data(p, 6, 16);\n}\n\n \nstatic void update_hashtables(struct sw842_param *p)\n{\n\tu64 pos = p->in - p->instart;\n\tu64 n8 = (pos >> 3) % (1 << I8_BITS);\n\tu64 n4 = (pos >> 2) % (1 << I4_BITS);\n\tu64 n2 = (pos >> 1) % (1 << I2_BITS);\n\n\treplace_hash(p, 8, n8, 0);\n\treplace_hash(p, 4, n4, 0);\n\treplace_hash(p, 4, n4, 1);\n\treplace_hash(p, 2, n2, 0);\n\treplace_hash(p, 2, n2, 1);\n\treplace_hash(p, 2, n2, 2);\n\treplace_hash(p, 2, n2, 3);\n}\n\n \nstatic int process_next(struct sw842_param *p)\n{\n\tint ret, i;\n\n\tp->index8[0] = INDEX_NOT_CHECKED;\n\tp->index4[0] = INDEX_NOT_CHECKED;\n\tp->index4[1] = INDEX_NOT_CHECKED;\n\tp->index2[0] = INDEX_NOT_CHECKED;\n\tp->index2[1] = INDEX_NOT_CHECKED;\n\tp->index2[2] = INDEX_NOT_CHECKED;\n\tp->index2[3] = INDEX_NOT_CHECKED;\n\n\t \n\tfor (i = 0; i < OPS_MAX - 1; i++) {\n\t\tif (check_template(p, i))\n\t\t\tbreak;\n\t}\n\n\tret = add_template(p, i);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\n \nint sw842_compress(const u8 *in, unsigned int ilen,\n\t\t   u8 *out, unsigned int *olen, void *wmem)\n{\n\tstruct sw842_param *p = (struct sw842_param *)wmem;\n\tint ret;\n\tu64 last, next, pad, total;\n\tu8 repeat_count = 0;\n\tu32 crc;\n\n\tBUILD_BUG_ON(sizeof(*p) > SW842_MEM_COMPRESS);\n\n\tinit_hashtable_nodes(p, 8);\n\tinit_hashtable_nodes(p, 4);\n\tinit_hashtable_nodes(p, 2);\n\n\tp->in = (u8 *)in;\n\tp->instart = p->in;\n\tp->ilen = ilen;\n\tp->out = out;\n\tp->olen = *olen;\n\tp->bit = 0;\n\n\ttotal = p->olen;\n\n\t*olen = 0;\n\n\t \n\tif (sw842_strict && (ilen % 8)) {\n\t\tpr_err(\"Using strict mode, can't compress len %d\\n\", ilen);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (unlikely(ilen < 8))\n\t\tgoto skip_comp;\n\n\t \n\tlast = ~get_unaligned((u64 *)p->in);\n\n\twhile (p->ilen > 7) {\n\t\tnext = get_unaligned((u64 *)p->in);\n\n\t\t \n\t\tget_next_data(p);\n\n\t\t \n\t\tif (next == last) {\n\t\t\t \n\t\t\tif (++repeat_count <= REPEAT_BITS_MAX)\n\t\t\t\tgoto repeat;\n\t\t}\n\t\tif (repeat_count) {\n\t\t\tret = add_repeat_template(p, repeat_count);\n\t\t\trepeat_count = 0;\n\t\t\tif (next == last)  \n\t\t\t\tgoto repeat;\n\t\t}\n\n\t\tif (next == 0)\n\t\t\tret = add_zeros_template(p);\n\t\telse\n\t\t\tret = process_next(p);\n\n\t\tif (ret)\n\t\t\treturn ret;\n\nrepeat:\n\t\tlast = next;\n\t\tupdate_hashtables(p);\n\t\tp->in += 8;\n\t\tp->ilen -= 8;\n\t}\n\n\tif (repeat_count) {\n\t\tret = add_repeat_template(p, repeat_count);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\nskip_comp:\n\tif (p->ilen > 0) {\n\t\tret = add_short_data_template(p, p->ilen);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tp->in += p->ilen;\n\t\tp->ilen = 0;\n\t}\n\n\tret = add_end_template(p);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tcrc = crc32_be(0, in, ilen);\n\tret = add_bits(p, crc, CRC_BITS);\n\tif (ret)\n\t\treturn ret;\n\n\tif (p->bit) {\n\t\tp->out++;\n\t\tp->olen--;\n\t\tp->bit = 0;\n\t}\n\n\t \n\tpad = (8 - ((total - p->olen) % 8)) % 8;\n\tif (pad) {\n\t\tif (pad > p->olen)  \n\t\t\treturn -ENOSPC;\n\t\tmemset(p->out, 0, pad);\n\t\tp->out += pad;\n\t\tp->olen -= pad;\n\t}\n\n\tif (unlikely((total - p->olen) > UINT_MAX))\n\t\treturn -ENOSPC;\n\n\t*olen = total - p->olen;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(sw842_compress);\n\nstatic int __init sw842_init(void)\n{\n\tif (sw842_template_counts)\n\t\tsw842_debugfs_create();\n\n\treturn 0;\n}\nmodule_init(sw842_init);\n\nstatic void __exit sw842_exit(void)\n{\n\tif (sw842_template_counts)\n\t\tsw842_debugfs_remove();\n}\nmodule_exit(sw842_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"Software 842 Compressor\");\nMODULE_AUTHOR(\"Dan Streetman <ddstreet@ieee.org>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}