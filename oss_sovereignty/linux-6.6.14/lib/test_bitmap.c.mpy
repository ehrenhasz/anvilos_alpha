{
  "module_name": "test_bitmap.c",
  "hash_id": "a56be14dc113253a2c45233723e8060f6122efb9ad33abf705f9f59c0c4a6fc2",
  "original_prompt": "Ingested from linux-6.6.14/lib/test_bitmap.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/bitmap.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/printk.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n\n#include \"../tools/testing/selftests/kselftest_module.h\"\n\n#define EXP1_IN_BITS\t(sizeof(exp1) * 8)\n\nKSTM_MODULE_GLOBALS();\n\nstatic char pbl_buffer[PAGE_SIZE] __initdata;\nstatic char print_buf[PAGE_SIZE * 2] __initdata;\n\nstatic const unsigned long exp1[] __initconst = {\n\tBITMAP_FROM_U64(1),\n\tBITMAP_FROM_U64(2),\n\tBITMAP_FROM_U64(0x0000ffff),\n\tBITMAP_FROM_U64(0xffff0000),\n\tBITMAP_FROM_U64(0x55555555),\n\tBITMAP_FROM_U64(0xaaaaaaaa),\n\tBITMAP_FROM_U64(0x11111111),\n\tBITMAP_FROM_U64(0x22222222),\n\tBITMAP_FROM_U64(0xffffffff),\n\tBITMAP_FROM_U64(0xfffffffe),\n\tBITMAP_FROM_U64(0x3333333311111111ULL),\n\tBITMAP_FROM_U64(0xffffffff77777777ULL),\n\tBITMAP_FROM_U64(0),\n\tBITMAP_FROM_U64(0x00008000),\n\tBITMAP_FROM_U64(0x80000000),\n};\n\nstatic const unsigned long exp2[] __initconst = {\n\tBITMAP_FROM_U64(0x3333333311111111ULL),\n\tBITMAP_FROM_U64(0xffffffff77777777ULL),\n};\n\n \nstatic const unsigned long exp2_to_exp3_mask[] __initconst = {\n\tBITMAP_FROM_U64(0x008000020020212eULL),\n};\n \nstatic const unsigned long exp3_0_1[] __initconst = {\n\tBITMAP_FROM_U64(0x33b3333311313137ULL),\n};\n \nstatic const unsigned long exp3_1_0[] __initconst = {\n\tBITMAP_FROM_U64(0xff7fffff77575751ULL),\n};\n\nstatic bool __init\n__check_eq_uint(const char *srcfile, unsigned int line,\n\t\tconst unsigned int exp_uint, unsigned int x)\n{\n\tif (exp_uint != x) {\n\t\tpr_err(\"[%s:%u] expected %u, got %u\\n\",\n\t\t\tsrcfile, line, exp_uint, x);\n\t\treturn false;\n\t}\n\treturn true;\n}\n\n\nstatic bool __init\n__check_eq_bitmap(const char *srcfile, unsigned int line,\n\t\t  const unsigned long *exp_bmap, const unsigned long *bmap,\n\t\t  unsigned int nbits)\n{\n\tif (!bitmap_equal(exp_bmap, bmap, nbits)) {\n\t\tpr_warn(\"[%s:%u] bitmaps contents differ: expected \\\"%*pbl\\\", got \\\"%*pbl\\\"\\n\",\n\t\t\tsrcfile, line,\n\t\t\tnbits, exp_bmap, nbits, bmap);\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nstatic bool __init\n__check_eq_pbl(const char *srcfile, unsigned int line,\n\t       const char *expected_pbl,\n\t       const unsigned long *bitmap, unsigned int nbits)\n{\n\tsnprintf(pbl_buffer, sizeof(pbl_buffer), \"%*pbl\", nbits, bitmap);\n\tif (strcmp(expected_pbl, pbl_buffer)) {\n\t\tpr_warn(\"[%s:%u] expected \\\"%s\\\", got \\\"%s\\\"\\n\",\n\t\t\tsrcfile, line,\n\t\t\texpected_pbl, pbl_buffer);\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nstatic bool __init\n__check_eq_u32_array(const char *srcfile, unsigned int line,\n\t\t     const u32 *exp_arr, unsigned int exp_len,\n\t\t     const u32 *arr, unsigned int len) __used;\nstatic bool __init\n__check_eq_u32_array(const char *srcfile, unsigned int line,\n\t\t     const u32 *exp_arr, unsigned int exp_len,\n\t\t     const u32 *arr, unsigned int len)\n{\n\tif (exp_len != len) {\n\t\tpr_warn(\"[%s:%u] array length differ: expected %u, got %u\\n\",\n\t\t\tsrcfile, line,\n\t\t\texp_len, len);\n\t\treturn false;\n\t}\n\n\tif (memcmp(exp_arr, arr, len*sizeof(*arr))) {\n\t\tpr_warn(\"[%s:%u] array contents differ\\n\", srcfile, line);\n\t\tprint_hex_dump(KERN_WARNING, \"  exp:  \", DUMP_PREFIX_OFFSET,\n\t\t\t       32, 4, exp_arr, exp_len*sizeof(*exp_arr), false);\n\t\tprint_hex_dump(KERN_WARNING, \"  got:  \", DUMP_PREFIX_OFFSET,\n\t\t\t       32, 4, arr, len*sizeof(*arr), false);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic bool __init __check_eq_clump8(const char *srcfile, unsigned int line,\n\t\t\t\t    const unsigned int offset,\n\t\t\t\t    const unsigned int size,\n\t\t\t\t    const unsigned char *const clump_exp,\n\t\t\t\t    const unsigned long *const clump)\n{\n\tunsigned long exp;\n\n\tif (offset >= size) {\n\t\tpr_warn(\"[%s:%u] bit offset for clump out-of-bounds: expected less than %u, got %u\\n\",\n\t\t\tsrcfile, line, size, offset);\n\t\treturn false;\n\t}\n\n\texp = clump_exp[offset / 8];\n\tif (!exp) {\n\t\tpr_warn(\"[%s:%u] bit offset for zero clump: expected nonzero clump, got bit offset %u with clump value 0\",\n\t\t\tsrcfile, line, offset);\n\t\treturn false;\n\t}\n\n\tif (*clump != exp) {\n\t\tpr_warn(\"[%s:%u] expected clump value of 0x%lX, got clump value of 0x%lX\",\n\t\t\tsrcfile, line, exp, *clump);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic bool __init\n__check_eq_str(const char *srcfile, unsigned int line,\n\t\tconst char *exp_str, const char *str,\n\t\tunsigned int len)\n{\n\tbool eq;\n\n\teq = strncmp(exp_str, str, len) == 0;\n\tif (!eq)\n\t\tpr_err(\"[%s:%u] expected %s, got %s\\n\", srcfile, line, exp_str, str);\n\n\treturn eq;\n}\n\n#define __expect_eq(suffix, ...)\t\t\t\t\t\\\n\t({\t\t\t\t\t\t\t\t\\\n\t\tint result = 0;\t\t\t\t\t\t\\\n\t\ttotal_tests++;\t\t\t\t\t\t\\\n\t\tif (!__check_eq_ ## suffix(__FILE__, __LINE__,\t\t\\\n\t\t\t\t\t   ##__VA_ARGS__)) {\t\t\\\n\t\t\tfailed_tests++;\t\t\t\t\t\\\n\t\t\tresult = 1;\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t\tresult;\t\t\t\t\t\t\t\\\n\t})\n\n#define expect_eq_uint(...)\t\t__expect_eq(uint, ##__VA_ARGS__)\n#define expect_eq_bitmap(...)\t\t__expect_eq(bitmap, ##__VA_ARGS__)\n#define expect_eq_pbl(...)\t\t__expect_eq(pbl, ##__VA_ARGS__)\n#define expect_eq_u32_array(...)\t__expect_eq(u32_array, ##__VA_ARGS__)\n#define expect_eq_clump8(...)\t\t__expect_eq(clump8, ##__VA_ARGS__)\n#define expect_eq_str(...)\t\t__expect_eq(str, ##__VA_ARGS__)\n\nstatic void __init test_zero_clear(void)\n{\n\tDECLARE_BITMAP(bmap, 1024);\n\n\t \n\tmemset(bmap, 0xff, 128);\n\n\texpect_eq_pbl(\"0-22\", bmap, 23);\n\texpect_eq_pbl(\"0-1023\", bmap, 1024);\n\n\t \n\tbitmap_clear(bmap, 0, 9);\n\texpect_eq_pbl(\"9-1023\", bmap, 1024);\n\n\tbitmap_zero(bmap, 35);\n\texpect_eq_pbl(\"64-1023\", bmap, 1024);\n\n\t \n\tbitmap_clear(bmap, 79, 19);\n\texpect_eq_pbl(\"64-78,98-1023\", bmap, 1024);\n\n\tbitmap_zero(bmap, 115);\n\texpect_eq_pbl(\"128-1023\", bmap, 1024);\n\n\t \n\tbitmap_zero(bmap, 1024);\n\texpect_eq_pbl(\"\", bmap, 1024);\n}\n\nstatic void __init test_find_nth_bit(void)\n{\n\tunsigned long b, bit, cnt = 0;\n\tDECLARE_BITMAP(bmap, 64 * 3);\n\n\tbitmap_zero(bmap, 64 * 3);\n\t__set_bit(10, bmap);\n\t__set_bit(20, bmap);\n\t__set_bit(30, bmap);\n\t__set_bit(40, bmap);\n\t__set_bit(50, bmap);\n\t__set_bit(60, bmap);\n\t__set_bit(80, bmap);\n\t__set_bit(123, bmap);\n\n\texpect_eq_uint(10,  find_nth_bit(bmap, 64 * 3, 0));\n\texpect_eq_uint(20,  find_nth_bit(bmap, 64 * 3, 1));\n\texpect_eq_uint(30,  find_nth_bit(bmap, 64 * 3, 2));\n\texpect_eq_uint(40,  find_nth_bit(bmap, 64 * 3, 3));\n\texpect_eq_uint(50,  find_nth_bit(bmap, 64 * 3, 4));\n\texpect_eq_uint(60,  find_nth_bit(bmap, 64 * 3, 5));\n\texpect_eq_uint(80,  find_nth_bit(bmap, 64 * 3, 6));\n\texpect_eq_uint(123, find_nth_bit(bmap, 64 * 3, 7));\n\texpect_eq_uint(64 * 3, find_nth_bit(bmap, 64 * 3, 8));\n\n\texpect_eq_uint(10,  find_nth_bit(bmap, 64 * 3 - 1, 0));\n\texpect_eq_uint(20,  find_nth_bit(bmap, 64 * 3 - 1, 1));\n\texpect_eq_uint(30,  find_nth_bit(bmap, 64 * 3 - 1, 2));\n\texpect_eq_uint(40,  find_nth_bit(bmap, 64 * 3 - 1, 3));\n\texpect_eq_uint(50,  find_nth_bit(bmap, 64 * 3 - 1, 4));\n\texpect_eq_uint(60,  find_nth_bit(bmap, 64 * 3 - 1, 5));\n\texpect_eq_uint(80,  find_nth_bit(bmap, 64 * 3 - 1, 6));\n\texpect_eq_uint(123, find_nth_bit(bmap, 64 * 3 - 1, 7));\n\texpect_eq_uint(64 * 3 - 1, find_nth_bit(bmap, 64 * 3 - 1, 8));\n\n\tfor_each_set_bit(bit, exp1, EXP1_IN_BITS) {\n\t\tb = find_nth_bit(exp1, EXP1_IN_BITS, cnt++);\n\t\texpect_eq_uint(b, bit);\n\t}\n}\n\nstatic void __init test_fill_set(void)\n{\n\tDECLARE_BITMAP(bmap, 1024);\n\n\t \n\tmemset(bmap, 0x00, 128);\n\n\texpect_eq_pbl(\"\", bmap, 23);\n\texpect_eq_pbl(\"\", bmap, 1024);\n\n\t \n\tbitmap_set(bmap, 0, 9);\n\texpect_eq_pbl(\"0-8\", bmap, 1024);\n\n\tbitmap_fill(bmap, 35);\n\texpect_eq_pbl(\"0-63\", bmap, 1024);\n\n\t \n\tbitmap_set(bmap, 79, 19);\n\texpect_eq_pbl(\"0-63,79-97\", bmap, 1024);\n\n\tbitmap_fill(bmap, 115);\n\texpect_eq_pbl(\"0-127\", bmap, 1024);\n\n\t \n\tbitmap_fill(bmap, 1024);\n\texpect_eq_pbl(\"0-1023\", bmap, 1024);\n}\n\nstatic void __init test_copy(void)\n{\n\tDECLARE_BITMAP(bmap1, 1024);\n\tDECLARE_BITMAP(bmap2, 1024);\n\n\tbitmap_zero(bmap1, 1024);\n\tbitmap_zero(bmap2, 1024);\n\n\t \n\tbitmap_set(bmap1, 0, 19);\n\tbitmap_copy(bmap2, bmap1, 23);\n\texpect_eq_pbl(\"0-18\", bmap2, 1024);\n\n\tbitmap_set(bmap2, 0, 23);\n\tbitmap_copy(bmap2, bmap1, 23);\n\texpect_eq_pbl(\"0-18\", bmap2, 1024);\n\n\t \n\tbitmap_set(bmap1, 0, 109);\n\tbitmap_copy(bmap2, bmap1, 1024);\n\texpect_eq_pbl(\"0-108\", bmap2, 1024);\n\n\tbitmap_fill(bmap2, 1024);\n\tbitmap_copy(bmap2, bmap1, 1024);\n\texpect_eq_pbl(\"0-108\", bmap2, 1024);\n\n\t \n\n\tbitmap_fill(bmap2, 1024);\n\tbitmap_copy(bmap2, bmap1, 109);   \n\texpect_eq_pbl(\"0-108,128-1023\", bmap2, 1024);\n\n\tbitmap_fill(bmap2, 1024);\n\tbitmap_copy(bmap2, bmap1, 97);   \n\texpect_eq_pbl(\"0-108,128-1023\", bmap2, 1024);\n}\n\n#define EXP2_IN_BITS\t(sizeof(exp2) * 8)\n\nstatic void __init test_replace(void)\n{\n\tunsigned int nbits = 64;\n\tunsigned int nlongs = DIV_ROUND_UP(nbits, BITS_PER_LONG);\n\tDECLARE_BITMAP(bmap, 1024);\n\n\tBUILD_BUG_ON(EXP2_IN_BITS < nbits * 2);\n\n\tbitmap_zero(bmap, 1024);\n\tbitmap_replace(bmap, &exp2[0 * nlongs], &exp2[1 * nlongs], exp2_to_exp3_mask, nbits);\n\texpect_eq_bitmap(bmap, exp3_0_1, nbits);\n\n\tbitmap_zero(bmap, 1024);\n\tbitmap_replace(bmap, &exp2[1 * nlongs], &exp2[0 * nlongs], exp2_to_exp3_mask, nbits);\n\texpect_eq_bitmap(bmap, exp3_1_0, nbits);\n\n\tbitmap_fill(bmap, 1024);\n\tbitmap_replace(bmap, &exp2[0 * nlongs], &exp2[1 * nlongs], exp2_to_exp3_mask, nbits);\n\texpect_eq_bitmap(bmap, exp3_0_1, nbits);\n\n\tbitmap_fill(bmap, 1024);\n\tbitmap_replace(bmap, &exp2[1 * nlongs], &exp2[0 * nlongs], exp2_to_exp3_mask, nbits);\n\texpect_eq_bitmap(bmap, exp3_1_0, nbits);\n}\n\n#define PARSE_TIME\t0x1\n#define NO_LEN\t\t0x2\n\nstruct test_bitmap_parselist{\n\tconst int errno;\n\tconst char *in;\n\tconst unsigned long *expected;\n\tconst int nbits;\n\tconst int flags;\n};\n\nstatic const struct test_bitmap_parselist parselist_tests[] __initconst = {\n#define step (sizeof(u64) / sizeof(unsigned long))\n\n\t{0, \"0\",\t\t\t&exp1[0], 8, 0},\n\t{0, \"1\",\t\t\t&exp1[1 * step], 8, 0},\n\t{0, \"0-15\",\t\t\t&exp1[2 * step], 32, 0},\n\t{0, \"16-31\",\t\t\t&exp1[3 * step], 32, 0},\n\t{0, \"0-31:1/2\",\t\t\t&exp1[4 * step], 32, 0},\n\t{0, \"1-31:1/2\",\t\t\t&exp1[5 * step], 32, 0},\n\t{0, \"0-31:1/4\",\t\t\t&exp1[6 * step], 32, 0},\n\t{0, \"1-31:1/4\",\t\t\t&exp1[7 * step], 32, 0},\n\t{0, \"0-31:4/4\",\t\t\t&exp1[8 * step], 32, 0},\n\t{0, \"1-31:4/4\",\t\t\t&exp1[9 * step], 32, 0},\n\t{0, \"0-31:1/4,32-63:2/4\",\t&exp1[10 * step], 64, 0},\n\t{0, \"0-31:3/4,32-63:4/4\",\t&exp1[11 * step], 64, 0},\n\t{0, \"  ,,  0-31:3/4  ,, 32-63:4/4  ,,  \",\t&exp1[11 * step], 64, 0},\n\n\t{0, \"0-31:1/4,32-63:2/4,64-95:3/4,96-127:4/4\",\texp2, 128, 0},\n\n\t{0, \"0-2047:128/256\", NULL, 2048, PARSE_TIME},\n\n\t{0, \"\",\t\t\t\t&exp1[12 * step], 8, 0},\n\t{0, \"\\n\",\t\t\t&exp1[12 * step], 8, 0},\n\t{0, \",,  ,,  , ,  ,\",\t\t&exp1[12 * step], 8, 0},\n\t{0, \" ,  ,,  , ,   \",\t\t&exp1[12 * step], 8, 0},\n\t{0, \" ,  ,,  , ,   \\n\",\t\t&exp1[12 * step], 8, 0},\n\n\t{0, \"0-0\",\t\t\t&exp1[0], 32, 0},\n\t{0, \"1-1\",\t\t\t&exp1[1 * step], 32, 0},\n\t{0, \"15-15\",\t\t\t&exp1[13 * step], 32, 0},\n\t{0, \"31-31\",\t\t\t&exp1[14 * step], 32, 0},\n\n\t{0, \"0-0:0/1\",\t\t\t&exp1[12 * step], 32, 0},\n\t{0, \"0-0:1/1\",\t\t\t&exp1[0], 32, 0},\n\t{0, \"0-0:1/31\",\t\t\t&exp1[0], 32, 0},\n\t{0, \"0-0:31/31\",\t\t&exp1[0], 32, 0},\n\t{0, \"1-1:1/1\",\t\t\t&exp1[1 * step], 32, 0},\n\t{0, \"0-15:16/31\",\t\t&exp1[2 * step], 32, 0},\n\t{0, \"15-15:1/2\",\t\t&exp1[13 * step], 32, 0},\n\t{0, \"15-15:31/31\",\t\t&exp1[13 * step], 32, 0},\n\t{0, \"15-31:1/31\",\t\t&exp1[13 * step], 32, 0},\n\t{0, \"16-31:16/31\",\t\t&exp1[3 * step], 32, 0},\n\t{0, \"31-31:31/31\",\t\t&exp1[14 * step], 32, 0},\n\n\t{0, \"N-N\",\t\t\t&exp1[14 * step], 32, 0},\n\t{0, \"0-0:1/N\",\t\t\t&exp1[0], 32, 0},\n\t{0, \"0-0:N/N\",\t\t\t&exp1[0], 32, 0},\n\t{0, \"0-15:16/N\",\t\t&exp1[2 * step], 32, 0},\n\t{0, \"15-15:N/N\",\t\t&exp1[13 * step], 32, 0},\n\t{0, \"15-N:1/N\",\t\t\t&exp1[13 * step], 32, 0},\n\t{0, \"16-N:16/N\",\t\t&exp1[3 * step], 32, 0},\n\t{0, \"N-N:N/N\",\t\t\t&exp1[14 * step], 32, 0},\n\n\t{0, \"0-N:1/3,1-N:1/3,2-N:1/3\",\t\t&exp1[8 * step], 32, 0},\n\t{0, \"0-31:1/3,1-31:1/3,2-31:1/3\",\t&exp1[8 * step], 32, 0},\n\t{0, \"1-10:8/12,8-31:24/29,0-31:0/3\",\t&exp1[9 * step], 32, 0},\n\n\t{0,\t  \"all\",\t\t&exp1[8 * step], 32, 0},\n\t{0,\t  \"0, 1, all,  \",\t&exp1[8 * step], 32, 0},\n\t{0,\t  \"all:1/2\",\t\t&exp1[4 * step], 32, 0},\n\t{0,\t  \"ALL:1/2\",\t\t&exp1[4 * step], 32, 0},\n\t{-EINVAL, \"al\", NULL, 8, 0},\n\t{-EINVAL, \"alll\", NULL, 8, 0},\n\n\t{-EINVAL, \"-1\",\tNULL, 8, 0},\n\t{-EINVAL, \"-0\",\tNULL, 8, 0},\n\t{-EINVAL, \"10-1\", NULL, 8, 0},\n\t{-ERANGE, \"8-8\", NULL, 8, 0},\n\t{-ERANGE, \"0-31\", NULL, 8, 0},\n\t{-EINVAL, \"0-31:\", NULL, 32, 0},\n\t{-EINVAL, \"0-31:0\", NULL, 32, 0},\n\t{-EINVAL, \"0-31:0/\", NULL, 32, 0},\n\t{-EINVAL, \"0-31:0/0\", NULL, 32, 0},\n\t{-EINVAL, \"0-31:1/0\", NULL, 32, 0},\n\t{-EINVAL, \"0-31:10/1\", NULL, 32, 0},\n\t{-EOVERFLOW, \"0-98765432123456789:10/1\", NULL, 8, 0},\n\n\t{-EINVAL, \"a-31\", NULL, 8, 0},\n\t{-EINVAL, \"0-a1\", NULL, 8, 0},\n\t{-EINVAL, \"a-31:10/1\", NULL, 8, 0},\n\t{-EINVAL, \"0-31:a/1\", NULL, 8, 0},\n\t{-EINVAL, \"0-\\n\", NULL, 8, 0},\n\n};\n\nstatic void __init test_bitmap_parselist(void)\n{\n\tint i;\n\tint err;\n\tktime_t time;\n\tDECLARE_BITMAP(bmap, 2048);\n\n\tfor (i = 0; i < ARRAY_SIZE(parselist_tests); i++) {\n#define ptest parselist_tests[i]\n\n\t\ttime = ktime_get();\n\t\terr = bitmap_parselist(ptest.in, bmap, ptest.nbits);\n\t\ttime = ktime_get() - time;\n\n\t\tif (err != ptest.errno) {\n\t\t\tpr_err(\"parselist: %d: input is %s, errno is %d, expected %d\\n\",\n\t\t\t\t\ti, ptest.in, err, ptest.errno);\n\t\t\tfailed_tests++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!err && ptest.expected\n\t\t\t && !__bitmap_equal(bmap, ptest.expected, ptest.nbits)) {\n\t\t\tpr_err(\"parselist: %d: input is %s, result is 0x%lx, expected 0x%lx\\n\",\n\t\t\t\t\ti, ptest.in, bmap[0],\n\t\t\t\t\t*ptest.expected);\n\t\t\tfailed_tests++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (ptest.flags & PARSE_TIME)\n\t\t\tpr_err(\"parselist: %d: input is '%s' OK, Time: %llu\\n\",\n\t\t\t\t\ti, ptest.in, time);\n\n#undef ptest\n\t}\n}\n\nstatic void __init test_bitmap_printlist(void)\n{\n\tunsigned long *bmap = kmalloc(PAGE_SIZE, GFP_KERNEL);\n\tchar *buf = kmalloc(PAGE_SIZE, GFP_KERNEL);\n\tchar expected[256];\n\tint ret, slen;\n\tktime_t time;\n\n\tif (!buf || !bmap)\n\t\tgoto out;\n\n\tmemset(bmap, -1, PAGE_SIZE);\n\tslen = snprintf(expected, 256, \"0-%ld\", PAGE_SIZE * 8 - 1);\n\tif (slen < 0)\n\t\tgoto out;\n\n\ttime = ktime_get();\n\tret = bitmap_print_to_pagebuf(true, buf, bmap, PAGE_SIZE * 8);\n\ttime = ktime_get() - time;\n\n\tif (ret != slen + 1) {\n\t\tpr_err(\"bitmap_print_to_pagebuf: result is %d, expected %d\\n\", ret, slen);\n\t\tfailed_tests++;\n\t\tgoto out;\n\t}\n\n\tif (strncmp(buf, expected, slen)) {\n\t\tpr_err(\"bitmap_print_to_pagebuf: result is %s, expected %s\\n\", buf, expected);\n\t\tfailed_tests++;\n\t\tgoto out;\n\t}\n\n\tpr_err(\"bitmap_print_to_pagebuf: input is '%s', Time: %llu\\n\", buf, time);\nout:\n\tkfree(buf);\n\tkfree(bmap);\n}\n\nstatic const unsigned long parse_test[] __initconst = {\n\tBITMAP_FROM_U64(0),\n\tBITMAP_FROM_U64(1),\n\tBITMAP_FROM_U64(0xdeadbeef),\n\tBITMAP_FROM_U64(0x100000000ULL),\n};\n\nstatic const unsigned long parse_test2[] __initconst = {\n\tBITMAP_FROM_U64(0x100000000ULL), BITMAP_FROM_U64(0xdeadbeef),\n\tBITMAP_FROM_U64(0x100000000ULL), BITMAP_FROM_U64(0xbaadf00ddeadbeef),\n\tBITMAP_FROM_U64(0x100000000ULL), BITMAP_FROM_U64(0x0badf00ddeadbeef),\n};\n\nstatic const struct test_bitmap_parselist parse_tests[] __initconst = {\n\t{0, \"\",\t\t\t\t&parse_test[0 * step], 32, 0},\n\t{0, \" \",\t\t\t&parse_test[0 * step], 32, 0},\n\t{0, \"0\",\t\t\t&parse_test[0 * step], 32, 0},\n\t{0, \"0\\n\",\t\t\t&parse_test[0 * step], 32, 0},\n\t{0, \"1\",\t\t\t&parse_test[1 * step], 32, 0},\n\t{0, \"deadbeef\",\t\t\t&parse_test[2 * step], 32, 0},\n\t{0, \"1,0\",\t\t\t&parse_test[3 * step], 33, 0},\n\t{0, \"deadbeef,\\n,0,1\",\t\t&parse_test[2 * step], 96, 0},\n\n\t{0, \"deadbeef,1,0\",\t\t&parse_test2[0 * 2 * step], 96, 0},\n\t{0, \"baadf00d,deadbeef,1,0\",\t&parse_test2[1 * 2 * step], 128, 0},\n\t{0, \"badf00d,deadbeef,1,0\",\t&parse_test2[2 * 2 * step], 124, 0},\n\t{0, \"badf00d,deadbeef,1,0\",\t&parse_test2[2 * 2 * step], 124, NO_LEN},\n\t{0, \"  badf00d,deadbeef,1,0  \",\t&parse_test2[2 * 2 * step], 124, 0},\n\t{0, \" , badf00d,deadbeef,1,0 , \",\t&parse_test2[2 * 2 * step], 124, 0},\n\t{0, \" , badf00d, ,, ,,deadbeef,1,0 , \",\t&parse_test2[2 * 2 * step], 124, 0},\n\n\t{-EINVAL,    \"goodfood,deadbeef,1,0\",\tNULL, 128, 0},\n\t{-EOVERFLOW, \"3,0\",\t\t\tNULL, 33, 0},\n\t{-EOVERFLOW, \"123badf00d,deadbeef,1,0\",\tNULL, 128, 0},\n\t{-EOVERFLOW, \"badf00d,deadbeef,1,0\",\tNULL, 90, 0},\n\t{-EOVERFLOW, \"fbadf00d,deadbeef,1,0\",\tNULL, 95, 0},\n\t{-EOVERFLOW, \"badf00d,deadbeef,1,0\",\tNULL, 100, 0},\n#undef step\n};\n\nstatic void __init test_bitmap_parse(void)\n{\n\tint i;\n\tint err;\n\tktime_t time;\n\tDECLARE_BITMAP(bmap, 2048);\n\n\tfor (i = 0; i < ARRAY_SIZE(parse_tests); i++) {\n\t\tstruct test_bitmap_parselist test = parse_tests[i];\n\t\tsize_t len = test.flags & NO_LEN ? UINT_MAX : strlen(test.in);\n\n\t\ttime = ktime_get();\n\t\terr = bitmap_parse(test.in, len, bmap, test.nbits);\n\t\ttime = ktime_get() - time;\n\n\t\tif (err != test.errno) {\n\t\t\tpr_err(\"parse: %d: input is %s, errno is %d, expected %d\\n\",\n\t\t\t\t\ti, test.in, err, test.errno);\n\t\t\tfailed_tests++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!err && test.expected\n\t\t\t && !__bitmap_equal(bmap, test.expected, test.nbits)) {\n\t\t\tpr_err(\"parse: %d: input is %s, result is 0x%lx, expected 0x%lx\\n\",\n\t\t\t\t\ti, test.in, bmap[0],\n\t\t\t\t\t*test.expected);\n\t\t\tfailed_tests++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (test.flags & PARSE_TIME)\n\t\t\tpr_err(\"parse: %d: input is '%s' OK, Time: %llu\\n\",\n\t\t\t\t\ti, test.in, time);\n\t}\n}\n\nstatic void __init test_bitmap_arr32(void)\n{\n\tunsigned int nbits, next_bit;\n\tu32 arr[EXP1_IN_BITS / 32];\n\tDECLARE_BITMAP(bmap2, EXP1_IN_BITS);\n\n\tmemset(arr, 0xa5, sizeof(arr));\n\n\tfor (nbits = 0; nbits < EXP1_IN_BITS; ++nbits) {\n\t\tbitmap_to_arr32(arr, exp1, nbits);\n\t\tbitmap_from_arr32(bmap2, arr, nbits);\n\t\texpect_eq_bitmap(bmap2, exp1, nbits);\n\n\t\tnext_bit = find_next_bit(bmap2,\n\t\t\t\tround_up(nbits, BITS_PER_LONG), nbits);\n\t\tif (next_bit < round_up(nbits, BITS_PER_LONG)) {\n\t\t\tpr_err(\"bitmap_copy_arr32(nbits == %d:\"\n\t\t\t\t\" tail is not safely cleared: %d\\n\",\n\t\t\t\tnbits, next_bit);\n\t\t\tfailed_tests++;\n\t\t}\n\n\t\tif (nbits < EXP1_IN_BITS - 32)\n\t\t\texpect_eq_uint(arr[DIV_ROUND_UP(nbits, 32)],\n\t\t\t\t\t\t\t\t0xa5a5a5a5);\n\t}\n}\n\nstatic void __init test_bitmap_arr64(void)\n{\n\tunsigned int nbits, next_bit;\n\tu64 arr[EXP1_IN_BITS / 64];\n\tDECLARE_BITMAP(bmap2, EXP1_IN_BITS);\n\n\tmemset(arr, 0xa5, sizeof(arr));\n\n\tfor (nbits = 0; nbits < EXP1_IN_BITS; ++nbits) {\n\t\tmemset(bmap2, 0xff, sizeof(arr));\n\t\tbitmap_to_arr64(arr, exp1, nbits);\n\t\tbitmap_from_arr64(bmap2, arr, nbits);\n\t\texpect_eq_bitmap(bmap2, exp1, nbits);\n\n\t\tnext_bit = find_next_bit(bmap2, round_up(nbits, BITS_PER_LONG), nbits);\n\t\tif (next_bit < round_up(nbits, BITS_PER_LONG)) {\n\t\t\tpr_err(\"bitmap_copy_arr64(nbits == %d:\"\n\t\t\t\t\" tail is not safely cleared: %d\\n\", nbits, next_bit);\n\t\t\tfailed_tests++;\n\t\t}\n\n\t\tif ((nbits % 64) &&\n\t\t    (arr[(nbits - 1) / 64] & ~GENMASK_ULL((nbits - 1) % 64, 0))) {\n\t\t\tpr_err(\"bitmap_to_arr64(nbits == %d): tail is not safely cleared: 0x%016llx (must be 0x%016llx)\\n\",\n\t\t\t       nbits, arr[(nbits - 1) / 64],\n\t\t\t       GENMASK_ULL((nbits - 1) % 64, 0));\n\t\t\tfailed_tests++;\n\t\t}\n\n\t\tif (nbits < EXP1_IN_BITS - 64)\n\t\t\texpect_eq_uint(arr[DIV_ROUND_UP(nbits, 64)], 0xa5a5a5a5);\n\t}\n}\n\nstatic void noinline __init test_mem_optimisations(void)\n{\n\tDECLARE_BITMAP(bmap1, 1024);\n\tDECLARE_BITMAP(bmap2, 1024);\n\tunsigned int start, nbits;\n\n\tfor (start = 0; start < 1024; start += 8) {\n\t\tfor (nbits = 0; nbits < 1024 - start; nbits += 8) {\n\t\t\tmemset(bmap1, 0x5a, sizeof(bmap1));\n\t\t\tmemset(bmap2, 0x5a, sizeof(bmap2));\n\n\t\t\tbitmap_set(bmap1, start, nbits);\n\t\t\t__bitmap_set(bmap2, start, nbits);\n\t\t\tif (!bitmap_equal(bmap1, bmap2, 1024)) {\n\t\t\t\tprintk(\"set not equal %d %d\\n\", start, nbits);\n\t\t\t\tfailed_tests++;\n\t\t\t}\n\t\t\tif (!__bitmap_equal(bmap1, bmap2, 1024)) {\n\t\t\t\tprintk(\"set not __equal %d %d\\n\", start, nbits);\n\t\t\t\tfailed_tests++;\n\t\t\t}\n\n\t\t\tbitmap_clear(bmap1, start, nbits);\n\t\t\t__bitmap_clear(bmap2, start, nbits);\n\t\t\tif (!bitmap_equal(bmap1, bmap2, 1024)) {\n\t\t\t\tprintk(\"clear not equal %d %d\\n\", start, nbits);\n\t\t\t\tfailed_tests++;\n\t\t\t}\n\t\t\tif (!__bitmap_equal(bmap1, bmap2, 1024)) {\n\t\t\t\tprintk(\"clear not __equal %d %d\\n\", start,\n\t\t\t\t\t\t\t\t\tnbits);\n\t\t\t\tfailed_tests++;\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic const unsigned char clump_exp[] __initconst = {\n\t0x01,\t \n\t0x02,\t \n\t0x00,\t \n\t0x38,\t \n\t0x38,\t \n\t0x0F,\t \n\t0xFF,\t \n\t0x05,\t \n};\n\nstatic void __init test_for_each_set_clump8(void)\n{\n#define CLUMP_EXP_NUMBITS 64\n\tDECLARE_BITMAP(bits, CLUMP_EXP_NUMBITS);\n\tunsigned int start;\n\tunsigned long clump;\n\n\t \n\tbitmap_zero(bits, CLUMP_EXP_NUMBITS);\n\tbitmap_set(bits, 0, 1);\t\t \n\tbitmap_set(bits, 9, 1);\t\t \n\tbitmap_set(bits, 27, 3);\t \n\tbitmap_set(bits, 35, 3);\t \n\tbitmap_set(bits, 40, 4);\t \n\tbitmap_set(bits, 48, 8);\t \n\tbitmap_set(bits, 56, 1);\t \n\tbitmap_set(bits, 58, 1);\t \n\n\tfor_each_set_clump8(start, clump, bits, CLUMP_EXP_NUMBITS)\n\t\texpect_eq_clump8(start, CLUMP_EXP_NUMBITS, clump_exp, &clump);\n}\n\nstatic void __init test_for_each_set_bit_wrap(void)\n{\n\tDECLARE_BITMAP(orig, 500);\n\tDECLARE_BITMAP(copy, 500);\n\tunsigned int wr, bit;\n\n\tbitmap_zero(orig, 500);\n\n\t \n\tfor (bit = 0; bit < 500; bit += 10)\n\t\tbitmap_set(orig, bit, 1);\n\n\t \n\tbitmap_set(orig, 100, 50);\n\n\tfor (wr = 0; wr < 500; wr++) {\n\t\tbitmap_zero(copy, 500);\n\n\t\tfor_each_set_bit_wrap(bit, orig, 500, wr)\n\t\t\tbitmap_set(copy, bit, 1);\n\n\t\texpect_eq_bitmap(orig, copy, 500);\n\t}\n}\n\nstatic void __init test_for_each_set_bit(void)\n{\n\tDECLARE_BITMAP(orig, 500);\n\tDECLARE_BITMAP(copy, 500);\n\tunsigned int bit;\n\n\tbitmap_zero(orig, 500);\n\tbitmap_zero(copy, 500);\n\n\t \n\tfor (bit = 0; bit < 500; bit += 10)\n\t\tbitmap_set(orig, bit, 1);\n\n\t \n\tbitmap_set(orig, 100, 50);\n\n\tfor_each_set_bit(bit, orig, 500)\n\t\tbitmap_set(copy, bit, 1);\n\n\texpect_eq_bitmap(orig, copy, 500);\n}\n\nstatic void __init test_for_each_set_bit_from(void)\n{\n\tDECLARE_BITMAP(orig, 500);\n\tDECLARE_BITMAP(copy, 500);\n\tunsigned int wr, bit;\n\n\tbitmap_zero(orig, 500);\n\n\t \n\tfor (bit = 0; bit < 500; bit += 10)\n\t\tbitmap_set(orig, bit, 1);\n\n\t \n\tbitmap_set(orig, 100, 50);\n\n\tfor (wr = 0; wr < 500; wr++) {\n\t\tDECLARE_BITMAP(tmp, 500);\n\n\t\tbitmap_zero(copy, 500);\n\t\tbit = wr;\n\n\t\tfor_each_set_bit_from(bit, orig, 500)\n\t\t\tbitmap_set(copy, bit, 1);\n\n\t\tbitmap_copy(tmp, orig, 500);\n\t\tbitmap_clear(tmp, 0, wr);\n\t\texpect_eq_bitmap(tmp, copy, 500);\n\t}\n}\n\nstatic void __init test_for_each_clear_bit(void)\n{\n\tDECLARE_BITMAP(orig, 500);\n\tDECLARE_BITMAP(copy, 500);\n\tunsigned int bit;\n\n\tbitmap_fill(orig, 500);\n\tbitmap_fill(copy, 500);\n\n\t \n\tfor (bit = 0; bit < 500; bit += 10)\n\t\tbitmap_clear(orig, bit, 1);\n\n\t \n\tbitmap_clear(orig, 100, 50);\n\n\tfor_each_clear_bit(bit, orig, 500)\n\t\tbitmap_clear(copy, bit, 1);\n\n\texpect_eq_bitmap(orig, copy, 500);\n}\n\nstatic void __init test_for_each_clear_bit_from(void)\n{\n\tDECLARE_BITMAP(orig, 500);\n\tDECLARE_BITMAP(copy, 500);\n\tunsigned int wr, bit;\n\n\tbitmap_fill(orig, 500);\n\n\t \n\tfor (bit = 0; bit < 500; bit += 10)\n\t\tbitmap_clear(orig, bit, 1);\n\n\t \n\tbitmap_clear(orig, 100, 50);\n\n\tfor (wr = 0; wr < 500; wr++) {\n\t\tDECLARE_BITMAP(tmp, 500);\n\n\t\tbitmap_fill(copy, 500);\n\t\tbit = wr;\n\n\t\tfor_each_clear_bit_from(bit, orig, 500)\n\t\t\tbitmap_clear(copy, bit, 1);\n\n\t\tbitmap_copy(tmp, orig, 500);\n\t\tbitmap_set(tmp, 0, wr);\n\t\texpect_eq_bitmap(tmp, copy, 500);\n\t}\n}\n\nstatic void __init test_for_each_set_bitrange(void)\n{\n\tDECLARE_BITMAP(orig, 500);\n\tDECLARE_BITMAP(copy, 500);\n\tunsigned int s, e;\n\n\tbitmap_zero(orig, 500);\n\tbitmap_zero(copy, 500);\n\n\t \n\tfor (s = 0; s < 500; s += 10)\n\t\tbitmap_set(orig, s, 1);\n\n\t \n\tbitmap_set(orig, 100, 50);\n\n\tfor_each_set_bitrange(s, e, orig, 500)\n\t\tbitmap_set(copy, s, e-s);\n\n\texpect_eq_bitmap(orig, copy, 500);\n}\n\nstatic void __init test_for_each_clear_bitrange(void)\n{\n\tDECLARE_BITMAP(orig, 500);\n\tDECLARE_BITMAP(copy, 500);\n\tunsigned int s, e;\n\n\tbitmap_fill(orig, 500);\n\tbitmap_fill(copy, 500);\n\n\t \n\tfor (s = 0; s < 500; s += 10)\n\t\tbitmap_clear(orig, s, 1);\n\n\t \n\tbitmap_clear(orig, 100, 50);\n\n\tfor_each_clear_bitrange(s, e, orig, 500)\n\t\tbitmap_clear(copy, s, e-s);\n\n\texpect_eq_bitmap(orig, copy, 500);\n}\n\nstatic void __init test_for_each_set_bitrange_from(void)\n{\n\tDECLARE_BITMAP(orig, 500);\n\tDECLARE_BITMAP(copy, 500);\n\tunsigned int wr, s, e;\n\n\tbitmap_zero(orig, 500);\n\n\t \n\tfor (s = 0; s < 500; s += 10)\n\t\tbitmap_set(orig, s, 1);\n\n\t \n\tbitmap_set(orig, 100, 50);\n\n\tfor (wr = 0; wr < 500; wr++) {\n\t\tDECLARE_BITMAP(tmp, 500);\n\n\t\tbitmap_zero(copy, 500);\n\t\ts = wr;\n\n\t\tfor_each_set_bitrange_from(s, e, orig, 500)\n\t\t\tbitmap_set(copy, s, e - s);\n\n\t\tbitmap_copy(tmp, orig, 500);\n\t\tbitmap_clear(tmp, 0, wr);\n\t\texpect_eq_bitmap(tmp, copy, 500);\n\t}\n}\n\nstatic void __init test_for_each_clear_bitrange_from(void)\n{\n\tDECLARE_BITMAP(orig, 500);\n\tDECLARE_BITMAP(copy, 500);\n\tunsigned int wr, s, e;\n\n\tbitmap_fill(orig, 500);\n\n\t \n\tfor (s = 0; s < 500; s += 10)\n\t\tbitmap_clear(orig, s, 1);\n\n\t \n\tbitmap_set(orig, 100, 50);\n\n\tfor (wr = 0; wr < 500; wr++) {\n\t\tDECLARE_BITMAP(tmp, 500);\n\n\t\tbitmap_fill(copy, 500);\n\t\ts = wr;\n\n\t\tfor_each_clear_bitrange_from(s, e, orig, 500)\n\t\t\tbitmap_clear(copy, s, e - s);\n\n\t\tbitmap_copy(tmp, orig, 500);\n\t\tbitmap_set(tmp, 0, wr);\n\t\texpect_eq_bitmap(tmp, copy, 500);\n\t}\n}\n\nstruct test_bitmap_cut {\n\tunsigned int first;\n\tunsigned int cut;\n\tunsigned int nbits;\n\tunsigned long in[4];\n\tunsigned long expected[4];\n};\n\nstatic struct test_bitmap_cut test_cut[] = {\n\t{  0,  0,  8, { 0x0000000aUL, }, { 0x0000000aUL, }, },\n\t{  0,  0, 32, { 0xdadadeadUL, }, { 0xdadadeadUL, }, },\n\t{  0,  3,  8, { 0x000000aaUL, }, { 0x00000015UL, }, },\n\t{  3,  3,  8, { 0x000000aaUL, }, { 0x00000012UL, }, },\n\t{  0,  1, 32, { 0xa5a5a5a5UL, }, { 0x52d2d2d2UL, }, },\n\t{  0,  8, 32, { 0xdeadc0deUL, }, { 0x00deadc0UL, }, },\n\t{  1,  1, 32, { 0x5a5a5a5aUL, }, { 0x2d2d2d2cUL, }, },\n\t{  0, 15, 32, { 0xa5a5a5a5UL, }, { 0x00014b4bUL, }, },\n\t{  0, 16, 32, { 0xa5a5a5a5UL, }, { 0x0000a5a5UL, }, },\n\t{ 15, 15, 32, { 0xa5a5a5a5UL, }, { 0x000125a5UL, }, },\n\t{ 15, 16, 32, { 0xa5a5a5a5UL, }, { 0x0000a5a5UL, }, },\n\t{ 16, 15, 32, { 0xa5a5a5a5UL, }, { 0x0001a5a5UL, }, },\n\n\t{ BITS_PER_LONG, BITS_PER_LONG, BITS_PER_LONG,\n\t\t{ 0xa5a5a5a5UL, 0xa5a5a5a5UL, },\n\t\t{ 0xa5a5a5a5UL, 0xa5a5a5a5UL, },\n\t},\n\t{ 1, BITS_PER_LONG - 1, BITS_PER_LONG,\n\t\t{ 0xa5a5a5a5UL, 0xa5a5a5a5UL, },\n\t\t{ 0x00000001UL, 0x00000001UL, },\n\t},\n\n\t{ 0, BITS_PER_LONG * 2, BITS_PER_LONG * 2 + 1,\n\t\t{ 0xa5a5a5a5UL, 0x00000001UL, 0x00000001UL, 0x00000001UL },\n\t\t{ 0x00000001UL, },\n\t},\n\t{ 16, BITS_PER_LONG * 2 + 1, BITS_PER_LONG * 2 + 1 + 16,\n\t\t{ 0x0000ffffUL, 0x5a5a5a5aUL, 0x5a5a5a5aUL, 0x5a5a5a5aUL },\n\t\t{ 0x2d2dffffUL, },\n\t},\n};\n\nstatic void __init test_bitmap_cut(void)\n{\n\tunsigned long b[5], *in = &b[1], *out = &b[0];\t \n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(test_cut); i++) {\n\t\tstruct test_bitmap_cut *t = &test_cut[i];\n\n\t\tmemcpy(in, t->in, sizeof(t->in));\n\n\t\tbitmap_cut(out, in, t->first, t->cut, t->nbits);\n\n\t\texpect_eq_bitmap(t->expected, out, t->nbits);\n\t}\n}\n\nstruct test_bitmap_print {\n\tconst unsigned long *bitmap;\n\tunsigned long nbits;\n\tconst char *mask;\n\tconst char *list;\n};\n\nstatic const unsigned long small_bitmap[] __initconst = {\n\tBITMAP_FROM_U64(0x3333333311111111ULL),\n};\n\nstatic const char small_mask[] __initconst = \"33333333,11111111\\n\";\nstatic const char small_list[] __initconst = \"0,4,8,12,16,20,24,28,32-33,36-37,40-41,44-45,48-49,52-53,56-57,60-61\\n\";\n\nstatic const unsigned long large_bitmap[] __initconst = {\n\tBITMAP_FROM_U64(0x3333333311111111ULL), BITMAP_FROM_U64(0x3333333311111111ULL),\n\tBITMAP_FROM_U64(0x3333333311111111ULL), BITMAP_FROM_U64(0x3333333311111111ULL),\n\tBITMAP_FROM_U64(0x3333333311111111ULL), BITMAP_FROM_U64(0x3333333311111111ULL),\n\tBITMAP_FROM_U64(0x3333333311111111ULL), BITMAP_FROM_U64(0x3333333311111111ULL),\n\tBITMAP_FROM_U64(0x3333333311111111ULL), BITMAP_FROM_U64(0x3333333311111111ULL),\n\tBITMAP_FROM_U64(0x3333333311111111ULL), BITMAP_FROM_U64(0x3333333311111111ULL),\n\tBITMAP_FROM_U64(0x3333333311111111ULL), BITMAP_FROM_U64(0x3333333311111111ULL),\n\tBITMAP_FROM_U64(0x3333333311111111ULL), BITMAP_FROM_U64(0x3333333311111111ULL),\n\tBITMAP_FROM_U64(0x3333333311111111ULL), BITMAP_FROM_U64(0x3333333311111111ULL),\n\tBITMAP_FROM_U64(0x3333333311111111ULL), BITMAP_FROM_U64(0x3333333311111111ULL),\n\tBITMAP_FROM_U64(0x3333333311111111ULL), BITMAP_FROM_U64(0x3333333311111111ULL),\n\tBITMAP_FROM_U64(0x3333333311111111ULL), BITMAP_FROM_U64(0x3333333311111111ULL),\n\tBITMAP_FROM_U64(0x3333333311111111ULL), BITMAP_FROM_U64(0x3333333311111111ULL),\n\tBITMAP_FROM_U64(0x3333333311111111ULL), BITMAP_FROM_U64(0x3333333311111111ULL),\n\tBITMAP_FROM_U64(0x3333333311111111ULL), BITMAP_FROM_U64(0x3333333311111111ULL),\n\tBITMAP_FROM_U64(0x3333333311111111ULL), BITMAP_FROM_U64(0x3333333311111111ULL),\n\tBITMAP_FROM_U64(0x3333333311111111ULL), BITMAP_FROM_U64(0x3333333311111111ULL),\n\tBITMAP_FROM_U64(0x3333333311111111ULL), BITMAP_FROM_U64(0x3333333311111111ULL),\n\tBITMAP_FROM_U64(0x3333333311111111ULL), BITMAP_FROM_U64(0x3333333311111111ULL),\n\tBITMAP_FROM_U64(0x3333333311111111ULL), BITMAP_FROM_U64(0x3333333311111111ULL),\n};\n\nstatic const char large_mask[] __initconst = \"33333333,11111111,33333333,11111111,\"\n\t\t\t\t\t\"33333333,11111111,33333333,11111111,\"\n\t\t\t\t\t\"33333333,11111111,33333333,11111111,\"\n\t\t\t\t\t\"33333333,11111111,33333333,11111111,\"\n\t\t\t\t\t\"33333333,11111111,33333333,11111111,\"\n\t\t\t\t\t\"33333333,11111111,33333333,11111111,\"\n\t\t\t\t\t\"33333333,11111111,33333333,11111111,\"\n\t\t\t\t\t\"33333333,11111111,33333333,11111111,\"\n\t\t\t\t\t\"33333333,11111111,33333333,11111111,\"\n\t\t\t\t\t\"33333333,11111111,33333333,11111111,\"\n\t\t\t\t\t\"33333333,11111111,33333333,11111111,\"\n\t\t\t\t\t\"33333333,11111111,33333333,11111111,\"\n\t\t\t\t\t\"33333333,11111111,33333333,11111111,\"\n\t\t\t\t\t\"33333333,11111111,33333333,11111111,\"\n\t\t\t\t\t\"33333333,11111111,33333333,11111111,\"\n\t\t\t\t\t\"33333333,11111111,33333333,11111111,\"\n\t\t\t\t\t\"33333333,11111111,33333333,11111111,\"\n\t\t\t\t\t\"33333333,11111111,33333333,11111111,\"\n\t\t\t\t\t\"33333333,11111111,33333333,11111111,\"\n\t\t\t\t\t\"33333333,11111111,33333333,11111111\\n\";\n\nstatic const char large_list[] __initconst =  \n\t\"0,4,8,12,16,20,24,28,32-33,36-37,40-41,44-45,48-49,52-53,56-57,60-61,64,68,72,76,80,84,88,92,96-97,100-101,104-1\"\n\t\"05,108-109,112-113,116-117,120-121,124-125,128,132,136,140,144,148,152,156,160-161,164-165,168-169,172-173,176-1\"\n\t\"77,180-181,184-185,188-189,192,196,200,204,208,212,216,220,224-225,228-229,232-233,236-237,240-241,244-245,248-2\"\n\t\"49,252-253,256,260,264,268,272,276,280,284,288-289,292-293,296-297,300-301,304-305,308-309,312-313,316-317,320,3\"\n\t\"24,328,332,336,340,344,348,352-353,356-357,360-361,364-365,368-369,372-373,376-377,380-381,384,388,392,396,400,4\"\n\t\"04,408,412,416-417,420-421,424-425,428-429,432-433,436-437,440-441,444-445,448,452,456,460,464,468,472,476,480-4\"\n\t\"81,484-485,488-489,492-493,496-497,500-501,504-505,508-509,512,516,520,524,528,532,536,540,544-545,548-549,552-5\"\n\t\"53,556-557,560-561,564-565,568-569,572-573,576,580,584,588,592,596,600,604,608-609,612-613,616-617,620-621,624-6\"\n\t\"25,628-629,632-633,636-637,640,644,648,652,656,660,664,668,672-673,676-677,680-681,684-685,688-689,692-693,696-6\"\n\t\"97,700-701,704,708,712,716,720,724,728,732,736-737,740-741,744-745,748-749,752-753,756-757,760-761,764-765,768,7\"\n\t\"72,776,780,784,788,792,796,800-801,804-805,808-809,812-813,816-817,820-821,824-825,828-829,832,836,840,844,848,8\"\n\t\"52,856,860,864-865,868-869,872-873,876-877,880-881,884-885,888-889,892-893,896,900,904,908,912,916,920,924,928-9\"\n\t\"29,932-933,936-937,940-941,944-945,948-949,952-953,956-957,960,964,968,972,976,980,984,988,992-993,996-997,1000-\"\n\t\"1001,1004-1005,1008-1009,1012-1013,1016-1017,1020-1021,1024,1028,1032,1036,1040,1044,1048,1052,1056-1057,1060-10\"\n\t\"61,1064-1065,1068-1069,1072-1073,1076-1077,1080-1081,1084-1085,1088,1092,1096,1100,1104,1108,1112,1116,1120-1121\"\n\t\",1124-1125,1128-1129,1132-1133,1136-1137,1140-1141,1144-1145,1148-1149,1152,1156,1160,1164,1168,1172,1176,1180,1\"\n\t\"184-1185,1188-1189,1192-1193,1196-1197,1200-1201,1204-1205,1208-1209,1212-1213,1216,1220,1224,1228,1232,1236,124\"\n\t\"0,1244,1248-1249,1252-1253,1256-1257,1260-1261,1264-1265,1268-1269,1272-1273,1276-1277,1280,1284,1288,1292,1296,\"\n\t\"1300,1304,1308,1312-1313,1316-1317,1320-1321,1324-1325,1328-1329,1332-1333,1336-1337,1340-1341,1344,1348,1352,13\"\n\t\"56,1360,1364,1368,1372,1376-1377,1380-1381,1384-1385,1388-1389,1392-1393,1396-1397,1400-1401,1404-1405,1408,1412\"\n\t\",1416,1420,1424,1428,1432,1436,1440-1441,1444-1445,1448-1449,1452-1453,1456-1457,1460-1461,1464-1465,1468-1469,1\"\n\t\"472,1476,1480,1484,1488,1492,1496,1500,1504-1505,1508-1509,1512-1513,1516-1517,1520-1521,1524-1525,1528-1529,153\"\n\t\"2-1533,1536,1540,1544,1548,1552,1556,1560,1564,1568-1569,1572-1573,1576-1577,1580-1581,1584-1585,1588-1589,1592-\"\n\t\"1593,1596-1597,1600,1604,1608,1612,1616,1620,1624,1628,1632-1633,1636-1637,1640-1641,1644-1645,1648-1649,1652-16\"\n\t\"53,1656-1657,1660-1661,1664,1668,1672,1676,1680,1684,1688,1692,1696-1697,1700-1701,1704-1705,1708-1709,1712-1713\"\n\t\",1716-1717,1720-1721,1724-1725,1728,1732,1736,1740,1744,1748,1752,1756,1760-1761,1764-1765,1768-1769,1772-1773,1\"\n\t\"776-1777,1780-1781,1784-1785,1788-1789,1792,1796,1800,1804,1808,1812,1816,1820,1824-1825,1828-1829,1832-1833,183\"\n\t\"6-1837,1840-1841,1844-1845,1848-1849,1852-1853,1856,1860,1864,1868,1872,1876,1880,1884,1888-1889,1892-1893,1896-\"\n\t\"1897,1900-1901,1904-1905,1908-1909,1912-1913,1916-1917,1920,1924,1928,1932,1936,1940,1944,1948,1952-1953,1956-19\"\n\t\"57,1960-1961,1964-1965,1968-1969,1972-1973,1976-1977,1980-1981,1984,1988,1992,1996,2000,2004,2008,2012,2016-2017\"\n\t\",2020-2021,2024-2025,2028-2029,2032-2033,2036-2037,2040-2041,2044-2045,2048,2052,2056,2060,2064,2068,2072,2076,2\"\n\t\"080-2081,2084-2085,2088-2089,2092-2093,2096-2097,2100-2101,2104-2105,2108-2109,2112,2116,2120,2124,2128,2132,213\"\n\t\"6,2140,2144-2145,2148-2149,2152-2153,2156-2157,2160-2161,2164-2165,2168-2169,2172-2173,2176,2180,2184,2188,2192,\"\n\t\"2196,2200,2204,2208-2209,2212-2213,2216-2217,2220-2221,2224-2225,2228-2229,2232-2233,2236-2237,2240,2244,2248,22\"\n\t\"52,2256,2260,2264,2268,2272-2273,2276-2277,2280-2281,2284-2285,2288-2289,2292-2293,2296-2297,2300-2301,2304,2308\"\n\t\",2312,2316,2320,2324,2328,2332,2336-2337,2340-2341,2344-2345,2348-2349,2352-2353,2356-2357,2360-2361,2364-2365,2\"\n\t\"368,2372,2376,2380,2384,2388,2392,2396,2400-2401,2404-2405,2408-2409,2412-2413,2416-2417,2420-2421,2424-2425,242\"\n\t\"8-2429,2432,2436,2440,2444,2448,2452,2456,2460,2464-2465,2468-2469,2472-2473,2476-2477,2480-2481,2484-2485,2488-\"\n\t\"2489,2492-2493,2496,2500,2504,2508,2512,2516,2520,2524,2528-2529,2532-2533,2536-2537,2540-2541,2544-2545,2548-25\"\n\t\"49,2552-2553,2556-2557\\n\";\n\nstatic const struct test_bitmap_print test_print[] __initconst = {\n\t{ small_bitmap, sizeof(small_bitmap) * BITS_PER_BYTE, small_mask, small_list },\n\t{ large_bitmap, sizeof(large_bitmap) * BITS_PER_BYTE, large_mask, large_list },\n};\n\nstatic void __init test_bitmap_print_buf(void)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(test_print); i++) {\n\t\tconst struct test_bitmap_print *t = &test_print[i];\n\t\tint n;\n\n\t\tn = bitmap_print_bitmask_to_buf(print_buf, t->bitmap, t->nbits,\n\t\t\t\t\t\t0, 2 * PAGE_SIZE);\n\t\texpect_eq_uint(strlen(t->mask) + 1, n);\n\t\texpect_eq_str(t->mask, print_buf, n);\n\n\t\tn = bitmap_print_list_to_buf(print_buf, t->bitmap, t->nbits,\n\t\t\t\t\t     0, 2 * PAGE_SIZE);\n\t\texpect_eq_uint(strlen(t->list) + 1, n);\n\t\texpect_eq_str(t->list, print_buf, n);\n\n\t\t \n\t\tif (strlen(t->list) > PAGE_SIZE) {\n\t\t\tn = bitmap_print_list_to_buf(print_buf, t->bitmap, t->nbits,\n\t\t\t\t\t\t     PAGE_SIZE, PAGE_SIZE);\n\t\t\texpect_eq_uint(strlen(t->list) + 1 - PAGE_SIZE, n);\n\t\t\texpect_eq_str(t->list + PAGE_SIZE, print_buf, n);\n\t\t}\n\t}\n}\n\n \nstatic void __init test_bitmap_const_eval(void)\n{\n\tDECLARE_BITMAP(bitmap, BITS_PER_LONG);\n\tunsigned long initvar = BIT(2);\n\tunsigned long bitopvar = 0;\n\tunsigned long var = 0;\n\tint res;\n\n\t \n\n\t \n\tbitmap_clear(bitmap, 0, BITS_PER_LONG);\n\tif (!test_bit(7, bitmap))\n\t\tbitmap_set(bitmap, 5, 2);\n\n\t \n\t__change_bit(31, &bitopvar);\n\tbitmap_shift_right(&bitopvar, &bitopvar, 11, BITS_PER_LONG);\n\n\t \n\tvar |= BIT(25);\n\tif (var & BIT(0))\n\t\tvar ^= GENMASK(9, 6);\n\n\t \n\tres = bitmap_weight(bitmap, 20);\n\tBUILD_BUG_ON(!__builtin_constant_p(res));\n\tBUILD_BUG_ON(res != 2);\n\n\t \n\tres = !test_bit(18, &bitopvar);\n\tBUILD_BUG_ON(!__builtin_constant_p(res));\n\tBUILD_BUG_ON(!res);\n\n\t \n\tres = initvar & GENMASK(14, 8);\n\tBUILD_BUG_ON(!__builtin_constant_p(res));\n\tBUILD_BUG_ON(res);\n\n\t \n\tBUILD_BUG_ON(!__builtin_constant_p(~var));\n\tBUILD_BUG_ON(~var != ~BIT(25));\n}\n\nstatic void __init selftest(void)\n{\n\ttest_zero_clear();\n\ttest_fill_set();\n\ttest_copy();\n\ttest_replace();\n\ttest_bitmap_arr32();\n\ttest_bitmap_arr64();\n\ttest_bitmap_parse();\n\ttest_bitmap_parselist();\n\ttest_bitmap_printlist();\n\ttest_mem_optimisations();\n\ttest_bitmap_cut();\n\ttest_bitmap_print_buf();\n\ttest_bitmap_const_eval();\n\n\ttest_find_nth_bit();\n\ttest_for_each_set_bit();\n\ttest_for_each_set_bit_from();\n\ttest_for_each_clear_bit();\n\ttest_for_each_clear_bit_from();\n\ttest_for_each_set_bitrange();\n\ttest_for_each_clear_bitrange();\n\ttest_for_each_set_bitrange_from();\n\ttest_for_each_clear_bitrange_from();\n\ttest_for_each_set_clump8();\n\ttest_for_each_set_bit_wrap();\n}\n\nKSTM_MODULE_LOADERS(test_bitmap);\nMODULE_AUTHOR(\"david decotigny <david.decotigny@googlers.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}