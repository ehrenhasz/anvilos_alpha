{
  "module_name": "prime_numbers.c",
  "hash_id": "639b7a19be115901eaf037313292e2c00df0ac0c21fa76eee9a99374cecec6b4",
  "original_prompt": "Ingested from linux-6.6.14/lib/math/prime_numbers.c",
  "human_readable_source": "\n#define pr_fmt(fmt) \"prime numbers: \" fmt\n\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/prime_numbers.h>\n#include <linux/slab.h>\n\n#define bitmap_size(nbits) (BITS_TO_LONGS(nbits) * sizeof(unsigned long))\n\nstruct primes {\n\tstruct rcu_head rcu;\n\tunsigned long last, sz;\n\tunsigned long primes[];\n};\n\n#if BITS_PER_LONG == 64\nstatic const struct primes small_primes = {\n\t.last = 61,\n\t.sz = 64,\n\t.primes = {\n\t\tBIT(2) |\n\t\tBIT(3) |\n\t\tBIT(5) |\n\t\tBIT(7) |\n\t\tBIT(11) |\n\t\tBIT(13) |\n\t\tBIT(17) |\n\t\tBIT(19) |\n\t\tBIT(23) |\n\t\tBIT(29) |\n\t\tBIT(31) |\n\t\tBIT(37) |\n\t\tBIT(41) |\n\t\tBIT(43) |\n\t\tBIT(47) |\n\t\tBIT(53) |\n\t\tBIT(59) |\n\t\tBIT(61)\n\t}\n};\n#elif BITS_PER_LONG == 32\nstatic const struct primes small_primes = {\n\t.last = 31,\n\t.sz = 32,\n\t.primes = {\n\t\tBIT(2) |\n\t\tBIT(3) |\n\t\tBIT(5) |\n\t\tBIT(7) |\n\t\tBIT(11) |\n\t\tBIT(13) |\n\t\tBIT(17) |\n\t\tBIT(19) |\n\t\tBIT(23) |\n\t\tBIT(29) |\n\t\tBIT(31)\n\t}\n};\n#else\n#error \"unhandled BITS_PER_LONG\"\n#endif\n\nstatic DEFINE_MUTEX(lock);\nstatic const struct primes __rcu *primes = RCU_INITIALIZER(&small_primes);\n\nstatic unsigned long selftest_max;\n\nstatic bool slow_is_prime_number(unsigned long x)\n{\n\tunsigned long y = int_sqrt(x);\n\n\twhile (y > 1) {\n\t\tif ((x % y) == 0)\n\t\t\tbreak;\n\t\ty--;\n\t}\n\n\treturn y == 1;\n}\n\nstatic unsigned long slow_next_prime_number(unsigned long x)\n{\n\twhile (x < ULONG_MAX && !slow_is_prime_number(++x))\n\t\t;\n\n\treturn x;\n}\n\nstatic unsigned long clear_multiples(unsigned long x,\n\t\t\t\t     unsigned long *p,\n\t\t\t\t     unsigned long start,\n\t\t\t\t     unsigned long end)\n{\n\tunsigned long m;\n\n\tm = 2 * x;\n\tif (m < start)\n\t\tm = roundup(start, x);\n\n\twhile (m < end) {\n\t\t__clear_bit(m, p);\n\t\tm += x;\n\t}\n\n\treturn x;\n}\n\nstatic bool expand_to_next_prime(unsigned long x)\n{\n\tconst struct primes *p;\n\tstruct primes *new;\n\tunsigned long sz, y;\n\n\t \n\tsz = 2 * x;\n\tif (sz < x)\n\t\treturn false;\n\n\tsz = round_up(sz, BITS_PER_LONG);\n\tnew = kmalloc(sizeof(*new) + bitmap_size(sz),\n\t\t      GFP_KERNEL | __GFP_NOWARN);\n\tif (!new)\n\t\treturn false;\n\n\tmutex_lock(&lock);\n\tp = rcu_dereference_protected(primes, lockdep_is_held(&lock));\n\tif (x < p->last) {\n\t\tkfree(new);\n\t\tgoto unlock;\n\t}\n\n\t \n\tbitmap_fill(new->primes, sz);\n\tbitmap_copy(new->primes, p->primes, p->sz);\n\tfor (y = 2UL; y < sz; y = find_next_bit(new->primes, sz, y + 1))\n\t\tnew->last = clear_multiples(y, new->primes, p->sz, sz);\n\tnew->sz = sz;\n\n\tBUG_ON(new->last <= x);\n\n\trcu_assign_pointer(primes, new);\n\tif (p != &small_primes)\n\t\tkfree_rcu((struct primes *)p, rcu);\n\nunlock:\n\tmutex_unlock(&lock);\n\treturn true;\n}\n\nstatic void free_primes(void)\n{\n\tconst struct primes *p;\n\n\tmutex_lock(&lock);\n\tp = rcu_dereference_protected(primes, lockdep_is_held(&lock));\n\tif (p != &small_primes) {\n\t\trcu_assign_pointer(primes, &small_primes);\n\t\tkfree_rcu((struct primes *)p, rcu);\n\t}\n\tmutex_unlock(&lock);\n}\n\n \nunsigned long next_prime_number(unsigned long x)\n{\n\tconst struct primes *p;\n\n\trcu_read_lock();\n\tp = rcu_dereference(primes);\n\twhile (x >= p->last) {\n\t\trcu_read_unlock();\n\n\t\tif (!expand_to_next_prime(x))\n\t\t\treturn slow_next_prime_number(x);\n\n\t\trcu_read_lock();\n\t\tp = rcu_dereference(primes);\n\t}\n\tx = find_next_bit(p->primes, p->last, x + 1);\n\trcu_read_unlock();\n\n\treturn x;\n}\nEXPORT_SYMBOL(next_prime_number);\n\n \nbool is_prime_number(unsigned long x)\n{\n\tconst struct primes *p;\n\tbool result;\n\n\trcu_read_lock();\n\tp = rcu_dereference(primes);\n\twhile (x >= p->sz) {\n\t\trcu_read_unlock();\n\n\t\tif (!expand_to_next_prime(x))\n\t\t\treturn slow_is_prime_number(x);\n\n\t\trcu_read_lock();\n\t\tp = rcu_dereference(primes);\n\t}\n\tresult = test_bit(x, p->primes);\n\trcu_read_unlock();\n\n\treturn result;\n}\nEXPORT_SYMBOL(is_prime_number);\n\nstatic void dump_primes(void)\n{\n\tconst struct primes *p;\n\tchar *buf;\n\n\tbuf = kmalloc(PAGE_SIZE, GFP_KERNEL);\n\n\trcu_read_lock();\n\tp = rcu_dereference(primes);\n\n\tif (buf)\n\t\tbitmap_print_to_pagebuf(true, buf, p->primes, p->sz);\n\tpr_info(\"primes.{last=%lu, .sz=%lu, .primes[]=...x%lx} = %s\\n\",\n\t\tp->last, p->sz, p->primes[BITS_TO_LONGS(p->sz) - 1], buf);\n\n\trcu_read_unlock();\n\n\tkfree(buf);\n}\n\nstatic int selftest(unsigned long max)\n{\n\tunsigned long x, last;\n\n\tif (!max)\n\t\treturn 0;\n\n\tfor (last = 0, x = 2; x < max; x++) {\n\t\tbool slow = slow_is_prime_number(x);\n\t\tbool fast = is_prime_number(x);\n\n\t\tif (slow != fast) {\n\t\t\tpr_err(\"inconsistent result for is-prime(%lu): slow=%s, fast=%s!\\n\",\n\t\t\t       x, slow ? \"yes\" : \"no\", fast ? \"yes\" : \"no\");\n\t\t\tgoto err;\n\t\t}\n\n\t\tif (!slow)\n\t\t\tcontinue;\n\n\t\tif (next_prime_number(last) != x) {\n\t\t\tpr_err(\"incorrect result for next-prime(%lu): expected %lu, got %lu\\n\",\n\t\t\t       last, x, next_prime_number(last));\n\t\t\tgoto err;\n\t\t}\n\t\tlast = x;\n\t}\n\n\tpr_info(\"%s(%lu) passed, last prime was %lu\\n\", __func__, x, last);\n\treturn 0;\n\nerr:\n\tdump_primes();\n\treturn -EINVAL;\n}\n\nstatic int __init primes_init(void)\n{\n\treturn selftest(selftest_max);\n}\n\nstatic void __exit primes_exit(void)\n{\n\tfree_primes();\n}\n\nmodule_init(primes_init);\nmodule_exit(primes_exit);\n\nmodule_param_named(selftest, selftest_max, ulong, 0400);\n\nMODULE_AUTHOR(\"Intel Corporation\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}