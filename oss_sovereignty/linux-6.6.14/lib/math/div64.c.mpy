{
  "module_name": "div64.c",
  "hash_id": "272ab407f6df7018d71e833a693cb6a9afbee8aca36289cceb1e8c6f5e74e54b",
  "original_prompt": "Ingested from linux-6.6.14/lib/math/div64.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/export.h>\n#include <linux/math.h>\n#include <linux/math64.h>\n#include <linux/log2.h>\n\n \n#if BITS_PER_LONG == 32\n\n#ifndef __div64_32\nuint32_t __attribute__((weak)) __div64_32(uint64_t *n, uint32_t base)\n{\n\tuint64_t rem = *n;\n\tuint64_t b = base;\n\tuint64_t res, d = 1;\n\tuint32_t high = rem >> 32;\n\n\t \n\tres = 0;\n\tif (high >= base) {\n\t\thigh /= base;\n\t\tres = (uint64_t) high << 32;\n\t\trem -= (uint64_t) (high*base) << 32;\n\t}\n\n\twhile ((int64_t)b > 0 && b < rem) {\n\t\tb = b+b;\n\t\td = d+d;\n\t}\n\n\tdo {\n\t\tif (rem >= b) {\n\t\t\trem -= b;\n\t\t\tres += d;\n\t\t}\n\t\tb >>= 1;\n\t\td >>= 1;\n\t} while (d);\n\n\t*n = res;\n\treturn rem;\n}\nEXPORT_SYMBOL(__div64_32);\n#endif\n\n#ifndef div_s64_rem\ns64 div_s64_rem(s64 dividend, s32 divisor, s32 *remainder)\n{\n\tu64 quotient;\n\n\tif (dividend < 0) {\n\t\tquotient = div_u64_rem(-dividend, abs(divisor), (u32 *)remainder);\n\t\t*remainder = -*remainder;\n\t\tif (divisor > 0)\n\t\t\tquotient = -quotient;\n\t} else {\n\t\tquotient = div_u64_rem(dividend, abs(divisor), (u32 *)remainder);\n\t\tif (divisor < 0)\n\t\t\tquotient = -quotient;\n\t}\n\treturn quotient;\n}\nEXPORT_SYMBOL(div_s64_rem);\n#endif\n\n \n#ifndef div64_u64_rem\nu64 div64_u64_rem(u64 dividend, u64 divisor, u64 *remainder)\n{\n\tu32 high = divisor >> 32;\n\tu64 quot;\n\n\tif (high == 0) {\n\t\tu32 rem32;\n\t\tquot = div_u64_rem(dividend, divisor, &rem32);\n\t\t*remainder = rem32;\n\t} else {\n\t\tint n = fls(high);\n\t\tquot = div_u64(dividend >> n, divisor >> n);\n\n\t\tif (quot != 0)\n\t\t\tquot--;\n\n\t\t*remainder = dividend - quot * divisor;\n\t\tif (*remainder >= divisor) {\n\t\t\tquot++;\n\t\t\t*remainder -= divisor;\n\t\t}\n\t}\n\n\treturn quot;\n}\nEXPORT_SYMBOL(div64_u64_rem);\n#endif\n\n \n#ifndef div64_u64\nu64 div64_u64(u64 dividend, u64 divisor)\n{\n\tu32 high = divisor >> 32;\n\tu64 quot;\n\n\tif (high == 0) {\n\t\tquot = div_u64(dividend, divisor);\n\t} else {\n\t\tint n = fls(high);\n\t\tquot = div_u64(dividend >> n, divisor >> n);\n\n\t\tif (quot != 0)\n\t\t\tquot--;\n\t\tif ((dividend - quot * divisor) >= divisor)\n\t\t\tquot++;\n\t}\n\n\treturn quot;\n}\nEXPORT_SYMBOL(div64_u64);\n#endif\n\n#ifndef div64_s64\ns64 div64_s64(s64 dividend, s64 divisor)\n{\n\ts64 quot, t;\n\n\tquot = div64_u64(abs(dividend), abs(divisor));\n\tt = (dividend ^ divisor) >> 63;\n\n\treturn (quot ^ t) - t;\n}\nEXPORT_SYMBOL(div64_s64);\n#endif\n\n#endif  \n\n \nu32 iter_div_u64_rem(u64 dividend, u32 divisor, u64 *remainder)\n{\n\treturn __iter_div_u64_rem(dividend, divisor, remainder);\n}\nEXPORT_SYMBOL(iter_div_u64_rem);\n\n#ifndef mul_u64_u64_div_u64\nu64 mul_u64_u64_div_u64(u64 a, u64 b, u64 c)\n{\n\tu64 res = 0, div, rem;\n\tint shift;\n\n\t \n\tif (ilog2(a) + ilog2(b) > 62) {\n\t\t \n\t\tdiv = div64_u64_rem(b, c, &rem);\n\t\tres = div * a;\n\t\tb = rem;\n\n\t\tshift = ilog2(a) + ilog2(b) - 62;\n\t\tif (shift > 0) {\n\t\t\t \n\t\t\tb >>= shift;\n\t\t\tc >>= shift;\n\t\t\tif (!c)\n\t\t\t\treturn res;\n\t\t}\n\t}\n\n\treturn res + div64_u64(a * b, c);\n}\nEXPORT_SYMBOL(mul_u64_u64_div_u64);\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}