{
  "module_name": "interval_tree.c",
  "hash_id": "eab232c2ef9acb672faefa9e6da3c46de649af7ba1fc37c3441fd315adbf303c",
  "original_prompt": "Ingested from linux-6.6.14/lib/interval_tree.c",
  "human_readable_source": "\n#include <linux/interval_tree.h>\n#include <linux/interval_tree_generic.h>\n#include <linux/compiler.h>\n#include <linux/export.h>\n\n#define START(node) ((node)->start)\n#define LAST(node)  ((node)->last)\n\nINTERVAL_TREE_DEFINE(struct interval_tree_node, rb,\n\t\t     unsigned long, __subtree_last,\n\t\t     START, LAST,, interval_tree)\n\nEXPORT_SYMBOL_GPL(interval_tree_insert);\nEXPORT_SYMBOL_GPL(interval_tree_remove);\nEXPORT_SYMBOL_GPL(interval_tree_iter_first);\nEXPORT_SYMBOL_GPL(interval_tree_iter_next);\n\n#ifdef CONFIG_INTERVAL_TREE_SPAN_ITER\n \nstatic void\ninterval_tree_span_iter_next_gap(struct interval_tree_span_iter *state)\n{\n\tstruct interval_tree_node *cur = state->nodes[1];\n\n\tstate->nodes[0] = cur;\n\tdo {\n\t\tif (cur->last > state->nodes[0]->last)\n\t\t\tstate->nodes[0] = cur;\n\t\tcur = interval_tree_iter_next(cur, state->first_index,\n\t\t\t\t\t      state->last_index);\n\t} while (cur && (state->nodes[0]->last >= cur->start ||\n\t\t\t state->nodes[0]->last + 1 == cur->start));\n\tstate->nodes[1] = cur;\n}\n\nvoid interval_tree_span_iter_first(struct interval_tree_span_iter *iter,\n\t\t\t\t   struct rb_root_cached *itree,\n\t\t\t\t   unsigned long first_index,\n\t\t\t\t   unsigned long last_index)\n{\n\titer->first_index = first_index;\n\titer->last_index = last_index;\n\titer->nodes[0] = NULL;\n\titer->nodes[1] =\n\t\tinterval_tree_iter_first(itree, first_index, last_index);\n\tif (!iter->nodes[1]) {\n\t\t \n\t\titer->start_hole = first_index;\n\t\titer->last_hole = last_index;\n\t\titer->is_hole = 1;\n\t\treturn;\n\t}\n\tif (iter->nodes[1]->start > first_index) {\n\t\t \n\t\titer->start_hole = first_index;\n\t\titer->last_hole = iter->nodes[1]->start - 1;\n\t\titer->is_hole = 1;\n\t\tinterval_tree_span_iter_next_gap(iter);\n\t\treturn;\n\t}\n\n\t \n\titer->start_used = first_index;\n\titer->is_hole = 0;\n\tinterval_tree_span_iter_next_gap(iter);\n\titer->last_used = iter->nodes[0]->last;\n\tif (iter->last_used >= last_index) {\n\t\titer->last_used = last_index;\n\t\titer->nodes[0] = NULL;\n\t\titer->nodes[1] = NULL;\n\t}\n}\nEXPORT_SYMBOL_GPL(interval_tree_span_iter_first);\n\nvoid interval_tree_span_iter_next(struct interval_tree_span_iter *iter)\n{\n\tif (!iter->nodes[0] && !iter->nodes[1]) {\n\t\titer->is_hole = -1;\n\t\treturn;\n\t}\n\n\tif (iter->is_hole) {\n\t\titer->start_used = iter->last_hole + 1;\n\t\titer->last_used = iter->nodes[0]->last;\n\t\tif (iter->last_used >= iter->last_index) {\n\t\t\titer->last_used = iter->last_index;\n\t\t\titer->nodes[0] = NULL;\n\t\t\titer->nodes[1] = NULL;\n\t\t}\n\t\titer->is_hole = 0;\n\t\treturn;\n\t}\n\n\tif (!iter->nodes[1]) {\n\t\t \n\t\titer->start_hole = iter->nodes[0]->last + 1;\n\t\titer->last_hole = iter->last_index;\n\t\titer->nodes[0] = NULL;\n\t\titer->is_hole = 1;\n\t\treturn;\n\t}\n\n\t \n\titer->start_hole = iter->nodes[0]->last + 1;\n\titer->last_hole = iter->nodes[1]->start - 1;\n\titer->is_hole = 1;\n\tinterval_tree_span_iter_next_gap(iter);\n}\nEXPORT_SYMBOL_GPL(interval_tree_span_iter_next);\n\n \nvoid interval_tree_span_iter_advance(struct interval_tree_span_iter *iter,\n\t\t\t\t     struct rb_root_cached *itree,\n\t\t\t\t     unsigned long new_index)\n{\n\tif (iter->is_hole == -1)\n\t\treturn;\n\n\titer->first_index = new_index;\n\tif (new_index > iter->last_index) {\n\t\titer->is_hole = -1;\n\t\treturn;\n\t}\n\n\t \n\tif (iter->start_hole <= new_index && new_index <= iter->last_hole) {\n\t\titer->start_hole = new_index;\n\t\treturn;\n\t}\n\tif (new_index == iter->last_hole + 1)\n\t\tinterval_tree_span_iter_next(iter);\n\telse\n\t\tinterval_tree_span_iter_first(iter, itree, new_index,\n\t\t\t\t\t      iter->last_index);\n}\nEXPORT_SYMBOL_GPL(interval_tree_span_iter_advance);\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}