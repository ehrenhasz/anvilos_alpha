{
  "module_name": "parman.c",
  "hash_id": "5ae7973fbc90c67ebda683fd636b5b92122d8ae58af6c8f53374b63fa7ccb793",
  "original_prompt": "Ingested from linux-6.6.14/lib/parman.c",
  "human_readable_source": " \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/list.h>\n#include <linux/err.h>\n#include <linux/parman.h>\n\nstruct parman_algo {\n\tint (*item_add)(struct parman *parman, struct parman_prio *prio,\n\t\t\tstruct parman_item *item);\n\tvoid (*item_remove)(struct parman *parman, struct parman_prio *prio,\n\t\t\t    struct parman_item *item);\n};\n\nstruct parman {\n\tconst struct parman_ops *ops;\n\tvoid *priv;\n\tconst struct parman_algo *algo;\n\tunsigned long count;\n\tunsigned long limit_count;\n\tstruct list_head prio_list;\n};\n\nstatic int parman_enlarge(struct parman *parman)\n{\n\tunsigned long new_count = parman->limit_count +\n\t\t\t\t  parman->ops->resize_step;\n\tint err;\n\n\terr = parman->ops->resize(parman->priv, new_count);\n\tif (err)\n\t\treturn err;\n\tparman->limit_count = new_count;\n\treturn 0;\n}\n\nstatic int parman_shrink(struct parman *parman)\n{\n\tunsigned long new_count = parman->limit_count -\n\t\t\t\t  parman->ops->resize_step;\n\tint err;\n\n\tif (new_count < parman->ops->base_count)\n\t\treturn 0;\n\terr = parman->ops->resize(parman->priv, new_count);\n\tif (err)\n\t\treturn err;\n\tparman->limit_count = new_count;\n\treturn 0;\n}\n\nstatic bool parman_prio_used(struct parman_prio *prio)\n{\n\treturn !list_empty(&prio->item_list);\n}\n\nstatic struct parman_item *parman_prio_first_item(struct parman_prio *prio)\n{\n\treturn list_first_entry(&prio->item_list,\n\t\t\t\ttypeof(struct parman_item), list);\n}\n\nstatic unsigned long parman_prio_first_index(struct parman_prio *prio)\n{\n\treturn parman_prio_first_item(prio)->index;\n}\n\nstatic struct parman_item *parman_prio_last_item(struct parman_prio *prio)\n{\n\treturn list_last_entry(&prio->item_list,\n\t\t\t       typeof(struct parman_item), list);\n}\n\nstatic unsigned long parman_prio_last_index(struct parman_prio *prio)\n{\n\treturn parman_prio_last_item(prio)->index;\n}\n\nstatic unsigned long parman_lsort_new_index_find(struct parman *parman,\n\t\t\t\t\t\t struct parman_prio *prio)\n{\n\tlist_for_each_entry_from_reverse(prio, &parman->prio_list, list) {\n\t\tif (!parman_prio_used(prio))\n\t\t\tcontinue;\n\t\treturn parman_prio_last_index(prio) + 1;\n\t}\n\treturn 0;\n}\n\nstatic void __parman_prio_move(struct parman *parman, struct parman_prio *prio,\n\t\t\t       struct parman_item *item, unsigned long to_index,\n\t\t\t       unsigned long count)\n{\n\tparman->ops->move(parman->priv, item->index, to_index, count);\n}\n\nstatic void parman_prio_shift_down(struct parman *parman,\n\t\t\t\t   struct parman_prio *prio)\n{\n\tstruct parman_item *item;\n\tunsigned long to_index;\n\n\tif (!parman_prio_used(prio))\n\t\treturn;\n\titem = parman_prio_first_item(prio);\n\tto_index = parman_prio_last_index(prio) + 1;\n\t__parman_prio_move(parman, prio, item, to_index, 1);\n\tlist_move_tail(&item->list, &prio->item_list);\n\titem->index = to_index;\n}\n\nstatic void parman_prio_shift_up(struct parman *parman,\n\t\t\t\t struct parman_prio *prio)\n{\n\tstruct parman_item *item;\n\tunsigned long to_index;\n\n\tif (!parman_prio_used(prio))\n\t\treturn;\n\titem = parman_prio_last_item(prio);\n\tto_index = parman_prio_first_index(prio) - 1;\n\t__parman_prio_move(parman, prio, item, to_index, 1);\n\tlist_move(&item->list, &prio->item_list);\n\titem->index = to_index;\n}\n\nstatic void parman_prio_item_remove(struct parman *parman,\n\t\t\t\t    struct parman_prio *prio,\n\t\t\t\t    struct parman_item *item)\n{\n\tstruct parman_item *last_item;\n\tunsigned long to_index;\n\n\tlast_item = parman_prio_last_item(prio);\n\tif (last_item == item) {\n\t\tlist_del(&item->list);\n\t\treturn;\n\t}\n\tto_index = item->index;\n\t__parman_prio_move(parman, prio, last_item, to_index, 1);\n\tlist_del(&last_item->list);\n\tlist_replace(&item->list, &last_item->list);\n\tlast_item->index = to_index;\n}\n\nstatic int parman_lsort_item_add(struct parman *parman,\n\t\t\t\t struct parman_prio *prio,\n\t\t\t\t struct parman_item *item)\n{\n\tstruct parman_prio *prio2;\n\tunsigned long new_index;\n\tint err;\n\n\tif (parman->count + 1 > parman->limit_count) {\n\t\terr = parman_enlarge(parman);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tnew_index = parman_lsort_new_index_find(parman, prio);\n\tlist_for_each_entry_reverse(prio2, &parman->prio_list, list) {\n\t\tif (prio2 == prio)\n\t\t\tbreak;\n\t\tparman_prio_shift_down(parman, prio2);\n\t}\n\titem->index = new_index;\n\tlist_add_tail(&item->list, &prio->item_list);\n\tparman->count++;\n\treturn 0;\n}\n\nstatic void parman_lsort_item_remove(struct parman *parman,\n\t\t\t\t     struct parman_prio *prio,\n\t\t\t\t     struct parman_item *item)\n{\n\tparman_prio_item_remove(parman, prio, item);\n\tlist_for_each_entry_continue(prio, &parman->prio_list, list)\n\t\tparman_prio_shift_up(parman, prio);\n\tparman->count--;\n\tif (parman->limit_count - parman->count >= parman->ops->resize_step)\n\t\tparman_shrink(parman);\n}\n\nstatic const struct parman_algo parman_lsort = {\n\t.item_add\t= parman_lsort_item_add,\n\t.item_remove\t= parman_lsort_item_remove,\n};\n\nstatic const struct parman_algo *parman_algos[] = {\n\t&parman_lsort,\n};\n\n \nstruct parman *parman_create(const struct parman_ops *ops, void *priv)\n{\n\tstruct parman *parman;\n\n\tparman = kzalloc(sizeof(*parman), GFP_KERNEL);\n\tif (!parman)\n\t\treturn NULL;\n\tINIT_LIST_HEAD(&parman->prio_list);\n\tparman->ops = ops;\n\tparman->priv = priv;\n\tparman->limit_count = ops->base_count;\n\tparman->algo = parman_algos[ops->algo];\n\treturn parman;\n}\nEXPORT_SYMBOL(parman_create);\n\n \nvoid parman_destroy(struct parman *parman)\n{\n\tWARN_ON(!list_empty(&parman->prio_list));\n\tkfree(parman);\n}\nEXPORT_SYMBOL(parman_destroy);\n\n \nvoid parman_prio_init(struct parman *parman, struct parman_prio *prio,\n\t\t      unsigned long priority)\n{\n\tstruct parman_prio *prio2;\n\tstruct list_head *pos;\n\n\tINIT_LIST_HEAD(&prio->item_list);\n\tprio->priority = priority;\n\n\t \n\tlist_for_each(pos, &parman->prio_list) {\n\t\tprio2 = list_entry(pos, typeof(*prio2), list);\n\t\tif (prio2->priority > prio->priority)\n\t\t\tbreak;\n\t}\n\tlist_add_tail(&prio->list, pos);\n}\nEXPORT_SYMBOL(parman_prio_init);\n\n \nvoid parman_prio_fini(struct parman_prio *prio)\n{\n\tWARN_ON(parman_prio_used(prio));\n\tlist_del(&prio->list);\n}\nEXPORT_SYMBOL(parman_prio_fini);\n\n \nint parman_item_add(struct parman *parman, struct parman_prio *prio,\n\t\t    struct parman_item *item)\n{\n\treturn parman->algo->item_add(parman, prio, item);\n}\nEXPORT_SYMBOL(parman_item_add);\n\n \nvoid parman_item_remove(struct parman *parman, struct parman_prio *prio,\n\t\t\tstruct parman_item *item)\n{\n\tparman->algo->item_remove(parman, prio, item);\n}\nEXPORT_SYMBOL(parman_item_remove);\n\nMODULE_LICENSE(\"Dual BSD/GPL\");\nMODULE_AUTHOR(\"Jiri Pirko <jiri@mellanox.com>\");\nMODULE_DESCRIPTION(\"Priority-based array manager\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}