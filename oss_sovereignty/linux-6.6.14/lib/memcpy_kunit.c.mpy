{
  "module_name": "memcpy_kunit.c",
  "hash_id": "e509ca5eabff720d3f675285285d6c85ddc3253c6a8ef738690dad9c7dcc334c",
  "original_prompt": "Ingested from linux-6.6.14/lib/memcpy_kunit.c",
  "human_readable_source": "\n \n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <kunit/test.h>\n#include <linux/device.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/overflow.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/vmalloc.h>\n\nstruct some_bytes {\n\tunion {\n\t\tu8 data[32];\n\t\tstruct {\n\t\t\tu32 one;\n\t\t\tu16 two;\n\t\t\tu8  three;\n\t\t\t \n\t\t\tu32 four[4];\n\t\t};\n\t};\n};\n\n#define check(instance, v) do {\t\\\n\tBUILD_BUG_ON(sizeof(instance.data) != 32);\t\\\n\tfor (size_t i = 0; i < sizeof(instance.data); i++) {\t\\\n\t\tKUNIT_ASSERT_EQ_MSG(test, instance.data[i], v, \\\n\t\t\t\"line %d: '%s' not initialized to 0x%02x @ %d (saw 0x%02x)\\n\", \\\n\t\t\t__LINE__, #instance, v, i, instance.data[i]);\t\\\n\t}\t\\\n} while (0)\n\n#define compare(name, one, two) do { \\\n\tBUILD_BUG_ON(sizeof(one) != sizeof(two)); \\\n\tfor (size_t i = 0; i < sizeof(one); i++) {\t\\\n\t\tKUNIT_EXPECT_EQ_MSG(test, one.data[i], two.data[i], \\\n\t\t\t\"line %d: %s.data[%d] (0x%02x) != %s.data[%d] (0x%02x)\\n\", \\\n\t\t\t__LINE__, #one, i, one.data[i], #two, i, two.data[i]); \\\n\t}\t\\\n\tkunit_info(test, \"ok: \" TEST_OP \"() \" name \"\\n\");\t\\\n} while (0)\n\nstatic void memcpy_test(struct kunit *test)\n{\n#define TEST_OP \"memcpy\"\n\tstruct some_bytes control = {\n\t\t.data = { 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t\t\t  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t\t\t  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t\t\t  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t\t\t},\n\t};\n\tstruct some_bytes zero = { };\n\tstruct some_bytes middle = {\n\t\t.data = { 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t\t\t  0x20, 0x20, 0x20, 0x20, 0x00, 0x00, 0x00, 0x00,\n\t\t\t  0x00, 0x00, 0x00, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t\t\t  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t\t\t},\n\t};\n\tstruct some_bytes three = {\n\t\t.data = { 0x00, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t\t\t  0x20, 0x00, 0x00, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t\t\t  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t\t\t  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t\t\t},\n\t};\n\tstruct some_bytes dest = { };\n\tint count;\n\tu8 *ptr;\n\n\t \n\tcheck(control, 0x20);\n\tcheck(zero, 0);\n\tcompare(\"static initializers\", dest, zero);\n\n\t \n\tdest = control;\n\tcompare(\"direct assignment\", dest, control);\n\n\t \n\tmemcpy(dest.data, zero.data, sizeof(dest.data));\n\tcompare(\"complete overwrite\", dest, zero);\n\n\t \n\tdest = control;\n\tmemcpy(dest.data + 12, zero.data, 7);\n\tcompare(\"middle overwrite\", dest, middle);\n\n\t \n\tdest = control;\n\tptr = dest.data;\n\tcount = 1;\n\tmemcpy(ptr++, zero.data, count++);\n\tptr += 8;\n\tmemcpy(ptr++, zero.data, count++);\n\tcompare(\"argument side-effects\", dest, three);\n#undef TEST_OP\n}\n\nstatic unsigned char larger_array [2048];\n\nstatic void memmove_test(struct kunit *test)\n{\n#define TEST_OP \"memmove\"\n\tstruct some_bytes control = {\n\t\t.data = { 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99,\n\t\t\t  0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99,\n\t\t\t  0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99,\n\t\t\t  0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99,\n\t\t\t},\n\t};\n\tstruct some_bytes zero = { };\n\tstruct some_bytes middle = {\n\t\t.data = { 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99,\n\t\t\t  0x99, 0x99, 0x99, 0x99, 0x00, 0x00, 0x00, 0x00,\n\t\t\t  0x00, 0x00, 0x00, 0x99, 0x99, 0x99, 0x99, 0x99,\n\t\t\t  0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99,\n\t\t\t},\n\t};\n\tstruct some_bytes five = {\n\t\t.data = { 0x00, 0x00, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99,\n\t\t\t  0x99, 0x99, 0x00, 0x00, 0x00, 0x99, 0x99, 0x99,\n\t\t\t  0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99,\n\t\t\t  0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99,\n\t\t\t},\n\t};\n\tstruct some_bytes overlap = {\n\t\t.data = { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\n\t\t\t  0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,\n\t\t\t  0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99,\n\t\t\t  0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99,\n\t\t\t},\n\t};\n\tstruct some_bytes overlap_expected = {\n\t\t.data = { 0x00, 0x01, 0x00, 0x01, 0x02, 0x03, 0x04, 0x07,\n\t\t\t  0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,\n\t\t\t  0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99,\n\t\t\t  0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99,\n\t\t\t},\n\t};\n\tstruct some_bytes dest = { };\n\tint count;\n\tu8 *ptr;\n\n\t \n\tcheck(control, 0x99);\n\tcheck(zero, 0);\n\tcompare(\"static initializers\", zero, dest);\n\n\t \n\tdest = control;\n\tcompare(\"direct assignment\", dest, control);\n\n\t \n\tmemmove(dest.data, zero.data, sizeof(dest.data));\n\tcompare(\"complete overwrite\", dest, zero);\n\n\t \n\tdest = control;\n\tmemmove(dest.data + 12, zero.data, 7);\n\tcompare(\"middle overwrite\", dest, middle);\n\n\t \n\tdest = control;\n\tptr = dest.data;\n\tcount = 2;\n\tmemmove(ptr++, zero.data, count++);\n\tptr += 9;\n\tmemmove(ptr++, zero.data, count++);\n\tcompare(\"argument side-effects\", dest, five);\n\n\t \n\tptr = &overlap.data[2];\n\tmemmove(ptr, overlap.data, 5);\n\tcompare(\"overlapping write\", overlap, overlap_expected);\n\n\t \n\tlarger_array[256] = 0xAAu;\n\t \n\tmemmove(larger_array, larger_array + 256, 1024);\n\tKUNIT_ASSERT_EQ(test, larger_array[0], 0xAAu);\n\tKUNIT_ASSERT_EQ(test, larger_array[256], 0x00);\n\tKUNIT_ASSERT_NULL(test,\n\t\tmemchr(larger_array + 1, 0xaa, ARRAY_SIZE(larger_array) - 1));\n\t \n\tlarger_array[0] = 0xBBu;\n\tmemmove(larger_array + 256, larger_array, 1024);\n\tKUNIT_ASSERT_EQ(test, larger_array[0], 0xBBu);\n\tKUNIT_ASSERT_EQ(test, larger_array[256], 0xBBu);\n\tKUNIT_ASSERT_NULL(test, memchr(larger_array + 1, 0xBBu, 256 - 1));\n\tKUNIT_ASSERT_NULL(test,\n\t\tmemchr(larger_array + 257, 0xBBu, ARRAY_SIZE(larger_array) - 257));\n#undef TEST_OP\n}\n\nstatic void memset_test(struct kunit *test)\n{\n#define TEST_OP \"memset\"\n\tstruct some_bytes control = {\n\t\t.data = { 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30,\n\t\t\t  0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30,\n\t\t\t  0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30,\n\t\t\t  0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30,\n\t\t\t},\n\t};\n\tstruct some_bytes complete = {\n\t\t.data = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t\t\t  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t\t\t  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t\t\t  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t\t\t},\n\t};\n\tstruct some_bytes middle = {\n\t\t.data = { 0x30, 0x30, 0x30, 0x30, 0x31, 0x31, 0x31, 0x31,\n\t\t\t  0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31,\n\t\t\t  0x31, 0x31, 0x31, 0x31, 0x30, 0x30, 0x30, 0x30,\n\t\t\t  0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30,\n\t\t\t},\n\t};\n\tstruct some_bytes three = {\n\t\t.data = { 0x60, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30,\n\t\t\t  0x30, 0x61, 0x61, 0x30, 0x30, 0x30, 0x30, 0x30,\n\t\t\t  0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30,\n\t\t\t  0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30,\n\t\t\t},\n\t};\n\tstruct some_bytes after = {\n\t\t.data = { 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x72,\n\t\t\t  0x72, 0x72, 0x72, 0x72, 0x72, 0x72, 0x72, 0x72,\n\t\t\t  0x72, 0x72, 0x72, 0x72, 0x72, 0x72, 0x72, 0x72,\n\t\t\t  0x72, 0x72, 0x72, 0x72, 0x72, 0x72, 0x72, 0x72,\n\t\t\t},\n\t};\n\tstruct some_bytes startat = {\n\t\t.data = { 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30,\n\t\t\t  0x79, 0x79, 0x79, 0x79, 0x79, 0x79, 0x79, 0x79,\n\t\t\t  0x79, 0x79, 0x79, 0x79, 0x79, 0x79, 0x79, 0x79,\n\t\t\t  0x79, 0x79, 0x79, 0x79, 0x79, 0x79, 0x79, 0x79,\n\t\t\t},\n\t};\n\tstruct some_bytes dest = { };\n\tint count, value;\n\tu8 *ptr;\n\n\t \n\tcheck(control, 0x30);\n\tcheck(dest, 0);\n\n\t \n\tdest = control;\n\tcompare(\"direct assignment\", dest, control);\n\n\t \n\tmemset(dest.data, 0xff, sizeof(dest.data));\n\tcompare(\"complete overwrite\", dest, complete);\n\n\t \n\tdest = control;\n\tmemset(dest.data + 4, 0x31, 16);\n\tcompare(\"middle overwrite\", dest, middle);\n\n\t \n\tdest = control;\n\tptr = dest.data;\n\tvalue = 0x60;\n\tcount = 1;\n\tmemset(ptr++, value++, count++);\n\tptr += 8;\n\tmemset(ptr++, value++, count++);\n\tcompare(\"argument side-effects\", dest, three);\n\n\t \n\tdest = control;\n\tmemset_after(&dest, 0x72, three);\n\tcompare(\"memset_after()\", dest, after);\n\n\t \n\tdest = control;\n\tmemset_startat(&dest, 0x79, four);\n\tcompare(\"memset_startat()\", dest, startat);\n#undef TEST_OP\n}\n\nstatic u8 large_src[1024];\nstatic u8 large_dst[2048];\nstatic const u8 large_zero[2048];\n\nstatic void set_random_nonzero(struct kunit *test, u8 *byte)\n{\n\tint failed_rng = 0;\n\n\twhile (*byte == 0) {\n\t\tget_random_bytes(byte, 1);\n\t\tKUNIT_ASSERT_LT_MSG(test, failed_rng++, 100,\n\t\t\t\t    \"Is the RNG broken?\");\n\t}\n}\n\nstatic void init_large(struct kunit *test)\n{\n\tif (!IS_ENABLED(CONFIG_MEMCPY_SLOW_KUNIT_TEST))\n\t\tkunit_skip(test, \"Slow test skipped. Enable with CONFIG_MEMCPY_SLOW_KUNIT_TEST=y\");\n\n\t \n\tget_random_bytes(large_src, ARRAY_SIZE(large_src));\n\n\t \n\tset_random_nonzero(test, &large_src[0]);\n\tset_random_nonzero(test, &large_src[ARRAY_SIZE(large_src) - 1]);\n\n\t \n\tmemset(large_dst, 0, ARRAY_SIZE(large_dst));\n}\n\n \nstatic void copy_large_test(struct kunit *test, bool use_memmove)\n{\n\tinit_large(test);\n\n\t \n\tfor (int bytes = 1; bytes <= ARRAY_SIZE(large_src); bytes++) {\n\t\t \n\t\tfor (int offset = 0; offset < ARRAY_SIZE(large_src); offset++) {\n\t\t\tint right_zero_pos = offset + bytes;\n\t\t\tint right_zero_size = ARRAY_SIZE(large_dst) - right_zero_pos;\n\n\t\t\t \n\t\t\tif (use_memmove)\n\t\t\t\tmemmove(large_dst + offset, large_src, bytes);\n\t\t\telse\n\t\t\t\tmemcpy(large_dst + offset, large_src, bytes);\n\n\t\t\t \n\t\t\tKUNIT_ASSERT_EQ_MSG(test,\n\t\t\t\tmemcmp(large_dst, large_zero, offset), 0,\n\t\t\t\t\"with size %d at offset %d\", bytes, offset);\n\t\t\t \n\t\t\tKUNIT_ASSERT_EQ_MSG(test,\n\t\t\t\tmemcmp(&large_dst[right_zero_pos], large_zero, right_zero_size), 0,\n\t\t\t\t\"with size %d at offset %d\", bytes, offset);\n\n\t\t\t \n\t\t\tKUNIT_ASSERT_EQ_MSG(test,\n\t\t\t\tmemcmp(large_dst + offset, large_src, bytes), 0,\n\t\t\t\t\"with size %d at offset %d\", bytes, offset);\n\n\t\t\t \n\t\t\tmemset(large_dst + offset, 0, bytes);\n\t\t}\n\t\t \n\t\tcond_resched();\n\t}\n}\n\nstatic void memcpy_large_test(struct kunit *test)\n{\n\tcopy_large_test(test, false);\n}\n\nstatic void memmove_large_test(struct kunit *test)\n{\n\tcopy_large_test(test, true);\n}\n\n \nstatic int next_step(int idx, int start, int end, int inc)\n{\n\tstart += inc;\n\tend -= inc;\n\n\tif (idx < start || idx + inc > end)\n\t\tinc = 1;\n\treturn idx + inc;\n}\n\nstatic void inner_loop(struct kunit *test, int bytes, int d_off, int s_off)\n{\n\tint left_zero_pos, left_zero_size;\n\tint right_zero_pos, right_zero_size;\n\tint src_pos, src_orig_pos, src_size;\n\tint pos;\n\n\t \n\tmemcpy(&large_dst[s_off], large_src, bytes);\n\n\t \n\tmemmove(&large_dst[d_off], &large_dst[s_off], bytes);\n\n\t \n\tKUNIT_ASSERT_EQ_MSG(test, memcmp(&large_dst[d_off], large_src, bytes), 0,\n\t\t\"with size %d at src offset %d and dest offset %d\",\n\t\tbytes, s_off, d_off);\n\n\t \n\tif (s_off < d_off) {\n\t\tleft_zero_pos = 0;\n\t\tleft_zero_size = s_off;\n\n\t\tright_zero_pos = d_off + bytes;\n\t\tright_zero_size = ARRAY_SIZE(large_dst) - right_zero_pos;\n\n\t\tsrc_pos = s_off;\n\t\tsrc_orig_pos = 0;\n\t\tsrc_size = d_off - s_off;\n\t} else {\n\t\tleft_zero_pos = 0;\n\t\tleft_zero_size = d_off;\n\n\t\tright_zero_pos = s_off + bytes;\n\t\tright_zero_size = ARRAY_SIZE(large_dst) - right_zero_pos;\n\n\t\tsrc_pos = d_off + bytes;\n\t\tsrc_orig_pos = src_pos - s_off;\n\t\tsrc_size = right_zero_pos - src_pos;\n\t}\n\n\t \n\tKUNIT_ASSERT_EQ_MSG(test,\n\t\tmemcmp(&large_dst[src_pos], &large_src[src_orig_pos], src_size), 0,\n\t\t\"with size %d at src offset %d and dest offset %d\",\n\t\tbytes, s_off, d_off);\n\n\t \n\tKUNIT_ASSERT_EQ_MSG(test,\n\t\tmemcmp(&large_dst[left_zero_pos], large_zero, left_zero_size), 0,\n\t\t\"with size %d at src offset %d and dest offset %d\",\n\t\tbytes, s_off, d_off);\n\t \n\tKUNIT_ASSERT_EQ_MSG(test,\n\t\tmemcmp(&large_dst[right_zero_pos], large_zero, right_zero_size), 0,\n\t\t\"with size %d at src offset %d and dest offset %d\",\n\t\tbytes, s_off, d_off);\n\n\t \n\tpos = left_zero_pos + left_zero_size;\n\tmemset(&large_dst[pos], 0, right_zero_pos - pos);\n}\n\nstatic void memmove_overlap_test(struct kunit *test)\n{\n\t \n\tstatic const int offset_max = 128;  \n\tstatic const int bytes_step = 7;\n\tstatic const int window_step = 7;\n\n\tstatic const int bytes_start = 1;\n\tstatic const int bytes_end = ARRAY_SIZE(large_src) + 1;\n\n\tinit_large(test);\n\n\t \n\tfor (int bytes = bytes_start; bytes < bytes_end;\n\t     bytes = next_step(bytes, bytes_start, bytes_end, bytes_step)) {\n\n\t\t \n\t\tfor (int d_off = 0; d_off < offset_max; d_off++) {\n\t\t\tint s_start = max(d_off - bytes, 0);\n\t\t\tint s_end = min_t(int, d_off + bytes, ARRAY_SIZE(large_src));\n\n\t\t\t \n\t\t\tfor (int s_off = s_start; s_off < s_end;\n\t\t\t     s_off = next_step(s_off, s_start, s_end, window_step))\n\t\t\t\tinner_loop(test, bytes, d_off, s_off);\n\n\t\t\t \n\t\t\tcond_resched();\n\t\t}\n\t}\n}\n\nstatic void strtomem_test(struct kunit *test)\n{\n\tstatic const char input[sizeof(unsigned long)] = \"hi\";\n\tstatic const char truncate[] = \"this is too long\";\n\tstruct {\n\t\tunsigned long canary1;\n\t\tunsigned char output[sizeof(unsigned long)] __nonstring;\n\t\tunsigned long canary2;\n\t} wrap;\n\n\tmemset(&wrap, 0xFF, sizeof(wrap));\n\tKUNIT_EXPECT_EQ_MSG(test, wrap.canary1, ULONG_MAX,\n\t\t\t    \"bad initial canary value\");\n\tKUNIT_EXPECT_EQ_MSG(test, wrap.canary2, ULONG_MAX,\n\t\t\t    \"bad initial canary value\");\n\n\t \n\tstrtomem(wrap.output, input);\n\tKUNIT_EXPECT_EQ(test, wrap.canary1, ULONG_MAX);\n\tKUNIT_EXPECT_EQ(test, wrap.output[0], input[0]);\n\tKUNIT_EXPECT_EQ(test, wrap.output[1], input[1]);\n\tfor (size_t i = 2; i < sizeof(wrap.output); i++)\n\t\tKUNIT_EXPECT_EQ(test, wrap.output[i], 0xFF);\n\tKUNIT_EXPECT_EQ(test, wrap.canary2, ULONG_MAX);\n\n\t \n\tmemset(&wrap, 0xFF, sizeof(wrap));\n\tstrtomem(wrap.output, truncate);\n\tKUNIT_EXPECT_EQ(test, wrap.canary1, ULONG_MAX);\n\tfor (size_t i = 0; i < sizeof(wrap.output); i++)\n\t\tKUNIT_EXPECT_EQ(test, wrap.output[i], truncate[i]);\n\tKUNIT_EXPECT_EQ(test, wrap.canary2, ULONG_MAX);\n\n\t \n\tmemset(&wrap, 0xFF, sizeof(wrap));\n\tstrtomem_pad(wrap.output, input, 0xAA);\n\tKUNIT_EXPECT_EQ(test, wrap.canary1, ULONG_MAX);\n\tKUNIT_EXPECT_EQ(test, wrap.output[0], input[0]);\n\tKUNIT_EXPECT_EQ(test, wrap.output[1], input[1]);\n\tfor (size_t i = 2; i < sizeof(wrap.output); i++)\n\t\tKUNIT_EXPECT_EQ(test, wrap.output[i], 0xAA);\n\tKUNIT_EXPECT_EQ(test, wrap.canary2, ULONG_MAX);\n\n\t \n\tmemset(&wrap, 0xFF, sizeof(wrap));\n\tstrtomem(wrap.output, truncate);\n\tKUNIT_EXPECT_EQ(test, wrap.canary1, ULONG_MAX);\n\tfor (size_t i = 0; i < sizeof(wrap.output); i++)\n\t\tKUNIT_EXPECT_EQ(test, wrap.output[i], truncate[i]);\n\tKUNIT_EXPECT_EQ(test, wrap.canary2, ULONG_MAX);\n}\n\nstatic struct kunit_case memcpy_test_cases[] = {\n\tKUNIT_CASE(memset_test),\n\tKUNIT_CASE(memcpy_test),\n\tKUNIT_CASE_SLOW(memcpy_large_test),\n\tKUNIT_CASE_SLOW(memmove_test),\n\tKUNIT_CASE_SLOW(memmove_large_test),\n\tKUNIT_CASE_SLOW(memmove_overlap_test),\n\tKUNIT_CASE(strtomem_test),\n\t{}\n};\n\nstatic struct kunit_suite memcpy_test_suite = {\n\t.name = \"memcpy\",\n\t.test_cases = memcpy_test_cases,\n};\n\nkunit_test_suite(memcpy_test_suite);\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}