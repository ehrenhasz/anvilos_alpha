{
  "module_name": "string.c",
  "hash_id": "b8d339b2031074c41041694aa9376346f46f50fc1f1b87d7a8f0de6037535b53",
  "original_prompt": "Ingested from linux-6.6.14/lib/string.c",
  "human_readable_source": "\n \n\n \n\n#define __NO_FORTIFY\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/bug.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n\n#include <asm/unaligned.h>\n#include <asm/byteorder.h>\n#include <asm/word-at-a-time.h>\n#include <asm/page.h>\n\n#ifndef __HAVE_ARCH_STRNCASECMP\n \nint strncasecmp(const char *s1, const char *s2, size_t len)\n{\n\t \n\tunsigned char c1, c2;\n\n\tif (!len)\n\t\treturn 0;\n\n\tdo {\n\t\tc1 = *s1++;\n\t\tc2 = *s2++;\n\t\tif (!c1 || !c2)\n\t\t\tbreak;\n\t\tif (c1 == c2)\n\t\t\tcontinue;\n\t\tc1 = tolower(c1);\n\t\tc2 = tolower(c2);\n\t\tif (c1 != c2)\n\t\t\tbreak;\n\t} while (--len);\n\treturn (int)c1 - (int)c2;\n}\nEXPORT_SYMBOL(strncasecmp);\n#endif\n\n#ifndef __HAVE_ARCH_STRCASECMP\nint strcasecmp(const char *s1, const char *s2)\n{\n\tint c1, c2;\n\n\tdo {\n\t\tc1 = tolower(*s1++);\n\t\tc2 = tolower(*s2++);\n\t} while (c1 == c2 && c1 != 0);\n\treturn c1 - c2;\n}\nEXPORT_SYMBOL(strcasecmp);\n#endif\n\n#ifndef __HAVE_ARCH_STRCPY\nchar *strcpy(char *dest, const char *src)\n{\n\tchar *tmp = dest;\n\n\twhile ((*dest++ = *src++) != '\\0')\n\t\t ;\n\treturn tmp;\n}\nEXPORT_SYMBOL(strcpy);\n#endif\n\n#ifndef __HAVE_ARCH_STRNCPY\nchar *strncpy(char *dest, const char *src, size_t count)\n{\n\tchar *tmp = dest;\n\n\twhile (count) {\n\t\tif ((*tmp = *src) != 0)\n\t\t\tsrc++;\n\t\ttmp++;\n\t\tcount--;\n\t}\n\treturn dest;\n}\nEXPORT_SYMBOL(strncpy);\n#endif\n\n#ifndef __HAVE_ARCH_STRLCPY\nsize_t strlcpy(char *dest, const char *src, size_t size)\n{\n\tsize_t ret = strlen(src);\n\n\tif (size) {\n\t\tsize_t len = (ret >= size) ? size - 1 : ret;\n\t\t__builtin_memcpy(dest, src, len);\n\t\tdest[len] = '\\0';\n\t}\n\treturn ret;\n}\nEXPORT_SYMBOL(strlcpy);\n#endif\n\n#ifndef __HAVE_ARCH_STRSCPY\nssize_t strscpy(char *dest, const char *src, size_t count)\n{\n\tconst struct word_at_a_time constants = WORD_AT_A_TIME_CONSTANTS;\n\tsize_t max = count;\n\tlong res = 0;\n\n\tif (count == 0 || WARN_ON_ONCE(count > INT_MAX))\n\t\treturn -E2BIG;\n\n#ifdef CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS\n\t \n\tif ((long)src & (sizeof(long) - 1)) {\n\t\tsize_t limit = PAGE_SIZE - ((long)src & (PAGE_SIZE - 1));\n\t\tif (limit < max)\n\t\t\tmax = limit;\n\t}\n#else\n\t \n\tif (((long) dest | (long) src) & (sizeof(long) - 1))\n\t\tmax = 0;\n#endif\n\n\t \n\tif (IS_ENABLED(CONFIG_KMSAN))\n\t\tmax = 0;\n\n\twhile (max >= sizeof(unsigned long)) {\n\t\tunsigned long c, data;\n\n\t\tc = read_word_at_a_time(src+res);\n\t\tif (has_zero(c, &data, &constants)) {\n\t\t\tdata = prep_zero_mask(c, data, &constants);\n\t\t\tdata = create_zero_mask(data);\n\t\t\t*(unsigned long *)(dest+res) = c & zero_bytemask(data);\n\t\t\treturn res + find_zero(data);\n\t\t}\n\t\t*(unsigned long *)(dest+res) = c;\n\t\tres += sizeof(unsigned long);\n\t\tcount -= sizeof(unsigned long);\n\t\tmax -= sizeof(unsigned long);\n\t}\n\n\twhile (count) {\n\t\tchar c;\n\n\t\tc = src[res];\n\t\tdest[res] = c;\n\t\tif (!c)\n\t\t\treturn res;\n\t\tres++;\n\t\tcount--;\n\t}\n\n\t \n\tif (res)\n\t\tdest[res-1] = '\\0';\n\n\treturn -E2BIG;\n}\nEXPORT_SYMBOL(strscpy);\n#endif\n\n \nchar *stpcpy(char *__restrict__ dest, const char *__restrict__ src);\nchar *stpcpy(char *__restrict__ dest, const char *__restrict__ src)\n{\n\twhile ((*dest++ = *src++) != '\\0')\n\t\t ;\n\treturn --dest;\n}\nEXPORT_SYMBOL(stpcpy);\n\n#ifndef __HAVE_ARCH_STRCAT\nchar *strcat(char *dest, const char *src)\n{\n\tchar *tmp = dest;\n\n\twhile (*dest)\n\t\tdest++;\n\twhile ((*dest++ = *src++) != '\\0')\n\t\t;\n\treturn tmp;\n}\nEXPORT_SYMBOL(strcat);\n#endif\n\n#ifndef __HAVE_ARCH_STRNCAT\nchar *strncat(char *dest, const char *src, size_t count)\n{\n\tchar *tmp = dest;\n\n\tif (count) {\n\t\twhile (*dest)\n\t\t\tdest++;\n\t\twhile ((*dest++ = *src++) != 0) {\n\t\t\tif (--count == 0) {\n\t\t\t\t*dest = '\\0';\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn tmp;\n}\nEXPORT_SYMBOL(strncat);\n#endif\n\n#ifndef __HAVE_ARCH_STRLCAT\nsize_t strlcat(char *dest, const char *src, size_t count)\n{\n\tsize_t dsize = strlen(dest);\n\tsize_t len = strlen(src);\n\tsize_t res = dsize + len;\n\n\t \n\tBUG_ON(dsize >= count);\n\n\tdest += dsize;\n\tcount -= dsize;\n\tif (len >= count)\n\t\tlen = count-1;\n\t__builtin_memcpy(dest, src, len);\n\tdest[len] = 0;\n\treturn res;\n}\nEXPORT_SYMBOL(strlcat);\n#endif\n\n#ifndef __HAVE_ARCH_STRCMP\n \nint strcmp(const char *cs, const char *ct)\n{\n\tunsigned char c1, c2;\n\n\twhile (1) {\n\t\tc1 = *cs++;\n\t\tc2 = *ct++;\n\t\tif (c1 != c2)\n\t\t\treturn c1 < c2 ? -1 : 1;\n\t\tif (!c1)\n\t\t\tbreak;\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL(strcmp);\n#endif\n\n#ifndef __HAVE_ARCH_STRNCMP\n \nint strncmp(const char *cs, const char *ct, size_t count)\n{\n\tunsigned char c1, c2;\n\n\twhile (count) {\n\t\tc1 = *cs++;\n\t\tc2 = *ct++;\n\t\tif (c1 != c2)\n\t\t\treturn c1 < c2 ? -1 : 1;\n\t\tif (!c1)\n\t\t\tbreak;\n\t\tcount--;\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL(strncmp);\n#endif\n\n#ifndef __HAVE_ARCH_STRCHR\n \nchar *strchr(const char *s, int c)\n{\n\tfor (; *s != (char)c; ++s)\n\t\tif (*s == '\\0')\n\t\t\treturn NULL;\n\treturn (char *)s;\n}\nEXPORT_SYMBOL(strchr);\n#endif\n\n#ifndef __HAVE_ARCH_STRCHRNUL\n \nchar *strchrnul(const char *s, int c)\n{\n\twhile (*s && *s != (char)c)\n\t\ts++;\n\treturn (char *)s;\n}\nEXPORT_SYMBOL(strchrnul);\n#endif\n\n \nchar *strnchrnul(const char *s, size_t count, int c)\n{\n\twhile (count-- && *s && *s != (char)c)\n\t\ts++;\n\treturn (char *)s;\n}\n\n#ifndef __HAVE_ARCH_STRRCHR\n \nchar *strrchr(const char *s, int c)\n{\n\tconst char *last = NULL;\n\tdo {\n\t\tif (*s == (char)c)\n\t\t\tlast = s;\n\t} while (*s++);\n\treturn (char *)last;\n}\nEXPORT_SYMBOL(strrchr);\n#endif\n\n#ifndef __HAVE_ARCH_STRNCHR\n \nchar *strnchr(const char *s, size_t count, int c)\n{\n\twhile (count--) {\n\t\tif (*s == (char)c)\n\t\t\treturn (char *)s;\n\t\tif (*s++ == '\\0')\n\t\t\tbreak;\n\t}\n\treturn NULL;\n}\nEXPORT_SYMBOL(strnchr);\n#endif\n\n#ifndef __HAVE_ARCH_STRLEN\nsize_t strlen(const char *s)\n{\n\tconst char *sc;\n\n\tfor (sc = s; *sc != '\\0'; ++sc)\n\t\t ;\n\treturn sc - s;\n}\nEXPORT_SYMBOL(strlen);\n#endif\n\n#ifndef __HAVE_ARCH_STRNLEN\nsize_t strnlen(const char *s, size_t count)\n{\n\tconst char *sc;\n\n\tfor (sc = s; count-- && *sc != '\\0'; ++sc)\n\t\t ;\n\treturn sc - s;\n}\nEXPORT_SYMBOL(strnlen);\n#endif\n\n#ifndef __HAVE_ARCH_STRSPN\n \nsize_t strspn(const char *s, const char *accept)\n{\n\tconst char *p;\n\n\tfor (p = s; *p != '\\0'; ++p) {\n\t\tif (!strchr(accept, *p))\n\t\t\tbreak;\n\t}\n\treturn p - s;\n}\nEXPORT_SYMBOL(strspn);\n#endif\n\n#ifndef __HAVE_ARCH_STRCSPN\n \nsize_t strcspn(const char *s, const char *reject)\n{\n\tconst char *p;\n\n\tfor (p = s; *p != '\\0'; ++p) {\n\t\tif (strchr(reject, *p))\n\t\t\tbreak;\n\t}\n\treturn p - s;\n}\nEXPORT_SYMBOL(strcspn);\n#endif\n\n#ifndef __HAVE_ARCH_STRPBRK\n \nchar *strpbrk(const char *cs, const char *ct)\n{\n\tconst char *sc;\n\n\tfor (sc = cs; *sc != '\\0'; ++sc) {\n\t\tif (strchr(ct, *sc))\n\t\t\treturn (char *)sc;\n\t}\n\treturn NULL;\n}\nEXPORT_SYMBOL(strpbrk);\n#endif\n\n#ifndef __HAVE_ARCH_STRSEP\n \nchar *strsep(char **s, const char *ct)\n{\n\tchar *sbegin = *s;\n\tchar *end;\n\n\tif (sbegin == NULL)\n\t\treturn NULL;\n\n\tend = strpbrk(sbegin, ct);\n\tif (end)\n\t\t*end++ = '\\0';\n\t*s = end;\n\treturn sbegin;\n}\nEXPORT_SYMBOL(strsep);\n#endif\n\n#ifndef __HAVE_ARCH_MEMSET\n \nvoid *memset(void *s, int c, size_t count)\n{\n\tchar *xs = s;\n\n\twhile (count--)\n\t\t*xs++ = c;\n\treturn s;\n}\nEXPORT_SYMBOL(memset);\n#endif\n\n#ifndef __HAVE_ARCH_MEMSET16\n \nvoid *memset16(uint16_t *s, uint16_t v, size_t count)\n{\n\tuint16_t *xs = s;\n\n\twhile (count--)\n\t\t*xs++ = v;\n\treturn s;\n}\nEXPORT_SYMBOL(memset16);\n#endif\n\n#ifndef __HAVE_ARCH_MEMSET32\n \nvoid *memset32(uint32_t *s, uint32_t v, size_t count)\n{\n\tuint32_t *xs = s;\n\n\twhile (count--)\n\t\t*xs++ = v;\n\treturn s;\n}\nEXPORT_SYMBOL(memset32);\n#endif\n\n#ifndef __HAVE_ARCH_MEMSET64\n \nvoid *memset64(uint64_t *s, uint64_t v, size_t count)\n{\n\tuint64_t *xs = s;\n\n\twhile (count--)\n\t\t*xs++ = v;\n\treturn s;\n}\nEXPORT_SYMBOL(memset64);\n#endif\n\n#ifndef __HAVE_ARCH_MEMCPY\n \nvoid *memcpy(void *dest, const void *src, size_t count)\n{\n\tchar *tmp = dest;\n\tconst char *s = src;\n\n\twhile (count--)\n\t\t*tmp++ = *s++;\n\treturn dest;\n}\nEXPORT_SYMBOL(memcpy);\n#endif\n\n#ifndef __HAVE_ARCH_MEMMOVE\n \nvoid *memmove(void *dest, const void *src, size_t count)\n{\n\tchar *tmp;\n\tconst char *s;\n\n\tif (dest <= src) {\n\t\ttmp = dest;\n\t\ts = src;\n\t\twhile (count--)\n\t\t\t*tmp++ = *s++;\n\t} else {\n\t\ttmp = dest;\n\t\ttmp += count;\n\t\ts = src;\n\t\ts += count;\n\t\twhile (count--)\n\t\t\t*--tmp = *--s;\n\t}\n\treturn dest;\n}\nEXPORT_SYMBOL(memmove);\n#endif\n\n#ifndef __HAVE_ARCH_MEMCMP\n \n#undef memcmp\n__visible int memcmp(const void *cs, const void *ct, size_t count)\n{\n\tconst unsigned char *su1, *su2;\n\tint res = 0;\n\n#ifdef CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS\n\tif (count >= sizeof(unsigned long)) {\n\t\tconst unsigned long *u1 = cs;\n\t\tconst unsigned long *u2 = ct;\n\t\tdo {\n\t\t\tif (get_unaligned(u1) != get_unaligned(u2))\n\t\t\t\tbreak;\n\t\t\tu1++;\n\t\t\tu2++;\n\t\t\tcount -= sizeof(unsigned long);\n\t\t} while (count >= sizeof(unsigned long));\n\t\tcs = u1;\n\t\tct = u2;\n\t}\n#endif\n\tfor (su1 = cs, su2 = ct; 0 < count; ++su1, ++su2, count--)\n\t\tif ((res = *su1 - *su2) != 0)\n\t\t\tbreak;\n\treturn res;\n}\nEXPORT_SYMBOL(memcmp);\n#endif\n\n#ifndef __HAVE_ARCH_BCMP\n \nint bcmp(const void *a, const void *b, size_t len)\n{\n\treturn memcmp(a, b, len);\n}\nEXPORT_SYMBOL(bcmp);\n#endif\n\n#ifndef __HAVE_ARCH_MEMSCAN\n \nvoid *memscan(void *addr, int c, size_t size)\n{\n\tunsigned char *p = addr;\n\n\twhile (size) {\n\t\tif (*p == (unsigned char)c)\n\t\t\treturn (void *)p;\n\t\tp++;\n\t\tsize--;\n\t}\n  \treturn (void *)p;\n}\nEXPORT_SYMBOL(memscan);\n#endif\n\n#ifndef __HAVE_ARCH_STRSTR\n \nchar *strstr(const char *s1, const char *s2)\n{\n\tsize_t l1, l2;\n\n\tl2 = strlen(s2);\n\tif (!l2)\n\t\treturn (char *)s1;\n\tl1 = strlen(s1);\n\twhile (l1 >= l2) {\n\t\tl1--;\n\t\tif (!memcmp(s1, s2, l2))\n\t\t\treturn (char *)s1;\n\t\ts1++;\n\t}\n\treturn NULL;\n}\nEXPORT_SYMBOL(strstr);\n#endif\n\n#ifndef __HAVE_ARCH_STRNSTR\n \nchar *strnstr(const char *s1, const char *s2, size_t len)\n{\n\tsize_t l2;\n\n\tl2 = strlen(s2);\n\tif (!l2)\n\t\treturn (char *)s1;\n\twhile (len >= l2) {\n\t\tlen--;\n\t\tif (!memcmp(s1, s2, l2))\n\t\t\treturn (char *)s1;\n\t\ts1++;\n\t}\n\treturn NULL;\n}\nEXPORT_SYMBOL(strnstr);\n#endif\n\n#ifndef __HAVE_ARCH_MEMCHR\n \nvoid *memchr(const void *s, int c, size_t n)\n{\n\tconst unsigned char *p = s;\n\twhile (n-- != 0) {\n        \tif ((unsigned char)c == *p++) {\n\t\t\treturn (void *)(p - 1);\n\t\t}\n\t}\n\treturn NULL;\n}\nEXPORT_SYMBOL(memchr);\n#endif\n\nstatic void *check_bytes8(const u8 *start, u8 value, unsigned int bytes)\n{\n\twhile (bytes) {\n\t\tif (*start != value)\n\t\t\treturn (void *)start;\n\t\tstart++;\n\t\tbytes--;\n\t}\n\treturn NULL;\n}\n\n \nvoid *memchr_inv(const void *start, int c, size_t bytes)\n{\n\tu8 value = c;\n\tu64 value64;\n\tunsigned int words, prefix;\n\n\tif (bytes <= 16)\n\t\treturn check_bytes8(start, value, bytes);\n\n\tvalue64 = value;\n#if defined(CONFIG_ARCH_HAS_FAST_MULTIPLIER) && BITS_PER_LONG == 64\n\tvalue64 *= 0x0101010101010101ULL;\n#elif defined(CONFIG_ARCH_HAS_FAST_MULTIPLIER)\n\tvalue64 *= 0x01010101;\n\tvalue64 |= value64 << 32;\n#else\n\tvalue64 |= value64 << 8;\n\tvalue64 |= value64 << 16;\n\tvalue64 |= value64 << 32;\n#endif\n\n\tprefix = (unsigned long)start % 8;\n\tif (prefix) {\n\t\tu8 *r;\n\n\t\tprefix = 8 - prefix;\n\t\tr = check_bytes8(start, value, prefix);\n\t\tif (r)\n\t\t\treturn r;\n\t\tstart += prefix;\n\t\tbytes -= prefix;\n\t}\n\n\twords = bytes / 8;\n\n\twhile (words) {\n\t\tif (*(u64 *)start != value64)\n\t\t\treturn check_bytes8(start, value, 8);\n\t\tstart += 8;\n\t\twords--;\n\t}\n\n\treturn check_bytes8(start, value, bytes % 8);\n}\nEXPORT_SYMBOL(memchr_inv);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}