{
  "module_name": "bitmap.c",
  "hash_id": "571555fe19b102bd0bf7195c4abb60f27ae59b51b9daab755ea4a6e7790a6446",
  "original_prompt": "Ingested from linux-6.6.14/lib/bitmap.c",
  "human_readable_source": "\n \n\n#include <linux/bitmap.h>\n#include <linux/bitops.h>\n#include <linux/bug.h>\n#include <linux/ctype.h>\n#include <linux/device.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/thread_info.h>\n#include <linux/uaccess.h>\n\n#include <asm/page.h>\n\n#include \"kstrtox.h\"\n\n \n\nbool __bitmap_equal(const unsigned long *bitmap1,\n\t\t    const unsigned long *bitmap2, unsigned int bits)\n{\n\tunsigned int k, lim = bits/BITS_PER_LONG;\n\tfor (k = 0; k < lim; ++k)\n\t\tif (bitmap1[k] != bitmap2[k])\n\t\t\treturn false;\n\n\tif (bits % BITS_PER_LONG)\n\t\tif ((bitmap1[k] ^ bitmap2[k]) & BITMAP_LAST_WORD_MASK(bits))\n\t\t\treturn false;\n\n\treturn true;\n}\nEXPORT_SYMBOL(__bitmap_equal);\n\nbool __bitmap_or_equal(const unsigned long *bitmap1,\n\t\t       const unsigned long *bitmap2,\n\t\t       const unsigned long *bitmap3,\n\t\t       unsigned int bits)\n{\n\tunsigned int k, lim = bits / BITS_PER_LONG;\n\tunsigned long tmp;\n\n\tfor (k = 0; k < lim; ++k) {\n\t\tif ((bitmap1[k] | bitmap2[k]) != bitmap3[k])\n\t\t\treturn false;\n\t}\n\n\tif (!(bits % BITS_PER_LONG))\n\t\treturn true;\n\n\ttmp = (bitmap1[k] | bitmap2[k]) ^ bitmap3[k];\n\treturn (tmp & BITMAP_LAST_WORD_MASK(bits)) == 0;\n}\n\nvoid __bitmap_complement(unsigned long *dst, const unsigned long *src, unsigned int bits)\n{\n\tunsigned int k, lim = BITS_TO_LONGS(bits);\n\tfor (k = 0; k < lim; ++k)\n\t\tdst[k] = ~src[k];\n}\nEXPORT_SYMBOL(__bitmap_complement);\n\n \nvoid __bitmap_shift_right(unsigned long *dst, const unsigned long *src,\n\t\t\tunsigned shift, unsigned nbits)\n{\n\tunsigned k, lim = BITS_TO_LONGS(nbits);\n\tunsigned off = shift/BITS_PER_LONG, rem = shift % BITS_PER_LONG;\n\tunsigned long mask = BITMAP_LAST_WORD_MASK(nbits);\n\tfor (k = 0; off + k < lim; ++k) {\n\t\tunsigned long upper, lower;\n\n\t\t \n\t\tif (!rem || off + k + 1 >= lim)\n\t\t\tupper = 0;\n\t\telse {\n\t\t\tupper = src[off + k + 1];\n\t\t\tif (off + k + 1 == lim - 1)\n\t\t\t\tupper &= mask;\n\t\t\tupper <<= (BITS_PER_LONG - rem);\n\t\t}\n\t\tlower = src[off + k];\n\t\tif (off + k == lim - 1)\n\t\t\tlower &= mask;\n\t\tlower >>= rem;\n\t\tdst[k] = lower | upper;\n\t}\n\tif (off)\n\t\tmemset(&dst[lim - off], 0, off*sizeof(unsigned long));\n}\nEXPORT_SYMBOL(__bitmap_shift_right);\n\n\n \n\nvoid __bitmap_shift_left(unsigned long *dst, const unsigned long *src,\n\t\t\tunsigned int shift, unsigned int nbits)\n{\n\tint k;\n\tunsigned int lim = BITS_TO_LONGS(nbits);\n\tunsigned int off = shift/BITS_PER_LONG, rem = shift % BITS_PER_LONG;\n\tfor (k = lim - off - 1; k >= 0; --k) {\n\t\tunsigned long upper, lower;\n\n\t\t \n\t\tif (rem && k > 0)\n\t\t\tlower = src[k - 1] >> (BITS_PER_LONG - rem);\n\t\telse\n\t\t\tlower = 0;\n\t\tupper = src[k] << rem;\n\t\tdst[k + off] = lower | upper;\n\t}\n\tif (off)\n\t\tmemset(dst, 0, off*sizeof(unsigned long));\n}\nEXPORT_SYMBOL(__bitmap_shift_left);\n\n \nvoid bitmap_cut(unsigned long *dst, const unsigned long *src,\n\t\tunsigned int first, unsigned int cut, unsigned int nbits)\n{\n\tunsigned int len = BITS_TO_LONGS(nbits);\n\tunsigned long keep = 0, carry;\n\tint i;\n\n\tif (first % BITS_PER_LONG) {\n\t\tkeep = src[first / BITS_PER_LONG] &\n\t\t       (~0UL >> (BITS_PER_LONG - first % BITS_PER_LONG));\n\t}\n\n\tmemmove(dst, src, len * sizeof(*dst));\n\n\twhile (cut--) {\n\t\tfor (i = first / BITS_PER_LONG; i < len; i++) {\n\t\t\tif (i < len - 1)\n\t\t\t\tcarry = dst[i + 1] & 1UL;\n\t\t\telse\n\t\t\t\tcarry = 0;\n\n\t\t\tdst[i] = (dst[i] >> 1) | (carry << (BITS_PER_LONG - 1));\n\t\t}\n\t}\n\n\tdst[first / BITS_PER_LONG] &= ~0UL << (first % BITS_PER_LONG);\n\tdst[first / BITS_PER_LONG] |= keep;\n}\nEXPORT_SYMBOL(bitmap_cut);\n\nbool __bitmap_and(unsigned long *dst, const unsigned long *bitmap1,\n\t\t\t\tconst unsigned long *bitmap2, unsigned int bits)\n{\n\tunsigned int k;\n\tunsigned int lim = bits/BITS_PER_LONG;\n\tunsigned long result = 0;\n\n\tfor (k = 0; k < lim; k++)\n\t\tresult |= (dst[k] = bitmap1[k] & bitmap2[k]);\n\tif (bits % BITS_PER_LONG)\n\t\tresult |= (dst[k] = bitmap1[k] & bitmap2[k] &\n\t\t\t   BITMAP_LAST_WORD_MASK(bits));\n\treturn result != 0;\n}\nEXPORT_SYMBOL(__bitmap_and);\n\nvoid __bitmap_or(unsigned long *dst, const unsigned long *bitmap1,\n\t\t\t\tconst unsigned long *bitmap2, unsigned int bits)\n{\n\tunsigned int k;\n\tunsigned int nr = BITS_TO_LONGS(bits);\n\n\tfor (k = 0; k < nr; k++)\n\t\tdst[k] = bitmap1[k] | bitmap2[k];\n}\nEXPORT_SYMBOL(__bitmap_or);\n\nvoid __bitmap_xor(unsigned long *dst, const unsigned long *bitmap1,\n\t\t\t\tconst unsigned long *bitmap2, unsigned int bits)\n{\n\tunsigned int k;\n\tunsigned int nr = BITS_TO_LONGS(bits);\n\n\tfor (k = 0; k < nr; k++)\n\t\tdst[k] = bitmap1[k] ^ bitmap2[k];\n}\nEXPORT_SYMBOL(__bitmap_xor);\n\nbool __bitmap_andnot(unsigned long *dst, const unsigned long *bitmap1,\n\t\t\t\tconst unsigned long *bitmap2, unsigned int bits)\n{\n\tunsigned int k;\n\tunsigned int lim = bits/BITS_PER_LONG;\n\tunsigned long result = 0;\n\n\tfor (k = 0; k < lim; k++)\n\t\tresult |= (dst[k] = bitmap1[k] & ~bitmap2[k]);\n\tif (bits % BITS_PER_LONG)\n\t\tresult |= (dst[k] = bitmap1[k] & ~bitmap2[k] &\n\t\t\t   BITMAP_LAST_WORD_MASK(bits));\n\treturn result != 0;\n}\nEXPORT_SYMBOL(__bitmap_andnot);\n\nvoid __bitmap_replace(unsigned long *dst,\n\t\t      const unsigned long *old, const unsigned long *new,\n\t\t      const unsigned long *mask, unsigned int nbits)\n{\n\tunsigned int k;\n\tunsigned int nr = BITS_TO_LONGS(nbits);\n\n\tfor (k = 0; k < nr; k++)\n\t\tdst[k] = (old[k] & ~mask[k]) | (new[k] & mask[k]);\n}\nEXPORT_SYMBOL(__bitmap_replace);\n\nbool __bitmap_intersects(const unsigned long *bitmap1,\n\t\t\t const unsigned long *bitmap2, unsigned int bits)\n{\n\tunsigned int k, lim = bits/BITS_PER_LONG;\n\tfor (k = 0; k < lim; ++k)\n\t\tif (bitmap1[k] & bitmap2[k])\n\t\t\treturn true;\n\n\tif (bits % BITS_PER_LONG)\n\t\tif ((bitmap1[k] & bitmap2[k]) & BITMAP_LAST_WORD_MASK(bits))\n\t\t\treturn true;\n\treturn false;\n}\nEXPORT_SYMBOL(__bitmap_intersects);\n\nbool __bitmap_subset(const unsigned long *bitmap1,\n\t\t     const unsigned long *bitmap2, unsigned int bits)\n{\n\tunsigned int k, lim = bits/BITS_PER_LONG;\n\tfor (k = 0; k < lim; ++k)\n\t\tif (bitmap1[k] & ~bitmap2[k])\n\t\t\treturn false;\n\n\tif (bits % BITS_PER_LONG)\n\t\tif ((bitmap1[k] & ~bitmap2[k]) & BITMAP_LAST_WORD_MASK(bits))\n\t\t\treturn false;\n\treturn true;\n}\nEXPORT_SYMBOL(__bitmap_subset);\n\n#define BITMAP_WEIGHT(FETCH, bits)\t\\\n({\t\t\t\t\t\t\t\t\t\t\\\n\tunsigned int __bits = (bits), idx, w = 0;\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\t\\\n\tfor (idx = 0; idx < __bits / BITS_PER_LONG; idx++)\t\t\t\\\n\t\tw += hweight_long(FETCH);\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\t\\\n\tif (__bits % BITS_PER_LONG)\t\t\t\t\t\t\\\n\t\tw += hweight_long((FETCH) & BITMAP_LAST_WORD_MASK(__bits));\t\\\n\t\t\t\t\t\t\t\t\t\t\\\n\tw;\t\t\t\t\t\t\t\t\t\\\n})\n\nunsigned int __bitmap_weight(const unsigned long *bitmap, unsigned int bits)\n{\n\treturn BITMAP_WEIGHT(bitmap[idx], bits);\n}\nEXPORT_SYMBOL(__bitmap_weight);\n\nunsigned int __bitmap_weight_and(const unsigned long *bitmap1,\n\t\t\t\tconst unsigned long *bitmap2, unsigned int bits)\n{\n\treturn BITMAP_WEIGHT(bitmap1[idx] & bitmap2[idx], bits);\n}\nEXPORT_SYMBOL(__bitmap_weight_and);\n\nvoid __bitmap_set(unsigned long *map, unsigned int start, int len)\n{\n\tunsigned long *p = map + BIT_WORD(start);\n\tconst unsigned int size = start + len;\n\tint bits_to_set = BITS_PER_LONG - (start % BITS_PER_LONG);\n\tunsigned long mask_to_set = BITMAP_FIRST_WORD_MASK(start);\n\n\twhile (len - bits_to_set >= 0) {\n\t\t*p |= mask_to_set;\n\t\tlen -= bits_to_set;\n\t\tbits_to_set = BITS_PER_LONG;\n\t\tmask_to_set = ~0UL;\n\t\tp++;\n\t}\n\tif (len) {\n\t\tmask_to_set &= BITMAP_LAST_WORD_MASK(size);\n\t\t*p |= mask_to_set;\n\t}\n}\nEXPORT_SYMBOL(__bitmap_set);\n\nvoid __bitmap_clear(unsigned long *map, unsigned int start, int len)\n{\n\tunsigned long *p = map + BIT_WORD(start);\n\tconst unsigned int size = start + len;\n\tint bits_to_clear = BITS_PER_LONG - (start % BITS_PER_LONG);\n\tunsigned long mask_to_clear = BITMAP_FIRST_WORD_MASK(start);\n\n\twhile (len - bits_to_clear >= 0) {\n\t\t*p &= ~mask_to_clear;\n\t\tlen -= bits_to_clear;\n\t\tbits_to_clear = BITS_PER_LONG;\n\t\tmask_to_clear = ~0UL;\n\t\tp++;\n\t}\n\tif (len) {\n\t\tmask_to_clear &= BITMAP_LAST_WORD_MASK(size);\n\t\t*p &= ~mask_to_clear;\n\t}\n}\nEXPORT_SYMBOL(__bitmap_clear);\n\n \nunsigned long bitmap_find_next_zero_area_off(unsigned long *map,\n\t\t\t\t\t     unsigned long size,\n\t\t\t\t\t     unsigned long start,\n\t\t\t\t\t     unsigned int nr,\n\t\t\t\t\t     unsigned long align_mask,\n\t\t\t\t\t     unsigned long align_offset)\n{\n\tunsigned long index, end, i;\nagain:\n\tindex = find_next_zero_bit(map, size, start);\n\n\t \n\tindex = __ALIGN_MASK(index + align_offset, align_mask) - align_offset;\n\n\tend = index + nr;\n\tif (end > size)\n\t\treturn end;\n\ti = find_next_bit(map, end, index);\n\tif (i < end) {\n\t\tstart = i + 1;\n\t\tgoto again;\n\t}\n\treturn index;\n}\nEXPORT_SYMBOL(bitmap_find_next_zero_area_off);\n\n \n\n \nint bitmap_parse_user(const char __user *ubuf,\n\t\t\tunsigned int ulen, unsigned long *maskp,\n\t\t\tint nmaskbits)\n{\n\tchar *buf;\n\tint ret;\n\n\tbuf = memdup_user_nul(ubuf, ulen);\n\tif (IS_ERR(buf))\n\t\treturn PTR_ERR(buf);\n\n\tret = bitmap_parse(buf, UINT_MAX, maskp, nmaskbits);\n\n\tkfree(buf);\n\treturn ret;\n}\nEXPORT_SYMBOL(bitmap_parse_user);\n\n \nint bitmap_print_to_pagebuf(bool list, char *buf, const unsigned long *maskp,\n\t\t\t    int nmaskbits)\n{\n\tptrdiff_t len = PAGE_SIZE - offset_in_page(buf);\n\n\treturn list ? scnprintf(buf, len, \"%*pbl\\n\", nmaskbits, maskp) :\n\t\t      scnprintf(buf, len, \"%*pb\\n\", nmaskbits, maskp);\n}\nEXPORT_SYMBOL(bitmap_print_to_pagebuf);\n\n \nstatic int bitmap_print_to_buf(bool list, char *buf, const unsigned long *maskp,\n\t\tint nmaskbits, loff_t off, size_t count)\n{\n\tconst char *fmt = list ? \"%*pbl\\n\" : \"%*pb\\n\";\n\tssize_t size;\n\tvoid *data;\n\n\tdata = kasprintf(GFP_KERNEL, fmt, nmaskbits, maskp);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tsize = memory_read_from_buffer(buf, count, &off, data, strlen(data) + 1);\n\tkfree(data);\n\n\treturn size;\n}\n\n \nint bitmap_print_bitmask_to_buf(char *buf, const unsigned long *maskp,\n\t\t\t\tint nmaskbits, loff_t off, size_t count)\n{\n\treturn bitmap_print_to_buf(false, buf, maskp, nmaskbits, off, count);\n}\nEXPORT_SYMBOL(bitmap_print_bitmask_to_buf);\n\n \nint bitmap_print_list_to_buf(char *buf, const unsigned long *maskp,\n\t\t\t     int nmaskbits, loff_t off, size_t count)\n{\n\treturn bitmap_print_to_buf(true, buf, maskp, nmaskbits, off, count);\n}\nEXPORT_SYMBOL(bitmap_print_list_to_buf);\n\n \nstruct region {\n\tunsigned int start;\n\tunsigned int off;\n\tunsigned int group_len;\n\tunsigned int end;\n\tunsigned int nbits;\n};\n\nstatic void bitmap_set_region(const struct region *r, unsigned long *bitmap)\n{\n\tunsigned int start;\n\n\tfor (start = r->start; start <= r->end; start += r->group_len)\n\t\tbitmap_set(bitmap, start, min(r->end - start + 1, r->off));\n}\n\nstatic int bitmap_check_region(const struct region *r)\n{\n\tif (r->start > r->end || r->group_len == 0 || r->off > r->group_len)\n\t\treturn -EINVAL;\n\n\tif (r->end >= r->nbits)\n\t\treturn -ERANGE;\n\n\treturn 0;\n}\n\nstatic const char *bitmap_getnum(const char *str, unsigned int *num,\n\t\t\t\t unsigned int lastbit)\n{\n\tunsigned long long n;\n\tunsigned int len;\n\n\tif (str[0] == 'N') {\n\t\t*num = lastbit;\n\t\treturn str + 1;\n\t}\n\n\tlen = _parse_integer(str, 10, &n);\n\tif (!len)\n\t\treturn ERR_PTR(-EINVAL);\n\tif (len & KSTRTOX_OVERFLOW || n != (unsigned int)n)\n\t\treturn ERR_PTR(-EOVERFLOW);\n\n\t*num = n;\n\treturn str + len;\n}\n\nstatic inline bool end_of_str(char c)\n{\n\treturn c == '\\0' || c == '\\n';\n}\n\nstatic inline bool __end_of_region(char c)\n{\n\treturn isspace(c) || c == ',';\n}\n\nstatic inline bool end_of_region(char c)\n{\n\treturn __end_of_region(c) || end_of_str(c);\n}\n\n \nstatic const char *bitmap_find_region(const char *str)\n{\n\twhile (__end_of_region(*str))\n\t\tstr++;\n\n\treturn end_of_str(*str) ? NULL : str;\n}\n\nstatic const char *bitmap_find_region_reverse(const char *start, const char *end)\n{\n\twhile (start <= end && __end_of_region(*end))\n\t\tend--;\n\n\treturn end;\n}\n\nstatic const char *bitmap_parse_region(const char *str, struct region *r)\n{\n\tunsigned int lastbit = r->nbits - 1;\n\n\tif (!strncasecmp(str, \"all\", 3)) {\n\t\tr->start = 0;\n\t\tr->end = lastbit;\n\t\tstr += 3;\n\n\t\tgoto check_pattern;\n\t}\n\n\tstr = bitmap_getnum(str, &r->start, lastbit);\n\tif (IS_ERR(str))\n\t\treturn str;\n\n\tif (end_of_region(*str))\n\t\tgoto no_end;\n\n\tif (*str != '-')\n\t\treturn ERR_PTR(-EINVAL);\n\n\tstr = bitmap_getnum(str + 1, &r->end, lastbit);\n\tif (IS_ERR(str))\n\t\treturn str;\n\ncheck_pattern:\n\tif (end_of_region(*str))\n\t\tgoto no_pattern;\n\n\tif (*str != ':')\n\t\treturn ERR_PTR(-EINVAL);\n\n\tstr = bitmap_getnum(str + 1, &r->off, lastbit);\n\tif (IS_ERR(str))\n\t\treturn str;\n\n\tif (*str != '/')\n\t\treturn ERR_PTR(-EINVAL);\n\n\treturn bitmap_getnum(str + 1, &r->group_len, lastbit);\n\nno_end:\n\tr->end = r->start;\nno_pattern:\n\tr->off = r->end + 1;\n\tr->group_len = r->end + 1;\n\n\treturn end_of_str(*str) ? NULL : str;\n}\n\n \nint bitmap_parselist(const char *buf, unsigned long *maskp, int nmaskbits)\n{\n\tstruct region r;\n\tlong ret;\n\n\tr.nbits = nmaskbits;\n\tbitmap_zero(maskp, r.nbits);\n\n\twhile (buf) {\n\t\tbuf = bitmap_find_region(buf);\n\t\tif (buf == NULL)\n\t\t\treturn 0;\n\n\t\tbuf = bitmap_parse_region(buf, &r);\n\t\tif (IS_ERR(buf))\n\t\t\treturn PTR_ERR(buf);\n\n\t\tret = bitmap_check_region(&r);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tbitmap_set_region(&r, maskp);\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(bitmap_parselist);\n\n\n \nint bitmap_parselist_user(const char __user *ubuf,\n\t\t\tunsigned int ulen, unsigned long *maskp,\n\t\t\tint nmaskbits)\n{\n\tchar *buf;\n\tint ret;\n\n\tbuf = memdup_user_nul(ubuf, ulen);\n\tif (IS_ERR(buf))\n\t\treturn PTR_ERR(buf);\n\n\tret = bitmap_parselist(buf, maskp, nmaskbits);\n\n\tkfree(buf);\n\treturn ret;\n}\nEXPORT_SYMBOL(bitmap_parselist_user);\n\nstatic const char *bitmap_get_x32_reverse(const char *start,\n\t\t\t\t\tconst char *end, u32 *num)\n{\n\tu32 ret = 0;\n\tint c, i;\n\n\tfor (i = 0; i < 32; i += 4) {\n\t\tc = hex_to_bin(*end--);\n\t\tif (c < 0)\n\t\t\treturn ERR_PTR(-EINVAL);\n\n\t\tret |= c << i;\n\n\t\tif (start > end || __end_of_region(*end))\n\t\t\tgoto out;\n\t}\n\n\tif (hex_to_bin(*end--) >= 0)\n\t\treturn ERR_PTR(-EOVERFLOW);\nout:\n\t*num = ret;\n\treturn end;\n}\n\n \nint bitmap_parse(const char *start, unsigned int buflen,\n\t\tunsigned long *maskp, int nmaskbits)\n{\n\tconst char *end = strnchrnul(start, buflen, '\\n') - 1;\n\tint chunks = BITS_TO_U32(nmaskbits);\n\tu32 *bitmap = (u32 *)maskp;\n\tint unset_bit;\n\tint chunk;\n\n\tfor (chunk = 0; ; chunk++) {\n\t\tend = bitmap_find_region_reverse(start, end);\n\t\tif (start > end)\n\t\t\tbreak;\n\n\t\tif (!chunks--)\n\t\t\treturn -EOVERFLOW;\n\n#if defined(CONFIG_64BIT) && defined(__BIG_ENDIAN)\n\t\tend = bitmap_get_x32_reverse(start, end, &bitmap[chunk ^ 1]);\n#else\n\t\tend = bitmap_get_x32_reverse(start, end, &bitmap[chunk]);\n#endif\n\t\tif (IS_ERR(end))\n\t\t\treturn PTR_ERR(end);\n\t}\n\n\tunset_bit = (BITS_TO_U32(nmaskbits) - chunks) * 32;\n\tif (unset_bit < nmaskbits) {\n\t\tbitmap_clear(maskp, unset_bit, nmaskbits - unset_bit);\n\t\treturn 0;\n\t}\n\n\tif (find_next_bit(maskp, unset_bit, nmaskbits) != unset_bit)\n\t\treturn -EOVERFLOW;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(bitmap_parse);\n\n \nstatic int bitmap_pos_to_ord(const unsigned long *buf, unsigned int pos, unsigned int nbits)\n{\n\tif (pos >= nbits || !test_bit(pos, buf))\n\t\treturn -1;\n\n\treturn bitmap_weight(buf, pos);\n}\n\n \nvoid bitmap_remap(unsigned long *dst, const unsigned long *src,\n\t\tconst unsigned long *old, const unsigned long *new,\n\t\tunsigned int nbits)\n{\n\tunsigned int oldbit, w;\n\n\tif (dst == src)\t\t \n\t\treturn;\n\tbitmap_zero(dst, nbits);\n\n\tw = bitmap_weight(new, nbits);\n\tfor_each_set_bit(oldbit, src, nbits) {\n\t\tint n = bitmap_pos_to_ord(old, oldbit, nbits);\n\n\t\tif (n < 0 || w == 0)\n\t\t\tset_bit(oldbit, dst);\t \n\t\telse\n\t\t\tset_bit(find_nth_bit(new, nbits, n % w), dst);\n\t}\n}\nEXPORT_SYMBOL(bitmap_remap);\n\n \nint bitmap_bitremap(int oldbit, const unsigned long *old,\n\t\t\t\tconst unsigned long *new, int bits)\n{\n\tint w = bitmap_weight(new, bits);\n\tint n = bitmap_pos_to_ord(old, oldbit, bits);\n\tif (n < 0 || w == 0)\n\t\treturn oldbit;\n\telse\n\t\treturn find_nth_bit(new, bits, n % w);\n}\nEXPORT_SYMBOL(bitmap_bitremap);\n\n#ifdef CONFIG_NUMA\n \nvoid bitmap_onto(unsigned long *dst, const unsigned long *orig,\n\t\t\tconst unsigned long *relmap, unsigned int bits)\n{\n\tunsigned int n, m;\t \n\n\tif (dst == orig)\t \n\t\treturn;\n\tbitmap_zero(dst, bits);\n\n\t \n\n\tm = 0;\n\tfor_each_set_bit(n, relmap, bits) {\n\t\t \n\t\tif (test_bit(m, orig))\n\t\t\tset_bit(n, dst);\n\t\tm++;\n\t}\n}\n\n \nvoid bitmap_fold(unsigned long *dst, const unsigned long *orig,\n\t\t\tunsigned int sz, unsigned int nbits)\n{\n\tunsigned int oldbit;\n\n\tif (dst == orig)\t \n\t\treturn;\n\tbitmap_zero(dst, nbits);\n\n\tfor_each_set_bit(oldbit, orig, nbits)\n\t\tset_bit(oldbit % sz, dst);\n}\n#endif  \n\n \n\nenum {\n\tREG_OP_ISFREE,\t\t \n\tREG_OP_ALLOC,\t\t \n\tREG_OP_RELEASE,\t\t \n};\n\nstatic int __reg_op(unsigned long *bitmap, unsigned int pos, int order, int reg_op)\n{\n\tint nbits_reg;\t\t \n\tint index;\t\t \n\tint offset;\t\t \n\tint nlongs_reg;\t\t \n\tint nbitsinlong;\t \n\tunsigned long mask;\t \n\tint i;\t\t\t \n\tint ret = 0;\t\t \n\n\t \n\tnbits_reg = 1 << order;\n\tindex = pos / BITS_PER_LONG;\n\toffset = pos - (index * BITS_PER_LONG);\n\tnlongs_reg = BITS_TO_LONGS(nbits_reg);\n\tnbitsinlong = min(nbits_reg,  BITS_PER_LONG);\n\n\t \n\tmask = (1UL << (nbitsinlong - 1));\n\tmask += mask - 1;\n\tmask <<= offset;\n\n\tswitch (reg_op) {\n\tcase REG_OP_ISFREE:\n\t\tfor (i = 0; i < nlongs_reg; i++) {\n\t\t\tif (bitmap[index + i] & mask)\n\t\t\t\tgoto done;\n\t\t}\n\t\tret = 1;\t \n\t\tbreak;\n\n\tcase REG_OP_ALLOC:\n\t\tfor (i = 0; i < nlongs_reg; i++)\n\t\t\tbitmap[index + i] |= mask;\n\t\tbreak;\n\n\tcase REG_OP_RELEASE:\n\t\tfor (i = 0; i < nlongs_reg; i++)\n\t\t\tbitmap[index + i] &= ~mask;\n\t\tbreak;\n\t}\ndone:\n\treturn ret;\n}\n\n \nint bitmap_find_free_region(unsigned long *bitmap, unsigned int bits, int order)\n{\n\tunsigned int pos, end;\t\t \n\n\tfor (pos = 0 ; (end = pos + (1U << order)) <= bits; pos = end) {\n\t\tif (!__reg_op(bitmap, pos, order, REG_OP_ISFREE))\n\t\t\tcontinue;\n\t\t__reg_op(bitmap, pos, order, REG_OP_ALLOC);\n\t\treturn pos;\n\t}\n\treturn -ENOMEM;\n}\nEXPORT_SYMBOL(bitmap_find_free_region);\n\n \nvoid bitmap_release_region(unsigned long *bitmap, unsigned int pos, int order)\n{\n\t__reg_op(bitmap, pos, order, REG_OP_RELEASE);\n}\nEXPORT_SYMBOL(bitmap_release_region);\n\n \nint bitmap_allocate_region(unsigned long *bitmap, unsigned int pos, int order)\n{\n\tif (!__reg_op(bitmap, pos, order, REG_OP_ISFREE))\n\t\treturn -EBUSY;\n\treturn __reg_op(bitmap, pos, order, REG_OP_ALLOC);\n}\nEXPORT_SYMBOL(bitmap_allocate_region);\n\n \n#ifdef __BIG_ENDIAN\nvoid bitmap_copy_le(unsigned long *dst, const unsigned long *src, unsigned int nbits)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < nbits/BITS_PER_LONG; i++) {\n\t\tif (BITS_PER_LONG == 64)\n\t\t\tdst[i] = cpu_to_le64(src[i]);\n\t\telse\n\t\t\tdst[i] = cpu_to_le32(src[i]);\n\t}\n}\nEXPORT_SYMBOL(bitmap_copy_le);\n#endif\n\nunsigned long *bitmap_alloc(unsigned int nbits, gfp_t flags)\n{\n\treturn kmalloc_array(BITS_TO_LONGS(nbits), sizeof(unsigned long),\n\t\t\t     flags);\n}\nEXPORT_SYMBOL(bitmap_alloc);\n\nunsigned long *bitmap_zalloc(unsigned int nbits, gfp_t flags)\n{\n\treturn bitmap_alloc(nbits, flags | __GFP_ZERO);\n}\nEXPORT_SYMBOL(bitmap_zalloc);\n\nunsigned long *bitmap_alloc_node(unsigned int nbits, gfp_t flags, int node)\n{\n\treturn kmalloc_array_node(BITS_TO_LONGS(nbits), sizeof(unsigned long),\n\t\t\t\t  flags, node);\n}\nEXPORT_SYMBOL(bitmap_alloc_node);\n\nunsigned long *bitmap_zalloc_node(unsigned int nbits, gfp_t flags, int node)\n{\n\treturn bitmap_alloc_node(nbits, flags | __GFP_ZERO, node);\n}\nEXPORT_SYMBOL(bitmap_zalloc_node);\n\nvoid bitmap_free(const unsigned long *bitmap)\n{\n\tkfree(bitmap);\n}\nEXPORT_SYMBOL(bitmap_free);\n\nstatic void devm_bitmap_free(void *data)\n{\n\tunsigned long *bitmap = data;\n\n\tbitmap_free(bitmap);\n}\n\nunsigned long *devm_bitmap_alloc(struct device *dev,\n\t\t\t\t unsigned int nbits, gfp_t flags)\n{\n\tunsigned long *bitmap;\n\tint ret;\n\n\tbitmap = bitmap_alloc(nbits, flags);\n\tif (!bitmap)\n\t\treturn NULL;\n\n\tret = devm_add_action_or_reset(dev, devm_bitmap_free, bitmap);\n\tif (ret)\n\t\treturn NULL;\n\n\treturn bitmap;\n}\nEXPORT_SYMBOL_GPL(devm_bitmap_alloc);\n\nunsigned long *devm_bitmap_zalloc(struct device *dev,\n\t\t\t\t  unsigned int nbits, gfp_t flags)\n{\n\treturn devm_bitmap_alloc(dev, nbits, flags | __GFP_ZERO);\n}\nEXPORT_SYMBOL_GPL(devm_bitmap_zalloc);\n\n#if BITS_PER_LONG == 64\n \nvoid bitmap_from_arr32(unsigned long *bitmap, const u32 *buf, unsigned int nbits)\n{\n\tunsigned int i, halfwords;\n\n\thalfwords = DIV_ROUND_UP(nbits, 32);\n\tfor (i = 0; i < halfwords; i++) {\n\t\tbitmap[i/2] = (unsigned long) buf[i];\n\t\tif (++i < halfwords)\n\t\t\tbitmap[i/2] |= ((unsigned long) buf[i]) << 32;\n\t}\n\n\t \n\tif (nbits % BITS_PER_LONG)\n\t\tbitmap[(halfwords - 1) / 2] &= BITMAP_LAST_WORD_MASK(nbits);\n}\nEXPORT_SYMBOL(bitmap_from_arr32);\n\n \nvoid bitmap_to_arr32(u32 *buf, const unsigned long *bitmap, unsigned int nbits)\n{\n\tunsigned int i, halfwords;\n\n\thalfwords = DIV_ROUND_UP(nbits, 32);\n\tfor (i = 0; i < halfwords; i++) {\n\t\tbuf[i] = (u32) (bitmap[i/2] & UINT_MAX);\n\t\tif (++i < halfwords)\n\t\t\tbuf[i] = (u32) (bitmap[i/2] >> 32);\n\t}\n\n\t \n\tif (nbits % BITS_PER_LONG)\n\t\tbuf[halfwords - 1] &= (u32) (UINT_MAX >> ((-nbits) & 31));\n}\nEXPORT_SYMBOL(bitmap_to_arr32);\n#endif\n\n#if BITS_PER_LONG == 32\n \nvoid bitmap_from_arr64(unsigned long *bitmap, const u64 *buf, unsigned int nbits)\n{\n\tint n;\n\n\tfor (n = nbits; n > 0; n -= 64) {\n\t\tu64 val = *buf++;\n\n\t\t*bitmap++ = val;\n\t\tif (n > 32)\n\t\t\t*bitmap++ = val >> 32;\n\t}\n\n\t \n\tif (nbits % BITS_PER_LONG)\n\t\tbitmap[-1] &= BITMAP_LAST_WORD_MASK(nbits);\n}\nEXPORT_SYMBOL(bitmap_from_arr64);\n\n \nvoid bitmap_to_arr64(u64 *buf, const unsigned long *bitmap, unsigned int nbits)\n{\n\tconst unsigned long *end = bitmap + BITS_TO_LONGS(nbits);\n\n\twhile (bitmap < end) {\n\t\t*buf = *bitmap++;\n\t\tif (bitmap < end)\n\t\t\t*buf |= (u64)(*bitmap++) << 32;\n\t\tbuf++;\n\t}\n\n\t \n\tif (nbits % 64)\n\t\tbuf[-1] &= GENMASK_ULL((nbits - 1) % 64, 0);\n}\nEXPORT_SYMBOL(bitmap_to_arr64);\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}