{
  "module_name": "overflow_kunit.c",
  "hash_id": "56daafd6a78558766205bf7676634a41608d8e8402d31fe4db2eb36a461179ca",
  "original_prompt": "Ingested from linux-6.6.14/lib/overflow_kunit.c",
  "human_readable_source": "\n \n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <kunit/test.h>\n#include <linux/device.h>\n#include <linux/kernel.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/overflow.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/vmalloc.h>\n\n#define SKIP(cond, reason)\t\tdo {\t\t\t\\\n\tif (cond) {\t\t\t\t\t\t\\\n\t\tkunit_skip(test, reason);\t\t\t\\\n\t\treturn;\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\\\n} while (0)\n\n \n#if defined(CONFIG_CC_IS_CLANG) && __clang_major__ <= 11\n# define SKIP_SIGN_MISMATCH(t)\tSKIP(t, \"Clang 11 unwanted libcalls\")\n#else\n# define SKIP_SIGN_MISMATCH(t)\tdo { } while (0)\n#endif\n\n \n#if defined(CONFIG_CC_IS_CLANG) && __clang_major__ <= 13 &&\t\\\n    BITS_PER_LONG != 64\n# define SKIP_64_ON_32(t)\tSKIP(t, \"Clang 13 unwanted libcalls\")\n#else\n# define SKIP_64_ON_32(t)\tdo { } while (0)\n#endif\n\n#define DEFINE_TEST_ARRAY_TYPED(t1, t2, t)\t\t\t\\\n\tstatic const struct test_ ## t1 ## _ ## t2 ## __ ## t {\t\\\n\t\tt1 a;\t\t\t\t\t\t\\\n\t\tt2 b;\t\t\t\t\t\t\\\n\t\tt sum, diff, prod;\t\t\t\t\\\n\t\tbool s_of, d_of, p_of;\t\t\t\t\\\n\t} t1 ## _ ## t2 ## __ ## t ## _tests[]\n\n#define DEFINE_TEST_ARRAY(t)\tDEFINE_TEST_ARRAY_TYPED(t, t, t)\n\nDEFINE_TEST_ARRAY(u8) = {\n\t{0, 0, 0, 0, 0, false, false, false},\n\t{1, 1, 2, 0, 1, false, false, false},\n\t{0, 1, 1, U8_MAX, 0, false, true, false},\n\t{1, 0, 1, 1, 0, false, false, false},\n\t{0, U8_MAX, U8_MAX, 1, 0, false, true, false},\n\t{U8_MAX, 0, U8_MAX, U8_MAX, 0, false, false, false},\n\t{1, U8_MAX, 0, 2, U8_MAX, true, true, false},\n\t{U8_MAX, 1, 0, U8_MAX-1, U8_MAX, true, false, false},\n\t{U8_MAX, U8_MAX, U8_MAX-1, 0, 1, true, false, true},\n\n\t{U8_MAX, U8_MAX-1, U8_MAX-2, 1, 2, true, false, true},\n\t{U8_MAX-1, U8_MAX, U8_MAX-2, U8_MAX, 2, true, true, true},\n\n\t{1U << 3, 1U << 3, 1U << 4, 0, 1U << 6, false, false, false},\n\t{1U << 4, 1U << 4, 1U << 5, 0, 0, false, false, true},\n\t{1U << 4, 1U << 3, 3*(1U << 3), 1U << 3, 1U << 7, false, false, false},\n\t{1U << 7, 1U << 7, 0, 0, 0, true, false, true},\n\n\t{48, 32, 80, 16, 0, false, false, true},\n\t{128, 128, 0, 0, 0, true, false, true},\n\t{123, 234, 101, 145, 110, true, true, true},\n};\nDEFINE_TEST_ARRAY(u16) = {\n\t{0, 0, 0, 0, 0, false, false, false},\n\t{1, 1, 2, 0, 1, false, false, false},\n\t{0, 1, 1, U16_MAX, 0, false, true, false},\n\t{1, 0, 1, 1, 0, false, false, false},\n\t{0, U16_MAX, U16_MAX, 1, 0, false, true, false},\n\t{U16_MAX, 0, U16_MAX, U16_MAX, 0, false, false, false},\n\t{1, U16_MAX, 0, 2, U16_MAX, true, true, false},\n\t{U16_MAX, 1, 0, U16_MAX-1, U16_MAX, true, false, false},\n\t{U16_MAX, U16_MAX, U16_MAX-1, 0, 1, true, false, true},\n\n\t{U16_MAX, U16_MAX-1, U16_MAX-2, 1, 2, true, false, true},\n\t{U16_MAX-1, U16_MAX, U16_MAX-2, U16_MAX, 2, true, true, true},\n\n\t{1U << 7, 1U << 7, 1U << 8, 0, 1U << 14, false, false, false},\n\t{1U << 8, 1U << 8, 1U << 9, 0, 0, false, false, true},\n\t{1U << 8, 1U << 7, 3*(1U << 7), 1U << 7, 1U << 15, false, false, false},\n\t{1U << 15, 1U << 15, 0, 0, 0, true, false, true},\n\n\t{123, 234, 357, 65425, 28782, false, true, false},\n\t{1234, 2345, 3579, 64425, 10146, false, true, true},\n};\nDEFINE_TEST_ARRAY(u32) = {\n\t{0, 0, 0, 0, 0, false, false, false},\n\t{1, 1, 2, 0, 1, false, false, false},\n\t{0, 1, 1, U32_MAX, 0, false, true, false},\n\t{1, 0, 1, 1, 0, false, false, false},\n\t{0, U32_MAX, U32_MAX, 1, 0, false, true, false},\n\t{U32_MAX, 0, U32_MAX, U32_MAX, 0, false, false, false},\n\t{1, U32_MAX, 0, 2, U32_MAX, true, true, false},\n\t{U32_MAX, 1, 0, U32_MAX-1, U32_MAX, true, false, false},\n\t{U32_MAX, U32_MAX, U32_MAX-1, 0, 1, true, false, true},\n\n\t{U32_MAX, U32_MAX-1, U32_MAX-2, 1, 2, true, false, true},\n\t{U32_MAX-1, U32_MAX, U32_MAX-2, U32_MAX, 2, true, true, true},\n\n\t{1U << 15, 1U << 15, 1U << 16, 0, 1U << 30, false, false, false},\n\t{1U << 16, 1U << 16, 1U << 17, 0, 0, false, false, true},\n\t{1U << 16, 1U << 15, 3*(1U << 15), 1U << 15, 1U << 31, false, false, false},\n\t{1U << 31, 1U << 31, 0, 0, 0, true, false, true},\n\n\t{-2U, 1U, -1U, -3U, -2U, false, false, false},\n\t{-4U, 5U, 1U, -9U, -20U, true, false, true},\n};\n\nDEFINE_TEST_ARRAY(u64) = {\n\t{0, 0, 0, 0, 0, false, false, false},\n\t{1, 1, 2, 0, 1, false, false, false},\n\t{0, 1, 1, U64_MAX, 0, false, true, false},\n\t{1, 0, 1, 1, 0, false, false, false},\n\t{0, U64_MAX, U64_MAX, 1, 0, false, true, false},\n\t{U64_MAX, 0, U64_MAX, U64_MAX, 0, false, false, false},\n\t{1, U64_MAX, 0, 2, U64_MAX, true, true, false},\n\t{U64_MAX, 1, 0, U64_MAX-1, U64_MAX, true, false, false},\n\t{U64_MAX, U64_MAX, U64_MAX-1, 0, 1, true, false, true},\n\n\t{U64_MAX, U64_MAX-1, U64_MAX-2, 1, 2, true, false, true},\n\t{U64_MAX-1, U64_MAX, U64_MAX-2, U64_MAX, 2, true, true, true},\n\n\t{1ULL << 31, 1ULL << 31, 1ULL << 32, 0, 1ULL << 62, false, false, false},\n\t{1ULL << 32, 1ULL << 32, 1ULL << 33, 0, 0, false, false, true},\n\t{1ULL << 32, 1ULL << 31, 3*(1ULL << 31), 1ULL << 31, 1ULL << 63, false, false, false},\n\t{1ULL << 63, 1ULL << 63, 0, 0, 0, true, false, true},\n\t{1000000000ULL  , 10000000000ULL  ,\n\t 11000000000ULL, 18446744064709551616ULL, 10000000000000000000ULL,\n\t false, true, false},\n\t{-15ULL, 10ULL, -5ULL, -25ULL, -150ULL, false, false, true},\n};\n\nDEFINE_TEST_ARRAY(s8) = {\n\t{0, 0, 0, 0, 0, false, false, false},\n\n\t{0, S8_MAX, S8_MAX, -S8_MAX, 0, false, false, false},\n\t{S8_MAX, 0, S8_MAX, S8_MAX, 0, false, false, false},\n\t{0, S8_MIN, S8_MIN, S8_MIN, 0, false, true, false},\n\t{S8_MIN, 0, S8_MIN, S8_MIN, 0, false, false, false},\n\n\t{-1, S8_MIN, S8_MAX, S8_MAX, S8_MIN, true, false, true},\n\t{S8_MIN, -1, S8_MAX, -S8_MAX, S8_MIN, true, false, true},\n\t{-1, S8_MAX, S8_MAX-1, S8_MIN, -S8_MAX, false, false, false},\n\t{S8_MAX, -1, S8_MAX-1, S8_MIN, -S8_MAX, false, true, false},\n\t{-1, -S8_MAX, S8_MIN, S8_MAX-1, S8_MAX, false, false, false},\n\t{-S8_MAX, -1, S8_MIN, S8_MIN+2, S8_MAX, false, false, false},\n\n\t{1, S8_MIN, -S8_MAX, -S8_MAX, S8_MIN, false, true, false},\n\t{S8_MIN, 1, -S8_MAX, S8_MAX, S8_MIN, false, true, false},\n\t{1, S8_MAX, S8_MIN, S8_MIN+2, S8_MAX, true, false, false},\n\t{S8_MAX, 1, S8_MIN, S8_MAX-1, S8_MAX, true, false, false},\n\n\t{S8_MIN, S8_MIN, 0, 0, 0, true, false, true},\n\t{S8_MAX, S8_MAX, -2, 0, 1, true, false, true},\n\n\t{-4, -32, -36, 28, -128, false, false, true},\n\t{-4, 32, 28, -36, -128, false, false, false},\n};\n\nDEFINE_TEST_ARRAY(s16) = {\n\t{0, 0, 0, 0, 0, false, false, false},\n\n\t{0, S16_MAX, S16_MAX, -S16_MAX, 0, false, false, false},\n\t{S16_MAX, 0, S16_MAX, S16_MAX, 0, false, false, false},\n\t{0, S16_MIN, S16_MIN, S16_MIN, 0, false, true, false},\n\t{S16_MIN, 0, S16_MIN, S16_MIN, 0, false, false, false},\n\n\t{-1, S16_MIN, S16_MAX, S16_MAX, S16_MIN, true, false, true},\n\t{S16_MIN, -1, S16_MAX, -S16_MAX, S16_MIN, true, false, true},\n\t{-1, S16_MAX, S16_MAX-1, S16_MIN, -S16_MAX, false, false, false},\n\t{S16_MAX, -1, S16_MAX-1, S16_MIN, -S16_MAX, false, true, false},\n\t{-1, -S16_MAX, S16_MIN, S16_MAX-1, S16_MAX, false, false, false},\n\t{-S16_MAX, -1, S16_MIN, S16_MIN+2, S16_MAX, false, false, false},\n\n\t{1, S16_MIN, -S16_MAX, -S16_MAX, S16_MIN, false, true, false},\n\t{S16_MIN, 1, -S16_MAX, S16_MAX, S16_MIN, false, true, false},\n\t{1, S16_MAX, S16_MIN, S16_MIN+2, S16_MAX, true, false, false},\n\t{S16_MAX, 1, S16_MIN, S16_MAX-1, S16_MAX, true, false, false},\n\n\t{S16_MIN, S16_MIN, 0, 0, 0, true, false, true},\n\t{S16_MAX, S16_MAX, -2, 0, 1, true, false, true},\n};\nDEFINE_TEST_ARRAY(s32) = {\n\t{0, 0, 0, 0, 0, false, false, false},\n\n\t{0, S32_MAX, S32_MAX, -S32_MAX, 0, false, false, false},\n\t{S32_MAX, 0, S32_MAX, S32_MAX, 0, false, false, false},\n\t{0, S32_MIN, S32_MIN, S32_MIN, 0, false, true, false},\n\t{S32_MIN, 0, S32_MIN, S32_MIN, 0, false, false, false},\n\n\t{-1, S32_MIN, S32_MAX, S32_MAX, S32_MIN, true, false, true},\n\t{S32_MIN, -1, S32_MAX, -S32_MAX, S32_MIN, true, false, true},\n\t{-1, S32_MAX, S32_MAX-1, S32_MIN, -S32_MAX, false, false, false},\n\t{S32_MAX, -1, S32_MAX-1, S32_MIN, -S32_MAX, false, true, false},\n\t{-1, -S32_MAX, S32_MIN, S32_MAX-1, S32_MAX, false, false, false},\n\t{-S32_MAX, -1, S32_MIN, S32_MIN+2, S32_MAX, false, false, false},\n\n\t{1, S32_MIN, -S32_MAX, -S32_MAX, S32_MIN, false, true, false},\n\t{S32_MIN, 1, -S32_MAX, S32_MAX, S32_MIN, false, true, false},\n\t{1, S32_MAX, S32_MIN, S32_MIN+2, S32_MAX, true, false, false},\n\t{S32_MAX, 1, S32_MIN, S32_MAX-1, S32_MAX, true, false, false},\n\n\t{S32_MIN, S32_MIN, 0, 0, 0, true, false, true},\n\t{S32_MAX, S32_MAX, -2, 0, 1, true, false, true},\n};\n\nDEFINE_TEST_ARRAY(s64) = {\n\t{0, 0, 0, 0, 0, false, false, false},\n\n\t{0, S64_MAX, S64_MAX, -S64_MAX, 0, false, false, false},\n\t{S64_MAX, 0, S64_MAX, S64_MAX, 0, false, false, false},\n\t{0, S64_MIN, S64_MIN, S64_MIN, 0, false, true, false},\n\t{S64_MIN, 0, S64_MIN, S64_MIN, 0, false, false, false},\n\n\t{-1, S64_MIN, S64_MAX, S64_MAX, S64_MIN, true, false, true},\n\t{S64_MIN, -1, S64_MAX, -S64_MAX, S64_MIN, true, false, true},\n\t{-1, S64_MAX, S64_MAX-1, S64_MIN, -S64_MAX, false, false, false},\n\t{S64_MAX, -1, S64_MAX-1, S64_MIN, -S64_MAX, false, true, false},\n\t{-1, -S64_MAX, S64_MIN, S64_MAX-1, S64_MAX, false, false, false},\n\t{-S64_MAX, -1, S64_MIN, S64_MIN+2, S64_MAX, false, false, false},\n\n\t{1, S64_MIN, -S64_MAX, -S64_MAX, S64_MIN, false, true, false},\n\t{S64_MIN, 1, -S64_MAX, S64_MAX, S64_MIN, false, true, false},\n\t{1, S64_MAX, S64_MIN, S64_MIN+2, S64_MAX, true, false, false},\n\t{S64_MAX, 1, S64_MIN, S64_MAX-1, S64_MAX, true, false, false},\n\n\t{S64_MIN, S64_MIN, 0, 0, 0, true, false, true},\n\t{S64_MAX, S64_MAX, -2, 0, 1, true, false, true},\n\n\t{-1, -1, -2, 0, 1, false, false, false},\n\t{-1, -128, -129, 127, 128, false, false, false},\n\t{-128, -1, -129, -127, 128, false, false, false},\n\t{0, -S64_MAX, -S64_MAX, S64_MAX, 0, false, false, false},\n};\n\n#define check_one_op(t, fmt, op, sym, a, b, r, of) do {\t\t\t\\\n\tint _a_orig = a, _a_bump = a + 1;\t\t\t\t\\\n\tint _b_orig = b, _b_bump = b + 1;\t\t\t\t\\\n\tbool _of;\t\t\t\t\t\t\t\\\n\tt _r;\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t_of = check_ ## op ## _overflow(a, b, &_r);\t\t\t\\\n\tKUNIT_EXPECT_EQ_MSG(test, _of, of,\t\t\t\t\\\n\t\t\"expected \"fmt\" \"sym\" \"fmt\" to%s overflow (type %s)\\n\",\t\\\n\t\ta, b, of ? \"\" : \" not\", #t);\t\t\t\t\\\n\tKUNIT_EXPECT_EQ_MSG(test, _r, r,\t\t\t\t\\\n\t\t\"expected \"fmt\" \"sym\" \"fmt\" == \"fmt\", got \"fmt\" (type %s)\\n\", \\\n\t\ta, b, r, _r, #t);\t\t\t\t\t\\\n\t \t\t\t\\\n\t_of = check_ ## op ## _overflow(_a_orig++, _b_orig++, &_r);\t\\\n\tKUNIT_EXPECT_EQ_MSG(test, _a_orig, _a_bump, \"Unexpected \" #op \" macro side-effect!\\n\"); \\\n\tKUNIT_EXPECT_EQ_MSG(test, _b_orig, _b_bump, \"Unexpected \" #op \" macro side-effect!\\n\"); \\\n} while (0)\n\n#define DEFINE_TEST_FUNC_TYPED(n, t, fmt)\t\t\t\t\\\nstatic void do_test_ ## n(struct kunit *test, const struct test_ ## n *p) \\\n{\t\t\t\t\t\t\t\t\t\\\n\tcheck_one_op(t, fmt, add, \"+\", p->a, p->b, p->sum, p->s_of);\t\\\n\tcheck_one_op(t, fmt, add, \"+\", p->b, p->a, p->sum, p->s_of);\t\\\n\tcheck_one_op(t, fmt, sub, \"-\", p->a, p->b, p->diff, p->d_of);\t\\\n\tcheck_one_op(t, fmt, mul, \"*\", p->a, p->b, p->prod, p->p_of);\t\\\n\tcheck_one_op(t, fmt, mul, \"*\", p->b, p->a, p->prod, p->p_of);\t\\\n}\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\nstatic void n ## _overflow_test(struct kunit *test) {\t\t\t\\\n\tunsigned i;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tSKIP_64_ON_32(__same_type(t, u64));\t\t\t\t\\\n\tSKIP_64_ON_32(__same_type(t, s64));\t\t\t\t\\\n\tSKIP_SIGN_MISMATCH(__same_type(n ## _tests[0].a, u32) &&\t\\\n\t\t\t   __same_type(n ## _tests[0].b, u32) &&\t\\\n\t\t\t   __same_type(n ## _tests[0].sum, int));\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tfor (i = 0; i < ARRAY_SIZE(n ## _tests); ++i)\t\t\t\\\n\t\tdo_test_ ## n(test, &n ## _tests[i]);\t\t\t\\\n\tkunit_info(test, \"%zu %s arithmetic tests finished\\n\",\t\t\\\n\t\tARRAY_SIZE(n ## _tests), #n);\t\t\t\t\\\n}\n\n#define DEFINE_TEST_FUNC(t, fmt)\t\t\t\t\t\\\n\tDEFINE_TEST_FUNC_TYPED(t ## _ ## t ## __ ## t, t, fmt)\n\nDEFINE_TEST_FUNC(u8, \"%d\");\nDEFINE_TEST_FUNC(s8, \"%d\");\nDEFINE_TEST_FUNC(u16, \"%d\");\nDEFINE_TEST_FUNC(s16, \"%d\");\nDEFINE_TEST_FUNC(u32, \"%u\");\nDEFINE_TEST_FUNC(s32, \"%d\");\nDEFINE_TEST_FUNC(u64, \"%llu\");\nDEFINE_TEST_FUNC(s64, \"%lld\");\n\nDEFINE_TEST_ARRAY_TYPED(u32, u32, u8) = {\n\t{0, 0, 0, 0, 0, false, false, false},\n\t{U8_MAX, 2, 1, U8_MAX - 2, U8_MAX - 1, true, false, true},\n\t{U8_MAX + 1, 0, 0, 0, 0, true, true, false},\n};\nDEFINE_TEST_FUNC_TYPED(u32_u32__u8, u8, \"%d\");\n\nDEFINE_TEST_ARRAY_TYPED(u32, u32, int) = {\n\t{0, 0, 0, 0, 0, false, false, false},\n\t{U32_MAX, 0, -1, -1, 0, true, true, false},\n};\nDEFINE_TEST_FUNC_TYPED(u32_u32__int, int, \"%d\");\n\nDEFINE_TEST_ARRAY_TYPED(u8, u8, int) = {\n\t{0, 0, 0, 0, 0, false, false, false},\n\t{U8_MAX, U8_MAX, 2 * U8_MAX, 0, U8_MAX * U8_MAX, false, false, false},\n\t{1, 2, 3, -1, 2, false, false, false},\n};\nDEFINE_TEST_FUNC_TYPED(u8_u8__int, int, \"%d\");\n\nDEFINE_TEST_ARRAY_TYPED(int, int, u8) = {\n\t{0, 0, 0, 0, 0, false, false, false},\n\t{1, 2, 3, U8_MAX, 2, false, true, false},\n\t{-1, 0, U8_MAX, U8_MAX, 0, true, true, false},\n};\nDEFINE_TEST_FUNC_TYPED(int_int__u8, u8, \"%d\");\n\n \n#define TEST_ONE_SHIFT(a, s, t, expect, of)\tdo {\t\t\t\\\n\ttypeof(a) __a = (a);\t\t\t\t\t\t\\\n\ttypeof(s) __s = (s);\t\t\t\t\t\t\\\n\tt __e = (expect);\t\t\t\t\t\t\\\n\tt __d;\t\t\t\t\t\t\t\t\\\n\tbool __of = check_shl_overflow(__a, __s, &__d);\t\t\t\\\n\tif (__of != of) {\t\t\t\t\t\t\\\n\t\tKUNIT_EXPECT_EQ_MSG(test, __of, of,\t\t\t\\\n\t\t\t\"expected (%s)(%s << %s) to%s overflow\\n\",\t\\\n\t\t\t#t, #a, #s, of ? \"\" : \" not\");\t\t\t\\\n\t} else if (!__of && __d != __e) {\t\t\t\t\\\n\t\tKUNIT_EXPECT_EQ_MSG(test, __d, __e,\t\t\t\\\n\t\t\t\"expected (%s)(%s << %s) == %s\\n\",\t\t\\\n\t\t\t#t, #a, #s, #expect);\t\t\t\t\\\n\t\tif ((t)-1 < 0)\t\t\t\t\t\t\\\n\t\t\tkunit_info(test, \"got %lld\\n\", (s64)__d);\t\\\n\t\telse\t\t\t\t\t\t\t\\\n\t\t\tkunit_info(test, \"got %llu\\n\", (u64)__d);\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\tcount++;\t\t\t\t\t\t\t\\\n} while (0)\n\nstatic void shift_sane_test(struct kunit *test)\n{\n\tint count = 0;\n\n\t \n\tTEST_ONE_SHIFT(1, 0, u8, 1 << 0, false);\n\tTEST_ONE_SHIFT(1, 4, u8, 1 << 4, false);\n\tTEST_ONE_SHIFT(1, 7, u8, 1 << 7, false);\n\tTEST_ONE_SHIFT(0xF, 4, u8, 0xF << 4, false);\n\tTEST_ONE_SHIFT(1, 0, u16, 1 << 0, false);\n\tTEST_ONE_SHIFT(1, 10, u16, 1 << 10, false);\n\tTEST_ONE_SHIFT(1, 15, u16, 1 << 15, false);\n\tTEST_ONE_SHIFT(0xFF, 8, u16, 0xFF << 8, false);\n\tTEST_ONE_SHIFT(1, 0, int, 1 << 0, false);\n\tTEST_ONE_SHIFT(1, 16, int, 1 << 16, false);\n\tTEST_ONE_SHIFT(1, 30, int, 1 << 30, false);\n\tTEST_ONE_SHIFT(1, 0, s32, 1 << 0, false);\n\tTEST_ONE_SHIFT(1, 16, s32, 1 << 16, false);\n\tTEST_ONE_SHIFT(1, 30, s32, 1 << 30, false);\n\tTEST_ONE_SHIFT(1, 0, unsigned int, 1U << 0, false);\n\tTEST_ONE_SHIFT(1, 20, unsigned int, 1U << 20, false);\n\tTEST_ONE_SHIFT(1, 31, unsigned int, 1U << 31, false);\n\tTEST_ONE_SHIFT(0xFFFFU, 16, unsigned int, 0xFFFFU << 16, false);\n\tTEST_ONE_SHIFT(1, 0, u32, 1U << 0, false);\n\tTEST_ONE_SHIFT(1, 20, u32, 1U << 20, false);\n\tTEST_ONE_SHIFT(1, 31, u32, 1U << 31, false);\n\tTEST_ONE_SHIFT(0xFFFFU, 16, u32, 0xFFFFU << 16, false);\n\tTEST_ONE_SHIFT(1, 0, u64, 1ULL << 0, false);\n\tTEST_ONE_SHIFT(1, 40, u64, 1ULL << 40, false);\n\tTEST_ONE_SHIFT(1, 63, u64, 1ULL << 63, false);\n\tTEST_ONE_SHIFT(0xFFFFFFFFULL, 32, u64, 0xFFFFFFFFULL << 32, false);\n\n\t \n\tTEST_ONE_SHIFT(0, 7, u8, 0, false);\n\tTEST_ONE_SHIFT(0, 15, u16, 0, false);\n\tTEST_ONE_SHIFT(0, 31, unsigned int, 0, false);\n\tTEST_ONE_SHIFT(0, 31, u32, 0, false);\n\tTEST_ONE_SHIFT(0, 63, u64, 0, false);\n\n\t \n\tTEST_ONE_SHIFT(0, 6, s8, 0, false);\n\tTEST_ONE_SHIFT(0, 14, s16, 0, false);\n\tTEST_ONE_SHIFT(0, 30, int, 0, false);\n\tTEST_ONE_SHIFT(0, 30, s32, 0, false);\n\tTEST_ONE_SHIFT(0, 62, s64, 0, false);\n\n\tkunit_info(test, \"%d sane shift tests finished\\n\", count);\n}\n\nstatic void shift_overflow_test(struct kunit *test)\n{\n\tint count = 0;\n\n\t \n\tTEST_ONE_SHIFT(1, 8, u8, 0, true);\n\tTEST_ONE_SHIFT(1, 16, u16, 0, true);\n\tTEST_ONE_SHIFT(1, 32, unsigned int, 0, true);\n\tTEST_ONE_SHIFT(1, 32, u32, 0, true);\n\tTEST_ONE_SHIFT(1, 64, u64, 0, true);\n\n\t \n\tTEST_ONE_SHIFT(1, 7, s8, 0, true);\n\tTEST_ONE_SHIFT(1, 15, s16, 0, true);\n\tTEST_ONE_SHIFT(1, 31, int, 0, true);\n\tTEST_ONE_SHIFT(1, 31, s32, 0, true);\n\tTEST_ONE_SHIFT(1, 63, s64, 0, true);\n\n\t \n\t \n\tTEST_ONE_SHIFT(150, 1, u8, 0, true);\n\t \n\tTEST_ONE_SHIFT(34966, 1, u16, 0, true);\n\t \n\tTEST_ONE_SHIFT(2215151766U, 1, u32, 0, true);\n\tTEST_ONE_SHIFT(2215151766U, 1, unsigned int, 0, true);\n\t \n\tTEST_ONE_SHIFT(9372061470395238550ULL, 1, u64, 0, true);\n\n\t \n\t \n\tTEST_ONE_SHIFT(75, 1, s8, 0, true);\n\t \n\tTEST_ONE_SHIFT(17483, 1, s16, 0, true);\n\t \n\tTEST_ONE_SHIFT(1107575883, 1, s32, 0, true);\n\tTEST_ONE_SHIFT(1107575883, 1, int, 0, true);\n\t \n\tTEST_ONE_SHIFT(4686030735197619275LL, 1, s64, 0, true);\n\n\t \n\t \n\tTEST_ONE_SHIFT(75, 2, s8, 0, true);\n\t \n\tTEST_ONE_SHIFT(17483, 2, s16, 0, true);\n\t \n\tTEST_ONE_SHIFT(1107575883, 2, s32, 0, true);\n\tTEST_ONE_SHIFT(1107575883, 2, int, 0, true);\n\t \n\tTEST_ONE_SHIFT(4686030735197619275LL, 2, s64, 0, true);\n\n\tkunit_info(test, \"%d overflow shift tests finished\\n\", count);\n}\n\nstatic void shift_truncate_test(struct kunit *test)\n{\n\tint count = 0;\n\n\t \n\tTEST_ONE_SHIFT(0x100, 0, u8, 0, true);\n\tTEST_ONE_SHIFT(0xFF, 0, s8, 0, true);\n\tTEST_ONE_SHIFT(0x10000U, 0, u16, 0, true);\n\tTEST_ONE_SHIFT(0xFFFFU, 0, s16, 0, true);\n\tTEST_ONE_SHIFT(0x100000000ULL, 0, u32, 0, true);\n\tTEST_ONE_SHIFT(0x100000000ULL, 0, unsigned int, 0, true);\n\tTEST_ONE_SHIFT(0xFFFFFFFFUL, 0, s32, 0, true);\n\tTEST_ONE_SHIFT(0xFFFFFFFFUL, 0, int, 0, true);\n\tTEST_ONE_SHIFT(0xFFFFFFFFFFFFFFFFULL, 0, s64, 0, true);\n\n\t \n\tTEST_ONE_SHIFT(0, 8, u8, 0, true);\n\tTEST_ONE_SHIFT(0, 9, u8, 0, true);\n\tTEST_ONE_SHIFT(0, 8, s8, 0, true);\n\tTEST_ONE_SHIFT(0, 9, s8, 0, true);\n\tTEST_ONE_SHIFT(0, 16, u16, 0, true);\n\tTEST_ONE_SHIFT(0, 17, u16, 0, true);\n\tTEST_ONE_SHIFT(0, 16, s16, 0, true);\n\tTEST_ONE_SHIFT(0, 17, s16, 0, true);\n\tTEST_ONE_SHIFT(0, 32, u32, 0, true);\n\tTEST_ONE_SHIFT(0, 33, u32, 0, true);\n\tTEST_ONE_SHIFT(0, 32, int, 0, true);\n\tTEST_ONE_SHIFT(0, 33, int, 0, true);\n\tTEST_ONE_SHIFT(0, 32, s32, 0, true);\n\tTEST_ONE_SHIFT(0, 33, s32, 0, true);\n\tTEST_ONE_SHIFT(0, 64, u64, 0, true);\n\tTEST_ONE_SHIFT(0, 65, u64, 0, true);\n\tTEST_ONE_SHIFT(0, 64, s64, 0, true);\n\tTEST_ONE_SHIFT(0, 65, s64, 0, true);\n\n\tkunit_info(test, \"%d truncate shift tests finished\\n\", count);\n}\n\nstatic void shift_nonsense_test(struct kunit *test)\n{\n\tint count = 0;\n\n\t \n\tTEST_ONE_SHIFT(-1, 0, s8, 0, true);\n\tTEST_ONE_SHIFT(-1, 0, u8, 0, true);\n\tTEST_ONE_SHIFT(-5, 0, s16, 0, true);\n\tTEST_ONE_SHIFT(-5, 0, u16, 0, true);\n\tTEST_ONE_SHIFT(-10, 0, int, 0, true);\n\tTEST_ONE_SHIFT(-10, 0, unsigned int, 0, true);\n\tTEST_ONE_SHIFT(-100, 0, s32, 0, true);\n\tTEST_ONE_SHIFT(-100, 0, u32, 0, true);\n\tTEST_ONE_SHIFT(-10000, 0, s64, 0, true);\n\tTEST_ONE_SHIFT(-10000, 0, u64, 0, true);\n\n\t \n\tTEST_ONE_SHIFT(0, -5, s8, 0, true);\n\tTEST_ONE_SHIFT(0, -5, u8, 0, true);\n\tTEST_ONE_SHIFT(0, -10, s16, 0, true);\n\tTEST_ONE_SHIFT(0, -10, u16, 0, true);\n\tTEST_ONE_SHIFT(0, -15, int, 0, true);\n\tTEST_ONE_SHIFT(0, -15, unsigned int, 0, true);\n\tTEST_ONE_SHIFT(0, -20, s32, 0, true);\n\tTEST_ONE_SHIFT(0, -20, u32, 0, true);\n\tTEST_ONE_SHIFT(0, -30, s64, 0, true);\n\tTEST_ONE_SHIFT(0, -30, u64, 0, true);\n\n\t \n\tTEST_ONE_SHIFT(0, 7, s8, 0, false);\n\tTEST_ONE_SHIFT(0, 15, s16, 0, false);\n\tTEST_ONE_SHIFT(0, 31, int, 0, false);\n\tTEST_ONE_SHIFT(0, 31, s32, 0, false);\n\tTEST_ONE_SHIFT(0, 63, s64, 0, false);\n\n\tkunit_info(test, \"%d nonsense shift tests finished\\n\", count);\n}\n#undef TEST_ONE_SHIFT\n\n \n#define alloc_GFP\t\t (GFP_KERNEL | __GFP_NOWARN)\n#define alloc010(alloc, arg, sz) alloc(sz, alloc_GFP)\n#define alloc011(alloc, arg, sz) alloc(sz, alloc_GFP, NUMA_NO_NODE)\n#define alloc000(alloc, arg, sz) alloc(sz)\n#define alloc001(alloc, arg, sz) alloc(sz, NUMA_NO_NODE)\n#define alloc110(alloc, arg, sz) alloc(arg, sz, alloc_GFP)\n#define free0(free, arg, ptr)\t free(ptr)\n#define free1(free, arg, ptr)\t free(arg, ptr)\n\n \n#define TEST_SIZE\t\t(5 * 4096)\n\n#define DEFINE_TEST_ALLOC(func, free_func, want_arg, want_gfp, want_node)\\\nstatic void test_ ## func (struct kunit *test, void *arg)\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tvolatile size_t a = TEST_SIZE;\t\t\t\t\t\\\n\tvolatile size_t b = (SIZE_MAX / TEST_SIZE) + 1;\t\t\t\\\n\tvoid *ptr;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t \t\t\t\t\t\\\n\tptr = alloc ## want_arg ## want_gfp ## want_node (func, arg, 1);\\\n\tKUNIT_ASSERT_NOT_ERR_OR_NULL_MSG(test, ptr,\t\t\t\\\n\t\t\t    #func \" failed regular allocation?!\\n\");\t\\\n\tfree ## want_arg (free_func, arg, ptr);\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t \t\t\t\t\t\\\n\tptr = alloc ## want_arg ## want_gfp ## want_node (func, arg,\t\\\n\t\t\t\t\t\t\t  a * b);\t\\\n\tKUNIT_ASSERT_NOT_ERR_OR_NULL_MSG(test, ptr,\t\t\t\\\n\t\t\t    #func \" unexpectedly failed bad wrapping?!\\n\"); \\\n\tfree ## want_arg (free_func, arg, ptr);\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t \t\t\t\t\\\n\tptr = alloc ## want_arg ## want_gfp ## want_node (func, arg,\t\\\n\t\t\t\t\t\t   array_size(a, b));\t\\\n\tif (ptr) {\t\t\t\t\t\t\t\\\n\t\tKUNIT_FAIL(test, #func \" missed saturation!\\n\");\t\\\n\t\tfree ## want_arg (free_func, arg, ptr);\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n}\n\n \nDEFINE_TEST_ALLOC(kmalloc,\t kfree,\t     0, 1, 0);\nDEFINE_TEST_ALLOC(kmalloc_node,\t kfree,\t     0, 1, 1);\nDEFINE_TEST_ALLOC(kzalloc,\t kfree,\t     0, 1, 0);\nDEFINE_TEST_ALLOC(kzalloc_node,  kfree,\t     0, 1, 1);\nDEFINE_TEST_ALLOC(__vmalloc,\t vfree,\t     0, 1, 0);\nDEFINE_TEST_ALLOC(kvmalloc,\t kvfree,     0, 1, 0);\nDEFINE_TEST_ALLOC(kvmalloc_node, kvfree,     0, 1, 1);\nDEFINE_TEST_ALLOC(kvzalloc,\t kvfree,     0, 1, 0);\nDEFINE_TEST_ALLOC(kvzalloc_node, kvfree,     0, 1, 1);\nDEFINE_TEST_ALLOC(devm_kmalloc,  devm_kfree, 1, 1, 0);\nDEFINE_TEST_ALLOC(devm_kzalloc,  devm_kfree, 1, 1, 0);\n\nstatic void overflow_allocation_test(struct kunit *test)\n{\n\tconst char device_name[] = \"overflow-test\";\n\tstruct device *dev;\n\tint count = 0;\n\n#define check_allocation_overflow(alloc)\tdo {\t\\\n\tcount++;\t\t\t\t\t\\\n\ttest_ ## alloc(test, dev);\t\t\t\\\n} while (0)\n\n\t \n\tdev = root_device_register(device_name);\n\tKUNIT_ASSERT_FALSE_MSG(test, IS_ERR(dev),\n\t\t\t       \"Cannot register test device\\n\");\n\n\tcheck_allocation_overflow(kmalloc);\n\tcheck_allocation_overflow(kmalloc_node);\n\tcheck_allocation_overflow(kzalloc);\n\tcheck_allocation_overflow(kzalloc_node);\n\tcheck_allocation_overflow(__vmalloc);\n\tcheck_allocation_overflow(kvmalloc);\n\tcheck_allocation_overflow(kvmalloc_node);\n\tcheck_allocation_overflow(kvzalloc);\n\tcheck_allocation_overflow(kvzalloc_node);\n\tcheck_allocation_overflow(devm_kmalloc);\n\tcheck_allocation_overflow(devm_kzalloc);\n\n\tdevice_unregister(dev);\n\n\tkunit_info(test, \"%d allocation overflow tests finished\\n\", count);\n#undef check_allocation_overflow\n}\n\nstruct __test_flex_array {\n\tunsigned long flags;\n\tsize_t count;\n\tunsigned long data[];\n};\n\nstatic void overflow_size_helpers_test(struct kunit *test)\n{\n\t \n\tu8 ce_array[struct_size_t(struct __test_flex_array, data, 55)];\n\tstruct __test_flex_array *obj;\n\tint count = 0;\n\tint var;\n\tvolatile int unconst = 0;\n\n\t \n\tvar = 55;\n\tOPTIMIZER_HIDE_VAR(var);\n\tKUNIT_EXPECT_EQ(test, sizeof(ce_array), struct_size(obj, data, var));\n\n#define check_one_size_helper(expected, func, args...)\tdo {\t\\\n\tsize_t _r = func(args);\t\t\t\t\t\\\n\tKUNIT_EXPECT_EQ_MSG(test, _r, expected,\t\t\t\\\n\t\t\"expected \" #func \"(\" #args \") to return %zu but got %zu instead\\n\", \\\n\t\t(size_t)(expected), _r);\t\t\t\\\n\tcount++;\t\t\t\t\t\t\\\n} while (0)\n\n\tvar = 4;\n\tcheck_one_size_helper(20,\tsize_mul, var++, 5);\n\tcheck_one_size_helper(20,\tsize_mul, 4, var++);\n\tcheck_one_size_helper(0,\tsize_mul, 0, 3);\n\tcheck_one_size_helper(0,\tsize_mul, 3, 0);\n\tcheck_one_size_helper(6,\tsize_mul, 2, 3);\n\tcheck_one_size_helper(SIZE_MAX,\tsize_mul, SIZE_MAX,  1);\n\tcheck_one_size_helper(SIZE_MAX,\tsize_mul, SIZE_MAX,  3);\n\tcheck_one_size_helper(SIZE_MAX,\tsize_mul, SIZE_MAX, -3);\n\n\tvar = 4;\n\tcheck_one_size_helper(9,\tsize_add, var++, 5);\n\tcheck_one_size_helper(9,\tsize_add, 4, var++);\n\tcheck_one_size_helper(9,\tsize_add, 9, 0);\n\tcheck_one_size_helper(9,\tsize_add, 0, 9);\n\tcheck_one_size_helper(5,\tsize_add, 2, 3);\n\tcheck_one_size_helper(SIZE_MAX, size_add, SIZE_MAX,  1);\n\tcheck_one_size_helper(SIZE_MAX, size_add, SIZE_MAX,  3);\n\tcheck_one_size_helper(SIZE_MAX, size_add, SIZE_MAX, -3);\n\n\tvar = 4;\n\tcheck_one_size_helper(1,\tsize_sub, var--, 3);\n\tcheck_one_size_helper(1,\tsize_sub, 4, var--);\n\tcheck_one_size_helper(1,\tsize_sub, 3, 2);\n\tcheck_one_size_helper(9,\tsize_sub, 9, 0);\n\tcheck_one_size_helper(SIZE_MAX, size_sub, 9, -3);\n\tcheck_one_size_helper(SIZE_MAX, size_sub, 0, 9);\n\tcheck_one_size_helper(SIZE_MAX, size_sub, 2, 3);\n\tcheck_one_size_helper(SIZE_MAX, size_sub, SIZE_MAX,  0);\n\tcheck_one_size_helper(SIZE_MAX, size_sub, SIZE_MAX, 10);\n\tcheck_one_size_helper(SIZE_MAX, size_sub, 0,  SIZE_MAX);\n\tcheck_one_size_helper(SIZE_MAX, size_sub, 14, SIZE_MAX);\n\tcheck_one_size_helper(SIZE_MAX - 2, size_sub, SIZE_MAX - 1,  1);\n\tcheck_one_size_helper(SIZE_MAX - 4, size_sub, SIZE_MAX - 1,  3);\n\tcheck_one_size_helper(1,\t\tsize_sub, SIZE_MAX - 1, -3);\n\n\tvar = 4;\n\tcheck_one_size_helper(4 * sizeof(*obj->data),\n\t\t\t      flex_array_size, obj, data, var++);\n\tcheck_one_size_helper(5 * sizeof(*obj->data),\n\t\t\t      flex_array_size, obj, data, var++);\n\tcheck_one_size_helper(0, flex_array_size, obj, data, 0 + unconst);\n\tcheck_one_size_helper(sizeof(*obj->data),\n\t\t\t      flex_array_size, obj, data, 1 + unconst);\n\tcheck_one_size_helper(7 * sizeof(*obj->data),\n\t\t\t      flex_array_size, obj, data, 7 + unconst);\n\tcheck_one_size_helper(SIZE_MAX,\n\t\t\t      flex_array_size, obj, data, -1 + unconst);\n\tcheck_one_size_helper(SIZE_MAX,\n\t\t\t      flex_array_size, obj, data, SIZE_MAX - 4 + unconst);\n\n\tvar = 4;\n\tcheck_one_size_helper(sizeof(*obj) + (4 * sizeof(*obj->data)),\n\t\t\t      struct_size, obj, data, var++);\n\tcheck_one_size_helper(sizeof(*obj) + (5 * sizeof(*obj->data)),\n\t\t\t      struct_size, obj, data, var++);\n\tcheck_one_size_helper(sizeof(*obj), struct_size, obj, data, 0 + unconst);\n\tcheck_one_size_helper(sizeof(*obj) + sizeof(*obj->data),\n\t\t\t      struct_size, obj, data, 1 + unconst);\n\tcheck_one_size_helper(SIZE_MAX,\n\t\t\t      struct_size, obj, data, -3 + unconst);\n\tcheck_one_size_helper(SIZE_MAX,\n\t\t\t      struct_size, obj, data, SIZE_MAX - 3 + unconst);\n\n\tkunit_info(test, \"%d overflow size helper tests finished\\n\", count);\n#undef check_one_size_helper\n}\n\nstatic void overflows_type_test(struct kunit *test)\n{\n\tint count = 0;\n\tunsigned int var;\n\n#define __TEST_OVERFLOWS_TYPE(func, arg1, arg2, of)\tdo {\t\t\\\n\tbool __of = func(arg1, arg2);\t\t\t\t\t\\\n\tKUNIT_EXPECT_EQ_MSG(test, __of, of,\t\t\t\t\\\n\t\t\"expected \" #func \"(\" #arg1 \", \" #arg2 \" to%s overflow\\n\",\\\n\t\tof ? \"\" : \" not\");\t\t\t\t\t\\\n\tcount++;\t\t\t\t\t\t\t\\\n} while (0)\n\n \n#define TEST_OVERFLOWS_TYPE(__t1, __t2, v, of) do {\t\t\t\\\n\t__t1 t1 = (v);\t\t\t\t\t\t\t\\\n\t__t2 t2;\t\t\t\t\t\t\t\\\n\t__TEST_OVERFLOWS_TYPE(__overflows_type, t1, t2, of);\t\t\\\n\t__TEST_OVERFLOWS_TYPE(__overflows_type, t1, __t2, of);\t\t\\\n\t__TEST_OVERFLOWS_TYPE(__overflows_type_constexpr, t1, t2, of);\t\\\n\t__TEST_OVERFLOWS_TYPE(__overflows_type_constexpr, t1, __t2, of);\\\n} while (0)\n\n\tTEST_OVERFLOWS_TYPE(u8, u8, U8_MAX, false);\n\tTEST_OVERFLOWS_TYPE(u8, u16, U8_MAX, false);\n\tTEST_OVERFLOWS_TYPE(u8, s8, U8_MAX, true);\n\tTEST_OVERFLOWS_TYPE(u8, s8, S8_MAX, false);\n\tTEST_OVERFLOWS_TYPE(u8, s8, (u8)S8_MAX + 1, true);\n\tTEST_OVERFLOWS_TYPE(u8, s16, U8_MAX, false);\n\tTEST_OVERFLOWS_TYPE(s8, u8, S8_MAX, false);\n\tTEST_OVERFLOWS_TYPE(s8, u8, -1, true);\n\tTEST_OVERFLOWS_TYPE(s8, u8, S8_MIN, true);\n\tTEST_OVERFLOWS_TYPE(s8, u16, S8_MAX, false);\n\tTEST_OVERFLOWS_TYPE(s8, u16, -1, true);\n\tTEST_OVERFLOWS_TYPE(s8, u16, S8_MIN, true);\n\tTEST_OVERFLOWS_TYPE(s8, u32, S8_MAX, false);\n\tTEST_OVERFLOWS_TYPE(s8, u32, -1, true);\n\tTEST_OVERFLOWS_TYPE(s8, u32, S8_MIN, true);\n#if BITS_PER_LONG == 64\n\tTEST_OVERFLOWS_TYPE(s8, u64, S8_MAX, false);\n\tTEST_OVERFLOWS_TYPE(s8, u64, -1, true);\n\tTEST_OVERFLOWS_TYPE(s8, u64, S8_MIN, true);\n#endif\n\tTEST_OVERFLOWS_TYPE(s8, s8, S8_MAX, false);\n\tTEST_OVERFLOWS_TYPE(s8, s8, S8_MIN, false);\n\tTEST_OVERFLOWS_TYPE(s8, s16, S8_MAX, false);\n\tTEST_OVERFLOWS_TYPE(s8, s16, S8_MIN, false);\n\tTEST_OVERFLOWS_TYPE(u16, u8, U8_MAX, false);\n\tTEST_OVERFLOWS_TYPE(u16, u8, (u16)U8_MAX + 1, true);\n\tTEST_OVERFLOWS_TYPE(u16, u8, U16_MAX, true);\n\tTEST_OVERFLOWS_TYPE(u16, s8, S8_MAX, false);\n\tTEST_OVERFLOWS_TYPE(u16, s8, (u16)S8_MAX + 1, true);\n\tTEST_OVERFLOWS_TYPE(u16, s8, U16_MAX, true);\n\tTEST_OVERFLOWS_TYPE(u16, s16, S16_MAX, false);\n\tTEST_OVERFLOWS_TYPE(u16, s16, (u16)S16_MAX + 1, true);\n\tTEST_OVERFLOWS_TYPE(u16, s16, U16_MAX, true);\n\tTEST_OVERFLOWS_TYPE(u16, u32, U16_MAX, false);\n\tTEST_OVERFLOWS_TYPE(u16, s32, U16_MAX, false);\n\tTEST_OVERFLOWS_TYPE(s16, u8, U8_MAX, false);\n\tTEST_OVERFLOWS_TYPE(s16, u8, (s16)U8_MAX + 1, true);\n\tTEST_OVERFLOWS_TYPE(s16, u8, -1, true);\n\tTEST_OVERFLOWS_TYPE(s16, u8, S16_MIN, true);\n\tTEST_OVERFLOWS_TYPE(s16, u16, S16_MAX, false);\n\tTEST_OVERFLOWS_TYPE(s16, u16, -1, true);\n\tTEST_OVERFLOWS_TYPE(s16, u16, S16_MIN, true);\n\tTEST_OVERFLOWS_TYPE(s16, u32, S16_MAX, false);\n\tTEST_OVERFLOWS_TYPE(s16, u32, -1, true);\n\tTEST_OVERFLOWS_TYPE(s16, u32, S16_MIN, true);\n#if BITS_PER_LONG == 64\n\tTEST_OVERFLOWS_TYPE(s16, u64, S16_MAX, false);\n\tTEST_OVERFLOWS_TYPE(s16, u64, -1, true);\n\tTEST_OVERFLOWS_TYPE(s16, u64, S16_MIN, true);\n#endif\n\tTEST_OVERFLOWS_TYPE(s16, s8, S8_MAX, false);\n\tTEST_OVERFLOWS_TYPE(s16, s8, S8_MIN, false);\n\tTEST_OVERFLOWS_TYPE(s16, s8, (s16)S8_MAX + 1, true);\n\tTEST_OVERFLOWS_TYPE(s16, s8, (s16)S8_MIN - 1, true);\n\tTEST_OVERFLOWS_TYPE(s16, s8, S16_MAX, true);\n\tTEST_OVERFLOWS_TYPE(s16, s8, S16_MIN, true);\n\tTEST_OVERFLOWS_TYPE(s16, s16, S16_MAX, false);\n\tTEST_OVERFLOWS_TYPE(s16, s16, S16_MIN, false);\n\tTEST_OVERFLOWS_TYPE(s16, s32, S16_MAX, false);\n\tTEST_OVERFLOWS_TYPE(s16, s32, S16_MIN, false);\n\tTEST_OVERFLOWS_TYPE(u32, u8, U8_MAX, false);\n\tTEST_OVERFLOWS_TYPE(u32, u8, (u32)U8_MAX + 1, true);\n\tTEST_OVERFLOWS_TYPE(u32, u8, U32_MAX, true);\n\tTEST_OVERFLOWS_TYPE(u32, s8, S8_MAX, false);\n\tTEST_OVERFLOWS_TYPE(u32, s8, (u32)S8_MAX + 1, true);\n\tTEST_OVERFLOWS_TYPE(u32, s8, U32_MAX, true);\n\tTEST_OVERFLOWS_TYPE(u32, u16, U16_MAX, false);\n\tTEST_OVERFLOWS_TYPE(u32, u16, U16_MAX + 1, true);\n\tTEST_OVERFLOWS_TYPE(u32, u16, U32_MAX, true);\n\tTEST_OVERFLOWS_TYPE(u32, s16, S16_MAX, false);\n\tTEST_OVERFLOWS_TYPE(u32, s16, (u32)S16_MAX + 1, true);\n\tTEST_OVERFLOWS_TYPE(u32, s16, U32_MAX, true);\n\tTEST_OVERFLOWS_TYPE(u32, u32, U32_MAX, false);\n\tTEST_OVERFLOWS_TYPE(u32, s32, S32_MAX, false);\n\tTEST_OVERFLOWS_TYPE(u32, s32, U32_MAX, true);\n\tTEST_OVERFLOWS_TYPE(u32, s32, (u32)S32_MAX + 1, true);\n#if BITS_PER_LONG == 64\n\tTEST_OVERFLOWS_TYPE(u32, u64, U32_MAX, false);\n\tTEST_OVERFLOWS_TYPE(u32, s64, U32_MAX, false);\n#endif\n\tTEST_OVERFLOWS_TYPE(s32, u8, U8_MAX, false);\n\tTEST_OVERFLOWS_TYPE(s32, u8, (s32)U8_MAX + 1, true);\n\tTEST_OVERFLOWS_TYPE(s32, u16, S32_MAX, true);\n\tTEST_OVERFLOWS_TYPE(s32, u8, -1, true);\n\tTEST_OVERFLOWS_TYPE(s32, u8, S32_MIN, true);\n\tTEST_OVERFLOWS_TYPE(s32, u16, U16_MAX, false);\n\tTEST_OVERFLOWS_TYPE(s32, u16, (s32)U16_MAX + 1, true);\n\tTEST_OVERFLOWS_TYPE(s32, u16, S32_MAX, true);\n\tTEST_OVERFLOWS_TYPE(s32, u16, -1, true);\n\tTEST_OVERFLOWS_TYPE(s32, u16, S32_MIN, true);\n\tTEST_OVERFLOWS_TYPE(s32, u32, S32_MAX, false);\n\tTEST_OVERFLOWS_TYPE(s32, u32, -1, true);\n\tTEST_OVERFLOWS_TYPE(s32, u32, S32_MIN, true);\n#if BITS_PER_LONG == 64\n\tTEST_OVERFLOWS_TYPE(s32, u64, S32_MAX, false);\n\tTEST_OVERFLOWS_TYPE(s32, u64, -1, true);\n\tTEST_OVERFLOWS_TYPE(s32, u64, S32_MIN, true);\n#endif\n\tTEST_OVERFLOWS_TYPE(s32, s8, S8_MAX, false);\n\tTEST_OVERFLOWS_TYPE(s32, s8, S8_MIN, false);\n\tTEST_OVERFLOWS_TYPE(s32, s8, (s32)S8_MAX + 1, true);\n\tTEST_OVERFLOWS_TYPE(s32, s8, (s32)S8_MIN - 1, true);\n\tTEST_OVERFLOWS_TYPE(s32, s8, S32_MAX, true);\n\tTEST_OVERFLOWS_TYPE(s32, s8, S32_MIN, true);\n\tTEST_OVERFLOWS_TYPE(s32, s16, S16_MAX, false);\n\tTEST_OVERFLOWS_TYPE(s32, s16, S16_MIN, false);\n\tTEST_OVERFLOWS_TYPE(s32, s16, (s32)S16_MAX + 1, true);\n\tTEST_OVERFLOWS_TYPE(s32, s16, (s32)S16_MIN - 1, true);\n\tTEST_OVERFLOWS_TYPE(s32, s16, S32_MAX, true);\n\tTEST_OVERFLOWS_TYPE(s32, s16, S32_MIN, true);\n\tTEST_OVERFLOWS_TYPE(s32, s32, S32_MAX, false);\n\tTEST_OVERFLOWS_TYPE(s32, s32, S32_MIN, false);\n#if BITS_PER_LONG == 64\n\tTEST_OVERFLOWS_TYPE(s32, s64, S32_MAX, false);\n\tTEST_OVERFLOWS_TYPE(s32, s64, S32_MIN, false);\n\tTEST_OVERFLOWS_TYPE(u64, u8, U64_MAX, true);\n\tTEST_OVERFLOWS_TYPE(u64, u8, U8_MAX, false);\n\tTEST_OVERFLOWS_TYPE(u64, u8, (u64)U8_MAX + 1, true);\n\tTEST_OVERFLOWS_TYPE(u64, u16, U64_MAX, true);\n\tTEST_OVERFLOWS_TYPE(u64, u16, U16_MAX, false);\n\tTEST_OVERFLOWS_TYPE(u64, u16, (u64)U16_MAX + 1, true);\n\tTEST_OVERFLOWS_TYPE(u64, u32, U64_MAX, true);\n\tTEST_OVERFLOWS_TYPE(u64, u32, U32_MAX, false);\n\tTEST_OVERFLOWS_TYPE(u64, u32, (u64)U32_MAX + 1, true);\n\tTEST_OVERFLOWS_TYPE(u64, u64, U64_MAX, false);\n\tTEST_OVERFLOWS_TYPE(u64, s8, S8_MAX, false);\n\tTEST_OVERFLOWS_TYPE(u64, s8, (u64)S8_MAX + 1, true);\n\tTEST_OVERFLOWS_TYPE(u64, s8, U64_MAX, true);\n\tTEST_OVERFLOWS_TYPE(u64, s16, S16_MAX, false);\n\tTEST_OVERFLOWS_TYPE(u64, s16, (u64)S16_MAX + 1, true);\n\tTEST_OVERFLOWS_TYPE(u64, s16, U64_MAX, true);\n\tTEST_OVERFLOWS_TYPE(u64, s32, S32_MAX, false);\n\tTEST_OVERFLOWS_TYPE(u64, s32, (u64)S32_MAX + 1, true);\n\tTEST_OVERFLOWS_TYPE(u64, s32, U64_MAX, true);\n\tTEST_OVERFLOWS_TYPE(u64, s64, S64_MAX, false);\n\tTEST_OVERFLOWS_TYPE(u64, s64, U64_MAX, true);\n\tTEST_OVERFLOWS_TYPE(u64, s64, (u64)S64_MAX + 1, true);\n\tTEST_OVERFLOWS_TYPE(s64, u8, S64_MAX, true);\n\tTEST_OVERFLOWS_TYPE(s64, u8, S64_MIN, true);\n\tTEST_OVERFLOWS_TYPE(s64, u8, -1, true);\n\tTEST_OVERFLOWS_TYPE(s64, u8, U8_MAX, false);\n\tTEST_OVERFLOWS_TYPE(s64, u8, (s64)U8_MAX + 1, true);\n\tTEST_OVERFLOWS_TYPE(s64, u16, S64_MAX, true);\n\tTEST_OVERFLOWS_TYPE(s64, u16, S64_MIN, true);\n\tTEST_OVERFLOWS_TYPE(s64, u16, -1, true);\n\tTEST_OVERFLOWS_TYPE(s64, u16, U16_MAX, false);\n\tTEST_OVERFLOWS_TYPE(s64, u16, (s64)U16_MAX + 1, true);\n\tTEST_OVERFLOWS_TYPE(s64, u32, S64_MAX, true);\n\tTEST_OVERFLOWS_TYPE(s64, u32, S64_MIN, true);\n\tTEST_OVERFLOWS_TYPE(s64, u32, -1, true);\n\tTEST_OVERFLOWS_TYPE(s64, u32, U32_MAX, false);\n\tTEST_OVERFLOWS_TYPE(s64, u32, (s64)U32_MAX + 1, true);\n\tTEST_OVERFLOWS_TYPE(s64, u64, S64_MAX, false);\n\tTEST_OVERFLOWS_TYPE(s64, u64, S64_MIN, true);\n\tTEST_OVERFLOWS_TYPE(s64, u64, -1, true);\n\tTEST_OVERFLOWS_TYPE(s64, s8, S8_MAX, false);\n\tTEST_OVERFLOWS_TYPE(s64, s8, S8_MIN, false);\n\tTEST_OVERFLOWS_TYPE(s64, s8, (s64)S8_MAX + 1, true);\n\tTEST_OVERFLOWS_TYPE(s64, s8, (s64)S8_MIN - 1, true);\n\tTEST_OVERFLOWS_TYPE(s64, s8, S64_MAX, true);\n\tTEST_OVERFLOWS_TYPE(s64, s16, S16_MAX, false);\n\tTEST_OVERFLOWS_TYPE(s64, s16, S16_MIN, false);\n\tTEST_OVERFLOWS_TYPE(s64, s16, (s64)S16_MAX + 1, true);\n\tTEST_OVERFLOWS_TYPE(s64, s16, (s64)S16_MIN - 1, true);\n\tTEST_OVERFLOWS_TYPE(s64, s16, S64_MAX, true);\n\tTEST_OVERFLOWS_TYPE(s64, s32, S32_MAX, false);\n\tTEST_OVERFLOWS_TYPE(s64, s32, S32_MIN, false);\n\tTEST_OVERFLOWS_TYPE(s64, s32, (s64)S32_MAX + 1, true);\n\tTEST_OVERFLOWS_TYPE(s64, s32, (s64)S32_MIN - 1, true);\n\tTEST_OVERFLOWS_TYPE(s64, s32, S64_MAX, true);\n\tTEST_OVERFLOWS_TYPE(s64, s64, S64_MAX, false);\n\tTEST_OVERFLOWS_TYPE(s64, s64, S64_MIN, false);\n#endif\n\n\t \n\tvar = INT_MAX - 1;\n\t__TEST_OVERFLOWS_TYPE(__overflows_type, var++, int, false);\n\t__TEST_OVERFLOWS_TYPE(__overflows_type, var++, int, false);\n\t__TEST_OVERFLOWS_TYPE(__overflows_type, var++, int, true);\n\tvar = INT_MAX - 1;\n\t__TEST_OVERFLOWS_TYPE(overflows_type, var++, int, false);\n\t__TEST_OVERFLOWS_TYPE(overflows_type, var++, int, false);\n\t__TEST_OVERFLOWS_TYPE(overflows_type, var++, int, true);\n\n\tkunit_info(test, \"%d overflows_type() tests finished\\n\", count);\n#undef TEST_OVERFLOWS_TYPE\n#undef __TEST_OVERFLOWS_TYPE\n}\n\nstatic void same_type_test(struct kunit *test)\n{\n\tint count = 0;\n\tint var;\n\n#define TEST_SAME_TYPE(t1, t2, same)\t\t\tdo {\t\\\n\ttypeof(t1) __t1h = type_max(t1);\t\t\t\\\n\ttypeof(t1) __t1l = type_min(t1);\t\t\t\\\n\ttypeof(t2) __t2h = type_max(t2);\t\t\t\\\n\ttypeof(t2) __t2l = type_min(t2);\t\t\t\\\n\tKUNIT_EXPECT_EQ(test, true, __same_type(t1, __t1h));\t\\\n\tKUNIT_EXPECT_EQ(test, true, __same_type(t1, __t1l));\t\\\n\tKUNIT_EXPECT_EQ(test, true, __same_type(__t1h, t1));\t\\\n\tKUNIT_EXPECT_EQ(test, true, __same_type(__t1l, t1));\t\\\n\tKUNIT_EXPECT_EQ(test, true, __same_type(t2, __t2h));\t\\\n\tKUNIT_EXPECT_EQ(test, true, __same_type(t2, __t2l));\t\\\n\tKUNIT_EXPECT_EQ(test, true, __same_type(__t2h, t2));\t\\\n\tKUNIT_EXPECT_EQ(test, true, __same_type(__t2l, t2));\t\\\n\tKUNIT_EXPECT_EQ(test, same, __same_type(t1, t2));\t\\\n\tKUNIT_EXPECT_EQ(test, same, __same_type(t2, __t1h));\t\\\n\tKUNIT_EXPECT_EQ(test, same, __same_type(t2, __t1l));\t\\\n\tKUNIT_EXPECT_EQ(test, same, __same_type(__t1h, t2));\t\\\n\tKUNIT_EXPECT_EQ(test, same, __same_type(__t1l, t2));\t\\\n\tKUNIT_EXPECT_EQ(test, same, __same_type(t1, __t2h));\t\\\n\tKUNIT_EXPECT_EQ(test, same, __same_type(t1, __t2l));\t\\\n\tKUNIT_EXPECT_EQ(test, same, __same_type(__t2h, t1));\t\\\n\tKUNIT_EXPECT_EQ(test, same, __same_type(__t2l, t1));\t\\\n} while (0)\n\n#if BITS_PER_LONG == 64\n# define TEST_SAME_TYPE64(base, t, m)\tTEST_SAME_TYPE(base, t, m)\n#else\n# define TEST_SAME_TYPE64(base, t, m)\tdo { } while (0)\n#endif\n\n#define TEST_TYPE_SETS(base, mu8, mu16, mu32, ms8, ms16, ms32, mu64, ms64) \\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tTEST_SAME_TYPE(base,  u8,  mu8);\t\t\t\t\\\n\tTEST_SAME_TYPE(base, u16, mu16);\t\t\t\t\\\n\tTEST_SAME_TYPE(base, u32, mu32);\t\t\t\t\\\n\tTEST_SAME_TYPE(base,  s8,  ms8);\t\t\t\t\\\n\tTEST_SAME_TYPE(base, s16, ms16);\t\t\t\t\\\n\tTEST_SAME_TYPE(base, s32, ms32);\t\t\t\t\\\n\tTEST_SAME_TYPE64(base, u64, mu64);\t\t\t\t\\\n\tTEST_SAME_TYPE64(base, s64, ms64);\t\t\t\t\\\n} while (0)\n\n\tTEST_TYPE_SETS(u8,   true, false, false, false, false, false, false, false);\n\tTEST_TYPE_SETS(u16, false,  true, false, false, false, false, false, false);\n\tTEST_TYPE_SETS(u32, false, false,  true, false, false, false, false, false);\n\tTEST_TYPE_SETS(s8,  false, false, false,  true, false, false, false, false);\n\tTEST_TYPE_SETS(s16, false, false, false, false,  true, false, false, false);\n\tTEST_TYPE_SETS(s32, false, false, false, false, false,  true, false, false);\n#if BITS_PER_LONG == 64\n\tTEST_TYPE_SETS(u64, false, false, false, false, false, false,  true, false);\n\tTEST_TYPE_SETS(s64, false, false, false, false, false, false, false,  true);\n#endif\n\n\t \n\tvar = 4;\n\tKUNIT_EXPECT_EQ(test, var, 4);\n\tKUNIT_EXPECT_TRUE(test, __same_type(var++, int));\n\tKUNIT_EXPECT_EQ(test, var, 4);\n\tKUNIT_EXPECT_TRUE(test, __same_type(int, var++));\n\tKUNIT_EXPECT_EQ(test, var, 4);\n\tKUNIT_EXPECT_TRUE(test, __same_type(var++, var++));\n\tKUNIT_EXPECT_EQ(test, var, 4);\n\n\tkunit_info(test, \"%d __same_type() tests finished\\n\", count);\n\n#undef TEST_TYPE_SETS\n#undef TEST_SAME_TYPE64\n#undef TEST_SAME_TYPE\n}\n\nstatic void castable_to_type_test(struct kunit *test)\n{\n\tint count = 0;\n\n#define TEST_CASTABLE_TO_TYPE(arg1, arg2, pass)\tdo {\t\\\n\tbool __pass = castable_to_type(arg1, arg2);\t\t\\\n\tKUNIT_EXPECT_EQ_MSG(test, __pass, pass,\t\t\t\\\n\t\t\"expected castable_to_type(\" #arg1 \", \" #arg2 \") to%s pass\\n\",\\\n\t\tpass ? \"\" : \" not\");\t\t\t\t\\\n\tcount++;\t\t\t\t\t\t\\\n} while (0)\n\n\tTEST_CASTABLE_TO_TYPE(16, u8, true);\n\tTEST_CASTABLE_TO_TYPE(16, u16, true);\n\tTEST_CASTABLE_TO_TYPE(16, u32, true);\n\tTEST_CASTABLE_TO_TYPE(16, s8, true);\n\tTEST_CASTABLE_TO_TYPE(16, s16, true);\n\tTEST_CASTABLE_TO_TYPE(16, s32, true);\n\tTEST_CASTABLE_TO_TYPE(-16, s8, true);\n\tTEST_CASTABLE_TO_TYPE(-16, s16, true);\n\tTEST_CASTABLE_TO_TYPE(-16, s32, true);\n#if BITS_PER_LONG == 64\n\tTEST_CASTABLE_TO_TYPE(16, u64, true);\n\tTEST_CASTABLE_TO_TYPE(-16, s64, true);\n#endif\n\n#define TEST_CASTABLE_TO_TYPE_VAR(width)\tdo {\t\t\t\t\\\n\tu ## width u ## width ## var = 0;\t\t\t\t\t\\\n\ts ## width s ## width ## var = 0;\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\t\\\n\t \t\t\t\t\\\n\tTEST_CASTABLE_TO_TYPE(type_max(u ## width), u ## width, true);\t\t\\\n\tTEST_CASTABLE_TO_TYPE(type_min(u ## width), u ## width, true);\t\t\\\n\tTEST_CASTABLE_TO_TYPE(type_max(u ## width), u ## width ## var, true);\t\\\n\tTEST_CASTABLE_TO_TYPE(type_min(u ## width), u ## width ## var, true);\t\\\n\tTEST_CASTABLE_TO_TYPE(type_max(s ## width), s ## width, true);\t\t\\\n\tTEST_CASTABLE_TO_TYPE(type_min(s ## width), s ## width, true);\t\t\\\n\tTEST_CASTABLE_TO_TYPE(type_max(s ## width), s ## width ## var, true);\t\\\n\tTEST_CASTABLE_TO_TYPE(type_min(u ## width), s ## width ## var, true);\t\\\n\t \t\t\t\\\n\tTEST_CASTABLE_TO_TYPE(type_max(u ## width), s ## width, false);\t\t\\\n\tTEST_CASTABLE_TO_TYPE(type_max(u ## width), s ## width ## var, false);\t\\\n\tTEST_CASTABLE_TO_TYPE(type_min(s ## width), u ## width, false);\t\t\\\n\tTEST_CASTABLE_TO_TYPE(type_min(s ## width), u ## width ## var, false);\t\\\n\t \t\t\t\\\n\tTEST_CASTABLE_TO_TYPE(s ## width ## var, u ## width, false);\t\t\\\n\tTEST_CASTABLE_TO_TYPE(u ## width ## var, s ## width, false);\t\t\\\n} while (0)\n\n#define TEST_CASTABLE_TO_TYPE_RANGE(width)\tdo {\t\t\t\t\\\n\tunsigned long big = U ## width ## _MAX;\t\t\t\t\t\\\n\tsigned long small = S ## width ## _MIN;\t\t\t\t\t\\\n\tu ## width u ## width ## var = 0;\t\t\t\t\t\\\n\ts ## width s ## width ## var = 0;\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\t\\\n\t \t\t\t\t\t\\\n\tTEST_CASTABLE_TO_TYPE(U ## width ## _MAX, u ## width, true);\t\t\\\n\tTEST_CASTABLE_TO_TYPE(U ## width ## _MAX, u ## width ## var, true);\t\\\n\tTEST_CASTABLE_TO_TYPE(S ## width ## _MIN, s ## width, true);\t\t\\\n\tTEST_CASTABLE_TO_TYPE(S ## width ## _MIN, s ## width ## var, true);\t\\\n\t \t\t\t\t\t\\\n\tTEST_CASTABLE_TO_TYPE((unsigned long)U ## width ## _MAX + 1, u ## width, false); \\\n\tTEST_CASTABLE_TO_TYPE((unsigned long)U ## width ## _MAX + 1, u ## width ## var, false); \\\n\tTEST_CASTABLE_TO_TYPE((signed long)S ## width ## _MIN - 1, s ## width, false); \\\n\tTEST_CASTABLE_TO_TYPE((signed long)S ## width ## _MIN - 1, s ## width ## var, false); \\\n\t \t\t\t\\\n\tTEST_CASTABLE_TO_TYPE(big, u ## width, false);\t\t\t\t\\\n\tTEST_CASTABLE_TO_TYPE(big, u ## width ## var, false);\t\t\t\\\n\tTEST_CASTABLE_TO_TYPE(small, s ## width, false);\t\t\t\\\n\tTEST_CASTABLE_TO_TYPE(small, s ## width ## var, false);\t\t\t\\\n} while (0)\n\n\tTEST_CASTABLE_TO_TYPE_VAR(8);\n\tTEST_CASTABLE_TO_TYPE_VAR(16);\n\tTEST_CASTABLE_TO_TYPE_VAR(32);\n#if BITS_PER_LONG == 64\n\tTEST_CASTABLE_TO_TYPE_VAR(64);\n#endif\n\n\tTEST_CASTABLE_TO_TYPE_RANGE(8);\n\tTEST_CASTABLE_TO_TYPE_RANGE(16);\n#if BITS_PER_LONG == 64\n\tTEST_CASTABLE_TO_TYPE_RANGE(32);\n#endif\n\tkunit_info(test, \"%d castable_to_type() tests finished\\n\", count);\n\n#undef TEST_CASTABLE_TO_TYPE_RANGE\n#undef TEST_CASTABLE_TO_TYPE_VAR\n#undef TEST_CASTABLE_TO_TYPE\n}\n\nstatic struct kunit_case overflow_test_cases[] = {\n\tKUNIT_CASE(u8_u8__u8_overflow_test),\n\tKUNIT_CASE(s8_s8__s8_overflow_test),\n\tKUNIT_CASE(u16_u16__u16_overflow_test),\n\tKUNIT_CASE(s16_s16__s16_overflow_test),\n\tKUNIT_CASE(u32_u32__u32_overflow_test),\n\tKUNIT_CASE(s32_s32__s32_overflow_test),\n\tKUNIT_CASE(u64_u64__u64_overflow_test),\n\tKUNIT_CASE(s64_s64__s64_overflow_test),\n\tKUNIT_CASE(u32_u32__int_overflow_test),\n\tKUNIT_CASE(u32_u32__u8_overflow_test),\n\tKUNIT_CASE(u8_u8__int_overflow_test),\n\tKUNIT_CASE(int_int__u8_overflow_test),\n\tKUNIT_CASE(shift_sane_test),\n\tKUNIT_CASE(shift_overflow_test),\n\tKUNIT_CASE(shift_truncate_test),\n\tKUNIT_CASE(shift_nonsense_test),\n\tKUNIT_CASE(overflow_allocation_test),\n\tKUNIT_CASE(overflow_size_helpers_test),\n\tKUNIT_CASE(overflows_type_test),\n\tKUNIT_CASE(same_type_test),\n\tKUNIT_CASE(castable_to_type_test),\n\t{}\n};\n\nstatic struct kunit_suite overflow_test_suite = {\n\t.name = \"overflow\",\n\t.test_cases = overflow_test_cases,\n};\n\nkunit_test_suite(overflow_test_suite);\n\nMODULE_LICENSE(\"Dual MIT/GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}