{
  "module_name": "lz4hc_compress.c",
  "hash_id": "cfc75579b583f738cd28c7348affdd38a892072cc56652ff858c2d112fee0dc9",
  "original_prompt": "Ingested from linux-6.6.14/lib/lz4/lz4hc_compress.c",
  "human_readable_source": " \n\n \n#include <linux/lz4.h>\n#include \"lz4defs.h\"\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/string.h>  \n\n \n\n#define OPTIMAL_ML (int)((ML_MASK - 1) + MINMATCH)\n\n#define HASH_FUNCTION(i)\t(((i) * 2654435761U) \\\n\t>> ((MINMATCH*8) - LZ4HC_HASH_LOG))\n#define DELTANEXTU16(p)\tchainTable[(U16)(p)]  \n\nstatic U32 LZ4HC_hashPtr(const void *ptr)\n{\n\treturn HASH_FUNCTION(LZ4_read32(ptr));\n}\n\n \nstatic void LZ4HC_init(LZ4HC_CCtx_internal *hc4, const BYTE *start)\n{\n\tmemset((void *)hc4->hashTable, 0, sizeof(hc4->hashTable));\n\tmemset(hc4->chainTable, 0xFF, sizeof(hc4->chainTable));\n\thc4->nextToUpdate = 64 * KB;\n\thc4->base = start - 64 * KB;\n\thc4->end = start;\n\thc4->dictBase = start - 64 * KB;\n\thc4->dictLimit = 64 * KB;\n\thc4->lowLimit = 64 * KB;\n}\n\n \nstatic FORCE_INLINE void LZ4HC_Insert(LZ4HC_CCtx_internal *hc4,\n\tconst BYTE *ip)\n{\n\tU16 * const chainTable = hc4->chainTable;\n\tU32 * const hashTable\t= hc4->hashTable;\n\tconst BYTE * const base = hc4->base;\n\tU32 const target = (U32)(ip - base);\n\tU32 idx = hc4->nextToUpdate;\n\n\twhile (idx < target) {\n\t\tU32 const h = LZ4HC_hashPtr(base + idx);\n\t\tsize_t delta = idx - hashTable[h];\n\n\t\tif (delta > MAX_DISTANCE)\n\t\t\tdelta = MAX_DISTANCE;\n\n\t\tDELTANEXTU16(idx) = (U16)delta;\n\n\t\thashTable[h] = idx;\n\t\tidx++;\n\t}\n\n\thc4->nextToUpdate = target;\n}\n\nstatic FORCE_INLINE int LZ4HC_InsertAndFindBestMatch(\n\tLZ4HC_CCtx_internal *hc4,  \n\tconst BYTE *ip,\n\tconst BYTE * const iLimit,\n\tconst BYTE **matchpos,\n\tconst int maxNbAttempts)\n{\n\tU16 * const chainTable = hc4->chainTable;\n\tU32 * const HashTable = hc4->hashTable;\n\tconst BYTE * const base = hc4->base;\n\tconst BYTE * const dictBase = hc4->dictBase;\n\tconst U32 dictLimit = hc4->dictLimit;\n\tconst U32 lowLimit = (hc4->lowLimit + 64 * KB > (U32)(ip - base))\n\t\t? hc4->lowLimit\n\t\t: (U32)(ip - base) - (64 * KB - 1);\n\tU32 matchIndex;\n\tint nbAttempts = maxNbAttempts;\n\tsize_t ml = 0;\n\n\t \n\tLZ4HC_Insert(hc4, ip);\n\tmatchIndex = HashTable[LZ4HC_hashPtr(ip)];\n\n\twhile ((matchIndex >= lowLimit)\n\t\t&& (nbAttempts)) {\n\t\tnbAttempts--;\n\t\tif (matchIndex >= dictLimit) {\n\t\t\tconst BYTE * const match = base + matchIndex;\n\n\t\t\tif (*(match + ml) == *(ip + ml)\n\t\t\t\t&& (LZ4_read32(match) == LZ4_read32(ip))) {\n\t\t\t\tsize_t const mlt = LZ4_count(ip + MINMATCH,\n\t\t\t\t\tmatch + MINMATCH, iLimit) + MINMATCH;\n\n\t\t\t\tif (mlt > ml) {\n\t\t\t\t\tml = mlt;\n\t\t\t\t\t*matchpos = match;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tconst BYTE * const match = dictBase + matchIndex;\n\n\t\t\tif (LZ4_read32(match) == LZ4_read32(ip)) {\n\t\t\t\tsize_t mlt;\n\t\t\t\tconst BYTE *vLimit = ip\n\t\t\t\t\t+ (dictLimit - matchIndex);\n\n\t\t\t\tif (vLimit > iLimit)\n\t\t\t\t\tvLimit = iLimit;\n\t\t\t\tmlt = LZ4_count(ip + MINMATCH,\n\t\t\t\t\tmatch + MINMATCH, vLimit) + MINMATCH;\n\t\t\t\tif ((ip + mlt == vLimit)\n\t\t\t\t\t&& (vLimit < iLimit))\n\t\t\t\t\tmlt += LZ4_count(ip + mlt,\n\t\t\t\t\t\tbase + dictLimit,\n\t\t\t\t\t\tiLimit);\n\t\t\t\tif (mlt > ml) {\n\t\t\t\t\t \n\t\t\t\t\tml = mlt;\n\t\t\t\t\t*matchpos = base + matchIndex;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmatchIndex -= DELTANEXTU16(matchIndex);\n\t}\n\n\treturn (int)ml;\n}\n\nstatic FORCE_INLINE int LZ4HC_InsertAndGetWiderMatch(\n\tLZ4HC_CCtx_internal *hc4,\n\tconst BYTE * const ip,\n\tconst BYTE * const iLowLimit,\n\tconst BYTE * const iHighLimit,\n\tint longest,\n\tconst BYTE **matchpos,\n\tconst BYTE **startpos,\n\tconst int maxNbAttempts)\n{\n\tU16 * const chainTable = hc4->chainTable;\n\tU32 * const HashTable = hc4->hashTable;\n\tconst BYTE * const base = hc4->base;\n\tconst U32 dictLimit = hc4->dictLimit;\n\tconst BYTE * const lowPrefixPtr = base + dictLimit;\n\tconst U32 lowLimit = (hc4->lowLimit + 64 * KB > (U32)(ip - base))\n\t\t? hc4->lowLimit\n\t\t: (U32)(ip - base) - (64 * KB - 1);\n\tconst BYTE * const dictBase = hc4->dictBase;\n\tU32 matchIndex;\n\tint nbAttempts = maxNbAttempts;\n\tint delta = (int)(ip - iLowLimit);\n\n\t \n\tLZ4HC_Insert(hc4, ip);\n\tmatchIndex = HashTable[LZ4HC_hashPtr(ip)];\n\n\twhile ((matchIndex >= lowLimit)\n\t\t&& (nbAttempts)) {\n\t\tnbAttempts--;\n\t\tif (matchIndex >= dictLimit) {\n\t\t\tconst BYTE *matchPtr = base + matchIndex;\n\n\t\t\tif (*(iLowLimit + longest)\n\t\t\t\t== *(matchPtr - delta + longest)) {\n\t\t\t\tif (LZ4_read32(matchPtr) == LZ4_read32(ip)) {\n\t\t\t\t\tint mlt = MINMATCH + LZ4_count(\n\t\t\t\t\t\tip + MINMATCH,\n\t\t\t\t\t\tmatchPtr + MINMATCH,\n\t\t\t\t\t\tiHighLimit);\n\t\t\t\t\tint back = 0;\n\n\t\t\t\t\twhile ((ip + back > iLowLimit)\n\t\t\t\t\t\t&& (matchPtr + back > lowPrefixPtr)\n\t\t\t\t\t\t&& (ip[back - 1] == matchPtr[back - 1]))\n\t\t\t\t\t\tback--;\n\n\t\t\t\t\tmlt -= back;\n\n\t\t\t\t\tif (mlt > longest) {\n\t\t\t\t\t\tlongest = (int)mlt;\n\t\t\t\t\t\t*matchpos = matchPtr + back;\n\t\t\t\t\t\t*startpos = ip + back;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tconst BYTE * const matchPtr = dictBase + matchIndex;\n\n\t\t\tif (LZ4_read32(matchPtr) == LZ4_read32(ip)) {\n\t\t\t\tsize_t mlt;\n\t\t\t\tint back = 0;\n\t\t\t\tconst BYTE *vLimit = ip + (dictLimit - matchIndex);\n\n\t\t\t\tif (vLimit > iHighLimit)\n\t\t\t\t\tvLimit = iHighLimit;\n\n\t\t\t\tmlt = LZ4_count(ip + MINMATCH,\n\t\t\t\t\tmatchPtr + MINMATCH, vLimit) + MINMATCH;\n\n\t\t\t\tif ((ip + mlt == vLimit) && (vLimit < iHighLimit))\n\t\t\t\t\tmlt += LZ4_count(ip + mlt, base + dictLimit,\n\t\t\t\t\t\tiHighLimit);\n\t\t\t\twhile ((ip + back > iLowLimit)\n\t\t\t\t\t&& (matchIndex + back > lowLimit)\n\t\t\t\t\t&& (ip[back - 1] == matchPtr[back - 1]))\n\t\t\t\t\tback--;\n\n\t\t\t\tmlt -= back;\n\n\t\t\t\tif ((int)mlt > longest) {\n\t\t\t\t\tlongest = (int)mlt;\n\t\t\t\t\t*matchpos = base + matchIndex + back;\n\t\t\t\t\t*startpos = ip + back;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tmatchIndex -= DELTANEXTU16(matchIndex);\n\t}\n\n\treturn longest;\n}\n\nstatic FORCE_INLINE int LZ4HC_encodeSequence(\n\tconst BYTE **ip,\n\tBYTE **op,\n\tconst BYTE **anchor,\n\tint matchLength,\n\tconst BYTE * const match,\n\tlimitedOutput_directive limitedOutputBuffer,\n\tBYTE *oend)\n{\n\tint length;\n\tBYTE *token;\n\n\t \n\tlength = (int)(*ip - *anchor);\n\ttoken = (*op)++;\n\n\tif ((limitedOutputBuffer)\n\t\t&& ((*op + (length>>8)\n\t\t\t+ length + (2 + 1 + LASTLITERALS)) > oend)) {\n\t\t \n\t\treturn 1;\n\t}\n\tif (length >= (int)RUN_MASK) {\n\t\tint len;\n\n\t\t*token = (RUN_MASK<<ML_BITS);\n\t\tlen = length - RUN_MASK;\n\t\tfor (; len > 254 ; len -= 255)\n\t\t\t*(*op)++ = 255;\n\t\t*(*op)++ = (BYTE)len;\n\t} else\n\t\t*token = (BYTE)(length<<ML_BITS);\n\n\t \n\tLZ4_wildCopy(*op, *anchor, (*op) + length);\n\t*op += length;\n\n\t \n\tLZ4_writeLE16(*op, (U16)(*ip - match));\n\t*op += 2;\n\n\t \n\tlength = (int)(matchLength - MINMATCH);\n\n\tif ((limitedOutputBuffer)\n\t\t&& (*op + (length>>8)\n\t\t\t+ (1 + LASTLITERALS) > oend)) {\n\t\t \n\t\treturn 1;\n\t}\n\n\tif (length >= (int)ML_MASK) {\n\t\t*token += ML_MASK;\n\t\tlength -= ML_MASK;\n\n\t\tfor (; length > 509 ; length -= 510) {\n\t\t\t*(*op)++ = 255;\n\t\t\t*(*op)++ = 255;\n\t\t}\n\n\t\tif (length > 254) {\n\t\t\tlength -= 255;\n\t\t\t*(*op)++ = 255;\n\t\t}\n\n\t\t*(*op)++ = (BYTE)length;\n\t} else\n\t\t*token += (BYTE)(length);\n\n\t \n\t*ip += matchLength;\n\t*anchor = *ip;\n\n\treturn 0;\n}\n\nstatic int LZ4HC_compress_generic(\n\tLZ4HC_CCtx_internal *const ctx,\n\tconst char * const source,\n\tchar * const dest,\n\tint const inputSize,\n\tint const maxOutputSize,\n\tint compressionLevel,\n\tlimitedOutput_directive limit\n\t)\n{\n\tconst BYTE *ip = (const BYTE *) source;\n\tconst BYTE *anchor = ip;\n\tconst BYTE * const iend = ip + inputSize;\n\tconst BYTE * const mflimit = iend - MFLIMIT;\n\tconst BYTE * const matchlimit = (iend - LASTLITERALS);\n\n\tBYTE *op = (BYTE *) dest;\n\tBYTE * const oend = op + maxOutputSize;\n\n\tunsigned int maxNbAttempts;\n\tint ml, ml2, ml3, ml0;\n\tconst BYTE *ref = NULL;\n\tconst BYTE *start2 = NULL;\n\tconst BYTE *ref2 = NULL;\n\tconst BYTE *start3 = NULL;\n\tconst BYTE *ref3 = NULL;\n\tconst BYTE *start0;\n\tconst BYTE *ref0;\n\n\t \n\tif (compressionLevel > LZ4HC_MAX_CLEVEL)\n\t\tcompressionLevel = LZ4HC_MAX_CLEVEL;\n\tif (compressionLevel < 1)\n\t\tcompressionLevel = LZ4HC_DEFAULT_CLEVEL;\n\tmaxNbAttempts = 1 << (compressionLevel - 1);\n\tctx->end += inputSize;\n\n\tip++;\n\n\t \n\twhile (ip < mflimit) {\n\t\tml = LZ4HC_InsertAndFindBestMatch(ctx, ip,\n\t\t\tmatchlimit, (&ref), maxNbAttempts);\n\t\tif (!ml) {\n\t\t\tip++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tstart0 = ip;\n\t\tref0 = ref;\n\t\tml0 = ml;\n\n_Search2:\n\t\tif (ip + ml < mflimit)\n\t\t\tml2 = LZ4HC_InsertAndGetWiderMatch(ctx,\n\t\t\t\tip + ml - 2, ip + 0,\n\t\t\t\tmatchlimit, ml, &ref2,\n\t\t\t\t&start2, maxNbAttempts);\n\t\telse\n\t\t\tml2 = ml;\n\n\t\tif (ml2 == ml) {\n\t\t\t \n\t\t\tif (LZ4HC_encodeSequence(&ip, &op,\n\t\t\t\t&anchor, ml, ref, limit, oend))\n\t\t\t\treturn 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (start0 < ip) {\n\t\t\tif (start2 < ip + ml0) {\n\t\t\t\t \n\t\t\t\tip = start0;\n\t\t\t\tref = ref0;\n\t\t\t\tml = ml0;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif ((start2 - ip) < 3) {\n\t\t\t \n\t\t\tml = ml2;\n\t\t\tip = start2;\n\t\t\tref = ref2;\n\t\t\tgoto _Search2;\n\t\t}\n\n_Search3:\n\t\t \n\t\tif ((start2 - ip) < OPTIMAL_ML) {\n\t\t\tint correction;\n\t\t\tint new_ml = ml;\n\n\t\t\tif (new_ml > OPTIMAL_ML)\n\t\t\t\tnew_ml = OPTIMAL_ML;\n\t\t\tif (ip + new_ml > start2 + ml2 - MINMATCH)\n\t\t\t\tnew_ml = (int)(start2 - ip) + ml2 - MINMATCH;\n\n\t\t\tcorrection = new_ml - (int)(start2 - ip);\n\n\t\t\tif (correction > 0) {\n\t\t\t\tstart2 += correction;\n\t\t\t\tref2 += correction;\n\t\t\t\tml2 -= correction;\n\t\t\t}\n\t\t}\n\t\t \n\n\t\tif (start2 + ml2 < mflimit)\n\t\t\tml3 = LZ4HC_InsertAndGetWiderMatch(ctx,\n\t\t\t\tstart2 + ml2 - 3, start2,\n\t\t\t\tmatchlimit, ml2, &ref3, &start3,\n\t\t\t\tmaxNbAttempts);\n\t\telse\n\t\t\tml3 = ml2;\n\n\t\tif (ml3 == ml2) {\n\t\t\t \n\t\t\t \n\t\t\tif (start2 < ip + ml)\n\t\t\t\tml = (int)(start2 - ip);\n\t\t\t \n\t\t\tif (LZ4HC_encodeSequence(&ip, &op, &anchor,\n\t\t\t\tml, ref, limit, oend))\n\t\t\t\treturn 0;\n\t\t\tip = start2;\n\t\t\tif (LZ4HC_encodeSequence(&ip, &op, &anchor,\n\t\t\t\tml2, ref2, limit, oend))\n\t\t\t\treturn 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (start3 < ip + ml + 3) {\n\t\t\t \n\t\t\tif (start3 >= (ip + ml)) {\n\t\t\t\t \n\t\t\t\tif (start2 < ip + ml) {\n\t\t\t\t\tint correction = (int)(ip + ml - start2);\n\n\t\t\t\t\tstart2 += correction;\n\t\t\t\t\tref2 += correction;\n\t\t\t\t\tml2 -= correction;\n\t\t\t\t\tif (ml2 < MINMATCH) {\n\t\t\t\t\t\tstart2 = start3;\n\t\t\t\t\t\tref2 = ref3;\n\t\t\t\t\t\tml2 = ml3;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (LZ4HC_encodeSequence(&ip, &op, &anchor,\n\t\t\t\t\tml, ref, limit, oend))\n\t\t\t\t\treturn 0;\n\t\t\t\tip = start3;\n\t\t\t\tref = ref3;\n\t\t\t\tml = ml3;\n\n\t\t\t\tstart0 = start2;\n\t\t\t\tref0 = ref2;\n\t\t\t\tml0 = ml2;\n\t\t\t\tgoto _Search2;\n\t\t\t}\n\n\t\t\tstart2 = start3;\n\t\t\tref2 = ref3;\n\t\t\tml2 = ml3;\n\t\t\tgoto _Search3;\n\t\t}\n\n\t\t \n\t\tif (start2 < ip + ml) {\n\t\t\tif ((start2 - ip) < (int)ML_MASK) {\n\t\t\t\tint correction;\n\n\t\t\t\tif (ml > OPTIMAL_ML)\n\t\t\t\t\tml = OPTIMAL_ML;\n\t\t\t\tif (ip + ml > start2 + ml2 - MINMATCH)\n\t\t\t\t\tml = (int)(start2 - ip) + ml2 - MINMATCH;\n\t\t\t\tcorrection = ml - (int)(start2 - ip);\n\t\t\t\tif (correction > 0) {\n\t\t\t\t\tstart2 += correction;\n\t\t\t\t\tref2 += correction;\n\t\t\t\t\tml2 -= correction;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\tml = (int)(start2 - ip);\n\t\t}\n\t\tif (LZ4HC_encodeSequence(&ip, &op, &anchor, ml,\n\t\t\tref, limit, oend))\n\t\t\treturn 0;\n\n\t\tip = start2;\n\t\tref = ref2;\n\t\tml = ml2;\n\n\t\tstart2 = start3;\n\t\tref2 = ref3;\n\t\tml2 = ml3;\n\n\t\tgoto _Search3;\n\t}\n\n\t \n\t{\n\t\tint lastRun = (int)(iend - anchor);\n\n\t\tif ((limit)\n\t\t\t&& (((char *)op - dest) + lastRun + 1\n\t\t\t\t+ ((lastRun + 255 - RUN_MASK)/255)\n\t\t\t\t\t> (U32)maxOutputSize)) {\n\t\t\t \n\t\t\treturn 0;\n\t\t}\n\t\tif (lastRun >= (int)RUN_MASK) {\n\t\t\t*op++ = (RUN_MASK<<ML_BITS);\n\t\t\tlastRun -= RUN_MASK;\n\t\t\tfor (; lastRun > 254 ; lastRun -= 255)\n\t\t\t\t*op++ = 255;\n\t\t\t*op++ = (BYTE) lastRun;\n\t\t} else\n\t\t\t*op++ = (BYTE)(lastRun<<ML_BITS);\n\t\tLZ4_memcpy(op, anchor, iend - anchor);\n\t\top += iend - anchor;\n\t}\n\n\t \n\treturn (int) (((char *)op) - dest);\n}\n\nstatic int LZ4_compress_HC_extStateHC(\n\tvoid *state,\n\tconst char *src,\n\tchar *dst,\n\tint srcSize,\n\tint maxDstSize,\n\tint compressionLevel)\n{\n\tLZ4HC_CCtx_internal *ctx = &((LZ4_streamHC_t *)state)->internal_donotuse;\n\n\tif (((size_t)(state)&(sizeof(void *) - 1)) != 0) {\n\t\t \n\t\treturn 0;\n\t}\n\n\tLZ4HC_init(ctx, (const BYTE *)src);\n\n\tif (maxDstSize < LZ4_compressBound(srcSize))\n\t\treturn LZ4HC_compress_generic(ctx, src, dst,\n\t\t\tsrcSize, maxDstSize, compressionLevel, limitedOutput);\n\telse\n\t\treturn LZ4HC_compress_generic(ctx, src, dst,\n\t\t\tsrcSize, maxDstSize, compressionLevel, noLimit);\n}\n\nint LZ4_compress_HC(const char *src, char *dst, int srcSize,\n\tint maxDstSize, int compressionLevel, void *wrkmem)\n{\n\treturn LZ4_compress_HC_extStateHC(wrkmem, src, dst,\n\t\tsrcSize, maxDstSize, compressionLevel);\n}\nEXPORT_SYMBOL(LZ4_compress_HC);\n\n \nvoid LZ4_resetStreamHC(LZ4_streamHC_t *LZ4_streamHCPtr, int compressionLevel)\n{\n\tLZ4_streamHCPtr->internal_donotuse.base = NULL;\n\tLZ4_streamHCPtr->internal_donotuse.compressionLevel = (unsigned int)compressionLevel;\n}\n\nint LZ4_loadDictHC(LZ4_streamHC_t *LZ4_streamHCPtr,\n\tconst char *dictionary,\n\tint dictSize)\n{\n\tLZ4HC_CCtx_internal *ctxPtr = &LZ4_streamHCPtr->internal_donotuse;\n\n\tif (dictSize > 64 * KB) {\n\t\tdictionary += dictSize - 64 * KB;\n\t\tdictSize = 64 * KB;\n\t}\n\tLZ4HC_init(ctxPtr, (const BYTE *)dictionary);\n\tif (dictSize >= 4)\n\t\tLZ4HC_Insert(ctxPtr, (const BYTE *)dictionary + (dictSize - 3));\n\tctxPtr->end = (const BYTE *)dictionary + dictSize;\n\treturn dictSize;\n}\nEXPORT_SYMBOL(LZ4_loadDictHC);\n\n \n\nstatic void LZ4HC_setExternalDict(\n\tLZ4HC_CCtx_internal *ctxPtr,\n\tconst BYTE *newBlock)\n{\n\tif (ctxPtr->end >= ctxPtr->base + 4) {\n\t\t \n\t\tLZ4HC_Insert(ctxPtr, ctxPtr->end - 3);\n\t}\n\n\t \n\tctxPtr->lowLimit\t= ctxPtr->dictLimit;\n\tctxPtr->dictLimit = (U32)(ctxPtr->end - ctxPtr->base);\n\tctxPtr->dictBase\t= ctxPtr->base;\n\tctxPtr->base = newBlock - ctxPtr->dictLimit;\n\tctxPtr->end\t= newBlock;\n\t \n\tctxPtr->nextToUpdate = ctxPtr->dictLimit;\n}\n\nstatic int LZ4_compressHC_continue_generic(\n\tLZ4_streamHC_t *LZ4_streamHCPtr,\n\tconst char *source,\n\tchar *dest,\n\tint inputSize,\n\tint maxOutputSize,\n\tlimitedOutput_directive limit)\n{\n\tLZ4HC_CCtx_internal *ctxPtr = &LZ4_streamHCPtr->internal_donotuse;\n\n\t \n\tif (ctxPtr->base == NULL)\n\t\tLZ4HC_init(ctxPtr, (const BYTE *) source);\n\n\t \n\tif ((size_t)(ctxPtr->end - ctxPtr->base) > 2 * GB) {\n\t\tsize_t dictSize = (size_t)(ctxPtr->end - ctxPtr->base)\n\t\t\t- ctxPtr->dictLimit;\n\t\tif (dictSize > 64 * KB)\n\t\t\tdictSize = 64 * KB;\n\t\tLZ4_loadDictHC(LZ4_streamHCPtr,\n\t\t\t(const char *)(ctxPtr->end) - dictSize, (int)dictSize);\n\t}\n\n\t \n\tif ((const BYTE *)source != ctxPtr->end)\n\t\tLZ4HC_setExternalDict(ctxPtr, (const BYTE *)source);\n\n\t \n\t{\n\t\tconst BYTE *sourceEnd = (const BYTE *) source + inputSize;\n\t\tconst BYTE * const dictBegin = ctxPtr->dictBase + ctxPtr->lowLimit;\n\t\tconst BYTE * const dictEnd = ctxPtr->dictBase + ctxPtr->dictLimit;\n\n\t\tif ((sourceEnd > dictBegin)\n\t\t\t&& ((const BYTE *)source < dictEnd)) {\n\t\t\tif (sourceEnd > dictEnd)\n\t\t\t\tsourceEnd = dictEnd;\n\t\t\tctxPtr->lowLimit = (U32)(sourceEnd - ctxPtr->dictBase);\n\n\t\t\tif (ctxPtr->dictLimit - ctxPtr->lowLimit < 4)\n\t\t\t\tctxPtr->lowLimit = ctxPtr->dictLimit;\n\t\t}\n\t}\n\n\treturn LZ4HC_compress_generic(ctxPtr, source, dest,\n\t\tinputSize, maxOutputSize, ctxPtr->compressionLevel, limit);\n}\n\nint LZ4_compress_HC_continue(\n\tLZ4_streamHC_t *LZ4_streamHCPtr,\n\tconst char *source,\n\tchar *dest,\n\tint inputSize,\n\tint maxOutputSize)\n{\n\tif (maxOutputSize < LZ4_compressBound(inputSize))\n\t\treturn LZ4_compressHC_continue_generic(LZ4_streamHCPtr,\n\t\t\tsource, dest, inputSize, maxOutputSize, limitedOutput);\n\telse\n\t\treturn LZ4_compressHC_continue_generic(LZ4_streamHCPtr,\n\t\t\tsource, dest, inputSize, maxOutputSize, noLimit);\n}\nEXPORT_SYMBOL(LZ4_compress_HC_continue);\n\n \n\nint LZ4_saveDictHC(\n\tLZ4_streamHC_t *LZ4_streamHCPtr,\n\tchar *safeBuffer,\n\tint dictSize)\n{\n\tLZ4HC_CCtx_internal *const streamPtr = &LZ4_streamHCPtr->internal_donotuse;\n\tint const prefixSize = (int)(streamPtr->end\n\t\t- (streamPtr->base + streamPtr->dictLimit));\n\n\tif (dictSize > 64 * KB)\n\t\tdictSize = 64 * KB;\n\tif (dictSize < 4)\n\t\tdictSize = 0;\n\tif (dictSize > prefixSize)\n\t\tdictSize = prefixSize;\n\n\tmemmove(safeBuffer, streamPtr->end - dictSize, dictSize);\n\n\t{\n\t\tU32 const endIndex = (U32)(streamPtr->end - streamPtr->base);\n\n\t\tstreamPtr->end = (const BYTE *)safeBuffer + dictSize;\n\t\tstreamPtr->base = streamPtr->end - endIndex;\n\t\tstreamPtr->dictLimit = endIndex - dictSize;\n\t\tstreamPtr->lowLimit = endIndex - dictSize;\n\n\t\tif (streamPtr->nextToUpdate < streamPtr->dictLimit)\n\t\t\tstreamPtr->nextToUpdate = streamPtr->dictLimit;\n\t}\n\treturn dictSize;\n}\nEXPORT_SYMBOL(LZ4_saveDictHC);\n\nMODULE_LICENSE(\"Dual BSD/GPL\");\nMODULE_DESCRIPTION(\"LZ4 HC compressor\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}