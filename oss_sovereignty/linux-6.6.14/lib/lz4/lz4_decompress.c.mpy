{
  "module_name": "lz4_decompress.c",
  "hash_id": "efc54d3fefa63869b34d1090f3f0bcab5a0e76a5591cc902be053f92980c88c5",
  "original_prompt": "Ingested from linux-6.6.14/lib/lz4/lz4_decompress.c",
  "human_readable_source": " \n\n \n#include <linux/lz4.h>\n#include \"lz4defs.h\"\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <asm/unaligned.h>\n\n \n\n#define DEBUGLOG(l, ...) {}\t \n\n#ifndef assert\n#define assert(condition) ((void)0)\n#endif\n\n \nstatic FORCE_INLINE int LZ4_decompress_generic(\n\t const char * const src,\n\t char * const dst,\n\t int srcSize,\n\t\t \n\t int outputSize,\n\t  \n\t endCondition_directive endOnInput,\n\t  \n\t earlyEnd_directive partialDecoding,\n\t  \n\t dict_directive dict,\n\t  \n\t const BYTE * const lowPrefix,\n\t  \n\t const BYTE * const dictStart,\n\t  \n\t const size_t dictSize\n\t )\n{\n\tconst BYTE *ip = (const BYTE *) src;\n\tconst BYTE * const iend = ip + srcSize;\n\n\tBYTE *op = (BYTE *) dst;\n\tBYTE * const oend = op + outputSize;\n\tBYTE *cpy;\n\n\tconst BYTE * const dictEnd = (const BYTE *)dictStart + dictSize;\n\tstatic const unsigned int inc32table[8] = {0, 1, 2, 1, 0, 4, 4, 4};\n\tstatic const int dec64table[8] = {0, 0, 0, -1, -4, 1, 2, 3};\n\n\tconst int safeDecode = (endOnInput == endOnInputSize);\n\tconst int checkOffset = ((safeDecode) && (dictSize < (int)(64 * KB)));\n\n\t \n\tconst BYTE *const shortiend = iend -\n\t\t(endOnInput ? 14 : 8)   - 2  ;\n\tconst BYTE *const shortoend = oend -\n\t\t(endOnInput ? 14 : 8)   - 18  ;\n\n\tDEBUGLOG(5, \"%s (srcSize:%i, dstSize:%i)\", __func__,\n\t\t srcSize, outputSize);\n\n\t \n\tassert(lowPrefix <= op);\n\tassert(src != NULL);\n\n\t \n\tif ((endOnInput) && (unlikely(outputSize == 0)))\n\t\treturn ((srcSize == 1) && (*ip == 0)) ? 0 : -1;\n\n\tif ((!endOnInput) && (unlikely(outputSize == 0)))\n\t\treturn (*ip == 0 ? 1 : -1);\n\n\tif ((endOnInput) && unlikely(srcSize == 0))\n\t\treturn -1;\n\n\t \n\twhile (1) {\n\t\tsize_t length;\n\t\tconst BYTE *match;\n\t\tsize_t offset;\n\n\t\t \n\t\tunsigned int const token = *ip++;\n\t\tlength = token>>ML_BITS;\n\n\t\t \n\t\tassert(!endOnInput || ip <= iend);\n\n\t\t \n\t\tif ((endOnInput ? length != RUN_MASK : length <= 8)\n\t\t    \n\t\t   && likely((endOnInput ? ip < shortiend : 1) &\n\t\t\t     (op <= shortoend))) {\n\t\t\t \n\t\t\tLZ4_memcpy(op, ip, endOnInput ? 16 : 8);\n\t\t\top += length; ip += length;\n\n\t\t\t \n\t\t\tlength = token & ML_MASK;  \n\t\t\toffset = LZ4_readLE16(ip);\n\t\t\tip += 2;\n\t\t\tmatch = op - offset;\n\t\t\tassert(match <= op);  \n\n\t\t\t \n\t\t\tif ((length != ML_MASK) &&\n\t\t\t    (offset >= 8) &&\n\t\t\t    (dict == withPrefix64k || match >= lowPrefix)) {\n\t\t\t\t \n\t\t\t\tLZ4_memcpy(op + 0, match + 0, 8);\n\t\t\t\tLZ4_memcpy(op + 8, match + 8, 8);\n\t\t\t\tLZ4_memcpy(op + 16, match + 16, 2);\n\t\t\t\top += length + MINMATCH;\n\t\t\t\t \n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t \n\t\t\tgoto _copy_match;\n\t\t}\n\n\t\t \n\t\tif (length == RUN_MASK) {\n\t\t\tunsigned int s;\n\n\t\t\tif (unlikely(endOnInput ? ip >= iend - RUN_MASK : 0)) {\n\t\t\t\t \n\t\t\t\tgoto _output_error;\n\t\t\t}\n\t\t\tdo {\n\t\t\t\ts = *ip++;\n\t\t\t\tlength += s;\n\t\t\t} while (likely(endOnInput\n\t\t\t\t? ip < iend - RUN_MASK\n\t\t\t\t: 1) & (s == 255));\n\n\t\t\tif ((safeDecode)\n\t\t\t    && unlikely((uptrval)(op) +\n\t\t\t\t\tlength < (uptrval)(op))) {\n\t\t\t\t \n\t\t\t\tgoto _output_error;\n\t\t\t}\n\t\t\tif ((safeDecode)\n\t\t\t    && unlikely((uptrval)(ip) +\n\t\t\t\t\tlength < (uptrval)(ip))) {\n\t\t\t\t \n\t\t\t\tgoto _output_error;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tcpy = op + length;\n\t\tLZ4_STATIC_ASSERT(MFLIMIT >= WILDCOPYLENGTH);\n\n\t\tif (((endOnInput) && ((cpy > oend - MFLIMIT)\n\t\t\t|| (ip + length > iend - (2 + 1 + LASTLITERALS))))\n\t\t\t|| ((!endOnInput) && (cpy > oend - WILDCOPYLENGTH))) {\n\t\t\tif (partialDecoding) {\n\t\t\t\tif (cpy > oend) {\n\t\t\t\t\t \n\t\t\t\t\tcpy = oend;\n\t\t\t\t\tlength = oend - op;\n\t\t\t\t}\n\t\t\t\tif ((endOnInput)\n\t\t\t\t\t&& (ip + length > iend)) {\n\t\t\t\t\t \n\t\t\t\t\tgoto _output_error;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif ((!endOnInput)\n\t\t\t\t\t&& (cpy != oend)) {\n\t\t\t\t\t \n\t\t\t\t\tgoto _output_error;\n\t\t\t\t}\n\t\t\t\tif ((endOnInput)\n\t\t\t\t\t&& ((ip + length != iend)\n\t\t\t\t\t|| (cpy > oend))) {\n\t\t\t\t\t \n\t\t\t\t\tgoto _output_error;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t \n\t\t\tLZ4_memmove(op, ip, length);\n\t\t\tip += length;\n\t\t\top += length;\n\n\t\t\t \n\t\t\tif (!partialDecoding || (cpy == oend) || (ip >= (iend - 2)))\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\t \n\t\t\tLZ4_wildCopy(op, ip, cpy);\n\t\t\tip += length;\n\t\t\top = cpy;\n\t\t}\n\n\t\t \n\t\toffset = LZ4_readLE16(ip);\n\t\tip += 2;\n\t\tmatch = op - offset;\n\n\t\t \n\t\tlength = token & ML_MASK;\n\n_copy_match:\n\t\tif ((checkOffset) && (unlikely(match + dictSize < lowPrefix))) {\n\t\t\t \n\t\t\tgoto _output_error;\n\t\t}\n\n\t\t \n\t\t \n\t\tif (!partialDecoding) {\n\t\t\tassert(oend > op);\n\t\t\tassert(oend - op >= 4);\n\n\t\t\tLZ4_write32(op, (U32)offset);\n\t\t}\n\n\t\tif (length == ML_MASK) {\n\t\t\tunsigned int s;\n\n\t\t\tdo {\n\t\t\t\ts = *ip++;\n\n\t\t\t\tif ((endOnInput) && (ip > iend - LASTLITERALS))\n\t\t\t\t\tgoto _output_error;\n\n\t\t\t\tlength += s;\n\t\t\t} while (s == 255);\n\n\t\t\tif ((safeDecode)\n\t\t\t\t&& unlikely(\n\t\t\t\t\t(uptrval)(op) + length < (uptrval)op)) {\n\t\t\t\t \n\t\t\t\tgoto _output_error;\n\t\t\t}\n\t\t}\n\n\t\tlength += MINMATCH;\n\n\t\t \n\t\tif ((dict == usingExtDict) && (match < lowPrefix)) {\n\t\t\tif (unlikely(op + length > oend - LASTLITERALS)) {\n\t\t\t\t \n\t\t\t\tif (!partialDecoding)\n\t\t\t\t\tgoto _output_error;\n\t\t\t\tlength = min(length, (size_t)(oend - op));\n\t\t\t}\n\n\t\t\tif (length <= (size_t)(lowPrefix - match)) {\n\t\t\t\t \n\t\t\t\tmemmove(op, dictEnd - (lowPrefix - match),\n\t\t\t\t\tlength);\n\t\t\t\top += length;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tsize_t const copySize = (size_t)(lowPrefix - match);\n\t\t\t\tsize_t const restSize = length - copySize;\n\n\t\t\t\tLZ4_memcpy(op, dictEnd - copySize, copySize);\n\t\t\t\top += copySize;\n\t\t\t\tif (restSize > (size_t)(op - lowPrefix)) {\n\t\t\t\t\t \n\t\t\t\t\tBYTE * const endOfMatch = op + restSize;\n\t\t\t\t\tconst BYTE *copyFrom = lowPrefix;\n\n\t\t\t\t\twhile (op < endOfMatch)\n\t\t\t\t\t\t*op++ = *copyFrom++;\n\t\t\t\t} else {\n\t\t\t\t\tLZ4_memcpy(op, lowPrefix, restSize);\n\t\t\t\t\top += restSize;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tcpy = op + length;\n\n\t\t \n\t\tassert(op <= oend);\n\t\tif (partialDecoding &&\n\t\t    (cpy > oend - MATCH_SAFEGUARD_DISTANCE)) {\n\t\t\tsize_t const mlen = min(length, (size_t)(oend - op));\n\t\t\tconst BYTE * const matchEnd = match + mlen;\n\t\t\tBYTE * const copyEnd = op + mlen;\n\n\t\t\tif (matchEnd > op) {\n\t\t\t\t \n\t\t\t\twhile (op < copyEnd)\n\t\t\t\t\t*op++ = *match++;\n\t\t\t} else {\n\t\t\t\tLZ4_memcpy(op, match, mlen);\n\t\t\t}\n\t\t\top = copyEnd;\n\t\t\tif (op == oend)\n\t\t\t\tbreak;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (unlikely(offset < 8)) {\n\t\t\top[0] = match[0];\n\t\t\top[1] = match[1];\n\t\t\top[2] = match[2];\n\t\t\top[3] = match[3];\n\t\t\tmatch += inc32table[offset];\n\t\t\tLZ4_memcpy(op + 4, match, 4);\n\t\t\tmatch -= dec64table[offset];\n\t\t} else {\n\t\t\tLZ4_copy8(op, match);\n\t\t\tmatch += 8;\n\t\t}\n\n\t\top += 8;\n\n\t\tif (unlikely(cpy > oend - MATCH_SAFEGUARD_DISTANCE)) {\n\t\t\tBYTE * const oCopyLimit = oend - (WILDCOPYLENGTH - 1);\n\n\t\t\tif (cpy > oend - LASTLITERALS) {\n\t\t\t\t \n\t\t\t\tgoto _output_error;\n\t\t\t}\n\n\t\t\tif (op < oCopyLimit) {\n\t\t\t\tLZ4_wildCopy(op, match, oCopyLimit);\n\t\t\t\tmatch += oCopyLimit - op;\n\t\t\t\top = oCopyLimit;\n\t\t\t}\n\t\t\twhile (op < cpy)\n\t\t\t\t*op++ = *match++;\n\t\t} else {\n\t\t\tLZ4_copy8(op, match);\n\t\t\tif (length > 16)\n\t\t\t\tLZ4_wildCopy(op + 8, match + 8, cpy);\n\t\t}\n\t\top = cpy;  \n\t}\n\n\t \n\tif (endOnInput) {\n\t\t \n\t\treturn (int) (((char *)op) - dst);\n\t} else {\n\t\t \n\t\treturn (int) (((const char *)ip) - src);\n\t}\n\n\t \n_output_error:\n\treturn (int) (-(((const char *)ip) - src)) - 1;\n}\n\nint LZ4_decompress_safe(const char *source, char *dest,\n\tint compressedSize, int maxDecompressedSize)\n{\n\treturn LZ4_decompress_generic(source, dest,\n\t\t\t\t      compressedSize, maxDecompressedSize,\n\t\t\t\t      endOnInputSize, decode_full_block,\n\t\t\t\t      noDict, (BYTE *)dest, NULL, 0);\n}\n\nint LZ4_decompress_safe_partial(const char *src, char *dst,\n\tint compressedSize, int targetOutputSize, int dstCapacity)\n{\n\tdstCapacity = min(targetOutputSize, dstCapacity);\n\treturn LZ4_decompress_generic(src, dst, compressedSize, dstCapacity,\n\t\t\t\t      endOnInputSize, partial_decode,\n\t\t\t\t      noDict, (BYTE *)dst, NULL, 0);\n}\n\nint LZ4_decompress_fast(const char *source, char *dest, int originalSize)\n{\n\treturn LZ4_decompress_generic(source, dest, 0, originalSize,\n\t\t\t\t      endOnOutputSize, decode_full_block,\n\t\t\t\t      withPrefix64k,\n\t\t\t\t      (BYTE *)dest - 64 * KB, NULL, 0);\n}\n\n \n\nstatic int LZ4_decompress_safe_withPrefix64k(const char *source, char *dest,\n\t\t\t\t      int compressedSize, int maxOutputSize)\n{\n\treturn LZ4_decompress_generic(source, dest,\n\t\t\t\t      compressedSize, maxOutputSize,\n\t\t\t\t      endOnInputSize, decode_full_block,\n\t\t\t\t      withPrefix64k,\n\t\t\t\t      (BYTE *)dest - 64 * KB, NULL, 0);\n}\n\nstatic int LZ4_decompress_safe_withSmallPrefix(const char *source, char *dest,\n\t\t\t\t\t       int compressedSize,\n\t\t\t\t\t       int maxOutputSize,\n\t\t\t\t\t       size_t prefixSize)\n{\n\treturn LZ4_decompress_generic(source, dest,\n\t\t\t\t      compressedSize, maxOutputSize,\n\t\t\t\t      endOnInputSize, decode_full_block,\n\t\t\t\t      noDict,\n\t\t\t\t      (BYTE *)dest - prefixSize, NULL, 0);\n}\n\nstatic int LZ4_decompress_safe_forceExtDict(const char *source, char *dest,\n\t\t\t\t\t    int compressedSize, int maxOutputSize,\n\t\t\t\t\t    const void *dictStart, size_t dictSize)\n{\n\treturn LZ4_decompress_generic(source, dest,\n\t\t\t\t      compressedSize, maxOutputSize,\n\t\t\t\t      endOnInputSize, decode_full_block,\n\t\t\t\t      usingExtDict, (BYTE *)dest,\n\t\t\t\t      (const BYTE *)dictStart, dictSize);\n}\n\nstatic int LZ4_decompress_fast_extDict(const char *source, char *dest,\n\t\t\t\t       int originalSize,\n\t\t\t\t       const void *dictStart, size_t dictSize)\n{\n\treturn LZ4_decompress_generic(source, dest,\n\t\t\t\t      0, originalSize,\n\t\t\t\t      endOnOutputSize, decode_full_block,\n\t\t\t\t      usingExtDict, (BYTE *)dest,\n\t\t\t\t      (const BYTE *)dictStart, dictSize);\n}\n\n \nstatic FORCE_INLINE\nint LZ4_decompress_safe_doubleDict(const char *source, char *dest,\n\t\t\t\t   int compressedSize, int maxOutputSize,\n\t\t\t\t   size_t prefixSize,\n\t\t\t\t   const void *dictStart, size_t dictSize)\n{\n\treturn LZ4_decompress_generic(source, dest,\n\t\t\t\t      compressedSize, maxOutputSize,\n\t\t\t\t      endOnInputSize, decode_full_block,\n\t\t\t\t      usingExtDict, (BYTE *)dest - prefixSize,\n\t\t\t\t      (const BYTE *)dictStart, dictSize);\n}\n\nstatic FORCE_INLINE\nint LZ4_decompress_fast_doubleDict(const char *source, char *dest,\n\t\t\t\t   int originalSize, size_t prefixSize,\n\t\t\t\t   const void *dictStart, size_t dictSize)\n{\n\treturn LZ4_decompress_generic(source, dest,\n\t\t\t\t      0, originalSize,\n\t\t\t\t      endOnOutputSize, decode_full_block,\n\t\t\t\t      usingExtDict, (BYTE *)dest - prefixSize,\n\t\t\t\t      (const BYTE *)dictStart, dictSize);\n}\n\n \n\nint LZ4_setStreamDecode(LZ4_streamDecode_t *LZ4_streamDecode,\n\tconst char *dictionary, int dictSize)\n{\n\tLZ4_streamDecode_t_internal *lz4sd =\n\t\t&LZ4_streamDecode->internal_donotuse;\n\n\tlz4sd->prefixSize = (size_t) dictSize;\n\tlz4sd->prefixEnd = (const BYTE *) dictionary + dictSize;\n\tlz4sd->externalDict = NULL;\n\tlz4sd->extDictSize\t= 0;\n\treturn 1;\n}\n\n \nint LZ4_decompress_safe_continue(LZ4_streamDecode_t *LZ4_streamDecode,\n\tconst char *source, char *dest, int compressedSize, int maxOutputSize)\n{\n\tLZ4_streamDecode_t_internal *lz4sd =\n\t\t&LZ4_streamDecode->internal_donotuse;\n\tint result;\n\n\tif (lz4sd->prefixSize == 0) {\n\t\t \n\t\tassert(lz4sd->extDictSize == 0);\n\t\tresult = LZ4_decompress_safe(source, dest,\n\t\t\tcompressedSize, maxOutputSize);\n\t\tif (result <= 0)\n\t\t\treturn result;\n\t\tlz4sd->prefixSize = result;\n\t\tlz4sd->prefixEnd = (BYTE *)dest + result;\n\t} else if (lz4sd->prefixEnd == (BYTE *)dest) {\n\t\t \n\t\tif (lz4sd->prefixSize >= 64 * KB - 1)\n\t\t\tresult = LZ4_decompress_safe_withPrefix64k(source, dest,\n\t\t\t\tcompressedSize, maxOutputSize);\n\t\telse if (lz4sd->extDictSize == 0)\n\t\t\tresult = LZ4_decompress_safe_withSmallPrefix(source,\n\t\t\t\tdest, compressedSize, maxOutputSize,\n\t\t\t\tlz4sd->prefixSize);\n\t\telse\n\t\t\tresult = LZ4_decompress_safe_doubleDict(source, dest,\n\t\t\t\tcompressedSize, maxOutputSize,\n\t\t\t\tlz4sd->prefixSize,\n\t\t\t\tlz4sd->externalDict, lz4sd->extDictSize);\n\t\tif (result <= 0)\n\t\t\treturn result;\n\t\tlz4sd->prefixSize += result;\n\t\tlz4sd->prefixEnd  += result;\n\t} else {\n\t\t \n\t\tlz4sd->extDictSize = lz4sd->prefixSize;\n\t\tlz4sd->externalDict = lz4sd->prefixEnd - lz4sd->extDictSize;\n\t\tresult = LZ4_decompress_safe_forceExtDict(source, dest,\n\t\t\tcompressedSize, maxOutputSize,\n\t\t\tlz4sd->externalDict, lz4sd->extDictSize);\n\t\tif (result <= 0)\n\t\t\treturn result;\n\t\tlz4sd->prefixSize = result;\n\t\tlz4sd->prefixEnd  = (BYTE *)dest + result;\n\t}\n\n\treturn result;\n}\n\nint LZ4_decompress_fast_continue(LZ4_streamDecode_t *LZ4_streamDecode,\n\tconst char *source, char *dest, int originalSize)\n{\n\tLZ4_streamDecode_t_internal *lz4sd = &LZ4_streamDecode->internal_donotuse;\n\tint result;\n\n\tif (lz4sd->prefixSize == 0) {\n\t\tassert(lz4sd->extDictSize == 0);\n\t\tresult = LZ4_decompress_fast(source, dest, originalSize);\n\t\tif (result <= 0)\n\t\t\treturn result;\n\t\tlz4sd->prefixSize = originalSize;\n\t\tlz4sd->prefixEnd = (BYTE *)dest + originalSize;\n\t} else if (lz4sd->prefixEnd == (BYTE *)dest) {\n\t\tif (lz4sd->prefixSize >= 64 * KB - 1 ||\n\t\t    lz4sd->extDictSize == 0)\n\t\t\tresult = LZ4_decompress_fast(source, dest,\n\t\t\t\t\t\t     originalSize);\n\t\telse\n\t\t\tresult = LZ4_decompress_fast_doubleDict(source, dest,\n\t\t\t\toriginalSize, lz4sd->prefixSize,\n\t\t\t\tlz4sd->externalDict, lz4sd->extDictSize);\n\t\tif (result <= 0)\n\t\t\treturn result;\n\t\tlz4sd->prefixSize += originalSize;\n\t\tlz4sd->prefixEnd  += originalSize;\n\t} else {\n\t\tlz4sd->extDictSize = lz4sd->prefixSize;\n\t\tlz4sd->externalDict = lz4sd->prefixEnd - lz4sd->extDictSize;\n\t\tresult = LZ4_decompress_fast_extDict(source, dest,\n\t\t\toriginalSize, lz4sd->externalDict, lz4sd->extDictSize);\n\t\tif (result <= 0)\n\t\t\treturn result;\n\t\tlz4sd->prefixSize = originalSize;\n\t\tlz4sd->prefixEnd = (BYTE *)dest + originalSize;\n\t}\n\treturn result;\n}\n\nint LZ4_decompress_safe_usingDict(const char *source, char *dest,\n\t\t\t\t  int compressedSize, int maxOutputSize,\n\t\t\t\t  const char *dictStart, int dictSize)\n{\n\tif (dictSize == 0)\n\t\treturn LZ4_decompress_safe(source, dest,\n\t\t\t\t\t   compressedSize, maxOutputSize);\n\tif (dictStart+dictSize == dest) {\n\t\tif (dictSize >= 64 * KB - 1)\n\t\t\treturn LZ4_decompress_safe_withPrefix64k(source, dest,\n\t\t\t\tcompressedSize, maxOutputSize);\n\t\treturn LZ4_decompress_safe_withSmallPrefix(source, dest,\n\t\t\tcompressedSize, maxOutputSize, dictSize);\n\t}\n\treturn LZ4_decompress_safe_forceExtDict(source, dest,\n\t\tcompressedSize, maxOutputSize, dictStart, dictSize);\n}\n\nint LZ4_decompress_fast_usingDict(const char *source, char *dest,\n\t\t\t\t  int originalSize,\n\t\t\t\t  const char *dictStart, int dictSize)\n{\n\tif (dictSize == 0 || dictStart + dictSize == dest)\n\t\treturn LZ4_decompress_fast(source, dest, originalSize);\n\n\treturn LZ4_decompress_fast_extDict(source, dest, originalSize,\n\t\tdictStart, dictSize);\n}\n\n#ifndef STATIC\nEXPORT_SYMBOL(LZ4_decompress_safe);\nEXPORT_SYMBOL(LZ4_decompress_safe_partial);\nEXPORT_SYMBOL(LZ4_decompress_fast);\nEXPORT_SYMBOL(LZ4_setStreamDecode);\nEXPORT_SYMBOL(LZ4_decompress_safe_continue);\nEXPORT_SYMBOL(LZ4_decompress_fast_continue);\nEXPORT_SYMBOL(LZ4_decompress_safe_usingDict);\nEXPORT_SYMBOL(LZ4_decompress_fast_usingDict);\n\nMODULE_LICENSE(\"Dual BSD/GPL\");\nMODULE_DESCRIPTION(\"LZ4 decompressor\");\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}