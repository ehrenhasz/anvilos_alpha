{
  "module_name": "lz4defs.h",
  "hash_id": "97fd6381e43a221a71b54512d528a141725d1fa8982fb4c9eb688c8067888bf9",
  "original_prompt": "Ingested from linux-6.6.14/lib/lz4/lz4defs.h",
  "human_readable_source": "#ifndef __LZ4DEFS_H__\n#define __LZ4DEFS_H__\n\n \n\n#include <asm/unaligned.h>\n\n#include <linux/bitops.h>\n#include <linux/string.h>\t  \n\n#define FORCE_INLINE __always_inline\n\n \n#include <linux/types.h>\n\ntypedef\tuint8_t BYTE;\ntypedef uint16_t U16;\ntypedef uint32_t U32;\ntypedef\tint32_t S32;\ntypedef uint64_t U64;\ntypedef uintptr_t uptrval;\n\n \n#if defined(CONFIG_64BIT)\n#define LZ4_ARCH64 1\n#else\n#define LZ4_ARCH64 0\n#endif\n\n#if defined(__LITTLE_ENDIAN)\n#define LZ4_LITTLE_ENDIAN 1\n#else\n#define LZ4_LITTLE_ENDIAN 0\n#endif\n\n \n#define MINMATCH 4\n\n#define WILDCOPYLENGTH 8\n#define LASTLITERALS 5\n#define MFLIMIT (WILDCOPYLENGTH + MINMATCH)\n \n#define MATCH_SAFEGUARD_DISTANCE  ((2 * WILDCOPYLENGTH) - MINMATCH)\n\n \n#define LZ4_SKIPTRIGGER 6\n\n#define HASH_UNIT sizeof(size_t)\n\n#define KB (1 << 10)\n#define MB (1 << 20)\n#define GB (1U << 30)\n\n#define MAXD_LOG 16\n#define MAX_DISTANCE ((1 << MAXD_LOG) - 1)\n#define STEPSIZE sizeof(size_t)\n\n#define ML_BITS\t4\n#define ML_MASK\t((1U << ML_BITS) - 1)\n#define RUN_BITS (8 - ML_BITS)\n#define RUN_MASK ((1U << RUN_BITS) - 1)\n\n \nstatic FORCE_INLINE U16 LZ4_read16(const void *ptr)\n{\n\treturn get_unaligned((const U16 *)ptr);\n}\n\nstatic FORCE_INLINE U32 LZ4_read32(const void *ptr)\n{\n\treturn get_unaligned((const U32 *)ptr);\n}\n\nstatic FORCE_INLINE size_t LZ4_read_ARCH(const void *ptr)\n{\n\treturn get_unaligned((const size_t *)ptr);\n}\n\nstatic FORCE_INLINE void LZ4_write16(void *memPtr, U16 value)\n{\n\tput_unaligned(value, (U16 *)memPtr);\n}\n\nstatic FORCE_INLINE void LZ4_write32(void *memPtr, U32 value)\n{\n\tput_unaligned(value, (U32 *)memPtr);\n}\n\nstatic FORCE_INLINE U16 LZ4_readLE16(const void *memPtr)\n{\n\treturn get_unaligned_le16(memPtr);\n}\n\nstatic FORCE_INLINE void LZ4_writeLE16(void *memPtr, U16 value)\n{\n\treturn put_unaligned_le16(value, memPtr);\n}\n\n \n#define LZ4_memcpy(dst, src, size) __builtin_memcpy(dst, src, size)\n#define LZ4_memmove(dst, src, size) __builtin_memmove(dst, src, size)\n\nstatic FORCE_INLINE void LZ4_copy8(void *dst, const void *src)\n{\n#if LZ4_ARCH64\n\tU64 a = get_unaligned((const U64 *)src);\n\n\tput_unaligned(a, (U64 *)dst);\n#else\n\tU32 a = get_unaligned((const U32 *)src);\n\tU32 b = get_unaligned((const U32 *)src + 1);\n\n\tput_unaligned(a, (U32 *)dst);\n\tput_unaligned(b, (U32 *)dst + 1);\n#endif\n}\n\n \nstatic FORCE_INLINE void LZ4_wildCopy(void *dstPtr,\n\tconst void *srcPtr, void *dstEnd)\n{\n\tBYTE *d = (BYTE *)dstPtr;\n\tconst BYTE *s = (const BYTE *)srcPtr;\n\tBYTE *const e = (BYTE *)dstEnd;\n\n\tdo {\n\t\tLZ4_copy8(d, s);\n\t\td += 8;\n\t\ts += 8;\n\t} while (d < e);\n}\n\nstatic FORCE_INLINE unsigned int LZ4_NbCommonBytes(register size_t val)\n{\n#if LZ4_LITTLE_ENDIAN\n\treturn __ffs(val) >> 3;\n#else\n\treturn (BITS_PER_LONG - 1 - __fls(val)) >> 3;\n#endif\n}\n\nstatic FORCE_INLINE unsigned int LZ4_count(\n\tconst BYTE *pIn,\n\tconst BYTE *pMatch,\n\tconst BYTE *pInLimit)\n{\n\tconst BYTE *const pStart = pIn;\n\n\twhile (likely(pIn < pInLimit - (STEPSIZE - 1))) {\n\t\tsize_t const diff = LZ4_read_ARCH(pMatch) ^ LZ4_read_ARCH(pIn);\n\n\t\tif (!diff) {\n\t\t\tpIn += STEPSIZE;\n\t\t\tpMatch += STEPSIZE;\n\t\t\tcontinue;\n\t\t}\n\n\t\tpIn += LZ4_NbCommonBytes(diff);\n\n\t\treturn (unsigned int)(pIn - pStart);\n\t}\n\n#if LZ4_ARCH64\n\tif ((pIn < (pInLimit - 3))\n\t\t&& (LZ4_read32(pMatch) == LZ4_read32(pIn))) {\n\t\tpIn += 4;\n\t\tpMatch += 4;\n\t}\n#endif\n\n\tif ((pIn < (pInLimit - 1))\n\t\t&& (LZ4_read16(pMatch) == LZ4_read16(pIn))) {\n\t\tpIn += 2;\n\t\tpMatch += 2;\n\t}\n\n\tif ((pIn < pInLimit) && (*pMatch == *pIn))\n\t\tpIn++;\n\n\treturn (unsigned int)(pIn - pStart);\n}\n\ntypedef enum { noLimit = 0, limitedOutput = 1 } limitedOutput_directive;\ntypedef enum { byPtr, byU32, byU16 } tableType_t;\n\ntypedef enum { noDict = 0, withPrefix64k, usingExtDict } dict_directive;\ntypedef enum { noDictIssue = 0, dictSmall } dictIssue_directive;\n\ntypedef enum { endOnOutputSize = 0, endOnInputSize = 1 } endCondition_directive;\ntypedef enum { decode_full_block = 0, partial_decode = 1 } earlyEnd_directive;\n\n#define LZ4_STATIC_ASSERT(c)\tBUILD_BUG_ON(!(c))\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}