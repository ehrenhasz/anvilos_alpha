{
  "module_name": "lz4_compress.c",
  "hash_id": "d278d91da41c0e67c636a403be211b55d8030c716d1e4c2eda0dd6fed68fc491",
  "original_prompt": "Ingested from linux-6.6.14/lib/lz4/lz4_compress.c",
  "human_readable_source": " \n\n \n#include <linux/lz4.h>\n#include \"lz4defs.h\"\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <asm/unaligned.h>\n\nstatic const int LZ4_minLength = (MFLIMIT + 1);\nstatic const int LZ4_64Klimit = ((64 * KB) + (MFLIMIT - 1));\n\n \nstatic FORCE_INLINE U32 LZ4_hash4(\n\tU32 sequence,\n\ttableType_t const tableType)\n{\n\tif (tableType == byU16)\n\t\treturn ((sequence * 2654435761U)\n\t\t\t>> ((MINMATCH * 8) - (LZ4_HASHLOG + 1)));\n\telse\n\t\treturn ((sequence * 2654435761U)\n\t\t\t>> ((MINMATCH * 8) - LZ4_HASHLOG));\n}\n\nstatic FORCE_INLINE U32 LZ4_hash5(\n\tU64 sequence,\n\ttableType_t const tableType)\n{\n\tconst U32 hashLog = (tableType == byU16)\n\t\t? LZ4_HASHLOG + 1\n\t\t: LZ4_HASHLOG;\n\n#if LZ4_LITTLE_ENDIAN\n\tstatic const U64 prime5bytes = 889523592379ULL;\n\n\treturn (U32)(((sequence << 24) * prime5bytes) >> (64 - hashLog));\n#else\n\tstatic const U64 prime8bytes = 11400714785074694791ULL;\n\n\treturn (U32)(((sequence >> 24) * prime8bytes) >> (64 - hashLog));\n#endif\n}\n\nstatic FORCE_INLINE U32 LZ4_hashPosition(\n\tconst void *p,\n\ttableType_t const tableType)\n{\n#if LZ4_ARCH64\n\tif (tableType == byU32)\n\t\treturn LZ4_hash5(LZ4_read_ARCH(p), tableType);\n#endif\n\n\treturn LZ4_hash4(LZ4_read32(p), tableType);\n}\n\nstatic void LZ4_putPositionOnHash(\n\tconst BYTE *p,\n\tU32 h,\n\tvoid *tableBase,\n\ttableType_t const tableType,\n\tconst BYTE *srcBase)\n{\n\tswitch (tableType) {\n\tcase byPtr:\n\t{\n\t\tconst BYTE **hashTable = (const BYTE **)tableBase;\n\n\t\thashTable[h] = p;\n\t\treturn;\n\t}\n\tcase byU32:\n\t{\n\t\tU32 *hashTable = (U32 *) tableBase;\n\n\t\thashTable[h] = (U32)(p - srcBase);\n\t\treturn;\n\t}\n\tcase byU16:\n\t{\n\t\tU16 *hashTable = (U16 *) tableBase;\n\n\t\thashTable[h] = (U16)(p - srcBase);\n\t\treturn;\n\t}\n\t}\n}\n\nstatic FORCE_INLINE void LZ4_putPosition(\n\tconst BYTE *p,\n\tvoid *tableBase,\n\ttableType_t tableType,\n\tconst BYTE *srcBase)\n{\n\tU32 const h = LZ4_hashPosition(p, tableType);\n\n\tLZ4_putPositionOnHash(p, h, tableBase, tableType, srcBase);\n}\n\nstatic const BYTE *LZ4_getPositionOnHash(\n\tU32 h,\n\tvoid *tableBase,\n\ttableType_t tableType,\n\tconst BYTE *srcBase)\n{\n\tif (tableType == byPtr) {\n\t\tconst BYTE **hashTable = (const BYTE **) tableBase;\n\n\t\treturn hashTable[h];\n\t}\n\n\tif (tableType == byU32) {\n\t\tconst U32 * const hashTable = (U32 *) tableBase;\n\n\t\treturn hashTable[h] + srcBase;\n\t}\n\n\t{\n\t\t \n\t\tconst U16 * const hashTable = (U16 *) tableBase;\n\n\t\treturn hashTable[h] + srcBase;\n\t}\n}\n\nstatic FORCE_INLINE const BYTE *LZ4_getPosition(\n\tconst BYTE *p,\n\tvoid *tableBase,\n\ttableType_t tableType,\n\tconst BYTE *srcBase)\n{\n\tU32 const h = LZ4_hashPosition(p, tableType);\n\n\treturn LZ4_getPositionOnHash(h, tableBase, tableType, srcBase);\n}\n\n\n \nstatic FORCE_INLINE int LZ4_compress_generic(\n\tLZ4_stream_t_internal * const dictPtr,\n\tconst char * const source,\n\tchar * const dest,\n\tconst int inputSize,\n\tconst int maxOutputSize,\n\tconst limitedOutput_directive outputLimited,\n\tconst tableType_t tableType,\n\tconst dict_directive dict,\n\tconst dictIssue_directive dictIssue,\n\tconst U32 acceleration)\n{\n\tconst BYTE *ip = (const BYTE *) source;\n\tconst BYTE *base;\n\tconst BYTE *lowLimit;\n\tconst BYTE * const lowRefLimit = ip - dictPtr->dictSize;\n\tconst BYTE * const dictionary = dictPtr->dictionary;\n\tconst BYTE * const dictEnd = dictionary + dictPtr->dictSize;\n\tconst size_t dictDelta = dictEnd - (const BYTE *)source;\n\tconst BYTE *anchor = (const BYTE *) source;\n\tconst BYTE * const iend = ip + inputSize;\n\tconst BYTE * const mflimit = iend - MFLIMIT;\n\tconst BYTE * const matchlimit = iend - LASTLITERALS;\n\n\tBYTE *op = (BYTE *) dest;\n\tBYTE * const olimit = op + maxOutputSize;\n\n\tU32 forwardH;\n\tsize_t refDelta = 0;\n\n\t \n\tif ((U32)inputSize > (U32)LZ4_MAX_INPUT_SIZE) {\n\t\t \n\t\treturn 0;\n\t}\n\n\tswitch (dict) {\n\tcase noDict:\n\tdefault:\n\t\tbase = (const BYTE *)source;\n\t\tlowLimit = (const BYTE *)source;\n\t\tbreak;\n\tcase withPrefix64k:\n\t\tbase = (const BYTE *)source - dictPtr->currentOffset;\n\t\tlowLimit = (const BYTE *)source - dictPtr->dictSize;\n\t\tbreak;\n\tcase usingExtDict:\n\t\tbase = (const BYTE *)source - dictPtr->currentOffset;\n\t\tlowLimit = (const BYTE *)source;\n\t\tbreak;\n\t}\n\n\tif ((tableType == byU16)\n\t\t&& (inputSize >= LZ4_64Klimit)) {\n\t\t \n\t\treturn 0;\n\t}\n\n\tif (inputSize < LZ4_minLength) {\n\t\t \n\t\tgoto _last_literals;\n\t}\n\n\t \n\tLZ4_putPosition(ip, dictPtr->hashTable, tableType, base);\n\tip++;\n\tforwardH = LZ4_hashPosition(ip, tableType);\n\n\t \n\tfor ( ; ; ) {\n\t\tconst BYTE *match;\n\t\tBYTE *token;\n\n\t\t \n\t\t{\n\t\t\tconst BYTE *forwardIp = ip;\n\t\t\tunsigned int step = 1;\n\t\t\tunsigned int searchMatchNb = acceleration << LZ4_SKIPTRIGGER;\n\n\t\t\tdo {\n\t\t\t\tU32 const h = forwardH;\n\n\t\t\t\tip = forwardIp;\n\t\t\t\tforwardIp += step;\n\t\t\t\tstep = (searchMatchNb++ >> LZ4_SKIPTRIGGER);\n\n\t\t\t\tif (unlikely(forwardIp > mflimit))\n\t\t\t\t\tgoto _last_literals;\n\n\t\t\t\tmatch = LZ4_getPositionOnHash(h,\n\t\t\t\t\tdictPtr->hashTable,\n\t\t\t\t\ttableType, base);\n\n\t\t\t\tif (dict == usingExtDict) {\n\t\t\t\t\tif (match < (const BYTE *)source) {\n\t\t\t\t\t\trefDelta = dictDelta;\n\t\t\t\t\t\tlowLimit = dictionary;\n\t\t\t\t\t} else {\n\t\t\t\t\t\trefDelta = 0;\n\t\t\t\t\t\tlowLimit = (const BYTE *)source;\n\t\t\t\t}\t }\n\n\t\t\t\tforwardH = LZ4_hashPosition(forwardIp,\n\t\t\t\t\ttableType);\n\n\t\t\t\tLZ4_putPositionOnHash(ip, h, dictPtr->hashTable,\n\t\t\t\t\ttableType, base);\n\t\t\t} while (((dictIssue == dictSmall)\n\t\t\t\t\t? (match < lowRefLimit)\n\t\t\t\t\t: 0)\n\t\t\t\t|| ((tableType == byU16)\n\t\t\t\t\t? 0\n\t\t\t\t\t: (match + MAX_DISTANCE < ip))\n\t\t\t\t|| (LZ4_read32(match + refDelta)\n\t\t\t\t\t!= LZ4_read32(ip)));\n\t\t}\n\n\t\t \n\t\twhile (((ip > anchor) & (match + refDelta > lowLimit))\n\t\t\t\t&& (unlikely(ip[-1] == match[refDelta - 1]))) {\n\t\t\tip--;\n\t\t\tmatch--;\n\t\t}\n\n\t\t \n\t\t{\n\t\t\tunsigned const int litLength = (unsigned int)(ip - anchor);\n\n\t\t\ttoken = op++;\n\n\t\t\tif ((outputLimited) &&\n\t\t\t\t \n\t\t\t\t(unlikely(op + litLength +\n\t\t\t\t\t(2 + 1 + LASTLITERALS) +\n\t\t\t\t\t(litLength / 255) > olimit)))\n\t\t\t\treturn 0;\n\n\t\t\tif (litLength >= RUN_MASK) {\n\t\t\t\tint len = (int)litLength - RUN_MASK;\n\n\t\t\t\t*token = (RUN_MASK << ML_BITS);\n\n\t\t\t\tfor (; len >= 255; len -= 255)\n\t\t\t\t\t*op++ = 255;\n\t\t\t\t*op++ = (BYTE)len;\n\t\t\t} else\n\t\t\t\t*token = (BYTE)(litLength << ML_BITS);\n\n\t\t\t \n\t\t\tLZ4_wildCopy(op, anchor, op + litLength);\n\t\t\top += litLength;\n\t\t}\n\n_next_match:\n\t\t \n\t\tLZ4_writeLE16(op, (U16)(ip - match));\n\t\top += 2;\n\n\t\t \n\t\t{\n\t\t\tunsigned int matchCode;\n\n\t\t\tif ((dict == usingExtDict)\n\t\t\t\t&& (lowLimit == dictionary)) {\n\t\t\t\tconst BYTE *limit;\n\n\t\t\t\tmatch += refDelta;\n\t\t\t\tlimit = ip + (dictEnd - match);\n\n\t\t\t\tif (limit > matchlimit)\n\t\t\t\t\tlimit = matchlimit;\n\n\t\t\t\tmatchCode = LZ4_count(ip + MINMATCH,\n\t\t\t\t\tmatch + MINMATCH, limit);\n\n\t\t\t\tip += MINMATCH + matchCode;\n\n\t\t\t\tif (ip == limit) {\n\t\t\t\t\tunsigned const int more = LZ4_count(ip,\n\t\t\t\t\t\t(const BYTE *)source,\n\t\t\t\t\t\tmatchlimit);\n\n\t\t\t\t\tmatchCode += more;\n\t\t\t\t\tip += more;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tmatchCode = LZ4_count(ip + MINMATCH,\n\t\t\t\t\tmatch + MINMATCH, matchlimit);\n\t\t\t\tip += MINMATCH + matchCode;\n\t\t\t}\n\n\t\t\tif (outputLimited &&\n\t\t\t\t \n\t\t\t\t(unlikely(op +\n\t\t\t\t\t(1 + LASTLITERALS) +\n\t\t\t\t\t(matchCode >> 8) > olimit)))\n\t\t\t\treturn 0;\n\n\t\t\tif (matchCode >= ML_MASK) {\n\t\t\t\t*token += ML_MASK;\n\t\t\t\tmatchCode -= ML_MASK;\n\t\t\t\tLZ4_write32(op, 0xFFFFFFFF);\n\n\t\t\t\twhile (matchCode >= 4 * 255) {\n\t\t\t\t\top += 4;\n\t\t\t\t\tLZ4_write32(op, 0xFFFFFFFF);\n\t\t\t\t\tmatchCode -= 4 * 255;\n\t\t\t\t}\n\n\t\t\t\top += matchCode / 255;\n\t\t\t\t*op++ = (BYTE)(matchCode % 255);\n\t\t\t} else\n\t\t\t\t*token += (BYTE)(matchCode);\n\t\t}\n\n\t\tanchor = ip;\n\n\t\t \n\t\tif (ip > mflimit)\n\t\t\tbreak;\n\n\t\t \n\t\tLZ4_putPosition(ip - 2, dictPtr->hashTable, tableType, base);\n\n\t\t \n\t\tmatch = LZ4_getPosition(ip, dictPtr->hashTable,\n\t\t\ttableType, base);\n\n\t\tif (dict == usingExtDict) {\n\t\t\tif (match < (const BYTE *)source) {\n\t\t\t\trefDelta = dictDelta;\n\t\t\t\tlowLimit = dictionary;\n\t\t\t} else {\n\t\t\t\trefDelta = 0;\n\t\t\t\tlowLimit = (const BYTE *)source;\n\t\t\t}\n\t\t}\n\n\t\tLZ4_putPosition(ip, dictPtr->hashTable, tableType, base);\n\n\t\tif (((dictIssue == dictSmall) ? (match >= lowRefLimit) : 1)\n\t\t\t&& (match + MAX_DISTANCE >= ip)\n\t\t\t&& (LZ4_read32(match + refDelta) == LZ4_read32(ip))) {\n\t\t\ttoken = op++;\n\t\t\t*token = 0;\n\t\t\tgoto _next_match;\n\t\t}\n\n\t\t \n\t\tforwardH = LZ4_hashPosition(++ip, tableType);\n\t}\n\n_last_literals:\n\t \n\t{\n\t\tsize_t const lastRun = (size_t)(iend - anchor);\n\n\t\tif ((outputLimited) &&\n\t\t\t \n\t\t\t((op - (BYTE *)dest) + lastRun + 1 +\n\t\t\t((lastRun + 255 - RUN_MASK) / 255) > (U32)maxOutputSize))\n\t\t\treturn 0;\n\n\t\tif (lastRun >= RUN_MASK) {\n\t\t\tsize_t accumulator = lastRun - RUN_MASK;\n\t\t\t*op++ = RUN_MASK << ML_BITS;\n\t\t\tfor (; accumulator >= 255; accumulator -= 255)\n\t\t\t\t*op++ = 255;\n\t\t\t*op++ = (BYTE) accumulator;\n\t\t} else {\n\t\t\t*op++ = (BYTE)(lastRun << ML_BITS);\n\t\t}\n\n\t\tLZ4_memcpy(op, anchor, lastRun);\n\n\t\top += lastRun;\n\t}\n\n\t \n\treturn (int) (((char *)op) - dest);\n}\n\nstatic int LZ4_compress_fast_extState(\n\tvoid *state,\n\tconst char *source,\n\tchar *dest,\n\tint inputSize,\n\tint maxOutputSize,\n\tint acceleration)\n{\n\tLZ4_stream_t_internal *ctx = &((LZ4_stream_t *)state)->internal_donotuse;\n#if LZ4_ARCH64\n\tconst tableType_t tableType = byU32;\n#else\n\tconst tableType_t tableType = byPtr;\n#endif\n\n\tLZ4_resetStream((LZ4_stream_t *)state);\n\n\tif (acceleration < 1)\n\t\tacceleration = LZ4_ACCELERATION_DEFAULT;\n\n\tif (maxOutputSize >= LZ4_COMPRESSBOUND(inputSize)) {\n\t\tif (inputSize < LZ4_64Klimit)\n\t\t\treturn LZ4_compress_generic(ctx, source,\n\t\t\t\tdest, inputSize, 0,\n\t\t\t\tnoLimit, byU16, noDict,\n\t\t\t\tnoDictIssue, acceleration);\n\t\telse\n\t\t\treturn LZ4_compress_generic(ctx, source,\n\t\t\t\tdest, inputSize, 0,\n\t\t\t\tnoLimit, tableType, noDict,\n\t\t\t\tnoDictIssue, acceleration);\n\t} else {\n\t\tif (inputSize < LZ4_64Klimit)\n\t\t\treturn LZ4_compress_generic(ctx, source,\n\t\t\t\tdest, inputSize,\n\t\t\t\tmaxOutputSize, limitedOutput, byU16, noDict,\n\t\t\t\tnoDictIssue, acceleration);\n\t\telse\n\t\t\treturn LZ4_compress_generic(ctx, source,\n\t\t\t\tdest, inputSize,\n\t\t\t\tmaxOutputSize, limitedOutput, tableType, noDict,\n\t\t\t\tnoDictIssue, acceleration);\n\t}\n}\n\nint LZ4_compress_fast(const char *source, char *dest, int inputSize,\n\tint maxOutputSize, int acceleration, void *wrkmem)\n{\n\treturn LZ4_compress_fast_extState(wrkmem, source, dest, inputSize,\n\t\tmaxOutputSize, acceleration);\n}\nEXPORT_SYMBOL(LZ4_compress_fast);\n\nint LZ4_compress_default(const char *source, char *dest, int inputSize,\n\tint maxOutputSize, void *wrkmem)\n{\n\treturn LZ4_compress_fast(source, dest, inputSize,\n\t\tmaxOutputSize, LZ4_ACCELERATION_DEFAULT, wrkmem);\n}\nEXPORT_SYMBOL(LZ4_compress_default);\n\n \nstatic int LZ4_compress_destSize_generic(\n\tLZ4_stream_t_internal * const ctx,\n\tconst char * const src,\n\tchar * const dst,\n\tint * const srcSizePtr,\n\tconst int targetDstSize,\n\tconst tableType_t tableType)\n{\n\tconst BYTE *ip = (const BYTE *) src;\n\tconst BYTE *base = (const BYTE *) src;\n\tconst BYTE *lowLimit = (const BYTE *) src;\n\tconst BYTE *anchor = ip;\n\tconst BYTE * const iend = ip + *srcSizePtr;\n\tconst BYTE * const mflimit = iend - MFLIMIT;\n\tconst BYTE * const matchlimit = iend - LASTLITERALS;\n\n\tBYTE *op = (BYTE *) dst;\n\tBYTE * const oend = op + targetDstSize;\n\tBYTE * const oMaxLit = op + targetDstSize - 2  \n\t\t- 8   - 1  ;\n\tBYTE * const oMaxMatch = op + targetDstSize\n\t\t- (LASTLITERALS + 1  );\n\tBYTE * const oMaxSeq = oMaxLit - 1  ;\n\n\tU32 forwardH;\n\n\t \n\t \n\tif (targetDstSize < 1)\n\t\treturn 0;\n\t \n\tif ((U32)*srcSizePtr > (U32)LZ4_MAX_INPUT_SIZE)\n\t\treturn 0;\n\t \n\tif ((tableType == byU16) && (*srcSizePtr >= LZ4_64Klimit))\n\t\treturn 0;\n\t \n\tif (*srcSizePtr < LZ4_minLength)\n\t\tgoto _last_literals;\n\n\t \n\t*srcSizePtr = 0;\n\tLZ4_putPosition(ip, ctx->hashTable, tableType, base);\n\tip++; forwardH = LZ4_hashPosition(ip, tableType);\n\n\t \n\tfor ( ; ; ) {\n\t\tconst BYTE *match;\n\t\tBYTE *token;\n\n\t\t \n\t\t{\n\t\t\tconst BYTE *forwardIp = ip;\n\t\t\tunsigned int step = 1;\n\t\t\tunsigned int searchMatchNb = 1 << LZ4_SKIPTRIGGER;\n\n\t\t\tdo {\n\t\t\t\tU32 h = forwardH;\n\n\t\t\t\tip = forwardIp;\n\t\t\t\tforwardIp += step;\n\t\t\t\tstep = (searchMatchNb++ >> LZ4_SKIPTRIGGER);\n\n\t\t\t\tif (unlikely(forwardIp > mflimit))\n\t\t\t\t\tgoto _last_literals;\n\n\t\t\t\tmatch = LZ4_getPositionOnHash(h, ctx->hashTable,\n\t\t\t\t\ttableType, base);\n\t\t\t\tforwardH = LZ4_hashPosition(forwardIp,\n\t\t\t\t\ttableType);\n\t\t\t\tLZ4_putPositionOnHash(ip, h,\n\t\t\t\t\tctx->hashTable, tableType,\n\t\t\t\t\tbase);\n\n\t\t\t} while (((tableType == byU16)\n\t\t\t\t? 0\n\t\t\t\t: (match + MAX_DISTANCE < ip))\n\t\t\t\t|| (LZ4_read32(match) != LZ4_read32(ip)));\n\t\t}\n\n\t\t \n\t\twhile ((ip > anchor)\n\t\t\t&& (match > lowLimit)\n\t\t\t&& (unlikely(ip[-1] == match[-1]))) {\n\t\t\tip--;\n\t\t\tmatch--;\n\t\t}\n\n\t\t \n\t\t{\n\t\t\tunsigned int litLength = (unsigned int)(ip - anchor);\n\n\t\t\ttoken = op++;\n\t\t\tif (op + ((litLength + 240) / 255)\n\t\t\t\t+ litLength > oMaxLit) {\n\t\t\t\t \n\t\t\t\top--;\n\t\t\t\tgoto _last_literals;\n\t\t\t}\n\t\t\tif (litLength >= RUN_MASK) {\n\t\t\t\tunsigned int len = litLength - RUN_MASK;\n\t\t\t\t*token = (RUN_MASK<<ML_BITS);\n\t\t\t\tfor (; len >= 255; len -= 255)\n\t\t\t\t\t*op++ = 255;\n\t\t\t\t*op++ = (BYTE)len;\n\t\t\t} else\n\t\t\t\t*token = (BYTE)(litLength << ML_BITS);\n\n\t\t\t \n\t\t\tLZ4_wildCopy(op, anchor, op + litLength);\n\t\t\top += litLength;\n\t\t}\n\n_next_match:\n\t\t \n\t\tLZ4_writeLE16(op, (U16)(ip - match)); op += 2;\n\n\t\t \n\t\t{\n\t\t\tsize_t matchLength = LZ4_count(ip + MINMATCH,\n\t\t\tmatch + MINMATCH, matchlimit);\n\n\t\t\tif (op + ((matchLength + 240)/255) > oMaxMatch) {\n\t\t\t\t \n\t\t\t\tmatchLength = (15 - 1) + (oMaxMatch - op) * 255;\n\t\t\t}\n\t\t\tip += MINMATCH + matchLength;\n\n\t\t\tif (matchLength >= ML_MASK) {\n\t\t\t\t*token += ML_MASK;\n\t\t\t\tmatchLength -= ML_MASK;\n\t\t\t\twhile (matchLength >= 255) {\n\t\t\t\t\tmatchLength -= 255;\n\t\t\t\t\t*op++ = 255;\n\t\t\t\t}\n\t\t\t\t*op++ = (BYTE)matchLength;\n\t\t\t} else\n\t\t\t\t*token += (BYTE)(matchLength);\n\t\t}\n\n\t\tanchor = ip;\n\n\t\t \n\t\tif (ip > mflimit)\n\t\t\tbreak;\n\t\tif (op > oMaxSeq)\n\t\t\tbreak;\n\n\t\t \n\t\tLZ4_putPosition(ip - 2, ctx->hashTable, tableType, base);\n\n\t\t \n\t\tmatch = LZ4_getPosition(ip, ctx->hashTable, tableType, base);\n\t\tLZ4_putPosition(ip, ctx->hashTable, tableType, base);\n\n\t\tif ((match + MAX_DISTANCE >= ip)\n\t\t\t&& (LZ4_read32(match) == LZ4_read32(ip))) {\n\t\t\ttoken = op++; *token = 0;\n\t\t\tgoto _next_match;\n\t\t}\n\n\t\t \n\t\tforwardH = LZ4_hashPosition(++ip, tableType);\n\t}\n\n_last_literals:\n\t \n\t{\n\t\tsize_t lastRunSize = (size_t)(iend - anchor);\n\n\t\tif (op + 1  \n\t\t\t+ ((lastRunSize + 240) / 255)  \n\t\t\t+ lastRunSize   > oend) {\n\t\t\t \n\t\t\tlastRunSize\t= (oend - op) - 1;\n\t\t\tlastRunSize -= (lastRunSize + 240) / 255;\n\t\t}\n\t\tip = anchor + lastRunSize;\n\n\t\tif (lastRunSize >= RUN_MASK) {\n\t\t\tsize_t accumulator = lastRunSize - RUN_MASK;\n\n\t\t\t*op++ = RUN_MASK << ML_BITS;\n\t\t\tfor (; accumulator >= 255; accumulator -= 255)\n\t\t\t\t*op++ = 255;\n\t\t\t*op++ = (BYTE) accumulator;\n\t\t} else {\n\t\t\t*op++ = (BYTE)(lastRunSize<<ML_BITS);\n\t\t}\n\t\tLZ4_memcpy(op, anchor, lastRunSize);\n\t\top += lastRunSize;\n\t}\n\n\t \n\t*srcSizePtr = (int) (((const char *)ip) - src);\n\treturn (int) (((char *)op) - dst);\n}\n\nstatic int LZ4_compress_destSize_extState(\n\tLZ4_stream_t *state,\n\tconst char *src,\n\tchar *dst,\n\tint *srcSizePtr,\n\tint targetDstSize)\n{\n#if LZ4_ARCH64\n\tconst tableType_t tableType = byU32;\n#else\n\tconst tableType_t tableType = byPtr;\n#endif\n\n\tLZ4_resetStream(state);\n\n\tif (targetDstSize >= LZ4_COMPRESSBOUND(*srcSizePtr)) {\n\t\t \n\t\treturn LZ4_compress_fast_extState(\n\t\t\tstate, src, dst, *srcSizePtr,\n\t\t\ttargetDstSize, 1);\n\t} else {\n\t\tif (*srcSizePtr < LZ4_64Klimit)\n\t\t\treturn LZ4_compress_destSize_generic(\n\t\t\t\t&state->internal_donotuse,\n\t\t\t\tsrc, dst, srcSizePtr,\n\t\t\t\ttargetDstSize, byU16);\n\t\telse\n\t\t\treturn LZ4_compress_destSize_generic(\n\t\t\t\t&state->internal_donotuse,\n\t\t\t\tsrc, dst, srcSizePtr,\n\t\t\t\ttargetDstSize, tableType);\n\t}\n}\n\n\nint LZ4_compress_destSize(\n\tconst char *src,\n\tchar *dst,\n\tint *srcSizePtr,\n\tint targetDstSize,\n\tvoid *wrkmem)\n{\n\treturn LZ4_compress_destSize_extState(wrkmem, src, dst, srcSizePtr,\n\t\ttargetDstSize);\n}\nEXPORT_SYMBOL(LZ4_compress_destSize);\n\n \nvoid LZ4_resetStream(LZ4_stream_t *LZ4_stream)\n{\n\tmemset(LZ4_stream, 0, sizeof(LZ4_stream_t));\n}\n\nint LZ4_loadDict(LZ4_stream_t *LZ4_dict,\n\tconst char *dictionary, int dictSize)\n{\n\tLZ4_stream_t_internal *dict = &LZ4_dict->internal_donotuse;\n\tconst BYTE *p = (const BYTE *)dictionary;\n\tconst BYTE * const dictEnd = p + dictSize;\n\tconst BYTE *base;\n\n\tif ((dict->initCheck)\n\t\t|| (dict->currentOffset > 1 * GB)) {\n\t\t \n\t\tLZ4_resetStream(LZ4_dict);\n\t}\n\n\tif (dictSize < (int)HASH_UNIT) {\n\t\tdict->dictionary = NULL;\n\t\tdict->dictSize = 0;\n\t\treturn 0;\n\t}\n\n\tif ((dictEnd - p) > 64 * KB)\n\t\tp = dictEnd - 64 * KB;\n\tdict->currentOffset += 64 * KB;\n\tbase = p - dict->currentOffset;\n\tdict->dictionary = p;\n\tdict->dictSize = (U32)(dictEnd - p);\n\tdict->currentOffset += dict->dictSize;\n\n\twhile (p <= dictEnd - HASH_UNIT) {\n\t\tLZ4_putPosition(p, dict->hashTable, byU32, base);\n\t\tp += 3;\n\t}\n\n\treturn dict->dictSize;\n}\nEXPORT_SYMBOL(LZ4_loadDict);\n\nstatic void LZ4_renormDictT(LZ4_stream_t_internal *LZ4_dict,\n\tconst BYTE *src)\n{\n\tif ((LZ4_dict->currentOffset > 0x80000000) ||\n\t\t((uptrval)LZ4_dict->currentOffset > (uptrval)src)) {\n\t\t \n\t\t \n\t\tU32 const delta = LZ4_dict->currentOffset - 64 * KB;\n\t\tconst BYTE *dictEnd = LZ4_dict->dictionary + LZ4_dict->dictSize;\n\t\tint i;\n\n\t\tfor (i = 0; i < LZ4_HASH_SIZE_U32; i++) {\n\t\t\tif (LZ4_dict->hashTable[i] < delta)\n\t\t\t\tLZ4_dict->hashTable[i] = 0;\n\t\t\telse\n\t\t\t\tLZ4_dict->hashTable[i] -= delta;\n\t\t}\n\t\tLZ4_dict->currentOffset = 64 * KB;\n\t\tif (LZ4_dict->dictSize > 64 * KB)\n\t\t\tLZ4_dict->dictSize = 64 * KB;\n\t\tLZ4_dict->dictionary = dictEnd - LZ4_dict->dictSize;\n\t}\n}\n\nint LZ4_saveDict(LZ4_stream_t *LZ4_dict, char *safeBuffer, int dictSize)\n{\n\tLZ4_stream_t_internal * const dict = &LZ4_dict->internal_donotuse;\n\tconst BYTE * const previousDictEnd = dict->dictionary + dict->dictSize;\n\n\tif ((U32)dictSize > 64 * KB) {\n\t\t \n\t\tdictSize = 64 * KB;\n\t}\n\tif ((U32)dictSize > dict->dictSize)\n\t\tdictSize = dict->dictSize;\n\n\tmemmove(safeBuffer, previousDictEnd - dictSize, dictSize);\n\n\tdict->dictionary = (const BYTE *)safeBuffer;\n\tdict->dictSize = (U32)dictSize;\n\n\treturn dictSize;\n}\nEXPORT_SYMBOL(LZ4_saveDict);\n\nint LZ4_compress_fast_continue(LZ4_stream_t *LZ4_stream, const char *source,\n\tchar *dest, int inputSize, int maxOutputSize, int acceleration)\n{\n\tLZ4_stream_t_internal *streamPtr = &LZ4_stream->internal_donotuse;\n\tconst BYTE * const dictEnd = streamPtr->dictionary\n\t\t+ streamPtr->dictSize;\n\n\tconst BYTE *smallest = (const BYTE *) source;\n\n\tif (streamPtr->initCheck) {\n\t\t \n\t\treturn 0;\n\t}\n\n\tif ((streamPtr->dictSize > 0) && (smallest > dictEnd))\n\t\tsmallest = dictEnd;\n\n\tLZ4_renormDictT(streamPtr, smallest);\n\n\tif (acceleration < 1)\n\t\tacceleration = LZ4_ACCELERATION_DEFAULT;\n\n\t \n\t{\n\t\tconst BYTE *sourceEnd = (const BYTE *) source + inputSize;\n\n\t\tif ((sourceEnd > streamPtr->dictionary)\n\t\t\t&& (sourceEnd < dictEnd)) {\n\t\t\tstreamPtr->dictSize = (U32)(dictEnd - sourceEnd);\n\t\t\tif (streamPtr->dictSize > 64 * KB)\n\t\t\t\tstreamPtr->dictSize = 64 * KB;\n\t\t\tif (streamPtr->dictSize < 4)\n\t\t\t\tstreamPtr->dictSize = 0;\n\t\t\tstreamPtr->dictionary = dictEnd - streamPtr->dictSize;\n\t\t}\n\t}\n\n\t \n\tif (dictEnd == (const BYTE *)source) {\n\t\tint result;\n\n\t\tif ((streamPtr->dictSize < 64 * KB) &&\n\t\t\t(streamPtr->dictSize < streamPtr->currentOffset)) {\n\t\t\tresult = LZ4_compress_generic(\n\t\t\t\tstreamPtr, source, dest, inputSize,\n\t\t\t\tmaxOutputSize, limitedOutput, byU32,\n\t\t\t\twithPrefix64k, dictSmall, acceleration);\n\t\t} else {\n\t\t\tresult = LZ4_compress_generic(\n\t\t\t\tstreamPtr, source, dest, inputSize,\n\t\t\t\tmaxOutputSize, limitedOutput, byU32,\n\t\t\t\twithPrefix64k, noDictIssue, acceleration);\n\t\t}\n\t\tstreamPtr->dictSize += (U32)inputSize;\n\t\tstreamPtr->currentOffset += (U32)inputSize;\n\t\treturn result;\n\t}\n\n\t \n\t{\n\t\tint result;\n\n\t\tif ((streamPtr->dictSize < 64 * KB) &&\n\t\t\t(streamPtr->dictSize < streamPtr->currentOffset)) {\n\t\t\tresult = LZ4_compress_generic(\n\t\t\t\tstreamPtr, source, dest, inputSize,\n\t\t\t\tmaxOutputSize, limitedOutput, byU32,\n\t\t\t\tusingExtDict, dictSmall, acceleration);\n\t\t} else {\n\t\t\tresult = LZ4_compress_generic(\n\t\t\t\tstreamPtr, source, dest, inputSize,\n\t\t\t\tmaxOutputSize, limitedOutput, byU32,\n\t\t\t\tusingExtDict, noDictIssue, acceleration);\n\t\t}\n\t\tstreamPtr->dictionary = (const BYTE *)source;\n\t\tstreamPtr->dictSize = (U32)inputSize;\n\t\tstreamPtr->currentOffset += (U32)inputSize;\n\t\treturn result;\n\t}\n}\nEXPORT_SYMBOL(LZ4_compress_fast_continue);\n\nMODULE_LICENSE(\"Dual BSD/GPL\");\nMODULE_DESCRIPTION(\"LZ4 compressor\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}