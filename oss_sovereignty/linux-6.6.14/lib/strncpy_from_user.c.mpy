{
  "module_name": "strncpy_from_user.c",
  "hash_id": "dd98d91dac26317272f2c9aa75bbb40c3d0fb685b393a752c2627fbf3cfaaae5",
  "original_prompt": "Ingested from linux-6.6.14/lib/strncpy_from_user.c",
  "human_readable_source": "\n#include <linux/compiler.h>\n#include <linux/export.h>\n#include <linux/fault-inject-usercopy.h>\n#include <linux/kasan-checks.h>\n#include <linux/thread_info.h>\n#include <linux/uaccess.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/mm.h>\n\n#include <asm/byteorder.h>\n#include <asm/word-at-a-time.h>\n\n#ifdef CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS\n#define IS_UNALIGNED(src, dst)\t0\n#else\n#define IS_UNALIGNED(src, dst)\t\\\n\t(((long) dst | (long) src) & (sizeof(long) - 1))\n#endif\n\n \nstatic __always_inline long do_strncpy_from_user(char *dst, const char __user *src,\n\t\t\t\t\tunsigned long count, unsigned long max)\n{\n\tconst struct word_at_a_time constants = WORD_AT_A_TIME_CONSTANTS;\n\tunsigned long res = 0;\n\n\tif (IS_UNALIGNED(src, dst))\n\t\tgoto byte_at_a_time;\n\n\twhile (max >= sizeof(unsigned long)) {\n\t\tunsigned long c, data, mask;\n\n\t\t \n\t\tunsafe_get_user(c, (unsigned long __user *)(src+res), byte_at_a_time);\n\n\t\t \n\t\tif (has_zero(c, &data, &constants)) {\n\t\t\tdata = prep_zero_mask(c, data, &constants);\n\t\t\tdata = create_zero_mask(data);\n\t\t\tmask = zero_bytemask(data);\n\t\t\t*(unsigned long *)(dst+res) = c & mask;\n\t\t\treturn res + find_zero(data);\n\t\t}\n\n\t\t*(unsigned long *)(dst+res) = c;\n\n\t\tres += sizeof(unsigned long);\n\t\tmax -= sizeof(unsigned long);\n\t}\n\nbyte_at_a_time:\n\twhile (max) {\n\t\tchar c;\n\n\t\tunsafe_get_user(c,src+res, efault);\n\t\tdst[res] = c;\n\t\tif (!c)\n\t\t\treturn res;\n\t\tres++;\n\t\tmax--;\n\t}\n\n\t \n\tif (res >= count)\n\t\treturn res;\n\n\t \nefault:\n\treturn -EFAULT;\n}\n\n \nlong strncpy_from_user(char *dst, const char __user *src, long count)\n{\n\tunsigned long max_addr, src_addr;\n\n\tmight_fault();\n\tif (should_fail_usercopy())\n\t\treturn -EFAULT;\n\tif (unlikely(count <= 0))\n\t\treturn 0;\n\n\tmax_addr = TASK_SIZE_MAX;\n\tsrc_addr = (unsigned long)untagged_addr(src);\n\tif (likely(src_addr < max_addr)) {\n\t\tunsigned long max = max_addr - src_addr;\n\t\tlong retval;\n\n\t\t \n\t\tif (max > count)\n\t\t\tmax = count;\n\n\t\tkasan_check_write(dst, count);\n\t\tcheck_object_size(dst, count, false);\n\t\tif (user_read_access_begin(src, max)) {\n\t\t\tretval = do_strncpy_from_user(dst, src, count, max);\n\t\t\tuser_read_access_end();\n\t\t\treturn retval;\n\t\t}\n\t}\n\treturn -EFAULT;\n}\nEXPORT_SYMBOL(strncpy_from_user);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}