{
  "module_name": "checksum.c",
  "hash_id": "51182d4fd1437678aa63a7b897529aea5b0877546b6ba10ec52cbd2a1a2ac29c",
  "original_prompt": "Ingested from linux-6.6.14/lib/checksum.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/export.h>\n#include <net/checksum.h>\n\n#include <asm/byteorder.h>\n\n#ifndef do_csum\nstatic inline unsigned short from32to16(unsigned int x)\n{\n\t \n\tx = (x & 0xffff) + (x >> 16);\n\t \n\tx = (x & 0xffff) + (x >> 16);\n\treturn x;\n}\n\nstatic unsigned int do_csum(const unsigned char *buff, int len)\n{\n\tint odd;\n\tunsigned int result = 0;\n\n\tif (len <= 0)\n\t\tgoto out;\n\todd = 1 & (unsigned long) buff;\n\tif (odd) {\n#ifdef __LITTLE_ENDIAN\n\t\tresult += (*buff << 8);\n#else\n\t\tresult = *buff;\n#endif\n\t\tlen--;\n\t\tbuff++;\n\t}\n\tif (len >= 2) {\n\t\tif (2 & (unsigned long) buff) {\n\t\t\tresult += *(unsigned short *) buff;\n\t\t\tlen -= 2;\n\t\t\tbuff += 2;\n\t\t}\n\t\tif (len >= 4) {\n\t\t\tconst unsigned char *end = buff + ((unsigned)len & ~3);\n\t\t\tunsigned int carry = 0;\n\t\t\tdo {\n\t\t\t\tunsigned int w = *(unsigned int *) buff;\n\t\t\t\tbuff += 4;\n\t\t\t\tresult += carry;\n\t\t\t\tresult += w;\n\t\t\t\tcarry = (w > result);\n\t\t\t} while (buff < end);\n\t\t\tresult += carry;\n\t\t\tresult = (result & 0xffff) + (result >> 16);\n\t\t}\n\t\tif (len & 2) {\n\t\t\tresult += *(unsigned short *) buff;\n\t\t\tbuff += 2;\n\t\t}\n\t}\n\tif (len & 1)\n#ifdef __LITTLE_ENDIAN\n\t\tresult += *buff;\n#else\n\t\tresult += (*buff << 8);\n#endif\n\tresult = from32to16(result);\n\tif (odd)\n\t\tresult = ((result >> 8) & 0xff) | ((result & 0xff) << 8);\nout:\n\treturn result;\n}\n#endif\n\n#ifndef ip_fast_csum\n \n__sum16 ip_fast_csum(const void *iph, unsigned int ihl)\n{\n\treturn (__force __sum16)~do_csum(iph, ihl*4);\n}\nEXPORT_SYMBOL(ip_fast_csum);\n#endif\n\n \n__wsum csum_partial(const void *buff, int len, __wsum wsum)\n{\n\tunsigned int sum = (__force unsigned int)wsum;\n\tunsigned int result = do_csum(buff, len);\n\n\t \n\tresult += sum;\n\tif (sum > result)\n\t\tresult += 1;\n\treturn (__force __wsum)result;\n}\nEXPORT_SYMBOL(csum_partial);\n\n \n__sum16 ip_compute_csum(const void *buff, int len)\n{\n\treturn (__force __sum16)~do_csum(buff, len);\n}\nEXPORT_SYMBOL(ip_compute_csum);\n\n#ifndef csum_tcpudp_nofold\nstatic inline u32 from64to32(u64 x)\n{\n\t \n\tx = (x & 0xffffffff) + (x >> 32);\n\t \n\tx = (x & 0xffffffff) + (x >> 32);\n\treturn (u32)x;\n}\n\n__wsum csum_tcpudp_nofold(__be32 saddr, __be32 daddr,\n\t\t\t  __u32 len, __u8 proto, __wsum sum)\n{\n\tunsigned long long s = (__force u32)sum;\n\n\ts += (__force u32)saddr;\n\ts += (__force u32)daddr;\n#ifdef __BIG_ENDIAN\n\ts += proto + len;\n#else\n\ts += (proto + len) << 8;\n#endif\n\treturn (__force __wsum)from64to32(s);\n}\nEXPORT_SYMBOL(csum_tcpudp_nofold);\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}