{
  "module_name": "test_firmware.c",
  "hash_id": "0d262295a16e87db75414f0da85aa87044c1df50302d464edc936c4e4355f732",
  "original_prompt": "Ingested from linux-6.6.14/lib/test_firmware.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/printk.h>\n#include <linux/completion.h>\n#include <linux/firmware.h>\n#include <linux/device.h>\n#include <linux/fs.h>\n#include <linux/miscdevice.h>\n#include <linux/sizes.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/kstrtox.h>\n#include <linux/kthread.h>\n#include <linux/vmalloc.h>\n#include <linux/efi_embedded_fw.h>\n\nMODULE_IMPORT_NS(TEST_FIRMWARE);\n\n#define TEST_FIRMWARE_NAME\t\"test-firmware.bin\"\n#define TEST_FIRMWARE_NUM_REQS\t4\n#define TEST_FIRMWARE_BUF_SIZE\tSZ_1K\n#define TEST_UPLOAD_MAX_SIZE\tSZ_2K\n#define TEST_UPLOAD_BLK_SIZE\t37\t \n\nstatic DEFINE_MUTEX(test_fw_mutex);\nstatic const struct firmware *test_firmware;\nstatic LIST_HEAD(test_upload_list);\n\nstruct test_batched_req {\n\tu8 idx;\n\tint rc;\n\tbool sent;\n\tconst struct firmware *fw;\n\tconst char *name;\n\tconst char *fw_buf;\n\tstruct completion completion;\n\tstruct task_struct *task;\n\tstruct device *dev;\n};\n\n \nstruct test_config {\n\tchar *name;\n\tbool into_buf;\n\tsize_t buf_size;\n\tsize_t file_offset;\n\tbool partial;\n\tbool sync_direct;\n\tbool send_uevent;\n\tu8 num_requests;\n\tu8 read_fw_idx;\n\tchar *upload_name;\n\n\t \n\tstruct test_batched_req *reqs;\n\tint test_result;\n\tint (*req_firmware)(const struct firmware **fw, const char *name,\n\t\t\t    struct device *device);\n};\n\nstruct upload_inject_err {\n\tconst char *prog;\n\tenum fw_upload_err err_code;\n};\n\nstruct test_firmware_upload {\n\tchar *name;\n\tstruct list_head node;\n\tchar *buf;\n\tsize_t size;\n\tbool cancel_request;\n\tstruct upload_inject_err inject;\n\tstruct fw_upload *fwl;\n};\n\nstatic struct test_config *test_fw_config;\n\nstatic struct test_firmware_upload *upload_lookup_name(const char *name)\n{\n\tstruct test_firmware_upload *tst;\n\n\tlist_for_each_entry(tst, &test_upload_list, node)\n\t\tif (strncmp(name, tst->name, strlen(tst->name)) == 0)\n\t\t\treturn tst;\n\n\treturn NULL;\n}\n\nstatic ssize_t test_fw_misc_read(struct file *f, char __user *buf,\n\t\t\t\t size_t size, loff_t *offset)\n{\n\tssize_t rc = 0;\n\n\tmutex_lock(&test_fw_mutex);\n\tif (test_firmware)\n\t\trc = simple_read_from_buffer(buf, size, offset,\n\t\t\t\t\t     test_firmware->data,\n\t\t\t\t\t     test_firmware->size);\n\tmutex_unlock(&test_fw_mutex);\n\treturn rc;\n}\n\nstatic const struct file_operations test_fw_fops = {\n\t.owner          = THIS_MODULE,\n\t.read           = test_fw_misc_read,\n};\n\nstatic void __test_release_all_firmware(void)\n{\n\tstruct test_batched_req *req;\n\tu8 i;\n\n\tif (!test_fw_config->reqs)\n\t\treturn;\n\n\tfor (i = 0; i < test_fw_config->num_requests; i++) {\n\t\treq = &test_fw_config->reqs[i];\n\t\tif (req->fw) {\n\t\t\tif (req->fw_buf) {\n\t\t\t\tkfree_const(req->fw_buf);\n\t\t\t\treq->fw_buf = NULL;\n\t\t\t}\n\t\t\trelease_firmware(req->fw);\n\t\t\treq->fw = NULL;\n\t\t}\n\t}\n\n\tvfree(test_fw_config->reqs);\n\ttest_fw_config->reqs = NULL;\n}\n\nstatic void test_release_all_firmware(void)\n{\n\tmutex_lock(&test_fw_mutex);\n\t__test_release_all_firmware();\n\tmutex_unlock(&test_fw_mutex);\n}\n\n\nstatic void __test_firmware_config_free(void)\n{\n\t__test_release_all_firmware();\n\tkfree_const(test_fw_config->name);\n\ttest_fw_config->name = NULL;\n}\n\n \nstatic int __kstrncpy(char **dst, const char *name, size_t count, gfp_t gfp)\n{\n\t*dst = kstrndup(name, count, gfp);\n\tif (!*dst)\n\t\treturn -ENOMEM;\n\treturn count;\n}\n\nstatic int __test_firmware_config_init(void)\n{\n\tint ret;\n\n\tret = __kstrncpy(&test_fw_config->name, TEST_FIRMWARE_NAME,\n\t\t\t strlen(TEST_FIRMWARE_NAME), GFP_KERNEL);\n\tif (ret < 0)\n\t\tgoto out;\n\n\ttest_fw_config->num_requests = TEST_FIRMWARE_NUM_REQS;\n\ttest_fw_config->send_uevent = true;\n\ttest_fw_config->into_buf = false;\n\ttest_fw_config->buf_size = TEST_FIRMWARE_BUF_SIZE;\n\ttest_fw_config->file_offset = 0;\n\ttest_fw_config->partial = false;\n\ttest_fw_config->sync_direct = false;\n\ttest_fw_config->req_firmware = request_firmware;\n\ttest_fw_config->test_result = 0;\n\ttest_fw_config->reqs = NULL;\n\ttest_fw_config->upload_name = NULL;\n\n\treturn 0;\n\nout:\n\t__test_firmware_config_free();\n\treturn ret;\n}\n\nstatic ssize_t reset_store(struct device *dev,\n\t\t\t   struct device_attribute *attr,\n\t\t\t   const char *buf, size_t count)\n{\n\tint ret;\n\n\tmutex_lock(&test_fw_mutex);\n\n\t__test_firmware_config_free();\n\n\tret = __test_firmware_config_init();\n\tif (ret < 0) {\n\t\tret = -ENOMEM;\n\t\tpr_err(\"could not alloc settings for config trigger: %d\\n\",\n\t\t       ret);\n\t\tgoto out;\n\t}\n\n\tpr_info(\"reset\\n\");\n\tret = count;\n\nout:\n\tmutex_unlock(&test_fw_mutex);\n\n\treturn ret;\n}\nstatic DEVICE_ATTR_WO(reset);\n\nstatic ssize_t config_show(struct device *dev,\n\t\t\t   struct device_attribute *attr,\n\t\t\t   char *buf)\n{\n\tint len = 0;\n\n\tmutex_lock(&test_fw_mutex);\n\n\tlen += scnprintf(buf, PAGE_SIZE - len,\n\t\t\t\"Custom trigger configuration for: %s\\n\",\n\t\t\tdev_name(dev));\n\n\tif (test_fw_config->name)\n\t\tlen += scnprintf(buf + len, PAGE_SIZE - len,\n\t\t\t\t\"name:\\t%s\\n\",\n\t\t\t\ttest_fw_config->name);\n\telse\n\t\tlen += scnprintf(buf + len, PAGE_SIZE - len,\n\t\t\t\t\"name:\\tEMPTY\\n\");\n\n\tlen += scnprintf(buf + len, PAGE_SIZE - len,\n\t\t\t\"num_requests:\\t%u\\n\", test_fw_config->num_requests);\n\n\tlen += scnprintf(buf + len, PAGE_SIZE - len,\n\t\t\t\"send_uevent:\\t\\t%s\\n\",\n\t\t\ttest_fw_config->send_uevent ?\n\t\t\t\"FW_ACTION_UEVENT\" :\n\t\t\t\"FW_ACTION_NOUEVENT\");\n\tlen += scnprintf(buf + len, PAGE_SIZE - len,\n\t\t\t\"into_buf:\\t\\t%s\\n\",\n\t\t\ttest_fw_config->into_buf ? \"true\" : \"false\");\n\tlen += scnprintf(buf + len, PAGE_SIZE - len,\n\t\t\t\"buf_size:\\t%zu\\n\", test_fw_config->buf_size);\n\tlen += scnprintf(buf + len, PAGE_SIZE - len,\n\t\t\t\"file_offset:\\t%zu\\n\", test_fw_config->file_offset);\n\tlen += scnprintf(buf + len, PAGE_SIZE - len,\n\t\t\t\"partial:\\t\\t%s\\n\",\n\t\t\ttest_fw_config->partial ? \"true\" : \"false\");\n\tlen += scnprintf(buf + len, PAGE_SIZE - len,\n\t\t\t\"sync_direct:\\t\\t%s\\n\",\n\t\t\ttest_fw_config->sync_direct ? \"true\" : \"false\");\n\tlen += scnprintf(buf + len, PAGE_SIZE - len,\n\t\t\t\"read_fw_idx:\\t%u\\n\", test_fw_config->read_fw_idx);\n\tif (test_fw_config->upload_name)\n\t\tlen += scnprintf(buf + len, PAGE_SIZE - len,\n\t\t\t\t\"upload_name:\\t%s\\n\",\n\t\t\t\ttest_fw_config->upload_name);\n\telse\n\t\tlen += scnprintf(buf + len, PAGE_SIZE - len,\n\t\t\t\t\"upload_name:\\tEMPTY\\n\");\n\n\tmutex_unlock(&test_fw_mutex);\n\n\treturn len;\n}\nstatic DEVICE_ATTR_RO(config);\n\nstatic ssize_t config_name_store(struct device *dev,\n\t\t\t\t struct device_attribute *attr,\n\t\t\t\t const char *buf, size_t count)\n{\n\tint ret;\n\n\tmutex_lock(&test_fw_mutex);\n\tkfree_const(test_fw_config->name);\n\tret = __kstrncpy(&test_fw_config->name, buf, count, GFP_KERNEL);\n\tmutex_unlock(&test_fw_mutex);\n\n\treturn ret;\n}\n\n \nstatic ssize_t config_test_show_str(char *dst,\n\t\t\t\t    char *src)\n{\n\tint len;\n\n\tmutex_lock(&test_fw_mutex);\n\tlen = snprintf(dst, PAGE_SIZE, \"%s\\n\", src);\n\tmutex_unlock(&test_fw_mutex);\n\n\treturn len;\n}\n\nstatic inline int __test_dev_config_update_bool(const char *buf, size_t size,\n\t\t\t\t       bool *cfg)\n{\n\tint ret;\n\n\tif (kstrtobool(buf, cfg) < 0)\n\t\tret = -EINVAL;\n\telse\n\t\tret = size;\n\n\treturn ret;\n}\n\nstatic int test_dev_config_update_bool(const char *buf, size_t size,\n\t\t\t\t       bool *cfg)\n{\n\tint ret;\n\n\tmutex_lock(&test_fw_mutex);\n\tret = __test_dev_config_update_bool(buf, size, cfg);\n\tmutex_unlock(&test_fw_mutex);\n\n\treturn ret;\n}\n\nstatic ssize_t test_dev_config_show_bool(char *buf, bool val)\n{\n\treturn snprintf(buf, PAGE_SIZE, \"%d\\n\", val);\n}\n\nstatic int __test_dev_config_update_size_t(\n\t\t\t\t\t const char *buf,\n\t\t\t\t\t size_t size,\n\t\t\t\t\t size_t *cfg)\n{\n\tint ret;\n\tlong new;\n\n\tret = kstrtol(buf, 10, &new);\n\tif (ret)\n\t\treturn ret;\n\n\t*(size_t *)cfg = new;\n\n\t \n\treturn size;\n}\n\nstatic ssize_t test_dev_config_show_size_t(char *buf, size_t val)\n{\n\treturn snprintf(buf, PAGE_SIZE, \"%zu\\n\", val);\n}\n\nstatic ssize_t test_dev_config_show_int(char *buf, int val)\n{\n\treturn snprintf(buf, PAGE_SIZE, \"%d\\n\", val);\n}\n\nstatic int __test_dev_config_update_u8(const char *buf, size_t size, u8 *cfg)\n{\n\tu8 val;\n\tint ret;\n\n\tret = kstrtou8(buf, 10, &val);\n\tif (ret)\n\t\treturn ret;\n\n\t*(u8 *)cfg = val;\n\n\t \n\treturn size;\n}\n\nstatic int test_dev_config_update_u8(const char *buf, size_t size, u8 *cfg)\n{\n\tint ret;\n\n\tmutex_lock(&test_fw_mutex);\n\tret = __test_dev_config_update_u8(buf, size, cfg);\n\tmutex_unlock(&test_fw_mutex);\n\n\treturn ret;\n}\n\nstatic ssize_t test_dev_config_show_u8(char *buf, u8 val)\n{\n\treturn snprintf(buf, PAGE_SIZE, \"%u\\n\", val);\n}\n\nstatic ssize_t config_name_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr,\n\t\t\t\tchar *buf)\n{\n\treturn config_test_show_str(buf, test_fw_config->name);\n}\nstatic DEVICE_ATTR_RW(config_name);\n\nstatic ssize_t config_upload_name_store(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tconst char *buf, size_t count)\n{\n\tstruct test_firmware_upload *tst;\n\tint ret = count;\n\n\tmutex_lock(&test_fw_mutex);\n\ttst = upload_lookup_name(buf);\n\tif (tst)\n\t\ttest_fw_config->upload_name = tst->name;\n\telse\n\t\tret = -EINVAL;\n\tmutex_unlock(&test_fw_mutex);\n\n\treturn ret;\n}\n\nstatic ssize_t config_upload_name_show(struct device *dev,\n\t\t\t\t       struct device_attribute *attr,\n\t\t\t\t       char *buf)\n{\n\treturn config_test_show_str(buf, test_fw_config->upload_name);\n}\nstatic DEVICE_ATTR_RW(config_upload_name);\n\nstatic ssize_t config_num_requests_store(struct device *dev,\n\t\t\t\t\t struct device_attribute *attr,\n\t\t\t\t\t const char *buf, size_t count)\n{\n\tint rc;\n\n\tmutex_lock(&test_fw_mutex);\n\tif (test_fw_config->reqs) {\n\t\tpr_err(\"Must call release_all_firmware prior to changing config\\n\");\n\t\trc = -EINVAL;\n\t\tmutex_unlock(&test_fw_mutex);\n\t\tgoto out;\n\t}\n\n\trc = __test_dev_config_update_u8(buf, count,\n\t\t\t\t\t &test_fw_config->num_requests);\n\tmutex_unlock(&test_fw_mutex);\n\nout:\n\treturn rc;\n}\n\nstatic ssize_t config_num_requests_show(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tchar *buf)\n{\n\treturn test_dev_config_show_u8(buf, test_fw_config->num_requests);\n}\nstatic DEVICE_ATTR_RW(config_num_requests);\n\nstatic ssize_t config_into_buf_store(struct device *dev,\n\t\t\t\t     struct device_attribute *attr,\n\t\t\t\t     const char *buf, size_t count)\n{\n\treturn test_dev_config_update_bool(buf,\n\t\t\t\t\t   count,\n\t\t\t\t\t   &test_fw_config->into_buf);\n}\n\nstatic ssize_t config_into_buf_show(struct device *dev,\n\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t    char *buf)\n{\n\treturn test_dev_config_show_bool(buf, test_fw_config->into_buf);\n}\nstatic DEVICE_ATTR_RW(config_into_buf);\n\nstatic ssize_t config_buf_size_store(struct device *dev,\n\t\t\t\t     struct device_attribute *attr,\n\t\t\t\t     const char *buf, size_t count)\n{\n\tint rc;\n\n\tmutex_lock(&test_fw_mutex);\n\tif (test_fw_config->reqs) {\n\t\tpr_err(\"Must call release_all_firmware prior to changing config\\n\");\n\t\trc = -EINVAL;\n\t\tmutex_unlock(&test_fw_mutex);\n\t\tgoto out;\n\t}\n\n\trc = __test_dev_config_update_size_t(buf, count,\n\t\t\t\t\t     &test_fw_config->buf_size);\n\tmutex_unlock(&test_fw_mutex);\n\nout:\n\treturn rc;\n}\n\nstatic ssize_t config_buf_size_show(struct device *dev,\n\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t    char *buf)\n{\n\treturn test_dev_config_show_size_t(buf, test_fw_config->buf_size);\n}\nstatic DEVICE_ATTR_RW(config_buf_size);\n\nstatic ssize_t config_file_offset_store(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tconst char *buf, size_t count)\n{\n\tint rc;\n\n\tmutex_lock(&test_fw_mutex);\n\tif (test_fw_config->reqs) {\n\t\tpr_err(\"Must call release_all_firmware prior to changing config\\n\");\n\t\trc = -EINVAL;\n\t\tmutex_unlock(&test_fw_mutex);\n\t\tgoto out;\n\t}\n\n\trc = __test_dev_config_update_size_t(buf, count,\n\t\t\t\t\t     &test_fw_config->file_offset);\n\tmutex_unlock(&test_fw_mutex);\n\nout:\n\treturn rc;\n}\n\nstatic ssize_t config_file_offset_show(struct device *dev,\n\t\t\t\t       struct device_attribute *attr,\n\t\t\t\t       char *buf)\n{\n\treturn test_dev_config_show_size_t(buf, test_fw_config->file_offset);\n}\nstatic DEVICE_ATTR_RW(config_file_offset);\n\nstatic ssize_t config_partial_store(struct device *dev,\n\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t    const char *buf, size_t count)\n{\n\treturn test_dev_config_update_bool(buf,\n\t\t\t\t\t   count,\n\t\t\t\t\t   &test_fw_config->partial);\n}\n\nstatic ssize_t config_partial_show(struct device *dev,\n\t\t\t\t   struct device_attribute *attr,\n\t\t\t\t   char *buf)\n{\n\treturn test_dev_config_show_bool(buf, test_fw_config->partial);\n}\nstatic DEVICE_ATTR_RW(config_partial);\n\nstatic ssize_t config_sync_direct_store(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tconst char *buf, size_t count)\n{\n\tint rc = test_dev_config_update_bool(buf, count,\n\t\t\t\t\t     &test_fw_config->sync_direct);\n\n\tif (rc == count)\n\t\ttest_fw_config->req_firmware = test_fw_config->sync_direct ?\n\t\t\t\t       request_firmware_direct :\n\t\t\t\t       request_firmware;\n\treturn rc;\n}\n\nstatic ssize_t config_sync_direct_show(struct device *dev,\n\t\t\t\t       struct device_attribute *attr,\n\t\t\t\t       char *buf)\n{\n\treturn test_dev_config_show_bool(buf, test_fw_config->sync_direct);\n}\nstatic DEVICE_ATTR_RW(config_sync_direct);\n\nstatic ssize_t config_send_uevent_store(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tconst char *buf, size_t count)\n{\n\treturn test_dev_config_update_bool(buf, count,\n\t\t\t\t\t   &test_fw_config->send_uevent);\n}\n\nstatic ssize_t config_send_uevent_show(struct device *dev,\n\t\t\t\t       struct device_attribute *attr,\n\t\t\t\t       char *buf)\n{\n\treturn test_dev_config_show_bool(buf, test_fw_config->send_uevent);\n}\nstatic DEVICE_ATTR_RW(config_send_uevent);\n\nstatic ssize_t config_read_fw_idx_store(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tconst char *buf, size_t count)\n{\n\treturn test_dev_config_update_u8(buf, count,\n\t\t\t\t\t &test_fw_config->read_fw_idx);\n}\n\nstatic ssize_t config_read_fw_idx_show(struct device *dev,\n\t\t\t\t       struct device_attribute *attr,\n\t\t\t\t       char *buf)\n{\n\treturn test_dev_config_show_u8(buf, test_fw_config->read_fw_idx);\n}\nstatic DEVICE_ATTR_RW(config_read_fw_idx);\n\n\nstatic ssize_t trigger_request_store(struct device *dev,\n\t\t\t\t     struct device_attribute *attr,\n\t\t\t\t     const char *buf, size_t count)\n{\n\tint rc;\n\tchar *name;\n\n\tname = kstrndup(buf, count, GFP_KERNEL);\n\tif (!name)\n\t\treturn -ENOMEM;\n\n\tpr_info(\"loading '%s'\\n\", name);\n\n\tmutex_lock(&test_fw_mutex);\n\trelease_firmware(test_firmware);\n\tif (test_fw_config->reqs)\n\t\t__test_release_all_firmware();\n\ttest_firmware = NULL;\n\trc = request_firmware(&test_firmware, name, dev);\n\tif (rc) {\n\t\tpr_info(\"load of '%s' failed: %d\\n\", name, rc);\n\t\tgoto out;\n\t}\n\tpr_info(\"loaded: %zu\\n\", test_firmware->size);\n\trc = count;\n\nout:\n\tmutex_unlock(&test_fw_mutex);\n\n\tkfree(name);\n\n\treturn rc;\n}\nstatic DEVICE_ATTR_WO(trigger_request);\n\n#ifdef CONFIG_EFI_EMBEDDED_FIRMWARE\nextern struct list_head efi_embedded_fw_list;\nextern bool efi_embedded_fw_checked;\n\nstatic ssize_t trigger_request_platform_store(struct device *dev,\n\t\t\t\t\t      struct device_attribute *attr,\n\t\t\t\t\t      const char *buf, size_t count)\n{\n\tstatic const u8 test_data[] = {\n\t\t0x55, 0xaa, 0x55, 0xaa, 0x01, 0x02, 0x03, 0x04,\n\t\t0x55, 0xaa, 0x55, 0xaa, 0x05, 0x06, 0x07, 0x08,\n\t\t0x55, 0xaa, 0x55, 0xaa, 0x10, 0x20, 0x30, 0x40,\n\t\t0x55, 0xaa, 0x55, 0xaa, 0x50, 0x60, 0x70, 0x80\n\t};\n\tstruct efi_embedded_fw efi_embedded_fw;\n\tconst struct firmware *firmware = NULL;\n\tbool saved_efi_embedded_fw_checked;\n\tchar *name;\n\tint rc;\n\n\tname = kstrndup(buf, count, GFP_KERNEL);\n\tif (!name)\n\t\treturn -ENOMEM;\n\n\tpr_info(\"inserting test platform fw '%s'\\n\", name);\n\tefi_embedded_fw.name = name;\n\tefi_embedded_fw.data = (void *)test_data;\n\tefi_embedded_fw.length = sizeof(test_data);\n\tlist_add(&efi_embedded_fw.list, &efi_embedded_fw_list);\n\tsaved_efi_embedded_fw_checked = efi_embedded_fw_checked;\n\tefi_embedded_fw_checked = true;\n\n\tpr_info(\"loading '%s'\\n\", name);\n\trc = firmware_request_platform(&firmware, name, dev);\n\tif (rc) {\n\t\tpr_info(\"load of '%s' failed: %d\\n\", name, rc);\n\t\tgoto out;\n\t}\n\tif (firmware->size != sizeof(test_data) ||\n\t    memcmp(firmware->data, test_data, sizeof(test_data)) != 0) {\n\t\tpr_info(\"firmware contents mismatch for '%s'\\n\", name);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\tpr_info(\"loaded: %zu\\n\", firmware->size);\n\trc = count;\n\nout:\n\tefi_embedded_fw_checked = saved_efi_embedded_fw_checked;\n\trelease_firmware(firmware);\n\tlist_del(&efi_embedded_fw.list);\n\tkfree(name);\n\n\treturn rc;\n}\nstatic DEVICE_ATTR_WO(trigger_request_platform);\n#endif\n\nstatic DECLARE_COMPLETION(async_fw_done);\n\nstatic void trigger_async_request_cb(const struct firmware *fw, void *context)\n{\n\ttest_firmware = fw;\n\tcomplete(&async_fw_done);\n}\n\nstatic ssize_t trigger_async_request_store(struct device *dev,\n\t\t\t\t\t   struct device_attribute *attr,\n\t\t\t\t\t   const char *buf, size_t count)\n{\n\tint rc;\n\tchar *name;\n\n\tname = kstrndup(buf, count, GFP_KERNEL);\n\tif (!name)\n\t\treturn -ENOMEM;\n\n\tpr_info(\"loading '%s'\\n\", name);\n\n\tmutex_lock(&test_fw_mutex);\n\trelease_firmware(test_firmware);\n\ttest_firmware = NULL;\n\tif (test_fw_config->reqs)\n\t\t__test_release_all_firmware();\n\trc = request_firmware_nowait(THIS_MODULE, 1, name, dev, GFP_KERNEL,\n\t\t\t\t     NULL, trigger_async_request_cb);\n\tif (rc) {\n\t\tpr_info(\"async load of '%s' failed: %d\\n\", name, rc);\n\t\tkfree(name);\n\t\tgoto out;\n\t}\n\t \n\tkfree(name);\n\n\twait_for_completion(&async_fw_done);\n\n\tif (test_firmware) {\n\t\tpr_info(\"loaded: %zu\\n\", test_firmware->size);\n\t\trc = count;\n\t} else {\n\t\tpr_err(\"failed to async load firmware\\n\");\n\t\trc = -ENOMEM;\n\t}\n\nout:\n\tmutex_unlock(&test_fw_mutex);\n\n\treturn rc;\n}\nstatic DEVICE_ATTR_WO(trigger_async_request);\n\nstatic ssize_t trigger_custom_fallback_store(struct device *dev,\n\t\t\t\t\t     struct device_attribute *attr,\n\t\t\t\t\t     const char *buf, size_t count)\n{\n\tint rc;\n\tchar *name;\n\n\tname = kstrndup(buf, count, GFP_KERNEL);\n\tif (!name)\n\t\treturn -ENOMEM;\n\n\tpr_info(\"loading '%s' using custom fallback mechanism\\n\", name);\n\n\tmutex_lock(&test_fw_mutex);\n\trelease_firmware(test_firmware);\n\tif (test_fw_config->reqs)\n\t\t__test_release_all_firmware();\n\ttest_firmware = NULL;\n\trc = request_firmware_nowait(THIS_MODULE, FW_ACTION_NOUEVENT, name,\n\t\t\t\t     dev, GFP_KERNEL, NULL,\n\t\t\t\t     trigger_async_request_cb);\n\tif (rc) {\n\t\tpr_info(\"async load of '%s' failed: %d\\n\", name, rc);\n\t\tkfree(name);\n\t\tgoto out;\n\t}\n\t \n\tkfree(name);\n\n\twait_for_completion(&async_fw_done);\n\n\tif (test_firmware) {\n\t\tpr_info(\"loaded: %zu\\n\", test_firmware->size);\n\t\trc = count;\n\t} else {\n\t\tpr_err(\"failed to async load firmware\\n\");\n\t\trc = -ENODEV;\n\t}\n\nout:\n\tmutex_unlock(&test_fw_mutex);\n\n\treturn rc;\n}\nstatic DEVICE_ATTR_WO(trigger_custom_fallback);\n\nstatic int test_fw_run_batch_request(void *data)\n{\n\tstruct test_batched_req *req = data;\n\n\tif (!req) {\n\t\ttest_fw_config->test_result = -EINVAL;\n\t\treturn -EINVAL;\n\t}\n\n\tif (test_fw_config->into_buf) {\n\t\tvoid *test_buf;\n\n\t\ttest_buf = kzalloc(TEST_FIRMWARE_BUF_SIZE, GFP_KERNEL);\n\t\tif (!test_buf)\n\t\t\treturn -ENOMEM;\n\n\t\tif (test_fw_config->partial)\n\t\t\treq->rc = request_partial_firmware_into_buf\n\t\t\t\t\t\t(&req->fw,\n\t\t\t\t\t\t req->name,\n\t\t\t\t\t\t req->dev,\n\t\t\t\t\t\t test_buf,\n\t\t\t\t\t\t test_fw_config->buf_size,\n\t\t\t\t\t\t test_fw_config->file_offset);\n\t\telse\n\t\t\treq->rc = request_firmware_into_buf\n\t\t\t\t\t\t(&req->fw,\n\t\t\t\t\t\t req->name,\n\t\t\t\t\t\t req->dev,\n\t\t\t\t\t\t test_buf,\n\t\t\t\t\t\t test_fw_config->buf_size);\n\t\tif (!req->fw)\n\t\t\tkfree(test_buf);\n\t\telse\n\t\t\treq->fw_buf = test_buf;\n\t} else {\n\t\treq->rc = test_fw_config->req_firmware(&req->fw,\n\t\t\t\t\t\t       req->name,\n\t\t\t\t\t\t       req->dev);\n\t}\n\n\tif (req->rc) {\n\t\tpr_info(\"#%u: batched sync load failed: %d\\n\",\n\t\t\treq->idx, req->rc);\n\t\tif (!test_fw_config->test_result)\n\t\t\ttest_fw_config->test_result = req->rc;\n\t} else if (req->fw) {\n\t\treq->sent = true;\n\t\tpr_info(\"#%u: batched sync loaded %zu\\n\",\n\t\t\treq->idx, req->fw->size);\n\t}\n\tcomplete(&req->completion);\n\n\treq->task = NULL;\n\n\treturn 0;\n}\n\n \nstatic ssize_t trigger_batched_requests_store(struct device *dev,\n\t\t\t\t\t      struct device_attribute *attr,\n\t\t\t\t\t      const char *buf, size_t count)\n{\n\tstruct test_batched_req *req;\n\tint rc;\n\tu8 i;\n\n\tmutex_lock(&test_fw_mutex);\n\n\tif (test_fw_config->reqs) {\n\t\trc = -EBUSY;\n\t\tgoto out_bail;\n\t}\n\n\ttest_fw_config->reqs =\n\t\tvzalloc(array3_size(sizeof(struct test_batched_req),\n\t\t\t\t    test_fw_config->num_requests, 2));\n\tif (!test_fw_config->reqs) {\n\t\trc = -ENOMEM;\n\t\tgoto out_unlock;\n\t}\n\n\tpr_info(\"batched sync firmware loading '%s' %u times\\n\",\n\t\ttest_fw_config->name, test_fw_config->num_requests);\n\n\tfor (i = 0; i < test_fw_config->num_requests; i++) {\n\t\treq = &test_fw_config->reqs[i];\n\t\treq->fw = NULL;\n\t\treq->idx = i;\n\t\treq->name = test_fw_config->name;\n\t\treq->fw_buf = NULL;\n\t\treq->dev = dev;\n\t\tinit_completion(&req->completion);\n\t\treq->task = kthread_run(test_fw_run_batch_request, req,\n\t\t\t\t\t     \"%s-%u\", KBUILD_MODNAME, req->idx);\n\t\tif (!req->task || IS_ERR(req->task)) {\n\t\t\tpr_err(\"Setting up thread %u failed\\n\", req->idx);\n\t\t\treq->task = NULL;\n\t\t\trc = -ENOMEM;\n\t\t\tgoto out_bail;\n\t\t}\n\t}\n\n\trc = count;\n\n\t \n\nout_bail:\n\tfor (i = 0; i < test_fw_config->num_requests; i++) {\n\t\treq = &test_fw_config->reqs[i];\n\t\tif (req->task || req->sent)\n\t\t\twait_for_completion(&req->completion);\n\t}\n\n\t \n\tif (rc < 0)\n\t\ttest_fw_config->test_result = rc;\n\nout_unlock:\n\tmutex_unlock(&test_fw_mutex);\n\n\treturn rc;\n}\nstatic DEVICE_ATTR_WO(trigger_batched_requests);\n\n \nstatic void trigger_batched_cb(const struct firmware *fw, void *context)\n{\n\tstruct test_batched_req *req = context;\n\n\tif (!req) {\n\t\ttest_fw_config->test_result = -EINVAL;\n\t\treturn;\n\t}\n\n\t \n\tif (!req->idx)\n\t\tssleep(2);\n\n\treq->fw = fw;\n\n\t \n\tif (!fw && !test_fw_config->test_result)\n\t\ttest_fw_config->test_result = -ENOENT;\n\n\tcomplete(&req->completion);\n}\n\nstatic\nssize_t trigger_batched_requests_async_store(struct device *dev,\n\t\t\t\t\t     struct device_attribute *attr,\n\t\t\t\t\t     const char *buf, size_t count)\n{\n\tstruct test_batched_req *req;\n\tbool send_uevent;\n\tint rc;\n\tu8 i;\n\n\tmutex_lock(&test_fw_mutex);\n\n\tif (test_fw_config->reqs) {\n\t\trc = -EBUSY;\n\t\tgoto out_bail;\n\t}\n\n\ttest_fw_config->reqs =\n\t\tvzalloc(array3_size(sizeof(struct test_batched_req),\n\t\t\t\t    test_fw_config->num_requests, 2));\n\tif (!test_fw_config->reqs) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tpr_info(\"batched loading '%s' custom fallback mechanism %u times\\n\",\n\t\ttest_fw_config->name, test_fw_config->num_requests);\n\n\tsend_uevent = test_fw_config->send_uevent ? FW_ACTION_UEVENT :\n\t\tFW_ACTION_NOUEVENT;\n\n\tfor (i = 0; i < test_fw_config->num_requests; i++) {\n\t\treq = &test_fw_config->reqs[i];\n\t\treq->name = test_fw_config->name;\n\t\treq->fw_buf = NULL;\n\t\treq->fw = NULL;\n\t\treq->idx = i;\n\t\tinit_completion(&req->completion);\n\t\trc = request_firmware_nowait(THIS_MODULE, send_uevent,\n\t\t\t\t\t     req->name,\n\t\t\t\t\t     dev, GFP_KERNEL, req,\n\t\t\t\t\t     trigger_batched_cb);\n\t\tif (rc) {\n\t\t\tpr_info(\"#%u: batched async load failed setup: %d\\n\",\n\t\t\t\ti, rc);\n\t\t\treq->rc = rc;\n\t\t\tgoto out_bail;\n\t\t} else\n\t\t\treq->sent = true;\n\t}\n\n\trc = count;\n\nout_bail:\n\n\t \n\n\tfor (i = 0; i < test_fw_config->num_requests; i++) {\n\t\treq = &test_fw_config->reqs[i];\n\t\tif (req->sent)\n\t\t\twait_for_completion(&req->completion);\n\t}\n\n\t \n\tif (rc < 0)\n\t\ttest_fw_config->test_result = rc;\n\nout:\n\tmutex_unlock(&test_fw_mutex);\n\n\treturn rc;\n}\nstatic DEVICE_ATTR_WO(trigger_batched_requests_async);\n\nstatic void upload_release(struct test_firmware_upload *tst)\n{\n\tfirmware_upload_unregister(tst->fwl);\n\tkfree(tst->buf);\n\tkfree(tst->name);\n\tkfree(tst);\n}\n\nstatic void upload_release_all(void)\n{\n\tstruct test_firmware_upload *tst, *tmp;\n\n\tlist_for_each_entry_safe(tst, tmp, &test_upload_list, node) {\n\t\tlist_del(&tst->node);\n\t\tupload_release(tst);\n\t}\n\ttest_fw_config->upload_name = NULL;\n}\n\n \nstatic const char * const fw_upload_err_str[] = {\n\t[FW_UPLOAD_ERR_NONE]\t     = \"none\",\n\t[FW_UPLOAD_ERR_HW_ERROR]     = \"hw-error\",\n\t[FW_UPLOAD_ERR_TIMEOUT]\t     = \"timeout\",\n\t[FW_UPLOAD_ERR_CANCELED]     = \"user-abort\",\n\t[FW_UPLOAD_ERR_BUSY]\t     = \"device-busy\",\n\t[FW_UPLOAD_ERR_INVALID_SIZE] = \"invalid-file-size\",\n\t[FW_UPLOAD_ERR_RW_ERROR]     = \"read-write-error\",\n\t[FW_UPLOAD_ERR_WEAROUT]\t     = \"flash-wearout\",\n};\n\nstatic void upload_err_inject_error(struct test_firmware_upload *tst,\n\t\t\t\t    const u8 *p, const char *prog)\n{\n\tenum fw_upload_err err;\n\n\tfor (err = FW_UPLOAD_ERR_NONE + 1; err < FW_UPLOAD_ERR_MAX; err++) {\n\t\tif (strncmp(p, fw_upload_err_str[err],\n\t\t\t    strlen(fw_upload_err_str[err])) == 0) {\n\t\t\ttst->inject.prog = prog;\n\t\t\ttst->inject.err_code = err;\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nstatic void upload_err_inject_prog(struct test_firmware_upload *tst,\n\t\t\t\t   const u8 *p)\n{\n\tstatic const char * const progs[] = {\n\t\t\"preparing:\", \"transferring:\", \"programming:\"\n\t};\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(progs); i++) {\n\t\tif (strncmp(p, progs[i], strlen(progs[i])) == 0) {\n\t\t\tupload_err_inject_error(tst, p + strlen(progs[i]),\n\t\t\t\t\t\tprogs[i]);\n\t\t\treturn;\n\t\t}\n\t}\n}\n\n#define FIVE_MINUTES_MS\t(5 * 60 * 1000)\nstatic enum fw_upload_err\nfw_upload_wait_on_cancel(struct test_firmware_upload *tst)\n{\n\tint ms_delay;\n\n\tfor (ms_delay = 0; ms_delay < FIVE_MINUTES_MS; ms_delay += 100) {\n\t\tmsleep(100);\n\t\tif (tst->cancel_request)\n\t\t\treturn FW_UPLOAD_ERR_CANCELED;\n\t}\n\treturn FW_UPLOAD_ERR_NONE;\n}\n\nstatic enum fw_upload_err test_fw_upload_prepare(struct fw_upload *fwl,\n\t\t\t\t\t\t const u8 *data, u32 size)\n{\n\tstruct test_firmware_upload *tst = fwl->dd_handle;\n\tenum fw_upload_err ret = FW_UPLOAD_ERR_NONE;\n\tconst char *progress = \"preparing:\";\n\n\ttst->cancel_request = false;\n\n\tif (!size || size > TEST_UPLOAD_MAX_SIZE) {\n\t\tret = FW_UPLOAD_ERR_INVALID_SIZE;\n\t\tgoto err_out;\n\t}\n\n\tif (strncmp(data, \"inject:\", strlen(\"inject:\")) == 0)\n\t\tupload_err_inject_prog(tst, data + strlen(\"inject:\"));\n\n\tmemset(tst->buf, 0, TEST_UPLOAD_MAX_SIZE);\n\ttst->size = size;\n\n\tif (tst->inject.err_code == FW_UPLOAD_ERR_NONE ||\n\t    strncmp(tst->inject.prog, progress, strlen(progress)) != 0)\n\t\treturn FW_UPLOAD_ERR_NONE;\n\n\tif (tst->inject.err_code == FW_UPLOAD_ERR_CANCELED)\n\t\tret = fw_upload_wait_on_cancel(tst);\n\telse\n\t\tret = tst->inject.err_code;\n\nerr_out:\n\t \n\ttst->inject.err_code = FW_UPLOAD_ERR_NONE;\n\ttst->inject.prog = NULL;\n\n\treturn ret;\n}\n\nstatic enum fw_upload_err test_fw_upload_write(struct fw_upload *fwl,\n\t\t\t\t\t       const u8 *data, u32 offset,\n\t\t\t\t\t       u32 size, u32 *written)\n{\n\tstruct test_firmware_upload *tst = fwl->dd_handle;\n\tconst char *progress = \"transferring:\";\n\tu32 blk_size;\n\n\tif (tst->cancel_request)\n\t\treturn FW_UPLOAD_ERR_CANCELED;\n\n\tblk_size = min_t(u32, TEST_UPLOAD_BLK_SIZE, size);\n\tmemcpy(tst->buf + offset, data + offset, blk_size);\n\n\t*written = blk_size;\n\n\tif (tst->inject.err_code == FW_UPLOAD_ERR_NONE ||\n\t    strncmp(tst->inject.prog, progress, strlen(progress)) != 0)\n\t\treturn FW_UPLOAD_ERR_NONE;\n\n\tif (tst->inject.err_code == FW_UPLOAD_ERR_CANCELED)\n\t\treturn fw_upload_wait_on_cancel(tst);\n\n\treturn tst->inject.err_code;\n}\n\nstatic enum fw_upload_err test_fw_upload_complete(struct fw_upload *fwl)\n{\n\tstruct test_firmware_upload *tst = fwl->dd_handle;\n\tconst char *progress = \"programming:\";\n\n\tif (tst->cancel_request)\n\t\treturn FW_UPLOAD_ERR_CANCELED;\n\n\tif (tst->inject.err_code == FW_UPLOAD_ERR_NONE ||\n\t    strncmp(tst->inject.prog, progress, strlen(progress)) != 0)\n\t\treturn FW_UPLOAD_ERR_NONE;\n\n\tif (tst->inject.err_code == FW_UPLOAD_ERR_CANCELED)\n\t\treturn fw_upload_wait_on_cancel(tst);\n\n\treturn tst->inject.err_code;\n}\n\nstatic void test_fw_upload_cancel(struct fw_upload *fwl)\n{\n\tstruct test_firmware_upload *tst = fwl->dd_handle;\n\n\ttst->cancel_request = true;\n}\n\nstatic void test_fw_cleanup(struct fw_upload *fwl)\n{\n\tstruct test_firmware_upload *tst = fwl->dd_handle;\n\n\ttst->inject.err_code = FW_UPLOAD_ERR_NONE;\n\ttst->inject.prog = NULL;\n}\n\nstatic const struct fw_upload_ops upload_test_ops = {\n\t.prepare = test_fw_upload_prepare,\n\t.write = test_fw_upload_write,\n\t.poll_complete = test_fw_upload_complete,\n\t.cancel = test_fw_upload_cancel,\n\t.cleanup = test_fw_cleanup\n};\n\nstatic ssize_t upload_register_store(struct device *dev,\n\t\t\t\t     struct device_attribute *attr,\n\t\t\t\t     const char *buf, size_t count)\n{\n\tstruct test_firmware_upload *tst;\n\tstruct fw_upload *fwl;\n\tchar *name;\n\tint ret;\n\n\tname = kstrndup(buf, count, GFP_KERNEL);\n\tif (!name)\n\t\treturn -ENOMEM;\n\n\tmutex_lock(&test_fw_mutex);\n\ttst = upload_lookup_name(name);\n\tif (tst) {\n\t\tret = -EEXIST;\n\t\tgoto free_name;\n\t}\n\n\ttst = kzalloc(sizeof(*tst), GFP_KERNEL);\n\tif (!tst) {\n\t\tret = -ENOMEM;\n\t\tgoto free_name;\n\t}\n\n\ttst->name = name;\n\ttst->buf = kzalloc(TEST_UPLOAD_MAX_SIZE, GFP_KERNEL);\n\tif (!tst->buf) {\n\t\tret = -ENOMEM;\n\t\tgoto free_tst;\n\t}\n\n\tfwl = firmware_upload_register(THIS_MODULE, dev, tst->name,\n\t\t\t\t       &upload_test_ops, tst);\n\tif (IS_ERR(fwl)) {\n\t\tret = PTR_ERR(fwl);\n\t\tgoto free_buf;\n\t}\n\n\ttst->fwl = fwl;\n\tlist_add_tail(&tst->node, &test_upload_list);\n\tmutex_unlock(&test_fw_mutex);\n\treturn count;\n\nfree_buf:\n\tkfree(tst->buf);\n\nfree_tst:\n\tkfree(tst);\n\nfree_name:\n\tmutex_unlock(&test_fw_mutex);\n\tkfree(name);\n\n\treturn ret;\n}\nstatic DEVICE_ATTR_WO(upload_register);\n\nstatic ssize_t upload_unregister_store(struct device *dev,\n\t\t\t\t       struct device_attribute *attr,\n\t\t\t\t       const char *buf, size_t count)\n{\n\tstruct test_firmware_upload *tst;\n\tint ret = count;\n\n\tmutex_lock(&test_fw_mutex);\n\ttst = upload_lookup_name(buf);\n\tif (!tst) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (test_fw_config->upload_name == tst->name)\n\t\ttest_fw_config->upload_name = NULL;\n\n\tlist_del(&tst->node);\n\tupload_release(tst);\n\nout:\n\tmutex_unlock(&test_fw_mutex);\n\treturn ret;\n}\nstatic DEVICE_ATTR_WO(upload_unregister);\n\nstatic ssize_t test_result_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr,\n\t\t\t\tchar *buf)\n{\n\treturn test_dev_config_show_int(buf, test_fw_config->test_result);\n}\nstatic DEVICE_ATTR_RO(test_result);\n\nstatic ssize_t release_all_firmware_store(struct device *dev,\n\t\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t\t  const char *buf, size_t count)\n{\n\ttest_release_all_firmware();\n\treturn count;\n}\nstatic DEVICE_ATTR_WO(release_all_firmware);\n\nstatic ssize_t read_firmware_show(struct device *dev,\n\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t  char *buf)\n{\n\tstruct test_batched_req *req;\n\tu8 idx;\n\tssize_t rc = 0;\n\n\tmutex_lock(&test_fw_mutex);\n\n\tidx = test_fw_config->read_fw_idx;\n\tif (idx >= test_fw_config->num_requests) {\n\t\trc = -ERANGE;\n\t\tgoto out;\n\t}\n\n\tif (!test_fw_config->reqs) {\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\treq = &test_fw_config->reqs[idx];\n\tif (!req->fw) {\n\t\tpr_err(\"#%u: failed to async load firmware\\n\", idx);\n\t\trc = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tpr_info(\"#%u: loaded %zu\\n\", idx, req->fw->size);\n\n\tif (req->fw->size > PAGE_SIZE) {\n\t\tpr_err(\"Testing interface must use PAGE_SIZE firmware for now\\n\");\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\tmemcpy(buf, req->fw->data, req->fw->size);\n\n\trc = req->fw->size;\nout:\n\tmutex_unlock(&test_fw_mutex);\n\n\treturn rc;\n}\nstatic DEVICE_ATTR_RO(read_firmware);\n\nstatic ssize_t upload_read_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr,\n\t\t\t\tchar *buf)\n{\n\tstruct test_firmware_upload *tst = NULL;\n\tstruct test_firmware_upload *tst_iter;\n\tint ret = -EINVAL;\n\n\tif (!test_fw_config->upload_name) {\n\t\tpr_err(\"Set config_upload_name before using upload_read\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&test_fw_mutex);\n\tlist_for_each_entry(tst_iter, &test_upload_list, node)\n\t\tif (tst_iter->name == test_fw_config->upload_name) {\n\t\t\ttst = tst_iter;\n\t\t\tbreak;\n\t\t}\n\n\tif (!tst) {\n\t\tpr_err(\"Firmware name not found: %s\\n\",\n\t\t       test_fw_config->upload_name);\n\t\tgoto out;\n\t}\n\n\tif (tst->size > PAGE_SIZE) {\n\t\tpr_err(\"Testing interface must use PAGE_SIZE firmware for now\\n\");\n\t\tgoto out;\n\t}\n\n\tmemcpy(buf, tst->buf, tst->size);\n\tret = tst->size;\nout:\n\tmutex_unlock(&test_fw_mutex);\n\treturn ret;\n}\nstatic DEVICE_ATTR_RO(upload_read);\n\n#define TEST_FW_DEV_ATTR(name)          &dev_attr_##name.attr\n\nstatic struct attribute *test_dev_attrs[] = {\n\tTEST_FW_DEV_ATTR(reset),\n\n\tTEST_FW_DEV_ATTR(config),\n\tTEST_FW_DEV_ATTR(config_name),\n\tTEST_FW_DEV_ATTR(config_num_requests),\n\tTEST_FW_DEV_ATTR(config_into_buf),\n\tTEST_FW_DEV_ATTR(config_buf_size),\n\tTEST_FW_DEV_ATTR(config_file_offset),\n\tTEST_FW_DEV_ATTR(config_partial),\n\tTEST_FW_DEV_ATTR(config_sync_direct),\n\tTEST_FW_DEV_ATTR(config_send_uevent),\n\tTEST_FW_DEV_ATTR(config_read_fw_idx),\n\tTEST_FW_DEV_ATTR(config_upload_name),\n\n\t \n\tTEST_FW_DEV_ATTR(trigger_request),\n\tTEST_FW_DEV_ATTR(trigger_async_request),\n\tTEST_FW_DEV_ATTR(trigger_custom_fallback),\n#ifdef CONFIG_EFI_EMBEDDED_FIRMWARE\n\tTEST_FW_DEV_ATTR(trigger_request_platform),\n#endif\n\n\t \n\tTEST_FW_DEV_ATTR(trigger_batched_requests),\n\tTEST_FW_DEV_ATTR(trigger_batched_requests_async),\n\n\tTEST_FW_DEV_ATTR(release_all_firmware),\n\tTEST_FW_DEV_ATTR(test_result),\n\tTEST_FW_DEV_ATTR(read_firmware),\n\tTEST_FW_DEV_ATTR(upload_read),\n\tTEST_FW_DEV_ATTR(upload_register),\n\tTEST_FW_DEV_ATTR(upload_unregister),\n\tNULL,\n};\n\nATTRIBUTE_GROUPS(test_dev);\n\nstatic struct miscdevice test_fw_misc_device = {\n\t.minor          = MISC_DYNAMIC_MINOR,\n\t.name           = \"test_firmware\",\n\t.fops           = &test_fw_fops,\n\t.groups \t= test_dev_groups,\n};\n\nstatic int __init test_firmware_init(void)\n{\n\tint rc;\n\n\ttest_fw_config = kzalloc(sizeof(struct test_config), GFP_KERNEL);\n\tif (!test_fw_config)\n\t\treturn -ENOMEM;\n\n\trc = __test_firmware_config_init();\n\tif (rc) {\n\t\tkfree(test_fw_config);\n\t\tpr_err(\"could not init firmware test config: %d\\n\", rc);\n\t\treturn rc;\n\t}\n\n\trc = misc_register(&test_fw_misc_device);\n\tif (rc) {\n\t\t__test_firmware_config_free();\n\t\tkfree(test_fw_config);\n\t\tpr_err(\"could not register misc device: %d\\n\", rc);\n\t\treturn rc;\n\t}\n\n\tpr_warn(\"interface ready\\n\");\n\n\treturn 0;\n}\n\nmodule_init(test_firmware_init);\n\nstatic void __exit test_firmware_exit(void)\n{\n\tmutex_lock(&test_fw_mutex);\n\trelease_firmware(test_firmware);\n\tmisc_deregister(&test_fw_misc_device);\n\tupload_release_all();\n\t__test_firmware_config_free();\n\tkfree(test_fw_config);\n\tmutex_unlock(&test_fw_mutex);\n\n\tpr_warn(\"removed interface\\n\");\n}\n\nmodule_exit(test_firmware_exit);\n\nMODULE_AUTHOR(\"Kees Cook <keescook@chromium.org>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}