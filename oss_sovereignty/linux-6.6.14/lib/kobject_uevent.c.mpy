{
  "module_name": "kobject_uevent.c",
  "hash_id": "6c016aa317b3a49209f2622ea77af66798a8c74befb6d6828897f30ded6fc6e9",
  "original_prompt": "Ingested from linux-6.6.14/lib/kobject_uevent.c",
  "human_readable_source": "\n \n\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/kobject.h>\n#include <linux/export.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/socket.h>\n#include <linux/skbuff.h>\n#include <linux/netlink.h>\n#include <linux/uidgid.h>\n#include <linux/uuid.h>\n#include <linux/ctype.h>\n#include <net/sock.h>\n#include <net/netlink.h>\n#include <net/net_namespace.h>\n\n\nu64 uevent_seqnum;\n#ifdef CONFIG_UEVENT_HELPER\nchar uevent_helper[UEVENT_HELPER_PATH_LEN] = CONFIG_UEVENT_HELPER_PATH;\n#endif\n\nstruct uevent_sock {\n\tstruct list_head list;\n\tstruct sock *sk;\n};\n\n#ifdef CONFIG_NET\nstatic LIST_HEAD(uevent_sock_list);\n#endif\n\n \nstatic DEFINE_MUTEX(uevent_sock_mutex);\n\n \nstatic const char *kobject_actions[] = {\n\t[KOBJ_ADD] =\t\t\"add\",\n\t[KOBJ_REMOVE] =\t\t\"remove\",\n\t[KOBJ_CHANGE] =\t\t\"change\",\n\t[KOBJ_MOVE] =\t\t\"move\",\n\t[KOBJ_ONLINE] =\t\t\"online\",\n\t[KOBJ_OFFLINE] =\t\"offline\",\n\t[KOBJ_BIND] =\t\t\"bind\",\n\t[KOBJ_UNBIND] =\t\t\"unbind\",\n};\n\nstatic int kobject_action_type(const char *buf, size_t count,\n\t\t\t       enum kobject_action *type,\n\t\t\t       const char **args)\n{\n\tenum kobject_action action;\n\tsize_t count_first;\n\tconst char *args_start;\n\tint ret = -EINVAL;\n\n\tif (count && (buf[count-1] == '\\n' || buf[count-1] == '\\0'))\n\t\tcount--;\n\n\tif (!count)\n\t\tgoto out;\n\n\targs_start = strnchr(buf, count, ' ');\n\tif (args_start) {\n\t\tcount_first = args_start - buf;\n\t\targs_start = args_start + 1;\n\t} else\n\t\tcount_first = count;\n\n\tfor (action = 0; action < ARRAY_SIZE(kobject_actions); action++) {\n\t\tif (strncmp(kobject_actions[action], buf, count_first) != 0)\n\t\t\tcontinue;\n\t\tif (kobject_actions[action][count_first] != '\\0')\n\t\t\tcontinue;\n\t\tif (args)\n\t\t\t*args = args_start;\n\t\t*type = action;\n\t\tret = 0;\n\t\tbreak;\n\t}\nout:\n\treturn ret;\n}\n\nstatic const char *action_arg_word_end(const char *buf, const char *buf_end,\n\t\t\t\t       char delim)\n{\n\tconst char *next = buf;\n\n\twhile (next <= buf_end && *next != delim)\n\t\tif (!isalnum(*next++))\n\t\t\treturn NULL;\n\n\tif (next == buf)\n\t\treturn NULL;\n\n\treturn next;\n}\n\nstatic int kobject_action_args(const char *buf, size_t count,\n\t\t\t       struct kobj_uevent_env **ret_env)\n{\n\tstruct kobj_uevent_env *env = NULL;\n\tconst char *next, *buf_end, *key;\n\tint key_len;\n\tint r = -EINVAL;\n\n\tif (count && (buf[count - 1] == '\\n' || buf[count - 1] == '\\0'))\n\t\tcount--;\n\n\tif (!count)\n\t\treturn -EINVAL;\n\n\tenv = kzalloc(sizeof(*env), GFP_KERNEL);\n\tif (!env)\n\t\treturn -ENOMEM;\n\n\t \n\tif (count < UUID_STRING_LEN || !uuid_is_valid(buf) ||\n\t    add_uevent_var(env, \"SYNTH_UUID=%.*s\", UUID_STRING_LEN, buf))\n\t\tgoto out;\n\n\t \n\tnext = buf + UUID_STRING_LEN;\n\tbuf_end = buf + count - 1;\n\n\twhile (next <= buf_end) {\n\t\tif (*next != ' ')\n\t\t\tgoto out;\n\n\t\t \n\t\tkey = ++next;\n\t\tif (key > buf_end)\n\t\t\tgoto out;\n\n\t\tbuf = next;\n\t\tnext = action_arg_word_end(buf, buf_end, '=');\n\t\tif (!next || next > buf_end || *next != '=')\n\t\t\tgoto out;\n\t\tkey_len = next - buf;\n\n\t\t \n\t\tif (++next > buf_end)\n\t\t\tgoto out;\n\n\t\tbuf = next;\n\t\tnext = action_arg_word_end(buf, buf_end, ' ');\n\t\tif (!next)\n\t\t\tgoto out;\n\n\t\tif (add_uevent_var(env, \"SYNTH_ARG_%.*s=%.*s\",\n\t\t\t\t   key_len, key, (int) (next - buf), buf))\n\t\t\tgoto out;\n\t}\n\n\tr = 0;\nout:\n\tif (r)\n\t\tkfree(env);\n\telse\n\t\t*ret_env = env;\n\treturn r;\n}\n\n \nint kobject_synth_uevent(struct kobject *kobj, const char *buf, size_t count)\n{\n\tchar *no_uuid_envp[] = { \"SYNTH_UUID=0\", NULL };\n\tenum kobject_action action;\n\tconst char *action_args;\n\tstruct kobj_uevent_env *env;\n\tconst char *msg = NULL, *devpath;\n\tint r;\n\n\tr = kobject_action_type(buf, count, &action, &action_args);\n\tif (r) {\n\t\tmsg = \"unknown uevent action string\";\n\t\tgoto out;\n\t}\n\n\tif (!action_args) {\n\t\tr = kobject_uevent_env(kobj, action, no_uuid_envp);\n\t\tgoto out;\n\t}\n\n\tr = kobject_action_args(action_args,\n\t\t\t\tcount - (action_args - buf), &env);\n\tif (r == -EINVAL) {\n\t\tmsg = \"incorrect uevent action arguments\";\n\t\tgoto out;\n\t}\n\n\tif (r)\n\t\tgoto out;\n\n\tr = kobject_uevent_env(kobj, action, env->envp);\n\tkfree(env);\nout:\n\tif (r) {\n\t\tdevpath = kobject_get_path(kobj, GFP_KERNEL);\n\t\tpr_warn(\"synth uevent: %s: %s\\n\",\n\t\t       devpath ?: \"unknown device\",\n\t\t       msg ?: \"failed to send uevent\");\n\t\tkfree(devpath);\n\t}\n\treturn r;\n}\n\n#ifdef CONFIG_UEVENT_HELPER\nstatic int kobj_usermode_filter(struct kobject *kobj)\n{\n\tconst struct kobj_ns_type_operations *ops;\n\n\tops = kobj_ns_ops(kobj);\n\tif (ops) {\n\t\tconst void *init_ns, *ns;\n\n\t\tns = kobj->ktype->namespace(kobj);\n\t\tinit_ns = ops->initial_ns();\n\t\treturn ns != init_ns;\n\t}\n\n\treturn 0;\n}\n\nstatic int init_uevent_argv(struct kobj_uevent_env *env, const char *subsystem)\n{\n\tint buffer_size = sizeof(env->buf) - env->buflen;\n\tint len;\n\n\tlen = strlcpy(&env->buf[env->buflen], subsystem, buffer_size);\n\tif (len >= buffer_size) {\n\t\tpr_warn(\"init_uevent_argv: buffer size of %d too small, needed %d\\n\",\n\t\t\tbuffer_size, len);\n\t\treturn -ENOMEM;\n\t}\n\n\tenv->argv[0] = uevent_helper;\n\tenv->argv[1] = &env->buf[env->buflen];\n\tenv->argv[2] = NULL;\n\n\tenv->buflen += len + 1;\n\treturn 0;\n}\n\nstatic void cleanup_uevent_env(struct subprocess_info *info)\n{\n\tkfree(info->data);\n}\n#endif\n\n#ifdef CONFIG_NET\nstatic struct sk_buff *alloc_uevent_skb(struct kobj_uevent_env *env,\n\t\t\t\t\tconst char *action_string,\n\t\t\t\t\tconst char *devpath)\n{\n\tstruct netlink_skb_parms *parms;\n\tstruct sk_buff *skb = NULL;\n\tchar *scratch;\n\tsize_t len;\n\n\t \n\tlen = strlen(action_string) + strlen(devpath) + 2;\n\tskb = alloc_skb(len + env->buflen, GFP_KERNEL);\n\tif (!skb)\n\t\treturn NULL;\n\n\t \n\tscratch = skb_put(skb, len);\n\tsprintf(scratch, \"%s@%s\", action_string, devpath);\n\n\tskb_put_data(skb, env->buf, env->buflen);\n\n\tparms = &NETLINK_CB(skb);\n\tparms->creds.uid = GLOBAL_ROOT_UID;\n\tparms->creds.gid = GLOBAL_ROOT_GID;\n\tparms->dst_group = 1;\n\tparms->portid = 0;\n\n\treturn skb;\n}\n\nstatic int uevent_net_broadcast_untagged(struct kobj_uevent_env *env,\n\t\t\t\t\t const char *action_string,\n\t\t\t\t\t const char *devpath)\n{\n\tstruct sk_buff *skb = NULL;\n\tstruct uevent_sock *ue_sk;\n\tint retval = 0;\n\n\t \n\tlist_for_each_entry(ue_sk, &uevent_sock_list, list) {\n\t\tstruct sock *uevent_sock = ue_sk->sk;\n\n\t\tif (!netlink_has_listeners(uevent_sock, 1))\n\t\t\tcontinue;\n\n\t\tif (!skb) {\n\t\t\tretval = -ENOMEM;\n\t\t\tskb = alloc_uevent_skb(env, action_string, devpath);\n\t\t\tif (!skb)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tretval = netlink_broadcast(uevent_sock, skb_get(skb), 0, 1,\n\t\t\t\t\t   GFP_KERNEL);\n\t\t \n\t\tif (retval == -ENOBUFS || retval == -ESRCH)\n\t\t\tretval = 0;\n\t}\n\tconsume_skb(skb);\n\n\treturn retval;\n}\n\nstatic int uevent_net_broadcast_tagged(struct sock *usk,\n\t\t\t\t       struct kobj_uevent_env *env,\n\t\t\t\t       const char *action_string,\n\t\t\t\t       const char *devpath)\n{\n\tstruct user_namespace *owning_user_ns = sock_net(usk)->user_ns;\n\tstruct sk_buff *skb = NULL;\n\tint ret = 0;\n\n\tskb = alloc_uevent_skb(env, action_string, devpath);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\t \n\tif (owning_user_ns != &init_user_ns) {\n\t\tstruct netlink_skb_parms *parms = &NETLINK_CB(skb);\n\t\tkuid_t root_uid;\n\t\tkgid_t root_gid;\n\n\t\t \n\t\troot_uid = make_kuid(owning_user_ns, 0);\n\t\tif (uid_valid(root_uid))\n\t\t\tparms->creds.uid = root_uid;\n\n\t\t \n\t\troot_gid = make_kgid(owning_user_ns, 0);\n\t\tif (gid_valid(root_gid))\n\t\t\tparms->creds.gid = root_gid;\n\t}\n\n\tret = netlink_broadcast(usk, skb, 0, 1, GFP_KERNEL);\n\t \n\tif (ret == -ENOBUFS || ret == -ESRCH)\n\t\tret = 0;\n\n\treturn ret;\n}\n#endif\n\nstatic int kobject_uevent_net_broadcast(struct kobject *kobj,\n\t\t\t\t\tstruct kobj_uevent_env *env,\n\t\t\t\t\tconst char *action_string,\n\t\t\t\t\tconst char *devpath)\n{\n\tint ret = 0;\n\n#ifdef CONFIG_NET\n\tconst struct kobj_ns_type_operations *ops;\n\tconst struct net *net = NULL;\n\n\tops = kobj_ns_ops(kobj);\n\tif (!ops && kobj->kset) {\n\t\tstruct kobject *ksobj = &kobj->kset->kobj;\n\n\t\tif (ksobj->parent != NULL)\n\t\t\tops = kobj_ns_ops(ksobj->parent);\n\t}\n\n\t \n\tif (ops && ops->netlink_ns && kobj->ktype->namespace)\n\t\tif (ops->type == KOBJ_NS_TYPE_NET)\n\t\t\tnet = kobj->ktype->namespace(kobj);\n\n\tif (!net)\n\t\tret = uevent_net_broadcast_untagged(env, action_string,\n\t\t\t\t\t\t    devpath);\n\telse\n\t\tret = uevent_net_broadcast_tagged(net->uevent_sock->sk, env,\n\t\t\t\t\t\t  action_string, devpath);\n#endif\n\n\treturn ret;\n}\n\nstatic void zap_modalias_env(struct kobj_uevent_env *env)\n{\n\tstatic const char modalias_prefix[] = \"MODALIAS=\";\n\tsize_t len;\n\tint i, j;\n\n\tfor (i = 0; i < env->envp_idx;) {\n\t\tif (strncmp(env->envp[i], modalias_prefix,\n\t\t\t    sizeof(modalias_prefix) - 1)) {\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tlen = strlen(env->envp[i]) + 1;\n\n\t\tif (i != env->envp_idx - 1) {\n\t\t\tmemmove(env->envp[i], env->envp[i + 1],\n\t\t\t\tenv->buflen - len);\n\n\t\t\tfor (j = i; j < env->envp_idx - 1; j++)\n\t\t\t\tenv->envp[j] = env->envp[j + 1] - len;\n\t\t}\n\n\t\tenv->envp_idx--;\n\t\tenv->buflen -= len;\n\t}\n}\n\n \nint kobject_uevent_env(struct kobject *kobj, enum kobject_action action,\n\t\t       char *envp_ext[])\n{\n\tstruct kobj_uevent_env *env;\n\tconst char *action_string = kobject_actions[action];\n\tconst char *devpath = NULL;\n\tconst char *subsystem;\n\tstruct kobject *top_kobj;\n\tstruct kset *kset;\n\tconst struct kset_uevent_ops *uevent_ops;\n\tint i = 0;\n\tint retval = 0;\n\n\t \n\tif (action == KOBJ_REMOVE)\n\t\tkobj->state_remove_uevent_sent = 1;\n\n\tpr_debug(\"kobject: '%s' (%p): %s\\n\",\n\t\t kobject_name(kobj), kobj, __func__);\n\n\t \n\ttop_kobj = kobj;\n\twhile (!top_kobj->kset && top_kobj->parent)\n\t\ttop_kobj = top_kobj->parent;\n\n\tif (!top_kobj->kset) {\n\t\tpr_debug(\"kobject: '%s' (%p): %s: attempted to send uevent \"\n\t\t\t \"without kset!\\n\", kobject_name(kobj), kobj,\n\t\t\t __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tkset = top_kobj->kset;\n\tuevent_ops = kset->uevent_ops;\n\n\t \n\tif (kobj->uevent_suppress) {\n\t\tpr_debug(\"kobject: '%s' (%p): %s: uevent_suppress \"\n\t\t\t\t \"caused the event to drop!\\n\",\n\t\t\t\t kobject_name(kobj), kobj, __func__);\n\t\treturn 0;\n\t}\n\t \n\tif (uevent_ops && uevent_ops->filter)\n\t\tif (!uevent_ops->filter(kobj)) {\n\t\t\tpr_debug(\"kobject: '%s' (%p): %s: filter function \"\n\t\t\t\t \"caused the event to drop!\\n\",\n\t\t\t\t kobject_name(kobj), kobj, __func__);\n\t\t\treturn 0;\n\t\t}\n\n\t \n\tif (uevent_ops && uevent_ops->name)\n\t\tsubsystem = uevent_ops->name(kobj);\n\telse\n\t\tsubsystem = kobject_name(&kset->kobj);\n\tif (!subsystem) {\n\t\tpr_debug(\"kobject: '%s' (%p): %s: unset subsystem caused the \"\n\t\t\t \"event to drop!\\n\", kobject_name(kobj), kobj,\n\t\t\t __func__);\n\t\treturn 0;\n\t}\n\n\t \n\tenv = kzalloc(sizeof(struct kobj_uevent_env), GFP_KERNEL);\n\tif (!env)\n\t\treturn -ENOMEM;\n\n\t \n\tdevpath = kobject_get_path(kobj, GFP_KERNEL);\n\tif (!devpath) {\n\t\tretval = -ENOENT;\n\t\tgoto exit;\n\t}\n\n\t \n\tretval = add_uevent_var(env, \"ACTION=%s\", action_string);\n\tif (retval)\n\t\tgoto exit;\n\tretval = add_uevent_var(env, \"DEVPATH=%s\", devpath);\n\tif (retval)\n\t\tgoto exit;\n\tretval = add_uevent_var(env, \"SUBSYSTEM=%s\", subsystem);\n\tif (retval)\n\t\tgoto exit;\n\n\t \n\tif (envp_ext) {\n\t\tfor (i = 0; envp_ext[i]; i++) {\n\t\t\tretval = add_uevent_var(env, \"%s\", envp_ext[i]);\n\t\t\tif (retval)\n\t\t\t\tgoto exit;\n\t\t}\n\t}\n\n\t \n\tif (uevent_ops && uevent_ops->uevent) {\n\t\tretval = uevent_ops->uevent(kobj, env);\n\t\tif (retval) {\n\t\t\tpr_debug(\"kobject: '%s' (%p): %s: uevent() returned \"\n\t\t\t\t \"%d\\n\", kobject_name(kobj), kobj,\n\t\t\t\t __func__, retval);\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\tswitch (action) {\n\tcase KOBJ_ADD:\n\t\t \n\t\tkobj->state_add_uevent_sent = 1;\n\t\tbreak;\n\n\tcase KOBJ_UNBIND:\n\t\tzap_modalias_env(env);\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\tmutex_lock(&uevent_sock_mutex);\n\t \n\tretval = add_uevent_var(env, \"SEQNUM=%llu\", ++uevent_seqnum);\n\tif (retval) {\n\t\tmutex_unlock(&uevent_sock_mutex);\n\t\tgoto exit;\n\t}\n\tretval = kobject_uevent_net_broadcast(kobj, env, action_string,\n\t\t\t\t\t      devpath);\n\tmutex_unlock(&uevent_sock_mutex);\n\n#ifdef CONFIG_UEVENT_HELPER\n\t \n\tif (uevent_helper[0] && !kobj_usermode_filter(kobj)) {\n\t\tstruct subprocess_info *info;\n\n\t\tretval = add_uevent_var(env, \"HOME=/\");\n\t\tif (retval)\n\t\t\tgoto exit;\n\t\tretval = add_uevent_var(env,\n\t\t\t\t\t\"PATH=/sbin:/bin:/usr/sbin:/usr/bin\");\n\t\tif (retval)\n\t\t\tgoto exit;\n\t\tretval = init_uevent_argv(env, subsystem);\n\t\tif (retval)\n\t\t\tgoto exit;\n\n\t\tretval = -ENOMEM;\n\t\tinfo = call_usermodehelper_setup(env->argv[0], env->argv,\n\t\t\t\t\t\t env->envp, GFP_KERNEL,\n\t\t\t\t\t\t NULL, cleanup_uevent_env, env);\n\t\tif (info) {\n\t\t\tretval = call_usermodehelper_exec(info, UMH_NO_WAIT);\n\t\t\tenv = NULL;\t \n\t\t}\n\t}\n#endif\n\nexit:\n\tkfree(devpath);\n\tkfree(env);\n\treturn retval;\n}\nEXPORT_SYMBOL_GPL(kobject_uevent_env);\n\n \nint kobject_uevent(struct kobject *kobj, enum kobject_action action)\n{\n\treturn kobject_uevent_env(kobj, action, NULL);\n}\nEXPORT_SYMBOL_GPL(kobject_uevent);\n\n \nint add_uevent_var(struct kobj_uevent_env *env, const char *format, ...)\n{\n\tva_list args;\n\tint len;\n\n\tif (env->envp_idx >= ARRAY_SIZE(env->envp)) {\n\t\tWARN(1, KERN_ERR \"add_uevent_var: too many keys\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tva_start(args, format);\n\tlen = vsnprintf(&env->buf[env->buflen],\n\t\t\tsizeof(env->buf) - env->buflen,\n\t\t\tformat, args);\n\tva_end(args);\n\n\tif (len >= (sizeof(env->buf) - env->buflen)) {\n\t\tWARN(1, KERN_ERR \"add_uevent_var: buffer size too small\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tenv->envp[env->envp_idx++] = &env->buf[env->buflen];\n\tenv->buflen += len + 1;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(add_uevent_var);\n\n#if defined(CONFIG_NET)\nstatic int uevent_net_broadcast(struct sock *usk, struct sk_buff *skb,\n\t\t\t\tstruct netlink_ext_ack *extack)\n{\n\t \n\tchar buf[sizeof(\"SEQNUM=\") + 21];\n\tstruct sk_buff *skbc;\n\tint ret;\n\n\t \n\tret = snprintf(buf, sizeof(buf), \"SEQNUM=%llu\", ++uevent_seqnum);\n\tif (ret < 0 || (size_t)ret >= sizeof(buf))\n\t\treturn -ENOMEM;\n\tret++;\n\n\t \n\tif ((skb->len + ret) > UEVENT_BUFFER_SIZE) {\n\t\tNL_SET_ERR_MSG(extack, \"uevent message too big\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tskbc = skb_copy_expand(skb, 0, ret, GFP_KERNEL);\n\tif (!skbc)\n\t\treturn -ENOMEM;\n\n\t \n\tskb_put_data(skbc, buf, ret);\n\n\t \n\tskb_pull(skbc, NLMSG_HDRLEN);\n\n\t \n\tNETLINK_CB(skbc).portid = 0;\n\tNETLINK_CB(skbc).dst_group = 1;\n\n\tret = netlink_broadcast(usk, skbc, 0, 1, GFP_KERNEL);\n\t \n\tif (ret == -ENOBUFS || ret == -ESRCH)\n\t\tret = 0;\n\n\treturn ret;\n}\n\nstatic int uevent_net_rcv_skb(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\t\t      struct netlink_ext_ack *extack)\n{\n\tstruct net *net;\n\tint ret;\n\n\tif (!nlmsg_data(nlh))\n\t\treturn -EINVAL;\n\n\t \n\tnet = sock_net(NETLINK_CB(skb).sk);\n\tif (!netlink_ns_capable(skb, net->user_ns, CAP_SYS_ADMIN)) {\n\t\tNL_SET_ERR_MSG(extack, \"missing CAP_SYS_ADMIN capability\");\n\t\treturn -EPERM;\n\t}\n\n\tmutex_lock(&uevent_sock_mutex);\n\tret = uevent_net_broadcast(net->uevent_sock->sk, skb, extack);\n\tmutex_unlock(&uevent_sock_mutex);\n\n\treturn ret;\n}\n\nstatic void uevent_net_rcv(struct sk_buff *skb)\n{\n\tnetlink_rcv_skb(skb, &uevent_net_rcv_skb);\n}\n\nstatic int uevent_net_init(struct net *net)\n{\n\tstruct uevent_sock *ue_sk;\n\tstruct netlink_kernel_cfg cfg = {\n\t\t.groups\t= 1,\n\t\t.input = uevent_net_rcv,\n\t\t.flags\t= NL_CFG_F_NONROOT_RECV\n\t};\n\n\tue_sk = kzalloc(sizeof(*ue_sk), GFP_KERNEL);\n\tif (!ue_sk)\n\t\treturn -ENOMEM;\n\n\tue_sk->sk = netlink_kernel_create(net, NETLINK_KOBJECT_UEVENT, &cfg);\n\tif (!ue_sk->sk) {\n\t\tpr_err(\"kobject_uevent: unable to create netlink socket!\\n\");\n\t\tkfree(ue_sk);\n\t\treturn -ENODEV;\n\t}\n\n\tnet->uevent_sock = ue_sk;\n\n\t \n\tif (sock_net(ue_sk->sk)->user_ns == &init_user_ns) {\n\t\tmutex_lock(&uevent_sock_mutex);\n\t\tlist_add_tail(&ue_sk->list, &uevent_sock_list);\n\t\tmutex_unlock(&uevent_sock_mutex);\n\t}\n\n\treturn 0;\n}\n\nstatic void uevent_net_exit(struct net *net)\n{\n\tstruct uevent_sock *ue_sk = net->uevent_sock;\n\n\tif (sock_net(ue_sk->sk)->user_ns == &init_user_ns) {\n\t\tmutex_lock(&uevent_sock_mutex);\n\t\tlist_del(&ue_sk->list);\n\t\tmutex_unlock(&uevent_sock_mutex);\n\t}\n\n\tnetlink_kernel_release(ue_sk->sk);\n\tkfree(ue_sk);\n}\n\nstatic struct pernet_operations uevent_net_ops = {\n\t.init\t= uevent_net_init,\n\t.exit\t= uevent_net_exit,\n};\n\nstatic int __init kobject_uevent_init(void)\n{\n\treturn register_pernet_subsys(&uevent_net_ops);\n}\n\n\npostcore_initcall(kobject_uevent_init);\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}