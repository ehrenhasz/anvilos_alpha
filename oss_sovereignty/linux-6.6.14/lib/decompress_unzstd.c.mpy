{
  "module_name": "decompress_unzstd.c",
  "hash_id": "9d2b4e987bf4845a0957d8cd255c54bf2baf97371a4b5b20fda49606b879970e",
  "original_prompt": "Ingested from linux-6.6.14/lib/decompress_unzstd.c",
  "human_readable_source": "\n\n \n\n \n#ifdef STATIC\n# define UNZSTD_PREBOOT\n# include \"xxhash.c\"\n# include \"zstd/decompress_sources.h\"\n#else\n#include <linux/decompress/unzstd.h>\n#endif\n\n#include <linux/decompress/mm.h>\n#include <linux/kernel.h>\n#include <linux/zstd.h>\n\n \n#define ZSTD_WINDOWSIZE_MAX\t(1 << ZSTD_WINDOWLOG_MAX)\n \n#define ZSTD_IOBUF_SIZE\t\t(1 << 17)\n\nstatic int INIT handle_zstd_error(size_t ret, void (*error)(char *x))\n{\n\tconst zstd_error_code err = zstd_get_error_code(ret);\n\n\tif (!zstd_is_error(ret))\n\t\treturn 0;\n\n\t \n\tswitch (err) {\n\tcase ZSTD_error_memory_allocation:\n\t\terror(\"ZSTD decompressor ran out of memory\");\n\t\tbreak;\n\tcase ZSTD_error_prefix_unknown:\n\t\terror(\"Input is not in the ZSTD format (wrong magic bytes)\");\n\t\tbreak;\n\tcase ZSTD_error_dstSize_tooSmall:\n\tcase ZSTD_error_corruption_detected:\n\tcase ZSTD_error_checksum_wrong:\n\t\terror(\"ZSTD-compressed data is corrupt\");\n\t\tbreak;\n\tdefault:\n\t\terror(\"ZSTD-compressed data is probably corrupt\");\n\t\tbreak;\n\t}\n\treturn -1;\n}\n\n \nstatic int INIT decompress_single(const u8 *in_buf, long in_len, u8 *out_buf,\n\t\t\t\t  long out_len, long *in_pos,\n\t\t\t\t  void (*error)(char *x))\n{\n\tconst size_t wksp_size = zstd_dctx_workspace_bound();\n\tvoid *wksp = large_malloc(wksp_size);\n\tzstd_dctx *dctx = zstd_init_dctx(wksp, wksp_size);\n\tint err;\n\tsize_t ret;\n\n\tif (dctx == NULL) {\n\t\terror(\"Out of memory while allocating zstd_dctx\");\n\t\terr = -1;\n\t\tgoto out;\n\t}\n\t \n\tret = zstd_find_frame_compressed_size(in_buf, in_len);\n\terr = handle_zstd_error(ret, error);\n\tif (err)\n\t\tgoto out;\n\tin_len = (long)ret;\n\n\tret = zstd_decompress_dctx(dctx, out_buf, out_len, in_buf, in_len);\n\terr = handle_zstd_error(ret, error);\n\tif (err)\n\t\tgoto out;\n\n\tif (in_pos != NULL)\n\t\t*in_pos = in_len;\n\n\terr = 0;\nout:\n\tif (wksp != NULL)\n\t\tlarge_free(wksp);\n\treturn err;\n}\n\nstatic int INIT __unzstd(unsigned char *in_buf, long in_len,\n\t\t\t long (*fill)(void*, unsigned long),\n\t\t\t long (*flush)(void*, unsigned long),\n\t\t\t unsigned char *out_buf, long out_len,\n\t\t\t long *in_pos,\n\t\t\t void (*error)(char *x))\n{\n\tzstd_in_buffer in;\n\tzstd_out_buffer out;\n\tzstd_frame_header header;\n\tvoid *in_allocated = NULL;\n\tvoid *out_allocated = NULL;\n\tvoid *wksp = NULL;\n\tsize_t wksp_size;\n\tzstd_dstream *dstream;\n\tint err;\n\tsize_t ret;\n\n\t \n\tif (out_len == 0)\n\t\tout_len = UINTPTR_MAX - (uintptr_t)out_buf;\n\n\tif (fill == NULL && flush == NULL)\n\t\t \n\t\treturn decompress_single(in_buf, in_len, out_buf, out_len,\n\t\t\t\t\t in_pos, error);\n\n\t \n\tif (in_buf == NULL) {\n\t\tin_allocated = large_malloc(ZSTD_IOBUF_SIZE);\n\t\tif (in_allocated == NULL) {\n\t\t\terror(\"Out of memory while allocating input buffer\");\n\t\t\terr = -1;\n\t\t\tgoto out;\n\t\t}\n\t\tin_buf = in_allocated;\n\t\tin_len = 0;\n\t}\n\t \n\tif (fill != NULL)\n\t\tin_len = fill(in_buf, ZSTD_IOBUF_SIZE);\n\tif (in_len < 0) {\n\t\terror(\"ZSTD-compressed data is truncated\");\n\t\terr = -1;\n\t\tgoto out;\n\t}\n\t \n\tin.src = in_buf;\n\tin.pos = 0;\n\tin.size = in_len;\n\t \n\tif (flush != NULL) {\n\t\tout_allocated = large_malloc(ZSTD_IOBUF_SIZE);\n\t\tif (out_allocated == NULL) {\n\t\t\terror(\"Out of memory while allocating output buffer\");\n\t\t\terr = -1;\n\t\t\tgoto out;\n\t\t}\n\t\tout_buf = out_allocated;\n\t\tout_len = ZSTD_IOBUF_SIZE;\n\t}\n\t \n\tout.dst = out_buf;\n\tout.pos = 0;\n\tout.size = out_len;\n\n\t \n\tret = zstd_get_frame_header(&header, in.src, in.size);\n\terr = handle_zstd_error(ret, error);\n\tif (err)\n\t\tgoto out;\n\tif (ret != 0) {\n\t\terror(\"ZSTD-compressed data has an incomplete frame header\");\n\t\terr = -1;\n\t\tgoto out;\n\t}\n\tif (header.windowSize > ZSTD_WINDOWSIZE_MAX) {\n\t\terror(\"ZSTD-compressed data has too large a window size\");\n\t\terr = -1;\n\t\tgoto out;\n\t}\n\n\t \n\twksp_size = zstd_dstream_workspace_bound(header.windowSize);\n\twksp = large_malloc(wksp_size);\n\tdstream = zstd_init_dstream(header.windowSize, wksp, wksp_size);\n\tif (dstream == NULL) {\n\t\terror(\"Out of memory while allocating ZSTD_DStream\");\n\t\terr = -1;\n\t\tgoto out;\n\t}\n\n\t \n\tif (in_pos != NULL)\n\t\t*in_pos = 0;\n\tdo {\n\t\t \n\t\tif (in.pos == in.size) {\n\t\t\tif (in_pos != NULL)\n\t\t\t\t*in_pos += in.pos;\n\t\t\tin_len = fill ? fill(in_buf, ZSTD_IOBUF_SIZE) : -1;\n\t\t\tif (in_len < 0) {\n\t\t\t\terror(\"ZSTD-compressed data is truncated\");\n\t\t\t\terr = -1;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tin.pos = 0;\n\t\t\tin.size = in_len;\n\t\t}\n\t\t \n\t\tret = zstd_decompress_stream(dstream, &out, &in);\n\t\terr = handle_zstd_error(ret, error);\n\t\tif (err)\n\t\t\tgoto out;\n\t\t \n\t\tif (flush != NULL && out.pos > 0) {\n\t\t\tif (out.pos != flush(out.dst, out.pos)) {\n\t\t\t\terror(\"Failed to flush()\");\n\t\t\t\terr = -1;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tout.pos = 0;\n\t\t}\n\t} while (ret != 0);\n\n\tif (in_pos != NULL)\n\t\t*in_pos += in.pos;\n\n\terr = 0;\nout:\n\tif (in_allocated != NULL)\n\t\tlarge_free(in_allocated);\n\tif (out_allocated != NULL)\n\t\tlarge_free(out_allocated);\n\tif (wksp != NULL)\n\t\tlarge_free(wksp);\n\treturn err;\n}\n\n#ifndef UNZSTD_PREBOOT\nSTATIC int INIT unzstd(unsigned char *buf, long len,\n\t\t       long (*fill)(void*, unsigned long),\n\t\t       long (*flush)(void*, unsigned long),\n\t\t       unsigned char *out_buf,\n\t\t       long *pos,\n\t\t       void (*error)(char *x))\n{\n\treturn __unzstd(buf, len, fill, flush, out_buf, 0, pos, error);\n}\n#else\nSTATIC int INIT __decompress(unsigned char *buf, long len,\n\t\t\t     long (*fill)(void*, unsigned long),\n\t\t\t     long (*flush)(void*, unsigned long),\n\t\t\t     unsigned char *out_buf, long out_len,\n\t\t\t     long *pos,\n\t\t\t     void (*error)(char *x))\n{\n\treturn __unzstd(buf, len, fill, flush, out_buf, out_len, pos, error);\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}