{
  "module_name": "asn1_encoder.c",
  "hash_id": "ad3ab8a349c78a623ef18224d5d7d1b243ee537bab2c071ee35e15e004e87a06",
  "original_prompt": "Ingested from linux-6.6.14/lib/asn1_encoder.c",
  "human_readable_source": "\n \n\n#include <linux/asn1_encoder.h>\n#include <linux/bug.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\n \nunsigned char *\nasn1_encode_integer(unsigned char *data, const unsigned char *end_data,\n\t\t    s64 integer)\n{\n\tint data_len = end_data - data;\n\tunsigned char *d = &data[2];\n\tbool found = false;\n\tint i;\n\n\tif (WARN(integer < 0,\n\t\t \"BUG: integer encode only supports positive integers\"))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (IS_ERR(data))\n\t\treturn data;\n\n\t \n\tif (data_len < 3)\n\t\treturn ERR_PTR(-EINVAL);\n\n\t \n\tdata_len -= 2;\n\n\tdata[0] = _tag(UNIV, PRIM, INT);\n\tif (integer == 0) {\n\t\t*d++ = 0;\n\t\tgoto out;\n\t}\n\n\tfor (i = sizeof(integer); i > 0 ; i--) {\n\t\tint byte = integer >> (8 * (i - 1));\n\n\t\tif (!found && byte == 0)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (!found && (byte & 0x80)) {\n\t\t\t \n\t\t\t*d++ = 0;\n\t\t\tdata_len--;\n\t\t}\n\n\t\tfound = true;\n\t\tif (data_len == 0)\n\t\t\treturn ERR_PTR(-EINVAL);\n\n\t\t*d++ = byte;\n\t\tdata_len--;\n\t}\n\n out:\n\tdata[1] = d - data - 2;\n\n\treturn d;\n}\nEXPORT_SYMBOL_GPL(asn1_encode_integer);\n\n \nstatic int asn1_encode_oid_digit(unsigned char **_data, int *data_len, u32 oid)\n{\n\tunsigned char *data = *_data;\n\tint start = 7 + 7 + 7 + 7;\n\tint ret = 0;\n\n\tif (*data_len < 1)\n\t\treturn -EINVAL;\n\n\t \n\tif (oid == 0) {\n\t\t*data++ = 0x80;\n\t\t(*data_len)--;\n\t\tgoto out;\n\t}\n\n\twhile (oid >> start == 0)\n\t\tstart -= 7;\n\n\twhile (start > 0 && *data_len > 0) {\n\t\tu8 byte;\n\n\t\tbyte = oid >> start;\n\t\toid = oid - (byte << start);\n\t\tstart -= 7;\n\t\tbyte |= 0x80;\n\t\t*data++ = byte;\n\t\t(*data_len)--;\n\t}\n\n\tif (*data_len > 0) {\n\t\t*data++ = oid;\n\t\t(*data_len)--;\n\t} else {\n\t\tret = -EINVAL;\n\t}\n\n out:\n\t*_data = data;\n\treturn ret;\n}\n\n \nunsigned char *\nasn1_encode_oid(unsigned char *data, const unsigned char *end_data,\n\t\tu32 oid[], int oid_len)\n{\n\tint data_len = end_data - data;\n\tunsigned char *d = data + 2;\n\tint i, ret;\n\n\tif (WARN(oid_len < 2, \"OID must have at least two elements\"))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (WARN(oid_len > 32, \"OID is too large\"))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (IS_ERR(data))\n\t\treturn data;\n\n\n\t \n\tif (data_len < 3)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tdata[0] = _tag(UNIV, PRIM, OID);\n\t*d++ = oid[0] * 40 + oid[1];\n\n\tdata_len -= 3;\n\n\tfor (i = 2; i < oid_len; i++) {\n\t\tret = asn1_encode_oid_digit(&d, &data_len, oid[i]);\n\t\tif (ret < 0)\n\t\t\treturn ERR_PTR(ret);\n\t}\n\n\tdata[1] = d - data - 2;\n\n\treturn d;\n}\nEXPORT_SYMBOL_GPL(asn1_encode_oid);\n\n \nstatic int asn1_encode_length(unsigned char **data, int *data_len, int len)\n{\n\tif (*data_len < 1)\n\t\treturn -EINVAL;\n\n\tif (len < 0) {\n\t\t*((*data)++) = 0;\n\t\t(*data_len)--;\n\t\treturn 0;\n\t}\n\n\tif (len <= 0x7f) {\n\t\t*((*data)++) = len;\n\t\t(*data_len)--;\n\t\treturn 0;\n\t}\n\n\tif (*data_len < 2)\n\t\treturn -EINVAL;\n\n\tif (len <= 0xff) {\n\t\t*((*data)++) = 0x81;\n\t\t*((*data)++) = len & 0xff;\n\t\t*data_len -= 2;\n\t\treturn 0;\n\t}\n\n\tif (*data_len < 3)\n\t\treturn -EINVAL;\n\n\tif (len <= 0xffff) {\n\t\t*((*data)++) = 0x82;\n\t\t*((*data)++) = (len >> 8) & 0xff;\n\t\t*((*data)++) = len & 0xff;\n\t\t*data_len -= 3;\n\t\treturn 0;\n\t}\n\n\tif (WARN(len > 0xffffff, \"ASN.1 length can't be > 0xffffff\"))\n\t\treturn -EINVAL;\n\n\tif (*data_len < 4)\n\t\treturn -EINVAL;\n\t*((*data)++) = 0x83;\n\t*((*data)++) = (len >> 16) & 0xff;\n\t*((*data)++) = (len >> 8) & 0xff;\n\t*((*data)++) = len & 0xff;\n\t*data_len -= 4;\n\n\treturn 0;\n}\n\n \nunsigned char *\nasn1_encode_tag(unsigned char *data, const unsigned char *end_data,\n\t\tu32 tag, const unsigned char *string, int len)\n{\n\tint data_len = end_data - data;\n\tint ret;\n\n\tif (WARN(tag > 30, \"ASN.1 tag can't be > 30\"))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (!string && WARN(len > 127,\n\t\t\t    \"BUG: recode tag is too big (>127)\"))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (IS_ERR(data))\n\t\treturn data;\n\n\tif (!string && len > 0) {\n\t\t \n\t\tdata -= 2;\n\t\tdata_len = 2;\n\t}\n\n\tif (data_len < 2)\n\t\treturn ERR_PTR(-EINVAL);\n\n\t*(data++) = _tagn(CONT, CONS, tag);\n\tdata_len--;\n\tret = asn1_encode_length(&data, &data_len, len);\n\tif (ret < 0)\n\t\treturn ERR_PTR(ret);\n\n\tif (!string)\n\t\treturn data;\n\n\tif (data_len < len)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tmemcpy(data, string, len);\n\tdata += len;\n\n\treturn data;\n}\nEXPORT_SYMBOL_GPL(asn1_encode_tag);\n\n \nunsigned char *\nasn1_encode_octet_string(unsigned char *data,\n\t\t\t const unsigned char *end_data,\n\t\t\t const unsigned char *string, u32 len)\n{\n\tint data_len = end_data - data;\n\tint ret;\n\n\tif (IS_ERR(data))\n\t\treturn data;\n\n\t \n\tif (data_len < 2)\n\t\treturn ERR_PTR(-EINVAL);\n\n\t*(data++) = _tag(UNIV, PRIM, OTS);\n\tdata_len--;\n\n\tret = asn1_encode_length(&data, &data_len, len);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tif (data_len < len)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tmemcpy(data, string, len);\n\tdata += len;\n\n\treturn data;\n}\nEXPORT_SYMBOL_GPL(asn1_encode_octet_string);\n\n \nunsigned char *\nasn1_encode_sequence(unsigned char *data, const unsigned char *end_data,\n\t\t     const unsigned char *seq, int len)\n{\n\tint data_len = end_data - data;\n\tint ret;\n\n\tif (!seq && WARN(len > 127,\n\t\t\t \"BUG: recode sequence is too big (>127)\"))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (IS_ERR(data))\n\t\treturn data;\n\n\tif (!seq && len >= 0) {\n\t\t \n\t\tdata -= 2;\n\t\tdata_len = 2;\n\t}\n\n\tif (data_len < 2)\n\t\treturn ERR_PTR(-EINVAL);\n\n\t*(data++) = _tag(UNIV, CONS, SEQ);\n\tdata_len--;\n\n\tret = asn1_encode_length(&data, &data_len, len);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tif (!seq)\n\t\treturn data;\n\n\tif (data_len < len)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tmemcpy(data, seq, len);\n\tdata += len;\n\n\treturn data;\n}\nEXPORT_SYMBOL_GPL(asn1_encode_sequence);\n\n \nunsigned char *\nasn1_encode_boolean(unsigned char *data, const unsigned char *end_data,\n\t\t    bool val)\n{\n\tint data_len = end_data - data;\n\n\tif (IS_ERR(data))\n\t\treturn data;\n\n\t \n\tif (data_len < 3)\n\t\treturn ERR_PTR(-EINVAL);\n\n\t*(data++) = _tag(UNIV, PRIM, BOOL);\n\tdata_len--;\n\n\tasn1_encode_length(&data, &data_len, 1);\n\n\tif (val)\n\t\t*(data++) = 1;\n\telse\n\t\t*(data++) = 0;\n\n\treturn data;\n}\nEXPORT_SYMBOL_GPL(asn1_encode_boolean);\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}