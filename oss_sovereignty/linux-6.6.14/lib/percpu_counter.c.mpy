{
  "module_name": "percpu_counter.c",
  "hash_id": "116eeaf14bc5e12f88ca2e65f0e5087665bc12f8ac2ef4771fb76872778341e5",
  "original_prompt": "Ingested from linux-6.6.14/lib/percpu_counter.c",
  "human_readable_source": "\n \n\n#include <linux/percpu_counter.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/debugobjects.h>\n\n#ifdef CONFIG_HOTPLUG_CPU\nstatic LIST_HEAD(percpu_counters);\nstatic DEFINE_SPINLOCK(percpu_counters_lock);\n#endif\n\n#ifdef CONFIG_DEBUG_OBJECTS_PERCPU_COUNTER\n\nstatic const struct debug_obj_descr percpu_counter_debug_descr;\n\nstatic bool percpu_counter_fixup_free(void *addr, enum debug_obj_state state)\n{\n\tstruct percpu_counter *fbc = addr;\n\n\tswitch (state) {\n\tcase ODEBUG_STATE_ACTIVE:\n\t\tpercpu_counter_destroy(fbc);\n\t\tdebug_object_free(fbc, &percpu_counter_debug_descr);\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic const struct debug_obj_descr percpu_counter_debug_descr = {\n\t.name\t\t= \"percpu_counter\",\n\t.fixup_free\t= percpu_counter_fixup_free,\n};\n\nstatic inline void debug_percpu_counter_activate(struct percpu_counter *fbc)\n{\n\tdebug_object_init(fbc, &percpu_counter_debug_descr);\n\tdebug_object_activate(fbc, &percpu_counter_debug_descr);\n}\n\nstatic inline void debug_percpu_counter_deactivate(struct percpu_counter *fbc)\n{\n\tdebug_object_deactivate(fbc, &percpu_counter_debug_descr);\n\tdebug_object_free(fbc, &percpu_counter_debug_descr);\n}\n\n#else\t \nstatic inline void debug_percpu_counter_activate(struct percpu_counter *fbc)\n{ }\nstatic inline void debug_percpu_counter_deactivate(struct percpu_counter *fbc)\n{ }\n#endif\t \n\nvoid percpu_counter_set(struct percpu_counter *fbc, s64 amount)\n{\n\tint cpu;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&fbc->lock, flags);\n\tfor_each_possible_cpu(cpu) {\n\t\ts32 *pcount = per_cpu_ptr(fbc->counters, cpu);\n\t\t*pcount = 0;\n\t}\n\tfbc->count = amount;\n\traw_spin_unlock_irqrestore(&fbc->lock, flags);\n}\nEXPORT_SYMBOL(percpu_counter_set);\n\n \nvoid percpu_counter_add_batch(struct percpu_counter *fbc, s64 amount, s32 batch)\n{\n\ts64 count;\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tcount = __this_cpu_read(*fbc->counters) + amount;\n\tif (abs(count) >= batch) {\n\t\traw_spin_lock(&fbc->lock);\n\t\tfbc->count += count;\n\t\t__this_cpu_sub(*fbc->counters, count - amount);\n\t\traw_spin_unlock(&fbc->lock);\n\t} else {\n\t\tthis_cpu_add(*fbc->counters, amount);\n\t}\n\tlocal_irq_restore(flags);\n}\nEXPORT_SYMBOL(percpu_counter_add_batch);\n\n \nvoid percpu_counter_sync(struct percpu_counter *fbc)\n{\n\tunsigned long flags;\n\ts64 count;\n\n\traw_spin_lock_irqsave(&fbc->lock, flags);\n\tcount = __this_cpu_read(*fbc->counters);\n\tfbc->count += count;\n\t__this_cpu_sub(*fbc->counters, count);\n\traw_spin_unlock_irqrestore(&fbc->lock, flags);\n}\nEXPORT_SYMBOL(percpu_counter_sync);\n\n \ns64 __percpu_counter_sum(struct percpu_counter *fbc)\n{\n\ts64 ret;\n\tint cpu;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&fbc->lock, flags);\n\tret = fbc->count;\n\tfor_each_cpu_or(cpu, cpu_online_mask, cpu_dying_mask) {\n\t\ts32 *pcount = per_cpu_ptr(fbc->counters, cpu);\n\t\tret += *pcount;\n\t}\n\traw_spin_unlock_irqrestore(&fbc->lock, flags);\n\treturn ret;\n}\nEXPORT_SYMBOL(__percpu_counter_sum);\n\nint __percpu_counter_init_many(struct percpu_counter *fbc, s64 amount,\n\t\t\t       gfp_t gfp, u32 nr_counters,\n\t\t\t       struct lock_class_key *key)\n{\n\tunsigned long flags __maybe_unused;\n\tsize_t counter_size;\n\ts32 __percpu *counters;\n\tu32 i;\n\n\tcounter_size = ALIGN(sizeof(*counters), __alignof__(*counters));\n\tcounters = __alloc_percpu_gfp(nr_counters * counter_size,\n\t\t\t\t      __alignof__(*counters), gfp);\n\tif (!counters) {\n\t\tfbc[0].counters = NULL;\n\t\treturn -ENOMEM;\n\t}\n\n\tfor (i = 0; i < nr_counters; i++) {\n\t\traw_spin_lock_init(&fbc[i].lock);\n\t\tlockdep_set_class(&fbc[i].lock, key);\n#ifdef CONFIG_HOTPLUG_CPU\n\t\tINIT_LIST_HEAD(&fbc[i].list);\n#endif\n\t\tfbc[i].count = amount;\n\t\tfbc[i].counters = (void *)counters + (i * counter_size);\n\n\t\tdebug_percpu_counter_activate(&fbc[i]);\n\t}\n\n#ifdef CONFIG_HOTPLUG_CPU\n\tspin_lock_irqsave(&percpu_counters_lock, flags);\n\tfor (i = 0; i < nr_counters; i++)\n\t\tlist_add(&fbc[i].list, &percpu_counters);\n\tspin_unlock_irqrestore(&percpu_counters_lock, flags);\n#endif\n\treturn 0;\n}\nEXPORT_SYMBOL(__percpu_counter_init_many);\n\nvoid percpu_counter_destroy_many(struct percpu_counter *fbc, u32 nr_counters)\n{\n\tunsigned long flags __maybe_unused;\n\tu32 i;\n\n\tif (WARN_ON_ONCE(!fbc))\n\t\treturn;\n\n\tif (!fbc[0].counters)\n\t\treturn;\n\n\tfor (i = 0; i < nr_counters; i++)\n\t\tdebug_percpu_counter_deactivate(&fbc[i]);\n\n#ifdef CONFIG_HOTPLUG_CPU\n\tspin_lock_irqsave(&percpu_counters_lock, flags);\n\tfor (i = 0; i < nr_counters; i++)\n\t\tlist_del(&fbc[i].list);\n\tspin_unlock_irqrestore(&percpu_counters_lock, flags);\n#endif\n\n\tfree_percpu(fbc[0].counters);\n\n\tfor (i = 0; i < nr_counters; i++)\n\t\tfbc[i].counters = NULL;\n}\nEXPORT_SYMBOL(percpu_counter_destroy_many);\n\nint percpu_counter_batch __read_mostly = 32;\nEXPORT_SYMBOL(percpu_counter_batch);\n\nstatic int compute_batch_value(unsigned int cpu)\n{\n\tint nr = num_online_cpus();\n\n\tpercpu_counter_batch = max(32, nr*2);\n\treturn 0;\n}\n\nstatic int percpu_counter_cpu_dead(unsigned int cpu)\n{\n#ifdef CONFIG_HOTPLUG_CPU\n\tstruct percpu_counter *fbc;\n\n\tcompute_batch_value(cpu);\n\n\tspin_lock_irq(&percpu_counters_lock);\n\tlist_for_each_entry(fbc, &percpu_counters, list) {\n\t\ts32 *pcount;\n\n\t\traw_spin_lock(&fbc->lock);\n\t\tpcount = per_cpu_ptr(fbc->counters, cpu);\n\t\tfbc->count += *pcount;\n\t\t*pcount = 0;\n\t\traw_spin_unlock(&fbc->lock);\n\t}\n\tspin_unlock_irq(&percpu_counters_lock);\n#endif\n\treturn 0;\n}\n\n \nint __percpu_counter_compare(struct percpu_counter *fbc, s64 rhs, s32 batch)\n{\n\ts64\tcount;\n\n\tcount = percpu_counter_read(fbc);\n\t \n\tif (abs(count - rhs) > (batch * num_online_cpus())) {\n\t\tif (count > rhs)\n\t\t\treturn 1;\n\t\telse\n\t\t\treturn -1;\n\t}\n\t \n\tcount = percpu_counter_sum(fbc);\n\tif (count > rhs)\n\t\treturn 1;\n\telse if (count < rhs)\n\t\treturn -1;\n\telse\n\t\treturn 0;\n}\nEXPORT_SYMBOL(__percpu_counter_compare);\n\nstatic int __init percpu_counter_startup(void)\n{\n\tint ret;\n\n\tret = cpuhp_setup_state(CPUHP_AP_ONLINE_DYN, \"lib/percpu_cnt:online\",\n\t\t\t\tcompute_batch_value, NULL);\n\tWARN_ON(ret < 0);\n\tret = cpuhp_setup_state_nocalls(CPUHP_PERCPU_CNT_DEAD,\n\t\t\t\t\t\"lib/percpu_cnt:dead\", NULL,\n\t\t\t\t\tpercpu_counter_cpu_dead);\n\tWARN_ON(ret < 0);\n\treturn 0;\n}\nmodule_init(percpu_counter_startup);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}