{
  "module_name": "inflate.c",
  "hash_id": "1f7858ae557e20e6dc7077d9563f45059e642fecb7e88c35994bedc8de7a6095",
  "original_prompt": "Ingested from linux-6.6.14/lib/zlib_inflate/inflate.c",
  "human_readable_source": " \n\n#include <linux/zutil.h>\n#include \"inftrees.h\"\n#include \"inflate.h\"\n#include \"inffast.h\"\n#include \"infutil.h\"\n\n \n#ifdef CONFIG_ZLIB_DFLTCC\n#  include \"../zlib_dfltcc/dfltcc_inflate.h\"\n#else\n#define INFLATE_RESET_HOOK(strm) do {} while (0)\n#define INFLATE_TYPEDO_HOOK(strm, flush) do {} while (0)\n#define INFLATE_NEED_UPDATEWINDOW(strm) 1\n#define INFLATE_NEED_CHECKSUM(strm) 1\n#endif\n\nint zlib_inflate_workspacesize(void)\n{\n    return sizeof(struct inflate_workspace);\n}\n\nint zlib_inflateReset(z_streamp strm)\n{\n    struct inflate_state *state;\n\n    if (strm == NULL || strm->state == NULL) return Z_STREAM_ERROR;\n    state = (struct inflate_state *)strm->state;\n    strm->total_in = strm->total_out = state->total = 0;\n    strm->msg = NULL;\n    strm->adler = 1;         \n    state->mode = HEAD;\n    state->last = 0;\n    state->havedict = 0;\n    state->dmax = 32768U;\n    state->hold = 0;\n    state->bits = 0;\n    state->lencode = state->distcode = state->next = state->codes;\n\n     \n    state->wsize = 1U << state->wbits;\n    state->write = 0;\n    state->whave = 0;\n\n    INFLATE_RESET_HOOK(strm);\n    return Z_OK;\n}\n\nint zlib_inflateInit2(z_streamp strm, int windowBits)\n{\n    struct inflate_state *state;\n\n    if (strm == NULL) return Z_STREAM_ERROR;\n    strm->msg = NULL;                  \n\n    state = &WS(strm)->inflate_state;\n    strm->state = (struct internal_state *)state;\n\n    if (windowBits < 0) {\n        state->wrap = 0;\n        windowBits = -windowBits;\n    }\n    else {\n        state->wrap = (windowBits >> 4) + 1;\n    }\n    if (windowBits < 8 || windowBits > 15) {\n        return Z_STREAM_ERROR;\n    }\n    state->wbits = (unsigned)windowBits;\n#ifdef CONFIG_ZLIB_DFLTCC\n     \n    state->window = PTR_ALIGN(&WS(strm)->working_window[0], PAGE_SIZE);\n#else\n    state->window = &WS(strm)->working_window[0];\n#endif\n\n    return zlib_inflateReset(strm);\n}\n\n \nstatic void zlib_fixedtables(struct inflate_state *state)\n{\n#   include \"inffixed.h\"\n    state->lencode = lenfix;\n    state->lenbits = 9;\n    state->distcode = distfix;\n    state->distbits = 5;\n}\n\n\n \nstatic void zlib_updatewindow(z_streamp strm, unsigned out)\n{\n    struct inflate_state *state;\n    unsigned copy, dist;\n\n    state = (struct inflate_state *)strm->state;\n\n     \n    copy = out - strm->avail_out;\n    if (copy >= state->wsize) {\n        memcpy(state->window, strm->next_out - state->wsize, state->wsize);\n        state->write = 0;\n        state->whave = state->wsize;\n    }\n    else {\n        dist = state->wsize - state->write;\n        if (dist > copy) dist = copy;\n        memcpy(state->window + state->write, strm->next_out - copy, dist);\n        copy -= dist;\n        if (copy) {\n            memcpy(state->window, strm->next_out - copy, copy);\n            state->write = copy;\n            state->whave = state->wsize;\n        }\n        else {\n            state->write += dist;\n            if (state->write == state->wsize) state->write = 0;\n            if (state->whave < state->wsize) state->whave += dist;\n        }\n    }\n}\n\n\n \n \nstatic int zlib_inflateSyncPacket(z_streamp strm)\n{\n    struct inflate_state *state;\n\n    if (strm == NULL || strm->state == NULL) return Z_STREAM_ERROR;\n    state = (struct inflate_state *)strm->state;\n\n    if (state->mode == STORED && state->bits == 0) {\n\tstate->mode = TYPE;\n        return Z_OK;\n    }\n    return Z_DATA_ERROR;\n}\n\n \n\n \n#define UPDATE(check, buf, len) zlib_adler32(check, buf, len)\n\n \n#define LOAD() \\\n    do { \\\n        put = strm->next_out; \\\n        left = strm->avail_out; \\\n        next = strm->next_in; \\\n        have = strm->avail_in; \\\n        hold = state->hold; \\\n        bits = state->bits; \\\n    } while (0)\n\n \n#define RESTORE() \\\n    do { \\\n        strm->next_out = put; \\\n        strm->avail_out = left; \\\n        strm->next_in = next; \\\n        strm->avail_in = have; \\\n        state->hold = hold; \\\n        state->bits = bits; \\\n    } while (0)\n\n \n#define INITBITS() \\\n    do { \\\n        hold = 0; \\\n        bits = 0; \\\n    } while (0)\n\n \n#define PULLBYTE() \\\n    do { \\\n        if (have == 0) goto inf_leave; \\\n        have--; \\\n        hold += (unsigned long)(*next++) << bits; \\\n        bits += 8; \\\n    } while (0)\n\n \n#define NEEDBITS(n) \\\n    do { \\\n        while (bits < (unsigned)(n)) \\\n            PULLBYTE(); \\\n    } while (0)\n\n \n#define BITS(n) \\\n    ((unsigned)hold & ((1U << (n)) - 1))\n\n \n#define DROPBITS(n) \\\n    do { \\\n        hold >>= (n); \\\n        bits -= (unsigned)(n); \\\n    } while (0)\n\n \n#define BYTEBITS() \\\n    do { \\\n        hold >>= bits & 7; \\\n        bits -= bits & 7; \\\n    } while (0)\n\n \n\nint zlib_inflate(z_streamp strm, int flush)\n{\n    struct inflate_state *state;\n    const unsigned char *next;   \n    unsigned char *put;          \n    unsigned have, left;         \n    unsigned long hold;          \n    unsigned bits;               \n    unsigned in, out;            \n    unsigned copy;               \n    unsigned char *from;         \n    code this;                   \n    code last;                   \n    unsigned len;                \n    int ret;                     \n    static const unsigned short order[19] =  \n        {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};\n\n     \n\n    if (strm == NULL || strm->state == NULL ||\n        (strm->next_in == NULL && strm->avail_in != 0))\n        return Z_STREAM_ERROR;\n\n    state = (struct inflate_state *)strm->state;\n\n    if (state->mode == TYPE) state->mode = TYPEDO;       \n    LOAD();\n    in = have;\n    out = left;\n    ret = Z_OK;\n    for (;;)\n        switch (state->mode) {\n        case HEAD:\n            if (state->wrap == 0) {\n                state->mode = TYPEDO;\n                break;\n            }\n            NEEDBITS(16);\n            if (\n                ((BITS(8) << 8) + (hold >> 8)) % 31) {\n                strm->msg = (char *)\"incorrect header check\";\n                state->mode = BAD;\n                break;\n            }\n            if (BITS(4) != Z_DEFLATED) {\n                strm->msg = (char *)\"unknown compression method\";\n                state->mode = BAD;\n                break;\n            }\n            DROPBITS(4);\n            len = BITS(4) + 8;\n            if (len > state->wbits) {\n                strm->msg = (char *)\"invalid window size\";\n                state->mode = BAD;\n                break;\n            }\n            state->dmax = 1U << len;\n            strm->adler = state->check = zlib_adler32(0L, NULL, 0);\n            state->mode = hold & 0x200 ? DICTID : TYPE;\n            INITBITS();\n            break;\n        case DICTID:\n            NEEDBITS(32);\n            strm->adler = state->check = REVERSE(hold);\n            INITBITS();\n            state->mode = DICT;\n\t    fallthrough;\n        case DICT:\n            if (state->havedict == 0) {\n                RESTORE();\n                return Z_NEED_DICT;\n            }\n            strm->adler = state->check = zlib_adler32(0L, NULL, 0);\n            state->mode = TYPE;\n\t    fallthrough;\n        case TYPE:\n            if (flush == Z_BLOCK) goto inf_leave;\n\t    fallthrough;\n        case TYPEDO:\n            INFLATE_TYPEDO_HOOK(strm, flush);\n            if (state->last) {\n                BYTEBITS();\n                state->mode = CHECK;\n                break;\n            }\n            NEEDBITS(3);\n            state->last = BITS(1);\n            DROPBITS(1);\n            switch (BITS(2)) {\n            case 0:                              \n                state->mode = STORED;\n                break;\n            case 1:                              \n                zlib_fixedtables(state);\n                state->mode = LEN;               \n                break;\n            case 2:                              \n                state->mode = TABLE;\n                break;\n            case 3:\n                strm->msg = (char *)\"invalid block type\";\n                state->mode = BAD;\n            }\n            DROPBITS(2);\n            break;\n        case STORED:\n            BYTEBITS();                          \n            NEEDBITS(32);\n            if ((hold & 0xffff) != ((hold >> 16) ^ 0xffff)) {\n                strm->msg = (char *)\"invalid stored block lengths\";\n                state->mode = BAD;\n                break;\n            }\n            state->length = (unsigned)hold & 0xffff;\n            INITBITS();\n            state->mode = COPY;\n\t    fallthrough;\n        case COPY:\n            copy = state->length;\n            if (copy) {\n                if (copy > have) copy = have;\n                if (copy > left) copy = left;\n                if (copy == 0) goto inf_leave;\n                memcpy(put, next, copy);\n                have -= copy;\n                next += copy;\n                left -= copy;\n                put += copy;\n                state->length -= copy;\n                break;\n            }\n            state->mode = TYPE;\n            break;\n        case TABLE:\n            NEEDBITS(14);\n            state->nlen = BITS(5) + 257;\n            DROPBITS(5);\n            state->ndist = BITS(5) + 1;\n            DROPBITS(5);\n            state->ncode = BITS(4) + 4;\n            DROPBITS(4);\n#ifndef PKZIP_BUG_WORKAROUND\n            if (state->nlen > 286 || state->ndist > 30) {\n                strm->msg = (char *)\"too many length or distance symbols\";\n                state->mode = BAD;\n                break;\n            }\n#endif\n            state->have = 0;\n            state->mode = LENLENS;\n\t    fallthrough;\n        case LENLENS:\n            while (state->have < state->ncode) {\n                NEEDBITS(3);\n                state->lens[order[state->have++]] = (unsigned short)BITS(3);\n                DROPBITS(3);\n            }\n            while (state->have < 19)\n                state->lens[order[state->have++]] = 0;\n            state->next = state->codes;\n            state->lencode = (code const *)(state->next);\n            state->lenbits = 7;\n            ret = zlib_inflate_table(CODES, state->lens, 19, &(state->next),\n                                &(state->lenbits), state->work);\n            if (ret) {\n                strm->msg = (char *)\"invalid code lengths set\";\n                state->mode = BAD;\n                break;\n            }\n            state->have = 0;\n            state->mode = CODELENS;\n\t    fallthrough;\n        case CODELENS:\n            while (state->have < state->nlen + state->ndist) {\n                for (;;) {\n                    this = state->lencode[BITS(state->lenbits)];\n                    if ((unsigned)(this.bits) <= bits) break;\n                    PULLBYTE();\n                }\n                if (this.val < 16) {\n                    NEEDBITS(this.bits);\n                    DROPBITS(this.bits);\n                    state->lens[state->have++] = this.val;\n                }\n                else {\n                    if (this.val == 16) {\n                        NEEDBITS(this.bits + 2);\n                        DROPBITS(this.bits);\n                        if (state->have == 0) {\n                            strm->msg = (char *)\"invalid bit length repeat\";\n                            state->mode = BAD;\n                            break;\n                        }\n                        len = state->lens[state->have - 1];\n                        copy = 3 + BITS(2);\n                        DROPBITS(2);\n                    }\n                    else if (this.val == 17) {\n                        NEEDBITS(this.bits + 3);\n                        DROPBITS(this.bits);\n                        len = 0;\n                        copy = 3 + BITS(3);\n                        DROPBITS(3);\n                    }\n                    else {\n                        NEEDBITS(this.bits + 7);\n                        DROPBITS(this.bits);\n                        len = 0;\n                        copy = 11 + BITS(7);\n                        DROPBITS(7);\n                    }\n                    if (state->have + copy > state->nlen + state->ndist) {\n                        strm->msg = (char *)\"invalid bit length repeat\";\n                        state->mode = BAD;\n                        break;\n                    }\n                    while (copy--)\n                        state->lens[state->have++] = (unsigned short)len;\n                }\n            }\n\n             \n            if (state->mode == BAD) break;\n\n             \n            state->next = state->codes;\n            state->lencode = (code const *)(state->next);\n            state->lenbits = 9;\n            ret = zlib_inflate_table(LENS, state->lens, state->nlen, &(state->next),\n                                &(state->lenbits), state->work);\n            if (ret) {\n                strm->msg = (char *)\"invalid literal/lengths set\";\n                state->mode = BAD;\n                break;\n            }\n            state->distcode = (code const *)(state->next);\n            state->distbits = 6;\n            ret = zlib_inflate_table(DISTS, state->lens + state->nlen, state->ndist,\n                            &(state->next), &(state->distbits), state->work);\n            if (ret) {\n                strm->msg = (char *)\"invalid distances set\";\n                state->mode = BAD;\n                break;\n            }\n            state->mode = LEN;\n\t    fallthrough;\n        case LEN:\n            if (have >= 6 && left >= 258) {\n                RESTORE();\n                inflate_fast(strm, out);\n                LOAD();\n                break;\n            }\n            for (;;) {\n                this = state->lencode[BITS(state->lenbits)];\n                if ((unsigned)(this.bits) <= bits) break;\n                PULLBYTE();\n            }\n            if (this.op && (this.op & 0xf0) == 0) {\n                last = this;\n                for (;;) {\n                    this = state->lencode[last.val +\n                            (BITS(last.bits + last.op) >> last.bits)];\n                    if ((unsigned)(last.bits + this.bits) <= bits) break;\n                    PULLBYTE();\n                }\n                DROPBITS(last.bits);\n            }\n            DROPBITS(this.bits);\n            state->length = (unsigned)this.val;\n            if ((int)(this.op) == 0) {\n                state->mode = LIT;\n                break;\n            }\n            if (this.op & 32) {\n                state->mode = TYPE;\n                break;\n            }\n            if (this.op & 64) {\n                strm->msg = (char *)\"invalid literal/length code\";\n                state->mode = BAD;\n                break;\n            }\n            state->extra = (unsigned)(this.op) & 15;\n            state->mode = LENEXT;\n\t    fallthrough;\n        case LENEXT:\n            if (state->extra) {\n                NEEDBITS(state->extra);\n                state->length += BITS(state->extra);\n                DROPBITS(state->extra);\n            }\n            state->mode = DIST;\n\t    fallthrough;\n        case DIST:\n            for (;;) {\n                this = state->distcode[BITS(state->distbits)];\n                if ((unsigned)(this.bits) <= bits) break;\n                PULLBYTE();\n            }\n            if ((this.op & 0xf0) == 0) {\n                last = this;\n                for (;;) {\n                    this = state->distcode[last.val +\n                            (BITS(last.bits + last.op) >> last.bits)];\n                    if ((unsigned)(last.bits + this.bits) <= bits) break;\n                    PULLBYTE();\n                }\n                DROPBITS(last.bits);\n            }\n            DROPBITS(this.bits);\n            if (this.op & 64) {\n                strm->msg = (char *)\"invalid distance code\";\n                state->mode = BAD;\n                break;\n            }\n            state->offset = (unsigned)this.val;\n            state->extra = (unsigned)(this.op) & 15;\n            state->mode = DISTEXT;\n\t    fallthrough;\n        case DISTEXT:\n            if (state->extra) {\n                NEEDBITS(state->extra);\n                state->offset += BITS(state->extra);\n                DROPBITS(state->extra);\n            }\n#ifdef INFLATE_STRICT\n            if (state->offset > state->dmax) {\n                strm->msg = (char *)\"invalid distance too far back\";\n                state->mode = BAD;\n                break;\n            }\n#endif\n            if (state->offset > state->whave + out - left) {\n                strm->msg = (char *)\"invalid distance too far back\";\n                state->mode = BAD;\n                break;\n            }\n            state->mode = MATCH;\n\t    fallthrough;\n        case MATCH:\n            if (left == 0) goto inf_leave;\n            copy = out - left;\n            if (state->offset > copy) {          \n                copy = state->offset - copy;\n                if (copy > state->write) {\n                    copy -= state->write;\n                    from = state->window + (state->wsize - copy);\n                }\n                else\n                    from = state->window + (state->write - copy);\n                if (copy > state->length) copy = state->length;\n            }\n            else {                               \n                from = put - state->offset;\n                copy = state->length;\n            }\n            if (copy > left) copy = left;\n            left -= copy;\n            state->length -= copy;\n            do {\n                *put++ = *from++;\n            } while (--copy);\n            if (state->length == 0) state->mode = LEN;\n            break;\n        case LIT:\n            if (left == 0) goto inf_leave;\n            *put++ = (unsigned char)(state->length);\n            left--;\n            state->mode = LEN;\n            break;\n        case CHECK:\n            if (state->wrap) {\n                NEEDBITS(32);\n                out -= left;\n                strm->total_out += out;\n                state->total += out;\n                if (INFLATE_NEED_CHECKSUM(strm) && out)\n                    strm->adler = state->check =\n                        UPDATE(state->check, put - out, out);\n                out = left;\n                if ((\n                     REVERSE(hold)) != state->check) {\n                    strm->msg = (char *)\"incorrect data check\";\n                    state->mode = BAD;\n                    break;\n                }\n                INITBITS();\n            }\n            state->mode = DONE;\n\t    fallthrough;\n        case DONE:\n            ret = Z_STREAM_END;\n            goto inf_leave;\n        case BAD:\n            ret = Z_DATA_ERROR;\n            goto inf_leave;\n        case MEM:\n            return Z_MEM_ERROR;\n        case SYNC:\n        default:\n            return Z_STREAM_ERROR;\n        }\n\n     \n  inf_leave:\n    RESTORE();\n    if (INFLATE_NEED_UPDATEWINDOW(strm) &&\n            (state->wsize || (state->mode < CHECK && out != strm->avail_out)))\n        zlib_updatewindow(strm, out);\n\n    in -= strm->avail_in;\n    out -= strm->avail_out;\n    strm->total_in += in;\n    strm->total_out += out;\n    state->total += out;\n    if (INFLATE_NEED_CHECKSUM(strm) && state->wrap && out)\n        strm->adler = state->check =\n            UPDATE(state->check, strm->next_out - out, out);\n\n    strm->data_type = state->bits + (state->last ? 64 : 0) +\n                      (state->mode == TYPE ? 128 : 0);\n\n    if (flush == Z_PACKET_FLUSH && ret == Z_OK &&\n            strm->avail_out != 0 && strm->avail_in == 0)\n\t\treturn zlib_inflateSyncPacket(strm);\n\n    if (((in == 0 && out == 0) || flush == Z_FINISH) && ret == Z_OK)\n        ret = Z_BUF_ERROR;\n\n    return ret;\n}\n\nint zlib_inflateEnd(z_streamp strm)\n{\n    if (strm == NULL || strm->state == NULL)\n        return Z_STREAM_ERROR;\n    return Z_OK;\n}\n\n \nint zlib_inflateIncomp(z_stream *z)\n{\n    struct inflate_state *state = (struct inflate_state *)z->state;\n    Byte *saved_no = z->next_out;\n    uInt saved_ao = z->avail_out;\n\n    if (state->mode != TYPE && state->mode != HEAD)\n\treturn Z_DATA_ERROR;\n\n     \n    z->avail_out = 0;\n    z->next_out = (unsigned char*)z->next_in + z->avail_in;\n\n    zlib_updatewindow(z, z->avail_in);\n\n     \n    z->avail_out = saved_ao;\n    z->next_out = saved_no;\n\n    z->adler = state->check =\n        UPDATE(state->check, z->next_in, z->avail_in);\n\n    z->total_out += z->avail_in;\n    z->total_in += z->avail_in;\n    z->next_in += z->avail_in;\n    state->total += z->avail_in;\n    z->avail_in = 0;\n\n    return Z_OK;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}