{
  "module_name": "inffast.c",
  "hash_id": "4f567522ec9783aa38c84384b26a53ba70d7d9f6655852d2dfb8b6ddecfc556b",
  "original_prompt": "Ingested from linux-6.6.14/lib/zlib_inflate/inffast.c",
  "human_readable_source": " \n\n#include <linux/zutil.h>\n#include \"inftrees.h\"\n#include \"inflate.h\"\n#include \"inffast.h\"\n\n#ifndef ASMINF\n\nunion uu {\n\tunsigned short us;\n\tunsigned char b[2];\n};\n\n \nstatic inline unsigned short\nget_unaligned16(const unsigned short *p)\n{\n\tunion uu  mm;\n\tunsigned char *b = (unsigned char *)p;\n\n\tmm.b[0] = b[0];\n\tmm.b[1] = b[1];\n\treturn mm.us;\n}\n\n \nvoid inflate_fast(z_streamp strm, unsigned start)\n{\n    struct inflate_state *state;\n    const unsigned char *in;     \n    const unsigned char *last;   \n    unsigned char *out;          \n    unsigned char *beg;          \n    unsigned char *end;          \n#ifdef INFLATE_STRICT\n    unsigned dmax;               \n#endif\n    unsigned wsize;              \n    unsigned whave;              \n    unsigned write;              \n    unsigned char *window;       \n    unsigned long hold;          \n    unsigned bits;               \n    code const *lcode;           \n    code const *dcode;           \n    unsigned lmask;              \n    unsigned dmask;              \n    code this;                   \n    unsigned op;                 \n                                 \n    unsigned len;                \n    unsigned dist;               \n    unsigned char *from;         \n\n     \n    state = (struct inflate_state *)strm->state;\n    in = strm->next_in;\n    last = in + (strm->avail_in - 5);\n    out = strm->next_out;\n    beg = out - (start - strm->avail_out);\n    end = out + (strm->avail_out - 257);\n#ifdef INFLATE_STRICT\n    dmax = state->dmax;\n#endif\n    wsize = state->wsize;\n    whave = state->whave;\n    write = state->write;\n    window = state->window;\n    hold = state->hold;\n    bits = state->bits;\n    lcode = state->lencode;\n    dcode = state->distcode;\n    lmask = (1U << state->lenbits) - 1;\n    dmask = (1U << state->distbits) - 1;\n\n     \n    do {\n        if (bits < 15) {\n            hold += (unsigned long)(*in++) << bits;\n            bits += 8;\n            hold += (unsigned long)(*in++) << bits;\n            bits += 8;\n        }\n        this = lcode[hold & lmask];\n      dolen:\n        op = (unsigned)(this.bits);\n        hold >>= op;\n        bits -= op;\n        op = (unsigned)(this.op);\n        if (op == 0) {                           \n            *out++ = (unsigned char)(this.val);\n        }\n        else if (op & 16) {                      \n            len = (unsigned)(this.val);\n            op &= 15;                            \n            if (op) {\n                if (bits < op) {\n                    hold += (unsigned long)(*in++) << bits;\n                    bits += 8;\n                }\n                len += (unsigned)hold & ((1U << op) - 1);\n                hold >>= op;\n                bits -= op;\n            }\n            if (bits < 15) {\n                hold += (unsigned long)(*in++) << bits;\n                bits += 8;\n                hold += (unsigned long)(*in++) << bits;\n                bits += 8;\n            }\n            this = dcode[hold & dmask];\n          dodist:\n            op = (unsigned)(this.bits);\n            hold >>= op;\n            bits -= op;\n            op = (unsigned)(this.op);\n            if (op & 16) {                       \n                dist = (unsigned)(this.val);\n                op &= 15;                        \n                if (bits < op) {\n                    hold += (unsigned long)(*in++) << bits;\n                    bits += 8;\n                    if (bits < op) {\n                        hold += (unsigned long)(*in++) << bits;\n                        bits += 8;\n                    }\n                }\n                dist += (unsigned)hold & ((1U << op) - 1);\n#ifdef INFLATE_STRICT\n                if (dist > dmax) {\n                    strm->msg = (char *)\"invalid distance too far back\";\n                    state->mode = BAD;\n                    break;\n                }\n#endif\n                hold >>= op;\n                bits -= op;\n                op = (unsigned)(out - beg);      \n                if (dist > op) {                 \n                    op = dist - op;              \n                    if (op > whave) {\n                        strm->msg = (char *)\"invalid distance too far back\";\n                        state->mode = BAD;\n                        break;\n                    }\n                    from = window;\n                    if (write == 0) {            \n                        from += wsize - op;\n                        if (op < len) {          \n                            len -= op;\n                            do {\n                                *out++ = *from++;\n                            } while (--op);\n                            from = out - dist;   \n                        }\n                    }\n                    else if (write < op) {       \n                        from += wsize + write - op;\n                        op -= write;\n                        if (op < len) {          \n                            len -= op;\n                            do {\n                                *out++ = *from++;\n                            } while (--op);\n                            from = window;\n                            if (write < len) {   \n                                op = write;\n                                len -= op;\n                                do {\n                                    *out++ = *from++;\n                                } while (--op);\n                                from = out - dist;       \n                            }\n                        }\n                    }\n                    else {                       \n                        from += write - op;\n                        if (op < len) {          \n                            len -= op;\n                            do {\n                                *out++ = *from++;\n                            } while (--op);\n                            from = out - dist;   \n                        }\n                    }\n                    while (len > 2) {\n                        *out++ = *from++;\n                        *out++ = *from++;\n                        *out++ = *from++;\n                        len -= 3;\n                    }\n                    if (len) {\n                        *out++ = *from++;\n                        if (len > 1)\n                            *out++ = *from++;\n                    }\n                }\n                else {\n\t\t    unsigned short *sout;\n\t\t    unsigned long loops;\n\n                    from = out - dist;           \n\t\t     \n\t\t     \n\t\t    if (!((long)(out - 1) & 1)) {\n\t\t\t*out++ = *from++;\n\t\t\tlen--;\n\t\t    }\n\t\t    sout = (unsigned short *)(out);\n\t\t    if (dist > 2) {\n\t\t\tunsigned short *sfrom;\n\n\t\t\tsfrom = (unsigned short *)(from);\n\t\t\tloops = len >> 1;\n\t\t\tdo {\n\t\t\t    if (IS_ENABLED(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS))\n\t\t\t\t*sout++ = *sfrom++;\n\t\t\t    else\n\t\t\t\t*sout++ = get_unaligned16(sfrom++);\n\t\t\t} while (--loops);\n\t\t\tout = (unsigned char *)sout;\n\t\t\tfrom = (unsigned char *)sfrom;\n\t\t    } else {  \n\t\t\tunsigned short pat16;\n\n\t\t\tpat16 = *(sout-1);\n\t\t\tif (dist == 1) {\n\t\t\t\tunion uu mm;\n\t\t\t\t \n\t\t\t\tmm.us = pat16;\n\t\t\t\tmm.b[0] = mm.b[1];\n\t\t\t\tpat16 = mm.us;\n\t\t\t}\n\t\t\tloops = len >> 1;\n\t\t\tdo\n\t\t\t    *sout++ = pat16;\n\t\t\twhile (--loops);\n\t\t\tout = (unsigned char *)sout;\n\t\t    }\n\t\t    if (len & 1)\n\t\t\t*out++ = *from++;\n                }\n            }\n            else if ((op & 64) == 0) {           \n                this = dcode[this.val + (hold & ((1U << op) - 1))];\n                goto dodist;\n            }\n            else {\n                strm->msg = (char *)\"invalid distance code\";\n                state->mode = BAD;\n                break;\n            }\n        }\n        else if ((op & 64) == 0) {               \n            this = lcode[this.val + (hold & ((1U << op) - 1))];\n            goto dolen;\n        }\n        else if (op & 32) {                      \n            state->mode = TYPE;\n            break;\n        }\n        else {\n            strm->msg = (char *)\"invalid literal/length code\";\n            state->mode = BAD;\n            break;\n        }\n    } while (in < last && out < end);\n\n     \n    len = bits >> 3;\n    in -= len;\n    bits -= len << 3;\n    hold &= (1U << bits) - 1;\n\n     \n    strm->next_in = in;\n    strm->next_out = out;\n    strm->avail_in = (unsigned)(in < last ? 5 + (last - in) : 5 - (in - last));\n    strm->avail_out = (unsigned)(out < end ?\n                                 257 + (end - out) : 257 - (out - end));\n    state->hold = hold;\n    state->bits = bits;\n    return;\n}\n\n \n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}