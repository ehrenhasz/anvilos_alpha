{
  "module_name": "inftrees.c",
  "hash_id": "1cc8c4da64cd32b0c483bbb6d3276d3182128824edc9f37611f9f12ff3c7a663",
  "original_prompt": "Ingested from linux-6.6.14/lib/zlib_inflate/inftrees.c",
  "human_readable_source": " \n\n#include <linux/zutil.h>\n#include \"inftrees.h\"\n\n#define MAXBITS 15\n\n \nint zlib_inflate_table(codetype type, unsigned short *lens, unsigned codes,\n\t\t\tcode **table, unsigned *bits, unsigned short *work)\n{\n    unsigned len;                \n    unsigned sym;                \n    unsigned min, max;           \n    unsigned root;               \n    unsigned curr;               \n    unsigned drop;               \n    int left;                    \n    unsigned used;               \n    unsigned huff;               \n    unsigned incr;               \n    unsigned fill;               \n    unsigned low;                \n    unsigned mask;               \n    code this;                   \n    code *next;              \n    const unsigned short *base;      \n    const unsigned short *extra;     \n    int end;                     \n    unsigned short count[MAXBITS+1];     \n    unsigned short offs[MAXBITS+1];      \n    static const unsigned short lbase[31] = {  \n        3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,\n        35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0};\n    static const unsigned short lext[31] = {  \n        16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,\n        19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 201, 196};\n    static const unsigned short dbase[32] = {  \n        1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,\n        257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,\n        8193, 12289, 16385, 24577, 0, 0};\n    static const unsigned short dext[32] = {  \n        16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,\n        23, 23, 24, 24, 25, 25, 26, 26, 27, 27,\n        28, 28, 29, 29, 64, 64};\n\n     \n\n     \n    for (len = 0; len <= MAXBITS; len++)\n        count[len] = 0;\n    for (sym = 0; sym < codes; sym++)\n        count[lens[sym]]++;\n\n     \n    root = *bits;\n    for (max = MAXBITS; max >= 1; max--)\n        if (count[max] != 0) break;\n    if (root > max) root = max;\n    if (max == 0) {                      \n        this.op = (unsigned char)64;     \n        this.bits = (unsigned char)1;\n        this.val = (unsigned short)0;\n        *(*table)++ = this;              \n        *(*table)++ = this;\n        *bits = 1;\n        return 0;      \n    }\n    for (min = 1; min < MAXBITS; min++)\n        if (count[min] != 0) break;\n    if (root < min) root = min;\n\n     \n    left = 1;\n    for (len = 1; len <= MAXBITS; len++) {\n        left <<= 1;\n        left -= count[len];\n        if (left < 0) return -1;         \n    }\n    if (left > 0 && (type == CODES || max != 1))\n        return -1;                       \n\n     \n    offs[1] = 0;\n    for (len = 1; len < MAXBITS; len++)\n        offs[len + 1] = offs[len] + count[len];\n\n     \n    for (sym = 0; sym < codes; sym++)\n        if (lens[sym] != 0) work[offs[lens[sym]]++] = (unsigned short)sym;\n\n     \n\n     \n    switch (type) {\n    case CODES:\n        base = extra = work;     \n        end = 19;\n        break;\n    case LENS:\n        base = lbase;\n        base -= 257;\n        extra = lext;\n        extra -= 257;\n        end = 256;\n        break;\n    default:             \n        base = dbase;\n        extra = dext;\n        end = -1;\n    }\n\n     \n    huff = 0;                    \n    sym = 0;                     \n    len = min;                   \n    next = *table;               \n    curr = root;                 \n    drop = 0;                    \n    low = (unsigned)(-1);        \n    used = 1U << root;           \n    mask = used - 1;             \n\n     \n    if (type == LENS && used >= ENOUGH - MAXD)\n        return 1;\n\n     \n    for (;;) {\n         \n        this.bits = (unsigned char)(len - drop);\n        if ((int)(work[sym]) < end) {\n            this.op = (unsigned char)0;\n            this.val = work[sym];\n        }\n        else if ((int)(work[sym]) > end) {\n            this.op = (unsigned char)(extra[work[sym]]);\n            this.val = base[work[sym]];\n        }\n        else {\n            this.op = (unsigned char)(32 + 64);          \n            this.val = 0;\n        }\n\n         \n        incr = 1U << (len - drop);\n        fill = 1U << curr;\n        min = fill;                  \n        do {\n            fill -= incr;\n            next[(huff >> drop) + fill] = this;\n        } while (fill != 0);\n\n         \n        incr = 1U << (len - 1);\n        while (huff & incr)\n            incr >>= 1;\n        if (incr != 0) {\n            huff &= incr - 1;\n            huff += incr;\n        }\n        else\n            huff = 0;\n\n         \n        sym++;\n        if (--(count[len]) == 0) {\n            if (len == max) break;\n            len = lens[work[sym]];\n        }\n\n         \n        if (len > root && (huff & mask) != low) {\n             \n            if (drop == 0)\n                drop = root;\n\n             \n            next += min;             \n\n             \n            curr = len - drop;\n            left = (int)(1 << curr);\n            while (curr + drop < max) {\n                left -= count[curr + drop];\n                if (left <= 0) break;\n                curr++;\n                left <<= 1;\n            }\n\n             \n            used += 1U << curr;\n            if (type == LENS && used >= ENOUGH - MAXD)\n                return 1;\n\n             \n            low = huff & mask;\n            (*table)[low].op = (unsigned char)curr;\n            (*table)[low].bits = (unsigned char)root;\n            (*table)[low].val = (unsigned short)(next - *table);\n        }\n    }\n\n     \n    this.op = (unsigned char)64;                 \n    this.bits = (unsigned char)(len - drop);\n    this.val = (unsigned short)0;\n    while (huff != 0) {\n         \n        if (drop != 0 && (huff & mask) != low) {\n            drop = 0;\n            len = root;\n            next = *table;\n            this.bits = (unsigned char)len;\n        }\n\n         \n        next[huff >> drop] = this;\n\n         \n        incr = 1U << (len - 1);\n        while (huff & incr)\n            incr >>= 1;\n        if (incr != 0) {\n            huff &= incr - 1;\n            huff += incr;\n        }\n        else\n            huff = 0;\n    }\n\n     \n    *table += used;\n    *bits = root;\n    return 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}