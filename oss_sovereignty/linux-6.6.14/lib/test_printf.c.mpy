{
  "module_name": "test_printf.c",
  "hash_id": "b502a87783117f35910bfc9c58cb6800ba54cdf4695b89c0ba37dc0108db1fec",
  "original_prompt": "Ingested from linux-6.6.14/lib/test_printf.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/printk.h>\n#include <linux/random.h>\n#include <linux/rtc.h>\n#include <linux/slab.h>\n#include <linux/sprintf.h>\n#include <linux/string.h>\n\n#include <linux/bitmap.h>\n#include <linux/dcache.h>\n#include <linux/socket.h>\n#include <linux/in.h>\n\n#include <linux/gfp.h>\n#include <linux/mm.h>\n\n#include <linux/property.h>\n\n#include \"../tools/testing/selftests/kselftest_module.h\"\n\n#define BUF_SIZE 256\n#define PAD_SIZE 16\n#define FILL_CHAR '$'\n\n#define NOWARN(option, comment, block) \\\n\t__diag_push(); \\\n\t__diag_ignore_all(#option, comment); \\\n\tblock \\\n\t__diag_pop();\n\nKSTM_MODULE_GLOBALS();\n\nstatic char *test_buffer __initdata;\nstatic char *alloced_buffer __initdata;\n\nstatic int __printf(4, 0) __init\ndo_test(int bufsize, const char *expect, int elen,\n\tconst char *fmt, va_list ap)\n{\n\tva_list aq;\n\tint ret, written;\n\n\ttotal_tests++;\n\n\tmemset(alloced_buffer, FILL_CHAR, BUF_SIZE + 2*PAD_SIZE);\n\tva_copy(aq, ap);\n\tret = vsnprintf(test_buffer, bufsize, fmt, aq);\n\tva_end(aq);\n\n\tif (ret != elen) {\n\t\tpr_warn(\"vsnprintf(buf, %d, \\\"%s\\\", ...) returned %d, expected %d\\n\",\n\t\t\tbufsize, fmt, ret, elen);\n\t\treturn 1;\n\t}\n\n\tif (memchr_inv(alloced_buffer, FILL_CHAR, PAD_SIZE)) {\n\t\tpr_warn(\"vsnprintf(buf, %d, \\\"%s\\\", ...) wrote before buffer\\n\", bufsize, fmt);\n\t\treturn 1;\n\t}\n\n\tif (!bufsize) {\n\t\tif (memchr_inv(test_buffer, FILL_CHAR, BUF_SIZE + PAD_SIZE)) {\n\t\t\tpr_warn(\"vsnprintf(buf, 0, \\\"%s\\\", ...) wrote to buffer\\n\",\n\t\t\t\tfmt);\n\t\t\treturn 1;\n\t\t}\n\t\treturn 0;\n\t}\n\n\twritten = min(bufsize-1, elen);\n\tif (test_buffer[written]) {\n\t\tpr_warn(\"vsnprintf(buf, %d, \\\"%s\\\", ...) did not nul-terminate buffer\\n\",\n\t\t\tbufsize, fmt);\n\t\treturn 1;\n\t}\n\n\tif (memchr_inv(test_buffer + written + 1, FILL_CHAR, bufsize - (written + 1))) {\n\t\tpr_warn(\"vsnprintf(buf, %d, \\\"%s\\\", ...) wrote beyond the nul-terminator\\n\",\n\t\t\tbufsize, fmt);\n\t\treturn 1;\n\t}\n\n\tif (memchr_inv(test_buffer + bufsize, FILL_CHAR, BUF_SIZE + PAD_SIZE - bufsize)) {\n\t\tpr_warn(\"vsnprintf(buf, %d, \\\"%s\\\", ...) wrote beyond buffer\\n\", bufsize, fmt);\n\t\treturn 1;\n\t}\n\n\tif (memcmp(test_buffer, expect, written)) {\n\t\tpr_warn(\"vsnprintf(buf, %d, \\\"%s\\\", ...) wrote '%s', expected '%.*s'\\n\",\n\t\t\tbufsize, fmt, test_buffer, written, expect);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic void __printf(3, 4) __init\n__test(const char *expect, int elen, const char *fmt, ...)\n{\n\tva_list ap;\n\tint rand;\n\tchar *p;\n\n\tif (elen >= BUF_SIZE) {\n\t\tpr_err(\"error in test suite: expected output length %d too long. Format was '%s'.\\n\",\n\t\t       elen, fmt);\n\t\tfailed_tests++;\n\t\treturn;\n\t}\n\n\tva_start(ap, fmt);\n\n\t \n\tfailed_tests += do_test(BUF_SIZE, expect, elen, fmt, ap);\n\trand = get_random_u32_inclusive(1, elen + 1);\n\t \n\tfailed_tests += do_test(rand, expect, elen, fmt, ap);\n\tfailed_tests += do_test(0, expect, elen, fmt, ap);\n\n\tp = kvasprintf(GFP_KERNEL, fmt, ap);\n\tif (p) {\n\t\ttotal_tests++;\n\t\tif (memcmp(p, expect, elen+1)) {\n\t\t\tpr_warn(\"kvasprintf(..., \\\"%s\\\", ...) returned '%s', expected '%s'\\n\",\n\t\t\t\tfmt, p, expect);\n\t\t\tfailed_tests++;\n\t\t}\n\t\tkfree(p);\n\t}\n\tva_end(ap);\n}\n\n#define test(expect, fmt, ...)\t\t\t\t\t\\\n\t__test(expect, strlen(expect), fmt, ##__VA_ARGS__)\n\nstatic void __init\ntest_basic(void)\n{\n\t \n\tchar nul = '\\0';\n\n\ttest(\"\", &nul);\n\ttest(\"100%\", \"100%%\");\n\ttest(\"xxx%yyy\", \"xxx%cyyy\", '%');\n\t__test(\"xxx\\0yyy\", 7, \"xxx%cyyy\", '\\0');\n}\n\nstatic void __init\ntest_number(void)\n{\n\ttest(\"0x1234abcd  \", \"%#-12x\", 0x1234abcd);\n\ttest(\"  0x1234abcd\", \"%#12x\", 0x1234abcd);\n\ttest(\"0|001| 12|+123| 1234|-123|-1234\", \"%d|%03d|%3d|%+d|% d|%+d|% d\", 0, 1, 12, 123, 1234, -123, -1234);\n\tNOWARN(-Wformat, \"Intentionally test narrowing conversion specifiers.\", {\n\t\ttest(\"0|1|1|128|255\", \"%hhu|%hhu|%hhu|%hhu|%hhu\", 0, 1, 257, 128, -1);\n\t\ttest(\"0|1|1|-128|-1\", \"%hhd|%hhd|%hhd|%hhd|%hhd\", 0, 1, 257, 128, -1);\n\t\ttest(\"2015122420151225\", \"%ho%ho%#ho\", 1037, 5282, -11627);\n\t})\n\t \n\ttest(\"00|0|0|0|0\", \"%.2d|%.1d|%.0d|%.*d|%1.0d\", 0, 0, 0, 0, 0, 0);\n}\n\nstatic void __init\ntest_string(void)\n{\n\ttest(\"\", \"%s%.0s\", \"\", \"123\");\n\ttest(\"ABCD|abc|123\", \"%s|%.3s|%.*s\", \"ABCD\", \"abcdef\", 3, \"123456\");\n\ttest(\"1  |  2|3  |  4|5  \", \"%-3s|%3s|%-*s|%*s|%*s\", \"1\", \"2\", 3, \"3\", 3, \"4\", -3, \"5\");\n\ttest(\"1234      \", \"%-10.4s\", \"123456\");\n\ttest(\"      1234\", \"%10.4s\", \"123456\");\n\t \n\ttest(\"    \", \"%4.*s\", -5, \"123456\");\n\ttest(\"123456\", \"%.s\", \"123456\");\n\ttest(\"a||\", \"%.s|%.0s|%.*s\", \"a\", \"b\", 0, \"c\");\n\ttest(\"a  |   |   \", \"%-3.s|%-3.0s|%-3.*s\", \"a\", \"b\", 0, \"c\");\n}\n\n#define PLAIN_BUF_SIZE 64\t \n\n#if BITS_PER_LONG == 64\n\n#define PTR_WIDTH 16\n#define PTR ((void *)0xffff0123456789abUL)\n#define PTR_STR \"ffff0123456789ab\"\n#define PTR_VAL_NO_CRNG \"(____ptrval____)\"\n#define ZEROS \"00000000\"\t \n#define ONES \"ffffffff\"\t\t \n\nstatic int __init\nplain_format(void)\n{\n\tchar buf[PLAIN_BUF_SIZE];\n\tint nchars;\n\n\tnchars = snprintf(buf, PLAIN_BUF_SIZE, \"%p\", PTR);\n\n\tif (nchars != PTR_WIDTH)\n\t\treturn -1;\n\n\tif (strncmp(buf, PTR_VAL_NO_CRNG, PTR_WIDTH) == 0) {\n\t\tpr_warn(\"crng possibly not yet initialized. plain 'p' buffer contains \\\"%s\\\"\",\n\t\t\tPTR_VAL_NO_CRNG);\n\t\treturn 0;\n\t}\n\n\tif (strncmp(buf, ZEROS, strlen(ZEROS)) != 0)\n\t\treturn -1;\n\n\treturn 0;\n}\n\n#else\n\n#define PTR_WIDTH 8\n#define PTR ((void *)0x456789ab)\n#define PTR_STR \"456789ab\"\n#define PTR_VAL_NO_CRNG \"(ptrval)\"\n#define ZEROS \"\"\n#define ONES \"\"\n\nstatic int __init\nplain_format(void)\n{\n\t \n\treturn 0;\n}\n\n#endif\t \n\nstatic int __init\nplain_hash_to_buffer(const void *p, char *buf, size_t len)\n{\n\tint nchars;\n\n\tnchars = snprintf(buf, len, \"%p\", p);\n\n\tif (nchars != PTR_WIDTH)\n\t\treturn -1;\n\n\tif (strncmp(buf, PTR_VAL_NO_CRNG, PTR_WIDTH) == 0) {\n\t\tpr_warn(\"crng possibly not yet initialized. plain 'p' buffer contains \\\"%s\\\"\",\n\t\t\tPTR_VAL_NO_CRNG);\n\t\treturn 0;\n\t}\n\n\treturn 0;\n}\n\nstatic int __init\nplain_hash(void)\n{\n\tchar buf[PLAIN_BUF_SIZE];\n\tint ret;\n\n\tret = plain_hash_to_buffer(PTR, buf, PLAIN_BUF_SIZE);\n\tif (ret)\n\t\treturn ret;\n\n\tif (strncmp(buf, PTR_STR, PTR_WIDTH) == 0)\n\t\treturn -1;\n\n\treturn 0;\n}\n\n \nstatic void __init\nplain(void)\n{\n\tint err;\n\n\tif (no_hash_pointers) {\n\t\tpr_warn(\"skipping plain 'p' tests\");\n\t\tskipped_tests += 2;\n\t\treturn;\n\t}\n\n\terr = plain_hash();\n\tif (err) {\n\t\tpr_warn(\"plain 'p' does not appear to be hashed\\n\");\n\t\tfailed_tests++;\n\t\treturn;\n\t}\n\n\terr = plain_format();\n\tif (err) {\n\t\tpr_warn(\"hashing plain 'p' has unexpected format\\n\");\n\t\tfailed_tests++;\n\t}\n}\n\nstatic void __init\ntest_hashed(const char *fmt, const void *p)\n{\n\tchar buf[PLAIN_BUF_SIZE];\n\tint ret;\n\n\t \n\tret = plain_hash_to_buffer(p, buf, PLAIN_BUF_SIZE);\n\tif (ret)\n\t\treturn;\n\n\ttest(buf, fmt, p);\n}\n\n \nstatic void __init\nnull_pointer(void)\n{\n\ttest(ZEROS \"00000000\", \"%p\", NULL);\n\ttest(ZEROS \"00000000\", \"%px\", NULL);\n\ttest(\"(null)\", \"%pE\", NULL);\n}\n\n \nstatic void __init\nerror_pointer(void)\n{\n\ttest(ONES \"fffffff5\", \"%p\", ERR_PTR(-11));\n\ttest(ONES \"fffffff5\", \"%px\", ERR_PTR(-11));\n\ttest(\"(efault)\", \"%pE\", ERR_PTR(-11));\n}\n\n#define PTR_INVALID ((void *)0x000000ab)\n\nstatic void __init\ninvalid_pointer(void)\n{\n\ttest_hashed(\"%p\", PTR_INVALID);\n\ttest(ZEROS \"000000ab\", \"%px\", PTR_INVALID);\n\ttest(\"(efault)\", \"%pE\", PTR_INVALID);\n}\n\nstatic void __init\nsymbol_ptr(void)\n{\n}\n\nstatic void __init\nkernel_ptr(void)\n{\n\t \n}\n\nstatic void __init\nstruct_resource(void)\n{\n}\n\nstatic void __init\naddr(void)\n{\n}\n\nstatic void __init\nescaped_str(void)\n{\n}\n\nstatic void __init\nhex_string(void)\n{\n\tconst char buf[3] = {0xc0, 0xff, 0xee};\n\n\ttest(\"c0 ff ee|c0:ff:ee|c0-ff-ee|c0ffee\",\n\t     \"%3ph|%3phC|%3phD|%3phN\", buf, buf, buf, buf);\n\ttest(\"c0 ff ee|c0:ff:ee|c0-ff-ee|c0ffee\",\n\t     \"%*ph|%*phC|%*phD|%*phN\", 3, buf, 3, buf, 3, buf, 3, buf);\n}\n\nstatic void __init\nmac(void)\n{\n\tconst u8 addr[6] = {0x2d, 0x48, 0xd6, 0xfc, 0x7a, 0x05};\n\n\ttest(\"2d:48:d6:fc:7a:05\", \"%pM\", addr);\n\ttest(\"05:7a:fc:d6:48:2d\", \"%pMR\", addr);\n\ttest(\"2d-48-d6-fc-7a-05\", \"%pMF\", addr);\n\ttest(\"2d48d6fc7a05\", \"%pm\", addr);\n\ttest(\"057afcd6482d\", \"%pmR\", addr);\n}\n\nstatic void __init\nip4(void)\n{\n\tstruct sockaddr_in sa;\n\n\tsa.sin_family = AF_INET;\n\tsa.sin_port = cpu_to_be16(12345);\n\tsa.sin_addr.s_addr = cpu_to_be32(0x7f000001);\n\n\ttest(\"127.000.000.001|127.0.0.1\", \"%pi4|%pI4\", &sa.sin_addr, &sa.sin_addr);\n\ttest(\"127.000.000.001|127.0.0.1\", \"%piS|%pIS\", &sa, &sa);\n\tsa.sin_addr.s_addr = cpu_to_be32(0x01020304);\n\ttest(\"001.002.003.004:12345|1.2.3.4:12345\", \"%piSp|%pISp\", &sa, &sa);\n}\n\nstatic void __init\nip6(void)\n{\n}\n\nstatic void __init\nip(void)\n{\n\tip4();\n\tip6();\n}\n\nstatic void __init\nuuid(void)\n{\n\tconst char uuid[16] = {0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7,\n\t\t\t       0x8, 0x9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf};\n\n\ttest(\"00010203-0405-0607-0809-0a0b0c0d0e0f\", \"%pUb\", uuid);\n\ttest(\"00010203-0405-0607-0809-0A0B0C0D0E0F\", \"%pUB\", uuid);\n\ttest(\"03020100-0504-0706-0809-0a0b0c0d0e0f\", \"%pUl\", uuid);\n\ttest(\"03020100-0504-0706-0809-0A0B0C0D0E0F\", \"%pUL\", uuid);\n}\n\nstatic struct dentry test_dentry[4] __initdata = {\n\t{ .d_parent = &test_dentry[0],\n\t  .d_name = QSTR_INIT(test_dentry[0].d_iname, 3),\n\t  .d_iname = \"foo\" },\n\t{ .d_parent = &test_dentry[0],\n\t  .d_name = QSTR_INIT(test_dentry[1].d_iname, 5),\n\t  .d_iname = \"bravo\" },\n\t{ .d_parent = &test_dentry[1],\n\t  .d_name = QSTR_INIT(test_dentry[2].d_iname, 4),\n\t  .d_iname = \"alfa\" },\n\t{ .d_parent = &test_dentry[2],\n\t  .d_name = QSTR_INIT(test_dentry[3].d_iname, 5),\n\t  .d_iname = \"romeo\" },\n};\n\nstatic void __init\ndentry(void)\n{\n\ttest(\"foo\", \"%pd\", &test_dentry[0]);\n\ttest(\"foo\", \"%pd2\", &test_dentry[0]);\n\n\ttest(\"(null)\", \"%pd\", NULL);\n\ttest(\"(efault)\", \"%pd\", PTR_INVALID);\n\ttest(\"(null)\", \"%pD\", NULL);\n\ttest(\"(efault)\", \"%pD\", PTR_INVALID);\n\n\ttest(\"romeo\", \"%pd\", &test_dentry[3]);\n\ttest(\"alfa/romeo\", \"%pd2\", &test_dentry[3]);\n\ttest(\"bravo/alfa/romeo\", \"%pd3\", &test_dentry[3]);\n\ttest(\"/bravo/alfa/romeo\", \"%pd4\", &test_dentry[3]);\n\ttest(\"/bravo/alfa\", \"%pd4\", &test_dentry[2]);\n\n\ttest(\"bravo/alfa  |bravo/alfa  \", \"%-12pd2|%*pd2\", &test_dentry[2], -12, &test_dentry[2]);\n\ttest(\"  bravo/alfa|  bravo/alfa\", \"%12pd2|%*pd2\", &test_dentry[2], 12, &test_dentry[2]);\n}\n\nstatic void __init\nstruct_va_format(void)\n{\n}\n\nstatic void __init\ntime_and_date(void)\n{\n\t \n\tconst struct rtc_time tm = {\n\t\t.tm_sec = 43,\n\t\t.tm_min = 35,\n\t\t.tm_hour = 5,\n\t\t.tm_mday = 26,\n\t\t.tm_mon = 10,\n\t\t.tm_year = 118,\n\t};\n\t \n\ttime64_t t = 1546615943;\n\n\ttest(\"(%pt?)\", \"%pt\", &tm);\n\ttest(\"2018-11-26T05:35:43\", \"%ptR\", &tm);\n\ttest(\"0118-10-26T05:35:43\", \"%ptRr\", &tm);\n\ttest(\"05:35:43|2018-11-26\", \"%ptRt|%ptRd\", &tm, &tm);\n\ttest(\"05:35:43|0118-10-26\", \"%ptRtr|%ptRdr\", &tm, &tm);\n\ttest(\"05:35:43|2018-11-26\", \"%ptRttr|%ptRdtr\", &tm, &tm);\n\ttest(\"05:35:43 tr|2018-11-26 tr\", \"%ptRt tr|%ptRd tr\", &tm, &tm);\n\n\ttest(\"2019-01-04T15:32:23\", \"%ptT\", &t);\n\ttest(\"0119-00-04T15:32:23\", \"%ptTr\", &t);\n\ttest(\"15:32:23|2019-01-04\", \"%ptTt|%ptTd\", &t, &t);\n\ttest(\"15:32:23|0119-00-04\", \"%ptTtr|%ptTdr\", &t, &t);\n\n\ttest(\"2019-01-04 15:32:23\", \"%ptTs\", &t);\n\ttest(\"0119-00-04 15:32:23\", \"%ptTsr\", &t);\n\ttest(\"15:32:23|2019-01-04\", \"%ptTts|%ptTds\", &t, &t);\n\ttest(\"15:32:23|0119-00-04\", \"%ptTtrs|%ptTdrs\", &t, &t);\n}\n\nstatic void __init\nstruct_clk(void)\n{\n}\n\nstatic void __init\nlarge_bitmap(void)\n{\n\tconst int nbits = 1 << 16;\n\tunsigned long *bits = bitmap_zalloc(nbits, GFP_KERNEL);\n\tif (!bits)\n\t\treturn;\n\n\tbitmap_set(bits, 1, 20);\n\tbitmap_set(bits, 60000, 15);\n\ttest(\"1-20,60000-60014\", \"%*pbl\", nbits, bits);\n\tbitmap_free(bits);\n}\n\nstatic void __init\nbitmap(void)\n{\n\tDECLARE_BITMAP(bits, 20);\n\tconst int primes[] = {2,3,5,7,11,13,17,19};\n\tint i;\n\n\tbitmap_zero(bits, 20);\n\ttest(\"00000|00000\", \"%20pb|%*pb\", bits, 20, bits);\n\ttest(\"|\", \"%20pbl|%*pbl\", bits, 20, bits);\n\n\tfor (i = 0; i < ARRAY_SIZE(primes); ++i)\n\t\tset_bit(primes[i], bits);\n\ttest(\"a28ac|a28ac\", \"%20pb|%*pb\", bits, 20, bits);\n\ttest(\"2-3,5,7,11,13,17,19|2-3,5,7,11,13,17,19\", \"%20pbl|%*pbl\", bits, 20, bits);\n\n\tbitmap_fill(bits, 20);\n\ttest(\"fffff|fffff\", \"%20pb|%*pb\", bits, 20, bits);\n\ttest(\"0-19|0-19\", \"%20pbl|%*pbl\", bits, 20, bits);\n\n\tlarge_bitmap();\n}\n\nstatic void __init\nnetdev_features(void)\n{\n}\n\nstruct page_flags_test {\n\tint width;\n\tint shift;\n\tint mask;\n\tconst char *fmt;\n\tconst char *name;\n};\n\nstatic const struct page_flags_test pft[] = {\n\t{SECTIONS_WIDTH, SECTIONS_PGSHIFT, SECTIONS_MASK,\n\t \"%d\", \"section\"},\n\t{NODES_WIDTH, NODES_PGSHIFT, NODES_MASK,\n\t \"%d\", \"node\"},\n\t{ZONES_WIDTH, ZONES_PGSHIFT, ZONES_MASK,\n\t \"%d\", \"zone\"},\n\t{LAST_CPUPID_WIDTH, LAST_CPUPID_PGSHIFT, LAST_CPUPID_MASK,\n\t \"%#x\", \"lastcpupid\"},\n\t{KASAN_TAG_WIDTH, KASAN_TAG_PGSHIFT, KASAN_TAG_MASK,\n\t \"%#x\", \"kasantag\"},\n};\n\nstatic void __init\npage_flags_test(int section, int node, int zone, int last_cpupid,\n\t\tint kasan_tag, unsigned long flags, const char *name,\n\t\tchar *cmp_buf)\n{\n\tunsigned long values[] = {section, node, zone, last_cpupid, kasan_tag};\n\tunsigned long size;\n\tbool append = false;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(values); i++)\n\t\tflags |= (values[i] & pft[i].mask) << pft[i].shift;\n\n\tsize = scnprintf(cmp_buf, BUF_SIZE, \"%#lx(\", flags);\n\tif (flags & PAGEFLAGS_MASK) {\n\t\tsize += scnprintf(cmp_buf + size, BUF_SIZE - size, \"%s\", name);\n\t\tappend = true;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(pft); i++) {\n\t\tif (!pft[i].width)\n\t\t\tcontinue;\n\n\t\tif (append)\n\t\t\tsize += scnprintf(cmp_buf + size, BUF_SIZE - size, \"|\");\n\n\t\tsize += scnprintf(cmp_buf + size, BUF_SIZE - size, \"%s=\",\n\t\t\t\tpft[i].name);\n\t\tsize += scnprintf(cmp_buf + size, BUF_SIZE - size, pft[i].fmt,\n\t\t\t\tvalues[i] & pft[i].mask);\n\t\tappend = true;\n\t}\n\n\tsnprintf(cmp_buf + size, BUF_SIZE - size, \")\");\n\n\ttest(cmp_buf, \"%pGp\", &flags);\n}\n\nstatic void __init page_type_test(unsigned int page_type, const char *name,\n\t\t\t\t  char *cmp_buf)\n{\n\tunsigned long size;\n\n\tsize = scnprintf(cmp_buf, BUF_SIZE, \"%#x(\", page_type);\n\tif (page_type_has_type(page_type))\n\t\tsize += scnprintf(cmp_buf + size, BUF_SIZE - size, \"%s\", name);\n\n\tsnprintf(cmp_buf + size, BUF_SIZE - size, \")\");\n\ttest(cmp_buf, \"%pGt\", &page_type);\n}\n\nstatic void __init\nflags(void)\n{\n\tunsigned long flags;\n\tchar *cmp_buffer;\n\tgfp_t gfp;\n\tunsigned int page_type;\n\n\tcmp_buffer = kmalloc(BUF_SIZE, GFP_KERNEL);\n\tif (!cmp_buffer)\n\t\treturn;\n\n\tflags = 0;\n\tpage_flags_test(0, 0, 0, 0, 0, flags, \"\", cmp_buffer);\n\n\tflags = 1UL << NR_PAGEFLAGS;\n\tpage_flags_test(0, 0, 0, 0, 0, flags, \"\", cmp_buffer);\n\n\tflags |= 1UL << PG_uptodate | 1UL << PG_dirty | 1UL << PG_lru\n\t\t| 1UL << PG_active | 1UL << PG_swapbacked;\n\tpage_flags_test(1, 1, 1, 0x1fffff, 1, flags,\n\t\t\t\"uptodate|dirty|lru|active|swapbacked\",\n\t\t\tcmp_buffer);\n\n\tflags = VM_READ | VM_EXEC | VM_MAYREAD | VM_MAYWRITE | VM_MAYEXEC;\n\ttest(\"read|exec|mayread|maywrite|mayexec\", \"%pGv\", &flags);\n\n\tgfp = GFP_TRANSHUGE;\n\ttest(\"GFP_TRANSHUGE\", \"%pGg\", &gfp);\n\n\tgfp = GFP_ATOMIC|__GFP_DMA;\n\ttest(\"GFP_ATOMIC|GFP_DMA\", \"%pGg\", &gfp);\n\n\tgfp = __GFP_HIGH;\n\ttest(\"__GFP_HIGH\", \"%pGg\", &gfp);\n\n\t \n\tgfp = ~__GFP_BITS_MASK;\n\tsnprintf(cmp_buffer, BUF_SIZE, \"%#lx\", (unsigned long) gfp);\n\ttest(cmp_buffer, \"%pGg\", &gfp);\n\n\tsnprintf(cmp_buffer, BUF_SIZE, \"__GFP_HIGH|%#lx\",\n\t\t\t\t\t\t\t(unsigned long) gfp);\n\tgfp |= __GFP_HIGH;\n\ttest(cmp_buffer, \"%pGg\", &gfp);\n\n\tpage_type = ~0;\n\tpage_type_test(page_type, \"\", cmp_buffer);\n\n\tpage_type = 10;\n\tpage_type_test(page_type, \"\", cmp_buffer);\n\n\tpage_type = ~PG_buddy;\n\tpage_type_test(page_type, \"buddy\", cmp_buffer);\n\n\tpage_type = ~(PG_table | PG_buddy);\n\tpage_type_test(page_type, \"table|buddy\", cmp_buffer);\n\n\tkfree(cmp_buffer);\n}\n\nstatic void __init fwnode_pointer(void)\n{\n\tconst struct software_node first = { .name = \"first\" };\n\tconst struct software_node second = { .name = \"second\", .parent = &first };\n\tconst struct software_node third = { .name = \"third\", .parent = &second };\n\tconst struct software_node *group[] = { &first, &second, &third, NULL };\n\tconst char * const full_name_second = \"first/second\";\n\tconst char * const full_name_third = \"first/second/third\";\n\tconst char * const second_name = \"second\";\n\tconst char * const third_name = \"third\";\n\tint rval;\n\n\trval = software_node_register_node_group(group);\n\tif (rval) {\n\t\tpr_warn(\"cannot register softnodes; rval %d\\n\", rval);\n\t\treturn;\n\t}\n\n\ttest(full_name_second, \"%pfw\", software_node_fwnode(&second));\n\ttest(full_name_third, \"%pfw\", software_node_fwnode(&third));\n\ttest(full_name_third, \"%pfwf\", software_node_fwnode(&third));\n\ttest(second_name, \"%pfwP\", software_node_fwnode(&second));\n\ttest(third_name, \"%pfwP\", software_node_fwnode(&third));\n\n\tsoftware_node_unregister_node_group(group);\n}\n\nstatic void __init fourcc_pointer(void)\n{\n\tstruct {\n\t\tu32 code;\n\t\tchar *str;\n\t} const try[] = {\n\t\t{ 0x3231564e, \"NV12 little-endian (0x3231564e)\", },\n\t\t{ 0xb231564e, \"NV12 big-endian (0xb231564e)\", },\n\t\t{ 0x10111213, \".... little-endian (0x10111213)\", },\n\t\t{ 0x20303159, \"Y10  little-endian (0x20303159)\", },\n\t};\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(try); i++)\n\t\ttest(try[i].str, \"%p4cc\", &try[i].code);\n}\n\nstatic void __init\nerrptr(void)\n{\n\ttest(\"-1234\", \"%pe\", ERR_PTR(-1234));\n\n\t \n\tBUILD_BUG_ON(IS_ERR(PTR));\n\ttest_hashed(\"%pe\", PTR);\n\n#ifdef CONFIG_SYMBOLIC_ERRNAME\n\ttest(\"(-ENOTSOCK)\", \"(%pe)\", ERR_PTR(-ENOTSOCK));\n\ttest(\"(-EAGAIN)\", \"(%pe)\", ERR_PTR(-EAGAIN));\n\tBUILD_BUG_ON(EAGAIN != EWOULDBLOCK);\n\ttest(\"(-EAGAIN)\", \"(%pe)\", ERR_PTR(-EWOULDBLOCK));\n\ttest(\"[-EIO    ]\", \"[%-8pe]\", ERR_PTR(-EIO));\n\ttest(\"[    -EIO]\", \"[%8pe]\", ERR_PTR(-EIO));\n\ttest(\"-EPROBE_DEFER\", \"%pe\", ERR_PTR(-EPROBE_DEFER));\n#endif\n}\n\nstatic void __init\ntest_pointer(void)\n{\n\tplain();\n\tnull_pointer();\n\terror_pointer();\n\tinvalid_pointer();\n\tsymbol_ptr();\n\tkernel_ptr();\n\tstruct_resource();\n\taddr();\n\tescaped_str();\n\thex_string();\n\tmac();\n\tip();\n\tuuid();\n\tdentry();\n\tstruct_va_format();\n\ttime_and_date();\n\tstruct_clk();\n\tbitmap();\n\tnetdev_features();\n\tflags();\n\terrptr();\n\tfwnode_pointer();\n\tfourcc_pointer();\n}\n\nstatic void __init selftest(void)\n{\n\talloced_buffer = kmalloc(BUF_SIZE + 2*PAD_SIZE, GFP_KERNEL);\n\tif (!alloced_buffer)\n\t\treturn;\n\ttest_buffer = alloced_buffer + PAD_SIZE;\n\n\ttest_basic();\n\ttest_number();\n\ttest_string();\n\ttest_pointer();\n\n\tkfree(alloced_buffer);\n}\n\nKSTM_MODULE_LOADERS(test_printf);\nMODULE_AUTHOR(\"Rasmus Villemoes <linux@rasmusvillemoes.dk>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}