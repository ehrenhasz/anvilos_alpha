{
  "module_name": "once.c",
  "hash_id": "8d91573348cbb3e2742fd7b1623f9069b7eb4de8e324adccb9e978826be08edc",
  "original_prompt": "Ingested from linux-6.6.14/lib/once.c",
  "human_readable_source": "\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/once.h>\n#include <linux/random.h>\n#include <linux/module.h>\n\nstruct once_work {\n\tstruct work_struct work;\n\tstruct static_key_true *key;\n\tstruct module *module;\n};\n\nstatic void once_deferred(struct work_struct *w)\n{\n\tstruct once_work *work;\n\n\twork = container_of(w, struct once_work, work);\n\tBUG_ON(!static_key_enabled(work->key));\n\tstatic_branch_disable(work->key);\n\tmodule_put(work->module);\n\tkfree(work);\n}\n\nstatic void once_disable_jump(struct static_key_true *key, struct module *mod)\n{\n\tstruct once_work *w;\n\n\tw = kmalloc(sizeof(*w), GFP_ATOMIC);\n\tif (!w)\n\t\treturn;\n\n\tINIT_WORK(&w->work, once_deferred);\n\tw->key = key;\n\tw->module = mod;\n\t__module_get(mod);\n\tschedule_work(&w->work);\n}\n\nstatic DEFINE_SPINLOCK(once_lock);\n\nbool __do_once_start(bool *done, unsigned long *flags)\n\t__acquires(once_lock)\n{\n\tspin_lock_irqsave(&once_lock, *flags);\n\tif (*done) {\n\t\tspin_unlock_irqrestore(&once_lock, *flags);\n\t\t \n\t\t__acquire(once_lock);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\nEXPORT_SYMBOL(__do_once_start);\n\nvoid __do_once_done(bool *done, struct static_key_true *once_key,\n\t\t    unsigned long *flags, struct module *mod)\n\t__releases(once_lock)\n{\n\t*done = true;\n\tspin_unlock_irqrestore(&once_lock, *flags);\n\tonce_disable_jump(once_key, mod);\n}\nEXPORT_SYMBOL(__do_once_done);\n\nstatic DEFINE_MUTEX(once_mutex);\n\nbool __do_once_sleepable_start(bool *done)\n\t__acquires(once_mutex)\n{\n\tmutex_lock(&once_mutex);\n\tif (*done) {\n\t\tmutex_unlock(&once_mutex);\n\t\t \n\t\t__acquire(once_mutex);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\nEXPORT_SYMBOL(__do_once_sleepable_start);\n\nvoid __do_once_sleepable_done(bool *done, struct static_key_true *once_key,\n\t\t\t struct module *mod)\n\t__releases(once_mutex)\n{\n\t*done = true;\n\tmutex_unlock(&once_mutex);\n\tonce_disable_jump(once_key, mod);\n}\nEXPORT_SYMBOL(__do_once_sleepable_done);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}