{
  "module_name": "extable.c",
  "hash_id": "9e25e528ee6caf2f0866de9a028bff431b6031ce6fcdc5199e6519150bf949a6",
  "original_prompt": "Ingested from linux-6.6.14/lib/extable.c",
  "human_readable_source": "\n \n\n#include <linux/bsearch.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/uaccess.h>\n#include <linux/extable.h>\n\n#ifndef ARCH_HAS_RELATIVE_EXTABLE\n#define ex_to_insn(x)\t((x)->insn)\n#else\nstatic inline unsigned long ex_to_insn(const struct exception_table_entry *x)\n{\n\treturn (unsigned long)&x->insn + x->insn;\n}\n#endif\n\n#ifndef ARCH_HAS_RELATIVE_EXTABLE\n#define swap_ex\t\tNULL\n#else\nstatic void swap_ex(void *a, void *b, int size)\n{\n\tstruct exception_table_entry *x = a, *y = b, tmp;\n\tint delta = b - a;\n\n\ttmp = *x;\n\tx->insn = y->insn + delta;\n\ty->insn = tmp.insn - delta;\n\n#ifdef swap_ex_entry_fixup\n\tswap_ex_entry_fixup(x, y, tmp, delta);\n#else\n\tx->fixup = y->fixup + delta;\n\ty->fixup = tmp.fixup - delta;\n#endif\n}\n#endif  \n\n \nstatic int cmp_ex_sort(const void *a, const void *b)\n{\n\tconst struct exception_table_entry *x = a, *y = b;\n\n\t \n\tif (ex_to_insn(x) > ex_to_insn(y))\n\t\treturn 1;\n\tif (ex_to_insn(x) < ex_to_insn(y))\n\t\treturn -1;\n\treturn 0;\n}\n\nvoid sort_extable(struct exception_table_entry *start,\n\t\t  struct exception_table_entry *finish)\n{\n\tsort(start, finish - start, sizeof(struct exception_table_entry),\n\t     cmp_ex_sort, swap_ex);\n}\n\n#ifdef CONFIG_MODULES\n \nvoid trim_init_extable(struct module *m)\n{\n\t \n\twhile (m->num_exentries &&\n\t       within_module_init(ex_to_insn(&m->extable[0]), m)) {\n\t\tm->extable++;\n\t\tm->num_exentries--;\n\t}\n\t \n\twhile (m->num_exentries &&\n\t       within_module_init(ex_to_insn(&m->extable[m->num_exentries - 1]),\n\t\t\t\t  m))\n\t\tm->num_exentries--;\n}\n#endif  \n\nstatic int cmp_ex_search(const void *key, const void *elt)\n{\n\tconst struct exception_table_entry *_elt = elt;\n\tunsigned long _key = *(unsigned long *)key;\n\n\t \n\tif (_key > ex_to_insn(_elt))\n\t\treturn 1;\n\tif (_key < ex_to_insn(_elt))\n\t\treturn -1;\n\treturn 0;\n}\n\n \nconst struct exception_table_entry *\nsearch_extable(const struct exception_table_entry *base,\n\t       const size_t num,\n\t       unsigned long value)\n{\n\treturn bsearch(&value, base, num,\n\t\t       sizeof(struct exception_table_entry), cmp_ex_search);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}