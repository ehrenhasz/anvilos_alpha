{
  "module_name": "blk-crypto-internal.h",
  "hash_id": "76d3dc57b7711522ddfcfb667937dafc2712d7b120b6ce7a335bcae23ab0ec45",
  "original_prompt": "Ingested from linux-6.6.14/block/blk-crypto-internal.h",
  "human_readable_source": " \n \n\n#ifndef __LINUX_BLK_CRYPTO_INTERNAL_H\n#define __LINUX_BLK_CRYPTO_INTERNAL_H\n\n#include <linux/bio.h>\n#include <linux/blk-mq.h>\n\n \nstruct blk_crypto_mode {\n\tconst char *name;  \n\tconst char *cipher_str;  \n\tunsigned int keysize;  \n\tunsigned int ivsize;  \n};\n\nextern const struct blk_crypto_mode blk_crypto_modes[];\n\n#ifdef CONFIG_BLK_INLINE_ENCRYPTION\n\nint blk_crypto_sysfs_register(struct gendisk *disk);\n\nvoid blk_crypto_sysfs_unregister(struct gendisk *disk);\n\nvoid bio_crypt_dun_increment(u64 dun[BLK_CRYPTO_DUN_ARRAY_SIZE],\n\t\t\t     unsigned int inc);\n\nbool bio_crypt_rq_ctx_compatible(struct request *rq, struct bio *bio);\n\nbool bio_crypt_ctx_mergeable(struct bio_crypt_ctx *bc1, unsigned int bc1_bytes,\n\t\t\t     struct bio_crypt_ctx *bc2);\n\nstatic inline bool bio_crypt_ctx_back_mergeable(struct request *req,\n\t\t\t\t\t\tstruct bio *bio)\n{\n\treturn bio_crypt_ctx_mergeable(req->crypt_ctx, blk_rq_bytes(req),\n\t\t\t\t       bio->bi_crypt_context);\n}\n\nstatic inline bool bio_crypt_ctx_front_mergeable(struct request *req,\n\t\t\t\t\t\t struct bio *bio)\n{\n\treturn bio_crypt_ctx_mergeable(bio->bi_crypt_context,\n\t\t\t\t       bio->bi_iter.bi_size, req->crypt_ctx);\n}\n\nstatic inline bool bio_crypt_ctx_merge_rq(struct request *req,\n\t\t\t\t\t  struct request *next)\n{\n\treturn bio_crypt_ctx_mergeable(req->crypt_ctx, blk_rq_bytes(req),\n\t\t\t\t       next->crypt_ctx);\n}\n\nstatic inline void blk_crypto_rq_set_defaults(struct request *rq)\n{\n\trq->crypt_ctx = NULL;\n\trq->crypt_keyslot = NULL;\n}\n\nstatic inline bool blk_crypto_rq_is_encrypted(struct request *rq)\n{\n\treturn rq->crypt_ctx;\n}\n\nstatic inline bool blk_crypto_rq_has_keyslot(struct request *rq)\n{\n\treturn rq->crypt_keyslot;\n}\n\nblk_status_t blk_crypto_get_keyslot(struct blk_crypto_profile *profile,\n\t\t\t\t    const struct blk_crypto_key *key,\n\t\t\t\t    struct blk_crypto_keyslot **slot_ptr);\n\nvoid blk_crypto_put_keyslot(struct blk_crypto_keyslot *slot);\n\nint __blk_crypto_evict_key(struct blk_crypto_profile *profile,\n\t\t\t   const struct blk_crypto_key *key);\n\nbool __blk_crypto_cfg_supported(struct blk_crypto_profile *profile,\n\t\t\t\tconst struct blk_crypto_config *cfg);\n\n#else  \n\nstatic inline int blk_crypto_sysfs_register(struct gendisk *disk)\n{\n\treturn 0;\n}\n\nstatic inline void blk_crypto_sysfs_unregister(struct gendisk *disk)\n{\n}\n\nstatic inline bool bio_crypt_rq_ctx_compatible(struct request *rq,\n\t\t\t\t\t       struct bio *bio)\n{\n\treturn true;\n}\n\nstatic inline bool bio_crypt_ctx_front_mergeable(struct request *req,\n\t\t\t\t\t\t struct bio *bio)\n{\n\treturn true;\n}\n\nstatic inline bool bio_crypt_ctx_back_mergeable(struct request *req,\n\t\t\t\t\t\tstruct bio *bio)\n{\n\treturn true;\n}\n\nstatic inline bool bio_crypt_ctx_merge_rq(struct request *req,\n\t\t\t\t\t  struct request *next)\n{\n\treturn true;\n}\n\nstatic inline void blk_crypto_rq_set_defaults(struct request *rq) { }\n\nstatic inline bool blk_crypto_rq_is_encrypted(struct request *rq)\n{\n\treturn false;\n}\n\nstatic inline bool blk_crypto_rq_has_keyslot(struct request *rq)\n{\n\treturn false;\n}\n\n#endif  \n\nvoid __bio_crypt_advance(struct bio *bio, unsigned int bytes);\nstatic inline void bio_crypt_advance(struct bio *bio, unsigned int bytes)\n{\n\tif (bio_has_crypt_ctx(bio))\n\t\t__bio_crypt_advance(bio, bytes);\n}\n\nvoid __bio_crypt_free_ctx(struct bio *bio);\nstatic inline void bio_crypt_free_ctx(struct bio *bio)\n{\n\tif (bio_has_crypt_ctx(bio))\n\t\t__bio_crypt_free_ctx(bio);\n}\n\nstatic inline void bio_crypt_do_front_merge(struct request *rq,\n\t\t\t\t\t    struct bio *bio)\n{\n#ifdef CONFIG_BLK_INLINE_ENCRYPTION\n\tif (bio_has_crypt_ctx(bio))\n\t\tmemcpy(rq->crypt_ctx->bc_dun, bio->bi_crypt_context->bc_dun,\n\t\t       sizeof(rq->crypt_ctx->bc_dun));\n#endif\n}\n\nbool __blk_crypto_bio_prep(struct bio **bio_ptr);\nstatic inline bool blk_crypto_bio_prep(struct bio **bio_ptr)\n{\n\tif (bio_has_crypt_ctx(*bio_ptr))\n\t\treturn __blk_crypto_bio_prep(bio_ptr);\n\treturn true;\n}\n\nblk_status_t __blk_crypto_rq_get_keyslot(struct request *rq);\nstatic inline blk_status_t blk_crypto_rq_get_keyslot(struct request *rq)\n{\n\tif (blk_crypto_rq_is_encrypted(rq))\n\t\treturn __blk_crypto_rq_get_keyslot(rq);\n\treturn BLK_STS_OK;\n}\n\nvoid __blk_crypto_rq_put_keyslot(struct request *rq);\nstatic inline void blk_crypto_rq_put_keyslot(struct request *rq)\n{\n\tif (blk_crypto_rq_has_keyslot(rq))\n\t\t__blk_crypto_rq_put_keyslot(rq);\n}\n\nvoid __blk_crypto_free_request(struct request *rq);\nstatic inline void blk_crypto_free_request(struct request *rq)\n{\n\tif (blk_crypto_rq_is_encrypted(rq))\n\t\t__blk_crypto_free_request(rq);\n}\n\nint __blk_crypto_rq_bio_prep(struct request *rq, struct bio *bio,\n\t\t\t     gfp_t gfp_mask);\n \nstatic inline int blk_crypto_rq_bio_prep(struct request *rq, struct bio *bio,\n\t\t\t\t\t gfp_t gfp_mask)\n{\n\tif (bio_has_crypt_ctx(bio))\n\t\treturn __blk_crypto_rq_bio_prep(rq, bio, gfp_mask);\n\treturn 0;\n}\n\n#ifdef CONFIG_BLK_INLINE_ENCRYPTION_FALLBACK\n\nint blk_crypto_fallback_start_using_mode(enum blk_crypto_mode_num mode_num);\n\nbool blk_crypto_fallback_bio_prep(struct bio **bio_ptr);\n\nint blk_crypto_fallback_evict_key(const struct blk_crypto_key *key);\n\n#else  \n\nstatic inline int\nblk_crypto_fallback_start_using_mode(enum blk_crypto_mode_num mode_num)\n{\n\tpr_warn_once(\"crypto API fallback is disabled\\n\");\n\treturn -ENOPKG;\n}\n\nstatic inline bool blk_crypto_fallback_bio_prep(struct bio **bio_ptr)\n{\n\tpr_warn_once(\"crypto API fallback disabled; failing request.\\n\");\n\t(*bio_ptr)->bi_status = BLK_STS_NOTSUPP;\n\treturn false;\n}\n\nstatic inline int\nblk_crypto_fallback_evict_key(const struct blk_crypto_key *key)\n{\n\treturn 0;\n}\n\n#endif  \n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}