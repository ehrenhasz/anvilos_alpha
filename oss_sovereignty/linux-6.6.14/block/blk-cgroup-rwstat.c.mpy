{
  "module_name": "blk-cgroup-rwstat.c",
  "hash_id": "876a4d388fa5a5c1d778fc3f7e2500dec19cca550971753b1a16c959e305d921",
  "original_prompt": "Ingested from linux-6.6.14/block/blk-cgroup-rwstat.c",
  "human_readable_source": " \n#include \"blk-cgroup-rwstat.h\"\n\nint blkg_rwstat_init(struct blkg_rwstat *rwstat, gfp_t gfp)\n{\n\tint i, ret;\n\n\tfor (i = 0; i < BLKG_RWSTAT_NR; i++) {\n\t\tret = percpu_counter_init(&rwstat->cpu_cnt[i], 0, gfp);\n\t\tif (ret) {\n\t\t\twhile (--i >= 0)\n\t\t\t\tpercpu_counter_destroy(&rwstat->cpu_cnt[i]);\n\t\t\treturn ret;\n\t\t}\n\t\tatomic64_set(&rwstat->aux_cnt[i], 0);\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(blkg_rwstat_init);\n\nvoid blkg_rwstat_exit(struct blkg_rwstat *rwstat)\n{\n\tint i;\n\n\tfor (i = 0; i < BLKG_RWSTAT_NR; i++)\n\t\tpercpu_counter_destroy(&rwstat->cpu_cnt[i]);\n}\nEXPORT_SYMBOL_GPL(blkg_rwstat_exit);\n\n \nu64 __blkg_prfill_rwstat(struct seq_file *sf, struct blkg_policy_data *pd,\n\t\t\t const struct blkg_rwstat_sample *rwstat)\n{\n\tstatic const char *rwstr[] = {\n\t\t[BLKG_RWSTAT_READ]\t= \"Read\",\n\t\t[BLKG_RWSTAT_WRITE]\t= \"Write\",\n\t\t[BLKG_RWSTAT_SYNC]\t= \"Sync\",\n\t\t[BLKG_RWSTAT_ASYNC]\t= \"Async\",\n\t\t[BLKG_RWSTAT_DISCARD]\t= \"Discard\",\n\t};\n\tconst char *dname = blkg_dev_name(pd->blkg);\n\tu64 v;\n\tint i;\n\n\tif (!dname)\n\t\treturn 0;\n\n\tfor (i = 0; i < BLKG_RWSTAT_NR; i++)\n\t\tseq_printf(sf, \"%s %s %llu\\n\", dname, rwstr[i],\n\t\t\t   rwstat->cnt[i]);\n\n\tv = rwstat->cnt[BLKG_RWSTAT_READ] +\n\t\trwstat->cnt[BLKG_RWSTAT_WRITE] +\n\t\trwstat->cnt[BLKG_RWSTAT_DISCARD];\n\tseq_printf(sf, \"%s Total %llu\\n\", dname, v);\n\treturn v;\n}\nEXPORT_SYMBOL_GPL(__blkg_prfill_rwstat);\n\n \nu64 blkg_prfill_rwstat(struct seq_file *sf, struct blkg_policy_data *pd,\n\t\t       int off)\n{\n\tstruct blkg_rwstat_sample rwstat = { };\n\n\tblkg_rwstat_read((void *)pd + off, &rwstat);\n\treturn __blkg_prfill_rwstat(sf, pd, &rwstat);\n}\nEXPORT_SYMBOL_GPL(blkg_prfill_rwstat);\n\n \nvoid blkg_rwstat_recursive_sum(struct blkcg_gq *blkg, struct blkcg_policy *pol,\n\t\tint off, struct blkg_rwstat_sample *sum)\n{\n\tstruct blkcg_gq *pos_blkg;\n\tstruct cgroup_subsys_state *pos_css;\n\tunsigned int i;\n\n\tlockdep_assert_held(&blkg->q->queue_lock);\n\n\tmemset(sum, 0, sizeof(*sum));\n\trcu_read_lock();\n\tblkg_for_each_descendant_pre(pos_blkg, pos_css, blkg) {\n\t\tstruct blkg_rwstat *rwstat;\n\n\t\tif (!pos_blkg->online)\n\t\t\tcontinue;\n\n\t\tif (pol)\n\t\t\trwstat = (void *)blkg_to_pd(pos_blkg, pol) + off;\n\t\telse\n\t\t\trwstat = (void *)pos_blkg + off;\n\n\t\tfor (i = 0; i < BLKG_RWSTAT_NR; i++)\n\t\t\tsum->cnt[i] += blkg_rwstat_read_counter(rwstat, i);\n\t}\n\trcu_read_unlock();\n}\nEXPORT_SYMBOL_GPL(blkg_rwstat_recursive_sum);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}