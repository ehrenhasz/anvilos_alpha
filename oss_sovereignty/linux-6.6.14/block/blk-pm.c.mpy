{
  "module_name": "blk-pm.c",
  "hash_id": "72c57ec84e452363f710f69b7cf385c3d77d2da749778deff75fc777beffcddc",
  "original_prompt": "Ingested from linux-6.6.14/block/blk-pm.c",
  "human_readable_source": "\n\n#include <linux/blk-pm.h>\n#include <linux/blkdev.h>\n#include <linux/pm_runtime.h>\n#include \"blk-mq.h\"\n\n \nvoid blk_pm_runtime_init(struct request_queue *q, struct device *dev)\n{\n\tq->dev = dev;\n\tq->rpm_status = RPM_ACTIVE;\n\tpm_runtime_set_autosuspend_delay(q->dev, -1);\n\tpm_runtime_use_autosuspend(q->dev);\n}\nEXPORT_SYMBOL(blk_pm_runtime_init);\n\n \nint blk_pre_runtime_suspend(struct request_queue *q)\n{\n\tint ret = 0;\n\n\tif (!q->dev)\n\t\treturn ret;\n\n\tWARN_ON_ONCE(q->rpm_status != RPM_ACTIVE);\n\n\tspin_lock_irq(&q->queue_lock);\n\tq->rpm_status = RPM_SUSPENDING;\n\tspin_unlock_irq(&q->queue_lock);\n\n\t \n\tblk_set_pm_only(q);\n\tret = -EBUSY;\n\t \n\tblk_freeze_queue_start(q);\n\t \n\tpercpu_ref_switch_to_atomic_sync(&q->q_usage_counter);\n\tif (percpu_ref_is_zero(&q->q_usage_counter))\n\t\tret = 0;\n\t \n\tblk_mq_unfreeze_queue(q);\n\n\tif (ret < 0) {\n\t\tspin_lock_irq(&q->queue_lock);\n\t\tq->rpm_status = RPM_ACTIVE;\n\t\tpm_runtime_mark_last_busy(q->dev);\n\t\tspin_unlock_irq(&q->queue_lock);\n\n\t\tblk_clear_pm_only(q);\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL(blk_pre_runtime_suspend);\n\n \nvoid blk_post_runtime_suspend(struct request_queue *q, int err)\n{\n\tif (!q->dev)\n\t\treturn;\n\n\tspin_lock_irq(&q->queue_lock);\n\tif (!err) {\n\t\tq->rpm_status = RPM_SUSPENDED;\n\t} else {\n\t\tq->rpm_status = RPM_ACTIVE;\n\t\tpm_runtime_mark_last_busy(q->dev);\n\t}\n\tspin_unlock_irq(&q->queue_lock);\n\n\tif (err)\n\t\tblk_clear_pm_only(q);\n}\nEXPORT_SYMBOL(blk_post_runtime_suspend);\n\n \nvoid blk_pre_runtime_resume(struct request_queue *q)\n{\n\tif (!q->dev)\n\t\treturn;\n\n\tspin_lock_irq(&q->queue_lock);\n\tq->rpm_status = RPM_RESUMING;\n\tspin_unlock_irq(&q->queue_lock);\n}\nEXPORT_SYMBOL(blk_pre_runtime_resume);\n\n \nvoid blk_post_runtime_resume(struct request_queue *q)\n{\n\tblk_set_runtime_active(q);\n}\nEXPORT_SYMBOL(blk_post_runtime_resume);\n\n \nvoid blk_set_runtime_active(struct request_queue *q)\n{\n\tint old_status;\n\n\tif (!q->dev)\n\t\treturn;\n\n\tspin_lock_irq(&q->queue_lock);\n\told_status = q->rpm_status;\n\tq->rpm_status = RPM_ACTIVE;\n\tpm_runtime_mark_last_busy(q->dev);\n\tpm_request_autosuspend(q->dev);\n\tspin_unlock_irq(&q->queue_lock);\n\n\tif (old_status != RPM_ACTIVE)\n\t\tblk_clear_pm_only(q);\n}\nEXPORT_SYMBOL(blk_set_runtime_active);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}