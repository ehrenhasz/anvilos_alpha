{
  "module_name": "elevator.c",
  "hash_id": "cef8568d2ca505d2d99de4756b191ecf2c36d461842580b4a029dd33bed97634",
  "original_prompt": "Ingested from linux-6.6.14/block/elevator.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/compiler.h>\n#include <linux/blktrace_api.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/pm_runtime.h>\n\n#include <trace/events/block.h>\n\n#include \"elevator.h\"\n#include \"blk.h\"\n#include \"blk-mq-sched.h\"\n#include \"blk-pm.h\"\n#include \"blk-wbt.h\"\n#include \"blk-cgroup.h\"\n\nstatic DEFINE_SPINLOCK(elv_list_lock);\nstatic LIST_HEAD(elv_list);\n\n \n#define rq_hash_key(rq)\t\t(blk_rq_pos(rq) + blk_rq_sectors(rq))\n\n \nstatic bool elv_iosched_allow_bio_merge(struct request *rq, struct bio *bio)\n{\n\tstruct request_queue *q = rq->q;\n\tstruct elevator_queue *e = q->elevator;\n\n\tif (e->type->ops.allow_merge)\n\t\treturn e->type->ops.allow_merge(q, rq, bio);\n\n\treturn true;\n}\n\n \nbool elv_bio_merge_ok(struct request *rq, struct bio *bio)\n{\n\tif (!blk_rq_merge_ok(rq, bio))\n\t\treturn false;\n\n\tif (!elv_iosched_allow_bio_merge(rq, bio))\n\t\treturn false;\n\n\treturn true;\n}\nEXPORT_SYMBOL(elv_bio_merge_ok);\n\nstatic inline bool elv_support_features(struct request_queue *q,\n\t\tconst struct elevator_type *e)\n{\n\treturn (q->required_elevator_features & e->elevator_features) ==\n\t\tq->required_elevator_features;\n}\n\n \nstatic bool elevator_match(const struct elevator_type *e, const char *name)\n{\n\treturn !strcmp(e->elevator_name, name) ||\n\t\t(e->elevator_alias && !strcmp(e->elevator_alias, name));\n}\n\nstatic struct elevator_type *__elevator_find(const char *name)\n{\n\tstruct elevator_type *e;\n\n\tlist_for_each_entry(e, &elv_list, list)\n\t\tif (elevator_match(e, name))\n\t\t\treturn e;\n\treturn NULL;\n}\n\nstatic struct elevator_type *elevator_find_get(struct request_queue *q,\n\t\tconst char *name)\n{\n\tstruct elevator_type *e;\n\n\tspin_lock(&elv_list_lock);\n\te = __elevator_find(name);\n\tif (e && (!elv_support_features(q, e) || !elevator_tryget(e)))\n\t\te = NULL;\n\tspin_unlock(&elv_list_lock);\n\treturn e;\n}\n\nstatic const struct kobj_type elv_ktype;\n\nstruct elevator_queue *elevator_alloc(struct request_queue *q,\n\t\t\t\t  struct elevator_type *e)\n{\n\tstruct elevator_queue *eq;\n\n\teq = kzalloc_node(sizeof(*eq), GFP_KERNEL, q->node);\n\tif (unlikely(!eq))\n\t\treturn NULL;\n\n\t__elevator_get(e);\n\teq->type = e;\n\tkobject_init(&eq->kobj, &elv_ktype);\n\tmutex_init(&eq->sysfs_lock);\n\thash_init(eq->hash);\n\n\treturn eq;\n}\nEXPORT_SYMBOL(elevator_alloc);\n\nstatic void elevator_release(struct kobject *kobj)\n{\n\tstruct elevator_queue *e;\n\n\te = container_of(kobj, struct elevator_queue, kobj);\n\televator_put(e->type);\n\tkfree(e);\n}\n\nvoid elevator_exit(struct request_queue *q)\n{\n\tstruct elevator_queue *e = q->elevator;\n\n\tioc_clear_queue(q);\n\tblk_mq_sched_free_rqs(q);\n\n\tmutex_lock(&e->sysfs_lock);\n\tblk_mq_exit_sched(q, e);\n\tmutex_unlock(&e->sysfs_lock);\n\n\tkobject_put(&e->kobj);\n}\n\nstatic inline void __elv_rqhash_del(struct request *rq)\n{\n\thash_del(&rq->hash);\n\trq->rq_flags &= ~RQF_HASHED;\n}\n\nvoid elv_rqhash_del(struct request_queue *q, struct request *rq)\n{\n\tif (ELV_ON_HASH(rq))\n\t\t__elv_rqhash_del(rq);\n}\nEXPORT_SYMBOL_GPL(elv_rqhash_del);\n\nvoid elv_rqhash_add(struct request_queue *q, struct request *rq)\n{\n\tstruct elevator_queue *e = q->elevator;\n\n\tBUG_ON(ELV_ON_HASH(rq));\n\thash_add(e->hash, &rq->hash, rq_hash_key(rq));\n\trq->rq_flags |= RQF_HASHED;\n}\nEXPORT_SYMBOL_GPL(elv_rqhash_add);\n\nvoid elv_rqhash_reposition(struct request_queue *q, struct request *rq)\n{\n\t__elv_rqhash_del(rq);\n\telv_rqhash_add(q, rq);\n}\n\nstruct request *elv_rqhash_find(struct request_queue *q, sector_t offset)\n{\n\tstruct elevator_queue *e = q->elevator;\n\tstruct hlist_node *next;\n\tstruct request *rq;\n\n\thash_for_each_possible_safe(e->hash, rq, next, hash, offset) {\n\t\tBUG_ON(!ELV_ON_HASH(rq));\n\n\t\tif (unlikely(!rq_mergeable(rq))) {\n\t\t\t__elv_rqhash_del(rq);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (rq_hash_key(rq) == offset)\n\t\t\treturn rq;\n\t}\n\n\treturn NULL;\n}\n\n \nvoid elv_rb_add(struct rb_root *root, struct request *rq)\n{\n\tstruct rb_node **p = &root->rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct request *__rq;\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\t__rq = rb_entry(parent, struct request, rb_node);\n\n\t\tif (blk_rq_pos(rq) < blk_rq_pos(__rq))\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (blk_rq_pos(rq) >= blk_rq_pos(__rq))\n\t\t\tp = &(*p)->rb_right;\n\t}\n\n\trb_link_node(&rq->rb_node, parent, p);\n\trb_insert_color(&rq->rb_node, root);\n}\nEXPORT_SYMBOL(elv_rb_add);\n\nvoid elv_rb_del(struct rb_root *root, struct request *rq)\n{\n\tBUG_ON(RB_EMPTY_NODE(&rq->rb_node));\n\trb_erase(&rq->rb_node, root);\n\tRB_CLEAR_NODE(&rq->rb_node);\n}\nEXPORT_SYMBOL(elv_rb_del);\n\nstruct request *elv_rb_find(struct rb_root *root, sector_t sector)\n{\n\tstruct rb_node *n = root->rb_node;\n\tstruct request *rq;\n\n\twhile (n) {\n\t\trq = rb_entry(n, struct request, rb_node);\n\n\t\tif (sector < blk_rq_pos(rq))\n\t\t\tn = n->rb_left;\n\t\telse if (sector > blk_rq_pos(rq))\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\treturn rq;\n\t}\n\n\treturn NULL;\n}\nEXPORT_SYMBOL(elv_rb_find);\n\nenum elv_merge elv_merge(struct request_queue *q, struct request **req,\n\t\tstruct bio *bio)\n{\n\tstruct elevator_queue *e = q->elevator;\n\tstruct request *__rq;\n\n\t \n\tif (blk_queue_nomerges(q) || !bio_mergeable(bio))\n\t\treturn ELEVATOR_NO_MERGE;\n\n\t \n\tif (q->last_merge && elv_bio_merge_ok(q->last_merge, bio)) {\n\t\tenum elv_merge ret = blk_try_merge(q->last_merge, bio);\n\n\t\tif (ret != ELEVATOR_NO_MERGE) {\n\t\t\t*req = q->last_merge;\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (blk_queue_noxmerges(q))\n\t\treturn ELEVATOR_NO_MERGE;\n\n\t \n\t__rq = elv_rqhash_find(q, bio->bi_iter.bi_sector);\n\tif (__rq && elv_bio_merge_ok(__rq, bio)) {\n\t\t*req = __rq;\n\n\t\tif (blk_discard_mergable(__rq))\n\t\t\treturn ELEVATOR_DISCARD_MERGE;\n\t\treturn ELEVATOR_BACK_MERGE;\n\t}\n\n\tif (e->type->ops.request_merge)\n\t\treturn e->type->ops.request_merge(q, req, bio);\n\n\treturn ELEVATOR_NO_MERGE;\n}\n\n \nbool elv_attempt_insert_merge(struct request_queue *q, struct request *rq,\n\t\t\t      struct list_head *free)\n{\n\tstruct request *__rq;\n\tbool ret;\n\n\tif (blk_queue_nomerges(q))\n\t\treturn false;\n\n\t \n\tif (q->last_merge && blk_attempt_req_merge(q, q->last_merge, rq)) {\n\t\tlist_add(&rq->queuelist, free);\n\t\treturn true;\n\t}\n\n\tif (blk_queue_noxmerges(q))\n\t\treturn false;\n\n\tret = false;\n\t \n\twhile (1) {\n\t\t__rq = elv_rqhash_find(q, blk_rq_pos(rq));\n\t\tif (!__rq || !blk_attempt_req_merge(q, __rq, rq))\n\t\t\tbreak;\n\n\t\tlist_add(&rq->queuelist, free);\n\t\t \n\t\tret = true;\n\t\trq = __rq;\n\t}\n\n\treturn ret;\n}\n\nvoid elv_merged_request(struct request_queue *q, struct request *rq,\n\t\tenum elv_merge type)\n{\n\tstruct elevator_queue *e = q->elevator;\n\n\tif (e->type->ops.request_merged)\n\t\te->type->ops.request_merged(q, rq, type);\n\n\tif (type == ELEVATOR_BACK_MERGE)\n\t\telv_rqhash_reposition(q, rq);\n\n\tq->last_merge = rq;\n}\n\nvoid elv_merge_requests(struct request_queue *q, struct request *rq,\n\t\t\t     struct request *next)\n{\n\tstruct elevator_queue *e = q->elevator;\n\n\tif (e->type->ops.requests_merged)\n\t\te->type->ops.requests_merged(q, rq, next);\n\n\telv_rqhash_reposition(q, rq);\n\tq->last_merge = rq;\n}\n\nstruct request *elv_latter_request(struct request_queue *q, struct request *rq)\n{\n\tstruct elevator_queue *e = q->elevator;\n\n\tif (e->type->ops.next_request)\n\t\treturn e->type->ops.next_request(q, rq);\n\n\treturn NULL;\n}\n\nstruct request *elv_former_request(struct request_queue *q, struct request *rq)\n{\n\tstruct elevator_queue *e = q->elevator;\n\n\tif (e->type->ops.former_request)\n\t\treturn e->type->ops.former_request(q, rq);\n\n\treturn NULL;\n}\n\n#define to_elv(atr) container_of((atr), struct elv_fs_entry, attr)\n\nstatic ssize_t\nelv_attr_show(struct kobject *kobj, struct attribute *attr, char *page)\n{\n\tstruct elv_fs_entry *entry = to_elv(attr);\n\tstruct elevator_queue *e;\n\tssize_t error;\n\n\tif (!entry->show)\n\t\treturn -EIO;\n\n\te = container_of(kobj, struct elevator_queue, kobj);\n\tmutex_lock(&e->sysfs_lock);\n\terror = e->type ? entry->show(e, page) : -ENOENT;\n\tmutex_unlock(&e->sysfs_lock);\n\treturn error;\n}\n\nstatic ssize_t\nelv_attr_store(struct kobject *kobj, struct attribute *attr,\n\t       const char *page, size_t length)\n{\n\tstruct elv_fs_entry *entry = to_elv(attr);\n\tstruct elevator_queue *e;\n\tssize_t error;\n\n\tif (!entry->store)\n\t\treturn -EIO;\n\n\te = container_of(kobj, struct elevator_queue, kobj);\n\tmutex_lock(&e->sysfs_lock);\n\terror = e->type ? entry->store(e, page, length) : -ENOENT;\n\tmutex_unlock(&e->sysfs_lock);\n\treturn error;\n}\n\nstatic const struct sysfs_ops elv_sysfs_ops = {\n\t.show\t= elv_attr_show,\n\t.store\t= elv_attr_store,\n};\n\nstatic const struct kobj_type elv_ktype = {\n\t.sysfs_ops\t= &elv_sysfs_ops,\n\t.release\t= elevator_release,\n};\n\nint elv_register_queue(struct request_queue *q, bool uevent)\n{\n\tstruct elevator_queue *e = q->elevator;\n\tint error;\n\n\tlockdep_assert_held(&q->sysfs_lock);\n\n\terror = kobject_add(&e->kobj, &q->disk->queue_kobj, \"iosched\");\n\tif (!error) {\n\t\tstruct elv_fs_entry *attr = e->type->elevator_attrs;\n\t\tif (attr) {\n\t\t\twhile (attr->attr.name) {\n\t\t\t\tif (sysfs_create_file(&e->kobj, &attr->attr))\n\t\t\t\t\tbreak;\n\t\t\t\tattr++;\n\t\t\t}\n\t\t}\n\t\tif (uevent)\n\t\t\tkobject_uevent(&e->kobj, KOBJ_ADD);\n\n\t\tset_bit(ELEVATOR_FLAG_REGISTERED, &e->flags);\n\t}\n\treturn error;\n}\n\nvoid elv_unregister_queue(struct request_queue *q)\n{\n\tstruct elevator_queue *e = q->elevator;\n\n\tlockdep_assert_held(&q->sysfs_lock);\n\n\tif (e && test_and_clear_bit(ELEVATOR_FLAG_REGISTERED, &e->flags)) {\n\t\tkobject_uevent(&e->kobj, KOBJ_REMOVE);\n\t\tkobject_del(&e->kobj);\n\t}\n}\n\nint elv_register(struct elevator_type *e)\n{\n\t \n\tif (WARN_ON_ONCE(!e->ops.finish_request))\n\t\treturn -EINVAL;\n\t \n\tif (WARN_ON_ONCE(!e->ops.insert_requests || !e->ops.dispatch_request))\n\t\treturn -EINVAL;\n\n\t \n\tif (e->icq_size) {\n\t\tif (WARN_ON(e->icq_size < sizeof(struct io_cq)) ||\n\t\t    WARN_ON(e->icq_align < __alignof__(struct io_cq)))\n\t\t\treturn -EINVAL;\n\n\t\tsnprintf(e->icq_cache_name, sizeof(e->icq_cache_name),\n\t\t\t \"%s_io_cq\", e->elevator_name);\n\t\te->icq_cache = kmem_cache_create(e->icq_cache_name, e->icq_size,\n\t\t\t\t\t\t e->icq_align, 0, NULL);\n\t\tif (!e->icq_cache)\n\t\t\treturn -ENOMEM;\n\t}\n\n\t \n\tspin_lock(&elv_list_lock);\n\tif (__elevator_find(e->elevator_name)) {\n\t\tspin_unlock(&elv_list_lock);\n\t\tkmem_cache_destroy(e->icq_cache);\n\t\treturn -EBUSY;\n\t}\n\tlist_add_tail(&e->list, &elv_list);\n\tspin_unlock(&elv_list_lock);\n\n\tprintk(KERN_INFO \"io scheduler %s registered\\n\", e->elevator_name);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(elv_register);\n\nvoid elv_unregister(struct elevator_type *e)\n{\n\t \n\tspin_lock(&elv_list_lock);\n\tlist_del_init(&e->list);\n\tspin_unlock(&elv_list_lock);\n\n\t \n\tif (e->icq_cache) {\n\t\trcu_barrier();\n\t\tkmem_cache_destroy(e->icq_cache);\n\t\te->icq_cache = NULL;\n\t}\n}\nEXPORT_SYMBOL_GPL(elv_unregister);\n\nstatic inline bool elv_support_iosched(struct request_queue *q)\n{\n\tif (!queue_is_mq(q) ||\n\t    (q->tag_set && (q->tag_set->flags & BLK_MQ_F_NO_SCHED)))\n\t\treturn false;\n\treturn true;\n}\n\n \nstatic struct elevator_type *elevator_get_default(struct request_queue *q)\n{\n\tif (q->tag_set && q->tag_set->flags & BLK_MQ_F_NO_SCHED_BY_DEFAULT)\n\t\treturn NULL;\n\n\tif (q->nr_hw_queues != 1 &&\n\t    !blk_mq_is_shared_tags(q->tag_set->flags))\n\t\treturn NULL;\n\n\treturn elevator_find_get(q, \"mq-deadline\");\n}\n\n \nstatic struct elevator_type *elevator_get_by_features(struct request_queue *q)\n{\n\tstruct elevator_type *e, *found = NULL;\n\n\tspin_lock(&elv_list_lock);\n\n\tlist_for_each_entry(e, &elv_list, list) {\n\t\tif (elv_support_features(q, e)) {\n\t\t\tfound = e;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (found && !elevator_tryget(found))\n\t\tfound = NULL;\n\n\tspin_unlock(&elv_list_lock);\n\treturn found;\n}\n\n \nvoid elevator_init_mq(struct request_queue *q)\n{\n\tstruct elevator_type *e;\n\tint err;\n\n\tif (!elv_support_iosched(q))\n\t\treturn;\n\n\tWARN_ON_ONCE(blk_queue_registered(q));\n\n\tif (unlikely(q->elevator))\n\t\treturn;\n\n\tif (!q->required_elevator_features)\n\t\te = elevator_get_default(q);\n\telse\n\t\te = elevator_get_by_features(q);\n\tif (!e)\n\t\treturn;\n\n\t \n\tblk_mq_freeze_queue(q);\n\tblk_mq_cancel_work_sync(q);\n\n\terr = blk_mq_init_sched(q, e);\n\n\tblk_mq_unfreeze_queue(q);\n\n\tif (err) {\n\t\tpr_warn(\"\\\"%s\\\" elevator initialization failed, \"\n\t\t\t\"falling back to \\\"none\\\"\\n\", e->elevator_name);\n\t}\n\n\televator_put(e);\n}\n\n \nint elevator_switch(struct request_queue *q, struct elevator_type *new_e)\n{\n\tint ret;\n\n\tlockdep_assert_held(&q->sysfs_lock);\n\n\tblk_mq_freeze_queue(q);\n\tblk_mq_quiesce_queue(q);\n\n\tif (q->elevator) {\n\t\telv_unregister_queue(q);\n\t\televator_exit(q);\n\t}\n\n\tret = blk_mq_init_sched(q, new_e);\n\tif (ret)\n\t\tgoto out_unfreeze;\n\n\tret = elv_register_queue(q, true);\n\tif (ret) {\n\t\televator_exit(q);\n\t\tgoto out_unfreeze;\n\t}\n\tblk_add_trace_msg(q, \"elv switch: %s\", new_e->elevator_name);\n\nout_unfreeze:\n\tblk_mq_unquiesce_queue(q);\n\tblk_mq_unfreeze_queue(q);\n\n\tif (ret) {\n\t\tpr_warn(\"elv: switch to \\\"%s\\\" failed, falling back to \\\"none\\\"\\n\",\n\t\t\tnew_e->elevator_name);\n\t}\n\n\treturn ret;\n}\n\nvoid elevator_disable(struct request_queue *q)\n{\n\tlockdep_assert_held(&q->sysfs_lock);\n\n\tblk_mq_freeze_queue(q);\n\tblk_mq_quiesce_queue(q);\n\n\telv_unregister_queue(q);\n\televator_exit(q);\n\tblk_queue_flag_clear(QUEUE_FLAG_SQ_SCHED, q);\n\tq->elevator = NULL;\n\tq->nr_requests = q->tag_set->queue_depth;\n\tblk_add_trace_msg(q, \"elv switch: none\");\n\n\tblk_mq_unquiesce_queue(q);\n\tblk_mq_unfreeze_queue(q);\n}\n\n \nstatic int elevator_change(struct request_queue *q, const char *elevator_name)\n{\n\tstruct elevator_type *e;\n\tint ret;\n\n\t \n\tif (!blk_queue_registered(q))\n\t\treturn -ENOENT;\n\n\tif (!strncmp(elevator_name, \"none\", 4)) {\n\t\tif (q->elevator)\n\t\t\televator_disable(q);\n\t\treturn 0;\n\t}\n\n\tif (q->elevator && elevator_match(q->elevator->type, elevator_name))\n\t\treturn 0;\n\n\te = elevator_find_get(q, elevator_name);\n\tif (!e) {\n\t\trequest_module(\"%s-iosched\", elevator_name);\n\t\te = elevator_find_get(q, elevator_name);\n\t\tif (!e)\n\t\t\treturn -EINVAL;\n\t}\n\tret = elevator_switch(q, e);\n\televator_put(e);\n\treturn ret;\n}\n\nssize_t elv_iosched_store(struct request_queue *q, const char *buf,\n\t\t\t  size_t count)\n{\n\tchar elevator_name[ELV_NAME_MAX];\n\tint ret;\n\n\tif (!elv_support_iosched(q))\n\t\treturn count;\n\n\tstrscpy(elevator_name, buf, sizeof(elevator_name));\n\tret = elevator_change(q, strstrip(elevator_name));\n\tif (!ret)\n\t\treturn count;\n\treturn ret;\n}\n\nssize_t elv_iosched_show(struct request_queue *q, char *name)\n{\n\tstruct elevator_queue *eq = q->elevator;\n\tstruct elevator_type *cur = NULL, *e;\n\tint len = 0;\n\n\tif (!elv_support_iosched(q))\n\t\treturn sprintf(name, \"none\\n\");\n\n\tif (!q->elevator) {\n\t\tlen += sprintf(name+len, \"[none] \");\n\t} else {\n\t\tlen += sprintf(name+len, \"none \");\n\t\tcur = eq->type;\n\t}\n\n\tspin_lock(&elv_list_lock);\n\tlist_for_each_entry(e, &elv_list, list) {\n\t\tif (e == cur)\n\t\t\tlen += sprintf(name+len, \"[%s] \", e->elevator_name);\n\t\telse if (elv_support_features(q, e))\n\t\t\tlen += sprintf(name+len, \"%s \", e->elevator_name);\n\t}\n\tspin_unlock(&elv_list_lock);\n\n\tlen += sprintf(name+len, \"\\n\");\n\treturn len;\n}\n\nstruct request *elv_rb_former_request(struct request_queue *q,\n\t\t\t\t      struct request *rq)\n{\n\tstruct rb_node *rbprev = rb_prev(&rq->rb_node);\n\n\tif (rbprev)\n\t\treturn rb_entry_rq(rbprev);\n\n\treturn NULL;\n}\nEXPORT_SYMBOL(elv_rb_former_request);\n\nstruct request *elv_rb_latter_request(struct request_queue *q,\n\t\t\t\t      struct request *rq)\n{\n\tstruct rb_node *rbnext = rb_next(&rq->rb_node);\n\n\tif (rbnext)\n\t\treturn rb_entry_rq(rbnext);\n\n\treturn NULL;\n}\nEXPORT_SYMBOL(elv_rb_latter_request);\n\nstatic int __init elevator_setup(char *str)\n{\n\tpr_warn(\"Kernel parameter elevator= does not have any effect anymore.\\n\"\n\t\t\"Please use sysfs to set IO scheduler for individual devices.\\n\");\n\treturn 1;\n}\n\n__setup(\"elevator=\", elevator_setup);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}