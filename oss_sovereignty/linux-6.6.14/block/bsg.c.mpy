{
  "module_name": "bsg.c",
  "hash_id": "3fa25caffe975953c6d7b523c6f0c9253cca941e0ceb7d670d470f7db1ed753d",
  "original_prompt": "Ingested from linux-6.6.14/block/bsg.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/cdev.h>\n#include <linux/jiffies.h>\n#include <linux/percpu.h>\n#include <linux/idr.h>\n#include <linux/bsg.h>\n#include <linux/slab.h>\n\n#include <scsi/scsi.h>\n#include <scsi/scsi_ioctl.h>\n#include <scsi/sg.h>\n\n#define BSG_DESCRIPTION\t\"Block layer SCSI generic (bsg) driver\"\n#define BSG_VERSION\t\"0.4\"\n\nstruct bsg_device {\n\tstruct request_queue *queue;\n\tstruct device device;\n\tstruct cdev cdev;\n\tint max_queue;\n\tunsigned int timeout;\n\tunsigned int reserved_size;\n\tbsg_sg_io_fn *sg_io_fn;\n};\n\nstatic inline struct bsg_device *to_bsg_device(struct inode *inode)\n{\n\treturn container_of(inode->i_cdev, struct bsg_device, cdev);\n}\n\n#define BSG_DEFAULT_CMDS\t64\n#define BSG_MAX_DEVS\t\t(1 << MINORBITS)\n\nstatic DEFINE_IDA(bsg_minor_ida);\nstatic const struct class bsg_class;\nstatic int bsg_major;\n\nstatic unsigned int bsg_timeout(struct bsg_device *bd, struct sg_io_v4 *hdr)\n{\n\tunsigned int timeout = BLK_DEFAULT_SG_TIMEOUT;\n\n\tif (hdr->timeout)\n\t\ttimeout = msecs_to_jiffies(hdr->timeout);\n\telse if (bd->timeout)\n\t\ttimeout = bd->timeout;\n\n\treturn max_t(unsigned int, timeout, BLK_MIN_SG_TIMEOUT);\n}\n\nstatic int bsg_sg_io(struct bsg_device *bd, bool open_for_write,\n\t\t     void __user *uarg)\n{\n\tstruct sg_io_v4 hdr;\n\tint ret;\n\n\tif (copy_from_user(&hdr, uarg, sizeof(hdr)))\n\t\treturn -EFAULT;\n\tif (hdr.guard != 'Q')\n\t\treturn -EINVAL;\n\tret = bd->sg_io_fn(bd->queue, &hdr, open_for_write,\n\t\t\t   bsg_timeout(bd, &hdr));\n\tif (!ret && copy_to_user(uarg, &hdr, sizeof(hdr)))\n\t\treturn -EFAULT;\n\treturn ret;\n}\n\nstatic int bsg_open(struct inode *inode, struct file *file)\n{\n\tif (!blk_get_queue(to_bsg_device(inode)->queue))\n\t\treturn -ENXIO;\n\treturn 0;\n}\n\nstatic int bsg_release(struct inode *inode, struct file *file)\n{\n\tblk_put_queue(to_bsg_device(inode)->queue);\n\treturn 0;\n}\n\nstatic int bsg_get_command_q(struct bsg_device *bd, int __user *uarg)\n{\n\treturn put_user(READ_ONCE(bd->max_queue), uarg);\n}\n\nstatic int bsg_set_command_q(struct bsg_device *bd, int __user *uarg)\n{\n\tint max_queue;\n\n\tif (get_user(max_queue, uarg))\n\t\treturn -EFAULT;\n\tif (max_queue < 1)\n\t\treturn -EINVAL;\n\tWRITE_ONCE(bd->max_queue, max_queue);\n\treturn 0;\n}\n\nstatic long bsg_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tstruct bsg_device *bd = to_bsg_device(file_inode(file));\n\tstruct request_queue *q = bd->queue;\n\tvoid __user *uarg = (void __user *) arg;\n\tint __user *intp = uarg;\n\tint val;\n\n\tswitch (cmd) {\n\t \n\tcase SG_GET_COMMAND_Q:\n\t\treturn bsg_get_command_q(bd, uarg);\n\tcase SG_SET_COMMAND_Q:\n\t\treturn bsg_set_command_q(bd, uarg);\n\n\t \n\tcase SG_GET_VERSION_NUM:\n\t\treturn put_user(30527, intp);\n\tcase SCSI_IOCTL_GET_IDLUN:\n\t\treturn put_user(0, intp);\n\tcase SCSI_IOCTL_GET_BUS_NUMBER:\n\t\treturn put_user(0, intp);\n\tcase SG_SET_TIMEOUT:\n\t\tif (get_user(val, intp))\n\t\t\treturn -EFAULT;\n\t\tbd->timeout = clock_t_to_jiffies(val);\n\t\treturn 0;\n\tcase SG_GET_TIMEOUT:\n\t\treturn jiffies_to_clock_t(bd->timeout);\n\tcase SG_GET_RESERVED_SIZE:\n\t\treturn put_user(min(bd->reserved_size, queue_max_bytes(q)),\n\t\t\t\tintp);\n\tcase SG_SET_RESERVED_SIZE:\n\t\tif (get_user(val, intp))\n\t\t\treturn -EFAULT;\n\t\tif (val < 0)\n\t\t\treturn -EINVAL;\n\t\tbd->reserved_size =\n\t\t\tmin_t(unsigned int, val, queue_max_bytes(q));\n\t\treturn 0;\n\tcase SG_EMULATED_HOST:\n\t\treturn put_user(1, intp);\n\tcase SG_IO:\n\t\treturn bsg_sg_io(bd, file->f_mode & FMODE_WRITE, uarg);\n\tcase SCSI_IOCTL_SEND_COMMAND:\n\t\tpr_warn_ratelimited(\"%s: calling unsupported SCSI_IOCTL_SEND_COMMAND\\n\",\n\t\t\t\tcurrent->comm);\n\t\treturn -EINVAL;\n\tdefault:\n\t\treturn -ENOTTY;\n\t}\n}\n\nstatic const struct file_operations bsg_fops = {\n\t.open\t\t=\tbsg_open,\n\t.release\t=\tbsg_release,\n\t.unlocked_ioctl\t=\tbsg_ioctl,\n\t.compat_ioctl\t=\tcompat_ptr_ioctl,\n\t.owner\t\t=\tTHIS_MODULE,\n\t.llseek\t\t=\tdefault_llseek,\n};\n\nstatic void bsg_device_release(struct device *dev)\n{\n\tstruct bsg_device *bd = container_of(dev, struct bsg_device, device);\n\n\tida_free(&bsg_minor_ida, MINOR(bd->device.devt));\n\tkfree(bd);\n}\n\nvoid bsg_unregister_queue(struct bsg_device *bd)\n{\n\tstruct gendisk *disk = bd->queue->disk;\n\n\tif (disk && disk->queue_kobj.sd)\n\t\tsysfs_remove_link(&disk->queue_kobj, \"bsg\");\n\tcdev_device_del(&bd->cdev, &bd->device);\n\tput_device(&bd->device);\n}\nEXPORT_SYMBOL_GPL(bsg_unregister_queue);\n\nstruct bsg_device *bsg_register_queue(struct request_queue *q,\n\t\tstruct device *parent, const char *name, bsg_sg_io_fn *sg_io_fn)\n{\n\tstruct bsg_device *bd;\n\tint ret;\n\n\tbd = kzalloc(sizeof(*bd), GFP_KERNEL);\n\tif (!bd)\n\t\treturn ERR_PTR(-ENOMEM);\n\tbd->max_queue = BSG_DEFAULT_CMDS;\n\tbd->reserved_size = INT_MAX;\n\tbd->queue = q;\n\tbd->sg_io_fn = sg_io_fn;\n\n\tret = ida_alloc_max(&bsg_minor_ida, BSG_MAX_DEVS - 1, GFP_KERNEL);\n\tif (ret < 0) {\n\t\tif (ret == -ENOSPC)\n\t\t\tdev_err(parent, \"bsg: too many bsg devices\\n\");\n\t\tkfree(bd);\n\t\treturn ERR_PTR(ret);\n\t}\n\tbd->device.devt = MKDEV(bsg_major, ret);\n\tbd->device.class = &bsg_class;\n\tbd->device.parent = parent;\n\tbd->device.release = bsg_device_release;\n\tdev_set_name(&bd->device, \"%s\", name);\n\tdevice_initialize(&bd->device);\n\n\tcdev_init(&bd->cdev, &bsg_fops);\n\tbd->cdev.owner = THIS_MODULE;\n\tret = cdev_device_add(&bd->cdev, &bd->device);\n\tif (ret)\n\t\tgoto out_put_device;\n\n\tif (q->disk && q->disk->queue_kobj.sd) {\n\t\tret = sysfs_create_link(&q->disk->queue_kobj, &bd->device.kobj,\n\t\t\t\t\t\"bsg\");\n\t\tif (ret)\n\t\t\tgoto out_device_del;\n\t}\n\n\treturn bd;\n\nout_device_del:\n\tcdev_device_del(&bd->cdev, &bd->device);\nout_put_device:\n\tput_device(&bd->device);\n\treturn ERR_PTR(ret);\n}\nEXPORT_SYMBOL_GPL(bsg_register_queue);\n\nstatic char *bsg_devnode(const struct device *dev, umode_t *mode)\n{\n\treturn kasprintf(GFP_KERNEL, \"bsg/%s\", dev_name(dev));\n}\n\nstatic const struct class bsg_class = {\n\t.name\t\t= \"bsg\",\n\t.devnode\t= bsg_devnode,\n};\n\nstatic int __init bsg_init(void)\n{\n\tdev_t devid;\n\tint ret;\n\n\tret = class_register(&bsg_class);\n\tif (ret)\n\t\treturn ret;\n\n\tret = alloc_chrdev_region(&devid, 0, BSG_MAX_DEVS, \"bsg\");\n\tif (ret)\n\t\tgoto destroy_bsg_class;\n\tbsg_major = MAJOR(devid);\n\n\tprintk(KERN_INFO BSG_DESCRIPTION \" version \" BSG_VERSION\n\t       \" loaded (major %d)\\n\", bsg_major);\n\treturn 0;\n\ndestroy_bsg_class:\n\tclass_unregister(&bsg_class);\n\treturn ret;\n}\n\nMODULE_AUTHOR(\"Jens Axboe\");\nMODULE_DESCRIPTION(BSG_DESCRIPTION);\nMODULE_LICENSE(\"GPL\");\n\ndevice_initcall(bsg_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}