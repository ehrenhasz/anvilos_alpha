{
  "module_name": "early-lookup.c",
  "hash_id": "7f82c326de0fb6f402ca8d1325939784cadcbeda9de9d7343e7d7f1d057ec7e7",
  "original_prompt": "Ingested from linux-6.6.14/block/early-lookup.c",
  "human_readable_source": "\n \n#include <linux/blkdev.h>\n#include <linux/ctype.h>\n\nstruct uuidcmp {\n\tconst char *uuid;\n\tint len;\n};\n\n \nstatic int __init match_dev_by_uuid(struct device *dev, const void *data)\n{\n\tstruct block_device *bdev = dev_to_bdev(dev);\n\tconst struct uuidcmp *cmp = data;\n\n\tif (!bdev->bd_meta_info ||\n\t    strncasecmp(cmp->uuid, bdev->bd_meta_info->uuid, cmp->len))\n\t\treturn 0;\n\treturn 1;\n}\n\n \nstatic int __init devt_from_partuuid(const char *uuid_str, dev_t *devt)\n{\n\tstruct uuidcmp cmp;\n\tstruct device *dev = NULL;\n\tint offset = 0;\n\tchar *slash;\n\n\tcmp.uuid = uuid_str;\n\n\tslash = strchr(uuid_str, '/');\n\t \n\tif (slash) {\n\t\tchar c = 0;\n\n\t\t \n\t\tif (sscanf(slash + 1, \"PARTNROFF=%d%c\", &offset, &c) != 1)\n\t\t\tgoto out_invalid;\n\t\tcmp.len = slash - uuid_str;\n\t} else {\n\t\tcmp.len = strlen(uuid_str);\n\t}\n\n\tif (!cmp.len)\n\t\tgoto out_invalid;\n\n\tdev = class_find_device(&block_class, NULL, &cmp, &match_dev_by_uuid);\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\tif (offset) {\n\t\t \n\t\t*devt = part_devt(dev_to_disk(dev),\n\t\t\t\t  dev_to_bdev(dev)->bd_partno + offset);\n\t} else {\n\t\t*devt = dev->devt;\n\t}\n\n\tput_device(dev);\n\treturn 0;\n\nout_invalid:\n\tpr_err(\"VFS: PARTUUID= is invalid.\\n\"\n\t       \"Expected PARTUUID=<valid-uuid-id>[/PARTNROFF=%%d]\\n\");\n\treturn -EINVAL;\n}\n\n \nstatic int __init match_dev_by_label(struct device *dev, const void *data)\n{\n\tstruct block_device *bdev = dev_to_bdev(dev);\n\tconst char *label = data;\n\n\tif (!bdev->bd_meta_info || strcmp(label, bdev->bd_meta_info->volname))\n\t\treturn 0;\n\treturn 1;\n}\n\nstatic int __init devt_from_partlabel(const char *label, dev_t *devt)\n{\n\tstruct device *dev;\n\n\tdev = class_find_device(&block_class, NULL, label, &match_dev_by_label);\n\tif (!dev)\n\t\treturn -ENODEV;\n\t*devt = dev->devt;\n\tput_device(dev);\n\treturn 0;\n}\n\nstatic dev_t __init blk_lookup_devt(const char *name, int partno)\n{\n\tdev_t devt = MKDEV(0, 0);\n\tstruct class_dev_iter iter;\n\tstruct device *dev;\n\n\tclass_dev_iter_init(&iter, &block_class, NULL, &disk_type);\n\twhile ((dev = class_dev_iter_next(&iter))) {\n\t\tstruct gendisk *disk = dev_to_disk(dev);\n\n\t\tif (strcmp(dev_name(dev), name))\n\t\t\tcontinue;\n\n\t\tif (partno < disk->minors) {\n\t\t\t \n\t\t\tdevt = MKDEV(MAJOR(dev->devt),\n\t\t\t\t     MINOR(dev->devt) + partno);\n\t\t} else {\n\t\t\tdevt = part_devt(disk, partno);\n\t\t\tif (devt)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tclass_dev_iter_exit(&iter);\n\treturn devt;\n}\n\nstatic int __init devt_from_devname(const char *name, dev_t *devt)\n{\n\tint part;\n\tchar s[32];\n\tchar *p;\n\n\tif (strlen(name) > 31)\n\t\treturn -EINVAL;\n\tstrcpy(s, name);\n\tfor (p = s; *p; p++) {\n\t\tif (*p == '/')\n\t\t\t*p = '!';\n\t}\n\n\t*devt = blk_lookup_devt(s, 0);\n\tif (*devt)\n\t\treturn 0;\n\n\t \n\twhile (p > s && isdigit(p[-1]))\n\t\tp--;\n\tif (p == s || !*p || *p == '0')\n\t\treturn -ENODEV;\n\n\t \n\tpart = simple_strtoul(p, NULL, 10);\n\t*p = '\\0';\n\t*devt = blk_lookup_devt(s, part);\n\tif (*devt)\n\t\treturn 0;\n\n\t \n\tif (p < s + 2 || !isdigit(p[-2]) || p[-1] != 'p')\n\t\treturn -ENODEV;\n\tp[-1] = '\\0';\n\t*devt = blk_lookup_devt(s, part);\n\tif (*devt)\n\t\treturn 0;\n\treturn -ENODEV;\n}\n\nstatic int __init devt_from_devnum(const char *name, dev_t *devt)\n{\n\tunsigned maj, min, offset;\n\tchar *p, dummy;\n\n\tif (sscanf(name, \"%u:%u%c\", &maj, &min, &dummy) == 2 ||\n\t    sscanf(name, \"%u:%u:%u:%c\", &maj, &min, &offset, &dummy) == 3) {\n\t\t*devt = MKDEV(maj, min);\n\t\tif (maj != MAJOR(*devt) || min != MINOR(*devt))\n\t\t\treturn -EINVAL;\n\t} else {\n\t\t*devt = new_decode_dev(simple_strtoul(name, &p, 16));\n\t\tif (*p)\n\t\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \nint __init early_lookup_bdev(const char *name, dev_t *devt)\n{\n\tif (strncmp(name, \"PARTUUID=\", 9) == 0)\n\t\treturn devt_from_partuuid(name + 9, devt);\n\tif (strncmp(name, \"PARTLABEL=\", 10) == 0)\n\t\treturn devt_from_partlabel(name + 10, devt);\n\tif (strncmp(name, \"/dev/\", 5) == 0)\n\t\treturn devt_from_devname(name + 5, devt);\n\treturn devt_from_devnum(name, devt);\n}\n\nstatic char __init *bdevt_str(dev_t devt, char *buf)\n{\n\tif (MAJOR(devt) <= 0xff && MINOR(devt) <= 0xff) {\n\t\tchar tbuf[BDEVT_SIZE];\n\t\tsnprintf(tbuf, BDEVT_SIZE, \"%02x%02x\", MAJOR(devt), MINOR(devt));\n\t\tsnprintf(buf, BDEVT_SIZE, \"%-9s\", tbuf);\n\t} else\n\t\tsnprintf(buf, BDEVT_SIZE, \"%03x:%05x\", MAJOR(devt), MINOR(devt));\n\n\treturn buf;\n}\n\n \nvoid __init printk_all_partitions(void)\n{\n\tstruct class_dev_iter iter;\n\tstruct device *dev;\n\n\tclass_dev_iter_init(&iter, &block_class, NULL, &disk_type);\n\twhile ((dev = class_dev_iter_next(&iter))) {\n\t\tstruct gendisk *disk = dev_to_disk(dev);\n\t\tstruct block_device *part;\n\t\tchar devt_buf[BDEVT_SIZE];\n\t\tunsigned long idx;\n\n\t\t \n\t\tif (get_capacity(disk) == 0 || (disk->flags & GENHD_FL_HIDDEN))\n\t\t\tcontinue;\n\n\t\t \n\t\trcu_read_lock();\n\t\txa_for_each(&disk->part_tbl, idx, part) {\n\t\t\tif (!bdev_nr_sectors(part))\n\t\t\t\tcontinue;\n\t\t\tprintk(\"%s%s %10llu %pg %s\",\n\t\t\t       bdev_is_partition(part) ? \"  \" : \"\",\n\t\t\t       bdevt_str(part->bd_dev, devt_buf),\n\t\t\t       bdev_nr_sectors(part) >> 1, part,\n\t\t\t       part->bd_meta_info ?\n\t\t\t\t\tpart->bd_meta_info->uuid : \"\");\n\t\t\tif (bdev_is_partition(part))\n\t\t\t\tprintk(\"\\n\");\n\t\t\telse if (dev->parent && dev->parent->driver)\n\t\t\t\tprintk(\" driver: %s\\n\",\n\t\t\t\t\tdev->parent->driver->name);\n\t\t\telse\n\t\t\t\tprintk(\" (driver?)\\n\");\n\t\t}\n\t\trcu_read_unlock();\n\t}\n\tclass_dev_iter_exit(&iter);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}