{
  "module_name": "genhd.c",
  "hash_id": "51946be706ffb9424bb3a517a4e0f3034e3e6f9c4214d13244b6c3ae03cca81c",
  "original_prompt": "Ingested from linux-6.6.14/block/genhd.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/fs.h>\n#include <linux/kdev_t.h>\n#include <linux/kernel.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/spinlock.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/kmod.h>\n#include <linux/major.h>\n#include <linux/mutex.h>\n#include <linux/idr.h>\n#include <linux/log2.h>\n#include <linux/pm_runtime.h>\n#include <linux/badblocks.h>\n#include <linux/part_stat.h>\n#include <linux/blktrace_api.h>\n\n#include \"blk-throttle.h\"\n#include \"blk.h\"\n#include \"blk-mq-sched.h\"\n#include \"blk-rq-qos.h\"\n#include \"blk-cgroup.h\"\n\nstatic struct kobject *block_depr;\n\n \nstatic atomic64_t diskseq;\n\n \n#define NR_EXT_DEVT\t\t(1 << MINORBITS)\nstatic DEFINE_IDA(ext_devt_ida);\n\nvoid set_capacity(struct gendisk *disk, sector_t sectors)\n{\n\tbdev_set_nr_sectors(disk->part0, sectors);\n}\nEXPORT_SYMBOL(set_capacity);\n\n \nbool set_capacity_and_notify(struct gendisk *disk, sector_t size)\n{\n\tsector_t capacity = get_capacity(disk);\n\tchar *envp[] = { \"RESIZE=1\", NULL };\n\n\tset_capacity(disk, size);\n\n\t \n\tif (size == capacity ||\n\t    !disk_live(disk) ||\n\t    (disk->flags & GENHD_FL_HIDDEN))\n\t\treturn false;\n\n\tpr_info(\"%s: detected capacity change from %lld to %lld\\n\",\n\t\tdisk->disk_name, capacity, size);\n\n\t \n\tif (!capacity || !size)\n\t\treturn false;\n\tkobject_uevent_env(&disk_to_dev(disk)->kobj, KOBJ_CHANGE, envp);\n\treturn true;\n}\nEXPORT_SYMBOL_GPL(set_capacity_and_notify);\n\nstatic void part_stat_read_all(struct block_device *part,\n\t\tstruct disk_stats *stat)\n{\n\tint cpu;\n\n\tmemset(stat, 0, sizeof(struct disk_stats));\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct disk_stats *ptr = per_cpu_ptr(part->bd_stats, cpu);\n\t\tint group;\n\n\t\tfor (group = 0; group < NR_STAT_GROUPS; group++) {\n\t\t\tstat->nsecs[group] += ptr->nsecs[group];\n\t\t\tstat->sectors[group] += ptr->sectors[group];\n\t\t\tstat->ios[group] += ptr->ios[group];\n\t\t\tstat->merges[group] += ptr->merges[group];\n\t\t}\n\n\t\tstat->io_ticks += ptr->io_ticks;\n\t}\n}\n\nstatic unsigned int part_in_flight(struct block_device *part)\n{\n\tunsigned int inflight = 0;\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tinflight += part_stat_local_read_cpu(part, in_flight[0], cpu) +\n\t\t\t    part_stat_local_read_cpu(part, in_flight[1], cpu);\n\t}\n\tif ((int)inflight < 0)\n\t\tinflight = 0;\n\n\treturn inflight;\n}\n\nstatic void part_in_flight_rw(struct block_device *part,\n\t\tunsigned int inflight[2])\n{\n\tint cpu;\n\n\tinflight[0] = 0;\n\tinflight[1] = 0;\n\tfor_each_possible_cpu(cpu) {\n\t\tinflight[0] += part_stat_local_read_cpu(part, in_flight[0], cpu);\n\t\tinflight[1] += part_stat_local_read_cpu(part, in_flight[1], cpu);\n\t}\n\tif ((int)inflight[0] < 0)\n\t\tinflight[0] = 0;\n\tif ((int)inflight[1] < 0)\n\t\tinflight[1] = 0;\n}\n\n \n#define BLKDEV_MAJOR_HASH_SIZE 255\nstatic struct blk_major_name {\n\tstruct blk_major_name *next;\n\tint major;\n\tchar name[16];\n#ifdef CONFIG_BLOCK_LEGACY_AUTOLOAD\n\tvoid (*probe)(dev_t devt);\n#endif\n} *major_names[BLKDEV_MAJOR_HASH_SIZE];\nstatic DEFINE_MUTEX(major_names_lock);\nstatic DEFINE_SPINLOCK(major_names_spinlock);\n\n \nstatic inline int major_to_index(unsigned major)\n{\n\treturn major % BLKDEV_MAJOR_HASH_SIZE;\n}\n\n#ifdef CONFIG_PROC_FS\nvoid blkdev_show(struct seq_file *seqf, off_t offset)\n{\n\tstruct blk_major_name *dp;\n\n\tspin_lock(&major_names_spinlock);\n\tfor (dp = major_names[major_to_index(offset)]; dp; dp = dp->next)\n\t\tif (dp->major == offset)\n\t\t\tseq_printf(seqf, \"%3d %s\\n\", dp->major, dp->name);\n\tspin_unlock(&major_names_spinlock);\n}\n#endif  \n\n \nint __register_blkdev(unsigned int major, const char *name,\n\t\tvoid (*probe)(dev_t devt))\n{\n\tstruct blk_major_name **n, *p;\n\tint index, ret = 0;\n\n\tmutex_lock(&major_names_lock);\n\n\t \n\tif (major == 0) {\n\t\tfor (index = ARRAY_SIZE(major_names)-1; index > 0; index--) {\n\t\t\tif (major_names[index] == NULL)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (index == 0) {\n\t\t\tprintk(\"%s: failed to get major for %s\\n\",\n\t\t\t       __func__, name);\n\t\t\tret = -EBUSY;\n\t\t\tgoto out;\n\t\t}\n\t\tmajor = index;\n\t\tret = major;\n\t}\n\n\tif (major >= BLKDEV_MAJOR_MAX) {\n\t\tpr_err(\"%s: major requested (%u) is greater than the maximum (%u) for %s\\n\",\n\t\t       __func__, major, BLKDEV_MAJOR_MAX-1, name);\n\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tp = kmalloc(sizeof(struct blk_major_name), GFP_KERNEL);\n\tif (p == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tp->major = major;\n#ifdef CONFIG_BLOCK_LEGACY_AUTOLOAD\n\tp->probe = probe;\n#endif\n\tstrscpy(p->name, name, sizeof(p->name));\n\tp->next = NULL;\n\tindex = major_to_index(major);\n\n\tspin_lock(&major_names_spinlock);\n\tfor (n = &major_names[index]; *n; n = &(*n)->next) {\n\t\tif ((*n)->major == major)\n\t\t\tbreak;\n\t}\n\tif (!*n)\n\t\t*n = p;\n\telse\n\t\tret = -EBUSY;\n\tspin_unlock(&major_names_spinlock);\n\n\tif (ret < 0) {\n\t\tprintk(\"register_blkdev: cannot get major %u for %s\\n\",\n\t\t       major, name);\n\t\tkfree(p);\n\t}\nout:\n\tmutex_unlock(&major_names_lock);\n\treturn ret;\n}\nEXPORT_SYMBOL(__register_blkdev);\n\nvoid unregister_blkdev(unsigned int major, const char *name)\n{\n\tstruct blk_major_name **n;\n\tstruct blk_major_name *p = NULL;\n\tint index = major_to_index(major);\n\n\tmutex_lock(&major_names_lock);\n\tspin_lock(&major_names_spinlock);\n\tfor (n = &major_names[index]; *n; n = &(*n)->next)\n\t\tif ((*n)->major == major)\n\t\t\tbreak;\n\tif (!*n || strcmp((*n)->name, name)) {\n\t\tWARN_ON(1);\n\t} else {\n\t\tp = *n;\n\t\t*n = p->next;\n\t}\n\tspin_unlock(&major_names_spinlock);\n\tmutex_unlock(&major_names_lock);\n\tkfree(p);\n}\n\nEXPORT_SYMBOL(unregister_blkdev);\n\nint blk_alloc_ext_minor(void)\n{\n\tint idx;\n\n\tidx = ida_alloc_range(&ext_devt_ida, 0, NR_EXT_DEVT - 1, GFP_KERNEL);\n\tif (idx == -ENOSPC)\n\t\treturn -EBUSY;\n\treturn idx;\n}\n\nvoid blk_free_ext_minor(unsigned int minor)\n{\n\tida_free(&ext_devt_ida, minor);\n}\n\nvoid disk_uevent(struct gendisk *disk, enum kobject_action action)\n{\n\tstruct block_device *part;\n\tunsigned long idx;\n\n\trcu_read_lock();\n\txa_for_each(&disk->part_tbl, idx, part) {\n\t\tif (bdev_is_partition(part) && !bdev_nr_sectors(part))\n\t\t\tcontinue;\n\t\tif (!kobject_get_unless_zero(&part->bd_device.kobj))\n\t\t\tcontinue;\n\n\t\trcu_read_unlock();\n\t\tkobject_uevent(bdev_kobj(part), action);\n\t\tput_device(&part->bd_device);\n\t\trcu_read_lock();\n\t}\n\trcu_read_unlock();\n}\nEXPORT_SYMBOL_GPL(disk_uevent);\n\nint disk_scan_partitions(struct gendisk *disk, blk_mode_t mode)\n{\n\tstruct block_device *bdev;\n\tint ret = 0;\n\n\tif (disk->flags & (GENHD_FL_NO_PART | GENHD_FL_HIDDEN))\n\t\treturn -EINVAL;\n\tif (test_bit(GD_SUPPRESS_PART_SCAN, &disk->state))\n\t\treturn -EINVAL;\n\tif (disk->open_partitions)\n\t\treturn -EBUSY;\n\n\t \n\tif (!(mode & BLK_OPEN_EXCL)) {\n\t\tret = bd_prepare_to_claim(disk->part0, disk_scan_partitions,\n\t\t\t\t\t  NULL);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tset_bit(GD_NEED_PART_SCAN, &disk->state);\n\tbdev = blkdev_get_by_dev(disk_devt(disk), mode & ~BLK_OPEN_EXCL, NULL,\n\t\t\t\t NULL);\n\tif (IS_ERR(bdev))\n\t\tret =  PTR_ERR(bdev);\n\telse\n\t\tblkdev_put(bdev, NULL);\n\n\t \n\tclear_bit(GD_NEED_PART_SCAN, &disk->state);\n\tif (!(mode & BLK_OPEN_EXCL))\n\t\tbd_abort_claiming(disk->part0, disk_scan_partitions);\n\treturn ret;\n}\n\n \nint __must_check device_add_disk(struct device *parent, struct gendisk *disk,\n\t\t\t\t const struct attribute_group **groups)\n\n{\n\tstruct device *ddev = disk_to_dev(disk);\n\tint ret;\n\n\t \n\tif (queue_is_mq(disk->queue) && disk->fops->poll_bio)\n\t\treturn -EINVAL;\n\n\t \n\televator_init_mq(disk->queue);\n\n\t \n\tdisk->part0->bd_has_submit_bio = disk->fops->submit_bio != NULL;\n\n\t \n\tret = -EINVAL;\n\tif (disk->major) {\n\t\tif (WARN_ON(!disk->minors))\n\t\t\tgoto out_exit_elevator;\n\n\t\tif (disk->minors > DISK_MAX_PARTS) {\n\t\t\tpr_err(\"block: can't allocate more than %d partitions\\n\",\n\t\t\t\tDISK_MAX_PARTS);\n\t\t\tdisk->minors = DISK_MAX_PARTS;\n\t\t}\n\t\tif (disk->first_minor > MINORMASK ||\n\t\t    disk->minors > MINORMASK + 1 ||\n\t\t    disk->first_minor + disk->minors > MINORMASK + 1)\n\t\t\tgoto out_exit_elevator;\n\t} else {\n\t\tif (WARN_ON(disk->minors))\n\t\t\tgoto out_exit_elevator;\n\n\t\tret = blk_alloc_ext_minor();\n\t\tif (ret < 0)\n\t\t\tgoto out_exit_elevator;\n\t\tdisk->major = BLOCK_EXT_MAJOR;\n\t\tdisk->first_minor = ret;\n\t}\n\n\t \n\tdev_set_uevent_suppress(ddev, 1);\n\n\tddev->parent = parent;\n\tddev->groups = groups;\n\tdev_set_name(ddev, \"%s\", disk->disk_name);\n\tif (!(disk->flags & GENHD_FL_HIDDEN))\n\t\tddev->devt = MKDEV(disk->major, disk->first_minor);\n\tret = device_add(ddev);\n\tif (ret)\n\t\tgoto out_free_ext_minor;\n\n\tret = disk_alloc_events(disk);\n\tif (ret)\n\t\tgoto out_device_del;\n\n\tret = sysfs_create_link(block_depr, &ddev->kobj,\n\t\t\t\tkobject_name(&ddev->kobj));\n\tif (ret)\n\t\tgoto out_device_del;\n\n\t \n\tpm_runtime_set_memalloc_noio(ddev, true);\n\n\tdisk->part0->bd_holder_dir =\n\t\tkobject_create_and_add(\"holders\", &ddev->kobj);\n\tif (!disk->part0->bd_holder_dir) {\n\t\tret = -ENOMEM;\n\t\tgoto out_del_block_link;\n\t}\n\tdisk->slave_dir = kobject_create_and_add(\"slaves\", &ddev->kobj);\n\tif (!disk->slave_dir) {\n\t\tret = -ENOMEM;\n\t\tgoto out_put_holder_dir;\n\t}\n\n\tret = blk_register_queue(disk);\n\tif (ret)\n\t\tgoto out_put_slave_dir;\n\n\tif (!(disk->flags & GENHD_FL_HIDDEN)) {\n\t\tret = bdi_register(disk->bdi, \"%u:%u\",\n\t\t\t\t   disk->major, disk->first_minor);\n\t\tif (ret)\n\t\t\tgoto out_unregister_queue;\n\t\tbdi_set_owner(disk->bdi, ddev);\n\t\tret = sysfs_create_link(&ddev->kobj,\n\t\t\t\t\t&disk->bdi->dev->kobj, \"bdi\");\n\t\tif (ret)\n\t\t\tgoto out_unregister_bdi;\n\n\t\t \n\t\tif (get_capacity(disk) && !(disk->flags & GENHD_FL_NO_PART) &&\n\t\t    !test_bit(GD_SUPPRESS_PART_SCAN, &disk->state))\n\t\t\tset_bit(GD_NEED_PART_SCAN, &disk->state);\n\n\t\tbdev_add(disk->part0, ddev->devt);\n\t\tif (get_capacity(disk))\n\t\t\tdisk_scan_partitions(disk, BLK_OPEN_READ);\n\n\t\t \n\t\tdev_set_uevent_suppress(ddev, 0);\n\t\tdisk_uevent(disk, KOBJ_ADD);\n\t} else {\n\t\t \n\t\tdisk->part0->bd_dev = MKDEV(disk->major, disk->first_minor);\n\t}\n\n\tdisk_update_readahead(disk);\n\tdisk_add_events(disk);\n\tset_bit(GD_ADDED, &disk->state);\n\treturn 0;\n\nout_unregister_bdi:\n\tif (!(disk->flags & GENHD_FL_HIDDEN))\n\t\tbdi_unregister(disk->bdi);\nout_unregister_queue:\n\tblk_unregister_queue(disk);\n\trq_qos_exit(disk->queue);\nout_put_slave_dir:\n\tkobject_put(disk->slave_dir);\n\tdisk->slave_dir = NULL;\nout_put_holder_dir:\n\tkobject_put(disk->part0->bd_holder_dir);\nout_del_block_link:\n\tsysfs_remove_link(block_depr, dev_name(ddev));\n\tpm_runtime_set_memalloc_noio(ddev, false);\nout_device_del:\n\tdevice_del(ddev);\nout_free_ext_minor:\n\tif (disk->major == BLOCK_EXT_MAJOR)\n\t\tblk_free_ext_minor(disk->first_minor);\nout_exit_elevator:\n\tif (disk->queue->elevator)\n\t\televator_exit(disk->queue);\n\treturn ret;\n}\nEXPORT_SYMBOL(device_add_disk);\n\nstatic void blk_report_disk_dead(struct gendisk *disk, bool surprise)\n{\n\tstruct block_device *bdev;\n\tunsigned long idx;\n\n\trcu_read_lock();\n\txa_for_each(&disk->part_tbl, idx, bdev) {\n\t\tif (!kobject_get_unless_zero(&bdev->bd_device.kobj))\n\t\t\tcontinue;\n\t\trcu_read_unlock();\n\n\t\tbdev_mark_dead(bdev, surprise);\n\n\t\tput_device(&bdev->bd_device);\n\t\trcu_read_lock();\n\t}\n\trcu_read_unlock();\n}\n\nstatic void __blk_mark_disk_dead(struct gendisk *disk)\n{\n\t \n\tif (test_and_set_bit(GD_DEAD, &disk->state))\n\t\treturn;\n\n\tif (test_bit(GD_OWNS_QUEUE, &disk->state))\n\t\tblk_queue_flag_set(QUEUE_FLAG_DYING, disk->queue);\n\n\t \n\tset_capacity(disk, 0);\n\n\t \n\tblk_queue_start_drain(disk->queue);\n}\n\n \nvoid blk_mark_disk_dead(struct gendisk *disk)\n{\n\t__blk_mark_disk_dead(disk);\n\tblk_report_disk_dead(disk, true);\n}\nEXPORT_SYMBOL_GPL(blk_mark_disk_dead);\n\n \nvoid del_gendisk(struct gendisk *disk)\n{\n\tstruct request_queue *q = disk->queue;\n\tstruct block_device *part;\n\tunsigned long idx;\n\n\tmight_sleep();\n\n\tif (WARN_ON_ONCE(!disk_live(disk) && !(disk->flags & GENHD_FL_HIDDEN)))\n\t\treturn;\n\n\tdisk_del_events(disk);\n\n\t \n\tmutex_lock(&disk->open_mutex);\n\txa_for_each(&disk->part_tbl, idx, part)\n\t\tremove_inode_hash(part->bd_inode);\n\tmutex_unlock(&disk->open_mutex);\n\n\t \n\tif (!test_bit(GD_DEAD, &disk->state))\n\t\tblk_report_disk_dead(disk, false);\n\t__blk_mark_disk_dead(disk);\n\n\t \n\tmutex_lock(&disk->open_mutex);\n\txa_for_each_start(&disk->part_tbl, idx, part, 1)\n\t\tdrop_partition(part);\n\tmutex_unlock(&disk->open_mutex);\n\n\tif (!(disk->flags & GENHD_FL_HIDDEN)) {\n\t\tsysfs_remove_link(&disk_to_dev(disk)->kobj, \"bdi\");\n\n\t\t \n\t\tbdi_unregister(disk->bdi);\n\t}\n\n\tblk_unregister_queue(disk);\n\n\tkobject_put(disk->part0->bd_holder_dir);\n\tkobject_put(disk->slave_dir);\n\tdisk->slave_dir = NULL;\n\n\tpart_stat_set_all(disk->part0, 0);\n\tdisk->part0->bd_stamp = 0;\n\tsysfs_remove_link(block_depr, dev_name(disk_to_dev(disk)));\n\tpm_runtime_set_memalloc_noio(disk_to_dev(disk), false);\n\tdevice_del(disk_to_dev(disk));\n\n\tblk_mq_freeze_queue_wait(q);\n\n\tblk_throtl_cancel_bios(disk);\n\n\tblk_sync_queue(q);\n\tblk_flush_integrity();\n\n\tif (queue_is_mq(q))\n\t\tblk_mq_cancel_work_sync(q);\n\n\tblk_mq_quiesce_queue(q);\n\tif (q->elevator) {\n\t\tmutex_lock(&q->sysfs_lock);\n\t\televator_exit(q);\n\t\tmutex_unlock(&q->sysfs_lock);\n\t}\n\trq_qos_exit(q);\n\tblk_mq_unquiesce_queue(q);\n\n\t \n\tif (!test_bit(GD_OWNS_QUEUE, &disk->state)) {\n\t\tblk_queue_flag_clear(QUEUE_FLAG_INIT_DONE, q);\n\t\t__blk_mq_unfreeze_queue(q, true);\n\t} else {\n\t\tif (queue_is_mq(q))\n\t\t\tblk_mq_exit_queue(q);\n\t}\n}\nEXPORT_SYMBOL(del_gendisk);\n\n \nvoid invalidate_disk(struct gendisk *disk)\n{\n\tstruct block_device *bdev = disk->part0;\n\n\tinvalidate_bdev(bdev);\n\tbdev->bd_inode->i_mapping->wb_err = 0;\n\tset_capacity(disk, 0);\n}\nEXPORT_SYMBOL(invalidate_disk);\n\n \nstatic ssize_t disk_badblocks_show(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tchar *page)\n{\n\tstruct gendisk *disk = dev_to_disk(dev);\n\n\tif (!disk->bb)\n\t\treturn sprintf(page, \"\\n\");\n\n\treturn badblocks_show(disk->bb, page, 0);\n}\n\nstatic ssize_t disk_badblocks_store(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tconst char *page, size_t len)\n{\n\tstruct gendisk *disk = dev_to_disk(dev);\n\n\tif (!disk->bb)\n\t\treturn -ENXIO;\n\n\treturn badblocks_store(disk->bb, page, len, 0);\n}\n\n#ifdef CONFIG_BLOCK_LEGACY_AUTOLOAD\nvoid blk_request_module(dev_t devt)\n{\n\tunsigned int major = MAJOR(devt);\n\tstruct blk_major_name **n;\n\n\tmutex_lock(&major_names_lock);\n\tfor (n = &major_names[major_to_index(major)]; *n; n = &(*n)->next) {\n\t\tif ((*n)->major == major && (*n)->probe) {\n\t\t\t(*n)->probe(devt);\n\t\t\tmutex_unlock(&major_names_lock);\n\t\t\treturn;\n\t\t}\n\t}\n\tmutex_unlock(&major_names_lock);\n\n\tif (request_module(\"block-major-%d-%d\", MAJOR(devt), MINOR(devt)) > 0)\n\t\t \n\t\trequest_module(\"block-major-%d\", MAJOR(devt));\n}\n#endif  \n\n#ifdef CONFIG_PROC_FS\n \nstatic void *disk_seqf_start(struct seq_file *seqf, loff_t *pos)\n{\n\tloff_t skip = *pos;\n\tstruct class_dev_iter *iter;\n\tstruct device *dev;\n\n\titer = kmalloc(sizeof(*iter), GFP_KERNEL);\n\tif (!iter)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tseqf->private = iter;\n\tclass_dev_iter_init(iter, &block_class, NULL, &disk_type);\n\tdo {\n\t\tdev = class_dev_iter_next(iter);\n\t\tif (!dev)\n\t\t\treturn NULL;\n\t} while (skip--);\n\n\treturn dev_to_disk(dev);\n}\n\nstatic void *disk_seqf_next(struct seq_file *seqf, void *v, loff_t *pos)\n{\n\tstruct device *dev;\n\n\t(*pos)++;\n\tdev = class_dev_iter_next(seqf->private);\n\tif (dev)\n\t\treturn dev_to_disk(dev);\n\n\treturn NULL;\n}\n\nstatic void disk_seqf_stop(struct seq_file *seqf, void *v)\n{\n\tstruct class_dev_iter *iter = seqf->private;\n\n\t \n\tif (iter) {\n\t\tclass_dev_iter_exit(iter);\n\t\tkfree(iter);\n\t\tseqf->private = NULL;\n\t}\n}\n\nstatic void *show_partition_start(struct seq_file *seqf, loff_t *pos)\n{\n\tvoid *p;\n\n\tp = disk_seqf_start(seqf, pos);\n\tif (!IS_ERR_OR_NULL(p) && !*pos)\n\t\tseq_puts(seqf, \"major minor  #blocks  name\\n\\n\");\n\treturn p;\n}\n\nstatic int show_partition(struct seq_file *seqf, void *v)\n{\n\tstruct gendisk *sgp = v;\n\tstruct block_device *part;\n\tunsigned long idx;\n\n\tif (!get_capacity(sgp) || (sgp->flags & GENHD_FL_HIDDEN))\n\t\treturn 0;\n\n\trcu_read_lock();\n\txa_for_each(&sgp->part_tbl, idx, part) {\n\t\tif (!bdev_nr_sectors(part))\n\t\t\tcontinue;\n\t\tseq_printf(seqf, \"%4d  %7d %10llu %pg\\n\",\n\t\t\t   MAJOR(part->bd_dev), MINOR(part->bd_dev),\n\t\t\t   bdev_nr_sectors(part) >> 1, part);\n\t}\n\trcu_read_unlock();\n\treturn 0;\n}\n\nstatic const struct seq_operations partitions_op = {\n\t.start\t= show_partition_start,\n\t.next\t= disk_seqf_next,\n\t.stop\t= disk_seqf_stop,\n\t.show\t= show_partition\n};\n#endif\n\nstatic int __init genhd_device_init(void)\n{\n\tint error;\n\n\terror = class_register(&block_class);\n\tif (unlikely(error))\n\t\treturn error;\n\tblk_dev_init();\n\n\tregister_blkdev(BLOCK_EXT_MAJOR, \"blkext\");\n\n\t \n\tblock_depr = kobject_create_and_add(\"block\", NULL);\n\treturn 0;\n}\n\nsubsys_initcall(genhd_device_init);\n\nstatic ssize_t disk_range_show(struct device *dev,\n\t\t\t       struct device_attribute *attr, char *buf)\n{\n\tstruct gendisk *disk = dev_to_disk(dev);\n\n\treturn sprintf(buf, \"%d\\n\", disk->minors);\n}\n\nstatic ssize_t disk_ext_range_show(struct device *dev,\n\t\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tstruct gendisk *disk = dev_to_disk(dev);\n\n\treturn sprintf(buf, \"%d\\n\",\n\t\t(disk->flags & GENHD_FL_NO_PART) ? 1 : DISK_MAX_PARTS);\n}\n\nstatic ssize_t disk_removable_show(struct device *dev,\n\t\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tstruct gendisk *disk = dev_to_disk(dev);\n\n\treturn sprintf(buf, \"%d\\n\",\n\t\t       (disk->flags & GENHD_FL_REMOVABLE ? 1 : 0));\n}\n\nstatic ssize_t disk_hidden_show(struct device *dev,\n\t\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tstruct gendisk *disk = dev_to_disk(dev);\n\n\treturn sprintf(buf, \"%d\\n\",\n\t\t       (disk->flags & GENHD_FL_HIDDEN ? 1 : 0));\n}\n\nstatic ssize_t disk_ro_show(struct device *dev,\n\t\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tstruct gendisk *disk = dev_to_disk(dev);\n\n\treturn sprintf(buf, \"%d\\n\", get_disk_ro(disk) ? 1 : 0);\n}\n\nssize_t part_size_show(struct device *dev,\n\t\t       struct device_attribute *attr, char *buf)\n{\n\treturn sprintf(buf, \"%llu\\n\", bdev_nr_sectors(dev_to_bdev(dev)));\n}\n\nssize_t part_stat_show(struct device *dev,\n\t\t       struct device_attribute *attr, char *buf)\n{\n\tstruct block_device *bdev = dev_to_bdev(dev);\n\tstruct request_queue *q = bdev_get_queue(bdev);\n\tstruct disk_stats stat;\n\tunsigned int inflight;\n\n\tif (queue_is_mq(q))\n\t\tinflight = blk_mq_in_flight(q, bdev);\n\telse\n\t\tinflight = part_in_flight(bdev);\n\n\tif (inflight) {\n\t\tpart_stat_lock();\n\t\tupdate_io_ticks(bdev, jiffies, true);\n\t\tpart_stat_unlock();\n\t}\n\tpart_stat_read_all(bdev, &stat);\n\treturn sprintf(buf,\n\t\t\"%8lu %8lu %8llu %8u \"\n\t\t\"%8lu %8lu %8llu %8u \"\n\t\t\"%8u %8u %8u \"\n\t\t\"%8lu %8lu %8llu %8u \"\n\t\t\"%8lu %8u\"\n\t\t\"\\n\",\n\t\tstat.ios[STAT_READ],\n\t\tstat.merges[STAT_READ],\n\t\t(unsigned long long)stat.sectors[STAT_READ],\n\t\t(unsigned int)div_u64(stat.nsecs[STAT_READ], NSEC_PER_MSEC),\n\t\tstat.ios[STAT_WRITE],\n\t\tstat.merges[STAT_WRITE],\n\t\t(unsigned long long)stat.sectors[STAT_WRITE],\n\t\t(unsigned int)div_u64(stat.nsecs[STAT_WRITE], NSEC_PER_MSEC),\n\t\tinflight,\n\t\tjiffies_to_msecs(stat.io_ticks),\n\t\t(unsigned int)div_u64(stat.nsecs[STAT_READ] +\n\t\t\t\t      stat.nsecs[STAT_WRITE] +\n\t\t\t\t      stat.nsecs[STAT_DISCARD] +\n\t\t\t\t      stat.nsecs[STAT_FLUSH],\n\t\t\t\t\t\tNSEC_PER_MSEC),\n\t\tstat.ios[STAT_DISCARD],\n\t\tstat.merges[STAT_DISCARD],\n\t\t(unsigned long long)stat.sectors[STAT_DISCARD],\n\t\t(unsigned int)div_u64(stat.nsecs[STAT_DISCARD], NSEC_PER_MSEC),\n\t\tstat.ios[STAT_FLUSH],\n\t\t(unsigned int)div_u64(stat.nsecs[STAT_FLUSH], NSEC_PER_MSEC));\n}\n\nssize_t part_inflight_show(struct device *dev, struct device_attribute *attr,\n\t\t\t   char *buf)\n{\n\tstruct block_device *bdev = dev_to_bdev(dev);\n\tstruct request_queue *q = bdev_get_queue(bdev);\n\tunsigned int inflight[2];\n\n\tif (queue_is_mq(q))\n\t\tblk_mq_in_flight_rw(q, bdev, inflight);\n\telse\n\t\tpart_in_flight_rw(bdev, inflight);\n\n\treturn sprintf(buf, \"%8u %8u\\n\", inflight[0], inflight[1]);\n}\n\nstatic ssize_t disk_capability_show(struct device *dev,\n\t\t\t\t    struct device_attribute *attr, char *buf)\n{\n\tdev_warn_once(dev, \"the capability attribute has been deprecated.\\n\");\n\treturn sprintf(buf, \"0\\n\");\n}\n\nstatic ssize_t disk_alignment_offset_show(struct device *dev,\n\t\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t\t  char *buf)\n{\n\tstruct gendisk *disk = dev_to_disk(dev);\n\n\treturn sprintf(buf, \"%d\\n\", bdev_alignment_offset(disk->part0));\n}\n\nstatic ssize_t disk_discard_alignment_show(struct device *dev,\n\t\t\t\t\t   struct device_attribute *attr,\n\t\t\t\t\t   char *buf)\n{\n\tstruct gendisk *disk = dev_to_disk(dev);\n\n\treturn sprintf(buf, \"%d\\n\", bdev_alignment_offset(disk->part0));\n}\n\nstatic ssize_t diskseq_show(struct device *dev,\n\t\t\t    struct device_attribute *attr, char *buf)\n{\n\tstruct gendisk *disk = dev_to_disk(dev);\n\n\treturn sprintf(buf, \"%llu\\n\", disk->diskseq);\n}\n\nstatic DEVICE_ATTR(range, 0444, disk_range_show, NULL);\nstatic DEVICE_ATTR(ext_range, 0444, disk_ext_range_show, NULL);\nstatic DEVICE_ATTR(removable, 0444, disk_removable_show, NULL);\nstatic DEVICE_ATTR(hidden, 0444, disk_hidden_show, NULL);\nstatic DEVICE_ATTR(ro, 0444, disk_ro_show, NULL);\nstatic DEVICE_ATTR(size, 0444, part_size_show, NULL);\nstatic DEVICE_ATTR(alignment_offset, 0444, disk_alignment_offset_show, NULL);\nstatic DEVICE_ATTR(discard_alignment, 0444, disk_discard_alignment_show, NULL);\nstatic DEVICE_ATTR(capability, 0444, disk_capability_show, NULL);\nstatic DEVICE_ATTR(stat, 0444, part_stat_show, NULL);\nstatic DEVICE_ATTR(inflight, 0444, part_inflight_show, NULL);\nstatic DEVICE_ATTR(badblocks, 0644, disk_badblocks_show, disk_badblocks_store);\nstatic DEVICE_ATTR(diskseq, 0444, diskseq_show, NULL);\n\n#ifdef CONFIG_FAIL_MAKE_REQUEST\nssize_t part_fail_show(struct device *dev,\n\t\t       struct device_attribute *attr, char *buf)\n{\n\treturn sprintf(buf, \"%d\\n\", dev_to_bdev(dev)->bd_make_it_fail);\n}\n\nssize_t part_fail_store(struct device *dev,\n\t\t\tstruct device_attribute *attr,\n\t\t\tconst char *buf, size_t count)\n{\n\tint i;\n\n\tif (count > 0 && sscanf(buf, \"%d\", &i) > 0)\n\t\tdev_to_bdev(dev)->bd_make_it_fail = i;\n\n\treturn count;\n}\n\nstatic struct device_attribute dev_attr_fail =\n\t__ATTR(make-it-fail, 0644, part_fail_show, part_fail_store);\n#endif  \n\n#ifdef CONFIG_FAIL_IO_TIMEOUT\nstatic struct device_attribute dev_attr_fail_timeout =\n\t__ATTR(io-timeout-fail, 0644, part_timeout_show, part_timeout_store);\n#endif\n\nstatic struct attribute *disk_attrs[] = {\n\t&dev_attr_range.attr,\n\t&dev_attr_ext_range.attr,\n\t&dev_attr_removable.attr,\n\t&dev_attr_hidden.attr,\n\t&dev_attr_ro.attr,\n\t&dev_attr_size.attr,\n\t&dev_attr_alignment_offset.attr,\n\t&dev_attr_discard_alignment.attr,\n\t&dev_attr_capability.attr,\n\t&dev_attr_stat.attr,\n\t&dev_attr_inflight.attr,\n\t&dev_attr_badblocks.attr,\n\t&dev_attr_events.attr,\n\t&dev_attr_events_async.attr,\n\t&dev_attr_events_poll_msecs.attr,\n\t&dev_attr_diskseq.attr,\n#ifdef CONFIG_FAIL_MAKE_REQUEST\n\t&dev_attr_fail.attr,\n#endif\n#ifdef CONFIG_FAIL_IO_TIMEOUT\n\t&dev_attr_fail_timeout.attr,\n#endif\n\tNULL\n};\n\nstatic umode_t disk_visible(struct kobject *kobj, struct attribute *a, int n)\n{\n\tstruct device *dev = container_of(kobj, typeof(*dev), kobj);\n\tstruct gendisk *disk = dev_to_disk(dev);\n\n\tif (a == &dev_attr_badblocks.attr && !disk->bb)\n\t\treturn 0;\n\treturn a->mode;\n}\n\nstatic struct attribute_group disk_attr_group = {\n\t.attrs = disk_attrs,\n\t.is_visible = disk_visible,\n};\n\nstatic const struct attribute_group *disk_attr_groups[] = {\n\t&disk_attr_group,\n#ifdef CONFIG_BLK_DEV_IO_TRACE\n\t&blk_trace_attr_group,\n#endif\n#ifdef CONFIG_BLK_DEV_INTEGRITY\n\t&blk_integrity_attr_group,\n#endif\n\tNULL\n};\n\n \nstatic void disk_release(struct device *dev)\n{\n\tstruct gendisk *disk = dev_to_disk(dev);\n\n\tmight_sleep();\n\tWARN_ON_ONCE(disk_live(disk));\n\n\tblk_trace_remove(disk->queue);\n\n\t \n\tif (queue_is_mq(disk->queue) &&\n\t    test_bit(GD_OWNS_QUEUE, &disk->state) &&\n\t    !test_bit(GD_ADDED, &disk->state))\n\t\tblk_mq_exit_queue(disk->queue);\n\n\tblkcg_exit_disk(disk);\n\n\tbioset_exit(&disk->bio_split);\n\n\tdisk_release_events(disk);\n\tkfree(disk->random);\n\tdisk_free_zone_bitmaps(disk);\n\txa_destroy(&disk->part_tbl);\n\n\tdisk->queue->disk = NULL;\n\tblk_put_queue(disk->queue);\n\n\tif (test_bit(GD_ADDED, &disk->state) && disk->fops->free_disk)\n\t\tdisk->fops->free_disk(disk);\n\n\tiput(disk->part0->bd_inode);\t \n}\n\nstatic int block_uevent(const struct device *dev, struct kobj_uevent_env *env)\n{\n\tconst struct gendisk *disk = dev_to_disk(dev);\n\n\treturn add_uevent_var(env, \"DISKSEQ=%llu\", disk->diskseq);\n}\n\nstruct class block_class = {\n\t.name\t\t= \"block\",\n\t.dev_uevent\t= block_uevent,\n};\n\nstatic char *block_devnode(const struct device *dev, umode_t *mode,\n\t\t\t   kuid_t *uid, kgid_t *gid)\n{\n\tstruct gendisk *disk = dev_to_disk(dev);\n\n\tif (disk->fops->devnode)\n\t\treturn disk->fops->devnode(disk, mode);\n\treturn NULL;\n}\n\nconst struct device_type disk_type = {\n\t.name\t\t= \"disk\",\n\t.groups\t\t= disk_attr_groups,\n\t.release\t= disk_release,\n\t.devnode\t= block_devnode,\n};\n\n#ifdef CONFIG_PROC_FS\n \nstatic int diskstats_show(struct seq_file *seqf, void *v)\n{\n\tstruct gendisk *gp = v;\n\tstruct block_device *hd;\n\tunsigned int inflight;\n\tstruct disk_stats stat;\n\tunsigned long idx;\n\n\t \n\n\trcu_read_lock();\n\txa_for_each(&gp->part_tbl, idx, hd) {\n\t\tif (bdev_is_partition(hd) && !bdev_nr_sectors(hd))\n\t\t\tcontinue;\n\t\tif (queue_is_mq(gp->queue))\n\t\t\tinflight = blk_mq_in_flight(gp->queue, hd);\n\t\telse\n\t\t\tinflight = part_in_flight(hd);\n\n\t\tif (inflight) {\n\t\t\tpart_stat_lock();\n\t\t\tupdate_io_ticks(hd, jiffies, true);\n\t\t\tpart_stat_unlock();\n\t\t}\n\t\tpart_stat_read_all(hd, &stat);\n\t\tseq_printf(seqf, \"%4d %7d %pg \"\n\t\t\t   \"%lu %lu %lu %u \"\n\t\t\t   \"%lu %lu %lu %u \"\n\t\t\t   \"%u %u %u \"\n\t\t\t   \"%lu %lu %lu %u \"\n\t\t\t   \"%lu %u\"\n\t\t\t   \"\\n\",\n\t\t\t   MAJOR(hd->bd_dev), MINOR(hd->bd_dev), hd,\n\t\t\t   stat.ios[STAT_READ],\n\t\t\t   stat.merges[STAT_READ],\n\t\t\t   stat.sectors[STAT_READ],\n\t\t\t   (unsigned int)div_u64(stat.nsecs[STAT_READ],\n\t\t\t\t\t\t\tNSEC_PER_MSEC),\n\t\t\t   stat.ios[STAT_WRITE],\n\t\t\t   stat.merges[STAT_WRITE],\n\t\t\t   stat.sectors[STAT_WRITE],\n\t\t\t   (unsigned int)div_u64(stat.nsecs[STAT_WRITE],\n\t\t\t\t\t\t\tNSEC_PER_MSEC),\n\t\t\t   inflight,\n\t\t\t   jiffies_to_msecs(stat.io_ticks),\n\t\t\t   (unsigned int)div_u64(stat.nsecs[STAT_READ] +\n\t\t\t\t\t\t stat.nsecs[STAT_WRITE] +\n\t\t\t\t\t\t stat.nsecs[STAT_DISCARD] +\n\t\t\t\t\t\t stat.nsecs[STAT_FLUSH],\n\t\t\t\t\t\t\tNSEC_PER_MSEC),\n\t\t\t   stat.ios[STAT_DISCARD],\n\t\t\t   stat.merges[STAT_DISCARD],\n\t\t\t   stat.sectors[STAT_DISCARD],\n\t\t\t   (unsigned int)div_u64(stat.nsecs[STAT_DISCARD],\n\t\t\t\t\t\t NSEC_PER_MSEC),\n\t\t\t   stat.ios[STAT_FLUSH],\n\t\t\t   (unsigned int)div_u64(stat.nsecs[STAT_FLUSH],\n\t\t\t\t\t\t NSEC_PER_MSEC)\n\t\t\t);\n\t}\n\trcu_read_unlock();\n\n\treturn 0;\n}\n\nstatic const struct seq_operations diskstats_op = {\n\t.start\t= disk_seqf_start,\n\t.next\t= disk_seqf_next,\n\t.stop\t= disk_seqf_stop,\n\t.show\t= diskstats_show\n};\n\nstatic int __init proc_genhd_init(void)\n{\n\tproc_create_seq(\"diskstats\", 0, NULL, &diskstats_op);\n\tproc_create_seq(\"partitions\", 0, NULL, &partitions_op);\n\treturn 0;\n}\nmodule_init(proc_genhd_init);\n#endif  \n\ndev_t part_devt(struct gendisk *disk, u8 partno)\n{\n\tstruct block_device *part;\n\tdev_t devt = 0;\n\n\trcu_read_lock();\n\tpart = xa_load(&disk->part_tbl, partno);\n\tif (part)\n\t\tdevt = part->bd_dev;\n\trcu_read_unlock();\n\n\treturn devt;\n}\n\nstruct gendisk *__alloc_disk_node(struct request_queue *q, int node_id,\n\t\tstruct lock_class_key *lkclass)\n{\n\tstruct gendisk *disk;\n\n\tdisk = kzalloc_node(sizeof(struct gendisk), GFP_KERNEL, node_id);\n\tif (!disk)\n\t\treturn NULL;\n\n\tif (bioset_init(&disk->bio_split, BIO_POOL_SIZE, 0, 0))\n\t\tgoto out_free_disk;\n\n\tdisk->bdi = bdi_alloc(node_id);\n\tif (!disk->bdi)\n\t\tgoto out_free_bioset;\n\n\t \n\tdisk->queue = q;\n\n\tdisk->part0 = bdev_alloc(disk, 0);\n\tif (!disk->part0)\n\t\tgoto out_free_bdi;\n\n\tdisk->node_id = node_id;\n\tmutex_init(&disk->open_mutex);\n\txa_init(&disk->part_tbl);\n\tif (xa_insert(&disk->part_tbl, 0, disk->part0, GFP_KERNEL))\n\t\tgoto out_destroy_part_tbl;\n\n\tif (blkcg_init_disk(disk))\n\t\tgoto out_erase_part0;\n\n\trand_initialize_disk(disk);\n\tdisk_to_dev(disk)->class = &block_class;\n\tdisk_to_dev(disk)->type = &disk_type;\n\tdevice_initialize(disk_to_dev(disk));\n\tinc_diskseq(disk);\n\tq->disk = disk;\n\tlockdep_init_map(&disk->lockdep_map, \"(bio completion)\", lkclass, 0);\n#ifdef CONFIG_BLOCK_HOLDER_DEPRECATED\n\tINIT_LIST_HEAD(&disk->slave_bdevs);\n#endif\n\treturn disk;\n\nout_erase_part0:\n\txa_erase(&disk->part_tbl, 0);\nout_destroy_part_tbl:\n\txa_destroy(&disk->part_tbl);\n\tdisk->part0->bd_disk = NULL;\n\tiput(disk->part0->bd_inode);\nout_free_bdi:\n\tbdi_put(disk->bdi);\nout_free_bioset:\n\tbioset_exit(&disk->bio_split);\nout_free_disk:\n\tkfree(disk);\n\treturn NULL;\n}\n\nstruct gendisk *__blk_alloc_disk(int node, struct lock_class_key *lkclass)\n{\n\tstruct request_queue *q;\n\tstruct gendisk *disk;\n\n\tq = blk_alloc_queue(node);\n\tif (!q)\n\t\treturn NULL;\n\n\tdisk = __alloc_disk_node(q, node, lkclass);\n\tif (!disk) {\n\t\tblk_put_queue(q);\n\t\treturn NULL;\n\t}\n\tset_bit(GD_OWNS_QUEUE, &disk->state);\n\treturn disk;\n}\nEXPORT_SYMBOL(__blk_alloc_disk);\n\n \nvoid put_disk(struct gendisk *disk)\n{\n\tif (disk)\n\t\tput_device(disk_to_dev(disk));\n}\nEXPORT_SYMBOL(put_disk);\n\nstatic void set_disk_ro_uevent(struct gendisk *gd, int ro)\n{\n\tchar event[] = \"DISK_RO=1\";\n\tchar *envp[] = { event, NULL };\n\n\tif (!ro)\n\t\tevent[8] = '0';\n\tkobject_uevent_env(&disk_to_dev(gd)->kobj, KOBJ_CHANGE, envp);\n}\n\n \nvoid set_disk_ro(struct gendisk *disk, bool read_only)\n{\n\tif (read_only) {\n\t\tif (test_and_set_bit(GD_READ_ONLY, &disk->state))\n\t\t\treturn;\n\t} else {\n\t\tif (!test_and_clear_bit(GD_READ_ONLY, &disk->state))\n\t\t\treturn;\n\t}\n\tset_disk_ro_uevent(disk, read_only);\n}\nEXPORT_SYMBOL(set_disk_ro);\n\nvoid inc_diskseq(struct gendisk *disk)\n{\n\tdisk->diskseq = atomic64_inc_return(&diskseq);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}