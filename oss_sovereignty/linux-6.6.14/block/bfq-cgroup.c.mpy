{
  "module_name": "bfq-cgroup.c",
  "hash_id": "bae62d7ac919a45caab1d8cfd3f06d0e0d14ef9d39d7f5767961963c735f5404",
  "original_prompt": "Ingested from linux-6.6.14/block/bfq-cgroup.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/cgroup.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/ioprio.h>\n#include <linux/sbitmap.h>\n#include <linux/delay.h>\n\n#include \"elevator.h\"\n#include \"bfq-iosched.h\"\n\n#ifdef CONFIG_BFQ_CGROUP_DEBUG\nstatic int bfq_stat_init(struct bfq_stat *stat, gfp_t gfp)\n{\n\tint ret;\n\n\tret = percpu_counter_init(&stat->cpu_cnt, 0, gfp);\n\tif (ret)\n\t\treturn ret;\n\n\tatomic64_set(&stat->aux_cnt, 0);\n\treturn 0;\n}\n\nstatic void bfq_stat_exit(struct bfq_stat *stat)\n{\n\tpercpu_counter_destroy(&stat->cpu_cnt);\n}\n\n \nstatic inline void bfq_stat_add(struct bfq_stat *stat, uint64_t val)\n{\n\tpercpu_counter_add_batch(&stat->cpu_cnt, val, BLKG_STAT_CPU_BATCH);\n}\n\n \nstatic inline uint64_t bfq_stat_read(struct bfq_stat *stat)\n{\n\treturn percpu_counter_sum_positive(&stat->cpu_cnt);\n}\n\n \nstatic inline void bfq_stat_reset(struct bfq_stat *stat)\n{\n\tpercpu_counter_set(&stat->cpu_cnt, 0);\n\tatomic64_set(&stat->aux_cnt, 0);\n}\n\n \nstatic inline void bfq_stat_add_aux(struct bfq_stat *to,\n\t\t\t\t     struct bfq_stat *from)\n{\n\tatomic64_add(bfq_stat_read(from) + atomic64_read(&from->aux_cnt),\n\t\t     &to->aux_cnt);\n}\n\n \nstatic u64 blkg_prfill_stat(struct seq_file *sf, struct blkg_policy_data *pd,\n\t\tint off)\n{\n\treturn __blkg_prfill_u64(sf, pd, bfq_stat_read((void *)pd + off));\n}\n\n \nenum bfqg_stats_flags {\n\tBFQG_stats_waiting = 0,\n\tBFQG_stats_idling,\n\tBFQG_stats_empty,\n};\n\n#define BFQG_FLAG_FNS(name)\t\t\t\t\t\t\\\nstatic void bfqg_stats_mark_##name(struct bfqg_stats *stats)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstats->flags |= (1 << BFQG_stats_##name);\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\nstatic void bfqg_stats_clear_##name(struct bfqg_stats *stats)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstats->flags &= ~(1 << BFQG_stats_##name);\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\nstatic int bfqg_stats_##name(struct bfqg_stats *stats)\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\treturn (stats->flags & (1 << BFQG_stats_##name)) != 0;\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\n\nBFQG_FLAG_FNS(waiting)\nBFQG_FLAG_FNS(idling)\nBFQG_FLAG_FNS(empty)\n#undef BFQG_FLAG_FNS\n\n \nstatic void bfqg_stats_update_group_wait_time(struct bfqg_stats *stats)\n{\n\tu64 now;\n\n\tif (!bfqg_stats_waiting(stats))\n\t\treturn;\n\n\tnow = ktime_get_ns();\n\tif (now > stats->start_group_wait_time)\n\t\tbfq_stat_add(&stats->group_wait_time,\n\t\t\t      now - stats->start_group_wait_time);\n\tbfqg_stats_clear_waiting(stats);\n}\n\n \nstatic void bfqg_stats_set_start_group_wait_time(struct bfq_group *bfqg,\n\t\t\t\t\t\t struct bfq_group *curr_bfqg)\n{\n\tstruct bfqg_stats *stats = &bfqg->stats;\n\n\tif (bfqg_stats_waiting(stats))\n\t\treturn;\n\tif (bfqg == curr_bfqg)\n\t\treturn;\n\tstats->start_group_wait_time = ktime_get_ns();\n\tbfqg_stats_mark_waiting(stats);\n}\n\n \nstatic void bfqg_stats_end_empty_time(struct bfqg_stats *stats)\n{\n\tu64 now;\n\n\tif (!bfqg_stats_empty(stats))\n\t\treturn;\n\n\tnow = ktime_get_ns();\n\tif (now > stats->start_empty_time)\n\t\tbfq_stat_add(&stats->empty_time,\n\t\t\t      now - stats->start_empty_time);\n\tbfqg_stats_clear_empty(stats);\n}\n\nvoid bfqg_stats_update_dequeue(struct bfq_group *bfqg)\n{\n\tbfq_stat_add(&bfqg->stats.dequeue, 1);\n}\n\nvoid bfqg_stats_set_start_empty_time(struct bfq_group *bfqg)\n{\n\tstruct bfqg_stats *stats = &bfqg->stats;\n\n\tif (blkg_rwstat_total(&stats->queued))\n\t\treturn;\n\n\t \n\tif (bfqg_stats_empty(stats))\n\t\treturn;\n\n\tstats->start_empty_time = ktime_get_ns();\n\tbfqg_stats_mark_empty(stats);\n}\n\nvoid bfqg_stats_update_idle_time(struct bfq_group *bfqg)\n{\n\tstruct bfqg_stats *stats = &bfqg->stats;\n\n\tif (bfqg_stats_idling(stats)) {\n\t\tu64 now = ktime_get_ns();\n\n\t\tif (now > stats->start_idle_time)\n\t\t\tbfq_stat_add(&stats->idle_time,\n\t\t\t\t      now - stats->start_idle_time);\n\t\tbfqg_stats_clear_idling(stats);\n\t}\n}\n\nvoid bfqg_stats_set_start_idle_time(struct bfq_group *bfqg)\n{\n\tstruct bfqg_stats *stats = &bfqg->stats;\n\n\tstats->start_idle_time = ktime_get_ns();\n\tbfqg_stats_mark_idling(stats);\n}\n\nvoid bfqg_stats_update_avg_queue_size(struct bfq_group *bfqg)\n{\n\tstruct bfqg_stats *stats = &bfqg->stats;\n\n\tbfq_stat_add(&stats->avg_queue_size_sum,\n\t\t      blkg_rwstat_total(&stats->queued));\n\tbfq_stat_add(&stats->avg_queue_size_samples, 1);\n\tbfqg_stats_update_group_wait_time(stats);\n}\n\nvoid bfqg_stats_update_io_add(struct bfq_group *bfqg, struct bfq_queue *bfqq,\n\t\t\t      blk_opf_t opf)\n{\n\tblkg_rwstat_add(&bfqg->stats.queued, opf, 1);\n\tbfqg_stats_end_empty_time(&bfqg->stats);\n\tif (!(bfqq == bfqg->bfqd->in_service_queue))\n\t\tbfqg_stats_set_start_group_wait_time(bfqg, bfqq_group(bfqq));\n}\n\nvoid bfqg_stats_update_io_remove(struct bfq_group *bfqg, blk_opf_t opf)\n{\n\tblkg_rwstat_add(&bfqg->stats.queued, opf, -1);\n}\n\nvoid bfqg_stats_update_io_merged(struct bfq_group *bfqg, blk_opf_t opf)\n{\n\tblkg_rwstat_add(&bfqg->stats.merged, opf, 1);\n}\n\nvoid bfqg_stats_update_completion(struct bfq_group *bfqg, u64 start_time_ns,\n\t\t\t\t  u64 io_start_time_ns, blk_opf_t opf)\n{\n\tstruct bfqg_stats *stats = &bfqg->stats;\n\tu64 now = ktime_get_ns();\n\n\tif (now > io_start_time_ns)\n\t\tblkg_rwstat_add(&stats->service_time, opf,\n\t\t\t\tnow - io_start_time_ns);\n\tif (io_start_time_ns > start_time_ns)\n\t\tblkg_rwstat_add(&stats->wait_time, opf,\n\t\t\t\tio_start_time_ns - start_time_ns);\n}\n\n#else  \n\nvoid bfqg_stats_update_io_remove(struct bfq_group *bfqg, blk_opf_t opf) { }\nvoid bfqg_stats_update_io_merged(struct bfq_group *bfqg, blk_opf_t opf) { }\nvoid bfqg_stats_update_completion(struct bfq_group *bfqg, u64 start_time_ns,\n\t\t\t\t  u64 io_start_time_ns, blk_opf_t opf) { }\nvoid bfqg_stats_update_dequeue(struct bfq_group *bfqg) { }\nvoid bfqg_stats_set_start_idle_time(struct bfq_group *bfqg) { }\n\n#endif  \n\n#ifdef CONFIG_BFQ_GROUP_IOSCHED\n\n \n\nstatic struct bfq_group *pd_to_bfqg(struct blkg_policy_data *pd)\n{\n\treturn pd ? container_of(pd, struct bfq_group, pd) : NULL;\n}\n\nstruct blkcg_gq *bfqg_to_blkg(struct bfq_group *bfqg)\n{\n\treturn pd_to_blkg(&bfqg->pd);\n}\n\nstatic struct bfq_group *blkg_to_bfqg(struct blkcg_gq *blkg)\n{\n\treturn pd_to_bfqg(blkg_to_pd(blkg, &blkcg_policy_bfq));\n}\n\n \n\nstatic struct bfq_group *bfqg_parent(struct bfq_group *bfqg)\n{\n\tstruct blkcg_gq *pblkg = bfqg_to_blkg(bfqg)->parent;\n\n\treturn pblkg ? blkg_to_bfqg(pblkg) : NULL;\n}\n\nstruct bfq_group *bfqq_group(struct bfq_queue *bfqq)\n{\n\tstruct bfq_entity *group_entity = bfqq->entity.parent;\n\n\treturn group_entity ? container_of(group_entity, struct bfq_group,\n\t\t\t\t\t   entity) :\n\t\t\t      bfqq->bfqd->root_group;\n}\n\n \n\nstatic void bfqg_get(struct bfq_group *bfqg)\n{\n\trefcount_inc(&bfqg->ref);\n}\n\nstatic void bfqg_put(struct bfq_group *bfqg)\n{\n\tif (refcount_dec_and_test(&bfqg->ref))\n\t\tkfree(bfqg);\n}\n\nstatic void bfqg_and_blkg_get(struct bfq_group *bfqg)\n{\n\t \n\tbfqg_get(bfqg);\n\n\tblkg_get(bfqg_to_blkg(bfqg));\n}\n\nvoid bfqg_and_blkg_put(struct bfq_group *bfqg)\n{\n\tblkg_put(bfqg_to_blkg(bfqg));\n\n\tbfqg_put(bfqg);\n}\n\nvoid bfqg_stats_update_legacy_io(struct request_queue *q, struct request *rq)\n{\n\tstruct bfq_group *bfqg = blkg_to_bfqg(rq->bio->bi_blkg);\n\n\tif (!bfqg)\n\t\treturn;\n\n\tblkg_rwstat_add(&bfqg->stats.bytes, rq->cmd_flags, blk_rq_bytes(rq));\n\tblkg_rwstat_add(&bfqg->stats.ios, rq->cmd_flags, 1);\n}\n\n \nstatic void bfqg_stats_reset(struct bfqg_stats *stats)\n{\n#ifdef CONFIG_BFQ_CGROUP_DEBUG\n\t \n\tblkg_rwstat_reset(&stats->merged);\n\tblkg_rwstat_reset(&stats->service_time);\n\tblkg_rwstat_reset(&stats->wait_time);\n\tbfq_stat_reset(&stats->time);\n\tbfq_stat_reset(&stats->avg_queue_size_sum);\n\tbfq_stat_reset(&stats->avg_queue_size_samples);\n\tbfq_stat_reset(&stats->dequeue);\n\tbfq_stat_reset(&stats->group_wait_time);\n\tbfq_stat_reset(&stats->idle_time);\n\tbfq_stat_reset(&stats->empty_time);\n#endif\n}\n\n \nstatic void bfqg_stats_add_aux(struct bfqg_stats *to, struct bfqg_stats *from)\n{\n\tif (!to || !from)\n\t\treturn;\n\n#ifdef CONFIG_BFQ_CGROUP_DEBUG\n\t \n\tblkg_rwstat_add_aux(&to->merged, &from->merged);\n\tblkg_rwstat_add_aux(&to->service_time, &from->service_time);\n\tblkg_rwstat_add_aux(&to->wait_time, &from->wait_time);\n\tbfq_stat_add_aux(&from->time, &from->time);\n\tbfq_stat_add_aux(&to->avg_queue_size_sum, &from->avg_queue_size_sum);\n\tbfq_stat_add_aux(&to->avg_queue_size_samples,\n\t\t\t  &from->avg_queue_size_samples);\n\tbfq_stat_add_aux(&to->dequeue, &from->dequeue);\n\tbfq_stat_add_aux(&to->group_wait_time, &from->group_wait_time);\n\tbfq_stat_add_aux(&to->idle_time, &from->idle_time);\n\tbfq_stat_add_aux(&to->empty_time, &from->empty_time);\n#endif\n}\n\n \nstatic void bfqg_stats_xfer_dead(struct bfq_group *bfqg)\n{\n\tstruct bfq_group *parent;\n\n\tif (!bfqg)  \n\t\treturn;\n\n\tparent = bfqg_parent(bfqg);\n\n\tlockdep_assert_held(&bfqg_to_blkg(bfqg)->q->queue_lock);\n\n\tif (unlikely(!parent))\n\t\treturn;\n\n\tbfqg_stats_add_aux(&parent->stats, &bfqg->stats);\n\tbfqg_stats_reset(&bfqg->stats);\n}\n\nvoid bfq_init_entity(struct bfq_entity *entity, struct bfq_group *bfqg)\n{\n\tstruct bfq_queue *bfqq = bfq_entity_to_bfqq(entity);\n\n\tentity->weight = entity->new_weight;\n\tentity->orig_weight = entity->new_weight;\n\tif (bfqq) {\n\t\tbfqq->ioprio = bfqq->new_ioprio;\n\t\tbfqq->ioprio_class = bfqq->new_ioprio_class;\n\t\t \n\t\tbfqg_and_blkg_get(bfqg);\n\t}\n\tentity->parent = bfqg->my_entity;  \n\tentity->sched_data = &bfqg->sched_data;\n}\n\nstatic void bfqg_stats_exit(struct bfqg_stats *stats)\n{\n\tblkg_rwstat_exit(&stats->bytes);\n\tblkg_rwstat_exit(&stats->ios);\n#ifdef CONFIG_BFQ_CGROUP_DEBUG\n\tblkg_rwstat_exit(&stats->merged);\n\tblkg_rwstat_exit(&stats->service_time);\n\tblkg_rwstat_exit(&stats->wait_time);\n\tblkg_rwstat_exit(&stats->queued);\n\tbfq_stat_exit(&stats->time);\n\tbfq_stat_exit(&stats->avg_queue_size_sum);\n\tbfq_stat_exit(&stats->avg_queue_size_samples);\n\tbfq_stat_exit(&stats->dequeue);\n\tbfq_stat_exit(&stats->group_wait_time);\n\tbfq_stat_exit(&stats->idle_time);\n\tbfq_stat_exit(&stats->empty_time);\n#endif\n}\n\nstatic int bfqg_stats_init(struct bfqg_stats *stats, gfp_t gfp)\n{\n\tif (blkg_rwstat_init(&stats->bytes, gfp) ||\n\t    blkg_rwstat_init(&stats->ios, gfp))\n\t\tgoto error;\n\n#ifdef CONFIG_BFQ_CGROUP_DEBUG\n\tif (blkg_rwstat_init(&stats->merged, gfp) ||\n\t    blkg_rwstat_init(&stats->service_time, gfp) ||\n\t    blkg_rwstat_init(&stats->wait_time, gfp) ||\n\t    blkg_rwstat_init(&stats->queued, gfp) ||\n\t    bfq_stat_init(&stats->time, gfp) ||\n\t    bfq_stat_init(&stats->avg_queue_size_sum, gfp) ||\n\t    bfq_stat_init(&stats->avg_queue_size_samples, gfp) ||\n\t    bfq_stat_init(&stats->dequeue, gfp) ||\n\t    bfq_stat_init(&stats->group_wait_time, gfp) ||\n\t    bfq_stat_init(&stats->idle_time, gfp) ||\n\t    bfq_stat_init(&stats->empty_time, gfp))\n\t\tgoto error;\n#endif\n\n\treturn 0;\n\nerror:\n\tbfqg_stats_exit(stats);\n\treturn -ENOMEM;\n}\n\nstatic struct bfq_group_data *cpd_to_bfqgd(struct blkcg_policy_data *cpd)\n{\n\treturn cpd ? container_of(cpd, struct bfq_group_data, pd) : NULL;\n}\n\nstatic struct bfq_group_data *blkcg_to_bfqgd(struct blkcg *blkcg)\n{\n\treturn cpd_to_bfqgd(blkcg_to_cpd(blkcg, &blkcg_policy_bfq));\n}\n\nstatic struct blkcg_policy_data *bfq_cpd_alloc(gfp_t gfp)\n{\n\tstruct bfq_group_data *bgd;\n\n\tbgd = kzalloc(sizeof(*bgd), gfp);\n\tif (!bgd)\n\t\treturn NULL;\n\n\tbgd->weight = CGROUP_WEIGHT_DFL;\n\treturn &bgd->pd;\n}\n\nstatic void bfq_cpd_free(struct blkcg_policy_data *cpd)\n{\n\tkfree(cpd_to_bfqgd(cpd));\n}\n\nstatic struct blkg_policy_data *bfq_pd_alloc(struct gendisk *disk,\n\t\tstruct blkcg *blkcg, gfp_t gfp)\n{\n\tstruct bfq_group *bfqg;\n\n\tbfqg = kzalloc_node(sizeof(*bfqg), gfp, disk->node_id);\n\tif (!bfqg)\n\t\treturn NULL;\n\n\tif (bfqg_stats_init(&bfqg->stats, gfp)) {\n\t\tkfree(bfqg);\n\t\treturn NULL;\n\t}\n\n\t \n\trefcount_set(&bfqg->ref, 1);\n\treturn &bfqg->pd;\n}\n\nstatic void bfq_pd_init(struct blkg_policy_data *pd)\n{\n\tstruct blkcg_gq *blkg = pd_to_blkg(pd);\n\tstruct bfq_group *bfqg = blkg_to_bfqg(blkg);\n\tstruct bfq_data *bfqd = blkg->q->elevator->elevator_data;\n\tstruct bfq_entity *entity = &bfqg->entity;\n\tstruct bfq_group_data *d = blkcg_to_bfqgd(blkg->blkcg);\n\n\tentity->orig_weight = entity->weight = entity->new_weight = d->weight;\n\tentity->my_sched_data = &bfqg->sched_data;\n\tentity->last_bfqq_created = NULL;\n\n\tbfqg->my_entity = entity;  \n\tbfqg->bfqd = bfqd;\n\tbfqg->active_entities = 0;\n\tbfqg->num_queues_with_pending_reqs = 0;\n\tbfqg->rq_pos_tree = RB_ROOT;\n}\n\nstatic void bfq_pd_free(struct blkg_policy_data *pd)\n{\n\tstruct bfq_group *bfqg = pd_to_bfqg(pd);\n\n\tbfqg_stats_exit(&bfqg->stats);\n\tbfqg_put(bfqg);\n}\n\nstatic void bfq_pd_reset_stats(struct blkg_policy_data *pd)\n{\n\tstruct bfq_group *bfqg = pd_to_bfqg(pd);\n\n\tbfqg_stats_reset(&bfqg->stats);\n}\n\nstatic void bfq_group_set_parent(struct bfq_group *bfqg,\n\t\t\t\t\tstruct bfq_group *parent)\n{\n\tstruct bfq_entity *entity;\n\n\tentity = &bfqg->entity;\n\tentity->parent = parent->my_entity;\n\tentity->sched_data = &parent->sched_data;\n}\n\nstatic void bfq_link_bfqg(struct bfq_data *bfqd, struct bfq_group *bfqg)\n{\n\tstruct bfq_group *parent;\n\tstruct bfq_entity *entity;\n\n\t \n\tentity = &bfqg->entity;\n\tfor_each_entity(entity) {\n\t\tstruct bfq_group *curr_bfqg = container_of(entity,\n\t\t\t\t\t\tstruct bfq_group, entity);\n\t\tif (curr_bfqg != bfqd->root_group) {\n\t\t\tparent = bfqg_parent(curr_bfqg);\n\t\t\tif (!parent)\n\t\t\t\tparent = bfqd->root_group;\n\t\t\tbfq_group_set_parent(curr_bfqg, parent);\n\t\t}\n\t}\n}\n\nstruct bfq_group *bfq_bio_bfqg(struct bfq_data *bfqd, struct bio *bio)\n{\n\tstruct blkcg_gq *blkg = bio->bi_blkg;\n\tstruct bfq_group *bfqg;\n\n\twhile (blkg) {\n\t\tif (!blkg->online) {\n\t\t\tblkg = blkg->parent;\n\t\t\tcontinue;\n\t\t}\n\t\tbfqg = blkg_to_bfqg(blkg);\n\t\tif (bfqg->pd.online) {\n\t\t\tbio_associate_blkg_from_css(bio, &blkg->blkcg->css);\n\t\t\treturn bfqg;\n\t\t}\n\t\tblkg = blkg->parent;\n\t}\n\tbio_associate_blkg_from_css(bio,\n\t\t\t\t&bfqg_to_blkg(bfqd->root_group)->blkcg->css);\n\treturn bfqd->root_group;\n}\n\n \nvoid bfq_bfqq_move(struct bfq_data *bfqd, struct bfq_queue *bfqq,\n\t\t   struct bfq_group *bfqg)\n{\n\tstruct bfq_entity *entity = &bfqq->entity;\n\tstruct bfq_group *old_parent = bfqq_group(bfqq);\n\tbool has_pending_reqs = false;\n\n\t \n\tif (old_parent == bfqg)\n\t\treturn;\n\n\t \n\tif (bfqq == &bfqd->oom_bfqq)\n\t\treturn;\n\t \n\tbfqq->ref++;\n\n\tif (entity->in_groups_with_pending_reqs) {\n\t\thas_pending_reqs = true;\n\t\tbfq_del_bfqq_in_groups_with_pending_reqs(bfqq);\n\t}\n\n\t \n\tif (bfqq == bfqd->in_service_queue)\n\t\tbfq_bfqq_expire(bfqd, bfqd->in_service_queue,\n\t\t\t\tfalse, BFQQE_PREEMPTED);\n\n\tif (bfq_bfqq_busy(bfqq))\n\t\tbfq_deactivate_bfqq(bfqd, bfqq, false, false);\n\telse if (entity->on_st_or_in_serv)\n\t\tbfq_put_idle_entity(bfq_entity_service_tree(entity), entity);\n\tbfqg_and_blkg_put(old_parent);\n\n\tif (entity->parent &&\n\t    entity->parent->last_bfqq_created == bfqq)\n\t\tentity->parent->last_bfqq_created = NULL;\n\telse if (bfqd->last_bfqq_created == bfqq)\n\t\tbfqd->last_bfqq_created = NULL;\n\n\tentity->parent = bfqg->my_entity;\n\tentity->sched_data = &bfqg->sched_data;\n\t \n\tbfqg_and_blkg_get(bfqg);\n\n\tif (has_pending_reqs)\n\t\tbfq_add_bfqq_in_groups_with_pending_reqs(bfqq);\n\n\tif (bfq_bfqq_busy(bfqq)) {\n\t\tif (unlikely(!bfqd->nonrot_with_queueing))\n\t\t\tbfq_pos_tree_add_move(bfqd, bfqq);\n\t\tbfq_activate_bfqq(bfqd, bfqq);\n\t}\n\n\tif (!bfqd->in_service_queue && !bfqd->tot_rq_in_driver)\n\t\tbfq_schedule_dispatch(bfqd);\n\t \n\tbfq_put_queue(bfqq);\n}\n\nstatic void bfq_sync_bfqq_move(struct bfq_data *bfqd,\n\t\t\t       struct bfq_queue *sync_bfqq,\n\t\t\t       struct bfq_io_cq *bic,\n\t\t\t       struct bfq_group *bfqg,\n\t\t\t       unsigned int act_idx)\n{\n\tstruct bfq_queue *bfqq;\n\n\tif (!sync_bfqq->new_bfqq && !bfq_bfqq_coop(sync_bfqq)) {\n\t\t \n\t\tif (sync_bfqq->entity.sched_data != &bfqg->sched_data)\n\t\t\tbfq_bfqq_move(bfqd, sync_bfqq, bfqg);\n\t\treturn;\n\t}\n\n\t \n\tfor (bfqq = sync_bfqq; bfqq; bfqq = bfqq->new_bfqq)\n\t\tif (bfqq->entity.sched_data != &bfqg->sched_data)\n\t\t\tbreak;\n\tif (bfqq) {\n\t\t \n\t\tbfq_put_cooperator(sync_bfqq);\n\t\tbic_set_bfqq(bic, NULL, true, act_idx);\n\t\tbfq_release_process_ref(bfqd, sync_bfqq);\n\t}\n}\n\n \nstatic void __bfq_bic_change_cgroup(struct bfq_data *bfqd,\n\t\t\t\t    struct bfq_io_cq *bic,\n\t\t\t\t    struct bfq_group *bfqg)\n{\n\tunsigned int act_idx;\n\n\tfor (act_idx = 0; act_idx < bfqd->num_actuators; act_idx++) {\n\t\tstruct bfq_queue *async_bfqq = bic_to_bfqq(bic, false, act_idx);\n\t\tstruct bfq_queue *sync_bfqq = bic_to_bfqq(bic, true, act_idx);\n\n\t\tif (async_bfqq &&\n\t\t    async_bfqq->entity.sched_data != &bfqg->sched_data) {\n\t\t\tbic_set_bfqq(bic, NULL, false, act_idx);\n\t\t\tbfq_release_process_ref(bfqd, async_bfqq);\n\t\t}\n\n\t\tif (sync_bfqq)\n\t\t\tbfq_sync_bfqq_move(bfqd, sync_bfqq, bic, bfqg, act_idx);\n\t}\n}\n\nvoid bfq_bic_update_cgroup(struct bfq_io_cq *bic, struct bio *bio)\n{\n\tstruct bfq_data *bfqd = bic_to_bfqd(bic);\n\tstruct bfq_group *bfqg = bfq_bio_bfqg(bfqd, bio);\n\tuint64_t serial_nr;\n\n\tserial_nr = bfqg_to_blkg(bfqg)->blkcg->css.serial_nr;\n\n\t \n\tif (unlikely(!bfqd) || likely(bic->blkcg_serial_nr == serial_nr))\n\t\treturn;\n\n\t \n\tbfq_link_bfqg(bfqd, bfqg);\n\t__bfq_bic_change_cgroup(bfqd, bic, bfqg);\n\t \n\tblkg_path(bfqg_to_blkg(bfqg), bfqg->blkg_path, sizeof(bfqg->blkg_path));\n\tbic->blkcg_serial_nr = serial_nr;\n}\n\n \nstatic void bfq_flush_idle_tree(struct bfq_service_tree *st)\n{\n\tstruct bfq_entity *entity = st->first_idle;\n\n\tfor (; entity ; entity = st->first_idle)\n\t\t__bfq_deactivate_entity(entity, false);\n}\n\n \nstatic void bfq_reparent_leaf_entity(struct bfq_data *bfqd,\n\t\t\t\t     struct bfq_entity *entity,\n\t\t\t\t     int ioprio_class)\n{\n\tstruct bfq_queue *bfqq;\n\tstruct bfq_entity *child_entity = entity;\n\n\twhile (child_entity->my_sched_data) {  \n\t\tstruct bfq_sched_data *child_sd = child_entity->my_sched_data;\n\t\tstruct bfq_service_tree *child_st = child_sd->service_tree +\n\t\t\tioprio_class;\n\t\tstruct rb_root *child_active = &child_st->active;\n\n\t\tchild_entity = bfq_entity_of(rb_first(child_active));\n\n\t\tif (!child_entity)\n\t\t\tchild_entity = child_sd->in_service_entity;\n\t}\n\n\tbfqq = bfq_entity_to_bfqq(child_entity);\n\tbfq_bfqq_move(bfqd, bfqq, bfqd->root_group);\n}\n\n \nstatic void bfq_reparent_active_queues(struct bfq_data *bfqd,\n\t\t\t\t       struct bfq_group *bfqg,\n\t\t\t\t       struct bfq_service_tree *st,\n\t\t\t\t       int ioprio_class)\n{\n\tstruct rb_root *active = &st->active;\n\tstruct bfq_entity *entity;\n\n\twhile ((entity = bfq_entity_of(rb_first(active))))\n\t\tbfq_reparent_leaf_entity(bfqd, entity, ioprio_class);\n\n\tif (bfqg->sched_data.in_service_entity)\n\t\tbfq_reparent_leaf_entity(bfqd,\n\t\t\t\t\t bfqg->sched_data.in_service_entity,\n\t\t\t\t\t ioprio_class);\n}\n\n \nstatic void bfq_pd_offline(struct blkg_policy_data *pd)\n{\n\tstruct bfq_service_tree *st;\n\tstruct bfq_group *bfqg = pd_to_bfqg(pd);\n\tstruct bfq_data *bfqd = bfqg->bfqd;\n\tstruct bfq_entity *entity = bfqg->my_entity;\n\tunsigned long flags;\n\tint i;\n\n\tspin_lock_irqsave(&bfqd->lock, flags);\n\n\tif (!entity)  \n\t\tgoto put_async_queues;\n\n\t \n\tfor (i = 0; i < BFQ_IOPRIO_CLASSES; i++) {\n\t\tst = bfqg->sched_data.service_tree + i;\n\n\t\t \n\t\tbfq_reparent_active_queues(bfqd, bfqg, st, i);\n\n\t\t \n\t\tbfq_flush_idle_tree(st);\n\t}\n\n\t__bfq_deactivate_entity(entity, false);\n\nput_async_queues:\n\tbfq_put_async_queues(bfqd, bfqg);\n\n\tspin_unlock_irqrestore(&bfqd->lock, flags);\n\t \n\tbfqg_stats_xfer_dead(bfqg);\n}\n\nvoid bfq_end_wr_async(struct bfq_data *bfqd)\n{\n\tstruct blkcg_gq *blkg;\n\n\tlist_for_each_entry(blkg, &bfqd->queue->blkg_list, q_node) {\n\t\tstruct bfq_group *bfqg = blkg_to_bfqg(blkg);\n\n\t\tbfq_end_wr_async_queues(bfqd, bfqg);\n\t}\n\tbfq_end_wr_async_queues(bfqd, bfqd->root_group);\n}\n\nstatic int bfq_io_show_weight_legacy(struct seq_file *sf, void *v)\n{\n\tstruct blkcg *blkcg = css_to_blkcg(seq_css(sf));\n\tstruct bfq_group_data *bfqgd = blkcg_to_bfqgd(blkcg);\n\tunsigned int val = 0;\n\n\tif (bfqgd)\n\t\tval = bfqgd->weight;\n\n\tseq_printf(sf, \"%u\\n\", val);\n\n\treturn 0;\n}\n\nstatic u64 bfqg_prfill_weight_device(struct seq_file *sf,\n\t\t\t\t     struct blkg_policy_data *pd, int off)\n{\n\tstruct bfq_group *bfqg = pd_to_bfqg(pd);\n\n\tif (!bfqg->entity.dev_weight)\n\t\treturn 0;\n\treturn __blkg_prfill_u64(sf, pd, bfqg->entity.dev_weight);\n}\n\nstatic int bfq_io_show_weight(struct seq_file *sf, void *v)\n{\n\tstruct blkcg *blkcg = css_to_blkcg(seq_css(sf));\n\tstruct bfq_group_data *bfqgd = blkcg_to_bfqgd(blkcg);\n\n\tseq_printf(sf, \"default %u\\n\", bfqgd->weight);\n\tblkcg_print_blkgs(sf, blkcg, bfqg_prfill_weight_device,\n\t\t\t  &blkcg_policy_bfq, 0, false);\n\treturn 0;\n}\n\nstatic void bfq_group_set_weight(struct bfq_group *bfqg, u64 weight, u64 dev_weight)\n{\n\tweight = dev_weight ?: weight;\n\n\tbfqg->entity.dev_weight = dev_weight;\n\t \n\tif ((unsigned short)weight != bfqg->entity.new_weight) {\n\t\tbfqg->entity.new_weight = (unsigned short)weight;\n\t\t \n\t\tsmp_wmb();\n\t\tbfqg->entity.prio_changed = 1;\n\t}\n}\n\nstatic int bfq_io_set_weight_legacy(struct cgroup_subsys_state *css,\n\t\t\t\t    struct cftype *cftype,\n\t\t\t\t    u64 val)\n{\n\tstruct blkcg *blkcg = css_to_blkcg(css);\n\tstruct bfq_group_data *bfqgd = blkcg_to_bfqgd(blkcg);\n\tstruct blkcg_gq *blkg;\n\tint ret = -ERANGE;\n\n\tif (val < BFQ_MIN_WEIGHT || val > BFQ_MAX_WEIGHT)\n\t\treturn ret;\n\n\tret = 0;\n\tspin_lock_irq(&blkcg->lock);\n\tbfqgd->weight = (unsigned short)val;\n\thlist_for_each_entry(blkg, &blkcg->blkg_list, blkcg_node) {\n\t\tstruct bfq_group *bfqg = blkg_to_bfqg(blkg);\n\n\t\tif (bfqg)\n\t\t\tbfq_group_set_weight(bfqg, val, 0);\n\t}\n\tspin_unlock_irq(&blkcg->lock);\n\n\treturn ret;\n}\n\nstatic ssize_t bfq_io_set_device_weight(struct kernfs_open_file *of,\n\t\t\t\t\tchar *buf, size_t nbytes,\n\t\t\t\t\tloff_t off)\n{\n\tint ret;\n\tstruct blkg_conf_ctx ctx;\n\tstruct blkcg *blkcg = css_to_blkcg(of_css(of));\n\tstruct bfq_group *bfqg;\n\tu64 v;\n\n\tblkg_conf_init(&ctx, buf);\n\n\tret = blkg_conf_prep(blkcg, &blkcg_policy_bfq, &ctx);\n\tif (ret)\n\t\tgoto out;\n\n\tif (sscanf(ctx.body, \"%llu\", &v) == 1) {\n\t\t \n\t\tret = -ERANGE;\n\t\tif (!v)\n\t\t\tgoto out;\n\t} else if (!strcmp(strim(ctx.body), \"default\")) {\n\t\tv = 0;\n\t} else {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tbfqg = blkg_to_bfqg(ctx.blkg);\n\n\tret = -ERANGE;\n\tif (!v || (v >= BFQ_MIN_WEIGHT && v <= BFQ_MAX_WEIGHT)) {\n\t\tbfq_group_set_weight(bfqg, bfqg->entity.weight, v);\n\t\tret = 0;\n\t}\nout:\n\tblkg_conf_exit(&ctx);\n\treturn ret ?: nbytes;\n}\n\nstatic ssize_t bfq_io_set_weight(struct kernfs_open_file *of,\n\t\t\t\t char *buf, size_t nbytes,\n\t\t\t\t loff_t off)\n{\n\tchar *endp;\n\tint ret;\n\tu64 v;\n\n\tbuf = strim(buf);\n\n\t \n\tv = simple_strtoull(buf, &endp, 0);\n\tif (*endp == '\\0' || sscanf(buf, \"default %llu\", &v) == 1) {\n\t\tret = bfq_io_set_weight_legacy(of_css(of), NULL, v);\n\t\treturn ret ?: nbytes;\n\t}\n\n\treturn bfq_io_set_device_weight(of, buf, nbytes, off);\n}\n\nstatic int bfqg_print_rwstat(struct seq_file *sf, void *v)\n{\n\tblkcg_print_blkgs(sf, css_to_blkcg(seq_css(sf)), blkg_prfill_rwstat,\n\t\t\t  &blkcg_policy_bfq, seq_cft(sf)->private, true);\n\treturn 0;\n}\n\nstatic u64 bfqg_prfill_rwstat_recursive(struct seq_file *sf,\n\t\t\t\t\tstruct blkg_policy_data *pd, int off)\n{\n\tstruct blkg_rwstat_sample sum;\n\n\tblkg_rwstat_recursive_sum(pd_to_blkg(pd), &blkcg_policy_bfq, off, &sum);\n\treturn __blkg_prfill_rwstat(sf, pd, &sum);\n}\n\nstatic int bfqg_print_rwstat_recursive(struct seq_file *sf, void *v)\n{\n\tblkcg_print_blkgs(sf, css_to_blkcg(seq_css(sf)),\n\t\t\t  bfqg_prfill_rwstat_recursive, &blkcg_policy_bfq,\n\t\t\t  seq_cft(sf)->private, true);\n\treturn 0;\n}\n\n#ifdef CONFIG_BFQ_CGROUP_DEBUG\nstatic int bfqg_print_stat(struct seq_file *sf, void *v)\n{\n\tblkcg_print_blkgs(sf, css_to_blkcg(seq_css(sf)), blkg_prfill_stat,\n\t\t\t  &blkcg_policy_bfq, seq_cft(sf)->private, false);\n\treturn 0;\n}\n\nstatic u64 bfqg_prfill_stat_recursive(struct seq_file *sf,\n\t\t\t\t      struct blkg_policy_data *pd, int off)\n{\n\tstruct blkcg_gq *blkg = pd_to_blkg(pd);\n\tstruct blkcg_gq *pos_blkg;\n\tstruct cgroup_subsys_state *pos_css;\n\tu64 sum = 0;\n\n\tlockdep_assert_held(&blkg->q->queue_lock);\n\n\trcu_read_lock();\n\tblkg_for_each_descendant_pre(pos_blkg, pos_css, blkg) {\n\t\tstruct bfq_stat *stat;\n\n\t\tif (!pos_blkg->online)\n\t\t\tcontinue;\n\n\t\tstat = (void *)blkg_to_pd(pos_blkg, &blkcg_policy_bfq) + off;\n\t\tsum += bfq_stat_read(stat) + atomic64_read(&stat->aux_cnt);\n\t}\n\trcu_read_unlock();\n\n\treturn __blkg_prfill_u64(sf, pd, sum);\n}\n\nstatic int bfqg_print_stat_recursive(struct seq_file *sf, void *v)\n{\n\tblkcg_print_blkgs(sf, css_to_blkcg(seq_css(sf)),\n\t\t\t  bfqg_prfill_stat_recursive, &blkcg_policy_bfq,\n\t\t\t  seq_cft(sf)->private, false);\n\treturn 0;\n}\n\nstatic u64 bfqg_prfill_sectors(struct seq_file *sf, struct blkg_policy_data *pd,\n\t\t\t       int off)\n{\n\tstruct bfq_group *bfqg = blkg_to_bfqg(pd->blkg);\n\tu64 sum = blkg_rwstat_total(&bfqg->stats.bytes);\n\n\treturn __blkg_prfill_u64(sf, pd, sum >> 9);\n}\n\nstatic int bfqg_print_stat_sectors(struct seq_file *sf, void *v)\n{\n\tblkcg_print_blkgs(sf, css_to_blkcg(seq_css(sf)),\n\t\t\t  bfqg_prfill_sectors, &blkcg_policy_bfq, 0, false);\n\treturn 0;\n}\n\nstatic u64 bfqg_prfill_sectors_recursive(struct seq_file *sf,\n\t\t\t\t\t struct blkg_policy_data *pd, int off)\n{\n\tstruct blkg_rwstat_sample tmp;\n\n\tblkg_rwstat_recursive_sum(pd->blkg, &blkcg_policy_bfq,\n\t\t\toffsetof(struct bfq_group, stats.bytes), &tmp);\n\n\treturn __blkg_prfill_u64(sf, pd,\n\t\t(tmp.cnt[BLKG_RWSTAT_READ] + tmp.cnt[BLKG_RWSTAT_WRITE]) >> 9);\n}\n\nstatic int bfqg_print_stat_sectors_recursive(struct seq_file *sf, void *v)\n{\n\tblkcg_print_blkgs(sf, css_to_blkcg(seq_css(sf)),\n\t\t\t  bfqg_prfill_sectors_recursive, &blkcg_policy_bfq, 0,\n\t\t\t  false);\n\treturn 0;\n}\n\nstatic u64 bfqg_prfill_avg_queue_size(struct seq_file *sf,\n\t\t\t\t      struct blkg_policy_data *pd, int off)\n{\n\tstruct bfq_group *bfqg = pd_to_bfqg(pd);\n\tu64 samples = bfq_stat_read(&bfqg->stats.avg_queue_size_samples);\n\tu64 v = 0;\n\n\tif (samples) {\n\t\tv = bfq_stat_read(&bfqg->stats.avg_queue_size_sum);\n\t\tv = div64_u64(v, samples);\n\t}\n\t__blkg_prfill_u64(sf, pd, v);\n\treturn 0;\n}\n\n \nstatic int bfqg_print_avg_queue_size(struct seq_file *sf, void *v)\n{\n\tblkcg_print_blkgs(sf, css_to_blkcg(seq_css(sf)),\n\t\t\t  bfqg_prfill_avg_queue_size, &blkcg_policy_bfq,\n\t\t\t  0, false);\n\treturn 0;\n}\n#endif  \n\nstruct bfq_group *bfq_create_group_hierarchy(struct bfq_data *bfqd, int node)\n{\n\tint ret;\n\n\tret = blkcg_activate_policy(bfqd->queue->disk, &blkcg_policy_bfq);\n\tif (ret)\n\t\treturn NULL;\n\n\treturn blkg_to_bfqg(bfqd->queue->root_blkg);\n}\n\nstruct blkcg_policy blkcg_policy_bfq = {\n\t.dfl_cftypes\t\t= bfq_blkg_files,\n\t.legacy_cftypes\t\t= bfq_blkcg_legacy_files,\n\n\t.cpd_alloc_fn\t\t= bfq_cpd_alloc,\n\t.cpd_free_fn\t\t= bfq_cpd_free,\n\n\t.pd_alloc_fn\t\t= bfq_pd_alloc,\n\t.pd_init_fn\t\t= bfq_pd_init,\n\t.pd_offline_fn\t\t= bfq_pd_offline,\n\t.pd_free_fn\t\t= bfq_pd_free,\n\t.pd_reset_stats_fn\t= bfq_pd_reset_stats,\n};\n\nstruct cftype bfq_blkcg_legacy_files[] = {\n\t{\n\t\t.name = \"bfq.weight\",\n\t\t.flags = CFTYPE_NOT_ON_ROOT,\n\t\t.seq_show = bfq_io_show_weight_legacy,\n\t\t.write_u64 = bfq_io_set_weight_legacy,\n\t},\n\t{\n\t\t.name = \"bfq.weight_device\",\n\t\t.flags = CFTYPE_NOT_ON_ROOT,\n\t\t.seq_show = bfq_io_show_weight,\n\t\t.write = bfq_io_set_weight,\n\t},\n\n\t \n\t{\n\t\t.name = \"bfq.io_service_bytes\",\n\t\t.private = offsetof(struct bfq_group, stats.bytes),\n\t\t.seq_show = bfqg_print_rwstat,\n\t},\n\t{\n\t\t.name = \"bfq.io_serviced\",\n\t\t.private = offsetof(struct bfq_group, stats.ios),\n\t\t.seq_show = bfqg_print_rwstat,\n\t},\n#ifdef CONFIG_BFQ_CGROUP_DEBUG\n\t{\n\t\t.name = \"bfq.time\",\n\t\t.private = offsetof(struct bfq_group, stats.time),\n\t\t.seq_show = bfqg_print_stat,\n\t},\n\t{\n\t\t.name = \"bfq.sectors\",\n\t\t.seq_show = bfqg_print_stat_sectors,\n\t},\n\t{\n\t\t.name = \"bfq.io_service_time\",\n\t\t.private = offsetof(struct bfq_group, stats.service_time),\n\t\t.seq_show = bfqg_print_rwstat,\n\t},\n\t{\n\t\t.name = \"bfq.io_wait_time\",\n\t\t.private = offsetof(struct bfq_group, stats.wait_time),\n\t\t.seq_show = bfqg_print_rwstat,\n\t},\n\t{\n\t\t.name = \"bfq.io_merged\",\n\t\t.private = offsetof(struct bfq_group, stats.merged),\n\t\t.seq_show = bfqg_print_rwstat,\n\t},\n\t{\n\t\t.name = \"bfq.io_queued\",\n\t\t.private = offsetof(struct bfq_group, stats.queued),\n\t\t.seq_show = bfqg_print_rwstat,\n\t},\n#endif  \n\n\t \n\t{\n\t\t.name = \"bfq.io_service_bytes_recursive\",\n\t\t.private = offsetof(struct bfq_group, stats.bytes),\n\t\t.seq_show = bfqg_print_rwstat_recursive,\n\t},\n\t{\n\t\t.name = \"bfq.io_serviced_recursive\",\n\t\t.private = offsetof(struct bfq_group, stats.ios),\n\t\t.seq_show = bfqg_print_rwstat_recursive,\n\t},\n#ifdef CONFIG_BFQ_CGROUP_DEBUG\n\t{\n\t\t.name = \"bfq.time_recursive\",\n\t\t.private = offsetof(struct bfq_group, stats.time),\n\t\t.seq_show = bfqg_print_stat_recursive,\n\t},\n\t{\n\t\t.name = \"bfq.sectors_recursive\",\n\t\t.seq_show = bfqg_print_stat_sectors_recursive,\n\t},\n\t{\n\t\t.name = \"bfq.io_service_time_recursive\",\n\t\t.private = offsetof(struct bfq_group, stats.service_time),\n\t\t.seq_show = bfqg_print_rwstat_recursive,\n\t},\n\t{\n\t\t.name = \"bfq.io_wait_time_recursive\",\n\t\t.private = offsetof(struct bfq_group, stats.wait_time),\n\t\t.seq_show = bfqg_print_rwstat_recursive,\n\t},\n\t{\n\t\t.name = \"bfq.io_merged_recursive\",\n\t\t.private = offsetof(struct bfq_group, stats.merged),\n\t\t.seq_show = bfqg_print_rwstat_recursive,\n\t},\n\t{\n\t\t.name = \"bfq.io_queued_recursive\",\n\t\t.private = offsetof(struct bfq_group, stats.queued),\n\t\t.seq_show = bfqg_print_rwstat_recursive,\n\t},\n\t{\n\t\t.name = \"bfq.avg_queue_size\",\n\t\t.seq_show = bfqg_print_avg_queue_size,\n\t},\n\t{\n\t\t.name = \"bfq.group_wait_time\",\n\t\t.private = offsetof(struct bfq_group, stats.group_wait_time),\n\t\t.seq_show = bfqg_print_stat,\n\t},\n\t{\n\t\t.name = \"bfq.idle_time\",\n\t\t.private = offsetof(struct bfq_group, stats.idle_time),\n\t\t.seq_show = bfqg_print_stat,\n\t},\n\t{\n\t\t.name = \"bfq.empty_time\",\n\t\t.private = offsetof(struct bfq_group, stats.empty_time),\n\t\t.seq_show = bfqg_print_stat,\n\t},\n\t{\n\t\t.name = \"bfq.dequeue\",\n\t\t.private = offsetof(struct bfq_group, stats.dequeue),\n\t\t.seq_show = bfqg_print_stat,\n\t},\n#endif\t \n\t{ }\t \n};\n\nstruct cftype bfq_blkg_files[] = {\n\t{\n\t\t.name = \"bfq.weight\",\n\t\t.flags = CFTYPE_NOT_ON_ROOT,\n\t\t.seq_show = bfq_io_show_weight,\n\t\t.write = bfq_io_set_weight,\n\t},\n\t{}  \n};\n\n#else\t \n\nvoid bfq_bfqq_move(struct bfq_data *bfqd, struct bfq_queue *bfqq,\n\t\t   struct bfq_group *bfqg) {}\n\nvoid bfq_init_entity(struct bfq_entity *entity, struct bfq_group *bfqg)\n{\n\tstruct bfq_queue *bfqq = bfq_entity_to_bfqq(entity);\n\n\tentity->weight = entity->new_weight;\n\tentity->orig_weight = entity->new_weight;\n\tif (bfqq) {\n\t\tbfqq->ioprio = bfqq->new_ioprio;\n\t\tbfqq->ioprio_class = bfqq->new_ioprio_class;\n\t}\n\tentity->sched_data = &bfqg->sched_data;\n}\n\nvoid bfq_bic_update_cgroup(struct bfq_io_cq *bic, struct bio *bio) {}\n\nvoid bfq_end_wr_async(struct bfq_data *bfqd)\n{\n\tbfq_end_wr_async_queues(bfqd, bfqd->root_group);\n}\n\nstruct bfq_group *bfq_bio_bfqg(struct bfq_data *bfqd, struct bio *bio)\n{\n\treturn bfqd->root_group;\n}\n\nstruct bfq_group *bfqq_group(struct bfq_queue *bfqq)\n{\n\treturn bfqq->bfqd->root_group;\n}\n\nvoid bfqg_and_blkg_put(struct bfq_group *bfqg) {}\n\nstruct bfq_group *bfq_create_group_hierarchy(struct bfq_data *bfqd, int node)\n{\n\tstruct bfq_group *bfqg;\n\tint i;\n\n\tbfqg = kmalloc_node(sizeof(*bfqg), GFP_KERNEL | __GFP_ZERO, node);\n\tif (!bfqg)\n\t\treturn NULL;\n\n\tfor (i = 0; i < BFQ_IOPRIO_CLASSES; i++)\n\t\tbfqg->sched_data.service_tree[i] = BFQ_SERVICE_TREE_INIT;\n\n\treturn bfqg;\n}\n#endif\t \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}