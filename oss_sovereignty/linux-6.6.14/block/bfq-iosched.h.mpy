{
  "module_name": "bfq-iosched.h",
  "hash_id": "3a753e222100e1af1454c6b3220d9a017188bdc2418b82c58b3914d8734e97dd",
  "original_prompt": "Ingested from linux-6.6.14/block/bfq-iosched.h",
  "human_readable_source": " \n \n#ifndef _BFQ_H\n#define _BFQ_H\n\n#include <linux/blktrace_api.h>\n#include <linux/hrtimer.h>\n\n#include \"blk-cgroup-rwstat.h\"\n\n#define BFQ_IOPRIO_CLASSES\t3\n#define BFQ_CL_IDLE_TIMEOUT\t(HZ/5)\n\n#define BFQ_MIN_WEIGHT\t\t\t1\n#define BFQ_MAX_WEIGHT\t\t\t1000\n#define BFQ_WEIGHT_CONVERSION_COEFF\t10\n\n#define BFQ_DEFAULT_QUEUE_IOPRIO\t4\n\n#define BFQ_DEFAULT_GRP_IOPRIO\t0\n#define BFQ_DEFAULT_GRP_CLASS\tIOPRIO_CLASS_BE\n\n#define MAX_BFQQ_NAME_LENGTH 16\n\n \n#define BFQ_SOFTRT_WEIGHT_FACTOR\t100\n\n \n#define BFQ_MAX_ACTUATORS 8\n\nstruct bfq_entity;\n\n \nstruct bfq_service_tree {\n\t \n\tstruct rb_root active;\n\t \n\tstruct rb_root idle;\n\n\t \n\tstruct bfq_entity *first_idle;\n\t \n\tstruct bfq_entity *last_idle;\n\n\t \n\tu64 vtime;\n\t \n\tunsigned long wsum;\n};\n\n \nstruct bfq_sched_data {\n\t \n\tstruct bfq_entity *in_service_entity;\n\t \n\tstruct bfq_entity *next_in_service;\n\t \n\tstruct bfq_service_tree service_tree[BFQ_IOPRIO_CLASSES];\n\t \n\tunsigned long bfq_class_idle_last_service;\n\n};\n\n \nstruct bfq_weight_counter {\n\tunsigned int weight;  \n\tunsigned int num_active;  \n\t \n\tstruct rb_node weights_node;\n};\n\n \nstruct bfq_entity {\n\t \n\tstruct rb_node rb_node;\n\n\t \n\tbool on_st_or_in_serv;\n\n\t \n\tu64 start, finish;\n\n\t \n\tstruct rb_root *tree;\n\n\t \n\tu64 min_start;\n\n\t \n\tint service;\n\n\t \n\tint budget;\n\n\t \n\tint allocated;\n\n\t \n\tint dev_weight;\n\t \n\tint weight;\n\t \n\tint new_weight;\n\n\t \n\tint orig_weight;\n\n\t \n\tstruct bfq_entity *parent;\n\n\t \n\tstruct bfq_sched_data *my_sched_data;\n\t \n\tstruct bfq_sched_data *sched_data;\n\n\t \n\tint prio_changed;\n\n#ifdef CONFIG_BFQ_GROUP_IOSCHED\n\t \n\tbool in_groups_with_pending_reqs;\n#endif\n\n\t \n\tstruct bfq_queue *last_bfqq_created;\n};\n\nstruct bfq_group;\n\n \nstruct bfq_ttime {\n\t \n\tu64 last_end_request;\n\n\t \n\tu64 ttime_total;\n\t \n\tunsigned long ttime_samples;\n\t \n\tu64 ttime_mean;\n};\n\n \nstruct bfq_queue {\n\t \n\tint ref;\n\t \n\tint stable_ref;\n\t \n\tstruct bfq_data *bfqd;\n\n\t \n\tunsigned short ioprio, ioprio_class;\n\t \n\tunsigned short new_ioprio, new_ioprio_class;\n\n\t \n\tu64 last_serv_time_ns;\n\t \n\tunsigned int inject_limit;\n\t \n\tunsigned long decrease_time_jif;\n\n\t \n\tstruct bfq_queue *new_bfqq;\n\t \n\tstruct rb_node pos_node;\n\t \n\tstruct rb_root *pos_root;\n\n\t \n\tstruct rb_root sort_list;\n\t \n\tstruct request *next_rq;\n\t \n\tint queued[2];\n\t \n\tint meta_pending;\n\t \n\tstruct list_head fifo;\n\n\t \n\tstruct bfq_entity entity;\n\n\t \n\tstruct bfq_weight_counter *weight_counter;\n\n\t \n\tint max_budget;\n\t \n\tunsigned long budget_timeout;\n\n\t \n\tint dispatched;\n\n\t \n\tunsigned long flags;\n\n\t \n\tstruct list_head bfqq_list;\n\n\t \n\tstruct bfq_ttime ttime;\n\n\t \n\tu64 io_start_time;\n\t \n\tu64 tot_idle_time;\n\n\t \n\tu32 seek_history;\n\n\t \n\tstruct hlist_node burst_list_node;\n\n\t \n\tsector_t last_request_pos;\n\n\t \n\tunsigned int requests_within_timer;\n\n\t \n\tpid_t pid;\n\n\t \n\tstruct bfq_io_cq *bic;\n\n\t \n\tunsigned long wr_cur_max_time;\n\t \n\tunsigned long soft_rt_next_start;\n\t \n\tunsigned long last_wr_start_finish;\n\t \n\tunsigned int wr_coeff;\n\t \n\tunsigned long last_idle_bklogged;\n\t \n\tunsigned long service_from_backlogged;\n\t \n\tunsigned long service_from_wr;\n\n\t \n\tunsigned long wr_start_at_switch_to_srt;\n\n\tunsigned long split_time;  \n\n\tunsigned long first_IO_time;  \n\tunsigned long creation_time;  \n\n\t \n\tstruct bfq_queue *waker_bfqq;\n\t \n\tstruct bfq_queue *tentative_waker_bfqq;\n\t \n\tunsigned int num_waker_detections;\n\t \n\tu64 waker_detection_started;\n\n\t \n\tstruct hlist_node woken_list_node;\n\t \n\tstruct hlist_head woken_list;\n\n\t \n\tunsigned int actuator_idx;\n};\n\n \nstruct bfq_iocq_bfqq_data {\n\t \n\tbool saved_has_short_ttime;\n\t \n\tbool saved_IO_bound;\n\n\tu64 saved_io_start_time;\n\tu64 saved_tot_idle_time;\n\n\t \n\tbool saved_in_large_burst;\n\t \n\tbool was_in_burst_list;\n\n\t \n\tunsigned int saved_weight;\n\n\t \n\tunsigned long saved_wr_coeff;\n\tunsigned long saved_last_wr_start_finish;\n\tunsigned long saved_service_from_wr;\n\tunsigned long saved_wr_start_at_switch_to_srt;\n\tunsigned int saved_wr_cur_max_time;\n\tstruct bfq_ttime saved_ttime;\n\n\t \n\tu64 saved_last_serv_time_ns;\n\tunsigned int saved_inject_limit;\n\tunsigned long saved_decrease_time_jif;\n\n\t \n\tstruct bfq_queue *stable_merge_bfqq;\n\n\tbool stably_merged;\t \n};\n\n \nstruct bfq_io_cq {\n\t \n\tstruct io_cq icq;  \n\t \n\tstruct bfq_queue *bfqq[2][BFQ_MAX_ACTUATORS];\n\t \n\tint ioprio;\n#ifdef CONFIG_BFQ_GROUP_IOSCHED\n\tuint64_t blkcg_serial_nr;  \n#endif\n\n\t \n\tstruct bfq_iocq_bfqq_data bfqq_data[BFQ_MAX_ACTUATORS];\n\n\tunsigned int requests;\t \n};\n\n \nstruct bfq_data {\n\t \n\tstruct request_queue *queue;\n\t \n\tstruct list_head dispatch;\n\n\t \n\tstruct bfq_group *root_group;\n\n\t \n\tstruct rb_root_cached queue_weights_tree;\n\n#ifdef CONFIG_BFQ_GROUP_IOSCHED\n\t \n\tunsigned int num_groups_with_pending_reqs;\n#endif\n\n\t \n\tunsigned int busy_queues[3];\n\t \n\tint wr_busy_queues;\n\t \n\tint queued;\n\t \n\tint tot_rq_in_driver;\n\t \n\tint rq_in_driver[BFQ_MAX_ACTUATORS];\n\n\t \n\tbool nonrot_with_queueing;\n\n\t \n\tint max_rq_in_driver;\n\t \n\tint hw_tag_samples;\n\t \n\tint hw_tag;\n\n\t \n\tint budgets_assigned;\n\n\t \n\tstruct hrtimer idle_slice_timer;\n\n\t \n\tstruct bfq_queue *in_service_queue;\n\n\t \n\tsector_t last_position;\n\n\t \n\tsector_t in_serv_last_pos;\n\n\t \n\tu64 last_completion;\n\n\t \n\tstruct bfq_queue *last_completed_rq_bfqq;\n\n\t \n\tstruct bfq_queue *last_bfqq_created;\n\n\t \n\tu64 last_empty_occupied_ns;\n\n\t \n\tbool wait_dispatch;\n\t \n\tstruct request *waited_rq;\n\t \n\tbool rqs_injected;\n\n\t \n\tu64 first_dispatch;\n\t \n\tu64 last_dispatch;\n\n\t \n\tktime_t last_budget_start;\n\t \n\tktime_t last_idling_start;\n\tunsigned long last_idling_start_jiffies;\n\n\t \n\tint peak_rate_samples;\n\t \n\tu32 sequential_samples;\n\t \n\tu64 tot_sectors_dispatched;\n\t \n\tu32 last_rq_max_size;\n\t \n\tu64 delta_from_first;\n\t \n\tu32 peak_rate;\n\n\t \n\tint bfq_max_budget;\n\n\t \n\tstruct list_head active_list[BFQ_MAX_ACTUATORS];\n\t \n\tstruct list_head idle_list;\n\n\t \n\tu64 bfq_fifo_expire[2];\n\t \n\tunsigned int bfq_back_penalty;\n\t \n\tunsigned int bfq_back_max;\n\t \n\tu32 bfq_slice_idle;\n\n\t \n\tint bfq_user_max_budget;\n\t \n\tunsigned int bfq_timeout;\n\n\t \n\tbool strict_guarantees;\n\n\t \n\tunsigned long last_ins_in_burst;\n\t \n\tunsigned long bfq_burst_interval;\n\t \n\tint burst_size;\n\n\t \n\tstruct bfq_entity *burst_parent_entity;\n\t \n\tunsigned long bfq_large_burst_thresh;\n\t \n\tbool large_burst;\n\t \n\tstruct hlist_head burst_list;\n\n\t \n\tbool low_latency;\n\t \n\tunsigned int bfq_wr_coeff;\n\n\t \n\tunsigned int bfq_wr_rt_max_time;\n\t \n\tunsigned int bfq_wr_min_idle_time;\n\t \n\tunsigned long bfq_wr_min_inter_arr_async;\n\n\t \n\tunsigned int bfq_wr_max_softrt_rate;\n\t \n\tu64 rate_dur_prod;\n\n\t \n\tstruct bfq_queue oom_bfqq;\n\n\tspinlock_t lock;\n\n\t \n\tstruct bfq_io_cq *bio_bic;\n\t \n\tstruct bfq_queue *bio_bfqq;\n\n\t \n\tunsigned int word_depths[2][2];\n\tunsigned int full_depth_shift;\n\n\t \n\tunsigned int num_actuators;\n\t \n\tsector_t sector[BFQ_MAX_ACTUATORS];\n\tsector_t nr_sectors[BFQ_MAX_ACTUATORS];\n\tstruct blk_independent_access_range ia_ranges[BFQ_MAX_ACTUATORS];\n\n\t \n\tunsigned int actuator_load_threshold;\n};\n\nenum bfqq_state_flags {\n\tBFQQF_just_created = 0,\t \n\tBFQQF_busy,\t\t \n\tBFQQF_wait_request,\t \n\tBFQQF_non_blocking_wait_rq,  \n\tBFQQF_fifo_expire,\t \n\tBFQQF_has_short_ttime,\t \n\tBFQQF_sync,\t\t \n\tBFQQF_IO_bound,\t\t \n\tBFQQF_in_large_burst,\t \n\tBFQQF_softrt_update,\t \n\tBFQQF_coop,\t\t \n\tBFQQF_split_coop,\t \n};\n\n#define BFQ_BFQQ_FNS(name)\t\t\t\t\t\t\\\nvoid bfq_mark_bfqq_##name(struct bfq_queue *bfqq);\t\t\t\\\nvoid bfq_clear_bfqq_##name(struct bfq_queue *bfqq);\t\t\t\\\nint bfq_bfqq_##name(const struct bfq_queue *bfqq);\n\nBFQ_BFQQ_FNS(just_created);\nBFQ_BFQQ_FNS(busy);\nBFQ_BFQQ_FNS(wait_request);\nBFQ_BFQQ_FNS(non_blocking_wait_rq);\nBFQ_BFQQ_FNS(fifo_expire);\nBFQ_BFQQ_FNS(has_short_ttime);\nBFQ_BFQQ_FNS(sync);\nBFQ_BFQQ_FNS(IO_bound);\nBFQ_BFQQ_FNS(in_large_burst);\nBFQ_BFQQ_FNS(coop);\nBFQ_BFQQ_FNS(split_coop);\nBFQ_BFQQ_FNS(softrt_update);\n#undef BFQ_BFQQ_FNS\n\n \nenum bfqq_expiration {\n\tBFQQE_TOO_IDLE = 0,\t\t \n\tBFQQE_BUDGET_TIMEOUT,\t \n\tBFQQE_BUDGET_EXHAUSTED,\t \n\tBFQQE_NO_MORE_REQUESTS,\t \n\tBFQQE_PREEMPTED\t\t \n};\n\nstruct bfq_stat {\n\tstruct percpu_counter\t\tcpu_cnt;\n\tatomic64_t\t\t\taux_cnt;\n};\n\nstruct bfqg_stats {\n\t \n\tstruct blkg_rwstat\t\tbytes;\n\tstruct blkg_rwstat\t\tios;\n#ifdef CONFIG_BFQ_CGROUP_DEBUG\n\t \n\tstruct blkg_rwstat\t\tmerged;\n\t \n\tstruct blkg_rwstat\t\tservice_time;\n\t \n\tstruct blkg_rwstat\t\twait_time;\n\t \n\tstruct blkg_rwstat\t\tqueued;\n\t \n\tstruct bfq_stat\t\ttime;\n\t \n\tstruct bfq_stat\t\tavg_queue_size_sum;\n\t \n\tstruct bfq_stat\t\tavg_queue_size_samples;\n\t \n\tstruct bfq_stat\t\tdequeue;\n\t \n\tstruct bfq_stat\t\tgroup_wait_time;\n\t \n\tstruct bfq_stat\t\tidle_time;\n\t \n\tstruct bfq_stat\t\tempty_time;\n\t \n\tu64\t\t\t\tstart_group_wait_time;\n\tu64\t\t\t\tstart_idle_time;\n\tu64\t\t\t\tstart_empty_time;\n\tuint16_t\t\t\tflags;\n#endif  \n};\n\n#ifdef CONFIG_BFQ_GROUP_IOSCHED\n\n \nstruct bfq_group_data {\n\t \n\tstruct blkcg_policy_data pd;\n\n\tunsigned int weight;\n};\n\n \nstruct bfq_group {\n\t \n\tstruct blkg_policy_data pd;\n\n\t \n\tchar blkg_path[128];\n\n\t \n\trefcount_t ref;\n\n\tstruct bfq_entity entity;\n\tstruct bfq_sched_data sched_data;\n\n\tstruct bfq_data *bfqd;\n\n\tstruct bfq_queue *async_bfqq[2][IOPRIO_NR_LEVELS][BFQ_MAX_ACTUATORS];\n\tstruct bfq_queue *async_idle_bfqq[BFQ_MAX_ACTUATORS];\n\n\tstruct bfq_entity *my_entity;\n\n\tint active_entities;\n\tint num_queues_with_pending_reqs;\n\n\tstruct rb_root rq_pos_tree;\n\n\tstruct bfqg_stats stats;\n};\n\n#else\nstruct bfq_group {\n\tstruct bfq_entity entity;\n\tstruct bfq_sched_data sched_data;\n\n\tstruct bfq_queue *async_bfqq[2][IOPRIO_NR_LEVELS][BFQ_MAX_ACTUATORS];\n\tstruct bfq_queue *async_idle_bfqq[BFQ_MAX_ACTUATORS];\n\n\tstruct rb_root rq_pos_tree;\n};\n#endif\n\n \n\n#define BFQ_SERVICE_TREE_INIT\t((struct bfq_service_tree)\t\t\\\n\t\t\t\t{ RB_ROOT, RB_ROOT, NULL, NULL, 0, 0 })\n\nextern const int bfq_timeout;\n\nstruct bfq_queue *bic_to_bfqq(struct bfq_io_cq *bic, bool is_sync,\n\t\t\t\tunsigned int actuator_idx);\nvoid bic_set_bfqq(struct bfq_io_cq *bic, struct bfq_queue *bfqq, bool is_sync,\n\t\t\t\tunsigned int actuator_idx);\nstruct bfq_data *bic_to_bfqd(struct bfq_io_cq *bic);\nvoid bfq_pos_tree_add_move(struct bfq_data *bfqd, struct bfq_queue *bfqq);\nvoid bfq_weights_tree_add(struct bfq_queue *bfqq);\nvoid bfq_weights_tree_remove(struct bfq_queue *bfqq);\nvoid bfq_bfqq_expire(struct bfq_data *bfqd, struct bfq_queue *bfqq,\n\t\t     bool compensate, enum bfqq_expiration reason);\nvoid bfq_put_queue(struct bfq_queue *bfqq);\nvoid bfq_put_cooperator(struct bfq_queue *bfqq);\nvoid bfq_end_wr_async_queues(struct bfq_data *bfqd, struct bfq_group *bfqg);\nvoid bfq_release_process_ref(struct bfq_data *bfqd, struct bfq_queue *bfqq);\nvoid bfq_schedule_dispatch(struct bfq_data *bfqd);\nvoid bfq_put_async_queues(struct bfq_data *bfqd, struct bfq_group *bfqg);\n\n \n\n \n\nvoid bfqg_stats_update_legacy_io(struct request_queue *q, struct request *rq);\nvoid bfqg_stats_update_io_remove(struct bfq_group *bfqg, blk_opf_t opf);\nvoid bfqg_stats_update_io_merged(struct bfq_group *bfqg, blk_opf_t opf);\nvoid bfqg_stats_update_completion(struct bfq_group *bfqg, u64 start_time_ns,\n\t\t\t\t  u64 io_start_time_ns, blk_opf_t opf);\nvoid bfqg_stats_update_dequeue(struct bfq_group *bfqg);\nvoid bfqg_stats_set_start_idle_time(struct bfq_group *bfqg);\nvoid bfq_bfqq_move(struct bfq_data *bfqd, struct bfq_queue *bfqq,\n\t\t   struct bfq_group *bfqg);\n\n#ifdef CONFIG_BFQ_CGROUP_DEBUG\nvoid bfqg_stats_update_io_add(struct bfq_group *bfqg, struct bfq_queue *bfqq,\n\t\t\t      blk_opf_t opf);\nvoid bfqg_stats_set_start_empty_time(struct bfq_group *bfqg);\nvoid bfqg_stats_update_idle_time(struct bfq_group *bfqg);\nvoid bfqg_stats_update_avg_queue_size(struct bfq_group *bfqg);\n#endif\n\nvoid bfq_init_entity(struct bfq_entity *entity, struct bfq_group *bfqg);\nvoid bfq_bic_update_cgroup(struct bfq_io_cq *bic, struct bio *bio);\nvoid bfq_end_wr_async(struct bfq_data *bfqd);\nstruct bfq_group *bfq_bio_bfqg(struct bfq_data *bfqd, struct bio *bio);\nstruct blkcg_gq *bfqg_to_blkg(struct bfq_group *bfqg);\nstruct bfq_group *bfqq_group(struct bfq_queue *bfqq);\nstruct bfq_group *bfq_create_group_hierarchy(struct bfq_data *bfqd, int node);\nvoid bfqg_and_blkg_put(struct bfq_group *bfqg);\n\n#ifdef CONFIG_BFQ_GROUP_IOSCHED\nextern struct cftype bfq_blkcg_legacy_files[];\nextern struct cftype bfq_blkg_files[];\nextern struct blkcg_policy blkcg_policy_bfq;\n#endif\n\n \n\n \n\n#ifdef CONFIG_BFQ_GROUP_IOSCHED\n \n#define for_each_entity(entity)\t\\\n\tfor (; entity ; entity = entity->parent)\n\n \n#define for_each_entity_safe(entity, parent) \\\n\tfor (; entity && ({ parent = entity->parent; 1; }); entity = parent)\n\n#else  \n \n#define for_each_entity(entity)\t\\\n\tfor (; entity ; entity = NULL)\n\n#define for_each_entity_safe(entity, parent) \\\n\tfor (parent = NULL; entity ; entity = parent)\n#endif  \n\nstruct bfq_queue *bfq_entity_to_bfqq(struct bfq_entity *entity);\nunsigned int bfq_tot_busy_queues(struct bfq_data *bfqd);\nstruct bfq_service_tree *bfq_entity_service_tree(struct bfq_entity *entity);\nstruct bfq_entity *bfq_entity_of(struct rb_node *node);\nunsigned short bfq_ioprio_to_weight(int ioprio);\nvoid bfq_put_idle_entity(struct bfq_service_tree *st,\n\t\t\t struct bfq_entity *entity);\nstruct bfq_service_tree *\n__bfq_entity_update_weight_prio(struct bfq_service_tree *old_st,\n\t\t\t\tstruct bfq_entity *entity,\n\t\t\t\tbool update_class_too);\nvoid bfq_bfqq_served(struct bfq_queue *bfqq, int served);\nvoid bfq_bfqq_charge_time(struct bfq_data *bfqd, struct bfq_queue *bfqq,\n\t\t\t  unsigned long time_ms);\nbool __bfq_deactivate_entity(struct bfq_entity *entity,\n\t\t\t     bool ins_into_idle_tree);\nbool next_queue_may_preempt(struct bfq_data *bfqd);\nstruct bfq_queue *bfq_get_next_queue(struct bfq_data *bfqd);\nbool __bfq_bfqd_reset_in_service(struct bfq_data *bfqd);\nvoid bfq_deactivate_bfqq(struct bfq_data *bfqd, struct bfq_queue *bfqq,\n\t\t\t bool ins_into_idle_tree, bool expiration);\nvoid bfq_activate_bfqq(struct bfq_data *bfqd, struct bfq_queue *bfqq);\nvoid bfq_requeue_bfqq(struct bfq_data *bfqd, struct bfq_queue *bfqq,\n\t\t      bool expiration);\nvoid bfq_del_bfqq_busy(struct bfq_queue *bfqq, bool expiration);\nvoid bfq_add_bfqq_busy(struct bfq_queue *bfqq);\nvoid bfq_add_bfqq_in_groups_with_pending_reqs(struct bfq_queue *bfqq);\nvoid bfq_del_bfqq_in_groups_with_pending_reqs(struct bfq_queue *bfqq);\n\n \n\n \nstatic inline void bfq_bfqq_name(struct bfq_queue *bfqq, char *str, int len)\n{\n\tchar type = bfq_bfqq_sync(bfqq) ? 'S' : 'A';\n\n\tif (bfqq->pid != -1)\n\t\tsnprintf(str, len, \"bfq%d%c\", bfqq->pid, type);\n\telse\n\t\tsnprintf(str, len, \"bfqSHARED-%c\", type);\n}\n\n#ifdef CONFIG_BFQ_GROUP_IOSCHED\nstruct bfq_group *bfqq_group(struct bfq_queue *bfqq);\n\n#define bfq_log_bfqq(bfqd, bfqq, fmt, args...)\tdo {\t\t\t\\\n\tchar pid_str[MAX_BFQQ_NAME_LENGTH];\t\t\t\t\\\n\tif (likely(!blk_trace_note_message_enabled((bfqd)->queue)))\t\\\n\t\tbreak;\t\t\t\t\t\t\t\\\n\tbfq_bfqq_name((bfqq), pid_str, MAX_BFQQ_NAME_LENGTH);\t\t\\\n\tblk_add_cgroup_trace_msg((bfqd)->queue,\t\t\t\t\\\n\t\t\t&bfqg_to_blkg(bfqq_group(bfqq))->blkcg->css,\t\\\n\t\t\t\"%s \" fmt, pid_str, ##args);\t\t\t\\\n} while (0)\n\n#define bfq_log_bfqg(bfqd, bfqg, fmt, args...)\tdo {\t\t\t\\\n\tblk_add_cgroup_trace_msg((bfqd)->queue,\t\t\t\t\\\n\t\t&bfqg_to_blkg(bfqg)->blkcg->css, fmt, ##args);\t\t\\\n} while (0)\n\n#else  \n\n#define bfq_log_bfqq(bfqd, bfqq, fmt, args...) do {\t\\\n\tchar pid_str[MAX_BFQQ_NAME_LENGTH];\t\t\t\t\\\n\tif (likely(!blk_trace_note_message_enabled((bfqd)->queue)))\t\\\n\t\tbreak;\t\t\t\t\t\t\t\\\n\tbfq_bfqq_name((bfqq), pid_str, MAX_BFQQ_NAME_LENGTH);\t\t\\\n\tblk_add_trace_msg((bfqd)->queue, \"%s \" fmt, pid_str, ##args);\t\\\n} while (0)\n#define bfq_log_bfqg(bfqd, bfqg, fmt, args...)\t\tdo {} while (0)\n\n#endif  \n\n#define bfq_log(bfqd, fmt, args...) \\\n\tblk_add_trace_msg((bfqd)->queue, \"bfq \" fmt, ##args)\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}