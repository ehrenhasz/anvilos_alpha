{
  "module_name": "sed-opal.c",
  "hash_id": "10feca54f64dbf0ba8c877d45f07c1004d8cd5736ce4a9da827b2af7796d20e1",
  "original_prompt": "Ingested from linux-6.6.14/block/sed-opal.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \":OPAL: \" fmt\n\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <uapi/linux/sed-opal.h>\n#include <linux/sed-opal.h>\n#include <linux/string.h>\n#include <linux/kdev_t.h>\n#include <linux/key.h>\n#include <linux/key-type.h>\n#include <keys/user-type.h>\n\n#include \"opal_proto.h\"\n\n#define IO_BUFFER_LENGTH 2048\n#define MAX_TOKS 64\n\n \n#define CMD_FINALIZE_BYTES_NEEDED 7\n\nstatic struct key *sed_opal_keyring;\n\nstruct opal_step {\n\tint (*fn)(struct opal_dev *dev, void *data);\n\tvoid *data;\n};\ntypedef int (cont_fn)(struct opal_dev *dev);\n\nenum opal_atom_width {\n\tOPAL_WIDTH_TINY,\n\tOPAL_WIDTH_SHORT,\n\tOPAL_WIDTH_MEDIUM,\n\tOPAL_WIDTH_LONG,\n\tOPAL_WIDTH_TOKEN\n};\n\n \nstruct opal_resp_tok {\n\tconst u8 *pos;\n\tsize_t len;\n\tenum opal_response_token type;\n\tenum opal_atom_width width;\n\tunion {\n\t\tu64 u;\n\t\ts64 s;\n\t} stored;\n};\n\n \nstruct parsed_resp {\n\tint num;\n\tstruct opal_resp_tok toks[MAX_TOKS];\n};\n\nstruct opal_dev {\n\tu32 flags;\n\n\tvoid *data;\n\tsec_send_recv *send_recv;\n\n\tstruct mutex dev_lock;\n\tu16 comid;\n\tu32 hsn;\n\tu32 tsn;\n\tu64 align;  \n\tu64 lowest_lba;\n\tu32 logical_block_size;\n\tu8  align_required;  \n\n\tsize_t pos;\n\tu8 *cmd;\n\tu8 *resp;\n\n\tstruct parsed_resp parsed;\n\tsize_t prev_d_len;\n\tvoid *prev_data;\n\n\tstruct list_head unlk_lst;\n};\n\n\nstatic const u8 opaluid[][OPAL_UID_LENGTH] = {\n\t \n\t[OPAL_SMUID_UID] =\n\t\t{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff },\n\t[OPAL_THISSP_UID] =\n\t\t{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01 },\n\t[OPAL_ADMINSP_UID] =\n\t\t{ 0x00, 0x00, 0x02, 0x05, 0x00, 0x00, 0x00, 0x01 },\n\t[OPAL_LOCKINGSP_UID] =\n\t\t{ 0x00, 0x00, 0x02, 0x05, 0x00, 0x00, 0x00, 0x02 },\n\t[OPAL_ENTERPRISE_LOCKINGSP_UID] =\n\t\t{ 0x00, 0x00, 0x02, 0x05, 0x00, 0x01, 0x00, 0x01 },\n\t[OPAL_ANYBODY_UID] =\n\t\t{ 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x01 },\n\t[OPAL_SID_UID] =\n\t\t{ 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x06 },\n\t[OPAL_ADMIN1_UID] =\n\t\t{ 0x00, 0x00, 0x00, 0x09, 0x00, 0x01, 0x00, 0x01 },\n\t[OPAL_USER1_UID] =\n\t\t{ 0x00, 0x00, 0x00, 0x09, 0x00, 0x03, 0x00, 0x01 },\n\t[OPAL_USER2_UID] =\n\t\t{ 0x00, 0x00, 0x00, 0x09, 0x00, 0x03, 0x00, 0x02 },\n\t[OPAL_PSID_UID] =\n\t\t{ 0x00, 0x00, 0x00, 0x09, 0x00, 0x01, 0xff, 0x01 },\n\t[OPAL_ENTERPRISE_BANDMASTER0_UID] =\n\t\t{ 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x80, 0x01 },\n\t[OPAL_ENTERPRISE_ERASEMASTER_UID] =\n\t\t{ 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x84, 0x01 },\n\n\t \n\t[OPAL_TABLE_TABLE] =\n\t\t{ 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01 },\n\t[OPAL_LOCKINGRANGE_GLOBAL] =\n\t\t{ 0x00, 0x00, 0x08, 0x02, 0x00, 0x00, 0x00, 0x01 },\n\t[OPAL_LOCKINGRANGE_ACE_START_TO_KEY] =\n\t\t{ 0x00, 0x00, 0x00, 0x08, 0x00, 0x03, 0xD0, 0x01 },\n\t[OPAL_LOCKINGRANGE_ACE_RDLOCKED] =\n\t\t{ 0x00, 0x00, 0x00, 0x08, 0x00, 0x03, 0xE0, 0x01 },\n\t[OPAL_LOCKINGRANGE_ACE_WRLOCKED] =\n\t\t{ 0x00, 0x00, 0x00, 0x08, 0x00, 0x03, 0xE8, 0x01 },\n\t[OPAL_MBRCONTROL] =\n\t\t{ 0x00, 0x00, 0x08, 0x03, 0x00, 0x00, 0x00, 0x01 },\n\t[OPAL_MBR] =\n\t\t{ 0x00, 0x00, 0x08, 0x04, 0x00, 0x00, 0x00, 0x00 },\n\t[OPAL_AUTHORITY_TABLE] =\n\t\t{ 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x00},\n\t[OPAL_C_PIN_TABLE] =\n\t\t{ 0x00, 0x00, 0x00, 0x0B, 0x00, 0x00, 0x00, 0x00},\n\t[OPAL_LOCKING_INFO_TABLE] =\n\t\t{ 0x00, 0x00, 0x08, 0x01, 0x00, 0x00, 0x00, 0x01 },\n\t[OPAL_ENTERPRISE_LOCKING_INFO_TABLE] =\n\t\t{ 0x00, 0x00, 0x08, 0x01, 0x00, 0x00, 0x00, 0x00 },\n\t[OPAL_DATASTORE] =\n\t\t{ 0x00, 0x00, 0x10, 0x01, 0x00, 0x00, 0x00, 0x00 },\n\n\t \n\t[OPAL_C_PIN_MSID] =\n\t\t{ 0x00, 0x00, 0x00, 0x0B, 0x00, 0x00, 0x84, 0x02},\n\t[OPAL_C_PIN_SID] =\n\t\t{ 0x00, 0x00, 0x00, 0x0B, 0x00, 0x00, 0x00, 0x01},\n\t[OPAL_C_PIN_ADMIN1] =\n\t\t{ 0x00, 0x00, 0x00, 0x0B, 0x00, 0x01, 0x00, 0x01},\n\n\t \n\t[OPAL_HALF_UID_AUTHORITY_OBJ_REF] =\n\t\t{ 0x00, 0x00, 0x0C, 0x05, 0xff, 0xff, 0xff, 0xff },\n\t[OPAL_HALF_UID_BOOLEAN_ACE] =\n\t\t{ 0x00, 0x00, 0x04, 0x0E, 0xff, 0xff, 0xff, 0xff },\n\n\t \n\t[OPAL_UID_HEXFF] =\n\t\t{ 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff},\n};\n\n \nstatic const u8 opalmethod[][OPAL_METHOD_LENGTH] = {\n\t[OPAL_PROPERTIES] =\n\t\t{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x01 },\n\t[OPAL_STARTSESSION] =\n\t\t{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x02 },\n\t[OPAL_REVERT] =\n\t\t{ 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x02, 0x02 },\n\t[OPAL_ACTIVATE] =\n\t\t{ 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x02, 0x03 },\n\t[OPAL_EGET] =\n\t\t{ 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x06 },\n\t[OPAL_ESET] =\n\t\t{ 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x07 },\n\t[OPAL_NEXT] =\n\t\t{ 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x08 },\n\t[OPAL_EAUTHENTICATE] =\n\t\t{ 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x0c },\n\t[OPAL_GETACL] =\n\t\t{ 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x0d },\n\t[OPAL_GENKEY] =\n\t\t{ 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x10 },\n\t[OPAL_REVERTSP] =\n\t\t{ 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x11 },\n\t[OPAL_GET] =\n\t\t{ 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x16 },\n\t[OPAL_SET] =\n\t\t{ 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x17 },\n\t[OPAL_AUTHENTICATE] =\n\t\t{ 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x1c },\n\t[OPAL_RANDOM] =\n\t\t{ 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x06, 0x01 },\n\t[OPAL_ERASE] =\n\t\t{ 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x08, 0x03 },\n};\n\nstatic int end_opal_session_error(struct opal_dev *dev);\nstatic int opal_discovery0_step(struct opal_dev *dev);\n\nstruct opal_suspend_data {\n\tstruct opal_lock_unlock unlk;\n\tu8 lr;\n\tstruct list_head node;\n};\n\n \nstatic const char * const opal_errors[] = {\n\t\"Success\",\n\t\"Not Authorized\",\n\t\"Unknown Error\",\n\t\"SP Busy\",\n\t\"SP Failed\",\n\t\"SP Disabled\",\n\t\"SP Frozen\",\n\t\"No Sessions Available\",\n\t\"Uniqueness Conflict\",\n\t\"Insufficient Space\",\n\t\"Insufficient Rows\",\n\t\"Invalid Function\",\n\t\"Invalid Parameter\",\n\t\"Invalid Reference\",\n\t\"Unknown Error\",\n\t\"TPER Malfunction\",\n\t\"Transaction Failure\",\n\t\"Response Overflow\",\n\t\"Authority Locked Out\",\n};\n\nstatic const char *opal_error_to_human(int error)\n{\n\tif (error == 0x3f)\n\t\treturn \"Failed\";\n\n\tif (error >= ARRAY_SIZE(opal_errors) || error < 0)\n\t\treturn \"Unknown Error\";\n\n\treturn opal_errors[error];\n}\n\nstatic void print_buffer(const u8 *ptr, u32 length)\n{\n#ifdef DEBUG\n\tprint_hex_dump_bytes(\"OPAL: \", DUMP_PREFIX_OFFSET, ptr, length);\n\tpr_debug(\"\\n\");\n#endif\n}\n\n \nstatic int update_sed_opal_key(const char *desc, u_char *key_data, int keylen)\n{\n\tkey_ref_t kr;\n\n\tif (!sed_opal_keyring)\n\t\treturn -ENOKEY;\n\n\tkr = key_create_or_update(make_key_ref(sed_opal_keyring, true), \"user\",\n\t\t\t\t  desc, (const void *)key_data, keylen,\n\t\t\t\t  KEY_USR_VIEW | KEY_USR_SEARCH | KEY_USR_WRITE,\n\t\t\t\t  KEY_ALLOC_NOT_IN_QUOTA | KEY_ALLOC_BUILT_IN |\n\t\t\t\t\tKEY_ALLOC_BYPASS_RESTRICTION);\n\tif (IS_ERR(kr)) {\n\t\tpr_err(\"Error adding SED key (%ld)\\n\", PTR_ERR(kr));\n\t\treturn PTR_ERR(kr);\n\t}\n\n\treturn 0;\n}\n\n \nstatic int read_sed_opal_key(const char *key_name, u_char *buffer, int buflen)\n{\n\tint ret;\n\tkey_ref_t kref;\n\tstruct key *key;\n\n\tif (!sed_opal_keyring)\n\t\treturn -ENOKEY;\n\n\tkref = keyring_search(make_key_ref(sed_opal_keyring, true),\n\t\t\t      &key_type_user, key_name, true);\n\n\tif (IS_ERR(kref))\n\t\tret = PTR_ERR(kref);\n\n\tkey = key_ref_to_ptr(kref);\n\tdown_read(&key->sem);\n\tret = key_validate(key);\n\tif (ret == 0) {\n\t\tif (buflen > key->datalen)\n\t\t\tbuflen = key->datalen;\n\n\t\tret = key->type->read(key, (char *)buffer, buflen);\n\t}\n\tup_read(&key->sem);\n\n\tkey_ref_put(kref);\n\n\treturn ret;\n}\n\nstatic int opal_get_key(struct opal_dev *dev, struct opal_key *key)\n{\n\tint ret = 0;\n\n\tswitch (key->key_type) {\n\tcase OPAL_INCLUDED:\n\t\t \n\t\tbreak;\n\tcase OPAL_KEYRING:\n\t\t \n\t\tret = read_sed_opal_key(OPAL_AUTH_KEY, key->key, OPAL_KEY_MAX);\n\t\tif (ret > 0) {\n\t\t\tif (ret > U8_MAX) {\n\t\t\t\tret = -ENOSPC;\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tkey->key_len = ret;\n\t\t\tkey->key_type = OPAL_INCLUDED;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\tif (ret < 0)\n\t\tgoto error;\n\n\t \n\tif (key->key_type != OPAL_INCLUDED || key->key_len == 0) {\n\t\tret = -EINVAL;\n\t\tgoto error;\n\t}\n\treturn 0;\nerror:\n\tpr_debug(\"Error getting password: %d\\n\", ret);\n\treturn ret;\n}\n\nstatic bool check_tper(const void *data)\n{\n\tconst struct d0_tper_features *tper = data;\n\tu8 flags = tper->supported_features;\n\n\tif (!(flags & TPER_SYNC_SUPPORTED)) {\n\t\tpr_debug(\"TPer sync not supported. flags = %d\\n\",\n\t\t\t tper->supported_features);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic bool check_lcksuppt(const void *data)\n{\n\tconst struct d0_locking_features *lfeat = data;\n\tu8 sup_feat = lfeat->supported_features;\n\n\treturn !!(sup_feat & LOCKING_SUPPORTED_MASK);\n}\n\nstatic bool check_lckenabled(const void *data)\n{\n\tconst struct d0_locking_features *lfeat = data;\n\tu8 sup_feat = lfeat->supported_features;\n\n\treturn !!(sup_feat & LOCKING_ENABLED_MASK);\n}\n\nstatic bool check_locked(const void *data)\n{\n\tconst struct d0_locking_features *lfeat = data;\n\tu8 sup_feat = lfeat->supported_features;\n\n\treturn !!(sup_feat & LOCKED_MASK);\n}\n\nstatic bool check_mbrenabled(const void *data)\n{\n\tconst struct d0_locking_features *lfeat = data;\n\tu8 sup_feat = lfeat->supported_features;\n\n\treturn !!(sup_feat & MBR_ENABLED_MASK);\n}\n\nstatic bool check_mbrdone(const void *data)\n{\n\tconst struct d0_locking_features *lfeat = data;\n\tu8 sup_feat = lfeat->supported_features;\n\n\treturn !!(sup_feat & MBR_DONE_MASK);\n}\n\nstatic bool check_sum(const void *data)\n{\n\tconst struct d0_single_user_mode *sum = data;\n\tu32 nlo = be32_to_cpu(sum->num_locking_objects);\n\n\tif (nlo == 0) {\n\t\tpr_debug(\"Need at least one locking object.\\n\");\n\t\treturn false;\n\t}\n\n\tpr_debug(\"Number of locking objects: %d\\n\", nlo);\n\n\treturn true;\n}\n\nstatic u16 get_comid_v100(const void *data)\n{\n\tconst struct d0_opal_v100 *v100 = data;\n\n\treturn be16_to_cpu(v100->baseComID);\n}\n\nstatic u16 get_comid_v200(const void *data)\n{\n\tconst struct d0_opal_v200 *v200 = data;\n\n\treturn be16_to_cpu(v200->baseComID);\n}\n\nstatic int opal_send_cmd(struct opal_dev *dev)\n{\n\treturn dev->send_recv(dev->data, dev->comid, TCG_SECP_01,\n\t\t\t      dev->cmd, IO_BUFFER_LENGTH,\n\t\t\t      true);\n}\n\nstatic int opal_recv_cmd(struct opal_dev *dev)\n{\n\treturn dev->send_recv(dev->data, dev->comid, TCG_SECP_01,\n\t\t\t      dev->resp, IO_BUFFER_LENGTH,\n\t\t\t      false);\n}\n\nstatic int opal_recv_check(struct opal_dev *dev)\n{\n\tsize_t buflen = IO_BUFFER_LENGTH;\n\tvoid *buffer = dev->resp;\n\tstruct opal_header *hdr = buffer;\n\tint ret;\n\n\tdo {\n\t\tpr_debug(\"Sent OPAL command: outstanding=%d, minTransfer=%d\\n\",\n\t\t\t hdr->cp.outstandingData,\n\t\t\t hdr->cp.minTransfer);\n\n\t\tif (hdr->cp.outstandingData == 0 ||\n\t\t    hdr->cp.minTransfer != 0)\n\t\t\treturn 0;\n\n\t\tmemset(buffer, 0, buflen);\n\t\tret = opal_recv_cmd(dev);\n\t} while (!ret);\n\n\treturn ret;\n}\n\nstatic int opal_send_recv(struct opal_dev *dev, cont_fn *cont)\n{\n\tint ret;\n\n\tret = opal_send_cmd(dev);\n\tif (ret)\n\t\treturn ret;\n\tret = opal_recv_cmd(dev);\n\tif (ret)\n\t\treturn ret;\n\tret = opal_recv_check(dev);\n\tif (ret)\n\t\treturn ret;\n\treturn cont(dev);\n}\n\nstatic void check_geometry(struct opal_dev *dev, const void *data)\n{\n\tconst struct d0_geometry_features *geo = data;\n\n\tdev->align = be64_to_cpu(geo->alignment_granularity);\n\tdev->lowest_lba = be64_to_cpu(geo->lowest_aligned_lba);\n\tdev->logical_block_size = be32_to_cpu(geo->logical_block_size);\n\tdev->align_required = geo->reserved01 & 1;\n}\n\nstatic int execute_step(struct opal_dev *dev,\n\t\t\tconst struct opal_step *step, size_t stepIndex)\n{\n\tint error = step->fn(dev, step->data);\n\n\tif (error) {\n\t\tpr_debug(\"Step %zu (%pS) failed with error %d: %s\\n\",\n\t\t\t stepIndex, step->fn, error,\n\t\t\t opal_error_to_human(error));\n\t}\n\n\treturn error;\n}\n\nstatic int execute_steps(struct opal_dev *dev,\n\t\t\t const struct opal_step *steps, size_t n_steps)\n{\n\tsize_t state = 0;\n\tint error;\n\n\t \n\terror = opal_discovery0_step(dev);\n\tif (error)\n\t\treturn error;\n\n\tfor (state = 0; state < n_steps; state++) {\n\t\terror = execute_step(dev, &steps[state], state);\n\t\tif (error)\n\t\t\tgoto out_error;\n\t}\n\n\treturn 0;\n\nout_error:\n\t \n\tif (state > 0)\n\t\tend_opal_session_error(dev);\n\n\treturn error;\n}\n\nstatic int opal_discovery0_end(struct opal_dev *dev, void *data)\n{\n\tstruct opal_discovery *discv_out = data;  \n\tu8 __user *buf_out;\n\tu64 len_out;\n\tbool found_com_id = false, supported = true, single_user = false;\n\tconst struct d0_header *hdr = (struct d0_header *)dev->resp;\n\tconst u8 *epos = dev->resp, *cpos = dev->resp;\n\tu16 comid = 0;\n\tu32 hlen = be32_to_cpu(hdr->length);\n\n\tprint_buffer(dev->resp, hlen);\n\tdev->flags &= OPAL_FL_SUPPORTED;\n\n\tif (hlen > IO_BUFFER_LENGTH - sizeof(*hdr)) {\n\t\tpr_debug(\"Discovery length overflows buffer (%zu+%u)/%u\\n\",\n\t\t\t sizeof(*hdr), hlen, IO_BUFFER_LENGTH);\n\t\treturn -EFAULT;\n\t}\n\n\tif (discv_out) {\n\t\tbuf_out = (u8 __user *)(uintptr_t)discv_out->data;\n\t\tlen_out = min_t(u64, discv_out->size, hlen);\n\t\tif (buf_out && copy_to_user(buf_out, dev->resp, len_out))\n\t\t\treturn -EFAULT;\n\n\t\tdiscv_out->size = hlen;  \n\t}\n\n\tepos += hlen;  \n\tcpos += sizeof(*hdr);  \n\n\twhile (cpos < epos && supported) {\n\t\tconst struct d0_features *body =\n\t\t\t(const struct d0_features *)cpos;\n\n\t\tswitch (be16_to_cpu(body->code)) {\n\t\tcase FC_TPER:\n\t\t\tsupported = check_tper(body->features);\n\t\t\tbreak;\n\t\tcase FC_SINGLEUSER:\n\t\t\tsingle_user = check_sum(body->features);\n\t\t\tif (single_user)\n\t\t\t\tdev->flags |= OPAL_FL_SUM_SUPPORTED;\n\t\t\tbreak;\n\t\tcase FC_GEOMETRY:\n\t\t\tcheck_geometry(dev, body);\n\t\t\tbreak;\n\t\tcase FC_LOCKING:\n\t\t\tif (check_lcksuppt(body->features))\n\t\t\t\tdev->flags |= OPAL_FL_LOCKING_SUPPORTED;\n\t\t\tif (check_lckenabled(body->features))\n\t\t\t\tdev->flags |= OPAL_FL_LOCKING_ENABLED;\n\t\t\tif (check_locked(body->features))\n\t\t\t\tdev->flags |= OPAL_FL_LOCKED;\n\t\t\tif (check_mbrenabled(body->features))\n\t\t\t\tdev->flags |= OPAL_FL_MBR_ENABLED;\n\t\t\tif (check_mbrdone(body->features))\n\t\t\t\tdev->flags |= OPAL_FL_MBR_DONE;\n\t\t\tbreak;\n\t\tcase FC_ENTERPRISE:\n\t\tcase FC_DATASTORE:\n\t\t\t \n\t\t\tpr_debug(\"Found OPAL feature description: %d\\n\",\n\t\t\t\t be16_to_cpu(body->code));\n\t\t\tbreak;\n\t\tcase FC_OPALV100:\n\t\t\tcomid = get_comid_v100(body->features);\n\t\t\tfound_com_id = true;\n\t\t\tbreak;\n\t\tcase FC_OPALV200:\n\t\t\tcomid = get_comid_v200(body->features);\n\t\t\tfound_com_id = true;\n\t\t\tbreak;\n\t\tcase 0xbfff ... 0xffff:\n\t\t\t \n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_debug(\"OPAL Unknown feature: %d\\n\",\n\t\t\t\t be16_to_cpu(body->code));\n\n\t\t}\n\t\tcpos += body->length + 4;\n\t}\n\n\tif (!supported) {\n\t\tpr_debug(\"This device is not Opal enabled. Not Supported!\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (!single_user)\n\t\tpr_debug(\"Device doesn't support single user mode\\n\");\n\n\n\tif (!found_com_id) {\n\t\tpr_debug(\"Could not find OPAL comid for device. Returning early\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tdev->comid = comid;\n\n\treturn 0;\n}\n\nstatic int opal_discovery0(struct opal_dev *dev, void *data)\n{\n\tint ret;\n\n\tmemset(dev->resp, 0, IO_BUFFER_LENGTH);\n\tdev->comid = OPAL_DISCOVERY_COMID;\n\tret = opal_recv_cmd(dev);\n\tif (ret)\n\t\treturn ret;\n\n\treturn opal_discovery0_end(dev, data);\n}\n\nstatic int opal_discovery0_step(struct opal_dev *dev)\n{\n\tconst struct opal_step discovery0_step = {\n\t\topal_discovery0, NULL\n\t};\n\n\treturn execute_step(dev, &discovery0_step, 0);\n}\n\nstatic size_t remaining_size(struct opal_dev *cmd)\n{\n\treturn IO_BUFFER_LENGTH - cmd->pos;\n}\n\nstatic bool can_add(int *err, struct opal_dev *cmd, size_t len)\n{\n\tif (*err)\n\t\treturn false;\n\n\tif (remaining_size(cmd) < len) {\n\t\tpr_debug(\"Error adding %zu bytes: end of buffer.\\n\", len);\n\t\t*err = -ERANGE;\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic void add_token_u8(int *err, struct opal_dev *cmd, u8 tok)\n{\n\tif (!can_add(err, cmd, 1))\n\t\treturn;\n\n\tcmd->cmd[cmd->pos++] = tok;\n}\n\nstatic void add_short_atom_header(struct opal_dev *cmd, bool bytestring,\n\t\t\t\t  bool has_sign, int len)\n{\n\tu8 atom;\n\tint err = 0;\n\n\tatom = SHORT_ATOM_ID;\n\tatom |= bytestring ? SHORT_ATOM_BYTESTRING : 0;\n\tatom |= has_sign ? SHORT_ATOM_SIGNED : 0;\n\tatom |= len & SHORT_ATOM_LEN_MASK;\n\n\tadd_token_u8(&err, cmd, atom);\n}\n\nstatic void add_medium_atom_header(struct opal_dev *cmd, bool bytestring,\n\t\t\t\t   bool has_sign, int len)\n{\n\tu8 header0;\n\n\theader0 = MEDIUM_ATOM_ID;\n\theader0 |= bytestring ? MEDIUM_ATOM_BYTESTRING : 0;\n\theader0 |= has_sign ? MEDIUM_ATOM_SIGNED : 0;\n\theader0 |= (len >> 8) & MEDIUM_ATOM_LEN_MASK;\n\n\tcmd->cmd[cmd->pos++] = header0;\n\tcmd->cmd[cmd->pos++] = len;\n}\n\nstatic void add_token_u64(int *err, struct opal_dev *cmd, u64 number)\n{\n\tsize_t len;\n\tint msb;\n\n\tif (!(number & ~TINY_ATOM_DATA_MASK)) {\n\t\tadd_token_u8(err, cmd, number);\n\t\treturn;\n\t}\n\n\tmsb = fls64(number);\n\tlen = DIV_ROUND_UP(msb, 8);\n\n\tif (!can_add(err, cmd, len + 1)) {\n\t\tpr_debug(\"Error adding u64: end of buffer.\\n\");\n\t\treturn;\n\t}\n\tadd_short_atom_header(cmd, false, false, len);\n\twhile (len--)\n\t\tadd_token_u8(err, cmd, number >> (len * 8));\n}\n\nstatic u8 *add_bytestring_header(int *err, struct opal_dev *cmd, size_t len)\n{\n\tsize_t header_len = 1;\n\tbool is_short_atom = true;\n\n\tif (len & ~SHORT_ATOM_LEN_MASK) {\n\t\theader_len = 2;\n\t\tis_short_atom = false;\n\t}\n\n\tif (!can_add(err, cmd, header_len + len)) {\n\t\tpr_debug(\"Error adding bytestring: end of buffer.\\n\");\n\t\treturn NULL;\n\t}\n\n\tif (is_short_atom)\n\t\tadd_short_atom_header(cmd, true, false, len);\n\telse\n\t\tadd_medium_atom_header(cmd, true, false, len);\n\n\treturn &cmd->cmd[cmd->pos];\n}\n\nstatic void add_token_bytestring(int *err, struct opal_dev *cmd,\n\t\t\t\t const u8 *bytestring, size_t len)\n{\n\tu8 *start;\n\n\tstart = add_bytestring_header(err, cmd, len);\n\tif (!start)\n\t\treturn;\n\tmemcpy(start, bytestring, len);\n\tcmd->pos += len;\n}\n\nstatic int build_locking_range(u8 *buffer, size_t length, u8 lr)\n{\n\tif (length > OPAL_UID_LENGTH) {\n\t\tpr_debug(\"Can't build locking range. Length OOB\\n\");\n\t\treturn -ERANGE;\n\t}\n\n\tmemcpy(buffer, opaluid[OPAL_LOCKINGRANGE_GLOBAL], OPAL_UID_LENGTH);\n\n\tif (lr == 0)\n\t\treturn 0;\n\n\tbuffer[5] = LOCKING_RANGE_NON_GLOBAL;\n\tbuffer[7] = lr;\n\n\treturn 0;\n}\n\nstatic int build_locking_user(u8 *buffer, size_t length, u8 lr)\n{\n\tif (length > OPAL_UID_LENGTH) {\n\t\tpr_debug(\"Can't build locking range user. Length OOB\\n\");\n\t\treturn -ERANGE;\n\t}\n\n\tmemcpy(buffer, opaluid[OPAL_USER1_UID], OPAL_UID_LENGTH);\n\n\tbuffer[7] = lr + 1;\n\n\treturn 0;\n}\n\nstatic void set_comid(struct opal_dev *cmd, u16 comid)\n{\n\tstruct opal_header *hdr = (struct opal_header *)cmd->cmd;\n\n\thdr->cp.extendedComID[0] = comid >> 8;\n\thdr->cp.extendedComID[1] = comid;\n\thdr->cp.extendedComID[2] = 0;\n\thdr->cp.extendedComID[3] = 0;\n}\n\nstatic int cmd_finalize(struct opal_dev *cmd, u32 hsn, u32 tsn)\n{\n\tstruct opal_header *hdr;\n\tint err = 0;\n\n\t \n\tadd_token_u8(&err, cmd, OPAL_ENDLIST);\n\n\tadd_token_u8(&err, cmd, OPAL_ENDOFDATA);\n\tadd_token_u8(&err, cmd, OPAL_STARTLIST);\n\tadd_token_u8(&err, cmd, 0);\n\tadd_token_u8(&err, cmd, 0);\n\tadd_token_u8(&err, cmd, 0);\n\tadd_token_u8(&err, cmd, OPAL_ENDLIST);\n\n\tif (err) {\n\t\tpr_debug(\"Error finalizing command.\\n\");\n\t\treturn -EFAULT;\n\t}\n\n\thdr = (struct opal_header *) cmd->cmd;\n\n\thdr->pkt.tsn = cpu_to_be32(tsn);\n\thdr->pkt.hsn = cpu_to_be32(hsn);\n\n\thdr->subpkt.length = cpu_to_be32(cmd->pos - sizeof(*hdr));\n\twhile (cmd->pos % 4) {\n\t\tif (cmd->pos >= IO_BUFFER_LENGTH) {\n\t\t\tpr_debug(\"Error: Buffer overrun\\n\");\n\t\t\treturn -ERANGE;\n\t\t}\n\t\tcmd->cmd[cmd->pos++] = 0;\n\t}\n\thdr->pkt.length = cpu_to_be32(cmd->pos - sizeof(hdr->cp) -\n\t\t\t\t      sizeof(hdr->pkt));\n\thdr->cp.length = cpu_to_be32(cmd->pos - sizeof(hdr->cp));\n\n\treturn 0;\n}\n\nstatic const struct opal_resp_tok *response_get_token(\n\t\t\t\tconst struct parsed_resp *resp,\n\t\t\t\tint n)\n{\n\tconst struct opal_resp_tok *tok;\n\n\tif (!resp) {\n\t\tpr_debug(\"Response is NULL\\n\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tif (n >= resp->num) {\n\t\tpr_debug(\"Token number doesn't exist: %d, resp: %d\\n\",\n\t\t\t n, resp->num);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\ttok = &resp->toks[n];\n\tif (tok->len == 0) {\n\t\tpr_debug(\"Token length must be non-zero\\n\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\treturn tok;\n}\n\nstatic ssize_t response_parse_tiny(struct opal_resp_tok *tok,\n\t\t\t\t   const u8 *pos)\n{\n\ttok->pos = pos;\n\ttok->len = 1;\n\ttok->width = OPAL_WIDTH_TINY;\n\n\tif (pos[0] & TINY_ATOM_SIGNED) {\n\t\ttok->type = OPAL_DTA_TOKENID_SINT;\n\t} else {\n\t\ttok->type = OPAL_DTA_TOKENID_UINT;\n\t\ttok->stored.u = pos[0] & 0x3f;\n\t}\n\n\treturn tok->len;\n}\n\nstatic ssize_t response_parse_short(struct opal_resp_tok *tok,\n\t\t\t\t    const u8 *pos)\n{\n\ttok->pos = pos;\n\ttok->len = (pos[0] & SHORT_ATOM_LEN_MASK) + 1;\n\ttok->width = OPAL_WIDTH_SHORT;\n\n\tif (pos[0] & SHORT_ATOM_BYTESTRING) {\n\t\ttok->type = OPAL_DTA_TOKENID_BYTESTRING;\n\t} else if (pos[0] & SHORT_ATOM_SIGNED) {\n\t\ttok->type = OPAL_DTA_TOKENID_SINT;\n\t} else {\n\t\tu64 u_integer = 0;\n\t\tssize_t i, b = 0;\n\n\t\ttok->type = OPAL_DTA_TOKENID_UINT;\n\t\tif (tok->len > 9) {\n\t\t\tpr_debug(\"uint64 with more than 8 bytes\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tfor (i = tok->len - 1; i > 0; i--) {\n\t\t\tu_integer |= ((u64)pos[i] << (8 * b));\n\t\t\tb++;\n\t\t}\n\t\ttok->stored.u = u_integer;\n\t}\n\n\treturn tok->len;\n}\n\nstatic ssize_t response_parse_medium(struct opal_resp_tok *tok,\n\t\t\t\t     const u8 *pos)\n{\n\ttok->pos = pos;\n\ttok->len = (((pos[0] & MEDIUM_ATOM_LEN_MASK) << 8) | pos[1]) + 2;\n\ttok->width = OPAL_WIDTH_MEDIUM;\n\n\tif (pos[0] & MEDIUM_ATOM_BYTESTRING)\n\t\ttok->type = OPAL_DTA_TOKENID_BYTESTRING;\n\telse if (pos[0] & MEDIUM_ATOM_SIGNED)\n\t\ttok->type = OPAL_DTA_TOKENID_SINT;\n\telse\n\t\ttok->type = OPAL_DTA_TOKENID_UINT;\n\n\treturn tok->len;\n}\n\nstatic ssize_t response_parse_long(struct opal_resp_tok *tok,\n\t\t\t\t   const u8 *pos)\n{\n\ttok->pos = pos;\n\ttok->len = ((pos[1] << 16) | (pos[2] << 8) | pos[3]) + 4;\n\ttok->width = OPAL_WIDTH_LONG;\n\n\tif (pos[0] & LONG_ATOM_BYTESTRING)\n\t\ttok->type = OPAL_DTA_TOKENID_BYTESTRING;\n\telse if (pos[0] & LONG_ATOM_SIGNED)\n\t\ttok->type = OPAL_DTA_TOKENID_SINT;\n\telse\n\t\ttok->type = OPAL_DTA_TOKENID_UINT;\n\n\treturn tok->len;\n}\n\nstatic ssize_t response_parse_token(struct opal_resp_tok *tok,\n\t\t\t\t    const u8 *pos)\n{\n\ttok->pos = pos;\n\ttok->len = 1;\n\ttok->type = OPAL_DTA_TOKENID_TOKEN;\n\ttok->width = OPAL_WIDTH_TOKEN;\n\n\treturn tok->len;\n}\n\nstatic int response_parse(const u8 *buf, size_t length,\n\t\t\t  struct parsed_resp *resp)\n{\n\tconst struct opal_header *hdr;\n\tstruct opal_resp_tok *iter;\n\tint num_entries = 0;\n\tint total;\n\tssize_t token_length;\n\tconst u8 *pos;\n\tu32 clen, plen, slen;\n\n\tif (!buf)\n\t\treturn -EFAULT;\n\n\tif (!resp)\n\t\treturn -EFAULT;\n\n\thdr = (struct opal_header *)buf;\n\tpos = buf;\n\tpos += sizeof(*hdr);\n\n\tclen = be32_to_cpu(hdr->cp.length);\n\tplen = be32_to_cpu(hdr->pkt.length);\n\tslen = be32_to_cpu(hdr->subpkt.length);\n\tpr_debug(\"Response size: cp: %u, pkt: %u, subpkt: %u\\n\",\n\t\t clen, plen, slen);\n\n\tif (clen == 0 || plen == 0 || slen == 0 ||\n\t    slen > IO_BUFFER_LENGTH - sizeof(*hdr)) {\n\t\tpr_debug(\"Bad header length. cp: %u, pkt: %u, subpkt: %u\\n\",\n\t\t\t clen, plen, slen);\n\t\tprint_buffer(pos, sizeof(*hdr));\n\t\treturn -EINVAL;\n\t}\n\n\tif (pos > buf + length)\n\t\treturn -EFAULT;\n\n\titer = resp->toks;\n\ttotal = slen;\n\tprint_buffer(pos, total);\n\twhile (total > 0) {\n\t\tif (pos[0] <= TINY_ATOM_BYTE)  \n\t\t\ttoken_length = response_parse_tiny(iter, pos);\n\t\telse if (pos[0] <= SHORT_ATOM_BYTE)  \n\t\t\ttoken_length = response_parse_short(iter, pos);\n\t\telse if (pos[0] <= MEDIUM_ATOM_BYTE)  \n\t\t\ttoken_length = response_parse_medium(iter, pos);\n\t\telse if (pos[0] <= LONG_ATOM_BYTE)  \n\t\t\ttoken_length = response_parse_long(iter, pos);\n\t\telse  \n\t\t\ttoken_length = response_parse_token(iter, pos);\n\n\t\tif (token_length < 0)\n\t\t\treturn token_length;\n\n\t\tpos += token_length;\n\t\ttotal -= token_length;\n\t\titer++;\n\t\tnum_entries++;\n\t}\n\n\tresp->num = num_entries;\n\n\treturn 0;\n}\n\nstatic size_t response_get_string(const struct parsed_resp *resp, int n,\n\t\t\t\t  const char **store)\n{\n\tu8 skip;\n\tconst struct opal_resp_tok *tok;\n\n\t*store = NULL;\n\ttok = response_get_token(resp, n);\n\tif (IS_ERR(tok))\n\t\treturn 0;\n\n\tif (tok->type != OPAL_DTA_TOKENID_BYTESTRING) {\n\t\tpr_debug(\"Token is not a byte string!\\n\");\n\t\treturn 0;\n\t}\n\n\tswitch (tok->width) {\n\tcase OPAL_WIDTH_TINY:\n\tcase OPAL_WIDTH_SHORT:\n\t\tskip = 1;\n\t\tbreak;\n\tcase OPAL_WIDTH_MEDIUM:\n\t\tskip = 2;\n\t\tbreak;\n\tcase OPAL_WIDTH_LONG:\n\t\tskip = 4;\n\t\tbreak;\n\tdefault:\n\t\tpr_debug(\"Token has invalid width!\\n\");\n\t\treturn 0;\n\t}\n\n\t*store = tok->pos + skip;\n\n\treturn tok->len - skip;\n}\n\nstatic u64 response_get_u64(const struct parsed_resp *resp, int n)\n{\n\tconst struct opal_resp_tok *tok;\n\n\ttok = response_get_token(resp, n);\n\tif (IS_ERR(tok))\n\t\treturn 0;\n\n\tif (tok->type != OPAL_DTA_TOKENID_UINT) {\n\t\tpr_debug(\"Token is not unsigned int: %d\\n\", tok->type);\n\t\treturn 0;\n\t}\n\n\tif (tok->width != OPAL_WIDTH_TINY && tok->width != OPAL_WIDTH_SHORT) {\n\t\tpr_debug(\"Atom is not short or tiny: %d\\n\", tok->width);\n\t\treturn 0;\n\t}\n\n\treturn tok->stored.u;\n}\n\nstatic bool response_token_matches(const struct opal_resp_tok *token, u8 match)\n{\n\tif (IS_ERR(token) ||\n\t    token->type != OPAL_DTA_TOKENID_TOKEN ||\n\t    token->pos[0] != match)\n\t\treturn false;\n\treturn true;\n}\n\nstatic u8 response_status(const struct parsed_resp *resp)\n{\n\tconst struct opal_resp_tok *tok;\n\n\ttok = response_get_token(resp, 0);\n\tif (response_token_matches(tok, OPAL_ENDOFSESSION))\n\t\treturn 0;\n\n\tif (resp->num < 5)\n\t\treturn DTAERROR_NO_METHOD_STATUS;\n\n\ttok = response_get_token(resp, resp->num - 5);\n\tif (!response_token_matches(tok, OPAL_STARTLIST))\n\t\treturn DTAERROR_NO_METHOD_STATUS;\n\n\ttok = response_get_token(resp, resp->num - 1);\n\tif (!response_token_matches(tok, OPAL_ENDLIST))\n\t\treturn DTAERROR_NO_METHOD_STATUS;\n\n\treturn response_get_u64(resp, resp->num - 4);\n}\n\n \nstatic int parse_and_check_status(struct opal_dev *dev)\n{\n\tint error;\n\n\tprint_buffer(dev->cmd, dev->pos);\n\n\terror = response_parse(dev->resp, IO_BUFFER_LENGTH, &dev->parsed);\n\tif (error) {\n\t\tpr_debug(\"Couldn't parse response.\\n\");\n\t\treturn error;\n\t}\n\n\treturn response_status(&dev->parsed);\n}\n\nstatic void clear_opal_cmd(struct opal_dev *dev)\n{\n\tdev->pos = sizeof(struct opal_header);\n\tmemset(dev->cmd, 0, IO_BUFFER_LENGTH);\n}\n\nstatic int cmd_start(struct opal_dev *dev, const u8 *uid, const u8 *method)\n{\n\tint err = 0;\n\n\tclear_opal_cmd(dev);\n\tset_comid(dev, dev->comid);\n\n\tadd_token_u8(&err, dev, OPAL_CALL);\n\tadd_token_bytestring(&err, dev, uid, OPAL_UID_LENGTH);\n\tadd_token_bytestring(&err, dev, method, OPAL_METHOD_LENGTH);\n\n\t \n\tadd_token_u8(&err, dev, OPAL_STARTLIST);\n\n\treturn err;\n}\n\nstatic int start_opal_session_cont(struct opal_dev *dev)\n{\n\tu32 hsn, tsn;\n\tint error = 0;\n\n\terror = parse_and_check_status(dev);\n\tif (error)\n\t\treturn error;\n\n\thsn = response_get_u64(&dev->parsed, 4);\n\ttsn = response_get_u64(&dev->parsed, 5);\n\n\tif (hsn != GENERIC_HOST_SESSION_NUM || tsn < FIRST_TPER_SESSION_NUM) {\n\t\tpr_debug(\"Couldn't authenticate session\\n\");\n\t\treturn -EPERM;\n\t}\n\n\tdev->hsn = hsn;\n\tdev->tsn = tsn;\n\n\treturn 0;\n}\n\nstatic void add_suspend_info(struct opal_dev *dev,\n\t\t\t     struct opal_suspend_data *sus)\n{\n\tstruct opal_suspend_data *iter;\n\n\tlist_for_each_entry(iter, &dev->unlk_lst, node) {\n\t\tif (iter->lr == sus->lr) {\n\t\t\tlist_del(&iter->node);\n\t\t\tkfree(iter);\n\t\t\tbreak;\n\t\t}\n\t}\n\tlist_add_tail(&sus->node, &dev->unlk_lst);\n}\n\nstatic int end_session_cont(struct opal_dev *dev)\n{\n\tdev->hsn = 0;\n\tdev->tsn = 0;\n\n\treturn parse_and_check_status(dev);\n}\n\nstatic int finalize_and_send(struct opal_dev *dev, cont_fn cont)\n{\n\tint ret;\n\n\tret = cmd_finalize(dev, dev->hsn, dev->tsn);\n\tif (ret) {\n\t\tpr_debug(\"Error finalizing command buffer: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tprint_buffer(dev->cmd, dev->pos);\n\n\treturn opal_send_recv(dev, cont);\n}\n\nstatic int generic_get_columns(struct opal_dev *dev, const u8 *table,\n\t\t\t       u64 start_column, u64 end_column)\n{\n\tint err;\n\n\terr = cmd_start(dev, table, opalmethod[OPAL_GET]);\n\n\tadd_token_u8(&err, dev, OPAL_STARTLIST);\n\n\tadd_token_u8(&err, dev, OPAL_STARTNAME);\n\tadd_token_u8(&err, dev, OPAL_STARTCOLUMN);\n\tadd_token_u64(&err, dev, start_column);\n\tadd_token_u8(&err, dev, OPAL_ENDNAME);\n\n\tadd_token_u8(&err, dev, OPAL_STARTNAME);\n\tadd_token_u8(&err, dev, OPAL_ENDCOLUMN);\n\tadd_token_u64(&err, dev, end_column);\n\tadd_token_u8(&err, dev, OPAL_ENDNAME);\n\n\tadd_token_u8(&err, dev, OPAL_ENDLIST);\n\n\tif (err)\n\t\treturn err;\n\n\treturn finalize_and_send(dev, parse_and_check_status);\n}\n\n \nstatic int generic_get_column(struct opal_dev *dev, const u8 *table,\n\t\t\t      u64 column)\n{\n\treturn generic_get_columns(dev, table, column, column);\n}\n\n \nstatic int generic_get_table_info(struct opal_dev *dev, const u8 *table_uid,\n\t\t\t\t  u64 column)\n{\n\tu8 uid[OPAL_UID_LENGTH];\n\tconst unsigned int half = OPAL_UID_LENGTH_HALF;\n\n\t \n\tmemcpy(uid, opaluid[OPAL_TABLE_TABLE], half);\n\tmemcpy(uid + half, table_uid, half);\n\n\treturn generic_get_column(dev, uid, column);\n}\n\nstatic int gen_key(struct opal_dev *dev, void *data)\n{\n\tu8 uid[OPAL_UID_LENGTH];\n\tint err;\n\n\tmemcpy(uid, dev->prev_data, min(sizeof(uid), dev->prev_d_len));\n\tkfree(dev->prev_data);\n\tdev->prev_data = NULL;\n\n\terr = cmd_start(dev, uid, opalmethod[OPAL_GENKEY]);\n\n\tif (err) {\n\t\tpr_debug(\"Error building gen key command\\n\");\n\t\treturn err;\n\n\t}\n\n\treturn finalize_and_send(dev, parse_and_check_status);\n}\n\nstatic int get_active_key_cont(struct opal_dev *dev)\n{\n\tconst char *activekey;\n\tsize_t keylen;\n\tint error = 0;\n\n\terror = parse_and_check_status(dev);\n\tif (error)\n\t\treturn error;\n\n\tkeylen = response_get_string(&dev->parsed, 4, &activekey);\n\tif (!activekey) {\n\t\tpr_debug(\"%s: Couldn't extract the Activekey from the response\\n\",\n\t\t\t __func__);\n\t\treturn OPAL_INVAL_PARAM;\n\t}\n\n\tdev->prev_data = kmemdup(activekey, keylen, GFP_KERNEL);\n\n\tif (!dev->prev_data)\n\t\treturn -ENOMEM;\n\n\tdev->prev_d_len = keylen;\n\n\treturn 0;\n}\n\nstatic int get_active_key(struct opal_dev *dev, void *data)\n{\n\tu8 uid[OPAL_UID_LENGTH];\n\tint err;\n\tu8 *lr = data;\n\n\terr = build_locking_range(uid, sizeof(uid), *lr);\n\tif (err)\n\t\treturn err;\n\n\terr = generic_get_column(dev, uid, OPAL_ACTIVEKEY);\n\tif (err)\n\t\treturn err;\n\n\treturn get_active_key_cont(dev);\n}\n\nstatic int generic_table_write_data(struct opal_dev *dev, const u64 data,\n\t\t\t\t    u64 offset, u64 size, const u8 *uid)\n{\n\tconst u8 __user *src = (u8 __user *)(uintptr_t)data;\n\tu8 *dst;\n\tu64 len;\n\tsize_t off = 0;\n\tint err;\n\n\t \n\terr = generic_get_table_info(dev, uid, OPAL_TABLE_ROWS);\n\tif (err) {\n\t\tpr_debug(\"Couldn't get the table size\\n\");\n\t\treturn err;\n\t}\n\n\tlen = response_get_u64(&dev->parsed, 4);\n\tif (size > len || offset > len - size) {\n\t\tpr_debug(\"Does not fit in the table (%llu vs. %llu)\\n\",\n\t\t\t  offset + size, len);\n\t\treturn -ENOSPC;\n\t}\n\n\t \n\twhile (off < size) {\n\t\terr = cmd_start(dev, uid, opalmethod[OPAL_SET]);\n\t\tadd_token_u8(&err, dev, OPAL_STARTNAME);\n\t\tadd_token_u8(&err, dev, OPAL_WHERE);\n\t\tadd_token_u64(&err, dev, offset + off);\n\t\tadd_token_u8(&err, dev, OPAL_ENDNAME);\n\n\t\tadd_token_u8(&err, dev, OPAL_STARTNAME);\n\t\tadd_token_u8(&err, dev, OPAL_VALUES);\n\n\t\t \n\t\tlen = min(remaining_size(dev) - (2+1+CMD_FINALIZE_BYTES_NEEDED),\n\t\t\t  (size_t)(size - off));\n\t\tpr_debug(\"Write bytes %zu+%llu/%llu\\n\", off, len, size);\n\n\t\tdst = add_bytestring_header(&err, dev, len);\n\t\tif (!dst)\n\t\t\tbreak;\n\n\t\tif (copy_from_user(dst, src + off, len)) {\n\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tdev->pos += len;\n\n\t\tadd_token_u8(&err, dev, OPAL_ENDNAME);\n\t\tif (err)\n\t\t\tbreak;\n\n\t\terr = finalize_and_send(dev, parse_and_check_status);\n\t\tif (err)\n\t\t\tbreak;\n\n\t\toff += len;\n\t}\n\n\treturn err;\n}\n\nstatic int generic_lr_enable_disable(struct opal_dev *dev,\n\t\t\t\t     u8 *uid, bool rle, bool wle,\n\t\t\t\t     bool rl, bool wl)\n{\n\tint err;\n\n\terr = cmd_start(dev, uid, opalmethod[OPAL_SET]);\n\n\tadd_token_u8(&err, dev, OPAL_STARTNAME);\n\tadd_token_u8(&err, dev, OPAL_VALUES);\n\tadd_token_u8(&err, dev, OPAL_STARTLIST);\n\n\tadd_token_u8(&err, dev, OPAL_STARTNAME);\n\tadd_token_u8(&err, dev, OPAL_READLOCKENABLED);\n\tadd_token_u8(&err, dev, rle);\n\tadd_token_u8(&err, dev, OPAL_ENDNAME);\n\n\tadd_token_u8(&err, dev, OPAL_STARTNAME);\n\tadd_token_u8(&err, dev, OPAL_WRITELOCKENABLED);\n\tadd_token_u8(&err, dev, wle);\n\tadd_token_u8(&err, dev, OPAL_ENDNAME);\n\n\tadd_token_u8(&err, dev, OPAL_STARTNAME);\n\tadd_token_u8(&err, dev, OPAL_READLOCKED);\n\tadd_token_u8(&err, dev, rl);\n\tadd_token_u8(&err, dev, OPAL_ENDNAME);\n\n\tadd_token_u8(&err, dev, OPAL_STARTNAME);\n\tadd_token_u8(&err, dev, OPAL_WRITELOCKED);\n\tadd_token_u8(&err, dev, wl);\n\tadd_token_u8(&err, dev, OPAL_ENDNAME);\n\n\tadd_token_u8(&err, dev, OPAL_ENDLIST);\n\tadd_token_u8(&err, dev, OPAL_ENDNAME);\n\n\treturn err;\n}\n\nstatic inline int enable_global_lr(struct opal_dev *dev, u8 *uid,\n\t\t\t\t   struct opal_user_lr_setup *setup)\n{\n\tint err;\n\n\terr = generic_lr_enable_disable(dev, uid, !!setup->RLE, !!setup->WLE,\n\t\t\t\t\t0, 0);\n\tif (err)\n\t\tpr_debug(\"Failed to create enable global lr command\\n\");\n\n\treturn err;\n}\n\nstatic int setup_locking_range(struct opal_dev *dev, void *data)\n{\n\tu8 uid[OPAL_UID_LENGTH];\n\tstruct opal_user_lr_setup *setup = data;\n\tu8 lr;\n\tint err;\n\n\tlr = setup->session.opal_key.lr;\n\terr = build_locking_range(uid, sizeof(uid), lr);\n\tif (err)\n\t\treturn err;\n\n\tif (lr == 0)\n\t\terr = enable_global_lr(dev, uid, setup);\n\telse {\n\t\terr = cmd_start(dev, uid, opalmethod[OPAL_SET]);\n\n\t\tadd_token_u8(&err, dev, OPAL_STARTNAME);\n\t\tadd_token_u8(&err, dev, OPAL_VALUES);\n\t\tadd_token_u8(&err, dev, OPAL_STARTLIST);\n\n\t\tadd_token_u8(&err, dev, OPAL_STARTNAME);\n\t\tadd_token_u8(&err, dev, OPAL_RANGESTART);\n\t\tadd_token_u64(&err, dev, setup->range_start);\n\t\tadd_token_u8(&err, dev, OPAL_ENDNAME);\n\n\t\tadd_token_u8(&err, dev, OPAL_STARTNAME);\n\t\tadd_token_u8(&err, dev, OPAL_RANGELENGTH);\n\t\tadd_token_u64(&err, dev, setup->range_length);\n\t\tadd_token_u8(&err, dev, OPAL_ENDNAME);\n\n\t\tadd_token_u8(&err, dev, OPAL_STARTNAME);\n\t\tadd_token_u8(&err, dev, OPAL_READLOCKENABLED);\n\t\tadd_token_u64(&err, dev, !!setup->RLE);\n\t\tadd_token_u8(&err, dev, OPAL_ENDNAME);\n\n\t\tadd_token_u8(&err, dev, OPAL_STARTNAME);\n\t\tadd_token_u8(&err, dev, OPAL_WRITELOCKENABLED);\n\t\tadd_token_u64(&err, dev, !!setup->WLE);\n\t\tadd_token_u8(&err, dev, OPAL_ENDNAME);\n\n\t\tadd_token_u8(&err, dev, OPAL_ENDLIST);\n\t\tadd_token_u8(&err, dev, OPAL_ENDNAME);\n\t}\n\tif (err) {\n\t\tpr_debug(\"Error building Setup Locking range command.\\n\");\n\t\treturn err;\n\t}\n\n\treturn finalize_and_send(dev, parse_and_check_status);\n}\n\nstatic int response_get_column(const struct parsed_resp *resp,\n\t\t\t       int *iter,\n\t\t\t       u8 column,\n\t\t\t       u64 *value)\n{\n\tconst struct opal_resp_tok *tok;\n\tint n = *iter;\n\tu64 val;\n\n\ttok = response_get_token(resp, n);\n\tif (IS_ERR(tok))\n\t\treturn PTR_ERR(tok);\n\n\tif (!response_token_matches(tok, OPAL_STARTNAME)) {\n\t\tpr_debug(\"Unexpected response token type %d.\\n\", n);\n\t\treturn OPAL_INVAL_PARAM;\n\t}\n\tn++;\n\n\tif (response_get_u64(resp, n) != column) {\n\t\tpr_debug(\"Token %d does not match expected column %u.\\n\",\n\t\t\t n, column);\n\t\treturn OPAL_INVAL_PARAM;\n\t}\n\tn++;\n\n\tval = response_get_u64(resp, n);\n\tn++;\n\n\ttok = response_get_token(resp, n);\n\tif (IS_ERR(tok))\n\t\treturn PTR_ERR(tok);\n\n\tif (!response_token_matches(tok, OPAL_ENDNAME)) {\n\t\tpr_debug(\"Unexpected response token type %d.\\n\", n);\n\t\treturn OPAL_INVAL_PARAM;\n\t}\n\tn++;\n\n\t*value = val;\n\t*iter = n;\n\n\treturn 0;\n}\n\nstatic int locking_range_status(struct opal_dev *dev, void *data)\n{\n\tu8 lr_buffer[OPAL_UID_LENGTH];\n\tu64 resp;\n\tbool rlocked, wlocked;\n\tint err, tok_n = 2;\n\tstruct opal_lr_status *lrst = data;\n\n\terr = build_locking_range(lr_buffer, sizeof(lr_buffer),\n\t\t\t\t  lrst->session.opal_key.lr);\n\tif (err)\n\t\treturn err;\n\n\terr = generic_get_columns(dev, lr_buffer, OPAL_RANGESTART,\n\t\t\t\t  OPAL_WRITELOCKED);\n\tif (err) {\n\t\tpr_debug(\"Couldn't get lr %u table columns %d to %d.\\n\",\n\t\t\t lrst->session.opal_key.lr, OPAL_RANGESTART,\n\t\t\t OPAL_WRITELOCKED);\n\t\treturn err;\n\t}\n\n\t \n\terr = response_get_column(&dev->parsed, &tok_n, OPAL_RANGESTART,\n\t\t\t\t  &lrst->range_start);\n\tif (err)\n\t\treturn err;\n\n\t \n\terr = response_get_column(&dev->parsed, &tok_n, OPAL_RANGELENGTH,\n\t\t\t\t  &lrst->range_length);\n\tif (err)\n\t\treturn err;\n\n\t \n\terr = response_get_column(&dev->parsed, &tok_n, OPAL_READLOCKENABLED,\n\t\t\t\t  &resp);\n\tif (err)\n\t\treturn err;\n\n\tlrst->RLE = !!resp;\n\n\t \n\terr = response_get_column(&dev->parsed, &tok_n, OPAL_WRITELOCKENABLED,\n\t\t\t\t  &resp);\n\tif (err)\n\t\treturn err;\n\n\tlrst->WLE = !!resp;\n\n\t \n\terr = response_get_column(&dev->parsed, &tok_n, OPAL_READLOCKED, &resp);\n\tif (err)\n\t\treturn err;\n\n\trlocked = !!resp;\n\n\t \n\terr = response_get_column(&dev->parsed, &tok_n, OPAL_WRITELOCKED, &resp);\n\tif (err)\n\t\treturn err;\n\n\twlocked = !!resp;\n\n\t \n\tlrst->l_state = OPAL_RW;\n\tif (rlocked && wlocked)\n\t\tlrst->l_state = OPAL_LK;\n\telse if (wlocked)\n\t\tlrst->l_state = OPAL_RO;\n\telse if (rlocked) {\n\t\tpr_debug(\"Can not report read locked only state.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int start_generic_opal_session(struct opal_dev *dev,\n\t\t\t\t      enum opal_uid auth,\n\t\t\t\t      enum opal_uid sp_type,\n\t\t\t\t      const char *key,\n\t\t\t\t      u8 key_len)\n{\n\tu32 hsn;\n\tint err;\n\n\tif (key == NULL && auth != OPAL_ANYBODY_UID)\n\t\treturn OPAL_INVAL_PARAM;\n\n\thsn = GENERIC_HOST_SESSION_NUM;\n\terr = cmd_start(dev, opaluid[OPAL_SMUID_UID],\n\t\t\topalmethod[OPAL_STARTSESSION]);\n\n\tadd_token_u64(&err, dev, hsn);\n\tadd_token_bytestring(&err, dev, opaluid[sp_type], OPAL_UID_LENGTH);\n\tadd_token_u8(&err, dev, 1);\n\n\tswitch (auth) {\n\tcase OPAL_ANYBODY_UID:\n\t\tbreak;\n\tcase OPAL_ADMIN1_UID:\n\tcase OPAL_SID_UID:\n\tcase OPAL_PSID_UID:\n\t\tadd_token_u8(&err, dev, OPAL_STARTNAME);\n\t\tadd_token_u8(&err, dev, 0);  \n\t\tadd_token_bytestring(&err, dev, key, key_len);\n\t\tadd_token_u8(&err, dev, OPAL_ENDNAME);\n\t\tadd_token_u8(&err, dev, OPAL_STARTNAME);\n\t\tadd_token_u8(&err, dev, 3);  \n\t\tadd_token_bytestring(&err, dev, opaluid[auth],\n\t\t\t\t     OPAL_UID_LENGTH);\n\t\tadd_token_u8(&err, dev, OPAL_ENDNAME);\n\t\tbreak;\n\tdefault:\n\t\tpr_debug(\"Cannot start Admin SP session with auth %d\\n\", auth);\n\t\treturn OPAL_INVAL_PARAM;\n\t}\n\n\tif (err) {\n\t\tpr_debug(\"Error building start adminsp session command.\\n\");\n\t\treturn err;\n\t}\n\n\treturn finalize_and_send(dev, start_opal_session_cont);\n}\n\nstatic int start_anybodyASP_opal_session(struct opal_dev *dev, void *data)\n{\n\treturn start_generic_opal_session(dev, OPAL_ANYBODY_UID,\n\t\t\t\t\t  OPAL_ADMINSP_UID, NULL, 0);\n}\n\nstatic int start_SIDASP_opal_session(struct opal_dev *dev, void *data)\n{\n\tint ret;\n\tconst u8 *key = dev->prev_data;\n\n\tif (!key) {\n\t\tconst struct opal_key *okey = data;\n\n\t\tret = start_generic_opal_session(dev, OPAL_SID_UID,\n\t\t\t\t\t\t OPAL_ADMINSP_UID,\n\t\t\t\t\t\t okey->key,\n\t\t\t\t\t\t okey->key_len);\n\t} else {\n\t\tret = start_generic_opal_session(dev, OPAL_SID_UID,\n\t\t\t\t\t\t OPAL_ADMINSP_UID,\n\t\t\t\t\t\t key, dev->prev_d_len);\n\t\tkfree(key);\n\t\tdev->prev_data = NULL;\n\t}\n\n\treturn ret;\n}\n\nstatic int start_admin1LSP_opal_session(struct opal_dev *dev, void *data)\n{\n\tstruct opal_key *key = data;\n\n\treturn start_generic_opal_session(dev, OPAL_ADMIN1_UID,\n\t\t\t\t\t  OPAL_LOCKINGSP_UID,\n\t\t\t\t\t  key->key, key->key_len);\n}\n\nstatic int start_PSID_opal_session(struct opal_dev *dev, void *data)\n{\n\tconst struct opal_key *okey = data;\n\n\treturn start_generic_opal_session(dev, OPAL_PSID_UID,\n\t\t\t\t\t  OPAL_ADMINSP_UID,\n\t\t\t\t\t  okey->key,\n\t\t\t\t\t  okey->key_len);\n}\n\nstatic int start_auth_opal_session(struct opal_dev *dev, void *data)\n{\n\tstruct opal_session_info *session = data;\n\tu8 lk_ul_user[OPAL_UID_LENGTH];\n\tsize_t keylen = session->opal_key.key_len;\n\tint err = 0;\n\n\tu8 *key = session->opal_key.key;\n\tu32 hsn = GENERIC_HOST_SESSION_NUM;\n\n\tif (session->sum)\n\t\terr = build_locking_user(lk_ul_user, sizeof(lk_ul_user),\n\t\t\t\t\t session->opal_key.lr);\n\telse if (session->who != OPAL_ADMIN1 && !session->sum)\n\t\terr = build_locking_user(lk_ul_user, sizeof(lk_ul_user),\n\t\t\t\t\t session->who - 1);\n\telse\n\t\tmemcpy(lk_ul_user, opaluid[OPAL_ADMIN1_UID], OPAL_UID_LENGTH);\n\n\tif (err)\n\t\treturn err;\n\n\terr = cmd_start(dev, opaluid[OPAL_SMUID_UID],\n\t\t\topalmethod[OPAL_STARTSESSION]);\n\n\tadd_token_u64(&err, dev, hsn);\n\tadd_token_bytestring(&err, dev, opaluid[OPAL_LOCKINGSP_UID],\n\t\t\t     OPAL_UID_LENGTH);\n\tadd_token_u8(&err, dev, 1);\n\tadd_token_u8(&err, dev, OPAL_STARTNAME);\n\tadd_token_u8(&err, dev, 0);\n\tadd_token_bytestring(&err, dev, key, keylen);\n\tadd_token_u8(&err, dev, OPAL_ENDNAME);\n\tadd_token_u8(&err, dev, OPAL_STARTNAME);\n\tadd_token_u8(&err, dev, 3);\n\tadd_token_bytestring(&err, dev, lk_ul_user, OPAL_UID_LENGTH);\n\tadd_token_u8(&err, dev, OPAL_ENDNAME);\n\n\tif (err) {\n\t\tpr_debug(\"Error building STARTSESSION command.\\n\");\n\t\treturn err;\n\t}\n\n\treturn finalize_and_send(dev, start_opal_session_cont);\n}\n\nstatic int revert_tper(struct opal_dev *dev, void *data)\n{\n\tint err;\n\n\terr = cmd_start(dev, opaluid[OPAL_ADMINSP_UID],\n\t\t\topalmethod[OPAL_REVERT]);\n\tif (err) {\n\t\tpr_debug(\"Error building REVERT TPER command.\\n\");\n\t\treturn err;\n\t}\n\n\treturn finalize_and_send(dev, parse_and_check_status);\n}\n\nstatic int internal_activate_user(struct opal_dev *dev, void *data)\n{\n\tstruct opal_session_info *session = data;\n\tu8 uid[OPAL_UID_LENGTH];\n\tint err;\n\n\tmemcpy(uid, opaluid[OPAL_USER1_UID], OPAL_UID_LENGTH);\n\tuid[7] = session->who;\n\n\terr = cmd_start(dev, uid, opalmethod[OPAL_SET]);\n\tadd_token_u8(&err, dev, OPAL_STARTNAME);\n\tadd_token_u8(&err, dev, OPAL_VALUES);\n\tadd_token_u8(&err, dev, OPAL_STARTLIST);\n\tadd_token_u8(&err, dev, OPAL_STARTNAME);\n\tadd_token_u8(&err, dev, 5);  \n\tadd_token_u8(&err, dev, OPAL_TRUE);\n\tadd_token_u8(&err, dev, OPAL_ENDNAME);\n\tadd_token_u8(&err, dev, OPAL_ENDLIST);\n\tadd_token_u8(&err, dev, OPAL_ENDNAME);\n\n\tif (err) {\n\t\tpr_debug(\"Error building Activate UserN command.\\n\");\n\t\treturn err;\n\t}\n\n\treturn finalize_and_send(dev, parse_and_check_status);\n}\n\nstatic int revert_lsp(struct opal_dev *dev, void *data)\n{\n\tstruct opal_revert_lsp *rev = data;\n\tint err;\n\n\terr = cmd_start(dev, opaluid[OPAL_THISSP_UID],\n\t\t\topalmethod[OPAL_REVERTSP]);\n\tadd_token_u8(&err, dev, OPAL_STARTNAME);\n\tadd_token_u64(&err, dev, OPAL_KEEP_GLOBAL_RANGE_KEY);\n\tadd_token_u8(&err, dev, (rev->options & OPAL_PRESERVE) ?\n\t\t\tOPAL_TRUE : OPAL_FALSE);\n\tadd_token_u8(&err, dev, OPAL_ENDNAME);\n\tif (err) {\n\t\tpr_debug(\"Error building REVERT SP command.\\n\");\n\t\treturn err;\n\t}\n\n\treturn finalize_and_send(dev, parse_and_check_status);\n}\n\nstatic int erase_locking_range(struct opal_dev *dev, void *data)\n{\n\tstruct opal_session_info *session = data;\n\tu8 uid[OPAL_UID_LENGTH];\n\tint err;\n\n\tif (build_locking_range(uid, sizeof(uid), session->opal_key.lr) < 0)\n\t\treturn -ERANGE;\n\n\terr = cmd_start(dev, uid, opalmethod[OPAL_ERASE]);\n\n\tif (err) {\n\t\tpr_debug(\"Error building Erase Locking Range Command.\\n\");\n\t\treturn err;\n\t}\n\n\treturn finalize_and_send(dev, parse_and_check_status);\n}\n\nstatic int set_mbr_done(struct opal_dev *dev, void *data)\n{\n\tu8 *mbr_done_tf = data;\n\tint err;\n\n\terr = cmd_start(dev, opaluid[OPAL_MBRCONTROL],\n\t\t\topalmethod[OPAL_SET]);\n\n\tadd_token_u8(&err, dev, OPAL_STARTNAME);\n\tadd_token_u8(&err, dev, OPAL_VALUES);\n\tadd_token_u8(&err, dev, OPAL_STARTLIST);\n\tadd_token_u8(&err, dev, OPAL_STARTNAME);\n\tadd_token_u8(&err, dev, OPAL_MBRDONE);\n\tadd_token_u8(&err, dev, *mbr_done_tf);  \n\tadd_token_u8(&err, dev, OPAL_ENDNAME);\n\tadd_token_u8(&err, dev, OPAL_ENDLIST);\n\tadd_token_u8(&err, dev, OPAL_ENDNAME);\n\n\tif (err) {\n\t\tpr_debug(\"Error Building set MBR Done command\\n\");\n\t\treturn err;\n\t}\n\n\treturn finalize_and_send(dev, parse_and_check_status);\n}\n\nstatic int set_mbr_enable_disable(struct opal_dev *dev, void *data)\n{\n\tu8 *mbr_en_dis = data;\n\tint err;\n\n\terr = cmd_start(dev, opaluid[OPAL_MBRCONTROL],\n\t\t\topalmethod[OPAL_SET]);\n\n\tadd_token_u8(&err, dev, OPAL_STARTNAME);\n\tadd_token_u8(&err, dev, OPAL_VALUES);\n\tadd_token_u8(&err, dev, OPAL_STARTLIST);\n\tadd_token_u8(&err, dev, OPAL_STARTNAME);\n\tadd_token_u8(&err, dev, OPAL_MBRENABLE);\n\tadd_token_u8(&err, dev, *mbr_en_dis);\n\tadd_token_u8(&err, dev, OPAL_ENDNAME);\n\tadd_token_u8(&err, dev, OPAL_ENDLIST);\n\tadd_token_u8(&err, dev, OPAL_ENDNAME);\n\n\tif (err) {\n\t\tpr_debug(\"Error Building set MBR done command\\n\");\n\t\treturn err;\n\t}\n\n\treturn finalize_and_send(dev, parse_and_check_status);\n}\n\nstatic int write_shadow_mbr(struct opal_dev *dev, void *data)\n{\n\tstruct opal_shadow_mbr *shadow = data;\n\n\treturn generic_table_write_data(dev, shadow->data, shadow->offset,\n\t\t\t\t\tshadow->size, opaluid[OPAL_MBR]);\n}\n\nstatic int generic_pw_cmd(u8 *key, size_t key_len, u8 *cpin_uid,\n\t\t\t  struct opal_dev *dev)\n{\n\tint err;\n\n\terr = cmd_start(dev, cpin_uid, opalmethod[OPAL_SET]);\n\n\tadd_token_u8(&err, dev, OPAL_STARTNAME);\n\tadd_token_u8(&err, dev, OPAL_VALUES);\n\tadd_token_u8(&err, dev, OPAL_STARTLIST);\n\tadd_token_u8(&err, dev, OPAL_STARTNAME);\n\tadd_token_u8(&err, dev, OPAL_PIN);\n\tadd_token_bytestring(&err, dev, key, key_len);\n\tadd_token_u8(&err, dev, OPAL_ENDNAME);\n\tadd_token_u8(&err, dev, OPAL_ENDLIST);\n\tadd_token_u8(&err, dev, OPAL_ENDNAME);\n\n\treturn err;\n}\n\nstatic int set_new_pw(struct opal_dev *dev, void *data)\n{\n\tu8 cpin_uid[OPAL_UID_LENGTH];\n\tstruct opal_session_info *usr = data;\n\n\tmemcpy(cpin_uid, opaluid[OPAL_C_PIN_ADMIN1], OPAL_UID_LENGTH);\n\n\tif (usr->who != OPAL_ADMIN1) {\n\t\tcpin_uid[5] = 0x03;\n\t\tif (usr->sum)\n\t\t\tcpin_uid[7] = usr->opal_key.lr + 1;\n\t\telse\n\t\t\tcpin_uid[7] = usr->who;\n\t}\n\n\tif (generic_pw_cmd(usr->opal_key.key, usr->opal_key.key_len,\n\t\t\t   cpin_uid, dev)) {\n\t\tpr_debug(\"Error building set password command.\\n\");\n\t\treturn -ERANGE;\n\t}\n\n\treturn finalize_and_send(dev, parse_and_check_status);\n}\n\nstatic int set_sid_cpin_pin(struct opal_dev *dev, void *data)\n{\n\tu8 cpin_uid[OPAL_UID_LENGTH];\n\tstruct opal_key *key = data;\n\n\tmemcpy(cpin_uid, opaluid[OPAL_C_PIN_SID], OPAL_UID_LENGTH);\n\n\tif (generic_pw_cmd(key->key, key->key_len, cpin_uid, dev)) {\n\t\tpr_debug(\"Error building Set SID cpin\\n\");\n\t\treturn -ERANGE;\n\t}\n\treturn finalize_and_send(dev, parse_and_check_status);\n}\n\nstatic void add_authority_object_ref(int *err,\n\t\t\t\t     struct opal_dev *dev,\n\t\t\t\t     const u8 *uid,\n\t\t\t\t     size_t uid_len)\n{\n\tadd_token_u8(err, dev, OPAL_STARTNAME);\n\tadd_token_bytestring(err, dev,\n\t\t\t     opaluid[OPAL_HALF_UID_AUTHORITY_OBJ_REF],\n\t\t\t     OPAL_UID_LENGTH/2);\n\tadd_token_bytestring(err, dev, uid, uid_len);\n\tadd_token_u8(err, dev, OPAL_ENDNAME);\n}\n\nstatic void add_boolean_object_ref(int *err,\n\t\t\t\t   struct opal_dev *dev,\n\t\t\t\t   u8 boolean_op)\n{\n\tadd_token_u8(err, dev, OPAL_STARTNAME);\n\tadd_token_bytestring(err, dev, opaluid[OPAL_HALF_UID_BOOLEAN_ACE],\n\t\t\t     OPAL_UID_LENGTH/2);\n\tadd_token_u8(err, dev, boolean_op);\n\tadd_token_u8(err, dev, OPAL_ENDNAME);\n}\n\nstatic int set_lr_boolean_ace(struct opal_dev *dev,\n\t\t\t      unsigned int opal_uid,\n\t\t\t      u8 lr,\n\t\t\t      const u8 *users,\n\t\t\t      size_t users_len)\n{\n\tu8 lr_buffer[OPAL_UID_LENGTH];\n\tu8 user_uid[OPAL_UID_LENGTH];\n\tu8 u;\n\tint err;\n\n\tmemcpy(lr_buffer, opaluid[opal_uid], OPAL_UID_LENGTH);\n\tlr_buffer[7] = lr;\n\n\terr = cmd_start(dev, lr_buffer, opalmethod[OPAL_SET]);\n\n\tadd_token_u8(&err, dev, OPAL_STARTNAME);\n\tadd_token_u8(&err, dev, OPAL_VALUES);\n\n\tadd_token_u8(&err, dev, OPAL_STARTLIST);\n\tadd_token_u8(&err, dev, OPAL_STARTNAME);\n\tadd_token_u8(&err, dev, 3);\n\n\tadd_token_u8(&err, dev, OPAL_STARTLIST);\n\n\tfor (u = 0; u < users_len; u++) {\n\t\tif (users[u] == OPAL_ADMIN1)\n\t\t\tmemcpy(user_uid, opaluid[OPAL_ADMIN1_UID],\n\t\t\t       OPAL_UID_LENGTH);\n\t\telse {\n\t\t\tmemcpy(user_uid, opaluid[OPAL_USER1_UID],\n\t\t\t       OPAL_UID_LENGTH);\n\t\t\tuser_uid[7] = users[u];\n\t\t}\n\n\t\tadd_authority_object_ref(&err, dev, user_uid, sizeof(user_uid));\n\n\t\t \n\t\tif (u > 0)\n\t\t\tadd_boolean_object_ref(&err, dev, OPAL_BOOLEAN_OR);\n\t}\n\n\tadd_token_u8(&err, dev, OPAL_ENDLIST);\n\tadd_token_u8(&err, dev, OPAL_ENDNAME);\n\tadd_token_u8(&err, dev, OPAL_ENDLIST);\n\tadd_token_u8(&err, dev, OPAL_ENDNAME);\n\n\treturn err;\n}\n\nstatic int add_user_to_lr(struct opal_dev *dev, void *data)\n{\n\tint err;\n\tstruct opal_lock_unlock *lkul = data;\n\tconst u8 users[] = {\n\t\tlkul->session.who\n\t};\n\n\terr = set_lr_boolean_ace(dev,\n\t\t\t\t lkul->l_state == OPAL_RW ?\n\t\t\t\t\tOPAL_LOCKINGRANGE_ACE_WRLOCKED :\n\t\t\t\t\tOPAL_LOCKINGRANGE_ACE_RDLOCKED,\n\t\t\t\t lkul->session.opal_key.lr, users,\n\t\t\t\t ARRAY_SIZE(users));\n\tif (err) {\n\t\tpr_debug(\"Error building add user to locking range command.\\n\");\n\t\treturn err;\n\t}\n\n\treturn finalize_and_send(dev, parse_and_check_status);\n}\n\nstatic int add_user_to_lr_ace(struct opal_dev *dev, void *data)\n{\n\tint err;\n\tstruct opal_lock_unlock *lkul = data;\n\tconst u8 users[] = {\n\t\tOPAL_ADMIN1,\n\t\tlkul->session.who\n\t};\n\n\terr = set_lr_boolean_ace(dev, OPAL_LOCKINGRANGE_ACE_START_TO_KEY,\n\t\t\t\t lkul->session.opal_key.lr, users,\n\t\t\t\t ARRAY_SIZE(users));\n\n\tif (err) {\n\t\tpr_debug(\"Error building add user to locking ranges ACEs.\\n\");\n\t\treturn err;\n\t}\n\n\treturn finalize_and_send(dev, parse_and_check_status);\n}\n\nstatic int lock_unlock_locking_range(struct opal_dev *dev, void *data)\n{\n\tu8 lr_buffer[OPAL_UID_LENGTH];\n\tstruct opal_lock_unlock *lkul = data;\n\tu8 read_locked = 1, write_locked = 1;\n\tint err = 0;\n\n\tif (build_locking_range(lr_buffer, sizeof(lr_buffer),\n\t\t\t\tlkul->session.opal_key.lr) < 0)\n\t\treturn -ERANGE;\n\n\tswitch (lkul->l_state) {\n\tcase OPAL_RO:\n\t\tread_locked = 0;\n\t\twrite_locked = 1;\n\t\tbreak;\n\tcase OPAL_RW:\n\t\tread_locked = 0;\n\t\twrite_locked = 0;\n\t\tbreak;\n\tcase OPAL_LK:\n\t\t \n\t\tbreak;\n\tdefault:\n\t\tpr_debug(\"Tried to set an invalid locking state... returning to uland\\n\");\n\t\treturn OPAL_INVAL_PARAM;\n\t}\n\n\terr = cmd_start(dev, lr_buffer, opalmethod[OPAL_SET]);\n\n\tadd_token_u8(&err, dev, OPAL_STARTNAME);\n\tadd_token_u8(&err, dev, OPAL_VALUES);\n\tadd_token_u8(&err, dev, OPAL_STARTLIST);\n\n\tadd_token_u8(&err, dev, OPAL_STARTNAME);\n\tadd_token_u8(&err, dev, OPAL_READLOCKED);\n\tadd_token_u8(&err, dev, read_locked);\n\tadd_token_u8(&err, dev, OPAL_ENDNAME);\n\n\tadd_token_u8(&err, dev, OPAL_STARTNAME);\n\tadd_token_u8(&err, dev, OPAL_WRITELOCKED);\n\tadd_token_u8(&err, dev, write_locked);\n\tadd_token_u8(&err, dev, OPAL_ENDNAME);\n\n\tadd_token_u8(&err, dev, OPAL_ENDLIST);\n\tadd_token_u8(&err, dev, OPAL_ENDNAME);\n\n\tif (err) {\n\t\tpr_debug(\"Error building SET command.\\n\");\n\t\treturn err;\n\t}\n\n\treturn finalize_and_send(dev, parse_and_check_status);\n}\n\n\nstatic int lock_unlock_locking_range_sum(struct opal_dev *dev, void *data)\n{\n\tu8 lr_buffer[OPAL_UID_LENGTH];\n\tu8 read_locked = 1, write_locked = 1;\n\tstruct opal_lock_unlock *lkul = data;\n\tint ret;\n\n\tclear_opal_cmd(dev);\n\tset_comid(dev, dev->comid);\n\n\tif (build_locking_range(lr_buffer, sizeof(lr_buffer),\n\t\t\t\tlkul->session.opal_key.lr) < 0)\n\t\treturn -ERANGE;\n\n\tswitch (lkul->l_state) {\n\tcase OPAL_RO:\n\t\tread_locked = 0;\n\t\twrite_locked = 1;\n\t\tbreak;\n\tcase OPAL_RW:\n\t\tread_locked = 0;\n\t\twrite_locked = 0;\n\t\tbreak;\n\tcase OPAL_LK:\n\t\t \n\t\tbreak;\n\tdefault:\n\t\tpr_debug(\"Tried to set an invalid locking state.\\n\");\n\t\treturn OPAL_INVAL_PARAM;\n\t}\n\tret = generic_lr_enable_disable(dev, lr_buffer, 1, 1,\n\t\t\t\t\tread_locked, write_locked);\n\n\tif (ret < 0) {\n\t\tpr_debug(\"Error building SET command.\\n\");\n\t\treturn ret;\n\t}\n\n\treturn finalize_and_send(dev, parse_and_check_status);\n}\n\nstatic int activate_lsp(struct opal_dev *dev, void *data)\n{\n\tstruct opal_lr_act *opal_act = data;\n\tu8 user_lr[OPAL_UID_LENGTH];\n\tint err, i;\n\n\terr = cmd_start(dev, opaluid[OPAL_LOCKINGSP_UID],\n\t\t\topalmethod[OPAL_ACTIVATE]);\n\n\tif (opal_act->sum) {\n\t\terr = build_locking_range(user_lr, sizeof(user_lr),\n\t\t\t\t\t  opal_act->lr[0]);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tadd_token_u8(&err, dev, OPAL_STARTNAME);\n\t\tadd_token_u64(&err, dev, OPAL_SUM_SET_LIST);\n\n\t\tadd_token_u8(&err, dev, OPAL_STARTLIST);\n\t\tadd_token_bytestring(&err, dev, user_lr, OPAL_UID_LENGTH);\n\t\tfor (i = 1; i < opal_act->num_lrs; i++) {\n\t\t\tuser_lr[7] = opal_act->lr[i];\n\t\t\tadd_token_bytestring(&err, dev, user_lr, OPAL_UID_LENGTH);\n\t\t}\n\t\tadd_token_u8(&err, dev, OPAL_ENDLIST);\n\t\tadd_token_u8(&err, dev, OPAL_ENDNAME);\n\t}\n\n\tif (err) {\n\t\tpr_debug(\"Error building Activate LockingSP command.\\n\");\n\t\treturn err;\n\t}\n\n\treturn finalize_and_send(dev, parse_and_check_status);\n}\n\n \nstatic int get_lsp_lifecycle(struct opal_dev *dev, void *data)\n{\n\tu8 lc_status;\n\tint err;\n\n\terr = generic_get_column(dev, opaluid[OPAL_LOCKINGSP_UID],\n\t\t\t\t OPAL_LIFECYCLE);\n\tif (err)\n\t\treturn err;\n\n\tlc_status = response_get_u64(&dev->parsed, 4);\n\t \n\t \n\tif (lc_status != OPAL_MANUFACTURED_INACTIVE) {\n\t\tpr_debug(\"Couldn't determine the status of the Lifecycle state\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\nstatic int get_msid_cpin_pin(struct opal_dev *dev, void *data)\n{\n\tconst char *msid_pin;\n\tsize_t strlen;\n\tint err;\n\n\terr = generic_get_column(dev, opaluid[OPAL_C_PIN_MSID], OPAL_PIN);\n\tif (err)\n\t\treturn err;\n\n\tstrlen = response_get_string(&dev->parsed, 4, &msid_pin);\n\tif (!msid_pin) {\n\t\tpr_debug(\"Couldn't extract MSID_CPIN from response\\n\");\n\t\treturn OPAL_INVAL_PARAM;\n\t}\n\n\tdev->prev_data = kmemdup(msid_pin, strlen, GFP_KERNEL);\n\tif (!dev->prev_data)\n\t\treturn -ENOMEM;\n\n\tdev->prev_d_len = strlen;\n\n\treturn 0;\n}\n\nstatic int write_table_data(struct opal_dev *dev, void *data)\n{\n\tstruct opal_read_write_table *write_tbl = data;\n\n\treturn generic_table_write_data(dev, write_tbl->data, write_tbl->offset,\n\t\t\t\t\twrite_tbl->size, write_tbl->table_uid);\n}\n\nstatic int read_table_data_cont(struct opal_dev *dev)\n{\n\tint err;\n\tconst char *data_read;\n\n\terr = parse_and_check_status(dev);\n\tif (err)\n\t\treturn err;\n\n\tdev->prev_d_len = response_get_string(&dev->parsed, 1, &data_read);\n\tdev->prev_data = (void *)data_read;\n\tif (!dev->prev_data) {\n\t\tpr_debug(\"%s: Couldn't read data from the table.\\n\", __func__);\n\t\treturn OPAL_INVAL_PARAM;\n\t}\n\n\treturn 0;\n}\n\n \n#define OPAL_MAX_READ_TABLE (0x7BD)\n\nstatic int read_table_data(struct opal_dev *dev, void *data)\n{\n\tstruct opal_read_write_table *read_tbl = data;\n\tint err;\n\tsize_t off = 0, max_read_size = OPAL_MAX_READ_TABLE;\n\tu64 table_len, len;\n\tu64 offset = read_tbl->offset, read_size = read_tbl->size - 1;\n\tu8 __user *dst;\n\n\terr = generic_get_table_info(dev, read_tbl->table_uid, OPAL_TABLE_ROWS);\n\tif (err) {\n\t\tpr_debug(\"Couldn't get the table size\\n\");\n\t\treturn err;\n\t}\n\n\ttable_len = response_get_u64(&dev->parsed, 4);\n\n\t \n\tif (read_size > table_len || offset > table_len - read_size) {\n\t\tpr_debug(\"Read size exceeds the Table size limits (%llu vs. %llu)\\n\",\n\t\t\t  offset + read_size, table_len);\n\t\treturn -EINVAL;\n\t}\n\n\twhile (off < read_size) {\n\t\terr = cmd_start(dev, read_tbl->table_uid, opalmethod[OPAL_GET]);\n\n\t\tadd_token_u8(&err, dev, OPAL_STARTLIST);\n\t\tadd_token_u8(&err, dev, OPAL_STARTNAME);\n\t\tadd_token_u8(&err, dev, OPAL_STARTROW);\n\t\tadd_token_u64(&err, dev, offset + off);  \n\t\tadd_token_u8(&err, dev, OPAL_ENDNAME);\n\n\t\tadd_token_u8(&err, dev, OPAL_STARTNAME);\n\t\tadd_token_u8(&err, dev, OPAL_ENDROW);\n\n\t\tlen = min(max_read_size, (size_t)(read_size - off));\n\t\tadd_token_u64(&err, dev, offset + off + len);  \n\t\tadd_token_u8(&err, dev, OPAL_ENDNAME);\n\t\tadd_token_u8(&err, dev, OPAL_ENDLIST);\n\n\t\tif (err) {\n\t\t\tpr_debug(\"Error building read table data command.\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\terr = finalize_and_send(dev, read_table_data_cont);\n\t\tif (err)\n\t\t\tbreak;\n\n\t\t \n\t\tif (dev->prev_d_len > len + 1) {\n\t\t\terr = -EOVERFLOW;\n\t\t\tbreak;\n\t\t}\n\n\t\tdst = (u8 __user *)(uintptr_t)read_tbl->data;\n\t\tif (copy_to_user(dst + off, dev->prev_data, dev->prev_d_len)) {\n\t\t\tpr_debug(\"Error copying data to userspace\\n\");\n\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tdev->prev_data = NULL;\n\n\t\toff += len;\n\t}\n\n\treturn err;\n}\n\nstatic int end_opal_session(struct opal_dev *dev, void *data)\n{\n\tint err = 0;\n\n\tclear_opal_cmd(dev);\n\tset_comid(dev, dev->comid);\n\tadd_token_u8(&err, dev, OPAL_ENDOFSESSION);\n\n\tif (err < 0)\n\t\treturn err;\n\n\treturn finalize_and_send(dev, end_session_cont);\n}\n\nstatic int end_opal_session_error(struct opal_dev *dev)\n{\n\tconst struct opal_step error_end_session = {\n\t\tend_opal_session,\n\t};\n\n\treturn execute_step(dev, &error_end_session, 0);\n}\n\nstatic inline void setup_opal_dev(struct opal_dev *dev)\n{\n\tdev->tsn = 0;\n\tdev->hsn = 0;\n\tdev->prev_data = NULL;\n}\n\nstatic int check_opal_support(struct opal_dev *dev)\n{\n\tint ret;\n\n\tmutex_lock(&dev->dev_lock);\n\tsetup_opal_dev(dev);\n\tret = opal_discovery0_step(dev);\n\tif (!ret)\n\t\tdev->flags |= OPAL_FL_SUPPORTED;\n\tmutex_unlock(&dev->dev_lock);\n\n\treturn ret;\n}\n\nstatic void clean_opal_dev(struct opal_dev *dev)\n{\n\n\tstruct opal_suspend_data *suspend, *next;\n\n\tmutex_lock(&dev->dev_lock);\n\tlist_for_each_entry_safe(suspend, next, &dev->unlk_lst, node) {\n\t\tlist_del(&suspend->node);\n\t\tkfree(suspend);\n\t}\n\tmutex_unlock(&dev->dev_lock);\n}\n\nvoid free_opal_dev(struct opal_dev *dev)\n{\n\tif (!dev)\n\t\treturn;\n\n\tclean_opal_dev(dev);\n\tkfree(dev->resp);\n\tkfree(dev->cmd);\n\tkfree(dev);\n}\nEXPORT_SYMBOL(free_opal_dev);\n\nstruct opal_dev *init_opal_dev(void *data, sec_send_recv *send_recv)\n{\n\tstruct opal_dev *dev;\n\n\tdev = kmalloc(sizeof(*dev), GFP_KERNEL);\n\tif (!dev)\n\t\treturn NULL;\n\n\t \n\tdev->cmd = kmalloc(IO_BUFFER_LENGTH, GFP_KERNEL);\n\tif (!dev->cmd)\n\t\tgoto err_free_dev;\n\n\tdev->resp = kmalloc(IO_BUFFER_LENGTH, GFP_KERNEL);\n\tif (!dev->resp)\n\t\tgoto err_free_cmd;\n\n\tINIT_LIST_HEAD(&dev->unlk_lst);\n\tmutex_init(&dev->dev_lock);\n\tdev->flags = 0;\n\tdev->data = data;\n\tdev->send_recv = send_recv;\n\tif (check_opal_support(dev) != 0) {\n\t\tpr_debug(\"Opal is not supported on this device\\n\");\n\t\tgoto err_free_resp;\n\t}\n\n\treturn dev;\n\nerr_free_resp:\n\tkfree(dev->resp);\n\nerr_free_cmd:\n\tkfree(dev->cmd);\n\nerr_free_dev:\n\tkfree(dev);\n\n\treturn NULL;\n}\nEXPORT_SYMBOL(init_opal_dev);\n\nstatic int opal_secure_erase_locking_range(struct opal_dev *dev,\n\t\t\t\t\t   struct opal_session_info *opal_session)\n{\n\tconst struct opal_step erase_steps[] = {\n\t\t{ start_auth_opal_session, opal_session },\n\t\t{ get_active_key, &opal_session->opal_key.lr },\n\t\t{ gen_key, },\n\t\t{ end_opal_session, }\n\t};\n\tint ret;\n\n\tret = opal_get_key(dev, &opal_session->opal_key);\n\tif (ret)\n\t\treturn ret;\n\tmutex_lock(&dev->dev_lock);\n\tsetup_opal_dev(dev);\n\tret = execute_steps(dev, erase_steps, ARRAY_SIZE(erase_steps));\n\tmutex_unlock(&dev->dev_lock);\n\n\treturn ret;\n}\n\nstatic int opal_get_discv(struct opal_dev *dev, struct opal_discovery *discv)\n{\n\tconst struct opal_step discovery0_step = {\n\t\topal_discovery0, discv\n\t};\n\tint ret = 0;\n\n\tmutex_lock(&dev->dev_lock);\n\tsetup_opal_dev(dev);\n\tret = execute_step(dev, &discovery0_step, 0);\n\tmutex_unlock(&dev->dev_lock);\n\tif (ret)\n\t\treturn ret;\n\treturn discv->size;  \n}\n\nstatic int opal_revertlsp(struct opal_dev *dev, struct opal_revert_lsp *rev)\n{\n\t \n\tconst struct opal_step steps[] = {\n\t\t{ start_admin1LSP_opal_session, &rev->key },\n\t\t{ revert_lsp, rev }\n\t};\n\tint ret;\n\n\tret = opal_get_key(dev, &rev->key);\n\tif (ret)\n\t\treturn ret;\n\tmutex_lock(&dev->dev_lock);\n\tsetup_opal_dev(dev);\n\tret = execute_steps(dev, steps, ARRAY_SIZE(steps));\n\tmutex_unlock(&dev->dev_lock);\n\n\treturn ret;\n}\n\nstatic int opal_erase_locking_range(struct opal_dev *dev,\n\t\t\t\t    struct opal_session_info *opal_session)\n{\n\tconst struct opal_step erase_steps[] = {\n\t\t{ start_auth_opal_session, opal_session },\n\t\t{ erase_locking_range, opal_session },\n\t\t{ end_opal_session, }\n\t};\n\tint ret;\n\n\tret = opal_get_key(dev, &opal_session->opal_key);\n\tif (ret)\n\t\treturn ret;\n\tmutex_lock(&dev->dev_lock);\n\tsetup_opal_dev(dev);\n\tret = execute_steps(dev, erase_steps, ARRAY_SIZE(erase_steps));\n\tmutex_unlock(&dev->dev_lock);\n\n\treturn ret;\n}\n\nstatic int opal_enable_disable_shadow_mbr(struct opal_dev *dev,\n\t\t\t\t\t  struct opal_mbr_data *opal_mbr)\n{\n\tu8 enable_disable = opal_mbr->enable_disable == OPAL_MBR_ENABLE ?\n\t\tOPAL_TRUE : OPAL_FALSE;\n\n\tconst struct opal_step mbr_steps[] = {\n\t\t{ start_admin1LSP_opal_session, &opal_mbr->key },\n\t\t{ set_mbr_done, &enable_disable },\n\t\t{ end_opal_session, },\n\t\t{ start_admin1LSP_opal_session, &opal_mbr->key },\n\t\t{ set_mbr_enable_disable, &enable_disable },\n\t\t{ end_opal_session, }\n\t};\n\tint ret;\n\n\tif (opal_mbr->enable_disable != OPAL_MBR_ENABLE &&\n\t    opal_mbr->enable_disable != OPAL_MBR_DISABLE)\n\t\treturn -EINVAL;\n\n\tret = opal_get_key(dev, &opal_mbr->key);\n\tif (ret)\n\t\treturn ret;\n\tmutex_lock(&dev->dev_lock);\n\tsetup_opal_dev(dev);\n\tret = execute_steps(dev, mbr_steps, ARRAY_SIZE(mbr_steps));\n\tmutex_unlock(&dev->dev_lock);\n\n\treturn ret;\n}\n\nstatic int opal_set_mbr_done(struct opal_dev *dev,\n\t\t\t     struct opal_mbr_done *mbr_done)\n{\n\tu8 mbr_done_tf = mbr_done->done_flag == OPAL_MBR_DONE ?\n\t\tOPAL_TRUE : OPAL_FALSE;\n\n\tconst struct opal_step mbr_steps[] = {\n\t\t{ start_admin1LSP_opal_session, &mbr_done->key },\n\t\t{ set_mbr_done, &mbr_done_tf },\n\t\t{ end_opal_session, }\n\t};\n\tint ret;\n\n\tif (mbr_done->done_flag != OPAL_MBR_DONE &&\n\t    mbr_done->done_flag != OPAL_MBR_NOT_DONE)\n\t\treturn -EINVAL;\n\n\tret = opal_get_key(dev, &mbr_done->key);\n\tif (ret)\n\t\treturn ret;\n\tmutex_lock(&dev->dev_lock);\n\tsetup_opal_dev(dev);\n\tret = execute_steps(dev, mbr_steps, ARRAY_SIZE(mbr_steps));\n\tmutex_unlock(&dev->dev_lock);\n\n\treturn ret;\n}\n\nstatic int opal_write_shadow_mbr(struct opal_dev *dev,\n\t\t\t\t struct opal_shadow_mbr *info)\n{\n\tconst struct opal_step mbr_steps[] = {\n\t\t{ start_admin1LSP_opal_session, &info->key },\n\t\t{ write_shadow_mbr, info },\n\t\t{ end_opal_session, }\n\t};\n\tint ret;\n\n\tif (info->size == 0)\n\t\treturn 0;\n\n\tret = opal_get_key(dev, &info->key);\n\tif (ret)\n\t\treturn ret;\n\tmutex_lock(&dev->dev_lock);\n\tsetup_opal_dev(dev);\n\tret = execute_steps(dev, mbr_steps, ARRAY_SIZE(mbr_steps));\n\tmutex_unlock(&dev->dev_lock);\n\n\treturn ret;\n}\n\nstatic int opal_save(struct opal_dev *dev, struct opal_lock_unlock *lk_unlk)\n{\n\tstruct opal_suspend_data *suspend;\n\n\tsuspend = kzalloc(sizeof(*suspend), GFP_KERNEL);\n\tif (!suspend)\n\t\treturn -ENOMEM;\n\n\tsuspend->unlk = *lk_unlk;\n\tsuspend->lr = lk_unlk->session.opal_key.lr;\n\n\tmutex_lock(&dev->dev_lock);\n\tsetup_opal_dev(dev);\n\tadd_suspend_info(dev, suspend);\n\tmutex_unlock(&dev->dev_lock);\n\n\treturn 0;\n}\n\nstatic int opal_add_user_to_lr(struct opal_dev *dev,\n\t\t\t       struct opal_lock_unlock *lk_unlk)\n{\n\tconst struct opal_step steps[] = {\n\t\t{ start_admin1LSP_opal_session, &lk_unlk->session.opal_key },\n\t\t{ add_user_to_lr, lk_unlk },\n\t\t{ add_user_to_lr_ace, lk_unlk },\n\t\t{ end_opal_session, }\n\t};\n\tint ret;\n\n\tif (lk_unlk->l_state != OPAL_RO &&\n\t    lk_unlk->l_state != OPAL_RW) {\n\t\tpr_debug(\"Locking state was not RO or RW\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (lk_unlk->session.who < OPAL_USER1 ||\n\t    lk_unlk->session.who > OPAL_USER9) {\n\t\tpr_debug(\"Authority was not within the range of users: %d\\n\",\n\t\t\t lk_unlk->session.who);\n\t\treturn -EINVAL;\n\t}\n\n\tif (lk_unlk->session.sum) {\n\t\tpr_debug(\"%s not supported in sum. Use setup locking range\\n\",\n\t\t\t __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tret = opal_get_key(dev, &lk_unlk->session.opal_key);\n\tif (ret)\n\t\treturn ret;\n\tmutex_lock(&dev->dev_lock);\n\tsetup_opal_dev(dev);\n\tret = execute_steps(dev, steps, ARRAY_SIZE(steps));\n\tmutex_unlock(&dev->dev_lock);\n\n\treturn ret;\n}\n\nstatic int opal_reverttper(struct opal_dev *dev, struct opal_key *opal, bool psid)\n{\n\t \n\tconst struct opal_step revert_steps[] = {\n\t\t{ start_SIDASP_opal_session, opal },\n\t\t{ revert_tper, }\n\t};\n\tconst struct opal_step psid_revert_steps[] = {\n\t\t{ start_PSID_opal_session, opal },\n\t\t{ revert_tper, }\n\t};\n\n\tint ret;\n\n\tret = opal_get_key(dev, opal);\n\n\tif (ret)\n\t\treturn ret;\n\tmutex_lock(&dev->dev_lock);\n\tsetup_opal_dev(dev);\n\tif (psid)\n\t\tret = execute_steps(dev, psid_revert_steps,\n\t\t\t\t    ARRAY_SIZE(psid_revert_steps));\n\telse\n\t\tret = execute_steps(dev, revert_steps,\n\t\t\t\t    ARRAY_SIZE(revert_steps));\n\tmutex_unlock(&dev->dev_lock);\n\n\t \n\tif (!ret)\n\t\tclean_opal_dev(dev);\n\n\treturn ret;\n}\n\nstatic int __opal_lock_unlock(struct opal_dev *dev,\n\t\t\t      struct opal_lock_unlock *lk_unlk)\n{\n\tconst struct opal_step unlock_steps[] = {\n\t\t{ start_auth_opal_session, &lk_unlk->session },\n\t\t{ lock_unlock_locking_range, lk_unlk },\n\t\t{ end_opal_session, }\n\t};\n\tconst struct opal_step unlock_sum_steps[] = {\n\t\t{ start_auth_opal_session, &lk_unlk->session },\n\t\t{ lock_unlock_locking_range_sum, lk_unlk },\n\t\t{ end_opal_session, }\n\t};\n\n\tif (lk_unlk->session.sum)\n\t\treturn execute_steps(dev, unlock_sum_steps,\n\t\t\t\t     ARRAY_SIZE(unlock_sum_steps));\n\telse\n\t\treturn execute_steps(dev, unlock_steps,\n\t\t\t\t     ARRAY_SIZE(unlock_steps));\n}\n\nstatic int __opal_set_mbr_done(struct opal_dev *dev, struct opal_key *key)\n{\n\tu8 mbr_done_tf = OPAL_TRUE;\n\tconst struct opal_step mbrdone_step[] = {\n\t\t{ start_admin1LSP_opal_session, key },\n\t\t{ set_mbr_done, &mbr_done_tf },\n\t\t{ end_opal_session, }\n\t};\n\n\treturn execute_steps(dev, mbrdone_step, ARRAY_SIZE(mbrdone_step));\n}\n\nstatic void opal_lock_check_for_saved_key(struct opal_dev *dev,\n\t\t\t    struct opal_lock_unlock *lk_unlk)\n{\n\tstruct opal_suspend_data *iter;\n\n\tif (lk_unlk->l_state != OPAL_LK ||\n\t\t\tlk_unlk->session.opal_key.key_len > 0)\n\t\treturn;\n\n\t \n\tsetup_opal_dev(dev);\n\tlist_for_each_entry(iter, &dev->unlk_lst, node) {\n\t\tif ((iter->unlk.flags & OPAL_SAVE_FOR_LOCK) &&\n\t\t\t\titer->lr == lk_unlk->session.opal_key.lr &&\n\t\t\t\titer->unlk.session.opal_key.key_len > 0) {\n\t\t\tlk_unlk->session.opal_key.key_len =\n\t\t\t\titer->unlk.session.opal_key.key_len;\n\t\t\tmemcpy(lk_unlk->session.opal_key.key,\n\t\t\t\titer->unlk.session.opal_key.key,\n\t\t\t\titer->unlk.session.opal_key.key_len);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic int opal_lock_unlock(struct opal_dev *dev,\n\t\t\t    struct opal_lock_unlock *lk_unlk)\n{\n\tint ret;\n\n\tif (lk_unlk->session.who > OPAL_USER9)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&dev->dev_lock);\n\topal_lock_check_for_saved_key(dev, lk_unlk);\n\tret = opal_get_key(dev, &lk_unlk->session.opal_key);\n\tif (!ret)\n\t\tret = __opal_lock_unlock(dev, lk_unlk);\n\tmutex_unlock(&dev->dev_lock);\n\n\treturn ret;\n}\n\nstatic int opal_take_ownership(struct opal_dev *dev, struct opal_key *opal)\n{\n\tconst struct opal_step owner_steps[] = {\n\t\t{ start_anybodyASP_opal_session, },\n\t\t{ get_msid_cpin_pin, },\n\t\t{ end_opal_session, },\n\t\t{ start_SIDASP_opal_session, opal },\n\t\t{ set_sid_cpin_pin, opal },\n\t\t{ end_opal_session, }\n\t};\n\tint ret;\n\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\tret = opal_get_key(dev, opal);\n\tif (ret)\n\t\treturn ret;\n\tmutex_lock(&dev->dev_lock);\n\tsetup_opal_dev(dev);\n\tret = execute_steps(dev, owner_steps, ARRAY_SIZE(owner_steps));\n\tmutex_unlock(&dev->dev_lock);\n\n\treturn ret;\n}\n\nstatic int opal_activate_lsp(struct opal_dev *dev,\n\t\t\t     struct opal_lr_act *opal_lr_act)\n{\n\tconst struct opal_step active_steps[] = {\n\t\t{ start_SIDASP_opal_session, &opal_lr_act->key },\n\t\t{ get_lsp_lifecycle, },\n\t\t{ activate_lsp, opal_lr_act },\n\t\t{ end_opal_session, }\n\t};\n\tint ret;\n\n\tif (!opal_lr_act->num_lrs || opal_lr_act->num_lrs > OPAL_MAX_LRS)\n\t\treturn -EINVAL;\n\n\tret = opal_get_key(dev, &opal_lr_act->key);\n\tif (ret)\n\t\treturn ret;\n\tmutex_lock(&dev->dev_lock);\n\tsetup_opal_dev(dev);\n\tret = execute_steps(dev, active_steps, ARRAY_SIZE(active_steps));\n\tmutex_unlock(&dev->dev_lock);\n\n\treturn ret;\n}\n\nstatic int opal_setup_locking_range(struct opal_dev *dev,\n\t\t\t\t    struct opal_user_lr_setup *opal_lrs)\n{\n\tconst struct opal_step lr_steps[] = {\n\t\t{ start_auth_opal_session, &opal_lrs->session },\n\t\t{ setup_locking_range, opal_lrs },\n\t\t{ end_opal_session, }\n\t};\n\tint ret;\n\n\tret = opal_get_key(dev, &opal_lrs->session.opal_key);\n\tif (ret)\n\t\treturn ret;\n\tmutex_lock(&dev->dev_lock);\n\tsetup_opal_dev(dev);\n\tret = execute_steps(dev, lr_steps, ARRAY_SIZE(lr_steps));\n\tmutex_unlock(&dev->dev_lock);\n\n\treturn ret;\n}\n\nstatic int opal_locking_range_status(struct opal_dev *dev,\n\t\t\t  struct opal_lr_status *opal_lrst,\n\t\t\t  void __user *data)\n{\n\tconst struct opal_step lr_steps[] = {\n\t\t{ start_auth_opal_session, &opal_lrst->session },\n\t\t{ locking_range_status, opal_lrst },\n\t\t{ end_opal_session, }\n\t};\n\tint ret;\n\n\tmutex_lock(&dev->dev_lock);\n\tsetup_opal_dev(dev);\n\tret = execute_steps(dev, lr_steps, ARRAY_SIZE(lr_steps));\n\tmutex_unlock(&dev->dev_lock);\n\n\t \n\tif (!ret && copy_to_user(data + offsetof(struct opal_lr_status, range_start),\n\t\t\t\t(void *)opal_lrst + offsetof(struct opal_lr_status, range_start),\n\t\t\t\tsizeof(*opal_lrst) - offsetof(struct opal_lr_status, range_start))) {\n\t\tpr_debug(\"Error copying status to userspace\\n\");\n\t\treturn -EFAULT;\n\t}\n\n\treturn ret;\n}\n\nstatic int opal_set_new_pw(struct opal_dev *dev, struct opal_new_pw *opal_pw)\n{\n\tconst struct opal_step pw_steps[] = {\n\t\t{ start_auth_opal_session, &opal_pw->session },\n\t\t{ set_new_pw, &opal_pw->new_user_pw },\n\t\t{ end_opal_session, }\n\t};\n\tint ret;\n\n\tif (opal_pw->session.who > OPAL_USER9  ||\n\t    opal_pw->new_user_pw.who > OPAL_USER9)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&dev->dev_lock);\n\tsetup_opal_dev(dev);\n\tret = execute_steps(dev, pw_steps, ARRAY_SIZE(pw_steps));\n\tmutex_unlock(&dev->dev_lock);\n\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = update_sed_opal_key(OPAL_AUTH_KEY,\n\t\t\t\t  opal_pw->new_user_pw.opal_key.key,\n\t\t\t\t  opal_pw->new_user_pw.opal_key.key_len);\n\n\treturn ret;\n}\n\nstatic int opal_activate_user(struct opal_dev *dev,\n\t\t\t      struct opal_session_info *opal_session)\n{\n\tconst struct opal_step act_steps[] = {\n\t\t{ start_admin1LSP_opal_session, &opal_session->opal_key },\n\t\t{ internal_activate_user, opal_session },\n\t\t{ end_opal_session, }\n\t};\n\tint ret;\n\n\t \n\tif (opal_session->who < OPAL_USER1 ||\n\t    opal_session->who > OPAL_USER9) {\n\t\tpr_debug(\"Who was not a valid user: %d\\n\", opal_session->who);\n\t\treturn -EINVAL;\n\t}\n\n\tret = opal_get_key(dev, &opal_session->opal_key);\n\tif (ret)\n\t\treturn ret;\n\tmutex_lock(&dev->dev_lock);\n\tsetup_opal_dev(dev);\n\tret = execute_steps(dev, act_steps, ARRAY_SIZE(act_steps));\n\tmutex_unlock(&dev->dev_lock);\n\n\treturn ret;\n}\n\nbool opal_unlock_from_suspend(struct opal_dev *dev)\n{\n\tstruct opal_suspend_data *suspend;\n\tbool was_failure = false;\n\tint ret = 0;\n\n\tif (!dev)\n\t\treturn false;\n\n\tif (!(dev->flags & OPAL_FL_SUPPORTED))\n\t\treturn false;\n\n\tmutex_lock(&dev->dev_lock);\n\tsetup_opal_dev(dev);\n\n\tlist_for_each_entry(suspend, &dev->unlk_lst, node) {\n\t\tdev->tsn = 0;\n\t\tdev->hsn = 0;\n\n\t\tret = __opal_lock_unlock(dev, &suspend->unlk);\n\t\tif (ret) {\n\t\t\tpr_debug(\"Failed to unlock LR %hhu with sum %d\\n\",\n\t\t\t\t suspend->unlk.session.opal_key.lr,\n\t\t\t\t suspend->unlk.session.sum);\n\t\t\twas_failure = true;\n\t\t}\n\n\t\tif (dev->flags & OPAL_FL_MBR_ENABLED) {\n\t\t\tret = __opal_set_mbr_done(dev, &suspend->unlk.session.opal_key);\n\t\t\tif (ret)\n\t\t\t\tpr_debug(\"Failed to set MBR Done in S3 resume\\n\");\n\t\t}\n\t}\n\tmutex_unlock(&dev->dev_lock);\n\n\treturn was_failure;\n}\nEXPORT_SYMBOL(opal_unlock_from_suspend);\n\nstatic int opal_read_table(struct opal_dev *dev,\n\t\t\t   struct opal_read_write_table *rw_tbl)\n{\n\tconst struct opal_step read_table_steps[] = {\n\t\t{ start_admin1LSP_opal_session, &rw_tbl->key },\n\t\t{ read_table_data, rw_tbl },\n\t\t{ end_opal_session, }\n\t};\n\tint ret = 0;\n\n\tif (!rw_tbl->size)\n\t\treturn ret;\n\n\treturn execute_steps(dev, read_table_steps,\n\t\t\t     ARRAY_SIZE(read_table_steps));\n}\n\nstatic int opal_write_table(struct opal_dev *dev,\n\t\t\t    struct opal_read_write_table *rw_tbl)\n{\n\tconst struct opal_step write_table_steps[] = {\n\t\t{ start_admin1LSP_opal_session, &rw_tbl->key },\n\t\t{ write_table_data, rw_tbl },\n\t\t{ end_opal_session, }\n\t};\n\tint ret = 0;\n\n\tif (!rw_tbl->size)\n\t\treturn ret;\n\n\treturn execute_steps(dev, write_table_steps,\n\t\t\t     ARRAY_SIZE(write_table_steps));\n}\n\nstatic int opal_generic_read_write_table(struct opal_dev *dev,\n\t\t\t\t\t struct opal_read_write_table *rw_tbl)\n{\n\tint ret, bit_set;\n\n\tret = opal_get_key(dev, &rw_tbl->key);\n\tif (ret)\n\t\treturn ret;\n\tmutex_lock(&dev->dev_lock);\n\tsetup_opal_dev(dev);\n\n\tbit_set = fls64(rw_tbl->flags) - 1;\n\tswitch (bit_set) {\n\tcase OPAL_READ_TABLE:\n\t\tret = opal_read_table(dev, rw_tbl);\n\t\tbreak;\n\tcase OPAL_WRITE_TABLE:\n\t\tret = opal_write_table(dev, rw_tbl);\n\t\tbreak;\n\tdefault:\n\t\tpr_debug(\"Invalid bit set in the flag (%016llx).\\n\",\n\t\t\t rw_tbl->flags);\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\tmutex_unlock(&dev->dev_lock);\n\n\treturn ret;\n}\n\nstatic int opal_get_status(struct opal_dev *dev, void __user *data)\n{\n\tstruct opal_status sts = {0};\n\n\t \n\tif (!check_opal_support(dev))\n\t\tsts.flags = dev->flags;\n\tif (copy_to_user(data, &sts, sizeof(sts))) {\n\t\tpr_debug(\"Error copying status to userspace\\n\");\n\t\treturn -EFAULT;\n\t}\n\treturn 0;\n}\n\nstatic int opal_get_geometry(struct opal_dev *dev, void __user *data)\n{\n\tstruct opal_geometry geo = {0};\n\n\tif (check_opal_support(dev))\n\t\treturn -EINVAL;\n\n\tgeo.align = dev->align_required;\n\tgeo.logical_block_size = dev->logical_block_size;\n\tgeo.alignment_granularity =  dev->align;\n\tgeo.lowest_aligned_lba = dev->lowest_lba;\n\n\tif (copy_to_user(data, &geo, sizeof(geo))) {\n\t\tpr_debug(\"Error copying geometry data to userspace\\n\");\n\t\treturn -EFAULT;\n\t}\n\n\treturn 0;\n}\n\nint sed_ioctl(struct opal_dev *dev, unsigned int cmd, void __user *arg)\n{\n\tvoid *p;\n\tint ret = -ENOTTY;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EACCES;\n\tif (!dev)\n\t\treturn -EOPNOTSUPP;\n\tif (!(dev->flags & OPAL_FL_SUPPORTED))\n\t\treturn -EOPNOTSUPP;\n\n\tif (cmd & IOC_IN) {\n\t\tp = memdup_user(arg, _IOC_SIZE(cmd));\n\t\tif (IS_ERR(p))\n\t\t\treturn PTR_ERR(p);\n\t}\n\n\tswitch (cmd) {\n\tcase IOC_OPAL_SAVE:\n\t\tret = opal_save(dev, p);\n\t\tbreak;\n\tcase IOC_OPAL_LOCK_UNLOCK:\n\t\tret = opal_lock_unlock(dev, p);\n\t\tbreak;\n\tcase IOC_OPAL_TAKE_OWNERSHIP:\n\t\tret = opal_take_ownership(dev, p);\n\t\tbreak;\n\tcase IOC_OPAL_ACTIVATE_LSP:\n\t\tret = opal_activate_lsp(dev, p);\n\t\tbreak;\n\tcase IOC_OPAL_SET_PW:\n\t\tret = opal_set_new_pw(dev, p);\n\t\tbreak;\n\tcase IOC_OPAL_ACTIVATE_USR:\n\t\tret = opal_activate_user(dev, p);\n\t\tbreak;\n\tcase IOC_OPAL_REVERT_TPR:\n\t\tret = opal_reverttper(dev, p, false);\n\t\tbreak;\n\tcase IOC_OPAL_LR_SETUP:\n\t\tret = opal_setup_locking_range(dev, p);\n\t\tbreak;\n\tcase IOC_OPAL_ADD_USR_TO_LR:\n\t\tret = opal_add_user_to_lr(dev, p);\n\t\tbreak;\n\tcase IOC_OPAL_ENABLE_DISABLE_MBR:\n\t\tret = opal_enable_disable_shadow_mbr(dev, p);\n\t\tbreak;\n\tcase IOC_OPAL_MBR_DONE:\n\t\tret = opal_set_mbr_done(dev, p);\n\t\tbreak;\n\tcase IOC_OPAL_WRITE_SHADOW_MBR:\n\t\tret = opal_write_shadow_mbr(dev, p);\n\t\tbreak;\n\tcase IOC_OPAL_ERASE_LR:\n\t\tret = opal_erase_locking_range(dev, p);\n\t\tbreak;\n\tcase IOC_OPAL_SECURE_ERASE_LR:\n\t\tret = opal_secure_erase_locking_range(dev, p);\n\t\tbreak;\n\tcase IOC_OPAL_PSID_REVERT_TPR:\n\t\tret = opal_reverttper(dev, p, true);\n\t\tbreak;\n\tcase IOC_OPAL_GENERIC_TABLE_RW:\n\t\tret = opal_generic_read_write_table(dev, p);\n\t\tbreak;\n\tcase IOC_OPAL_GET_STATUS:\n\t\tret = opal_get_status(dev, arg);\n\t\tbreak;\n\tcase IOC_OPAL_GET_LR_STATUS:\n\t\tret = opal_locking_range_status(dev, p, arg);\n\t\tbreak;\n\tcase IOC_OPAL_GET_GEOMETRY:\n\t\tret = opal_get_geometry(dev, arg);\n\t\tbreak;\n\tcase IOC_OPAL_REVERT_LSP:\n\t\tret = opal_revertlsp(dev, p);\n\t\tbreak;\n\tcase IOC_OPAL_DISCOVERY:\n\t\tret = opal_get_discv(dev, p);\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (cmd & IOC_IN)\n\t\tkfree(p);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(sed_ioctl);\n\nstatic int __init sed_opal_init(void)\n{\n\tstruct key *kr;\n\n\tkr = keyring_alloc(\".sed_opal\",\n\t\t\t   GLOBAL_ROOT_UID, GLOBAL_ROOT_GID, current_cred(),\n\t\t\t   (KEY_POS_ALL & ~KEY_POS_SETATTR) | KEY_USR_VIEW |\n\t\t\t   KEY_USR_READ | KEY_USR_SEARCH | KEY_USR_WRITE,\n\t\t\t   KEY_ALLOC_NOT_IN_QUOTA,\n\t\t\t   NULL, NULL);\n\tif (IS_ERR(kr))\n\t\treturn PTR_ERR(kr);\n\n\tsed_opal_keyring = kr;\n\n\treturn 0;\n}\nlate_initcall(sed_opal_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}