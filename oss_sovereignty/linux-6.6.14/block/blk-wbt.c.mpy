{
  "module_name": "blk-wbt.c",
  "hash_id": "240dda4c915e1e92c6f69071d02416f285af88af1099ffe88cf2caaec826bb04",
  "original_prompt": "Ingested from linux-6.6.14/block/blk-wbt.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n#include <linux/blk_types.h>\n#include <linux/slab.h>\n#include <linux/backing-dev.h>\n#include <linux/swap.h>\n\n#include \"blk-stat.h\"\n#include \"blk-wbt.h\"\n#include \"blk-rq-qos.h\"\n#include \"elevator.h\"\n\n#define CREATE_TRACE_POINTS\n#include <trace/events/wbt.h>\n\nenum wbt_flags {\n\tWBT_TRACKED\t\t= 1,\t \n\tWBT_READ\t\t= 2,\t \n\tWBT_KSWAPD\t\t= 4,\t \n\tWBT_DISCARD\t\t= 8,\t \n\n\tWBT_NR_BITS\t\t= 4,\t \n};\n\nenum {\n\tWBT_RWQ_BG\t\t= 0,\n\tWBT_RWQ_KSWAPD,\n\tWBT_RWQ_DISCARD,\n\tWBT_NUM_RWQ,\n};\n\n \nenum {\n\tWBT_STATE_ON_DEFAULT\t= 1,\t \n\tWBT_STATE_ON_MANUAL\t= 2,\t \n\tWBT_STATE_OFF_DEFAULT\t= 3,\t \n\tWBT_STATE_OFF_MANUAL\t= 4,\t \n};\n\nstruct rq_wb {\n\t \n\tunsigned int wb_background;\t\t \n\tunsigned int wb_normal;\t\t\t \n\n\tshort enable_state;\t\t\t \n\n\t \n\tunsigned int unknown_cnt;\n\n\tu64 win_nsec;\t\t\t\t \n\tu64 cur_win_nsec;\t\t\t \n\n\tstruct blk_stat_callback *cb;\n\n\tu64 sync_issue;\n\tvoid *sync_cookie;\n\n\tunsigned int wc;\n\n\tunsigned long last_issue;\t\t \n\tunsigned long last_comp;\t\t \n\tunsigned long min_lat_nsec;\n\tstruct rq_qos rqos;\n\tstruct rq_wait rq_wait[WBT_NUM_RWQ];\n\tstruct rq_depth rq_depth;\n};\n\nstatic inline struct rq_wb *RQWB(struct rq_qos *rqos)\n{\n\treturn container_of(rqos, struct rq_wb, rqos);\n}\n\nstatic inline void wbt_clear_state(struct request *rq)\n{\n\trq->wbt_flags = 0;\n}\n\nstatic inline enum wbt_flags wbt_flags(struct request *rq)\n{\n\treturn rq->wbt_flags;\n}\n\nstatic inline bool wbt_is_tracked(struct request *rq)\n{\n\treturn rq->wbt_flags & WBT_TRACKED;\n}\n\nstatic inline bool wbt_is_read(struct request *rq)\n{\n\treturn rq->wbt_flags & WBT_READ;\n}\n\nenum {\n\t \n\tRWB_DEF_DEPTH\t= 16,\n\n\t \n\tRWB_WINDOW_NSEC\t\t= 100 * 1000 * 1000ULL,\n\n\t \n\tRWB_MIN_WRITE_SAMPLES\t= 3,\n\n\t \n\tRWB_UNKNOWN_BUMP\t= 5,\n};\n\nstatic inline bool rwb_enabled(struct rq_wb *rwb)\n{\n\treturn rwb && rwb->enable_state != WBT_STATE_OFF_DEFAULT &&\n\t\t      rwb->enable_state != WBT_STATE_OFF_MANUAL;\n}\n\nstatic void wb_timestamp(struct rq_wb *rwb, unsigned long *var)\n{\n\tif (rwb_enabled(rwb)) {\n\t\tconst unsigned long cur = jiffies;\n\n\t\tif (cur != *var)\n\t\t\t*var = cur;\n\t}\n}\n\n \nstatic bool wb_recent_wait(struct rq_wb *rwb)\n{\n\tstruct bdi_writeback *wb = &rwb->rqos.disk->bdi->wb;\n\n\treturn time_before(jiffies, wb->dirty_sleep + HZ);\n}\n\nstatic inline struct rq_wait *get_rq_wait(struct rq_wb *rwb,\n\t\t\t\t\t  enum wbt_flags wb_acct)\n{\n\tif (wb_acct & WBT_KSWAPD)\n\t\treturn &rwb->rq_wait[WBT_RWQ_KSWAPD];\n\telse if (wb_acct & WBT_DISCARD)\n\t\treturn &rwb->rq_wait[WBT_RWQ_DISCARD];\n\n\treturn &rwb->rq_wait[WBT_RWQ_BG];\n}\n\nstatic void rwb_wake_all(struct rq_wb *rwb)\n{\n\tint i;\n\n\tfor (i = 0; i < WBT_NUM_RWQ; i++) {\n\t\tstruct rq_wait *rqw = &rwb->rq_wait[i];\n\n\t\tif (wq_has_sleeper(&rqw->wait))\n\t\t\twake_up_all(&rqw->wait);\n\t}\n}\n\nstatic void wbt_rqw_done(struct rq_wb *rwb, struct rq_wait *rqw,\n\t\t\t enum wbt_flags wb_acct)\n{\n\tint inflight, limit;\n\n\tinflight = atomic_dec_return(&rqw->inflight);\n\n\t \n\tif (wb_acct & WBT_DISCARD)\n\t\tlimit = rwb->wb_background;\n\telse if (rwb->wc && !wb_recent_wait(rwb))\n\t\tlimit = 0;\n\telse\n\t\tlimit = rwb->wb_normal;\n\n\t \n\tif (inflight && inflight >= limit)\n\t\treturn;\n\n\tif (wq_has_sleeper(&rqw->wait)) {\n\t\tint diff = limit - inflight;\n\n\t\tif (!inflight || diff >= rwb->wb_background / 2)\n\t\t\twake_up_all(&rqw->wait);\n\t}\n}\n\nstatic void __wbt_done(struct rq_qos *rqos, enum wbt_flags wb_acct)\n{\n\tstruct rq_wb *rwb = RQWB(rqos);\n\tstruct rq_wait *rqw;\n\n\tif (!(wb_acct & WBT_TRACKED))\n\t\treturn;\n\n\trqw = get_rq_wait(rwb, wb_acct);\n\twbt_rqw_done(rwb, rqw, wb_acct);\n}\n\n \nstatic void wbt_done(struct rq_qos *rqos, struct request *rq)\n{\n\tstruct rq_wb *rwb = RQWB(rqos);\n\n\tif (!wbt_is_tracked(rq)) {\n\t\tif (rwb->sync_cookie == rq) {\n\t\t\trwb->sync_issue = 0;\n\t\t\trwb->sync_cookie = NULL;\n\t\t}\n\n\t\tif (wbt_is_read(rq))\n\t\t\twb_timestamp(rwb, &rwb->last_comp);\n\t} else {\n\t\tWARN_ON_ONCE(rq == rwb->sync_cookie);\n\t\t__wbt_done(rqos, wbt_flags(rq));\n\t}\n\twbt_clear_state(rq);\n}\n\nstatic inline bool stat_sample_valid(struct blk_rq_stat *stat)\n{\n\t \n\treturn (stat[READ].nr_samples >= 1 &&\n\t\tstat[WRITE].nr_samples >= RWB_MIN_WRITE_SAMPLES);\n}\n\nstatic u64 rwb_sync_issue_lat(struct rq_wb *rwb)\n{\n\tu64 now, issue = READ_ONCE(rwb->sync_issue);\n\n\tif (!issue || !rwb->sync_cookie)\n\t\treturn 0;\n\n\tnow = ktime_to_ns(ktime_get());\n\treturn now - issue;\n}\n\nstatic inline unsigned int wbt_inflight(struct rq_wb *rwb)\n{\n\tunsigned int i, ret = 0;\n\n\tfor (i = 0; i < WBT_NUM_RWQ; i++)\n\t\tret += atomic_read(&rwb->rq_wait[i].inflight);\n\n\treturn ret;\n}\n\nenum {\n\tLAT_OK = 1,\n\tLAT_UNKNOWN,\n\tLAT_UNKNOWN_WRITES,\n\tLAT_EXCEEDED,\n};\n\nstatic int latency_exceeded(struct rq_wb *rwb, struct blk_rq_stat *stat)\n{\n\tstruct backing_dev_info *bdi = rwb->rqos.disk->bdi;\n\tstruct rq_depth *rqd = &rwb->rq_depth;\n\tu64 thislat;\n\n\t \n\tthislat = rwb_sync_issue_lat(rwb);\n\tif (thislat > rwb->cur_win_nsec ||\n\t    (thislat > rwb->min_lat_nsec && !stat[READ].nr_samples)) {\n\t\ttrace_wbt_lat(bdi, thislat);\n\t\treturn LAT_EXCEEDED;\n\t}\n\n\t \n\tif (!stat_sample_valid(stat)) {\n\t\t \n\t\tif (stat[WRITE].nr_samples || wb_recent_wait(rwb) ||\n\t\t    wbt_inflight(rwb))\n\t\t\treturn LAT_UNKNOWN_WRITES;\n\t\treturn LAT_UNKNOWN;\n\t}\n\n\t \n\tif (stat[READ].min > rwb->min_lat_nsec) {\n\t\ttrace_wbt_lat(bdi, stat[READ].min);\n\t\ttrace_wbt_stat(bdi, stat);\n\t\treturn LAT_EXCEEDED;\n\t}\n\n\tif (rqd->scale_step)\n\t\ttrace_wbt_stat(bdi, stat);\n\n\treturn LAT_OK;\n}\n\nstatic void rwb_trace_step(struct rq_wb *rwb, const char *msg)\n{\n\tstruct backing_dev_info *bdi = rwb->rqos.disk->bdi;\n\tstruct rq_depth *rqd = &rwb->rq_depth;\n\n\ttrace_wbt_step(bdi, msg, rqd->scale_step, rwb->cur_win_nsec,\n\t\t\trwb->wb_background, rwb->wb_normal, rqd->max_depth);\n}\n\nstatic void calc_wb_limits(struct rq_wb *rwb)\n{\n\tif (rwb->min_lat_nsec == 0) {\n\t\trwb->wb_normal = rwb->wb_background = 0;\n\t} else if (rwb->rq_depth.max_depth <= 2) {\n\t\trwb->wb_normal = rwb->rq_depth.max_depth;\n\t\trwb->wb_background = 1;\n\t} else {\n\t\trwb->wb_normal = (rwb->rq_depth.max_depth + 1) / 2;\n\t\trwb->wb_background = (rwb->rq_depth.max_depth + 3) / 4;\n\t}\n}\n\nstatic void scale_up(struct rq_wb *rwb)\n{\n\tif (!rq_depth_scale_up(&rwb->rq_depth))\n\t\treturn;\n\tcalc_wb_limits(rwb);\n\trwb->unknown_cnt = 0;\n\trwb_wake_all(rwb);\n\trwb_trace_step(rwb, tracepoint_string(\"scale up\"));\n}\n\nstatic void scale_down(struct rq_wb *rwb, bool hard_throttle)\n{\n\tif (!rq_depth_scale_down(&rwb->rq_depth, hard_throttle))\n\t\treturn;\n\tcalc_wb_limits(rwb);\n\trwb->unknown_cnt = 0;\n\trwb_trace_step(rwb, tracepoint_string(\"scale down\"));\n}\n\nstatic void rwb_arm_timer(struct rq_wb *rwb)\n{\n\tstruct rq_depth *rqd = &rwb->rq_depth;\n\n\tif (rqd->scale_step > 0) {\n\t\t \n\t\trwb->cur_win_nsec = div_u64(rwb->win_nsec << 4,\n\t\t\t\t\tint_sqrt((rqd->scale_step + 1) << 8));\n\t} else {\n\t\t \n\t\trwb->cur_win_nsec = rwb->win_nsec;\n\t}\n\n\tblk_stat_activate_nsecs(rwb->cb, rwb->cur_win_nsec);\n}\n\nstatic void wb_timer_fn(struct blk_stat_callback *cb)\n{\n\tstruct rq_wb *rwb = cb->data;\n\tstruct rq_depth *rqd = &rwb->rq_depth;\n\tunsigned int inflight = wbt_inflight(rwb);\n\tint status;\n\n\tif (!rwb->rqos.disk)\n\t\treturn;\n\n\tstatus = latency_exceeded(rwb, cb->stat);\n\n\ttrace_wbt_timer(rwb->rqos.disk->bdi, status, rqd->scale_step, inflight);\n\n\t \n\tswitch (status) {\n\tcase LAT_EXCEEDED:\n\t\tscale_down(rwb, true);\n\t\tbreak;\n\tcase LAT_OK:\n\t\tscale_up(rwb);\n\t\tbreak;\n\tcase LAT_UNKNOWN_WRITES:\n\t\t \n\t\tscale_up(rwb);\n\t\tbreak;\n\tcase LAT_UNKNOWN:\n\t\tif (++rwb->unknown_cnt < RWB_UNKNOWN_BUMP)\n\t\t\tbreak;\n\t\t \n\t\tif (rqd->scale_step > 0)\n\t\t\tscale_up(rwb);\n\t\telse if (rqd->scale_step < 0)\n\t\t\tscale_down(rwb, false);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t \n\tif (rqd->scale_step || inflight)\n\t\trwb_arm_timer(rwb);\n}\n\nstatic void wbt_update_limits(struct rq_wb *rwb)\n{\n\tstruct rq_depth *rqd = &rwb->rq_depth;\n\n\trqd->scale_step = 0;\n\trqd->scaled_max = false;\n\n\trq_depth_calc_max_depth(rqd);\n\tcalc_wb_limits(rwb);\n\n\trwb_wake_all(rwb);\n}\n\nbool wbt_disabled(struct request_queue *q)\n{\n\tstruct rq_qos *rqos = wbt_rq_qos(q);\n\n\treturn !rqos || !rwb_enabled(RQWB(rqos));\n}\n\nu64 wbt_get_min_lat(struct request_queue *q)\n{\n\tstruct rq_qos *rqos = wbt_rq_qos(q);\n\tif (!rqos)\n\t\treturn 0;\n\treturn RQWB(rqos)->min_lat_nsec;\n}\n\nvoid wbt_set_min_lat(struct request_queue *q, u64 val)\n{\n\tstruct rq_qos *rqos = wbt_rq_qos(q);\n\tif (!rqos)\n\t\treturn;\n\n\tRQWB(rqos)->min_lat_nsec = val;\n\tif (val)\n\t\tRQWB(rqos)->enable_state = WBT_STATE_ON_MANUAL;\n\telse\n\t\tRQWB(rqos)->enable_state = WBT_STATE_OFF_MANUAL;\n\n\twbt_update_limits(RQWB(rqos));\n}\n\n\nstatic bool close_io(struct rq_wb *rwb)\n{\n\tconst unsigned long now = jiffies;\n\n\treturn time_before(now, rwb->last_issue + HZ / 10) ||\n\t\ttime_before(now, rwb->last_comp + HZ / 10);\n}\n\n#define REQ_HIPRIO\t(REQ_SYNC | REQ_META | REQ_PRIO)\n\nstatic inline unsigned int get_limit(struct rq_wb *rwb, blk_opf_t opf)\n{\n\tunsigned int limit;\n\n\tif ((opf & REQ_OP_MASK) == REQ_OP_DISCARD)\n\t\treturn rwb->wb_background;\n\n\t \n\tif ((opf & REQ_HIPRIO) || wb_recent_wait(rwb) || current_is_kswapd())\n\t\tlimit = rwb->rq_depth.max_depth;\n\telse if ((opf & REQ_BACKGROUND) || close_io(rwb)) {\n\t\t \n\t\tlimit = rwb->wb_background;\n\t} else\n\t\tlimit = rwb->wb_normal;\n\n\treturn limit;\n}\n\nstruct wbt_wait_data {\n\tstruct rq_wb *rwb;\n\tenum wbt_flags wb_acct;\n\tblk_opf_t opf;\n};\n\nstatic bool wbt_inflight_cb(struct rq_wait *rqw, void *private_data)\n{\n\tstruct wbt_wait_data *data = private_data;\n\treturn rq_wait_inc_below(rqw, get_limit(data->rwb, data->opf));\n}\n\nstatic void wbt_cleanup_cb(struct rq_wait *rqw, void *private_data)\n{\n\tstruct wbt_wait_data *data = private_data;\n\twbt_rqw_done(data->rwb, rqw, data->wb_acct);\n}\n\n \nstatic void __wbt_wait(struct rq_wb *rwb, enum wbt_flags wb_acct,\n\t\t       blk_opf_t opf)\n{\n\tstruct rq_wait *rqw = get_rq_wait(rwb, wb_acct);\n\tstruct wbt_wait_data data = {\n\t\t.rwb = rwb,\n\t\t.wb_acct = wb_acct,\n\t\t.opf = opf,\n\t};\n\n\trq_qos_wait(rqw, &data, wbt_inflight_cb, wbt_cleanup_cb);\n}\n\nstatic inline bool wbt_should_throttle(struct bio *bio)\n{\n\tswitch (bio_op(bio)) {\n\tcase REQ_OP_WRITE:\n\t\t \n\t\tif ((bio->bi_opf & (REQ_SYNC | REQ_IDLE)) ==\n\t\t    (REQ_SYNC | REQ_IDLE))\n\t\t\treturn false;\n\t\tfallthrough;\n\tcase REQ_OP_DISCARD:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic enum wbt_flags bio_to_wbt_flags(struct rq_wb *rwb, struct bio *bio)\n{\n\tenum wbt_flags flags = 0;\n\n\tif (!rwb_enabled(rwb))\n\t\treturn 0;\n\n\tif (bio_op(bio) == REQ_OP_READ) {\n\t\tflags = WBT_READ;\n\t} else if (wbt_should_throttle(bio)) {\n\t\tif (current_is_kswapd())\n\t\t\tflags |= WBT_KSWAPD;\n\t\tif (bio_op(bio) == REQ_OP_DISCARD)\n\t\t\tflags |= WBT_DISCARD;\n\t\tflags |= WBT_TRACKED;\n\t}\n\treturn flags;\n}\n\nstatic void wbt_cleanup(struct rq_qos *rqos, struct bio *bio)\n{\n\tstruct rq_wb *rwb = RQWB(rqos);\n\tenum wbt_flags flags = bio_to_wbt_flags(rwb, bio);\n\t__wbt_done(rqos, flags);\n}\n\n \nstatic void wbt_wait(struct rq_qos *rqos, struct bio *bio)\n{\n\tstruct rq_wb *rwb = RQWB(rqos);\n\tenum wbt_flags flags;\n\n\tflags = bio_to_wbt_flags(rwb, bio);\n\tif (!(flags & WBT_TRACKED)) {\n\t\tif (flags & WBT_READ)\n\t\t\twb_timestamp(rwb, &rwb->last_issue);\n\t\treturn;\n\t}\n\n\t__wbt_wait(rwb, flags, bio->bi_opf);\n\n\tif (!blk_stat_is_active(rwb->cb))\n\t\trwb_arm_timer(rwb);\n}\n\nstatic void wbt_track(struct rq_qos *rqos, struct request *rq, struct bio *bio)\n{\n\tstruct rq_wb *rwb = RQWB(rqos);\n\trq->wbt_flags |= bio_to_wbt_flags(rwb, bio);\n}\n\nstatic void wbt_issue(struct rq_qos *rqos, struct request *rq)\n{\n\tstruct rq_wb *rwb = RQWB(rqos);\n\n\tif (!rwb_enabled(rwb))\n\t\treturn;\n\n\t \n\tif (wbt_is_read(rq) && !rwb->sync_issue) {\n\t\trwb->sync_cookie = rq;\n\t\trwb->sync_issue = rq->io_start_time_ns;\n\t}\n}\n\nstatic void wbt_requeue(struct rq_qos *rqos, struct request *rq)\n{\n\tstruct rq_wb *rwb = RQWB(rqos);\n\tif (!rwb_enabled(rwb))\n\t\treturn;\n\tif (rq == rwb->sync_cookie) {\n\t\trwb->sync_issue = 0;\n\t\trwb->sync_cookie = NULL;\n\t}\n}\n\nvoid wbt_set_write_cache(struct request_queue *q, bool write_cache_on)\n{\n\tstruct rq_qos *rqos = wbt_rq_qos(q);\n\tif (rqos)\n\t\tRQWB(rqos)->wc = write_cache_on;\n}\n\n \nvoid wbt_enable_default(struct gendisk *disk)\n{\n\tstruct request_queue *q = disk->queue;\n\tstruct rq_qos *rqos;\n\tbool enable = IS_ENABLED(CONFIG_BLK_WBT_MQ);\n\n\tif (q->elevator &&\n\t    test_bit(ELEVATOR_FLAG_DISABLE_WBT, &q->elevator->flags))\n\t\tenable = false;\n\n\t \n\trqos = wbt_rq_qos(q);\n\tif (rqos) {\n\t\tif (enable && RQWB(rqos)->enable_state == WBT_STATE_OFF_DEFAULT)\n\t\t\tRQWB(rqos)->enable_state = WBT_STATE_ON_DEFAULT;\n\t\treturn;\n\t}\n\n\t \n\tif (!blk_queue_registered(q))\n\t\treturn;\n\n\tif (queue_is_mq(q) && enable)\n\t\twbt_init(disk);\n}\nEXPORT_SYMBOL_GPL(wbt_enable_default);\n\nu64 wbt_default_latency_nsec(struct request_queue *q)\n{\n\t \n\tif (blk_queue_nonrot(q))\n\t\treturn 2000000ULL;\n\telse\n\t\treturn 75000000ULL;\n}\n\nstatic int wbt_data_dir(const struct request *rq)\n{\n\tconst enum req_op op = req_op(rq);\n\n\tif (op == REQ_OP_READ)\n\t\treturn READ;\n\telse if (op_is_write(op))\n\t\treturn WRITE;\n\n\t \n\treturn -1;\n}\n\nstatic void wbt_queue_depth_changed(struct rq_qos *rqos)\n{\n\tRQWB(rqos)->rq_depth.queue_depth = blk_queue_depth(rqos->disk->queue);\n\twbt_update_limits(RQWB(rqos));\n}\n\nstatic void wbt_exit(struct rq_qos *rqos)\n{\n\tstruct rq_wb *rwb = RQWB(rqos);\n\n\tblk_stat_remove_callback(rqos->disk->queue, rwb->cb);\n\tblk_stat_free_callback(rwb->cb);\n\tkfree(rwb);\n}\n\n \nvoid wbt_disable_default(struct gendisk *disk)\n{\n\tstruct rq_qos *rqos = wbt_rq_qos(disk->queue);\n\tstruct rq_wb *rwb;\n\tif (!rqos)\n\t\treturn;\n\trwb = RQWB(rqos);\n\tif (rwb->enable_state == WBT_STATE_ON_DEFAULT) {\n\t\tblk_stat_deactivate(rwb->cb);\n\t\trwb->enable_state = WBT_STATE_OFF_DEFAULT;\n\t}\n}\nEXPORT_SYMBOL_GPL(wbt_disable_default);\n\n#ifdef CONFIG_BLK_DEBUG_FS\nstatic int wbt_curr_win_nsec_show(void *data, struct seq_file *m)\n{\n\tstruct rq_qos *rqos = data;\n\tstruct rq_wb *rwb = RQWB(rqos);\n\n\tseq_printf(m, \"%llu\\n\", rwb->cur_win_nsec);\n\treturn 0;\n}\n\nstatic int wbt_enabled_show(void *data, struct seq_file *m)\n{\n\tstruct rq_qos *rqos = data;\n\tstruct rq_wb *rwb = RQWB(rqos);\n\n\tseq_printf(m, \"%d\\n\", rwb->enable_state);\n\treturn 0;\n}\n\nstatic int wbt_id_show(void *data, struct seq_file *m)\n{\n\tstruct rq_qos *rqos = data;\n\n\tseq_printf(m, \"%u\\n\", rqos->id);\n\treturn 0;\n}\n\nstatic int wbt_inflight_show(void *data, struct seq_file *m)\n{\n\tstruct rq_qos *rqos = data;\n\tstruct rq_wb *rwb = RQWB(rqos);\n\tint i;\n\n\tfor (i = 0; i < WBT_NUM_RWQ; i++)\n\t\tseq_printf(m, \"%d: inflight %d\\n\", i,\n\t\t\t   atomic_read(&rwb->rq_wait[i].inflight));\n\treturn 0;\n}\n\nstatic int wbt_min_lat_nsec_show(void *data, struct seq_file *m)\n{\n\tstruct rq_qos *rqos = data;\n\tstruct rq_wb *rwb = RQWB(rqos);\n\n\tseq_printf(m, \"%lu\\n\", rwb->min_lat_nsec);\n\treturn 0;\n}\n\nstatic int wbt_unknown_cnt_show(void *data, struct seq_file *m)\n{\n\tstruct rq_qos *rqos = data;\n\tstruct rq_wb *rwb = RQWB(rqos);\n\n\tseq_printf(m, \"%u\\n\", rwb->unknown_cnt);\n\treturn 0;\n}\n\nstatic int wbt_normal_show(void *data, struct seq_file *m)\n{\n\tstruct rq_qos *rqos = data;\n\tstruct rq_wb *rwb = RQWB(rqos);\n\n\tseq_printf(m, \"%u\\n\", rwb->wb_normal);\n\treturn 0;\n}\n\nstatic int wbt_background_show(void *data, struct seq_file *m)\n{\n\tstruct rq_qos *rqos = data;\n\tstruct rq_wb *rwb = RQWB(rqos);\n\n\tseq_printf(m, \"%u\\n\", rwb->wb_background);\n\treturn 0;\n}\n\nstatic const struct blk_mq_debugfs_attr wbt_debugfs_attrs[] = {\n\t{\"curr_win_nsec\", 0400, wbt_curr_win_nsec_show},\n\t{\"enabled\", 0400, wbt_enabled_show},\n\t{\"id\", 0400, wbt_id_show},\n\t{\"inflight\", 0400, wbt_inflight_show},\n\t{\"min_lat_nsec\", 0400, wbt_min_lat_nsec_show},\n\t{\"unknown_cnt\", 0400, wbt_unknown_cnt_show},\n\t{\"wb_normal\", 0400, wbt_normal_show},\n\t{\"wb_background\", 0400, wbt_background_show},\n\t{},\n};\n#endif\n\nstatic const struct rq_qos_ops wbt_rqos_ops = {\n\t.throttle = wbt_wait,\n\t.issue = wbt_issue,\n\t.track = wbt_track,\n\t.requeue = wbt_requeue,\n\t.done = wbt_done,\n\t.cleanup = wbt_cleanup,\n\t.queue_depth_changed = wbt_queue_depth_changed,\n\t.exit = wbt_exit,\n#ifdef CONFIG_BLK_DEBUG_FS\n\t.debugfs_attrs = wbt_debugfs_attrs,\n#endif\n};\n\nint wbt_init(struct gendisk *disk)\n{\n\tstruct request_queue *q = disk->queue;\n\tstruct rq_wb *rwb;\n\tint i;\n\tint ret;\n\n\trwb = kzalloc(sizeof(*rwb), GFP_KERNEL);\n\tif (!rwb)\n\t\treturn -ENOMEM;\n\n\trwb->cb = blk_stat_alloc_callback(wb_timer_fn, wbt_data_dir, 2, rwb);\n\tif (!rwb->cb) {\n\t\tkfree(rwb);\n\t\treturn -ENOMEM;\n\t}\n\n\tfor (i = 0; i < WBT_NUM_RWQ; i++)\n\t\trq_wait_init(&rwb->rq_wait[i]);\n\n\trwb->last_comp = rwb->last_issue = jiffies;\n\trwb->win_nsec = RWB_WINDOW_NSEC;\n\trwb->enable_state = WBT_STATE_ON_DEFAULT;\n\trwb->wc = test_bit(QUEUE_FLAG_WC, &q->queue_flags);\n\trwb->rq_depth.default_depth = RWB_DEF_DEPTH;\n\trwb->min_lat_nsec = wbt_default_latency_nsec(q);\n\trwb->rq_depth.queue_depth = blk_queue_depth(q);\n\twbt_update_limits(rwb);\n\n\t \n\tmutex_lock(&q->rq_qos_mutex);\n\tret = rq_qos_add(&rwb->rqos, disk, RQ_QOS_WBT, &wbt_rqos_ops);\n\tmutex_unlock(&q->rq_qos_mutex);\n\tif (ret)\n\t\tgoto err_free;\n\n\tblk_stat_add_callback(q, rwb->cb);\n\n\treturn 0;\n\nerr_free:\n\tblk_stat_free_callback(rwb->cb);\n\tkfree(rwb);\n\treturn ret;\n\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}