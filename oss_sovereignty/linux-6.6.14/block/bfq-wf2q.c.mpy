{
  "module_name": "bfq-wf2q.c",
  "hash_id": "b3eaac37651849c1b1e49d1d1eacebc608c8c58dd241a9cc9aaa7ffea93245be",
  "original_prompt": "Ingested from linux-6.6.14/block/bfq-wf2q.c",
  "human_readable_source": "\n \n#include \"bfq-iosched.h\"\n\n \nstatic int bfq_gt(u64 a, u64 b)\n{\n\treturn (s64)(a - b) > 0;\n}\n\nstatic struct bfq_entity *bfq_root_active_entity(struct rb_root *tree)\n{\n\tstruct rb_node *node = tree->rb_node;\n\n\treturn rb_entry(node, struct bfq_entity, rb_node);\n}\n\nstatic unsigned int bfq_class_idx(struct bfq_entity *entity)\n{\n\tstruct bfq_queue *bfqq = bfq_entity_to_bfqq(entity);\n\n\treturn bfqq ? bfqq->ioprio_class - 1 :\n\t\tBFQ_DEFAULT_GRP_CLASS - 1;\n}\n\nunsigned int bfq_tot_busy_queues(struct bfq_data *bfqd)\n{\n\treturn bfqd->busy_queues[0] + bfqd->busy_queues[1] +\n\t\tbfqd->busy_queues[2];\n}\n\nstatic struct bfq_entity *bfq_lookup_next_entity(struct bfq_sched_data *sd,\n\t\t\t\t\t\t bool expiration);\n\nstatic bool bfq_update_parent_budget(struct bfq_entity *next_in_service);\n\n \nstatic bool bfq_update_next_in_service(struct bfq_sched_data *sd,\n\t\t\t\t       struct bfq_entity *new_entity,\n\t\t\t\t       bool expiration)\n{\n\tstruct bfq_entity *next_in_service = sd->next_in_service;\n\tbool parent_sched_may_change = false;\n\tbool change_without_lookup = false;\n\n\t \n\tif (new_entity && new_entity != sd->next_in_service) {\n\t\t \n\t\tchange_without_lookup = true;\n\n\t\t \n\t\tif (next_in_service) {\n\t\t\tunsigned int new_entity_class_idx =\n\t\t\t\tbfq_class_idx(new_entity);\n\t\t\tstruct bfq_service_tree *st =\n\t\t\t\tsd->service_tree + new_entity_class_idx;\n\n\t\t\tchange_without_lookup =\n\t\t\t\t(new_entity_class_idx ==\n\t\t\t\t bfq_class_idx(next_in_service)\n\t\t\t\t &&\n\t\t\t\t !bfq_gt(new_entity->start, st->vtime)\n\t\t\t\t &&\n\t\t\t\t bfq_gt(next_in_service->finish,\n\t\t\t\t\tnew_entity->finish));\n\t\t}\n\n\t\tif (change_without_lookup)\n\t\t\tnext_in_service = new_entity;\n\t}\n\n\tif (!change_without_lookup)  \n\t\tnext_in_service = bfq_lookup_next_entity(sd, expiration);\n\n\tif (next_in_service) {\n\t\tbool new_budget_triggers_change =\n\t\t\tbfq_update_parent_budget(next_in_service);\n\n\t\tparent_sched_may_change = !sd->next_in_service ||\n\t\t\tnew_budget_triggers_change;\n\t}\n\n\tsd->next_in_service = next_in_service;\n\n\treturn parent_sched_may_change;\n}\n\n#ifdef CONFIG_BFQ_GROUP_IOSCHED\n\n \nstatic bool bfq_update_parent_budget(struct bfq_entity *next_in_service)\n{\n\tstruct bfq_entity *bfqg_entity;\n\tstruct bfq_group *bfqg;\n\tstruct bfq_sched_data *group_sd;\n\tbool ret = false;\n\n\tgroup_sd = next_in_service->sched_data;\n\n\tbfqg = container_of(group_sd, struct bfq_group, sched_data);\n\t \n\tbfqg_entity = bfqg->my_entity;\n\tif (bfqg_entity) {\n\t\tif (bfqg_entity->budget > next_in_service->budget)\n\t\t\tret = true;\n\t\tbfqg_entity->budget = next_in_service->budget;\n\t}\n\n\treturn ret;\n}\n\n \nstatic bool bfq_no_longer_next_in_service(struct bfq_entity *entity)\n{\n\tstruct bfq_group *bfqg;\n\n\tif (bfq_entity_to_bfqq(entity))\n\t\treturn true;\n\n\tbfqg = container_of(entity, struct bfq_group, entity);\n\n\t \n\tif (bfqg->active_entities == 1)\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic void bfq_inc_active_entities(struct bfq_entity *entity)\n{\n\tstruct bfq_sched_data *sd = entity->sched_data;\n\tstruct bfq_group *bfqg = container_of(sd, struct bfq_group, sched_data);\n\n\tif (bfqg != bfqg->bfqd->root_group)\n\t\tbfqg->active_entities++;\n}\n\nstatic void bfq_dec_active_entities(struct bfq_entity *entity)\n{\n\tstruct bfq_sched_data *sd = entity->sched_data;\n\tstruct bfq_group *bfqg = container_of(sd, struct bfq_group, sched_data);\n\n\tif (bfqg != bfqg->bfqd->root_group)\n\t\tbfqg->active_entities--;\n}\n\n#else  \n\nstatic bool bfq_update_parent_budget(struct bfq_entity *next_in_service)\n{\n\treturn false;\n}\n\nstatic bool bfq_no_longer_next_in_service(struct bfq_entity *entity)\n{\n\treturn true;\n}\n\nstatic void bfq_inc_active_entities(struct bfq_entity *entity)\n{\n}\n\nstatic void bfq_dec_active_entities(struct bfq_entity *entity)\n{\n}\n\n#endif  \n\n \n#define WFQ_SERVICE_SHIFT\t22\n\nstruct bfq_queue *bfq_entity_to_bfqq(struct bfq_entity *entity)\n{\n\tstruct bfq_queue *bfqq = NULL;\n\n\tif (!entity->my_sched_data)\n\t\tbfqq = container_of(entity, struct bfq_queue, entity);\n\n\treturn bfqq;\n}\n\n\n \nstatic u64 bfq_delta(unsigned long service, unsigned long weight)\n{\n\treturn div64_ul((u64)service << WFQ_SERVICE_SHIFT, weight);\n}\n\n \nstatic void bfq_calc_finish(struct bfq_entity *entity, unsigned long service)\n{\n\tstruct bfq_queue *bfqq = bfq_entity_to_bfqq(entity);\n\n\tentity->finish = entity->start +\n\t\tbfq_delta(service, entity->weight);\n\n\tif (bfqq) {\n\t\tbfq_log_bfqq(bfqq->bfqd, bfqq,\n\t\t\t\"calc_finish: serv %lu, w %d\",\n\t\t\tservice, entity->weight);\n\t\tbfq_log_bfqq(bfqq->bfqd, bfqq,\n\t\t\t\"calc_finish: start %llu, finish %llu, delta %llu\",\n\t\t\tentity->start, entity->finish,\n\t\t\tbfq_delta(service, entity->weight));\n\t}\n}\n\n \nstruct bfq_entity *bfq_entity_of(struct rb_node *node)\n{\n\tstruct bfq_entity *entity = NULL;\n\n\tif (node)\n\t\tentity = rb_entry(node, struct bfq_entity, rb_node);\n\n\treturn entity;\n}\n\n \nstatic void bfq_extract(struct rb_root *root, struct bfq_entity *entity)\n{\n\tentity->tree = NULL;\n\trb_erase(&entity->rb_node, root);\n}\n\n \nstatic void bfq_idle_extract(struct bfq_service_tree *st,\n\t\t\t     struct bfq_entity *entity)\n{\n\tstruct bfq_queue *bfqq = bfq_entity_to_bfqq(entity);\n\tstruct rb_node *next;\n\n\tif (entity == st->first_idle) {\n\t\tnext = rb_next(&entity->rb_node);\n\t\tst->first_idle = bfq_entity_of(next);\n\t}\n\n\tif (entity == st->last_idle) {\n\t\tnext = rb_prev(&entity->rb_node);\n\t\tst->last_idle = bfq_entity_of(next);\n\t}\n\n\tbfq_extract(&st->idle, entity);\n\n\tif (bfqq)\n\t\tlist_del(&bfqq->bfqq_list);\n}\n\n \nstatic void bfq_insert(struct rb_root *root, struct bfq_entity *entity)\n{\n\tstruct bfq_entity *entry;\n\tstruct rb_node **node = &root->rb_node;\n\tstruct rb_node *parent = NULL;\n\n\twhile (*node) {\n\t\tparent = *node;\n\t\tentry = rb_entry(parent, struct bfq_entity, rb_node);\n\n\t\tif (bfq_gt(entry->finish, entity->finish))\n\t\t\tnode = &parent->rb_left;\n\t\telse\n\t\t\tnode = &parent->rb_right;\n\t}\n\n\trb_link_node(&entity->rb_node, parent, node);\n\trb_insert_color(&entity->rb_node, root);\n\n\tentity->tree = root;\n}\n\n \nstatic void bfq_update_min(struct bfq_entity *entity, struct rb_node *node)\n{\n\tstruct bfq_entity *child;\n\n\tif (node) {\n\t\tchild = rb_entry(node, struct bfq_entity, rb_node);\n\t\tif (bfq_gt(entity->min_start, child->min_start))\n\t\t\tentity->min_start = child->min_start;\n\t}\n}\n\n \nstatic void bfq_update_active_node(struct rb_node *node)\n{\n\tstruct bfq_entity *entity = rb_entry(node, struct bfq_entity, rb_node);\n\n\tentity->min_start = entity->start;\n\tbfq_update_min(entity, node->rb_right);\n\tbfq_update_min(entity, node->rb_left);\n}\n\n \nstatic void bfq_update_active_tree(struct rb_node *node)\n{\n\tstruct rb_node *parent;\n\nup:\n\tbfq_update_active_node(node);\n\n\tparent = rb_parent(node);\n\tif (!parent)\n\t\treturn;\n\n\tif (node == parent->rb_left && parent->rb_right)\n\t\tbfq_update_active_node(parent->rb_right);\n\telse if (parent->rb_left)\n\t\tbfq_update_active_node(parent->rb_left);\n\n\tnode = parent;\n\tgoto up;\n}\n\n \nstatic void bfq_active_insert(struct bfq_service_tree *st,\n\t\t\t      struct bfq_entity *entity)\n{\n\tstruct bfq_queue *bfqq = bfq_entity_to_bfqq(entity);\n\tstruct rb_node *node = &entity->rb_node;\n\n\tbfq_insert(&st->active, entity);\n\n\tif (node->rb_left)\n\t\tnode = node->rb_left;\n\telse if (node->rb_right)\n\t\tnode = node->rb_right;\n\n\tbfq_update_active_tree(node);\n\n\tif (bfqq)\n\t\tlist_add(&bfqq->bfqq_list, &bfqq->bfqd->active_list[bfqq->actuator_idx]);\n\n\tbfq_inc_active_entities(entity);\n}\n\n \nunsigned short bfq_ioprio_to_weight(int ioprio)\n{\n\treturn (IOPRIO_NR_LEVELS - ioprio) * BFQ_WEIGHT_CONVERSION_COEFF;\n}\n\n \nstatic unsigned short bfq_weight_to_ioprio(int weight)\n{\n\treturn max_t(int, 0,\n\t\t     IOPRIO_NR_LEVELS - weight / BFQ_WEIGHT_CONVERSION_COEFF);\n}\n\nstatic void bfq_get_entity(struct bfq_entity *entity)\n{\n\tstruct bfq_queue *bfqq = bfq_entity_to_bfqq(entity);\n\n\tif (bfqq) {\n\t\tbfqq->ref++;\n\t\tbfq_log_bfqq(bfqq->bfqd, bfqq, \"get_entity: %p %d\",\n\t\t\t     bfqq, bfqq->ref);\n\t}\n}\n\n \nstatic struct rb_node *bfq_find_deepest(struct rb_node *node)\n{\n\tstruct rb_node *deepest;\n\n\tif (!node->rb_right && !node->rb_left)\n\t\tdeepest = rb_parent(node);\n\telse if (!node->rb_right)\n\t\tdeepest = node->rb_left;\n\telse if (!node->rb_left)\n\t\tdeepest = node->rb_right;\n\telse {\n\t\tdeepest = rb_next(node);\n\t\tif (deepest->rb_right)\n\t\t\tdeepest = deepest->rb_right;\n\t\telse if (rb_parent(deepest) != node)\n\t\t\tdeepest = rb_parent(deepest);\n\t}\n\n\treturn deepest;\n}\n\n \nstatic void bfq_active_extract(struct bfq_service_tree *st,\n\t\t\t       struct bfq_entity *entity)\n{\n\tstruct bfq_queue *bfqq = bfq_entity_to_bfqq(entity);\n\tstruct rb_node *node;\n\n\tnode = bfq_find_deepest(&entity->rb_node);\n\tbfq_extract(&st->active, entity);\n\n\tif (node)\n\t\tbfq_update_active_tree(node);\n\tif (bfqq)\n\t\tlist_del(&bfqq->bfqq_list);\n\n\tbfq_dec_active_entities(entity);\n}\n\n \nstatic void bfq_idle_insert(struct bfq_service_tree *st,\n\t\t\t    struct bfq_entity *entity)\n{\n\tstruct bfq_queue *bfqq = bfq_entity_to_bfqq(entity);\n\tstruct bfq_entity *first_idle = st->first_idle;\n\tstruct bfq_entity *last_idle = st->last_idle;\n\n\tif (!first_idle || bfq_gt(first_idle->finish, entity->finish))\n\t\tst->first_idle = entity;\n\tif (!last_idle || bfq_gt(entity->finish, last_idle->finish))\n\t\tst->last_idle = entity;\n\n\tbfq_insert(&st->idle, entity);\n\n\tif (bfqq)\n\t\tlist_add(&bfqq->bfqq_list, &bfqq->bfqd->idle_list);\n}\n\n \nstatic void bfq_forget_entity(struct bfq_service_tree *st,\n\t\t\t      struct bfq_entity *entity,\n\t\t\t      bool is_in_service)\n{\n\tstruct bfq_queue *bfqq = bfq_entity_to_bfqq(entity);\n\n\tentity->on_st_or_in_serv = false;\n\tst->wsum -= entity->weight;\n\tif (bfqq && !is_in_service)\n\t\tbfq_put_queue(bfqq);\n}\n\n \nvoid bfq_put_idle_entity(struct bfq_service_tree *st, struct bfq_entity *entity)\n{\n\tbfq_idle_extract(st, entity);\n\tbfq_forget_entity(st, entity,\n\t\t\t  entity == entity->sched_data->in_service_entity);\n}\n\n \nstatic void bfq_forget_idle(struct bfq_service_tree *st)\n{\n\tstruct bfq_entity *first_idle = st->first_idle;\n\tstruct bfq_entity *last_idle = st->last_idle;\n\n\tif (RB_EMPTY_ROOT(&st->active) && last_idle &&\n\t    !bfq_gt(last_idle->finish, st->vtime)) {\n\t\t \n\t\tst->vtime = last_idle->finish;\n\t}\n\n\tif (first_idle && !bfq_gt(first_idle->finish, st->vtime))\n\t\tbfq_put_idle_entity(st, first_idle);\n}\n\nstruct bfq_service_tree *bfq_entity_service_tree(struct bfq_entity *entity)\n{\n\tstruct bfq_sched_data *sched_data = entity->sched_data;\n\tunsigned int idx = bfq_class_idx(entity);\n\n\treturn sched_data->service_tree + idx;\n}\n\n \nstruct bfq_service_tree *\n__bfq_entity_update_weight_prio(struct bfq_service_tree *old_st,\n\t\t\t\tstruct bfq_entity *entity,\n\t\t\t\tbool update_class_too)\n{\n\tstruct bfq_service_tree *new_st = old_st;\n\n\tif (entity->prio_changed) {\n\t\tstruct bfq_queue *bfqq = bfq_entity_to_bfqq(entity);\n\t\tunsigned int prev_weight, new_weight;\n\n\t\t \n\t\tsmp_rmb();\n\t\told_st->wsum -= entity->weight;\n\n\t\tif (entity->new_weight != entity->orig_weight) {\n\t\t\tif (entity->new_weight < BFQ_MIN_WEIGHT ||\n\t\t\t    entity->new_weight > BFQ_MAX_WEIGHT) {\n\t\t\t\tpr_crit(\"update_weight_prio: new_weight %d\\n\",\n\t\t\t\t\tentity->new_weight);\n\t\t\t\tif (entity->new_weight < BFQ_MIN_WEIGHT)\n\t\t\t\t\tentity->new_weight = BFQ_MIN_WEIGHT;\n\t\t\t\telse\n\t\t\t\t\tentity->new_weight = BFQ_MAX_WEIGHT;\n\t\t\t}\n\t\t\tentity->orig_weight = entity->new_weight;\n\t\t\tif (bfqq)\n\t\t\t\tbfqq->ioprio =\n\t\t\t\t  bfq_weight_to_ioprio(entity->orig_weight);\n\t\t}\n\n\t\tif (bfqq && update_class_too)\n\t\t\tbfqq->ioprio_class = bfqq->new_ioprio_class;\n\n\t\t \n\t\tif (!bfqq || bfqq->ioprio_class == bfqq->new_ioprio_class)\n\t\t\tentity->prio_changed = 0;\n\n\t\t \n\t\tnew_st = bfq_entity_service_tree(entity);\n\n\t\tprev_weight = entity->weight;\n\t\tnew_weight = entity->orig_weight *\n\t\t\t     (bfqq ? bfqq->wr_coeff : 1);\n\t\t \n\t\tif (prev_weight != new_weight && bfqq)\n\t\t\tbfq_weights_tree_remove(bfqq);\n\t\tentity->weight = new_weight;\n\t\t \n\t\tif (prev_weight != new_weight && bfqq && bfqq->wr_coeff == 1)\n\t\t\tbfq_weights_tree_add(bfqq);\n\n\t\tnew_st->wsum += entity->weight;\n\n\t\tif (new_st != old_st)\n\t\t\tentity->start = new_st->vtime;\n\t}\n\n\treturn new_st;\n}\n\n \nvoid bfq_bfqq_served(struct bfq_queue *bfqq, int served)\n{\n\tstruct bfq_entity *entity = &bfqq->entity;\n\tstruct bfq_service_tree *st;\n\n\tif (!bfqq->service_from_backlogged)\n\t\tbfqq->first_IO_time = jiffies;\n\n\tif (bfqq->wr_coeff > 1)\n\t\tbfqq->service_from_wr += served;\n\n\tbfqq->service_from_backlogged += served;\n\tfor_each_entity(entity) {\n\t\tst = bfq_entity_service_tree(entity);\n\n\t\tentity->service += served;\n\n\t\tst->vtime += bfq_delta(served, st->wsum);\n\t\tbfq_forget_idle(st);\n\t}\n\tbfq_log_bfqq(bfqq->bfqd, bfqq, \"bfqq_served %d secs\", served);\n}\n\n \nvoid bfq_bfqq_charge_time(struct bfq_data *bfqd, struct bfq_queue *bfqq,\n\t\t\t  unsigned long time_ms)\n{\n\tstruct bfq_entity *entity = &bfqq->entity;\n\tunsigned long timeout_ms = jiffies_to_msecs(bfq_timeout);\n\tunsigned long bounded_time_ms = min(time_ms, timeout_ms);\n\tint serv_to_charge_for_time =\n\t\t(bfqd->bfq_max_budget * bounded_time_ms) / timeout_ms;\n\tint tot_serv_to_charge = max(serv_to_charge_for_time, entity->service);\n\n\t \n\tif (tot_serv_to_charge > entity->budget)\n\t\tentity->budget = tot_serv_to_charge;\n\n\tbfq_bfqq_served(bfqq,\n\t\t\tmax_t(int, 0, tot_serv_to_charge - entity->service));\n}\n\nstatic void bfq_update_fin_time_enqueue(struct bfq_entity *entity,\n\t\t\t\t\tstruct bfq_service_tree *st,\n\t\t\t\t\tbool backshifted)\n{\n\tstruct bfq_queue *bfqq = bfq_entity_to_bfqq(entity);\n\n\t \n\tst = __bfq_entity_update_weight_prio(st, entity, true);\n\tbfq_calc_finish(entity, entity->budget);\n\n\t \n\tif (backshifted && bfq_gt(st->vtime, entity->finish)) {\n\t\tunsigned long delta = st->vtime - entity->finish;\n\n\t\tif (bfqq)\n\t\t\tdelta /= bfqq->wr_coeff;\n\n\t\tentity->start += delta;\n\t\tentity->finish += delta;\n\t}\n\n\tbfq_active_insert(st, entity);\n}\n\n \nstatic void __bfq_activate_entity(struct bfq_entity *entity,\n\t\t\t\t  bool non_blocking_wait_rq)\n{\n\tstruct bfq_service_tree *st = bfq_entity_service_tree(entity);\n\tbool backshifted = false;\n\tunsigned long long min_vstart;\n\n\t \n\tif (non_blocking_wait_rq && bfq_gt(st->vtime, entity->finish)) {\n\t\tbackshifted = true;\n\t\tmin_vstart = entity->finish;\n\t} else\n\t\tmin_vstart = st->vtime;\n\n\tif (entity->tree == &st->idle) {\n\t\t \n\t\tbfq_idle_extract(st, entity);\n\t\tentity->start = bfq_gt(min_vstart, entity->finish) ?\n\t\t\tmin_vstart : entity->finish;\n\t} else {\n\t\t \n\t\tentity->start = min_vstart;\n\t\tst->wsum += entity->weight;\n\t\t \n\t\tbfq_get_entity(entity);\n\n\t\tentity->on_st_or_in_serv = true;\n\t}\n\n\tbfq_update_fin_time_enqueue(entity, st, backshifted);\n}\n\n \nstatic void __bfq_requeue_entity(struct bfq_entity *entity)\n{\n\tstruct bfq_sched_data *sd = entity->sched_data;\n\tstruct bfq_service_tree *st = bfq_entity_service_tree(entity);\n\n\tif (entity == sd->in_service_entity) {\n\t\t \n\t\tbfq_calc_finish(entity, entity->service);\n\t\tentity->start = entity->finish;\n\t\t \n\t\tif (entity->tree)\n\t\t\tbfq_active_extract(st, entity);\n\t} else {  \n\t\t \n\t\tbfq_active_extract(st, entity);\n\t}\n\n\tbfq_update_fin_time_enqueue(entity, st, false);\n}\n\nstatic void __bfq_activate_requeue_entity(struct bfq_entity *entity,\n\t\t\t\t\t  bool non_blocking_wait_rq)\n{\n\tstruct bfq_service_tree *st = bfq_entity_service_tree(entity);\n\n\tif (entity->sched_data->in_service_entity == entity ||\n\t    entity->tree == &st->active)\n\t\t  \n\t\t__bfq_requeue_entity(entity);\n\telse\n\t\t \n\t\t__bfq_activate_entity(entity, non_blocking_wait_rq);\n}\n\n\n \nstatic void bfq_activate_requeue_entity(struct bfq_entity *entity,\n\t\t\t\t\tbool non_blocking_wait_rq,\n\t\t\t\t\tbool requeue, bool expiration)\n{\n\tfor_each_entity(entity) {\n\t\t__bfq_activate_requeue_entity(entity, non_blocking_wait_rq);\n\t\tif (!bfq_update_next_in_service(entity->sched_data, entity,\n\t\t\t\t\t\texpiration) && !requeue)\n\t\t\tbreak;\n\t}\n}\n\n \nbool __bfq_deactivate_entity(struct bfq_entity *entity, bool ins_into_idle_tree)\n{\n\tstruct bfq_sched_data *sd = entity->sched_data;\n\tstruct bfq_service_tree *st;\n\tbool is_in_service;\n\n\tif (!entity->on_st_or_in_serv)  \n\t\treturn false;\n\n\t \n\tst = bfq_entity_service_tree(entity);\n\tis_in_service = entity == sd->in_service_entity;\n\n\tbfq_calc_finish(entity, entity->service);\n\n\tif (is_in_service)\n\t\tsd->in_service_entity = NULL;\n\telse\n\t\t \n\t\tentity->service = 0;\n\n\tif (entity->tree == &st->active)\n\t\tbfq_active_extract(st, entity);\n\telse if (!is_in_service && entity->tree == &st->idle)\n\t\tbfq_idle_extract(st, entity);\n\n\tif (!ins_into_idle_tree || !bfq_gt(entity->finish, st->vtime))\n\t\tbfq_forget_entity(st, entity, is_in_service);\n\telse\n\t\tbfq_idle_insert(st, entity);\n\n\treturn true;\n}\n\n \nstatic void bfq_deactivate_entity(struct bfq_entity *entity,\n\t\t\t\t  bool ins_into_idle_tree,\n\t\t\t\t  bool expiration)\n{\n\tstruct bfq_sched_data *sd;\n\tstruct bfq_entity *parent = NULL;\n\n\tfor_each_entity_safe(entity, parent) {\n\t\tsd = entity->sched_data;\n\n\t\tif (!__bfq_deactivate_entity(entity, ins_into_idle_tree)) {\n\t\t\t \n\t\t\treturn;\n\t\t}\n\n\t\tif (sd->next_in_service == entity)\n\t\t\t \n\t\t\tbfq_update_next_in_service(sd, NULL, expiration);\n\n\t\tif (sd->next_in_service || sd->in_service_entity) {\n\t\t\t \n\t\t\tbreak;\n\t\t}\n\n\t\t \n\n\t\t \n\t\tins_into_idle_tree = true;\n\t}\n\n\t \n\tentity = parent;\n\tfor_each_entity(entity) {\n\t\t \n\t\t__bfq_requeue_entity(entity);\n\n\t\tsd = entity->sched_data;\n\t\tif (!bfq_update_next_in_service(sd, entity, expiration) &&\n\t\t    !expiration)\n\t\t\t \n\t\t\tbreak;\n\t}\n}\n\n \nstatic u64 bfq_calc_vtime_jump(struct bfq_service_tree *st)\n{\n\tstruct bfq_entity *root_entity = bfq_root_active_entity(&st->active);\n\n\tif (bfq_gt(root_entity->min_start, st->vtime))\n\t\treturn root_entity->min_start;\n\n\treturn st->vtime;\n}\n\nstatic void bfq_update_vtime(struct bfq_service_tree *st, u64 new_value)\n{\n\tif (new_value > st->vtime) {\n\t\tst->vtime = new_value;\n\t\tbfq_forget_idle(st);\n\t}\n}\n\n \nstatic struct bfq_entity *bfq_first_active_entity(struct bfq_service_tree *st,\n\t\t\t\t\t\t  u64 vtime)\n{\n\tstruct bfq_entity *entry, *first = NULL;\n\tstruct rb_node *node = st->active.rb_node;\n\n\twhile (node) {\n\t\tentry = rb_entry(node, struct bfq_entity, rb_node);\nleft:\n\t\tif (!bfq_gt(entry->start, vtime))\n\t\t\tfirst = entry;\n\n\t\tif (node->rb_left) {\n\t\t\tentry = rb_entry(node->rb_left,\n\t\t\t\t\t struct bfq_entity, rb_node);\n\t\t\tif (!bfq_gt(entry->min_start, vtime)) {\n\t\t\t\tnode = node->rb_left;\n\t\t\t\tgoto left;\n\t\t\t}\n\t\t}\n\t\tif (first)\n\t\t\tbreak;\n\t\tnode = node->rb_right;\n\t}\n\n\treturn first;\n}\n\n \nstatic struct bfq_entity *\n__bfq_lookup_next_entity(struct bfq_service_tree *st, bool in_service)\n{\n\tstruct bfq_entity *entity;\n\tu64 new_vtime;\n\n\tif (RB_EMPTY_ROOT(&st->active))\n\t\treturn NULL;\n\n\t \n\tnew_vtime = bfq_calc_vtime_jump(st);\n\n\t \n\tif (!in_service)\n\t\tbfq_update_vtime(st, new_vtime);\n\n\tentity = bfq_first_active_entity(st, new_vtime);\n\n\treturn entity;\n}\n\n \nstatic struct bfq_entity *bfq_lookup_next_entity(struct bfq_sched_data *sd,\n\t\t\t\t\t\t bool expiration)\n{\n\tstruct bfq_service_tree *st = sd->service_tree;\n\tstruct bfq_service_tree *idle_class_st = st + (BFQ_IOPRIO_CLASSES - 1);\n\tstruct bfq_entity *entity = NULL;\n\tint class_idx = 0;\n\n\t \n\tif (time_is_before_jiffies(sd->bfq_class_idle_last_service +\n\t\t\t\t   BFQ_CL_IDLE_TIMEOUT)) {\n\t\tif (!RB_EMPTY_ROOT(&idle_class_st->active))\n\t\t\tclass_idx = BFQ_IOPRIO_CLASSES - 1;\n\t\t \n\t\tsd->bfq_class_idle_last_service = jiffies;\n\t}\n\n\t \n\tfor (; class_idx < BFQ_IOPRIO_CLASSES; class_idx++) {\n\t\t \n\t\tentity = __bfq_lookup_next_entity(st + class_idx,\n\t\t\t\t\t\t  sd->in_service_entity &&\n\t\t\t\t\t\t  !expiration);\n\n\t\tif (entity)\n\t\t\tbreak;\n\t}\n\n\treturn entity;\n}\n\nbool next_queue_may_preempt(struct bfq_data *bfqd)\n{\n\tstruct bfq_sched_data *sd = &bfqd->root_group->sched_data;\n\n\treturn sd->next_in_service != sd->in_service_entity;\n}\n\n \nstruct bfq_queue *bfq_get_next_queue(struct bfq_data *bfqd)\n{\n\tstruct bfq_entity *entity = NULL;\n\tstruct bfq_sched_data *sd;\n\tstruct bfq_queue *bfqq;\n\n\tif (bfq_tot_busy_queues(bfqd) == 0)\n\t\treturn NULL;\n\n\t \n\tsd = &bfqd->root_group->sched_data;\n\tfor (; sd ; sd = entity->my_sched_data) {\n\t\t \n\n\t\t \n\t\tentity = sd->next_in_service;\n\t\tsd->in_service_entity = entity;\n\n\t\t \n\t\tif (bfq_no_longer_next_in_service(entity))\n\t\t\tbfq_active_extract(bfq_entity_service_tree(entity),\n\t\t\t\t\t   entity);\n\n\t\t \n\t}\n\n\tbfqq = bfq_entity_to_bfqq(entity);\n\n\t \n\tfor_each_entity(entity) {\n\t\tstruct bfq_sched_data *sd = entity->sched_data;\n\n\t\tif (!bfq_update_next_in_service(sd, NULL, false))\n\t\t\tbreak;\n\t}\n\n\treturn bfqq;\n}\n\n \nbool __bfq_bfqd_reset_in_service(struct bfq_data *bfqd)\n{\n\tstruct bfq_queue *in_serv_bfqq = bfqd->in_service_queue;\n\tstruct bfq_entity *in_serv_entity = &in_serv_bfqq->entity;\n\tstruct bfq_entity *entity = in_serv_entity;\n\n\tbfq_clear_bfqq_wait_request(in_serv_bfqq);\n\thrtimer_try_to_cancel(&bfqd->idle_slice_timer);\n\tbfqd->in_service_queue = NULL;\n\n\t \n\tfor_each_entity(entity)\n\t\tentity->sched_data->in_service_entity = NULL;\n\n\t \n\tif (!in_serv_entity->on_st_or_in_serv) {\n\t\t \n\t\tint ref = in_serv_bfqq->ref;\n\t\tbfq_put_queue(in_serv_bfqq);\n\t\tif (ref == 1)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nvoid bfq_deactivate_bfqq(struct bfq_data *bfqd, struct bfq_queue *bfqq,\n\t\t\t bool ins_into_idle_tree, bool expiration)\n{\n\tstruct bfq_entity *entity = &bfqq->entity;\n\n\tbfq_deactivate_entity(entity, ins_into_idle_tree, expiration);\n}\n\nvoid bfq_activate_bfqq(struct bfq_data *bfqd, struct bfq_queue *bfqq)\n{\n\tstruct bfq_entity *entity = &bfqq->entity;\n\n\tbfq_activate_requeue_entity(entity, bfq_bfqq_non_blocking_wait_rq(bfqq),\n\t\t\t\t    false, false);\n\tbfq_clear_bfqq_non_blocking_wait_rq(bfqq);\n}\n\nvoid bfq_requeue_bfqq(struct bfq_data *bfqd, struct bfq_queue *bfqq,\n\t\t      bool expiration)\n{\n\tstruct bfq_entity *entity = &bfqq->entity;\n\n\tbfq_activate_requeue_entity(entity, false,\n\t\t\t\t    bfqq == bfqd->in_service_queue, expiration);\n}\n\nvoid bfq_add_bfqq_in_groups_with_pending_reqs(struct bfq_queue *bfqq)\n{\n#ifdef CONFIG_BFQ_GROUP_IOSCHED\n\tstruct bfq_entity *entity = &bfqq->entity;\n\n\tif (!entity->in_groups_with_pending_reqs) {\n\t\tentity->in_groups_with_pending_reqs = true;\n\t\tif (!(bfqq_group(bfqq)->num_queues_with_pending_reqs++))\n\t\t\tbfqq->bfqd->num_groups_with_pending_reqs++;\n\t}\n#endif\n}\n\nvoid bfq_del_bfqq_in_groups_with_pending_reqs(struct bfq_queue *bfqq)\n{\n#ifdef CONFIG_BFQ_GROUP_IOSCHED\n\tstruct bfq_entity *entity = &bfqq->entity;\n\n\tif (entity->in_groups_with_pending_reqs) {\n\t\tentity->in_groups_with_pending_reqs = false;\n\t\tif (!(--bfqq_group(bfqq)->num_queues_with_pending_reqs))\n\t\t\tbfqq->bfqd->num_groups_with_pending_reqs--;\n\t}\n#endif\n}\n\n \nvoid bfq_del_bfqq_busy(struct bfq_queue *bfqq, bool expiration)\n{\n\tstruct bfq_data *bfqd = bfqq->bfqd;\n\n\tbfq_log_bfqq(bfqd, bfqq, \"del from busy\");\n\n\tbfq_clear_bfqq_busy(bfqq);\n\n\tbfqd->busy_queues[bfqq->ioprio_class - 1]--;\n\n\tif (bfqq->wr_coeff > 1)\n\t\tbfqd->wr_busy_queues--;\n\n\tbfqg_stats_update_dequeue(bfqq_group(bfqq));\n\n\tbfq_deactivate_bfqq(bfqd, bfqq, true, expiration);\n\n\tif (!bfqq->dispatched) {\n\t\tbfq_del_bfqq_in_groups_with_pending_reqs(bfqq);\n\t\t \n\t\tbfq_weights_tree_remove(bfqq);\n\t}\n}\n\n \nvoid bfq_add_bfqq_busy(struct bfq_queue *bfqq)\n{\n\tstruct bfq_data *bfqd = bfqq->bfqd;\n\n\tbfq_log_bfqq(bfqd, bfqq, \"add to busy\");\n\n\tbfq_activate_bfqq(bfqd, bfqq);\n\n\tbfq_mark_bfqq_busy(bfqq);\n\tbfqd->busy_queues[bfqq->ioprio_class - 1]++;\n\n\tif (!bfqq->dispatched) {\n\t\tbfq_add_bfqq_in_groups_with_pending_reqs(bfqq);\n\t\tif (bfqq->wr_coeff == 1)\n\t\t\tbfq_weights_tree_add(bfqq);\n\t}\n\n\tif (bfqq->wr_coeff > 1)\n\t\tbfqd->wr_busy_queues++;\n\n\t \n\tif (!hlist_unhashed(&bfqq->woken_list_node) &&\n\t    &bfqq->woken_list_node != bfqq->waker_bfqq->woken_list.first) {\n\t\thlist_del_init(&bfqq->woken_list_node);\n\t\thlist_add_head(&bfqq->woken_list_node,\n\t\t\t       &bfqq->waker_bfqq->woken_list);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}