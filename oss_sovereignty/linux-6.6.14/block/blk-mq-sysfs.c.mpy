{
  "module_name": "blk-mq-sysfs.c",
  "hash_id": "dfc85f76122875e64aa43470bab1aa448cf21f8d1a16fa3a218bba925b2f6226",
  "original_prompt": "Ingested from linux-6.6.14/block/blk-mq-sysfs.c",
  "human_readable_source": "\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/bio.h>\n#include <linux/blkdev.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/smp.h>\n\n#include \"blk.h\"\n#include \"blk-mq.h\"\n\nstatic void blk_mq_sysfs_release(struct kobject *kobj)\n{\n\tstruct blk_mq_ctxs *ctxs = container_of(kobj, struct blk_mq_ctxs, kobj);\n\n\tfree_percpu(ctxs->queue_ctx);\n\tkfree(ctxs);\n}\n\nstatic void blk_mq_ctx_sysfs_release(struct kobject *kobj)\n{\n\tstruct blk_mq_ctx *ctx = container_of(kobj, struct blk_mq_ctx, kobj);\n\n\t \n\tkobject_put(&ctx->ctxs->kobj);\n}\n\nstatic void blk_mq_hw_sysfs_release(struct kobject *kobj)\n{\n\tstruct blk_mq_hw_ctx *hctx = container_of(kobj, struct blk_mq_hw_ctx,\n\t\t\t\t\t\t  kobj);\n\n\tblk_free_flush_queue(hctx->fq);\n\tsbitmap_free(&hctx->ctx_map);\n\tfree_cpumask_var(hctx->cpumask);\n\tkfree(hctx->ctxs);\n\tkfree(hctx);\n}\n\nstruct blk_mq_hw_ctx_sysfs_entry {\n\tstruct attribute attr;\n\tssize_t (*show)(struct blk_mq_hw_ctx *, char *);\n};\n\nstatic ssize_t blk_mq_hw_sysfs_show(struct kobject *kobj,\n\t\t\t\t    struct attribute *attr, char *page)\n{\n\tstruct blk_mq_hw_ctx_sysfs_entry *entry;\n\tstruct blk_mq_hw_ctx *hctx;\n\tstruct request_queue *q;\n\tssize_t res;\n\n\tentry = container_of(attr, struct blk_mq_hw_ctx_sysfs_entry, attr);\n\thctx = container_of(kobj, struct blk_mq_hw_ctx, kobj);\n\tq = hctx->queue;\n\n\tif (!entry->show)\n\t\treturn -EIO;\n\n\tmutex_lock(&q->sysfs_lock);\n\tres = entry->show(hctx, page);\n\tmutex_unlock(&q->sysfs_lock);\n\treturn res;\n}\n\nstatic ssize_t blk_mq_hw_sysfs_nr_tags_show(struct blk_mq_hw_ctx *hctx,\n\t\t\t\t\t    char *page)\n{\n\treturn sprintf(page, \"%u\\n\", hctx->tags->nr_tags);\n}\n\nstatic ssize_t blk_mq_hw_sysfs_nr_reserved_tags_show(struct blk_mq_hw_ctx *hctx,\n\t\t\t\t\t\t     char *page)\n{\n\treturn sprintf(page, \"%u\\n\", hctx->tags->nr_reserved_tags);\n}\n\nstatic ssize_t blk_mq_hw_sysfs_cpus_show(struct blk_mq_hw_ctx *hctx, char *page)\n{\n\tconst size_t size = PAGE_SIZE - 1;\n\tunsigned int i, first = 1;\n\tint ret = 0, pos = 0;\n\n\tfor_each_cpu(i, hctx->cpumask) {\n\t\tif (first)\n\t\t\tret = snprintf(pos + page, size - pos, \"%u\", i);\n\t\telse\n\t\t\tret = snprintf(pos + page, size - pos, \", %u\", i);\n\n\t\tif (ret >= size - pos)\n\t\t\tbreak;\n\n\t\tfirst = 0;\n\t\tpos += ret;\n\t}\n\n\tret = snprintf(pos + page, size + 1 - pos, \"\\n\");\n\treturn pos + ret;\n}\n\nstatic struct blk_mq_hw_ctx_sysfs_entry blk_mq_hw_sysfs_nr_tags = {\n\t.attr = {.name = \"nr_tags\", .mode = 0444 },\n\t.show = blk_mq_hw_sysfs_nr_tags_show,\n};\nstatic struct blk_mq_hw_ctx_sysfs_entry blk_mq_hw_sysfs_nr_reserved_tags = {\n\t.attr = {.name = \"nr_reserved_tags\", .mode = 0444 },\n\t.show = blk_mq_hw_sysfs_nr_reserved_tags_show,\n};\nstatic struct blk_mq_hw_ctx_sysfs_entry blk_mq_hw_sysfs_cpus = {\n\t.attr = {.name = \"cpu_list\", .mode = 0444 },\n\t.show = blk_mq_hw_sysfs_cpus_show,\n};\n\nstatic struct attribute *default_hw_ctx_attrs[] = {\n\t&blk_mq_hw_sysfs_nr_tags.attr,\n\t&blk_mq_hw_sysfs_nr_reserved_tags.attr,\n\t&blk_mq_hw_sysfs_cpus.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(default_hw_ctx);\n\nstatic const struct sysfs_ops blk_mq_hw_sysfs_ops = {\n\t.show\t= blk_mq_hw_sysfs_show,\n};\n\nstatic const struct kobj_type blk_mq_ktype = {\n\t.release\t= blk_mq_sysfs_release,\n};\n\nstatic const struct kobj_type blk_mq_ctx_ktype = {\n\t.release\t= blk_mq_ctx_sysfs_release,\n};\n\nstatic const struct kobj_type blk_mq_hw_ktype = {\n\t.sysfs_ops\t= &blk_mq_hw_sysfs_ops,\n\t.default_groups = default_hw_ctx_groups,\n\t.release\t= blk_mq_hw_sysfs_release,\n};\n\nstatic void blk_mq_unregister_hctx(struct blk_mq_hw_ctx *hctx)\n{\n\tstruct blk_mq_ctx *ctx;\n\tint i;\n\n\tif (!hctx->nr_ctx)\n\t\treturn;\n\n\thctx_for_each_ctx(hctx, ctx, i)\n\t\tkobject_del(&ctx->kobj);\n\n\tkobject_del(&hctx->kobj);\n}\n\nstatic int blk_mq_register_hctx(struct blk_mq_hw_ctx *hctx)\n{\n\tstruct request_queue *q = hctx->queue;\n\tstruct blk_mq_ctx *ctx;\n\tint i, j, ret;\n\n\tif (!hctx->nr_ctx)\n\t\treturn 0;\n\n\tret = kobject_add(&hctx->kobj, q->mq_kobj, \"%u\", hctx->queue_num);\n\tif (ret)\n\t\treturn ret;\n\n\thctx_for_each_ctx(hctx, ctx, i) {\n\t\tret = kobject_add(&ctx->kobj, &hctx->kobj, \"cpu%u\", ctx->cpu);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\treturn 0;\nout:\n\thctx_for_each_ctx(hctx, ctx, j) {\n\t\tif (j < i)\n\t\t\tkobject_del(&ctx->kobj);\n\t}\n\tkobject_del(&hctx->kobj);\n\treturn ret;\n}\n\nvoid blk_mq_hctx_kobj_init(struct blk_mq_hw_ctx *hctx)\n{\n\tkobject_init(&hctx->kobj, &blk_mq_hw_ktype);\n}\n\nvoid blk_mq_sysfs_deinit(struct request_queue *q)\n{\n\tstruct blk_mq_ctx *ctx;\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tctx = per_cpu_ptr(q->queue_ctx, cpu);\n\t\tkobject_put(&ctx->kobj);\n\t}\n\tkobject_put(q->mq_kobj);\n}\n\nvoid blk_mq_sysfs_init(struct request_queue *q)\n{\n\tstruct blk_mq_ctx *ctx;\n\tint cpu;\n\n\tkobject_init(q->mq_kobj, &blk_mq_ktype);\n\n\tfor_each_possible_cpu(cpu) {\n\t\tctx = per_cpu_ptr(q->queue_ctx, cpu);\n\n\t\tkobject_get(q->mq_kobj);\n\t\tkobject_init(&ctx->kobj, &blk_mq_ctx_ktype);\n\t}\n}\n\nint blk_mq_sysfs_register(struct gendisk *disk)\n{\n\tstruct request_queue *q = disk->queue;\n\tstruct blk_mq_hw_ctx *hctx;\n\tunsigned long i, j;\n\tint ret;\n\n\tlockdep_assert_held(&q->sysfs_dir_lock);\n\n\tret = kobject_add(q->mq_kobj, &disk_to_dev(disk)->kobj, \"mq\");\n\tif (ret < 0)\n\t\tgoto out;\n\n\tkobject_uevent(q->mq_kobj, KOBJ_ADD);\n\n\tqueue_for_each_hw_ctx(q, hctx, i) {\n\t\tret = blk_mq_register_hctx(hctx);\n\t\tif (ret)\n\t\t\tgoto unreg;\n\t}\n\n\tq->mq_sysfs_init_done = true;\n\nout:\n\treturn ret;\n\nunreg:\n\tqueue_for_each_hw_ctx(q, hctx, j) {\n\t\tif (j < i)\n\t\t\tblk_mq_unregister_hctx(hctx);\n\t}\n\n\tkobject_uevent(q->mq_kobj, KOBJ_REMOVE);\n\tkobject_del(q->mq_kobj);\n\treturn ret;\n}\n\nvoid blk_mq_sysfs_unregister(struct gendisk *disk)\n{\n\tstruct request_queue *q = disk->queue;\n\tstruct blk_mq_hw_ctx *hctx;\n\tunsigned long i;\n\n\tlockdep_assert_held(&q->sysfs_dir_lock);\n\n\tqueue_for_each_hw_ctx(q, hctx, i)\n\t\tblk_mq_unregister_hctx(hctx);\n\n\tkobject_uevent(q->mq_kobj, KOBJ_REMOVE);\n\tkobject_del(q->mq_kobj);\n\n\tq->mq_sysfs_init_done = false;\n}\n\nvoid blk_mq_sysfs_unregister_hctxs(struct request_queue *q)\n{\n\tstruct blk_mq_hw_ctx *hctx;\n\tunsigned long i;\n\n\tmutex_lock(&q->sysfs_dir_lock);\n\tif (!q->mq_sysfs_init_done)\n\t\tgoto unlock;\n\n\tqueue_for_each_hw_ctx(q, hctx, i)\n\t\tblk_mq_unregister_hctx(hctx);\n\nunlock:\n\tmutex_unlock(&q->sysfs_dir_lock);\n}\n\nint blk_mq_sysfs_register_hctxs(struct request_queue *q)\n{\n\tstruct blk_mq_hw_ctx *hctx;\n\tunsigned long i;\n\tint ret = 0;\n\n\tmutex_lock(&q->sysfs_dir_lock);\n\tif (!q->mq_sysfs_init_done)\n\t\tgoto unlock;\n\n\tqueue_for_each_hw_ctx(q, hctx, i) {\n\t\tret = blk_mq_register_hctx(hctx);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\nunlock:\n\tmutex_unlock(&q->sysfs_dir_lock);\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}