{
  "module_name": "blk-lib.c",
  "hash_id": "ed87f86b7e4eb7602cb8768dc96c19688a95534d44d3123c44cb40c46cf1ae85",
  "original_prompt": "Ingested from linux-6.6.14/block/blk-lib.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/bio.h>\n#include <linux/blkdev.h>\n#include <linux/scatterlist.h>\n\n#include \"blk.h\"\n\nstatic sector_t bio_discard_limit(struct block_device *bdev, sector_t sector)\n{\n\tunsigned int discard_granularity = bdev_discard_granularity(bdev);\n\tsector_t granularity_aligned_sector;\n\n\tif (bdev_is_partition(bdev))\n\t\tsector += bdev->bd_start_sect;\n\n\tgranularity_aligned_sector =\n\t\tround_up(sector, discard_granularity >> SECTOR_SHIFT);\n\n\t \n\tif (granularity_aligned_sector != sector)\n\t\treturn granularity_aligned_sector - sector;\n\n\t \n\treturn round_down(UINT_MAX, discard_granularity) >> SECTOR_SHIFT;\n}\n\nint __blkdev_issue_discard(struct block_device *bdev, sector_t sector,\n\t\tsector_t nr_sects, gfp_t gfp_mask, struct bio **biop)\n{\n\tstruct bio *bio = *biop;\n\tsector_t bs_mask;\n\n\tif (bdev_read_only(bdev))\n\t\treturn -EPERM;\n\tif (!bdev_max_discard_sectors(bdev))\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tif (WARN_ON_ONCE(!bdev_discard_granularity(bdev))) {\n\t\tpr_err_ratelimited(\"%pg: Error: discard_granularity is 0.\\n\",\n\t\t\t\t   bdev);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tbs_mask = (bdev_logical_block_size(bdev) >> 9) - 1;\n\tif ((sector | nr_sects) & bs_mask)\n\t\treturn -EINVAL;\n\n\tif (!nr_sects)\n\t\treturn -EINVAL;\n\n\twhile (nr_sects) {\n\t\tsector_t req_sects =\n\t\t\tmin(nr_sects, bio_discard_limit(bdev, sector));\n\n\t\tbio = blk_next_bio(bio, bdev, 0, REQ_OP_DISCARD, gfp_mask);\n\t\tbio->bi_iter.bi_sector = sector;\n\t\tbio->bi_iter.bi_size = req_sects << 9;\n\t\tsector += req_sects;\n\t\tnr_sects -= req_sects;\n\n\t\t \n\t\tcond_resched();\n\t}\n\n\t*biop = bio;\n\treturn 0;\n}\nEXPORT_SYMBOL(__blkdev_issue_discard);\n\n \nint blkdev_issue_discard(struct block_device *bdev, sector_t sector,\n\t\tsector_t nr_sects, gfp_t gfp_mask)\n{\n\tstruct bio *bio = NULL;\n\tstruct blk_plug plug;\n\tint ret;\n\n\tblk_start_plug(&plug);\n\tret = __blkdev_issue_discard(bdev, sector, nr_sects, gfp_mask, &bio);\n\tif (!ret && bio) {\n\t\tret = submit_bio_wait(bio);\n\t\tif (ret == -EOPNOTSUPP)\n\t\t\tret = 0;\n\t\tbio_put(bio);\n\t}\n\tblk_finish_plug(&plug);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(blkdev_issue_discard);\n\nstatic int __blkdev_issue_write_zeroes(struct block_device *bdev,\n\t\tsector_t sector, sector_t nr_sects, gfp_t gfp_mask,\n\t\tstruct bio **biop, unsigned flags)\n{\n\tstruct bio *bio = *biop;\n\tunsigned int max_write_zeroes_sectors;\n\n\tif (bdev_read_only(bdev))\n\t\treturn -EPERM;\n\n\t \n\tmax_write_zeroes_sectors = bdev_write_zeroes_sectors(bdev);\n\n\tif (max_write_zeroes_sectors == 0)\n\t\treturn -EOPNOTSUPP;\n\n\twhile (nr_sects) {\n\t\tbio = blk_next_bio(bio, bdev, 0, REQ_OP_WRITE_ZEROES, gfp_mask);\n\t\tbio->bi_iter.bi_sector = sector;\n\t\tif (flags & BLKDEV_ZERO_NOUNMAP)\n\t\t\tbio->bi_opf |= REQ_NOUNMAP;\n\n\t\tif (nr_sects > max_write_zeroes_sectors) {\n\t\t\tbio->bi_iter.bi_size = max_write_zeroes_sectors << 9;\n\t\t\tnr_sects -= max_write_zeroes_sectors;\n\t\t\tsector += max_write_zeroes_sectors;\n\t\t} else {\n\t\t\tbio->bi_iter.bi_size = nr_sects << 9;\n\t\t\tnr_sects = 0;\n\t\t}\n\t\tcond_resched();\n\t}\n\n\t*biop = bio;\n\treturn 0;\n}\n\n \nstatic unsigned int __blkdev_sectors_to_bio_pages(sector_t nr_sects)\n{\n\tsector_t pages = DIV_ROUND_UP_SECTOR_T(nr_sects, PAGE_SIZE / 512);\n\n\treturn min(pages, (sector_t)BIO_MAX_VECS);\n}\n\nstatic int __blkdev_issue_zero_pages(struct block_device *bdev,\n\t\tsector_t sector, sector_t nr_sects, gfp_t gfp_mask,\n\t\tstruct bio **biop)\n{\n\tstruct bio *bio = *biop;\n\tint bi_size = 0;\n\tunsigned int sz;\n\n\tif (bdev_read_only(bdev))\n\t\treturn -EPERM;\n\n\twhile (nr_sects != 0) {\n\t\tbio = blk_next_bio(bio, bdev, __blkdev_sectors_to_bio_pages(nr_sects),\n\t\t\t\t   REQ_OP_WRITE, gfp_mask);\n\t\tbio->bi_iter.bi_sector = sector;\n\n\t\twhile (nr_sects != 0) {\n\t\t\tsz = min((sector_t) PAGE_SIZE, nr_sects << 9);\n\t\t\tbi_size = bio_add_page(bio, ZERO_PAGE(0), sz, 0);\n\t\t\tnr_sects -= bi_size >> 9;\n\t\t\tsector += bi_size >> 9;\n\t\t\tif (bi_size < sz)\n\t\t\t\tbreak;\n\t\t}\n\t\tcond_resched();\n\t}\n\n\t*biop = bio;\n\treturn 0;\n}\n\n \nint __blkdev_issue_zeroout(struct block_device *bdev, sector_t sector,\n\t\tsector_t nr_sects, gfp_t gfp_mask, struct bio **biop,\n\t\tunsigned flags)\n{\n\tint ret;\n\tsector_t bs_mask;\n\n\tbs_mask = (bdev_logical_block_size(bdev) >> 9) - 1;\n\tif ((sector | nr_sects) & bs_mask)\n\t\treturn -EINVAL;\n\n\tret = __blkdev_issue_write_zeroes(bdev, sector, nr_sects, gfp_mask,\n\t\t\tbiop, flags);\n\tif (ret != -EOPNOTSUPP || (flags & BLKDEV_ZERO_NOFALLBACK))\n\t\treturn ret;\n\n\treturn __blkdev_issue_zero_pages(bdev, sector, nr_sects, gfp_mask,\n\t\t\t\t\t biop);\n}\nEXPORT_SYMBOL(__blkdev_issue_zeroout);\n\n \nint blkdev_issue_zeroout(struct block_device *bdev, sector_t sector,\n\t\tsector_t nr_sects, gfp_t gfp_mask, unsigned flags)\n{\n\tint ret = 0;\n\tsector_t bs_mask;\n\tstruct bio *bio;\n\tstruct blk_plug plug;\n\tbool try_write_zeroes = !!bdev_write_zeroes_sectors(bdev);\n\n\tbs_mask = (bdev_logical_block_size(bdev) >> 9) - 1;\n\tif ((sector | nr_sects) & bs_mask)\n\t\treturn -EINVAL;\n\nretry:\n\tbio = NULL;\n\tblk_start_plug(&plug);\n\tif (try_write_zeroes) {\n\t\tret = __blkdev_issue_write_zeroes(bdev, sector, nr_sects,\n\t\t\t\t\t\t  gfp_mask, &bio, flags);\n\t} else if (!(flags & BLKDEV_ZERO_NOFALLBACK)) {\n\t\tret = __blkdev_issue_zero_pages(bdev, sector, nr_sects,\n\t\t\t\t\t\tgfp_mask, &bio);\n\t} else {\n\t\t \n\t\tret = -EOPNOTSUPP;\n\t}\n\tif (ret == 0 && bio) {\n\t\tret = submit_bio_wait(bio);\n\t\tbio_put(bio);\n\t}\n\tblk_finish_plug(&plug);\n\tif (ret && try_write_zeroes) {\n\t\tif (!(flags & BLKDEV_ZERO_NOFALLBACK)) {\n\t\t\ttry_write_zeroes = false;\n\t\t\tgoto retry;\n\t\t}\n\t\tif (!bdev_write_zeroes_sectors(bdev)) {\n\t\t\t \n\t\t\tret = -EOPNOTSUPP;\n\t\t}\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL(blkdev_issue_zeroout);\n\nint blkdev_issue_secure_erase(struct block_device *bdev, sector_t sector,\n\t\tsector_t nr_sects, gfp_t gfp)\n{\n\tsector_t bs_mask = (bdev_logical_block_size(bdev) >> 9) - 1;\n\tunsigned int max_sectors = bdev_max_secure_erase_sectors(bdev);\n\tstruct bio *bio = NULL;\n\tstruct blk_plug plug;\n\tint ret = 0;\n\n\t \n\tif (max_sectors > UINT_MAX >> SECTOR_SHIFT)\n\t\tmax_sectors = UINT_MAX >> SECTOR_SHIFT;\n\tmax_sectors &= ~bs_mask;\n\n\tif (max_sectors == 0)\n\t\treturn -EOPNOTSUPP;\n\tif ((sector | nr_sects) & bs_mask)\n\t\treturn -EINVAL;\n\tif (bdev_read_only(bdev))\n\t\treturn -EPERM;\n\n\tblk_start_plug(&plug);\n\tfor (;;) {\n\t\tunsigned int len = min_t(sector_t, nr_sects, max_sectors);\n\n\t\tbio = blk_next_bio(bio, bdev, 0, REQ_OP_SECURE_ERASE, gfp);\n\t\tbio->bi_iter.bi_sector = sector;\n\t\tbio->bi_iter.bi_size = len << SECTOR_SHIFT;\n\n\t\tsector += len;\n\t\tnr_sects -= len;\n\t\tif (!nr_sects) {\n\t\t\tret = submit_bio_wait(bio);\n\t\t\tbio_put(bio);\n\t\t\tbreak;\n\t\t}\n\t\tcond_resched();\n\t}\n\tblk_finish_plug(&plug);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(blkdev_issue_secure_erase);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}