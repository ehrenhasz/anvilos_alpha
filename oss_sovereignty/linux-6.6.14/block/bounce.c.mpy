{
  "module_name": "bounce.c",
  "hash_id": "e0d6184042a70950479fdc7e1484515bfca3ff0459d3280337e1dce802940f0e",
  "original_prompt": "Ingested from linux-6.6.14/block/bounce.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/swap.h>\n#include <linux/gfp.h>\n#include <linux/bio.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/highmem.h>\n#include <linux/printk.h>\n#include <asm/tlbflush.h>\n\n#include <trace/events/block.h>\n#include \"blk.h\"\n#include \"blk-cgroup.h\"\n\n#define POOL_SIZE\t64\n#define ISA_POOL_SIZE\t16\n\nstatic struct bio_set bounce_bio_set, bounce_bio_split;\nstatic mempool_t page_pool;\n\nstatic void init_bounce_bioset(void)\n{\n\tstatic bool bounce_bs_setup;\n\tint ret;\n\n\tif (bounce_bs_setup)\n\t\treturn;\n\n\tret = bioset_init(&bounce_bio_set, BIO_POOL_SIZE, 0, BIOSET_NEED_BVECS);\n\tBUG_ON(ret);\n\tif (bioset_integrity_create(&bounce_bio_set, BIO_POOL_SIZE))\n\t\tBUG_ON(1);\n\n\tret = bioset_init(&bounce_bio_split, BIO_POOL_SIZE, 0, 0);\n\tBUG_ON(ret);\n\tbounce_bs_setup = true;\n}\n\nstatic __init int init_emergency_pool(void)\n{\n\tint ret;\n\n#ifndef CONFIG_MEMORY_HOTPLUG\n\tif (max_pfn <= max_low_pfn)\n\t\treturn 0;\n#endif\n\n\tret = mempool_init_page_pool(&page_pool, POOL_SIZE, 0);\n\tBUG_ON(ret);\n\tpr_info(\"pool size: %d pages\\n\", POOL_SIZE);\n\n\tinit_bounce_bioset();\n\treturn 0;\n}\n\n__initcall(init_emergency_pool);\n\n \nstatic void copy_to_high_bio_irq(struct bio *to, struct bio *from)\n{\n\tstruct bio_vec tovec, fromvec;\n\tstruct bvec_iter iter;\n\t \n\tstruct bvec_iter from_iter = BVEC_ITER_ALL_INIT;\n\n\tbio_for_each_segment(tovec, to, iter) {\n\t\tfromvec = bio_iter_iovec(from, from_iter);\n\t\tif (tovec.bv_page != fromvec.bv_page) {\n\t\t\t \n\t\t\tmemcpy_to_bvec(&tovec, page_address(fromvec.bv_page) +\n\t\t\t\t       tovec.bv_offset);\n\t\t}\n\t\tbio_advance_iter(from, &from_iter, tovec.bv_len);\n\t}\n}\n\nstatic void bounce_end_io(struct bio *bio)\n{\n\tstruct bio *bio_orig = bio->bi_private;\n\tstruct bio_vec *bvec, orig_vec;\n\tstruct bvec_iter orig_iter = bio_orig->bi_iter;\n\tstruct bvec_iter_all iter_all;\n\n\t \n\tbio_for_each_segment_all(bvec, bio, iter_all) {\n\t\torig_vec = bio_iter_iovec(bio_orig, orig_iter);\n\t\tif (bvec->bv_page != orig_vec.bv_page) {\n\t\t\tdec_zone_page_state(bvec->bv_page, NR_BOUNCE);\n\t\t\tmempool_free(bvec->bv_page, &page_pool);\n\t\t}\n\t\tbio_advance_iter(bio_orig, &orig_iter, orig_vec.bv_len);\n\t}\n\n\tbio_orig->bi_status = bio->bi_status;\n\tbio_endio(bio_orig);\n\tbio_put(bio);\n}\n\nstatic void bounce_end_io_write(struct bio *bio)\n{\n\tbounce_end_io(bio);\n}\n\nstatic void bounce_end_io_read(struct bio *bio)\n{\n\tstruct bio *bio_orig = bio->bi_private;\n\n\tif (!bio->bi_status)\n\t\tcopy_to_high_bio_irq(bio_orig, bio);\n\n\tbounce_end_io(bio);\n}\n\nstatic struct bio *bounce_clone_bio(struct bio *bio_src)\n{\n\tstruct bvec_iter iter;\n\tstruct bio_vec bv;\n\tstruct bio *bio;\n\n\t \n\tbio = bio_alloc_bioset(bio_src->bi_bdev, bio_segments(bio_src),\n\t\t\t       bio_src->bi_opf, GFP_NOIO, &bounce_bio_set);\n\tif (bio_flagged(bio_src, BIO_REMAPPED))\n\t\tbio_set_flag(bio, BIO_REMAPPED);\n\tbio->bi_ioprio\t\t= bio_src->bi_ioprio;\n\tbio->bi_iter.bi_sector\t= bio_src->bi_iter.bi_sector;\n\tbio->bi_iter.bi_size\t= bio_src->bi_iter.bi_size;\n\n\tswitch (bio_op(bio)) {\n\tcase REQ_OP_DISCARD:\n\tcase REQ_OP_SECURE_ERASE:\n\tcase REQ_OP_WRITE_ZEROES:\n\t\tbreak;\n\tdefault:\n\t\tbio_for_each_segment(bv, bio_src, iter)\n\t\t\tbio->bi_io_vec[bio->bi_vcnt++] = bv;\n\t\tbreak;\n\t}\n\n\tif (bio_crypt_clone(bio, bio_src, GFP_NOIO) < 0)\n\t\tgoto err_put;\n\n\tif (bio_integrity(bio_src) &&\n\t    bio_integrity_clone(bio, bio_src, GFP_NOIO) < 0)\n\t\tgoto err_put;\n\n\tbio_clone_blkg_association(bio, bio_src);\n\n\treturn bio;\n\nerr_put:\n\tbio_put(bio);\n\treturn NULL;\n}\n\nstruct bio *__blk_queue_bounce(struct bio *bio_orig, struct request_queue *q)\n{\n\tstruct bio *bio;\n\tint rw = bio_data_dir(bio_orig);\n\tstruct bio_vec *to, from;\n\tstruct bvec_iter iter;\n\tunsigned i = 0, bytes = 0;\n\tbool bounce = false;\n\tint sectors;\n\n\tbio_for_each_segment(from, bio_orig, iter) {\n\t\tif (i++ < BIO_MAX_VECS)\n\t\t\tbytes += from.bv_len;\n\t\tif (PageHighMem(from.bv_page))\n\t\t\tbounce = true;\n\t}\n\tif (!bounce)\n\t\treturn bio_orig;\n\n\t \n\tsectors = ALIGN_DOWN(bytes, queue_logical_block_size(q)) >>\n\t\t\tSECTOR_SHIFT;\n\tif (sectors < bio_sectors(bio_orig)) {\n\t\tbio = bio_split(bio_orig, sectors, GFP_NOIO, &bounce_bio_split);\n\t\tbio_chain(bio, bio_orig);\n\t\tsubmit_bio_noacct(bio_orig);\n\t\tbio_orig = bio;\n\t}\n\tbio = bounce_clone_bio(bio_orig);\n\n\t \n\tfor (i = 0, to = bio->bi_io_vec; i < bio->bi_vcnt; to++, i++) {\n\t\tstruct page *bounce_page;\n\n\t\tif (!PageHighMem(to->bv_page))\n\t\t\tcontinue;\n\n\t\tbounce_page = mempool_alloc(&page_pool, GFP_NOIO);\n\t\tinc_zone_page_state(bounce_page, NR_BOUNCE);\n\n\t\tif (rw == WRITE) {\n\t\t\tflush_dcache_page(to->bv_page);\n\t\t\tmemcpy_from_bvec(page_address(bounce_page), to);\n\t\t}\n\t\tto->bv_page = bounce_page;\n\t}\n\n\ttrace_block_bio_bounce(bio_orig);\n\n\tbio->bi_flags |= (1 << BIO_BOUNCED);\n\n\tif (rw == READ)\n\t\tbio->bi_end_io = bounce_end_io_read;\n\telse\n\t\tbio->bi_end_io = bounce_end_io_write;\n\n\tbio->bi_private = bio_orig;\n\treturn bio;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}