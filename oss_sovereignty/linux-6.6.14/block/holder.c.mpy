{
  "module_name": "holder.c",
  "hash_id": "5345cb3b744564ca57df729cc8e3bee8fcfcc66d85e24b4501ce6be98cac7159",
  "original_prompt": "Ingested from linux-6.6.14/block/holder.c",
  "human_readable_source": "\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n\nstruct bd_holder_disk {\n\tstruct list_head\tlist;\n\tstruct kobject\t\t*holder_dir;\n\tint\t\t\trefcnt;\n};\n\nstatic struct bd_holder_disk *bd_find_holder_disk(struct block_device *bdev,\n\t\t\t\t\t\t  struct gendisk *disk)\n{\n\tstruct bd_holder_disk *holder;\n\n\tlist_for_each_entry(holder, &disk->slave_bdevs, list)\n\t\tif (holder->holder_dir == bdev->bd_holder_dir)\n\t\t\treturn holder;\n\treturn NULL;\n}\n\nstatic int add_symlink(struct kobject *from, struct kobject *to)\n{\n\treturn sysfs_create_link(from, to, kobject_name(to));\n}\n\nstatic void del_symlink(struct kobject *from, struct kobject *to)\n{\n\tsysfs_remove_link(from, kobject_name(to));\n}\n\n \nint bd_link_disk_holder(struct block_device *bdev, struct gendisk *disk)\n{\n\tstruct bd_holder_disk *holder;\n\tint ret = 0;\n\n\tif (WARN_ON_ONCE(!disk->slave_dir))\n\t\treturn -EINVAL;\n\n\tif (bdev->bd_disk == disk)\n\t\treturn -EINVAL;\n\n\t \n\tmutex_lock(&bdev->bd_disk->open_mutex);\n\tif (!disk_live(bdev->bd_disk)) {\n\t\tmutex_unlock(&bdev->bd_disk->open_mutex);\n\t\treturn -ENODEV;\n\t}\n\tkobject_get(bdev->bd_holder_dir);\n\tmutex_unlock(&bdev->bd_disk->open_mutex);\n\n\tmutex_lock(&disk->open_mutex);\n\tWARN_ON_ONCE(!bdev->bd_holder);\n\n\tholder = bd_find_holder_disk(bdev, disk);\n\tif (holder) {\n\t\tkobject_put(bdev->bd_holder_dir);\n\t\tholder->refcnt++;\n\t\tgoto out_unlock;\n\t}\n\n\tholder = kzalloc(sizeof(*holder), GFP_KERNEL);\n\tif (!holder) {\n\t\tret = -ENOMEM;\n\t\tgoto out_unlock;\n\t}\n\n\tINIT_LIST_HEAD(&holder->list);\n\tholder->refcnt = 1;\n\tholder->holder_dir = bdev->bd_holder_dir;\n\n\tret = add_symlink(disk->slave_dir, bdev_kobj(bdev));\n\tif (ret)\n\t\tgoto out_free_holder;\n\tret = add_symlink(bdev->bd_holder_dir, &disk_to_dev(disk)->kobj);\n\tif (ret)\n\t\tgoto out_del_symlink;\n\tlist_add(&holder->list, &disk->slave_bdevs);\n\n\tmutex_unlock(&disk->open_mutex);\n\treturn 0;\n\nout_del_symlink:\n\tdel_symlink(disk->slave_dir, bdev_kobj(bdev));\nout_free_holder:\n\tkfree(holder);\nout_unlock:\n\tmutex_unlock(&disk->open_mutex);\n\tif (ret)\n\t\tkobject_put(bdev->bd_holder_dir);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(bd_link_disk_holder);\n\n \nvoid bd_unlink_disk_holder(struct block_device *bdev, struct gendisk *disk)\n{\n\tstruct bd_holder_disk *holder;\n\n\tif (WARN_ON_ONCE(!disk->slave_dir))\n\t\treturn;\n\n\tmutex_lock(&disk->open_mutex);\n\tholder = bd_find_holder_disk(bdev, disk);\n\tif (!WARN_ON_ONCE(holder == NULL) && !--holder->refcnt) {\n\t\tdel_symlink(disk->slave_dir, bdev_kobj(bdev));\n\t\tdel_symlink(holder->holder_dir, &disk_to_dev(disk)->kobj);\n\t\tkobject_put(holder->holder_dir);\n\t\tlist_del_init(&holder->list);\n\t\tkfree(holder);\n\t}\n\tmutex_unlock(&disk->open_mutex);\n}\nEXPORT_SYMBOL_GPL(bd_unlink_disk_holder);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}