{
  "module_name": "ioprio.c",
  "hash_id": "07575d7e2dfa8bcb8c852ef3ca02ded31d46404ac42cf7945d1d05def9f427eb",
  "original_prompt": "Ingested from linux-6.6.14/block/ioprio.c",
  "human_readable_source": "\n \n#include <linux/gfp.h>\n#include <linux/kernel.h>\n#include <linux/ioprio.h>\n#include <linux/cred.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/pid_namespace.h>\n\nint ioprio_check_cap(int ioprio)\n{\n\tint class = IOPRIO_PRIO_CLASS(ioprio);\n\tint level = IOPRIO_PRIO_LEVEL(ioprio);\n\n\tswitch (class) {\n\t\tcase IOPRIO_CLASS_RT:\n\t\t\t \n\t\t\tif (!capable(CAP_SYS_ADMIN) && !capable(CAP_SYS_NICE))\n\t\t\t\treturn -EPERM;\n\t\t\tfallthrough;\n\t\t\t \n\t\tcase IOPRIO_CLASS_BE:\n\t\t\tif (level >= IOPRIO_NR_LEVELS)\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tcase IOPRIO_CLASS_IDLE:\n\t\t\tbreak;\n\t\tcase IOPRIO_CLASS_NONE:\n\t\t\tif (level)\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tcase IOPRIO_CLASS_INVALID:\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nSYSCALL_DEFINE3(ioprio_set, int, which, int, who, int, ioprio)\n{\n\tstruct task_struct *p, *g;\n\tstruct user_struct *user;\n\tstruct pid *pgrp;\n\tkuid_t uid;\n\tint ret;\n\n\tret = ioprio_check_cap(ioprio);\n\tif (ret)\n\t\treturn ret;\n\n\tret = -ESRCH;\n\trcu_read_lock();\n\tswitch (which) {\n\t\tcase IOPRIO_WHO_PROCESS:\n\t\t\tif (!who)\n\t\t\t\tp = current;\n\t\t\telse\n\t\t\t\tp = find_task_by_vpid(who);\n\t\t\tif (p)\n\t\t\t\tret = set_task_ioprio(p, ioprio);\n\t\t\tbreak;\n\t\tcase IOPRIO_WHO_PGRP:\n\t\t\tif (!who)\n\t\t\t\tpgrp = task_pgrp(current);\n\t\t\telse\n\t\t\t\tpgrp = find_vpid(who);\n\n\t\t\tread_lock(&tasklist_lock);\n\t\t\tdo_each_pid_thread(pgrp, PIDTYPE_PGID, p) {\n\t\t\t\tret = set_task_ioprio(p, ioprio);\n\t\t\t\tif (ret) {\n\t\t\t\t\tread_unlock(&tasklist_lock);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t} while_each_pid_thread(pgrp, PIDTYPE_PGID, p);\n\t\t\tread_unlock(&tasklist_lock);\n\n\t\t\tbreak;\n\t\tcase IOPRIO_WHO_USER:\n\t\t\tuid = make_kuid(current_user_ns(), who);\n\t\t\tif (!uid_valid(uid))\n\t\t\t\tbreak;\n\t\t\tif (!who)\n\t\t\t\tuser = current_user();\n\t\t\telse\n\t\t\t\tuser = find_user(uid);\n\n\t\t\tif (!user)\n\t\t\t\tbreak;\n\n\t\t\tfor_each_process_thread(g, p) {\n\t\t\t\tif (!uid_eq(task_uid(p), uid) ||\n\t\t\t\t    !task_pid_vnr(p))\n\t\t\t\t\tcontinue;\n\t\t\t\tret = set_task_ioprio(p, ioprio);\n\t\t\t\tif (ret)\n\t\t\t\t\tgoto free_uid;\n\t\t\t}\nfree_uid:\n\t\t\tif (who)\n\t\t\t\tfree_uid(user);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = -EINVAL;\n\t}\n\nout:\n\trcu_read_unlock();\n\treturn ret;\n}\n\n \nint __get_task_ioprio(struct task_struct *p)\n{\n\tstruct io_context *ioc = p->io_context;\n\tint prio;\n\n\tif (p != current)\n\t\tlockdep_assert_held(&p->alloc_lock);\n\tif (ioc)\n\t\tprio = ioc->ioprio;\n\telse\n\t\tprio = IOPRIO_DEFAULT;\n\n\tif (IOPRIO_PRIO_CLASS(prio) == IOPRIO_CLASS_NONE)\n\t\tprio = IOPRIO_PRIO_VALUE(task_nice_ioclass(p),\n\t\t\t\t\t task_nice_ioprio(p));\n\treturn prio;\n}\nEXPORT_SYMBOL_GPL(__get_task_ioprio);\n\nstatic int get_task_ioprio(struct task_struct *p)\n{\n\tint ret;\n\n\tret = security_task_getioprio(p);\n\tif (ret)\n\t\tgoto out;\n\ttask_lock(p);\n\tret = __get_task_ioprio(p);\n\ttask_unlock(p);\nout:\n\treturn ret;\n}\n\n \nstatic int get_task_raw_ioprio(struct task_struct *p)\n{\n\tint ret;\n\n\tret = security_task_getioprio(p);\n\tif (ret)\n\t\tgoto out;\n\ttask_lock(p);\n\tif (p->io_context)\n\t\tret = p->io_context->ioprio;\n\telse\n\t\tret = IOPRIO_DEFAULT;\n\ttask_unlock(p);\nout:\n\treturn ret;\n}\n\nstatic int ioprio_best(unsigned short aprio, unsigned short bprio)\n{\n\treturn min(aprio, bprio);\n}\n\nSYSCALL_DEFINE2(ioprio_get, int, which, int, who)\n{\n\tstruct task_struct *g, *p;\n\tstruct user_struct *user;\n\tstruct pid *pgrp;\n\tkuid_t uid;\n\tint ret = -ESRCH;\n\tint tmpio;\n\n\trcu_read_lock();\n\tswitch (which) {\n\t\tcase IOPRIO_WHO_PROCESS:\n\t\t\tif (!who)\n\t\t\t\tp = current;\n\t\t\telse\n\t\t\t\tp = find_task_by_vpid(who);\n\t\t\tif (p)\n\t\t\t\tret = get_task_raw_ioprio(p);\n\t\t\tbreak;\n\t\tcase IOPRIO_WHO_PGRP:\n\t\t\tif (!who)\n\t\t\t\tpgrp = task_pgrp(current);\n\t\t\telse\n\t\t\t\tpgrp = find_vpid(who);\n\t\t\tread_lock(&tasklist_lock);\n\t\t\tdo_each_pid_thread(pgrp, PIDTYPE_PGID, p) {\n\t\t\t\ttmpio = get_task_ioprio(p);\n\t\t\t\tif (tmpio < 0)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (ret == -ESRCH)\n\t\t\t\t\tret = tmpio;\n\t\t\t\telse\n\t\t\t\t\tret = ioprio_best(ret, tmpio);\n\t\t\t} while_each_pid_thread(pgrp, PIDTYPE_PGID, p);\n\t\t\tread_unlock(&tasklist_lock);\n\n\t\t\tbreak;\n\t\tcase IOPRIO_WHO_USER:\n\t\t\tuid = make_kuid(current_user_ns(), who);\n\t\t\tif (!who)\n\t\t\t\tuser = current_user();\n\t\t\telse\n\t\t\t\tuser = find_user(uid);\n\n\t\t\tif (!user)\n\t\t\t\tbreak;\n\n\t\t\tfor_each_process_thread(g, p) {\n\t\t\t\tif (!uid_eq(task_uid(p), user->uid) ||\n\t\t\t\t    !task_pid_vnr(p))\n\t\t\t\t\tcontinue;\n\t\t\t\ttmpio = get_task_ioprio(p);\n\t\t\t\tif (tmpio < 0)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (ret == -ESRCH)\n\t\t\t\t\tret = tmpio;\n\t\t\t\telse\n\t\t\t\t\tret = ioprio_best(ret, tmpio);\n\t\t\t}\n\n\t\t\tif (who)\n\t\t\t\tfree_uid(user);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = -EINVAL;\n\t}\n\n\trcu_read_unlock();\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}