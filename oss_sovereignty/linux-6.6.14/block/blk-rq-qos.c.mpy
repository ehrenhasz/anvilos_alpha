{
  "module_name": "blk-rq-qos.c",
  "hash_id": "3819c9e61b52a81ea6e1437172f9f3967dab27c1511552066bd4e9f739354f55",
  "original_prompt": "Ingested from linux-6.6.14/block/blk-rq-qos.c",
  "human_readable_source": "\n\n#include \"blk-rq-qos.h\"\n\n \nstatic bool atomic_inc_below(atomic_t *v, unsigned int below)\n{\n\tunsigned int cur = atomic_read(v);\n\n\tdo {\n\t\tif (cur >= below)\n\t\t\treturn false;\n\t} while (!atomic_try_cmpxchg(v, &cur, cur + 1));\n\n\treturn true;\n}\n\nbool rq_wait_inc_below(struct rq_wait *rq_wait, unsigned int limit)\n{\n\treturn atomic_inc_below(&rq_wait->inflight, limit);\n}\n\nvoid __rq_qos_cleanup(struct rq_qos *rqos, struct bio *bio)\n{\n\tdo {\n\t\tif (rqos->ops->cleanup)\n\t\t\trqos->ops->cleanup(rqos, bio);\n\t\trqos = rqos->next;\n\t} while (rqos);\n}\n\nvoid __rq_qos_done(struct rq_qos *rqos, struct request *rq)\n{\n\tdo {\n\t\tif (rqos->ops->done)\n\t\t\trqos->ops->done(rqos, rq);\n\t\trqos = rqos->next;\n\t} while (rqos);\n}\n\nvoid __rq_qos_issue(struct rq_qos *rqos, struct request *rq)\n{\n\tdo {\n\t\tif (rqos->ops->issue)\n\t\t\trqos->ops->issue(rqos, rq);\n\t\trqos = rqos->next;\n\t} while (rqos);\n}\n\nvoid __rq_qos_requeue(struct rq_qos *rqos, struct request *rq)\n{\n\tdo {\n\t\tif (rqos->ops->requeue)\n\t\t\trqos->ops->requeue(rqos, rq);\n\t\trqos = rqos->next;\n\t} while (rqos);\n}\n\nvoid __rq_qos_throttle(struct rq_qos *rqos, struct bio *bio)\n{\n\tdo {\n\t\tif (rqos->ops->throttle)\n\t\t\trqos->ops->throttle(rqos, bio);\n\t\trqos = rqos->next;\n\t} while (rqos);\n}\n\nvoid __rq_qos_track(struct rq_qos *rqos, struct request *rq, struct bio *bio)\n{\n\tdo {\n\t\tif (rqos->ops->track)\n\t\t\trqos->ops->track(rqos, rq, bio);\n\t\trqos = rqos->next;\n\t} while (rqos);\n}\n\nvoid __rq_qos_merge(struct rq_qos *rqos, struct request *rq, struct bio *bio)\n{\n\tdo {\n\t\tif (rqos->ops->merge)\n\t\t\trqos->ops->merge(rqos, rq, bio);\n\t\trqos = rqos->next;\n\t} while (rqos);\n}\n\nvoid __rq_qos_done_bio(struct rq_qos *rqos, struct bio *bio)\n{\n\tdo {\n\t\tif (rqos->ops->done_bio)\n\t\t\trqos->ops->done_bio(rqos, bio);\n\t\trqos = rqos->next;\n\t} while (rqos);\n}\n\nvoid __rq_qos_queue_depth_changed(struct rq_qos *rqos)\n{\n\tdo {\n\t\tif (rqos->ops->queue_depth_changed)\n\t\t\trqos->ops->queue_depth_changed(rqos);\n\t\trqos = rqos->next;\n\t} while (rqos);\n}\n\n \nbool rq_depth_calc_max_depth(struct rq_depth *rqd)\n{\n\tunsigned int depth;\n\tbool ret = false;\n\n\t \n\tif (rqd->queue_depth == 1) {\n\t\tif (rqd->scale_step > 0)\n\t\t\trqd->max_depth = 1;\n\t\telse {\n\t\t\trqd->max_depth = 2;\n\t\t\tret = true;\n\t\t}\n\t} else {\n\t\t \n\t\tdepth = min_t(unsigned int, rqd->default_depth,\n\t\t\t      rqd->queue_depth);\n\t\tif (rqd->scale_step > 0)\n\t\t\tdepth = 1 + ((depth - 1) >> min(31, rqd->scale_step));\n\t\telse if (rqd->scale_step < 0) {\n\t\t\tunsigned int maxd = 3 * rqd->queue_depth / 4;\n\n\t\t\tdepth = 1 + ((depth - 1) << -rqd->scale_step);\n\t\t\tif (depth > maxd) {\n\t\t\t\tdepth = maxd;\n\t\t\t\tret = true;\n\t\t\t}\n\t\t}\n\n\t\trqd->max_depth = depth;\n\t}\n\n\treturn ret;\n}\n\n \nbool rq_depth_scale_up(struct rq_depth *rqd)\n{\n\t \n\tif (rqd->scaled_max)\n\t\treturn false;\n\n\trqd->scale_step--;\n\n\trqd->scaled_max = rq_depth_calc_max_depth(rqd);\n\treturn true;\n}\n\n \nbool rq_depth_scale_down(struct rq_depth *rqd, bool hard_throttle)\n{\n\t \n\tif (rqd->max_depth == 1)\n\t\treturn false;\n\n\tif (rqd->scale_step < 0 && hard_throttle)\n\t\trqd->scale_step = 0;\n\telse\n\t\trqd->scale_step++;\n\n\trqd->scaled_max = false;\n\trq_depth_calc_max_depth(rqd);\n\treturn true;\n}\n\nstruct rq_qos_wait_data {\n\tstruct wait_queue_entry wq;\n\tstruct task_struct *task;\n\tstruct rq_wait *rqw;\n\tacquire_inflight_cb_t *cb;\n\tvoid *private_data;\n\tbool got_token;\n};\n\nstatic int rq_qos_wake_function(struct wait_queue_entry *curr,\n\t\t\t\tunsigned int mode, int wake_flags, void *key)\n{\n\tstruct rq_qos_wait_data *data = container_of(curr,\n\t\t\t\t\t\t     struct rq_qos_wait_data,\n\t\t\t\t\t\t     wq);\n\n\t \n\tif (!data->cb(data->rqw, data->private_data))\n\t\treturn -1;\n\n\tdata->got_token = true;\n\tsmp_wmb();\n\tlist_del_init(&curr->entry);\n\twake_up_process(data->task);\n\treturn 1;\n}\n\n \nvoid rq_qos_wait(struct rq_wait *rqw, void *private_data,\n\t\t acquire_inflight_cb_t *acquire_inflight_cb,\n\t\t cleanup_cb_t *cleanup_cb)\n{\n\tstruct rq_qos_wait_data data = {\n\t\t.wq = {\n\t\t\t.func\t= rq_qos_wake_function,\n\t\t\t.entry\t= LIST_HEAD_INIT(data.wq.entry),\n\t\t},\n\t\t.task = current,\n\t\t.rqw = rqw,\n\t\t.cb = acquire_inflight_cb,\n\t\t.private_data = private_data,\n\t};\n\tbool has_sleeper;\n\n\thas_sleeper = wq_has_sleeper(&rqw->wait);\n\tif (!has_sleeper && acquire_inflight_cb(rqw, private_data))\n\t\treturn;\n\n\thas_sleeper = !prepare_to_wait_exclusive(&rqw->wait, &data.wq,\n\t\t\t\t\t\t TASK_UNINTERRUPTIBLE);\n\tdo {\n\t\t \n\t\tif (data.got_token)\n\t\t\tbreak;\n\t\tif (!has_sleeper && acquire_inflight_cb(rqw, private_data)) {\n\t\t\tfinish_wait(&rqw->wait, &data.wq);\n\n\t\t\t \n\t\t\tsmp_rmb();\n\t\t\tif (data.got_token)\n\t\t\t\tcleanup_cb(rqw, private_data);\n\t\t\tbreak;\n\t\t}\n\t\tio_schedule();\n\t\thas_sleeper = true;\n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t} while (1);\n\tfinish_wait(&rqw->wait, &data.wq);\n}\n\nvoid rq_qos_exit(struct request_queue *q)\n{\n\tmutex_lock(&q->rq_qos_mutex);\n\twhile (q->rq_qos) {\n\t\tstruct rq_qos *rqos = q->rq_qos;\n\t\tq->rq_qos = rqos->next;\n\t\trqos->ops->exit(rqos);\n\t}\n\tmutex_unlock(&q->rq_qos_mutex);\n}\n\nint rq_qos_add(struct rq_qos *rqos, struct gendisk *disk, enum rq_qos_id id,\n\t\tconst struct rq_qos_ops *ops)\n{\n\tstruct request_queue *q = disk->queue;\n\n\tlockdep_assert_held(&q->rq_qos_mutex);\n\n\trqos->disk = disk;\n\trqos->id = id;\n\trqos->ops = ops;\n\n\t \n\tblk_mq_freeze_queue(q);\n\n\tif (rq_qos_id(q, rqos->id))\n\t\tgoto ebusy;\n\trqos->next = q->rq_qos;\n\tq->rq_qos = rqos;\n\n\tblk_mq_unfreeze_queue(q);\n\n\tif (rqos->ops->debugfs_attrs) {\n\t\tmutex_lock(&q->debugfs_mutex);\n\t\tblk_mq_debugfs_register_rqos(rqos);\n\t\tmutex_unlock(&q->debugfs_mutex);\n\t}\n\n\treturn 0;\nebusy:\n\tblk_mq_unfreeze_queue(q);\n\treturn -EBUSY;\n}\n\nvoid rq_qos_del(struct rq_qos *rqos)\n{\n\tstruct request_queue *q = rqos->disk->queue;\n\tstruct rq_qos **cur;\n\n\tlockdep_assert_held(&q->rq_qos_mutex);\n\n\tblk_mq_freeze_queue(q);\n\tfor (cur = &q->rq_qos; *cur; cur = &(*cur)->next) {\n\t\tif (*cur == rqos) {\n\t\t\t*cur = rqos->next;\n\t\t\tbreak;\n\t\t}\n\t}\n\tblk_mq_unfreeze_queue(q);\n\n\tmutex_lock(&q->debugfs_mutex);\n\tblk_mq_debugfs_unregister_rqos(rqos);\n\tmutex_unlock(&q->debugfs_mutex);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}