{
  "module_name": "bio-integrity.c",
  "hash_id": "873814cdd5329a69d12492ae686dc5dece7fabd58796875ab4c1b3c2bcef9306",
  "original_prompt": "Ingested from linux-6.6.14/block/bio-integrity.c",
  "human_readable_source": "\n \n\n#include <linux/blk-integrity.h>\n#include <linux/mempool.h>\n#include <linux/export.h>\n#include <linux/bio.h>\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include \"blk.h\"\n\nstatic struct kmem_cache *bip_slab;\nstatic struct workqueue_struct *kintegrityd_wq;\n\nvoid blk_flush_integrity(void)\n{\n\tflush_workqueue(kintegrityd_wq);\n}\n\nstatic void __bio_integrity_free(struct bio_set *bs,\n\t\t\t\t struct bio_integrity_payload *bip)\n{\n\tif (bs && mempool_initialized(&bs->bio_integrity_pool)) {\n\t\tif (bip->bip_vec)\n\t\t\tbvec_free(&bs->bvec_integrity_pool, bip->bip_vec,\n\t\t\t\t  bip->bip_max_vcnt);\n\t\tmempool_free(bip, &bs->bio_integrity_pool);\n\t} else {\n\t\tkfree(bip);\n\t}\n}\n\n \nstruct bio_integrity_payload *bio_integrity_alloc(struct bio *bio,\n\t\t\t\t\t\t  gfp_t gfp_mask,\n\t\t\t\t\t\t  unsigned int nr_vecs)\n{\n\tstruct bio_integrity_payload *bip;\n\tstruct bio_set *bs = bio->bi_pool;\n\tunsigned inline_vecs;\n\n\tif (WARN_ON_ONCE(bio_has_crypt_ctx(bio)))\n\t\treturn ERR_PTR(-EOPNOTSUPP);\n\n\tif (!bs || !mempool_initialized(&bs->bio_integrity_pool)) {\n\t\tbip = kmalloc(struct_size(bip, bip_inline_vecs, nr_vecs), gfp_mask);\n\t\tinline_vecs = nr_vecs;\n\t} else {\n\t\tbip = mempool_alloc(&bs->bio_integrity_pool, gfp_mask);\n\t\tinline_vecs = BIO_INLINE_VECS;\n\t}\n\n\tif (unlikely(!bip))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmemset(bip, 0, sizeof(*bip));\n\n\tif (nr_vecs > inline_vecs) {\n\t\tbip->bip_max_vcnt = nr_vecs;\n\t\tbip->bip_vec = bvec_alloc(&bs->bvec_integrity_pool,\n\t\t\t\t\t  &bip->bip_max_vcnt, gfp_mask);\n\t\tif (!bip->bip_vec)\n\t\t\tgoto err;\n\t} else {\n\t\tbip->bip_vec = bip->bip_inline_vecs;\n\t\tbip->bip_max_vcnt = inline_vecs;\n\t}\n\n\tbip->bip_bio = bio;\n\tbio->bi_integrity = bip;\n\tbio->bi_opf |= REQ_INTEGRITY;\n\n\treturn bip;\nerr:\n\t__bio_integrity_free(bs, bip);\n\treturn ERR_PTR(-ENOMEM);\n}\nEXPORT_SYMBOL(bio_integrity_alloc);\n\n \nvoid bio_integrity_free(struct bio *bio)\n{\n\tstruct bio_integrity_payload *bip = bio_integrity(bio);\n\tstruct bio_set *bs = bio->bi_pool;\n\n\tif (bip->bip_flags & BIP_BLOCK_INTEGRITY)\n\t\tkfree(bvec_virt(bip->bip_vec));\n\n\t__bio_integrity_free(bs, bip);\n\tbio->bi_integrity = NULL;\n\tbio->bi_opf &= ~REQ_INTEGRITY;\n}\n\n \nint bio_integrity_add_page(struct bio *bio, struct page *page,\n\t\t\t   unsigned int len, unsigned int offset)\n{\n\tstruct request_queue *q = bdev_get_queue(bio->bi_bdev);\n\tstruct bio_integrity_payload *bip = bio_integrity(bio);\n\n\tif (((bip->bip_iter.bi_size + len) >> SECTOR_SHIFT) >\n\t    queue_max_hw_sectors(q))\n\t\treturn 0;\n\n\tif (bip->bip_vcnt > 0) {\n\t\tstruct bio_vec *bv = &bip->bip_vec[bip->bip_vcnt - 1];\n\t\tbool same_page = false;\n\n\t\tif (bvec_try_merge_hw_page(q, bv, page, len, offset,\n\t\t\t\t\t   &same_page)) {\n\t\t\tbip->bip_iter.bi_size += len;\n\t\t\treturn len;\n\t\t}\n\n\t\tif (bip->bip_vcnt >=\n\t\t    min(bip->bip_max_vcnt, queue_max_integrity_segments(q)))\n\t\t\treturn 0;\n\n\t\t \n\t\tif (bvec_gap_to_prev(&q->limits, bv, offset))\n\t\t\treturn 0;\n\t}\n\n\tbvec_set_page(&bip->bip_vec[bip->bip_vcnt], page, len, offset);\n\tbip->bip_vcnt++;\n\tbip->bip_iter.bi_size += len;\n\n\treturn len;\n}\nEXPORT_SYMBOL(bio_integrity_add_page);\n\n \nstatic blk_status_t bio_integrity_process(struct bio *bio,\n\t\tstruct bvec_iter *proc_iter, integrity_processing_fn *proc_fn)\n{\n\tstruct blk_integrity *bi = blk_get_integrity(bio->bi_bdev->bd_disk);\n\tstruct blk_integrity_iter iter;\n\tstruct bvec_iter bviter;\n\tstruct bio_vec bv;\n\tstruct bio_integrity_payload *bip = bio_integrity(bio);\n\tblk_status_t ret = BLK_STS_OK;\n\n\titer.disk_name = bio->bi_bdev->bd_disk->disk_name;\n\titer.interval = 1 << bi->interval_exp;\n\titer.tuple_size = bi->tuple_size;\n\titer.seed = proc_iter->bi_sector;\n\titer.prot_buf = bvec_virt(bip->bip_vec);\n\n\t__bio_for_each_segment(bv, bio, bviter, *proc_iter) {\n\t\tvoid *kaddr = bvec_kmap_local(&bv);\n\n\t\titer.data_buf = kaddr;\n\t\titer.data_size = bv.bv_len;\n\t\tret = proc_fn(&iter);\n\t\tkunmap_local(kaddr);\n\n\t\tif (ret)\n\t\t\tbreak;\n\n\t}\n\treturn ret;\n}\n\n \nbool bio_integrity_prep(struct bio *bio)\n{\n\tstruct bio_integrity_payload *bip;\n\tstruct blk_integrity *bi = blk_get_integrity(bio->bi_bdev->bd_disk);\n\tvoid *buf;\n\tunsigned long start, end;\n\tunsigned int len, nr_pages;\n\tunsigned int bytes, offset, i;\n\n\tif (!bi)\n\t\treturn true;\n\n\tif (bio_op(bio) != REQ_OP_READ && bio_op(bio) != REQ_OP_WRITE)\n\t\treturn true;\n\n\tif (!bio_sectors(bio))\n\t\treturn true;\n\n\t \n\tif (bio_integrity(bio))\n\t\treturn true;\n\n\tif (bio_data_dir(bio) == READ) {\n\t\tif (!bi->profile->verify_fn ||\n\t\t    !(bi->flags & BLK_INTEGRITY_VERIFY))\n\t\t\treturn true;\n\t} else {\n\t\tif (!bi->profile->generate_fn ||\n\t\t    !(bi->flags & BLK_INTEGRITY_GENERATE))\n\t\t\treturn true;\n\t}\n\n\t \n\tlen = bio_integrity_bytes(bi, bio_sectors(bio));\n\tbuf = kmalloc(len, GFP_NOIO);\n\tif (unlikely(buf == NULL)) {\n\t\tprintk(KERN_ERR \"could not allocate integrity buffer\\n\");\n\t\tgoto err_end_io;\n\t}\n\n\tend = (((unsigned long) buf) + len + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\tstart = ((unsigned long) buf) >> PAGE_SHIFT;\n\tnr_pages = end - start;\n\n\t \n\tbip = bio_integrity_alloc(bio, GFP_NOIO, nr_pages);\n\tif (IS_ERR(bip)) {\n\t\tprintk(KERN_ERR \"could not allocate data integrity bioset\\n\");\n\t\tkfree(buf);\n\t\tgoto err_end_io;\n\t}\n\n\tbip->bip_flags |= BIP_BLOCK_INTEGRITY;\n\tbip_set_seed(bip, bio->bi_iter.bi_sector);\n\n\tif (bi->flags & BLK_INTEGRITY_IP_CHECKSUM)\n\t\tbip->bip_flags |= BIP_IP_CHECKSUM;\n\n\t \n\toffset = offset_in_page(buf);\n\tfor (i = 0; i < nr_pages && len > 0; i++) {\n\t\tbytes = PAGE_SIZE - offset;\n\n\t\tif (bytes > len)\n\t\t\tbytes = len;\n\n\t\tif (bio_integrity_add_page(bio, virt_to_page(buf),\n\t\t\t\t\t   bytes, offset) < bytes) {\n\t\t\tprintk(KERN_ERR \"could not attach integrity payload\\n\");\n\t\t\tgoto err_end_io;\n\t\t}\n\n\t\tbuf += bytes;\n\t\tlen -= bytes;\n\t\toffset = 0;\n\t}\n\n\t \n\tif (bio_data_dir(bio) == WRITE) {\n\t\tbio_integrity_process(bio, &bio->bi_iter,\n\t\t\t\t      bi->profile->generate_fn);\n\t} else {\n\t\tbip->bio_iter = bio->bi_iter;\n\t}\n\treturn true;\n\nerr_end_io:\n\tbio->bi_status = BLK_STS_RESOURCE;\n\tbio_endio(bio);\n\treturn false;\n}\nEXPORT_SYMBOL(bio_integrity_prep);\n\n \nstatic void bio_integrity_verify_fn(struct work_struct *work)\n{\n\tstruct bio_integrity_payload *bip =\n\t\tcontainer_of(work, struct bio_integrity_payload, bip_work);\n\tstruct bio *bio = bip->bip_bio;\n\tstruct blk_integrity *bi = blk_get_integrity(bio->bi_bdev->bd_disk);\n\n\t \n\tbio->bi_status = bio_integrity_process(bio, &bip->bio_iter,\n\t\t\t\t\t\tbi->profile->verify_fn);\n\tbio_integrity_free(bio);\n\tbio_endio(bio);\n}\n\n \nbool __bio_integrity_endio(struct bio *bio)\n{\n\tstruct blk_integrity *bi = blk_get_integrity(bio->bi_bdev->bd_disk);\n\tstruct bio_integrity_payload *bip = bio_integrity(bio);\n\n\tif (bio_op(bio) == REQ_OP_READ && !bio->bi_status &&\n\t    (bip->bip_flags & BIP_BLOCK_INTEGRITY) && bi->profile->verify_fn) {\n\t\tINIT_WORK(&bip->bip_work, bio_integrity_verify_fn);\n\t\tqueue_work(kintegrityd_wq, &bip->bip_work);\n\t\treturn false;\n\t}\n\n\tbio_integrity_free(bio);\n\treturn true;\n}\n\n \nvoid bio_integrity_advance(struct bio *bio, unsigned int bytes_done)\n{\n\tstruct bio_integrity_payload *bip = bio_integrity(bio);\n\tstruct blk_integrity *bi = blk_get_integrity(bio->bi_bdev->bd_disk);\n\tunsigned bytes = bio_integrity_bytes(bi, bytes_done >> 9);\n\n\tbip->bip_iter.bi_sector += bio_integrity_intervals(bi, bytes_done >> 9);\n\tbvec_iter_advance(bip->bip_vec, &bip->bip_iter, bytes);\n}\n\n \nvoid bio_integrity_trim(struct bio *bio)\n{\n\tstruct bio_integrity_payload *bip = bio_integrity(bio);\n\tstruct blk_integrity *bi = blk_get_integrity(bio->bi_bdev->bd_disk);\n\n\tbip->bip_iter.bi_size = bio_integrity_bytes(bi, bio_sectors(bio));\n}\nEXPORT_SYMBOL(bio_integrity_trim);\n\n \nint bio_integrity_clone(struct bio *bio, struct bio *bio_src,\n\t\t\tgfp_t gfp_mask)\n{\n\tstruct bio_integrity_payload *bip_src = bio_integrity(bio_src);\n\tstruct bio_integrity_payload *bip;\n\n\tBUG_ON(bip_src == NULL);\n\n\tbip = bio_integrity_alloc(bio, gfp_mask, bip_src->bip_vcnt);\n\tif (IS_ERR(bip))\n\t\treturn PTR_ERR(bip);\n\n\tmemcpy(bip->bip_vec, bip_src->bip_vec,\n\t       bip_src->bip_vcnt * sizeof(struct bio_vec));\n\n\tbip->bip_vcnt = bip_src->bip_vcnt;\n\tbip->bip_iter = bip_src->bip_iter;\n\tbip->bip_flags = bip_src->bip_flags & ~BIP_BLOCK_INTEGRITY;\n\n\treturn 0;\n}\n\nint bioset_integrity_create(struct bio_set *bs, int pool_size)\n{\n\tif (mempool_initialized(&bs->bio_integrity_pool))\n\t\treturn 0;\n\n\tif (mempool_init_slab_pool(&bs->bio_integrity_pool,\n\t\t\t\t   pool_size, bip_slab))\n\t\treturn -1;\n\n\tif (biovec_init_pool(&bs->bvec_integrity_pool, pool_size)) {\n\t\tmempool_exit(&bs->bio_integrity_pool);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(bioset_integrity_create);\n\nvoid bioset_integrity_free(struct bio_set *bs)\n{\n\tmempool_exit(&bs->bio_integrity_pool);\n\tmempool_exit(&bs->bvec_integrity_pool);\n}\n\nvoid __init bio_integrity_init(void)\n{\n\t \n\tkintegrityd_wq = alloc_workqueue(\"kintegrityd\", WQ_MEM_RECLAIM |\n\t\t\t\t\t WQ_HIGHPRI | WQ_CPU_INTENSIVE, 1);\n\tif (!kintegrityd_wq)\n\t\tpanic(\"Failed to create kintegrityd\\n\");\n\n\tbip_slab = kmem_cache_create(\"bio_integrity_payload\",\n\t\t\t\t     sizeof(struct bio_integrity_payload) +\n\t\t\t\t     sizeof(struct bio_vec) * BIO_INLINE_VECS,\n\t\t\t\t     0, SLAB_HWCACHE_ALIGN|SLAB_PANIC, NULL);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}