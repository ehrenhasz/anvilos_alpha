{
  "module_name": "blk-crypto-profile.c",
  "hash_id": "01e6479f4ea3160209506570e323e7ae821a3397ed51eb05cedc4cd1893fd555",
  "original_prompt": "Ingested from linux-6.6.14/block/blk-crypto-profile.c",
  "human_readable_source": "\n \n\n \n\n#define pr_fmt(fmt) \"blk-crypto: \" fmt\n\n#include <linux/blk-crypto-profile.h>\n#include <linux/device.h>\n#include <linux/atomic.h>\n#include <linux/mutex.h>\n#include <linux/pm_runtime.h>\n#include <linux/wait.h>\n#include <linux/blkdev.h>\n#include <linux/blk-integrity.h>\n#include \"blk-crypto-internal.h\"\n\nstruct blk_crypto_keyslot {\n\tatomic_t slot_refs;\n\tstruct list_head idle_slot_node;\n\tstruct hlist_node hash_node;\n\tconst struct blk_crypto_key *key;\n\tstruct blk_crypto_profile *profile;\n};\n\nstatic inline void blk_crypto_hw_enter(struct blk_crypto_profile *profile)\n{\n\t \n\tif (profile->dev)\n\t\tpm_runtime_get_sync(profile->dev);\n\tdown_write(&profile->lock);\n}\n\nstatic inline void blk_crypto_hw_exit(struct blk_crypto_profile *profile)\n{\n\tup_write(&profile->lock);\n\tif (profile->dev)\n\t\tpm_runtime_put_sync(profile->dev);\n}\n\n \nint blk_crypto_profile_init(struct blk_crypto_profile *profile,\n\t\t\t    unsigned int num_slots)\n{\n\tunsigned int slot;\n\tunsigned int i;\n\tunsigned int slot_hashtable_size;\n\n\tmemset(profile, 0, sizeof(*profile));\n\n\t \n\tlockdep_register_key(&profile->lockdep_key);\n\t__init_rwsem(&profile->lock, \"&profile->lock\", &profile->lockdep_key);\n\n\tif (num_slots == 0)\n\t\treturn 0;\n\n\t \n\n\tprofile->slots = kvcalloc(num_slots, sizeof(profile->slots[0]),\n\t\t\t\t  GFP_KERNEL);\n\tif (!profile->slots)\n\t\tgoto err_destroy;\n\n\tprofile->num_slots = num_slots;\n\n\tinit_waitqueue_head(&profile->idle_slots_wait_queue);\n\tINIT_LIST_HEAD(&profile->idle_slots);\n\n\tfor (slot = 0; slot < num_slots; slot++) {\n\t\tprofile->slots[slot].profile = profile;\n\t\tlist_add_tail(&profile->slots[slot].idle_slot_node,\n\t\t\t      &profile->idle_slots);\n\t}\n\n\tspin_lock_init(&profile->idle_slots_lock);\n\n\tslot_hashtable_size = roundup_pow_of_two(num_slots);\n\t \n\tif (slot_hashtable_size < 2)\n\t\tslot_hashtable_size = 2;\n\n\tprofile->log_slot_ht_size = ilog2(slot_hashtable_size);\n\tprofile->slot_hashtable =\n\t\tkvmalloc_array(slot_hashtable_size,\n\t\t\t       sizeof(profile->slot_hashtable[0]), GFP_KERNEL);\n\tif (!profile->slot_hashtable)\n\t\tgoto err_destroy;\n\tfor (i = 0; i < slot_hashtable_size; i++)\n\t\tINIT_HLIST_HEAD(&profile->slot_hashtable[i]);\n\n\treturn 0;\n\nerr_destroy:\n\tblk_crypto_profile_destroy(profile);\n\treturn -ENOMEM;\n}\nEXPORT_SYMBOL_GPL(blk_crypto_profile_init);\n\nstatic void blk_crypto_profile_destroy_callback(void *profile)\n{\n\tblk_crypto_profile_destroy(profile);\n}\n\n \nint devm_blk_crypto_profile_init(struct device *dev,\n\t\t\t\t struct blk_crypto_profile *profile,\n\t\t\t\t unsigned int num_slots)\n{\n\tint err = blk_crypto_profile_init(profile, num_slots);\n\n\tif (err)\n\t\treturn err;\n\n\treturn devm_add_action_or_reset(dev,\n\t\t\t\t\tblk_crypto_profile_destroy_callback,\n\t\t\t\t\tprofile);\n}\nEXPORT_SYMBOL_GPL(devm_blk_crypto_profile_init);\n\nstatic inline struct hlist_head *\nblk_crypto_hash_bucket_for_key(struct blk_crypto_profile *profile,\n\t\t\t       const struct blk_crypto_key *key)\n{\n\treturn &profile->slot_hashtable[\n\t\t\thash_ptr(key, profile->log_slot_ht_size)];\n}\n\nstatic void\nblk_crypto_remove_slot_from_lru_list(struct blk_crypto_keyslot *slot)\n{\n\tstruct blk_crypto_profile *profile = slot->profile;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&profile->idle_slots_lock, flags);\n\tlist_del(&slot->idle_slot_node);\n\tspin_unlock_irqrestore(&profile->idle_slots_lock, flags);\n}\n\nstatic struct blk_crypto_keyslot *\nblk_crypto_find_keyslot(struct blk_crypto_profile *profile,\n\t\t\tconst struct blk_crypto_key *key)\n{\n\tconst struct hlist_head *head =\n\t\tblk_crypto_hash_bucket_for_key(profile, key);\n\tstruct blk_crypto_keyslot *slotp;\n\n\thlist_for_each_entry(slotp, head, hash_node) {\n\t\tif (slotp->key == key)\n\t\t\treturn slotp;\n\t}\n\treturn NULL;\n}\n\nstatic struct blk_crypto_keyslot *\nblk_crypto_find_and_grab_keyslot(struct blk_crypto_profile *profile,\n\t\t\t\t const struct blk_crypto_key *key)\n{\n\tstruct blk_crypto_keyslot *slot;\n\n\tslot = blk_crypto_find_keyslot(profile, key);\n\tif (!slot)\n\t\treturn NULL;\n\tif (atomic_inc_return(&slot->slot_refs) == 1) {\n\t\t \n\t\tblk_crypto_remove_slot_from_lru_list(slot);\n\t}\n\treturn slot;\n}\n\n \nunsigned int blk_crypto_keyslot_index(struct blk_crypto_keyslot *slot)\n{\n\treturn slot - slot->profile->slots;\n}\nEXPORT_SYMBOL_GPL(blk_crypto_keyslot_index);\n\n \nblk_status_t blk_crypto_get_keyslot(struct blk_crypto_profile *profile,\n\t\t\t\t    const struct blk_crypto_key *key,\n\t\t\t\t    struct blk_crypto_keyslot **slot_ptr)\n{\n\tstruct blk_crypto_keyslot *slot;\n\tint slot_idx;\n\tint err;\n\n\t*slot_ptr = NULL;\n\n\t \n\tif (profile->num_slots == 0)\n\t\treturn BLK_STS_OK;\n\n\tdown_read(&profile->lock);\n\tslot = blk_crypto_find_and_grab_keyslot(profile, key);\n\tup_read(&profile->lock);\n\tif (slot)\n\t\tgoto success;\n\n\tfor (;;) {\n\t\tblk_crypto_hw_enter(profile);\n\t\tslot = blk_crypto_find_and_grab_keyslot(profile, key);\n\t\tif (slot) {\n\t\t\tblk_crypto_hw_exit(profile);\n\t\t\tgoto success;\n\t\t}\n\n\t\t \n\t\tif (!list_empty(&profile->idle_slots))\n\t\t\tbreak;\n\n\t\tblk_crypto_hw_exit(profile);\n\t\twait_event(profile->idle_slots_wait_queue,\n\t\t\t   !list_empty(&profile->idle_slots));\n\t}\n\n\tslot = list_first_entry(&profile->idle_slots, struct blk_crypto_keyslot,\n\t\t\t\tidle_slot_node);\n\tslot_idx = blk_crypto_keyslot_index(slot);\n\n\terr = profile->ll_ops.keyslot_program(profile, key, slot_idx);\n\tif (err) {\n\t\twake_up(&profile->idle_slots_wait_queue);\n\t\tblk_crypto_hw_exit(profile);\n\t\treturn errno_to_blk_status(err);\n\t}\n\n\t \n\tif (slot->key)\n\t\thlist_del(&slot->hash_node);\n\tslot->key = key;\n\thlist_add_head(&slot->hash_node,\n\t\t       blk_crypto_hash_bucket_for_key(profile, key));\n\n\tatomic_set(&slot->slot_refs, 1);\n\n\tblk_crypto_remove_slot_from_lru_list(slot);\n\n\tblk_crypto_hw_exit(profile);\nsuccess:\n\t*slot_ptr = slot;\n\treturn BLK_STS_OK;\n}\n\n \nvoid blk_crypto_put_keyslot(struct blk_crypto_keyslot *slot)\n{\n\tstruct blk_crypto_profile *profile = slot->profile;\n\tunsigned long flags;\n\n\tif (atomic_dec_and_lock_irqsave(&slot->slot_refs,\n\t\t\t\t\t&profile->idle_slots_lock, flags)) {\n\t\tlist_add_tail(&slot->idle_slot_node, &profile->idle_slots);\n\t\tspin_unlock_irqrestore(&profile->idle_slots_lock, flags);\n\t\twake_up(&profile->idle_slots_wait_queue);\n\t}\n}\n\n \nbool __blk_crypto_cfg_supported(struct blk_crypto_profile *profile,\n\t\t\t\tconst struct blk_crypto_config *cfg)\n{\n\tif (!profile)\n\t\treturn false;\n\tif (!(profile->modes_supported[cfg->crypto_mode] & cfg->data_unit_size))\n\t\treturn false;\n\tif (profile->max_dun_bytes_supported < cfg->dun_bytes)\n\t\treturn false;\n\treturn true;\n}\n\n \nint __blk_crypto_evict_key(struct blk_crypto_profile *profile,\n\t\t\t   const struct blk_crypto_key *key)\n{\n\tstruct blk_crypto_keyslot *slot;\n\tint err;\n\n\tif (profile->num_slots == 0) {\n\t\tif (profile->ll_ops.keyslot_evict) {\n\t\t\tblk_crypto_hw_enter(profile);\n\t\t\terr = profile->ll_ops.keyslot_evict(profile, key, -1);\n\t\t\tblk_crypto_hw_exit(profile);\n\t\t\treturn err;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tblk_crypto_hw_enter(profile);\n\tslot = blk_crypto_find_keyslot(profile, key);\n\tif (!slot) {\n\t\t \n\t\terr = 0;\n\t\tgoto out;\n\t}\n\n\tif (WARN_ON_ONCE(atomic_read(&slot->slot_refs) != 0)) {\n\t\t \n\t\terr = -EBUSY;\n\t\tgoto out_remove;\n\t}\n\terr = profile->ll_ops.keyslot_evict(profile, key,\n\t\t\t\t\t    blk_crypto_keyslot_index(slot));\nout_remove:\n\t \n\thlist_del(&slot->hash_node);\n\tslot->key = NULL;\nout:\n\tblk_crypto_hw_exit(profile);\n\treturn err;\n}\n\n \nvoid blk_crypto_reprogram_all_keys(struct blk_crypto_profile *profile)\n{\n\tunsigned int slot;\n\n\tif (profile->num_slots == 0)\n\t\treturn;\n\n\t \n\tdown_write(&profile->lock);\n\tfor (slot = 0; slot < profile->num_slots; slot++) {\n\t\tconst struct blk_crypto_key *key = profile->slots[slot].key;\n\t\tint err;\n\n\t\tif (!key)\n\t\t\tcontinue;\n\n\t\terr = profile->ll_ops.keyslot_program(profile, key, slot);\n\t\tWARN_ON(err);\n\t}\n\tup_write(&profile->lock);\n}\nEXPORT_SYMBOL_GPL(blk_crypto_reprogram_all_keys);\n\nvoid blk_crypto_profile_destroy(struct blk_crypto_profile *profile)\n{\n\tif (!profile)\n\t\treturn;\n\tlockdep_unregister_key(&profile->lockdep_key);\n\tkvfree(profile->slot_hashtable);\n\tkvfree_sensitive(profile->slots,\n\t\t\t sizeof(profile->slots[0]) * profile->num_slots);\n\tmemzero_explicit(profile, sizeof(*profile));\n}\nEXPORT_SYMBOL_GPL(blk_crypto_profile_destroy);\n\nbool blk_crypto_register(struct blk_crypto_profile *profile,\n\t\t\t struct request_queue *q)\n{\n\tif (blk_integrity_queue_supports_integrity(q)) {\n\t\tpr_warn(\"Integrity and hardware inline encryption are not supported together. Disabling hardware inline encryption.\\n\");\n\t\treturn false;\n\t}\n\tq->crypto_profile = profile;\n\treturn true;\n}\nEXPORT_SYMBOL_GPL(blk_crypto_register);\n\n \nvoid blk_crypto_intersect_capabilities(struct blk_crypto_profile *parent,\n\t\t\t\t       const struct blk_crypto_profile *child)\n{\n\tif (child) {\n\t\tunsigned int i;\n\n\t\tparent->max_dun_bytes_supported =\n\t\t\tmin(parent->max_dun_bytes_supported,\n\t\t\t    child->max_dun_bytes_supported);\n\t\tfor (i = 0; i < ARRAY_SIZE(child->modes_supported); i++)\n\t\t\tparent->modes_supported[i] &= child->modes_supported[i];\n\t} else {\n\t\tparent->max_dun_bytes_supported = 0;\n\t\tmemset(parent->modes_supported, 0,\n\t\t       sizeof(parent->modes_supported));\n\t}\n}\nEXPORT_SYMBOL_GPL(blk_crypto_intersect_capabilities);\n\n \nbool blk_crypto_has_capabilities(const struct blk_crypto_profile *target,\n\t\t\t\t const struct blk_crypto_profile *reference)\n{\n\tint i;\n\n\tif (!reference)\n\t\treturn true;\n\n\tif (!target)\n\t\treturn false;\n\n\tfor (i = 0; i < ARRAY_SIZE(target->modes_supported); i++) {\n\t\tif (reference->modes_supported[i] & ~target->modes_supported[i])\n\t\t\treturn false;\n\t}\n\n\tif (reference->max_dun_bytes_supported >\n\t    target->max_dun_bytes_supported)\n\t\treturn false;\n\n\treturn true;\n}\nEXPORT_SYMBOL_GPL(blk_crypto_has_capabilities);\n\n \nvoid blk_crypto_update_capabilities(struct blk_crypto_profile *dst,\n\t\t\t\t    const struct blk_crypto_profile *src)\n{\n\tmemcpy(dst->modes_supported, src->modes_supported,\n\t       sizeof(dst->modes_supported));\n\n\tdst->max_dun_bytes_supported = src->max_dun_bytes_supported;\n}\nEXPORT_SYMBOL_GPL(blk_crypto_update_capabilities);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}