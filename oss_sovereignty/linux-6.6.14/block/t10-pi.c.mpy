{
  "module_name": "t10-pi.c",
  "hash_id": "8d6b9ab3092db9a39d747dc7a8e6f93973ecb73cd37fae9d2c422daa055ff4f4",
  "original_prompt": "Ingested from linux-6.6.14/block/t10-pi.c",
  "human_readable_source": "\n \n\n#include <linux/t10-pi.h>\n#include <linux/blk-integrity.h>\n#include <linux/crc-t10dif.h>\n#include <linux/crc64.h>\n#include <linux/module.h>\n#include <net/checksum.h>\n#include <asm/unaligned.h>\n\ntypedef __be16 (csum_fn) (void *, unsigned int);\n\nstatic __be16 t10_pi_crc_fn(void *data, unsigned int len)\n{\n\treturn cpu_to_be16(crc_t10dif(data, len));\n}\n\nstatic __be16 t10_pi_ip_fn(void *data, unsigned int len)\n{\n\treturn (__force __be16)ip_compute_csum(data, len);\n}\n\n \nstatic blk_status_t t10_pi_generate(struct blk_integrity_iter *iter,\n\t\tcsum_fn *fn, enum t10_dif_type type)\n{\n\tunsigned int i;\n\n\tfor (i = 0 ; i < iter->data_size ; i += iter->interval) {\n\t\tstruct t10_pi_tuple *pi = iter->prot_buf;\n\n\t\tpi->guard_tag = fn(iter->data_buf, iter->interval);\n\t\tpi->app_tag = 0;\n\n\t\tif (type == T10_PI_TYPE1_PROTECTION)\n\t\t\tpi->ref_tag = cpu_to_be32(lower_32_bits(iter->seed));\n\t\telse\n\t\t\tpi->ref_tag = 0;\n\n\t\titer->data_buf += iter->interval;\n\t\titer->prot_buf += iter->tuple_size;\n\t\titer->seed++;\n\t}\n\n\treturn BLK_STS_OK;\n}\n\nstatic blk_status_t t10_pi_verify(struct blk_integrity_iter *iter,\n\t\tcsum_fn *fn, enum t10_dif_type type)\n{\n\tunsigned int i;\n\n\tBUG_ON(type == T10_PI_TYPE0_PROTECTION);\n\n\tfor (i = 0 ; i < iter->data_size ; i += iter->interval) {\n\t\tstruct t10_pi_tuple *pi = iter->prot_buf;\n\t\t__be16 csum;\n\n\t\tif (type == T10_PI_TYPE1_PROTECTION ||\n\t\t    type == T10_PI_TYPE2_PROTECTION) {\n\t\t\tif (pi->app_tag == T10_PI_APP_ESCAPE)\n\t\t\t\tgoto next;\n\n\t\t\tif (be32_to_cpu(pi->ref_tag) !=\n\t\t\t    lower_32_bits(iter->seed)) {\n\t\t\t\tpr_err(\"%s: ref tag error at location %llu \" \\\n\t\t\t\t       \"(rcvd %u)\\n\", iter->disk_name,\n\t\t\t\t       (unsigned long long)\n\t\t\t\t       iter->seed, be32_to_cpu(pi->ref_tag));\n\t\t\t\treturn BLK_STS_PROTECTION;\n\t\t\t}\n\t\t} else if (type == T10_PI_TYPE3_PROTECTION) {\n\t\t\tif (pi->app_tag == T10_PI_APP_ESCAPE &&\n\t\t\t    pi->ref_tag == T10_PI_REF_ESCAPE)\n\t\t\t\tgoto next;\n\t\t}\n\n\t\tcsum = fn(iter->data_buf, iter->interval);\n\n\t\tif (pi->guard_tag != csum) {\n\t\t\tpr_err(\"%s: guard tag error at sector %llu \" \\\n\t\t\t       \"(rcvd %04x, want %04x)\\n\", iter->disk_name,\n\t\t\t       (unsigned long long)iter->seed,\n\t\t\t       be16_to_cpu(pi->guard_tag), be16_to_cpu(csum));\n\t\t\treturn BLK_STS_PROTECTION;\n\t\t}\n\nnext:\n\t\titer->data_buf += iter->interval;\n\t\titer->prot_buf += iter->tuple_size;\n\t\titer->seed++;\n\t}\n\n\treturn BLK_STS_OK;\n}\n\nstatic blk_status_t t10_pi_type1_generate_crc(struct blk_integrity_iter *iter)\n{\n\treturn t10_pi_generate(iter, t10_pi_crc_fn, T10_PI_TYPE1_PROTECTION);\n}\n\nstatic blk_status_t t10_pi_type1_generate_ip(struct blk_integrity_iter *iter)\n{\n\treturn t10_pi_generate(iter, t10_pi_ip_fn, T10_PI_TYPE1_PROTECTION);\n}\n\nstatic blk_status_t t10_pi_type1_verify_crc(struct blk_integrity_iter *iter)\n{\n\treturn t10_pi_verify(iter, t10_pi_crc_fn, T10_PI_TYPE1_PROTECTION);\n}\n\nstatic blk_status_t t10_pi_type1_verify_ip(struct blk_integrity_iter *iter)\n{\n\treturn t10_pi_verify(iter, t10_pi_ip_fn, T10_PI_TYPE1_PROTECTION);\n}\n\n \nstatic void t10_pi_type1_prepare(struct request *rq)\n{\n\tconst int tuple_sz = rq->q->integrity.tuple_size;\n\tu32 ref_tag = t10_pi_ref_tag(rq);\n\tstruct bio *bio;\n\n\t__rq_for_each_bio(bio, rq) {\n\t\tstruct bio_integrity_payload *bip = bio_integrity(bio);\n\t\tu32 virt = bip_get_seed(bip) & 0xffffffff;\n\t\tstruct bio_vec iv;\n\t\tstruct bvec_iter iter;\n\n\t\t \n\t\tif (bip->bip_flags & BIP_MAPPED_INTEGRITY)\n\t\t\tbreak;\n\n\t\tbip_for_each_vec(iv, bip, iter) {\n\t\t\tunsigned int j;\n\t\t\tvoid *p;\n\n\t\t\tp = bvec_kmap_local(&iv);\n\t\t\tfor (j = 0; j < iv.bv_len; j += tuple_sz) {\n\t\t\t\tstruct t10_pi_tuple *pi = p;\n\n\t\t\t\tif (be32_to_cpu(pi->ref_tag) == virt)\n\t\t\t\t\tpi->ref_tag = cpu_to_be32(ref_tag);\n\t\t\t\tvirt++;\n\t\t\t\tref_tag++;\n\t\t\t\tp += tuple_sz;\n\t\t\t}\n\t\t\tkunmap_local(p);\n\t\t}\n\n\t\tbip->bip_flags |= BIP_MAPPED_INTEGRITY;\n\t}\n}\n\n \nstatic void t10_pi_type1_complete(struct request *rq, unsigned int nr_bytes)\n{\n\tunsigned intervals = nr_bytes >> rq->q->integrity.interval_exp;\n\tconst int tuple_sz = rq->q->integrity.tuple_size;\n\tu32 ref_tag = t10_pi_ref_tag(rq);\n\tstruct bio *bio;\n\n\t__rq_for_each_bio(bio, rq) {\n\t\tstruct bio_integrity_payload *bip = bio_integrity(bio);\n\t\tu32 virt = bip_get_seed(bip) & 0xffffffff;\n\t\tstruct bio_vec iv;\n\t\tstruct bvec_iter iter;\n\n\t\tbip_for_each_vec(iv, bip, iter) {\n\t\t\tunsigned int j;\n\t\t\tvoid *p;\n\n\t\t\tp = bvec_kmap_local(&iv);\n\t\t\tfor (j = 0; j < iv.bv_len && intervals; j += tuple_sz) {\n\t\t\t\tstruct t10_pi_tuple *pi = p;\n\n\t\t\t\tif (be32_to_cpu(pi->ref_tag) == ref_tag)\n\t\t\t\t\tpi->ref_tag = cpu_to_be32(virt);\n\t\t\t\tvirt++;\n\t\t\t\tref_tag++;\n\t\t\t\tintervals--;\n\t\t\t\tp += tuple_sz;\n\t\t\t}\n\t\t\tkunmap_local(p);\n\t\t}\n\t}\n}\n\nstatic blk_status_t t10_pi_type3_generate_crc(struct blk_integrity_iter *iter)\n{\n\treturn t10_pi_generate(iter, t10_pi_crc_fn, T10_PI_TYPE3_PROTECTION);\n}\n\nstatic blk_status_t t10_pi_type3_generate_ip(struct blk_integrity_iter *iter)\n{\n\treturn t10_pi_generate(iter, t10_pi_ip_fn, T10_PI_TYPE3_PROTECTION);\n}\n\nstatic blk_status_t t10_pi_type3_verify_crc(struct blk_integrity_iter *iter)\n{\n\treturn t10_pi_verify(iter, t10_pi_crc_fn, T10_PI_TYPE3_PROTECTION);\n}\n\nstatic blk_status_t t10_pi_type3_verify_ip(struct blk_integrity_iter *iter)\n{\n\treturn t10_pi_verify(iter, t10_pi_ip_fn, T10_PI_TYPE3_PROTECTION);\n}\n\n \nstatic void t10_pi_type3_prepare(struct request *rq)\n{\n}\n\n \nstatic void t10_pi_type3_complete(struct request *rq, unsigned int nr_bytes)\n{\n}\n\nconst struct blk_integrity_profile t10_pi_type1_crc = {\n\t.name\t\t\t= \"T10-DIF-TYPE1-CRC\",\n\t.generate_fn\t\t= t10_pi_type1_generate_crc,\n\t.verify_fn\t\t= t10_pi_type1_verify_crc,\n\t.prepare_fn\t\t= t10_pi_type1_prepare,\n\t.complete_fn\t\t= t10_pi_type1_complete,\n};\nEXPORT_SYMBOL(t10_pi_type1_crc);\n\nconst struct blk_integrity_profile t10_pi_type1_ip = {\n\t.name\t\t\t= \"T10-DIF-TYPE1-IP\",\n\t.generate_fn\t\t= t10_pi_type1_generate_ip,\n\t.verify_fn\t\t= t10_pi_type1_verify_ip,\n\t.prepare_fn\t\t= t10_pi_type1_prepare,\n\t.complete_fn\t\t= t10_pi_type1_complete,\n};\nEXPORT_SYMBOL(t10_pi_type1_ip);\n\nconst struct blk_integrity_profile t10_pi_type3_crc = {\n\t.name\t\t\t= \"T10-DIF-TYPE3-CRC\",\n\t.generate_fn\t\t= t10_pi_type3_generate_crc,\n\t.verify_fn\t\t= t10_pi_type3_verify_crc,\n\t.prepare_fn\t\t= t10_pi_type3_prepare,\n\t.complete_fn\t\t= t10_pi_type3_complete,\n};\nEXPORT_SYMBOL(t10_pi_type3_crc);\n\nconst struct blk_integrity_profile t10_pi_type3_ip = {\n\t.name\t\t\t= \"T10-DIF-TYPE3-IP\",\n\t.generate_fn\t\t= t10_pi_type3_generate_ip,\n\t.verify_fn\t\t= t10_pi_type3_verify_ip,\n\t.prepare_fn\t\t= t10_pi_type3_prepare,\n\t.complete_fn\t\t= t10_pi_type3_complete,\n};\nEXPORT_SYMBOL(t10_pi_type3_ip);\n\nstatic __be64 ext_pi_crc64(void *data, unsigned int len)\n{\n\treturn cpu_to_be64(crc64_rocksoft(data, len));\n}\n\nstatic blk_status_t ext_pi_crc64_generate(struct blk_integrity_iter *iter,\n\t\t\t\t\tenum t10_dif_type type)\n{\n\tunsigned int i;\n\n\tfor (i = 0 ; i < iter->data_size ; i += iter->interval) {\n\t\tstruct crc64_pi_tuple *pi = iter->prot_buf;\n\n\t\tpi->guard_tag = ext_pi_crc64(iter->data_buf, iter->interval);\n\t\tpi->app_tag = 0;\n\n\t\tif (type == T10_PI_TYPE1_PROTECTION)\n\t\t\tput_unaligned_be48(iter->seed, pi->ref_tag);\n\t\telse\n\t\t\tput_unaligned_be48(0ULL, pi->ref_tag);\n\n\t\titer->data_buf += iter->interval;\n\t\titer->prot_buf += iter->tuple_size;\n\t\titer->seed++;\n\t}\n\n\treturn BLK_STS_OK;\n}\n\nstatic bool ext_pi_ref_escape(u8 *ref_tag)\n{\n\tstatic u8 ref_escape[6] = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };\n\n\treturn memcmp(ref_tag, ref_escape, sizeof(ref_escape)) == 0;\n}\n\nstatic blk_status_t ext_pi_crc64_verify(struct blk_integrity_iter *iter,\n\t\t\t\t      enum t10_dif_type type)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < iter->data_size; i += iter->interval) {\n\t\tstruct crc64_pi_tuple *pi = iter->prot_buf;\n\t\tu64 ref, seed;\n\t\t__be64 csum;\n\n\t\tif (type == T10_PI_TYPE1_PROTECTION) {\n\t\t\tif (pi->app_tag == T10_PI_APP_ESCAPE)\n\t\t\t\tgoto next;\n\n\t\t\tref = get_unaligned_be48(pi->ref_tag);\n\t\t\tseed = lower_48_bits(iter->seed);\n\t\t\tif (ref != seed) {\n\t\t\t\tpr_err(\"%s: ref tag error at location %llu (rcvd %llu)\\n\",\n\t\t\t\t\titer->disk_name, seed, ref);\n\t\t\t\treturn BLK_STS_PROTECTION;\n\t\t\t}\n\t\t} else if (type == T10_PI_TYPE3_PROTECTION) {\n\t\t\tif (pi->app_tag == T10_PI_APP_ESCAPE &&\n\t\t\t    ext_pi_ref_escape(pi->ref_tag))\n\t\t\t\tgoto next;\n\t\t}\n\n\t\tcsum = ext_pi_crc64(iter->data_buf, iter->interval);\n\t\tif (pi->guard_tag != csum) {\n\t\t\tpr_err(\"%s: guard tag error at sector %llu \" \\\n\t\t\t       \"(rcvd %016llx, want %016llx)\\n\",\n\t\t\t\titer->disk_name, (unsigned long long)iter->seed,\n\t\t\t\tbe64_to_cpu(pi->guard_tag), be64_to_cpu(csum));\n\t\t\treturn BLK_STS_PROTECTION;\n\t\t}\n\nnext:\n\t\titer->data_buf += iter->interval;\n\t\titer->prot_buf += iter->tuple_size;\n\t\titer->seed++;\n\t}\n\n\treturn BLK_STS_OK;\n}\n\nstatic blk_status_t ext_pi_type1_verify_crc64(struct blk_integrity_iter *iter)\n{\n\treturn ext_pi_crc64_verify(iter, T10_PI_TYPE1_PROTECTION);\n}\n\nstatic blk_status_t ext_pi_type1_generate_crc64(struct blk_integrity_iter *iter)\n{\n\treturn ext_pi_crc64_generate(iter, T10_PI_TYPE1_PROTECTION);\n}\n\nstatic void ext_pi_type1_prepare(struct request *rq)\n{\n\tconst int tuple_sz = rq->q->integrity.tuple_size;\n\tu64 ref_tag = ext_pi_ref_tag(rq);\n\tstruct bio *bio;\n\n\t__rq_for_each_bio(bio, rq) {\n\t\tstruct bio_integrity_payload *bip = bio_integrity(bio);\n\t\tu64 virt = lower_48_bits(bip_get_seed(bip));\n\t\tstruct bio_vec iv;\n\t\tstruct bvec_iter iter;\n\n\t\t \n\t\tif (bip->bip_flags & BIP_MAPPED_INTEGRITY)\n\t\t\tbreak;\n\n\t\tbip_for_each_vec(iv, bip, iter) {\n\t\t\tunsigned int j;\n\t\t\tvoid *p;\n\n\t\t\tp = bvec_kmap_local(&iv);\n\t\t\tfor (j = 0; j < iv.bv_len; j += tuple_sz) {\n\t\t\t\tstruct crc64_pi_tuple *pi = p;\n\t\t\t\tu64 ref = get_unaligned_be48(pi->ref_tag);\n\n\t\t\t\tif (ref == virt)\n\t\t\t\t\tput_unaligned_be48(ref_tag, pi->ref_tag);\n\t\t\t\tvirt++;\n\t\t\t\tref_tag++;\n\t\t\t\tp += tuple_sz;\n\t\t\t}\n\t\t\tkunmap_local(p);\n\t\t}\n\n\t\tbip->bip_flags |= BIP_MAPPED_INTEGRITY;\n\t}\n}\n\nstatic void ext_pi_type1_complete(struct request *rq, unsigned int nr_bytes)\n{\n\tunsigned intervals = nr_bytes >> rq->q->integrity.interval_exp;\n\tconst int tuple_sz = rq->q->integrity.tuple_size;\n\tu64 ref_tag = ext_pi_ref_tag(rq);\n\tstruct bio *bio;\n\n\t__rq_for_each_bio(bio, rq) {\n\t\tstruct bio_integrity_payload *bip = bio_integrity(bio);\n\t\tu64 virt = lower_48_bits(bip_get_seed(bip));\n\t\tstruct bio_vec iv;\n\t\tstruct bvec_iter iter;\n\n\t\tbip_for_each_vec(iv, bip, iter) {\n\t\t\tunsigned int j;\n\t\t\tvoid *p;\n\n\t\t\tp = bvec_kmap_local(&iv);\n\t\t\tfor (j = 0; j < iv.bv_len && intervals; j += tuple_sz) {\n\t\t\t\tstruct crc64_pi_tuple *pi = p;\n\t\t\t\tu64 ref = get_unaligned_be48(pi->ref_tag);\n\n\t\t\t\tif (ref == ref_tag)\n\t\t\t\t\tput_unaligned_be48(virt, pi->ref_tag);\n\t\t\t\tvirt++;\n\t\t\t\tref_tag++;\n\t\t\t\tintervals--;\n\t\t\t\tp += tuple_sz;\n\t\t\t}\n\t\t\tkunmap_local(p);\n\t\t}\n\t}\n}\n\nstatic blk_status_t ext_pi_type3_verify_crc64(struct blk_integrity_iter *iter)\n{\n\treturn ext_pi_crc64_verify(iter, T10_PI_TYPE3_PROTECTION);\n}\n\nstatic blk_status_t ext_pi_type3_generate_crc64(struct blk_integrity_iter *iter)\n{\n\treturn ext_pi_crc64_generate(iter, T10_PI_TYPE3_PROTECTION);\n}\n\nconst struct blk_integrity_profile ext_pi_type1_crc64 = {\n\t.name\t\t\t= \"EXT-DIF-TYPE1-CRC64\",\n\t.generate_fn\t\t= ext_pi_type1_generate_crc64,\n\t.verify_fn\t\t= ext_pi_type1_verify_crc64,\n\t.prepare_fn\t\t= ext_pi_type1_prepare,\n\t.complete_fn\t\t= ext_pi_type1_complete,\n};\nEXPORT_SYMBOL_GPL(ext_pi_type1_crc64);\n\nconst struct blk_integrity_profile ext_pi_type3_crc64 = {\n\t.name\t\t\t= \"EXT-DIF-TYPE3-CRC64\",\n\t.generate_fn\t\t= ext_pi_type3_generate_crc64,\n\t.verify_fn\t\t= ext_pi_type3_verify_crc64,\n\t.prepare_fn\t\t= t10_pi_type3_prepare,\n\t.complete_fn\t\t= t10_pi_type3_complete,\n};\nEXPORT_SYMBOL_GPL(ext_pi_type3_crc64);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}