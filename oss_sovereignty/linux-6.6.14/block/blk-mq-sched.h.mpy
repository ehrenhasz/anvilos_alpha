{
  "module_name": "blk-mq-sched.h",
  "hash_id": "9ce544a78affcc10a8feccd99b489d25dd2f894b1d8c4d8f4d06aa2be31ba02d",
  "original_prompt": "Ingested from linux-6.6.14/block/blk-mq-sched.h",
  "human_readable_source": " \n#ifndef BLK_MQ_SCHED_H\n#define BLK_MQ_SCHED_H\n\n#include \"elevator.h\"\n#include \"blk-mq.h\"\n\n#define MAX_SCHED_RQ (16 * BLKDEV_DEFAULT_RQ)\n\nbool blk_mq_sched_try_merge(struct request_queue *q, struct bio *bio,\n\t\tunsigned int nr_segs, struct request **merged_request);\nbool blk_mq_sched_bio_merge(struct request_queue *q, struct bio *bio,\n\t\tunsigned int nr_segs);\nbool blk_mq_sched_try_insert_merge(struct request_queue *q, struct request *rq,\n\t\t\t\t   struct list_head *free);\nvoid blk_mq_sched_mark_restart_hctx(struct blk_mq_hw_ctx *hctx);\nvoid __blk_mq_sched_restart(struct blk_mq_hw_ctx *hctx);\n\nvoid blk_mq_sched_dispatch_requests(struct blk_mq_hw_ctx *hctx);\n\nint blk_mq_init_sched(struct request_queue *q, struct elevator_type *e);\nvoid blk_mq_exit_sched(struct request_queue *q, struct elevator_queue *e);\nvoid blk_mq_sched_free_rqs(struct request_queue *q);\n\nstatic inline void blk_mq_sched_restart(struct blk_mq_hw_ctx *hctx)\n{\n\tif (test_bit(BLK_MQ_S_SCHED_RESTART, &hctx->state))\n\t\t__blk_mq_sched_restart(hctx);\n}\n\nstatic inline bool bio_mergeable(struct bio *bio)\n{\n\treturn !(bio->bi_opf & REQ_NOMERGE_FLAGS);\n}\n\nstatic inline bool\nblk_mq_sched_allow_merge(struct request_queue *q, struct request *rq,\n\t\t\t struct bio *bio)\n{\n\tif (rq->rq_flags & RQF_USE_SCHED) {\n\t\tstruct elevator_queue *e = q->elevator;\n\n\t\tif (e->type->ops.allow_merge)\n\t\t\treturn e->type->ops.allow_merge(q, rq, bio);\n\t}\n\treturn true;\n}\n\nstatic inline void blk_mq_sched_completed_request(struct request *rq, u64 now)\n{\n\tif (rq->rq_flags & RQF_USE_SCHED) {\n\t\tstruct elevator_queue *e = rq->q->elevator;\n\n\t\tif (e->type->ops.completed_request)\n\t\t\te->type->ops.completed_request(rq, now);\n\t}\n}\n\nstatic inline void blk_mq_sched_requeue_request(struct request *rq)\n{\n\tif (rq->rq_flags & RQF_USE_SCHED) {\n\t\tstruct request_queue *q = rq->q;\n\t\tstruct elevator_queue *e = q->elevator;\n\n\t\tif (e->type->ops.requeue_request)\n\t\t\te->type->ops.requeue_request(rq);\n\t}\n}\n\nstatic inline bool blk_mq_sched_has_work(struct blk_mq_hw_ctx *hctx)\n{\n\tstruct elevator_queue *e = hctx->queue->elevator;\n\n\tif (e && e->type->ops.has_work)\n\t\treturn e->type->ops.has_work(hctx);\n\n\treturn false;\n}\n\nstatic inline bool blk_mq_sched_needs_restart(struct blk_mq_hw_ctx *hctx)\n{\n\treturn test_bit(BLK_MQ_S_SCHED_RESTART, &hctx->state);\n}\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}