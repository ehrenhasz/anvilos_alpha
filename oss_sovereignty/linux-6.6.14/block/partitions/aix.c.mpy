{
  "module_name": "aix.c",
  "hash_id": "82527466144f19246fc55f04c3ae3f7ddd4255f969e6c970b751c260f3d68043",
  "original_prompt": "Ingested from linux-6.6.14/block/partitions/aix.c",
  "human_readable_source": "\n \n\n#include \"check.h\"\n\nstruct lvm_rec {\n\tchar lvm_id[4];  \n\tchar reserved4[16];\n\t__be32 lvmarea_len;\n\t__be32 vgda_len;\n\t__be32 vgda_psn[2];\n\tchar reserved36[10];\n\t__be16 pp_size;  \n\tchar reserved46[12];\n\t__be16 version;\n\t};\n\nstruct vgda {\n\t__be32 secs;\n\t__be32 usec;\n\tchar reserved8[16];\n\t__be16 numlvs;\n\t__be16 maxlvs;\n\t__be16 pp_size;\n\t__be16 numpvs;\n\t__be16 total_vgdas;\n\t__be16 vgda_size;\n\t};\n\nstruct lvd {\n\t__be16 lv_ix;\n\t__be16 res2;\n\t__be16 res4;\n\t__be16 maxsize;\n\t__be16 lv_state;\n\t__be16 mirror;\n\t__be16 mirror_policy;\n\t__be16 num_lps;\n\t__be16 res10[8];\n\t};\n\nstruct lvname {\n\tchar name[64];\n\t};\n\nstruct ppe {\n\t__be16 lv_ix;\n\tunsigned short res2;\n\tunsigned short res4;\n\t__be16 lp_ix;\n\tunsigned short res8[12];\n\t};\n\nstruct pvd {\n\tchar reserved0[16];\n\t__be16 pp_count;\n\tchar reserved18[2];\n\t__be32 psn_part1;\n\tchar reserved24[8];\n\tstruct ppe ppe[1016];\n\t};\n\n#define LVM_MAXLVS 256\n\n \nstatic size_t read_lba(struct parsed_partitions *state, u64 lba, u8 *buffer,\n\t\t\tsize_t count)\n{\n\tsize_t totalreadcount = 0;\n\n\tif (!buffer || lba + count / 512 > get_capacity(state->disk) - 1ULL)\n\t\treturn 0;\n\n\twhile (count) {\n\t\tint copied = 512;\n\t\tSector sect;\n\t\tunsigned char *data = read_part_sector(state, lba++, &sect);\n\t\tif (!data)\n\t\t\tbreak;\n\t\tif (copied > count)\n\t\t\tcopied = count;\n\t\tmemcpy(buffer, data, copied);\n\t\tput_dev_sector(sect);\n\t\tbuffer += copied;\n\t\ttotalreadcount += copied;\n\t\tcount -= copied;\n\t}\n\treturn totalreadcount;\n}\n\n \nstatic struct pvd *alloc_pvd(struct parsed_partitions *state, u32 lba)\n{\n\tsize_t count = sizeof(struct pvd);\n\tstruct pvd *p;\n\n\tp = kmalloc(count, GFP_KERNEL);\n\tif (!p)\n\t\treturn NULL;\n\n\tif (read_lba(state, lba, (u8 *) p, count) < count) {\n\t\tkfree(p);\n\t\treturn NULL;\n\t}\n\treturn p;\n}\n\n \nstatic struct lvname *alloc_lvn(struct parsed_partitions *state, u32 lba)\n{\n\tsize_t count = sizeof(struct lvname) * LVM_MAXLVS;\n\tstruct lvname *p;\n\n\tp = kmalloc(count, GFP_KERNEL);\n\tif (!p)\n\t\treturn NULL;\n\n\tif (read_lba(state, lba, (u8 *) p, count) < count) {\n\t\tkfree(p);\n\t\treturn NULL;\n\t}\n\treturn p;\n}\n\nint aix_partition(struct parsed_partitions *state)\n{\n\tint ret = 0;\n\tSector sect;\n\tunsigned char *d;\n\tu32 pp_bytes_size;\n\tu32 pp_blocks_size = 0;\n\tu32 vgda_sector = 0;\n\tu32 vgda_len = 0;\n\tint numlvs = 0;\n\tstruct pvd *pvd = NULL;\n\tstruct lv_info {\n\t\tunsigned short pps_per_lv;\n\t\tunsigned short pps_found;\n\t\tunsigned char lv_is_contiguous;\n\t} *lvip;\n\tstruct lvname *n = NULL;\n\n\td = read_part_sector(state, 7, &sect);\n\tif (d) {\n\t\tstruct lvm_rec *p = (struct lvm_rec *)d;\n\t\tu16 lvm_version = be16_to_cpu(p->version);\n\t\tchar tmp[64];\n\n\t\tif (lvm_version == 1) {\n\t\t\tint pp_size_log2 = be16_to_cpu(p->pp_size);\n\n\t\t\tpp_bytes_size = 1 << pp_size_log2;\n\t\t\tpp_blocks_size = pp_bytes_size / 512;\n\t\t\tsnprintf(tmp, sizeof(tmp),\n\t\t\t\t\" AIX LVM header version %u found\\n\",\n\t\t\t\tlvm_version);\n\t\t\tvgda_len = be32_to_cpu(p->vgda_len);\n\t\t\tvgda_sector = be32_to_cpu(p->vgda_psn[0]);\n\t\t} else {\n\t\t\tsnprintf(tmp, sizeof(tmp),\n\t\t\t\t\" unsupported AIX LVM version %d found\\n\",\n\t\t\t\tlvm_version);\n\t\t}\n\t\tstrlcat(state->pp_buf, tmp, PAGE_SIZE);\n\t\tput_dev_sector(sect);\n\t}\n\tif (vgda_sector && (d = read_part_sector(state, vgda_sector, &sect))) {\n\t\tstruct vgda *p = (struct vgda *)d;\n\n\t\tnumlvs = be16_to_cpu(p->numlvs);\n\t\tput_dev_sector(sect);\n\t}\n\tlvip = kcalloc(state->limit, sizeof(struct lv_info), GFP_KERNEL);\n\tif (!lvip)\n\t\treturn 0;\n\tif (numlvs && (d = read_part_sector(state, vgda_sector + 1, &sect))) {\n\t\tstruct lvd *p = (struct lvd *)d;\n\t\tint i;\n\n\t\tn = alloc_lvn(state, vgda_sector + vgda_len - 33);\n\t\tif (n) {\n\t\t\tint foundlvs = 0;\n\n\t\t\tfor (i = 0; foundlvs < numlvs && i < state->limit; i += 1) {\n\t\t\t\tlvip[i].pps_per_lv = be16_to_cpu(p[i].num_lps);\n\t\t\t\tif (lvip[i].pps_per_lv)\n\t\t\t\t\tfoundlvs += 1;\n\t\t\t}\n\t\t\t \n\t\t\tpvd = alloc_pvd(state, vgda_sector + 17);\n\t\t}\n\t\tput_dev_sector(sect);\n\t}\n\tif (pvd) {\n\t\tint numpps = be16_to_cpu(pvd->pp_count);\n\t\tint psn_part1 = be32_to_cpu(pvd->psn_part1);\n\t\tint i;\n\t\tint cur_lv_ix = -1;\n\t\tint next_lp_ix = 1;\n\t\tint lp_ix;\n\n\t\tfor (i = 0; i < numpps; i += 1) {\n\t\t\tstruct ppe *p = pvd->ppe + i;\n\t\t\tunsigned int lv_ix;\n\n\t\t\tlp_ix = be16_to_cpu(p->lp_ix);\n\t\t\tif (!lp_ix) {\n\t\t\t\tnext_lp_ix = 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tlv_ix = be16_to_cpu(p->lv_ix) - 1;\n\t\t\tif (lv_ix >= state->limit) {\n\t\t\t\tcur_lv_ix = -1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tlvip[lv_ix].pps_found += 1;\n\t\t\tif (lp_ix == 1) {\n\t\t\t\tcur_lv_ix = lv_ix;\n\t\t\t\tnext_lp_ix = 1;\n\t\t\t} else if (lv_ix != cur_lv_ix || lp_ix != next_lp_ix) {\n\t\t\t\tnext_lp_ix = 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (lp_ix == lvip[lv_ix].pps_per_lv) {\n\t\t\t\tchar tmp[70];\n\n\t\t\t\tput_partition(state, lv_ix + 1,\n\t\t\t\t  (i + 1 - lp_ix) * pp_blocks_size + psn_part1,\n\t\t\t\t  lvip[lv_ix].pps_per_lv * pp_blocks_size);\n\t\t\t\tsnprintf(tmp, sizeof(tmp), \" <%s>\\n\",\n\t\t\t\t\t n[lv_ix].name);\n\t\t\t\tstrlcat(state->pp_buf, tmp, PAGE_SIZE);\n\t\t\t\tlvip[lv_ix].lv_is_contiguous = 1;\n\t\t\t\tret = 1;\n\t\t\t\tnext_lp_ix = 1;\n\t\t\t} else\n\t\t\t\tnext_lp_ix += 1;\n\t\t}\n\t\tfor (i = 0; i < state->limit; i += 1)\n\t\t\tif (lvip[i].pps_found && !lvip[i].lv_is_contiguous) {\n\t\t\t\tchar tmp[sizeof(n[i].name) + 1]; \n\n\t\t\t\tsnprintf(tmp, sizeof(tmp), \"%s\", n[i].name);\n\t\t\t\tpr_warn(\"partition %s (%u pp's found) is \"\n\t\t\t\t\t\"not contiguous\\n\",\n\t\t\t\t\ttmp, lvip[i].pps_found);\n\t\t\t}\n\t\tkfree(pvd);\n\t}\n\tkfree(n);\n\tkfree(lvip);\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}