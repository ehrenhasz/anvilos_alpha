{
  "module_name": "mac.c",
  "hash_id": "98bb4e371194fce3aa285be96c6891fc888a57ad7550747a62fdadf9e4c54c13",
  "original_prompt": "Ingested from linux-6.6.14/block/partitions/mac.c",
  "human_readable_source": "\n \n\n#include <linux/ctype.h>\n#include \"check.h\"\n#include \"mac.h\"\n\n#ifdef CONFIG_PPC_PMAC\n#include <asm/machdep.h>\nextern void note_bootable_part(dev_t dev, int part, int goodness);\n#endif\n\n \n\nstatic inline void mac_fix_string(char *stg, int len)\n{\n\tint i;\n\n\tfor (i = len - 1; i >= 0 && stg[i] == ' '; i--)\n\t\tstg[i] = 0;\n}\n\nint mac_partition(struct parsed_partitions *state)\n{\n\tSector sect;\n\tunsigned char *data;\n\tint slot, blocks_in_map;\n\tunsigned secsize, datasize, partoffset;\n#ifdef CONFIG_PPC_PMAC\n\tint found_root = 0;\n\tint found_root_goodness = 0;\n#endif\n\tstruct mac_partition *part;\n\tstruct mac_driver_desc *md;\n\n\t \n\tmd = read_part_sector(state, 0, &sect);\n\tif (!md)\n\t\treturn -1;\n\tif (be16_to_cpu(md->signature) != MAC_DRIVER_MAGIC) {\n\t\tput_dev_sector(sect);\n\t\treturn 0;\n\t}\n\tsecsize = be16_to_cpu(md->block_size);\n\tput_dev_sector(sect);\n\tdatasize = round_down(secsize, 512);\n\tdata = read_part_sector(state, datasize / 512, &sect);\n\tif (!data)\n\t\treturn -1;\n\tpartoffset = secsize % 512;\n\tif (partoffset + sizeof(*part) > datasize)\n\t\treturn -1;\n\tpart = (struct mac_partition *) (data + partoffset);\n\tif (be16_to_cpu(part->signature) != MAC_PARTITION_MAGIC) {\n\t\tput_dev_sector(sect);\n\t\treturn 0;\t\t \n\t}\n\tblocks_in_map = be32_to_cpu(part->map_count);\n\tif (blocks_in_map < 0 || blocks_in_map >= DISK_MAX_PARTS) {\n\t\tput_dev_sector(sect);\n\t\treturn 0;\n\t}\n\n\tif (blocks_in_map >= state->limit)\n\t\tblocks_in_map = state->limit - 1;\n\n\tstrlcat(state->pp_buf, \" [mac]\", PAGE_SIZE);\n\tfor (slot = 1; slot <= blocks_in_map; ++slot) {\n\t\tint pos = slot * secsize;\n\t\tput_dev_sector(sect);\n\t\tdata = read_part_sector(state, pos/512, &sect);\n\t\tif (!data)\n\t\t\treturn -1;\n\t\tpart = (struct mac_partition *) (data + pos%512);\n\t\tif (be16_to_cpu(part->signature) != MAC_PARTITION_MAGIC)\n\t\t\tbreak;\n\t\tput_partition(state, slot,\n\t\t\tbe32_to_cpu(part->start_block) * (secsize/512),\n\t\t\tbe32_to_cpu(part->block_count) * (secsize/512));\n\n\t\tif (!strncasecmp(part->type, \"Linux_RAID\", 10))\n\t\t\tstate->parts[slot].flags = ADDPART_FLAG_RAID;\n#ifdef CONFIG_PPC_PMAC\n\t\t \n\t\tif (machine_is(powermac)) {\n\t\t\tint goodness = 0;\n\n\t\t\tmac_fix_string(part->processor, 16);\n\t\t\tmac_fix_string(part->name, 32);\n\t\t\tmac_fix_string(part->type, 32);\t\t\t\t\t\n\t\t    \n\t\t\tif ((be32_to_cpu(part->status) & MAC_STATUS_BOOTABLE)\n\t\t\t    && strcasecmp(part->processor, \"powerpc\") == 0)\n\t\t\t\tgoodness++;\n\n\t\t\tif (strcasecmp(part->type, \"Apple_UNIX_SVR2\") == 0\n\t\t\t    || (strncasecmp(part->type, \"Linux\", 5) == 0\n\t\t\t        && strcasecmp(part->type, \"Linux_swap\") != 0)) {\n\t\t\t\tint i, l;\n\n\t\t\t\tgoodness++;\n\t\t\t\tl = strlen(part->name);\n\t\t\t\tif (strcmp(part->name, \"/\") == 0)\n\t\t\t\t\tgoodness++;\n\t\t\t\tfor (i = 0; i <= l - 4; ++i) {\n\t\t\t\t\tif (strncasecmp(part->name + i, \"root\",\n\t\t\t\t\t\t     4) == 0) {\n\t\t\t\t\t\tgoodness += 2;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (strncasecmp(part->name, \"swap\", 4) == 0)\n\t\t\t\t\tgoodness--;\n\t\t\t}\n\n\t\t\tif (goodness > found_root_goodness) {\n\t\t\t\tfound_root = slot;\n\t\t\t\tfound_root_goodness = goodness;\n\t\t\t}\n\t\t}\n#endif  \n\t}\n#ifdef CONFIG_PPC_PMAC\n\tif (found_root_goodness)\n\t\tnote_bootable_part(state->disk->part0->bd_dev, found_root,\n\t\t\t\t   found_root_goodness);\n#endif\n\n\tput_dev_sector(sect);\n\tstrlcat(state->pp_buf, \"\\n\", PAGE_SIZE);\n\treturn 1;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}