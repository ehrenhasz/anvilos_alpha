{
  "module_name": "core.c",
  "hash_id": "bcf987a3169cb06d326fe112745ffe44c8045e3a20349316ae6f4561cc3f2a43",
  "original_prompt": "Ingested from linux-6.6.14/block/partitions/core.c",
  "human_readable_source": "\n \n#include <linux/fs.h>\n#include <linux/major.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/vmalloc.h>\n#include <linux/raid/detect.h>\n#include \"check.h\"\n\nstatic int (*const check_part[])(struct parsed_partitions *) = {\n\t \n#ifdef CONFIG_ACORN_PARTITION_ICS\n\tadfspart_check_ICS,\n#endif\n#ifdef CONFIG_ACORN_PARTITION_POWERTEC\n\tadfspart_check_POWERTEC,\n#endif\n#ifdef CONFIG_ACORN_PARTITION_EESOX\n\tadfspart_check_EESOX,\n#endif\n\n\t \n#ifdef CONFIG_ACORN_PARTITION_CUMANA\n\tadfspart_check_CUMANA,\n#endif\n#ifdef CONFIG_ACORN_PARTITION_ADFS\n\tadfspart_check_ADFS,\n#endif\n\n#ifdef CONFIG_CMDLINE_PARTITION\n\tcmdline_partition,\n#endif\n#ifdef CONFIG_EFI_PARTITION\n\tefi_partition,\t\t \n#endif\n#ifdef CONFIG_SGI_PARTITION\n\tsgi_partition,\n#endif\n#ifdef CONFIG_LDM_PARTITION\n\tldm_partition,\t\t \n#endif\n#ifdef CONFIG_MSDOS_PARTITION\n\tmsdos_partition,\n#endif\n#ifdef CONFIG_OSF_PARTITION\n\tosf_partition,\n#endif\n#ifdef CONFIG_SUN_PARTITION\n\tsun_partition,\n#endif\n#ifdef CONFIG_AMIGA_PARTITION\n\tamiga_partition,\n#endif\n#ifdef CONFIG_ATARI_PARTITION\n\tatari_partition,\n#endif\n#ifdef CONFIG_MAC_PARTITION\n\tmac_partition,\n#endif\n#ifdef CONFIG_ULTRIX_PARTITION\n\tultrix_partition,\n#endif\n#ifdef CONFIG_IBM_PARTITION\n\tibm_partition,\n#endif\n#ifdef CONFIG_KARMA_PARTITION\n\tkarma_partition,\n#endif\n#ifdef CONFIG_SYSV68_PARTITION\n\tsysv68_partition,\n#endif\n\tNULL\n};\n\nstatic struct parsed_partitions *allocate_partitions(struct gendisk *hd)\n{\n\tstruct parsed_partitions *state;\n\tint nr = DISK_MAX_PARTS;\n\n\tstate = kzalloc(sizeof(*state), GFP_KERNEL);\n\tif (!state)\n\t\treturn NULL;\n\n\tstate->parts = vzalloc(array_size(nr, sizeof(state->parts[0])));\n\tif (!state->parts) {\n\t\tkfree(state);\n\t\treturn NULL;\n\t}\n\n\tstate->limit = nr;\n\n\treturn state;\n}\n\nstatic void free_partitions(struct parsed_partitions *state)\n{\n\tvfree(state->parts);\n\tkfree(state);\n}\n\nstatic struct parsed_partitions *check_partition(struct gendisk *hd)\n{\n\tstruct parsed_partitions *state;\n\tint i, res, err;\n\n\tstate = allocate_partitions(hd);\n\tif (!state)\n\t\treturn NULL;\n\tstate->pp_buf = (char *)__get_free_page(GFP_KERNEL);\n\tif (!state->pp_buf) {\n\t\tfree_partitions(state);\n\t\treturn NULL;\n\t}\n\tstate->pp_buf[0] = '\\0';\n\n\tstate->disk = hd;\n\tsnprintf(state->name, BDEVNAME_SIZE, \"%s\", hd->disk_name);\n\tsnprintf(state->pp_buf, PAGE_SIZE, \" %s:\", state->name);\n\tif (isdigit(state->name[strlen(state->name)-1]))\n\t\tsprintf(state->name, \"p\");\n\n\ti = res = err = 0;\n\twhile (!res && check_part[i]) {\n\t\tmemset(state->parts, 0, state->limit * sizeof(state->parts[0]));\n\t\tres = check_part[i++](state);\n\t\tif (res < 0) {\n\t\t\t \n\t\t\terr = res;\n\t\t\tres = 0;\n\t\t}\n\n\t}\n\tif (res > 0) {\n\t\tprintk(KERN_INFO \"%s\", state->pp_buf);\n\n\t\tfree_page((unsigned long)state->pp_buf);\n\t\treturn state;\n\t}\n\tif (state->access_beyond_eod)\n\t\terr = -ENOSPC;\n\t \n\tif (err)\n\t\tres = err;\n\tif (res) {\n\t\tstrlcat(state->pp_buf,\n\t\t\t\" unable to read partition table\\n\", PAGE_SIZE);\n\t\tprintk(KERN_INFO \"%s\", state->pp_buf);\n\t}\n\n\tfree_page((unsigned long)state->pp_buf);\n\tfree_partitions(state);\n\treturn ERR_PTR(res);\n}\n\nstatic ssize_t part_partition_show(struct device *dev,\n\t\t\t\t   struct device_attribute *attr, char *buf)\n{\n\treturn sprintf(buf, \"%d\\n\", dev_to_bdev(dev)->bd_partno);\n}\n\nstatic ssize_t part_start_show(struct device *dev,\n\t\t\t       struct device_attribute *attr, char *buf)\n{\n\treturn sprintf(buf, \"%llu\\n\", dev_to_bdev(dev)->bd_start_sect);\n}\n\nstatic ssize_t part_ro_show(struct device *dev,\n\t\t\t    struct device_attribute *attr, char *buf)\n{\n\treturn sprintf(buf, \"%d\\n\", bdev_read_only(dev_to_bdev(dev)));\n}\n\nstatic ssize_t part_alignment_offset_show(struct device *dev,\n\t\t\t\t\t  struct device_attribute *attr, char *buf)\n{\n\treturn sprintf(buf, \"%u\\n\", bdev_alignment_offset(dev_to_bdev(dev)));\n}\n\nstatic ssize_t part_discard_alignment_show(struct device *dev,\n\t\t\t\t\t   struct device_attribute *attr, char *buf)\n{\n\treturn sprintf(buf, \"%u\\n\", bdev_discard_alignment(dev_to_bdev(dev)));\n}\n\nstatic DEVICE_ATTR(partition, 0444, part_partition_show, NULL);\nstatic DEVICE_ATTR(start, 0444, part_start_show, NULL);\nstatic DEVICE_ATTR(size, 0444, part_size_show, NULL);\nstatic DEVICE_ATTR(ro, 0444, part_ro_show, NULL);\nstatic DEVICE_ATTR(alignment_offset, 0444, part_alignment_offset_show, NULL);\nstatic DEVICE_ATTR(discard_alignment, 0444, part_discard_alignment_show, NULL);\nstatic DEVICE_ATTR(stat, 0444, part_stat_show, NULL);\nstatic DEVICE_ATTR(inflight, 0444, part_inflight_show, NULL);\n#ifdef CONFIG_FAIL_MAKE_REQUEST\nstatic struct device_attribute dev_attr_fail =\n\t__ATTR(make-it-fail, 0644, part_fail_show, part_fail_store);\n#endif\n\nstatic struct attribute *part_attrs[] = {\n\t&dev_attr_partition.attr,\n\t&dev_attr_start.attr,\n\t&dev_attr_size.attr,\n\t&dev_attr_ro.attr,\n\t&dev_attr_alignment_offset.attr,\n\t&dev_attr_discard_alignment.attr,\n\t&dev_attr_stat.attr,\n\t&dev_attr_inflight.attr,\n#ifdef CONFIG_FAIL_MAKE_REQUEST\n\t&dev_attr_fail.attr,\n#endif\n\tNULL\n};\n\nstatic const struct attribute_group part_attr_group = {\n\t.attrs = part_attrs,\n};\n\nstatic const struct attribute_group *part_attr_groups[] = {\n\t&part_attr_group,\n#ifdef CONFIG_BLK_DEV_IO_TRACE\n\t&blk_trace_attr_group,\n#endif\n\tNULL\n};\n\nstatic void part_release(struct device *dev)\n{\n\tput_disk(dev_to_bdev(dev)->bd_disk);\n\tiput(dev_to_bdev(dev)->bd_inode);\n}\n\nstatic int part_uevent(const struct device *dev, struct kobj_uevent_env *env)\n{\n\tconst struct block_device *part = dev_to_bdev(dev);\n\n\tadd_uevent_var(env, \"PARTN=%u\", part->bd_partno);\n\tif (part->bd_meta_info && part->bd_meta_info->volname[0])\n\t\tadd_uevent_var(env, \"PARTNAME=%s\", part->bd_meta_info->volname);\n\treturn 0;\n}\n\nconst struct device_type part_type = {\n\t.name\t\t= \"partition\",\n\t.groups\t\t= part_attr_groups,\n\t.release\t= part_release,\n\t.uevent\t\t= part_uevent,\n};\n\nvoid drop_partition(struct block_device *part)\n{\n\tlockdep_assert_held(&part->bd_disk->open_mutex);\n\n\txa_erase(&part->bd_disk->part_tbl, part->bd_partno);\n\tkobject_put(part->bd_holder_dir);\n\n\tdevice_del(&part->bd_device);\n\tput_device(&part->bd_device);\n}\n\nstatic void delete_partition(struct block_device *part)\n{\n\t \n\tremove_inode_hash(part->bd_inode);\n\tbdev_mark_dead(part, false);\n\tdrop_partition(part);\n}\n\nstatic ssize_t whole_disk_show(struct device *dev,\n\t\t\t       struct device_attribute *attr, char *buf)\n{\n\treturn 0;\n}\nstatic const DEVICE_ATTR(whole_disk, 0444, whole_disk_show, NULL);\n\n \nstatic struct block_device *add_partition(struct gendisk *disk, int partno,\n\t\t\t\tsector_t start, sector_t len, int flags,\n\t\t\t\tstruct partition_meta_info *info)\n{\n\tdev_t devt = MKDEV(0, 0);\n\tstruct device *ddev = disk_to_dev(disk);\n\tstruct device *pdev;\n\tstruct block_device *bdev;\n\tconst char *dname;\n\tint err;\n\n\tlockdep_assert_held(&disk->open_mutex);\n\n\tif (partno >= DISK_MAX_PARTS)\n\t\treturn ERR_PTR(-EINVAL);\n\n\t \n\tswitch (disk->queue->limits.zoned) {\n\tcase BLK_ZONED_HM:\n\t\tpr_warn(\"%s: partitions not supported on host managed zoned block device\\n\",\n\t\t\tdisk->disk_name);\n\t\treturn ERR_PTR(-ENXIO);\n\tcase BLK_ZONED_HA:\n\t\tpr_info(\"%s: disabling host aware zoned block device support due to partitions\\n\",\n\t\t\tdisk->disk_name);\n\t\tdisk_set_zoned(disk, BLK_ZONED_NONE);\n\t\tbreak;\n\tcase BLK_ZONED_NONE:\n\t\tbreak;\n\t}\n\n\tif (xa_load(&disk->part_tbl, partno))\n\t\treturn ERR_PTR(-EBUSY);\n\n\t \n\tget_device(disk_to_dev(disk));\n\n\terr = -ENOMEM;\n\tbdev = bdev_alloc(disk, partno);\n\tif (!bdev)\n\t\tgoto out_put_disk;\n\n\tbdev->bd_start_sect = start;\n\tbdev_set_nr_sectors(bdev, len);\n\n\tpdev = &bdev->bd_device;\n\tdname = dev_name(ddev);\n\tif (isdigit(dname[strlen(dname) - 1]))\n\t\tdev_set_name(pdev, \"%sp%d\", dname, partno);\n\telse\n\t\tdev_set_name(pdev, \"%s%d\", dname, partno);\n\n\tdevice_initialize(pdev);\n\tpdev->class = &block_class;\n\tpdev->type = &part_type;\n\tpdev->parent = ddev;\n\n\t \n\tif (bdev->bd_partno < disk->minors) {\n\t\tdevt = MKDEV(disk->major, disk->first_minor + bdev->bd_partno);\n\t} else {\n\t\terr = blk_alloc_ext_minor();\n\t\tif (err < 0)\n\t\t\tgoto out_put;\n\t\tdevt = MKDEV(BLOCK_EXT_MAJOR, err);\n\t}\n\tpdev->devt = devt;\n\n\tif (info) {\n\t\terr = -ENOMEM;\n\t\tbdev->bd_meta_info = kmemdup(info, sizeof(*info), GFP_KERNEL);\n\t\tif (!bdev->bd_meta_info)\n\t\t\tgoto out_put;\n\t}\n\n\t \n\tdev_set_uevent_suppress(pdev, 1);\n\terr = device_add(pdev);\n\tif (err)\n\t\tgoto out_put;\n\n\terr = -ENOMEM;\n\tbdev->bd_holder_dir = kobject_create_and_add(\"holders\", &pdev->kobj);\n\tif (!bdev->bd_holder_dir)\n\t\tgoto out_del;\n\n\tdev_set_uevent_suppress(pdev, 0);\n\tif (flags & ADDPART_FLAG_WHOLEDISK) {\n\t\terr = device_create_file(pdev, &dev_attr_whole_disk);\n\t\tif (err)\n\t\t\tgoto out_del;\n\t}\n\n\t \n\terr = xa_insert(&disk->part_tbl, partno, bdev, GFP_KERNEL);\n\tif (err)\n\t\tgoto out_del;\n\tbdev_add(bdev, devt);\n\n\t \n\tif (!dev_get_uevent_suppress(ddev))\n\t\tkobject_uevent(&pdev->kobj, KOBJ_ADD);\n\treturn bdev;\n\nout_del:\n\tkobject_put(bdev->bd_holder_dir);\n\tdevice_del(pdev);\nout_put:\n\tput_device(pdev);\n\treturn ERR_PTR(err);\nout_put_disk:\n\tput_disk(disk);\n\treturn ERR_PTR(err);\n}\n\nstatic bool partition_overlaps(struct gendisk *disk, sector_t start,\n\t\tsector_t length, int skip_partno)\n{\n\tstruct block_device *part;\n\tbool overlap = false;\n\tunsigned long idx;\n\n\trcu_read_lock();\n\txa_for_each_start(&disk->part_tbl, idx, part, 1) {\n\t\tif (part->bd_partno != skip_partno &&\n\t\t    start < part->bd_start_sect + bdev_nr_sectors(part) &&\n\t\t    start + length > part->bd_start_sect) {\n\t\t\toverlap = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\treturn overlap;\n}\n\nint bdev_add_partition(struct gendisk *disk, int partno, sector_t start,\n\t\tsector_t length)\n{\n\tsector_t capacity = get_capacity(disk), end;\n\tstruct block_device *part;\n\tint ret;\n\n\tmutex_lock(&disk->open_mutex);\n\tif (check_add_overflow(start, length, &end)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (start >= capacity || end > capacity) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (!disk_live(disk)) {\n\t\tret = -ENXIO;\n\t\tgoto out;\n\t}\n\n\tif (partition_overlaps(disk, start, length, -1)) {\n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tpart = add_partition(disk, partno, start, length,\n\t\t\tADDPART_FLAG_NONE, NULL);\n\tret = PTR_ERR_OR_ZERO(part);\nout:\n\tmutex_unlock(&disk->open_mutex);\n\treturn ret;\n}\n\nint bdev_del_partition(struct gendisk *disk, int partno)\n{\n\tstruct block_device *part = NULL;\n\tint ret = -ENXIO;\n\n\tmutex_lock(&disk->open_mutex);\n\tpart = xa_load(&disk->part_tbl, partno);\n\tif (!part)\n\t\tgoto out_unlock;\n\n\tret = -EBUSY;\n\tif (atomic_read(&part->bd_openers))\n\t\tgoto out_unlock;\n\n\tdelete_partition(part);\n\tret = 0;\nout_unlock:\n\tmutex_unlock(&disk->open_mutex);\n\treturn ret;\n}\n\nint bdev_resize_partition(struct gendisk *disk, int partno, sector_t start,\n\t\tsector_t length)\n{\n\tstruct block_device *part = NULL;\n\tint ret = -ENXIO;\n\n\tmutex_lock(&disk->open_mutex);\n\tpart = xa_load(&disk->part_tbl, partno);\n\tif (!part)\n\t\tgoto out_unlock;\n\n\tret = -EINVAL;\n\tif (start != part->bd_start_sect)\n\t\tgoto out_unlock;\n\n\tret = -EBUSY;\n\tif (partition_overlaps(disk, start, length, partno))\n\t\tgoto out_unlock;\n\n\tbdev_set_nr_sectors(part, length);\n\n\tret = 0;\nout_unlock:\n\tmutex_unlock(&disk->open_mutex);\n\treturn ret;\n}\n\nstatic bool disk_unlock_native_capacity(struct gendisk *disk)\n{\n\tif (!disk->fops->unlock_native_capacity ||\n\t    test_and_set_bit(GD_NATIVE_CAPACITY, &disk->state)) {\n\t\tprintk(KERN_CONT \"truncated\\n\");\n\t\treturn false;\n\t}\n\n\tprintk(KERN_CONT \"enabling native capacity\\n\");\n\tdisk->fops->unlock_native_capacity(disk);\n\treturn true;\n}\n\nstatic bool blk_add_partition(struct gendisk *disk,\n\t\tstruct parsed_partitions *state, int p)\n{\n\tsector_t size = state->parts[p].size;\n\tsector_t from = state->parts[p].from;\n\tstruct block_device *part;\n\n\tif (!size)\n\t\treturn true;\n\n\tif (from >= get_capacity(disk)) {\n\t\tprintk(KERN_WARNING\n\t\t       \"%s: p%d start %llu is beyond EOD, \",\n\t\t       disk->disk_name, p, (unsigned long long) from);\n\t\tif (disk_unlock_native_capacity(disk))\n\t\t\treturn false;\n\t\treturn true;\n\t}\n\n\tif (from + size > get_capacity(disk)) {\n\t\tprintk(KERN_WARNING\n\t\t       \"%s: p%d size %llu extends beyond EOD, \",\n\t\t       disk->disk_name, p, (unsigned long long) size);\n\n\t\tif (disk_unlock_native_capacity(disk))\n\t\t\treturn false;\n\n\t\t \n\t\tsize = get_capacity(disk) - from;\n\t}\n\n\tpart = add_partition(disk, p, from, size, state->parts[p].flags,\n\t\t\t     &state->parts[p].info);\n\tif (IS_ERR(part) && PTR_ERR(part) != -ENXIO) {\n\t\tprintk(KERN_ERR \" %s: p%d could not be added: %ld\\n\",\n\t\t       disk->disk_name, p, -PTR_ERR(part));\n\t\treturn true;\n\t}\n\n\tif (IS_BUILTIN(CONFIG_BLK_DEV_MD) &&\n\t    (state->parts[p].flags & ADDPART_FLAG_RAID))\n\t\tmd_autodetect_dev(part->bd_dev);\n\n\treturn true;\n}\n\nstatic int blk_add_partitions(struct gendisk *disk)\n{\n\tstruct parsed_partitions *state;\n\tint ret = -EAGAIN, p;\n\n\tif (disk->flags & GENHD_FL_NO_PART)\n\t\treturn 0;\n\n\tif (test_bit(GD_SUPPRESS_PART_SCAN, &disk->state))\n\t\treturn 0;\n\n\tstate = check_partition(disk);\n\tif (!state)\n\t\treturn 0;\n\tif (IS_ERR(state)) {\n\t\t \n\t\tif (PTR_ERR(state) == -ENOSPC) {\n\t\t\tprintk(KERN_WARNING \"%s: partition table beyond EOD, \",\n\t\t\t       disk->disk_name);\n\t\t\tif (disk_unlock_native_capacity(disk))\n\t\t\t\treturn -EAGAIN;\n\t\t}\n\t\treturn -EIO;\n\t}\n\n\t \n\tif (disk->queue->limits.zoned == BLK_ZONED_HM) {\n\t\tpr_warn(\"%s: ignoring partition table on host managed zoned block device\\n\",\n\t\t\tdisk->disk_name);\n\t\tret = 0;\n\t\tgoto out_free_state;\n\t}\n\n\t \n\tif (state->access_beyond_eod) {\n\t\tprintk(KERN_WARNING\n\t\t       \"%s: partition table partially beyond EOD, \",\n\t\t       disk->disk_name);\n\t\tif (disk_unlock_native_capacity(disk))\n\t\t\tgoto out_free_state;\n\t}\n\n\t \n\tkobject_uevent(&disk_to_dev(disk)->kobj, KOBJ_CHANGE);\n\n\tfor (p = 1; p < state->limit; p++)\n\t\tif (!blk_add_partition(disk, state, p))\n\t\t\tgoto out_free_state;\n\n\tret = 0;\nout_free_state:\n\tfree_partitions(state);\n\treturn ret;\n}\n\nint bdev_disk_changed(struct gendisk *disk, bool invalidate)\n{\n\tstruct block_device *part;\n\tunsigned long idx;\n\tint ret = 0;\n\n\tlockdep_assert_held(&disk->open_mutex);\n\n\tif (!disk_live(disk))\n\t\treturn -ENXIO;\n\nrescan:\n\tif (disk->open_partitions)\n\t\treturn -EBUSY;\n\tsync_blockdev(disk->part0);\n\tinvalidate_bdev(disk->part0);\n\n\txa_for_each_start(&disk->part_tbl, idx, part, 1)\n\t\tdelete_partition(part);\n\tclear_bit(GD_NEED_PART_SCAN, &disk->state);\n\n\t \n\tif (invalidate) {\n\t\tif (!(disk->flags & GENHD_FL_NO_PART) ||\n\t\t    !(disk->flags & GENHD_FL_REMOVABLE))\n\t\t\tset_capacity(disk, 0);\n\t}\n\n\tif (get_capacity(disk)) {\n\t\tret = blk_add_partitions(disk);\n\t\tif (ret == -EAGAIN)\n\t\t\tgoto rescan;\n\t} else if (invalidate) {\n\t\t \n\t\tkobject_uevent(&disk_to_dev(disk)->kobj, KOBJ_CHANGE);\n\t}\n\n\treturn ret;\n}\n \nEXPORT_SYMBOL_GPL(bdev_disk_changed);\n\nvoid *read_part_sector(struct parsed_partitions *state, sector_t n, Sector *p)\n{\n\tstruct address_space *mapping = state->disk->part0->bd_inode->i_mapping;\n\tstruct folio *folio;\n\n\tif (n >= get_capacity(state->disk)) {\n\t\tstate->access_beyond_eod = true;\n\t\tgoto out;\n\t}\n\n\tfolio = read_mapping_folio(mapping, n >> PAGE_SECTORS_SHIFT, NULL);\n\tif (IS_ERR(folio))\n\t\tgoto out;\n\n\tp->v = folio;\n\treturn folio_address(folio) + offset_in_folio(folio, n * SECTOR_SIZE);\nout:\n\tp->v = NULL;\n\treturn NULL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}