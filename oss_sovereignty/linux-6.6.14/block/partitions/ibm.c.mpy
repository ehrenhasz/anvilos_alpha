{
  "module_name": "ibm.c",
  "hash_id": "7f1cee5e05f239a931d5ffcf708185d8380cc8262bc18123e4a482032dda2e16",
  "original_prompt": "Ingested from linux-6.6.14/block/partitions/ibm.c",
  "human_readable_source": "\n \n\n#include <linux/buffer_head.h>\n#include <linux/hdreg.h>\n#include <linux/slab.h>\n#include <asm/dasd.h>\n#include <asm/ebcdic.h>\n#include <linux/uaccess.h>\n#include <asm/vtoc.h>\n#include <linux/module.h>\n#include <linux/dasd_mod.h>\n\n#include \"check.h\"\n\nunion label_t {\n\tstruct vtoc_volume_label_cdl vol;\n\tstruct vtoc_volume_label_ldl lnx;\n\tstruct vtoc_cms_label cms;\n};\n\n \nstatic sector_t cchh2blk(struct vtoc_cchh *ptr, struct hd_geometry *geo)\n{\n\tsector_t cyl;\n\t__u16 head;\n\n\t \n\tcyl = ptr->hh & 0xFFF0;\n\tcyl <<= 12;\n\tcyl |= ptr->cc;\n\thead = ptr->hh & 0x000F;\n\treturn cyl * geo->heads * geo->sectors +\n\t       head * geo->sectors;\n}\n\n \nstatic sector_t cchhb2blk(struct vtoc_cchhb *ptr, struct hd_geometry *geo)\n{\n\tsector_t cyl;\n\t__u16 head;\n\n\t \n\tcyl = ptr->hh & 0xFFF0;\n\tcyl <<= 12;\n\tcyl |= ptr->cc;\n\thead = ptr->hh & 0x000F;\n\treturn\tcyl * geo->heads * geo->sectors +\n\t\thead * geo->sectors +\n\t\tptr->b;\n}\n\nstatic int find_label(struct parsed_partitions *state,\n\t\t      dasd_information2_t *info,\n\t\t      struct hd_geometry *geo,\n\t\t      int blocksize,\n\t\t      sector_t *labelsect,\n\t\t      char name[],\n\t\t      char type[],\n\t\t      union label_t *label)\n{\n\tSector sect;\n\tunsigned char *data;\n\tsector_t testsect[3];\n\tunsigned char temp[5];\n\tint found = 0;\n\tint i, testcount;\n\n\t \n\tif (info) {\n\t\tif ((info->cu_type == 0x6310 && info->dev_type == 0x9336) ||\n\t\t    (info->cu_type == 0x3880 && info->dev_type == 0x3370))\n\t\t\ttestsect[0] = info->label_block;\n\t\telse\n\t\t\ttestsect[0] = info->label_block * (blocksize >> 9);\n\t\ttestcount = 1;\n\t} else {\n\t\ttestsect[0] = 1;\n\t\ttestsect[1] = (blocksize >> 9);\n\t\ttestsect[2] = 2 * (blocksize >> 9);\n\t\ttestcount = 3;\n\t}\n\tfor (i = 0; i < testcount; ++i) {\n\t\tdata = read_part_sector(state, testsect[i], &sect);\n\t\tif (data == NULL)\n\t\t\tcontinue;\n\t\tmemcpy(label, data, sizeof(*label));\n\t\tmemcpy(temp, data, 4);\n\t\ttemp[4] = 0;\n\t\tEBCASC(temp, 4);\n\t\tput_dev_sector(sect);\n\t\tif (!strcmp(temp, \"VOL1\") ||\n\t\t    !strcmp(temp, \"LNX1\") ||\n\t\t    !strcmp(temp, \"CMS1\")) {\n\t\t\tif (!strcmp(temp, \"VOL1\")) {\n\t\t\t\tstrncpy(type, label->vol.vollbl, 4);\n\t\t\t\tstrncpy(name, label->vol.volid, 6);\n\t\t\t} else {\n\t\t\t\tstrncpy(type, label->lnx.vollbl, 4);\n\t\t\t\tstrncpy(name, label->lnx.volid, 6);\n\t\t\t}\n\t\t\tEBCASC(type, 4);\n\t\t\tEBCASC(name, 6);\n\t\t\t*labelsect = testsect[i];\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!found)\n\t\tmemset(label, 0, sizeof(*label));\n\n\treturn found;\n}\n\nstatic int find_vol1_partitions(struct parsed_partitions *state,\n\t\t\t\tstruct hd_geometry *geo,\n\t\t\t\tint blocksize,\n\t\t\t\tchar name[],\n\t\t\t\tunion label_t *label)\n{\n\tsector_t blk;\n\tint counter;\n\tchar tmp[64];\n\tSector sect;\n\tunsigned char *data;\n\tloff_t offset, size;\n\tstruct vtoc_format1_label f1;\n\tint secperblk;\n\n\tsnprintf(tmp, sizeof(tmp), \"VOL1/%8s:\", name);\n\tstrlcat(state->pp_buf, tmp, PAGE_SIZE);\n\t \n\tsecperblk = blocksize >> 9;\n\tblk = cchhb2blk(&label->vol.vtoc, geo) + 1;\n\tcounter = 0;\n\tdata = read_part_sector(state, blk * secperblk, &sect);\n\twhile (data != NULL) {\n\t\tmemcpy(&f1, data, sizeof(struct vtoc_format1_label));\n\t\tput_dev_sector(sect);\n\t\t \n\t\tif (f1.DS1FMTID == _ascebc['4']\n\t\t    || f1.DS1FMTID == _ascebc['5']\n\t\t    || f1.DS1FMTID == _ascebc['7']\n\t\t    || f1.DS1FMTID == _ascebc['9']) {\n\t\t\tblk++;\n\t\t\tdata = read_part_sector(state, blk * secperblk, &sect);\n\t\t\tcontinue;\n\t\t}\n\t\t \n\t\tif (f1.DS1FMTID != _ascebc['1'] &&\n\t\t    f1.DS1FMTID != _ascebc['8'])\n\t\t\tbreak;\n\t\t \n\t\toffset = cchh2blk(&f1.DS1EXT1.llimit, geo);\n\t\tsize  = cchh2blk(&f1.DS1EXT1.ulimit, geo) -\n\t\t\toffset + geo->sectors;\n\t\toffset *= secperblk;\n\t\tsize *= secperblk;\n\t\tif (counter >= state->limit)\n\t\t\tbreak;\n\t\tput_partition(state, counter + 1, offset, size);\n\t\tcounter++;\n\t\tblk++;\n\t\tdata = read_part_sector(state, blk * secperblk, &sect);\n\t}\n\tstrlcat(state->pp_buf, \"\\n\", PAGE_SIZE);\n\n\tif (!data)\n\t\treturn -1;\n\n\treturn 1;\n}\n\nstatic int find_lnx1_partitions(struct parsed_partitions *state,\n\t\t\t\tstruct hd_geometry *geo,\n\t\t\t\tint blocksize,\n\t\t\t\tchar name[],\n\t\t\t\tunion label_t *label,\n\t\t\t\tsector_t labelsect,\n\t\t\t\tsector_t nr_sectors,\n\t\t\t\tdasd_information2_t *info)\n{\n\tloff_t offset, geo_size, size;\n\tchar tmp[64];\n\tint secperblk;\n\n\tsnprintf(tmp, sizeof(tmp), \"LNX1/%8s:\", name);\n\tstrlcat(state->pp_buf, tmp, PAGE_SIZE);\n\tsecperblk = blocksize >> 9;\n\tif (label->lnx.ldl_version == 0xf2) {\n\t\tsize = label->lnx.formatted_blocks * secperblk;\n\t} else {\n\t\t \n\t\tgeo_size = geo->cylinders * geo->heads\n\t\t\t* geo->sectors * secperblk;\n\t\tsize = nr_sectors;\n\t\tif (size != geo_size) {\n\t\t\tif (!info) {\n\t\t\t\tstrlcat(state->pp_buf, \"\\n\", PAGE_SIZE);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tif (!strcmp(info->type, \"ECKD\"))\n\t\t\t\tif (geo_size < size)\n\t\t\t\t\tsize = geo_size;\n\t\t\t \n\t\t}\n\t}\n\t \n\toffset = labelsect + secperblk;\n\tput_partition(state, 1, offset, size - offset);\n\tstrlcat(state->pp_buf, \"\\n\", PAGE_SIZE);\n\treturn 1;\n}\n\nstatic int find_cms1_partitions(struct parsed_partitions *state,\n\t\t\t\tstruct hd_geometry *geo,\n\t\t\t\tint blocksize,\n\t\t\t\tchar name[],\n\t\t\t\tunion label_t *label,\n\t\t\t\tsector_t labelsect)\n{\n\tloff_t offset, size;\n\tchar tmp[64];\n\tint secperblk;\n\n\t \n\tblocksize = label->cms.block_size;\n\tsecperblk = blocksize >> 9;\n\tif (label->cms.disk_offset != 0) {\n\t\tsnprintf(tmp, sizeof(tmp), \"CMS1/%8s(MDSK):\", name);\n\t\tstrlcat(state->pp_buf, tmp, PAGE_SIZE);\n\t\t \n\t\toffset = label->cms.disk_offset * secperblk;\n\t\tsize = (label->cms.block_count - 1) * secperblk;\n\t} else {\n\t\tsnprintf(tmp, sizeof(tmp), \"CMS1/%8s:\", name);\n\t\tstrlcat(state->pp_buf, tmp, PAGE_SIZE);\n\t\t \n\t\tif (labelsect == 1)\n\t\t\toffset = 2 * secperblk;\n\t\telse\n\t\t\toffset = labelsect + secperblk;\n\t\tsize = label->cms.block_count * secperblk;\n\t}\n\n\tput_partition(state, 1, offset, size-offset);\n\tstrlcat(state->pp_buf, \"\\n\", PAGE_SIZE);\n\treturn 1;\n}\n\n\n \nint ibm_partition(struct parsed_partitions *state)\n{\n\tint (*fn)(struct gendisk *disk, dasd_information2_t *info);\n\tstruct gendisk *disk = state->disk;\n\tstruct block_device *bdev = disk->part0;\n\tint blocksize, res;\n\tloff_t offset, size;\n\tsector_t nr_sectors;\n\tdasd_information2_t *info;\n\tstruct hd_geometry *geo;\n\tchar type[5] = {0,};\n\tchar name[7] = {0,};\n\tsector_t labelsect;\n\tunion label_t *label;\n\n\tres = 0;\n\tif (!disk->fops->getgeo)\n\t\tgoto out_exit;\n\tfn = symbol_get(dasd_biodasdinfo);\n\tblocksize = bdev_logical_block_size(bdev);\n\tif (blocksize <= 0)\n\t\tgoto out_symbol;\n\tnr_sectors = bdev_nr_sectors(bdev);\n\tif (nr_sectors == 0)\n\t\tgoto out_symbol;\n\tinfo = kmalloc(sizeof(dasd_information2_t), GFP_KERNEL);\n\tif (info == NULL)\n\t\tgoto out_symbol;\n\tgeo = kmalloc(sizeof(struct hd_geometry), GFP_KERNEL);\n\tif (geo == NULL)\n\t\tgoto out_nogeo;\n\tlabel = kmalloc(sizeof(union label_t), GFP_KERNEL);\n\tif (label == NULL)\n\t\tgoto out_nolab;\n\t \n\tgeo->start = get_start_sect(bdev);\n\tif (disk->fops->getgeo(bdev, geo))\n\t\tgoto out_freeall;\n\tif (!fn || fn(disk, info)) {\n\t\tkfree(info);\n\t\tinfo = NULL;\n\t}\n\n\tif (find_label(state, info, geo, blocksize, &labelsect, name, type,\n\t\t       label)) {\n\t\tif (!strncmp(type, \"VOL1\", 4)) {\n\t\t\tres = find_vol1_partitions(state, geo, blocksize, name,\n\t\t\t\t\t\t   label);\n\t\t} else if (!strncmp(type, \"LNX1\", 4)) {\n\t\t\tres = find_lnx1_partitions(state, geo, blocksize, name,\n\t\t\t\t\t\t   label, labelsect, nr_sectors,\n\t\t\t\t\t\t   info);\n\t\t} else if (!strncmp(type, \"CMS1\", 4)) {\n\t\t\tres = find_cms1_partitions(state, geo, blocksize, name,\n\t\t\t\t\t\t   label, labelsect);\n\t\t}\n\t} else if (info) {\n\t\t \n\t\tres = 1;\n\t\tif (info->format == DASD_FORMAT_LDL) {\n\t\t\tstrlcat(state->pp_buf, \"(nonl)\", PAGE_SIZE);\n\t\t\tsize = nr_sectors;\n\t\t\toffset = (info->label_block + 1) * (blocksize >> 9);\n\t\t\tput_partition(state, 1, offset, size-offset);\n\t\t\tstrlcat(state->pp_buf, \"\\n\", PAGE_SIZE);\n\t\t}\n\t} else\n\t\tres = 0;\n\nout_freeall:\n\tkfree(label);\nout_nolab:\n\tkfree(geo);\nout_nogeo:\n\tkfree(info);\nout_symbol:\n\tif (fn)\n\t\tsymbol_put(dasd_biodasdinfo);\nout_exit:\n\treturn res;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}