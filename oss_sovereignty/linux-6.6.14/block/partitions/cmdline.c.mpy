{
  "module_name": "cmdline.c",
  "hash_id": "d91be2d8cd92e13d7c2e7e187645816d54ea98085f37a997f6b61d8575752c79",
  "original_prompt": "Ingested from linux-6.6.14/block/partitions/cmdline.c",
  "human_readable_source": "\n \n#include <linux/blkdev.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include \"check.h\"\n\n\n \n#define PF_RDONLY                   0x01  \n#define PF_POWERUP_LOCK             0x02  \n\nstruct cmdline_subpart {\n\tchar name[BDEVNAME_SIZE];  \n\tsector_t from;\n\tsector_t size;\n\tint flags;\n\tstruct cmdline_subpart *next_subpart;\n};\n\nstruct cmdline_parts {\n\tchar name[BDEVNAME_SIZE];  \n\tunsigned int nr_subparts;\n\tstruct cmdline_subpart *subpart;\n\tstruct cmdline_parts *next_parts;\n};\n\nstatic int parse_subpart(struct cmdline_subpart **subpart, char *partdef)\n{\n\tint ret = 0;\n\tstruct cmdline_subpart *new_subpart;\n\n\t*subpart = NULL;\n\n\tnew_subpart = kzalloc(sizeof(struct cmdline_subpart), GFP_KERNEL);\n\tif (!new_subpart)\n\t\treturn -ENOMEM;\n\n\tif (*partdef == '-') {\n\t\tnew_subpart->size = (sector_t)(~0ULL);\n\t\tpartdef++;\n\t} else {\n\t\tnew_subpart->size = (sector_t)memparse(partdef, &partdef);\n\t\tif (new_subpart->size < (sector_t)PAGE_SIZE) {\n\t\t\tpr_warn(\"cmdline partition size is invalid.\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\tif (*partdef == '@') {\n\t\tpartdef++;\n\t\tnew_subpart->from = (sector_t)memparse(partdef, &partdef);\n\t} else {\n\t\tnew_subpart->from = (sector_t)(~0ULL);\n\t}\n\n\tif (*partdef == '(') {\n\t\tint length;\n\t\tchar *next = strchr(++partdef, ')');\n\n\t\tif (!next) {\n\t\t\tpr_warn(\"cmdline partition format is invalid.\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto fail;\n\t\t}\n\n\t\tlength = min_t(int, next - partdef,\n\t\t\t       sizeof(new_subpart->name) - 1);\n\t\tstrscpy(new_subpart->name, partdef, length);\n\n\t\tpartdef = ++next;\n\t} else\n\t\tnew_subpart->name[0] = '\\0';\n\n\tnew_subpart->flags = 0;\n\n\tif (!strncmp(partdef, \"ro\", 2)) {\n\t\tnew_subpart->flags |= PF_RDONLY;\n\t\tpartdef += 2;\n\t}\n\n\tif (!strncmp(partdef, \"lk\", 2)) {\n\t\tnew_subpart->flags |= PF_POWERUP_LOCK;\n\t\tpartdef += 2;\n\t}\n\n\t*subpart = new_subpart;\n\treturn 0;\nfail:\n\tkfree(new_subpart);\n\treturn ret;\n}\n\nstatic void free_subpart(struct cmdline_parts *parts)\n{\n\tstruct cmdline_subpart *subpart;\n\n\twhile (parts->subpart) {\n\t\tsubpart = parts->subpart;\n\t\tparts->subpart = subpart->next_subpart;\n\t\tkfree(subpart);\n\t}\n}\n\nstatic int parse_parts(struct cmdline_parts **parts, const char *bdevdef)\n{\n\tint ret = -EINVAL;\n\tchar *next;\n\tint length;\n\tstruct cmdline_subpart **next_subpart;\n\tstruct cmdline_parts *newparts;\n\tchar buf[BDEVNAME_SIZE + 32 + 4];\n\n\t*parts = NULL;\n\n\tnewparts = kzalloc(sizeof(struct cmdline_parts), GFP_KERNEL);\n\tif (!newparts)\n\t\treturn -ENOMEM;\n\n\tnext = strchr(bdevdef, ':');\n\tif (!next) {\n\t\tpr_warn(\"cmdline partition has no block device.\");\n\t\tgoto fail;\n\t}\n\n\tlength = min_t(int, next - bdevdef, sizeof(newparts->name) - 1);\n\tstrscpy(newparts->name, bdevdef, length);\n\tnewparts->nr_subparts = 0;\n\n\tnext_subpart = &newparts->subpart;\n\n\twhile (next && *(++next)) {\n\t\tbdevdef = next;\n\t\tnext = strchr(bdevdef, ',');\n\n\t\tlength = (!next) ? (sizeof(buf) - 1) :\n\t\t\tmin_t(int, next - bdevdef, sizeof(buf) - 1);\n\n\t\tstrscpy(buf, bdevdef, length);\n\n\t\tret = parse_subpart(next_subpart, buf);\n\t\tif (ret)\n\t\t\tgoto fail;\n\n\t\tnewparts->nr_subparts++;\n\t\tnext_subpart = &(*next_subpart)->next_subpart;\n\t}\n\n\tif (!newparts->subpart) {\n\t\tpr_warn(\"cmdline partition has no valid partition.\");\n\t\tret = -EINVAL;\n\t\tgoto fail;\n\t}\n\n\t*parts = newparts;\n\n\treturn 0;\nfail:\n\tfree_subpart(newparts);\n\tkfree(newparts);\n\treturn ret;\n}\n\nstatic void cmdline_parts_free(struct cmdline_parts **parts)\n{\n\tstruct cmdline_parts *next_parts;\n\n\twhile (*parts) {\n\t\tnext_parts = (*parts)->next_parts;\n\t\tfree_subpart(*parts);\n\t\tkfree(*parts);\n\t\t*parts = next_parts;\n\t}\n}\n\nstatic int cmdline_parts_parse(struct cmdline_parts **parts,\n\t\tconst char *cmdline)\n{\n\tint ret;\n\tchar *buf;\n\tchar *pbuf;\n\tchar *next;\n\tstruct cmdline_parts **next_parts;\n\n\t*parts = NULL;\n\n\tnext = pbuf = buf = kstrdup(cmdline, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tnext_parts = parts;\n\n\twhile (next && *pbuf) {\n\t\tnext = strchr(pbuf, ';');\n\t\tif (next)\n\t\t\t*next = '\\0';\n\n\t\tret = parse_parts(next_parts, pbuf);\n\t\tif (ret)\n\t\t\tgoto fail;\n\n\t\tif (next)\n\t\t\tpbuf = ++next;\n\n\t\tnext_parts = &(*next_parts)->next_parts;\n\t}\n\n\tif (!*parts) {\n\t\tpr_warn(\"cmdline partition has no valid partition.\");\n\t\tret = -EINVAL;\n\t\tgoto fail;\n\t}\n\n\tret = 0;\ndone:\n\tkfree(buf);\n\treturn ret;\n\nfail:\n\tcmdline_parts_free(parts);\n\tgoto done;\n}\n\nstatic struct cmdline_parts *cmdline_parts_find(struct cmdline_parts *parts,\n\t\t\t\t\t const char *bdev)\n{\n\twhile (parts && strncmp(bdev, parts->name, sizeof(parts->name)))\n\t\tparts = parts->next_parts;\n\treturn parts;\n}\n\nstatic char *cmdline;\nstatic struct cmdline_parts *bdev_parts;\n\nstatic int add_part(int slot, struct cmdline_subpart *subpart,\n\t\tstruct parsed_partitions *state)\n{\n\tint label_min;\n\tstruct partition_meta_info *info;\n\tchar tmp[sizeof(info->volname) + 4];\n\n\tif (slot >= state->limit)\n\t\treturn 1;\n\n\tput_partition(state, slot, subpart->from >> 9,\n\t\t      subpart->size >> 9);\n\n\tinfo = &state->parts[slot].info;\n\n\tlabel_min = min_t(int, sizeof(info->volname) - 1,\n\t\t\t  sizeof(subpart->name));\n\tstrscpy(info->volname, subpart->name, label_min);\n\n\tsnprintf(tmp, sizeof(tmp), \"(%s)\", info->volname);\n\tstrlcat(state->pp_buf, tmp, PAGE_SIZE);\n\n\tstate->parts[slot].has_info = true;\n\n\treturn 0;\n}\n\nstatic int cmdline_parts_set(struct cmdline_parts *parts, sector_t disk_size,\n\t\tstruct parsed_partitions *state)\n{\n\tsector_t from = 0;\n\tstruct cmdline_subpart *subpart;\n\tint slot = 1;\n\n\tfor (subpart = parts->subpart; subpart;\n\t     subpart = subpart->next_subpart, slot++) {\n\t\tif (subpart->from == (sector_t)(~0ULL))\n\t\t\tsubpart->from = from;\n\t\telse\n\t\t\tfrom = subpart->from;\n\n\t\tif (from >= disk_size)\n\t\t\tbreak;\n\n\t\tif (subpart->size > (disk_size - from))\n\t\t\tsubpart->size = disk_size - from;\n\n\t\tfrom += subpart->size;\n\n\t\tif (add_part(slot, subpart, state))\n\t\t\tbreak;\n\t}\n\n\treturn slot;\n}\n\nstatic int __init cmdline_parts_setup(char *s)\n{\n\tcmdline = s;\n\treturn 1;\n}\n__setup(\"blkdevparts=\", cmdline_parts_setup);\n\nstatic bool has_overlaps(sector_t from, sector_t size,\n\t\t\t sector_t from2, sector_t size2)\n{\n\tsector_t end = from + size;\n\tsector_t end2 = from2 + size2;\n\n\tif (from >= from2 && from < end2)\n\t\treturn true;\n\n\tif (end > from2 && end <= end2)\n\t\treturn true;\n\n\tif (from2 >= from && from2 < end)\n\t\treturn true;\n\n\tif (end2 > from && end2 <= end)\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic inline void overlaps_warns_header(void)\n{\n\tpr_warn(\"Overlapping partitions are used in command line partitions.\");\n\tpr_warn(\"Don't use filesystems on overlapping partitions:\");\n}\n\nstatic void cmdline_parts_verifier(int slot, struct parsed_partitions *state)\n{\n\tint i;\n\tbool header = true;\n\n\tfor (; slot < state->limit && state->parts[slot].has_info; slot++) {\n\t\tfor (i = slot+1; i < state->limit && state->parts[i].has_info;\n\t\t     i++) {\n\t\t\tif (has_overlaps(state->parts[slot].from,\n\t\t\t\t\t state->parts[slot].size,\n\t\t\t\t\t state->parts[i].from,\n\t\t\t\t\t state->parts[i].size)) {\n\t\t\t\tif (header) {\n\t\t\t\t\theader = false;\n\t\t\t\t\toverlaps_warns_header();\n\t\t\t\t}\n\t\t\t\tpr_warn(\"%s[%llu,%llu] overlaps with \"\n\t\t\t\t\t\"%s[%llu,%llu].\",\n\t\t\t\t\tstate->parts[slot].info.volname,\n\t\t\t\t\t(u64)state->parts[slot].from << 9,\n\t\t\t\t\t(u64)state->parts[slot].size << 9,\n\t\t\t\t\tstate->parts[i].info.volname,\n\t\t\t\t\t(u64)state->parts[i].from << 9,\n\t\t\t\t\t(u64)state->parts[i].size << 9);\n\t\t\t}\n\t\t}\n\t}\n}\n\n \nint cmdline_partition(struct parsed_partitions *state)\n{\n\tsector_t disk_size;\n\tstruct cmdline_parts *parts;\n\n\tif (cmdline) {\n\t\tif (bdev_parts)\n\t\t\tcmdline_parts_free(&bdev_parts);\n\n\t\tif (cmdline_parts_parse(&bdev_parts, cmdline)) {\n\t\t\tcmdline = NULL;\n\t\t\treturn -1;\n\t\t}\n\t\tcmdline = NULL;\n\t}\n\n\tif (!bdev_parts)\n\t\treturn 0;\n\n\tparts = cmdline_parts_find(bdev_parts, state->disk->disk_name);\n\tif (!parts)\n\t\treturn 0;\n\n\tdisk_size = get_capacity(state->disk) << 9;\n\n\tcmdline_parts_set(parts, disk_size, state);\n\tcmdline_parts_verifier(1, state);\n\n\tstrlcat(state->pp_buf, \"\\n\", PAGE_SIZE);\n\n\treturn 1;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}