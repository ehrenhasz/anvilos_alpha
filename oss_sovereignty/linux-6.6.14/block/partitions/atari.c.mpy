{
  "module_name": "atari.c",
  "hash_id": "1e0fb66d46b7aff6685a37b43942c261d58723277a6beedde96fe35b4cbf144a",
  "original_prompt": "Ingested from linux-6.6.14/block/partitions/atari.c",
  "human_readable_source": "\n \n\n#include <linux/ctype.h>\n#include \"check.h\"\n#include \"atari.h\"\n\n \n#define ICD_PARTS\n\n \n#define\tVALID_PARTITION(pi,hdsiz)\t\t\t\t\t     \\\n    (((pi)->flg & 1) &&\t\t\t\t\t\t\t     \\\n     isalnum((pi)->id[0]) && isalnum((pi)->id[1]) && isalnum((pi)->id[2]) && \\\n     be32_to_cpu((pi)->st) <= (hdsiz) &&\t\t\t\t     \\\n     be32_to_cpu((pi)->st) + be32_to_cpu((pi)->siz) <= (hdsiz))\n\nstatic inline int OK_id(char *s)\n{\n\treturn  memcmp (s, \"GEM\", 3) == 0 || memcmp (s, \"BGM\", 3) == 0 ||\n\t\tmemcmp (s, \"LNX\", 3) == 0 || memcmp (s, \"SWP\", 3) == 0 ||\n\t\tmemcmp (s, \"RAW\", 3) == 0 ;\n}\n\nint atari_partition(struct parsed_partitions *state)\n{\n\tSector sect;\n\tstruct rootsector *rs;\n\tstruct partition_info *pi;\n\tu32 extensect;\n\tu32 hd_size;\n\tint slot;\n#ifdef ICD_PARTS\n\tint part_fmt = 0;  \n#endif\n\n\t \n\tif (queue_logical_block_size(state->disk->queue) != 512)\n\t\treturn 0;\n\n\trs = read_part_sector(state, 0, &sect);\n\tif (!rs)\n\t\treturn -1;\n\n\t \n\thd_size = get_capacity(state->disk);\n\tif (!VALID_PARTITION(&rs->part[0], hd_size) &&\n\t    !VALID_PARTITION(&rs->part[1], hd_size) &&\n\t    !VALID_PARTITION(&rs->part[2], hd_size) &&\n\t    !VALID_PARTITION(&rs->part[3], hd_size)) {\n\t\t \n\t\tput_dev_sector(sect);\n\t\treturn 0;\n\t}\n\n\tpi = &rs->part[0];\n\tstrlcat(state->pp_buf, \" AHDI\", PAGE_SIZE);\n\tfor (slot = 1; pi < &rs->part[4] && slot < state->limit; slot++, pi++) {\n\t\tstruct rootsector *xrs;\n\t\tSector sect2;\n\t\tulong partsect;\n\n\t\tif ( !(pi->flg & 1) )\n\t\t\tcontinue;\n\t\t \n\t\tif (memcmp (pi->id, \"XGM\", 3) != 0) {\n\t\t\t \n\t\t\tput_partition (state, slot, be32_to_cpu(pi->st),\n\t\t\t\t\tbe32_to_cpu(pi->siz));\n\t\t\tcontinue;\n\t\t}\n\t\t \n#ifdef ICD_PARTS\n\t\tpart_fmt = 1;\n#endif\n\t\tstrlcat(state->pp_buf, \" XGM<\", PAGE_SIZE);\n\t\tpartsect = extensect = be32_to_cpu(pi->st);\n\t\twhile (1) {\n\t\t\txrs = read_part_sector(state, partsect, &sect2);\n\t\t\tif (!xrs) {\n\t\t\t\tprintk (\" block %ld read failed\\n\", partsect);\n\t\t\t\tput_dev_sector(sect);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (!(xrs->part[0].flg & 1)) {\n\t\t\t\tprintk( \"\\nFirst sub-partition in extended partition is not valid!\\n\" );\n\t\t\t\tput_dev_sector(sect2);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tput_partition(state, slot,\n\t\t\t\t   partsect + be32_to_cpu(xrs->part[0].st),\n\t\t\t\t   be32_to_cpu(xrs->part[0].siz));\n\n\t\t\tif (!(xrs->part[1].flg & 1)) {\n\t\t\t\t \n\t\t\t\tput_dev_sector(sect2);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (memcmp( xrs->part[1].id, \"XGM\", 3 ) != 0) {\n\t\t\t\tprintk(\"\\nID of extended partition is not XGM!\\n\");\n\t\t\t\tput_dev_sector(sect2);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tpartsect = be32_to_cpu(xrs->part[1].st) + extensect;\n\t\t\tput_dev_sector(sect2);\n\t\t\tif (++slot == state->limit) {\n\t\t\t\tprintk( \"\\nMaximum number of partitions reached!\\n\" );\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tstrlcat(state->pp_buf, \" >\", PAGE_SIZE);\n\t}\n#ifdef ICD_PARTS\n\tif ( part_fmt!=1 ) {  \n\t\tpi = &rs->icdpart[0];\n\t\t \n\t\tif (OK_id(pi->id)) {\n\t\t\tstrlcat(state->pp_buf, \" ICD<\", PAGE_SIZE);\n\t\t\tfor (; pi < &rs->icdpart[8] && slot < state->limit; slot++, pi++) {\n\t\t\t\t \n\t\t\t\tif (!((pi->flg & 1) && OK_id(pi->id)))\n\t\t\t\t\tcontinue;\n\t\t\t\tput_partition (state, slot,\n\t\t\t\t\t\tbe32_to_cpu(pi->st),\n\t\t\t\t\t\tbe32_to_cpu(pi->siz));\n\t\t\t}\n\t\t\tstrlcat(state->pp_buf, \" >\", PAGE_SIZE);\n\t\t}\n\t}\n#endif\n\tput_dev_sector(sect);\n\n\tstrlcat(state->pp_buf, \"\\n\", PAGE_SIZE);\n\n\treturn 1;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}