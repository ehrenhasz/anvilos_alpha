{
  "module_name": "msdos.c",
  "hash_id": "c101642d9b141292cfddd501f150271e6d67b48611474afc42c2849782b4e3ec",
  "original_prompt": "Ingested from linux-6.6.14/block/partitions/msdos.c",
  "human_readable_source": "\n \n#include <linux/msdos_fs.h>\n#include <linux/msdos_partition.h>\n\n#include \"check.h\"\n#include \"efi.h\"\n\n \n#include <asm/unaligned.h>\n\nstatic inline sector_t nr_sects(struct msdos_partition *p)\n{\n\treturn (sector_t)get_unaligned_le32(&p->nr_sects);\n}\n\nstatic inline sector_t start_sect(struct msdos_partition *p)\n{\n\treturn (sector_t)get_unaligned_le32(&p->start_sect);\n}\n\nstatic inline int is_extended_partition(struct msdos_partition *p)\n{\n\treturn (p->sys_ind == DOS_EXTENDED_PARTITION ||\n\t\tp->sys_ind == WIN98_EXTENDED_PARTITION ||\n\t\tp->sys_ind == LINUX_EXTENDED_PARTITION);\n}\n\n#define MSDOS_LABEL_MAGIC1\t0x55\n#define MSDOS_LABEL_MAGIC2\t0xAA\n\nstatic inline int\nmsdos_magic_present(unsigned char *p)\n{\n\treturn (p[0] == MSDOS_LABEL_MAGIC1 && p[1] == MSDOS_LABEL_MAGIC2);\n}\n\n \n#define AIX_LABEL_MAGIC1\t0xC9\n#define AIX_LABEL_MAGIC2\t0xC2\n#define AIX_LABEL_MAGIC3\t0xD4\n#define AIX_LABEL_MAGIC4\t0xC1\nstatic int aix_magic_present(struct parsed_partitions *state, unsigned char *p)\n{\n\tstruct msdos_partition *pt = (struct msdos_partition *) (p + 0x1be);\n\tSector sect;\n\tunsigned char *d;\n\tint slot, ret = 0;\n\n\tif (!(p[0] == AIX_LABEL_MAGIC1 &&\n\t\tp[1] == AIX_LABEL_MAGIC2 &&\n\t\tp[2] == AIX_LABEL_MAGIC3 &&\n\t\tp[3] == AIX_LABEL_MAGIC4))\n\t\treturn 0;\n\n\t \n\tfor (slot = 1; slot <= 4; slot++, pt++) {\n\t\tif (pt->sys_ind == SOLARIS_X86_PARTITION ||\n\t\t    pt->sys_ind == LINUX_RAID_PARTITION ||\n\t\t    pt->sys_ind == LINUX_DATA_PARTITION ||\n\t\t    pt->sys_ind == LINUX_LVM_PARTITION ||\n\t\t    is_extended_partition(pt))\n\t\t\treturn 0;\n\t}\n\td = read_part_sector(state, 7, &sect);\n\tif (d) {\n\t\tif (d[0] == '_' && d[1] == 'L' && d[2] == 'V' && d[3] == 'M')\n\t\t\tret = 1;\n\t\tput_dev_sector(sect);\n\t}\n\treturn ret;\n}\n\nstatic void set_info(struct parsed_partitions *state, int slot,\n\t\t     u32 disksig)\n{\n\tstruct partition_meta_info *info = &state->parts[slot].info;\n\n\tsnprintf(info->uuid, sizeof(info->uuid), \"%08x-%02x\", disksig,\n\t\t slot);\n\tinfo->volname[0] = 0;\n\tstate->parts[slot].has_info = true;\n}\n\n \n\nstatic void parse_extended(struct parsed_partitions *state,\n\t\t\t   sector_t first_sector, sector_t first_size,\n\t\t\t   u32 disksig)\n{\n\tstruct msdos_partition *p;\n\tSector sect;\n\tunsigned char *data;\n\tsector_t this_sector, this_size;\n\tsector_t sector_size;\n\tint loopct = 0;\t\t \n\tint i;\n\n\tsector_size = queue_logical_block_size(state->disk->queue) / 512;\n\tthis_sector = first_sector;\n\tthis_size = first_size;\n\n\twhile (1) {\n\t\tif (++loopct > 100)\n\t\t\treturn;\n\t\tif (state->next == state->limit)\n\t\t\treturn;\n\t\tdata = read_part_sector(state, this_sector, &sect);\n\t\tif (!data)\n\t\t\treturn;\n\n\t\tif (!msdos_magic_present(data + 510))\n\t\t\tgoto done;\n\n\t\tp = (struct msdos_partition *) (data + 0x1be);\n\n\t\t \n\n\t\t \n\t\tfor (i = 0; i < 4; i++, p++) {\n\t\t\tsector_t offs, size, next;\n\n\t\t\tif (!nr_sects(p) || is_extended_partition(p))\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\toffs = start_sect(p)*sector_size;\n\t\t\tsize = nr_sects(p)*sector_size;\n\t\t\tnext = this_sector + offs;\n\t\t\tif (i >= 2) {\n\t\t\t\tif (offs + size > this_size)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (next < first_sector)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (next + size > first_sector + first_size)\n\t\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tput_partition(state, state->next, next, size);\n\t\t\tset_info(state, state->next, disksig);\n\t\t\tif (p->sys_ind == LINUX_RAID_PARTITION)\n\t\t\t\tstate->parts[state->next].flags = ADDPART_FLAG_RAID;\n\t\t\tloopct = 0;\n\t\t\tif (++state->next == state->limit)\n\t\t\t\tgoto done;\n\t\t}\n\t\t \n\t\tp -= 4;\n\t\tfor (i = 0; i < 4; i++, p++)\n\t\t\tif (nr_sects(p) && is_extended_partition(p))\n\t\t\t\tbreak;\n\t\tif (i == 4)\n\t\t\tgoto done;\t  \n\n\t\tthis_sector = first_sector + start_sect(p) * sector_size;\n\t\tthis_size = nr_sects(p) * sector_size;\n\t\tput_dev_sector(sect);\n\t}\ndone:\n\tput_dev_sector(sect);\n}\n\n#define SOLARIS_X86_NUMSLICE\t16\n#define SOLARIS_X86_VTOC_SANE\t(0x600DDEEEUL)\n\nstruct solaris_x86_slice {\n\t__le16 s_tag;\t\t \n\t__le16 s_flag;\t\t \n\t__le32 s_start;\t\t \n\t__le32 s_size;\t\t \n};\n\nstruct solaris_x86_vtoc {\n\tunsigned int v_bootinfo[3];\t \n\t__le32 v_sanity;\t\t \n\t__le32 v_version;\t\t \n\tchar\tv_volume[8];\t\t \n\t__le16\tv_sectorsz;\t\t \n\t__le16\tv_nparts;\t\t \n\tunsigned int v_reserved[10];\t \n\tstruct solaris_x86_slice\n\t\tv_slice[SOLARIS_X86_NUMSLICE];  \n\tunsigned int timestamp[SOLARIS_X86_NUMSLICE];  \n\tchar\tv_asciilabel[128];\t \n};\n\n \n\nstatic void parse_solaris_x86(struct parsed_partitions *state,\n\t\t\t      sector_t offset, sector_t size, int origin)\n{\n#ifdef CONFIG_SOLARIS_X86_PARTITION\n\tSector sect;\n\tstruct solaris_x86_vtoc *v;\n\tint i;\n\tshort max_nparts;\n\n\tv = read_part_sector(state, offset + 1, &sect);\n\tif (!v)\n\t\treturn;\n\tif (le32_to_cpu(v->v_sanity) != SOLARIS_X86_VTOC_SANE) {\n\t\tput_dev_sector(sect);\n\t\treturn;\n\t}\n\t{\n\t\tchar tmp[1 + BDEVNAME_SIZE + 10 + 11 + 1];\n\n\t\tsnprintf(tmp, sizeof(tmp), \" %s%d: <solaris:\", state->name, origin);\n\t\tstrlcat(state->pp_buf, tmp, PAGE_SIZE);\n\t}\n\tif (le32_to_cpu(v->v_version) != 1) {\n\t\tchar tmp[64];\n\n\t\tsnprintf(tmp, sizeof(tmp), \"  cannot handle version %d vtoc>\\n\",\n\t\t\t le32_to_cpu(v->v_version));\n\t\tstrlcat(state->pp_buf, tmp, PAGE_SIZE);\n\t\tput_dev_sector(sect);\n\t\treturn;\n\t}\n\t \n\tmax_nparts = le16_to_cpu(v->v_nparts) > 8 ? SOLARIS_X86_NUMSLICE : 8;\n\tfor (i = 0; i < max_nparts && state->next < state->limit; i++) {\n\t\tstruct solaris_x86_slice *s = &v->v_slice[i];\n\t\tchar tmp[3 + 10 + 1 + 1];\n\n\t\tif (s->s_size == 0)\n\t\t\tcontinue;\n\t\tsnprintf(tmp, sizeof(tmp), \" [s%d]\", i);\n\t\tstrlcat(state->pp_buf, tmp, PAGE_SIZE);\n\t\t \n\t\tput_partition(state, state->next++,\n\t\t\t\t le32_to_cpu(s->s_start)+offset,\n\t\t\t\t le32_to_cpu(s->s_size));\n\t}\n\tput_dev_sector(sect);\n\tstrlcat(state->pp_buf, \" >\\n\", PAGE_SIZE);\n#endif\n}\n\n \n#define BSD_DISKMAGIC\t(0x82564557UL)\t \n#define BSD_MAXPARTITIONS\t16\n#define OPENBSD_MAXPARTITIONS\t16\n#define BSD_FS_UNUSED\t\t0  \nstruct bsd_disklabel {\n\t__le32\td_magic;\t\t \n\t__s16\td_type;\t\t\t \n\t__s16\td_subtype;\t\t \n\tchar\td_typename[16];\t\t \n\tchar\td_packname[16];\t\t \n\t__u32\td_secsize;\t\t \n\t__u32\td_nsectors;\t\t \n\t__u32\td_ntracks;\t\t \n\t__u32\td_ncylinders;\t\t \n\t__u32\td_secpercyl;\t\t \n\t__u32\td_secperunit;\t\t \n\t__u16\td_sparespertrack;\t \n\t__u16\td_sparespercyl;\t\t \n\t__u32\td_acylinders;\t\t \n\t__u16\td_rpm;\t\t\t \n\t__u16\td_interleave;\t\t \n\t__u16\td_trackskew;\t\t \n\t__u16\td_cylskew;\t\t \n\t__u32\td_headswitch;\t\t \n\t__u32\td_trkseek;\t\t \n\t__u32\td_flags;\t\t \n#define NDDATA 5\n\t__u32\td_drivedata[NDDATA];\t \n#define NSPARE 5\n\t__u32\td_spare[NSPARE];\t \n\t__le32\td_magic2;\t\t \n\t__le16\td_checksum;\t\t \n\n\t\t\t \n\t__le16\td_npartitions;\t\t \n\t__le32\td_bbsize;\t\t \n\t__le32\td_sbsize;\t\t \n\tstruct\tbsd_partition {\t\t \n\t\t__le32\tp_size;\t\t \n\t\t__le32\tp_offset;\t \n\t\t__le32\tp_fsize;\t \n\t\t__u8\tp_fstype;\t \n\t\t__u8\tp_frag;\t\t \n\t\t__le16\tp_cpg;\t\t \n\t} d_partitions[BSD_MAXPARTITIONS];\t \n};\n\n#if defined(CONFIG_BSD_DISKLABEL)\n \nstatic void parse_bsd(struct parsed_partitions *state,\n\t\t      sector_t offset, sector_t size, int origin, char *flavour,\n\t\t      int max_partitions)\n{\n\tSector sect;\n\tstruct bsd_disklabel *l;\n\tstruct bsd_partition *p;\n\tchar tmp[64];\n\n\tl = read_part_sector(state, offset + 1, &sect);\n\tif (!l)\n\t\treturn;\n\tif (le32_to_cpu(l->d_magic) != BSD_DISKMAGIC) {\n\t\tput_dev_sector(sect);\n\t\treturn;\n\t}\n\n\tsnprintf(tmp, sizeof(tmp), \" %s%d: <%s:\", state->name, origin, flavour);\n\tstrlcat(state->pp_buf, tmp, PAGE_SIZE);\n\n\tif (le16_to_cpu(l->d_npartitions) < max_partitions)\n\t\tmax_partitions = le16_to_cpu(l->d_npartitions);\n\tfor (p = l->d_partitions; p - l->d_partitions < max_partitions; p++) {\n\t\tsector_t bsd_start, bsd_size;\n\n\t\tif (state->next == state->limit)\n\t\t\tbreak;\n\t\tif (p->p_fstype == BSD_FS_UNUSED)\n\t\t\tcontinue;\n\t\tbsd_start = le32_to_cpu(p->p_offset);\n\t\tbsd_size = le32_to_cpu(p->p_size);\n\t\t \n\t\tif (memcmp(flavour, \"bsd\\0\", 4) == 0 &&\n\t\t    le32_to_cpu(l->d_partitions[2].p_offset) == 0)\n\t\t\tbsd_start += offset;\n\t\tif (offset == bsd_start && size == bsd_size)\n\t\t\t \n\t\t\tcontinue;\n\t\tif (offset > bsd_start || offset+size < bsd_start+bsd_size) {\n\t\t\tstrlcat(state->pp_buf, \"bad subpartition - ignored\\n\", PAGE_SIZE);\n\t\t\tcontinue;\n\t\t}\n\t\tput_partition(state, state->next++, bsd_start, bsd_size);\n\t}\n\tput_dev_sector(sect);\n\tif (le16_to_cpu(l->d_npartitions) > max_partitions) {\n\t\tsnprintf(tmp, sizeof(tmp), \" (ignored %d more)\",\n\t\t\t le16_to_cpu(l->d_npartitions) - max_partitions);\n\t\tstrlcat(state->pp_buf, tmp, PAGE_SIZE);\n\t}\n\tstrlcat(state->pp_buf, \" >\\n\", PAGE_SIZE);\n}\n#endif\n\nstatic void parse_freebsd(struct parsed_partitions *state,\n\t\t\t  sector_t offset, sector_t size, int origin)\n{\n#ifdef CONFIG_BSD_DISKLABEL\n\tparse_bsd(state, offset, size, origin, \"bsd\", BSD_MAXPARTITIONS);\n#endif\n}\n\nstatic void parse_netbsd(struct parsed_partitions *state,\n\t\t\t sector_t offset, sector_t size, int origin)\n{\n#ifdef CONFIG_BSD_DISKLABEL\n\tparse_bsd(state, offset, size, origin, \"netbsd\", BSD_MAXPARTITIONS);\n#endif\n}\n\nstatic void parse_openbsd(struct parsed_partitions *state,\n\t\t\t  sector_t offset, sector_t size, int origin)\n{\n#ifdef CONFIG_BSD_DISKLABEL\n\tparse_bsd(state, offset, size, origin, \"openbsd\",\n\t\t  OPENBSD_MAXPARTITIONS);\n#endif\n}\n\n#define UNIXWARE_DISKMAGIC     (0xCA5E600DUL)\t \n#define UNIXWARE_DISKMAGIC2    (0x600DDEEEUL)\t \n#define UNIXWARE_NUMSLICE      16\n#define UNIXWARE_FS_UNUSED     0\t\t \n\nstruct unixware_slice {\n\t__le16   s_label;\t \n\t__le16   s_flags;\t \n\t__le32   start_sect;\t \n\t__le32   nr_sects;\t \n};\n\nstruct unixware_disklabel {\n\t__le32\td_type;\t\t\t \n\t__le32\td_magic;\t\t \n\t__le32\td_version;\t\t \n\tchar\td_serial[12];\t\t \n\t__le32\td_ncylinders;\t\t \n\t__le32\td_ntracks;\t\t \n\t__le32\td_nsectors;\t\t \n\t__le32\td_secsize;\t\t \n\t__le32\td_part_start;\t\t \n\t__le32\td_unknown1[12];\t\t \n\t__le32\td_alt_tbl;\t\t \n\t__le32\td_alt_len;\t\t \n\t__le32\td_phys_cyl;\t\t \n\t__le32\td_phys_trk;\t\t \n\t__le32\td_phys_sec;\t\t \n\t__le32\td_phys_bytes;\t\t \n\t__le32\td_unknown2;\t\t \n\t__le32\td_unknown3;\t\t \n\t__le32\td_pad[8];\t\t \n\n\tstruct unixware_vtoc {\n\t\t__le32\tv_magic;\t\t \n\t\t__le32\tv_version;\t\t \n\t\tchar\tv_name[8];\t\t \n\t\t__le16\tv_nslices;\t\t \n\t\t__le16\tv_unknown1;\t\t \n\t\t__le32\tv_reserved[10];\t\t \n\t\tstruct unixware_slice\n\t\t\tv_slice[UNIXWARE_NUMSLICE];\t \n\t} vtoc;\n};   \n\n \nstatic void parse_unixware(struct parsed_partitions *state,\n\t\t\t   sector_t offset, sector_t size, int origin)\n{\n#ifdef CONFIG_UNIXWARE_DISKLABEL\n\tSector sect;\n\tstruct unixware_disklabel *l;\n\tstruct unixware_slice *p;\n\n\tl = read_part_sector(state, offset + 29, &sect);\n\tif (!l)\n\t\treturn;\n\tif (le32_to_cpu(l->d_magic) != UNIXWARE_DISKMAGIC ||\n\t    le32_to_cpu(l->vtoc.v_magic) != UNIXWARE_DISKMAGIC2) {\n\t\tput_dev_sector(sect);\n\t\treturn;\n\t}\n\t{\n\t\tchar tmp[1 + BDEVNAME_SIZE + 10 + 12 + 1];\n\n\t\tsnprintf(tmp, sizeof(tmp), \" %s%d: <unixware:\", state->name, origin);\n\t\tstrlcat(state->pp_buf, tmp, PAGE_SIZE);\n\t}\n\tp = &l->vtoc.v_slice[1];\n\t \n\twhile (p - &l->vtoc.v_slice[0] < UNIXWARE_NUMSLICE) {\n\t\tif (state->next == state->limit)\n\t\t\tbreak;\n\n\t\tif (p->s_label != UNIXWARE_FS_UNUSED)\n\t\t\tput_partition(state, state->next++,\n\t\t\t\t      le32_to_cpu(p->start_sect),\n\t\t\t\t      le32_to_cpu(p->nr_sects));\n\t\tp++;\n\t}\n\tput_dev_sector(sect);\n\tstrlcat(state->pp_buf, \" >\\n\", PAGE_SIZE);\n#endif\n}\n\n#define MINIX_NR_SUBPARTITIONS  4\n\n \nstatic void parse_minix(struct parsed_partitions *state,\n\t\t\tsector_t offset, sector_t size, int origin)\n{\n#ifdef CONFIG_MINIX_SUBPARTITION\n\tSector sect;\n\tunsigned char *data;\n\tstruct msdos_partition *p;\n\tint i;\n\n\tdata = read_part_sector(state, offset, &sect);\n\tif (!data)\n\t\treturn;\n\n\tp = (struct msdos_partition *)(data + 0x1be);\n\n\t \n\tif (msdos_magic_present(data + 510) &&\n\t    p->sys_ind == MINIX_PARTITION) {  \n\t\tchar tmp[1 + BDEVNAME_SIZE + 10 + 9 + 1];\n\n\t\tsnprintf(tmp, sizeof(tmp), \" %s%d: <minix:\", state->name, origin);\n\t\tstrlcat(state->pp_buf, tmp, PAGE_SIZE);\n\t\tfor (i = 0; i < MINIX_NR_SUBPARTITIONS; i++, p++) {\n\t\t\tif (state->next == state->limit)\n\t\t\t\tbreak;\n\t\t\t \n\t\t\tif (p->sys_ind == MINIX_PARTITION)\n\t\t\t\tput_partition(state, state->next++,\n\t\t\t\t\t      start_sect(p), nr_sects(p));\n\t\t}\n\t\tstrlcat(state->pp_buf, \" >\\n\", PAGE_SIZE);\n\t}\n\tput_dev_sector(sect);\n#endif  \n}\n\nstatic struct {\n\tunsigned char id;\n\tvoid (*parse)(struct parsed_partitions *, sector_t, sector_t, int);\n} subtypes[] = {\n\t{FREEBSD_PARTITION, parse_freebsd},\n\t{NETBSD_PARTITION, parse_netbsd},\n\t{OPENBSD_PARTITION, parse_openbsd},\n\t{MINIX_PARTITION, parse_minix},\n\t{UNIXWARE_PARTITION, parse_unixware},\n\t{SOLARIS_X86_PARTITION, parse_solaris_x86},\n\t{NEW_SOLARIS_X86_PARTITION, parse_solaris_x86},\n\t{0, NULL},\n};\n\nint msdos_partition(struct parsed_partitions *state)\n{\n\tsector_t sector_size;\n\tSector sect;\n\tunsigned char *data;\n\tstruct msdos_partition *p;\n\tstruct fat_boot_sector *fb;\n\tint slot;\n\tu32 disksig;\n\n\tsector_size = queue_logical_block_size(state->disk->queue) / 512;\n\tdata = read_part_sector(state, 0, &sect);\n\tif (!data)\n\t\treturn -1;\n\n\t \n\tif (aix_magic_present(state, data)) {\n\t\tput_dev_sector(sect);\n#ifdef CONFIG_AIX_PARTITION\n\t\treturn aix_partition(state);\n#else\n\t\tstrlcat(state->pp_buf, \" [AIX]\", PAGE_SIZE);\n\t\treturn 0;\n#endif\n\t}\n\n\tif (!msdos_magic_present(data + 510)) {\n\t\tput_dev_sector(sect);\n\t\treturn 0;\n\t}\n\n\t \n\tp = (struct msdos_partition *) (data + 0x1be);\n\tfor (slot = 1; slot <= 4; slot++, p++) {\n\t\tif (p->boot_ind != 0 && p->boot_ind != 0x80) {\n\t\t\t \n\t\t\tfb = (struct fat_boot_sector *) data;\n\t\t\tif (slot == 1 && fb->reserved && fb->fats\n\t\t\t\t&& fat_valid_media(fb->media)) {\n\t\t\t\tstrlcat(state->pp_buf, \"\\n\", PAGE_SIZE);\n\t\t\t\tput_dev_sector(sect);\n\t\t\t\treturn 1;\n\t\t\t} else {\n\t\t\t\tput_dev_sector(sect);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\n#ifdef CONFIG_EFI_PARTITION\n\tp = (struct msdos_partition *) (data + 0x1be);\n\tfor (slot = 1 ; slot <= 4 ; slot++, p++) {\n\t\t \n\t\tif (p->sys_ind == EFI_PMBR_OSTYPE_EFI_GPT) {\n\t\t\tput_dev_sector(sect);\n\t\t\treturn 0;\n\t\t}\n\t}\n#endif\n\tp = (struct msdos_partition *) (data + 0x1be);\n\n\tdisksig = le32_to_cpup((__le32 *)(data + 0x1b8));\n\n\t \n\n\tstate->next = 5;\n\tfor (slot = 1 ; slot <= 4 ; slot++, p++) {\n\t\tsector_t start = start_sect(p)*sector_size;\n\t\tsector_t size = nr_sects(p)*sector_size;\n\n\t\tif (!size)\n\t\t\tcontinue;\n\t\tif (is_extended_partition(p)) {\n\t\t\t \n\t\t\tsector_t n = 2;\n\n\t\t\tn = min(size, max(sector_size, n));\n\t\t\tput_partition(state, slot, start, n);\n\n\t\t\tstrlcat(state->pp_buf, \" <\", PAGE_SIZE);\n\t\t\tparse_extended(state, start, size, disksig);\n\t\t\tstrlcat(state->pp_buf, \" >\", PAGE_SIZE);\n\t\t\tcontinue;\n\t\t}\n\t\tput_partition(state, slot, start, size);\n\t\tset_info(state, slot, disksig);\n\t\tif (p->sys_ind == LINUX_RAID_PARTITION)\n\t\t\tstate->parts[slot].flags = ADDPART_FLAG_RAID;\n\t\tif (p->sys_ind == DM6_PARTITION)\n\t\t\tstrlcat(state->pp_buf, \"[DM]\", PAGE_SIZE);\n\t\tif (p->sys_ind == EZD_PARTITION)\n\t\t\tstrlcat(state->pp_buf, \"[EZD]\", PAGE_SIZE);\n\t}\n\n\tstrlcat(state->pp_buf, \"\\n\", PAGE_SIZE);\n\n\t \n\tp = (struct msdos_partition *) (0x1be + data);\n\tfor (slot = 1 ; slot <= 4 ; slot++, p++) {\n\t\tunsigned char id = p->sys_ind;\n\t\tint n;\n\n\t\tif (!nr_sects(p))\n\t\t\tcontinue;\n\n\t\tfor (n = 0; subtypes[n].parse && id != subtypes[n].id; n++)\n\t\t\t;\n\n\t\tif (!subtypes[n].parse)\n\t\t\tcontinue;\n\t\tsubtypes[n].parse(state, start_sect(p) * sector_size,\n\t\t\t\t  nr_sects(p) * sector_size, slot);\n\t}\n\tput_dev_sector(sect);\n\treturn 1;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}