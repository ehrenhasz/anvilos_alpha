{
  "module_name": "amiga.c",
  "hash_id": "1698760bd15039952953593d4cd88b3811b7cf82ceefea923026d29aa54103ee",
  "original_prompt": "Ingested from linux-6.6.14/block/partitions/amiga.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) fmt\n\n#include <linux/types.h>\n#include <linux/mm_types.h>\n#include <linux/overflow.h>\n#include <linux/affs_hardblocks.h>\n\n#include \"check.h\"\n\n \n#define NR_HD\t3\n#define NR_SECT\t5\n#define LO_CYL\t9\n#define HI_CYL\t10\n\nstatic __inline__ u32\nchecksum_block(__be32 *m, int size)\n{\n\tu32 sum = 0;\n\n\twhile (size--)\n\t\tsum += be32_to_cpu(*m++);\n\treturn sum;\n}\n\nint amiga_partition(struct parsed_partitions *state)\n{\n\tSector sect;\n\tunsigned char *data;\n\tstruct RigidDiskBlock *rdb;\n\tstruct PartitionBlock *pb;\n\tu64 start_sect, nr_sects;\n\tsector_t blk, end_sect;\n\tu32 cylblk;\t\t \n\tu32 nr_hd, nr_sect, lo_cyl, hi_cyl;\n\tint part, res = 0;\n\tunsigned int blksize = 1;\t \n\tint slot = 1;\n\n\tfor (blk = 0; ; blk++, put_dev_sector(sect)) {\n\t\tif (blk == RDB_ALLOCATION_LIMIT)\n\t\t\tgoto rdb_done;\n\t\tdata = read_part_sector(state, blk, &sect);\n\t\tif (!data) {\n\t\t\tpr_err(\"Dev %s: unable to read RDB block %llu\\n\",\n\t\t\t       state->disk->disk_name, blk);\n\t\t\tres = -1;\n\t\t\tgoto rdb_done;\n\t\t}\n\t\tif (*(__be32 *)data != cpu_to_be32(IDNAME_RIGIDDISK))\n\t\t\tcontinue;\n\n\t\trdb = (struct RigidDiskBlock *)data;\n\t\tif (checksum_block((__be32 *)data, be32_to_cpu(rdb->rdb_SummedLongs) & 0x7F) == 0)\n\t\t\tbreak;\n\t\t \n\t\t*(__be32 *)(data+0xdc) = 0;\n\t\tif (checksum_block((__be32 *)data,\n\t\t\t\tbe32_to_cpu(rdb->rdb_SummedLongs) & 0x7F)==0) {\n\t\t\tpr_err(\"Trashed word at 0xd0 in block %llu ignored in checksum calculation\\n\",\n\t\t\t       blk);\n\t\t\tbreak;\n\t\t}\n\n\t\tpr_err(\"Dev %s: RDB in block %llu has bad checksum\\n\",\n\t\t       state->disk->disk_name, blk);\n\t}\n\n\t \n\tblksize = be32_to_cpu( rdb->rdb_BlockBytes ) / 512;\n\n\t{\n\t\tchar tmp[7 + 10 + 1 + 1];\n\n\t\t \n\t\tsnprintf(tmp, sizeof(tmp), \" RDSK (%d)\", blksize * 512);\n\t\tstrlcat(state->pp_buf, tmp, PAGE_SIZE);\n\t}\n\tblk = be32_to_cpu(rdb->rdb_PartitionList);\n\tput_dev_sector(sect);\n\tfor (part = 1; (s32) blk>0 && part<=16; part++, put_dev_sector(sect)) {\n\t\t \n\t\tif (check_mul_overflow(blk, (sector_t) blksize, &blk)) {\n\t\t\tpr_err(\"Dev %s: overflow calculating partition block %llu! Skipping partitions %u and beyond\\n\",\n\t\t\t\tstate->disk->disk_name, blk, part);\n\t\t\tbreak;\n\t\t}\n\t\tdata = read_part_sector(state, blk, &sect);\n\t\tif (!data) {\n\t\t\tpr_err(\"Dev %s: unable to read partition block %llu\\n\",\n\t\t\t       state->disk->disk_name, blk);\n\t\t\tres = -1;\n\t\t\tgoto rdb_done;\n\t\t}\n\t\tpb  = (struct PartitionBlock *)data;\n\t\tblk = be32_to_cpu(pb->pb_Next);\n\t\tif (pb->pb_ID != cpu_to_be32(IDNAME_PARTITION))\n\t\t\tcontinue;\n\t\tif (checksum_block((__be32 *)pb, be32_to_cpu(pb->pb_SummedLongs) & 0x7F) != 0 )\n\t\t\tcontinue;\n\n\t\t \n\n\t\tnr_hd   = be32_to_cpu(pb->pb_Environment[NR_HD]);\n\t\tnr_sect = be32_to_cpu(pb->pb_Environment[NR_SECT]);\n\n\t\t \n\t\tif (check_mul_overflow(nr_hd, nr_sect, &cylblk)) {\n\t\t\tpr_err(\"Dev %s: heads*sects %u overflows u32, skipping partition!\\n\",\n\t\t\t\tstate->disk->disk_name, cylblk);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (cylblk > be32_to_cpu(rdb->rdb_CylBlocks)) {\n\t\t\tpr_warn(\"Dev %s: cylblk %u > rdb_CylBlocks %u!\\n\",\n\t\t\t\tstate->disk->disk_name, cylblk,\n\t\t\t\tbe32_to_cpu(rdb->rdb_CylBlocks));\n\t\t}\n\n\t\t \n\n\t\tif (check_mul_overflow(cylblk, blksize, &cylblk)) {\n\t\t\tpr_err(\"Dev %s: partition %u bytes per cyl. overflows u32, skipping partition!\\n\",\n\t\t\t\tstate->disk->disk_name, part);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\n\t\tlo_cyl = be32_to_cpu(pb->pb_Environment[LO_CYL]);\n\t\tstart_sect = ((u64) lo_cyl * cylblk);\n\n\t\thi_cyl = be32_to_cpu(pb->pb_Environment[HI_CYL]);\n\t\tnr_sects = (((u64) hi_cyl - lo_cyl + 1) * cylblk);\n\n\t\tif (!nr_sects)\n\t\t\tcontinue;\n\n\t\t \n\n\t\tif ((start_sect + nr_sects) > UINT_MAX) {\n\t\t\tpr_warn(\"Dev %s: partition %u (%llu-%llu) needs 64 bit device support!\\n\",\n\t\t\t\tstate->disk->disk_name, part,\n\t\t\t\tstart_sect, start_sect + nr_sects);\n\t\t}\n\n\t\tif (check_add_overflow(start_sect, nr_sects, &end_sect)) {\n\t\t\tpr_err(\"Dev %s: partition %u (%llu-%llu) needs LBD device support, skipping partition!\\n\",\n\t\t\t\tstate->disk->disk_name, part,\n\t\t\t\tstart_sect, end_sect);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\n\t\tput_partition(state,slot++,start_sect,nr_sects);\n\t\t{\n\t\t\t \n\t\t\tchar dostype[4];\n\t\t\tchar tmp[42];\n\n\t\t\t__be32 *dt = (__be32 *)dostype;\n\t\t\t*dt = pb->pb_Environment[16];\n\t\t\tif (dostype[3] < ' ')\n\t\t\t\tsnprintf(tmp, sizeof(tmp), \" (%c%c%c^%c)\",\n\t\t\t\t\tdostype[0], dostype[1],\n\t\t\t\t\tdostype[2], dostype[3] + '@' );\n\t\t\telse\n\t\t\t\tsnprintf(tmp, sizeof(tmp), \" (%c%c%c%c)\",\n\t\t\t\t\tdostype[0], dostype[1],\n\t\t\t\t\tdostype[2], dostype[3]);\n\t\t\tstrlcat(state->pp_buf, tmp, PAGE_SIZE);\n\t\t\tsnprintf(tmp, sizeof(tmp), \"(res %d spb %d)\",\n\t\t\t\tbe32_to_cpu(pb->pb_Environment[6]),\n\t\t\t\tbe32_to_cpu(pb->pb_Environment[4]));\n\t\t\tstrlcat(state->pp_buf, tmp, PAGE_SIZE);\n\t\t}\n\t\tres = 1;\n\t}\n\tstrlcat(state->pp_buf, \"\\n\", PAGE_SIZE);\n\nrdb_done:\n\treturn res;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}