{
  "module_name": "efi.c",
  "hash_id": "475b4c08b83878755e03dd5e20812d92b91393cfa3379681f3f3cc184230348b",
  "original_prompt": "Ingested from linux-6.6.14/block/partitions/efi.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n#include <linux/crc32.h>\n#include <linux/ctype.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include \"check.h\"\n#include \"efi.h\"\n\n \nstatic int force_gpt;\nstatic int __init\nforce_gpt_fn(char *str)\n{\n\tforce_gpt = 1;\n\treturn 1;\n}\n__setup(\"gpt\", force_gpt_fn);\n\n\n \nstatic inline u32\nefi_crc32(const void *buf, unsigned long len)\n{\n\treturn (crc32(~0L, buf, len) ^ ~0L);\n}\n\n \nstatic u64 last_lba(struct gendisk *disk)\n{\n\treturn div_u64(bdev_nr_bytes(disk->part0),\n\t\t       queue_logical_block_size(disk->queue)) - 1ULL;\n}\n\nstatic inline int pmbr_part_valid(gpt_mbr_record *part)\n{\n\tif (part->os_type != EFI_PMBR_OSTYPE_EFI_GPT)\n\t\tgoto invalid;\n\n\t \n\tif (le32_to_cpu(part->starting_lba) != GPT_PRIMARY_PARTITION_TABLE_LBA)\n\t\tgoto invalid;\n\n\treturn GPT_MBR_PROTECTIVE;\ninvalid:\n\treturn 0;\n}\n\n \nstatic int is_pmbr_valid(legacy_mbr *mbr, sector_t total_sectors)\n{\n\tuint32_t sz = 0;\n\tint i, part = 0, ret = 0;  \n\n\tif (!mbr || le16_to_cpu(mbr->signature) != MSDOS_MBR_SIGNATURE)\n\t\tgoto done;\n\n\tfor (i = 0; i < 4; i++) {\n\t\tret = pmbr_part_valid(&mbr->partition_record[i]);\n\t\tif (ret == GPT_MBR_PROTECTIVE) {\n\t\t\tpart = i;\n\t\t\t \n\t\t\tgoto check_hybrid;\n\t\t}\n\t}\n\n\tif (ret != GPT_MBR_PROTECTIVE)\n\t\tgoto done;\ncheck_hybrid:\n\tfor (i = 0; i < 4; i++)\n\t\tif ((mbr->partition_record[i].os_type !=\n\t\t\tEFI_PMBR_OSTYPE_EFI_GPT) &&\n\t\t    (mbr->partition_record[i].os_type != 0x00))\n\t\t\tret = GPT_MBR_HYBRID;\n\n\t \n\tif (ret == GPT_MBR_PROTECTIVE) {\n\t\tsz = le32_to_cpu(mbr->partition_record[part].size_in_lba);\n\t\tif (sz != (uint32_t) total_sectors - 1 && sz != 0xFFFFFFFF)\n\t\t\tpr_debug(\"GPT: mbr size in lba (%u) different than whole disk (%u).\\n\",\n\t\t\t\t sz, min_t(uint32_t,\n\t\t\t\t\t   total_sectors - 1, 0xFFFFFFFF));\n\t}\ndone:\n\treturn ret;\n}\n\n \nstatic size_t read_lba(struct parsed_partitions *state,\n\t\t       u64 lba, u8 *buffer, size_t count)\n{\n\tsize_t totalreadcount = 0;\n\tsector_t n = lba *\n\t\t(queue_logical_block_size(state->disk->queue) / 512);\n\n\tif (!buffer || lba > last_lba(state->disk))\n                return 0;\n\n\twhile (count) {\n\t\tint copied = 512;\n\t\tSector sect;\n\t\tunsigned char *data = read_part_sector(state, n++, &sect);\n\t\tif (!data)\n\t\t\tbreak;\n\t\tif (copied > count)\n\t\t\tcopied = count;\n\t\tmemcpy(buffer, data, copied);\n\t\tput_dev_sector(sect);\n\t\tbuffer += copied;\n\t\ttotalreadcount +=copied;\n\t\tcount -= copied;\n\t}\n\treturn totalreadcount;\n}\n\n \nstatic gpt_entry *alloc_read_gpt_entries(struct parsed_partitions *state,\n\t\t\t\t\t gpt_header *gpt)\n{\n\tsize_t count;\n\tgpt_entry *pte;\n\n\tif (!gpt)\n\t\treturn NULL;\n\n\tcount = (size_t)le32_to_cpu(gpt->num_partition_entries) *\n                le32_to_cpu(gpt->sizeof_partition_entry);\n\tif (!count)\n\t\treturn NULL;\n\tpte = kmalloc(count, GFP_KERNEL);\n\tif (!pte)\n\t\treturn NULL;\n\n\tif (read_lba(state, le64_to_cpu(gpt->partition_entry_lba),\n\t\t\t(u8 *) pte, count) < count) {\n\t\tkfree(pte);\n                pte=NULL;\n\t\treturn NULL;\n\t}\n\treturn pte;\n}\n\n \nstatic gpt_header *alloc_read_gpt_header(struct parsed_partitions *state,\n\t\t\t\t\t u64 lba)\n{\n\tgpt_header *gpt;\n\tunsigned ssz = queue_logical_block_size(state->disk->queue);\n\n\tgpt = kmalloc(ssz, GFP_KERNEL);\n\tif (!gpt)\n\t\treturn NULL;\n\n\tif (read_lba(state, lba, (u8 *) gpt, ssz) < ssz) {\n\t\tkfree(gpt);\n                gpt=NULL;\n\t\treturn NULL;\n\t}\n\n\treturn gpt;\n}\n\n \nstatic int is_gpt_valid(struct parsed_partitions *state, u64 lba,\n\t\t\tgpt_header **gpt, gpt_entry **ptes)\n{\n\tu32 crc, origcrc;\n\tu64 lastlba, pt_size;\n\n\tif (!ptes)\n\t\treturn 0;\n\tif (!(*gpt = alloc_read_gpt_header(state, lba)))\n\t\treturn 0;\n\n\t \n\tif (le64_to_cpu((*gpt)->signature) != GPT_HEADER_SIGNATURE) {\n\t\tpr_debug(\"GUID Partition Table Header signature is wrong:\"\n\t\t\t \"%lld != %lld\\n\",\n\t\t\t (unsigned long long)le64_to_cpu((*gpt)->signature),\n\t\t\t (unsigned long long)GPT_HEADER_SIGNATURE);\n\t\tgoto fail;\n\t}\n\n\t \n\tif (le32_to_cpu((*gpt)->header_size) >\n\t\t\tqueue_logical_block_size(state->disk->queue)) {\n\t\tpr_debug(\"GUID Partition Table Header size is too large: %u > %u\\n\",\n\t\t\tle32_to_cpu((*gpt)->header_size),\n\t\t\tqueue_logical_block_size(state->disk->queue));\n\t\tgoto fail;\n\t}\n\n\t \n\tif (le32_to_cpu((*gpt)->header_size) < sizeof(gpt_header)) {\n\t\tpr_debug(\"GUID Partition Table Header size is too small: %u < %zu\\n\",\n\t\t\tle32_to_cpu((*gpt)->header_size),\n\t\t\tsizeof(gpt_header));\n\t\tgoto fail;\n\t}\n\n\t \n\torigcrc = le32_to_cpu((*gpt)->header_crc32);\n\t(*gpt)->header_crc32 = 0;\n\tcrc = efi_crc32((const unsigned char *) (*gpt), le32_to_cpu((*gpt)->header_size));\n\n\tif (crc != origcrc) {\n\t\tpr_debug(\"GUID Partition Table Header CRC is wrong: %x != %x\\n\",\n\t\t\t crc, origcrc);\n\t\tgoto fail;\n\t}\n\t(*gpt)->header_crc32 = cpu_to_le32(origcrc);\n\n\t \n\tif (le64_to_cpu((*gpt)->my_lba) != lba) {\n\t\tpr_debug(\"GPT my_lba incorrect: %lld != %lld\\n\",\n\t\t\t (unsigned long long)le64_to_cpu((*gpt)->my_lba),\n\t\t\t (unsigned long long)lba);\n\t\tgoto fail;\n\t}\n\n\t \n\tlastlba = last_lba(state->disk);\n\tif (le64_to_cpu((*gpt)->first_usable_lba) > lastlba) {\n\t\tpr_debug(\"GPT: first_usable_lba incorrect: %lld > %lld\\n\",\n\t\t\t (unsigned long long)le64_to_cpu((*gpt)->first_usable_lba),\n\t\t\t (unsigned long long)lastlba);\n\t\tgoto fail;\n\t}\n\tif (le64_to_cpu((*gpt)->last_usable_lba) > lastlba) {\n\t\tpr_debug(\"GPT: last_usable_lba incorrect: %lld > %lld\\n\",\n\t\t\t (unsigned long long)le64_to_cpu((*gpt)->last_usable_lba),\n\t\t\t (unsigned long long)lastlba);\n\t\tgoto fail;\n\t}\n\tif (le64_to_cpu((*gpt)->last_usable_lba) < le64_to_cpu((*gpt)->first_usable_lba)) {\n\t\tpr_debug(\"GPT: last_usable_lba incorrect: %lld > %lld\\n\",\n\t\t\t (unsigned long long)le64_to_cpu((*gpt)->last_usable_lba),\n\t\t\t (unsigned long long)le64_to_cpu((*gpt)->first_usable_lba));\n\t\tgoto fail;\n\t}\n\t \n\tif (le32_to_cpu((*gpt)->sizeof_partition_entry) != sizeof(gpt_entry)) {\n\t\tpr_debug(\"GUID Partition Entry Size check failed.\\n\");\n\t\tgoto fail;\n\t}\n\n\t \n\tpt_size = (u64)le32_to_cpu((*gpt)->num_partition_entries) *\n\t\tle32_to_cpu((*gpt)->sizeof_partition_entry);\n\tif (pt_size > KMALLOC_MAX_SIZE) {\n\t\tpr_debug(\"GUID Partition Table is too large: %llu > %lu bytes\\n\",\n\t\t\t (unsigned long long)pt_size, KMALLOC_MAX_SIZE);\n\t\tgoto fail;\n\t}\n\n\tif (!(*ptes = alloc_read_gpt_entries(state, *gpt)))\n\t\tgoto fail;\n\n\t \n\tcrc = efi_crc32((const unsigned char *) (*ptes), pt_size);\n\n\tif (crc != le32_to_cpu((*gpt)->partition_entry_array_crc32)) {\n\t\tpr_debug(\"GUID Partition Entry Array CRC check failed.\\n\");\n\t\tgoto fail_ptes;\n\t}\n\n\t \n\treturn 1;\n\n fail_ptes:\n\tkfree(*ptes);\n\t*ptes = NULL;\n fail:\n\tkfree(*gpt);\n\t*gpt = NULL;\n\treturn 0;\n}\n\n \nstatic inline int\nis_pte_valid(const gpt_entry *pte, const u64 lastlba)\n{\n\tif ((!efi_guidcmp(pte->partition_type_guid, NULL_GUID)) ||\n\t    le64_to_cpu(pte->starting_lba) > lastlba         ||\n\t    le64_to_cpu(pte->ending_lba)   > lastlba)\n\t\treturn 0;\n\treturn 1;\n}\n\n \nstatic void\ncompare_gpts(gpt_header *pgpt, gpt_header *agpt, u64 lastlba)\n{\n\tint error_found = 0;\n\tif (!pgpt || !agpt)\n\t\treturn;\n\tif (le64_to_cpu(pgpt->my_lba) != le64_to_cpu(agpt->alternate_lba)) {\n\t\tpr_warn(\"GPT:Primary header LBA != Alt. header alternate_lba\\n\");\n\t\tpr_warn(\"GPT:%lld != %lld\\n\",\n\t\t       (unsigned long long)le64_to_cpu(pgpt->my_lba),\n                       (unsigned long long)le64_to_cpu(agpt->alternate_lba));\n\t\terror_found++;\n\t}\n\tif (le64_to_cpu(pgpt->alternate_lba) != le64_to_cpu(agpt->my_lba)) {\n\t\tpr_warn(\"GPT:Primary header alternate_lba != Alt. header my_lba\\n\");\n\t\tpr_warn(\"GPT:%lld != %lld\\n\",\n\t\t       (unsigned long long)le64_to_cpu(pgpt->alternate_lba),\n                       (unsigned long long)le64_to_cpu(agpt->my_lba));\n\t\terror_found++;\n\t}\n\tif (le64_to_cpu(pgpt->first_usable_lba) !=\n            le64_to_cpu(agpt->first_usable_lba)) {\n\t\tpr_warn(\"GPT:first_usable_lbas don't match.\\n\");\n\t\tpr_warn(\"GPT:%lld != %lld\\n\",\n\t\t       (unsigned long long)le64_to_cpu(pgpt->first_usable_lba),\n                       (unsigned long long)le64_to_cpu(agpt->first_usable_lba));\n\t\terror_found++;\n\t}\n\tif (le64_to_cpu(pgpt->last_usable_lba) !=\n            le64_to_cpu(agpt->last_usable_lba)) {\n\t\tpr_warn(\"GPT:last_usable_lbas don't match.\\n\");\n\t\tpr_warn(\"GPT:%lld != %lld\\n\",\n\t\t       (unsigned long long)le64_to_cpu(pgpt->last_usable_lba),\n                       (unsigned long long)le64_to_cpu(agpt->last_usable_lba));\n\t\terror_found++;\n\t}\n\tif (efi_guidcmp(pgpt->disk_guid, agpt->disk_guid)) {\n\t\tpr_warn(\"GPT:disk_guids don't match.\\n\");\n\t\terror_found++;\n\t}\n\tif (le32_to_cpu(pgpt->num_partition_entries) !=\n            le32_to_cpu(agpt->num_partition_entries)) {\n\t\tpr_warn(\"GPT:num_partition_entries don't match: \"\n\t\t       \"0x%x != 0x%x\\n\",\n\t\t       le32_to_cpu(pgpt->num_partition_entries),\n\t\t       le32_to_cpu(agpt->num_partition_entries));\n\t\terror_found++;\n\t}\n\tif (le32_to_cpu(pgpt->sizeof_partition_entry) !=\n            le32_to_cpu(agpt->sizeof_partition_entry)) {\n\t\tpr_warn(\"GPT:sizeof_partition_entry values don't match: \"\n\t\t       \"0x%x != 0x%x\\n\",\n                       le32_to_cpu(pgpt->sizeof_partition_entry),\n\t\t       le32_to_cpu(agpt->sizeof_partition_entry));\n\t\terror_found++;\n\t}\n\tif (le32_to_cpu(pgpt->partition_entry_array_crc32) !=\n            le32_to_cpu(agpt->partition_entry_array_crc32)) {\n\t\tpr_warn(\"GPT:partition_entry_array_crc32 values don't match: \"\n\t\t       \"0x%x != 0x%x\\n\",\n                       le32_to_cpu(pgpt->partition_entry_array_crc32),\n\t\t       le32_to_cpu(agpt->partition_entry_array_crc32));\n\t\terror_found++;\n\t}\n\tif (le64_to_cpu(pgpt->alternate_lba) != lastlba) {\n\t\tpr_warn(\"GPT:Primary header thinks Alt. header is not at the end of the disk.\\n\");\n\t\tpr_warn(\"GPT:%lld != %lld\\n\",\n\t\t\t(unsigned long long)le64_to_cpu(pgpt->alternate_lba),\n\t\t\t(unsigned long long)lastlba);\n\t\terror_found++;\n\t}\n\n\tif (le64_to_cpu(agpt->my_lba) != lastlba) {\n\t\tpr_warn(\"GPT:Alternate GPT header not at the end of the disk.\\n\");\n\t\tpr_warn(\"GPT:%lld != %lld\\n\",\n\t\t\t(unsigned long long)le64_to_cpu(agpt->my_lba),\n\t\t\t(unsigned long long)lastlba);\n\t\terror_found++;\n\t}\n\n\tif (error_found)\n\t\tpr_warn(\"GPT: Use GNU Parted to correct GPT errors.\\n\");\n\treturn;\n}\n\n \nstatic int find_valid_gpt(struct parsed_partitions *state, gpt_header **gpt,\n\t\t\t  gpt_entry **ptes)\n{\n\tint good_pgpt = 0, good_agpt = 0, good_pmbr = 0;\n\tgpt_header *pgpt = NULL, *agpt = NULL;\n\tgpt_entry *pptes = NULL, *aptes = NULL;\n\tlegacy_mbr *legacymbr;\n\tstruct gendisk *disk = state->disk;\n\tconst struct block_device_operations *fops = disk->fops;\n\tsector_t total_sectors = get_capacity(state->disk);\n\tu64 lastlba;\n\n\tif (!ptes)\n\t\treturn 0;\n\n\tlastlba = last_lba(state->disk);\n        if (!force_gpt) {\n\t\t \n\t\tlegacymbr = kzalloc(sizeof(*legacymbr), GFP_KERNEL);\n\t\tif (!legacymbr)\n\t\t\tgoto fail;\n\n\t\tread_lba(state, 0, (u8 *)legacymbr, sizeof(*legacymbr));\n\t\tgood_pmbr = is_pmbr_valid(legacymbr, total_sectors);\n\t\tkfree(legacymbr);\n\n\t\tif (!good_pmbr)\n\t\t\tgoto fail;\n\n\t\tpr_debug(\"Device has a %s MBR\\n\",\n\t\t\t good_pmbr == GPT_MBR_PROTECTIVE ?\n\t\t\t\t\t\t\"protective\" : \"hybrid\");\n\t}\n\n\tgood_pgpt = is_gpt_valid(state, GPT_PRIMARY_PARTITION_TABLE_LBA,\n\t\t\t\t &pgpt, &pptes);\n        if (good_pgpt)\n\t\tgood_agpt = is_gpt_valid(state,\n\t\t\t\t\t le64_to_cpu(pgpt->alternate_lba),\n\t\t\t\t\t &agpt, &aptes);\n        if (!good_agpt && force_gpt)\n                good_agpt = is_gpt_valid(state, lastlba, &agpt, &aptes);\n\n\tif (!good_agpt && force_gpt && fops->alternative_gpt_sector) {\n\t\tsector_t agpt_sector;\n\t\tint err;\n\n\t\terr = fops->alternative_gpt_sector(disk, &agpt_sector);\n\t\tif (!err)\n\t\t\tgood_agpt = is_gpt_valid(state, agpt_sector,\n\t\t\t\t\t\t &agpt, &aptes);\n\t}\n\n         \n        if (!good_pgpt && !good_agpt)\n                goto fail;\n\n        compare_gpts(pgpt, agpt, lastlba);\n\n         \n        if (good_pgpt) {\n                *gpt  = pgpt;\n                *ptes = pptes;\n                kfree(agpt);\n                kfree(aptes);\n\t\tif (!good_agpt)\n                        pr_warn(\"Alternate GPT is invalid, using primary GPT.\\n\");\n                return 1;\n        }\n        else if (good_agpt) {\n                *gpt  = agpt;\n                *ptes = aptes;\n                kfree(pgpt);\n                kfree(pptes);\n\t\tpr_warn(\"Primary GPT is invalid, using alternate GPT.\\n\");\n                return 1;\n        }\n\n fail:\n        kfree(pgpt);\n        kfree(agpt);\n        kfree(pptes);\n        kfree(aptes);\n        *gpt = NULL;\n        *ptes = NULL;\n        return 0;\n}\n\n \nstatic void utf16_le_to_7bit(const __le16 *in, unsigned int size, u8 *out)\n{\n\tunsigned int i = 0;\n\n\tout[size] = 0;\n\n\twhile (i < size) {\n\t\tu8 c = le16_to_cpu(in[i]) & 0xff;\n\n\t\tif (c && !isprint(c))\n\t\t\tc = '!';\n\t\tout[i] = c;\n\t\ti++;\n\t}\n}\n\n \nint efi_partition(struct parsed_partitions *state)\n{\n\tgpt_header *gpt = NULL;\n\tgpt_entry *ptes = NULL;\n\tu32 i;\n\tunsigned ssz = queue_logical_block_size(state->disk->queue) / 512;\n\n\tif (!find_valid_gpt(state, &gpt, &ptes) || !gpt || !ptes) {\n\t\tkfree(gpt);\n\t\tkfree(ptes);\n\t\treturn 0;\n\t}\n\n\tpr_debug(\"GUID Partition Table is valid!  Yea!\\n\");\n\n\tfor (i = 0; i < le32_to_cpu(gpt->num_partition_entries) && i < state->limit-1; i++) {\n\t\tstruct partition_meta_info *info;\n\t\tunsigned label_max;\n\t\tu64 start = le64_to_cpu(ptes[i].starting_lba);\n\t\tu64 size = le64_to_cpu(ptes[i].ending_lba) -\n\t\t\t   le64_to_cpu(ptes[i].starting_lba) + 1ULL;\n\n\t\tif (!is_pte_valid(&ptes[i], last_lba(state->disk)))\n\t\t\tcontinue;\n\n\t\tput_partition(state, i+1, start * ssz, size * ssz);\n\n\t\t \n\t\tif (!efi_guidcmp(ptes[i].partition_type_guid, PARTITION_LINUX_RAID_GUID))\n\t\t\tstate->parts[i + 1].flags = ADDPART_FLAG_RAID;\n\n\t\tinfo = &state->parts[i + 1].info;\n\t\tefi_guid_to_str(&ptes[i].unique_partition_guid, info->uuid);\n\n\t\t \n\t\tlabel_max = min(ARRAY_SIZE(info->volname) - 1,\n\t\t\t\tARRAY_SIZE(ptes[i].partition_name));\n\t\tutf16_le_to_7bit(ptes[i].partition_name, label_max, info->volname);\n\t\tstate->parts[i + 1].has_info = true;\n\t}\n\tkfree(ptes);\n\tkfree(gpt);\n\tstrlcat(state->pp_buf, \"\\n\", PAGE_SIZE);\n\treturn 1;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}