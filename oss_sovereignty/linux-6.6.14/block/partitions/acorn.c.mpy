{
  "module_name": "acorn.c",
  "hash_id": "e2848e248cf3887768edc80f24ff331212e67fb86a879410f2557a25a8be9379",
  "original_prompt": "Ingested from linux-6.6.14/block/partitions/acorn.c",
  "human_readable_source": "\n \n#include <linux/buffer_head.h>\n#include <linux/adfs_fs.h>\n\n#include \"check.h\"\n\n \n#define PARTITION_RISCIX_MFM\t1\n#define PARTITION_RISCIX_SCSI\t2\n#define PARTITION_LINUX\t\t9\n\n#if defined(CONFIG_ACORN_PARTITION_CUMANA) || \\\n\tdefined(CONFIG_ACORN_PARTITION_ADFS)\nstatic struct adfs_discrecord *\nadfs_partition(struct parsed_partitions *state, char *name, char *data,\n\t       unsigned long first_sector, int slot)\n{\n\tstruct adfs_discrecord *dr;\n\tunsigned int nr_sects;\n\n\tif (adfs_checkbblk(data))\n\t\treturn NULL;\n\n\tdr = (struct adfs_discrecord *)(data + 0x1c0);\n\n\tif (dr->disc_size == 0 && dr->disc_size_high == 0)\n\t\treturn NULL;\n\n\tnr_sects = (le32_to_cpu(dr->disc_size_high) << 23) |\n\t\t   (le32_to_cpu(dr->disc_size) >> 9);\n\n\tif (name) {\n\t\tstrlcat(state->pp_buf, \" [\", PAGE_SIZE);\n\t\tstrlcat(state->pp_buf, name, PAGE_SIZE);\n\t\tstrlcat(state->pp_buf, \"]\", PAGE_SIZE);\n\t}\n\tput_partition(state, slot, first_sector, nr_sects);\n\treturn dr;\n}\n#endif\n\n#ifdef CONFIG_ACORN_PARTITION_RISCIX\n\nstruct riscix_part {\n\t__le32\tstart;\n\t__le32\tlength;\n\t__le32\tone;\n\tchar\tname[16];\n};\n\nstruct riscix_record {\n\t__le32\tmagic;\n#define RISCIX_MAGIC\tcpu_to_le32(0x4a657320)\n\t__le32\tdate;\n\tstruct riscix_part part[8];\n};\n\n#if defined(CONFIG_ACORN_PARTITION_CUMANA) || \\\n\tdefined(CONFIG_ACORN_PARTITION_ADFS)\nstatic int riscix_partition(struct parsed_partitions *state,\n\t\t\t    unsigned long first_sect, int slot,\n\t\t\t    unsigned long nr_sects)\n{\n\tSector sect;\n\tstruct riscix_record *rr;\n\t\n\trr = read_part_sector(state, first_sect, &sect);\n\tif (!rr)\n\t\treturn -1;\n\n\tstrlcat(state->pp_buf, \" [RISCiX]\", PAGE_SIZE);\n\n\n\tif (rr->magic == RISCIX_MAGIC) {\n\t\tunsigned long size = nr_sects > 2 ? 2 : nr_sects;\n\t\tint part;\n\n\t\tstrlcat(state->pp_buf, \" <\", PAGE_SIZE);\n\n\t\tput_partition(state, slot++, first_sect, size);\n\t\tfor (part = 0; part < 8; part++) {\n\t\t\tif (rr->part[part].one &&\n\t\t\t    memcmp(rr->part[part].name, \"All\\0\", 4)) {\n\t\t\t\tput_partition(state, slot++,\n\t\t\t\t\tle32_to_cpu(rr->part[part].start),\n\t\t\t\t\tle32_to_cpu(rr->part[part].length));\n\t\t\t\tstrlcat(state->pp_buf, \"(\", PAGE_SIZE);\n\t\t\t\tstrlcat(state->pp_buf, rr->part[part].name, PAGE_SIZE);\n\t\t\t\tstrlcat(state->pp_buf, \")\", PAGE_SIZE);\n\t\t\t}\n\t\t}\n\n\t\tstrlcat(state->pp_buf, \" >\\n\", PAGE_SIZE);\n\t} else {\n\t\tput_partition(state, slot++, first_sect, nr_sects);\n\t}\n\n\tput_dev_sector(sect);\n\treturn slot;\n}\n#endif\n#endif\n\n#define LINUX_NATIVE_MAGIC 0xdeafa1de\n#define LINUX_SWAP_MAGIC   0xdeafab1e\n\nstruct linux_part {\n\t__le32 magic;\n\t__le32 start_sect;\n\t__le32 nr_sects;\n};\n\n#if defined(CONFIG_ACORN_PARTITION_CUMANA) || \\\n\tdefined(CONFIG_ACORN_PARTITION_ADFS)\nstatic int linux_partition(struct parsed_partitions *state,\n\t\t\t   unsigned long first_sect, int slot,\n\t\t\t   unsigned long nr_sects)\n{\n\tSector sect;\n\tstruct linux_part *linuxp;\n\tunsigned long size = nr_sects > 2 ? 2 : nr_sects;\n\n\tstrlcat(state->pp_buf, \" [Linux]\", PAGE_SIZE);\n\n\tput_partition(state, slot++, first_sect, size);\n\n\tlinuxp = read_part_sector(state, first_sect, &sect);\n\tif (!linuxp)\n\t\treturn -1;\n\n\tstrlcat(state->pp_buf, \" <\", PAGE_SIZE);\n\twhile (linuxp->magic == cpu_to_le32(LINUX_NATIVE_MAGIC) ||\n\t       linuxp->magic == cpu_to_le32(LINUX_SWAP_MAGIC)) {\n\t\tif (slot == state->limit)\n\t\t\tbreak;\n\t\tput_partition(state, slot++, first_sect +\n\t\t\t\t le32_to_cpu(linuxp->start_sect),\n\t\t\t\t le32_to_cpu(linuxp->nr_sects));\n\t\tlinuxp ++;\n\t}\n\tstrlcat(state->pp_buf, \" >\", PAGE_SIZE);\n\n\tput_dev_sector(sect);\n\treturn slot;\n}\n#endif\n\n#ifdef CONFIG_ACORN_PARTITION_CUMANA\nint adfspart_check_CUMANA(struct parsed_partitions *state)\n{\n\tunsigned long first_sector = 0;\n\tunsigned int start_blk = 0;\n\tSector sect;\n\tunsigned char *data;\n\tchar *name = \"CUMANA/ADFS\";\n\tint first = 1;\n\tint slot = 1;\n\n\t \n\tdo {\n\t\tstruct adfs_discrecord *dr;\n\t\tunsigned int nr_sects;\n\n\t\tdata = read_part_sector(state, start_blk * 2 + 6, &sect);\n\t\tif (!data)\n\t\t\treturn -1;\n\n\t\tif (slot == state->limit)\n\t\t\tbreak;\n\n\t\tdr = adfs_partition(state, name, data, first_sector, slot++);\n\t\tif (!dr)\n\t\t\tbreak;\n\n\t\tname = NULL;\n\n\t\tnr_sects = (data[0x1fd] + (data[0x1fe] << 8)) *\n\t\t\t   (dr->heads + (dr->lowsector & 0x40 ? 1 : 0)) *\n\t\t\t   dr->secspertrack;\n\n\t\tif (!nr_sects)\n\t\t\tbreak;\n\n\t\tfirst = 0;\n\t\tfirst_sector += nr_sects;\n\t\tstart_blk += nr_sects >> (BLOCK_SIZE_BITS - 9);\n\t\tnr_sects = 0;  \n\n\t\tswitch (data[0x1fc] & 15) {\n\t\tcase 0:  \n\t\t\tbreak;\n\n#ifdef CONFIG_ACORN_PARTITION_RISCIX\n\t\tcase PARTITION_RISCIX_SCSI:\n\t\t\t \n\t\t\tslot = riscix_partition(state, first_sector, slot,\n\t\t\t\t\t\tnr_sects);\n\t\t\tbreak;\n#endif\n\n\t\tcase PARTITION_LINUX:\n\t\t\tslot = linux_partition(state, first_sector, slot,\n\t\t\t\t\t       nr_sects);\n\t\t\tbreak;\n\t\t}\n\t\tput_dev_sector(sect);\n\t\tif (slot == -1)\n\t\t\treturn -1;\n\t} while (1);\n\tput_dev_sector(sect);\n\treturn first ? 0 : 1;\n}\n#endif\n\n#ifdef CONFIG_ACORN_PARTITION_ADFS\n \nint adfspart_check_ADFS(struct parsed_partitions *state)\n{\n\tunsigned long start_sect, nr_sects, sectscyl, heads;\n\tSector sect;\n\tunsigned char *data;\n\tstruct adfs_discrecord *dr;\n\tunsigned char id;\n\tint slot = 1;\n\n\tdata = read_part_sector(state, 6, &sect);\n\tif (!data)\n\t\treturn -1;\n\n\tdr = adfs_partition(state, \"ADFS\", data, 0, slot++);\n\tif (!dr) {\n\t\tput_dev_sector(sect);\n    \t\treturn 0;\n\t}\n\n\theads = dr->heads + ((dr->lowsector >> 6) & 1);\n\tsectscyl = dr->secspertrack * heads;\n\tstart_sect = ((data[0x1fe] << 8) + data[0x1fd]) * sectscyl;\n\tid = data[0x1fc] & 15;\n\tput_dev_sector(sect);\n\n\t \n\tnr_sects = get_capacity(state->disk) - start_sect;\n\n\tif (start_sect) {\n\t\tswitch (id) {\n#ifdef CONFIG_ACORN_PARTITION_RISCIX\n\t\tcase PARTITION_RISCIX_SCSI:\n\t\tcase PARTITION_RISCIX_MFM:\n\t\t\triscix_partition(state, start_sect, slot,\n\t\t\t\t\t\tnr_sects);\n\t\t\tbreak;\n#endif\n\n\t\tcase PARTITION_LINUX:\n\t\t\tlinux_partition(state, start_sect, slot,\n\t\t\t\t\t       nr_sects);\n\t\t\tbreak;\n\t\t}\n\t}\n\tstrlcat(state->pp_buf, \"\\n\", PAGE_SIZE);\n\treturn 1;\n}\n#endif\n\n#ifdef CONFIG_ACORN_PARTITION_ICS\n\nstruct ics_part {\n\t__le32 start;\n\t__le32 size;\n};\n\nstatic int adfspart_check_ICSLinux(struct parsed_partitions *state,\n\t\t\t\t   unsigned long block)\n{\n\tSector sect;\n\tunsigned char *data = read_part_sector(state, block, &sect);\n\tint result = 0;\n\n\tif (data) {\n\t\tif (memcmp(data, \"LinuxPart\", 9) == 0)\n\t\t\tresult = 1;\n\t\tput_dev_sector(sect);\n\t}\n\n\treturn result;\n}\n\n \nstatic inline int valid_ics_sector(const unsigned char *data)\n{\n\tunsigned long sum;\n\tint i;\n\n\tfor (i = 0, sum = 0x50617274; i < 508; i++)\n\t\tsum += data[i];\n\n\tsum -= le32_to_cpu(*(__le32 *)(&data[508]));\n\n\treturn sum == 0;\n}\n\n \nint adfspart_check_ICS(struct parsed_partitions *state)\n{\n\tconst unsigned char *data;\n\tconst struct ics_part *p;\n\tint slot;\n\tSector sect;\n\n\t \n\tdata = read_part_sector(state, 0, &sect);\n\tif (!data)\n\t    \treturn -1;\n\n\tif (!valid_ics_sector(data)) {\n\t    \tput_dev_sector(sect);\n\t\treturn 0;\n\t}\n\n\tstrlcat(state->pp_buf, \" [ICS]\", PAGE_SIZE);\n\n\tfor (slot = 1, p = (const struct ics_part *)data; p->size; p++) {\n\t\tu32 start = le32_to_cpu(p->start);\n\t\ts32 size = le32_to_cpu(p->size);  \n\n\t\tif (slot == state->limit)\n\t\t\tbreak;\n\n\t\t \n\t\tif (size < 0) {\n\t\t\tsize = -size;\n\n\t\t\t \n\t\t\tif (size > 1 && adfspart_check_ICSLinux(state, start)) {\n\t\t\t\tstart += 1;\n\t\t\t\tsize -= 1;\n\t\t\t}\n\t\t}\n\n\t\tif (size)\n\t\t\tput_partition(state, slot++, start, size);\n\t}\n\n\tput_dev_sector(sect);\n\tstrlcat(state->pp_buf, \"\\n\", PAGE_SIZE);\n\treturn 1;\n}\n#endif\n\n#ifdef CONFIG_ACORN_PARTITION_POWERTEC\nstruct ptec_part {\n\t__le32 unused1;\n\t__le32 unused2;\n\t__le32 start;\n\t__le32 size;\n\t__le32 unused5;\n\tchar type[8];\n};\n\nstatic inline int valid_ptec_sector(const unsigned char *data)\n{\n\tunsigned char checksum = 0x2a;\n\tint i;\n\n\t \n\tif (data[510] == 0x55 && data[511] == 0xaa)\n\t\treturn 0;\n\n\tfor (i = 0; i < 511; i++)\n\t\tchecksum += data[i];\n\n\treturn checksum == data[511];\n}\n\n \nint adfspart_check_POWERTEC(struct parsed_partitions *state)\n{\n\tSector sect;\n\tconst unsigned char *data;\n\tconst struct ptec_part *p;\n\tint slot = 1;\n\tint i;\n\n\tdata = read_part_sector(state, 0, &sect);\n\tif (!data)\n\t\treturn -1;\n\n\tif (!valid_ptec_sector(data)) {\n\t\tput_dev_sector(sect);\n\t\treturn 0;\n\t}\n\n\tstrlcat(state->pp_buf, \" [POWERTEC]\", PAGE_SIZE);\n\n\tfor (i = 0, p = (const struct ptec_part *)data; i < 12; i++, p++) {\n\t\tu32 start = le32_to_cpu(p->start);\n\t\tu32 size = le32_to_cpu(p->size);\n\n\t\tif (size)\n\t\t\tput_partition(state, slot++, start, size);\n\t}\n\n\tput_dev_sector(sect);\n\tstrlcat(state->pp_buf, \"\\n\", PAGE_SIZE);\n\treturn 1;\n}\n#endif\n\n#ifdef CONFIG_ACORN_PARTITION_EESOX\nstruct eesox_part {\n\tchar\tmagic[6];\n\tchar\tname[10];\n\t__le32\tstart;\n\t__le32\tunused6;\n\t__le32\tunused7;\n\t__le32\tunused8;\n};\n\n \nstatic const char eesox_name[] = {\n\t'N', 'e', 'i', 'l', ' ',\n\t'C', 'r', 'i', 't', 'c', 'h', 'e', 'l', 'l', ' ', ' '\n};\n\n \nint adfspart_check_EESOX(struct parsed_partitions *state)\n{\n\tSector sect;\n\tconst unsigned char *data;\n\tunsigned char buffer[256];\n\tstruct eesox_part *p;\n\tsector_t start = 0;\n\tint i, slot = 1;\n\n\tdata = read_part_sector(state, 7, &sect);\n\tif (!data)\n\t\treturn -1;\n\n\t \n\tfor (i = 0; i < 256; i++)\n\t\tbuffer[i] = data[i] ^ eesox_name[i & 15];\n\n\tput_dev_sector(sect);\n\n\tfor (i = 0, p = (struct eesox_part *)buffer; i < 8; i++, p++) {\n\t\tsector_t next;\n\n\t\tif (memcmp(p->magic, \"Eesox\", 6))\n\t\t\tbreak;\n\n\t\tnext = le32_to_cpu(p->start);\n\t\tif (i)\n\t\t\tput_partition(state, slot++, start, next - start);\n\t\tstart = next;\n\t}\n\n\tif (i != 0) {\n\t\tsector_t size;\n\n\t\tsize = get_capacity(state->disk);\n\t\tput_partition(state, slot++, start, size - start);\n\t\tstrlcat(state->pp_buf, \"\\n\", PAGE_SIZE);\n\t}\n\n\treturn i ? 1 : 0;\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}