{
  "module_name": "ldm.c",
  "hash_id": "534d5e84ba7568bbfaab02ea01d39baddb5e57254b6eaf756b501cb4bb7c9906",
  "original_prompt": "Ingested from linux-6.6.14/block/partitions/ldm.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/stringify.h>\n#include <linux/kernel.h>\n#include <linux/uuid.h>\n#include <linux/msdos_partition.h>\n\n#include \"ldm.h\"\n#include \"check.h\"\n\n \n#ifndef CONFIG_LDM_DEBUG\n#define ldm_debug(...)\tdo {} while (0)\n#else\n#define ldm_debug(f, a...) _ldm_printk (KERN_DEBUG, __func__, f, ##a)\n#endif\n\n#define ldm_crit(f, a...)  _ldm_printk (KERN_CRIT,  __func__, f, ##a)\n#define ldm_error(f, a...) _ldm_printk (KERN_ERR,   __func__, f, ##a)\n#define ldm_info(f, a...)  _ldm_printk (KERN_INFO,  __func__, f, ##a)\n\nstatic __printf(3, 4)\nvoid _ldm_printk(const char *level, const char *function, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start (args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%s%s(): %pV\\n\", level, function, &vaf);\n\n\tva_end(args);\n}\n\n \nstatic bool ldm_parse_privhead(const u8 *data, struct privhead *ph)\n{\n\tbool is_vista = false;\n\n\tBUG_ON(!data || !ph);\n\tif (MAGIC_PRIVHEAD != get_unaligned_be64(data)) {\n\t\tldm_error(\"Cannot find PRIVHEAD structure. LDM database is\"\n\t\t\t\" corrupt. Aborting.\");\n\t\treturn false;\n\t}\n\tph->ver_major = get_unaligned_be16(data + 0x000C);\n\tph->ver_minor = get_unaligned_be16(data + 0x000E);\n\tph->logical_disk_start = get_unaligned_be64(data + 0x011B);\n\tph->logical_disk_size = get_unaligned_be64(data + 0x0123);\n\tph->config_start = get_unaligned_be64(data + 0x012B);\n\tph->config_size = get_unaligned_be64(data + 0x0133);\n\t \n\tif (ph->ver_major == 2 && ph->ver_minor == 12)\n\t\tis_vista = true;\n\tif (!is_vista && (ph->ver_major != 2 || ph->ver_minor != 11)) {\n\t\tldm_error(\"Expected PRIVHEAD version 2.11 or 2.12, got %d.%d.\"\n\t\t\t\" Aborting.\", ph->ver_major, ph->ver_minor);\n\t\treturn false;\n\t}\n\tldm_debug(\"PRIVHEAD version %d.%d (Windows %s).\", ph->ver_major,\n\t\t\tph->ver_minor, is_vista ? \"Vista\" : \"2000/XP\");\n\tif (ph->config_size != LDM_DB_SIZE) {\t \n\t\t \n\t\tldm_info(\"Database is normally %u bytes, it claims to \"\n\t\t\t\"be %llu bytes.\", LDM_DB_SIZE,\n\t\t\t(unsigned long long)ph->config_size);\n\t}\n\tif ((ph->logical_disk_size == 0) || (ph->logical_disk_start +\n\t\t\tph->logical_disk_size > ph->config_start)) {\n\t\tldm_error(\"PRIVHEAD disk size doesn't match real disk size\");\n\t\treturn false;\n\t}\n\tif (uuid_parse(data + 0x0030, &ph->disk_id)) {\n\t\tldm_error(\"PRIVHEAD contains an invalid GUID.\");\n\t\treturn false;\n\t}\n\tldm_debug(\"Parsed PRIVHEAD successfully.\");\n\treturn true;\n}\n\n \nstatic bool ldm_parse_tocblock (const u8 *data, struct tocblock *toc)\n{\n\tBUG_ON (!data || !toc);\n\n\tif (MAGIC_TOCBLOCK != get_unaligned_be64(data)) {\n\t\tldm_crit (\"Cannot find TOCBLOCK, database may be corrupt.\");\n\t\treturn false;\n\t}\n\tstrncpy (toc->bitmap1_name, data + 0x24, sizeof (toc->bitmap1_name));\n\ttoc->bitmap1_name[sizeof (toc->bitmap1_name) - 1] = 0;\n\ttoc->bitmap1_start = get_unaligned_be64(data + 0x2E);\n\ttoc->bitmap1_size  = get_unaligned_be64(data + 0x36);\n\n\tif (strncmp (toc->bitmap1_name, TOC_BITMAP1,\n\t\t\tsizeof (toc->bitmap1_name)) != 0) {\n\t\tldm_crit (\"TOCBLOCK's first bitmap is '%s', should be '%s'.\",\n\t\t\t\tTOC_BITMAP1, toc->bitmap1_name);\n\t\treturn false;\n\t}\n\tstrncpy (toc->bitmap2_name, data + 0x46, sizeof (toc->bitmap2_name));\n\ttoc->bitmap2_name[sizeof (toc->bitmap2_name) - 1] = 0;\n\ttoc->bitmap2_start = get_unaligned_be64(data + 0x50);\n\ttoc->bitmap2_size  = get_unaligned_be64(data + 0x58);\n\tif (strncmp (toc->bitmap2_name, TOC_BITMAP2,\n\t\t\tsizeof (toc->bitmap2_name)) != 0) {\n\t\tldm_crit (\"TOCBLOCK's second bitmap is '%s', should be '%s'.\",\n\t\t\t\tTOC_BITMAP2, toc->bitmap2_name);\n\t\treturn false;\n\t}\n\tldm_debug (\"Parsed TOCBLOCK successfully.\");\n\treturn true;\n}\n\n \nstatic bool ldm_parse_vmdb (const u8 *data, struct vmdb *vm)\n{\n\tBUG_ON (!data || !vm);\n\n\tif (MAGIC_VMDB != get_unaligned_be32(data)) {\n\t\tldm_crit (\"Cannot find the VMDB, database may be corrupt.\");\n\t\treturn false;\n\t}\n\n\tvm->ver_major = get_unaligned_be16(data + 0x12);\n\tvm->ver_minor = get_unaligned_be16(data + 0x14);\n\tif ((vm->ver_major != 4) || (vm->ver_minor != 10)) {\n\t\tldm_error (\"Expected VMDB version %d.%d, got %d.%d. \"\n\t\t\t\"Aborting.\", 4, 10, vm->ver_major, vm->ver_minor);\n\t\treturn false;\n\t}\n\n\tvm->vblk_size     = get_unaligned_be32(data + 0x08);\n\tif (vm->vblk_size == 0) {\n\t\tldm_error (\"Illegal VBLK size\");\n\t\treturn false;\n\t}\n\n\tvm->vblk_offset   = get_unaligned_be32(data + 0x0C);\n\tvm->last_vblk_seq = get_unaligned_be32(data + 0x04);\n\n\tldm_debug (\"Parsed VMDB successfully.\");\n\treturn true;\n}\n\n \nstatic bool ldm_compare_privheads (const struct privhead *ph1,\n\t\t\t\t   const struct privhead *ph2)\n{\n\tBUG_ON (!ph1 || !ph2);\n\n\treturn ((ph1->ver_major          == ph2->ver_major)\t\t&&\n\t\t(ph1->ver_minor          == ph2->ver_minor)\t\t&&\n\t\t(ph1->logical_disk_start == ph2->logical_disk_start)\t&&\n\t\t(ph1->logical_disk_size  == ph2->logical_disk_size)\t&&\n\t\t(ph1->config_start       == ph2->config_start)\t\t&&\n\t\t(ph1->config_size        == ph2->config_size)\t\t&&\n\t\tuuid_equal(&ph1->disk_id, &ph2->disk_id));\n}\n\n \nstatic bool ldm_compare_tocblocks (const struct tocblock *toc1,\n\t\t\t\t   const struct tocblock *toc2)\n{\n\tBUG_ON (!toc1 || !toc2);\n\n\treturn ((toc1->bitmap1_start == toc2->bitmap1_start)\t&&\n\t\t(toc1->bitmap1_size  == toc2->bitmap1_size)\t&&\n\t\t(toc1->bitmap2_start == toc2->bitmap2_start)\t&&\n\t\t(toc1->bitmap2_size  == toc2->bitmap2_size)\t&&\n\t\t!strncmp (toc1->bitmap1_name, toc2->bitmap1_name,\n\t\t\tsizeof (toc1->bitmap1_name))\t\t&&\n\t\t!strncmp (toc1->bitmap2_name, toc2->bitmap2_name,\n\t\t\tsizeof (toc1->bitmap2_name)));\n}\n\n \nstatic bool ldm_validate_privheads(struct parsed_partitions *state,\n\t\t\t\t   struct privhead *ph1)\n{\n\tstatic const int off[3] = { OFF_PRIV1, OFF_PRIV2, OFF_PRIV3 };\n\tstruct privhead *ph[3] = { ph1 };\n\tSector sect;\n\tu8 *data;\n\tbool result = false;\n\tlong num_sects;\n\tint i;\n\n\tBUG_ON (!state || !ph1);\n\n\tph[1] = kmalloc (sizeof (*ph[1]), GFP_KERNEL);\n\tph[2] = kmalloc (sizeof (*ph[2]), GFP_KERNEL);\n\tif (!ph[1] || !ph[2]) {\n\t\tldm_crit (\"Out of memory.\");\n\t\tgoto out;\n\t}\n\n\t \n\tph[0]->config_start = 0;\n\n\t \n\tfor (i = 0; i < 3; i++) {\n\t\tdata = read_part_sector(state, ph[0]->config_start + off[i],\n\t\t\t\t\t&sect);\n\t\tif (!data) {\n\t\t\tldm_crit (\"Disk read failed.\");\n\t\t\tgoto out;\n\t\t}\n\t\tresult = ldm_parse_privhead (data, ph[i]);\n\t\tput_dev_sector (sect);\n\t\tif (!result) {\n\t\t\tldm_error (\"Cannot find PRIVHEAD %d.\", i+1);  \n\t\t\tif (i < 2)\n\t\t\t\tgoto out;\t \n\t\t\telse\n\t\t\t\tbreak;\t \n\t\t}\n\t}\n\n\tnum_sects = get_capacity(state->disk);\n\n\tif ((ph[0]->config_start > num_sects) ||\n\t   ((ph[0]->config_start + ph[0]->config_size) > num_sects)) {\n\t\tldm_crit (\"Database extends beyond the end of the disk.\");\n\t\tgoto out;\n\t}\n\n\tif ((ph[0]->logical_disk_start > ph[0]->config_start) ||\n\t   ((ph[0]->logical_disk_start + ph[0]->logical_disk_size)\n\t\t    > ph[0]->config_start)) {\n\t\tldm_crit (\"Disk and database overlap.\");\n\t\tgoto out;\n\t}\n\n\tif (!ldm_compare_privheads (ph[0], ph[1])) {\n\t\tldm_crit (\"Primary and backup PRIVHEADs don't match.\");\n\t\tgoto out;\n\t}\n\t \n\tldm_debug (\"Validated PRIVHEADs successfully.\");\n\tresult = true;\nout:\n\tkfree (ph[1]);\n\tkfree (ph[2]);\n\treturn result;\n}\n\n \nstatic bool ldm_validate_tocblocks(struct parsed_partitions *state,\n\t\t\t\t   unsigned long base, struct ldmdb *ldb)\n{\n\tstatic const int off[4] = { OFF_TOCB1, OFF_TOCB2, OFF_TOCB3, OFF_TOCB4};\n\tstruct tocblock *tb[4];\n\tstruct privhead *ph;\n\tSector sect;\n\tu8 *data;\n\tint i, nr_tbs;\n\tbool result = false;\n\n\tBUG_ON(!state || !ldb);\n\tph = &ldb->ph;\n\ttb[0] = &ldb->toc;\n\ttb[1] = kmalloc_array(3, sizeof(*tb[1]), GFP_KERNEL);\n\tif (!tb[1]) {\n\t\tldm_crit(\"Out of memory.\");\n\t\tgoto err;\n\t}\n\ttb[2] = (struct tocblock*)((u8*)tb[1] + sizeof(*tb[1]));\n\ttb[3] = (struct tocblock*)((u8*)tb[2] + sizeof(*tb[2]));\n\t \n\tfor (nr_tbs = i = 0; i < 4; i++) {\n\t\tdata = read_part_sector(state, base + off[i], &sect);\n\t\tif (!data) {\n\t\t\tldm_error(\"Disk read failed for TOCBLOCK %d.\", i);\n\t\t\tcontinue;\n\t\t}\n\t\tif (ldm_parse_tocblock(data, tb[nr_tbs]))\n\t\t\tnr_tbs++;\n\t\tput_dev_sector(sect);\n\t}\n\tif (!nr_tbs) {\n\t\tldm_crit(\"Failed to find a valid TOCBLOCK.\");\n\t\tgoto err;\n\t}\n\t \n\tif (((tb[0]->bitmap1_start + tb[0]->bitmap1_size) > ph->config_size) ||\n\t\t\t((tb[0]->bitmap2_start + tb[0]->bitmap2_size) >\n\t\t\tph->config_size)) {\n\t\tldm_crit(\"The bitmaps are out of range.  Giving up.\");\n\t\tgoto err;\n\t}\n\t \n\tfor (i = 1; i < nr_tbs; i++) {\n\t\tif (!ldm_compare_tocblocks(tb[0], tb[i])) {\n\t\t\tldm_crit(\"TOCBLOCKs 0 and %d do not match.\", i);\n\t\t\tgoto err;\n\t\t}\n\t}\n\tldm_debug(\"Validated %d TOCBLOCKs successfully.\", nr_tbs);\n\tresult = true;\nerr:\n\tkfree(tb[1]);\n\treturn result;\n}\n\n \nstatic bool ldm_validate_vmdb(struct parsed_partitions *state,\n\t\t\t      unsigned long base, struct ldmdb *ldb)\n{\n\tSector sect;\n\tu8 *data;\n\tbool result = false;\n\tstruct vmdb *vm;\n\tstruct tocblock *toc;\n\n\tBUG_ON (!state || !ldb);\n\n\tvm  = &ldb->vm;\n\ttoc = &ldb->toc;\n\n\tdata = read_part_sector(state, base + OFF_VMDB, &sect);\n\tif (!data) {\n\t\tldm_crit (\"Disk read failed.\");\n\t\treturn false;\n\t}\n\n\tif (!ldm_parse_vmdb (data, vm))\n\t\tgoto out;\t\t\t\t \n\n\t \n\tif (get_unaligned_be16(data + 0x10) != 0x01) {\n\t\tldm_crit (\"Database is not in a consistent state.  Aborting.\");\n\t\tgoto out;\n\t}\n\n\tif (vm->vblk_offset != 512)\n\t\tldm_info (\"VBLKs start at offset 0x%04x.\", vm->vblk_offset);\n\n\t \n\tif ((vm->vblk_size * vm->last_vblk_seq) > (toc->bitmap1_size << 9)) {\n\t\tldm_crit (\"VMDB exceeds allowed size specified by TOCBLOCK.  \"\n\t\t\t\t\"Database is corrupt.  Aborting.\");\n\t\tgoto out;\n\t}\n\n\tresult = true;\nout:\n\tput_dev_sector (sect);\n\treturn result;\n}\n\n\n \nstatic bool ldm_validate_partition_table(struct parsed_partitions *state)\n{\n\tSector sect;\n\tu8 *data;\n\tstruct msdos_partition *p;\n\tint i;\n\tbool result = false;\n\n\tBUG_ON(!state);\n\n\tdata = read_part_sector(state, 0, &sect);\n\tif (!data) {\n\t\tldm_info (\"Disk read failed.\");\n\t\treturn false;\n\t}\n\n\tif (*(__le16*) (data + 0x01FE) != cpu_to_le16 (MSDOS_LABEL_MAGIC))\n\t\tgoto out;\n\n\tp = (struct msdos_partition *)(data + 0x01BE);\n\tfor (i = 0; i < 4; i++, p++)\n\t\tif (p->sys_ind == LDM_PARTITION) {\n\t\t\tresult = true;\n\t\t\tbreak;\n\t\t}\n\n\tif (result)\n\t\tldm_debug (\"Found W2K dynamic disk partition type.\");\n\nout:\n\tput_dev_sector (sect);\n\treturn result;\n}\n\n \nstatic struct vblk * ldm_get_disk_objid (const struct ldmdb *ldb)\n{\n\tstruct list_head *item;\n\n\tBUG_ON (!ldb);\n\n\tlist_for_each (item, &ldb->v_disk) {\n\t\tstruct vblk *v = list_entry (item, struct vblk, list);\n\t\tif (uuid_equal(&v->vblk.disk.disk_id, &ldb->ph.disk_id))\n\t\t\treturn v;\n\t}\n\n\treturn NULL;\n}\n\n \nstatic bool ldm_create_data_partitions (struct parsed_partitions *pp,\n\t\t\t\t\tconst struct ldmdb *ldb)\n{\n\tstruct list_head *item;\n\tstruct vblk *vb;\n\tstruct vblk *disk;\n\tstruct vblk_part *part;\n\tint part_num = 1;\n\n\tBUG_ON (!pp || !ldb);\n\n\tdisk = ldm_get_disk_objid (ldb);\n\tif (!disk) {\n\t\tldm_crit (\"Can't find the ID of this disk in the database.\");\n\t\treturn false;\n\t}\n\n\tstrlcat(pp->pp_buf, \" [LDM]\", PAGE_SIZE);\n\n\t \n\tlist_for_each (item, &ldb->v_part) {\n\t\tvb = list_entry (item, struct vblk, list);\n\t\tpart = &vb->vblk.part;\n\n\t\tif (part->disk_id != disk->obj_id)\n\t\t\tcontinue;\n\n\t\tput_partition (pp, part_num, ldb->ph.logical_disk_start +\n\t\t\t\tpart->start, part->size);\n\t\tpart_num++;\n\t}\n\n\tstrlcat(pp->pp_buf, \"\\n\", PAGE_SIZE);\n\treturn true;\n}\n\n\n \nstatic int ldm_relative(const u8 *buffer, int buflen, int base, int offset)\n{\n\n\tbase += offset;\n\tif (!buffer || offset < 0 || base > buflen) {\n\t\tif (!buffer)\n\t\t\tldm_error(\"!buffer\");\n\t\tif (offset < 0)\n\t\t\tldm_error(\"offset (%d) < 0\", offset);\n\t\tif (base > buflen)\n\t\t\tldm_error(\"base (%d) > buflen (%d)\", base, buflen);\n\t\treturn -1;\n\t}\n\tif (base + buffer[base] >= buflen) {\n\t\tldm_error(\"base (%d) + buffer[base] (%d) >= buflen (%d)\", base,\n\t\t\t\tbuffer[base], buflen);\n\t\treturn -1;\n\t}\n\treturn buffer[base] + offset + 1;\n}\n\n \nstatic u64 ldm_get_vnum (const u8 *block)\n{\n\tu64 tmp = 0;\n\tu8 length;\n\n\tBUG_ON (!block);\n\n\tlength = *block++;\n\n\tif (length && length <= 8)\n\t\twhile (length--)\n\t\t\ttmp = (tmp << 8) | *block++;\n\telse\n\t\tldm_error (\"Illegal length %d.\", length);\n\n\treturn tmp;\n}\n\n \nstatic int ldm_get_vstr (const u8 *block, u8 *buffer, int buflen)\n{\n\tint length;\n\n\tBUG_ON (!block || !buffer);\n\n\tlength = block[0];\n\tif (length >= buflen) {\n\t\tldm_error (\"Truncating string %d -> %d.\", length, buflen);\n\t\tlength = buflen - 1;\n\t}\n\tmemcpy (buffer, block + 1, length);\n\tbuffer[length] = 0;\n\treturn length;\n}\n\n\n \nstatic bool ldm_parse_cmp3 (const u8 *buffer, int buflen, struct vblk *vb)\n{\n\tint r_objid, r_name, r_vstate, r_child, r_parent, r_stripe, r_cols, len;\n\tstruct vblk_comp *comp;\n\n\tBUG_ON (!buffer || !vb);\n\n\tr_objid  = ldm_relative (buffer, buflen, 0x18, 0);\n\tr_name   = ldm_relative (buffer, buflen, 0x18, r_objid);\n\tr_vstate = ldm_relative (buffer, buflen, 0x18, r_name);\n\tr_child  = ldm_relative (buffer, buflen, 0x1D, r_vstate);\n\tr_parent = ldm_relative (buffer, buflen, 0x2D, r_child);\n\n\tif (buffer[0x12] & VBLK_FLAG_COMP_STRIPE) {\n\t\tr_stripe = ldm_relative (buffer, buflen, 0x2E, r_parent);\n\t\tr_cols   = ldm_relative (buffer, buflen, 0x2E, r_stripe);\n\t\tlen = r_cols;\n\t} else {\n\t\tr_stripe = 0;\n\t\tlen = r_parent;\n\t}\n\tif (len < 0)\n\t\treturn false;\n\n\tlen += VBLK_SIZE_CMP3;\n\tif (len != get_unaligned_be32(buffer + 0x14))\n\t\treturn false;\n\n\tcomp = &vb->vblk.comp;\n\tldm_get_vstr (buffer + 0x18 + r_name, comp->state,\n\t\tsizeof (comp->state));\n\tcomp->type      = buffer[0x18 + r_vstate];\n\tcomp->children  = ldm_get_vnum (buffer + 0x1D + r_vstate);\n\tcomp->parent_id = ldm_get_vnum (buffer + 0x2D + r_child);\n\tcomp->chunksize = r_stripe ? ldm_get_vnum (buffer+r_parent+0x2E) : 0;\n\n\treturn true;\n}\n\n \nstatic int ldm_parse_dgr3 (const u8 *buffer, int buflen, struct vblk *vb)\n{\n\tint r_objid, r_name, r_diskid, r_id1, r_id2, len;\n\tstruct vblk_dgrp *dgrp;\n\n\tBUG_ON (!buffer || !vb);\n\n\tr_objid  = ldm_relative (buffer, buflen, 0x18, 0);\n\tr_name   = ldm_relative (buffer, buflen, 0x18, r_objid);\n\tr_diskid = ldm_relative (buffer, buflen, 0x18, r_name);\n\n\tif (buffer[0x12] & VBLK_FLAG_DGR3_IDS) {\n\t\tr_id1 = ldm_relative (buffer, buflen, 0x24, r_diskid);\n\t\tr_id2 = ldm_relative (buffer, buflen, 0x24, r_id1);\n\t\tlen = r_id2;\n\t} else\n\t\tlen = r_diskid;\n\tif (len < 0)\n\t\treturn false;\n\n\tlen += VBLK_SIZE_DGR3;\n\tif (len != get_unaligned_be32(buffer + 0x14))\n\t\treturn false;\n\n\tdgrp = &vb->vblk.dgrp;\n\tldm_get_vstr (buffer + 0x18 + r_name, dgrp->disk_id,\n\t\tsizeof (dgrp->disk_id));\n\treturn true;\n}\n\n \nstatic bool ldm_parse_dgr4 (const u8 *buffer, int buflen, struct vblk *vb)\n{\n\tchar buf[64];\n\tint r_objid, r_name, r_id1, r_id2, len;\n\n\tBUG_ON (!buffer || !vb);\n\n\tr_objid  = ldm_relative (buffer, buflen, 0x18, 0);\n\tr_name   = ldm_relative (buffer, buflen, 0x18, r_objid);\n\n\tif (buffer[0x12] & VBLK_FLAG_DGR4_IDS) {\n\t\tr_id1 = ldm_relative (buffer, buflen, 0x44, r_name);\n\t\tr_id2 = ldm_relative (buffer, buflen, 0x44, r_id1);\n\t\tlen = r_id2;\n\t} else\n\t\tlen = r_name;\n\tif (len < 0)\n\t\treturn false;\n\n\tlen += VBLK_SIZE_DGR4;\n\tif (len != get_unaligned_be32(buffer + 0x14))\n\t\treturn false;\n\n\tldm_get_vstr (buffer + 0x18 + r_objid, buf, sizeof (buf));\n\treturn true;\n}\n\n \nstatic bool ldm_parse_dsk3 (const u8 *buffer, int buflen, struct vblk *vb)\n{\n\tint r_objid, r_name, r_diskid, r_altname, len;\n\tstruct vblk_disk *disk;\n\n\tBUG_ON (!buffer || !vb);\n\n\tr_objid   = ldm_relative (buffer, buflen, 0x18, 0);\n\tr_name    = ldm_relative (buffer, buflen, 0x18, r_objid);\n\tr_diskid  = ldm_relative (buffer, buflen, 0x18, r_name);\n\tr_altname = ldm_relative (buffer, buflen, 0x18, r_diskid);\n\tlen = r_altname;\n\tif (len < 0)\n\t\treturn false;\n\n\tlen += VBLK_SIZE_DSK3;\n\tif (len != get_unaligned_be32(buffer + 0x14))\n\t\treturn false;\n\n\tdisk = &vb->vblk.disk;\n\tldm_get_vstr (buffer + 0x18 + r_diskid, disk->alt_name,\n\t\tsizeof (disk->alt_name));\n\tif (uuid_parse(buffer + 0x19 + r_name, &disk->disk_id))\n\t\treturn false;\n\n\treturn true;\n}\n\n \nstatic bool ldm_parse_dsk4 (const u8 *buffer, int buflen, struct vblk *vb)\n{\n\tint r_objid, r_name, len;\n\tstruct vblk_disk *disk;\n\n\tBUG_ON (!buffer || !vb);\n\n\tr_objid = ldm_relative (buffer, buflen, 0x18, 0);\n\tr_name  = ldm_relative (buffer, buflen, 0x18, r_objid);\n\tlen     = r_name;\n\tif (len < 0)\n\t\treturn false;\n\n\tlen += VBLK_SIZE_DSK4;\n\tif (len != get_unaligned_be32(buffer + 0x14))\n\t\treturn false;\n\n\tdisk = &vb->vblk.disk;\n\timport_uuid(&disk->disk_id, buffer + 0x18 + r_name);\n\treturn true;\n}\n\n \nstatic bool ldm_parse_prt3(const u8 *buffer, int buflen, struct vblk *vb)\n{\n\tint r_objid, r_name, r_size, r_parent, r_diskid, r_index, len;\n\tstruct vblk_part *part;\n\n\tBUG_ON(!buffer || !vb);\n\tr_objid = ldm_relative(buffer, buflen, 0x18, 0);\n\tif (r_objid < 0) {\n\t\tldm_error(\"r_objid %d < 0\", r_objid);\n\t\treturn false;\n\t}\n\tr_name = ldm_relative(buffer, buflen, 0x18, r_objid);\n\tif (r_name < 0) {\n\t\tldm_error(\"r_name %d < 0\", r_name);\n\t\treturn false;\n\t}\n\tr_size = ldm_relative(buffer, buflen, 0x34, r_name);\n\tif (r_size < 0) {\n\t\tldm_error(\"r_size %d < 0\", r_size);\n\t\treturn false;\n\t}\n\tr_parent = ldm_relative(buffer, buflen, 0x34, r_size);\n\tif (r_parent < 0) {\n\t\tldm_error(\"r_parent %d < 0\", r_parent);\n\t\treturn false;\n\t}\n\tr_diskid = ldm_relative(buffer, buflen, 0x34, r_parent);\n\tif (r_diskid < 0) {\n\t\tldm_error(\"r_diskid %d < 0\", r_diskid);\n\t\treturn false;\n\t}\n\tif (buffer[0x12] & VBLK_FLAG_PART_INDEX) {\n\t\tr_index = ldm_relative(buffer, buflen, 0x34, r_diskid);\n\t\tif (r_index < 0) {\n\t\t\tldm_error(\"r_index %d < 0\", r_index);\n\t\t\treturn false;\n\t\t}\n\t\tlen = r_index;\n\t} else\n\t\tlen = r_diskid;\n\tif (len < 0) {\n\t\tldm_error(\"len %d < 0\", len);\n\t\treturn false;\n\t}\n\tlen += VBLK_SIZE_PRT3;\n\tif (len > get_unaligned_be32(buffer + 0x14)) {\n\t\tldm_error(\"len %d > BE32(buffer + 0x14) %d\", len,\n\t\t\t\tget_unaligned_be32(buffer + 0x14));\n\t\treturn false;\n\t}\n\tpart = &vb->vblk.part;\n\tpart->start = get_unaligned_be64(buffer + 0x24 + r_name);\n\tpart->volume_offset = get_unaligned_be64(buffer + 0x2C + r_name);\n\tpart->size = ldm_get_vnum(buffer + 0x34 + r_name);\n\tpart->parent_id = ldm_get_vnum(buffer + 0x34 + r_size);\n\tpart->disk_id = ldm_get_vnum(buffer + 0x34 + r_parent);\n\tif (vb->flags & VBLK_FLAG_PART_INDEX)\n\t\tpart->partnum = buffer[0x35 + r_diskid];\n\telse\n\t\tpart->partnum = 0;\n\treturn true;\n}\n\n \nstatic bool ldm_parse_vol5(const u8 *buffer, int buflen, struct vblk *vb)\n{\n\tint r_objid, r_name, r_vtype, r_disable_drive_letter, r_child, r_size;\n\tint r_id1, r_id2, r_size2, r_drive, len;\n\tstruct vblk_volu *volu;\n\n\tBUG_ON(!buffer || !vb);\n\tr_objid = ldm_relative(buffer, buflen, 0x18, 0);\n\tif (r_objid < 0) {\n\t\tldm_error(\"r_objid %d < 0\", r_objid);\n\t\treturn false;\n\t}\n\tr_name = ldm_relative(buffer, buflen, 0x18, r_objid);\n\tif (r_name < 0) {\n\t\tldm_error(\"r_name %d < 0\", r_name);\n\t\treturn false;\n\t}\n\tr_vtype = ldm_relative(buffer, buflen, 0x18, r_name);\n\tif (r_vtype < 0) {\n\t\tldm_error(\"r_vtype %d < 0\", r_vtype);\n\t\treturn false;\n\t}\n\tr_disable_drive_letter = ldm_relative(buffer, buflen, 0x18, r_vtype);\n\tif (r_disable_drive_letter < 0) {\n\t\tldm_error(\"r_disable_drive_letter %d < 0\",\n\t\t\t\tr_disable_drive_letter);\n\t\treturn false;\n\t}\n\tr_child = ldm_relative(buffer, buflen, 0x2D, r_disable_drive_letter);\n\tif (r_child < 0) {\n\t\tldm_error(\"r_child %d < 0\", r_child);\n\t\treturn false;\n\t}\n\tr_size = ldm_relative(buffer, buflen, 0x3D, r_child);\n\tif (r_size < 0) {\n\t\tldm_error(\"r_size %d < 0\", r_size);\n\t\treturn false;\n\t}\n\tif (buffer[0x12] & VBLK_FLAG_VOLU_ID1) {\n\t\tr_id1 = ldm_relative(buffer, buflen, 0x52, r_size);\n\t\tif (r_id1 < 0) {\n\t\t\tldm_error(\"r_id1 %d < 0\", r_id1);\n\t\t\treturn false;\n\t\t}\n\t} else\n\t\tr_id1 = r_size;\n\tif (buffer[0x12] & VBLK_FLAG_VOLU_ID2) {\n\t\tr_id2 = ldm_relative(buffer, buflen, 0x52, r_id1);\n\t\tif (r_id2 < 0) {\n\t\t\tldm_error(\"r_id2 %d < 0\", r_id2);\n\t\t\treturn false;\n\t\t}\n\t} else\n\t\tr_id2 = r_id1;\n\tif (buffer[0x12] & VBLK_FLAG_VOLU_SIZE) {\n\t\tr_size2 = ldm_relative(buffer, buflen, 0x52, r_id2);\n\t\tif (r_size2 < 0) {\n\t\t\tldm_error(\"r_size2 %d < 0\", r_size2);\n\t\t\treturn false;\n\t\t}\n\t} else\n\t\tr_size2 = r_id2;\n\tif (buffer[0x12] & VBLK_FLAG_VOLU_DRIVE) {\n\t\tr_drive = ldm_relative(buffer, buflen, 0x52, r_size2);\n\t\tif (r_drive < 0) {\n\t\t\tldm_error(\"r_drive %d < 0\", r_drive);\n\t\t\treturn false;\n\t\t}\n\t} else\n\t\tr_drive = r_size2;\n\tlen = r_drive;\n\tif (len < 0) {\n\t\tldm_error(\"len %d < 0\", len);\n\t\treturn false;\n\t}\n\tlen += VBLK_SIZE_VOL5;\n\tif (len > get_unaligned_be32(buffer + 0x14)) {\n\t\tldm_error(\"len %d > BE32(buffer + 0x14) %d\", len,\n\t\t\t\tget_unaligned_be32(buffer + 0x14));\n\t\treturn false;\n\t}\n\tvolu = &vb->vblk.volu;\n\tldm_get_vstr(buffer + 0x18 + r_name, volu->volume_type,\n\t\t\tsizeof(volu->volume_type));\n\tmemcpy(volu->volume_state, buffer + 0x18 + r_disable_drive_letter,\n\t\t\tsizeof(volu->volume_state));\n\tvolu->size = ldm_get_vnum(buffer + 0x3D + r_child);\n\tvolu->partition_type = buffer[0x41 + r_size];\n\tmemcpy(volu->guid, buffer + 0x42 + r_size, sizeof(volu->guid));\n\tif (buffer[0x12] & VBLK_FLAG_VOLU_DRIVE) {\n\t\tldm_get_vstr(buffer + 0x52 + r_size, volu->drive_hint,\n\t\t\t\tsizeof(volu->drive_hint));\n\t}\n\treturn true;\n}\n\n \nstatic bool ldm_parse_vblk (const u8 *buf, int len, struct vblk *vb)\n{\n\tbool result = false;\n\tint r_objid;\n\n\tBUG_ON (!buf || !vb);\n\n\tr_objid = ldm_relative (buf, len, 0x18, 0);\n\tif (r_objid < 0) {\n\t\tldm_error (\"VBLK header is corrupt.\");\n\t\treturn false;\n\t}\n\n\tvb->flags  = buf[0x12];\n\tvb->type   = buf[0x13];\n\tvb->obj_id = ldm_get_vnum (buf + 0x18);\n\tldm_get_vstr (buf+0x18+r_objid, vb->name, sizeof (vb->name));\n\n\tswitch (vb->type) {\n\t\tcase VBLK_CMP3:  result = ldm_parse_cmp3 (buf, len, vb); break;\n\t\tcase VBLK_DSK3:  result = ldm_parse_dsk3 (buf, len, vb); break;\n\t\tcase VBLK_DSK4:  result = ldm_parse_dsk4 (buf, len, vb); break;\n\t\tcase VBLK_DGR3:  result = ldm_parse_dgr3 (buf, len, vb); break;\n\t\tcase VBLK_DGR4:  result = ldm_parse_dgr4 (buf, len, vb); break;\n\t\tcase VBLK_PRT3:  result = ldm_parse_prt3 (buf, len, vb); break;\n\t\tcase VBLK_VOL5:  result = ldm_parse_vol5 (buf, len, vb); break;\n\t}\n\n\tif (result)\n\t\tldm_debug (\"Parsed VBLK 0x%llx (type: 0x%02x) ok.\",\n\t\t\t (unsigned long long) vb->obj_id, vb->type);\n\telse\n\t\tldm_error (\"Failed to parse VBLK 0x%llx (type: 0x%02x).\",\n\t\t\t(unsigned long long) vb->obj_id, vb->type);\n\n\treturn result;\n}\n\n\n \nstatic bool ldm_ldmdb_add (u8 *data, int len, struct ldmdb *ldb)\n{\n\tstruct vblk *vb;\n\tstruct list_head *item;\n\n\tBUG_ON (!data || !ldb);\n\n\tvb = kmalloc (sizeof (*vb), GFP_KERNEL);\n\tif (!vb) {\n\t\tldm_crit (\"Out of memory.\");\n\t\treturn false;\n\t}\n\n\tif (!ldm_parse_vblk (data, len, vb)) {\n\t\tkfree(vb);\n\t\treturn false;\t\t\t \n\t}\n\n\t \n\tswitch (vb->type) {\n\tcase VBLK_DGR3:\n\tcase VBLK_DGR4:\n\t\tlist_add (&vb->list, &ldb->v_dgrp);\n\t\tbreak;\n\tcase VBLK_DSK3:\n\tcase VBLK_DSK4:\n\t\tlist_add (&vb->list, &ldb->v_disk);\n\t\tbreak;\n\tcase VBLK_VOL5:\n\t\tlist_add (&vb->list, &ldb->v_volu);\n\t\tbreak;\n\tcase VBLK_CMP3:\n\t\tlist_add (&vb->list, &ldb->v_comp);\n\t\tbreak;\n\tcase VBLK_PRT3:\n\t\t \n\t\tlist_for_each (item, &ldb->v_part) {\n\t\t\tstruct vblk *v = list_entry (item, struct vblk, list);\n\t\t\tif ((v->vblk.part.disk_id == vb->vblk.part.disk_id) &&\n\t\t\t    (v->vblk.part.start > vb->vblk.part.start)) {\n\t\t\t\tlist_add_tail (&vb->list, &v->list);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tlist_add_tail (&vb->list, &ldb->v_part);\n\t\tbreak;\n\t}\n\treturn true;\n}\n\n \nstatic bool ldm_frag_add (const u8 *data, int size, struct list_head *frags)\n{\n\tstruct frag *f;\n\tstruct list_head *item;\n\tint rec, num, group;\n\n\tBUG_ON (!data || !frags);\n\n\tif (size < 2 * VBLK_SIZE_HEAD) {\n\t\tldm_error(\"Value of size is too small.\");\n\t\treturn false;\n\t}\n\n\tgroup = get_unaligned_be32(data + 0x08);\n\trec   = get_unaligned_be16(data + 0x0C);\n\tnum   = get_unaligned_be16(data + 0x0E);\n\tif ((num < 1) || (num > 4)) {\n\t\tldm_error (\"A VBLK claims to have %d parts.\", num);\n\t\treturn false;\n\t}\n\tif (rec >= num) {\n\t\tldm_error(\"REC value (%d) exceeds NUM value (%d)\", rec, num);\n\t\treturn false;\n\t}\n\n\tlist_for_each (item, frags) {\n\t\tf = list_entry (item, struct frag, list);\n\t\tif (f->group == group)\n\t\t\tgoto found;\n\t}\n\n\tf = kmalloc (sizeof (*f) + size*num, GFP_KERNEL);\n\tif (!f) {\n\t\tldm_crit (\"Out of memory.\");\n\t\treturn false;\n\t}\n\n\tf->group = group;\n\tf->num   = num;\n\tf->rec   = rec;\n\tf->map   = 0xFF << num;\n\n\tlist_add_tail (&f->list, frags);\nfound:\n\tif (rec >= f->num) {\n\t\tldm_error(\"REC value (%d) exceeds NUM value (%d)\", rec, f->num);\n\t\treturn false;\n\t}\n\tif (f->map & (1 << rec)) {\n\t\tldm_error (\"Duplicate VBLK, part %d.\", rec);\n\t\tf->map &= 0x7F;\t\t\t \n\t\treturn false;\n\t}\n\tf->map |= (1 << rec);\n\tif (!rec)\n\t\tmemcpy(f->data, data, VBLK_SIZE_HEAD);\n\tdata += VBLK_SIZE_HEAD;\n\tsize -= VBLK_SIZE_HEAD;\n\tmemcpy(f->data + VBLK_SIZE_HEAD + rec * size, data, size);\n\treturn true;\n}\n\n \nstatic void ldm_frag_free (struct list_head *list)\n{\n\tstruct list_head *item, *tmp;\n\n\tBUG_ON (!list);\n\n\tlist_for_each_safe (item, tmp, list)\n\t\tkfree (list_entry (item, struct frag, list));\n}\n\n \nstatic bool ldm_frag_commit (struct list_head *frags, struct ldmdb *ldb)\n{\n\tstruct frag *f;\n\tstruct list_head *item;\n\n\tBUG_ON (!frags || !ldb);\n\n\tlist_for_each (item, frags) {\n\t\tf = list_entry (item, struct frag, list);\n\n\t\tif (f->map != 0xFF) {\n\t\t\tldm_error (\"VBLK group %d is incomplete (0x%02x).\",\n\t\t\t\tf->group, f->map);\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!ldm_ldmdb_add (f->data, f->num*ldb->vm.vblk_size, ldb))\n\t\t\treturn false;\t\t \n\t}\n\treturn true;\n}\n\n \nstatic bool ldm_get_vblks(struct parsed_partitions *state, unsigned long base,\n\t\t\t  struct ldmdb *ldb)\n{\n\tint size, perbuf, skip, finish, s, v, recs;\n\tu8 *data = NULL;\n\tSector sect;\n\tbool result = false;\n\tLIST_HEAD (frags);\n\n\tBUG_ON(!state || !ldb);\n\n\tsize   = ldb->vm.vblk_size;\n\tperbuf = 512 / size;\n\tskip   = ldb->vm.vblk_offset >> 9;\t\t \n\tfinish = (size * ldb->vm.last_vblk_seq) >> 9;\n\n\tfor (s = skip; s < finish; s++) {\t\t \n\t\tdata = read_part_sector(state, base + OFF_VMDB + s, &sect);\n\t\tif (!data) {\n\t\t\tldm_crit (\"Disk read failed.\");\n\t\t\tgoto out;\n\t\t}\n\n\t\tfor (v = 0; v < perbuf; v++, data+=size) {   \n\t\t\tif (MAGIC_VBLK != get_unaligned_be32(data)) {\n\t\t\t\tldm_error (\"Expected to find a VBLK.\");\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\trecs = get_unaligned_be16(data + 0x0E);\t \n\t\t\tif (recs == 1) {\n\t\t\t\tif (!ldm_ldmdb_add (data, size, ldb))\n\t\t\t\t\tgoto out;\t \n\t\t\t} else if (recs > 1) {\n\t\t\t\tif (!ldm_frag_add (data, size, &frags))\n\t\t\t\t\tgoto out;\t \n\t\t\t}\n\t\t\t \n\t\t}\n\t\tput_dev_sector (sect);\n\t\tdata = NULL;\n\t}\n\n\tresult = ldm_frag_commit (&frags, ldb);\t \nout:\n\tif (data)\n\t\tput_dev_sector (sect);\n\tldm_frag_free (&frags);\n\n\treturn result;\n}\n\n \nstatic void ldm_free_vblks (struct list_head *lh)\n{\n\tstruct list_head *item, *tmp;\n\n\tBUG_ON (!lh);\n\n\tlist_for_each_safe (item, tmp, lh)\n\t\tkfree (list_entry (item, struct vblk, list));\n}\n\n\n \nint ldm_partition(struct parsed_partitions *state)\n{\n\tstruct ldmdb  *ldb;\n\tunsigned long base;\n\tint result = -1;\n\n\tBUG_ON(!state);\n\n\t \n\tif (!ldm_validate_partition_table(state))\n\t\treturn 0;\n\n\tldb = kmalloc (sizeof (*ldb), GFP_KERNEL);\n\tif (!ldb) {\n\t\tldm_crit (\"Out of memory.\");\n\t\tgoto out;\n\t}\n\n\t \n\tif (!ldm_validate_privheads(state, &ldb->ph))\n\t\tgoto out;\t\t \n\n\t \n\tbase = ldb->ph.config_start;\n\n\t \n\tif (!ldm_validate_tocblocks(state, base, ldb) ||\n\t    !ldm_validate_vmdb(state, base, ldb))\n\t    \tgoto out;\t\t \n\n\t \n\tINIT_LIST_HEAD (&ldb->v_dgrp);\n\tINIT_LIST_HEAD (&ldb->v_disk);\n\tINIT_LIST_HEAD (&ldb->v_volu);\n\tINIT_LIST_HEAD (&ldb->v_comp);\n\tINIT_LIST_HEAD (&ldb->v_part);\n\n\tif (!ldm_get_vblks(state, base, ldb)) {\n\t\tldm_crit (\"Failed to read the VBLKs from the database.\");\n\t\tgoto cleanup;\n\t}\n\n\t \n\tif (ldm_create_data_partitions(state, ldb)) {\n\t\tldm_debug (\"Parsed LDM database successfully.\");\n\t\tresult = 1;\n\t}\n\t \n\ncleanup:\n\tldm_free_vblks (&ldb->v_dgrp);\n\tldm_free_vblks (&ldb->v_disk);\n\tldm_free_vblks (&ldb->v_volu);\n\tldm_free_vblks (&ldb->v_comp);\n\tldm_free_vblks (&ldb->v_part);\nout:\n\tkfree (ldb);\n\treturn result;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}