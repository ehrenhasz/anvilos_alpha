{
  "module_name": "blk-timeout.c",
  "hash_id": "fae00bd01c6613463ab9b84805b77471abc94dfd09e67e16b880d1d10d7dc82b",
  "original_prompt": "Ingested from linux-6.6.14/block/blk-timeout.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/fault-inject.h>\n\n#include \"blk.h\"\n#include \"blk-mq.h\"\n\n#ifdef CONFIG_FAIL_IO_TIMEOUT\n\nstatic DECLARE_FAULT_ATTR(fail_io_timeout);\n\nstatic int __init setup_fail_io_timeout(char *str)\n{\n\treturn setup_fault_attr(&fail_io_timeout, str);\n}\n__setup(\"fail_io_timeout=\", setup_fail_io_timeout);\n\nbool __blk_should_fake_timeout(struct request_queue *q)\n{\n\treturn should_fail(&fail_io_timeout, 1);\n}\nEXPORT_SYMBOL_GPL(__blk_should_fake_timeout);\n\nstatic int __init fail_io_timeout_debugfs(void)\n{\n\tstruct dentry *dir = fault_create_debugfs_attr(\"fail_io_timeout\",\n\t\t\t\t\t\tNULL, &fail_io_timeout);\n\n\treturn PTR_ERR_OR_ZERO(dir);\n}\n\nlate_initcall(fail_io_timeout_debugfs);\n\nssize_t part_timeout_show(struct device *dev, struct device_attribute *attr,\n\t\t\t  char *buf)\n{\n\tstruct gendisk *disk = dev_to_disk(dev);\n\tint set = test_bit(QUEUE_FLAG_FAIL_IO, &disk->queue->queue_flags);\n\n\treturn sprintf(buf, \"%d\\n\", set != 0);\n}\n\nssize_t part_timeout_store(struct device *dev, struct device_attribute *attr,\n\t\t\t   const char *buf, size_t count)\n{\n\tstruct gendisk *disk = dev_to_disk(dev);\n\tint val;\n\n\tif (count) {\n\t\tstruct request_queue *q = disk->queue;\n\t\tchar *p = (char *) buf;\n\n\t\tval = simple_strtoul(p, &p, 10);\n\t\tif (val)\n\t\t\tblk_queue_flag_set(QUEUE_FLAG_FAIL_IO, q);\n\t\telse\n\t\t\tblk_queue_flag_clear(QUEUE_FLAG_FAIL_IO, q);\n\t}\n\n\treturn count;\n}\n\n#endif  \n\n \nvoid blk_abort_request(struct request *req)\n{\n\t \n\tWRITE_ONCE(req->deadline, jiffies);\n\tkblockd_schedule_work(&req->q->timeout_work);\n}\nEXPORT_SYMBOL_GPL(blk_abort_request);\n\nstatic unsigned long blk_timeout_mask __read_mostly;\n\nstatic int __init blk_timeout_init(void)\n{\n\tblk_timeout_mask = roundup_pow_of_two(HZ) - 1;\n\treturn 0;\n}\n\nlate_initcall(blk_timeout_init);\n\n \nstatic inline unsigned long blk_round_jiffies(unsigned long j)\n{\n\treturn (j + blk_timeout_mask) + 1;\n}\n\nunsigned long blk_rq_timeout(unsigned long timeout)\n{\n\tunsigned long maxt;\n\n\tmaxt = blk_round_jiffies(jiffies + BLK_MAX_TIMEOUT);\n\tif (time_after(timeout, maxt))\n\t\ttimeout = maxt;\n\n\treturn timeout;\n}\n\n \nvoid blk_add_timer(struct request *req)\n{\n\tstruct request_queue *q = req->q;\n\tunsigned long expiry;\n\n\t \n\tif (!req->timeout)\n\t\treq->timeout = q->rq_timeout;\n\n\treq->rq_flags &= ~RQF_TIMED_OUT;\n\n\texpiry = jiffies + req->timeout;\n\tWRITE_ONCE(req->deadline, expiry);\n\n\t \n\texpiry = blk_rq_timeout(blk_round_jiffies(expiry));\n\n\tif (!timer_pending(&q->timeout) ||\n\t    time_before(expiry, q->timeout.expires)) {\n\t\tunsigned long diff = q->timeout.expires - expiry;\n\n\t\t \n\t\tif (!timer_pending(&q->timeout) || (diff >= HZ / 2))\n\t\t\tmod_timer(&q->timeout, expiry);\n\t}\n\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}