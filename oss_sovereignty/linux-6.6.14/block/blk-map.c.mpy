{
  "module_name": "blk-map.c",
  "hash_id": "504de8acad7ec79ba7d1b6cc312faa4e04b8d6f5b366ac5f84a27c15ca1c90ec",
  "original_prompt": "Ingested from linux-6.6.14/block/blk-map.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n#include <linux/sched/task_stack.h>\n#include <linux/module.h>\n#include <linux/bio.h>\n#include <linux/blkdev.h>\n#include <linux/uio.h>\n\n#include \"blk.h\"\n\nstruct bio_map_data {\n\tbool is_our_pages : 1;\n\tbool is_null_mapped : 1;\n\tstruct iov_iter iter;\n\tstruct iovec iov[];\n};\n\nstatic struct bio_map_data *bio_alloc_map_data(struct iov_iter *data,\n\t\t\t\t\t       gfp_t gfp_mask)\n{\n\tstruct bio_map_data *bmd;\n\n\tif (data->nr_segs > UIO_MAXIOV)\n\t\treturn NULL;\n\n\tbmd = kmalloc(struct_size(bmd, iov, data->nr_segs), gfp_mask);\n\tif (!bmd)\n\t\treturn NULL;\n\tbmd->iter = *data;\n\tif (iter_is_iovec(data)) {\n\t\tmemcpy(bmd->iov, iter_iov(data), sizeof(struct iovec) * data->nr_segs);\n\t\tbmd->iter.__iov = bmd->iov;\n\t}\n\treturn bmd;\n}\n\n \nstatic int bio_copy_from_iter(struct bio *bio, struct iov_iter *iter)\n{\n\tstruct bio_vec *bvec;\n\tstruct bvec_iter_all iter_all;\n\n\tbio_for_each_segment_all(bvec, bio, iter_all) {\n\t\tssize_t ret;\n\n\t\tret = copy_page_from_iter(bvec->bv_page,\n\t\t\t\t\t  bvec->bv_offset,\n\t\t\t\t\t  bvec->bv_len,\n\t\t\t\t\t  iter);\n\n\t\tif (!iov_iter_count(iter))\n\t\t\tbreak;\n\n\t\tif (ret < bvec->bv_len)\n\t\t\treturn -EFAULT;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int bio_copy_to_iter(struct bio *bio, struct iov_iter iter)\n{\n\tstruct bio_vec *bvec;\n\tstruct bvec_iter_all iter_all;\n\n\tbio_for_each_segment_all(bvec, bio, iter_all) {\n\t\tssize_t ret;\n\n\t\tret = copy_page_to_iter(bvec->bv_page,\n\t\t\t\t\tbvec->bv_offset,\n\t\t\t\t\tbvec->bv_len,\n\t\t\t\t\t&iter);\n\n\t\tif (!iov_iter_count(&iter))\n\t\t\tbreak;\n\n\t\tif (ret < bvec->bv_len)\n\t\t\treturn -EFAULT;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int bio_uncopy_user(struct bio *bio)\n{\n\tstruct bio_map_data *bmd = bio->bi_private;\n\tint ret = 0;\n\n\tif (!bmd->is_null_mapped) {\n\t\t \n\t\tif (!current->mm)\n\t\t\tret = -EINTR;\n\t\telse if (bio_data_dir(bio) == READ)\n\t\t\tret = bio_copy_to_iter(bio, bmd->iter);\n\t\tif (bmd->is_our_pages)\n\t\t\tbio_free_pages(bio);\n\t}\n\tkfree(bmd);\n\treturn ret;\n}\n\nstatic int bio_copy_user_iov(struct request *rq, struct rq_map_data *map_data,\n\t\tstruct iov_iter *iter, gfp_t gfp_mask)\n{\n\tstruct bio_map_data *bmd;\n\tstruct page *page;\n\tstruct bio *bio;\n\tint i = 0, ret;\n\tint nr_pages;\n\tunsigned int len = iter->count;\n\tunsigned int offset = map_data ? offset_in_page(map_data->offset) : 0;\n\n\tbmd = bio_alloc_map_data(iter, gfp_mask);\n\tif (!bmd)\n\t\treturn -ENOMEM;\n\n\t \n\tbmd->is_our_pages = !map_data;\n\tbmd->is_null_mapped = (map_data && map_data->null_mapped);\n\n\tnr_pages = bio_max_segs(DIV_ROUND_UP(offset + len, PAGE_SIZE));\n\n\tret = -ENOMEM;\n\tbio = bio_kmalloc(nr_pages, gfp_mask);\n\tif (!bio)\n\t\tgoto out_bmd;\n\tbio_init(bio, NULL, bio->bi_inline_vecs, nr_pages, req_op(rq));\n\n\tif (map_data) {\n\t\tnr_pages = 1U << map_data->page_order;\n\t\ti = map_data->offset / PAGE_SIZE;\n\t}\n\twhile (len) {\n\t\tunsigned int bytes = PAGE_SIZE;\n\n\t\tbytes -= offset;\n\n\t\tif (bytes > len)\n\t\t\tbytes = len;\n\n\t\tif (map_data) {\n\t\t\tif (i == map_data->nr_entries * nr_pages) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\n\t\t\tpage = map_data->pages[i / nr_pages];\n\t\t\tpage += (i % nr_pages);\n\n\t\t\ti++;\n\t\t} else {\n\t\t\tpage = alloc_page(GFP_NOIO | gfp_mask);\n\t\t\tif (!page) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t}\n\n\t\tif (bio_add_pc_page(rq->q, bio, page, bytes, offset) < bytes) {\n\t\t\tif (!map_data)\n\t\t\t\t__free_page(page);\n\t\t\tbreak;\n\t\t}\n\n\t\tlen -= bytes;\n\t\toffset = 0;\n\t}\n\n\tif (map_data)\n\t\tmap_data->offset += bio->bi_iter.bi_size;\n\n\t \n\tif ((iov_iter_rw(iter) == WRITE &&\n\t     (!map_data || !map_data->null_mapped)) ||\n\t    (map_data && map_data->from_user)) {\n\t\tret = bio_copy_from_iter(bio, iter);\n\t\tif (ret)\n\t\t\tgoto cleanup;\n\t} else {\n\t\tif (bmd->is_our_pages)\n\t\t\tzero_fill_bio(bio);\n\t\tiov_iter_advance(iter, bio->bi_iter.bi_size);\n\t}\n\n\tbio->bi_private = bmd;\n\n\tret = blk_rq_append_bio(rq, bio);\n\tif (ret)\n\t\tgoto cleanup;\n\treturn 0;\ncleanup:\n\tif (!map_data)\n\t\tbio_free_pages(bio);\n\tbio_uninit(bio);\n\tkfree(bio);\nout_bmd:\n\tkfree(bmd);\n\treturn ret;\n}\n\nstatic void blk_mq_map_bio_put(struct bio *bio)\n{\n\tif (bio->bi_opf & REQ_ALLOC_CACHE) {\n\t\tbio_put(bio);\n\t} else {\n\t\tbio_uninit(bio);\n\t\tkfree(bio);\n\t}\n}\n\nstatic struct bio *blk_rq_map_bio_alloc(struct request *rq,\n\t\tunsigned int nr_vecs, gfp_t gfp_mask)\n{\n\tstruct bio *bio;\n\n\tif (rq->cmd_flags & REQ_ALLOC_CACHE && (nr_vecs <= BIO_INLINE_VECS)) {\n\t\tbio = bio_alloc_bioset(NULL, nr_vecs, rq->cmd_flags, gfp_mask,\n\t\t\t\t\t&fs_bio_set);\n\t\tif (!bio)\n\t\t\treturn NULL;\n\t} else {\n\t\tbio = bio_kmalloc(nr_vecs, gfp_mask);\n\t\tif (!bio)\n\t\t\treturn NULL;\n\t\tbio_init(bio, NULL, bio->bi_inline_vecs, nr_vecs, req_op(rq));\n\t}\n\treturn bio;\n}\n\nstatic int bio_map_user_iov(struct request *rq, struct iov_iter *iter,\n\t\tgfp_t gfp_mask)\n{\n\tiov_iter_extraction_t extraction_flags = 0;\n\tunsigned int max_sectors = queue_max_hw_sectors(rq->q);\n\tunsigned int nr_vecs = iov_iter_npages(iter, BIO_MAX_VECS);\n\tstruct bio *bio;\n\tint ret;\n\tint j;\n\n\tif (!iov_iter_count(iter))\n\t\treturn -EINVAL;\n\n\tbio = blk_rq_map_bio_alloc(rq, nr_vecs, gfp_mask);\n\tif (bio == NULL)\n\t\treturn -ENOMEM;\n\n\tif (blk_queue_pci_p2pdma(rq->q))\n\t\textraction_flags |= ITER_ALLOW_P2PDMA;\n\tif (iov_iter_extract_will_pin(iter))\n\t\tbio_set_flag(bio, BIO_PAGE_PINNED);\n\n\twhile (iov_iter_count(iter)) {\n\t\tstruct page *stack_pages[UIO_FASTIOV];\n\t\tstruct page **pages = stack_pages;\n\t\tssize_t bytes;\n\t\tsize_t offs;\n\t\tint npages;\n\n\t\tif (nr_vecs > ARRAY_SIZE(stack_pages))\n\t\t\tpages = NULL;\n\n\t\tbytes = iov_iter_extract_pages(iter, &pages, LONG_MAX,\n\t\t\t\t\t       nr_vecs, extraction_flags, &offs);\n\t\tif (unlikely(bytes <= 0)) {\n\t\t\tret = bytes ? bytes : -EFAULT;\n\t\t\tgoto out_unmap;\n\t\t}\n\n\t\tnpages = DIV_ROUND_UP(offs + bytes, PAGE_SIZE);\n\n\t\tif (unlikely(offs & queue_dma_alignment(rq->q)))\n\t\t\tj = 0;\n\t\telse {\n\t\t\tfor (j = 0; j < npages; j++) {\n\t\t\t\tstruct page *page = pages[j];\n\t\t\t\tunsigned int n = PAGE_SIZE - offs;\n\t\t\t\tbool same_page = false;\n\n\t\t\t\tif (n > bytes)\n\t\t\t\t\tn = bytes;\n\n\t\t\t\tif (!bio_add_hw_page(rq->q, bio, page, n, offs,\n\t\t\t\t\t\t     max_sectors, &same_page))\n\t\t\t\t\tbreak;\n\n\t\t\t\tif (same_page)\n\t\t\t\t\tbio_release_page(bio, page);\n\t\t\t\tbytes -= n;\n\t\t\t\toffs = 0;\n\t\t\t}\n\t\t}\n\t\t \n\t\twhile (j < npages)\n\t\t\tbio_release_page(bio, pages[j++]);\n\t\tif (pages != stack_pages)\n\t\t\tkvfree(pages);\n\t\t \n\t\tif (bytes) {\n\t\t\tiov_iter_revert(iter, bytes);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tret = blk_rq_append_bio(rq, bio);\n\tif (ret)\n\t\tgoto out_unmap;\n\treturn 0;\n\n out_unmap:\n\tbio_release_pages(bio, false);\n\tblk_mq_map_bio_put(bio);\n\treturn ret;\n}\n\nstatic void bio_invalidate_vmalloc_pages(struct bio *bio)\n{\n#ifdef ARCH_IMPLEMENTS_FLUSH_KERNEL_VMAP_RANGE\n\tif (bio->bi_private && !op_is_write(bio_op(bio))) {\n\t\tunsigned long i, len = 0;\n\n\t\tfor (i = 0; i < bio->bi_vcnt; i++)\n\t\t\tlen += bio->bi_io_vec[i].bv_len;\n\t\tinvalidate_kernel_vmap_range(bio->bi_private, len);\n\t}\n#endif\n}\n\nstatic void bio_map_kern_endio(struct bio *bio)\n{\n\tbio_invalidate_vmalloc_pages(bio);\n\tbio_uninit(bio);\n\tkfree(bio);\n}\n\n \nstatic struct bio *bio_map_kern(struct request_queue *q, void *data,\n\t\tunsigned int len, gfp_t gfp_mask)\n{\n\tunsigned long kaddr = (unsigned long)data;\n\tunsigned long end = (kaddr + len + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\tunsigned long start = kaddr >> PAGE_SHIFT;\n\tconst int nr_pages = end - start;\n\tbool is_vmalloc = is_vmalloc_addr(data);\n\tstruct page *page;\n\tint offset, i;\n\tstruct bio *bio;\n\n\tbio = bio_kmalloc(nr_pages, gfp_mask);\n\tif (!bio)\n\t\treturn ERR_PTR(-ENOMEM);\n\tbio_init(bio, NULL, bio->bi_inline_vecs, nr_pages, 0);\n\n\tif (is_vmalloc) {\n\t\tflush_kernel_vmap_range(data, len);\n\t\tbio->bi_private = data;\n\t}\n\n\toffset = offset_in_page(kaddr);\n\tfor (i = 0; i < nr_pages; i++) {\n\t\tunsigned int bytes = PAGE_SIZE - offset;\n\n\t\tif (len <= 0)\n\t\t\tbreak;\n\n\t\tif (bytes > len)\n\t\t\tbytes = len;\n\n\t\tif (!is_vmalloc)\n\t\t\tpage = virt_to_page(data);\n\t\telse\n\t\t\tpage = vmalloc_to_page(data);\n\t\tif (bio_add_pc_page(q, bio, page, bytes,\n\t\t\t\t    offset) < bytes) {\n\t\t\t \n\t\t\tbio_uninit(bio);\n\t\t\tkfree(bio);\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\t}\n\n\t\tdata += bytes;\n\t\tlen -= bytes;\n\t\toffset = 0;\n\t}\n\n\tbio->bi_end_io = bio_map_kern_endio;\n\treturn bio;\n}\n\nstatic void bio_copy_kern_endio(struct bio *bio)\n{\n\tbio_free_pages(bio);\n\tbio_uninit(bio);\n\tkfree(bio);\n}\n\nstatic void bio_copy_kern_endio_read(struct bio *bio)\n{\n\tchar *p = bio->bi_private;\n\tstruct bio_vec *bvec;\n\tstruct bvec_iter_all iter_all;\n\n\tbio_for_each_segment_all(bvec, bio, iter_all) {\n\t\tmemcpy_from_bvec(p, bvec);\n\t\tp += bvec->bv_len;\n\t}\n\n\tbio_copy_kern_endio(bio);\n}\n\n \nstatic struct bio *bio_copy_kern(struct request_queue *q, void *data,\n\t\tunsigned int len, gfp_t gfp_mask, int reading)\n{\n\tunsigned long kaddr = (unsigned long)data;\n\tunsigned long end = (kaddr + len + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\tunsigned long start = kaddr >> PAGE_SHIFT;\n\tstruct bio *bio;\n\tvoid *p = data;\n\tint nr_pages = 0;\n\n\t \n\tif (end < start)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tnr_pages = end - start;\n\tbio = bio_kmalloc(nr_pages, gfp_mask);\n\tif (!bio)\n\t\treturn ERR_PTR(-ENOMEM);\n\tbio_init(bio, NULL, bio->bi_inline_vecs, nr_pages, 0);\n\n\twhile (len) {\n\t\tstruct page *page;\n\t\tunsigned int bytes = PAGE_SIZE;\n\n\t\tif (bytes > len)\n\t\t\tbytes = len;\n\n\t\tpage = alloc_page(GFP_NOIO | __GFP_ZERO | gfp_mask);\n\t\tif (!page)\n\t\t\tgoto cleanup;\n\n\t\tif (!reading)\n\t\t\tmemcpy(page_address(page), p, bytes);\n\n\t\tif (bio_add_pc_page(q, bio, page, bytes, 0) < bytes)\n\t\t\tbreak;\n\n\t\tlen -= bytes;\n\t\tp += bytes;\n\t}\n\n\tif (reading) {\n\t\tbio->bi_end_io = bio_copy_kern_endio_read;\n\t\tbio->bi_private = data;\n\t} else {\n\t\tbio->bi_end_io = bio_copy_kern_endio;\n\t}\n\n\treturn bio;\n\ncleanup:\n\tbio_free_pages(bio);\n\tbio_uninit(bio);\n\tkfree(bio);\n\treturn ERR_PTR(-ENOMEM);\n}\n\n \nint blk_rq_append_bio(struct request *rq, struct bio *bio)\n{\n\tstruct bvec_iter iter;\n\tstruct bio_vec bv;\n\tunsigned int nr_segs = 0;\n\n\tbio_for_each_bvec(bv, bio, iter)\n\t\tnr_segs++;\n\n\tif (!rq->bio) {\n\t\tblk_rq_bio_prep(rq, bio, nr_segs);\n\t} else {\n\t\tif (!ll_back_merge_fn(rq, bio, nr_segs))\n\t\t\treturn -EINVAL;\n\t\trq->biotail->bi_next = bio;\n\t\trq->biotail = bio;\n\t\trq->__data_len += (bio)->bi_iter.bi_size;\n\t\tbio_crypt_free_ctx(bio);\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(blk_rq_append_bio);\n\n \nstatic int blk_rq_map_user_bvec(struct request *rq, const struct iov_iter *iter)\n{\n\tstruct request_queue *q = rq->q;\n\tsize_t nr_iter = iov_iter_count(iter);\n\tsize_t nr_segs = iter->nr_segs;\n\tstruct bio_vec *bvecs, *bvprvp = NULL;\n\tconst struct queue_limits *lim = &q->limits;\n\tunsigned int nsegs = 0, bytes = 0;\n\tstruct bio *bio;\n\tsize_t i;\n\n\tif (!nr_iter || (nr_iter >> SECTOR_SHIFT) > queue_max_hw_sectors(q))\n\t\treturn -EINVAL;\n\tif (nr_segs > queue_max_segments(q))\n\t\treturn -EINVAL;\n\n\t \n\tbio = blk_rq_map_bio_alloc(rq, 0, GFP_KERNEL);\n\tif (bio == NULL)\n\t\treturn -ENOMEM;\n\n\tbio_iov_bvec_set(bio, (struct iov_iter *)iter);\n\tblk_rq_bio_prep(rq, bio, nr_segs);\n\n\t \n\tbvecs = (struct bio_vec *)iter->bvec;\n\tfor (i = 0; i < nr_segs; i++) {\n\t\tstruct bio_vec *bv = &bvecs[i];\n\n\t\t \n\t\tif (bvprvp && bvec_gap_to_prev(lim, bvprvp, bv->bv_offset)) {\n\t\t\tblk_mq_map_bio_put(bio);\n\t\t\treturn -EREMOTEIO;\n\t\t}\n\t\t \n\t\tif (nsegs >= nr_segs || bytes > UINT_MAX - bv->bv_len)\n\t\t\tgoto put_bio;\n\t\tif (bytes + bv->bv_len > nr_iter)\n\t\t\tgoto put_bio;\n\t\tif (bv->bv_offset + bv->bv_len > PAGE_SIZE)\n\t\t\tgoto put_bio;\n\n\t\tnsegs++;\n\t\tbytes += bv->bv_len;\n\t\tbvprvp = bv;\n\t}\n\treturn 0;\nput_bio:\n\tblk_mq_map_bio_put(bio);\n\treturn -EINVAL;\n}\n\n \nint blk_rq_map_user_iov(struct request_queue *q, struct request *rq,\n\t\t\tstruct rq_map_data *map_data,\n\t\t\tconst struct iov_iter *iter, gfp_t gfp_mask)\n{\n\tbool copy = false, map_bvec = false;\n\tunsigned long align = q->dma_pad_mask | queue_dma_alignment(q);\n\tstruct bio *bio = NULL;\n\tstruct iov_iter i;\n\tint ret = -EINVAL;\n\n\tif (map_data)\n\t\tcopy = true;\n\telse if (blk_queue_may_bounce(q))\n\t\tcopy = true;\n\telse if (iov_iter_alignment(iter) & align)\n\t\tcopy = true;\n\telse if (iov_iter_is_bvec(iter))\n\t\tmap_bvec = true;\n\telse if (!user_backed_iter(iter))\n\t\tcopy = true;\n\telse if (queue_virt_boundary(q))\n\t\tcopy = queue_virt_boundary(q) & iov_iter_gap_alignment(iter);\n\n\tif (map_bvec) {\n\t\tret = blk_rq_map_user_bvec(rq, iter);\n\t\tif (!ret)\n\t\t\treturn 0;\n\t\tif (ret != -EREMOTEIO)\n\t\t\tgoto fail;\n\t\t \n\t\tcopy = true;\n\t}\n\n\ti = *iter;\n\tdo {\n\t\tif (copy)\n\t\t\tret = bio_copy_user_iov(rq, map_data, &i, gfp_mask);\n\t\telse\n\t\t\tret = bio_map_user_iov(rq, &i, gfp_mask);\n\t\tif (ret)\n\t\t\tgoto unmap_rq;\n\t\tif (!bio)\n\t\t\tbio = rq->bio;\n\t} while (iov_iter_count(&i));\n\n\treturn 0;\n\nunmap_rq:\n\tblk_rq_unmap_user(bio);\nfail:\n\trq->bio = NULL;\n\treturn ret;\n}\nEXPORT_SYMBOL(blk_rq_map_user_iov);\n\nint blk_rq_map_user(struct request_queue *q, struct request *rq,\n\t\t    struct rq_map_data *map_data, void __user *ubuf,\n\t\t    unsigned long len, gfp_t gfp_mask)\n{\n\tstruct iov_iter i;\n\tint ret = import_ubuf(rq_data_dir(rq), ubuf, len, &i);\n\n\tif (unlikely(ret < 0))\n\t\treturn ret;\n\n\treturn blk_rq_map_user_iov(q, rq, map_data, &i, gfp_mask);\n}\nEXPORT_SYMBOL(blk_rq_map_user);\n\nint blk_rq_map_user_io(struct request *req, struct rq_map_data *map_data,\n\t\tvoid __user *ubuf, unsigned long buf_len, gfp_t gfp_mask,\n\t\tbool vec, int iov_count, bool check_iter_count, int rw)\n{\n\tint ret = 0;\n\n\tif (vec) {\n\t\tstruct iovec fast_iov[UIO_FASTIOV];\n\t\tstruct iovec *iov = fast_iov;\n\t\tstruct iov_iter iter;\n\n\t\tret = import_iovec(rw, ubuf, iov_count ? iov_count : buf_len,\n\t\t\t\tUIO_FASTIOV, &iov, &iter);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tif (iov_count) {\n\t\t\t \n\t\t\tiov_iter_truncate(&iter, buf_len);\n\t\t\tif (check_iter_count && !iov_iter_count(&iter)) {\n\t\t\t\tkfree(iov);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\n\t\tret = blk_rq_map_user_iov(req->q, req, map_data, &iter,\n\t\t\t\tgfp_mask);\n\t\tkfree(iov);\n\t} else if (buf_len) {\n\t\tret = blk_rq_map_user(req->q, req, map_data, ubuf, buf_len,\n\t\t\t\tgfp_mask);\n\t}\n\treturn ret;\n}\nEXPORT_SYMBOL(blk_rq_map_user_io);\n\n \nint blk_rq_unmap_user(struct bio *bio)\n{\n\tstruct bio *next_bio;\n\tint ret = 0, ret2;\n\n\twhile (bio) {\n\t\tif (bio->bi_private) {\n\t\t\tret2 = bio_uncopy_user(bio);\n\t\t\tif (ret2 && !ret)\n\t\t\t\tret = ret2;\n\t\t} else {\n\t\t\tbio_release_pages(bio, bio_data_dir(bio) == READ);\n\t\t}\n\n\t\tnext_bio = bio;\n\t\tbio = bio->bi_next;\n\t\tblk_mq_map_bio_put(next_bio);\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL(blk_rq_unmap_user);\n\n \nint blk_rq_map_kern(struct request_queue *q, struct request *rq, void *kbuf,\n\t\t    unsigned int len, gfp_t gfp_mask)\n{\n\tint reading = rq_data_dir(rq) == READ;\n\tunsigned long addr = (unsigned long) kbuf;\n\tstruct bio *bio;\n\tint ret;\n\n\tif (len > (queue_max_hw_sectors(q) << 9))\n\t\treturn -EINVAL;\n\tif (!len || !kbuf)\n\t\treturn -EINVAL;\n\n\tif (!blk_rq_aligned(q, addr, len) || object_is_on_stack(kbuf) ||\n\t    blk_queue_may_bounce(q))\n\t\tbio = bio_copy_kern(q, kbuf, len, gfp_mask, reading);\n\telse\n\t\tbio = bio_map_kern(q, kbuf, len, gfp_mask);\n\n\tif (IS_ERR(bio))\n\t\treturn PTR_ERR(bio);\n\n\tbio->bi_opf &= ~REQ_OP_MASK;\n\tbio->bi_opf |= req_op(rq);\n\n\tret = blk_rq_append_bio(rq, bio);\n\tif (unlikely(ret)) {\n\t\tbio_uninit(bio);\n\t\tkfree(bio);\n\t}\n\treturn ret;\n}\nEXPORT_SYMBOL(blk_rq_map_kern);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}