{
  "module_name": "fops.c",
  "hash_id": "2d48b3c71ebab897738e33929c810904bec043f4f865d52f611afbb1abeccf82",
  "original_prompt": "Ingested from linux-6.6.14/block/fops.c",
  "human_readable_source": "\n \n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/mpage.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/falloc.h>\n#include <linux/suspend.h>\n#include <linux/fs.h>\n#include <linux/iomap.h>\n#include <linux/module.h>\n#include \"blk.h\"\n\nstatic inline struct inode *bdev_file_inode(struct file *file)\n{\n\treturn file->f_mapping->host;\n}\n\nstatic blk_opf_t dio_bio_write_op(struct kiocb *iocb)\n{\n\tblk_opf_t opf = REQ_OP_WRITE | REQ_SYNC | REQ_IDLE;\n\n\t \n\tif (iocb_is_dsync(iocb))\n\t\topf |= REQ_FUA;\n\treturn opf;\n}\n\nstatic bool blkdev_dio_unaligned(struct block_device *bdev, loff_t pos,\n\t\t\t      struct iov_iter *iter)\n{\n\treturn pos & (bdev_logical_block_size(bdev) - 1) ||\n\t\t!bdev_iter_is_aligned(bdev, iter);\n}\n\n#define DIO_INLINE_BIO_VECS 4\n\nstatic ssize_t __blkdev_direct_IO_simple(struct kiocb *iocb,\n\t\tstruct iov_iter *iter, unsigned int nr_pages)\n{\n\tstruct block_device *bdev = I_BDEV(iocb->ki_filp->f_mapping->host);\n\tstruct bio_vec inline_vecs[DIO_INLINE_BIO_VECS], *vecs;\n\tloff_t pos = iocb->ki_pos;\n\tbool should_dirty = false;\n\tstruct bio bio;\n\tssize_t ret;\n\n\tif (blkdev_dio_unaligned(bdev, pos, iter))\n\t\treturn -EINVAL;\n\n\tif (nr_pages <= DIO_INLINE_BIO_VECS)\n\t\tvecs = inline_vecs;\n\telse {\n\t\tvecs = kmalloc_array(nr_pages, sizeof(struct bio_vec),\n\t\t\t\t     GFP_KERNEL);\n\t\tif (!vecs)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tif (iov_iter_rw(iter) == READ) {\n\t\tbio_init(&bio, bdev, vecs, nr_pages, REQ_OP_READ);\n\t\tif (user_backed_iter(iter))\n\t\t\tshould_dirty = true;\n\t} else {\n\t\tbio_init(&bio, bdev, vecs, nr_pages, dio_bio_write_op(iocb));\n\t}\n\tbio.bi_iter.bi_sector = pos >> SECTOR_SHIFT;\n\tbio.bi_ioprio = iocb->ki_ioprio;\n\n\tret = bio_iov_iter_get_pages(&bio, iter);\n\tif (unlikely(ret))\n\t\tgoto out;\n\tret = bio.bi_iter.bi_size;\n\n\tif (iov_iter_rw(iter) == WRITE)\n\t\ttask_io_account_write(ret);\n\n\tif (iocb->ki_flags & IOCB_NOWAIT)\n\t\tbio.bi_opf |= REQ_NOWAIT;\n\n\tsubmit_bio_wait(&bio);\n\n\tbio_release_pages(&bio, should_dirty);\n\tif (unlikely(bio.bi_status))\n\t\tret = blk_status_to_errno(bio.bi_status);\n\nout:\n\tif (vecs != inline_vecs)\n\t\tkfree(vecs);\n\n\tbio_uninit(&bio);\n\n\treturn ret;\n}\n\nenum {\n\tDIO_SHOULD_DIRTY\t= 1,\n\tDIO_IS_SYNC\t\t= 2,\n};\n\nstruct blkdev_dio {\n\tunion {\n\t\tstruct kiocb\t\t*iocb;\n\t\tstruct task_struct\t*waiter;\n\t};\n\tsize_t\t\t\tsize;\n\tatomic_t\t\tref;\n\tunsigned int\t\tflags;\n\tstruct bio\t\tbio ____cacheline_aligned_in_smp;\n};\n\nstatic struct bio_set blkdev_dio_pool;\n\nstatic void blkdev_bio_end_io(struct bio *bio)\n{\n\tstruct blkdev_dio *dio = bio->bi_private;\n\tbool should_dirty = dio->flags & DIO_SHOULD_DIRTY;\n\n\tif (bio->bi_status && !dio->bio.bi_status)\n\t\tdio->bio.bi_status = bio->bi_status;\n\n\tif (atomic_dec_and_test(&dio->ref)) {\n\t\tif (!(dio->flags & DIO_IS_SYNC)) {\n\t\t\tstruct kiocb *iocb = dio->iocb;\n\t\t\tssize_t ret;\n\n\t\t\tWRITE_ONCE(iocb->private, NULL);\n\n\t\t\tif (likely(!dio->bio.bi_status)) {\n\t\t\t\tret = dio->size;\n\t\t\t\tiocb->ki_pos += ret;\n\t\t\t} else {\n\t\t\t\tret = blk_status_to_errno(dio->bio.bi_status);\n\t\t\t}\n\n\t\t\tdio->iocb->ki_complete(iocb, ret);\n\t\t\tbio_put(&dio->bio);\n\t\t} else {\n\t\t\tstruct task_struct *waiter = dio->waiter;\n\n\t\t\tWRITE_ONCE(dio->waiter, NULL);\n\t\t\tblk_wake_io_task(waiter);\n\t\t}\n\t}\n\n\tif (should_dirty) {\n\t\tbio_check_pages_dirty(bio);\n\t} else {\n\t\tbio_release_pages(bio, false);\n\t\tbio_put(bio);\n\t}\n}\n\nstatic ssize_t __blkdev_direct_IO(struct kiocb *iocb, struct iov_iter *iter,\n\t\tunsigned int nr_pages)\n{\n\tstruct block_device *bdev = I_BDEV(iocb->ki_filp->f_mapping->host);\n\tstruct blk_plug plug;\n\tstruct blkdev_dio *dio;\n\tstruct bio *bio;\n\tbool is_read = (iov_iter_rw(iter) == READ), is_sync;\n\tblk_opf_t opf = is_read ? REQ_OP_READ : dio_bio_write_op(iocb);\n\tloff_t pos = iocb->ki_pos;\n\tint ret = 0;\n\n\tif (blkdev_dio_unaligned(bdev, pos, iter))\n\t\treturn -EINVAL;\n\n\tif (iocb->ki_flags & IOCB_ALLOC_CACHE)\n\t\topf |= REQ_ALLOC_CACHE;\n\tbio = bio_alloc_bioset(bdev, nr_pages, opf, GFP_KERNEL,\n\t\t\t       &blkdev_dio_pool);\n\tdio = container_of(bio, struct blkdev_dio, bio);\n\tatomic_set(&dio->ref, 1);\n\t \n\tbio_get(bio);\n\n\tis_sync = is_sync_kiocb(iocb);\n\tif (is_sync) {\n\t\tdio->flags = DIO_IS_SYNC;\n\t\tdio->waiter = current;\n\t} else {\n\t\tdio->flags = 0;\n\t\tdio->iocb = iocb;\n\t}\n\n\tdio->size = 0;\n\tif (is_read && user_backed_iter(iter))\n\t\tdio->flags |= DIO_SHOULD_DIRTY;\n\n\tblk_start_plug(&plug);\n\n\tfor (;;) {\n\t\tbio->bi_iter.bi_sector = pos >> SECTOR_SHIFT;\n\t\tbio->bi_private = dio;\n\t\tbio->bi_end_io = blkdev_bio_end_io;\n\t\tbio->bi_ioprio = iocb->ki_ioprio;\n\n\t\tret = bio_iov_iter_get_pages(bio, iter);\n\t\tif (unlikely(ret)) {\n\t\t\tbio->bi_status = BLK_STS_IOERR;\n\t\t\tbio_endio(bio);\n\t\t\tbreak;\n\t\t}\n\t\tif (iocb->ki_flags & IOCB_NOWAIT) {\n\t\t\t \n\t\t\tif (unlikely(iov_iter_count(iter))) {\n\t\t\t\tbio_release_pages(bio, false);\n\t\t\t\tbio_clear_flag(bio, BIO_REFFED);\n\t\t\t\tbio_put(bio);\n\t\t\t\tblk_finish_plug(&plug);\n\t\t\t\treturn -EAGAIN;\n\t\t\t}\n\t\t\tbio->bi_opf |= REQ_NOWAIT;\n\t\t}\n\n\t\tif (is_read) {\n\t\t\tif (dio->flags & DIO_SHOULD_DIRTY)\n\t\t\t\tbio_set_pages_dirty(bio);\n\t\t} else {\n\t\t\ttask_io_account_write(bio->bi_iter.bi_size);\n\t\t}\n\t\tdio->size += bio->bi_iter.bi_size;\n\t\tpos += bio->bi_iter.bi_size;\n\n\t\tnr_pages = bio_iov_vecs_to_alloc(iter, BIO_MAX_VECS);\n\t\tif (!nr_pages) {\n\t\t\tsubmit_bio(bio);\n\t\t\tbreak;\n\t\t}\n\t\tatomic_inc(&dio->ref);\n\t\tsubmit_bio(bio);\n\t\tbio = bio_alloc(bdev, nr_pages, opf, GFP_KERNEL);\n\t}\n\n\tblk_finish_plug(&plug);\n\n\tif (!is_sync)\n\t\treturn -EIOCBQUEUED;\n\n\tfor (;;) {\n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\tif (!READ_ONCE(dio->waiter))\n\t\t\tbreak;\n\t\tblk_io_schedule();\n\t}\n\t__set_current_state(TASK_RUNNING);\n\n\tif (!ret)\n\t\tret = blk_status_to_errno(dio->bio.bi_status);\n\tif (likely(!ret))\n\t\tret = dio->size;\n\n\tbio_put(&dio->bio);\n\treturn ret;\n}\n\nstatic void blkdev_bio_end_io_async(struct bio *bio)\n{\n\tstruct blkdev_dio *dio = container_of(bio, struct blkdev_dio, bio);\n\tstruct kiocb *iocb = dio->iocb;\n\tssize_t ret;\n\n\tWRITE_ONCE(iocb->private, NULL);\n\n\tif (likely(!bio->bi_status)) {\n\t\tret = dio->size;\n\t\tiocb->ki_pos += ret;\n\t} else {\n\t\tret = blk_status_to_errno(bio->bi_status);\n\t}\n\n\tiocb->ki_complete(iocb, ret);\n\n\tif (dio->flags & DIO_SHOULD_DIRTY) {\n\t\tbio_check_pages_dirty(bio);\n\t} else {\n\t\tbio_release_pages(bio, false);\n\t\tbio_put(bio);\n\t}\n}\n\nstatic ssize_t __blkdev_direct_IO_async(struct kiocb *iocb,\n\t\t\t\t\tstruct iov_iter *iter,\n\t\t\t\t\tunsigned int nr_pages)\n{\n\tstruct block_device *bdev = I_BDEV(iocb->ki_filp->f_mapping->host);\n\tbool is_read = iov_iter_rw(iter) == READ;\n\tblk_opf_t opf = is_read ? REQ_OP_READ : dio_bio_write_op(iocb);\n\tstruct blkdev_dio *dio;\n\tstruct bio *bio;\n\tloff_t pos = iocb->ki_pos;\n\tint ret = 0;\n\n\tif (blkdev_dio_unaligned(bdev, pos, iter))\n\t\treturn -EINVAL;\n\n\tif (iocb->ki_flags & IOCB_ALLOC_CACHE)\n\t\topf |= REQ_ALLOC_CACHE;\n\tbio = bio_alloc_bioset(bdev, nr_pages, opf, GFP_KERNEL,\n\t\t\t       &blkdev_dio_pool);\n\tdio = container_of(bio, struct blkdev_dio, bio);\n\tdio->flags = 0;\n\tdio->iocb = iocb;\n\tbio->bi_iter.bi_sector = pos >> SECTOR_SHIFT;\n\tbio->bi_end_io = blkdev_bio_end_io_async;\n\tbio->bi_ioprio = iocb->ki_ioprio;\n\n\tif (iov_iter_is_bvec(iter)) {\n\t\t \n\t\tbio_iov_bvec_set(bio, iter);\n\t} else {\n\t\tret = bio_iov_iter_get_pages(bio, iter);\n\t\tif (unlikely(ret)) {\n\t\t\tbio_put(bio);\n\t\t\treturn ret;\n\t\t}\n\t}\n\tdio->size = bio->bi_iter.bi_size;\n\n\tif (is_read) {\n\t\tif (user_backed_iter(iter)) {\n\t\t\tdio->flags |= DIO_SHOULD_DIRTY;\n\t\t\tbio_set_pages_dirty(bio);\n\t\t}\n\t} else {\n\t\ttask_io_account_write(bio->bi_iter.bi_size);\n\t}\n\n\tif (iocb->ki_flags & IOCB_NOWAIT)\n\t\tbio->bi_opf |= REQ_NOWAIT;\n\n\tif (iocb->ki_flags & IOCB_HIPRI) {\n\t\tbio->bi_opf |= REQ_POLLED;\n\t\tsubmit_bio(bio);\n\t\tWRITE_ONCE(iocb->private, bio);\n\t} else {\n\t\tsubmit_bio(bio);\n\t}\n\treturn -EIOCBQUEUED;\n}\n\nstatic ssize_t blkdev_direct_IO(struct kiocb *iocb, struct iov_iter *iter)\n{\n\tunsigned int nr_pages;\n\n\tif (!iov_iter_count(iter))\n\t\treturn 0;\n\n\tnr_pages = bio_iov_vecs_to_alloc(iter, BIO_MAX_VECS + 1);\n\tif (likely(nr_pages <= BIO_MAX_VECS)) {\n\t\tif (is_sync_kiocb(iocb))\n\t\t\treturn __blkdev_direct_IO_simple(iocb, iter, nr_pages);\n\t\treturn __blkdev_direct_IO_async(iocb, iter, nr_pages);\n\t}\n\treturn __blkdev_direct_IO(iocb, iter, bio_max_segs(nr_pages));\n}\n\nstatic int blkdev_iomap_begin(struct inode *inode, loff_t offset, loff_t length,\n\t\tunsigned int flags, struct iomap *iomap, struct iomap *srcmap)\n{\n\tstruct block_device *bdev = I_BDEV(inode);\n\tloff_t isize = i_size_read(inode);\n\n\tiomap->bdev = bdev;\n\tiomap->offset = ALIGN_DOWN(offset, bdev_logical_block_size(bdev));\n\tif (iomap->offset >= isize)\n\t\treturn -EIO;\n\tiomap->type = IOMAP_MAPPED;\n\tiomap->addr = iomap->offset;\n\tiomap->length = isize - iomap->offset;\n\tiomap->flags |= IOMAP_F_BUFFER_HEAD;  \n\treturn 0;\n}\n\nstatic const struct iomap_ops blkdev_iomap_ops = {\n\t.iomap_begin\t\t= blkdev_iomap_begin,\n};\n\n#ifdef CONFIG_BUFFER_HEAD\nstatic int blkdev_get_block(struct inode *inode, sector_t iblock,\n\t\tstruct buffer_head *bh, int create)\n{\n\tbh->b_bdev = I_BDEV(inode);\n\tbh->b_blocknr = iblock;\n\tset_buffer_mapped(bh);\n\treturn 0;\n}\n\nstatic int blkdev_writepage(struct page *page, struct writeback_control *wbc)\n{\n\treturn block_write_full_page(page, blkdev_get_block, wbc);\n}\n\nstatic int blkdev_read_folio(struct file *file, struct folio *folio)\n{\n\treturn block_read_full_folio(folio, blkdev_get_block);\n}\n\nstatic void blkdev_readahead(struct readahead_control *rac)\n{\n\tmpage_readahead(rac, blkdev_get_block);\n}\n\nstatic int blkdev_write_begin(struct file *file, struct address_space *mapping,\n\t\tloff_t pos, unsigned len, struct page **pagep, void **fsdata)\n{\n\treturn block_write_begin(mapping, pos, len, pagep, blkdev_get_block);\n}\n\nstatic int blkdev_write_end(struct file *file, struct address_space *mapping,\n\t\tloff_t pos, unsigned len, unsigned copied, struct page *page,\n\t\tvoid *fsdata)\n{\n\tint ret;\n\tret = block_write_end(file, mapping, pos, len, copied, page, fsdata);\n\n\tunlock_page(page);\n\tput_page(page);\n\n\treturn ret;\n}\n\nconst struct address_space_operations def_blk_aops = {\n\t.dirty_folio\t= block_dirty_folio,\n\t.invalidate_folio = block_invalidate_folio,\n\t.read_folio\t= blkdev_read_folio,\n\t.readahead\t= blkdev_readahead,\n\t.writepage\t= blkdev_writepage,\n\t.write_begin\t= blkdev_write_begin,\n\t.write_end\t= blkdev_write_end,\n\t.migrate_folio\t= buffer_migrate_folio_norefs,\n\t.is_dirty_writeback = buffer_check_dirty_writeback,\n};\n#else  \nstatic int blkdev_read_folio(struct file *file, struct folio *folio)\n{\n\treturn iomap_read_folio(folio, &blkdev_iomap_ops);\n}\n\nstatic void blkdev_readahead(struct readahead_control *rac)\n{\n\tiomap_readahead(rac, &blkdev_iomap_ops);\n}\n\nstatic int blkdev_map_blocks(struct iomap_writepage_ctx *wpc,\n\t\tstruct inode *inode, loff_t offset)\n{\n\tloff_t isize = i_size_read(inode);\n\n\tif (WARN_ON_ONCE(offset >= isize))\n\t\treturn -EIO;\n\tif (offset >= wpc->iomap.offset &&\n\t    offset < wpc->iomap.offset + wpc->iomap.length)\n\t\treturn 0;\n\treturn blkdev_iomap_begin(inode, offset, isize - offset,\n\t\t\t\t  IOMAP_WRITE, &wpc->iomap, NULL);\n}\n\nstatic const struct iomap_writeback_ops blkdev_writeback_ops = {\n\t.map_blocks\t\t= blkdev_map_blocks,\n};\n\nstatic int blkdev_writepages(struct address_space *mapping,\n\t\tstruct writeback_control *wbc)\n{\n\tstruct iomap_writepage_ctx wpc = { };\n\n\treturn iomap_writepages(mapping, wbc, &wpc, &blkdev_writeback_ops);\n}\n\nconst struct address_space_operations def_blk_aops = {\n\t.dirty_folio\t= filemap_dirty_folio,\n\t.release_folio\t\t= iomap_release_folio,\n\t.invalidate_folio\t= iomap_invalidate_folio,\n\t.read_folio\t\t= blkdev_read_folio,\n\t.readahead\t\t= blkdev_readahead,\n\t.writepages\t\t= blkdev_writepages,\n\t.is_partially_uptodate  = iomap_is_partially_uptodate,\n\t.error_remove_page\t= generic_error_remove_page,\n\t.migrate_folio\t\t= filemap_migrate_folio,\n};\n#endif  \n\n \nstatic loff_t blkdev_llseek(struct file *file, loff_t offset, int whence)\n{\n\tstruct inode *bd_inode = bdev_file_inode(file);\n\tloff_t retval;\n\n\tinode_lock(bd_inode);\n\tretval = fixed_size_llseek(file, offset, whence, i_size_read(bd_inode));\n\tinode_unlock(bd_inode);\n\treturn retval;\n}\n\nstatic int blkdev_fsync(struct file *filp, loff_t start, loff_t end,\n\t\tint datasync)\n{\n\tstruct block_device *bdev = I_BDEV(filp->f_mapping->host);\n\tint error;\n\n\terror = file_write_and_wait_range(filp, start, end);\n\tif (error)\n\t\treturn error;\n\n\t \n\terror = blkdev_issue_flush(bdev);\n\tif (error == -EOPNOTSUPP)\n\t\terror = 0;\n\n\treturn error;\n}\n\nblk_mode_t file_to_blk_mode(struct file *file)\n{\n\tblk_mode_t mode = 0;\n\n\tif (file->f_mode & FMODE_READ)\n\t\tmode |= BLK_OPEN_READ;\n\tif (file->f_mode & FMODE_WRITE)\n\t\tmode |= BLK_OPEN_WRITE;\n\tif (file->private_data)\n\t\tmode |= BLK_OPEN_EXCL;\n\tif (file->f_flags & O_NDELAY)\n\t\tmode |= BLK_OPEN_NDELAY;\n\n\t \n\tif ((file->f_flags & O_ACCMODE) == (O_RDWR | O_WRONLY))\n\t\tmode |= BLK_OPEN_WRITE_IOCTL;\n\n\treturn mode;\n}\n\nstatic int blkdev_open(struct inode *inode, struct file *filp)\n{\n\tstruct block_device *bdev;\n\n\t \n\tfilp->f_flags |= O_LARGEFILE;\n\tfilp->f_mode |= FMODE_BUF_RASYNC | FMODE_CAN_ODIRECT;\n\n\t \n\tif (filp->f_flags & O_EXCL)\n\t\tfilp->private_data = filp;\n\n\tbdev = blkdev_get_by_dev(inode->i_rdev, file_to_blk_mode(filp),\n\t\t\t\t filp->private_data, NULL);\n\tif (IS_ERR(bdev))\n\t\treturn PTR_ERR(bdev);\n\n\tif (bdev_nowait(bdev))\n\t\tfilp->f_mode |= FMODE_NOWAIT;\n\n\tfilp->f_mapping = bdev->bd_inode->i_mapping;\n\tfilp->f_wb_err = filemap_sample_wb_err(filp->f_mapping);\n\treturn 0;\n}\n\nstatic int blkdev_release(struct inode *inode, struct file *filp)\n{\n\tblkdev_put(I_BDEV(filp->f_mapping->host), filp->private_data);\n\treturn 0;\n}\n\nstatic ssize_t\nblkdev_direct_write(struct kiocb *iocb, struct iov_iter *from)\n{\n\tsize_t count = iov_iter_count(from);\n\tssize_t written;\n\n\twritten = kiocb_invalidate_pages(iocb, count);\n\tif (written) {\n\t\tif (written == -EBUSY)\n\t\t\treturn 0;\n\t\treturn written;\n\t}\n\n\twritten = blkdev_direct_IO(iocb, from);\n\tif (written > 0) {\n\t\tkiocb_invalidate_post_direct_write(iocb, count);\n\t\tiocb->ki_pos += written;\n\t\tcount -= written;\n\t}\n\tif (written != -EIOCBQUEUED)\n\t\tiov_iter_revert(from, count - iov_iter_count(from));\n\treturn written;\n}\n\nstatic ssize_t blkdev_buffered_write(struct kiocb *iocb, struct iov_iter *from)\n{\n\treturn iomap_file_buffered_write(iocb, from, &blkdev_iomap_ops);\n}\n\n \nstatic ssize_t blkdev_write_iter(struct kiocb *iocb, struct iov_iter *from)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct block_device *bdev = I_BDEV(file->f_mapping->host);\n\tstruct inode *bd_inode = bdev->bd_inode;\n\tloff_t size = bdev_nr_bytes(bdev);\n\tsize_t shorted = 0;\n\tssize_t ret;\n\n\tif (bdev_read_only(bdev))\n\t\treturn -EPERM;\n\n\tif (IS_SWAPFILE(bd_inode) && !is_hibernate_resume_dev(bd_inode->i_rdev))\n\t\treturn -ETXTBSY;\n\n\tif (!iov_iter_count(from))\n\t\treturn 0;\n\n\tif (iocb->ki_pos >= size)\n\t\treturn -ENOSPC;\n\n\tif ((iocb->ki_flags & (IOCB_NOWAIT | IOCB_DIRECT)) == IOCB_NOWAIT)\n\t\treturn -EOPNOTSUPP;\n\n\tsize -= iocb->ki_pos;\n\tif (iov_iter_count(from) > size) {\n\t\tshorted = iov_iter_count(from) - size;\n\t\tiov_iter_truncate(from, size);\n\t}\n\n\tret = file_update_time(file);\n\tif (ret)\n\t\treturn ret;\n\n\tif (iocb->ki_flags & IOCB_DIRECT) {\n\t\tret = blkdev_direct_write(iocb, from);\n\t\tif (ret >= 0 && iov_iter_count(from))\n\t\t\tret = direct_write_fallback(iocb, from, ret,\n\t\t\t\t\tblkdev_buffered_write(iocb, from));\n\t} else {\n\t\tret = blkdev_buffered_write(iocb, from);\n\t}\n\n\tif (ret > 0)\n\t\tret = generic_write_sync(iocb, ret);\n\tiov_iter_reexpand(from, iov_iter_count(from) + shorted);\n\treturn ret;\n}\n\nstatic ssize_t blkdev_read_iter(struct kiocb *iocb, struct iov_iter *to)\n{\n\tstruct block_device *bdev = I_BDEV(iocb->ki_filp->f_mapping->host);\n\tloff_t size = bdev_nr_bytes(bdev);\n\tloff_t pos = iocb->ki_pos;\n\tsize_t shorted = 0;\n\tssize_t ret = 0;\n\tsize_t count;\n\n\tif (unlikely(pos + iov_iter_count(to) > size)) {\n\t\tif (pos >= size)\n\t\t\treturn 0;\n\t\tsize -= pos;\n\t\tshorted = iov_iter_count(to) - size;\n\t\tiov_iter_truncate(to, size);\n\t}\n\n\tcount = iov_iter_count(to);\n\tif (!count)\n\t\tgoto reexpand;  \n\n\tif (iocb->ki_flags & IOCB_DIRECT) {\n\t\tret = kiocb_write_and_wait(iocb, count);\n\t\tif (ret < 0)\n\t\t\tgoto reexpand;\n\t\tfile_accessed(iocb->ki_filp);\n\n\t\tret = blkdev_direct_IO(iocb, to);\n\t\tif (ret >= 0) {\n\t\t\tiocb->ki_pos += ret;\n\t\t\tcount -= ret;\n\t\t}\n\t\tiov_iter_revert(to, count - iov_iter_count(to));\n\t\tif (ret < 0 || !count)\n\t\t\tgoto reexpand;\n\t}\n\n\tret = filemap_read(iocb, to, ret);\n\nreexpand:\n\tif (unlikely(shorted))\n\t\tiov_iter_reexpand(to, iov_iter_count(to) + shorted);\n\treturn ret;\n}\n\n#define\tBLKDEV_FALLOC_FL_SUPPORTED\t\t\t\t\t\\\n\t\t(FALLOC_FL_KEEP_SIZE | FALLOC_FL_PUNCH_HOLE |\t\t\\\n\t\t FALLOC_FL_ZERO_RANGE | FALLOC_FL_NO_HIDE_STALE)\n\nstatic long blkdev_fallocate(struct file *file, int mode, loff_t start,\n\t\t\t     loff_t len)\n{\n\tstruct inode *inode = bdev_file_inode(file);\n\tstruct block_device *bdev = I_BDEV(inode);\n\tloff_t end = start + len - 1;\n\tloff_t isize;\n\tint error;\n\n\t \n\tif (mode & ~BLKDEV_FALLOC_FL_SUPPORTED)\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tisize = bdev_nr_bytes(bdev);\n\tif (start >= isize)\n\t\treturn -EINVAL;\n\tif (end >= isize) {\n\t\tif (mode & FALLOC_FL_KEEP_SIZE) {\n\t\t\tlen = isize - start;\n\t\t\tend = start + len - 1;\n\t\t} else\n\t\t\treturn -EINVAL;\n\t}\n\n\t \n\tif ((start | len) & (bdev_logical_block_size(bdev) - 1))\n\t\treturn -EINVAL;\n\n\tfilemap_invalidate_lock(inode->i_mapping);\n\n\t \n\tswitch (mode) {\n\tcase FALLOC_FL_ZERO_RANGE:\n\tcase FALLOC_FL_ZERO_RANGE | FALLOC_FL_KEEP_SIZE:\n\t\terror = truncate_bdev_range(bdev, file_to_blk_mode(file), start, end);\n\t\tif (error)\n\t\t\tgoto fail;\n\n\t\terror = blkdev_issue_zeroout(bdev, start >> SECTOR_SHIFT,\n\t\t\t\t\t     len >> SECTOR_SHIFT, GFP_KERNEL,\n\t\t\t\t\t     BLKDEV_ZERO_NOUNMAP);\n\t\tbreak;\n\tcase FALLOC_FL_PUNCH_HOLE | FALLOC_FL_KEEP_SIZE:\n\t\terror = truncate_bdev_range(bdev, file_to_blk_mode(file), start, end);\n\t\tif (error)\n\t\t\tgoto fail;\n\n\t\terror = blkdev_issue_zeroout(bdev, start >> SECTOR_SHIFT,\n\t\t\t\t\t     len >> SECTOR_SHIFT, GFP_KERNEL,\n\t\t\t\t\t     BLKDEV_ZERO_NOFALLBACK);\n\t\tbreak;\n\tcase FALLOC_FL_PUNCH_HOLE | FALLOC_FL_KEEP_SIZE | FALLOC_FL_NO_HIDE_STALE:\n\t\terror = truncate_bdev_range(bdev, file_to_blk_mode(file), start, end);\n\t\tif (error)\n\t\t\tgoto fail;\n\n\t\terror = blkdev_issue_discard(bdev, start >> SECTOR_SHIFT,\n\t\t\t\t\t     len >> SECTOR_SHIFT, GFP_KERNEL);\n\t\tbreak;\n\tdefault:\n\t\terror = -EOPNOTSUPP;\n\t}\n\n fail:\n\tfilemap_invalidate_unlock(inode->i_mapping);\n\treturn error;\n}\n\nstatic int blkdev_mmap(struct file *file, struct vm_area_struct *vma)\n{\n\tstruct inode *bd_inode = bdev_file_inode(file);\n\n\tif (bdev_read_only(I_BDEV(bd_inode)))\n\t\treturn generic_file_readonly_mmap(file, vma);\n\n\treturn generic_file_mmap(file, vma);\n}\n\nconst struct file_operations def_blk_fops = {\n\t.open\t\t= blkdev_open,\n\t.release\t= blkdev_release,\n\t.llseek\t\t= blkdev_llseek,\n\t.read_iter\t= blkdev_read_iter,\n\t.write_iter\t= blkdev_write_iter,\n\t.iopoll\t\t= iocb_bio_iopoll,\n\t.mmap\t\t= blkdev_mmap,\n\t.fsync\t\t= blkdev_fsync,\n\t.unlocked_ioctl\t= blkdev_ioctl,\n#ifdef CONFIG_COMPAT\n\t.compat_ioctl\t= compat_blkdev_ioctl,\n#endif\n\t.splice_read\t= filemap_splice_read,\n\t.splice_write\t= iter_file_splice_write,\n\t.fallocate\t= blkdev_fallocate,\n};\n\nstatic __init int blkdev_init(void)\n{\n\treturn bioset_init(&blkdev_dio_pool, 4,\n\t\t\t\toffsetof(struct blkdev_dio, bio),\n\t\t\t\tBIOSET_NEED_BVECS|BIOSET_PERCPU_CACHE);\n}\nmodule_init(blkdev_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}