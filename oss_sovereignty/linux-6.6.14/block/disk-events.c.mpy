{
  "module_name": "disk-events.c",
  "hash_id": "699860027ee052f57ecb0cb873a74acfec2b9b4cc93d92394cabfc4303f85964",
  "original_prompt": "Ingested from linux-6.6.14/block/disk-events.c",
  "human_readable_source": "\n \n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/blkdev.h>\n#include \"blk.h\"\n\nstruct disk_events {\n\tstruct list_head\tnode;\t\t \n\tstruct gendisk\t\t*disk;\t\t \n\tspinlock_t\t\tlock;\n\n\tstruct mutex\t\tblock_mutex;\t \n\tint\t\t\tblock;\t\t \n\tunsigned int\t\tpending;\t \n\tunsigned int\t\tclearing;\t \n\n\tlong\t\t\tpoll_msecs;\t \n\tstruct delayed_work\tdwork;\n};\n\nstatic const char *disk_events_strs[] = {\n\t[ilog2(DISK_EVENT_MEDIA_CHANGE)]\t= \"media_change\",\n\t[ilog2(DISK_EVENT_EJECT_REQUEST)]\t= \"eject_request\",\n};\n\nstatic char *disk_uevents[] = {\n\t[ilog2(DISK_EVENT_MEDIA_CHANGE)]\t= \"DISK_MEDIA_CHANGE=1\",\n\t[ilog2(DISK_EVENT_EJECT_REQUEST)]\t= \"DISK_EJECT_REQUEST=1\",\n};\n\n \nstatic DEFINE_MUTEX(disk_events_mutex);\nstatic LIST_HEAD(disk_events);\n\n \nstatic unsigned long disk_events_dfl_poll_msecs;\n\nstatic unsigned long disk_events_poll_jiffies(struct gendisk *disk)\n{\n\tstruct disk_events *ev = disk->ev;\n\tlong intv_msecs = 0;\n\n\t \n\tif (ev->poll_msecs >= 0)\n\t\tintv_msecs = ev->poll_msecs;\n\telse if (disk->event_flags & DISK_EVENT_FLAG_POLL)\n\t\tintv_msecs = disk_events_dfl_poll_msecs;\n\n\treturn msecs_to_jiffies(intv_msecs);\n}\n\n \nvoid disk_block_events(struct gendisk *disk)\n{\n\tstruct disk_events *ev = disk->ev;\n\tunsigned long flags;\n\tbool cancel;\n\n\tif (!ev)\n\t\treturn;\n\n\t \n\tmutex_lock(&ev->block_mutex);\n\n\tspin_lock_irqsave(&ev->lock, flags);\n\tcancel = !ev->block++;\n\tspin_unlock_irqrestore(&ev->lock, flags);\n\n\tif (cancel)\n\t\tcancel_delayed_work_sync(&disk->ev->dwork);\n\n\tmutex_unlock(&ev->block_mutex);\n}\n\nstatic void __disk_unblock_events(struct gendisk *disk, bool check_now)\n{\n\tstruct disk_events *ev = disk->ev;\n\tunsigned long intv;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ev->lock, flags);\n\n\tif (WARN_ON_ONCE(ev->block <= 0))\n\t\tgoto out_unlock;\n\n\tif (--ev->block)\n\t\tgoto out_unlock;\n\n\tintv = disk_events_poll_jiffies(disk);\n\tif (check_now)\n\t\tqueue_delayed_work(system_freezable_power_efficient_wq,\n\t\t\t\t&ev->dwork, 0);\n\telse if (intv)\n\t\tqueue_delayed_work(system_freezable_power_efficient_wq,\n\t\t\t\t&ev->dwork, intv);\nout_unlock:\n\tspin_unlock_irqrestore(&ev->lock, flags);\n}\n\n \nvoid disk_unblock_events(struct gendisk *disk)\n{\n\tif (disk->ev)\n\t\t__disk_unblock_events(disk, false);\n}\n\n \nvoid disk_flush_events(struct gendisk *disk, unsigned int mask)\n{\n\tstruct disk_events *ev = disk->ev;\n\n\tif (!ev)\n\t\treturn;\n\n\tspin_lock_irq(&ev->lock);\n\tev->clearing |= mask;\n\tif (!ev->block)\n\t\tmod_delayed_work(system_freezable_power_efficient_wq,\n\t\t\t\t&ev->dwork, 0);\n\tspin_unlock_irq(&ev->lock);\n}\n\n \nstatic void disk_event_uevent(struct gendisk *disk, unsigned int events)\n{\n\tchar *envp[ARRAY_SIZE(disk_uevents) + 1] = { };\n\tint nr_events = 0, i;\n\n\tfor (i = 0; i < ARRAY_SIZE(disk_uevents); i++)\n\t\tif (events & disk->events & (1 << i))\n\t\t\tenvp[nr_events++] = disk_uevents[i];\n\n\tif (nr_events)\n\t\tkobject_uevent_env(&disk_to_dev(disk)->kobj, KOBJ_CHANGE, envp);\n}\n\nstatic void disk_check_events(struct disk_events *ev,\n\t\t\t      unsigned int *clearing_ptr)\n{\n\tstruct gendisk *disk = ev->disk;\n\tunsigned int clearing = *clearing_ptr;\n\tunsigned int events;\n\tunsigned long intv;\n\n\t \n\tevents = disk->fops->check_events(disk, clearing);\n\n\t \n\tspin_lock_irq(&ev->lock);\n\n\tevents &= ~ev->pending;\n\tev->pending |= events;\n\t*clearing_ptr &= ~clearing;\n\n\tintv = disk_events_poll_jiffies(disk);\n\tif (!ev->block && intv)\n\t\tqueue_delayed_work(system_freezable_power_efficient_wq,\n\t\t\t\t&ev->dwork, intv);\n\n\tspin_unlock_irq(&ev->lock);\n\n\tif (events & DISK_EVENT_MEDIA_CHANGE)\n\t\tinc_diskseq(disk);\n\n\tif (disk->event_flags & DISK_EVENT_FLAG_UEVENT)\n\t\tdisk_event_uevent(disk, events);\n}\n\n \nstatic unsigned int disk_clear_events(struct gendisk *disk, unsigned int mask)\n{\n\tstruct disk_events *ev = disk->ev;\n\tunsigned int pending;\n\tunsigned int clearing = mask;\n\n\tif (!ev)\n\t\treturn 0;\n\n\tdisk_block_events(disk);\n\n\t \n\tspin_lock_irq(&ev->lock);\n\tclearing |= ev->clearing;\n\tev->clearing = 0;\n\tspin_unlock_irq(&ev->lock);\n\n\tdisk_check_events(ev, &clearing);\n\t \n\t__disk_unblock_events(disk, ev->clearing ? true : false);\n\n\t \n\tspin_lock_irq(&ev->lock);\n\tpending = ev->pending & mask;\n\tev->pending &= ~mask;\n\tspin_unlock_irq(&ev->lock);\n\tWARN_ON_ONCE(clearing & mask);\n\n\treturn pending;\n}\n\n \nbool disk_check_media_change(struct gendisk *disk)\n{\n\tunsigned int events;\n\n\tevents = disk_clear_events(disk, DISK_EVENT_MEDIA_CHANGE |\n\t\t\t\t   DISK_EVENT_EJECT_REQUEST);\n\tif (!(events & DISK_EVENT_MEDIA_CHANGE))\n\t\treturn false;\n\n\tbdev_mark_dead(disk->part0, true);\n\tset_bit(GD_NEED_PART_SCAN, &disk->state);\n\treturn true;\n}\nEXPORT_SYMBOL(disk_check_media_change);\n\n \nvoid disk_force_media_change(struct gendisk *disk)\n{\n\tdisk_event_uevent(disk, DISK_EVENT_MEDIA_CHANGE);\n\tinc_diskseq(disk);\n\tbdev_mark_dead(disk->part0, true);\n\tset_bit(GD_NEED_PART_SCAN, &disk->state);\n}\nEXPORT_SYMBOL_GPL(disk_force_media_change);\n\n \nstatic void disk_events_workfn(struct work_struct *work)\n{\n\tstruct delayed_work *dwork = to_delayed_work(work);\n\tstruct disk_events *ev = container_of(dwork, struct disk_events, dwork);\n\n\tdisk_check_events(ev, &ev->clearing);\n}\n\n \nstatic ssize_t __disk_events_show(unsigned int events, char *buf)\n{\n\tconst char *delim = \"\";\n\tssize_t pos = 0;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(disk_events_strs); i++)\n\t\tif (events & (1 << i)) {\n\t\t\tpos += sprintf(buf + pos, \"%s%s\",\n\t\t\t\t       delim, disk_events_strs[i]);\n\t\t\tdelim = \" \";\n\t\t}\n\tif (pos)\n\t\tpos += sprintf(buf + pos, \"\\n\");\n\treturn pos;\n}\n\nstatic ssize_t disk_events_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct gendisk *disk = dev_to_disk(dev);\n\n\tif (!(disk->event_flags & DISK_EVENT_FLAG_UEVENT))\n\t\treturn 0;\n\treturn __disk_events_show(disk->events, buf);\n}\n\nstatic ssize_t disk_events_async_show(struct device *dev,\n\t\t\t\t      struct device_attribute *attr, char *buf)\n{\n\treturn 0;\n}\n\nstatic ssize_t disk_events_poll_msecs_show(struct device *dev,\n\t\t\t\t\t   struct device_attribute *attr,\n\t\t\t\t\t   char *buf)\n{\n\tstruct gendisk *disk = dev_to_disk(dev);\n\n\tif (!disk->ev)\n\t\treturn sprintf(buf, \"-1\\n\");\n\treturn sprintf(buf, \"%ld\\n\", disk->ev->poll_msecs);\n}\n\nstatic ssize_t disk_events_poll_msecs_store(struct device *dev,\n\t\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t\t    const char *buf, size_t count)\n{\n\tstruct gendisk *disk = dev_to_disk(dev);\n\tlong intv;\n\n\tif (!count || !sscanf(buf, \"%ld\", &intv))\n\t\treturn -EINVAL;\n\n\tif (intv < 0 && intv != -1)\n\t\treturn -EINVAL;\n\n\tif (!disk->ev)\n\t\treturn -ENODEV;\n\n\tdisk_block_events(disk);\n\tdisk->ev->poll_msecs = intv;\n\t__disk_unblock_events(disk, true);\n\treturn count;\n}\n\nDEVICE_ATTR(events, 0444, disk_events_show, NULL);\nDEVICE_ATTR(events_async, 0444, disk_events_async_show, NULL);\nDEVICE_ATTR(events_poll_msecs, 0644, disk_events_poll_msecs_show,\n\t    disk_events_poll_msecs_store);\n\n \nstatic int disk_events_set_dfl_poll_msecs(const char *val,\n\t\t\t\t\t  const struct kernel_param *kp)\n{\n\tstruct disk_events *ev;\n\tint ret;\n\n\tret = param_set_ulong(val, kp);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tmutex_lock(&disk_events_mutex);\n\tlist_for_each_entry(ev, &disk_events, node)\n\t\tdisk_flush_events(ev->disk, 0);\n\tmutex_unlock(&disk_events_mutex);\n\treturn 0;\n}\n\nstatic const struct kernel_param_ops disk_events_dfl_poll_msecs_param_ops = {\n\t.set\t= disk_events_set_dfl_poll_msecs,\n\t.get\t= param_get_ulong,\n};\n\n#undef MODULE_PARAM_PREFIX\n#define MODULE_PARAM_PREFIX\t\"block.\"\n\nmodule_param_cb(events_dfl_poll_msecs, &disk_events_dfl_poll_msecs_param_ops,\n\t\t&disk_events_dfl_poll_msecs, 0644);\n\n \nint disk_alloc_events(struct gendisk *disk)\n{\n\tstruct disk_events *ev;\n\n\tif (!disk->fops->check_events || !disk->events)\n\t\treturn 0;\n\n\tev = kzalloc(sizeof(*ev), GFP_KERNEL);\n\tif (!ev) {\n\t\tpr_warn(\"%s: failed to initialize events\\n\", disk->disk_name);\n\t\treturn -ENOMEM;\n\t}\n\n\tINIT_LIST_HEAD(&ev->node);\n\tev->disk = disk;\n\tspin_lock_init(&ev->lock);\n\tmutex_init(&ev->block_mutex);\n\tev->block = 1;\n\tev->poll_msecs = -1;\n\tINIT_DELAYED_WORK(&ev->dwork, disk_events_workfn);\n\n\tdisk->ev = ev;\n\treturn 0;\n}\n\nvoid disk_add_events(struct gendisk *disk)\n{\n\tif (!disk->ev)\n\t\treturn;\n\n\tmutex_lock(&disk_events_mutex);\n\tlist_add_tail(&disk->ev->node, &disk_events);\n\tmutex_unlock(&disk_events_mutex);\n\n\t \n\t__disk_unblock_events(disk, true);\n}\n\nvoid disk_del_events(struct gendisk *disk)\n{\n\tif (disk->ev) {\n\t\tdisk_block_events(disk);\n\n\t\tmutex_lock(&disk_events_mutex);\n\t\tlist_del_init(&disk->ev->node);\n\t\tmutex_unlock(&disk_events_mutex);\n\t}\n}\n\nvoid disk_release_events(struct gendisk *disk)\n{\n\t \n\tWARN_ON_ONCE(disk->ev && disk->ev->block != 1);\n\tkfree(disk->ev);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}