{
  "module_name": "blk-ia-ranges.c",
  "hash_id": "546d8105607e519fd4a13dffd5a700024e296d3464bba81d6eec5dc645b824a7",
  "original_prompt": "Ingested from linux-6.6.14/block/blk-ia-ranges.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n\n#include \"blk.h\"\n\nstatic ssize_t\nblk_ia_range_sector_show(struct blk_independent_access_range *iar,\n\t\t\t char *buf)\n{\n\treturn sprintf(buf, \"%llu\\n\", iar->sector);\n}\n\nstatic ssize_t\nblk_ia_range_nr_sectors_show(struct blk_independent_access_range *iar,\n\t\t\t     char *buf)\n{\n\treturn sprintf(buf, \"%llu\\n\", iar->nr_sectors);\n}\n\nstruct blk_ia_range_sysfs_entry {\n\tstruct attribute attr;\n\tssize_t (*show)(struct blk_independent_access_range *iar, char *buf);\n};\n\nstatic struct blk_ia_range_sysfs_entry blk_ia_range_sector_entry = {\n\t.attr = { .name = \"sector\", .mode = 0444 },\n\t.show = blk_ia_range_sector_show,\n};\n\nstatic struct blk_ia_range_sysfs_entry blk_ia_range_nr_sectors_entry = {\n\t.attr = { .name = \"nr_sectors\", .mode = 0444 },\n\t.show = blk_ia_range_nr_sectors_show,\n};\n\nstatic struct attribute *blk_ia_range_attrs[] = {\n\t&blk_ia_range_sector_entry.attr,\n\t&blk_ia_range_nr_sectors_entry.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(blk_ia_range);\n\nstatic ssize_t blk_ia_range_sysfs_show(struct kobject *kobj,\n\t\t\t\t      struct attribute *attr, char *buf)\n{\n\tstruct blk_ia_range_sysfs_entry *entry =\n\t\tcontainer_of(attr, struct blk_ia_range_sysfs_entry, attr);\n\tstruct blk_independent_access_range *iar =\n\t\tcontainer_of(kobj, struct blk_independent_access_range, kobj);\n\n\treturn entry->show(iar, buf);\n}\n\nstatic const struct sysfs_ops blk_ia_range_sysfs_ops = {\n\t.show\t= blk_ia_range_sysfs_show,\n};\n\n \nstatic void blk_ia_range_sysfs_nop_release(struct kobject *kobj)\n{\n}\n\nstatic const struct kobj_type blk_ia_range_ktype = {\n\t.sysfs_ops\t= &blk_ia_range_sysfs_ops,\n\t.default_groups\t= blk_ia_range_groups,\n\t.release\t= blk_ia_range_sysfs_nop_release,\n};\n\n \nstatic void blk_ia_ranges_sysfs_release(struct kobject *kobj)\n{\n\tstruct blk_independent_access_ranges *iars =\n\t\tcontainer_of(kobj, struct blk_independent_access_ranges, kobj);\n\n\tkfree(iars);\n}\n\nstatic const struct kobj_type blk_ia_ranges_ktype = {\n\t.release\t= blk_ia_ranges_sysfs_release,\n};\n\n \nint disk_register_independent_access_ranges(struct gendisk *disk)\n{\n\tstruct blk_independent_access_ranges *iars = disk->ia_ranges;\n\tstruct request_queue *q = disk->queue;\n\tint i, ret;\n\n\tlockdep_assert_held(&q->sysfs_dir_lock);\n\tlockdep_assert_held(&q->sysfs_lock);\n\n\tif (!iars)\n\t\treturn 0;\n\n\t \n\tWARN_ON(iars->sysfs_registered);\n\tret = kobject_init_and_add(&iars->kobj, &blk_ia_ranges_ktype,\n\t\t\t\t   &disk->queue_kobj, \"%s\",\n\t\t\t\t   \"independent_access_ranges\");\n\tif (ret) {\n\t\tdisk->ia_ranges = NULL;\n\t\tkobject_put(&iars->kobj);\n\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < iars->nr_ia_ranges; i++) {\n\t\tret = kobject_init_and_add(&iars->ia_range[i].kobj,\n\t\t\t\t\t   &blk_ia_range_ktype, &iars->kobj,\n\t\t\t\t\t   \"%d\", i);\n\t\tif (ret) {\n\t\t\twhile (--i >= 0)\n\t\t\t\tkobject_del(&iars->ia_range[i].kobj);\n\t\t\tkobject_del(&iars->kobj);\n\t\t\tkobject_put(&iars->kobj);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tiars->sysfs_registered = true;\n\n\treturn 0;\n}\n\nvoid disk_unregister_independent_access_ranges(struct gendisk *disk)\n{\n\tstruct request_queue *q = disk->queue;\n\tstruct blk_independent_access_ranges *iars = disk->ia_ranges;\n\tint i;\n\n\tlockdep_assert_held(&q->sysfs_dir_lock);\n\tlockdep_assert_held(&q->sysfs_lock);\n\n\tif (!iars)\n\t\treturn;\n\n\tif (iars->sysfs_registered) {\n\t\tfor (i = 0; i < iars->nr_ia_ranges; i++)\n\t\t\tkobject_del(&iars->ia_range[i].kobj);\n\t\tkobject_del(&iars->kobj);\n\t\tkobject_put(&iars->kobj);\n\t} else {\n\t\tkfree(iars);\n\t}\n\n\tdisk->ia_ranges = NULL;\n}\n\nstatic struct blk_independent_access_range *\ndisk_find_ia_range(struct blk_independent_access_ranges *iars,\n\t\t  sector_t sector)\n{\n\tstruct blk_independent_access_range *iar;\n\tint i;\n\n\tfor (i = 0; i < iars->nr_ia_ranges; i++) {\n\t\tiar = &iars->ia_range[i];\n\t\tif (sector >= iar->sector &&\n\t\t    sector < iar->sector + iar->nr_sectors)\n\t\t\treturn iar;\n\t}\n\n\treturn NULL;\n}\n\nstatic bool disk_check_ia_ranges(struct gendisk *disk,\n\t\t\t\tstruct blk_independent_access_ranges *iars)\n{\n\tstruct blk_independent_access_range *iar, *tmp;\n\tsector_t capacity = get_capacity(disk);\n\tsector_t sector = 0;\n\tint i;\n\n\tif (WARN_ON_ONCE(!iars->nr_ia_ranges))\n\t\treturn false;\n\n\t \n\tfor (i = 0; i < iars->nr_ia_ranges; i++) {\n\t\ttmp = disk_find_ia_range(iars, sector);\n\t\tif (!tmp || tmp->sector != sector) {\n\t\t\tpr_warn(\"Invalid non-contiguous independent access ranges\\n\");\n\t\t\treturn false;\n\t\t}\n\n\t\tiar = &iars->ia_range[i];\n\t\tif (tmp != iar) {\n\t\t\tswap(iar->sector, tmp->sector);\n\t\t\tswap(iar->nr_sectors, tmp->nr_sectors);\n\t\t}\n\n\t\tsector += iar->nr_sectors;\n\t}\n\n\tif (sector != capacity) {\n\t\tpr_warn(\"Independent access ranges do not match disk capacity\\n\");\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic bool disk_ia_ranges_changed(struct gendisk *disk,\n\t\t\t\t   struct blk_independent_access_ranges *new)\n{\n\tstruct blk_independent_access_ranges *old = disk->ia_ranges;\n\tint i;\n\n\tif (!old)\n\t\treturn true;\n\n\tif (old->nr_ia_ranges != new->nr_ia_ranges)\n\t\treturn true;\n\n\tfor (i = 0; i < old->nr_ia_ranges; i++) {\n\t\tif (new->ia_range[i].sector != old->ia_range[i].sector ||\n\t\t    new->ia_range[i].nr_sectors != old->ia_range[i].nr_sectors)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n \nstruct blk_independent_access_ranges *\ndisk_alloc_independent_access_ranges(struct gendisk *disk, int nr_ia_ranges)\n{\n\tstruct blk_independent_access_ranges *iars;\n\n\tiars = kzalloc_node(struct_size(iars, ia_range, nr_ia_ranges),\n\t\t\t    GFP_KERNEL, disk->queue->node);\n\tif (iars)\n\t\tiars->nr_ia_ranges = nr_ia_ranges;\n\treturn iars;\n}\nEXPORT_SYMBOL_GPL(disk_alloc_independent_access_ranges);\n\n \nvoid disk_set_independent_access_ranges(struct gendisk *disk,\n\t\t\t\tstruct blk_independent_access_ranges *iars)\n{\n\tstruct request_queue *q = disk->queue;\n\n\tmutex_lock(&q->sysfs_dir_lock);\n\tmutex_lock(&q->sysfs_lock);\n\tif (iars && !disk_check_ia_ranges(disk, iars)) {\n\t\tkfree(iars);\n\t\tiars = NULL;\n\t}\n\tif (iars && !disk_ia_ranges_changed(disk, iars)) {\n\t\tkfree(iars);\n\t\tgoto unlock;\n\t}\n\n\t \n\tdisk_unregister_independent_access_ranges(disk);\n\tdisk->ia_ranges = iars;\n\tif (blk_queue_registered(q))\n\t\tdisk_register_independent_access_ranges(disk);\nunlock:\n\tmutex_unlock(&q->sysfs_lock);\n\tmutex_unlock(&q->sysfs_dir_lock);\n}\nEXPORT_SYMBOL_GPL(disk_set_independent_access_ranges);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}