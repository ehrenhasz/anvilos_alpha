{
  "module_name": "ioctl.c",
  "hash_id": "5eb94c55bc39ae8ab0c00566a72cc3b2c53c18e15213fd3781c22774e3cee352",
  "original_prompt": "Ingested from linux-6.6.14/block/ioctl.c",
  "human_readable_source": "\n#include <linux/capability.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/export.h>\n#include <linux/gfp.h>\n#include <linux/blkpg.h>\n#include <linux/hdreg.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n#include <linux/blktrace_api.h>\n#include <linux/pr.h>\n#include <linux/uaccess.h>\n#include \"blk.h\"\n\nstatic int blkpg_do_ioctl(struct block_device *bdev,\n\t\t\t  struct blkpg_partition __user *upart, int op)\n{\n\tstruct gendisk *disk = bdev->bd_disk;\n\tstruct blkpg_partition p;\n\tsector_t start, length;\n\n\tif (disk->flags & GENHD_FL_NO_PART)\n\t\treturn -EINVAL;\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EACCES;\n\tif (copy_from_user(&p, upart, sizeof(struct blkpg_partition)))\n\t\treturn -EFAULT;\n\tif (bdev_is_partition(bdev))\n\t\treturn -EINVAL;\n\n\tif (p.pno <= 0)\n\t\treturn -EINVAL;\n\n\tif (op == BLKPG_DEL_PARTITION)\n\t\treturn bdev_del_partition(disk, p.pno);\n\n\tif (p.start < 0 || p.length <= 0 || p.start + p.length < 0)\n\t\treturn -EINVAL;\n\t \n\tif (!IS_ALIGNED(p.start | p.length, bdev_logical_block_size(bdev)))\n\t\treturn -EINVAL;\n\n\tstart = p.start >> SECTOR_SHIFT;\n\tlength = p.length >> SECTOR_SHIFT;\n\n\tswitch (op) {\n\tcase BLKPG_ADD_PARTITION:\n\t\treturn bdev_add_partition(disk, p.pno, start, length);\n\tcase BLKPG_RESIZE_PARTITION:\n\t\treturn bdev_resize_partition(disk, p.pno, start, length);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int blkpg_ioctl(struct block_device *bdev,\n\t\t       struct blkpg_ioctl_arg __user *arg)\n{\n\tstruct blkpg_partition __user *udata;\n\tint op;\n\n\tif (get_user(op, &arg->op) || get_user(udata, &arg->data))\n\t\treturn -EFAULT;\n\n\treturn blkpg_do_ioctl(bdev, udata, op);\n}\n\n#ifdef CONFIG_COMPAT\nstruct compat_blkpg_ioctl_arg {\n\tcompat_int_t op;\n\tcompat_int_t flags;\n\tcompat_int_t datalen;\n\tcompat_caddr_t data;\n};\n\nstatic int compat_blkpg_ioctl(struct block_device *bdev,\n\t\t\t      struct compat_blkpg_ioctl_arg __user *arg)\n{\n\tcompat_caddr_t udata;\n\tint op;\n\n\tif (get_user(op, &arg->op) || get_user(udata, &arg->data))\n\t\treturn -EFAULT;\n\n\treturn blkpg_do_ioctl(bdev, compat_ptr(udata), op);\n}\n#endif\n\nstatic int blk_ioctl_discard(struct block_device *bdev, blk_mode_t mode,\n\t\tunsigned long arg)\n{\n\tuint64_t range[2];\n\tuint64_t start, len;\n\tstruct inode *inode = bdev->bd_inode;\n\tint err;\n\n\tif (!(mode & BLK_OPEN_WRITE))\n\t\treturn -EBADF;\n\n\tif (!bdev_max_discard_sectors(bdev))\n\t\treturn -EOPNOTSUPP;\n\n\tif (copy_from_user(range, (void __user *)arg, sizeof(range)))\n\t\treturn -EFAULT;\n\n\tstart = range[0];\n\tlen = range[1];\n\n\tif (start & 511)\n\t\treturn -EINVAL;\n\tif (len & 511)\n\t\treturn -EINVAL;\n\n\tif (start + len > bdev_nr_bytes(bdev))\n\t\treturn -EINVAL;\n\n\tfilemap_invalidate_lock(inode->i_mapping);\n\terr = truncate_bdev_range(bdev, mode, start, start + len - 1);\n\tif (err)\n\t\tgoto fail;\n\terr = blkdev_issue_discard(bdev, start >> 9, len >> 9, GFP_KERNEL);\nfail:\n\tfilemap_invalidate_unlock(inode->i_mapping);\n\treturn err;\n}\n\nstatic int blk_ioctl_secure_erase(struct block_device *bdev, blk_mode_t mode,\n\t\tvoid __user *argp)\n{\n\tuint64_t start, len;\n\tuint64_t range[2];\n\tint err;\n\n\tif (!(mode & BLK_OPEN_WRITE))\n\t\treturn -EBADF;\n\tif (!bdev_max_secure_erase_sectors(bdev))\n\t\treturn -EOPNOTSUPP;\n\tif (copy_from_user(range, argp, sizeof(range)))\n\t\treturn -EFAULT;\n\n\tstart = range[0];\n\tlen = range[1];\n\tif ((start & 511) || (len & 511))\n\t\treturn -EINVAL;\n\tif (start + len > bdev_nr_bytes(bdev))\n\t\treturn -EINVAL;\n\n\tfilemap_invalidate_lock(bdev->bd_inode->i_mapping);\n\terr = truncate_bdev_range(bdev, mode, start, start + len - 1);\n\tif (!err)\n\t\terr = blkdev_issue_secure_erase(bdev, start >> 9, len >> 9,\n\t\t\t\t\t\tGFP_KERNEL);\n\tfilemap_invalidate_unlock(bdev->bd_inode->i_mapping);\n\treturn err;\n}\n\n\nstatic int blk_ioctl_zeroout(struct block_device *bdev, blk_mode_t mode,\n\t\tunsigned long arg)\n{\n\tuint64_t range[2];\n\tuint64_t start, end, len;\n\tstruct inode *inode = bdev->bd_inode;\n\tint err;\n\n\tif (!(mode & BLK_OPEN_WRITE))\n\t\treturn -EBADF;\n\n\tif (copy_from_user(range, (void __user *)arg, sizeof(range)))\n\t\treturn -EFAULT;\n\n\tstart = range[0];\n\tlen = range[1];\n\tend = start + len - 1;\n\n\tif (start & 511)\n\t\treturn -EINVAL;\n\tif (len & 511)\n\t\treturn -EINVAL;\n\tif (end >= (uint64_t)bdev_nr_bytes(bdev))\n\t\treturn -EINVAL;\n\tif (end < start)\n\t\treturn -EINVAL;\n\n\t \n\tfilemap_invalidate_lock(inode->i_mapping);\n\terr = truncate_bdev_range(bdev, mode, start, end);\n\tif (err)\n\t\tgoto fail;\n\n\terr = blkdev_issue_zeroout(bdev, start >> 9, len >> 9, GFP_KERNEL,\n\t\t\t\t   BLKDEV_ZERO_NOUNMAP);\n\nfail:\n\tfilemap_invalidate_unlock(inode->i_mapping);\n\treturn err;\n}\n\nstatic int put_ushort(unsigned short __user *argp, unsigned short val)\n{\n\treturn put_user(val, argp);\n}\n\nstatic int put_int(int __user *argp, int val)\n{\n\treturn put_user(val, argp);\n}\n\nstatic int put_uint(unsigned int __user *argp, unsigned int val)\n{\n\treturn put_user(val, argp);\n}\n\nstatic int put_long(long __user *argp, long val)\n{\n\treturn put_user(val, argp);\n}\n\nstatic int put_ulong(unsigned long __user *argp, unsigned long val)\n{\n\treturn put_user(val, argp);\n}\n\nstatic int put_u64(u64 __user *argp, u64 val)\n{\n\treturn put_user(val, argp);\n}\n\n#ifdef CONFIG_COMPAT\nstatic int compat_put_long(compat_long_t __user *argp, long val)\n{\n\treturn put_user(val, argp);\n}\n\nstatic int compat_put_ulong(compat_ulong_t __user *argp, compat_ulong_t val)\n{\n\treturn put_user(val, argp);\n}\n#endif\n\n#ifdef CONFIG_COMPAT\n \nint blkdev_compat_ptr_ioctl(struct block_device *bdev, blk_mode_t mode,\n\t\t\tunsigned cmd, unsigned long arg)\n{\n\tstruct gendisk *disk = bdev->bd_disk;\n\n\tif (disk->fops->ioctl)\n\t\treturn disk->fops->ioctl(bdev, mode, cmd,\n\t\t\t\t\t (unsigned long)compat_ptr(arg));\n\n\treturn -ENOIOCTLCMD;\n}\nEXPORT_SYMBOL(blkdev_compat_ptr_ioctl);\n#endif\n\nstatic bool blkdev_pr_allowed(struct block_device *bdev, blk_mode_t mode)\n{\n\t \n\tif (bdev_is_partition(bdev))\n\t\treturn false;\n\n\tif (capable(CAP_SYS_ADMIN))\n\t\treturn true;\n\t \n\treturn mode & BLK_OPEN_WRITE;\n}\n\nstatic int blkdev_pr_register(struct block_device *bdev, blk_mode_t mode,\n\t\tstruct pr_registration __user *arg)\n{\n\tconst struct pr_ops *ops = bdev->bd_disk->fops->pr_ops;\n\tstruct pr_registration reg;\n\n\tif (!blkdev_pr_allowed(bdev, mode))\n\t\treturn -EPERM;\n\tif (!ops || !ops->pr_register)\n\t\treturn -EOPNOTSUPP;\n\tif (copy_from_user(&reg, arg, sizeof(reg)))\n\t\treturn -EFAULT;\n\n\tif (reg.flags & ~PR_FL_IGNORE_KEY)\n\t\treturn -EOPNOTSUPP;\n\treturn ops->pr_register(bdev, reg.old_key, reg.new_key, reg.flags);\n}\n\nstatic int blkdev_pr_reserve(struct block_device *bdev, blk_mode_t mode,\n\t\tstruct pr_reservation __user *arg)\n{\n\tconst struct pr_ops *ops = bdev->bd_disk->fops->pr_ops;\n\tstruct pr_reservation rsv;\n\n\tif (!blkdev_pr_allowed(bdev, mode))\n\t\treturn -EPERM;\n\tif (!ops || !ops->pr_reserve)\n\t\treturn -EOPNOTSUPP;\n\tif (copy_from_user(&rsv, arg, sizeof(rsv)))\n\t\treturn -EFAULT;\n\n\tif (rsv.flags & ~PR_FL_IGNORE_KEY)\n\t\treturn -EOPNOTSUPP;\n\treturn ops->pr_reserve(bdev, rsv.key, rsv.type, rsv.flags);\n}\n\nstatic int blkdev_pr_release(struct block_device *bdev, blk_mode_t mode,\n\t\tstruct pr_reservation __user *arg)\n{\n\tconst struct pr_ops *ops = bdev->bd_disk->fops->pr_ops;\n\tstruct pr_reservation rsv;\n\n\tif (!blkdev_pr_allowed(bdev, mode))\n\t\treturn -EPERM;\n\tif (!ops || !ops->pr_release)\n\t\treturn -EOPNOTSUPP;\n\tif (copy_from_user(&rsv, arg, sizeof(rsv)))\n\t\treturn -EFAULT;\n\n\tif (rsv.flags)\n\t\treturn -EOPNOTSUPP;\n\treturn ops->pr_release(bdev, rsv.key, rsv.type);\n}\n\nstatic int blkdev_pr_preempt(struct block_device *bdev, blk_mode_t mode,\n\t\tstruct pr_preempt __user *arg, bool abort)\n{\n\tconst struct pr_ops *ops = bdev->bd_disk->fops->pr_ops;\n\tstruct pr_preempt p;\n\n\tif (!blkdev_pr_allowed(bdev, mode))\n\t\treturn -EPERM;\n\tif (!ops || !ops->pr_preempt)\n\t\treturn -EOPNOTSUPP;\n\tif (copy_from_user(&p, arg, sizeof(p)))\n\t\treturn -EFAULT;\n\n\tif (p.flags)\n\t\treturn -EOPNOTSUPP;\n\treturn ops->pr_preempt(bdev, p.old_key, p.new_key, p.type, abort);\n}\n\nstatic int blkdev_pr_clear(struct block_device *bdev, blk_mode_t mode,\n\t\tstruct pr_clear __user *arg)\n{\n\tconst struct pr_ops *ops = bdev->bd_disk->fops->pr_ops;\n\tstruct pr_clear c;\n\n\tif (!blkdev_pr_allowed(bdev, mode))\n\t\treturn -EPERM;\n\tif (!ops || !ops->pr_clear)\n\t\treturn -EOPNOTSUPP;\n\tif (copy_from_user(&c, arg, sizeof(c)))\n\t\treturn -EFAULT;\n\n\tif (c.flags)\n\t\treturn -EOPNOTSUPP;\n\treturn ops->pr_clear(bdev, c.key);\n}\n\nstatic int blkdev_flushbuf(struct block_device *bdev, unsigned cmd,\n\t\tunsigned long arg)\n{\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EACCES;\n\n\tmutex_lock(&bdev->bd_holder_lock);\n\tif (bdev->bd_holder_ops && bdev->bd_holder_ops->sync)\n\t\tbdev->bd_holder_ops->sync(bdev);\n\telse\n\t\tsync_blockdev(bdev);\n\tmutex_unlock(&bdev->bd_holder_lock);\n\n\tinvalidate_bdev(bdev);\n\treturn 0;\n}\n\nstatic int blkdev_roset(struct block_device *bdev, unsigned cmd,\n\t\tunsigned long arg)\n{\n\tint ret, n;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EACCES;\n\n\tif (get_user(n, (int __user *)arg))\n\t\treturn -EFAULT;\n\tif (bdev->bd_disk->fops->set_read_only) {\n\t\tret = bdev->bd_disk->fops->set_read_only(bdev, n);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\tbdev->bd_read_only = n;\n\treturn 0;\n}\n\nstatic int blkdev_getgeo(struct block_device *bdev,\n\t\tstruct hd_geometry __user *argp)\n{\n\tstruct gendisk *disk = bdev->bd_disk;\n\tstruct hd_geometry geo;\n\tint ret;\n\n\tif (!argp)\n\t\treturn -EINVAL;\n\tif (!disk->fops->getgeo)\n\t\treturn -ENOTTY;\n\n\t \n\tmemset(&geo, 0, sizeof(geo));\n\tgeo.start = get_start_sect(bdev);\n\tret = disk->fops->getgeo(bdev, &geo);\n\tif (ret)\n\t\treturn ret;\n\tif (copy_to_user(argp, &geo, sizeof(geo)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\n#ifdef CONFIG_COMPAT\nstruct compat_hd_geometry {\n\tunsigned char heads;\n\tunsigned char sectors;\n\tunsigned short cylinders;\n\tu32 start;\n};\n\nstatic int compat_hdio_getgeo(struct block_device *bdev,\n\t\t\t      struct compat_hd_geometry __user *ugeo)\n{\n\tstruct gendisk *disk = bdev->bd_disk;\n\tstruct hd_geometry geo;\n\tint ret;\n\n\tif (!ugeo)\n\t\treturn -EINVAL;\n\tif (!disk->fops->getgeo)\n\t\treturn -ENOTTY;\n\n\tmemset(&geo, 0, sizeof(geo));\n\t \n\tgeo.start = get_start_sect(bdev);\n\tret = disk->fops->getgeo(bdev, &geo);\n\tif (ret)\n\t\treturn ret;\n\n\tret = copy_to_user(ugeo, &geo, 4);\n\tret |= put_user(geo.start, &ugeo->start);\n\tif (ret)\n\t\tret = -EFAULT;\n\n\treturn ret;\n}\n#endif\n\n \nstatic int blkdev_bszset(struct block_device *bdev, blk_mode_t mode,\n\t\tint __user *argp)\n{\n\tint ret, n;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EACCES;\n\tif (!argp)\n\t\treturn -EINVAL;\n\tif (get_user(n, argp))\n\t\treturn -EFAULT;\n\n\tif (mode & BLK_OPEN_EXCL)\n\t\treturn set_blocksize(bdev, n);\n\n\tif (IS_ERR(blkdev_get_by_dev(bdev->bd_dev, mode, &bdev, NULL)))\n\t\treturn -EBUSY;\n\tret = set_blocksize(bdev, n);\n\tblkdev_put(bdev, &bdev);\n\n\treturn ret;\n}\n\n \nstatic int blkdev_common_ioctl(struct block_device *bdev, blk_mode_t mode,\n\t\t\t       unsigned int cmd, unsigned long arg,\n\t\t\t       void __user *argp)\n{\n\tunsigned int max_sectors;\n\n\tswitch (cmd) {\n\tcase BLKFLSBUF:\n\t\treturn blkdev_flushbuf(bdev, cmd, arg);\n\tcase BLKROSET:\n\t\treturn blkdev_roset(bdev, cmd, arg);\n\tcase BLKDISCARD:\n\t\treturn blk_ioctl_discard(bdev, mode, arg);\n\tcase BLKSECDISCARD:\n\t\treturn blk_ioctl_secure_erase(bdev, mode, argp);\n\tcase BLKZEROOUT:\n\t\treturn blk_ioctl_zeroout(bdev, mode, arg);\n\tcase BLKGETDISKSEQ:\n\t\treturn put_u64(argp, bdev->bd_disk->diskseq);\n\tcase BLKREPORTZONE:\n\t\treturn blkdev_report_zones_ioctl(bdev, cmd, arg);\n\tcase BLKRESETZONE:\n\tcase BLKOPENZONE:\n\tcase BLKCLOSEZONE:\n\tcase BLKFINISHZONE:\n\t\treturn blkdev_zone_mgmt_ioctl(bdev, mode, cmd, arg);\n\tcase BLKGETZONESZ:\n\t\treturn put_uint(argp, bdev_zone_sectors(bdev));\n\tcase BLKGETNRZONES:\n\t\treturn put_uint(argp, bdev_nr_zones(bdev));\n\tcase BLKROGET:\n\t\treturn put_int(argp, bdev_read_only(bdev) != 0);\n\tcase BLKSSZGET:  \n\t\treturn put_int(argp, bdev_logical_block_size(bdev));\n\tcase BLKPBSZGET:  \n\t\treturn put_uint(argp, bdev_physical_block_size(bdev));\n\tcase BLKIOMIN:\n\t\treturn put_uint(argp, bdev_io_min(bdev));\n\tcase BLKIOOPT:\n\t\treturn put_uint(argp, bdev_io_opt(bdev));\n\tcase BLKALIGNOFF:\n\t\treturn put_int(argp, bdev_alignment_offset(bdev));\n\tcase BLKDISCARDZEROES:\n\t\treturn put_uint(argp, 0);\n\tcase BLKSECTGET:\n\t\tmax_sectors = min_t(unsigned int, USHRT_MAX,\n\t\t\t\t    queue_max_sectors(bdev_get_queue(bdev)));\n\t\treturn put_ushort(argp, max_sectors);\n\tcase BLKROTATIONAL:\n\t\treturn put_ushort(argp, !bdev_nonrot(bdev));\n\tcase BLKRASET:\n\tcase BLKFRASET:\n\t\tif(!capable(CAP_SYS_ADMIN))\n\t\t\treturn -EACCES;\n\t\tbdev->bd_disk->bdi->ra_pages = (arg * 512) / PAGE_SIZE;\n\t\treturn 0;\n\tcase BLKRRPART:\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn -EACCES;\n\t\tif (bdev_is_partition(bdev))\n\t\t\treturn -EINVAL;\n\t\treturn disk_scan_partitions(bdev->bd_disk, mode);\n\tcase BLKTRACESTART:\n\tcase BLKTRACESTOP:\n\tcase BLKTRACETEARDOWN:\n\t\treturn blk_trace_ioctl(bdev, cmd, argp);\n\tcase IOC_PR_REGISTER:\n\t\treturn blkdev_pr_register(bdev, mode, argp);\n\tcase IOC_PR_RESERVE:\n\t\treturn blkdev_pr_reserve(bdev, mode, argp);\n\tcase IOC_PR_RELEASE:\n\t\treturn blkdev_pr_release(bdev, mode, argp);\n\tcase IOC_PR_PREEMPT:\n\t\treturn blkdev_pr_preempt(bdev, mode, argp, false);\n\tcase IOC_PR_PREEMPT_ABORT:\n\t\treturn blkdev_pr_preempt(bdev, mode, argp, true);\n\tcase IOC_PR_CLEAR:\n\t\treturn blkdev_pr_clear(bdev, mode, argp);\n\tdefault:\n\t\treturn -ENOIOCTLCMD;\n\t}\n}\n\n \nlong blkdev_ioctl(struct file *file, unsigned cmd, unsigned long arg)\n{\n\tstruct block_device *bdev = I_BDEV(file->f_mapping->host);\n\tvoid __user *argp = (void __user *)arg;\n\tblk_mode_t mode = file_to_blk_mode(file);\n\tint ret;\n\n\tswitch (cmd) {\n\t \n\tcase HDIO_GETGEO:\n\t\treturn blkdev_getgeo(bdev, argp);\n\tcase BLKPG:\n\t\treturn blkpg_ioctl(bdev, argp);\n\n\t \n\tcase BLKRAGET:\n\tcase BLKFRAGET:\n\t\tif (!argp)\n\t\t\treturn -EINVAL;\n\t\treturn put_long(argp,\n\t\t\t(bdev->bd_disk->bdi->ra_pages * PAGE_SIZE) / 512);\n\tcase BLKGETSIZE:\n\t\tif (bdev_nr_sectors(bdev) > ~0UL)\n\t\t\treturn -EFBIG;\n\t\treturn put_ulong(argp, bdev_nr_sectors(bdev));\n\n\t \n\tcase BLKBSZGET:  \n\t\treturn put_int(argp, block_size(bdev));\n\tcase BLKBSZSET:\n\t\treturn blkdev_bszset(bdev, mode, argp);\n\tcase BLKGETSIZE64:\n\t\treturn put_u64(argp, bdev_nr_bytes(bdev));\n\n\t \n\tcase BLKTRACESETUP:\n\t\treturn blk_trace_ioctl(bdev, cmd, argp);\n\tdefault:\n\t\tbreak;\n\t}\n\n\tret = blkdev_common_ioctl(bdev, mode, cmd, arg, argp);\n\tif (ret != -ENOIOCTLCMD)\n\t\treturn ret;\n\n\tif (!bdev->bd_disk->fops->ioctl)\n\t\treturn -ENOTTY;\n\treturn bdev->bd_disk->fops->ioctl(bdev, mode, cmd, arg);\n}\n\n#ifdef CONFIG_COMPAT\n\n#define BLKBSZGET_32\t\t_IOR(0x12, 112, int)\n#define BLKBSZSET_32\t\t_IOW(0x12, 113, int)\n#define BLKGETSIZE64_32\t\t_IOR(0x12, 114, int)\n\n \nlong compat_blkdev_ioctl(struct file *file, unsigned cmd, unsigned long arg)\n{\n\tint ret;\n\tvoid __user *argp = compat_ptr(arg);\n\tstruct block_device *bdev = I_BDEV(file->f_mapping->host);\n\tstruct gendisk *disk = bdev->bd_disk;\n\tblk_mode_t mode = file_to_blk_mode(file);\n\n\tswitch (cmd) {\n\t \n\tcase HDIO_GETGEO:\n\t\treturn compat_hdio_getgeo(bdev, argp);\n\tcase BLKPG:\n\t\treturn compat_blkpg_ioctl(bdev, argp);\n\n\t \n\tcase BLKRAGET:\n\tcase BLKFRAGET:\n\t\tif (!argp)\n\t\t\treturn -EINVAL;\n\t\treturn compat_put_long(argp,\n\t\t\t(bdev->bd_disk->bdi->ra_pages * PAGE_SIZE) / 512);\n\tcase BLKGETSIZE:\n\t\tif (bdev_nr_sectors(bdev) > ~(compat_ulong_t)0)\n\t\t\treturn -EFBIG;\n\t\treturn compat_put_ulong(argp, bdev_nr_sectors(bdev));\n\n\t \n\tcase BLKBSZGET_32:  \n\t\treturn put_int(argp, bdev_logical_block_size(bdev));\n\tcase BLKBSZSET_32:\n\t\treturn blkdev_bszset(bdev, mode, argp);\n\tcase BLKGETSIZE64_32:\n\t\treturn put_u64(argp, bdev_nr_bytes(bdev));\n\n\t \n\tcase BLKTRACESETUP32:\n\t\treturn blk_trace_ioctl(bdev, cmd, argp);\n\tdefault:\n\t\tbreak;\n\t}\n\n\tret = blkdev_common_ioctl(bdev, mode, cmd, arg, argp);\n\tif (ret == -ENOIOCTLCMD && disk->fops->compat_ioctl)\n\t\tret = disk->fops->compat_ioctl(bdev, mode, cmd, arg);\n\n\treturn ret;\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}