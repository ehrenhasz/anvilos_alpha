{
  "module_name": "badblocks.c",
  "hash_id": "df6ae14868392d5f05b1bbbd3fd0ca1d2ec6388766097d2b91fc858c05a7247a",
  "original_prompt": "Ingested from linux-6.6.14/block/badblocks.c",
  "human_readable_source": "\n \n\n#include <linux/badblocks.h>\n#include <linux/seqlock.h>\n#include <linux/device.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/stddef.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n\n \nint badblocks_check(struct badblocks *bb, sector_t s, int sectors,\n\t\t\tsector_t *first_bad, int *bad_sectors)\n{\n\tint hi;\n\tint lo;\n\tu64 *p = bb->page;\n\tint rv;\n\tsector_t target = s + sectors;\n\tunsigned seq;\n\n\tif (bb->shift > 0) {\n\t\t \n\t\ts >>= bb->shift;\n\t\ttarget += (1<<bb->shift) - 1;\n\t\ttarget >>= bb->shift;\n\t}\n\t \n\nretry:\n\tseq = read_seqbegin(&bb->lock);\n\tlo = 0;\n\trv = 0;\n\thi = bb->count;\n\n\t \n\t \n\twhile (hi - lo > 1) {\n\t\tint mid = (lo + hi) / 2;\n\t\tsector_t a = BB_OFFSET(p[mid]);\n\n\t\tif (a < target)\n\t\t\t \n\t\t\tlo = mid;\n\t\telse\n\t\t\t \n\t\t\thi = mid;\n\t}\n\t \n\tif (hi > lo) {\n\t\t \n\t\twhile (lo >= 0 &&\n\t\t       BB_OFFSET(p[lo]) + BB_LEN(p[lo]) > s) {\n\t\t\tif (BB_OFFSET(p[lo]) < target) {\n\t\t\t\t \n\t\t\t\tif (rv != -1 && BB_ACK(p[lo]))\n\t\t\t\t\trv = 1;\n\t\t\t\telse\n\t\t\t\t\trv = -1;\n\t\t\t\t*first_bad = BB_OFFSET(p[lo]);\n\t\t\t\t*bad_sectors = BB_LEN(p[lo]);\n\t\t\t}\n\t\t\tlo--;\n\t\t}\n\t}\n\n\tif (read_seqretry(&bb->lock, seq))\n\t\tgoto retry;\n\n\treturn rv;\n}\nEXPORT_SYMBOL_GPL(badblocks_check);\n\nstatic void badblocks_update_acked(struct badblocks *bb)\n{\n\tu64 *p = bb->page;\n\tint i;\n\tbool unacked = false;\n\n\tif (!bb->unacked_exist)\n\t\treturn;\n\n\tfor (i = 0; i < bb->count ; i++) {\n\t\tif (!BB_ACK(p[i])) {\n\t\t\tunacked = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!unacked)\n\t\tbb->unacked_exist = 0;\n}\n\n \nint badblocks_set(struct badblocks *bb, sector_t s, int sectors,\n\t\t\tint acknowledged)\n{\n\tu64 *p;\n\tint lo, hi;\n\tint rv = 0;\n\tunsigned long flags;\n\n\tif (bb->shift < 0)\n\t\t \n\t\treturn 1;\n\n\tif (bb->shift) {\n\t\t \n\t\tsector_t next = s + sectors;\n\n\t\ts >>= bb->shift;\n\t\tnext += (1<<bb->shift) - 1;\n\t\tnext >>= bb->shift;\n\t\tsectors = next - s;\n\t}\n\n\twrite_seqlock_irqsave(&bb->lock, flags);\n\n\tp = bb->page;\n\tlo = 0;\n\thi = bb->count;\n\t \n\twhile (hi - lo > 1) {\n\t\tint mid = (lo + hi) / 2;\n\t\tsector_t a = BB_OFFSET(p[mid]);\n\n\t\tif (a <= s)\n\t\t\tlo = mid;\n\t\telse\n\t\t\thi = mid;\n\t}\n\tif (hi > lo && BB_OFFSET(p[lo]) > s)\n\t\thi = lo;\n\n\tif (hi > lo) {\n\t\t \n\t\tsector_t a = BB_OFFSET(p[lo]);\n\t\tsector_t e = a + BB_LEN(p[lo]);\n\t\tint ack = BB_ACK(p[lo]);\n\n\t\tif (e >= s) {\n\t\t\t \n\t\t\tif (s == a && s + sectors >= e)\n\t\t\t\t \n\t\t\t\tack = acknowledged;\n\t\t\telse\n\t\t\t\tack = ack && acknowledged;\n\n\t\t\tif (e < s + sectors)\n\t\t\t\te = s + sectors;\n\t\t\tif (e - a <= BB_MAX_LEN) {\n\t\t\t\tp[lo] = BB_MAKE(a, e-a, ack);\n\t\t\t\ts = e;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tif (BB_LEN(p[lo]) != BB_MAX_LEN)\n\t\t\t\t\tp[lo] = BB_MAKE(a, BB_MAX_LEN, ack);\n\t\t\t\ts = a + BB_MAX_LEN;\n\t\t\t}\n\t\t\tsectors = e - s;\n\t\t}\n\t}\n\tif (sectors && hi < bb->count) {\n\t\t \n\t\tsector_t a = BB_OFFSET(p[hi]);\n\t\tsector_t e = a + BB_LEN(p[hi]);\n\t\tint ack = BB_ACK(p[hi]);\n\n\t\tif (a <= s + sectors) {\n\t\t\t \n\t\t\tif (e <= s + sectors) {\n\t\t\t\t \n\t\t\t\te = s + sectors;\n\t\t\t\tack = acknowledged;\n\t\t\t} else\n\t\t\t\tack = ack && acknowledged;\n\n\t\t\ta = s;\n\t\t\tif (e - a <= BB_MAX_LEN) {\n\t\t\t\tp[hi] = BB_MAKE(a, e-a, ack);\n\t\t\t\ts = e;\n\t\t\t} else {\n\t\t\t\tp[hi] = BB_MAKE(a, BB_MAX_LEN, ack);\n\t\t\t\ts = a + BB_MAX_LEN;\n\t\t\t}\n\t\t\tsectors = e - s;\n\t\t\tlo = hi;\n\t\t\thi++;\n\t\t}\n\t}\n\tif (sectors == 0 && hi < bb->count) {\n\t\t \n\t\t \n\t\tsector_t a = BB_OFFSET(p[hi]);\n\t\tint lolen = BB_LEN(p[lo]);\n\t\tint hilen = BB_LEN(p[hi]);\n\t\tint newlen = lolen + hilen - (s - a);\n\n\t\tif (s >= a && newlen < BB_MAX_LEN) {\n\t\t\t \n\t\t\tint ack = BB_ACK(p[lo]) && BB_ACK(p[hi]);\n\n\t\t\tp[lo] = BB_MAKE(BB_OFFSET(p[lo]), newlen, ack);\n\t\t\tmemmove(p + hi, p + hi + 1,\n\t\t\t\t(bb->count - hi - 1) * 8);\n\t\t\tbb->count--;\n\t\t}\n\t}\n\twhile (sectors) {\n\t\t \n\t\tif (bb->count >= MAX_BADBLOCKS) {\n\t\t\t \n\t\t\trv = 1;\n\t\t\tbreak;\n\t\t} else {\n\t\t\tint this_sectors = sectors;\n\n\t\t\tmemmove(p + hi + 1, p + hi,\n\t\t\t\t(bb->count - hi) * 8);\n\t\t\tbb->count++;\n\n\t\t\tif (this_sectors > BB_MAX_LEN)\n\t\t\t\tthis_sectors = BB_MAX_LEN;\n\t\t\tp[hi] = BB_MAKE(s, this_sectors, acknowledged);\n\t\t\tsectors -= this_sectors;\n\t\t\ts += this_sectors;\n\t\t}\n\t}\n\n\tbb->changed = 1;\n\tif (!acknowledged)\n\t\tbb->unacked_exist = 1;\n\telse\n\t\tbadblocks_update_acked(bb);\n\twrite_sequnlock_irqrestore(&bb->lock, flags);\n\n\treturn rv;\n}\nEXPORT_SYMBOL_GPL(badblocks_set);\n\n \nint badblocks_clear(struct badblocks *bb, sector_t s, int sectors)\n{\n\tu64 *p;\n\tint lo, hi;\n\tsector_t target = s + sectors;\n\tint rv = 0;\n\n\tif (bb->shift > 0) {\n\t\t \n\t\ts += (1<<bb->shift) - 1;\n\t\ts >>= bb->shift;\n\t\ttarget >>= bb->shift;\n\t}\n\n\twrite_seqlock_irq(&bb->lock);\n\n\tp = bb->page;\n\tlo = 0;\n\thi = bb->count;\n\t \n\twhile (hi - lo > 1) {\n\t\tint mid = (lo + hi) / 2;\n\t\tsector_t a = BB_OFFSET(p[mid]);\n\n\t\tif (a < target)\n\t\t\tlo = mid;\n\t\telse\n\t\t\thi = mid;\n\t}\n\tif (hi > lo) {\n\t\t \n\t\tif ((BB_OFFSET(p[lo]) + BB_LEN(p[lo]) > target) &&\n\t\t    (BB_OFFSET(p[lo]) < target)) {\n\t\t\t \n\t\t\tint ack = BB_ACK(p[lo]);\n\t\t\tsector_t a = BB_OFFSET(p[lo]);\n\t\t\tsector_t end = a + BB_LEN(p[lo]);\n\n\t\t\tif (a < s) {\n\t\t\t\t \n\t\t\t\tif (bb->count >= MAX_BADBLOCKS) {\n\t\t\t\t\trv = -ENOSPC;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tmemmove(p+lo+1, p+lo, (bb->count - lo) * 8);\n\t\t\t\tbb->count++;\n\t\t\t\tp[lo] = BB_MAKE(a, s-a, ack);\n\t\t\t\tlo++;\n\t\t\t}\n\t\t\tp[lo] = BB_MAKE(target, end - target, ack);\n\t\t\t \n\t\t\thi = lo;\n\t\t\tlo--;\n\t\t}\n\t\twhile (lo >= 0 &&\n\t\t       (BB_OFFSET(p[lo]) + BB_LEN(p[lo]) > s) &&\n\t\t       (BB_OFFSET(p[lo]) < target)) {\n\t\t\t \n\t\t\tif (BB_OFFSET(p[lo]) < s) {\n\t\t\t\t \n\t\t\t\tint ack = BB_ACK(p[lo]);\n\t\t\t\tsector_t start = BB_OFFSET(p[lo]);\n\n\t\t\t\tp[lo] = BB_MAKE(start, s - start, ack);\n\t\t\t\t \n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tlo--;\n\t\t}\n\t\t \n\t\tif (hi - lo > 1) {\n\t\t\tmemmove(p+lo+1, p+hi, (bb->count - hi) * 8);\n\t\t\tbb->count -= (hi - lo - 1);\n\t\t}\n\t}\n\n\tbadblocks_update_acked(bb);\n\tbb->changed = 1;\nout:\n\twrite_sequnlock_irq(&bb->lock);\n\treturn rv;\n}\nEXPORT_SYMBOL_GPL(badblocks_clear);\n\n \nvoid ack_all_badblocks(struct badblocks *bb)\n{\n\tif (bb->page == NULL || bb->changed)\n\t\t \n\t\treturn;\n\twrite_seqlock_irq(&bb->lock);\n\n\tif (bb->changed == 0 && bb->unacked_exist) {\n\t\tu64 *p = bb->page;\n\t\tint i;\n\n\t\tfor (i = 0; i < bb->count ; i++) {\n\t\t\tif (!BB_ACK(p[i])) {\n\t\t\t\tsector_t start = BB_OFFSET(p[i]);\n\t\t\t\tint len = BB_LEN(p[i]);\n\n\t\t\t\tp[i] = BB_MAKE(start, len, 1);\n\t\t\t}\n\t\t}\n\t\tbb->unacked_exist = 0;\n\t}\n\twrite_sequnlock_irq(&bb->lock);\n}\nEXPORT_SYMBOL_GPL(ack_all_badblocks);\n\n \nssize_t badblocks_show(struct badblocks *bb, char *page, int unack)\n{\n\tsize_t len;\n\tint i;\n\tu64 *p = bb->page;\n\tunsigned seq;\n\n\tif (bb->shift < 0)\n\t\treturn 0;\n\nretry:\n\tseq = read_seqbegin(&bb->lock);\n\n\tlen = 0;\n\ti = 0;\n\n\twhile (len < PAGE_SIZE && i < bb->count) {\n\t\tsector_t s = BB_OFFSET(p[i]);\n\t\tunsigned int length = BB_LEN(p[i]);\n\t\tint ack = BB_ACK(p[i]);\n\n\t\ti++;\n\n\t\tif (unack && ack)\n\t\t\tcontinue;\n\n\t\tlen += snprintf(page+len, PAGE_SIZE-len, \"%llu %u\\n\",\n\t\t\t\t(unsigned long long)s << bb->shift,\n\t\t\t\tlength << bb->shift);\n\t}\n\tif (unack && len == 0)\n\t\tbb->unacked_exist = 0;\n\n\tif (read_seqretry(&bb->lock, seq))\n\t\tgoto retry;\n\n\treturn len;\n}\nEXPORT_SYMBOL_GPL(badblocks_show);\n\n \nssize_t badblocks_store(struct badblocks *bb, const char *page, size_t len,\n\t\t\tint unack)\n{\n\tunsigned long long sector;\n\tint length;\n\tchar newline;\n\n\tswitch (sscanf(page, \"%llu %d%c\", &sector, &length, &newline)) {\n\tcase 3:\n\t\tif (newline != '\\n')\n\t\t\treturn -EINVAL;\n\t\tfallthrough;\n\tcase 2:\n\t\tif (length <= 0)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (badblocks_set(bb, sector, length, !unack))\n\t\treturn -ENOSPC;\n\telse\n\t\treturn len;\n}\nEXPORT_SYMBOL_GPL(badblocks_store);\n\nstatic int __badblocks_init(struct device *dev, struct badblocks *bb,\n\t\tint enable)\n{\n\tbb->dev = dev;\n\tbb->count = 0;\n\tif (enable)\n\t\tbb->shift = 0;\n\telse\n\t\tbb->shift = -1;\n\tif (dev)\n\t\tbb->page = devm_kzalloc(dev, PAGE_SIZE, GFP_KERNEL);\n\telse\n\t\tbb->page = kzalloc(PAGE_SIZE, GFP_KERNEL);\n\tif (!bb->page) {\n\t\tbb->shift = -1;\n\t\treturn -ENOMEM;\n\t}\n\tseqlock_init(&bb->lock);\n\n\treturn 0;\n}\n\n \nint badblocks_init(struct badblocks *bb, int enable)\n{\n\treturn __badblocks_init(NULL, bb, enable);\n}\nEXPORT_SYMBOL_GPL(badblocks_init);\n\nint devm_init_badblocks(struct device *dev, struct badblocks *bb)\n{\n\tif (!bb)\n\t\treturn -EINVAL;\n\treturn __badblocks_init(dev, bb, 1);\n}\nEXPORT_SYMBOL_GPL(devm_init_badblocks);\n\n \nvoid badblocks_exit(struct badblocks *bb)\n{\n\tif (!bb)\n\t\treturn;\n\tif (bb->dev)\n\t\tdevm_kfree(bb->dev, bb->page);\n\telse\n\t\tkfree(bb->page);\n\tbb->page = NULL;\n}\nEXPORT_SYMBOL_GPL(badblocks_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}