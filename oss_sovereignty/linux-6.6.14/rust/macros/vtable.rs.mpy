{
  "module_name": "vtable.rs",
  "hash_id": "9b4f8db1b0f83d3411ae7ca3152f4f8c3460afb04a785611b3060e66f3f41e87",
  "original_prompt": "Ingested from linux-6.6.14/rust/macros/vtable.rs",
  "human_readable_source": "// SPDX-License-Identifier: GPL-2.0\n\nuse proc_macro::{Delimiter, Group, TokenStream, TokenTree};\nuse std::collections::HashSet;\nuse std::fmt::Write;\n\npub(crate) fn vtable(_attr: TokenStream, ts: TokenStream) -> TokenStream {\n    let mut tokens: Vec<_> = ts.into_iter().collect();\n\n    // Scan for the `trait` or `impl` keyword.\n    let is_trait = tokens\n        .iter()\n        .find_map(|token| match token {\n            TokenTree::Ident(ident) => match ident.to_string().as_str() {\n                \"trait\" => Some(true),\n                \"impl\" => Some(false),\n                _ => None,\n            },\n            _ => None,\n        })\n        .expect(\"#[vtable] attribute should only be applied to trait or impl block\");\n\n    // Retrieve the main body. The main body should be the last token tree.\n    let body = match tokens.pop() {\n        Some(TokenTree::Group(group)) if group.delimiter() == Delimiter::Brace => group,\n        _ => panic!(\"cannot locate main body of trait or impl block\"),\n    };\n\n    let mut body_it = body.stream().into_iter();\n    let mut functions = Vec::new();\n    let mut consts = HashSet::new();\n    while let Some(token) = body_it.next() {\n        match token {\n            TokenTree::Ident(ident) if ident.to_string() == \"fn\" => {\n                let fn_name = match body_it.next() {\n                    Some(TokenTree::Ident(ident)) => ident.to_string(),\n                    // Possibly we've encountered a fn pointer type instead.\n                    _ => continue,\n                };\n                functions.push(fn_name);\n            }\n            TokenTree::Ident(ident) if ident.to_string() == \"const\" => {\n                let const_name = match body_it.next() {\n                    Some(TokenTree::Ident(ident)) => ident.to_string(),\n                    // Possibly we've encountered an inline const block instead.\n                    _ => continue,\n                };\n                consts.insert(const_name);\n            }\n            _ => (),\n        }\n    }\n\n    let mut const_items;\n    if is_trait {\n        const_items = \"\n                /// A marker to prevent implementors from forgetting to use [`#[vtable]`](vtable)\n                /// attribute when implementing this trait.\n                const USE_VTABLE_ATTR: ();\n        \"\n        .to_owned();\n\n        for f in functions {\n            let gen_const_name = format!(\"HAS_{}\", f.to_uppercase());\n            // Skip if it's declared already -- this allows user override.\n            if consts.contains(&gen_const_name) {\n                continue;\n            }\n            // We don't know on the implementation-site whether a method is required or provided\n            // so we have to generate a const for all methods.\n            write!(\n                const_items,\n                \"/// Indicates if the `{f}` method is overridden by the implementor.\n                const {gen_const_name}: bool = false;\",\n            )\n            .unwrap();\n            consts.insert(gen_const_name);\n        }\n    } else {\n        const_items = \"const USE_VTABLE_ATTR: () = ();\".to_owned();\n\n        for f in functions {\n            let gen_const_name = format!(\"HAS_{}\", f.to_uppercase());\n            if consts.contains(&gen_const_name) {\n                continue;\n            }\n            write!(const_items, \"const {gen_const_name}: bool = true;\").unwrap();\n        }\n    }\n\n    let new_body = vec![const_items.parse().unwrap(), body.stream()]\n        .into_iter()\n        .collect();\n    tokens.push(TokenTree::Group(Group::new(Delimiter::Brace, new_body)));\n    tokens.into_iter().collect()\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}