{
  "module_name": "lib.rs",
  "hash_id": "02472ae9f0761cd8421a41c4fa57714a113a77fb162cc0f8cfd1645e2aca4a18",
  "original_prompt": "Ingested from linux-6.6.14/rust/macros/lib.rs",
  "human_readable_source": "// SPDX-License-Identifier: GPL-2.0\n\n//! Crate for all kernel procedural macros.\n\n#[macro_use]\nmod quote;\nmod concat_idents;\nmod helpers;\nmod module;\nmod paste;\nmod pin_data;\nmod pinned_drop;\nmod vtable;\nmod zeroable;\n\nuse proc_macro::TokenStream;\n\n/// Declares a kernel module.\n///\n/// The `type` argument should be a type which implements the [`Module`]\n/// trait. Also accepts various forms of kernel metadata.\n///\n/// C header: [`include/linux/moduleparam.h`](../../../include/linux/moduleparam.h)\n///\n/// [`Module`]: ../kernel/trait.Module.html\n///\n/// # Examples\n///\n/// ```ignore\n/// use kernel::prelude::*;\n///\n/// module!{\n///     type: MyModule,\n///     name: \"my_kernel_module\",\n///     author: \"Rust for Linux Contributors\",\n///     description: \"My very own kernel module!\",\n///     license: \"GPL\",\n///     params: {\n///        my_i32: i32 {\n///            default: 42,\n///            permissions: 0o000,\n///            description: \"Example of i32\",\n///        },\n///        writeable_i32: i32 {\n///            default: 42,\n///            permissions: 0o644,\n///            description: \"Example of i32\",\n///        },\n///    },\n/// }\n///\n/// struct MyModule;\n///\n/// impl kernel::Module for MyModule {\n///     fn init() -> Result<Self> {\n///         // If the parameter is writeable, then the kparam lock must be\n///         // taken to read the parameter:\n///         {\n///             let lock = THIS_MODULE.kernel_param_lock();\n///             pr_info!(\"i32 param is:  {}\\n\", writeable_i32.read(&lock));\n///         }\n///         // If the parameter is read only, it can be read without locking\n///         // the kernel parameters:\n///         pr_info!(\"i32 param is:  {}\\n\", my_i32.read());\n///         Ok(Self)\n///     }\n/// }\n/// ```\n///\n/// # Supported argument types\n///   - `type`: type which implements the [`Module`] trait (required).\n///   - `name`: byte array of the name of the kernel module (required).\n///   - `author`: byte array of the author of the kernel module.\n///   - `description`: byte array of the description of the kernel module.\n///   - `license`: byte array of the license of the kernel module (required).\n///   - `alias`: byte array of alias name of the kernel module.\n#[proc_macro]\npub fn module(ts: TokenStream) -> TokenStream {\n    module::module(ts)\n}\n\n/// Declares or implements a vtable trait.\n///\n/// Linux's use of pure vtables is very close to Rust traits, but they differ\n/// in how unimplemented functions are represented. In Rust, traits can provide\n/// default implementation for all non-required methods (and the default\n/// implementation could just return `Error::EINVAL`); Linux typically use C\n/// `NULL` pointers to represent these functions.\n///\n/// This attribute is intended to close the gap. Traits can be declared and\n/// implemented with the `#[vtable]` attribute, and a `HAS_*` associated constant\n/// will be generated for each method in the trait, indicating if the implementor\n/// has overridden a method.\n///\n/// This attribute is not needed if all methods are required.\n///\n/// # Examples\n///\n/// ```ignore\n/// use kernel::prelude::*;\n///\n/// // Declares a `#[vtable]` trait\n/// #[vtable]\n/// pub trait Operations: Send + Sync + Sized {\n///     fn foo(&self) -> Result<()> {\n///         Err(EINVAL)\n///     }\n///\n///     fn bar(&self) -> Result<()> {\n///         Err(EINVAL)\n///     }\n/// }\n///\n/// struct Foo;\n///\n/// // Implements the `#[vtable]` trait\n/// #[vtable]\n/// impl Operations for Foo {\n///     fn foo(&self) -> Result<()> {\n/// #        Err(EINVAL)\n///         // ...\n///     }\n/// }\n///\n/// assert_eq!(<Foo as Operations>::HAS_FOO, true);\n/// assert_eq!(<Foo as Operations>::HAS_BAR, false);\n/// ```\n#[proc_macro_attribute]\npub fn vtable(attr: TokenStream, ts: TokenStream) -> TokenStream {\n    vtable::vtable(attr, ts)\n}\n\n/// Concatenate two identifiers.\n///\n/// This is useful in macros that need to declare or reference items with names\n/// starting with a fixed prefix and ending in a user specified name. The resulting\n/// identifier has the span of the second argument.\n///\n/// # Examples\n///\n/// ```ignore\n/// use kernel::macro::concat_idents;\n///\n/// macro_rules! pub_no_prefix {\n///     ($prefix:ident, $($newname:ident),+) => {\n///         $(pub(crate) const $newname: u32 = kernel::macros::concat_idents!($prefix, $newname);)+\n///     };\n/// }\n///\n/// pub_no_prefix!(\n///     binder_driver_return_protocol_,\n///     BR_OK,\n///     BR_ERROR,\n///     BR_TRANSACTION,\n///     BR_REPLY,\n///     BR_DEAD_REPLY,\n///     BR_TRANSACTION_COMPLETE,\n///     BR_INCREFS,\n///     BR_ACQUIRE,\n///     BR_RELEASE,\n///     BR_DECREFS,\n///     BR_NOOP,\n///     BR_SPAWN_LOOPER,\n///     BR_DEAD_BINDER,\n///     BR_CLEAR_DEATH_NOTIFICATION_DONE,\n///     BR_FAILED_REPLY\n/// );\n///\n/// assert_eq!(BR_OK, binder_driver_return_protocol_BR_OK);\n/// ```\n#[proc_macro]\npub fn concat_idents(ts: TokenStream) -> TokenStream {\n    concat_idents::concat_idents(ts)\n}\n\n/// Used to specify the pinning information of the fields of a struct.\n///\n/// This is somewhat similar in purpose as\n/// [pin-project-lite](https://crates.io/crates/pin-project-lite).\n/// Place this macro on a struct definition and then `#[pin]` in front of the attributes of each\n/// field you want to structurally pin.\n///\n/// This macro enables the use of the [`pin_init!`] macro. When pin-initializing a `struct`,\n/// then `#[pin]` directs the type of initializer that is required.\n///\n/// If your `struct` implements `Drop`, then you need to add `PinnedDrop` as arguments to this\n/// macro, and change your `Drop` implementation to `PinnedDrop` annotated with\n/// `#[`[`macro@pinned_drop`]`]`, since dropping pinned values requires extra care.\n///\n/// # Examples\n///\n/// ```rust,ignore\n/// #[pin_data]\n/// struct DriverData {\n///     #[pin]\n///     queue: Mutex<Vec<Command>>,\n///     buf: Box<[u8; 1024 * 1024]>,\n/// }\n/// ```\n///\n/// ```rust,ignore\n/// #[pin_data(PinnedDrop)]\n/// struct DriverData {\n///     #[pin]\n///     queue: Mutex<Vec<Command>>,\n///     buf: Box<[u8; 1024 * 1024]>,\n///     raw_info: *mut Info,\n/// }\n///\n/// #[pinned_drop]\n/// impl PinnedDrop for DriverData {\n///     fn drop(self: Pin<&mut Self>) {\n///         unsafe { bindings::destroy_info(self.raw_info) };\n///     }\n/// }\n/// ```\n///\n/// [`pin_init!`]: ../kernel/macro.pin_init.html\n//  ^ cannot use direct link, since `kernel` is not a dependency of `macros`.\n#[proc_macro_attribute]\npub fn pin_data(inner: TokenStream, item: TokenStream) -> TokenStream {\n    pin_data::pin_data(inner, item)\n}\n\n/// Used to implement `PinnedDrop` safely.\n///\n/// Only works on structs that are annotated via `#[`[`macro@pin_data`]`]`.\n///\n/// # Examples\n///\n/// ```rust,ignore\n/// #[pin_data(PinnedDrop)]\n/// struct DriverData {\n///     #[pin]\n///     queue: Mutex<Vec<Command>>,\n///     buf: Box<[u8; 1024 * 1024]>,\n///     raw_info: *mut Info,\n/// }\n///\n/// #[pinned_drop]\n/// impl PinnedDrop for DriverData {\n///     fn drop(self: Pin<&mut Self>) {\n///         unsafe { bindings::destroy_info(self.raw_info) };\n///     }\n/// }\n/// ```\n#[proc_macro_attribute]\npub fn pinned_drop(args: TokenStream, input: TokenStream) -> TokenStream {\n    pinned_drop::pinned_drop(args, input)\n}\n\n/// Paste identifiers together.\n///\n/// Within the `paste!` macro, identifiers inside `[<` and `>]` are concatenated together to form a\n/// single identifier.\n///\n/// This is similar to the [`paste`] crate, but with pasting feature limited to identifiers\n/// (literals, lifetimes and documentation strings are not supported). There is a difference in\n/// supported modifiers as well.\n///\n/// # Example\n///\n/// ```ignore\n/// use kernel::macro::paste;\n///\n/// macro_rules! pub_no_prefix {\n///     ($prefix:ident, $($newname:ident),+) => {\n///         paste! {\n///             $(pub(crate) const $newname: u32 = [<$prefix $newname>];)+\n///         }\n///     };\n/// }\n///\n/// pub_no_prefix!(\n///     binder_driver_return_protocol_,\n///     BR_OK,\n///     BR_ERROR,\n///     BR_TRANSACTION,\n///     BR_REPLY,\n///     BR_DEAD_REPLY,\n///     BR_TRANSACTION_COMPLETE,\n///     BR_INCREFS,\n///     BR_ACQUIRE,\n///     BR_RELEASE,\n///     BR_DECREFS,\n///     BR_NOOP,\n///     BR_SPAWN_LOOPER,\n///     BR_DEAD_BINDER,\n///     BR_CLEAR_DEATH_NOTIFICATION_DONE,\n///     BR_FAILED_REPLY\n/// );\n///\n/// assert_eq!(BR_OK, binder_driver_return_protocol_BR_OK);\n/// ```\n///\n/// # Modifiers\n///\n/// For each identifier, it is possible to attach one or multiple modifiers to\n/// it.\n///\n/// Currently supported modifiers are:\n/// * `span`: change the span of concatenated identifier to the span of the specified token. By\n/// default the span of the `[< >]` group is used.\n/// * `lower`: change the identifier to lower case.\n/// * `upper`: change the identifier to upper case.\n///\n/// ```ignore\n/// use kernel::macro::paste;\n///\n/// macro_rules! pub_no_prefix {\n///     ($prefix:ident, $($newname:ident),+) => {\n///         kernel::macros::paste! {\n///             $(pub(crate) const fn [<$newname:lower:span>]: u32 = [<$prefix $newname:span>];)+\n///         }\n///     };\n/// }\n///\n/// pub_no_prefix!(\n///     binder_driver_return_protocol_,\n///     BR_OK,\n///     BR_ERROR,\n///     BR_TRANSACTION,\n///     BR_REPLY,\n///     BR_DEAD_REPLY,\n///     BR_TRANSACTION_COMPLETE,\n///     BR_INCREFS,\n///     BR_ACQUIRE,\n///     BR_RELEASE,\n///     BR_DECREFS,\n///     BR_NOOP,\n///     BR_SPAWN_LOOPER,\n///     BR_DEAD_BINDER,\n///     BR_CLEAR_DEATH_NOTIFICATION_DONE,\n///     BR_FAILED_REPLY\n/// );\n///\n/// assert_eq!(br_ok(), binder_driver_return_protocol_BR_OK);\n/// ```\n///\n/// [`paste`]: https://docs.rs/paste/\n#[proc_macro]\npub fn paste(input: TokenStream) -> TokenStream {\n    let mut tokens = input.into_iter().collect();\n    paste::expand(&mut tokens);\n    tokens.into_iter().collect()\n}\n\n/// Derives the [`Zeroable`] trait for the given struct.\n///\n/// This can only be used for structs where every field implements the [`Zeroable`] trait.\n///\n/// # Examples\n///\n/// ```rust,ignore\n/// #[derive(Zeroable)]\n/// pub struct DriverData {\n///     id: i64,\n///     buf_ptr: *mut u8,\n///     len: usize,\n/// }\n/// ```\n#[proc_macro_derive(Zeroable)]\npub fn derive_zeroable(input: TokenStream) -> TokenStream {\n    zeroable::derive(input)\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}