{
  "module_name": "pinned_drop.rs",
  "hash_id": "0621650044f5f074db851af0efe3719f00200c4824b8f417158bbb5f73fc1636",
  "original_prompt": "Ingested from linux-6.6.14/rust/macros/pinned_drop.rs",
  "human_readable_source": "// SPDX-License-Identifier: Apache-2.0 OR MIT\n\nuse proc_macro::{TokenStream, TokenTree};\n\npub(crate) fn pinned_drop(_args: TokenStream, input: TokenStream) -> TokenStream {\n    let mut toks = input.into_iter().collect::<Vec<_>>();\n    assert!(!toks.is_empty());\n    // Ensure that we have an `impl` item.\n    assert!(matches!(&toks[0], TokenTree::Ident(i) if i.to_string() == \"impl\"));\n    // Ensure that we are implementing `PinnedDrop`.\n    let mut nesting: usize = 0;\n    let mut pinned_drop_idx = None;\n    for (i, tt) in toks.iter().enumerate() {\n        match tt {\n            TokenTree::Punct(p) if p.as_char() == '<' => {\n                nesting += 1;\n            }\n            TokenTree::Punct(p) if p.as_char() == '>' => {\n                nesting = nesting.checked_sub(1).unwrap();\n                continue;\n            }\n            _ => {}\n        }\n        if i >= 1 && nesting == 0 {\n            // Found the end of the generics, this should be `PinnedDrop`.\n            assert!(\n                matches!(tt, TokenTree::Ident(i) if i.to_string() == \"PinnedDrop\"),\n                \"expected 'PinnedDrop', found: '{:?}'\",\n                tt\n            );\n            pinned_drop_idx = Some(i);\n            break;\n        }\n    }\n    let idx = pinned_drop_idx\n        .unwrap_or_else(|| panic!(\"Expected an `impl` block implementing `PinnedDrop`.\"));\n    // Fully qualify the `PinnedDrop`, as to avoid any tampering.\n    toks.splice(idx..idx, quote!(::kernel::init::));\n    // Take the `{}` body and call the declarative macro.\n    if let Some(TokenTree::Group(last)) = toks.pop() {\n        let last = last.stream();\n        quote!(::kernel::__pinned_drop! {\n            @impl_sig(#(#toks)*),\n            @impl_body(#last),\n        })\n    } else {\n        TokenStream::from_iter(toks)\n    }\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}