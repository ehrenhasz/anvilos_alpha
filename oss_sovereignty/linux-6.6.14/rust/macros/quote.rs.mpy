{
  "module_name": "quote.rs",
  "hash_id": "40059366920801fae0a7ecc981751403c9fa140ce88f31f14294267517025b8f",
  "original_prompt": "Ingested from linux-6.6.14/rust/macros/quote.rs",
  "human_readable_source": "// SPDX-License-Identifier: Apache-2.0 OR MIT\n\nuse proc_macro::{TokenStream, TokenTree};\n\npub(crate) trait ToTokens {\n    fn to_tokens(&self, tokens: &mut TokenStream);\n}\n\nimpl<T: ToTokens> ToTokens for Option<T> {\n    fn to_tokens(&self, tokens: &mut TokenStream) {\n        if let Some(v) = self {\n            v.to_tokens(tokens);\n        }\n    }\n}\n\nimpl ToTokens for proc_macro::Group {\n    fn to_tokens(&self, tokens: &mut TokenStream) {\n        tokens.extend([TokenTree::from(self.clone())]);\n    }\n}\n\nimpl ToTokens for TokenTree {\n    fn to_tokens(&self, tokens: &mut TokenStream) {\n        tokens.extend([self.clone()]);\n    }\n}\n\nimpl ToTokens for TokenStream {\n    fn to_tokens(&self, tokens: &mut TokenStream) {\n        tokens.extend(self.clone());\n    }\n}\n\n/// Converts tokens into [`proc_macro::TokenStream`] and performs variable interpolations with\n/// the given span.\n///\n/// This is a similar to the\n/// [`quote_spanned!`](https://docs.rs/quote/latest/quote/macro.quote_spanned.html) macro from the\n/// `quote` crate but provides only just enough functionality needed by the current `macros` crate.\nmacro_rules! quote_spanned {\n    ($span:expr => $($tt:tt)*) => {{\n        let mut tokens;\n        #[allow(clippy::vec_init_then_push)]\n        {\n            tokens = ::std::vec::Vec::new();\n            let span = $span;\n            quote_spanned!(@proc tokens span $($tt)*);\n        }\n        ::proc_macro::TokenStream::from_iter(tokens)\n    }};\n    (@proc $v:ident $span:ident) => {};\n    (@proc $v:ident $span:ident #$id:ident $($tt:tt)*) => {\n        let mut ts = ::proc_macro::TokenStream::new();\n        $crate::quote::ToTokens::to_tokens(&$id, &mut ts);\n        $v.extend(ts);\n        quote_spanned!(@proc $v $span $($tt)*);\n    };\n    (@proc $v:ident $span:ident #(#$id:ident)* $($tt:tt)*) => {\n        for token in $id {\n            let mut ts = ::proc_macro::TokenStream::new();\n            $crate::quote::ToTokens::to_tokens(&token, &mut ts);\n            $v.extend(ts);\n        }\n        quote_spanned!(@proc $v $span $($tt)*);\n    };\n    (@proc $v:ident $span:ident ( $($inner:tt)* ) $($tt:tt)*) => {\n        let mut tokens = ::std::vec::Vec::new();\n        quote_spanned!(@proc tokens $span $($inner)*);\n        $v.push(::proc_macro::TokenTree::Group(::proc_macro::Group::new(\n            ::proc_macro::Delimiter::Parenthesis,\n            ::proc_macro::TokenStream::from_iter(tokens)\n        )));\n        quote_spanned!(@proc $v $span $($tt)*);\n    };\n    (@proc $v:ident $span:ident [ $($inner:tt)* ] $($tt:tt)*) => {\n        let mut tokens = ::std::vec::Vec::new();\n        quote_spanned!(@proc tokens $span $($inner)*);\n        $v.push(::proc_macro::TokenTree::Group(::proc_macro::Group::new(\n            ::proc_macro::Delimiter::Bracket,\n            ::proc_macro::TokenStream::from_iter(tokens)\n        )));\n        quote_spanned!(@proc $v $span $($tt)*);\n    };\n    (@proc $v:ident $span:ident { $($inner:tt)* } $($tt:tt)*) => {\n        let mut tokens = ::std::vec::Vec::new();\n        quote_spanned!(@proc tokens $span $($inner)*);\n        $v.push(::proc_macro::TokenTree::Group(::proc_macro::Group::new(\n            ::proc_macro::Delimiter::Brace,\n            ::proc_macro::TokenStream::from_iter(tokens)\n        )));\n        quote_spanned!(@proc $v $span $($tt)*);\n    };\n    (@proc $v:ident $span:ident :: $($tt:tt)*) => {\n        $v.push(::proc_macro::TokenTree::Punct(\n                ::proc_macro::Punct::new(':', ::proc_macro::Spacing::Joint)\n        ));\n        $v.push(::proc_macro::TokenTree::Punct(\n                ::proc_macro::Punct::new(':', ::proc_macro::Spacing::Alone)\n        ));\n        quote_spanned!(@proc $v $span $($tt)*);\n    };\n    (@proc $v:ident $span:ident : $($tt:tt)*) => {\n        $v.push(::proc_macro::TokenTree::Punct(\n                ::proc_macro::Punct::new(':', ::proc_macro::Spacing::Alone)\n        ));\n        quote_spanned!(@proc $v $span $($tt)*);\n    };\n    (@proc $v:ident $span:ident , $($tt:tt)*) => {\n        $v.push(::proc_macro::TokenTree::Punct(\n                ::proc_macro::Punct::new(',', ::proc_macro::Spacing::Alone)\n        ));\n        quote_spanned!(@proc $v $span $($tt)*);\n    };\n    (@proc $v:ident $span:ident @ $($tt:tt)*) => {\n        $v.push(::proc_macro::TokenTree::Punct(\n                ::proc_macro::Punct::new('@', ::proc_macro::Spacing::Alone)\n        ));\n        quote_spanned!(@proc $v $span $($tt)*);\n    };\n    (@proc $v:ident $span:ident ! $($tt:tt)*) => {\n        $v.push(::proc_macro::TokenTree::Punct(\n                ::proc_macro::Punct::new('!', ::proc_macro::Spacing::Alone)\n        ));\n        quote_spanned!(@proc $v $span $($tt)*);\n    };\n    (@proc $v:ident $span:ident ; $($tt:tt)*) => {\n        $v.push(::proc_macro::TokenTree::Punct(\n                ::proc_macro::Punct::new(';', ::proc_macro::Spacing::Alone)\n        ));\n        quote_spanned!(@proc $v $span $($tt)*);\n    };\n    (@proc $v:ident $span:ident + $($tt:tt)*) => {\n        $v.push(::proc_macro::TokenTree::Punct(\n                ::proc_macro::Punct::new('+', ::proc_macro::Spacing::Alone)\n        ));\n        quote_spanned!(@proc $v $span $($tt)*);\n    };\n    (@proc $v:ident $span:ident $id:ident $($tt:tt)*) => {\n        $v.push(::proc_macro::TokenTree::Ident(::proc_macro::Ident::new(stringify!($id), $span)));\n        quote_spanned!(@proc $v $span $($tt)*);\n    };\n}\n\n/// Converts tokens into [`proc_macro::TokenStream`] and performs variable interpolations with\n/// mixed site span ([`Span::mixed_site()`]).\n///\n/// This is a similar to the [`quote!`](https://docs.rs/quote/latest/quote/macro.quote.html) macro\n/// from the `quote` crate but provides only just enough functionality needed by the current\n/// `macros` crate.\n///\n/// [`Span::mixed_site()`]: https://doc.rust-lang.org/proc_macro/struct.Span.html#method.mixed_site\nmacro_rules! quote {\n    ($($tt:tt)*) => {\n        quote_spanned!(::proc_macro::Span::mixed_site() => $($tt)*)\n    }\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}