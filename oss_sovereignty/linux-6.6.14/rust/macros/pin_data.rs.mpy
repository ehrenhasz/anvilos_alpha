{
  "module_name": "pin_data.rs",
  "hash_id": "dda02d8c8d93ef8defc4b04e28d13080f68680c9300b2f72e06760f6e172190d",
  "original_prompt": "Ingested from linux-6.6.14/rust/macros/pin_data.rs",
  "human_readable_source": "// SPDX-License-Identifier: Apache-2.0 OR MIT\n\nuse crate::helpers::{parse_generics, Generics};\nuse proc_macro::{Group, Punct, Spacing, TokenStream, TokenTree};\n\npub(crate) fn pin_data(args: TokenStream, input: TokenStream) -> TokenStream {\n    // This proc-macro only does some pre-parsing and then delegates the actual parsing to\n    // `kernel::__pin_data!`.\n\n    let (\n        Generics {\n            impl_generics,\n            ty_generics,\n        },\n        rest,\n    ) = parse_generics(input);\n    // The struct definition might contain the `Self` type. Since `__pin_data!` will define a new\n    // type with the same generics and bounds, this poses a problem, since `Self` will refer to the\n    // new type as opposed to this struct definition. Therefore we have to replace `Self` with the\n    // concrete name.\n\n    // Errors that occur when replacing `Self` with `struct_name`.\n    let mut errs = TokenStream::new();\n    // The name of the struct with ty_generics.\n    let struct_name = rest\n        .iter()\n        .skip_while(|tt| !matches!(tt, TokenTree::Ident(i) if i.to_string() == \"struct\"))\n        .nth(1)\n        .and_then(|tt| match tt {\n            TokenTree::Ident(_) => {\n                let tt = tt.clone();\n                let mut res = vec![tt];\n                if !ty_generics.is_empty() {\n                    // We add this, so it is maximally compatible with e.g. `Self::CONST` which\n                    // will be replaced by `StructName::<$generics>::CONST`.\n                    res.push(TokenTree::Punct(Punct::new(':', Spacing::Joint)));\n                    res.push(TokenTree::Punct(Punct::new(':', Spacing::Alone)));\n                    res.push(TokenTree::Punct(Punct::new('<', Spacing::Alone)));\n                    res.extend(ty_generics.iter().cloned());\n                    res.push(TokenTree::Punct(Punct::new('>', Spacing::Alone)));\n                }\n                Some(res)\n            }\n            _ => None,\n        })\n        .unwrap_or_else(|| {\n            // If we did not find the name of the struct then we will use `Self` as the replacement\n            // and add a compile error to ensure it does not compile.\n            errs.extend(\n                \"::core::compile_error!(\\\"Could not locate type name.\\\");\"\n                    .parse::<TokenStream>()\n                    .unwrap(),\n            );\n            \"Self\".parse::<TokenStream>().unwrap().into_iter().collect()\n        });\n    let impl_generics = impl_generics\n        .into_iter()\n        .flat_map(|tt| replace_self_and_deny_type_defs(&struct_name, tt, &mut errs))\n        .collect::<Vec<_>>();\n    let mut rest = rest\n        .into_iter()\n        .flat_map(|tt| {\n            // We ignore top level `struct` tokens, since they would emit a compile error.\n            if matches!(&tt, TokenTree::Ident(i) if i.to_string() == \"struct\") {\n                vec![tt]\n            } else {\n                replace_self_and_deny_type_defs(&struct_name, tt, &mut errs)\n            }\n        })\n        .collect::<Vec<_>>();\n    // This should be the body of the struct `{...}`.\n    let last = rest.pop();\n    let mut quoted = quote!(::kernel::__pin_data! {\n        parse_input:\n        @args(#args),\n        @sig(#(#rest)*),\n        @impl_generics(#(#impl_generics)*),\n        @ty_generics(#(#ty_generics)*),\n        @body(#last),\n    });\n    quoted.extend(errs);\n    quoted\n}\n\n/// Replaces `Self` with `struct_name` and errors on `enum`, `trait`, `struct` `union` and `impl`\n/// keywords.\n///\n/// The error is appended to `errs` to allow normal parsing to continue.\nfn replace_self_and_deny_type_defs(\n    struct_name: &Vec<TokenTree>,\n    tt: TokenTree,\n    errs: &mut TokenStream,\n) -> Vec<TokenTree> {\n    match tt {\n        TokenTree::Ident(ref i)\n            if i.to_string() == \"enum\"\n                || i.to_string() == \"trait\"\n                || i.to_string() == \"struct\"\n                || i.to_string() == \"union\"\n                || i.to_string() == \"impl\" =>\n        {\n            errs.extend(\n                format!(\n                    \"::core::compile_error!(\\\"Cannot use `{i}` inside of struct definition with \\\n                        `#[pin_data]`.\\\");\"\n                )\n                .parse::<TokenStream>()\n                .unwrap()\n                .into_iter()\n                .map(|mut tok| {\n                    tok.set_span(tt.span());\n                    tok\n                }),\n            );\n            vec![tt]\n        }\n        TokenTree::Ident(i) if i.to_string() == \"Self\" => struct_name.clone(),\n        TokenTree::Literal(_) | TokenTree::Punct(_) | TokenTree::Ident(_) => vec![tt],\n        TokenTree::Group(g) => vec![TokenTree::Group(Group::new(\n            g.delimiter(),\n            g.stream()\n                .into_iter()\n                .flat_map(|tt| replace_self_and_deny_type_defs(struct_name, tt, errs))\n                .collect(),\n        ))],\n    }\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}