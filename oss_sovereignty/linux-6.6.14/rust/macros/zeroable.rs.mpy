{
  "module_name": "zeroable.rs",
  "hash_id": "837ae71a8da1f99ec5ed81292422aac6bf06b8f0ebcad19a0a0945ecdce06c31",
  "original_prompt": "Ingested from linux-6.6.14/rust/macros/zeroable.rs",
  "human_readable_source": "// SPDX-License-Identifier: GPL-2.0\n\nuse crate::helpers::{parse_generics, Generics};\nuse proc_macro::{TokenStream, TokenTree};\n\npub(crate) fn derive(input: TokenStream) -> TokenStream {\n    let (\n        Generics {\n            impl_generics,\n            ty_generics,\n        },\n        mut rest,\n    ) = parse_generics(input);\n    // This should be the body of the struct `{...}`.\n    let last = rest.pop();\n    // Now we insert `Zeroable` as a bound for every generic parameter in `impl_generics`.\n    let mut new_impl_generics = Vec::with_capacity(impl_generics.len());\n    // Are we inside of a generic where we want to add `Zeroable`?\n    let mut in_generic = !impl_generics.is_empty();\n    // Have we already inserted `Zeroable`?\n    let mut inserted = false;\n    // Level of `<>` nestings.\n    let mut nested = 0;\n    for tt in impl_generics {\n        match &tt {\n            // If we find a `,`, then we have finished a generic/constant/lifetime parameter.\n            TokenTree::Punct(p) if nested == 0 && p.as_char() == ',' => {\n                if in_generic && !inserted {\n                    new_impl_generics.extend(quote! { : ::kernel::init::Zeroable });\n                }\n                in_generic = true;\n                inserted = false;\n                new_impl_generics.push(tt);\n            }\n            // If we find `'`, then we are entering a lifetime.\n            TokenTree::Punct(p) if nested == 0 && p.as_char() == '\\'' => {\n                in_generic = false;\n                new_impl_generics.push(tt);\n            }\n            TokenTree::Punct(p) if nested == 0 && p.as_char() == ':' => {\n                new_impl_generics.push(tt);\n                if in_generic {\n                    new_impl_generics.extend(quote! { ::kernel::init::Zeroable + });\n                    inserted = true;\n                }\n            }\n            TokenTree::Punct(p) if p.as_char() == '<' => {\n                nested += 1;\n                new_impl_generics.push(tt);\n            }\n            TokenTree::Punct(p) if p.as_char() == '>' => {\n                assert!(nested > 0);\n                nested -= 1;\n                new_impl_generics.push(tt);\n            }\n            _ => new_impl_generics.push(tt),\n        }\n    }\n    assert_eq!(nested, 0);\n    if in_generic && !inserted {\n        new_impl_generics.extend(quote! { : ::kernel::init::Zeroable });\n    }\n    quote! {\n        ::kernel::__derive_zeroable!(\n            parse_input:\n                @sig(#(#rest)*),\n                @impl_generics(#(#new_impl_generics)*),\n                @ty_generics(#(#ty_generics)*),\n                @body(#last),\n        );\n    }\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}