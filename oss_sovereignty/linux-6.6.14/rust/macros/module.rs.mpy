{
  "module_name": "module.rs",
  "hash_id": "035884bbfbfe103822a2de10ed7813ff24f0584a0dc60b5ce5550cafbb64a88e",
  "original_prompt": "Ingested from linux-6.6.14/rust/macros/module.rs",
  "human_readable_source": "// SPDX-License-Identifier: GPL-2.0\n\nuse crate::helpers::*;\nuse proc_macro::{token_stream, Delimiter, Literal, TokenStream, TokenTree};\nuse std::fmt::Write;\n\nfn expect_string_array(it: &mut token_stream::IntoIter) -> Vec<String> {\n    let group = expect_group(it);\n    assert_eq!(group.delimiter(), Delimiter::Bracket);\n    let mut values = Vec::new();\n    let mut it = group.stream().into_iter();\n\n    while let Some(val) = try_string(&mut it) {\n        assert!(val.is_ascii(), \"Expected ASCII string\");\n        values.push(val);\n        match it.next() {\n            Some(TokenTree::Punct(punct)) => assert_eq!(punct.as_char(), ','),\n            None => break,\n            _ => panic!(\"Expected ',' or end of array\"),\n        }\n    }\n    values\n}\n\nstruct ModInfoBuilder<'a> {\n    module: &'a str,\n    counter: usize,\n    buffer: String,\n}\n\nimpl<'a> ModInfoBuilder<'a> {\n    fn new(module: &'a str) -> Self {\n        ModInfoBuilder {\n            module,\n            counter: 0,\n            buffer: String::new(),\n        }\n    }\n\n    fn emit_base(&mut self, field: &str, content: &str, builtin: bool) {\n        let string = if builtin {\n            // Built-in modules prefix their modinfo strings by `module.`.\n            format!(\n                \"{module}.{field}={content}\\0\",\n                module = self.module,\n                field = field,\n                content = content\n            )\n        } else {\n            // Loadable modules' modinfo strings go as-is.\n            format!(\"{field}={content}\\0\", field = field, content = content)\n        };\n\n        write!(\n            &mut self.buffer,\n            \"\n                {cfg}\n                #[doc(hidden)]\n                #[link_section = \\\".modinfo\\\"]\n                #[used]\n                pub static __{module}_{counter}: [u8; {length}] = *{string};\n            \",\n            cfg = if builtin {\n                \"#[cfg(not(MODULE))]\"\n            } else {\n                \"#[cfg(MODULE)]\"\n            },\n            module = self.module.to_uppercase(),\n            counter = self.counter,\n            length = string.len(),\n            string = Literal::byte_string(string.as_bytes()),\n        )\n        .unwrap();\n\n        self.counter += 1;\n    }\n\n    fn emit_only_builtin(&mut self, field: &str, content: &str) {\n        self.emit_base(field, content, true)\n    }\n\n    fn emit_only_loadable(&mut self, field: &str, content: &str) {\n        self.emit_base(field, content, false)\n    }\n\n    fn emit(&mut self, field: &str, content: &str) {\n        self.emit_only_builtin(field, content);\n        self.emit_only_loadable(field, content);\n    }\n}\n\n#[derive(Debug, Default)]\nstruct ModuleInfo {\n    type_: String,\n    license: String,\n    name: String,\n    author: Option<String>,\n    description: Option<String>,\n    alias: Option<Vec<String>>,\n}\n\nimpl ModuleInfo {\n    fn parse(it: &mut token_stream::IntoIter) -> Self {\n        let mut info = ModuleInfo::default();\n\n        const EXPECTED_KEYS: &[&str] =\n            &[\"type\", \"name\", \"author\", \"description\", \"license\", \"alias\"];\n        const REQUIRED_KEYS: &[&str] = &[\"type\", \"name\", \"license\"];\n        let mut seen_keys = Vec::new();\n\n        loop {\n            let key = match it.next() {\n                Some(TokenTree::Ident(ident)) => ident.to_string(),\n                Some(_) => panic!(\"Expected Ident or end\"),\n                None => break,\n            };\n\n            if seen_keys.contains(&key) {\n                panic!(\n                    \"Duplicated key \\\"{}\\\". Keys can only be specified once.\",\n                    key\n                );\n            }\n\n            assert_eq!(expect_punct(it), ':');\n\n            match key.as_str() {\n                \"type\" => info.type_ = expect_ident(it),\n                \"name\" => info.name = expect_string_ascii(it),\n                \"author\" => info.author = Some(expect_string(it)),\n                \"description\" => info.description = Some(expect_string(it)),\n                \"license\" => info.license = expect_string_ascii(it),\n                \"alias\" => info.alias = Some(expect_string_array(it)),\n                _ => panic!(\n                    \"Unknown key \\\"{}\\\". Valid keys are: {:?}.\",\n                    key, EXPECTED_KEYS\n                ),\n            }\n\n            assert_eq!(expect_punct(it), ',');\n\n            seen_keys.push(key);\n        }\n\n        expect_end(it);\n\n        for key in REQUIRED_KEYS {\n            if !seen_keys.iter().any(|e| e == key) {\n                panic!(\"Missing required key \\\"{}\\\".\", key);\n            }\n        }\n\n        let mut ordered_keys: Vec<&str> = Vec::new();\n        for key in EXPECTED_KEYS {\n            if seen_keys.iter().any(|e| e == key) {\n                ordered_keys.push(key);\n            }\n        }\n\n        if seen_keys != ordered_keys {\n            panic!(\n                \"Keys are not ordered as expected. Order them like: {:?}.\",\n                ordered_keys\n            );\n        }\n\n        info\n    }\n}\n\npub(crate) fn module(ts: TokenStream) -> TokenStream {\n    let mut it = ts.into_iter();\n\n    let info = ModuleInfo::parse(&mut it);\n\n    let mut modinfo = ModInfoBuilder::new(info.name.as_ref());\n    if let Some(author) = info.author {\n        modinfo.emit(\"author\", &author);\n    }\n    if let Some(description) = info.description {\n        modinfo.emit(\"description\", &description);\n    }\n    modinfo.emit(\"license\", &info.license);\n    if let Some(aliases) = info.alias {\n        for alias in aliases {\n            modinfo.emit(\"alias\", &alias);\n        }\n    }\n\n    // Built-in modules also export the `file` modinfo string.\n    let file =\n        std::env::var(\"RUST_MODFILE\").expect(\"Unable to fetch RUST_MODFILE environmental variable\");\n    modinfo.emit_only_builtin(\"file\", &file);\n\n    format!(\n        \"\n            /// The module name.\n            ///\n            /// Used by the printing macros, e.g. [`info!`].\n            const __LOG_PREFIX: &[u8] = b\\\"{name}\\\\0\\\";\n\n            /// The \\\"Rust loadable module\\\" mark.\n            //\n            // This may be best done another way later on, e.g. as a new modinfo\n            // key or a new section. For the moment, keep it simple.\n            #[cfg(MODULE)]\n            #[doc(hidden)]\n            #[used]\n            static __IS_RUST_MODULE: () = ();\n\n            static mut __MOD: Option<{type_}> = None;\n\n            // SAFETY: `__this_module` is constructed by the kernel at load time and will not be\n            // freed until the module is unloaded.\n            #[cfg(MODULE)]\n            static THIS_MODULE: kernel::ThisModule = unsafe {{\n                kernel::ThisModule::from_ptr(&kernel::bindings::__this_module as *const _ as *mut _)\n            }};\n            #[cfg(not(MODULE))]\n            static THIS_MODULE: kernel::ThisModule = unsafe {{\n                kernel::ThisModule::from_ptr(core::ptr::null_mut())\n            }};\n\n            // Loadable modules need to export the `{{init,cleanup}}_module` identifiers.\n            #[cfg(MODULE)]\n            #[doc(hidden)]\n            #[no_mangle]\n            pub extern \\\"C\\\" fn init_module() -> core::ffi::c_int {{\n                __init()\n            }}\n\n            #[cfg(MODULE)]\n            #[doc(hidden)]\n            #[no_mangle]\n            pub extern \\\"C\\\" fn cleanup_module() {{\n                __exit()\n            }}\n\n            // Built-in modules are initialized through an initcall pointer\n            // and the identifiers need to be unique.\n            #[cfg(not(MODULE))]\n            #[cfg(not(CONFIG_HAVE_ARCH_PREL32_RELOCATIONS))]\n            #[doc(hidden)]\n            #[link_section = \\\"{initcall_section}\\\"]\n            #[used]\n            pub static __{name}_initcall: extern \\\"C\\\" fn() -> core::ffi::c_int = __{name}_init;\n\n            #[cfg(not(MODULE))]\n            #[cfg(CONFIG_HAVE_ARCH_PREL32_RELOCATIONS)]\n            core::arch::global_asm!(\n                r#\\\".section \\\"{initcall_section}\\\", \\\"a\\\"\n                __{name}_initcall:\n                    .long   __{name}_init - .\n                    .previous\n                \\\"#\n            );\n\n            #[cfg(not(MODULE))]\n            #[doc(hidden)]\n            #[no_mangle]\n            pub extern \\\"C\\\" fn __{name}_init() -> core::ffi::c_int {{\n                __init()\n            }}\n\n            #[cfg(not(MODULE))]\n            #[doc(hidden)]\n            #[no_mangle]\n            pub extern \\\"C\\\" fn __{name}_exit() {{\n                __exit()\n            }}\n\n            fn __init() -> core::ffi::c_int {{\n                match <{type_} as kernel::Module>::init(&THIS_MODULE) {{\n                    Ok(m) => {{\n                        unsafe {{\n                            __MOD = Some(m);\n                        }}\n                        return 0;\n                    }}\n                    Err(e) => {{\n                        return e.to_errno();\n                    }}\n                }}\n            }}\n\n            fn __exit() {{\n                unsafe {{\n                    // Invokes `drop()` on `__MOD`, which should be used for cleanup.\n                    __MOD = None;\n                }}\n            }}\n\n            {modinfo}\n        \",\n        type_ = info.type_,\n        name = info.name,\n        modinfo = modinfo.buffer,\n        initcall_section = \".initcall6.init\"\n    )\n    .parse()\n    .expect(\"Error parsing formatted string into token stream.\")\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}