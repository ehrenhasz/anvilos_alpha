{
  "module_name": "mod.rs",
  "hash_id": "3a31b4dd0fe0a9a4db61c83549bb159335eaddde7ec52f72b9897def0ccfff52",
  "original_prompt": "Ingested from linux-6.6.14/rust/alloc/collections/mod.rs",
  "human_readable_source": "// SPDX-License-Identifier: Apache-2.0 OR MIT\n\n//! Collection types.\n\n#![stable(feature = \"rust1\", since = \"1.0.0\")]\n\n#[cfg(not(no_global_oom_handling))]\npub mod binary_heap;\n#[cfg(not(no_global_oom_handling))]\nmod btree;\n#[cfg(not(no_global_oom_handling))]\npub mod linked_list;\n#[cfg(not(no_global_oom_handling))]\npub mod vec_deque;\n\n#[cfg(not(no_global_oom_handling))]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub mod btree_map {\n    //! An ordered map based on a B-Tree.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub use super::btree::map::*;\n}\n\n#[cfg(not(no_global_oom_handling))]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub mod btree_set {\n    //! An ordered set based on a B-Tree.\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub use super::btree::set::*;\n}\n\n#[cfg(not(no_global_oom_handling))]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[doc(no_inline)]\npub use binary_heap::BinaryHeap;\n\n#[cfg(not(no_global_oom_handling))]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[doc(no_inline)]\npub use btree_map::BTreeMap;\n\n#[cfg(not(no_global_oom_handling))]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[doc(no_inline)]\npub use btree_set::BTreeSet;\n\n#[cfg(not(no_global_oom_handling))]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[doc(no_inline)]\npub use linked_list::LinkedList;\n\n#[cfg(not(no_global_oom_handling))]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[doc(no_inline)]\npub use vec_deque::VecDeque;\n\nuse crate::alloc::{Layout, LayoutError};\nuse core::fmt::Display;\n\n/// The error type for `try_reserve` methods.\n#[derive(Clone, PartialEq, Eq, Debug)]\n#[stable(feature = \"try_reserve\", since = \"1.57.0\")]\npub struct TryReserveError {\n    kind: TryReserveErrorKind,\n}\n\nimpl TryReserveError {\n    /// Details about the allocation that caused the error\n    #[inline]\n    #[must_use]\n    #[unstable(\n        feature = \"try_reserve_kind\",\n        reason = \"Uncertain how much info should be exposed\",\n        issue = \"48043\"\n    )]\n    pub fn kind(&self) -> TryReserveErrorKind {\n        self.kind.clone()\n    }\n}\n\n/// Details of the allocation that caused a `TryReserveError`\n#[derive(Clone, PartialEq, Eq, Debug)]\n#[unstable(\n    feature = \"try_reserve_kind\",\n    reason = \"Uncertain how much info should be exposed\",\n    issue = \"48043\"\n)]\npub enum TryReserveErrorKind {\n    /// Error due to the computed capacity exceeding the collection's maximum\n    /// (usually `isize::MAX` bytes).\n    CapacityOverflow,\n\n    /// The memory allocator returned an error\n    AllocError {\n        /// The layout of allocation request that failed\n        layout: Layout,\n\n        #[doc(hidden)]\n        #[unstable(\n            feature = \"container_error_extra\",\n            issue = \"none\",\n            reason = \"\\\n            Enable exposing the allocator\u2019s custom error value \\\n            if an associated type is added in the future: \\\n            https://github.com/rust-lang/wg-allocators/issues/23\"\n        )]\n        non_exhaustive: (),\n    },\n}\n\n#[unstable(\n    feature = \"try_reserve_kind\",\n    reason = \"Uncertain how much info should be exposed\",\n    issue = \"48043\"\n)]\nimpl From<TryReserveErrorKind> for TryReserveError {\n    #[inline]\n    fn from(kind: TryReserveErrorKind) -> Self {\n        Self { kind }\n    }\n}\n\n#[unstable(feature = \"try_reserve_kind\", reason = \"new API\", issue = \"48043\")]\nimpl From<LayoutError> for TryReserveErrorKind {\n    /// Always evaluates to [`TryReserveErrorKind::CapacityOverflow`].\n    #[inline]\n    fn from(_: LayoutError) -> Self {\n        TryReserveErrorKind::CapacityOverflow\n    }\n}\n\n#[stable(feature = \"try_reserve\", since = \"1.57.0\")]\nimpl Display for TryReserveError {\n    fn fmt(\n        &self,\n        fmt: &mut core::fmt::Formatter<'_>,\n    ) -> core::result::Result<(), core::fmt::Error> {\n        fmt.write_str(\"memory allocation failed\")?;\n        let reason = match self.kind {\n            TryReserveErrorKind::CapacityOverflow => {\n                \" because the computed capacity exceeded the collection's maximum\"\n            }\n            TryReserveErrorKind::AllocError { .. } => {\n                \" because the memory allocator returned an error\"\n            }\n        };\n        fmt.write_str(reason)\n    }\n}\n\n/// An intermediate trait for specialization of `Extend`.\n#[doc(hidden)]\ntrait SpecExtend<I: IntoIterator> {\n    /// Extends `self` with the contents of the given iterator.\n    fn spec_extend(&mut self, iter: I);\n}\n\n#[stable(feature = \"try_reserve\", since = \"1.57.0\")]\nimpl core::error::Error for TryReserveError {}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}