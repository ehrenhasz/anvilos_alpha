{
  "module_name": "is_zero.rs",
  "hash_id": "b518e1015832c670f986d00ea85699382ba28165d9c24f2230f931d0f286efd2",
  "original_prompt": "Ingested from linux-6.6.14/rust/alloc/vec/is_zero.rs",
  "human_readable_source": "// SPDX-License-Identifier: Apache-2.0 OR MIT\n\nuse core::num::{Saturating, Wrapping};\n\nuse crate::boxed::Box;\n\n#[rustc_specialization_trait]\npub(super) unsafe trait IsZero {\n    /// Whether this value's representation is all zeros,\n    /// or can be represented with all zeroes.\n    fn is_zero(&self) -> bool;\n}\n\nmacro_rules! impl_is_zero {\n    ($t:ty, $is_zero:expr) => {\n        unsafe impl IsZero for $t {\n            #[inline]\n            fn is_zero(&self) -> bool {\n                $is_zero(*self)\n            }\n        }\n    };\n}\n\nimpl_is_zero!(i8, |x| x == 0); // It is needed to impl for arrays and tuples of i8.\nimpl_is_zero!(i16, |x| x == 0);\nimpl_is_zero!(i32, |x| x == 0);\nimpl_is_zero!(i64, |x| x == 0);\nimpl_is_zero!(i128, |x| x == 0);\nimpl_is_zero!(isize, |x| x == 0);\n\nimpl_is_zero!(u8, |x| x == 0); // It is needed to impl for arrays and tuples of u8.\nimpl_is_zero!(u16, |x| x == 0);\nimpl_is_zero!(u32, |x| x == 0);\nimpl_is_zero!(u64, |x| x == 0);\nimpl_is_zero!(u128, |x| x == 0);\nimpl_is_zero!(usize, |x| x == 0);\n\nimpl_is_zero!(bool, |x| x == false);\nimpl_is_zero!(char, |x| x == '\\0');\n\nimpl_is_zero!(f32, |x: f32| x.to_bits() == 0);\nimpl_is_zero!(f64, |x: f64| x.to_bits() == 0);\n\nunsafe impl<T> IsZero for *const T {\n    #[inline]\n    fn is_zero(&self) -> bool {\n        (*self).is_null()\n    }\n}\n\nunsafe impl<T> IsZero for *mut T {\n    #[inline]\n    fn is_zero(&self) -> bool {\n        (*self).is_null()\n    }\n}\n\nunsafe impl<T: IsZero, const N: usize> IsZero for [T; N] {\n    #[inline]\n    fn is_zero(&self) -> bool {\n        // Because this is generated as a runtime check, it's not obvious that\n        // it's worth doing if the array is really long. The threshold here\n        // is largely arbitrary, but was picked because as of 2022-07-01 LLVM\n        // fails to const-fold the check in `vec![[1; 32]; n]`\n        // See https://github.com/rust-lang/rust/pull/97581#issuecomment-1166628022\n        // Feel free to tweak if you have better evidence.\n\n        N <= 16 && self.iter().all(IsZero::is_zero)\n    }\n}\n\n// This is recursive macro.\nmacro_rules! impl_for_tuples {\n    // Stopper\n    () => {\n        // No use for implementing for empty tuple because it is ZST.\n    };\n    ($first_arg:ident $(,$rest:ident)*) => {\n        unsafe impl <$first_arg: IsZero, $($rest: IsZero,)*> IsZero for ($first_arg, $($rest,)*){\n            #[inline]\n            fn is_zero(&self) -> bool{\n                // Destructure tuple to N references\n                // Rust allows to hide generic params by local variable names.\n                #[allow(non_snake_case)]\n                let ($first_arg, $($rest,)*) = self;\n\n                $first_arg.is_zero()\n                    $( && $rest.is_zero() )*\n            }\n        }\n\n        impl_for_tuples!($($rest),*);\n    }\n}\n\nimpl_for_tuples!(A, B, C, D, E, F, G, H);\n\n// `Option<&T>` and `Option<Box<T>>` are guaranteed to represent `None` as null.\n// For fat pointers, the bytes that would be the pointer metadata in the `Some`\n// variant are padding in the `None` variant, so ignoring them and\n// zero-initializing instead is ok.\n// `Option<&mut T>` never implements `Clone`, so there's no need for an impl of\n// `SpecFromElem`.\n\nunsafe impl<T: ?Sized> IsZero for Option<&T> {\n    #[inline]\n    fn is_zero(&self) -> bool {\n        self.is_none()\n    }\n}\n\nunsafe impl<T: ?Sized> IsZero for Option<Box<T>> {\n    #[inline]\n    fn is_zero(&self) -> bool {\n        self.is_none()\n    }\n}\n\n// `Option<num::NonZeroU32>` and similar have a representation guarantee that\n// they're the same size as the corresponding `u32` type, as well as a guarantee\n// that transmuting between `NonZeroU32` and `Option<num::NonZeroU32>` works.\n// While the documentation officially makes it UB to transmute from `None`,\n// we're the standard library so we can make extra inferences, and we know that\n// the only niche available to represent `None` is the one that's all zeros.\n\nmacro_rules! impl_is_zero_option_of_nonzero {\n    ($($t:ident,)+) => {$(\n        unsafe impl IsZero for Option<core::num::$t> {\n            #[inline]\n            fn is_zero(&self) -> bool {\n                self.is_none()\n            }\n        }\n    )+};\n}\n\nimpl_is_zero_option_of_nonzero!(\n    NonZeroU8,\n    NonZeroU16,\n    NonZeroU32,\n    NonZeroU64,\n    NonZeroU128,\n    NonZeroI8,\n    NonZeroI16,\n    NonZeroI32,\n    NonZeroI64,\n    NonZeroI128,\n    NonZeroUsize,\n    NonZeroIsize,\n);\n\nmacro_rules! impl_is_zero_option_of_num {\n    ($($t:ty,)+) => {$(\n        unsafe impl IsZero for Option<$t> {\n            #[inline]\n            fn is_zero(&self) -> bool {\n                const {\n                    let none: Self = unsafe { core::mem::MaybeUninit::zeroed().assume_init() };\n                    assert!(none.is_none());\n                }\n                self.is_none()\n            }\n        }\n    )+};\n}\n\nimpl_is_zero_option_of_num!(u8, u16, u32, u64, u128, i8, i16, i32, i64, i128, usize, isize,);\n\nunsafe impl<T: IsZero> IsZero for Wrapping<T> {\n    #[inline]\n    fn is_zero(&self) -> bool {\n        self.0.is_zero()\n    }\n}\n\nunsafe impl<T: IsZero> IsZero for Saturating<T> {\n    #[inline]\n    fn is_zero(&self) -> bool {\n        self.0.is_zero()\n    }\n}\n\nmacro_rules! impl_for_optional_bool {\n    ($($t:ty,)+) => {$(\n        unsafe impl IsZero for $t {\n            #[inline]\n            fn is_zero(&self) -> bool {\n                // SAFETY: This is *not* a stable layout guarantee, but\n                // inside `core` we're allowed to rely on the current rustc\n                // behaviour that options of bools will be one byte with\n                // no padding, so long as they're nested less than 254 deep.\n                let raw: u8 = unsafe { core::mem::transmute(*self) };\n                raw == 0\n            }\n        }\n    )+};\n}\nimpl_for_optional_bool! {\n    Option<bool>,\n    Option<Option<bool>>,\n    Option<Option<Option<bool>>>,\n    // Could go further, but not worth the metadata overhead\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}