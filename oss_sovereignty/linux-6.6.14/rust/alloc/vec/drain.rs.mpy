{
  "module_name": "drain.rs",
  "hash_id": "3fffbd6a984f08472502bc92ede07aa28b0fe80874c646d7717bd27504c1f368",
  "original_prompt": "Ingested from linux-6.6.14/rust/alloc/vec/drain.rs",
  "human_readable_source": "// SPDX-License-Identifier: Apache-2.0 OR MIT\n\nuse crate::alloc::{Allocator, Global};\nuse core::fmt;\nuse core::iter::{FusedIterator, TrustedLen};\nuse core::mem::{self, ManuallyDrop, SizedTypeProperties};\nuse core::ptr::{self, NonNull};\nuse core::slice::{self};\n\nuse super::Vec;\n\n/// A draining iterator for `Vec<T>`.\n///\n/// This `struct` is created by [`Vec::drain`].\n/// See its documentation for more.\n///\n/// # Example\n///\n/// ```\n/// let mut v = vec![0, 1, 2];\n/// let iter: std::vec::Drain<'_, _> = v.drain(..);\n/// ```\n#[stable(feature = \"drain\", since = \"1.6.0\")]\npub struct Drain<\n    'a,\n    T: 'a,\n    #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: Allocator + 'a = Global,\n> {\n    /// Index of tail to preserve\n    pub(super) tail_start: usize,\n    /// Length of tail\n    pub(super) tail_len: usize,\n    /// Current remaining range to remove\n    pub(super) iter: slice::Iter<'a, T>,\n    pub(super) vec: NonNull<Vec<T, A>>,\n}\n\n#[stable(feature = \"collection_debug\", since = \"1.17.0\")]\nimpl<T: fmt::Debug, A: Allocator> fmt::Debug for Drain<'_, T, A> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_tuple(\"Drain\").field(&self.iter.as_slice()).finish()\n    }\n}\n\nimpl<'a, T, A: Allocator> Drain<'a, T, A> {\n    /// Returns the remaining items of this iterator as a slice.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut vec = vec!['a', 'b', 'c'];\n    /// let mut drain = vec.drain(..);\n    /// assert_eq!(drain.as_slice(), &['a', 'b', 'c']);\n    /// let _ = drain.next().unwrap();\n    /// assert_eq!(drain.as_slice(), &['b', 'c']);\n    /// ```\n    #[must_use]\n    #[stable(feature = \"vec_drain_as_slice\", since = \"1.46.0\")]\n    pub fn as_slice(&self) -> &[T] {\n        self.iter.as_slice()\n    }\n\n    /// Returns a reference to the underlying allocator.\n    #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n    #[must_use]\n    #[inline]\n    pub fn allocator(&self) -> &A {\n        unsafe { self.vec.as_ref().allocator() }\n    }\n\n    /// Keep unyielded elements in the source `Vec`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(drain_keep_rest)]\n    ///\n    /// let mut vec = vec!['a', 'b', 'c'];\n    /// let mut drain = vec.drain(..);\n    ///\n    /// assert_eq!(drain.next().unwrap(), 'a');\n    ///\n    /// // This call keeps 'b' and 'c' in the vec.\n    /// drain.keep_rest();\n    ///\n    /// // If we wouldn't call `keep_rest()`,\n    /// // `vec` would be empty.\n    /// assert_eq!(vec, ['b', 'c']);\n    /// ```\n    #[unstable(feature = \"drain_keep_rest\", issue = \"101122\")]\n    pub fn keep_rest(self) {\n        // At this moment layout looks like this:\n        //\n        // [head] [yielded by next] [unyielded] [yielded by next_back] [tail]\n        //        ^-- start         \\_________/-- unyielded_len        \\____/-- self.tail_len\n        //                          ^-- unyielded_ptr                  ^-- tail\n        //\n        // Normally `Drop` impl would drop [unyielded] and then move [tail] to the `start`.\n        // Here we want to\n        // 1. Move [unyielded] to `start`\n        // 2. Move [tail] to a new start at `start + len(unyielded)`\n        // 3. Update length of the original vec to `len(head) + len(unyielded) + len(tail)`\n        //    a. In case of ZST, this is the only thing we want to do\n        // 4. Do *not* drop self, as everything is put in a consistent state already, there is nothing to do\n        let mut this = ManuallyDrop::new(self);\n\n        unsafe {\n            let source_vec = this.vec.as_mut();\n\n            let start = source_vec.len();\n            let tail = this.tail_start;\n\n            let unyielded_len = this.iter.len();\n            let unyielded_ptr = this.iter.as_slice().as_ptr();\n\n            // ZSTs have no identity, so we don't need to move them around.\n            if !T::IS_ZST {\n                let start_ptr = source_vec.as_mut_ptr().add(start);\n\n                // memmove back unyielded elements\n                if unyielded_ptr != start_ptr {\n                    let src = unyielded_ptr;\n                    let dst = start_ptr;\n\n                    ptr::copy(src, dst, unyielded_len);\n                }\n\n                // memmove back untouched tail\n                if tail != (start + unyielded_len) {\n                    let src = source_vec.as_ptr().add(tail);\n                    let dst = start_ptr.add(unyielded_len);\n                    ptr::copy(src, dst, this.tail_len);\n                }\n            }\n\n            source_vec.set_len(start + unyielded_len + this.tail_len);\n        }\n    }\n}\n\n#[stable(feature = \"vec_drain_as_slice\", since = \"1.46.0\")]\nimpl<'a, T, A: Allocator> AsRef<[T]> for Drain<'a, T, A> {\n    fn as_ref(&self) -> &[T] {\n        self.as_slice()\n    }\n}\n\n#[stable(feature = \"drain\", since = \"1.6.0\")]\nunsafe impl<T: Sync, A: Sync + Allocator> Sync for Drain<'_, T, A> {}\n#[stable(feature = \"drain\", since = \"1.6.0\")]\nunsafe impl<T: Send, A: Send + Allocator> Send for Drain<'_, T, A> {}\n\n#[stable(feature = \"drain\", since = \"1.6.0\")]\nimpl<T, A: Allocator> Iterator for Drain<'_, T, A> {\n    type Item = T;\n\n    #[inline]\n    fn next(&mut self) -> Option<T> {\n        self.iter.next().map(|elt| unsafe { ptr::read(elt as *const _) })\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.iter.size_hint()\n    }\n}\n\n#[stable(feature = \"drain\", since = \"1.6.0\")]\nimpl<T, A: Allocator> DoubleEndedIterator for Drain<'_, T, A> {\n    #[inline]\n    fn next_back(&mut self) -> Option<T> {\n        self.iter.next_back().map(|elt| unsafe { ptr::read(elt as *const _) })\n    }\n}\n\n#[stable(feature = \"drain\", since = \"1.6.0\")]\nimpl<T, A: Allocator> Drop for Drain<'_, T, A> {\n    fn drop(&mut self) {\n        /// Moves back the un-`Drain`ed elements to restore the original `Vec`.\n        struct DropGuard<'r, 'a, T, A: Allocator>(&'r mut Drain<'a, T, A>);\n\n        impl<'r, 'a, T, A: Allocator> Drop for DropGuard<'r, 'a, T, A> {\n            fn drop(&mut self) {\n                if self.0.tail_len > 0 {\n                    unsafe {\n                        let source_vec = self.0.vec.as_mut();\n                        // memmove back untouched tail, update to new length\n                        let start = source_vec.len();\n                        let tail = self.0.tail_start;\n                        if tail != start {\n                            let src = source_vec.as_ptr().add(tail);\n                            let dst = source_vec.as_mut_ptr().add(start);\n                            ptr::copy(src, dst, self.0.tail_len);\n                        }\n                        source_vec.set_len(start + self.0.tail_len);\n                    }\n                }\n            }\n        }\n\n        let iter = mem::take(&mut self.iter);\n        let drop_len = iter.len();\n\n        let mut vec = self.vec;\n\n        if T::IS_ZST {\n            // ZSTs have no identity, so we don't need to move them around, we only need to drop the correct amount.\n            // this can be achieved by manipulating the Vec length instead of moving values out from `iter`.\n            unsafe {\n                let vec = vec.as_mut();\n                let old_len = vec.len();\n                vec.set_len(old_len + drop_len + self.tail_len);\n                vec.truncate(old_len + self.tail_len);\n            }\n\n            return;\n        }\n\n        // ensure elements are moved back into their appropriate places, even when drop_in_place panics\n        let _guard = DropGuard(self);\n\n        if drop_len == 0 {\n            return;\n        }\n\n        // as_slice() must only be called when iter.len() is > 0 because\n        // it also gets touched by vec::Splice which may turn it into a dangling pointer\n        // which would make it and the vec pointer point to different allocations which would\n        // lead to invalid pointer arithmetic below.\n        let drop_ptr = iter.as_slice().as_ptr();\n\n        unsafe {\n            // drop_ptr comes from a slice::Iter which only gives us a &[T] but for drop_in_place\n            // a pointer with mutable provenance is necessary. Therefore we must reconstruct\n            // it from the original vec but also avoid creating a &mut to the front since that could\n            // invalidate raw pointers to it which some unsafe code might rely on.\n            let vec_ptr = vec.as_mut().as_mut_ptr();\n            let drop_offset = drop_ptr.sub_ptr(vec_ptr);\n            let to_drop = ptr::slice_from_raw_parts_mut(vec_ptr.add(drop_offset), drop_len);\n            ptr::drop_in_place(to_drop);\n        }\n    }\n}\n\n#[stable(feature = \"drain\", since = \"1.6.0\")]\nimpl<T, A: Allocator> ExactSizeIterator for Drain<'_, T, A> {\n    fn is_empty(&self) -> bool {\n        self.iter.is_empty()\n    }\n}\n\n#[unstable(feature = \"trusted_len\", issue = \"37572\")]\nunsafe impl<T, A: Allocator> TrustedLen for Drain<'_, T, A> {}\n\n#[stable(feature = \"fused\", since = \"1.26.0\")]\nimpl<T, A: Allocator> FusedIterator for Drain<'_, T, A> {}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}