{
  "module_name": "partial_eq.rs",
  "hash_id": "394c1ac660235e34ced7d6150635938de82c48e28594acbb14051d2732c5e07d",
  "original_prompt": "Ingested from linux-6.6.14/rust/alloc/vec/partial_eq.rs",
  "human_readable_source": "// SPDX-License-Identifier: Apache-2.0 OR MIT\n\nuse crate::alloc::Allocator;\n#[cfg(not(no_global_oom_handling))]\nuse crate::borrow::Cow;\n\nuse super::Vec;\n\nmacro_rules! __impl_slice_eq1 {\n    ([$($vars:tt)*] $lhs:ty, $rhs:ty $(where $ty:ty: $bound:ident)?, #[$stability:meta]) => {\n        #[$stability]\n        impl<T, U, $($vars)*> PartialEq<$rhs> for $lhs\n        where\n            T: PartialEq<U>,\n            $($ty: $bound)?\n        {\n            #[inline]\n            fn eq(&self, other: &$rhs) -> bool { self[..] == other[..] }\n            #[inline]\n            fn ne(&self, other: &$rhs) -> bool { self[..] != other[..] }\n        }\n    }\n}\n\n__impl_slice_eq1! { [A1: Allocator, A2: Allocator] Vec<T, A1>, Vec<U, A2>, #[stable(feature = \"rust1\", since = \"1.0.0\")] }\n__impl_slice_eq1! { [A: Allocator] Vec<T, A>, &[U], #[stable(feature = \"rust1\", since = \"1.0.0\")] }\n__impl_slice_eq1! { [A: Allocator] Vec<T, A>, &mut [U], #[stable(feature = \"rust1\", since = \"1.0.0\")] }\n__impl_slice_eq1! { [A: Allocator] &[T], Vec<U, A>, #[stable(feature = \"partialeq_vec_for_ref_slice\", since = \"1.46.0\")] }\n__impl_slice_eq1! { [A: Allocator] &mut [T], Vec<U, A>, #[stable(feature = \"partialeq_vec_for_ref_slice\", since = \"1.46.0\")] }\n__impl_slice_eq1! { [A: Allocator] Vec<T, A>, [U], #[stable(feature = \"partialeq_vec_for_slice\", since = \"1.48.0\")]  }\n__impl_slice_eq1! { [A: Allocator] [T], Vec<U, A>, #[stable(feature = \"partialeq_vec_for_slice\", since = \"1.48.0\")]  }\n#[cfg(not(no_global_oom_handling))]\n__impl_slice_eq1! { [A: Allocator] Cow<'_, [T]>, Vec<U, A> where T: Clone, #[stable(feature = \"rust1\", since = \"1.0.0\")] }\n#[cfg(not(no_global_oom_handling))]\n__impl_slice_eq1! { [] Cow<'_, [T]>, &[U] where T: Clone, #[stable(feature = \"rust1\", since = \"1.0.0\")] }\n#[cfg(not(no_global_oom_handling))]\n__impl_slice_eq1! { [] Cow<'_, [T]>, &mut [U] where T: Clone, #[stable(feature = \"rust1\", since = \"1.0.0\")] }\n__impl_slice_eq1! { [A: Allocator, const N: usize] Vec<T, A>, [U; N], #[stable(feature = \"rust1\", since = \"1.0.0\")] }\n__impl_slice_eq1! { [A: Allocator, const N: usize] Vec<T, A>, &[U; N], #[stable(feature = \"rust1\", since = \"1.0.0\")] }\n\n// NOTE: some less important impls are omitted to reduce code bloat\n// FIXME(Centril): Reconsider this?\n//__impl_slice_eq1! { [const N: usize] Vec<A>, &mut [B; N], }\n//__impl_slice_eq1! { [const N: usize] [A; N], Vec<B>, }\n//__impl_slice_eq1! { [const N: usize] &[A; N], Vec<B>, }\n//__impl_slice_eq1! { [const N: usize] &mut [A; N], Vec<B>, }\n//__impl_slice_eq1! { [const N: usize] Cow<'a, [A]>, [B; N], }\n//__impl_slice_eq1! { [const N: usize] Cow<'a, [A]>, &[B; N], }\n//__impl_slice_eq1! { [const N: usize] Cow<'a, [A]>, &mut [B; N], }\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}