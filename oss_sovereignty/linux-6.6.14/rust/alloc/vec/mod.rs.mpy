{
  "module_name": "mod.rs",
  "hash_id": "131fdefd14515b46f680a4b32c708f6ab8f6649e2043f1c5e52272df50687fa3",
  "original_prompt": "Ingested from linux-6.6.14/rust/alloc/vec/mod.rs",
  "human_readable_source": "// SPDX-License-Identifier: Apache-2.0 OR MIT\n\n//! A contiguous growable array type with heap-allocated contents, written\n//! `Vec<T>`.\n//!\n//! Vectors have *O*(1) indexing, amortized *O*(1) push (to the end) and\n//! *O*(1) pop (from the end).\n//!\n//! Vectors ensure they never allocate more than `isize::MAX` bytes.\n//!\n//! # Examples\n//!\n//! You can explicitly create a [`Vec`] with [`Vec::new`]:\n//!\n//! ```\n//! let v: Vec<i32> = Vec::new();\n//! ```\n//!\n//! ...or by using the [`vec!`] macro:\n//!\n//! ```\n//! let v: Vec<i32> = vec![];\n//!\n//! let v = vec![1, 2, 3, 4, 5];\n//!\n//! let v = vec![0; 10]; // ten zeroes\n//! ```\n//!\n//! You can [`push`] values onto the end of a vector (which will grow the vector\n//! as needed):\n//!\n//! ```\n//! let mut v = vec![1, 2];\n//!\n//! v.push(3);\n//! ```\n//!\n//! Popping values works in much the same way:\n//!\n//! ```\n//! let mut v = vec![1, 2];\n//!\n//! let two = v.pop();\n//! ```\n//!\n//! Vectors also support indexing (through the [`Index`] and [`IndexMut`] traits):\n//!\n//! ```\n//! let mut v = vec![1, 2, 3];\n//! let three = v[2];\n//! v[1] = v[1] + 5;\n//! ```\n//!\n//! [`push`]: Vec::push\n\n#![stable(feature = \"rust1\", since = \"1.0.0\")]\n\n#[cfg(not(no_global_oom_handling))]\nuse core::cmp;\nuse core::cmp::Ordering;\nuse core::fmt;\nuse core::hash::{Hash, Hasher};\nuse core::iter;\nuse core::marker::PhantomData;\nuse core::mem::{self, ManuallyDrop, MaybeUninit, SizedTypeProperties};\nuse core::ops::{self, Index, IndexMut, Range, RangeBounds};\nuse core::ptr::{self, NonNull};\nuse core::slice::{self, SliceIndex};\n\nuse crate::alloc::{Allocator, Global};\n#[cfg(not(no_borrow))]\nuse crate::borrow::{Cow, ToOwned};\nuse crate::boxed::Box;\nuse crate::collections::{TryReserveError, TryReserveErrorKind};\nuse crate::raw_vec::RawVec;\n\n#[unstable(feature = \"drain_filter\", reason = \"recently added\", issue = \"43244\")]\npub use self::drain_filter::DrainFilter;\n\nmod drain_filter;\n\n#[cfg(not(no_global_oom_handling))]\n#[stable(feature = \"vec_splice\", since = \"1.21.0\")]\npub use self::splice::Splice;\n\n#[cfg(not(no_global_oom_handling))]\nmod splice;\n\n#[stable(feature = \"drain\", since = \"1.6.0\")]\npub use self::drain::Drain;\n\nmod drain;\n\n#[cfg(not(no_borrow))]\n#[cfg(not(no_global_oom_handling))]\nmod cow;\n\n#[cfg(not(no_global_oom_handling))]\npub(crate) use self::in_place_collect::AsVecIntoIter;\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use self::into_iter::IntoIter;\n\nmod into_iter;\n\n#[cfg(not(no_global_oom_handling))]\nuse self::is_zero::IsZero;\n\nmod is_zero;\n\n#[cfg(not(no_global_oom_handling))]\nmod in_place_collect;\n\nmod partial_eq;\n\n#[cfg(not(no_global_oom_handling))]\nuse self::spec_from_elem::SpecFromElem;\n\n#[cfg(not(no_global_oom_handling))]\nmod spec_from_elem;\n\nuse self::set_len_on_drop::SetLenOnDrop;\n\nmod set_len_on_drop;\n\n#[cfg(not(no_global_oom_handling))]\nuse self::in_place_drop::{InPlaceDrop, InPlaceDstBufDrop};\n\n#[cfg(not(no_global_oom_handling))]\nmod in_place_drop;\n\n#[cfg(not(no_global_oom_handling))]\nuse self::spec_from_iter_nested::SpecFromIterNested;\n\n#[cfg(not(no_global_oom_handling))]\nmod spec_from_iter_nested;\n\n#[cfg(not(no_global_oom_handling))]\nuse self::spec_from_iter::SpecFromIter;\n\n#[cfg(not(no_global_oom_handling))]\nmod spec_from_iter;\n\n#[cfg(not(no_global_oom_handling))]\nuse self::spec_extend::SpecExtend;\n\nuse self::spec_extend::TrySpecExtend;\n\nmod spec_extend;\n\n/// A contiguous growable array type, written as `Vec<T>`, short for 'vector'.\n///\n/// # Examples\n///\n/// ```\n/// let mut vec = Vec::new();\n/// vec.push(1);\n/// vec.push(2);\n///\n/// assert_eq!(vec.len(), 2);\n/// assert_eq!(vec[0], 1);\n///\n/// assert_eq!(vec.pop(), Some(2));\n/// assert_eq!(vec.len(), 1);\n///\n/// vec[0] = 7;\n/// assert_eq!(vec[0], 7);\n///\n/// vec.extend([1, 2, 3]);\n///\n/// for x in &vec {\n///     println!(\"{x}\");\n/// }\n/// assert_eq!(vec, [7, 1, 2, 3]);\n/// ```\n///\n/// The [`vec!`] macro is provided for convenient initialization:\n///\n/// ```\n/// let mut vec1 = vec![1, 2, 3];\n/// vec1.push(4);\n/// let vec2 = Vec::from([1, 2, 3, 4]);\n/// assert_eq!(vec1, vec2);\n/// ```\n///\n/// It can also initialize each element of a `Vec<T>` with a given value.\n/// This may be more efficient than performing allocation and initialization\n/// in separate steps, especially when initializing a vector of zeros:\n///\n/// ```\n/// let vec = vec![0; 5];\n/// assert_eq!(vec, [0, 0, 0, 0, 0]);\n///\n/// // The following is equivalent, but potentially slower:\n/// let mut vec = Vec::with_capacity(5);\n/// vec.resize(5, 0);\n/// assert_eq!(vec, [0, 0, 0, 0, 0]);\n/// ```\n///\n/// For more information, see\n/// [Capacity and Reallocation](#capacity-and-reallocation).\n///\n/// Use a `Vec<T>` as an efficient stack:\n///\n/// ```\n/// let mut stack = Vec::new();\n///\n/// stack.push(1);\n/// stack.push(2);\n/// stack.push(3);\n///\n/// while let Some(top) = stack.pop() {\n///     // Prints 3, 2, 1\n///     println!(\"{top}\");\n/// }\n/// ```\n///\n/// # Indexing\n///\n/// The `Vec` type allows to access values by index, because it implements the\n/// [`Index`] trait. An example will be more explicit:\n///\n/// ```\n/// let v = vec![0, 2, 4, 6];\n/// println!(\"{}\", v[1]); // it will display '2'\n/// ```\n///\n/// However be careful: if you try to access an index which isn't in the `Vec`,\n/// your software will panic! You cannot do this:\n///\n/// ```should_panic\n/// let v = vec![0, 2, 4, 6];\n/// println!(\"{}\", v[6]); // it will panic!\n/// ```\n///\n/// Use [`get`] and [`get_mut`] if you want to check whether the index is in\n/// the `Vec`.\n///\n/// # Slicing\n///\n/// A `Vec` can be mutable. On the other hand, slices are read-only objects.\n/// To get a [slice][prim@slice], use [`&`]. Example:\n///\n/// ```\n/// fn read_slice(slice: &[usize]) {\n///     // ...\n/// }\n///\n/// let v = vec![0, 1];\n/// read_slice(&v);\n///\n/// // ... and that's all!\n/// // you can also do it like this:\n/// let u: &[usize] = &v;\n/// // or like this:\n/// let u: &[_] = &v;\n/// ```\n///\n/// In Rust, it's more common to pass slices as arguments rather than vectors\n/// when you just want to provide read access. The same goes for [`String`] and\n/// [`&str`].\n///\n/// # Capacity and reallocation\n///\n/// The capacity of a vector is the amount of space allocated for any future\n/// elements that will be added onto the vector. This is not to be confused with\n/// the *length* of a vector, which specifies the number of actual elements\n/// within the vector. If a vector's length exceeds its capacity, its capacity\n/// will automatically be increased, but its elements will have to be\n/// reallocated.\n///\n/// For example, a vector with capacity 10 and length 0 would be an empty vector\n/// with space for 10 more elements. Pushing 10 or fewer elements onto the\n/// vector will not change its capacity or cause reallocation to occur. However,\n/// if the vector's length is increased to 11, it will have to reallocate, which\n/// can be slow. For this reason, it is recommended to use [`Vec::with_capacity`]\n/// whenever possible to specify how big the vector is expected to get.\n///\n/// # Guarantees\n///\n/// Due to its incredibly fundamental nature, `Vec` makes a lot of guarantees\n/// about its design. This ensures that it's as low-overhead as possible in\n/// the general case, and can be correctly manipulated in primitive ways\n/// by unsafe code. Note that these guarantees refer to an unqualified `Vec<T>`.\n/// If additional type parameters are added (e.g., to support custom allocators),\n/// overriding their defaults may change the behavior.\n///\n/// Most fundamentally, `Vec` is and always will be a (pointer, capacity, length)\n/// triplet. No more, no less. The order of these fields is completely\n/// unspecified, and you should use the appropriate methods to modify these.\n/// The pointer will never be null, so this type is null-pointer-optimized.\n///\n/// However, the pointer might not actually point to allocated memory. In particular,\n/// if you construct a `Vec` with capacity 0 via [`Vec::new`], [`vec![]`][`vec!`],\n/// [`Vec::with_capacity(0)`][`Vec::with_capacity`], or by calling [`shrink_to_fit`]\n/// on an empty Vec, it will not allocate memory. Similarly, if you store zero-sized\n/// types inside a `Vec`, it will not allocate space for them. *Note that in this case\n/// the `Vec` might not report a [`capacity`] of 0*. `Vec` will allocate if and only\n/// if <code>[mem::size_of::\\<T>]\\() * [capacity]\\() > 0</code>. In general, `Vec`'s allocation\n/// details are very subtle --- if you intend to allocate memory using a `Vec`\n/// and use it for something else (either to pass to unsafe code, or to build your\n/// own memory-backed collection), be sure to deallocate this memory by using\n/// `from_raw_parts` to recover the `Vec` and then dropping it.\n///\n/// If a `Vec` *has* allocated memory, then the memory it points to is on the heap\n/// (as defined by the allocator Rust is configured to use by default), and its\n/// pointer points to [`len`] initialized, contiguous elements in order (what\n/// you would see if you coerced it to a slice), followed by <code>[capacity] - [len]</code>\n/// logically uninitialized, contiguous elements.\n///\n/// A vector containing the elements `'a'` and `'b'` with capacity 4 can be\n/// visualized as below. The top part is the `Vec` struct, it contains a\n/// pointer to the head of the allocation in the heap, length and capacity.\n/// The bottom part is the allocation on the heap, a contiguous memory block.\n///\n/// ```text\n///             ptr      len  capacity\n///        +--------+--------+--------+\n///        | 0x0123 |      2 |      4 |\n///        +--------+--------+--------+\n///             |\n///             v\n/// Heap   +--------+--------+--------+--------+\n///        |    'a' |    'b' | uninit | uninit |\n///        +--------+--------+--------+--------+\n/// ```\n///\n/// - **uninit** represents memory that is not initialized, see [`MaybeUninit`].\n/// - Note: the ABI is not stable and `Vec` makes no guarantees about its memory\n///   layout (including the order of fields).\n///\n/// `Vec` will never perform a \"small optimization\" where elements are actually\n/// stored on the stack for two reasons:\n///\n/// * It would make it more difficult for unsafe code to correctly manipulate\n///   a `Vec`. The contents of a `Vec` wouldn't have a stable address if it were\n///   only moved, and it would be more difficult to determine if a `Vec` had\n///   actually allocated memory.\n///\n/// * It would penalize the general case, incurring an additional branch\n///   on every access.\n///\n/// `Vec` will never automatically shrink itself, even if completely empty. This\n/// ensures no unnecessary allocations or deallocations occur. Emptying a `Vec`\n/// and then filling it back up to the same [`len`] should incur no calls to\n/// the allocator. If you wish to free up unused memory, use\n/// [`shrink_to_fit`] or [`shrink_to`].\n///\n/// [`push`] and [`insert`] will never (re)allocate if the reported capacity is\n/// sufficient. [`push`] and [`insert`] *will* (re)allocate if\n/// <code>[len] == [capacity]</code>. That is, the reported capacity is completely\n/// accurate, and can be relied on. It can even be used to manually free the memory\n/// allocated by a `Vec` if desired. Bulk insertion methods *may* reallocate, even\n/// when not necessary.\n///\n/// `Vec` does not guarantee any particular growth strategy when reallocating\n/// when full, nor when [`reserve`] is called. The current strategy is basic\n/// and it may prove desirable to use a non-constant growth factor. Whatever\n/// strategy is used will of course guarantee *O*(1) amortized [`push`].\n///\n/// `vec![x; n]`, `vec![a, b, c, d]`, and\n/// [`Vec::with_capacity(n)`][`Vec::with_capacity`], will all produce a `Vec`\n/// with exactly the requested capacity. If <code>[len] == [capacity]</code>,\n/// (as is the case for the [`vec!`] macro), then a `Vec<T>` can be converted to\n/// and from a [`Box<[T]>`][owned slice] without reallocating or moving the elements.\n///\n/// `Vec` will not specifically overwrite any data that is removed from it,\n/// but also won't specifically preserve it. Its uninitialized memory is\n/// scratch space that it may use however it wants. It will generally just do\n/// whatever is most efficient or otherwise easy to implement. Do not rely on\n/// removed data to be erased for security purposes. Even if you drop a `Vec`, its\n/// buffer may simply be reused by another allocation. Even if you zero a `Vec`'s memory\n/// first, that might not actually happen because the optimizer does not consider\n/// this a side-effect that must be preserved. There is one case which we will\n/// not break, however: using `unsafe` code to write to the excess capacity,\n/// and then increasing the length to match, is always valid.\n///\n/// Currently, `Vec` does not guarantee the order in which elements are dropped.\n/// The order has changed in the past and may change again.\n///\n/// [`get`]: slice::get\n/// [`get_mut`]: slice::get_mut\n/// [`String`]: crate::string::String\n/// [`&str`]: type@str\n/// [`shrink_to_fit`]: Vec::shrink_to_fit\n/// [`shrink_to`]: Vec::shrink_to\n/// [capacity]: Vec::capacity\n/// [`capacity`]: Vec::capacity\n/// [mem::size_of::\\<T>]: core::mem::size_of\n/// [len]: Vec::len\n/// [`len`]: Vec::len\n/// [`push`]: Vec::push\n/// [`insert`]: Vec::insert\n/// [`reserve`]: Vec::reserve\n/// [`MaybeUninit`]: core::mem::MaybeUninit\n/// [owned slice]: Box\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[cfg_attr(not(test), rustc_diagnostic_item = \"Vec\")]\n#[rustc_insignificant_dtor]\npub struct Vec<T, #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: Allocator = Global> {\n    buf: RawVec<T, A>,\n    len: usize,\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Inherent methods\n////////////////////////////////////////////////////////////////////////////////\n\nimpl<T> Vec<T> {\n    /// Constructs a new, empty `Vec<T>`.\n    ///\n    /// The vector will not allocate until elements are pushed onto it.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #![allow(unused_mut)]\n    /// let mut vec: Vec<i32> = Vec::new();\n    /// ```\n    #[inline]\n    #[rustc_const_stable(feature = \"const_vec_new\", since = \"1.39.0\")]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[must_use]\n    pub const fn new() -> Self {\n        Vec { buf: RawVec::NEW, len: 0 }\n    }\n\n    /// Constructs a new, empty `Vec<T>` with at least the specified capacity.\n    ///\n    /// The vector will be able to hold at least `capacity` elements without\n    /// reallocating. This method is allowed to allocate for more elements than\n    /// `capacity`. If `capacity` is 0, the vector will not allocate.\n    ///\n    /// It is important to note that although the returned vector has the\n    /// minimum *capacity* specified, the vector will have a zero *length*. For\n    /// an explanation of the difference between length and capacity, see\n    /// *[Capacity and reallocation]*.\n    ///\n    /// If it is important to know the exact allocated capacity of a `Vec`,\n    /// always use the [`capacity`] method after construction.\n    ///\n    /// For `Vec<T>` where `T` is a zero-sized type, there will be no allocation\n    /// and the capacity will always be `usize::MAX`.\n    ///\n    /// [Capacity and reallocation]: #capacity-and-reallocation\n    /// [`capacity`]: Vec::capacity\n    ///\n    /// # Panics\n    ///\n    /// Panics if the new capacity exceeds `isize::MAX` bytes.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut vec = Vec::with_capacity(10);\n    ///\n    /// // The vector contains no items, even though it has capacity for more\n    /// assert_eq!(vec.len(), 0);\n    /// assert!(vec.capacity() >= 10);\n    ///\n    /// // These are all done without reallocating...\n    /// for i in 0..10 {\n    ///     vec.push(i);\n    /// }\n    /// assert_eq!(vec.len(), 10);\n    /// assert!(vec.capacity() >= 10);\n    ///\n    /// // ...but this may make the vector reallocate\n    /// vec.push(11);\n    /// assert_eq!(vec.len(), 11);\n    /// assert!(vec.capacity() >= 11);\n    ///\n    /// // A vector of a zero-sized type will always over-allocate, since no\n    /// // allocation is necessary\n    /// let vec_units = Vec::<()>::with_capacity(10);\n    /// assert_eq!(vec_units.capacity(), usize::MAX);\n    /// ```\n    #[cfg(not(no_global_oom_handling))]\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[must_use]\n    pub fn with_capacity(capacity: usize) -> Self {\n        Self::with_capacity_in(capacity, Global)\n    }\n\n    /// Tries to construct a new, empty `Vec<T>` with at least the specified capacity.\n    ///\n    /// The vector will be able to hold at least `capacity` elements without\n    /// reallocating. This method is allowed to allocate for more elements than\n    /// `capacity`. If `capacity` is 0, the vector will not allocate.\n    ///\n    /// It is important to note that although the returned vector has the\n    /// minimum *capacity* specified, the vector will have a zero *length*. For\n    /// an explanation of the difference between length and capacity, see\n    /// *[Capacity and reallocation]*.\n    ///\n    /// If it is important to know the exact allocated capacity of a `Vec`,\n    /// always use the [`capacity`] method after construction.\n    ///\n    /// For `Vec<T>` where `T` is a zero-sized type, there will be no allocation\n    /// and the capacity will always be `usize::MAX`.\n    ///\n    /// [Capacity and reallocation]: #capacity-and-reallocation\n    /// [`capacity`]: Vec::capacity\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut vec = Vec::try_with_capacity(10).unwrap();\n    ///\n    /// // The vector contains no items, even though it has capacity for more\n    /// assert_eq!(vec.len(), 0);\n    /// assert!(vec.capacity() >= 10);\n    ///\n    /// // These are all done without reallocating...\n    /// for i in 0..10 {\n    ///     vec.push(i);\n    /// }\n    /// assert_eq!(vec.len(), 10);\n    /// assert!(vec.capacity() >= 10);\n    ///\n    /// // ...but this may make the vector reallocate\n    /// vec.push(11);\n    /// assert_eq!(vec.len(), 11);\n    /// assert!(vec.capacity() >= 11);\n    ///\n    /// let mut result = Vec::try_with_capacity(usize::MAX);\n    /// assert!(result.is_err());\n    ///\n    /// // A vector of a zero-sized type will always over-allocate, since no\n    /// // allocation is necessary\n    /// let vec_units = Vec::<()>::try_with_capacity(10).unwrap();\n    /// assert_eq!(vec_units.capacity(), usize::MAX);\n    /// ```\n    #[inline]\n    #[stable(feature = \"kernel\", since = \"1.0.0\")]\n    pub fn try_with_capacity(capacity: usize) -> Result<Self, TryReserveError> {\n        Self::try_with_capacity_in(capacity, Global)\n    }\n\n    /// Creates a `Vec<T>` directly from a pointer, a capacity, and a length.\n    ///\n    /// # Safety\n    ///\n    /// This is highly unsafe, due to the number of invariants that aren't\n    /// checked:\n    ///\n    /// * `ptr` must have been allocated using the global allocator, such as via\n    ///   the [`alloc::alloc`] function.\n    /// * `T` needs to have the same alignment as what `ptr` was allocated with.\n    ///   (`T` having a less strict alignment is not sufficient, the alignment really\n    ///   needs to be equal to satisfy the [`dealloc`] requirement that memory must be\n    ///   allocated and deallocated with the same layout.)\n    /// * The size of `T` times the `capacity` (ie. the allocated size in bytes) needs\n    ///   to be the same size as the pointer was allocated with. (Because similar to\n    ///   alignment, [`dealloc`] must be called with the same layout `size`.)\n    /// * `length` needs to be less than or equal to `capacity`.\n    /// * The first `length` values must be properly initialized values of type `T`.\n    /// * `capacity` needs to be the capacity that the pointer was allocated with.\n    /// * The allocated size in bytes must be no larger than `isize::MAX`.\n    ///   See the safety documentation of [`pointer::offset`].\n    ///\n    /// These requirements are always upheld by any `ptr` that has been allocated\n    /// via `Vec<T>`. Other allocation sources are allowed if the invariants are\n    /// upheld.\n    ///\n    /// Violating these may cause problems like corrupting the allocator's\n    /// internal data structures. For example it is normally **not** safe\n    /// to build a `Vec<u8>` from a pointer to a C `char` array with length\n    /// `size_t`, doing so is only safe if the array was initially allocated by\n    /// a `Vec` or `String`.\n    /// It's also not safe to build one from a `Vec<u16>` and its length, because\n    /// the allocator cares about the alignment, and these two types have different\n    /// alignments. The buffer was allocated with alignment 2 (for `u16`), but after\n    /// turning it into a `Vec<u8>` it'll be deallocated with alignment 1. To avoid\n    /// these issues, it is often preferable to do casting/transmuting using\n    /// [`slice::from_raw_parts`] instead.\n    ///\n    /// The ownership of `ptr` is effectively transferred to the\n    /// `Vec<T>` which may then deallocate, reallocate or change the\n    /// contents of memory pointed to by the pointer at will. Ensure\n    /// that nothing else uses the pointer after calling this\n    /// function.\n    ///\n    /// [`String`]: crate::string::String\n    /// [`alloc::alloc`]: crate::alloc::alloc\n    /// [`dealloc`]: crate::alloc::GlobalAlloc::dealloc\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::ptr;\n    /// use std::mem;\n    ///\n    /// let v = vec![1, 2, 3];\n    ///\n    // FIXME Update this when vec_into_raw_parts is stabilized\n    /// // Prevent running `v`'s destructor so we are in complete control\n    /// // of the allocation.\n    /// let mut v = mem::ManuallyDrop::new(v);\n    ///\n    /// // Pull out the various important pieces of information about `v`\n    /// let p = v.as_mut_ptr();\n    /// let len = v.len();\n    /// let cap = v.capacity();\n    ///\n    /// unsafe {\n    ///     // Overwrite memory with 4, 5, 6\n    ///     for i in 0..len {\n    ///         ptr::write(p.add(i), 4 + i);\n    ///     }\n    ///\n    ///     // Put everything back together into a Vec\n    ///     let rebuilt = Vec::from_raw_parts(p, len, cap);\n    ///     assert_eq!(rebuilt, [4, 5, 6]);\n    /// }\n    /// ```\n    ///\n    /// Using memory that was allocated elsewhere:\n    ///\n    /// ```rust\n    /// #![feature(allocator_api)]\n    ///\n    /// use std::alloc::{AllocError, Allocator, Global, Layout};\n    ///\n    /// fn main() {\n    ///     let layout = Layout::array::<u32>(16).expect(\"overflow cannot happen\");\n    ///\n    ///     let vec = unsafe {\n    ///         let mem = match Global.allocate(layout) {\n    ///             Ok(mem) => mem.cast::<u32>().as_ptr(),\n    ///             Err(AllocError) => return,\n    ///         };\n    ///\n    ///         mem.write(1_000_000);\n    ///\n    ///         Vec::from_raw_parts_in(mem, 1, 16, Global)\n    ///     };\n    ///\n    ///     assert_eq!(vec, &[1_000_000]);\n    ///     assert_eq!(vec.capacity(), 16);\n    /// }\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub unsafe fn from_raw_parts(ptr: *mut T, length: usize, capacity: usize) -> Self {\n        unsafe { Self::from_raw_parts_in(ptr, length, capacity, Global) }\n    }\n}\n\nimpl<T, A: Allocator> Vec<T, A> {\n    /// Constructs a new, empty `Vec<T, A>`.\n    ///\n    /// The vector will not allocate until elements are pushed onto it.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(allocator_api)]\n    ///\n    /// use std::alloc::System;\n    ///\n    /// # #[allow(unused_mut)]\n    /// let mut vec: Vec<i32, _> = Vec::new_in(System);\n    /// ```\n    #[inline]\n    #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n    pub const fn new_in(alloc: A) -> Self {\n        Vec { buf: RawVec::new_in(alloc), len: 0 }\n    }\n\n    /// Constructs a new, empty `Vec<T, A>` with at least the specified capacity\n    /// with the provided allocator.\n    ///\n    /// The vector will be able to hold at least `capacity` elements without\n    /// reallocating. This method is allowed to allocate for more elements than\n    /// `capacity`. If `capacity` is 0, the vector will not allocate.\n    ///\n    /// It is important to note that although the returned vector has the\n    /// minimum *capacity* specified, the vector will have a zero *length*. For\n    /// an explanation of the difference between length and capacity, see\n    /// *[Capacity and reallocation]*.\n    ///\n    /// If it is important to know the exact allocated capacity of a `Vec`,\n    /// always use the [`capacity`] method after construction.\n    ///\n    /// For `Vec<T, A>` where `T` is a zero-sized type, there will be no allocation\n    /// and the capacity will always be `usize::MAX`.\n    ///\n    /// [Capacity and reallocation]: #capacity-and-reallocation\n    /// [`capacity`]: Vec::capacity\n    ///\n    /// # Panics\n    ///\n    /// Panics if the new capacity exceeds `isize::MAX` bytes.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(allocator_api)]\n    ///\n    /// use std::alloc::System;\n    ///\n    /// let mut vec = Vec::with_capacity_in(10, System);\n    ///\n    /// // The vector contains no items, even though it has capacity for more\n    /// assert_eq!(vec.len(), 0);\n    /// assert!(vec.capacity() >= 10);\n    ///\n    /// // These are all done without reallocating...\n    /// for i in 0..10 {\n    ///     vec.push(i);\n    /// }\n    /// assert_eq!(vec.len(), 10);\n    /// assert!(vec.capacity() >= 10);\n    ///\n    /// // ...but this may make the vector reallocate\n    /// vec.push(11);\n    /// assert_eq!(vec.len(), 11);\n    /// assert!(vec.capacity() >= 11);\n    ///\n    /// // A vector of a zero-sized type will always over-allocate, since no\n    /// // allocation is necessary\n    /// let vec_units = Vec::<(), System>::with_capacity_in(10, System);\n    /// assert_eq!(vec_units.capacity(), usize::MAX);\n    /// ```\n    #[cfg(not(no_global_oom_handling))]\n    #[inline]\n    #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n    pub fn with_capacity_in(capacity: usize, alloc: A) -> Self {\n        Vec { buf: RawVec::with_capacity_in(capacity, alloc), len: 0 }\n    }\n\n    /// Tries to construct a new, empty `Vec<T, A>` with at least the specified capacity\n    /// with the provided allocator.\n    ///\n    /// The vector will be able to hold at least `capacity` elements without\n    /// reallocating. This method is allowed to allocate for more elements than\n    /// `capacity`. If `capacity` is 0, the vector will not allocate.\n    ///\n    /// It is important to note that although the returned vector has the\n    /// minimum *capacity* specified, the vector will have a zero *length*. For\n    /// an explanation of the difference between length and capacity, see\n    /// *[Capacity and reallocation]*.\n    ///\n    /// If it is important to know the exact allocated capacity of a `Vec`,\n    /// always use the [`capacity`] method after construction.\n    ///\n    /// For `Vec<T, A>` where `T` is a zero-sized type, there will be no allocation\n    /// and the capacity will always be `usize::MAX`.\n    ///\n    /// [Capacity and reallocation]: #capacity-and-reallocation\n    /// [`capacity`]: Vec::capacity\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(allocator_api)]\n    ///\n    /// use std::alloc::System;\n    ///\n    /// let mut vec = Vec::try_with_capacity_in(10, System).unwrap();\n    ///\n    /// // The vector contains no items, even though it has capacity for more\n    /// assert_eq!(vec.len(), 0);\n    /// assert!(vec.capacity() >= 10);\n    ///\n    /// // These are all done without reallocating...\n    /// for i in 0..10 {\n    ///     vec.push(i);\n    /// }\n    /// assert_eq!(vec.len(), 10);\n    /// assert!(vec.capacity() >= 10);\n    ///\n    /// // ...but this may make the vector reallocate\n    /// vec.push(11);\n    /// assert_eq!(vec.len(), 11);\n    /// assert!(vec.capacity() >= 11);\n    ///\n    /// let mut result = Vec::try_with_capacity_in(usize::MAX, System);\n    /// assert!(result.is_err());\n    ///\n    /// // A vector of a zero-sized type will always over-allocate, since no\n    /// // allocation is necessary\n    /// let vec_units = Vec::<(), System>::try_with_capacity_in(10, System).unwrap();\n    /// assert_eq!(vec_units.capacity(), usize::MAX);\n    /// ```\n    #[inline]\n    #[stable(feature = \"kernel\", since = \"1.0.0\")]\n    pub fn try_with_capacity_in(capacity: usize, alloc: A) -> Result<Self, TryReserveError> {\n        Ok(Vec { buf: RawVec::try_with_capacity_in(capacity, alloc)?, len: 0 })\n    }\n\n    /// Creates a `Vec<T, A>` directly from a pointer, a capacity, a length,\n    /// and an allocator.\n    ///\n    /// # Safety\n    ///\n    /// This is highly unsafe, due to the number of invariants that aren't\n    /// checked:\n    ///\n    /// * `ptr` must be [*currently allocated*] via the given allocator `alloc`.\n    /// * `T` needs to have the same alignment as what `ptr` was allocated with.\n    ///   (`T` having a less strict alignment is not sufficient, the alignment really\n    ///   needs to be equal to satisfy the [`dealloc`] requirement that memory must be\n    ///   allocated and deallocated with the same layout.)\n    /// * The size of `T` times the `capacity` (ie. the allocated size in bytes) needs\n    ///   to be the same size as the pointer was allocated with. (Because similar to\n    ///   alignment, [`dealloc`] must be called with the same layout `size`.)\n    /// * `length` needs to be less than or equal to `capacity`.\n    /// * The first `length` values must be properly initialized values of type `T`.\n    /// * `capacity` needs to [*fit*] the layout size that the pointer was allocated with.\n    /// * The allocated size in bytes must be no larger than `isize::MAX`.\n    ///   See the safety documentation of [`pointer::offset`].\n    ///\n    /// These requirements are always upheld by any `ptr` that has been allocated\n    /// via `Vec<T, A>`. Other allocation sources are allowed if the invariants are\n    /// upheld.\n    ///\n    /// Violating these may cause problems like corrupting the allocator's\n    /// internal data structures. For example it is **not** safe\n    /// to build a `Vec<u8>` from a pointer to a C `char` array with length `size_t`.\n    /// It's also not safe to build one from a `Vec<u16>` and its length, because\n    /// the allocator cares about the alignment, and these two types have different\n    /// alignments. The buffer was allocated with alignment 2 (for `u16`), but after\n    /// turning it into a `Vec<u8>` it'll be deallocated with alignment 1.\n    ///\n    /// The ownership of `ptr` is effectively transferred to the\n    /// `Vec<T>` which may then deallocate, reallocate or change the\n    /// contents of memory pointed to by the pointer at will. Ensure\n    /// that nothing else uses the pointer after calling this\n    /// function.\n    ///\n    /// [`String`]: crate::string::String\n    /// [`dealloc`]: crate::alloc::GlobalAlloc::dealloc\n    /// [*currently allocated*]: crate::alloc::Allocator#currently-allocated-memory\n    /// [*fit*]: crate::alloc::Allocator#memory-fitting\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(allocator_api)]\n    ///\n    /// use std::alloc::System;\n    ///\n    /// use std::ptr;\n    /// use std::mem;\n    ///\n    /// let mut v = Vec::with_capacity_in(3, System);\n    /// v.push(1);\n    /// v.push(2);\n    /// v.push(3);\n    ///\n    // FIXME Update this when vec_into_raw_parts is stabilized\n    /// // Prevent running `v`'s destructor so we are in complete control\n    /// // of the allocation.\n    /// let mut v = mem::ManuallyDrop::new(v);\n    ///\n    /// // Pull out the various important pieces of information about `v`\n    /// let p = v.as_mut_ptr();\n    /// let len = v.len();\n    /// let cap = v.capacity();\n    /// let alloc = v.allocator();\n    ///\n    /// unsafe {\n    ///     // Overwrite memory with 4, 5, 6\n    ///     for i in 0..len {\n    ///         ptr::write(p.add(i), 4 + i);\n    ///     }\n    ///\n    ///     // Put everything back together into a Vec\n    ///     let rebuilt = Vec::from_raw_parts_in(p, len, cap, alloc.clone());\n    ///     assert_eq!(rebuilt, [4, 5, 6]);\n    /// }\n    /// ```\n    ///\n    /// Using memory that was allocated elsewhere:\n    ///\n    /// ```rust\n    /// use std::alloc::{alloc, Layout};\n    ///\n    /// fn main() {\n    ///     let layout = Layout::array::<u32>(16).expect(\"overflow cannot happen\");\n    ///     let vec = unsafe {\n    ///         let mem = alloc(layout).cast::<u32>();\n    ///         if mem.is_null() {\n    ///             return;\n    ///         }\n    ///\n    ///         mem.write(1_000_000);\n    ///\n    ///         Vec::from_raw_parts(mem, 1, 16)\n    ///     };\n    ///\n    ///     assert_eq!(vec, &[1_000_000]);\n    ///     assert_eq!(vec.capacity(), 16);\n    /// }\n    /// ```\n    #[inline]\n    #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n    pub unsafe fn from_raw_parts_in(ptr: *mut T, length: usize, capacity: usize, alloc: A) -> Self {\n        unsafe { Vec { buf: RawVec::from_raw_parts_in(ptr, capacity, alloc), len: length } }\n    }\n\n    /// Decomposes a `Vec<T>` into its raw components.\n    ///\n    /// Returns the raw pointer to the underlying data, the length of\n    /// the vector (in elements), and the allocated capacity of the\n    /// data (in elements). These are the same arguments in the same\n    /// order as the arguments to [`from_raw_parts`].\n    ///\n    /// After calling this function, the caller is responsible for the\n    /// memory previously managed by the `Vec`. The only way to do\n    /// this is to convert the raw pointer, length, and capacity back\n    /// into a `Vec` with the [`from_raw_parts`] function, allowing\n    /// the destructor to perform the cleanup.\n    ///\n    /// [`from_raw_parts`]: Vec::from_raw_parts\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(vec_into_raw_parts)]\n    /// let v: Vec<i32> = vec![-1, 0, 1];\n    ///\n    /// let (ptr, len, cap) = v.into_raw_parts();\n    ///\n    /// let rebuilt = unsafe {\n    ///     // We can now make changes to the components, such as\n    ///     // transmuting the raw pointer to a compatible type.\n    ///     let ptr = ptr as *mut u32;\n    ///\n    ///     Vec::from_raw_parts(ptr, len, cap)\n    /// };\n    /// assert_eq!(rebuilt, [4294967295, 0, 1]);\n    /// ```\n    #[unstable(feature = \"vec_into_raw_parts\", reason = \"new API\", issue = \"65816\")]\n    pub fn into_raw_parts(self) -> (*mut T, usize, usize) {\n        let mut me = ManuallyDrop::new(self);\n        (me.as_mut_ptr(), me.len(), me.capacity())\n    }\n\n    /// Decomposes a `Vec<T>` into its raw components.\n    ///\n    /// Returns the raw pointer to the underlying data, the length of the vector (in elements),\n    /// the allocated capacity of the data (in elements), and the allocator. These are the same\n    /// arguments in the same order as the arguments to [`from_raw_parts_in`].\n    ///\n    /// After calling this function, the caller is responsible for the\n    /// memory previously managed by the `Vec`. The only way to do\n    /// this is to convert the raw pointer, length, and capacity back\n    /// into a `Vec` with the [`from_raw_parts_in`] function, allowing\n    /// the destructor to perform the cleanup.\n    ///\n    /// [`from_raw_parts_in`]: Vec::from_raw_parts_in\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(allocator_api, vec_into_raw_parts)]\n    ///\n    /// use std::alloc::System;\n    ///\n    /// let mut v: Vec<i32, System> = Vec::new_in(System);\n    /// v.push(-1);\n    /// v.push(0);\n    /// v.push(1);\n    ///\n    /// let (ptr, len, cap, alloc) = v.into_raw_parts_with_alloc();\n    ///\n    /// let rebuilt = unsafe {\n    ///     // We can now make changes to the components, such as\n    ///     // transmuting the raw pointer to a compatible type.\n    ///     let ptr = ptr as *mut u32;\n    ///\n    ///     Vec::from_raw_parts_in(ptr, len, cap, alloc)\n    /// };\n    /// assert_eq!(rebuilt, [4294967295, 0, 1]);\n    /// ```\n    #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n    // #[unstable(feature = \"vec_into_raw_parts\", reason = \"new API\", issue = \"65816\")]\n    pub fn into_raw_parts_with_alloc(self) -> (*mut T, usize, usize, A) {\n        let mut me = ManuallyDrop::new(self);\n        let len = me.len();\n        let capacity = me.capacity();\n        let ptr = me.as_mut_ptr();\n        let alloc = unsafe { ptr::read(me.allocator()) };\n        (ptr, len, capacity, alloc)\n    }\n\n    /// Returns the total number of elements the vector can hold without\n    /// reallocating.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut vec: Vec<i32> = Vec::with_capacity(10);\n    /// vec.push(42);\n    /// assert!(vec.capacity() >= 10);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn capacity(&self) -> usize {\n        self.buf.capacity()\n    }\n\n    /// Reserves capacity for at least `additional` more elements to be inserted\n    /// in the given `Vec<T>`. The collection may reserve more space to\n    /// speculatively avoid frequent reallocations. After calling `reserve`,\n    /// capacity will be greater than or equal to `self.len() + additional`.\n    /// Does nothing if capacity is already sufficient.\n    ///\n    /// # Panics\n    ///\n    /// Panics if the new capacity exceeds `isize::MAX` bytes.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut vec = vec![1];\n    /// vec.reserve(10);\n    /// assert!(vec.capacity() >= 11);\n    /// ```\n    #[cfg(not(no_global_oom_handling))]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn reserve(&mut self, additional: usize) {\n        self.buf.reserve(self.len, additional);\n    }\n\n    /// Reserves the minimum capacity for at least `additional` more elements to\n    /// be inserted in the given `Vec<T>`. Unlike [`reserve`], this will not\n    /// deliberately over-allocate to speculatively avoid frequent allocations.\n    /// After calling `reserve_exact`, capacity will be greater than or equal to\n    /// `self.len() + additional`. Does nothing if the capacity is already\n    /// sufficient.\n    ///\n    /// Note that the allocator may give the collection more space than it\n    /// requests. Therefore, capacity can not be relied upon to be precisely\n    /// minimal. Prefer [`reserve`] if future insertions are expected.\n    ///\n    /// [`reserve`]: Vec::reserve\n    ///\n    /// # Panics\n    ///\n    /// Panics if the new capacity exceeds `isize::MAX` bytes.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut vec = vec![1];\n    /// vec.reserve_exact(10);\n    /// assert!(vec.capacity() >= 11);\n    /// ```\n    #[cfg(not(no_global_oom_handling))]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn reserve_exact(&mut self, additional: usize) {\n        self.buf.reserve_exact(self.len, additional);\n    }\n\n    /// Tries to reserve capacity for at least `additional` more elements to be inserted\n    /// in the given `Vec<T>`. The collection may reserve more space to speculatively avoid\n    /// frequent reallocations. After calling `try_reserve`, capacity will be\n    /// greater than or equal to `self.len() + additional` if it returns\n    /// `Ok(())`. Does nothing if capacity is already sufficient. This method\n    /// preserves the contents even if an error occurs.\n    ///\n    /// # Errors\n    ///\n    /// If the capacity overflows, or the allocator reports a failure, then an error\n    /// is returned.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::TryReserveError;\n    ///\n    /// fn process_data(data: &[u32]) -> Result<Vec<u32>, TryReserveError> {\n    ///     let mut output = Vec::new();\n    ///\n    ///     // Pre-reserve the memory, exiting if we can't\n    ///     output.try_reserve(data.len())?;\n    ///\n    ///     // Now we know this can't OOM in the middle of our complex work\n    ///     output.extend(data.iter().map(|&val| {\n    ///         val * 2 + 5 // very complicated\n    ///     }));\n    ///\n    ///     Ok(output)\n    /// }\n    /// # process_data(&[1, 2, 3]).expect(\"why is the test harness OOMing on 12 bytes?\");\n    /// ```\n    #[stable(feature = \"try_reserve\", since = \"1.57.0\")]\n    pub fn try_reserve(&mut self, additional: usize) -> Result<(), TryReserveError> {\n        self.buf.try_reserve(self.len, additional)\n    }\n\n    /// Tries to reserve the minimum capacity for at least `additional`\n    /// elements to be inserted in the given `Vec<T>`. Unlike [`try_reserve`],\n    /// this will not deliberately over-allocate to speculatively avoid frequent\n    /// allocations. After calling `try_reserve_exact`, capacity will be greater\n    /// than or equal to `self.len() + additional` if it returns `Ok(())`.\n    /// Does nothing if the capacity is already sufficient.\n    ///\n    /// Note that the allocator may give the collection more space than it\n    /// requests. Therefore, capacity can not be relied upon to be precisely\n    /// minimal. Prefer [`try_reserve`] if future insertions are expected.\n    ///\n    /// [`try_reserve`]: Vec::try_reserve\n    ///\n    /// # Errors\n    ///\n    /// If the capacity overflows, or the allocator reports a failure, then an error\n    /// is returned.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::collections::TryReserveError;\n    ///\n    /// fn process_data(data: &[u32]) -> Result<Vec<u32>, TryReserveError> {\n    ///     let mut output = Vec::new();\n    ///\n    ///     // Pre-reserve the memory, exiting if we can't\n    ///     output.try_reserve_exact(data.len())?;\n    ///\n    ///     // Now we know this can't OOM in the middle of our complex work\n    ///     output.extend(data.iter().map(|&val| {\n    ///         val * 2 + 5 // very complicated\n    ///     }));\n    ///\n    ///     Ok(output)\n    /// }\n    /// # process_data(&[1, 2, 3]).expect(\"why is the test harness OOMing on 12 bytes?\");\n    /// ```\n    #[stable(feature = \"try_reserve\", since = \"1.57.0\")]\n    pub fn try_reserve_exact(&mut self, additional: usize) -> Result<(), TryReserveError> {\n        self.buf.try_reserve_exact(self.len, additional)\n    }\n\n    /// Shrinks the capacity of the vector as much as possible.\n    ///\n    /// It will drop down as close as possible to the length but the allocator\n    /// may still inform the vector that there is space for a few more elements.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut vec = Vec::with_capacity(10);\n    /// vec.extend([1, 2, 3]);\n    /// assert!(vec.capacity() >= 10);\n    /// vec.shrink_to_fit();\n    /// assert!(vec.capacity() >= 3);\n    /// ```\n    #[cfg(not(no_global_oom_handling))]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn shrink_to_fit(&mut self) {\n        // The capacity is never less than the length, and there's nothing to do when\n        // they are equal, so we can avoid the panic case in `RawVec::shrink_to_fit`\n        // by only calling it with a greater capacity.\n        if self.capacity() > self.len {\n            self.buf.shrink_to_fit(self.len);\n        }\n    }\n\n    /// Shrinks the capacity of the vector with a lower bound.\n    ///\n    /// The capacity will remain at least as large as both the length\n    /// and the supplied value.\n    ///\n    /// If the current capacity is less than the lower limit, this is a no-op.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut vec = Vec::with_capacity(10);\n    /// vec.extend([1, 2, 3]);\n    /// assert!(vec.capacity() >= 10);\n    /// vec.shrink_to(4);\n    /// assert!(vec.capacity() >= 4);\n    /// vec.shrink_to(0);\n    /// assert!(vec.capacity() >= 3);\n    /// ```\n    #[cfg(not(no_global_oom_handling))]\n    #[stable(feature = \"shrink_to\", since = \"1.56.0\")]\n    pub fn shrink_to(&mut self, min_capacity: usize) {\n        if self.capacity() > min_capacity {\n            self.buf.shrink_to_fit(cmp::max(self.len, min_capacity));\n        }\n    }\n\n    /// Converts the vector into [`Box<[T]>`][owned slice].\n    ///\n    /// If the vector has excess capacity, its items will be moved into a\n    /// newly-allocated buffer with exactly the right capacity.\n    ///\n    /// [owned slice]: Box\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let v = vec![1, 2, 3];\n    ///\n    /// let slice = v.into_boxed_slice();\n    /// ```\n    ///\n    /// Any excess capacity is removed:\n    ///\n    /// ```\n    /// let mut vec = Vec::with_capacity(10);\n    /// vec.extend([1, 2, 3]);\n    ///\n    /// assert!(vec.capacity() >= 10);\n    /// let slice = vec.into_boxed_slice();\n    /// assert_eq!(slice.into_vec().capacity(), 3);\n    /// ```\n    #[cfg(not(no_global_oom_handling))]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn into_boxed_slice(mut self) -> Box<[T], A> {\n        unsafe {\n            self.shrink_to_fit();\n            let me = ManuallyDrop::new(self);\n            let buf = ptr::read(&me.buf);\n            let len = me.len();\n            buf.into_box(len).assume_init()\n        }\n    }\n\n    /// Shortens the vector, keeping the first `len` elements and dropping\n    /// the rest.\n    ///\n    /// If `len` is greater than the vector's current length, this has no\n    /// effect.\n    ///\n    /// The [`drain`] method can emulate `truncate`, but causes the excess\n    /// elements to be returned instead of dropped.\n    ///\n    /// Note that this method has no effect on the allocated capacity\n    /// of the vector.\n    ///\n    /// # Examples\n    ///\n    /// Truncating a five element vector to two elements:\n    ///\n    /// ```\n    /// let mut vec = vec![1, 2, 3, 4, 5];\n    /// vec.truncate(2);\n    /// assert_eq!(vec, [1, 2]);\n    /// ```\n    ///\n    /// No truncation occurs when `len` is greater than the vector's current\n    /// length:\n    ///\n    /// ```\n    /// let mut vec = vec![1, 2, 3];\n    /// vec.truncate(8);\n    /// assert_eq!(vec, [1, 2, 3]);\n    /// ```\n    ///\n    /// Truncating when `len == 0` is equivalent to calling the [`clear`]\n    /// method.\n    ///\n    /// ```\n    /// let mut vec = vec![1, 2, 3];\n    /// vec.truncate(0);\n    /// assert_eq!(vec, []);\n    /// ```\n    ///\n    /// [`clear`]: Vec::clear\n    /// [`drain`]: Vec::drain\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn truncate(&mut self, len: usize) {\n        // This is safe because:\n        //\n        // * the slice passed to `drop_in_place` is valid; the `len > self.len`\n        //   case avoids creating an invalid slice, and\n        // * the `len` of the vector is shrunk before calling `drop_in_place`,\n        //   such that no value will be dropped twice in case `drop_in_place`\n        //   were to panic once (if it panics twice, the program aborts).\n        unsafe {\n            // Note: It's intentional that this is `>` and not `>=`.\n            //       Changing it to `>=` has negative performance\n            //       implications in some cases. See #78884 for more.\n            if len > self.len {\n                return;\n            }\n            let remaining_len = self.len - len;\n            let s = ptr::slice_from_raw_parts_mut(self.as_mut_ptr().add(len), remaining_len);\n            self.len = len;\n            ptr::drop_in_place(s);\n        }\n    }\n\n    /// Extracts a slice containing the entire vector.\n    ///\n    /// Equivalent to `&s[..]`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::io::{self, Write};\n    /// let buffer = vec![1, 2, 3, 5, 8];\n    /// io::sink().write(buffer.as_slice()).unwrap();\n    /// ```\n    #[inline]\n    #[stable(feature = \"vec_as_slice\", since = \"1.7.0\")]\n    pub fn as_slice(&self) -> &[T] {\n        self\n    }\n\n    /// Extracts a mutable slice of the entire vector.\n    ///\n    /// Equivalent to `&mut s[..]`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::io::{self, Read};\n    /// let mut buffer = vec![0; 3];\n    /// io::repeat(0b101).read_exact(buffer.as_mut_slice()).unwrap();\n    /// ```\n    #[inline]\n    #[stable(feature = \"vec_as_slice\", since = \"1.7.0\")]\n    pub fn as_mut_slice(&mut self) -> &mut [T] {\n        self\n    }\n\n    /// Returns a raw pointer to the vector's buffer, or a dangling raw pointer\n    /// valid for zero sized reads if the vector didn't allocate.\n    ///\n    /// The caller must ensure that the vector outlives the pointer this\n    /// function returns, or else it will end up pointing to garbage.\n    /// Modifying the vector may cause its buffer to be reallocated,\n    /// which would also make any pointers to it invalid.\n    ///\n    /// The caller must also ensure that the memory the pointer (non-transitively) points to\n    /// is never written to (except inside an `UnsafeCell`) using this pointer or any pointer\n    /// derived from it. If you need to mutate the contents of the slice, use [`as_mut_ptr`].\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let x = vec![1, 2, 4];\n    /// let x_ptr = x.as_ptr();\n    ///\n    /// unsafe {\n    ///     for i in 0..x.len() {\n    ///         assert_eq!(*x_ptr.add(i), 1 << i);\n    ///     }\n    /// }\n    /// ```\n    ///\n    /// [`as_mut_ptr`]: Vec::as_mut_ptr\n    #[stable(feature = \"vec_as_ptr\", since = \"1.37.0\")]\n    #[inline]\n    pub fn as_ptr(&self) -> *const T {\n        // We shadow the slice method of the same name to avoid going through\n        // `deref`, which creates an intermediate reference.\n        self.buf.ptr()\n    }\n\n    /// Returns an unsafe mutable pointer to the vector's buffer, or a dangling\n    /// raw pointer valid for zero sized reads if the vector didn't allocate.\n    ///\n    /// The caller must ensure that the vector outlives the pointer this\n    /// function returns, or else it will end up pointing to garbage.\n    /// Modifying the vector may cause its buffer to be reallocated,\n    /// which would also make any pointers to it invalid.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// // Allocate vector big enough for 4 elements.\n    /// let size = 4;\n    /// let mut x: Vec<i32> = Vec::with_capacity(size);\n    /// let x_ptr = x.as_mut_ptr();\n    ///\n    /// // Initialize elements via raw pointer writes, then set length.\n    /// unsafe {\n    ///     for i in 0..size {\n    ///         *x_ptr.add(i) = i as i32;\n    ///     }\n    ///     x.set_len(size);\n    /// }\n    /// assert_eq!(&*x, &[0, 1, 2, 3]);\n    /// ```\n    #[stable(feature = \"vec_as_ptr\", since = \"1.37.0\")]\n    #[inline]\n    pub fn as_mut_ptr(&mut self) -> *mut T {\n        // We shadow the slice method of the same name to avoid going through\n        // `deref_mut`, which creates an intermediate reference.\n        self.buf.ptr()\n    }\n\n    /// Returns a reference to the underlying allocator.\n    #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n    #[inline]\n    pub fn allocator(&self) -> &A {\n        self.buf.allocator()\n    }\n\n    /// Forces the length of the vector to `new_len`.\n    ///\n    /// This is a low-level operation that maintains none of the normal\n    /// invariants of the type. Normally changing the length of a vector\n    /// is done using one of the safe operations instead, such as\n    /// [`truncate`], [`resize`], [`extend`], or [`clear`].\n    ///\n    /// [`truncate`]: Vec::truncate\n    /// [`resize`]: Vec::resize\n    /// [`extend`]: Extend::extend\n    /// [`clear`]: Vec::clear\n    ///\n    /// # Safety\n    ///\n    /// - `new_len` must be less than or equal to [`capacity()`].\n    /// - The elements at `old_len..new_len` must be initialized.\n    ///\n    /// [`capacity()`]: Vec::capacity\n    ///\n    /// # Examples\n    ///\n    /// This method can be useful for situations in which the vector\n    /// is serving as a buffer for other code, particularly over FFI:\n    ///\n    /// ```no_run\n    /// # #![allow(dead_code)]\n    /// # // This is just a minimal skeleton for the doc example;\n    /// # // don't use this as a starting point for a real library.\n    /// # pub struct StreamWrapper { strm: *mut std::ffi::c_void }\n    /// # const Z_OK: i32 = 0;\n    /// # extern \"C\" {\n    /// #     fn deflateGetDictionary(\n    /// #         strm: *mut std::ffi::c_void,\n    /// #         dictionary: *mut u8,\n    /// #         dictLength: *mut usize,\n    /// #     ) -> i32;\n    /// # }\n    /// # impl StreamWrapper {\n    /// pub fn get_dictionary(&self) -> Option<Vec<u8>> {\n    ///     // Per the FFI method's docs, \"32768 bytes is always enough\".\n    ///     let mut dict = Vec::with_capacity(32_768);\n    ///     let mut dict_length = 0;\n    ///     // SAFETY: When `deflateGetDictionary` returns `Z_OK`, it holds that:\n    ///     // 1. `dict_length` elements were initialized.\n    ///     // 2. `dict_length` <= the capacity (32_768)\n    ///     // which makes `set_len` safe to call.\n    ///     unsafe {\n    ///         // Make the FFI call...\n    ///         let r = deflateGetDictionary(self.strm, dict.as_mut_ptr(), &mut dict_length);\n    ///         if r == Z_OK {\n    ///             // ...and update the length to what was initialized.\n    ///             dict.set_len(dict_length);\n    ///             Some(dict)\n    ///         } else {\n    ///             None\n    ///         }\n    ///     }\n    /// }\n    /// # }\n    /// ```\n    ///\n    /// While the following example is sound, there is a memory leak since\n    /// the inner vectors were not freed prior to the `set_len` call:\n    ///\n    /// ```\n    /// let mut vec = vec![vec![1, 0, 0],\n    ///                    vec![0, 1, 0],\n    ///                    vec![0, 0, 1]];\n    /// // SAFETY:\n    /// // 1. `old_len..0` is empty so no elements need to be initialized.\n    /// // 2. `0 <= capacity` always holds whatever `capacity` is.\n    /// unsafe {\n    ///     vec.set_len(0);\n    /// }\n    /// ```\n    ///\n    /// Normally, here, one would use [`clear`] instead to correctly drop\n    /// the contents and thus not leak memory.\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub unsafe fn set_len(&mut self, new_len: usize) {\n        debug_assert!(new_len <= self.capacity());\n\n        self.len = new_len;\n    }\n\n    /// Removes an element from the vector and returns it.\n    ///\n    /// The removed element is replaced by the last element of the vector.\n    ///\n    /// This does not preserve ordering, but is *O*(1).\n    /// If you need to preserve the element order, use [`remove`] instead.\n    ///\n    /// [`remove`]: Vec::remove\n    ///\n    /// # Panics\n    ///\n    /// Panics if `index` is out of bounds.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut v = vec![\"foo\", \"bar\", \"baz\", \"qux\"];\n    ///\n    /// assert_eq!(v.swap_remove(1), \"bar\");\n    /// assert_eq!(v, [\"foo\", \"qux\", \"baz\"]);\n    ///\n    /// assert_eq!(v.swap_remove(0), \"foo\");\n    /// assert_eq!(v, [\"baz\", \"qux\"]);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn swap_remove(&mut self, index: usize) -> T {\n        #[cold]\n        #[inline(never)]\n        fn assert_failed(index: usize, len: usize) -> ! {\n            panic!(\"swap_remove index (is {index}) should be < len (is {len})\");\n        }\n\n        let len = self.len();\n        if index >= len {\n            assert_failed(index, len);\n        }\n        unsafe {\n            // We replace self[index] with the last element. Note that if the\n            // bounds check above succeeds there must be a last element (which\n            // can be self[index] itself).\n            let value = ptr::read(self.as_ptr().add(index));\n            let base_ptr = self.as_mut_ptr();\n            ptr::copy(base_ptr.add(len - 1), base_ptr.add(index), 1);\n            self.set_len(len - 1);\n            value\n        }\n    }\n\n    /// Inserts an element at position `index` within the vector, shifting all\n    /// elements after it to the right.\n    ///\n    /// # Panics\n    ///\n    /// Panics if `index > len`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut vec = vec![1, 2, 3];\n    /// vec.insert(1, 4);\n    /// assert_eq!(vec, [1, 4, 2, 3]);\n    /// vec.insert(4, 5);\n    /// assert_eq!(vec, [1, 4, 2, 3, 5]);\n    /// ```\n    #[cfg(not(no_global_oom_handling))]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn insert(&mut self, index: usize, element: T) {\n        #[cold]\n        #[inline(never)]\n        fn assert_failed(index: usize, len: usize) -> ! {\n            panic!(\"insertion index (is {index}) should be <= len (is {len})\");\n        }\n\n        let len = self.len();\n\n        // space for the new element\n        if len == self.buf.capacity() {\n            self.reserve(1);\n        }\n\n        unsafe {\n            // infallible\n            // The spot to put the new value\n            {\n                let p = self.as_mut_ptr().add(index);\n                if index < len {\n                    // Shift everything over to make space. (Duplicating the\n                    // `index`th element into two consecutive places.)\n                    ptr::copy(p, p.add(1), len - index);\n                } else if index == len {\n                    // No elements need shifting.\n                } else {\n                    assert_failed(index, len);\n                }\n                // Write it in, overwriting the first copy of the `index`th\n                // element.\n                ptr::write(p, element);\n            }\n            self.set_len(len + 1);\n        }\n    }\n\n    /// Removes and returns the element at position `index` within the vector,\n    /// shifting all elements after it to the left.\n    ///\n    /// Note: Because this shifts over the remaining elements, it has a\n    /// worst-case performance of *O*(*n*). If you don't need the order of elements\n    /// to be preserved, use [`swap_remove`] instead. If you'd like to remove\n    /// elements from the beginning of the `Vec`, consider using\n    /// [`VecDeque::pop_front`] instead.\n    ///\n    /// [`swap_remove`]: Vec::swap_remove\n    /// [`VecDeque::pop_front`]: crate::collections::VecDeque::pop_front\n    ///\n    /// # Panics\n    ///\n    /// Panics if `index` is out of bounds.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut v = vec![1, 2, 3];\n    /// assert_eq!(v.remove(1), 2);\n    /// assert_eq!(v, [1, 3]);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[track_caller]\n    pub fn remove(&mut self, index: usize) -> T {\n        #[cold]\n        #[inline(never)]\n        #[track_caller]\n        fn assert_failed(index: usize, len: usize) -> ! {\n            panic!(\"removal index (is {index}) should be < len (is {len})\");\n        }\n\n        let len = self.len();\n        if index >= len {\n            assert_failed(index, len);\n        }\n        unsafe {\n            // infallible\n            let ret;\n            {\n                // the place we are taking from.\n                let ptr = self.as_mut_ptr().add(index);\n                // copy it out, unsafely having a copy of the value on\n                // the stack and in the vector at the same time.\n                ret = ptr::read(ptr);\n\n                // Shift everything down to fill in that spot.\n                ptr::copy(ptr.add(1), ptr, len - index - 1);\n            }\n            self.set_len(len - 1);\n            ret\n        }\n    }\n\n    /// Retains only the elements specified by the predicate.\n    ///\n    /// In other words, remove all elements `e` for which `f(&e)` returns `false`.\n    /// This method operates in place, visiting each element exactly once in the\n    /// original order, and preserves the order of the retained elements.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut vec = vec![1, 2, 3, 4];\n    /// vec.retain(|&x| x % 2 == 0);\n    /// assert_eq!(vec, [2, 4]);\n    /// ```\n    ///\n    /// Because the elements are visited exactly once in the original order,\n    /// external state may be used to decide which elements to keep.\n    ///\n    /// ```\n    /// let mut vec = vec![1, 2, 3, 4, 5];\n    /// let keep = [false, true, true, false, true];\n    /// let mut iter = keep.iter();\n    /// vec.retain(|_| *iter.next().unwrap());\n    /// assert_eq!(vec, [2, 3, 5]);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn retain<F>(&mut self, mut f: F)\n    where\n        F: FnMut(&T) -> bool,\n    {\n        self.retain_mut(|elem| f(elem));\n    }\n\n    /// Retains only the elements specified by the predicate, passing a mutable reference to it.\n    ///\n    /// In other words, remove all elements `e` such that `f(&mut e)` returns `false`.\n    /// This method operates in place, visiting each element exactly once in the\n    /// original order, and preserves the order of the retained elements.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut vec = vec![1, 2, 3, 4];\n    /// vec.retain_mut(|x| if *x <= 3 {\n    ///     *x += 1;\n    ///     true\n    /// } else {\n    ///     false\n    /// });\n    /// assert_eq!(vec, [2, 3, 4]);\n    /// ```\n    #[stable(feature = \"vec_retain_mut\", since = \"1.61.0\")]\n    pub fn retain_mut<F>(&mut self, mut f: F)\n    where\n        F: FnMut(&mut T) -> bool,\n    {\n        let original_len = self.len();\n        // Avoid double drop if the drop guard is not executed,\n        // since we may make some holes during the process.\n        unsafe { self.set_len(0) };\n\n        // Vec: [Kept, Kept, Hole, Hole, Hole, Hole, Unchecked, Unchecked]\n        //      |<-              processed len   ->| ^- next to check\n        //                  |<-  deleted cnt     ->|\n        //      |<-              original_len                          ->|\n        // Kept: Elements which predicate returns true on.\n        // Hole: Moved or dropped element slot.\n        // Unchecked: Unchecked valid elements.\n        //\n        // This drop guard will be invoked when predicate or `drop` of element panicked.\n        // It shifts unchecked elements to cover holes and `set_len` to the correct length.\n        // In cases when predicate and `drop` never panick, it will be optimized out.\n        struct BackshiftOnDrop<'a, T, A: Allocator> {\n            v: &'a mut Vec<T, A>,\n            processed_len: usize,\n            deleted_cnt: usize,\n            original_len: usize,\n        }\n\n        impl<T, A: Allocator> Drop for BackshiftOnDrop<'_, T, A> {\n            fn drop(&mut self) {\n                if self.deleted_cnt > 0 {\n                    // SAFETY: Trailing unchecked items must be valid since we never touch them.\n                    unsafe {\n                        ptr::copy(\n                            self.v.as_ptr().add(self.processed_len),\n                            self.v.as_mut_ptr().add(self.processed_len - self.deleted_cnt),\n                            self.original_len - self.processed_len,\n                        );\n                    }\n                }\n                // SAFETY: After filling holes, all items are in contiguous memory.\n                unsafe {\n                    self.v.set_len(self.original_len - self.deleted_cnt);\n                }\n            }\n        }\n\n        let mut g = BackshiftOnDrop { v: self, processed_len: 0, deleted_cnt: 0, original_len };\n\n        fn process_loop<F, T, A: Allocator, const DELETED: bool>(\n            original_len: usize,\n            f: &mut F,\n            g: &mut BackshiftOnDrop<'_, T, A>,\n        ) where\n            F: FnMut(&mut T) -> bool,\n        {\n            while g.processed_len != original_len {\n                // SAFETY: Unchecked element must be valid.\n                let cur = unsafe { &mut *g.v.as_mut_ptr().add(g.processed_len) };\n                if !f(cur) {\n                    // Advance early to avoid double drop if `drop_in_place` panicked.\n                    g.processed_len += 1;\n                    g.deleted_cnt += 1;\n                    // SAFETY: We never touch this element again after dropped.\n                    unsafe { ptr::drop_in_place(cur) };\n                    // We already advanced the counter.\n                    if DELETED {\n                        continue;\n                    } else {\n                        break;\n                    }\n                }\n                if DELETED {\n                    // SAFETY: `deleted_cnt` > 0, so the hole slot must not overlap with current element.\n                    // We use copy for move, and never touch this element again.\n                    unsafe {\n                        let hole_slot = g.v.as_mut_ptr().add(g.processed_len - g.deleted_cnt);\n                        ptr::copy_nonoverlapping(cur, hole_slot, 1);\n                    }\n                }\n                g.processed_len += 1;\n            }\n        }\n\n        // Stage 1: Nothing was deleted.\n        process_loop::<F, T, A, false>(original_len, &mut f, &mut g);\n\n        // Stage 2: Some elements were deleted.\n        process_loop::<F, T, A, true>(original_len, &mut f, &mut g);\n\n        // All item are processed. This can be optimized to `set_len` by LLVM.\n        drop(g);\n    }\n\n    /// Removes all but the first of consecutive elements in the vector that resolve to the same\n    /// key.\n    ///\n    /// If the vector is sorted, this removes all duplicates.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut vec = vec![10, 20, 21, 30, 20];\n    ///\n    /// vec.dedup_by_key(|i| *i / 10);\n    ///\n    /// assert_eq!(vec, [10, 20, 30, 20]);\n    /// ```\n    #[stable(feature = \"dedup_by\", since = \"1.16.0\")]\n    #[inline]\n    pub fn dedup_by_key<F, K>(&mut self, mut key: F)\n    where\n        F: FnMut(&mut T) -> K,\n        K: PartialEq,\n    {\n        self.dedup_by(|a, b| key(a) == key(b))\n    }\n\n    /// Removes all but the first of consecutive elements in the vector satisfying a given equality\n    /// relation.\n    ///\n    /// The `same_bucket` function is passed references to two elements from the vector and\n    /// must determine if the elements compare equal. The elements are passed in opposite order\n    /// from their order in the slice, so if `same_bucket(a, b)` returns `true`, `a` is removed.\n    ///\n    /// If the vector is sorted, this removes all duplicates.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut vec = vec![\"foo\", \"bar\", \"Bar\", \"baz\", \"bar\"];\n    ///\n    /// vec.dedup_by(|a, b| a.eq_ignore_ascii_case(b));\n    ///\n    /// assert_eq!(vec, [\"foo\", \"bar\", \"baz\", \"bar\"]);\n    /// ```\n    #[stable(feature = \"dedup_by\", since = \"1.16.0\")]\n    pub fn dedup_by<F>(&mut self, mut same_bucket: F)\n    where\n        F: FnMut(&mut T, &mut T) -> bool,\n    {\n        let len = self.len();\n        if len <= 1 {\n            return;\n        }\n\n        /* INVARIANT: vec.len() > read >= write > write-1 >= 0 */\n        struct FillGapOnDrop<'a, T, A: core::alloc::Allocator> {\n            /* Offset of the element we want to check if it is duplicate */\n            read: usize,\n\n            /* Offset of the place where we want to place the non-duplicate\n             * when we find it. */\n            write: usize,\n\n            /* The Vec that would need correction if `same_bucket` panicked */\n            vec: &'a mut Vec<T, A>,\n        }\n\n        impl<'a, T, A: core::alloc::Allocator> Drop for FillGapOnDrop<'a, T, A> {\n            fn drop(&mut self) {\n                /* This code gets executed when `same_bucket` panics */\n\n                /* SAFETY: invariant guarantees that `read - write`\n                 * and `len - read` never overflow and that the copy is always\n                 * in-bounds. */\n                unsafe {\n                    let ptr = self.vec.as_mut_ptr();\n                    let len = self.vec.len();\n\n                    /* How many items were left when `same_bucket` panicked.\n                     * Basically vec[read..].len() */\n                    let items_left = len.wrapping_sub(self.read);\n\n                    /* Pointer to first item in vec[write..write+items_left] slice */\n                    let dropped_ptr = ptr.add(self.write);\n                    /* Pointer to first item in vec[read..] slice */\n                    let valid_ptr = ptr.add(self.read);\n\n                    /* Copy `vec[read..]` to `vec[write..write+items_left]`.\n                     * The slices can overlap, so `copy_nonoverlapping` cannot be used */\n                    ptr::copy(valid_ptr, dropped_ptr, items_left);\n\n                    /* How many items have been already dropped\n                     * Basically vec[read..write].len() */\n                    let dropped = self.read.wrapping_sub(self.write);\n\n                    self.vec.set_len(len - dropped);\n                }\n            }\n        }\n\n        let mut gap = FillGapOnDrop { read: 1, write: 1, vec: self };\n        let ptr = gap.vec.as_mut_ptr();\n\n        /* Drop items while going through Vec, it should be more efficient than\n         * doing slice partition_dedup + truncate */\n\n        /* SAFETY: Because of the invariant, read_ptr, prev_ptr and write_ptr\n         * are always in-bounds and read_ptr never aliases prev_ptr */\n        unsafe {\n            while gap.read < len {\n                let read_ptr = ptr.add(gap.read);\n                let prev_ptr = ptr.add(gap.write.wrapping_sub(1));\n\n                if same_bucket(&mut *read_ptr, &mut *prev_ptr) {\n                    // Increase `gap.read` now since the drop may panic.\n                    gap.read += 1;\n                    /* We have found duplicate, drop it in-place */\n                    ptr::drop_in_place(read_ptr);\n                } else {\n                    let write_ptr = ptr.add(gap.write);\n\n                    /* Because `read_ptr` can be equal to `write_ptr`, we either\n                     * have to use `copy` or conditional `copy_nonoverlapping`.\n                     * Looks like the first option is faster. */\n                    ptr::copy(read_ptr, write_ptr, 1);\n\n                    /* We have filled that place, so go further */\n                    gap.write += 1;\n                    gap.read += 1;\n                }\n            }\n\n            /* Technically we could let `gap` clean up with its Drop, but\n             * when `same_bucket` is guaranteed to not panic, this bloats a little\n             * the codegen, so we just do it manually */\n            gap.vec.set_len(gap.write);\n            mem::forget(gap);\n        }\n    }\n\n    /// Appends an element to the back of a collection.\n    ///\n    /// # Panics\n    ///\n    /// Panics if the new capacity exceeds `isize::MAX` bytes.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut vec = vec![1, 2];\n    /// vec.push(3);\n    /// assert_eq!(vec, [1, 2, 3]);\n    /// ```\n    #[cfg(not(no_global_oom_handling))]\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn push(&mut self, value: T) {\n        // This will panic or abort if we would allocate > isize::MAX bytes\n        // or if the length increment would overflow for zero-sized types.\n        if self.len == self.buf.capacity() {\n            self.buf.reserve_for_push(self.len);\n        }\n        unsafe {\n            let end = self.as_mut_ptr().add(self.len);\n            ptr::write(end, value);\n            self.len += 1;\n        }\n    }\n\n    /// Tries to append an element to the back of a collection.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut vec = vec![1, 2];\n    /// vec.try_push(3).unwrap();\n    /// assert_eq!(vec, [1, 2, 3]);\n    /// ```\n    #[inline]\n    #[stable(feature = \"kernel\", since = \"1.0.0\")]\n    pub fn try_push(&mut self, value: T) -> Result<(), TryReserveError> {\n        if self.len == self.buf.capacity() {\n            self.buf.try_reserve_for_push(self.len)?;\n        }\n        unsafe {\n            let end = self.as_mut_ptr().add(self.len);\n            ptr::write(end, value);\n            self.len += 1;\n        }\n        Ok(())\n    }\n\n    /// Appends an element if there is sufficient spare capacity, otherwise an error is returned\n    /// with the element.\n    ///\n    /// Unlike [`push`] this method will not reallocate when there's insufficient capacity.\n    /// The caller should use [`reserve`] or [`try_reserve`] to ensure that there is enough capacity.\n    ///\n    /// [`push`]: Vec::push\n    /// [`reserve`]: Vec::reserve\n    /// [`try_reserve`]: Vec::try_reserve\n    ///\n    /// # Examples\n    ///\n    /// A manual, panic-free alternative to [`FromIterator`]:\n    ///\n    /// ```\n    /// #![feature(vec_push_within_capacity)]\n    ///\n    /// use std::collections::TryReserveError;\n    /// fn from_iter_fallible<T>(iter: impl Iterator<Item=T>) -> Result<Vec<T>, TryReserveError> {\n    ///     let mut vec = Vec::new();\n    ///     for value in iter {\n    ///         if let Err(value) = vec.push_within_capacity(value) {\n    ///             vec.try_reserve(1)?;\n    ///             // this cannot fail, the previous line either returned or added at least 1 free slot\n    ///             let _ = vec.push_within_capacity(value);\n    ///         }\n    ///     }\n    ///     Ok(vec)\n    /// }\n    /// assert_eq!(from_iter_fallible(0..100), Ok(Vec::from_iter(0..100)));\n    /// ```\n    #[inline]\n    #[unstable(feature = \"vec_push_within_capacity\", issue = \"100486\")]\n    pub fn push_within_capacity(&mut self, value: T) -> Result<(), T> {\n        if self.len == self.buf.capacity() {\n            return Err(value);\n        }\n        unsafe {\n            let end = self.as_mut_ptr().add(self.len);\n            ptr::write(end, value);\n            self.len += 1;\n        }\n        Ok(())\n    }\n\n    /// Removes the last element from a vector and returns it, or [`None`] if it\n    /// is empty.\n    ///\n    /// If you'd like to pop the first element, consider using\n    /// [`VecDeque::pop_front`] instead.\n    ///\n    /// [`VecDeque::pop_front`]: crate::collections::VecDeque::pop_front\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut vec = vec![1, 2, 3];\n    /// assert_eq!(vec.pop(), Some(3));\n    /// assert_eq!(vec, [1, 2]);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn pop(&mut self) -> Option<T> {\n        if self.len == 0 {\n            None\n        } else {\n            unsafe {\n                self.len -= 1;\n                Some(ptr::read(self.as_ptr().add(self.len())))\n            }\n        }\n    }\n\n    /// Moves all the elements of `other` into `self`, leaving `other` empty.\n    ///\n    /// # Panics\n    ///\n    /// Panics if the new capacity exceeds `isize::MAX` bytes.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut vec = vec![1, 2, 3];\n    /// let mut vec2 = vec![4, 5, 6];\n    /// vec.append(&mut vec2);\n    /// assert_eq!(vec, [1, 2, 3, 4, 5, 6]);\n    /// assert_eq!(vec2, []);\n    /// ```\n    #[cfg(not(no_global_oom_handling))]\n    #[inline]\n    #[stable(feature = \"append\", since = \"1.4.0\")]\n    pub fn append(&mut self, other: &mut Self) {\n        unsafe {\n            self.append_elements(other.as_slice() as _);\n            other.set_len(0);\n        }\n    }\n\n    /// Appends elements to `self` from other buffer.\n    #[cfg(not(no_global_oom_handling))]\n    #[inline]\n    unsafe fn append_elements(&mut self, other: *const [T]) {\n        let count = unsafe { (*other).len() };\n        self.reserve(count);\n        let len = self.len();\n        unsafe { ptr::copy_nonoverlapping(other as *const T, self.as_mut_ptr().add(len), count) };\n        self.len += count;\n    }\n\n    /// Tries to append elements to `self` from other buffer.\n    #[inline]\n    unsafe fn try_append_elements(&mut self, other: *const [T]) -> Result<(), TryReserveError> {\n        let count = unsafe { (*other).len() };\n        self.try_reserve(count)?;\n        let len = self.len();\n        unsafe { ptr::copy_nonoverlapping(other as *const T, self.as_mut_ptr().add(len), count) };\n        self.len += count;\n        Ok(())\n    }\n\n    /// Removes the specified range from the vector in bulk, returning all\n    /// removed elements as an iterator. If the iterator is dropped before\n    /// being fully consumed, it drops the remaining removed elements.\n    ///\n    /// The returned iterator keeps a mutable borrow on the vector to optimize\n    /// its implementation.\n    ///\n    /// # Panics\n    ///\n    /// Panics if the starting point is greater than the end point or if\n    /// the end point is greater than the length of the vector.\n    ///\n    /// # Leaking\n    ///\n    /// If the returned iterator goes out of scope without being dropped (due to\n    /// [`mem::forget`], for example), the vector may have lost and leaked\n    /// elements arbitrarily, including elements outside the range.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut v = vec![1, 2, 3];\n    /// let u: Vec<_> = v.drain(1..).collect();\n    /// assert_eq!(v, &[1]);\n    /// assert_eq!(u, &[2, 3]);\n    ///\n    /// // A full range clears the vector, like `clear()` does\n    /// v.drain(..);\n    /// assert_eq!(v, &[]);\n    /// ```\n    #[stable(feature = \"drain\", since = \"1.6.0\")]\n    pub fn drain<R>(&mut self, range: R) -> Drain<'_, T, A>\n    where\n        R: RangeBounds<usize>,\n    {\n        // Memory safety\n        //\n        // When the Drain is first created, it shortens the length of\n        // the source vector to make sure no uninitialized or moved-from elements\n        // are accessible at all if the Drain's destructor never gets to run.\n        //\n        // Drain will ptr::read out the values to remove.\n        // When finished, remaining tail of the vec is copied back to cover\n        // the hole, and the vector length is restored to the new length.\n        //\n        let len = self.len();\n        let Range { start, end } = slice::range(range, ..len);\n\n        unsafe {\n            // set self.vec length's to start, to be safe in case Drain is leaked\n            self.set_len(start);\n            let range_slice = slice::from_raw_parts(self.as_ptr().add(start), end - start);\n            Drain {\n                tail_start: end,\n                tail_len: len - end,\n                iter: range_slice.iter(),\n                vec: NonNull::from(self),\n            }\n        }\n    }\n\n    /// Clears the vector, removing all values.\n    ///\n    /// Note that this method has no effect on the allocated capacity\n    /// of the vector.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut v = vec![1, 2, 3];\n    ///\n    /// v.clear();\n    ///\n    /// assert!(v.is_empty());\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn clear(&mut self) {\n        let elems: *mut [T] = self.as_mut_slice();\n\n        // SAFETY:\n        // - `elems` comes directly from `as_mut_slice` and is therefore valid.\n        // - Setting `self.len` before calling `drop_in_place` means that,\n        //   if an element's `Drop` impl panics, the vector's `Drop` impl will\n        //   do nothing (leaking the rest of the elements) instead of dropping\n        //   some twice.\n        unsafe {\n            self.len = 0;\n            ptr::drop_in_place(elems);\n        }\n    }\n\n    /// Returns the number of elements in the vector, also referred to\n    /// as its 'length'.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let a = vec![1, 2, 3];\n    /// assert_eq!(a.len(), 3);\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn len(&self) -> usize {\n        self.len\n    }\n\n    /// Returns `true` if the vector contains no elements.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut v = Vec::new();\n    /// assert!(v.is_empty());\n    ///\n    /// v.push(1);\n    /// assert!(!v.is_empty());\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn is_empty(&self) -> bool {\n        self.len() == 0\n    }\n\n    /// Splits the collection into two at the given index.\n    ///\n    /// Returns a newly allocated vector containing the elements in the range\n    /// `[at, len)`. After the call, the original vector will be left containing\n    /// the elements `[0, at)` with its previous capacity unchanged.\n    ///\n    /// # Panics\n    ///\n    /// Panics if `at > len`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut vec = vec![1, 2, 3];\n    /// let vec2 = vec.split_off(1);\n    /// assert_eq!(vec, [1]);\n    /// assert_eq!(vec2, [2, 3]);\n    /// ```\n    #[cfg(not(no_global_oom_handling))]\n    #[inline]\n    #[must_use = \"use `.truncate()` if you don't need the other half\"]\n    #[stable(feature = \"split_off\", since = \"1.4.0\")]\n    pub fn split_off(&mut self, at: usize) -> Self\n    where\n        A: Clone,\n    {\n        #[cold]\n        #[inline(never)]\n        fn assert_failed(at: usize, len: usize) -> ! {\n            panic!(\"`at` split index (is {at}) should be <= len (is {len})\");\n        }\n\n        if at > self.len() {\n            assert_failed(at, self.len());\n        }\n\n        if at == 0 {\n            // the new vector can take over the original buffer and avoid the copy\n            return mem::replace(\n                self,\n                Vec::with_capacity_in(self.capacity(), self.allocator().clone()),\n            );\n        }\n\n        let other_len = self.len - at;\n        let mut other = Vec::with_capacity_in(other_len, self.allocator().clone());\n\n        // Unsafely `set_len` and copy items to `other`.\n        unsafe {\n            self.set_len(at);\n            other.set_len(other_len);\n\n            ptr::copy_nonoverlapping(self.as_ptr().add(at), other.as_mut_ptr(), other.len());\n        }\n        other\n    }\n\n    /// Resizes the `Vec` in-place so that `len` is equal to `new_len`.\n    ///\n    /// If `new_len` is greater than `len`, the `Vec` is extended by the\n    /// difference, with each additional slot filled with the result of\n    /// calling the closure `f`. The return values from `f` will end up\n    /// in the `Vec` in the order they have been generated.\n    ///\n    /// If `new_len` is less than `len`, the `Vec` is simply truncated.\n    ///\n    /// This method uses a closure to create new values on every push. If\n    /// you'd rather [`Clone`] a given value, use [`Vec::resize`]. If you\n    /// want to use the [`Default`] trait to generate values, you can\n    /// pass [`Default::default`] as the second argument.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut vec = vec![1, 2, 3];\n    /// vec.resize_with(5, Default::default);\n    /// assert_eq!(vec, [1, 2, 3, 0, 0]);\n    ///\n    /// let mut vec = vec![];\n    /// let mut p = 1;\n    /// vec.resize_with(4, || { p *= 2; p });\n    /// assert_eq!(vec, [2, 4, 8, 16]);\n    /// ```\n    #[cfg(not(no_global_oom_handling))]\n    #[stable(feature = \"vec_resize_with\", since = \"1.33.0\")]\n    pub fn resize_with<F>(&mut self, new_len: usize, f: F)\n    where\n        F: FnMut() -> T,\n    {\n        let len = self.len();\n        if new_len > len {\n            self.extend_trusted(iter::repeat_with(f).take(new_len - len));\n        } else {\n            self.truncate(new_len);\n        }\n    }\n\n    /// Consumes and leaks the `Vec`, returning a mutable reference to the contents,\n    /// `&'a mut [T]`. Note that the type `T` must outlive the chosen lifetime\n    /// `'a`. If the type has only static references, or none at all, then this\n    /// may be chosen to be `'static`.\n    ///\n    /// As of Rust 1.57, this method does not reallocate or shrink the `Vec`,\n    /// so the leaked allocation may include unused capacity that is not part\n    /// of the returned slice.\n    ///\n    /// This function is mainly useful for data that lives for the remainder of\n    /// the program's life. Dropping the returned reference will cause a memory\n    /// leak.\n    ///\n    /// # Examples\n    ///\n    /// Simple usage:\n    ///\n    /// ```\n    /// let x = vec![1, 2, 3];\n    /// let static_ref: &'static mut [usize] = x.leak();\n    /// static_ref[0] += 1;\n    /// assert_eq!(static_ref, &[2, 2, 3]);\n    /// ```\n    #[stable(feature = \"vec_leak\", since = \"1.47.0\")]\n    #[inline]\n    pub fn leak<'a>(self) -> &'a mut [T]\n    where\n        A: 'a,\n    {\n        let mut me = ManuallyDrop::new(self);\n        unsafe { slice::from_raw_parts_mut(me.as_mut_ptr(), me.len) }\n    }\n\n    /// Returns the remaining spare capacity of the vector as a slice of\n    /// `MaybeUninit<T>`.\n    ///\n    /// The returned slice can be used to fill the vector with data (e.g. by\n    /// reading from a file) before marking the data as initialized using the\n    /// [`set_len`] method.\n    ///\n    /// [`set_len`]: Vec::set_len\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// // Allocate vector big enough for 10 elements.\n    /// let mut v = Vec::with_capacity(10);\n    ///\n    /// // Fill in the first 3 elements.\n    /// let uninit = v.spare_capacity_mut();\n    /// uninit[0].write(0);\n    /// uninit[1].write(1);\n    /// uninit[2].write(2);\n    ///\n    /// // Mark the first 3 elements of the vector as being initialized.\n    /// unsafe {\n    ///     v.set_len(3);\n    /// }\n    ///\n    /// assert_eq!(&v, &[0, 1, 2]);\n    /// ```\n    #[stable(feature = \"vec_spare_capacity\", since = \"1.60.0\")]\n    #[inline]\n    pub fn spare_capacity_mut(&mut self) -> &mut [MaybeUninit<T>] {\n        // Note:\n        // This method is not implemented in terms of `split_at_spare_mut`,\n        // to prevent invalidation of pointers to the buffer.\n        unsafe {\n            slice::from_raw_parts_mut(\n                self.as_mut_ptr().add(self.len) as *mut MaybeUninit<T>,\n                self.buf.capacity() - self.len,\n            )\n        }\n    }\n\n    /// Returns vector content as a slice of `T`, along with the remaining spare\n    /// capacity of the vector as a slice of `MaybeUninit<T>`.\n    ///\n    /// The returned spare capacity slice can be used to fill the vector with data\n    /// (e.g. by reading from a file) before marking the data as initialized using\n    /// the [`set_len`] method.\n    ///\n    /// [`set_len`]: Vec::set_len\n    ///\n    /// Note that this is a low-level API, which should be used with care for\n    /// optimization purposes. If you need to append data to a `Vec`\n    /// you can use [`push`], [`extend`], [`extend_from_slice`],\n    /// [`extend_from_within`], [`insert`], [`append`], [`resize`] or\n    /// [`resize_with`], depending on your exact needs.\n    ///\n    /// [`push`]: Vec::push\n    /// [`extend`]: Vec::extend\n    /// [`extend_from_slice`]: Vec::extend_from_slice\n    /// [`extend_from_within`]: Vec::extend_from_within\n    /// [`insert`]: Vec::insert\n    /// [`append`]: Vec::append\n    /// [`resize`]: Vec::resize\n    /// [`resize_with`]: Vec::resize_with\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(vec_split_at_spare)]\n    ///\n    /// let mut v = vec![1, 1, 2];\n    ///\n    /// // Reserve additional space big enough for 10 elements.\n    /// v.reserve(10);\n    ///\n    /// let (init, uninit) = v.split_at_spare_mut();\n    /// let sum = init.iter().copied().sum::<u32>();\n    ///\n    /// // Fill in the next 4 elements.\n    /// uninit[0].write(sum);\n    /// uninit[1].write(sum * 2);\n    /// uninit[2].write(sum * 3);\n    /// uninit[3].write(sum * 4);\n    ///\n    /// // Mark the 4 elements of the vector as being initialized.\n    /// unsafe {\n    ///     let len = v.len();\n    ///     v.set_len(len + 4);\n    /// }\n    ///\n    /// assert_eq!(&v, &[1, 1, 2, 4, 8, 12, 16]);\n    /// ```\n    #[unstable(feature = \"vec_split_at_spare\", issue = \"81944\")]\n    #[inline]\n    pub fn split_at_spare_mut(&mut self) -> (&mut [T], &mut [MaybeUninit<T>]) {\n        // SAFETY:\n        // - len is ignored and so never changed\n        let (init, spare, _) = unsafe { self.split_at_spare_mut_with_len() };\n        (init, spare)\n    }\n\n    /// Safety: changing returned .2 (&mut usize) is considered the same as calling `.set_len(_)`.\n    ///\n    /// This method provides unique access to all vec parts at once in `extend_from_within`.\n    unsafe fn split_at_spare_mut_with_len(\n        &mut self,\n    ) -> (&mut [T], &mut [MaybeUninit<T>], &mut usize) {\n        let ptr = self.as_mut_ptr();\n        // SAFETY:\n        // - `ptr` is guaranteed to be valid for `self.len` elements\n        // - but the allocation extends out to `self.buf.capacity()` elements, possibly\n        // uninitialized\n        let spare_ptr = unsafe { ptr.add(self.len) };\n        let spare_ptr = spare_ptr.cast::<MaybeUninit<T>>();\n        let spare_len = self.buf.capacity() - self.len;\n\n        // SAFETY:\n        // - `ptr` is guaranteed to be valid for `self.len` elements\n        // - `spare_ptr` is pointing one element past the buffer, so it doesn't overlap with `initialized`\n        unsafe {\n            let initialized = slice::from_raw_parts_mut(ptr, self.len);\n            let spare = slice::from_raw_parts_mut(spare_ptr, spare_len);\n\n            (initialized, spare, &mut self.len)\n        }\n    }\n}\n\nimpl<T: Clone, A: Allocator> Vec<T, A> {\n    /// Resizes the `Vec` in-place so that `len` is equal to `new_len`.\n    ///\n    /// If `new_len` is greater than `len`, the `Vec` is extended by the\n    /// difference, with each additional slot filled with `value`.\n    /// If `new_len` is less than `len`, the `Vec` is simply truncated.\n    ///\n    /// This method requires `T` to implement [`Clone`],\n    /// in order to be able to clone the passed value.\n    /// If you need more flexibility (or want to rely on [`Default`] instead of\n    /// [`Clone`]), use [`Vec::resize_with`].\n    /// If you only need to resize to a smaller size, use [`Vec::truncate`].\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut vec = vec![\"hello\"];\n    /// vec.resize(3, \"world\");\n    /// assert_eq!(vec, [\"hello\", \"world\", \"world\"]);\n    ///\n    /// let mut vec = vec![1, 2, 3, 4];\n    /// vec.resize(2, 0);\n    /// assert_eq!(vec, [1, 2]);\n    /// ```\n    #[cfg(not(no_global_oom_handling))]\n    #[stable(feature = \"vec_resize\", since = \"1.5.0\")]\n    pub fn resize(&mut self, new_len: usize, value: T) {\n        let len = self.len();\n\n        if new_len > len {\n            self.extend_with(new_len - len, ExtendElement(value))\n        } else {\n            self.truncate(new_len);\n        }\n    }\n\n    /// Tries to resize the `Vec` in-place so that `len` is equal to `new_len`.\n    ///\n    /// If `new_len` is greater than `len`, the `Vec` is extended by the\n    /// difference, with each additional slot filled with `value`.\n    /// If `new_len` is less than `len`, the `Vec` is simply truncated.\n    ///\n    /// This method requires `T` to implement [`Clone`],\n    /// in order to be able to clone the passed value.\n    /// If you need more flexibility (or want to rely on [`Default`] instead of\n    /// [`Clone`]), use [`Vec::resize_with`].\n    /// If you only need to resize to a smaller size, use [`Vec::truncate`].\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut vec = vec![\"hello\"];\n    /// vec.try_resize(3, \"world\").unwrap();\n    /// assert_eq!(vec, [\"hello\", \"world\", \"world\"]);\n    ///\n    /// let mut vec = vec![1, 2, 3, 4];\n    /// vec.try_resize(2, 0).unwrap();\n    /// assert_eq!(vec, [1, 2]);\n    ///\n    /// let mut vec = vec![42];\n    /// let result = vec.try_resize(usize::MAX, 0);\n    /// assert!(result.is_err());\n    /// ```\n    #[stable(feature = \"kernel\", since = \"1.0.0\")]\n    pub fn try_resize(&mut self, new_len: usize, value: T) -> Result<(), TryReserveError> {\n        let len = self.len();\n\n        if new_len > len {\n            self.try_extend_with(new_len - len, ExtendElement(value))\n        } else {\n            self.truncate(new_len);\n            Ok(())\n        }\n    }\n\n    /// Clones and appends all elements in a slice to the `Vec`.\n    ///\n    /// Iterates over the slice `other`, clones each element, and then appends\n    /// it to this `Vec`. The `other` slice is traversed in-order.\n    ///\n    /// Note that this function is same as [`extend`] except that it is\n    /// specialized to work with slices instead. If and when Rust gets\n    /// specialization this function will likely be deprecated (but still\n    /// available).\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut vec = vec![1];\n    /// vec.extend_from_slice(&[2, 3, 4]);\n    /// assert_eq!(vec, [1, 2, 3, 4]);\n    /// ```\n    ///\n    /// [`extend`]: Vec::extend\n    #[cfg(not(no_global_oom_handling))]\n    #[stable(feature = \"vec_extend_from_slice\", since = \"1.6.0\")]\n    pub fn extend_from_slice(&mut self, other: &[T]) {\n        self.spec_extend(other.iter())\n    }\n\n    /// Tries to clone and append all elements in a slice to the `Vec`.\n    ///\n    /// Iterates over the slice `other`, clones each element, and then appends\n    /// it to this `Vec`. The `other` slice is traversed in-order.\n    ///\n    /// Note that this function is same as [`extend`] except that it is\n    /// specialized to work with slices instead. If and when Rust gets\n    /// specialization this function will likely be deprecated (but still\n    /// available).\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut vec = vec![1];\n    /// vec.try_extend_from_slice(&[2, 3, 4]).unwrap();\n    /// assert_eq!(vec, [1, 2, 3, 4]);\n    /// ```\n    ///\n    /// [`extend`]: Vec::extend\n    #[stable(feature = \"kernel\", since = \"1.0.0\")]\n    pub fn try_extend_from_slice(&mut self, other: &[T]) -> Result<(), TryReserveError> {\n        self.try_spec_extend(other.iter())\n    }\n\n    /// Copies elements from `src` range to the end of the vector.\n    ///\n    /// # Panics\n    ///\n    /// Panics if the starting point is greater than the end point or if\n    /// the end point is greater than the length of the vector.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut vec = vec![0, 1, 2, 3, 4];\n    ///\n    /// vec.extend_from_within(2..);\n    /// assert_eq!(vec, [0, 1, 2, 3, 4, 2, 3, 4]);\n    ///\n    /// vec.extend_from_within(..2);\n    /// assert_eq!(vec, [0, 1, 2, 3, 4, 2, 3, 4, 0, 1]);\n    ///\n    /// vec.extend_from_within(4..8);\n    /// assert_eq!(vec, [0, 1, 2, 3, 4, 2, 3, 4, 0, 1, 4, 2, 3, 4]);\n    /// ```\n    #[cfg(not(no_global_oom_handling))]\n    #[stable(feature = \"vec_extend_from_within\", since = \"1.53.0\")]\n    pub fn extend_from_within<R>(&mut self, src: R)\n    where\n        R: RangeBounds<usize>,\n    {\n        let range = slice::range(src, ..self.len());\n        self.reserve(range.len());\n\n        // SAFETY:\n        // - `slice::range` guarantees that the given range is valid for indexing self\n        unsafe {\n            self.spec_extend_from_within(range);\n        }\n    }\n}\n\nimpl<T, A: Allocator, const N: usize> Vec<[T; N], A> {\n    /// Takes a `Vec<[T; N]>` and flattens it into a `Vec<T>`.\n    ///\n    /// # Panics\n    ///\n    /// Panics if the length of the resulting vector would overflow a `usize`.\n    ///\n    /// This is only possible when flattening a vector of arrays of zero-sized\n    /// types, and thus tends to be irrelevant in practice. If\n    /// `size_of::<T>() > 0`, this will never panic.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(slice_flatten)]\n    ///\n    /// let mut vec = vec![[1, 2, 3], [4, 5, 6], [7, 8, 9]];\n    /// assert_eq!(vec.pop(), Some([7, 8, 9]));\n    ///\n    /// let mut flattened = vec.into_flattened();\n    /// assert_eq!(flattened.pop(), Some(6));\n    /// ```\n    #[unstable(feature = \"slice_flatten\", issue = \"95629\")]\n    pub fn into_flattened(self) -> Vec<T, A> {\n        let (ptr, len, cap, alloc) = self.into_raw_parts_with_alloc();\n        let (new_len, new_cap) = if T::IS_ZST {\n            (len.checked_mul(N).expect(\"vec len overflow\"), usize::MAX)\n        } else {\n            // SAFETY:\n            // - `cap * N` cannot overflow because the allocation is already in\n            // the address space.\n            // - Each `[T; N]` has `N` valid elements, so there are `len * N`\n            // valid elements in the allocation.\n            unsafe { (len.unchecked_mul(N), cap.unchecked_mul(N)) }\n        };\n        // SAFETY:\n        // - `ptr` was allocated by `self`\n        // - `ptr` is well-aligned because `[T; N]` has the same alignment as `T`.\n        // - `new_cap` refers to the same sized allocation as `cap` because\n        // `new_cap * size_of::<T>()` == `cap * size_of::<[T; N]>()`\n        // - `len` <= `cap`, so `len * N` <= `cap * N`.\n        unsafe { Vec::<T, A>::from_raw_parts_in(ptr.cast(), new_len, new_cap, alloc) }\n    }\n}\n\n// This code generalizes `extend_with_{element,default}`.\ntrait ExtendWith<T> {\n    fn next(&mut self) -> T;\n    fn last(self) -> T;\n}\n\nstruct ExtendElement<T>(T);\nimpl<T: Clone> ExtendWith<T> for ExtendElement<T> {\n    fn next(&mut self) -> T {\n        self.0.clone()\n    }\n    fn last(self) -> T {\n        self.0\n    }\n}\n\nimpl<T, A: Allocator> Vec<T, A> {\n    #[cfg(not(no_global_oom_handling))]\n    /// Extend the vector by `n` values, using the given generator.\n    fn extend_with<E: ExtendWith<T>>(&mut self, n: usize, mut value: E) {\n        self.reserve(n);\n\n        unsafe {\n            let mut ptr = self.as_mut_ptr().add(self.len());\n            // Use SetLenOnDrop to work around bug where compiler\n            // might not realize the store through `ptr` through self.set_len()\n            // don't alias.\n            let mut local_len = SetLenOnDrop::new(&mut self.len);\n\n            // Write all elements except the last one\n            for _ in 1..n {\n                ptr::write(ptr, value.next());\n                ptr = ptr.add(1);\n                // Increment the length in every step in case next() panics\n                local_len.increment_len(1);\n            }\n\n            if n > 0 {\n                // We can write the last element directly without cloning needlessly\n                ptr::write(ptr, value.last());\n                local_len.increment_len(1);\n            }\n\n            // len set by scope guard\n        }\n    }\n\n    /// Try to extend the vector by `n` values, using the given generator.\n    fn try_extend_with<E: ExtendWith<T>>(&mut self, n: usize, mut value: E) -> Result<(), TryReserveError> {\n        self.try_reserve(n)?;\n\n        unsafe {\n            let mut ptr = self.as_mut_ptr().add(self.len());\n            // Use SetLenOnDrop to work around bug where compiler\n            // might not realize the store through `ptr` through self.set_len()\n            // don't alias.\n            let mut local_len = SetLenOnDrop::new(&mut self.len);\n\n            // Write all elements except the last one\n            for _ in 1..n {\n                ptr::write(ptr, value.next());\n                ptr = ptr.add(1);\n                // Increment the length in every step in case next() panics\n                local_len.increment_len(1);\n            }\n\n            if n > 0 {\n                // We can write the last element directly without cloning needlessly\n                ptr::write(ptr, value.last());\n                local_len.increment_len(1);\n            }\n\n            // len set by scope guard\n            Ok(())\n        }\n    }\n}\n\nimpl<T: PartialEq, A: Allocator> Vec<T, A> {\n    /// Removes consecutive repeated elements in the vector according to the\n    /// [`PartialEq`] trait implementation.\n    ///\n    /// If the vector is sorted, this removes all duplicates.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut vec = vec![1, 2, 2, 3, 2];\n    ///\n    /// vec.dedup();\n    ///\n    /// assert_eq!(vec, [1, 2, 3, 2]);\n    /// ```\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn dedup(&mut self) {\n        self.dedup_by(|a, b| a == b)\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Internal methods and functions\n////////////////////////////////////////////////////////////////////////////////\n\n#[doc(hidden)]\n#[cfg(not(no_global_oom_handling))]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub fn from_elem<T: Clone>(elem: T, n: usize) -> Vec<T> {\n    <T as SpecFromElem>::from_elem(elem, n, Global)\n}\n\n#[doc(hidden)]\n#[cfg(not(no_global_oom_handling))]\n#[unstable(feature = \"allocator_api\", issue = \"32838\")]\npub fn from_elem_in<T: Clone, A: Allocator>(elem: T, n: usize, alloc: A) -> Vec<T, A> {\n    <T as SpecFromElem>::from_elem(elem, n, alloc)\n}\n\ntrait ExtendFromWithinSpec {\n    /// # Safety\n    ///\n    /// - `src` needs to be valid index\n    /// - `self.capacity() - self.len()` must be `>= src.len()`\n    unsafe fn spec_extend_from_within(&mut self, src: Range<usize>);\n}\n\nimpl<T: Clone, A: Allocator> ExtendFromWithinSpec for Vec<T, A> {\n    default unsafe fn spec_extend_from_within(&mut self, src: Range<usize>) {\n        // SAFETY:\n        // - len is increased only after initializing elements\n        let (this, spare, len) = unsafe { self.split_at_spare_mut_with_len() };\n\n        // SAFETY:\n        // - caller guarantees that src is a valid index\n        let to_clone = unsafe { this.get_unchecked(src) };\n\n        iter::zip(to_clone, spare)\n            .map(|(src, dst)| dst.write(src.clone()))\n            // Note:\n            // - Element was just initialized with `MaybeUninit::write`, so it's ok to increase len\n            // - len is increased after each element to prevent leaks (see issue #82533)\n            .for_each(|_| *len += 1);\n    }\n}\n\nimpl<T: Copy, A: Allocator> ExtendFromWithinSpec for Vec<T, A> {\n    unsafe fn spec_extend_from_within(&mut self, src: Range<usize>) {\n        let count = src.len();\n        {\n            let (init, spare) = self.split_at_spare_mut();\n\n            // SAFETY:\n            // - caller guarantees that `src` is a valid index\n            let source = unsafe { init.get_unchecked(src) };\n\n            // SAFETY:\n            // - Both pointers are created from unique slice references (`&mut [_]`)\n            //   so they are valid and do not overlap.\n            // - Elements are :Copy so it's OK to copy them, without doing\n            //   anything with the original values\n            // - `count` is equal to the len of `source`, so source is valid for\n            //   `count` reads\n            // - `.reserve(count)` guarantees that `spare.len() >= count` so spare\n            //   is valid for `count` writes\n            unsafe { ptr::copy_nonoverlapping(source.as_ptr(), spare.as_mut_ptr() as _, count) };\n        }\n\n        // SAFETY:\n        // - The elements were just initialized by `copy_nonoverlapping`\n        self.len += count;\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Common trait implementations for Vec\n////////////////////////////////////////////////////////////////////////////////\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T, A: Allocator> ops::Deref for Vec<T, A> {\n    type Target = [T];\n\n    #[inline]\n    fn deref(&self) -> &[T] {\n        unsafe { slice::from_raw_parts(self.as_ptr(), self.len) }\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T, A: Allocator> ops::DerefMut for Vec<T, A> {\n    #[inline]\n    fn deref_mut(&mut self) -> &mut [T] {\n        unsafe { slice::from_raw_parts_mut(self.as_mut_ptr(), self.len) }\n    }\n}\n\n#[cfg(not(no_global_oom_handling))]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: Clone, A: Allocator + Clone> Clone for Vec<T, A> {\n    #[cfg(not(test))]\n    fn clone(&self) -> Self {\n        let alloc = self.allocator().clone();\n        <[T]>::to_vec_in(&**self, alloc)\n    }\n\n    // HACK(japaric): with cfg(test) the inherent `[T]::to_vec` method, which is\n    // required for this method definition, is not available. Instead use the\n    // `slice::to_vec` function which is only available with cfg(test)\n    // NB see the slice::hack module in slice.rs for more information\n    #[cfg(test)]\n    fn clone(&self) -> Self {\n        let alloc = self.allocator().clone();\n        crate::slice::to_vec(&**self, alloc)\n    }\n\n    fn clone_from(&mut self, other: &Self) {\n        crate::slice::SpecCloneIntoVec::clone_into(other.as_slice(), self);\n    }\n}\n\n/// The hash of a vector is the same as that of the corresponding slice,\n/// as required by the `core::borrow::Borrow` implementation.\n///\n/// ```\n/// use std::hash::BuildHasher;\n///\n/// let b = std::collections::hash_map::RandomState::new();\n/// let v: Vec<u8> = vec![0xa8, 0x3c, 0x09];\n/// let s: &[u8] = &[0xa8, 0x3c, 0x09];\n/// assert_eq!(b.hash_one(v), b.hash_one(s));\n/// ```\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: Hash, A: Allocator> Hash for Vec<T, A> {\n    #[inline]\n    fn hash<H: Hasher>(&self, state: &mut H) {\n        Hash::hash(&**self, state)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[rustc_on_unimplemented(\n    message = \"vector indices are of type `usize` or ranges of `usize`\",\n    label = \"vector indices are of type `usize` or ranges of `usize`\"\n)]\nimpl<T, I: SliceIndex<[T]>, A: Allocator> Index<I> for Vec<T, A> {\n    type Output = I::Output;\n\n    #[inline]\n    fn index(&self, index: I) -> &Self::Output {\n        Index::index(&**self, index)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n#[rustc_on_unimplemented(\n    message = \"vector indices are of type `usize` or ranges of `usize`\",\n    label = \"vector indices are of type `usize` or ranges of `usize`\"\n)]\nimpl<T, I: SliceIndex<[T]>, A: Allocator> IndexMut<I> for Vec<T, A> {\n    #[inline]\n    fn index_mut(&mut self, index: I) -> &mut Self::Output {\n        IndexMut::index_mut(&mut **self, index)\n    }\n}\n\n#[cfg(not(no_global_oom_handling))]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T> FromIterator<T> for Vec<T> {\n    #[inline]\n    fn from_iter<I: IntoIterator<Item = T>>(iter: I) -> Vec<T> {\n        <Self as SpecFromIter<T, I::IntoIter>>::from_iter(iter.into_iter())\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T, A: Allocator> IntoIterator for Vec<T, A> {\n    type Item = T;\n    type IntoIter = IntoIter<T, A>;\n\n    /// Creates a consuming iterator, that is, one that moves each value out of\n    /// the vector (from start to end). The vector cannot be used after calling\n    /// this.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let v = vec![\"a\".to_string(), \"b\".to_string()];\n    /// let mut v_iter = v.into_iter();\n    ///\n    /// let first_element: Option<String> = v_iter.next();\n    ///\n    /// assert_eq!(first_element, Some(\"a\".to_string()));\n    /// assert_eq!(v_iter.next(), Some(\"b\".to_string()));\n    /// assert_eq!(v_iter.next(), None);\n    /// ```\n    #[inline]\n    fn into_iter(self) -> Self::IntoIter {\n        unsafe {\n            let mut me = ManuallyDrop::new(self);\n            let alloc = ManuallyDrop::new(ptr::read(me.allocator()));\n            let begin = me.as_mut_ptr();\n            let end = if T::IS_ZST {\n                begin.wrapping_byte_add(me.len())\n            } else {\n                begin.add(me.len()) as *const T\n            };\n            let cap = me.buf.capacity();\n            IntoIter {\n                buf: NonNull::new_unchecked(begin),\n                phantom: PhantomData,\n                cap,\n                alloc,\n                ptr: begin,\n                end,\n            }\n        }\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, T, A: Allocator> IntoIterator for &'a Vec<T, A> {\n    type Item = &'a T;\n    type IntoIter = slice::Iter<'a, T>;\n\n    fn into_iter(self) -> Self::IntoIter {\n        self.iter()\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, T, A: Allocator> IntoIterator for &'a mut Vec<T, A> {\n    type Item = &'a mut T;\n    type IntoIter = slice::IterMut<'a, T>;\n\n    fn into_iter(self) -> Self::IntoIter {\n        self.iter_mut()\n    }\n}\n\n#[cfg(not(no_global_oom_handling))]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T, A: Allocator> Extend<T> for Vec<T, A> {\n    #[inline]\n    fn extend<I: IntoIterator<Item = T>>(&mut self, iter: I) {\n        <Self as SpecExtend<T, I::IntoIter>>::spec_extend(self, iter.into_iter())\n    }\n\n    #[inline]\n    fn extend_one(&mut self, item: T) {\n        self.push(item);\n    }\n\n    #[inline]\n    fn extend_reserve(&mut self, additional: usize) {\n        self.reserve(additional);\n    }\n}\n\nimpl<T, A: Allocator> Vec<T, A> {\n    // leaf method to which various SpecFrom/SpecExtend implementations delegate when\n    // they have no further optimizations to apply\n    #[cfg(not(no_global_oom_handling))]\n    fn extend_desugared<I: Iterator<Item = T>>(&mut self, mut iterator: I) {\n        // This is the case for a general iterator.\n        //\n        // This function should be the moral equivalent of:\n        //\n        //      for item in iterator {\n        //          self.push(item);\n        //      }\n        while let Some(element) = iterator.next() {\n            let len = self.len();\n            if len == self.capacity() {\n                let (lower, _) = iterator.size_hint();\n                self.reserve(lower.saturating_add(1));\n            }\n            unsafe {\n                ptr::write(self.as_mut_ptr().add(len), element);\n                // Since next() executes user code which can panic we have to bump the length\n                // after each step.\n                // NB can't overflow since we would have had to alloc the address space\n                self.set_len(len + 1);\n            }\n        }\n    }\n\n    // leaf method to which various SpecFrom/SpecExtend implementations delegate when\n    // they have no further optimizations to apply\n    fn try_extend_desugared<I: Iterator<Item = T>>(&mut self, mut iterator: I) -> Result<(), TryReserveError> {\n        // This is the case for a general iterator.\n        //\n        // This function should be the moral equivalent of:\n        //\n        //      for item in iterator {\n        //          self.push(item);\n        //      }\n        while let Some(element) = iterator.next() {\n            let len = self.len();\n            if len == self.capacity() {\n                let (lower, _) = iterator.size_hint();\n                self.try_reserve(lower.saturating_add(1))?;\n            }\n            unsafe {\n                ptr::write(self.as_mut_ptr().add(len), element);\n                // Since next() executes user code which can panic we have to bump the length\n                // after each step.\n                // NB can't overflow since we would have had to alloc the address space\n                self.set_len(len + 1);\n            }\n        }\n\n        Ok(())\n    }\n\n    // specific extend for `TrustedLen` iterators, called both by the specializations\n    // and internal places where resolving specialization makes compilation slower\n    #[cfg(not(no_global_oom_handling))]\n    fn extend_trusted(&mut self, iterator: impl iter::TrustedLen<Item = T>) {\n        let (low, high) = iterator.size_hint();\n        if let Some(additional) = high {\n            debug_assert_eq!(\n                low,\n                additional,\n                \"TrustedLen iterator's size hint is not exact: {:?}\",\n                (low, high)\n            );\n            self.reserve(additional);\n            unsafe {\n                let ptr = self.as_mut_ptr();\n                let mut local_len = SetLenOnDrop::new(&mut self.len);\n                iterator.for_each(move |element| {\n                    ptr::write(ptr.add(local_len.current_len()), element);\n                    // Since the loop executes user code which can panic we have to update\n                    // the length every step to correctly drop what we've written.\n                    // NB can't overflow since we would have had to alloc the address space\n                    local_len.increment_len(1);\n                });\n            }\n        } else {\n            // Per TrustedLen contract a `None` upper bound means that the iterator length\n            // truly exceeds usize::MAX, which would eventually lead to a capacity overflow anyway.\n            // Since the other branch already panics eagerly (via `reserve()`) we do the same here.\n            // This avoids additional codegen for a fallback code path which would eventually\n            // panic anyway.\n            panic!(\"capacity overflow\");\n        }\n    }\n\n    // specific extend for `TrustedLen` iterators, called both by the specializations\n    // and internal places where resolving specialization makes compilation slower\n    fn try_extend_trusted(&mut self, iterator: impl iter::TrustedLen<Item = T>) -> Result<(), TryReserveError> {\n        let (low, high) = iterator.size_hint();\n        if let Some(additional) = high {\n            debug_assert_eq!(\n                low,\n                additional,\n                \"TrustedLen iterator's size hint is not exact: {:?}\",\n                (low, high)\n            );\n            self.try_reserve(additional)?;\n            unsafe {\n                let ptr = self.as_mut_ptr();\n                let mut local_len = SetLenOnDrop::new(&mut self.len);\n                iterator.for_each(move |element| {\n                    ptr::write(ptr.add(local_len.current_len()), element);\n                    // Since the loop executes user code which can panic we have to update\n                    // the length every step to correctly drop what we've written.\n                    // NB can't overflow since we would have had to alloc the address space\n                    local_len.increment_len(1);\n                });\n            }\n            Ok(())\n        } else {\n            Err(TryReserveErrorKind::CapacityOverflow.into())\n        }\n    }\n\n    /// Creates a splicing iterator that replaces the specified range in the vector\n    /// with the given `replace_with` iterator and yields the removed items.\n    /// `replace_with` does not need to be the same length as `range`.\n    ///\n    /// `range` is removed even if the iterator is not consumed until the end.\n    ///\n    /// It is unspecified how many elements are removed from the vector\n    /// if the `Splice` value is leaked.\n    ///\n    /// The input iterator `replace_with` is only consumed when the `Splice` value is dropped.\n    ///\n    /// This is optimal if:\n    ///\n    /// * The tail (elements in the vector after `range`) is empty,\n    /// * or `replace_with` yields fewer or equal elements than `range`\u2019s length\n    /// * or the lower bound of its `size_hint()` is exact.\n    ///\n    /// Otherwise, a temporary vector is allocated and the tail is moved twice.\n    ///\n    /// # Panics\n    ///\n    /// Panics if the starting point is greater than the end point or if\n    /// the end point is greater than the length of the vector.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut v = vec![1, 2, 3, 4];\n    /// let new = [7, 8, 9];\n    /// let u: Vec<_> = v.splice(1..3, new).collect();\n    /// assert_eq!(v, &[1, 7, 8, 9, 4]);\n    /// assert_eq!(u, &[2, 3]);\n    /// ```\n    #[cfg(not(no_global_oom_handling))]\n    #[inline]\n    #[stable(feature = \"vec_splice\", since = \"1.21.0\")]\n    pub fn splice<R, I>(&mut self, range: R, replace_with: I) -> Splice<'_, I::IntoIter, A>\n    where\n        R: RangeBounds<usize>,\n        I: IntoIterator<Item = T>,\n    {\n        Splice { drain: self.drain(range), replace_with: replace_with.into_iter() }\n    }\n\n    /// Creates an iterator which uses a closure to determine if an element should be removed.\n    ///\n    /// If the closure returns true, then the element is removed and yielded.\n    /// If the closure returns false, the element will remain in the vector and will not be yielded\n    /// by the iterator.\n    ///\n    /// Using this method is equivalent to the following code:\n    ///\n    /// ```\n    /// # let some_predicate = |x: &mut i32| { *x == 2 || *x == 3 || *x == 6 };\n    /// # let mut vec = vec![1, 2, 3, 4, 5, 6];\n    /// let mut i = 0;\n    /// while i < vec.len() {\n    ///     if some_predicate(&mut vec[i]) {\n    ///         let val = vec.remove(i);\n    ///         // your code here\n    ///     } else {\n    ///         i += 1;\n    ///     }\n    /// }\n    ///\n    /// # assert_eq!(vec, vec![1, 4, 5]);\n    /// ```\n    ///\n    /// But `drain_filter` is easier to use. `drain_filter` is also more efficient,\n    /// because it can backshift the elements of the array in bulk.\n    ///\n    /// Note that `drain_filter` also lets you mutate every element in the filter closure,\n    /// regardless of whether you choose to keep or remove it.\n    ///\n    /// # Examples\n    ///\n    /// Splitting an array into evens and odds, reusing the original allocation:\n    ///\n    /// ```\n    /// #![feature(drain_filter)]\n    /// let mut numbers = vec![1, 2, 3, 4, 5, 6, 8, 9, 11, 13, 14, 15];\n    ///\n    /// let evens = numbers.drain_filter(|x| *x % 2 == 0).collect::<Vec<_>>();\n    /// let odds = numbers;\n    ///\n    /// assert_eq!(evens, vec![2, 4, 6, 8, 14]);\n    /// assert_eq!(odds, vec![1, 3, 5, 9, 11, 13, 15]);\n    /// ```\n    #[unstable(feature = \"drain_filter\", reason = \"recently added\", issue = \"43244\")]\n    pub fn drain_filter<F>(&mut self, filter: F) -> DrainFilter<'_, T, F, A>\n    where\n        F: FnMut(&mut T) -> bool,\n    {\n        let old_len = self.len();\n\n        // Guard against us getting leaked (leak amplification)\n        unsafe {\n            self.set_len(0);\n        }\n\n        DrainFilter { vec: self, idx: 0, del: 0, old_len, pred: filter, panic_flag: false }\n    }\n}\n\n/// Extend implementation that copies elements out of references before pushing them onto the Vec.\n///\n/// This implementation is specialized for slice iterators, where it uses [`copy_from_slice`] to\n/// append the entire slice at once.\n///\n/// [`copy_from_slice`]: slice::copy_from_slice\n#[cfg(not(no_global_oom_handling))]\n#[stable(feature = \"extend_ref\", since = \"1.2.0\")]\nimpl<'a, T: Copy + 'a, A: Allocator + 'a> Extend<&'a T> for Vec<T, A> {\n    fn extend<I: IntoIterator<Item = &'a T>>(&mut self, iter: I) {\n        self.spec_extend(iter.into_iter())\n    }\n\n    #[inline]\n    fn extend_one(&mut self, &item: &'a T) {\n        self.push(item);\n    }\n\n    #[inline]\n    fn extend_reserve(&mut self, additional: usize) {\n        self.reserve(additional);\n    }\n}\n\n/// Implements comparison of vectors, [lexicographically](Ord#lexicographical-comparison).\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: PartialOrd, A: Allocator> PartialOrd for Vec<T, A> {\n    #[inline]\n    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n        PartialOrd::partial_cmp(&**self, &**other)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: Eq, A: Allocator> Eq for Vec<T, A> {}\n\n/// Implements ordering of vectors, [lexicographically](Ord#lexicographical-comparison).\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: Ord, A: Allocator> Ord for Vec<T, A> {\n    #[inline]\n    fn cmp(&self, other: &Self) -> Ordering {\n        Ord::cmp(&**self, &**other)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nunsafe impl<#[may_dangle] T, A: Allocator> Drop for Vec<T, A> {\n    fn drop(&mut self) {\n        unsafe {\n            // use drop for [T]\n            // use a raw slice to refer to the elements of the vector as weakest necessary type;\n            // could avoid questions of validity in certain cases\n            ptr::drop_in_place(ptr::slice_from_raw_parts_mut(self.as_mut_ptr(), self.len))\n        }\n        // RawVec handles deallocation\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T> Default for Vec<T> {\n    /// Creates an empty `Vec<T>`.\n    ///\n    /// The vector will not allocate until elements are pushed onto it.\n    fn default() -> Vec<T> {\n        Vec::new()\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: fmt::Debug, A: Allocator> fmt::Debug for Vec<T, A> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        fmt::Debug::fmt(&**self, f)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T, A: Allocator> AsRef<Vec<T, A>> for Vec<T, A> {\n    fn as_ref(&self) -> &Vec<T, A> {\n        self\n    }\n}\n\n#[stable(feature = \"vec_as_mut\", since = \"1.5.0\")]\nimpl<T, A: Allocator> AsMut<Vec<T, A>> for Vec<T, A> {\n    fn as_mut(&mut self) -> &mut Vec<T, A> {\n        self\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T, A: Allocator> AsRef<[T]> for Vec<T, A> {\n    fn as_ref(&self) -> &[T] {\n        self\n    }\n}\n\n#[stable(feature = \"vec_as_mut\", since = \"1.5.0\")]\nimpl<T, A: Allocator> AsMut<[T]> for Vec<T, A> {\n    fn as_mut(&mut self) -> &mut [T] {\n        self\n    }\n}\n\n#[cfg(not(no_global_oom_handling))]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: Clone> From<&[T]> for Vec<T> {\n    /// Allocate a `Vec<T>` and fill it by cloning `s`'s items.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// assert_eq!(Vec::from(&[1, 2, 3][..]), vec![1, 2, 3]);\n    /// ```\n    #[cfg(not(test))]\n    fn from(s: &[T]) -> Vec<T> {\n        s.to_vec()\n    }\n    #[cfg(test)]\n    fn from(s: &[T]) -> Vec<T> {\n        crate::slice::to_vec(s, Global)\n    }\n}\n\n#[cfg(not(no_global_oom_handling))]\n#[stable(feature = \"vec_from_mut\", since = \"1.19.0\")]\nimpl<T: Clone> From<&mut [T]> for Vec<T> {\n    /// Allocate a `Vec<T>` and fill it by cloning `s`'s items.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// assert_eq!(Vec::from(&mut [1, 2, 3][..]), vec![1, 2, 3]);\n    /// ```\n    #[cfg(not(test))]\n    fn from(s: &mut [T]) -> Vec<T> {\n        s.to_vec()\n    }\n    #[cfg(test)]\n    fn from(s: &mut [T]) -> Vec<T> {\n        crate::slice::to_vec(s, Global)\n    }\n}\n\n#[cfg(not(no_global_oom_handling))]\n#[stable(feature = \"vec_from_array\", since = \"1.44.0\")]\nimpl<T, const N: usize> From<[T; N]> for Vec<T> {\n    /// Allocate a `Vec<T>` and move `s`'s items into it.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// assert_eq!(Vec::from([1, 2, 3]), vec![1, 2, 3]);\n    /// ```\n    #[cfg(not(test))]\n    fn from(s: [T; N]) -> Vec<T> {\n        <[T]>::into_vec(Box::new(s))\n    }\n\n    #[cfg(test)]\n    fn from(s: [T; N]) -> Vec<T> {\n        crate::slice::into_vec(Box::new(s))\n    }\n}\n\n#[cfg(not(no_borrow))]\n#[stable(feature = \"vec_from_cow_slice\", since = \"1.14.0\")]\nimpl<'a, T> From<Cow<'a, [T]>> for Vec<T>\nwhere\n    [T]: ToOwned<Owned = Vec<T>>,\n{\n    /// Convert a clone-on-write slice into a vector.\n    ///\n    /// If `s` already owns a `Vec<T>`, it will be returned directly.\n    /// If `s` is borrowing a slice, a new `Vec<T>` will be allocated and\n    /// filled by cloning `s`'s items into it.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use std::borrow::Cow;\n    /// let o: Cow<'_, [i32]> = Cow::Owned(vec![1, 2, 3]);\n    /// let b: Cow<'_, [i32]> = Cow::Borrowed(&[1, 2, 3]);\n    /// assert_eq!(Vec::from(o), Vec::from(b));\n    /// ```\n    fn from(s: Cow<'a, [T]>) -> Vec<T> {\n        s.into_owned()\n    }\n}\n\n// note: test pulls in std, which causes errors here\n#[cfg(not(test))]\n#[stable(feature = \"vec_from_box\", since = \"1.18.0\")]\nimpl<T, A: Allocator> From<Box<[T], A>> for Vec<T, A> {\n    /// Convert a boxed slice into a vector by transferring ownership of\n    /// the existing heap allocation.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let b: Box<[i32]> = vec![1, 2, 3].into_boxed_slice();\n    /// assert_eq!(Vec::from(b), vec![1, 2, 3]);\n    /// ```\n    fn from(s: Box<[T], A>) -> Self {\n        s.into_vec()\n    }\n}\n\n// note: test pulls in std, which causes errors here\n#[cfg(not(no_global_oom_handling))]\n#[cfg(not(test))]\n#[stable(feature = \"box_from_vec\", since = \"1.20.0\")]\nimpl<T, A: Allocator> From<Vec<T, A>> for Box<[T], A> {\n    /// Convert a vector into a boxed slice.\n    ///\n    /// If `v` has excess capacity, its items will be moved into a\n    /// newly-allocated buffer with exactly the right capacity.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// assert_eq!(Box::from(vec![1, 2, 3]), vec![1, 2, 3].into_boxed_slice());\n    /// ```\n    ///\n    /// Any excess capacity is removed:\n    /// ```\n    /// let mut vec = Vec::with_capacity(10);\n    /// vec.extend([1, 2, 3]);\n    ///\n    /// assert_eq!(Box::from(vec), vec![1, 2, 3].into_boxed_slice());\n    /// ```\n    fn from(v: Vec<T, A>) -> Self {\n        v.into_boxed_slice()\n    }\n}\n\n#[cfg(not(no_global_oom_handling))]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl From<&str> for Vec<u8> {\n    /// Allocate a `Vec<u8>` and fill it with a UTF-8 string.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// assert_eq!(Vec::from(\"123\"), vec![b'1', b'2', b'3']);\n    /// ```\n    fn from(s: &str) -> Vec<u8> {\n        From::from(s.as_bytes())\n    }\n}\n\n#[stable(feature = \"array_try_from_vec\", since = \"1.48.0\")]\nimpl<T, A: Allocator, const N: usize> TryFrom<Vec<T, A>> for [T; N] {\n    type Error = Vec<T, A>;\n\n    /// Gets the entire contents of the `Vec<T>` as an array,\n    /// if its size exactly matches that of the requested array.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// assert_eq!(vec![1, 2, 3].try_into(), Ok([1, 2, 3]));\n    /// assert_eq!(<Vec<i32>>::new().try_into(), Ok([]));\n    /// ```\n    ///\n    /// If the length doesn't match, the input comes back in `Err`:\n    /// ```\n    /// let r: Result<[i32; 4], _> = (0..10).collect::<Vec<_>>().try_into();\n    /// assert_eq!(r, Err(vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9]));\n    /// ```\n    ///\n    /// If you're fine with just getting a prefix of the `Vec<T>`,\n    /// you can call [`.truncate(N)`](Vec::truncate) first.\n    /// ```\n    /// let mut v = String::from(\"hello world\").into_bytes();\n    /// v.sort();\n    /// v.truncate(2);\n    /// let [a, b]: [_; 2] = v.try_into().unwrap();\n    /// assert_eq!(a, b' ');\n    /// assert_eq!(b, b'd');\n    /// ```\n    fn try_from(mut vec: Vec<T, A>) -> Result<[T; N], Vec<T, A>> {\n        if vec.len() != N {\n            return Err(vec);\n        }\n\n        // SAFETY: `.set_len(0)` is always sound.\n        unsafe { vec.set_len(0) };\n\n        // SAFETY: A `Vec`'s pointer is always aligned properly, and\n        // the alignment the array needs is the same as the items.\n        // We checked earlier that we have sufficient items.\n        // The items will not double-drop as the `set_len`\n        // tells the `Vec` not to also drop them.\n        let array = unsafe { ptr::read(vec.as_ptr() as *const [T; N]) };\n        Ok(array)\n    }\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}