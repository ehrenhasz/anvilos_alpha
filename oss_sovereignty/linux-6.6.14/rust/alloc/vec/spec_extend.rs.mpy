{
  "module_name": "spec_extend.rs",
  "hash_id": "a78740ff7918d2a53b017f41dfbe43c7526773a43b1789b5df66ca55975742e3",
  "original_prompt": "Ingested from linux-6.6.14/rust/alloc/vec/spec_extend.rs",
  "human_readable_source": "// SPDX-License-Identifier: Apache-2.0 OR MIT\n\nuse crate::alloc::Allocator;\nuse crate::collections::TryReserveError;\nuse core::iter::TrustedLen;\nuse core::slice::{self};\n\nuse super::{IntoIter, Vec};\n\n// Specialization trait used for Vec::extend\n#[cfg(not(no_global_oom_handling))]\npub(super) trait SpecExtend<T, I> {\n    fn spec_extend(&mut self, iter: I);\n}\n\n// Specialization trait used for Vec::try_extend\npub(super) trait TrySpecExtend<T, I> {\n    fn try_spec_extend(&mut self, iter: I) -> Result<(), TryReserveError>;\n}\n\n#[cfg(not(no_global_oom_handling))]\nimpl<T, I, A: Allocator> SpecExtend<T, I> for Vec<T, A>\nwhere\n    I: Iterator<Item = T>,\n{\n    default fn spec_extend(&mut self, iter: I) {\n        self.extend_desugared(iter)\n    }\n}\n\nimpl<T, I, A: Allocator> TrySpecExtend<T, I> for Vec<T, A>\nwhere\n    I: Iterator<Item = T>,\n{\n    default fn try_spec_extend(&mut self, iter: I) -> Result<(), TryReserveError> {\n        self.try_extend_desugared(iter)\n    }\n}\n\n#[cfg(not(no_global_oom_handling))]\nimpl<T, I, A: Allocator> SpecExtend<T, I> for Vec<T, A>\nwhere\n    I: TrustedLen<Item = T>,\n{\n    default fn spec_extend(&mut self, iterator: I) {\n        self.extend_trusted(iterator)\n    }\n}\n\nimpl<T, I, A: Allocator> TrySpecExtend<T, I> for Vec<T, A>\nwhere\n    I: TrustedLen<Item = T>,\n{\n    default fn try_spec_extend(&mut self, iterator: I) -> Result<(), TryReserveError> {\n        self.try_extend_trusted(iterator)\n    }\n}\n\n#[cfg(not(no_global_oom_handling))]\nimpl<T, A: Allocator> SpecExtend<T, IntoIter<T>> for Vec<T, A> {\n    fn spec_extend(&mut self, mut iterator: IntoIter<T>) {\n        unsafe {\n            self.append_elements(iterator.as_slice() as _);\n        }\n        iterator.forget_remaining_elements();\n    }\n}\n\nimpl<T, A: Allocator> TrySpecExtend<T, IntoIter<T>> for Vec<T, A> {\n    fn try_spec_extend(&mut self, mut iterator: IntoIter<T>) -> Result<(), TryReserveError> {\n        unsafe {\n            self.try_append_elements(iterator.as_slice() as _)?;\n        }\n        iterator.forget_remaining_elements();\n        Ok(())\n    }\n}\n\n#[cfg(not(no_global_oom_handling))]\nimpl<'a, T: 'a, I, A: Allocator + 'a> SpecExtend<&'a T, I> for Vec<T, A>\nwhere\n    I: Iterator<Item = &'a T>,\n    T: Clone,\n{\n    default fn spec_extend(&mut self, iterator: I) {\n        self.spec_extend(iterator.cloned())\n    }\n}\n\nimpl<'a, T: 'a, I, A: Allocator + 'a> TrySpecExtend<&'a T, I> for Vec<T, A>\nwhere\n    I: Iterator<Item = &'a T>,\n    T: Clone,\n{\n    default fn try_spec_extend(&mut self, iterator: I) -> Result<(), TryReserveError> {\n        self.try_spec_extend(iterator.cloned())\n    }\n}\n\n#[cfg(not(no_global_oom_handling))]\nimpl<'a, T: 'a, A: Allocator + 'a> SpecExtend<&'a T, slice::Iter<'a, T>> for Vec<T, A>\nwhere\n    T: Copy,\n{\n    fn spec_extend(&mut self, iterator: slice::Iter<'a, T>) {\n        let slice = iterator.as_slice();\n        unsafe { self.append_elements(slice) };\n    }\n}\n\nimpl<'a, T: 'a, A: Allocator + 'a> TrySpecExtend<&'a T, slice::Iter<'a, T>> for Vec<T, A>\nwhere\n    T: Copy,\n{\n    fn try_spec_extend(&mut self, iterator: slice::Iter<'a, T>) -> Result<(), TryReserveError> {\n        let slice = iterator.as_slice();\n        unsafe { self.try_append_elements(slice) }\n    }\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}