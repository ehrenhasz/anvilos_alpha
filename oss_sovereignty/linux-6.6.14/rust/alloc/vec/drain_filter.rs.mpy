{
  "module_name": "drain_filter.rs",
  "hash_id": "b9e57752cf577dfc66fa8cd65a5c219f8eca6c34d4192a0d70b44a8e20e7d66c",
  "original_prompt": "Ingested from linux-6.6.14/rust/alloc/vec/drain_filter.rs",
  "human_readable_source": "// SPDX-License-Identifier: Apache-2.0 OR MIT\n\nuse crate::alloc::{Allocator, Global};\nuse core::mem::{ManuallyDrop, SizedTypeProperties};\nuse core::ptr;\nuse core::slice;\n\nuse super::Vec;\n\n/// An iterator which uses a closure to determine if an element should be removed.\n///\n/// This struct is created by [`Vec::drain_filter`].\n/// See its documentation for more.\n///\n/// # Example\n///\n/// ```\n/// #![feature(drain_filter)]\n///\n/// let mut v = vec![0, 1, 2];\n/// let iter: std::vec::DrainFilter<'_, _, _> = v.drain_filter(|x| *x % 2 == 0);\n/// ```\n#[unstable(feature = \"drain_filter\", reason = \"recently added\", issue = \"43244\")]\n#[derive(Debug)]\npub struct DrainFilter<\n    'a,\n    T,\n    F,\n    #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: Allocator = Global,\n> where\n    F: FnMut(&mut T) -> bool,\n{\n    pub(super) vec: &'a mut Vec<T, A>,\n    /// The index of the item that will be inspected by the next call to `next`.\n    pub(super) idx: usize,\n    /// The number of items that have been drained (removed) thus far.\n    pub(super) del: usize,\n    /// The original length of `vec` prior to draining.\n    pub(super) old_len: usize,\n    /// The filter test predicate.\n    pub(super) pred: F,\n    /// A flag that indicates a panic has occurred in the filter test predicate.\n    /// This is used as a hint in the drop implementation to prevent consumption\n    /// of the remainder of the `DrainFilter`. Any unprocessed items will be\n    /// backshifted in the `vec`, but no further items will be dropped or\n    /// tested by the filter predicate.\n    pub(super) panic_flag: bool,\n}\n\nimpl<T, F, A: Allocator> DrainFilter<'_, T, F, A>\nwhere\n    F: FnMut(&mut T) -> bool,\n{\n    /// Returns a reference to the underlying allocator.\n    #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n    #[inline]\n    pub fn allocator(&self) -> &A {\n        self.vec.allocator()\n    }\n\n    /// Keep unyielded elements in the source `Vec`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(drain_filter)]\n    /// #![feature(drain_keep_rest)]\n    ///\n    /// let mut vec = vec!['a', 'b', 'c'];\n    /// let mut drain = vec.drain_filter(|_| true);\n    ///\n    /// assert_eq!(drain.next().unwrap(), 'a');\n    ///\n    /// // This call keeps 'b' and 'c' in the vec.\n    /// drain.keep_rest();\n    ///\n    /// // If we wouldn't call `keep_rest()`,\n    /// // `vec` would be empty.\n    /// assert_eq!(vec, ['b', 'c']);\n    /// ```\n    #[unstable(feature = \"drain_keep_rest\", issue = \"101122\")]\n    pub fn keep_rest(self) {\n        // At this moment layout looks like this:\n        //\n        //  _____________________/-- old_len\n        // /                     \\\n        // [kept] [yielded] [tail]\n        //        \\_______/ ^-- idx\n        //                \\-- del\n        //\n        // Normally `Drop` impl would drop [tail] (via .for_each(drop), ie still calling `pred`)\n        //\n        // 1. Move [tail] after [kept]\n        // 2. Update length of the original vec to `old_len - del`\n        //    a. In case of ZST, this is the only thing we want to do\n        // 3. Do *not* drop self, as everything is put in a consistent state already, there is nothing to do\n        let mut this = ManuallyDrop::new(self);\n\n        unsafe {\n            // ZSTs have no identity, so we don't need to move them around.\n            if !T::IS_ZST && this.idx < this.old_len && this.del > 0 {\n                let ptr = this.vec.as_mut_ptr();\n                let src = ptr.add(this.idx);\n                let dst = src.sub(this.del);\n                let tail_len = this.old_len - this.idx;\n                src.copy_to(dst, tail_len);\n            }\n\n            let new_len = this.old_len - this.del;\n            this.vec.set_len(new_len);\n        }\n    }\n}\n\n#[unstable(feature = \"drain_filter\", reason = \"recently added\", issue = \"43244\")]\nimpl<T, F, A: Allocator> Iterator for DrainFilter<'_, T, F, A>\nwhere\n    F: FnMut(&mut T) -> bool,\n{\n    type Item = T;\n\n    fn next(&mut self) -> Option<T> {\n        unsafe {\n            while self.idx < self.old_len {\n                let i = self.idx;\n                let v = slice::from_raw_parts_mut(self.vec.as_mut_ptr(), self.old_len);\n                self.panic_flag = true;\n                let drained = (self.pred)(&mut v[i]);\n                self.panic_flag = false;\n                // Update the index *after* the predicate is called. If the index\n                // is updated prior and the predicate panics, the element at this\n                // index would be leaked.\n                self.idx += 1;\n                if drained {\n                    self.del += 1;\n                    return Some(ptr::read(&v[i]));\n                } else if self.del > 0 {\n                    let del = self.del;\n                    let src: *const T = &v[i];\n                    let dst: *mut T = &mut v[i - del];\n                    ptr::copy_nonoverlapping(src, dst, 1);\n                }\n            }\n            None\n        }\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        (0, Some(self.old_len - self.idx))\n    }\n}\n\n#[unstable(feature = \"drain_filter\", reason = \"recently added\", issue = \"43244\")]\nimpl<T, F, A: Allocator> Drop for DrainFilter<'_, T, F, A>\nwhere\n    F: FnMut(&mut T) -> bool,\n{\n    fn drop(&mut self) {\n        struct BackshiftOnDrop<'a, 'b, T, F, A: Allocator>\n        where\n            F: FnMut(&mut T) -> bool,\n        {\n            drain: &'b mut DrainFilter<'a, T, F, A>,\n        }\n\n        impl<'a, 'b, T, F, A: Allocator> Drop for BackshiftOnDrop<'a, 'b, T, F, A>\n        where\n            F: FnMut(&mut T) -> bool,\n        {\n            fn drop(&mut self) {\n                unsafe {\n                    if self.drain.idx < self.drain.old_len && self.drain.del > 0 {\n                        // This is a pretty messed up state, and there isn't really an\n                        // obviously right thing to do. We don't want to keep trying\n                        // to execute `pred`, so we just backshift all the unprocessed\n                        // elements and tell the vec that they still exist. The backshift\n                        // is required to prevent a double-drop of the last successfully\n                        // drained item prior to a panic in the predicate.\n                        let ptr = self.drain.vec.as_mut_ptr();\n                        let src = ptr.add(self.drain.idx);\n                        let dst = src.sub(self.drain.del);\n                        let tail_len = self.drain.old_len - self.drain.idx;\n                        src.copy_to(dst, tail_len);\n                    }\n                    self.drain.vec.set_len(self.drain.old_len - self.drain.del);\n                }\n            }\n        }\n\n        let backshift = BackshiftOnDrop { drain: self };\n\n        // Attempt to consume any remaining elements if the filter predicate\n        // has not yet panicked. We'll backshift any remaining elements\n        // whether we've already panicked or if the consumption here panics.\n        if !backshift.drain.panic_flag {\n            backshift.drain.for_each(drop);\n        }\n    }\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}