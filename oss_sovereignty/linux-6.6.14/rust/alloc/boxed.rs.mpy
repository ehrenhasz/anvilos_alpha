{
  "module_name": "boxed.rs",
  "hash_id": "0ec8b6dc84090150e4c1fc7dc83b7b1ef0281b2362244b54b87af4575898edc1",
  "original_prompt": "Ingested from linux-6.6.14/rust/alloc/boxed.rs",
  "human_readable_source": "// SPDX-License-Identifier: Apache-2.0 OR MIT\n\n//! The `Box<T>` type for heap allocation.\n//!\n//! [`Box<T>`], casually referred to as a 'box', provides the simplest form of\n//! heap allocation in Rust. Boxes provide ownership for this allocation, and\n//! drop their contents when they go out of scope. Boxes also ensure that they\n//! never allocate more than `isize::MAX` bytes.\n//!\n//! # Examples\n//!\n//! Move a value from the stack to the heap by creating a [`Box`]:\n//!\n//! ```\n//! let val: u8 = 5;\n//! let boxed: Box<u8> = Box::new(val);\n//! ```\n//!\n//! Move a value from a [`Box`] back to the stack by [dereferencing]:\n//!\n//! ```\n//! let boxed: Box<u8> = Box::new(5);\n//! let val: u8 = *boxed;\n//! ```\n//!\n//! Creating a recursive data structure:\n//!\n//! ```\n//! #[derive(Debug)]\n//! enum List<T> {\n//!     Cons(T, Box<List<T>>),\n//!     Nil,\n//! }\n//!\n//! let list: List<i32> = List::Cons(1, Box::new(List::Cons(2, Box::new(List::Nil))));\n//! println!(\"{list:?}\");\n//! ```\n//!\n//! This will print `Cons(1, Cons(2, Nil))`.\n//!\n//! Recursive structures must be boxed, because if the definition of `Cons`\n//! looked like this:\n//!\n//! ```compile_fail,E0072\n//! # enum List<T> {\n//! Cons(T, List<T>),\n//! # }\n//! ```\n//!\n//! It wouldn't work. This is because the size of a `List` depends on how many\n//! elements are in the list, and so we don't know how much memory to allocate\n//! for a `Cons`. By introducing a [`Box<T>`], which has a defined size, we know how\n//! big `Cons` needs to be.\n//!\n//! # Memory layout\n//!\n//! For non-zero-sized values, a [`Box`] will use the [`Global`] allocator for\n//! its allocation. It is valid to convert both ways between a [`Box`] and a\n//! raw pointer allocated with the [`Global`] allocator, given that the\n//! [`Layout`] used with the allocator is correct for the type. More precisely,\n//! a `value: *mut T` that has been allocated with the [`Global`] allocator\n//! with `Layout::for_value(&*value)` may be converted into a box using\n//! [`Box::<T>::from_raw(value)`]. Conversely, the memory backing a `value: *mut\n//! T` obtained from [`Box::<T>::into_raw`] may be deallocated using the\n//! [`Global`] allocator with [`Layout::for_value(&*value)`].\n//!\n//! For zero-sized values, the `Box` pointer still has to be [valid] for reads\n//! and writes and sufficiently aligned. In particular, casting any aligned\n//! non-zero integer literal to a raw pointer produces a valid pointer, but a\n//! pointer pointing into previously allocated memory that since got freed is\n//! not valid. The recommended way to build a Box to a ZST if `Box::new` cannot\n//! be used is to use [`ptr::NonNull::dangling`].\n//!\n//! So long as `T: Sized`, a `Box<T>` is guaranteed to be represented\n//! as a single pointer and is also ABI-compatible with C pointers\n//! (i.e. the C type `T*`). This means that if you have extern \"C\"\n//! Rust functions that will be called from C, you can define those\n//! Rust functions using `Box<T>` types, and use `T*` as corresponding\n//! type on the C side. As an example, consider this C header which\n//! declares functions that create and destroy some kind of `Foo`\n//! value:\n//!\n//! ```c\n//! /* C header */\n//!\n//! /* Returns ownership to the caller */\n//! struct Foo* foo_new(void);\n//!\n//! /* Takes ownership from the caller; no-op when invoked with null */\n//! void foo_delete(struct Foo*);\n//! ```\n//!\n//! These two functions might be implemented in Rust as follows. Here, the\n//! `struct Foo*` type from C is translated to `Box<Foo>`, which captures\n//! the ownership constraints. Note also that the nullable argument to\n//! `foo_delete` is represented in Rust as `Option<Box<Foo>>`, since `Box<Foo>`\n//! cannot be null.\n//!\n//! ```\n//! #[repr(C)]\n//! pub struct Foo;\n//!\n//! #[no_mangle]\n//! pub extern \"C\" fn foo_new() -> Box<Foo> {\n//!     Box::new(Foo)\n//! }\n//!\n//! #[no_mangle]\n//! pub extern \"C\" fn foo_delete(_: Option<Box<Foo>>) {}\n//! ```\n//!\n//! Even though `Box<T>` has the same representation and C ABI as a C pointer,\n//! this does not mean that you can convert an arbitrary `T*` into a `Box<T>`\n//! and expect things to work. `Box<T>` values will always be fully aligned,\n//! non-null pointers. Moreover, the destructor for `Box<T>` will attempt to\n//! free the value with the global allocator. In general, the best practice\n//! is to only use `Box<T>` for pointers that originated from the global\n//! allocator.\n//!\n//! **Important.** At least at present, you should avoid using\n//! `Box<T>` types for functions that are defined in C but invoked\n//! from Rust. In those cases, you should directly mirror the C types\n//! as closely as possible. Using types like `Box<T>` where the C\n//! definition is just using `T*` can lead to undefined behavior, as\n//! described in [rust-lang/unsafe-code-guidelines#198][ucg#198].\n//!\n//! # Considerations for unsafe code\n//!\n//! **Warning: This section is not normative and is subject to change, possibly\n//! being relaxed in the future! It is a simplified summary of the rules\n//! currently implemented in the compiler.**\n//!\n//! The aliasing rules for `Box<T>` are the same as for `&mut T`. `Box<T>`\n//! asserts uniqueness over its content. Using raw pointers derived from a box\n//! after that box has been mutated through, moved or borrowed as `&mut T`\n//! is not allowed. For more guidance on working with box from unsafe code, see\n//! [rust-lang/unsafe-code-guidelines#326][ucg#326].\n//!\n//!\n//! [ucg#198]: https://github.com/rust-lang/unsafe-code-guidelines/issues/198\n//! [ucg#326]: https://github.com/rust-lang/unsafe-code-guidelines/issues/326\n//! [dereferencing]: core::ops::Deref\n//! [`Box::<T>::from_raw(value)`]: Box::from_raw\n//! [`Global`]: crate::alloc::Global\n//! [`Layout`]: crate::alloc::Layout\n//! [`Layout::for_value(&*value)`]: crate::alloc::Layout::for_value\n//! [valid]: ptr#safety\n\n#![stable(feature = \"rust1\", since = \"1.0.0\")]\n\nuse core::any::Any;\nuse core::async_iter::AsyncIterator;\nuse core::borrow;\nuse core::cmp::Ordering;\nuse core::error::Error;\nuse core::fmt;\nuse core::future::Future;\nuse core::hash::{Hash, Hasher};\nuse core::iter::FusedIterator;\nuse core::marker::Tuple;\nuse core::marker::Unsize;\nuse core::mem;\nuse core::ops::{\n    CoerceUnsized, Deref, DerefMut, DispatchFromDyn, Generator, GeneratorState, Receiver,\n};\nuse core::pin::Pin;\nuse core::ptr::{self, Unique};\nuse core::task::{Context, Poll};\n\n#[cfg(not(no_global_oom_handling))]\nuse crate::alloc::{handle_alloc_error, WriteCloneIntoRaw};\nuse crate::alloc::{AllocError, Allocator, Global, Layout};\n#[cfg(not(no_global_oom_handling))]\nuse crate::borrow::Cow;\nuse crate::raw_vec::RawVec;\n#[cfg(not(no_global_oom_handling))]\nuse crate::str::from_boxed_utf8_unchecked;\n#[cfg(not(no_global_oom_handling))]\nuse crate::string::String;\n#[cfg(not(no_global_oom_handling))]\nuse crate::vec::Vec;\n\n#[cfg(not(no_thin))]\n#[unstable(feature = \"thin_box\", issue = \"92791\")]\npub use thin::ThinBox;\n\n#[cfg(not(no_thin))]\nmod thin;\n\n/// A pointer type that uniquely owns a heap allocation of type `T`.\n///\n/// See the [module-level documentation](../../std/boxed/index.html) for more.\n#[lang = \"owned_box\"]\n#[fundamental]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\n// The declaration of the `Box` struct must be kept in sync with the\n// `alloc::alloc::box_free` function or ICEs will happen. See the comment\n// on `box_free` for more details.\npub struct Box<\n    T: ?Sized,\n    #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: Allocator = Global,\n>(Unique<T>, A);\n\nimpl<T> Box<T> {\n    /// Allocates memory on the heap and then places `x` into it.\n    ///\n    /// This doesn't actually allocate if `T` is zero-sized.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let five = Box::new(5);\n    /// ```\n    #[cfg(all(not(no_global_oom_handling)))]\n    #[inline(always)]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[must_use]\n    #[rustc_diagnostic_item = \"box_new\"]\n    pub fn new(x: T) -> Self {\n        #[rustc_box]\n        Box::new(x)\n    }\n\n    /// Constructs a new box with uninitialized contents.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(new_uninit)]\n    ///\n    /// let mut five = Box::<u32>::new_uninit();\n    ///\n    /// let five = unsafe {\n    ///     // Deferred initialization:\n    ///     five.as_mut_ptr().write(5);\n    ///\n    ///     five.assume_init()\n    /// };\n    ///\n    /// assert_eq!(*five, 5)\n    /// ```\n    #[cfg(not(no_global_oom_handling))]\n    #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n    #[must_use]\n    #[inline]\n    pub fn new_uninit() -> Box<mem::MaybeUninit<T>> {\n        Self::new_uninit_in(Global)\n    }\n\n    /// Constructs a new `Box` with uninitialized contents, with the memory\n    /// being filled with `0` bytes.\n    ///\n    /// See [`MaybeUninit::zeroed`][zeroed] for examples of correct and incorrect usage\n    /// of this method.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(new_uninit)]\n    ///\n    /// let zero = Box::<u32>::new_zeroed();\n    /// let zero = unsafe { zero.assume_init() };\n    ///\n    /// assert_eq!(*zero, 0)\n    /// ```\n    ///\n    /// [zeroed]: mem::MaybeUninit::zeroed\n    #[cfg(not(no_global_oom_handling))]\n    #[inline]\n    #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n    #[must_use]\n    pub fn new_zeroed() -> Box<mem::MaybeUninit<T>> {\n        Self::new_zeroed_in(Global)\n    }\n\n    /// Constructs a new `Pin<Box<T>>`. If `T` does not implement [`Unpin`], then\n    /// `x` will be pinned in memory and unable to be moved.\n    ///\n    /// Constructing and pinning of the `Box` can also be done in two steps: `Box::pin(x)`\n    /// does the same as <code>[Box::into_pin]\\([Box::new]\\(x))</code>. Consider using\n    /// [`into_pin`](Box::into_pin) if you already have a `Box<T>`, or if you want to\n    /// construct a (pinned) `Box` in a different way than with [`Box::new`].\n    #[cfg(not(no_global_oom_handling))]\n    #[stable(feature = \"pin\", since = \"1.33.0\")]\n    #[must_use]\n    #[inline(always)]\n    pub fn pin(x: T) -> Pin<Box<T>> {\n        Box::new(x).into()\n    }\n\n    /// Allocates memory on the heap then places `x` into it,\n    /// returning an error if the allocation fails\n    ///\n    /// This doesn't actually allocate if `T` is zero-sized.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(allocator_api)]\n    ///\n    /// let five = Box::try_new(5)?;\n    /// # Ok::<(), std::alloc::AllocError>(())\n    /// ```\n    #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n    #[inline]\n    pub fn try_new(x: T) -> Result<Self, AllocError> {\n        Self::try_new_in(x, Global)\n    }\n\n    /// Constructs a new box with uninitialized contents on the heap,\n    /// returning an error if the allocation fails\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(allocator_api, new_uninit)]\n    ///\n    /// let mut five = Box::<u32>::try_new_uninit()?;\n    ///\n    /// let five = unsafe {\n    ///     // Deferred initialization:\n    ///     five.as_mut_ptr().write(5);\n    ///\n    ///     five.assume_init()\n    /// };\n    ///\n    /// assert_eq!(*five, 5);\n    /// # Ok::<(), std::alloc::AllocError>(())\n    /// ```\n    #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n    // #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n    #[inline]\n    pub fn try_new_uninit() -> Result<Box<mem::MaybeUninit<T>>, AllocError> {\n        Box::try_new_uninit_in(Global)\n    }\n\n    /// Constructs a new `Box` with uninitialized contents, with the memory\n    /// being filled with `0` bytes on the heap\n    ///\n    /// See [`MaybeUninit::zeroed`][zeroed] for examples of correct and incorrect usage\n    /// of this method.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(allocator_api, new_uninit)]\n    ///\n    /// let zero = Box::<u32>::try_new_zeroed()?;\n    /// let zero = unsafe { zero.assume_init() };\n    ///\n    /// assert_eq!(*zero, 0);\n    /// # Ok::<(), std::alloc::AllocError>(())\n    /// ```\n    ///\n    /// [zeroed]: mem::MaybeUninit::zeroed\n    #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n    // #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n    #[inline]\n    pub fn try_new_zeroed() -> Result<Box<mem::MaybeUninit<T>>, AllocError> {\n        Box::try_new_zeroed_in(Global)\n    }\n}\n\nimpl<T, A: Allocator> Box<T, A> {\n    /// Allocates memory in the given allocator then places `x` into it.\n    ///\n    /// This doesn't actually allocate if `T` is zero-sized.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(allocator_api)]\n    ///\n    /// use std::alloc::System;\n    ///\n    /// let five = Box::new_in(5, System);\n    /// ```\n    #[cfg(not(no_global_oom_handling))]\n    #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n    #[must_use]\n    #[inline]\n    pub fn new_in(x: T, alloc: A) -> Self\n    where\n        A: Allocator,\n    {\n        let mut boxed = Self::new_uninit_in(alloc);\n        unsafe {\n            boxed.as_mut_ptr().write(x);\n            boxed.assume_init()\n        }\n    }\n\n    /// Allocates memory in the given allocator then places `x` into it,\n    /// returning an error if the allocation fails\n    ///\n    /// This doesn't actually allocate if `T` is zero-sized.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(allocator_api)]\n    ///\n    /// use std::alloc::System;\n    ///\n    /// let five = Box::try_new_in(5, System)?;\n    /// # Ok::<(), std::alloc::AllocError>(())\n    /// ```\n    #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n    #[inline]\n    pub fn try_new_in(x: T, alloc: A) -> Result<Self, AllocError>\n    where\n        A: Allocator,\n    {\n        let mut boxed = Self::try_new_uninit_in(alloc)?;\n        unsafe {\n            boxed.as_mut_ptr().write(x);\n            Ok(boxed.assume_init())\n        }\n    }\n\n    /// Constructs a new box with uninitialized contents in the provided allocator.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(allocator_api, new_uninit)]\n    ///\n    /// use std::alloc::System;\n    ///\n    /// let mut five = Box::<u32, _>::new_uninit_in(System);\n    ///\n    /// let five = unsafe {\n    ///     // Deferred initialization:\n    ///     five.as_mut_ptr().write(5);\n    ///\n    ///     five.assume_init()\n    /// };\n    ///\n    /// assert_eq!(*five, 5)\n    /// ```\n    #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n    #[cfg(not(no_global_oom_handling))]\n    #[must_use]\n    // #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n    pub fn new_uninit_in(alloc: A) -> Box<mem::MaybeUninit<T>, A>\n    where\n        A: Allocator,\n    {\n        let layout = Layout::new::<mem::MaybeUninit<T>>();\n        // NOTE: Prefer match over unwrap_or_else since closure sometimes not inlineable.\n        // That would make code size bigger.\n        match Box::try_new_uninit_in(alloc) {\n            Ok(m) => m,\n            Err(_) => handle_alloc_error(layout),\n        }\n    }\n\n    /// Constructs a new box with uninitialized contents in the provided allocator,\n    /// returning an error if the allocation fails\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(allocator_api, new_uninit)]\n    ///\n    /// use std::alloc::System;\n    ///\n    /// let mut five = Box::<u32, _>::try_new_uninit_in(System)?;\n    ///\n    /// let five = unsafe {\n    ///     // Deferred initialization:\n    ///     five.as_mut_ptr().write(5);\n    ///\n    ///     five.assume_init()\n    /// };\n    ///\n    /// assert_eq!(*five, 5);\n    /// # Ok::<(), std::alloc::AllocError>(())\n    /// ```\n    #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n    // #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n    pub fn try_new_uninit_in(alloc: A) -> Result<Box<mem::MaybeUninit<T>, A>, AllocError>\n    where\n        A: Allocator,\n    {\n        let layout = Layout::new::<mem::MaybeUninit<T>>();\n        let ptr = alloc.allocate(layout)?.cast();\n        unsafe { Ok(Box::from_raw_in(ptr.as_ptr(), alloc)) }\n    }\n\n    /// Constructs a new `Box` with uninitialized contents, with the memory\n    /// being filled with `0` bytes in the provided allocator.\n    ///\n    /// See [`MaybeUninit::zeroed`][zeroed] for examples of correct and incorrect usage\n    /// of this method.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(allocator_api, new_uninit)]\n    ///\n    /// use std::alloc::System;\n    ///\n    /// let zero = Box::<u32, _>::new_zeroed_in(System);\n    /// let zero = unsafe { zero.assume_init() };\n    ///\n    /// assert_eq!(*zero, 0)\n    /// ```\n    ///\n    /// [zeroed]: mem::MaybeUninit::zeroed\n    #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n    #[cfg(not(no_global_oom_handling))]\n    // #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n    #[must_use]\n    pub fn new_zeroed_in(alloc: A) -> Box<mem::MaybeUninit<T>, A>\n    where\n        A: Allocator,\n    {\n        let layout = Layout::new::<mem::MaybeUninit<T>>();\n        // NOTE: Prefer match over unwrap_or_else since closure sometimes not inlineable.\n        // That would make code size bigger.\n        match Box::try_new_zeroed_in(alloc) {\n            Ok(m) => m,\n            Err(_) => handle_alloc_error(layout),\n        }\n    }\n\n    /// Constructs a new `Box` with uninitialized contents, with the memory\n    /// being filled with `0` bytes in the provided allocator,\n    /// returning an error if the allocation fails,\n    ///\n    /// See [`MaybeUninit::zeroed`][zeroed] for examples of correct and incorrect usage\n    /// of this method.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(allocator_api, new_uninit)]\n    ///\n    /// use std::alloc::System;\n    ///\n    /// let zero = Box::<u32, _>::try_new_zeroed_in(System)?;\n    /// let zero = unsafe { zero.assume_init() };\n    ///\n    /// assert_eq!(*zero, 0);\n    /// # Ok::<(), std::alloc::AllocError>(())\n    /// ```\n    ///\n    /// [zeroed]: mem::MaybeUninit::zeroed\n    #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n    // #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n    pub fn try_new_zeroed_in(alloc: A) -> Result<Box<mem::MaybeUninit<T>, A>, AllocError>\n    where\n        A: Allocator,\n    {\n        let layout = Layout::new::<mem::MaybeUninit<T>>();\n        let ptr = alloc.allocate_zeroed(layout)?.cast();\n        unsafe { Ok(Box::from_raw_in(ptr.as_ptr(), alloc)) }\n    }\n\n    /// Constructs a new `Pin<Box<T, A>>`. If `T` does not implement [`Unpin`], then\n    /// `x` will be pinned in memory and unable to be moved.\n    ///\n    /// Constructing and pinning of the `Box` can also be done in two steps: `Box::pin_in(x, alloc)`\n    /// does the same as <code>[Box::into_pin]\\([Box::new_in]\\(x, alloc))</code>. Consider using\n    /// [`into_pin`](Box::into_pin) if you already have a `Box<T, A>`, or if you want to\n    /// construct a (pinned) `Box` in a different way than with [`Box::new_in`].\n    #[cfg(not(no_global_oom_handling))]\n    #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n    #[must_use]\n    #[inline(always)]\n    pub fn pin_in(x: T, alloc: A) -> Pin<Self>\n    where\n        A: 'static + Allocator,\n    {\n        Self::into_pin(Self::new_in(x, alloc))\n    }\n\n    /// Converts a `Box<T>` into a `Box<[T]>`\n    ///\n    /// This conversion does not allocate on the heap and happens in place.\n    #[unstable(feature = \"box_into_boxed_slice\", issue = \"71582\")]\n    pub fn into_boxed_slice(boxed: Self) -> Box<[T], A> {\n        let (raw, alloc) = Box::into_raw_with_allocator(boxed);\n        unsafe { Box::from_raw_in(raw as *mut [T; 1], alloc) }\n    }\n\n    /// Consumes the `Box`, returning the wrapped value.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(box_into_inner)]\n    ///\n    /// let c = Box::new(5);\n    ///\n    /// assert_eq!(Box::into_inner(c), 5);\n    /// ```\n    #[unstable(feature = \"box_into_inner\", issue = \"80437\")]\n    #[inline]\n    pub fn into_inner(boxed: Self) -> T {\n        *boxed\n    }\n}\n\nimpl<T> Box<[T]> {\n    /// Constructs a new boxed slice with uninitialized contents.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(new_uninit)]\n    ///\n    /// let mut values = Box::<[u32]>::new_uninit_slice(3);\n    ///\n    /// let values = unsafe {\n    ///     // Deferred initialization:\n    ///     values[0].as_mut_ptr().write(1);\n    ///     values[1].as_mut_ptr().write(2);\n    ///     values[2].as_mut_ptr().write(3);\n    ///\n    ///     values.assume_init()\n    /// };\n    ///\n    /// assert_eq!(*values, [1, 2, 3])\n    /// ```\n    #[cfg(not(no_global_oom_handling))]\n    #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n    #[must_use]\n    pub fn new_uninit_slice(len: usize) -> Box<[mem::MaybeUninit<T>]> {\n        unsafe { RawVec::with_capacity(len).into_box(len) }\n    }\n\n    /// Constructs a new boxed slice with uninitialized contents, with the memory\n    /// being filled with `0` bytes.\n    ///\n    /// See [`MaybeUninit::zeroed`][zeroed] for examples of correct and incorrect usage\n    /// of this method.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(new_uninit)]\n    ///\n    /// let values = Box::<[u32]>::new_zeroed_slice(3);\n    /// let values = unsafe { values.assume_init() };\n    ///\n    /// assert_eq!(*values, [0, 0, 0])\n    /// ```\n    ///\n    /// [zeroed]: mem::MaybeUninit::zeroed\n    #[cfg(not(no_global_oom_handling))]\n    #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n    #[must_use]\n    pub fn new_zeroed_slice(len: usize) -> Box<[mem::MaybeUninit<T>]> {\n        unsafe { RawVec::with_capacity_zeroed(len).into_box(len) }\n    }\n\n    /// Constructs a new boxed slice with uninitialized contents. Returns an error if\n    /// the allocation fails\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(allocator_api, new_uninit)]\n    ///\n    /// let mut values = Box::<[u32]>::try_new_uninit_slice(3)?;\n    /// let values = unsafe {\n    ///     // Deferred initialization:\n    ///     values[0].as_mut_ptr().write(1);\n    ///     values[1].as_mut_ptr().write(2);\n    ///     values[2].as_mut_ptr().write(3);\n    ///     values.assume_init()\n    /// };\n    ///\n    /// assert_eq!(*values, [1, 2, 3]);\n    /// # Ok::<(), std::alloc::AllocError>(())\n    /// ```\n    #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n    #[inline]\n    pub fn try_new_uninit_slice(len: usize) -> Result<Box<[mem::MaybeUninit<T>]>, AllocError> {\n        unsafe {\n            let layout = match Layout::array::<mem::MaybeUninit<T>>(len) {\n                Ok(l) => l,\n                Err(_) => return Err(AllocError),\n            };\n            let ptr = Global.allocate(layout)?;\n            Ok(RawVec::from_raw_parts_in(ptr.as_mut_ptr() as *mut _, len, Global).into_box(len))\n        }\n    }\n\n    /// Constructs a new boxed slice with uninitialized contents, with the memory\n    /// being filled with `0` bytes. Returns an error if the allocation fails\n    ///\n    /// See [`MaybeUninit::zeroed`][zeroed] for examples of correct and incorrect usage\n    /// of this method.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(allocator_api, new_uninit)]\n    ///\n    /// let values = Box::<[u32]>::try_new_zeroed_slice(3)?;\n    /// let values = unsafe { values.assume_init() };\n    ///\n    /// assert_eq!(*values, [0, 0, 0]);\n    /// # Ok::<(), std::alloc::AllocError>(())\n    /// ```\n    ///\n    /// [zeroed]: mem::MaybeUninit::zeroed\n    #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n    #[inline]\n    pub fn try_new_zeroed_slice(len: usize) -> Result<Box<[mem::MaybeUninit<T>]>, AllocError> {\n        unsafe {\n            let layout = match Layout::array::<mem::MaybeUninit<T>>(len) {\n                Ok(l) => l,\n                Err(_) => return Err(AllocError),\n            };\n            let ptr = Global.allocate_zeroed(layout)?;\n            Ok(RawVec::from_raw_parts_in(ptr.as_mut_ptr() as *mut _, len, Global).into_box(len))\n        }\n    }\n}\n\nimpl<T, A: Allocator> Box<[T], A> {\n    /// Constructs a new boxed slice with uninitialized contents in the provided allocator.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(allocator_api, new_uninit)]\n    ///\n    /// use std::alloc::System;\n    ///\n    /// let mut values = Box::<[u32], _>::new_uninit_slice_in(3, System);\n    ///\n    /// let values = unsafe {\n    ///     // Deferred initialization:\n    ///     values[0].as_mut_ptr().write(1);\n    ///     values[1].as_mut_ptr().write(2);\n    ///     values[2].as_mut_ptr().write(3);\n    ///\n    ///     values.assume_init()\n    /// };\n    ///\n    /// assert_eq!(*values, [1, 2, 3])\n    /// ```\n    #[cfg(not(no_global_oom_handling))]\n    #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n    // #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n    #[must_use]\n    pub fn new_uninit_slice_in(len: usize, alloc: A) -> Box<[mem::MaybeUninit<T>], A> {\n        unsafe { RawVec::with_capacity_in(len, alloc).into_box(len) }\n    }\n\n    /// Constructs a new boxed slice with uninitialized contents in the provided allocator,\n    /// with the memory being filled with `0` bytes.\n    ///\n    /// See [`MaybeUninit::zeroed`][zeroed] for examples of correct and incorrect usage\n    /// of this method.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(allocator_api, new_uninit)]\n    ///\n    /// use std::alloc::System;\n    ///\n    /// let values = Box::<[u32], _>::new_zeroed_slice_in(3, System);\n    /// let values = unsafe { values.assume_init() };\n    ///\n    /// assert_eq!(*values, [0, 0, 0])\n    /// ```\n    ///\n    /// [zeroed]: mem::MaybeUninit::zeroed\n    #[cfg(not(no_global_oom_handling))]\n    #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n    // #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n    #[must_use]\n    pub fn new_zeroed_slice_in(len: usize, alloc: A) -> Box<[mem::MaybeUninit<T>], A> {\n        unsafe { RawVec::with_capacity_zeroed_in(len, alloc).into_box(len) }\n    }\n}\n\nimpl<T, A: Allocator> Box<mem::MaybeUninit<T>, A> {\n    /// Converts to `Box<T, A>`.\n    ///\n    /// # Safety\n    ///\n    /// As with [`MaybeUninit::assume_init`],\n    /// it is up to the caller to guarantee that the value\n    /// really is in an initialized state.\n    /// Calling this when the content is not yet fully initialized\n    /// causes immediate undefined behavior.\n    ///\n    /// [`MaybeUninit::assume_init`]: mem::MaybeUninit::assume_init\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(new_uninit)]\n    ///\n    /// let mut five = Box::<u32>::new_uninit();\n    ///\n    /// let five: Box<u32> = unsafe {\n    ///     // Deferred initialization:\n    ///     five.as_mut_ptr().write(5);\n    ///\n    ///     five.assume_init()\n    /// };\n    ///\n    /// assert_eq!(*five, 5)\n    /// ```\n    #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n    #[inline]\n    pub unsafe fn assume_init(self) -> Box<T, A> {\n        let (raw, alloc) = Box::into_raw_with_allocator(self);\n        unsafe { Box::from_raw_in(raw as *mut T, alloc) }\n    }\n\n    /// Writes the value and converts to `Box<T, A>`.\n    ///\n    /// This method converts the box similarly to [`Box::assume_init`] but\n    /// writes `value` into it before conversion thus guaranteeing safety.\n    /// In some scenarios use of this method may improve performance because\n    /// the compiler may be able to optimize copying from stack.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(new_uninit)]\n    ///\n    /// let big_box = Box::<[usize; 1024]>::new_uninit();\n    ///\n    /// let mut array = [0; 1024];\n    /// for (i, place) in array.iter_mut().enumerate() {\n    ///     *place = i;\n    /// }\n    ///\n    /// // The optimizer may be able to elide this copy, so previous code writes\n    /// // to heap directly.\n    /// let big_box = Box::write(big_box, array);\n    ///\n    /// for (i, x) in big_box.iter().enumerate() {\n    ///     assert_eq!(*x, i);\n    /// }\n    /// ```\n    #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n    #[inline]\n    pub fn write(mut boxed: Self, value: T) -> Box<T, A> {\n        unsafe {\n            (*boxed).write(value);\n            boxed.assume_init()\n        }\n    }\n}\n\nimpl<T, A: Allocator> Box<[mem::MaybeUninit<T>], A> {\n    /// Converts to `Box<[T], A>`.\n    ///\n    /// # Safety\n    ///\n    /// As with [`MaybeUninit::assume_init`],\n    /// it is up to the caller to guarantee that the values\n    /// really are in an initialized state.\n    /// Calling this when the content is not yet fully initialized\n    /// causes immediate undefined behavior.\n    ///\n    /// [`MaybeUninit::assume_init`]: mem::MaybeUninit::assume_init\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(new_uninit)]\n    ///\n    /// let mut values = Box::<[u32]>::new_uninit_slice(3);\n    ///\n    /// let values = unsafe {\n    ///     // Deferred initialization:\n    ///     values[0].as_mut_ptr().write(1);\n    ///     values[1].as_mut_ptr().write(2);\n    ///     values[2].as_mut_ptr().write(3);\n    ///\n    ///     values.assume_init()\n    /// };\n    ///\n    /// assert_eq!(*values, [1, 2, 3])\n    /// ```\n    #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n    #[inline]\n    pub unsafe fn assume_init(self) -> Box<[T], A> {\n        let (raw, alloc) = Box::into_raw_with_allocator(self);\n        unsafe { Box::from_raw_in(raw as *mut [T], alloc) }\n    }\n}\n\nimpl<T: ?Sized> Box<T> {\n    /// Constructs a box from a raw pointer.\n    ///\n    /// After calling this function, the raw pointer is owned by the\n    /// resulting `Box`. Specifically, the `Box` destructor will call\n    /// the destructor of `T` and free the allocated memory. For this\n    /// to be safe, the memory must have been allocated in accordance\n    /// with the [memory layout] used by `Box` .\n    ///\n    /// # Safety\n    ///\n    /// This function is unsafe because improper use may lead to\n    /// memory problems. For example, a double-free may occur if the\n    /// function is called twice on the same raw pointer.\n    ///\n    /// The safety conditions are described in the [memory layout] section.\n    ///\n    /// # Examples\n    ///\n    /// Recreate a `Box` which was previously converted to a raw pointer\n    /// using [`Box::into_raw`]:\n    /// ```\n    /// let x = Box::new(5);\n    /// let ptr = Box::into_raw(x);\n    /// let x = unsafe { Box::from_raw(ptr) };\n    /// ```\n    /// Manually create a `Box` from scratch by using the global allocator:\n    /// ```\n    /// use std::alloc::{alloc, Layout};\n    ///\n    /// unsafe {\n    ///     let ptr = alloc(Layout::new::<i32>()) as *mut i32;\n    ///     // In general .write is required to avoid attempting to destruct\n    ///     // the (uninitialized) previous contents of `ptr`, though for this\n    ///     // simple example `*ptr = 5` would have worked as well.\n    ///     ptr.write(5);\n    ///     let x = Box::from_raw(ptr);\n    /// }\n    /// ```\n    ///\n    /// [memory layout]: self#memory-layout\n    /// [`Layout`]: crate::Layout\n    #[stable(feature = \"box_raw\", since = \"1.4.0\")]\n    #[inline]\n    #[must_use = \"call `drop(Box::from_raw(ptr))` if you intend to drop the `Box`\"]\n    pub unsafe fn from_raw(raw: *mut T) -> Self {\n        unsafe { Self::from_raw_in(raw, Global) }\n    }\n}\n\nimpl<T: ?Sized, A: Allocator> Box<T, A> {\n    /// Constructs a box from a raw pointer in the given allocator.\n    ///\n    /// After calling this function, the raw pointer is owned by the\n    /// resulting `Box`. Specifically, the `Box` destructor will call\n    /// the destructor of `T` and free the allocated memory. For this\n    /// to be safe, the memory must have been allocated in accordance\n    /// with the [memory layout] used by `Box` .\n    ///\n    /// # Safety\n    ///\n    /// This function is unsafe because improper use may lead to\n    /// memory problems. For example, a double-free may occur if the\n    /// function is called twice on the same raw pointer.\n    ///\n    ///\n    /// # Examples\n    ///\n    /// Recreate a `Box` which was previously converted to a raw pointer\n    /// using [`Box::into_raw_with_allocator`]:\n    /// ```\n    /// #![feature(allocator_api)]\n    ///\n    /// use std::alloc::System;\n    ///\n    /// let x = Box::new_in(5, System);\n    /// let (ptr, alloc) = Box::into_raw_with_allocator(x);\n    /// let x = unsafe { Box::from_raw_in(ptr, alloc) };\n    /// ```\n    /// Manually create a `Box` from scratch by using the system allocator:\n    /// ```\n    /// #![feature(allocator_api, slice_ptr_get)]\n    ///\n    /// use std::alloc::{Allocator, Layout, System};\n    ///\n    /// unsafe {\n    ///     let ptr = System.allocate(Layout::new::<i32>())?.as_mut_ptr() as *mut i32;\n    ///     // In general .write is required to avoid attempting to destruct\n    ///     // the (uninitialized) previous contents of `ptr`, though for this\n    ///     // simple example `*ptr = 5` would have worked as well.\n    ///     ptr.write(5);\n    ///     let x = Box::from_raw_in(ptr, System);\n    /// }\n    /// # Ok::<(), std::alloc::AllocError>(())\n    /// ```\n    ///\n    /// [memory layout]: self#memory-layout\n    /// [`Layout`]: crate::Layout\n    #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n    #[rustc_const_unstable(feature = \"const_box\", issue = \"92521\")]\n    #[inline]\n    pub const unsafe fn from_raw_in(raw: *mut T, alloc: A) -> Self {\n        Box(unsafe { Unique::new_unchecked(raw) }, alloc)\n    }\n\n    /// Consumes the `Box`, returning a wrapped raw pointer.\n    ///\n    /// The pointer will be properly aligned and non-null.\n    ///\n    /// After calling this function, the caller is responsible for the\n    /// memory previously managed by the `Box`. In particular, the\n    /// caller should properly destroy `T` and release the memory, taking\n    /// into account the [memory layout] used by `Box`. The easiest way to\n    /// do this is to convert the raw pointer back into a `Box` with the\n    /// [`Box::from_raw`] function, allowing the `Box` destructor to perform\n    /// the cleanup.\n    ///\n    /// Note: this is an associated function, which means that you have\n    /// to call it as `Box::into_raw(b)` instead of `b.into_raw()`. This\n    /// is so that there is no conflict with a method on the inner type.\n    ///\n    /// # Examples\n    /// Converting the raw pointer back into a `Box` with [`Box::from_raw`]\n    /// for automatic cleanup:\n    /// ```\n    /// let x = Box::new(String::from(\"Hello\"));\n    /// let ptr = Box::into_raw(x);\n    /// let x = unsafe { Box::from_raw(ptr) };\n    /// ```\n    /// Manual cleanup by explicitly running the destructor and deallocating\n    /// the memory:\n    /// ```\n    /// use std::alloc::{dealloc, Layout};\n    /// use std::ptr;\n    ///\n    /// let x = Box::new(String::from(\"Hello\"));\n    /// let p = Box::into_raw(x);\n    /// unsafe {\n    ///     ptr::drop_in_place(p);\n    ///     dealloc(p as *mut u8, Layout::new::<String>());\n    /// }\n    /// ```\n    ///\n    /// [memory layout]: self#memory-layout\n    #[stable(feature = \"box_raw\", since = \"1.4.0\")]\n    #[inline]\n    pub fn into_raw(b: Self) -> *mut T {\n        Self::into_raw_with_allocator(b).0\n    }\n\n    /// Consumes the `Box`, returning a wrapped raw pointer and the allocator.\n    ///\n    /// The pointer will be properly aligned and non-null.\n    ///\n    /// After calling this function, the caller is responsible for the\n    /// memory previously managed by the `Box`. In particular, the\n    /// caller should properly destroy `T` and release the memory, taking\n    /// into account the [memory layout] used by `Box`. The easiest way to\n    /// do this is to convert the raw pointer back into a `Box` with the\n    /// [`Box::from_raw_in`] function, allowing the `Box` destructor to perform\n    /// the cleanup.\n    ///\n    /// Note: this is an associated function, which means that you have\n    /// to call it as `Box::into_raw_with_allocator(b)` instead of `b.into_raw_with_allocator()`. This\n    /// is so that there is no conflict with a method on the inner type.\n    ///\n    /// # Examples\n    /// Converting the raw pointer back into a `Box` with [`Box::from_raw_in`]\n    /// for automatic cleanup:\n    /// ```\n    /// #![feature(allocator_api)]\n    ///\n    /// use std::alloc::System;\n    ///\n    /// let x = Box::new_in(String::from(\"Hello\"), System);\n    /// let (ptr, alloc) = Box::into_raw_with_allocator(x);\n    /// let x = unsafe { Box::from_raw_in(ptr, alloc) };\n    /// ```\n    /// Manual cleanup by explicitly running the destructor and deallocating\n    /// the memory:\n    /// ```\n    /// #![feature(allocator_api)]\n    ///\n    /// use std::alloc::{Allocator, Layout, System};\n    /// use std::ptr::{self, NonNull};\n    ///\n    /// let x = Box::new_in(String::from(\"Hello\"), System);\n    /// let (ptr, alloc) = Box::into_raw_with_allocator(x);\n    /// unsafe {\n    ///     ptr::drop_in_place(ptr);\n    ///     let non_null = NonNull::new_unchecked(ptr);\n    ///     alloc.deallocate(non_null.cast(), Layout::new::<String>());\n    /// }\n    /// ```\n    ///\n    /// [memory layout]: self#memory-layout\n    #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n    #[inline]\n    pub fn into_raw_with_allocator(b: Self) -> (*mut T, A) {\n        let (leaked, alloc) = Box::into_unique(b);\n        (leaked.as_ptr(), alloc)\n    }\n\n    #[unstable(\n        feature = \"ptr_internals\",\n        issue = \"none\",\n        reason = \"use `Box::leak(b).into()` or `Unique::from(Box::leak(b))` instead\"\n    )]\n    #[inline]\n    #[doc(hidden)]\n    pub fn into_unique(b: Self) -> (Unique<T>, A) {\n        // Box is recognized as a \"unique pointer\" by Stacked Borrows, but internally it is a\n        // raw pointer for the type system. Turning it directly into a raw pointer would not be\n        // recognized as \"releasing\" the unique pointer to permit aliased raw accesses,\n        // so all raw pointer methods have to go through `Box::leak`. Turning *that* to a raw pointer\n        // behaves correctly.\n        let alloc = unsafe { ptr::read(&b.1) };\n        (Unique::from(Box::leak(b)), alloc)\n    }\n\n    /// Returns a reference to the underlying allocator.\n    ///\n    /// Note: this is an associated function, which means that you have\n    /// to call it as `Box::allocator(&b)` instead of `b.allocator()`. This\n    /// is so that there is no conflict with a method on the inner type.\n    #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n    #[rustc_const_unstable(feature = \"const_box\", issue = \"92521\")]\n    #[inline]\n    pub const fn allocator(b: &Self) -> &A {\n        &b.1\n    }\n\n    /// Consumes and leaks the `Box`, returning a mutable reference,\n    /// `&'a mut T`. Note that the type `T` must outlive the chosen lifetime\n    /// `'a`. If the type has only static references, or none at all, then this\n    /// may be chosen to be `'static`.\n    ///\n    /// This function is mainly useful for data that lives for the remainder of\n    /// the program's life. Dropping the returned reference will cause a memory\n    /// leak. If this is not acceptable, the reference should first be wrapped\n    /// with the [`Box::from_raw`] function producing a `Box`. This `Box` can\n    /// then be dropped which will properly destroy `T` and release the\n    /// allocated memory.\n    ///\n    /// Note: this is an associated function, which means that you have\n    /// to call it as `Box::leak(b)` instead of `b.leak()`. This\n    /// is so that there is no conflict with a method on the inner type.\n    ///\n    /// # Examples\n    ///\n    /// Simple usage:\n    ///\n    /// ```\n    /// let x = Box::new(41);\n    /// let static_ref: &'static mut usize = Box::leak(x);\n    /// *static_ref += 1;\n    /// assert_eq!(*static_ref, 42);\n    /// ```\n    ///\n    /// Unsized data:\n    ///\n    /// ```\n    /// let x = vec![1, 2, 3].into_boxed_slice();\n    /// let static_ref = Box::leak(x);\n    /// static_ref[0] = 4;\n    /// assert_eq!(*static_ref, [4, 2, 3]);\n    /// ```\n    #[stable(feature = \"box_leak\", since = \"1.26.0\")]\n    #[inline]\n    pub fn leak<'a>(b: Self) -> &'a mut T\n    where\n        A: 'a,\n    {\n        unsafe { &mut *mem::ManuallyDrop::new(b).0.as_ptr() }\n    }\n\n    /// Converts a `Box<T>` into a `Pin<Box<T>>`. If `T` does not implement [`Unpin`], then\n    /// `*boxed` will be pinned in memory and unable to be moved.\n    ///\n    /// This conversion does not allocate on the heap and happens in place.\n    ///\n    /// This is also available via [`From`].\n    ///\n    /// Constructing and pinning a `Box` with <code>Box::into_pin([Box::new]\\(x))</code>\n    /// can also be written more concisely using <code>[Box::pin]\\(x)</code>.\n    /// This `into_pin` method is useful if you already have a `Box<T>`, or you are\n    /// constructing a (pinned) `Box` in a different way than with [`Box::new`].\n    ///\n    /// # Notes\n    ///\n    /// It's not recommended that crates add an impl like `From<Box<T>> for Pin<T>`,\n    /// as it'll introduce an ambiguity when calling `Pin::from`.\n    /// A demonstration of such a poor impl is shown below.\n    ///\n    /// ```compile_fail\n    /// # use std::pin::Pin;\n    /// struct Foo; // A type defined in this crate.\n    /// impl From<Box<()>> for Pin<Foo> {\n    ///     fn from(_: Box<()>) -> Pin<Foo> {\n    ///         Pin::new(Foo)\n    ///     }\n    /// }\n    ///\n    /// let foo = Box::new(());\n    /// let bar = Pin::from(foo);\n    /// ```\n    #[stable(feature = \"box_into_pin\", since = \"1.63.0\")]\n    #[rustc_const_unstable(feature = \"const_box\", issue = \"92521\")]\n    pub const fn into_pin(boxed: Self) -> Pin<Self>\n    where\n        A: 'static,\n    {\n        // It's not possible to move or replace the insides of a `Pin<Box<T>>`\n        // when `T: !Unpin`, so it's safe to pin it directly without any\n        // additional requirements.\n        unsafe { Pin::new_unchecked(boxed) }\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nunsafe impl<#[may_dangle] T: ?Sized, A: Allocator> Drop for Box<T, A> {\n    fn drop(&mut self) {\n        // FIXME: Do nothing, drop is currently performed by compiler.\n    }\n}\n\n#[cfg(not(no_global_oom_handling))]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: Default> Default for Box<T> {\n    /// Creates a `Box<T>`, with the `Default` value for T.\n    #[inline]\n    fn default() -> Self {\n        Box::new(T::default())\n    }\n}\n\n#[cfg(not(no_global_oom_handling))]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T> Default for Box<[T]> {\n    #[inline]\n    fn default() -> Self {\n        let ptr: Unique<[T]> = Unique::<[T; 0]>::dangling();\n        Box(ptr, Global)\n    }\n}\n\n#[cfg(not(no_global_oom_handling))]\n#[stable(feature = \"default_box_extra\", since = \"1.17.0\")]\nimpl Default for Box<str> {\n    #[inline]\n    fn default() -> Self {\n        // SAFETY: This is the same as `Unique::cast<U>` but with an unsized `U = str`.\n        let ptr: Unique<str> = unsafe {\n            let bytes: Unique<[u8]> = Unique::<[u8; 0]>::dangling();\n            Unique::new_unchecked(bytes.as_ptr() as *mut str)\n        };\n        Box(ptr, Global)\n    }\n}\n\n#[cfg(not(no_global_oom_handling))]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: Clone, A: Allocator + Clone> Clone for Box<T, A> {\n    /// Returns a new box with a `clone()` of this box's contents.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let x = Box::new(5);\n    /// let y = x.clone();\n    ///\n    /// // The value is the same\n    /// assert_eq!(x, y);\n    ///\n    /// // But they are unique objects\n    /// assert_ne!(&*x as *const i32, &*y as *const i32);\n    /// ```\n    #[inline]\n    fn clone(&self) -> Self {\n        // Pre-allocate memory to allow writing the cloned value directly.\n        let mut boxed = Self::new_uninit_in(self.1.clone());\n        unsafe {\n            (**self).write_clone_into_raw(boxed.as_mut_ptr());\n            boxed.assume_init()\n        }\n    }\n\n    /// Copies `source`'s contents into `self` without creating a new allocation.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let x = Box::new(5);\n    /// let mut y = Box::new(10);\n    /// let yp: *const i32 = &*y;\n    ///\n    /// y.clone_from(&x);\n    ///\n    /// // The value is the same\n    /// assert_eq!(x, y);\n    ///\n    /// // And no allocation occurred\n    /// assert_eq!(yp, &*y);\n    /// ```\n    #[inline]\n    fn clone_from(&mut self, source: &Self) {\n        (**self).clone_from(&(**source));\n    }\n}\n\n#[cfg(not(no_global_oom_handling))]\n#[stable(feature = \"box_slice_clone\", since = \"1.3.0\")]\nimpl Clone for Box<str> {\n    fn clone(&self) -> Self {\n        // this makes a copy of the data\n        let buf: Box<[u8]> = self.as_bytes().into();\n        unsafe { from_boxed_utf8_unchecked(buf) }\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: ?Sized + PartialEq, A: Allocator> PartialEq for Box<T, A> {\n    #[inline]\n    fn eq(&self, other: &Self) -> bool {\n        PartialEq::eq(&**self, &**other)\n    }\n    #[inline]\n    fn ne(&self, other: &Self) -> bool {\n        PartialEq::ne(&**self, &**other)\n    }\n}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: ?Sized + PartialOrd, A: Allocator> PartialOrd for Box<T, A> {\n    #[inline]\n    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n        PartialOrd::partial_cmp(&**self, &**other)\n    }\n    #[inline]\n    fn lt(&self, other: &Self) -> bool {\n        PartialOrd::lt(&**self, &**other)\n    }\n    #[inline]\n    fn le(&self, other: &Self) -> bool {\n        PartialOrd::le(&**self, &**other)\n    }\n    #[inline]\n    fn ge(&self, other: &Self) -> bool {\n        PartialOrd::ge(&**self, &**other)\n    }\n    #[inline]\n    fn gt(&self, other: &Self) -> bool {\n        PartialOrd::gt(&**self, &**other)\n    }\n}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: ?Sized + Ord, A: Allocator> Ord for Box<T, A> {\n    #[inline]\n    fn cmp(&self, other: &Self) -> Ordering {\n        Ord::cmp(&**self, &**other)\n    }\n}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: ?Sized + Eq, A: Allocator> Eq for Box<T, A> {}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: ?Sized + Hash, A: Allocator> Hash for Box<T, A> {\n    fn hash<H: Hasher>(&self, state: &mut H) {\n        (**self).hash(state);\n    }\n}\n\n#[stable(feature = \"indirect_hasher_impl\", since = \"1.22.0\")]\nimpl<T: ?Sized + Hasher, A: Allocator> Hasher for Box<T, A> {\n    fn finish(&self) -> u64 {\n        (**self).finish()\n    }\n    fn write(&mut self, bytes: &[u8]) {\n        (**self).write(bytes)\n    }\n    fn write_u8(&mut self, i: u8) {\n        (**self).write_u8(i)\n    }\n    fn write_u16(&mut self, i: u16) {\n        (**self).write_u16(i)\n    }\n    fn write_u32(&mut self, i: u32) {\n        (**self).write_u32(i)\n    }\n    fn write_u64(&mut self, i: u64) {\n        (**self).write_u64(i)\n    }\n    fn write_u128(&mut self, i: u128) {\n        (**self).write_u128(i)\n    }\n    fn write_usize(&mut self, i: usize) {\n        (**self).write_usize(i)\n    }\n    fn write_i8(&mut self, i: i8) {\n        (**self).write_i8(i)\n    }\n    fn write_i16(&mut self, i: i16) {\n        (**self).write_i16(i)\n    }\n    fn write_i32(&mut self, i: i32) {\n        (**self).write_i32(i)\n    }\n    fn write_i64(&mut self, i: i64) {\n        (**self).write_i64(i)\n    }\n    fn write_i128(&mut self, i: i128) {\n        (**self).write_i128(i)\n    }\n    fn write_isize(&mut self, i: isize) {\n        (**self).write_isize(i)\n    }\n    fn write_length_prefix(&mut self, len: usize) {\n        (**self).write_length_prefix(len)\n    }\n    fn write_str(&mut self, s: &str) {\n        (**self).write_str(s)\n    }\n}\n\n#[cfg(not(no_global_oom_handling))]\n#[stable(feature = \"from_for_ptrs\", since = \"1.6.0\")]\nimpl<T> From<T> for Box<T> {\n    /// Converts a `T` into a `Box<T>`\n    ///\n    /// The conversion allocates on the heap and moves `t`\n    /// from the stack into it.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// let x = 5;\n    /// let boxed = Box::new(5);\n    ///\n    /// assert_eq!(Box::from(x), boxed);\n    /// ```\n    fn from(t: T) -> Self {\n        Box::new(t)\n    }\n}\n\n#[stable(feature = \"pin\", since = \"1.33.0\")]\nimpl<T: ?Sized, A: Allocator> From<Box<T, A>> for Pin<Box<T, A>>\nwhere\n    A: 'static,\n{\n    /// Converts a `Box<T>` into a `Pin<Box<T>>`. If `T` does not implement [`Unpin`], then\n    /// `*boxed` will be pinned in memory and unable to be moved.\n    ///\n    /// This conversion does not allocate on the heap and happens in place.\n    ///\n    /// This is also available via [`Box::into_pin`].\n    ///\n    /// Constructing and pinning a `Box` with <code><Pin<Box\\<T>>>::from([Box::new]\\(x))</code>\n    /// can also be written more concisely using <code>[Box::pin]\\(x)</code>.\n    /// This `From` implementation is useful if you already have a `Box<T>`, or you are\n    /// constructing a (pinned) `Box` in a different way than with [`Box::new`].\n    fn from(boxed: Box<T, A>) -> Self {\n        Box::into_pin(boxed)\n    }\n}\n\n/// Specialization trait used for `From<&[T]>`.\n#[cfg(not(no_global_oom_handling))]\ntrait BoxFromSlice<T> {\n    fn from_slice(slice: &[T]) -> Self;\n}\n\n#[cfg(not(no_global_oom_handling))]\nimpl<T: Clone> BoxFromSlice<T> for Box<[T]> {\n    #[inline]\n    default fn from_slice(slice: &[T]) -> Self {\n        slice.to_vec().into_boxed_slice()\n    }\n}\n\n#[cfg(not(no_global_oom_handling))]\nimpl<T: Copy> BoxFromSlice<T> for Box<[T]> {\n    #[inline]\n    fn from_slice(slice: &[T]) -> Self {\n        let len = slice.len();\n        let buf = RawVec::with_capacity(len);\n        unsafe {\n            ptr::copy_nonoverlapping(slice.as_ptr(), buf.ptr(), len);\n            buf.into_box(slice.len()).assume_init()\n        }\n    }\n}\n\n#[cfg(not(no_global_oom_handling))]\n#[stable(feature = \"box_from_slice\", since = \"1.17.0\")]\nimpl<T: Clone> From<&[T]> for Box<[T]> {\n    /// Converts a `&[T]` into a `Box<[T]>`\n    ///\n    /// This conversion allocates on the heap\n    /// and performs a copy of `slice` and its contents.\n    ///\n    /// # Examples\n    /// ```rust\n    /// // create a &[u8] which will be used to create a Box<[u8]>\n    /// let slice: &[u8] = &[104, 101, 108, 108, 111];\n    /// let boxed_slice: Box<[u8]> = Box::from(slice);\n    ///\n    /// println!(\"{boxed_slice:?}\");\n    /// ```\n    #[inline]\n    fn from(slice: &[T]) -> Box<[T]> {\n        <Self as BoxFromSlice<T>>::from_slice(slice)\n    }\n}\n\n#[cfg(not(no_global_oom_handling))]\n#[stable(feature = \"box_from_cow\", since = \"1.45.0\")]\nimpl<T: Clone> From<Cow<'_, [T]>> for Box<[T]> {\n    /// Converts a `Cow<'_, [T]>` into a `Box<[T]>`\n    ///\n    /// When `cow` is the `Cow::Borrowed` variant, this\n    /// conversion allocates on the heap and copies the\n    /// underlying slice. Otherwise, it will try to reuse the owned\n    /// `Vec`'s allocation.\n    #[inline]\n    fn from(cow: Cow<'_, [T]>) -> Box<[T]> {\n        match cow {\n            Cow::Borrowed(slice) => Box::from(slice),\n            Cow::Owned(slice) => Box::from(slice),\n        }\n    }\n}\n\n#[cfg(not(no_global_oom_handling))]\n#[stable(feature = \"box_from_slice\", since = \"1.17.0\")]\nimpl From<&str> for Box<str> {\n    /// Converts a `&str` into a `Box<str>`\n    ///\n    /// This conversion allocates on the heap\n    /// and performs a copy of `s`.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// let boxed: Box<str> = Box::from(\"hello\");\n    /// println!(\"{boxed}\");\n    /// ```\n    #[inline]\n    fn from(s: &str) -> Box<str> {\n        unsafe { from_boxed_utf8_unchecked(Box::from(s.as_bytes())) }\n    }\n}\n\n#[cfg(not(no_global_oom_handling))]\n#[stable(feature = \"box_from_cow\", since = \"1.45.0\")]\nimpl From<Cow<'_, str>> for Box<str> {\n    /// Converts a `Cow<'_, str>` into a `Box<str>`\n    ///\n    /// When `cow` is the `Cow::Borrowed` variant, this\n    /// conversion allocates on the heap and copies the\n    /// underlying `str`. Otherwise, it will try to reuse the owned\n    /// `String`'s allocation.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// use std::borrow::Cow;\n    ///\n    /// let unboxed = Cow::Borrowed(\"hello\");\n    /// let boxed: Box<str> = Box::from(unboxed);\n    /// println!(\"{boxed}\");\n    /// ```\n    ///\n    /// ```rust\n    /// # use std::borrow::Cow;\n    /// let unboxed = Cow::Owned(\"hello\".to_string());\n    /// let boxed: Box<str> = Box::from(unboxed);\n    /// println!(\"{boxed}\");\n    /// ```\n    #[inline]\n    fn from(cow: Cow<'_, str>) -> Box<str> {\n        match cow {\n            Cow::Borrowed(s) => Box::from(s),\n            Cow::Owned(s) => Box::from(s),\n        }\n    }\n}\n\n#[stable(feature = \"boxed_str_conv\", since = \"1.19.0\")]\nimpl<A: Allocator> From<Box<str, A>> for Box<[u8], A> {\n    /// Converts a `Box<str>` into a `Box<[u8]>`\n    ///\n    /// This conversion does not allocate on the heap and happens in place.\n    ///\n    /// # Examples\n    /// ```rust\n    /// // create a Box<str> which will be used to create a Box<[u8]>\n    /// let boxed: Box<str> = Box::from(\"hello\");\n    /// let boxed_str: Box<[u8]> = Box::from(boxed);\n    ///\n    /// // create a &[u8] which will be used to create a Box<[u8]>\n    /// let slice: &[u8] = &[104, 101, 108, 108, 111];\n    /// let boxed_slice = Box::from(slice);\n    ///\n    /// assert_eq!(boxed_slice, boxed_str);\n    /// ```\n    #[inline]\n    fn from(s: Box<str, A>) -> Self {\n        let (raw, alloc) = Box::into_raw_with_allocator(s);\n        unsafe { Box::from_raw_in(raw as *mut [u8], alloc) }\n    }\n}\n\n#[cfg(not(no_global_oom_handling))]\n#[stable(feature = \"box_from_array\", since = \"1.45.0\")]\nimpl<T, const N: usize> From<[T; N]> for Box<[T]> {\n    /// Converts a `[T; N]` into a `Box<[T]>`\n    ///\n    /// This conversion moves the array to newly heap-allocated memory.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// let boxed: Box<[u8]> = Box::from([4, 2]);\n    /// println!(\"{boxed:?}\");\n    /// ```\n    fn from(array: [T; N]) -> Box<[T]> {\n        Box::new(array)\n    }\n}\n\n/// Casts a boxed slice to a boxed array.\n///\n/// # Safety\n///\n/// `boxed_slice.len()` must be exactly `N`.\nunsafe fn boxed_slice_as_array_unchecked<T, A: Allocator, const N: usize>(\n    boxed_slice: Box<[T], A>,\n) -> Box<[T; N], A> {\n    debug_assert_eq!(boxed_slice.len(), N);\n\n    let (ptr, alloc) = Box::into_raw_with_allocator(boxed_slice);\n    // SAFETY: Pointer and allocator came from an existing box,\n    // and our safety condition requires that the length is exactly `N`\n    unsafe { Box::from_raw_in(ptr as *mut [T; N], alloc) }\n}\n\n#[stable(feature = \"boxed_slice_try_from\", since = \"1.43.0\")]\nimpl<T, const N: usize> TryFrom<Box<[T]>> for Box<[T; N]> {\n    type Error = Box<[T]>;\n\n    /// Attempts to convert a `Box<[T]>` into a `Box<[T; N]>`.\n    ///\n    /// The conversion occurs in-place and does not require a\n    /// new memory allocation.\n    ///\n    /// # Errors\n    ///\n    /// Returns the old `Box<[T]>` in the `Err` variant if\n    /// `boxed_slice.len()` does not equal `N`.\n    fn try_from(boxed_slice: Box<[T]>) -> Result<Self, Self::Error> {\n        if boxed_slice.len() == N {\n            Ok(unsafe { boxed_slice_as_array_unchecked(boxed_slice) })\n        } else {\n            Err(boxed_slice)\n        }\n    }\n}\n\n#[cfg(not(no_global_oom_handling))]\n#[stable(feature = \"boxed_array_try_from_vec\", since = \"1.66.0\")]\nimpl<T, const N: usize> TryFrom<Vec<T>> for Box<[T; N]> {\n    type Error = Vec<T>;\n\n    /// Attempts to convert a `Vec<T>` into a `Box<[T; N]>`.\n    ///\n    /// Like [`Vec::into_boxed_slice`], this is in-place if `vec.capacity() == N`,\n    /// but will require a reallocation otherwise.\n    ///\n    /// # Errors\n    ///\n    /// Returns the original `Vec<T>` in the `Err` variant if\n    /// `boxed_slice.len()` does not equal `N`.\n    ///\n    /// # Examples\n    ///\n    /// This can be used with [`vec!`] to create an array on the heap:\n    ///\n    /// ```\n    /// let state: Box<[f32; 100]> = vec![1.0; 100].try_into().unwrap();\n    /// assert_eq!(state.len(), 100);\n    /// ```\n    fn try_from(vec: Vec<T>) -> Result<Self, Self::Error> {\n        if vec.len() == N {\n            let boxed_slice = vec.into_boxed_slice();\n            Ok(unsafe { boxed_slice_as_array_unchecked(boxed_slice) })\n        } else {\n            Err(vec)\n        }\n    }\n}\n\nimpl<A: Allocator> Box<dyn Any, A> {\n    /// Attempt to downcast the box to a concrete type.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::any::Any;\n    ///\n    /// fn print_if_string(value: Box<dyn Any>) {\n    ///     if let Ok(string) = value.downcast::<String>() {\n    ///         println!(\"String ({}): {}\", string.len(), string);\n    ///     }\n    /// }\n    ///\n    /// let my_string = \"Hello World\".to_string();\n    /// print_if_string(Box::new(my_string));\n    /// print_if_string(Box::new(0i8));\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn downcast<T: Any>(self) -> Result<Box<T, A>, Self> {\n        if self.is::<T>() { unsafe { Ok(self.downcast_unchecked::<T>()) } } else { Err(self) }\n    }\n\n    /// Downcasts the box to a concrete type.\n    ///\n    /// For a safe alternative see [`downcast`].\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(downcast_unchecked)]\n    ///\n    /// use std::any::Any;\n    ///\n    /// let x: Box<dyn Any> = Box::new(1_usize);\n    ///\n    /// unsafe {\n    ///     assert_eq!(*x.downcast_unchecked::<usize>(), 1);\n    /// }\n    /// ```\n    ///\n    /// # Safety\n    ///\n    /// The contained value must be of type `T`. Calling this method\n    /// with the incorrect type is *undefined behavior*.\n    ///\n    /// [`downcast`]: Self::downcast\n    #[inline]\n    #[unstable(feature = \"downcast_unchecked\", issue = \"90850\")]\n    pub unsafe fn downcast_unchecked<T: Any>(self) -> Box<T, A> {\n        debug_assert!(self.is::<T>());\n        unsafe {\n            let (raw, alloc): (*mut dyn Any, _) = Box::into_raw_with_allocator(self);\n            Box::from_raw_in(raw as *mut T, alloc)\n        }\n    }\n}\n\nimpl<A: Allocator> Box<dyn Any + Send, A> {\n    /// Attempt to downcast the box to a concrete type.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::any::Any;\n    ///\n    /// fn print_if_string(value: Box<dyn Any + Send>) {\n    ///     if let Ok(string) = value.downcast::<String>() {\n    ///         println!(\"String ({}): {}\", string.len(), string);\n    ///     }\n    /// }\n    ///\n    /// let my_string = \"Hello World\".to_string();\n    /// print_if_string(Box::new(my_string));\n    /// print_if_string(Box::new(0i8));\n    /// ```\n    #[inline]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn downcast<T: Any>(self) -> Result<Box<T, A>, Self> {\n        if self.is::<T>() { unsafe { Ok(self.downcast_unchecked::<T>()) } } else { Err(self) }\n    }\n\n    /// Downcasts the box to a concrete type.\n    ///\n    /// For a safe alternative see [`downcast`].\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(downcast_unchecked)]\n    ///\n    /// use std::any::Any;\n    ///\n    /// let x: Box<dyn Any + Send> = Box::new(1_usize);\n    ///\n    /// unsafe {\n    ///     assert_eq!(*x.downcast_unchecked::<usize>(), 1);\n    /// }\n    /// ```\n    ///\n    /// # Safety\n    ///\n    /// The contained value must be of type `T`. Calling this method\n    /// with the incorrect type is *undefined behavior*.\n    ///\n    /// [`downcast`]: Self::downcast\n    #[inline]\n    #[unstable(feature = \"downcast_unchecked\", issue = \"90850\")]\n    pub unsafe fn downcast_unchecked<T: Any>(self) -> Box<T, A> {\n        debug_assert!(self.is::<T>());\n        unsafe {\n            let (raw, alloc): (*mut (dyn Any + Send), _) = Box::into_raw_with_allocator(self);\n            Box::from_raw_in(raw as *mut T, alloc)\n        }\n    }\n}\n\nimpl<A: Allocator> Box<dyn Any + Send + Sync, A> {\n    /// Attempt to downcast the box to a concrete type.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::any::Any;\n    ///\n    /// fn print_if_string(value: Box<dyn Any + Send + Sync>) {\n    ///     if let Ok(string) = value.downcast::<String>() {\n    ///         println!(\"String ({}): {}\", string.len(), string);\n    ///     }\n    /// }\n    ///\n    /// let my_string = \"Hello World\".to_string();\n    /// print_if_string(Box::new(my_string));\n    /// print_if_string(Box::new(0i8));\n    /// ```\n    #[inline]\n    #[stable(feature = \"box_send_sync_any_downcast\", since = \"1.51.0\")]\n    pub fn downcast<T: Any>(self) -> Result<Box<T, A>, Self> {\n        if self.is::<T>() { unsafe { Ok(self.downcast_unchecked::<T>()) } } else { Err(self) }\n    }\n\n    /// Downcasts the box to a concrete type.\n    ///\n    /// For a safe alternative see [`downcast`].\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(downcast_unchecked)]\n    ///\n    /// use std::any::Any;\n    ///\n    /// let x: Box<dyn Any + Send + Sync> = Box::new(1_usize);\n    ///\n    /// unsafe {\n    ///     assert_eq!(*x.downcast_unchecked::<usize>(), 1);\n    /// }\n    /// ```\n    ///\n    /// # Safety\n    ///\n    /// The contained value must be of type `T`. Calling this method\n    /// with the incorrect type is *undefined behavior*.\n    ///\n    /// [`downcast`]: Self::downcast\n    #[inline]\n    #[unstable(feature = \"downcast_unchecked\", issue = \"90850\")]\n    pub unsafe fn downcast_unchecked<T: Any>(self) -> Box<T, A> {\n        debug_assert!(self.is::<T>());\n        unsafe {\n            let (raw, alloc): (*mut (dyn Any + Send + Sync), _) =\n                Box::into_raw_with_allocator(self);\n            Box::from_raw_in(raw as *mut T, alloc)\n        }\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: fmt::Display + ?Sized, A: Allocator> fmt::Display for Box<T, A> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        fmt::Display::fmt(&**self, f)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: fmt::Debug + ?Sized, A: Allocator> fmt::Debug for Box<T, A> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        fmt::Debug::fmt(&**self, f)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: ?Sized, A: Allocator> fmt::Pointer for Box<T, A> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        // It's not possible to extract the inner Uniq directly from the Box,\n        // instead we cast it to a *const which aliases the Unique\n        let ptr: *const T = &**self;\n        fmt::Pointer::fmt(&ptr, f)\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: ?Sized, A: Allocator> Deref for Box<T, A> {\n    type Target = T;\n\n    fn deref(&self) -> &T {\n        &**self\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: ?Sized, A: Allocator> DerefMut for Box<T, A> {\n    fn deref_mut(&mut self) -> &mut T {\n        &mut **self\n    }\n}\n\n#[unstable(feature = \"receiver_trait\", issue = \"none\")]\nimpl<T: ?Sized, A: Allocator> Receiver for Box<T, A> {}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<I: Iterator + ?Sized, A: Allocator> Iterator for Box<I, A> {\n    type Item = I::Item;\n    fn next(&mut self) -> Option<I::Item> {\n        (**self).next()\n    }\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        (**self).size_hint()\n    }\n    fn nth(&mut self, n: usize) -> Option<I::Item> {\n        (**self).nth(n)\n    }\n    fn last(self) -> Option<I::Item> {\n        BoxIter::last(self)\n    }\n}\n\ntrait BoxIter {\n    type Item;\n    fn last(self) -> Option<Self::Item>;\n}\n\nimpl<I: Iterator + ?Sized, A: Allocator> BoxIter for Box<I, A> {\n    type Item = I::Item;\n    default fn last(self) -> Option<I::Item> {\n        #[inline]\n        fn some<T>(_: Option<T>, x: T) -> Option<T> {\n            Some(x)\n        }\n\n        self.fold(None, some)\n    }\n}\n\n/// Specialization for sized `I`s that uses `I`s implementation of `last()`\n/// instead of the default.\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<I: Iterator, A: Allocator> BoxIter for Box<I, A> {\n    fn last(self) -> Option<I::Item> {\n        (*self).last()\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<I: DoubleEndedIterator + ?Sized, A: Allocator> DoubleEndedIterator for Box<I, A> {\n    fn next_back(&mut self) -> Option<I::Item> {\n        (**self).next_back()\n    }\n    fn nth_back(&mut self, n: usize) -> Option<I::Item> {\n        (**self).nth_back(n)\n    }\n}\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<I: ExactSizeIterator + ?Sized, A: Allocator> ExactSizeIterator for Box<I, A> {\n    fn len(&self) -> usize {\n        (**self).len()\n    }\n    fn is_empty(&self) -> bool {\n        (**self).is_empty()\n    }\n}\n\n#[stable(feature = \"fused\", since = \"1.26.0\")]\nimpl<I: FusedIterator + ?Sized, A: Allocator> FusedIterator for Box<I, A> {}\n\n#[stable(feature = \"boxed_closure_impls\", since = \"1.35.0\")]\nimpl<Args: Tuple, F: FnOnce<Args> + ?Sized, A: Allocator> FnOnce<Args> for Box<F, A> {\n    type Output = <F as FnOnce<Args>>::Output;\n\n    extern \"rust-call\" fn call_once(self, args: Args) -> Self::Output {\n        <F as FnOnce<Args>>::call_once(*self, args)\n    }\n}\n\n#[stable(feature = \"boxed_closure_impls\", since = \"1.35.0\")]\nimpl<Args: Tuple, F: FnMut<Args> + ?Sized, A: Allocator> FnMut<Args> for Box<F, A> {\n    extern \"rust-call\" fn call_mut(&mut self, args: Args) -> Self::Output {\n        <F as FnMut<Args>>::call_mut(self, args)\n    }\n}\n\n#[stable(feature = \"boxed_closure_impls\", since = \"1.35.0\")]\nimpl<Args: Tuple, F: Fn<Args> + ?Sized, A: Allocator> Fn<Args> for Box<F, A> {\n    extern \"rust-call\" fn call(&self, args: Args) -> Self::Output {\n        <F as Fn<Args>>::call(self, args)\n    }\n}\n\n#[unstable(feature = \"coerce_unsized\", issue = \"18598\")]\nimpl<T: ?Sized + Unsize<U>, U: ?Sized, A: Allocator> CoerceUnsized<Box<U, A>> for Box<T, A> {}\n\n#[unstable(feature = \"dispatch_from_dyn\", issue = \"none\")]\nimpl<T: ?Sized + Unsize<U>, U: ?Sized> DispatchFromDyn<Box<U>> for Box<T, Global> {}\n\n#[cfg(not(no_global_oom_handling))]\n#[stable(feature = \"boxed_slice_from_iter\", since = \"1.32.0\")]\nimpl<I> FromIterator<I> for Box<[I]> {\n    fn from_iter<T: IntoIterator<Item = I>>(iter: T) -> Self {\n        iter.into_iter().collect::<Vec<_>>().into_boxed_slice()\n    }\n}\n\n#[cfg(not(no_global_oom_handling))]\n#[stable(feature = \"box_slice_clone\", since = \"1.3.0\")]\nimpl<T: Clone, A: Allocator + Clone> Clone for Box<[T], A> {\n    fn clone(&self) -> Self {\n        let alloc = Box::allocator(self).clone();\n        self.to_vec_in(alloc).into_boxed_slice()\n    }\n\n    fn clone_from(&mut self, other: &Self) {\n        if self.len() == other.len() {\n            self.clone_from_slice(&other);\n        } else {\n            *self = other.clone();\n        }\n    }\n}\n\n#[stable(feature = \"box_borrow\", since = \"1.1.0\")]\nimpl<T: ?Sized, A: Allocator> borrow::Borrow<T> for Box<T, A> {\n    fn borrow(&self) -> &T {\n        &**self\n    }\n}\n\n#[stable(feature = \"box_borrow\", since = \"1.1.0\")]\nimpl<T: ?Sized, A: Allocator> borrow::BorrowMut<T> for Box<T, A> {\n    fn borrow_mut(&mut self) -> &mut T {\n        &mut **self\n    }\n}\n\n#[stable(since = \"1.5.0\", feature = \"smart_ptr_as_ref\")]\nimpl<T: ?Sized, A: Allocator> AsRef<T> for Box<T, A> {\n    fn as_ref(&self) -> &T {\n        &**self\n    }\n}\n\n#[stable(since = \"1.5.0\", feature = \"smart_ptr_as_ref\")]\nimpl<T: ?Sized, A: Allocator> AsMut<T> for Box<T, A> {\n    fn as_mut(&mut self) -> &mut T {\n        &mut **self\n    }\n}\n\n/* Nota bene\n *\n *  We could have chosen not to add this impl, and instead have written a\n *  function of Pin<Box<T>> to Pin<T>. Such a function would not be sound,\n *  because Box<T> implements Unpin even when T does not, as a result of\n *  this impl.\n *\n *  We chose this API instead of the alternative for a few reasons:\n *      - Logically, it is helpful to understand pinning in regard to the\n *        memory region being pointed to. For this reason none of the\n *        standard library pointer types support projecting through a pin\n *        (Box<T> is the only pointer type in std for which this would be\n *        safe.)\n *      - It is in practice very useful to have Box<T> be unconditionally\n *        Unpin because of trait objects, for which the structural auto\n *        trait functionality does not apply (e.g., Box<dyn Foo> would\n *        otherwise not be Unpin).\n *\n *  Another type with the same semantics as Box but only a conditional\n *  implementation of `Unpin` (where `T: Unpin`) would be valid/safe, and\n *  could have a method to project a Pin<T> from it.\n */\n#[stable(feature = \"pin\", since = \"1.33.0\")]\nimpl<T: ?Sized, A: Allocator> Unpin for Box<T, A> where A: 'static {}\n\n#[unstable(feature = \"generator_trait\", issue = \"43122\")]\nimpl<G: ?Sized + Generator<R> + Unpin, R, A: Allocator> Generator<R> for Box<G, A>\nwhere\n    A: 'static,\n{\n    type Yield = G::Yield;\n    type Return = G::Return;\n\n    fn resume(mut self: Pin<&mut Self>, arg: R) -> GeneratorState<Self::Yield, Self::Return> {\n        G::resume(Pin::new(&mut *self), arg)\n    }\n}\n\n#[unstable(feature = \"generator_trait\", issue = \"43122\")]\nimpl<G: ?Sized + Generator<R>, R, A: Allocator> Generator<R> for Pin<Box<G, A>>\nwhere\n    A: 'static,\n{\n    type Yield = G::Yield;\n    type Return = G::Return;\n\n    fn resume(mut self: Pin<&mut Self>, arg: R) -> GeneratorState<Self::Yield, Self::Return> {\n        G::resume((*self).as_mut(), arg)\n    }\n}\n\n#[stable(feature = \"futures_api\", since = \"1.36.0\")]\nimpl<F: ?Sized + Future + Unpin, A: Allocator> Future for Box<F, A>\nwhere\n    A: 'static,\n{\n    type Output = F::Output;\n\n    fn poll(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {\n        F::poll(Pin::new(&mut *self), cx)\n    }\n}\n\n#[unstable(feature = \"async_iterator\", issue = \"79024\")]\nimpl<S: ?Sized + AsyncIterator + Unpin> AsyncIterator for Box<S> {\n    type Item = S::Item;\n\n    fn poll_next(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Option<Self::Item>> {\n        Pin::new(&mut **self).poll_next(cx)\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        (**self).size_hint()\n    }\n}\n\nimpl dyn Error {\n    #[inline]\n    #[stable(feature = \"error_downcast\", since = \"1.3.0\")]\n    #[rustc_allow_incoherent_impl]\n    /// Attempts to downcast the box to a concrete type.\n    pub fn downcast<T: Error + 'static>(self: Box<Self>) -> Result<Box<T>, Box<dyn Error>> {\n        if self.is::<T>() {\n            unsafe {\n                let raw: *mut dyn Error = Box::into_raw(self);\n                Ok(Box::from_raw(raw as *mut T))\n            }\n        } else {\n            Err(self)\n        }\n    }\n}\n\nimpl dyn Error + Send {\n    #[inline]\n    #[stable(feature = \"error_downcast\", since = \"1.3.0\")]\n    #[rustc_allow_incoherent_impl]\n    /// Attempts to downcast the box to a concrete type.\n    pub fn downcast<T: Error + 'static>(self: Box<Self>) -> Result<Box<T>, Box<dyn Error + Send>> {\n        let err: Box<dyn Error> = self;\n        <dyn Error>::downcast(err).map_err(|s| unsafe {\n            // Reapply the `Send` marker.\n            mem::transmute::<Box<dyn Error>, Box<dyn Error + Send>>(s)\n        })\n    }\n}\n\nimpl dyn Error + Send + Sync {\n    #[inline]\n    #[stable(feature = \"error_downcast\", since = \"1.3.0\")]\n    #[rustc_allow_incoherent_impl]\n    /// Attempts to downcast the box to a concrete type.\n    pub fn downcast<T: Error + 'static>(self: Box<Self>) -> Result<Box<T>, Box<Self>> {\n        let err: Box<dyn Error> = self;\n        <dyn Error>::downcast(err).map_err(|s| unsafe {\n            // Reapply the `Send + Sync` marker.\n            mem::transmute::<Box<dyn Error>, Box<dyn Error + Send + Sync>>(s)\n        })\n    }\n}\n\n#[cfg(not(no_global_oom_handling))]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, E: Error + 'a> From<E> for Box<dyn Error + 'a> {\n    /// Converts a type of [`Error`] into a box of dyn [`Error`].\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::error::Error;\n    /// use std::fmt;\n    /// use std::mem;\n    ///\n    /// #[derive(Debug)]\n    /// struct AnError;\n    ///\n    /// impl fmt::Display for AnError {\n    ///     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n    ///         write!(f, \"An error\")\n    ///     }\n    /// }\n    ///\n    /// impl Error for AnError {}\n    ///\n    /// let an_error = AnError;\n    /// assert!(0 == mem::size_of_val(&an_error));\n    /// let a_boxed_error = Box::<dyn Error>::from(an_error);\n    /// assert!(mem::size_of::<Box<dyn Error>>() == mem::size_of_val(&a_boxed_error))\n    /// ```\n    fn from(err: E) -> Box<dyn Error + 'a> {\n        Box::new(err)\n    }\n}\n\n#[cfg(not(no_global_oom_handling))]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a, E: Error + Send + Sync + 'a> From<E> for Box<dyn Error + Send + Sync + 'a> {\n    /// Converts a type of [`Error`] + [`Send`] + [`Sync`] into a box of\n    /// dyn [`Error`] + [`Send`] + [`Sync`].\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::error::Error;\n    /// use std::fmt;\n    /// use std::mem;\n    ///\n    /// #[derive(Debug)]\n    /// struct AnError;\n    ///\n    /// impl fmt::Display for AnError {\n    ///     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n    ///         write!(f, \"An error\")\n    ///     }\n    /// }\n    ///\n    /// impl Error for AnError {}\n    ///\n    /// unsafe impl Send for AnError {}\n    ///\n    /// unsafe impl Sync for AnError {}\n    ///\n    /// let an_error = AnError;\n    /// assert!(0 == mem::size_of_val(&an_error));\n    /// let a_boxed_error = Box::<dyn Error + Send + Sync>::from(an_error);\n    /// assert!(\n    ///     mem::size_of::<Box<dyn Error + Send + Sync>>() == mem::size_of_val(&a_boxed_error))\n    /// ```\n    fn from(err: E) -> Box<dyn Error + Send + Sync + 'a> {\n        Box::new(err)\n    }\n}\n\n#[cfg(not(no_global_oom_handling))]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl From<String> for Box<dyn Error + Send + Sync> {\n    /// Converts a [`String`] into a box of dyn [`Error`] + [`Send`] + [`Sync`].\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::error::Error;\n    /// use std::mem;\n    ///\n    /// let a_string_error = \"a string error\".to_string();\n    /// let a_boxed_error = Box::<dyn Error + Send + Sync>::from(a_string_error);\n    /// assert!(\n    ///     mem::size_of::<Box<dyn Error + Send + Sync>>() == mem::size_of_val(&a_boxed_error))\n    /// ```\n    #[inline]\n    fn from(err: String) -> Box<dyn Error + Send + Sync> {\n        struct StringError(String);\n\n        impl Error for StringError {\n            #[allow(deprecated)]\n            fn description(&self) -> &str {\n                &self.0\n            }\n        }\n\n        impl fmt::Display for StringError {\n            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n                fmt::Display::fmt(&self.0, f)\n            }\n        }\n\n        // Purposefully skip printing \"StringError(..)\"\n        impl fmt::Debug for StringError {\n            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n                fmt::Debug::fmt(&self.0, f)\n            }\n        }\n\n        Box::new(StringError(err))\n    }\n}\n\n#[cfg(not(no_global_oom_handling))]\n#[stable(feature = \"string_box_error\", since = \"1.6.0\")]\nimpl From<String> for Box<dyn Error> {\n    /// Converts a [`String`] into a box of dyn [`Error`].\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::error::Error;\n    /// use std::mem;\n    ///\n    /// let a_string_error = \"a string error\".to_string();\n    /// let a_boxed_error = Box::<dyn Error>::from(a_string_error);\n    /// assert!(mem::size_of::<Box<dyn Error>>() == mem::size_of_val(&a_boxed_error))\n    /// ```\n    fn from(str_err: String) -> Box<dyn Error> {\n        let err1: Box<dyn Error + Send + Sync> = From::from(str_err);\n        let err2: Box<dyn Error> = err1;\n        err2\n    }\n}\n\n#[cfg(not(no_global_oom_handling))]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<'a> From<&str> for Box<dyn Error + Send + Sync + 'a> {\n    /// Converts a [`str`] into a box of dyn [`Error`] + [`Send`] + [`Sync`].\n    ///\n    /// [`str`]: prim@str\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::error::Error;\n    /// use std::mem;\n    ///\n    /// let a_str_error = \"a str error\";\n    /// let a_boxed_error = Box::<dyn Error + Send + Sync>::from(a_str_error);\n    /// assert!(\n    ///     mem::size_of::<Box<dyn Error + Send + Sync>>() == mem::size_of_val(&a_boxed_error))\n    /// ```\n    #[inline]\n    fn from(err: &str) -> Box<dyn Error + Send + Sync + 'a> {\n        From::from(String::from(err))\n    }\n}\n\n#[cfg(not(no_global_oom_handling))]\n#[stable(feature = \"string_box_error\", since = \"1.6.0\")]\nimpl From<&str> for Box<dyn Error> {\n    /// Converts a [`str`] into a box of dyn [`Error`].\n    ///\n    /// [`str`]: prim@str\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::error::Error;\n    /// use std::mem;\n    ///\n    /// let a_str_error = \"a str error\";\n    /// let a_boxed_error = Box::<dyn Error>::from(a_str_error);\n    /// assert!(mem::size_of::<Box<dyn Error>>() == mem::size_of_val(&a_boxed_error))\n    /// ```\n    fn from(err: &str) -> Box<dyn Error> {\n        From::from(String::from(err))\n    }\n}\n\n#[cfg(not(no_global_oom_handling))]\n#[stable(feature = \"cow_box_error\", since = \"1.22.0\")]\nimpl<'a, 'b> From<Cow<'b, str>> for Box<dyn Error + Send + Sync + 'a> {\n    /// Converts a [`Cow`] into a box of dyn [`Error`] + [`Send`] + [`Sync`].\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::error::Error;\n    /// use std::mem;\n    /// use std::borrow::Cow;\n    ///\n    /// let a_cow_str_error = Cow::from(\"a str error\");\n    /// let a_boxed_error = Box::<dyn Error + Send + Sync>::from(a_cow_str_error);\n    /// assert!(\n    ///     mem::size_of::<Box<dyn Error + Send + Sync>>() == mem::size_of_val(&a_boxed_error))\n    /// ```\n    fn from(err: Cow<'b, str>) -> Box<dyn Error + Send + Sync + 'a> {\n        From::from(String::from(err))\n    }\n}\n\n#[cfg(not(no_global_oom_handling))]\n#[stable(feature = \"cow_box_error\", since = \"1.22.0\")]\nimpl<'a> From<Cow<'a, str>> for Box<dyn Error> {\n    /// Converts a [`Cow`] into a box of dyn [`Error`].\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::error::Error;\n    /// use std::mem;\n    /// use std::borrow::Cow;\n    ///\n    /// let a_cow_str_error = Cow::from(\"a str error\");\n    /// let a_boxed_error = Box::<dyn Error>::from(a_cow_str_error);\n    /// assert!(mem::size_of::<Box<dyn Error>>() == mem::size_of_val(&a_boxed_error))\n    /// ```\n    fn from(err: Cow<'a, str>) -> Box<dyn Error> {\n        From::from(String::from(err))\n    }\n}\n\n#[stable(feature = \"box_error\", since = \"1.8.0\")]\nimpl<T: core::error::Error> core::error::Error for Box<T> {\n    #[allow(deprecated, deprecated_in_future)]\n    fn description(&self) -> &str {\n        core::error::Error::description(&**self)\n    }\n\n    #[allow(deprecated)]\n    fn cause(&self) -> Option<&dyn core::error::Error> {\n        core::error::Error::cause(&**self)\n    }\n\n    fn source(&self) -> Option<&(dyn core::error::Error + 'static)> {\n        core::error::Error::source(&**self)\n    }\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}