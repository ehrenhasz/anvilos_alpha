{
  "module_name": "lib.rs",
  "hash_id": "004a385a959a9c10837d6bb785f38e5d15c95cde06fd9a7b765dd33e61ade7bb",
  "original_prompt": "Ingested from linux-6.6.14/rust/alloc/lib.rs",
  "human_readable_source": "// SPDX-License-Identifier: Apache-2.0 OR MIT\n\n//! # The Rust core allocation and collections library\n//!\n//! This library provides smart pointers and collections for managing\n//! heap-allocated values.\n//!\n//! This library, like core, normally doesn\u2019t need to be used directly\n//! since its contents are re-exported in the [`std` crate](../std/index.html).\n//! Crates that use the `#![no_std]` attribute however will typically\n//! not depend on `std`, so they\u2019d use this crate instead.\n//!\n//! ## Boxed values\n//!\n//! The [`Box`] type is a smart pointer type. There can only be one owner of a\n//! [`Box`], and the owner can decide to mutate the contents, which live on the\n//! heap.\n//!\n//! This type can be sent among threads efficiently as the size of a `Box` value\n//! is the same as that of a pointer. Tree-like data structures are often built\n//! with boxes because each node often has only one owner, the parent.\n//!\n//! ## Reference counted pointers\n//!\n//! The [`Rc`] type is a non-threadsafe reference-counted pointer type intended\n//! for sharing memory within a thread. An [`Rc`] pointer wraps a type, `T`, and\n//! only allows access to `&T`, a shared reference.\n//!\n//! This type is useful when inherited mutability (such as using [`Box`]) is too\n//! constraining for an application, and is often paired with the [`Cell`] or\n//! [`RefCell`] types in order to allow mutation.\n//!\n//! ## Atomically reference counted pointers\n//!\n//! The [`Arc`] type is the threadsafe equivalent of the [`Rc`] type. It\n//! provides all the same functionality of [`Rc`], except it requires that the\n//! contained type `T` is shareable. Additionally, [`Arc<T>`][`Arc`] is itself\n//! sendable while [`Rc<T>`][`Rc`] is not.\n//!\n//! This type allows for shared access to the contained data, and is often\n//! paired with synchronization primitives such as mutexes to allow mutation of\n//! shared resources.\n//!\n//! ## Collections\n//!\n//! Implementations of the most common general purpose data structures are\n//! defined in this library. They are re-exported through the\n//! [standard collections library](../std/collections/index.html).\n//!\n//! ## Heap interfaces\n//!\n//! The [`alloc`](alloc/index.html) module defines the low-level interface to the\n//! default global allocator. It is not compatible with the libc allocator API.\n//!\n//! [`Arc`]: sync\n//! [`Box`]: boxed\n//! [`Cell`]: core::cell\n//! [`Rc`]: rc\n//! [`RefCell`]: core::cell\n\n#![allow(unused_attributes)]\n#![stable(feature = \"alloc\", since = \"1.36.0\")]\n#![doc(\n    html_playground_url = \"https://play.rust-lang.org/\",\n    issue_tracker_base_url = \"https://github.com/rust-lang/rust/issues/\",\n    test(no_crate_inject, attr(allow(unused_variables), deny(warnings)))\n)]\n#![doc(cfg_hide(\n    not(test),\n    not(any(test, bootstrap)),\n    any(not(feature = \"miri-test-libstd\"), test, doctest),\n    no_global_oom_handling,\n    not(no_global_oom_handling),\n    not(no_rc),\n    not(no_sync),\n    target_has_atomic = \"ptr\"\n))]\n#![no_std]\n#![needs_allocator]\n// To run alloc tests without x.py without ending up with two copies of alloc, Miri needs to be\n// able to \"empty\" this crate. See <https://github.com/rust-lang/miri-test-libstd/issues/4>.\n// rustc itself never sets the feature, so this line has no affect there.\n#![cfg(any(not(feature = \"miri-test-libstd\"), test, doctest))]\n//\n// Lints:\n#![deny(unsafe_op_in_unsafe_fn)]\n#![deny(fuzzy_provenance_casts)]\n#![warn(deprecated_in_future)]\n#![warn(missing_debug_implementations)]\n#![warn(missing_docs)]\n#![allow(explicit_outlives_requirements)]\n#![warn(multiple_supertrait_upcastable)]\n//\n// Library features:\n// tidy-alphabetical-start\n#![cfg_attr(not(no_global_oom_handling), feature(const_alloc_error))]\n#![cfg_attr(not(no_global_oom_handling), feature(const_btree_len))]\n#![cfg_attr(test, feature(is_sorted))]\n#![cfg_attr(test, feature(new_uninit))]\n#![feature(alloc_layout_extra)]\n#![feature(allocator_api)]\n#![feature(array_chunks)]\n#![feature(array_into_iter_constructors)]\n#![feature(array_methods)]\n#![feature(array_windows)]\n#![feature(ascii_char)]\n#![feature(assert_matches)]\n#![feature(async_iterator)]\n#![feature(coerce_unsized)]\n#![feature(const_align_of_val)]\n#![feature(const_box)]\n#![cfg_attr(not(no_borrow), feature(const_cow_is_borrowed))]\n#![feature(const_eval_select)]\n#![feature(const_maybe_uninit_as_mut_ptr)]\n#![feature(const_maybe_uninit_write)]\n#![feature(const_maybe_uninit_zeroed)]\n#![feature(const_pin)]\n#![feature(const_refs_to_cell)]\n#![feature(const_size_of_val)]\n#![feature(const_waker)]\n#![feature(core_intrinsics)]\n#![feature(core_panic)]\n#![feature(dispatch_from_dyn)]\n#![feature(error_generic_member_access)]\n#![feature(error_in_core)]\n#![feature(exact_size_is_empty)]\n#![feature(extend_one)]\n#![feature(fmt_internals)]\n#![feature(fn_traits)]\n#![feature(hasher_prefixfree_extras)]\n#![feature(inline_const)]\n#![feature(inplace_iteration)]\n#![feature(iter_advance_by)]\n#![feature(iter_next_chunk)]\n#![feature(iter_repeat_n)]\n#![feature(layout_for_ptr)]\n#![feature(maybe_uninit_slice)]\n#![feature(maybe_uninit_uninit_array)]\n#![feature(maybe_uninit_uninit_array_transpose)]\n#![feature(pattern)]\n#![feature(pointer_byte_offsets)]\n#![feature(provide_any)]\n#![feature(ptr_internals)]\n#![feature(ptr_metadata)]\n#![feature(ptr_sub_ptr)]\n#![feature(receiver_trait)]\n#![feature(saturating_int_impl)]\n#![feature(set_ptr_value)]\n#![feature(sized_type_properties)]\n#![feature(slice_from_ptr_range)]\n#![feature(slice_group_by)]\n#![feature(slice_ptr_get)]\n#![feature(slice_ptr_len)]\n#![feature(slice_range)]\n#![feature(std_internals)]\n#![feature(str_internals)]\n#![feature(strict_provenance)]\n#![feature(trusted_len)]\n#![feature(trusted_random_access)]\n#![feature(try_trait_v2)]\n#![feature(tuple_trait)]\n#![feature(unchecked_math)]\n#![feature(unicode_internals)]\n#![feature(unsize)]\n#![feature(utf8_chunks)]\n// tidy-alphabetical-end\n//\n// Language features:\n// tidy-alphabetical-start\n#![cfg_attr(not(test), feature(generator_trait))]\n#![cfg_attr(test, feature(panic_update_hook))]\n#![cfg_attr(test, feature(test))]\n#![feature(allocator_internals)]\n#![feature(allow_internal_unstable)]\n#![feature(associated_type_bounds)]\n#![feature(c_unwind)]\n#![feature(cfg_sanitize)]\n#![feature(const_mut_refs)]\n#![feature(const_precise_live_drops)]\n#![feature(const_ptr_write)]\n#![feature(const_trait_impl)]\n#![feature(const_try)]\n#![feature(dropck_eyepatch)]\n#![feature(exclusive_range_pattern)]\n#![feature(fundamental)]\n#![feature(hashmap_internals)]\n#![feature(lang_items)]\n#![feature(min_specialization)]\n#![feature(multiple_supertrait_upcastable)]\n#![feature(negative_impls)]\n#![feature(never_type)]\n#![feature(pointer_is_aligned)]\n#![feature(rustc_allow_const_fn_unstable)]\n#![feature(rustc_attrs)]\n#![feature(slice_internals)]\n#![feature(staged_api)]\n#![feature(stmt_expr_attributes)]\n#![feature(unboxed_closures)]\n#![feature(unsized_fn_params)]\n#![feature(with_negative_coherence)]\n// tidy-alphabetical-end\n//\n// Rustdoc features:\n#![feature(doc_cfg)]\n#![feature(doc_cfg_hide)]\n// Technically, this is a bug in rustdoc: rustdoc sees the documentation on `#[lang = slice_alloc]`\n// blocks is for `&[T]`, which also has documentation using this feature in `core`, and gets mad\n// that the feature-gate isn't enabled. Ideally, it wouldn't check for the feature gate for docs\n// from other crates, but since this can only appear for lang items, it doesn't seem worth fixing.\n#![feature(intra_doc_pointers)]\n\n// Allow testing this library\n#[cfg(test)]\n#[macro_use]\nextern crate std;\n#[cfg(test)]\nextern crate test;\n#[cfg(test)]\nmod testing;\n\n// Module with internal macros used by other modules (needs to be included before other modules).\n#[cfg(not(no_macros))]\n#[macro_use]\nmod macros;\n\nmod raw_vec;\n\n// Heaps provided for low-level allocation strategies\n\npub mod alloc;\n\n// Primitive types using the heaps above\n\n// Need to conditionally define the mod from `boxed.rs` to avoid\n// duplicating the lang-items when building in test cfg; but also need\n// to allow code to have `use boxed::Box;` declarations.\n#[cfg(not(test))]\npub mod boxed;\n#[cfg(test)]\nmod boxed {\n    pub use std::boxed::Box;\n}\n#[cfg(not(no_borrow))]\npub mod borrow;\npub mod collections;\n#[cfg(all(not(no_rc), not(no_sync), not(no_global_oom_handling)))]\npub mod ffi;\n#[cfg(not(no_fmt))]\npub mod fmt;\n#[cfg(not(no_rc))]\npub mod rc;\npub mod slice;\n#[cfg(not(no_str))]\npub mod str;\n#[cfg(not(no_string))]\npub mod string;\n#[cfg(all(not(no_rc), not(no_sync), target_has_atomic = \"ptr\"))]\npub mod sync;\n#[cfg(all(not(no_global_oom_handling), not(no_rc), not(no_sync), target_has_atomic = \"ptr\"))]\npub mod task;\n#[cfg(test)]\nmod tests;\npub mod vec;\n\n#[doc(hidden)]\n#[unstable(feature = \"liballoc_internals\", issue = \"none\", reason = \"implementation detail\")]\npub mod __export {\n    pub use core::format_args;\n}\n\n#[cfg(test)]\n#[allow(dead_code)] // Not used in all configurations\npub(crate) mod test_helpers {\n    /// Copied from `std::test_helpers::test_rng`, since these tests rely on the\n    /// seed not being the same for every RNG invocation too.\n    pub(crate) fn test_rng() -> rand_xorshift::XorShiftRng {\n        use std::hash::{BuildHasher, Hash, Hasher};\n        let mut hasher = std::collections::hash_map::RandomState::new().build_hasher();\n        std::panic::Location::caller().hash(&mut hasher);\n        let hc64 = hasher.finish();\n        let seed_vec =\n            hc64.to_le_bytes().into_iter().chain(0u8..8).collect::<crate::vec::Vec<u8>>();\n        let seed: [u8; 16] = seed_vec.as_slice().try_into().unwrap();\n        rand::SeedableRng::from_seed(seed)\n    }\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}