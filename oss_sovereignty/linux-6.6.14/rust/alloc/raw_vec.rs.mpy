{
  "module_name": "raw_vec.rs",
  "hash_id": "0470b62ec5d17ef445b536c26be3f1c54a084514e592cbcd42ec79c8736481b2",
  "original_prompt": "Ingested from linux-6.6.14/rust/alloc/raw_vec.rs",
  "human_readable_source": "// SPDX-License-Identifier: Apache-2.0 OR MIT\n\n#![unstable(feature = \"raw_vec_internals\", reason = \"unstable const warnings\", issue = \"none\")]\n\nuse core::alloc::LayoutError;\nuse core::cmp;\nuse core::intrinsics;\nuse core::mem::{self, ManuallyDrop, MaybeUninit, SizedTypeProperties};\nuse core::ptr::{self, NonNull, Unique};\nuse core::slice;\n\n#[cfg(not(no_global_oom_handling))]\nuse crate::alloc::handle_alloc_error;\nuse crate::alloc::{Allocator, Global, Layout};\nuse crate::boxed::Box;\nuse crate::collections::TryReserveError;\nuse crate::collections::TryReserveErrorKind::*;\n\n#[cfg(test)]\nmod tests;\n\nenum AllocInit {\n    /// The contents of the new memory are uninitialized.\n    Uninitialized,\n    /// The new memory is guaranteed to be zeroed.\n    #[allow(dead_code)]\n    Zeroed,\n}\n\n/// A low-level utility for more ergonomically allocating, reallocating, and deallocating\n/// a buffer of memory on the heap without having to worry about all the corner cases\n/// involved. This type is excellent for building your own data structures like Vec and VecDeque.\n/// In particular:\n///\n/// * Produces `Unique::dangling()` on zero-sized types.\n/// * Produces `Unique::dangling()` on zero-length allocations.\n/// * Avoids freeing `Unique::dangling()`.\n/// * Catches all overflows in capacity computations (promotes them to \"capacity overflow\" panics).\n/// * Guards against 32-bit systems allocating more than isize::MAX bytes.\n/// * Guards against overflowing your length.\n/// * Calls `handle_alloc_error` for fallible allocations.\n/// * Contains a `ptr::Unique` and thus endows the user with all related benefits.\n/// * Uses the excess returned from the allocator to use the largest available capacity.\n///\n/// This type does not in anyway inspect the memory that it manages. When dropped it *will*\n/// free its memory, but it *won't* try to drop its contents. It is up to the user of `RawVec`\n/// to handle the actual things *stored* inside of a `RawVec`.\n///\n/// Note that the excess of a zero-sized types is always infinite, so `capacity()` always returns\n/// `usize::MAX`. This means that you need to be careful when round-tripping this type with a\n/// `Box<[T]>`, since `capacity()` won't yield the length.\n#[allow(missing_debug_implementations)]\npub(crate) struct RawVec<T, A: Allocator = Global> {\n    ptr: Unique<T>,\n    cap: usize,\n    alloc: A,\n}\n\nimpl<T> RawVec<T, Global> {\n    /// HACK(Centril): This exists because stable `const fn` can only call stable `const fn`, so\n    /// they cannot call `Self::new()`.\n    ///\n    /// If you change `RawVec<T>::new` or dependencies, please take care to not introduce anything\n    /// that would truly const-call something unstable.\n    pub const NEW: Self = Self::new();\n\n    /// Creates the biggest possible `RawVec` (on the system heap)\n    /// without allocating. If `T` has positive size, then this makes a\n    /// `RawVec` with capacity `0`. If `T` is zero-sized, then it makes a\n    /// `RawVec` with capacity `usize::MAX`. Useful for implementing\n    /// delayed allocation.\n    #[must_use]\n    pub const fn new() -> Self {\n        Self::new_in(Global)\n    }\n\n    /// Creates a `RawVec` (on the system heap) with exactly the\n    /// capacity and alignment requirements for a `[T; capacity]`. This is\n    /// equivalent to calling `RawVec::new` when `capacity` is `0` or `T` is\n    /// zero-sized. Note that if `T` is zero-sized this means you will\n    /// *not* get a `RawVec` with the requested capacity.\n    ///\n    /// # Panics\n    ///\n    /// Panics if the requested capacity exceeds `isize::MAX` bytes.\n    ///\n    /// # Aborts\n    ///\n    /// Aborts on OOM.\n    #[cfg(not(any(no_global_oom_handling, test)))]\n    #[must_use]\n    #[inline]\n    pub fn with_capacity(capacity: usize) -> Self {\n        Self::with_capacity_in(capacity, Global)\n    }\n\n    /// Like `with_capacity`, but guarantees the buffer is zeroed.\n    #[cfg(not(any(no_global_oom_handling, test)))]\n    #[must_use]\n    #[inline]\n    pub fn with_capacity_zeroed(capacity: usize) -> Self {\n        Self::with_capacity_zeroed_in(capacity, Global)\n    }\n}\n\nimpl<T, A: Allocator> RawVec<T, A> {\n    // Tiny Vecs are dumb. Skip to:\n    // - 8 if the element size is 1, because any heap allocators is likely\n    //   to round up a request of less than 8 bytes to at least 8 bytes.\n    // - 4 if elements are moderate-sized (<= 1 KiB).\n    // - 1 otherwise, to avoid wasting too much space for very short Vecs.\n    pub(crate) const MIN_NON_ZERO_CAP: usize = if mem::size_of::<T>() == 1 {\n        8\n    } else if mem::size_of::<T>() <= 1024 {\n        4\n    } else {\n        1\n    };\n\n    /// Like `new`, but parameterized over the choice of allocator for\n    /// the returned `RawVec`.\n    pub const fn new_in(alloc: A) -> Self {\n        // `cap: 0` means \"unallocated\". zero-sized types are ignored.\n        Self { ptr: Unique::dangling(), cap: 0, alloc }\n    }\n\n    /// Like `with_capacity`, but parameterized over the choice of\n    /// allocator for the returned `RawVec`.\n    #[cfg(not(no_global_oom_handling))]\n    #[inline]\n    pub fn with_capacity_in(capacity: usize, alloc: A) -> Self {\n        Self::allocate_in(capacity, AllocInit::Uninitialized, alloc)\n    }\n\n    /// Like `try_with_capacity`, but parameterized over the choice of\n    /// allocator for the returned `RawVec`.\n    #[inline]\n    pub fn try_with_capacity_in(capacity: usize, alloc: A) -> Result<Self, TryReserveError> {\n        Self::try_allocate_in(capacity, AllocInit::Uninitialized, alloc)\n    }\n\n    /// Like `with_capacity_zeroed`, but parameterized over the choice\n    /// of allocator for the returned `RawVec`.\n    #[cfg(not(no_global_oom_handling))]\n    #[inline]\n    pub fn with_capacity_zeroed_in(capacity: usize, alloc: A) -> Self {\n        Self::allocate_in(capacity, AllocInit::Zeroed, alloc)\n    }\n\n    /// Converts the entire buffer into `Box<[MaybeUninit<T>]>` with the specified `len`.\n    ///\n    /// Note that this will correctly reconstitute any `cap` changes\n    /// that may have been performed. (See description of type for details.)\n    ///\n    /// # Safety\n    ///\n    /// * `len` must be greater than or equal to the most recently requested capacity, and\n    /// * `len` must be less than or equal to `self.capacity()`.\n    ///\n    /// Note, that the requested capacity and `self.capacity()` could differ, as\n    /// an allocator could overallocate and return a greater memory block than requested.\n    pub unsafe fn into_box(self, len: usize) -> Box<[MaybeUninit<T>], A> {\n        // Sanity-check one half of the safety requirement (we cannot check the other half).\n        debug_assert!(\n            len <= self.capacity(),\n            \"`len` must be smaller than or equal to `self.capacity()`\"\n        );\n\n        let me = ManuallyDrop::new(self);\n        unsafe {\n            let slice = slice::from_raw_parts_mut(me.ptr() as *mut MaybeUninit<T>, len);\n            Box::from_raw_in(slice, ptr::read(&me.alloc))\n        }\n    }\n\n    #[cfg(not(no_global_oom_handling))]\n    fn allocate_in(capacity: usize, init: AllocInit, alloc: A) -> Self {\n        // Don't allocate here because `Drop` will not deallocate when `capacity` is 0.\n        if T::IS_ZST || capacity == 0 {\n            Self::new_in(alloc)\n        } else {\n            // We avoid `unwrap_or_else` here because it bloats the amount of\n            // LLVM IR generated.\n            let layout = match Layout::array::<T>(capacity) {\n                Ok(layout) => layout,\n                Err(_) => capacity_overflow(),\n            };\n            match alloc_guard(layout.size()) {\n                Ok(_) => {}\n                Err(_) => capacity_overflow(),\n            }\n            let result = match init {\n                AllocInit::Uninitialized => alloc.allocate(layout),\n                AllocInit::Zeroed => alloc.allocate_zeroed(layout),\n            };\n            let ptr = match result {\n                Ok(ptr) => ptr,\n                Err(_) => handle_alloc_error(layout),\n            };\n\n            // Allocators currently return a `NonNull<[u8]>` whose length\n            // matches the size requested. If that ever changes, the capacity\n            // here should change to `ptr.len() / mem::size_of::<T>()`.\n            Self {\n                ptr: unsafe { Unique::new_unchecked(ptr.cast().as_ptr()) },\n                cap: capacity,\n                alloc,\n            }\n        }\n    }\n\n    fn try_allocate_in(capacity: usize, init: AllocInit, alloc: A) -> Result<Self, TryReserveError> {\n        // Don't allocate here because `Drop` will not deallocate when `capacity` is 0.\n        if T::IS_ZST || capacity == 0 {\n            return Ok(Self::new_in(alloc));\n        }\n\n        let layout = Layout::array::<T>(capacity).map_err(|_| CapacityOverflow)?;\n        alloc_guard(layout.size())?;\n        let result = match init {\n            AllocInit::Uninitialized => alloc.allocate(layout),\n            AllocInit::Zeroed => alloc.allocate_zeroed(layout),\n        };\n        let ptr = result.map_err(|_| AllocError { layout, non_exhaustive: () })?;\n\n        // Allocators currently return a `NonNull<[u8]>` whose length\n        // matches the size requested. If that ever changes, the capacity\n        // here should change to `ptr.len() / mem::size_of::<T>()`.\n        Ok(Self {\n            ptr: unsafe { Unique::new_unchecked(ptr.cast().as_ptr()) },\n            cap: capacity,\n            alloc,\n        })\n    }\n\n    /// Reconstitutes a `RawVec` from a pointer, capacity, and allocator.\n    ///\n    /// # Safety\n    ///\n    /// The `ptr` must be allocated (via the given allocator `alloc`), and with the given\n    /// `capacity`.\n    /// The `capacity` cannot exceed `isize::MAX` for sized types. (only a concern on 32-bit\n    /// systems). ZST vectors may have a capacity up to `usize::MAX`.\n    /// If the `ptr` and `capacity` come from a `RawVec` created via `alloc`, then this is\n    /// guaranteed.\n    #[inline]\n    pub unsafe fn from_raw_parts_in(ptr: *mut T, capacity: usize, alloc: A) -> Self {\n        Self { ptr: unsafe { Unique::new_unchecked(ptr) }, cap: capacity, alloc }\n    }\n\n    /// Gets a raw pointer to the start of the allocation. Note that this is\n    /// `Unique::dangling()` if `capacity == 0` or `T` is zero-sized. In the former case, you must\n    /// be careful.\n    #[inline]\n    pub fn ptr(&self) -> *mut T {\n        self.ptr.as_ptr()\n    }\n\n    /// Gets the capacity of the allocation.\n    ///\n    /// This will always be `usize::MAX` if `T` is zero-sized.\n    #[inline(always)]\n    pub fn capacity(&self) -> usize {\n        if T::IS_ZST { usize::MAX } else { self.cap }\n    }\n\n    /// Returns a shared reference to the allocator backing this `RawVec`.\n    pub fn allocator(&self) -> &A {\n        &self.alloc\n    }\n\n    fn current_memory(&self) -> Option<(NonNull<u8>, Layout)> {\n        if T::IS_ZST || self.cap == 0 {\n            None\n        } else {\n            // We could use Layout::array here which ensures the absence of isize and usize overflows\n            // and could hypothetically handle differences between stride and size, but this memory\n            // has already been allocated so we know it can't overflow and currently rust does not\n            // support such types. So we can do better by skipping some checks and avoid an unwrap.\n            let _: () = const { assert!(mem::size_of::<T>() % mem::align_of::<T>() == 0) };\n            unsafe {\n                let align = mem::align_of::<T>();\n                let size = mem::size_of::<T>().unchecked_mul(self.cap);\n                let layout = Layout::from_size_align_unchecked(size, align);\n                Some((self.ptr.cast().into(), layout))\n            }\n        }\n    }\n\n    /// Ensures that the buffer contains at least enough space to hold `len +\n    /// additional` elements. If it doesn't already have enough capacity, will\n    /// reallocate enough space plus comfortable slack space to get amortized\n    /// *O*(1) behavior. Will limit this behavior if it would needlessly cause\n    /// itself to panic.\n    ///\n    /// If `len` exceeds `self.capacity()`, this may fail to actually allocate\n    /// the requested space. This is not really unsafe, but the unsafe\n    /// code *you* write that relies on the behavior of this function may break.\n    ///\n    /// This is ideal for implementing a bulk-push operation like `extend`.\n    ///\n    /// # Panics\n    ///\n    /// Panics if the new capacity exceeds `isize::MAX` bytes.\n    ///\n    /// # Aborts\n    ///\n    /// Aborts on OOM.\n    #[cfg(not(no_global_oom_handling))]\n    #[inline]\n    pub fn reserve(&mut self, len: usize, additional: usize) {\n        // Callers expect this function to be very cheap when there is already sufficient capacity.\n        // Therefore, we move all the resizing and error-handling logic from grow_amortized and\n        // handle_reserve behind a call, while making sure that this function is likely to be\n        // inlined as just a comparison and a call if the comparison fails.\n        #[cold]\n        fn do_reserve_and_handle<T, A: Allocator>(\n            slf: &mut RawVec<T, A>,\n            len: usize,\n            additional: usize,\n        ) {\n            handle_reserve(slf.grow_amortized(len, additional));\n        }\n\n        if self.needs_to_grow(len, additional) {\n            do_reserve_and_handle(self, len, additional);\n        }\n    }\n\n    /// A specialized version of `reserve()` used only by the hot and\n    /// oft-instantiated `Vec::push()`, which does its own capacity check.\n    #[cfg(not(no_global_oom_handling))]\n    #[inline(never)]\n    pub fn reserve_for_push(&mut self, len: usize) {\n        handle_reserve(self.grow_amortized(len, 1));\n    }\n\n    /// The same as `reserve`, but returns on errors instead of panicking or aborting.\n    pub fn try_reserve(&mut self, len: usize, additional: usize) -> Result<(), TryReserveError> {\n        if self.needs_to_grow(len, additional) {\n            self.grow_amortized(len, additional)\n        } else {\n            Ok(())\n        }\n    }\n\n    /// The same as `reserve_for_push`, but returns on errors instead of panicking or aborting.\n    #[inline(never)]\n    pub fn try_reserve_for_push(&mut self, len: usize) -> Result<(), TryReserveError> {\n        self.grow_amortized(len, 1)\n    }\n\n    /// Ensures that the buffer contains at least enough space to hold `len +\n    /// additional` elements. If it doesn't already, will reallocate the\n    /// minimum possible amount of memory necessary. Generally this will be\n    /// exactly the amount of memory necessary, but in principle the allocator\n    /// is free to give back more than we asked for.\n    ///\n    /// If `len` exceeds `self.capacity()`, this may fail to actually allocate\n    /// the requested space. This is not really unsafe, but the unsafe code\n    /// *you* write that relies on the behavior of this function may break.\n    ///\n    /// # Panics\n    ///\n    /// Panics if the new capacity exceeds `isize::MAX` bytes.\n    ///\n    /// # Aborts\n    ///\n    /// Aborts on OOM.\n    #[cfg(not(no_global_oom_handling))]\n    pub fn reserve_exact(&mut self, len: usize, additional: usize) {\n        handle_reserve(self.try_reserve_exact(len, additional));\n    }\n\n    /// The same as `reserve_exact`, but returns on errors instead of panicking or aborting.\n    pub fn try_reserve_exact(\n        &mut self,\n        len: usize,\n        additional: usize,\n    ) -> Result<(), TryReserveError> {\n        if self.needs_to_grow(len, additional) { self.grow_exact(len, additional) } else { Ok(()) }\n    }\n\n    /// Shrinks the buffer down to the specified capacity. If the given amount\n    /// is 0, actually completely deallocates.\n    ///\n    /// # Panics\n    ///\n    /// Panics if the given amount is *larger* than the current capacity.\n    ///\n    /// # Aborts\n    ///\n    /// Aborts on OOM.\n    #[cfg(not(no_global_oom_handling))]\n    pub fn shrink_to_fit(&mut self, cap: usize) {\n        handle_reserve(self.shrink(cap));\n    }\n}\n\nimpl<T, A: Allocator> RawVec<T, A> {\n    /// Returns if the buffer needs to grow to fulfill the needed extra capacity.\n    /// Mainly used to make inlining reserve-calls possible without inlining `grow`.\n    fn needs_to_grow(&self, len: usize, additional: usize) -> bool {\n        additional > self.capacity().wrapping_sub(len)\n    }\n\n    fn set_ptr_and_cap(&mut self, ptr: NonNull<[u8]>, cap: usize) {\n        // Allocators currently return a `NonNull<[u8]>` whose length matches\n        // the size requested. If that ever changes, the capacity here should\n        // change to `ptr.len() / mem::size_of::<T>()`.\n        self.ptr = unsafe { Unique::new_unchecked(ptr.cast().as_ptr()) };\n        self.cap = cap;\n    }\n\n    // This method is usually instantiated many times. So we want it to be as\n    // small as possible, to improve compile times. But we also want as much of\n    // its contents to be statically computable as possible, to make the\n    // generated code run faster. Therefore, this method is carefully written\n    // so that all of the code that depends on `T` is within it, while as much\n    // of the code that doesn't depend on `T` as possible is in functions that\n    // are non-generic over `T`.\n    fn grow_amortized(&mut self, len: usize, additional: usize) -> Result<(), TryReserveError> {\n        // This is ensured by the calling contexts.\n        debug_assert!(additional > 0);\n\n        if T::IS_ZST {\n            // Since we return a capacity of `usize::MAX` when `elem_size` is\n            // 0, getting to here necessarily means the `RawVec` is overfull.\n            return Err(CapacityOverflow.into());\n        }\n\n        // Nothing we can really do about these checks, sadly.\n        let required_cap = len.checked_add(additional).ok_or(CapacityOverflow)?;\n\n        // This guarantees exponential growth. The doubling cannot overflow\n        // because `cap <= isize::MAX` and the type of `cap` is `usize`.\n        let cap = cmp::max(self.cap * 2, required_cap);\n        let cap = cmp::max(Self::MIN_NON_ZERO_CAP, cap);\n\n        let new_layout = Layout::array::<T>(cap);\n\n        // `finish_grow` is non-generic over `T`.\n        let ptr = finish_grow(new_layout, self.current_memory(), &mut self.alloc)?;\n        self.set_ptr_and_cap(ptr, cap);\n        Ok(())\n    }\n\n    // The constraints on this method are much the same as those on\n    // `grow_amortized`, but this method is usually instantiated less often so\n    // it's less critical.\n    fn grow_exact(&mut self, len: usize, additional: usize) -> Result<(), TryReserveError> {\n        if T::IS_ZST {\n            // Since we return a capacity of `usize::MAX` when the type size is\n            // 0, getting to here necessarily means the `RawVec` is overfull.\n            return Err(CapacityOverflow.into());\n        }\n\n        let cap = len.checked_add(additional).ok_or(CapacityOverflow)?;\n        let new_layout = Layout::array::<T>(cap);\n\n        // `finish_grow` is non-generic over `T`.\n        let ptr = finish_grow(new_layout, self.current_memory(), &mut self.alloc)?;\n        self.set_ptr_and_cap(ptr, cap);\n        Ok(())\n    }\n\n    #[cfg(not(no_global_oom_handling))]\n    fn shrink(&mut self, cap: usize) -> Result<(), TryReserveError> {\n        assert!(cap <= self.capacity(), \"Tried to shrink to a larger capacity\");\n\n        let (ptr, layout) = if let Some(mem) = self.current_memory() { mem } else { return Ok(()) };\n        // See current_memory() why this assert is here\n        let _: () = const { assert!(mem::size_of::<T>() % mem::align_of::<T>() == 0) };\n        let ptr = unsafe {\n            // `Layout::array` cannot overflow here because it would have\n            // overflowed earlier when capacity was larger.\n            let new_size = mem::size_of::<T>().unchecked_mul(cap);\n            let new_layout = Layout::from_size_align_unchecked(new_size, layout.align());\n            self.alloc\n                .shrink(ptr, layout, new_layout)\n                .map_err(|_| AllocError { layout: new_layout, non_exhaustive: () })?\n        };\n        self.set_ptr_and_cap(ptr, cap);\n        Ok(())\n    }\n}\n\n// This function is outside `RawVec` to minimize compile times. See the comment\n// above `RawVec::grow_amortized` for details. (The `A` parameter isn't\n// significant, because the number of different `A` types seen in practice is\n// much smaller than the number of `T` types.)\n#[inline(never)]\nfn finish_grow<A>(\n    new_layout: Result<Layout, LayoutError>,\n    current_memory: Option<(NonNull<u8>, Layout)>,\n    alloc: &mut A,\n) -> Result<NonNull<[u8]>, TryReserveError>\nwhere\n    A: Allocator,\n{\n    // Check for the error here to minimize the size of `RawVec::grow_*`.\n    let new_layout = new_layout.map_err(|_| CapacityOverflow)?;\n\n    alloc_guard(new_layout.size())?;\n\n    let memory = if let Some((ptr, old_layout)) = current_memory {\n        debug_assert_eq!(old_layout.align(), new_layout.align());\n        unsafe {\n            // The allocator checks for alignment equality\n            intrinsics::assume(old_layout.align() == new_layout.align());\n            alloc.grow(ptr, old_layout, new_layout)\n        }\n    } else {\n        alloc.allocate(new_layout)\n    };\n\n    memory.map_err(|_| AllocError { layout: new_layout, non_exhaustive: () }.into())\n}\n\nunsafe impl<#[may_dangle] T, A: Allocator> Drop for RawVec<T, A> {\n    /// Frees the memory owned by the `RawVec` *without* trying to drop its contents.\n    fn drop(&mut self) {\n        if let Some((ptr, layout)) = self.current_memory() {\n            unsafe { self.alloc.deallocate(ptr, layout) }\n        }\n    }\n}\n\n// Central function for reserve error handling.\n#[cfg(not(no_global_oom_handling))]\n#[inline]\nfn handle_reserve(result: Result<(), TryReserveError>) {\n    match result.map_err(|e| e.kind()) {\n        Err(CapacityOverflow) => capacity_overflow(),\n        Err(AllocError { layout, .. }) => handle_alloc_error(layout),\n        Ok(()) => { /* yay */ }\n    }\n}\n\n// We need to guarantee the following:\n// * We don't ever allocate `> isize::MAX` byte-size objects.\n// * We don't overflow `usize::MAX` and actually allocate too little.\n//\n// On 64-bit we just need to check for overflow since trying to allocate\n// `> isize::MAX` bytes will surely fail. On 32-bit and 16-bit we need to add\n// an extra guard for this in case we're running on a platform which can use\n// all 4GB in user-space, e.g., PAE or x32.\n\n#[inline]\nfn alloc_guard(alloc_size: usize) -> Result<(), TryReserveError> {\n    if usize::BITS < 64 && alloc_size > isize::MAX as usize {\n        Err(CapacityOverflow.into())\n    } else {\n        Ok(())\n    }\n}\n\n// One central function responsible for reporting capacity overflows. This'll\n// ensure that the code generation related to these panics is minimal as there's\n// only one location which panics rather than a bunch throughout the module.\n#[cfg(not(no_global_oom_handling))]\nfn capacity_overflow() -> ! {\n    panic!(\"capacity overflow\");\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}