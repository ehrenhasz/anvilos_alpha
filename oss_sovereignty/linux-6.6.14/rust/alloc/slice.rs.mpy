{
  "module_name": "slice.rs",
  "hash_id": "0a393d47d2c180186ec00c2de9f177d359f9be4cc9df35546b19e20ad002ffda",
  "original_prompt": "Ingested from linux-6.6.14/rust/alloc/slice.rs",
  "human_readable_source": "// SPDX-License-Identifier: Apache-2.0 OR MIT\n\n//! Utilities for the slice primitive type.\n//!\n//! *[See also the slice primitive type](slice).*\n//!\n//! Most of the structs in this module are iterator types which can only be created\n//! using a certain function. For example, `slice.iter()` yields an [`Iter`].\n//!\n//! A few functions are provided to create a slice from a value reference\n//! or from a raw pointer.\n#![stable(feature = \"rust1\", since = \"1.0.0\")]\n// Many of the usings in this module are only used in the test configuration.\n// It's cleaner to just turn off the unused_imports warning than to fix them.\n#![cfg_attr(test, allow(unused_imports, dead_code))]\n\nuse core::borrow::{Borrow, BorrowMut};\n#[cfg(not(no_global_oom_handling))]\nuse core::cmp::Ordering::{self, Less};\n#[cfg(not(no_global_oom_handling))]\nuse core::mem::{self, SizedTypeProperties};\n#[cfg(not(no_global_oom_handling))]\nuse core::ptr;\n#[cfg(not(no_global_oom_handling))]\nuse core::slice::sort;\n\nuse crate::alloc::Allocator;\n#[cfg(not(no_global_oom_handling))]\nuse crate::alloc::{self, Global};\n#[cfg(not(no_global_oom_handling))]\nuse crate::borrow::ToOwned;\nuse crate::boxed::Box;\nuse crate::vec::Vec;\n\n#[cfg(test)]\nmod tests;\n\n#[unstable(feature = \"slice_range\", issue = \"76393\")]\npub use core::slice::range;\n#[unstable(feature = \"array_chunks\", issue = \"74985\")]\npub use core::slice::ArrayChunks;\n#[unstable(feature = \"array_chunks\", issue = \"74985\")]\npub use core::slice::ArrayChunksMut;\n#[unstable(feature = \"array_windows\", issue = \"75027\")]\npub use core::slice::ArrayWindows;\n#[stable(feature = \"inherent_ascii_escape\", since = \"1.60.0\")]\npub use core::slice::EscapeAscii;\n#[stable(feature = \"slice_get_slice\", since = \"1.28.0\")]\npub use core::slice::SliceIndex;\n#[stable(feature = \"from_ref\", since = \"1.28.0\")]\npub use core::slice::{from_mut, from_ref};\n#[unstable(feature = \"slice_from_ptr_range\", issue = \"89792\")]\npub use core::slice::{from_mut_ptr_range, from_ptr_range};\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use core::slice::{from_raw_parts, from_raw_parts_mut};\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use core::slice::{Chunks, Windows};\n#[stable(feature = \"chunks_exact\", since = \"1.31.0\")]\npub use core::slice::{ChunksExact, ChunksExactMut};\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use core::slice::{ChunksMut, Split, SplitMut};\n#[unstable(feature = \"slice_group_by\", issue = \"80552\")]\npub use core::slice::{GroupBy, GroupByMut};\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use core::slice::{Iter, IterMut};\n#[stable(feature = \"rchunks\", since = \"1.31.0\")]\npub use core::slice::{RChunks, RChunksExact, RChunksExactMut, RChunksMut};\n#[stable(feature = \"slice_rsplit\", since = \"1.27.0\")]\npub use core::slice::{RSplit, RSplitMut};\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\npub use core::slice::{RSplitN, RSplitNMut, SplitN, SplitNMut};\n#[stable(feature = \"split_inclusive\", since = \"1.51.0\")]\npub use core::slice::{SplitInclusive, SplitInclusiveMut};\n\n////////////////////////////////////////////////////////////////////////////////\n// Basic slice extension methods\n////////////////////////////////////////////////////////////////////////////////\n\n// HACK(japaric) needed for the implementation of `vec!` macro during testing\n// N.B., see the `hack` module in this file for more details.\n#[cfg(test)]\npub use hack::into_vec;\n\n// HACK(japaric) needed for the implementation of `Vec::clone` during testing\n// N.B., see the `hack` module in this file for more details.\n#[cfg(test)]\npub use hack::to_vec;\n\n// HACK(japaric): With cfg(test) `impl [T]` is not available, these three\n// functions are actually methods that are in `impl [T]` but not in\n// `core::slice::SliceExt` - we need to supply these functions for the\n// `test_permutations` test\npub(crate) mod hack {\n    use core::alloc::Allocator;\n\n    use crate::boxed::Box;\n    use crate::vec::Vec;\n\n    // We shouldn't add inline attribute to this since this is used in\n    // `vec!` macro mostly and causes perf regression. See #71204 for\n    // discussion and perf results.\n    pub fn into_vec<T, A: Allocator>(b: Box<[T], A>) -> Vec<T, A> {\n        unsafe {\n            let len = b.len();\n            let (b, alloc) = Box::into_raw_with_allocator(b);\n            Vec::from_raw_parts_in(b as *mut T, len, len, alloc)\n        }\n    }\n\n    #[cfg(not(no_global_oom_handling))]\n    #[inline]\n    pub fn to_vec<T: ConvertVec, A: Allocator>(s: &[T], alloc: A) -> Vec<T, A> {\n        T::to_vec(s, alloc)\n    }\n\n    #[cfg(not(no_global_oom_handling))]\n    pub trait ConvertVec {\n        fn to_vec<A: Allocator>(s: &[Self], alloc: A) -> Vec<Self, A>\n        where\n            Self: Sized;\n    }\n\n    #[cfg(not(no_global_oom_handling))]\n    impl<T: Clone> ConvertVec for T {\n        #[inline]\n        default fn to_vec<A: Allocator>(s: &[Self], alloc: A) -> Vec<Self, A> {\n            struct DropGuard<'a, T, A: Allocator> {\n                vec: &'a mut Vec<T, A>,\n                num_init: usize,\n            }\n            impl<'a, T, A: Allocator> Drop for DropGuard<'a, T, A> {\n                #[inline]\n                fn drop(&mut self) {\n                    // SAFETY:\n                    // items were marked initialized in the loop below\n                    unsafe {\n                        self.vec.set_len(self.num_init);\n                    }\n                }\n            }\n            let mut vec = Vec::with_capacity_in(s.len(), alloc);\n            let mut guard = DropGuard { vec: &mut vec, num_init: 0 };\n            let slots = guard.vec.spare_capacity_mut();\n            // .take(slots.len()) is necessary for LLVM to remove bounds checks\n            // and has better codegen than zip.\n            for (i, b) in s.iter().enumerate().take(slots.len()) {\n                guard.num_init = i;\n                slots[i].write(b.clone());\n            }\n            core::mem::forget(guard);\n            // SAFETY:\n            // the vec was allocated and initialized above to at least this length.\n            unsafe {\n                vec.set_len(s.len());\n            }\n            vec\n        }\n    }\n\n    #[cfg(not(no_global_oom_handling))]\n    impl<T: Copy> ConvertVec for T {\n        #[inline]\n        fn to_vec<A: Allocator>(s: &[Self], alloc: A) -> Vec<Self, A> {\n            let mut v = Vec::with_capacity_in(s.len(), alloc);\n            // SAFETY:\n            // allocated above with the capacity of `s`, and initialize to `s.len()` in\n            // ptr::copy_to_non_overlapping below.\n            unsafe {\n                s.as_ptr().copy_to_nonoverlapping(v.as_mut_ptr(), s.len());\n                v.set_len(s.len());\n            }\n            v\n        }\n    }\n}\n\n#[cfg(not(test))]\nimpl<T> [T] {\n    /// Sorts the slice.\n    ///\n    /// This sort is stable (i.e., does not reorder equal elements) and *O*(*n* \\* log(*n*)) worst-case.\n    ///\n    /// When applicable, unstable sorting is preferred because it is generally faster than stable\n    /// sorting and it doesn't allocate auxiliary memory.\n    /// See [`sort_unstable`](slice::sort_unstable).\n    ///\n    /// # Current implementation\n    ///\n    /// The current algorithm is an adaptive, iterative merge sort inspired by\n    /// [timsort](https://en.wikipedia.org/wiki/Timsort).\n    /// It is designed to be very fast in cases where the slice is nearly sorted, or consists of\n    /// two or more sorted sequences concatenated one after another.\n    ///\n    /// Also, it allocates temporary storage half the size of `self`, but for short slices a\n    /// non-allocating insertion sort is used instead.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut v = [-5, 4, 1, -3, 2];\n    ///\n    /// v.sort();\n    /// assert!(v == [-5, -3, 1, 2, 4]);\n    /// ```\n    #[cfg(not(no_global_oom_handling))]\n    #[rustc_allow_incoherent_impl]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn sort(&mut self)\n    where\n        T: Ord,\n    {\n        stable_sort(self, T::lt);\n    }\n\n    /// Sorts the slice with a comparator function.\n    ///\n    /// This sort is stable (i.e., does not reorder equal elements) and *O*(*n* \\* log(*n*)) worst-case.\n    ///\n    /// The comparator function must define a total ordering for the elements in the slice. If\n    /// the ordering is not total, the order of the elements is unspecified. An order is a\n    /// total order if it is (for all `a`, `b` and `c`):\n    ///\n    /// * total and antisymmetric: exactly one of `a < b`, `a == b` or `a > b` is true, and\n    /// * transitive, `a < b` and `b < c` implies `a < c`. The same must hold for both `==` and `>`.\n    ///\n    /// For example, while [`f64`] doesn't implement [`Ord`] because `NaN != NaN`, we can use\n    /// `partial_cmp` as our sort function when we know the slice doesn't contain a `NaN`.\n    ///\n    /// ```\n    /// let mut floats = [5f64, 4.0, 1.0, 3.0, 2.0];\n    /// floats.sort_by(|a, b| a.partial_cmp(b).unwrap());\n    /// assert_eq!(floats, [1.0, 2.0, 3.0, 4.0, 5.0]);\n    /// ```\n    ///\n    /// When applicable, unstable sorting is preferred because it is generally faster than stable\n    /// sorting and it doesn't allocate auxiliary memory.\n    /// See [`sort_unstable_by`](slice::sort_unstable_by).\n    ///\n    /// # Current implementation\n    ///\n    /// The current algorithm is an adaptive, iterative merge sort inspired by\n    /// [timsort](https://en.wikipedia.org/wiki/Timsort).\n    /// It is designed to be very fast in cases where the slice is nearly sorted, or consists of\n    /// two or more sorted sequences concatenated one after another.\n    ///\n    /// Also, it allocates temporary storage half the size of `self`, but for short slices a\n    /// non-allocating insertion sort is used instead.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut v = [5, 4, 1, 3, 2];\n    /// v.sort_by(|a, b| a.cmp(b));\n    /// assert!(v == [1, 2, 3, 4, 5]);\n    ///\n    /// // reverse sorting\n    /// v.sort_by(|a, b| b.cmp(a));\n    /// assert!(v == [5, 4, 3, 2, 1]);\n    /// ```\n    #[cfg(not(no_global_oom_handling))]\n    #[rustc_allow_incoherent_impl]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn sort_by<F>(&mut self, mut compare: F)\n    where\n        F: FnMut(&T, &T) -> Ordering,\n    {\n        stable_sort(self, |a, b| compare(a, b) == Less);\n    }\n\n    /// Sorts the slice with a key extraction function.\n    ///\n    /// This sort is stable (i.e., does not reorder equal elements) and *O*(*m* \\* *n* \\* log(*n*))\n    /// worst-case, where the key function is *O*(*m*).\n    ///\n    /// For expensive key functions (e.g. functions that are not simple property accesses or\n    /// basic operations), [`sort_by_cached_key`](slice::sort_by_cached_key) is likely to be\n    /// significantly faster, as it does not recompute element keys.\n    ///\n    /// When applicable, unstable sorting is preferred because it is generally faster than stable\n    /// sorting and it doesn't allocate auxiliary memory.\n    /// See [`sort_unstable_by_key`](slice::sort_unstable_by_key).\n    ///\n    /// # Current implementation\n    ///\n    /// The current algorithm is an adaptive, iterative merge sort inspired by\n    /// [timsort](https://en.wikipedia.org/wiki/Timsort).\n    /// It is designed to be very fast in cases where the slice is nearly sorted, or consists of\n    /// two or more sorted sequences concatenated one after another.\n    ///\n    /// Also, it allocates temporary storage half the size of `self`, but for short slices a\n    /// non-allocating insertion sort is used instead.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut v = [-5i32, 4, 1, -3, 2];\n    ///\n    /// v.sort_by_key(|k| k.abs());\n    /// assert!(v == [1, 2, -3, 4, -5]);\n    /// ```\n    #[cfg(not(no_global_oom_handling))]\n    #[rustc_allow_incoherent_impl]\n    #[stable(feature = \"slice_sort_by_key\", since = \"1.7.0\")]\n    #[inline]\n    pub fn sort_by_key<K, F>(&mut self, mut f: F)\n    where\n        F: FnMut(&T) -> K,\n        K: Ord,\n    {\n        stable_sort(self, |a, b| f(a).lt(&f(b)));\n    }\n\n    /// Sorts the slice with a key extraction function.\n    ///\n    /// During sorting, the key function is called at most once per element, by using\n    /// temporary storage to remember the results of key evaluation.\n    /// The order of calls to the key function is unspecified and may change in future versions\n    /// of the standard library.\n    ///\n    /// This sort is stable (i.e., does not reorder equal elements) and *O*(*m* \\* *n* + *n* \\* log(*n*))\n    /// worst-case, where the key function is *O*(*m*).\n    ///\n    /// For simple key functions (e.g., functions that are property accesses or\n    /// basic operations), [`sort_by_key`](slice::sort_by_key) is likely to be\n    /// faster.\n    ///\n    /// # Current implementation\n    ///\n    /// The current algorithm is based on [pattern-defeating quicksort][pdqsort] by Orson Peters,\n    /// which combines the fast average case of randomized quicksort with the fast worst case of\n    /// heapsort, while achieving linear time on slices with certain patterns. It uses some\n    /// randomization to avoid degenerate cases, but with a fixed seed to always provide\n    /// deterministic behavior.\n    ///\n    /// In the worst case, the algorithm allocates temporary storage in a `Vec<(K, usize)>` the\n    /// length of the slice.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let mut v = [-5i32, 4, 32, -3, 2];\n    ///\n    /// v.sort_by_cached_key(|k| k.to_string());\n    /// assert!(v == [-3, -5, 2, 32, 4]);\n    /// ```\n    ///\n    /// [pdqsort]: https://github.com/orlp/pdqsort\n    #[cfg(not(no_global_oom_handling))]\n    #[rustc_allow_incoherent_impl]\n    #[stable(feature = \"slice_sort_by_cached_key\", since = \"1.34.0\")]\n    #[inline]\n    pub fn sort_by_cached_key<K, F>(&mut self, f: F)\n    where\n        F: FnMut(&T) -> K,\n        K: Ord,\n    {\n        // Helper macro for indexing our vector by the smallest possible type, to reduce allocation.\n        macro_rules! sort_by_key {\n            ($t:ty, $slice:ident, $f:ident) => {{\n                let mut indices: Vec<_> =\n                    $slice.iter().map($f).enumerate().map(|(i, k)| (k, i as $t)).collect();\n                // The elements of `indices` are unique, as they are indexed, so any sort will be\n                // stable with respect to the original slice. We use `sort_unstable` here because\n                // it requires less memory allocation.\n                indices.sort_unstable();\n                for i in 0..$slice.len() {\n                    let mut index = indices[i].1;\n                    while (index as usize) < i {\n                        index = indices[index as usize].1;\n                    }\n                    indices[i].1 = index;\n                    $slice.swap(i, index as usize);\n                }\n            }};\n        }\n\n        let sz_u8 = mem::size_of::<(K, u8)>();\n        let sz_u16 = mem::size_of::<(K, u16)>();\n        let sz_u32 = mem::size_of::<(K, u32)>();\n        let sz_usize = mem::size_of::<(K, usize)>();\n\n        let len = self.len();\n        if len < 2 {\n            return;\n        }\n        if sz_u8 < sz_u16 && len <= (u8::MAX as usize) {\n            return sort_by_key!(u8, self, f);\n        }\n        if sz_u16 < sz_u32 && len <= (u16::MAX as usize) {\n            return sort_by_key!(u16, self, f);\n        }\n        if sz_u32 < sz_usize && len <= (u32::MAX as usize) {\n            return sort_by_key!(u32, self, f);\n        }\n        sort_by_key!(usize, self, f)\n    }\n\n    /// Copies `self` into a new `Vec`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let s = [10, 40, 30];\n    /// let x = s.to_vec();\n    /// // Here, `s` and `x` can be modified independently.\n    /// ```\n    #[cfg(not(no_global_oom_handling))]\n    #[rustc_allow_incoherent_impl]\n    #[rustc_conversion_suggestion]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn to_vec(&self) -> Vec<T>\n    where\n        T: Clone,\n    {\n        self.to_vec_in(Global)\n    }\n\n    /// Copies `self` into a new `Vec` with an allocator.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// #![feature(allocator_api)]\n    ///\n    /// use std::alloc::System;\n    ///\n    /// let s = [10, 40, 30];\n    /// let x = s.to_vec_in(System);\n    /// // Here, `s` and `x` can be modified independently.\n    /// ```\n    #[cfg(not(no_global_oom_handling))]\n    #[rustc_allow_incoherent_impl]\n    #[inline]\n    #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n    pub fn to_vec_in<A: Allocator>(&self, alloc: A) -> Vec<T, A>\n    where\n        T: Clone,\n    {\n        // N.B., see the `hack` module in this file for more details.\n        hack::to_vec(self, alloc)\n    }\n\n    /// Converts `self` into a vector without clones or allocation.\n    ///\n    /// The resulting vector can be converted back into a box via\n    /// `Vec<T>`'s `into_boxed_slice` method.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let s: Box<[i32]> = Box::new([10, 40, 30]);\n    /// let x = s.into_vec();\n    /// // `s` cannot be used anymore because it has been converted into `x`.\n    ///\n    /// assert_eq!(x, vec![10, 40, 30]);\n    /// ```\n    #[rustc_allow_incoherent_impl]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[inline]\n    pub fn into_vec<A: Allocator>(self: Box<Self, A>) -> Vec<T, A> {\n        // N.B., see the `hack` module in this file for more details.\n        hack::into_vec(self)\n    }\n\n    /// Creates a vector by copying a slice `n` times.\n    ///\n    /// # Panics\n    ///\n    /// This function will panic if the capacity would overflow.\n    ///\n    /// # Examples\n    ///\n    /// Basic usage:\n    ///\n    /// ```\n    /// assert_eq!([1, 2].repeat(3), vec![1, 2, 1, 2, 1, 2]);\n    /// ```\n    ///\n    /// A panic upon overflow:\n    ///\n    /// ```should_panic\n    /// // this will panic at runtime\n    /// b\"0123456789abcdef\".repeat(usize::MAX);\n    /// ```\n    #[rustc_allow_incoherent_impl]\n    #[cfg(not(no_global_oom_handling))]\n    #[stable(feature = \"repeat_generic_slice\", since = \"1.40.0\")]\n    pub fn repeat(&self, n: usize) -> Vec<T>\n    where\n        T: Copy,\n    {\n        if n == 0 {\n            return Vec::new();\n        }\n\n        // If `n` is larger than zero, it can be split as\n        // `n = 2^expn + rem (2^expn > rem, expn >= 0, rem >= 0)`.\n        // `2^expn` is the number represented by the leftmost '1' bit of `n`,\n        // and `rem` is the remaining part of `n`.\n\n        // Using `Vec` to access `set_len()`.\n        let capacity = self.len().checked_mul(n).expect(\"capacity overflow\");\n        let mut buf = Vec::with_capacity(capacity);\n\n        // `2^expn` repetition is done by doubling `buf` `expn`-times.\n        buf.extend(self);\n        {\n            let mut m = n >> 1;\n            // If `m > 0`, there are remaining bits up to the leftmost '1'.\n            while m > 0 {\n                // `buf.extend(buf)`:\n                unsafe {\n                    ptr::copy_nonoverlapping(\n                        buf.as_ptr(),\n                        (buf.as_mut_ptr() as *mut T).add(buf.len()),\n                        buf.len(),\n                    );\n                    // `buf` has capacity of `self.len() * n`.\n                    let buf_len = buf.len();\n                    buf.set_len(buf_len * 2);\n                }\n\n                m >>= 1;\n            }\n        }\n\n        // `rem` (`= n - 2^expn`) repetition is done by copying\n        // first `rem` repetitions from `buf` itself.\n        let rem_len = capacity - buf.len(); // `self.len() * rem`\n        if rem_len > 0 {\n            // `buf.extend(buf[0 .. rem_len])`:\n            unsafe {\n                // This is non-overlapping since `2^expn > rem`.\n                ptr::copy_nonoverlapping(\n                    buf.as_ptr(),\n                    (buf.as_mut_ptr() as *mut T).add(buf.len()),\n                    rem_len,\n                );\n                // `buf.len() + rem_len` equals to `buf.capacity()` (`= self.len() * n`).\n                buf.set_len(capacity);\n            }\n        }\n        buf\n    }\n\n    /// Flattens a slice of `T` into a single value `Self::Output`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// assert_eq!([\"hello\", \"world\"].concat(), \"helloworld\");\n    /// assert_eq!([[1, 2], [3, 4]].concat(), [1, 2, 3, 4]);\n    /// ```\n    #[rustc_allow_incoherent_impl]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    pub fn concat<Item: ?Sized>(&self) -> <Self as Concat<Item>>::Output\n    where\n        Self: Concat<Item>,\n    {\n        Concat::concat(self)\n    }\n\n    /// Flattens a slice of `T` into a single value `Self::Output`, placing a\n    /// given separator between each.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// assert_eq!([\"hello\", \"world\"].join(\" \"), \"hello world\");\n    /// assert_eq!([[1, 2], [3, 4]].join(&0), [1, 2, 0, 3, 4]);\n    /// assert_eq!([[1, 2], [3, 4]].join(&[0, 0][..]), [1, 2, 0, 0, 3, 4]);\n    /// ```\n    #[rustc_allow_incoherent_impl]\n    #[stable(feature = \"rename_connect_to_join\", since = \"1.3.0\")]\n    pub fn join<Separator>(&self, sep: Separator) -> <Self as Join<Separator>>::Output\n    where\n        Self: Join<Separator>,\n    {\n        Join::join(self, sep)\n    }\n\n    /// Flattens a slice of `T` into a single value `Self::Output`, placing a\n    /// given separator between each.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #![allow(deprecated)]\n    /// assert_eq!([\"hello\", \"world\"].connect(\" \"), \"hello world\");\n    /// assert_eq!([[1, 2], [3, 4]].connect(&0), [1, 2, 0, 3, 4]);\n    /// ```\n    #[rustc_allow_incoherent_impl]\n    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n    #[deprecated(since = \"1.3.0\", note = \"renamed to join\")]\n    pub fn connect<Separator>(&self, sep: Separator) -> <Self as Join<Separator>>::Output\n    where\n        Self: Join<Separator>,\n    {\n        Join::join(self, sep)\n    }\n}\n\n#[cfg(not(test))]\nimpl [u8] {\n    /// Returns a vector containing a copy of this slice where each byte\n    /// is mapped to its ASCII upper case equivalent.\n    ///\n    /// ASCII letters 'a' to 'z' are mapped to 'A' to 'Z',\n    /// but non-ASCII letters are unchanged.\n    ///\n    /// To uppercase the value in-place, use [`make_ascii_uppercase`].\n    ///\n    /// [`make_ascii_uppercase`]: slice::make_ascii_uppercase\n    #[cfg(not(no_global_oom_handling))]\n    #[rustc_allow_incoherent_impl]\n    #[must_use = \"this returns the uppercase bytes as a new Vec, \\\n                  without modifying the original\"]\n    #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")]\n    #[inline]\n    pub fn to_ascii_uppercase(&self) -> Vec<u8> {\n        let mut me = self.to_vec();\n        me.make_ascii_uppercase();\n        me\n    }\n\n    /// Returns a vector containing a copy of this slice where each byte\n    /// is mapped to its ASCII lower case equivalent.\n    ///\n    /// ASCII letters 'A' to 'Z' are mapped to 'a' to 'z',\n    /// but non-ASCII letters are unchanged.\n    ///\n    /// To lowercase the value in-place, use [`make_ascii_lowercase`].\n    ///\n    /// [`make_ascii_lowercase`]: slice::make_ascii_lowercase\n    #[cfg(not(no_global_oom_handling))]\n    #[rustc_allow_incoherent_impl]\n    #[must_use = \"this returns the lowercase bytes as a new Vec, \\\n                  without modifying the original\"]\n    #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")]\n    #[inline]\n    pub fn to_ascii_lowercase(&self) -> Vec<u8> {\n        let mut me = self.to_vec();\n        me.make_ascii_lowercase();\n        me\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Extension traits for slices over specific kinds of data\n////////////////////////////////////////////////////////////////////////////////\n\n/// Helper trait for [`[T]::concat`](slice::concat).\n///\n/// Note: the `Item` type parameter is not used in this trait,\n/// but it allows impls to be more generic.\n/// Without it, we get this error:\n///\n/// ```error\n/// error[E0207]: the type parameter `T` is not constrained by the impl trait, self type, or predica\n///    --> library/alloc/src/slice.rs:608:6\n///     |\n/// 608 | impl<T: Clone, V: Borrow<[T]>> Concat for [V] {\n///     |      ^ unconstrained type parameter\n/// ```\n///\n/// This is because there could exist `V` types with multiple `Borrow<[_]>` impls,\n/// such that multiple `T` types would apply:\n///\n/// ```\n/// # #[allow(dead_code)]\n/// pub struct Foo(Vec<u32>, Vec<String>);\n///\n/// impl std::borrow::Borrow<[u32]> for Foo {\n///     fn borrow(&self) -> &[u32] { &self.0 }\n/// }\n///\n/// impl std::borrow::Borrow<[String]> for Foo {\n///     fn borrow(&self) -> &[String] { &self.1 }\n/// }\n/// ```\n#[unstable(feature = \"slice_concat_trait\", issue = \"27747\")]\npub trait Concat<Item: ?Sized> {\n    #[unstable(feature = \"slice_concat_trait\", issue = \"27747\")]\n    /// The resulting type after concatenation\n    type Output;\n\n    /// Implementation of [`[T]::concat`](slice::concat)\n    #[unstable(feature = \"slice_concat_trait\", issue = \"27747\")]\n    fn concat(slice: &Self) -> Self::Output;\n}\n\n/// Helper trait for [`[T]::join`](slice::join)\n#[unstable(feature = \"slice_concat_trait\", issue = \"27747\")]\npub trait Join<Separator> {\n    #[unstable(feature = \"slice_concat_trait\", issue = \"27747\")]\n    /// The resulting type after concatenation\n    type Output;\n\n    /// Implementation of [`[T]::join`](slice::join)\n    #[unstable(feature = \"slice_concat_trait\", issue = \"27747\")]\n    fn join(slice: &Self, sep: Separator) -> Self::Output;\n}\n\n#[cfg(not(no_global_oom_handling))]\n#[unstable(feature = \"slice_concat_ext\", issue = \"27747\")]\nimpl<T: Clone, V: Borrow<[T]>> Concat<T> for [V] {\n    type Output = Vec<T>;\n\n    fn concat(slice: &Self) -> Vec<T> {\n        let size = slice.iter().map(|slice| slice.borrow().len()).sum();\n        let mut result = Vec::with_capacity(size);\n        for v in slice {\n            result.extend_from_slice(v.borrow())\n        }\n        result\n    }\n}\n\n#[cfg(not(no_global_oom_handling))]\n#[unstable(feature = \"slice_concat_ext\", issue = \"27747\")]\nimpl<T: Clone, V: Borrow<[T]>> Join<&T> for [V] {\n    type Output = Vec<T>;\n\n    fn join(slice: &Self, sep: &T) -> Vec<T> {\n        let mut iter = slice.iter();\n        let first = match iter.next() {\n            Some(first) => first,\n            None => return vec![],\n        };\n        let size = slice.iter().map(|v| v.borrow().len()).sum::<usize>() + slice.len() - 1;\n        let mut result = Vec::with_capacity(size);\n        result.extend_from_slice(first.borrow());\n\n        for v in iter {\n            result.push(sep.clone());\n            result.extend_from_slice(v.borrow())\n        }\n        result\n    }\n}\n\n#[cfg(not(no_global_oom_handling))]\n#[unstable(feature = \"slice_concat_ext\", issue = \"27747\")]\nimpl<T: Clone, V: Borrow<[T]>> Join<&[T]> for [V] {\n    type Output = Vec<T>;\n\n    fn join(slice: &Self, sep: &[T]) -> Vec<T> {\n        let mut iter = slice.iter();\n        let first = match iter.next() {\n            Some(first) => first,\n            None => return vec![],\n        };\n        let size =\n            slice.iter().map(|v| v.borrow().len()).sum::<usize>() + sep.len() * (slice.len() - 1);\n        let mut result = Vec::with_capacity(size);\n        result.extend_from_slice(first.borrow());\n\n        for v in iter {\n            result.extend_from_slice(sep);\n            result.extend_from_slice(v.borrow())\n        }\n        result\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Standard trait implementations for slices\n////////////////////////////////////////////////////////////////////////////////\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T, A: Allocator> Borrow<[T]> for Vec<T, A> {\n    fn borrow(&self) -> &[T] {\n        &self[..]\n    }\n}\n\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T, A: Allocator> BorrowMut<[T]> for Vec<T, A> {\n    fn borrow_mut(&mut self) -> &mut [T] {\n        &mut self[..]\n    }\n}\n\n// Specializable trait for implementing ToOwned::clone_into. This is\n// public in the crate and has the Allocator parameter so that\n// vec::clone_from use it too.\n#[cfg(not(no_global_oom_handling))]\npub(crate) trait SpecCloneIntoVec<T, A: Allocator> {\n    fn clone_into(&self, target: &mut Vec<T, A>);\n}\n\n#[cfg(not(no_global_oom_handling))]\nimpl<T: Clone, A: Allocator> SpecCloneIntoVec<T, A> for [T] {\n    default fn clone_into(&self, target: &mut Vec<T, A>) {\n        // drop anything in target that will not be overwritten\n        target.truncate(self.len());\n\n        // target.len <= self.len due to the truncate above, so the\n        // slices here are always in-bounds.\n        let (init, tail) = self.split_at(target.len());\n\n        // reuse the contained values' allocations/resources.\n        target.clone_from_slice(init);\n        target.extend_from_slice(tail);\n    }\n}\n\n#[cfg(not(no_global_oom_handling))]\nimpl<T: Copy, A: Allocator> SpecCloneIntoVec<T, A> for [T] {\n    fn clone_into(&self, target: &mut Vec<T, A>) {\n        target.clear();\n        target.extend_from_slice(self);\n    }\n}\n\n#[cfg(not(no_global_oom_handling))]\n#[stable(feature = \"rust1\", since = \"1.0.0\")]\nimpl<T: Clone> ToOwned for [T] {\n    type Owned = Vec<T>;\n    #[cfg(not(test))]\n    fn to_owned(&self) -> Vec<T> {\n        self.to_vec()\n    }\n\n    #[cfg(test)]\n    fn to_owned(&self) -> Vec<T> {\n        hack::to_vec(self, Global)\n    }\n\n    fn clone_into(&self, target: &mut Vec<T>) {\n        SpecCloneIntoVec::clone_into(self, target);\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Sorting\n////////////////////////////////////////////////////////////////////////////////\n\n#[inline]\n#[cfg(not(no_global_oom_handling))]\nfn stable_sort<T, F>(v: &mut [T], mut is_less: F)\nwhere\n    F: FnMut(&T, &T) -> bool,\n{\n    if T::IS_ZST {\n        // Sorting has no meaningful behavior on zero-sized types. Do nothing.\n        return;\n    }\n\n    let elem_alloc_fn = |len: usize| -> *mut T {\n        // SAFETY: Creating the layout is safe as long as merge_sort never calls this with len >\n        // v.len(). Alloc in general will only be used as 'shadow-region' to store temporary swap\n        // elements.\n        unsafe { alloc::alloc(alloc::Layout::array::<T>(len).unwrap_unchecked()) as *mut T }\n    };\n\n    let elem_dealloc_fn = |buf_ptr: *mut T, len: usize| {\n        // SAFETY: Creating the layout is safe as long as merge_sort never calls this with len >\n        // v.len(). The caller must ensure that buf_ptr was created by elem_alloc_fn with the same\n        // len.\n        unsafe {\n            alloc::dealloc(buf_ptr as *mut u8, alloc::Layout::array::<T>(len).unwrap_unchecked());\n        }\n    };\n\n    let run_alloc_fn = |len: usize| -> *mut sort::TimSortRun {\n        // SAFETY: Creating the layout is safe as long as merge_sort never calls this with an\n        // obscene length or 0.\n        unsafe {\n            alloc::alloc(alloc::Layout::array::<sort::TimSortRun>(len).unwrap_unchecked())\n                as *mut sort::TimSortRun\n        }\n    };\n\n    let run_dealloc_fn = |buf_ptr: *mut sort::TimSortRun, len: usize| {\n        // SAFETY: The caller must ensure that buf_ptr was created by elem_alloc_fn with the same\n        // len.\n        unsafe {\n            alloc::dealloc(\n                buf_ptr as *mut u8,\n                alloc::Layout::array::<sort::TimSortRun>(len).unwrap_unchecked(),\n            );\n        }\n    };\n\n    sort::merge_sort(v, &mut is_less, elem_alloc_fn, elem_dealloc_fn, run_alloc_fn, run_dealloc_fn);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}