{
  "module_name": "Makefile",
  "hash_id": "0c8fcbae7bae6b9e4f60b99c7b6e1a61586b211d39470c7f449428f926180da4",
  "original_prompt": "Ingested from linux-6.6.14/rust/Makefile",
  "human_readable_source": "# SPDX-License-Identifier: GPL-2.0\n\n# Where to place rustdoc generated documentation\nrustdoc_output := $(objtree)/Documentation/output/rust/rustdoc\n\nobj-$(CONFIG_RUST) += core.o compiler_builtins.o\nalways-$(CONFIG_RUST) += exports_core_generated.h\n\n# Missing prototypes are expected in the helpers since these are exported\n# for Rust only, thus there is no header nor prototypes.\nobj-$(CONFIG_RUST) += helpers.o\nCFLAGS_REMOVE_helpers.o = -Wmissing-prototypes -Wmissing-declarations\n\nalways-$(CONFIG_RUST) += libmacros.so\nno-clean-files += libmacros.so\n\nalways-$(CONFIG_RUST) += bindings/bindings_generated.rs bindings/bindings_helpers_generated.rs\nobj-$(CONFIG_RUST) += alloc.o bindings.o kernel.o\nalways-$(CONFIG_RUST) += exports_alloc_generated.h exports_bindings_generated.h \\\n    exports_kernel_generated.h\n\nalways-$(CONFIG_RUST) += uapi/uapi_generated.rs\nobj-$(CONFIG_RUST) += uapi.o\n\nifdef CONFIG_RUST_BUILD_ASSERT_ALLOW\nobj-$(CONFIG_RUST) += build_error.o\nelse\nalways-$(CONFIG_RUST) += build_error.o\nendif\n\nobj-$(CONFIG_RUST) += exports.o\n\nalways-$(CONFIG_RUST_KERNEL_DOCTESTS) += doctests_kernel_generated.rs\nalways-$(CONFIG_RUST_KERNEL_DOCTESTS) += doctests_kernel_generated_kunit.c\n\nobj-$(CONFIG_RUST_KERNEL_DOCTESTS) += doctests_kernel_generated.o\nobj-$(CONFIG_RUST_KERNEL_DOCTESTS) += doctests_kernel_generated_kunit.o\n\n# Avoids running `$(RUSTC)` for the sysroot when it may not be available.\nifdef CONFIG_RUST\n\n# `$(rust_flags)` is passed in case the user added `--sysroot`.\nrustc_sysroot := $(shell $(RUSTC) $(rust_flags) --print sysroot)\nrustc_host_target := $(shell $(RUSTC) --version --verbose | grep -F 'host: ' | cut -d' ' -f2)\nRUST_LIB_SRC ?= $(rustc_sysroot)/lib/rustlib/src/rust/library\n\nifeq ($(quiet),silent_)\ncargo_quiet=-q\nrust_test_quiet=-q\nrustdoc_test_quiet=--test-args -q\nrustdoc_test_kernel_quiet=>/dev/null\nelse ifeq ($(quiet),quiet_)\nrust_test_quiet=-q\nrustdoc_test_quiet=--test-args -q\nrustdoc_test_kernel_quiet=>/dev/null\nelse\ncargo_quiet=--verbose\nendif\n\ncore-cfgs = \\\n    --cfg no_fp_fmt_parse\n\nalloc-cfgs = \\\n    --cfg no_borrow \\\n    --cfg no_fmt \\\n    --cfg no_global_oom_handling \\\n    --cfg no_macros \\\n    --cfg no_rc \\\n    --cfg no_str \\\n    --cfg no_string \\\n    --cfg no_sync \\\n    --cfg no_thin\n\nquiet_cmd_rustdoc = RUSTDOC $(if $(rustdoc_host),H, ) $<\n      cmd_rustdoc = \\\n\tOBJTREE=$(abspath $(objtree)) \\\n\t$(RUSTDOC) $(if $(rustdoc_host),$(rust_common_flags),$(rust_flags)) \\\n\t\t$(rustc_target_flags) -L$(objtree)/$(obj) \\\n\t\t--output $(rustdoc_output) \\\n\t\t--crate-name $(subst rustdoc-,,$@) \\\n\t\t@$(objtree)/include/generated/rustc_cfg $<\n\n# The `html_logo_url` and `html_favicon_url` forms of the `doc` attribute\n# can be used to specify a custom logo. However:\n#   - The given value is used as-is, thus it cannot be relative or a local file\n#     (unlike the non-custom case) since the generated docs have subfolders.\n#   - It requires adding it to every crate.\n#   - It requires changing `core` which comes from the sysroot.\n#\n# Using `-Zcrate-attr` would solve the last two points, but not the first.\n# The https://github.com/rust-lang/rfcs/pull/3226 RFC suggests two new\n# command-like flags to solve the issue. Meanwhile, we use the non-custom case\n# and then retouch the generated files.\nrustdoc: rustdoc-core rustdoc-macros rustdoc-compiler_builtins \\\n    rustdoc-alloc rustdoc-kernel\n\t$(Q)cp $(srctree)/Documentation/images/logo.svg $(rustdoc_output)/static.files/\n\t$(Q)cp $(srctree)/Documentation/images/COPYING-logo $(rustdoc_output)/static.files/\n\t$(Q)find $(rustdoc_output) -name '*.html' -type f -print0 | xargs -0 sed -Ei \\\n\t\t-e 's:rust-logo-[0-9a-f]+\\.svg:logo.svg:g' \\\n\t\t-e 's:favicon-[0-9a-f]+\\.svg:logo.svg:g' \\\n\t\t-e 's:<link rel=\"alternate icon\" type=\"image/png\" href=\"[/.]+/static\\.files/favicon-(16x16|32x32)-[0-9a-f]+\\.png\">::g'\n\t$(Q)for f in $(rustdoc_output)/static.files/rustdoc-*.css; do \\\n\t\techo \".logo-container > img { object-fit: contain; }\" >> $$f; done\n\nrustdoc-macros: private rustdoc_host = yes\nrustdoc-macros: private rustc_target_flags = --crate-type proc-macro \\\n    --extern proc_macro\nrustdoc-macros: $(src)/macros/lib.rs FORCE\n\t$(call if_changed,rustdoc)\n\nrustdoc-core: private rustc_target_flags = $(core-cfgs)\nrustdoc-core: $(RUST_LIB_SRC)/core/src/lib.rs FORCE\n\t$(call if_changed,rustdoc)\n\nrustdoc-compiler_builtins: $(src)/compiler_builtins.rs rustdoc-core FORCE\n\t$(call if_changed,rustdoc)\n\n# We need to allow `rustdoc::broken_intra_doc_links` because some\n# `no_global_oom_handling` functions refer to non-`no_global_oom_handling`\n# functions. Ideally `rustdoc` would have a way to distinguish broken links\n# due to things that are \"configured out\" vs. entirely non-existing ones.\nrustdoc-alloc: private rustc_target_flags = $(alloc-cfgs) \\\n    -Arustdoc::broken_intra_doc_links\nrustdoc-alloc: $(src)/alloc/lib.rs rustdoc-core rustdoc-compiler_builtins FORCE\n\t$(call if_changed,rustdoc)\n\nrustdoc-kernel: private rustc_target_flags = --extern alloc \\\n    --extern build_error --extern macros=$(objtree)/$(obj)/libmacros.so \\\n    --extern bindings --extern uapi\nrustdoc-kernel: $(src)/kernel/lib.rs rustdoc-core rustdoc-macros \\\n    rustdoc-compiler_builtins rustdoc-alloc $(obj)/libmacros.so \\\n    $(obj)/bindings.o FORCE\n\t$(call if_changed,rustdoc)\n\nquiet_cmd_rustc_test_library = RUSTC TL $<\n      cmd_rustc_test_library = \\\n\tOBJTREE=$(abspath $(objtree)) \\\n\t$(RUSTC) $(rust_common_flags) \\\n\t\t@$(objtree)/include/generated/rustc_cfg $(rustc_target_flags) \\\n\t\t--crate-type $(if $(rustc_test_library_proc),proc-macro,rlib) \\\n\t\t--out-dir $(objtree)/$(obj)/test --cfg testlib \\\n\t\t--sysroot $(objtree)/$(obj)/test/sysroot \\\n\t\t-L$(objtree)/$(obj)/test \\\n\t\t--crate-name $(subst rusttest-,,$(subst rusttestlib-,,$@)) $<\n\nrusttestlib-build_error: $(src)/build_error.rs rusttest-prepare FORCE\n\t$(call if_changed,rustc_test_library)\n\nrusttestlib-macros: private rustc_target_flags = --extern proc_macro\nrusttestlib-macros: private rustc_test_library_proc = yes\nrusttestlib-macros: $(src)/macros/lib.rs rusttest-prepare FORCE\n\t$(call if_changed,rustc_test_library)\n\nrusttestlib-bindings: $(src)/bindings/lib.rs rusttest-prepare FORCE\n\t$(call if_changed,rustc_test_library)\n\nrusttestlib-uapi: $(src)/uapi/lib.rs rusttest-prepare FORCE\n\t$(call if_changed,rustc_test_library)\n\nquiet_cmd_rustdoc_test = RUSTDOC T $<\n      cmd_rustdoc_test = \\\n\tOBJTREE=$(abspath $(objtree)) \\\n\t$(RUSTDOC) --test $(rust_common_flags) \\\n\t\t@$(objtree)/include/generated/rustc_cfg \\\n\t\t$(rustc_target_flags) $(rustdoc_test_target_flags) \\\n\t\t--sysroot $(objtree)/$(obj)/test/sysroot $(rustdoc_test_quiet) \\\n\t\t-L$(objtree)/$(obj)/test --output $(rustdoc_output) \\\n\t\t--crate-name $(subst rusttest-,,$@) $<\n\nquiet_cmd_rustdoc_test_kernel = RUSTDOC TK $<\n      cmd_rustdoc_test_kernel = \\\n\trm -rf $(objtree)/$(obj)/test/doctests/kernel; \\\n\tmkdir -p $(objtree)/$(obj)/test/doctests/kernel; \\\n\tOBJTREE=$(abspath $(objtree)) \\\n\t$(RUSTDOC) --test $(rust_flags) \\\n\t\t@$(objtree)/include/generated/rustc_cfg \\\n\t\t-L$(objtree)/$(obj) --extern alloc --extern kernel \\\n\t\t--extern build_error --extern macros \\\n\t\t--extern bindings --extern uapi \\\n\t\t--no-run --crate-name kernel -Zunstable-options \\\n\t\t--test-builder $(objtree)/scripts/rustdoc_test_builder \\\n\t\t$< $(rustdoc_test_kernel_quiet); \\\n\t$(objtree)/scripts/rustdoc_test_gen\n\n%/doctests_kernel_generated.rs %/doctests_kernel_generated_kunit.c: \\\n    $(src)/kernel/lib.rs $(obj)/kernel.o \\\n    $(objtree)/scripts/rustdoc_test_builder \\\n    $(objtree)/scripts/rustdoc_test_gen FORCE\n\t$(call if_changed,rustdoc_test_kernel)\n\n# We cannot use `-Zpanic-abort-tests` because some tests are dynamic,\n# so for the moment we skip `-Cpanic=abort`.\nquiet_cmd_rustc_test = RUSTC T  $<\n      cmd_rustc_test = \\\n\tOBJTREE=$(abspath $(objtree)) \\\n\t$(RUSTC) --test $(rust_common_flags) \\\n\t\t@$(objtree)/include/generated/rustc_cfg \\\n\t\t$(rustc_target_flags) --out-dir $(objtree)/$(obj)/test \\\n\t\t--sysroot $(objtree)/$(obj)/test/sysroot \\\n\t\t-L$(objtree)/$(obj)/test \\\n\t\t--crate-name $(subst rusttest-,,$@) $<; \\\n\t$(objtree)/$(obj)/test/$(subst rusttest-,,$@) $(rust_test_quiet) \\\n\t\t$(rustc_test_run_flags)\n\nrusttest: rusttest-macros rusttest-kernel\n\n# This prepares a custom sysroot with our custom `alloc` instead of\n# the standard one.\n#\n# This requires several hacks:\n#   - Unlike `core` and `alloc`, `std` depends on more than a dozen crates,\n#     including third-party crates that need to be downloaded, plus custom\n#     `build.rs` steps. Thus hardcoding things here is not maintainable.\n#   - `cargo` knows how to build the standard library, but it is an unstable\n#     feature so far (`-Zbuild-std`).\n#   - `cargo` only considers the use case of building the standard library\n#     to use it in a given package. Thus we need to create a dummy package\n#     and pick the generated libraries from there.\n#   - Since we only keep a subset of upstream `alloc` in-tree, we need\n#     to recreate it on the fly by putting our sources on top.\n#   - The usual ways of modifying the dependency graph in `cargo` do not seem\n#     to apply for the `-Zbuild-std` steps, thus we have to mislead it\n#     by modifying the sources in the sysroot.\n#   - To avoid messing with the user's Rust installation, we create a clone\n#     of the sysroot. However, `cargo` ignores `RUSTFLAGS` in the `-Zbuild-std`\n#     steps, thus we use a wrapper binary passed via `RUSTC` to pass the flag.\n#\n# In the future, we hope to avoid the whole ordeal by either:\n#   - Making the `test` crate not depend on `std` (either improving upstream\n#     or having our own custom crate).\n#   - Making the tests run in kernel space (requires the previous point).\n#   - Making `std` and friends be more like a \"normal\" crate, so that\n#     `-Zbuild-std` and related hacks are not needed.\nquiet_cmd_rustsysroot = RUSTSYSROOT\n      cmd_rustsysroot = \\\n\trm -rf $(objtree)/$(obj)/test; \\\n\tmkdir -p $(objtree)/$(obj)/test; \\\n\tcp -a $(rustc_sysroot) $(objtree)/$(obj)/test/sysroot; \\\n\tcp -r $(srctree)/$(src)/alloc/* \\\n\t\t$(objtree)/$(obj)/test/sysroot/lib/rustlib/src/rust/library/alloc/src; \\\n\techo '\\#!/bin/sh' > $(objtree)/$(obj)/test/rustc_sysroot; \\\n\techo \"$(RUSTC) --sysroot=$(abspath $(objtree)/$(obj)/test/sysroot) \\\"\\$$@\\\"\" \\\n\t\t>> $(objtree)/$(obj)/test/rustc_sysroot; \\\n\tchmod u+x $(objtree)/$(obj)/test/rustc_sysroot; \\\n\t$(CARGO) -q new $(objtree)/$(obj)/test/dummy; \\\n\tRUSTC=$(objtree)/$(obj)/test/rustc_sysroot $(CARGO) $(cargo_quiet) \\\n\t\ttest -Zbuild-std --target $(rustc_host_target) \\\n\t\t--manifest-path $(objtree)/$(obj)/test/dummy/Cargo.toml; \\\n\trm $(objtree)/$(obj)/test/sysroot/lib/rustlib/$(rustc_host_target)/lib/*; \\\n\tcp $(objtree)/$(obj)/test/dummy/target/$(rustc_host_target)/debug/deps/* \\\n\t\t$(objtree)/$(obj)/test/sysroot/lib/rustlib/$(rustc_host_target)/lib\n\nrusttest-prepare: FORCE\n\t$(call if_changed,rustsysroot)\n\nrusttest-macros: private rustc_target_flags = --extern proc_macro\nrusttest-macros: private rustdoc_test_target_flags = --crate-type proc-macro\nrusttest-macros: $(src)/macros/lib.rs rusttest-prepare FORCE\n\t$(call if_changed,rustc_test)\n\t$(call if_changed,rustdoc_test)\n\nrusttest-kernel: private rustc_target_flags = --extern alloc \\\n    --extern build_error --extern macros --extern bindings --extern uapi\nrusttest-kernel: $(src)/kernel/lib.rs rusttest-prepare \\\n    rusttestlib-build_error rusttestlib-macros rusttestlib-bindings \\\n    rusttestlib-uapi FORCE\n\t$(call if_changed,rustc_test)\n\t$(call if_changed,rustc_test_library)\n\nifdef CONFIG_CC_IS_CLANG\nbindgen_c_flags = $(c_flags)\nelse\n# bindgen relies on libclang to parse C. Ideally, bindgen would support a GCC\n# plugin backend and/or the Clang driver would be perfectly compatible with GCC.\n#\n# For the moment, here we are tweaking the flags on the fly. This is a hack,\n# and some kernel configurations may not work (e.g. `GCC_PLUGIN_RANDSTRUCT`\n# if we end up using one of those structs).\nbindgen_skip_c_flags := -mno-fp-ret-in-387 -mpreferred-stack-boundary=% \\\n\t-mskip-rax-setup -mgeneral-regs-only -msign-return-address=% \\\n\t-mindirect-branch=thunk-extern -mindirect-branch-register \\\n\t-mfunction-return=thunk-extern -mrecord-mcount -mabi=lp64 \\\n\t-mindirect-branch-cs-prefix -mstack-protector-guard% -mtraceback=no \\\n\t-mno-pointers-to-nested-functions -mno-string \\\n\t-mno-strict-align -mstrict-align \\\n\t-fconserve-stack -falign-jumps=% -falign-loops=% \\\n\t-femit-struct-debug-baseonly -fno-ipa-cp-clone -fno-ipa-sra \\\n\t-fno-partial-inlining -fplugin-arg-arm_ssp_per_task_plugin-% \\\n\t-fno-reorder-blocks -fno-allow-store-data-races -fasan-shadow-offset=% \\\n\t-fzero-call-used-regs=% -fno-stack-clash-protection \\\n\t-fno-inline-functions-called-once -fsanitize=bounds-strict \\\n\t-fstrict-flex-arrays=% \\\n\t--param=% --param asan-%\n\n# Derived from `scripts/Makefile.clang`.\nBINDGEN_TARGET_x86\t:= x86_64-linux-gnu\nBINDGEN_TARGET\t\t:= $(BINDGEN_TARGET_$(SRCARCH))\n\n# All warnings are inhibited since GCC builds are very experimental,\n# many GCC warnings are not supported by Clang, they may only appear in\n# some configurations, with new GCC versions, etc.\nbindgen_extra_c_flags = -w --target=$(BINDGEN_TARGET)\n\n# Auto variable zero-initialization requires an additional special option with\n# clang that is going to be removed sometime in the future (likely in\n# clang-18), so make sure to pass this option only if clang supports it\n# (libclang major version < 16).\n#\n# https://github.com/llvm/llvm-project/issues/44842\n# https://github.com/llvm/llvm-project/blob/llvmorg-16.0.0-rc2/clang/docs/ReleaseNotes.rst#deprecated-compiler-flags\nifdef CONFIG_INIT_STACK_ALL_ZERO\nlibclang_maj_ver=$(shell $(BINDGEN) $(srctree)/scripts/rust_is_available_bindgen_libclang.h 2>&1 | sed -ne 's/.*clang version \\([0-9]*\\).*/\\1/p')\nifeq ($(shell expr $(libclang_maj_ver) \\< 16), 1)\nbindgen_extra_c_flags += -enable-trivial-auto-var-init-zero-knowing-it-will-be-removed-from-clang\nendif\nendif\n\nbindgen_c_flags = $(filter-out $(bindgen_skip_c_flags), $(c_flags)) \\\n\t$(bindgen_extra_c_flags)\nendif\n\nifdef CONFIG_LTO\nbindgen_c_flags_lto = $(filter-out $(CC_FLAGS_LTO), $(bindgen_c_flags))\nelse\nbindgen_c_flags_lto = $(bindgen_c_flags)\nendif\n\nbindgen_c_flags_final = $(bindgen_c_flags_lto) -D__BINDGEN__\n\nquiet_cmd_bindgen = BINDGEN $@\n      cmd_bindgen = \\\n\t$(BINDGEN) $< $(bindgen_target_flags) \\\n\t\t--use-core --with-derive-default --ctypes-prefix core::ffi --no-layout-tests \\\n\t\t--no-debug '.*' \\\n\t\t-o $@ -- $(bindgen_c_flags_final) -DMODULE \\\n\t\t$(bindgen_target_cflags) $(bindgen_target_extra)\n\n$(obj)/bindings/bindings_generated.rs: private bindgen_target_flags = \\\n    $(shell grep -v '^#\\|^$$' $(srctree)/$(src)/bindgen_parameters)\n$(obj)/bindings/bindings_generated.rs: $(src)/bindings/bindings_helper.h \\\n    $(src)/bindgen_parameters FORCE\n\t$(call if_changed_dep,bindgen)\n\n$(obj)/uapi/uapi_generated.rs: private bindgen_target_flags = \\\n    $(shell grep -v '^#\\|^$$' $(srctree)/$(src)/bindgen_parameters)\n$(obj)/uapi/uapi_generated.rs: $(src)/uapi/uapi_helper.h \\\n    $(src)/bindgen_parameters FORCE\n\t$(call if_changed_dep,bindgen)\n\n# See `CFLAGS_REMOVE_helpers.o` above. In addition, Clang on C does not warn\n# with `-Wmissing-declarations` (unlike GCC), so it is not strictly needed here\n# given it is `libclang`; but for consistency, future Clang changes and/or\n# a potential future GCC backend for `bindgen`, we disable it too.\n$(obj)/bindings/bindings_helpers_generated.rs: private bindgen_target_flags = \\\n    --blocklist-type '.*' --allowlist-var '' \\\n    --allowlist-function 'rust_helper_.*'\n$(obj)/bindings/bindings_helpers_generated.rs: private bindgen_target_cflags = \\\n    -I$(objtree)/$(obj) -Wno-missing-prototypes -Wno-missing-declarations\n$(obj)/bindings/bindings_helpers_generated.rs: private bindgen_target_extra = ; \\\n    sed -Ei 's/pub fn rust_helper_([a-zA-Z0-9_]*)/#[link_name=\"rust_helper_\\1\"]\\n    pub fn \\1/g' $@\n$(obj)/bindings/bindings_helpers_generated.rs: $(src)/helpers.c FORCE\n\t$(call if_changed_dep,bindgen)\n\nquiet_cmd_exports = EXPORTS $@\n      cmd_exports = \\\n\t$(NM) -p --defined-only $< \\\n\t\t| grep -E ' (T|R|D) ' | cut -d ' ' -f 3 \\\n\t\t| xargs -Isymbol \\\n\t\techo 'EXPORT_SYMBOL_RUST_GPL(symbol);' > $@\n\n$(obj)/exports_core_generated.h: $(obj)/core.o FORCE\n\t$(call if_changed,exports)\n\n$(obj)/exports_alloc_generated.h: $(obj)/alloc.o FORCE\n\t$(call if_changed,exports)\n\n$(obj)/exports_bindings_generated.h: $(obj)/bindings.o FORCE\n\t$(call if_changed,exports)\n\n$(obj)/exports_kernel_generated.h: $(obj)/kernel.o FORCE\n\t$(call if_changed,exports)\n\nquiet_cmd_rustc_procmacro = $(RUSTC_OR_CLIPPY_QUIET) P $@\n      cmd_rustc_procmacro = \\\n\t$(RUSTC_OR_CLIPPY) $(rust_common_flags) \\\n\t\t--emit=dep-info=$(depfile) --emit=link=$@ --extern proc_macro \\\n\t\t--crate-type proc-macro \\\n\t\t--crate-name $(patsubst lib%.so,%,$(notdir $@)) $<\n\n# Procedural macros can only be used with the `rustc` that compiled it.\n# Therefore, to get `libmacros.so` automatically recompiled when the compiler\n# version changes, we add `core.o` as a dependency (even if it is not needed).\n$(obj)/libmacros.so: $(src)/macros/lib.rs $(obj)/core.o FORCE\n\t$(call if_changed_dep,rustc_procmacro)\n\nquiet_cmd_rustc_library = $(if $(skip_clippy),RUSTC,$(RUSTC_OR_CLIPPY_QUIET)) L $@\n      cmd_rustc_library = \\\n\tOBJTREE=$(abspath $(objtree)) \\\n\t$(if $(skip_clippy),$(RUSTC),$(RUSTC_OR_CLIPPY)) \\\n\t\t$(filter-out $(skip_flags),$(rust_flags) $(rustc_target_flags)) \\\n\t\t--emit=dep-info=$(depfile) --emit=obj=$@ \\\n\t\t--emit=metadata=$(dir $@)$(patsubst %.o,lib%.rmeta,$(notdir $@)) \\\n\t\t--crate-type rlib -L$(objtree)/$(obj) \\\n\t\t--crate-name $(patsubst %.o,%,$(notdir $@)) $< \\\n\t$(if $(rustc_objcopy),;$(OBJCOPY) $(rustc_objcopy) $@)\n\nrust-analyzer:\n\t$(Q)$(srctree)/scripts/generate_rust_analyzer.py \\\n\t\t--cfgs='core=$(core-cfgs)' --cfgs='alloc=$(alloc-cfgs)' \\\n\t\t$(abs_srctree) $(abs_objtree) \\\n\t\t$(RUST_LIB_SRC) $(KBUILD_EXTMOD) > \\\n\t\t$(if $(KBUILD_EXTMOD),$(extmod_prefix),$(objtree))/rust-project.json\n\nredirect-intrinsics = \\\n\t__addsf3 __eqsf2 __gesf2 __lesf2 __ltsf2 __mulsf3 __nesf2 __unordsf2 \\\n\t__adddf3 __ledf2 __ltdf2 __muldf3 __unorddf2 \\\n\t__muloti4 __multi3 \\\n\t__udivmodti4 __udivti3 __umodti3\n\nifneq ($(or $(CONFIG_ARM64),$(and $(CONFIG_RISCV),$(CONFIG_64BIT))),)\n\t# These intrinsics are defined for ARM64 and RISCV64\n\tredirect-intrinsics += \\\n\t\t__ashrti3 \\\n\t\t__ashlti3 __lshrti3\nendif\n\n$(obj)/core.o: private skip_clippy = 1\n$(obj)/core.o: private skip_flags = -Dunreachable_pub\n$(obj)/core.o: private rustc_objcopy = $(foreach sym,$(redirect-intrinsics),--redefine-sym $(sym)=__rust$(sym))\n$(obj)/core.o: private rustc_target_flags = $(core-cfgs)\n$(obj)/core.o: $(RUST_LIB_SRC)/core/src/lib.rs scripts/target.json FORCE\n\t$(call if_changed_dep,rustc_library)\n\n$(obj)/compiler_builtins.o: private rustc_objcopy = -w -W '__*'\n$(obj)/compiler_builtins.o: $(src)/compiler_builtins.rs $(obj)/core.o FORCE\n\t$(call if_changed_dep,rustc_library)\n\n$(obj)/alloc.o: private skip_clippy = 1\n$(obj)/alloc.o: private skip_flags = -Dunreachable_pub\n$(obj)/alloc.o: private rustc_target_flags = $(alloc-cfgs)\n$(obj)/alloc.o: $(src)/alloc/lib.rs $(obj)/compiler_builtins.o FORCE\n\t$(call if_changed_dep,rustc_library)\n\n$(obj)/build_error.o: $(src)/build_error.rs $(obj)/compiler_builtins.o FORCE\n\t$(call if_changed_dep,rustc_library)\n\n$(obj)/bindings.o: $(src)/bindings/lib.rs \\\n    $(obj)/compiler_builtins.o \\\n    $(obj)/bindings/bindings_generated.rs \\\n    $(obj)/bindings/bindings_helpers_generated.rs FORCE\n\t$(call if_changed_dep,rustc_library)\n\n$(obj)/uapi.o: $(src)/uapi/lib.rs \\\n    $(obj)/compiler_builtins.o \\\n    $(obj)/uapi/uapi_generated.rs FORCE\n\t$(call if_changed_dep,rustc_library)\n\n$(obj)/kernel.o: private rustc_target_flags = --extern alloc \\\n    --extern build_error --extern macros --extern bindings --extern uapi\n$(obj)/kernel.o: $(src)/kernel/lib.rs $(obj)/alloc.o $(obj)/build_error.o \\\n    $(obj)/libmacros.so $(obj)/bindings.o $(obj)/uapi.o FORCE\n\t$(call if_changed_dep,rustc_library)\n\nendif # CONFIG_RUST\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}