{
  "module_name": "lib.rs",
  "hash_id": "33e7584d0c8fad1671ae7228490e2ad5730995f3c07bf18f84da307252ec6b03",
  "original_prompt": "Ingested from linux-6.6.14/rust/kernel/lib.rs",
  "human_readable_source": "// SPDX-License-Identifier: GPL-2.0\n\n//! The `kernel` crate.\n//!\n//! This crate contains the kernel APIs that have been ported or wrapped for\n//! usage by Rust code in the kernel and is shared by all of them.\n//!\n//! In other words, all the rest of the Rust code in the kernel (e.g. kernel\n//! modules written in Rust) depends on [`core`], [`alloc`] and this crate.\n//!\n//! If you need a kernel C API that is not ported or wrapped yet here, then\n//! do so first instead of bypassing this crate.\n\n#![no_std]\n#![feature(allocator_api)]\n#![feature(coerce_unsized)]\n#![feature(dispatch_from_dyn)]\n#![feature(new_uninit)]\n#![feature(receiver_trait)]\n#![feature(unsize)]\n\n// Ensure conditional compilation based on the kernel configuration works;\n// otherwise we may silently break things like initcall handling.\n#[cfg(not(CONFIG_RUST))]\ncompile_error!(\"Missing kernel configuration for conditional compilation\");\n\n// Allow proc-macros to refer to `::kernel` inside the `kernel` crate (this crate).\nextern crate self as kernel;\n\n#[cfg(not(test))]\n#[cfg(not(testlib))]\nmod allocator;\nmod build_assert;\npub mod error;\npub mod init;\npub mod ioctl;\n#[cfg(CONFIG_KUNIT)]\npub mod kunit;\npub mod prelude;\npub mod print;\nmod static_assert;\n#[doc(hidden)]\npub mod std_vendor;\npub mod str;\npub mod sync;\npub mod task;\npub mod types;\n\n#[doc(hidden)]\npub use bindings;\npub use macros;\npub use uapi;\n\n#[doc(hidden)]\npub use build_error::build_error;\n\n/// Prefix to appear before log messages printed from within the `kernel` crate.\nconst __LOG_PREFIX: &[u8] = b\"rust_kernel\\0\";\n\n/// The top level entrypoint to implementing a kernel module.\n///\n/// For any teardown or cleanup operations, your type may implement [`Drop`].\npub trait Module: Sized + Sync {\n    /// Called at module initialization time.\n    ///\n    /// Use this method to perform whatever setup or registration your module\n    /// should do.\n    ///\n    /// Equivalent to the `module_init` macro in the C API.\n    fn init(module: &'static ThisModule) -> error::Result<Self>;\n}\n\n/// Equivalent to `THIS_MODULE` in the C API.\n///\n/// C header: `include/linux/export.h`\npub struct ThisModule(*mut bindings::module);\n\n// SAFETY: `THIS_MODULE` may be used from all threads within a module.\nunsafe impl Sync for ThisModule {}\n\nimpl ThisModule {\n    /// Creates a [`ThisModule`] given the `THIS_MODULE` pointer.\n    ///\n    /// # Safety\n    ///\n    /// The pointer must be equal to the right `THIS_MODULE`.\n    pub const unsafe fn from_ptr(ptr: *mut bindings::module) -> ThisModule {\n        ThisModule(ptr)\n    }\n}\n\n#[cfg(not(any(testlib, test)))]\n#[panic_handler]\nfn panic(info: &core::panic::PanicInfo<'_>) -> ! {\n    pr_emerg!(\"{}\\n\", info);\n    // SAFETY: FFI call.\n    unsafe { bindings::BUG() };\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}