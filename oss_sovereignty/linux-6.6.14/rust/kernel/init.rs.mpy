{
  "module_name": "init.rs",
  "hash_id": "ef1fa3c0bb6b7a12c2dd7e8a5e752e5c1d2d2c81cee4854e49fdad77c619c64c",
  "original_prompt": "Ingested from linux-6.6.14/rust/kernel/init.rs",
  "human_readable_source": "// SPDX-License-Identifier: Apache-2.0 OR MIT\n\n//! API to safely and fallibly initialize pinned `struct`s using in-place constructors.\n//!\n//! It also allows in-place initialization of big `struct`s that would otherwise produce a stack\n//! overflow.\n//!\n//! Most `struct`s from the [`sync`] module need to be pinned, because they contain self-referential\n//! `struct`s from C. [Pinning][pinning] is Rust's way of ensuring data does not move.\n//!\n//! # Overview\n//!\n//! To initialize a `struct` with an in-place constructor you will need two things:\n//! - an in-place constructor,\n//! - a memory location that can hold your `struct` (this can be the [stack], an [`Arc<T>`],\n//!   [`UniqueArc<T>`], [`Box<T>`] or any other smart pointer that implements [`InPlaceInit`]).\n//!\n//! To get an in-place constructor there are generally three options:\n//! - directly creating an in-place constructor using the [`pin_init!`] macro,\n//! - a custom function/macro returning an in-place constructor provided by someone else,\n//! - using the unsafe function [`pin_init_from_closure()`] to manually create an initializer.\n//!\n//! Aside from pinned initialization, this API also supports in-place construction without pinning,\n//! the macros/types/functions are generally named like the pinned variants without the `pin`\n//! prefix.\n//!\n//! # Examples\n//!\n//! ## Using the [`pin_init!`] macro\n//!\n//! If you want to use [`PinInit`], then you will have to annotate your `struct` with\n//! `#[`[`pin_data`]`]`. It is a macro that uses `#[pin]` as a marker for\n//! [structurally pinned fields]. After doing this, you can then create an in-place constructor via\n//! [`pin_init!`]. The syntax is almost the same as normal `struct` initializers. The difference is\n//! that you need to write `<-` instead of `:` for fields that you want to initialize in-place.\n//!\n//! ```rust\n//! # #![allow(clippy::disallowed_names, clippy::new_ret_no_self)]\n//! use kernel::{prelude::*, sync::Mutex, new_mutex};\n//! # use core::pin::Pin;\n//! #[pin_data]\n//! struct Foo {\n//!     #[pin]\n//!     a: Mutex<usize>,\n//!     b: u32,\n//! }\n//!\n//! let foo = pin_init!(Foo {\n//!     a <- new_mutex!(42, \"Foo::a\"),\n//!     b: 24,\n//! });\n//! ```\n//!\n//! `foo` now is of the type [`impl PinInit<Foo>`]. We can now use any smart pointer that we like\n//! (or just the stack) to actually initialize a `Foo`:\n//!\n//! ```rust\n//! # #![allow(clippy::disallowed_names, clippy::new_ret_no_self)]\n//! # use kernel::{prelude::*, sync::Mutex, new_mutex};\n//! # use core::pin::Pin;\n//! # #[pin_data]\n//! # struct Foo {\n//! #     #[pin]\n//! #     a: Mutex<usize>,\n//! #     b: u32,\n//! # }\n//! # let foo = pin_init!(Foo {\n//! #     a <- new_mutex!(42, \"Foo::a\"),\n//! #     b: 24,\n//! # });\n//! let foo: Result<Pin<Box<Foo>>> = Box::pin_init(foo);\n//! ```\n//!\n//! For more information see the [`pin_init!`] macro.\n//!\n//! ## Using a custom function/macro that returns an initializer\n//!\n//! Many types from the kernel supply a function/macro that returns an initializer, because the\n//! above method only works for types where you can access the fields.\n//!\n//! ```rust\n//! # use kernel::{new_mutex, sync::{Arc, Mutex}};\n//! let mtx: Result<Arc<Mutex<usize>>> = Arc::pin_init(new_mutex!(42, \"example::mtx\"));\n//! ```\n//!\n//! To declare an init macro/function you just return an [`impl PinInit<T, E>`]:\n//!\n//! ```rust\n//! # #![allow(clippy::disallowed_names, clippy::new_ret_no_self)]\n//! # use kernel::{sync::Mutex, prelude::*, new_mutex, init::PinInit, try_pin_init};\n//! #[pin_data]\n//! struct DriverData {\n//!     #[pin]\n//!     status: Mutex<i32>,\n//!     buffer: Box<[u8; 1_000_000]>,\n//! }\n//!\n//! impl DriverData {\n//!     fn new() -> impl PinInit<Self, Error> {\n//!         try_pin_init!(Self {\n//!             status <- new_mutex!(0, \"DriverData::status\"),\n//!             buffer: Box::init(kernel::init::zeroed())?,\n//!         })\n//!     }\n//! }\n//! ```\n//!\n//! ## Manual creation of an initializer\n//!\n//! Often when working with primitives the previous approaches are not sufficient. That is where\n//! [`pin_init_from_closure()`] comes in. This `unsafe` function allows you to create a\n//! [`impl PinInit<T, E>`] directly from a closure. Of course you have to ensure that the closure\n//! actually does the initialization in the correct way. Here are the things to look out for\n//! (we are calling the parameter to the closure `slot`):\n//! - when the closure returns `Ok(())`, then it has completed the initialization successfully, so\n//!   `slot` now contains a valid bit pattern for the type `T`,\n//! - when the closure returns `Err(e)`, then the caller may deallocate the memory at `slot`, so\n//!   you need to take care to clean up anything if your initialization fails mid-way,\n//! - you may assume that `slot` will stay pinned even after the closure returns until `drop` of\n//!   `slot` gets called.\n//!\n//! ```rust\n//! # #![allow(unreachable_pub, clippy::disallowed_names)]\n//! use kernel::{prelude::*, init, types::Opaque};\n//! use core::{ptr::addr_of_mut, marker::PhantomPinned, pin::Pin};\n//! # mod bindings {\n//! #     #![allow(non_camel_case_types)]\n//! #     pub struct foo;\n//! #     pub unsafe fn init_foo(_ptr: *mut foo) {}\n//! #     pub unsafe fn destroy_foo(_ptr: *mut foo) {}\n//! #     pub unsafe fn enable_foo(_ptr: *mut foo, _flags: u32) -> i32 { 0 }\n//! # }\n//! # // `Error::from_errno` is `pub(crate)` in the `kernel` crate, thus provide a workaround.\n//! # trait FromErrno {\n//! #     fn from_errno(errno: core::ffi::c_int) -> Error {\n//! #         // Dummy error that can be constructed outside the `kernel` crate.\n//! #         Error::from(core::fmt::Error)\n//! #     }\n//! # }\n//! # impl FromErrno for Error {}\n//! /// # Invariants\n//! ///\n//! /// `foo` is always initialized\n//! #[pin_data(PinnedDrop)]\n//! pub struct RawFoo {\n//!     #[pin]\n//!     foo: Opaque<bindings::foo>,\n//!     #[pin]\n//!     _p: PhantomPinned,\n//! }\n//!\n//! impl RawFoo {\n//!     pub fn new(flags: u32) -> impl PinInit<Self, Error> {\n//!         // SAFETY:\n//!         // - when the closure returns `Ok(())`, then it has successfully initialized and\n//!         //   enabled `foo`,\n//!         // - when it returns `Err(e)`, then it has cleaned up before\n//!         unsafe {\n//!             init::pin_init_from_closure(move |slot: *mut Self| {\n//!                 // `slot` contains uninit memory, avoid creating a reference.\n//!                 let foo = addr_of_mut!((*slot).foo);\n//!\n//!                 // Initialize the `foo`\n//!                 bindings::init_foo(Opaque::raw_get(foo));\n//!\n//!                 // Try to enable it.\n//!                 let err = bindings::enable_foo(Opaque::raw_get(foo), flags);\n//!                 if err != 0 {\n//!                     // Enabling has failed, first clean up the foo and then return the error.\n//!                     bindings::destroy_foo(Opaque::raw_get(foo));\n//!                     return Err(Error::from_errno(err));\n//!                 }\n//!\n//!                 // All fields of `RawFoo` have been initialized, since `_p` is a ZST.\n//!                 Ok(())\n//!             })\n//!         }\n//!     }\n//! }\n//!\n//! #[pinned_drop]\n//! impl PinnedDrop for RawFoo {\n//!     fn drop(self: Pin<&mut Self>) {\n//!         // SAFETY: Since `foo` is initialized, destroying is safe.\n//!         unsafe { bindings::destroy_foo(self.foo.get()) };\n//!     }\n//! }\n//! ```\n//!\n//! For the special case where initializing a field is a single FFI-function call that cannot fail,\n//! there exist the helper function [`Opaque::ffi_init`]. This function initialize a single\n//! [`Opaque`] field by just delegating to the supplied closure. You can use these in combination\n//! with [`pin_init!`].\n//!\n//! For more information on how to use [`pin_init_from_closure()`], take a look at the uses inside\n//! the `kernel` crate. The [`sync`] module is a good starting point.\n//!\n//! [`sync`]: kernel::sync\n//! [pinning]: https://doc.rust-lang.org/std/pin/index.html\n//! [structurally pinned fields]:\n//!     https://doc.rust-lang.org/std/pin/index.html#pinning-is-structural-for-field\n//! [stack]: crate::stack_pin_init\n//! [`Arc<T>`]: crate::sync::Arc\n//! [`impl PinInit<Foo>`]: PinInit\n//! [`impl PinInit<T, E>`]: PinInit\n//! [`impl Init<T, E>`]: Init\n//! [`Opaque`]: kernel::types::Opaque\n//! [`Opaque::ffi_init`]: kernel::types::Opaque::ffi_init\n//! [`pin_data`]: ::macros::pin_data\n//! [`pin_init!`]: crate::pin_init!\n\nuse crate::{\n    error::{self, Error},\n    sync::UniqueArc,\n    types::{Opaque, ScopeGuard},\n};\nuse alloc::boxed::Box;\nuse core::{\n    alloc::AllocError,\n    cell::UnsafeCell,\n    convert::Infallible,\n    marker::PhantomData,\n    mem::MaybeUninit,\n    num::*,\n    pin::Pin,\n    ptr::{self, NonNull},\n};\n\n#[doc(hidden)]\npub mod __internal;\n#[doc(hidden)]\npub mod macros;\n\n/// Initialize and pin a type directly on the stack.\n///\n/// # Examples\n///\n/// ```rust\n/// # #![allow(clippy::disallowed_names, clippy::new_ret_no_self)]\n/// # use kernel::{init, macros::pin_data, pin_init, stack_pin_init, init::*, sync::Mutex, new_mutex};\n/// # use core::pin::Pin;\n/// #[pin_data]\n/// struct Foo {\n///     #[pin]\n///     a: Mutex<usize>,\n///     b: Bar,\n/// }\n///\n/// #[pin_data]\n/// struct Bar {\n///     x: u32,\n/// }\n///\n/// stack_pin_init!(let foo = pin_init!(Foo {\n///     a <- new_mutex!(42),\n///     b: Bar {\n///         x: 64,\n///     },\n/// }));\n/// let foo: Pin<&mut Foo> = foo;\n/// pr_info!(\"a: {}\", &*foo.a.lock());\n/// ```\n///\n/// # Syntax\n///\n/// A normal `let` binding with optional type annotation. The expression is expected to implement\n/// [`PinInit`]/[`Init`] with the error type [`Infallible`]. If you want to use a different error\n/// type, then use [`stack_try_pin_init!`].\n///\n/// [`stack_try_pin_init!`]: crate::stack_try_pin_init!\n#[macro_export]\nmacro_rules! stack_pin_init {\n    (let $var:ident $(: $t:ty)? = $val:expr) => {\n        let val = $val;\n        let mut $var = ::core::pin::pin!($crate::init::__internal::StackInit$(::<$t>)?::uninit());\n        let mut $var = match $crate::init::__internal::StackInit::init($var, val) {\n            Ok(res) => res,\n            Err(x) => {\n                let x: ::core::convert::Infallible = x;\n                match x {}\n            }\n        };\n    };\n}\n\n/// Initialize and pin a type directly on the stack.\n///\n/// # Examples\n///\n/// ```rust,ignore\n/// # #![allow(clippy::disallowed_names, clippy::new_ret_no_self)]\n/// # use kernel::{init, pin_init, stack_try_pin_init, init::*, sync::Mutex, new_mutex};\n/// # use macros::pin_data;\n/// # use core::{alloc::AllocError, pin::Pin};\n/// #[pin_data]\n/// struct Foo {\n///     #[pin]\n///     a: Mutex<usize>,\n///     b: Box<Bar>,\n/// }\n///\n/// struct Bar {\n///     x: u32,\n/// }\n///\n/// stack_try_pin_init!(let foo: Result<Pin<&mut Foo>, AllocError> = pin_init!(Foo {\n///     a <- new_mutex!(42),\n///     b: Box::try_new(Bar {\n///         x: 64,\n///     })?,\n/// }));\n/// let foo = foo.unwrap();\n/// pr_info!(\"a: {}\", &*foo.a.lock());\n/// ```\n///\n/// ```rust,ignore\n/// # #![allow(clippy::disallowed_names, clippy::new_ret_no_self)]\n/// # use kernel::{init, pin_init, stack_try_pin_init, init::*, sync::Mutex, new_mutex};\n/// # use macros::pin_data;\n/// # use core::{alloc::AllocError, pin::Pin};\n/// #[pin_data]\n/// struct Foo {\n///     #[pin]\n///     a: Mutex<usize>,\n///     b: Box<Bar>,\n/// }\n///\n/// struct Bar {\n///     x: u32,\n/// }\n///\n/// stack_try_pin_init!(let foo: Pin<&mut Foo> =? pin_init!(Foo {\n///     a <- new_mutex!(42),\n///     b: Box::try_new(Bar {\n///         x: 64,\n///     })?,\n/// }));\n/// pr_info!(\"a: {}\", &*foo.a.lock());\n/// # Ok::<_, AllocError>(())\n/// ```\n///\n/// # Syntax\n///\n/// A normal `let` binding with optional type annotation. The expression is expected to implement\n/// [`PinInit`]/[`Init`]. This macro assigns a result to the given variable, adding a `?` after the\n/// `=` will propagate this error.\n#[macro_export]\nmacro_rules! stack_try_pin_init {\n    (let $var:ident $(: $t:ty)? = $val:expr) => {\n        let val = $val;\n        let mut $var = ::core::pin::pin!($crate::init::__internal::StackInit$(::<$t>)?::uninit());\n        let mut $var = $crate::init::__internal::StackInit::init($var, val);\n    };\n    (let $var:ident $(: $t:ty)? =? $val:expr) => {\n        let val = $val;\n        let mut $var = ::core::pin::pin!($crate::init::__internal::StackInit$(::<$t>)?::uninit());\n        let mut $var = $crate::init::__internal::StackInit::init($var, val)?;\n    };\n}\n\n/// Construct an in-place, pinned initializer for `struct`s.\n///\n/// This macro defaults the error to [`Infallible`]. If you need [`Error`], then use\n/// [`try_pin_init!`].\n///\n/// The syntax is almost identical to that of a normal `struct` initializer:\n///\n/// ```rust\n/// # #![allow(clippy::disallowed_names, clippy::new_ret_no_self)]\n/// # use kernel::{init, pin_init, macros::pin_data, init::*};\n/// # use core::pin::Pin;\n/// #[pin_data]\n/// struct Foo {\n///     a: usize,\n///     b: Bar,\n/// }\n///\n/// #[pin_data]\n/// struct Bar {\n///     x: u32,\n/// }\n///\n/// # fn demo() -> impl PinInit<Foo> {\n/// let a = 42;\n///\n/// let initializer = pin_init!(Foo {\n///     a,\n///     b: Bar {\n///         x: 64,\n///     },\n/// });\n/// # initializer }\n/// # Box::pin_init(demo()).unwrap();\n/// ```\n///\n/// Arbitrary Rust expressions can be used to set the value of a variable.\n///\n/// The fields are initialized in the order that they appear in the initializer. So it is possible\n/// to read already initialized fields using raw pointers.\n///\n/// IMPORTANT: You are not allowed to create references to fields of the struct inside of the\n/// initializer.\n///\n/// # Init-functions\n///\n/// When working with this API it is often desired to let others construct your types without\n/// giving access to all fields. This is where you would normally write a plain function `new`\n/// that would return a new instance of your type. With this API that is also possible.\n/// However, there are a few extra things to keep in mind.\n///\n/// To create an initializer function, simply declare it like this:\n///\n/// ```rust\n/// # #![allow(clippy::disallowed_names, clippy::new_ret_no_self)]\n/// # use kernel::{init, pin_init, prelude::*, init::*};\n/// # use core::pin::Pin;\n/// # #[pin_data]\n/// # struct Foo {\n/// #     a: usize,\n/// #     b: Bar,\n/// # }\n/// # #[pin_data]\n/// # struct Bar {\n/// #     x: u32,\n/// # }\n/// impl Foo {\n///     fn new() -> impl PinInit<Self> {\n///         pin_init!(Self {\n///             a: 42,\n///             b: Bar {\n///                 x: 64,\n///             },\n///         })\n///     }\n/// }\n/// ```\n///\n/// Users of `Foo` can now create it like this:\n///\n/// ```rust\n/// # #![allow(clippy::disallowed_names, clippy::new_ret_no_self)]\n/// # use kernel::{init, pin_init, macros::pin_data, init::*};\n/// # use core::pin::Pin;\n/// # #[pin_data]\n/// # struct Foo {\n/// #     a: usize,\n/// #     b: Bar,\n/// # }\n/// # #[pin_data]\n/// # struct Bar {\n/// #     x: u32,\n/// # }\n/// # impl Foo {\n/// #     fn new() -> impl PinInit<Self> {\n/// #         pin_init!(Self {\n/// #             a: 42,\n/// #             b: Bar {\n/// #                 x: 64,\n/// #             },\n/// #         })\n/// #     }\n/// # }\n/// let foo = Box::pin_init(Foo::new());\n/// ```\n///\n/// They can also easily embed it into their own `struct`s:\n///\n/// ```rust\n/// # #![allow(clippy::disallowed_names, clippy::new_ret_no_self)]\n/// # use kernel::{init, pin_init, macros::pin_data, init::*};\n/// # use core::pin::Pin;\n/// # #[pin_data]\n/// # struct Foo {\n/// #     a: usize,\n/// #     b: Bar,\n/// # }\n/// # #[pin_data]\n/// # struct Bar {\n/// #     x: u32,\n/// # }\n/// # impl Foo {\n/// #     fn new() -> impl PinInit<Self> {\n/// #         pin_init!(Self {\n/// #             a: 42,\n/// #             b: Bar {\n/// #                 x: 64,\n/// #             },\n/// #         })\n/// #     }\n/// # }\n/// #[pin_data]\n/// struct FooContainer {\n///     #[pin]\n///     foo1: Foo,\n///     #[pin]\n///     foo2: Foo,\n///     other: u32,\n/// }\n///\n/// impl FooContainer {\n///     fn new(other: u32) -> impl PinInit<Self> {\n///         pin_init!(Self {\n///             foo1 <- Foo::new(),\n///             foo2 <- Foo::new(),\n///             other,\n///         })\n///     }\n/// }\n/// ```\n///\n/// Here we see that when using `pin_init!` with `PinInit`, one needs to write `<-` instead of `:`.\n/// This signifies that the given field is initialized in-place. As with `struct` initializers, just\n/// writing the field (in this case `other`) without `:` or `<-` means `other: other,`.\n///\n/// # Syntax\n///\n/// As already mentioned in the examples above, inside of `pin_init!` a `struct` initializer with\n/// the following modifications is expected:\n/// - Fields that you want to initialize in-place have to use `<-` instead of `:`.\n/// - In front of the initializer you can write `&this in` to have access to a [`NonNull<Self>`]\n///   pointer named `this` inside of the initializer.\n/// - Using struct update syntax one can place `..Zeroable::zeroed()` at the very end of the\n///   struct, this initializes every field with 0 and then runs all initializers specified in the\n///   body. This can only be done if [`Zeroable`] is implemented for the struct.\n///\n/// For instance:\n///\n/// ```rust\n/// # use kernel::{macros::{Zeroable, pin_data}, pin_init};\n/// # use core::{ptr::addr_of_mut, marker::PhantomPinned};\n/// #[pin_data]\n/// #[derive(Zeroable)]\n/// struct Buf {\n///     // `ptr` points into `buf`.\n///     ptr: *mut u8,\n///     buf: [u8; 64],\n///     #[pin]\n///     pin: PhantomPinned,\n/// }\n/// pin_init!(&this in Buf {\n///     buf: [0; 64],\n///     ptr: unsafe { addr_of_mut!((*this.as_ptr()).buf).cast() },\n///     pin: PhantomPinned,\n/// });\n/// pin_init!(Buf {\n///     buf: [1; 64],\n///     ..Zeroable::zeroed()\n/// });\n/// ```\n///\n/// [`try_pin_init!`]: kernel::try_pin_init\n/// [`NonNull<Self>`]: core::ptr::NonNull\n// For a detailed example of how this macro works, see the module documentation of the hidden\n// module `__internal` inside of `init/__internal.rs`.\n#[macro_export]\nmacro_rules! pin_init {\n    ($(&$this:ident in)? $t:ident $(::<$($generics:ty),* $(,)?>)? {\n        $($fields:tt)*\n    }) => {\n        $crate::__init_internal!(\n            @this($($this)?),\n            @typ($t $(::<$($generics),*>)?),\n            @fields($($fields)*),\n            @error(::core::convert::Infallible),\n            @data(PinData, use_data),\n            @has_data(HasPinData, __pin_data),\n            @construct_closure(pin_init_from_closure),\n            @munch_fields($($fields)*),\n        )\n    };\n}\n\n/// Construct an in-place, fallible pinned initializer for `struct`s.\n///\n/// If the initialization can complete without error (or [`Infallible`]), then use [`pin_init!`].\n///\n/// You can use the `?` operator or use `return Err(err)` inside the initializer to stop\n/// initialization and return the error.\n///\n/// IMPORTANT: if you have `unsafe` code inside of the initializer you have to ensure that when\n/// initialization fails, the memory can be safely deallocated without any further modifications.\n///\n/// This macro defaults the error to [`Error`].\n///\n/// The syntax is identical to [`pin_init!`] with the following exception: you can append `? $type`\n/// after the `struct` initializer to specify the error type you want to use.\n///\n/// # Examples\n///\n/// ```rust\n/// # #![feature(new_uninit)]\n/// use kernel::{init::{self, PinInit}, error::Error};\n/// #[pin_data]\n/// struct BigBuf {\n///     big: Box<[u8; 1024 * 1024 * 1024]>,\n///     small: [u8; 1024 * 1024],\n///     ptr: *mut u8,\n/// }\n///\n/// impl BigBuf {\n///     fn new() -> impl PinInit<Self, Error> {\n///         try_pin_init!(Self {\n///             big: Box::init(init::zeroed())?,\n///             small: [0; 1024 * 1024],\n///             ptr: core::ptr::null_mut(),\n///         }? Error)\n///     }\n/// }\n/// ```\n// For a detailed example of how this macro works, see the module documentation of the hidden\n// module `__internal` inside of `init/__internal.rs`.\n#[macro_export]\nmacro_rules! try_pin_init {\n    ($(&$this:ident in)? $t:ident $(::<$($generics:ty),* $(,)?>)? {\n        $($fields:tt)*\n    }) => {\n        $crate::__init_internal!(\n            @this($($this)?),\n            @typ($t $(::<$($generics),*>)? ),\n            @fields($($fields)*),\n            @error($crate::error::Error),\n            @data(PinData, use_data),\n            @has_data(HasPinData, __pin_data),\n            @construct_closure(pin_init_from_closure),\n            @munch_fields($($fields)*),\n        )\n    };\n    ($(&$this:ident in)? $t:ident $(::<$($generics:ty),* $(,)?>)? {\n        $($fields:tt)*\n    }? $err:ty) => {\n        $crate::__init_internal!(\n            @this($($this)?),\n            @typ($t $(::<$($generics),*>)? ),\n            @fields($($fields)*),\n            @error($err),\n            @data(PinData, use_data),\n            @has_data(HasPinData, __pin_data),\n            @construct_closure(pin_init_from_closure),\n            @munch_fields($($fields)*),\n        )\n    };\n}\n\n/// Construct an in-place initializer for `struct`s.\n///\n/// This macro defaults the error to [`Infallible`]. If you need [`Error`], then use\n/// [`try_init!`].\n///\n/// The syntax is identical to [`pin_init!`] and its safety caveats also apply:\n/// - `unsafe` code must guarantee either full initialization or return an error and allow\n///   deallocation of the memory.\n/// - the fields are initialized in the order given in the initializer.\n/// - no references to fields are allowed to be created inside of the initializer.\n///\n/// This initializer is for initializing data in-place that might later be moved. If you want to\n/// pin-initialize, use [`pin_init!`].\n///\n/// [`try_init!`]: crate::try_init!\n// For a detailed example of how this macro works, see the module documentation of the hidden\n// module `__internal` inside of `init/__internal.rs`.\n#[macro_export]\nmacro_rules! init {\n    ($(&$this:ident in)? $t:ident $(::<$($generics:ty),* $(,)?>)? {\n        $($fields:tt)*\n    }) => {\n        $crate::__init_internal!(\n            @this($($this)?),\n            @typ($t $(::<$($generics),*>)?),\n            @fields($($fields)*),\n            @error(::core::convert::Infallible),\n            @data(InitData, /*no use_data*/),\n            @has_data(HasInitData, __init_data),\n            @construct_closure(init_from_closure),\n            @munch_fields($($fields)*),\n        )\n    }\n}\n\n/// Construct an in-place fallible initializer for `struct`s.\n///\n/// This macro defaults the error to [`Error`]. If you need [`Infallible`], then use\n/// [`init!`].\n///\n/// The syntax is identical to [`try_pin_init!`]. If you want to specify a custom error,\n/// append `? $type` after the `struct` initializer.\n/// The safety caveats from [`try_pin_init!`] also apply:\n/// - `unsafe` code must guarantee either full initialization or return an error and allow\n///   deallocation of the memory.\n/// - the fields are initialized in the order given in the initializer.\n/// - no references to fields are allowed to be created inside of the initializer.\n///\n/// # Examples\n///\n/// ```rust\n/// use kernel::{init::{PinInit, zeroed}, error::Error};\n/// struct BigBuf {\n///     big: Box<[u8; 1024 * 1024 * 1024]>,\n///     small: [u8; 1024 * 1024],\n/// }\n///\n/// impl BigBuf {\n///     fn new() -> impl Init<Self, Error> {\n///         try_init!(Self {\n///             big: Box::init(zeroed())?,\n///             small: [0; 1024 * 1024],\n///         }? Error)\n///     }\n/// }\n/// ```\n// For a detailed example of how this macro works, see the module documentation of the hidden\n// module `__internal` inside of `init/__internal.rs`.\n#[macro_export]\nmacro_rules! try_init {\n    ($(&$this:ident in)? $t:ident $(::<$($generics:ty),* $(,)?>)? {\n        $($fields:tt)*\n    }) => {\n        $crate::__init_internal!(\n            @this($($this)?),\n            @typ($t $(::<$($generics),*>)?),\n            @fields($($fields)*),\n            @error($crate::error::Error),\n            @data(InitData, /*no use_data*/),\n            @has_data(HasInitData, __init_data),\n            @construct_closure(init_from_closure),\n            @munch_fields($($fields)*),\n        )\n    };\n    ($(&$this:ident in)? $t:ident $(::<$($generics:ty),* $(,)?>)? {\n        $($fields:tt)*\n    }? $err:ty) => {\n        $crate::__init_internal!(\n            @this($($this)?),\n            @typ($t $(::<$($generics),*>)?),\n            @fields($($fields)*),\n            @error($err),\n            @data(InitData, /*no use_data*/),\n            @has_data(HasInitData, __init_data),\n            @construct_closure(init_from_closure),\n            @munch_fields($($fields)*),\n        )\n    };\n}\n\n/// A pin-initializer for the type `T`.\n///\n/// To use this initializer, you will need a suitable memory location that can hold a `T`. This can\n/// be [`Box<T>`], [`Arc<T>`], [`UniqueArc<T>`] or even the stack (see [`stack_pin_init!`]). Use the\n/// [`InPlaceInit::pin_init`] function of a smart pointer like [`Arc<T>`] on this.\n///\n/// Also see the [module description](self).\n///\n/// # Safety\n///\n/// When implementing this type you will need to take great care. Also there are probably very few\n/// cases where a manual implementation is necessary. Use [`pin_init_from_closure`] where possible.\n///\n/// The [`PinInit::__pinned_init`] function\n/// - returns `Ok(())` if it initialized every field of `slot`,\n/// - returns `Err(err)` if it encountered an error and then cleaned `slot`, this means:\n///     - `slot` can be deallocated without UB occurring,\n///     - `slot` does not need to be dropped,\n///     - `slot` is not partially initialized.\n/// - while constructing the `T` at `slot` it upholds the pinning invariants of `T`.\n///\n/// [`Arc<T>`]: crate::sync::Arc\n/// [`Arc::pin_init`]: crate::sync::Arc::pin_init\n#[must_use = \"An initializer must be used in order to create its value.\"]\npub unsafe trait PinInit<T: ?Sized, E = Infallible>: Sized {\n    /// Initializes `slot`.\n    ///\n    /// # Safety\n    ///\n    /// - `slot` is a valid pointer to uninitialized memory.\n    /// - the caller does not touch `slot` when `Err` is returned, they are only permitted to\n    ///   deallocate.\n    /// - `slot` will not move until it is dropped, i.e. it will be pinned.\n    unsafe fn __pinned_init(self, slot: *mut T) -> Result<(), E>;\n\n    /// First initializes the value using `self` then calls the function `f` with the initialized\n    /// value.\n    ///\n    /// If `f` returns an error the value is dropped and the initializer will forward the error.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # #![allow(clippy::disallowed_names)]\n    /// use kernel::{types::Opaque, init::pin_init_from_closure};\n    /// #[repr(C)]\n    /// struct RawFoo([u8; 16]);\n    /// extern {\n    ///     fn init_foo(_: *mut RawFoo);\n    /// }\n    ///\n    /// #[pin_data]\n    /// struct Foo {\n    ///     #[pin]\n    ///     raw: Opaque<RawFoo>,\n    /// }\n    ///\n    /// impl Foo {\n    ///     fn setup(self: Pin<&mut Self>) {\n    ///         pr_info!(\"Setting up foo\");\n    ///     }\n    /// }\n    ///\n    /// let foo = pin_init!(Foo {\n    ///     raw <- unsafe {\n    ///         Opaque::ffi_init(|s| {\n    ///             init_foo(s);\n    ///         })\n    ///     },\n    /// }).pin_chain(|foo| {\n    ///     foo.setup();\n    ///     Ok(())\n    /// });\n    /// ```\n    fn pin_chain<F>(self, f: F) -> ChainPinInit<Self, F, T, E>\n    where\n        F: FnOnce(Pin<&mut T>) -> Result<(), E>,\n    {\n        ChainPinInit(self, f, PhantomData)\n    }\n}\n\n/// An initializer returned by [`PinInit::pin_chain`].\npub struct ChainPinInit<I, F, T: ?Sized, E>(I, F, __internal::Invariant<(E, Box<T>)>);\n\n// SAFETY: The `__pinned_init` function is implemented such that it\n// - returns `Ok(())` on successful initialization,\n// - returns `Err(err)` on error and in this case `slot` will be dropped.\n// - considers `slot` pinned.\nunsafe impl<T: ?Sized, E, I, F> PinInit<T, E> for ChainPinInit<I, F, T, E>\nwhere\n    I: PinInit<T, E>,\n    F: FnOnce(Pin<&mut T>) -> Result<(), E>,\n{\n    unsafe fn __pinned_init(self, slot: *mut T) -> Result<(), E> {\n        // SAFETY: All requirements fulfilled since this function is `__pinned_init`.\n        unsafe { self.0.__pinned_init(slot)? };\n        // SAFETY: The above call initialized `slot` and we still have unique access.\n        let val = unsafe { &mut *slot };\n        // SAFETY: `slot` is considered pinned.\n        let val = unsafe { Pin::new_unchecked(val) };\n        (self.1)(val).map_err(|e| {\n            // SAFETY: `slot` was initialized above.\n            unsafe { core::ptr::drop_in_place(slot) };\n            e\n        })\n    }\n}\n\n/// An initializer for `T`.\n///\n/// To use this initializer, you will need a suitable memory location that can hold a `T`. This can\n/// be [`Box<T>`], [`Arc<T>`], [`UniqueArc<T>`] or even the stack (see [`stack_pin_init!`]). Use the\n/// [`InPlaceInit::init`] function of a smart pointer like [`Arc<T>`] on this. Because\n/// [`PinInit<T, E>`] is a super trait, you can use every function that takes it as well.\n///\n/// Also see the [module description](self).\n///\n/// # Safety\n///\n/// When implementing this type you will need to take great care. Also there are probably very few\n/// cases where a manual implementation is necessary. Use [`init_from_closure`] where possible.\n///\n/// The [`Init::__init`] function\n/// - returns `Ok(())` if it initialized every field of `slot`,\n/// - returns `Err(err)` if it encountered an error and then cleaned `slot`, this means:\n///     - `slot` can be deallocated without UB occurring,\n///     - `slot` does not need to be dropped,\n///     - `slot` is not partially initialized.\n/// - while constructing the `T` at `slot` it upholds the pinning invariants of `T`.\n///\n/// The `__pinned_init` function from the supertrait [`PinInit`] needs to execute the exact same\n/// code as `__init`.\n///\n/// Contrary to its supertype [`PinInit<T, E>`] the caller is allowed to\n/// move the pointee after initialization.\n///\n/// [`Arc<T>`]: crate::sync::Arc\n#[must_use = \"An initializer must be used in order to create its value.\"]\npub unsafe trait Init<T: ?Sized, E = Infallible>: PinInit<T, E> {\n    /// Initializes `slot`.\n    ///\n    /// # Safety\n    ///\n    /// - `slot` is a valid pointer to uninitialized memory.\n    /// - the caller does not touch `slot` when `Err` is returned, they are only permitted to\n    ///   deallocate.\n    unsafe fn __init(self, slot: *mut T) -> Result<(), E>;\n\n    /// First initializes the value using `self` then calls the function `f` with the initialized\n    /// value.\n    ///\n    /// If `f` returns an error the value is dropped and the initializer will forward the error.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # #![allow(clippy::disallowed_names)]\n    /// use kernel::{types::Opaque, init::{self, init_from_closure}};\n    /// struct Foo {\n    ///     buf: [u8; 1_000_000],\n    /// }\n    ///\n    /// impl Foo {\n    ///     fn setup(&mut self) {\n    ///         pr_info!(\"Setting up foo\");\n    ///     }\n    /// }\n    ///\n    /// let foo = init!(Foo {\n    ///     buf <- init::zeroed()\n    /// }).chain(|foo| {\n    ///     foo.setup();\n    ///     Ok(())\n    /// });\n    /// ```\n    fn chain<F>(self, f: F) -> ChainInit<Self, F, T, E>\n    where\n        F: FnOnce(&mut T) -> Result<(), E>,\n    {\n        ChainInit(self, f, PhantomData)\n    }\n}\n\n/// An initializer returned by [`Init::chain`].\npub struct ChainInit<I, F, T: ?Sized, E>(I, F, __internal::Invariant<(E, Box<T>)>);\n\n// SAFETY: The `__init` function is implemented such that it\n// - returns `Ok(())` on successful initialization,\n// - returns `Err(err)` on error and in this case `slot` will be dropped.\nunsafe impl<T: ?Sized, E, I, F> Init<T, E> for ChainInit<I, F, T, E>\nwhere\n    I: Init<T, E>,\n    F: FnOnce(&mut T) -> Result<(), E>,\n{\n    unsafe fn __init(self, slot: *mut T) -> Result<(), E> {\n        // SAFETY: All requirements fulfilled since this function is `__init`.\n        unsafe { self.0.__pinned_init(slot)? };\n        // SAFETY: The above call initialized `slot` and we still have unique access.\n        (self.1)(unsafe { &mut *slot }).map_err(|e| {\n            // SAFETY: `slot` was initialized above.\n            unsafe { core::ptr::drop_in_place(slot) };\n            e\n        })\n    }\n}\n\n// SAFETY: `__pinned_init` behaves exactly the same as `__init`.\nunsafe impl<T: ?Sized, E, I, F> PinInit<T, E> for ChainInit<I, F, T, E>\nwhere\n    I: Init<T, E>,\n    F: FnOnce(&mut T) -> Result<(), E>,\n{\n    unsafe fn __pinned_init(self, slot: *mut T) -> Result<(), E> {\n        // SAFETY: `__init` has less strict requirements compared to `__pinned_init`.\n        unsafe { self.__init(slot) }\n    }\n}\n\n/// Creates a new [`PinInit<T, E>`] from the given closure.\n///\n/// # Safety\n///\n/// The closure:\n/// - returns `Ok(())` if it initialized every field of `slot`,\n/// - returns `Err(err)` if it encountered an error and then cleaned `slot`, this means:\n///     - `slot` can be deallocated without UB occurring,\n///     - `slot` does not need to be dropped,\n///     - `slot` is not partially initialized.\n/// - may assume that the `slot` does not move if `T: !Unpin`,\n/// - while constructing the `T` at `slot` it upholds the pinning invariants of `T`.\n#[inline]\npub const unsafe fn pin_init_from_closure<T: ?Sized, E>(\n    f: impl FnOnce(*mut T) -> Result<(), E>,\n) -> impl PinInit<T, E> {\n    __internal::InitClosure(f, PhantomData)\n}\n\n/// Creates a new [`Init<T, E>`] from the given closure.\n///\n/// # Safety\n///\n/// The closure:\n/// - returns `Ok(())` if it initialized every field of `slot`,\n/// - returns `Err(err)` if it encountered an error and then cleaned `slot`, this means:\n///     - `slot` can be deallocated without UB occurring,\n///     - `slot` does not need to be dropped,\n///     - `slot` is not partially initialized.\n/// - the `slot` may move after initialization.\n/// - while constructing the `T` at `slot` it upholds the pinning invariants of `T`.\n#[inline]\npub const unsafe fn init_from_closure<T: ?Sized, E>(\n    f: impl FnOnce(*mut T) -> Result<(), E>,\n) -> impl Init<T, E> {\n    __internal::InitClosure(f, PhantomData)\n}\n\n/// An initializer that leaves the memory uninitialized.\n///\n/// The initializer is a no-op. The `slot` memory is not changed.\n#[inline]\npub fn uninit<T, E>() -> impl Init<MaybeUninit<T>, E> {\n    // SAFETY: The memory is allowed to be uninitialized.\n    unsafe { init_from_closure(|_| Ok(())) }\n}\n\n/// Initializes an array by initializing each element via the provided initializer.\n///\n/// # Examples\n///\n/// ```rust\n/// use kernel::{error::Error, init::init_array_from_fn};\n/// let array: Box<[usize; 1_000]>= Box::init::<Error>(init_array_from_fn(|i| i)).unwrap();\n/// assert_eq!(array.len(), 1_000);\n/// ```\npub fn init_array_from_fn<I, const N: usize, T, E>(\n    mut make_init: impl FnMut(usize) -> I,\n) -> impl Init<[T; N], E>\nwhere\n    I: Init<T, E>,\n{\n    let init = move |slot: *mut [T; N]| {\n        let slot = slot.cast::<T>();\n        // Counts the number of initialized elements and when dropped drops that many elements from\n        // `slot`.\n        let mut init_count = ScopeGuard::new_with_data(0, |i| {\n            // We now free every element that has been initialized before:\n            // SAFETY: The loop initialized exactly the values from 0..i and since we\n            // return `Err` below, the caller will consider the memory at `slot` as\n            // uninitialized.\n            unsafe { ptr::drop_in_place(ptr::slice_from_raw_parts_mut(slot, i)) };\n        });\n        for i in 0..N {\n            let init = make_init(i);\n            // SAFETY: Since 0 <= `i` < N, it is still in bounds of `[T; N]`.\n            let ptr = unsafe { slot.add(i) };\n            // SAFETY: The pointer is derived from `slot` and thus satisfies the `__init`\n            // requirements.\n            unsafe { init.__init(ptr) }?;\n            *init_count += 1;\n        }\n        init_count.dismiss();\n        Ok(())\n    };\n    // SAFETY: The initializer above initializes every element of the array. On failure it drops\n    // any initialized elements and returns `Err`.\n    unsafe { init_from_closure(init) }\n}\n\n/// Initializes an array by initializing each element via the provided initializer.\n///\n/// # Examples\n///\n/// ```rust\n/// use kernel::{sync::{Arc, Mutex}, init::pin_init_array_from_fn, new_mutex};\n/// let array: Arc<[Mutex<usize>; 1_000]>=\n///     Arc::pin_init(pin_init_array_from_fn(|i| new_mutex!(i))).unwrap();\n/// assert_eq!(array.len(), 1_000);\n/// ```\npub fn pin_init_array_from_fn<I, const N: usize, T, E>(\n    mut make_init: impl FnMut(usize) -> I,\n) -> impl PinInit<[T; N], E>\nwhere\n    I: PinInit<T, E>,\n{\n    let init = move |slot: *mut [T; N]| {\n        let slot = slot.cast::<T>();\n        // Counts the number of initialized elements and when dropped drops that many elements from\n        // `slot`.\n        let mut init_count = ScopeGuard::new_with_data(0, |i| {\n            // We now free every element that has been initialized before:\n            // SAFETY: The loop initialized exactly the values from 0..i and since we\n            // return `Err` below, the caller will consider the memory at `slot` as\n            // uninitialized.\n            unsafe { ptr::drop_in_place(ptr::slice_from_raw_parts_mut(slot, i)) };\n        });\n        for i in 0..N {\n            let init = make_init(i);\n            // SAFETY: Since 0 <= `i` < N, it is still in bounds of `[T; N]`.\n            let ptr = unsafe { slot.add(i) };\n            // SAFETY: The pointer is derived from `slot` and thus satisfies the `__init`\n            // requirements.\n            unsafe { init.__pinned_init(ptr) }?;\n            *init_count += 1;\n        }\n        init_count.dismiss();\n        Ok(())\n    };\n    // SAFETY: The initializer above initializes every element of the array. On failure it drops\n    // any initialized elements and returns `Err`.\n    unsafe { pin_init_from_closure(init) }\n}\n\n// SAFETY: Every type can be initialized by-value.\nunsafe impl<T, E> Init<T, E> for T {\n    unsafe fn __init(self, slot: *mut T) -> Result<(), E> {\n        unsafe { slot.write(self) };\n        Ok(())\n    }\n}\n\n// SAFETY: Every type can be initialized by-value. `__pinned_init` calls `__init`.\nunsafe impl<T, E> PinInit<T, E> for T {\n    unsafe fn __pinned_init(self, slot: *mut T) -> Result<(), E> {\n        unsafe { self.__init(slot) }\n    }\n}\n\n/// Smart pointer that can initialize memory in-place.\npub trait InPlaceInit<T>: Sized {\n    /// Use the given pin-initializer to pin-initialize a `T` inside of a new smart pointer of this\n    /// type.\n    ///\n    /// If `T: !Unpin` it will not be able to move afterwards.\n    fn try_pin_init<E>(init: impl PinInit<T, E>) -> Result<Pin<Self>, E>\n    where\n        E: From<AllocError>;\n\n    /// Use the given pin-initializer to pin-initialize a `T` inside of a new smart pointer of this\n    /// type.\n    ///\n    /// If `T: !Unpin` it will not be able to move afterwards.\n    fn pin_init<E>(init: impl PinInit<T, E>) -> error::Result<Pin<Self>>\n    where\n        Error: From<E>,\n    {\n        // SAFETY: We delegate to `init` and only change the error type.\n        let init = unsafe {\n            pin_init_from_closure(|slot| init.__pinned_init(slot).map_err(|e| Error::from(e)))\n        };\n        Self::try_pin_init(init)\n    }\n\n    /// Use the given initializer to in-place initialize a `T`.\n    fn try_init<E>(init: impl Init<T, E>) -> Result<Self, E>\n    where\n        E: From<AllocError>;\n\n    /// Use the given initializer to in-place initialize a `T`.\n    fn init<E>(init: impl Init<T, E>) -> error::Result<Self>\n    where\n        Error: From<E>,\n    {\n        // SAFETY: We delegate to `init` and only change the error type.\n        let init = unsafe {\n            init_from_closure(|slot| init.__pinned_init(slot).map_err(|e| Error::from(e)))\n        };\n        Self::try_init(init)\n    }\n}\n\nimpl<T> InPlaceInit<T> for Box<T> {\n    #[inline]\n    fn try_pin_init<E>(init: impl PinInit<T, E>) -> Result<Pin<Self>, E>\n    where\n        E: From<AllocError>,\n    {\n        let mut this = Box::try_new_uninit()?;\n        let slot = this.as_mut_ptr();\n        // SAFETY: When init errors/panics, slot will get deallocated but not dropped,\n        // slot is valid and will not be moved, because we pin it later.\n        unsafe { init.__pinned_init(slot)? };\n        // SAFETY: All fields have been initialized.\n        Ok(unsafe { this.assume_init() }.into())\n    }\n\n    #[inline]\n    fn try_init<E>(init: impl Init<T, E>) -> Result<Self, E>\n    where\n        E: From<AllocError>,\n    {\n        let mut this = Box::try_new_uninit()?;\n        let slot = this.as_mut_ptr();\n        // SAFETY: When init errors/panics, slot will get deallocated but not dropped,\n        // slot is valid.\n        unsafe { init.__init(slot)? };\n        // SAFETY: All fields have been initialized.\n        Ok(unsafe { this.assume_init() })\n    }\n}\n\nimpl<T> InPlaceInit<T> for UniqueArc<T> {\n    #[inline]\n    fn try_pin_init<E>(init: impl PinInit<T, E>) -> Result<Pin<Self>, E>\n    where\n        E: From<AllocError>,\n    {\n        let mut this = UniqueArc::try_new_uninit()?;\n        let slot = this.as_mut_ptr();\n        // SAFETY: When init errors/panics, slot will get deallocated but not dropped,\n        // slot is valid and will not be moved, because we pin it later.\n        unsafe { init.__pinned_init(slot)? };\n        // SAFETY: All fields have been initialized.\n        Ok(unsafe { this.assume_init() }.into())\n    }\n\n    #[inline]\n    fn try_init<E>(init: impl Init<T, E>) -> Result<Self, E>\n    where\n        E: From<AllocError>,\n    {\n        let mut this = UniqueArc::try_new_uninit()?;\n        let slot = this.as_mut_ptr();\n        // SAFETY: When init errors/panics, slot will get deallocated but not dropped,\n        // slot is valid.\n        unsafe { init.__init(slot)? };\n        // SAFETY: All fields have been initialized.\n        Ok(unsafe { this.assume_init() })\n    }\n}\n\n/// Trait facilitating pinned destruction.\n///\n/// Use [`pinned_drop`] to implement this trait safely:\n///\n/// ```rust\n/// # use kernel::sync::Mutex;\n/// use kernel::macros::pinned_drop;\n/// use core::pin::Pin;\n/// #[pin_data(PinnedDrop)]\n/// struct Foo {\n///     #[pin]\n///     mtx: Mutex<usize>,\n/// }\n///\n/// #[pinned_drop]\n/// impl PinnedDrop for Foo {\n///     fn drop(self: Pin<&mut Self>) {\n///         pr_info!(\"Foo is being dropped!\");\n///     }\n/// }\n/// ```\n///\n/// # Safety\n///\n/// This trait must be implemented via the [`pinned_drop`] proc-macro attribute on the impl.\n///\n/// [`pinned_drop`]: kernel::macros::pinned_drop\npub unsafe trait PinnedDrop: __internal::HasPinData {\n    /// Executes the pinned destructor of this type.\n    ///\n    /// While this function is marked safe, it is actually unsafe to call it manually. For this\n    /// reason it takes an additional parameter. This type can only be constructed by `unsafe` code\n    /// and thus prevents this function from being called where it should not.\n    ///\n    /// This extra parameter will be generated by the `#[pinned_drop]` proc-macro attribute\n    /// automatically.\n    fn drop(self: Pin<&mut Self>, only_call_from_drop: __internal::OnlyCallFromDrop);\n}\n\n/// Marker trait for types that can be initialized by writing just zeroes.\n///\n/// # Safety\n///\n/// The bit pattern consisting of only zeroes is a valid bit pattern for this type. In other words,\n/// this is not UB:\n///\n/// ```rust,ignore\n/// let val: Self = unsafe { core::mem::zeroed() };\n/// ```\npub unsafe trait Zeroable {}\n\n/// Create a new zeroed T.\n///\n/// The returned initializer will write `0x00` to every byte of the given `slot`.\n#[inline]\npub fn zeroed<T: Zeroable>() -> impl Init<T> {\n    // SAFETY: Because `T: Zeroable`, all bytes zero is a valid bit pattern for `T`\n    // and because we write all zeroes, the memory is initialized.\n    unsafe {\n        init_from_closure(|slot: *mut T| {\n            slot.write_bytes(0, 1);\n            Ok(())\n        })\n    }\n}\n\nmacro_rules! impl_zeroable {\n    ($($({$($generics:tt)*})? $t:ty, )*) => {\n        $(unsafe impl$($($generics)*)? Zeroable for $t {})*\n    };\n}\n\nimpl_zeroable! {\n    // SAFETY: All primitives that are allowed to be zero.\n    bool,\n    char,\n    u8, u16, u32, u64, u128, usize,\n    i8, i16, i32, i64, i128, isize,\n    f32, f64,\n\n    // SAFETY: These are ZSTs, there is nothing to zero.\n    {<T: ?Sized>} PhantomData<T>, core::marker::PhantomPinned, Infallible, (),\n\n    // SAFETY: Type is allowed to take any value, including all zeros.\n    {<T>} MaybeUninit<T>,\n    // SAFETY: Type is allowed to take any value, including all zeros.\n    {<T>} Opaque<T>,\n\n    // SAFETY: `T: Zeroable` and `UnsafeCell` is `repr(transparent)`.\n    {<T: ?Sized + Zeroable>} UnsafeCell<T>,\n\n    // SAFETY: All zeros is equivalent to `None` (option layout optimization guarantee).\n    Option<NonZeroU8>, Option<NonZeroU16>, Option<NonZeroU32>, Option<NonZeroU64>,\n    Option<NonZeroU128>, Option<NonZeroUsize>,\n    Option<NonZeroI8>, Option<NonZeroI16>, Option<NonZeroI32>, Option<NonZeroI64>,\n    Option<NonZeroI128>, Option<NonZeroIsize>,\n\n    // SAFETY: All zeros is equivalent to `None` (option layout optimization guarantee).\n    //\n    // In this case we are allowed to use `T: ?Sized`, since all zeros is the `None` variant.\n    {<T: ?Sized>} Option<NonNull<T>>,\n    {<T: ?Sized>} Option<Box<T>>,\n\n    // SAFETY: `null` pointer is valid.\n    //\n    // We cannot use `T: ?Sized`, since the VTABLE pointer part of fat pointers is not allowed to be\n    // null.\n    //\n    // When `Pointee` gets stabilized, we could use\n    // `T: ?Sized where <T as Pointee>::Metadata: Zeroable`\n    {<T>} *mut T, {<T>} *const T,\n\n    // SAFETY: `null` pointer is valid and the metadata part of these fat pointers is allowed to be\n    // zero.\n    {<T>} *mut [T], {<T>} *const [T], *mut str, *const str,\n\n    // SAFETY: `T` is `Zeroable`.\n    {<const N: usize, T: Zeroable>} [T; N], {<T: Zeroable>} Wrapping<T>,\n}\n\nmacro_rules! impl_tuple_zeroable {\n    ($(,)?) => {};\n    ($first:ident, $($t:ident),* $(,)?) => {\n        // SAFETY: All elements are zeroable and padding can be zero.\n        unsafe impl<$first: Zeroable, $($t: Zeroable),*> Zeroable for ($first, $($t),*) {}\n        impl_tuple_zeroable!($($t),* ,);\n    }\n}\n\nimpl_tuple_zeroable!(A, B, C, D, E, F, G, H, I, J);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}