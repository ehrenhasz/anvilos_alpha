{
  "module_name": "__internal.rs",
  "hash_id": "c6dc925e0c8e7045711ee188492a4ae4b0d5e795e9a22ac2a6910d07de4f4a90",
  "original_prompt": "Ingested from linux-6.6.14/rust/kernel/init/__internal.rs",
  "human_readable_source": "// SPDX-License-Identifier: Apache-2.0 OR MIT\n\n//! This module contains API-internal items for pin-init.\n//!\n//! These items must not be used outside of\n//! - `kernel/init.rs`\n//! - `macros/pin_data.rs`\n//! - `macros/pinned_drop.rs`\n\nuse super::*;\n\n/// See the [nomicon] for what subtyping is. See also [this table].\n///\n/// [nomicon]: https://doc.rust-lang.org/nomicon/subtyping.html\n/// [this table]: https://doc.rust-lang.org/nomicon/phantom-data.html#table-of-phantomdata-patterns\npub(super) type Invariant<T> = PhantomData<fn(*mut T) -> *mut T>;\n\n/// This is the module-internal type implementing `PinInit` and `Init`. It is unsafe to create this\n/// type, since the closure needs to fulfill the same safety requirement as the\n/// `__pinned_init`/`__init` functions.\npub(crate) struct InitClosure<F, T: ?Sized, E>(pub(crate) F, pub(crate) Invariant<(E, T)>);\n\n// SAFETY: While constructing the `InitClosure`, the user promised that it upholds the\n// `__init` invariants.\nunsafe impl<T: ?Sized, F, E> Init<T, E> for InitClosure<F, T, E>\nwhere\n    F: FnOnce(*mut T) -> Result<(), E>,\n{\n    #[inline]\n    unsafe fn __init(self, slot: *mut T) -> Result<(), E> {\n        (self.0)(slot)\n    }\n}\n\n// SAFETY: While constructing the `InitClosure`, the user promised that it upholds the\n// `__pinned_init` invariants.\nunsafe impl<T: ?Sized, F, E> PinInit<T, E> for InitClosure<F, T, E>\nwhere\n    F: FnOnce(*mut T) -> Result<(), E>,\n{\n    #[inline]\n    unsafe fn __pinned_init(self, slot: *mut T) -> Result<(), E> {\n        (self.0)(slot)\n    }\n}\n\n/// This trait is only implemented via the `#[pin_data]` proc-macro. It is used to facilitate\n/// the pin projections within the initializers.\n///\n/// # Safety\n///\n/// Only the `init` module is allowed to use this trait.\npub unsafe trait HasPinData {\n    type PinData: PinData;\n\n    unsafe fn __pin_data() -> Self::PinData;\n}\n\n/// Marker trait for pinning data of structs.\n///\n/// # Safety\n///\n/// Only the `init` module is allowed to use this trait.\npub unsafe trait PinData: Copy {\n    type Datee: ?Sized + HasPinData;\n\n    /// Type inference helper function.\n    fn make_closure<F, O, E>(self, f: F) -> F\n    where\n        F: FnOnce(*mut Self::Datee) -> Result<O, E>,\n    {\n        f\n    }\n}\n\n/// This trait is automatically implemented for every type. It aims to provide the same type\n/// inference help as `HasPinData`.\n///\n/// # Safety\n///\n/// Only the `init` module is allowed to use this trait.\npub unsafe trait HasInitData {\n    type InitData: InitData;\n\n    unsafe fn __init_data() -> Self::InitData;\n}\n\n/// Same function as `PinData`, but for arbitrary data.\n///\n/// # Safety\n///\n/// Only the `init` module is allowed to use this trait.\npub unsafe trait InitData: Copy {\n    type Datee: ?Sized + HasInitData;\n\n    /// Type inference helper function.\n    fn make_closure<F, O, E>(self, f: F) -> F\n    where\n        F: FnOnce(*mut Self::Datee) -> Result<O, E>,\n    {\n        f\n    }\n}\n\npub struct AllData<T: ?Sized>(PhantomData<fn(Box<T>) -> Box<T>>);\n\nimpl<T: ?Sized> Clone for AllData<T> {\n    fn clone(&self) -> Self {\n        *self\n    }\n}\n\nimpl<T: ?Sized> Copy for AllData<T> {}\n\nunsafe impl<T: ?Sized> InitData for AllData<T> {\n    type Datee = T;\n}\n\nunsafe impl<T: ?Sized> HasInitData for T {\n    type InitData = AllData<T>;\n\n    unsafe fn __init_data() -> Self::InitData {\n        AllData(PhantomData)\n    }\n}\n\n/// Stack initializer helper type. Use [`stack_pin_init`] instead of this primitive.\n///\n/// # Invariants\n///\n/// If `self.is_init` is true, then `self.value` is initialized.\n///\n/// [`stack_pin_init`]: kernel::stack_pin_init\npub struct StackInit<T> {\n    value: MaybeUninit<T>,\n    is_init: bool,\n}\n\nimpl<T> Drop for StackInit<T> {\n    #[inline]\n    fn drop(&mut self) {\n        if self.is_init {\n            // SAFETY: As we are being dropped, we only call this once. And since `self.is_init` is\n            // true, `self.value` is initialized.\n            unsafe { self.value.assume_init_drop() };\n        }\n    }\n}\n\nimpl<T> StackInit<T> {\n    /// Creates a new [`StackInit<T>`] that is uninitialized. Use [`stack_pin_init`] instead of this\n    /// primitive.\n    ///\n    /// [`stack_pin_init`]: kernel::stack_pin_init\n    #[inline]\n    pub fn uninit() -> Self {\n        Self {\n            value: MaybeUninit::uninit(),\n            is_init: false,\n        }\n    }\n\n    /// Initializes the contents and returns the result.\n    #[inline]\n    pub fn init<E>(self: Pin<&mut Self>, init: impl PinInit<T, E>) -> Result<Pin<&mut T>, E> {\n        // SAFETY: We never move out of `this`.\n        let this = unsafe { Pin::into_inner_unchecked(self) };\n        // The value is currently initialized, so it needs to be dropped before we can reuse\n        // the memory (this is a safety guarantee of `Pin`).\n        if this.is_init {\n            this.is_init = false;\n            // SAFETY: `this.is_init` was true and therefore `this.value` is initialized.\n            unsafe { this.value.assume_init_drop() };\n        }\n        // SAFETY: The memory slot is valid and this type ensures that it will stay pinned.\n        unsafe { init.__pinned_init(this.value.as_mut_ptr())? };\n        // INVARIANT: `this.value` is initialized above.\n        this.is_init = true;\n        // SAFETY: The slot is now pinned, since we will never give access to `&mut T`.\n        Ok(unsafe { Pin::new_unchecked(this.value.assume_init_mut()) })\n    }\n}\n\n/// When a value of this type is dropped, it drops a `T`.\n///\n/// Can be forgotten to prevent the drop.\npub struct DropGuard<T: ?Sized> {\n    ptr: *mut T,\n}\n\nimpl<T: ?Sized> DropGuard<T> {\n    /// Creates a new [`DropGuard<T>`]. It will [`ptr::drop_in_place`] `ptr` when it gets dropped.\n    ///\n    /// # Safety\n    ///\n    /// `ptr` must be a valid pointer.\n    ///\n    /// It is the callers responsibility that `self` will only get dropped if the pointee of `ptr`:\n    /// - has not been dropped,\n    /// - is not accessible by any other means,\n    /// - will not be dropped by any other means.\n    #[inline]\n    pub unsafe fn new(ptr: *mut T) -> Self {\n        Self { ptr }\n    }\n}\n\nimpl<T: ?Sized> Drop for DropGuard<T> {\n    #[inline]\n    fn drop(&mut self) {\n        // SAFETY: A `DropGuard` can only be constructed using the unsafe `new` function\n        // ensuring that this operation is safe.\n        unsafe { ptr::drop_in_place(self.ptr) }\n    }\n}\n\n/// Token used by `PinnedDrop` to prevent calling the function without creating this unsafely\n/// created struct. This is needed, because the `drop` function is safe, but should not be called\n/// manually.\npub struct OnlyCallFromDrop(());\n\nimpl OnlyCallFromDrop {\n    /// # Safety\n    ///\n    /// This function should only be called from the [`Drop::drop`] function and only be used to\n    /// delegate the destruction to the pinned destructor [`PinnedDrop::drop`] of the same type.\n    pub unsafe fn new() -> Self {\n        Self(())\n    }\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}