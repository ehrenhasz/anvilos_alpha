{
  "module_name": "macros.rs",
  "hash_id": "e9ca05377a5c5f3b4ac89f93a54eb8459d2c8215129efb9b6af3ce22799c30fe",
  "original_prompt": "Ingested from linux-6.6.14/rust/kernel/init/macros.rs",
  "human_readable_source": "// SPDX-License-Identifier: Apache-2.0 OR MIT\n\n//! This module provides the macros that actually implement the proc-macros `pin_data` and\n//! `pinned_drop`. It also contains `__init_internal` the implementation of the `{try_}{pin_}init!`\n//! macros.\n//!\n//! These macros should never be called directly, since they expect their input to be\n//! in a certain format which is internal. If used incorrectly, these macros can lead to UB even in\n//! safe code! Use the public facing macros instead.\n//!\n//! This architecture has been chosen because the kernel does not yet have access to `syn` which\n//! would make matters a lot easier for implementing these as proc-macros.\n//!\n//! # Macro expansion example\n//!\n//! This section is intended for readers trying to understand the macros in this module and the\n//! `pin_init!` macros from `init.rs`.\n//!\n//! We will look at the following example:\n//!\n//! ```rust,ignore\n//! # use kernel::init::*;\n//! # use core::pin::Pin;\n//! #[pin_data]\n//! #[repr(C)]\n//! struct Bar<T> {\n//!     #[pin]\n//!     t: T,\n//!     pub x: usize,\n//! }\n//!\n//! impl<T> Bar<T> {\n//!     fn new(t: T) -> impl PinInit<Self> {\n//!         pin_init!(Self { t, x: 0 })\n//!     }\n//! }\n//!\n//! #[pin_data(PinnedDrop)]\n//! struct Foo {\n//!     a: usize,\n//!     #[pin]\n//!     b: Bar<u32>,\n//! }\n//!\n//! #[pinned_drop]\n//! impl PinnedDrop for Foo {\n//!     fn drop(self: Pin<&mut Self>) {\n//!         pr_info!(\"{self:p} is getting dropped.\");\n//!     }\n//! }\n//!\n//! let a = 42;\n//! let initializer = pin_init!(Foo {\n//!     a,\n//!     b <- Bar::new(36),\n//! });\n//! ```\n//!\n//! This example includes the most common and important features of the pin-init API.\n//!\n//! Below you can find individual section about the different macro invocations. Here are some\n//! general things we need to take into account when designing macros:\n//! - use global paths, similarly to file paths, these start with the separator: `::core::panic!()`\n//!   this ensures that the correct item is used, since users could define their own `mod core {}`\n//!   and then their own `panic!` inside to execute arbitrary code inside of our macro.\n//! - macro `unsafe` hygiene: we need to ensure that we do not expand arbitrary, user-supplied\n//!   expressions inside of an `unsafe` block in the macro, because this would allow users to do\n//!   `unsafe` operations without an associated `unsafe` block.\n//!\n//! ## `#[pin_data]` on `Bar`\n//!\n//! This macro is used to specify which fields are structurally pinned and which fields are not. It\n//! is placed on the struct definition and allows `#[pin]` to be placed on the fields.\n//!\n//! Here is the definition of `Bar` from our example:\n//!\n//! ```rust,ignore\n//! # use kernel::init::*;\n//! #[pin_data]\n//! #[repr(C)]\n//! struct Bar<T> {\n//!     #[pin]\n//!     t: T,\n//!     pub x: usize,\n//! }\n//! ```\n//!\n//! This expands to the following code:\n//!\n//! ```rust,ignore\n//! // Firstly the normal definition of the struct, attributes are preserved:\n//! #[repr(C)]\n//! struct Bar<T> {\n//!     t: T,\n//!     pub x: usize,\n//! }\n//! // Then an anonymous constant is defined, this is because we do not want any code to access the\n//! // types that we define inside:\n//! const _: () = {\n//!     // We define the pin-data carrying struct, it is a ZST and needs to have the same generics,\n//!     // since we need to implement access functions for each field and thus need to know its\n//!     // type.\n//!     struct __ThePinData<T> {\n//!         __phantom: ::core::marker::PhantomData<fn(Bar<T>) -> Bar<T>>,\n//!     }\n//!     // We implement `Copy` for the pin-data struct, since all functions it defines will take\n//!     // `self` by value.\n//!     impl<T> ::core::clone::Clone for __ThePinData<T> {\n//!         fn clone(&self) -> Self {\n//!             *self\n//!         }\n//!     }\n//!     impl<T> ::core::marker::Copy for __ThePinData<T> {}\n//!     // For every field of `Bar`, the pin-data struct will define a function with the same name\n//!     // and accessor (`pub` or `pub(crate)` etc.). This function will take a pointer to the\n//!     // field (`slot`) and a `PinInit` or `Init` depending on the projection kind of the field\n//!     // (if pinning is structural for the field, then `PinInit` otherwise `Init`).\n//!     #[allow(dead_code)]\n//!     impl<T> __ThePinData<T> {\n//!         unsafe fn t<E>(\n//!             self,\n//!             slot: *mut T,\n//!             // Since `t` is `#[pin]`, this is `PinInit`.\n//!             init: impl ::kernel::init::PinInit<T, E>,\n//!         ) -> ::core::result::Result<(), E> {\n//!             unsafe { ::kernel::init::PinInit::__pinned_init(init, slot) }\n//!         }\n//!         pub unsafe fn x<E>(\n//!             self,\n//!             slot: *mut usize,\n//!             // Since `x` is not `#[pin]`, this is `Init`.\n//!             init: impl ::kernel::init::Init<usize, E>,\n//!         ) -> ::core::result::Result<(), E> {\n//!             unsafe { ::kernel::init::Init::__init(init, slot) }\n//!         }\n//!     }\n//!     // Implement the internal `HasPinData` trait that associates `Bar` with the pin-data struct\n//!     // that we constructed above.\n//!     unsafe impl<T> ::kernel::init::__internal::HasPinData for Bar<T> {\n//!         type PinData = __ThePinData<T>;\n//!         unsafe fn __pin_data() -> Self::PinData {\n//!             __ThePinData {\n//!                 __phantom: ::core::marker::PhantomData,\n//!             }\n//!         }\n//!     }\n//!     // Implement the internal `PinData` trait that marks the pin-data struct as a pin-data\n//!     // struct. This is important to ensure that no user can implement a rouge `__pin_data`\n//!     // function without using `unsafe`.\n//!     unsafe impl<T> ::kernel::init::__internal::PinData for __ThePinData<T> {\n//!         type Datee = Bar<T>;\n//!     }\n//!     // Now we only want to implement `Unpin` for `Bar` when every structurally pinned field is\n//!     // `Unpin`. In other words, whether `Bar` is `Unpin` only depends on structurally pinned\n//!     // fields (those marked with `#[pin]`). These fields will be listed in this struct, in our\n//!     // case no such fields exist, hence this is almost empty. The two phantomdata fields exist\n//!     // for two reasons:\n//!     // - `__phantom`: every generic must be used, since we cannot really know which generics\n//!     //   are used, we declere all and then use everything here once.\n//!     // - `__phantom_pin`: uses the `'__pin` lifetime and ensures that this struct is invariant\n//!     //   over it. The lifetime is needed to work around the limitation that trait bounds must\n//!     //   not be trivial, e.g. the user has a `#[pin] PhantomPinned` field -- this is\n//!     //   unconditionally `!Unpin` and results in an error. The lifetime tricks the compiler\n//!     //   into accepting these bounds regardless.\n//!     #[allow(dead_code)]\n//!     struct __Unpin<'__pin, T> {\n//!         __phantom_pin: ::core::marker::PhantomData<fn(&'__pin ()) -> &'__pin ()>,\n//!         __phantom: ::core::marker::PhantomData<fn(Bar<T>) -> Bar<T>>,\n//!         // Our only `#[pin]` field is `t`.\n//!         t: T,\n//!     }\n//!     #[doc(hidden)]\n//!     impl<'__pin, T> ::core::marker::Unpin for Bar<T>\n//!     where\n//!         __Unpin<'__pin, T>: ::core::marker::Unpin,\n//!     {}\n//!     // Now we need to ensure that `Bar` does not implement `Drop`, since that would give users\n//!     // access to `&mut self` inside of `drop` even if the struct was pinned. This could lead to\n//!     // UB with only safe code, so we disallow this by giving a trait implementation error using\n//!     // a direct impl and a blanket implementation.\n//!     trait MustNotImplDrop {}\n//!     // Normally `Drop` bounds do not have the correct semantics, but for this purpose they do\n//!     // (normally people want to know if a type has any kind of drop glue at all, here we want\n//!     // to know if it has any kind of custom drop glue, which is exactly what this bound does).\n//!     #[allow(drop_bounds)]\n//!     impl<T: ::core::ops::Drop> MustNotImplDrop for T {}\n//!     impl<T> MustNotImplDrop for Bar<T> {}\n//!     // Here comes a convenience check, if one implemented `PinnedDrop`, but forgot to add it to\n//!     // `#[pin_data]`, then this will error with the same mechanic as above, this is not needed\n//!     // for safety, but a good sanity check, since no normal code calls `PinnedDrop::drop`.\n//!     #[allow(non_camel_case_types)]\n//!     trait UselessPinnedDropImpl_you_need_to_specify_PinnedDrop {}\n//!     impl<\n//!         T: ::kernel::init::PinnedDrop,\n//!     > UselessPinnedDropImpl_you_need_to_specify_PinnedDrop for T {}\n//!     impl<T> UselessPinnedDropImpl_you_need_to_specify_PinnedDrop for Bar<T> {}\n//! };\n//! ```\n//!\n//! ## `pin_init!` in `impl Bar`\n//!\n//! This macro creates an pin-initializer for the given struct. It requires that the struct is\n//! annotated by `#[pin_data]`.\n//!\n//! Here is the impl on `Bar` defining the new function:\n//!\n//! ```rust,ignore\n//! impl<T> Bar<T> {\n//!     fn new(t: T) -> impl PinInit<Self> {\n//!         pin_init!(Self { t, x: 0 })\n//!     }\n//! }\n//! ```\n//!\n//! This expands to the following code:\n//!\n//! ```rust,ignore\n//! impl<T> Bar<T> {\n//!     fn new(t: T) -> impl PinInit<Self> {\n//!         {\n//!             // We do not want to allow arbitrary returns, so we declare this type as the `Ok`\n//!             // return type and shadow it later when we insert the arbitrary user code. That way\n//!             // there will be no possibility of returning without `unsafe`.\n//!             struct __InitOk;\n//!             // Get the data about fields from the supplied type.\n//!             // - the function is unsafe, hence the unsafe block\n//!             // - we `use` the `HasPinData` trait in the block, it is only available in that\n//!             //   scope.\n//!             let data = unsafe {\n//!                 use ::kernel::init::__internal::HasPinData;\n//!                 Self::__pin_data()\n//!             };\n//!             // Ensure that `data` really is of type `PinData` and help with type inference:\n//!             let init = ::kernel::init::__internal::PinData::make_closure::<\n//!                 _,\n//!                 __InitOk,\n//!                 ::core::convert::Infallible,\n//!             >(data, move |slot| {\n//!                 {\n//!                     // Shadow the structure so it cannot be used to return early. If a user\n//!                     // tries to write `return Ok(__InitOk)`, then they get a type error,\n//!                     // since that will refer to this struct instead of the one defined\n//!                     // above.\n//!                     struct __InitOk;\n//!                     // This is the expansion of `t,`, which is syntactic sugar for `t: t,`.\n//!                     {\n//!                         unsafe { ::core::ptr::write(::core::addr_of_mut!((*slot).t), t) };\n//!                     }\n//!                     // Since initialization could fail later (not in this case, since the\n//!                     // error type is `Infallible`) we will need to drop this field if there\n//!                     // is an error later. This `DropGuard` will drop the field when it gets\n//!                     // dropped and has not yet been forgotten.\n//!                     let t = unsafe {\n//!                         ::pinned_init::__internal::DropGuard::new(::core::addr_of_mut!((*slot).t))\n//!                     };\n//!                     // Expansion of `x: 0,`:\n//!                     // Since this can be an arbitrary expression we cannot place it inside\n//!                     // of the `unsafe` block, so we bind it here.\n//!                     {\n//!                         let x = 0;\n//!                         unsafe { ::core::ptr::write(::core::addr_of_mut!((*slot).x), x) };\n//!                     }\n//!                     // We again create a `DropGuard`.\n//!                     let x = unsafe {\n//!                         ::kernel::init::__internal::DropGuard::new(::core::addr_of_mut!((*slot).x))\n//!                     };\n//!                     // Since initialization has successfully completed, we can now forget\n//!                     // the guards. This is not `mem::forget`, since we only have\n//!                     // `&DropGuard`.\n//!                     ::core::mem::forget(x);\n//!                     ::core::mem::forget(t);\n//!                     // Here we use the type checker to ensure that every field has been\n//!                     // initialized exactly once, since this is `if false` it will never get\n//!                     // executed, but still type-checked.\n//!                     // Additionally we abuse `slot` to automatically infer the correct type\n//!                     // for the struct. This is also another check that every field is\n//!                     // accessible from this scope.\n//!                     #[allow(unreachable_code, clippy::diverging_sub_expression)]\n//!                     let _ = || {\n//!                         unsafe {\n//!                             ::core::ptr::write(\n//!                                 slot,\n//!                                 Self {\n//!                                     // We only care about typecheck finding every field\n//!                                     // here, the expression does not matter, just conjure\n//!                                     // one using `panic!()`:\n//!                                     t: ::core::panic!(),\n//!                                     x: ::core::panic!(),\n//!                                 },\n//!                             );\n//!                         };\n//!                     };\n//!                 }\n//!                 // We leave the scope above and gain access to the previously shadowed\n//!                 // `__InitOk` that we need to return.\n//!                 Ok(__InitOk)\n//!             });\n//!             // Change the return type from `__InitOk` to `()`.\n//!             let init = move |\n//!                 slot,\n//!             | -> ::core::result::Result<(), ::core::convert::Infallible> {\n//!                 init(slot).map(|__InitOk| ())\n//!             };\n//!             // Construct the initializer.\n//!             let init = unsafe {\n//!                 ::kernel::init::pin_init_from_closure::<\n//!                     _,\n//!                     ::core::convert::Infallible,\n//!                 >(init)\n//!             };\n//!             init\n//!         }\n//!     }\n//! }\n//! ```\n//!\n//! ## `#[pin_data]` on `Foo`\n//!\n//! Since we already took a look at `#[pin_data]` on `Bar`, this section will only explain the\n//! differences/new things in the expansion of the `Foo` definition:\n//!\n//! ```rust,ignore\n//! #[pin_data(PinnedDrop)]\n//! struct Foo {\n//!     a: usize,\n//!     #[pin]\n//!     b: Bar<u32>,\n//! }\n//! ```\n//!\n//! This expands to the following code:\n//!\n//! ```rust,ignore\n//! struct Foo {\n//!     a: usize,\n//!     b: Bar<u32>,\n//! }\n//! const _: () = {\n//!     struct __ThePinData {\n//!         __phantom: ::core::marker::PhantomData<fn(Foo) -> Foo>,\n//!     }\n//!     impl ::core::clone::Clone for __ThePinData {\n//!         fn clone(&self) -> Self {\n//!             *self\n//!         }\n//!     }\n//!     impl ::core::marker::Copy for __ThePinData {}\n//!     #[allow(dead_code)]\n//!     impl __ThePinData {\n//!         unsafe fn b<E>(\n//!             self,\n//!             slot: *mut Bar<u32>,\n//!             init: impl ::kernel::init::PinInit<Bar<u32>, E>,\n//!         ) -> ::core::result::Result<(), E> {\n//!             unsafe { ::kernel::init::PinInit::__pinned_init(init, slot) }\n//!         }\n//!         unsafe fn a<E>(\n//!             self,\n//!             slot: *mut usize,\n//!             init: impl ::kernel::init::Init<usize, E>,\n//!         ) -> ::core::result::Result<(), E> {\n//!             unsafe { ::kernel::init::Init::__init(init, slot) }\n//!         }\n//!     }\n//!     unsafe impl ::kernel::init::__internal::HasPinData for Foo {\n//!         type PinData = __ThePinData;\n//!         unsafe fn __pin_data() -> Self::PinData {\n//!             __ThePinData {\n//!                 __phantom: ::core::marker::PhantomData,\n//!             }\n//!         }\n//!     }\n//!     unsafe impl ::kernel::init::__internal::PinData for __ThePinData {\n//!         type Datee = Foo;\n//!     }\n//!     #[allow(dead_code)]\n//!     struct __Unpin<'__pin> {\n//!         __phantom_pin: ::core::marker::PhantomData<fn(&'__pin ()) -> &'__pin ()>,\n//!         __phantom: ::core::marker::PhantomData<fn(Foo) -> Foo>,\n//!         b: Bar<u32>,\n//!     }\n//!     #[doc(hidden)]\n//!     impl<'__pin> ::core::marker::Unpin for Foo\n//!     where\n//!         __Unpin<'__pin>: ::core::marker::Unpin,\n//!     {}\n//!     // Since we specified `PinnedDrop` as the argument to `#[pin_data]`, we expect `Foo` to\n//!     // implement `PinnedDrop`. Thus we do not need to prevent `Drop` implementations like\n//!     // before, instead we implement `Drop` here and delegate to `PinnedDrop`.\n//!     impl ::core::ops::Drop for Foo {\n//!         fn drop(&mut self) {\n//!             // Since we are getting dropped, no one else has a reference to `self` and thus we\n//!             // can assume that we never move.\n//!             let pinned = unsafe { ::core::pin::Pin::new_unchecked(self) };\n//!             // Create the unsafe token that proves that we are inside of a destructor, this\n//!             // type is only allowed to be created in a destructor.\n//!             let token = unsafe { ::kernel::init::__internal::OnlyCallFromDrop::new() };\n//!             ::kernel::init::PinnedDrop::drop(pinned, token);\n//!         }\n//!     }\n//! };\n//! ```\n//!\n//! ## `#[pinned_drop]` on `impl PinnedDrop for Foo`\n//!\n//! This macro is used to implement the `PinnedDrop` trait, since that trait is `unsafe` and has an\n//! extra parameter that should not be used at all. The macro hides that parameter.\n//!\n//! Here is the `PinnedDrop` impl for `Foo`:\n//!\n//! ```rust,ignore\n//! #[pinned_drop]\n//! impl PinnedDrop for Foo {\n//!     fn drop(self: Pin<&mut Self>) {\n//!         pr_info!(\"{self:p} is getting dropped.\");\n//!     }\n//! }\n//! ```\n//!\n//! This expands to the following code:\n//!\n//! ```rust,ignore\n//! // `unsafe`, full path and the token parameter are added, everything else stays the same.\n//! unsafe impl ::kernel::init::PinnedDrop for Foo {\n//!     fn drop(self: Pin<&mut Self>, _: ::kernel::init::__internal::OnlyCallFromDrop) {\n//!         pr_info!(\"{self:p} is getting dropped.\");\n//!     }\n//! }\n//! ```\n//!\n//! ## `pin_init!` on `Foo`\n//!\n//! Since we already took a look at `pin_init!` on `Bar`, this section will only show the expansion\n//! of `pin_init!` on `Foo`:\n//!\n//! ```rust,ignore\n//! let a = 42;\n//! let initializer = pin_init!(Foo {\n//!     a,\n//!     b <- Bar::new(36),\n//! });\n//! ```\n//!\n//! This expands to the following code:\n//!\n//! ```rust,ignore\n//! let a = 42;\n//! let initializer = {\n//!     struct __InitOk;\n//!     let data = unsafe {\n//!         use ::kernel::init::__internal::HasPinData;\n//!         Foo::__pin_data()\n//!     };\n//!     let init = ::kernel::init::__internal::PinData::make_closure::<\n//!         _,\n//!         __InitOk,\n//!         ::core::convert::Infallible,\n//!     >(data, move |slot| {\n//!         {\n//!             struct __InitOk;\n//!             {\n//!                 unsafe { ::core::ptr::write(::core::addr_of_mut!((*slot).a), a) };\n//!             }\n//!             let a = unsafe {\n//!                 ::kernel::init::__internal::DropGuard::new(::core::addr_of_mut!((*slot).a))\n//!             };\n//!             let init = Bar::new(36);\n//!             unsafe { data.b(::core::addr_of_mut!((*slot).b), b)? };\n//!             let b = unsafe {\n//!                 ::kernel::init::__internal::DropGuard::new(::core::addr_of_mut!((*slot).b))\n//!             };\n//!             ::core::mem::forget(b);\n//!             ::core::mem::forget(a);\n//!             #[allow(unreachable_code, clippy::diverging_sub_expression)]\n//!             let _ = || {\n//!                 unsafe {\n//!                     ::core::ptr::write(\n//!                         slot,\n//!                         Foo {\n//!                             a: ::core::panic!(),\n//!                             b: ::core::panic!(),\n//!                         },\n//!                     );\n//!                 };\n//!             };\n//!         }\n//!         Ok(__InitOk)\n//!     });\n//!     let init = move |\n//!         slot,\n//!     | -> ::core::result::Result<(), ::core::convert::Infallible> {\n//!         init(slot).map(|__InitOk| ())\n//!     };\n//!     let init = unsafe {\n//!         ::kernel::init::pin_init_from_closure::<_, ::core::convert::Infallible>(init)\n//!     };\n//!     init\n//! };\n//! ```\n\n/// Creates a `unsafe impl<...> PinnedDrop for $type` block.\n///\n/// See [`PinnedDrop`] for more information.\n#[doc(hidden)]\n#[macro_export]\nmacro_rules! __pinned_drop {\n    (\n        @impl_sig($($impl_sig:tt)*),\n        @impl_body(\n            $(#[$($attr:tt)*])*\n            fn drop($($sig:tt)*) {\n                $($inner:tt)*\n            }\n        ),\n    ) => {\n        unsafe $($impl_sig)* {\n            // Inherit all attributes and the type/ident tokens for the signature.\n            $(#[$($attr)*])*\n            fn drop($($sig)*, _: $crate::init::__internal::OnlyCallFromDrop) {\n                $($inner)*\n            }\n        }\n    }\n}\n\n/// This macro first parses the struct definition such that it separates pinned and not pinned\n/// fields. Afterwards it declares the struct and implement the `PinData` trait safely.\n#[doc(hidden)]\n#[macro_export]\nmacro_rules! __pin_data {\n    // Proc-macro entry point, this is supplied by the proc-macro pre-parsing.\n    (parse_input:\n        @args($($pinned_drop:ident)?),\n        @sig(\n            $(#[$($struct_attr:tt)*])*\n            $vis:vis struct $name:ident\n            $(where $($whr:tt)*)?\n        ),\n        @impl_generics($($impl_generics:tt)*),\n        @ty_generics($($ty_generics:tt)*),\n        @body({ $($fields:tt)* }),\n    ) => {\n        // We now use token munching to iterate through all of the fields. While doing this we\n        // identify fields marked with `#[pin]`, these fields are the 'pinned fields'. The user\n        // wants these to be structurally pinned. The rest of the fields are the\n        // 'not pinned fields'. Additionally we collect all fields, since we need them in the right\n        // order to declare the struct.\n        //\n        // In this call we also put some explaining comments for the parameters.\n        $crate::__pin_data!(find_pinned_fields:\n            // Attributes on the struct itself, these will just be propagated to be put onto the\n            // struct definition.\n            @struct_attrs($(#[$($struct_attr)*])*),\n            // The visibility of the struct.\n            @vis($vis),\n            // The name of the struct.\n            @name($name),\n            // The 'impl generics', the generics that will need to be specified on the struct inside\n            // of an `impl<$ty_generics>` block.\n            @impl_generics($($impl_generics)*),\n            // The 'ty generics', the generics that will need to be specified on the impl blocks.\n            @ty_generics($($ty_generics)*),\n            // The where clause of any impl block and the declaration.\n            @where($($($whr)*)?),\n            // The remaining fields tokens that need to be processed.\n            // We add a `,` at the end to ensure correct parsing.\n            @fields_munch($($fields)* ,),\n            // The pinned fields.\n            @pinned(),\n            // The not pinned fields.\n            @not_pinned(),\n            // All fields.\n            @fields(),\n            // The accumulator containing all attributes already parsed.\n            @accum(),\n            // Contains `yes` or `` to indicate if `#[pin]` was found on the current field.\n            @is_pinned(),\n            // The proc-macro argument, this should be `PinnedDrop` or ``.\n            @pinned_drop($($pinned_drop)?),\n        );\n    };\n    (find_pinned_fields:\n        @struct_attrs($($struct_attrs:tt)*),\n        @vis($vis:vis),\n        @name($name:ident),\n        @impl_generics($($impl_generics:tt)*),\n        @ty_generics($($ty_generics:tt)*),\n        @where($($whr:tt)*),\n        // We found a PhantomPinned field, this should generally be pinned!\n        @fields_munch($field:ident : $($($(::)?core::)?marker::)?PhantomPinned, $($rest:tt)*),\n        @pinned($($pinned:tt)*),\n        @not_pinned($($not_pinned:tt)*),\n        @fields($($fields:tt)*),\n        @accum($($accum:tt)*),\n        // This field is not pinned.\n        @is_pinned(),\n        @pinned_drop($($pinned_drop:ident)?),\n    ) => {\n        ::core::compile_error!(concat!(\n            \"The field `\",\n            stringify!($field),\n            \"` of type `PhantomPinned` only has an effect, if it has the `#[pin]` attribute.\",\n        ));\n        $crate::__pin_data!(find_pinned_fields:\n            @struct_attrs($($struct_attrs)*),\n            @vis($vis),\n            @name($name),\n            @impl_generics($($impl_generics)*),\n            @ty_generics($($ty_generics)*),\n            @where($($whr)*),\n            @fields_munch($($rest)*),\n            @pinned($($pinned)* $($accum)* $field: ::core::marker::PhantomPinned,),\n            @not_pinned($($not_pinned)*),\n            @fields($($fields)* $($accum)* $field: ::core::marker::PhantomPinned,),\n            @accum(),\n            @is_pinned(),\n            @pinned_drop($($pinned_drop)?),\n        );\n    };\n    (find_pinned_fields:\n        @struct_attrs($($struct_attrs:tt)*),\n        @vis($vis:vis),\n        @name($name:ident),\n        @impl_generics($($impl_generics:tt)*),\n        @ty_generics($($ty_generics:tt)*),\n        @where($($whr:tt)*),\n        // We reached the field declaration.\n        @fields_munch($field:ident : $type:ty, $($rest:tt)*),\n        @pinned($($pinned:tt)*),\n        @not_pinned($($not_pinned:tt)*),\n        @fields($($fields:tt)*),\n        @accum($($accum:tt)*),\n        // This field is pinned.\n        @is_pinned(yes),\n        @pinned_drop($($pinned_drop:ident)?),\n    ) => {\n        $crate::__pin_data!(find_pinned_fields:\n            @struct_attrs($($struct_attrs)*),\n            @vis($vis),\n            @name($name),\n            @impl_generics($($impl_generics)*),\n            @ty_generics($($ty_generics)*),\n            @where($($whr)*),\n            @fields_munch($($rest)*),\n            @pinned($($pinned)* $($accum)* $field: $type,),\n            @not_pinned($($not_pinned)*),\n            @fields($($fields)* $($accum)* $field: $type,),\n            @accum(),\n            @is_pinned(),\n            @pinned_drop($($pinned_drop)?),\n        );\n    };\n    (find_pinned_fields:\n        @struct_attrs($($struct_attrs:tt)*),\n        @vis($vis:vis),\n        @name($name:ident),\n        @impl_generics($($impl_generics:tt)*),\n        @ty_generics($($ty_generics:tt)*),\n        @where($($whr:tt)*),\n        // We reached the field declaration.\n        @fields_munch($field:ident : $type:ty, $($rest:tt)*),\n        @pinned($($pinned:tt)*),\n        @not_pinned($($not_pinned:tt)*),\n        @fields($($fields:tt)*),\n        @accum($($accum:tt)*),\n        // This field is not pinned.\n        @is_pinned(),\n        @pinned_drop($($pinned_drop:ident)?),\n    ) => {\n        $crate::__pin_data!(find_pinned_fields:\n            @struct_attrs($($struct_attrs)*),\n            @vis($vis),\n            @name($name),\n            @impl_generics($($impl_generics)*),\n            @ty_generics($($ty_generics)*),\n            @where($($whr)*),\n            @fields_munch($($rest)*),\n            @pinned($($pinned)*),\n            @not_pinned($($not_pinned)* $($accum)* $field: $type,),\n            @fields($($fields)* $($accum)* $field: $type,),\n            @accum(),\n            @is_pinned(),\n            @pinned_drop($($pinned_drop)?),\n        );\n    };\n    (find_pinned_fields:\n        @struct_attrs($($struct_attrs:tt)*),\n        @vis($vis:vis),\n        @name($name:ident),\n        @impl_generics($($impl_generics:tt)*),\n        @ty_generics($($ty_generics:tt)*),\n        @where($($whr:tt)*),\n        // We found the `#[pin]` attr.\n        @fields_munch(#[pin] $($rest:tt)*),\n        @pinned($($pinned:tt)*),\n        @not_pinned($($not_pinned:tt)*),\n        @fields($($fields:tt)*),\n        @accum($($accum:tt)*),\n        @is_pinned($($is_pinned:ident)?),\n        @pinned_drop($($pinned_drop:ident)?),\n    ) => {\n        $crate::__pin_data!(find_pinned_fields:\n            @struct_attrs($($struct_attrs)*),\n            @vis($vis),\n            @name($name),\n            @impl_generics($($impl_generics)*),\n            @ty_generics($($ty_generics)*),\n            @where($($whr)*),\n            @fields_munch($($rest)*),\n            // We do not include `#[pin]` in the list of attributes, since it is not actually an\n            // attribute that is defined somewhere.\n            @pinned($($pinned)*),\n            @not_pinned($($not_pinned)*),\n            @fields($($fields)*),\n            @accum($($accum)*),\n            // Set this to `yes`.\n            @is_pinned(yes),\n            @pinned_drop($($pinned_drop)?),\n        );\n    };\n    (find_pinned_fields:\n        @struct_attrs($($struct_attrs:tt)*),\n        @vis($vis:vis),\n        @name($name:ident),\n        @impl_generics($($impl_generics:tt)*),\n        @ty_generics($($ty_generics:tt)*),\n        @where($($whr:tt)*),\n        // We reached the field declaration with visibility, for simplicity we only munch the\n        // visibility and put it into `$accum`.\n        @fields_munch($fvis:vis $field:ident $($rest:tt)*),\n        @pinned($($pinned:tt)*),\n        @not_pinned($($not_pinned:tt)*),\n        @fields($($fields:tt)*),\n        @accum($($accum:tt)*),\n        @is_pinned($($is_pinned:ident)?),\n        @pinned_drop($($pinned_drop:ident)?),\n    ) => {\n        $crate::__pin_data!(find_pinned_fields:\n            @struct_attrs($($struct_attrs)*),\n            @vis($vis),\n            @name($name),\n            @impl_generics($($impl_generics)*),\n            @ty_generics($($ty_generics)*),\n            @where($($whr)*),\n            @fields_munch($field $($rest)*),\n            @pinned($($pinned)*),\n            @not_pinned($($not_pinned)*),\n            @fields($($fields)*),\n            @accum($($accum)* $fvis),\n            @is_pinned($($is_pinned)?),\n            @pinned_drop($($pinned_drop)?),\n        );\n    };\n    (find_pinned_fields:\n        @struct_attrs($($struct_attrs:tt)*),\n        @vis($vis:vis),\n        @name($name:ident),\n        @impl_generics($($impl_generics:tt)*),\n        @ty_generics($($ty_generics:tt)*),\n        @where($($whr:tt)*),\n        // Some other attribute, just put it into `$accum`.\n        @fields_munch(#[$($attr:tt)*] $($rest:tt)*),\n        @pinned($($pinned:tt)*),\n        @not_pinned($($not_pinned:tt)*),\n        @fields($($fields:tt)*),\n        @accum($($accum:tt)*),\n        @is_pinned($($is_pinned:ident)?),\n        @pinned_drop($($pinned_drop:ident)?),\n    ) => {\n        $crate::__pin_data!(find_pinned_fields:\n            @struct_attrs($($struct_attrs)*),\n            @vis($vis),\n            @name($name),\n            @impl_generics($($impl_generics)*),\n            @ty_generics($($ty_generics)*),\n            @where($($whr)*),\n            @fields_munch($($rest)*),\n            @pinned($($pinned)*),\n            @not_pinned($($not_pinned)*),\n            @fields($($fields)*),\n            @accum($($accum)* #[$($attr)*]),\n            @is_pinned($($is_pinned)?),\n            @pinned_drop($($pinned_drop)?),\n        );\n    };\n    (find_pinned_fields:\n        @struct_attrs($($struct_attrs:tt)*),\n        @vis($vis:vis),\n        @name($name:ident),\n        @impl_generics($($impl_generics:tt)*),\n        @ty_generics($($ty_generics:tt)*),\n        @where($($whr:tt)*),\n        // We reached the end of the fields, plus an optional additional comma, since we added one\n        // before and the user is also allowed to put a trailing comma.\n        @fields_munch($(,)?),\n        @pinned($($pinned:tt)*),\n        @not_pinned($($not_pinned:tt)*),\n        @fields($($fields:tt)*),\n        @accum(),\n        @is_pinned(),\n        @pinned_drop($($pinned_drop:ident)?),\n    ) => {\n        // Declare the struct with all fields in the correct order.\n        $($struct_attrs)*\n        $vis struct $name <$($impl_generics)*>\n        where $($whr)*\n        {\n            $($fields)*\n        }\n\n        // We put the rest into this const item, because it then will not be accessible to anything\n        // outside.\n        const _: () = {\n            // We declare this struct which will host all of the projection function for our type.\n            // it will be invariant over all generic parameters which are inherited from the\n            // struct.\n            $vis struct __ThePinData<$($impl_generics)*>\n            where $($whr)*\n            {\n                __phantom: ::core::marker::PhantomData<\n                    fn($name<$($ty_generics)*>) -> $name<$($ty_generics)*>\n                >,\n            }\n\n            impl<$($impl_generics)*> ::core::clone::Clone for __ThePinData<$($ty_generics)*>\n            where $($whr)*\n            {\n                fn clone(&self) -> Self { *self }\n            }\n\n            impl<$($impl_generics)*> ::core::marker::Copy for __ThePinData<$($ty_generics)*>\n            where $($whr)*\n            {}\n\n            // Make all projection functions.\n            $crate::__pin_data!(make_pin_data:\n                @pin_data(__ThePinData),\n                @impl_generics($($impl_generics)*),\n                @ty_generics($($ty_generics)*),\n                @where($($whr)*),\n                @pinned($($pinned)*),\n                @not_pinned($($not_pinned)*),\n            );\n\n            // SAFETY: We have added the correct projection functions above to `__ThePinData` and\n            // we also use the least restrictive generics possible.\n            unsafe impl<$($impl_generics)*>\n                $crate::init::__internal::HasPinData for $name<$($ty_generics)*>\n            where $($whr)*\n            {\n                type PinData = __ThePinData<$($ty_generics)*>;\n\n                unsafe fn __pin_data() -> Self::PinData {\n                    __ThePinData { __phantom: ::core::marker::PhantomData }\n                }\n            }\n\n            unsafe impl<$($impl_generics)*>\n                $crate::init::__internal::PinData for __ThePinData<$($ty_generics)*>\n            where $($whr)*\n            {\n                type Datee = $name<$($ty_generics)*>;\n            }\n\n            // This struct will be used for the unpin analysis. Since only structurally pinned\n            // fields are relevant whether the struct should implement `Unpin`.\n            #[allow(dead_code)]\n            struct __Unpin <'__pin, $($impl_generics)*>\n            where $($whr)*\n            {\n                __phantom_pin: ::core::marker::PhantomData<fn(&'__pin ()) -> &'__pin ()>,\n                __phantom: ::core::marker::PhantomData<\n                    fn($name<$($ty_generics)*>) -> $name<$($ty_generics)*>\n                >,\n                // Only the pinned fields.\n                $($pinned)*\n            }\n\n            #[doc(hidden)]\n            impl<'__pin, $($impl_generics)*> ::core::marker::Unpin for $name<$($ty_generics)*>\n            where\n                __Unpin<'__pin, $($ty_generics)*>: ::core::marker::Unpin,\n                $($whr)*\n            {}\n\n            // We need to disallow normal `Drop` implementation, the exact behavior depends on\n            // whether `PinnedDrop` was specified as the parameter.\n            $crate::__pin_data!(drop_prevention:\n                @name($name),\n                @impl_generics($($impl_generics)*),\n                @ty_generics($($ty_generics)*),\n                @where($($whr)*),\n                @pinned_drop($($pinned_drop)?),\n            );\n        };\n    };\n    // When no `PinnedDrop` was specified, then we have to prevent implementing drop.\n    (drop_prevention:\n        @name($name:ident),\n        @impl_generics($($impl_generics:tt)*),\n        @ty_generics($($ty_generics:tt)*),\n        @where($($whr:tt)*),\n        @pinned_drop(),\n    ) => {\n        // We prevent this by creating a trait that will be implemented for all types implementing\n        // `Drop`. Additionally we will implement this trait for the struct leading to a conflict,\n        // if it also implements `Drop`\n        trait MustNotImplDrop {}\n        #[allow(drop_bounds)]\n        impl<T: ::core::ops::Drop> MustNotImplDrop for T {}\n        impl<$($impl_generics)*> MustNotImplDrop for $name<$($ty_generics)*>\n        where $($whr)* {}\n        // We also take care to prevent users from writing a useless `PinnedDrop` implementation.\n        // They might implement `PinnedDrop` correctly for the struct, but forget to give\n        // `PinnedDrop` as the parameter to `#[pin_data]`.\n        #[allow(non_camel_case_types)]\n        trait UselessPinnedDropImpl_you_need_to_specify_PinnedDrop {}\n        impl<T: $crate::init::PinnedDrop>\n            UselessPinnedDropImpl_you_need_to_specify_PinnedDrop for T {}\n        impl<$($impl_generics)*>\n            UselessPinnedDropImpl_you_need_to_specify_PinnedDrop for $name<$($ty_generics)*>\n        where $($whr)* {}\n    };\n    // When `PinnedDrop` was specified we just implement `Drop` and delegate.\n    (drop_prevention:\n        @name($name:ident),\n        @impl_generics($($impl_generics:tt)*),\n        @ty_generics($($ty_generics:tt)*),\n        @where($($whr:tt)*),\n        @pinned_drop(PinnedDrop),\n    ) => {\n        impl<$($impl_generics)*> ::core::ops::Drop for $name<$($ty_generics)*>\n        where $($whr)*\n        {\n            fn drop(&mut self) {\n                // SAFETY: Since this is a destructor, `self` will not move after this function\n                // terminates, since it is inaccessible.\n                let pinned = unsafe { ::core::pin::Pin::new_unchecked(self) };\n                // SAFETY: Since this is a drop function, we can create this token to call the\n                // pinned destructor of this type.\n                let token = unsafe { $crate::init::__internal::OnlyCallFromDrop::new() };\n                $crate::init::PinnedDrop::drop(pinned, token);\n            }\n        }\n    };\n    // If some other parameter was specified, we emit a readable error.\n    (drop_prevention:\n        @name($name:ident),\n        @impl_generics($($impl_generics:tt)*),\n        @ty_generics($($ty_generics:tt)*),\n        @where($($whr:tt)*),\n        @pinned_drop($($rest:tt)*),\n    ) => {\n        compile_error!(\n            \"Wrong parameters to `#[pin_data]`, expected nothing or `PinnedDrop`, got '{}'.\",\n            stringify!($($rest)*),\n        );\n    };\n    (make_pin_data:\n        @pin_data($pin_data:ident),\n        @impl_generics($($impl_generics:tt)*),\n        @ty_generics($($ty_generics:tt)*),\n        @where($($whr:tt)*),\n        @pinned($($(#[$($p_attr:tt)*])* $pvis:vis $p_field:ident : $p_type:ty),* $(,)?),\n        @not_pinned($($(#[$($attr:tt)*])* $fvis:vis $field:ident : $type:ty),* $(,)?),\n    ) => {\n        // For every field, we create a projection function according to its projection type. If a\n        // field is structurally pinned, then it must be initialized via `PinInit`, if it is not\n        // structurally pinned, then it can be initialized via `Init`.\n        //\n        // The functions are `unsafe` to prevent accidentally calling them.\n        #[allow(dead_code)]\n        impl<$($impl_generics)*> $pin_data<$($ty_generics)*>\n        where $($whr)*\n        {\n            $(\n                $(#[$($p_attr)*])*\n                $pvis unsafe fn $p_field<E>(\n                    self,\n                    slot: *mut $p_type,\n                    init: impl $crate::init::PinInit<$p_type, E>,\n                ) -> ::core::result::Result<(), E> {\n                    unsafe { $crate::init::PinInit::__pinned_init(init, slot) }\n                }\n            )*\n            $(\n                $(#[$($attr)*])*\n                $fvis unsafe fn $field<E>(\n                    self,\n                    slot: *mut $type,\n                    init: impl $crate::init::Init<$type, E>,\n                ) -> ::core::result::Result<(), E> {\n                    unsafe { $crate::init::Init::__init(init, slot) }\n                }\n            )*\n        }\n    };\n}\n\n/// The internal init macro. Do not call manually!\n///\n/// This is called by the `{try_}{pin_}init!` macros with various inputs.\n///\n/// This macro has multiple internal call configurations, these are always the very first ident:\n/// - nothing: this is the base case and called by the `{try_}{pin_}init!` macros.\n/// - `with_update_parsed`: when the `..Zeroable::zeroed()` syntax has been handled.\n/// - `init_slot`: recursively creates the code that initializes all fields in `slot`.\n/// - `make_initializer`: recursively create the struct initializer that guarantees that every\n///   field has been initialized exactly once.\n#[doc(hidden)]\n#[macro_export]\nmacro_rules! __init_internal {\n    (\n        @this($($this:ident)?),\n        @typ($t:path),\n        @fields($($fields:tt)*),\n        @error($err:ty),\n        // Either `PinData` or `InitData`, `$use_data` should only be present in the `PinData`\n        // case.\n        @data($data:ident, $($use_data:ident)?),\n        // `HasPinData` or `HasInitData`.\n        @has_data($has_data:ident, $get_data:ident),\n        // `pin_init_from_closure` or `init_from_closure`.\n        @construct_closure($construct_closure:ident),\n        @munch_fields(),\n    ) => {\n        $crate::__init_internal!(with_update_parsed:\n            @this($($this)?),\n            @typ($t),\n            @fields($($fields)*),\n            @error($err),\n            @data($data, $($use_data)?),\n            @has_data($has_data, $get_data),\n            @construct_closure($construct_closure),\n            @zeroed(), // Nothing means default behavior.\n        )\n    };\n    (\n        @this($($this:ident)?),\n        @typ($t:path),\n        @fields($($fields:tt)*),\n        @error($err:ty),\n        // Either `PinData` or `InitData`, `$use_data` should only be present in the `PinData`\n        // case.\n        @data($data:ident, $($use_data:ident)?),\n        // `HasPinData` or `HasInitData`.\n        @has_data($has_data:ident, $get_data:ident),\n        // `pin_init_from_closure` or `init_from_closure`.\n        @construct_closure($construct_closure:ident),\n        @munch_fields(..Zeroable::zeroed()),\n    ) => {\n        $crate::__init_internal!(with_update_parsed:\n            @this($($this)?),\n            @typ($t),\n            @fields($($fields)*),\n            @error($err),\n            @data($data, $($use_data)?),\n            @has_data($has_data, $get_data),\n            @construct_closure($construct_closure),\n            @zeroed(()), // `()` means zero all fields not mentioned.\n        )\n    };\n    (\n        @this($($this:ident)?),\n        @typ($t:path),\n        @fields($($fields:tt)*),\n        @error($err:ty),\n        // Either `PinData` or `InitData`, `$use_data` should only be present in the `PinData`\n        // case.\n        @data($data:ident, $($use_data:ident)?),\n        // `HasPinData` or `HasInitData`.\n        @has_data($has_data:ident, $get_data:ident),\n        // `pin_init_from_closure` or `init_from_closure`.\n        @construct_closure($construct_closure:ident),\n        @munch_fields($ignore:tt $($rest:tt)*),\n    ) => {\n        $crate::__init_internal!(\n            @this($($this)?),\n            @typ($t),\n            @fields($($fields)*),\n            @error($err),\n            @data($data, $($use_data)?),\n            @has_data($has_data, $get_data),\n            @construct_closure($construct_closure),\n            @munch_fields($($rest)*),\n        )\n    };\n    (with_update_parsed:\n        @this($($this:ident)?),\n        @typ($t:path),\n        @fields($($fields:tt)*),\n        @error($err:ty),\n        // Either `PinData` or `InitData`, `$use_data` should only be present in the `PinData`\n        // case.\n        @data($data:ident, $($use_data:ident)?),\n        // `HasPinData` or `HasInitData`.\n        @has_data($has_data:ident, $get_data:ident),\n        // `pin_init_from_closure` or `init_from_closure`.\n        @construct_closure($construct_closure:ident),\n        @zeroed($($init_zeroed:expr)?),\n    ) => {{\n        // We do not want to allow arbitrary returns, so we declare this type as the `Ok` return\n        // type and shadow it later when we insert the arbitrary user code. That way there will be\n        // no possibility of returning without `unsafe`.\n        struct __InitOk;\n        // Get the data about fields from the supplied type.\n        let data = unsafe {\n            use $crate::init::__internal::$has_data;\n            // Here we abuse `paste!` to retokenize `$t`. Declarative macros have some internal\n            // information that is associated to already parsed fragments, so a path fragment\n            // cannot be used in this position. Doing the retokenization results in valid rust\n            // code.\n            ::kernel::macros::paste!($t::$get_data())\n        };\n        // Ensure that `data` really is of type `$data` and help with type inference:\n        let init = $crate::init::__internal::$data::make_closure::<_, __InitOk, $err>(\n            data,\n            move |slot| {\n                {\n                    // Shadow the structure so it cannot be used to return early.\n                    struct __InitOk;\n                    // If `$init_zeroed` is present we should zero the slot now and not emit an\n                    // error when fields are missing (since they will be zeroed). We also have to\n                    // check that the type actually implements `Zeroable`.\n                    $({\n                        fn assert_zeroable<T: $crate::init::Zeroable>(_: *mut T) {}\n                        // Ensure that the struct is indeed `Zeroable`.\n                        assert_zeroable(slot);\n                        // SAFETY: The type implements `Zeroable` by the check above.\n                        unsafe { ::core::ptr::write_bytes(slot, 0, 1) };\n                        $init_zeroed // This will be `()` if set.\n                    })?\n                    // Create the `this` so it can be referenced by the user inside of the\n                    // expressions creating the individual fields.\n                    $(let $this = unsafe { ::core::ptr::NonNull::new_unchecked(slot) };)?\n                    // Initialize every field.\n                    $crate::__init_internal!(init_slot($($use_data)?):\n                        @data(data),\n                        @slot(slot),\n                        @guards(),\n                        @munch_fields($($fields)*,),\n                    );\n                    // We use unreachable code to ensure that all fields have been mentioned exactly\n                    // once, this struct initializer will still be type-checked and complain with a\n                    // very natural error message if a field is forgotten/mentioned more than once.\n                    #[allow(unreachable_code, clippy::diverging_sub_expression)]\n                    let _ = || {\n                        $crate::__init_internal!(make_initializer:\n                            @slot(slot),\n                            @type_name($t),\n                            @munch_fields($($fields)*,),\n                            @acc(),\n                        );\n                    };\n                }\n                Ok(__InitOk)\n            }\n        );\n        let init = move |slot| -> ::core::result::Result<(), $err> {\n            init(slot).map(|__InitOk| ())\n        };\n        let init = unsafe { $crate::init::$construct_closure::<_, $err>(init) };\n        init\n    }};\n    (init_slot($($use_data:ident)?):\n        @data($data:ident),\n        @slot($slot:ident),\n        @guards($($guards:ident,)*),\n        @munch_fields($(..Zeroable::zeroed())? $(,)?),\n    ) => {\n        // Endpoint of munching, no fields are left. If execution reaches this point, all fields\n        // have been initialized. Therefore we can now dismiss the guards by forgetting them.\n        $(::core::mem::forget($guards);)*\n    };\n    (init_slot($use_data:ident): // `use_data` is present, so we use the `data` to init fields.\n        @data($data:ident),\n        @slot($slot:ident),\n        @guards($($guards:ident,)*),\n        // In-place initialization syntax.\n        @munch_fields($field:ident <- $val:expr, $($rest:tt)*),\n    ) => {\n        let init = $val;\n        // Call the initializer.\n        //\n        // SAFETY: `slot` is valid, because we are inside of an initializer closure, we\n        // return when an error/panic occurs.\n        // We also use the `data` to require the correct trait (`Init` or `PinInit`) for `$field`.\n        unsafe { $data.$field(::core::ptr::addr_of_mut!((*$slot).$field), init)? };\n        // Create the drop guard:\n        //\n        // We rely on macro hygiene to make it impossible for users to access this local variable.\n        // We use `paste!` to create new hygiene for `$field`.\n        ::kernel::macros::paste! {\n            // SAFETY: We forget the guard later when initialization has succeeded.\n            let [<$field>] = unsafe {\n                $crate::init::__internal::DropGuard::new(::core::ptr::addr_of_mut!((*$slot).$field))\n            };\n\n            $crate::__init_internal!(init_slot($use_data):\n                @data($data),\n                @slot($slot),\n                @guards([<$field>], $($guards,)*),\n                @munch_fields($($rest)*),\n            );\n        }\n    };\n    (init_slot(): // No `use_data`, so we use `Init::__init` directly.\n        @data($data:ident),\n        @slot($slot:ident),\n        @guards($($guards:ident,)*),\n        // In-place initialization syntax.\n        @munch_fields($field:ident <- $val:expr, $($rest:tt)*),\n    ) => {\n        let init = $val;\n        // Call the initializer.\n        //\n        // SAFETY: `slot` is valid, because we are inside of an initializer closure, we\n        // return when an error/panic occurs.\n        unsafe { $crate::init::Init::__init(init, ::core::ptr::addr_of_mut!((*$slot).$field))? };\n        // Create the drop guard:\n        //\n        // We rely on macro hygiene to make it impossible for users to access this local variable.\n        // We use `paste!` to create new hygiene for `$field`.\n        ::kernel::macros::paste! {\n            // SAFETY: We forget the guard later when initialization has succeeded.\n            let [<$field>] = unsafe {\n                $crate::init::__internal::DropGuard::new(::core::ptr::addr_of_mut!((*$slot).$field))\n            };\n\n            $crate::__init_internal!(init_slot():\n                @data($data),\n                @slot($slot),\n                @guards([<$field>], $($guards,)*),\n                @munch_fields($($rest)*),\n            );\n        }\n    };\n    (init_slot($($use_data:ident)?):\n        @data($data:ident),\n        @slot($slot:ident),\n        @guards($($guards:ident,)*),\n        // Init by-value.\n        @munch_fields($field:ident $(: $val:expr)?, $($rest:tt)*),\n    ) => {\n        {\n            $(let $field = $val;)?\n            // Initialize the field.\n            //\n            // SAFETY: The memory at `slot` is uninitialized.\n            unsafe { ::core::ptr::write(::core::ptr::addr_of_mut!((*$slot).$field), $field) };\n        }\n        // Create the drop guard:\n        //\n        // We rely on macro hygiene to make it impossible for users to access this local variable.\n        // We use `paste!` to create new hygiene for `$field`.\n        ::kernel::macros::paste! {\n            // SAFETY: We forget the guard later when initialization has succeeded.\n            let [<$field>] = unsafe {\n                $crate::init::__internal::DropGuard::new(::core::ptr::addr_of_mut!((*$slot).$field))\n            };\n\n            $crate::__init_internal!(init_slot($($use_data)?):\n                @data($data),\n                @slot($slot),\n                @guards([<$field>], $($guards,)*),\n                @munch_fields($($rest)*),\n            );\n        }\n    };\n    (make_initializer:\n        @slot($slot:ident),\n        @type_name($t:path),\n        @munch_fields(..Zeroable::zeroed() $(,)?),\n        @acc($($acc:tt)*),\n    ) => {\n        // Endpoint, nothing more to munch, create the initializer. Since the users specified\n        // `..Zeroable::zeroed()`, the slot will already have been zeroed and all field that have\n        // not been overwritten are thus zero and initialized. We still check that all fields are\n        // actually accessible by using the struct update syntax ourselves.\n        // We are inside of a closure that is never executed and thus we can abuse `slot` to\n        // get the correct type inference here:\n        #[allow(unused_assignments)]\n        unsafe {\n            let mut zeroed = ::core::mem::zeroed();\n            // We have to use type inference here to make zeroed have the correct type. This does\n            // not get executed, so it has no effect.\n            ::core::ptr::write($slot, zeroed);\n            zeroed = ::core::mem::zeroed();\n            // Here we abuse `paste!` to retokenize `$t`. Declarative macros have some internal\n            // information that is associated to already parsed fragments, so a path fragment\n            // cannot be used in this position. Doing the retokenization results in valid rust\n            // code.\n            ::kernel::macros::paste!(\n                ::core::ptr::write($slot, $t {\n                    $($acc)*\n                    ..zeroed\n                });\n            );\n        }\n    };\n    (make_initializer:\n        @slot($slot:ident),\n        @type_name($t:path),\n        @munch_fields($(,)?),\n        @acc($($acc:tt)*),\n    ) => {\n        // Endpoint, nothing more to munch, create the initializer.\n        // Since we are in the closure that is never called, this will never get executed.\n        // We abuse `slot` to get the correct type inference here:\n        unsafe {\n            // Here we abuse `paste!` to retokenize `$t`. Declarative macros have some internal\n            // information that is associated to already parsed fragments, so a path fragment\n            // cannot be used in this position. Doing the retokenization results in valid rust\n            // code.\n            ::kernel::macros::paste!(\n                ::core::ptr::write($slot, $t {\n                    $($acc)*\n                });\n            );\n        }\n    };\n    (make_initializer:\n        @slot($slot:ident),\n        @type_name($t:path),\n        @munch_fields($field:ident <- $val:expr, $($rest:tt)*),\n        @acc($($acc:tt)*),\n    ) => {\n        $crate::__init_internal!(make_initializer:\n            @slot($slot),\n            @type_name($t),\n            @munch_fields($($rest)*),\n            @acc($($acc)* $field: ::core::panic!(),),\n        );\n    };\n    (make_initializer:\n        @slot($slot:ident),\n        @type_name($t:path),\n        @munch_fields($field:ident $(: $val:expr)?, $($rest:tt)*),\n        @acc($($acc:tt)*),\n    ) => {\n        $crate::__init_internal!(make_initializer:\n            @slot($slot),\n            @type_name($t),\n            @munch_fields($($rest)*),\n            @acc($($acc)* $field: ::core::panic!(),),\n        );\n    };\n}\n\n#[doc(hidden)]\n#[macro_export]\nmacro_rules! __derive_zeroable {\n    (parse_input:\n        @sig(\n            $(#[$($struct_attr:tt)*])*\n            $vis:vis struct $name:ident\n            $(where $($whr:tt)*)?\n        ),\n        @impl_generics($($impl_generics:tt)*),\n        @ty_generics($($ty_generics:tt)*),\n        @body({\n            $(\n                $(#[$($field_attr:tt)*])*\n                $field:ident : $field_ty:ty\n            ),* $(,)?\n        }),\n    ) => {\n        // SAFETY: Every field type implements `Zeroable` and padding bytes may be zero.\n        #[automatically_derived]\n        unsafe impl<$($impl_generics)*> $crate::init::Zeroable for $name<$($ty_generics)*>\n        where\n            $($($whr)*)?\n        {}\n        const _: () = {\n            fn assert_zeroable<T: ?::core::marker::Sized + $crate::init::Zeroable>() {}\n            fn ensure_zeroable<$($impl_generics)*>()\n                where $($($whr)*)?\n            {\n                $(assert_zeroable::<$field_ty>();)*\n            }\n        };\n    };\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}