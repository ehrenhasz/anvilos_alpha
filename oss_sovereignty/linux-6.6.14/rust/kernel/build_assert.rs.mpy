{
  "module_name": "build_assert.rs",
  "hash_id": "9990b4a83d2f20aaf269fa0dbb908ed95da20c69983d7e9317148cca90050ad9",
  "original_prompt": "Ingested from linux-6.6.14/rust/kernel/build_assert.rs",
  "human_readable_source": "// SPDX-License-Identifier: GPL-2.0\n\n//! Build-time assert.\n\n/// Fails the build if the code path calling `build_error!` can possibly be executed.\n///\n/// If the macro is executed in const context, `build_error!` will panic.\n/// If the compiler or optimizer cannot guarantee that `build_error!` can never\n/// be called, a build error will be triggered.\n///\n/// # Examples\n///\n/// ```\n/// # use kernel::build_error;\n/// #[inline]\n/// fn foo(a: usize) -> usize {\n///     a.checked_add(1).unwrap_or_else(|| build_error!(\"overflow\"))\n/// }\n///\n/// assert_eq!(foo(usize::MAX - 1), usize::MAX); // OK.\n/// // foo(usize::MAX); // Fails to compile.\n/// ```\n#[macro_export]\nmacro_rules! build_error {\n    () => {{\n        $crate::build_error(\"\")\n    }};\n    ($msg:expr) => {{\n        $crate::build_error($msg)\n    }};\n}\n\n/// Asserts that a boolean expression is `true` at compile time.\n///\n/// If the condition is evaluated to `false` in const context, `build_assert!`\n/// will panic. If the compiler or optimizer cannot guarantee the condition will\n/// be evaluated to `true`, a build error will be triggered.\n///\n/// [`static_assert!`] should be preferred to `build_assert!` whenever possible.\n///\n/// # Examples\n///\n/// These examples show that different types of [`assert!`] will trigger errors\n/// at different stage of compilation. It is preferred to err as early as\n/// possible, so [`static_assert!`] should be used whenever possible.\n/// ```ignore\n/// fn foo() {\n///     static_assert!(1 > 1); // Compile-time error\n///     build_assert!(1 > 1); // Build-time error\n///     assert!(1 > 1); // Run-time error\n/// }\n/// ```\n///\n/// When the condition refers to generic parameters or parameters of an inline function,\n/// [`static_assert!`] cannot be used. Use `build_assert!` in this scenario.\n/// ```\n/// fn foo<const N: usize>() {\n///     // `static_assert!(N > 1);` is not allowed\n///     build_assert!(N > 1); // Build-time check\n///     assert!(N > 1); // Run-time check\n/// }\n///\n/// #[inline]\n/// fn bar(n: usize) {\n///     // `static_assert!(n > 1);` is not allowed\n///     build_assert!(n > 1); // Build-time check\n///     assert!(n > 1); // Run-time check\n/// }\n/// ```\n///\n/// [`static_assert!`]: crate::static_assert!\n#[macro_export]\nmacro_rules! build_assert {\n    ($cond:expr $(,)?) => {{\n        if !$cond {\n            $crate::build_error(concat!(\"assertion failed: \", stringify!($cond)));\n        }\n    }};\n    ($cond:expr, $msg:expr) => {{\n        if !$cond {\n            $crate::build_error($msg);\n        }\n    }};\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}