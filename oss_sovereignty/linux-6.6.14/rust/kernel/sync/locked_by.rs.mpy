{
  "module_name": "locked_by.rs",
  "hash_id": "d39a5be18f14ac55f08dbffdc15148a14587b63a61ff8302bd3cc1ec6fa7103d",
  "original_prompt": "Ingested from linux-6.6.14/rust/kernel/sync/locked_by.rs",
  "human_readable_source": "// SPDX-License-Identifier: GPL-2.0\n\n//! A wrapper for data protected by a lock that does not wrap it.\n\nuse super::{lock::Backend, lock::Lock};\nuse crate::build_assert;\nuse core::{cell::UnsafeCell, mem::size_of, ptr};\n\n/// Allows access to some data to be serialised by a lock that does not wrap it.\n///\n/// In most cases, data protected by a lock is wrapped by the appropriate lock type, e.g.,\n/// [`super::Mutex`] or [`super::SpinLock`]. [`LockedBy`] is meant for cases when this is not\n/// possible. For example, if a container has a lock and some data in the contained elements needs\n/// to be protected by the same lock.\n///\n/// [`LockedBy`] wraps the data in lieu of another locking primitive, and only allows access to it\n/// when the caller shows evidence that the 'external' lock is locked. It panics if the evidence\n/// refers to the wrong instance of the lock.\n///\n/// # Examples\n///\n/// The following is an example for illustrative purposes: `InnerDirectory::bytes_used` is an\n/// aggregate of all `InnerFile::bytes_used` and must be kept consistent; so we wrap `InnerFile` in\n/// a `LockedBy` so that it shares a lock with `InnerDirectory`. This allows us to enforce at\n/// compile-time that access to `InnerFile` is only granted when an `InnerDirectory` is also\n/// locked; we enforce at run time that the right `InnerDirectory` is locked.\n///\n/// ```\n/// use kernel::sync::{LockedBy, Mutex};\n///\n/// struct InnerFile {\n///     bytes_used: u64,\n/// }\n///\n/// struct File {\n///     _ino: u32,\n///     inner: LockedBy<InnerFile, InnerDirectory>,\n/// }\n///\n/// struct InnerDirectory {\n///     /// The sum of the bytes used by all files.\n///     bytes_used: u64,\n///     _files: Vec<File>,\n/// }\n///\n/// struct Directory {\n///     _ino: u32,\n///     inner: Mutex<InnerDirectory>,\n/// }\n///\n/// /// Prints `bytes_used` from both the directory and file.\n/// fn print_bytes_used(dir: &Directory, file: &File) {\n///     let guard = dir.inner.lock();\n///     let inner_file = file.inner.access(&guard);\n///     pr_info!(\"{} {}\", guard.bytes_used, inner_file.bytes_used);\n/// }\n///\n/// /// Increments `bytes_used` for both the directory and file.\n/// fn inc_bytes_used(dir: &Directory, file: &File) {\n///     let mut guard = dir.inner.lock();\n///     guard.bytes_used += 10;\n///\n///     let file_inner = file.inner.access_mut(&mut guard);\n///     file_inner.bytes_used += 10;\n/// }\n///\n/// /// Creates a new file.\n/// fn new_file(ino: u32, dir: &Directory) -> File {\n///     File {\n///         _ino: ino,\n///         inner: LockedBy::new(&dir.inner, InnerFile { bytes_used: 0 }),\n///     }\n/// }\n/// ```\npub struct LockedBy<T: ?Sized, U: ?Sized> {\n    owner: *const U,\n    data: UnsafeCell<T>,\n}\n\n// SAFETY: `LockedBy` can be transferred across thread boundaries iff the data it protects can.\nunsafe impl<T: ?Sized + Send, U: ?Sized> Send for LockedBy<T, U> {}\n\n// SAFETY: `LockedBy` serialises the interior mutability it provides, so it is `Sync` as long as the\n// data it protects is `Send`.\nunsafe impl<T: ?Sized + Send, U: ?Sized> Sync for LockedBy<T, U> {}\n\nimpl<T, U> LockedBy<T, U> {\n    /// Constructs a new instance of [`LockedBy`].\n    ///\n    /// It stores a raw pointer to the owner that is never dereferenced. It is only used to ensure\n    /// that the right owner is being used to access the protected data. If the owner is freed, the\n    /// data becomes inaccessible; if another instance of the owner is allocated *on the same\n    /// memory location*, the data becomes accessible again: none of this affects memory safety\n    /// because in any case at most one thread (or CPU) can access the protected data at a time.\n    pub fn new<B: Backend>(owner: &Lock<U, B>, data: T) -> Self {\n        build_assert!(\n            size_of::<Lock<U, B>>() > 0,\n            \"The lock type cannot be a ZST because it may be impossible to distinguish instances\"\n        );\n        Self {\n            owner: owner.data.get(),\n            data: UnsafeCell::new(data),\n        }\n    }\n}\n\nimpl<T: ?Sized, U> LockedBy<T, U> {\n    /// Returns a reference to the protected data when the caller provides evidence (via a\n    /// reference) that the owner is locked.\n    ///\n    /// `U` cannot be a zero-sized type (ZST) because there are ways to get an `&U` that matches\n    /// the data protected by the lock without actually holding it.\n    ///\n    /// # Panics\n    ///\n    /// Panics if `owner` is different from the data protected by the lock used in\n    /// [`new`](LockedBy::new).\n    pub fn access<'a>(&'a self, owner: &'a U) -> &'a T {\n        build_assert!(\n            size_of::<U>() > 0,\n            \"`U` cannot be a ZST because `owner` wouldn't be unique\"\n        );\n        if !ptr::eq(owner, self.owner) {\n            panic!(\"mismatched owners\");\n        }\n\n        // SAFETY: `owner` is evidence that the owner is locked.\n        unsafe { &*self.data.get() }\n    }\n\n    /// Returns a mutable reference to the protected data when the caller provides evidence (via a\n    /// mutable owner) that the owner is locked mutably.\n    ///\n    /// `U` cannot be a zero-sized type (ZST) because there are ways to get an `&mut U` that\n    /// matches the data protected by the lock without actually holding it.\n    ///\n    /// Showing a mutable reference to the owner is sufficient because we know no other references\n    /// can exist to it.\n    ///\n    /// # Panics\n    ///\n    /// Panics if `owner` is different from the data protected by the lock used in\n    /// [`new`](LockedBy::new).\n    pub fn access_mut<'a>(&'a self, owner: &'a mut U) -> &'a mut T {\n        build_assert!(\n            size_of::<U>() > 0,\n            \"`U` cannot be a ZST because `owner` wouldn't be unique\"\n        );\n        if !ptr::eq(owner, self.owner) {\n            panic!(\"mismatched owners\");\n        }\n\n        // SAFETY: `owner` is evidence that there is only one reference to the owner.\n        unsafe { &mut *self.data.get() }\n    }\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}