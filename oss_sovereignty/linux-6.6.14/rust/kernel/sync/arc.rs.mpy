{
  "module_name": "arc.rs",
  "hash_id": "68562312037bb2008dd6a50626e760289619ccb3603484258f008784ef780057",
  "original_prompt": "Ingested from linux-6.6.14/rust/kernel/sync/arc.rs",
  "human_readable_source": "// SPDX-License-Identifier: GPL-2.0\n\n//! A reference-counted pointer.\n//!\n//! This module implements a way for users to create reference-counted objects and pointers to\n//! them. Such a pointer automatically increments and decrements the count, and drops the\n//! underlying object when it reaches zero. It is also safe to use concurrently from multiple\n//! threads.\n//!\n//! It is different from the standard library's [`Arc`] in a few ways:\n//! 1. It is backed by the kernel's `refcount_t` type.\n//! 2. It does not support weak references, which allows it to be half the size.\n//! 3. It saturates the reference count instead of aborting when it goes over a threshold.\n//! 4. It does not provide a `get_mut` method, so the ref counted object is pinned.\n//!\n//! [`Arc`]: https://doc.rust-lang.org/std/sync/struct.Arc.html\n\nuse crate::{\n    bindings,\n    error::{self, Error},\n    init::{self, InPlaceInit, Init, PinInit},\n    try_init,\n    types::{ForeignOwnable, Opaque},\n};\nuse alloc::boxed::Box;\nuse core::{\n    alloc::AllocError,\n    fmt,\n    marker::{PhantomData, Unsize},\n    mem::{ManuallyDrop, MaybeUninit},\n    ops::{Deref, DerefMut},\n    pin::Pin,\n    ptr::NonNull,\n};\nuse macros::pin_data;\n\nmod std_vendor;\n\n/// A reference-counted pointer to an instance of `T`.\n///\n/// The reference count is incremented when new instances of [`Arc`] are created, and decremented\n/// when they are dropped. When the count reaches zero, the underlying `T` is also dropped.\n///\n/// # Invariants\n///\n/// The reference count on an instance of [`Arc`] is always non-zero.\n/// The object pointed to by [`Arc`] is always pinned.\n///\n/// # Examples\n///\n/// ```\n/// use kernel::sync::Arc;\n///\n/// struct Example {\n///     a: u32,\n///     b: u32,\n/// }\n///\n/// // Create a ref-counted instance of `Example`.\n/// let obj = Arc::try_new(Example { a: 10, b: 20 })?;\n///\n/// // Get a new pointer to `obj` and increment the refcount.\n/// let cloned = obj.clone();\n///\n/// // Assert that both `obj` and `cloned` point to the same underlying object.\n/// assert!(core::ptr::eq(&*obj, &*cloned));\n///\n/// // Destroy `obj` and decrement its refcount.\n/// drop(obj);\n///\n/// // Check that the values are still accessible through `cloned`.\n/// assert_eq!(cloned.a, 10);\n/// assert_eq!(cloned.b, 20);\n///\n/// // The refcount drops to zero when `cloned` goes out of scope, and the memory is freed.\n/// # Ok::<(), Error>(())\n/// ```\n///\n/// Using `Arc<T>` as the type of `self`:\n///\n/// ```\n/// use kernel::sync::Arc;\n///\n/// struct Example {\n///     a: u32,\n///     b: u32,\n/// }\n///\n/// impl Example {\n///     fn take_over(self: Arc<Self>) {\n///         // ...\n///     }\n///\n///     fn use_reference(self: &Arc<Self>) {\n///         // ...\n///     }\n/// }\n///\n/// let obj = Arc::try_new(Example { a: 10, b: 20 })?;\n/// obj.use_reference();\n/// obj.take_over();\n/// # Ok::<(), Error>(())\n/// ```\n///\n/// Coercion from `Arc<Example>` to `Arc<dyn MyTrait>`:\n///\n/// ```\n/// use kernel::sync::{Arc, ArcBorrow};\n///\n/// trait MyTrait {\n///     // Trait has a function whose `self` type is `Arc<Self>`.\n///     fn example1(self: Arc<Self>) {}\n///\n///     // Trait has a function whose `self` type is `ArcBorrow<'_, Self>`.\n///     fn example2(self: ArcBorrow<'_, Self>) {}\n/// }\n///\n/// struct Example;\n/// impl MyTrait for Example {}\n///\n/// // `obj` has type `Arc<Example>`.\n/// let obj: Arc<Example> = Arc::try_new(Example)?;\n///\n/// // `coerced` has type `Arc<dyn MyTrait>`.\n/// let coerced: Arc<dyn MyTrait> = obj;\n/// # Ok::<(), Error>(())\n/// ```\npub struct Arc<T: ?Sized> {\n    ptr: NonNull<ArcInner<T>>,\n    _p: PhantomData<ArcInner<T>>,\n}\n\n#[pin_data]\n#[repr(C)]\nstruct ArcInner<T: ?Sized> {\n    refcount: Opaque<bindings::refcount_t>,\n    data: T,\n}\n\n// This is to allow [`Arc`] (and variants) to be used as the type of `self`.\nimpl<T: ?Sized> core::ops::Receiver for Arc<T> {}\n\n// This is to allow coercion from `Arc<T>` to `Arc<U>` if `T` can be converted to the\n// dynamically-sized type (DST) `U`.\nimpl<T: ?Sized + Unsize<U>, U: ?Sized> core::ops::CoerceUnsized<Arc<U>> for Arc<T> {}\n\n// This is to allow `Arc<U>` to be dispatched on when `Arc<T>` can be coerced into `Arc<U>`.\nimpl<T: ?Sized + Unsize<U>, U: ?Sized> core::ops::DispatchFromDyn<Arc<U>> for Arc<T> {}\n\n// SAFETY: It is safe to send `Arc<T>` to another thread when the underlying `T` is `Sync` because\n// it effectively means sharing `&T` (which is safe because `T` is `Sync`); additionally, it needs\n// `T` to be `Send` because any thread that has an `Arc<T>` may ultimately access `T` using a\n// mutable reference when the reference count reaches zero and `T` is dropped.\nunsafe impl<T: ?Sized + Sync + Send> Send for Arc<T> {}\n\n// SAFETY: It is safe to send `&Arc<T>` to another thread when the underlying `T` is `Sync`\n// because it effectively means sharing `&T` (which is safe because `T` is `Sync`); additionally,\n// it needs `T` to be `Send` because any thread that has a `&Arc<T>` may clone it and get an\n// `Arc<T>` on that thread, so the thread may ultimately access `T` using a mutable reference when\n// the reference count reaches zero and `T` is dropped.\nunsafe impl<T: ?Sized + Sync + Send> Sync for Arc<T> {}\n\nimpl<T> Arc<T> {\n    /// Constructs a new reference counted instance of `T`.\n    pub fn try_new(contents: T) -> Result<Self, AllocError> {\n        // INVARIANT: The refcount is initialised to a non-zero value.\n        let value = ArcInner {\n            // SAFETY: There are no safety requirements for this FFI call.\n            refcount: Opaque::new(unsafe { bindings::REFCOUNT_INIT(1) }),\n            data: contents,\n        };\n\n        let inner = Box::try_new(value)?;\n\n        // SAFETY: We just created `inner` with a reference count of 1, which is owned by the new\n        // `Arc` object.\n        Ok(unsafe { Self::from_inner(Box::leak(inner).into()) })\n    }\n\n    /// Use the given initializer to in-place initialize a `T`.\n    ///\n    /// If `T: !Unpin` it will not be able to move afterwards.\n    #[inline]\n    pub fn pin_init<E>(init: impl PinInit<T, E>) -> error::Result<Self>\n    where\n        Error: From<E>,\n    {\n        UniqueArc::pin_init(init).map(|u| u.into())\n    }\n\n    /// Use the given initializer to in-place initialize a `T`.\n    ///\n    /// This is equivalent to [`Arc<T>::pin_init`], since an [`Arc`] is always pinned.\n    #[inline]\n    pub fn init<E>(init: impl Init<T, E>) -> error::Result<Self>\n    where\n        Error: From<E>,\n    {\n        UniqueArc::init(init).map(|u| u.into())\n    }\n}\n\nimpl<T: ?Sized> Arc<T> {\n    /// Constructs a new [`Arc`] from an existing [`ArcInner`].\n    ///\n    /// # Safety\n    ///\n    /// The caller must ensure that `inner` points to a valid location and has a non-zero reference\n    /// count, one of which will be owned by the new [`Arc`] instance.\n    unsafe fn from_inner(inner: NonNull<ArcInner<T>>) -> Self {\n        // INVARIANT: By the safety requirements, the invariants hold.\n        Arc {\n            ptr: inner,\n            _p: PhantomData,\n        }\n    }\n\n    /// Returns an [`ArcBorrow`] from the given [`Arc`].\n    ///\n    /// This is useful when the argument of a function call is an [`ArcBorrow`] (e.g., in a method\n    /// receiver), but we have an [`Arc`] instead. Getting an [`ArcBorrow`] is free when optimised.\n    #[inline]\n    pub fn as_arc_borrow(&self) -> ArcBorrow<'_, T> {\n        // SAFETY: The constraint that the lifetime of the shared reference must outlive that of\n        // the returned `ArcBorrow` ensures that the object remains alive and that no mutable\n        // reference can be created.\n        unsafe { ArcBorrow::new(self.ptr) }\n    }\n\n    /// Compare whether two [`Arc`] pointers reference the same underlying object.\n    pub fn ptr_eq(this: &Self, other: &Self) -> bool {\n        core::ptr::eq(this.ptr.as_ptr(), other.ptr.as_ptr())\n    }\n}\n\nimpl<T: 'static> ForeignOwnable for Arc<T> {\n    type Borrowed<'a> = ArcBorrow<'a, T>;\n\n    fn into_foreign(self) -> *const core::ffi::c_void {\n        ManuallyDrop::new(self).ptr.as_ptr() as _\n    }\n\n    unsafe fn borrow<'a>(ptr: *const core::ffi::c_void) -> ArcBorrow<'a, T> {\n        // SAFETY: By the safety requirement of this function, we know that `ptr` came from\n        // a previous call to `Arc::into_foreign`.\n        let inner = NonNull::new(ptr as *mut ArcInner<T>).unwrap();\n\n        // SAFETY: The safety requirements of `from_foreign` ensure that the object remains alive\n        // for the lifetime of the returned value.\n        unsafe { ArcBorrow::new(inner) }\n    }\n\n    unsafe fn from_foreign(ptr: *const core::ffi::c_void) -> Self {\n        // SAFETY: By the safety requirement of this function, we know that `ptr` came from\n        // a previous call to `Arc::into_foreign`, which guarantees that `ptr` is valid and\n        // holds a reference count increment that is transferrable to us.\n        unsafe { Self::from_inner(NonNull::new(ptr as _).unwrap()) }\n    }\n}\n\nimpl<T: ?Sized> Deref for Arc<T> {\n    type Target = T;\n\n    fn deref(&self) -> &Self::Target {\n        // SAFETY: By the type invariant, there is necessarily a reference to the object, so it is\n        // safe to dereference it.\n        unsafe { &self.ptr.as_ref().data }\n    }\n}\n\nimpl<T: ?Sized> AsRef<T> for Arc<T> {\n    fn as_ref(&self) -> &T {\n        self.deref()\n    }\n}\n\nimpl<T: ?Sized> Clone for Arc<T> {\n    fn clone(&self) -> Self {\n        // INVARIANT: C `refcount_inc` saturates the refcount, so it cannot overflow to zero.\n        // SAFETY: By the type invariant, there is necessarily a reference to the object, so it is\n        // safe to increment the refcount.\n        unsafe { bindings::refcount_inc(self.ptr.as_ref().refcount.get()) };\n\n        // SAFETY: We just incremented the refcount. This increment is now owned by the new `Arc`.\n        unsafe { Self::from_inner(self.ptr) }\n    }\n}\n\nimpl<T: ?Sized> Drop for Arc<T> {\n    fn drop(&mut self) {\n        // SAFETY: By the type invariant, there is necessarily a reference to the object. We cannot\n        // touch `refcount` after it's decremented to a non-zero value because another thread/CPU\n        // may concurrently decrement it to zero and free it. It is ok to have a raw pointer to\n        // freed/invalid memory as long as it is never dereferenced.\n        let refcount = unsafe { self.ptr.as_ref() }.refcount.get();\n\n        // INVARIANT: If the refcount reaches zero, there are no other instances of `Arc`, and\n        // this instance is being dropped, so the broken invariant is not observable.\n        // SAFETY: Also by the type invariant, we are allowed to decrement the refcount.\n        let is_zero = unsafe { bindings::refcount_dec_and_test(refcount) };\n        if is_zero {\n            // The count reached zero, we must free the memory.\n            //\n            // SAFETY: The pointer was initialised from the result of `Box::leak`.\n            unsafe { Box::from_raw(self.ptr.as_ptr()) };\n        }\n    }\n}\n\nimpl<T: ?Sized> From<UniqueArc<T>> for Arc<T> {\n    fn from(item: UniqueArc<T>) -> Self {\n        item.inner\n    }\n}\n\nimpl<T: ?Sized> From<Pin<UniqueArc<T>>> for Arc<T> {\n    fn from(item: Pin<UniqueArc<T>>) -> Self {\n        // SAFETY: The type invariants of `Arc` guarantee that the data is pinned.\n        unsafe { Pin::into_inner_unchecked(item).inner }\n    }\n}\n\n/// A borrowed reference to an [`Arc`] instance.\n///\n/// For cases when one doesn't ever need to increment the refcount on the allocation, it is simpler\n/// to use just `&T`, which we can trivially get from an `Arc<T>` instance.\n///\n/// However, when one may need to increment the refcount, it is preferable to use an `ArcBorrow<T>`\n/// over `&Arc<T>` because the latter results in a double-indirection: a pointer (shared reference)\n/// to a pointer (`Arc<T>`) to the object (`T`). An [`ArcBorrow`] eliminates this double\n/// indirection while still allowing one to increment the refcount and getting an `Arc<T>` when/if\n/// needed.\n///\n/// # Invariants\n///\n/// There are no mutable references to the underlying [`Arc`], and it remains valid for the\n/// lifetime of the [`ArcBorrow`] instance.\n///\n/// # Example\n///\n/// ```\n/// use kernel::sync::{Arc, ArcBorrow};\n///\n/// struct Example;\n///\n/// fn do_something(e: ArcBorrow<'_, Example>) -> Arc<Example> {\n///     e.into()\n/// }\n///\n/// let obj = Arc::try_new(Example)?;\n/// let cloned = do_something(obj.as_arc_borrow());\n///\n/// // Assert that both `obj` and `cloned` point to the same underlying object.\n/// assert!(core::ptr::eq(&*obj, &*cloned));\n/// # Ok::<(), Error>(())\n/// ```\n///\n/// Using `ArcBorrow<T>` as the type of `self`:\n///\n/// ```\n/// use kernel::sync::{Arc, ArcBorrow};\n///\n/// struct Example {\n///     a: u32,\n///     b: u32,\n/// }\n///\n/// impl Example {\n///     fn use_reference(self: ArcBorrow<'_, Self>) {\n///         // ...\n///     }\n/// }\n///\n/// let obj = Arc::try_new(Example { a: 10, b: 20 })?;\n/// obj.as_arc_borrow().use_reference();\n/// # Ok::<(), Error>(())\n/// ```\npub struct ArcBorrow<'a, T: ?Sized + 'a> {\n    inner: NonNull<ArcInner<T>>,\n    _p: PhantomData<&'a ()>,\n}\n\n// This is to allow [`ArcBorrow`] (and variants) to be used as the type of `self`.\nimpl<T: ?Sized> core::ops::Receiver for ArcBorrow<'_, T> {}\n\n// This is to allow `ArcBorrow<U>` to be dispatched on when `ArcBorrow<T>` can be coerced into\n// `ArcBorrow<U>`.\nimpl<T: ?Sized + Unsize<U>, U: ?Sized> core::ops::DispatchFromDyn<ArcBorrow<'_, U>>\n    for ArcBorrow<'_, T>\n{\n}\n\nimpl<T: ?Sized> Clone for ArcBorrow<'_, T> {\n    fn clone(&self) -> Self {\n        *self\n    }\n}\n\nimpl<T: ?Sized> Copy for ArcBorrow<'_, T> {}\n\nimpl<T: ?Sized> ArcBorrow<'_, T> {\n    /// Creates a new [`ArcBorrow`] instance.\n    ///\n    /// # Safety\n    ///\n    /// Callers must ensure the following for the lifetime of the returned [`ArcBorrow`] instance:\n    /// 1. That `inner` remains valid;\n    /// 2. That no mutable references to `inner` are created.\n    unsafe fn new(inner: NonNull<ArcInner<T>>) -> Self {\n        // INVARIANT: The safety requirements guarantee the invariants.\n        Self {\n            inner,\n            _p: PhantomData,\n        }\n    }\n}\n\nimpl<T: ?Sized> From<ArcBorrow<'_, T>> for Arc<T> {\n    fn from(b: ArcBorrow<'_, T>) -> Self {\n        // SAFETY: The existence of `b` guarantees that the refcount is non-zero. `ManuallyDrop`\n        // guarantees that `drop` isn't called, so it's ok that the temporary `Arc` doesn't own the\n        // increment.\n        ManuallyDrop::new(unsafe { Arc::from_inner(b.inner) })\n            .deref()\n            .clone()\n    }\n}\n\nimpl<T: ?Sized> Deref for ArcBorrow<'_, T> {\n    type Target = T;\n\n    fn deref(&self) -> &Self::Target {\n        // SAFETY: By the type invariant, the underlying object is still alive with no mutable\n        // references to it, so it is safe to create a shared reference.\n        unsafe { &self.inner.as_ref().data }\n    }\n}\n\n/// A refcounted object that is known to have a refcount of 1.\n///\n/// It is mutable and can be converted to an [`Arc`] so that it can be shared.\n///\n/// # Invariants\n///\n/// `inner` always has a reference count of 1.\n///\n/// # Examples\n///\n/// In the following example, we make changes to the inner object before turning it into an\n/// `Arc<Test>` object (after which point, it cannot be mutated directly). Note that `x.into()`\n/// cannot fail.\n///\n/// ```\n/// use kernel::sync::{Arc, UniqueArc};\n///\n/// struct Example {\n///     a: u32,\n///     b: u32,\n/// }\n///\n/// fn test() -> Result<Arc<Example>> {\n///     let mut x = UniqueArc::try_new(Example { a: 10, b: 20 })?;\n///     x.a += 1;\n///     x.b += 1;\n///     Ok(x.into())\n/// }\n///\n/// # test().unwrap();\n/// ```\n///\n/// In the following example we first allocate memory for a ref-counted `Example` but we don't\n/// initialise it on allocation. We do initialise it later with a call to [`UniqueArc::write`],\n/// followed by a conversion to `Arc<Example>`. This is particularly useful when allocation happens\n/// in one context (e.g., sleepable) and initialisation in another (e.g., atomic):\n///\n/// ```\n/// use kernel::sync::{Arc, UniqueArc};\n///\n/// struct Example {\n///     a: u32,\n///     b: u32,\n/// }\n///\n/// fn test() -> Result<Arc<Example>> {\n///     let x = UniqueArc::try_new_uninit()?;\n///     Ok(x.write(Example { a: 10, b: 20 }).into())\n/// }\n///\n/// # test().unwrap();\n/// ```\n///\n/// In the last example below, the caller gets a pinned instance of `Example` while converting to\n/// `Arc<Example>`; this is useful in scenarios where one needs a pinned reference during\n/// initialisation, for example, when initialising fields that are wrapped in locks.\n///\n/// ```\n/// use kernel::sync::{Arc, UniqueArc};\n///\n/// struct Example {\n///     a: u32,\n///     b: u32,\n/// }\n///\n/// fn test() -> Result<Arc<Example>> {\n///     let mut pinned = Pin::from(UniqueArc::try_new(Example { a: 10, b: 20 })?);\n///     // We can modify `pinned` because it is `Unpin`.\n///     pinned.as_mut().a += 1;\n///     Ok(pinned.into())\n/// }\n///\n/// # test().unwrap();\n/// ```\npub struct UniqueArc<T: ?Sized> {\n    inner: Arc<T>,\n}\n\nimpl<T> UniqueArc<T> {\n    /// Tries to allocate a new [`UniqueArc`] instance.\n    pub fn try_new(value: T) -> Result<Self, AllocError> {\n        Ok(Self {\n            // INVARIANT: The newly-created object has a ref-count of 1.\n            inner: Arc::try_new(value)?,\n        })\n    }\n\n    /// Tries to allocate a new [`UniqueArc`] instance whose contents are not initialised yet.\n    pub fn try_new_uninit() -> Result<UniqueArc<MaybeUninit<T>>, AllocError> {\n        // INVARIANT: The refcount is initialised to a non-zero value.\n        let inner = Box::try_init::<AllocError>(try_init!(ArcInner {\n            // SAFETY: There are no safety requirements for this FFI call.\n            refcount: Opaque::new(unsafe { bindings::REFCOUNT_INIT(1) }),\n            data <- init::uninit::<T, AllocError>(),\n        }? AllocError))?;\n        Ok(UniqueArc {\n            // INVARIANT: The newly-created object has a ref-count of 1.\n            // SAFETY: The pointer from the `Box` is valid.\n            inner: unsafe { Arc::from_inner(Box::leak(inner).into()) },\n        })\n    }\n}\n\nimpl<T> UniqueArc<MaybeUninit<T>> {\n    /// Converts a `UniqueArc<MaybeUninit<T>>` into a `UniqueArc<T>` by writing a value into it.\n    pub fn write(mut self, value: T) -> UniqueArc<T> {\n        self.deref_mut().write(value);\n        // SAFETY: We just wrote the value to be initialized.\n        unsafe { self.assume_init() }\n    }\n\n    /// Unsafely assume that `self` is initialized.\n    ///\n    /// # Safety\n    ///\n    /// The caller guarantees that the value behind this pointer has been initialized. It is\n    /// *immediate* UB to call this when the value is not initialized.\n    pub unsafe fn assume_init(self) -> UniqueArc<T> {\n        let inner = ManuallyDrop::new(self).inner.ptr;\n        UniqueArc {\n            // SAFETY: The new `Arc` is taking over `ptr` from `self.inner` (which won't be\n            // dropped). The types are compatible because `MaybeUninit<T>` is compatible with `T`.\n            inner: unsafe { Arc::from_inner(inner.cast()) },\n        }\n    }\n\n    /// Initialize `self` using the given initializer.\n    pub fn init_with<E>(mut self, init: impl Init<T, E>) -> core::result::Result<UniqueArc<T>, E> {\n        // SAFETY: The supplied pointer is valid for initialization.\n        match unsafe { init.__init(self.as_mut_ptr()) } {\n            // SAFETY: Initialization completed successfully.\n            Ok(()) => Ok(unsafe { self.assume_init() }),\n            Err(err) => Err(err),\n        }\n    }\n\n    /// Pin-initialize `self` using the given pin-initializer.\n    pub fn pin_init_with<E>(\n        mut self,\n        init: impl PinInit<T, E>,\n    ) -> core::result::Result<Pin<UniqueArc<T>>, E> {\n        // SAFETY: The supplied pointer is valid for initialization and we will later pin the value\n        // to ensure it does not move.\n        match unsafe { init.__pinned_init(self.as_mut_ptr()) } {\n            // SAFETY: Initialization completed successfully.\n            Ok(()) => Ok(unsafe { self.assume_init() }.into()),\n            Err(err) => Err(err),\n        }\n    }\n}\n\nimpl<T: ?Sized> From<UniqueArc<T>> for Pin<UniqueArc<T>> {\n    fn from(obj: UniqueArc<T>) -> Self {\n        // SAFETY: It is not possible to move/replace `T` inside a `Pin<UniqueArc<T>>` (unless `T`\n        // is `Unpin`), so it is ok to convert it to `Pin<UniqueArc<T>>`.\n        unsafe { Pin::new_unchecked(obj) }\n    }\n}\n\nimpl<T: ?Sized> Deref for UniqueArc<T> {\n    type Target = T;\n\n    fn deref(&self) -> &Self::Target {\n        self.inner.deref()\n    }\n}\n\nimpl<T: ?Sized> DerefMut for UniqueArc<T> {\n    fn deref_mut(&mut self) -> &mut Self::Target {\n        // SAFETY: By the `Arc` type invariant, there is necessarily a reference to the object, so\n        // it is safe to dereference it. Additionally, we know there is only one reference when\n        // it's inside a `UniqueArc`, so it is safe to get a mutable reference.\n        unsafe { &mut self.inner.ptr.as_mut().data }\n    }\n}\n\nimpl<T: fmt::Display + ?Sized> fmt::Display for UniqueArc<T> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        fmt::Display::fmt(self.deref(), f)\n    }\n}\n\nimpl<T: fmt::Display + ?Sized> fmt::Display for Arc<T> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        fmt::Display::fmt(self.deref(), f)\n    }\n}\n\nimpl<T: fmt::Debug + ?Sized> fmt::Debug for UniqueArc<T> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        fmt::Debug::fmt(self.deref(), f)\n    }\n}\n\nimpl<T: fmt::Debug + ?Sized> fmt::Debug for Arc<T> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        fmt::Debug::fmt(self.deref(), f)\n    }\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}