{
  "module_name": "spinlock.rs",
  "hash_id": "4c3211aaaa769b84af5cab6055fda91c81316ce286aa547c26055242a6048418",
  "original_prompt": "Ingested from linux-6.6.14/rust/kernel/sync/lock/spinlock.rs",
  "human_readable_source": "// SPDX-License-Identifier: GPL-2.0\n\n//! A kernel spinlock.\n//!\n//! This module allows Rust code to use the kernel's `spinlock_t`.\n\nuse crate::bindings;\n\n/// Creates a [`SpinLock`] initialiser with the given name and a newly-created lock class.\n///\n/// It uses the name if one is given, otherwise it generates one based on the file name and line\n/// number.\n#[macro_export]\nmacro_rules! new_spinlock {\n    ($inner:expr $(, $name:literal)? $(,)?) => {\n        $crate::sync::SpinLock::new(\n            $inner, $crate::optional_name!($($name)?), $crate::static_lock_class!())\n    };\n}\n\n/// A spinlock.\n///\n/// Exposes the kernel's [`spinlock_t`]. When multiple CPUs attempt to lock the same spinlock, only\n/// one at a time is allowed to progress, the others will block (spinning) until the spinlock is\n/// unlocked, at which point another CPU will be allowed to make progress.\n///\n/// Instances of [`SpinLock`] need a lock class and to be pinned. The recommended way to create such\n/// instances is with the [`pin_init`](crate::pin_init) and [`new_spinlock`] macros.\n///\n/// # Examples\n///\n/// The following example shows how to declare, allocate and initialise a struct (`Example`) that\n/// contains an inner struct (`Inner`) that is protected by a spinlock.\n///\n/// ```\n/// use kernel::{init::InPlaceInit, init::PinInit, new_spinlock, pin_init, sync::SpinLock};\n///\n/// struct Inner {\n///     a: u32,\n///     b: u32,\n/// }\n///\n/// #[pin_data]\n/// struct Example {\n///     c: u32,\n///     #[pin]\n///     d: SpinLock<Inner>,\n/// }\n///\n/// impl Example {\n///     fn new() -> impl PinInit<Self> {\n///         pin_init!(Self {\n///             c: 10,\n///             d <- new_spinlock!(Inner { a: 20, b: 30 }),\n///         })\n///     }\n/// }\n///\n/// // Allocate a boxed `Example`.\n/// let e = Box::pin_init(Example::new())?;\n/// assert_eq!(e.c, 10);\n/// assert_eq!(e.d.lock().a, 20);\n/// assert_eq!(e.d.lock().b, 30);\n/// # Ok::<(), Error>(())\n/// ```\n///\n/// The following example shows how to use interior mutability to modify the contents of a struct\n/// protected by a spinlock despite only having a shared reference:\n///\n/// ```\n/// use kernel::sync::SpinLock;\n///\n/// struct Example {\n///     a: u32,\n///     b: u32,\n/// }\n///\n/// fn example(m: &SpinLock<Example>) {\n///     let mut guard = m.lock();\n///     guard.a += 10;\n///     guard.b += 20;\n/// }\n/// ```\n///\n/// [`spinlock_t`]: ../../../../include/linux/spinlock.h\npub type SpinLock<T> = super::Lock<T, SpinLockBackend>;\n\n/// A kernel `spinlock_t` lock backend.\npub struct SpinLockBackend;\n\n// SAFETY: The underlying kernel `spinlock_t` object ensures mutual exclusion. `relock` uses the\n// default implementation that always calls the same locking method.\nunsafe impl super::Backend for SpinLockBackend {\n    type State = bindings::spinlock_t;\n    type GuardState = ();\n\n    unsafe fn init(\n        ptr: *mut Self::State,\n        name: *const core::ffi::c_char,\n        key: *mut bindings::lock_class_key,\n    ) {\n        // SAFETY: The safety requirements ensure that `ptr` is valid for writes, and `name` and\n        // `key` are valid for read indefinitely.\n        unsafe { bindings::__spin_lock_init(ptr, name, key) }\n    }\n\n    unsafe fn lock(ptr: *mut Self::State) -> Self::GuardState {\n        // SAFETY: The safety requirements of this function ensure that `ptr` points to valid\n        // memory, and that it has been initialised before.\n        unsafe { bindings::spin_lock(ptr) }\n    }\n\n    unsafe fn unlock(ptr: *mut Self::State, _guard_state: &Self::GuardState) {\n        // SAFETY: The safety requirements of this function ensure that `ptr` is valid and that the\n        // caller is the owner of the mutex.\n        unsafe { bindings::spin_unlock(ptr) }\n    }\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}