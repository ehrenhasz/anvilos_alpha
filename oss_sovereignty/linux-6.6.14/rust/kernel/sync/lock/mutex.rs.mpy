{
  "module_name": "mutex.rs",
  "hash_id": "518758bafd95c48968901a708502e3e98f3fc32841d9101f0ad011fe9063056d",
  "original_prompt": "Ingested from linux-6.6.14/rust/kernel/sync/lock/mutex.rs",
  "human_readable_source": "// SPDX-License-Identifier: GPL-2.0\n\n//! A kernel mutex.\n//!\n//! This module allows Rust code to use the kernel's `struct mutex`.\n\nuse crate::bindings;\n\n/// Creates a [`Mutex`] initialiser with the given name and a newly-created lock class.\n///\n/// It uses the name if one is given, otherwise it generates one based on the file name and line\n/// number.\n#[macro_export]\nmacro_rules! new_mutex {\n    ($inner:expr $(, $name:literal)? $(,)?) => {\n        $crate::sync::Mutex::new(\n            $inner, $crate::optional_name!($($name)?), $crate::static_lock_class!())\n    };\n}\n\n/// A mutual exclusion primitive.\n///\n/// Exposes the kernel's [`struct mutex`]. When multiple threads attempt to lock the same mutex,\n/// only one at a time is allowed to progress, the others will block (sleep) until the mutex is\n/// unlocked, at which point another thread will be allowed to wake up and make progress.\n///\n/// Since it may block, [`Mutex`] needs to be used with care in atomic contexts.\n///\n/// Instances of [`Mutex`] need a lock class and to be pinned. The recommended way to create such\n/// instances is with the [`pin_init`](crate::pin_init) and [`new_mutex`] macros.\n///\n/// # Examples\n///\n/// The following example shows how to declare, allocate and initialise a struct (`Example`) that\n/// contains an inner struct (`Inner`) that is protected by a mutex.\n///\n/// ```\n/// use kernel::{init::InPlaceInit, init::PinInit, new_mutex, pin_init, sync::Mutex};\n///\n/// struct Inner {\n///     a: u32,\n///     b: u32,\n/// }\n///\n/// #[pin_data]\n/// struct Example {\n///     c: u32,\n///     #[pin]\n///     d: Mutex<Inner>,\n/// }\n///\n/// impl Example {\n///     fn new() -> impl PinInit<Self> {\n///         pin_init!(Self {\n///             c: 10,\n///             d <- new_mutex!(Inner { a: 20, b: 30 }),\n///         })\n///     }\n/// }\n///\n/// // Allocate a boxed `Example`.\n/// let e = Box::pin_init(Example::new())?;\n/// assert_eq!(e.c, 10);\n/// assert_eq!(e.d.lock().a, 20);\n/// assert_eq!(e.d.lock().b, 30);\n/// # Ok::<(), Error>(())\n/// ```\n///\n/// The following example shows how to use interior mutability to modify the contents of a struct\n/// protected by a mutex despite only having a shared reference:\n///\n/// ```\n/// use kernel::sync::Mutex;\n///\n/// struct Example {\n///     a: u32,\n///     b: u32,\n/// }\n///\n/// fn example(m: &Mutex<Example>) {\n///     let mut guard = m.lock();\n///     guard.a += 10;\n///     guard.b += 20;\n/// }\n/// ```\n///\n/// [`struct mutex`]: ../../../../include/linux/mutex.h\npub type Mutex<T> = super::Lock<T, MutexBackend>;\n\n/// A kernel `struct mutex` lock backend.\npub struct MutexBackend;\n\n// SAFETY: The underlying kernel `struct mutex` object ensures mutual exclusion.\nunsafe impl super::Backend for MutexBackend {\n    type State = bindings::mutex;\n    type GuardState = ();\n\n    unsafe fn init(\n        ptr: *mut Self::State,\n        name: *const core::ffi::c_char,\n        key: *mut bindings::lock_class_key,\n    ) {\n        // SAFETY: The safety requirements ensure that `ptr` is valid for writes, and `name` and\n        // `key` are valid for read indefinitely.\n        unsafe { bindings::__mutex_init(ptr, name, key) }\n    }\n\n    unsafe fn lock(ptr: *mut Self::State) -> Self::GuardState {\n        // SAFETY: The safety requirements of this function ensure that `ptr` points to valid\n        // memory, and that it has been initialised before.\n        unsafe { bindings::mutex_lock(ptr) };\n    }\n\n    unsafe fn unlock(ptr: *mut Self::State, _guard_state: &Self::GuardState) {\n        // SAFETY: The safety requirements of this function ensure that `ptr` is valid and that the\n        // caller is the owner of the mutex.\n        unsafe { bindings::mutex_unlock(ptr) };\n    }\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}