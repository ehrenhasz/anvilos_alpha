{
  "module_name": "condvar.rs",
  "hash_id": "7e637f702d1755e583ba9efa5aa2f5ecf76a8de25919239cddc410c87520b765",
  "original_prompt": "Ingested from linux-6.6.14/rust/kernel/sync/condvar.rs",
  "human_readable_source": "// SPDX-License-Identifier: GPL-2.0\n\n//! A condition variable.\n//!\n//! This module allows Rust code to use the kernel's [`struct wait_queue_head`] as a condition\n//! variable.\n\nuse super::{lock::Backend, lock::Guard, LockClassKey};\nuse crate::{bindings, init::PinInit, pin_init, str::CStr, types::Opaque};\nuse core::marker::PhantomPinned;\nuse macros::pin_data;\n\n/// Creates a [`CondVar`] initialiser with the given name and a newly-created lock class.\n#[macro_export]\nmacro_rules! new_condvar {\n    ($($name:literal)?) => {\n        $crate::sync::CondVar::new($crate::optional_name!($($name)?), $crate::static_lock_class!())\n    };\n}\n\n/// A conditional variable.\n///\n/// Exposes the kernel's [`struct wait_queue_head`] as a condition variable. It allows the caller to\n/// atomically release the given lock and go to sleep. It reacquires the lock when it wakes up. And\n/// it wakes up when notified by another thread (via [`CondVar::notify_one`] or\n/// [`CondVar::notify_all`]) or because the thread received a signal. It may also wake up\n/// spuriously.\n///\n/// Instances of [`CondVar`] need a lock class and to be pinned. The recommended way to create such\n/// instances is with the [`pin_init`](crate::pin_init) and [`new_condvar`] macros.\n///\n/// # Examples\n///\n/// The following is an example of using a condvar with a mutex:\n///\n/// ```\n/// use kernel::sync::{CondVar, Mutex};\n/// use kernel::{new_condvar, new_mutex};\n///\n/// #[pin_data]\n/// pub struct Example {\n///     #[pin]\n///     value: Mutex<u32>,\n///\n///     #[pin]\n///     value_changed: CondVar,\n/// }\n///\n/// /// Waits for `e.value` to become `v`.\n/// fn wait_for_value(e: &Example, v: u32) {\n///     let mut guard = e.value.lock();\n///     while *guard != v {\n///         e.value_changed.wait_uninterruptible(&mut guard);\n///     }\n/// }\n///\n/// /// Increments `e.value` and notifies all potential waiters.\n/// fn increment(e: &Example) {\n///     *e.value.lock() += 1;\n///     e.value_changed.notify_all();\n/// }\n///\n/// /// Allocates a new boxed `Example`.\n/// fn new_example() -> Result<Pin<Box<Example>>> {\n///     Box::pin_init(pin_init!(Example {\n///         value <- new_mutex!(0),\n///         value_changed <- new_condvar!(),\n///     }))\n/// }\n/// ```\n///\n/// [`struct wait_queue_head`]: ../../../include/linux/wait.h\n#[pin_data]\npub struct CondVar {\n    #[pin]\n    pub(crate) wait_list: Opaque<bindings::wait_queue_head>,\n\n    /// A condvar needs to be pinned because it contains a [`struct list_head`] that is\n    /// self-referential, so it cannot be safely moved once it is initialised.\n    #[pin]\n    _pin: PhantomPinned,\n}\n\n// SAFETY: `CondVar` only uses a `struct wait_queue_head`, which is safe to use on any thread.\n#[allow(clippy::non_send_fields_in_send_ty)]\nunsafe impl Send for CondVar {}\n\n// SAFETY: `CondVar` only uses a `struct wait_queue_head`, which is safe to use on multiple threads\n// concurrently.\nunsafe impl Sync for CondVar {}\n\nimpl CondVar {\n    /// Constructs a new condvar initialiser.\n    #[allow(clippy::new_ret_no_self)]\n    pub fn new(name: &'static CStr, key: &'static LockClassKey) -> impl PinInit<Self> {\n        pin_init!(Self {\n            _pin: PhantomPinned,\n            // SAFETY: `slot` is valid while the closure is called and both `name` and `key` have\n            // static lifetimes so they live indefinitely.\n            wait_list <- Opaque::ffi_init(|slot| unsafe {\n                bindings::__init_waitqueue_head(slot, name.as_char_ptr(), key.as_ptr())\n            }),\n        })\n    }\n\n    fn wait_internal<T: ?Sized, B: Backend>(&self, wait_state: u32, guard: &mut Guard<'_, T, B>) {\n        let wait = Opaque::<bindings::wait_queue_entry>::uninit();\n\n        // SAFETY: `wait` points to valid memory.\n        unsafe { bindings::init_wait(wait.get()) };\n\n        // SAFETY: Both `wait` and `wait_list` point to valid memory.\n        unsafe {\n            bindings::prepare_to_wait_exclusive(self.wait_list.get(), wait.get(), wait_state as _)\n        };\n\n        // SAFETY: No arguments, switches to another thread.\n        guard.do_unlocked(|| unsafe { bindings::schedule() });\n\n        // SAFETY: Both `wait` and `wait_list` point to valid memory.\n        unsafe { bindings::finish_wait(self.wait_list.get(), wait.get()) };\n    }\n\n    /// Releases the lock and waits for a notification in interruptible mode.\n    ///\n    /// Atomically releases the given lock (whose ownership is proven by the guard) and puts the\n    /// thread to sleep, reacquiring the lock on wake up. It wakes up when notified by\n    /// [`CondVar::notify_one`] or [`CondVar::notify_all`], or when the thread receives a signal.\n    /// It may also wake up spuriously.\n    ///\n    /// Returns whether there is a signal pending.\n    #[must_use = \"wait returns if a signal is pending, so the caller must check the return value\"]\n    pub fn wait<T: ?Sized, B: Backend>(&self, guard: &mut Guard<'_, T, B>) -> bool {\n        self.wait_internal(bindings::TASK_INTERRUPTIBLE, guard);\n        crate::current!().signal_pending()\n    }\n\n    /// Releases the lock and waits for a notification in uninterruptible mode.\n    ///\n    /// Similar to [`CondVar::wait`], except that the wait is not interruptible. That is, the\n    /// thread won't wake up due to signals. It may, however, wake up supirously.\n    pub fn wait_uninterruptible<T: ?Sized, B: Backend>(&self, guard: &mut Guard<'_, T, B>) {\n        self.wait_internal(bindings::TASK_UNINTERRUPTIBLE, guard)\n    }\n\n    /// Calls the kernel function to notify the appropriate number of threads with the given flags.\n    fn notify(&self, count: i32, flags: u32) {\n        // SAFETY: `wait_list` points to valid memory.\n        unsafe {\n            bindings::__wake_up(\n                self.wait_list.get(),\n                bindings::TASK_NORMAL,\n                count,\n                flags as _,\n            )\n        };\n    }\n\n    /// Wakes a single waiter up, if any.\n    ///\n    /// This is not 'sticky' in the sense that if no thread is waiting, the notification is lost\n    /// completely (as opposed to automatically waking up the next waiter).\n    pub fn notify_one(&self) {\n        self.notify(1, 0);\n    }\n\n    /// Wakes all waiters up, if any.\n    ///\n    /// This is not 'sticky' in the sense that if no thread is waiting, the notification is lost\n    /// completely (as opposed to automatically waking up the next waiter).\n    pub fn notify_all(&self) {\n        self.notify(0, 0);\n    }\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}