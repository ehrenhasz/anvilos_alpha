{
  "module_name": "types.rs",
  "hash_id": "b97c752c32f7a7d9e27f9d5b044130e8d4afbd1a6de003e3c4e18c50cb9ff497",
  "original_prompt": "Ingested from linux-6.6.14/rust/kernel/types.rs",
  "human_readable_source": "// SPDX-License-Identifier: GPL-2.0\n\n//! Kernel types.\n\nuse crate::init::{self, PinInit};\nuse alloc::boxed::Box;\nuse core::{\n    cell::UnsafeCell,\n    marker::{PhantomData, PhantomPinned},\n    mem::MaybeUninit,\n    ops::{Deref, DerefMut},\n    ptr::NonNull,\n};\n\n/// Used to transfer ownership to and from foreign (non-Rust) languages.\n///\n/// Ownership is transferred from Rust to a foreign language by calling [`Self::into_foreign`] and\n/// later may be transferred back to Rust by calling [`Self::from_foreign`].\n///\n/// This trait is meant to be used in cases when Rust objects are stored in C objects and\n/// eventually \"freed\" back to Rust.\npub trait ForeignOwnable: Sized {\n    /// Type of values borrowed between calls to [`ForeignOwnable::into_foreign`] and\n    /// [`ForeignOwnable::from_foreign`].\n    type Borrowed<'a>;\n\n    /// Converts a Rust-owned object to a foreign-owned one.\n    ///\n    /// The foreign representation is a pointer to void.\n    fn into_foreign(self) -> *const core::ffi::c_void;\n\n    /// Borrows a foreign-owned object.\n    ///\n    /// # Safety\n    ///\n    /// `ptr` must have been returned by a previous call to [`ForeignOwnable::into_foreign`] for\n    /// which a previous matching [`ForeignOwnable::from_foreign`] hasn't been called yet.\n    unsafe fn borrow<'a>(ptr: *const core::ffi::c_void) -> Self::Borrowed<'a>;\n\n    /// Converts a foreign-owned object back to a Rust-owned one.\n    ///\n    /// # Safety\n    ///\n    /// `ptr` must have been returned by a previous call to [`ForeignOwnable::into_foreign`] for\n    /// which a previous matching [`ForeignOwnable::from_foreign`] hasn't been called yet.\n    /// Additionally, all instances (if any) of values returned by [`ForeignOwnable::borrow`] for\n    /// this object must have been dropped.\n    unsafe fn from_foreign(ptr: *const core::ffi::c_void) -> Self;\n}\n\nimpl<T: 'static> ForeignOwnable for Box<T> {\n    type Borrowed<'a> = &'a T;\n\n    fn into_foreign(self) -> *const core::ffi::c_void {\n        Box::into_raw(self) as _\n    }\n\n    unsafe fn borrow<'a>(ptr: *const core::ffi::c_void) -> &'a T {\n        // SAFETY: The safety requirements for this function ensure that the object is still alive,\n        // so it is safe to dereference the raw pointer.\n        // The safety requirements of `from_foreign` also ensure that the object remains alive for\n        // the lifetime of the returned value.\n        unsafe { &*ptr.cast() }\n    }\n\n    unsafe fn from_foreign(ptr: *const core::ffi::c_void) -> Self {\n        // SAFETY: The safety requirements of this function ensure that `ptr` comes from a previous\n        // call to `Self::into_foreign`.\n        unsafe { Box::from_raw(ptr as _) }\n    }\n}\n\nimpl ForeignOwnable for () {\n    type Borrowed<'a> = ();\n\n    fn into_foreign(self) -> *const core::ffi::c_void {\n        core::ptr::NonNull::dangling().as_ptr()\n    }\n\n    unsafe fn borrow<'a>(_: *const core::ffi::c_void) -> Self::Borrowed<'a> {}\n\n    unsafe fn from_foreign(_: *const core::ffi::c_void) -> Self {}\n}\n\n/// Runs a cleanup function/closure when dropped.\n///\n/// The [`ScopeGuard::dismiss`] function prevents the cleanup function from running.\n///\n/// # Examples\n///\n/// In the example below, we have multiple exit paths and we want to log regardless of which one is\n/// taken:\n/// ```\n/// # use kernel::types::ScopeGuard;\n/// fn example1(arg: bool) {\n///     let _log = ScopeGuard::new(|| pr_info!(\"example1 completed\\n\"));\n///\n///     if arg {\n///         return;\n///     }\n///\n///     pr_info!(\"Do something...\\n\");\n/// }\n///\n/// # example1(false);\n/// # example1(true);\n/// ```\n///\n/// In the example below, we want to log the same message on all early exits but a different one on\n/// the main exit path:\n/// ```\n/// # use kernel::types::ScopeGuard;\n/// fn example2(arg: bool) {\n///     let log = ScopeGuard::new(|| pr_info!(\"example2 returned early\\n\"));\n///\n///     if arg {\n///         return;\n///     }\n///\n///     // (Other early returns...)\n///\n///     log.dismiss();\n///     pr_info!(\"example2 no early return\\n\");\n/// }\n///\n/// # example2(false);\n/// # example2(true);\n/// ```\n///\n/// In the example below, we need a mutable object (the vector) to be accessible within the log\n/// function, so we wrap it in the [`ScopeGuard`]:\n/// ```\n/// # use kernel::types::ScopeGuard;\n/// fn example3(arg: bool) -> Result {\n///     let mut vec =\n///         ScopeGuard::new_with_data(Vec::new(), |v| pr_info!(\"vec had {} elements\\n\", v.len()));\n///\n///     vec.try_push(10u8)?;\n///     if arg {\n///         return Ok(());\n///     }\n///     vec.try_push(20u8)?;\n///     Ok(())\n/// }\n///\n/// # assert_eq!(example3(false), Ok(()));\n/// # assert_eq!(example3(true), Ok(()));\n/// ```\n///\n/// # Invariants\n///\n/// The value stored in the struct is nearly always `Some(_)`, except between\n/// [`ScopeGuard::dismiss`] and [`ScopeGuard::drop`]: in this case, it will be `None` as the value\n/// will have been returned to the caller. Since  [`ScopeGuard::dismiss`] consumes the guard,\n/// callers won't be able to use it anymore.\npub struct ScopeGuard<T, F: FnOnce(T)>(Option<(T, F)>);\n\nimpl<T, F: FnOnce(T)> ScopeGuard<T, F> {\n    /// Creates a new guarded object wrapping the given data and with the given cleanup function.\n    pub fn new_with_data(data: T, cleanup_func: F) -> Self {\n        // INVARIANT: The struct is being initialised with `Some(_)`.\n        Self(Some((data, cleanup_func)))\n    }\n\n    /// Prevents the cleanup function from running and returns the guarded data.\n    pub fn dismiss(mut self) -> T {\n        // INVARIANT: This is the exception case in the invariant; it is not visible to callers\n        // because this function consumes `self`.\n        self.0.take().unwrap().0\n    }\n}\n\nimpl ScopeGuard<(), fn(())> {\n    /// Creates a new guarded object with the given cleanup function.\n    pub fn new(cleanup: impl FnOnce()) -> ScopeGuard<(), impl FnOnce(())> {\n        ScopeGuard::new_with_data((), move |_| cleanup())\n    }\n}\n\nimpl<T, F: FnOnce(T)> Deref for ScopeGuard<T, F> {\n    type Target = T;\n\n    fn deref(&self) -> &T {\n        // The type invariants guarantee that `unwrap` will succeed.\n        &self.0.as_ref().unwrap().0\n    }\n}\n\nimpl<T, F: FnOnce(T)> DerefMut for ScopeGuard<T, F> {\n    fn deref_mut(&mut self) -> &mut T {\n        // The type invariants guarantee that `unwrap` will succeed.\n        &mut self.0.as_mut().unwrap().0\n    }\n}\n\nimpl<T, F: FnOnce(T)> Drop for ScopeGuard<T, F> {\n    fn drop(&mut self) {\n        // Run the cleanup function if one is still present.\n        if let Some((data, cleanup)) = self.0.take() {\n            cleanup(data)\n        }\n    }\n}\n\n/// Stores an opaque value.\n///\n/// This is meant to be used with FFI objects that are never interpreted by Rust code.\n#[repr(transparent)]\npub struct Opaque<T> {\n    value: UnsafeCell<MaybeUninit<T>>,\n    _pin: PhantomPinned,\n}\n\nimpl<T> Opaque<T> {\n    /// Creates a new opaque value.\n    pub const fn new(value: T) -> Self {\n        Self {\n            value: UnsafeCell::new(MaybeUninit::new(value)),\n            _pin: PhantomPinned,\n        }\n    }\n\n    /// Creates an uninitialised value.\n    pub const fn uninit() -> Self {\n        Self {\n            value: UnsafeCell::new(MaybeUninit::uninit()),\n            _pin: PhantomPinned,\n        }\n    }\n\n    /// Creates a pin-initializer from the given initializer closure.\n    ///\n    /// The returned initializer calls the given closure with the pointer to the inner `T` of this\n    /// `Opaque`. Since this memory is uninitialized, the closure is not allowed to read from it.\n    ///\n    /// This function is safe, because the `T` inside of an `Opaque` is allowed to be\n    /// uninitialized. Additionally, access to the inner `T` requires `unsafe`, so the caller needs\n    /// to verify at that point that the inner value is valid.\n    pub fn ffi_init(init_func: impl FnOnce(*mut T)) -> impl PinInit<Self> {\n        // SAFETY: We contain a `MaybeUninit`, so it is OK for the `init_func` to not fully\n        // initialize the `T`.\n        unsafe {\n            init::pin_init_from_closure::<_, ::core::convert::Infallible>(move |slot| {\n                init_func(Self::raw_get(slot));\n                Ok(())\n            })\n        }\n    }\n\n    /// Returns a raw pointer to the opaque data.\n    pub fn get(&self) -> *mut T {\n        UnsafeCell::get(&self.value).cast::<T>()\n    }\n\n    /// Gets the value behind `this`.\n    ///\n    /// This function is useful to get access to the value without creating intermediate\n    /// references.\n    pub const fn raw_get(this: *const Self) -> *mut T {\n        UnsafeCell::raw_get(this.cast::<UnsafeCell<MaybeUninit<T>>>()).cast::<T>()\n    }\n}\n\n/// Types that are _always_ reference counted.\n///\n/// It allows such types to define their own custom ref increment and decrement functions.\n/// Additionally, it allows users to convert from a shared reference `&T` to an owned reference\n/// [`ARef<T>`].\n///\n/// This is usually implemented by wrappers to existing structures on the C side of the code. For\n/// Rust code, the recommendation is to use [`Arc`](crate::sync::Arc) to create reference-counted\n/// instances of a type.\n///\n/// # Safety\n///\n/// Implementers must ensure that increments to the reference count keep the object alive in memory\n/// at least until matching decrements are performed.\n///\n/// Implementers must also ensure that all instances are reference-counted. (Otherwise they\n/// won't be able to honour the requirement that [`AlwaysRefCounted::inc_ref`] keep the object\n/// alive.)\npub unsafe trait AlwaysRefCounted {\n    /// Increments the reference count on the object.\n    fn inc_ref(&self);\n\n    /// Decrements the reference count on the object.\n    ///\n    /// Frees the object when the count reaches zero.\n    ///\n    /// # Safety\n    ///\n    /// Callers must ensure that there was a previous matching increment to the reference count,\n    /// and that the object is no longer used after its reference count is decremented (as it may\n    /// result in the object being freed), unless the caller owns another increment on the refcount\n    /// (e.g., it calls [`AlwaysRefCounted::inc_ref`] twice, then calls\n    /// [`AlwaysRefCounted::dec_ref`] once).\n    unsafe fn dec_ref(obj: NonNull<Self>);\n}\n\n/// An owned reference to an always-reference-counted object.\n///\n/// The object's reference count is automatically decremented when an instance of [`ARef`] is\n/// dropped. It is also automatically incremented when a new instance is created via\n/// [`ARef::clone`].\n///\n/// # Invariants\n///\n/// The pointer stored in `ptr` is non-null and valid for the lifetime of the [`ARef`] instance. In\n/// particular, the [`ARef`] instance owns an increment on the underlying object's reference count.\npub struct ARef<T: AlwaysRefCounted> {\n    ptr: NonNull<T>,\n    _p: PhantomData<T>,\n}\n\n// SAFETY: It is safe to send `ARef<T>` to another thread when the underlying `T` is `Sync` because\n// it effectively means sharing `&T` (which is safe because `T` is `Sync`); additionally, it needs\n// `T` to be `Send` because any thread that has an `ARef<T>` may ultimately access `T` using a\n// mutable reference, for example, when the reference count reaches zero and `T` is dropped.\nunsafe impl<T: AlwaysRefCounted + Sync + Send> Send for ARef<T> {}\n\n// SAFETY: It is safe to send `&ARef<T>` to another thread when the underlying `T` is `Sync`\n// because it effectively means sharing `&T` (which is safe because `T` is `Sync`); additionally,\n// it needs `T` to be `Send` because any thread that has a `&ARef<T>` may clone it and get an\n// `ARef<T>` on that thread, so the thread may ultimately access `T` using a mutable reference, for\n// example, when the reference count reaches zero and `T` is dropped.\nunsafe impl<T: AlwaysRefCounted + Sync + Send> Sync for ARef<T> {}\n\nimpl<T: AlwaysRefCounted> ARef<T> {\n    /// Creates a new instance of [`ARef`].\n    ///\n    /// It takes over an increment of the reference count on the underlying object.\n    ///\n    /// # Safety\n    ///\n    /// Callers must ensure that the reference count was incremented at least once, and that they\n    /// are properly relinquishing one increment. That is, if there is only one increment, callers\n    /// must not use the underlying object anymore -- it is only safe to do so via the newly\n    /// created [`ARef`].\n    pub unsafe fn from_raw(ptr: NonNull<T>) -> Self {\n        // INVARIANT: The safety requirements guarantee that the new instance now owns the\n        // increment on the refcount.\n        Self {\n            ptr,\n            _p: PhantomData,\n        }\n    }\n}\n\nimpl<T: AlwaysRefCounted> Clone for ARef<T> {\n    fn clone(&self) -> Self {\n        self.inc_ref();\n        // SAFETY: We just incremented the refcount above.\n        unsafe { Self::from_raw(self.ptr) }\n    }\n}\n\nimpl<T: AlwaysRefCounted> Deref for ARef<T> {\n    type Target = T;\n\n    fn deref(&self) -> &Self::Target {\n        // SAFETY: The type invariants guarantee that the object is valid.\n        unsafe { self.ptr.as_ref() }\n    }\n}\n\nimpl<T: AlwaysRefCounted> From<&T> for ARef<T> {\n    fn from(b: &T) -> Self {\n        b.inc_ref();\n        // SAFETY: We just incremented the refcount above.\n        unsafe { Self::from_raw(NonNull::from(b)) }\n    }\n}\n\nimpl<T: AlwaysRefCounted> Drop for ARef<T> {\n    fn drop(&mut self) {\n        // SAFETY: The type invariants guarantee that the `ARef` owns the reference we're about to\n        // decrement.\n        unsafe { T::dec_ref(self.ptr) };\n    }\n}\n\n/// A sum type that always holds either a value of type `L` or `R`.\npub enum Either<L, R> {\n    /// Constructs an instance of [`Either`] containing a value of type `L`.\n    Left(L),\n\n    /// Constructs an instance of [`Either`] containing a value of type `R`.\n    Right(R),\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}