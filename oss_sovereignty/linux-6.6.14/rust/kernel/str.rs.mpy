{
  "module_name": "str.rs",
  "hash_id": "981396f52fc1d5780f448bfe89100cb46b220bcd2ea352136c3d2e8d04fd944e",
  "original_prompt": "Ingested from linux-6.6.14/rust/kernel/str.rs",
  "human_readable_source": "// SPDX-License-Identifier: GPL-2.0\n\n//! String representations.\n\nuse alloc::alloc::AllocError;\nuse alloc::vec::Vec;\nuse core::fmt::{self, Write};\nuse core::ops::{self, Deref, Index};\n\nuse crate::{\n    bindings,\n    error::{code::*, Error},\n};\n\n/// Byte string without UTF-8 validity guarantee.\n///\n/// `BStr` is simply an alias to `[u8]`, but has a more evident semantical meaning.\npub type BStr = [u8];\n\n/// Creates a new [`BStr`] from a string literal.\n///\n/// `b_str!` converts the supplied string literal to byte string, so non-ASCII\n/// characters can be included.\n///\n/// # Examples\n///\n/// ```\n/// # use kernel::b_str;\n/// # use kernel::str::BStr;\n/// const MY_BSTR: &BStr = b_str!(\"My awesome BStr!\");\n/// ```\n#[macro_export]\nmacro_rules! b_str {\n    ($str:literal) => {{\n        const S: &'static str = $str;\n        const C: &'static $crate::str::BStr = S.as_bytes();\n        C\n    }};\n}\n\n/// Possible errors when using conversion functions in [`CStr`].\n#[derive(Debug, Clone, Copy)]\npub enum CStrConvertError {\n    /// Supplied bytes contain an interior `NUL`.\n    InteriorNul,\n\n    /// Supplied bytes are not terminated by `NUL`.\n    NotNulTerminated,\n}\n\nimpl From<CStrConvertError> for Error {\n    #[inline]\n    fn from(_: CStrConvertError) -> Error {\n        EINVAL\n    }\n}\n\n/// A string that is guaranteed to have exactly one `NUL` byte, which is at the\n/// end.\n///\n/// Used for interoperability with kernel APIs that take C strings.\n#[repr(transparent)]\npub struct CStr([u8]);\n\nimpl CStr {\n    /// Returns the length of this string excluding `NUL`.\n    #[inline]\n    pub const fn len(&self) -> usize {\n        self.len_with_nul() - 1\n    }\n\n    /// Returns the length of this string with `NUL`.\n    #[inline]\n    pub const fn len_with_nul(&self) -> usize {\n        // SAFETY: This is one of the invariant of `CStr`.\n        // We add a `unreachable_unchecked` here to hint the optimizer that\n        // the value returned from this function is non-zero.\n        if self.0.is_empty() {\n            unsafe { core::hint::unreachable_unchecked() };\n        }\n        self.0.len()\n    }\n\n    /// Returns `true` if the string only includes `NUL`.\n    #[inline]\n    pub const fn is_empty(&self) -> bool {\n        self.len() == 0\n    }\n\n    /// Wraps a raw C string pointer.\n    ///\n    /// # Safety\n    ///\n    /// `ptr` must be a valid pointer to a `NUL`-terminated C string, and it must\n    /// last at least `'a`. When `CStr` is alive, the memory pointed by `ptr`\n    /// must not be mutated.\n    #[inline]\n    pub unsafe fn from_char_ptr<'a>(ptr: *const core::ffi::c_char) -> &'a Self {\n        // SAFETY: The safety precondition guarantees `ptr` is a valid pointer\n        // to a `NUL`-terminated C string.\n        let len = unsafe { bindings::strlen(ptr) } + 1;\n        // SAFETY: Lifetime guaranteed by the safety precondition.\n        let bytes = unsafe { core::slice::from_raw_parts(ptr as _, len as _) };\n        // SAFETY: As `len` is returned by `strlen`, `bytes` does not contain interior `NUL`.\n        // As we have added 1 to `len`, the last byte is known to be `NUL`.\n        unsafe { Self::from_bytes_with_nul_unchecked(bytes) }\n    }\n\n    /// Creates a [`CStr`] from a `[u8]`.\n    ///\n    /// The provided slice must be `NUL`-terminated, does not contain any\n    /// interior `NUL` bytes.\n    pub const fn from_bytes_with_nul(bytes: &[u8]) -> Result<&Self, CStrConvertError> {\n        if bytes.is_empty() {\n            return Err(CStrConvertError::NotNulTerminated);\n        }\n        if bytes[bytes.len() - 1] != 0 {\n            return Err(CStrConvertError::NotNulTerminated);\n        }\n        let mut i = 0;\n        // `i + 1 < bytes.len()` allows LLVM to optimize away bounds checking,\n        // while it couldn't optimize away bounds checks for `i < bytes.len() - 1`.\n        while i + 1 < bytes.len() {\n            if bytes[i] == 0 {\n                return Err(CStrConvertError::InteriorNul);\n            }\n            i += 1;\n        }\n        // SAFETY: We just checked that all properties hold.\n        Ok(unsafe { Self::from_bytes_with_nul_unchecked(bytes) })\n    }\n\n    /// Creates a [`CStr`] from a `[u8]` without performing any additional\n    /// checks.\n    ///\n    /// # Safety\n    ///\n    /// `bytes` *must* end with a `NUL` byte, and should only have a single\n    /// `NUL` byte (or the string will be truncated).\n    #[inline]\n    pub const unsafe fn from_bytes_with_nul_unchecked(bytes: &[u8]) -> &CStr {\n        // SAFETY: Properties of `bytes` guaranteed by the safety precondition.\n        unsafe { core::mem::transmute(bytes) }\n    }\n\n    /// Returns a C pointer to the string.\n    #[inline]\n    pub const fn as_char_ptr(&self) -> *const core::ffi::c_char {\n        self.0.as_ptr() as _\n    }\n\n    /// Convert the string to a byte slice without the trailing 0 byte.\n    #[inline]\n    pub fn as_bytes(&self) -> &[u8] {\n        &self.0[..self.len()]\n    }\n\n    /// Convert the string to a byte slice containing the trailing 0 byte.\n    #[inline]\n    pub const fn as_bytes_with_nul(&self) -> &[u8] {\n        &self.0\n    }\n\n    /// Yields a [`&str`] slice if the [`CStr`] contains valid UTF-8.\n    ///\n    /// If the contents of the [`CStr`] are valid UTF-8 data, this\n    /// function will return the corresponding [`&str`] slice. Otherwise,\n    /// it will return an error with details of where UTF-8 validation failed.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use kernel::str::CStr;\n    /// let cstr = CStr::from_bytes_with_nul(b\"foo\\0\").unwrap();\n    /// assert_eq!(cstr.to_str(), Ok(\"foo\"));\n    /// ```\n    #[inline]\n    pub fn to_str(&self) -> Result<&str, core::str::Utf8Error> {\n        core::str::from_utf8(self.as_bytes())\n    }\n\n    /// Unsafely convert this [`CStr`] into a [`&str`], without checking for\n    /// valid UTF-8.\n    ///\n    /// # Safety\n    ///\n    /// The contents must be valid UTF-8.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use kernel::c_str;\n    /// # use kernel::str::CStr;\n    /// // SAFETY: String literals are guaranteed to be valid UTF-8\n    /// // by the Rust compiler.\n    /// let bar = c_str!(\"\u30c4\");\n    /// assert_eq!(unsafe { bar.as_str_unchecked() }, \"\u30c4\");\n    /// ```\n    #[inline]\n    pub unsafe fn as_str_unchecked(&self) -> &str {\n        unsafe { core::str::from_utf8_unchecked(self.as_bytes()) }\n    }\n\n    /// Convert this [`CStr`] into a [`CString`] by allocating memory and\n    /// copying over the string data.\n    pub fn to_cstring(&self) -> Result<CString, AllocError> {\n        CString::try_from(self)\n    }\n}\n\nimpl fmt::Display for CStr {\n    /// Formats printable ASCII characters, escaping the rest.\n    ///\n    /// ```\n    /// # use kernel::c_str;\n    /// # use kernel::fmt;\n    /// # use kernel::str::CStr;\n    /// # use kernel::str::CString;\n    /// let penguin = c_str!(\"\ud83d\udc27\");\n    /// let s = CString::try_from_fmt(fmt!(\"{}\", penguin)).unwrap();\n    /// assert_eq!(s.as_bytes_with_nul(), \"\\\\xf0\\\\x9f\\\\x90\\\\xa7\\0\".as_bytes());\n    ///\n    /// let ascii = c_str!(\"so \\\"cool\\\"\");\n    /// let s = CString::try_from_fmt(fmt!(\"{}\", ascii)).unwrap();\n    /// assert_eq!(s.as_bytes_with_nul(), \"so \\\"cool\\\"\\0\".as_bytes());\n    /// ```\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        for &c in self.as_bytes() {\n            if (0x20..0x7f).contains(&c) {\n                // Printable character.\n                f.write_char(c as char)?;\n            } else {\n                write!(f, \"\\\\x{:02x}\", c)?;\n            }\n        }\n        Ok(())\n    }\n}\n\nimpl fmt::Debug for CStr {\n    /// Formats printable ASCII characters with a double quote on either end, escaping the rest.\n    ///\n    /// ```\n    /// # use kernel::c_str;\n    /// # use kernel::fmt;\n    /// # use kernel::str::CStr;\n    /// # use kernel::str::CString;\n    /// let penguin = c_str!(\"\ud83d\udc27\");\n    /// let s = CString::try_from_fmt(fmt!(\"{:?}\", penguin)).unwrap();\n    /// assert_eq!(s.as_bytes_with_nul(), \"\\\"\\\\xf0\\\\x9f\\\\x90\\\\xa7\\\"\\0\".as_bytes());\n    ///\n    /// // Embedded double quotes are escaped.\n    /// let ascii = c_str!(\"so \\\"cool\\\"\");\n    /// let s = CString::try_from_fmt(fmt!(\"{:?}\", ascii)).unwrap();\n    /// assert_eq!(s.as_bytes_with_nul(), \"\\\"so \\\\\\\"cool\\\\\\\"\\\"\\0\".as_bytes());\n    /// ```\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.write_str(\"\\\"\")?;\n        for &c in self.as_bytes() {\n            match c {\n                // Printable characters.\n                b'\\\"' => f.write_str(\"\\\\\\\"\")?,\n                0x20..=0x7e => f.write_char(c as char)?,\n                _ => write!(f, \"\\\\x{:02x}\", c)?,\n            }\n        }\n        f.write_str(\"\\\"\")\n    }\n}\n\nimpl AsRef<BStr> for CStr {\n    #[inline]\n    fn as_ref(&self) -> &BStr {\n        self.as_bytes()\n    }\n}\n\nimpl Deref for CStr {\n    type Target = BStr;\n\n    #[inline]\n    fn deref(&self) -> &Self::Target {\n        self.as_bytes()\n    }\n}\n\nimpl Index<ops::RangeFrom<usize>> for CStr {\n    type Output = CStr;\n\n    #[inline]\n    fn index(&self, index: ops::RangeFrom<usize>) -> &Self::Output {\n        // Delegate bounds checking to slice.\n        // Assign to _ to mute clippy's unnecessary operation warning.\n        let _ = &self.as_bytes()[index.start..];\n        // SAFETY: We just checked the bounds.\n        unsafe { Self::from_bytes_with_nul_unchecked(&self.0[index.start..]) }\n    }\n}\n\nimpl Index<ops::RangeFull> for CStr {\n    type Output = CStr;\n\n    #[inline]\n    fn index(&self, _index: ops::RangeFull) -> &Self::Output {\n        self\n    }\n}\n\nmod private {\n    use core::ops;\n\n    // Marker trait for index types that can be forward to `BStr`.\n    pub trait CStrIndex {}\n\n    impl CStrIndex for usize {}\n    impl CStrIndex for ops::Range<usize> {}\n    impl CStrIndex for ops::RangeInclusive<usize> {}\n    impl CStrIndex for ops::RangeToInclusive<usize> {}\n}\n\nimpl<Idx> Index<Idx> for CStr\nwhere\n    Idx: private::CStrIndex,\n    BStr: Index<Idx>,\n{\n    type Output = <BStr as Index<Idx>>::Output;\n\n    #[inline]\n    fn index(&self, index: Idx) -> &Self::Output {\n        &self.as_bytes()[index]\n    }\n}\n\n/// Creates a new [`CStr`] from a string literal.\n///\n/// The string literal should not contain any `NUL` bytes.\n///\n/// # Examples\n///\n/// ```\n/// # use kernel::c_str;\n/// # use kernel::str::CStr;\n/// const MY_CSTR: &CStr = c_str!(\"My awesome CStr!\");\n/// ```\n#[macro_export]\nmacro_rules! c_str {\n    ($str:expr) => {{\n        const S: &str = concat!($str, \"\\0\");\n        const C: &$crate::str::CStr = match $crate::str::CStr::from_bytes_with_nul(S.as_bytes()) {\n            Ok(v) => v,\n            Err(_) => panic!(\"string contains interior NUL\"),\n        };\n        C\n    }};\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_cstr_to_str() {\n        let good_bytes = b\"\\xf0\\x9f\\xa6\\x80\\0\";\n        let checked_cstr = CStr::from_bytes_with_nul(good_bytes).unwrap();\n        let checked_str = checked_cstr.to_str().unwrap();\n        assert_eq!(checked_str, \"\ud83e\udd80\");\n    }\n\n    #[test]\n    #[should_panic]\n    fn test_cstr_to_str_panic() {\n        let bad_bytes = b\"\\xc3\\x28\\0\";\n        let checked_cstr = CStr::from_bytes_with_nul(bad_bytes).unwrap();\n        checked_cstr.to_str().unwrap();\n    }\n\n    #[test]\n    fn test_cstr_as_str_unchecked() {\n        let good_bytes = b\"\\xf0\\x9f\\x90\\xA7\\0\";\n        let checked_cstr = CStr::from_bytes_with_nul(good_bytes).unwrap();\n        let unchecked_str = unsafe { checked_cstr.as_str_unchecked() };\n        assert_eq!(unchecked_str, \"\ud83d\udc27\");\n    }\n}\n\n/// Allows formatting of [`fmt::Arguments`] into a raw buffer.\n///\n/// It does not fail if callers write past the end of the buffer so that they can calculate the\n/// size required to fit everything.\n///\n/// # Invariants\n///\n/// The memory region between `pos` (inclusive) and `end` (exclusive) is valid for writes if `pos`\n/// is less than `end`.\npub(crate) struct RawFormatter {\n    // Use `usize` to use `saturating_*` functions.\n    beg: usize,\n    pos: usize,\n    end: usize,\n}\n\nimpl RawFormatter {\n    /// Creates a new instance of [`RawFormatter`] with an empty buffer.\n    fn new() -> Self {\n        // INVARIANT: The buffer is empty, so the region that needs to be writable is empty.\n        Self {\n            beg: 0,\n            pos: 0,\n            end: 0,\n        }\n    }\n\n    /// Creates a new instance of [`RawFormatter`] with the given buffer pointers.\n    ///\n    /// # Safety\n    ///\n    /// If `pos` is less than `end`, then the region between `pos` (inclusive) and `end`\n    /// (exclusive) must be valid for writes for the lifetime of the returned [`RawFormatter`].\n    pub(crate) unsafe fn from_ptrs(pos: *mut u8, end: *mut u8) -> Self {\n        // INVARIANT: The safety requirements guarantee the type invariants.\n        Self {\n            beg: pos as _,\n            pos: pos as _,\n            end: end as _,\n        }\n    }\n\n    /// Creates a new instance of [`RawFormatter`] with the given buffer.\n    ///\n    /// # Safety\n    ///\n    /// The memory region starting at `buf` and extending for `len` bytes must be valid for writes\n    /// for the lifetime of the returned [`RawFormatter`].\n    pub(crate) unsafe fn from_buffer(buf: *mut u8, len: usize) -> Self {\n        let pos = buf as usize;\n        // INVARIANT: We ensure that `end` is never less then `buf`, and the safety requirements\n        // guarantees that the memory region is valid for writes.\n        Self {\n            pos,\n            beg: pos,\n            end: pos.saturating_add(len),\n        }\n    }\n\n    /// Returns the current insert position.\n    ///\n    /// N.B. It may point to invalid memory.\n    pub(crate) fn pos(&self) -> *mut u8 {\n        self.pos as _\n    }\n\n    /// Return the number of bytes written to the formatter.\n    pub(crate) fn bytes_written(&self) -> usize {\n        self.pos - self.beg\n    }\n}\n\nimpl fmt::Write for RawFormatter {\n    fn write_str(&mut self, s: &str) -> fmt::Result {\n        // `pos` value after writing `len` bytes. This does not have to be bounded by `end`, but we\n        // don't want it to wrap around to 0.\n        let pos_new = self.pos.saturating_add(s.len());\n\n        // Amount that we can copy. `saturating_sub` ensures we get 0 if `pos` goes past `end`.\n        let len_to_copy = core::cmp::min(pos_new, self.end).saturating_sub(self.pos);\n\n        if len_to_copy > 0 {\n            // SAFETY: If `len_to_copy` is non-zero, then we know `pos` has not gone past `end`\n            // yet, so it is valid for write per the type invariants.\n            unsafe {\n                core::ptr::copy_nonoverlapping(\n                    s.as_bytes().as_ptr(),\n                    self.pos as *mut u8,\n                    len_to_copy,\n                )\n            };\n        }\n\n        self.pos = pos_new;\n        Ok(())\n    }\n}\n\n/// Allows formatting of [`fmt::Arguments`] into a raw buffer.\n///\n/// Fails if callers attempt to write more than will fit in the buffer.\npub(crate) struct Formatter(RawFormatter);\n\nimpl Formatter {\n    /// Creates a new instance of [`Formatter`] with the given buffer.\n    ///\n    /// # Safety\n    ///\n    /// The memory region starting at `buf` and extending for `len` bytes must be valid for writes\n    /// for the lifetime of the returned [`Formatter`].\n    pub(crate) unsafe fn from_buffer(buf: *mut u8, len: usize) -> Self {\n        // SAFETY: The safety requirements of this function satisfy those of the callee.\n        Self(unsafe { RawFormatter::from_buffer(buf, len) })\n    }\n}\n\nimpl Deref for Formatter {\n    type Target = RawFormatter;\n\n    fn deref(&self) -> &Self::Target {\n        &self.0\n    }\n}\n\nimpl fmt::Write for Formatter {\n    fn write_str(&mut self, s: &str) -> fmt::Result {\n        self.0.write_str(s)?;\n\n        // Fail the request if we go past the end of the buffer.\n        if self.0.pos > self.0.end {\n            Err(fmt::Error)\n        } else {\n            Ok(())\n        }\n    }\n}\n\n/// An owned string that is guaranteed to have exactly one `NUL` byte, which is at the end.\n///\n/// Used for interoperability with kernel APIs that take C strings.\n///\n/// # Invariants\n///\n/// The string is always `NUL`-terminated and contains no other `NUL` bytes.\n///\n/// # Examples\n///\n/// ```\n/// use kernel::{str::CString, fmt};\n///\n/// let s = CString::try_from_fmt(fmt!(\"{}{}{}\", \"abc\", 10, 20)).unwrap();\n/// assert_eq!(s.as_bytes_with_nul(), \"abc1020\\0\".as_bytes());\n///\n/// let tmp = \"testing\";\n/// let s = CString::try_from_fmt(fmt!(\"{tmp}{}\", 123)).unwrap();\n/// assert_eq!(s.as_bytes_with_nul(), \"testing123\\0\".as_bytes());\n///\n/// // This fails because it has an embedded `NUL` byte.\n/// let s = CString::try_from_fmt(fmt!(\"a\\0b{}\", 123));\n/// assert_eq!(s.is_ok(), false);\n/// ```\npub struct CString {\n    buf: Vec<u8>,\n}\n\nimpl CString {\n    /// Creates an instance of [`CString`] from the given formatted arguments.\n    pub fn try_from_fmt(args: fmt::Arguments<'_>) -> Result<Self, Error> {\n        // Calculate the size needed (formatted string plus `NUL` terminator).\n        let mut f = RawFormatter::new();\n        f.write_fmt(args)?;\n        f.write_str(\"\\0\")?;\n        let size = f.bytes_written();\n\n        // Allocate a vector with the required number of bytes, and write to it.\n        let mut buf = Vec::try_with_capacity(size)?;\n        // SAFETY: The buffer stored in `buf` is at least of size `size` and is valid for writes.\n        let mut f = unsafe { Formatter::from_buffer(buf.as_mut_ptr(), size) };\n        f.write_fmt(args)?;\n        f.write_str(\"\\0\")?;\n\n        // SAFETY: The number of bytes that can be written to `f` is bounded by `size`, which is\n        // `buf`'s capacity. The contents of the buffer have been initialised by writes to `f`.\n        unsafe { buf.set_len(f.bytes_written()) };\n\n        // Check that there are no `NUL` bytes before the end.\n        // SAFETY: The buffer is valid for read because `f.bytes_written()` is bounded by `size`\n        // (which the minimum buffer size) and is non-zero (we wrote at least the `NUL` terminator)\n        // so `f.bytes_written() - 1` doesn't underflow.\n        let ptr = unsafe { bindings::memchr(buf.as_ptr().cast(), 0, (f.bytes_written() - 1) as _) };\n        if !ptr.is_null() {\n            return Err(EINVAL);\n        }\n\n        // INVARIANT: We wrote the `NUL` terminator and checked above that no other `NUL` bytes\n        // exist in the buffer.\n        Ok(Self { buf })\n    }\n}\n\nimpl Deref for CString {\n    type Target = CStr;\n\n    fn deref(&self) -> &Self::Target {\n        // SAFETY: The type invariants guarantee that the string is `NUL`-terminated and that no\n        // other `NUL` bytes exist.\n        unsafe { CStr::from_bytes_with_nul_unchecked(self.buf.as_slice()) }\n    }\n}\n\nimpl<'a> TryFrom<&'a CStr> for CString {\n    type Error = AllocError;\n\n    fn try_from(cstr: &'a CStr) -> Result<CString, AllocError> {\n        let mut buf = Vec::new();\n\n        buf.try_extend_from_slice(cstr.as_bytes_with_nul())\n            .map_err(|_| AllocError)?;\n\n        // INVARIANT: The `CStr` and `CString` types have the same invariants for\n        // the string data, and we copied it over without changes.\n        Ok(CString { buf })\n    }\n}\n\n/// A convenience alias for [`core::format_args`].\n#[macro_export]\nmacro_rules! fmt {\n    ($($f:tt)*) => ( core::format_args!($($f)*) )\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}