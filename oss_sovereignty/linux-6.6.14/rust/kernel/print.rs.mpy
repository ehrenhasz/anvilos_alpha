{
  "module_name": "print.rs",
  "hash_id": "f0314e2c8c0c2b9695add32b01e1bac945c0ffa92c0c7695f1ed228b93c1a60c",
  "original_prompt": "Ingested from linux-6.6.14/rust/kernel/print.rs",
  "human_readable_source": "// SPDX-License-Identifier: GPL-2.0\n\n//! Printing facilities.\n//!\n//! C header: [`include/linux/printk.h`](../../../../include/linux/printk.h)\n//!\n//! Reference: <https://www.kernel.org/doc/html/latest/core-api/printk-basics.html>\n\nuse core::{\n    ffi::{c_char, c_void},\n    fmt,\n};\n\nuse crate::str::RawFormatter;\n\n#[cfg(CONFIG_PRINTK)]\nuse crate::bindings;\n\n// Called from `vsprintf` with format specifier `%pA`.\n#[no_mangle]\nunsafe extern \"C\" fn rust_fmt_argument(\n    buf: *mut c_char,\n    end: *mut c_char,\n    ptr: *const c_void,\n) -> *mut c_char {\n    use fmt::Write;\n    // SAFETY: The C contract guarantees that `buf` is valid if it's less than `end`.\n    let mut w = unsafe { RawFormatter::from_ptrs(buf.cast(), end.cast()) };\n    let _ = w.write_fmt(unsafe { *(ptr as *const fmt::Arguments<'_>) });\n    w.pos().cast()\n}\n\n/// Format strings.\n///\n/// Public but hidden since it should only be used from public macros.\n#[doc(hidden)]\npub mod format_strings {\n    use crate::bindings;\n\n    /// The length we copy from the `KERN_*` kernel prefixes.\n    const LENGTH_PREFIX: usize = 2;\n\n    /// The length of the fixed format strings.\n    pub const LENGTH: usize = 10;\n\n    /// Generates a fixed format string for the kernel's [`_printk`].\n    ///\n    /// The format string is always the same for a given level, i.e. for a\n    /// given `prefix`, which are the kernel's `KERN_*` constants.\n    ///\n    /// [`_printk`]: ../../../../include/linux/printk.h\n    const fn generate(is_cont: bool, prefix: &[u8; 3]) -> [u8; LENGTH] {\n        // Ensure the `KERN_*` macros are what we expect.\n        assert!(prefix[0] == b'\\x01');\n        if is_cont {\n            assert!(prefix[1] == b'c');\n        } else {\n            assert!(prefix[1] >= b'0' && prefix[1] <= b'7');\n        }\n        assert!(prefix[2] == b'\\x00');\n\n        let suffix: &[u8; LENGTH - LENGTH_PREFIX] = if is_cont {\n            b\"%pA\\0\\0\\0\\0\\0\"\n        } else {\n            b\"%s: %pA\\0\"\n        };\n\n        [\n            prefix[0], prefix[1], suffix[0], suffix[1], suffix[2], suffix[3], suffix[4], suffix[5],\n            suffix[6], suffix[7],\n        ]\n    }\n\n    // Generate the format strings at compile-time.\n    //\n    // This avoids the compiler generating the contents on the fly in the stack.\n    //\n    // Furthermore, `static` instead of `const` is used to share the strings\n    // for all the kernel.\n    pub static EMERG: [u8; LENGTH] = generate(false, bindings::KERN_EMERG);\n    pub static ALERT: [u8; LENGTH] = generate(false, bindings::KERN_ALERT);\n    pub static CRIT: [u8; LENGTH] = generate(false, bindings::KERN_CRIT);\n    pub static ERR: [u8; LENGTH] = generate(false, bindings::KERN_ERR);\n    pub static WARNING: [u8; LENGTH] = generate(false, bindings::KERN_WARNING);\n    pub static NOTICE: [u8; LENGTH] = generate(false, bindings::KERN_NOTICE);\n    pub static INFO: [u8; LENGTH] = generate(false, bindings::KERN_INFO);\n    pub static DEBUG: [u8; LENGTH] = generate(false, bindings::KERN_DEBUG);\n    pub static CONT: [u8; LENGTH] = generate(true, bindings::KERN_CONT);\n}\n\n/// Prints a message via the kernel's [`_printk`].\n///\n/// Public but hidden since it should only be used from public macros.\n///\n/// # Safety\n///\n/// The format string must be one of the ones in [`format_strings`], and\n/// the module name must be null-terminated.\n///\n/// [`_printk`]: ../../../../include/linux/_printk.h\n#[doc(hidden)]\n#[cfg_attr(not(CONFIG_PRINTK), allow(unused_variables))]\npub unsafe fn call_printk(\n    format_string: &[u8; format_strings::LENGTH],\n    module_name: &[u8],\n    args: fmt::Arguments<'_>,\n) {\n    // `_printk` does not seem to fail in any path.\n    #[cfg(CONFIG_PRINTK)]\n    unsafe {\n        bindings::_printk(\n            format_string.as_ptr() as _,\n            module_name.as_ptr(),\n            &args as *const _ as *const c_void,\n        );\n    }\n}\n\n/// Prints a message via the kernel's [`_printk`] for the `CONT` level.\n///\n/// Public but hidden since it should only be used from public macros.\n///\n/// [`_printk`]: ../../../../include/linux/printk.h\n#[doc(hidden)]\n#[cfg_attr(not(CONFIG_PRINTK), allow(unused_variables))]\npub fn call_printk_cont(args: fmt::Arguments<'_>) {\n    // `_printk` does not seem to fail in any path.\n    //\n    // SAFETY: The format string is fixed.\n    #[cfg(CONFIG_PRINTK)]\n    unsafe {\n        bindings::_printk(\n            format_strings::CONT.as_ptr() as _,\n            &args as *const _ as *const c_void,\n        );\n    }\n}\n\n/// Performs formatting and forwards the string to [`call_printk`].\n///\n/// Public but hidden since it should only be used from public macros.\n#[doc(hidden)]\n#[cfg(not(testlib))]\n#[macro_export]\n#[allow(clippy::crate_in_macro_def)]\nmacro_rules! print_macro (\n    // The non-continuation cases (most of them, e.g. `INFO`).\n    ($format_string:path, false, $($arg:tt)+) => (\n        // To remain sound, `arg`s must be expanded outside the `unsafe` block.\n        // Typically one would use a `let` binding for that; however, `format_args!`\n        // takes borrows on the arguments, but does not extend the scope of temporaries.\n        // Therefore, a `match` expression is used to keep them around, since\n        // the scrutinee is kept until the end of the `match`.\n        match format_args!($($arg)+) {\n            // SAFETY: This hidden macro should only be called by the documented\n            // printing macros which ensure the format string is one of the fixed\n            // ones. All `__LOG_PREFIX`s are null-terminated as they are generated\n            // by the `module!` proc macro or fixed values defined in a kernel\n            // crate.\n            args => unsafe {\n                $crate::print::call_printk(\n                    &$format_string,\n                    crate::__LOG_PREFIX,\n                    args,\n                );\n            }\n        }\n    );\n\n    // The `CONT` case.\n    ($format_string:path, true, $($arg:tt)+) => (\n        $crate::print::call_printk_cont(\n            format_args!($($arg)+),\n        );\n    );\n);\n\n/// Stub for doctests\n#[cfg(testlib)]\n#[macro_export]\nmacro_rules! print_macro (\n    ($format_string:path, $e:expr, $($arg:tt)+) => (\n        ()\n    );\n);\n\n// We could use a macro to generate these macros. However, doing so ends\n// up being a bit ugly: it requires the dollar token trick to escape `$` as\n// well as playing with the `doc` attribute. Furthermore, they cannot be easily\n// imported in the prelude due to [1]. So, for the moment, we just write them\n// manually, like in the C side; while keeping most of the logic in another\n// macro, i.e. [`print_macro`].\n//\n// [1]: https://github.com/rust-lang/rust/issues/52234\n\n/// Prints an emergency-level message (level 0).\n///\n/// Use this level if the system is unusable.\n///\n/// Equivalent to the kernel's [`pr_emerg`] macro.\n///\n/// Mimics the interface of [`std::print!`]. See [`core::fmt`] and\n/// `alloc::format!` for information about the formatting syntax.\n///\n/// [`pr_emerg`]: https://www.kernel.org/doc/html/latest/core-api/printk-basics.html#c.pr_emerg\n/// [`std::print!`]: https://doc.rust-lang.org/std/macro.print.html\n///\n/// # Examples\n///\n/// ```\n/// pr_emerg!(\"hello {}\\n\", \"there\");\n/// ```\n#[macro_export]\nmacro_rules! pr_emerg (\n    ($($arg:tt)*) => (\n        $crate::print_macro!($crate::print::format_strings::EMERG, false, $($arg)*)\n    )\n);\n\n/// Prints an alert-level message (level 1).\n///\n/// Use this level if action must be taken immediately.\n///\n/// Equivalent to the kernel's [`pr_alert`] macro.\n///\n/// Mimics the interface of [`std::print!`]. See [`core::fmt`] and\n/// `alloc::format!` for information about the formatting syntax.\n///\n/// [`pr_alert`]: https://www.kernel.org/doc/html/latest/core-api/printk-basics.html#c.pr_alert\n/// [`std::print!`]: https://doc.rust-lang.org/std/macro.print.html\n///\n/// # Examples\n///\n/// ```\n/// pr_alert!(\"hello {}\\n\", \"there\");\n/// ```\n#[macro_export]\nmacro_rules! pr_alert (\n    ($($arg:tt)*) => (\n        $crate::print_macro!($crate::print::format_strings::ALERT, false, $($arg)*)\n    )\n);\n\n/// Prints a critical-level message (level 2).\n///\n/// Use this level for critical conditions.\n///\n/// Equivalent to the kernel's [`pr_crit`] macro.\n///\n/// Mimics the interface of [`std::print!`]. See [`core::fmt`] and\n/// `alloc::format!` for information about the formatting syntax.\n///\n/// [`pr_crit`]: https://www.kernel.org/doc/html/latest/core-api/printk-basics.html#c.pr_crit\n/// [`std::print!`]: https://doc.rust-lang.org/std/macro.print.html\n///\n/// # Examples\n///\n/// ```\n/// pr_crit!(\"hello {}\\n\", \"there\");\n/// ```\n#[macro_export]\nmacro_rules! pr_crit (\n    ($($arg:tt)*) => (\n        $crate::print_macro!($crate::print::format_strings::CRIT, false, $($arg)*)\n    )\n);\n\n/// Prints an error-level message (level 3).\n///\n/// Use this level for error conditions.\n///\n/// Equivalent to the kernel's [`pr_err`] macro.\n///\n/// Mimics the interface of [`std::print!`]. See [`core::fmt`] and\n/// `alloc::format!` for information about the formatting syntax.\n///\n/// [`pr_err`]: https://www.kernel.org/doc/html/latest/core-api/printk-basics.html#c.pr_err\n/// [`std::print!`]: https://doc.rust-lang.org/std/macro.print.html\n///\n/// # Examples\n///\n/// ```\n/// pr_err!(\"hello {}\\n\", \"there\");\n/// ```\n#[macro_export]\nmacro_rules! pr_err (\n    ($($arg:tt)*) => (\n        $crate::print_macro!($crate::print::format_strings::ERR, false, $($arg)*)\n    )\n);\n\n/// Prints a warning-level message (level 4).\n///\n/// Use this level for warning conditions.\n///\n/// Equivalent to the kernel's [`pr_warn`] macro.\n///\n/// Mimics the interface of [`std::print!`]. See [`core::fmt`] and\n/// `alloc::format!` for information about the formatting syntax.\n///\n/// [`pr_warn`]: https://www.kernel.org/doc/html/latest/core-api/printk-basics.html#c.pr_warn\n/// [`std::print!`]: https://doc.rust-lang.org/std/macro.print.html\n///\n/// # Examples\n///\n/// ```\n/// pr_warn!(\"hello {}\\n\", \"there\");\n/// ```\n#[macro_export]\nmacro_rules! pr_warn (\n    ($($arg:tt)*) => (\n        $crate::print_macro!($crate::print::format_strings::WARNING, false, $($arg)*)\n    )\n);\n\n/// Prints a notice-level message (level 5).\n///\n/// Use this level for normal but significant conditions.\n///\n/// Equivalent to the kernel's [`pr_notice`] macro.\n///\n/// Mimics the interface of [`std::print!`]. See [`core::fmt`] and\n/// `alloc::format!` for information about the formatting syntax.\n///\n/// [`pr_notice`]: https://www.kernel.org/doc/html/latest/core-api/printk-basics.html#c.pr_notice\n/// [`std::print!`]: https://doc.rust-lang.org/std/macro.print.html\n///\n/// # Examples\n///\n/// ```\n/// pr_notice!(\"hello {}\\n\", \"there\");\n/// ```\n#[macro_export]\nmacro_rules! pr_notice (\n    ($($arg:tt)*) => (\n        $crate::print_macro!($crate::print::format_strings::NOTICE, false, $($arg)*)\n    )\n);\n\n/// Prints an info-level message (level 6).\n///\n/// Use this level for informational messages.\n///\n/// Equivalent to the kernel's [`pr_info`] macro.\n///\n/// Mimics the interface of [`std::print!`]. See [`core::fmt`] and\n/// `alloc::format!` for information about the formatting syntax.\n///\n/// [`pr_info`]: https://www.kernel.org/doc/html/latest/core-api/printk-basics.html#c.pr_info\n/// [`std::print!`]: https://doc.rust-lang.org/std/macro.print.html\n///\n/// # Examples\n///\n/// ```\n/// pr_info!(\"hello {}\\n\", \"there\");\n/// ```\n#[macro_export]\n#[doc(alias = \"print\")]\nmacro_rules! pr_info (\n    ($($arg:tt)*) => (\n        $crate::print_macro!($crate::print::format_strings::INFO, false, $($arg)*)\n    )\n);\n\n/// Prints a debug-level message (level 7).\n///\n/// Use this level for debug messages.\n///\n/// Equivalent to the kernel's [`pr_debug`] macro, except that it doesn't support dynamic debug\n/// yet.\n///\n/// Mimics the interface of [`std::print!`]. See [`core::fmt`] and\n/// `alloc::format!` for information about the formatting syntax.\n///\n/// [`pr_debug`]: https://www.kernel.org/doc/html/latest/core-api/printk-basics.html#c.pr_debug\n/// [`std::print!`]: https://doc.rust-lang.org/std/macro.print.html\n///\n/// # Examples\n///\n/// ```\n/// pr_debug!(\"hello {}\\n\", \"there\");\n/// ```\n#[macro_export]\n#[doc(alias = \"print\")]\nmacro_rules! pr_debug (\n    ($($arg:tt)*) => (\n        if cfg!(debug_assertions) {\n            $crate::print_macro!($crate::print::format_strings::DEBUG, false, $($arg)*)\n        }\n    )\n);\n\n/// Continues a previous log message in the same line.\n///\n/// Use only when continuing a previous `pr_*!` macro (e.g. [`pr_info!`]).\n///\n/// Equivalent to the kernel's [`pr_cont`] macro.\n///\n/// Mimics the interface of [`std::print!`]. See [`core::fmt`] and\n/// `alloc::format!` for information about the formatting syntax.\n///\n/// [`pr_cont`]: https://www.kernel.org/doc/html/latest/core-api/printk-basics.html#c.pr_cont\n/// [`std::print!`]: https://doc.rust-lang.org/std/macro.print.html\n///\n/// # Examples\n///\n/// ```\n/// # use kernel::pr_cont;\n/// pr_info!(\"hello\");\n/// pr_cont!(\" {}\\n\", \"there\");\n/// ```\n#[macro_export]\nmacro_rules! pr_cont (\n    ($($arg:tt)*) => (\n        $crate::print_macro!($crate::print::format_strings::CONT, true, $($arg)*)\n    )\n);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}