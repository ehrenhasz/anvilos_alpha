{
  "module_name": "error.rs",
  "hash_id": "9e3ada591e06e26fd4da8a628ff1c8c19aa13362e0eb8ae123daed2622f2d452",
  "original_prompt": "Ingested from linux-6.6.14/rust/kernel/error.rs",
  "human_readable_source": "// SPDX-License-Identifier: GPL-2.0\n\n//! Kernel errors.\n//!\n//! C header: [`include/uapi/asm-generic/errno-base.h`](../../../include/uapi/asm-generic/errno-base.h)\n\nuse crate::str::CStr;\n\nuse alloc::{\n    alloc::{AllocError, LayoutError},\n    collections::TryReserveError,\n};\n\nuse core::convert::From;\nuse core::fmt;\nuse core::num::TryFromIntError;\nuse core::str::Utf8Error;\n\n/// Contains the C-compatible error codes.\n#[rustfmt::skip]\npub mod code {\n    macro_rules! declare_err {\n        ($err:tt $(,)? $($doc:expr),+) => {\n            $(\n            #[doc = $doc]\n            )*\n            pub const $err: super::Error = super::Error(-(crate::bindings::$err as i32));\n        };\n    }\n\n    declare_err!(EPERM, \"Operation not permitted.\");\n    declare_err!(ENOENT, \"No such file or directory.\");\n    declare_err!(ESRCH, \"No such process.\");\n    declare_err!(EINTR, \"Interrupted system call.\");\n    declare_err!(EIO, \"I/O error.\");\n    declare_err!(ENXIO, \"No such device or address.\");\n    declare_err!(E2BIG, \"Argument list too long.\");\n    declare_err!(ENOEXEC, \"Exec format error.\");\n    declare_err!(EBADF, \"Bad file number.\");\n    declare_err!(ECHILD, \"No child processes.\");\n    declare_err!(EAGAIN, \"Try again.\");\n    declare_err!(ENOMEM, \"Out of memory.\");\n    declare_err!(EACCES, \"Permission denied.\");\n    declare_err!(EFAULT, \"Bad address.\");\n    declare_err!(ENOTBLK, \"Block device required.\");\n    declare_err!(EBUSY, \"Device or resource busy.\");\n    declare_err!(EEXIST, \"File exists.\");\n    declare_err!(EXDEV, \"Cross-device link.\");\n    declare_err!(ENODEV, \"No such device.\");\n    declare_err!(ENOTDIR, \"Not a directory.\");\n    declare_err!(EISDIR, \"Is a directory.\");\n    declare_err!(EINVAL, \"Invalid argument.\");\n    declare_err!(ENFILE, \"File table overflow.\");\n    declare_err!(EMFILE, \"Too many open files.\");\n    declare_err!(ENOTTY, \"Not a typewriter.\");\n    declare_err!(ETXTBSY, \"Text file busy.\");\n    declare_err!(EFBIG, \"File too large.\");\n    declare_err!(ENOSPC, \"No space left on device.\");\n    declare_err!(ESPIPE, \"Illegal seek.\");\n    declare_err!(EROFS, \"Read-only file system.\");\n    declare_err!(EMLINK, \"Too many links.\");\n    declare_err!(EPIPE, \"Broken pipe.\");\n    declare_err!(EDOM, \"Math argument out of domain of func.\");\n    declare_err!(ERANGE, \"Math result not representable.\");\n    declare_err!(ERESTARTSYS, \"Restart the system call.\");\n    declare_err!(ERESTARTNOINTR, \"System call was interrupted by a signal and will be restarted.\");\n    declare_err!(ERESTARTNOHAND, \"Restart if no handler.\");\n    declare_err!(ENOIOCTLCMD, \"No ioctl command.\");\n    declare_err!(ERESTART_RESTARTBLOCK, \"Restart by calling sys_restart_syscall.\");\n    declare_err!(EPROBE_DEFER, \"Driver requests probe retry.\");\n    declare_err!(EOPENSTALE, \"Open found a stale dentry.\");\n    declare_err!(ENOPARAM, \"Parameter not supported.\");\n    declare_err!(EBADHANDLE, \"Illegal NFS file handle.\");\n    declare_err!(ENOTSYNC, \"Update synchronization mismatch.\");\n    declare_err!(EBADCOOKIE, \"Cookie is stale.\");\n    declare_err!(ENOTSUPP, \"Operation is not supported.\");\n    declare_err!(ETOOSMALL, \"Buffer or request is too small.\");\n    declare_err!(ESERVERFAULT, \"An untranslatable error occurred.\");\n    declare_err!(EBADTYPE, \"Type not supported by server.\");\n    declare_err!(EJUKEBOX, \"Request initiated, but will not complete before timeout.\");\n    declare_err!(EIOCBQUEUED, \"iocb queued, will get completion event.\");\n    declare_err!(ERECALLCONFLICT, \"Conflict with recalled state.\");\n    declare_err!(ENOGRACE, \"NFS file lock reclaim refused.\");\n}\n\n/// Generic integer kernel error.\n///\n/// The kernel defines a set of integer generic error codes based on C and\n/// POSIX ones. These codes may have a more specific meaning in some contexts.\n///\n/// # Invariants\n///\n/// The value is a valid `errno` (i.e. `>= -MAX_ERRNO && < 0`).\n#[derive(Clone, Copy, PartialEq, Eq)]\npub struct Error(core::ffi::c_int);\n\nimpl Error {\n    /// Creates an [`Error`] from a kernel error code.\n    ///\n    /// It is a bug to pass an out-of-range `errno`. `EINVAL` would\n    /// be returned in such a case.\n    pub(crate) fn from_errno(errno: core::ffi::c_int) -> Error {\n        if errno < -(bindings::MAX_ERRNO as i32) || errno >= 0 {\n            // TODO: Make it a `WARN_ONCE` once available.\n            crate::pr_warn!(\n                \"attempted to create `Error` with out of range `errno`: {}\",\n                errno\n            );\n            return code::EINVAL;\n        }\n\n        // INVARIANT: The check above ensures the type invariant\n        // will hold.\n        Error(errno)\n    }\n\n    /// Creates an [`Error`] from a kernel error code.\n    ///\n    /// # Safety\n    ///\n    /// `errno` must be within error code range (i.e. `>= -MAX_ERRNO && < 0`).\n    unsafe fn from_errno_unchecked(errno: core::ffi::c_int) -> Error {\n        // INVARIANT: The contract ensures the type invariant\n        // will hold.\n        Error(errno)\n    }\n\n    /// Returns the kernel error code.\n    pub fn to_errno(self) -> core::ffi::c_int {\n        self.0\n    }\n\n    /// Returns the error encoded as a pointer.\n    #[allow(dead_code)]\n    pub(crate) fn to_ptr<T>(self) -> *mut T {\n        // SAFETY: `self.0` is a valid error due to its invariant.\n        unsafe { bindings::ERR_PTR(self.0.into()) as *mut _ }\n    }\n\n    /// Returns a string representing the error, if one exists.\n    #[cfg(not(testlib))]\n    pub fn name(&self) -> Option<&'static CStr> {\n        // SAFETY: Just an FFI call, there are no extra safety requirements.\n        let ptr = unsafe { bindings::errname(-self.0) };\n        if ptr.is_null() {\n            None\n        } else {\n            // SAFETY: The string returned by `errname` is static and `NUL`-terminated.\n            Some(unsafe { CStr::from_char_ptr(ptr) })\n        }\n    }\n\n    /// Returns a string representing the error, if one exists.\n    ///\n    /// When `testlib` is configured, this always returns `None` to avoid the dependency on a\n    /// kernel function so that tests that use this (e.g., by calling [`Result::unwrap`]) can still\n    /// run in userspace.\n    #[cfg(testlib)]\n    pub fn name(&self) -> Option<&'static CStr> {\n        None\n    }\n}\n\nimpl fmt::Debug for Error {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        match self.name() {\n            // Print out number if no name can be found.\n            None => f.debug_tuple(\"Error\").field(&-self.0).finish(),\n            // SAFETY: These strings are ASCII-only.\n            Some(name) => f\n                .debug_tuple(unsafe { core::str::from_utf8_unchecked(name) })\n                .finish(),\n        }\n    }\n}\n\nimpl From<AllocError> for Error {\n    fn from(_: AllocError) -> Error {\n        code::ENOMEM\n    }\n}\n\nimpl From<TryFromIntError> for Error {\n    fn from(_: TryFromIntError) -> Error {\n        code::EINVAL\n    }\n}\n\nimpl From<Utf8Error> for Error {\n    fn from(_: Utf8Error) -> Error {\n        code::EINVAL\n    }\n}\n\nimpl From<TryReserveError> for Error {\n    fn from(_: TryReserveError) -> Error {\n        code::ENOMEM\n    }\n}\n\nimpl From<LayoutError> for Error {\n    fn from(_: LayoutError) -> Error {\n        code::ENOMEM\n    }\n}\n\nimpl From<core::fmt::Error> for Error {\n    fn from(_: core::fmt::Error) -> Error {\n        code::EINVAL\n    }\n}\n\nimpl From<core::convert::Infallible> for Error {\n    fn from(e: core::convert::Infallible) -> Error {\n        match e {}\n    }\n}\n\n/// A [`Result`] with an [`Error`] error type.\n///\n/// To be used as the return type for functions that may fail.\n///\n/// # Error codes in C and Rust\n///\n/// In C, it is common that functions indicate success or failure through\n/// their return value; modifying or returning extra data through non-`const`\n/// pointer parameters. In particular, in the kernel, functions that may fail\n/// typically return an `int` that represents a generic error code. We model\n/// those as [`Error`].\n///\n/// In Rust, it is idiomatic to model functions that may fail as returning\n/// a [`Result`]. Since in the kernel many functions return an error code,\n/// [`Result`] is a type alias for a [`core::result::Result`] that uses\n/// [`Error`] as its error type.\n///\n/// Note that even if a function does not return anything when it succeeds,\n/// it should still be modeled as returning a `Result` rather than\n/// just an [`Error`].\npub type Result<T = (), E = Error> = core::result::Result<T, E>;\n\n/// Converts an integer as returned by a C kernel function to an error if it's negative, and\n/// `Ok(())` otherwise.\npub fn to_result(err: core::ffi::c_int) -> Result {\n    if err < 0 {\n        Err(Error::from_errno(err))\n    } else {\n        Ok(())\n    }\n}\n\n/// Transform a kernel \"error pointer\" to a normal pointer.\n///\n/// Some kernel C API functions return an \"error pointer\" which optionally\n/// embeds an `errno`. Callers are supposed to check the returned pointer\n/// for errors. This function performs the check and converts the \"error pointer\"\n/// to a normal pointer in an idiomatic fashion.\n///\n/// # Examples\n///\n/// ```ignore\n/// # use kernel::from_err_ptr;\n/// # use kernel::bindings;\n/// fn devm_platform_ioremap_resource(\n///     pdev: &mut PlatformDevice,\n///     index: u32,\n/// ) -> Result<*mut core::ffi::c_void> {\n///     // SAFETY: FFI call.\n///     unsafe {\n///         from_err_ptr(bindings::devm_platform_ioremap_resource(\n///             pdev.to_ptr(),\n///             index,\n///         ))\n///     }\n/// }\n/// ```\n// TODO: Remove `dead_code` marker once an in-kernel client is available.\n#[allow(dead_code)]\npub(crate) fn from_err_ptr<T>(ptr: *mut T) -> Result<*mut T> {\n    // CAST: Casting a pointer to `*const core::ffi::c_void` is always valid.\n    let const_ptr: *const core::ffi::c_void = ptr.cast();\n    // SAFETY: The FFI function does not deref the pointer.\n    if unsafe { bindings::IS_ERR(const_ptr) } {\n        // SAFETY: The FFI function does not deref the pointer.\n        let err = unsafe { bindings::PTR_ERR(const_ptr) };\n        // CAST: If `IS_ERR()` returns `true`,\n        // then `PTR_ERR()` is guaranteed to return a\n        // negative value greater-or-equal to `-bindings::MAX_ERRNO`,\n        // which always fits in an `i16`, as per the invariant above.\n        // And an `i16` always fits in an `i32`. So casting `err` to\n        // an `i32` can never overflow, and is always valid.\n        //\n        // SAFETY: `IS_ERR()` ensures `err` is a\n        // negative value greater-or-equal to `-bindings::MAX_ERRNO`.\n        #[allow(clippy::unnecessary_cast)]\n        return Err(unsafe { Error::from_errno_unchecked(err as core::ffi::c_int) });\n    }\n    Ok(ptr)\n}\n\n/// Calls a closure returning a [`crate::error::Result<T>`] and converts the result to\n/// a C integer result.\n///\n/// This is useful when calling Rust functions that return [`crate::error::Result<T>`]\n/// from inside `extern \"C\"` functions that need to return an integer error result.\n///\n/// `T` should be convertible from an `i16` via `From<i16>`.\n///\n/// # Examples\n///\n/// ```ignore\n/// # use kernel::from_result;\n/// # use kernel::bindings;\n/// unsafe extern \"C\" fn probe_callback(\n///     pdev: *mut bindings::platform_device,\n/// ) -> core::ffi::c_int {\n///     from_result(|| {\n///         let ptr = devm_alloc(pdev)?;\n///         bindings::platform_set_drvdata(pdev, ptr);\n///         Ok(0)\n///     })\n/// }\n/// ```\n// TODO: Remove `dead_code` marker once an in-kernel client is available.\n#[allow(dead_code)]\npub(crate) fn from_result<T, F>(f: F) -> T\nwhere\n    T: From<i16>,\n    F: FnOnce() -> Result<T>,\n{\n    match f() {\n        Ok(v) => v,\n        // NO-OVERFLOW: negative `errno`s are no smaller than `-bindings::MAX_ERRNO`,\n        // `-bindings::MAX_ERRNO` fits in an `i16` as per invariant above,\n        // therefore a negative `errno` always fits in an `i16` and will not overflow.\n        Err(e) => T::from(e.to_errno() as i16),\n    }\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}