{
  "module_name": "std_vendor.rs",
  "hash_id": "9432f3f2e93f8b814965fd9c44001b28e2a3ce1067d2c880adaa90b0742239e4",
  "original_prompt": "Ingested from linux-6.6.14/rust/kernel/std_vendor.rs",
  "human_readable_source": "// SPDX-License-Identifier: Apache-2.0 OR MIT\n\n//! The contents of this file come from the Rust standard library, hosted in\n//! the <https://github.com/rust-lang/rust> repository, licensed under\n//! \"Apache-2.0 OR MIT\" and adapted for kernel use. For copyright details,\n//! see <https://github.com/rust-lang/rust/blob/master/COPYRIGHT>.\n\n/// [`std::dbg`], but using [`pr_info`] instead of [`eprintln`].\n///\n/// Prints and returns the value of a given expression for quick and dirty\n/// debugging.\n///\n/// An example:\n///\n/// ```rust\n/// let a = 2;\n/// # #[allow(clippy::dbg_macro)]\n/// let b = dbg!(a * 2) + 1;\n/// //      ^-- prints: [src/main.rs:2] a * 2 = 4\n/// assert_eq!(b, 5);\n/// ```\n///\n/// The macro works by using the `Debug` implementation of the type of\n/// the given expression to print the value with [`printk`] along with the\n/// source location of the macro invocation as well as the source code\n/// of the expression.\n///\n/// Invoking the macro on an expression moves and takes ownership of it\n/// before returning the evaluated expression unchanged. If the type\n/// of the expression does not implement `Copy` and you don't want\n/// to give up ownership, you can instead borrow with `dbg!(&expr)`\n/// for some expression `expr`.\n///\n/// The `dbg!` macro works exactly the same in release builds.\n/// This is useful when debugging issues that only occur in release\n/// builds or when debugging in release mode is significantly faster.\n///\n/// Note that the macro is intended as a temporary debugging tool to be\n/// used during development. Therefore, avoid committing `dbg!` macro\n/// invocations into the kernel tree.\n///\n/// For debug output that is intended to be kept in the kernel tree,\n/// use [`pr_debug`] and similar facilities instead.\n///\n/// # Stability\n///\n/// The exact output printed by this macro should not be relied upon\n/// and is subject to future changes.\n///\n/// # Further examples\n///\n/// With a method call:\n///\n/// ```rust\n/// # #[allow(clippy::dbg_macro)]\n/// fn foo(n: usize) {\n///     if dbg!(n.checked_sub(4)).is_some() {\n///         // ...\n///     }\n/// }\n///\n/// foo(3)\n/// ```\n///\n/// This prints to the kernel log:\n///\n/// ```text,ignore\n/// [src/main.rs:4] n.checked_sub(4) = None\n/// ```\n///\n/// Naive factorial implementation:\n///\n/// ```rust\n/// # #[allow(clippy::dbg_macro)]\n/// # {\n/// fn factorial(n: u32) -> u32 {\n///     if dbg!(n <= 1) {\n///         dbg!(1)\n///     } else {\n///         dbg!(n * factorial(n - 1))\n///     }\n/// }\n///\n/// dbg!(factorial(4));\n/// # }\n/// ```\n///\n/// This prints to the kernel log:\n///\n/// ```text,ignore\n/// [src/main.rs:3] n <= 1 = false\n/// [src/main.rs:3] n <= 1 = false\n/// [src/main.rs:3] n <= 1 = false\n/// [src/main.rs:3] n <= 1 = true\n/// [src/main.rs:4] 1 = 1\n/// [src/main.rs:5] n * factorial(n - 1) = 2\n/// [src/main.rs:5] n * factorial(n - 1) = 6\n/// [src/main.rs:5] n * factorial(n - 1) = 24\n/// [src/main.rs:11] factorial(4) = 24\n/// ```\n///\n/// The `dbg!(..)` macro moves the input:\n///\n/// ```ignore\n/// /// A wrapper around `usize` which importantly is not Copyable.\n/// #[derive(Debug)]\n/// struct NoCopy(usize);\n///\n/// let a = NoCopy(42);\n/// let _ = dbg!(a); // <-- `a` is moved here.\n/// let _ = dbg!(a); // <-- `a` is moved again; error!\n/// ```\n///\n/// You can also use `dbg!()` without a value to just print the\n/// file and line whenever it's reached.\n///\n/// Finally, if you want to `dbg!(..)` multiple values, it will treat them as\n/// a tuple (and return it, too):\n///\n/// ```\n/// # #[allow(clippy::dbg_macro)]\n/// assert_eq!(dbg!(1usize, 2u32), (1, 2));\n/// ```\n///\n/// However, a single argument with a trailing comma will still not be treated\n/// as a tuple, following the convention of ignoring trailing commas in macro\n/// invocations. You can use a 1-tuple directly if you need one:\n///\n/// ```\n/// # #[allow(clippy::dbg_macro)]\n/// # {\n/// assert_eq!(1, dbg!(1u32,)); // trailing comma ignored\n/// assert_eq!((1,), dbg!((1u32,))); // 1-tuple\n/// # }\n/// ```\n///\n/// [`std::dbg`]: https://doc.rust-lang.org/std/macro.dbg.html\n/// [`eprintln`]: https://doc.rust-lang.org/std/macro.eprintln.html\n/// [`printk`]: https://www.kernel.org/doc/html/latest/core-api/printk-basics.html\n/// [`pr_info`]: crate::pr_info!\n/// [`pr_debug`]: crate::pr_debug!\n#[macro_export]\nmacro_rules! dbg {\n    // NOTE: We cannot use `concat!` to make a static string as a format argument\n    // of `pr_info!` because `file!` could contain a `{` or\n    // `$val` expression could be a block (`{ .. }`), in which case the `pr_info!`\n    // will be malformed.\n    () => {\n        $crate::pr_info!(\"[{}:{}]\\n\", ::core::file!(), ::core::line!())\n    };\n    ($val:expr $(,)?) => {\n        // Use of `match` here is intentional because it affects the lifetimes\n        // of temporaries - https://stackoverflow.com/a/48732525/1063961\n        match $val {\n            tmp => {\n                $crate::pr_info!(\"[{}:{}] {} = {:#?}\\n\",\n                    ::core::file!(), ::core::line!(), ::core::stringify!($val), &tmp);\n                tmp\n            }\n        }\n    };\n    ($($val:expr),+ $(,)?) => {\n        ($($crate::dbg!($val)),+,)\n    };\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}