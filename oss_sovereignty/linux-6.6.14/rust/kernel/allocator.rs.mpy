{
  "module_name": "allocator.rs",
  "hash_id": "fbd9642868024ca2cf740a9ad14105f52a754872f7b1cc618e48d16fc8e21ef1",
  "original_prompt": "Ingested from linux-6.6.14/rust/kernel/allocator.rs",
  "human_readable_source": "// SPDX-License-Identifier: GPL-2.0\n\n//! Allocator support.\n\nuse core::alloc::{GlobalAlloc, Layout};\nuse core::ptr;\n\nuse crate::bindings;\n\nstruct KernelAllocator;\n\n/// Calls `krealloc` with a proper size to alloc a new object aligned to `new_layout`'s alignment.\n///\n/// # Safety\n///\n/// - `ptr` can be either null or a pointer which has been allocated by this allocator.\n/// - `new_layout` must have a non-zero size.\nunsafe fn krealloc_aligned(ptr: *mut u8, new_layout: Layout, flags: bindings::gfp_t) -> *mut u8 {\n    // Customized layouts from `Layout::from_size_align()` can have size < align, so pad first.\n    let layout = new_layout.pad_to_align();\n\n    let mut size = layout.size();\n\n    if layout.align() > bindings::BINDINGS_ARCH_SLAB_MINALIGN {\n        // The alignment requirement exceeds the slab guarantee, thus try to enlarge the size\n        // to use the \"power-of-two\" size/alignment guarantee (see comments in `kmalloc()` for\n        // more information).\n        //\n        // Note that `layout.size()` (after padding) is guaranteed to be a multiple of\n        // `layout.align()`, so `next_power_of_two` gives enough alignment guarantee.\n        size = size.next_power_of_two();\n    }\n\n    // SAFETY:\n    // - `ptr` is either null or a pointer returned from a previous `k{re}alloc()` by the\n    //   function safety requirement.\n    // - `size` is greater than 0 since it's either a `layout.size()` (which cannot be zero\n    //    according to the function safety requirement) or a result from `next_power_of_two()`.\n    unsafe { bindings::krealloc(ptr as *const core::ffi::c_void, size, flags) as *mut u8 }\n}\n\nunsafe impl GlobalAlloc for KernelAllocator {\n    unsafe fn alloc(&self, layout: Layout) -> *mut u8 {\n        // SAFETY: `ptr::null_mut()` is null and `layout` has a non-zero size by the function safety\n        // requirement.\n        unsafe { krealloc_aligned(ptr::null_mut(), layout, bindings::GFP_KERNEL) }\n    }\n\n    unsafe fn dealloc(&self, ptr: *mut u8, _layout: Layout) {\n        unsafe {\n            bindings::kfree(ptr as *const core::ffi::c_void);\n        }\n    }\n\n    unsafe fn realloc(&self, ptr: *mut u8, layout: Layout, new_size: usize) -> *mut u8 {\n        // SAFETY:\n        // - `new_size`, when rounded up to the nearest multiple of `layout.align()`, will not\n        //   overflow `isize` by the function safety requirement.\n        // - `layout.align()` is a proper alignment (i.e. not zero and must be a power of two).\n        let layout = unsafe { Layout::from_size_align_unchecked(new_size, layout.align()) };\n\n        // SAFETY:\n        // - `ptr` is either null or a pointer allocated by this allocator by the function safety\n        //   requirement.\n        // - the size of `layout` is not zero because `new_size` is not zero by the function safety\n        //   requirement.\n        unsafe { krealloc_aligned(ptr, layout, bindings::GFP_KERNEL) }\n    }\n\n    unsafe fn alloc_zeroed(&self, layout: Layout) -> *mut u8 {\n        // SAFETY: `ptr::null_mut()` is null and `layout` has a non-zero size by the function safety\n        // requirement.\n        unsafe {\n            krealloc_aligned(\n                ptr::null_mut(),\n                layout,\n                bindings::GFP_KERNEL | bindings::__GFP_ZERO,\n            )\n        }\n    }\n}\n\n#[global_allocator]\nstatic ALLOCATOR: KernelAllocator = KernelAllocator;\n\n// See <https://github.com/rust-lang/rust/pull/86844>.\n#[no_mangle]\nstatic __rust_no_alloc_shim_is_unstable: u8 = 0;\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}