{
  "module_name": "task.rs",
  "hash_id": "dff1de78461c18d7e2e3d8c6e7bc4ad7168a1bb932d32f1c8144c0d20c30c4d1",
  "original_prompt": "Ingested from linux-6.6.14/rust/kernel/task.rs",
  "human_readable_source": "// SPDX-License-Identifier: GPL-2.0\n\n//! Tasks (threads and processes).\n//!\n//! C header: [`include/linux/sched.h`](../../../../include/linux/sched.h).\n\nuse crate::{bindings, types::Opaque};\nuse core::{marker::PhantomData, ops::Deref, ptr};\n\n/// Returns the currently running task.\n#[macro_export]\nmacro_rules! current {\n    () => {\n        // SAFETY: Deref + addr-of below create a temporary `TaskRef` that cannot outlive the\n        // caller.\n        unsafe { &*$crate::task::Task::current() }\n    };\n}\n\n/// Wraps the kernel's `struct task_struct`.\n///\n/// # Invariants\n///\n/// All instances are valid tasks created by the C portion of the kernel.\n///\n/// Instances of this type are always ref-counted, that is, a call to `get_task_struct` ensures\n/// that the allocation remains valid at least until the matching call to `put_task_struct`.\n///\n/// # Examples\n///\n/// The following is an example of getting the PID of the current thread with zero additional cost\n/// when compared to the C version:\n///\n/// ```\n/// let pid = current!().pid();\n/// ```\n///\n/// Getting the PID of the current process, also zero additional cost:\n///\n/// ```\n/// let pid = current!().group_leader().pid();\n/// ```\n///\n/// Getting the current task and storing it in some struct. The reference count is automatically\n/// incremented when creating `State` and decremented when it is dropped:\n///\n/// ```\n/// use kernel::{task::Task, types::ARef};\n///\n/// struct State {\n///     creator: ARef<Task>,\n///     index: u32,\n/// }\n///\n/// impl State {\n///     fn new() -> Self {\n///         Self {\n///             creator: current!().into(),\n///             index: 0,\n///         }\n///     }\n/// }\n/// ```\n#[repr(transparent)]\npub struct Task(pub(crate) Opaque<bindings::task_struct>);\n\n// SAFETY: By design, the only way to access a `Task` is via the `current` function or via an\n// `ARef<Task>` obtained through the `AlwaysRefCounted` impl. This means that the only situation in\n// which a `Task` can be accessed mutably is when the refcount drops to zero and the destructor\n// runs. It is safe for that to happen on any thread, so it is ok for this type to be `Send`.\nunsafe impl Send for Task {}\n\n// SAFETY: It's OK to access `Task` through shared references from other threads because we're\n// either accessing properties that don't change (e.g., `pid`, `group_leader`) or that are properly\n// synchronised by C code (e.g., `signal_pending`).\nunsafe impl Sync for Task {}\n\n/// The type of process identifiers (PIDs).\ntype Pid = bindings::pid_t;\n\nimpl Task {\n    /// Returns a task reference for the currently executing task/thread.\n    ///\n    /// The recommended way to get the current task/thread is to use the\n    /// [`current`](crate::current) macro because it is safe.\n    ///\n    /// # Safety\n    ///\n    /// Callers must ensure that the returned object doesn't outlive the current task/thread.\n    pub unsafe fn current() -> impl Deref<Target = Task> {\n        struct TaskRef<'a> {\n            task: &'a Task,\n            _not_send: PhantomData<*mut ()>,\n        }\n\n        impl Deref for TaskRef<'_> {\n            type Target = Task;\n\n            fn deref(&self) -> &Self::Target {\n                self.task\n            }\n        }\n\n        // SAFETY: Just an FFI call with no additional safety requirements.\n        let ptr = unsafe { bindings::get_current() };\n\n        TaskRef {\n            // SAFETY: If the current thread is still running, the current task is valid. Given\n            // that `TaskRef` is not `Send`, we know it cannot be transferred to another thread\n            // (where it could potentially outlive the caller).\n            task: unsafe { &*ptr.cast() },\n            _not_send: PhantomData,\n        }\n    }\n\n    /// Returns the group leader of the given task.\n    pub fn group_leader(&self) -> &Task {\n        // SAFETY: By the type invariant, we know that `self.0` is a valid task. Valid tasks always\n        // have a valid group_leader.\n        let ptr = unsafe { *ptr::addr_of!((*self.0.get()).group_leader) };\n\n        // SAFETY: The lifetime of the returned task reference is tied to the lifetime of `self`,\n        // and given that a task has a reference to its group leader, we know it must be valid for\n        // the lifetime of the returned task reference.\n        unsafe { &*ptr.cast() }\n    }\n\n    /// Returns the PID of the given task.\n    pub fn pid(&self) -> Pid {\n        // SAFETY: By the type invariant, we know that `self.0` is a valid task. Valid tasks always\n        // have a valid pid.\n        unsafe { *ptr::addr_of!((*self.0.get()).pid) }\n    }\n\n    /// Determines whether the given task has pending signals.\n    pub fn signal_pending(&self) -> bool {\n        // SAFETY: By the type invariant, we know that `self.0` is valid.\n        unsafe { bindings::signal_pending(self.0.get()) != 0 }\n    }\n\n    /// Wakes up the task.\n    pub fn wake_up(&self) {\n        // SAFETY: By the type invariant, we know that `self.0.get()` is non-null and valid.\n        // And `wake_up_process` is safe to be called for any valid task, even if the task is\n        // running.\n        unsafe { bindings::wake_up_process(self.0.get()) };\n    }\n}\n\n// SAFETY: The type invariants guarantee that `Task` is always ref-counted.\nunsafe impl crate::types::AlwaysRefCounted for Task {\n    fn inc_ref(&self) {\n        // SAFETY: The existence of a shared reference means that the refcount is nonzero.\n        unsafe { bindings::get_task_struct(self.0.get()) };\n    }\n\n    unsafe fn dec_ref(obj: ptr::NonNull<Self>) {\n        // SAFETY: The safety requirements guarantee that the refcount is nonzero.\n        unsafe { bindings::put_task_struct(obj.cast().as_ptr()) }\n    }\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}