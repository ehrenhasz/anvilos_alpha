{
  "module_name": "kunit.rs",
  "hash_id": "8b952cf427be66b297fbea47a0d61f70cc7474fb3138bcba30ba53f20ee3e88f",
  "original_prompt": "Ingested from linux-6.6.14/rust/kernel/kunit.rs",
  "human_readable_source": "// SPDX-License-Identifier: GPL-2.0\n\n//! KUnit-based macros for Rust unit tests.\n//!\n//! C header: [`include/kunit/test.h`](../../../../../include/kunit/test.h)\n//!\n//! Reference: <https://docs.kernel.org/dev-tools/kunit/index.html>\n\nuse core::{ffi::c_void, fmt};\n\n/// Prints a KUnit error-level message.\n///\n/// Public but hidden since it should only be used from KUnit generated code.\n#[doc(hidden)]\npub fn err(args: fmt::Arguments<'_>) {\n    // SAFETY: The format string is null-terminated and the `%pA` specifier matches the argument we\n    // are passing.\n    #[cfg(CONFIG_PRINTK)]\n    unsafe {\n        bindings::_printk(\n            b\"\\x013%pA\\0\".as_ptr() as _,\n            &args as *const _ as *const c_void,\n        );\n    }\n}\n\n/// Prints a KUnit info-level message.\n///\n/// Public but hidden since it should only be used from KUnit generated code.\n#[doc(hidden)]\npub fn info(args: fmt::Arguments<'_>) {\n    // SAFETY: The format string is null-terminated and the `%pA` specifier matches the argument we\n    // are passing.\n    #[cfg(CONFIG_PRINTK)]\n    unsafe {\n        bindings::_printk(\n            b\"\\x016%pA\\0\".as_ptr() as _,\n            &args as *const _ as *const c_void,\n        );\n    }\n}\n\n/// Asserts that a boolean expression is `true` at runtime.\n///\n/// Public but hidden since it should only be used from generated tests.\n///\n/// Unlike the one in `core`, this one does not panic; instead, it is mapped to the KUnit\n/// facilities. See [`assert!`] for more details.\n#[doc(hidden)]\n#[macro_export]\nmacro_rules! kunit_assert {\n    ($name:literal, $file:literal, $diff:expr, $condition:expr $(,)?) => {\n        'out: {\n            // Do nothing if the condition is `true`.\n            if $condition {\n                break 'out;\n            }\n\n            static FILE: &'static $crate::str::CStr = $crate::c_str!($file);\n            static LINE: i32 = core::line!() as i32 - $diff;\n            static CONDITION: &'static $crate::str::CStr = $crate::c_str!(stringify!($condition));\n\n            // SAFETY: FFI call without safety requirements.\n            let kunit_test = unsafe { $crate::bindings::kunit_get_current_test() };\n            if kunit_test.is_null() {\n                // The assertion failed but this task is not running a KUnit test, so we cannot call\n                // KUnit, but at least print an error to the kernel log. This may happen if this\n                // macro is called from an spawned thread in a test (see\n                // `scripts/rustdoc_test_gen.rs`) or if some non-test code calls this macro by\n                // mistake (it is hidden to prevent that).\n                //\n                // This mimics KUnit's failed assertion format.\n                $crate::kunit::err(format_args!(\n                    \"    # {}: ASSERTION FAILED at {FILE}:{LINE}\\n\",\n                    $name\n                ));\n                $crate::kunit::err(format_args!(\n                    \"    Expected {CONDITION} to be true, but is false\\n\"\n                ));\n                $crate::kunit::err(format_args!(\n                    \"    Failure not reported to KUnit since this is a non-KUnit task\\n\"\n                ));\n                break 'out;\n            }\n\n            #[repr(transparent)]\n            struct Location($crate::bindings::kunit_loc);\n\n            #[repr(transparent)]\n            struct UnaryAssert($crate::bindings::kunit_unary_assert);\n\n            // SAFETY: There is only a static instance and in that one the pointer field points to\n            // an immutable C string.\n            unsafe impl Sync for Location {}\n\n            // SAFETY: There is only a static instance and in that one the pointer field points to\n            // an immutable C string.\n            unsafe impl Sync for UnaryAssert {}\n\n            static LOCATION: Location = Location($crate::bindings::kunit_loc {\n                file: FILE.as_char_ptr(),\n                line: LINE,\n            });\n            static ASSERTION: UnaryAssert = UnaryAssert($crate::bindings::kunit_unary_assert {\n                assert: $crate::bindings::kunit_assert {},\n                condition: CONDITION.as_char_ptr(),\n                expected_true: true,\n            });\n\n            // SAFETY:\n            //   - FFI call.\n            //   - The `kunit_test` pointer is valid because we got it from\n            //     `kunit_get_current_test()` and it was not null. This means we are in a KUnit\n            //     test, and that the pointer can be passed to KUnit functions and assertions.\n            //   - The string pointers (`file` and `condition` above) point to null-terminated\n            //     strings since they are `CStr`s.\n            //   - The function pointer (`format`) points to the proper function.\n            //   - The pointers passed will remain valid since they point to `static`s.\n            //   - The format string is allowed to be null.\n            //   - There are, however, problems with this: first of all, this will end up stopping\n            //     the thread, without running destructors. While that is problematic in itself,\n            //     it is considered UB to have what is effectively a forced foreign unwind\n            //     with `extern \"C\"` ABI. One could observe the stack that is now gone from\n            //     another thread. We should avoid pinning stack variables to prevent library UB,\n            //     too. For the moment, given that test failures are reported immediately before the\n            //     next test runs, that test failures should be fixed and that KUnit is explicitly\n            //     documented as not suitable for production environments, we feel it is reasonable.\n            unsafe {\n                $crate::bindings::__kunit_do_failed_assertion(\n                    kunit_test,\n                    core::ptr::addr_of!(LOCATION.0),\n                    $crate::bindings::kunit_assert_type_KUNIT_ASSERTION,\n                    core::ptr::addr_of!(ASSERTION.0.assert),\n                    Some($crate::bindings::kunit_unary_assert_format),\n                    core::ptr::null(),\n                );\n            }\n\n            // SAFETY: FFI call; the `test` pointer is valid because this hidden macro should only\n            // be called by the generated documentation tests which forward the test pointer given\n            // by KUnit.\n            unsafe {\n                $crate::bindings::__kunit_abort(kunit_test);\n            }\n        }\n    };\n}\n\n/// Asserts that two expressions are equal to each other (using [`PartialEq`]).\n///\n/// Public but hidden since it should only be used from generated tests.\n///\n/// Unlike the one in `core`, this one does not panic; instead, it is mapped to the KUnit\n/// facilities. See [`assert!`] for more details.\n#[doc(hidden)]\n#[macro_export]\nmacro_rules! kunit_assert_eq {\n    ($name:literal, $file:literal, $diff:expr, $left:expr, $right:expr $(,)?) => {{\n        // For the moment, we just forward to the expression assert because, for binary asserts,\n        // KUnit supports only a few types (e.g. integers).\n        $crate::kunit_assert!($name, $file, $diff, $left == $right);\n    }};\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}