{
  "module_name": "mei-amt-version.c",
  "hash_id": "5d6351a372c92e52c63aaf3bd3ed62fb2737063a307e748e7ad37d30f2a2f4de",
  "original_prompt": "Ingested from linux-6.6.14/samples/mei/mei-amt-version.c",
  "human_readable_source": " \n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <fcntl.h>\n#include <sys/ioctl.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdint.h>\n#include <stdbool.h>\n#include <bits/wordsize.h>\n#include <linux/mei.h>\n\n \n\n#define mei_msg(_me, fmt, ARGS...) do {         \\\n\tif (_me->verbose)                       \\\n\t\tfprintf(stderr, fmt, ##ARGS);\t\\\n} while (0)\n\n#define mei_err(_me, fmt, ARGS...) do {         \\\n\tfprintf(stderr, \"Error: \" fmt, ##ARGS); \\\n} while (0)\n\nstruct mei {\n\tuuid_le guid;\n\tbool initialized;\n\tbool verbose;\n\tunsigned int buf_size;\n\tunsigned char prot_ver;\n\tint fd;\n};\n\nstatic void mei_deinit(struct mei *cl)\n{\n\tif (cl->fd != -1)\n\t\tclose(cl->fd);\n\tcl->fd = -1;\n\tcl->buf_size = 0;\n\tcl->prot_ver = 0;\n\tcl->initialized = false;\n}\n\nstatic bool mei_init(struct mei *me, const uuid_le *guid,\n\t\tunsigned char req_protocol_version, bool verbose)\n{\n\tint result;\n\tstruct mei_client *cl;\n\tstruct mei_connect_client_data data;\n\n\tme->verbose = verbose;\n\n\tme->fd = open(\"/dev/mei0\", O_RDWR);\n\tif (me->fd == -1) {\n\t\tmei_err(me, \"Cannot establish a handle to the Intel MEI driver\\n\");\n\t\tgoto err;\n\t}\n\tmemcpy(&me->guid, guid, sizeof(*guid));\n\tmemset(&data, 0, sizeof(data));\n\tme->initialized = true;\n\n\tmemcpy(&data.in_client_uuid, &me->guid, sizeof(me->guid));\n\tresult = ioctl(me->fd, IOCTL_MEI_CONNECT_CLIENT, &data);\n\tif (result) {\n\t\tmei_err(me, \"IOCTL_MEI_CONNECT_CLIENT receive message. err=%d\\n\", result);\n\t\tgoto err;\n\t}\n\tcl = &data.out_client_properties;\n\tmei_msg(me, \"max_message_length %d\\n\", cl->max_msg_length);\n\tmei_msg(me, \"protocol_version %d\\n\", cl->protocol_version);\n\n\tif ((req_protocol_version > 0) &&\n\t     (cl->protocol_version != req_protocol_version)) {\n\t\tmei_err(me, \"Intel MEI protocol version not supported\\n\");\n\t\tgoto err;\n\t}\n\n\tme->buf_size = cl->max_msg_length;\n\tme->prot_ver = cl->protocol_version;\n\n\treturn true;\nerr:\n\tmei_deinit(me);\n\treturn false;\n}\n\nstatic ssize_t mei_recv_msg(struct mei *me, unsigned char *buffer,\n\t\t\tssize_t len, unsigned long timeout)\n{\n\tstruct timeval tv;\n\tfd_set set;\n\tssize_t rc;\n\n\ttv.tv_sec = timeout / 1000;\n\ttv.tv_usec = (timeout % 1000) * 1000000;\n\n\tmei_msg(me, \"call read length = %zd\\n\", len);\n\n\tFD_ZERO(&set);\n\tFD_SET(me->fd, &set);\n\trc = select(me->fd + 1, &set, NULL, NULL, &tv);\n\tif (rc > 0 && FD_ISSET(me->fd, &set)) {\n\t\tmei_msg(me, \"have reply\\n\");\n\t} else if (rc == 0) {\n\t\trc = -1;\n\t\tmei_err(me, \"read failed on timeout\\n\");\n\t\tgoto out;\n\t} else {  \n\t\trc = errno;\n\t\tmei_err(me, \"read failed on select with status %zd %s\\n\",\n\t\t\trc, strerror(errno));\n\t\tgoto out;\n\t}\n\n\trc = read(me->fd, buffer, len);\n\tif (rc < 0) {\n\t\tmei_err(me, \"read failed with status %zd %s\\n\",\n\t\t\t\trc, strerror(errno));\n\t\tgoto out;\n\t}\n\n\tmei_msg(me, \"read succeeded with result %zd\\n\", rc);\n\nout:\n\tif (rc < 0)\n\t\tmei_deinit(me);\n\n\treturn rc;\n}\n\nstatic ssize_t mei_send_msg(struct mei *me, const unsigned char *buffer,\n\t\t\tssize_t len, unsigned long timeout)\n{\n\tssize_t written;\n\tssize_t rc;\n\n\tmei_msg(me, \"call write length = %zd\\n\", len);\n\n\twritten = write(me->fd, buffer, len);\n\tif (written < 0) {\n\t\trc = -errno;\n\t\tmei_err(me, \"write failed with status %zd %s\\n\",\n\t\t\twritten, strerror(errno));\n\t\tgoto out;\n\t}\n\tmei_msg(me, \"write success\\n\");\n\n\trc = written;\nout:\n\tif (rc < 0)\n\t\tmei_deinit(me);\n\n\treturn rc;\n}\n\n \n\n#define AMT_MAJOR_VERSION 1\n#define AMT_MINOR_VERSION 1\n\n#define AMT_STATUS_SUCCESS                0x0\n#define AMT_STATUS_INTERNAL_ERROR         0x1\n#define AMT_STATUS_NOT_READY              0x2\n#define AMT_STATUS_INVALID_AMT_MODE       0x3\n#define AMT_STATUS_INVALID_MESSAGE_LENGTH 0x4\n\n#define AMT_STATUS_HOST_IF_EMPTY_RESPONSE  0x4000\n#define AMT_STATUS_SDK_RESOURCES      0x1004\n\n\n#define AMT_BIOS_VERSION_LEN   65\n#define AMT_VERSIONS_NUMBER    50\n#define AMT_UNICODE_STRING_LEN 20\n\nstruct amt_unicode_string {\n\tuint16_t length;\n\tchar string[AMT_UNICODE_STRING_LEN];\n} __attribute__((packed));\n\nstruct amt_version_type {\n\tstruct amt_unicode_string description;\n\tstruct amt_unicode_string version;\n} __attribute__((packed));\n\nstruct amt_version {\n\tuint8_t major;\n\tuint8_t minor;\n} __attribute__((packed));\n\nstruct amt_code_versions {\n\tuint8_t bios[AMT_BIOS_VERSION_LEN];\n\tuint32_t count;\n\tstruct amt_version_type versions[AMT_VERSIONS_NUMBER];\n} __attribute__((packed));\n\n \n\nstruct amt_host_if_msg_header {\n\tstruct amt_version version;\n\tuint16_t _reserved;\n\tuint32_t command;\n\tuint32_t length;\n} __attribute__((packed));\n\nstruct amt_host_if_resp_header {\n\tstruct amt_host_if_msg_header header;\n\tuint32_t status;\n\tunsigned char data[];\n} __attribute__((packed));\n\nconst uuid_le MEI_IAMTHIF = UUID_LE(0x12f80028, 0xb4b7, 0x4b2d,  \\\n\t\t\t\t0xac, 0xa8, 0x46, 0xe0, 0xff, 0x65, 0x81, 0x4c);\n\n#define AMT_HOST_IF_CODE_VERSIONS_REQUEST  0x0400001A\n#define AMT_HOST_IF_CODE_VERSIONS_RESPONSE 0x0480001A\n\nconst struct amt_host_if_msg_header CODE_VERSION_REQ = {\n\t.version = {AMT_MAJOR_VERSION, AMT_MINOR_VERSION},\n\t._reserved = 0,\n\t.command = AMT_HOST_IF_CODE_VERSIONS_REQUEST,\n\t.length = 0\n};\n\n\nstruct amt_host_if {\n\tstruct mei mei_cl;\n\tunsigned long send_timeout;\n\tbool initialized;\n};\n\n\nstatic bool amt_host_if_init(struct amt_host_if *acmd,\n\t\t      unsigned long send_timeout, bool verbose)\n{\n\tacmd->send_timeout = (send_timeout) ? send_timeout : 20000;\n\tacmd->initialized = mei_init(&acmd->mei_cl, &MEI_IAMTHIF, 0, verbose);\n\treturn acmd->initialized;\n}\n\nstatic void amt_host_if_deinit(struct amt_host_if *acmd)\n{\n\tmei_deinit(&acmd->mei_cl);\n\tacmd->initialized = false;\n}\n\nstatic uint32_t amt_verify_code_versions(const struct amt_host_if_resp_header *resp)\n{\n\tuint32_t status = AMT_STATUS_SUCCESS;\n\tstruct amt_code_versions *code_ver;\n\tsize_t code_ver_len;\n\tuint32_t ver_type_cnt;\n\tuint32_t len;\n\tuint32_t i;\n\n\tcode_ver = (struct amt_code_versions *)resp->data;\n\t \n\tcode_ver_len = resp->header.length - sizeof(uint32_t);\n\tver_type_cnt = code_ver_len -\n\t\t\tsizeof(code_ver->bios) -\n\t\t\tsizeof(code_ver->count);\n\tif (code_ver->count != ver_type_cnt / sizeof(struct amt_version_type)) {\n\t\tstatus = AMT_STATUS_INTERNAL_ERROR;\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < code_ver->count; i++) {\n\t\tlen = code_ver->versions[i].description.length;\n\n\t\tif (len > AMT_UNICODE_STRING_LEN) {\n\t\t\tstatus = AMT_STATUS_INTERNAL_ERROR;\n\t\t\tgoto out;\n\t\t}\n\n\t\tlen = code_ver->versions[i].version.length;\n\t\tif (code_ver->versions[i].version.string[len] != '\\0' ||\n\t\t    len != strlen(code_ver->versions[i].version.string)) {\n\t\t\tstatus = AMT_STATUS_INTERNAL_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t}\nout:\n\treturn status;\n}\n\nstatic uint32_t amt_verify_response_header(uint32_t command,\n\t\t\t\tconst struct amt_host_if_msg_header *resp_hdr,\n\t\t\t\tuint32_t response_size)\n{\n\tif (response_size < sizeof(struct amt_host_if_resp_header)) {\n\t\treturn AMT_STATUS_INTERNAL_ERROR;\n\t} else if (response_size != (resp_hdr->length +\n\t\t\t\tsizeof(struct amt_host_if_msg_header))) {\n\t\treturn AMT_STATUS_INTERNAL_ERROR;\n\t} else if (resp_hdr->command != command) {\n\t\treturn AMT_STATUS_INTERNAL_ERROR;\n\t} else if (resp_hdr->_reserved != 0) {\n\t\treturn AMT_STATUS_INTERNAL_ERROR;\n\t} else if (resp_hdr->version.major != AMT_MAJOR_VERSION ||\n\t\t   resp_hdr->version.minor < AMT_MINOR_VERSION) {\n\t\treturn AMT_STATUS_INTERNAL_ERROR;\n\t}\n\treturn AMT_STATUS_SUCCESS;\n}\n\nstatic uint32_t amt_host_if_call(struct amt_host_if *acmd,\n\t\t\tconst unsigned char *command, ssize_t command_sz,\n\t\t\tuint8_t **read_buf, uint32_t rcmd,\n\t\t\tunsigned int expected_sz)\n{\n\tuint32_t in_buf_sz;\n\tssize_t out_buf_sz;\n\tssize_t written;\n\tuint32_t status;\n\tstruct amt_host_if_resp_header *msg_hdr;\n\n\tin_buf_sz = acmd->mei_cl.buf_size;\n\t*read_buf = (uint8_t *)malloc(sizeof(uint8_t) * in_buf_sz);\n\tif (*read_buf == NULL)\n\t\treturn AMT_STATUS_SDK_RESOURCES;\n\tmemset(*read_buf, 0, in_buf_sz);\n\tmsg_hdr = (struct amt_host_if_resp_header *)*read_buf;\n\n\twritten = mei_send_msg(&acmd->mei_cl,\n\t\t\t\tcommand, command_sz, acmd->send_timeout);\n\tif (written != command_sz)\n\t\treturn AMT_STATUS_INTERNAL_ERROR;\n\n\tout_buf_sz = mei_recv_msg(&acmd->mei_cl, *read_buf, in_buf_sz, 2000);\n\tif (out_buf_sz <= 0)\n\t\treturn AMT_STATUS_HOST_IF_EMPTY_RESPONSE;\n\n\tstatus = msg_hdr->status;\n\tif (status != AMT_STATUS_SUCCESS)\n\t\treturn status;\n\n\tstatus = amt_verify_response_header(rcmd,\n\t\t\t\t&msg_hdr->header, out_buf_sz);\n\tif (status != AMT_STATUS_SUCCESS)\n\t\treturn status;\n\n\tif (expected_sz && expected_sz != out_buf_sz)\n\t\treturn AMT_STATUS_INTERNAL_ERROR;\n\n\treturn AMT_STATUS_SUCCESS;\n}\n\n\nstatic uint32_t amt_get_code_versions(struct amt_host_if *cmd,\n\t\t\t       struct amt_code_versions *versions)\n{\n\tstruct amt_host_if_resp_header *response = NULL;\n\tuint32_t status;\n\n\tstatus = amt_host_if_call(cmd,\n\t\t\t(const unsigned char *)&CODE_VERSION_REQ,\n\t\t\tsizeof(CODE_VERSION_REQ),\n\t\t\t(uint8_t **)&response,\n\t\t\tAMT_HOST_IF_CODE_VERSIONS_RESPONSE, 0);\n\n\tif (status != AMT_STATUS_SUCCESS)\n\t\tgoto out;\n\n\tstatus = amt_verify_code_versions(response);\n\tif (status != AMT_STATUS_SUCCESS)\n\t\tgoto out;\n\n\tmemcpy(versions, response->data, sizeof(struct amt_code_versions));\nout:\n\tif (response != NULL)\n\t\tfree(response);\n\n\treturn status;\n}\n\n \nint main(int argc, char **argv)\n{\n\tstruct amt_code_versions ver;\n\tstruct amt_host_if acmd;\n\tunsigned int i;\n\tuint32_t status;\n\tint ret;\n\tbool verbose;\n\n\tverbose = (argc > 1 && strcmp(argv[1], \"-v\") == 0);\n\n\tif (!amt_host_if_init(&acmd, 5000, verbose)) {\n\t\tret = 1;\n\t\tgoto out;\n\t}\n\n\tstatus = amt_get_code_versions(&acmd, &ver);\n\n\tamt_host_if_deinit(&acmd);\n\n\tswitch (status) {\n\tcase AMT_STATUS_HOST_IF_EMPTY_RESPONSE:\n\t\tprintf(\"Intel AMT: DISABLED\\n\");\n\t\tret = 0;\n\t\tbreak;\n\tcase AMT_STATUS_SUCCESS:\n\t\tprintf(\"Intel AMT: ENABLED\\n\");\n\t\tfor (i = 0; i < ver.count; i++) {\n\t\t\tprintf(\"%s:\\t%s\\n\", ver.versions[i].description.string,\n\t\t\t\tver.versions[i].version.string);\n\t\t}\n\t\tret = 0;\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"An error has occurred\\n\");\n\t\tret = 1;\n\t\tbreak;\n\t}\n\nout:\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}