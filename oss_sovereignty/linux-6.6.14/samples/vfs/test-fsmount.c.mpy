{
  "module_name": "test-fsmount.c",
  "hash_id": "60369e255f805aa7c57a14017fbc828aea23476993bdb053596979537b54b52d",
  "original_prompt": "Ingested from linux-6.6.14/samples/vfs/test-fsmount.c",
  "human_readable_source": "\n \n\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <sys/prctl.h>\n#include <sys/wait.h>\n#include <linux/mount.h>\n#include <linux/unistd.h>\n\n#define E(x) do { if ((x) == -1) { perror(#x); exit(1); } } while(0)\n\nstatic void check_messages(int fd)\n{\n\tchar buf[4096];\n\tint err, n;\n\n\terr = errno;\n\n\tfor (;;) {\n\t\tn = read(fd, buf, sizeof(buf));\n\t\tif (n < 0)\n\t\t\tbreak;\n\t\tn -= 2;\n\n\t\tswitch (buf[0]) {\n\t\tcase 'e':\n\t\t\tfprintf(stderr, \"Error: %*.*s\\n\", n, n, buf + 2);\n\t\t\tbreak;\n\t\tcase 'w':\n\t\t\tfprintf(stderr, \"Warning: %*.*s\\n\", n, n, buf + 2);\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\tfprintf(stderr, \"Info: %*.*s\\n\", n, n, buf + 2);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\terrno = err;\n}\n\nstatic __attribute__((noreturn))\nvoid mount_error(int fd, const char *s)\n{\n\tcheck_messages(fd);\n\tfprintf(stderr, \"%s: %m\\n\", s);\n\texit(1);\n}\n\n \n#ifndef __NR_fsopen\n#define __NR_fsopen -1\n#endif\n#ifndef __NR_fsmount\n#define __NR_fsmount -1\n#endif\n#ifndef __NR_fsconfig\n#define __NR_fsconfig -1\n#endif\n#ifndef __NR_move_mount\n#define __NR_move_mount -1\n#endif\n\n\nstatic inline int fsopen(const char *fs_name, unsigned int flags)\n{\n\treturn syscall(__NR_fsopen, fs_name, flags);\n}\n\nstatic inline int fsmount(int fsfd, unsigned int flags, unsigned int ms_flags)\n{\n\treturn syscall(__NR_fsmount, fsfd, flags, ms_flags);\n}\n\nstatic inline int fsconfig(int fsfd, unsigned int cmd,\n\t\t\t   const char *key, const void *val, int aux)\n{\n\treturn syscall(__NR_fsconfig, fsfd, cmd, key, val, aux);\n}\n\nstatic inline int move_mount(int from_dfd, const char *from_pathname,\n\t\t\t     int to_dfd, const char *to_pathname,\n\t\t\t     unsigned int flags)\n{\n\treturn syscall(__NR_move_mount,\n\t\t       from_dfd, from_pathname,\n\t\t       to_dfd, to_pathname, flags);\n}\n\n#define E_fsconfig(fd, cmd, key, val, aux)\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tif (fsconfig(fd, cmd, key, val, aux) == -1)\t\t\\\n\t\t\tmount_error(fd, key ?: \"create\");\t\t\\\n\t} while (0)\n\nint main(int argc, char *argv[])\n{\n\tint fsfd, mfd;\n\n\t \n\tfsfd = fsopen(\"afs\", 0);\n\tif (fsfd == -1) {\n\t\tperror(\"fsopen\");\n\t\texit(1);\n\t}\n\n\tE_fsconfig(fsfd, FSCONFIG_SET_STRING, \"source\", \"#grand.central.org:root.cell.\", 0);\n\tE_fsconfig(fsfd, FSCONFIG_CMD_CREATE, NULL, NULL, 0);\n\n\tmfd = fsmount(fsfd, 0, MOUNT_ATTR_RDONLY);\n\tif (mfd < 0)\n\t\tmount_error(fsfd, \"fsmount\");\n\tE(close(fsfd));\n\n\tif (move_mount(mfd, \"\", AT_FDCWD, \"/mnt\", MOVE_MOUNT_F_EMPTY_PATH) < 0) {\n\t\tperror(\"move_mount\");\n\t\texit(1);\n\t}\n\n\tE(close(mfd));\n\texit(0);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}