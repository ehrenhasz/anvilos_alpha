{
  "module_name": "ucon.c",
  "hash_id": "40166525989a587f118b6509147f8381ee19f93eac6d54cb95782f9b195998a3",
  "original_prompt": "Ingested from linux-6.6.14/samples/connector/ucon.c",
  "human_readable_source": "\n \n\n#include <asm/types.h>\n\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <sys/poll.h>\n\n#include <linux/netlink.h>\n#include <linux/rtnetlink.h>\n\n#include <arpa/inet.h>\n\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <string.h>\n#include <errno.h>\n#include <time.h>\n#include <getopt.h>\n\n#include <linux/connector.h>\n\n#define DEBUG\n#define NETLINK_CONNECTOR \t11\n\n \n#define CN_TEST_IDX\t\tCN_NETLINK_USERS + 3\n#define CN_TEST_VAL\t\t0x456\n\n#ifdef DEBUG\n#define ulog(f, a...) fprintf(stdout, f, ##a)\n#else\n#define ulog(f, a...) do {} while (0)\n#endif\n\nstatic int need_exit;\nstatic __u32 seq;\n\nstatic int netlink_send(int s, struct cn_msg *msg)\n{\n\tstruct nlmsghdr *nlh;\n\tunsigned int size;\n\tint err;\n\tchar buf[128];\n\tstruct cn_msg *m;\n\n\tsize = NLMSG_SPACE(sizeof(struct cn_msg) + msg->len);\n\n\tnlh = (struct nlmsghdr *)buf;\n\tnlh->nlmsg_seq = seq++;\n\tnlh->nlmsg_pid = getpid();\n\tnlh->nlmsg_type = NLMSG_DONE;\n\tnlh->nlmsg_len = size;\n\tnlh->nlmsg_flags = 0;\n\n\tm = NLMSG_DATA(nlh);\n#if 0\n\tulog(\"%s: [%08x.%08x] len=%u, seq=%u, ack=%u.\\n\",\n\t       __func__, msg->id.idx, msg->id.val, msg->len, msg->seq, msg->ack);\n#endif\n\tmemcpy(m, msg, sizeof(*m) + msg->len);\n\n\terr = send(s, nlh, size, 0);\n\tif (err == -1)\n\t\tulog(\"Failed to send: %s [%d].\\n\",\n\t\t\tstrerror(errno), errno);\n\n\treturn err;\n}\n\nstatic void usage(void)\n{\n\tprintf(\n\t\t\"Usage: ucon [options] [output file]\\n\"\n\t\t\"\\n\"\n\t\t\"\\t-h\\tthis help screen\\n\"\n\t\t\"\\t-s\\tsend buffers to the test module\\n\"\n\t\t\"\\n\"\n\t\t\"The default behavior of ucon is to subscribe to the test module\\n\"\n\t\t\"and wait for state messages.  Any ones received are dumped to the\\n\"\n\t\t\"specified output file (or stdout).  The test module is assumed to\\n\"\n\t\t\"have an id of {%u.%u}\\n\"\n\t\t\"\\n\"\n\t\t\"If you get no output, then verify the cn_test module id matches\\n\"\n\t\t\"the expected id above.\\n\"\n\t\t, CN_TEST_IDX, CN_TEST_VAL\n\t);\n}\n\nint main(int argc, char *argv[])\n{\n\tint s;\n\tchar buf[1024];\n\tint len;\n\tstruct nlmsghdr *reply;\n\tstruct sockaddr_nl l_local;\n\tstruct cn_msg *data;\n\tFILE *out;\n\ttime_t tm;\n\tstruct pollfd pfd;\n\tbool send_msgs = false;\n\n\twhile ((s = getopt(argc, argv, \"hs\")) != -1) {\n\t\tswitch (s) {\n\t\tcase 's':\n\t\t\tsend_msgs = true;\n\t\t\tbreak;\n\n\t\tcase 'h':\n\t\t\tusage();\n\t\t\treturn 0;\n\n\t\tdefault:\n\t\t\t \n\t\t\tusage();\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tif (argc != optind) {\n\t\tout = fopen(argv[optind], \"a+\");\n\t\tif (!out) {\n\t\t\tulog(\"Unable to open %s for writing: %s\\n\",\n\t\t\t\targv[1], strerror(errno));\n\t\t\tout = stdout;\n\t\t}\n\t} else\n\t\tout = stdout;\n\n\tmemset(buf, 0, sizeof(buf));\n\n\ts = socket(PF_NETLINK, SOCK_DGRAM, NETLINK_CONNECTOR);\n\tif (s == -1) {\n\t\tperror(\"socket\");\n\t\treturn -1;\n\t}\n\n\tl_local.nl_family = AF_NETLINK;\n\tl_local.nl_groups = -1;  \n\tl_local.nl_pid = 0;\n\n\tulog(\"subscribing to %u.%u\\n\", CN_TEST_IDX, CN_TEST_VAL);\n\n\tif (bind(s, (struct sockaddr *)&l_local, sizeof(struct sockaddr_nl)) == -1) {\n\t\tperror(\"bind\");\n\t\tclose(s);\n\t\treturn -1;\n\t}\n\n#if 0\n\t{\n\t\tint on = 0x57;  \n\t\tsetsockopt(s, SOL_NETLINK, NETLINK_ADD_MEMBERSHIP, &on, sizeof(on));\n\t}\n#endif\n\tif (send_msgs) {\n\t\tint i, j;\n\n\t\tmemset(buf, 0, sizeof(buf));\n\n\t\tdata = (struct cn_msg *)buf;\n\n\t\tdata->id.idx = CN_TEST_IDX;\n\t\tdata->id.val = CN_TEST_VAL;\n\t\tdata->seq = seq++;\n\t\tdata->ack = 0;\n\t\tdata->len = 0;\n\n\t\tfor (j=0; j<10; ++j) {\n\t\t\tfor (i=0; i<1000; ++i) {\n\t\t\t\tlen = netlink_send(s, data);\n\t\t\t}\n\n\t\t\tulog(\"%d messages have been sent to %08x.%08x.\\n\", i, data->id.idx, data->id.val);\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\n\tpfd.fd = s;\n\n\twhile (!need_exit) {\n\t\tpfd.events = POLLIN;\n\t\tpfd.revents = 0;\n\t\tswitch (poll(&pfd, 1, -1)) {\n\t\t\tcase 0:\n\t\t\t\tneed_exit = 1;\n\t\t\t\tbreak;\n\t\t\tcase -1:\n\t\t\t\tif (errno != EINTR) {\n\t\t\t\t\tneed_exit = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t}\n\t\tif (need_exit)\n\t\t\tbreak;\n\n\t\tmemset(buf, 0, sizeof(buf));\n\t\tlen = recv(s, buf, sizeof(buf), 0);\n\t\tif (len == -1) {\n\t\t\tperror(\"recv buf\");\n\t\t\tclose(s);\n\t\t\treturn -1;\n\t\t}\n\t\treply = (struct nlmsghdr *)buf;\n\n\t\tswitch (reply->nlmsg_type) {\n\t\tcase NLMSG_ERROR:\n\t\t\tfprintf(out, \"Error message received.\\n\");\n\t\t\tfflush(out);\n\t\t\tbreak;\n\t\tcase NLMSG_DONE:\n\t\t\tdata = (struct cn_msg *)NLMSG_DATA(reply);\n\n\t\t\ttime(&tm);\n\t\t\tfprintf(out, \"%.24s : [%x.%x] [%08u.%08u].\\n\",\n\t\t\t\tctime(&tm), data->id.idx, data->id.val, data->seq, data->ack);\n\t\t\tfflush(out);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tclose(s);\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}