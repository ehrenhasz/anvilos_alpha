{
  "module_name": "cn_test.c",
  "hash_id": "a11683ad2dd98144b82b60e314886e328605bd7bdd26b587049246a92635ca5c",
  "original_prompt": "Ingested from linux-6.6.14/samples/connector/cn_test.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"cn_test: \" fmt\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/skbuff.h>\n#include <linux/slab.h>\n#include <linux/timer.h>\n\n#include <linux/connector.h>\n\nstatic struct cb_id cn_test_id = { CN_NETLINK_USERS + 3, 0x456 };\nstatic char cn_test_name[] = \"cn_test\";\nstatic struct sock *nls;\nstatic struct timer_list cn_test_timer;\n\nstatic void cn_test_callback(struct cn_msg *msg, struct netlink_skb_parms *nsp)\n{\n\tpr_info(\"%s: %lu: idx=%x, val=%x, seq=%u, ack=%u, len=%d: %s.\\n\",\n\t        __func__, jiffies, msg->id.idx, msg->id.val,\n\t        msg->seq, msg->ack, msg->len,\n\t        msg->len ? (char *)msg->data : \"\");\n}\n\n \n#if 0\nstatic int cn_test_want_notify(void)\n{\n\tstruct cn_ctl_msg *ctl;\n\tstruct cn_notify_req *req;\n\tstruct cn_msg *msg = NULL;\n\tint size, size0;\n\tstruct sk_buff *skb;\n\tstruct nlmsghdr *nlh;\n\tu32 group = 1;\n\n\tsize0 = sizeof(*msg) + sizeof(*ctl) + 3 * sizeof(*req);\n\n\tsize = NLMSG_SPACE(size0);\n\n\tskb = alloc_skb(size, GFP_ATOMIC);\n\tif (!skb) {\n\t\tpr_err(\"failed to allocate new skb with size=%u\\n\", size);\n\t\treturn -ENOMEM;\n\t}\n\n\tnlh = nlmsg_put(skb, 0, 0x123, NLMSG_DONE, size - sizeof(*nlh), 0);\n\tif (!nlh) {\n\t\tkfree_skb(skb);\n\t\treturn -EMSGSIZE;\n\t}\n\n\tmsg = nlmsg_data(nlh);\n\n\tmemset(msg, 0, size0);\n\n\tmsg->id.idx = -1;\n\tmsg->id.val = -1;\n\tmsg->seq = 0x123;\n\tmsg->ack = 0x345;\n\tmsg->len = size0 - sizeof(*msg);\n\n\tctl = (struct cn_ctl_msg *)(msg + 1);\n\n\tctl->idx_notify_num = 1;\n\tctl->val_notify_num = 2;\n\tctl->group = group;\n\tctl->len = msg->len - sizeof(*ctl);\n\n\treq = (struct cn_notify_req *)(ctl + 1);\n\n\t \n\treq->first = cn_test_id.idx;\n\treq->range = 10;\n\n\t \n\treq++;\n\treq->first = cn_test_id.val;\n\treq->range = 10;\n\n\t \n\treq++;\n\treq->first = cn_test_id.val + 20;\n\treq->range = 10;\n\n\tNETLINK_CB(skb).dst_group = ctl->group;\n\t\n\tnetlink_unicast(nls, skb, 0, 0);\n\n\tpr_info(\"request was sent: group=0x%x\\n\", ctl->group);\n\n\treturn 0;\n}\n#endif\n\nstatic u32 cn_test_timer_counter;\nstatic void cn_test_timer_func(struct timer_list *unused)\n{\n\tstruct cn_msg *m;\n\tchar data[32];\n\n\tpr_debug(\"%s: timer fired\\n\", __func__);\n\n\tm = kzalloc(sizeof(*m) + sizeof(data), GFP_ATOMIC);\n\tif (m) {\n\n\t\tmemcpy(&m->id, &cn_test_id, sizeof(m->id));\n\t\tm->seq = cn_test_timer_counter;\n\t\tm->len = sizeof(data);\n\n\t\tm->len =\n\t\t    scnprintf(data, sizeof(data), \"counter = %u\",\n\t\t\t      cn_test_timer_counter) + 1;\n\n\t\tmemcpy(m + 1, data, m->len);\n\n\t\tcn_netlink_send(m, 0, 0, GFP_ATOMIC);\n\t\tkfree(m);\n\t}\n\n\tcn_test_timer_counter++;\n\n\tmod_timer(&cn_test_timer, jiffies + msecs_to_jiffies(1000));\n}\n\nstatic int cn_test_init(void)\n{\n\tint err;\n\n\terr = cn_add_callback(&cn_test_id, cn_test_name, cn_test_callback);\n\tif (err)\n\t\tgoto err_out;\n\tcn_test_id.val++;\n\terr = cn_add_callback(&cn_test_id, cn_test_name, cn_test_callback);\n\tif (err) {\n\t\tcn_del_callback(&cn_test_id);\n\t\tgoto err_out;\n\t}\n\n\ttimer_setup(&cn_test_timer, cn_test_timer_func, 0);\n\tmod_timer(&cn_test_timer, jiffies + msecs_to_jiffies(1000));\n\n\tpr_info(\"initialized with id={%u.%u}\\n\",\n\t\tcn_test_id.idx, cn_test_id.val);\n\n\treturn 0;\n\n      err_out:\n\tif (nls && nls->sk_socket)\n\t\tsock_release(nls->sk_socket);\n\n\treturn err;\n}\n\nstatic void cn_test_fini(void)\n{\n\tdel_timer_sync(&cn_test_timer);\n\tcn_del_callback(&cn_test_id);\n\tcn_test_id.val--;\n\tcn_del_callback(&cn_test_id);\n\tif (nls && nls->sk_socket)\n\t\tsock_release(nls->sk_socket);\n}\n\nmodule_init(cn_test_init);\nmodule_exit(cn_test_fini);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Evgeniy Polyakov <zbr@ioremap.net>\");\nMODULE_DESCRIPTION(\"Connector's test module\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}