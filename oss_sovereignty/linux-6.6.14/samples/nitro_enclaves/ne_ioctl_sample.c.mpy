{
  "module_name": "ne_ioctl_sample.c",
  "hash_id": "423e2a5499b2621322c425eb51fdf23e459a228632eabbfc02e8940f6c0e4f94",
  "original_prompt": "Ingested from linux-6.6.14/samples/nitro_enclaves/ne_ioctl_sample.c",
  "human_readable_source": "\n \n\n \n\n#include <stdio.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <limits.h>\n#include <poll.h>\n#include <pthread.h>\n#include <string.h>\n#include <sys/eventfd.h>\n#include <sys/ioctl.h>\n#include <sys/mman.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n\n#include <linux/mman.h>\n#include <linux/nitro_enclaves.h>\n#include <linux/vm_sockets.h>\n\n \n#define NE_DEV_NAME\t\t\t\"/dev/nitro_enclaves\"\n\n \n#define NE_POLL_WAIT_TIME\t\t(60)\n \n#define NE_POLL_WAIT_TIME_MS\t\t(NE_POLL_WAIT_TIME * 1000)\n\n \n#define NE_SLEEP_TIME\t\t\t(300)\n\n \n#define NE_DEFAULT_NR_VCPUS\t\t(2)\n\n \n#define NE_MIN_MEM_REGION_SIZE\t\t(2 * 1024 * 1024)\n\n \n#define NE_DEFAULT_NR_MEM_REGIONS\t(256)\n\n \n#define NE_IMAGE_LOAD_HEARTBEAT_CID\t(3)\n \n#define NE_IMAGE_LOAD_HEARTBEAT_PORT\t(9000)\n \n#define NE_IMAGE_LOAD_HEARTBEAT_VALUE\t(0xb7)\n\n \nstruct ne_user_mem_region {\n\tvoid\t*userspace_addr;\n\tsize_t\tmemory_size;\n};\n\n \nstatic int ne_create_vm(int ne_dev_fd, unsigned long *slot_uid, int *enclave_fd)\n{\n\tint rc = -EINVAL;\n\t*enclave_fd = ioctl(ne_dev_fd, NE_CREATE_VM, slot_uid);\n\n\tif (*enclave_fd < 0) {\n\t\trc = *enclave_fd;\n\t\tswitch (errno) {\n\t\tcase NE_ERR_NO_CPUS_AVAIL_IN_POOL: {\n\t\t\tprintf(\"Error in create VM, no CPUs available in the NE CPU pool\\n\");\n\n\t\t\tbreak;\n\t\t}\n\n\t\tdefault:\n\t\t\tprintf(\"Error in create VM [%m]\\n\");\n\t\t}\n\n\t\treturn rc;\n\t}\n\n\treturn 0;\n}\n\n \nvoid *ne_poll_enclave_fd(void *data)\n{\n\tint enclave_fd = *(int *)data;\n\tstruct pollfd fds[1] = {};\n\tint i = 0;\n\tint rc = -EINVAL;\n\n\tprintf(\"Running from poll thread, enclave fd %d\\n\", enclave_fd);\n\n\tfds[0].fd = enclave_fd;\n\tfds[0].events = POLLIN | POLLERR | POLLHUP;\n\n\t \n\twhile (1) {\n\t\tprintf(\"[iter %d] Polling ...\\n\", i);\n\n\t\trc = poll(fds, 1, NE_POLL_WAIT_TIME_MS);\n\t\tif (rc < 0) {\n\t\t\tprintf(\"Error in poll [%m]\\n\");\n\n\t\t\treturn NULL;\n\t\t}\n\n\t\ti++;\n\n\t\tif (!rc) {\n\t\t\tprintf(\"Poll: %d seconds elapsed\\n\",\n\t\t\t       i * NE_POLL_WAIT_TIME);\n\n\t\t\tcontinue;\n\t\t}\n\n\t\tprintf(\"Poll received value 0x%x\\n\", fds[0].revents);\n\n\t\tif (fds[0].revents & POLLHUP) {\n\t\t\tprintf(\"Received POLLHUP\\n\");\n\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (fds[0].revents & POLLNVAL) {\n\t\t\tprintf(\"Received POLLNVAL\\n\");\n\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\n \nstatic int ne_alloc_user_mem_region(struct ne_user_mem_region *ne_user_mem_region)\n{\n\t \n\tne_user_mem_region->userspace_addr = mmap(NULL, ne_user_mem_region->memory_size,\n\t\t\t\t\t\t  PROT_READ | PROT_WRITE,\n\t\t\t\t\t\t  MAP_PRIVATE | MAP_ANONYMOUS |\n\t\t\t\t\t\t  MAP_HUGETLB | MAP_HUGE_2MB, -1, 0);\n\tif (ne_user_mem_region->userspace_addr == MAP_FAILED) {\n\t\tprintf(\"Error in mmap memory [%m]\\n\");\n\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int ne_load_enclave_image(int enclave_fd, struct ne_user_mem_region ne_user_mem_regions[],\n\t\t\t\t char *enclave_image_path)\n{\n\tunsigned char *enclave_image = NULL;\n\tint enclave_image_fd = -1;\n\tsize_t enclave_image_size = 0;\n\tsize_t enclave_memory_size = 0;\n\tunsigned long i = 0;\n\tsize_t image_written_bytes = 0;\n\tstruct ne_image_load_info image_load_info = {\n\t\t.flags = NE_EIF_IMAGE,\n\t};\n\tstruct stat image_stat_buf = {};\n\tint rc = -EINVAL;\n\tsize_t temp_image_offset = 0;\n\n\tfor (i = 0; i < NE_DEFAULT_NR_MEM_REGIONS; i++)\n\t\tenclave_memory_size += ne_user_mem_regions[i].memory_size;\n\n\trc = stat(enclave_image_path, &image_stat_buf);\n\tif (rc < 0) {\n\t\tprintf(\"Error in get image stat info [%m]\\n\");\n\n\t\treturn rc;\n\t}\n\n\tenclave_image_size = image_stat_buf.st_size;\n\n\tif (enclave_memory_size < enclave_image_size) {\n\t\tprintf(\"The enclave memory is smaller than the enclave image size\\n\");\n\n\t\treturn -ENOMEM;\n\t}\n\n\trc = ioctl(enclave_fd, NE_GET_IMAGE_LOAD_INFO, &image_load_info);\n\tif (rc < 0) {\n\t\tswitch (errno) {\n\t\tcase NE_ERR_NOT_IN_INIT_STATE: {\n\t\t\tprintf(\"Error in get image load info, enclave not in init state\\n\");\n\n\t\t\tbreak;\n\t\t}\n\n\t\tcase NE_ERR_INVALID_FLAG_VALUE: {\n\t\t\tprintf(\"Error in get image load info, provided invalid flag\\n\");\n\n\t\t\tbreak;\n\t\t}\n\n\t\tdefault:\n\t\t\tprintf(\"Error in get image load info [%m]\\n\");\n\t\t}\n\n\t\treturn rc;\n\t}\n\n\tprintf(\"Enclave image offset in enclave memory is %lld\\n\",\n\t       image_load_info.memory_offset);\n\n\tenclave_image_fd = open(enclave_image_path, O_RDONLY);\n\tif (enclave_image_fd < 0) {\n\t\tprintf(\"Error in open enclave image file [%m]\\n\");\n\n\t\treturn enclave_image_fd;\n\t}\n\n\tenclave_image = mmap(NULL, enclave_image_size, PROT_READ,\n\t\t\t     MAP_PRIVATE, enclave_image_fd, 0);\n\tif (enclave_image == MAP_FAILED) {\n\t\tprintf(\"Error in mmap enclave image [%m]\\n\");\n\n\t\treturn -1;\n\t}\n\n\ttemp_image_offset = image_load_info.memory_offset;\n\n\tfor (i = 0; i < NE_DEFAULT_NR_MEM_REGIONS; i++) {\n\t\tsize_t bytes_to_write = 0;\n\t\tsize_t memory_offset = 0;\n\t\tsize_t memory_size = ne_user_mem_regions[i].memory_size;\n\t\tsize_t remaining_bytes = 0;\n\t\tvoid *userspace_addr = ne_user_mem_regions[i].userspace_addr;\n\n\t\tif (temp_image_offset >= memory_size) {\n\t\t\ttemp_image_offset -= memory_size;\n\n\t\t\tcontinue;\n\t\t} else if (temp_image_offset != 0) {\n\t\t\tmemory_offset = temp_image_offset;\n\t\t\tmemory_size -= temp_image_offset;\n\t\t\ttemp_image_offset = 0;\n\t\t}\n\n\t\tremaining_bytes = enclave_image_size - image_written_bytes;\n\t\tbytes_to_write = memory_size < remaining_bytes ?\n\t\t\t\t memory_size : remaining_bytes;\n\n\t\tmemcpy(userspace_addr + memory_offset,\n\t\t       enclave_image + image_written_bytes, bytes_to_write);\n\n\t\timage_written_bytes += bytes_to_write;\n\n\t\tif (image_written_bytes == enclave_image_size)\n\t\t\tbreak;\n\t}\n\n\tmunmap(enclave_image, enclave_image_size);\n\n\tclose(enclave_image_fd);\n\n\treturn 0;\n}\n\n \nstatic int ne_set_user_mem_region(int enclave_fd, struct ne_user_mem_region ne_user_mem_region)\n{\n\tstruct ne_user_memory_region mem_region = {\n\t\t.flags = NE_DEFAULT_MEMORY_REGION,\n\t\t.memory_size = ne_user_mem_region.memory_size,\n\t\t.userspace_addr = (__u64)ne_user_mem_region.userspace_addr,\n\t};\n\tint rc = -EINVAL;\n\n\trc = ioctl(enclave_fd, NE_SET_USER_MEMORY_REGION, &mem_region);\n\tif (rc < 0) {\n\t\tswitch (errno) {\n\t\tcase NE_ERR_NOT_IN_INIT_STATE: {\n\t\t\tprintf(\"Error in set user memory region, enclave not in init state\\n\");\n\n\t\t\tbreak;\n\t\t}\n\n\t\tcase NE_ERR_INVALID_MEM_REGION_SIZE: {\n\t\t\tprintf(\"Error in set user memory region, mem size not multiple of 2 MiB\\n\");\n\n\t\t\tbreak;\n\t\t}\n\n\t\tcase NE_ERR_INVALID_MEM_REGION_ADDR: {\n\t\t\tprintf(\"Error in set user memory region, invalid user space address\\n\");\n\n\t\t\tbreak;\n\t\t}\n\n\t\tcase NE_ERR_UNALIGNED_MEM_REGION_ADDR: {\n\t\t\tprintf(\"Error in set user memory region, unaligned user space address\\n\");\n\n\t\t\tbreak;\n\t\t}\n\n\t\tcase NE_ERR_MEM_REGION_ALREADY_USED: {\n\t\t\tprintf(\"Error in set user memory region, memory region already used\\n\");\n\n\t\t\tbreak;\n\t\t}\n\n\t\tcase NE_ERR_MEM_NOT_HUGE_PAGE: {\n\t\t\tprintf(\"Error in set user memory region, not backed by huge pages\\n\");\n\n\t\t\tbreak;\n\t\t}\n\n\t\tcase NE_ERR_MEM_DIFFERENT_NUMA_NODE: {\n\t\t\tprintf(\"Error in set user memory region, different NUMA node than CPUs\\n\");\n\n\t\t\tbreak;\n\t\t}\n\n\t\tcase NE_ERR_MEM_MAX_REGIONS: {\n\t\t\tprintf(\"Error in set user memory region, max memory regions reached\\n\");\n\n\t\t\tbreak;\n\t\t}\n\n\t\tcase NE_ERR_INVALID_PAGE_SIZE: {\n\t\t\tprintf(\"Error in set user memory region, has page not multiple of 2 MiB\\n\");\n\n\t\t\tbreak;\n\t\t}\n\n\t\tcase NE_ERR_INVALID_FLAG_VALUE: {\n\t\t\tprintf(\"Error in set user memory region, provided invalid flag\\n\");\n\n\t\t\tbreak;\n\t\t}\n\n\t\tdefault:\n\t\t\tprintf(\"Error in set user memory region [%m]\\n\");\n\t\t}\n\n\t\treturn rc;\n\t}\n\n\treturn 0;\n}\n\n \nstatic void ne_free_mem_regions(struct ne_user_mem_region ne_user_mem_regions[])\n{\n\tunsigned int i = 0;\n\n\tfor (i = 0; i < NE_DEFAULT_NR_MEM_REGIONS; i++)\n\t\tmunmap(ne_user_mem_regions[i].userspace_addr,\n\t\t       ne_user_mem_regions[i].memory_size);\n}\n\n \nstatic int ne_add_vcpu(int enclave_fd, unsigned int *vcpu_id)\n{\n\tint rc = -EINVAL;\n\n\trc = ioctl(enclave_fd, NE_ADD_VCPU, vcpu_id);\n\tif (rc < 0) {\n\t\tswitch (errno) {\n\t\tcase NE_ERR_NO_CPUS_AVAIL_IN_POOL: {\n\t\t\tprintf(\"Error in add vcpu, no CPUs available in the NE CPU pool\\n\");\n\n\t\t\tbreak;\n\t\t}\n\n\t\tcase NE_ERR_VCPU_ALREADY_USED: {\n\t\t\tprintf(\"Error in add vcpu, the provided vCPU is already used\\n\");\n\n\t\t\tbreak;\n\t\t}\n\n\t\tcase NE_ERR_VCPU_NOT_IN_CPU_POOL: {\n\t\t\tprintf(\"Error in add vcpu, the provided vCPU is not in the NE CPU pool\\n\");\n\n\t\t\tbreak;\n\t\t}\n\n\t\tcase NE_ERR_VCPU_INVALID_CPU_CORE: {\n\t\t\tprintf(\"Error in add vcpu, the core id of the provided vCPU is invalid\\n\");\n\n\t\t\tbreak;\n\t\t}\n\n\t\tcase NE_ERR_NOT_IN_INIT_STATE: {\n\t\t\tprintf(\"Error in add vcpu, enclave not in init state\\n\");\n\n\t\t\tbreak;\n\t\t}\n\n\t\tcase NE_ERR_INVALID_VCPU: {\n\t\t\tprintf(\"Error in add vcpu, the provided vCPU is out of avail CPUs range\\n\");\n\n\t\t\tbreak;\n\t\t}\n\n\t\tdefault:\n\t\t\tprintf(\"Error in add vcpu [%m]\\n\");\n\t\t}\n\n\t\treturn rc;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int ne_start_enclave(int enclave_fd,  struct ne_enclave_start_info *enclave_start_info)\n{\n\tint rc = -EINVAL;\n\n\trc = ioctl(enclave_fd, NE_START_ENCLAVE, enclave_start_info);\n\tif (rc < 0) {\n\t\tswitch (errno) {\n\t\tcase NE_ERR_NOT_IN_INIT_STATE: {\n\t\t\tprintf(\"Error in start enclave, enclave not in init state\\n\");\n\n\t\t\tbreak;\n\t\t}\n\n\t\tcase NE_ERR_NO_MEM_REGIONS_ADDED: {\n\t\t\tprintf(\"Error in start enclave, no memory regions have been added\\n\");\n\n\t\t\tbreak;\n\t\t}\n\n\t\tcase NE_ERR_NO_VCPUS_ADDED: {\n\t\t\tprintf(\"Error in start enclave, no vCPUs have been added\\n\");\n\n\t\t\tbreak;\n\t\t}\n\n\t\tcase NE_ERR_FULL_CORES_NOT_USED: {\n\t\t\tprintf(\"Error in start enclave, enclave has no full cores set\\n\");\n\n\t\t\tbreak;\n\t\t}\n\n\t\tcase NE_ERR_ENCLAVE_MEM_MIN_SIZE: {\n\t\t\tprintf(\"Error in start enclave, enclave memory is less than min size\\n\");\n\n\t\t\tbreak;\n\t\t}\n\n\t\tcase NE_ERR_INVALID_FLAG_VALUE: {\n\t\t\tprintf(\"Error in start enclave, provided invalid flag\\n\");\n\n\t\t\tbreak;\n\t\t}\n\n\t\tcase NE_ERR_INVALID_ENCLAVE_CID: {\n\t\t\tprintf(\"Error in start enclave, provided invalid enclave CID\\n\");\n\n\t\t\tbreak;\n\t\t}\n\n\t\tdefault:\n\t\t\tprintf(\"Error in start enclave [%m]\\n\");\n\t\t}\n\n\t\treturn rc;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int ne_start_enclave_check_booted(int enclave_fd)\n{\n\tstruct sockaddr_vm client_vsock_addr = {};\n\tint client_vsock_fd = -1;\n\tsocklen_t client_vsock_len = sizeof(client_vsock_addr);\n\tstruct ne_enclave_start_info enclave_start_info = {};\n\tstruct pollfd fds[1] = {};\n\tint rc = -EINVAL;\n\tunsigned char recv_buf = 0;\n\tstruct sockaddr_vm server_vsock_addr = {\n\t\t.svm_family = AF_VSOCK,\n\t\t.svm_cid = NE_IMAGE_LOAD_HEARTBEAT_CID,\n\t\t.svm_port = NE_IMAGE_LOAD_HEARTBEAT_PORT,\n\t};\n\tint server_vsock_fd = -1;\n\n\tserver_vsock_fd = socket(AF_VSOCK, SOCK_STREAM, 0);\n\tif (server_vsock_fd < 0) {\n\t\trc = server_vsock_fd;\n\n\t\tprintf(\"Error in socket [%m]\\n\");\n\n\t\treturn rc;\n\t}\n\n\trc = bind(server_vsock_fd, (struct sockaddr *)&server_vsock_addr,\n\t\t  sizeof(server_vsock_addr));\n\tif (rc < 0) {\n\t\tprintf(\"Error in bind [%m]\\n\");\n\n\t\tgoto out;\n\t}\n\n\trc = listen(server_vsock_fd, 1);\n\tif (rc < 0) {\n\t\tprintf(\"Error in listen [%m]\\n\");\n\n\t\tgoto out;\n\t}\n\n\trc = ne_start_enclave(enclave_fd, &enclave_start_info);\n\tif (rc < 0)\n\t\tgoto out;\n\n\tprintf(\"Enclave started, CID %llu\\n\", enclave_start_info.enclave_cid);\n\n\tfds[0].fd = server_vsock_fd;\n\tfds[0].events = POLLIN;\n\n\trc = poll(fds, 1, NE_POLL_WAIT_TIME_MS);\n\tif (rc < 0) {\n\t\tprintf(\"Error in poll [%m]\\n\");\n\n\t\tgoto out;\n\t}\n\n\tif (!rc) {\n\t\tprintf(\"Poll timeout, %d seconds elapsed\\n\", NE_POLL_WAIT_TIME);\n\n\t\trc = -ETIMEDOUT;\n\n\t\tgoto out;\n\t}\n\n\tif ((fds[0].revents & POLLIN) == 0) {\n\t\tprintf(\"Poll received value %d\\n\", fds[0].revents);\n\n\t\trc = -EINVAL;\n\n\t\tgoto out;\n\t}\n\n\trc = accept(server_vsock_fd, (struct sockaddr *)&client_vsock_addr,\n\t\t    &client_vsock_len);\n\tif (rc < 0) {\n\t\tprintf(\"Error in accept [%m]\\n\");\n\n\t\tgoto out;\n\t}\n\n\tclient_vsock_fd = rc;\n\n\t \n\trc = read(client_vsock_fd, &recv_buf, sizeof(recv_buf));\n\tif (rc < 0) {\n\t\tprintf(\"Error in read [%m]\\n\");\n\n\t\tgoto out;\n\t}\n\n\tif (rc != sizeof(recv_buf) || recv_buf != NE_IMAGE_LOAD_HEARTBEAT_VALUE) {\n\t\tprintf(\"Read %d instead of %d\\n\", recv_buf,\n\t\t       NE_IMAGE_LOAD_HEARTBEAT_VALUE);\n\n\t\tgoto out;\n\t}\n\n\t \n\trc = write(client_vsock_fd, &recv_buf, sizeof(recv_buf));\n\tif (rc < 0) {\n\t\tprintf(\"Error in write [%m]\\n\");\n\n\t\tgoto out;\n\t}\n\n\trc = 0;\n\nout:\n\tclose(server_vsock_fd);\n\n\treturn rc;\n}\n\nint main(int argc, char *argv[])\n{\n\tint enclave_fd = -1;\n\tunsigned int i = 0;\n\tint ne_dev_fd = -1;\n\tstruct ne_user_mem_region ne_user_mem_regions[NE_DEFAULT_NR_MEM_REGIONS] = {};\n\tunsigned int ne_vcpus[NE_DEFAULT_NR_VCPUS] = {};\n\tint rc = -EINVAL;\n\tpthread_t thread_id = 0;\n\tunsigned long slot_uid = 0;\n\n\tif (argc != 2) {\n\t\tprintf(\"Usage: %s <path_to_enclave_image>\\n\", argv[0]);\n\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tif (strlen(argv[1]) >= PATH_MAX) {\n\t\tprintf(\"The size of the path to enclave image is higher than max path\\n\");\n\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tne_dev_fd = open(NE_DEV_NAME, O_RDWR | O_CLOEXEC);\n\tif (ne_dev_fd < 0) {\n\t\tprintf(\"Error in open NE device [%m]\\n\");\n\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tprintf(\"Creating enclave slot ...\\n\");\n\n\trc = ne_create_vm(ne_dev_fd, &slot_uid, &enclave_fd);\n\n\tclose(ne_dev_fd);\n\n\tif (rc < 0)\n\t\texit(EXIT_FAILURE);\n\n\tprintf(\"Enclave fd %d\\n\", enclave_fd);\n\n\trc = pthread_create(&thread_id, NULL, ne_poll_enclave_fd, (void *)&enclave_fd);\n\tif (rc < 0) {\n\t\tprintf(\"Error in thread create [%m]\\n\");\n\n\t\tclose(enclave_fd);\n\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tfor (i = 0; i < NE_DEFAULT_NR_MEM_REGIONS; i++) {\n\t\tne_user_mem_regions[i].memory_size = NE_MIN_MEM_REGION_SIZE;\n\n\t\trc = ne_alloc_user_mem_region(&ne_user_mem_regions[i]);\n\t\tif (rc < 0) {\n\t\t\tprintf(\"Error in alloc userspace memory region, iter %d\\n\", i);\n\n\t\t\tgoto release_enclave_fd;\n\t\t}\n\t}\n\n\trc = ne_load_enclave_image(enclave_fd, ne_user_mem_regions, argv[1]);\n\tif (rc < 0)\n\t\tgoto release_enclave_fd;\n\n\tfor (i = 0; i < NE_DEFAULT_NR_MEM_REGIONS; i++) {\n\t\trc = ne_set_user_mem_region(enclave_fd, ne_user_mem_regions[i]);\n\t\tif (rc < 0) {\n\t\t\tprintf(\"Error in set memory region, iter %d\\n\", i);\n\n\t\t\tgoto release_enclave_fd;\n\t\t}\n\t}\n\n\tprintf(\"Enclave memory regions were added\\n\");\n\n\tfor (i = 0; i < NE_DEFAULT_NR_VCPUS; i++) {\n\t\t \n\t\tne_vcpus[i] = 0;\n\t\trc = ne_add_vcpu(enclave_fd, &ne_vcpus[i]);\n\t\tif (rc < 0) {\n\t\t\tprintf(\"Error in add vcpu, iter %d\\n\", i);\n\n\t\t\tgoto release_enclave_fd;\n\t\t}\n\n\t\tprintf(\"Added vCPU %d to the enclave\\n\", ne_vcpus[i]);\n\t}\n\n\tprintf(\"Enclave vCPUs were added\\n\");\n\n\trc = ne_start_enclave_check_booted(enclave_fd);\n\tif (rc < 0) {\n\t\tprintf(\"Error in the enclave start / image loading heartbeat logic [rc=%d]\\n\", rc);\n\n\t\tgoto release_enclave_fd;\n\t}\n\n\tprintf(\"Entering sleep for %d seconds ...\\n\", NE_SLEEP_TIME);\n\n\tsleep(NE_SLEEP_TIME);\n\n\tclose(enclave_fd);\n\n\tne_free_mem_regions(ne_user_mem_regions);\n\n\texit(EXIT_SUCCESS);\n\nrelease_enclave_fd:\n\tclose(enclave_fd);\n\tne_free_mem_regions(ne_user_mem_regions);\n\n\texit(EXIT_FAILURE);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}