{
  "module_name": "hid_surface_dial.c",
  "hash_id": "2cdcf9f69eef5e37066a3a76afe69166c90934e101518a8ff5ca7905dee1e426",
  "original_prompt": "Ingested from linux-6.6.14/samples/hid/hid_surface_dial.c",
  "human_readable_source": "\n \n\n#include <assert.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <libgen.h>\n#include <signal.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/resource.h>\n#include <unistd.h>\n\n#include <linux/bpf.h>\n#include <linux/errno.h>\n\n#include <bpf/bpf.h>\n#include <bpf/libbpf.h>\n\n#include \"hid_surface_dial.skel.h\"\n#include \"hid_bpf_attach.h\"\n\nstatic bool running = true;\n\nstruct haptic_syscall_args {\n\tunsigned int hid;\n\tint retval;\n};\n\nstatic void int_exit(int sig)\n{\n\trunning = false;\n\texit(0);\n}\n\nstatic void usage(const char *prog)\n{\n\tfprintf(stderr,\n\t\t\"%s: %s [OPTIONS] /sys/bus/hid/devices/0BUS:0VID:0PID:00ID\\n\\n\"\n\t\t\"  OPTIONS:\\n\"\n\t\t\"    -r N\\t set the given resolution to the device (number of ticks per 360\u00b0)\\n\\n\",\n\t\t__func__, prog);\n\tfprintf(stderr,\n\t\t\"This program will morph the Microsoft Surface Dial into a mouse,\\n\"\n\t\t\"and depending on the chosen resolution enable or not the haptic feedback:\\n\"\n\t\t\"- a resolution (-r) of 3600 will report 3600 'ticks' in one full rotation\\n\"\n\t\t\"  without haptic feedback\\n\"\n\t\t\"- any other resolution will report N 'ticks' in a full rotation with haptic\\n\"\n\t\t\"  feedback\\n\"\n\t\t\"\\n\"\n\t\t\"A good default for low resolution haptic scrolling is 72 (1 'tick' every 5\\n\"\n\t\t\"degrees), and set to 3600 for smooth scrolling.\\n\");\n}\n\nstatic int get_hid_id(const char *path)\n{\n\tconst char *str_id, *dir;\n\tchar uevent[1024];\n\tint fd;\n\n\tmemset(uevent, 0, sizeof(uevent));\n\tsnprintf(uevent, sizeof(uevent) - 1, \"%s/uevent\", path);\n\n\tfd = open(uevent, O_RDONLY | O_NONBLOCK);\n\tif (fd < 0)\n\t\treturn -ENOENT;\n\n\tclose(fd);\n\n\tdir = basename((char *)path);\n\n\tstr_id = dir + sizeof(\"0003:0001:0A37.\");\n\treturn (int)strtol(str_id, NULL, 16);\n}\n\nstatic int attach_prog(struct hid_surface_dial *skel, struct bpf_program *prog, int hid_id)\n{\n\tstruct attach_prog_args args = {\n\t\t.hid = hid_id,\n\t\t.retval = -1,\n\t};\n\tint attach_fd, err;\n\tDECLARE_LIBBPF_OPTS(bpf_test_run_opts, tattr,\n\t\t\t    .ctx_in = &args,\n\t\t\t    .ctx_size_in = sizeof(args),\n\t);\n\n\tattach_fd = bpf_program__fd(skel->progs.attach_prog);\n\tif (attach_fd < 0) {\n\t\tfprintf(stderr, \"can't locate attach prog: %m\\n\");\n\t\treturn 1;\n\t}\n\n\targs.prog_fd = bpf_program__fd(prog);\n\terr = bpf_prog_test_run_opts(attach_fd, &tattr);\n\tif (err) {\n\t\tfprintf(stderr, \"can't attach prog to hid device %d: %m (err: %d)\\n\",\n\t\t\thid_id, err);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic int set_haptic(struct hid_surface_dial *skel, int hid_id)\n{\n\tstruct haptic_syscall_args args = {\n\t\t.hid = hid_id,\n\t\t.retval = -1,\n\t};\n\tint haptic_fd, err;\n\tDECLARE_LIBBPF_OPTS(bpf_test_run_opts, tattr,\n\t\t\t    .ctx_in = &args,\n\t\t\t    .ctx_size_in = sizeof(args),\n\t);\n\n\thaptic_fd = bpf_program__fd(skel->progs.set_haptic);\n\tif (haptic_fd < 0) {\n\t\tfprintf(stderr, \"can't locate haptic prog: %m\\n\");\n\t\treturn 1;\n\t}\n\n\terr = bpf_prog_test_run_opts(haptic_fd, &tattr);\n\tif (err) {\n\t\tfprintf(stderr, \"can't set haptic configuration to hid device %d: %m (err: %d)\\n\",\n\t\t\thid_id, err);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nint main(int argc, char **argv)\n{\n\tstruct hid_surface_dial *skel;\n\tstruct bpf_program *prog;\n\tconst char *optstr = \"r:\";\n\tconst char *sysfs_path;\n\tint opt, hid_id, resolution = 72;\n\n\twhile ((opt = getopt(argc, argv, optstr)) != -1) {\n\t\tswitch (opt) {\n\t\tcase 'r':\n\t\t\t{\n\t\t\t\tchar *endp = NULL;\n\t\t\t\tlong l = -1;\n\n\t\t\t\tif (optarg) {\n\t\t\t\t\tl = strtol(optarg, &endp, 10);\n\t\t\t\t\tif (endp && *endp)\n\t\t\t\t\t\tl = -1;\n\t\t\t\t}\n\n\t\t\t\tif (l < 0) {\n\t\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\t\"invalid r option %s - expecting a number\\n\",\n\t\t\t\t\t\toptarg ? optarg : \"\");\n\t\t\t\t\texit(EXIT_FAILURE);\n\t\t\t\t};\n\n\t\t\t\tresolution = (int) l;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tdefault:\n\t\t\tusage(basename(argv[0]));\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tif (optind == argc) {\n\t\tusage(basename(argv[0]));\n\t\treturn 1;\n\t}\n\n\tsysfs_path = argv[optind];\n\tif (!sysfs_path) {\n\t\tperror(\"sysfs\");\n\t\treturn 1;\n\t}\n\n\tskel = hid_surface_dial__open_and_load();\n\tif (!skel) {\n\t\tfprintf(stderr, \"%s  %s:%d\", __func__, __FILE__, __LINE__);\n\t\treturn -1;\n\t}\n\n\thid_id = get_hid_id(sysfs_path);\n\tif (hid_id < 0) {\n\t\tfprintf(stderr, \"can not open HID device: %m\\n\");\n\t\treturn 1;\n\t}\n\n\tskel->data->resolution = resolution;\n\tskel->data->physical = (int)(resolution / 72);\n\n\tbpf_object__for_each_program(prog, *skel->skeleton->obj) {\n\t\t \n\t\tif (bpf_program__get_type(prog) != BPF_PROG_TYPE_TRACING)\n\t\t\tcontinue;\n\n\t\tattach_prog(skel, prog, hid_id);\n\t}\n\n\tsignal(SIGINT, int_exit);\n\tsignal(SIGTERM, int_exit);\n\n\tset_haptic(skel, hid_id);\n\n\twhile (running)\n\t\tsleep(1);\n\n\thid_surface_dial__destroy(skel);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}