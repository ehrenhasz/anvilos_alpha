{
  "module_name": "hid_mouse.c",
  "hash_id": "f2804f26436ad9f3878f2d15a7cc7d01013ffaff12dbceabd9eda97a9e8024fa",
  "original_prompt": "Ingested from linux-6.6.14/samples/hid/hid_mouse.c",
  "human_readable_source": "\n \n\n#include <assert.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <libgen.h>\n#include <signal.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/resource.h>\n#include <unistd.h>\n\n#include <linux/bpf.h>\n#include <linux/errno.h>\n\n#include <bpf/bpf.h>\n#include <bpf/libbpf.h>\n\n#include \"hid_mouse.skel.h\"\n#include \"hid_bpf_attach.h\"\n\nstatic bool running = true;\n\nstatic void int_exit(int sig)\n{\n\trunning = false;\n\texit(0);\n}\n\nstatic void usage(const char *prog)\n{\n\tfprintf(stderr,\n\t\t\"%s: %s /sys/bus/hid/devices/0BUS:0VID:0PID:00ID\\n\\n\",\n\t\t__func__, prog);\n\tfprintf(stderr,\n\t\t\"This program will upload and attach a HID-BPF program to the given device.\\n\"\n\t\t\"On the Etekcity Scroll 6E, the X and Y axis will be inverted, but on any other\\n\"\n\t\t\"device, chances are high that the device will not be working anymore\\n\\n\"\n\t\t\"consider this as a demo and adapt the eBPF program to your needs\\n\"\n\t\t\"Hit Ctrl-C to unbind the program and reset the device\\n\");\n}\n\nstatic int get_hid_id(const char *path)\n{\n\tconst char *str_id, *dir;\n\tchar uevent[1024];\n\tint fd;\n\n\tmemset(uevent, 0, sizeof(uevent));\n\tsnprintf(uevent, sizeof(uevent) - 1, \"%s/uevent\", path);\n\n\tfd = open(uevent, O_RDONLY | O_NONBLOCK);\n\tif (fd < 0)\n\t\treturn -ENOENT;\n\n\tclose(fd);\n\n\tdir = basename((char *)path);\n\n\tstr_id = dir + sizeof(\"0003:0001:0A37.\");\n\treturn (int)strtol(str_id, NULL, 16);\n}\n\nint main(int argc, char **argv)\n{\n\tstruct hid_mouse *skel;\n\tstruct bpf_program *prog;\n\tint err;\n\tconst char *optstr = \"\";\n\tconst char *sysfs_path;\n\tint opt, hid_id, attach_fd;\n\tstruct attach_prog_args args = {\n\t\t.retval = -1,\n\t};\n\tDECLARE_LIBBPF_OPTS(bpf_test_run_opts, tattr,\n\t\t\t    .ctx_in = &args,\n\t\t\t    .ctx_size_in = sizeof(args),\n\t);\n\n\twhile ((opt = getopt(argc, argv, optstr)) != -1) {\n\t\tswitch (opt) {\n\t\tdefault:\n\t\t\tusage(basename(argv[0]));\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tif (optind == argc) {\n\t\tusage(basename(argv[0]));\n\t\treturn 1;\n\t}\n\n\tsysfs_path = argv[optind];\n\tif (!sysfs_path) {\n\t\tperror(\"sysfs\");\n\t\treturn 1;\n\t}\n\n\tskel = hid_mouse__open_and_load();\n\tif (!skel) {\n\t\tfprintf(stderr, \"%s  %s:%d\", __func__, __FILE__, __LINE__);\n\t\treturn -1;\n\t}\n\n\thid_id = get_hid_id(sysfs_path);\n\n\tif (hid_id < 0) {\n\t\tfprintf(stderr, \"can not open HID device: %m\\n\");\n\t\treturn 1;\n\t}\n\targs.hid = hid_id;\n\n\tattach_fd = bpf_program__fd(skel->progs.attach_prog);\n\tif (attach_fd < 0) {\n\t\tfprintf(stderr, \"can't locate attach prog: %m\\n\");\n\t\treturn 1;\n\t}\n\n\tbpf_object__for_each_program(prog, *skel->skeleton->obj) {\n\t\t \n\t\tif (bpf_program__get_type(prog) != BPF_PROG_TYPE_TRACING)\n\t\t\tcontinue;\n\n\t\targs.retval = -1;\n\t\targs.prog_fd = bpf_program__fd(prog);\n\t\terr = bpf_prog_test_run_opts(attach_fd, &tattr);\n\t\tif (err) {\n\t\t\tfprintf(stderr, \"can't attach prog to hid device %d: %m (err: %d)\\n\",\n\t\t\t\thid_id, err);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tsignal(SIGINT, int_exit);\n\tsignal(SIGTERM, int_exit);\n\n\twhile (running)\n\t\tsleep(1);\n\n\thid_mouse__destroy(skel);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}