{
  "module_name": "tc_l2_redirect_kern.c",
  "hash_id": "e4faeaf917a24b2dca0a02937d13d3bcce9a42a104a06aea54a0a9da749ab42e",
  "original_prompt": "Ingested from linux-6.6.14/samples/bpf/tc_l2_redirect_kern.c",
  "human_readable_source": " \n#define KBUILD_MODNAME \"foo\"\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/if_ether.h>\n#include <uapi/linux/if_packet.h>\n#include <uapi/linux/ip.h>\n#include <uapi/linux/ipv6.h>\n#include <uapi/linux/in.h>\n#include <uapi/linux/tcp.h>\n#include <uapi/linux/filter.h>\n#include <uapi/linux/pkt_cls.h>\n#include <net/ipv6.h>\n#include <bpf/bpf_helpers.h>\n\n#define _htonl __builtin_bswap32\n\n#define PIN_GLOBAL_NS\t\t2\nstruct bpf_elf_map {\n\t__u32 type;\n\t__u32 size_key;\n\t__u32 size_value;\n\t__u32 max_elem;\n\t__u32 flags;\n\t__u32 id;\n\t__u32 pinning;\n};\n\n \nstruct eth_hdr {\n\tunsigned char   h_dest[ETH_ALEN];\n\tunsigned char   h_source[ETH_ALEN];\n\tunsigned short  h_proto;\n};\n\nstruct bpf_elf_map SEC(\"maps\") tun_iface = {\n\t.type = BPF_MAP_TYPE_ARRAY,\n\t.size_key = sizeof(int),\n\t.size_value = sizeof(int),\n\t.pinning = PIN_GLOBAL_NS,\n\t.max_elem = 1,\n};\n\nstatic __always_inline bool is_vip_addr(__be16 eth_proto, __be32 daddr)\n{\n\tif (eth_proto == htons(ETH_P_IP))\n\t\treturn (_htonl(0xffffff00) & daddr) == _htonl(0x0a0a0100);\n\telse if (eth_proto == htons(ETH_P_IPV6))\n\t\treturn (daddr == _htonl(0x2401face));\n\n\treturn false;\n}\n\nSEC(\"l2_to_iptun_ingress_forward\")\nint _l2_to_iptun_ingress_forward(struct __sk_buff *skb)\n{\n\tstruct bpf_tunnel_key tkey = {};\n\tvoid *data = (void *)(long)skb->data;\n\tstruct eth_hdr *eth = data;\n\tvoid *data_end = (void *)(long)skb->data_end;\n\tint key = 0, *ifindex;\n\n\tint ret;\n\n\tif (data + sizeof(*eth) > data_end)\n\t\treturn TC_ACT_OK;\n\n\tifindex = bpf_map_lookup_elem(&tun_iface, &key);\n\tif (!ifindex)\n\t\treturn TC_ACT_OK;\n\n\tif (eth->h_proto == htons(ETH_P_IP)) {\n\t\tchar fmt4[] = \"ingress forward to ifindex:%d daddr4:%x\\n\";\n\t\tstruct iphdr *iph = data + sizeof(*eth);\n\n\t\tif (data + sizeof(*eth) + sizeof(*iph) > data_end)\n\t\t\treturn TC_ACT_OK;\n\n\t\tif (iph->protocol != IPPROTO_IPIP)\n\t\t\treturn TC_ACT_OK;\n\n\t\tbpf_trace_printk(fmt4, sizeof(fmt4), *ifindex,\n\t\t\t\t _htonl(iph->daddr));\n\t\treturn bpf_redirect(*ifindex, BPF_F_INGRESS);\n\t} else if (eth->h_proto == htons(ETH_P_IPV6)) {\n\t\tchar fmt6[] = \"ingress forward to ifindex:%d daddr6:%x::%x\\n\";\n\t\tstruct ipv6hdr *ip6h = data + sizeof(*eth);\n\n\t\tif (data + sizeof(*eth) + sizeof(*ip6h) > data_end)\n\t\t\treturn TC_ACT_OK;\n\n\t\tif (ip6h->nexthdr != IPPROTO_IPIP &&\n\t\t    ip6h->nexthdr != IPPROTO_IPV6)\n\t\t\treturn TC_ACT_OK;\n\n\t\tbpf_trace_printk(fmt6, sizeof(fmt6), *ifindex,\n\t\t\t\t _htonl(ip6h->daddr.s6_addr32[0]),\n\t\t\t\t _htonl(ip6h->daddr.s6_addr32[3]));\n\t\treturn bpf_redirect(*ifindex, BPF_F_INGRESS);\n\t}\n\n\treturn TC_ACT_OK;\n}\n\nSEC(\"l2_to_iptun_ingress_redirect\")\nint _l2_to_iptun_ingress_redirect(struct __sk_buff *skb)\n{\n\tstruct bpf_tunnel_key tkey = {};\n\tvoid *data = (void *)(long)skb->data;\n\tstruct eth_hdr *eth = data;\n\tvoid *data_end = (void *)(long)skb->data_end;\n\tint key = 0, *ifindex;\n\n\tint ret;\n\n\tif (data + sizeof(*eth) > data_end)\n\t\treturn TC_ACT_OK;\n\n\tifindex = bpf_map_lookup_elem(&tun_iface, &key);\n\tif (!ifindex)\n\t\treturn TC_ACT_OK;\n\n\tif (eth->h_proto == htons(ETH_P_IP)) {\n\t\tchar fmt4[] = \"e/ingress redirect daddr4:%x to ifindex:%d\\n\";\n\t\tstruct iphdr *iph = data + sizeof(*eth);\n\t\t__be32 daddr = iph->daddr;\n\n\t\tif (data + sizeof(*eth) + sizeof(*iph) > data_end)\n\t\t\treturn TC_ACT_OK;\n\n\t\tif (!is_vip_addr(eth->h_proto, daddr))\n\t\t\treturn TC_ACT_OK;\n\n\t\tbpf_trace_printk(fmt4, sizeof(fmt4), _htonl(daddr), *ifindex);\n\t} else {\n\t\treturn TC_ACT_OK;\n\t}\n\n\ttkey.tunnel_id = 10000;\n\ttkey.tunnel_ttl = 64;\n\ttkey.remote_ipv4 = 0x0a020166;  \n\tbpf_skb_set_tunnel_key(skb, &tkey, sizeof(tkey), 0);\n\treturn bpf_redirect(*ifindex, 0);\n}\n\nSEC(\"l2_to_ip6tun_ingress_redirect\")\nint _l2_to_ip6tun_ingress_redirect(struct __sk_buff *skb)\n{\n\tstruct bpf_tunnel_key tkey = {};\n\tvoid *data = (void *)(long)skb->data;\n\tstruct eth_hdr *eth = data;\n\tvoid *data_end = (void *)(long)skb->data_end;\n\tint key = 0, *ifindex;\n\n\tif (data + sizeof(*eth) > data_end)\n\t\treturn TC_ACT_OK;\n\n\tifindex = bpf_map_lookup_elem(&tun_iface, &key);\n\tif (!ifindex)\n\t\treturn TC_ACT_OK;\n\n\tif (eth->h_proto == htons(ETH_P_IP)) {\n\t\tchar fmt4[] = \"e/ingress redirect daddr4:%x to ifindex:%d\\n\";\n\t\tstruct iphdr *iph = data + sizeof(*eth);\n\n\t\tif (data + sizeof(*eth) + sizeof(*iph) > data_end)\n\t\t\treturn TC_ACT_OK;\n\n\t\tif (!is_vip_addr(eth->h_proto, iph->daddr))\n\t\t\treturn TC_ACT_OK;\n\n\t\tbpf_trace_printk(fmt4, sizeof(fmt4), _htonl(iph->daddr),\n\t\t\t\t *ifindex);\n\t} else if (eth->h_proto == htons(ETH_P_IPV6)) {\n\t\tchar fmt6[] = \"e/ingress redirect daddr6:%x to ifindex:%d\\n\";\n\t\tstruct ipv6hdr *ip6h = data + sizeof(*eth);\n\n\t\tif (data + sizeof(*eth) + sizeof(*ip6h) > data_end)\n\t\t\treturn TC_ACT_OK;\n\n\t\tif (!is_vip_addr(eth->h_proto, ip6h->daddr.s6_addr32[0]))\n\t\t\treturn TC_ACT_OK;\n\n\t\tbpf_trace_printk(fmt6, sizeof(fmt6),\n\t\t\t\t _htonl(ip6h->daddr.s6_addr32[0]), *ifindex);\n\t} else {\n\t\treturn TC_ACT_OK;\n\t}\n\n\ttkey.tunnel_id = 10000;\n\ttkey.tunnel_ttl = 64;\n\t \n\ttkey.remote_ipv6[0] = _htonl(0x2401db02);\n\ttkey.remote_ipv6[1] = 0;\n\ttkey.remote_ipv6[2] = 0;\n\ttkey.remote_ipv6[3] = _htonl(0x00000066);\n\tbpf_skb_set_tunnel_key(skb, &tkey, sizeof(tkey), BPF_F_TUNINFO_IPV6);\n\treturn bpf_redirect(*ifindex, 0);\n}\n\nSEC(\"drop_non_tun_vip\")\nint _drop_non_tun_vip(struct __sk_buff *skb)\n{\n\tstruct bpf_tunnel_key tkey = {};\n\tvoid *data = (void *)(long)skb->data;\n\tstruct eth_hdr *eth = data;\n\tvoid *data_end = (void *)(long)skb->data_end;\n\n\tif (data + sizeof(*eth) > data_end)\n\t\treturn TC_ACT_OK;\n\n\tif (eth->h_proto == htons(ETH_P_IP)) {\n\t\tstruct iphdr *iph = data + sizeof(*eth);\n\n\t\tif (data + sizeof(*eth) + sizeof(*iph) > data_end)\n\t\t\treturn TC_ACT_OK;\n\n\t\tif (is_vip_addr(eth->h_proto, iph->daddr))\n\t\t\treturn TC_ACT_SHOT;\n\t} else if (eth->h_proto == htons(ETH_P_IPV6)) {\n\t\tstruct ipv6hdr *ip6h = data + sizeof(*eth);\n\n\t\tif (data + sizeof(*eth) + sizeof(*ip6h) > data_end)\n\t\t\treturn TC_ACT_OK;\n\n\t\tif (is_vip_addr(eth->h_proto, ip6h->daddr.s6_addr32[0]))\n\t\t\treturn TC_ACT_SHOT;\n\t}\n\n\treturn TC_ACT_OK;\n}\n\nchar _license[] SEC(\"license\") = \"GPL\";\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}