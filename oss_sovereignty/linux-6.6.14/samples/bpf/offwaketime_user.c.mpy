{
  "module_name": "offwaketime_user.c",
  "hash_id": "3fd629b6f48598171052915754128eca57ad8e9789cbee6272effd72706189c3",
  "original_prompt": "Ingested from linux-6.6.14/samples/bpf/offwaketime_user.c",
  "human_readable_source": "\n \n#include <stdio.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <linux/perf_event.h>\n#include <errno.h>\n#include <stdbool.h>\n#include <bpf/libbpf.h>\n#include <bpf/bpf.h>\n#include \"trace_helpers.h\"\n\n#define PRINT_RAW_ADDR 0\n\n \nstatic int map_fd[2];\n\nstatic void print_ksym(__u64 addr)\n{\n\tstruct ksym *sym;\n\n\tif (!addr)\n\t\treturn;\n\tsym = ksym_search(addr);\n\tif (!sym) {\n\t\tprintf(\"ksym not found. Is kallsyms loaded?\\n\");\n\t\treturn;\n\t}\n\n\tif (PRINT_RAW_ADDR)\n\t\tprintf(\"%s/%llx;\", sym->name, addr);\n\telse\n\t\tprintf(\"%s;\", sym->name);\n}\n\n#define TASK_COMM_LEN 16\n\nstruct key_t {\n\tchar waker[TASK_COMM_LEN];\n\tchar target[TASK_COMM_LEN];\n\t__u32 wret;\n\t__u32 tret;\n};\n\nstatic void print_stack(struct key_t *key, __u64 count)\n{\n\t__u64 ip[PERF_MAX_STACK_DEPTH] = {};\n\tstatic bool warned;\n\tint i;\n\n\tprintf(\"%s;\", key->target);\n\tif (bpf_map_lookup_elem(map_fd[1], &key->tret, ip) != 0) {\n\t\tprintf(\"---;\");\n\t} else {\n\t\tfor (i = PERF_MAX_STACK_DEPTH - 1; i >= 0; i--)\n\t\t\tprint_ksym(ip[i]);\n\t}\n\tprintf(\"-;\");\n\tif (bpf_map_lookup_elem(map_fd[1], &key->wret, ip) != 0) {\n\t\tprintf(\"---;\");\n\t} else {\n\t\tfor (i = 0; i < PERF_MAX_STACK_DEPTH; i++)\n\t\t\tprint_ksym(ip[i]);\n\t}\n\tprintf(\";%s %lld\\n\", key->waker, count);\n\n\tif ((key->tret == -EEXIST || key->wret == -EEXIST) && !warned) {\n\t\tprintf(\"stackmap collisions seen. Consider increasing size\\n\");\n\t\twarned = true;\n\t} else if (((int)(key->tret) < 0 || (int)(key->wret) < 0)) {\n\t\tprintf(\"err stackid %d %d\\n\", key->tret, key->wret);\n\t}\n}\n\nstatic void print_stacks(int fd)\n{\n\tstruct key_t key = {}, next_key;\n\t__u64 value;\n\n\twhile (bpf_map_get_next_key(fd, &key, &next_key) == 0) {\n\t\tbpf_map_lookup_elem(fd, &next_key, &value);\n\t\tprint_stack(&next_key, value);\n\t\tkey = next_key;\n\t}\n}\n\nstatic void int_exit(int sig)\n{\n\tprint_stacks(map_fd[0]);\n\texit(0);\n}\n\nint main(int argc, char **argv)\n{\n\tstruct bpf_object *obj = NULL;\n\tstruct bpf_link *links[2];\n\tstruct bpf_program *prog;\n\tint delay = 1, i = 0;\n\tchar filename[256];\n\n\tif (load_kallsyms()) {\n\t\tprintf(\"failed to process /proc/kallsyms\\n\");\n\t\treturn 2;\n\t}\n\n\tsnprintf(filename, sizeof(filename), \"%s.bpf.o\", argv[0]);\n\tobj = bpf_object__open_file(filename, NULL);\n\tif (libbpf_get_error(obj)) {\n\t\tfprintf(stderr, \"ERROR: opening BPF object file failed\\n\");\n\t\tobj = NULL;\n\t\tgoto cleanup;\n\t}\n\n\t \n\tif (bpf_object__load(obj)) {\n\t\tfprintf(stderr, \"ERROR: loading BPF object file failed\\n\");\n\t\tgoto cleanup;\n\t}\n\n\tmap_fd[0] = bpf_object__find_map_fd_by_name(obj, \"counts\");\n\tmap_fd[1] = bpf_object__find_map_fd_by_name(obj, \"stackmap\");\n\tif (map_fd[0] < 0 || map_fd[1] < 0) {\n\t\tfprintf(stderr, \"ERROR: finding a map in obj file failed\\n\");\n\t\tgoto cleanup;\n\t}\n\n\tsignal(SIGINT, int_exit);\n\tsignal(SIGTERM, int_exit);\n\n\tbpf_object__for_each_program(prog, obj) {\n\t\tlinks[i] = bpf_program__attach(prog);\n\t\tif (libbpf_get_error(links[i])) {\n\t\t\tfprintf(stderr, \"ERROR: bpf_program__attach failed\\n\");\n\t\t\tlinks[i] = NULL;\n\t\t\tgoto cleanup;\n\t\t}\n\t\ti++;\n\t}\n\n\tif (argc > 1)\n\t\tdelay = atoi(argv[1]);\n\tsleep(delay);\n\tprint_stacks(map_fd[0]);\n\ncleanup:\n\tfor (i--; i >= 0; i--)\n\t\tbpf_link__destroy(links[i]);\n\n\tbpf_object__close(obj);\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}