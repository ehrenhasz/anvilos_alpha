{
  "module_name": "cookie_uid_helper_example.c",
  "hash_id": "863c2a64d635614481037a82cc92e895aa0226412868d4d853dda0f0ca7ea66e",
  "original_prompt": "Ingested from linux-6.6.14/samples/bpf/cookie_uid_helper_example.c",
  "human_readable_source": " \n\n#define _GNU_SOURCE\n\n#define offsetof(type, member)\t__builtin_offsetof(type, member)\n#define ARRAY_SIZE(x) (sizeof(x) / sizeof(*(x)))\n\n#include <arpa/inet.h>\n#include <errno.h>\n#include <error.h>\n#include <limits.h>\n#include <linux/bpf.h>\n#include <linux/if_ether.h>\n#include <net/if.h>\n#include <signal.h>\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <bpf/bpf.h>\n#include \"bpf_insn.h\"\n\n#define PORT 8888\n\nstruct stats {\n\tuint32_t uid;\n\tuint64_t packets;\n\tuint64_t bytes;\n};\n\nstatic int map_fd, prog_fd;\n\nstatic bool test_finish;\n\nstatic void maps_create(void)\n{\n\tmap_fd = bpf_map_create(BPF_MAP_TYPE_HASH, NULL, sizeof(uint32_t),\n\t\t\t\tsizeof(struct stats), 100, NULL);\n\tif (map_fd < 0)\n\t\terror(1, errno, \"map create failed!\\n\");\n}\n\nstatic void prog_load(void)\n{\n\tstatic char log_buf[1 << 16];\n\n\tstruct bpf_insn prog[] = {\n\t\t \n\t\tBPF_MOV64_REG(BPF_REG_6, BPF_REG_1),\n\t\t \n\t\tBPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0,\n\t\t\t\tBPF_FUNC_get_socket_cookie),\n\t\t \n\t\tBPF_STX_MEM(BPF_DW, BPF_REG_10, BPF_REG_0, -8),\n\t\tBPF_MOV64_REG(BPF_REG_7, BPF_REG_10),\n\t\tBPF_ALU64_IMM(BPF_ADD, BPF_REG_7, -8),\n\t\t \n\t\tBPF_LD_MAP_FD(BPF_REG_1, map_fd),\n\t\tBPF_MOV64_REG(BPF_REG_2, BPF_REG_7),\n\t\tBPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0,\n\t\t\t\tBPF_FUNC_map_lookup_elem),\n\t\t \n\t\tBPF_JMP_IMM(BPF_JNE, BPF_REG_0, 0, 14),\n\t\tBPF_MOV64_REG(BPF_REG_1, BPF_REG_6),\n\t\tBPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0,\n\t\t\t\tBPF_FUNC_get_socket_uid),\n\t\t \n\t\tBPF_STX_MEM(BPF_DW, BPF_REG_10, BPF_REG_0,\n\t\t\t    -32 + (__s16)offsetof(struct stats, uid)),\n\t\tBPF_ST_MEM(BPF_DW, BPF_REG_10,\n\t\t\t   -32 + (__s16)offsetof(struct stats, packets), 1),\n\t\t \n\t\tBPF_LDX_MEM(BPF_W, BPF_REG_1, BPF_REG_6,\n\t\t\t\toffsetof(struct __sk_buff, len)),\n\t\tBPF_STX_MEM(BPF_DW, BPF_REG_10, BPF_REG_1,\n\t\t\t    -32 + (__s16)offsetof(struct stats, bytes)),\n\t\t \n\t\tBPF_LD_MAP_FD(BPF_REG_1, map_fd),\n\t\tBPF_MOV64_REG(BPF_REG_2, BPF_REG_7),\n\t\tBPF_MOV64_REG(BPF_REG_3, BPF_REG_10),\n\t\tBPF_ALU64_IMM(BPF_ADD, BPF_REG_3, -32),\n\t\tBPF_MOV64_IMM(BPF_REG_4, 0),\n\t\tBPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0,\n\t\t\t\tBPF_FUNC_map_update_elem),\n\t\tBPF_JMP_IMM(BPF_JA, 0, 0, 5),\n\t\t \n\t\tBPF_MOV64_REG(BPF_REG_9, BPF_REG_0),\n\t\tBPF_MOV64_IMM(BPF_REG_1, 1),\n\t\tBPF_ATOMIC_OP(BPF_DW, BPF_ADD, BPF_REG_9, BPF_REG_1,\n\t\t\t      offsetof(struct stats, packets)),\n\t\tBPF_LDX_MEM(BPF_W, BPF_REG_1, BPF_REG_6,\n\t\t\t\toffsetof(struct __sk_buff, len)),\n\t\tBPF_ATOMIC_OP(BPF_DW, BPF_ADD, BPF_REG_9, BPF_REG_1,\n\t\t\t      offsetof(struct stats, bytes)),\n\t\tBPF_LDX_MEM(BPF_W, BPF_REG_0, BPF_REG_6,\n\t\t\t\toffsetof(struct __sk_buff, len)),\n\t\tBPF_EXIT_INSN(),\n\t};\n\tLIBBPF_OPTS(bpf_prog_load_opts, opts,\n\t\t.log_buf = log_buf,\n\t\t.log_size = sizeof(log_buf),\n\t);\n\n\tprog_fd = bpf_prog_load(BPF_PROG_TYPE_SOCKET_FILTER, NULL, \"GPL\",\n\t\t\t\tprog, ARRAY_SIZE(prog), &opts);\n\tif (prog_fd < 0)\n\t\terror(1, errno, \"failed to load prog\\n%s\\n\", log_buf);\n}\n\nstatic void prog_attach_iptables(char *file)\n{\n\tint ret;\n\tchar rules[256];\n\n\tif (bpf_obj_pin(prog_fd, file))\n\t\terror(1, errno, \"bpf_obj_pin\");\n\tif (strlen(file) > 50) {\n\t\tprintf(\"file path too long: %s\\n\", file);\n\t\texit(1);\n\t}\n\tret = snprintf(rules, sizeof(rules),\n\t\t       \"iptables -A OUTPUT -m bpf --object-pinned %s -j ACCEPT\",\n\t\t       file);\n\tif (ret < 0 || ret >= sizeof(rules)) {\n\t\tprintf(\"error constructing iptables command\\n\");\n\t\texit(1);\n\t}\n\tret = system(rules);\n\tif (ret < 0) {\n\t\tprintf(\"iptables rule update failed: %d/n\", WEXITSTATUS(ret));\n\t\texit(1);\n\t}\n}\n\nstatic void print_table(void)\n{\n\tstruct stats curEntry;\n\tuint32_t curN = UINT32_MAX;\n\tuint32_t nextN;\n\tint res;\n\n\twhile (bpf_map_get_next_key(map_fd, &curN, &nextN) > -1) {\n\t\tcurN = nextN;\n\t\tres = bpf_map_lookup_elem(map_fd, &curN, &curEntry);\n\t\tif (res < 0) {\n\t\t\terror(1, errno, \"fail to get entry value of Key: %u\\n\",\n\t\t\t\tcurN);\n\t\t} else {\n\t\t\tprintf(\"cookie: %u, uid: 0x%x, Packet Count: %lu,\"\n\t\t\t\t\" Bytes Count: %lu\\n\", curN, curEntry.uid,\n\t\t\t\tcurEntry.packets, curEntry.bytes);\n\t\t}\n\t}\n}\n\nstatic void udp_client(void)\n{\n\tstruct sockaddr_in si_other = {0};\n\tstruct sockaddr_in si_me = {0};\n\tstruct stats dataEntry;\n\tint s_rcv, s_send, i, recv_len;\n\tchar message = 'a';\n\tchar buf;\n\tuint64_t cookie;\n\tint res;\n\tsocklen_t cookie_len = sizeof(cookie);\n\tsocklen_t slen = sizeof(si_other);\n\n\ts_rcv = socket(PF_INET, SOCK_DGRAM, 0);\n\tif (s_rcv < 0)\n\t\terror(1, errno, \"rcv socket creat failed!\\n\");\n\tsi_other.sin_family = AF_INET;\n\tsi_other.sin_port = htons(PORT);\n\tif (inet_aton(\"127.0.0.1\", &si_other.sin_addr) == 0)\n\t\terror(1, errno, \"inet_aton\\n\");\n\tif (bind(s_rcv, (struct sockaddr *)&si_other, sizeof(si_other)) == -1)\n\t\terror(1, errno, \"bind\\n\");\n\ts_send = socket(PF_INET, SOCK_DGRAM, 0);\n\tif (s_send < 0)\n\t\terror(1, errno, \"send socket creat failed!\\n\");\n\tres = getsockopt(s_send, SOL_SOCKET, SO_COOKIE, &cookie, &cookie_len);\n\tif (res < 0)\n\t\tprintf(\"get cookie failed: %s\\n\", strerror(errno));\n\tres = bpf_map_lookup_elem(map_fd, &cookie, &dataEntry);\n\tif (res != -1)\n\t\terror(1, errno, \"socket stat found while flow not active\\n\");\n\tfor (i = 0; i < 10; i++) {\n\t\tres = sendto(s_send, &message, sizeof(message), 0,\n\t\t\t     (struct sockaddr *)&si_other, slen);\n\t\tif (res == -1)\n\t\t\terror(1, errno, \"send\\n\");\n\t\tif (res != sizeof(message))\n\t\t\terror(1, 0, \"%uB != %luB\\n\", res, sizeof(message));\n\t\trecv_len = recvfrom(s_rcv, &buf, sizeof(buf), 0,\n\t\t\t     (struct sockaddr *)&si_me, &slen);\n\t\tif (recv_len < 0)\n\t\t\terror(1, errno, \"receive\\n\");\n\t\tres = memcmp(&(si_other.sin_addr), &(si_me.sin_addr),\n\t\t\t   sizeof(si_me.sin_addr));\n\t\tif (res != 0)\n\t\t\terror(1, EFAULT, \"sender addr error: %d\\n\", res);\n\t\tprintf(\"Message received: %c\\n\", buf);\n\t\tres = bpf_map_lookup_elem(map_fd, &cookie, &dataEntry);\n\t\tif (res < 0)\n\t\t\terror(1, errno, \"lookup sk stat failed, cookie: %lu\\n\",\n\t\t\t      cookie);\n\t\tprintf(\"cookie: %lu, uid: 0x%x, Packet Count: %lu,\"\n\t\t\t\" Bytes Count: %lu\\n\\n\", cookie, dataEntry.uid,\n\t\t\tdataEntry.packets, dataEntry.bytes);\n\t}\n\tclose(s_send);\n\tclose(s_rcv);\n}\n\nstatic int usage(void)\n{\n\tprintf(\"Usage: ./run_cookie_uid_helper_example.sh\"\n\t\t\" bpfObjName -option\\n\"\n\t\t\"\t-t\ttraffic monitor test\\n\"\n\t\t\"\t-s\tgetsockopt cookie test\\n\");\n\treturn 1;\n}\n\nstatic void finish(int ret)\n{\n\ttest_finish = true;\n}\n\nint main(int argc, char *argv[])\n{\n\tint opt;\n\tbool cfg_test_traffic = false;\n\tbool cfg_test_cookie = false;\n\n\tif (argc != 3)\n\t\treturn usage();\n\twhile ((opt = getopt(argc, argv, \"ts\")) != -1) {\n\t\tswitch (opt) {\n\t\tcase 't':\n\t\t\tcfg_test_traffic = true;\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tcfg_test_cookie = true;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tprintf(\"unknown option %c\\n\", opt);\n\t\t\tusage();\n\t\t\treturn -1;\n\t\t}\n\t}\n\tmaps_create();\n\tprog_load();\n\tprog_attach_iptables(argv[2]);\n\tif (cfg_test_traffic) {\n\t\tif (signal(SIGINT, finish) == SIG_ERR)\n\t\t\terror(1, errno, \"register SIGINT handler failed\");\n\t\tif (signal(SIGTERM, finish) == SIG_ERR)\n\t\t\terror(1, errno, \"register SIGTERM handler failed\");\n\t\twhile (!test_finish) {\n\t\t\tprint_table();\n\t\t\tprintf(\"\\n\");\n\t\t\tsleep(1);\n\t\t}\n\t} else if (cfg_test_cookie) {\n\t\tudp_client();\n\t}\n\tclose(prog_fd);\n\tclose(map_fd);\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}