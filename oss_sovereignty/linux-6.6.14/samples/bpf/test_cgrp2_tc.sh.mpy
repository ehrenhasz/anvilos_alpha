{
  "module_name": "test_cgrp2_tc.sh",
  "hash_id": "6ec3ea4b141e87f74be0bc052c5b90c830c7eaded8d6f8e5d3eb7f8db98b8f85",
  "original_prompt": "Ingested from linux-6.6.14/samples/bpf/test_cgrp2_tc.sh",
  "human_readable_source": "#!/bin/bash\n# SPDX-License-Identifier: GPL-2.0\n\nMY_DIR=$(dirname $0)\n# Details on the bpf prog\nBPF_CGRP2_ARRAY_NAME='test_cgrp2_array_pin'\nBPF_PROG=\"$MY_DIR/test_cgrp2_tc.bpf.o\"\nBPF_SECTION='filter'\n\n[ -z \"$TC\" ] && TC='tc'\n[ -z \"$IP\" ] && IP='ip'\n\n# Names of the veth interface, net namespace...etc.\nHOST_IFC='ve'\nNS_IFC='vens'\nNS='ns'\n\nfind_mnt() {\n    cat /proc/mounts | \\\n\tawk '{ if ($3 == \"'$1'\" && mnt == \"\") { mnt = $2 }} END { print mnt }'\n}\n\n# Init cgroup2 vars\ninit_cgrp2_vars() {\n    CGRP2_ROOT=$(find_mnt cgroup2)\n    if [ -z \"$CGRP2_ROOT\" ]\n    then\n\tCGRP2_ROOT='/mnt/cgroup2'\n\tMOUNT_CGRP2=\"yes\"\n    fi\n    CGRP2_TC=\"$CGRP2_ROOT/tc\"\n    CGRP2_TC_LEAF=\"$CGRP2_TC/leaf\"\n}\n\n# Init bpf fs vars\ninit_bpf_fs_vars() {\n    local bpf_fs_root=$(find_mnt bpf)\n    [ -n \"$bpf_fs_root\" ] || return -1\n    BPF_FS_TC_SHARE=\"$bpf_fs_root/tc/globals\"\n}\n\nsetup_cgrp2() {\n    case $1 in\n\tstart)\n\t    if [ \"$MOUNT_CGRP2\" == 'yes' ]\n\t    then\n\t\t[ -d $CGRP2_ROOT ] || mkdir -p $CGRP2_ROOT\n\t\tmount -t cgroup2 none $CGRP2_ROOT || return $?\n\t    fi\n\t    mkdir -p $CGRP2_TC_LEAF\n\t    ;;\n\t*)\n\t    rmdir $CGRP2_TC_LEAF && rmdir $CGRP2_TC\n\t    [ \"$MOUNT_CGRP2\" == 'yes' ] && umount $CGRP2_ROOT\n\t    ;;\n    esac\n}\n\nsetup_bpf_cgrp2_array() {\n    local bpf_cgrp2_array=\"$BPF_FS_TC_SHARE/$BPF_CGRP2_ARRAY_NAME\"\n    case $1 in\n\tstart)\n\t    $MY_DIR/test_cgrp2_array_pin -U $bpf_cgrp2_array -v $CGRP2_TC\n\t    ;;\n\t*)\n\t    [ -d \"$BPF_FS_TC_SHARE\" ] && rm -f $bpf_cgrp2_array\n\t    ;;\n    esac\n}\n\nsetup_net() {\n    case $1 in\n\tstart)\n\t    $IP link add $HOST_IFC type veth peer name $NS_IFC || return $?\n\t    $IP link set dev $HOST_IFC up || return $?\n\t    sysctl -q net.ipv6.conf.$HOST_IFC.disable_ipv6=0\n\t    sysctl -q net.ipv6.conf.$HOST_IFC.accept_dad=0\n\n\t    $IP netns add $NS || return $?\n\t    $IP link set dev $NS_IFC netns $NS || return $?\n\t    $IP -n $NS link set dev $NS_IFC up || return $?\n\t    $IP netns exec $NS sysctl -q net.ipv6.conf.$NS_IFC.disable_ipv6=0\n\t    $IP netns exec $NS sysctl -q net.ipv6.conf.$NS_IFC.accept_dad=0\n\t    $TC qdisc add dev $HOST_IFC clsact || return $?\n\t    $TC filter add dev $HOST_IFC egress bpf da obj $BPF_PROG sec $BPF_SECTION || return $?\n\t    ;;\n\t*)\n\t    $IP netns del $NS\n\t    $IP link del $HOST_IFC\n\t    ;;\n    esac\n}\n\nrun_in_cgrp() {\n    # Fork another bash and move it under the specified cgroup.\n    # It makes the cgroup cleanup easier at the end of the test.\n    cmd='echo $$ > '\n    cmd=\"$cmd $1/cgroup.procs; exec $2\"\n    bash -c \"$cmd\"\n}\n\ndo_test() {\n    run_in_cgrp $CGRP2_TC_LEAF \"ping -6 -c3 ff02::1%$HOST_IFC >& /dev/null\"\n    local dropped=$($TC -s qdisc show dev $HOST_IFC | tail -3 | \\\n\t\t\t   awk '/drop/{print substr($7, 0, index($7, \",\")-1)}')\n    if [[ $dropped -eq 0 ]]\n    then\n\techo \"FAIL\"\n\treturn 1\n    else\n\techo \"Successfully filtered $dropped packets\"\n\treturn 0\n    fi\n}\n\ndo_exit() {\n    if [ \"$DEBUG\" == \"yes\" ] && [ \"$MODE\" != 'cleanuponly' ]\n    then\n\techo \"------ DEBUG ------\"\n\techo \"mount: \"; mount | grep -E '(cgroup2|bpf)'; echo\n\techo \"$CGRP2_TC_LEAF: \"; ls -l $CGRP2_TC_LEAF; echo\n\tif [ -d \"$BPF_FS_TC_SHARE\" ]\n\tthen\n\t    echo \"$BPF_FS_TC_SHARE: \"; ls -l $BPF_FS_TC_SHARE; echo\n\tfi\n\techo \"Host net:\"\n\t$IP netns\n\t$IP link show dev $HOST_IFC\n\t$IP -6 a show dev $HOST_IFC\n\t$TC -s qdisc show dev $HOST_IFC\n\techo\n\techo \"$NS net:\"\n\t$IP -n $NS link show dev $NS_IFC\n\t$IP -n $NS -6 link show dev $NS_IFC\n\techo \"------ DEBUG ------\"\n\techo\n    fi\n\n    if [ \"$MODE\" != 'nocleanup' ]\n    then\n\tsetup_net stop\n\tsetup_bpf_cgrp2_array stop\n\tsetup_cgrp2 stop\n    fi\n}\n\ninit_cgrp2_vars\ninit_bpf_fs_vars\n\nwhile [[ $# -ge 1 ]]\ndo\n    a=\"$1\"\n    case $a in\n\tdebug)\n\t    DEBUG='yes'\n\t    shift 1\n\t    ;;\n\tcleanup-only)\n\t    MODE='cleanuponly'\n\t    shift 1\n\t    ;;\n\tno-cleanup)\n\t    MODE='nocleanup'\n\t    shift 1\n\t    ;;\n\t*)\n\t    echo \"test_cgrp2_tc [debug] [cleanup-only | no-cleanup]\"\n\t    echo \"  debug: Print cgrp and network setup details at the end of the test\"\n\t    echo \"  cleanup-only: Try to cleanup things from last test.  No test will be run\"\n\t    echo \"  no-cleanup: Run the test but don't do cleanup at the end\"\n\t    echo \"[Note: If no arg is given, it will run the test and do cleanup at the end]\"\n\t    echo\n\t    exit -1\n\t    ;;\n    esac\ndone\n\ntrap do_exit 0\n\n[ \"$MODE\" == 'cleanuponly' ] && exit\n\nsetup_cgrp2 start || exit $?\nsetup_net start || exit $?\ninit_bpf_fs_vars || exit $?\nsetup_bpf_cgrp2_array start || exit $?\ndo_test\necho\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}