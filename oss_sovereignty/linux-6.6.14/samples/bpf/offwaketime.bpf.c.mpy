{
  "module_name": "offwaketime.bpf.c",
  "hash_id": "63a1d56f89a02b37ba733fb0ff8e36f9fcfba15e4937cb5b36af6e9e631aba40",
  "original_prompt": "Ingested from linux-6.6.14/samples/bpf/offwaketime.bpf.c",
  "human_readable_source": " \n#include \"vmlinux.h\"\n#include <linux/version.h>\n#include <bpf/bpf_helpers.h>\n#include <bpf/bpf_tracing.h>\n#include <bpf/bpf_core_read.h>\n\n#ifndef PERF_MAX_STACK_DEPTH\n#define PERF_MAX_STACK_DEPTH         127\n#endif\n\n#define MINBLOCK_US\t1\n#define MAX_ENTRIES\t10000\n\nstruct key_t {\n\tchar waker[TASK_COMM_LEN];\n\tchar target[TASK_COMM_LEN];\n\tu32 wret;\n\tu32 tret;\n};\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_HASH);\n\t__type(key, struct key_t);\n\t__type(value, u64);\n\t__uint(max_entries, MAX_ENTRIES);\n} counts SEC(\".maps\");\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_HASH);\n\t__type(key, u32);\n\t__type(value, u64);\n\t__uint(max_entries, MAX_ENTRIES);\n} start SEC(\".maps\");\n\nstruct wokeby_t {\n\tchar name[TASK_COMM_LEN];\n\tu32 ret;\n};\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_HASH);\n\t__type(key, u32);\n\t__type(value, struct wokeby_t);\n\t__uint(max_entries, MAX_ENTRIES);\n} wokeby SEC(\".maps\");\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_STACK_TRACE);\n\t__uint(key_size, sizeof(u32));\n\t__uint(value_size, PERF_MAX_STACK_DEPTH * sizeof(u64));\n\t__uint(max_entries, MAX_ENTRIES);\n} stackmap SEC(\".maps\");\n\n#define STACKID_FLAGS (0 | BPF_F_FAST_STACK_CMP)\n\nSEC(\"kprobe/try_to_wake_up\")\nint waker(struct pt_regs *ctx)\n{\n\tstruct task_struct *p = (void *)PT_REGS_PARM1_CORE(ctx);\n\tu32 pid = BPF_CORE_READ(p, pid);\n\tstruct wokeby_t woke;\n\n\tbpf_get_current_comm(&woke.name, sizeof(woke.name));\n\twoke.ret = bpf_get_stackid(ctx, &stackmap, STACKID_FLAGS);\n\n\tbpf_map_update_elem(&wokeby, &pid, &woke, BPF_ANY);\n\treturn 0;\n}\n\nstatic inline int update_counts(void *ctx, u32 pid, u64 delta)\n{\n\tstruct wokeby_t *woke;\n\tu64 zero = 0, *val;\n\tstruct key_t key;\n\n\t__builtin_memset(&key.waker, 0, sizeof(key.waker));\n\tbpf_get_current_comm(&key.target, sizeof(key.target));\n\tkey.tret = bpf_get_stackid(ctx, &stackmap, STACKID_FLAGS);\n\tkey.wret = 0;\n\n\twoke = bpf_map_lookup_elem(&wokeby, &pid);\n\tif (woke) {\n\t\tkey.wret = woke->ret;\n\t\t__builtin_memcpy(&key.waker, woke->name, sizeof(key.waker));\n\t\tbpf_map_delete_elem(&wokeby, &pid);\n\t}\n\n\tval = bpf_map_lookup_elem(&counts, &key);\n\tif (!val) {\n\t\tbpf_map_update_elem(&counts, &key, &zero, BPF_NOEXIST);\n\t\tval = bpf_map_lookup_elem(&counts, &key);\n\t\tif (!val)\n\t\t\treturn 0;\n\t}\n\t(*val) += delta;\n\treturn 0;\n}\n\n#if 1\n \nSEC(\"tracepoint/sched/sched_switch\")\nint oncpu(struct trace_event_raw_sched_switch *ctx)\n{\n\t \n\tu32 pid = ctx->prev_pid;\n#else\nSEC(\"kprobe.multi/finish_task_switch*\")\nint oncpu(struct pt_regs *ctx)\n{\n\tstruct task_struct *p = (void *)PT_REGS_PARM1_CORE(ctx);\n\t \n\tu32 pid = BPF_CORE_READ(p, pid);\n#endif\n\tu64 delta, ts, *tsp;\n\n\tts = bpf_ktime_get_ns();\n\tbpf_map_update_elem(&start, &pid, &ts, BPF_ANY);\n\n\t \n\tpid = bpf_get_current_pid_tgid();\n\ttsp = bpf_map_lookup_elem(&start, &pid);\n\tif (!tsp)\n\t\t \n\t\treturn 0;\n\n\tdelta = bpf_ktime_get_ns() - *tsp;\n\tbpf_map_delete_elem(&start, &pid);\n\tdelta = delta / 1000;\n\tif (delta < MINBLOCK_US)\n\t\treturn 0;\n\n\treturn update_counts(ctx, pid, delta);\n}\nchar _license[] SEC(\"license\") = \"GPL\";\nu32 _version SEC(\"version\") = LINUX_VERSION_CODE;\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}