{
  "module_name": "xdp_router_ipv4_user.c",
  "hash_id": "698055e38b6bc699589d2a4d62e200c538649fdd09f9a7e8328147a7b4822c90",
  "original_prompt": "Ingested from linux-6.6.14/samples/bpf/xdp_router_ipv4_user.c",
  "human_readable_source": "\n \n#include <linux/bpf.h>\n#include <linux/netlink.h>\n#include <linux/rtnetlink.h>\n#include <assert.h>\n#include <errno.h>\n#include <signal.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#include <bpf/bpf.h>\n#include <arpa/inet.h>\n#include <fcntl.h>\n#include <poll.h>\n#include <net/if.h>\n#include <netdb.h>\n#include <sys/ioctl.h>\n#include <sys/syscall.h>\n#include \"bpf_util.h\"\n#include <bpf/libbpf.h>\n#include <libgen.h>\n#include <getopt.h>\n#include <pthread.h>\n#include \"xdp_sample_user.h\"\n#include \"xdp_router_ipv4.skel.h\"\n\nstatic const char *__doc__ =\n\"XDP IPv4 router implementation\\n\"\n\"Usage: xdp_router_ipv4 <IFNAME-0> ... <IFNAME-N>\\n\";\n\nstatic char buf[8192];\nstatic int lpm_map_fd;\nstatic int arp_table_map_fd;\nstatic int exact_match_map_fd;\nstatic int tx_port_map_fd;\n\nstatic bool routes_thread_exit;\nstatic int interval = 5;\n\nstatic int mask = SAMPLE_RX_CNT | SAMPLE_REDIRECT_ERR_MAP_CNT |\n\t\t  SAMPLE_DEVMAP_XMIT_CNT_MULTI | SAMPLE_EXCEPTION_CNT;\n\nDEFINE_SAMPLE_INIT(xdp_router_ipv4);\n\nstatic const struct option long_options[] = {\n\t{ \"help\", no_argument, NULL, 'h' },\n\t{ \"skb-mode\", no_argument, NULL, 'S' },\n\t{ \"force\", no_argument, NULL, 'F' },\n\t{ \"interval\", required_argument, NULL, 'i' },\n\t{ \"verbose\", no_argument, NULL, 'v' },\n\t{ \"stats\", no_argument, NULL, 's' },\n\t{}\n};\n\nstatic int get_route_table(int rtm_family);\n\nstatic int recv_msg(struct sockaddr_nl sock_addr, int sock)\n{\n\tstruct nlmsghdr *nh;\n\tint len, nll = 0;\n\tchar *buf_ptr;\n\n\tbuf_ptr = buf;\n\twhile (1) {\n\t\tlen = recv(sock, buf_ptr, sizeof(buf) - nll, 0);\n\t\tif (len < 0)\n\t\t\treturn len;\n\n\t\tnh = (struct nlmsghdr *)buf_ptr;\n\n\t\tif (nh->nlmsg_type == NLMSG_DONE)\n\t\t\tbreak;\n\t\tbuf_ptr += len;\n\t\tnll += len;\n\t\tif ((sock_addr.nl_groups & RTMGRP_NEIGH) == RTMGRP_NEIGH)\n\t\t\tbreak;\n\n\t\tif ((sock_addr.nl_groups & RTMGRP_IPV4_ROUTE) == RTMGRP_IPV4_ROUTE)\n\t\t\tbreak;\n\t}\n\treturn nll;\n}\n\n \nstatic void read_route(struct nlmsghdr *nh, int nll)\n{\n\tchar dsts[24], gws[24], ifs[16], dsts_len[24], metrics[24];\n\tstruct bpf_lpm_trie_key *prefix_key;\n\tstruct rtattr *rt_attr;\n\tstruct rtmsg *rt_msg;\n\tint rtm_family;\n\tint rtl;\n\tint i;\n\tstruct route_table {\n\t\tint  dst_len, iface, metric;\n\t\t__be32 dst, gw;\n\t\t__be64 mac;\n\t} route;\n\tstruct arp_table {\n\t\t__be64 mac;\n\t\t__be32 dst;\n\t};\n\n\tstruct direct_map {\n\t\tstruct arp_table arp;\n\t\tint ifindex;\n\t\t__be64 mac;\n\t} direct_entry;\n\n\tmemset(&route, 0, sizeof(route));\n\tfor (; NLMSG_OK(nh, nll); nh = NLMSG_NEXT(nh, nll)) {\n\t\trt_msg = (struct rtmsg *)NLMSG_DATA(nh);\n\t\trtm_family = rt_msg->rtm_family;\n\t\tif (rtm_family == AF_INET)\n\t\t\tif (rt_msg->rtm_table != RT_TABLE_MAIN)\n\t\t\t\tcontinue;\n\t\trt_attr = (struct rtattr *)RTM_RTA(rt_msg);\n\t\trtl = RTM_PAYLOAD(nh);\n\n\t\tfor (; RTA_OK(rt_attr, rtl); rt_attr = RTA_NEXT(rt_attr, rtl)) {\n\t\t\tswitch (rt_attr->rta_type) {\n\t\t\tcase NDA_DST:\n\t\t\t\tsprintf(dsts, \"%u\",\n\t\t\t\t\t(*((__be32 *)RTA_DATA(rt_attr))));\n\t\t\t\tbreak;\n\t\t\tcase RTA_GATEWAY:\n\t\t\t\tsprintf(gws, \"%u\",\n\t\t\t\t\t*((__be32 *)RTA_DATA(rt_attr)));\n\t\t\t\tbreak;\n\t\t\tcase RTA_OIF:\n\t\t\t\tsprintf(ifs, \"%u\",\n\t\t\t\t\t*((int *)RTA_DATA(rt_attr)));\n\t\t\t\tbreak;\n\t\t\tcase RTA_METRICS:\n\t\t\t\tsprintf(metrics, \"%u\",\n\t\t\t\t\t*((int *)RTA_DATA(rt_attr)));\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tsprintf(dsts_len, \"%d\", rt_msg->rtm_dst_len);\n\t\troute.dst = atoi(dsts);\n\t\troute.dst_len = atoi(dsts_len);\n\t\troute.gw = atoi(gws);\n\t\troute.iface = atoi(ifs);\n\t\troute.metric = atoi(metrics);\n\t\tassert(get_mac_addr(route.iface, &route.mac) == 0);\n\t\tassert(bpf_map_update_elem(tx_port_map_fd,\n\t\t\t\t\t   &route.iface, &route.iface, 0) == 0);\n\t\tif (rtm_family == AF_INET) {\n\t\t\tstruct trie_value {\n\t\t\t\t__u8 prefix[4];\n\t\t\t\t__be64 value;\n\t\t\t\tint ifindex;\n\t\t\t\tint metric;\n\t\t\t\t__be32 gw;\n\t\t\t} *prefix_value;\n\n\t\t\tprefix_key = alloca(sizeof(*prefix_key) + 4);\n\t\t\tprefix_value = alloca(sizeof(*prefix_value));\n\n\t\t\tprefix_key->prefixlen = 32;\n\t\t\tprefix_key->prefixlen = route.dst_len;\n\t\t\tdirect_entry.mac = route.mac & 0xffffffffffff;\n\t\t\tdirect_entry.ifindex = route.iface;\n\t\t\tdirect_entry.arp.mac = 0;\n\t\t\tdirect_entry.arp.dst = 0;\n\t\t\tif (route.dst_len == 32) {\n\t\t\t\tif (nh->nlmsg_type == RTM_DELROUTE) {\n\t\t\t\t\tassert(bpf_map_delete_elem(exact_match_map_fd,\n\t\t\t\t\t\t\t\t   &route.dst) == 0);\n\t\t\t\t} else {\n\t\t\t\t\tif (bpf_map_lookup_elem(arp_table_map_fd,\n\t\t\t\t\t\t\t\t&route.dst,\n\t\t\t\t\t\t\t\t&direct_entry.arp.mac) == 0)\n\t\t\t\t\t\tdirect_entry.arp.dst = route.dst;\n\t\t\t\t\tassert(bpf_map_update_elem(exact_match_map_fd,\n\t\t\t\t\t\t\t\t   &route.dst,\n\t\t\t\t\t\t\t\t   &direct_entry, 0) == 0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (i = 0; i < 4; i++)\n\t\t\t\tprefix_key->data[i] = (route.dst >> i * 8) & 0xff;\n\n\t\t\tif (bpf_map_lookup_elem(lpm_map_fd, prefix_key,\n\t\t\t\t\t\tprefix_value) < 0) {\n\t\t\t\tfor (i = 0; i < 4; i++)\n\t\t\t\t\tprefix_value->prefix[i] = prefix_key->data[i];\n\t\t\t\tprefix_value->value = route.mac & 0xffffffffffff;\n\t\t\t\tprefix_value->ifindex = route.iface;\n\t\t\t\tprefix_value->gw = route.gw;\n\t\t\t\tprefix_value->metric = route.metric;\n\n\t\t\t\tassert(bpf_map_update_elem(lpm_map_fd,\n\t\t\t\t\t\t\t   prefix_key,\n\t\t\t\t\t\t\t   prefix_value, 0\n\t\t\t\t\t\t\t   ) == 0);\n\t\t\t} else {\n\t\t\t\tif (nh->nlmsg_type == RTM_DELROUTE) {\n\t\t\t\t\tassert(bpf_map_delete_elem(lpm_map_fd,\n\t\t\t\t\t\t\t\t   prefix_key\n\t\t\t\t\t\t\t\t   ) == 0);\n\t\t\t\t\t \n\t\t\t\t\tget_route_table(AF_INET);\n\t\t\t\t} else if (prefix_key->data[0] ==\n\t\t\t\t\t   prefix_value->prefix[0] &&\n\t\t\t\t\t   prefix_key->data[1] ==\n\t\t\t\t\t   prefix_value->prefix[1] &&\n\t\t\t\t\t   prefix_key->data[2] ==\n\t\t\t\t\t   prefix_value->prefix[2] &&\n\t\t\t\t\t   prefix_key->data[3] ==\n\t\t\t\t\t   prefix_value->prefix[3] &&\n\t\t\t\t\t   route.metric >= prefix_value->metric) {\n\t\t\t\t\tcontinue;\n\t\t\t\t} else {\n\t\t\t\t\tfor (i = 0; i < 4; i++)\n\t\t\t\t\t\tprefix_value->prefix[i] =\n\t\t\t\t\t\t\tprefix_key->data[i];\n\t\t\t\t\tprefix_value->value =\n\t\t\t\t\t\troute.mac & 0xffffffffffff;\n\t\t\t\t\tprefix_value->ifindex = route.iface;\n\t\t\t\t\tprefix_value->gw = route.gw;\n\t\t\t\t\tprefix_value->metric = route.metric;\n\t\t\t\t\tassert(bpf_map_update_elem(lpm_map_fd,\n\t\t\t\t\t\t\t\t   prefix_key,\n\t\t\t\t\t\t\t\t   prefix_value,\n\t\t\t\t\t\t\t\t   0) == 0);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmemset(&route, 0, sizeof(route));\n\t\tmemset(dsts, 0, sizeof(dsts));\n\t\tmemset(dsts_len, 0, sizeof(dsts_len));\n\t\tmemset(gws, 0, sizeof(gws));\n\t\tmemset(ifs, 0, sizeof(ifs));\n\t\tmemset(&route, 0, sizeof(route));\n\t}\n}\n\n \nstatic int get_route_table(int rtm_family)\n{\n\tstruct sockaddr_nl sa;\n\tstruct nlmsghdr *nh;\n\tint sock, seq = 0;\n\tstruct msghdr msg;\n\tstruct iovec iov;\n\tint ret = 0;\n\tint nll;\n\n\tstruct {\n\t\tstruct nlmsghdr nl;\n\t\tstruct rtmsg rt;\n\t\tchar buf[8192];\n\t} req;\n\n\tsock = socket(AF_NETLINK, SOCK_RAW, NETLINK_ROUTE);\n\tif (sock < 0) {\n\t\tfprintf(stderr, \"open netlink socket: %s\\n\", strerror(errno));\n\t\treturn -errno;\n\t}\n\tmemset(&sa, 0, sizeof(sa));\n\tsa.nl_family = AF_NETLINK;\n\tif (bind(sock, (struct sockaddr *)&sa, sizeof(sa)) < 0) {\n\t\tfprintf(stderr, \"bind netlink socket: %s\\n\", strerror(errno));\n\t\tret = -errno;\n\t\tgoto cleanup;\n\t}\n\tmemset(&req, 0, sizeof(req));\n\treq.nl.nlmsg_len = NLMSG_LENGTH(sizeof(struct rtmsg));\n\treq.nl.nlmsg_flags = NLM_F_REQUEST | NLM_F_DUMP;\n\treq.nl.nlmsg_type = RTM_GETROUTE;\n\n\treq.rt.rtm_family = rtm_family;\n\treq.rt.rtm_table = RT_TABLE_MAIN;\n\treq.nl.nlmsg_pid = 0;\n\treq.nl.nlmsg_seq = ++seq;\n\tmemset(&msg, 0, sizeof(msg));\n\tiov.iov_base = (void *)&req.nl;\n\tiov.iov_len = req.nl.nlmsg_len;\n\tmsg.msg_iov = &iov;\n\tmsg.msg_iovlen = 1;\n\tret = sendmsg(sock, &msg, 0);\n\tif (ret < 0) {\n\t\tfprintf(stderr, \"send to netlink: %s\\n\", strerror(errno));\n\t\tret = -errno;\n\t\tgoto cleanup;\n\t}\n\tmemset(buf, 0, sizeof(buf));\n\tnll = recv_msg(sa, sock);\n\tif (nll < 0) {\n\t\tfprintf(stderr, \"recv from netlink: %s\\n\", strerror(nll));\n\t\tret = nll;\n\t\tgoto cleanup;\n\t}\n\tnh = (struct nlmsghdr *)buf;\n\tread_route(nh, nll);\ncleanup:\n\tclose(sock);\n\treturn ret;\n}\n\n \nstatic void read_arp(struct nlmsghdr *nh, int nll)\n{\n\tstruct rtattr *rt_attr;\n\tchar dsts[24], mac[24];\n\tstruct ndmsg *rt_msg;\n\tint rtl, ndm_family;\n\n\tstruct arp_table {\n\t\t__be64 mac;\n\t\t__be32 dst;\n\t} arp_entry;\n\tstruct direct_map {\n\t\tstruct arp_table arp;\n\t\tint ifindex;\n\t\t__be64 mac;\n\t} direct_entry;\n\n\tfor (; NLMSG_OK(nh, nll); nh = NLMSG_NEXT(nh, nll)) {\n\t\trt_msg = (struct ndmsg *)NLMSG_DATA(nh);\n\t\trt_attr = (struct rtattr *)RTM_RTA(rt_msg);\n\t\tndm_family = rt_msg->ndm_family;\n\t\trtl = RTM_PAYLOAD(nh);\n\t\tfor (; RTA_OK(rt_attr, rtl); rt_attr = RTA_NEXT(rt_attr, rtl)) {\n\t\t\tswitch (rt_attr->rta_type) {\n\t\t\tcase NDA_DST:\n\t\t\t\tsprintf(dsts, \"%u\",\n\t\t\t\t\t*((__be32 *)RTA_DATA(rt_attr)));\n\t\t\t\tbreak;\n\t\t\tcase NDA_LLADDR:\n\t\t\t\tsprintf(mac, \"%lld\",\n\t\t\t\t\t*((__be64 *)RTA_DATA(rt_attr)));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tarp_entry.dst = atoi(dsts);\n\t\tarp_entry.mac = atol(mac);\n\n\t\tif (ndm_family == AF_INET) {\n\t\t\tif (bpf_map_lookup_elem(exact_match_map_fd,\n\t\t\t\t\t\t&arp_entry.dst,\n\t\t\t\t\t\t&direct_entry) == 0) {\n\t\t\t\tif (nh->nlmsg_type == RTM_DELNEIGH) {\n\t\t\t\t\tdirect_entry.arp.dst = 0;\n\t\t\t\t\tdirect_entry.arp.mac = 0;\n\t\t\t\t} else if (nh->nlmsg_type == RTM_NEWNEIGH) {\n\t\t\t\t\tdirect_entry.arp.dst = arp_entry.dst;\n\t\t\t\t\tdirect_entry.arp.mac = arp_entry.mac;\n\t\t\t\t}\n\t\t\t\tassert(bpf_map_update_elem(exact_match_map_fd,\n\t\t\t\t\t\t\t   &arp_entry.dst,\n\t\t\t\t\t\t\t   &direct_entry, 0\n\t\t\t\t\t\t\t   ) == 0);\n\t\t\t\tmemset(&direct_entry, 0, sizeof(direct_entry));\n\t\t\t}\n\t\t\tif (nh->nlmsg_type == RTM_DELNEIGH) {\n\t\t\t\tassert(bpf_map_delete_elem(arp_table_map_fd,\n\t\t\t\t\t\t\t   &arp_entry.dst) == 0);\n\t\t\t} else if (nh->nlmsg_type == RTM_NEWNEIGH) {\n\t\t\t\tassert(bpf_map_update_elem(arp_table_map_fd,\n\t\t\t\t\t\t\t   &arp_entry.dst,\n\t\t\t\t\t\t\t   &arp_entry.mac, 0\n\t\t\t\t\t\t\t   ) == 0);\n\t\t\t}\n\t\t}\n\t\tmemset(&arp_entry, 0, sizeof(arp_entry));\n\t\tmemset(dsts, 0, sizeof(dsts));\n\t}\n}\n\n \nstatic int get_arp_table(int rtm_family)\n{\n\tstruct sockaddr_nl sa;\n\tstruct nlmsghdr *nh;\n\tint sock, seq = 0;\n\tstruct msghdr msg;\n\tstruct iovec iov;\n\tint ret = 0;\n\tint nll;\n\tstruct {\n\t\tstruct nlmsghdr nl;\n\t\tstruct ndmsg rt;\n\t\tchar buf[8192];\n\t} req;\n\n\tsock = socket(AF_NETLINK, SOCK_RAW, NETLINK_ROUTE);\n\tif (sock < 0) {\n\t\tfprintf(stderr, \"open netlink socket: %s\\n\", strerror(errno));\n\t\treturn -errno;\n\t}\n\tmemset(&sa, 0, sizeof(sa));\n\tsa.nl_family = AF_NETLINK;\n\tif (bind(sock, (struct sockaddr *)&sa, sizeof(sa)) < 0) {\n\t\tfprintf(stderr, \"bind netlink socket: %s\\n\", strerror(errno));\n\t\tret = -errno;\n\t\tgoto cleanup;\n\t}\n\tmemset(&req, 0, sizeof(req));\n\treq.nl.nlmsg_len = NLMSG_LENGTH(sizeof(struct rtmsg));\n\treq.nl.nlmsg_flags = NLM_F_REQUEST | NLM_F_DUMP;\n\treq.nl.nlmsg_type = RTM_GETNEIGH;\n\treq.rt.ndm_state = NUD_REACHABLE;\n\treq.rt.ndm_family = rtm_family;\n\treq.nl.nlmsg_pid = 0;\n\treq.nl.nlmsg_seq = ++seq;\n\tmemset(&msg, 0, sizeof(msg));\n\tiov.iov_base = (void *)&req.nl;\n\tiov.iov_len = req.nl.nlmsg_len;\n\tmsg.msg_iov = &iov;\n\tmsg.msg_iovlen = 1;\n\tret = sendmsg(sock, &msg, 0);\n\tif (ret < 0) {\n\t\tfprintf(stderr, \"send to netlink: %s\\n\", strerror(errno));\n\t\tret = -errno;\n\t\tgoto cleanup;\n\t}\n\tmemset(buf, 0, sizeof(buf));\n\tnll = recv_msg(sa, sock);\n\tif (nll < 0) {\n\t\tfprintf(stderr, \"recv from netlink: %s\\n\", strerror(nll));\n\t\tret = nll;\n\t\tgoto cleanup;\n\t}\n\tnh = (struct nlmsghdr *)buf;\n\tread_arp(nh, nll);\ncleanup:\n\tclose(sock);\n\treturn ret;\n}\n\n \nstatic void *monitor_routes_thread(void *arg)\n{\n\tstruct pollfd fds_route, fds_arp;\n\tstruct sockaddr_nl la, lr;\n\tint sock, sock_arp, nll;\n\tstruct nlmsghdr *nh;\n\n\tsock = socket(AF_NETLINK, SOCK_RAW, NETLINK_ROUTE);\n\tif (sock < 0) {\n\t\tfprintf(stderr, \"open netlink socket: %s\\n\", strerror(errno));\n\t\treturn NULL;\n\t}\n\n\tfcntl(sock, F_SETFL, O_NONBLOCK);\n\tmemset(&lr, 0, sizeof(lr));\n\tlr.nl_family = AF_NETLINK;\n\tlr.nl_groups = RTMGRP_IPV6_ROUTE | RTMGRP_IPV4_ROUTE | RTMGRP_NOTIFY;\n\tif (bind(sock, (struct sockaddr *)&lr, sizeof(lr)) < 0) {\n\t\tfprintf(stderr, \"bind netlink socket: %s\\n\", strerror(errno));\n\t\tclose(sock);\n\t\treturn NULL;\n\t}\n\n\tfds_route.fd = sock;\n\tfds_route.events = POLL_IN;\n\n\tsock_arp = socket(AF_NETLINK, SOCK_RAW, NETLINK_ROUTE);\n\tif (sock_arp < 0) {\n\t\tfprintf(stderr, \"open netlink socket: %s\\n\", strerror(errno));\n\t\tclose(sock);\n\t\treturn NULL;\n\t}\n\n\tfcntl(sock_arp, F_SETFL, O_NONBLOCK);\n\tmemset(&la, 0, sizeof(la));\n\tla.nl_family = AF_NETLINK;\n\tla.nl_groups = RTMGRP_NEIGH | RTMGRP_NOTIFY;\n\tif (bind(sock_arp, (struct sockaddr *)&la, sizeof(la)) < 0) {\n\t\tfprintf(stderr, \"bind netlink socket: %s\\n\", strerror(errno));\n\t\tgoto cleanup;\n\t}\n\n\tfds_arp.fd = sock_arp;\n\tfds_arp.events = POLL_IN;\n\n\t \n\tif (get_arp_table(AF_INET) < 0) {\n\t\tfprintf(stderr, \"Failed reading arp table\\n\");\n\t\tgoto cleanup;\n\t}\n\n\tif (get_route_table(AF_INET) < 0) {\n\t\tfprintf(stderr, \"Failed reading route table\\n\");\n\t\tgoto cleanup;\n\t}\n\n\twhile (!routes_thread_exit) {\n\t\tmemset(buf, 0, sizeof(buf));\n\t\tif (poll(&fds_route, 1, 3) == POLL_IN) {\n\t\t\tnll = recv_msg(lr, sock);\n\t\t\tif (nll < 0) {\n\t\t\t\tfprintf(stderr, \"recv from netlink: %s\\n\",\n\t\t\t\t\tstrerror(nll));\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\n\t\t\tnh = (struct nlmsghdr *)buf;\n\t\t\tread_route(nh, nll);\n\t\t}\n\n\t\tmemset(buf, 0, sizeof(buf));\n\t\tif (poll(&fds_arp, 1, 3) == POLL_IN) {\n\t\t\tnll = recv_msg(la, sock_arp);\n\t\t\tif (nll < 0) {\n\t\t\t\tfprintf(stderr, \"recv from netlink: %s\\n\",\n\t\t\t\t\tstrerror(nll));\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\n\t\t\tnh = (struct nlmsghdr *)buf;\n\t\t\tread_arp(nh, nll);\n\t\t}\n\n\t\tsleep(interval);\n\t}\n\ncleanup:\n\tclose(sock_arp);\n\tclose(sock);\n\treturn NULL;\n}\n\nstatic void usage(char *argv[], const struct option *long_options,\n\t\t  const char *doc, int mask, bool error,\n\t\t  struct bpf_object *obj)\n{\n\tsample_usage(argv, long_options, doc, mask, error);\n}\n\nint main(int argc, char **argv)\n{\n\tbool error = true, generic = false, force = false;\n\tint opt, ret = EXIT_FAIL_BPF;\n\tstruct xdp_router_ipv4 *skel;\n\tint i, total_ifindex = argc - 1;\n\tchar **ifname_list = argv + 1;\n\tpthread_t routes_thread;\n\tint longindex = 0;\n\n\tif (libbpf_set_strict_mode(LIBBPF_STRICT_ALL) < 0) {\n\t\tfprintf(stderr, \"Failed to set libbpf strict mode: %s\\n\",\n\t\t\tstrerror(errno));\n\t\tgoto end;\n\t}\n\n\tskel = xdp_router_ipv4__open();\n\tif (!skel) {\n\t\tfprintf(stderr, \"Failed to xdp_router_ipv4__open: %s\\n\",\n\t\t\tstrerror(errno));\n\t\tgoto end;\n\t}\n\n\tret = sample_init_pre_load(skel);\n\tif (ret < 0) {\n\t\tfprintf(stderr, \"Failed to sample_init_pre_load: %s\\n\",\n\t\t\tstrerror(-ret));\n\t\tret = EXIT_FAIL_BPF;\n\t\tgoto end_destroy;\n\t}\n\n\tret = xdp_router_ipv4__load(skel);\n\tif (ret < 0) {\n\t\tfprintf(stderr, \"Failed to xdp_router_ipv4__load: %s\\n\",\n\t\t\tstrerror(errno));\n\t\tgoto end_destroy;\n\t}\n\n\tret = sample_init(skel, mask);\n\tif (ret < 0) {\n\t\tfprintf(stderr, \"Failed to initialize sample: %s\\n\", strerror(-ret));\n\t\tret = EXIT_FAIL;\n\t\tgoto end_destroy;\n\t}\n\n\twhile ((opt = getopt_long(argc, argv, \"si:SFvh\",\n\t\t\t\t  long_options, &longindex)) != -1) {\n\t\tswitch (opt) {\n\t\tcase 's':\n\t\t\tmask |= SAMPLE_REDIRECT_MAP_CNT;\n\t\t\ttotal_ifindex--;\n\t\t\tifname_list++;\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\tinterval = strtoul(optarg, NULL, 0);\n\t\t\ttotal_ifindex -= 2;\n\t\t\tifname_list += 2;\n\t\t\tbreak;\n\t\tcase 'S':\n\t\t\tgeneric = true;\n\t\t\ttotal_ifindex--;\n\t\t\tifname_list++;\n\t\t\tbreak;\n\t\tcase 'F':\n\t\t\tforce = true;\n\t\t\ttotal_ifindex--;\n\t\t\tifname_list++;\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\tsample_switch_mode();\n\t\t\ttotal_ifindex--;\n\t\t\tifname_list++;\n\t\t\tbreak;\n\t\tcase 'h':\n\t\t\terror = false;\n\t\tdefault:\n\t\t\tusage(argv, long_options, __doc__, mask, error, skel->obj);\n\t\t\tgoto end_destroy;\n\t\t}\n\t}\n\n\tret = EXIT_FAIL_OPTION;\n\tif (optind == argc) {\n\t\tusage(argv, long_options, __doc__, mask, true, skel->obj);\n\t\tgoto end_destroy;\n\t}\n\n\tlpm_map_fd = bpf_map__fd(skel->maps.lpm_map);\n\tif (lpm_map_fd < 0) {\n\t\tfprintf(stderr, \"Failed loading lpm_map %s\\n\",\n\t\t\tstrerror(-lpm_map_fd));\n\t\tgoto end_destroy;\n\t}\n\tarp_table_map_fd = bpf_map__fd(skel->maps.arp_table);\n\tif (arp_table_map_fd < 0) {\n\t\tfprintf(stderr, \"Failed loading arp_table_map_fd %s\\n\",\n\t\t\tstrerror(-arp_table_map_fd));\n\t\tgoto end_destroy;\n\t}\n\texact_match_map_fd = bpf_map__fd(skel->maps.exact_match);\n\tif (exact_match_map_fd < 0) {\n\t\tfprintf(stderr, \"Failed loading exact_match_map_fd %s\\n\",\n\t\t\tstrerror(-exact_match_map_fd));\n\t\tgoto end_destroy;\n\t}\n\ttx_port_map_fd = bpf_map__fd(skel->maps.tx_port);\n\tif (tx_port_map_fd < 0) {\n\t\tfprintf(stderr, \"Failed loading tx_port_map_fd %s\\n\",\n\t\t\tstrerror(-tx_port_map_fd));\n\t\tgoto end_destroy;\n\t}\n\n\tret = EXIT_FAIL_XDP;\n\tfor (i = 0; i < total_ifindex; i++) {\n\t\tint index = if_nametoindex(ifname_list[i]);\n\n\t\tif (!index) {\n\t\t\tfprintf(stderr, \"Interface %s not found %s\\n\",\n\t\t\t\tifname_list[i], strerror(-tx_port_map_fd));\n\t\t\tgoto end_destroy;\n\t\t}\n\t\tif (sample_install_xdp(skel->progs.xdp_router_ipv4_prog,\n\t\t\t\t       index, generic, force) < 0)\n\t\t\tgoto end_destroy;\n\t}\n\n\tret = pthread_create(&routes_thread, NULL, monitor_routes_thread, NULL);\n\tif (ret) {\n\t\tfprintf(stderr, \"Failed creating routes_thread: %s\\n\", strerror(-ret));\n\t\tret = EXIT_FAIL;\n\t\tgoto end_destroy;\n\t}\n\n\tret = sample_run(interval, NULL, NULL);\n\troutes_thread_exit = true;\n\n\tif (ret < 0) {\n\t\tfprintf(stderr, \"Failed during sample run: %s\\n\", strerror(-ret));\n\t\tret = EXIT_FAIL;\n\t\tgoto end_thread_wait;\n\t}\n\tret = EXIT_OK;\n\nend_thread_wait:\n\tpthread_join(routes_thread, NULL);\nend_destroy:\n\txdp_router_ipv4__destroy(skel);\nend:\n\tsample_exit(ret);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}