{
  "module_name": "parse_varlen.c",
  "hash_id": "bef0af0bfb6696f8631736b6c7b787e522a59759b836111ec3c569b84887ff75",
  "original_prompt": "Ingested from linux-6.6.14/samples/bpf/parse_varlen.c",
  "human_readable_source": " \n#define KBUILD_MODNAME \"foo\"\n#include <linux/if_ether.h>\n#include <linux/if_vlan.h>\n#include <linux/ip.h>\n#include <linux/ipv6.h>\n#include <linux/in.h>\n#include <linux/tcp.h>\n#include <linux/udp.h>\n#include <uapi/linux/bpf.h>\n#include <net/ip.h>\n#include <bpf/bpf_helpers.h>\n\n#define DEFAULT_PKTGEN_UDP_PORT 9\n#define DEBUG 0\n\nstatic int tcp(void *data, uint64_t tp_off, void *data_end)\n{\n\tstruct tcphdr *tcp = data + tp_off;\n\n\tif (tcp + 1 > data_end)\n\t\treturn 0;\n\tif (tcp->dest == htons(80) || tcp->source == htons(80))\n\t\treturn TC_ACT_SHOT;\n\treturn 0;\n}\n\nstatic int udp(void *data, uint64_t tp_off, void *data_end)\n{\n\tstruct udphdr *udp = data + tp_off;\n\n\tif (udp + 1 > data_end)\n\t\treturn 0;\n\tif (udp->dest == htons(DEFAULT_PKTGEN_UDP_PORT) ||\n\t    udp->source == htons(DEFAULT_PKTGEN_UDP_PORT)) {\n\t\tif (DEBUG) {\n\t\t\tchar fmt[] = \"udp port 9 indeed\\n\";\n\n\t\t\tbpf_trace_printk(fmt, sizeof(fmt));\n\t\t}\n\t\treturn TC_ACT_SHOT;\n\t}\n\treturn 0;\n}\n\nstatic int parse_ipv4(void *data, uint64_t nh_off, void *data_end)\n{\n\tstruct iphdr *iph;\n\tuint64_t ihl_len;\n\n\tiph = data + nh_off;\n\tif (iph + 1 > data_end)\n\t\treturn 0;\n\n\tif (ip_is_fragment(iph))\n\t\treturn 0;\n\tihl_len = iph->ihl * 4;\n\n\tif (iph->protocol == IPPROTO_IPIP) {\n\t\tiph = data + nh_off + ihl_len;\n\t\tif (iph + 1 > data_end)\n\t\t\treturn 0;\n\t\tihl_len += iph->ihl * 4;\n\t}\n\n\tif (iph->protocol == IPPROTO_TCP)\n\t\treturn tcp(data, nh_off + ihl_len, data_end);\n\telse if (iph->protocol == IPPROTO_UDP)\n\t\treturn udp(data, nh_off + ihl_len, data_end);\n\treturn 0;\n}\n\nstatic int parse_ipv6(void *data, uint64_t nh_off, void *data_end)\n{\n\tstruct ipv6hdr *ip6h;\n\tstruct iphdr *iph;\n\tuint64_t ihl_len = sizeof(struct ipv6hdr);\n\tuint64_t nexthdr;\n\n\tip6h = data + nh_off;\n\tif (ip6h + 1 > data_end)\n\t\treturn 0;\n\n\tnexthdr = ip6h->nexthdr;\n\n\tif (nexthdr == IPPROTO_IPIP) {\n\t\tiph = data + nh_off + ihl_len;\n\t\tif (iph + 1 > data_end)\n\t\t\treturn 0;\n\t\tihl_len += iph->ihl * 4;\n\t\tnexthdr = iph->protocol;\n\t} else if (nexthdr == IPPROTO_IPV6) {\n\t\tip6h = data + nh_off + ihl_len;\n\t\tif (ip6h + 1 > data_end)\n\t\t\treturn 0;\n\t\tihl_len += sizeof(struct ipv6hdr);\n\t\tnexthdr = ip6h->nexthdr;\n\t}\n\n\tif (nexthdr == IPPROTO_TCP)\n\t\treturn tcp(data, nh_off + ihl_len, data_end);\n\telse if (nexthdr == IPPROTO_UDP)\n\t\treturn udp(data, nh_off + ihl_len, data_end);\n\treturn 0;\n}\n\nSEC(\"varlen\")\nint handle_ingress(struct __sk_buff *skb)\n{\n\tvoid *data = (void *)(long)skb->data;\n\tstruct ethhdr *eth = data;\n\tvoid *data_end = (void *)(long)skb->data_end;\n\tuint64_t h_proto, nh_off;\n\n\tnh_off = sizeof(*eth);\n\tif (data + nh_off > data_end)\n\t\treturn 0;\n\n\th_proto = eth->h_proto;\n\n\tif (h_proto == ETH_P_8021Q || h_proto == ETH_P_8021AD) {\n\t\tstruct vlan_hdr *vhdr;\n\n\t\tvhdr = data + nh_off;\n\t\tnh_off += sizeof(struct vlan_hdr);\n\t\tif (data + nh_off > data_end)\n\t\t\treturn 0;\n\t\th_proto = vhdr->h_vlan_encapsulated_proto;\n\t}\n\tif (h_proto == ETH_P_8021Q || h_proto == ETH_P_8021AD) {\n\t\tstruct vlan_hdr *vhdr;\n\n\t\tvhdr = data + nh_off;\n\t\tnh_off += sizeof(struct vlan_hdr);\n\t\tif (data + nh_off > data_end)\n\t\t\treturn 0;\n\t\th_proto = vhdr->h_vlan_encapsulated_proto;\n\t}\n\tif (h_proto == htons(ETH_P_IP))\n\t\treturn parse_ipv4(data, nh_off, data_end);\n\telse if (h_proto == htons(ETH_P_IPV6))\n\t\treturn parse_ipv6(data, nh_off, data_end);\n\treturn 0;\n}\nchar _license[] SEC(\"license\") = \"GPL\";\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}