{
  "module_name": "tracex2.bpf.c",
  "hash_id": "54fc2a66657ac00f764c40c6f9e1ec4f5cf6b3e141f79d670d7dd8a6ddb16e8a",
  "original_prompt": "Ingested from linux-6.6.14/samples/bpf/tracex2.bpf.c",
  "human_readable_source": " \n#include \"vmlinux.h\"\n#include <linux/version.h>\n#include <bpf/bpf_helpers.h>\n#include <bpf/bpf_tracing.h>\n#include <bpf/bpf_core_read.h>\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_HASH);\n\t__type(key, long);\n\t__type(value, long);\n\t__uint(max_entries, 1024);\n} my_map SEC(\".maps\");\n\n \nSEC(\"kprobe/kfree_skb_reason\")\nint bpf_prog2(struct pt_regs *ctx)\n{\n\tlong loc = 0;\n\tlong init_val = 1;\n\tlong *value;\n\n\t \n\tBPF_KPROBE_READ_RET_IP(loc, ctx);\n\n\tvalue = bpf_map_lookup_elem(&my_map, &loc);\n\tif (value)\n\t\t*value += 1;\n\telse\n\t\tbpf_map_update_elem(&my_map, &loc, &init_val, BPF_ANY);\n\treturn 0;\n}\n\nstatic unsigned int log2(unsigned int v)\n{\n\tunsigned int r;\n\tunsigned int shift;\n\n\tr = (v > 0xFFFF) << 4; v >>= r;\n\tshift = (v > 0xFF) << 3; v >>= shift; r |= shift;\n\tshift = (v > 0xF) << 2; v >>= shift; r |= shift;\n\tshift = (v > 0x3) << 1; v >>= shift; r |= shift;\n\tr |= (v >> 1);\n\treturn r;\n}\n\nstatic unsigned int log2l(unsigned long v)\n{\n\tunsigned int hi = v >> 32;\n\tif (hi)\n\t\treturn log2(hi) + 32;\n\telse\n\t\treturn log2(v);\n}\n\nstruct hist_key {\n\tchar comm[16];\n\tu64 pid_tgid;\n\tu64 uid_gid;\n\tu64 index;\n};\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_PERCPU_HASH);\n\t__uint(key_size, sizeof(struct hist_key));\n\t__uint(value_size, sizeof(long));\n\t__uint(max_entries, 1024);\n} my_hist_map SEC(\".maps\");\n\nSEC(\"ksyscall/write\")\nint BPF_KSYSCALL(bpf_prog3, unsigned int fd, const char *buf, size_t count)\n{\n\tlong init_val = 1;\n\tlong *value;\n\tstruct hist_key key;\n\n\tkey.index = log2l(count);\n\tkey.pid_tgid = bpf_get_current_pid_tgid();\n\tkey.uid_gid = bpf_get_current_uid_gid();\n\tbpf_get_current_comm(&key.comm, sizeof(key.comm));\n\n\tvalue = bpf_map_lookup_elem(&my_hist_map, &key);\n\tif (value)\n\t\t__sync_fetch_and_add(value, 1);\n\telse\n\t\tbpf_map_update_elem(&my_hist_map, &key, &init_val, BPF_ANY);\n\treturn 0;\n}\nchar _license[] SEC(\"license\") = \"GPL\";\nu32 _version SEC(\"version\") = LINUX_VERSION_CODE;\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}