{
  "module_name": "trace_event_user.c",
  "hash_id": "ca654886d10ec56ab63c484707c3fe03bdd492283b98fe0d226d1c3e3956bb88",
  "original_prompt": "Ingested from linux-6.6.14/samples/bpf/trace_event_user.c",
  "human_readable_source": "\n \n#include <stdio.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <string.h>\n#include <linux/perf_event.h>\n#include <linux/bpf.h>\n#include <signal.h>\n#include <errno.h>\n#include <sys/resource.h>\n#include <bpf/bpf.h>\n#include <bpf/libbpf.h>\n#include \"perf-sys.h\"\n#include \"trace_helpers.h\"\n\n#define SAMPLE_FREQ 50\n\nstatic int pid;\n \nstatic int map_fd[2];\nstruct bpf_program *prog;\nstatic bool sys_read_seen, sys_write_seen;\n\nstatic void print_ksym(__u64 addr)\n{\n\tstruct ksym *sym;\n\n\tif (!addr)\n\t\treturn;\n\tsym = ksym_search(addr);\n\tif (!sym) {\n\t\tprintf(\"ksym not found. Is kallsyms loaded?\\n\");\n\t\treturn;\n\t}\n\n\tprintf(\"%s;\", sym->name);\n\tif (!strstr(sym->name, \"sys_read\"))\n\t\tsys_read_seen = true;\n\telse if (!strstr(sym->name, \"sys_write\"))\n\t\tsys_write_seen = true;\n}\n\nstatic void print_addr(__u64 addr)\n{\n\tif (!addr)\n\t\treturn;\n\tprintf(\"%llx;\", addr);\n}\n\n#define TASK_COMM_LEN 16\n\nstruct key_t {\n\tchar comm[TASK_COMM_LEN];\n\t__u32 kernstack;\n\t__u32 userstack;\n};\n\nstatic void print_stack(struct key_t *key, __u64 count)\n{\n\t__u64 ip[PERF_MAX_STACK_DEPTH] = {};\n\tstatic bool warned;\n\tint i;\n\n\tprintf(\"%3lld %s;\", count, key->comm);\n\tif (bpf_map_lookup_elem(map_fd[1], &key->kernstack, ip) != 0) {\n\t\tprintf(\"---;\");\n\t} else {\n\t\tfor (i = PERF_MAX_STACK_DEPTH - 1; i >= 0; i--)\n\t\t\tprint_ksym(ip[i]);\n\t}\n\tprintf(\"-;\");\n\tif (bpf_map_lookup_elem(map_fd[1], &key->userstack, ip) != 0) {\n\t\tprintf(\"---;\");\n\t} else {\n\t\tfor (i = PERF_MAX_STACK_DEPTH - 1; i >= 0; i--)\n\t\t\tprint_addr(ip[i]);\n\t}\n\tif (count < 6)\n\t\tprintf(\"\\r\");\n\telse\n\t\tprintf(\"\\n\");\n\n\tif (key->kernstack == -EEXIST && !warned) {\n\t\tprintf(\"stackmap collisions seen. Consider increasing size\\n\");\n\t\twarned = true;\n\t} else if ((int)key->kernstack < 0 && (int)key->userstack < 0) {\n\t\tprintf(\"err stackid %d %d\\n\", key->kernstack, key->userstack);\n\t}\n}\n\nstatic void err_exit(int err)\n{\n\tkill(pid, SIGKILL);\n\texit(err);\n}\n\nstatic void print_stacks(void)\n{\n\tstruct key_t key = {}, next_key;\n\t__u64 value;\n\t__u32 stackid = 0, next_id;\n\tint error = 1, fd = map_fd[0], stack_map = map_fd[1];\n\n\tsys_read_seen = sys_write_seen = false;\n\twhile (bpf_map_get_next_key(fd, &key, &next_key) == 0) {\n\t\tbpf_map_lookup_elem(fd, &next_key, &value);\n\t\tprint_stack(&next_key, value);\n\t\tbpf_map_delete_elem(fd, &next_key);\n\t\tkey = next_key;\n\t}\n\tprintf(\"\\n\");\n\tif (!sys_read_seen || !sys_write_seen) {\n\t\tprintf(\"BUG kernel stack doesn't contain sys_read() and sys_write()\\n\");\n\t\terr_exit(error);\n\t}\n\n\t \n\twhile (bpf_map_get_next_key(stack_map, &stackid, &next_id) == 0) {\n\t\tbpf_map_delete_elem(stack_map, &next_id);\n\t\tstackid = next_id;\n\t}\n}\n\nstatic inline int generate_load(void)\n{\n\tif (system(\"dd if=/dev/zero of=/dev/null count=5000k status=none\") < 0) {\n\t\tprintf(\"failed to generate some load with dd: %s\\n\", strerror(errno));\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic void test_perf_event_all_cpu(struct perf_event_attr *attr)\n{\n\tint nr_cpus = sysconf(_SC_NPROCESSORS_ONLN);\n\tstruct bpf_link **links = calloc(nr_cpus, sizeof(struct bpf_link *));\n\tint i, pmu_fd, error = 1;\n\n\tif (!links) {\n\t\tprintf(\"malloc of links failed\\n\");\n\t\tgoto err;\n\t}\n\n\t \n\tattr->inherit = 0;\n\n\t \n\tfor (i = 0; i < nr_cpus; i++) {\n\t\tpmu_fd = sys_perf_event_open(attr, -1, i, -1, 0);\n\t\tif (pmu_fd < 0) {\n\t\t\tprintf(\"sys_perf_event_open failed\\n\");\n\t\t\tgoto all_cpu_err;\n\t\t}\n\t\tlinks[i] = bpf_program__attach_perf_event(prog, pmu_fd);\n\t\tif (libbpf_get_error(links[i])) {\n\t\t\tprintf(\"bpf_program__attach_perf_event failed\\n\");\n\t\t\tlinks[i] = NULL;\n\t\t\tclose(pmu_fd);\n\t\t\tgoto all_cpu_err;\n\t\t}\n\t}\n\n\tif (generate_load() < 0)\n\t\tgoto all_cpu_err;\n\n\tprint_stacks();\n\terror = 0;\nall_cpu_err:\n\tfor (i--; i >= 0; i--)\n\t\tbpf_link__destroy(links[i]);\nerr:\n\tfree(links);\n\tif (error)\n\t\terr_exit(error);\n}\n\nstatic void test_perf_event_task(struct perf_event_attr *attr)\n{\n\tstruct bpf_link *link = NULL;\n\tint pmu_fd, error = 1;\n\n\t \n\tattr->inherit = 1;\n\n\t \n\tpmu_fd = sys_perf_event_open(attr, 0, -1, -1, 0);\n\tif (pmu_fd < 0) {\n\t\tprintf(\"sys_perf_event_open failed\\n\");\n\t\tgoto err;\n\t}\n\tlink = bpf_program__attach_perf_event(prog, pmu_fd);\n\tif (libbpf_get_error(link)) {\n\t\tprintf(\"bpf_program__attach_perf_event failed\\n\");\n\t\tlink = NULL;\n\t\tclose(pmu_fd);\n\t\tgoto err;\n\t}\n\n\tif (generate_load() < 0)\n\t\tgoto err;\n\n\tprint_stacks();\n\terror = 0;\nerr:\n\tbpf_link__destroy(link);\n\tif (error)\n\t\terr_exit(error);\n}\n\nstatic void test_bpf_perf_event(void)\n{\n\tstruct perf_event_attr attr_type_hw = {\n\t\t.sample_freq = SAMPLE_FREQ,\n\t\t.freq = 1,\n\t\t.type = PERF_TYPE_HARDWARE,\n\t\t.config = PERF_COUNT_HW_CPU_CYCLES,\n\t};\n\tstruct perf_event_attr attr_type_sw = {\n\t\t.sample_freq = SAMPLE_FREQ,\n\t\t.freq = 1,\n\t\t.type = PERF_TYPE_SOFTWARE,\n\t\t.config = PERF_COUNT_SW_CPU_CLOCK,\n\t};\n\tstruct perf_event_attr attr_hw_cache_l1d = {\n\t\t.sample_freq = SAMPLE_FREQ,\n\t\t.freq = 1,\n\t\t.type = PERF_TYPE_HW_CACHE,\n\t\t.config =\n\t\t\tPERF_COUNT_HW_CACHE_L1D |\n\t\t\t(PERF_COUNT_HW_CACHE_OP_READ << 8) |\n\t\t\t(PERF_COUNT_HW_CACHE_RESULT_ACCESS << 16),\n\t};\n\tstruct perf_event_attr attr_hw_cache_branch_miss = {\n\t\t.sample_freq = SAMPLE_FREQ,\n\t\t.freq = 1,\n\t\t.type = PERF_TYPE_HW_CACHE,\n\t\t.config =\n\t\t\tPERF_COUNT_HW_CACHE_BPU |\n\t\t\t(PERF_COUNT_HW_CACHE_OP_READ << 8) |\n\t\t\t(PERF_COUNT_HW_CACHE_RESULT_MISS << 16),\n\t};\n\tstruct perf_event_attr attr_type_raw = {\n\t\t.sample_freq = SAMPLE_FREQ,\n\t\t.freq = 1,\n\t\t.type = PERF_TYPE_RAW,\n\t\t \n\t\t.config = 0xc0,\n\t};\n\tstruct perf_event_attr attr_type_raw_lock_load = {\n\t\t.sample_freq = SAMPLE_FREQ,\n\t\t.freq = 1,\n\t\t.type = PERF_TYPE_RAW,\n\t\t \n\t\t.config = 0x21d0,\n\t\t \n\t\t.sample_type = PERF_SAMPLE_ADDR,\n\t\t \n\t\t.precise_ip = 2,\n\t};\n\n\tprintf(\"Test HW_CPU_CYCLES\\n\");\n\ttest_perf_event_all_cpu(&attr_type_hw);\n\ttest_perf_event_task(&attr_type_hw);\n\n\tprintf(\"Test SW_CPU_CLOCK\\n\");\n\ttest_perf_event_all_cpu(&attr_type_sw);\n\ttest_perf_event_task(&attr_type_sw);\n\n\tprintf(\"Test HW_CACHE_L1D\\n\");\n\ttest_perf_event_all_cpu(&attr_hw_cache_l1d);\n\ttest_perf_event_task(&attr_hw_cache_l1d);\n\n\tprintf(\"Test HW_CACHE_BPU\\n\");\n\ttest_perf_event_all_cpu(&attr_hw_cache_branch_miss);\n\ttest_perf_event_task(&attr_hw_cache_branch_miss);\n\n\tprintf(\"Test Instruction Retired\\n\");\n\ttest_perf_event_all_cpu(&attr_type_raw);\n\ttest_perf_event_task(&attr_type_raw);\n\n\tprintf(\"Test Lock Load\\n\");\n\ttest_perf_event_all_cpu(&attr_type_raw_lock_load);\n\ttest_perf_event_task(&attr_type_raw_lock_load);\n\n\tprintf(\"*** PASS ***\\n\");\n}\n\n\nint main(int argc, char **argv)\n{\n\tstruct bpf_object *obj = NULL;\n\tchar filename[256];\n\tint error = 1;\n\n\tsnprintf(filename, sizeof(filename), \"%s_kern.o\", argv[0]);\n\n\tsignal(SIGINT, err_exit);\n\tsignal(SIGTERM, err_exit);\n\n\tif (load_kallsyms()) {\n\t\tprintf(\"failed to process /proc/kallsyms\\n\");\n\t\tgoto cleanup;\n\t}\n\n\tobj = bpf_object__open_file(filename, NULL);\n\tif (libbpf_get_error(obj)) {\n\t\tprintf(\"opening BPF object file failed\\n\");\n\t\tobj = NULL;\n\t\tgoto cleanup;\n\t}\n\n\tprog = bpf_object__find_program_by_name(obj, \"bpf_prog1\");\n\tif (!prog) {\n\t\tprintf(\"finding a prog in obj file failed\\n\");\n\t\tgoto cleanup;\n\t}\n\n\t \n\tif (bpf_object__load(obj)) {\n\t\tprintf(\"loading BPF object file failed\\n\");\n\t\tgoto cleanup;\n\t}\n\n\tmap_fd[0] = bpf_object__find_map_fd_by_name(obj, \"counts\");\n\tmap_fd[1] = bpf_object__find_map_fd_by_name(obj, \"stackmap\");\n\tif (map_fd[0] < 0 || map_fd[1] < 0) {\n\t\tprintf(\"finding a counts/stackmap map in obj file failed\\n\");\n\t\tgoto cleanup;\n\t}\n\n\tpid = fork();\n\tif (pid == 0) {\n\t\tread_trace_pipe();\n\t\treturn 0;\n\t} else if (pid == -1) {\n\t\tprintf(\"couldn't spawn process\\n\");\n\t\tgoto cleanup;\n\t}\n\n\ttest_bpf_perf_event();\n\terror = 0;\n\ncleanup:\n\tbpf_object__close(obj);\n\terr_exit(error);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}