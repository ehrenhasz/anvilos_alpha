{
  "module_name": "test_lwt_bpf.c",
  "hash_id": "a9a246aaa85127942d44bc05d1ffc7ea358cd723b5e27a2e2c0e9c8dddeb1586",
  "original_prompt": "Ingested from linux-6.6.14/samples/bpf/test_lwt_bpf.c",
  "human_readable_source": " \n\n#include \"vmlinux.h\"\n#include \"net_shared.h\"\n#include <bpf/bpf_helpers.h>\n#include <string.h>\n\n# define printk(fmt, ...)\t\t\t\t\t\t\\\n\t\t({\t\t\t\t\t\t\t\\\n\t\t\tchar ____fmt[] = fmt;\t\t\t\t\\\n\t\t\tbpf_trace_printk(____fmt, sizeof(____fmt),\t\\\n\t\t\t\t     ##__VA_ARGS__);\t\t\t\\\n\t\t})\n\n#define CB_MAGIC 1234\n\n \nSEC(\"nop\")\nint do_nop(struct __sk_buff *skb)\n{\n\treturn BPF_OK;\n}\n\n \nSEC(\"test_ctx\")\nint do_test_ctx(struct __sk_buff *skb)\n{\n\tskb->cb[0] = CB_MAGIC;\n\tprintk(\"len %d hash %d protocol %d\", skb->len, skb->hash,\n\t       skb->protocol);\n\tprintk(\"cb %d ingress_ifindex %d ifindex %d\", skb->cb[0],\n\t       skb->ingress_ifindex, skb->ifindex);\n\n\treturn BPF_OK;\n}\n\n \nSEC(\"test_cb\")\nint do_test_cb(struct __sk_buff *skb)\n{\n\tprintk(\"cb0: %x cb1: %x cb2: %x\", skb->cb[0], skb->cb[1],\n\t       skb->cb[2]);\n\tprintk(\"cb3: %x cb4: %x\", skb->cb[3], skb->cb[4]);\n\n\treturn BPF_OK;\n}\n\n \nSEC(\"test_data\")\nint do_test_data(struct __sk_buff *skb)\n{\n\tvoid *data = (void *)(long)skb->data;\n\tvoid *data_end = (void *)(long)skb->data_end;\n\tstruct iphdr *iph = data;\n\n\tif (data + sizeof(*iph) > data_end) {\n\t\tprintk(\"packet truncated\");\n\t\treturn BPF_DROP;\n\t}\n\n\tprintk(\"src: %x dst: %x\", iph->saddr, iph->daddr);\n\n\treturn BPF_OK;\n}\n\n#define IP_CSUM_OFF offsetof(struct iphdr, check)\n#define IP_DST_OFF offsetof(struct iphdr, daddr)\n#define IP_SRC_OFF offsetof(struct iphdr, saddr)\n#define IP_PROTO_OFF offsetof(struct iphdr, protocol)\n#define TCP_CSUM_OFF offsetof(struct tcphdr, check)\n#define UDP_CSUM_OFF offsetof(struct udphdr, check)\n#define IS_PSEUDO 0x10\n\nstatic inline int rewrite(struct __sk_buff *skb, uint32_t old_ip,\n\t\t\t  uint32_t new_ip, int rw_daddr)\n{\n\tint ret, off = 0, flags = IS_PSEUDO;\n\tuint8_t proto;\n\n\tret = bpf_skb_load_bytes(skb, IP_PROTO_OFF, &proto, 1);\n\tif (ret < 0) {\n\t\tprintk(\"bpf_l4_csum_replace failed: %d\", ret);\n\t\treturn BPF_DROP;\n\t}\n\n\tswitch (proto) {\n\tcase IPPROTO_TCP:\n\t\toff = TCP_CSUM_OFF;\n\t\tbreak;\n\n\tcase IPPROTO_UDP:\n\t\toff = UDP_CSUM_OFF;\n\t\tflags |= BPF_F_MARK_MANGLED_0;\n\t\tbreak;\n\n\tcase IPPROTO_ICMPV6:\n\t\toff = offsetof(struct icmp6hdr, icmp6_cksum);\n\t\tbreak;\n\t}\n\n\tif (off) {\n\t\tret = bpf_l4_csum_replace(skb, off, old_ip, new_ip,\n\t\t\t\t\t  flags | sizeof(new_ip));\n\t\tif (ret < 0) {\n\t\t\tprintk(\"bpf_l4_csum_replace failed: %d\");\n\t\t\treturn BPF_DROP;\n\t\t}\n\t}\n\n\tret = bpf_l3_csum_replace(skb, IP_CSUM_OFF, old_ip, new_ip, sizeof(new_ip));\n\tif (ret < 0) {\n\t\tprintk(\"bpf_l3_csum_replace failed: %d\", ret);\n\t\treturn BPF_DROP;\n\t}\n\n\tif (rw_daddr)\n\t\tret = bpf_skb_store_bytes(skb, IP_DST_OFF, &new_ip, sizeof(new_ip), 0);\n\telse\n\t\tret = bpf_skb_store_bytes(skb, IP_SRC_OFF, &new_ip, sizeof(new_ip), 0);\n\n\tif (ret < 0) {\n\t\tprintk(\"bpf_skb_store_bytes() failed: %d\", ret);\n\t\treturn BPF_DROP;\n\t}\n\n\treturn BPF_OK;\n}\n\n \nSEC(\"test_rewrite\")\nint do_test_rewrite(struct __sk_buff *skb)\n{\n\tuint32_t old_ip, new_ip = 0x3fea8c0;\n\tint ret;\n\n\tret = bpf_skb_load_bytes(skb, IP_DST_OFF, &old_ip, 4);\n\tif (ret < 0) {\n\t\tprintk(\"bpf_skb_load_bytes failed: %d\", ret);\n\t\treturn BPF_DROP;\n\t}\n\n\tif (old_ip == 0x2fea8c0) {\n\t\tprintk(\"out: rewriting from %x to %x\", old_ip, new_ip);\n\t\treturn rewrite(skb, old_ip, new_ip, 1);\n\t}\n\n\treturn BPF_OK;\n}\n\nstatic inline int __do_push_ll_and_redirect(struct __sk_buff *skb)\n{\n\tuint64_t smac = SRC_MAC, dmac = DST_MAC;\n\tint ret, ifindex = DST_IFINDEX;\n\tstruct ethhdr ehdr;\n\n\tret = bpf_skb_change_head(skb, 14, 0);\n\tif (ret < 0) {\n\t\tprintk(\"skb_change_head() failed: %d\", ret);\n\t}\n\n\tehdr.h_proto = bpf_htons(ETH_P_IP);\n\tmemcpy(&ehdr.h_source, &smac, 6);\n\tmemcpy(&ehdr.h_dest, &dmac, 6);\n\n\tret = bpf_skb_store_bytes(skb, 0, &ehdr, sizeof(ehdr), 0);\n\tif (ret < 0) {\n\t\tprintk(\"skb_store_bytes() failed: %d\", ret);\n\t\treturn BPF_DROP;\n\t}\n\n\treturn bpf_redirect(ifindex, 0);\n}\n\nSEC(\"push_ll_and_redirect_silent\")\nint do_push_ll_and_redirect_silent(struct __sk_buff *skb)\n{\n\treturn __do_push_ll_and_redirect(skb);\n}\n\nSEC(\"push_ll_and_redirect\")\nint do_push_ll_and_redirect(struct __sk_buff *skb)\n{\n\tint ret, ifindex = DST_IFINDEX;\n\n\tret = __do_push_ll_and_redirect(skb);\n\tif (ret >= 0)\n\t\tprintk(\"redirected to %d\", ifindex);\n\n\treturn ret;\n}\n\nstatic inline void __fill_garbage(struct __sk_buff *skb)\n{\n\tuint64_t f = 0xFFFFFFFFFFFFFFFF;\n\n\tbpf_skb_store_bytes(skb, 0, &f, sizeof(f), 0);\n\tbpf_skb_store_bytes(skb, 8, &f, sizeof(f), 0);\n\tbpf_skb_store_bytes(skb, 16, &f, sizeof(f), 0);\n\tbpf_skb_store_bytes(skb, 24, &f, sizeof(f), 0);\n\tbpf_skb_store_bytes(skb, 32, &f, sizeof(f), 0);\n\tbpf_skb_store_bytes(skb, 40, &f, sizeof(f), 0);\n\tbpf_skb_store_bytes(skb, 48, &f, sizeof(f), 0);\n\tbpf_skb_store_bytes(skb, 56, &f, sizeof(f), 0);\n\tbpf_skb_store_bytes(skb, 64, &f, sizeof(f), 0);\n\tbpf_skb_store_bytes(skb, 72, &f, sizeof(f), 0);\n\tbpf_skb_store_bytes(skb, 80, &f, sizeof(f), 0);\n\tbpf_skb_store_bytes(skb, 88, &f, sizeof(f), 0);\n}\n\nSEC(\"fill_garbage\")\nint do_fill_garbage(struct __sk_buff *skb)\n{\n\t__fill_garbage(skb);\n\tprintk(\"Set initial 96 bytes of header to FF\");\n\treturn BPF_OK;\n}\n\nSEC(\"fill_garbage_and_redirect\")\nint do_fill_garbage_and_redirect(struct __sk_buff *skb)\n{\n\tint ifindex = DST_IFINDEX;\n\t__fill_garbage(skb);\n\tprintk(\"redirected to %d\", ifindex);\n\treturn bpf_redirect(ifindex, 0);\n}\n\n \nSEC(\"drop_all\")\nint do_drop_all(struct __sk_buff *skb)\n{\n\tprintk(\"dropping with: %d\", BPF_DROP);\n\treturn BPF_DROP;\n}\n\nchar _license[] SEC(\"license\") = \"GPL\";\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}