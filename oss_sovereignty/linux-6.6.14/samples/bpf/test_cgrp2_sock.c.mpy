{
  "module_name": "test_cgrp2_sock.c",
  "hash_id": "673e01a852c4f31761f075ff63a6abdc2ffdab64cf925c0dfaaf04eeef002b95",
  "original_prompt": "Ingested from linux-6.6.14/samples/bpf/test_cgrp2_sock.c",
  "human_readable_source": " \n\n#define _GNU_SOURCE\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <string.h>\n#include <unistd.h>\n#include <assert.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <net/if.h>\n#include <inttypes.h>\n#include <linux/bpf.h>\n#include <bpf/bpf.h>\n\n#include \"bpf_insn.h\"\n\nchar bpf_log_buf[BPF_LOG_BUF_SIZE];\n\nstatic int prog_load(__u32 idx, __u32 mark, __u32 prio)\n{\n\t \n\tstruct bpf_insn prog_start[] = {\n\t\tBPF_MOV64_REG(BPF_REG_6, BPF_REG_1),\n\t};\n\tstruct bpf_insn prog_end[] = {\n\t\tBPF_MOV64_IMM(BPF_REG_0, 1),  \n\t\tBPF_EXIT_INSN(),\n\t};\n\n\t \n\tstruct bpf_insn prog_dev[] = {\n\t\tBPF_MOV64_IMM(BPF_REG_3, idx),\n\t\tBPF_MOV64_IMM(BPF_REG_2, offsetof(struct bpf_sock, bound_dev_if)),\n\t\tBPF_STX_MEM(BPF_W, BPF_REG_1, BPF_REG_3, offsetof(struct bpf_sock, bound_dev_if)),\n\t};\n\n\t \n\tstruct bpf_insn prog_mark[] = {\n\t\t \n\t\tBPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0,\n\t\t\t     BPF_FUNC_get_current_uid_gid),\n\t\tBPF_ALU64_IMM(BPF_AND, BPF_REG_0, 0xffffffff),\n\n\t\t \n\t\tBPF_MOV64_REG(BPF_REG_3, BPF_REG_0),\n\t\tBPF_JMP_IMM(BPF_JNE, BPF_REG_0, 0, 1),\n\t\tBPF_MOV64_IMM(BPF_REG_3, mark),\n\n\t\t \n\t\tBPF_MOV64_REG(BPF_REG_1, BPF_REG_6),\n\t\tBPF_MOV64_IMM(BPF_REG_2, offsetof(struct bpf_sock, mark)),\n\t\tBPF_STX_MEM(BPF_W, BPF_REG_1, BPF_REG_3, offsetof(struct bpf_sock, mark)),\n\t};\n\n\t \n\tstruct bpf_insn prog_prio[] = {\n\t\tBPF_MOV64_REG(BPF_REG_1, BPF_REG_6),\n\t\tBPF_MOV64_IMM(BPF_REG_3, prio),\n\t\tBPF_MOV64_IMM(BPF_REG_2, offsetof(struct bpf_sock, priority)),\n\t\tBPF_STX_MEM(BPF_W, BPF_REG_1, BPF_REG_3, offsetof(struct bpf_sock, priority)),\n\t};\n\tLIBBPF_OPTS(bpf_prog_load_opts, opts,\n\t\t.log_buf = bpf_log_buf,\n\t\t.log_size = BPF_LOG_BUF_SIZE,\n\t);\n\n\tstruct bpf_insn *prog;\n\tsize_t insns_cnt;\n\tvoid *p;\n\tint ret;\n\n\tinsns_cnt = sizeof(prog_start) + sizeof(prog_end);\n\tif (idx)\n\t\tinsns_cnt += sizeof(prog_dev);\n\n\tif (mark)\n\t\tinsns_cnt += sizeof(prog_mark);\n\n\tif (prio)\n\t\tinsns_cnt += sizeof(prog_prio);\n\n\tp = prog = malloc(insns_cnt);\n\tif (!prog) {\n\t\tfprintf(stderr, \"Failed to allocate memory for instructions\\n\");\n\t\treturn EXIT_FAILURE;\n\t}\n\n\tmemcpy(p, prog_start, sizeof(prog_start));\n\tp += sizeof(prog_start);\n\n\tif (idx) {\n\t\tmemcpy(p, prog_dev, sizeof(prog_dev));\n\t\tp += sizeof(prog_dev);\n\t}\n\n\tif (mark) {\n\t\tmemcpy(p, prog_mark, sizeof(prog_mark));\n\t\tp += sizeof(prog_mark);\n\t}\n\n\tif (prio) {\n\t\tmemcpy(p, prog_prio, sizeof(prog_prio));\n\t\tp += sizeof(prog_prio);\n\t}\n\n\tmemcpy(p, prog_end, sizeof(prog_end));\n\tp += sizeof(prog_end);\n\n\tinsns_cnt /= sizeof(struct bpf_insn);\n\n\tret = bpf_prog_load(BPF_PROG_TYPE_CGROUP_SOCK, NULL, \"GPL\",\n\t\t\t    prog, insns_cnt, &opts);\n\n\tfree(prog);\n\n\treturn ret;\n}\n\nstatic int get_bind_to_device(int sd, char *name, size_t len)\n{\n\tsocklen_t optlen = len;\n\tint rc;\n\n\tname[0] = '\\0';\n\trc = getsockopt(sd, SOL_SOCKET, SO_BINDTODEVICE, name, &optlen);\n\tif (rc < 0)\n\t\tperror(\"setsockopt(SO_BINDTODEVICE)\");\n\n\treturn rc;\n}\n\nstatic unsigned int get_somark(int sd)\n{\n\tunsigned int mark = 0;\n\tsocklen_t optlen = sizeof(mark);\n\tint rc;\n\n\trc = getsockopt(sd, SOL_SOCKET, SO_MARK, &mark, &optlen);\n\tif (rc < 0)\n\t\tperror(\"getsockopt(SO_MARK)\");\n\n\treturn mark;\n}\n\nstatic unsigned int get_priority(int sd)\n{\n\tunsigned int prio = 0;\n\tsocklen_t optlen = sizeof(prio);\n\tint rc;\n\n\trc = getsockopt(sd, SOL_SOCKET, SO_PRIORITY, &prio, &optlen);\n\tif (rc < 0)\n\t\tperror(\"getsockopt(SO_PRIORITY)\");\n\n\treturn prio;\n}\n\nstatic int show_sockopts(int family)\n{\n\tunsigned int mark, prio;\n\tchar name[16];\n\tint sd;\n\n\tsd = socket(family, SOCK_DGRAM, 17);\n\tif (sd < 0) {\n\t\tperror(\"socket\");\n\t\treturn 1;\n\t}\n\n\tif (get_bind_to_device(sd, name, sizeof(name)) < 0)\n\t\treturn 1;\n\n\tmark = get_somark(sd);\n\tprio = get_priority(sd);\n\n\tclose(sd);\n\n\tprintf(\"sd %d: dev %s, mark %u, priority %u\\n\", sd, name, mark, prio);\n\n\treturn 0;\n}\n\nstatic int usage(const char *argv0)\n{\n\tprintf(\"Usage:\\n\");\n\tprintf(\"  Attach a program\\n\");\n\tprintf(\"  %s -b bind-to-dev -m mark -p prio cg-path\\n\", argv0);\n\tprintf(\"\\n\");\n\tprintf(\"  Detach a program\\n\");\n\tprintf(\"  %s -d cg-path\\n\", argv0);\n\tprintf(\"\\n\");\n\tprintf(\"  Show inherited socket settings (mark, priority, and device)\\n\");\n\tprintf(\"  %s [-6]\\n\", argv0);\n\treturn EXIT_FAILURE;\n}\n\nint main(int argc, char **argv)\n{\n\t__u32 idx = 0, mark = 0, prio = 0;\n\tconst char *cgrp_path = NULL;\n\tint cg_fd, prog_fd, ret;\n\tint family = PF_INET;\n\tint do_attach = 1;\n\tint rc;\n\n\twhile ((rc = getopt(argc, argv, \"db:m:p:6\")) != -1) {\n\t\tswitch (rc) {\n\t\tcase 'd':\n\t\t\tdo_attach = 0;\n\t\t\tbreak;\n\t\tcase 'b':\n\t\t\tidx = if_nametoindex(optarg);\n\t\t\tif (!idx) {\n\t\t\t\tidx = strtoumax(optarg, NULL, 0);\n\t\t\t\tif (!idx) {\n\t\t\t\t\tprintf(\"Invalid device name\\n\");\n\t\t\t\t\treturn EXIT_FAILURE;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'm':\n\t\t\tmark = strtoumax(optarg, NULL, 0);\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\tprio = strtoumax(optarg, NULL, 0);\n\t\t\tbreak;\n\t\tcase '6':\n\t\t\tfamily = PF_INET6;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn usage(argv[0]);\n\t\t}\n\t}\n\n\tif (optind == argc)\n\t\treturn show_sockopts(family);\n\n\tcgrp_path = argv[optind];\n\tif (!cgrp_path) {\n\t\tfprintf(stderr, \"cgroup path not given\\n\");\n\t\treturn EXIT_FAILURE;\n\t}\n\n\tif (do_attach && !idx && !mark && !prio) {\n\t\tfprintf(stderr,\n\t\t\t\"One of device, mark or priority must be given\\n\");\n\t\treturn EXIT_FAILURE;\n\t}\n\n\tcg_fd = open(cgrp_path, O_DIRECTORY | O_RDONLY);\n\tif (cg_fd < 0) {\n\t\tprintf(\"Failed to open cgroup path: '%s'\\n\", strerror(errno));\n\t\treturn EXIT_FAILURE;\n\t}\n\n\tif (do_attach) {\n\t\tprog_fd = prog_load(idx, mark, prio);\n\t\tif (prog_fd < 0) {\n\t\t\tprintf(\"Failed to load prog: '%s'\\n\", strerror(errno));\n\t\t\tprintf(\"Output from kernel verifier:\\n%s\\n-------\\n\",\n\t\t\t       bpf_log_buf);\n\t\t\treturn EXIT_FAILURE;\n\t\t}\n\n\t\tret = bpf_prog_attach(prog_fd, cg_fd,\n\t\t\t\t      BPF_CGROUP_INET_SOCK_CREATE, 0);\n\t\tif (ret < 0) {\n\t\t\tprintf(\"Failed to attach prog to cgroup: '%s'\\n\",\n\t\t\t       strerror(errno));\n\t\t\treturn EXIT_FAILURE;\n\t\t}\n\t} else {\n\t\tret = bpf_prog_detach(cg_fd, BPF_CGROUP_INET_SOCK_CREATE);\n\t\tif (ret < 0) {\n\t\t\tprintf(\"Failed to detach prog from cgroup: '%s'\\n\",\n\t\t\t       strerror(errno));\n\t\t\treturn EXIT_FAILURE;\n\t\t}\n\t}\n\n\tclose(cg_fd);\n\treturn EXIT_SUCCESS;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}