{
  "module_name": "hbm_kern.h",
  "hash_id": "994d128f7c3205d8d2b92a06b1b3cf435be11c460233e7729a867e2903324504",
  "original_prompt": "Ingested from linux-6.6.14/samples/bpf/hbm_kern.h",
  "human_readable_source": " \n#define KBUILD_MODNAME \"foo\"\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/if_ether.h>\n#include <uapi/linux/if_packet.h>\n#include <uapi/linux/ip.h>\n#include <uapi/linux/ipv6.h>\n#include <uapi/linux/in.h>\n#include <uapi/linux/tcp.h>\n#include <uapi/linux/filter.h>\n#include <uapi/linux/pkt_cls.h>\n#include <net/ipv6.h>\n#include <net/inet_ecn.h>\n#include <bpf/bpf_endian.h>\n#include <bpf/bpf_helpers.h>\n#include \"hbm.h\"\n\n#define DROP_PKT\t0\n#define ALLOW_PKT\t1\n#define TCP_ECN_OK\t1\n#define CWR\t\t2\n\n#ifndef HBM_DEBUG  \n#undef bpf_printk\n#define bpf_printk(fmt, ...)\n#endif\n\n#define INITIAL_CREDIT_PACKETS\t100\n#define MAX_BYTES_PER_PACKET\t1500\n#define MARK_THRESH\t\t(40 * MAX_BYTES_PER_PACKET)\n#define DROP_THRESH\t\t(80 * 5 * MAX_BYTES_PER_PACKET)\n#define LARGE_PKT_DROP_THRESH\t(DROP_THRESH - (15 * MAX_BYTES_PER_PACKET))\n#define MARK_REGION_SIZE\t(LARGE_PKT_DROP_THRESH - MARK_THRESH)\n#define LARGE_PKT_THRESH\t120\n#define MAX_CREDIT\t\t(100 * MAX_BYTES_PER_PACKET)\n#define INIT_CREDIT\t\t(INITIAL_CREDIT_PACKETS * MAX_BYTES_PER_PACKET)\n\n\n#define BURST_SIZE_NS\t\t100000 \n#define MARK_THRESH_NS\t\t50000 \n#define DROP_THRESH_NS\t\t500000 \n\n#define LARGE_PKT_DROP_THRESH_NS (DROP_THRESH_NS - 20000)\n#define MARK_REGION_SIZE_NS\t(LARGE_PKT_DROP_THRESH_NS - MARK_THRESH_NS)\n\n\n#define CREDIT_PER_NS(delta, rate) ((((u64)(delta)) * (rate)) >> 20)\n#define BYTES_PER_NS(delta, rate) ((((u64)(delta)) * (rate)) >> 20)\n#define BYTES_TO_NS(bytes, rate) div64_u64(((u64)(bytes)) << 20, (u64)(rate))\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_CGROUP_STORAGE);\n\t__type(key, struct bpf_cgroup_storage_key);\n\t__type(value, struct hbm_vqueue);\n} queue_state SEC(\".maps\");\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_ARRAY);\n\t__uint(max_entries, 1);\n\t__type(key, u32);\n\t__type(value, struct hbm_queue_stats);\n} queue_stats SEC(\".maps\");\n\nstruct hbm_pkt_info {\n\tint\tcwnd;\n\tint\trtt;\n\tint\tpackets_out;\n\tbool\tis_ip;\n\tbool\tis_tcp;\n\tshort\tecn;\n};\n\nstatic int get_tcp_info(struct __sk_buff *skb, struct hbm_pkt_info *pkti)\n{\n\tstruct bpf_sock *sk;\n\tstruct bpf_tcp_sock *tp;\n\n\tsk = skb->sk;\n\tif (sk) {\n\t\tsk = bpf_sk_fullsock(sk);\n\t\tif (sk) {\n\t\t\tif (sk->protocol == IPPROTO_TCP) {\n\t\t\t\ttp = bpf_tcp_sock(sk);\n\t\t\t\tif (tp) {\n\t\t\t\t\tpkti->cwnd = tp->snd_cwnd;\n\t\t\t\t\tpkti->rtt = tp->srtt_us >> 3;\n\t\t\t\t\tpkti->packets_out = tp->packets_out;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tpkti->cwnd = 0;\n\tpkti->rtt = 0;\n\tpkti->packets_out = 0;\n\treturn 1;\n}\n\nstatic void hbm_get_pkt_info(struct __sk_buff *skb,\n\t\t\t     struct hbm_pkt_info *pkti)\n{\n\tstruct iphdr iph;\n\tstruct ipv6hdr *ip6h;\n\n\tpkti->cwnd = 0;\n\tpkti->rtt = 0;\n\tbpf_skb_load_bytes(skb, 0, &iph, 12);\n\tif (iph.version == 6) {\n\t\tip6h = (struct ipv6hdr *)&iph;\n\t\tpkti->is_ip = true;\n\t\tpkti->is_tcp = (ip6h->nexthdr == 6);\n\t\tpkti->ecn = (ip6h->flow_lbl[0] >> 4) & INET_ECN_MASK;\n\t} else if (iph.version == 4) {\n\t\tpkti->is_ip = true;\n\t\tpkti->is_tcp = (iph.protocol == 6);\n\t\tpkti->ecn = iph.tos & INET_ECN_MASK;\n\t} else {\n\t\tpkti->is_ip = false;\n\t\tpkti->is_tcp = false;\n\t\tpkti->ecn = 0;\n\t}\n\tif (pkti->is_tcp)\n\t\tget_tcp_info(skb, pkti);\n}\n\nstatic __always_inline void hbm_init_vqueue(struct hbm_vqueue *qdp, int rate)\n{\n\tbpf_printk(\"Initializing queue_state, rate:%d\\n\", rate * 128);\n\tqdp->lasttime = bpf_ktime_get_ns();\n\tqdp->credit = INIT_CREDIT;\n\tqdp->rate = rate * 128;\n}\n\nstatic __always_inline void hbm_init_edt_vqueue(struct hbm_vqueue *qdp,\n\t\t\t\t\t\tint rate)\n{\n\tunsigned long long curtime;\n\n\tcurtime = bpf_ktime_get_ns();\n\tbpf_printk(\"Initializing queue_state, rate:%d\\n\", rate * 128);\n\tqdp->lasttime = curtime - BURST_SIZE_NS;\t\n\tqdp->credit = 0;\t\t\t\t\n\tqdp->rate = rate * 128;\n}\n\nstatic __always_inline void hbm_update_stats(struct hbm_queue_stats *qsp,\n\t\t\t\t\t     int len,\n\t\t\t\t\t     unsigned long long curtime,\n\t\t\t\t\t     bool congestion_flag,\n\t\t\t\t\t     bool drop_flag,\n\t\t\t\t\t     bool cwr_flag,\n\t\t\t\t\t     bool ecn_ce_flag,\n\t\t\t\t\t     struct hbm_pkt_info *pkti,\n\t\t\t\t\t     int credit)\n{\n\tint rv = ALLOW_PKT;\n\n\tif (qsp != NULL) {\n\t\t\n\t\t__sync_add_and_fetch(&(qsp->bytes_total), len);\n\t\tif (qsp->stats) {\n\t\t\t\n\t\t\tif (qsp->firstPacketTime == 0)\n\t\t\t\tqsp->firstPacketTime = curtime;\n\t\t\tqsp->lastPacketTime = curtime;\n\t\t\t__sync_add_and_fetch(&(qsp->pkts_total), 1);\n\t\t\tif (congestion_flag) {\n\t\t\t\t__sync_add_and_fetch(&(qsp->pkts_marked), 1);\n\t\t\t\t__sync_add_and_fetch(&(qsp->bytes_marked), len);\n\t\t\t}\n\t\t\tif (drop_flag) {\n\t\t\t\t__sync_add_and_fetch(&(qsp->pkts_dropped), 1);\n\t\t\t\t__sync_add_and_fetch(&(qsp->bytes_dropped),\n\t\t\t\t\t\t     len);\n\t\t\t}\n\t\t\tif (ecn_ce_flag)\n\t\t\t\t__sync_add_and_fetch(&(qsp->pkts_ecn_ce), 1);\n\t\t\tif (pkti->cwnd) {\n\t\t\t\t__sync_add_and_fetch(&(qsp->sum_cwnd),\n\t\t\t\t\t\t     pkti->cwnd);\n\t\t\t\t__sync_add_and_fetch(&(qsp->sum_cwnd_cnt), 1);\n\t\t\t}\n\t\t\tif (pkti->rtt)\n\t\t\t\t__sync_add_and_fetch(&(qsp->sum_rtt),\n\t\t\t\t\t\t     pkti->rtt);\n\t\t\t__sync_add_and_fetch(&(qsp->sum_credit), credit);\n\n\t\t\tif (drop_flag)\n\t\t\t\trv = DROP_PKT;\n\t\t\tif (cwr_flag)\n\t\t\t\trv |= 2;\n\t\t\tif (rv == DROP_PKT)\n\t\t\t\t__sync_add_and_fetch(&(qsp->returnValCount[0]),\n\t\t\t\t\t\t     1);\n\t\t\telse if (rv == ALLOW_PKT)\n\t\t\t\t__sync_add_and_fetch(&(qsp->returnValCount[1]),\n\t\t\t\t\t\t     1);\n\t\t\telse if (rv == 2)\n\t\t\t\t__sync_add_and_fetch(&(qsp->returnValCount[2]),\n\t\t\t\t\t\t     1);\n\t\t\telse if (rv == 3)\n\t\t\t\t__sync_add_and_fetch(&(qsp->returnValCount[3]),\n\t\t\t\t\t\t     1);\n\t\t}\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}