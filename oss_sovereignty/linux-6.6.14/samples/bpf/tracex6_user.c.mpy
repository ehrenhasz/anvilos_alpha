{
  "module_name": "tracex6_user.c",
  "hash_id": "70117f9086ce856e1436ecfd089c5bf9dfa79ffb8410733950ac5b6e1f0cf0cb",
  "original_prompt": "Ingested from linux-6.6.14/samples/bpf/tracex6_user.c",
  "human_readable_source": "\n#define _GNU_SOURCE\n\n#include <assert.h>\n#include <fcntl.h>\n#include <linux/perf_event.h>\n#include <sched.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <sys/ioctl.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/wait.h>\n#include <unistd.h>\n\n#include <bpf/bpf.h>\n#include <bpf/libbpf.h>\n#include \"perf-sys.h\"\n\n#define SAMPLE_PERIOD  0x7fffffffffffffffULL\n\n \nstatic int map_fd[3];\n\nstatic void check_on_cpu(int cpu, struct perf_event_attr *attr)\n{\n\tstruct bpf_perf_event_value value2;\n\tint pmu_fd, error = 0;\n\tcpu_set_t set;\n\t__u64 value;\n\n\t \n\tCPU_ZERO(&set);\n\tCPU_SET(cpu, &set);\n\tassert(sched_setaffinity(0, sizeof(set), &set) == 0);\n\t \n\tpmu_fd = sys_perf_event_open(attr, -1 , cpu , -1 , 0);\n\tif (pmu_fd < 0) {\n\t\tfprintf(stderr, \"sys_perf_event_open failed on CPU %d\\n\", cpu);\n\t\terror = 1;\n\t\tgoto on_exit;\n\t}\n\tassert(bpf_map_update_elem(map_fd[0], &cpu, &pmu_fd, BPF_ANY) == 0);\n\tassert(ioctl(pmu_fd, PERF_EVENT_IOC_ENABLE, 0) == 0);\n\t \n\tbpf_map_get_next_key(map_fd[1], &cpu, NULL);\n\t \n\tif (bpf_map_lookup_elem(map_fd[1], &cpu, &value)) {\n\t\tfprintf(stderr, \"Value missing for CPU %d\\n\", cpu);\n\t\terror = 1;\n\t\tgoto on_exit;\n\t} else {\n\t\tfprintf(stderr, \"CPU %d: %llu\\n\", cpu, value);\n\t}\n\t \n\tif (bpf_map_lookup_elem(map_fd[2], &cpu, &value2)) {\n\t\tfprintf(stderr, \"Value2 missing for CPU %d\\n\", cpu);\n\t\terror = 1;\n\t\tgoto on_exit;\n\t} else {\n\t\tfprintf(stderr, \"CPU %d: counter: %llu, enabled: %llu, running: %llu\\n\", cpu,\n\t\t\tvalue2.counter, value2.enabled, value2.running);\n\t}\n\non_exit:\n\tassert(bpf_map_delete_elem(map_fd[0], &cpu) == 0 || error);\n\tassert(ioctl(pmu_fd, PERF_EVENT_IOC_DISABLE, 0) == 0 || error);\n\tassert(close(pmu_fd) == 0 || error);\n\tassert(bpf_map_delete_elem(map_fd[1], &cpu) == 0 || error);\n\texit(error);\n}\n\nstatic void test_perf_event_array(struct perf_event_attr *attr,\n\t\t\t\t  const char *name)\n{\n\tint i, status, nr_cpus = sysconf(_SC_NPROCESSORS_CONF);\n\tpid_t pid[nr_cpus];\n\tint err = 0;\n\n\tprintf(\"Test reading %s counters\\n\", name);\n\n\tfor (i = 0; i < nr_cpus; i++) {\n\t\tpid[i] = fork();\n\t\tassert(pid[i] >= 0);\n\t\tif (pid[i] == 0) {\n\t\t\tcheck_on_cpu(i, attr);\n\t\t\texit(1);\n\t\t}\n\t}\n\n\tfor (i = 0; i < nr_cpus; i++) {\n\t\tassert(waitpid(pid[i], &status, 0) == pid[i]);\n\t\terr |= status;\n\t}\n\n\tif (err)\n\t\tprintf(\"Test: %s FAILED\\n\", name);\n}\n\nstatic void test_bpf_perf_event(void)\n{\n\tstruct perf_event_attr attr_cycles = {\n\t\t.freq = 0,\n\t\t.sample_period = SAMPLE_PERIOD,\n\t\t.inherit = 0,\n\t\t.type = PERF_TYPE_HARDWARE,\n\t\t.read_format = 0,\n\t\t.sample_type = 0,\n\t\t.config = PERF_COUNT_HW_CPU_CYCLES,\n\t};\n\tstruct perf_event_attr attr_clock = {\n\t\t.freq = 0,\n\t\t.sample_period = SAMPLE_PERIOD,\n\t\t.inherit = 0,\n\t\t.type = PERF_TYPE_SOFTWARE,\n\t\t.read_format = 0,\n\t\t.sample_type = 0,\n\t\t.config = PERF_COUNT_SW_CPU_CLOCK,\n\t};\n\tstruct perf_event_attr attr_raw = {\n\t\t.freq = 0,\n\t\t.sample_period = SAMPLE_PERIOD,\n\t\t.inherit = 0,\n\t\t.type = PERF_TYPE_RAW,\n\t\t.read_format = 0,\n\t\t.sample_type = 0,\n\t\t \n\t\t.config = 0xc0,\n\t};\n\tstruct perf_event_attr attr_l1d_load = {\n\t\t.freq = 0,\n\t\t.sample_period = SAMPLE_PERIOD,\n\t\t.inherit = 0,\n\t\t.type = PERF_TYPE_HW_CACHE,\n\t\t.read_format = 0,\n\t\t.sample_type = 0,\n\t\t.config =\n\t\t\tPERF_COUNT_HW_CACHE_L1D |\n\t\t\t(PERF_COUNT_HW_CACHE_OP_READ << 8) |\n\t\t\t(PERF_COUNT_HW_CACHE_RESULT_ACCESS << 16),\n\t};\n\tstruct perf_event_attr attr_llc_miss = {\n\t\t.freq = 0,\n\t\t.sample_period = SAMPLE_PERIOD,\n\t\t.inherit = 0,\n\t\t.type = PERF_TYPE_HW_CACHE,\n\t\t.read_format = 0,\n\t\t.sample_type = 0,\n\t\t.config =\n\t\t\tPERF_COUNT_HW_CACHE_LL |\n\t\t\t(PERF_COUNT_HW_CACHE_OP_READ << 8) |\n\t\t\t(PERF_COUNT_HW_CACHE_RESULT_MISS << 16),\n\t};\n\tstruct perf_event_attr attr_msr_tsc = {\n\t\t.freq = 0,\n\t\t.sample_period = 0,\n\t\t.inherit = 0,\n\t\t \n\t\t.type = 7,\n\t\t.read_format = 0,\n\t\t.sample_type = 0,\n\t\t.config = 0,\n\t};\n\n\ttest_perf_event_array(&attr_cycles, \"HARDWARE-cycles\");\n\ttest_perf_event_array(&attr_clock, \"SOFTWARE-clock\");\n\ttest_perf_event_array(&attr_raw, \"RAW-instruction-retired\");\n\ttest_perf_event_array(&attr_l1d_load, \"HW_CACHE-L1D-load\");\n\n\t \n\ttest_perf_event_array(&attr_llc_miss, \"HW_CACHE-LLC-miss\");\n\ttest_perf_event_array(&attr_msr_tsc, \"Dynamic-msr-tsc\");\n}\n\nint main(int argc, char **argv)\n{\n\tstruct bpf_link *links[2];\n\tstruct bpf_program *prog;\n\tstruct bpf_object *obj;\n\tchar filename[256];\n\tint i = 0;\n\n\tsnprintf(filename, sizeof(filename), \"%s.bpf.o\", argv[0]);\n\tobj = bpf_object__open_file(filename, NULL);\n\tif (libbpf_get_error(obj)) {\n\t\tfprintf(stderr, \"ERROR: opening BPF object file failed\\n\");\n\t\treturn 0;\n\t}\n\n\t \n\tif (bpf_object__load(obj)) {\n\t\tfprintf(stderr, \"ERROR: loading BPF object file failed\\n\");\n\t\tgoto cleanup;\n\t}\n\n\tmap_fd[0] = bpf_object__find_map_fd_by_name(obj, \"counters\");\n\tmap_fd[1] = bpf_object__find_map_fd_by_name(obj, \"values\");\n\tmap_fd[2] = bpf_object__find_map_fd_by_name(obj, \"values2\");\n\tif (map_fd[0] < 0 || map_fd[1] < 0 || map_fd[2] < 0) {\n\t\tfprintf(stderr, \"ERROR: finding a map in obj file failed\\n\");\n\t\tgoto cleanup;\n\t}\n\n\tbpf_object__for_each_program(prog, obj) {\n\t\tlinks[i] = bpf_program__attach(prog);\n\t\tif (libbpf_get_error(links[i])) {\n\t\t\tfprintf(stderr, \"ERROR: bpf_program__attach failed\\n\");\n\t\t\tlinks[i] = NULL;\n\t\t\tgoto cleanup;\n\t\t}\n\t\ti++;\n\t}\n\n\ttest_bpf_perf_event();\n\ncleanup:\n\tfor (i--; i >= 0; i--)\n\t\tbpf_link__destroy(links[i]);\n\n\tbpf_object__close(obj);\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}