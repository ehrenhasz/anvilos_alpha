{
  "module_name": "xdp_tx_iptunnel_user.c",
  "hash_id": "0e7b6f3d65caedd14e307fd9206aad8cb83025cf06edd18ac32903163fc3d2f2",
  "original_prompt": "Ingested from linux-6.6.14/samples/bpf/xdp_tx_iptunnel_user.c",
  "human_readable_source": "\n \n#include <linux/bpf.h>\n#include <linux/if_link.h>\n#include <assert.h>\n#include <errno.h>\n#include <signal.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <net/if.h>\n#include <arpa/inet.h>\n#include <netinet/ether.h>\n#include <unistd.h>\n#include <time.h>\n#include <bpf/libbpf.h>\n#include <bpf/bpf.h>\n#include \"bpf_util.h\"\n#include \"xdp_tx_iptunnel_common.h\"\n\n#define STATS_INTERVAL_S 2U\n\nstatic int ifindex = -1;\nstatic __u32 xdp_flags = XDP_FLAGS_UPDATE_IF_NOEXIST;\nstatic int rxcnt_map_fd;\nstatic __u32 prog_id;\n\nstatic void int_exit(int sig)\n{\n\t__u32 curr_prog_id = 0;\n\n\tif (ifindex > -1) {\n\t\tif (bpf_xdp_query_id(ifindex, xdp_flags, &curr_prog_id)) {\n\t\t\tprintf(\"bpf_xdp_query_id failed\\n\");\n\t\t\texit(1);\n\t\t}\n\t\tif (prog_id == curr_prog_id)\n\t\t\tbpf_xdp_detach(ifindex, xdp_flags, NULL);\n\t\telse if (!curr_prog_id)\n\t\t\tprintf(\"couldn't find a prog id on a given iface\\n\");\n\t\telse\n\t\t\tprintf(\"program on interface changed, not removing\\n\");\n\t}\n\texit(0);\n}\n\n \nstatic void poll_stats(unsigned int kill_after_s)\n{\n\tconst unsigned int nr_protos = 256;\n\tunsigned int nr_cpus = bpf_num_possible_cpus();\n\ttime_t started_at = time(NULL);\n\t__u64 values[nr_cpus], prev[nr_protos][nr_cpus];\n\t__u32 proto;\n\tint i;\n\n\tmemset(prev, 0, sizeof(prev));\n\n\twhile (!kill_after_s || time(NULL) - started_at <= kill_after_s) {\n\t\tsleep(STATS_INTERVAL_S);\n\n\t\tfor (proto = 0; proto < nr_protos; proto++) {\n\t\t\t__u64 sum = 0;\n\n\t\t\tassert(bpf_map_lookup_elem(rxcnt_map_fd, &proto,\n\t\t\t\t\t\t   values) == 0);\n\t\t\tfor (i = 0; i < nr_cpus; i++)\n\t\t\t\tsum += (values[i] - prev[proto][i]);\n\n\t\t\tif (sum)\n\t\t\t\tprintf(\"proto %u: sum:%10llu pkts, rate:%10llu pkts/s\\n\",\n\t\t\t\t       proto, sum, sum / STATS_INTERVAL_S);\n\t\t\tmemcpy(prev[proto], values, sizeof(values));\n\t\t}\n\t}\n}\n\nstatic void usage(const char *cmd)\n{\n\tprintf(\"Start a XDP prog which encapsulates incoming packets\\n\"\n\t       \"in an IPv4/v6 header and XDP_TX it out.  The dst <VIP:PORT>\\n\"\n\t       \"is used to select packets to encapsulate\\n\\n\");\n\tprintf(\"Usage: %s [...]\\n\", cmd);\n\tprintf(\"    -i <ifname|ifindex> Interface\\n\");\n\tprintf(\"    -a <vip-service-address> IPv4 or IPv6\\n\");\n\tprintf(\"    -p <vip-service-port> A port range (e.g. 433-444) is also allowed\\n\");\n\tprintf(\"    -s <source-ip> Used in the IPTunnel header\\n\");\n\tprintf(\"    -d <dest-ip> Used in the IPTunnel header\\n\");\n\tprintf(\"    -m <dest-MAC> Used in sending the IP Tunneled pkt\\n\");\n\tprintf(\"    -T <stop-after-X-seconds> Default: 0 (forever)\\n\");\n\tprintf(\"    -P <IP-Protocol> Default is TCP\\n\");\n\tprintf(\"    -S use skb-mode\\n\");\n\tprintf(\"    -N enforce native mode\\n\");\n\tprintf(\"    -F Force loading the XDP prog\\n\");\n\tprintf(\"    -h Display this help\\n\");\n}\n\nstatic int parse_ipstr(const char *ipstr, unsigned int *addr)\n{\n\tif (inet_pton(AF_INET6, ipstr, addr) == 1) {\n\t\treturn AF_INET6;\n\t} else if (inet_pton(AF_INET, ipstr, addr) == 1) {\n\t\taddr[1] = addr[2] = addr[3] = 0;\n\t\treturn AF_INET;\n\t}\n\n\tfprintf(stderr, \"%s is an invalid IP\\n\", ipstr);\n\treturn AF_UNSPEC;\n}\n\nstatic int parse_ports(const char *port_str, int *min_port, int *max_port)\n{\n\tchar *end;\n\tlong tmp_min_port;\n\tlong tmp_max_port;\n\n\ttmp_min_port = strtol(optarg, &end, 10);\n\tif (tmp_min_port < 1 || tmp_min_port > 65535) {\n\t\tfprintf(stderr, \"Invalid port(s):%s\\n\", optarg);\n\t\treturn 1;\n\t}\n\n\tif (*end == '-') {\n\t\tend++;\n\t\ttmp_max_port = strtol(end, NULL, 10);\n\t\tif (tmp_max_port < 1 || tmp_max_port > 65535) {\n\t\t\tfprintf(stderr, \"Invalid port(s):%s\\n\", optarg);\n\t\t\treturn 1;\n\t\t}\n\t} else {\n\t\ttmp_max_port = tmp_min_port;\n\t}\n\n\tif (tmp_min_port > tmp_max_port) {\n\t\tfprintf(stderr, \"Invalid port(s):%s\\n\", optarg);\n\t\treturn 1;\n\t}\n\n\tif (tmp_max_port - tmp_min_port + 1 > MAX_IPTNL_ENTRIES) {\n\t\tfprintf(stderr, \"Port range (%s) is larger than %u\\n\",\n\t\t\tport_str, MAX_IPTNL_ENTRIES);\n\t\treturn 1;\n\t}\n\t*min_port = tmp_min_port;\n\t*max_port = tmp_max_port;\n\n\treturn 0;\n}\n\nint main(int argc, char **argv)\n{\n\tint min_port = 0, max_port = 0, vip2tnl_map_fd;\n\tconst char *optstr = \"i:a:p:s:d:m:T:P:FSNh\";\n\tunsigned char opt_flags[256] = {};\n\tstruct bpf_prog_info info = {};\n\t__u32 info_len = sizeof(info);\n\tunsigned int kill_after_s = 0;\n\tstruct iptnl_info tnl = {};\n\tstruct bpf_program *prog;\n\tstruct bpf_object *obj;\n\tstruct vip vip = {};\n\tchar filename[256];\n\tint opt, prog_fd;\n\tint i, err;\n\n\ttnl.family = AF_UNSPEC;\n\tvip.protocol = IPPROTO_TCP;\n\n\tfor (i = 0; i < strlen(optstr); i++)\n\t\tif (optstr[i] != 'h' && 'a' <= optstr[i] && optstr[i] <= 'z')\n\t\t\topt_flags[(unsigned char)optstr[i]] = 1;\n\n\twhile ((opt = getopt(argc, argv, optstr)) != -1) {\n\t\tunsigned short family;\n\t\tunsigned int *v6;\n\n\t\tswitch (opt) {\n\t\tcase 'i':\n\t\t\tifindex = if_nametoindex(optarg);\n\t\t\tif (!ifindex)\n\t\t\t\tifindex = atoi(optarg);\n\t\t\tbreak;\n\t\tcase 'a':\n\t\t\tvip.family = parse_ipstr(optarg, vip.daddr.v6);\n\t\t\tif (vip.family == AF_UNSPEC)\n\t\t\t\treturn 1;\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\tif (parse_ports(optarg, &min_port, &max_port))\n\t\t\t\treturn 1;\n\t\t\tbreak;\n\t\tcase 'P':\n\t\t\tvip.protocol = atoi(optarg);\n\t\t\tbreak;\n\t\tcase 's':\n\t\tcase 'd':\n\t\t\tif (opt == 's')\n\t\t\t\tv6 = tnl.saddr.v6;\n\t\t\telse\n\t\t\t\tv6 = tnl.daddr.v6;\n\n\t\t\tfamily = parse_ipstr(optarg, v6);\n\t\t\tif (family == AF_UNSPEC)\n\t\t\t\treturn 1;\n\t\t\tif (tnl.family == AF_UNSPEC) {\n\t\t\t\ttnl.family = family;\n\t\t\t} else if (tnl.family != family) {\n\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\"The IP version of the src and dst addresses used in the IP encapsulation does not match\\n\");\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'm':\n\t\t\tif (!ether_aton_r(optarg,\n\t\t\t\t\t  (struct ether_addr *)tnl.dmac)) {\n\t\t\t\tfprintf(stderr, \"Invalid mac address:%s\\n\",\n\t\t\t\t\toptarg);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'T':\n\t\t\tkill_after_s = atoi(optarg);\n\t\t\tbreak;\n\t\tcase 'S':\n\t\t\txdp_flags |= XDP_FLAGS_SKB_MODE;\n\t\t\tbreak;\n\t\tcase 'N':\n\t\t\t \n\t\t\tbreak;\n\t\tcase 'F':\n\t\t\txdp_flags &= ~XDP_FLAGS_UPDATE_IF_NOEXIST;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tusage(argv[0]);\n\t\t\treturn 1;\n\t\t}\n\t\topt_flags[opt] = 0;\n\t}\n\n\tif (!(xdp_flags & XDP_FLAGS_SKB_MODE))\n\t\txdp_flags |= XDP_FLAGS_DRV_MODE;\n\n\tfor (i = 0; i < strlen(optstr); i++) {\n\t\tif (opt_flags[(unsigned int)optstr[i]]) {\n\t\t\tfprintf(stderr, \"Missing argument -%c\\n\", optstr[i]);\n\t\t\tusage(argv[0]);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tif (!ifindex) {\n\t\tfprintf(stderr, \"Invalid ifname\\n\");\n\t\treturn 1;\n\t}\n\n\tsnprintf(filename, sizeof(filename), \"%s_kern.o\", argv[0]);\n\n\tobj = bpf_object__open_file(filename, NULL);\n\tif (libbpf_get_error(obj))\n\t\treturn 1;\n\n\tprog = bpf_object__next_program(obj, NULL);\n\tbpf_program__set_type(prog, BPF_PROG_TYPE_XDP);\n\n\terr = bpf_object__load(obj);\n\tif (err) {\n\t\tprintf(\"bpf_object__load(): %s\\n\", strerror(errno));\n\t\treturn 1;\n\t}\n\tprog_fd = bpf_program__fd(prog);\n\n\trxcnt_map_fd = bpf_object__find_map_fd_by_name(obj, \"rxcnt\");\n\tvip2tnl_map_fd = bpf_object__find_map_fd_by_name(obj, \"vip2tnl\");\n\tif (vip2tnl_map_fd < 0 || rxcnt_map_fd < 0) {\n\t\tprintf(\"bpf_object__find_map_fd_by_name failed\\n\");\n\t\treturn 1;\n\t}\n\n\tsignal(SIGINT, int_exit);\n\tsignal(SIGTERM, int_exit);\n\n\twhile (min_port <= max_port) {\n\t\tvip.dport = htons(min_port++);\n\t\tif (bpf_map_update_elem(vip2tnl_map_fd, &vip, &tnl,\n\t\t\t\t\tBPF_NOEXIST)) {\n\t\t\tperror(\"bpf_map_update_elem(&vip2tnl)\");\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tif (bpf_xdp_attach(ifindex, prog_fd, xdp_flags, NULL) < 0) {\n\t\tprintf(\"link set xdp fd failed\\n\");\n\t\treturn 1;\n\t}\n\n\terr = bpf_prog_get_info_by_fd(prog_fd, &info, &info_len);\n\tif (err) {\n\t\tprintf(\"can't get prog info - %s\\n\", strerror(errno));\n\t\treturn err;\n\t}\n\tprog_id = info.id;\n\n\tpoll_stats(kill_after_s);\n\n\tbpf_xdp_detach(ifindex, xdp_flags, NULL);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}