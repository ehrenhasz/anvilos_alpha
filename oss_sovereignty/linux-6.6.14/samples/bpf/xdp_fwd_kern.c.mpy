{
  "module_name": "xdp_fwd_kern.c",
  "hash_id": "3fe0a223987ad75d68addd4eedf55d5f95c1e4e36376e815055089f4ca48d3d5",
  "original_prompt": "Ingested from linux-6.6.14/samples/bpf/xdp_fwd_kern.c",
  "human_readable_source": "\n \n#define KBUILD_MODNAME \"foo\"\n#include <uapi/linux/bpf.h>\n#include <linux/in.h>\n#include <linux/if_ether.h>\n#include <linux/if_packet.h>\n#include <linux/if_vlan.h>\n#include <linux/ip.h>\n#include <linux/ipv6.h>\n\n#include <bpf/bpf_helpers.h>\n\n#define IPV6_FLOWINFO_MASK              cpu_to_be32(0x0FFFFFFF)\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_DEVMAP);\n\t__uint(key_size, sizeof(int));\n\t__uint(value_size, sizeof(int));\n\t__uint(max_entries, 64);\n} xdp_tx_ports SEC(\".maps\");\n\n \nstatic __always_inline int ip_decrease_ttl(struct iphdr *iph)\n{\n\tu32 check = (__force u32)iph->check;\n\n\tcheck += (__force u32)htons(0x0100);\n\tiph->check = (__force __sum16)(check + (check >= 0xFFFF));\n\treturn --iph->ttl;\n}\n\nstatic __always_inline int xdp_fwd_flags(struct xdp_md *ctx, u32 flags)\n{\n\tvoid *data_end = (void *)(long)ctx->data_end;\n\tvoid *data = (void *)(long)ctx->data;\n\tstruct bpf_fib_lookup fib_params;\n\tstruct ethhdr *eth = data;\n\tstruct ipv6hdr *ip6h;\n\tstruct iphdr *iph;\n\tu16 h_proto;\n\tu64 nh_off;\n\tint rc;\n\n\tnh_off = sizeof(*eth);\n\tif (data + nh_off > data_end)\n\t\treturn XDP_DROP;\n\n\t__builtin_memset(&fib_params, 0, sizeof(fib_params));\n\n\th_proto = eth->h_proto;\n\tif (h_proto == htons(ETH_P_IP)) {\n\t\tiph = data + nh_off;\n\n\t\tif (iph + 1 > data_end)\n\t\t\treturn XDP_DROP;\n\n\t\tif (iph->ttl <= 1)\n\t\t\treturn XDP_PASS;\n\n\t\tfib_params.family\t= AF_INET;\n\t\tfib_params.tos\t\t= iph->tos;\n\t\tfib_params.l4_protocol\t= iph->protocol;\n\t\tfib_params.sport\t= 0;\n\t\tfib_params.dport\t= 0;\n\t\tfib_params.tot_len\t= ntohs(iph->tot_len);\n\t\tfib_params.ipv4_src\t= iph->saddr;\n\t\tfib_params.ipv4_dst\t= iph->daddr;\n\t} else if (h_proto == htons(ETH_P_IPV6)) {\n\t\tstruct in6_addr *src = (struct in6_addr *) fib_params.ipv6_src;\n\t\tstruct in6_addr *dst = (struct in6_addr *) fib_params.ipv6_dst;\n\n\t\tip6h = data + nh_off;\n\t\tif (ip6h + 1 > data_end)\n\t\t\treturn XDP_DROP;\n\n\t\tif (ip6h->hop_limit <= 1)\n\t\t\treturn XDP_PASS;\n\n\t\tfib_params.family\t= AF_INET6;\n\t\tfib_params.flowinfo\t= *(__be32 *)ip6h & IPV6_FLOWINFO_MASK;\n\t\tfib_params.l4_protocol\t= ip6h->nexthdr;\n\t\tfib_params.sport\t= 0;\n\t\tfib_params.dport\t= 0;\n\t\tfib_params.tot_len\t= ntohs(ip6h->payload_len);\n\t\t*src\t\t\t= ip6h->saddr;\n\t\t*dst\t\t\t= ip6h->daddr;\n\t} else {\n\t\treturn XDP_PASS;\n\t}\n\n\tfib_params.ifindex = ctx->ingress_ifindex;\n\n\trc = bpf_fib_lookup(ctx, &fib_params, sizeof(fib_params), flags);\n\t \n\tif (rc == BPF_FIB_LKUP_RET_SUCCESS) {\n\t\t \n\t\tif (!bpf_map_lookup_elem(&xdp_tx_ports, &fib_params.ifindex))\n\t\t\treturn XDP_PASS;\n\n\t\tif (h_proto == htons(ETH_P_IP))\n\t\t\tip_decrease_ttl(iph);\n\t\telse if (h_proto == htons(ETH_P_IPV6))\n\t\t\tip6h->hop_limit--;\n\n\t\tmemcpy(eth->h_dest, fib_params.dmac, ETH_ALEN);\n\t\tmemcpy(eth->h_source, fib_params.smac, ETH_ALEN);\n\t\treturn bpf_redirect_map(&xdp_tx_ports, fib_params.ifindex, 0);\n\t}\n\n\treturn XDP_PASS;\n}\n\nSEC(\"xdp_fwd\")\nint xdp_fwd_prog(struct xdp_md *ctx)\n{\n\treturn xdp_fwd_flags(ctx, 0);\n}\n\nSEC(\"xdp_fwd_direct\")\nint xdp_fwd_direct_prog(struct xdp_md *ctx)\n{\n\treturn xdp_fwd_flags(ctx, BPF_FIB_LOOKUP_DIRECT);\n}\n\nchar _license[] SEC(\"license\") = \"GPL\";\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}