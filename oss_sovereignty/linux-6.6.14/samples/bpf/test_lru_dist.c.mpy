{
  "module_name": "test_lru_dist.c",
  "hash_id": "10956421410f2ee6059c31dfa6e6a1748d625204c6fd23bc6505f114554560e8",
  "original_prompt": "Ingested from linux-6.6.14/samples/bpf/test_lru_dist.c",
  "human_readable_source": "\n \n#define _GNU_SOURCE\n#include <linux/types.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <linux/bpf.h>\n#include <errno.h>\n#include <string.h>\n#include <assert.h>\n#include <sched.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <stdlib.h>\n#include <time.h>\n\n#include <bpf/bpf.h>\n#include \"bpf_util.h\"\n\n#define min(a, b) ((a) < (b) ? (a) : (b))\n#ifndef offsetof\n# define offsetof(TYPE, MEMBER)\t((size_t)&((TYPE *)0)->MEMBER)\n#endif\n#define container_of(ptr, type, member) ({\t\t\t\\\n\tconst typeof( ((type *)0)->member ) *__mptr = (ptr);\t\\\n\t(type *)( (char *)__mptr - offsetof(type,member) );})\n\nstatic int nr_cpus;\nstatic unsigned long long *dist_keys;\nstatic unsigned int dist_key_counts;\n\nstruct list_head {\n\tstruct list_head *next, *prev;\n};\n\nstatic inline void INIT_LIST_HEAD(struct list_head *list)\n{\n\tlist->next = list;\n\tlist->prev = list;\n}\n\nstatic inline void __list_add(struct list_head *new,\n\t\t\t      struct list_head *prev,\n\t\t\t      struct list_head *next)\n{\n\tnext->prev = new;\n\tnew->next = next;\n\tnew->prev = prev;\n\tprev->next = new;\n}\n\nstatic inline void list_add(struct list_head *new, struct list_head *head)\n{\n\t__list_add(new, head, head->next);\n}\n\nstatic inline void __list_del(struct list_head *prev, struct list_head *next)\n{\n\tnext->prev = prev;\n\tprev->next = next;\n}\n\nstatic inline void __list_del_entry(struct list_head *entry)\n{\n\t__list_del(entry->prev, entry->next);\n}\n\nstatic inline void list_move(struct list_head *list, struct list_head *head)\n{\n\t__list_del_entry(list);\n\tlist_add(list, head);\n}\n\n#define list_entry(ptr, type, member) \\\n\tcontainer_of(ptr, type, member)\n\n#define list_last_entry(ptr, type, member) \\\n\tlist_entry((ptr)->prev, type, member)\n\nstruct pfect_lru_node {\n\tstruct list_head list;\n\tunsigned long long key;\n};\n\nstruct pfect_lru {\n\tstruct list_head list;\n\tstruct pfect_lru_node *free_nodes;\n\tunsigned int cur_size;\n\tunsigned int lru_size;\n\tunsigned int nr_unique;\n\tunsigned int nr_misses;\n\tunsigned int total;\n\tint map_fd;\n};\n\nstatic void pfect_lru_init(struct pfect_lru *lru, unsigned int lru_size,\n\t\t\t   unsigned int nr_possible_elems)\n{\n\tlru->map_fd = bpf_map_create(BPF_MAP_TYPE_HASH, NULL,\n\t\t\t\t     sizeof(unsigned long long),\n\t\t\t\t     sizeof(struct pfect_lru_node *),\n\t\t\t\t     nr_possible_elems, NULL);\n\tassert(lru->map_fd != -1);\n\n\tlru->free_nodes = malloc(lru_size * sizeof(struct pfect_lru_node));\n\tassert(lru->free_nodes);\n\n\tINIT_LIST_HEAD(&lru->list);\n\tlru->cur_size = 0;\n\tlru->lru_size = lru_size;\n\tlru->nr_unique = lru->nr_misses = lru->total = 0;\n}\n\nstatic void pfect_lru_destroy(struct pfect_lru *lru)\n{\n\tclose(lru->map_fd);\n\tfree(lru->free_nodes);\n}\n\nstatic int pfect_lru_lookup_or_insert(struct pfect_lru *lru,\n\t\t\t\t      unsigned long long key)\n{\n\tstruct pfect_lru_node *node = NULL;\n\tint seen = 0;\n\n\tlru->total++;\n\tif (!bpf_map_lookup_elem(lru->map_fd, &key, &node)) {\n\t\tif (node) {\n\t\t\tlist_move(&node->list, &lru->list);\n\t\t\treturn 1;\n\t\t}\n\t\tseen = 1;\n\t}\n\n\tif (lru->cur_size < lru->lru_size) {\n\t\tnode =  &lru->free_nodes[lru->cur_size++];\n\t\tINIT_LIST_HEAD(&node->list);\n\t} else {\n\t\tstruct pfect_lru_node *null_node = NULL;\n\n\t\tnode = list_last_entry(&lru->list,\n\t\t\t\t       struct pfect_lru_node,\n\t\t\t\t       list);\n\t\tbpf_map_update_elem(lru->map_fd, &node->key, &null_node, BPF_EXIST);\n\t}\n\n\tnode->key = key;\n\tlist_move(&node->list, &lru->list);\n\n\tlru->nr_misses++;\n\tif (seen) {\n\t\tassert(!bpf_map_update_elem(lru->map_fd, &key, &node, BPF_EXIST));\n\t} else {\n\t\tlru->nr_unique++;\n\t\tassert(!bpf_map_update_elem(lru->map_fd, &key, &node, BPF_NOEXIST));\n\t}\n\n\treturn seen;\n}\n\nstatic unsigned int read_keys(const char *dist_file,\n\t\t\t      unsigned long long **keys)\n{\n\tstruct stat fst;\n\tunsigned long long *retkeys;\n\tunsigned int counts = 0;\n\tint dist_fd;\n\tchar *b, *l;\n\tint i;\n\n\tdist_fd = open(dist_file, 0);\n\tassert(dist_fd != -1);\n\n\tassert(fstat(dist_fd, &fst) == 0);\n\tb = malloc(fst.st_size);\n\tassert(b);\n\n\tassert(read(dist_fd, b, fst.st_size) == fst.st_size);\n\tclose(dist_fd);\n\tfor (i = 0; i < fst.st_size; i++) {\n\t\tif (b[i] == '\\n')\n\t\t\tcounts++;\n\t}\n\tcounts++;  \n\n\tretkeys = malloc(counts * sizeof(unsigned long long));\n\tassert(retkeys);\n\n\tcounts = 0;\n\tfor (l = strtok(b, \"\\n\"); l; l = strtok(NULL, \"\\n\"))\n\t\tretkeys[counts++] = strtoull(l, NULL, 10);\n\tfree(b);\n\n\t*keys = retkeys;\n\n\treturn counts;\n}\n\nstatic int create_map(int map_type, int map_flags, unsigned int size)\n{\n\tLIBBPF_OPTS(bpf_map_create_opts, opts,\n\t\t.map_flags = map_flags,\n\t);\n\tint map_fd;\n\n\tmap_fd = bpf_map_create(map_type, NULL, sizeof(unsigned long long),\n\t\t\t\tsizeof(unsigned long long), size, &opts);\n\n\tif (map_fd == -1)\n\t\tperror(\"bpf_create_map\");\n\n\treturn map_fd;\n}\n\nstatic int sched_next_online(int pid, int next_to_try)\n{\n\tcpu_set_t cpuset;\n\n\tif (next_to_try == nr_cpus)\n\t\treturn -1;\n\n\twhile (next_to_try < nr_cpus) {\n\t\tCPU_ZERO(&cpuset);\n\t\tCPU_SET(next_to_try++, &cpuset);\n\t\tif (!sched_setaffinity(pid, sizeof(cpuset), &cpuset))\n\t\t\tbreak;\n\t}\n\n\treturn next_to_try;\n}\n\nstatic void run_parallel(unsigned int tasks, void (*fn)(int i, void *data),\n\t\t\t void *data)\n{\n\tint next_sched_cpu = 0;\n\tpid_t pid[tasks];\n\tint i;\n\n\tfor (i = 0; i < tasks; i++) {\n\t\tpid[i] = fork();\n\t\tif (pid[i] == 0) {\n\t\t\tnext_sched_cpu = sched_next_online(0, next_sched_cpu);\n\t\t\tfn(i, data);\n\t\t\texit(0);\n\t\t} else if (pid[i] == -1) {\n\t\t\tprintf(\"couldn't spawn #%d process\\n\", i);\n\t\t\texit(1);\n\t\t}\n\t\t \n\t\tnext_sched_cpu = sched_next_online(pid[i], next_sched_cpu);\n\t}\n\tfor (i = 0; i < tasks; i++) {\n\t\tint status;\n\n\t\tassert(waitpid(pid[i], &status, 0) == pid[i]);\n\t\tassert(status == 0);\n\t}\n}\n\nstatic void do_test_lru_dist(int task, void *data)\n{\n\tunsigned int nr_misses = 0;\n\tstruct pfect_lru pfect_lru;\n\tunsigned long long key, value = 1234;\n\tunsigned int i;\n\n\tunsigned int lru_map_fd = ((unsigned int *)data)[0];\n\tunsigned int lru_size = ((unsigned int *)data)[1];\n\tunsigned long long key_offset = task * dist_key_counts;\n\n\tpfect_lru_init(&pfect_lru, lru_size, dist_key_counts);\n\n\tfor (i = 0; i < dist_key_counts; i++) {\n\t\tkey = dist_keys[i] + key_offset;\n\n\t\tpfect_lru_lookup_or_insert(&pfect_lru, key);\n\n\t\tif (!bpf_map_lookup_elem(lru_map_fd, &key, &value))\n\t\t\tcontinue;\n\n\t\tif (bpf_map_update_elem(lru_map_fd, &key, &value, BPF_NOEXIST)) {\n\t\t\tprintf(\"bpf_map_update_elem(lru_map_fd, %llu): errno:%d\\n\",\n\t\t\t       key, errno);\n\t\t\tassert(0);\n\t\t}\n\n\t\tnr_misses++;\n\t}\n\n\tprintf(\"    task:%d BPF LRU: nr_unique:%u(/%u) nr_misses:%u(/%u)\\n\",\n\t       task, pfect_lru.nr_unique, dist_key_counts, nr_misses,\n\t       dist_key_counts);\n\tprintf(\"    task:%d Perfect LRU: nr_unique:%u(/%u) nr_misses:%u(/%u)\\n\",\n\t       task, pfect_lru.nr_unique, pfect_lru.total,\n\t       pfect_lru.nr_misses, pfect_lru.total);\n\n\tpfect_lru_destroy(&pfect_lru);\n\tclose(lru_map_fd);\n}\n\nstatic void test_parallel_lru_dist(int map_type, int map_flags,\n\t\t\t\t   int nr_tasks, unsigned int lru_size)\n{\n\tint child_data[2];\n\tint lru_map_fd;\n\n\tprintf(\"%s (map_type:%d map_flags:0x%X):\\n\", __func__, map_type,\n\t       map_flags);\n\n\tif (map_flags & BPF_F_NO_COMMON_LRU)\n\t\tlru_map_fd = create_map(map_type, map_flags,\n\t\t\t\t\tnr_cpus * lru_size);\n\telse\n\t\tlru_map_fd = create_map(map_type, map_flags,\n\t\t\t\t\tnr_tasks * lru_size);\n\tassert(lru_map_fd != -1);\n\n\tchild_data[0] = lru_map_fd;\n\tchild_data[1] = lru_size;\n\n\trun_parallel(nr_tasks, do_test_lru_dist, child_data);\n\n\tclose(lru_map_fd);\n}\n\nstatic void test_lru_loss0(int map_type, int map_flags)\n{\n\tunsigned long long key, value[nr_cpus];\n\tunsigned int old_unused_losses = 0;\n\tunsigned int new_unused_losses = 0;\n\tunsigned int used_losses = 0;\n\tint map_fd;\n\n\tprintf(\"%s (map_type:%d map_flags:0x%X): \", __func__, map_type,\n\t       map_flags);\n\n\tassert(sched_next_online(0, 0) != -1);\n\n\tif (map_flags & BPF_F_NO_COMMON_LRU)\n\t\tmap_fd = create_map(map_type, map_flags, 900 * nr_cpus);\n\telse\n\t\tmap_fd = create_map(map_type, map_flags, 900);\n\n\tassert(map_fd != -1);\n\n\tvalue[0] = 1234;\n\n\tfor (key = 1; key <= 1000; key++) {\n\t\tint start_key, end_key;\n\n\t\tassert(bpf_map_update_elem(map_fd, &key, value, BPF_NOEXIST) == 0);\n\n\t\tstart_key = 101;\n\t\tend_key = min(key, 900);\n\n\t\twhile (start_key <= end_key) {\n\t\t\tbpf_map_lookup_elem(map_fd, &start_key, value);\n\t\t\tstart_key++;\n\t\t}\n\t}\n\n\tfor (key = 1; key <= 1000; key++) {\n\t\tif (bpf_map_lookup_elem(map_fd, &key, value)) {\n\t\t\tif (key <= 100)\n\t\t\t\told_unused_losses++;\n\t\t\telse if (key <= 900)\n\t\t\t\tused_losses++;\n\t\t\telse\n\t\t\t\tnew_unused_losses++;\n\t\t}\n\t}\n\n\tclose(map_fd);\n\n\tprintf(\"older-elem-losses:%d(/100) active-elem-losses:%d(/800) \"\n\t       \"newer-elem-losses:%d(/100)\\n\",\n\t       old_unused_losses, used_losses, new_unused_losses);\n}\n\nstatic void test_lru_loss1(int map_type, int map_flags)\n{\n\tunsigned long long key, value[nr_cpus];\n\tint map_fd;\n\tunsigned int nr_losses = 0;\n\n\tprintf(\"%s (map_type:%d map_flags:0x%X): \", __func__, map_type,\n\t       map_flags);\n\n\tassert(sched_next_online(0, 0) != -1);\n\n\tif (map_flags & BPF_F_NO_COMMON_LRU)\n\t\tmap_fd = create_map(map_type, map_flags, 1000 * nr_cpus);\n\telse\n\t\tmap_fd = create_map(map_type, map_flags, 1000);\n\n\tassert(map_fd != -1);\n\n\tvalue[0] = 1234;\n\n\tfor (key = 1; key <= 1000; key++)\n\t\tassert(!bpf_map_update_elem(map_fd, &key, value, BPF_NOEXIST));\n\n\tfor (key = 1; key <= 1000; key++) {\n\t\tif (bpf_map_lookup_elem(map_fd, &key, value))\n\t\t\tnr_losses++;\n\t}\n\n\tclose(map_fd);\n\n\tprintf(\"nr_losses:%d(/1000)\\n\", nr_losses);\n}\n\nstatic void do_test_parallel_lru_loss(int task, void *data)\n{\n\tconst unsigned int nr_stable_elems = 1000;\n\tconst unsigned int nr_repeats = 100000;\n\n\tint map_fd = *(int *)data;\n\tunsigned long long stable_base;\n\tunsigned long long key, value[nr_cpus];\n\tunsigned long long next_ins_key;\n\tunsigned int nr_losses = 0;\n\tunsigned int i;\n\n\tstable_base = task * nr_repeats * 2 + 1;\n\tnext_ins_key = stable_base;\n\tvalue[0] = 1234;\n\tfor (i = 0; i < nr_stable_elems; i++) {\n\t\tassert(bpf_map_update_elem(map_fd, &next_ins_key, value,\n\t\t\t\t       BPF_NOEXIST) == 0);\n\t\tnext_ins_key++;\n\t}\n\n\tfor (i = 0; i < nr_repeats; i++) {\n\t\tint rn;\n\n\t\trn = rand();\n\n\t\tif (rn % 10) {\n\t\t\tkey = rn % nr_stable_elems + stable_base;\n\t\t\tbpf_map_lookup_elem(map_fd, &key, value);\n\t\t} else {\n\t\t\tbpf_map_update_elem(map_fd, &next_ins_key, value,\n\t\t\t\t\tBPF_NOEXIST);\n\t\t\tnext_ins_key++;\n\t\t}\n\t}\n\n\tkey = stable_base;\n\tfor (i = 0; i < nr_stable_elems; i++) {\n\t\tif (bpf_map_lookup_elem(map_fd, &key, value))\n\t\t\tnr_losses++;\n\t\tkey++;\n\t}\n\n\tprintf(\"    task:%d nr_losses:%u\\n\", task, nr_losses);\n}\n\nstatic void test_parallel_lru_loss(int map_type, int map_flags, int nr_tasks)\n{\n\tint map_fd;\n\n\tprintf(\"%s (map_type:%d map_flags:0x%X):\\n\", __func__, map_type,\n\t       map_flags);\n\n\t \n\tif (map_flags & BPF_F_NO_COMMON_LRU)\n\t\tmap_fd = create_map(map_type, map_flags,\n\t\t\t\t    nr_cpus * (1000 + 200));\n\telse\n\t\tmap_fd = create_map(map_type, map_flags,\n\t\t\t\t    nr_tasks * (1000 + 200));\n\n\tassert(map_fd != -1);\n\n\trun_parallel(nr_tasks, do_test_parallel_lru_loss, &map_fd);\n\n\tclose(map_fd);\n}\n\nint main(int argc, char **argv)\n{\n\tint map_flags[] = {0, BPF_F_NO_COMMON_LRU};\n\tconst char *dist_file;\n\tint nr_tasks = 1;\n\tint lru_size;\n\tint f;\n\n\tif (argc < 4) {\n\t\tprintf(\"Usage: %s <dist-file> <lru-size> <nr-tasks>\\n\",\n\t\t       argv[0]);\n\t\treturn -1;\n\t}\n\n\tdist_file = argv[1];\n\tlru_size = atoi(argv[2]);\n\tnr_tasks = atoi(argv[3]);\n\n\tsetbuf(stdout, NULL);\n\n\tsrand(time(NULL));\n\n\tnr_cpus = bpf_num_possible_cpus();\n\tassert(nr_cpus != -1);\n\tprintf(\"nr_cpus:%d\\n\\n\", nr_cpus);\n\n\tnr_tasks = min(nr_tasks, nr_cpus);\n\n\tdist_key_counts = read_keys(dist_file, &dist_keys);\n\tif (!dist_key_counts) {\n\t\tprintf(\"%s has no key\\n\", dist_file);\n\t\treturn -1;\n\t}\n\n\tfor (f = 0; f < ARRAY_SIZE(map_flags); f++) {\n\t\ttest_lru_loss0(BPF_MAP_TYPE_LRU_HASH, map_flags[f]);\n\t\ttest_lru_loss1(BPF_MAP_TYPE_LRU_HASH, map_flags[f]);\n\t\ttest_parallel_lru_loss(BPF_MAP_TYPE_LRU_HASH, map_flags[f],\n\t\t\t\t       nr_tasks);\n\t\ttest_parallel_lru_dist(BPF_MAP_TYPE_LRU_HASH, map_flags[f],\n\t\t\t\t       nr_tasks, lru_size);\n\t\tprintf(\"\\n\");\n\t}\n\n\tfree(dist_keys);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}