{
  "module_name": "tracex4_user.c",
  "hash_id": "4b63b409df332d367b926a3bc329edeb64f0516c1986068f78e8ab13b15a6e21",
  "original_prompt": "Ingested from linux-6.6.14/samples/bpf/tracex4_user.c",
  "human_readable_source": "\n \n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <unistd.h>\n#include <stdbool.h>\n#include <string.h>\n#include <time.h>\n\n#include <bpf/bpf.h>\n#include <bpf/libbpf.h>\n\nstruct pair {\n\tlong long val;\n\t__u64 ip;\n};\n\nstatic __u64 time_get_ns(void)\n{\n\tstruct timespec ts;\n\n\tclock_gettime(CLOCK_MONOTONIC, &ts);\n\treturn ts.tv_sec * 1000000000ull + ts.tv_nsec;\n}\n\nstatic void print_old_objects(int fd)\n{\n\tlong long val = time_get_ns();\n\t__u64 key, next_key;\n\tstruct pair v;\n\n\tkey = write(1, \"\\e[1;1H\\e[2J\", 11);  \n\n\tkey = -1;\n\twhile (bpf_map_get_next_key(fd, &key, &next_key) == 0) {\n\t\tbpf_map_lookup_elem(fd, &next_key, &v);\n\t\tkey = next_key;\n\t\tif (val - v.val < 1000000000ll)\n\t\t\t \n\t\t\tcontinue;\n\t\tprintf(\"obj 0x%llx is %2lldsec old was allocated at ip %llx\\n\",\n\t\t       next_key, (val - v.val) / 1000000000ll, v.ip);\n\t}\n}\n\nint main(int ac, char **argv)\n{\n\tstruct bpf_link *links[2];\n\tstruct bpf_program *prog;\n\tstruct bpf_object *obj;\n\tchar filename[256];\n\tint map_fd, j = 0;\n\n\tsnprintf(filename, sizeof(filename), \"%s.bpf.o\", argv[0]);\n\tobj = bpf_object__open_file(filename, NULL);\n\tif (libbpf_get_error(obj)) {\n\t\tfprintf(stderr, \"ERROR: opening BPF object file failed\\n\");\n\t\treturn 0;\n\t}\n\n\t \n\tif (bpf_object__load(obj)) {\n\t\tfprintf(stderr, \"ERROR: loading BPF object file failed\\n\");\n\t\tgoto cleanup;\n\t}\n\n\tmap_fd = bpf_object__find_map_fd_by_name(obj, \"my_map\");\n\tif (map_fd < 0) {\n\t\tfprintf(stderr, \"ERROR: finding a map in obj file failed\\n\");\n\t\tgoto cleanup;\n\t}\n\n\tbpf_object__for_each_program(prog, obj) {\n\t\tlinks[j] = bpf_program__attach(prog);\n\t\tif (libbpf_get_error(links[j])) {\n\t\t\tfprintf(stderr, \"ERROR: bpf_program__attach failed\\n\");\n\t\t\tlinks[j] = NULL;\n\t\t\tgoto cleanup;\n\t\t}\n\t\tj++;\n\t}\n\n\twhile (1) {\n\t\tprint_old_objects(map_fd);\n\t\tsleep(1);\n\t}\n\ncleanup:\n\tfor (j--; j >= 0; j--)\n\t\tbpf_link__destroy(links[j]);\n\n\tbpf_object__close(obj);\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}