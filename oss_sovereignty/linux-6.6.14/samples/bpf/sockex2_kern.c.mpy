{
  "module_name": "sockex2_kern.c",
  "hash_id": "010fdb820f306c0a8038c5d1ab1abdd8e931aa2ab0181b0421ba47c5bf210a6e",
  "original_prompt": "Ingested from linux-6.6.14/samples/bpf/sockex2_kern.c",
  "human_readable_source": "#include <uapi/linux/bpf.h>\n#include <uapi/linux/in.h>\n#include <uapi/linux/if.h>\n#include <uapi/linux/if_ether.h>\n#include <uapi/linux/ip.h>\n#include <uapi/linux/ipv6.h>\n#include <uapi/linux/if_tunnel.h>\n#include <bpf/bpf_helpers.h>\n#include \"bpf_legacy.h\"\n#define IP_MF\t\t0x2000\n#define IP_OFFSET\t0x1FFF\n\nstruct vlan_hdr {\n\t__be16 h_vlan_TCI;\n\t__be16 h_vlan_encapsulated_proto;\n};\n\nstruct flow_key_record {\n\t__be32 src;\n\t__be32 dst;\n\tunion {\n\t\t__be32 ports;\n\t\t__be16 port16[2];\n\t};\n\t__u16 thoff;\n\t__u8 ip_proto;\n};\n\nstatic inline int proto_ports_offset(__u64 proto)\n{\n\tswitch (proto) {\n\tcase IPPROTO_TCP:\n\tcase IPPROTO_UDP:\n\tcase IPPROTO_DCCP:\n\tcase IPPROTO_ESP:\n\tcase IPPROTO_SCTP:\n\tcase IPPROTO_UDPLITE:\n\t\treturn 0;\n\tcase IPPROTO_AH:\n\t\treturn 4;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic inline int ip_is_fragment(struct __sk_buff *ctx, __u64 nhoff)\n{\n\treturn load_half(ctx, nhoff + offsetof(struct iphdr, frag_off))\n\t\t& (IP_MF | IP_OFFSET);\n}\n\nstatic inline __u32 ipv6_addr_hash(struct __sk_buff *ctx, __u64 off)\n{\n\t__u64 w0 = load_word(ctx, off);\n\t__u64 w1 = load_word(ctx, off + 4);\n\t__u64 w2 = load_word(ctx, off + 8);\n\t__u64 w3 = load_word(ctx, off + 12);\n\n\treturn (__u32)(w0 ^ w1 ^ w2 ^ w3);\n}\n\nstatic inline __u64 parse_ip(struct __sk_buff *skb, __u64 nhoff, __u64 *ip_proto,\n\t\t\t     struct flow_key_record *flow)\n{\n\t__u64 verlen;\n\n\tif (unlikely(ip_is_fragment(skb, nhoff)))\n\t\t*ip_proto = 0;\n\telse\n\t\t*ip_proto = load_byte(skb, nhoff + offsetof(struct iphdr, protocol));\n\n\tif (*ip_proto != IPPROTO_GRE) {\n\t\tflow->src = load_word(skb, nhoff + offsetof(struct iphdr, saddr));\n\t\tflow->dst = load_word(skb, nhoff + offsetof(struct iphdr, daddr));\n\t}\n\n\tverlen = load_byte(skb, nhoff + 0 );\n\tif (likely(verlen == 0x45))\n\t\tnhoff += 20;\n\telse\n\t\tnhoff += (verlen & 0xF) << 2;\n\n\treturn nhoff;\n}\n\nstatic inline __u64 parse_ipv6(struct __sk_buff *skb, __u64 nhoff, __u64 *ip_proto,\n\t\t\t       struct flow_key_record *flow)\n{\n\t*ip_proto = load_byte(skb,\n\t\t\t      nhoff + offsetof(struct ipv6hdr, nexthdr));\n\tflow->src = ipv6_addr_hash(skb,\n\t\t\t\t   nhoff + offsetof(struct ipv6hdr, saddr));\n\tflow->dst = ipv6_addr_hash(skb,\n\t\t\t\t   nhoff + offsetof(struct ipv6hdr, daddr));\n\tnhoff += sizeof(struct ipv6hdr);\n\n\treturn nhoff;\n}\n\nstatic inline bool flow_dissector(struct __sk_buff *skb,\n\t\t\t\t  struct flow_key_record *flow)\n{\n\t__u64 nhoff = ETH_HLEN;\n\t__u64 ip_proto;\n\t__u64 proto = load_half(skb, 12);\n\tint poff;\n\n\tif (proto == ETH_P_8021AD) {\n\t\tproto = load_half(skb, nhoff + offsetof(struct vlan_hdr,\n\t\t\t\t\t\t\th_vlan_encapsulated_proto));\n\t\tnhoff += sizeof(struct vlan_hdr);\n\t}\n\n\tif (proto == ETH_P_8021Q) {\n\t\tproto = load_half(skb, nhoff + offsetof(struct vlan_hdr,\n\t\t\t\t\t\t\th_vlan_encapsulated_proto));\n\t\tnhoff += sizeof(struct vlan_hdr);\n\t}\n\n\tif (likely(proto == ETH_P_IP))\n\t\tnhoff = parse_ip(skb, nhoff, &ip_proto, flow);\n\telse if (proto == ETH_P_IPV6)\n\t\tnhoff = parse_ipv6(skb, nhoff, &ip_proto, flow);\n\telse\n\t\treturn false;\n\n\tswitch (ip_proto) {\n\tcase IPPROTO_GRE: {\n\t\tstruct gre_hdr {\n\t\t\t__be16 flags;\n\t\t\t__be16 proto;\n\t\t};\n\n\t\t__u64 gre_flags = load_half(skb,\n\t\t\t\t\t    nhoff + offsetof(struct gre_hdr, flags));\n\t\t__u64 gre_proto = load_half(skb,\n\t\t\t\t\t    nhoff + offsetof(struct gre_hdr, proto));\n\n\t\tif (gre_flags & (GRE_VERSION|GRE_ROUTING))\n\t\t\tbreak;\n\n\t\tproto = gre_proto;\n\t\tnhoff += 4;\n\t\tif (gre_flags & GRE_CSUM)\n\t\t\tnhoff += 4;\n\t\tif (gre_flags & GRE_KEY)\n\t\t\tnhoff += 4;\n\t\tif (gre_flags & GRE_SEQ)\n\t\t\tnhoff += 4;\n\n\t\tif (proto == ETH_P_8021Q) {\n\t\t\tproto = load_half(skb,\n\t\t\t\t\t  nhoff + offsetof(struct vlan_hdr,\n\t\t\t\t\t\t\t   h_vlan_encapsulated_proto));\n\t\t\tnhoff += sizeof(struct vlan_hdr);\n\t\t}\n\n\t\tif (proto == ETH_P_IP)\n\t\t\tnhoff = parse_ip(skb, nhoff, &ip_proto, flow);\n\t\telse if (proto == ETH_P_IPV6)\n\t\t\tnhoff = parse_ipv6(skb, nhoff, &ip_proto, flow);\n\t\telse\n\t\t\treturn false;\n\t\tbreak;\n\t}\n\tcase IPPROTO_IPIP:\n\t\tnhoff = parse_ip(skb, nhoff, &ip_proto, flow);\n\t\tbreak;\n\tcase IPPROTO_IPV6:\n\t\tnhoff = parse_ipv6(skb, nhoff, &ip_proto, flow);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tflow->ip_proto = ip_proto;\n\tpoff = proto_ports_offset(ip_proto);\n\tif (poff >= 0) {\n\t\tnhoff += poff;\n\t\tflow->ports = load_word(skb, nhoff);\n\t}\n\n\tflow->thoff = (__u16) nhoff;\n\n\treturn true;\n}\n\nstruct pair {\n\tlong packets;\n\tlong bytes;\n};\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_HASH);\n\t__type(key, __be32);\n\t__type(value, struct pair);\n\t__uint(max_entries, 1024);\n} hash_map SEC(\".maps\");\n\nSEC(\"socket2\")\nint bpf_prog2(struct __sk_buff *skb)\n{\n\tstruct flow_key_record flow = {};\n\tstruct pair *value;\n\tu32 key;\n\n\tif (!flow_dissector(skb, &flow))\n\t\treturn 0;\n\n\tkey = flow.dst;\n\tvalue = bpf_map_lookup_elem(&hash_map, &key);\n\tif (value) {\n\t\t__sync_fetch_and_add(&value->packets, 1);\n\t\t__sync_fetch_and_add(&value->bytes, skb->len);\n\t} else {\n\t\tstruct pair val = {1, skb->len};\n\n\t\tbpf_map_update_elem(&hash_map, &key, &val, BPF_ANY);\n\t}\n\treturn 0;\n}\n\nchar _license[] SEC(\"license\") = \"GPL\";\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}