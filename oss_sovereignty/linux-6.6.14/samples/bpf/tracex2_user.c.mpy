{
  "module_name": "tracex2_user.c",
  "hash_id": "6a77b923f9cd57f03cdb11721da0db002cbade5480423d514d17142de3455401",
  "original_prompt": "Ingested from linux-6.6.14/samples/bpf/tracex2_user.c",
  "human_readable_source": "\n#include <stdio.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <string.h>\n\n#include <bpf/bpf.h>\n#include <bpf/libbpf.h>\n#include \"bpf_util.h\"\n\n#define MAX_INDEX\t64\n#define MAX_STARS\t38\n\n \nstatic int map_fd[2];\n\nstatic void stars(char *str, long val, long max, int width)\n{\n\tint i;\n\n\tfor (i = 0; i < (width * val / max) - 1 && i < width - 1; i++)\n\t\tstr[i] = '*';\n\tif (val > max)\n\t\tstr[i - 1] = '+';\n\tstr[i] = '\\0';\n}\n\nstruct task {\n\tchar comm[16];\n\t__u64 pid_tgid;\n\t__u64 uid_gid;\n};\n\nstruct hist_key {\n\tstruct task t;\n\t__u32 index;\n};\n\n#define SIZE sizeof(struct task)\n\nstatic void print_hist_for_pid(int fd, void *task)\n{\n\tunsigned int nr_cpus = bpf_num_possible_cpus();\n\tstruct hist_key key = {}, next_key;\n\tlong values[nr_cpus];\n\tchar starstr[MAX_STARS];\n\tlong value;\n\tlong data[MAX_INDEX] = {};\n\tint max_ind = -1;\n\tlong max_value = 0;\n\tint i, ind;\n\n\twhile (bpf_map_get_next_key(fd, &key, &next_key) == 0) {\n\t\tif (memcmp(&next_key, task, SIZE)) {\n\t\t\tkey = next_key;\n\t\t\tcontinue;\n\t\t}\n\t\tbpf_map_lookup_elem(fd, &next_key, values);\n\t\tvalue = 0;\n\t\tfor (i = 0; i < nr_cpus; i++)\n\t\t\tvalue += values[i];\n\t\tind = next_key.index;\n\t\tdata[ind] = value;\n\t\tif (value && ind > max_ind)\n\t\t\tmax_ind = ind;\n\t\tif (value > max_value)\n\t\t\tmax_value = value;\n\t\tkey = next_key;\n\t}\n\n\tprintf(\"           syscall write() stats\\n\");\n\tprintf(\"     byte_size       : count     distribution\\n\");\n\tfor (i = 1; i <= max_ind + 1; i++) {\n\t\tstars(starstr, data[i - 1], max_value, MAX_STARS);\n\t\tprintf(\"%8ld -> %-8ld : %-8ld |%-*s|\\n\",\n\t\t       (1l << i) >> 1, (1l << i) - 1, data[i - 1],\n\t\t       MAX_STARS, starstr);\n\t}\n}\n\nstatic void print_hist(int fd)\n{\n\tstruct hist_key key = {}, next_key;\n\tstatic struct task tasks[1024];\n\tint task_cnt = 0;\n\tint i;\n\n\twhile (bpf_map_get_next_key(fd, &key, &next_key) == 0) {\n\t\tint found = 0;\n\n\t\tfor (i = 0; i < task_cnt; i++)\n\t\t\tif (memcmp(&tasks[i], &next_key, SIZE) == 0)\n\t\t\t\tfound = 1;\n\t\tif (!found)\n\t\t\tmemcpy(&tasks[task_cnt++], &next_key, SIZE);\n\t\tkey = next_key;\n\t}\n\n\tfor (i = 0; i < task_cnt; i++) {\n\t\tprintf(\"\\npid %d cmd %s uid %d\\n\",\n\t\t       (__u32) tasks[i].pid_tgid,\n\t\t       tasks[i].comm,\n\t\t       (__u32) tasks[i].uid_gid);\n\t\tprint_hist_for_pid(fd, &tasks[i]);\n\t}\n\n}\n\nstatic void int_exit(int sig)\n{\n\tprint_hist(map_fd[1]);\n\texit(0);\n}\n\nint main(int ac, char **argv)\n{\n\tlong key, next_key, value;\n\tstruct bpf_link *links[2];\n\tstruct bpf_program *prog;\n\tstruct bpf_object *obj;\n\tchar filename[256];\n\tint i, j = 0;\n\tFILE *f;\n\n\tsnprintf(filename, sizeof(filename), \"%s.bpf.o\", argv[0]);\n\tobj = bpf_object__open_file(filename, NULL);\n\tif (libbpf_get_error(obj)) {\n\t\tfprintf(stderr, \"ERROR: opening BPF object file failed\\n\");\n\t\treturn 0;\n\t}\n\n\t \n\tif (bpf_object__load(obj)) {\n\t\tfprintf(stderr, \"ERROR: loading BPF object file failed\\n\");\n\t\tgoto cleanup;\n\t}\n\n\tmap_fd[0] = bpf_object__find_map_fd_by_name(obj, \"my_map\");\n\tmap_fd[1] = bpf_object__find_map_fd_by_name(obj, \"my_hist_map\");\n\tif (map_fd[0] < 0 || map_fd[1] < 0) {\n\t\tfprintf(stderr, \"ERROR: finding a map in obj file failed\\n\");\n\t\tgoto cleanup;\n\t}\n\n\tsignal(SIGINT, int_exit);\n\tsignal(SIGTERM, int_exit);\n\n\t \n\tf = popen(\"ping -4 -c5 localhost\", \"r\");\n\t(void) f;\n\n\t \n\tf = popen(\"dd if=/dev/zero of=/dev/null count=5000000\", \"r\");\n\t(void) f;\n\n\tbpf_object__for_each_program(prog, obj) {\n\t\tlinks[j] = bpf_program__attach(prog);\n\t\tif (libbpf_get_error(links[j])) {\n\t\t\tfprintf(stderr, \"ERROR: bpf_program__attach failed\\n\");\n\t\t\tlinks[j] = NULL;\n\t\t\tgoto cleanup;\n\t\t}\n\t\tj++;\n\t}\n\n\tfor (i = 0; i < 5; i++) {\n\t\tkey = 0;\n\t\twhile (bpf_map_get_next_key(map_fd[0], &key, &next_key) == 0) {\n\t\t\tbpf_map_lookup_elem(map_fd[0], &next_key, &value);\n\t\t\tprintf(\"location 0x%lx count %ld\\n\", next_key, value);\n\t\t\tkey = next_key;\n\t\t}\n\t\tif (key)\n\t\t\tprintf(\"\\n\");\n\t\tsleep(1);\n\t}\n\tprint_hist(map_fd[1]);\n\ncleanup:\n\tfor (j--; j >= 0; j--)\n\t\tbpf_link__destroy(links[j]);\n\n\tbpf_object__close(obj);\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}