{
  "module_name": "xdp_router_ipv4.bpf.c",
  "hash_id": "f0d079eb0b2678565fa5d8d11c5243d82efccb114ecc0fafe6324f577a3e5801",
  "original_prompt": "Ingested from linux-6.6.14/samples/bpf/xdp_router_ipv4.bpf.c",
  "human_readable_source": " \n\n#include \"vmlinux.h\"\n#include \"xdp_sample.bpf.h\"\n#include \"xdp_sample_shared.h\"\n\n#define ETH_ALEN\t6\n#define ETH_P_8021Q\t0x8100\n#define ETH_P_8021AD\t0x88A8\n\nstruct trie_value {\n\t__u8 prefix[4];\n\t__be64 value;\n\tint ifindex;\n\tint metric;\n\t__be32 gw;\n};\n\n \nunion key_4 {\n\tu32 b32[2];\n\tu8 b8[8];\n};\n\nstruct arp_entry {\n\t__be64 mac;\n\t__be32 dst;\n};\n\nstruct direct_map {\n\tstruct arp_entry arp;\n\tint ifindex;\n\t__be64 mac;\n};\n\n \nstruct {\n\t__uint(type, BPF_MAP_TYPE_LPM_TRIE);\n\t__uint(key_size, 8);\n\t__uint(value_size, sizeof(struct trie_value));\n\t__uint(max_entries, 50);\n\t__uint(map_flags, BPF_F_NO_PREALLOC);\n} lpm_map SEC(\".maps\");\n\n \nstruct {\n\t__uint(type, BPF_MAP_TYPE_HASH);\n\t__type(key, __be32);\n\t__type(value, __be64);\n\t__uint(max_entries, 50);\n} arp_table SEC(\".maps\");\n\n \nstruct {\n\t__uint(type, BPF_MAP_TYPE_HASH);\n\t__type(key, __be32);\n\t__type(value, struct direct_map);\n\t__uint(max_entries, 50);\n} exact_match SEC(\".maps\");\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_DEVMAP);\n\t__uint(key_size, sizeof(int));\n\t__uint(value_size, sizeof(int));\n\t__uint(max_entries, 100);\n} tx_port SEC(\".maps\");\n\nSEC(\"xdp\")\nint xdp_router_ipv4_prog(struct xdp_md *ctx)\n{\n\tvoid *data_end = (void *)(long)ctx->data_end;\n\tvoid *data = (void *)(long)ctx->data;\n\tstruct ethhdr *eth = data;\n\tu64 nh_off = sizeof(*eth);\n\tstruct datarec *rec;\n\t__be16 h_proto;\n\tu32 key = 0;\n\n\trec = bpf_map_lookup_elem(&rx_cnt, &key);\n\tif (rec)\n\t\tNO_TEAR_INC(rec->processed);\n\n\tif (data + nh_off > data_end)\n\t\tgoto drop;\n\n\th_proto = eth->h_proto;\n\tif (h_proto == bpf_htons(ETH_P_8021Q) ||\n\t    h_proto == bpf_htons(ETH_P_8021AD)) {\n\t\tstruct vlan_hdr *vhdr;\n\n\t\tvhdr = data + nh_off;\n\t\tnh_off += sizeof(struct vlan_hdr);\n\t\tif (data + nh_off > data_end)\n\t\t\tgoto drop;\n\n\t\th_proto = vhdr->h_vlan_encapsulated_proto;\n\t}\n\n\tswitch (bpf_ntohs(h_proto)) {\n\tcase ETH_P_ARP:\n\t\tif (rec)\n\t\t\tNO_TEAR_INC(rec->xdp_pass);\n\t\treturn XDP_PASS;\n\tcase ETH_P_IP: {\n\t\tstruct iphdr *iph = data + nh_off;\n\t\tstruct direct_map *direct_entry;\n\t\t__be64 *dest_mac, *src_mac;\n\t\tint forward_to;\n\n\t\tif (iph + 1 > data_end)\n\t\t\tgoto drop;\n\n\t\tdirect_entry = bpf_map_lookup_elem(&exact_match, &iph->daddr);\n\n\t\t \n\t\tif (direct_entry && direct_entry->mac &&\n\t\t    direct_entry->arp.mac) {\n\t\t\tsrc_mac = &direct_entry->mac;\n\t\t\tdest_mac = &direct_entry->arp.mac;\n\t\t\tforward_to = direct_entry->ifindex;\n\t\t} else {\n\t\t\tstruct trie_value *prefix_value;\n\t\t\tunion key_4 key4;\n\n\t\t\t \n\t\t\tkey4.b32[0] = 32;\n\t\t\tkey4.b8[4] = iph->daddr & 0xff;\n\t\t\tkey4.b8[5] = (iph->daddr >> 8) & 0xff;\n\t\t\tkey4.b8[6] = (iph->daddr >> 16) & 0xff;\n\t\t\tkey4.b8[7] = (iph->daddr >> 24) & 0xff;\n\n\t\t\tprefix_value = bpf_map_lookup_elem(&lpm_map, &key4);\n\t\t\tif (!prefix_value)\n\t\t\t\tgoto drop;\n\n\t\t\tforward_to = prefix_value->ifindex;\n\t\t\tsrc_mac = &prefix_value->value;\n\t\t\tif (!src_mac)\n\t\t\t\tgoto drop;\n\n\t\t\tdest_mac = bpf_map_lookup_elem(&arp_table, &iph->daddr);\n\t\t\tif (!dest_mac) {\n\t\t\t\tif (!prefix_value->gw)\n\t\t\t\t\tgoto drop;\n\n\t\t\t\tdest_mac = bpf_map_lookup_elem(&arp_table,\n\t\t\t\t\t\t\t       &prefix_value->gw);\n\t\t\t\tif (!dest_mac) {\n\t\t\t\t\t \n\t\t\t\t\tif (rec)\n\t\t\t\t\t\tNO_TEAR_INC(rec->xdp_pass);\n\t\t\t\t\treturn XDP_PASS;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (src_mac && dest_mac) {\n\t\t\tint ret;\n\n\t\t\t__builtin_memcpy(eth->h_dest, dest_mac, ETH_ALEN);\n\t\t\t__builtin_memcpy(eth->h_source, src_mac, ETH_ALEN);\n\n\t\t\tret = bpf_redirect_map(&tx_port, forward_to, 0);\n\t\t\tif (ret == XDP_REDIRECT) {\n\t\t\t\tif (rec)\n\t\t\t\t\tNO_TEAR_INC(rec->xdp_redirect);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\tdefault:\n\t\tbreak;\n\t}\ndrop:\n\tif (rec)\n\t\tNO_TEAR_INC(rec->xdp_drop);\n\n\treturn XDP_DROP;\n}\n\nchar _license[] SEC(\"license\") = \"GPL\";\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}