{
  "module_name": "trace_event_kern.c",
  "hash_id": "bfa75adcc7256177ad426303fcca293fa92c1e0ae1cbce158ef2e383332ccbcc",
  "original_prompt": "Ingested from linux-6.6.14/samples/bpf/trace_event_kern.c",
  "human_readable_source": " \n#include <linux/ptrace.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/perf_event.h>\n#include <bpf/bpf_helpers.h>\n#include <bpf/bpf_tracing.h>\n\nstruct key_t {\n\tchar comm[TASK_COMM_LEN];\n\tu32 kernstack;\n\tu32 userstack;\n};\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_HASH);\n\t__type(key, struct key_t);\n\t__type(value, u64);\n\t__uint(max_entries, 10000);\n} counts SEC(\".maps\");\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_STACK_TRACE);\n\t__uint(key_size, sizeof(u32));\n\t__uint(value_size, PERF_MAX_STACK_DEPTH * sizeof(u64));\n\t__uint(max_entries, 10000);\n} stackmap SEC(\".maps\");\n\n#define KERN_STACKID_FLAGS (0 | BPF_F_FAST_STACK_CMP)\n#define USER_STACKID_FLAGS (0 | BPF_F_FAST_STACK_CMP | BPF_F_USER_STACK)\n\nSEC(\"perf_event\")\nint bpf_prog1(struct bpf_perf_event_data *ctx)\n{\n\tchar time_fmt1[] = \"Time Enabled: %llu, Time Running: %llu\";\n\tchar time_fmt2[] = \"Get Time Failed, ErrCode: %d\";\n\tchar addr_fmt[] = \"Address recorded on event: %llx\";\n\tchar fmt[] = \"CPU-%d period %lld ip %llx\";\n\tu32 cpu = bpf_get_smp_processor_id();\n\tstruct bpf_perf_event_value value_buf;\n\tstruct key_t key;\n\tu64 *val, one = 1;\n\tint ret;\n\n\tif (ctx->sample_period < 10000)\n\t\t \n\t\treturn 0;\n\tbpf_get_current_comm(&key.comm, sizeof(key.comm));\n\tkey.kernstack = bpf_get_stackid(ctx, &stackmap, KERN_STACKID_FLAGS);\n\tkey.userstack = bpf_get_stackid(ctx, &stackmap, USER_STACKID_FLAGS);\n\tif ((int)key.kernstack < 0 && (int)key.userstack < 0) {\n\t\tbpf_trace_printk(fmt, sizeof(fmt), cpu, ctx->sample_period,\n\t\t\t\t PT_REGS_IP(&ctx->regs));\n\t\treturn 0;\n\t}\n\n\tret = bpf_perf_prog_read_value(ctx, (void *)&value_buf, sizeof(struct bpf_perf_event_value));\n\tif (!ret)\n\t  bpf_trace_printk(time_fmt1, sizeof(time_fmt1), value_buf.enabled, value_buf.running);\n\telse\n\t  bpf_trace_printk(time_fmt2, sizeof(time_fmt2), ret);\n\n\tif (ctx->addr != 0)\n\t  bpf_trace_printk(addr_fmt, sizeof(addr_fmt), ctx->addr);\n\n\tval = bpf_map_lookup_elem(&counts, &key);\n\tif (val)\n\t\t(*val)++;\n\telse\n\t\tbpf_map_update_elem(&counts, &key, &one, BPF_NOEXIST);\n\treturn 0;\n}\n\nchar _license[] SEC(\"license\") = \"GPL\";\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}