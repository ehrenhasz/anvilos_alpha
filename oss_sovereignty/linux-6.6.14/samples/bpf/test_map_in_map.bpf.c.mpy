{
  "module_name": "test_map_in_map.bpf.c",
  "hash_id": "6548787c1be40b2b295eccd0047089145ddd866ae5afa5463d30f9562bf8c226",
  "original_prompt": "Ingested from linux-6.6.14/samples/bpf/test_map_in_map.bpf.c",
  "human_readable_source": " \n#define KBUILD_MODNAME \"foo\"\n#include \"vmlinux.h\"\n#include <linux/version.h>\n#include <bpf/bpf_helpers.h>\n#include <bpf/bpf_tracing.h>\n#include <bpf/bpf_core_read.h>\n\n#define MAX_NR_PORTS 65536\n\n#define EINVAL 22\n#define ENOENT 2\n\n \nstruct inner_a {\n\t__uint(type, BPF_MAP_TYPE_ARRAY);\n\t__type(key, u32);\n\t__type(value, int);\n\t__uint(max_entries, MAX_NR_PORTS);\n} port_a SEC(\".maps\");\n\n \nstruct inner_h {\n\t__uint(type, BPF_MAP_TYPE_HASH);\n\t__type(key, u32);\n\t__type(value, int);\n\t__uint(max_entries, 1);\n} port_h SEC(\".maps\");\n\n \nstruct {\n\t__uint(type, BPF_MAP_TYPE_HASH);\n\t__type(key, u32);\n\t__type(value, int);\n\t__uint(max_entries, 1);\n} reg_result_h SEC(\".maps\");\n\n \nstruct {\n\t__uint(type, BPF_MAP_TYPE_HASH);\n\t__type(key, u32);\n\t__type(value, int);\n\t__uint(max_entries, 1);\n} inline_result_h SEC(\".maps\");\n\n   \nstruct {\n\t__uint(type, BPF_MAP_TYPE_ARRAY_OF_MAPS);\n\t__uint(max_entries, MAX_NR_PORTS);\n\t__uint(key_size, sizeof(u32));\n\t__array(values, struct inner_a);  \n} a_of_port_a SEC(\".maps\");\n\n   \nstruct {\n\t__uint(type, BPF_MAP_TYPE_HASH_OF_MAPS);\n\t__uint(max_entries, 1);\n\t__uint(key_size, sizeof(u32));\n\t__array(values, struct inner_a);  \n} h_of_port_a SEC(\".maps\");\n\n   \nstruct {\n\t__uint(type, BPF_MAP_TYPE_HASH_OF_MAPS);\n\t__uint(max_entries, 1);\n\t__uint(key_size, sizeof(u32));\n\t__array(values, struct inner_h);  \n} h_of_port_h SEC(\".maps\");\n\nstatic __always_inline int do_reg_lookup(void *inner_map, u32 port)\n{\n\tint *result;\n\n\tresult = bpf_map_lookup_elem(inner_map, &port);\n\treturn result ? *result : -ENOENT;\n}\n\nstatic __always_inline int do_inline_array_lookup(void *inner_map, u32 port)\n{\n\tint *result;\n\n\tif (inner_map != &port_a)\n\t\treturn -EINVAL;\n\n\tresult = bpf_map_lookup_elem(&port_a, &port);\n\treturn result ? *result : -ENOENT;\n}\n\nstatic __always_inline int do_inline_hash_lookup(void *inner_map, u32 port)\n{\n\tint *result;\n\n\tif (inner_map != &port_h)\n\t\treturn -EINVAL;\n\n\tresult = bpf_map_lookup_elem(&port_h, &port);\n\treturn result ? *result : -ENOENT;\n}\n\nSEC(\"ksyscall/connect\")\nint BPF_KSYSCALL(trace_sys_connect, unsigned int fd, struct sockaddr_in6 *in6, int addrlen)\n{\n\tu16 test_case, port, dst6[8];\n\tint ret, inline_ret, ret_key = 0;\n\tu32 port_key;\n\tvoid *outer_map, *inner_map;\n\tbool inline_hash = false;\n\n\tif (addrlen != sizeof(*in6))\n\t\treturn 0;\n\n\tret = bpf_probe_read_user(dst6, sizeof(dst6), &in6->sin6_addr);\n\tif (ret) {\n\t\tinline_ret = ret;\n\t\tgoto done;\n\t}\n\n\tif (dst6[0] != 0xdead || dst6[1] != 0xbeef)\n\t\treturn 0;\n\n\ttest_case = dst6[7];\n\n\tret = bpf_probe_read_user(&port, sizeof(port), &in6->sin6_port);\n\tif (ret) {\n\t\tinline_ret = ret;\n\t\tgoto done;\n\t}\n\n\tport_key = port;\n\n\tret = -ENOENT;\n\tif (test_case == 0) {\n\t\touter_map = &a_of_port_a;\n\t} else if (test_case == 1) {\n\t\touter_map = &h_of_port_a;\n\t} else if (test_case == 2) {\n\t\touter_map = &h_of_port_h;\n\t} else {\n\t\tret = __LINE__;\n\t\tinline_ret = ret;\n\t\tgoto done;\n\t}\n\n\tinner_map = bpf_map_lookup_elem(outer_map, &port_key);\n\tif (!inner_map) {\n\t\tret = __LINE__;\n\t\tinline_ret = ret;\n\t\tgoto done;\n\t}\n\n\tret = do_reg_lookup(inner_map, port_key);\n\n\tif (test_case == 0 || test_case == 1)\n\t\tinline_ret = do_inline_array_lookup(inner_map, port_key);\n\telse\n\t\tinline_ret = do_inline_hash_lookup(inner_map, port_key);\n\ndone:\n\tbpf_map_update_elem(&reg_result_h, &ret_key, &ret, BPF_ANY);\n\tbpf_map_update_elem(&inline_result_h, &ret_key, &inline_ret, BPF_ANY);\n\n\treturn 0;\n}\n\nchar _license[] SEC(\"license\") = \"GPL\";\nu32 _version SEC(\"version\") = LINUX_VERSION_CODE;\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}