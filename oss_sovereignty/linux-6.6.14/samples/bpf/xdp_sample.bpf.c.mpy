{
  "module_name": "xdp_sample.bpf.c",
  "hash_id": "5403993f3aefc24992dfc31bea7d996e54082d7bc6c48d9173ce17e474b72d79",
  "original_prompt": "Ingested from linux-6.6.14/samples/bpf/xdp_sample.bpf.c",
  "human_readable_source": "\n \n#include \"xdp_sample.bpf.h\"\n\n#include <bpf/bpf_tracing.h>\n#include <bpf/bpf_core_read.h>\n#include <bpf/bpf_helpers.h>\n\narray_map rx_cnt SEC(\".maps\");\narray_map redir_err_cnt SEC(\".maps\");\narray_map cpumap_enqueue_cnt SEC(\".maps\");\narray_map cpumap_kthread_cnt SEC(\".maps\");\narray_map exception_cnt SEC(\".maps\");\narray_map devmap_xmit_cnt SEC(\".maps\");\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_PERCPU_HASH);\n\t__uint(max_entries, 32 * 32);\n\t__type(key, u64);\n\t__type(value, struct datarec);\n} devmap_xmit_cnt_multi SEC(\".maps\");\n\nconst volatile int nr_cpus = 0;\n\n \nconst volatile int from_match[32] = {};\nconst volatile int to_match[32] = {};\n\nint cpumap_map_id = 0;\n\n \n#define IN_SET(a, b)                                                 \\\n\t({                                                           \\\n\t\tbool __res = !(a)[0];                                \\\n\t\tfor (int i = 0; i < ARRAY_SIZE(a) && (a)[i]; i++) { \\\n\t\t\t__res = (a)[i] == (b);                       \\\n\t\t\tif (__res)                                   \\\n\t\t\t\tbreak;                               \\\n\t\t}                                                    \\\n\t\t__res;                                               \\\n\t})\n\nstatic __always_inline __u32 xdp_get_err_key(int err)\n{\n\tswitch (err) {\n\tcase 0:\n\t\treturn 0;\n\tcase -EINVAL:\n\t\treturn 2;\n\tcase -ENETDOWN:\n\t\treturn 3;\n\tcase -EMSGSIZE:\n\t\treturn 4;\n\tcase -EOPNOTSUPP:\n\t\treturn 5;\n\tcase -ENOSPC:\n\t\treturn 6;\n\tdefault:\n\t\treturn 1;\n\t}\n}\n\nstatic __always_inline int xdp_redirect_collect_stat(int from, int err)\n{\n\tu32 cpu = bpf_get_smp_processor_id();\n\tu32 key = XDP_REDIRECT_ERROR;\n\tstruct datarec *rec;\n\tu32 idx;\n\n\tif (!IN_SET(from_match, from))\n\t\treturn 0;\n\n\tkey = xdp_get_err_key(err);\n\n\tidx = key * nr_cpus + cpu;\n\trec = bpf_map_lookup_elem(&redir_err_cnt, &idx);\n\tif (!rec)\n\t\treturn 0;\n\tif (key)\n\t\tNO_TEAR_INC(rec->dropped);\n\telse\n\t\tNO_TEAR_INC(rec->processed);\n\treturn 0;  \n\t \n}\n\nSEC(\"tp_btf/xdp_redirect_err\")\nint BPF_PROG(tp_xdp_redirect_err, const struct net_device *dev,\n\t     const struct bpf_prog *xdp, const void *tgt, int err,\n\t     const struct bpf_map *map, u32 index)\n{\n\treturn xdp_redirect_collect_stat(dev->ifindex, err);\n}\n\nSEC(\"tp_btf/xdp_redirect_map_err\")\nint BPF_PROG(tp_xdp_redirect_map_err, const struct net_device *dev,\n\t     const struct bpf_prog *xdp, const void *tgt, int err,\n\t     const struct bpf_map *map, u32 index)\n{\n\treturn xdp_redirect_collect_stat(dev->ifindex, err);\n}\n\nSEC(\"tp_btf/xdp_redirect\")\nint BPF_PROG(tp_xdp_redirect, const struct net_device *dev,\n\t     const struct bpf_prog *xdp, const void *tgt, int err,\n\t     const struct bpf_map *map, u32 index)\n{\n\treturn xdp_redirect_collect_stat(dev->ifindex, err);\n}\n\nSEC(\"tp_btf/xdp_redirect_map\")\nint BPF_PROG(tp_xdp_redirect_map, const struct net_device *dev,\n\t     const struct bpf_prog *xdp, const void *tgt, int err,\n\t     const struct bpf_map *map, u32 index)\n{\n\treturn xdp_redirect_collect_stat(dev->ifindex, err);\n}\n\nSEC(\"tp_btf/xdp_cpumap_enqueue\")\nint BPF_PROG(tp_xdp_cpumap_enqueue, int map_id, unsigned int processed,\n\t     unsigned int drops, int to_cpu)\n{\n\tu32 cpu = bpf_get_smp_processor_id();\n\tstruct datarec *rec;\n\tu32 idx;\n\n\tif (cpumap_map_id && cpumap_map_id != map_id)\n\t\treturn 0;\n\n\tidx = to_cpu * nr_cpus + cpu;\n\trec = bpf_map_lookup_elem(&cpumap_enqueue_cnt, &idx);\n\tif (!rec)\n\t\treturn 0;\n\tNO_TEAR_ADD(rec->processed, processed);\n\tNO_TEAR_ADD(rec->dropped, drops);\n\t \n\tif (processed > 0)\n\t\tNO_TEAR_INC(rec->issue);\n\t \n\treturn 0;\n}\n\nSEC(\"tp_btf/xdp_cpumap_kthread\")\nint BPF_PROG(tp_xdp_cpumap_kthread, int map_id, unsigned int processed,\n\t     unsigned int drops, int sched, struct xdp_cpumap_stats *xdp_stats)\n{\n\tstruct datarec *rec;\n\tu32 cpu;\n\n\tif (cpumap_map_id && cpumap_map_id != map_id)\n\t\treturn 0;\n\n\tcpu = bpf_get_smp_processor_id();\n\trec = bpf_map_lookup_elem(&cpumap_kthread_cnt, &cpu);\n\tif (!rec)\n\t\treturn 0;\n\tNO_TEAR_ADD(rec->processed, processed);\n\tNO_TEAR_ADD(rec->dropped, drops);\n\tNO_TEAR_ADD(rec->xdp_pass, xdp_stats->pass);\n\tNO_TEAR_ADD(rec->xdp_drop, xdp_stats->drop);\n\tNO_TEAR_ADD(rec->xdp_redirect, xdp_stats->redirect);\n\t \n\tif (sched)\n\t\tNO_TEAR_INC(rec->issue);\n\treturn 0;\n}\n\nSEC(\"tp_btf/xdp_exception\")\nint BPF_PROG(tp_xdp_exception, const struct net_device *dev,\n\t     const struct bpf_prog *xdp, u32 act)\n{\n\tu32 cpu = bpf_get_smp_processor_id();\n\tstruct datarec *rec;\n\tu32 key = act, idx;\n\n\tif (!IN_SET(from_match, dev->ifindex))\n\t\treturn 0;\n\tif (!IN_SET(to_match, dev->ifindex))\n\t\treturn 0;\n\n\tif (key > XDP_REDIRECT)\n\t\tkey = XDP_REDIRECT + 1;\n\n\tidx = key * nr_cpus + cpu;\n\trec = bpf_map_lookup_elem(&exception_cnt, &idx);\n\tif (!rec)\n\t\treturn 0;\n\tNO_TEAR_INC(rec->dropped);\n\n\treturn 0;\n}\n\nSEC(\"tp_btf/xdp_devmap_xmit\")\nint BPF_PROG(tp_xdp_devmap_xmit, const struct net_device *from_dev,\n\t     const struct net_device *to_dev, int sent, int drops, int err)\n{\n\tstruct datarec *rec;\n\tint idx_in, idx_out;\n\tu32 cpu;\n\n\tidx_in = from_dev->ifindex;\n\tidx_out = to_dev->ifindex;\n\n\tif (!IN_SET(from_match, idx_in))\n\t\treturn 0;\n\tif (!IN_SET(to_match, idx_out))\n\t\treturn 0;\n\n\tcpu = bpf_get_smp_processor_id();\n\trec = bpf_map_lookup_elem(&devmap_xmit_cnt, &cpu);\n\tif (!rec)\n\t\treturn 0;\n\tNO_TEAR_ADD(rec->processed, sent);\n\tNO_TEAR_ADD(rec->dropped, drops);\n\t \n\tNO_TEAR_INC(rec->info);\n\t \n\t \n\tif (err || drops < 0)\n\t\tNO_TEAR_INC(rec->issue);\n\treturn 0;\n}\n\nSEC(\"tp_btf/xdp_devmap_xmit\")\nint BPF_PROG(tp_xdp_devmap_xmit_multi, const struct net_device *from_dev,\n\t     const struct net_device *to_dev, int sent, int drops, int err)\n{\n\tstruct datarec empty = {};\n\tstruct datarec *rec;\n\tint idx_in, idx_out;\n\tu64 idx;\n\n\tidx_in = from_dev->ifindex;\n\tidx_out = to_dev->ifindex;\n\tidx = idx_in;\n\tidx = idx << 32 | idx_out;\n\n\tif (!IN_SET(from_match, idx_in))\n\t\treturn 0;\n\tif (!IN_SET(to_match, idx_out))\n\t\treturn 0;\n\n\tbpf_map_update_elem(&devmap_xmit_cnt_multi, &idx, &empty, BPF_NOEXIST);\n\trec = bpf_map_lookup_elem(&devmap_xmit_cnt_multi, &idx);\n\tif (!rec)\n\t\treturn 0;\n\n\tNO_TEAR_ADD(rec->processed, sent);\n\tNO_TEAR_ADD(rec->dropped, drops);\n\tNO_TEAR_INC(rec->info);\n\tif (err || drops < 0)\n\t\tNO_TEAR_INC(rec->issue);\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}