{
  "module_name": "hbm_edt_kern.c",
  "hash_id": "a47f36016f4f43cdd658328b54772ca7c0cf441c80271b90f7f9028106c2b6f8",
  "original_prompt": "Ingested from linux-6.6.14/samples/bpf/hbm_edt_kern.c",
  "human_readable_source": "\n \n\n#include \"hbm_kern.h\"\n\nSEC(\"cgroup_skb/egress\")\nint _hbm_out_cg(struct __sk_buff *skb)\n{\n\tlong long delta = 0, delta_send;\n\tunsigned long long curtime, sendtime;\n\tstruct hbm_queue_stats *qsp = NULL;\n\tunsigned int queue_index = 0;\n\tbool congestion_flag = false;\n\tbool ecn_ce_flag = false;\n\tstruct hbm_pkt_info pkti = {};\n\tstruct hbm_vqueue *qdp;\n\tbool drop_flag = false;\n\tbool cwr_flag = false;\n\tint len = skb->len;\n\tint rv = ALLOW_PKT;\n\n\tqsp = bpf_map_lookup_elem(&queue_stats, &queue_index);\n\n\t\n\tif (qsp != NULL && !qsp->loopback && (skb->ifindex == 1))\n\t\treturn ALLOW_PKT;\n\n\thbm_get_pkt_info(skb, &pkti);\n\n\t\n\t\n\t\n\n\tqdp = bpf_get_local_storage(&queue_state, 0);\n\tif (!qdp)\n\t\treturn ALLOW_PKT;\n\tif (qdp->lasttime == 0)\n\t\thbm_init_edt_vqueue(qdp, 1024);\n\n\tcurtime = bpf_ktime_get_ns();\n\n\t\n\tbpf_spin_lock(&qdp->lock);\n\tdelta = qdp->lasttime - curtime;\n\t\n\tif (delta < -BURST_SIZE_NS) {\n\t\t\n\t\tqdp->lasttime = curtime - BURST_SIZE_NS;\n\t\tdelta = -BURST_SIZE_NS;\n\t}\n\tsendtime = qdp->lasttime;\n\tdelta_send = BYTES_TO_NS(len, qdp->rate);\n\t__sync_add_and_fetch(&(qdp->lasttime), delta_send);\n\tbpf_spin_unlock(&qdp->lock);\n\t\n\n\t\n\tskb->tstamp = sendtime;\n\n\t\n\tif (qsp != NULL && (qsp->rate * 128) != qdp->rate)\n\t\tqdp->rate = qsp->rate * 128;\n\n\t\n\t\n\tif (delta > DROP_THRESH_NS || (delta > LARGE_PKT_DROP_THRESH_NS &&\n\t\t\t\t       len > LARGE_PKT_THRESH)) {\n\t\tdrop_flag = true;\n\t\tif (pkti.is_tcp && pkti.ecn == 0)\n\t\t\tcwr_flag = true;\n\t} else if (delta > MARK_THRESH_NS) {\n\t\tif (pkti.is_tcp)\n\t\t\tcongestion_flag = true;\n\t\telse\n\t\t\tdrop_flag = true;\n\t}\n\n\tif (congestion_flag) {\n\t\tif (bpf_skb_ecn_set_ce(skb)) {\n\t\t\tecn_ce_flag = true;\n\t\t} else {\n\t\t\tif (pkti.is_tcp) {\n\t\t\t\tunsigned int rand = bpf_get_prandom_u32();\n\n\t\t\t\tif (delta >= MARK_THRESH_NS +\n\t\t\t\t    (rand % MARK_REGION_SIZE_NS)) {\n\t\t\t\t\t\n\t\t\t\t\tcwr_flag = true;\n\t\t\t\t}\n\t\t\t} else if (len > LARGE_PKT_THRESH) {\n\t\t\t\t\n\t\t\t\tdrop_flag = true;\n\t\t\t\tcongestion_flag = false;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (pkti.is_tcp && drop_flag && pkti.packets_out <= 1) {\n\t\tdrop_flag = false;\n\t\tcwr_flag = true;\n\t\tcongestion_flag = false;\n\t}\n\n\tif (qsp != NULL && qsp->no_cn)\n\t\t\tcwr_flag = false;\n\n\thbm_update_stats(qsp, len, curtime, congestion_flag, drop_flag,\n\t\t\t cwr_flag, ecn_ce_flag, &pkti, (int) delta);\n\n\tif (drop_flag) {\n\t\t__sync_add_and_fetch(&(qdp->lasttime), -delta_send);\n\t\trv = DROP_PKT;\n\t}\n\n\tif (cwr_flag)\n\t\trv |= CWR;\n\treturn rv;\n}\nchar _license[] SEC(\"license\") = \"GPL\";\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}