{
  "module_name": "fds_example.c",
  "hash_id": "a1980c1d953d3732c26d773bf5bc4c9dfab67ec7086448ca0116aa78dd859c59",
  "original_prompt": "Ingested from linux-6.6.14/samples/bpf/fds_example.c",
  "human_readable_source": "#include <linux/unistd.h>\n#include <linux/bpf.h>\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <unistd.h>\n#include <string.h>\n#include <assert.h>\n#include <errno.h>\n\n#include <sys/types.h>\n#include <sys/socket.h>\n\n#include <bpf/bpf.h>\n\n#include <bpf/libbpf.h>\n#include \"bpf_insn.h\"\n#include \"sock_example.h\"\n#include \"bpf_util.h\"\n\n#define BPF_F_PIN\t(1 << 0)\n#define BPF_F_GET\t(1 << 1)\n#define BPF_F_PIN_GET\t(BPF_F_PIN | BPF_F_GET)\n\n#define BPF_F_KEY\t(1 << 2)\n#define BPF_F_VAL\t(1 << 3)\n#define BPF_F_KEY_VAL\t(BPF_F_KEY | BPF_F_VAL)\n\n#define BPF_M_UNSPEC\t0\n#define BPF_M_MAP\t1\n#define BPF_M_PROG\t2\n\nchar bpf_log_buf[BPF_LOG_BUF_SIZE];\n\nstatic void usage(void)\n{\n\tprintf(\"Usage: fds_example [...]\\n\");\n\tprintf(\"       -F <file>   File to pin/get object\\n\");\n\tprintf(\"       -P          |- pin object\\n\");\n\tprintf(\"       -G          `- get object\\n\");\n\tprintf(\"       -m          eBPF map mode\\n\");\n\tprintf(\"       -k <key>    |- map key\\n\");\n\tprintf(\"       -v <value>  `- map value\\n\");\n\tprintf(\"       -p          eBPF prog mode\\n\");\n\tprintf(\"       -o <object> `- object file\\n\");\n\tprintf(\"       -h          Display this help.\\n\");\n}\n\nstatic int bpf_prog_create(const char *object)\n{\n\tstatic struct bpf_insn insns[] = {\n\t\tBPF_MOV64_IMM(BPF_REG_0, 1),\n\t\tBPF_EXIT_INSN(),\n\t};\n\tsize_t insns_cnt = ARRAY_SIZE(insns);\n\tstruct bpf_object *obj;\n\tint err;\n\n\tif (object) {\n\t\tobj = bpf_object__open_file(object, NULL);\n\t\tassert(!libbpf_get_error(obj));\n\t\terr = bpf_object__load(obj);\n\t\tassert(!err);\n\t\treturn bpf_program__fd(bpf_object__next_program(obj, NULL));\n\t} else {\n\t\tLIBBPF_OPTS(bpf_prog_load_opts, opts,\n\t\t\t.log_buf = bpf_log_buf,\n\t\t\t.log_size = BPF_LOG_BUF_SIZE,\n\t\t);\n\n\t\treturn bpf_prog_load(BPF_PROG_TYPE_SOCKET_FILTER, NULL, \"GPL\",\n\t\t\t\t     insns, insns_cnt, &opts);\n\t}\n}\n\nstatic int bpf_do_map(const char *file, uint32_t flags, uint32_t key,\n\t\t      uint32_t value)\n{\n\tint fd, ret;\n\n\tif (flags & BPF_F_PIN) {\n\t\tfd = bpf_map_create(BPF_MAP_TYPE_ARRAY, NULL, sizeof(uint32_t),\n\t\t\t\t    sizeof(uint32_t), 1024, NULL);\n\t\tprintf(\"bpf: map fd:%d (%s)\\n\", fd, strerror(errno));\n\t\tassert(fd > 0);\n\n\t\tret = bpf_obj_pin(fd, file);\n\t\tprintf(\"bpf: pin ret:(%d,%s)\\n\", ret, strerror(errno));\n\t\tassert(ret == 0);\n\t} else {\n\t\tfd = bpf_obj_get(file);\n\t\tprintf(\"bpf: get fd:%d (%s)\\n\", fd, strerror(errno));\n\t\tassert(fd > 0);\n\t}\n\n\tif ((flags & BPF_F_KEY_VAL) == BPF_F_KEY_VAL) {\n\t\tret = bpf_map_update_elem(fd, &key, &value, 0);\n\t\tprintf(\"bpf: fd:%d u->(%u:%u) ret:(%d,%s)\\n\", fd, key, value,\n\t\t       ret, strerror(errno));\n\t\tassert(ret == 0);\n\t} else if (flags & BPF_F_KEY) {\n\t\tret = bpf_map_lookup_elem(fd, &key, &value);\n\t\tprintf(\"bpf: fd:%d l->(%u):%u ret:(%d,%s)\\n\", fd, key, value,\n\t\t       ret, strerror(errno));\n\t\tassert(ret == 0);\n\t}\n\n\treturn 0;\n}\n\nstatic int bpf_do_prog(const char *file, uint32_t flags, const char *object)\n{\n\tint fd, sock, ret;\n\n\tif (flags & BPF_F_PIN) {\n\t\tfd = bpf_prog_create(object);\n\t\tprintf(\"bpf: prog fd:%d (%s)\\n\", fd, strerror(errno));\n\t\tassert(fd > 0);\n\n\t\tret = bpf_obj_pin(fd, file);\n\t\tprintf(\"bpf: pin ret:(%d,%s)\\n\", ret, strerror(errno));\n\t\tassert(ret == 0);\n\t} else {\n\t\tfd = bpf_obj_get(file);\n\t\tprintf(\"bpf: get fd:%d (%s)\\n\", fd, strerror(errno));\n\t\tassert(fd > 0);\n\t}\n\n\tsock = open_raw_sock(\"lo\");\n\tassert(sock > 0);\n\n\tret = setsockopt(sock, SOL_SOCKET, SO_ATTACH_BPF, &fd, sizeof(fd));\n\tprintf(\"bpf: sock:%d <- fd:%d attached ret:(%d,%s)\\n\", sock, fd,\n\t       ret, strerror(errno));\n\tassert(ret == 0);\n\n\treturn 0;\n}\n\nint main(int argc, char **argv)\n{\n\tconst char *file = NULL, *object = NULL;\n\tuint32_t key = 0, value = 0, flags = 0;\n\tint opt, mode = BPF_M_UNSPEC;\n\n\twhile ((opt = getopt(argc, argv, \"F:PGmk:v:po:\")) != -1) {\n\t\tswitch (opt) {\n\t\t \n\t\tcase 'F':\n\t\t\tfile = optarg;\n\t\t\tbreak;\n\t\tcase 'P':\n\t\t\tflags |= BPF_F_PIN;\n\t\t\tbreak;\n\t\tcase 'G':\n\t\t\tflags |= BPF_F_GET;\n\t\t\tbreak;\n\t\t \n\t\tcase 'm':\n\t\t\tmode = BPF_M_MAP;\n\t\t\tbreak;\n\t\tcase 'k':\n\t\t\tkey = strtoul(optarg, NULL, 0);\n\t\t\tflags |= BPF_F_KEY;\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\tvalue = strtoul(optarg, NULL, 0);\n\t\t\tflags |= BPF_F_VAL;\n\t\t\tbreak;\n\t\t \n\t\tcase 'p':\n\t\t\tmode = BPF_M_PROG;\n\t\t\tbreak;\n\t\tcase 'o':\n\t\t\tobject = optarg;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (!(flags & BPF_F_PIN_GET) || !file)\n\t\tgoto out;\n\n\tswitch (mode) {\n\tcase BPF_M_MAP:\n\t\treturn bpf_do_map(file, flags, key, value);\n\tcase BPF_M_PROG:\n\t\treturn bpf_do_prog(file, flags, object);\n\t}\nout:\n\tusage();\n\treturn -1;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}