{
  "module_name": "tcbpf1_kern.c",
  "hash_id": "48b5e14762249eb3c80e26810777c2e63955f227e43816f5b048f13fbdebd3b7",
  "original_prompt": "Ingested from linux-6.6.14/samples/bpf/tcbpf1_kern.c",
  "human_readable_source": "#define KBUILD_MODNAME \"foo\"\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/if_ether.h>\n#include <uapi/linux/if_packet.h>\n#include <uapi/linux/ip.h>\n#include <uapi/linux/in.h>\n#include <uapi/linux/tcp.h>\n#include <uapi/linux/filter.h>\n#include <uapi/linux/pkt_cls.h>\n#include <bpf/bpf_helpers.h>\n#include \"bpf_legacy.h\"\n\n \n#define _htonl __builtin_bswap32\n\nstatic inline void set_dst_mac(struct __sk_buff *skb, char *mac)\n{\n\tbpf_skb_store_bytes(skb, 0, mac, ETH_ALEN, 1);\n}\n\n#define IP_CSUM_OFF (ETH_HLEN + offsetof(struct iphdr, check))\n#define TOS_OFF (ETH_HLEN + offsetof(struct iphdr, tos))\n\nstatic inline void set_ip_tos(struct __sk_buff *skb, __u8 new_tos)\n{\n\t__u8 old_tos = load_byte(skb, TOS_OFF);\n\n\tbpf_l3_csum_replace(skb, IP_CSUM_OFF, htons(old_tos), htons(new_tos), 2);\n\tbpf_skb_store_bytes(skb, TOS_OFF, &new_tos, sizeof(new_tos), 0);\n}\n\n#define TCP_CSUM_OFF (ETH_HLEN + sizeof(struct iphdr) + offsetof(struct tcphdr, check))\n#define IP_SRC_OFF (ETH_HLEN + offsetof(struct iphdr, saddr))\n\n#define IS_PSEUDO 0x10\n\nstatic inline void set_tcp_ip_src(struct __sk_buff *skb, __u32 new_ip)\n{\n\t__u32 old_ip = _htonl(load_word(skb, IP_SRC_OFF));\n\n\tbpf_l4_csum_replace(skb, TCP_CSUM_OFF, old_ip, new_ip, IS_PSEUDO | sizeof(new_ip));\n\tbpf_l3_csum_replace(skb, IP_CSUM_OFF, old_ip, new_ip, sizeof(new_ip));\n\tbpf_skb_store_bytes(skb, IP_SRC_OFF, &new_ip, sizeof(new_ip), 0);\n}\n\n#define TCP_DPORT_OFF (ETH_HLEN + sizeof(struct iphdr) + offsetof(struct tcphdr, dest))\nstatic inline void set_tcp_dest_port(struct __sk_buff *skb, __u16 new_port)\n{\n\t__u16 old_port = htons(load_half(skb, TCP_DPORT_OFF));\n\n\tbpf_l4_csum_replace(skb, TCP_CSUM_OFF, old_port, new_port, sizeof(new_port));\n\tbpf_skb_store_bytes(skb, TCP_DPORT_OFF, &new_port, sizeof(new_port), 0);\n}\n\nSEC(\"classifier\")\nint bpf_prog1(struct __sk_buff *skb)\n{\n\t__u8 proto = load_byte(skb, ETH_HLEN + offsetof(struct iphdr, protocol));\n\tlong *value;\n\n\tif (proto == IPPROTO_TCP) {\n\t\tset_ip_tos(skb, 8);\n\t\tset_tcp_ip_src(skb, 0xA010101);\n\t\tset_tcp_dest_port(skb, 5001);\n\t}\n\n\treturn 0;\n}\nSEC(\"redirect_xmit\")\nint _redirect_xmit(struct __sk_buff *skb)\n{\n\treturn bpf_redirect(skb->ifindex + 1, 0);\n}\nSEC(\"redirect_recv\")\nint _redirect_recv(struct __sk_buff *skb)\n{\n\treturn bpf_redirect(skb->ifindex + 1, 1);\n}\nSEC(\"clone_redirect_xmit\")\nint _clone_redirect_xmit(struct __sk_buff *skb)\n{\n\tbpf_clone_redirect(skb, skb->ifindex + 1, 0);\n\treturn TC_ACT_SHOT;\n}\nSEC(\"clone_redirect_recv\")\nint _clone_redirect_recv(struct __sk_buff *skb)\n{\n\tbpf_clone_redirect(skb, skb->ifindex + 1, 1);\n\treturn TC_ACT_SHOT;\n}\nchar _license[] SEC(\"license\") = \"GPL\";\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}