{
  "module_name": "sampleip_user.c",
  "hash_id": "a63e3b230f70b4246f6c2614543291ad6cd81ee09c7204696923d0c710438f46",
  "original_prompt": "Ingested from linux-6.6.14/samples/bpf/sampleip_user.c",
  "human_readable_source": "\n \n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <errno.h>\n#include <signal.h>\n#include <string.h>\n#include <linux/perf_event.h>\n#include <linux/ptrace.h>\n#include <linux/bpf.h>\n#include <bpf/bpf.h>\n#include <bpf/libbpf.h>\n#include \"perf-sys.h\"\n#include \"trace_helpers.h\"\n\n#define DEFAULT_FREQ\t99\n#define DEFAULT_SECS\t5\n#define MAX_IPS\t\t8192\n\nstatic int map_fd;\nstatic int nr_cpus;\nstatic long _text_addr;\n\nstatic void usage(void)\n{\n\tprintf(\"USAGE: sampleip [-F freq] [duration]\\n\");\n\tprintf(\"       -F freq    # sample frequency (Hertz), default 99\\n\");\n\tprintf(\"       duration   # sampling duration (seconds), default 5\\n\");\n}\n\nstatic int sampling_start(int freq, struct bpf_program *prog,\n\t\t\t  struct bpf_link *links[])\n{\n\tint i, pmu_fd;\n\n\tstruct perf_event_attr pe_sample_attr = {\n\t\t.type = PERF_TYPE_SOFTWARE,\n\t\t.freq = 1,\n\t\t.sample_period = freq,\n\t\t.config = PERF_COUNT_SW_CPU_CLOCK,\n\t\t.inherit = 1,\n\t};\n\n\tfor (i = 0; i < nr_cpus; i++) {\n\t\tpmu_fd = sys_perf_event_open(&pe_sample_attr, -1  , i,\n\t\t\t\t\t    -1  , 0  );\n\t\tif (pmu_fd < 0) {\n\t\t\tfprintf(stderr, \"ERROR: Initializing perf sampling\\n\");\n\t\t\treturn 1;\n\t\t}\n\t\tlinks[i] = bpf_program__attach_perf_event(prog, pmu_fd);\n\t\tif (libbpf_get_error(links[i])) {\n\t\t\tfprintf(stderr, \"ERROR: Attach perf event\\n\");\n\t\t\tlinks[i] = NULL;\n\t\t\tclose(pmu_fd);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void sampling_end(struct bpf_link *links[])\n{\n\tint i;\n\n\tfor (i = 0; i < nr_cpus; i++)\n\t\tbpf_link__destroy(links[i]);\n}\n\nstruct ipcount {\n\t__u64 ip;\n\t__u32 count;\n};\n\n \nstruct ipcount counts[MAX_IPS];\n\nstatic int count_cmp(const void *p1, const void *p2)\n{\n\treturn ((struct ipcount *)p1)->count - ((struct ipcount *)p2)->count;\n}\n\nstatic void print_ip_map(int fd)\n{\n\tstruct ksym *sym;\n\t__u64 key, next_key;\n\t__u32 value;\n\tint i, max;\n\n\tprintf(\"%-19s %-32s %s\\n\", \"ADDR\", \"KSYM\", \"COUNT\");\n\n\t \n\tkey = 0, i = 0;\n\twhile (bpf_map_get_next_key(fd, &key, &next_key) == 0) {\n\t\tbpf_map_lookup_elem(fd, &next_key, &value);\n\t\tcounts[i].ip = next_key;\n\t\tcounts[i++].count = value;\n\t\tkey = next_key;\n\t}\n\tmax = i;\n\n\t \n\tqsort(counts, max, sizeof(struct ipcount), count_cmp);\n\tfor (i = 0; i < max; i++) {\n\t\tif (counts[i].ip > _text_addr) {\n\t\t\tsym = ksym_search(counts[i].ip);\n\t\t\tif (!sym) {\n\t\t\t\tprintf(\"ksym not found. Is kallsyms loaded?\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tprintf(\"0x%-17llx %-32s %u\\n\", counts[i].ip, sym->name,\n\t\t\t       counts[i].count);\n\t\t} else {\n\t\t\tprintf(\"0x%-17llx %-32s %u\\n\", counts[i].ip, \"(user)\",\n\t\t\t       counts[i].count);\n\t\t}\n\t}\n\n\tif (max == MAX_IPS) {\n\t\tprintf(\"WARNING: IP hash was full (max %d entries); \", max);\n\t\tprintf(\"may have dropped samples\\n\");\n\t}\n}\n\nstatic void int_exit(int sig)\n{\n\tprintf(\"\\n\");\n\tprint_ip_map(map_fd);\n\texit(0);\n}\n\nint main(int argc, char **argv)\n{\n\tint opt, freq = DEFAULT_FREQ, secs = DEFAULT_SECS, error = 1;\n\tstruct bpf_object *obj = NULL;\n\tstruct bpf_program *prog;\n\tstruct bpf_link **links;\n\tchar filename[256];\n\n\t \n\twhile ((opt = getopt(argc, argv, \"F:h\")) != -1) {\n\t\tswitch (opt) {\n\t\tcase 'F':\n\t\t\tfreq = atoi(optarg);\n\t\t\tbreak;\n\t\tcase 'h':\n\t\tdefault:\n\t\t\tusage();\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (argc - optind == 1)\n\t\tsecs = atoi(argv[optind]);\n\tif (freq == 0 || secs == 0) {\n\t\tusage();\n\t\treturn 1;\n\t}\n\n\t \n\tif (load_kallsyms()) {\n\t\tfprintf(stderr, \"ERROR: loading /proc/kallsyms\\n\");\n\t\treturn 2;\n\t}\n\n\t \n\t_text_addr = ksym_get_addr(\"_text\");\n\tif (!_text_addr) {\n\t\tfprintf(stderr, \"ERROR: no '_text' in /proc/kallsyms\\n\");\n\t\treturn 3;\n\t}\n\n\t \n\tnr_cpus = sysconf(_SC_NPROCESSORS_ONLN);\n\tlinks = calloc(nr_cpus, sizeof(struct bpf_link *));\n\tif (!links) {\n\t\tfprintf(stderr, \"ERROR: malloc of links\\n\");\n\t\tgoto cleanup;\n\t}\n\n\tsnprintf(filename, sizeof(filename), \"%s_kern.o\", argv[0]);\n\tobj = bpf_object__open_file(filename, NULL);\n\tif (libbpf_get_error(obj)) {\n\t\tfprintf(stderr, \"ERROR: opening BPF object file failed\\n\");\n\t\tobj = NULL;\n\t\tgoto cleanup;\n\t}\n\n\tprog = bpf_object__find_program_by_name(obj, \"do_sample\");\n\tif (!prog) {\n\t\tfprintf(stderr, \"ERROR: finding a prog in obj file failed\\n\");\n\t\tgoto cleanup;\n\t}\n\n\t \n\tif (bpf_object__load(obj)) {\n\t\tfprintf(stderr, \"ERROR: loading BPF object file failed\\n\");\n\t\tgoto cleanup;\n\t}\n\n\tmap_fd = bpf_object__find_map_fd_by_name(obj, \"ip_map\");\n\tif (map_fd < 0) {\n\t\tfprintf(stderr, \"ERROR: finding a map in obj file failed\\n\");\n\t\tgoto cleanup;\n\t}\n\n\tsignal(SIGINT, int_exit);\n\tsignal(SIGTERM, int_exit);\n\n\t \n\tprintf(\"Sampling at %d Hertz for %d seconds. Ctrl-C also ends.\\n\",\n\t       freq, secs);\n\tif (sampling_start(freq, prog, links) != 0)\n\t\tgoto cleanup;\n\n\tsleep(secs);\n\terror = 0;\n\ncleanup:\n\tsampling_end(links);\n\t \n\tif (!error)\n\t\tprint_ip_map(map_fd);\n\n\tfree(links);\n\tbpf_object__close(obj);\n\treturn error;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}