{
  "module_name": "xdp_adjust_tail_kern.c",
  "hash_id": "1cba0f2de4032c7294411cfa9ccf29a75717b16ff15e91c44d65a7212729a628",
  "original_prompt": "Ingested from linux-6.6.14/samples/bpf/xdp_adjust_tail_kern.c",
  "human_readable_source": " \n#define KBUILD_MODNAME \"foo\"\n#include <uapi/linux/bpf.h>\n#include <linux/in.h>\n#include <linux/if_ether.h>\n#include <linux/if_packet.h>\n#include <linux/if_vlan.h>\n#include <linux/ip.h>\n#include <linux/icmp.h>\n#include <bpf/bpf_helpers.h>\n\n#define DEFAULT_TTL 64\n#define MAX_PCKT_SIZE 600\n#define ICMP_TOOBIG_SIZE 98\n#define ICMP_TOOBIG_PAYLOAD_SIZE 92\n\n \nstatic volatile __u32 max_pcktsz = MAX_PCKT_SIZE;\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_ARRAY);\n\t__type(key, __u32);\n\t__type(value, __u64);\n\t__uint(max_entries, 1);\n} icmpcnt SEC(\".maps\");\n\nstatic __always_inline void count_icmp(void)\n{\n\tu64 key = 0;\n\tu64 *icmp_count;\n\n\ticmp_count = bpf_map_lookup_elem(&icmpcnt, &key);\n\tif (icmp_count)\n\t\t*icmp_count += 1;\n}\n\nstatic __always_inline void swap_mac(void *data, struct ethhdr *orig_eth)\n{\n\tstruct ethhdr *eth;\n\n\teth = data;\n\tmemcpy(eth->h_source, orig_eth->h_dest, ETH_ALEN);\n\tmemcpy(eth->h_dest, orig_eth->h_source, ETH_ALEN);\n\teth->h_proto = orig_eth->h_proto;\n}\n\nstatic __always_inline __u16 csum_fold_helper(__u32 csum)\n{\n\treturn ~((csum & 0xffff) + (csum >> 16));\n}\n\nstatic __always_inline void ipv4_csum(void *data_start, int data_size,\n\t\t\t\t      __u32 *csum)\n{\n\t*csum = bpf_csum_diff(0, 0, data_start, data_size, *csum);\n\t*csum = csum_fold_helper(*csum);\n}\n\nstatic __always_inline int send_icmp4_too_big(struct xdp_md *xdp)\n{\n\tint headroom = (int)sizeof(struct iphdr) + (int)sizeof(struct icmphdr);\n\n\tif (bpf_xdp_adjust_head(xdp, 0 - headroom))\n\t\treturn XDP_DROP;\n\tvoid *data = (void *)(long)xdp->data;\n\tvoid *data_end = (void *)(long)xdp->data_end;\n\n\tif (data + (ICMP_TOOBIG_SIZE + headroom) > data_end)\n\t\treturn XDP_DROP;\n\n\tstruct iphdr *iph, *orig_iph;\n\tstruct icmphdr *icmp_hdr;\n\tstruct ethhdr *orig_eth;\n\t__u32 csum = 0;\n\t__u64 off = 0;\n\n\torig_eth = data + headroom;\n\tswap_mac(data, orig_eth);\n\toff += sizeof(struct ethhdr);\n\tiph = data + off;\n\toff += sizeof(struct iphdr);\n\ticmp_hdr = data + off;\n\toff += sizeof(struct icmphdr);\n\torig_iph = data + off;\n\ticmp_hdr->type = ICMP_DEST_UNREACH;\n\ticmp_hdr->code = ICMP_FRAG_NEEDED;\n\ticmp_hdr->un.frag.mtu = htons(max_pcktsz - sizeof(struct ethhdr));\n\ticmp_hdr->checksum = 0;\n\tipv4_csum(icmp_hdr, ICMP_TOOBIG_PAYLOAD_SIZE, &csum);\n\ticmp_hdr->checksum = csum;\n\tiph->ttl = DEFAULT_TTL;\n\tiph->daddr = orig_iph->saddr;\n\tiph->saddr = orig_iph->daddr;\n\tiph->version = 4;\n\tiph->ihl = 5;\n\tiph->protocol = IPPROTO_ICMP;\n\tiph->tos = 0;\n\tiph->tot_len = htons(\n\t\tICMP_TOOBIG_SIZE + headroom - sizeof(struct ethhdr));\n\tiph->check = 0;\n\tcsum = 0;\n\tipv4_csum(iph, sizeof(struct iphdr), &csum);\n\tiph->check = csum;\n\tcount_icmp();\n\treturn XDP_TX;\n}\n\n\nstatic __always_inline int handle_ipv4(struct xdp_md *xdp)\n{\n\tvoid *data_end = (void *)(long)xdp->data_end;\n\tvoid *data = (void *)(long)xdp->data;\n\tint pckt_size = data_end - data;\n\tint offset;\n\n\tif (pckt_size > max(max_pcktsz, ICMP_TOOBIG_SIZE)) {\n\t\toffset = pckt_size - ICMP_TOOBIG_SIZE;\n\t\tif (bpf_xdp_adjust_tail(xdp, 0 - offset))\n\t\t\treturn XDP_PASS;\n\t\treturn send_icmp4_too_big(xdp);\n\t}\n\treturn XDP_PASS;\n}\n\nSEC(\"xdp_icmp\")\nint _xdp_icmp(struct xdp_md *xdp)\n{\n\tvoid *data_end = (void *)(long)xdp->data_end;\n\tvoid *data = (void *)(long)xdp->data;\n\tstruct ethhdr *eth = data;\n\t__u16 h_proto;\n\n\tif (eth + 1 > data_end)\n\t\treturn XDP_DROP;\n\n\th_proto = eth->h_proto;\n\n\tif (h_proto == htons(ETH_P_IP))\n\t\treturn handle_ipv4(xdp);\n\telse\n\t\treturn XDP_PASS;\n}\n\nchar _license[] SEC(\"license\") = \"GPL\";\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}