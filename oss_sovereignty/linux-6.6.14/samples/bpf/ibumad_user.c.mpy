{
  "module_name": "ibumad_user.c",
  "hash_id": "31b7116a48914a65b659fc48fe70731eb55b80a29edef9b8d54db41d5c65c687",
  "original_prompt": "Ingested from linux-6.6.14/samples/bpf/ibumad_user.c",
  "human_readable_source": "\n\n \n\n#include <linux/bpf.h>\n#include <signal.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <limits.h>\n\n#include <getopt.h>\n#include <net/if.h>\n\n#include <bpf/bpf.h>\n#include \"bpf_util.h\"\n#include <bpf/libbpf.h>\n\nstatic struct bpf_link *tp_links[3];\nstatic struct bpf_object *obj;\nstatic int map_fd[2];\nstatic int tp_cnt;\n\nstatic void dump_counts(int fd)\n{\n\t__u32 key;\n\t__u64 value;\n\n\tfor (key = 0; key < 256; key++) {\n\t\tif (bpf_map_lookup_elem(fd, &key, &value)) {\n\t\t\tprintf(\"failed to read key %u\\n\", key);\n\t\t\tcontinue;\n\t\t}\n\t\tif (value)\n\t\t\tprintf(\"0x%02x : %llu\\n\", key, value);\n\t}\n}\n\nstatic void dump_all_counts(void)\n{\n\tprintf(\"Read 'Class : count'\\n\");\n\tdump_counts(map_fd[0]);\n\tprintf(\"Write 'Class : count'\\n\");\n\tdump_counts(map_fd[1]);\n}\n\nstatic void dump_exit(int sig)\n{\n\tdump_all_counts();\n\t \n\twhile (tp_cnt)\n\t\tbpf_link__destroy(tp_links[--tp_cnt]);\n\n\tbpf_object__close(obj);\n\texit(0);\n}\n\nstatic const struct option long_options[] = {\n\t{\"help\",      no_argument,       NULL, 'h'},\n\t{\"delay\",     required_argument, NULL, 'd'},\n};\n\nstatic void usage(char *cmd)\n{\n\tprintf(\"eBPF test program to count packets from various IP addresses\\n\"\n\t\t\"Usage: %s <options>\\n\"\n\t\t\"       --help,   -h  this menu\\n\"\n\t\t\"       --delay,  -d  <delay>  wait <delay> sec between prints [1 - 1000000]\\n\"\n\t\t, cmd\n\t\t);\n}\n\nint main(int argc, char **argv)\n{\n\tstruct bpf_program *prog;\n\tunsigned long delay = 5;\n\tchar filename[256];\n\tint longindex = 0;\n\tint opt, err = -1;\n\n\twhile ((opt = getopt_long(argc, argv, \"hd:rSw\",\n\t\t\t\t  long_options, &longindex)) != -1) {\n\t\tswitch (opt) {\n\t\tcase 'd':\n\t\t\tdelay = strtoul(optarg, NULL, 0);\n\t\t\tif (delay == ULONG_MAX || delay < 0 ||\n\t\t\t    delay > 1000000) {\n\t\t\t\tfprintf(stderr, \"ERROR: invalid delay : %s\\n\",\n\t\t\t\t\toptarg);\n\t\t\t\tusage(argv[0]);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\tcase 'h':\n\t\t\tusage(argv[0]);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\t \n\tsignal(SIGINT, dump_exit);\n\tsignal(SIGTERM, dump_exit);\n\n\tsnprintf(filename, sizeof(filename), \"%s_kern.o\", argv[0]);\n\tobj = bpf_object__open_file(filename, NULL);\n\tif (libbpf_get_error(obj)) {\n\t\tfprintf(stderr, \"ERROR: opening BPF object file failed\\n\");\n\t\treturn err;\n\t}\n\n\t \n\tif (bpf_object__load(obj)) {\n\t\tfprintf(stderr, \"ERROR: loading BPF object file failed\\n\");\n\t\tgoto cleanup;\n\t}\n\n\tmap_fd[0] = bpf_object__find_map_fd_by_name(obj, \"read_count\");\n\tmap_fd[1] = bpf_object__find_map_fd_by_name(obj, \"write_count\");\n\tif (map_fd[0] < 0 || map_fd[1] < 0) {\n\t\tfprintf(stderr, \"ERROR: finding a map in obj file failed\\n\");\n\t\tgoto cleanup;\n\t}\n\n\tbpf_object__for_each_program(prog, obj) {\n\t\ttp_links[tp_cnt] = bpf_program__attach(prog);\n\t\tif (libbpf_get_error(tp_links[tp_cnt])) {\n\t\t\tfprintf(stderr, \"ERROR: bpf_program__attach failed\\n\");\n\t\t\ttp_links[tp_cnt] = NULL;\n\t\t\tgoto cleanup;\n\t\t}\n\t\ttp_cnt++;\n\t}\n\n\twhile (1) {\n\t\tsleep(delay);\n\t\tdump_all_counts();\n\t}\n\terr = 0;\n\ncleanup:\n\t \n\twhile (tp_cnt)\n\t\tbpf_link__destroy(tp_links[--tp_cnt]);\n\n\tbpf_object__close(obj);\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}