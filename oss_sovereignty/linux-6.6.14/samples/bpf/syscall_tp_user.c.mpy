{
  "module_name": "syscall_tp_user.c",
  "hash_id": "474ea0e9a3a01dd369a1ad33fef24e82d695123f17a687cc6528f7abdcc18741",
  "original_prompt": "Ingested from linux-6.6.14/samples/bpf/syscall_tp_user.c",
  "human_readable_source": "\n \n#include <stdio.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <stdlib.h>\n#include <string.h>\n#include <linux/perf_event.h>\n#include <errno.h>\n#include <bpf/libbpf.h>\n#include <bpf/bpf.h>\n\n \n\nstatic void usage(const char *cmd)\n{\n\tprintf(\"USAGE: %s [-i nr_tests] [-h]\\n\", cmd);\n\tprintf(\"       -i nr_tests      # rounds of test to run\\n\");\n\tprintf(\"       -h               # help\\n\");\n}\n\nstatic void verify_map(int map_id)\n{\n\t__u32 key = 0;\n\t__u32 val;\n\n\tif (bpf_map_lookup_elem(map_id, &key, &val) != 0) {\n\t\tfprintf(stderr, \"map_lookup failed: %s\\n\", strerror(errno));\n\t\treturn;\n\t}\n\tif (val == 0) {\n\t\tfprintf(stderr, \"failed: map #%d returns value 0\\n\", map_id);\n\t\treturn;\n\t}\n\n\tprintf(\"verify map:%d val: %d\\n\", map_id, val);\n\n\tval = 0;\n\tif (bpf_map_update_elem(map_id, &key, &val, BPF_ANY) != 0) {\n\t\tfprintf(stderr, \"map_update failed: %s\\n\", strerror(errno));\n\t\treturn;\n\t}\n}\n\nstatic int test(char *filename, int nr_tests)\n{\n\tint map0_fds[nr_tests], map1_fds[nr_tests], fd, i, j = 0;\n\tstruct bpf_link **links = NULL;\n\tstruct bpf_object *objs[nr_tests];\n\tstruct bpf_program *prog;\n\n\tfor (i = 0; i < nr_tests; i++) {\n\t\tobjs[i] = bpf_object__open_file(filename, NULL);\n\t\tif (libbpf_get_error(objs[i])) {\n\t\t\tfprintf(stderr, \"opening BPF object file failed\\n\");\n\t\t\tobjs[i] = NULL;\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\t \n\t\tif (!links) {\n\t\t\tint nr_progs = 0;\n\n\t\t\tbpf_object__for_each_program(prog, objs[i])\n\t\t\t\tnr_progs += 1;\n\n\t\t\tlinks = calloc(nr_progs * nr_tests, sizeof(struct bpf_link *));\n\n\t\t\tif (!links)\n\t\t\t\tgoto cleanup;\n\t\t}\n\n\t\t \n\t\tif (bpf_object__load(objs[i])) {\n\t\t\tfprintf(stderr, \"loading BPF object file failed\\n\");\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\tmap0_fds[i] = bpf_object__find_map_fd_by_name(objs[i],\n\t\t\t\t\t\t\t      \"enter_open_map\");\n\t\tmap1_fds[i] = bpf_object__find_map_fd_by_name(objs[i],\n\t\t\t\t\t\t\t      \"exit_open_map\");\n\t\tif (map0_fds[i] < 0 || map1_fds[i] < 0) {\n\t\t\tfprintf(stderr, \"finding a map in obj file failed\\n\");\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\tbpf_object__for_each_program(prog, objs[i]) {\n\t\t\tlinks[j] = bpf_program__attach(prog);\n\t\t\tif (libbpf_get_error(links[j])) {\n\t\t\t\tfprintf(stderr, \"bpf_program__attach failed\\n\");\n\t\t\t\tlinks[j] = NULL;\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\tj++;\n\t\t}\n\t\tprintf(\"prog #%d: map ids %d %d\\n\", i, map0_fds[i], map1_fds[i]);\n\t}\n\n\t \n\t \n\tfd = open(filename, O_RDONLY);\n\tif (fd < 0) {\n\t\tfprintf(stderr, \"open failed: %s\\n\", strerror(errno));\n\t\treturn 1;\n\t}\n\tclose(fd);\n\n\t \n\tfor (i = 0; i < nr_tests; i++) {\n\t\tverify_map(map0_fds[i]);\n\t\tverify_map(map1_fds[i]);\n\t}\n\ncleanup:\n\tif (links) {\n\t\tfor (j--; j >= 0; j--)\n\t\t\tbpf_link__destroy(links[j]);\n\n\t\tfree(links);\n\t}\n\n\tfor (i--; i >= 0; i--)\n\t\tbpf_object__close(objs[i]);\n\treturn 0;\n}\n\nint main(int argc, char **argv)\n{\n\tint opt, nr_tests = 1;\n\tchar filename[256];\n\n\twhile ((opt = getopt(argc, argv, \"i:h\")) != -1) {\n\t\tswitch (opt) {\n\t\tcase 'i':\n\t\t\tnr_tests = atoi(optarg);\n\t\t\tbreak;\n\t\tcase 'h':\n\t\tdefault:\n\t\t\tusage(argv[0]);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tsnprintf(filename, sizeof(filename), \"%s_kern.o\", argv[0]);\n\n\treturn test(filename, nr_tests);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}