{
  "module_name": "test_map_in_map_user.c",
  "hash_id": "02a1161aee371a29d01fe5e12c4f115b0b94aace6d5a97dd907b4d800790ce42",
  "original_prompt": "Ingested from linux-6.6.14/samples/bpf/test_map_in_map_user.c",
  "human_readable_source": "\n \n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <stdint.h>\n#include <assert.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <bpf/bpf.h>\n#include <bpf/libbpf.h>\n\n#include \"bpf_util.h\"\n\nstatic int map_fd[7];\n\n#define PORT_A\t\t(map_fd[0])\n#define PORT_H\t\t(map_fd[1])\n#define REG_RESULT_H\t(map_fd[2])\n#define INLINE_RESULT_H\t(map_fd[3])\n#define A_OF_PORT_A\t(map_fd[4])  \n#define H_OF_PORT_A\t(map_fd[5])  \n#define H_OF_PORT_H\t(map_fd[6])  \n\nstatic const char * const test_names[] = {\n\t\"Array of Array\",\n\t\"Hash of Array\",\n\t\"Hash of Hash\",\n};\n\n#define NR_TESTS ARRAY_SIZE(test_names)\n\nstatic void check_map_id(int inner_map_fd, int map_in_map_fd, uint32_t key)\n{\n\tstruct bpf_map_info info = {};\n\tuint32_t info_len = sizeof(info);\n\tint ret, id;\n\n\tret = bpf_map_get_info_by_fd(inner_map_fd, &info, &info_len);\n\tassert(!ret);\n\n\tret = bpf_map_lookup_elem(map_in_map_fd, &key, &id);\n\tassert(!ret);\n\tassert(id == info.id);\n}\n\nstatic void populate_map(uint32_t port_key, int magic_result)\n{\n\tint ret;\n\n\tret = bpf_map_update_elem(PORT_A, &port_key, &magic_result, BPF_ANY);\n\tassert(!ret);\n\n\tret = bpf_map_update_elem(PORT_H, &port_key, &magic_result,\n\t\t\t\t  BPF_NOEXIST);\n\tassert(!ret);\n\n\tret = bpf_map_update_elem(A_OF_PORT_A, &port_key, &PORT_A, BPF_ANY);\n\tassert(!ret);\n\tcheck_map_id(PORT_A, A_OF_PORT_A, port_key);\n\n\tret = bpf_map_update_elem(H_OF_PORT_A, &port_key, &PORT_A, BPF_NOEXIST);\n\tassert(!ret);\n\tcheck_map_id(PORT_A, H_OF_PORT_A, port_key);\n\n\tret = bpf_map_update_elem(H_OF_PORT_H, &port_key, &PORT_H, BPF_NOEXIST);\n\tassert(!ret);\n\tcheck_map_id(PORT_H, H_OF_PORT_H, port_key);\n}\n\nstatic void test_map_in_map(void)\n{\n\tstruct sockaddr_in6 in6 = { .sin6_family = AF_INET6 };\n\tuint32_t result_key = 0, port_key;\n\tint result, inline_result;\n\tint magic_result = 0xfaceb00c;\n\tint ret;\n\tint i;\n\n\tport_key = rand() & 0x00FF;\n\tpopulate_map(port_key, magic_result);\n\n\tin6.sin6_addr.s6_addr16[0] = 0xdead;\n\tin6.sin6_addr.s6_addr16[1] = 0xbeef;\n\tin6.sin6_port = port_key;\n\n\tfor (i = 0; i < NR_TESTS; i++) {\n\t\tprintf(\"%s: \", test_names[i]);\n\n\t\tin6.sin6_addr.s6_addr16[7] = i;\n\t\tret = connect(-1, (struct sockaddr *)&in6, sizeof(in6));\n\t\tassert(ret == -1 && errno == EBADF);\n\n\t\tret = bpf_map_lookup_elem(REG_RESULT_H, &result_key, &result);\n\t\tassert(!ret);\n\n\t\tret = bpf_map_lookup_elem(INLINE_RESULT_H, &result_key,\n\t\t\t\t\t  &inline_result);\n\t\tassert(!ret);\n\n\t\tif (result != magic_result || inline_result != magic_result) {\n\t\t\tprintf(\"Error. result:%d inline_result:%d\\n\",\n\t\t\t       result, inline_result);\n\t\t\texit(1);\n\t\t}\n\n\t\tbpf_map_delete_elem(REG_RESULT_H, &result_key);\n\t\tbpf_map_delete_elem(INLINE_RESULT_H, &result_key);\n\n\t\tprintf(\"Pass\\n\");\n\t}\n}\n\nint main(int argc, char **argv)\n{\n\tstruct bpf_link *link = NULL;\n\tstruct bpf_program *prog;\n\tstruct bpf_object *obj;\n\tchar filename[256];\n\n\tsnprintf(filename, sizeof(filename), \"%s.bpf.o\", argv[0]);\n\tobj = bpf_object__open_file(filename, NULL);\n\tif (libbpf_get_error(obj)) {\n\t\tfprintf(stderr, \"ERROR: opening BPF object file failed\\n\");\n\t\treturn 0;\n\t}\n\n\tprog = bpf_object__find_program_by_name(obj, \"trace_sys_connect\");\n\tif (!prog) {\n\t\tprintf(\"finding a prog in obj file failed\\n\");\n\t\tgoto cleanup;\n\t}\n\n\t \n\tif (bpf_object__load(obj)) {\n\t\tfprintf(stderr, \"ERROR: loading BPF object file failed\\n\");\n\t\tgoto cleanup;\n\t}\n\n\tmap_fd[0] = bpf_object__find_map_fd_by_name(obj, \"port_a\");\n\tmap_fd[1] = bpf_object__find_map_fd_by_name(obj, \"port_h\");\n\tmap_fd[2] = bpf_object__find_map_fd_by_name(obj, \"reg_result_h\");\n\tmap_fd[3] = bpf_object__find_map_fd_by_name(obj, \"inline_result_h\");\n\tmap_fd[4] = bpf_object__find_map_fd_by_name(obj, \"a_of_port_a\");\n\tmap_fd[5] = bpf_object__find_map_fd_by_name(obj, \"h_of_port_a\");\n\tmap_fd[6] = bpf_object__find_map_fd_by_name(obj, \"h_of_port_h\");\n\tif (map_fd[0] < 0 || map_fd[1] < 0 || map_fd[2] < 0 ||\n\t    map_fd[3] < 0 || map_fd[4] < 0 || map_fd[5] < 0 || map_fd[6] < 0) {\n\t\tfprintf(stderr, \"ERROR: finding a map in obj file failed\\n\");\n\t\tgoto cleanup;\n\t}\n\n\tlink = bpf_program__attach(prog);\n\tif (libbpf_get_error(link)) {\n\t\tfprintf(stderr, \"ERROR: bpf_program__attach failed\\n\");\n\t\tlink = NULL;\n\t\tgoto cleanup;\n\t}\n\n\ttest_map_in_map();\n\ncleanup:\n\tbpf_link__destroy(link);\n\tbpf_object__close(obj);\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}