{
  "module_name": "cpustat_kern.c",
  "hash_id": "5b3f9023c505f90571f821b5ed1db86e68959a05edd287c6d0b9e6e27d41610e",
  "original_prompt": "Ingested from linux-6.6.14/samples/bpf/cpustat_kern.c",
  "human_readable_source": "\n\n#include <linux/version.h>\n#include <linux/ptrace.h>\n#include <uapi/linux/bpf.h>\n#include <bpf/bpf_helpers.h>\n\n \n#define MAX_CPU\t\t\t8\n#define MAX_PSTATE_ENTRIES\t5\n#define MAX_CSTATE_ENTRIES\t3\n\nstatic int cpu_opps[] = { 208000, 432000, 729000, 960000, 1200000 };\n\n \n#define MAP_OFF_CSTATE_TIME\t0\n#define MAP_OFF_CSTATE_IDX\t1\n#define MAP_OFF_PSTATE_TIME\t2\n#define MAP_OFF_PSTATE_IDX\t3\n#define MAP_OFF_NUM\t\t4\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_ARRAY);\n\t__type(key, u32);\n\t__type(value, u64);\n\t__uint(max_entries, MAX_CPU * MAP_OFF_NUM);\n} my_map SEC(\".maps\");\n\n \nstruct {\n\t__uint(type, BPF_MAP_TYPE_ARRAY);\n\t__type(key, u32);\n\t__type(value, u64);\n\t__uint(max_entries, MAX_CPU * MAX_CSTATE_ENTRIES);\n} cstate_duration SEC(\".maps\");\n\n \nstruct {\n\t__uint(type, BPF_MAP_TYPE_ARRAY);\n\t__type(key, u32);\n\t__type(value, u64);\n\t__uint(max_entries, MAX_CPU * MAX_PSTATE_ENTRIES);\n} pstate_duration SEC(\".maps\");\n\n \nstruct cpu_args {\n\tu64 pad;\n\tu32 state;\n\tu32 cpu_id;\n};\n\n \nstatic u32 find_cpu_pstate_idx(u32 frequency)\n{\n\tu32 i;\n\n\tfor (i = 0; i < sizeof(cpu_opps) / sizeof(u32); i++) {\n\t\tif (frequency == cpu_opps[i])\n\t\t\treturn i;\n\t}\n\n\treturn i;\n}\n\nSEC(\"tracepoint/power/cpu_idle\")\nint bpf_prog1(struct cpu_args *ctx)\n{\n\tu64 *cts, *pts, *cstate, *pstate, prev_state, cur_ts, delta;\n\tu32 key, cpu, pstate_idx;\n\tu64 *val;\n\n\tif (ctx->cpu_id > MAX_CPU)\n\t\treturn 0;\n\n\tcpu = ctx->cpu_id;\n\n\tkey = cpu * MAP_OFF_NUM + MAP_OFF_CSTATE_TIME;\n\tcts = bpf_map_lookup_elem(&my_map, &key);\n\tif (!cts)\n\t\treturn 0;\n\n\tkey = cpu * MAP_OFF_NUM + MAP_OFF_CSTATE_IDX;\n\tcstate = bpf_map_lookup_elem(&my_map, &key);\n\tif (!cstate)\n\t\treturn 0;\n\n\tkey = cpu * MAP_OFF_NUM + MAP_OFF_PSTATE_TIME;\n\tpts = bpf_map_lookup_elem(&my_map, &key);\n\tif (!pts)\n\t\treturn 0;\n\n\tkey = cpu * MAP_OFF_NUM + MAP_OFF_PSTATE_IDX;\n\tpstate = bpf_map_lookup_elem(&my_map, &key);\n\tif (!pstate)\n\t\treturn 0;\n\n\tprev_state = *cstate;\n\t*cstate = ctx->state;\n\n\tif (!*cts) {\n\t\t*cts = bpf_ktime_get_ns();\n\t\treturn 0;\n\t}\n\n\tcur_ts = bpf_ktime_get_ns();\n\tdelta = cur_ts - *cts;\n\t*cts = cur_ts;\n\n\t \n\tif (ctx->state != (u32)-1) {\n\n\t\t \n\t\tif (!*pts)\n\t\t\treturn 0;\n\n\t\tdelta = cur_ts - *pts;\n\n\t\tpstate_idx = find_cpu_pstate_idx(*pstate);\n\t\tif (pstate_idx >= MAX_PSTATE_ENTRIES)\n\t\t\treturn 0;\n\n\t\tkey = cpu * MAX_PSTATE_ENTRIES + pstate_idx;\n\t\tval = bpf_map_lookup_elem(&pstate_duration, &key);\n\t\tif (val)\n\t\t\t__sync_fetch_and_add((long *)val, delta);\n\n\t \n\t} else {\n\n\t\tkey = cpu * MAX_CSTATE_ENTRIES + prev_state;\n\t\tval = bpf_map_lookup_elem(&cstate_duration, &key);\n\t\tif (val)\n\t\t\t__sync_fetch_and_add((long *)val, delta);\n\t}\n\n\t \n\tif (*pts)\n\t\t*pts = cur_ts;\n\n\treturn 0;\n}\n\nSEC(\"tracepoint/power/cpu_frequency\")\nint bpf_prog2(struct cpu_args *ctx)\n{\n\tu64 *pts, *cstate, *pstate, prev_state, cur_ts, delta;\n\tu32 key, cpu, pstate_idx;\n\tu64 *val;\n\n\tcpu = ctx->cpu_id;\n\n\tkey = cpu * MAP_OFF_NUM + MAP_OFF_PSTATE_TIME;\n\tpts = bpf_map_lookup_elem(&my_map, &key);\n\tif (!pts)\n\t\treturn 0;\n\n\tkey = cpu * MAP_OFF_NUM + MAP_OFF_PSTATE_IDX;\n\tpstate = bpf_map_lookup_elem(&my_map, &key);\n\tif (!pstate)\n\t\treturn 0;\n\n\tkey = cpu * MAP_OFF_NUM + MAP_OFF_CSTATE_IDX;\n\tcstate = bpf_map_lookup_elem(&my_map, &key);\n\tif (!cstate)\n\t\treturn 0;\n\n\tprev_state = *pstate;\n\t*pstate = ctx->state;\n\n\tif (!*pts) {\n\t\t*pts = bpf_ktime_get_ns();\n\t\treturn 0;\n\t}\n\n\tcur_ts = bpf_ktime_get_ns();\n\tdelta = cur_ts - *pts;\n\t*pts = cur_ts;\n\n\t \n\tif (*cstate != (u32)(-1))\n\t\treturn 0;\n\n\t \n\tpstate_idx = find_cpu_pstate_idx(*pstate);\n\tif (pstate_idx >= MAX_PSTATE_ENTRIES)\n\t\treturn 0;\n\n\tkey = cpu * MAX_PSTATE_ENTRIES + pstate_idx;\n\tval = bpf_map_lookup_elem(&pstate_duration, &key);\n\tif (val)\n\t\t__sync_fetch_and_add((long *)val, delta);\n\n\treturn 0;\n}\n\nchar _license[] SEC(\"license\") = \"GPL\";\nu32 _version SEC(\"version\") = LINUX_VERSION_CODE;\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}