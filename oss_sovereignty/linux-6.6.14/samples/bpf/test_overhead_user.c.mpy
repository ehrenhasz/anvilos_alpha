{
  "module_name": "test_overhead_user.c",
  "hash_id": "1eac46542fd04b78257919b01533fee07c64e8d2002ac0d5c4bfccbcf63ec741",
  "original_prompt": "Ingested from linux-6.6.14/samples/bpf/test_overhead_user.c",
  "human_readable_source": "\n \n#define _GNU_SOURCE\n#include <sched.h>\n#include <errno.h>\n#include <stdio.h>\n#include <sys/types.h>\n#include <asm/unistd.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <assert.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <linux/bpf.h>\n#include <string.h>\n#include <time.h>\n#include <bpf/bpf.h>\n#include <bpf/libbpf.h>\n\n#define MAX_CNT 1000000\n#define DUMMY_IP \"127.0.0.1\"\n#define DUMMY_PORT 80\n\nstatic struct bpf_link *links[2];\nstatic struct bpf_object *obj;\nstatic int cnt;\n\nstatic __u64 time_get_ns(void)\n{\n\tstruct timespec ts;\n\n\tclock_gettime(CLOCK_MONOTONIC, &ts);\n\treturn ts.tv_sec * 1000000000ull + ts.tv_nsec;\n}\n\nstatic void test_task_rename(int cpu)\n{\n\tchar buf[] = \"test\\n\";\n\t__u64 start_time;\n\tint i, fd;\n\n\tfd = open(\"/proc/self/comm\", O_WRONLY|O_TRUNC);\n\tif (fd < 0) {\n\t\tprintf(\"couldn't open /proc\\n\");\n\t\texit(1);\n\t}\n\tstart_time = time_get_ns();\n\tfor (i = 0; i < MAX_CNT; i++) {\n\t\tif (write(fd, buf, sizeof(buf)) < 0) {\n\t\t\tprintf(\"task rename failed: %s\\n\", strerror(errno));\n\t\t\tclose(fd);\n\t\t\treturn;\n\t\t}\n\t}\n\tprintf(\"task_rename:%d: %lld events per sec\\n\",\n\t       cpu, MAX_CNT * 1000000000ll / (time_get_ns() - start_time));\n\tclose(fd);\n}\n\nstatic void test_fib_table_lookup(int cpu)\n{\n\tstruct sockaddr_in addr;\n\tchar buf[] = \"test\\n\";\n\t__u64 start_time;\n\tint i, fd;\n\n\tfd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);\n\tif (fd < 0) {\n\t\tprintf(\"couldn't open socket\\n\");\n\t\texit(1);\n\t}\n\tmemset((char *)&addr, 0, sizeof(addr));\n\taddr.sin_addr.s_addr = inet_addr(DUMMY_IP);\n\taddr.sin_port = htons(DUMMY_PORT);\n\taddr.sin_family = AF_INET;\n\tstart_time = time_get_ns();\n\tfor (i = 0; i < MAX_CNT; i++) {\n\t\tif (sendto(fd, buf, strlen(buf), 0,\n\t\t\t   (struct sockaddr *)&addr, sizeof(addr)) < 0) {\n\t\t\tprintf(\"failed to start ping: %s\\n\", strerror(errno));\n\t\t\tclose(fd);\n\t\t\treturn;\n\t\t}\n\t}\n\tprintf(\"fib_table_lookup:%d: %lld events per sec\\n\",\n\t       cpu, MAX_CNT * 1000000000ll / (time_get_ns() - start_time));\n\tclose(fd);\n}\n\nstatic void loop(int cpu, int flags)\n{\n\tcpu_set_t cpuset;\n\n\tCPU_ZERO(&cpuset);\n\tCPU_SET(cpu, &cpuset);\n\tsched_setaffinity(0, sizeof(cpuset), &cpuset);\n\n\tif (flags & 1)\n\t\ttest_task_rename(cpu);\n\tif (flags & 2)\n\t\ttest_fib_table_lookup(cpu);\n}\n\nstatic void run_perf_test(int tasks, int flags)\n{\n\tpid_t pid[tasks];\n\tint i;\n\n\tfor (i = 0; i < tasks; i++) {\n\t\tpid[i] = fork();\n\t\tif (pid[i] == 0) {\n\t\t\tloop(i, flags);\n\t\t\texit(0);\n\t\t} else if (pid[i] == -1) {\n\t\t\tprintf(\"couldn't spawn #%d process\\n\", i);\n\t\t\texit(1);\n\t\t}\n\t}\n\tfor (i = 0; i < tasks; i++) {\n\t\tint status;\n\n\t\tassert(waitpid(pid[i], &status, 0) == pid[i]);\n\t\tassert(status == 0);\n\t}\n}\n\nstatic int load_progs(char *filename)\n{\n\tstruct bpf_program *prog;\n\tint err = 0;\n\n\tobj = bpf_object__open_file(filename, NULL);\n\terr = libbpf_get_error(obj);\n\tif (err < 0) {\n\t\tfprintf(stderr, \"ERROR: opening BPF object file failed\\n\");\n\t\treturn err;\n\t}\n\n\t \n\terr = bpf_object__load(obj);\n\tif (err < 0) {\n\t\tfprintf(stderr, \"ERROR: loading BPF object file failed\\n\");\n\t\treturn err;\n\t}\n\n\tbpf_object__for_each_program(prog, obj) {\n\t\tlinks[cnt] = bpf_program__attach(prog);\n\t\terr = libbpf_get_error(links[cnt]);\n\t\tif (err < 0) {\n\t\t\tfprintf(stderr, \"ERROR: bpf_program__attach failed\\n\");\n\t\t\tlinks[cnt] = NULL;\n\t\t\treturn err;\n\t\t}\n\t\tcnt++;\n\t}\n\n\treturn err;\n}\n\nstatic void unload_progs(void)\n{\n\twhile (cnt)\n\t\tbpf_link__destroy(links[--cnt]);\n\n\tbpf_object__close(obj);\n}\n\nint main(int argc, char **argv)\n{\n\tint num_cpu = sysconf(_SC_NPROCESSORS_ONLN);\n\tint test_flags = ~0;\n\tchar filename[256];\n\tint err = 0;\n\n\n\tif (argc > 1)\n\t\ttest_flags = atoi(argv[1]) ? : test_flags;\n\tif (argc > 2)\n\t\tnum_cpu = atoi(argv[2]) ? : num_cpu;\n\n\tif (test_flags & 0x3) {\n\t\tprintf(\"BASE\\n\");\n\t\trun_perf_test(num_cpu, test_flags);\n\t}\n\n\tif (test_flags & 0xC) {\n\t\tsnprintf(filename, sizeof(filename),\n\t\t\t \"%s_kprobe.bpf.o\", argv[0]);\n\n\t\tprintf(\"w/KPROBE\\n\");\n\t\terr = load_progs(filename);\n\t\tif (!err)\n\t\t\trun_perf_test(num_cpu, test_flags >> 2);\n\n\t\tunload_progs();\n\t}\n\n\tif (test_flags & 0x30) {\n\t\tsnprintf(filename, sizeof(filename),\n\t\t\t \"%s_tp.bpf.o\", argv[0]);\n\t\tprintf(\"w/TRACEPOINT\\n\");\n\t\terr = load_progs(filename);\n\t\tif (!err)\n\t\t\trun_perf_test(num_cpu, test_flags >> 4);\n\n\t\tunload_progs();\n\t}\n\n\tif (test_flags & 0xC0) {\n\t\tsnprintf(filename, sizeof(filename),\n\t\t\t \"%s_raw_tp.bpf.o\", argv[0]);\n\t\tprintf(\"w/RAW_TRACEPOINT\\n\");\n\t\terr = load_progs(filename);\n\t\tif (!err)\n\t\t\trun_perf_test(num_cpu, test_flags >> 6);\n\n\t\tunload_progs();\n\t}\n\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}