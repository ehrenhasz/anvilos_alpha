{
  "module_name": "map_perf_test_user.c",
  "hash_id": "b36ffe0a716773839ef6f9a6012b53cdc4965573a78c93b9d7eca13018ec9c51",
  "original_prompt": "Ingested from linux-6.6.14/samples/bpf/map_perf_test_user.c",
  "human_readable_source": "\n \n#define _GNU_SOURCE\n#include <sched.h>\n#include <stdio.h>\n#include <sys/types.h>\n#include <asm/unistd.h>\n#include <unistd.h>\n#include <assert.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <string.h>\n#include <time.h>\n#include <arpa/inet.h>\n#include <errno.h>\n\n#include <bpf/bpf.h>\n#include <bpf/libbpf.h>\n\n#define TEST_BIT(t) (1U << (t))\n#define MAX_NR_CPUS 1024\n\nstatic __u64 time_get_ns(void)\n{\n\tstruct timespec ts;\n\n\tclock_gettime(CLOCK_MONOTONIC, &ts);\n\treturn ts.tv_sec * 1000000000ull + ts.tv_nsec;\n}\n\nenum test_type {\n\tHASH_PREALLOC,\n\tPERCPU_HASH_PREALLOC,\n\tHASH_KMALLOC,\n\tPERCPU_HASH_KMALLOC,\n\tLRU_HASH_PREALLOC,\n\tNOCOMMON_LRU_HASH_PREALLOC,\n\tLPM_KMALLOC,\n\tHASH_LOOKUP,\n\tARRAY_LOOKUP,\n\tINNER_LRU_HASH_PREALLOC,\n\tLRU_HASH_LOOKUP,\n\tNR_TESTS,\n};\n\nconst char *test_map_names[NR_TESTS] = {\n\t[HASH_PREALLOC] = \"hash_map\",\n\t[PERCPU_HASH_PREALLOC] = \"percpu_hash_map\",\n\t[HASH_KMALLOC] = \"hash_map_alloc\",\n\t[PERCPU_HASH_KMALLOC] = \"percpu_hash_map_alloc\",\n\t[LRU_HASH_PREALLOC] = \"lru_hash_map\",\n\t[NOCOMMON_LRU_HASH_PREALLOC] = \"nocommon_lru_hash_map\",\n\t[LPM_KMALLOC] = \"lpm_trie_map_alloc\",\n\t[HASH_LOOKUP] = \"hash_map\",\n\t[ARRAY_LOOKUP] = \"array_map\",\n\t[INNER_LRU_HASH_PREALLOC] = \"inner_lru_hash_map\",\n\t[LRU_HASH_LOOKUP] = \"lru_hash_lookup_map\",\n};\n\nenum map_idx {\n\tarray_of_lru_hashs_idx,\n\thash_map_alloc_idx,\n\tlru_hash_lookup_idx,\n\tNR_IDXES,\n};\n\nstatic int map_fd[NR_IDXES];\n\nstatic int test_flags = ~0;\nstatic uint32_t num_map_entries;\nstatic uint32_t inner_lru_hash_size;\nstatic int lru_hash_lookup_test_entries = 32;\nstatic uint32_t max_cnt = 10000;\n\nstatic int check_test_flags(enum test_type t)\n{\n\treturn test_flags & TEST_BIT(t);\n}\n\nstatic void test_hash_prealloc(int cpu)\n{\n\t__u64 start_time;\n\tint i;\n\n\tstart_time = time_get_ns();\n\tfor (i = 0; i < max_cnt; i++)\n\t\tsyscall(__NR_getuid);\n\tprintf(\"%d:hash_map_perf pre-alloc %lld events per sec\\n\",\n\t       cpu, max_cnt * 1000000000ll / (time_get_ns() - start_time));\n}\n\nstatic int pre_test_lru_hash_lookup(int tasks)\n{\n\tint fd = map_fd[lru_hash_lookup_idx];\n\tuint32_t key;\n\tlong val = 1;\n\tint ret;\n\n\tif (num_map_entries > lru_hash_lookup_test_entries)\n\t\tlru_hash_lookup_test_entries = num_map_entries;\n\n\t \n\tfor (key = 0; key < lru_hash_lookup_test_entries; key++) {\n\t\tret = bpf_map_update_elem(fd, &key, &val, BPF_NOEXIST);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void do_test_lru(enum test_type test, int cpu)\n{\n\tstatic int inner_lru_map_fds[MAX_NR_CPUS];\n\n\tstruct sockaddr_in6 in6 = { .sin6_family = AF_INET6 };\n\tconst char *test_name;\n\t__u64 start_time;\n\tint i, ret;\n\n\tif (test == INNER_LRU_HASH_PREALLOC && cpu) {\n\t\t \n\t\tint outer_fd = map_fd[array_of_lru_hashs_idx];\n\t\tunsigned int mycpu, mynode;\n\t\tLIBBPF_OPTS(bpf_map_create_opts, opts,\n\t\t\t.map_flags = BPF_F_NUMA_NODE,\n\t\t);\n\n\t\tassert(cpu < MAX_NR_CPUS);\n\n\t\tret = syscall(__NR_getcpu, &mycpu, &mynode, NULL);\n\t\tassert(!ret);\n\n\t\topts.numa_node = mynode;\n\t\tinner_lru_map_fds[cpu] =\n\t\t\tbpf_map_create(BPF_MAP_TYPE_LRU_HASH,\n\t\t\t\t       test_map_names[INNER_LRU_HASH_PREALLOC],\n\t\t\t\t       sizeof(uint32_t),\n\t\t\t\t       sizeof(long),\n\t\t\t\t       inner_lru_hash_size, &opts);\n\t\tif (inner_lru_map_fds[cpu] == -1) {\n\t\t\tprintf(\"cannot create BPF_MAP_TYPE_LRU_HASH %s(%d)\\n\",\n\t\t\t       strerror(errno), errno);\n\t\t\texit(1);\n\t\t}\n\n\t\tret = bpf_map_update_elem(outer_fd, &cpu,\n\t\t\t\t\t  &inner_lru_map_fds[cpu],\n\t\t\t\t\t  BPF_ANY);\n\t\tif (ret) {\n\t\t\tprintf(\"cannot update ARRAY_OF_LRU_HASHS with key:%u. %s(%d)\\n\",\n\t\t\t       cpu, strerror(errno), errno);\n\t\t\texit(1);\n\t\t}\n\t}\n\n\tin6.sin6_addr.s6_addr16[0] = 0xdead;\n\tin6.sin6_addr.s6_addr16[1] = 0xbeef;\n\n\tif (test == LRU_HASH_PREALLOC) {\n\t\ttest_name = \"lru_hash_map_perf\";\n\t\tin6.sin6_addr.s6_addr16[2] = 0;\n\t} else if (test == NOCOMMON_LRU_HASH_PREALLOC) {\n\t\ttest_name = \"nocommon_lru_hash_map_perf\";\n\t\tin6.sin6_addr.s6_addr16[2] = 1;\n\t} else if (test == INNER_LRU_HASH_PREALLOC) {\n\t\ttest_name = \"inner_lru_hash_map_perf\";\n\t\tin6.sin6_addr.s6_addr16[2] = 2;\n\t} else if (test == LRU_HASH_LOOKUP) {\n\t\ttest_name = \"lru_hash_lookup_perf\";\n\t\tin6.sin6_addr.s6_addr16[2] = 3;\n\t\tin6.sin6_addr.s6_addr32[3] = 0;\n\t} else {\n\t\tassert(0);\n\t}\n\n\tstart_time = time_get_ns();\n\tfor (i = 0; i < max_cnt; i++) {\n\t\tret = connect(-1, (const struct sockaddr *)&in6, sizeof(in6));\n\t\tassert(ret == -1 && errno == EBADF);\n\t\tif (in6.sin6_addr.s6_addr32[3] <\n\t\t    lru_hash_lookup_test_entries - 32)\n\t\t\tin6.sin6_addr.s6_addr32[3] += 32;\n\t\telse\n\t\t\tin6.sin6_addr.s6_addr32[3] = 0;\n\t}\n\tprintf(\"%d:%s pre-alloc %lld events per sec\\n\",\n\t       cpu, test_name,\n\t       max_cnt * 1000000000ll / (time_get_ns() - start_time));\n}\n\nstatic void test_lru_hash_prealloc(int cpu)\n{\n\tdo_test_lru(LRU_HASH_PREALLOC, cpu);\n}\n\nstatic void test_nocommon_lru_hash_prealloc(int cpu)\n{\n\tdo_test_lru(NOCOMMON_LRU_HASH_PREALLOC, cpu);\n}\n\nstatic void test_inner_lru_hash_prealloc(int cpu)\n{\n\tdo_test_lru(INNER_LRU_HASH_PREALLOC, cpu);\n}\n\nstatic void test_lru_hash_lookup(int cpu)\n{\n\tdo_test_lru(LRU_HASH_LOOKUP, cpu);\n}\n\nstatic void test_percpu_hash_prealloc(int cpu)\n{\n\t__u64 start_time;\n\tint i;\n\n\tstart_time = time_get_ns();\n\tfor (i = 0; i < max_cnt; i++)\n\t\tsyscall(__NR_geteuid);\n\tprintf(\"%d:percpu_hash_map_perf pre-alloc %lld events per sec\\n\",\n\t       cpu, max_cnt * 1000000000ll / (time_get_ns() - start_time));\n}\n\nstatic void test_hash_kmalloc(int cpu)\n{\n\t__u64 start_time;\n\tint i;\n\n\tstart_time = time_get_ns();\n\tfor (i = 0; i < max_cnt; i++)\n\t\tsyscall(__NR_getgid);\n\tprintf(\"%d:hash_map_perf kmalloc %lld events per sec\\n\",\n\t       cpu, max_cnt * 1000000000ll / (time_get_ns() - start_time));\n}\n\nstatic void test_percpu_hash_kmalloc(int cpu)\n{\n\t__u64 start_time;\n\tint i;\n\n\tstart_time = time_get_ns();\n\tfor (i = 0; i < max_cnt; i++)\n\t\tsyscall(__NR_getegid);\n\tprintf(\"%d:percpu_hash_map_perf kmalloc %lld events per sec\\n\",\n\t       cpu, max_cnt * 1000000000ll / (time_get_ns() - start_time));\n}\n\nstatic void test_lpm_kmalloc(int cpu)\n{\n\t__u64 start_time;\n\tint i;\n\n\tstart_time = time_get_ns();\n\tfor (i = 0; i < max_cnt; i++)\n\t\tsyscall(__NR_gettid);\n\tprintf(\"%d:lpm_perf kmalloc %lld events per sec\\n\",\n\t       cpu, max_cnt * 1000000000ll / (time_get_ns() - start_time));\n}\n\nstatic void test_hash_lookup(int cpu)\n{\n\t__u64 start_time;\n\tint i;\n\n\tstart_time = time_get_ns();\n\tfor (i = 0; i < max_cnt; i++)\n\t\tsyscall(__NR_getpgid, 0);\n\tprintf(\"%d:hash_lookup %lld lookups per sec\\n\",\n\t       cpu, max_cnt * 1000000000ll * 64 / (time_get_ns() - start_time));\n}\n\nstatic void test_array_lookup(int cpu)\n{\n\t__u64 start_time;\n\tint i;\n\n\tstart_time = time_get_ns();\n\tfor (i = 0; i < max_cnt; i++)\n\t\tsyscall(__NR_getppid, 0);\n\tprintf(\"%d:array_lookup %lld lookups per sec\\n\",\n\t       cpu, max_cnt * 1000000000ll * 64 / (time_get_ns() - start_time));\n}\n\ntypedef int (*pre_test_func)(int tasks);\nconst pre_test_func pre_test_funcs[] = {\n\t[LRU_HASH_LOOKUP] = pre_test_lru_hash_lookup,\n};\n\ntypedef void (*test_func)(int cpu);\nconst test_func test_funcs[] = {\n\t[HASH_PREALLOC] = test_hash_prealloc,\n\t[PERCPU_HASH_PREALLOC] = test_percpu_hash_prealloc,\n\t[HASH_KMALLOC] = test_hash_kmalloc,\n\t[PERCPU_HASH_KMALLOC] = test_percpu_hash_kmalloc,\n\t[LRU_HASH_PREALLOC] = test_lru_hash_prealloc,\n\t[NOCOMMON_LRU_HASH_PREALLOC] = test_nocommon_lru_hash_prealloc,\n\t[LPM_KMALLOC] = test_lpm_kmalloc,\n\t[HASH_LOOKUP] = test_hash_lookup,\n\t[ARRAY_LOOKUP] = test_array_lookup,\n\t[INNER_LRU_HASH_PREALLOC] = test_inner_lru_hash_prealloc,\n\t[LRU_HASH_LOOKUP] = test_lru_hash_lookup,\n};\n\nstatic int pre_test(int tasks)\n{\n\tint i;\n\n\tfor (i = 0; i < NR_TESTS; i++) {\n\t\tif (pre_test_funcs[i] && check_test_flags(i)) {\n\t\t\tint ret = pre_test_funcs[i](tasks);\n\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void loop(int cpu)\n{\n\tcpu_set_t cpuset;\n\tint i;\n\n\tCPU_ZERO(&cpuset);\n\tCPU_SET(cpu, &cpuset);\n\tsched_setaffinity(0, sizeof(cpuset), &cpuset);\n\n\tfor (i = 0; i < NR_TESTS; i++) {\n\t\tif (check_test_flags(i))\n\t\t\ttest_funcs[i](cpu);\n\t}\n}\n\nstatic void run_perf_test(int tasks)\n{\n\tpid_t pid[tasks];\n\tint i;\n\n\tassert(!pre_test(tasks));\n\n\tfor (i = 0; i < tasks; i++) {\n\t\tpid[i] = fork();\n\t\tif (pid[i] == 0) {\n\t\t\tloop(i);\n\t\t\texit(0);\n\t\t} else if (pid[i] == -1) {\n\t\t\tprintf(\"couldn't spawn #%d process\\n\", i);\n\t\t\texit(1);\n\t\t}\n\t}\n\tfor (i = 0; i < tasks; i++) {\n\t\tint status;\n\n\t\tassert(waitpid(pid[i], &status, 0) == pid[i]);\n\t\tassert(status == 0);\n\t}\n}\n\nstatic void fill_lpm_trie(void)\n{\n\tstruct bpf_lpm_trie_key *key;\n\tunsigned long value = 0;\n\tunsigned int i;\n\tint r;\n\n\tkey = alloca(sizeof(*key) + 4);\n\tkey->prefixlen = 32;\n\n\tfor (i = 0; i < 512; ++i) {\n\t\tkey->prefixlen = rand() % 33;\n\t\tkey->data[0] = rand() & 0xff;\n\t\tkey->data[1] = rand() & 0xff;\n\t\tkey->data[2] = rand() & 0xff;\n\t\tkey->data[3] = rand() & 0xff;\n\t\tr = bpf_map_update_elem(map_fd[hash_map_alloc_idx],\n\t\t\t\t\tkey, &value, 0);\n\t\tassert(!r);\n\t}\n\n\tkey->prefixlen = 32;\n\tkey->data[0] = 192;\n\tkey->data[1] = 168;\n\tkey->data[2] = 0;\n\tkey->data[3] = 1;\n\tvalue = 128;\n\n\tr = bpf_map_update_elem(map_fd[hash_map_alloc_idx], key, &value, 0);\n\tassert(!r);\n}\n\nstatic void fixup_map(struct bpf_object *obj)\n{\n\tstruct bpf_map *map;\n\tint i;\n\n\tbpf_object__for_each_map(map, obj) {\n\t\tconst char *name = bpf_map__name(map);\n\n\t\t \n\t\tfor (i = 0; i < NR_TESTS; i++) {\n\t\t\tif (!strcmp(test_map_names[i], name) &&\n\t\t\t    (check_test_flags(i))) {\n\t\t\t\tbpf_map__set_max_entries(map, num_map_entries);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t}\n\n\tinner_lru_hash_size = num_map_entries;\n}\n\nint main(int argc, char **argv)\n{\n\tint nr_cpus = sysconf(_SC_NPROCESSORS_ONLN);\n\tstruct bpf_link *links[8];\n\tstruct bpf_program *prog;\n\tstruct bpf_object *obj;\n\tstruct bpf_map *map;\n\tchar filename[256];\n\tint i = 0;\n\n\tif (argc > 1)\n\t\ttest_flags = atoi(argv[1]) ? : test_flags;\n\n\tif (argc > 2)\n\t\tnr_cpus = atoi(argv[2]) ? : nr_cpus;\n\n\tif (argc > 3)\n\t\tnum_map_entries = atoi(argv[3]);\n\n\tif (argc > 4)\n\t\tmax_cnt = atoi(argv[4]);\n\n\tsnprintf(filename, sizeof(filename), \"%s.bpf.o\", argv[0]);\n\tobj = bpf_object__open_file(filename, NULL);\n\tif (libbpf_get_error(obj)) {\n\t\tfprintf(stderr, \"ERROR: opening BPF object file failed\\n\");\n\t\treturn 0;\n\t}\n\n\tmap = bpf_object__find_map_by_name(obj, \"inner_lru_hash_map\");\n\tif (libbpf_get_error(map)) {\n\t\tfprintf(stderr, \"ERROR: finding a map in obj file failed\\n\");\n\t\tgoto cleanup;\n\t}\n\n\tinner_lru_hash_size = bpf_map__max_entries(map);\n\tif (!inner_lru_hash_size) {\n\t\tfprintf(stderr, \"ERROR: failed to get map attribute\\n\");\n\t\tgoto cleanup;\n\t}\n\n\t \n\tif (num_map_entries > 0)\n\t\tfixup_map(obj);\n\n\t \n\tif (bpf_object__load(obj)) {\n\t\tfprintf(stderr, \"ERROR: loading BPF object file failed\\n\");\n\t\tgoto cleanup;\n\t}\n\n\tmap_fd[0] = bpf_object__find_map_fd_by_name(obj, \"array_of_lru_hashs\");\n\tmap_fd[1] = bpf_object__find_map_fd_by_name(obj, \"hash_map_alloc\");\n\tmap_fd[2] = bpf_object__find_map_fd_by_name(obj, \"lru_hash_lookup_map\");\n\tif (map_fd[0] < 0 || map_fd[1] < 0 || map_fd[2] < 0) {\n\t\tfprintf(stderr, \"ERROR: finding a map in obj file failed\\n\");\n\t\tgoto cleanup;\n\t}\n\n\tbpf_object__for_each_program(prog, obj) {\n\t\tlinks[i] = bpf_program__attach(prog);\n\t\tif (libbpf_get_error(links[i])) {\n\t\t\tfprintf(stderr, \"ERROR: bpf_program__attach failed\\n\");\n\t\t\tlinks[i] = NULL;\n\t\t\tgoto cleanup;\n\t\t}\n\t\ti++;\n\t}\n\n\tfill_lpm_trie();\n\n\trun_perf_test(nr_cpus);\n\ncleanup:\n\tfor (i--; i >= 0; i--)\n\t\tbpf_link__destroy(links[i]);\n\n\tbpf_object__close(obj);\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}