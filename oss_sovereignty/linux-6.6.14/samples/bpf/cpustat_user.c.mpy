{
  "module_name": "cpustat_user.c",
  "hash_id": "797666e1dcee9b10947edf50768f5dac135f6b087cb127176207979d6b348300",
  "original_prompt": "Ingested from linux-6.6.14/samples/bpf/cpustat_user.c",
  "human_readable_source": "\n\n#define _GNU_SOURCE\n#include <errno.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sched.h>\n#include <string.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <locale.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <sys/wait.h>\n\n#include <bpf/bpf.h>\n#include <bpf/libbpf.h>\n\nstatic int cstate_map_fd, pstate_map_fd;\n\n#define MAX_CPU\t\t\t8\n#define MAX_PSTATE_ENTRIES\t5\n#define MAX_CSTATE_ENTRIES\t3\n#define MAX_STARS\t\t40\n\n#define CPUFREQ_MAX_SYSFS_PATH\t\"/sys/devices/system/cpu/cpu0/cpufreq/scaling_max_freq\"\n#define CPUFREQ_LOWEST_FREQ\t\"208000\"\n#define CPUFREQ_HIGHEST_FREQ\t\"12000000\"\n\nstruct cpu_stat_data {\n\tunsigned long cstate[MAX_CSTATE_ENTRIES];\n\tunsigned long pstate[MAX_PSTATE_ENTRIES];\n};\n\nstatic struct cpu_stat_data stat_data[MAX_CPU];\n\nstatic void cpu_stat_print(void)\n{\n\tint i, j;\n\tchar state_str[sizeof(\"cstate-9\")];\n\tstruct cpu_stat_data *data;\n\n\t \n\tprintf(\"\\033[2J\");\n\n\t \n\tprintf(\"\\nCPU states statistics:\\n\");\n\tprintf(\"%-10s \", \"state(ms)\");\n\n\tfor (i = 0; i < MAX_CSTATE_ENTRIES; i++) {\n\t\tsprintf(state_str, \"cstate-%d\", i);\n\t\tprintf(\"%-11s \", state_str);\n\t}\n\n\tfor (i = 0; i < MAX_PSTATE_ENTRIES; i++) {\n\t\tsprintf(state_str, \"pstate-%d\", i);\n\t\tprintf(\"%-11s \", state_str);\n\t}\n\n\tprintf(\"\\n\");\n\n\tfor (j = 0; j < MAX_CPU; j++) {\n\t\tdata = &stat_data[j];\n\n\t\tprintf(\"CPU-%-6d \", j);\n\t\tfor (i = 0; i < MAX_CSTATE_ENTRIES; i++)\n\t\t\tprintf(\"%-11ld \", data->cstate[i] / 1000000);\n\n\t\tfor (i = 0; i < MAX_PSTATE_ENTRIES; i++)\n\t\t\tprintf(\"%-11ld \", data->pstate[i] / 1000000);\n\n\t\tprintf(\"\\n\");\n\t}\n}\n\nstatic void cpu_stat_update(int cstate_fd, int pstate_fd)\n{\n\tunsigned long key, value;\n\tint c, i;\n\n\tfor (c = 0; c < MAX_CPU; c++) {\n\t\tfor (i = 0; i < MAX_CSTATE_ENTRIES; i++) {\n\t\t\tkey = c * MAX_CSTATE_ENTRIES + i;\n\t\t\tbpf_map_lookup_elem(cstate_fd, &key, &value);\n\t\t\tstat_data[c].cstate[i] = value;\n\t\t}\n\n\t\tfor (i = 0; i < MAX_PSTATE_ENTRIES; i++) {\n\t\t\tkey = c * MAX_PSTATE_ENTRIES + i;\n\t\t\tbpf_map_lookup_elem(pstate_fd, &key, &value);\n\t\t\tstat_data[c].pstate[i] = value;\n\t\t}\n\t}\n}\n\n \nstatic int cpu_stat_inject_cpu_idle_event(void)\n{\n\tint rcpu, i, ret;\n\tcpu_set_t cpumask;\n\tcpu_set_t original_cpumask;\n\n\tret = sysconf(_SC_NPROCESSORS_CONF);\n\tif (ret < 0)\n\t\treturn -1;\n\n\trcpu = sched_getcpu();\n\tif (rcpu < 0)\n\t\treturn -1;\n\n\t \n\tsched_getaffinity(0, sizeof(original_cpumask), &original_cpumask);\n\n\tfor (i = 0; i < ret; i++) {\n\n\t\t \n\t\tif (i == rcpu)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (!CPU_ISSET(i, &original_cpumask))\n\t\t\tcontinue;\n\n\t\tCPU_ZERO(&cpumask);\n\t\tCPU_SET(i, &cpumask);\n\n\t\tsched_setaffinity(0, sizeof(cpumask), &cpumask);\n\t}\n\n\t \n\tsched_setaffinity(0, sizeof(original_cpumask), &original_cpumask);\n\treturn 0;\n}\n\n \nstatic int cpu_stat_inject_cpu_frequency_event(void)\n{\n\tint len, fd;\n\n\tfd = open(CPUFREQ_MAX_SYSFS_PATH, O_WRONLY);\n\tif (fd < 0) {\n\t\tprintf(\"failed to open scaling_max_freq, errno=%d\\n\", errno);\n\t\treturn fd;\n\t}\n\n\tlen = write(fd, CPUFREQ_LOWEST_FREQ, strlen(CPUFREQ_LOWEST_FREQ));\n\tif (len < 0) {\n\t\tprintf(\"failed to open scaling_max_freq, errno=%d\\n\", errno);\n\t\tgoto err;\n\t}\n\n\tlen = write(fd, CPUFREQ_HIGHEST_FREQ, strlen(CPUFREQ_HIGHEST_FREQ));\n\tif (len < 0) {\n\t\tprintf(\"failed to open scaling_max_freq, errno=%d\\n\", errno);\n\t\tgoto err;\n\t}\n\nerr:\n\tclose(fd);\n\treturn len;\n}\n\nstatic void int_exit(int sig)\n{\n\tcpu_stat_inject_cpu_idle_event();\n\tcpu_stat_inject_cpu_frequency_event();\n\tcpu_stat_update(cstate_map_fd, pstate_map_fd);\n\tcpu_stat_print();\n\texit(0);\n}\n\nint main(int argc, char **argv)\n{\n\tstruct bpf_link *link = NULL;\n\tstruct bpf_program *prog;\n\tstruct bpf_object *obj;\n\tchar filename[256];\n\tint ret;\n\n\tsnprintf(filename, sizeof(filename), \"%s_kern.o\", argv[0]);\n\tobj = bpf_object__open_file(filename, NULL);\n\tif (libbpf_get_error(obj)) {\n\t\tfprintf(stderr, \"ERROR: opening BPF object file failed\\n\");\n\t\treturn 0;\n\t}\n\n\tprog = bpf_object__find_program_by_name(obj, \"bpf_prog1\");\n\tif (!prog) {\n\t\tprintf(\"finding a prog in obj file failed\\n\");\n\t\tgoto cleanup;\n\t}\n\n\t \n\tif (bpf_object__load(obj)) {\n\t\tfprintf(stderr, \"ERROR: loading BPF object file failed\\n\");\n\t\tgoto cleanup;\n\t}\n\n\tcstate_map_fd = bpf_object__find_map_fd_by_name(obj, \"cstate_duration\");\n\tpstate_map_fd = bpf_object__find_map_fd_by_name(obj, \"pstate_duration\");\n\tif (cstate_map_fd < 0 || pstate_map_fd < 0) {\n\t\tfprintf(stderr, \"ERROR: finding a map in obj file failed\\n\");\n\t\tgoto cleanup;\n\t}\n\n\tlink = bpf_program__attach(prog);\n\tif (libbpf_get_error(link)) {\n\t\tfprintf(stderr, \"ERROR: bpf_program__attach failed\\n\");\n\t\tlink = NULL;\n\t\tgoto cleanup;\n\t}\n\n\tret = cpu_stat_inject_cpu_idle_event();\n\tif (ret < 0)\n\t\treturn 1;\n\n\tret = cpu_stat_inject_cpu_frequency_event();\n\tif (ret < 0)\n\t\treturn 1;\n\n\tsignal(SIGINT, int_exit);\n\tsignal(SIGTERM, int_exit);\n\n\twhile (1) {\n\t\tcpu_stat_update(cstate_map_fd, pstate_map_fd);\n\t\tcpu_stat_print();\n\t\tsleep(5);\n\t}\n\ncleanup:\n\tbpf_link__destroy(link);\n\tbpf_object__close(obj);\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}