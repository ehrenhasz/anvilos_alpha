{
  "module_name": "sockex3_kern.c",
  "hash_id": "57bfe316dd46786589da1769e50beb77883f11fc90d5322eae57a0617fde0ee8",
  "original_prompt": "Ingested from linux-6.6.14/samples/bpf/sockex3_kern.c",
  "human_readable_source": " \n#include <uapi/linux/bpf.h>\n#include <uapi/linux/in.h>\n#include <uapi/linux/if.h>\n#include <uapi/linux/if_ether.h>\n#include <uapi/linux/ip.h>\n#include <uapi/linux/ipv6.h>\n#include <uapi/linux/if_tunnel.h>\n#include <uapi/linux/mpls.h>\n#include <bpf/bpf_helpers.h>\n#include \"bpf_legacy.h\"\n#define IP_MF\t\t0x2000\n#define IP_OFFSET\t0x1FFF\n\n#define PARSE_VLAN 1\n#define PARSE_MPLS 2\n#define PARSE_IP 3\n#define PARSE_IPV6 4\n\nstruct vlan_hdr {\n\t__be16 h_vlan_TCI;\n\t__be16 h_vlan_encapsulated_proto;\n};\n\nstruct flow_key_record {\n\t__be32 src;\n\t__be32 dst;\n\tunion {\n\t\t__be32 ports;\n\t\t__be16 port16[2];\n\t};\n\t__u32 ip_proto;\n};\n\nstatic inline void parse_eth_proto(struct __sk_buff *skb, u32 proto);\n\nstatic inline int ip_is_fragment(struct __sk_buff *ctx, __u64 nhoff)\n{\n\treturn load_half(ctx, nhoff + offsetof(struct iphdr, frag_off))\n\t\t& (IP_MF | IP_OFFSET);\n}\n\nstatic inline __u32 ipv6_addr_hash(struct __sk_buff *ctx, __u64 off)\n{\n\t__u64 w0 = load_word(ctx, off);\n\t__u64 w1 = load_word(ctx, off + 4);\n\t__u64 w2 = load_word(ctx, off + 8);\n\t__u64 w3 = load_word(ctx, off + 12);\n\n\treturn (__u32)(w0 ^ w1 ^ w2 ^ w3);\n}\n\nstruct globals {\n\tstruct flow_key_record flow;\n};\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_ARRAY);\n\t__type(key, __u32);\n\t__type(value, struct globals);\n\t__uint(max_entries, 32);\n} percpu_map SEC(\".maps\");\n\n \nstatic struct globals *this_cpu_globals(void)\n{\n\tu32 key = bpf_get_smp_processor_id();\n\n\treturn bpf_map_lookup_elem(&percpu_map, &key);\n}\n\n \nstruct pair {\n\t__u64 packets;\n\t__u64 bytes;\n};\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_HASH);\n\t__type(key, struct flow_key_record);\n\t__type(value, struct pair);\n\t__uint(max_entries, 1024);\n} hash_map SEC(\".maps\");\n\nstatic void update_stats(struct __sk_buff *skb, struct globals *g)\n{\n\tstruct flow_key_record key = g->flow;\n\tstruct pair *value;\n\n\tvalue = bpf_map_lookup_elem(&hash_map, &key);\n\tif (value) {\n\t\t__sync_fetch_and_add(&value->packets, 1);\n\t\t__sync_fetch_and_add(&value->bytes, skb->len);\n\t} else {\n\t\tstruct pair val = {1, skb->len};\n\n\t\tbpf_map_update_elem(&hash_map, &key, &val, BPF_ANY);\n\t}\n}\n\nstatic __always_inline void parse_ip_proto(struct __sk_buff *skb,\n\t\t\t\t\t   struct globals *g, __u32 ip_proto)\n{\n\t__u32 nhoff = skb->cb[0];\n\tint poff;\n\n\tswitch (ip_proto) {\n\tcase IPPROTO_GRE: {\n\t\tstruct gre_hdr {\n\t\t\t__be16 flags;\n\t\t\t__be16 proto;\n\t\t};\n\n\t\t__u32 gre_flags = load_half(skb,\n\t\t\t\t\t    nhoff + offsetof(struct gre_hdr, flags));\n\t\t__u32 gre_proto = load_half(skb,\n\t\t\t\t\t    nhoff + offsetof(struct gre_hdr, proto));\n\n\t\tif (gre_flags & (GRE_VERSION|GRE_ROUTING))\n\t\t\tbreak;\n\n\t\tnhoff += 4;\n\t\tif (gre_flags & GRE_CSUM)\n\t\t\tnhoff += 4;\n\t\tif (gre_flags & GRE_KEY)\n\t\t\tnhoff += 4;\n\t\tif (gre_flags & GRE_SEQ)\n\t\t\tnhoff += 4;\n\n\t\tskb->cb[0] = nhoff;\n\t\tparse_eth_proto(skb, gre_proto);\n\t\tbreak;\n\t}\n\tcase IPPROTO_IPIP:\n\t\tparse_eth_proto(skb, ETH_P_IP);\n\t\tbreak;\n\tcase IPPROTO_IPV6:\n\t\tparse_eth_proto(skb, ETH_P_IPV6);\n\t\tbreak;\n\tcase IPPROTO_TCP:\n\tcase IPPROTO_UDP:\n\t\tg->flow.ports = load_word(skb, nhoff);\n\tcase IPPROTO_ICMP:\n\t\tg->flow.ip_proto = ip_proto;\n\t\tupdate_stats(skb, g);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nSEC(\"socket\")\nint bpf_func_ip(struct __sk_buff *skb)\n{\n\tstruct globals *g = this_cpu_globals();\n\t__u32 nhoff, verlen, ip_proto;\n\n\tif (!g)\n\t\treturn 0;\n\n\tnhoff = skb->cb[0];\n\n\tif (unlikely(ip_is_fragment(skb, nhoff)))\n\t\treturn 0;\n\n\tip_proto = load_byte(skb, nhoff + offsetof(struct iphdr, protocol));\n\n\tif (ip_proto != IPPROTO_GRE) {\n\t\tg->flow.src = load_word(skb, nhoff + offsetof(struct iphdr, saddr));\n\t\tg->flow.dst = load_word(skb, nhoff + offsetof(struct iphdr, daddr));\n\t}\n\n\tverlen = load_byte(skb, nhoff + 0 );\n\tnhoff += (verlen & 0xF) << 2;\n\n\tskb->cb[0] = nhoff;\n\tparse_ip_proto(skb, g, ip_proto);\n\treturn 0;\n}\n\nSEC(\"socket\")\nint bpf_func_ipv6(struct __sk_buff *skb)\n{\n\tstruct globals *g = this_cpu_globals();\n\t__u32 nhoff, ip_proto;\n\n\tif (!g)\n\t\treturn 0;\n\n\tnhoff = skb->cb[0];\n\n\tip_proto = load_byte(skb,\n\t\t\t     nhoff + offsetof(struct ipv6hdr, nexthdr));\n\tg->flow.src = ipv6_addr_hash(skb,\n\t\t\t\t     nhoff + offsetof(struct ipv6hdr, saddr));\n\tg->flow.dst = ipv6_addr_hash(skb,\n\t\t\t\t     nhoff + offsetof(struct ipv6hdr, daddr));\n\tnhoff += sizeof(struct ipv6hdr);\n\n\tskb->cb[0] = nhoff;\n\tparse_ip_proto(skb, g, ip_proto);\n\treturn 0;\n}\n\nSEC(\"socket\")\nint bpf_func_vlan(struct __sk_buff *skb)\n{\n\t__u32 nhoff, proto;\n\n\tnhoff = skb->cb[0];\n\n\tproto = load_half(skb, nhoff + offsetof(struct vlan_hdr,\n\t\t\t\t\t\th_vlan_encapsulated_proto));\n\tnhoff += sizeof(struct vlan_hdr);\n\tskb->cb[0] = nhoff;\n\n\tparse_eth_proto(skb, proto);\n\n\treturn 0;\n}\n\nSEC(\"socket\")\nint bpf_func_mpls(struct __sk_buff *skb)\n{\n\t__u32 nhoff, label;\n\n\tnhoff = skb->cb[0];\n\n\tlabel = load_word(skb, nhoff);\n\tnhoff += sizeof(struct mpls_label);\n\tskb->cb[0] = nhoff;\n\n\tif (label & MPLS_LS_S_MASK) {\n\t\t__u8 verlen = load_byte(skb, nhoff);\n\t\tif ((verlen & 0xF0) == 4)\n\t\t\tparse_eth_proto(skb, ETH_P_IP);\n\t\telse\n\t\t\tparse_eth_proto(skb, ETH_P_IPV6);\n\t} else {\n\t\tparse_eth_proto(skb, ETH_P_MPLS_UC);\n\t}\n\n\treturn 0;\n}\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_PROG_ARRAY);\n\t__uint(key_size, sizeof(u32));\n\t__uint(max_entries, 8);\n\t__array(values, u32 (void *));\n} prog_array_init SEC(\".maps\") = {\n\t.values = {\n\t\t[PARSE_VLAN] = (void *)&bpf_func_vlan,\n\t\t[PARSE_IP]   = (void *)&bpf_func_ip,\n\t\t[PARSE_IPV6] = (void *)&bpf_func_ipv6,\n\t\t[PARSE_MPLS] = (void *)&bpf_func_mpls,\n\t},\n};\n\n \nstatic inline void parse_eth_proto(struct __sk_buff *skb, u32 proto)\n{\n\tswitch (proto) {\n\tcase ETH_P_8021Q:\n\tcase ETH_P_8021AD:\n\t\tbpf_tail_call(skb, &prog_array_init, PARSE_VLAN);\n\t\tbreak;\n\tcase ETH_P_MPLS_UC:\n\tcase ETH_P_MPLS_MC:\n\t\tbpf_tail_call(skb, &prog_array_init, PARSE_MPLS);\n\t\tbreak;\n\tcase ETH_P_IP:\n\t\tbpf_tail_call(skb, &prog_array_init, PARSE_IP);\n\t\tbreak;\n\tcase ETH_P_IPV6:\n\t\tbpf_tail_call(skb, &prog_array_init, PARSE_IPV6);\n\t\tbreak;\n\t}\n}\n\nSEC(\"socket\")\nint main_prog(struct __sk_buff *skb)\n{\n\t__u32 nhoff = ETH_HLEN;\n\t__u32 proto = load_half(skb, 12);\n\n\tskb->cb[0] = nhoff;\n\tparse_eth_proto(skb, proto);\n\treturn 0;\n}\n\nchar _license[] SEC(\"license\") = \"GPL\";\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}