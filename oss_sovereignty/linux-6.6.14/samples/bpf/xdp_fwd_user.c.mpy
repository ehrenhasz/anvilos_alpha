{
  "module_name": "xdp_fwd_user.c",
  "hash_id": "fe3d7707a7eca8d57bf16f13b4ff133d45506ce0a6ae830c6cefafde3940058d",
  "original_prompt": "Ingested from linux-6.6.14/samples/bpf/xdp_fwd_user.c",
  "human_readable_source": "\n \n\n#include <linux/bpf.h>\n#include <linux/if_link.h>\n#include <linux/limits.h>\n#include <net/if.h>\n#include <errno.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <string.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <libgen.h>\n\n#include <bpf/libbpf.h>\n#include <bpf/bpf.h>\n\nstatic __u32 xdp_flags = XDP_FLAGS_UPDATE_IF_NOEXIST;\n\nstatic int do_attach(int idx, int prog_fd, int map_fd, const char *name)\n{\n\tint err;\n\n\terr = bpf_xdp_attach(idx, prog_fd, xdp_flags, NULL);\n\tif (err < 0) {\n\t\tprintf(\"ERROR: failed to attach program to %s\\n\", name);\n\t\treturn err;\n\t}\n\n\t \n\terr = bpf_map_update_elem(map_fd, &idx, &idx, 0);\n\tif (err)\n\t\tprintf(\"ERROR: failed using device %s as TX-port\\n\", name);\n\n\treturn err;\n}\n\nstatic int do_detach(int ifindex, const char *ifname, const char *app_name)\n{\n\tLIBBPF_OPTS(bpf_xdp_attach_opts, opts);\n\tstruct bpf_prog_info prog_info = {};\n\tchar prog_name[BPF_OBJ_NAME_LEN];\n\t__u32 info_len, curr_prog_id;\n\tint prog_fd;\n\tint err = 1;\n\n\tif (bpf_xdp_query_id(ifindex, xdp_flags, &curr_prog_id)) {\n\t\tprintf(\"ERROR: bpf_xdp_query_id failed (%s)\\n\",\n\t\t       strerror(errno));\n\t\treturn err;\n\t}\n\n\tif (!curr_prog_id) {\n\t\tprintf(\"ERROR: flags(0x%x) xdp prog is not attached to %s\\n\",\n\t\t       xdp_flags, ifname);\n\t\treturn err;\n\t}\n\n\tinfo_len = sizeof(prog_info);\n\tprog_fd = bpf_prog_get_fd_by_id(curr_prog_id);\n\tif (prog_fd < 0) {\n\t\tprintf(\"ERROR: bpf_prog_get_fd_by_id failed (%s)\\n\",\n\t\t       strerror(errno));\n\t\treturn prog_fd;\n\t}\n\n\terr = bpf_prog_get_info_by_fd(prog_fd, &prog_info, &info_len);\n\tif (err) {\n\t\tprintf(\"ERROR: bpf_prog_get_info_by_fd failed (%s)\\n\",\n\t\t       strerror(errno));\n\t\tgoto close_out;\n\t}\n\tsnprintf(prog_name, sizeof(prog_name), \"%s_prog\", app_name);\n\tprog_name[BPF_OBJ_NAME_LEN - 1] = '\\0';\n\n\tif (strcmp(prog_info.name, prog_name)) {\n\t\tprintf(\"ERROR: %s isn't attached to %s\\n\", app_name, ifname);\n\t\terr = 1;\n\t\tgoto close_out;\n\t}\n\n\topts.old_prog_fd = prog_fd;\n\terr = bpf_xdp_detach(ifindex, xdp_flags, &opts);\n\tif (err < 0)\n\t\tprintf(\"ERROR: failed to detach program from %s (%s)\\n\",\n\t\t       ifname, strerror(errno));\n\t \nclose_out:\n\tclose(prog_fd);\n\treturn err;\n}\n\nstatic void usage(const char *prog)\n{\n\tfprintf(stderr,\n\t\t\"usage: %s [OPTS] interface-list\\n\"\n\t\t\"\\nOPTS:\\n\"\n\t\t\"    -d    detach program\\n\"\n\t\t\"    -S    use skb-mode\\n\"\n\t\t\"    -F    force loading prog\\n\"\n\t\t\"    -D    direct table lookups (skip fib rules)\\n\",\n\t\tprog);\n}\n\nint main(int argc, char **argv)\n{\n\tconst char *prog_name = \"xdp_fwd\";\n\tstruct bpf_program *prog = NULL;\n\tstruct bpf_program *pos;\n\tconst char *sec_name;\n\tint prog_fd = -1, map_fd = -1;\n\tchar filename[PATH_MAX];\n\tstruct bpf_object *obj;\n\tint opt, i, idx, err;\n\tint attach = 1;\n\tint ret = 0;\n\n\twhile ((opt = getopt(argc, argv, \":dDSF\")) != -1) {\n\t\tswitch (opt) {\n\t\tcase 'd':\n\t\t\tattach = 0;\n\t\t\tbreak;\n\t\tcase 'S':\n\t\t\txdp_flags |= XDP_FLAGS_SKB_MODE;\n\t\t\tbreak;\n\t\tcase 'F':\n\t\t\txdp_flags &= ~XDP_FLAGS_UPDATE_IF_NOEXIST;\n\t\t\tbreak;\n\t\tcase 'D':\n\t\t\tprog_name = \"xdp_fwd_direct\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tusage(basename(argv[0]));\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tif (!(xdp_flags & XDP_FLAGS_SKB_MODE))\n\t\txdp_flags |= XDP_FLAGS_DRV_MODE;\n\n\tif (optind == argc) {\n\t\tusage(basename(argv[0]));\n\t\treturn 1;\n\t}\n\n\tif (attach) {\n\t\tsnprintf(filename, sizeof(filename), \"%s_kern.o\", argv[0]);\n\n\t\tif (access(filename, O_RDONLY) < 0) {\n\t\t\tprintf(\"error accessing file %s: %s\\n\",\n\t\t\t\tfilename, strerror(errno));\n\t\t\treturn 1;\n\t\t}\n\n\t\tobj = bpf_object__open_file(filename, NULL);\n\t\tif (libbpf_get_error(obj))\n\t\t\treturn 1;\n\n\t\tprog = bpf_object__next_program(obj, NULL);\n\t\tbpf_program__set_type(prog, BPF_PROG_TYPE_XDP);\n\n\t\terr = bpf_object__load(obj);\n\t\tif (err) {\n\t\t\tprintf(\"Does kernel support devmap lookup?\\n\");\n\t\t\t \n\t\t\treturn 1;\n\t\t}\n\n\t\tbpf_object__for_each_program(pos, obj) {\n\t\t\tsec_name = bpf_program__section_name(pos);\n\t\t\tif (sec_name && !strcmp(sec_name, prog_name)) {\n\t\t\t\tprog = pos;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tprog_fd = bpf_program__fd(prog);\n\t\tif (prog_fd < 0) {\n\t\t\tprintf(\"program not found: %s\\n\", strerror(prog_fd));\n\t\t\treturn 1;\n\t\t}\n\t\tmap_fd = bpf_map__fd(bpf_object__find_map_by_name(obj,\n\t\t\t\t\t\t\t\"xdp_tx_ports\"));\n\t\tif (map_fd < 0) {\n\t\t\tprintf(\"map not found: %s\\n\", strerror(map_fd));\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tfor (i = optind; i < argc; ++i) {\n\t\tidx = if_nametoindex(argv[i]);\n\t\tif (!idx)\n\t\t\tidx = strtoul(argv[i], NULL, 0);\n\n\t\tif (!idx) {\n\t\t\tfprintf(stderr, \"Invalid arg\\n\");\n\t\t\treturn 1;\n\t\t}\n\t\tif (!attach) {\n\t\t\terr = do_detach(idx, argv[i], prog_name);\n\t\t\tif (err)\n\t\t\t\tret = err;\n\t\t} else {\n\t\t\terr = do_attach(idx, prog_fd, map_fd, argv[i]);\n\t\t\tif (err)\n\t\t\t\tret = err;\n\t\t}\n\t}\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}