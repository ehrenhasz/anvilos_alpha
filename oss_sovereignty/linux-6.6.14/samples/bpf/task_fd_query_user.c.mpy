{
  "module_name": "task_fd_query_user.c",
  "hash_id": "7494f80c8afa969766fd81b06e0f47ed1d2b684fbd5a87e401e5b3f8e66708ee",
  "original_prompt": "Ingested from linux-6.6.14/samples/bpf/task_fd_query_user.c",
  "human_readable_source": "\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <unistd.h>\n#include <stdbool.h>\n#include <string.h>\n#include <stdint.h>\n#include <fcntl.h>\n#include <linux/bpf.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <linux/perf_event.h>\n\n#include <bpf/bpf.h>\n#include <bpf/libbpf.h>\n#include \"bpf_util.h\"\n#include \"perf-sys.h\"\n#include \"trace_helpers.h\"\n\nstatic struct bpf_program *progs[2];\nstatic struct bpf_link *links[2];\n\n#define CHECK_PERROR_RET(condition) ({\t\t\t\\\n\tint __ret = !!(condition);\t\t\t\\\n\tif (__ret) {\t\t\t\t\t\\\n\t\tprintf(\"FAIL: %s:\\n\", __func__);\t\\\n\t\tperror(\"    \");\t\t\t\\\n\t\treturn -1;\t\t\t\t\\\n\t}\t\t\t\t\t\t\\\n})\n\n#define CHECK_AND_RET(condition) ({\t\t\t\\\n\tint __ret = !!(condition);\t\t\t\\\n\tif (__ret)\t\t\t\t\t\\\n\t\treturn -1;\t\t\t\t\\\n})\n\nstatic __u64 ptr_to_u64(void *ptr)\n{\n\treturn (__u64) (unsigned long) ptr;\n}\n\n#define PMU_TYPE_FILE \"/sys/bus/event_source/devices/%s/type\"\nstatic int bpf_find_probe_type(const char *event_type)\n{\n\tchar buf[256];\n\tint fd, ret;\n\n\tret = snprintf(buf, sizeof(buf), PMU_TYPE_FILE, event_type);\n\tCHECK_PERROR_RET(ret < 0 || ret >= sizeof(buf));\n\n\tfd = open(buf, O_RDONLY);\n\tCHECK_PERROR_RET(fd < 0);\n\n\tret = read(fd, buf, sizeof(buf));\n\tclose(fd);\n\tCHECK_PERROR_RET(ret < 0 || ret >= sizeof(buf));\n\n\terrno = 0;\n\tret = (int)strtol(buf, NULL, 10);\n\tCHECK_PERROR_RET(errno);\n\treturn ret;\n}\n\n#define PMU_RETPROBE_FILE \"/sys/bus/event_source/devices/%s/format/retprobe\"\nstatic int bpf_get_retprobe_bit(const char *event_type)\n{\n\tchar buf[256];\n\tint fd, ret;\n\n\tret = snprintf(buf, sizeof(buf), PMU_RETPROBE_FILE, event_type);\n\tCHECK_PERROR_RET(ret < 0 || ret >= sizeof(buf));\n\n\tfd = open(buf, O_RDONLY);\n\tCHECK_PERROR_RET(fd < 0);\n\n\tret = read(fd, buf, sizeof(buf));\n\tclose(fd);\n\tCHECK_PERROR_RET(ret < 0 || ret >= sizeof(buf));\n\tCHECK_PERROR_RET(strlen(buf) < strlen(\"config:\"));\n\n\terrno = 0;\n\tret = (int)strtol(buf + strlen(\"config:\"), NULL, 10);\n\tCHECK_PERROR_RET(errno);\n\treturn ret;\n}\n\nstatic int test_debug_fs_kprobe(int link_idx, const char *fn_name,\n\t\t\t\t__u32 expected_fd_type)\n{\n\t__u64 probe_offset, probe_addr;\n\t__u32 len, prog_id, fd_type;\n\tint err, event_fd;\n\tchar buf[256];\n\n\tlen = sizeof(buf);\n\tevent_fd = bpf_link__fd(links[link_idx]);\n\terr = bpf_task_fd_query(getpid(), event_fd, 0, buf, &len,\n\t\t\t\t&prog_id, &fd_type, &probe_offset,\n\t\t\t\t&probe_addr);\n\tif (err < 0) {\n\t\tprintf(\"FAIL: %s, for event_fd idx %d, fn_name %s\\n\",\n\t\t       __func__, link_idx, fn_name);\n\t\tperror(\"    :\");\n\t\treturn -1;\n\t}\n\tif (strcmp(buf, fn_name) != 0 ||\n\t    fd_type != expected_fd_type ||\n\t    probe_offset != 0x0 || probe_addr != 0x0) {\n\t\tprintf(\"FAIL: bpf_trace_event_query(event_fd[%d]):\\n\",\n\t\t       link_idx);\n\t\tprintf(\"buf: %s, fd_type: %u, probe_offset: 0x%llx,\"\n\t\t       \" probe_addr: 0x%llx\\n\",\n\t\t       buf, fd_type, probe_offset, probe_addr);\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int test_nondebug_fs_kuprobe_common(const char *event_type,\n\tconst char *name, __u64 offset, __u64 addr, bool is_return,\n\tchar *buf, __u32 *buf_len, __u32 *prog_id, __u32 *fd_type,\n\t__u64 *probe_offset, __u64 *probe_addr)\n{\n\tint is_return_bit = bpf_get_retprobe_bit(event_type);\n\tint type = bpf_find_probe_type(event_type);\n\tstruct perf_event_attr attr = {};\n\tstruct bpf_link *link;\n\tint fd, err = -1;\n\n\tif (type < 0 || is_return_bit < 0) {\n\t\tprintf(\"FAIL: %s incorrect type (%d) or is_return_bit (%d)\\n\",\n\t\t\t__func__, type, is_return_bit);\n\t\treturn err;\n\t}\n\n\tattr.sample_period = 1;\n\tattr.wakeup_events = 1;\n\tif (is_return)\n\t\tattr.config |= 1 << is_return_bit;\n\n\tif (name) {\n\t\tattr.config1 = ptr_to_u64((void *)name);\n\t\tattr.config2 = offset;\n\t} else {\n\t\tattr.config1 = 0;\n\t\tattr.config2 = addr;\n\t}\n\tattr.size = sizeof(attr);\n\tattr.type = type;\n\n\tfd = sys_perf_event_open(&attr, -1, 0, -1, 0);\n\tlink = bpf_program__attach_perf_event(progs[0], fd);\n\tif (libbpf_get_error(link)) {\n\t\tprintf(\"ERROR: bpf_program__attach_perf_event failed\\n\");\n\t\tlink = NULL;\n\t\tclose(fd);\n\t\tgoto cleanup;\n\t}\n\n\tCHECK_PERROR_RET(bpf_task_fd_query(getpid(), fd, 0, buf, buf_len,\n\t\t\t prog_id, fd_type, probe_offset, probe_addr) < 0);\n\terr = 0;\n\ncleanup:\n\tbpf_link__destroy(link);\n\treturn err;\n}\n\nstatic int test_nondebug_fs_probe(const char *event_type, const char *name,\n\t\t\t\t  __u64 offset, __u64 addr, bool is_return,\n\t\t\t\t  __u32 expected_fd_type,\n\t\t\t\t  __u32 expected_ret_fd_type,\n\t\t\t\t  char *buf, __u32 buf_len)\n{\n\t__u64 probe_offset, probe_addr;\n\t__u32 prog_id, fd_type;\n\tint err;\n\n\terr = test_nondebug_fs_kuprobe_common(event_type, name,\n\t\t\t\t\t      offset, addr, is_return,\n\t\t\t\t\t      buf, &buf_len, &prog_id,\n\t\t\t\t\t      &fd_type, &probe_offset,\n\t\t\t\t\t      &probe_addr);\n\tif (err < 0) {\n\t\tprintf(\"FAIL: %s, \"\n\t\t       \"for name %s, offset 0x%llx, addr 0x%llx, is_return %d\\n\",\n\t\t       __func__, name ? name : \"\", offset, addr, is_return);\n\t\tperror(\"    :\");\n\t\treturn -1;\n\t}\n\tif ((is_return && fd_type != expected_ret_fd_type) ||\n\t    (!is_return && fd_type != expected_fd_type)) {\n\t\tprintf(\"FAIL: %s, incorrect fd_type %u\\n\",\n\t\t       __func__, fd_type);\n\t\treturn -1;\n\t}\n\tif (name) {\n\t\tif (strcmp(name, buf) != 0) {\n\t\t\tprintf(\"FAIL: %s, incorrect buf %s\\n\", __func__, buf);\n\t\t\treturn -1;\n\t\t}\n\t\tif (probe_offset != offset) {\n\t\t\tprintf(\"FAIL: %s, incorrect probe_offset 0x%llx\\n\",\n\t\t\t       __func__, probe_offset);\n\t\t\treturn -1;\n\t\t}\n\t} else {\n\t\tif (buf_len != 0) {\n\t\t\tprintf(\"FAIL: %s, incorrect buf %p\\n\",\n\t\t\t       __func__, buf);\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (probe_addr != addr) {\n\t\t\tprintf(\"FAIL: %s, incorrect probe_addr 0x%llx\\n\",\n\t\t\t       __func__, probe_addr);\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int test_debug_fs_uprobe(char *binary_path, long offset, bool is_return)\n{\n\tchar buf[256], event_alias[sizeof(\"test_1234567890\")];\n\tconst char *event_type = \"uprobe\";\n\tstruct perf_event_attr attr = {};\n\t__u64 probe_offset, probe_addr;\n\t__u32 len, prog_id, fd_type;\n\tint err = -1, res, kfd, efd;\n\tstruct bpf_link *link;\n\tssize_t bytes;\n\n\tsnprintf(buf, sizeof(buf), \"/sys/kernel/tracing/%s_events\",\n\t\t event_type);\n\tkfd = open(buf, O_WRONLY | O_TRUNC, 0);\n\tCHECK_PERROR_RET(kfd < 0);\n\n\tres = snprintf(event_alias, sizeof(event_alias), \"test_%d\", getpid());\n\tCHECK_PERROR_RET(res < 0 || res >= sizeof(event_alias));\n\n\tres = snprintf(buf, sizeof(buf), \"%c:%ss/%s %s:0x%lx\",\n\t\t       is_return ? 'r' : 'p', event_type, event_alias,\n\t\t       binary_path, offset);\n\tCHECK_PERROR_RET(res < 0 || res >= sizeof(buf));\n\tCHECK_PERROR_RET(write(kfd, buf, strlen(buf)) < 0);\n\n\tclose(kfd);\n\tkfd = -1;\n\n\tsnprintf(buf, sizeof(buf), \"/sys/kernel/tracing/events/%ss/%s/id\",\n\t\t event_type, event_alias);\n\tefd = open(buf, O_RDONLY, 0);\n\tCHECK_PERROR_RET(efd < 0);\n\n\tbytes = read(efd, buf, sizeof(buf));\n\tCHECK_PERROR_RET(bytes <= 0 || bytes >= sizeof(buf));\n\tclose(efd);\n\tbuf[bytes] = '\\0';\n\n\tattr.config = strtol(buf, NULL, 0);\n\tattr.type = PERF_TYPE_TRACEPOINT;\n\tattr.sample_period = 1;\n\tattr.wakeup_events = 1;\n\n\tkfd = sys_perf_event_open(&attr, -1, 0, -1, PERF_FLAG_FD_CLOEXEC);\n\tlink = bpf_program__attach_perf_event(progs[0], kfd);\n\tif (libbpf_get_error(link)) {\n\t\tprintf(\"ERROR: bpf_program__attach_perf_event failed\\n\");\n\t\tlink = NULL;\n\t\tclose(kfd);\n\t\tgoto cleanup;\n\t}\n\n\tlen = sizeof(buf);\n\terr = bpf_task_fd_query(getpid(), kfd, 0, buf, &len,\n\t\t\t\t&prog_id, &fd_type, &probe_offset,\n\t\t\t\t&probe_addr);\n\tif (err < 0) {\n\t\tprintf(\"FAIL: %s, binary_path %s\\n\", __func__, binary_path);\n\t\tperror(\"    :\");\n\t\treturn -1;\n\t}\n\tif ((is_return && fd_type != BPF_FD_TYPE_URETPROBE) ||\n\t    (!is_return && fd_type != BPF_FD_TYPE_UPROBE)) {\n\t\tprintf(\"FAIL: %s, incorrect fd_type %u\\n\", __func__,\n\t\t       fd_type);\n\t\treturn -1;\n\t}\n\tif (strcmp(binary_path, buf) != 0) {\n\t\tprintf(\"FAIL: %s, incorrect buf %s\\n\", __func__, buf);\n\t\treturn -1;\n\t}\n\tif (probe_offset != offset) {\n\t\tprintf(\"FAIL: %s, incorrect probe_offset 0x%llx\\n\", __func__,\n\t\t       probe_offset);\n\t\treturn -1;\n\t}\n\terr = 0;\n\ncleanup:\n\tbpf_link__destroy(link);\n\treturn err;\n}\n\nint main(int argc, char **argv)\n{\n\textern char __executable_start;\n\tchar filename[256], buf[256];\n\t__u64 uprobe_file_offset;\n\tstruct bpf_program *prog;\n\tstruct bpf_object *obj;\n\tint i = 0, err = -1;\n\n\tif (load_kallsyms()) {\n\t\tprintf(\"failed to process /proc/kallsyms\\n\");\n\t\treturn err;\n\t}\n\n\tsnprintf(filename, sizeof(filename), \"%s_kern.o\", argv[0]);\n\tobj = bpf_object__open_file(filename, NULL);\n\tif (libbpf_get_error(obj)) {\n\t\tfprintf(stderr, \"ERROR: opening BPF object file failed\\n\");\n\t\treturn err;\n\t}\n\n\t \n\tif (bpf_object__load(obj)) {\n\t\tfprintf(stderr, \"ERROR: loading BPF object file failed\\n\");\n\t\tgoto cleanup;\n\t}\n\n\tbpf_object__for_each_program(prog, obj) {\n\t\tprogs[i] = prog;\n\t\tlinks[i] = bpf_program__attach(progs[i]);\n\t\tif (libbpf_get_error(links[i])) {\n\t\t\tfprintf(stderr, \"ERROR: bpf_program__attach failed\\n\");\n\t\t\tlinks[i] = NULL;\n\t\t\tgoto cleanup;\n\t\t}\n\t\ti++;\n\t}\n\n\t \n\tCHECK_AND_RET(test_debug_fs_kprobe(0, \"blk_mq_start_request\",\n\t\t\t\t\t   BPF_FD_TYPE_KPROBE));\n\tCHECK_AND_RET(test_debug_fs_kprobe(1, \"__blk_account_io_done\",\n\t\t\t\t\t   BPF_FD_TYPE_KRETPROBE));\n\n\t \n\tCHECK_AND_RET(test_nondebug_fs_probe(\"kprobe\", \"bpf_check\", 0x0, 0x0,\n\t\t\t\t\t     false, BPF_FD_TYPE_KPROBE,\n\t\t\t\t\t     BPF_FD_TYPE_KRETPROBE,\n\t\t\t\t\t     buf, sizeof(buf)));\n#ifdef __x86_64__\n\t \n\tCHECK_AND_RET(test_nondebug_fs_probe(\"kprobe\", \"bpf_check\", 0x5, 0x0,\n\t\t\t\t\t     false, BPF_FD_TYPE_KPROBE,\n\t\t\t\t\t     BPF_FD_TYPE_KRETPROBE,\n\t\t\t\t\t     buf, sizeof(buf)));\n#endif\n\tCHECK_AND_RET(test_nondebug_fs_probe(\"kprobe\", \"bpf_check\", 0x0, 0x0,\n\t\t\t\t\t     true, BPF_FD_TYPE_KPROBE,\n\t\t\t\t\t     BPF_FD_TYPE_KRETPROBE,\n\t\t\t\t\t     buf, sizeof(buf)));\n\tCHECK_AND_RET(test_nondebug_fs_probe(\"kprobe\", NULL, 0x0,\n\t\t\t\t\t     ksym_get_addr(\"bpf_check\"), false,\n\t\t\t\t\t     BPF_FD_TYPE_KPROBE,\n\t\t\t\t\t     BPF_FD_TYPE_KRETPROBE,\n\t\t\t\t\t     buf, sizeof(buf)));\n\tCHECK_AND_RET(test_nondebug_fs_probe(\"kprobe\", NULL, 0x0,\n\t\t\t\t\t     ksym_get_addr(\"bpf_check\"), false,\n\t\t\t\t\t     BPF_FD_TYPE_KPROBE,\n\t\t\t\t\t     BPF_FD_TYPE_KRETPROBE,\n\t\t\t\t\t     NULL, 0));\n\tCHECK_AND_RET(test_nondebug_fs_probe(\"kprobe\", NULL, 0x0,\n\t\t\t\t\t     ksym_get_addr(\"bpf_check\"), true,\n\t\t\t\t\t     BPF_FD_TYPE_KPROBE,\n\t\t\t\t\t     BPF_FD_TYPE_KRETPROBE,\n\t\t\t\t\t     buf, sizeof(buf)));\n\tCHECK_AND_RET(test_nondebug_fs_probe(\"kprobe\", NULL, 0x0,\n\t\t\t\t\t     ksym_get_addr(\"bpf_check\"), true,\n\t\t\t\t\t     BPF_FD_TYPE_KPROBE,\n\t\t\t\t\t     BPF_FD_TYPE_KRETPROBE,\n\t\t\t\t\t     0, 0));\n\n\t \n\t \n\tuprobe_file_offset = (unsigned long)main - (unsigned long)&__executable_start;\n\tCHECK_AND_RET(test_nondebug_fs_probe(\"uprobe\", (char *)argv[0],\n\t\t\t\t\t     uprobe_file_offset, 0x0, false,\n\t\t\t\t\t     BPF_FD_TYPE_UPROBE,\n\t\t\t\t\t     BPF_FD_TYPE_URETPROBE,\n\t\t\t\t\t     buf, sizeof(buf)));\n\tCHECK_AND_RET(test_nondebug_fs_probe(\"uprobe\", (char *)argv[0],\n\t\t\t\t\t     uprobe_file_offset, 0x0, true,\n\t\t\t\t\t     BPF_FD_TYPE_UPROBE,\n\t\t\t\t\t     BPF_FD_TYPE_URETPROBE,\n\t\t\t\t\t     buf, sizeof(buf)));\n\n\t \n\tCHECK_AND_RET(test_debug_fs_uprobe((char *)argv[0], uprobe_file_offset,\n\t\t\t\t\t   false));\n\tCHECK_AND_RET(test_debug_fs_uprobe((char *)argv[0], uprobe_file_offset,\n\t\t\t\t\t   true));\n\terr = 0;\n\ncleanup:\n\tfor (i--; i >= 0; i--)\n\t\tbpf_link__destroy(links[i]);\n\n\tbpf_object__close(obj);\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}