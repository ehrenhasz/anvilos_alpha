{
  "module_name": "sockex3_user.c",
  "hash_id": "b7d8ca2749bc10c908b2c26dede46910734a1b46c6843fe252bdb0ca1be97766",
  "original_prompt": "Ingested from linux-6.6.14/samples/bpf/sockex3_user.c",
  "human_readable_source": "\n#include <stdio.h>\n#include <assert.h>\n#include <bpf/bpf.h>\n#include <bpf/libbpf.h>\n#include \"sock_example.h\"\n#include <unistd.h>\n#include <arpa/inet.h>\n\nstruct flow_key_record {\n\t__be32 src;\n\t__be32 dst;\n\tunion {\n\t\t__be32 ports;\n\t\t__be16 port16[2];\n\t};\n\t__u32 ip_proto;\n};\n\nstruct pair {\n\t__u64 packets;\n\t__u64 bytes;\n};\n\nint main(int argc, char **argv)\n{\n\tint i, sock, fd, main_prog_fd, hash_map_fd;\n\tstruct bpf_program *prog;\n\tstruct bpf_object *obj;\n\tchar filename[256];\n\tFILE *f;\n\n\tsnprintf(filename, sizeof(filename), \"%s_kern.o\", argv[0]);\n\n\tobj = bpf_object__open_file(filename, NULL);\n\tif (libbpf_get_error(obj)) {\n\t\tfprintf(stderr, \"ERROR: opening BPF object file failed\\n\");\n\t\treturn 0;\n\t}\n\n\t \n\tif (bpf_object__load(obj)) {\n\t\tfprintf(stderr, \"ERROR: loading BPF object file failed\\n\");\n\t\tgoto cleanup;\n\t}\n\n\thash_map_fd = bpf_object__find_map_fd_by_name(obj, \"hash_map\");\n\tif (hash_map_fd < 0) {\n\t\tfprintf(stderr, \"ERROR: finding a map in obj file failed\\n\");\n\t\tgoto cleanup;\n\t}\n\n\t \n\tmain_prog_fd = 0;\n\tbpf_object__for_each_program(prog, obj) {\n\t\tfd = bpf_program__fd(prog);\n\n\t\tif (!strcmp(bpf_program__name(prog), \"main_prog\"))\n\t\t\tmain_prog_fd = fd;\n\t}\n\n\tif (main_prog_fd == 0) {\n\t\tfprintf(stderr, \"ERROR: can't find main_prog\\n\");\n\t\tgoto cleanup;\n\t}\n\n\tsock = open_raw_sock(\"lo\");\n\n\t \n\tassert(setsockopt(sock, SOL_SOCKET, SO_ATTACH_BPF, &main_prog_fd,\n\t\t\t  sizeof(__u32)) == 0);\n\n\tif (argc > 1)\n\t\tf = popen(\"ping -4 -c5 localhost\", \"r\");\n\telse\n\t\tf = popen(\"netperf -l 4 localhost\", \"r\");\n\t(void) f;\n\n\tfor (i = 0; i < 5; i++) {\n\t\tstruct flow_key_record key = {}, next_key;\n\t\tstruct pair value;\n\n\t\tsleep(1);\n\t\tprintf(\"IP     src.port -> dst.port               bytes      packets\\n\");\n\t\twhile (bpf_map_get_next_key(hash_map_fd, &key, &next_key) == 0) {\n\t\t\tbpf_map_lookup_elem(hash_map_fd, &next_key, &value);\n\t\t\tprintf(\"%s.%05d -> %s.%05d %12lld %12lld\\n\",\n\t\t\t       inet_ntoa((struct in_addr){htonl(next_key.src)}),\n\t\t\t       next_key.port16[0],\n\t\t\t       inet_ntoa((struct in_addr){htonl(next_key.dst)}),\n\t\t\t       next_key.port16[1],\n\t\t\t       value.bytes, value.packets);\n\t\t\tkey = next_key;\n\t\t}\n\t}\n\ncleanup:\n\tbpf_object__close(obj);\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}