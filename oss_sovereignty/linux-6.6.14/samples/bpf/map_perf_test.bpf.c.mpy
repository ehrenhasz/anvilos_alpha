{
  "module_name": "map_perf_test.bpf.c",
  "hash_id": "9d5a7b4318abacf4954fd87be60de1f8ccb4819848a489eba080f5067e941575",
  "original_prompt": "Ingested from linux-6.6.14/samples/bpf/map_perf_test.bpf.c",
  "human_readable_source": " \n#include \"vmlinux.h\"\n#include <errno.h>\n#include <linux/version.h>\n#include <bpf/bpf_helpers.h>\n#include <bpf/bpf_tracing.h>\n#include <bpf/bpf_core_read.h>\n\n#define MAX_ENTRIES 1000\n#define MAX_NR_CPUS 1024\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_HASH);\n\t__type(key, u32);\n\t__type(value, long);\n\t__uint(max_entries, MAX_ENTRIES);\n} hash_map SEC(\".maps\");\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_LRU_HASH);\n\t__type(key, u32);\n\t__type(value, long);\n\t__uint(max_entries, 10000);\n} lru_hash_map SEC(\".maps\");\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_LRU_HASH);\n\t__type(key, u32);\n\t__type(value, long);\n\t__uint(max_entries, 10000);\n\t__uint(map_flags, BPF_F_NO_COMMON_LRU);\n} nocommon_lru_hash_map SEC(\".maps\");\n\nstruct inner_lru {\n\t__uint(type, BPF_MAP_TYPE_LRU_HASH);\n\t__type(key, u32);\n\t__type(value, long);\n\t__uint(max_entries, MAX_ENTRIES);\n\t__uint(map_flags, BPF_F_NUMA_NODE);\n\t__uint(numa_node, 0);\n} inner_lru_hash_map SEC(\".maps\");\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_ARRAY_OF_MAPS);\n\t__uint(max_entries, MAX_NR_CPUS);\n\t__uint(key_size, sizeof(u32));\n\t__array(values, struct inner_lru);  \n} array_of_lru_hashs SEC(\".maps\") = {\n\t \n\t.values = { &inner_lru_hash_map },\n};\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_PERCPU_HASH);\n\t__uint(key_size, sizeof(u32));\n\t__uint(value_size, sizeof(long));\n\t__uint(max_entries, MAX_ENTRIES);\n} percpu_hash_map SEC(\".maps\");\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_HASH);\n\t__type(key, u32);\n\t__type(value, long);\n\t__uint(max_entries, MAX_ENTRIES);\n\t__uint(map_flags, BPF_F_NO_PREALLOC);\n} hash_map_alloc SEC(\".maps\");\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_PERCPU_HASH);\n\t__uint(key_size, sizeof(u32));\n\t__uint(value_size, sizeof(long));\n\t__uint(max_entries, MAX_ENTRIES);\n\t__uint(map_flags, BPF_F_NO_PREALLOC);\n} percpu_hash_map_alloc SEC(\".maps\");\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_LPM_TRIE);\n\t__uint(key_size, 8);\n\t__uint(value_size, sizeof(long));\n\t__uint(max_entries, 10000);\n\t__uint(map_flags, BPF_F_NO_PREALLOC);\n} lpm_trie_map_alloc SEC(\".maps\");\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_ARRAY);\n\t__type(key, u32);\n\t__type(value, long);\n\t__uint(max_entries, MAX_ENTRIES);\n} array_map SEC(\".maps\");\n\nstruct {\n\t__uint(type, BPF_MAP_TYPE_LRU_HASH);\n\t__type(key, u32);\n\t__type(value, long);\n\t__uint(max_entries, MAX_ENTRIES);\n} lru_hash_lookup_map SEC(\".maps\");\n\nSEC(\"ksyscall/getuid\")\nint BPF_KSYSCALL(stress_hmap)\n{\n\tu32 key = bpf_get_current_pid_tgid();\n\tlong init_val = 1;\n\tlong *value;\n\tint i;\n\n\tfor (i = 0; i < 10; i++) {\n\t\tbpf_map_update_elem(&hash_map, &key, &init_val, BPF_ANY);\n\t\tvalue = bpf_map_lookup_elem(&hash_map, &key);\n\t\tif (value)\n\t\t\tbpf_map_delete_elem(&hash_map, &key);\n\t}\n\n\treturn 0;\n}\n\nSEC(\"ksyscall/geteuid\")\nint BPF_KSYSCALL(stress_percpu_hmap)\n{\n\tu32 key = bpf_get_current_pid_tgid();\n\tlong init_val = 1;\n\tlong *value;\n\tint i;\n\n\tfor (i = 0; i < 10; i++) {\n\t\tbpf_map_update_elem(&percpu_hash_map, &key, &init_val, BPF_ANY);\n\t\tvalue = bpf_map_lookup_elem(&percpu_hash_map, &key);\n\t\tif (value)\n\t\t\tbpf_map_delete_elem(&percpu_hash_map, &key);\n\t}\n\treturn 0;\n}\n\nSEC(\"ksyscall/getgid\")\nint BPF_KSYSCALL(stress_hmap_alloc)\n{\n\tu32 key = bpf_get_current_pid_tgid();\n\tlong init_val = 1;\n\tlong *value;\n\tint i;\n\n\tfor (i = 0; i < 10; i++) {\n\t\tbpf_map_update_elem(&hash_map_alloc, &key, &init_val, BPF_ANY);\n\t\tvalue = bpf_map_lookup_elem(&hash_map_alloc, &key);\n\t\tif (value)\n\t\t\tbpf_map_delete_elem(&hash_map_alloc, &key);\n\t}\n\treturn 0;\n}\n\nSEC(\"ksyscall/getegid\")\nint BPF_KSYSCALL(stress_percpu_hmap_alloc)\n{\n\tu32 key = bpf_get_current_pid_tgid();\n\tlong init_val = 1;\n\tlong *value;\n\tint i;\n\n\tfor (i = 0; i < 10; i++) {\n\t\tbpf_map_update_elem(&percpu_hash_map_alloc, &key, &init_val, BPF_ANY);\n\t\tvalue = bpf_map_lookup_elem(&percpu_hash_map_alloc, &key);\n\t\tif (value)\n\t\t\tbpf_map_delete_elem(&percpu_hash_map_alloc, &key);\n\t}\n\treturn 0;\n}\nSEC(\"ksyscall/connect\")\nint BPF_KSYSCALL(stress_lru_hmap_alloc, int fd, struct sockaddr_in *uservaddr,\n\t\t int addrlen)\n{\n\tchar fmt[] = \"Failed at stress_lru_hmap_alloc. ret:%dn\";\n\tunion {\n\t\tu16 dst6[8];\n\t\tstruct {\n\t\t\tu16 magic0;\n\t\t\tu16 magic1;\n\t\t\tu16 tcase;\n\t\t\tu16 unused16;\n\t\t\tu32 unused32;\n\t\t\tu32 key;\n\t\t};\n\t} test_params;\n\tstruct sockaddr_in6 *in6 = (struct sockaddr_in6 *)uservaddr;\n\tu16 test_case;\n\tlong val = 1;\n\tu32 key = 0;\n\tint ret;\n\n\tif (addrlen != sizeof(*in6))\n\t\treturn 0;\n\n\tret = bpf_probe_read_user(test_params.dst6, sizeof(test_params.dst6),\n\t\t\t\t  &in6->sin6_addr);\n\tif (ret)\n\t\tgoto done;\n\n\tif (test_params.magic0 != 0xdead ||\n\t    test_params.magic1 != 0xbeef)\n\t\treturn 0;\n\n\ttest_case = test_params.tcase;\n\tif (test_case != 3)\n\t\tkey = bpf_get_prandom_u32();\n\n\tif (test_case == 0) {\n\t\tret = bpf_map_update_elem(&lru_hash_map, &key, &val, BPF_ANY);\n\t} else if (test_case == 1) {\n\t\tret = bpf_map_update_elem(&nocommon_lru_hash_map, &key, &val,\n\t\t\t\t\t  BPF_ANY);\n\t} else if (test_case == 2) {\n\t\tvoid *nolocal_lru_map;\n\t\tint cpu = bpf_get_smp_processor_id();\n\n\t\tnolocal_lru_map = bpf_map_lookup_elem(&array_of_lru_hashs,\n\t\t\t\t\t\t      &cpu);\n\t\tif (!nolocal_lru_map) {\n\t\t\tret = -ENOENT;\n\t\t\tgoto done;\n\t\t}\n\n\t\tret = bpf_map_update_elem(nolocal_lru_map, &key, &val,\n\t\t\t\t\t  BPF_ANY);\n\t} else if (test_case == 3) {\n\t\tu32 i;\n\n\t\tkey = test_params.key;\n\n#pragma clang loop unroll(full)\n\t\tfor (i = 0; i < 32; i++) {\n\t\t\tbpf_map_lookup_elem(&lru_hash_lookup_map, &key);\n\t\t\tkey++;\n\t\t}\n\t} else {\n\t\tret = -EINVAL;\n\t}\n\ndone:\n\tif (ret)\n\t\tbpf_trace_printk(fmt, sizeof(fmt), ret);\n\n\treturn 0;\n}\n\nSEC(\"ksyscall/gettid\")\nint BPF_KSYSCALL(stress_lpm_trie_map_alloc)\n{\n\tunion {\n\t\tu32 b32[2];\n\t\tu8 b8[8];\n\t} key;\n\tunsigned int i;\n\n\tkey.b32[0] = 32;\n\tkey.b8[4] = 192;\n\tkey.b8[5] = 168;\n\tkey.b8[6] = 0;\n\tkey.b8[7] = 1;\n\n#pragma clang loop unroll(full)\n\tfor (i = 0; i < 32; ++i)\n\t\tbpf_map_lookup_elem(&lpm_trie_map_alloc, &key);\n\n\treturn 0;\n}\n\nSEC(\"ksyscall/getpgid\")\nint BPF_KSYSCALL(stress_hash_map_lookup)\n{\n\tu32 key = 1, i;\n\tlong *value;\n\n#pragma clang loop unroll(full)\n\tfor (i = 0; i < 64; ++i)\n\t\tvalue = bpf_map_lookup_elem(&hash_map, &key);\n\n\treturn 0;\n}\n\nSEC(\"ksyscall/getppid\")\nint BPF_KSYSCALL(stress_array_map_lookup)\n{\n\tu32 key = 1, i;\n\tlong *value;\n\n#pragma clang loop unroll(full)\n\tfor (i = 0; i < 64; ++i)\n\t\tvalue = bpf_map_lookup_elem(&array_map, &key);\n\n\treturn 0;\n}\n\nchar _license[] SEC(\"license\") = \"GPL\";\nu32 _version SEC(\"version\") = LINUX_VERSION_CODE;\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}