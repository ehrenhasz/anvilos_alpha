{
  "module_name": "hbm.c",
  "hash_id": "ab85c6470536eb9172b80d07fc411fced73946265766cb23c88ebf3fc570d142",
  "original_prompt": "Ingested from linux-6.6.14/samples/bpf/hbm.c",
  "human_readable_source": "\n \n\n#define _GNU_SOURCE\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <sys/time.h>\n#include <unistd.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/unistd.h>\n#include <linux/compiler.h>\n\n#include <linux/bpf.h>\n#include <bpf/bpf.h>\n#include <getopt.h>\n\n#include \"cgroup_helpers.h\"\n#include \"hbm.h\"\n#include \"bpf_util.h\"\n#include <bpf/libbpf.h>\n\nbool outFlag = true;\nint minRate = 1000;\t\t \nint rate = 1000;\t\t \nint dur = 1;\nbool stats_flag;\nbool loopback_flag;\nbool debugFlag;\nbool work_conserving_flag;\nbool no_cn_flag;\nbool edt_flag;\n\nstatic void Usage(void);\nstatic void read_trace_pipe2(void);\nstatic void do_error(char *msg, bool errno_flag);\n\n#define TRACEFS \"/sys/kernel/tracing/\"\n\nstatic struct bpf_program *bpf_prog;\nstatic struct bpf_object *obj;\nstatic int queue_stats_fd;\n\nstatic void read_trace_pipe2(void)\n{\n\tint trace_fd;\n\tFILE *outf;\n\tchar *outFname = \"hbm_out.log\";\n\n\ttrace_fd = open(TRACEFS \"trace_pipe\", O_RDONLY, 0);\n\tif (trace_fd < 0) {\n\t\tprintf(\"Error opening trace_pipe\\n\");\n\t\treturn;\n\t}\n\n \n \n \n\toutf = fopen(outFname, \"w\");\n\n\tif (outf == NULL)\n\t\tprintf(\"Error creating %s\\n\", outFname);\n\n\twhile (1) {\n\t\tstatic char buf[4097];\n\t\tssize_t sz;\n\n\t\tsz = read(trace_fd, buf, sizeof(buf) - 1);\n\t\tif (sz > 0) {\n\t\t\tbuf[sz] = 0;\n\t\t\tputs(buf);\n\t\t\tif (outf != NULL) {\n\t\t\t\tfprintf(outf, \"%s\\n\", buf);\n\t\t\t\tfflush(outf);\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void do_error(char *msg, bool errno_flag)\n{\n\tif (errno_flag)\n\t\tprintf(\"ERROR: %s, errno: %d\\n\", msg, errno);\n\telse\n\t\tprintf(\"ERROR: %s\\n\", msg);\n\texit(1);\n}\n\nstatic int prog_load(char *prog)\n{\n\tstruct bpf_program *pos;\n\tconst char *sec_name;\n\n\tobj = bpf_object__open_file(prog, NULL);\n\tif (libbpf_get_error(obj)) {\n\t\tprintf(\"ERROR: opening BPF object file failed\\n\");\n\t\treturn 1;\n\t}\n\n\t \n\tif (bpf_object__load(obj)) {\n\t\tprintf(\"ERROR: loading BPF object file failed\\n\");\n\t\tgoto err;\n\t}\n\n\tbpf_object__for_each_program(pos, obj) {\n\t\tsec_name = bpf_program__section_name(pos);\n\t\tif (sec_name && !strcmp(sec_name, \"cgroup_skb/egress\")) {\n\t\t\tbpf_prog = pos;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!bpf_prog) {\n\t\tprintf(\"ERROR: finding a prog in obj file failed\\n\");\n\t\tgoto err;\n\t}\n\n\tqueue_stats_fd = bpf_object__find_map_fd_by_name(obj, \"queue_stats\");\n\tif (queue_stats_fd < 0) {\n\t\tprintf(\"ERROR: finding a map in obj file failed\\n\");\n\t\tgoto err;\n\t}\n\n\treturn 0;\n\nerr:\n\tbpf_object__close(obj);\n\treturn 1;\n}\n\nstatic int run_bpf_prog(char *prog, int cg_id)\n{\n\tstruct hbm_queue_stats qstats = {0};\n\tchar cg_dir[100], cg_pin_path[100];\n\tstruct bpf_link *link = NULL;\n\tint key = 0;\n\tint cg1 = 0;\n\tint rc = 0;\n\n\tsprintf(cg_dir, \"/hbm%d\", cg_id);\n\trc = prog_load(prog);\n\tif (rc != 0)\n\t\treturn rc;\n\n\tif (setup_cgroup_environment()) {\n\t\tprintf(\"ERROR: setting cgroup environment\\n\");\n\t\tgoto err;\n\t}\n\tcg1 = create_and_get_cgroup(cg_dir);\n\tif (!cg1) {\n\t\tprintf(\"ERROR: create_and_get_cgroup\\n\");\n\t\tgoto err;\n\t}\n\tif (join_cgroup(cg_dir)) {\n\t\tprintf(\"ERROR: join_cgroup\\n\");\n\t\tgoto err;\n\t}\n\n\tqstats.rate = rate;\n\tqstats.stats = stats_flag ? 1 : 0;\n\tqstats.loopback = loopback_flag ? 1 : 0;\n\tqstats.no_cn = no_cn_flag ? 1 : 0;\n\tif (bpf_map_update_elem(queue_stats_fd, &key, &qstats, BPF_ANY)) {\n\t\tprintf(\"ERROR: Could not update map element\\n\");\n\t\tgoto err;\n\t}\n\n\tif (!outFlag)\n\t\tbpf_program__set_expected_attach_type(bpf_prog, BPF_CGROUP_INET_INGRESS);\n\n\tlink = bpf_program__attach_cgroup(bpf_prog, cg1);\n\tif (libbpf_get_error(link)) {\n\t\tfprintf(stderr, \"ERROR: bpf_program__attach_cgroup failed\\n\");\n\t\tgoto err;\n\t}\n\n\tsprintf(cg_pin_path, \"/sys/fs/bpf/hbm%d\", cg_id);\n\trc = bpf_link__pin(link, cg_pin_path);\n\tif (rc < 0) {\n\t\tprintf(\"ERROR: bpf_link__pin failed: %d\\n\", rc);\n\t\tgoto err;\n\t}\n\n\tif (work_conserving_flag) {\n\t\tstruct timeval t0, t_last, t_new;\n\t\tFILE *fin;\n\t\tunsigned long long last_eth_tx_bytes, new_eth_tx_bytes;\n\t\tsigned long long last_cg_tx_bytes, new_cg_tx_bytes;\n\t\tsigned long long delta_time, delta_bytes, delta_rate;\n\t\tint delta_ms;\n#define DELTA_RATE_CHECK 10000\t\t \n#define RATE_THRESHOLD 9500000000\t \n\n\t\tbpf_map_lookup_elem(queue_stats_fd, &key, &qstats);\n\t\tif (gettimeofday(&t0, NULL) < 0)\n\t\t\tdo_error(\"gettimeofday failed\", true);\n\t\tt_last = t0;\n\t\tfin = fopen(\"/sys/class/net/eth0/statistics/tx_bytes\", \"r\");\n\t\tif (fscanf(fin, \"%llu\", &last_eth_tx_bytes) != 1)\n\t\t\tdo_error(\"fscanf fails\", false);\n\t\tfclose(fin);\n\t\tlast_cg_tx_bytes = qstats.bytes_total;\n\t\twhile (true) {\n\t\t\tusleep(DELTA_RATE_CHECK);\n\t\t\tif (gettimeofday(&t_new, NULL) < 0)\n\t\t\t\tdo_error(\"gettimeofday failed\", true);\n\t\t\tdelta_ms = (t_new.tv_sec - t0.tv_sec) * 1000 +\n\t\t\t\t(t_new.tv_usec - t0.tv_usec)/1000;\n\t\t\tif (delta_ms > dur * 1000)\n\t\t\t\tbreak;\n\t\t\tdelta_time = (t_new.tv_sec - t_last.tv_sec) * 1000000 +\n\t\t\t\t(t_new.tv_usec - t_last.tv_usec);\n\t\t\tif (delta_time == 0)\n\t\t\t\tcontinue;\n\t\t\tt_last = t_new;\n\t\t\tfin = fopen(\"/sys/class/net/eth0/statistics/tx_bytes\",\n\t\t\t\t    \"r\");\n\t\t\tif (fscanf(fin, \"%llu\", &new_eth_tx_bytes) != 1)\n\t\t\t\tdo_error(\"fscanf fails\", false);\n\t\t\tfclose(fin);\n\t\t\tprintf(\"  new_eth_tx_bytes:%llu\\n\",\n\t\t\t       new_eth_tx_bytes);\n\t\t\tbpf_map_lookup_elem(queue_stats_fd, &key, &qstats);\n\t\t\tnew_cg_tx_bytes = qstats.bytes_total;\n\t\t\tdelta_bytes = new_eth_tx_bytes - last_eth_tx_bytes;\n\t\t\tlast_eth_tx_bytes = new_eth_tx_bytes;\n\t\t\tdelta_rate = (delta_bytes * 8000000) / delta_time;\n\t\t\tprintf(\"%5d - eth_rate:%.1fGbps cg_rate:%.3fGbps\",\n\t\t\t       delta_ms, delta_rate/1000000000.0,\n\t\t\t       rate/1000.0);\n\t\t\tif (delta_rate < RATE_THRESHOLD) {\n\t\t\t\t \n\t\t\t\tint rate_diff100;\n\n\t\t\t\tdelta_bytes = new_cg_tx_bytes -\n\t\t\t\t\tlast_cg_tx_bytes;\n\t\t\t\tlast_cg_tx_bytes = new_cg_tx_bytes;\n\t\t\t\tdelta_rate = (delta_bytes * 8000000) /\n\t\t\t\t\tdelta_time;\n\t\t\t\tprintf(\" rate:%.3fGbps\",\n\t\t\t\t       delta_rate/1000000000.0);\n\t\t\t\trate_diff100 = (((long long)rate)*1000000 -\n\t\t\t\t\t\t     delta_rate) * 100 /\n\t\t\t\t\t(((long long) rate) * 1000000);\n\t\t\t\tprintf(\"  rdiff:%d\", rate_diff100);\n\t\t\t\tif (rate_diff100  <= 3) {\n\t\t\t\t\trate += (rate >> 4);\n\t\t\t\t\tif (rate > RATE_THRESHOLD / 1000000)\n\t\t\t\t\t\trate = RATE_THRESHOLD / 1000000;\n\t\t\t\t\tqstats.rate = rate;\n\t\t\t\t\tprintf(\" INC\\n\");\n\t\t\t\t} else {\n\t\t\t\t\tprintf(\"\\n\");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tprintf(\" DEC\\n\");\n\t\t\t\trate -= (rate >> 3);\n\t\t\t\tif (rate < minRate)\n\t\t\t\t\trate = minRate;\n\t\t\t\tqstats.rate = rate;\n\t\t\t}\n\t\t\tif (bpf_map_update_elem(queue_stats_fd, &key, &qstats, BPF_ANY))\n\t\t\t\tdo_error(\"update map element fails\", false);\n\t\t}\n\t} else {\n\t\tsleep(dur);\n\t}\n\t \n\tif (stats_flag && bpf_map_lookup_elem(queue_stats_fd, &key, &qstats)) {\n\t\tchar fname[100];\n\t\tFILE *fout;\n\n\t\tif (!outFlag)\n\t\t\tsprintf(fname, \"hbm.%d.in\", cg_id);\n\t\telse\n\t\t\tsprintf(fname, \"hbm.%d.out\", cg_id);\n\t\tfout = fopen(fname, \"w\");\n\t\tfprintf(fout, \"id:%d\\n\", cg_id);\n\t\tfprintf(fout, \"ERROR: Could not lookup queue_stats\\n\");\n\t\tfclose(fout);\n\t} else if (stats_flag && qstats.lastPacketTime >\n\t\t   qstats.firstPacketTime) {\n\t\tlong long delta_us = (qstats.lastPacketTime -\n\t\t\t\t      qstats.firstPacketTime)/1000;\n\t\tunsigned int rate_mbps = ((qstats.bytes_total -\n\t\t\t\t\t   qstats.bytes_dropped) * 8 /\n\t\t\t\t\t  delta_us);\n\t\tdouble percent_pkts, percent_bytes;\n\t\tchar fname[100];\n\t\tFILE *fout;\n\t\tint k;\n\t\tstatic const char *returnValNames[] = {\n\t\t\t\"DROP_PKT\",\n\t\t\t\"ALLOW_PKT\",\n\t\t\t\"DROP_PKT_CWR\",\n\t\t\t\"ALLOW_PKT_CWR\"\n\t\t};\n#define RET_VAL_COUNT 4\n\n \n \n \n \n\t\tsprintf(fname, \"hbm.%d.out\", cg_id);\n\t\tfout = fopen(fname, \"w\");\n\t\tfprintf(fout, \"id:%d\\n\", cg_id);\n\t\tfprintf(fout, \"rate_mbps:%d\\n\", rate_mbps);\n\t\tfprintf(fout, \"duration:%.1f secs\\n\",\n\t\t\t(qstats.lastPacketTime - qstats.firstPacketTime) /\n\t\t\t1000000000.0);\n\t\tfprintf(fout, \"packets:%d\\n\", (int)qstats.pkts_total);\n\t\tfprintf(fout, \"bytes_MB:%d\\n\", (int)(qstats.bytes_total /\n\t\t\t\t\t\t     1000000));\n\t\tfprintf(fout, \"pkts_dropped:%d\\n\", (int)qstats.pkts_dropped);\n\t\tfprintf(fout, \"bytes_dropped_MB:%d\\n\",\n\t\t\t(int)(qstats.bytes_dropped /\n\t\t\t\t\t\t       1000000));\n\t\t \n\t\tpercent_pkts = (qstats.pkts_marked * 100.0) /\n\t\t\t(qstats.pkts_total + 1);\n\t\tpercent_bytes = (qstats.bytes_marked * 100.0) /\n\t\t\t(qstats.bytes_total + 1);\n\t\tfprintf(fout, \"pkts_marked_percent:%6.2f\\n\", percent_pkts);\n\t\tfprintf(fout, \"bytes_marked_percent:%6.2f\\n\", percent_bytes);\n\n\t\t \n\t\tpercent_pkts = (qstats.pkts_dropped * 100.0) /\n\t\t\t(qstats.pkts_total + 1);\n\t\tpercent_bytes = (qstats.bytes_dropped * 100.0) /\n\t\t\t(qstats.bytes_total + 1);\n\t\tfprintf(fout, \"pkts_dropped_percent:%6.2f\\n\", percent_pkts);\n\t\tfprintf(fout, \"bytes_dropped_percent:%6.2f\\n\", percent_bytes);\n\n\t\t \n\t\tpercent_pkts = (qstats.pkts_ecn_ce * 100.0) /\n\t\t\t(qstats.pkts_total + 1);\n\t\tfprintf(fout, \"pkts_ecn_ce:%6.2f (%d)\\n\", percent_pkts,\n\t\t\t(int)qstats.pkts_ecn_ce);\n\n\t\t \n\t\tfprintf(fout, \"avg cwnd:%d\\n\",\n\t\t\t(int)(qstats.sum_cwnd / (qstats.sum_cwnd_cnt + 1)));\n\t\t \n\t\tfprintf(fout, \"avg rtt:%d\\n\",\n\t\t\t(int)(qstats.sum_rtt / (qstats.pkts_total + 1)));\n\t\t \n\t\tif (edt_flag)\n\t\t\tfprintf(fout, \"avg credit_ms:%.03f\\n\",\n\t\t\t\t(qstats.sum_credit /\n\t\t\t\t (qstats.pkts_total + 1.0)) / 1000000.0);\n\t\telse\n\t\t\tfprintf(fout, \"avg credit:%d\\n\",\n\t\t\t\t(int)(qstats.sum_credit /\n\t\t\t\t      (1500 * ((int)qstats.pkts_total ) + 1)));\n\n\t\t \n\t\tfor (k = 0; k < RET_VAL_COUNT; k++) {\n\t\t\tpercent_pkts = (qstats.returnValCount[k] * 100.0) /\n\t\t\t\t(qstats.pkts_total + 1);\n\t\t\tfprintf(fout, \"%s:%6.2f (%d)\\n\", returnValNames[k],\n\t\t\t\tpercent_pkts, (int)qstats.returnValCount[k]);\n\t\t}\n\t\tfclose(fout);\n\t}\n\n\tif (debugFlag)\n\t\tread_trace_pipe2();\n\tgoto cleanup;\n\nerr:\n\trc = 1;\n\ncleanup:\n\tbpf_link__destroy(link);\n\tbpf_object__close(obj);\n\n\tif (cg1 != -1)\n\t\tclose(cg1);\n\n\tif (rc != 0)\n\t\tcleanup_cgroup_environment();\n\treturn rc;\n}\n\nstatic void Usage(void)\n{\n\tprintf(\"This program loads a cgroup skb BPF program to enforce\\n\"\n\t       \"cgroup output (egress) bandwidth limits.\\n\\n\"\n\t       \"USAGE: hbm [-o] [-d]  [-l] [-n <id>] [--no_cn] [-r <rate>]\\n\"\n\t       \"           [-s] [-t <secs>] [-w] [-h] [prog]\\n\"\n\t       \"  Where:\\n\"\n\t       \"    -o         indicates egress direction (default)\\n\"\n\t       \"    -d         print BPF trace debug buffer\\n\"\n\t       \"    --edt      use fq's Earliest Departure Time\\n\"\n\t       \"    -l         also limit flows using loopback\\n\"\n\t       \"    -n <#>     to create cgroup \\\"/hbm#\\\" and attach prog\\n\"\n\t       \"               Default is /hbm1\\n\"\n\t       \"    --no_cn    disable CN notifications\\n\"\n\t       \"    -r <rate>  Rate in Mbps\\n\"\n\t       \"    -s         Update HBM stats\\n\"\n\t       \"    -t <time>  Exit after specified seconds (default is 0)\\n\"\n\t       \"    -w\t       Work conserving flag. cgroup can increase\\n\"\n\t       \"               bandwidth beyond the rate limit specified\\n\"\n\t       \"               while there is available bandwidth. Current\\n\"\n\t       \"               implementation assumes there is only eth0\\n\"\n\t       \"               but can be extended to support multiple NICs\\n\"\n\t       \"    -h         print this info\\n\"\n\t       \"    prog       BPF program file name. Name defaults to\\n\"\n\t       \"                 hbm_out_kern.o\\n\");\n}\n\nint main(int argc, char **argv)\n{\n\tchar *prog = \"hbm_out_kern.o\";\n\tint  k;\n\tint cg_id = 1;\n\tchar *optstring = \"iodln:r:st:wh\";\n\tstruct option loptions[] = {\n\t\t{\"no_cn\", 0, NULL, 1},\n\t\t{\"edt\", 0, NULL, 2},\n\t\t{NULL, 0, NULL, 0}\n\t};\n\n\twhile ((k = getopt_long(argc, argv, optstring, loptions, NULL)) != -1) {\n\t\tswitch (k) {\n\t\tcase 1:\n\t\t\tno_cn_flag = true;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tprog = \"hbm_edt_kern.o\";\n\t\t\tedt_flag = true;\n\t\t\tbreak;\n\t\tcase'o':\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tdebugFlag = true;\n\t\t\tbreak;\n\t\tcase 'l':\n\t\t\tloopback_flag = true;\n\t\t\tbreak;\n\t\tcase 'n':\n\t\t\tcg_id = atoi(optarg);\n\t\t\tbreak;\n\t\tcase 'r':\n\t\t\tminRate = atoi(optarg) * 1.024;\n\t\t\trate = minRate;\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tstats_flag = true;\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\tdur = atoi(optarg);\n\t\t\tbreak;\n\t\tcase 'w':\n\t\t\twork_conserving_flag = true;\n\t\t\tbreak;\n\t\tcase '?':\n\t\t\tif (optopt == 'n' || optopt == 'r' || optopt == 't')\n\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\"Option -%c requires an argument.\\n\\n\",\n\t\t\t\t\toptopt);\n\t\tcase 'h':\n\t\tdefault:\n\t\t\tUsage();\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (optind < argc)\n\t\tprog = argv[optind];\n\tprintf(\"HBM prog: %s\\n\", prog != NULL ? prog : \"NULL\");\n\n\t \n\tlibbpf_set_strict_mode(LIBBPF_STRICT_ALL);\n\n\treturn run_bpf_prog(prog, cg_id);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}