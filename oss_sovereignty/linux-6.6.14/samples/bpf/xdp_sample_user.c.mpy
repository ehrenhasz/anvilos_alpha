{
  "module_name": "xdp_sample_user.c",
  "hash_id": "bd45084293d1f8a02ea5a69451af21d4bd2fc029911e7d7aa5539779d72b9b47",
  "original_prompt": "Ingested from linux-6.6.14/samples/bpf/xdp_sample_user.c",
  "human_readable_source": "\n#define _GNU_SOURCE\n\n#include <arpa/inet.h>\n#include <bpf/bpf.h>\n#include <bpf/libbpf.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <getopt.h>\n#include <linux/ethtool.h>\n#include <linux/hashtable.h>\n#include <linux/if_link.h>\n#include <linux/jhash.h>\n#include <linux/limits.h>\n#include <linux/list.h>\n#include <linux/sockios.h>\n#include <locale.h>\n#include <math.h>\n#include <net/if.h>\n#include <poll.h>\n#include <signal.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/ioctl.h>\n#include <sys/mman.h>\n#include <sys/signalfd.h>\n#include <sys/sysinfo.h>\n#include <sys/timerfd.h>\n#include <sys/utsname.h>\n#include <time.h>\n#include <unistd.h>\n\n#include \"bpf_util.h\"\n#include \"xdp_sample_user.h\"\n\n#define __sample_print(fmt, cond, ...)                                         \\\n\t({                                                                     \\\n\t\tif (cond)                                                      \\\n\t\t\tprintf(fmt, ##__VA_ARGS__);                            \\\n\t})\n\n#define print_always(fmt, ...) __sample_print(fmt, 1, ##__VA_ARGS__)\n#define print_default(fmt, ...)                                                \\\n\t__sample_print(fmt, sample_log_level & LL_DEFAULT, ##__VA_ARGS__)\n#define __print_err(err, fmt, ...)                                             \\\n\t({                                                                     \\\n\t\t__sample_print(fmt, err > 0 || sample_log_level & LL_DEFAULT,  \\\n\t\t\t       ##__VA_ARGS__);                                 \\\n\t\tsample_err_exp = sample_err_exp ? true : err > 0;              \\\n\t})\n#define print_err(err, fmt, ...) __print_err(err, fmt, ##__VA_ARGS__)\n\n#define __COLUMN(x) \"%'10\" x \" %-13s\"\n#define FMT_COLUMNf __COLUMN(\".0f\")\n#define FMT_COLUMNd __COLUMN(\"d\")\n#define FMT_COLUMNl __COLUMN(\"llu\")\n#define RX(rx) rx, \"rx/s\"\n#define PPS(pps) pps, \"pkt/s\"\n#define DROP(drop) drop, \"drop/s\"\n#define ERR(err) err, \"error/s\"\n#define HITS(hits) hits, \"hit/s\"\n#define XMIT(xmit) xmit, \"xmit/s\"\n#define PASS(pass) pass, \"pass/s\"\n#define REDIR(redir) redir, \"redir/s\"\n#define NANOSEC_PER_SEC 1000000000  \n\n#define XDP_UNKNOWN (XDP_REDIRECT + 1)\n#define XDP_ACTION_MAX (XDP_UNKNOWN + 1)\n#define XDP_REDIRECT_ERR_MAX 7\n\nenum map_type {\n\tMAP_RX,\n\tMAP_REDIRECT_ERR,\n\tMAP_CPUMAP_ENQUEUE,\n\tMAP_CPUMAP_KTHREAD,\n\tMAP_EXCEPTION,\n\tMAP_DEVMAP_XMIT,\n\tMAP_DEVMAP_XMIT_MULTI,\n\tNUM_MAP,\n};\n\nenum log_level {\n\tLL_DEFAULT = 1U << 0,\n\tLL_SIMPLE = 1U << 1,\n\tLL_DEBUG = 1U << 2,\n};\n\nstruct record {\n\t__u64 timestamp;\n\tstruct datarec total;\n\tstruct datarec *cpu;\n};\n\nstruct map_entry {\n\tstruct hlist_node node;\n\t__u64 pair;\n\tstruct record val;\n};\n\nstruct stats_record {\n\tstruct record rx_cnt;\n\tstruct record redir_err[XDP_REDIRECT_ERR_MAX];\n\tstruct record kthread;\n\tstruct record exception[XDP_ACTION_MAX];\n\tstruct record devmap_xmit;\n\tDECLARE_HASHTABLE(xmit_map, 5);\n\tstruct record enq[];\n};\n\nstruct sample_output {\n\tstruct {\n\t\t__u64 rx;\n\t\t__u64 redir;\n\t\t__u64 drop;\n\t\t__u64 drop_xmit;\n\t\t__u64 err;\n\t\t__u64 xmit;\n\t} totals;\n\tstruct {\n\t\tunion {\n\t\t\t__u64 pps;\n\t\t\t__u64 num;\n\t\t};\n\t\t__u64 drop;\n\t\t__u64 err;\n\t} rx_cnt;\n\tstruct {\n\t\t__u64 suc;\n\t\t__u64 err;\n\t} redir_cnt;\n\tstruct {\n\t\t__u64 hits;\n\t} except_cnt;\n\tstruct {\n\t\t__u64 pps;\n\t\t__u64 drop;\n\t\t__u64 err;\n\t\tdouble bavg;\n\t} xmit_cnt;\n};\n\nstruct xdp_desc {\n\tint ifindex;\n\t__u32 prog_id;\n\tint flags;\n} sample_xdp_progs[32];\n\nstruct datarec *sample_mmap[NUM_MAP];\nstruct bpf_map *sample_map[NUM_MAP];\nsize_t sample_map_count[NUM_MAP];\nenum log_level sample_log_level;\nstruct sample_output sample_out;\nunsigned long sample_interval;\nbool sample_err_exp;\nint sample_xdp_cnt;\nint sample_n_cpus;\nint sample_sig_fd;\nint sample_mask;\n\nstatic const char *xdp_redirect_err_names[XDP_REDIRECT_ERR_MAX] = {\n\t \n\t\"Success\",\n\t\"Unknown\",\n\t\"EINVAL\",\n\t\"ENETDOWN\",\n\t\"EMSGSIZE\",\n\t\"EOPNOTSUPP\",\n\t\"ENOSPC\",\n};\n\n \nstatic const char *xdp_redirect_err_help[XDP_REDIRECT_ERR_MAX - 1] = {\n\t\"Unknown error\",\n\t\"Invalid redirection\",\n\t\"Device being redirected to is down\",\n\t\"Packet length too large for device\",\n\t\"Operation not supported\",\n\t\"No space in ptr_ring of cpumap kthread\",\n};\n\nstatic const char *xdp_action_names[XDP_ACTION_MAX] = {\n\t[XDP_ABORTED]  = \"XDP_ABORTED\",\n\t[XDP_DROP]     = \"XDP_DROP\",\n\t[XDP_PASS]     = \"XDP_PASS\",\n\t[XDP_TX]       = \"XDP_TX\",\n\t[XDP_REDIRECT] = \"XDP_REDIRECT\",\n\t[XDP_UNKNOWN]  = \"XDP_UNKNOWN\",\n};\n\nstatic __u64 gettime(void)\n{\n\tstruct timespec t;\n\tint res;\n\n\tres = clock_gettime(CLOCK_MONOTONIC, &t);\n\tif (res < 0) {\n\t\tfprintf(stderr, \"Error with gettimeofday! (%i)\\n\", res);\n\t\treturn UINT64_MAX;\n\t}\n\treturn (__u64)t.tv_sec * NANOSEC_PER_SEC + t.tv_nsec;\n}\n\nstatic const char *action2str(int action)\n{\n\tif (action < XDP_ACTION_MAX)\n\t\treturn xdp_action_names[action];\n\treturn NULL;\n}\n\nstatic void sample_print_help(int mask)\n{\n\tprintf(\"Output format description\\n\\n\"\n\t       \"By default, redirect success statistics are disabled, use -s to enable.\\n\"\n\t       \"The terse output mode is default, verbose mode can be activated using -v\\n\"\n\t       \"Use SIGQUIT (Ctrl + \\\\) to switch the mode dynamically at runtime\\n\\n\"\n\t       \"Terse mode displays at most the following fields:\\n\"\n\t       \"  rx/s        Number of packets received per second\\n\"\n\t       \"  redir/s     Number of packets successfully redirected per second\\n\"\n\t       \"  err,drop/s  Aggregated count of errors per second (including dropped packets)\\n\"\n\t       \"  xmit/s      Number of packets transmitted on the output device per second\\n\\n\"\n\t       \"Output description for verbose mode:\\n\"\n\t       \"  FIELD                 DESCRIPTION\\n\");\n\n\tif (mask & SAMPLE_RX_CNT) {\n\t\tprintf(\"  receive\\t\\tDisplays the number of packets received & errors encountered\\n\"\n\t\t       \" \\t\\t\\tWhenever an error or packet drop occurs, details of per CPU error\\n\"\n\t\t       \" \\t\\t\\tand drop statistics will be expanded inline in terse mode.\\n\"\n\t\t       \" \\t\\t\\t\\tpkt/s     - Packets received per second\\n\"\n\t\t       \" \\t\\t\\t\\tdrop/s    - Packets dropped per second\\n\"\n\t\t       \" \\t\\t\\t\\terror/s   - Errors encountered per second\\n\\n\");\n\t}\n\tif (mask & (SAMPLE_REDIRECT_CNT | SAMPLE_REDIRECT_ERR_CNT)) {\n\t\tprintf(\"  redirect\\t\\tDisplays the number of packets successfully redirected\\n\"\n\t\t       \"  \\t\\t\\tErrors encountered are expanded under redirect_err field\\n\"\n\t\t       \"  \\t\\t\\tNote that passing -s to enable it has a per packet overhead\\n\"\n\t\t       \"  \\t\\t\\t\\tredir/s   - Packets redirected successfully per second\\n\\n\"\n\t\t       \"  redirect_err\\t\\tDisplays the number of packets that failed redirection\\n\"\n\t\t       \"  \\t\\t\\tThe errno is expanded under this field with per CPU count\\n\"\n\t\t       \"  \\t\\t\\tThe recognized errors are:\\n\");\n\n\t\tfor (int i = 2; i < XDP_REDIRECT_ERR_MAX; i++)\n\t\t\tprintf(\"\\t\\t\\t  %s: %s\\n\", xdp_redirect_err_names[i],\n\t\t\t       xdp_redirect_err_help[i - 1]);\n\n\t\tprintf(\"  \\n\\t\\t\\t\\terror/s   - Packets that failed redirection per second\\n\\n\");\n\t}\n\n\tif (mask & SAMPLE_CPUMAP_ENQUEUE_CNT) {\n\t\tprintf(\"  enqueue to cpu N\\tDisplays the number of packets enqueued to bulk queue of CPU N\\n\"\n\t\t       \"  \\t\\t\\tExpands to cpu:FROM->N to display enqueue stats for each CPU enqueuing to CPU N\\n\"\n\t\t       \"  \\t\\t\\tReceived packets can be associated with the CPU redirect program is enqueuing \\n\"\n\t\t       \"  \\t\\t\\tpackets to.\\n\"\n\t\t       \"  \\t\\t\\t\\tpkt/s    - Packets enqueued per second from other CPU to CPU N\\n\"\n\t\t       \"  \\t\\t\\t\\tdrop/s   - Packets dropped when trying to enqueue to CPU N\\n\"\n\t\t       \"  \\t\\t\\t\\tbulk-avg - Average number of packets processed for each event\\n\\n\");\n\t}\n\n\tif (mask & SAMPLE_CPUMAP_KTHREAD_CNT) {\n\t\tprintf(\"  kthread\\t\\tDisplays the number of packets processed in CPUMAP kthread for each CPU\\n\"\n\t\t       \"  \\t\\t\\tPackets consumed from ptr_ring in kthread, and its xdp_stats (after calling \\n\"\n\t\t       \"  \\t\\t\\tCPUMAP bpf prog) are expanded below this. xdp_stats are expanded as a total and\\n\"\n\t\t       \"  \\t\\t\\tthen per-CPU to associate it to each CPU's pinned CPUMAP kthread.\\n\"\n\t\t       \"  \\t\\t\\t\\tpkt/s    - Packets consumed per second from ptr_ring\\n\"\n\t\t       \"  \\t\\t\\t\\tdrop/s   - Packets dropped per second in kthread\\n\"\n\t\t       \"  \\t\\t\\t\\tsched    - Number of times kthread called schedule()\\n\\n\"\n\t\t       \"  \\t\\t\\txdp_stats (also expands to per-CPU counts)\\n\"\n\t\t       \"  \\t\\t\\t\\tpass/s  - XDP_PASS count for CPUMAP program execution\\n\"\n\t\t       \"  \\t\\t\\t\\tdrop/s  - XDP_DROP count for CPUMAP program execution\\n\"\n\t\t       \"  \\t\\t\\t\\tredir/s - XDP_REDIRECT count for CPUMAP program execution\\n\\n\");\n\t}\n\n\tif (mask & SAMPLE_EXCEPTION_CNT) {\n\t\tprintf(\"  xdp_exception\\t\\tDisplays xdp_exception tracepoint events\\n\"\n\t\t       \"  \\t\\t\\tThis can occur due to internal driver errors, unrecognized\\n\"\n\t\t       \"  \\t\\t\\tXDP actions and due to explicit user trigger by use of XDP_ABORTED\\n\"\n\t\t       \"  \\t\\t\\tEach action is expanded below this field with its count\\n\"\n\t\t       \"  \\t\\t\\t\\thit/s     - Number of times the tracepoint was hit per second\\n\\n\");\n\t}\n\n\tif (mask & SAMPLE_DEVMAP_XMIT_CNT) {\n\t\tprintf(\"  devmap_xmit\\t\\tDisplays devmap_xmit tracepoint events\\n\"\n\t\t       \"  \\t\\t\\tThis tracepoint is invoked for successful transmissions on output\\n\"\n\t\t       \"  \\t\\t\\tdevice but these statistics are not available for generic XDP mode,\\n\"\n\t\t       \"  \\t\\t\\thence they will be omitted from the output when using SKB mode\\n\"\n\t\t       \"  \\t\\t\\t\\txmit/s    - Number of packets that were transmitted per second\\n\"\n\t\t       \"  \\t\\t\\t\\tdrop/s    - Number of packets that failed transmissions per second\\n\"\n\t\t       \"  \\t\\t\\t\\tdrv_err/s - Number of internal driver errors per second\\n\"\n\t\t       \"  \\t\\t\\t\\tbulk-avg  - Average number of packets processed for each event\\n\\n\");\n\t}\n}\n\nvoid sample_usage(char *argv[], const struct option *long_options,\n\t\t  const char *doc, int mask, bool error)\n{\n\tint i;\n\n\tif (!error)\n\t\tsample_print_help(mask);\n\n\tprintf(\"\\n%s\\nOption for %s:\\n\", doc, argv[0]);\n\tfor (i = 0; long_options[i].name != 0; i++) {\n\t\tprintf(\" --%-15s\", long_options[i].name);\n\t\tif (long_options[i].flag != NULL)\n\t\t\tprintf(\" flag (internal value: %d)\",\n\t\t\t       *long_options[i].flag);\n\t\telse\n\t\t\tprintf(\"\\t short-option: -%c\", long_options[i].val);\n\t\tprintf(\"\\n\");\n\t}\n\tprintf(\"\\n\");\n}\n\nstatic struct datarec *alloc_record_per_cpu(void)\n{\n\tunsigned int nr_cpus = libbpf_num_possible_cpus();\n\tstruct datarec *array;\n\n\tarray = calloc(nr_cpus, sizeof(*array));\n\tif (!array) {\n\t\tfprintf(stderr, \"Failed to allocate memory (nr_cpus: %u)\\n\",\n\t\t\tnr_cpus);\n\t\treturn NULL;\n\t}\n\treturn array;\n}\n\nstatic int map_entry_init(struct map_entry *e, __u64 pair)\n{\n\te->pair = pair;\n\tINIT_HLIST_NODE(&e->node);\n\te->val.timestamp = gettime();\n\te->val.cpu = alloc_record_per_cpu();\n\tif (!e->val.cpu)\n\t\treturn -ENOMEM;\n\treturn 0;\n}\n\nstatic void map_collect_percpu(struct datarec *values, struct record *rec)\n{\n\t \n\tunsigned int nr_cpus = libbpf_num_possible_cpus();\n\t__u64 sum_xdp_redirect = 0;\n\t__u64 sum_processed = 0;\n\t__u64 sum_xdp_pass = 0;\n\t__u64 sum_xdp_drop = 0;\n\t__u64 sum_dropped = 0;\n\t__u64 sum_issue = 0;\n\tint i;\n\n\t \n\trec->timestamp = gettime();\n\n\t \n\tfor (i = 0; i < nr_cpus; i++) {\n\t\trec->cpu[i].processed = READ_ONCE(values[i].processed);\n\t\trec->cpu[i].dropped = READ_ONCE(values[i].dropped);\n\t\trec->cpu[i].issue = READ_ONCE(values[i].issue);\n\t\trec->cpu[i].xdp_pass = READ_ONCE(values[i].xdp_pass);\n\t\trec->cpu[i].xdp_drop = READ_ONCE(values[i].xdp_drop);\n\t\trec->cpu[i].xdp_redirect = READ_ONCE(values[i].xdp_redirect);\n\n\t\tsum_processed += rec->cpu[i].processed;\n\t\tsum_dropped += rec->cpu[i].dropped;\n\t\tsum_issue += rec->cpu[i].issue;\n\t\tsum_xdp_pass += rec->cpu[i].xdp_pass;\n\t\tsum_xdp_drop += rec->cpu[i].xdp_drop;\n\t\tsum_xdp_redirect += rec->cpu[i].xdp_redirect;\n\t}\n\n\trec->total.processed = sum_processed;\n\trec->total.dropped = sum_dropped;\n\trec->total.issue = sum_issue;\n\trec->total.xdp_pass = sum_xdp_pass;\n\trec->total.xdp_drop = sum_xdp_drop;\n\trec->total.xdp_redirect = sum_xdp_redirect;\n}\n\nstatic int map_collect_percpu_devmap(int map_fd, struct stats_record *rec)\n{\n\tunsigned int nr_cpus = bpf_num_possible_cpus();\n\t__u32 batch, count = 32;\n\tstruct datarec *values;\n\tbool init = false;\n\t__u64 *keys;\n\tint i, ret;\n\n\tkeys = calloc(count, sizeof(__u64));\n\tif (!keys)\n\t\treturn -ENOMEM;\n\tvalues = calloc(count * nr_cpus, sizeof(struct datarec));\n\tif (!values) {\n\t\tfree(keys);\n\t\treturn -ENOMEM;\n\t}\n\n\tfor (;;) {\n\t\tbool exit = false;\n\n\t\tret = bpf_map_lookup_batch(map_fd, init ? &batch : NULL, &batch,\n\t\t\t\t\t   keys, values, &count, NULL);\n\t\tif (ret < 0 && errno != ENOENT)\n\t\t\tbreak;\n\t\tif (errno == ENOENT)\n\t\t\texit = true;\n\n\t\tinit = true;\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tstruct map_entry *e, *x = NULL;\n\t\t\t__u64 pair = keys[i];\n\t\t\tstruct datarec *arr;\n\n\t\t\tarr = &values[i * nr_cpus];\n\t\t\thash_for_each_possible(rec->xmit_map, e, node, pair) {\n\t\t\t\tif (e->pair == pair) {\n\t\t\t\t\tx = e;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!x) {\n\t\t\t\tx = calloc(1, sizeof(*x));\n\t\t\t\tif (!x)\n\t\t\t\t\tgoto cleanup;\n\t\t\t\tif (map_entry_init(x, pair) < 0) {\n\t\t\t\t\tfree(x);\n\t\t\t\t\tgoto cleanup;\n\t\t\t\t}\n\t\t\t\thash_add(rec->xmit_map, &x->node, pair);\n\t\t\t}\n\t\t\tmap_collect_percpu(arr, &x->val);\n\t\t}\n\n\t\tif (exit)\n\t\t\tbreak;\n\t\tcount = 32;\n\t}\n\n\tfree(values);\n\tfree(keys);\n\treturn 0;\ncleanup:\n\tfree(values);\n\tfree(keys);\n\treturn -ENOMEM;\n}\n\nstatic struct stats_record *alloc_stats_record(void)\n{\n\tstruct stats_record *rec;\n\tint i;\n\n\trec = calloc(1, sizeof(*rec) + sample_n_cpus * sizeof(struct record));\n\tif (!rec) {\n\t\tfprintf(stderr, \"Failed to allocate memory\\n\");\n\t\treturn NULL;\n\t}\n\n\tif (sample_mask & SAMPLE_RX_CNT) {\n\t\trec->rx_cnt.cpu = alloc_record_per_cpu();\n\t\tif (!rec->rx_cnt.cpu) {\n\t\t\tfprintf(stderr,\n\t\t\t\t\"Failed to allocate rx_cnt per-CPU array\\n\");\n\t\t\tgoto end_rec;\n\t\t}\n\t}\n\tif (sample_mask & (SAMPLE_REDIRECT_CNT | SAMPLE_REDIRECT_ERR_CNT)) {\n\t\tfor (i = 0; i < XDP_REDIRECT_ERR_MAX; i++) {\n\t\t\trec->redir_err[i].cpu = alloc_record_per_cpu();\n\t\t\tif (!rec->redir_err[i].cpu) {\n\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\"Failed to allocate redir_err per-CPU array for \"\n\t\t\t\t\t\"\\\"%s\\\" case\\n\",\n\t\t\t\t\txdp_redirect_err_names[i]);\n\t\t\t\twhile (i--)\n\t\t\t\t\tfree(rec->redir_err[i].cpu);\n\t\t\t\tgoto end_rx_cnt;\n\t\t\t}\n\t\t}\n\t}\n\tif (sample_mask & SAMPLE_CPUMAP_KTHREAD_CNT) {\n\t\trec->kthread.cpu = alloc_record_per_cpu();\n\t\tif (!rec->kthread.cpu) {\n\t\t\tfprintf(stderr,\n\t\t\t\t\"Failed to allocate kthread per-CPU array\\n\");\n\t\t\tgoto end_redir;\n\t\t}\n\t}\n\tif (sample_mask & SAMPLE_EXCEPTION_CNT) {\n\t\tfor (i = 0; i < XDP_ACTION_MAX; i++) {\n\t\t\trec->exception[i].cpu = alloc_record_per_cpu();\n\t\t\tif (!rec->exception[i].cpu) {\n\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\"Failed to allocate exception per-CPU array for \"\n\t\t\t\t\t\"\\\"%s\\\" case\\n\",\n\t\t\t\t\taction2str(i));\n\t\t\t\twhile (i--)\n\t\t\t\t\tfree(rec->exception[i].cpu);\n\t\t\t\tgoto end_kthread;\n\t\t\t}\n\t\t}\n\t}\n\tif (sample_mask & SAMPLE_DEVMAP_XMIT_CNT) {\n\t\trec->devmap_xmit.cpu = alloc_record_per_cpu();\n\t\tif (!rec->devmap_xmit.cpu) {\n\t\t\tfprintf(stderr,\n\t\t\t\t\"Failed to allocate devmap_xmit per-CPU array\\n\");\n\t\t\tgoto end_exception;\n\t\t}\n\t}\n\tif (sample_mask & SAMPLE_DEVMAP_XMIT_CNT_MULTI)\n\t\thash_init(rec->xmit_map);\n\tif (sample_mask & SAMPLE_CPUMAP_ENQUEUE_CNT) {\n\t\tfor (i = 0; i < sample_n_cpus; i++) {\n\t\t\trec->enq[i].cpu = alloc_record_per_cpu();\n\t\t\tif (!rec->enq[i].cpu) {\n\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\"Failed to allocate enqueue per-CPU array for \"\n\t\t\t\t\t\"CPU %d\\n\",\n\t\t\t\t\ti);\n\t\t\t\twhile (i--)\n\t\t\t\t\tfree(rec->enq[i].cpu);\n\t\t\t\tgoto end_devmap_xmit;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn rec;\n\nend_devmap_xmit:\n\tfree(rec->devmap_xmit.cpu);\nend_exception:\n\tfor (i = 0; i < XDP_ACTION_MAX; i++)\n\t\tfree(rec->exception[i].cpu);\nend_kthread:\n\tfree(rec->kthread.cpu);\nend_redir:\n\tfor (i = 0; i < XDP_REDIRECT_ERR_MAX; i++)\n\t\tfree(rec->redir_err[i].cpu);\nend_rx_cnt:\n\tfree(rec->rx_cnt.cpu);\nend_rec:\n\tfree(rec);\n\treturn NULL;\n}\n\nstatic void free_stats_record(struct stats_record *r)\n{\n\tstruct hlist_node *tmp;\n\tstruct map_entry *e;\n\tint i;\n\n\tfor (i = 0; i < sample_n_cpus; i++)\n\t\tfree(r->enq[i].cpu);\n\thash_for_each_safe(r->xmit_map, i, tmp, e, node) {\n\t\thash_del(&e->node);\n\t\tfree(e->val.cpu);\n\t\tfree(e);\n\t}\n\tfree(r->devmap_xmit.cpu);\n\tfor (i = 0; i < XDP_ACTION_MAX; i++)\n\t\tfree(r->exception[i].cpu);\n\tfree(r->kthread.cpu);\n\tfor (i = 0; i < XDP_REDIRECT_ERR_MAX; i++)\n\t\tfree(r->redir_err[i].cpu);\n\tfree(r->rx_cnt.cpu);\n\tfree(r);\n}\n\nstatic double calc_period(struct record *r, struct record *p)\n{\n\tdouble period_ = 0;\n\t__u64 period = 0;\n\n\tperiod = r->timestamp - p->timestamp;\n\tif (period > 0)\n\t\tperiod_ = ((double)period / NANOSEC_PER_SEC);\n\n\treturn period_;\n}\n\nstatic double sample_round(double val)\n{\n\tif (val - floor(val) < 0.5)\n\t\treturn floor(val);\n\treturn ceil(val);\n}\n\nstatic __u64 calc_pps(struct datarec *r, struct datarec *p, double period_)\n{\n\t__u64 packets = 0;\n\t__u64 pps = 0;\n\n\tif (period_ > 0) {\n\t\tpackets = r->processed - p->processed;\n\t\tpps = sample_round(packets / period_);\n\t}\n\treturn pps;\n}\n\nstatic __u64 calc_drop_pps(struct datarec *r, struct datarec *p, double period_)\n{\n\t__u64 packets = 0;\n\t__u64 pps = 0;\n\n\tif (period_ > 0) {\n\t\tpackets = r->dropped - p->dropped;\n\t\tpps = sample_round(packets / period_);\n\t}\n\treturn pps;\n}\n\nstatic __u64 calc_errs_pps(struct datarec *r, struct datarec *p, double period_)\n{\n\t__u64 packets = 0;\n\t__u64 pps = 0;\n\n\tif (period_ > 0) {\n\t\tpackets = r->issue - p->issue;\n\t\tpps = sample_round(packets / period_);\n\t}\n\treturn pps;\n}\n\nstatic __u64 calc_info_pps(struct datarec *r, struct datarec *p, double period_)\n{\n\t__u64 packets = 0;\n\t__u64 pps = 0;\n\n\tif (period_ > 0) {\n\t\tpackets = r->info - p->info;\n\t\tpps = sample_round(packets / period_);\n\t}\n\treturn pps;\n}\n\nstatic void calc_xdp_pps(struct datarec *r, struct datarec *p, double *xdp_pass,\n\t\t\t double *xdp_drop, double *xdp_redirect, double period_)\n{\n\t*xdp_pass = 0, *xdp_drop = 0, *xdp_redirect = 0;\n\tif (period_ > 0) {\n\t\t*xdp_redirect = (r->xdp_redirect - p->xdp_redirect) / period_;\n\t\t*xdp_pass = (r->xdp_pass - p->xdp_pass) / period_;\n\t\t*xdp_drop = (r->xdp_drop - p->xdp_drop) / period_;\n\t}\n}\n\nstatic void stats_get_rx_cnt(struct stats_record *stats_rec,\n\t\t\t     struct stats_record *stats_prev,\n\t\t\t     unsigned int nr_cpus, struct sample_output *out)\n{\n\tstruct record *rec, *prev;\n\tdouble t, pps, drop, err;\n\tint i;\n\n\trec = &stats_rec->rx_cnt;\n\tprev = &stats_prev->rx_cnt;\n\tt = calc_period(rec, prev);\n\n\tfor (i = 0; i < nr_cpus; i++) {\n\t\tstruct datarec *r = &rec->cpu[i];\n\t\tstruct datarec *p = &prev->cpu[i];\n\t\tchar str[64];\n\n\t\tpps = calc_pps(r, p, t);\n\t\tdrop = calc_drop_pps(r, p, t);\n\t\terr = calc_errs_pps(r, p, t);\n\t\tif (!pps && !drop && !err)\n\t\t\tcontinue;\n\n\t\tsnprintf(str, sizeof(str), \"cpu:%d\", i);\n\t\tprint_default(\"    %-18s \" FMT_COLUMNf FMT_COLUMNf FMT_COLUMNf\n\t\t\t      \"\\n\",\n\t\t\t      str, PPS(pps), DROP(drop), ERR(err));\n\t}\n\n\tif (out) {\n\t\tpps = calc_pps(&rec->total, &prev->total, t);\n\t\tdrop = calc_drop_pps(&rec->total, &prev->total, t);\n\t\terr = calc_errs_pps(&rec->total, &prev->total, t);\n\n\t\tout->rx_cnt.pps = pps;\n\t\tout->rx_cnt.drop = drop;\n\t\tout->rx_cnt.err = err;\n\t\tout->totals.rx += pps;\n\t\tout->totals.drop += drop;\n\t\tout->totals.err += err;\n\t}\n}\n\nstatic void stats_get_cpumap_enqueue(struct stats_record *stats_rec,\n\t\t\t\t     struct stats_record *stats_prev,\n\t\t\t\t     unsigned int nr_cpus)\n{\n\tstruct record *rec, *prev;\n\tdouble t, pps, drop, err;\n\tint i, to_cpu;\n\n\t \n\tfor (to_cpu = 0; to_cpu < sample_n_cpus; to_cpu++) {\n\t\trec = &stats_rec->enq[to_cpu];\n\t\tprev = &stats_prev->enq[to_cpu];\n\t\tt = calc_period(rec, prev);\n\n\t\tpps = calc_pps(&rec->total, &prev->total, t);\n\t\tdrop = calc_drop_pps(&rec->total, &prev->total, t);\n\t\terr = calc_errs_pps(&rec->total, &prev->total, t);\n\n\t\tif (pps > 0 || drop > 0) {\n\t\t\tchar str[64];\n\n\t\t\tsnprintf(str, sizeof(str), \"enqueue to cpu %d\", to_cpu);\n\n\t\t\tif (err > 0)\n\t\t\t\terr = pps / err;  \n\n\t\t\tprint_err(drop,\n\t\t\t\t  \"  %-20s \" FMT_COLUMNf FMT_COLUMNf __COLUMN(\n\t\t\t\t\t  \".2f\") \"\\n\",\n\t\t\t\t  str, PPS(pps), DROP(drop), err, \"bulk-avg\");\n\t\t}\n\n\t\tfor (i = 0; i < nr_cpus; i++) {\n\t\t\tstruct datarec *r = &rec->cpu[i];\n\t\t\tstruct datarec *p = &prev->cpu[i];\n\t\t\tchar str[64];\n\n\t\t\tpps = calc_pps(r, p, t);\n\t\t\tdrop = calc_drop_pps(r, p, t);\n\t\t\terr = calc_errs_pps(r, p, t);\n\t\t\tif (!pps && !drop && !err)\n\t\t\t\tcontinue;\n\n\t\t\tsnprintf(str, sizeof(str), \"cpu:%d->%d\", i, to_cpu);\n\t\t\tif (err > 0)\n\t\t\t\terr = pps / err;  \n\t\t\tprint_default(\n\t\t\t\t\"    %-18s \" FMT_COLUMNf FMT_COLUMNf __COLUMN(\n\t\t\t\t\t\".2f\") \"\\n\",\n\t\t\t\tstr, PPS(pps), DROP(drop), err, \"bulk-avg\");\n\t\t}\n\t}\n}\n\nstatic void stats_get_cpumap_remote(struct stats_record *stats_rec,\n\t\t\t\t    struct stats_record *stats_prev,\n\t\t\t\t    unsigned int nr_cpus)\n{\n\tdouble xdp_pass, xdp_drop, xdp_redirect;\n\tstruct record *rec, *prev;\n\tdouble t;\n\tint i;\n\n\trec = &stats_rec->kthread;\n\tprev = &stats_prev->kthread;\n\tt = calc_period(rec, prev);\n\n\tcalc_xdp_pps(&rec->total, &prev->total, &xdp_pass, &xdp_drop,\n\t\t     &xdp_redirect, t);\n\tif (xdp_pass || xdp_drop || xdp_redirect) {\n\t\tprint_err(xdp_drop,\n\t\t\t  \"    %-18s \" FMT_COLUMNf FMT_COLUMNf FMT_COLUMNf \"\\n\",\n\t\t\t  \"xdp_stats\", PASS(xdp_pass), DROP(xdp_drop),\n\t\t\t  REDIR(xdp_redirect));\n\t}\n\n\tfor (i = 0; i < nr_cpus; i++) {\n\t\tstruct datarec *r = &rec->cpu[i];\n\t\tstruct datarec *p = &prev->cpu[i];\n\t\tchar str[64];\n\n\t\tcalc_xdp_pps(r, p, &xdp_pass, &xdp_drop, &xdp_redirect, t);\n\t\tif (!xdp_pass && !xdp_drop && !xdp_redirect)\n\t\t\tcontinue;\n\n\t\tsnprintf(str, sizeof(str), \"cpu:%d\", i);\n\t\tprint_default(\"      %-16s \" FMT_COLUMNf FMT_COLUMNf FMT_COLUMNf\n\t\t\t      \"\\n\",\n\t\t\t      str, PASS(xdp_pass), DROP(xdp_drop),\n\t\t\t      REDIR(xdp_redirect));\n\t}\n}\n\nstatic void stats_get_cpumap_kthread(struct stats_record *stats_rec,\n\t\t\t\t     struct stats_record *stats_prev,\n\t\t\t\t     unsigned int nr_cpus)\n{\n\tstruct record *rec, *prev;\n\tdouble t, pps, drop, err;\n\tint i;\n\n\trec = &stats_rec->kthread;\n\tprev = &stats_prev->kthread;\n\tt = calc_period(rec, prev);\n\n\tpps = calc_pps(&rec->total, &prev->total, t);\n\tdrop = calc_drop_pps(&rec->total, &prev->total, t);\n\terr = calc_errs_pps(&rec->total, &prev->total, t);\n\n\tprint_err(drop, \"  %-20s \" FMT_COLUMNf FMT_COLUMNf FMT_COLUMNf \"\\n\",\n\t\t  pps ? \"kthread total\" : \"kthread\", PPS(pps), DROP(drop), err,\n\t\t  \"sched\");\n\n\tfor (i = 0; i < nr_cpus; i++) {\n\t\tstruct datarec *r = &rec->cpu[i];\n\t\tstruct datarec *p = &prev->cpu[i];\n\t\tchar str[64];\n\n\t\tpps = calc_pps(r, p, t);\n\t\tdrop = calc_drop_pps(r, p, t);\n\t\terr = calc_errs_pps(r, p, t);\n\t\tif (!pps && !drop && !err)\n\t\t\tcontinue;\n\n\t\tsnprintf(str, sizeof(str), \"cpu:%d\", i);\n\t\tprint_default(\"    %-18s \" FMT_COLUMNf FMT_COLUMNf FMT_COLUMNf\n\t\t\t      \"\\n\",\n\t\t\t      str, PPS(pps), DROP(drop), err, \"sched\");\n\t}\n}\n\nstatic void stats_get_redirect_cnt(struct stats_record *stats_rec,\n\t\t\t\t   struct stats_record *stats_prev,\n\t\t\t\t   unsigned int nr_cpus,\n\t\t\t\t   struct sample_output *out)\n{\n\tstruct record *rec, *prev;\n\tdouble t, pps;\n\tint i;\n\n\trec = &stats_rec->redir_err[0];\n\tprev = &stats_prev->redir_err[0];\n\tt = calc_period(rec, prev);\n\tfor (i = 0; i < nr_cpus; i++) {\n\t\tstruct datarec *r = &rec->cpu[i];\n\t\tstruct datarec *p = &prev->cpu[i];\n\t\tchar str[64];\n\n\t\tpps = calc_pps(r, p, t);\n\t\tif (!pps)\n\t\t\tcontinue;\n\n\t\tsnprintf(str, sizeof(str), \"cpu:%d\", i);\n\t\tprint_default(\"    %-18s \" FMT_COLUMNf \"\\n\", str, REDIR(pps));\n\t}\n\n\tif (out) {\n\t\tpps = calc_pps(&rec->total, &prev->total, t);\n\t\tout->redir_cnt.suc = pps;\n\t\tout->totals.redir += pps;\n\t}\n}\n\nstatic void stats_get_redirect_err_cnt(struct stats_record *stats_rec,\n\t\t\t\t       struct stats_record *stats_prev,\n\t\t\t\t       unsigned int nr_cpus,\n\t\t\t\t       struct sample_output *out)\n{\n\tstruct record *rec, *prev;\n\tdouble t, drop, sum = 0;\n\tint rec_i, i;\n\n\tfor (rec_i = 1; rec_i < XDP_REDIRECT_ERR_MAX; rec_i++) {\n\t\tchar str[64];\n\n\t\trec = &stats_rec->redir_err[rec_i];\n\t\tprev = &stats_prev->redir_err[rec_i];\n\t\tt = calc_period(rec, prev);\n\n\t\tdrop = calc_drop_pps(&rec->total, &prev->total, t);\n\t\tif (drop > 0 && !out) {\n\t\t\tsnprintf(str, sizeof(str),\n\t\t\t\t sample_log_level & LL_DEFAULT ? \"%s total\" :\n\t\t\t\t\t\t\t\t       \"%s\",\n\t\t\t\t xdp_redirect_err_names[rec_i]);\n\t\t\tprint_err(drop, \"    %-18s \" FMT_COLUMNf \"\\n\", str,\n\t\t\t\t  ERR(drop));\n\t\t}\n\n\t\tfor (i = 0; i < nr_cpus; i++) {\n\t\t\tstruct datarec *r = &rec->cpu[i];\n\t\t\tstruct datarec *p = &prev->cpu[i];\n\t\t\tdouble drop;\n\n\t\t\tdrop = calc_drop_pps(r, p, t);\n\t\t\tif (!drop)\n\t\t\t\tcontinue;\n\n\t\t\tsnprintf(str, sizeof(str), \"cpu:%d\", i);\n\t\t\tprint_default(\"       %-16s\" FMT_COLUMNf \"\\n\", str,\n\t\t\t\t      ERR(drop));\n\t\t}\n\n\t\tsum += drop;\n\t}\n\n\tif (out) {\n\t\tout->redir_cnt.err = sum;\n\t\tout->totals.err += sum;\n\t}\n}\n\nstatic void stats_get_exception_cnt(struct stats_record *stats_rec,\n\t\t\t\t    struct stats_record *stats_prev,\n\t\t\t\t    unsigned int nr_cpus,\n\t\t\t\t    struct sample_output *out)\n{\n\tdouble t, drop, sum = 0;\n\tstruct record *rec, *prev;\n\tint rec_i, i;\n\n\tfor (rec_i = 0; rec_i < XDP_ACTION_MAX; rec_i++) {\n\t\trec = &stats_rec->exception[rec_i];\n\t\tprev = &stats_prev->exception[rec_i];\n\t\tt = calc_period(rec, prev);\n\n\t\tdrop = calc_drop_pps(&rec->total, &prev->total, t);\n\t\t \n\t\tsum += drop;\n\n\t\tif (drop > 0 && !out) {\n\t\t\tprint_always(\"    %-18s \" FMT_COLUMNf \"\\n\",\n\t\t\t\t     action2str(rec_i), ERR(drop));\n\n\t\t\tfor (i = 0; i < nr_cpus; i++) {\n\t\t\t\tstruct datarec *r = &rec->cpu[i];\n\t\t\t\tstruct datarec *p = &prev->cpu[i];\n\t\t\t\tchar str[64];\n\t\t\t\tdouble drop;\n\n\t\t\t\tdrop = calc_drop_pps(r, p, t);\n\t\t\t\tif (!drop)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tsnprintf(str, sizeof(str), \"cpu:%d\", i);\n\t\t\t\tprint_default(\"       %-16s\" FMT_COLUMNf \"\\n\",\n\t\t\t\t\t      str, ERR(drop));\n\t\t\t}\n\t\t}\n\t}\n\n\tif (out) {\n\t\tout->except_cnt.hits = sum;\n\t\tout->totals.err += sum;\n\t}\n}\n\nstatic void stats_get_devmap_xmit(struct stats_record *stats_rec,\n\t\t\t\t  struct stats_record *stats_prev,\n\t\t\t\t  unsigned int nr_cpus,\n\t\t\t\t  struct sample_output *out)\n{\n\tdouble pps, drop, info, err;\n\tstruct record *rec, *prev;\n\tdouble t;\n\tint i;\n\n\trec = &stats_rec->devmap_xmit;\n\tprev = &stats_prev->devmap_xmit;\n\tt = calc_period(rec, prev);\n\tfor (i = 0; i < nr_cpus; i++) {\n\t\tstruct datarec *r = &rec->cpu[i];\n\t\tstruct datarec *p = &prev->cpu[i];\n\t\tchar str[64];\n\n\t\tpps = calc_pps(r, p, t);\n\t\tdrop = calc_drop_pps(r, p, t);\n\t\terr = calc_errs_pps(r, p, t);\n\n\t\tif (!pps && !drop && !err)\n\t\t\tcontinue;\n\n\t\tsnprintf(str, sizeof(str), \"cpu:%d\", i);\n\t\tinfo = calc_info_pps(r, p, t);\n\t\tif (info > 0)\n\t\t\tinfo = (pps + drop) / info;  \n\t\tprint_default(\"     %-18s\" FMT_COLUMNf FMT_COLUMNf FMT_COLUMNf\n\t\t\t\t      __COLUMN(\".2f\") \"\\n\",\n\t\t\t      str, XMIT(pps), DROP(drop), err, \"drv_err/s\",\n\t\t\t      info, \"bulk-avg\");\n\t}\n\tif (out) {\n\t\tpps = calc_pps(&rec->total, &prev->total, t);\n\t\tdrop = calc_drop_pps(&rec->total, &prev->total, t);\n\t\tinfo = calc_info_pps(&rec->total, &prev->total, t);\n\t\tif (info > 0)\n\t\t\tinfo = (pps + drop) / info;  \n\t\terr = calc_errs_pps(&rec->total, &prev->total, t);\n\n\t\tout->xmit_cnt.pps = pps;\n\t\tout->xmit_cnt.drop = drop;\n\t\tout->xmit_cnt.bavg = info;\n\t\tout->xmit_cnt.err = err;\n\t\tout->totals.xmit += pps;\n\t\tout->totals.drop_xmit += drop;\n\t\tout->totals.err += err;\n\t}\n}\n\nstatic void stats_get_devmap_xmit_multi(struct stats_record *stats_rec,\n\t\t\t\t\tstruct stats_record *stats_prev,\n\t\t\t\t\tunsigned int nr_cpus,\n\t\t\t\t\tstruct sample_output *out,\n\t\t\t\t\tbool xmit_total)\n{\n\tdouble pps, drop, info, err;\n\tstruct map_entry *entry;\n\tstruct record *r, *p;\n\tdouble t;\n\tint bkt;\n\n\thash_for_each(stats_rec->xmit_map, bkt, entry, node) {\n\t\tstruct map_entry *e, *x = NULL;\n\t\tchar ifname_from[IFNAMSIZ];\n\t\tchar ifname_to[IFNAMSIZ];\n\t\tconst char *fstr, *tstr;\n\t\tunsigned long prev_time;\n\t\tstruct record beg = {};\n\t\t__u32 from_idx, to_idx;\n\t\tchar str[128];\n\t\t__u64 pair;\n\t\tint i;\n\n\t\tprev_time = sample_interval * NANOSEC_PER_SEC;\n\n\t\tpair = entry->pair;\n\t\tfrom_idx = pair >> 32;\n\t\tto_idx = pair & 0xFFFFFFFF;\n\n\t\tr = &entry->val;\n\t\tbeg.timestamp = r->timestamp - prev_time;\n\n\t\t \n\t\thash_for_each_possible(stats_prev->xmit_map, e, node, pair) {\n\t\t\tif (e->pair == pair) {\n\t\t\t\tx = e;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (x)\n\t\t\tp = &x->val;\n\t\telse\n\t\t\tp = &beg;\n\t\tt = calc_period(r, p);\n\t\tpps = calc_pps(&r->total, &p->total, t);\n\t\tdrop = calc_drop_pps(&r->total, &p->total, t);\n\t\tinfo = calc_info_pps(&r->total, &p->total, t);\n\t\tif (info > 0)\n\t\t\tinfo = (pps + drop) / info;  \n\t\terr = calc_errs_pps(&r->total, &p->total, t);\n\n\t\tif (out) {\n\t\t\t \n\t\t\tout->totals.xmit += pps;\n\t\t\tout->totals.drop_xmit += drop;\n\t\t\tout->totals.err += err;\n\t\t\tcontinue;\n\t\t}\n\n\t\tfstr = tstr = NULL;\n\t\tif (if_indextoname(from_idx, ifname_from))\n\t\t\tfstr = ifname_from;\n\t\tif (if_indextoname(to_idx, ifname_to))\n\t\t\ttstr = ifname_to;\n\n\t\tsnprintf(str, sizeof(str), \"xmit %s->%s\", fstr ?: \"?\",\n\t\t\t tstr ?: \"?\");\n\t\t \n\t\tif (pps || drop || err) {\n\t\t\tprint_err(drop,\n\t\t\t\t  \"  %-20s \" FMT_COLUMNf FMT_COLUMNf FMT_COLUMNf\n\t\t\t\t  __COLUMN(\".2f\") \"\\n\", str, XMIT(pps), DROP(drop),\n\t\t\t\t  err, \"drv_err/s\", info, \"bulk-avg\");\n\t\t}\n\n\t\tfor (i = 0; i < nr_cpus; i++) {\n\t\t\tstruct datarec *rc = &r->cpu[i];\n\t\t\tstruct datarec *pc, p_beg = {};\n\t\t\tchar str[64];\n\n\t\t\tpc = p == &beg ? &p_beg : &p->cpu[i];\n\n\t\t\tpps = calc_pps(rc, pc, t);\n\t\t\tdrop = calc_drop_pps(rc, pc, t);\n\t\t\terr = calc_errs_pps(rc, pc, t);\n\n\t\t\tif (!pps && !drop && !err)\n\t\t\t\tcontinue;\n\n\t\t\tsnprintf(str, sizeof(str), \"cpu:%d\", i);\n\t\t\tinfo = calc_info_pps(rc, pc, t);\n\t\t\tif (info > 0)\n\t\t\t\tinfo = (pps + drop) / info;  \n\n\t\t\tprint_default(\"     %-18s\" FMT_COLUMNf FMT_COLUMNf FMT_COLUMNf\n\t\t\t\t      __COLUMN(\".2f\") \"\\n\", str, XMIT(pps),\n\t\t\t\t      DROP(drop), err, \"drv_err/s\", info, \"bulk-avg\");\n\t\t}\n\t}\n}\n\nstatic void stats_print(const char *prefix, int mask, struct stats_record *r,\n\t\t\tstruct stats_record *p, struct sample_output *out)\n{\n\tint nr_cpus = libbpf_num_possible_cpus();\n\tconst char *str;\n\n\tprint_always(\"%-23s\", prefix ?: \"Summary\");\n\tif (mask & SAMPLE_RX_CNT)\n\t\tprint_always(FMT_COLUMNl, RX(out->totals.rx));\n\tif (mask & SAMPLE_REDIRECT_CNT)\n\t\tprint_always(FMT_COLUMNl, REDIR(out->totals.redir));\n\tprintf(FMT_COLUMNl,\n\t       out->totals.err + out->totals.drop + out->totals.drop_xmit,\n\t       \"err,drop/s\");\n\tif (mask & SAMPLE_DEVMAP_XMIT_CNT ||\n\t    mask & SAMPLE_DEVMAP_XMIT_CNT_MULTI)\n\t\tprintf(FMT_COLUMNl, XMIT(out->totals.xmit));\n\tprintf(\"\\n\");\n\n\tif (mask & SAMPLE_RX_CNT) {\n\t\tstr = (sample_log_level & LL_DEFAULT) && out->rx_cnt.pps ?\n\t\t\t\t    \"receive total\" :\n\t\t\t\t    \"receive\";\n\t\tprint_err((out->rx_cnt.err || out->rx_cnt.drop),\n\t\t\t  \"  %-20s \" FMT_COLUMNl FMT_COLUMNl FMT_COLUMNl \"\\n\",\n\t\t\t  str, PPS(out->rx_cnt.pps), DROP(out->rx_cnt.drop),\n\t\t\t  ERR(out->rx_cnt.err));\n\n\t\tstats_get_rx_cnt(r, p, nr_cpus, NULL);\n\t}\n\n\tif (mask & SAMPLE_CPUMAP_ENQUEUE_CNT)\n\t\tstats_get_cpumap_enqueue(r, p, nr_cpus);\n\n\tif (mask & SAMPLE_CPUMAP_KTHREAD_CNT) {\n\t\tstats_get_cpumap_kthread(r, p, nr_cpus);\n\t\tstats_get_cpumap_remote(r, p, nr_cpus);\n\t}\n\n\tif (mask & SAMPLE_REDIRECT_CNT) {\n\t\tstr = out->redir_cnt.suc ? \"redirect total\" : \"redirect\";\n\t\tprint_default(\"  %-20s \" FMT_COLUMNl \"\\n\", str,\n\t\t\t      REDIR(out->redir_cnt.suc));\n\n\t\tstats_get_redirect_cnt(r, p, nr_cpus, NULL);\n\t}\n\n\tif (mask & SAMPLE_REDIRECT_ERR_CNT) {\n\t\tstr = (sample_log_level & LL_DEFAULT) && out->redir_cnt.err ?\n\t\t\t\t    \"redirect_err total\" :\n\t\t\t\t    \"redirect_err\";\n\t\tprint_err(out->redir_cnt.err, \"  %-20s \" FMT_COLUMNl \"\\n\", str,\n\t\t\t  ERR(out->redir_cnt.err));\n\n\t\tstats_get_redirect_err_cnt(r, p, nr_cpus, NULL);\n\t}\n\n\tif (mask & SAMPLE_EXCEPTION_CNT) {\n\t\tstr = out->except_cnt.hits ? \"xdp_exception total\" :\n\t\t\t\t\t\t   \"xdp_exception\";\n\n\t\tprint_err(out->except_cnt.hits, \"  %-20s \" FMT_COLUMNl \"\\n\", str,\n\t\t\t  HITS(out->except_cnt.hits));\n\n\t\tstats_get_exception_cnt(r, p, nr_cpus, NULL);\n\t}\n\n\tif (mask & SAMPLE_DEVMAP_XMIT_CNT) {\n\t\tstr = (sample_log_level & LL_DEFAULT) && out->xmit_cnt.pps ?\n\t\t\t\t    \"devmap_xmit total\" :\n\t\t\t\t    \"devmap_xmit\";\n\n\t\tprint_err(out->xmit_cnt.err || out->xmit_cnt.drop,\n\t\t\t  \"  %-20s \" FMT_COLUMNl FMT_COLUMNl FMT_COLUMNl\n\t\t\t\t  __COLUMN(\".2f\") \"\\n\",\n\t\t\t  str, XMIT(out->xmit_cnt.pps),\n\t\t\t  DROP(out->xmit_cnt.drop), out->xmit_cnt.err,\n\t\t\t  \"drv_err/s\", out->xmit_cnt.bavg, \"bulk-avg\");\n\n\t\tstats_get_devmap_xmit(r, p, nr_cpus, NULL);\n\t}\n\n\tif (mask & SAMPLE_DEVMAP_XMIT_CNT_MULTI)\n\t\tstats_get_devmap_xmit_multi(r, p, nr_cpus, NULL,\n\t\t\t\t\t    mask & SAMPLE_DEVMAP_XMIT_CNT);\n\n\tif (sample_log_level & LL_DEFAULT ||\n\t    ((sample_log_level & LL_SIMPLE) && sample_err_exp)) {\n\t\tsample_err_exp = false;\n\t\tprintf(\"\\n\");\n\t}\n}\n\nint sample_setup_maps(struct bpf_map **maps)\n{\n\tsample_n_cpus = libbpf_num_possible_cpus();\n\n\tfor (int i = 0; i < MAP_DEVMAP_XMIT_MULTI; i++) {\n\t\tsample_map[i] = maps[i];\n\n\t\tswitch (i) {\n\t\tcase MAP_RX:\n\t\tcase MAP_CPUMAP_KTHREAD:\n\t\tcase MAP_DEVMAP_XMIT:\n\t\t\tsample_map_count[i] = sample_n_cpus;\n\t\t\tbreak;\n\t\tcase MAP_REDIRECT_ERR:\n\t\t\tsample_map_count[i] =\n\t\t\t\tXDP_REDIRECT_ERR_MAX * sample_n_cpus;\n\t\t\tbreak;\n\t\tcase MAP_EXCEPTION:\n\t\t\tsample_map_count[i] = XDP_ACTION_MAX * sample_n_cpus;\n\t\tcase MAP_CPUMAP_ENQUEUE:\n\t\t\tsample_map_count[i] = sample_n_cpus * sample_n_cpus;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (bpf_map__set_max_entries(sample_map[i], sample_map_count[i]) < 0)\n\t\t\treturn -errno;\n\t}\n\tsample_map[MAP_DEVMAP_XMIT_MULTI] = maps[MAP_DEVMAP_XMIT_MULTI];\n\treturn 0;\n}\n\nstatic int sample_setup_maps_mappings(void)\n{\n\tfor (int i = 0; i < MAP_DEVMAP_XMIT_MULTI; i++) {\n\t\tsize_t size = sample_map_count[i] * sizeof(struct datarec);\n\n\t\tsample_mmap[i] = mmap(NULL, size, PROT_READ | PROT_WRITE,\n\t\t\t\t      MAP_SHARED, bpf_map__fd(sample_map[i]), 0);\n\t\tif (sample_mmap[i] == MAP_FAILED)\n\t\t\treturn -errno;\n\t}\n\treturn 0;\n}\n\nint __sample_init(int mask)\n{\n\tsigset_t st;\n\n\tsigemptyset(&st);\n\tsigaddset(&st, SIGQUIT);\n\tsigaddset(&st, SIGINT);\n\tsigaddset(&st, SIGTERM);\n\n\tif (sigprocmask(SIG_BLOCK, &st, NULL) < 0)\n\t\treturn -errno;\n\n\tsample_sig_fd = signalfd(-1, &st, SFD_CLOEXEC | SFD_NONBLOCK);\n\tif (sample_sig_fd < 0)\n\t\treturn -errno;\n\n\tsample_mask = mask;\n\n\treturn sample_setup_maps_mappings();\n}\n\nstatic int __sample_remove_xdp(int ifindex, __u32 prog_id, int xdp_flags)\n{\n\t__u32 cur_prog_id = 0;\n\tint ret;\n\n\tif (prog_id) {\n\t\tret = bpf_xdp_query_id(ifindex, xdp_flags, &cur_prog_id);\n\t\tif (ret < 0)\n\t\t\treturn -errno;\n\n\t\tif (prog_id != cur_prog_id) {\n\t\t\tprint_always(\n\t\t\t\t\"Program on ifindex %d does not match installed \"\n\t\t\t\t\"program, skipping unload\\n\",\n\t\t\t\tifindex);\n\t\t\treturn -ENOENT;\n\t\t}\n\t}\n\n\treturn bpf_xdp_detach(ifindex, xdp_flags, NULL);\n}\n\nint sample_install_xdp(struct bpf_program *xdp_prog, int ifindex, bool generic,\n\t\t       bool force)\n{\n\tint ret, xdp_flags = 0;\n\t__u32 prog_id = 0;\n\n\tif (sample_xdp_cnt == 32) {\n\t\tfprintf(stderr,\n\t\t\t\"Total limit for installed XDP programs in a sample reached\\n\");\n\t\treturn -ENOTSUP;\n\t}\n\n\txdp_flags |= !force ? XDP_FLAGS_UPDATE_IF_NOEXIST : 0;\n\txdp_flags |= generic ? XDP_FLAGS_SKB_MODE : XDP_FLAGS_DRV_MODE;\n\tret = bpf_xdp_attach(ifindex, bpf_program__fd(xdp_prog), xdp_flags, NULL);\n\tif (ret < 0) {\n\t\tret = -errno;\n\t\tfprintf(stderr,\n\t\t\t\"Failed to install program \\\"%s\\\" on ifindex %d, mode = %s, \"\n\t\t\t\"force = %s: %s\\n\",\n\t\t\tbpf_program__name(xdp_prog), ifindex,\n\t\t\tgeneric ? \"skb\" : \"native\", force ? \"true\" : \"false\",\n\t\t\tstrerror(-ret));\n\t\treturn ret;\n\t}\n\n\tret = bpf_xdp_query_id(ifindex, xdp_flags, &prog_id);\n\tif (ret < 0) {\n\t\tret = -errno;\n\t\tfprintf(stderr,\n\t\t\t\"Failed to get XDP program id for ifindex %d, removing program: %s\\n\",\n\t\t\tifindex, strerror(errno));\n\t\t__sample_remove_xdp(ifindex, 0, xdp_flags);\n\t\treturn ret;\n\t}\n\tsample_xdp_progs[sample_xdp_cnt++] =\n\t\t(struct xdp_desc){ ifindex, prog_id, xdp_flags };\n\n\treturn 0;\n}\n\nstatic void sample_summary_print(void)\n{\n\tdouble num = sample_out.rx_cnt.num;\n\n\tif (sample_out.totals.rx) {\n\t\tdouble pkts = sample_out.totals.rx;\n\n\t\tprint_always(\"  Packets received    : %'-10llu\\n\",\n\t\t\t     sample_out.totals.rx);\n\t\tprint_always(\"  Average packets/s   : %'-10.0f\\n\",\n\t\t\t     sample_round(pkts / num));\n\t}\n\tif (sample_out.totals.redir) {\n\t\tdouble pkts = sample_out.totals.redir;\n\n\t\tprint_always(\"  Packets redirected  : %'-10llu\\n\",\n\t\t\t     sample_out.totals.redir);\n\t\tprint_always(\"  Average redir/s     : %'-10.0f\\n\",\n\t\t\t     sample_round(pkts / num));\n\t}\n\tif (sample_out.totals.drop)\n\t\tprint_always(\"  Rx dropped          : %'-10llu\\n\",\n\t\t\t     sample_out.totals.drop);\n\tif (sample_out.totals.drop_xmit)\n\t\tprint_always(\"  Tx dropped          : %'-10llu\\n\",\n\t\t\t     sample_out.totals.drop_xmit);\n\tif (sample_out.totals.err)\n\t\tprint_always(\"  Errors recorded     : %'-10llu\\n\",\n\t\t\t     sample_out.totals.err);\n\tif (sample_out.totals.xmit) {\n\t\tdouble pkts = sample_out.totals.xmit;\n\n\t\tprint_always(\"  Packets transmitted : %'-10llu\\n\",\n\t\t\t     sample_out.totals.xmit);\n\t\tprint_always(\"  Average transmit/s  : %'-10.0f\\n\",\n\t\t\t     sample_round(pkts / num));\n\t}\n}\n\nvoid sample_exit(int status)\n{\n\tsize_t size;\n\n\tfor (int i = 0; i < NUM_MAP; i++) {\n\t\tsize = sample_map_count[i] * sizeof(**sample_mmap);\n\t\tmunmap(sample_mmap[i], size);\n\t}\n\twhile (sample_xdp_cnt--) {\n\t\tint i = sample_xdp_cnt, ifindex, xdp_flags;\n\t\t__u32 prog_id;\n\n\t\tprog_id = sample_xdp_progs[i].prog_id;\n\t\tifindex = sample_xdp_progs[i].ifindex;\n\t\txdp_flags = sample_xdp_progs[i].flags;\n\n\t\t__sample_remove_xdp(ifindex, prog_id, xdp_flags);\n\t}\n\tsample_summary_print();\n\tclose(sample_sig_fd);\n\texit(status);\n}\n\nstatic int sample_stats_collect(struct stats_record *rec)\n{\n\tint i;\n\n\tif (sample_mask & SAMPLE_RX_CNT)\n\t\tmap_collect_percpu(sample_mmap[MAP_RX], &rec->rx_cnt);\n\n\tif (sample_mask & SAMPLE_REDIRECT_CNT)\n\t\tmap_collect_percpu(sample_mmap[MAP_REDIRECT_ERR], &rec->redir_err[0]);\n\n\tif (sample_mask & SAMPLE_REDIRECT_ERR_CNT) {\n\t\tfor (i = 1; i < XDP_REDIRECT_ERR_MAX; i++)\n\t\t\tmap_collect_percpu(&sample_mmap[MAP_REDIRECT_ERR][i * sample_n_cpus],\n\t\t\t\t\t   &rec->redir_err[i]);\n\t}\n\n\tif (sample_mask & SAMPLE_CPUMAP_ENQUEUE_CNT)\n\t\tfor (i = 0; i < sample_n_cpus; i++)\n\t\t\tmap_collect_percpu(&sample_mmap[MAP_CPUMAP_ENQUEUE][i * sample_n_cpus],\n\t\t\t\t\t   &rec->enq[i]);\n\n\tif (sample_mask & SAMPLE_CPUMAP_KTHREAD_CNT)\n\t\tmap_collect_percpu(sample_mmap[MAP_CPUMAP_KTHREAD],\n\t\t\t\t   &rec->kthread);\n\n\tif (sample_mask & SAMPLE_EXCEPTION_CNT)\n\t\tfor (i = 0; i < XDP_ACTION_MAX; i++)\n\t\t\tmap_collect_percpu(&sample_mmap[MAP_EXCEPTION][i * sample_n_cpus],\n\t\t\t\t\t   &rec->exception[i]);\n\n\tif (sample_mask & SAMPLE_DEVMAP_XMIT_CNT)\n\t\tmap_collect_percpu(sample_mmap[MAP_DEVMAP_XMIT], &rec->devmap_xmit);\n\n\tif (sample_mask & SAMPLE_DEVMAP_XMIT_CNT_MULTI) {\n\t\tif (map_collect_percpu_devmap(bpf_map__fd(sample_map[MAP_DEVMAP_XMIT_MULTI]), rec) < 0)\n\t\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic void sample_summary_update(struct sample_output *out)\n{\n\tsample_out.totals.rx += out->totals.rx;\n\tsample_out.totals.redir += out->totals.redir;\n\tsample_out.totals.drop += out->totals.drop;\n\tsample_out.totals.drop_xmit += out->totals.drop_xmit;\n\tsample_out.totals.err += out->totals.err;\n\tsample_out.totals.xmit += out->totals.xmit;\n\tsample_out.rx_cnt.num++;\n}\n\nstatic void sample_stats_print(int mask, struct stats_record *cur,\n\t\t\t       struct stats_record *prev, char *prog_name)\n{\n\tstruct sample_output out = {};\n\n\tif (mask & SAMPLE_RX_CNT)\n\t\tstats_get_rx_cnt(cur, prev, 0, &out);\n\tif (mask & SAMPLE_REDIRECT_CNT)\n\t\tstats_get_redirect_cnt(cur, prev, 0, &out);\n\tif (mask & SAMPLE_REDIRECT_ERR_CNT)\n\t\tstats_get_redirect_err_cnt(cur, prev, 0, &out);\n\tif (mask & SAMPLE_EXCEPTION_CNT)\n\t\tstats_get_exception_cnt(cur, prev, 0, &out);\n\tif (mask & SAMPLE_DEVMAP_XMIT_CNT)\n\t\tstats_get_devmap_xmit(cur, prev, 0, &out);\n\telse if (mask & SAMPLE_DEVMAP_XMIT_CNT_MULTI)\n\t\tstats_get_devmap_xmit_multi(cur, prev, 0, &out,\n\t\t\t\t\t    mask & SAMPLE_DEVMAP_XMIT_CNT);\n\tsample_summary_update(&out);\n\n\tstats_print(prog_name, mask, cur, prev, &out);\n}\n\nvoid sample_switch_mode(void)\n{\n\tsample_log_level ^= LL_DEBUG - 1;\n}\n\nstatic int sample_signal_cb(void)\n{\n\tstruct signalfd_siginfo si;\n\tint r;\n\n\tr = read(sample_sig_fd, &si, sizeof(si));\n\tif (r < 0)\n\t\treturn -errno;\n\n\tswitch (si.ssi_signo) {\n\tcase SIGQUIT:\n\t\tsample_switch_mode();\n\t\tprintf(\"\\n\");\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"\\n\");\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\n \nstatic void swap(struct stats_record **a, struct stats_record **b)\n{\n\tstruct stats_record *tmp;\n\n\ttmp = *a;\n\t*a = *b;\n\t*b = tmp;\n}\n\nstatic int sample_timer_cb(int timerfd, struct stats_record **rec,\n\t\t\t   struct stats_record **prev)\n{\n\tchar line[64] = \"Summary\";\n\tint ret;\n\t__u64 t;\n\n\tret = read(timerfd, &t, sizeof(t));\n\tif (ret < 0)\n\t\treturn -errno;\n\n\tswap(prev, rec);\n\tret = sample_stats_collect(*rec);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (sample_xdp_cnt == 2 && !(sample_mask & SAMPLE_SKIP_HEADING)) {\n\t\tchar fi[IFNAMSIZ];\n\t\tchar to[IFNAMSIZ];\n\t\tconst char *f, *t;\n\n\t\tf = t = NULL;\n\t\tif (if_indextoname(sample_xdp_progs[0].ifindex, fi))\n\t\t\tf = fi;\n\t\tif (if_indextoname(sample_xdp_progs[1].ifindex, to))\n\t\t\tt = to;\n\n\t\tsnprintf(line, sizeof(line), \"%s->%s\", f ?: \"?\", t ?: \"?\");\n\t}\n\n\tsample_stats_print(sample_mask, *rec, *prev, line);\n\treturn 0;\n}\n\nint sample_run(int interval, void (*post_cb)(void *), void *ctx)\n{\n\tstruct timespec ts = { interval, 0 };\n\tstruct itimerspec its = { ts, ts };\n\tstruct stats_record *rec, *prev;\n\tstruct pollfd pfd[2] = {};\n\tint timerfd, ret;\n\n\tif (!interval) {\n\t\tfprintf(stderr, \"Incorrect interval 0\\n\");\n\t\treturn -EINVAL;\n\t}\n\tsample_interval = interval;\n\t \n\tsetlocale(LC_NUMERIC, \"en_US.UTF-8\");\n\n\ttimerfd = timerfd_create(CLOCK_MONOTONIC, TFD_CLOEXEC | TFD_NONBLOCK);\n\tif (timerfd < 0)\n\t\treturn -errno;\n\ttimerfd_settime(timerfd, 0, &its, NULL);\n\n\tpfd[0].fd = sample_sig_fd;\n\tpfd[0].events = POLLIN;\n\n\tpfd[1].fd = timerfd;\n\tpfd[1].events = POLLIN;\n\n\tret = -ENOMEM;\n\trec = alloc_stats_record();\n\tif (!rec)\n\t\tgoto end;\n\tprev = alloc_stats_record();\n\tif (!prev)\n\t\tgoto end_rec;\n\n\tret = sample_stats_collect(rec);\n\tif (ret < 0)\n\t\tgoto end_rec_prev;\n\n\tfor (;;) {\n\t\tret = poll(pfd, 2, -1);\n\t\tif (ret < 0) {\n\t\t\tif (errno == EINTR)\n\t\t\t\tcontinue;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (pfd[0].revents & POLLIN)\n\t\t\tret = sample_signal_cb();\n\t\telse if (pfd[1].revents & POLLIN)\n\t\t\tret = sample_timer_cb(timerfd, &rec, &prev);\n\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tif (post_cb)\n\t\t\tpost_cb(ctx);\n\t}\n\nend_rec_prev:\n\tfree_stats_record(prev);\nend_rec:\n\tfree_stats_record(rec);\nend:\n\tclose(timerfd);\n\n\treturn ret;\n}\n\nconst char *get_driver_name(int ifindex)\n{\n\tstruct ethtool_drvinfo drv = {};\n\tchar ifname[IF_NAMESIZE];\n\tstatic char drvname[32];\n\tstruct ifreq ifr = {};\n\tint fd, r = 0;\n\n\tfd = socket(AF_INET, SOCK_DGRAM, 0);\n\tif (fd < 0)\n\t\treturn \"[error]\";\n\n\tif (!if_indextoname(ifindex, ifname))\n\t\tgoto end;\n\n\tdrv.cmd = ETHTOOL_GDRVINFO;\n\tsafe_strncpy(ifr.ifr_name, ifname, sizeof(ifr.ifr_name));\n\tifr.ifr_data = (void *)&drv;\n\n\tr = ioctl(fd, SIOCETHTOOL, &ifr);\n\tif (r)\n\t\tgoto end;\n\n\tsafe_strncpy(drvname, drv.driver, sizeof(drvname));\n\n\tclose(fd);\n\treturn drvname;\n\nend:\n\tr = errno;\n\tclose(fd);\n\treturn r == EOPNOTSUPP ? \"loopback\" : \"[error]\";\n}\n\nint get_mac_addr(int ifindex, void *mac_addr)\n{\n\tchar ifname[IF_NAMESIZE];\n\tstruct ifreq ifr = {};\n\tint fd, r;\n\n\tfd = socket(AF_INET, SOCK_DGRAM, 0);\n\tif (fd < 0)\n\t\treturn -errno;\n\n\tif (!if_indextoname(ifindex, ifname)) {\n\t\tr = -errno;\n\t\tgoto end;\n\t}\n\n\tsafe_strncpy(ifr.ifr_name, ifname, sizeof(ifr.ifr_name));\n\n\tr = ioctl(fd, SIOCGIFHWADDR, &ifr);\n\tif (r) {\n\t\tr = -errno;\n\t\tgoto end;\n\t}\n\n\tmemcpy(mac_addr, ifr.ifr_hwaddr.sa_data, 6 * sizeof(char));\n\nend:\n\tclose(fd);\n\treturn r;\n}\n\n__attribute__((constructor)) static void sample_ctor(void)\n{\n\tif (libbpf_set_strict_mode(LIBBPF_STRICT_ALL) < 0) {\n\t\tfprintf(stderr, \"Failed to set libbpf strict mode: %s\\n\",\n\t\t\tstrerror(errno));\n\t\t \n\t\texit(EXIT_FAIL_BPF);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}