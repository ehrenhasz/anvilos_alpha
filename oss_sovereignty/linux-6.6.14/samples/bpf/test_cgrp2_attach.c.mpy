{
  "module_name": "test_cgrp2_attach.c",
  "hash_id": "9dd27407c308a858cd15f5a2963b710839d92ff82a88f8dadf6b25e8c6609874",
  "original_prompt": "Ingested from linux-6.6.14/samples/bpf/test_cgrp2_attach.c",
  "human_readable_source": " \n\n#define _GNU_SOURCE\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <string.h>\n#include <unistd.h>\n#include <assert.h>\n#include <errno.h>\n#include <fcntl.h>\n\n#include <linux/bpf.h>\n#include <bpf/bpf.h>\n\n#include \"bpf_insn.h\"\n#include \"bpf_util.h\"\n\nenum {\n\tMAP_KEY_PACKETS,\n\tMAP_KEY_BYTES,\n};\n\nchar bpf_log_buf[BPF_LOG_BUF_SIZE];\n\nstatic int prog_load(int map_fd, int verdict)\n{\n\tstruct bpf_insn prog[] = {\n\t\tBPF_MOV64_REG(BPF_REG_6, BPF_REG_1),  \n\n\t\t \n\t\tBPF_MOV64_IMM(BPF_REG_0, MAP_KEY_PACKETS),  \n\t\tBPF_STX_MEM(BPF_W, BPF_REG_10, BPF_REG_0, -4),  \n\t\tBPF_MOV64_REG(BPF_REG_2, BPF_REG_10),\n\t\tBPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -4),  \n\t\tBPF_LD_MAP_FD(BPF_REG_1, map_fd),  \n\t\tBPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_map_lookup_elem),\n\t\tBPF_JMP_IMM(BPF_JEQ, BPF_REG_0, 0, 2),\n\t\tBPF_MOV64_IMM(BPF_REG_1, 1),  \n\t\tBPF_ATOMIC_OP(BPF_DW, BPF_ADD, BPF_REG_0, BPF_REG_1, 0),\n\n\t\t \n\t\tBPF_MOV64_IMM(BPF_REG_0, MAP_KEY_BYTES),  \n\t\tBPF_STX_MEM(BPF_W, BPF_REG_10, BPF_REG_0, -4),  \n\t\tBPF_MOV64_REG(BPF_REG_2, BPF_REG_10),\n\t\tBPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -4),  \n\t\tBPF_LD_MAP_FD(BPF_REG_1, map_fd),\n\t\tBPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_map_lookup_elem),\n\t\tBPF_JMP_IMM(BPF_JEQ, BPF_REG_0, 0, 2),\n\t\tBPF_LDX_MEM(BPF_W, BPF_REG_1, BPF_REG_6, offsetof(struct __sk_buff, len)),  \n\n\t\tBPF_ATOMIC_OP(BPF_DW, BPF_ADD, BPF_REG_0, BPF_REG_1, 0),\n\n\t\tBPF_MOV64_IMM(BPF_REG_0, verdict),  \n\t\tBPF_EXIT_INSN(),\n\t};\n\tsize_t insns_cnt = ARRAY_SIZE(prog);\n\tLIBBPF_OPTS(bpf_prog_load_opts, opts,\n\t\t.log_buf = bpf_log_buf,\n\t\t.log_size = BPF_LOG_BUF_SIZE,\n\t);\n\n\treturn bpf_prog_load(BPF_PROG_TYPE_CGROUP_SKB, NULL, \"GPL\",\n\t\t\t     prog, insns_cnt, &opts);\n}\n\nstatic int usage(const char *argv0)\n{\n\tprintf(\"Usage: %s [-d] [-D] <cg-path> <egress|ingress>\\n\", argv0);\n\tprintf(\"\t-d\tDrop Traffic\\n\");\n\tprintf(\"\t-D\tDetach filter, and exit\\n\");\n\treturn EXIT_FAILURE;\n}\n\nstatic int attach_filter(int cg_fd, int type, int verdict)\n{\n\tint prog_fd, map_fd, ret, key;\n\tlong long pkt_cnt, byte_cnt;\n\n\tmap_fd = bpf_map_create(BPF_MAP_TYPE_ARRAY, NULL,\n\t\t\t\tsizeof(key), sizeof(byte_cnt),\n\t\t\t\t256, NULL);\n\tif (map_fd < 0) {\n\t\tprintf(\"Failed to create map: '%s'\\n\", strerror(errno));\n\t\treturn EXIT_FAILURE;\n\t}\n\n\tprog_fd = prog_load(map_fd, verdict);\n\tprintf(\"Output from kernel verifier:\\n%s\\n-------\\n\", bpf_log_buf);\n\n\tif (prog_fd < 0) {\n\t\tprintf(\"Failed to load prog: '%s'\\n\", strerror(errno));\n\t\treturn EXIT_FAILURE;\n\t}\n\n\tret = bpf_prog_attach(prog_fd, cg_fd, type, 0);\n\tif (ret < 0) {\n\t\tprintf(\"Failed to attach prog to cgroup: '%s'\\n\",\n\t\t       strerror(errno));\n\t\treturn EXIT_FAILURE;\n\t}\n\twhile (1) {\n\t\tkey = MAP_KEY_PACKETS;\n\t\tassert(bpf_map_lookup_elem(map_fd, &key, &pkt_cnt) == 0);\n\n\t\tkey = MAP_KEY_BYTES;\n\t\tassert(bpf_map_lookup_elem(map_fd, &key, &byte_cnt) == 0);\n\n\t\tprintf(\"cgroup received %lld packets, %lld bytes\\n\",\n\t\t       pkt_cnt, byte_cnt);\n\t\tsleep(1);\n\t}\n\n\treturn EXIT_SUCCESS;\n}\n\nint main(int argc, char **argv)\n{\n\tint detach_only = 0, verdict = 1;\n\tenum bpf_attach_type type;\n\tint opt, cg_fd, ret;\n\n\twhile ((opt = getopt(argc, argv, \"Dd\")) != -1) {\n\t\tswitch (opt) {\n\t\tcase 'd':\n\t\t\tverdict = 0;\n\t\t\tbreak;\n\t\tcase 'D':\n\t\t\tdetach_only = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn usage(argv[0]);\n\t\t}\n\t}\n\n\tif (argc - optind < 2)\n\t\treturn usage(argv[0]);\n\n\tif (strcmp(argv[optind + 1], \"ingress\") == 0)\n\t\ttype = BPF_CGROUP_INET_INGRESS;\n\telse if (strcmp(argv[optind + 1], \"egress\") == 0)\n\t\ttype = BPF_CGROUP_INET_EGRESS;\n\telse\n\t\treturn usage(argv[0]);\n\n\tcg_fd = open(argv[optind], O_DIRECTORY | O_RDONLY);\n\tif (cg_fd < 0) {\n\t\tprintf(\"Failed to open cgroup path: '%s'\\n\", strerror(errno));\n\t\treturn EXIT_FAILURE;\n\t}\n\n\tif (detach_only) {\n\t\tret = bpf_prog_detach(cg_fd, type);\n\t\tprintf(\"bpf_prog_detach() returned '%s' (%d)\\n\",\n\t\t       strerror(errno), errno);\n\t} else\n\t\tret = attach_filter(cg_fd, type, verdict);\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}