{
  "module_name": "hbm_out_kern.c",
  "hash_id": "f779bf0c12fc0687b031af5358ac8e4d71c9a1027f55c7a4084b045de4d1bfe3",
  "original_prompt": "Ingested from linux-6.6.14/samples/bpf/hbm_out_kern.c",
  "human_readable_source": "\n \n\n#include \"hbm_kern.h\"\n\nSEC(\"cgroup_skb/egress\")\nint _hbm_out_cg(struct __sk_buff *skb)\n{\n\tstruct hbm_pkt_info pkti;\n\tint len = skb->len;\n\tunsigned int queue_index = 0;\n\tunsigned long long curtime;\n\tint credit;\n\tsigned long long delta = 0, new_credit;\n\tint max_credit = MAX_CREDIT;\n\tbool congestion_flag = false;\n\tbool drop_flag = false;\n\tbool cwr_flag = false;\n\tbool ecn_ce_flag = false;\n\tstruct hbm_vqueue *qdp;\n\tstruct hbm_queue_stats *qsp = NULL;\n\tint rv = ALLOW_PKT;\n\n\tqsp = bpf_map_lookup_elem(&queue_stats, &queue_index);\n\tif (qsp != NULL && !qsp->loopback && (skb->ifindex == 1))\n\t\treturn ALLOW_PKT;\n\n\thbm_get_pkt_info(skb, &pkti);\n\n\t\n\t\n\t\n\n\tqdp = bpf_get_local_storage(&queue_state, 0);\n\tif (!qdp)\n\t\treturn ALLOW_PKT;\n\telse if (qdp->lasttime == 0)\n\t\thbm_init_vqueue(qdp, 1024);\n\n\tcurtime = bpf_ktime_get_ns();\n\n\t\n\tbpf_spin_lock(&qdp->lock);\n\tcredit = qdp->credit;\n\tdelta = curtime - qdp->lasttime;\n\t \n\tif (delta > 0) {\n\t\tqdp->lasttime = curtime;\n\t\tnew_credit = credit + CREDIT_PER_NS(delta, qdp->rate);\n\t\tif (new_credit > MAX_CREDIT)\n\t\t\tcredit = MAX_CREDIT;\n\t\telse\n\t\t\tcredit = new_credit;\n\t}\n\tcredit -= len;\n\tqdp->credit = credit;\n\tbpf_spin_unlock(&qdp->lock);\n\t\n\n\t\n\tif (qsp != NULL && (qsp->rate * 128) != qdp->rate) {\n\t\tqdp->rate = qsp->rate * 128;\n\t\tbpf_printk(\"Updating rate: %d (1sec:%llu bits)\\n\",\n\t\t\t   (int)qdp->rate,\n\t\t\t   CREDIT_PER_NS(1000000000, qdp->rate) * 8);\n\t}\n\n\t\n\t\n\tif (credit < -DROP_THRESH ||\n\t    (len > LARGE_PKT_THRESH && credit < -LARGE_PKT_DROP_THRESH)) {\n\t\t\n\t\tdrop_flag = true;\n\t\tif (pkti.ecn)\n\t\t\tcongestion_flag = true;\n\t\telse if (pkti.is_tcp)\n\t\t\tcwr_flag = true;\n\t} else if (credit < 0) {\n\t\t\n\t\tif (pkti.ecn || pkti.is_tcp) {\n\t\t\tif (credit < -MARK_THRESH)\n\t\t\t\tcongestion_flag = true;\n\t\t\telse\n\t\t\t\tcongestion_flag = false;\n\t\t} else {\n\t\t\tcongestion_flag = true;\n\t\t}\n\t}\n\n\tif (congestion_flag) {\n\t\tif (bpf_skb_ecn_set_ce(skb)) {\n\t\t\tecn_ce_flag = true;\n\t\t} else {\n\t\t\tif (pkti.is_tcp) {\n\t\t\t\tunsigned int rand = bpf_get_prandom_u32();\n\n\t\t\t\tif (-credit >= MARK_THRESH +\n\t\t\t\t    (rand % MARK_REGION_SIZE)) {\n\t\t\t\t\t\n\t\t\t\t\tcwr_flag = true;\n\t\t\t\t}\n\t\t\t} else if (len > LARGE_PKT_THRESH) {\n\t\t\t\t\n\t\t\t\tdrop_flag = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (qsp != NULL)\n\t\tif (qsp->no_cn)\n\t\t\tcwr_flag = false;\n\n\thbm_update_stats(qsp, len, curtime, congestion_flag, drop_flag,\n\t\t\t cwr_flag, ecn_ce_flag, &pkti, credit);\n\n\tif (drop_flag) {\n\t\t__sync_add_and_fetch(&(qdp->credit), len);\n\t\trv = DROP_PKT;\n\t}\n\n\tif (cwr_flag)\n\t\trv |= 2;\n\treturn rv;\n}\nchar _license[] SEC(\"license\") = \"GPL\";\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}