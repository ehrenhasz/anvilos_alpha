{
  "module_name": "watch_test.c",
  "hash_id": "ae82396fb22ab242a4a317e152abcc329010c0b70c1c1436903816d9c96a0d2a",
  "original_prompt": "Ingested from linux-6.6.14/samples/watch_queue/watch_test.c",
  "human_readable_source": "\n \n\n#define _GNU_SOURCE\n#include <stdbool.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <signal.h>\n#include <unistd.h>\n#include <errno.h>\n#include <sys/ioctl.h>\n#include <limits.h>\n#include <linux/watch_queue.h>\n#include <linux/unistd.h>\n#include <linux/keyctl.h>\n\n#ifndef KEYCTL_WATCH_KEY\n#define KEYCTL_WATCH_KEY -1\n#endif\n#ifndef __NR_keyctl\n#define __NR_keyctl -1\n#endif\n\n#define BUF_SIZE 256\n\nstatic long keyctl_watch_key(int key, int watch_fd, int watch_id)\n{\n\treturn syscall(__NR_keyctl, KEYCTL_WATCH_KEY, key, watch_fd, watch_id);\n}\n\nstatic const char *key_subtypes[256] = {\n\t[NOTIFY_KEY_INSTANTIATED]\t= \"instantiated\",\n\t[NOTIFY_KEY_UPDATED]\t\t= \"updated\",\n\t[NOTIFY_KEY_LINKED]\t\t= \"linked\",\n\t[NOTIFY_KEY_UNLINKED]\t\t= \"unlinked\",\n\t[NOTIFY_KEY_CLEARED]\t\t= \"cleared\",\n\t[NOTIFY_KEY_REVOKED]\t\t= \"revoked\",\n\t[NOTIFY_KEY_INVALIDATED]\t= \"invalidated\",\n\t[NOTIFY_KEY_SETATTR]\t\t= \"setattr\",\n};\n\nstatic void saw_key_change(struct watch_notification *n, size_t len)\n{\n\tstruct key_notification *k = (struct key_notification *)n;\n\n\tif (len != sizeof(struct key_notification)) {\n\t\tfprintf(stderr, \"Incorrect key message length\\n\");\n\t\treturn;\n\t}\n\n\tprintf(\"KEY %08x change=%u[%s] aux=%u\\n\",\n\t       k->key_id, n->subtype, key_subtypes[n->subtype], k->aux);\n}\n\n \nstatic void consumer(int fd)\n{\n\tunsigned char buffer[433], *p, *end;\n\tunion {\n\t\tstruct watch_notification n;\n\t\tunsigned char buf1[128];\n\t} n;\n\tssize_t buf_len;\n\n\tfor (;;) {\n\t\tbuf_len = read(fd, buffer, sizeof(buffer));\n\t\tif (buf_len == -1) {\n\t\t\tperror(\"read\");\n\t\t\texit(1);\n\t\t}\n\n\t\tif (buf_len == 0) {\n\t\t\tprintf(\"-- END --\\n\");\n\t\t\treturn;\n\t\t}\n\n\t\tif (buf_len > sizeof(buffer)) {\n\t\t\tfprintf(stderr, \"Read buffer overrun: %zd\\n\", buf_len);\n\t\t\treturn;\n\t\t}\n\n\t\tprintf(\"read() = %zd\\n\", buf_len);\n\n\t\tp = buffer;\n\t\tend = buffer + buf_len;\n\t\twhile (p < end) {\n\t\t\tsize_t largest, len;\n\n\t\t\tlargest = end - p;\n\t\t\tif (largest > 128)\n\t\t\t\tlargest = 128;\n\t\t\tif (largest < sizeof(struct watch_notification)) {\n\t\t\t\tfprintf(stderr, \"Short message header: %zu\\n\", largest);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tmemcpy(&n, p, largest);\n\n\t\t\tprintf(\"NOTIFY[%03zx]: ty=%06x sy=%02x i=%08x\\n\",\n\t\t\t       p - buffer, n.n.type, n.n.subtype, n.n.info);\n\n\t\t\tlen = n.n.info & WATCH_INFO_LENGTH;\n\t\t\tif (len < sizeof(n.n) || len > largest) {\n\t\t\t\tfprintf(stderr, \"Bad message length: %zu/%zu\\n\", len, largest);\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\tswitch (n.n.type) {\n\t\t\tcase WATCH_TYPE_META:\n\t\t\t\tswitch (n.n.subtype) {\n\t\t\t\tcase WATCH_META_REMOVAL_NOTIFICATION:\n\t\t\t\t\tprintf(\"REMOVAL of watchpoint %08x\\n\",\n\t\t\t\t\t       (n.n.info & WATCH_INFO_ID) >>\n\t\t\t\t\t       WATCH_INFO_ID__SHIFT);\n\t\t\t\t\tbreak;\n\t\t\t\tcase WATCH_META_LOSS_NOTIFICATION:\n\t\t\t\t\tprintf(\"-- LOSS --\\n\");\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tprintf(\"other meta record\\n\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase WATCH_TYPE_KEY_NOTIFY:\n\t\t\t\tsaw_key_change(&n.n, len);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tprintf(\"other type\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tp += len;\n\t\t}\n\t}\n}\n\nstatic struct watch_notification_filter filter = {\n\t.nr_filters\t= 1,\n\t.filters = {\n\t\t[0]\t= {\n\t\t\t.type\t\t\t= WATCH_TYPE_KEY_NOTIFY,\n\t\t\t.subtype_filter[0]\t= UINT_MAX,\n\t\t},\n\t},\n};\n\nint main(int argc, char **argv)\n{\n\tint pipefd[2], fd;\n\n\tif (pipe2(pipefd, O_NOTIFICATION_PIPE) == -1) {\n\t\tperror(\"pipe2\");\n\t\texit(1);\n\t}\n\tfd = pipefd[0];\n\n\tif (ioctl(fd, IOC_WATCH_QUEUE_SET_SIZE, BUF_SIZE) == -1) {\n\t\tperror(\"watch_queue(size)\");\n\t\texit(1);\n\t}\n\n\tif (ioctl(fd, IOC_WATCH_QUEUE_SET_FILTER, &filter) == -1) {\n\t\tperror(\"watch_queue(filter)\");\n\t\texit(1);\n\t}\n\n\tif (keyctl_watch_key(KEY_SPEC_SESSION_KEYRING, fd, 0x01) == -1) {\n\t\tperror(\"keyctl\");\n\t\texit(1);\n\t}\n\n\tif (keyctl_watch_key(KEY_SPEC_USER_KEYRING, fd, 0x02) == -1) {\n\t\tperror(\"keyctl\");\n\t\texit(1);\n\t}\n\n\tconsumer(fd);\n\texit(0);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}