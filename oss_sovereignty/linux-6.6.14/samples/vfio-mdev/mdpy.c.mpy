{
  "module_name": "mdpy.c",
  "hash_id": "170bd040545543c5313eadd24c342d4e2531e177c796b25c3eec74add60dbd08",
  "original_prompt": "Ingested from linux-6.6.14/samples/vfio-mdev/mdpy.c",
  "human_readable_source": "\n \n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/cdev.h>\n#include <linux/vfio.h>\n#include <linux/iommu.h>\n#include <linux/sysfs.h>\n#include <linux/mdev.h>\n#include <linux/pci.h>\n#include <drm/drm_fourcc.h>\n#include \"mdpy-defs.h\"\n\n#define MDPY_NAME\t\t\"mdpy\"\n#define MDPY_CLASS_NAME\t\t\"mdpy\"\n\n#define MDPY_CONFIG_SPACE_SIZE\t0xff\n#define MDPY_MEMORY_BAR_OFFSET\tPAGE_SIZE\n#define MDPY_DISPLAY_REGION\t16\n\n#define STORE_LE16(addr, val)\t(*(u16 *)addr = val)\n#define STORE_LE32(addr, val)\t(*(u32 *)addr = val)\n\n\nMODULE_LICENSE(\"GPL v2\");\n\n#define MDPY_TYPE_1 \"vga\"\n#define MDPY_TYPE_2 \"xga\"\n#define MDPY_TYPE_3 \"hd\"\n\nstatic struct mdpy_type {\n\tstruct mdev_type type;\n\tu32 format;\n\tu32 bytepp;\n\tu32 width;\n\tu32 height;\n} mdpy_types[] = {\n\t{\n\t\t.type.sysfs_name \t= MDPY_TYPE_1,\n\t\t.type.pretty_name\t= MDPY_CLASS_NAME \"-\" MDPY_TYPE_1,\n\t\t.format = DRM_FORMAT_XRGB8888,\n\t\t.bytepp = 4,\n\t\t.width\t= 640,\n\t\t.height = 480,\n\t}, {\n\t\t.type.sysfs_name \t= MDPY_TYPE_2,\n\t\t.type.pretty_name\t= MDPY_CLASS_NAME \"-\" MDPY_TYPE_2,\n\t\t.format = DRM_FORMAT_XRGB8888,\n\t\t.bytepp = 4,\n\t\t.width\t= 1024,\n\t\t.height = 768,\n\t}, {\n\t\t.type.sysfs_name \t= MDPY_TYPE_3,\n\t\t.type.pretty_name\t= MDPY_CLASS_NAME \"-\" MDPY_TYPE_3,\n\t\t.format = DRM_FORMAT_XRGB8888,\n\t\t.bytepp = 4,\n\t\t.width\t= 1920,\n\t\t.height = 1080,\n\t},\n};\n\nstatic struct mdev_type *mdpy_mdev_types[] = {\n\t&mdpy_types[0].type,\n\t&mdpy_types[1].type,\n\t&mdpy_types[2].type,\n};\n\nstatic dev_t\t\tmdpy_devt;\nstatic struct class\t*mdpy_class;\nstatic struct cdev\tmdpy_cdev;\nstatic struct device\tmdpy_dev;\nstatic struct mdev_parent mdpy_parent;\nstatic const struct vfio_device_ops mdpy_dev_ops;\n\n \nstruct mdev_state {\n\tstruct vfio_device vdev;\n\tu8 *vconfig;\n\tu32 bar_mask;\n\tstruct mutex ops_lock;\n\tstruct mdev_device *mdev;\n\tstruct vfio_device_info dev_info;\n\n\tconst struct mdpy_type *type;\n\tu32 memsize;\n\tvoid *memblk;\n};\n\nstatic void mdpy_create_config_space(struct mdev_state *mdev_state)\n{\n\tSTORE_LE16((u16 *) &mdev_state->vconfig[PCI_VENDOR_ID],\n\t\t   MDPY_PCI_VENDOR_ID);\n\tSTORE_LE16((u16 *) &mdev_state->vconfig[PCI_DEVICE_ID],\n\t\t   MDPY_PCI_DEVICE_ID);\n\tSTORE_LE16((u16 *) &mdev_state->vconfig[PCI_SUBSYSTEM_VENDOR_ID],\n\t\t   MDPY_PCI_SUBVENDOR_ID);\n\tSTORE_LE16((u16 *) &mdev_state->vconfig[PCI_SUBSYSTEM_ID],\n\t\t   MDPY_PCI_SUBDEVICE_ID);\n\n\tSTORE_LE16((u16 *) &mdev_state->vconfig[PCI_COMMAND],\n\t\t   PCI_COMMAND_IO | PCI_COMMAND_MEMORY);\n\tSTORE_LE16((u16 *) &mdev_state->vconfig[PCI_STATUS],\n\t\t   PCI_STATUS_CAP_LIST);\n\tSTORE_LE16((u16 *) &mdev_state->vconfig[PCI_CLASS_DEVICE],\n\t\t   PCI_CLASS_DISPLAY_OTHER);\n\tmdev_state->vconfig[PCI_CLASS_REVISION] =  0x01;\n\n\tSTORE_LE32((u32 *) &mdev_state->vconfig[PCI_BASE_ADDRESS_0],\n\t\t   PCI_BASE_ADDRESS_SPACE_MEMORY |\n\t\t   PCI_BASE_ADDRESS_MEM_TYPE_32\t |\n\t\t   PCI_BASE_ADDRESS_MEM_PREFETCH);\n\tmdev_state->bar_mask = ~(mdev_state->memsize) + 1;\n\n\t \n\tmdev_state->vconfig[PCI_CAPABILITY_LIST]       = MDPY_VENDORCAP_OFFSET;\n\tmdev_state->vconfig[MDPY_VENDORCAP_OFFSET + 0] = 0x09;  \n\tmdev_state->vconfig[MDPY_VENDORCAP_OFFSET + 1] = 0x00;  \n\tmdev_state->vconfig[MDPY_VENDORCAP_OFFSET + 2] = MDPY_VENDORCAP_SIZE;\n\tSTORE_LE32((u32 *) &mdev_state->vconfig[MDPY_FORMAT_OFFSET],\n\t\t   mdev_state->type->format);\n\tSTORE_LE32((u32 *) &mdev_state->vconfig[MDPY_WIDTH_OFFSET],\n\t\t   mdev_state->type->width);\n\tSTORE_LE32((u32 *) &mdev_state->vconfig[MDPY_HEIGHT_OFFSET],\n\t\t   mdev_state->type->height);\n}\n\nstatic void handle_pci_cfg_write(struct mdev_state *mdev_state, u16 offset,\n\t\t\t\t char *buf, u32 count)\n{\n\tstruct device *dev = mdev_dev(mdev_state->mdev);\n\tu32 cfg_addr;\n\n\tswitch (offset) {\n\tcase PCI_BASE_ADDRESS_0:\n\t\tcfg_addr = *(u32 *)buf;\n\n\t\tif (cfg_addr == 0xffffffff) {\n\t\t\tcfg_addr = (cfg_addr & mdev_state->bar_mask);\n\t\t} else {\n\t\t\tcfg_addr &= PCI_BASE_ADDRESS_MEM_MASK;\n\t\t\tif (cfg_addr)\n\t\t\t\tdev_info(dev, \"BAR0 @ 0x%x\\n\", cfg_addr);\n\t\t}\n\n\t\tcfg_addr |= (mdev_state->vconfig[offset] &\n\t\t\t     ~PCI_BASE_ADDRESS_MEM_MASK);\n\t\tSTORE_LE32(&mdev_state->vconfig[offset], cfg_addr);\n\t\tbreak;\n\t}\n}\n\nstatic ssize_t mdev_access(struct mdev_state *mdev_state, char *buf,\n\t\t\t   size_t count, loff_t pos, bool is_write)\n{\n\tint ret = 0;\n\n\tmutex_lock(&mdev_state->ops_lock);\n\n\tif (pos < MDPY_CONFIG_SPACE_SIZE) {\n\t\tif (is_write)\n\t\t\thandle_pci_cfg_write(mdev_state, pos, buf, count);\n\t\telse\n\t\t\tmemcpy(buf, (mdev_state->vconfig + pos), count);\n\n\t} else if ((pos >= MDPY_MEMORY_BAR_OFFSET) &&\n\t\t   (pos + count <=\n\t\t    MDPY_MEMORY_BAR_OFFSET + mdev_state->memsize)) {\n\t\tpos -= MDPY_MEMORY_BAR_OFFSET;\n\t\tif (is_write)\n\t\t\tmemcpy(mdev_state->memblk, buf, count);\n\t\telse\n\t\t\tmemcpy(buf, mdev_state->memblk, count);\n\n\t} else {\n\t\tdev_info(mdev_state->vdev.dev,\n\t\t\t \"%s: %s @0x%llx (unhandled)\\n\", __func__,\n\t\t\t is_write ? \"WR\" : \"RD\", pos);\n\t\tret = -1;\n\t\tgoto accessfailed;\n\t}\n\n\tret = count;\n\n\naccessfailed:\n\tmutex_unlock(&mdev_state->ops_lock);\n\n\treturn ret;\n}\n\nstatic int mdpy_reset(struct mdev_state *mdev_state)\n{\n\tu32 stride, i;\n\n\t \n\tstride = mdev_state->type->width * mdev_state->type->bytepp;\n\tfor (i = 0; i < mdev_state->type->height; i++)\n\t\tmemset(mdev_state->memblk + i * stride,\n\t\t       i * 255 / mdev_state->type->height,\n\t\t       stride);\n\treturn 0;\n}\n\nstatic int mdpy_init_dev(struct vfio_device *vdev)\n{\n\tstruct mdev_state *mdev_state =\n\t\tcontainer_of(vdev, struct mdev_state, vdev);\n\tstruct mdev_device *mdev = to_mdev_device(vdev->dev);\n\tconst struct mdpy_type *type =\n\t\tcontainer_of(mdev->type, struct mdpy_type, type);\n\tu32 fbsize;\n\tint ret = -ENOMEM;\n\n\tmdev_state->vconfig = kzalloc(MDPY_CONFIG_SPACE_SIZE, GFP_KERNEL);\n\tif (!mdev_state->vconfig)\n\t\treturn ret;\n\n\tfbsize = roundup_pow_of_two(type->width * type->height * type->bytepp);\n\n\tmdev_state->memblk = vmalloc_user(fbsize);\n\tif (!mdev_state->memblk)\n\t\tgoto out_vconfig;\n\n\tmutex_init(&mdev_state->ops_lock);\n\tmdev_state->mdev = mdev;\n\tmdev_state->type = type;\n\tmdev_state->memsize = fbsize;\n\tmdpy_create_config_space(mdev_state);\n\tmdpy_reset(mdev_state);\n\n\tdev_info(vdev->dev, \"%s: %s (%dx%d)\\n\", __func__, type->type.pretty_name,\n\t\t type->width, type->height);\n\treturn 0;\n\nout_vconfig:\n\tkfree(mdev_state->vconfig);\n\treturn ret;\n}\n\nstatic int mdpy_probe(struct mdev_device *mdev)\n{\n\tstruct mdev_state *mdev_state;\n\tint ret;\n\n\tmdev_state = vfio_alloc_device(mdev_state, vdev, &mdev->dev,\n\t\t\t\t       &mdpy_dev_ops);\n\tif (IS_ERR(mdev_state))\n\t\treturn PTR_ERR(mdev_state);\n\n\tret = vfio_register_emulated_iommu_dev(&mdev_state->vdev);\n\tif (ret)\n\t\tgoto err_put_vdev;\n\tdev_set_drvdata(&mdev->dev, mdev_state);\n\treturn 0;\n\nerr_put_vdev:\n\tvfio_put_device(&mdev_state->vdev);\n\treturn ret;\n}\n\nstatic void mdpy_release_dev(struct vfio_device *vdev)\n{\n\tstruct mdev_state *mdev_state =\n\t\tcontainer_of(vdev, struct mdev_state, vdev);\n\n\tvfree(mdev_state->memblk);\n\tkfree(mdev_state->vconfig);\n}\n\nstatic void mdpy_remove(struct mdev_device *mdev)\n{\n\tstruct mdev_state *mdev_state = dev_get_drvdata(&mdev->dev);\n\n\tdev_info(&mdev->dev, \"%s\\n\", __func__);\n\n\tvfio_unregister_group_dev(&mdev_state->vdev);\n\tvfio_put_device(&mdev_state->vdev);\n}\n\nstatic ssize_t mdpy_read(struct vfio_device *vdev, char __user *buf,\n\t\t\t size_t count, loff_t *ppos)\n{\n\tstruct mdev_state *mdev_state =\n\t\tcontainer_of(vdev, struct mdev_state, vdev);\n\tunsigned int done = 0;\n\tint ret;\n\n\twhile (count) {\n\t\tsize_t filled;\n\n\t\tif (count >= 4 && !(*ppos % 4)) {\n\t\t\tu32 val;\n\n\t\t\tret = mdev_access(mdev_state, (char *)&val, sizeof(val),\n\t\t\t\t\t  *ppos, false);\n\t\t\tif (ret <= 0)\n\t\t\t\tgoto read_err;\n\n\t\t\tif (copy_to_user(buf, &val, sizeof(val)))\n\t\t\t\tgoto read_err;\n\n\t\t\tfilled = 4;\n\t\t} else if (count >= 2 && !(*ppos % 2)) {\n\t\t\tu16 val;\n\n\t\t\tret = mdev_access(mdev_state, (char *)&val, sizeof(val),\n\t\t\t\t\t  *ppos, false);\n\t\t\tif (ret <= 0)\n\t\t\t\tgoto read_err;\n\n\t\t\tif (copy_to_user(buf, &val, sizeof(val)))\n\t\t\t\tgoto read_err;\n\n\t\t\tfilled = 2;\n\t\t} else {\n\t\t\tu8 val;\n\n\t\t\tret = mdev_access(mdev_state, (char *)&val, sizeof(val),\n\t\t\t\t\t  *ppos, false);\n\t\t\tif (ret <= 0)\n\t\t\t\tgoto read_err;\n\n\t\t\tif (copy_to_user(buf, &val, sizeof(val)))\n\t\t\t\tgoto read_err;\n\n\t\t\tfilled = 1;\n\t\t}\n\n\t\tcount -= filled;\n\t\tdone += filled;\n\t\t*ppos += filled;\n\t\tbuf += filled;\n\t}\n\n\treturn done;\n\nread_err:\n\treturn -EFAULT;\n}\n\nstatic ssize_t mdpy_write(struct vfio_device *vdev, const char __user *buf,\n\t\t\t  size_t count, loff_t *ppos)\n{\n\tstruct mdev_state *mdev_state =\n\t\tcontainer_of(vdev, struct mdev_state, vdev);\n\tunsigned int done = 0;\n\tint ret;\n\n\twhile (count) {\n\t\tsize_t filled;\n\n\t\tif (count >= 4 && !(*ppos % 4)) {\n\t\t\tu32 val;\n\n\t\t\tif (copy_from_user(&val, buf, sizeof(val)))\n\t\t\t\tgoto write_err;\n\n\t\t\tret = mdev_access(mdev_state, (char *)&val, sizeof(val),\n\t\t\t\t\t  *ppos, true);\n\t\t\tif (ret <= 0)\n\t\t\t\tgoto write_err;\n\n\t\t\tfilled = 4;\n\t\t} else if (count >= 2 && !(*ppos % 2)) {\n\t\t\tu16 val;\n\n\t\t\tif (copy_from_user(&val, buf, sizeof(val)))\n\t\t\t\tgoto write_err;\n\n\t\t\tret = mdev_access(mdev_state, (char *)&val, sizeof(val),\n\t\t\t\t\t  *ppos, true);\n\t\t\tif (ret <= 0)\n\t\t\t\tgoto write_err;\n\n\t\t\tfilled = 2;\n\t\t} else {\n\t\t\tu8 val;\n\n\t\t\tif (copy_from_user(&val, buf, sizeof(val)))\n\t\t\t\tgoto write_err;\n\n\t\t\tret = mdev_access(mdev_state, (char *)&val, sizeof(val),\n\t\t\t\t\t  *ppos, true);\n\t\t\tif (ret <= 0)\n\t\t\t\tgoto write_err;\n\n\t\t\tfilled = 1;\n\t\t}\n\t\tcount -= filled;\n\t\tdone += filled;\n\t\t*ppos += filled;\n\t\tbuf += filled;\n\t}\n\n\treturn done;\nwrite_err:\n\treturn -EFAULT;\n}\n\nstatic int mdpy_mmap(struct vfio_device *vdev, struct vm_area_struct *vma)\n{\n\tstruct mdev_state *mdev_state =\n\t\tcontainer_of(vdev, struct mdev_state, vdev);\n\n\tif (vma->vm_pgoff != MDPY_MEMORY_BAR_OFFSET >> PAGE_SHIFT)\n\t\treturn -EINVAL;\n\tif (vma->vm_end < vma->vm_start)\n\t\treturn -EINVAL;\n\tif (vma->vm_end - vma->vm_start > mdev_state->memsize)\n\t\treturn -EINVAL;\n\tif ((vma->vm_flags & VM_SHARED) == 0)\n\t\treturn -EINVAL;\n\n\treturn remap_vmalloc_range(vma, mdev_state->memblk, 0);\n}\n\nstatic int mdpy_get_region_info(struct mdev_state *mdev_state,\n\t\t\t\tstruct vfio_region_info *region_info,\n\t\t\t\tu16 *cap_type_id, void **cap_type)\n{\n\tif (region_info->index >= VFIO_PCI_NUM_REGIONS &&\n\t    region_info->index != MDPY_DISPLAY_REGION)\n\t\treturn -EINVAL;\n\n\tswitch (region_info->index) {\n\tcase VFIO_PCI_CONFIG_REGION_INDEX:\n\t\tregion_info->offset = 0;\n\t\tregion_info->size   = MDPY_CONFIG_SPACE_SIZE;\n\t\tregion_info->flags  = (VFIO_REGION_INFO_FLAG_READ |\n\t\t\t\t       VFIO_REGION_INFO_FLAG_WRITE);\n\t\tbreak;\n\tcase VFIO_PCI_BAR0_REGION_INDEX:\n\tcase MDPY_DISPLAY_REGION:\n\t\tregion_info->offset = MDPY_MEMORY_BAR_OFFSET;\n\t\tregion_info->size   = mdev_state->memsize;\n\t\tregion_info->flags  = (VFIO_REGION_INFO_FLAG_READ  |\n\t\t\t\t       VFIO_REGION_INFO_FLAG_WRITE |\n\t\t\t\t       VFIO_REGION_INFO_FLAG_MMAP);\n\t\tbreak;\n\tdefault:\n\t\tregion_info->size   = 0;\n\t\tregion_info->offset = 0;\n\t\tregion_info->flags  = 0;\n\t}\n\n\treturn 0;\n}\n\nstatic int mdpy_get_irq_info(struct vfio_irq_info *irq_info)\n{\n\tirq_info->count = 0;\n\treturn 0;\n}\n\nstatic int mdpy_get_device_info(struct vfio_device_info *dev_info)\n{\n\tdev_info->flags = VFIO_DEVICE_FLAGS_PCI;\n\tdev_info->num_regions = VFIO_PCI_NUM_REGIONS;\n\tdev_info->num_irqs = VFIO_PCI_NUM_IRQS;\n\treturn 0;\n}\n\nstatic int mdpy_query_gfx_plane(struct mdev_state *mdev_state,\n\t\t\t\tstruct vfio_device_gfx_plane_info *plane)\n{\n\tif (plane->flags & VFIO_GFX_PLANE_TYPE_PROBE) {\n\t\tif (plane->flags == (VFIO_GFX_PLANE_TYPE_PROBE |\n\t\t\t\t     VFIO_GFX_PLANE_TYPE_REGION))\n\t\t\treturn 0;\n\t\treturn -EINVAL;\n\t}\n\n\tif (plane->flags != VFIO_GFX_PLANE_TYPE_REGION)\n\t\treturn -EINVAL;\n\n\tplane->drm_format     = mdev_state->type->format;\n\tplane->width\t      = mdev_state->type->width;\n\tplane->height\t      = mdev_state->type->height;\n\tplane->stride\t      = (mdev_state->type->width *\n\t\t\t\t mdev_state->type->bytepp);\n\tplane->size\t      = mdev_state->memsize;\n\tplane->region_index   = MDPY_DISPLAY_REGION;\n\n\t \n\tplane->drm_format_mod = 0;\n\tplane->x_pos\t      = 0;\n\tplane->y_pos\t      = 0;\n\tplane->x_hot\t      = 0;\n\tplane->y_hot\t      = 0;\n\n\treturn 0;\n}\n\nstatic long mdpy_ioctl(struct vfio_device *vdev, unsigned int cmd,\n\t\t       unsigned long arg)\n{\n\tint ret = 0;\n\tunsigned long minsz;\n\tstruct mdev_state *mdev_state =\n\t\tcontainer_of(vdev, struct mdev_state, vdev);\n\n\tswitch (cmd) {\n\tcase VFIO_DEVICE_GET_INFO:\n\t{\n\t\tstruct vfio_device_info info;\n\n\t\tminsz = offsetofend(struct vfio_device_info, num_irqs);\n\n\t\tif (copy_from_user(&info, (void __user *)arg, minsz))\n\t\t\treturn -EFAULT;\n\n\t\tif (info.argsz < minsz)\n\t\t\treturn -EINVAL;\n\n\t\tret = mdpy_get_device_info(&info);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tmemcpy(&mdev_state->dev_info, &info, sizeof(info));\n\n\t\tif (copy_to_user((void __user *)arg, &info, minsz))\n\t\t\treturn -EFAULT;\n\n\t\treturn 0;\n\t}\n\tcase VFIO_DEVICE_GET_REGION_INFO:\n\t{\n\t\tstruct vfio_region_info info;\n\t\tu16 cap_type_id = 0;\n\t\tvoid *cap_type = NULL;\n\n\t\tminsz = offsetofend(struct vfio_region_info, offset);\n\n\t\tif (copy_from_user(&info, (void __user *)arg, minsz))\n\t\t\treturn -EFAULT;\n\n\t\tif (info.argsz < minsz)\n\t\t\treturn -EINVAL;\n\n\t\tret = mdpy_get_region_info(mdev_state, &info, &cap_type_id,\n\t\t\t\t\t   &cap_type);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (copy_to_user((void __user *)arg, &info, minsz))\n\t\t\treturn -EFAULT;\n\n\t\treturn 0;\n\t}\n\n\tcase VFIO_DEVICE_GET_IRQ_INFO:\n\t{\n\t\tstruct vfio_irq_info info;\n\n\t\tminsz = offsetofend(struct vfio_irq_info, count);\n\n\t\tif (copy_from_user(&info, (void __user *)arg, minsz))\n\t\t\treturn -EFAULT;\n\n\t\tif ((info.argsz < minsz) ||\n\t\t    (info.index >= mdev_state->dev_info.num_irqs))\n\t\t\treturn -EINVAL;\n\n\t\tret = mdpy_get_irq_info(&info);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (copy_to_user((void __user *)arg, &info, minsz))\n\t\t\treturn -EFAULT;\n\n\t\treturn 0;\n\t}\n\n\tcase VFIO_DEVICE_QUERY_GFX_PLANE:\n\t{\n\t\tstruct vfio_device_gfx_plane_info plane;\n\n\t\tminsz = offsetofend(struct vfio_device_gfx_plane_info,\n\t\t\t\t    region_index);\n\n\t\tif (copy_from_user(&plane, (void __user *)arg, minsz))\n\t\t\treturn -EFAULT;\n\n\t\tif (plane.argsz < minsz)\n\t\t\treturn -EINVAL;\n\n\t\tret = mdpy_query_gfx_plane(mdev_state, &plane);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (copy_to_user((void __user *)arg, &plane, minsz))\n\t\t\treturn -EFAULT;\n\n\t\treturn 0;\n\t}\n\n\tcase VFIO_DEVICE_SET_IRQS:\n\t\treturn -EINVAL;\n\n\tcase VFIO_DEVICE_RESET:\n\t\treturn mdpy_reset(mdev_state);\n\t}\n\treturn -ENOTTY;\n}\n\nstatic ssize_t\nresolution_show(struct device *dev, struct device_attribute *attr,\n\t\tchar *buf)\n{\n\tstruct mdev_state *mdev_state = dev_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%dx%d\\n\",\n\t\t       mdev_state->type->width,\n\t\t       mdev_state->type->height);\n}\nstatic DEVICE_ATTR_RO(resolution);\n\nstatic struct attribute *mdev_dev_attrs[] = {\n\t&dev_attr_resolution.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group mdev_dev_group = {\n\t.name  = \"vendor\",\n\t.attrs = mdev_dev_attrs,\n};\n\nstatic const struct attribute_group *mdev_dev_groups[] = {\n\t&mdev_dev_group,\n\tNULL,\n};\n\nstatic ssize_t mdpy_show_description(struct mdev_type *mtype, char *buf)\n{\n\tstruct mdpy_type *type = container_of(mtype, struct mdpy_type, type);\n\n\treturn sprintf(buf, \"virtual display, %dx%d framebuffer\\n\",\n\t\t       type->width, type->height);\n}\n\nstatic const struct vfio_device_ops mdpy_dev_ops = {\n\t.init = mdpy_init_dev,\n\t.release = mdpy_release_dev,\n\t.read = mdpy_read,\n\t.write = mdpy_write,\n\t.ioctl = mdpy_ioctl,\n\t.mmap = mdpy_mmap,\n\t.bind_iommufd\t= vfio_iommufd_emulated_bind,\n\t.unbind_iommufd\t= vfio_iommufd_emulated_unbind,\n\t.attach_ioas\t= vfio_iommufd_emulated_attach_ioas,\n\t.detach_ioas\t= vfio_iommufd_emulated_detach_ioas,\n};\n\nstatic struct mdev_driver mdpy_driver = {\n\t.device_api = VFIO_DEVICE_API_PCI_STRING,\n\t.max_instances = 4,\n\t.driver = {\n\t\t.name = \"mdpy\",\n\t\t.owner = THIS_MODULE,\n\t\t.mod_name = KBUILD_MODNAME,\n\t\t.dev_groups = mdev_dev_groups,\n\t},\n\t.probe = mdpy_probe,\n\t.remove\t= mdpy_remove,\n\t.show_description = mdpy_show_description,\n};\n\nstatic const struct file_operations vd_fops = {\n\t.owner\t\t= THIS_MODULE,\n};\n\nstatic void mdpy_device_release(struct device *dev)\n{\n\t \n}\n\nstatic int __init mdpy_dev_init(void)\n{\n\tint ret = 0;\n\n\tret = alloc_chrdev_region(&mdpy_devt, 0, MINORMASK + 1, MDPY_NAME);\n\tif (ret < 0) {\n\t\tpr_err(\"Error: failed to register mdpy_dev, err: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\tcdev_init(&mdpy_cdev, &vd_fops);\n\tcdev_add(&mdpy_cdev, mdpy_devt, MINORMASK + 1);\n\tpr_info(\"%s: major %d\\n\", __func__, MAJOR(mdpy_devt));\n\n\tret = mdev_register_driver(&mdpy_driver);\n\tif (ret)\n\t\tgoto err_cdev;\n\n\tmdpy_class = class_create(MDPY_CLASS_NAME);\n\tif (IS_ERR(mdpy_class)) {\n\t\tpr_err(\"Error: failed to register mdpy_dev class\\n\");\n\t\tret = PTR_ERR(mdpy_class);\n\t\tgoto err_driver;\n\t}\n\tmdpy_dev.class = mdpy_class;\n\tmdpy_dev.release = mdpy_device_release;\n\tdev_set_name(&mdpy_dev, \"%s\", MDPY_NAME);\n\n\tret = device_register(&mdpy_dev);\n\tif (ret)\n\t\tgoto err_put;\n\n\tret = mdev_register_parent(&mdpy_parent, &mdpy_dev, &mdpy_driver,\n\t\t\t\t   mdpy_mdev_types,\n\t\t\t\t   ARRAY_SIZE(mdpy_mdev_types));\n\tif (ret)\n\t\tgoto err_device;\n\n\treturn 0;\n\nerr_device:\n\tdevice_del(&mdpy_dev);\nerr_put:\n\tput_device(&mdpy_dev);\n\tclass_destroy(mdpy_class);\nerr_driver:\n\tmdev_unregister_driver(&mdpy_driver);\nerr_cdev:\n\tcdev_del(&mdpy_cdev);\n\tunregister_chrdev_region(mdpy_devt, MINORMASK + 1);\n\treturn ret;\n}\n\nstatic void __exit mdpy_dev_exit(void)\n{\n\tmdpy_dev.bus = NULL;\n\tmdev_unregister_parent(&mdpy_parent);\n\n\tdevice_unregister(&mdpy_dev);\n\tmdev_unregister_driver(&mdpy_driver);\n\tcdev_del(&mdpy_cdev);\n\tunregister_chrdev_region(mdpy_devt, MINORMASK + 1);\n\tclass_destroy(mdpy_class);\n\tmdpy_class = NULL;\n}\n\nmodule_param_named(count, mdpy_driver.max_instances, int, 0444);\nMODULE_PARM_DESC(count, \"number of \" MDPY_NAME \" devices\");\n\nmodule_init(mdpy_dev_init)\nmodule_exit(mdpy_dev_exit)\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}