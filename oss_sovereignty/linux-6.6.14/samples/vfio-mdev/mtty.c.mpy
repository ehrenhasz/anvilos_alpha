{
  "module_name": "mtty.c",
  "hash_id": "06063eaf1e9005ca6c78c87e962269a3c74ecf6c3a88ba49949f072e54a9ce7f",
  "original_prompt": "Ingested from linux-6.6.14/samples/vfio-mdev/mtty.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/cdev.h>\n#include <linux/sched.h>\n#include <linux/wait.h>\n#include <linux/vfio.h>\n#include <linux/iommu.h>\n#include <linux/sysfs.h>\n#include <linux/ctype.h>\n#include <linux/file.h>\n#include <linux/mdev.h>\n#include <linux/pci.h>\n#include <linux/serial.h>\n#include <uapi/linux/serial_reg.h>\n#include <linux/eventfd.h>\n \n\n#define VERSION_STRING  \"0.1\"\n#define DRIVER_AUTHOR   \"NVIDIA Corporation\"\n\n#define MTTY_CLASS_NAME \"mtty\"\n\n#define MTTY_NAME       \"mtty\"\n\n#define MTTY_STRING_LEN\t\t16\n\n#define MTTY_CONFIG_SPACE_SIZE  0xff\n#define MTTY_IO_BAR_SIZE        0x8\n#define MTTY_MMIO_BAR_SIZE      0x100000\n\n#define STORE_LE16(addr, val)   (*(u16 *)addr = val)\n#define STORE_LE32(addr, val)   (*(u32 *)addr = val)\n\n#define MAX_FIFO_SIZE   16\n\n#define CIRCULAR_BUF_INC_IDX(idx)    (idx = (idx + 1) & (MAX_FIFO_SIZE - 1))\n\n#define MTTY_VFIO_PCI_OFFSET_SHIFT   40\n\n#define MTTY_VFIO_PCI_OFFSET_TO_INDEX(off)   (off >> MTTY_VFIO_PCI_OFFSET_SHIFT)\n#define MTTY_VFIO_PCI_INDEX_TO_OFFSET(index) \\\n\t\t\t\t((u64)(index) << MTTY_VFIO_PCI_OFFSET_SHIFT)\n#define MTTY_VFIO_PCI_OFFSET_MASK    \\\n\t\t\t\t(((u64)(1) << MTTY_VFIO_PCI_OFFSET_SHIFT) - 1)\n#define MAX_MTTYS\t24\n\n \n\nstatic struct mtty_dev {\n\tdev_t\t\tvd_devt;\n\tstruct class\t*vd_class;\n\tstruct cdev\tvd_cdev;\n\tstruct idr\tvd_idr;\n\tstruct device\tdev;\n\tstruct mdev_parent parent;\n} mtty_dev;\n\nstruct mdev_region_info {\n\tu64 start;\n\tu64 phys_start;\n\tu32 size;\n\tu64 vfio_offset;\n};\n\n#if defined(DEBUG_REGS)\nstatic const char *wr_reg[] = {\n\t\"TX\",\n\t\"IER\",\n\t\"FCR\",\n\t\"LCR\",\n\t\"MCR\",\n\t\"LSR\",\n\t\"MSR\",\n\t\"SCR\"\n};\n\nstatic const char *rd_reg[] = {\n\t\"RX\",\n\t\"IER\",\n\t\"IIR\",\n\t\"LCR\",\n\t\"MCR\",\n\t\"LSR\",\n\t\"MSR\",\n\t\"SCR\"\n};\n#endif\n\n \nstruct rxtx {\n\tu8 fifo[MAX_FIFO_SIZE];\n\tu8 head, tail;\n\tu8 count;\n};\n\nstruct serial_port {\n\tu8 uart_reg[8];          \n\tstruct rxtx rxtx;        \n\tbool dlab;\n\tbool overrun;\n\tu16 divisor;\n\tu8 fcr;                  \n\tu8 max_fifo_size;\n\tu8 intr_trigger_level;   \n};\n\n \nstruct mdev_state {\n\tstruct vfio_device vdev;\n\tstruct eventfd_ctx *intx_evtfd;\n\tstruct eventfd_ctx *msi_evtfd;\n\tint irq_index;\n\tu8 *vconfig;\n\tstruct mutex ops_lock;\n\tstruct mdev_device *mdev;\n\tstruct mdev_region_info region_info[VFIO_PCI_NUM_REGIONS];\n\tu32 bar_mask[VFIO_PCI_NUM_REGIONS];\n\tstruct list_head next;\n\tstruct serial_port s[2];\n\tstruct mutex rxtx_lock;\n\tstruct vfio_device_info dev_info;\n\tint nr_ports;\n\tu8 intx_mask:1;\n};\n\nstatic struct mtty_type {\n\tstruct mdev_type type;\n\tint nr_ports;\n} mtty_types[2] = {\n\t{ .nr_ports = 1, .type.sysfs_name = \"1\",\n\t  .type.pretty_name = \"Single port serial\" },\n\t{ .nr_ports = 2, .type.sysfs_name = \"2\",\n\t  .type.pretty_name = \"Dual port serial\" },\n};\n\nstatic struct mdev_type *mtty_mdev_types[] = {\n\t&mtty_types[0].type,\n\t&mtty_types[1].type,\n};\n\nstatic atomic_t mdev_avail_ports = ATOMIC_INIT(MAX_MTTYS);\n\nstatic const struct file_operations vd_fops = {\n\t.owner          = THIS_MODULE,\n};\n\nstatic const struct vfio_device_ops mtty_dev_ops;\n\n \n\nstatic void dump_buffer(u8 *buf, uint32_t count)\n{\n#if defined(DEBUG)\n\tint i;\n\n\tpr_info(\"Buffer:\\n\");\n\tfor (i = 0; i < count; i++) {\n\t\tpr_info(\"%2x \", *(buf + i));\n\t\tif ((i + 1) % 16 == 0)\n\t\t\tpr_info(\"\\n\");\n\t}\n#endif\n}\n\nstatic bool is_intx(struct mdev_state *mdev_state)\n{\n\treturn mdev_state->irq_index == VFIO_PCI_INTX_IRQ_INDEX;\n}\n\nstatic bool is_msi(struct mdev_state *mdev_state)\n{\n\treturn mdev_state->irq_index == VFIO_PCI_MSI_IRQ_INDEX;\n}\n\nstatic bool is_noirq(struct mdev_state *mdev_state)\n{\n\treturn !is_intx(mdev_state) && !is_msi(mdev_state);\n}\n\nstatic void mtty_trigger_interrupt(struct mdev_state *mdev_state)\n{\n\tlockdep_assert_held(&mdev_state->ops_lock);\n\n\tif (is_msi(mdev_state)) {\n\t\tif (mdev_state->msi_evtfd)\n\t\t\teventfd_signal(mdev_state->msi_evtfd, 1);\n\t} else if (is_intx(mdev_state)) {\n\t\tif (mdev_state->intx_evtfd && !mdev_state->intx_mask) {\n\t\t\teventfd_signal(mdev_state->intx_evtfd, 1);\n\t\t\tmdev_state->intx_mask = true;\n\t\t}\n\t}\n}\n\nstatic void mtty_create_config_space(struct mdev_state *mdev_state)\n{\n\t \n\tSTORE_LE32((u32 *) &mdev_state->vconfig[0x0], 0x32534348);\n\n\t \n\tSTORE_LE16((u16 *) &mdev_state->vconfig[0x4], 0x0001);\n\n\t \n\tSTORE_LE16((u16 *) &mdev_state->vconfig[0x6], 0x0200);\n\n\t \n\tmdev_state->vconfig[0x8] =  0x10;\n\n\t \n\tmdev_state->vconfig[0x9] =  0x02;\n\n\t \n\tmdev_state->vconfig[0xa] =  0x00;\n\n\t \n\tmdev_state->vconfig[0xb] =  0x07;\n\n\t \n\t \n\tSTORE_LE32((u32 *) &mdev_state->vconfig[0x10], 0x000001);\n\tmdev_state->bar_mask[0] = ~(MTTY_IO_BAR_SIZE) + 1;\n\n\tif (mdev_state->nr_ports == 2) {\n\t\t \n\t\tSTORE_LE32((u32 *) &mdev_state->vconfig[0x14], 0x000001);\n\t\tmdev_state->bar_mask[1] = ~(MTTY_IO_BAR_SIZE) + 1;\n\t}\n\n\t \n\tSTORE_LE32((u32 *) &mdev_state->vconfig[0x2c], 0x32534348);\n\n\tmdev_state->vconfig[0x34] =  0x00;    \n\tmdev_state->vconfig[0x3d] =  0x01;    \n\n\t \n\tmdev_state->vconfig[0x40] =  0x23;\n\tmdev_state->vconfig[0x43] =  0x80;\n\tmdev_state->vconfig[0x44] =  0x23;\n\tmdev_state->vconfig[0x48] =  0x23;\n\tmdev_state->vconfig[0x4c] =  0x23;\n\n\tmdev_state->vconfig[0x60] =  0x50;\n\tmdev_state->vconfig[0x61] =  0x43;\n\tmdev_state->vconfig[0x62] =  0x49;\n\tmdev_state->vconfig[0x63] =  0x20;\n\tmdev_state->vconfig[0x64] =  0x53;\n\tmdev_state->vconfig[0x65] =  0x65;\n\tmdev_state->vconfig[0x66] =  0x72;\n\tmdev_state->vconfig[0x67] =  0x69;\n\tmdev_state->vconfig[0x68] =  0x61;\n\tmdev_state->vconfig[0x69] =  0x6c;\n\tmdev_state->vconfig[0x6a] =  0x2f;\n\tmdev_state->vconfig[0x6b] =  0x55;\n\tmdev_state->vconfig[0x6c] =  0x41;\n\tmdev_state->vconfig[0x6d] =  0x52;\n\tmdev_state->vconfig[0x6e] =  0x54;\n}\n\nstatic void handle_pci_cfg_write(struct mdev_state *mdev_state, u16 offset,\n\t\t\t\t u8 *buf, u32 count)\n{\n\tu32 cfg_addr, bar_mask, bar_index = 0;\n\n\tswitch (offset) {\n\tcase 0x04:  \n\tcase 0x06:  \n\t\t \n\t\tbreak;\n\tcase 0x3c:   \n\t\tmdev_state->vconfig[0x3c] = buf[0];\n\t\tbreak;\n\tcase 0x3d:\n\t\t \n\t\tbreak;\n\tcase 0x10:   \n\tcase 0x14:   \n\t\tif (offset == 0x10)\n\t\t\tbar_index = 0;\n\t\telse if (offset == 0x14)\n\t\t\tbar_index = 1;\n\n\t\tif ((mdev_state->nr_ports == 1) && (bar_index == 1)) {\n\t\t\tSTORE_LE32(&mdev_state->vconfig[offset], 0);\n\t\t\tbreak;\n\t\t}\n\n\t\tcfg_addr = *(u32 *)buf;\n\t\tpr_info(\"BAR%d addr 0x%x\\n\", bar_index, cfg_addr);\n\n\t\tif (cfg_addr == 0xffffffff) {\n\t\t\tbar_mask = mdev_state->bar_mask[bar_index];\n\t\t\tcfg_addr = (cfg_addr & bar_mask);\n\t\t}\n\n\t\tcfg_addr |= (mdev_state->vconfig[offset] & 0x3ul);\n\t\tSTORE_LE32(&mdev_state->vconfig[offset], cfg_addr);\n\t\tbreak;\n\tcase 0x18:   \n\tcase 0x1c:   \n\tcase 0x20:   \n\t\tSTORE_LE32(&mdev_state->vconfig[offset], 0);\n\t\tbreak;\n\tdefault:\n\t\tpr_info(\"PCI config write @0x%x of %d bytes not handled\\n\",\n\t\t\toffset, count);\n\t\tbreak;\n\t}\n}\n\nstatic void handle_bar_write(unsigned int index, struct mdev_state *mdev_state,\n\t\t\t\tu16 offset, u8 *buf, u32 count)\n{\n\tu8 data = *buf;\n\n\t \n\tswitch (offset) {\n\tcase UART_TX:\n\t\t \n\t\tif (mdev_state->s[index].dlab) {\n\t\t\tmdev_state->s[index].divisor |= data;\n\t\t\tbreak;\n\t\t}\n\n\t\tmutex_lock(&mdev_state->rxtx_lock);\n\n\t\t \n\t\tif (mdev_state->s[index].rxtx.count <\n\t\t\t\tmdev_state->s[index].max_fifo_size) {\n\t\t\tmdev_state->s[index].rxtx.fifo[\n\t\t\t\t\tmdev_state->s[index].rxtx.head] = data;\n\t\t\tmdev_state->s[index].rxtx.count++;\n\t\t\tCIRCULAR_BUF_INC_IDX(mdev_state->s[index].rxtx.head);\n\t\t\tmdev_state->s[index].overrun = false;\n\n\t\t\t \n\t\t\tif ((mdev_state->s[index].uart_reg[UART_IER] &\n\t\t\t\t\t\tUART_IER_RDI) &&\n\t\t\t   (mdev_state->s[index].rxtx.count ==\n\t\t\t\t    mdev_state->s[index].intr_trigger_level)) {\n\t\t\t\t \n#if defined(DEBUG_INTR)\n\t\t\t\tpr_err(\"Serial port %d: Fifo level trigger\\n\",\n\t\t\t\t\tindex);\n#endif\n\t\t\t\tmtty_trigger_interrupt(mdev_state);\n\t\t\t}\n\t\t} else {\n#if defined(DEBUG_INTR)\n\t\t\tpr_err(\"Serial port %d: Buffer Overflow\\n\", index);\n#endif\n\t\t\tmdev_state->s[index].overrun = true;\n\n\t\t\t \n\t\t\tif (mdev_state->s[index].uart_reg[UART_IER] &\n\t\t\t\t\t\t\t\tUART_IER_RLSI)\n\t\t\t\tmtty_trigger_interrupt(mdev_state);\n\t\t}\n\t\tmutex_unlock(&mdev_state->rxtx_lock);\n\t\tbreak;\n\n\tcase UART_IER:\n\t\t \n\t\tif (mdev_state->s[index].dlab)\n\t\t\tmdev_state->s[index].divisor |= (u16)data << 8;\n\t\telse {\n\t\t\tmdev_state->s[index].uart_reg[offset] = data;\n\t\t\tmutex_lock(&mdev_state->rxtx_lock);\n\t\t\tif ((data & UART_IER_THRI) &&\n\t\t\t    (mdev_state->s[index].rxtx.head ==\n\t\t\t\t\tmdev_state->s[index].rxtx.tail)) {\n#if defined(DEBUG_INTR)\n\t\t\t\tpr_err(\"Serial port %d: IER_THRI write\\n\",\n\t\t\t\t\tindex);\n#endif\n\t\t\t\tmtty_trigger_interrupt(mdev_state);\n\t\t\t}\n\n\t\t\tmutex_unlock(&mdev_state->rxtx_lock);\n\t\t}\n\n\t\tbreak;\n\n\tcase UART_FCR:\n\t\tmdev_state->s[index].fcr = data;\n\n\t\tmutex_lock(&mdev_state->rxtx_lock);\n\t\tif (data & (UART_FCR_CLEAR_RCVR | UART_FCR_CLEAR_XMIT)) {\n\t\t\t \n\t\t\tmdev_state->s[index].rxtx.count = 0;\n\t\t\tmdev_state->s[index].rxtx.head = 0;\n\t\t\tmdev_state->s[index].rxtx.tail = 0;\n\t\t}\n\t\tmutex_unlock(&mdev_state->rxtx_lock);\n\n\t\tswitch (data & UART_FCR_TRIGGER_MASK) {\n\t\tcase UART_FCR_TRIGGER_1:\n\t\t\tmdev_state->s[index].intr_trigger_level = 1;\n\t\t\tbreak;\n\n\t\tcase UART_FCR_TRIGGER_4:\n\t\t\tmdev_state->s[index].intr_trigger_level = 4;\n\t\t\tbreak;\n\n\t\tcase UART_FCR_TRIGGER_8:\n\t\t\tmdev_state->s[index].intr_trigger_level = 8;\n\t\t\tbreak;\n\n\t\tcase UART_FCR_TRIGGER_14:\n\t\t\tmdev_state->s[index].intr_trigger_level = 14;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tmdev_state->s[index].intr_trigger_level = 1;\n\t\tif (data & UART_FCR_ENABLE_FIFO)\n\t\t\tmdev_state->s[index].max_fifo_size = MAX_FIFO_SIZE;\n\t\telse {\n\t\t\tmdev_state->s[index].max_fifo_size = 1;\n\t\t\tmdev_state->s[index].intr_trigger_level = 1;\n\t\t}\n\n\t\tbreak;\n\n\tcase UART_LCR:\n\t\tif (data & UART_LCR_DLAB) {\n\t\t\tmdev_state->s[index].dlab = true;\n\t\t\tmdev_state->s[index].divisor = 0;\n\t\t} else\n\t\t\tmdev_state->s[index].dlab = false;\n\n\t\tmdev_state->s[index].uart_reg[offset] = data;\n\t\tbreak;\n\n\tcase UART_MCR:\n\t\tmdev_state->s[index].uart_reg[offset] = data;\n\n\t\tif ((mdev_state->s[index].uart_reg[UART_IER] & UART_IER_MSI) &&\n\t\t\t\t(data & UART_MCR_OUT2)) {\n#if defined(DEBUG_INTR)\n\t\t\tpr_err(\"Serial port %d: MCR_OUT2 write\\n\", index);\n#endif\n\t\t\tmtty_trigger_interrupt(mdev_state);\n\t\t}\n\n\t\tif ((mdev_state->s[index].uart_reg[UART_IER] & UART_IER_MSI) &&\n\t\t\t\t(data & (UART_MCR_RTS | UART_MCR_DTR))) {\n#if defined(DEBUG_INTR)\n\t\t\tpr_err(\"Serial port %d: MCR RTS/DTR write\\n\", index);\n#endif\n\t\t\tmtty_trigger_interrupt(mdev_state);\n\t\t}\n\t\tbreak;\n\n\tcase UART_LSR:\n\tcase UART_MSR:\n\t\t \n\t\tbreak;\n\n\tcase UART_SCR:\n\t\tmdev_state->s[index].uart_reg[offset] = data;\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void handle_bar_read(unsigned int index, struct mdev_state *mdev_state,\n\t\t\t    u16 offset, u8 *buf, u32 count)\n{\n\t \n\tswitch (offset) {\n\tcase UART_RX:\n\t\t \n\t\tif (mdev_state->s[index].dlab) {\n\t\t\t*buf  = (u8)mdev_state->s[index].divisor;\n\t\t\tbreak;\n\t\t}\n\n\t\tmutex_lock(&mdev_state->rxtx_lock);\n\t\t \n\t\tif (mdev_state->s[index].rxtx.head !=\n\t\t\t\t mdev_state->s[index].rxtx.tail) {\n\t\t\t*buf = mdev_state->s[index].rxtx.fifo[\n\t\t\t\t\t\tmdev_state->s[index].rxtx.tail];\n\t\t\tmdev_state->s[index].rxtx.count--;\n\t\t\tCIRCULAR_BUF_INC_IDX(mdev_state->s[index].rxtx.tail);\n\t\t}\n\n\t\tif (mdev_state->s[index].rxtx.head ==\n\t\t\t\tmdev_state->s[index].rxtx.tail) {\n\t\t \n#if defined(DEBUG_INTR)\n\t\t\tpr_err(\"Serial port %d: Buffer Empty\\n\", index);\n#endif\n\t\t\tif (mdev_state->s[index].uart_reg[UART_IER] &\n\t\t\t\t\t\t\t UART_IER_THRI)\n\t\t\t\tmtty_trigger_interrupt(mdev_state);\n\t\t}\n\t\tmutex_unlock(&mdev_state->rxtx_lock);\n\n\t\tbreak;\n\n\tcase UART_IER:\n\t\tif (mdev_state->s[index].dlab) {\n\t\t\t*buf = (u8)(mdev_state->s[index].divisor >> 8);\n\t\t\tbreak;\n\t\t}\n\t\t*buf = mdev_state->s[index].uart_reg[offset] & 0x0f;\n\t\tbreak;\n\n\tcase UART_IIR:\n\t{\n\t\tu8 ier = mdev_state->s[index].uart_reg[UART_IER];\n\t\t*buf = 0;\n\n\t\tmutex_lock(&mdev_state->rxtx_lock);\n\t\t \n\t\tif ((ier & UART_IER_RLSI) && mdev_state->s[index].overrun)\n\t\t\t*buf |= UART_IIR_RLSI;\n\n\t\t \n\t\tif ((ier & UART_IER_RDI) &&\n\t\t    (mdev_state->s[index].rxtx.count >=\n\t\t      mdev_state->s[index].intr_trigger_level))\n\t\t\t*buf |= UART_IIR_RDI;\n\n\t\t \n\t\tif ((ier & UART_IER_THRI) &&\n\t\t    (mdev_state->s[index].rxtx.head ==\n\t\t\t\tmdev_state->s[index].rxtx.tail))\n\t\t\t*buf |= UART_IIR_THRI;\n\n\t\t \n\t\tif ((ier & UART_IER_MSI) &&\n\t\t    (mdev_state->s[index].uart_reg[UART_MCR] &\n\t\t\t\t (UART_MCR_RTS | UART_MCR_DTR)))\n\t\t\t*buf |= UART_IIR_MSI;\n\n\t\t \n\t\tif (*buf == 0)\n\t\t\t*buf = UART_IIR_NO_INT;\n\n\t\t \n\t\t*buf |= 0xC0;\n\t\tmutex_unlock(&mdev_state->rxtx_lock);\n\t}\n\tbreak;\n\n\tcase UART_LCR:\n\tcase UART_MCR:\n\t\t*buf = mdev_state->s[index].uart_reg[offset];\n\t\tbreak;\n\n\tcase UART_LSR:\n\t{\n\t\tu8 lsr = 0;\n\n\t\tmutex_lock(&mdev_state->rxtx_lock);\n\t\t \n\t\tif (mdev_state->s[index].rxtx.head !=\n\t\t\t\t mdev_state->s[index].rxtx.tail)\n\t\t\tlsr |= UART_LSR_DR;\n\n\t\t \n\t\tif (mdev_state->s[index].overrun)\n\t\t\tlsr |= UART_LSR_OE;\n\n\t\t \n\t\tif (mdev_state->s[index].rxtx.head ==\n\t\t\t\t mdev_state->s[index].rxtx.tail)\n\t\t\tlsr |= UART_LSR_TEMT | UART_LSR_THRE;\n\n\t\tmutex_unlock(&mdev_state->rxtx_lock);\n\t\t*buf = lsr;\n\t\tbreak;\n\t}\n\tcase UART_MSR:\n\t\t*buf = UART_MSR_DSR | UART_MSR_DDSR | UART_MSR_DCD;\n\n\t\tmutex_lock(&mdev_state->rxtx_lock);\n\t\t \n\t\tif (mdev_state->s[index].uart_reg[UART_MCR] &\n\t\t\t\t\t\t UART_MCR_AFE) {\n\t\t\tif (mdev_state->s[index].rxtx.count <\n\t\t\t\t\tmdev_state->s[index].max_fifo_size)\n\t\t\t\t*buf |= UART_MSR_CTS | UART_MSR_DCTS;\n\t\t} else\n\t\t\t*buf |= UART_MSR_CTS | UART_MSR_DCTS;\n\t\tmutex_unlock(&mdev_state->rxtx_lock);\n\n\t\tbreak;\n\n\tcase UART_SCR:\n\t\t*buf = mdev_state->s[index].uart_reg[offset];\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void mdev_read_base(struct mdev_state *mdev_state)\n{\n\tint index, pos;\n\tu32 start_lo, start_hi;\n\tu32 mem_type;\n\n\tpos = PCI_BASE_ADDRESS_0;\n\n\tfor (index = 0; index <= VFIO_PCI_BAR5_REGION_INDEX; index++) {\n\n\t\tif (!mdev_state->region_info[index].size)\n\t\t\tcontinue;\n\n\t\tstart_lo = (*(u32 *)(mdev_state->vconfig + pos)) &\n\t\t\tPCI_BASE_ADDRESS_MEM_MASK;\n\t\tmem_type = (*(u32 *)(mdev_state->vconfig + pos)) &\n\t\t\tPCI_BASE_ADDRESS_MEM_TYPE_MASK;\n\n\t\tswitch (mem_type) {\n\t\tcase PCI_BASE_ADDRESS_MEM_TYPE_64:\n\t\t\tstart_hi = (*(u32 *)(mdev_state->vconfig + pos + 4));\n\t\t\tpos += 4;\n\t\t\tbreak;\n\t\tcase PCI_BASE_ADDRESS_MEM_TYPE_32:\n\t\tcase PCI_BASE_ADDRESS_MEM_TYPE_1M:\n\t\t\t \n\t\tdefault:\n\t\t\t \n\t\t\tstart_hi = 0;\n\t\t\tbreak;\n\t\t}\n\t\tpos += 4;\n\t\tmdev_state->region_info[index].start = ((u64)start_hi << 32) |\n\t\t\t\t\t\t\tstart_lo;\n\t}\n}\n\nstatic ssize_t mdev_access(struct mdev_state *mdev_state, u8 *buf, size_t count,\n\t\t\t   loff_t pos, bool is_write)\n{\n\tunsigned int index;\n\tloff_t offset;\n\tint ret = 0;\n\n\tif (!buf)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&mdev_state->ops_lock);\n\n\tindex = MTTY_VFIO_PCI_OFFSET_TO_INDEX(pos);\n\toffset = pos & MTTY_VFIO_PCI_OFFSET_MASK;\n\tswitch (index) {\n\tcase VFIO_PCI_CONFIG_REGION_INDEX:\n\n#if defined(DEBUG)\n\t\tpr_info(\"%s: PCI config space %s at offset 0x%llx\\n\",\n\t\t\t __func__, is_write ? \"write\" : \"read\", offset);\n#endif\n\t\tif (is_write) {\n\t\t\tdump_buffer(buf, count);\n\t\t\thandle_pci_cfg_write(mdev_state, offset, buf, count);\n\t\t} else {\n\t\t\tmemcpy(buf, (mdev_state->vconfig + offset), count);\n\t\t\tdump_buffer(buf, count);\n\t\t}\n\n\t\tbreak;\n\n\tcase VFIO_PCI_BAR0_REGION_INDEX ... VFIO_PCI_BAR5_REGION_INDEX:\n\t\tif (!mdev_state->region_info[index].start)\n\t\t\tmdev_read_base(mdev_state);\n\n\t\tif (is_write) {\n\t\t\tdump_buffer(buf, count);\n\n#if defined(DEBUG_REGS)\n\t\t\tpr_info(\"%s: BAR%d  WR @0x%llx %s val:0x%02x dlab:%d\\n\",\n\t\t\t\t__func__, index, offset, wr_reg[offset],\n\t\t\t\t*buf, mdev_state->s[index].dlab);\n#endif\n\t\t\thandle_bar_write(index, mdev_state, offset, buf, count);\n\t\t} else {\n\t\t\thandle_bar_read(index, mdev_state, offset, buf, count);\n\t\t\tdump_buffer(buf, count);\n\n#if defined(DEBUG_REGS)\n\t\t\tpr_info(\"%s: BAR%d  RD @0x%llx %s val:0x%02x dlab:%d\\n\",\n\t\t\t\t__func__, index, offset, rd_reg[offset],\n\t\t\t\t*buf, mdev_state->s[index].dlab);\n#endif\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tret = -1;\n\t\tgoto accessfailed;\n\t}\n\n\tret = count;\n\n\naccessfailed:\n\tmutex_unlock(&mdev_state->ops_lock);\n\n\treturn ret;\n}\n\nstatic int mtty_init_dev(struct vfio_device *vdev)\n{\n\tstruct mdev_state *mdev_state =\n\t\tcontainer_of(vdev, struct mdev_state, vdev);\n\tstruct mdev_device *mdev = to_mdev_device(vdev->dev);\n\tstruct mtty_type *type =\n\t\tcontainer_of(mdev->type, struct mtty_type, type);\n\tint avail_ports = atomic_read(&mdev_avail_ports);\n\tint ret;\n\n\tdo {\n\t\tif (avail_ports < type->nr_ports)\n\t\t\treturn -ENOSPC;\n\t} while (!atomic_try_cmpxchg(&mdev_avail_ports,\n\t\t\t\t     &avail_ports,\n\t\t\t\t     avail_ports - type->nr_ports));\n\n\tmdev_state->nr_ports = type->nr_ports;\n\tmdev_state->irq_index = -1;\n\tmdev_state->s[0].max_fifo_size = MAX_FIFO_SIZE;\n\tmdev_state->s[1].max_fifo_size = MAX_FIFO_SIZE;\n\tmutex_init(&mdev_state->rxtx_lock);\n\n\tmdev_state->vconfig = kzalloc(MTTY_CONFIG_SPACE_SIZE, GFP_KERNEL);\n\tif (!mdev_state->vconfig) {\n\t\tret = -ENOMEM;\n\t\tgoto err_nr_ports;\n\t}\n\n\tmutex_init(&mdev_state->ops_lock);\n\tmdev_state->mdev = mdev;\n\tmtty_create_config_space(mdev_state);\n\treturn 0;\n\nerr_nr_ports:\n\tatomic_add(type->nr_ports, &mdev_avail_ports);\n\treturn ret;\n}\n\nstatic int mtty_probe(struct mdev_device *mdev)\n{\n\tstruct mdev_state *mdev_state;\n\tint ret;\n\n\tmdev_state = vfio_alloc_device(mdev_state, vdev, &mdev->dev,\n\t\t\t\t       &mtty_dev_ops);\n\tif (IS_ERR(mdev_state))\n\t\treturn PTR_ERR(mdev_state);\n\n\tret = vfio_register_emulated_iommu_dev(&mdev_state->vdev);\n\tif (ret)\n\t\tgoto err_put_vdev;\n\tdev_set_drvdata(&mdev->dev, mdev_state);\n\treturn 0;\n\nerr_put_vdev:\n\tvfio_put_device(&mdev_state->vdev);\n\treturn ret;\n}\n\nstatic void mtty_release_dev(struct vfio_device *vdev)\n{\n\tstruct mdev_state *mdev_state =\n\t\tcontainer_of(vdev, struct mdev_state, vdev);\n\n\tatomic_add(mdev_state->nr_ports, &mdev_avail_ports);\n\tkfree(mdev_state->vconfig);\n}\n\nstatic void mtty_remove(struct mdev_device *mdev)\n{\n\tstruct mdev_state *mdev_state = dev_get_drvdata(&mdev->dev);\n\n\tvfio_unregister_group_dev(&mdev_state->vdev);\n\tvfio_put_device(&mdev_state->vdev);\n}\n\nstatic int mtty_reset(struct mdev_state *mdev_state)\n{\n\tpr_info(\"%s: called\\n\", __func__);\n\n\treturn 0;\n}\n\nstatic ssize_t mtty_read(struct vfio_device *vdev, char __user *buf,\n\t\t\t size_t count, loff_t *ppos)\n{\n\tstruct mdev_state *mdev_state =\n\t\tcontainer_of(vdev, struct mdev_state, vdev);\n\tunsigned int done = 0;\n\tint ret;\n\n\twhile (count) {\n\t\tsize_t filled;\n\n\t\tif (count >= 4 && !(*ppos % 4)) {\n\t\t\tu32 val;\n\n\t\t\tret =  mdev_access(mdev_state, (u8 *)&val, sizeof(val),\n\t\t\t\t\t   *ppos, false);\n\t\t\tif (ret <= 0)\n\t\t\t\tgoto read_err;\n\n\t\t\tif (copy_to_user(buf, &val, sizeof(val)))\n\t\t\t\tgoto read_err;\n\n\t\t\tfilled = 4;\n\t\t} else if (count >= 2 && !(*ppos % 2)) {\n\t\t\tu16 val;\n\n\t\t\tret = mdev_access(mdev_state, (u8 *)&val, sizeof(val),\n\t\t\t\t\t  *ppos, false);\n\t\t\tif (ret <= 0)\n\t\t\t\tgoto read_err;\n\n\t\t\tif (copy_to_user(buf, &val, sizeof(val)))\n\t\t\t\tgoto read_err;\n\n\t\t\tfilled = 2;\n\t\t} else {\n\t\t\tu8 val;\n\n\t\t\tret = mdev_access(mdev_state, (u8 *)&val, sizeof(val),\n\t\t\t\t\t  *ppos, false);\n\t\t\tif (ret <= 0)\n\t\t\t\tgoto read_err;\n\n\t\t\tif (copy_to_user(buf, &val, sizeof(val)))\n\t\t\t\tgoto read_err;\n\n\t\t\tfilled = 1;\n\t\t}\n\n\t\tcount -= filled;\n\t\tdone += filled;\n\t\t*ppos += filled;\n\t\tbuf += filled;\n\t}\n\n\treturn done;\n\nread_err:\n\treturn -EFAULT;\n}\n\nstatic ssize_t mtty_write(struct vfio_device *vdev, const char __user *buf,\n\t\t   size_t count, loff_t *ppos)\n{\n\tstruct mdev_state *mdev_state =\n\t\tcontainer_of(vdev, struct mdev_state, vdev);\n\tunsigned int done = 0;\n\tint ret;\n\n\twhile (count) {\n\t\tsize_t filled;\n\n\t\tif (count >= 4 && !(*ppos % 4)) {\n\t\t\tu32 val;\n\n\t\t\tif (copy_from_user(&val, buf, sizeof(val)))\n\t\t\t\tgoto write_err;\n\n\t\t\tret = mdev_access(mdev_state, (u8 *)&val, sizeof(val),\n\t\t\t\t\t  *ppos, true);\n\t\t\tif (ret <= 0)\n\t\t\t\tgoto write_err;\n\n\t\t\tfilled = 4;\n\t\t} else if (count >= 2 && !(*ppos % 2)) {\n\t\t\tu16 val;\n\n\t\t\tif (copy_from_user(&val, buf, sizeof(val)))\n\t\t\t\tgoto write_err;\n\n\t\t\tret = mdev_access(mdev_state, (u8 *)&val, sizeof(val),\n\t\t\t\t\t  *ppos, true);\n\t\t\tif (ret <= 0)\n\t\t\t\tgoto write_err;\n\n\t\t\tfilled = 2;\n\t\t} else {\n\t\t\tu8 val;\n\n\t\t\tif (copy_from_user(&val, buf, sizeof(val)))\n\t\t\t\tgoto write_err;\n\n\t\t\tret = mdev_access(mdev_state, (u8 *)&val, sizeof(val),\n\t\t\t\t\t  *ppos, true);\n\t\t\tif (ret <= 0)\n\t\t\t\tgoto write_err;\n\n\t\t\tfilled = 1;\n\t\t}\n\t\tcount -= filled;\n\t\tdone += filled;\n\t\t*ppos += filled;\n\t\tbuf += filled;\n\t}\n\n\treturn done;\nwrite_err:\n\treturn -EFAULT;\n}\n\nstatic void mtty_disable_intx(struct mdev_state *mdev_state)\n{\n\tif (mdev_state->intx_evtfd) {\n\t\teventfd_ctx_put(mdev_state->intx_evtfd);\n\t\tmdev_state->intx_evtfd = NULL;\n\t\tmdev_state->intx_mask = false;\n\t\tmdev_state->irq_index = -1;\n\t}\n}\n\nstatic void mtty_disable_msi(struct mdev_state *mdev_state)\n{\n\tif (mdev_state->msi_evtfd) {\n\t\teventfd_ctx_put(mdev_state->msi_evtfd);\n\t\tmdev_state->msi_evtfd = NULL;\n\t\tmdev_state->irq_index = -1;\n\t}\n}\n\nstatic int mtty_set_irqs(struct mdev_state *mdev_state, uint32_t flags,\n\t\t\t unsigned int index, unsigned int start,\n\t\t\t unsigned int count, void *data)\n{\n\tint ret = 0;\n\n\tmutex_lock(&mdev_state->ops_lock);\n\tswitch (index) {\n\tcase VFIO_PCI_INTX_IRQ_INDEX:\n\t\tswitch (flags & VFIO_IRQ_SET_ACTION_TYPE_MASK) {\n\t\tcase VFIO_IRQ_SET_ACTION_MASK:\n\t\t\tif (!is_intx(mdev_state) || start != 0 || count != 1) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (flags & VFIO_IRQ_SET_DATA_NONE) {\n\t\t\t\tmdev_state->intx_mask = true;\n\t\t\t} else if (flags & VFIO_IRQ_SET_DATA_BOOL) {\n\t\t\t\tuint8_t mask = *(uint8_t *)data;\n\n\t\t\t\tif (mask)\n\t\t\t\t\tmdev_state->intx_mask = true;\n\t\t\t} else if (flags &  VFIO_IRQ_SET_DATA_EVENTFD) {\n\t\t\t\tret = -ENOTTY;  \n\t\t\t}\n\t\t\tbreak;\n\t\tcase VFIO_IRQ_SET_ACTION_UNMASK:\n\t\t\tif (!is_intx(mdev_state) || start != 0 || count != 1) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (flags & VFIO_IRQ_SET_DATA_NONE) {\n\t\t\t\tmdev_state->intx_mask = false;\n\t\t\t} else if (flags & VFIO_IRQ_SET_DATA_BOOL) {\n\t\t\t\tuint8_t mask = *(uint8_t *)data;\n\n\t\t\t\tif (mask)\n\t\t\t\t\tmdev_state->intx_mask = false;\n\t\t\t} else if (flags &  VFIO_IRQ_SET_DATA_EVENTFD) {\n\t\t\t\tret = -ENOTTY;  \n\t\t\t}\n\t\t\tbreak;\n\t\tcase VFIO_IRQ_SET_ACTION_TRIGGER:\n\t\t\tif (is_intx(mdev_state) && !count &&\n\t\t\t    (flags & VFIO_IRQ_SET_DATA_NONE)) {\n\t\t\t\tmtty_disable_intx(mdev_state);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (!(is_intx(mdev_state) || is_noirq(mdev_state)) ||\n\t\t\t    start != 0 || count != 1) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (flags & VFIO_IRQ_SET_DATA_EVENTFD) {\n\t\t\t\tint fd = *(int *)data;\n\t\t\t\tstruct eventfd_ctx *evt;\n\n\t\t\t\tmtty_disable_intx(mdev_state);\n\n\t\t\t\tif (fd < 0)\n\t\t\t\t\tbreak;\n\n\t\t\t\tevt = eventfd_ctx_fdget(fd);\n\t\t\t\tif (IS_ERR(evt)) {\n\t\t\t\t\tret = PTR_ERR(evt);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tmdev_state->intx_evtfd = evt;\n\t\t\t\tmdev_state->irq_index = index;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (!is_intx(mdev_state)) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (flags & VFIO_IRQ_SET_DATA_NONE) {\n\t\t\t\tmtty_trigger_interrupt(mdev_state);\n\t\t\t} else if (flags & VFIO_IRQ_SET_DATA_BOOL) {\n\t\t\t\tuint8_t trigger = *(uint8_t *)data;\n\n\t\t\t\tif (trigger)\n\t\t\t\t\tmtty_trigger_interrupt(mdev_state);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase VFIO_PCI_MSI_IRQ_INDEX:\n\t\tswitch (flags & VFIO_IRQ_SET_ACTION_TYPE_MASK) {\n\t\tcase VFIO_IRQ_SET_ACTION_MASK:\n\t\tcase VFIO_IRQ_SET_ACTION_UNMASK:\n\t\t\tret = -ENOTTY;\n\t\t\tbreak;\n\t\tcase VFIO_IRQ_SET_ACTION_TRIGGER:\n\t\t\tif (is_msi(mdev_state) && !count &&\n\t\t\t    (flags & VFIO_IRQ_SET_DATA_NONE)) {\n\t\t\t\tmtty_disable_msi(mdev_state);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (!(is_msi(mdev_state) || is_noirq(mdev_state)) ||\n\t\t\t    start != 0 || count != 1) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (flags & VFIO_IRQ_SET_DATA_EVENTFD) {\n\t\t\t\tint fd = *(int *)data;\n\t\t\t\tstruct eventfd_ctx *evt;\n\n\t\t\t\tmtty_disable_msi(mdev_state);\n\n\t\t\t\tif (fd < 0)\n\t\t\t\t\tbreak;\n\n\t\t\t\tevt = eventfd_ctx_fdget(fd);\n\t\t\t\tif (IS_ERR(evt)) {\n\t\t\t\t\tret = PTR_ERR(evt);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tmdev_state->msi_evtfd = evt;\n\t\t\t\tmdev_state->irq_index = index;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (!is_msi(mdev_state)) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (flags & VFIO_IRQ_SET_DATA_NONE) {\n\t\t\t\tmtty_trigger_interrupt(mdev_state);\n\t\t\t} else if (flags & VFIO_IRQ_SET_DATA_BOOL) {\n\t\t\t\tuint8_t trigger = *(uint8_t *)data;\n\n\t\t\t\tif (trigger)\n\t\t\t\t\tmtty_trigger_interrupt(mdev_state);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase VFIO_PCI_MSIX_IRQ_INDEX:\n\t\tdev_dbg(mdev_state->vdev.dev, \"%s: MSIX_IRQ\\n\", __func__);\n\t\tret = -ENOTTY;\n\t\tbreak;\n\tcase VFIO_PCI_ERR_IRQ_INDEX:\n\t\tdev_dbg(mdev_state->vdev.dev, \"%s: ERR_IRQ\\n\", __func__);\n\t\tret = -ENOTTY;\n\t\tbreak;\n\tcase VFIO_PCI_REQ_IRQ_INDEX:\n\t\tdev_dbg(mdev_state->vdev.dev, \"%s: REQ_IRQ\\n\", __func__);\n\t\tret = -ENOTTY;\n\t\tbreak;\n\t}\n\n\tmutex_unlock(&mdev_state->ops_lock);\n\treturn ret;\n}\n\nstatic int mtty_get_region_info(struct mdev_state *mdev_state,\n\t\t\t struct vfio_region_info *region_info,\n\t\t\t u16 *cap_type_id, void **cap_type)\n{\n\tunsigned int size = 0;\n\tu32 bar_index;\n\n\tbar_index = region_info->index;\n\tif (bar_index >= VFIO_PCI_NUM_REGIONS)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&mdev_state->ops_lock);\n\n\tswitch (bar_index) {\n\tcase VFIO_PCI_CONFIG_REGION_INDEX:\n\t\tsize = MTTY_CONFIG_SPACE_SIZE;\n\t\tbreak;\n\tcase VFIO_PCI_BAR0_REGION_INDEX:\n\t\tsize = MTTY_IO_BAR_SIZE;\n\t\tbreak;\n\tcase VFIO_PCI_BAR1_REGION_INDEX:\n\t\tif (mdev_state->nr_ports == 2)\n\t\t\tsize = MTTY_IO_BAR_SIZE;\n\t\tbreak;\n\tdefault:\n\t\tsize = 0;\n\t\tbreak;\n\t}\n\n\tmdev_state->region_info[bar_index].size = size;\n\tmdev_state->region_info[bar_index].vfio_offset =\n\t\tMTTY_VFIO_PCI_INDEX_TO_OFFSET(bar_index);\n\n\tregion_info->size = size;\n\tregion_info->offset = MTTY_VFIO_PCI_INDEX_TO_OFFSET(bar_index);\n\tregion_info->flags = VFIO_REGION_INFO_FLAG_READ |\n\t\tVFIO_REGION_INFO_FLAG_WRITE;\n\tmutex_unlock(&mdev_state->ops_lock);\n\treturn 0;\n}\n\nstatic int mtty_get_irq_info(struct vfio_irq_info *irq_info)\n{\n\tif (irq_info->index != VFIO_PCI_INTX_IRQ_INDEX &&\n\t    irq_info->index != VFIO_PCI_MSI_IRQ_INDEX)\n\t\treturn -EINVAL;\n\n\tirq_info->flags = VFIO_IRQ_INFO_EVENTFD;\n\tirq_info->count = 1;\n\n\tif (irq_info->index == VFIO_PCI_INTX_IRQ_INDEX)\n\t\tirq_info->flags |= VFIO_IRQ_INFO_MASKABLE |\n\t\t\t\t   VFIO_IRQ_INFO_AUTOMASKED;\n\telse\n\t\tirq_info->flags |= VFIO_IRQ_INFO_NORESIZE;\n\n\treturn 0;\n}\n\nstatic int mtty_get_device_info(struct vfio_device_info *dev_info)\n{\n\tdev_info->flags = VFIO_DEVICE_FLAGS_PCI;\n\tdev_info->num_regions = VFIO_PCI_NUM_REGIONS;\n\tdev_info->num_irqs = VFIO_PCI_NUM_IRQS;\n\n\treturn 0;\n}\n\nstatic long mtty_ioctl(struct vfio_device *vdev, unsigned int cmd,\n\t\t\tunsigned long arg)\n{\n\tstruct mdev_state *mdev_state =\n\t\tcontainer_of(vdev, struct mdev_state, vdev);\n\tint ret = 0;\n\tunsigned long minsz;\n\n\tswitch (cmd) {\n\tcase VFIO_DEVICE_GET_INFO:\n\t{\n\t\tstruct vfio_device_info info;\n\n\t\tminsz = offsetofend(struct vfio_device_info, num_irqs);\n\n\t\tif (copy_from_user(&info, (void __user *)arg, minsz))\n\t\t\treturn -EFAULT;\n\n\t\tif (info.argsz < minsz)\n\t\t\treturn -EINVAL;\n\n\t\tret = mtty_get_device_info(&info);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tmemcpy(&mdev_state->dev_info, &info, sizeof(info));\n\n\t\tif (copy_to_user((void __user *)arg, &info, minsz))\n\t\t\treturn -EFAULT;\n\n\t\treturn 0;\n\t}\n\tcase VFIO_DEVICE_GET_REGION_INFO:\n\t{\n\t\tstruct vfio_region_info info;\n\t\tu16 cap_type_id = 0;\n\t\tvoid *cap_type = NULL;\n\n\t\tminsz = offsetofend(struct vfio_region_info, offset);\n\n\t\tif (copy_from_user(&info, (void __user *)arg, minsz))\n\t\t\treturn -EFAULT;\n\n\t\tif (info.argsz < minsz)\n\t\t\treturn -EINVAL;\n\n\t\tret = mtty_get_region_info(mdev_state, &info, &cap_type_id,\n\t\t\t\t\t   &cap_type);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (copy_to_user((void __user *)arg, &info, minsz))\n\t\t\treturn -EFAULT;\n\n\t\treturn 0;\n\t}\n\n\tcase VFIO_DEVICE_GET_IRQ_INFO:\n\t{\n\t\tstruct vfio_irq_info info;\n\n\t\tminsz = offsetofend(struct vfio_irq_info, count);\n\n\t\tif (copy_from_user(&info, (void __user *)arg, minsz))\n\t\t\treturn -EFAULT;\n\n\t\tif ((info.argsz < minsz) ||\n\t\t    (info.index >= mdev_state->dev_info.num_irqs))\n\t\t\treturn -EINVAL;\n\n\t\tret = mtty_get_irq_info(&info);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (copy_to_user((void __user *)arg, &info, minsz))\n\t\t\treturn -EFAULT;\n\n\t\treturn 0;\n\t}\n\tcase VFIO_DEVICE_SET_IRQS:\n\t{\n\t\tstruct vfio_irq_set hdr;\n\t\tu8 *data = NULL, *ptr = NULL;\n\t\tsize_t data_size = 0;\n\n\t\tminsz = offsetofend(struct vfio_irq_set, count);\n\n\t\tif (copy_from_user(&hdr, (void __user *)arg, minsz))\n\t\t\treturn -EFAULT;\n\n\t\tret = vfio_set_irqs_validate_and_prepare(&hdr,\n\t\t\t\t\t\tmdev_state->dev_info.num_irqs,\n\t\t\t\t\t\tVFIO_PCI_NUM_IRQS,\n\t\t\t\t\t\t&data_size);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (data_size) {\n\t\t\tptr = data = memdup_user((void __user *)(arg + minsz),\n\t\t\t\t\t\t data_size);\n\t\t\tif (IS_ERR(data))\n\t\t\t\treturn PTR_ERR(data);\n\t\t}\n\n\t\tret = mtty_set_irqs(mdev_state, hdr.flags, hdr.index, hdr.start,\n\t\t\t\t    hdr.count, data);\n\n\t\tkfree(ptr);\n\t\treturn ret;\n\t}\n\tcase VFIO_DEVICE_RESET:\n\t\treturn mtty_reset(mdev_state);\n\t}\n\treturn -ENOTTY;\n}\n\nstatic ssize_t\nsample_mdev_dev_show(struct device *dev, struct device_attribute *attr,\n\t\t     char *buf)\n{\n\treturn sprintf(buf, \"This is MDEV %s\\n\", dev_name(dev));\n}\n\nstatic DEVICE_ATTR_RO(sample_mdev_dev);\n\nstatic struct attribute *mdev_dev_attrs[] = {\n\t&dev_attr_sample_mdev_dev.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group mdev_dev_group = {\n\t.name  = \"vendor\",\n\t.attrs = mdev_dev_attrs,\n};\n\nstatic const struct attribute_group *mdev_dev_groups[] = {\n\t&mdev_dev_group,\n\tNULL,\n};\n\nstatic unsigned int mtty_get_available(struct mdev_type *mtype)\n{\n\tstruct mtty_type *type = container_of(mtype, struct mtty_type, type);\n\n\treturn atomic_read(&mdev_avail_ports) / type->nr_ports;\n}\n\nstatic void mtty_close(struct vfio_device *vdev)\n{\n\tstruct mdev_state *mdev_state =\n\t\t\t\tcontainer_of(vdev, struct mdev_state, vdev);\n\n\tmtty_disable_intx(mdev_state);\n\tmtty_disable_msi(mdev_state);\n}\n\nstatic const struct vfio_device_ops mtty_dev_ops = {\n\t.name = \"vfio-mtty\",\n\t.init = mtty_init_dev,\n\t.release = mtty_release_dev,\n\t.read = mtty_read,\n\t.write = mtty_write,\n\t.ioctl = mtty_ioctl,\n\t.bind_iommufd\t= vfio_iommufd_emulated_bind,\n\t.unbind_iommufd\t= vfio_iommufd_emulated_unbind,\n\t.attach_ioas\t= vfio_iommufd_emulated_attach_ioas,\n\t.detach_ioas\t= vfio_iommufd_emulated_detach_ioas,\n\t.close_device\t= mtty_close,\n};\n\nstatic struct mdev_driver mtty_driver = {\n\t.device_api = VFIO_DEVICE_API_PCI_STRING,\n\t.driver = {\n\t\t.name = \"mtty\",\n\t\t.owner = THIS_MODULE,\n\t\t.mod_name = KBUILD_MODNAME,\n\t\t.dev_groups = mdev_dev_groups,\n\t},\n\t.probe = mtty_probe,\n\t.remove\t= mtty_remove,\n\t.get_available = mtty_get_available,\n};\n\nstatic void mtty_device_release(struct device *dev)\n{\n\tdev_dbg(dev, \"mtty: released\\n\");\n}\n\nstatic int __init mtty_dev_init(void)\n{\n\tint ret = 0;\n\n\tpr_info(\"mtty_dev: %s\\n\", __func__);\n\n\tmemset(&mtty_dev, 0, sizeof(mtty_dev));\n\n\tidr_init(&mtty_dev.vd_idr);\n\n\tret = alloc_chrdev_region(&mtty_dev.vd_devt, 0, MINORMASK + 1,\n\t\t\t\t  MTTY_NAME);\n\n\tif (ret < 0) {\n\t\tpr_err(\"Error: failed to register mtty_dev, err:%d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tcdev_init(&mtty_dev.vd_cdev, &vd_fops);\n\tcdev_add(&mtty_dev.vd_cdev, mtty_dev.vd_devt, MINORMASK + 1);\n\n\tpr_info(\"major_number:%d\\n\", MAJOR(mtty_dev.vd_devt));\n\n\tret = mdev_register_driver(&mtty_driver);\n\tif (ret)\n\t\tgoto err_cdev;\n\n\tmtty_dev.vd_class = class_create(MTTY_CLASS_NAME);\n\n\tif (IS_ERR(mtty_dev.vd_class)) {\n\t\tpr_err(\"Error: failed to register mtty_dev class\\n\");\n\t\tret = PTR_ERR(mtty_dev.vd_class);\n\t\tgoto err_driver;\n\t}\n\n\tmtty_dev.dev.class = mtty_dev.vd_class;\n\tmtty_dev.dev.release = mtty_device_release;\n\tdev_set_name(&mtty_dev.dev, \"%s\", MTTY_NAME);\n\n\tret = device_register(&mtty_dev.dev);\n\tif (ret)\n\t\tgoto err_put;\n\n\tret = mdev_register_parent(&mtty_dev.parent, &mtty_dev.dev,\n\t\t\t\t   &mtty_driver, mtty_mdev_types,\n\t\t\t\t   ARRAY_SIZE(mtty_mdev_types));\n\tif (ret)\n\t\tgoto err_device;\n\treturn 0;\n\nerr_device:\n\tdevice_del(&mtty_dev.dev);\nerr_put:\n\tput_device(&mtty_dev.dev);\n\tclass_destroy(mtty_dev.vd_class);\nerr_driver:\n\tmdev_unregister_driver(&mtty_driver);\nerr_cdev:\n\tcdev_del(&mtty_dev.vd_cdev);\n\tunregister_chrdev_region(mtty_dev.vd_devt, MINORMASK + 1);\n\treturn ret;\n}\n\nstatic void __exit mtty_dev_exit(void)\n{\n\tmtty_dev.dev.bus = NULL;\n\tmdev_unregister_parent(&mtty_dev.parent);\n\n\tdevice_unregister(&mtty_dev.dev);\n\tidr_destroy(&mtty_dev.vd_idr);\n\tmdev_unregister_driver(&mtty_driver);\n\tcdev_del(&mtty_dev.vd_cdev);\n\tunregister_chrdev_region(mtty_dev.vd_devt, MINORMASK + 1);\n\tclass_destroy(mtty_dev.vd_class);\n\tmtty_dev.vd_class = NULL;\n\tpr_info(\"mtty_dev: Unloaded!\\n\");\n}\n\nmodule_init(mtty_dev_init)\nmodule_exit(mtty_dev_exit)\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_INFO(supported, \"Test driver that simulate serial port over PCI\");\nMODULE_VERSION(VERSION_STRING);\nMODULE_AUTHOR(DRIVER_AUTHOR);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}