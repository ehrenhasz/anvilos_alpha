{
  "module_name": "fprobe_example.c",
  "hash_id": "b2c96d2e491a400c9821964fef22c5f00f448f89b21afd65f7750b78f21a3373",
  "original_prompt": "Ingested from linux-6.6.14/samples/fprobe/fprobe_example.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"%s: \" fmt, __func__\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/fprobe.h>\n#include <linux/sched/debug.h>\n#include <linux/slab.h>\n\n#define BACKTRACE_DEPTH 16\n#define MAX_SYMBOL_LEN 4096\nstatic struct fprobe sample_probe;\nstatic unsigned long nhit;\n\nstatic char symbol[MAX_SYMBOL_LEN] = \"kernel_clone\";\nmodule_param_string(symbol, symbol, sizeof(symbol), 0644);\nMODULE_PARM_DESC(symbol, \"Probed symbol(s), given by comma separated symbols or a wildcard pattern.\");\n\nstatic char nosymbol[MAX_SYMBOL_LEN] = \"\";\nmodule_param_string(nosymbol, nosymbol, sizeof(nosymbol), 0644);\nMODULE_PARM_DESC(nosymbol, \"Not-probed symbols, given by a wildcard pattern.\");\n\nstatic bool stackdump = true;\nmodule_param(stackdump, bool, 0644);\nMODULE_PARM_DESC(stackdump, \"Enable stackdump.\");\n\nstatic bool use_trace = false;\nmodule_param(use_trace, bool, 0644);\nMODULE_PARM_DESC(use_trace, \"Use trace_printk instead of printk. This is only for debugging.\");\n\nstatic void show_backtrace(void)\n{\n\tunsigned long stacks[BACKTRACE_DEPTH];\n\tunsigned int len;\n\n\tlen = stack_trace_save(stacks, BACKTRACE_DEPTH, 2);\n\tstack_trace_print(stacks, len, 24);\n}\n\nstatic int sample_entry_handler(struct fprobe *fp, unsigned long ip,\n\t\t\t\tunsigned long ret_ip,\n\t\t\t\tstruct pt_regs *regs, void *data)\n{\n\tif (use_trace)\n\t\t \n\t\ttrace_printk(\"Enter <%pS> ip = 0x%p\\n\", (void *)ip, (void *)ip);\n\telse\n\t\tpr_info(\"Enter <%pS> ip = 0x%p\\n\", (void *)ip, (void *)ip);\n\tnhit++;\n\tif (stackdump)\n\t\tshow_backtrace();\n\treturn 0;\n}\n\nstatic void sample_exit_handler(struct fprobe *fp, unsigned long ip,\n\t\t\t\tunsigned long ret_ip, struct pt_regs *regs,\n\t\t\t\tvoid *data)\n{\n\tunsigned long rip = ret_ip;\n\n\tif (use_trace)\n\t\t \n\t\ttrace_printk(\"Return from <%pS> ip = 0x%p to rip = 0x%p (%pS)\\n\",\n\t\t\t(void *)ip, (void *)ip, (void *)rip, (void *)rip);\n\telse\n\t\tpr_info(\"Return from <%pS> ip = 0x%p to rip = 0x%p (%pS)\\n\",\n\t\t\t(void *)ip, (void *)ip, (void *)rip, (void *)rip);\n\tnhit++;\n\tif (stackdump)\n\t\tshow_backtrace();\n}\n\nstatic int __init fprobe_init(void)\n{\n\tchar *p, *symbuf = NULL;\n\tconst char **syms;\n\tint ret, count, i;\n\n\tsample_probe.entry_handler = sample_entry_handler;\n\tsample_probe.exit_handler = sample_exit_handler;\n\n\tif (strchr(symbol, '*')) {\n\t\t \n\t\tret = register_fprobe(&sample_probe, symbol,\n\t\t\t\t      nosymbol[0] == '\\0' ? NULL : nosymbol);\n\t\tgoto out;\n\t} else if (!strchr(symbol, ',')) {\n\t\tsymbuf = symbol;\n\t\tret = register_fprobe_syms(&sample_probe, (const char **)&symbuf, 1);\n\t\tgoto out;\n\t}\n\n\t \n\tsymbuf = kstrdup(symbol, GFP_KERNEL);\n\tif (!symbuf)\n\t\treturn -ENOMEM;\n\tp = symbuf;\n\tcount = 1;\n\twhile ((p = strchr(++p, ',')) != NULL)\n\t\tcount++;\n\n\tpr_info(\"%d symbols found\\n\", count);\n\n\tsyms = kcalloc(count, sizeof(char *), GFP_KERNEL);\n\tif (!syms) {\n\t\tkfree(symbuf);\n\t\treturn -ENOMEM;\n\t}\n\n\tp = symbuf;\n\tfor (i = 0; i < count; i++)\n\t\tsyms[i] = strsep(&p, \",\");\n\n\tret = register_fprobe_syms(&sample_probe, syms, count);\n\tkfree(syms);\n\tkfree(symbuf);\nout:\n\tif (ret < 0)\n\t\tpr_err(\"register_fprobe failed, returned %d\\n\", ret);\n\telse\n\t\tpr_info(\"Planted fprobe at %s\\n\", symbol);\n\n\treturn ret;\n}\n\nstatic void __exit fprobe_exit(void)\n{\n\tunregister_fprobe(&sample_probe);\n\n\tpr_info(\"fprobe at %s unregistered. %ld times hit, %ld times missed\\n\",\n\t\tsymbol, nhit, sample_probe.nmissed);\n}\n\nmodule_init(fprobe_init)\nmodule_exit(fprobe_exit)\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}