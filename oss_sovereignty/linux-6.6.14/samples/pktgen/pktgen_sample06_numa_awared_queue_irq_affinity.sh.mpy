{
  "module_name": "pktgen_sample06_numa_awared_queue_irq_affinity.sh",
  "hash_id": "bba799ad00b4e349ff400be5ed2de062fb73495dd1bc3f306618ab40f88c2eb8",
  "original_prompt": "Ingested from linux-6.6.14/samples/pktgen/pktgen_sample06_numa_awared_queue_irq_affinity.sh",
  "human_readable_source": "#!/bin/bash\n#\n# Multiqueue: Using pktgen threads for sending on multiple CPUs\n#  * adding devices to kernel threads which are in the same NUMA node\n#  * bound devices queue's irq affinity to the threads, 1:1 mapping\n#  * notice the naming scheme for keeping device names unique\n#  * nameing scheme: dev@thread_number\n#  * flow variation via random UDP source port\n#\nbasedir=`dirname $0`\nsource ${basedir}/functions.sh\nroot_check_run_with_sudo \"$@\"\n#\n# Required param: -i dev in $DEV\nsource ${basedir}/parameters.sh\n\n# Trap EXIT first\ntrap_exit\n\n# Base Config\n[ -z \"$COUNT\" ]     && COUNT=\"20000000\"   # Zero means indefinitely\n[ -z \"$CLONE_SKB\" ] && CLONE_SKB=\"0\"\n\n# Flow variation random source port between min and max\nUDP_SRC_MIN=9\nUDP_SRC_MAX=109\n\nnode=`get_iface_node $DEV`\nirq_array=(`get_iface_irqs $DEV`)\ncpu_array=(`get_node_cpus $node`)\n\n[ $THREADS -gt ${#irq_array[*]} -o $THREADS -gt ${#cpu_array[*]}  ] && \\\n\terr 1 \"Thread number $THREADS exceeds: min (${#irq_array[*]},${#cpu_array[*]})\"\n\n# (example of setting default params in your script)\nif [ -z \"$DEST_IP\" ]; then\n    [ -z \"$IP6\" ] && DEST_IP=\"198.18.0.42\" || DEST_IP=\"FD00::1\"\nfi\n[ -z \"$DST_MAC\" ] && DST_MAC=\"90:e2:ba:ff:ff:ff\"\nif [ -n \"$DEST_IP\" ]; then\n    validate_addr${IP6} $DEST_IP\n    read -r DST_MIN DST_MAX <<< $(parse_addr${IP6} $DEST_IP)\nfi\nif [ -n \"$DST_PORT\" ]; then\n    read -r UDP_DST_MIN UDP_DST_MAX <<< $(parse_ports $DST_PORT)\n    validate_ports $UDP_DST_MIN $UDP_DST_MAX\nfi\n\n# General cleanup everything since last run\n[ -z \"$APPEND\" ] && pg_ctrl \"reset\"\n\n# Threads are specified with parameter -t value in $THREADS\nfor ((i = 0; i < $THREADS; i++)); do\n    # The device name is extended with @name, using thread number to\n    # make then unique, but any name will do.\n    # Set the queue's irq affinity to this $thread (processor)\n    # if '-f' is designated, offset cpu id\n    thread=${cpu_array[$((i+F_THREAD))]}\n    dev=${DEV}@${thread}\n    echo $thread > /proc/irq/${irq_array[$i]}/smp_affinity_list\n    info \"irq ${irq_array[$i]} is set affinity to `cat /proc/irq/${irq_array[$i]}/smp_affinity_list`\"\n\n    # Add remove all other devices and add_device $dev to thread\n    [ -z \"$APPEND\" ] && pg_thread $thread \"rem_device_all\"\n    pg_thread $thread \"add_device\" $dev\n\n    # select queue and bind the queue and $dev in 1:1 relationship\n    queue_num=$i\n    info \"queue number is $queue_num\"\n    pg_set $dev \"queue_map_min $queue_num\"\n    pg_set $dev \"queue_map_max $queue_num\"\n\n    # Notice config queue to map to cpu (mirrors smp_processor_id())\n    # It is beneficial to map IRQ /proc/irq/*/smp_affinity 1:1 to CPU number\n    pg_set $dev \"flag QUEUE_MAP_CPU\"\n\n    # Base config of dev\n    pg_set $dev \"count $COUNT\"\n    pg_set $dev \"clone_skb $CLONE_SKB\"\n    pg_set $dev \"pkt_size $PKT_SIZE\"\n    pg_set $dev \"delay $DELAY\"\n\n    # Flag example disabling timestamping\n    pg_set $dev \"flag NO_TIMESTAMP\"\n\n    # Destination\n    pg_set $dev \"dst_mac $DST_MAC\"\n    pg_set $dev \"dst${IP6}_min $DST_MIN\"\n    pg_set $dev \"dst${IP6}_max $DST_MAX\"\n\n    if [ -n \"$DST_PORT\" ]; then\n\t# Single destination port or random port range\n\tpg_set $dev \"flag UDPDST_RND\"\n\tpg_set $dev \"udp_dst_min $UDP_DST_MIN\"\n\tpg_set $dev \"udp_dst_max $UDP_DST_MAX\"\n    fi\n\n    [ ! -z \"$UDP_CSUM\" ] && pg_set $dev \"flag UDPCSUM\"\n\n    # Setup random UDP port src range\n    pg_set $dev \"flag UDPSRC_RND\"\n    pg_set $dev \"udp_src_min $UDP_SRC_MIN\"\n    pg_set $dev \"udp_src_max $UDP_SRC_MAX\"\ndone\n\n# Run if user hits control-c\nfunction print_result() {\n    # Print results\n    for ((i = 0; i < $THREADS; i++)); do\n        thread=${cpu_array[$((i+F_THREAD))]}\n        dev=${DEV}@${thread}\n        echo \"Device: $dev\"\n        cat /proc/net/pktgen/$dev | grep -A2 \"Result:\"\n    done\n}\n# trap keyboard interrupt (Ctrl-C)\ntrap true SIGINT\n\n# start_run\nif [ -z \"$APPEND\" ]; then\n    echo \"Running... ctrl^C to stop\" >&2\n    pg_ctrl \"start\"\n    echo \"Done\" >&2\n\n    print_result\nelse\n    echo \"Append mode: config done. Do more or use 'pg_ctrl start' to run\"\nfi\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}