{
  "module_name": "pktgen_sample04_many_flows.sh",
  "hash_id": "cd23404dd502f85bdfe840e0e04448930f4d62117c58688a5177ab29eb443a42",
  "original_prompt": "Ingested from linux-6.6.14/samples/pktgen/pktgen_sample04_many_flows.sh",
  "human_readable_source": "#!/bin/bash\n# SPDX-License-Identifier: GPL-2.0\n#\n# Script example for many flows testing\n#\n# Number of simultaneous flows limited by variable $FLOWS\n# and number of packets per flow controlled by variable $FLOWLEN\n#\nbasedir=`dirname $0`\nsource ${basedir}/functions.sh\nroot_check_run_with_sudo \"$@\"\n\n# Parameter parsing via include\nsource ${basedir}/parameters.sh\n\n# Trap EXIT first\ntrap_exit\n\n# Set some default params, if they didn't get set\nif [ -z \"$DEST_IP\" ]; then\n    [ -z \"$IP6\" ] && DEST_IP=\"198.18.0.42\" || DEST_IP=\"FD00::1\"\nfi\n[ -z \"$DST_MAC\" ]   && DST_MAC=\"90:e2:ba:ff:ff:ff\"\n[ -z \"$CLONE_SKB\" ] && CLONE_SKB=\"0\"\n[ -z \"$COUNT\" ]     && COUNT=\"0\" # Zero means indefinitely\nif [ -n \"$DEST_IP\" ]; then\n    validate_addr${IP6} $DEST_IP\n    read -r DST_MIN DST_MAX <<< $(parse_addr${IP6} $DEST_IP)\nfi\nif [ -n \"$DST_PORT\" ]; then\n    read -r UDP_DST_MIN UDP_DST_MAX <<< $(parse_ports $DST_PORT)\n    validate_ports $UDP_DST_MIN $UDP_DST_MAX\nfi\n\n# NOTICE:  Script specific settings\n# =======\n# Limiting the number of concurrent flows ($FLOWS)\n# and also set how many packets each flow contains ($FLOWLEN)\n#\n[ -z \"$FLOWS\" ]     && FLOWS=\"8000\"\n[ -z \"$FLOWLEN\" ]   && FLOWLEN=\"10\"\n\nif [[ -n \"$BURST\" ]]; then\n    err 1 \"Bursting not supported for this mode\"\nfi\n\n# 198.18.0.0 / 198.19.255.255\nread -r SRC_MIN SRC_MAX <<< $(parse_addr 198.18.0.0/15)\n\n# General cleanup everything since last run\n[ -z \"$APPEND\" ] && pg_ctrl \"reset\"\n\n# Threads are specified with parameter -t value in $THREADS\nfor ((thread = $F_THREAD; thread <= $L_THREAD; thread++)); do\n    dev=${DEV}@${thread}\n\n    # Add remove all other devices and add_device $dev to thread\n    [ -z \"$APPEND\" ] && pg_thread $thread \"rem_device_all\"\n    pg_thread $thread \"add_device\" $dev\n\n    # Base config\n    pg_set $dev \"flag QUEUE_MAP_CPU\"\n    pg_set $dev \"count $COUNT\"\n    pg_set $dev \"clone_skb $CLONE_SKB\"\n    pg_set $dev \"pkt_size $PKT_SIZE\"\n    pg_set $dev \"delay $DELAY\"\n    pg_set $dev \"flag NO_TIMESTAMP\"\n\n    # Single destination\n    pg_set $dev \"dst_mac $DST_MAC\"\n    pg_set $dev \"dst${IP6}_min $DST_MIN\"\n    pg_set $dev \"dst${IP6}_max $DST_MAX\"\n\n    if [ -n \"$DST_PORT\" ]; then\n\t# Single destination port or random port range\n\tpg_set $dev \"flag UDPDST_RND\"\n\tpg_set $dev \"udp_dst_min $UDP_DST_MIN\"\n\tpg_set $dev \"udp_dst_max $UDP_DST_MAX\"\n    fi\n\n    [ ! -z \"$UDP_CSUM\" ] && pg_set $dev \"flag UDPCSUM\"\n\n    # Randomize source IP-addresses\n    pg_set $dev \"flag IPSRC_RND\"\n    pg_set $dev \"src_min $SRC_MIN\"\n    pg_set $dev \"src_max $SRC_MAX\"\n\n    # Limit number of flows (max 65535)\n    pg_set $dev \"flows $FLOWS\"\n    #\n    # How many packets a flow will send, before flow \"entry\" is\n    # re-generated/setup.\n    pg_set $dev \"flowlen $FLOWLEN\"\n    #\n    # Flag FLOW_SEQ will cause $FLOWLEN packets from the same flow\n    # being send back-to-back, before next flow is selected\n    # incrementally.  This helps lookup caches, and is more realistic.\n    #\n    pg_set $dev \"flag FLOW_SEQ\"\n\ndone\n\n# Run if user hits control-c\nfunction print_result() {\n    # Print results\n    for ((thread = $F_THREAD; thread <= $L_THREAD; thread++)); do\n\tdev=${DEV}@${thread}\n\techo \"Device: $dev\"\n\tcat /proc/net/pktgen/$dev | grep -A2 \"Result:\"\n    done\n}\n# trap keyboard interrupt (Ctrl-C)\ntrap true SIGINT\n\nif [ -z \"$APPEND\" ]; then\n    echo \"Running... ctrl^C to stop\" >&2\n    pg_ctrl \"start\"\n\n    print_result\nelse\n    echo \"Append mode: config done. Do more or use 'pg_ctrl start' to run\"\nfi\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}