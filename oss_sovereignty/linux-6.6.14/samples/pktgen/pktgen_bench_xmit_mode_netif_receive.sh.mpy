{
  "module_name": "pktgen_bench_xmit_mode_netif_receive.sh",
  "hash_id": "c0185a71c876da026e1fd598723886964ded278f9c89dc5e99213225dcf7049f",
  "original_prompt": "Ingested from linux-6.6.14/samples/pktgen/pktgen_bench_xmit_mode_netif_receive.sh",
  "human_readable_source": "#!/bin/bash\n# SPDX-License-Identifier: GPL-2.0\n#\n# Benchmark script:\n#  - developed for benchmarking ingress qdisc path\n#\n# Script for injecting packets into RX path of the stack with pktgen\n# \"xmit_mode netif_receive\".  With an invalid dst_mac this will only\n# measure the ingress code path as packets gets dropped in ip_rcv().\n#\n# This script don't really need any hardware.  It benchmarks software\n# RX path just after NIC driver level.  With bursting is also\n# \"removes\" the SKB alloc/free overhead.\n#\n# Setup scenarios for measuring ingress qdisc (with invalid dst_mac):\n# ------------------------------------------------------------------\n# (1) no ingress (uses static_key_false(&ingress_needed))\n#\n# (2) ingress on other dev (change ingress_needed and calls\n#     handle_ing() but exit early)\n#\n#  config:  tc qdisc add dev $SOMEDEV handle ffff: ingress\n#\n# (3) ingress on this dev, handle_ing() -> tc_classify()\n#\n#  config:  tc qdisc add dev $DEV handle ffff: ingress\n#\n# (4) ingress on this dev + drop at u32 classifier/action.\n#\nbasedir=`dirname $0`\nsource ${basedir}/functions.sh\nroot_check_run_with_sudo \"$@\"\n\n# Parameter parsing via include\nsource ${basedir}/parameters.sh\n\n# Trap EXIT first\ntrap_exit\n\n# Using invalid DST_MAC will cause the packets to get dropped in\n# ip_rcv() which is part of the test\nif [ -z \"$DEST_IP\" ]; then\n    [ -z \"$IP6\" ] && DEST_IP=\"198.18.0.42\" || DEST_IP=\"FD00::1\"\nfi\n[ -z \"$DST_MAC\" ] && DST_MAC=\"90:e2:ba:ff:ff:ff\"\n[ -z \"$BURST\" ] && BURST=1024\n[ -z \"$COUNT\" ] && COUNT=\"10000000\" # Zero means indefinitely\nif [ -n \"$DEST_IP\" ]; then\n    validate_addr${IP6} $DEST_IP\n    read -r DST_MIN DST_MAX <<< $(parse_addr${IP6} $DEST_IP)\nfi\nif [ -n \"$DST_PORT\" ]; then\n    read -r UDP_DST_MIN UDP_DST_MAX <<< $(parse_ports $DST_PORT)\n    validate_ports $UDP_DST_MIN $UDP_DST_MAX\nfi\n\n# General cleanup everything since last run\npg_ctrl \"reset\"\n\n# Threads are specified with parameter -t value in $THREADS\nfor ((thread = $F_THREAD; thread <= $L_THREAD; thread++)); do\n    # The device name is extended with @name, using thread number to\n    # make then unique, but any name will do.\n    dev=${DEV}@${thread}\n\n    # Add remove all other devices and add_device $dev to thread\n    pg_thread $thread \"rem_device_all\"\n    pg_thread $thread \"add_device\" $dev\n\n    # Base config of dev\n    pg_set $dev \"flag QUEUE_MAP_CPU\"\n    pg_set $dev \"count $COUNT\"\n    pg_set $dev \"pkt_size $PKT_SIZE\"\n    pg_set $dev \"delay $DELAY\"\n    pg_set $dev \"flag NO_TIMESTAMP\"\n\n    # Destination\n    pg_set $dev \"dst_mac $DST_MAC\"\n    pg_set $dev \"dst${IP6}_min $DST_MIN\"\n    pg_set $dev \"dst${IP6}_max $DST_MAX\"\n\n    if [ -n \"$DST_PORT\" ]; then\n\t# Single destination port or random port range\n\tpg_set $dev \"flag UDPDST_RND\"\n\tpg_set $dev \"udp_dst_min $UDP_DST_MIN\"\n\tpg_set $dev \"udp_dst_max $UDP_DST_MAX\"\n    fi\n\n    # Inject packet into RX path of stack\n    pg_set $dev \"xmit_mode netif_receive\"\n\n    # Burst allow us to avoid measuring SKB alloc/free overhead\n    pg_set $dev \"burst $BURST\"\ndone\n\n# Run if user hits control-c\nfunction print_result() {\n    # Print results\n    for ((thread = $F_THREAD; thread <= $L_THREAD; thread++)); do\n        dev=${DEV}@${thread}\n        echo \"Device: $dev\"\n        cat /proc/net/pktgen/$dev | grep -A2 \"Result:\"\n    done\n}\n# trap keyboard interrupt (Ctrl-C)\ntrap true SIGINT\n\n# start_run\necho \"Running... ctrl^C to stop\" >&2\npg_ctrl \"start\"\necho \"Done\" >&2\n\nprint_result\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}