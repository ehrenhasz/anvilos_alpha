{
  "module_name": "functions.sh",
  "hash_id": "40218864a01bd16fa9193838b774f5f56e14996136ef190cd5cb93bbcf2ba7f9",
  "original_prompt": "Ingested from linux-6.6.14/samples/pktgen/functions.sh",
  "human_readable_source": "#\n# Common functions used by pktgen scripts\n#  - Depending on bash 3 (or higher) syntax\n#\n# Author: Jesper Dangaaard Brouer\n# License: GPL\n\nset -o errexit\n\n## -- General shell logging cmds --\nfunction err() {\n    local exitcode=$1\n    shift\n    echo \"ERROR: $@\" >&2\n    exit $exitcode\n}\n\nfunction warn() {\n    echo \"WARN : $@\" >&2\n}\n\nfunction info() {\n    if [[ -n \"$VERBOSE\" ]]; then\n\techo \"INFO : $@\" >&2\n    fi\n}\n\n## -- Pktgen proc config commands -- ##\nexport PROC_DIR=/proc/net/pktgen\n#\n# Three different shell functions for configuring the different\n# components of pktgen:\n#   pg_ctrl(), pg_thread() and pg_set().\n#\n# These functions correspond to pktgens different components.\n# * pg_ctrl()   control \"pgctrl\" (/proc/net/pktgen/pgctrl)\n# * pg_thread() control the kernel threads and binding to devices\n# * pg_set()    control setup of individual devices\nfunction pg_ctrl() {\n    local proc_file=\"pgctrl\"\n    proc_cmd ${proc_file} \"$@\"\n}\n\nfunction pg_thread() {\n    local thread=$1\n    local proc_file=\"kpktgend_${thread}\"\n    shift\n    proc_cmd ${proc_file} \"$@\"\n}\n\nfunction pg_set() {\n    local dev=$1\n    local proc_file=\"$dev\"\n    shift\n    proc_cmd ${proc_file} \"$@\"\n}\n\n# More generic replacement for pgset(), that does not depend on global\n# variable for proc file.\nfunction proc_cmd() {\n    local result\n    local proc_file=$1\n    local status=0\n    # after shift, the remaining args are contained in $@\n    shift\n    local proc_ctrl=${PROC_DIR}/$proc_file\n    if [[ ! -e \"$proc_ctrl\" ]]; then\n\terr 3 \"proc file:$proc_ctrl does not exists (dev added to thread?)\"\n    else\n\tif [[ ! -w \"$proc_ctrl\" ]]; then\n\t    err 4 \"proc file:$proc_ctrl not writable, not root?!\"\n\tfi\n    fi\n\n    if [[ \"$DEBUG\" == \"yes\" ]]; then\n\techo \"cmd: $@ > $proc_ctrl\"\n    fi\n    # Quoting of \"$@\" is important for space expansion\n    echo \"$@\" > \"$proc_ctrl\" || status=$?\n\n    if [[ \"$proc_file\" != \"pgctrl\" ]]; then\n        result=$(grep \"Result: OK:\" $proc_ctrl) || true\n        if [[ \"$result\" == \"\" ]]; then\n            grep \"Result:\" $proc_ctrl >&2\n        fi\n    fi\n    if (( $status != 0 )); then\n\terr 5 \"Write error($status) occurred cmd: \\\"$@ > $proc_ctrl\\\"\"\n    fi\n}\n\n# Old obsolete \"pgset\" function, with slightly improved err handling\nfunction pgset() {\n    local result\n\n    if [[ \"$DEBUG\" == \"yes\" ]]; then\n\techo \"cmd: $1 > $PGDEV\"\n    fi\n    echo $1 > $PGDEV\n    local status=$?\n\n    result=`cat $PGDEV | fgrep \"Result: OK:\"`\n    if [[ \"$result\" == \"\" ]]; then\n         cat $PGDEV | fgrep Result:\n    fi\n    if (( $status != 0 )); then\n\terr 5 \"Write error($status) occurred cmd: \\\"$1 > $PGDEV\\\"\"\n    fi\n}\n\nfunction trap_exit()\n{\n    # Cleanup pktgen setup on exit if thats not \"append mode\"\n    if [[ -z \"$APPEND\" ]] && [[ $EUID -eq 0 ]]; then\n        trap 'pg_ctrl \"reset\"' EXIT\n    fi\n}\n\n## -- General shell tricks --\n\nfunction root_check_run_with_sudo() {\n    # Trick so, program can be run as normal user, will just use \"sudo\"\n    #  call as root_check_run_as_sudo \"$@\"\n    if [ \"$EUID\" -ne 0 ]; then\n\tif [ -x $0 ]; then # Directly executable use sudo\n\t    info \"Not root, running with sudo\"\n            sudo -E \"$0\" \"$@\"\n            exit $?\n\tfi\n\terr 4 \"cannot perform sudo run of $0\"\n    fi\n}\n\n# Exact input device's NUMA node info\nfunction get_iface_node()\n{\n    local node=$(</sys/class/net/$1/device/numa_node)\n    if [[ $node == -1 ]]; then\n        echo 0\n    else\n        echo $node\n    fi\n}\n\n# Given an Dev/iface, get its queues' irq numbers\nfunction get_iface_irqs()\n{\n\tlocal IFACE=$1\n\tlocal queues=\"${IFACE}-.*TxRx\"\n\n\tirqs=$(grep \"$queues\" /proc/interrupts | cut -f1 -d:)\n\t[ -z \"$irqs\" ] && irqs=$(grep $IFACE /proc/interrupts | cut -f1 -d:)\n\t[ -z \"$irqs\" ] && irqs=$(for i in `ls -Ux /sys/class/net/$IFACE/device/msi_irqs` ;\\\n\t    do grep \"$i:.*TxRx\" /proc/interrupts | grep -v fdir | cut -f 1 -d : ;\\\n\t    done)\n\t[ -z \"$irqs\" ] && err 3 \"Could not find interrupts for $IFACE\"\n\n\techo $irqs\n}\n\n# Given a NUMA node, return cpu ids belonging to it.\nfunction get_node_cpus()\n{\n\tlocal node=$1\n\tlocal node_cpu_list\n\tlocal node_cpu_range_list=`cut -f1- -d, --output-delimiter=\" \" \\\n\t                  /sys/devices/system/node/node$node/cpulist`\n\n\tfor cpu_range in $node_cpu_range_list\n\tdo\n\t    node_cpu_list=\"$node_cpu_list \"`seq -s \" \" ${cpu_range//-/ }`\n\tdone\n\n\techo $node_cpu_list\n}\n\n# Check $1 is in between $2, $3 ($2 <= $1 <= $3)\nfunction in_between() { [[ ($1 -ge $2) && ($1 -le $3) ]] ; }\n\n# Extend shrunken IPv6 address.\n# fe80::42:bcff:fe84:e10a => fe80:0:0:0:42:bcff:fe84:e10a\nfunction extend_addr6()\n{\n    local addr=$1\n    local sep=: sep2=::\n    local sep_cnt=$(tr -cd $sep <<< $1 | wc -c)\n    local shrink\n\n    # separator count should be (2 <= $sep_cnt <= 7)\n    if ! (in_between $sep_cnt 2 7); then\n        err 5 \"Invalid IP6 address: $1\"\n    fi\n\n    # if shrink '::' occurs multiple, it's malformed.\n    shrink=( $(grep -E -o \"$sep{2,}\" <<< $addr) )\n    if [[ ${#shrink[@]} -ne 0 ]]; then\n        if [[ ${#shrink[@]} -gt 1 || ( ${shrink[0]} != $sep2 ) ]]; then\n            err 5 \"Invalid IP6 address: $1\"\n        fi\n    fi\n\n    # add 0 at begin & end, and extend addr by adding :0\n    [[ ${addr:0:1} == $sep ]] && addr=0${addr}\n    [[ ${addr: -1} == $sep ]] && addr=${addr}0\n    echo \"${addr/$sep2/$(printf ':0%.s' $(seq $[8-sep_cnt])):}\"\n}\n\n# Given a single IP(v4/v6) address, whether it is valid.\nfunction validate_addr()\n{\n    # check function is called with (funcname)6\n    [[ ${FUNCNAME[1]: -1} == 6 ]] && local IP6=6\n    local bitlen=$[ IP6 ? 128 : 32 ]\n    local len=$[ IP6 ? 8 : 4 ]\n    local max=$[ 2**(len*2)-1 ]\n    local net prefix\n    local addr sep\n\n    IFS='/' read net prefix <<< $1\n    [[ $IP6 ]] && net=$(extend_addr6 $net)\n\n    # if prefix exists, check (0 <= $prefix <= $bitlen)\n    if [[ -n $prefix ]]; then\n        if ! (in_between $prefix 0 $bitlen); then\n            err 5 \"Invalid prefix: /$prefix\"\n        fi\n    fi\n\n    # set separator for each IP(v4/v6)\n    [[ $IP6 ]] && sep=: || sep=.\n    IFS=$sep read -a addr <<< $net\n\n    # array length\n    if [[ ${#addr[@]} != $len ]]; then\n        err 5 \"Invalid IP$IP6 address: $1\"\n    fi\n\n    # check each digit (0 <= $digit <= $max)\n    for digit in \"${addr[@]}\"; do\n        [[ $IP6 ]] && digit=$[ 16#$digit ]\n        if ! (in_between $digit 0 $max); then\n            err 5 \"Invalid IP$IP6 address: $1\"\n        fi\n    done\n\n    return 0\n}\n\nfunction validate_addr6() { validate_addr $@ ; }\n\n# Given a single IP(v4/v6) or CIDR, return minimum and maximum IP addr.\nfunction parse_addr()\n{\n    # check function is called with (funcname)6\n    [[ ${FUNCNAME[1]: -1} == 6 ]] && local IP6=6\n    local net prefix\n    local min_ip max_ip\n\n    IFS='/' read net prefix <<< $1\n    [[ $IP6 ]] && net=$(extend_addr6 $net)\n\n    if [[ -z $prefix ]]; then\n        min_ip=$net\n        max_ip=$net\n    else\n        # defining array for converting Decimal 2 Binary\n        # 00000000 00000001 00000010 00000011 00000100 ...\n        local d2b='{0..1}{0..1}{0..1}{0..1}{0..1}{0..1}{0..1}{0..1}'\n        [[ $IP6 ]] && d2b+=$d2b\n        eval local D2B=($d2b)\n\n        local bitlen=$[ IP6 ? 128 : 32 ]\n        local remain=$[ bitlen-prefix ]\n        local octet=$[ IP6 ? 16 : 8 ]\n        local min_mask max_mask\n        local min max\n        local ip_bit\n        local ip sep\n\n        # set separator for each IP(v4/v6)\n        [[ $IP6 ]] && sep=: || sep=.\n        IFS=$sep read -ra ip <<< $net\n\n        min_mask=\"$(printf '1%.s' $(seq $prefix))$(printf '0%.s' $(seq $remain))\"\n        max_mask=\"$(printf '0%.s' $(seq $prefix))$(printf '1%.s' $(seq $remain))\"\n\n        # calculate min/max ip with &,| operator\n        for i in \"${!ip[@]}\"; do\n            digit=$[ IP6 ? 16#${ip[$i]} : ${ip[$i]} ]\n            ip_bit=${D2B[$digit]}\n\n            idx=$[ octet*i ]\n            min[$i]=$[ 2#$ip_bit & 2#${min_mask:$idx:$octet} ]\n            max[$i]=$[ 2#$ip_bit | 2#${max_mask:$idx:$octet} ]\n            [[ $IP6 ]] && { min[$i]=$(printf '%X' ${min[$i]});\n                            max[$i]=$(printf '%X' ${max[$i]}); }\n        done\n\n        min_ip=$(IFS=$sep; echo \"${min[*]}\")\n        max_ip=$(IFS=$sep; echo \"${max[*]}\")\n    fi\n\n    echo $min_ip $max_ip\n}\n\nfunction parse_addr6() { parse_addr $@ ; }\n\n# Given a single or range of port(s), return minimum and maximum port number.\nfunction parse_ports()\n{\n    local port_str=$1\n    local port_list\n    local min_port\n    local max_port\n\n    IFS=\"-\" read -ra port_list <<< $port_str\n\n    min_port=${port_list[0]}\n    max_port=${port_list[1]:-$min_port}\n\n    echo $min_port $max_port\n}\n\n# Given a minimum and maximum port, verify port number.\nfunction validate_ports()\n{\n    local min_port=$1\n    local max_port=$2\n\n    # 1 <= port <= 65535\n    if (in_between $min_port 1 65535); then\n\tif (in_between $max_port 1 65535); then\n\t    if [[ $min_port -le $max_port ]]; then\n\t\treturn 0\n\t    fi\n\tfi\n    fi\n\n    err 5 \"Invalid port(s): $min_port-$max_port\"\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}