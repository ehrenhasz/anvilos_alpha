{
  "module_name": "qmi_sample_client.c",
  "hash_id": "9af9cfd92be3695f2f422123086fb8d501b10d578f73bf59854b27b8c352c32f",
  "original_prompt": "Ingested from linux-6.6.14/samples/qmi/qmi_sample_client.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/debugfs.h>\n#include <linux/device.h>\n#include <linux/platform_device.h>\n#include <linux/qrtr.h>\n#include <linux/net.h>\n#include <linux/completion.h>\n#include <linux/idr.h>\n#include <linux/string.h>\n#include <net/sock.h>\n#include <linux/soc/qcom/qmi.h>\n\n#define PING_REQ1_TLV_TYPE\t\t0x1\n#define PING_RESP1_TLV_TYPE\t\t0x2\n#define PING_OPT1_TLV_TYPE\t\t0x10\n#define PING_OPT2_TLV_TYPE\t\t0x11\n\n#define DATA_REQ1_TLV_TYPE\t\t0x1\n#define DATA_RESP1_TLV_TYPE\t\t0x2\n#define DATA_OPT1_TLV_TYPE\t\t0x10\n#define DATA_OPT2_TLV_TYPE\t\t0x11\n\n#define TEST_MED_DATA_SIZE_V01\t\t8192\n#define TEST_MAX_NAME_SIZE_V01\t\t255\n\n#define TEST_PING_REQ_MSG_ID_V01\t0x20\n#define TEST_DATA_REQ_MSG_ID_V01\t0x21\n\n#define TEST_PING_REQ_MAX_MSG_LEN_V01\t266\n#define TEST_DATA_REQ_MAX_MSG_LEN_V01\t8456\n\nstruct test_name_type_v01 {\n\tu32 name_len;\n\tchar name[TEST_MAX_NAME_SIZE_V01];\n};\n\nstatic const struct qmi_elem_info test_name_type_v01_ei[] = {\n\t{\n\t\t.data_type\t= QMI_DATA_LEN,\n\t\t.elem_len\t= 1,\n\t\t.elem_size\t= sizeof(u8),\n\t\t.array_type\t= NO_ARRAY,\n\t\t.tlv_type\t= QMI_COMMON_TLV_TYPE,\n\t\t.offset\t\t= offsetof(struct test_name_type_v01,\n\t\t\t\t\t   name_len),\n\t},\n\t{\n\t\t.data_type\t= QMI_UNSIGNED_1_BYTE,\n\t\t.elem_len\t= TEST_MAX_NAME_SIZE_V01,\n\t\t.elem_size\t= sizeof(char),\n\t\t.array_type\t= VAR_LEN_ARRAY,\n\t\t.tlv_type\t= QMI_COMMON_TLV_TYPE,\n\t\t.offset\t\t= offsetof(struct test_name_type_v01,\n\t\t\t\t\t   name),\n\t},\n\t{}\n};\n\nstruct test_ping_req_msg_v01 {\n\tchar ping[4];\n\n\tu8 client_name_valid;\n\tstruct test_name_type_v01 client_name;\n};\n\nstatic const struct qmi_elem_info test_ping_req_msg_v01_ei[] = {\n\t{\n\t\t.data_type\t= QMI_UNSIGNED_1_BYTE,\n\t\t.elem_len\t= 4,\n\t\t.elem_size\t= sizeof(char),\n\t\t.array_type\t= STATIC_ARRAY,\n\t\t.tlv_type\t= PING_REQ1_TLV_TYPE,\n\t\t.offset\t\t= offsetof(struct test_ping_req_msg_v01,\n\t\t\t\t\t   ping),\n\t},\n\t{\n\t\t.data_type\t= QMI_OPT_FLAG,\n\t\t.elem_len\t= 1,\n\t\t.elem_size\t= sizeof(u8),\n\t\t.array_type\t= NO_ARRAY,\n\t\t.tlv_type\t= PING_OPT1_TLV_TYPE,\n\t\t.offset\t\t= offsetof(struct test_ping_req_msg_v01,\n\t\t\t\t\t   client_name_valid),\n\t},\n\t{\n\t\t.data_type\t= QMI_STRUCT,\n\t\t.elem_len\t= 1,\n\t\t.elem_size\t= sizeof(struct test_name_type_v01),\n\t\t.array_type\t= NO_ARRAY,\n\t\t.tlv_type\t= PING_OPT1_TLV_TYPE,\n\t\t.offset\t\t= offsetof(struct test_ping_req_msg_v01,\n\t\t\t\t\t   client_name),\n\t\t.ei_array\t= test_name_type_v01_ei,\n\t},\n\t{}\n};\n\nstruct test_ping_resp_msg_v01 {\n\tstruct qmi_response_type_v01 resp;\n\n\tu8 pong_valid;\n\tchar pong[4];\n\n\tu8 service_name_valid;\n\tstruct test_name_type_v01 service_name;\n};\n\nstatic const struct qmi_elem_info test_ping_resp_msg_v01_ei[] = {\n\t{\n\t\t.data_type\t= QMI_STRUCT,\n\t\t.elem_len\t= 1,\n\t\t.elem_size\t= sizeof(struct qmi_response_type_v01),\n\t\t.array_type\t= NO_ARRAY,\n\t\t.tlv_type\t= PING_RESP1_TLV_TYPE,\n\t\t.offset\t\t= offsetof(struct test_ping_resp_msg_v01,\n\t\t\t\t\t   resp),\n\t\t.ei_array\t= qmi_response_type_v01_ei,\n\t},\n\t{\n\t\t.data_type\t= QMI_OPT_FLAG,\n\t\t.elem_len\t= 1,\n\t\t.elem_size\t= sizeof(u8),\n\t\t.array_type\t= NO_ARRAY,\n\t\t.tlv_type\t= PING_OPT1_TLV_TYPE,\n\t\t.offset\t\t= offsetof(struct test_ping_resp_msg_v01,\n\t\t\t\t\t   pong_valid),\n\t},\n\t{\n\t\t.data_type\t= QMI_UNSIGNED_1_BYTE,\n\t\t.elem_len\t= 4,\n\t\t.elem_size\t= sizeof(char),\n\t\t.array_type\t= STATIC_ARRAY,\n\t\t.tlv_type\t= PING_OPT1_TLV_TYPE,\n\t\t.offset\t\t= offsetof(struct test_ping_resp_msg_v01,\n\t\t\t\t\t   pong),\n\t},\n\t{\n\t\t.data_type\t= QMI_OPT_FLAG,\n\t\t.elem_len\t= 1,\n\t\t.elem_size\t= sizeof(u8),\n\t\t.array_type\t= NO_ARRAY,\n\t\t.tlv_type\t= PING_OPT2_TLV_TYPE,\n\t\t.offset\t\t= offsetof(struct test_ping_resp_msg_v01,\n\t\t\t\t\t   service_name_valid),\n\t},\n\t{\n\t\t.data_type\t= QMI_STRUCT,\n\t\t.elem_len\t= 1,\n\t\t.elem_size\t= sizeof(struct test_name_type_v01),\n\t\t.array_type\t= NO_ARRAY,\n\t\t.tlv_type\t= PING_OPT2_TLV_TYPE,\n\t\t.offset\t\t= offsetof(struct test_ping_resp_msg_v01,\n\t\t\t\t\t   service_name),\n\t\t.ei_array\t= test_name_type_v01_ei,\n\t},\n\t{}\n};\n\nstruct test_data_req_msg_v01 {\n\tu32 data_len;\n\tu8 data[TEST_MED_DATA_SIZE_V01];\n\n\tu8 client_name_valid;\n\tstruct test_name_type_v01 client_name;\n};\n\nstatic const struct qmi_elem_info test_data_req_msg_v01_ei[] = {\n\t{\n\t\t.data_type\t= QMI_DATA_LEN,\n\t\t.elem_len\t= 1,\n\t\t.elem_size\t= sizeof(u32),\n\t\t.array_type\t= NO_ARRAY,\n\t\t.tlv_type\t= DATA_REQ1_TLV_TYPE,\n\t\t.offset\t\t= offsetof(struct test_data_req_msg_v01,\n\t\t\t\t\t   data_len),\n\t},\n\t{\n\t\t.data_type\t= QMI_UNSIGNED_1_BYTE,\n\t\t.elem_len\t= TEST_MED_DATA_SIZE_V01,\n\t\t.elem_size\t= sizeof(u8),\n\t\t.array_type\t= VAR_LEN_ARRAY,\n\t\t.tlv_type\t= DATA_REQ1_TLV_TYPE,\n\t\t.offset\t\t= offsetof(struct test_data_req_msg_v01,\n\t\t\t\t\t   data),\n\t},\n\t{\n\t\t.data_type\t= QMI_OPT_FLAG,\n\t\t.elem_len\t= 1,\n\t\t.elem_size\t= sizeof(u8),\n\t\t.array_type\t= NO_ARRAY,\n\t\t.tlv_type\t= DATA_OPT1_TLV_TYPE,\n\t\t.offset\t\t= offsetof(struct test_data_req_msg_v01,\n\t\t\t\t\t   client_name_valid),\n\t},\n\t{\n\t\t.data_type\t= QMI_STRUCT,\n\t\t.elem_len\t= 1,\n\t\t.elem_size\t= sizeof(struct test_name_type_v01),\n\t\t.array_type\t= NO_ARRAY,\n\t\t.tlv_type\t= DATA_OPT1_TLV_TYPE,\n\t\t.offset\t\t= offsetof(struct test_data_req_msg_v01,\n\t\t\t\t\t   client_name),\n\t\t.ei_array\t= test_name_type_v01_ei,\n\t},\n\t{}\n};\n\nstruct test_data_resp_msg_v01 {\n\tstruct qmi_response_type_v01 resp;\n\n\tu8 data_valid;\n\tu32 data_len;\n\tu8 data[TEST_MED_DATA_SIZE_V01];\n\n\tu8 service_name_valid;\n\tstruct test_name_type_v01 service_name;\n};\n\nstatic const struct qmi_elem_info test_data_resp_msg_v01_ei[] = {\n\t{\n\t\t.data_type\t= QMI_STRUCT,\n\t\t.elem_len\t= 1,\n\t\t.elem_size\t= sizeof(struct qmi_response_type_v01),\n\t\t.array_type\t= NO_ARRAY,\n\t\t.tlv_type\t= DATA_RESP1_TLV_TYPE,\n\t\t.offset\t\t= offsetof(struct test_data_resp_msg_v01,\n\t\t\t\t\t   resp),\n\t\t.ei_array\t= qmi_response_type_v01_ei,\n\t},\n\t{\n\t\t.data_type\t= QMI_OPT_FLAG,\n\t\t.elem_len\t= 1,\n\t\t.elem_size\t= sizeof(u8),\n\t\t.array_type\t= NO_ARRAY,\n\t\t.tlv_type\t= DATA_OPT1_TLV_TYPE,\n\t\t.offset\t\t= offsetof(struct test_data_resp_msg_v01,\n\t\t\t\t\t   data_valid),\n\t},\n\t{\n\t\t.data_type\t= QMI_DATA_LEN,\n\t\t.elem_len\t= 1,\n\t\t.elem_size\t= sizeof(u32),\n\t\t.array_type\t= NO_ARRAY,\n\t\t.tlv_type\t= DATA_OPT1_TLV_TYPE,\n\t\t.offset\t\t= offsetof(struct test_data_resp_msg_v01,\n\t\t\t\t\t   data_len),\n\t},\n\t{\n\t\t.data_type\t= QMI_UNSIGNED_1_BYTE,\n\t\t.elem_len\t= TEST_MED_DATA_SIZE_V01,\n\t\t.elem_size\t= sizeof(u8),\n\t\t.array_type\t= VAR_LEN_ARRAY,\n\t\t.tlv_type\t= DATA_OPT1_TLV_TYPE,\n\t\t.offset\t\t= offsetof(struct test_data_resp_msg_v01,\n\t\t\t\t\t   data),\n\t},\n\t{\n\t\t.data_type\t= QMI_OPT_FLAG,\n\t\t.elem_len\t= 1,\n\t\t.elem_size\t= sizeof(u8),\n\t\t.array_type\t= NO_ARRAY,\n\t\t.tlv_type\t= DATA_OPT2_TLV_TYPE,\n\t\t.offset\t\t= offsetof(struct test_data_resp_msg_v01,\n\t\t\t\t\t   service_name_valid),\n\t},\n\t{\n\t\t.data_type\t= QMI_STRUCT,\n\t\t.elem_len\t= 1,\n\t\t.elem_size\t= sizeof(struct test_name_type_v01),\n\t\t.array_type\t= NO_ARRAY,\n\t\t.tlv_type\t= DATA_OPT2_TLV_TYPE,\n\t\t.offset\t\t= offsetof(struct test_data_resp_msg_v01,\n\t\t\t\t\t   service_name),\n\t\t.ei_array\t= test_name_type_v01_ei,\n\t},\n\t{}\n};\n\n \nstatic ssize_t ping_write(struct file *file, const char __user *user_buf,\n\t\t\t  size_t count, loff_t *ppos)\n{\n\tstruct qmi_handle *qmi = file->private_data;\n\tstruct test_ping_req_msg_v01 req = {};\n\tstruct qmi_txn txn;\n\tint ret;\n\n\tmemcpy(req.ping, \"ping\", sizeof(req.ping));\n\n\tret = qmi_txn_init(qmi, &txn, NULL, NULL);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = qmi_send_request(qmi, NULL, &txn,\n\t\t\t       TEST_PING_REQ_MSG_ID_V01,\n\t\t\t       TEST_PING_REQ_MAX_MSG_LEN_V01,\n\t\t\t       test_ping_req_msg_v01_ei, &req);\n\tif (ret < 0) {\n\t\tqmi_txn_cancel(&txn);\n\t\treturn ret;\n\t}\n\n\tret = qmi_txn_wait(&txn, 5 * HZ);\n\tif (ret < 0)\n\t\tcount = ret;\n\n\treturn count;\n}\n\nstatic const struct file_operations ping_fops = {\n\t.open = simple_open,\n\t.write = ping_write,\n};\n\nstatic void ping_pong_cb(struct qmi_handle *qmi, struct sockaddr_qrtr *sq,\n\t\t\t struct qmi_txn *txn, const void *data)\n{\n\tconst struct test_ping_resp_msg_v01 *resp = data;\n\n\tif (!txn) {\n\t\tpr_err(\"spurious ping response\\n\");\n\t\treturn;\n\t}\n\n\tif (resp->resp.result == QMI_RESULT_FAILURE_V01)\n\t\ttxn->result = -ENXIO;\n\telse if (!resp->pong_valid || memcmp(resp->pong, \"pong\", 4))\n\t\ttxn->result = -EINVAL;\n\n\tcomplete(&txn->completion);\n}\n\n \nstatic ssize_t data_write(struct file *file, const char __user *user_buf,\n\t\t\t  size_t count, loff_t *ppos)\n\n{\n\tstruct qmi_handle *qmi = file->private_data;\n\tstruct test_data_resp_msg_v01 *resp;\n\tstruct test_data_req_msg_v01 *req;\n\tstruct qmi_txn txn;\n\tint ret;\n\n\treq = kzalloc(sizeof(*req), GFP_KERNEL);\n\tif (!req)\n\t\treturn -ENOMEM;\n\n\tresp = kzalloc(sizeof(*resp), GFP_KERNEL);\n\tif (!resp) {\n\t\tkfree(req);\n\t\treturn -ENOMEM;\n\t}\n\n\treq->data_len = min_t(size_t, sizeof(req->data), count);\n\tif (copy_from_user(req->data, user_buf, req->data_len)) {\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tret = qmi_txn_init(qmi, &txn, test_data_resp_msg_v01_ei, resp);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = qmi_send_request(qmi, NULL, &txn,\n\t\t\t       TEST_DATA_REQ_MSG_ID_V01,\n\t\t\t       TEST_DATA_REQ_MAX_MSG_LEN_V01,\n\t\t\t       test_data_req_msg_v01_ei, req);\n\tif (ret < 0) {\n\t\tqmi_txn_cancel(&txn);\n\t\tgoto out;\n\t}\n\n\tret = qmi_txn_wait(&txn, 5 * HZ);\n\tif (ret < 0) {\n\t\tgoto out;\n\t} else if (!resp->data_valid ||\n\t\t   resp->data_len != req->data_len ||\n\t\t   memcmp(resp->data, req->data, req->data_len)) {\n\t\tpr_err(\"response data doesn't match expectation\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tret = count;\n\nout:\n\tkfree(resp);\n\tkfree(req);\n\n\treturn ret;\n}\n\nstatic const struct file_operations data_fops = {\n\t.open = simple_open,\n\t.write = data_write,\n};\n\nstatic const struct qmi_msg_handler qmi_sample_handlers[] = {\n\t{\n\t\t.type = QMI_RESPONSE,\n\t\t.msg_id = TEST_PING_REQ_MSG_ID_V01,\n\t\t.ei = test_ping_resp_msg_v01_ei,\n\t\t.decoded_size = sizeof(struct test_ping_req_msg_v01),\n\t\t.fn = ping_pong_cb\n\t},\n\t{}\n};\n\nstruct qmi_sample {\n\tstruct qmi_handle qmi;\n\n\tstruct dentry *de_dir;\n\tstruct dentry *de_data;\n\tstruct dentry *de_ping;\n};\n\nstatic struct dentry *qmi_debug_dir;\n\nstatic int qmi_sample_probe(struct platform_device *pdev)\n{\n\tstruct sockaddr_qrtr *sq;\n\tstruct qmi_sample *sample;\n\tchar path[20];\n\tint ret;\n\n\tsample = devm_kzalloc(&pdev->dev, sizeof(*sample), GFP_KERNEL);\n\tif (!sample)\n\t\treturn -ENOMEM;\n\n\tret = qmi_handle_init(&sample->qmi, TEST_DATA_REQ_MAX_MSG_LEN_V01,\n\t\t\t      NULL,\n\t\t\t      qmi_sample_handlers);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tsq = dev_get_platdata(&pdev->dev);\n\tret = kernel_connect(sample->qmi.sock, (struct sockaddr *)sq,\n\t\t\t     sizeof(*sq), 0);\n\tif (ret < 0) {\n\t\tpr_err(\"failed to connect to remote service port\\n\");\n\t\tgoto err_release_qmi_handle;\n\t}\n\n\tsnprintf(path, sizeof(path), \"%d:%d\", sq->sq_node, sq->sq_port);\n\n\tsample->de_dir = debugfs_create_dir(path, qmi_debug_dir);\n\tif (IS_ERR(sample->de_dir)) {\n\t\tret = PTR_ERR(sample->de_dir);\n\t\tgoto err_release_qmi_handle;\n\t}\n\n\tsample->de_data = debugfs_create_file(\"data\", 0600, sample->de_dir,\n\t\t\t\t\t      sample, &data_fops);\n\tif (IS_ERR(sample->de_data)) {\n\t\tret = PTR_ERR(sample->de_data);\n\t\tgoto err_remove_de_dir;\n\t}\n\n\tsample->de_ping = debugfs_create_file(\"ping\", 0600, sample->de_dir,\n\t\t\t\t\t      sample, &ping_fops);\n\tif (IS_ERR(sample->de_ping)) {\n\t\tret = PTR_ERR(sample->de_ping);\n\t\tgoto err_remove_de_data;\n\t}\n\n\tplatform_set_drvdata(pdev, sample);\n\n\treturn 0;\n\nerr_remove_de_data:\n\tdebugfs_remove(sample->de_data);\nerr_remove_de_dir:\n\tdebugfs_remove(sample->de_dir);\nerr_release_qmi_handle:\n\tqmi_handle_release(&sample->qmi);\n\n\treturn ret;\n}\n\nstatic int qmi_sample_remove(struct platform_device *pdev)\n{\n\tstruct qmi_sample *sample = platform_get_drvdata(pdev);\n\n\tdebugfs_remove(sample->de_ping);\n\tdebugfs_remove(sample->de_data);\n\tdebugfs_remove(sample->de_dir);\n\n\tqmi_handle_release(&sample->qmi);\n\n\treturn 0;\n}\n\nstatic struct platform_driver qmi_sample_driver = {\n\t.probe = qmi_sample_probe,\n\t.remove = qmi_sample_remove,\n\t.driver = {\n\t\t.name = \"qmi_sample_client\",\n\t},\n};\n\nstatic int qmi_sample_new_server(struct qmi_handle *qmi,\n\t\t\t\t struct qmi_service *service)\n{\n\tstruct platform_device *pdev;\n\tstruct sockaddr_qrtr sq = { AF_QIPCRTR, service->node, service->port };\n\tint ret;\n\n\tpdev = platform_device_alloc(\"qmi_sample_client\", PLATFORM_DEVID_AUTO);\n\tif (!pdev)\n\t\treturn -ENOMEM;\n\n\tret = platform_device_add_data(pdev, &sq, sizeof(sq));\n\tif (ret)\n\t\tgoto err_put_device;\n\n\tret = platform_device_add(pdev);\n\tif (ret)\n\t\tgoto err_put_device;\n\n\tservice->priv = pdev;\n\n\treturn 0;\n\nerr_put_device:\n\tplatform_device_put(pdev);\n\n\treturn ret;\n}\n\nstatic void qmi_sample_del_server(struct qmi_handle *qmi,\n\t\t\t\t  struct qmi_service *service)\n{\n\tstruct platform_device *pdev = service->priv;\n\n\tplatform_device_unregister(pdev);\n}\n\nstatic struct qmi_handle lookup_client;\n\nstatic const struct qmi_ops lookup_ops = {\n\t.new_server = qmi_sample_new_server,\n\t.del_server = qmi_sample_del_server,\n};\n\nstatic int qmi_sample_init(void)\n{\n\tint ret;\n\n\tqmi_debug_dir = debugfs_create_dir(\"qmi_sample\", NULL);\n\tif (IS_ERR(qmi_debug_dir)) {\n\t\tpr_err(\"failed to create qmi_sample dir\\n\");\n\t\treturn PTR_ERR(qmi_debug_dir);\n\t}\n\n\tret = platform_driver_register(&qmi_sample_driver);\n\tif (ret)\n\t\tgoto err_remove_debug_dir;\n\n\tret = qmi_handle_init(&lookup_client, 0, &lookup_ops, NULL);\n\tif (ret < 0)\n\t\tgoto err_unregister_driver;\n\n\tqmi_add_lookup(&lookup_client, 15, 0, 0);\n\n\treturn 0;\n\nerr_unregister_driver:\n\tplatform_driver_unregister(&qmi_sample_driver);\nerr_remove_debug_dir:\n\tdebugfs_remove(qmi_debug_dir);\n\n\treturn ret;\n}\n\nstatic void qmi_sample_exit(void)\n{\n\tqmi_handle_release(&lookup_client);\n\n\tplatform_driver_unregister(&qmi_sample_driver);\n\n\tdebugfs_remove(qmi_debug_dir);\n}\n\nmodule_init(qmi_sample_init);\nmodule_exit(qmi_sample_exit);\n\nMODULE_DESCRIPTION(\"Sample QMI client driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}