{
  "module_name": "pfsm-wakeup.c",
  "hash_id": "f8fa1888beae7985ee88de1ae6cec8e180085393fc6bcdff6c98c6e00b1f6225",
  "original_prompt": "Ingested from linux-6.6.14/samples/pfsm/pfsm-wakeup.c",
  "human_readable_source": "\n \n\n#include <fcntl.h>\n#include <stdio.h>\n#include <sys/ioctl.h>\n#include <unistd.h>\n\n#include <linux/rtc.h>\n#include <linux/tps6594_pfsm.h>\n\n#define ALARM_DELTA_SEC 30\n\n#define RTC_A \"/dev/rtc0\"\n\n#define PMIC_NB 3\n#define PMIC_A \"/dev/pfsm-0-0x48\"\n#define PMIC_B \"/dev/pfsm-0-0x4c\"\n#define PMIC_C \"/dev/pfsm-2-0x58\"\n\nstatic const char * const dev_pfsm[] = {PMIC_A, PMIC_B, PMIC_C};\n\nint main(int argc, char *argv[])\n{\n\tint i, ret, fd_rtc, fd_pfsm[PMIC_NB] = { 0 };\n\tstruct rtc_time rtc_tm;\n\tstruct pmic_state_opt pmic_opt = { 0 };\n\tunsigned long data;\n\n\tfd_rtc = open(RTC_A, O_RDONLY);\n\tif (fd_rtc < 0) {\n\t\tperror(\"Failed to open RTC device.\");\n\t\tgoto out;\n\t}\n\n\tfor (i = 0 ; i < PMIC_NB ; i++) {\n\t\tfd_pfsm[i] = open(dev_pfsm[i], O_RDWR);\n\t\tif (fd_pfsm[i] < 0) {\n\t\t\tperror(\"Failed to open PFSM device.\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t \n\tret = ioctl(fd_rtc, RTC_RD_TIME, &rtc_tm);\n\tif (ret < 0) {\n\t\tperror(\"Failed to read RTC date/time.\");\n\t\tgoto out;\n\t}\n\tprintf(\"Current RTC date/time is %d-%d-%d, %02d:%02d:%02d.\\n\",\n\t       rtc_tm.tm_mday, rtc_tm.tm_mon + 1, rtc_tm.tm_year + 1900,\n\t       rtc_tm.tm_hour, rtc_tm.tm_min, rtc_tm.tm_sec);\n\n\t \n\trtc_tm.tm_sec += ALARM_DELTA_SEC;\n\tif (rtc_tm.tm_sec >= 60) {\n\t\trtc_tm.tm_sec %= 60;\n\t\trtc_tm.tm_min++;\n\t}\n\tif (rtc_tm.tm_min == 60) {\n\t\trtc_tm.tm_min = 0;\n\t\trtc_tm.tm_hour++;\n\t}\n\tif (rtc_tm.tm_hour == 24)\n\t\trtc_tm.tm_hour = 0;\n\tret = ioctl(fd_rtc, RTC_ALM_SET, &rtc_tm);\n\tif (ret < 0) {\n\t\tperror(\"Failed to set RTC alarm.\");\n\t\tgoto out;\n\t}\n\n\t \n\tret = ioctl(fd_rtc, RTC_AIE_ON, 0);\n\tif (ret < 0) {\n\t\tperror(\"Failed to enable alarm interrupts.\");\n\t\tgoto out;\n\t}\n\tprintf(\"Waiting %d seconds for alarm...\\n\", ALARM_DELTA_SEC);\n\n\t \n\tpmic_opt.ddr_retention = 1;\n\tfor (i = PMIC_NB - 1 ; i >= 0 ; i--) {\n\t\tprintf(\"Set RETENTION state for PMIC_%d.\\n\", i);\n\t\tsleep(1);\n\t\tret = ioctl(fd_pfsm[i], PMIC_SET_RETENTION_STATE, &pmic_opt);\n\t\tif (ret < 0) {\n\t\t\tperror(\"Failed to set RETENTION state.\");\n\t\t\tgoto out_reset;\n\t\t}\n\t}\n\n\t \n\tret = read(fd_rtc, &data, sizeof(unsigned long));\n\tif (ret < 0)\n\t\tperror(\"Failed to get RTC alarm.\");\n\telse\n\t\tputs(\"Alarm rang.\\n\");\n\nout_reset:\n\tioctl(fd_rtc, RTC_AIE_OFF, 0);\n\n\t \n\tioctl(fd_pfsm[0], PMIC_SET_ACTIVE_STATE, 0);\n\nout:\n\tfor (i = 0 ; i < PMIC_NB ; i++)\n\t\tif (fd_pfsm[i])\n\t\t\tclose(fd_pfsm[i]);\n\n\tif (fd_rtc)\n\t\tclose(fd_rtc);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}