{
  "module_name": "kmemleak-test.c",
  "hash_id": "5bd96d6893c18e8968261e86fc7ce359805e9dd925240a876de662a239db2a53",
  "original_prompt": "Ingested from linux-6.6.14/samples/kmemleak/kmemleak-test.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"kmemleak: \" fmt\n\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/list.h>\n#include <linux/percpu.h>\n#include <linux/fdtable.h>\n\n#include <linux/kmemleak.h>\n\nstruct test_node {\n\tlong header[25];\n\tstruct list_head list;\n\tlong footer[25];\n};\n\nstatic LIST_HEAD(test_list);\nstatic DEFINE_PER_CPU(void *, kmemleak_test_pointer);\n\n \nstatic int kmemleak_test_init(void)\n{\n\tstruct test_node *elem;\n\tint i;\n\n\tpr_info(\"Kmemleak testing\\n\");\n\n\t \n\tpr_info(\"kmalloc(32) = %p\\n\", kmalloc(32, GFP_KERNEL));\n\tpr_info(\"kmalloc(32) = %p\\n\", kmalloc(32, GFP_KERNEL));\n\tpr_info(\"kmalloc(1024) = %p\\n\", kmalloc(1024, GFP_KERNEL));\n\tpr_info(\"kmalloc(1024) = %p\\n\", kmalloc(1024, GFP_KERNEL));\n\tpr_info(\"kmalloc(2048) = %p\\n\", kmalloc(2048, GFP_KERNEL));\n\tpr_info(\"kmalloc(2048) = %p\\n\", kmalloc(2048, GFP_KERNEL));\n\tpr_info(\"kmalloc(4096) = %p\\n\", kmalloc(4096, GFP_KERNEL));\n\tpr_info(\"kmalloc(4096) = %p\\n\", kmalloc(4096, GFP_KERNEL));\n#ifndef CONFIG_MODULES\n\tpr_info(\"kmem_cache_alloc(files_cachep) = %p\\n\",\n\t\tkmem_cache_alloc(files_cachep, GFP_KERNEL));\n\tpr_info(\"kmem_cache_alloc(files_cachep) = %p\\n\",\n\t\tkmem_cache_alloc(files_cachep, GFP_KERNEL));\n#endif\n\tpr_info(\"vmalloc(64) = %p\\n\", vmalloc(64));\n\tpr_info(\"vmalloc(64) = %p\\n\", vmalloc(64));\n\tpr_info(\"vmalloc(64) = %p\\n\", vmalloc(64));\n\tpr_info(\"vmalloc(64) = %p\\n\", vmalloc(64));\n\tpr_info(\"vmalloc(64) = %p\\n\", vmalloc(64));\n\n\t \n\tfor (i = 0; i < 10; i++) {\n\t\telem = kzalloc(sizeof(*elem), GFP_KERNEL);\n\t\tpr_info(\"kzalloc(sizeof(*elem)) = %p\\n\", elem);\n\t\tif (!elem)\n\t\t\treturn -ENOMEM;\n\t\tINIT_LIST_HEAD(&elem->list);\n\t\tlist_add_tail(&elem->list, &test_list);\n\t}\n\n\tfor_each_possible_cpu(i) {\n\t\tper_cpu(kmemleak_test_pointer, i) = kmalloc(129, GFP_KERNEL);\n\t\tpr_info(\"kmalloc(129) = %p\\n\",\n\t\t\tper_cpu(kmemleak_test_pointer, i));\n\t}\n\n\treturn 0;\n}\nmodule_init(kmemleak_test_init);\n\nstatic void __exit kmemleak_test_exit(void)\n{\n\tstruct test_node *elem, *tmp;\n\n\t \n\tlist_for_each_entry_safe(elem, tmp, &test_list, list)\n\t\tlist_del(&elem->list);\n}\nmodule_exit(kmemleak_test_exit);\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}