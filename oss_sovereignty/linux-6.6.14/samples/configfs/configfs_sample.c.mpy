{
  "module_name": "configfs_sample.c",
  "hash_id": "5a79806d8bdddb771aa3119a5e8e62774d93a2c57745898adab6faba815bafbe",
  "original_prompt": "Ingested from linux-6.6.14/samples/configfs/configfs_sample.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/configfs.h>\n\n \n\nstruct childless {\n\tstruct configfs_subsystem subsys;\n\tint showme;\n\tint storeme;\n};\n\nstatic inline struct childless *to_childless(struct config_item *item)\n{\n\treturn container_of(to_configfs_subsystem(to_config_group(item)),\n\t\t\t    struct childless, subsys);\n}\n\nstatic ssize_t childless_showme_show(struct config_item *item, char *page)\n{\n\tstruct childless *childless = to_childless(item);\n\tssize_t pos;\n\n\tpos = sprintf(page, \"%d\\n\", childless->showme);\n\tchildless->showme++;\n\n\treturn pos;\n}\n\nstatic ssize_t childless_storeme_show(struct config_item *item, char *page)\n{\n\treturn sprintf(page, \"%d\\n\", to_childless(item)->storeme);\n}\n\nstatic ssize_t childless_storeme_store(struct config_item *item,\n\t\tconst char *page, size_t count)\n{\n\tstruct childless *childless = to_childless(item);\n\tint ret;\n\n\tret = kstrtoint(page, 10, &childless->storeme);\n\tif (ret)\n\t\treturn ret;\n\n\treturn count;\n}\n\nstatic ssize_t childless_description_show(struct config_item *item, char *page)\n{\n\treturn sprintf(page,\n\"[01-childless]\\n\"\n\"\\n\"\n\"The childless subsystem is the simplest possible subsystem in\\n\"\n\"configfs.  It does not support the creation of child config_items.\\n\"\n\"It only has a few attributes.  In fact, it isn't much different\\n\"\n\"than a directory in /proc.\\n\");\n}\n\nCONFIGFS_ATTR_RO(childless_, showme);\nCONFIGFS_ATTR(childless_, storeme);\nCONFIGFS_ATTR_RO(childless_, description);\n\nstatic struct configfs_attribute *childless_attrs[] = {\n\t&childless_attr_showme,\n\t&childless_attr_storeme,\n\t&childless_attr_description,\n\tNULL,\n};\n\nstatic const struct config_item_type childless_type = {\n\t.ct_attrs\t= childless_attrs,\n\t.ct_owner\t= THIS_MODULE,\n};\n\nstatic struct childless childless_subsys = {\n\t.subsys = {\n\t\t.su_group = {\n\t\t\t.cg_item = {\n\t\t\t\t.ci_namebuf = \"01-childless\",\n\t\t\t\t.ci_type = &childless_type,\n\t\t\t},\n\t\t},\n\t},\n};\n\n \n\n \n\nstruct simple_child {\n\tstruct config_item item;\n\tint storeme;\n};\n\nstatic inline struct simple_child *to_simple_child(struct config_item *item)\n{\n\treturn container_of(item, struct simple_child, item);\n}\n\nstatic ssize_t simple_child_storeme_show(struct config_item *item, char *page)\n{\n\treturn sprintf(page, \"%d\\n\", to_simple_child(item)->storeme);\n}\n\nstatic ssize_t simple_child_storeme_store(struct config_item *item,\n\t\tconst char *page, size_t count)\n{\n\tstruct simple_child *simple_child = to_simple_child(item);\n\tint ret;\n\n\tret = kstrtoint(page, 10, &simple_child->storeme);\n\tif (ret)\n\t\treturn ret;\n\n\treturn count;\n}\n\nCONFIGFS_ATTR(simple_child_, storeme);\n\nstatic struct configfs_attribute *simple_child_attrs[] = {\n\t&simple_child_attr_storeme,\n\tNULL,\n};\n\nstatic void simple_child_release(struct config_item *item)\n{\n\tkfree(to_simple_child(item));\n}\n\nstatic struct configfs_item_operations simple_child_item_ops = {\n\t.release\t= simple_child_release,\n};\n\nstatic const struct config_item_type simple_child_type = {\n\t.ct_item_ops\t= &simple_child_item_ops,\n\t.ct_attrs\t= simple_child_attrs,\n\t.ct_owner\t= THIS_MODULE,\n};\n\nstruct simple_children {\n\tstruct config_group group;\n};\n\nstatic inline struct simple_children *to_simple_children(struct config_item *item)\n{\n\treturn container_of(to_config_group(item),\n\t\t\t    struct simple_children, group);\n}\n\nstatic struct config_item *simple_children_make_item(struct config_group *group,\n\t\tconst char *name)\n{\n\tstruct simple_child *simple_child;\n\n\tsimple_child = kzalloc(sizeof(struct simple_child), GFP_KERNEL);\n\tif (!simple_child)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tconfig_item_init_type_name(&simple_child->item, name,\n\t\t\t\t   &simple_child_type);\n\n\treturn &simple_child->item;\n}\n\nstatic ssize_t simple_children_description_show(struct config_item *item,\n\t\tchar *page)\n{\n\treturn sprintf(page,\n\"[02-simple-children]\\n\"\n\"\\n\"\n\"This subsystem allows the creation of child config_items.  These\\n\"\n\"items have only one attribute that is readable and writeable.\\n\");\n}\n\nCONFIGFS_ATTR_RO(simple_children_, description);\n\nstatic struct configfs_attribute *simple_children_attrs[] = {\n\t&simple_children_attr_description,\n\tNULL,\n};\n\nstatic void simple_children_release(struct config_item *item)\n{\n\tkfree(to_simple_children(item));\n}\n\nstatic struct configfs_item_operations simple_children_item_ops = {\n\t.release\t= simple_children_release,\n};\n\n \nstatic struct configfs_group_operations simple_children_group_ops = {\n\t.make_item\t= simple_children_make_item,\n};\n\nstatic const struct config_item_type simple_children_type = {\n\t.ct_item_ops\t= &simple_children_item_ops,\n\t.ct_group_ops\t= &simple_children_group_ops,\n\t.ct_attrs\t= simple_children_attrs,\n\t.ct_owner\t= THIS_MODULE,\n};\n\nstatic struct configfs_subsystem simple_children_subsys = {\n\t.su_group = {\n\t\t.cg_item = {\n\t\t\t.ci_namebuf = \"02-simple-children\",\n\t\t\t.ci_type = &simple_children_type,\n\t\t},\n\t},\n};\n\n \n\n \n\nstatic struct config_group *group_children_make_group(\n\t\tstruct config_group *group, const char *name)\n{\n\tstruct simple_children *simple_children;\n\n\tsimple_children = kzalloc(sizeof(struct simple_children),\n\t\t\t\t  GFP_KERNEL);\n\tif (!simple_children)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tconfig_group_init_type_name(&simple_children->group, name,\n\t\t\t\t    &simple_children_type);\n\n\treturn &simple_children->group;\n}\n\nstatic ssize_t group_children_description_show(struct config_item *item,\n\t\tchar *page)\n{\n\treturn sprintf(page,\n\"[03-group-children]\\n\"\n\"\\n\"\n\"This subsystem allows the creation of child config_groups.  These\\n\"\n\"groups are like the subsystem simple-children.\\n\");\n}\n\nCONFIGFS_ATTR_RO(group_children_, description);\n\nstatic struct configfs_attribute *group_children_attrs[] = {\n\t&group_children_attr_description,\n\tNULL,\n};\n\n \nstatic struct configfs_group_operations group_children_group_ops = {\n\t.make_group\t= group_children_make_group,\n};\n\nstatic const struct config_item_type group_children_type = {\n\t.ct_group_ops\t= &group_children_group_ops,\n\t.ct_attrs\t= group_children_attrs,\n\t.ct_owner\t= THIS_MODULE,\n};\n\nstatic struct configfs_subsystem group_children_subsys = {\n\t.su_group = {\n\t\t.cg_item = {\n\t\t\t.ci_namebuf = \"03-group-children\",\n\t\t\t.ci_type = &group_children_type,\n\t\t},\n\t},\n};\n\n \n\n \nstatic struct configfs_subsystem *example_subsys[] = {\n\t&childless_subsys.subsys,\n\t&simple_children_subsys,\n\t&group_children_subsys,\n\tNULL,\n};\n\nstatic int __init configfs_example_init(void)\n{\n\tstruct configfs_subsystem *subsys;\n\tint ret, i;\n\n\tfor (i = 0; example_subsys[i]; i++) {\n\t\tsubsys = example_subsys[i];\n\n\t\tconfig_group_init(&subsys->su_group);\n\t\tmutex_init(&subsys->su_mutex);\n\t\tret = configfs_register_subsystem(subsys);\n\t\tif (ret) {\n\t\t\tpr_err(\"Error %d while registering subsystem %s\\n\",\n\t\t\t       ret, subsys->su_group.cg_item.ci_namebuf);\n\t\t\tgoto out_unregister;\n\t\t}\n\t}\n\n\treturn 0;\n\nout_unregister:\n\tfor (i--; i >= 0; i--)\n\t\tconfigfs_unregister_subsystem(example_subsys[i]);\n\n\treturn ret;\n}\n\nstatic void __exit configfs_example_exit(void)\n{\n\tint i;\n\n\tfor (i = 0; example_subsys[i]; i++)\n\t\tconfigfs_unregister_subsystem(example_subsys[i]);\n}\n\nmodule_init(configfs_example_init);\nmodule_exit(configfs_example_exit);\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}