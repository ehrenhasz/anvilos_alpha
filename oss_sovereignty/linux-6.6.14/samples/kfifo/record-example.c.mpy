{
  "module_name": "record-example.c",
  "hash_id": "a17abafef2604c9ba37b24f828a35af2ce51e94147c56f88f00b87c7cb19cfe9",
  "original_prompt": "Ingested from linux-6.6.14/samples/kfifo/record-example.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/proc_fs.h>\n#include <linux/mutex.h>\n#include <linux/kfifo.h>\n\n \n\n \n#define FIFO_SIZE\t128\n\n \n#define\tPROC_FIFO\t\"record-fifo\"\n\n \nstatic DEFINE_MUTEX(read_access);\n\n \nstatic DEFINE_MUTEX(write_access);\n\n \n#if 0\n#define DYNAMIC\n#endif\n\n \n\n#ifdef DYNAMIC\nstruct kfifo_rec_ptr_1 test;\n\n#else\ntypedef STRUCT_KFIFO_REC_1(FIFO_SIZE) mytest;\n\nstatic mytest test;\n#endif\n\nstatic const char *expected_result[] = {\n\t\"a\",\n\t\"bb\",\n\t\"ccc\",\n\t\"dddd\",\n\t\"eeeee\",\n\t\"ffffff\",\n\t\"ggggggg\",\n\t\"hhhhhhhh\",\n\t\"iiiiiiiii\",\n\t\"jjjjjjjjjj\",\n};\n\nstatic int __init testfunc(void)\n{\n\tchar\t\tbuf[100];\n\tunsigned int\ti;\n\tunsigned int\tret;\n\tstruct { unsigned char buf[6]; } hello = { \"hello\" };\n\n\tprintk(KERN_INFO \"record fifo test start\\n\");\n\n\tkfifo_in(&test, &hello, sizeof(hello));\n\n\t \n\tprintk(KERN_INFO \"fifo peek len: %u\\n\", kfifo_peek_len(&test));\n\n\t \n\tfor (i = 0; i < 10; i++) {\n\t\tmemset(buf, 'a' + i, i + 1);\n\t\tkfifo_in(&test, buf, i + 1);\n\t}\n\n\t \n\tprintk(KERN_INFO \"skip 1st element\\n\");\n\tkfifo_skip(&test);\n\n\tprintk(KERN_INFO \"fifo len: %u\\n\", kfifo_len(&test));\n\n\t \n\tret = kfifo_out_peek(&test, buf, sizeof(buf));\n\tif (ret)\n\t\tprintk(KERN_INFO \"%.*s\\n\", ret, buf);\n\n\t \n\ti = 0;\n\twhile (!kfifo_is_empty(&test)) {\n\t\tret = kfifo_out(&test, buf, sizeof(buf));\n\t\tbuf[ret] = '\\0';\n\t\tprintk(KERN_INFO \"item = %.*s\\n\", ret, buf);\n\t\tif (strcmp(buf, expected_result[i++])) {\n\t\t\tprintk(KERN_WARNING \"value mismatch: test failed\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\tif (i != ARRAY_SIZE(expected_result)) {\n\t\tprintk(KERN_WARNING \"size mismatch: test failed\\n\");\n\t\treturn -EIO;\n\t}\n\tprintk(KERN_INFO \"test passed\\n\");\n\n\treturn 0;\n}\n\nstatic ssize_t fifo_write(struct file *file, const char __user *buf,\n\t\t\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tint ret;\n\tunsigned int copied;\n\n\tif (mutex_lock_interruptible(&write_access))\n\t\treturn -ERESTARTSYS;\n\n\tret = kfifo_from_user(&test, buf, count, &copied);\n\n\tmutex_unlock(&write_access);\n\tif (ret)\n\t\treturn ret;\n\n\treturn copied;\n}\n\nstatic ssize_t fifo_read(struct file *file, char __user *buf,\n\t\t\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tint ret;\n\tunsigned int copied;\n\n\tif (mutex_lock_interruptible(&read_access))\n\t\treturn -ERESTARTSYS;\n\n\tret = kfifo_to_user(&test, buf, count, &copied);\n\n\tmutex_unlock(&read_access);\n\tif (ret)\n\t\treturn ret;\n\n\treturn copied;\n}\n\nstatic const struct proc_ops fifo_proc_ops = {\n\t.proc_read\t= fifo_read,\n\t.proc_write\t= fifo_write,\n\t.proc_lseek\t= noop_llseek,\n};\n\nstatic int __init example_init(void)\n{\n#ifdef DYNAMIC\n\tint ret;\n\n\tret = kfifo_alloc(&test, FIFO_SIZE, GFP_KERNEL);\n\tif (ret) {\n\t\tprintk(KERN_ERR \"error kfifo_alloc\\n\");\n\t\treturn ret;\n\t}\n#else\n\tINIT_KFIFO(test);\n#endif\n\tif (testfunc() < 0) {\n#ifdef DYNAMIC\n\t\tkfifo_free(&test);\n#endif\n\t\treturn -EIO;\n\t}\n\n\tif (proc_create(PROC_FIFO, 0, NULL, &fifo_proc_ops) == NULL) {\n#ifdef DYNAMIC\n\t\tkfifo_free(&test);\n#endif\n\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}\n\nstatic void __exit example_exit(void)\n{\n\tremove_proc_entry(PROC_FIFO, NULL);\n#ifdef DYNAMIC\n\tkfifo_free(&test);\n#endif\n}\n\nmodule_init(example_init);\nmodule_exit(example_exit);\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Stefani Seibold <stefani@seibold.net>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}