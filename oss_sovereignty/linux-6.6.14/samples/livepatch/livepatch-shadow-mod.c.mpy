{
  "module_name": "livepatch-shadow-mod.c",
  "hash_id": "b623b21d1df18486a2cd2aa16027c2a8ed43bf7da7ad1c2642d3abeaf091af18",
  "original_prompt": "Ingested from linux-6.6.14/samples/livepatch/livepatch-shadow-mod.c",
  "human_readable_source": "\n \n\n \n\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/workqueue.h>\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Joe Lawrence <joe.lawrence@redhat.com>\");\nMODULE_DESCRIPTION(\"Buggy module for shadow variable demo\");\n\n \n#define ALLOC_PERIOD\t1\n \n#define CLEANUP_PERIOD\t(3 * ALLOC_PERIOD)\n \n#define EXPIRE_PERIOD\t(4 * CLEANUP_PERIOD)\n\n \nstatic LIST_HEAD(dummy_list);\nstatic DEFINE_MUTEX(dummy_list_mutex);\n\nstruct dummy {\n\tstruct list_head list;\n\tunsigned long jiffies_expire;\n};\n\nstatic __used noinline struct dummy *dummy_alloc(void)\n{\n\tstruct dummy *d;\n\tint *leak;\n\n\td = kzalloc(sizeof(*d), GFP_KERNEL);\n\tif (!d)\n\t\treturn NULL;\n\n\td->jiffies_expire = jiffies +\n\t\tmsecs_to_jiffies(1000 * EXPIRE_PERIOD);\n\n\t \n\tleak = kzalloc(sizeof(*leak), GFP_KERNEL);\n\tif (!leak) {\n\t\tkfree(d);\n\t\treturn NULL;\n\t}\n\n\tpr_info(\"%s: dummy @ %p, expires @ %lx\\n\",\n\t\t__func__, d, d->jiffies_expire);\n\n\treturn d;\n}\n\nstatic __used noinline void dummy_free(struct dummy *d)\n{\n\tpr_info(\"%s: dummy @ %p, expired = %lx\\n\",\n\t\t__func__, d, d->jiffies_expire);\n\n\tkfree(d);\n}\n\nstatic __used noinline bool dummy_check(struct dummy *d,\n\t\t\t\t\t   unsigned long jiffies)\n{\n\treturn time_after(jiffies, d->jiffies_expire);\n}\n\n \n\nstatic void alloc_work_func(struct work_struct *work);\nstatic DECLARE_DELAYED_WORK(alloc_dwork, alloc_work_func);\n\nstatic void alloc_work_func(struct work_struct *work)\n{\n\tstruct dummy *d;\n\n\td = dummy_alloc();\n\tif (!d)\n\t\treturn;\n\n\tmutex_lock(&dummy_list_mutex);\n\tlist_add(&d->list, &dummy_list);\n\tmutex_unlock(&dummy_list_mutex);\n\n\tschedule_delayed_work(&alloc_dwork,\n\t\tmsecs_to_jiffies(1000 * ALLOC_PERIOD));\n}\n\n \n\nstatic void cleanup_work_func(struct work_struct *work);\nstatic DECLARE_DELAYED_WORK(cleanup_dwork, cleanup_work_func);\n\nstatic void cleanup_work_func(struct work_struct *work)\n{\n\tstruct dummy *d, *tmp;\n\tunsigned long j;\n\n\tj = jiffies;\n\tpr_info(\"%s: jiffies = %lx\\n\", __func__, j);\n\n\tmutex_lock(&dummy_list_mutex);\n\tlist_for_each_entry_safe(d, tmp, &dummy_list, list) {\n\n\t\t \n\t\tif (dummy_check(d, j)) {\n\t\t\tlist_del(&d->list);\n\t\t\tdummy_free(d);\n\t\t}\n\t}\n\tmutex_unlock(&dummy_list_mutex);\n\n\tschedule_delayed_work(&cleanup_dwork,\n\t\tmsecs_to_jiffies(1000 * CLEANUP_PERIOD));\n}\n\nstatic int livepatch_shadow_mod_init(void)\n{\n\tschedule_delayed_work(&alloc_dwork,\n\t\tmsecs_to_jiffies(1000 * ALLOC_PERIOD));\n\tschedule_delayed_work(&cleanup_dwork,\n\t\tmsecs_to_jiffies(1000 * CLEANUP_PERIOD));\n\n\treturn 0;\n}\n\nstatic void livepatch_shadow_mod_exit(void)\n{\n\tstruct dummy *d, *tmp;\n\n\t \n\tcancel_delayed_work_sync(&alloc_dwork);\n\tcancel_delayed_work_sync(&cleanup_dwork);\n\n\t \n\tlist_for_each_entry_safe(d, tmp, &dummy_list, list) {\n\t\tlist_del(&d->list);\n\t\tdummy_free(d);\n\t}\n}\n\nmodule_init(livepatch_shadow_mod_init);\nmodule_exit(livepatch_shadow_mod_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}