{
  "module_name": "livepatch-shadow-fix1.c",
  "hash_id": "637cae24494534db838bfdf45e0072ae7a8d70621ef14fddc49700caeee71775",
  "original_prompt": "Ingested from linux-6.6.14/samples/livepatch/livepatch-shadow-fix1.c",
  "human_readable_source": "\n \n\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/livepatch.h>\n#include <linux/slab.h>\n\n \n#define SV_LEAK\t\t1\n\n \n#define ALLOC_PERIOD\t1\n \n#define CLEANUP_PERIOD\t(3 * ALLOC_PERIOD)\n \n#define EXPIRE_PERIOD\t(4 * CLEANUP_PERIOD)\n\nstruct dummy {\n\tstruct list_head list;\n\tunsigned long jiffies_expire;\n};\n\n \nstatic int shadow_leak_ctor(void *obj, void *shadow_data, void *ctor_data)\n{\n\tint **shadow_leak = shadow_data;\n\tint **leak = ctor_data;\n\n\tif (!ctor_data)\n\t\treturn -EINVAL;\n\n\t*shadow_leak = *leak;\n\treturn 0;\n}\n\nstatic struct dummy *livepatch_fix1_dummy_alloc(void)\n{\n\tstruct dummy *d;\n\tint *leak;\n\tint **shadow_leak;\n\n\td = kzalloc(sizeof(*d), GFP_KERNEL);\n\tif (!d)\n\t\treturn NULL;\n\n\td->jiffies_expire = jiffies +\n\t\tmsecs_to_jiffies(1000 * EXPIRE_PERIOD);\n\n\t \n\tleak = kzalloc(sizeof(*leak), GFP_KERNEL);\n\tif (!leak)\n\t\tgoto err_leak;\n\n\tshadow_leak = klp_shadow_alloc(d, SV_LEAK, sizeof(leak), GFP_KERNEL,\n\t\t\t\t       shadow_leak_ctor, &leak);\n\tif (!shadow_leak) {\n\t\tpr_err(\"%s: failed to allocate shadow variable for the leaking pointer: dummy @ %p, leak @ %p\\n\",\n\t\t       __func__, d, leak);\n\t\tgoto err_shadow;\n\t}\n\n\tpr_info(\"%s: dummy @ %p, expires @ %lx\\n\",\n\t\t__func__, d, d->jiffies_expire);\n\n\treturn d;\n\nerr_shadow:\n\tkfree(leak);\nerr_leak:\n\tkfree(d);\n\treturn NULL;\n}\n\nstatic void livepatch_fix1_dummy_leak_dtor(void *obj, void *shadow_data)\n{\n\tvoid *d = obj;\n\tint **shadow_leak = shadow_data;\n\n\tpr_info(\"%s: dummy @ %p, prevented leak @ %p\\n\",\n\t\t\t __func__, d, *shadow_leak);\n\tkfree(*shadow_leak);\n}\n\nstatic void livepatch_fix1_dummy_free(struct dummy *d)\n{\n\tint **shadow_leak;\n\n\t \n\tshadow_leak = klp_shadow_get(d, SV_LEAK);\n\tif (shadow_leak)\n\t\tklp_shadow_free(d, SV_LEAK, livepatch_fix1_dummy_leak_dtor);\n\telse\n\t\tpr_info(\"%s: dummy @ %p leaked!\\n\", __func__, d);\n\n\tkfree(d);\n}\n\nstatic struct klp_func funcs[] = {\n\t{\n\t\t.old_name = \"dummy_alloc\",\n\t\t.new_func = livepatch_fix1_dummy_alloc,\n\t},\n\t{\n\t\t.old_name = \"dummy_free\",\n\t\t.new_func = livepatch_fix1_dummy_free,\n\t}, { }\n};\n\nstatic struct klp_object objs[] = {\n\t{\n\t\t.name = \"livepatch_shadow_mod\",\n\t\t.funcs = funcs,\n\t}, { }\n};\n\nstatic struct klp_patch patch = {\n\t.mod = THIS_MODULE,\n\t.objs = objs,\n};\n\nstatic int livepatch_shadow_fix1_init(void)\n{\n\treturn klp_enable_patch(&patch);\n}\n\nstatic void livepatch_shadow_fix1_exit(void)\n{\n\t \n\tklp_shadow_free_all(SV_LEAK, livepatch_fix1_dummy_leak_dtor);\n}\n\nmodule_init(livepatch_shadow_fix1_init);\nmodule_exit(livepatch_shadow_fix1_exit);\nMODULE_LICENSE(\"GPL\");\nMODULE_INFO(livepatch, \"Y\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}