{
  "module_name": "v4l2-pci-skeleton.c",
  "hash_id": "d9fa83e53ce3ffd7ef6d5a217f95f08018800ab48cfe5dbd46a4bc8d84212fc1",
  "original_prompt": "Ingested from linux-6.6.14/samples/v4l/v4l2-pci-skeleton.c",
  "human_readable_source": "\n \n\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kmod.h>\n#include <linux/mutex.h>\n#include <linux/pci.h>\n#include <linux/interrupt.h>\n#include <linux/videodev2.h>\n#include <linux/v4l2-dv-timings.h>\n#include <media/v4l2-device.h>\n#include <media/v4l2-dev.h>\n#include <media/v4l2-ioctl.h>\n#include <media/v4l2-dv-timings.h>\n#include <media/v4l2-ctrls.h>\n#include <media/v4l2-event.h>\n#include <media/videobuf2-v4l2.h>\n#include <media/videobuf2-dma-contig.h>\n\nMODULE_DESCRIPTION(\"V4L2 PCI Skeleton Driver\");\nMODULE_AUTHOR(\"Hans Verkuil\");\nMODULE_LICENSE(\"GPL v2\");\n\n \nstruct skeleton {\n\tstruct pci_dev *pdev;\n\tstruct v4l2_device v4l2_dev;\n\tstruct video_device vdev;\n\tstruct v4l2_ctrl_handler ctrl_handler;\n\tstruct mutex lock;\n\tv4l2_std_id std;\n\tstruct v4l2_dv_timings timings;\n\tstruct v4l2_pix_format format;\n\tunsigned input;\n\n\tstruct vb2_queue queue;\n\n\tspinlock_t qlock;\n\tstruct list_head buf_list;\n\tunsigned field;\n\tunsigned sequence;\n};\n\nstruct skel_buffer {\n\tstruct vb2_v4l2_buffer vb;\n\tstruct list_head list;\n};\n\nstatic inline struct skel_buffer *to_skel_buffer(struct vb2_v4l2_buffer *vbuf)\n{\n\treturn container_of(vbuf, struct skel_buffer, vb);\n}\n\nstatic const struct pci_device_id skeleton_pci_tbl[] = {\n\t \n\t{ 0, }\n};\nMODULE_DEVICE_TABLE(pci, skeleton_pci_tbl);\n\n \nstatic const struct v4l2_dv_timings_cap skel_timings_cap = {\n\t.type = V4L2_DV_BT_656_1120,\n\t \n\t.reserved = { 0 },\n\tV4L2_INIT_BT_TIMINGS(\n\t\t720, 1920,\t\t \n\t\t480, 1080,\t\t \n\t\t27000000, 74250000,\t \n\t\tV4L2_DV_BT_STD_CEA861,\t \n\t\t \n\t\tV4L2_DV_BT_CAP_INTERLACED | V4L2_DV_BT_CAP_PROGRESSIVE\n\t)\n};\n\n \n#define SKEL_TVNORMS V4L2_STD_ALL\n\n \nstatic irqreturn_t skeleton_irq(int irq, void *dev_id)\n{\n#ifdef TODO\n\tstruct skeleton *skel = dev_id;\n\n\t \n\n\t \n\tif (captured_new_frame) {\n\t\t...\n\t\tspin_lock(&skel->qlock);\n\t\tlist_del(&new_buf->list);\n\t\tspin_unlock(&skel->qlock);\n\t\tnew_buf->vb.vb2_buf.timestamp = ktime_get_ns();\n\t\tnew_buf->vb.sequence = skel->sequence++;\n\t\tnew_buf->vb.field = skel->field;\n\t\tif (skel->format.field == V4L2_FIELD_ALTERNATE) {\n\t\t\tif (skel->field == V4L2_FIELD_BOTTOM)\n\t\t\t\tskel->field = V4L2_FIELD_TOP;\n\t\t\telse if (skel->field == V4L2_FIELD_TOP)\n\t\t\t\tskel->field = V4L2_FIELD_BOTTOM;\n\t\t}\n\t\tvb2_buffer_done(&new_buf->vb.vb2_buf, VB2_BUF_STATE_DONE);\n\t}\n#endif\n\treturn IRQ_HANDLED;\n}\n\n \nstatic int queue_setup(struct vb2_queue *vq,\n\t\t       unsigned int *nbuffers, unsigned int *nplanes,\n\t\t       unsigned int sizes[], struct device *alloc_devs[])\n{\n\tstruct skeleton *skel = vb2_get_drv_priv(vq);\n\n\tskel->field = skel->format.field;\n\tif (skel->field == V4L2_FIELD_ALTERNATE) {\n\t\t \n\t\tif (vb2_fileio_is_active(vq))\n\t\t\treturn -EINVAL;\n\t\tskel->field = V4L2_FIELD_TOP;\n\t}\n\n\tif (vq->num_buffers + *nbuffers < 3)\n\t\t*nbuffers = 3 - vq->num_buffers;\n\n\tif (*nplanes)\n\t\treturn sizes[0] < skel->format.sizeimage ? -EINVAL : 0;\n\t*nplanes = 1;\n\tsizes[0] = skel->format.sizeimage;\n\treturn 0;\n}\n\n \nstatic int buffer_prepare(struct vb2_buffer *vb)\n{\n\tstruct skeleton *skel = vb2_get_drv_priv(vb->vb2_queue);\n\tunsigned long size = skel->format.sizeimage;\n\n\tif (vb2_plane_size(vb, 0) < size) {\n\t\tdev_err(&skel->pdev->dev, \"buffer too small (%lu < %lu)\\n\",\n\t\t\t vb2_plane_size(vb, 0), size);\n\t\treturn -EINVAL;\n\t}\n\n\tvb2_set_plane_payload(vb, 0, size);\n\treturn 0;\n}\n\n \nstatic void buffer_queue(struct vb2_buffer *vb)\n{\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct skeleton *skel = vb2_get_drv_priv(vb->vb2_queue);\n\tstruct skel_buffer *buf = to_skel_buffer(vbuf);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&skel->qlock, flags);\n\tlist_add_tail(&buf->list, &skel->buf_list);\n\n\t \n\n\tspin_unlock_irqrestore(&skel->qlock, flags);\n}\n\nstatic void return_all_buffers(struct skeleton *skel,\n\t\t\t       enum vb2_buffer_state state)\n{\n\tstruct skel_buffer *buf, *node;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&skel->qlock, flags);\n\tlist_for_each_entry_safe(buf, node, &skel->buf_list, list) {\n\t\tvb2_buffer_done(&buf->vb.vb2_buf, state);\n\t\tlist_del(&buf->list);\n\t}\n\tspin_unlock_irqrestore(&skel->qlock, flags);\n}\n\n \nstatic int start_streaming(struct vb2_queue *vq, unsigned int count)\n{\n\tstruct skeleton *skel = vb2_get_drv_priv(vq);\n\tint ret = 0;\n\n\tskel->sequence = 0;\n\n\t \n\n\tif (ret) {\n\t\t \n\t\treturn_all_buffers(skel, VB2_BUF_STATE_QUEUED);\n\t}\n\treturn ret;\n}\n\n \nstatic void stop_streaming(struct vb2_queue *vq)\n{\n\tstruct skeleton *skel = vb2_get_drv_priv(vq);\n\n\t \n\n\t \n\treturn_all_buffers(skel, VB2_BUF_STATE_ERROR);\n}\n\n \nstatic const struct vb2_ops skel_qops = {\n\t.queue_setup\t\t= queue_setup,\n\t.buf_prepare\t\t= buffer_prepare,\n\t.buf_queue\t\t= buffer_queue,\n\t.start_streaming\t= start_streaming,\n\t.stop_streaming\t\t= stop_streaming,\n\t.wait_prepare\t\t= vb2_ops_wait_prepare,\n\t.wait_finish\t\t= vb2_ops_wait_finish,\n};\n\n \nstatic int skeleton_querycap(struct file *file, void *priv,\n\t\t\t     struct v4l2_capability *cap)\n{\n\tstruct skeleton *skel = video_drvdata(file);\n\n\tstrlcpy(cap->driver, KBUILD_MODNAME, sizeof(cap->driver));\n\tstrlcpy(cap->card, \"V4L2 PCI Skeleton\", sizeof(cap->card));\n\tsnprintf(cap->bus_info, sizeof(cap->bus_info), \"PCI:%s\",\n\t\t pci_name(skel->pdev));\n\treturn 0;\n}\n\n \nstatic void skeleton_fill_pix_format(struct skeleton *skel,\n\t\t\t\t     struct v4l2_pix_format *pix)\n{\n\tpix->pixelformat = V4L2_PIX_FMT_YUYV;\n\tif (skel->input == 0) {\n\t\t \n\t\tpix->width = 720;\n\t\tpix->height = (skel->std & V4L2_STD_525_60) ? 480 : 576;\n\t\tpix->field = V4L2_FIELD_INTERLACED;\n\t\tpix->colorspace = V4L2_COLORSPACE_SMPTE170M;\n\t} else {\n\t\t \n\t\tpix->width = skel->timings.bt.width;\n\t\tpix->height = skel->timings.bt.height;\n\t\tif (skel->timings.bt.interlaced) {\n\t\t\tpix->field = V4L2_FIELD_ALTERNATE;\n\t\t\tpix->height /= 2;\n\t\t} else {\n\t\t\tpix->field = V4L2_FIELD_NONE;\n\t\t}\n\t\tpix->colorspace = V4L2_COLORSPACE_REC709;\n\t}\n\n\t \n\tpix->bytesperline = pix->width * 2;\n\tpix->sizeimage = pix->bytesperline * pix->height;\n\tpix->priv = 0;\n}\n\nstatic int skeleton_try_fmt_vid_cap(struct file *file, void *priv,\n\t\t\t\t    struct v4l2_format *f)\n{\n\tstruct skeleton *skel = video_drvdata(file);\n\tstruct v4l2_pix_format *pix = &f->fmt.pix;\n\n\t \n\tif (pix->pixelformat != V4L2_PIX_FMT_YUYV)\n\t\treturn -EINVAL;\n\tskeleton_fill_pix_format(skel, pix);\n\treturn 0;\n}\n\nstatic int skeleton_s_fmt_vid_cap(struct file *file, void *priv,\n\t\t\t\t  struct v4l2_format *f)\n{\n\tstruct skeleton *skel = video_drvdata(file);\n\tint ret;\n\n\tret = skeleton_try_fmt_vid_cap(file, priv, f);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (vb2_is_busy(&skel->queue))\n\t\treturn -EBUSY;\n\n\t \n\tskel->format = f->fmt.pix;\n\treturn 0;\n}\n\nstatic int skeleton_g_fmt_vid_cap(struct file *file, void *priv,\n\t\t\t\t  struct v4l2_format *f)\n{\n\tstruct skeleton *skel = video_drvdata(file);\n\n\tf->fmt.pix = skel->format;\n\treturn 0;\n}\n\nstatic int skeleton_enum_fmt_vid_cap(struct file *file, void *priv,\n\t\t\t\t     struct v4l2_fmtdesc *f)\n{\n\tif (f->index != 0)\n\t\treturn -EINVAL;\n\n\tf->pixelformat = V4L2_PIX_FMT_YUYV;\n\treturn 0;\n}\n\nstatic int skeleton_s_std(struct file *file, void *priv, v4l2_std_id std)\n{\n\tstruct skeleton *skel = video_drvdata(file);\n\n\t \n\tif (skel->input)\n\t\treturn -ENODATA;\n\n\t \n\tif (std == skel->std)\n\t\treturn 0;\n\n\t \n\tif (vb2_is_busy(&skel->queue))\n\t\treturn -EBUSY;\n\n\t \n\n\tskel->std = std;\n\n\t \n\tskeleton_fill_pix_format(skel, &skel->format);\n\treturn 0;\n}\n\nstatic int skeleton_g_std(struct file *file, void *priv, v4l2_std_id *std)\n{\n\tstruct skeleton *skel = video_drvdata(file);\n\n\t \n\tif (skel->input)\n\t\treturn -ENODATA;\n\n\t*std = skel->std;\n\treturn 0;\n}\n\n \nstatic int skeleton_querystd(struct file *file, void *priv, v4l2_std_id *std)\n{\n\tstruct skeleton *skel = video_drvdata(file);\n\n\t \n\tif (skel->input)\n\t\treturn -ENODATA;\n\n#ifdef TODO\n\t \n\tget_signal_info();\n\tif (no_signal) {\n\t\t*std = 0;\n\t\treturn 0;\n\t}\n\t \n\tif (signal_has_525_lines)\n\t\t*std &= V4L2_STD_525_60;\n\telse\n\t\t*std &= V4L2_STD_625_50;\n#endif\n\treturn 0;\n}\n\nstatic int skeleton_s_dv_timings(struct file *file, void *_fh,\n\t\t\t\t struct v4l2_dv_timings *timings)\n{\n\tstruct skeleton *skel = video_drvdata(file);\n\n\t \n\tif (skel->input == 0)\n\t\treturn -ENODATA;\n\n\t \n\tif (!v4l2_valid_dv_timings(timings, &skel_timings_cap, NULL, NULL))\n\t\treturn -EINVAL;\n\n\t \n\tif (!v4l2_find_dv_timings_cap(timings, &skel_timings_cap,\n\t\t\t\t      0, NULL, NULL))\n\t\treturn -EINVAL;\n\n\t \n\tif (v4l2_match_dv_timings(timings, &skel->timings, 0, false))\n\t\treturn 0;\n\n\t \n\tif (vb2_is_busy(&skel->queue))\n\t\treturn -EBUSY;\n\n\t \n\n\t \n\tskel->timings = *timings;\n\n\t \n\tskeleton_fill_pix_format(skel, &skel->format);\n\treturn 0;\n}\n\nstatic int skeleton_g_dv_timings(struct file *file, void *_fh,\n\t\t\t\t struct v4l2_dv_timings *timings)\n{\n\tstruct skeleton *skel = video_drvdata(file);\n\n\t \n\tif (skel->input == 0)\n\t\treturn -ENODATA;\n\n\t*timings = skel->timings;\n\treturn 0;\n}\n\nstatic int skeleton_enum_dv_timings(struct file *file, void *_fh,\n\t\t\t\t    struct v4l2_enum_dv_timings *timings)\n{\n\tstruct skeleton *skel = video_drvdata(file);\n\n\t \n\tif (skel->input == 0)\n\t\treturn -ENODATA;\n\n\treturn v4l2_enum_dv_timings_cap(timings, &skel_timings_cap,\n\t\t\t\t\tNULL, NULL);\n}\n\n \nstatic int skeleton_query_dv_timings(struct file *file, void *_fh,\n\t\t\t\t     struct v4l2_dv_timings *timings)\n{\n\tstruct skeleton *skel = video_drvdata(file);\n\n\t \n\tif (skel->input == 0)\n\t\treturn -ENODATA;\n\n#ifdef TODO\n\t \n\tdetect_timings();\n\tif (no_signal)\n\t\treturn -ENOLINK;\n\tif (cannot_lock_to_signal)\n\t\treturn -ENOLCK;\n\tif (signal_out_of_range_of_capabilities)\n\t\treturn -ERANGE;\n\n\t \n\tv4l2_print_dv_timings(skel->v4l2_dev.name, \"query_dv_timings:\",\n\t\t\ttimings, true);\n#endif\n\treturn 0;\n}\n\nstatic int skeleton_dv_timings_cap(struct file *file, void *fh,\n\t\t\t\t   struct v4l2_dv_timings_cap *cap)\n{\n\tstruct skeleton *skel = video_drvdata(file);\n\n\t \n\tif (skel->input == 0)\n\t\treturn -ENODATA;\n\t*cap = skel_timings_cap;\n\treturn 0;\n}\n\nstatic int skeleton_enum_input(struct file *file, void *priv,\n\t\t\t       struct v4l2_input *i)\n{\n\tif (i->index > 1)\n\t\treturn -EINVAL;\n\n\ti->type = V4L2_INPUT_TYPE_CAMERA;\n\tif (i->index == 0) {\n\t\ti->std = SKEL_TVNORMS;\n\t\tstrlcpy(i->name, \"S-Video\", sizeof(i->name));\n\t\ti->capabilities = V4L2_IN_CAP_STD;\n\t} else {\n\t\ti->std = 0;\n\t\tstrlcpy(i->name, \"HDMI\", sizeof(i->name));\n\t\ti->capabilities = V4L2_IN_CAP_DV_TIMINGS;\n\t}\n\treturn 0;\n}\n\nstatic int skeleton_s_input(struct file *file, void *priv, unsigned int i)\n{\n\tstruct skeleton *skel = video_drvdata(file);\n\n\tif (i > 1)\n\t\treturn -EINVAL;\n\n\t \n\tif (vb2_is_busy(&skel->queue))\n\t\treturn -EBUSY;\n\n\tskel->input = i;\n\t \n\tskel->vdev.tvnorms = i ? 0 : SKEL_TVNORMS;\n\n\t \n\tskeleton_fill_pix_format(skel, &skel->format);\n\treturn 0;\n}\n\nstatic int skeleton_g_input(struct file *file, void *priv, unsigned int *i)\n{\n\tstruct skeleton *skel = video_drvdata(file);\n\n\t*i = skel->input;\n\treturn 0;\n}\n\n \nstatic int skeleton_s_ctrl(struct v4l2_ctrl *ctrl)\n{\n\t \n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_BRIGHTNESS:\n\t\t \n\t\tbreak;\n\tcase V4L2_CID_CONTRAST:\n\t\t \n\t\tbreak;\n\tcase V4L2_CID_SATURATION:\n\t\t \n\t\tbreak;\n\tcase V4L2_CID_HUE:\n\t\t \n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\n \n\nstatic const struct v4l2_ctrl_ops skel_ctrl_ops = {\n\t.s_ctrl = skeleton_s_ctrl,\n};\n\n \nstatic const struct v4l2_ioctl_ops skel_ioctl_ops = {\n\t.vidioc_querycap = skeleton_querycap,\n\t.vidioc_try_fmt_vid_cap = skeleton_try_fmt_vid_cap,\n\t.vidioc_s_fmt_vid_cap = skeleton_s_fmt_vid_cap,\n\t.vidioc_g_fmt_vid_cap = skeleton_g_fmt_vid_cap,\n\t.vidioc_enum_fmt_vid_cap = skeleton_enum_fmt_vid_cap,\n\n\t.vidioc_g_std = skeleton_g_std,\n\t.vidioc_s_std = skeleton_s_std,\n\t.vidioc_querystd = skeleton_querystd,\n\n\t.vidioc_s_dv_timings = skeleton_s_dv_timings,\n\t.vidioc_g_dv_timings = skeleton_g_dv_timings,\n\t.vidioc_enum_dv_timings = skeleton_enum_dv_timings,\n\t.vidioc_query_dv_timings = skeleton_query_dv_timings,\n\t.vidioc_dv_timings_cap = skeleton_dv_timings_cap,\n\n\t.vidioc_enum_input = skeleton_enum_input,\n\t.vidioc_g_input = skeleton_g_input,\n\t.vidioc_s_input = skeleton_s_input,\n\n\t.vidioc_reqbufs = vb2_ioctl_reqbufs,\n\t.vidioc_create_bufs = vb2_ioctl_create_bufs,\n\t.vidioc_querybuf = vb2_ioctl_querybuf,\n\t.vidioc_qbuf = vb2_ioctl_qbuf,\n\t.vidioc_dqbuf = vb2_ioctl_dqbuf,\n\t.vidioc_expbuf = vb2_ioctl_expbuf,\n\t.vidioc_streamon = vb2_ioctl_streamon,\n\t.vidioc_streamoff = vb2_ioctl_streamoff,\n\n\t.vidioc_log_status = v4l2_ctrl_log_status,\n\t.vidioc_subscribe_event = v4l2_ctrl_subscribe_event,\n\t.vidioc_unsubscribe_event = v4l2_event_unsubscribe,\n};\n\n \nstatic const struct v4l2_file_operations skel_fops = {\n\t.owner = THIS_MODULE,\n\t.open = v4l2_fh_open,\n\t.release = vb2_fop_release,\n\t.unlocked_ioctl = video_ioctl2,\n\t.read = vb2_fop_read,\n\t.mmap = vb2_fop_mmap,\n\t.poll = vb2_fop_poll,\n};\n\n \nstatic int skeleton_probe(struct pci_dev *pdev, const struct pci_device_id *ent)\n{\n\t \n\tstatic const struct v4l2_dv_timings timings_def =\n\t\tV4L2_DV_BT_CEA_1280X720P60;\n\tstruct skeleton *skel;\n\tstruct video_device *vdev;\n\tstruct v4l2_ctrl_handler *hdl;\n\tstruct vb2_queue *q;\n\tint ret;\n\n\t \n\tret = pci_enable_device(pdev);\n\tif (ret)\n\t\treturn ret;\n\tret = dma_set_mask(&pdev->dev, DMA_BIT_MASK(32));\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"no suitable DMA available.\\n\");\n\t\tgoto disable_pci;\n\t}\n\n\t \n\tskel = devm_kzalloc(&pdev->dev, sizeof(struct skeleton), GFP_KERNEL);\n\tif (!skel) {\n\t\tret = -ENOMEM;\n\t\tgoto disable_pci;\n\t}\n\n\t \n\tret = devm_request_irq(&pdev->dev, pdev->irq,\n\t\t\t       skeleton_irq, 0, KBUILD_MODNAME, skel);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"request_irq failed\\n\");\n\t\tgoto disable_pci;\n\t}\n\tskel->pdev = pdev;\n\n\t \n\tskel->timings = timings_def;\n\tskel->std = V4L2_STD_625_50;\n\tskeleton_fill_pix_format(skel, &skel->format);\n\n\t \n\tret = v4l2_device_register(&pdev->dev, &skel->v4l2_dev);\n\tif (ret)\n\t\tgoto disable_pci;\n\n\tmutex_init(&skel->lock);\n\n\t \n\thdl = &skel->ctrl_handler;\n\tv4l2_ctrl_handler_init(hdl, 4);\n\tv4l2_ctrl_new_std(hdl, &skel_ctrl_ops,\n\t\t\t  V4L2_CID_BRIGHTNESS, 0, 255, 1, 127);\n\tv4l2_ctrl_new_std(hdl, &skel_ctrl_ops,\n\t\t\t  V4L2_CID_CONTRAST, 0, 255, 1, 16);\n\tv4l2_ctrl_new_std(hdl, &skel_ctrl_ops,\n\t\t\t  V4L2_CID_SATURATION, 0, 255, 1, 127);\n\tv4l2_ctrl_new_std(hdl, &skel_ctrl_ops,\n\t\t\t  V4L2_CID_HUE, -128, 127, 1, 0);\n\tif (hdl->error) {\n\t\tret = hdl->error;\n\t\tgoto free_hdl;\n\t}\n\tskel->v4l2_dev.ctrl_handler = hdl;\n\n\t \n\tq = &skel->queue;\n\tq->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\n\tq->io_modes = VB2_MMAP | VB2_DMABUF | VB2_READ;\n\tq->dev = &pdev->dev;\n\tq->drv_priv = skel;\n\tq->buf_struct_size = sizeof(struct skel_buffer);\n\tq->ops = &skel_qops;\n\tq->mem_ops = &vb2_dma_contig_memops;\n\tq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;\n\t \n\tq->min_buffers_needed = 2;\n\t \n\tq->lock = &skel->lock;\n\t \n\tq->gfp_flags = GFP_DMA32;\n\tret = vb2_queue_init(q);\n\tif (ret)\n\t\tgoto free_hdl;\n\n\tINIT_LIST_HEAD(&skel->buf_list);\n\tspin_lock_init(&skel->qlock);\n\n\t \n\tvdev = &skel->vdev;\n\tstrlcpy(vdev->name, KBUILD_MODNAME, sizeof(vdev->name));\n\t \n\tvdev->release = video_device_release_empty;\n\tvdev->fops = &skel_fops,\n\tvdev->ioctl_ops = &skel_ioctl_ops,\n\tvdev->device_caps = V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_READWRITE |\n\t\t\t    V4L2_CAP_STREAMING;\n\t \n\tvdev->lock = &skel->lock;\n\tvdev->queue = q;\n\tvdev->v4l2_dev = &skel->v4l2_dev;\n\t \n\tvdev->tvnorms = SKEL_TVNORMS;\n\tvideo_set_drvdata(vdev, skel);\n\n\tret = video_register_device(vdev, VFL_TYPE_VIDEO, -1);\n\tif (ret)\n\t\tgoto free_hdl;\n\n\tdev_info(&pdev->dev, \"V4L2 PCI Skeleton Driver loaded\\n\");\n\treturn 0;\n\nfree_hdl:\n\tv4l2_ctrl_handler_free(&skel->ctrl_handler);\n\tv4l2_device_unregister(&skel->v4l2_dev);\ndisable_pci:\n\tpci_disable_device(pdev);\n\treturn ret;\n}\n\nstatic void skeleton_remove(struct pci_dev *pdev)\n{\n\tstruct v4l2_device *v4l2_dev = pci_get_drvdata(pdev);\n\tstruct skeleton *skel = container_of(v4l2_dev, struct skeleton, v4l2_dev);\n\n\tvideo_unregister_device(&skel->vdev);\n\tv4l2_ctrl_handler_free(&skel->ctrl_handler);\n\tv4l2_device_unregister(&skel->v4l2_dev);\n\tpci_disable_device(skel->pdev);\n}\n\nstatic struct pci_driver skeleton_driver = {\n\t.name = KBUILD_MODNAME,\n\t.probe = skeleton_probe,\n\t.remove = skeleton_remove,\n\t.id_table = skeleton_pci_tbl,\n};\n\nmodule_pci_driver(skeleton_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}