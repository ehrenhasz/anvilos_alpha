{
  "module_name": "sandboxer.c",
  "hash_id": "6c9c02ad60b071fa9ddda2a6f45a21b980c53b15adaf38780bf9791aa8212803",
  "original_prompt": "Ingested from linux-6.6.14/samples/landlock/sandboxer.c",
  "human_readable_source": "\n \n\n#define _GNU_SOURCE\n#include <errno.h>\n#include <fcntl.h>\n#include <linux/landlock.h>\n#include <linux/prctl.h>\n#include <stddef.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/prctl.h>\n#include <sys/stat.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n\n#ifndef landlock_create_ruleset\nstatic inline int\nlandlock_create_ruleset(const struct landlock_ruleset_attr *const attr,\n\t\t\tconst size_t size, const __u32 flags)\n{\n\treturn syscall(__NR_landlock_create_ruleset, attr, size, flags);\n}\n#endif\n\n#ifndef landlock_add_rule\nstatic inline int landlock_add_rule(const int ruleset_fd,\n\t\t\t\t    const enum landlock_rule_type rule_type,\n\t\t\t\t    const void *const rule_attr,\n\t\t\t\t    const __u32 flags)\n{\n\treturn syscall(__NR_landlock_add_rule, ruleset_fd, rule_type, rule_attr,\n\t\t       flags);\n}\n#endif\n\n#ifndef landlock_restrict_self\nstatic inline int landlock_restrict_self(const int ruleset_fd,\n\t\t\t\t\t const __u32 flags)\n{\n\treturn syscall(__NR_landlock_restrict_self, ruleset_fd, flags);\n}\n#endif\n\n#define ENV_FS_RO_NAME \"LL_FS_RO\"\n#define ENV_FS_RW_NAME \"LL_FS_RW\"\n#define ENV_PATH_TOKEN \":\"\n\nstatic int parse_path(char *env_path, const char ***const path_list)\n{\n\tint i, num_paths = 0;\n\n\tif (env_path) {\n\t\tnum_paths++;\n\t\tfor (i = 0; env_path[i]; i++) {\n\t\t\tif (env_path[i] == ENV_PATH_TOKEN[0])\n\t\t\t\tnum_paths++;\n\t\t}\n\t}\n\t*path_list = malloc(num_paths * sizeof(**path_list));\n\tfor (i = 0; i < num_paths; i++)\n\t\t(*path_list)[i] = strsep(&env_path, ENV_PATH_TOKEN);\n\n\treturn num_paths;\n}\n\n \n\n#define ACCESS_FILE ( \\\n\tLANDLOCK_ACCESS_FS_EXECUTE | \\\n\tLANDLOCK_ACCESS_FS_WRITE_FILE | \\\n\tLANDLOCK_ACCESS_FS_READ_FILE | \\\n\tLANDLOCK_ACCESS_FS_TRUNCATE)\n\n \n\nstatic int populate_ruleset(const char *const env_var, const int ruleset_fd,\n\t\t\t    const __u64 allowed_access)\n{\n\tint num_paths, i, ret = 1;\n\tchar *env_path_name;\n\tconst char **path_list = NULL;\n\tstruct landlock_path_beneath_attr path_beneath = {\n\t\t.parent_fd = -1,\n\t};\n\n\tenv_path_name = getenv(env_var);\n\tif (!env_path_name) {\n\t\t \n\t\tfprintf(stderr, \"Missing environment variable %s\\n\", env_var);\n\t\treturn 1;\n\t}\n\tenv_path_name = strdup(env_path_name);\n\tunsetenv(env_var);\n\tnum_paths = parse_path(env_path_name, &path_list);\n\tif (num_paths == 1 && path_list[0][0] == '\\0') {\n\t\t \n\t\tret = 0;\n\t\tgoto out_free_name;\n\t}\n\n\tfor (i = 0; i < num_paths; i++) {\n\t\tstruct stat statbuf;\n\n\t\tpath_beneath.parent_fd = open(path_list[i], O_PATH | O_CLOEXEC);\n\t\tif (path_beneath.parent_fd < 0) {\n\t\t\tfprintf(stderr, \"Failed to open \\\"%s\\\": %s\\n\",\n\t\t\t\tpath_list[i], strerror(errno));\n\t\t\tgoto out_free_name;\n\t\t}\n\t\tif (fstat(path_beneath.parent_fd, &statbuf)) {\n\t\t\tclose(path_beneath.parent_fd);\n\t\t\tgoto out_free_name;\n\t\t}\n\t\tpath_beneath.allowed_access = allowed_access;\n\t\tif (!S_ISDIR(statbuf.st_mode))\n\t\t\tpath_beneath.allowed_access &= ACCESS_FILE;\n\t\tif (landlock_add_rule(ruleset_fd, LANDLOCK_RULE_PATH_BENEATH,\n\t\t\t\t      &path_beneath, 0)) {\n\t\t\tfprintf(stderr,\n\t\t\t\t\"Failed to update the ruleset with \\\"%s\\\": %s\\n\",\n\t\t\t\tpath_list[i], strerror(errno));\n\t\t\tclose(path_beneath.parent_fd);\n\t\t\tgoto out_free_name;\n\t\t}\n\t\tclose(path_beneath.parent_fd);\n\t}\n\tret = 0;\n\nout_free_name:\n\tfree(path_list);\n\tfree(env_path_name);\n\treturn ret;\n}\n\n \n\n#define ACCESS_FS_ROUGHLY_READ ( \\\n\tLANDLOCK_ACCESS_FS_EXECUTE | \\\n\tLANDLOCK_ACCESS_FS_READ_FILE | \\\n\tLANDLOCK_ACCESS_FS_READ_DIR)\n\n#define ACCESS_FS_ROUGHLY_WRITE ( \\\n\tLANDLOCK_ACCESS_FS_WRITE_FILE | \\\n\tLANDLOCK_ACCESS_FS_REMOVE_DIR | \\\n\tLANDLOCK_ACCESS_FS_REMOVE_FILE | \\\n\tLANDLOCK_ACCESS_FS_MAKE_CHAR | \\\n\tLANDLOCK_ACCESS_FS_MAKE_DIR | \\\n\tLANDLOCK_ACCESS_FS_MAKE_REG | \\\n\tLANDLOCK_ACCESS_FS_MAKE_SOCK | \\\n\tLANDLOCK_ACCESS_FS_MAKE_FIFO | \\\n\tLANDLOCK_ACCESS_FS_MAKE_BLOCK | \\\n\tLANDLOCK_ACCESS_FS_MAKE_SYM | \\\n\tLANDLOCK_ACCESS_FS_REFER | \\\n\tLANDLOCK_ACCESS_FS_TRUNCATE)\n\n \n\n#define LANDLOCK_ABI_LAST 3\n\nint main(const int argc, char *const argv[], char *const *const envp)\n{\n\tconst char *cmd_path;\n\tchar *const *cmd_argv;\n\tint ruleset_fd, abi;\n\t__u64 access_fs_ro = ACCESS_FS_ROUGHLY_READ,\n\t      access_fs_rw = ACCESS_FS_ROUGHLY_READ | ACCESS_FS_ROUGHLY_WRITE;\n\tstruct landlock_ruleset_attr ruleset_attr = {\n\t\t.handled_access_fs = access_fs_rw,\n\t};\n\n\tif (argc < 2) {\n\t\tfprintf(stderr,\n\t\t\t\"usage: %s=\\\"...\\\" %s=\\\"...\\\" %s <cmd> [args]...\\n\\n\",\n\t\t\tENV_FS_RO_NAME, ENV_FS_RW_NAME, argv[0]);\n\t\tfprintf(stderr,\n\t\t\t\"Launch a command in a restricted environment.\\n\\n\");\n\t\tfprintf(stderr, \"Environment variables containing paths, \"\n\t\t\t\t\"each separated by a colon:\\n\");\n\t\tfprintf(stderr,\n\t\t\t\"* %s: list of paths allowed to be used in a read-only way.\\n\",\n\t\t\tENV_FS_RO_NAME);\n\t\tfprintf(stderr,\n\t\t\t\"* %s: list of paths allowed to be used in a read-write way.\\n\",\n\t\t\tENV_FS_RW_NAME);\n\t\tfprintf(stderr,\n\t\t\t\"\\nexample:\\n\"\n\t\t\t\"%s=\\\"/bin:/lib:/usr:/proc:/etc:/dev/urandom\\\" \"\n\t\t\t\"%s=\\\"/dev/null:/dev/full:/dev/zero:/dev/pts:/tmp\\\" \"\n\t\t\t\"%s bash -i\\n\\n\",\n\t\t\tENV_FS_RO_NAME, ENV_FS_RW_NAME, argv[0]);\n\t\tfprintf(stderr,\n\t\t\t\"This sandboxer can use Landlock features \"\n\t\t\t\"up to ABI version %d.\\n\",\n\t\t\tLANDLOCK_ABI_LAST);\n\t\treturn 1;\n\t}\n\n\tabi = landlock_create_ruleset(NULL, 0, LANDLOCK_CREATE_RULESET_VERSION);\n\tif (abi < 0) {\n\t\tconst int err = errno;\n\n\t\tperror(\"Failed to check Landlock compatibility\");\n\t\tswitch (err) {\n\t\tcase ENOSYS:\n\t\t\tfprintf(stderr,\n\t\t\t\t\"Hint: Landlock is not supported by the current kernel. \"\n\t\t\t\t\"To support it, build the kernel with \"\n\t\t\t\t\"CONFIG_SECURITY_LANDLOCK=y and prepend \"\n\t\t\t\t\"\\\"landlock,\\\" to the content of CONFIG_LSM.\\n\");\n\t\t\tbreak;\n\t\tcase EOPNOTSUPP:\n\t\t\tfprintf(stderr,\n\t\t\t\t\"Hint: Landlock is currently disabled. \"\n\t\t\t\t\"It can be enabled in the kernel configuration by \"\n\t\t\t\t\"prepending \\\"landlock,\\\" to the content of CONFIG_LSM, \"\n\t\t\t\t\"or at boot time by setting the same content to the \"\n\t\t\t\t\"\\\"lsm\\\" kernel parameter.\\n\");\n\t\t\tbreak;\n\t\t}\n\t\treturn 1;\n\t}\n\n\t \n\tswitch (abi) {\n\tcase 1:\n\t\t \n\t\truleset_attr.handled_access_fs &= ~LANDLOCK_ACCESS_FS_REFER;\n\t\t__attribute__((fallthrough));\n\tcase 2:\n\t\t \n\t\truleset_attr.handled_access_fs &= ~LANDLOCK_ACCESS_FS_TRUNCATE;\n\n\t\tfprintf(stderr,\n\t\t\t\"Hint: You should update the running kernel \"\n\t\t\t\"to leverage Landlock features \"\n\t\t\t\"provided by ABI version %d (instead of %d).\\n\",\n\t\t\tLANDLOCK_ABI_LAST, abi);\n\t\t__attribute__((fallthrough));\n\tcase LANDLOCK_ABI_LAST:\n\t\tbreak;\n\tdefault:\n\t\tfprintf(stderr,\n\t\t\t\"Hint: You should update this sandboxer \"\n\t\t\t\"to leverage Landlock features \"\n\t\t\t\"provided by ABI version %d (instead of %d).\\n\",\n\t\t\tabi, LANDLOCK_ABI_LAST);\n\t}\n\taccess_fs_ro &= ruleset_attr.handled_access_fs;\n\taccess_fs_rw &= ruleset_attr.handled_access_fs;\n\n\truleset_fd =\n\t\tlandlock_create_ruleset(&ruleset_attr, sizeof(ruleset_attr), 0);\n\tif (ruleset_fd < 0) {\n\t\tperror(\"Failed to create a ruleset\");\n\t\treturn 1;\n\t}\n\tif (populate_ruleset(ENV_FS_RO_NAME, ruleset_fd, access_fs_ro)) {\n\t\tgoto err_close_ruleset;\n\t}\n\tif (populate_ruleset(ENV_FS_RW_NAME, ruleset_fd, access_fs_rw)) {\n\t\tgoto err_close_ruleset;\n\t}\n\tif (prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0)) {\n\t\tperror(\"Failed to restrict privileges\");\n\t\tgoto err_close_ruleset;\n\t}\n\tif (landlock_restrict_self(ruleset_fd, 0)) {\n\t\tperror(\"Failed to enforce ruleset\");\n\t\tgoto err_close_ruleset;\n\t}\n\tclose(ruleset_fd);\n\n\tcmd_path = argv[1];\n\tcmd_argv = argv + 1;\n\texecvpe(cmd_path, cmd_argv, envp);\n\tfprintf(stderr, \"Failed to execute \\\"%s\\\": %s\\n\", cmd_path,\n\t\tstrerror(errno));\n\tfprintf(stderr, \"Hint: access to the binary, the interpreter or \"\n\t\t\t\"shared libraries may be denied.\\n\");\n\treturn 1;\n\nerr_close_ruleset:\n\tclose(ruleset_fd);\n\treturn 1;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}