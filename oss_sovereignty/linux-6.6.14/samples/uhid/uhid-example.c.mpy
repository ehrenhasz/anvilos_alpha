{
  "module_name": "uhid-example.c",
  "hash_id": "ec138796656a3d1bc5dd07e0f007c6d42683f5ba41ef47b534a9bcaa728a3cd6",
  "original_prompt": "Ingested from linux-6.6.14/samples/uhid/uhid-example.c",
  "human_readable_source": "\n \n\n \n\n#include <errno.h>\n#include <fcntl.h>\n#include <poll.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <termios.h>\n#include <unistd.h>\n#include <linux/uhid.h>\n\n \n\nstatic unsigned char rdesc[] = {\n\t0x05, 0x01,\t \n\t0x09, 0x02,\t \n\t0xa1, 0x01,\t \n\t0x09, 0x01,\t\t \n\t0xa1, 0x00,\t\t \n\t0x85, 0x01,\t\t\t \n\t0x05, 0x09,\t\t\t \n\t0x19, 0x01,\t\t\t \n\t0x29, 0x03,\t\t\t \n\t0x15, 0x00,\t\t\t \n\t0x25, 0x01,\t\t\t \n\t0x95, 0x03,\t\t\t \n\t0x75, 0x01,\t\t\t \n\t0x81, 0x02,\t\t\t \n\t0x95, 0x01,\t\t\t \n\t0x75, 0x05,\t\t\t \n\t0x81, 0x01,\t\t\t \n\t0x05, 0x01,\t\t\t \n\t0x09, 0x30,\t\t\t \n\t0x09, 0x31,\t\t\t \n\t0x09, 0x38,\t\t\t \n\t0x15, 0x81,\t\t\t \n\t0x25, 0x7f,\t\t\t \n\t0x75, 0x08,\t\t\t \n\t0x95, 0x03,\t\t\t \n\t0x81, 0x06,\t\t\t \n\t0xc0,\t\t\t \n\t0xc0,\t\t \n\t0x05, 0x01,\t \n\t0x09, 0x06,\t \n\t0xa1, 0x01,\t \n\t0x85, 0x02,\t\t \n\t0x05, 0x08,\t\t \n\t0x19, 0x01,\t\t \n\t0x29, 0x03,\t\t \n\t0x15, 0x00,\t\t \n\t0x25, 0x01,\t\t \n\t0x95, 0x03,\t\t \n\t0x75, 0x01,\t\t \n\t0x91, 0x02,\t\t \n\t0x95, 0x01,\t\t \n\t0x75, 0x05,\t\t \n\t0x91, 0x01,\t\t \n\t0xc0,\t\t \n};\n\nstatic int uhid_write(int fd, const struct uhid_event *ev)\n{\n\tssize_t ret;\n\n\tret = write(fd, ev, sizeof(*ev));\n\tif (ret < 0) {\n\t\tfprintf(stderr, \"Cannot write to uhid: %m\\n\");\n\t\treturn -errno;\n\t} else if (ret != sizeof(*ev)) {\n\t\tfprintf(stderr, \"Wrong size written to uhid: %zd != %zu\\n\",\n\t\t\tret, sizeof(ev));\n\t\treturn -EFAULT;\n\t} else {\n\t\treturn 0;\n\t}\n}\n\nstatic int create(int fd)\n{\n\tstruct uhid_event ev;\n\n\tmemset(&ev, 0, sizeof(ev));\n\tev.type = UHID_CREATE;\n\tstrcpy((char*)ev.u.create.name, \"test-uhid-device\");\n\tev.u.create.rd_data = rdesc;\n\tev.u.create.rd_size = sizeof(rdesc);\n\tev.u.create.bus = BUS_USB;\n\tev.u.create.vendor = 0x15d9;\n\tev.u.create.product = 0x0a37;\n\tev.u.create.version = 0;\n\tev.u.create.country = 0;\n\n\treturn uhid_write(fd, &ev);\n}\n\nstatic void destroy(int fd)\n{\n\tstruct uhid_event ev;\n\n\tmemset(&ev, 0, sizeof(ev));\n\tev.type = UHID_DESTROY;\n\n\tuhid_write(fd, &ev);\n}\n\n \nstatic void handle_output(struct uhid_event *ev)\n{\n\t \n\tif (ev->u.output.rtype != UHID_OUTPUT_REPORT)\n\t\treturn;\n\t \n\tif (ev->u.output.size != 2)\n\t\treturn;\n\t \n\tif (ev->u.output.data[0] != 0x2)\n\t\treturn;\n\n\t \n\tfprintf(stderr, \"LED output report received with flags %x\\n\",\n\t\tev->u.output.data[1]);\n}\n\nstatic int event(int fd)\n{\n\tstruct uhid_event ev;\n\tssize_t ret;\n\n\tmemset(&ev, 0, sizeof(ev));\n\tret = read(fd, &ev, sizeof(ev));\n\tif (ret == 0) {\n\t\tfprintf(stderr, \"Read HUP on uhid-cdev\\n\");\n\t\treturn -EFAULT;\n\t} else if (ret < 0) {\n\t\tfprintf(stderr, \"Cannot read uhid-cdev: %m\\n\");\n\t\treturn -errno;\n\t} else if (ret != sizeof(ev)) {\n\t\tfprintf(stderr, \"Invalid size read from uhid-dev: %zd != %zu\\n\",\n\t\t\tret, sizeof(ev));\n\t\treturn -EFAULT;\n\t}\n\n\tswitch (ev.type) {\n\tcase UHID_START:\n\t\tfprintf(stderr, \"UHID_START from uhid-dev\\n\");\n\t\tbreak;\n\tcase UHID_STOP:\n\t\tfprintf(stderr, \"UHID_STOP from uhid-dev\\n\");\n\t\tbreak;\n\tcase UHID_OPEN:\n\t\tfprintf(stderr, \"UHID_OPEN from uhid-dev\\n\");\n\t\tbreak;\n\tcase UHID_CLOSE:\n\t\tfprintf(stderr, \"UHID_CLOSE from uhid-dev\\n\");\n\t\tbreak;\n\tcase UHID_OUTPUT:\n\t\tfprintf(stderr, \"UHID_OUTPUT from uhid-dev\\n\");\n\t\thandle_output(&ev);\n\t\tbreak;\n\tcase UHID_OUTPUT_EV:\n\t\tfprintf(stderr, \"UHID_OUTPUT_EV from uhid-dev\\n\");\n\t\tbreak;\n\tdefault:\n\t\tfprintf(stderr, \"Invalid event from uhid-dev: %u\\n\", ev.type);\n\t}\n\n\treturn 0;\n}\n\nstatic bool btn1_down;\nstatic bool btn2_down;\nstatic bool btn3_down;\nstatic signed char abs_hor;\nstatic signed char abs_ver;\nstatic signed char wheel;\n\nstatic int send_event(int fd)\n{\n\tstruct uhid_event ev;\n\n\tmemset(&ev, 0, sizeof(ev));\n\tev.type = UHID_INPUT;\n\tev.u.input.size = 5;\n\n\tev.u.input.data[0] = 0x1;\n\tif (btn1_down)\n\t\tev.u.input.data[1] |= 0x1;\n\tif (btn2_down)\n\t\tev.u.input.data[1] |= 0x2;\n\tif (btn3_down)\n\t\tev.u.input.data[1] |= 0x4;\n\n\tev.u.input.data[2] = abs_hor;\n\tev.u.input.data[3] = abs_ver;\n\tev.u.input.data[4] = wheel;\n\n\treturn uhid_write(fd, &ev);\n}\n\nstatic int keyboard(int fd)\n{\n\tchar buf[128];\n\tssize_t ret, i;\n\n\tret = read(STDIN_FILENO, buf, sizeof(buf));\n\tif (ret == 0) {\n\t\tfprintf(stderr, \"Read HUP on stdin\\n\");\n\t\treturn -EFAULT;\n\t} else if (ret < 0) {\n\t\tfprintf(stderr, \"Cannot read stdin: %m\\n\");\n\t\treturn -errno;\n\t}\n\n\tfor (i = 0; i < ret; ++i) {\n\t\tswitch (buf[i]) {\n\t\tcase '1':\n\t\t\tbtn1_down = !btn1_down;\n\t\t\tret = send_event(fd);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tbreak;\n\t\tcase '2':\n\t\t\tbtn2_down = !btn2_down;\n\t\t\tret = send_event(fd);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tbreak;\n\t\tcase '3':\n\t\t\tbtn3_down = !btn3_down;\n\t\t\tret = send_event(fd);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tbreak;\n\t\tcase 'a':\n\t\t\tabs_hor = -20;\n\t\t\tret = send_event(fd);\n\t\t\tabs_hor = 0;\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tabs_hor = 20;\n\t\t\tret = send_event(fd);\n\t\t\tabs_hor = 0;\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tbreak;\n\t\tcase 'w':\n\t\t\tabs_ver = -20;\n\t\t\tret = send_event(fd);\n\t\t\tabs_ver = 0;\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tabs_ver = 20;\n\t\t\tret = send_event(fd);\n\t\t\tabs_ver = 0;\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tbreak;\n\t\tcase 'r':\n\t\t\twheel = 1;\n\t\t\tret = send_event(fd);\n\t\t\twheel = 0;\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\twheel = -1;\n\t\t\tret = send_event(fd);\n\t\t\twheel = 0;\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tbreak;\n\t\tcase 'q':\n\t\t\treturn -ECANCELED;\n\t\tdefault:\n\t\t\tfprintf(stderr, \"Invalid input: %c\\n\", buf[i]);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint main(int argc, char **argv)\n{\n\tint fd;\n\tconst char *path = \"/dev/uhid\";\n\tstruct pollfd pfds[2];\n\tint ret;\n\tstruct termios state;\n\n\tret = tcgetattr(STDIN_FILENO, &state);\n\tif (ret) {\n\t\tfprintf(stderr, \"Cannot get tty state\\n\");\n\t} else {\n\t\tstate.c_lflag &= ~ICANON;\n\t\tstate.c_cc[VMIN] = 1;\n\t\tret = tcsetattr(STDIN_FILENO, TCSANOW, &state);\n\t\tif (ret)\n\t\t\tfprintf(stderr, \"Cannot set tty state\\n\");\n\t}\n\n\tif (argc >= 2) {\n\t\tif (!strcmp(argv[1], \"-h\") || !strcmp(argv[1], \"--help\")) {\n\t\t\tfprintf(stderr, \"Usage: %s [%s]\\n\", argv[0], path);\n\t\t\treturn EXIT_SUCCESS;\n\t\t} else {\n\t\t\tpath = argv[1];\n\t\t}\n\t}\n\n\tfprintf(stderr, \"Open uhid-cdev %s\\n\", path);\n\tfd = open(path, O_RDWR | O_CLOEXEC);\n\tif (fd < 0) {\n\t\tfprintf(stderr, \"Cannot open uhid-cdev %s: %m\\n\", path);\n\t\treturn EXIT_FAILURE;\n\t}\n\n\tfprintf(stderr, \"Create uhid device\\n\");\n\tret = create(fd);\n\tif (ret) {\n\t\tclose(fd);\n\t\treturn EXIT_FAILURE;\n\t}\n\n\tpfds[0].fd = STDIN_FILENO;\n\tpfds[0].events = POLLIN;\n\tpfds[1].fd = fd;\n\tpfds[1].events = POLLIN;\n\n\tfprintf(stderr, \"Press 'q' to quit...\\n\");\n\twhile (1) {\n\t\tret = poll(pfds, 2, -1);\n\t\tif (ret < 0) {\n\t\t\tfprintf(stderr, \"Cannot poll for fds: %m\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tif (pfds[0].revents & POLLHUP) {\n\t\t\tfprintf(stderr, \"Received HUP on stdin\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tif (pfds[1].revents & POLLHUP) {\n\t\t\tfprintf(stderr, \"Received HUP on uhid-cdev\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tif (pfds[0].revents & POLLIN) {\n\t\t\tret = keyboard(fd);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (pfds[1].revents & POLLIN) {\n\t\t\tret = event(fd);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tfprintf(stderr, \"Destroy uhid device\\n\");\n\tdestroy(fd);\n\treturn EXIT_SUCCESS;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}