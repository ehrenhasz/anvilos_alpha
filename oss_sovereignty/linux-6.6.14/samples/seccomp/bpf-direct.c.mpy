{
  "module_name": "bpf-direct.c",
  "hash_id": "2d432f7147d22c46434fbccb02090f6c474b3e40efb3ec5fbde6beb5cd67a118",
  "original_prompt": "Ingested from linux-6.6.14/samples/seccomp/bpf-direct.c",
  "human_readable_source": "\n \n#if defined(__i386__) || defined(__x86_64__)\n#define SUPPORTED_ARCH 1\n#endif\n\n#if defined(SUPPORTED_ARCH)\n#define __USE_GNU 1\n#define _GNU_SOURCE 1\n\n#include <linux/types.h>\n#include <linux/filter.h>\n#include <linux/seccomp.h>\n#include <linux/unistd.h>\n#include <signal.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <string.h>\n#include <sys/prctl.h>\n#include <unistd.h>\n\n#define syscall_arg(_n) (offsetof(struct seccomp_data, args[_n]))\n#define syscall_nr (offsetof(struct seccomp_data, nr))\n\n#if defined(__i386__)\n#define REG_RESULT\tREG_EAX\n#define REG_SYSCALL\tREG_EAX\n#define REG_ARG0\tREG_EBX\n#define REG_ARG1\tREG_ECX\n#define REG_ARG2\tREG_EDX\n#define REG_ARG3\tREG_ESI\n#define REG_ARG4\tREG_EDI\n#define REG_ARG5\tREG_EBP\n#elif defined(__x86_64__)\n#define REG_RESULT\tREG_RAX\n#define REG_SYSCALL\tREG_RAX\n#define REG_ARG0\tREG_RDI\n#define REG_ARG1\tREG_RSI\n#define REG_ARG2\tREG_RDX\n#define REG_ARG3\tREG_R10\n#define REG_ARG4\tREG_R8\n#define REG_ARG5\tREG_R9\n#endif\n\n#ifndef PR_SET_NO_NEW_PRIVS\n#define PR_SET_NO_NEW_PRIVS 38\n#endif\n\n#ifndef SYS_SECCOMP\n#define SYS_SECCOMP 1\n#endif\n\nstatic void emulator(int nr, siginfo_t *info, void *void_context)\n{\n\tucontext_t *ctx = (ucontext_t *)(void_context);\n\tint syscall;\n\tchar *buf;\n\tssize_t bytes;\n\tsize_t len;\n\tif (info->si_code != SYS_SECCOMP)\n\t\treturn;\n\tif (!ctx)\n\t\treturn;\n\tsyscall = ctx->uc_mcontext.gregs[REG_SYSCALL];\n\tbuf = (char *) ctx->uc_mcontext.gregs[REG_ARG1];\n\tlen = (size_t) ctx->uc_mcontext.gregs[REG_ARG2];\n\n\tif (syscall != __NR_write)\n\t\treturn;\n\tif (ctx->uc_mcontext.gregs[REG_ARG0] != STDERR_FILENO)\n\t\treturn;\n\t \n\tctx->uc_mcontext.gregs[REG_RESULT] = -1;\n\tif (write(STDOUT_FILENO, \"[ERR] \", 6) > 0) {\n\t\tbytes = write(STDOUT_FILENO, buf, len);\n\t\tctx->uc_mcontext.gregs[REG_RESULT] = bytes;\n\t}\n\treturn;\n}\n\nstatic int install_emulator(void)\n{\n\tstruct sigaction act;\n\tsigset_t mask;\n\tmemset(&act, 0, sizeof(act));\n\tsigemptyset(&mask);\n\tsigaddset(&mask, SIGSYS);\n\n\tact.sa_sigaction = &emulator;\n\tact.sa_flags = SA_SIGINFO;\n\tif (sigaction(SIGSYS, &act, NULL) < 0) {\n\t\tperror(\"sigaction\");\n\t\treturn -1;\n\t}\n\tif (sigprocmask(SIG_UNBLOCK, &mask, NULL)) {\n\t\tperror(\"sigprocmask\");\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int install_filter(void)\n{\n\tstruct sock_filter filter[] = {\n\t\t \n\t\tBPF_STMT(BPF_LD+BPF_W+BPF_ABS, syscall_nr),\n\t\t \n\t\tBPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, __NR_rt_sigreturn, 0, 1),\n\t\tBPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_ALLOW),\n#ifdef __NR_sigreturn\n\t\tBPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, __NR_sigreturn, 0, 1),\n\t\tBPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_ALLOW),\n#endif\n\t\tBPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, __NR_exit_group, 0, 1),\n\t\tBPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_ALLOW),\n\t\tBPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, __NR_exit, 0, 1),\n\t\tBPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_ALLOW),\n\t\tBPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, __NR_read, 1, 0),\n\t\tBPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, __NR_write, 3, 2),\n\n\t\t \n\t\tBPF_STMT(BPF_LD+BPF_W+BPF_ABS, syscall_arg(0)),\n\t\tBPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, STDIN_FILENO, 4, 0),\n\t\tBPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_KILL),\n\n\t\t \n\t\tBPF_STMT(BPF_LD+BPF_W+BPF_ABS, syscall_arg(0)),\n\t\tBPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, STDOUT_FILENO, 1, 0),\n\t\t \n\t\tBPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, STDERR_FILENO, 1, 2),\n\n\t\tBPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_ALLOW),\n\t\tBPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_TRAP),\n\t\tBPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_KILL),\n\t};\n\tstruct sock_fprog prog = {\n\t\t.len = (unsigned short)(sizeof(filter)/sizeof(filter[0])),\n\t\t.filter = filter,\n\t};\n\n\tif (prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0)) {\n\t\tperror(\"prctl(NO_NEW_PRIVS)\");\n\t\treturn 1;\n\t}\n\n\n\tif (prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &prog)) {\n\t\tperror(\"prctl\");\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n#define payload(_c) (_c), sizeof((_c))\nint main(int argc, char **argv)\n{\n\tchar buf[4096];\n\tssize_t bytes = 0;\n\tif (install_emulator())\n\t\treturn 1;\n\tif (install_filter())\n\t\treturn 1;\n\tsyscall(__NR_write, STDOUT_FILENO,\n\t\tpayload(\"OHAI! WHAT IS YOUR NAME? \"));\n\tbytes = syscall(__NR_read, STDIN_FILENO, buf, sizeof(buf));\n\tsyscall(__NR_write, STDOUT_FILENO, payload(\"HELLO, \"));\n\tsyscall(__NR_write, STDOUT_FILENO, buf, bytes);\n\tsyscall(__NR_write, STDERR_FILENO,\n\t\tpayload(\"Error message going to STDERR\\n\"));\n\treturn 0;\n}\n#else\t \n \nint main(void)\n{\n\treturn 1;\n}\n#endif\t \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}