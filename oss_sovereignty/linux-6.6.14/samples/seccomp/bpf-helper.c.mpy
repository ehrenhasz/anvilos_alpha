{
  "module_name": "bpf-helper.c",
  "hash_id": "5353b240d81d881941c763b22fff86a5e6f88d0bce5cf4386417ab674b719bc7",
  "original_prompt": "Ingested from linux-6.6.14/samples/seccomp/bpf-helper.c",
  "human_readable_source": "\n \n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"bpf-helper.h\"\n\nint bpf_resolve_jumps(struct bpf_labels *labels,\n\t\t      struct sock_filter *filter, size_t count)\n{\n\tsize_t i;\n\n\tif (count < 1 || count > BPF_MAXINSNS)\n\t\treturn -1;\n\t \n\tfor (i = 0; i < count; ++i) {\n\t\tsize_t offset = count - i - 1;\n\t\tstruct sock_filter *instr = &filter[offset];\n\t\tif (instr->code != (BPF_JMP+BPF_JA))\n\t\t\tcontinue;\n\t\tswitch ((instr->jt<<8)|instr->jf) {\n\t\tcase (JUMP_JT<<8)|JUMP_JF:\n\t\t\tif (labels->labels[instr->k].location == 0xffffffff) {\n\t\t\t\tfprintf(stderr, \"Unresolved label: '%s'\\n\",\n\t\t\t\t\tlabels->labels[instr->k].label);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tinstr->k = labels->labels[instr->k].location -\n\t\t\t\t    (offset + 1);\n\t\t\tinstr->jt = 0;\n\t\t\tinstr->jf = 0;\n\t\t\tcontinue;\n\t\tcase (LABEL_JT<<8)|LABEL_JF:\n\t\t\tif (labels->labels[instr->k].location != 0xffffffff) {\n\t\t\t\tfprintf(stderr, \"Duplicate label use: '%s'\\n\",\n\t\t\t\t\tlabels->labels[instr->k].label);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tlabels->labels[instr->k].location = offset;\n\t\t\tinstr->k = 0;  \n\t\t\tinstr->jt = 0;\n\t\t\tinstr->jf = 0;\n\t\t\tcontinue;\n\t\t}\n\t}\n\treturn 0;\n}\n\n \n__u32 seccomp_bpf_label(struct bpf_labels *labels, const char *label)\n{\n\tstruct __bpf_label *begin = labels->labels, *end;\n\tint id;\n\n\tif (labels->count == BPF_LABELS_MAX) {\n\t\tfprintf(stderr, \"Too many labels\\n\");\n\t\texit(1);\n\t}\n\tif (labels->count == 0) {\n\t\tbegin->label = label;\n\t\tbegin->location = 0xffffffff;\n\t\tlabels->count++;\n\t\treturn 0;\n\t}\n\tend = begin + labels->count;\n\tfor (id = 0; begin < end; ++begin, ++id) {\n\t\tif (!strcmp(label, begin->label))\n\t\t\treturn id;\n\t}\n\tbegin->label = label;\n\tbegin->location = 0xffffffff;\n\tlabels->count++;\n\treturn id;\n}\n\nvoid seccomp_bpf_print(struct sock_filter *filter, size_t count)\n{\n\tstruct sock_filter *end = filter + count;\n\tfor ( ; filter < end; ++filter)\n\t\tprintf(\"{ code=%u,jt=%u,jf=%u,k=%u },\\n\",\n\t\t\tfilter->code, filter->jt, filter->jf, filter->k);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}