{
  "module_name": "bpf-helper.h",
  "hash_id": "8c94c9a63f55c3c188c5e594ae55d6518f17a6c5c5d21c1104453c3843abbdd8",
  "original_prompt": "Ingested from linux-6.6.14/samples/seccomp/bpf-helper.h",
  "human_readable_source": " \n \n#ifndef __BPF_HELPER_H__\n#define __BPF_HELPER_H__\n\n#include <asm/bitsperlong.h>\t \n#include <endian.h>\n#include <linux/filter.h>\n#include <linux/seccomp.h>\t \n#include <linux/types.h>\n#include <linux/unistd.h>\n#include <stddef.h>\n\n#define BPF_LABELS_MAX 256\nstruct bpf_labels {\n\tint count;\n\tstruct __bpf_label {\n\t\tconst char *label;\n\t\t__u32 location;\n\t} labels[BPF_LABELS_MAX];\n};\n\nint bpf_resolve_jumps(struct bpf_labels *labels,\n\t\t      struct sock_filter *filter, size_t count);\n__u32 seccomp_bpf_label(struct bpf_labels *labels, const char *label);\nvoid seccomp_bpf_print(struct sock_filter *filter, size_t count);\n\n#define JUMP_JT 0xff\n#define JUMP_JF 0xff\n#define LABEL_JT 0xfe\n#define LABEL_JF 0xfe\n\n#define ALLOW \\\n\tBPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_ALLOW)\n#define DENY \\\n\tBPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_KILL)\n#define JUMP(labels, label) \\\n\tBPF_JUMP(BPF_JMP+BPF_JA, FIND_LABEL((labels), (label)), \\\n\t\t JUMP_JT, JUMP_JF)\n#define LABEL(labels, label) \\\n\tBPF_JUMP(BPF_JMP+BPF_JA, FIND_LABEL((labels), (label)), \\\n\t\t LABEL_JT, LABEL_JF)\n#define SYSCALL(nr, jt) \\\n\tBPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, (nr), 0, 1), \\\n\tjt\n\n \n#define FIND_LABEL(labels, label) seccomp_bpf_label((labels), #label)\n\n#define EXPAND(...) __VA_ARGS__\n\n \n#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__\n#define LO_ARG(idx) offsetof(struct seccomp_data, args[(idx)])\n#elif __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__\n#define LO_ARG(idx) offsetof(struct seccomp_data, args[(idx)]) + sizeof(__u32)\n#else\n#error \"Unknown endianness\"\n#endif\n\n \n#if __BITS_PER_LONG == 32\n\n#define JEQ(x, jt) JEQ32(x, EXPAND(jt))\n#define JNE(x, jt) JNE32(x, EXPAND(jt))\n#define JGT(x, jt) JGT32(x, EXPAND(jt))\n#define JLT(x, jt) JLT32(x, EXPAND(jt))\n#define JGE(x, jt) JGE32(x, EXPAND(jt))\n#define JLE(x, jt) JLE32(x, EXPAND(jt))\n#define JA(x, jt) JA32(x, EXPAND(jt))\n#define ARG(i) ARG_32(i)\n\n#elif __BITS_PER_LONG == 64\n\n \n#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__\n#define ENDIAN(_lo, _hi) _lo, _hi\n#define HI_ARG(idx) offsetof(struct seccomp_data, args[(idx)]) + sizeof(__u32)\n#elif __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__\n#define ENDIAN(_lo, _hi) _hi, _lo\n#define HI_ARG(idx) offsetof(struct seccomp_data, args[(idx)])\n#endif\n\nunion arg64 {\n\tstruct {\n\t\t__u32 ENDIAN(lo32, hi32);\n\t};\n\t__u64 u64;\n};\n\n#define JEQ(x, jt) \\\n\tJEQ64(((union arg64){.u64 = (x)}).lo32, \\\n\t      ((union arg64){.u64 = (x)}).hi32, \\\n\t      EXPAND(jt))\n#define JGT(x, jt) \\\n\tJGT64(((union arg64){.u64 = (x)}).lo32, \\\n\t      ((union arg64){.u64 = (x)}).hi32, \\\n\t      EXPAND(jt))\n#define JGE(x, jt) \\\n\tJGE64(((union arg64){.u64 = (x)}).lo32, \\\n\t      ((union arg64){.u64 = (x)}).hi32, \\\n\t      EXPAND(jt))\n#define JNE(x, jt) \\\n\tJNE64(((union arg64){.u64 = (x)}).lo32, \\\n\t      ((union arg64){.u64 = (x)}).hi32, \\\n\t      EXPAND(jt))\n#define JLT(x, jt) \\\n\tJLT64(((union arg64){.u64 = (x)}).lo32, \\\n\t      ((union arg64){.u64 = (x)}).hi32, \\\n\t      EXPAND(jt))\n#define JLE(x, jt) \\\n\tJLE64(((union arg64){.u64 = (x)}).lo32, \\\n\t      ((union arg64){.u64 = (x)}).hi32, \\\n\t      EXPAND(jt))\n\n#define JA(x, jt) \\\n\tJA64(((union arg64){.u64 = (x)}).lo32, \\\n\t       ((union arg64){.u64 = (x)}).hi32, \\\n\t       EXPAND(jt))\n#define ARG(i) ARG_64(i)\n\n#else\n#error __BITS_PER_LONG value unusable.\n#endif\n\n \n#define ARG_32(idx) \\\n\tBPF_STMT(BPF_LD+BPF_W+BPF_ABS, LO_ARG(idx))\n\n \n#define ARG_64(idx) \\\n\tBPF_STMT(BPF_LD+BPF_W+BPF_ABS, LO_ARG(idx)), \\\n\tBPF_STMT(BPF_ST, 0),   \\\n\tBPF_STMT(BPF_LD+BPF_W+BPF_ABS, HI_ARG(idx)), \\\n\tBPF_STMT(BPF_ST, 1)  \n\n#define JEQ32(value, jt) \\\n\tBPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, (value), 0, 1), \\\n\tjt\n\n#define JNE32(value, jt) \\\n\tBPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, (value), 1, 0), \\\n\tjt\n\n#define JA32(value, jt) \\\n\tBPF_JUMP(BPF_JMP+BPF_JSET+BPF_K, (value), 0, 1), \\\n\tjt\n\n#define JGE32(value, jt) \\\n\tBPF_JUMP(BPF_JMP+BPF_JGE+BPF_K, (value), 0, 1), \\\n\tjt\n\n#define JGT32(value, jt) \\\n\tBPF_JUMP(BPF_JMP+BPF_JGT+BPF_K, (value), 0, 1), \\\n\tjt\n\n#define JLE32(value, jt) \\\n\tBPF_JUMP(BPF_JMP+BPF_JGT+BPF_K, (value), 1, 0), \\\n\tjt\n\n#define JLT32(value, jt) \\\n\tBPF_JUMP(BPF_JMP+BPF_JGE+BPF_K, (value), 1, 0), \\\n\tjt\n\n \n#define JEQ64(lo, hi, jt) \\\n\t  \\\n\tBPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, (hi), 0, 5), \\\n\tBPF_STMT(BPF_LD+BPF_MEM, 0),   \\\n\t  \\\n\tBPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, (lo), 0, 2), \\\n\tBPF_STMT(BPF_LD+BPF_MEM, 1), \\\n\tjt, \\\n\tBPF_STMT(BPF_LD+BPF_MEM, 1)\n\n#define JNE64(lo, hi, jt) \\\n\t  \\\n\tBPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, (hi), 0, 3), \\\n\tBPF_STMT(BPF_LD+BPF_MEM, 0), \\\n\t  \\\n\tBPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, (lo), 2, 0), \\\n\tBPF_STMT(BPF_LD+BPF_MEM, 1), \\\n\tjt, \\\n\tBPF_STMT(BPF_LD+BPF_MEM, 1)\n\n#define JA64(lo, hi, jt) \\\n\t  \\\n\tBPF_JUMP(BPF_JMP+BPF_JSET+BPF_K, (hi), 3, 0), \\\n\tBPF_STMT(BPF_LD+BPF_MEM, 0), \\\n\t  \\\n\tBPF_JUMP(BPF_JMP+BPF_JSET+BPF_K, (lo), 0, 2), \\\n\tBPF_STMT(BPF_LD+BPF_MEM, 1), \\\n\tjt, \\\n\tBPF_STMT(BPF_LD+BPF_MEM, 1)\n\n#define JGE64(lo, hi, jt) \\\n\t  \\\n\tBPF_JUMP(BPF_JMP+BPF_JGT+BPF_K, (hi), 4, 0), \\\n\t  \\\n\tBPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, (hi), 0, 5), \\\n\tBPF_STMT(BPF_LD+BPF_MEM, 0), \\\n\t  \\\n\tBPF_JUMP(BPF_JMP+BPF_JGE+BPF_K, (lo), 0, 2), \\\n\tBPF_STMT(BPF_LD+BPF_MEM, 1), \\\n\tjt, \\\n\tBPF_STMT(BPF_LD+BPF_MEM, 1)\n\n#define JGT64(lo, hi, jt) \\\n\t  \\\n\tBPF_JUMP(BPF_JMP+BPF_JGT+BPF_K, (hi), 4, 0), \\\n\t  \\\n\tBPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, (hi), 0, 5), \\\n\tBPF_STMT(BPF_LD+BPF_MEM, 0), \\\n\t  \\\n\tBPF_JUMP(BPF_JMP+BPF_JGT+BPF_K, (lo), 0, 2), \\\n\tBPF_STMT(BPF_LD+BPF_MEM, 1), \\\n\tjt, \\\n\tBPF_STMT(BPF_LD+BPF_MEM, 1)\n\n#define JLE64(lo, hi, jt) \\\n\t  \\\n\tBPF_JUMP(BPF_JMP+BPF_JGE+BPF_K, (hi), 0, 4), \\\n\t  \\\n\tBPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, (hi), 0, 5), \\\n\tBPF_STMT(BPF_LD+BPF_MEM, 0), \\\n\t  \\\n\tBPF_JUMP(BPF_JMP+BPF_JGT+BPF_K, (lo), 2, 0), \\\n\tBPF_STMT(BPF_LD+BPF_MEM, 1), \\\n\tjt, \\\n\tBPF_STMT(BPF_LD+BPF_MEM, 1)\n\n#define JLT64(lo, hi, jt) \\\n\t  \\\n\tBPF_JUMP(BPF_JMP+BPF_JGE+BPF_K, (hi), 0, 4), \\\n\t  \\\n\tBPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, (hi), 0, 5), \\\n\tBPF_STMT(BPF_LD+BPF_MEM, 0), \\\n\t  \\\n\tBPF_JUMP(BPF_JMP+BPF_JGE+BPF_K, (lo), 2, 0), \\\n\tBPF_STMT(BPF_LD+BPF_MEM, 1), \\\n\tjt, \\\n\tBPF_STMT(BPF_LD+BPF_MEM, 1)\n\n#define LOAD_SYSCALL_NR \\\n\tBPF_STMT(BPF_LD+BPF_W+BPF_ABS, \\\n\t\t offsetof(struct seccomp_data, nr))\n\n#endif   \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}