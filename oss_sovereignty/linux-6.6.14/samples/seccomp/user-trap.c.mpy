{
  "module_name": "user-trap.c",
  "hash_id": "969794922d0c6c0bab0cfbf38dc00bdabb109a5b626f6c3d5e29606b67360be5",
  "original_prompt": "Ingested from linux-6.6.14/samples/seccomp/user-trap.c",
  "human_readable_source": "#include <signal.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <string.h>\n#include <stddef.h>\n#include <sys/sysmacros.h>\n#include <sys/types.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/mman.h>\n#include <sys/syscall.h>\n#include <sys/user.h>\n#include <sys/ioctl.h>\n#include <sys/ptrace.h>\n#include <sys/mount.h>\n#include <linux/limits.h>\n#include <linux/filter.h>\n#include <linux/seccomp.h>\n\n#define ARRAY_SIZE(x) (sizeof(x) / sizeof(*(x)))\n\nstatic int seccomp(unsigned int op, unsigned int flags, void *args)\n{\n\terrno = 0;\n\treturn syscall(__NR_seccomp, op, flags, args);\n}\n\nstatic int send_fd(int sock, int fd)\n{\n\tstruct msghdr msg = {};\n\tstruct cmsghdr *cmsg;\n\tchar buf[CMSG_SPACE(sizeof(int))] = {0}, c = 'c';\n\tstruct iovec io = {\n\t\t.iov_base = &c,\n\t\t.iov_len = 1,\n\t};\n\n\tmsg.msg_iov = &io;\n\tmsg.msg_iovlen = 1;\n\tmsg.msg_control = buf;\n\tmsg.msg_controllen = sizeof(buf);\n\tcmsg = CMSG_FIRSTHDR(&msg);\n\tcmsg->cmsg_level = SOL_SOCKET;\n\tcmsg->cmsg_type = SCM_RIGHTS;\n\tcmsg->cmsg_len = CMSG_LEN(sizeof(int));\n\t*((int *)CMSG_DATA(cmsg)) = fd;\n\tmsg.msg_controllen = cmsg->cmsg_len;\n\n\tif (sendmsg(sock, &msg, 0) < 0) {\n\t\tperror(\"sendmsg\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic int recv_fd(int sock)\n{\n\tstruct msghdr msg = {};\n\tstruct cmsghdr *cmsg;\n\tchar buf[CMSG_SPACE(sizeof(int))] = {0}, c = 'c';\n\tstruct iovec io = {\n\t\t.iov_base = &c,\n\t\t.iov_len = 1,\n\t};\n\n\tmsg.msg_iov = &io;\n\tmsg.msg_iovlen = 1;\n\tmsg.msg_control = buf;\n\tmsg.msg_controllen = sizeof(buf);\n\n\tif (recvmsg(sock, &msg, 0) < 0) {\n\t\tperror(\"recvmsg\");\n\t\treturn -1;\n\t}\n\n\tcmsg = CMSG_FIRSTHDR(&msg);\n\n\treturn *((int *)CMSG_DATA(cmsg));\n}\n\nstatic int user_trap_syscall(int nr, unsigned int flags)\n{\n\tstruct sock_filter filter[] = {\n\t\tBPF_STMT(BPF_LD+BPF_W+BPF_ABS,\n\t\t\toffsetof(struct seccomp_data, nr)),\n\t\tBPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, nr, 0, 1),\n\t\tBPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_USER_NOTIF),\n\t\tBPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_ALLOW),\n\t};\n\n\tstruct sock_fprog prog = {\n\t\t.len = (unsigned short)ARRAY_SIZE(filter),\n\t\t.filter = filter,\n\t};\n\n\treturn seccomp(SECCOMP_SET_MODE_FILTER, flags, &prog);\n}\n\nstatic int handle_req(struct seccomp_notif *req,\n\t\t      struct seccomp_notif_resp *resp, int listener)\n{\n\tchar path[PATH_MAX], source[PATH_MAX], target[PATH_MAX];\n\tint ret = -1, mem;\n\n\tresp->id = req->id;\n\tresp->error = -EPERM;\n\tresp->val = 0;\n\n\tif (req->data.nr != __NR_mount) {\n\t\tfprintf(stderr, \"huh? trapped something besides mount? %d\\n\", req->data.nr);\n\t\treturn -1;\n\t}\n\n\t \n\tif (!(req->data.args[3] & MS_BIND))\n\t\treturn 0;\n\n\t \n\tsnprintf(path, sizeof(path), \"/proc/%d/mem\", req->pid);\n\tmem = open(path, O_RDONLY);\n\tif (mem < 0) {\n\t\tperror(\"open mem\");\n\t\treturn -1;\n\t}\n\n\t \n\tif (ioctl(listener, SECCOMP_IOCTL_NOTIF_ID_VALID, &req->id) < 0) {\n\t\tfprintf(stderr, \"task died before we could map its memory\\n\");\n\t\tgoto out;\n\t}\n\n\t \n\tif (lseek(mem, req->data.args[0], SEEK_SET) < 0) {\n\t\tperror(\"seek\");\n\t\tgoto out;\n\t}\n\n\tret = read(mem, source, sizeof(source));\n\tif (ret < 0) {\n\t\tperror(\"read\");\n\t\tgoto out;\n\t}\n\n\tif (lseek(mem, req->data.args[1], SEEK_SET) < 0) {\n\t\tperror(\"seek\");\n\t\tgoto out;\n\t}\n\n\tret = read(mem, target, sizeof(target));\n\tif (ret < 0) {\n\t\tperror(\"read\");\n\t\tgoto out;\n\t}\n\n\t \n\tif (!strncmp(source, \"/tmp/\", 5) && !strncmp(target, \"/tmp/\", 5)) {\n\t\tif (mount(source, target, NULL, req->data.args[3], NULL) < 0) {\n\t\t\tret = -1;\n\t\t\tperror(\"actual mount\");\n\t\t\tgoto out;\n\t\t}\n\t\tresp->error = 0;\n\t}\n\n\t \n\tret = 0;\n\nout:\n\tclose(mem);\n\treturn ret;\n}\n\nint main(void)\n{\n\tint sk_pair[2], ret = 1, status, listener;\n\tpid_t worker = 0 , tracer = 0;\n\n\tif (socketpair(PF_LOCAL, SOCK_SEQPACKET, 0, sk_pair) < 0) {\n\t\tperror(\"socketpair\");\n\t\treturn 1;\n\t}\n\n\tworker = fork();\n\tif (worker < 0) {\n\t\tperror(\"fork\");\n\t\tgoto close_pair;\n\t}\n\n\tif (worker == 0) {\n\t\tlistener = user_trap_syscall(__NR_mount,\n\t\t\t\t\t     SECCOMP_FILTER_FLAG_NEW_LISTENER);\n\t\tif (listener < 0) {\n\t\t\tperror(\"seccomp\");\n\t\t\texit(1);\n\t\t}\n\n\t\t \n\t\tif (setuid(1000) < 0) {\n\t\t\tperror(\"setuid\");\n\t\t\texit(1);\n\t\t}\n\n\t\t \n\t\tif (send_fd(sk_pair[1], listener) < 0)\n\t\t\texit(1);\n\t\tclose(listener);\n\n\t\tif (mkdir(\"/tmp/foo\", 0755) < 0) {\n\t\t\tperror(\"mkdir\");\n\t\t\texit(1);\n\t\t}\n\n\t\t \n\t\tif (mount(\"/dev/sda\", \"/tmp/foo\", NULL, 0, NULL) != -1) {\n\t\t\tfprintf(stderr, \"huh? mounted /dev/sda?\\n\");\n\t\t\texit(1);\n\t\t}\n\n\t\tif (errno != EPERM) {\n\t\t\tperror(\"bad error from mount\");\n\t\t\texit(1);\n\t\t}\n\n\t\t \n\t\tif (mount(\"/tmp/foo\", \"/tmp/foo\", NULL, MS_BIND, NULL) < 0) {\n\t\t\tperror(\"mount\");\n\t\t\texit(1);\n\t\t}\n\n\t\texit(0);\n\t}\n\n\t \n\tlistener = recv_fd(sk_pair[0]);\n\tif (listener < 0)\n\t\tgoto out_kill;\n\n\t \n\ttracer = fork();\n\tif (tracer < 0) {\n\t\tperror(\"fork\");\n\t\tgoto out_kill;\n\t}\n\n\tif (tracer == 0) {\n\t\tstruct seccomp_notif *req;\n\t\tstruct seccomp_notif_resp *resp;\n\t\tstruct seccomp_notif_sizes sizes;\n\n\t\tif (seccomp(SECCOMP_GET_NOTIF_SIZES, 0, &sizes) < 0) {\n\t\t\tperror(\"seccomp(GET_NOTIF_SIZES)\");\n\t\t\tgoto out_close;\n\t\t}\n\n\t\treq = malloc(sizes.seccomp_notif);\n\t\tif (!req)\n\t\t\tgoto out_close;\n\n\t\tresp = malloc(sizes.seccomp_notif_resp);\n\t\tif (!resp)\n\t\t\tgoto out_req;\n\t\tmemset(resp, 0, sizes.seccomp_notif_resp);\n\n\t\twhile (1) {\n\t\t\tmemset(req, 0, sizes.seccomp_notif);\n\t\t\tif (ioctl(listener, SECCOMP_IOCTL_NOTIF_RECV, req)) {\n\t\t\t\tperror(\"ioctl recv\");\n\t\t\t\tgoto out_resp;\n\t\t\t}\n\n\t\t\tif (handle_req(req, resp, listener) < 0)\n\t\t\t\tgoto out_resp;\n\n\t\t\t \n\t\t\tif (ioctl(listener, SECCOMP_IOCTL_NOTIF_SEND, resp) < 0 &&\n\t\t\t    errno != ENOENT) {\n\t\t\t\tperror(\"ioctl send\");\n\t\t\t\tgoto out_resp;\n\t\t\t}\n\t\t}\nout_resp:\n\t\tfree(resp);\nout_req:\n\t\tfree(req);\nout_close:\n\t\tclose(listener);\n\t\texit(1);\n\t}\n\n\tclose(listener);\n\n\tif (waitpid(worker, &status, 0) != worker) {\n\t\tperror(\"waitpid\");\n\t\tgoto out_kill;\n\t}\n\n\tif (umount2(\"/tmp/foo\", MNT_DETACH) < 0 && errno != EINVAL) {\n\t\tperror(\"umount2\");\n\t\tgoto out_kill;\n\t}\n\n\tif (remove(\"/tmp/foo\") < 0 && errno != ENOENT) {\n\t\tperror(\"remove\");\n\t\texit(1);\n\t}\n\n\tif (!WIFEXITED(status) || WEXITSTATUS(status)) {\n\t\tfprintf(stderr, \"worker exited nonzero\\n\");\n\t\tgoto out_kill;\n\t}\n\n\tret = 0;\n\nout_kill:\n\tif (tracer > 0)\n\t\tkill(tracer, SIGKILL);\n\tif (worker > 0)\n\t\tkill(worker, SIGKILL);\n\nclose_pair:\n\tclose(sk_pair[0]);\n\tclose(sk_pair[1]);\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}