{
  "module_name": "pidfd-metadata.c",
  "hash_id": "1c60a5c8cf5a3077991a096234be328ef4ed6c1519fabe7870fbe07037999b42",
  "original_prompt": "Ingested from linux-6.6.14/samples/pidfd/pidfd-metadata.c",
  "human_readable_source": "\n\n#define _GNU_SOURCE\n#include <err.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <inttypes.h>\n#include <limits.h>\n#include <sched.h>\n#include <signal.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/syscall.h>\n#include <sys/types.h>\n#include <sys/wait.h>\n#include <unistd.h>\n\n#ifndef CLONE_PIDFD\n#define CLONE_PIDFD 0x00001000\n#endif\n\n#ifndef __NR_pidfd_send_signal\n#define __NR_pidfd_send_signal -1\n#endif\n\nstatic int do_child(void *args)\n{\n\tprintf(\"%d\\n\", getpid());\n\t_exit(EXIT_SUCCESS);\n}\n\nstatic pid_t pidfd_clone(int flags, int *pidfd)\n{\n\tsize_t stack_size = 1024;\n\tchar *stack[1024] = { 0 };\n\n#ifdef __ia64__\n\treturn __clone2(do_child, stack, stack_size, flags | SIGCHLD, NULL, pidfd);\n#else\n\treturn clone(do_child, stack + stack_size, flags | SIGCHLD, NULL, pidfd);\n#endif\n}\n\nstatic inline int sys_pidfd_send_signal(int pidfd, int sig, siginfo_t *info,\n\t\t\t\t\tunsigned int flags)\n{\n\treturn syscall(__NR_pidfd_send_signal, pidfd, sig, info, flags);\n}\n\nstatic int pidfd_metadata_fd(pid_t pid, int pidfd)\n{\n\tint procfd, ret;\n\tchar path[100];\n\n\tsnprintf(path, sizeof(path), \"/proc/%d\", pid);\n\tprocfd = open(path, O_DIRECTORY | O_RDONLY | O_CLOEXEC);\n\tif (procfd < 0) {\n\t\twarn(\"Failed to open %s\\n\", path);\n\t\treturn -1;\n\t}\n\n\t \n\tret = sys_pidfd_send_signal(pidfd, 0, NULL, 0);\n\tif (ret < 0) {\n\t\tswitch (errno) {\n\t\tcase EPERM:\n\t\t\t \n\t\t\tbreak;\n\t\tdefault:\n\t\t\twarn(\"Failed to signal process\\n\");\n\t\t\tclose(procfd);\n\t\t\tprocfd = -1;\n\t\t}\n\t}\n\n\treturn procfd;\n}\n\nint main(int argc, char *argv[])\n{\n\tint pidfd = -1, ret = EXIT_FAILURE;\n\tchar buf[4096] = { 0 };\n\tpid_t pid;\n\tint procfd, statusfd;\n\tssize_t bytes;\n\n\tpid = pidfd_clone(CLONE_PIDFD, &pidfd);\n\tif (pid < 0)\n\t\terr(ret, \"CLONE_PIDFD\");\n\tif (pidfd == -1) {\n\t\twarnx(\"CLONE_PIDFD is not supported by the kernel\");\n\t\tgoto out;\n\t}\n\n\tprocfd = pidfd_metadata_fd(pid, pidfd);\n\tclose(pidfd);\n\tif (procfd < 0)\n\t\tgoto out;\n\n\tstatusfd = openat(procfd, \"status\", O_RDONLY | O_CLOEXEC);\n\tclose(procfd);\n\tif (statusfd < 0)\n\t\tgoto out;\n\n\tbytes = read(statusfd, buf, sizeof(buf));\n\tif (bytes > 0)\n\t\tbytes = write(STDOUT_FILENO, buf, bytes);\n\tclose(statusfd);\n\tret = EXIT_SUCCESS;\n\nout:\n\t(void)wait(NULL);\n\n\texit(ret);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}