{
  "module_name": "vm-sample.c",
  "hash_id": "147bc1c3e4b79fb5e8c539efcee326792c4e5958ac20012083858bc4ca62fae9",
  "original_prompt": "Ingested from linux-6.6.14/samples/acrn/vm-sample.c",
  "human_readable_source": "\n \n#include <stdio.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <signal.h>\n#include <sys/ioctl.h>\n#include <linux/acrn.h>\n\n#define GUEST_MEMORY_SIZE\t(1024*1024)\nvoid *guest_memory;\n\nextern const unsigned char guest16[], guest16_end[];\nstatic char io_request_page[4096] __attribute__((aligned(4096)));\nstatic struct acrn_io_request *io_req_buf = (struct acrn_io_request *)io_request_page;\n\n__u16 vcpu_num;\n__u16 vmid;\n\nint hsm_fd;\nint is_running = 1;\n\nvoid vm_exit(int sig)\n{\n\tsig = sig;\n\n\tis_running = 0;\n\tioctl(hsm_fd, ACRN_IOCTL_PAUSE_VM, vmid);\n\tioctl(hsm_fd, ACRN_IOCTL_DESTROY_IOREQ_CLIENT, 0);\n}\n\nint main(int argc, char **argv)\n{\n\tint vcpu_id, ret;\n\tstruct acrn_vm_creation create_vm = {0};\n\tstruct acrn_vm_memmap ram_map = {0};\n\tstruct acrn_vcpu_regs regs;\n\tstruct acrn_io_request *io_req;\n\tstruct acrn_ioreq_notify __attribute__((aligned(8))) notify;\n\n\targc = argc;\n\targv = argv;\n\n\tret = posix_memalign(&guest_memory, 4096, GUEST_MEMORY_SIZE);\n\tif (ret < 0) {\n\t\tprintf(\"No enough memory!\\n\");\n\t\treturn -1;\n\t}\n\thsm_fd = open(\"/dev/acrn_hsm\", O_RDWR|O_CLOEXEC);\n\n\tcreate_vm.ioreq_buf = (__u64)io_req_buf;\n\tret = ioctl(hsm_fd, ACRN_IOCTL_CREATE_VM, &create_vm);\n\tprintf(\"Created VM! [%d]\\n\", ret);\n\tvcpu_num = create_vm.vcpu_num;\n\tvmid = create_vm.vmid;\n\n\t \n\tram_map.type = ACRN_MEMMAP_RAM;\n\tram_map.vma_base = (__u64)guest_memory;\n\tram_map.len = GUEST_MEMORY_SIZE;\n\tram_map.user_vm_pa = 0;\n\tram_map.attr = ACRN_MEM_ACCESS_RWX;\n\tret = ioctl(hsm_fd, ACRN_IOCTL_SET_MEMSEG, &ram_map);\n\tprintf(\"Set up VM memory! [%d]\\n\", ret);\n\n\tmemcpy(guest_memory, guest16, guest16_end-guest16);\n\n\t \n\tmemset(&regs, 0, sizeof(regs));\n\tregs.vcpu_id = 0;\n\tregs.vcpu_regs.rip = 0;\n\n\t \n\tregs.vcpu_regs.cr0 = 0x30U;\n\tregs.vcpu_regs.cs_ar = 0x009FU;\n\tregs.vcpu_regs.cs_sel = 0xF000U;\n\tregs.vcpu_regs.cs_limit = 0xFFFFU;\n\tregs.vcpu_regs.cs_base = 0 & 0xFFFF0000UL;\n\tregs.vcpu_regs.rip = 0 & 0xFFFFUL;\n\n\tret = ioctl(hsm_fd, ACRN_IOCTL_SET_VCPU_REGS, &regs);\n\tprintf(\"Set up VM BSP registers! [%d]\\n\", ret);\n\n\t \n\tret = ioctl(hsm_fd, ACRN_IOCTL_CREATE_IOREQ_CLIENT, 0);\n\tprintf(\"Created IO request client! [%d]\\n\", ret);\n\n\t \n\tret = ioctl(hsm_fd, ACRN_IOCTL_START_VM, vmid);\n\tprintf(\"Start VM! [%d]\\n\", ret);\n\n\tsignal(SIGINT, vm_exit);\n\twhile (is_running) {\n\t\tret = ioctl(hsm_fd, ACRN_IOCTL_ATTACH_IOREQ_CLIENT, 0);\n\n\t\tfor (vcpu_id = 0; vcpu_id < vcpu_num; vcpu_id++) {\n\t\t\tio_req = &io_req_buf[vcpu_id];\n\t\t\tif ((__sync_add_and_fetch(&io_req->processed, 0) == ACRN_IOREQ_STATE_PROCESSING)\n\t\t\t\t\t&& (!io_req->kernel_handled))\n\t\t\t\tif (io_req->type == ACRN_IOREQ_TYPE_PORTIO) {\n\t\t\t\t\tint bytes, port, in;\n\n\t\t\t\t\tport = io_req->reqs.pio_request.address;\n\t\t\t\t\tbytes = io_req->reqs.pio_request.size;\n\t\t\t\t\tin = (io_req->reqs.pio_request.direction == ACRN_IOREQ_DIR_READ);\n\t\t\t\t\tprintf(\"Guest VM %s PIO[%x] with size[%x]\\n\", in ? \"read\" : \"write\", port, bytes);\n\n\t\t\t\t\tnotify.vmid = vmid;\n\t\t\t\t\tnotify.vcpu = vcpu_id;\n\t\t\t\t\tioctl(hsm_fd, ACRN_IOCTL_NOTIFY_REQUEST_FINISH, &notify);\n\t\t\t\t}\n\t\t}\n\t}\n\n\tret = ioctl(hsm_fd, ACRN_IOCTL_DESTROY_VM, NULL);\n\tprintf(\"Destroy VM! [%d]\\n\", ret);\n\tclose(hsm_fd);\n\tfree(guest_memory);\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}