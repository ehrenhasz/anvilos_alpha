{
  "module_name": "ftrace-ops.c",
  "hash_id": "9953eb7da380e50c286f2805c410d5b14645b8fb1d4466b0119535659b499cfa",
  "original_prompt": "Ingested from linux-6.6.14/samples/ftrace/ftrace-ops.c",
  "human_readable_source": "\n\n#define pr_fmt(fmt)       KBUILD_MODNAME \": \" fmt\n\n#include <linux/ftrace.h>\n#include <linux/ktime.h>\n#include <linux/module.h>\n\n#include <asm/barrier.h>\n\n \nstatic unsigned int nr_function_calls = 100000;\nmodule_param(nr_function_calls, uint, 0);\nMODULE_PARM_DESC(nr_function_calls, \"How many times to call the relevant tracee\");\n\n \nstatic unsigned int nr_ops_relevant = 1;\nmodule_param(nr_ops_relevant, uint, 0);\nMODULE_PARM_DESC(nr_ops_relevant, \"How many ftrace_ops to associate with the relevant tracee\");\n\n \nstatic unsigned int nr_ops_irrelevant;\nmodule_param(nr_ops_irrelevant, uint, 0);\nMODULE_PARM_DESC(nr_ops_irrelevant, \"How many ftrace_ops to associate with the irrelevant tracee\");\n\n \nstatic bool save_regs;\nmodule_param(save_regs, bool, 0);\nMODULE_PARM_DESC(save_regs, \"Register ops with FTRACE_OPS_FL_SAVE_REGS (save all registers in the trampoline)\");\n\nstatic bool assist_recursion;\nmodule_param(assist_recursion, bool, 0);\nMODULE_PARM_DESC(assist_reursion, \"Register ops with FTRACE_OPS_FL_RECURSION\");\n\nstatic bool assist_rcu;\nmodule_param(assist_rcu, bool, 0);\nMODULE_PARM_DESC(assist_reursion, \"Register ops with FTRACE_OPS_FL_RCU\");\n\n \nstatic bool check_count;\nmodule_param(check_count, bool, 0);\nMODULE_PARM_DESC(check_count, \"Check that tracers are called the expected number of times\\n\");\n\n \nstatic bool persist;\nmodule_param(persist, bool, 0);\nMODULE_PARM_DESC(persist, \"Successfully load module and leave ftrace ops registered after test completes\\n\");\n\n \nstatic noinline void tracee_relevant(void)\n{\n\tbarrier();\n}\n\n \nstatic noinline void tracee_irrelevant(void)\n{\n\tbarrier();\n}\n\nstruct sample_ops {\n\tstruct ftrace_ops ops;\n\tunsigned int count;\n};\n\nstatic void ops_func_nop(unsigned long ip, unsigned long parent_ip,\n\t\t\t struct ftrace_ops *op,\n\t\t\t struct ftrace_regs *fregs)\n{\n\t \n}\n\nstatic void ops_func_count(unsigned long ip, unsigned long parent_ip,\n\t\t\t   struct ftrace_ops *op,\n\t\t\t   struct ftrace_regs *fregs)\n{\n\tstruct sample_ops *self;\n\n\tself = container_of(op, struct sample_ops, ops);\n\tself->count++;\n}\n\nstatic struct sample_ops *ops_relevant;\nstatic struct sample_ops *ops_irrelevant;\n\nstatic struct sample_ops *ops_alloc_init(void *tracee, ftrace_func_t func,\n\t\t\t\t\t unsigned long flags, int nr)\n{\n\tstruct sample_ops *ops;\n\n\tops = kcalloc(nr, sizeof(*ops), GFP_KERNEL);\n\tif (WARN_ON_ONCE(!ops))\n\t\treturn NULL;\n\n\tfor (unsigned int i = 0; i < nr; i++) {\n\t\tops[i].ops.func = func;\n\t\tops[i].ops.flags = flags;\n\t\tWARN_ON_ONCE(ftrace_set_filter_ip(&ops[i].ops, (unsigned long)tracee, 0, 0));\n\t\tWARN_ON_ONCE(register_ftrace_function(&ops[i].ops));\n\t}\n\n\treturn ops;\n}\n\nstatic void ops_destroy(struct sample_ops *ops, int nr)\n{\n\tif (!ops)\n\t\treturn;\n\n\tfor (unsigned int i = 0; i < nr; i++) {\n\t\tWARN_ON_ONCE(unregister_ftrace_function(&ops[i].ops));\n\t\tftrace_free_filter(&ops[i].ops);\n\t}\n\n\tkfree(ops);\n}\n\nstatic void ops_check(struct sample_ops *ops, int nr,\n\t\t      unsigned int expected_count)\n{\n\tif (!ops || !check_count)\n\t\treturn;\n\n\tfor (unsigned int i = 0; i < nr; i++) {\n\t\tif (ops->count == expected_count)\n\t\t\tcontinue;\n\t\tpr_warn(\"Counter called %u times (expected %u)\\n\",\n\t\t\tops->count, expected_count);\n\t}\n}\n\nstatic ftrace_func_t tracer_relevant = ops_func_nop;\nstatic ftrace_func_t tracer_irrelevant = ops_func_nop;\n\nstatic int __init ftrace_ops_sample_init(void)\n{\n\tunsigned long flags = 0;\n\tktime_t start, end;\n\tu64 period;\n\n\tif (!IS_ENABLED(CONFIG_DYNAMIC_FTRACE_WITH_REGS) && save_regs) {\n\t\tpr_info(\"this kernel does not support saving registers\\n\");\n\t\tsave_regs = false;\n\t} else if (save_regs) {\n\t\tflags |= FTRACE_OPS_FL_SAVE_REGS;\n\t}\n\n\tif (assist_recursion)\n\t\tflags |= FTRACE_OPS_FL_RECURSION;\n\n\tif (assist_rcu)\n\t\tflags |= FTRACE_OPS_FL_RCU;\n\n\tif (check_count) {\n\t\ttracer_relevant = ops_func_count;\n\t\ttracer_irrelevant = ops_func_count;\n\t}\n\n\tpr_info(\"registering:\\n\"\n\t\t\"  relevant ops: %u\\n\"\n\t\t\"    tracee: %ps\\n\"\n\t\t\"    tracer: %ps\\n\"\n\t\t\"  irrelevant ops: %u\\n\"\n\t\t\"    tracee: %ps\\n\"\n\t\t\"    tracer: %ps\\n\"\n\t\t\"  saving registers: %s\\n\"\n\t\t\"  assist recursion: %s\\n\"\n\t\t\"  assist RCU: %s\\n\",\n\t\tnr_ops_relevant, tracee_relevant, tracer_relevant,\n\t\tnr_ops_irrelevant, tracee_irrelevant, tracer_irrelevant,\n\t\tsave_regs ? \"YES\" : \"NO\",\n\t\tassist_recursion ? \"YES\" : \"NO\",\n\t\tassist_rcu ? \"YES\" : \"NO\");\n\n\tops_relevant = ops_alloc_init(tracee_relevant, tracer_relevant,\n\t\t\t\t      flags, nr_ops_relevant);\n\tops_irrelevant = ops_alloc_init(tracee_irrelevant, tracer_irrelevant,\n\t\t\t\t\tflags, nr_ops_irrelevant);\n\n\tstart = ktime_get();\n\tfor (unsigned int i = 0; i < nr_function_calls; i++)\n\t\ttracee_relevant();\n\tend = ktime_get();\n\n\tops_check(ops_relevant, nr_ops_relevant, nr_function_calls);\n\tops_check(ops_irrelevant, nr_ops_irrelevant, 0);\n\n\tperiod = ktime_to_ns(ktime_sub(end, start));\n\n\tpr_info(\"Attempted %u calls to %ps in %lluns (%lluns / call)\\n\",\n\t\tnr_function_calls, tracee_relevant,\n\t\tperiod, div_u64(period, nr_function_calls));\n\n\tif (persist)\n\t\treturn 0;\n\n\tops_destroy(ops_relevant, nr_ops_relevant);\n\tops_destroy(ops_irrelevant, nr_ops_irrelevant);\n\n\t \n\treturn -EINVAL;\n}\nmodule_init(ftrace_ops_sample_init);\n\nstatic void __exit ftrace_ops_sample_exit(void)\n{\n\tops_destroy(ops_relevant, nr_ops_relevant);\n\tops_destroy(ops_irrelevant, nr_ops_irrelevant);\n}\nmodule_exit(ftrace_ops_sample_exit);\n\nMODULE_AUTHOR(\"Mark Rutland\");\nMODULE_DESCRIPTION(\"Example of using custom ftrace_ops\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}