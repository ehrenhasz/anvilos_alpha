{
  "module_name": "fs-monitor.c",
  "hash_id": "e65950b0fb197ee5adc282da233a5c04661f61d78b91f9b2e4859a19da0ef842",
  "original_prompt": "Ingested from linux-6.6.14/samples/fanotify/fs-monitor.c",
  "human_readable_source": "\n \n\n#define _GNU_SOURCE\n#include <errno.h>\n#include <err.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sys/fanotify.h>\n#include <sys/types.h>\n#include <unistd.h>\n\n#ifndef FAN_FS_ERROR\n#define FAN_FS_ERROR\t\t0x00008000\n#define FAN_EVENT_INFO_TYPE_ERROR\t5\n\nstruct fanotify_event_info_error {\n\tstruct fanotify_event_info_header hdr;\n\t__s32 error;\n\t__u32 error_count;\n};\n#endif\n\n#ifndef FILEID_INO32_GEN\n#define FILEID_INO32_GEN\t1\n#endif\n\n#ifndef FILEID_INVALID\n#define\tFILEID_INVALID\t\t0xff\n#endif\n\nstatic void print_fh(struct file_handle *fh)\n{\n\tint i;\n\tuint32_t *h = (uint32_t *) fh->f_handle;\n\n\tprintf(\"\\tfh: \");\n\tfor (i = 0; i < fh->handle_bytes; i++)\n\t\tprintf(\"%hhx\", fh->f_handle[i]);\n\tprintf(\"\\n\");\n\n\tprintf(\"\\tdecoded fh: \");\n\tif (fh->handle_type == FILEID_INO32_GEN)\n\t\tprintf(\"inode=%u gen=%u\\n\", h[0], h[1]);\n\telse if (fh->handle_type == FILEID_INVALID && !fh->handle_bytes)\n\t\tprintf(\"Type %d (Superblock error)\\n\", fh->handle_type);\n\telse\n\t\tprintf(\"Type %d (Unknown)\\n\", fh->handle_type);\n\n}\n\nstatic void handle_notifications(char *buffer, int len)\n{\n\tstruct fanotify_event_metadata *event =\n\t\t(struct fanotify_event_metadata *) buffer;\n\tstruct fanotify_event_info_header *info;\n\tstruct fanotify_event_info_error *err;\n\tstruct fanotify_event_info_fid *fid;\n\tint off;\n\n\tfor (; FAN_EVENT_OK(event, len); event = FAN_EVENT_NEXT(event, len)) {\n\n\t\tif (event->mask != FAN_FS_ERROR) {\n\t\t\tprintf(\"unexpected FAN MARK: %llx\\n\",\n\t\t\t\t\t\t\t(unsigned long long)event->mask);\n\t\t\tgoto next_event;\n\t\t}\n\n\t\tif (event->fd != FAN_NOFD) {\n\t\t\tprintf(\"Unexpected fd (!= FAN_NOFD)\\n\");\n\t\t\tgoto next_event;\n\t\t}\n\n\t\tprintf(\"FAN_FS_ERROR (len=%d)\\n\", event->event_len);\n\n\t\tfor (off = sizeof(*event) ; off < event->event_len;\n\t\t     off += info->len) {\n\t\t\tinfo = (struct fanotify_event_info_header *)\n\t\t\t\t((char *) event + off);\n\n\t\t\tswitch (info->info_type) {\n\t\t\tcase FAN_EVENT_INFO_TYPE_ERROR:\n\t\t\t\terr = (struct fanotify_event_info_error *) info;\n\n\t\t\t\tprintf(\"\\tGeneric Error Record: len=%d\\n\",\n\t\t\t\t       err->hdr.len);\n\t\t\t\tprintf(\"\\terror: %d\\n\", err->error);\n\t\t\t\tprintf(\"\\terror_count: %d\\n\", err->error_count);\n\t\t\t\tbreak;\n\n\t\t\tcase FAN_EVENT_INFO_TYPE_FID:\n\t\t\t\tfid = (struct fanotify_event_info_fid *) info;\n\n\t\t\t\tprintf(\"\\tfsid: %x%x\\n\",\n\t\t\t\t       fid->fsid.val[0], fid->fsid.val[1]);\n\t\t\t\tprint_fh((struct file_handle *) &fid->handle);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tprintf(\"\\tUnknown info type=%d len=%d:\\n\",\n\t\t\t\t       info->info_type, info->len);\n\t\t\t}\n\t\t}\nnext_event:\n\t\tprintf(\"---\\n\\n\");\n\t}\n}\n\nint main(int argc, char **argv)\n{\n\tint fd;\n\n\tchar buffer[BUFSIZ];\n\n\tif (argc < 2) {\n\t\tprintf(\"Missing path argument\\n\");\n\t\treturn 1;\n\t}\n\n\tfd = fanotify_init(FAN_CLASS_NOTIF|FAN_REPORT_FID, O_RDONLY);\n\tif (fd < 0)\n\t\terrx(1, \"fanotify_init\");\n\n\tif (fanotify_mark(fd, FAN_MARK_ADD|FAN_MARK_FILESYSTEM,\n\t\t\t  FAN_FS_ERROR, AT_FDCWD, argv[1])) {\n\t\terrx(1, \"fanotify_mark\");\n\t}\n\n\twhile (1) {\n\t\tint n = read(fd, buffer, BUFSIZ);\n\n\t\tif (n < 0)\n\t\t\terrx(1, \"read\");\n\n\t\thandle_notifications(buffer, n);\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}