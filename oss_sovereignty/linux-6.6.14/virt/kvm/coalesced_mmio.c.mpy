{
  "module_name": "coalesced_mmio.c",
  "hash_id": "061013b876f63752d214a034f547bbdd21799c0f96d2361dec4dca3cd7507626",
  "original_prompt": "Ingested from linux-6.6.14/virt/kvm/coalesced_mmio.c",
  "human_readable_source": "\n \n\n#include <kvm/iodev.h>\n\n#include <linux/kvm_host.h>\n#include <linux/slab.h>\n#include <linux/kvm.h>\n\n#include \"coalesced_mmio.h\"\n\nstatic inline struct kvm_coalesced_mmio_dev *to_mmio(struct kvm_io_device *dev)\n{\n\treturn container_of(dev, struct kvm_coalesced_mmio_dev, dev);\n}\n\nstatic int coalesced_mmio_in_range(struct kvm_coalesced_mmio_dev *dev,\n\t\t\t\t   gpa_t addr, int len)\n{\n\t \n\tif (len < 0)\n\t\treturn 0;\n\tif (addr + len < addr)\n\t\treturn 0;\n\tif (addr < dev->zone.addr)\n\t\treturn 0;\n\tif (addr + len > dev->zone.addr + dev->zone.size)\n\t\treturn 0;\n\treturn 1;\n}\n\nstatic int coalesced_mmio_has_room(struct kvm_coalesced_mmio_dev *dev, u32 last)\n{\n\tstruct kvm_coalesced_mmio_ring *ring;\n\tunsigned avail;\n\n\t \n\n\t \n\tring = dev->kvm->coalesced_mmio_ring;\n\tavail = (ring->first - last - 1) % KVM_COALESCED_MMIO_MAX;\n\tif (avail == 0) {\n\t\t \n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\nstatic int coalesced_mmio_write(struct kvm_vcpu *vcpu,\n\t\t\t\tstruct kvm_io_device *this, gpa_t addr,\n\t\t\t\tint len, const void *val)\n{\n\tstruct kvm_coalesced_mmio_dev *dev = to_mmio(this);\n\tstruct kvm_coalesced_mmio_ring *ring = dev->kvm->coalesced_mmio_ring;\n\t__u32 insert;\n\n\tif (!coalesced_mmio_in_range(dev, addr, len))\n\t\treturn -EOPNOTSUPP;\n\n\tspin_lock(&dev->kvm->ring_lock);\n\n\tinsert = READ_ONCE(ring->last);\n\tif (!coalesced_mmio_has_room(dev, insert) ||\n\t    insert >= KVM_COALESCED_MMIO_MAX) {\n\t\tspin_unlock(&dev->kvm->ring_lock);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\t \n\n\tring->coalesced_mmio[insert].phys_addr = addr;\n\tring->coalesced_mmio[insert].len = len;\n\tmemcpy(ring->coalesced_mmio[insert].data, val, len);\n\tring->coalesced_mmio[insert].pio = dev->zone.pio;\n\tsmp_wmb();\n\tring->last = (insert + 1) % KVM_COALESCED_MMIO_MAX;\n\tspin_unlock(&dev->kvm->ring_lock);\n\treturn 0;\n}\n\nstatic void coalesced_mmio_destructor(struct kvm_io_device *this)\n{\n\tstruct kvm_coalesced_mmio_dev *dev = to_mmio(this);\n\n\tlist_del(&dev->list);\n\n\tkfree(dev);\n}\n\nstatic const struct kvm_io_device_ops coalesced_mmio_ops = {\n\t.write      = coalesced_mmio_write,\n\t.destructor = coalesced_mmio_destructor,\n};\n\nint kvm_coalesced_mmio_init(struct kvm *kvm)\n{\n\tstruct page *page;\n\n\tpage = alloc_page(GFP_KERNEL_ACCOUNT | __GFP_ZERO);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tkvm->coalesced_mmio_ring = page_address(page);\n\n\t \n\tspin_lock_init(&kvm->ring_lock);\n\tINIT_LIST_HEAD(&kvm->coalesced_zones);\n\n\treturn 0;\n}\n\nvoid kvm_coalesced_mmio_free(struct kvm *kvm)\n{\n\tif (kvm->coalesced_mmio_ring)\n\t\tfree_page((unsigned long)kvm->coalesced_mmio_ring);\n}\n\nint kvm_vm_ioctl_register_coalesced_mmio(struct kvm *kvm,\n\t\t\t\t\t struct kvm_coalesced_mmio_zone *zone)\n{\n\tint ret;\n\tstruct kvm_coalesced_mmio_dev *dev;\n\n\tif (zone->pio != 1 && zone->pio != 0)\n\t\treturn -EINVAL;\n\n\tdev = kzalloc(sizeof(struct kvm_coalesced_mmio_dev),\n\t\t      GFP_KERNEL_ACCOUNT);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\n\tkvm_iodevice_init(&dev->dev, &coalesced_mmio_ops);\n\tdev->kvm = kvm;\n\tdev->zone = *zone;\n\n\tmutex_lock(&kvm->slots_lock);\n\tret = kvm_io_bus_register_dev(kvm,\n\t\t\t\tzone->pio ? KVM_PIO_BUS : KVM_MMIO_BUS,\n\t\t\t\tzone->addr, zone->size, &dev->dev);\n\tif (ret < 0)\n\t\tgoto out_free_dev;\n\tlist_add_tail(&dev->list, &kvm->coalesced_zones);\n\tmutex_unlock(&kvm->slots_lock);\n\n\treturn 0;\n\nout_free_dev:\n\tmutex_unlock(&kvm->slots_lock);\n\tkfree(dev);\n\n\treturn ret;\n}\n\nint kvm_vm_ioctl_unregister_coalesced_mmio(struct kvm *kvm,\n\t\t\t\t\t   struct kvm_coalesced_mmio_zone *zone)\n{\n\tstruct kvm_coalesced_mmio_dev *dev, *tmp;\n\tint r;\n\n\tif (zone->pio != 1 && zone->pio != 0)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&kvm->slots_lock);\n\n\tlist_for_each_entry_safe(dev, tmp, &kvm->coalesced_zones, list) {\n\t\tif (zone->pio == dev->zone.pio &&\n\t\t    coalesced_mmio_in_range(dev, zone->addr, zone->size)) {\n\t\t\tr = kvm_io_bus_unregister_dev(kvm,\n\t\t\t\tzone->pio ? KVM_PIO_BUS : KVM_MMIO_BUS, &dev->dev);\n\t\t\t \n\t\t\tif (r)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tmutex_unlock(&kvm->slots_lock);\n\n\t \n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}