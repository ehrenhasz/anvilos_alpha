{
  "module_name": "irqchip.c",
  "hash_id": "aaed0fc13fb204fc000898479cdc2647b30ddb203bf5672d20d102763ba682a1",
  "original_prompt": "Ingested from linux-6.6.14/virt/kvm/irqchip.c",
  "human_readable_source": "\n \n\n#include <linux/kvm_host.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/export.h>\n#include <trace/events/kvm.h>\n\nint kvm_irq_map_gsi(struct kvm *kvm,\n\t\t    struct kvm_kernel_irq_routing_entry *entries, int gsi)\n{\n\tstruct kvm_irq_routing_table *irq_rt;\n\tstruct kvm_kernel_irq_routing_entry *e;\n\tint n = 0;\n\n\tirq_rt = srcu_dereference_check(kvm->irq_routing, &kvm->irq_srcu,\n\t\t\t\t\tlockdep_is_held(&kvm->irq_lock));\n\tif (irq_rt && gsi < irq_rt->nr_rt_entries) {\n\t\thlist_for_each_entry(e, &irq_rt->map[gsi], link) {\n\t\t\tentries[n] = *e;\n\t\t\t++n;\n\t\t}\n\t}\n\n\treturn n;\n}\n\nint kvm_irq_map_chip_pin(struct kvm *kvm, unsigned irqchip, unsigned pin)\n{\n\tstruct kvm_irq_routing_table *irq_rt;\n\n\tirq_rt = srcu_dereference(kvm->irq_routing, &kvm->irq_srcu);\n\treturn irq_rt->chip[irqchip][pin];\n}\n\nint kvm_send_userspace_msi(struct kvm *kvm, struct kvm_msi *msi)\n{\n\tstruct kvm_kernel_irq_routing_entry route;\n\n\tif (!kvm_arch_irqchip_in_kernel(kvm) || (msi->flags & ~KVM_MSI_VALID_DEVID))\n\t\treturn -EINVAL;\n\n\troute.msi.address_lo = msi->address_lo;\n\troute.msi.address_hi = msi->address_hi;\n\troute.msi.data = msi->data;\n\troute.msi.flags = msi->flags;\n\troute.msi.devid = msi->devid;\n\n\treturn kvm_set_msi(&route, kvm, KVM_USERSPACE_IRQ_SOURCE_ID, 1, false);\n}\n\n \nint kvm_set_irq(struct kvm *kvm, int irq_source_id, u32 irq, int level,\n\t\tbool line_status)\n{\n\tstruct kvm_kernel_irq_routing_entry irq_set[KVM_NR_IRQCHIPS];\n\tint ret = -1, i, idx;\n\n\ttrace_kvm_set_irq(irq, level, irq_source_id);\n\n\t \n\tidx = srcu_read_lock(&kvm->irq_srcu);\n\ti = kvm_irq_map_gsi(kvm, irq_set, irq);\n\tsrcu_read_unlock(&kvm->irq_srcu, idx);\n\n\twhile (i--) {\n\t\tint r;\n\t\tr = irq_set[i].set(&irq_set[i], kvm, irq_source_id, level,\n\t\t\t\t   line_status);\n\t\tif (r < 0)\n\t\t\tcontinue;\n\n\t\tret = r + ((ret < 0) ? 0 : ret);\n\t}\n\n\treturn ret;\n}\n\nstatic void free_irq_routing_table(struct kvm_irq_routing_table *rt)\n{\n\tint i;\n\n\tif (!rt)\n\t\treturn;\n\n\tfor (i = 0; i < rt->nr_rt_entries; ++i) {\n\t\tstruct kvm_kernel_irq_routing_entry *e;\n\t\tstruct hlist_node *n;\n\n\t\thlist_for_each_entry_safe(e, n, &rt->map[i], link) {\n\t\t\thlist_del(&e->link);\n\t\t\tkfree(e);\n\t\t}\n\t}\n\n\tkfree(rt);\n}\n\nvoid kvm_free_irq_routing(struct kvm *kvm)\n{\n\t \n\tstruct kvm_irq_routing_table *rt = rcu_access_pointer(kvm->irq_routing);\n\tfree_irq_routing_table(rt);\n}\n\nstatic int setup_routing_entry(struct kvm *kvm,\n\t\t\t       struct kvm_irq_routing_table *rt,\n\t\t\t       struct kvm_kernel_irq_routing_entry *e,\n\t\t\t       const struct kvm_irq_routing_entry *ue)\n{\n\tstruct kvm_kernel_irq_routing_entry *ei;\n\tint r;\n\tu32 gsi = array_index_nospec(ue->gsi, KVM_MAX_IRQ_ROUTES);\n\n\t \n\thlist_for_each_entry(ei, &rt->map[gsi], link)\n\t\tif (ei->type != KVM_IRQ_ROUTING_IRQCHIP ||\n\t\t    ue->type != KVM_IRQ_ROUTING_IRQCHIP ||\n\t\t    ue->u.irqchip.irqchip == ei->irqchip.irqchip)\n\t\t\treturn -EINVAL;\n\n\te->gsi = gsi;\n\te->type = ue->type;\n\tr = kvm_set_routing_entry(kvm, e, ue);\n\tif (r)\n\t\treturn r;\n\tif (e->type == KVM_IRQ_ROUTING_IRQCHIP)\n\t\trt->chip[e->irqchip.irqchip][e->irqchip.pin] = e->gsi;\n\n\thlist_add_head(&e->link, &rt->map[e->gsi]);\n\n\treturn 0;\n}\n\nvoid __attribute__((weak)) kvm_arch_irq_routing_update(struct kvm *kvm)\n{\n}\n\nbool __weak kvm_arch_can_set_irq_routing(struct kvm *kvm)\n{\n\treturn true;\n}\n\nint kvm_set_irq_routing(struct kvm *kvm,\n\t\t\tconst struct kvm_irq_routing_entry *ue,\n\t\t\tunsigned nr,\n\t\t\tunsigned flags)\n{\n\tstruct kvm_irq_routing_table *new, *old;\n\tstruct kvm_kernel_irq_routing_entry *e;\n\tu32 i, j, nr_rt_entries = 0;\n\tint r;\n\n\tfor (i = 0; i < nr; ++i) {\n\t\tif (ue[i].gsi >= KVM_MAX_IRQ_ROUTES)\n\t\t\treturn -EINVAL;\n\t\tnr_rt_entries = max(nr_rt_entries, ue[i].gsi);\n\t}\n\n\tnr_rt_entries += 1;\n\n\tnew = kzalloc(struct_size(new, map, nr_rt_entries), GFP_KERNEL_ACCOUNT);\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tnew->nr_rt_entries = nr_rt_entries;\n\tfor (i = 0; i < KVM_NR_IRQCHIPS; i++)\n\t\tfor (j = 0; j < KVM_IRQCHIP_NUM_PINS; j++)\n\t\t\tnew->chip[i][j] = -1;\n\n\tfor (i = 0; i < nr; ++i) {\n\t\tr = -ENOMEM;\n\t\te = kzalloc(sizeof(*e), GFP_KERNEL_ACCOUNT);\n\t\tif (!e)\n\t\t\tgoto out;\n\n\t\tr = -EINVAL;\n\t\tswitch (ue->type) {\n\t\tcase KVM_IRQ_ROUTING_MSI:\n\t\t\tif (ue->flags & ~KVM_MSI_VALID_DEVID)\n\t\t\t\tgoto free_entry;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (ue->flags)\n\t\t\t\tgoto free_entry;\n\t\t\tbreak;\n\t\t}\n\t\tr = setup_routing_entry(kvm, new, e, ue);\n\t\tif (r)\n\t\t\tgoto free_entry;\n\t\t++ue;\n\t}\n\n\tmutex_lock(&kvm->irq_lock);\n\told = rcu_dereference_protected(kvm->irq_routing, 1);\n\trcu_assign_pointer(kvm->irq_routing, new);\n\tkvm_irq_routing_update(kvm);\n\tkvm_arch_irq_routing_update(kvm);\n\tmutex_unlock(&kvm->irq_lock);\n\n\tkvm_arch_post_irq_routing_update(kvm);\n\n\tsynchronize_srcu_expedited(&kvm->irq_srcu);\n\n\tnew = old;\n\tr = 0;\n\tgoto out;\n\nfree_entry:\n\tkfree(e);\nout:\n\tfree_irq_routing_table(new);\n\n\treturn r;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}