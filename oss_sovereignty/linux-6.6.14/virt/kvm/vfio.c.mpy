{
  "module_name": "vfio.c",
  "hash_id": "0f5ed4000d69053e5d66c19ebbbff8b5b53aef5109584a75dc3c4e4477a66845",
  "original_prompt": "Ingested from linux-6.6.14/virt/kvm/vfio.c",
  "human_readable_source": "\n \n\n#include <linux/errno.h>\n#include <linux/file.h>\n#include <linux/kvm_host.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/vfio.h>\n#include \"vfio.h\"\n\n#ifdef CONFIG_SPAPR_TCE_IOMMU\n#include <asm/kvm_ppc.h>\n#endif\n\nstruct kvm_vfio_file {\n\tstruct list_head node;\n\tstruct file *file;\n#ifdef CONFIG_SPAPR_TCE_IOMMU\n\tstruct iommu_group *iommu_group;\n#endif\n};\n\nstruct kvm_vfio {\n\tstruct list_head file_list;\n\tstruct mutex lock;\n\tbool noncoherent;\n};\n\nstatic void kvm_vfio_file_set_kvm(struct file *file, struct kvm *kvm)\n{\n\tvoid (*fn)(struct file *file, struct kvm *kvm);\n\n\tfn = symbol_get(vfio_file_set_kvm);\n\tif (!fn)\n\t\treturn;\n\n\tfn(file, kvm);\n\n\tsymbol_put(vfio_file_set_kvm);\n}\n\nstatic bool kvm_vfio_file_enforced_coherent(struct file *file)\n{\n\tbool (*fn)(struct file *file);\n\tbool ret;\n\n\tfn = symbol_get(vfio_file_enforced_coherent);\n\tif (!fn)\n\t\treturn false;\n\n\tret = fn(file);\n\n\tsymbol_put(vfio_file_enforced_coherent);\n\n\treturn ret;\n}\n\nstatic bool kvm_vfio_file_is_valid(struct file *file)\n{\n\tbool (*fn)(struct file *file);\n\tbool ret;\n\n\tfn = symbol_get(vfio_file_is_valid);\n\tif (!fn)\n\t\treturn false;\n\n\tret = fn(file);\n\n\tsymbol_put(vfio_file_is_valid);\n\n\treturn ret;\n}\n\n#ifdef CONFIG_SPAPR_TCE_IOMMU\nstatic struct iommu_group *kvm_vfio_file_iommu_group(struct file *file)\n{\n\tstruct iommu_group *(*fn)(struct file *file);\n\tstruct iommu_group *ret;\n\n\tfn = symbol_get(vfio_file_iommu_group);\n\tif (!fn)\n\t\treturn NULL;\n\n\tret = fn(file);\n\n\tsymbol_put(vfio_file_iommu_group);\n\n\treturn ret;\n}\n\nstatic void kvm_spapr_tce_release_vfio_group(struct kvm *kvm,\n\t\t\t\t\t     struct kvm_vfio_file *kvf)\n{\n\tif (WARN_ON_ONCE(!kvf->iommu_group))\n\t\treturn;\n\n\tkvm_spapr_tce_release_iommu_group(kvm, kvf->iommu_group);\n\tiommu_group_put(kvf->iommu_group);\n\tkvf->iommu_group = NULL;\n}\n#endif\n\n \nstatic void kvm_vfio_update_coherency(struct kvm_device *dev)\n{\n\tstruct kvm_vfio *kv = dev->private;\n\tbool noncoherent = false;\n\tstruct kvm_vfio_file *kvf;\n\n\tlist_for_each_entry(kvf, &kv->file_list, node) {\n\t\tif (!kvm_vfio_file_enforced_coherent(kvf->file)) {\n\t\t\tnoncoherent = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (noncoherent != kv->noncoherent) {\n\t\tkv->noncoherent = noncoherent;\n\n\t\tif (kv->noncoherent)\n\t\t\tkvm_arch_register_noncoherent_dma(dev->kvm);\n\t\telse\n\t\t\tkvm_arch_unregister_noncoherent_dma(dev->kvm);\n\t}\n}\n\nstatic int kvm_vfio_file_add(struct kvm_device *dev, unsigned int fd)\n{\n\tstruct kvm_vfio *kv = dev->private;\n\tstruct kvm_vfio_file *kvf;\n\tstruct file *filp;\n\tint ret = 0;\n\n\tfilp = fget(fd);\n\tif (!filp)\n\t\treturn -EBADF;\n\n\t \n\tif (!kvm_vfio_file_is_valid(filp)) {\n\t\tret = -EINVAL;\n\t\tgoto out_fput;\n\t}\n\n\tmutex_lock(&kv->lock);\n\n\tlist_for_each_entry(kvf, &kv->file_list, node) {\n\t\tif (kvf->file == filp) {\n\t\t\tret = -EEXIST;\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\tkvf = kzalloc(sizeof(*kvf), GFP_KERNEL_ACCOUNT);\n\tif (!kvf) {\n\t\tret = -ENOMEM;\n\t\tgoto out_unlock;\n\t}\n\n\tkvf->file = get_file(filp);\n\tlist_add_tail(&kvf->node, &kv->file_list);\n\n\tkvm_arch_start_assignment(dev->kvm);\n\tkvm_vfio_file_set_kvm(kvf->file, dev->kvm);\n\tkvm_vfio_update_coherency(dev);\n\nout_unlock:\n\tmutex_unlock(&kv->lock);\nout_fput:\n\tfput(filp);\n\treturn ret;\n}\n\nstatic int kvm_vfio_file_del(struct kvm_device *dev, unsigned int fd)\n{\n\tstruct kvm_vfio *kv = dev->private;\n\tstruct kvm_vfio_file *kvf;\n\tstruct fd f;\n\tint ret;\n\n\tf = fdget(fd);\n\tif (!f.file)\n\t\treturn -EBADF;\n\n\tret = -ENOENT;\n\n\tmutex_lock(&kv->lock);\n\n\tlist_for_each_entry(kvf, &kv->file_list, node) {\n\t\tif (kvf->file != f.file)\n\t\t\tcontinue;\n\n\t\tlist_del(&kvf->node);\n\t\tkvm_arch_end_assignment(dev->kvm);\n#ifdef CONFIG_SPAPR_TCE_IOMMU\n\t\tkvm_spapr_tce_release_vfio_group(dev->kvm, kvf);\n#endif\n\t\tkvm_vfio_file_set_kvm(kvf->file, NULL);\n\t\tfput(kvf->file);\n\t\tkfree(kvf);\n\t\tret = 0;\n\t\tbreak;\n\t}\n\n\tkvm_vfio_update_coherency(dev);\n\n\tmutex_unlock(&kv->lock);\n\n\tfdput(f);\n\n\treturn ret;\n}\n\n#ifdef CONFIG_SPAPR_TCE_IOMMU\nstatic int kvm_vfio_file_set_spapr_tce(struct kvm_device *dev,\n\t\t\t\t       void __user *arg)\n{\n\tstruct kvm_vfio_spapr_tce param;\n\tstruct kvm_vfio *kv = dev->private;\n\tstruct kvm_vfio_file *kvf;\n\tstruct fd f;\n\tint ret;\n\n\tif (copy_from_user(&param, arg, sizeof(struct kvm_vfio_spapr_tce)))\n\t\treturn -EFAULT;\n\n\tf = fdget(param.groupfd);\n\tif (!f.file)\n\t\treturn -EBADF;\n\n\tret = -ENOENT;\n\n\tmutex_lock(&kv->lock);\n\n\tlist_for_each_entry(kvf, &kv->file_list, node) {\n\t\tif (kvf->file != f.file)\n\t\t\tcontinue;\n\n\t\tif (!kvf->iommu_group) {\n\t\t\tkvf->iommu_group = kvm_vfio_file_iommu_group(kvf->file);\n\t\t\tif (WARN_ON_ONCE(!kvf->iommu_group)) {\n\t\t\t\tret = -EIO;\n\t\t\t\tgoto err_fdput;\n\t\t\t}\n\t\t}\n\n\t\tret = kvm_spapr_tce_attach_iommu_group(dev->kvm, param.tablefd,\n\t\t\t\t\t\t       kvf->iommu_group);\n\t\tbreak;\n\t}\n\nerr_fdput:\n\tmutex_unlock(&kv->lock);\n\tfdput(f);\n\treturn ret;\n}\n#endif\n\nstatic int kvm_vfio_set_file(struct kvm_device *dev, long attr,\n\t\t\t     void __user *arg)\n{\n\tint32_t __user *argp = arg;\n\tint32_t fd;\n\n\tswitch (attr) {\n\tcase KVM_DEV_VFIO_FILE_ADD:\n\t\tif (get_user(fd, argp))\n\t\t\treturn -EFAULT;\n\t\treturn kvm_vfio_file_add(dev, fd);\n\n\tcase KVM_DEV_VFIO_FILE_DEL:\n\t\tif (get_user(fd, argp))\n\t\t\treturn -EFAULT;\n\t\treturn kvm_vfio_file_del(dev, fd);\n\n#ifdef CONFIG_SPAPR_TCE_IOMMU\n\tcase KVM_DEV_VFIO_GROUP_SET_SPAPR_TCE:\n\t\treturn kvm_vfio_file_set_spapr_tce(dev, arg);\n#endif\n\t}\n\n\treturn -ENXIO;\n}\n\nstatic int kvm_vfio_set_attr(struct kvm_device *dev,\n\t\t\t     struct kvm_device_attr *attr)\n{\n\tswitch (attr->group) {\n\tcase KVM_DEV_VFIO_FILE:\n\t\treturn kvm_vfio_set_file(dev, attr->attr,\n\t\t\t\t\t u64_to_user_ptr(attr->addr));\n\t}\n\n\treturn -ENXIO;\n}\n\nstatic int kvm_vfio_has_attr(struct kvm_device *dev,\n\t\t\t     struct kvm_device_attr *attr)\n{\n\tswitch (attr->group) {\n\tcase KVM_DEV_VFIO_FILE:\n\t\tswitch (attr->attr) {\n\t\tcase KVM_DEV_VFIO_FILE_ADD:\n\t\tcase KVM_DEV_VFIO_FILE_DEL:\n#ifdef CONFIG_SPAPR_TCE_IOMMU\n\t\tcase KVM_DEV_VFIO_GROUP_SET_SPAPR_TCE:\n#endif\n\t\t\treturn 0;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\treturn -ENXIO;\n}\n\nstatic void kvm_vfio_release(struct kvm_device *dev)\n{\n\tstruct kvm_vfio *kv = dev->private;\n\tstruct kvm_vfio_file *kvf, *tmp;\n\n\tlist_for_each_entry_safe(kvf, tmp, &kv->file_list, node) {\n#ifdef CONFIG_SPAPR_TCE_IOMMU\n\t\tkvm_spapr_tce_release_vfio_group(dev->kvm, kvf);\n#endif\n\t\tkvm_vfio_file_set_kvm(kvf->file, NULL);\n\t\tfput(kvf->file);\n\t\tlist_del(&kvf->node);\n\t\tkfree(kvf);\n\t\tkvm_arch_end_assignment(dev->kvm);\n\t}\n\n\tkvm_vfio_update_coherency(dev);\n\n\tkfree(kv);\n\tkfree(dev);  \n}\n\nstatic int kvm_vfio_create(struct kvm_device *dev, u32 type);\n\nstatic struct kvm_device_ops kvm_vfio_ops = {\n\t.name = \"kvm-vfio\",\n\t.create = kvm_vfio_create,\n\t.release = kvm_vfio_release,\n\t.set_attr = kvm_vfio_set_attr,\n\t.has_attr = kvm_vfio_has_attr,\n};\n\nstatic int kvm_vfio_create(struct kvm_device *dev, u32 type)\n{\n\tstruct kvm_device *tmp;\n\tstruct kvm_vfio *kv;\n\n\t \n\tlist_for_each_entry(tmp, &dev->kvm->devices, vm_node)\n\t\tif (tmp->ops == &kvm_vfio_ops)\n\t\t\treturn -EBUSY;\n\n\tkv = kzalloc(sizeof(*kv), GFP_KERNEL_ACCOUNT);\n\tif (!kv)\n\t\treturn -ENOMEM;\n\n\tINIT_LIST_HEAD(&kv->file_list);\n\tmutex_init(&kv->lock);\n\n\tdev->private = kv;\n\n\treturn 0;\n}\n\nint kvm_vfio_ops_init(void)\n{\n\treturn kvm_register_device_ops(&kvm_vfio_ops, KVM_DEV_TYPE_VFIO);\n}\n\nvoid kvm_vfio_ops_exit(void)\n{\n\tkvm_unregister_device_ops(KVM_DEV_TYPE_VFIO);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}