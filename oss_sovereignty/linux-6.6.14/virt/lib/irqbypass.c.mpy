{
  "module_name": "irqbypass.c",
  "hash_id": "cbaab46f31dfbef94068923058ee08cd5726fd793d5aed15ddab7a57e09c032f",
  "original_prompt": "Ingested from linux-6.6.14/virt/lib/irqbypass.c",
  "human_readable_source": "\n \n\n#include <linux/irqbypass.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"IRQ bypass manager utility module\");\n\nstatic LIST_HEAD(producers);\nstatic LIST_HEAD(consumers);\nstatic DEFINE_MUTEX(lock);\n\n \nstatic int __connect(struct irq_bypass_producer *prod,\n\t\t     struct irq_bypass_consumer *cons)\n{\n\tint ret = 0;\n\n\tif (prod->stop)\n\t\tprod->stop(prod);\n\tif (cons->stop)\n\t\tcons->stop(cons);\n\n\tif (prod->add_consumer)\n\t\tret = prod->add_consumer(prod, cons);\n\n\tif (!ret) {\n\t\tret = cons->add_producer(cons, prod);\n\t\tif (ret && prod->del_consumer)\n\t\t\tprod->del_consumer(prod, cons);\n\t}\n\n\tif (cons->start)\n\t\tcons->start(cons);\n\tif (prod->start)\n\t\tprod->start(prod);\n\n\treturn ret;\n}\n\n \nstatic void __disconnect(struct irq_bypass_producer *prod,\n\t\t\t struct irq_bypass_consumer *cons)\n{\n\tif (prod->stop)\n\t\tprod->stop(prod);\n\tif (cons->stop)\n\t\tcons->stop(cons);\n\n\tcons->del_producer(cons, prod);\n\n\tif (prod->del_consumer)\n\t\tprod->del_consumer(prod, cons);\n\n\tif (cons->start)\n\t\tcons->start(cons);\n\tif (prod->start)\n\t\tprod->start(prod);\n}\n\n \nint irq_bypass_register_producer(struct irq_bypass_producer *producer)\n{\n\tstruct irq_bypass_producer *tmp;\n\tstruct irq_bypass_consumer *consumer;\n\tint ret;\n\n\tif (!producer->token)\n\t\treturn -EINVAL;\n\n\tmight_sleep();\n\n\tif (!try_module_get(THIS_MODULE))\n\t\treturn -ENODEV;\n\n\tmutex_lock(&lock);\n\n\tlist_for_each_entry(tmp, &producers, node) {\n\t\tif (tmp->token == producer->token) {\n\t\t\tret = -EBUSY;\n\t\t\tgoto out_err;\n\t\t}\n\t}\n\n\tlist_for_each_entry(consumer, &consumers, node) {\n\t\tif (consumer->token == producer->token) {\n\t\t\tret = __connect(producer, consumer);\n\t\t\tif (ret)\n\t\t\t\tgoto out_err;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tlist_add(&producer->node, &producers);\n\n\tmutex_unlock(&lock);\n\n\treturn 0;\nout_err:\n\tmutex_unlock(&lock);\n\tmodule_put(THIS_MODULE);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(irq_bypass_register_producer);\n\n \nvoid irq_bypass_unregister_producer(struct irq_bypass_producer *producer)\n{\n\tstruct irq_bypass_producer *tmp;\n\tstruct irq_bypass_consumer *consumer;\n\n\tif (!producer->token)\n\t\treturn;\n\n\tmight_sleep();\n\n\tif (!try_module_get(THIS_MODULE))\n\t\treturn;  \n\n\tmutex_lock(&lock);\n\n\tlist_for_each_entry(tmp, &producers, node) {\n\t\tif (tmp->token != producer->token)\n\t\t\tcontinue;\n\n\t\tlist_for_each_entry(consumer, &consumers, node) {\n\t\t\tif (consumer->token == producer->token) {\n\t\t\t\t__disconnect(producer, consumer);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tlist_del(&producer->node);\n\t\tmodule_put(THIS_MODULE);\n\t\tbreak;\n\t}\n\n\tmutex_unlock(&lock);\n\n\tmodule_put(THIS_MODULE);\n}\nEXPORT_SYMBOL_GPL(irq_bypass_unregister_producer);\n\n \nint irq_bypass_register_consumer(struct irq_bypass_consumer *consumer)\n{\n\tstruct irq_bypass_consumer *tmp;\n\tstruct irq_bypass_producer *producer;\n\tint ret;\n\n\tif (!consumer->token ||\n\t    !consumer->add_producer || !consumer->del_producer)\n\t\treturn -EINVAL;\n\n\tmight_sleep();\n\n\tif (!try_module_get(THIS_MODULE))\n\t\treturn -ENODEV;\n\n\tmutex_lock(&lock);\n\n\tlist_for_each_entry(tmp, &consumers, node) {\n\t\tif (tmp->token == consumer->token || tmp == consumer) {\n\t\t\tret = -EBUSY;\n\t\t\tgoto out_err;\n\t\t}\n\t}\n\n\tlist_for_each_entry(producer, &producers, node) {\n\t\tif (producer->token == consumer->token) {\n\t\t\tret = __connect(producer, consumer);\n\t\t\tif (ret)\n\t\t\t\tgoto out_err;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tlist_add(&consumer->node, &consumers);\n\n\tmutex_unlock(&lock);\n\n\treturn 0;\nout_err:\n\tmutex_unlock(&lock);\n\tmodule_put(THIS_MODULE);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(irq_bypass_register_consumer);\n\n \nvoid irq_bypass_unregister_consumer(struct irq_bypass_consumer *consumer)\n{\n\tstruct irq_bypass_consumer *tmp;\n\tstruct irq_bypass_producer *producer;\n\n\tif (!consumer->token)\n\t\treturn;\n\n\tmight_sleep();\n\n\tif (!try_module_get(THIS_MODULE))\n\t\treturn;  \n\n\tmutex_lock(&lock);\n\n\tlist_for_each_entry(tmp, &consumers, node) {\n\t\tif (tmp != consumer)\n\t\t\tcontinue;\n\n\t\tlist_for_each_entry(producer, &producers, node) {\n\t\t\tif (producer->token == consumer->token) {\n\t\t\t\t__disconnect(producer, consumer);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tlist_del(&consumer->node);\n\t\tmodule_put(THIS_MODULE);\n\t\tbreak;\n\t}\n\n\tmutex_unlock(&lock);\n\n\tmodule_put(THIS_MODULE);\n}\nEXPORT_SYMBOL_GPL(irq_bypass_unregister_consumer);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}