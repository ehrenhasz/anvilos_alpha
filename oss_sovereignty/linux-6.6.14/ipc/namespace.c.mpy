{
  "module_name": "namespace.c",
  "hash_id": "1ea99cc6d39915497db0c4529132fab01f576432d43d3f3b0e25af40970f885d",
  "original_prompt": "Ingested from linux-6.6.14/ipc/namespace.c",
  "human_readable_source": "\n \n\n#include <linux/ipc.h>\n#include <linux/msg.h>\n#include <linux/ipc_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/nsproxy.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/user_namespace.h>\n#include <linux/proc_ns.h>\n#include <linux/sched/task.h>\n\n#include \"util.h\"\n\n \nstatic void free_ipc(struct work_struct *unused);\nstatic DECLARE_WORK(free_ipc_work, free_ipc);\n\nstatic struct ucounts *inc_ipc_namespaces(struct user_namespace *ns)\n{\n\treturn inc_ucount(ns, current_euid(), UCOUNT_IPC_NAMESPACES);\n}\n\nstatic void dec_ipc_namespaces(struct ucounts *ucounts)\n{\n\tdec_ucount(ucounts, UCOUNT_IPC_NAMESPACES);\n}\n\nstatic struct ipc_namespace *create_ipc_ns(struct user_namespace *user_ns,\n\t\t\t\t\t   struct ipc_namespace *old_ns)\n{\n\tstruct ipc_namespace *ns;\n\tstruct ucounts *ucounts;\n\tint err;\n\n\terr = -ENOSPC;\n again:\n\tucounts = inc_ipc_namespaces(user_ns);\n\tif (!ucounts) {\n\t\t \n\t\tif (flush_work(&free_ipc_work))\n\t\t\tgoto again;\n\t\tgoto fail;\n\t}\n\n\terr = -ENOMEM;\n\tns = kzalloc(sizeof(struct ipc_namespace), GFP_KERNEL_ACCOUNT);\n\tif (ns == NULL)\n\t\tgoto fail_dec;\n\n\terr = ns_alloc_inum(&ns->ns);\n\tif (err)\n\t\tgoto fail_free;\n\tns->ns.ops = &ipcns_operations;\n\n\trefcount_set(&ns->ns.count, 1);\n\tns->user_ns = get_user_ns(user_ns);\n\tns->ucounts = ucounts;\n\n\terr = mq_init_ns(ns);\n\tif (err)\n\t\tgoto fail_put;\n\n\terr = -ENOMEM;\n\tif (!setup_mq_sysctls(ns))\n\t\tgoto fail_put;\n\n\tif (!setup_ipc_sysctls(ns))\n\t\tgoto fail_mq;\n\n\terr = msg_init_ns(ns);\n\tif (err)\n\t\tgoto fail_put;\n\n\tsem_init_ns(ns);\n\tshm_init_ns(ns);\n\n\treturn ns;\n\nfail_mq:\n\tretire_mq_sysctls(ns);\n\nfail_put:\n\tput_user_ns(ns->user_ns);\n\tns_free_inum(&ns->ns);\nfail_free:\n\tkfree(ns);\nfail_dec:\n\tdec_ipc_namespaces(ucounts);\nfail:\n\treturn ERR_PTR(err);\n}\n\nstruct ipc_namespace *copy_ipcs(unsigned long flags,\n\tstruct user_namespace *user_ns, struct ipc_namespace *ns)\n{\n\tif (!(flags & CLONE_NEWIPC))\n\t\treturn get_ipc_ns(ns);\n\treturn create_ipc_ns(user_ns, ns);\n}\n\n \nvoid free_ipcs(struct ipc_namespace *ns, struct ipc_ids *ids,\n\t       void (*free)(struct ipc_namespace *, struct kern_ipc_perm *))\n{\n\tstruct kern_ipc_perm *perm;\n\tint next_id;\n\tint total, in_use;\n\n\tdown_write(&ids->rwsem);\n\n\tin_use = ids->in_use;\n\n\tfor (total = 0, next_id = 0; total < in_use; next_id++) {\n\t\tperm = idr_find(&ids->ipcs_idr, next_id);\n\t\tif (perm == NULL)\n\t\t\tcontinue;\n\t\trcu_read_lock();\n\t\tipc_lock_object(perm);\n\t\tfree(ns, perm);\n\t\ttotal++;\n\t}\n\tup_write(&ids->rwsem);\n}\n\nstatic void free_ipc_ns(struct ipc_namespace *ns)\n{\n\t \n\tmntput(ns->mq_mnt);\n\tsem_exit_ns(ns);\n\tmsg_exit_ns(ns);\n\tshm_exit_ns(ns);\n\n\tretire_mq_sysctls(ns);\n\tretire_ipc_sysctls(ns);\n\n\tdec_ipc_namespaces(ns->ucounts);\n\tput_user_ns(ns->user_ns);\n\tns_free_inum(&ns->ns);\n\tkfree(ns);\n}\n\nstatic LLIST_HEAD(free_ipc_list);\nstatic void free_ipc(struct work_struct *unused)\n{\n\tstruct llist_node *node = llist_del_all(&free_ipc_list);\n\tstruct ipc_namespace *n, *t;\n\n\tllist_for_each_entry_safe(n, t, node, mnt_llist)\n\t\tmnt_make_shortterm(n->mq_mnt);\n\n\t \n\tsynchronize_rcu();\n\n\tllist_for_each_entry_safe(n, t, node, mnt_llist)\n\t\tfree_ipc_ns(n);\n}\n\n \nvoid put_ipc_ns(struct ipc_namespace *ns)\n{\n\tif (refcount_dec_and_lock(&ns->ns.count, &mq_lock)) {\n\t\tmq_clear_sbinfo(ns);\n\t\tspin_unlock(&mq_lock);\n\n\t\tif (llist_add(&ns->mnt_llist, &free_ipc_list))\n\t\t\tschedule_work(&free_ipc_work);\n\t}\n}\n\nstatic inline struct ipc_namespace *to_ipc_ns(struct ns_common *ns)\n{\n\treturn container_of(ns, struct ipc_namespace, ns);\n}\n\nstatic struct ns_common *ipcns_get(struct task_struct *task)\n{\n\tstruct ipc_namespace *ns = NULL;\n\tstruct nsproxy *nsproxy;\n\n\ttask_lock(task);\n\tnsproxy = task->nsproxy;\n\tif (nsproxy)\n\t\tns = get_ipc_ns(nsproxy->ipc_ns);\n\ttask_unlock(task);\n\n\treturn ns ? &ns->ns : NULL;\n}\n\nstatic void ipcns_put(struct ns_common *ns)\n{\n\treturn put_ipc_ns(to_ipc_ns(ns));\n}\n\nstatic int ipcns_install(struct nsset *nsset, struct ns_common *new)\n{\n\tstruct nsproxy *nsproxy = nsset->nsproxy;\n\tstruct ipc_namespace *ns = to_ipc_ns(new);\n\tif (!ns_capable(ns->user_ns, CAP_SYS_ADMIN) ||\n\t    !ns_capable(nsset->cred->user_ns, CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tput_ipc_ns(nsproxy->ipc_ns);\n\tnsproxy->ipc_ns = get_ipc_ns(ns);\n\treturn 0;\n}\n\nstatic struct user_namespace *ipcns_owner(struct ns_common *ns)\n{\n\treturn to_ipc_ns(ns)->user_ns;\n}\n\nconst struct proc_ns_operations ipcns_operations = {\n\t.name\t\t= \"ipc\",\n\t.type\t\t= CLONE_NEWIPC,\n\t.get\t\t= ipcns_get,\n\t.put\t\t= ipcns_put,\n\t.install\t= ipcns_install,\n\t.owner\t\t= ipcns_owner,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}