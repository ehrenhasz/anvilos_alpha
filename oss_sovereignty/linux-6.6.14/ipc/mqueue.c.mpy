{
  "module_name": "mqueue.c",
  "hash_id": "179743a3dfce0137a0301cda04986dab004d7beacb7b1288433a72ea5c9bc1ad",
  "original_prompt": "Ingested from linux-6.6.14/ipc/mqueue.c",
  "human_readable_source": " \n\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/fs_context.h>\n#include <linux/namei.h>\n#include <linux/sysctl.h>\n#include <linux/poll.h>\n#include <linux/mqueue.h>\n#include <linux/msg.h>\n#include <linux/skbuff.h>\n#include <linux/vmalloc.h>\n#include <linux/netlink.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/signal.h>\n#include <linux/mutex.h>\n#include <linux/nsproxy.h>\n#include <linux/pid.h>\n#include <linux/ipc_namespace.h>\n#include <linux/user_namespace.h>\n#include <linux/slab.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/user.h>\n\n#include <net/sock.h>\n#include \"util.h\"\n\nstruct mqueue_fs_context {\n\tstruct ipc_namespace\t*ipc_ns;\n\tbool\t\t\t newns;\t \n};\n\n#define MQUEUE_MAGIC\t0x19800202\n#define DIRENT_SIZE\t20\n#define FILENT_SIZE\t80\n\n#define SEND\t\t0\n#define RECV\t\t1\n\n#define STATE_NONE\t0\n#define STATE_READY\t1\n\nstruct posix_msg_tree_node {\n\tstruct rb_node\t\trb_node;\n\tstruct list_head\tmsg_list;\n\tint\t\t\tpriority;\n};\n\n \n\nstruct ext_wait_queue {\t\t \n\tstruct task_struct *task;\n\tstruct list_head list;\n\tstruct msg_msg *msg;\t \n\tint state;\t\t \n};\n\nstruct mqueue_inode_info {\n\tspinlock_t lock;\n\tstruct inode vfs_inode;\n\twait_queue_head_t wait_q;\n\n\tstruct rb_root msg_tree;\n\tstruct rb_node *msg_tree_rightmost;\n\tstruct posix_msg_tree_node *node_cache;\n\tstruct mq_attr attr;\n\n\tstruct sigevent notify;\n\tstruct pid *notify_owner;\n\tu32 notify_self_exec_id;\n\tstruct user_namespace *notify_user_ns;\n\tstruct ucounts *ucounts;\t \n\tstruct sock *notify_sock;\n\tstruct sk_buff *notify_cookie;\n\n\t \n\tstruct ext_wait_queue e_wait_q[2];\n\n\tunsigned long qsize;  \n};\n\nstatic struct file_system_type mqueue_fs_type;\nstatic const struct inode_operations mqueue_dir_inode_operations;\nstatic const struct file_operations mqueue_file_operations;\nstatic const struct super_operations mqueue_super_ops;\nstatic const struct fs_context_operations mqueue_fs_context_ops;\nstatic void remove_notification(struct mqueue_inode_info *info);\n\nstatic struct kmem_cache *mqueue_inode_cachep;\n\nstatic inline struct mqueue_inode_info *MQUEUE_I(struct inode *inode)\n{\n\treturn container_of(inode, struct mqueue_inode_info, vfs_inode);\n}\n\n \nstatic inline struct ipc_namespace *__get_ns_from_inode(struct inode *inode)\n{\n\treturn get_ipc_ns(inode->i_sb->s_fs_info);\n}\n\nstatic struct ipc_namespace *get_ns_from_inode(struct inode *inode)\n{\n\tstruct ipc_namespace *ns;\n\n\tspin_lock(&mq_lock);\n\tns = __get_ns_from_inode(inode);\n\tspin_unlock(&mq_lock);\n\treturn ns;\n}\n\n \nstatic int msg_insert(struct msg_msg *msg, struct mqueue_inode_info *info)\n{\n\tstruct rb_node **p, *parent = NULL;\n\tstruct posix_msg_tree_node *leaf;\n\tbool rightmost = true;\n\n\tp = &info->msg_tree.rb_node;\n\twhile (*p) {\n\t\tparent = *p;\n\t\tleaf = rb_entry(parent, struct posix_msg_tree_node, rb_node);\n\n\t\tif (likely(leaf->priority == msg->m_type))\n\t\t\tgoto insert_msg;\n\t\telse if (msg->m_type < leaf->priority) {\n\t\t\tp = &(*p)->rb_left;\n\t\t\trightmost = false;\n\t\t} else\n\t\t\tp = &(*p)->rb_right;\n\t}\n\tif (info->node_cache) {\n\t\tleaf = info->node_cache;\n\t\tinfo->node_cache = NULL;\n\t} else {\n\t\tleaf = kmalloc(sizeof(*leaf), GFP_ATOMIC);\n\t\tif (!leaf)\n\t\t\treturn -ENOMEM;\n\t\tINIT_LIST_HEAD(&leaf->msg_list);\n\t}\n\tleaf->priority = msg->m_type;\n\n\tif (rightmost)\n\t\tinfo->msg_tree_rightmost = &leaf->rb_node;\n\n\trb_link_node(&leaf->rb_node, parent, p);\n\trb_insert_color(&leaf->rb_node, &info->msg_tree);\ninsert_msg:\n\tinfo->attr.mq_curmsgs++;\n\tinfo->qsize += msg->m_ts;\n\tlist_add_tail(&msg->m_list, &leaf->msg_list);\n\treturn 0;\n}\n\nstatic inline void msg_tree_erase(struct posix_msg_tree_node *leaf,\n\t\t\t\t  struct mqueue_inode_info *info)\n{\n\tstruct rb_node *node = &leaf->rb_node;\n\n\tif (info->msg_tree_rightmost == node)\n\t\tinfo->msg_tree_rightmost = rb_prev(node);\n\n\trb_erase(node, &info->msg_tree);\n\tif (info->node_cache)\n\t\tkfree(leaf);\n\telse\n\t\tinfo->node_cache = leaf;\n}\n\nstatic inline struct msg_msg *msg_get(struct mqueue_inode_info *info)\n{\n\tstruct rb_node *parent = NULL;\n\tstruct posix_msg_tree_node *leaf;\n\tstruct msg_msg *msg;\n\ntry_again:\n\t \n\tparent = info->msg_tree_rightmost;\n\tif (!parent) {\n\t\tif (info->attr.mq_curmsgs) {\n\t\t\tpr_warn_once(\"Inconsistency in POSIX message queue, \"\n\t\t\t\t     \"no tree element, but supposedly messages \"\n\t\t\t\t     \"should exist!\\n\");\n\t\t\tinfo->attr.mq_curmsgs = 0;\n\t\t}\n\t\treturn NULL;\n\t}\n\tleaf = rb_entry(parent, struct posix_msg_tree_node, rb_node);\n\tif (unlikely(list_empty(&leaf->msg_list))) {\n\t\tpr_warn_once(\"Inconsistency in POSIX message queue, \"\n\t\t\t     \"empty leaf node but we haven't implemented \"\n\t\t\t     \"lazy leaf delete!\\n\");\n\t\tmsg_tree_erase(leaf, info);\n\t\tgoto try_again;\n\t} else {\n\t\tmsg = list_first_entry(&leaf->msg_list,\n\t\t\t\t       struct msg_msg, m_list);\n\t\tlist_del(&msg->m_list);\n\t\tif (list_empty(&leaf->msg_list)) {\n\t\t\tmsg_tree_erase(leaf, info);\n\t\t}\n\t}\n\tinfo->attr.mq_curmsgs--;\n\tinfo->qsize -= msg->m_ts;\n\treturn msg;\n}\n\nstatic struct inode *mqueue_get_inode(struct super_block *sb,\n\t\tstruct ipc_namespace *ipc_ns, umode_t mode,\n\t\tstruct mq_attr *attr)\n{\n\tstruct inode *inode;\n\tint ret = -ENOMEM;\n\n\tinode = new_inode(sb);\n\tif (!inode)\n\t\tgoto err;\n\n\tinode->i_ino = get_next_ino();\n\tinode->i_mode = mode;\n\tinode->i_uid = current_fsuid();\n\tinode->i_gid = current_fsgid();\n\tinode->i_mtime = inode->i_atime = inode_set_ctime_current(inode);\n\n\tif (S_ISREG(mode)) {\n\t\tstruct mqueue_inode_info *info;\n\t\tunsigned long mq_bytes, mq_treesize;\n\n\t\tinode->i_fop = &mqueue_file_operations;\n\t\tinode->i_size = FILENT_SIZE;\n\t\t \n\t\tinfo = MQUEUE_I(inode);\n\t\tspin_lock_init(&info->lock);\n\t\tinit_waitqueue_head(&info->wait_q);\n\t\tINIT_LIST_HEAD(&info->e_wait_q[0].list);\n\t\tINIT_LIST_HEAD(&info->e_wait_q[1].list);\n\t\tinfo->notify_owner = NULL;\n\t\tinfo->notify_user_ns = NULL;\n\t\tinfo->qsize = 0;\n\t\tinfo->ucounts = NULL;\t \n\t\tinfo->msg_tree = RB_ROOT;\n\t\tinfo->msg_tree_rightmost = NULL;\n\t\tinfo->node_cache = NULL;\n\t\tmemset(&info->attr, 0, sizeof(info->attr));\n\t\tinfo->attr.mq_maxmsg = min(ipc_ns->mq_msg_max,\n\t\t\t\t\t   ipc_ns->mq_msg_default);\n\t\tinfo->attr.mq_msgsize = min(ipc_ns->mq_msgsize_max,\n\t\t\t\t\t    ipc_ns->mq_msgsize_default);\n\t\tif (attr) {\n\t\t\tinfo->attr.mq_maxmsg = attr->mq_maxmsg;\n\t\t\tinfo->attr.mq_msgsize = attr->mq_msgsize;\n\t\t}\n\t\t \n\n\t\tret = -EINVAL;\n\t\tif (info->attr.mq_maxmsg <= 0 || info->attr.mq_msgsize <= 0)\n\t\t\tgoto out_inode;\n\t\tif (capable(CAP_SYS_RESOURCE)) {\n\t\t\tif (info->attr.mq_maxmsg > HARD_MSGMAX ||\n\t\t\t    info->attr.mq_msgsize > HARD_MSGSIZEMAX)\n\t\t\t\tgoto out_inode;\n\t\t} else {\n\t\t\tif (info->attr.mq_maxmsg > ipc_ns->mq_msg_max ||\n\t\t\t\t\tinfo->attr.mq_msgsize > ipc_ns->mq_msgsize_max)\n\t\t\t\tgoto out_inode;\n\t\t}\n\t\tret = -EOVERFLOW;\n\t\t \n\t\tif (info->attr.mq_msgsize > ULONG_MAX/info->attr.mq_maxmsg)\n\t\t\tgoto out_inode;\n\t\tmq_treesize = info->attr.mq_maxmsg * sizeof(struct msg_msg) +\n\t\t\tmin_t(unsigned int, info->attr.mq_maxmsg, MQ_PRIO_MAX) *\n\t\t\tsizeof(struct posix_msg_tree_node);\n\t\tmq_bytes = info->attr.mq_maxmsg * info->attr.mq_msgsize;\n\t\tif (mq_bytes + mq_treesize < mq_bytes)\n\t\t\tgoto out_inode;\n\t\tmq_bytes += mq_treesize;\n\t\tinfo->ucounts = get_ucounts(current_ucounts());\n\t\tif (info->ucounts) {\n\t\t\tlong msgqueue;\n\n\t\t\tspin_lock(&mq_lock);\n\t\t\tmsgqueue = inc_rlimit_ucounts(info->ucounts, UCOUNT_RLIMIT_MSGQUEUE, mq_bytes);\n\t\t\tif (msgqueue == LONG_MAX || msgqueue > rlimit(RLIMIT_MSGQUEUE)) {\n\t\t\t\tdec_rlimit_ucounts(info->ucounts, UCOUNT_RLIMIT_MSGQUEUE, mq_bytes);\n\t\t\t\tspin_unlock(&mq_lock);\n\t\t\t\tput_ucounts(info->ucounts);\n\t\t\t\tinfo->ucounts = NULL;\n\t\t\t\t \n\t\t\t\tret = -EMFILE;\n\t\t\t\tgoto out_inode;\n\t\t\t}\n\t\t\tspin_unlock(&mq_lock);\n\t\t}\n\t} else if (S_ISDIR(mode)) {\n\t\tinc_nlink(inode);\n\t\t \n\t\tinode->i_size = 2 * DIRENT_SIZE;\n\t\tinode->i_op = &mqueue_dir_inode_operations;\n\t\tinode->i_fop = &simple_dir_operations;\n\t}\n\n\treturn inode;\nout_inode:\n\tiput(inode);\nerr:\n\treturn ERR_PTR(ret);\n}\n\nstatic int mqueue_fill_super(struct super_block *sb, struct fs_context *fc)\n{\n\tstruct inode *inode;\n\tstruct ipc_namespace *ns = sb->s_fs_info;\n\n\tsb->s_iflags |= SB_I_NOEXEC | SB_I_NODEV;\n\tsb->s_blocksize = PAGE_SIZE;\n\tsb->s_blocksize_bits = PAGE_SHIFT;\n\tsb->s_magic = MQUEUE_MAGIC;\n\tsb->s_op = &mqueue_super_ops;\n\n\tinode = mqueue_get_inode(sb, ns, S_IFDIR | S_ISVTX | S_IRWXUGO, NULL);\n\tif (IS_ERR(inode))\n\t\treturn PTR_ERR(inode);\n\n\tsb->s_root = d_make_root(inode);\n\tif (!sb->s_root)\n\t\treturn -ENOMEM;\n\treturn 0;\n}\n\nstatic int mqueue_get_tree(struct fs_context *fc)\n{\n\tstruct mqueue_fs_context *ctx = fc->fs_private;\n\n\t \n\tif (ctx->newns) {\n\t\tfc->s_fs_info = ctx->ipc_ns;\n\t\treturn get_tree_nodev(fc, mqueue_fill_super);\n\t}\n\treturn get_tree_keyed(fc, mqueue_fill_super, ctx->ipc_ns);\n}\n\nstatic void mqueue_fs_context_free(struct fs_context *fc)\n{\n\tstruct mqueue_fs_context *ctx = fc->fs_private;\n\n\tput_ipc_ns(ctx->ipc_ns);\n\tkfree(ctx);\n}\n\nstatic int mqueue_init_fs_context(struct fs_context *fc)\n{\n\tstruct mqueue_fs_context *ctx;\n\n\tctx = kzalloc(sizeof(struct mqueue_fs_context), GFP_KERNEL);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\tctx->ipc_ns = get_ipc_ns(current->nsproxy->ipc_ns);\n\tput_user_ns(fc->user_ns);\n\tfc->user_ns = get_user_ns(ctx->ipc_ns->user_ns);\n\tfc->fs_private = ctx;\n\tfc->ops = &mqueue_fs_context_ops;\n\treturn 0;\n}\n\n \nstatic struct vfsmount *mq_create_mount(struct ipc_namespace *ns)\n{\n\tstruct mqueue_fs_context *ctx;\n\tstruct fs_context *fc;\n\tstruct vfsmount *mnt;\n\n\tfc = fs_context_for_mount(&mqueue_fs_type, SB_KERNMOUNT);\n\tif (IS_ERR(fc))\n\t\treturn ERR_CAST(fc);\n\n\tctx = fc->fs_private;\n\tctx->newns = true;\n\tput_ipc_ns(ctx->ipc_ns);\n\tctx->ipc_ns = get_ipc_ns(ns);\n\tput_user_ns(fc->user_ns);\n\tfc->user_ns = get_user_ns(ctx->ipc_ns->user_ns);\n\n\tmnt = fc_mount(fc);\n\tput_fs_context(fc);\n\treturn mnt;\n}\n\nstatic void init_once(void *foo)\n{\n\tstruct mqueue_inode_info *p = foo;\n\n\tinode_init_once(&p->vfs_inode);\n}\n\nstatic struct inode *mqueue_alloc_inode(struct super_block *sb)\n{\n\tstruct mqueue_inode_info *ei;\n\n\tei = alloc_inode_sb(sb, mqueue_inode_cachep, GFP_KERNEL);\n\tif (!ei)\n\t\treturn NULL;\n\treturn &ei->vfs_inode;\n}\n\nstatic void mqueue_free_inode(struct inode *inode)\n{\n\tkmem_cache_free(mqueue_inode_cachep, MQUEUE_I(inode));\n}\n\nstatic void mqueue_evict_inode(struct inode *inode)\n{\n\tstruct mqueue_inode_info *info;\n\tstruct ipc_namespace *ipc_ns;\n\tstruct msg_msg *msg, *nmsg;\n\tLIST_HEAD(tmp_msg);\n\n\tclear_inode(inode);\n\n\tif (S_ISDIR(inode->i_mode))\n\t\treturn;\n\n\tipc_ns = get_ns_from_inode(inode);\n\tinfo = MQUEUE_I(inode);\n\tspin_lock(&info->lock);\n\twhile ((msg = msg_get(info)) != NULL)\n\t\tlist_add_tail(&msg->m_list, &tmp_msg);\n\tkfree(info->node_cache);\n\tspin_unlock(&info->lock);\n\n\tlist_for_each_entry_safe(msg, nmsg, &tmp_msg, m_list) {\n\t\tlist_del(&msg->m_list);\n\t\tfree_msg(msg);\n\t}\n\n\tif (info->ucounts) {\n\t\tunsigned long mq_bytes, mq_treesize;\n\n\t\t \n\t\tmq_treesize = info->attr.mq_maxmsg * sizeof(struct msg_msg) +\n\t\t\tmin_t(unsigned int, info->attr.mq_maxmsg, MQ_PRIO_MAX) *\n\t\t\tsizeof(struct posix_msg_tree_node);\n\n\t\tmq_bytes = mq_treesize + (info->attr.mq_maxmsg *\n\t\t\t\t\t  info->attr.mq_msgsize);\n\n\t\tspin_lock(&mq_lock);\n\t\tdec_rlimit_ucounts(info->ucounts, UCOUNT_RLIMIT_MSGQUEUE, mq_bytes);\n\t\t \n\t\tif (ipc_ns)\n\t\t\tipc_ns->mq_queues_count--;\n\t\tspin_unlock(&mq_lock);\n\t\tput_ucounts(info->ucounts);\n\t\tinfo->ucounts = NULL;\n\t}\n\tif (ipc_ns)\n\t\tput_ipc_ns(ipc_ns);\n}\n\nstatic int mqueue_create_attr(struct dentry *dentry, umode_t mode, void *arg)\n{\n\tstruct inode *dir = dentry->d_parent->d_inode;\n\tstruct inode *inode;\n\tstruct mq_attr *attr = arg;\n\tint error;\n\tstruct ipc_namespace *ipc_ns;\n\n\tspin_lock(&mq_lock);\n\tipc_ns = __get_ns_from_inode(dir);\n\tif (!ipc_ns) {\n\t\terror = -EACCES;\n\t\tgoto out_unlock;\n\t}\n\n\tif (ipc_ns->mq_queues_count >= ipc_ns->mq_queues_max &&\n\t    !capable(CAP_SYS_RESOURCE)) {\n\t\terror = -ENOSPC;\n\t\tgoto out_unlock;\n\t}\n\tipc_ns->mq_queues_count++;\n\tspin_unlock(&mq_lock);\n\n\tinode = mqueue_get_inode(dir->i_sb, ipc_ns, mode, attr);\n\tif (IS_ERR(inode)) {\n\t\terror = PTR_ERR(inode);\n\t\tspin_lock(&mq_lock);\n\t\tipc_ns->mq_queues_count--;\n\t\tgoto out_unlock;\n\t}\n\n\tput_ipc_ns(ipc_ns);\n\tdir->i_size += DIRENT_SIZE;\n\tdir->i_mtime = dir->i_atime = inode_set_ctime_current(dir);\n\n\td_instantiate(dentry, inode);\n\tdget(dentry);\n\treturn 0;\nout_unlock:\n\tspin_unlock(&mq_lock);\n\tif (ipc_ns)\n\t\tput_ipc_ns(ipc_ns);\n\treturn error;\n}\n\nstatic int mqueue_create(struct mnt_idmap *idmap, struct inode *dir,\n\t\t\t struct dentry *dentry, umode_t mode, bool excl)\n{\n\treturn mqueue_create_attr(dentry, mode, NULL);\n}\n\nstatic int mqueue_unlink(struct inode *dir, struct dentry *dentry)\n{\n\tstruct inode *inode = d_inode(dentry);\n\n\tdir->i_mtime = dir->i_atime = inode_set_ctime_current(dir);\n\tdir->i_size -= DIRENT_SIZE;\n\tdrop_nlink(inode);\n\tdput(dentry);\n\treturn 0;\n}\n\n \nstatic ssize_t mqueue_read_file(struct file *filp, char __user *u_data,\n\t\t\t\tsize_t count, loff_t *off)\n{\n\tstruct inode *inode = file_inode(filp);\n\tstruct mqueue_inode_info *info = MQUEUE_I(inode);\n\tchar buffer[FILENT_SIZE];\n\tssize_t ret;\n\n\tspin_lock(&info->lock);\n\tsnprintf(buffer, sizeof(buffer),\n\t\t\t\"QSIZE:%-10lu NOTIFY:%-5d SIGNO:%-5d NOTIFY_PID:%-6d\\n\",\n\t\t\tinfo->qsize,\n\t\t\tinfo->notify_owner ? info->notify.sigev_notify : 0,\n\t\t\t(info->notify_owner &&\n\t\t\t info->notify.sigev_notify == SIGEV_SIGNAL) ?\n\t\t\t\tinfo->notify.sigev_signo : 0,\n\t\t\tpid_vnr(info->notify_owner));\n\tspin_unlock(&info->lock);\n\tbuffer[sizeof(buffer)-1] = '\\0';\n\n\tret = simple_read_from_buffer(u_data, count, off, buffer,\n\t\t\t\tstrlen(buffer));\n\tif (ret <= 0)\n\t\treturn ret;\n\n\tinode->i_atime = inode_set_ctime_current(inode);\n\treturn ret;\n}\n\nstatic int mqueue_flush_file(struct file *filp, fl_owner_t id)\n{\n\tstruct mqueue_inode_info *info = MQUEUE_I(file_inode(filp));\n\n\tspin_lock(&info->lock);\n\tif (task_tgid(current) == info->notify_owner)\n\t\tremove_notification(info);\n\n\tspin_unlock(&info->lock);\n\treturn 0;\n}\n\nstatic __poll_t mqueue_poll_file(struct file *filp, struct poll_table_struct *poll_tab)\n{\n\tstruct mqueue_inode_info *info = MQUEUE_I(file_inode(filp));\n\t__poll_t retval = 0;\n\n\tpoll_wait(filp, &info->wait_q, poll_tab);\n\n\tspin_lock(&info->lock);\n\tif (info->attr.mq_curmsgs)\n\t\tretval = EPOLLIN | EPOLLRDNORM;\n\n\tif (info->attr.mq_curmsgs < info->attr.mq_maxmsg)\n\t\tretval |= EPOLLOUT | EPOLLWRNORM;\n\tspin_unlock(&info->lock);\n\n\treturn retval;\n}\n\n \nstatic void wq_add(struct mqueue_inode_info *info, int sr,\n\t\t\tstruct ext_wait_queue *ewp)\n{\n\tstruct ext_wait_queue *walk;\n\n\tlist_for_each_entry(walk, &info->e_wait_q[sr].list, list) {\n\t\tif (walk->task->prio <= current->prio) {\n\t\t\tlist_add_tail(&ewp->list, &walk->list);\n\t\t\treturn;\n\t\t}\n\t}\n\tlist_add_tail(&ewp->list, &info->e_wait_q[sr].list);\n}\n\n \nstatic int wq_sleep(struct mqueue_inode_info *info, int sr,\n\t\t    ktime_t *timeout, struct ext_wait_queue *ewp)\n\t__releases(&info->lock)\n{\n\tint retval;\n\tsigned long time;\n\n\twq_add(info, sr, ewp);\n\n\tfor (;;) {\n\t\t \n\t\t__set_current_state(TASK_INTERRUPTIBLE);\n\n\t\tspin_unlock(&info->lock);\n\t\ttime = schedule_hrtimeout_range_clock(timeout, 0,\n\t\t\tHRTIMER_MODE_ABS, CLOCK_REALTIME);\n\n\t\tif (READ_ONCE(ewp->state) == STATE_READY) {\n\t\t\t \n\t\t\tsmp_acquire__after_ctrl_dep();\n\t\t\tretval = 0;\n\t\t\tgoto out;\n\t\t}\n\t\tspin_lock(&info->lock);\n\n\t\t \n\t\tif (READ_ONCE(ewp->state) == STATE_READY) {\n\t\t\tretval = 0;\n\t\t\tgoto out_unlock;\n\t\t}\n\t\tif (signal_pending(current)) {\n\t\t\tretval = -ERESTARTSYS;\n\t\t\tbreak;\n\t\t}\n\t\tif (time == 0) {\n\t\t\tretval = -ETIMEDOUT;\n\t\t\tbreak;\n\t\t}\n\t}\n\tlist_del(&ewp->list);\nout_unlock:\n\tspin_unlock(&info->lock);\nout:\n\treturn retval;\n}\n\n \nstatic struct ext_wait_queue *wq_get_first_waiter(\n\t\tstruct mqueue_inode_info *info, int sr)\n{\n\tstruct list_head *ptr;\n\n\tptr = info->e_wait_q[sr].list.prev;\n\tif (ptr == &info->e_wait_q[sr].list)\n\t\treturn NULL;\n\treturn list_entry(ptr, struct ext_wait_queue, list);\n}\n\n\nstatic inline void set_cookie(struct sk_buff *skb, char code)\n{\n\t((char *)skb->data)[NOTIFY_COOKIE_LEN-1] = code;\n}\n\n \nstatic void __do_notify(struct mqueue_inode_info *info)\n{\n\t \n\tif (info->notify_owner &&\n\t    info->attr.mq_curmsgs == 1) {\n\t\tswitch (info->notify.sigev_notify) {\n\t\tcase SIGEV_NONE:\n\t\t\tbreak;\n\t\tcase SIGEV_SIGNAL: {\n\t\t\tstruct kernel_siginfo sig_i;\n\t\t\tstruct task_struct *task;\n\n\t\t\t \n\t\t\tif (!info->notify.sigev_signo)\n\t\t\t\tbreak;\n\n\t\t\tclear_siginfo(&sig_i);\n\t\t\tsig_i.si_signo = info->notify.sigev_signo;\n\t\t\tsig_i.si_errno = 0;\n\t\t\tsig_i.si_code = SI_MESGQ;\n\t\t\tsig_i.si_value = info->notify.sigev_value;\n\t\t\trcu_read_lock();\n\t\t\t \n\t\t\tsig_i.si_pid = task_tgid_nr_ns(current,\n\t\t\t\t\t\tns_of_pid(info->notify_owner));\n\t\t\tsig_i.si_uid = from_kuid_munged(info->notify_user_ns,\n\t\t\t\t\t\tcurrent_uid());\n\t\t\t \n\t\t\ttask = pid_task(info->notify_owner, PIDTYPE_TGID);\n\t\t\tif (task && task->self_exec_id ==\n\t\t\t\t\t\tinfo->notify_self_exec_id) {\n\t\t\t\tdo_send_sig_info(info->notify.sigev_signo,\n\t\t\t\t\t\t&sig_i, task, PIDTYPE_TGID);\n\t\t\t}\n\t\t\trcu_read_unlock();\n\t\t\tbreak;\n\t\t}\n\t\tcase SIGEV_THREAD:\n\t\t\tset_cookie(info->notify_cookie, NOTIFY_WOKENUP);\n\t\t\tnetlink_sendskb(info->notify_sock, info->notify_cookie);\n\t\t\tbreak;\n\t\t}\n\t\t \n\t\tput_pid(info->notify_owner);\n\t\tput_user_ns(info->notify_user_ns);\n\t\tinfo->notify_owner = NULL;\n\t\tinfo->notify_user_ns = NULL;\n\t}\n\twake_up(&info->wait_q);\n}\n\nstatic int prepare_timeout(const struct __kernel_timespec __user *u_abs_timeout,\n\t\t\t   struct timespec64 *ts)\n{\n\tif (get_timespec64(ts, u_abs_timeout))\n\t\treturn -EFAULT;\n\tif (!timespec64_valid(ts))\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\nstatic void remove_notification(struct mqueue_inode_info *info)\n{\n\tif (info->notify_owner != NULL &&\n\t    info->notify.sigev_notify == SIGEV_THREAD) {\n\t\tset_cookie(info->notify_cookie, NOTIFY_REMOVED);\n\t\tnetlink_sendskb(info->notify_sock, info->notify_cookie);\n\t}\n\tput_pid(info->notify_owner);\n\tput_user_ns(info->notify_user_ns);\n\tinfo->notify_owner = NULL;\n\tinfo->notify_user_ns = NULL;\n}\n\nstatic int prepare_open(struct dentry *dentry, int oflag, int ro,\n\t\t\tumode_t mode, struct filename *name,\n\t\t\tstruct mq_attr *attr)\n{\n\tstatic const int oflag2acc[O_ACCMODE] = { MAY_READ, MAY_WRITE,\n\t\t\t\t\t\t  MAY_READ | MAY_WRITE };\n\tint acc;\n\n\tif (d_really_is_negative(dentry)) {\n\t\tif (!(oflag & O_CREAT))\n\t\t\treturn -ENOENT;\n\t\tif (ro)\n\t\t\treturn ro;\n\t\taudit_inode_parent_hidden(name, dentry->d_parent);\n\t\treturn vfs_mkobj(dentry, mode & ~current_umask(),\n\t\t\t\t  mqueue_create_attr, attr);\n\t}\n\t \n\taudit_inode(name, dentry, 0);\n\tif ((oflag & (O_CREAT|O_EXCL)) == (O_CREAT|O_EXCL))\n\t\treturn -EEXIST;\n\tif ((oflag & O_ACCMODE) == (O_RDWR | O_WRONLY))\n\t\treturn -EINVAL;\n\tacc = oflag2acc[oflag & O_ACCMODE];\n\treturn inode_permission(&nop_mnt_idmap, d_inode(dentry), acc);\n}\n\nstatic int do_mq_open(const char __user *u_name, int oflag, umode_t mode,\n\t\t      struct mq_attr *attr)\n{\n\tstruct vfsmount *mnt = current->nsproxy->ipc_ns->mq_mnt;\n\tstruct dentry *root = mnt->mnt_root;\n\tstruct filename *name;\n\tstruct path path;\n\tint fd, error;\n\tint ro;\n\n\taudit_mq_open(oflag, mode, attr);\n\n\tif (IS_ERR(name = getname(u_name)))\n\t\treturn PTR_ERR(name);\n\n\tfd = get_unused_fd_flags(O_CLOEXEC);\n\tif (fd < 0)\n\t\tgoto out_putname;\n\n\tro = mnt_want_write(mnt);\t \n\tinode_lock(d_inode(root));\n\tpath.dentry = lookup_one_len(name->name, root, strlen(name->name));\n\tif (IS_ERR(path.dentry)) {\n\t\terror = PTR_ERR(path.dentry);\n\t\tgoto out_putfd;\n\t}\n\tpath.mnt = mntget(mnt);\n\terror = prepare_open(path.dentry, oflag, ro, mode, name, attr);\n\tif (!error) {\n\t\tstruct file *file = dentry_open(&path, oflag, current_cred());\n\t\tif (!IS_ERR(file))\n\t\t\tfd_install(fd, file);\n\t\telse\n\t\t\terror = PTR_ERR(file);\n\t}\n\tpath_put(&path);\nout_putfd:\n\tif (error) {\n\t\tput_unused_fd(fd);\n\t\tfd = error;\n\t}\n\tinode_unlock(d_inode(root));\n\tif (!ro)\n\t\tmnt_drop_write(mnt);\nout_putname:\n\tputname(name);\n\treturn fd;\n}\n\nSYSCALL_DEFINE4(mq_open, const char __user *, u_name, int, oflag, umode_t, mode,\n\t\tstruct mq_attr __user *, u_attr)\n{\n\tstruct mq_attr attr;\n\tif (u_attr && copy_from_user(&attr, u_attr, sizeof(struct mq_attr)))\n\t\treturn -EFAULT;\n\n\treturn do_mq_open(u_name, oflag, mode, u_attr ? &attr : NULL);\n}\n\nSYSCALL_DEFINE1(mq_unlink, const char __user *, u_name)\n{\n\tint err;\n\tstruct filename *name;\n\tstruct dentry *dentry;\n\tstruct inode *inode = NULL;\n\tstruct ipc_namespace *ipc_ns = current->nsproxy->ipc_ns;\n\tstruct vfsmount *mnt = ipc_ns->mq_mnt;\n\n\tname = getname(u_name);\n\tif (IS_ERR(name))\n\t\treturn PTR_ERR(name);\n\n\taudit_inode_parent_hidden(name, mnt->mnt_root);\n\terr = mnt_want_write(mnt);\n\tif (err)\n\t\tgoto out_name;\n\tinode_lock_nested(d_inode(mnt->mnt_root), I_MUTEX_PARENT);\n\tdentry = lookup_one_len(name->name, mnt->mnt_root,\n\t\t\t\tstrlen(name->name));\n\tif (IS_ERR(dentry)) {\n\t\terr = PTR_ERR(dentry);\n\t\tgoto out_unlock;\n\t}\n\n\tinode = d_inode(dentry);\n\tif (!inode) {\n\t\terr = -ENOENT;\n\t} else {\n\t\tihold(inode);\n\t\terr = vfs_unlink(&nop_mnt_idmap, d_inode(dentry->d_parent),\n\t\t\t\t dentry, NULL);\n\t}\n\tdput(dentry);\n\nout_unlock:\n\tinode_unlock(d_inode(mnt->mnt_root));\n\tiput(inode);\n\tmnt_drop_write(mnt);\nout_name:\n\tputname(name);\n\n\treturn err;\n}\n\n \n\nstatic inline void __pipelined_op(struct wake_q_head *wake_q,\n\t\t\t\t  struct mqueue_inode_info *info,\n\t\t\t\t  struct ext_wait_queue *this)\n{\n\tstruct task_struct *task;\n\n\tlist_del(&this->list);\n\ttask = get_task_struct(this->task);\n\n\t \n\tsmp_store_release(&this->state, STATE_READY);\n\twake_q_add_safe(wake_q, task);\n}\n\n \nstatic inline void pipelined_send(struct wake_q_head *wake_q,\n\t\t\t\t  struct mqueue_inode_info *info,\n\t\t\t\t  struct msg_msg *message,\n\t\t\t\t  struct ext_wait_queue *receiver)\n{\n\treceiver->msg = message;\n\t__pipelined_op(wake_q, info, receiver);\n}\n\n \nstatic inline void pipelined_receive(struct wake_q_head *wake_q,\n\t\t\t\t     struct mqueue_inode_info *info)\n{\n\tstruct ext_wait_queue *sender = wq_get_first_waiter(info, SEND);\n\n\tif (!sender) {\n\t\t \n\t\twake_up_interruptible(&info->wait_q);\n\t\treturn;\n\t}\n\tif (msg_insert(sender->msg, info))\n\t\treturn;\n\n\t__pipelined_op(wake_q, info, sender);\n}\n\nstatic int do_mq_timedsend(mqd_t mqdes, const char __user *u_msg_ptr,\n\t\tsize_t msg_len, unsigned int msg_prio,\n\t\tstruct timespec64 *ts)\n{\n\tstruct fd f;\n\tstruct inode *inode;\n\tstruct ext_wait_queue wait;\n\tstruct ext_wait_queue *receiver;\n\tstruct msg_msg *msg_ptr;\n\tstruct mqueue_inode_info *info;\n\tktime_t expires, *timeout = NULL;\n\tstruct posix_msg_tree_node *new_leaf = NULL;\n\tint ret = 0;\n\tDEFINE_WAKE_Q(wake_q);\n\n\tif (unlikely(msg_prio >= (unsigned long) MQ_PRIO_MAX))\n\t\treturn -EINVAL;\n\n\tif (ts) {\n\t\texpires = timespec64_to_ktime(*ts);\n\t\ttimeout = &expires;\n\t}\n\n\taudit_mq_sendrecv(mqdes, msg_len, msg_prio, ts);\n\n\tf = fdget(mqdes);\n\tif (unlikely(!f.file)) {\n\t\tret = -EBADF;\n\t\tgoto out;\n\t}\n\n\tinode = file_inode(f.file);\n\tif (unlikely(f.file->f_op != &mqueue_file_operations)) {\n\t\tret = -EBADF;\n\t\tgoto out_fput;\n\t}\n\tinfo = MQUEUE_I(inode);\n\taudit_file(f.file);\n\n\tif (unlikely(!(f.file->f_mode & FMODE_WRITE))) {\n\t\tret = -EBADF;\n\t\tgoto out_fput;\n\t}\n\n\tif (unlikely(msg_len > info->attr.mq_msgsize)) {\n\t\tret = -EMSGSIZE;\n\t\tgoto out_fput;\n\t}\n\n\t \n\tmsg_ptr = load_msg(u_msg_ptr, msg_len);\n\tif (IS_ERR(msg_ptr)) {\n\t\tret = PTR_ERR(msg_ptr);\n\t\tgoto out_fput;\n\t}\n\tmsg_ptr->m_ts = msg_len;\n\tmsg_ptr->m_type = msg_prio;\n\n\t \n\tif (!info->node_cache)\n\t\tnew_leaf = kmalloc(sizeof(*new_leaf), GFP_KERNEL);\n\n\tspin_lock(&info->lock);\n\n\tif (!info->node_cache && new_leaf) {\n\t\t \n\t\tINIT_LIST_HEAD(&new_leaf->msg_list);\n\t\tinfo->node_cache = new_leaf;\n\t\tnew_leaf = NULL;\n\t} else {\n\t\tkfree(new_leaf);\n\t}\n\n\tif (info->attr.mq_curmsgs == info->attr.mq_maxmsg) {\n\t\tif (f.file->f_flags & O_NONBLOCK) {\n\t\t\tret = -EAGAIN;\n\t\t} else {\n\t\t\twait.task = current;\n\t\t\twait.msg = (void *) msg_ptr;\n\n\t\t\t \n\t\t\tWRITE_ONCE(wait.state, STATE_NONE);\n\t\t\tret = wq_sleep(info, SEND, timeout, &wait);\n\t\t\t \n\t\t\tgoto out_free;\n\t\t}\n\t} else {\n\t\treceiver = wq_get_first_waiter(info, RECV);\n\t\tif (receiver) {\n\t\t\tpipelined_send(&wake_q, info, msg_ptr, receiver);\n\t\t} else {\n\t\t\t \n\t\t\tret = msg_insert(msg_ptr, info);\n\t\t\tif (ret)\n\t\t\t\tgoto out_unlock;\n\t\t\t__do_notify(info);\n\t\t}\n\t\tinode->i_atime = inode->i_mtime = inode_set_ctime_current(inode);\n\t}\nout_unlock:\n\tspin_unlock(&info->lock);\n\twake_up_q(&wake_q);\nout_free:\n\tif (ret)\n\t\tfree_msg(msg_ptr);\nout_fput:\n\tfdput(f);\nout:\n\treturn ret;\n}\n\nstatic int do_mq_timedreceive(mqd_t mqdes, char __user *u_msg_ptr,\n\t\tsize_t msg_len, unsigned int __user *u_msg_prio,\n\t\tstruct timespec64 *ts)\n{\n\tssize_t ret;\n\tstruct msg_msg *msg_ptr;\n\tstruct fd f;\n\tstruct inode *inode;\n\tstruct mqueue_inode_info *info;\n\tstruct ext_wait_queue wait;\n\tktime_t expires, *timeout = NULL;\n\tstruct posix_msg_tree_node *new_leaf = NULL;\n\n\tif (ts) {\n\t\texpires = timespec64_to_ktime(*ts);\n\t\ttimeout = &expires;\n\t}\n\n\taudit_mq_sendrecv(mqdes, msg_len, 0, ts);\n\n\tf = fdget(mqdes);\n\tif (unlikely(!f.file)) {\n\t\tret = -EBADF;\n\t\tgoto out;\n\t}\n\n\tinode = file_inode(f.file);\n\tif (unlikely(f.file->f_op != &mqueue_file_operations)) {\n\t\tret = -EBADF;\n\t\tgoto out_fput;\n\t}\n\tinfo = MQUEUE_I(inode);\n\taudit_file(f.file);\n\n\tif (unlikely(!(f.file->f_mode & FMODE_READ))) {\n\t\tret = -EBADF;\n\t\tgoto out_fput;\n\t}\n\n\t \n\tif (unlikely(msg_len < info->attr.mq_msgsize)) {\n\t\tret = -EMSGSIZE;\n\t\tgoto out_fput;\n\t}\n\n\t \n\tif (!info->node_cache)\n\t\tnew_leaf = kmalloc(sizeof(*new_leaf), GFP_KERNEL);\n\n\tspin_lock(&info->lock);\n\n\tif (!info->node_cache && new_leaf) {\n\t\t \n\t\tINIT_LIST_HEAD(&new_leaf->msg_list);\n\t\tinfo->node_cache = new_leaf;\n\t} else {\n\t\tkfree(new_leaf);\n\t}\n\n\tif (info->attr.mq_curmsgs == 0) {\n\t\tif (f.file->f_flags & O_NONBLOCK) {\n\t\t\tspin_unlock(&info->lock);\n\t\t\tret = -EAGAIN;\n\t\t} else {\n\t\t\twait.task = current;\n\n\t\t\t \n\t\t\tWRITE_ONCE(wait.state, STATE_NONE);\n\t\t\tret = wq_sleep(info, RECV, timeout, &wait);\n\t\t\tmsg_ptr = wait.msg;\n\t\t}\n\t} else {\n\t\tDEFINE_WAKE_Q(wake_q);\n\n\t\tmsg_ptr = msg_get(info);\n\n\t\tinode->i_atime = inode->i_mtime = inode_set_ctime_current(inode);\n\n\t\t \n\t\tpipelined_receive(&wake_q, info);\n\t\tspin_unlock(&info->lock);\n\t\twake_up_q(&wake_q);\n\t\tret = 0;\n\t}\n\tif (ret == 0) {\n\t\tret = msg_ptr->m_ts;\n\n\t\tif ((u_msg_prio && put_user(msg_ptr->m_type, u_msg_prio)) ||\n\t\t\tstore_msg(u_msg_ptr, msg_ptr, msg_ptr->m_ts)) {\n\t\t\tret = -EFAULT;\n\t\t}\n\t\tfree_msg(msg_ptr);\n\t}\nout_fput:\n\tfdput(f);\nout:\n\treturn ret;\n}\n\nSYSCALL_DEFINE5(mq_timedsend, mqd_t, mqdes, const char __user *, u_msg_ptr,\n\t\tsize_t, msg_len, unsigned int, msg_prio,\n\t\tconst struct __kernel_timespec __user *, u_abs_timeout)\n{\n\tstruct timespec64 ts, *p = NULL;\n\tif (u_abs_timeout) {\n\t\tint res = prepare_timeout(u_abs_timeout, &ts);\n\t\tif (res)\n\t\t\treturn res;\n\t\tp = &ts;\n\t}\n\treturn do_mq_timedsend(mqdes, u_msg_ptr, msg_len, msg_prio, p);\n}\n\nSYSCALL_DEFINE5(mq_timedreceive, mqd_t, mqdes, char __user *, u_msg_ptr,\n\t\tsize_t, msg_len, unsigned int __user *, u_msg_prio,\n\t\tconst struct __kernel_timespec __user *, u_abs_timeout)\n{\n\tstruct timespec64 ts, *p = NULL;\n\tif (u_abs_timeout) {\n\t\tint res = prepare_timeout(u_abs_timeout, &ts);\n\t\tif (res)\n\t\t\treturn res;\n\t\tp = &ts;\n\t}\n\treturn do_mq_timedreceive(mqdes, u_msg_ptr, msg_len, u_msg_prio, p);\n}\n\n \nstatic int do_mq_notify(mqd_t mqdes, const struct sigevent *notification)\n{\n\tint ret;\n\tstruct fd f;\n\tstruct sock *sock;\n\tstruct inode *inode;\n\tstruct mqueue_inode_info *info;\n\tstruct sk_buff *nc;\n\n\taudit_mq_notify(mqdes, notification);\n\n\tnc = NULL;\n\tsock = NULL;\n\tif (notification != NULL) {\n\t\tif (unlikely(notification->sigev_notify != SIGEV_NONE &&\n\t\t\t     notification->sigev_notify != SIGEV_SIGNAL &&\n\t\t\t     notification->sigev_notify != SIGEV_THREAD))\n\t\t\treturn -EINVAL;\n\t\tif (notification->sigev_notify == SIGEV_SIGNAL &&\n\t\t\t!valid_signal(notification->sigev_signo)) {\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (notification->sigev_notify == SIGEV_THREAD) {\n\t\t\tlong timeo;\n\n\t\t\t \n\t\t\tnc = alloc_skb(NOTIFY_COOKIE_LEN, GFP_KERNEL);\n\t\t\tif (!nc)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tif (copy_from_user(nc->data,\n\t\t\t\t\tnotification->sigev_value.sival_ptr,\n\t\t\t\t\tNOTIFY_COOKIE_LEN)) {\n\t\t\t\tret = -EFAULT;\n\t\t\t\tgoto free_skb;\n\t\t\t}\n\n\t\t\t \n\t\t\tskb_put(nc, NOTIFY_COOKIE_LEN);\n\t\t\t \nretry:\n\t\t\tf = fdget(notification->sigev_signo);\n\t\t\tif (!f.file) {\n\t\t\t\tret = -EBADF;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tsock = netlink_getsockbyfilp(f.file);\n\t\t\tfdput(f);\n\t\t\tif (IS_ERR(sock)) {\n\t\t\t\tret = PTR_ERR(sock);\n\t\t\t\tgoto free_skb;\n\t\t\t}\n\n\t\t\ttimeo = MAX_SCHEDULE_TIMEOUT;\n\t\t\tret = netlink_attachskb(sock, nc, &timeo, NULL);\n\t\t\tif (ret == 1) {\n\t\t\t\tsock = NULL;\n\t\t\t\tgoto retry;\n\t\t\t}\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\tf = fdget(mqdes);\n\tif (!f.file) {\n\t\tret = -EBADF;\n\t\tgoto out;\n\t}\n\n\tinode = file_inode(f.file);\n\tif (unlikely(f.file->f_op != &mqueue_file_operations)) {\n\t\tret = -EBADF;\n\t\tgoto out_fput;\n\t}\n\tinfo = MQUEUE_I(inode);\n\n\tret = 0;\n\tspin_lock(&info->lock);\n\tif (notification == NULL) {\n\t\tif (info->notify_owner == task_tgid(current)) {\n\t\t\tremove_notification(info);\n\t\t\tinode->i_atime = inode_set_ctime_current(inode);\n\t\t}\n\t} else if (info->notify_owner != NULL) {\n\t\tret = -EBUSY;\n\t} else {\n\t\tswitch (notification->sigev_notify) {\n\t\tcase SIGEV_NONE:\n\t\t\tinfo->notify.sigev_notify = SIGEV_NONE;\n\t\t\tbreak;\n\t\tcase SIGEV_THREAD:\n\t\t\tinfo->notify_sock = sock;\n\t\t\tinfo->notify_cookie = nc;\n\t\t\tsock = NULL;\n\t\t\tnc = NULL;\n\t\t\tinfo->notify.sigev_notify = SIGEV_THREAD;\n\t\t\tbreak;\n\t\tcase SIGEV_SIGNAL:\n\t\t\tinfo->notify.sigev_signo = notification->sigev_signo;\n\t\t\tinfo->notify.sigev_value = notification->sigev_value;\n\t\t\tinfo->notify.sigev_notify = SIGEV_SIGNAL;\n\t\t\tinfo->notify_self_exec_id = current->self_exec_id;\n\t\t\tbreak;\n\t\t}\n\n\t\tinfo->notify_owner = get_pid(task_tgid(current));\n\t\tinfo->notify_user_ns = get_user_ns(current_user_ns());\n\t\tinode->i_atime = inode_set_ctime_current(inode);\n\t}\n\tspin_unlock(&info->lock);\nout_fput:\n\tfdput(f);\nout:\n\tif (sock)\n\t\tnetlink_detachskb(sock, nc);\n\telse\nfree_skb:\n\t\tdev_kfree_skb(nc);\n\n\treturn ret;\n}\n\nSYSCALL_DEFINE2(mq_notify, mqd_t, mqdes,\n\t\tconst struct sigevent __user *, u_notification)\n{\n\tstruct sigevent n, *p = NULL;\n\tif (u_notification) {\n\t\tif (copy_from_user(&n, u_notification, sizeof(struct sigevent)))\n\t\t\treturn -EFAULT;\n\t\tp = &n;\n\t}\n\treturn do_mq_notify(mqdes, p);\n}\n\nstatic int do_mq_getsetattr(int mqdes, struct mq_attr *new, struct mq_attr *old)\n{\n\tstruct fd f;\n\tstruct inode *inode;\n\tstruct mqueue_inode_info *info;\n\n\tif (new && (new->mq_flags & (~O_NONBLOCK)))\n\t\treturn -EINVAL;\n\n\tf = fdget(mqdes);\n\tif (!f.file)\n\t\treturn -EBADF;\n\n\tif (unlikely(f.file->f_op != &mqueue_file_operations)) {\n\t\tfdput(f);\n\t\treturn -EBADF;\n\t}\n\n\tinode = file_inode(f.file);\n\tinfo = MQUEUE_I(inode);\n\n\tspin_lock(&info->lock);\n\n\tif (old) {\n\t\t*old = info->attr;\n\t\told->mq_flags = f.file->f_flags & O_NONBLOCK;\n\t}\n\tif (new) {\n\t\taudit_mq_getsetattr(mqdes, new);\n\t\tspin_lock(&f.file->f_lock);\n\t\tif (new->mq_flags & O_NONBLOCK)\n\t\t\tf.file->f_flags |= O_NONBLOCK;\n\t\telse\n\t\t\tf.file->f_flags &= ~O_NONBLOCK;\n\t\tspin_unlock(&f.file->f_lock);\n\n\t\tinode->i_atime = inode_set_ctime_current(inode);\n\t}\n\n\tspin_unlock(&info->lock);\n\tfdput(f);\n\treturn 0;\n}\n\nSYSCALL_DEFINE3(mq_getsetattr, mqd_t, mqdes,\n\t\tconst struct mq_attr __user *, u_mqstat,\n\t\tstruct mq_attr __user *, u_omqstat)\n{\n\tint ret;\n\tstruct mq_attr mqstat, omqstat;\n\tstruct mq_attr *new = NULL, *old = NULL;\n\n\tif (u_mqstat) {\n\t\tnew = &mqstat;\n\t\tif (copy_from_user(new, u_mqstat, sizeof(struct mq_attr)))\n\t\t\treturn -EFAULT;\n\t}\n\tif (u_omqstat)\n\t\told = &omqstat;\n\n\tret = do_mq_getsetattr(mqdes, new, old);\n\tif (ret || !old)\n\t\treturn ret;\n\n\tif (copy_to_user(u_omqstat, old, sizeof(struct mq_attr)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\n#ifdef CONFIG_COMPAT\n\nstruct compat_mq_attr {\n\tcompat_long_t mq_flags;       \n\tcompat_long_t mq_maxmsg;      \n\tcompat_long_t mq_msgsize;     \n\tcompat_long_t mq_curmsgs;     \n\tcompat_long_t __reserved[4];  \n};\n\nstatic inline int get_compat_mq_attr(struct mq_attr *attr,\n\t\t\tconst struct compat_mq_attr __user *uattr)\n{\n\tstruct compat_mq_attr v;\n\n\tif (copy_from_user(&v, uattr, sizeof(*uattr)))\n\t\treturn -EFAULT;\n\n\tmemset(attr, 0, sizeof(*attr));\n\tattr->mq_flags = v.mq_flags;\n\tattr->mq_maxmsg = v.mq_maxmsg;\n\tattr->mq_msgsize = v.mq_msgsize;\n\tattr->mq_curmsgs = v.mq_curmsgs;\n\treturn 0;\n}\n\nstatic inline int put_compat_mq_attr(const struct mq_attr *attr,\n\t\t\tstruct compat_mq_attr __user *uattr)\n{\n\tstruct compat_mq_attr v;\n\n\tmemset(&v, 0, sizeof(v));\n\tv.mq_flags = attr->mq_flags;\n\tv.mq_maxmsg = attr->mq_maxmsg;\n\tv.mq_msgsize = attr->mq_msgsize;\n\tv.mq_curmsgs = attr->mq_curmsgs;\n\tif (copy_to_user(uattr, &v, sizeof(*uattr)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nCOMPAT_SYSCALL_DEFINE4(mq_open, const char __user *, u_name,\n\t\t       int, oflag, compat_mode_t, mode,\n\t\t       struct compat_mq_attr __user *, u_attr)\n{\n\tstruct mq_attr attr, *p = NULL;\n\tif (u_attr && oflag & O_CREAT) {\n\t\tp = &attr;\n\t\tif (get_compat_mq_attr(&attr, u_attr))\n\t\t\treturn -EFAULT;\n\t}\n\treturn do_mq_open(u_name, oflag, mode, p);\n}\n\nCOMPAT_SYSCALL_DEFINE2(mq_notify, mqd_t, mqdes,\n\t\t       const struct compat_sigevent __user *, u_notification)\n{\n\tstruct sigevent n, *p = NULL;\n\tif (u_notification) {\n\t\tif (get_compat_sigevent(&n, u_notification))\n\t\t\treturn -EFAULT;\n\t\tif (n.sigev_notify == SIGEV_THREAD)\n\t\t\tn.sigev_value.sival_ptr = compat_ptr(n.sigev_value.sival_int);\n\t\tp = &n;\n\t}\n\treturn do_mq_notify(mqdes, p);\n}\n\nCOMPAT_SYSCALL_DEFINE3(mq_getsetattr, mqd_t, mqdes,\n\t\t       const struct compat_mq_attr __user *, u_mqstat,\n\t\t       struct compat_mq_attr __user *, u_omqstat)\n{\n\tint ret;\n\tstruct mq_attr mqstat, omqstat;\n\tstruct mq_attr *new = NULL, *old = NULL;\n\n\tif (u_mqstat) {\n\t\tnew = &mqstat;\n\t\tif (get_compat_mq_attr(new, u_mqstat))\n\t\t\treturn -EFAULT;\n\t}\n\tif (u_omqstat)\n\t\told = &omqstat;\n\n\tret = do_mq_getsetattr(mqdes, new, old);\n\tif (ret || !old)\n\t\treturn ret;\n\n\tif (put_compat_mq_attr(old, u_omqstat))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n#endif\n\n#ifdef CONFIG_COMPAT_32BIT_TIME\nstatic int compat_prepare_timeout(const struct old_timespec32 __user *p,\n\t\t\t\t   struct timespec64 *ts)\n{\n\tif (get_old_timespec32(ts, p))\n\t\treturn -EFAULT;\n\tif (!timespec64_valid(ts))\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\nSYSCALL_DEFINE5(mq_timedsend_time32, mqd_t, mqdes,\n\t\tconst char __user *, u_msg_ptr,\n\t\tunsigned int, msg_len, unsigned int, msg_prio,\n\t\tconst struct old_timespec32 __user *, u_abs_timeout)\n{\n\tstruct timespec64 ts, *p = NULL;\n\tif (u_abs_timeout) {\n\t\tint res = compat_prepare_timeout(u_abs_timeout, &ts);\n\t\tif (res)\n\t\t\treturn res;\n\t\tp = &ts;\n\t}\n\treturn do_mq_timedsend(mqdes, u_msg_ptr, msg_len, msg_prio, p);\n}\n\nSYSCALL_DEFINE5(mq_timedreceive_time32, mqd_t, mqdes,\n\t\tchar __user *, u_msg_ptr,\n\t\tunsigned int, msg_len, unsigned int __user *, u_msg_prio,\n\t\tconst struct old_timespec32 __user *, u_abs_timeout)\n{\n\tstruct timespec64 ts, *p = NULL;\n\tif (u_abs_timeout) {\n\t\tint res = compat_prepare_timeout(u_abs_timeout, &ts);\n\t\tif (res)\n\t\t\treturn res;\n\t\tp = &ts;\n\t}\n\treturn do_mq_timedreceive(mqdes, u_msg_ptr, msg_len, u_msg_prio, p);\n}\n#endif\n\nstatic const struct inode_operations mqueue_dir_inode_operations = {\n\t.lookup = simple_lookup,\n\t.create = mqueue_create,\n\t.unlink = mqueue_unlink,\n};\n\nstatic const struct file_operations mqueue_file_operations = {\n\t.flush = mqueue_flush_file,\n\t.poll = mqueue_poll_file,\n\t.read = mqueue_read_file,\n\t.llseek = default_llseek,\n};\n\nstatic const struct super_operations mqueue_super_ops = {\n\t.alloc_inode = mqueue_alloc_inode,\n\t.free_inode = mqueue_free_inode,\n\t.evict_inode = mqueue_evict_inode,\n\t.statfs = simple_statfs,\n};\n\nstatic const struct fs_context_operations mqueue_fs_context_ops = {\n\t.free\t\t= mqueue_fs_context_free,\n\t.get_tree\t= mqueue_get_tree,\n};\n\nstatic struct file_system_type mqueue_fs_type = {\n\t.name\t\t\t= \"mqueue\",\n\t.init_fs_context\t= mqueue_init_fs_context,\n\t.kill_sb\t\t= kill_litter_super,\n\t.fs_flags\t\t= FS_USERNS_MOUNT,\n};\n\nint mq_init_ns(struct ipc_namespace *ns)\n{\n\tstruct vfsmount *m;\n\n\tns->mq_queues_count  = 0;\n\tns->mq_queues_max    = DFLT_QUEUESMAX;\n\tns->mq_msg_max       = DFLT_MSGMAX;\n\tns->mq_msgsize_max   = DFLT_MSGSIZEMAX;\n\tns->mq_msg_default   = DFLT_MSG;\n\tns->mq_msgsize_default  = DFLT_MSGSIZE;\n\n\tm = mq_create_mount(ns);\n\tif (IS_ERR(m))\n\t\treturn PTR_ERR(m);\n\tns->mq_mnt = m;\n\treturn 0;\n}\n\nvoid mq_clear_sbinfo(struct ipc_namespace *ns)\n{\n\tns->mq_mnt->mnt_sb->s_fs_info = NULL;\n}\n\nstatic int __init init_mqueue_fs(void)\n{\n\tint error;\n\n\tmqueue_inode_cachep = kmem_cache_create(\"mqueue_inode_cache\",\n\t\t\t\tsizeof(struct mqueue_inode_info), 0,\n\t\t\t\tSLAB_HWCACHE_ALIGN|SLAB_ACCOUNT, init_once);\n\tif (mqueue_inode_cachep == NULL)\n\t\treturn -ENOMEM;\n\n\tif (!setup_mq_sysctls(&init_ipc_ns)) {\n\t\tpr_warn(\"sysctl registration failed\\n\");\n\t\terror = -ENOMEM;\n\t\tgoto out_kmem;\n\t}\n\n\terror = register_filesystem(&mqueue_fs_type);\n\tif (error)\n\t\tgoto out_sysctl;\n\n\tspin_lock_init(&mq_lock);\n\n\terror = mq_init_ns(&init_ipc_ns);\n\tif (error)\n\t\tgoto out_filesystem;\n\n\treturn 0;\n\nout_filesystem:\n\tunregister_filesystem(&mqueue_fs_type);\nout_sysctl:\n\tretire_mq_sysctls(&init_ipc_ns);\nout_kmem:\n\tkmem_cache_destroy(mqueue_inode_cachep);\n\treturn error;\n}\n\ndevice_initcall(init_mqueue_fs);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}