{
  "module_name": "util.c",
  "hash_id": "367eeef0febd033c7c6f5035db9c2954c69ef5ea6566ca9dbba4ebbaf4897415",
  "original_prompt": "Ingested from linux-6.6.14/ipc/util.c",
  "human_readable_source": "\n \n\n#include <linux/mm.h>\n#include <linux/shm.h>\n#include <linux/init.h>\n#include <linux/msg.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/notifier.h>\n#include <linux/capability.h>\n#include <linux/highuid.h>\n#include <linux/security.h>\n#include <linux/rcupdate.h>\n#include <linux/workqueue.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/audit.h>\n#include <linux/nsproxy.h>\n#include <linux/rwsem.h>\n#include <linux/memory.h>\n#include <linux/ipc_namespace.h>\n#include <linux/rhashtable.h>\n#include <linux/log2.h>\n\n#include <asm/unistd.h>\n\n#include \"util.h\"\n\nstruct ipc_proc_iface {\n\tconst char *path;\n\tconst char *header;\n\tint ids;\n\tint (*show)(struct seq_file *, void *);\n};\n\n \nstatic int __init ipc_init(void)\n{\n\tproc_mkdir(\"sysvipc\", NULL);\n\tsem_init();\n\tmsg_init();\n\tshm_init();\n\n\treturn 0;\n}\ndevice_initcall(ipc_init);\n\nstatic const struct rhashtable_params ipc_kht_params = {\n\t.head_offset\t\t= offsetof(struct kern_ipc_perm, khtnode),\n\t.key_offset\t\t= offsetof(struct kern_ipc_perm, key),\n\t.key_len\t\t= sizeof_field(struct kern_ipc_perm, key),\n\t.automatic_shrinking\t= true,\n};\n\n \nvoid ipc_init_ids(struct ipc_ids *ids)\n{\n\tids->in_use = 0;\n\tids->seq = 0;\n\tinit_rwsem(&ids->rwsem);\n\trhashtable_init(&ids->key_ht, &ipc_kht_params);\n\tidr_init(&ids->ipcs_idr);\n\tids->max_idx = -1;\n\tids->last_idx = -1;\n#ifdef CONFIG_CHECKPOINT_RESTORE\n\tids->next_id = -1;\n#endif\n}\n\n#ifdef CONFIG_PROC_FS\nstatic const struct proc_ops sysvipc_proc_ops;\n \nvoid __init ipc_init_proc_interface(const char *path, const char *header,\n\t\tint ids, int (*show)(struct seq_file *, void *))\n{\n\tstruct proc_dir_entry *pde;\n\tstruct ipc_proc_iface *iface;\n\n\tiface = kmalloc(sizeof(*iface), GFP_KERNEL);\n\tif (!iface)\n\t\treturn;\n\tiface->path\t= path;\n\tiface->header\t= header;\n\tiface->ids\t= ids;\n\tiface->show\t= show;\n\n\tpde = proc_create_data(path,\n\t\t\t       S_IRUGO,         \n\t\t\t       NULL,            \n\t\t\t       &sysvipc_proc_ops,\n\t\t\t       iface);\n\tif (!pde)\n\t\tkfree(iface);\n}\n#endif\n\n \nstatic struct kern_ipc_perm *ipc_findkey(struct ipc_ids *ids, key_t key)\n{\n\tstruct kern_ipc_perm *ipcp;\n\n\tipcp = rhashtable_lookup_fast(&ids->key_ht, &key,\n\t\t\t\t\t      ipc_kht_params);\n\tif (!ipcp)\n\t\treturn NULL;\n\n\trcu_read_lock();\n\tipc_lock_object(ipcp);\n\treturn ipcp;\n}\n\n \nstatic inline int ipc_idr_alloc(struct ipc_ids *ids, struct kern_ipc_perm *new)\n{\n\tint idx, next_id = -1;\n\n#ifdef CONFIG_CHECKPOINT_RESTORE\n\tnext_id = ids->next_id;\n\tids->next_id = -1;\n#endif\n\n\t \n\n\tif (next_id < 0) {  \n\t\tint max_idx;\n\n\t\tmax_idx = max(ids->in_use*3/2, ipc_min_cycle);\n\t\tmax_idx = min(max_idx, ipc_mni);\n\n\t\t \n\t\tidx = idr_alloc_cyclic(&ids->ipcs_idr, NULL, 0, max_idx,\n\t\t\t\t\tGFP_NOWAIT);\n\n\t\tif (idx >= 0) {\n\t\t\t \n\t\t\tif (idx <= ids->last_idx) {\n\t\t\t\tids->seq++;\n\t\t\t\tif (ids->seq >= ipcid_seq_max())\n\t\t\t\t\tids->seq = 0;\n\t\t\t}\n\t\t\tids->last_idx = idx;\n\n\t\t\tnew->seq = ids->seq;\n\t\t\t \n\t\t\tidr_replace(&ids->ipcs_idr, new, idx);\n\t\t}\n\t} else {\n\t\tnew->seq = ipcid_to_seqx(next_id);\n\t\tidx = idr_alloc(&ids->ipcs_idr, new, ipcid_to_idx(next_id),\n\t\t\t\t0, GFP_NOWAIT);\n\t}\n\tif (idx >= 0)\n\t\tnew->id = (new->seq << ipcmni_seq_shift()) + idx;\n\treturn idx;\n}\n\n \nint ipc_addid(struct ipc_ids *ids, struct kern_ipc_perm *new, int limit)\n{\n\tkuid_t euid;\n\tkgid_t egid;\n\tint idx, err;\n\n\t \n\trefcount_set(&new->refcount, 1);\n\n\tif (limit > ipc_mni)\n\t\tlimit = ipc_mni;\n\n\tif (ids->in_use >= limit)\n\t\treturn -ENOSPC;\n\n\tidr_preload(GFP_KERNEL);\n\n\tspin_lock_init(&new->lock);\n\trcu_read_lock();\n\tspin_lock(&new->lock);\n\n\tcurrent_euid_egid(&euid, &egid);\n\tnew->cuid = new->uid = euid;\n\tnew->gid = new->cgid = egid;\n\n\tnew->deleted = false;\n\n\tidx = ipc_idr_alloc(ids, new);\n\tidr_preload_end();\n\n\tif (idx >= 0 && new->key != IPC_PRIVATE) {\n\t\terr = rhashtable_insert_fast(&ids->key_ht, &new->khtnode,\n\t\t\t\t\t     ipc_kht_params);\n\t\tif (err < 0) {\n\t\t\tidr_remove(&ids->ipcs_idr, idx);\n\t\t\tidx = err;\n\t\t}\n\t}\n\tif (idx < 0) {\n\t\tnew->deleted = true;\n\t\tspin_unlock(&new->lock);\n\t\trcu_read_unlock();\n\t\treturn idx;\n\t}\n\n\tids->in_use++;\n\tif (idx > ids->max_idx)\n\t\tids->max_idx = idx;\n\treturn idx;\n}\n\n \nstatic int ipcget_new(struct ipc_namespace *ns, struct ipc_ids *ids,\n\t\tconst struct ipc_ops *ops, struct ipc_params *params)\n{\n\tint err;\n\n\tdown_write(&ids->rwsem);\n\terr = ops->getnew(ns, params);\n\tup_write(&ids->rwsem);\n\treturn err;\n}\n\n \nstatic int ipc_check_perms(struct ipc_namespace *ns,\n\t\t\t   struct kern_ipc_perm *ipcp,\n\t\t\t   const struct ipc_ops *ops,\n\t\t\t   struct ipc_params *params)\n{\n\tint err;\n\n\tif (ipcperms(ns, ipcp, params->flg))\n\t\terr = -EACCES;\n\telse {\n\t\terr = ops->associate(ipcp, params->flg);\n\t\tif (!err)\n\t\t\terr = ipcp->id;\n\t}\n\n\treturn err;\n}\n\n \nstatic int ipcget_public(struct ipc_namespace *ns, struct ipc_ids *ids,\n\t\tconst struct ipc_ops *ops, struct ipc_params *params)\n{\n\tstruct kern_ipc_perm *ipcp;\n\tint flg = params->flg;\n\tint err;\n\n\t \n\tdown_write(&ids->rwsem);\n\tipcp = ipc_findkey(ids, params->key);\n\tif (ipcp == NULL) {\n\t\t \n\t\tif (!(flg & IPC_CREAT))\n\t\t\terr = -ENOENT;\n\t\telse\n\t\t\terr = ops->getnew(ns, params);\n\t} else {\n\t\t \n\n\t\tif (flg & IPC_CREAT && flg & IPC_EXCL)\n\t\t\terr = -EEXIST;\n\t\telse {\n\t\t\terr = 0;\n\t\t\tif (ops->more_checks)\n\t\t\t\terr = ops->more_checks(ipcp, params);\n\t\t\tif (!err)\n\t\t\t\t \n\t\t\t\terr = ipc_check_perms(ns, ipcp, ops, params);\n\t\t}\n\t\tipc_unlock(ipcp);\n\t}\n\tup_write(&ids->rwsem);\n\n\treturn err;\n}\n\n \nstatic void ipc_kht_remove(struct ipc_ids *ids, struct kern_ipc_perm *ipcp)\n{\n\tif (ipcp->key != IPC_PRIVATE)\n\t\tWARN_ON_ONCE(rhashtable_remove_fast(&ids->key_ht, &ipcp->khtnode,\n\t\t\t\t       ipc_kht_params));\n}\n\n \nstatic int ipc_search_maxidx(struct ipc_ids *ids, int limit)\n{\n\tint tmpidx;\n\tint i;\n\tint retval;\n\n\ti = ilog2(limit+1);\n\n\tretval = 0;\n\tfor (; i >= 0; i--) {\n\t\ttmpidx = retval | (1<<i);\n\t\t \n\t\ttmpidx = tmpidx-1;\n\t\tif (idr_get_next(&ids->ipcs_idr, &tmpidx))\n\t\t\tretval |= (1<<i);\n\t}\n\treturn retval - 1;\n}\n\n \nvoid ipc_rmid(struct ipc_ids *ids, struct kern_ipc_perm *ipcp)\n{\n\tint idx = ipcid_to_idx(ipcp->id);\n\n\tWARN_ON_ONCE(idr_remove(&ids->ipcs_idr, idx) != ipcp);\n\tipc_kht_remove(ids, ipcp);\n\tids->in_use--;\n\tipcp->deleted = true;\n\n\tif (unlikely(idx == ids->max_idx)) {\n\t\tidx = ids->max_idx-1;\n\t\tif (idx >= 0)\n\t\t\tidx = ipc_search_maxidx(ids, idx);\n\t\tids->max_idx = idx;\n\t}\n}\n\n \nvoid ipc_set_key_private(struct ipc_ids *ids, struct kern_ipc_perm *ipcp)\n{\n\tipc_kht_remove(ids, ipcp);\n\tipcp->key = IPC_PRIVATE;\n}\n\nbool ipc_rcu_getref(struct kern_ipc_perm *ptr)\n{\n\treturn refcount_inc_not_zero(&ptr->refcount);\n}\n\nvoid ipc_rcu_putref(struct kern_ipc_perm *ptr,\n\t\t\tvoid (*func)(struct rcu_head *head))\n{\n\tif (!refcount_dec_and_test(&ptr->refcount))\n\t\treturn;\n\n\tcall_rcu(&ptr->rcu, func);\n}\n\n \nint ipcperms(struct ipc_namespace *ns, struct kern_ipc_perm *ipcp, short flag)\n{\n\tkuid_t euid = current_euid();\n\tint requested_mode, granted_mode;\n\n\taudit_ipc_obj(ipcp);\n\trequested_mode = (flag >> 6) | (flag >> 3) | flag;\n\tgranted_mode = ipcp->mode;\n\tif (uid_eq(euid, ipcp->cuid) ||\n\t    uid_eq(euid, ipcp->uid))\n\t\tgranted_mode >>= 6;\n\telse if (in_group_p(ipcp->cgid) || in_group_p(ipcp->gid))\n\t\tgranted_mode >>= 3;\n\t \n\tif ((requested_mode & ~granted_mode & 0007) &&\n\t    !ns_capable(ns->user_ns, CAP_IPC_OWNER))\n\t\treturn -1;\n\n\treturn security_ipc_permission(ipcp, flag);\n}\n\n \n\n \nvoid kernel_to_ipc64_perm(struct kern_ipc_perm *in, struct ipc64_perm *out)\n{\n\tout->key\t= in->key;\n\tout->uid\t= from_kuid_munged(current_user_ns(), in->uid);\n\tout->gid\t= from_kgid_munged(current_user_ns(), in->gid);\n\tout->cuid\t= from_kuid_munged(current_user_ns(), in->cuid);\n\tout->cgid\t= from_kgid_munged(current_user_ns(), in->cgid);\n\tout->mode\t= in->mode;\n\tout->seq\t= in->seq;\n}\n\n \nvoid ipc64_perm_to_ipc_perm(struct ipc64_perm *in, struct ipc_perm *out)\n{\n\tout->key\t= in->key;\n\tSET_UID(out->uid, in->uid);\n\tSET_GID(out->gid, in->gid);\n\tSET_UID(out->cuid, in->cuid);\n\tSET_GID(out->cgid, in->cgid);\n\tout->mode\t= in->mode;\n\tout->seq\t= in->seq;\n}\n\n \nstruct kern_ipc_perm *ipc_obtain_object_idr(struct ipc_ids *ids, int id)\n{\n\tstruct kern_ipc_perm *out;\n\tint idx = ipcid_to_idx(id);\n\n\tout = idr_find(&ids->ipcs_idr, idx);\n\tif (!out)\n\t\treturn ERR_PTR(-EINVAL);\n\n\treturn out;\n}\n\n \nstruct kern_ipc_perm *ipc_obtain_object_check(struct ipc_ids *ids, int id)\n{\n\tstruct kern_ipc_perm *out = ipc_obtain_object_idr(ids, id);\n\n\tif (IS_ERR(out))\n\t\tgoto out;\n\n\tif (ipc_checkid(out, id))\n\t\treturn ERR_PTR(-EINVAL);\nout:\n\treturn out;\n}\n\n \nint ipcget(struct ipc_namespace *ns, struct ipc_ids *ids,\n\t\t\tconst struct ipc_ops *ops, struct ipc_params *params)\n{\n\tif (params->key == IPC_PRIVATE)\n\t\treturn ipcget_new(ns, ids, ops, params);\n\telse\n\t\treturn ipcget_public(ns, ids, ops, params);\n}\n\n \nint ipc_update_perm(struct ipc64_perm *in, struct kern_ipc_perm *out)\n{\n\tkuid_t uid = make_kuid(current_user_ns(), in->uid);\n\tkgid_t gid = make_kgid(current_user_ns(), in->gid);\n\tif (!uid_valid(uid) || !gid_valid(gid))\n\t\treturn -EINVAL;\n\n\tout->uid = uid;\n\tout->gid = gid;\n\tout->mode = (out->mode & ~S_IRWXUGO)\n\t\t| (in->mode & S_IRWXUGO);\n\n\treturn 0;\n}\n\n \nstruct kern_ipc_perm *ipcctl_obtain_check(struct ipc_namespace *ns,\n\t\t\t\t\tstruct ipc_ids *ids, int id, int cmd,\n\t\t\t\t\tstruct ipc64_perm *perm, int extra_perm)\n{\n\tkuid_t euid;\n\tint err = -EPERM;\n\tstruct kern_ipc_perm *ipcp;\n\n\tipcp = ipc_obtain_object_check(ids, id);\n\tif (IS_ERR(ipcp)) {\n\t\terr = PTR_ERR(ipcp);\n\t\tgoto err;\n\t}\n\n\taudit_ipc_obj(ipcp);\n\tif (cmd == IPC_SET)\n\t\taudit_ipc_set_perm(extra_perm, perm->uid,\n\t\t\t\t   perm->gid, perm->mode);\n\n\teuid = current_euid();\n\tif (uid_eq(euid, ipcp->cuid) || uid_eq(euid, ipcp->uid)  ||\n\t    ns_capable(ns->user_ns, CAP_SYS_ADMIN))\n\t\treturn ipcp;  \nerr:\n\treturn ERR_PTR(err);\n}\n\n#ifdef CONFIG_ARCH_WANT_IPC_PARSE_VERSION\n\n\n \nint ipc_parse_version(int *cmd)\n{\n\tif (*cmd & IPC_64) {\n\t\t*cmd ^= IPC_64;\n\t\treturn IPC_64;\n\t} else {\n\t\treturn IPC_OLD;\n\t}\n}\n\n#endif  \n\n#ifdef CONFIG_PROC_FS\nstruct ipc_proc_iter {\n\tstruct ipc_namespace *ns;\n\tstruct pid_namespace *pid_ns;\n\tstruct ipc_proc_iface *iface;\n};\n\nstruct pid_namespace *ipc_seq_pid_ns(struct seq_file *s)\n{\n\tstruct ipc_proc_iter *iter = s->private;\n\treturn iter->pid_ns;\n}\n\n \nstatic struct kern_ipc_perm *sysvipc_find_ipc(struct ipc_ids *ids, loff_t *pos)\n{\n\tint tmpidx;\n\tstruct kern_ipc_perm *ipc;\n\n\t \n\ttmpidx = *pos - 1;\n\n\tipc = idr_get_next(&ids->ipcs_idr, &tmpidx);\n\tif (ipc != NULL) {\n\t\trcu_read_lock();\n\t\tipc_lock_object(ipc);\n\n\t\t \n\t\t*pos = tmpidx + 1;\n\t}\n\treturn ipc;\n}\n\nstatic void *sysvipc_proc_next(struct seq_file *s, void *it, loff_t *pos)\n{\n\tstruct ipc_proc_iter *iter = s->private;\n\tstruct ipc_proc_iface *iface = iter->iface;\n\tstruct kern_ipc_perm *ipc = it;\n\n\t \n\tif (ipc && ipc != SEQ_START_TOKEN)\n\t\tipc_unlock(ipc);\n\n\t \n\t(*pos)++;\n\treturn sysvipc_find_ipc(&iter->ns->ids[iface->ids], pos);\n}\n\n \nstatic void *sysvipc_proc_start(struct seq_file *s, loff_t *pos)\n{\n\tstruct ipc_proc_iter *iter = s->private;\n\tstruct ipc_proc_iface *iface = iter->iface;\n\tstruct ipc_ids *ids;\n\n\tids = &iter->ns->ids[iface->ids];\n\n\t \n\tdown_read(&ids->rwsem);\n\n\t \n\tif (*pos < 0)\n\t\treturn NULL;\n\n\t \n\tif (*pos == 0)\n\t\treturn SEQ_START_TOKEN;\n\n\t \n\treturn sysvipc_find_ipc(ids, pos);\n}\n\nstatic void sysvipc_proc_stop(struct seq_file *s, void *it)\n{\n\tstruct kern_ipc_perm *ipc = it;\n\tstruct ipc_proc_iter *iter = s->private;\n\tstruct ipc_proc_iface *iface = iter->iface;\n\tstruct ipc_ids *ids;\n\n\t \n\tif (ipc && ipc != SEQ_START_TOKEN)\n\t\tipc_unlock(ipc);\n\n\tids = &iter->ns->ids[iface->ids];\n\t \n\tup_read(&ids->rwsem);\n}\n\nstatic int sysvipc_proc_show(struct seq_file *s, void *it)\n{\n\tstruct ipc_proc_iter *iter = s->private;\n\tstruct ipc_proc_iface *iface = iter->iface;\n\n\tif (it == SEQ_START_TOKEN) {\n\t\tseq_puts(s, iface->header);\n\t\treturn 0;\n\t}\n\n\treturn iface->show(s, it);\n}\n\nstatic const struct seq_operations sysvipc_proc_seqops = {\n\t.start = sysvipc_proc_start,\n\t.stop  = sysvipc_proc_stop,\n\t.next  = sysvipc_proc_next,\n\t.show  = sysvipc_proc_show,\n};\n\nstatic int sysvipc_proc_open(struct inode *inode, struct file *file)\n{\n\tstruct ipc_proc_iter *iter;\n\n\titer = __seq_open_private(file, &sysvipc_proc_seqops, sizeof(*iter));\n\tif (!iter)\n\t\treturn -ENOMEM;\n\n\titer->iface = pde_data(inode);\n\titer->ns    = get_ipc_ns(current->nsproxy->ipc_ns);\n\titer->pid_ns = get_pid_ns(task_active_pid_ns(current));\n\n\treturn 0;\n}\n\nstatic int sysvipc_proc_release(struct inode *inode, struct file *file)\n{\n\tstruct seq_file *seq = file->private_data;\n\tstruct ipc_proc_iter *iter = seq->private;\n\tput_ipc_ns(iter->ns);\n\tput_pid_ns(iter->pid_ns);\n\treturn seq_release_private(inode, file);\n}\n\nstatic const struct proc_ops sysvipc_proc_ops = {\n\t.proc_flags\t= PROC_ENTRY_PERMANENT,\n\t.proc_open\t= sysvipc_proc_open,\n\t.proc_read\t= seq_read,\n\t.proc_lseek\t= seq_lseek,\n\t.proc_release\t= sysvipc_proc_release,\n};\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}