{
  "module_name": "shm.c",
  "hash_id": "05201e537f4af7fbd6aee4d755959296685c9a80b0785b88f8f96a206fcab85d",
  "original_prompt": "Ingested from linux-6.6.14/ipc/shm.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/hugetlb.h>\n#include <linux/shm.h>\n#include <linux/init.h>\n#include <linux/file.h>\n#include <linux/mman.h>\n#include <linux/shmem_fs.h>\n#include <linux/security.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/capability.h>\n#include <linux/ptrace.h>\n#include <linux/seq_file.h>\n#include <linux/rwsem.h>\n#include <linux/nsproxy.h>\n#include <linux/mount.h>\n#include <linux/ipc_namespace.h>\n#include <linux/rhashtable.h>\n\n#include <linux/uaccess.h>\n\n#include \"util.h\"\n\nstruct shmid_kernel  \n{\n\tstruct kern_ipc_perm\tshm_perm;\n\tstruct file\t\t*shm_file;\n\tunsigned long\t\tshm_nattch;\n\tunsigned long\t\tshm_segsz;\n\ttime64_t\t\tshm_atim;\n\ttime64_t\t\tshm_dtim;\n\ttime64_t\t\tshm_ctim;\n\tstruct pid\t\t*shm_cprid;\n\tstruct pid\t\t*shm_lprid;\n\tstruct ucounts\t\t*mlock_ucounts;\n\n\t \n\tstruct task_struct\t*shm_creator;\n\n\t \n\tstruct list_head\tshm_clist;\n\tstruct ipc_namespace\t*ns;\n} __randomize_layout;\n\n \n#define SHM_DEST\t01000\t \n#define SHM_LOCKED\t02000    \n\nstruct shm_file_data {\n\tint id;\n\tstruct ipc_namespace *ns;\n\tstruct file *file;\n\tconst struct vm_operations_struct *vm_ops;\n};\n\n#define shm_file_data(file) (*((struct shm_file_data **)&(file)->private_data))\n\nstatic const struct file_operations shm_file_operations;\nstatic const struct vm_operations_struct shm_vm_ops;\n\n#define shm_ids(ns)\t((ns)->ids[IPC_SHM_IDS])\n\n#define shm_unlock(shp)\t\t\t\\\n\tipc_unlock(&(shp)->shm_perm)\n\nstatic int newseg(struct ipc_namespace *, struct ipc_params *);\nstatic void shm_open(struct vm_area_struct *vma);\nstatic void shm_close(struct vm_area_struct *vma);\nstatic void shm_destroy(struct ipc_namespace *ns, struct shmid_kernel *shp);\n#ifdef CONFIG_PROC_FS\nstatic int sysvipc_shm_proc_show(struct seq_file *s, void *it);\n#endif\n\nvoid shm_init_ns(struct ipc_namespace *ns)\n{\n\tns->shm_ctlmax = SHMMAX;\n\tns->shm_ctlall = SHMALL;\n\tns->shm_ctlmni = SHMMNI;\n\tns->shm_rmid_forced = 0;\n\tns->shm_tot = 0;\n\tipc_init_ids(&shm_ids(ns));\n}\n\n \nstatic void do_shm_rmid(struct ipc_namespace *ns, struct kern_ipc_perm *ipcp)\n{\n\tstruct shmid_kernel *shp;\n\n\tshp = container_of(ipcp, struct shmid_kernel, shm_perm);\n\tWARN_ON(ns != shp->ns);\n\n\tif (shp->shm_nattch) {\n\t\tshp->shm_perm.mode |= SHM_DEST;\n\t\t \n\t\tipc_set_key_private(&shm_ids(ns), &shp->shm_perm);\n\t\tshm_unlock(shp);\n\t} else\n\t\tshm_destroy(ns, shp);\n}\n\n#ifdef CONFIG_IPC_NS\nvoid shm_exit_ns(struct ipc_namespace *ns)\n{\n\tfree_ipcs(ns, &shm_ids(ns), do_shm_rmid);\n\tidr_destroy(&ns->ids[IPC_SHM_IDS].ipcs_idr);\n\trhashtable_destroy(&ns->ids[IPC_SHM_IDS].key_ht);\n}\n#endif\n\nstatic int __init ipc_ns_init(void)\n{\n\tshm_init_ns(&init_ipc_ns);\n\treturn 0;\n}\n\npure_initcall(ipc_ns_init);\n\nvoid __init shm_init(void)\n{\n\tipc_init_proc_interface(\"sysvipc/shm\",\n#if BITS_PER_LONG <= 32\n\t\t\t\t\"       key      shmid perms       size  cpid  lpid nattch   uid   gid  cuid  cgid      atime      dtime      ctime        rss       swap\\n\",\n#else\n\t\t\t\t\"       key      shmid perms                  size  cpid  lpid nattch   uid   gid  cuid  cgid      atime      dtime      ctime                   rss                  swap\\n\",\n#endif\n\t\t\t\tIPC_SHM_IDS, sysvipc_shm_proc_show);\n}\n\nstatic inline struct shmid_kernel *shm_obtain_object(struct ipc_namespace *ns, int id)\n{\n\tstruct kern_ipc_perm *ipcp = ipc_obtain_object_idr(&shm_ids(ns), id);\n\n\tif (IS_ERR(ipcp))\n\t\treturn ERR_CAST(ipcp);\n\n\treturn container_of(ipcp, struct shmid_kernel, shm_perm);\n}\n\nstatic inline struct shmid_kernel *shm_obtain_object_check(struct ipc_namespace *ns, int id)\n{\n\tstruct kern_ipc_perm *ipcp = ipc_obtain_object_check(&shm_ids(ns), id);\n\n\tif (IS_ERR(ipcp))\n\t\treturn ERR_CAST(ipcp);\n\n\treturn container_of(ipcp, struct shmid_kernel, shm_perm);\n}\n\n \nstatic inline struct shmid_kernel *shm_lock(struct ipc_namespace *ns, int id)\n{\n\tstruct kern_ipc_perm *ipcp;\n\n\trcu_read_lock();\n\tipcp = ipc_obtain_object_idr(&shm_ids(ns), id);\n\tif (IS_ERR(ipcp))\n\t\tgoto err;\n\n\tipc_lock_object(ipcp);\n\t \n\tif (ipc_valid_object(ipcp)) {\n\t\t \n\t\treturn container_of(ipcp, struct shmid_kernel, shm_perm);\n\t}\n\n\tipc_unlock_object(ipcp);\n\tipcp = ERR_PTR(-EIDRM);\nerr:\n\trcu_read_unlock();\n\t \n\treturn ERR_CAST(ipcp);\n}\n\nstatic inline void shm_lock_by_ptr(struct shmid_kernel *ipcp)\n{\n\trcu_read_lock();\n\tipc_lock_object(&ipcp->shm_perm);\n}\n\nstatic void shm_rcu_free(struct rcu_head *head)\n{\n\tstruct kern_ipc_perm *ptr = container_of(head, struct kern_ipc_perm,\n\t\t\t\t\t\t\trcu);\n\tstruct shmid_kernel *shp = container_of(ptr, struct shmid_kernel,\n\t\t\t\t\t\t\tshm_perm);\n\tsecurity_shm_free(&shp->shm_perm);\n\tkfree(shp);\n}\n\n \nstatic inline void shm_clist_rm(struct shmid_kernel *shp)\n{\n\tstruct task_struct *creator;\n\n\t \n\trcu_read_lock();\n\n\t \n\tif (!list_empty(&shp->shm_clist)) {\n\t\t \n\t\tcreator = shp->shm_creator;\n\n\t\ttask_lock(creator);\n\t\t \n\t\tlist_del_init(&shp->shm_clist);\n\t\ttask_unlock(creator);\n\t}\n\trcu_read_unlock();\n}\n\nstatic inline void shm_rmid(struct shmid_kernel *s)\n{\n\tshm_clist_rm(s);\n\tipc_rmid(&shm_ids(s->ns), &s->shm_perm);\n}\n\n\nstatic int __shm_open(struct shm_file_data *sfd)\n{\n\tstruct shmid_kernel *shp;\n\n\tshp = shm_lock(sfd->ns, sfd->id);\n\n\tif (IS_ERR(shp))\n\t\treturn PTR_ERR(shp);\n\n\tif (shp->shm_file != sfd->file) {\n\t\t \n\t\tshm_unlock(shp);\n\t\treturn -EINVAL;\n\t}\n\n\tshp->shm_atim = ktime_get_real_seconds();\n\tipc_update_pid(&shp->shm_lprid, task_tgid(current));\n\tshp->shm_nattch++;\n\tshm_unlock(shp);\n\treturn 0;\n}\n\n \nstatic void shm_open(struct vm_area_struct *vma)\n{\n\tstruct file *file = vma->vm_file;\n\tstruct shm_file_data *sfd = shm_file_data(file);\n\tint err;\n\n\t \n\tif (sfd->vm_ops->open)\n\t\tsfd->vm_ops->open(vma);\n\n\terr = __shm_open(sfd);\n\t \n\tWARN_ON_ONCE(err);\n}\n\n \nstatic void shm_destroy(struct ipc_namespace *ns, struct shmid_kernel *shp)\n{\n\tstruct file *shm_file;\n\n\tshm_file = shp->shm_file;\n\tshp->shm_file = NULL;\n\tns->shm_tot -= (shp->shm_segsz + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\tshm_rmid(shp);\n\tshm_unlock(shp);\n\tif (!is_file_hugepages(shm_file))\n\t\tshmem_lock(shm_file, 0, shp->mlock_ucounts);\n\tfput(shm_file);\n\tipc_update_pid(&shp->shm_cprid, NULL);\n\tipc_update_pid(&shp->shm_lprid, NULL);\n\tipc_rcu_putref(&shp->shm_perm, shm_rcu_free);\n}\n\n \nstatic bool shm_may_destroy(struct shmid_kernel *shp)\n{\n\treturn (shp->shm_nattch == 0) &&\n\t       (shp->ns->shm_rmid_forced ||\n\t\t(shp->shm_perm.mode & SHM_DEST));\n}\n\n \nstatic void __shm_close(struct shm_file_data *sfd)\n{\n\tstruct shmid_kernel *shp;\n\tstruct ipc_namespace *ns = sfd->ns;\n\n\tdown_write(&shm_ids(ns).rwsem);\n\t \n\tshp = shm_lock(ns, sfd->id);\n\n\t \n\tif (WARN_ON_ONCE(IS_ERR(shp)))\n\t\tgoto done;  \n\n\tipc_update_pid(&shp->shm_lprid, task_tgid(current));\n\tshp->shm_dtim = ktime_get_real_seconds();\n\tshp->shm_nattch--;\n\tif (shm_may_destroy(shp))\n\t\tshm_destroy(ns, shp);\n\telse\n\t\tshm_unlock(shp);\ndone:\n\tup_write(&shm_ids(ns).rwsem);\n}\n\nstatic void shm_close(struct vm_area_struct *vma)\n{\n\tstruct file *file = vma->vm_file;\n\tstruct shm_file_data *sfd = shm_file_data(file);\n\n\t \n\tif (sfd->vm_ops->close)\n\t\tsfd->vm_ops->close(vma);\n\n\t__shm_close(sfd);\n}\n\n \nstatic int shm_try_destroy_orphaned(int id, void *p, void *data)\n{\n\tstruct ipc_namespace *ns = data;\n\tstruct kern_ipc_perm *ipcp = p;\n\tstruct shmid_kernel *shp = container_of(ipcp, struct shmid_kernel, shm_perm);\n\n\t \n\tif (!list_empty(&shp->shm_clist))\n\t\treturn 0;\n\n\tif (shm_may_destroy(shp)) {\n\t\tshm_lock_by_ptr(shp);\n\t\tshm_destroy(ns, shp);\n\t}\n\treturn 0;\n}\n\nvoid shm_destroy_orphaned(struct ipc_namespace *ns)\n{\n\tdown_write(&shm_ids(ns).rwsem);\n\tif (shm_ids(ns).in_use)\n\t\tidr_for_each(&shm_ids(ns).ipcs_idr, &shm_try_destroy_orphaned, ns);\n\tup_write(&shm_ids(ns).rwsem);\n}\n\n \nvoid exit_shm(struct task_struct *task)\n{\n\tfor (;;) {\n\t\tstruct shmid_kernel *shp;\n\t\tstruct ipc_namespace *ns;\n\n\t\ttask_lock(task);\n\n\t\tif (list_empty(&task->sysvshm.shm_clist)) {\n\t\t\ttask_unlock(task);\n\t\t\tbreak;\n\t\t}\n\n\t\tshp = list_first_entry(&task->sysvshm.shm_clist, struct shmid_kernel,\n\t\t\t\tshm_clist);\n\n\t\t \n\t\tns = shp->ns;\n\n\t\t \n\t\tif (!ns->shm_rmid_forced)\n\t\t\tgoto unlink_continue;\n\n\t\t \n\t\tns = get_ipc_ns_not_zero(ns);\n\t\tif (!ns) {\nunlink_continue:\n\t\t\tlist_del_init(&shp->shm_clist);\n\t\t\ttask_unlock(task);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tWARN_ON(!ipc_rcu_getref(&shp->shm_perm));\n\n\t\t \n\t\tlist_del_init(&shp->shm_clist);\n\n\t\ttask_unlock(task);\n\n\t\t \n\t\tdown_write(&shm_ids(ns).rwsem);\n\t\tshm_lock_by_ptr(shp);\n\t\t \n\t\tipc_rcu_putref(&shp->shm_perm, shm_rcu_free);\n\n\t\tif (ipc_valid_object(&shp->shm_perm)) {\n\t\t\tif (shm_may_destroy(shp))\n\t\t\t\tshm_destroy(ns, shp);\n\t\t\telse\n\t\t\t\tshm_unlock(shp);\n\t\t} else {\n\t\t\t \n\t\t\tshm_unlock(shp);\n\t\t}\n\n\t\tup_write(&shm_ids(ns).rwsem);\n\t\tput_ipc_ns(ns);  \n\t}\n}\n\nstatic vm_fault_t shm_fault(struct vm_fault *vmf)\n{\n\tstruct file *file = vmf->vma->vm_file;\n\tstruct shm_file_data *sfd = shm_file_data(file);\n\n\treturn sfd->vm_ops->fault(vmf);\n}\n\nstatic int shm_may_split(struct vm_area_struct *vma, unsigned long addr)\n{\n\tstruct file *file = vma->vm_file;\n\tstruct shm_file_data *sfd = shm_file_data(file);\n\n\tif (sfd->vm_ops->may_split)\n\t\treturn sfd->vm_ops->may_split(vma, addr);\n\n\treturn 0;\n}\n\nstatic unsigned long shm_pagesize(struct vm_area_struct *vma)\n{\n\tstruct file *file = vma->vm_file;\n\tstruct shm_file_data *sfd = shm_file_data(file);\n\n\tif (sfd->vm_ops->pagesize)\n\t\treturn sfd->vm_ops->pagesize(vma);\n\n\treturn PAGE_SIZE;\n}\n\n#ifdef CONFIG_NUMA\nstatic int shm_set_policy(struct vm_area_struct *vma, struct mempolicy *new)\n{\n\tstruct file *file = vma->vm_file;\n\tstruct shm_file_data *sfd = shm_file_data(file);\n\tint err = 0;\n\n\tif (sfd->vm_ops->set_policy)\n\t\terr = sfd->vm_ops->set_policy(vma, new);\n\treturn err;\n}\n\nstatic struct mempolicy *shm_get_policy(struct vm_area_struct *vma,\n\t\t\t\t\tunsigned long addr)\n{\n\tstruct file *file = vma->vm_file;\n\tstruct shm_file_data *sfd = shm_file_data(file);\n\tstruct mempolicy *pol = NULL;\n\n\tif (sfd->vm_ops->get_policy)\n\t\tpol = sfd->vm_ops->get_policy(vma, addr);\n\telse if (vma->vm_policy)\n\t\tpol = vma->vm_policy;\n\n\treturn pol;\n}\n#endif\n\nstatic int shm_mmap(struct file *file, struct vm_area_struct *vma)\n{\n\tstruct shm_file_data *sfd = shm_file_data(file);\n\tint ret;\n\n\t \n\tret = __shm_open(sfd);\n\tif (ret)\n\t\treturn ret;\n\n\tret = call_mmap(sfd->file, vma);\n\tif (ret) {\n\t\t__shm_close(sfd);\n\t\treturn ret;\n\t}\n\tsfd->vm_ops = vma->vm_ops;\n#ifdef CONFIG_MMU\n\tWARN_ON(!sfd->vm_ops->fault);\n#endif\n\tvma->vm_ops = &shm_vm_ops;\n\treturn 0;\n}\n\nstatic int shm_release(struct inode *ino, struct file *file)\n{\n\tstruct shm_file_data *sfd = shm_file_data(file);\n\n\tput_ipc_ns(sfd->ns);\n\tfput(sfd->file);\n\tshm_file_data(file) = NULL;\n\tkfree(sfd);\n\treturn 0;\n}\n\nstatic int shm_fsync(struct file *file, loff_t start, loff_t end, int datasync)\n{\n\tstruct shm_file_data *sfd = shm_file_data(file);\n\n\tif (!sfd->file->f_op->fsync)\n\t\treturn -EINVAL;\n\treturn sfd->file->f_op->fsync(sfd->file, start, end, datasync);\n}\n\nstatic long shm_fallocate(struct file *file, int mode, loff_t offset,\n\t\t\t  loff_t len)\n{\n\tstruct shm_file_data *sfd = shm_file_data(file);\n\n\tif (!sfd->file->f_op->fallocate)\n\t\treturn -EOPNOTSUPP;\n\treturn sfd->file->f_op->fallocate(file, mode, offset, len);\n}\n\nstatic unsigned long shm_get_unmapped_area(struct file *file,\n\tunsigned long addr, unsigned long len, unsigned long pgoff,\n\tunsigned long flags)\n{\n\tstruct shm_file_data *sfd = shm_file_data(file);\n\n\treturn sfd->file->f_op->get_unmapped_area(sfd->file, addr, len,\n\t\t\t\t\t\tpgoff, flags);\n}\n\nstatic const struct file_operations shm_file_operations = {\n\t.mmap\t\t= shm_mmap,\n\t.fsync\t\t= shm_fsync,\n\t.release\t= shm_release,\n\t.get_unmapped_area\t= shm_get_unmapped_area,\n\t.llseek\t\t= noop_llseek,\n\t.fallocate\t= shm_fallocate,\n};\n\n \nstatic const struct file_operations shm_file_operations_huge = {\n\t.mmap\t\t= shm_mmap,\n\t.fsync\t\t= shm_fsync,\n\t.release\t= shm_release,\n\t.get_unmapped_area\t= shm_get_unmapped_area,\n\t.llseek\t\t= noop_llseek,\n\t.fallocate\t= shm_fallocate,\n};\n\nbool is_file_shm_hugepages(struct file *file)\n{\n\treturn file->f_op == &shm_file_operations_huge;\n}\n\nstatic const struct vm_operations_struct shm_vm_ops = {\n\t.open\t= shm_open,\t \n\t.close\t= shm_close,\t \n\t.fault\t= shm_fault,\n\t.may_split = shm_may_split,\n\t.pagesize = shm_pagesize,\n#if defined(CONFIG_NUMA)\n\t.set_policy = shm_set_policy,\n\t.get_policy = shm_get_policy,\n#endif\n};\n\n \nstatic int newseg(struct ipc_namespace *ns, struct ipc_params *params)\n{\n\tkey_t key = params->key;\n\tint shmflg = params->flg;\n\tsize_t size = params->u.size;\n\tint error;\n\tstruct shmid_kernel *shp;\n\tsize_t numpages = (size + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\tstruct file *file;\n\tchar name[13];\n\tvm_flags_t acctflag = 0;\n\n\tif (size < SHMMIN || size > ns->shm_ctlmax)\n\t\treturn -EINVAL;\n\n\tif (numpages << PAGE_SHIFT < size)\n\t\treturn -ENOSPC;\n\n\tif (ns->shm_tot + numpages < ns->shm_tot ||\n\t\t\tns->shm_tot + numpages > ns->shm_ctlall)\n\t\treturn -ENOSPC;\n\n\tshp = kmalloc(sizeof(*shp), GFP_KERNEL_ACCOUNT);\n\tif (unlikely(!shp))\n\t\treturn -ENOMEM;\n\n\tshp->shm_perm.key = key;\n\tshp->shm_perm.mode = (shmflg & S_IRWXUGO);\n\tshp->mlock_ucounts = NULL;\n\n\tshp->shm_perm.security = NULL;\n\terror = security_shm_alloc(&shp->shm_perm);\n\tif (error) {\n\t\tkfree(shp);\n\t\treturn error;\n\t}\n\n\tsprintf(name, \"SYSV%08x\", key);\n\tif (shmflg & SHM_HUGETLB) {\n\t\tstruct hstate *hs;\n\t\tsize_t hugesize;\n\n\t\ths = hstate_sizelog((shmflg >> SHM_HUGE_SHIFT) & SHM_HUGE_MASK);\n\t\tif (!hs) {\n\t\t\terror = -EINVAL;\n\t\t\tgoto no_file;\n\t\t}\n\t\thugesize = ALIGN(size, huge_page_size(hs));\n\n\t\t \n\t\tif (shmflg & SHM_NORESERVE)\n\t\t\tacctflag = VM_NORESERVE;\n\t\tfile = hugetlb_file_setup(name, hugesize, acctflag,\n\t\t\t\tHUGETLB_SHMFS_INODE, (shmflg >> SHM_HUGE_SHIFT) & SHM_HUGE_MASK);\n\t} else {\n\t\t \n\t\tif  ((shmflg & SHM_NORESERVE) &&\n\t\t\t\tsysctl_overcommit_memory != OVERCOMMIT_NEVER)\n\t\t\tacctflag = VM_NORESERVE;\n\t\tfile = shmem_kernel_file_setup(name, size, acctflag);\n\t}\n\terror = PTR_ERR(file);\n\tif (IS_ERR(file))\n\t\tgoto no_file;\n\n\tshp->shm_cprid = get_pid(task_tgid(current));\n\tshp->shm_lprid = NULL;\n\tshp->shm_atim = shp->shm_dtim = 0;\n\tshp->shm_ctim = ktime_get_real_seconds();\n\tshp->shm_segsz = size;\n\tshp->shm_nattch = 0;\n\tshp->shm_file = file;\n\tshp->shm_creator = current;\n\n\t \n\terror = ipc_addid(&shm_ids(ns), &shp->shm_perm, ns->shm_ctlmni);\n\tif (error < 0)\n\t\tgoto no_id;\n\n\tshp->ns = ns;\n\n\ttask_lock(current);\n\tlist_add(&shp->shm_clist, &current->sysvshm.shm_clist);\n\ttask_unlock(current);\n\n\t \n\tfile_inode(file)->i_ino = shp->shm_perm.id;\n\n\tns->shm_tot += numpages;\n\terror = shp->shm_perm.id;\n\n\tipc_unlock_object(&shp->shm_perm);\n\trcu_read_unlock();\n\treturn error;\n\nno_id:\n\tipc_update_pid(&shp->shm_cprid, NULL);\n\tipc_update_pid(&shp->shm_lprid, NULL);\n\tfput(file);\n\tipc_rcu_putref(&shp->shm_perm, shm_rcu_free);\n\treturn error;\nno_file:\n\tcall_rcu(&shp->shm_perm.rcu, shm_rcu_free);\n\treturn error;\n}\n\n \nstatic int shm_more_checks(struct kern_ipc_perm *ipcp, struct ipc_params *params)\n{\n\tstruct shmid_kernel *shp;\n\n\tshp = container_of(ipcp, struct shmid_kernel, shm_perm);\n\tif (shp->shm_segsz < params->u.size)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nlong ksys_shmget(key_t key, size_t size, int shmflg)\n{\n\tstruct ipc_namespace *ns;\n\tstatic const struct ipc_ops shm_ops = {\n\t\t.getnew = newseg,\n\t\t.associate = security_shm_associate,\n\t\t.more_checks = shm_more_checks,\n\t};\n\tstruct ipc_params shm_params;\n\n\tns = current->nsproxy->ipc_ns;\n\n\tshm_params.key = key;\n\tshm_params.flg = shmflg;\n\tshm_params.u.size = size;\n\n\treturn ipcget(ns, &shm_ids(ns), &shm_ops, &shm_params);\n}\n\nSYSCALL_DEFINE3(shmget, key_t, key, size_t, size, int, shmflg)\n{\n\treturn ksys_shmget(key, size, shmflg);\n}\n\nstatic inline unsigned long copy_shmid_to_user(void __user *buf, struct shmid64_ds *in, int version)\n{\n\tswitch (version) {\n\tcase IPC_64:\n\t\treturn copy_to_user(buf, in, sizeof(*in));\n\tcase IPC_OLD:\n\t    {\n\t\tstruct shmid_ds out;\n\n\t\tmemset(&out, 0, sizeof(out));\n\t\tipc64_perm_to_ipc_perm(&in->shm_perm, &out.shm_perm);\n\t\tout.shm_segsz\t= in->shm_segsz;\n\t\tout.shm_atime\t= in->shm_atime;\n\t\tout.shm_dtime\t= in->shm_dtime;\n\t\tout.shm_ctime\t= in->shm_ctime;\n\t\tout.shm_cpid\t= in->shm_cpid;\n\t\tout.shm_lpid\t= in->shm_lpid;\n\t\tout.shm_nattch\t= in->shm_nattch;\n\n\t\treturn copy_to_user(buf, &out, sizeof(out));\n\t    }\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic inline unsigned long\ncopy_shmid_from_user(struct shmid64_ds *out, void __user *buf, int version)\n{\n\tswitch (version) {\n\tcase IPC_64:\n\t\tif (copy_from_user(out, buf, sizeof(*out)))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\tcase IPC_OLD:\n\t    {\n\t\tstruct shmid_ds tbuf_old;\n\n\t\tif (copy_from_user(&tbuf_old, buf, sizeof(tbuf_old)))\n\t\t\treturn -EFAULT;\n\n\t\tout->shm_perm.uid\t= tbuf_old.shm_perm.uid;\n\t\tout->shm_perm.gid\t= tbuf_old.shm_perm.gid;\n\t\tout->shm_perm.mode\t= tbuf_old.shm_perm.mode;\n\n\t\treturn 0;\n\t    }\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic inline unsigned long copy_shminfo_to_user(void __user *buf, struct shminfo64 *in, int version)\n{\n\tswitch (version) {\n\tcase IPC_64:\n\t\treturn copy_to_user(buf, in, sizeof(*in));\n\tcase IPC_OLD:\n\t    {\n\t\tstruct shminfo out;\n\n\t\tif (in->shmmax > INT_MAX)\n\t\t\tout.shmmax = INT_MAX;\n\t\telse\n\t\t\tout.shmmax = (int)in->shmmax;\n\n\t\tout.shmmin\t= in->shmmin;\n\t\tout.shmmni\t= in->shmmni;\n\t\tout.shmseg\t= in->shmseg;\n\t\tout.shmall\t= in->shmall;\n\n\t\treturn copy_to_user(buf, &out, sizeof(out));\n\t    }\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\n \nstatic void shm_add_rss_swap(struct shmid_kernel *shp,\n\tunsigned long *rss_add, unsigned long *swp_add)\n{\n\tstruct inode *inode;\n\n\tinode = file_inode(shp->shm_file);\n\n\tif (is_file_hugepages(shp->shm_file)) {\n\t\tstruct address_space *mapping = inode->i_mapping;\n\t\tstruct hstate *h = hstate_file(shp->shm_file);\n\t\t*rss_add += pages_per_huge_page(h) * mapping->nrpages;\n\t} else {\n#ifdef CONFIG_SHMEM\n\t\tstruct shmem_inode_info *info = SHMEM_I(inode);\n\n\t\tspin_lock_irq(&info->lock);\n\t\t*rss_add += inode->i_mapping->nrpages;\n\t\t*swp_add += info->swapped;\n\t\tspin_unlock_irq(&info->lock);\n#else\n\t\t*rss_add += inode->i_mapping->nrpages;\n#endif\n\t}\n}\n\n \nstatic void shm_get_stat(struct ipc_namespace *ns, unsigned long *rss,\n\t\tunsigned long *swp)\n{\n\tint next_id;\n\tint total, in_use;\n\n\t*rss = 0;\n\t*swp = 0;\n\n\tin_use = shm_ids(ns).in_use;\n\n\tfor (total = 0, next_id = 0; total < in_use; next_id++) {\n\t\tstruct kern_ipc_perm *ipc;\n\t\tstruct shmid_kernel *shp;\n\n\t\tipc = idr_find(&shm_ids(ns).ipcs_idr, next_id);\n\t\tif (ipc == NULL)\n\t\t\tcontinue;\n\t\tshp = container_of(ipc, struct shmid_kernel, shm_perm);\n\n\t\tshm_add_rss_swap(shp, rss, swp);\n\n\t\ttotal++;\n\t}\n}\n\n \nstatic int shmctl_down(struct ipc_namespace *ns, int shmid, int cmd,\n\t\t       struct shmid64_ds *shmid64)\n{\n\tstruct kern_ipc_perm *ipcp;\n\tstruct shmid_kernel *shp;\n\tint err;\n\n\tdown_write(&shm_ids(ns).rwsem);\n\trcu_read_lock();\n\n\tipcp = ipcctl_obtain_check(ns, &shm_ids(ns), shmid, cmd,\n\t\t\t\t      &shmid64->shm_perm, 0);\n\tif (IS_ERR(ipcp)) {\n\t\terr = PTR_ERR(ipcp);\n\t\tgoto out_unlock1;\n\t}\n\n\tshp = container_of(ipcp, struct shmid_kernel, shm_perm);\n\n\terr = security_shm_shmctl(&shp->shm_perm, cmd);\n\tif (err)\n\t\tgoto out_unlock1;\n\n\tswitch (cmd) {\n\tcase IPC_RMID:\n\t\tipc_lock_object(&shp->shm_perm);\n\t\t \n\t\tdo_shm_rmid(ns, ipcp);\n\t\tgoto out_up;\n\tcase IPC_SET:\n\t\tipc_lock_object(&shp->shm_perm);\n\t\terr = ipc_update_perm(&shmid64->shm_perm, ipcp);\n\t\tif (err)\n\t\t\tgoto out_unlock0;\n\t\tshp->shm_ctim = ktime_get_real_seconds();\n\t\tbreak;\n\tdefault:\n\t\terr = -EINVAL;\n\t\tgoto out_unlock1;\n\t}\n\nout_unlock0:\n\tipc_unlock_object(&shp->shm_perm);\nout_unlock1:\n\trcu_read_unlock();\nout_up:\n\tup_write(&shm_ids(ns).rwsem);\n\treturn err;\n}\n\nstatic int shmctl_ipc_info(struct ipc_namespace *ns,\n\t\t\t   struct shminfo64 *shminfo)\n{\n\tint err = security_shm_shmctl(NULL, IPC_INFO);\n\tif (!err) {\n\t\tmemset(shminfo, 0, sizeof(*shminfo));\n\t\tshminfo->shmmni = shminfo->shmseg = ns->shm_ctlmni;\n\t\tshminfo->shmmax = ns->shm_ctlmax;\n\t\tshminfo->shmall = ns->shm_ctlall;\n\t\tshminfo->shmmin = SHMMIN;\n\t\tdown_read(&shm_ids(ns).rwsem);\n\t\terr = ipc_get_maxidx(&shm_ids(ns));\n\t\tup_read(&shm_ids(ns).rwsem);\n\t\tif (err < 0)\n\t\t\terr = 0;\n\t}\n\treturn err;\n}\n\nstatic int shmctl_shm_info(struct ipc_namespace *ns,\n\t\t\t   struct shm_info *shm_info)\n{\n\tint err = security_shm_shmctl(NULL, SHM_INFO);\n\tif (!err) {\n\t\tmemset(shm_info, 0, sizeof(*shm_info));\n\t\tdown_read(&shm_ids(ns).rwsem);\n\t\tshm_info->used_ids = shm_ids(ns).in_use;\n\t\tshm_get_stat(ns, &shm_info->shm_rss, &shm_info->shm_swp);\n\t\tshm_info->shm_tot = ns->shm_tot;\n\t\tshm_info->swap_attempts = 0;\n\t\tshm_info->swap_successes = 0;\n\t\terr = ipc_get_maxidx(&shm_ids(ns));\n\t\tup_read(&shm_ids(ns).rwsem);\n\t\tif (err < 0)\n\t\t\terr = 0;\n\t}\n\treturn err;\n}\n\nstatic int shmctl_stat(struct ipc_namespace *ns, int shmid,\n\t\t\tint cmd, struct shmid64_ds *tbuf)\n{\n\tstruct shmid_kernel *shp;\n\tint err;\n\n\tmemset(tbuf, 0, sizeof(*tbuf));\n\n\trcu_read_lock();\n\tif (cmd == SHM_STAT || cmd == SHM_STAT_ANY) {\n\t\tshp = shm_obtain_object(ns, shmid);\n\t\tif (IS_ERR(shp)) {\n\t\t\terr = PTR_ERR(shp);\n\t\t\tgoto out_unlock;\n\t\t}\n\t} else {  \n\t\tshp = shm_obtain_object_check(ns, shmid);\n\t\tif (IS_ERR(shp)) {\n\t\t\terr = PTR_ERR(shp);\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\t \n\tif (cmd == SHM_STAT_ANY)\n\t\taudit_ipc_obj(&shp->shm_perm);\n\telse {\n\t\terr = -EACCES;\n\t\tif (ipcperms(ns, &shp->shm_perm, S_IRUGO))\n\t\t\tgoto out_unlock;\n\t}\n\n\terr = security_shm_shmctl(&shp->shm_perm, cmd);\n\tif (err)\n\t\tgoto out_unlock;\n\n\tipc_lock_object(&shp->shm_perm);\n\n\tif (!ipc_valid_object(&shp->shm_perm)) {\n\t\tipc_unlock_object(&shp->shm_perm);\n\t\terr = -EIDRM;\n\t\tgoto out_unlock;\n\t}\n\n\tkernel_to_ipc64_perm(&shp->shm_perm, &tbuf->shm_perm);\n\ttbuf->shm_segsz\t= shp->shm_segsz;\n\ttbuf->shm_atime\t= shp->shm_atim;\n\ttbuf->shm_dtime\t= shp->shm_dtim;\n\ttbuf->shm_ctime\t= shp->shm_ctim;\n#ifndef CONFIG_64BIT\n\ttbuf->shm_atime_high = shp->shm_atim >> 32;\n\ttbuf->shm_dtime_high = shp->shm_dtim >> 32;\n\ttbuf->shm_ctime_high = shp->shm_ctim >> 32;\n#endif\n\ttbuf->shm_cpid\t= pid_vnr(shp->shm_cprid);\n\ttbuf->shm_lpid\t= pid_vnr(shp->shm_lprid);\n\ttbuf->shm_nattch = shp->shm_nattch;\n\n\tif (cmd == IPC_STAT) {\n\t\t \n\t\terr = 0;\n\t} else {\n\t\t \n\t\terr = shp->shm_perm.id;\n\t}\n\n\tipc_unlock_object(&shp->shm_perm);\nout_unlock:\n\trcu_read_unlock();\n\treturn err;\n}\n\nstatic int shmctl_do_lock(struct ipc_namespace *ns, int shmid, int cmd)\n{\n\tstruct shmid_kernel *shp;\n\tstruct file *shm_file;\n\tint err;\n\n\trcu_read_lock();\n\tshp = shm_obtain_object_check(ns, shmid);\n\tif (IS_ERR(shp)) {\n\t\terr = PTR_ERR(shp);\n\t\tgoto out_unlock1;\n\t}\n\n\taudit_ipc_obj(&(shp->shm_perm));\n\terr = security_shm_shmctl(&shp->shm_perm, cmd);\n\tif (err)\n\t\tgoto out_unlock1;\n\n\tipc_lock_object(&shp->shm_perm);\n\n\t \n\tif (!ipc_valid_object(&shp->shm_perm)) {\n\t\terr = -EIDRM;\n\t\tgoto out_unlock0;\n\t}\n\n\tif (!ns_capable(ns->user_ns, CAP_IPC_LOCK)) {\n\t\tkuid_t euid = current_euid();\n\n\t\tif (!uid_eq(euid, shp->shm_perm.uid) &&\n\t\t    !uid_eq(euid, shp->shm_perm.cuid)) {\n\t\t\terr = -EPERM;\n\t\t\tgoto out_unlock0;\n\t\t}\n\t\tif (cmd == SHM_LOCK && !rlimit(RLIMIT_MEMLOCK)) {\n\t\t\terr = -EPERM;\n\t\t\tgoto out_unlock0;\n\t\t}\n\t}\n\n\tshm_file = shp->shm_file;\n\tif (is_file_hugepages(shm_file))\n\t\tgoto out_unlock0;\n\n\tif (cmd == SHM_LOCK) {\n\t\tstruct ucounts *ucounts = current_ucounts();\n\n\t\terr = shmem_lock(shm_file, 1, ucounts);\n\t\tif (!err && !(shp->shm_perm.mode & SHM_LOCKED)) {\n\t\t\tshp->shm_perm.mode |= SHM_LOCKED;\n\t\t\tshp->mlock_ucounts = ucounts;\n\t\t}\n\t\tgoto out_unlock0;\n\t}\n\n\t \n\tif (!(shp->shm_perm.mode & SHM_LOCKED))\n\t\tgoto out_unlock0;\n\tshmem_lock(shm_file, 0, shp->mlock_ucounts);\n\tshp->shm_perm.mode &= ~SHM_LOCKED;\n\tshp->mlock_ucounts = NULL;\n\tget_file(shm_file);\n\tipc_unlock_object(&shp->shm_perm);\n\trcu_read_unlock();\n\tshmem_unlock_mapping(shm_file->f_mapping);\n\n\tfput(shm_file);\n\treturn err;\n\nout_unlock0:\n\tipc_unlock_object(&shp->shm_perm);\nout_unlock1:\n\trcu_read_unlock();\n\treturn err;\n}\n\nstatic long ksys_shmctl(int shmid, int cmd, struct shmid_ds __user *buf, int version)\n{\n\tint err;\n\tstruct ipc_namespace *ns;\n\tstruct shmid64_ds sem64;\n\n\tif (cmd < 0 || shmid < 0)\n\t\treturn -EINVAL;\n\n\tns = current->nsproxy->ipc_ns;\n\n\tswitch (cmd) {\n\tcase IPC_INFO: {\n\t\tstruct shminfo64 shminfo;\n\t\terr = shmctl_ipc_info(ns, &shminfo);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tif (copy_shminfo_to_user(buf, &shminfo, version))\n\t\t\terr = -EFAULT;\n\t\treturn err;\n\t}\n\tcase SHM_INFO: {\n\t\tstruct shm_info shm_info;\n\t\terr = shmctl_shm_info(ns, &shm_info);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tif (copy_to_user(buf, &shm_info, sizeof(shm_info)))\n\t\t\terr = -EFAULT;\n\t\treturn err;\n\t}\n\tcase SHM_STAT:\n\tcase SHM_STAT_ANY:\n\tcase IPC_STAT: {\n\t\terr = shmctl_stat(ns, shmid, cmd, &sem64);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tif (copy_shmid_to_user(buf, &sem64, version))\n\t\t\terr = -EFAULT;\n\t\treturn err;\n\t}\n\tcase IPC_SET:\n\t\tif (copy_shmid_from_user(&sem64, buf, version))\n\t\t\treturn -EFAULT;\n\t\tfallthrough;\n\tcase IPC_RMID:\n\t\treturn shmctl_down(ns, shmid, cmd, &sem64);\n\tcase SHM_LOCK:\n\tcase SHM_UNLOCK:\n\t\treturn shmctl_do_lock(ns, shmid, cmd);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nSYSCALL_DEFINE3(shmctl, int, shmid, int, cmd, struct shmid_ds __user *, buf)\n{\n\treturn ksys_shmctl(shmid, cmd, buf, IPC_64);\n}\n\n#ifdef CONFIG_ARCH_WANT_IPC_PARSE_VERSION\nlong ksys_old_shmctl(int shmid, int cmd, struct shmid_ds __user *buf)\n{\n\tint version = ipc_parse_version(&cmd);\n\n\treturn ksys_shmctl(shmid, cmd, buf, version);\n}\n\nSYSCALL_DEFINE3(old_shmctl, int, shmid, int, cmd, struct shmid_ds __user *, buf)\n{\n\treturn ksys_old_shmctl(shmid, cmd, buf);\n}\n#endif\n\n#ifdef CONFIG_COMPAT\n\nstruct compat_shmid_ds {\n\tstruct compat_ipc_perm shm_perm;\n\tint shm_segsz;\n\told_time32_t shm_atime;\n\told_time32_t shm_dtime;\n\told_time32_t shm_ctime;\n\tcompat_ipc_pid_t shm_cpid;\n\tcompat_ipc_pid_t shm_lpid;\n\tunsigned short shm_nattch;\n\tunsigned short shm_unused;\n\tcompat_uptr_t shm_unused2;\n\tcompat_uptr_t shm_unused3;\n};\n\nstruct compat_shminfo64 {\n\tcompat_ulong_t shmmax;\n\tcompat_ulong_t shmmin;\n\tcompat_ulong_t shmmni;\n\tcompat_ulong_t shmseg;\n\tcompat_ulong_t shmall;\n\tcompat_ulong_t __unused1;\n\tcompat_ulong_t __unused2;\n\tcompat_ulong_t __unused3;\n\tcompat_ulong_t __unused4;\n};\n\nstruct compat_shm_info {\n\tcompat_int_t used_ids;\n\tcompat_ulong_t shm_tot, shm_rss, shm_swp;\n\tcompat_ulong_t swap_attempts, swap_successes;\n};\n\nstatic int copy_compat_shminfo_to_user(void __user *buf, struct shminfo64 *in,\n\t\t\t\t\tint version)\n{\n\tif (in->shmmax > INT_MAX)\n\t\tin->shmmax = INT_MAX;\n\tif (version == IPC_64) {\n\t\tstruct compat_shminfo64 info;\n\t\tmemset(&info, 0, sizeof(info));\n\t\tinfo.shmmax = in->shmmax;\n\t\tinfo.shmmin = in->shmmin;\n\t\tinfo.shmmni = in->shmmni;\n\t\tinfo.shmseg = in->shmseg;\n\t\tinfo.shmall = in->shmall;\n\t\treturn copy_to_user(buf, &info, sizeof(info));\n\t} else {\n\t\tstruct shminfo info;\n\t\tmemset(&info, 0, sizeof(info));\n\t\tinfo.shmmax = in->shmmax;\n\t\tinfo.shmmin = in->shmmin;\n\t\tinfo.shmmni = in->shmmni;\n\t\tinfo.shmseg = in->shmseg;\n\t\tinfo.shmall = in->shmall;\n\t\treturn copy_to_user(buf, &info, sizeof(info));\n\t}\n}\n\nstatic int put_compat_shm_info(struct shm_info *ip,\n\t\t\t\tstruct compat_shm_info __user *uip)\n{\n\tstruct compat_shm_info info;\n\n\tmemset(&info, 0, sizeof(info));\n\tinfo.used_ids = ip->used_ids;\n\tinfo.shm_tot = ip->shm_tot;\n\tinfo.shm_rss = ip->shm_rss;\n\tinfo.shm_swp = ip->shm_swp;\n\tinfo.swap_attempts = ip->swap_attempts;\n\tinfo.swap_successes = ip->swap_successes;\n\treturn copy_to_user(uip, &info, sizeof(info));\n}\n\nstatic int copy_compat_shmid_to_user(void __user *buf, struct shmid64_ds *in,\n\t\t\t\t\tint version)\n{\n\tif (version == IPC_64) {\n\t\tstruct compat_shmid64_ds v;\n\t\tmemset(&v, 0, sizeof(v));\n\t\tto_compat_ipc64_perm(&v.shm_perm, &in->shm_perm);\n\t\tv.shm_atime\t = lower_32_bits(in->shm_atime);\n\t\tv.shm_atime_high = upper_32_bits(in->shm_atime);\n\t\tv.shm_dtime\t = lower_32_bits(in->shm_dtime);\n\t\tv.shm_dtime_high = upper_32_bits(in->shm_dtime);\n\t\tv.shm_ctime\t = lower_32_bits(in->shm_ctime);\n\t\tv.shm_ctime_high = upper_32_bits(in->shm_ctime);\n\t\tv.shm_segsz = in->shm_segsz;\n\t\tv.shm_nattch = in->shm_nattch;\n\t\tv.shm_cpid = in->shm_cpid;\n\t\tv.shm_lpid = in->shm_lpid;\n\t\treturn copy_to_user(buf, &v, sizeof(v));\n\t} else {\n\t\tstruct compat_shmid_ds v;\n\t\tmemset(&v, 0, sizeof(v));\n\t\tto_compat_ipc_perm(&v.shm_perm, &in->shm_perm);\n\t\tv.shm_perm.key = in->shm_perm.key;\n\t\tv.shm_atime = in->shm_atime;\n\t\tv.shm_dtime = in->shm_dtime;\n\t\tv.shm_ctime = in->shm_ctime;\n\t\tv.shm_segsz = in->shm_segsz;\n\t\tv.shm_nattch = in->shm_nattch;\n\t\tv.shm_cpid = in->shm_cpid;\n\t\tv.shm_lpid = in->shm_lpid;\n\t\treturn copy_to_user(buf, &v, sizeof(v));\n\t}\n}\n\nstatic int copy_compat_shmid_from_user(struct shmid64_ds *out, void __user *buf,\n\t\t\t\t\tint version)\n{\n\tmemset(out, 0, sizeof(*out));\n\tif (version == IPC_64) {\n\t\tstruct compat_shmid64_ds __user *p = buf;\n\t\treturn get_compat_ipc64_perm(&out->shm_perm, &p->shm_perm);\n\t} else {\n\t\tstruct compat_shmid_ds __user *p = buf;\n\t\treturn get_compat_ipc_perm(&out->shm_perm, &p->shm_perm);\n\t}\n}\n\nstatic long compat_ksys_shmctl(int shmid, int cmd, void __user *uptr, int version)\n{\n\tstruct ipc_namespace *ns;\n\tstruct shmid64_ds sem64;\n\tint err;\n\n\tns = current->nsproxy->ipc_ns;\n\n\tif (cmd < 0 || shmid < 0)\n\t\treturn -EINVAL;\n\n\tswitch (cmd) {\n\tcase IPC_INFO: {\n\t\tstruct shminfo64 shminfo;\n\t\terr = shmctl_ipc_info(ns, &shminfo);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tif (copy_compat_shminfo_to_user(uptr, &shminfo, version))\n\t\t\terr = -EFAULT;\n\t\treturn err;\n\t}\n\tcase SHM_INFO: {\n\t\tstruct shm_info shm_info;\n\t\terr = shmctl_shm_info(ns, &shm_info);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tif (put_compat_shm_info(&shm_info, uptr))\n\t\t\terr = -EFAULT;\n\t\treturn err;\n\t}\n\tcase IPC_STAT:\n\tcase SHM_STAT_ANY:\n\tcase SHM_STAT:\n\t\terr = shmctl_stat(ns, shmid, cmd, &sem64);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tif (copy_compat_shmid_to_user(uptr, &sem64, version))\n\t\t\terr = -EFAULT;\n\t\treturn err;\n\n\tcase IPC_SET:\n\t\tif (copy_compat_shmid_from_user(&sem64, uptr, version))\n\t\t\treturn -EFAULT;\n\t\tfallthrough;\n\tcase IPC_RMID:\n\t\treturn shmctl_down(ns, shmid, cmd, &sem64);\n\tcase SHM_LOCK:\n\tcase SHM_UNLOCK:\n\t\treturn shmctl_do_lock(ns, shmid, cmd);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn err;\n}\n\nCOMPAT_SYSCALL_DEFINE3(shmctl, int, shmid, int, cmd, void __user *, uptr)\n{\n\treturn compat_ksys_shmctl(shmid, cmd, uptr, IPC_64);\n}\n\n#ifdef CONFIG_ARCH_WANT_COMPAT_IPC_PARSE_VERSION\nlong compat_ksys_old_shmctl(int shmid, int cmd, void __user *uptr)\n{\n\tint version = compat_ipc_parse_version(&cmd);\n\n\treturn compat_ksys_shmctl(shmid, cmd, uptr, version);\n}\n\nCOMPAT_SYSCALL_DEFINE3(old_shmctl, int, shmid, int, cmd, void __user *, uptr)\n{\n\treturn compat_ksys_old_shmctl(shmid, cmd, uptr);\n}\n#endif\n#endif\n\n \nlong do_shmat(int shmid, char __user *shmaddr, int shmflg,\n\t      ulong *raddr, unsigned long shmlba)\n{\n\tstruct shmid_kernel *shp;\n\tunsigned long addr = (unsigned long)shmaddr;\n\tunsigned long size;\n\tstruct file *file, *base;\n\tint    err;\n\tunsigned long flags = MAP_SHARED;\n\tunsigned long prot;\n\tint acc_mode;\n\tstruct ipc_namespace *ns;\n\tstruct shm_file_data *sfd;\n\tint f_flags;\n\tunsigned long populate = 0;\n\n\terr = -EINVAL;\n\tif (shmid < 0)\n\t\tgoto out;\n\n\tif (addr) {\n\t\tif (addr & (shmlba - 1)) {\n\t\t\tif (shmflg & SHM_RND) {\n\t\t\t\taddr &= ~(shmlba - 1);   \n\n\t\t\t\t \n\t\t\t\tif (!addr && (shmflg & SHM_REMAP))\n\t\t\t\t\tgoto out;\n\t\t\t} else\n#ifndef __ARCH_FORCE_SHMLBA\n\t\t\t\tif (addr & ~PAGE_MASK)\n#endif\n\t\t\t\t\tgoto out;\n\t\t}\n\n\t\tflags |= MAP_FIXED;\n\t} else if ((shmflg & SHM_REMAP))\n\t\tgoto out;\n\n\tif (shmflg & SHM_RDONLY) {\n\t\tprot = PROT_READ;\n\t\tacc_mode = S_IRUGO;\n\t\tf_flags = O_RDONLY;\n\t} else {\n\t\tprot = PROT_READ | PROT_WRITE;\n\t\tacc_mode = S_IRUGO | S_IWUGO;\n\t\tf_flags = O_RDWR;\n\t}\n\tif (shmflg & SHM_EXEC) {\n\t\tprot |= PROT_EXEC;\n\t\tacc_mode |= S_IXUGO;\n\t}\n\n\t \n\tns = current->nsproxy->ipc_ns;\n\trcu_read_lock();\n\tshp = shm_obtain_object_check(ns, shmid);\n\tif (IS_ERR(shp)) {\n\t\terr = PTR_ERR(shp);\n\t\tgoto out_unlock;\n\t}\n\n\terr = -EACCES;\n\tif (ipcperms(ns, &shp->shm_perm, acc_mode))\n\t\tgoto out_unlock;\n\n\terr = security_shm_shmat(&shp->shm_perm, shmaddr, shmflg);\n\tif (err)\n\t\tgoto out_unlock;\n\n\tipc_lock_object(&shp->shm_perm);\n\n\t \n\tif (!ipc_valid_object(&shp->shm_perm)) {\n\t\tipc_unlock_object(&shp->shm_perm);\n\t\terr = -EIDRM;\n\t\tgoto out_unlock;\n\t}\n\n\t \n\tbase = get_file(shp->shm_file);\n\tshp->shm_nattch++;\n\tsize = i_size_read(file_inode(base));\n\tipc_unlock_object(&shp->shm_perm);\n\trcu_read_unlock();\n\n\terr = -ENOMEM;\n\tsfd = kzalloc(sizeof(*sfd), GFP_KERNEL);\n\tif (!sfd) {\n\t\tfput(base);\n\t\tgoto out_nattch;\n\t}\n\n\tfile = alloc_file_clone(base, f_flags,\n\t\t\t  is_file_hugepages(base) ?\n\t\t\t\t&shm_file_operations_huge :\n\t\t\t\t&shm_file_operations);\n\terr = PTR_ERR(file);\n\tif (IS_ERR(file)) {\n\t\tkfree(sfd);\n\t\tfput(base);\n\t\tgoto out_nattch;\n\t}\n\n\tsfd->id = shp->shm_perm.id;\n\tsfd->ns = get_ipc_ns(ns);\n\tsfd->file = base;\n\tsfd->vm_ops = NULL;\n\tfile->private_data = sfd;\n\n\terr = security_mmap_file(file, prot, flags);\n\tif (err)\n\t\tgoto out_fput;\n\n\tif (mmap_write_lock_killable(current->mm)) {\n\t\terr = -EINTR;\n\t\tgoto out_fput;\n\t}\n\n\tif (addr && !(shmflg & SHM_REMAP)) {\n\t\terr = -EINVAL;\n\t\tif (addr + size < addr)\n\t\t\tgoto invalid;\n\n\t\tif (find_vma_intersection(current->mm, addr, addr + size))\n\t\t\tgoto invalid;\n\t}\n\n\taddr = do_mmap(file, addr, size, prot, flags, 0, 0, &populate, NULL);\n\t*raddr = addr;\n\terr = 0;\n\tif (IS_ERR_VALUE(addr))\n\t\terr = (long)addr;\ninvalid:\n\tmmap_write_unlock(current->mm);\n\tif (populate)\n\t\tmm_populate(addr, populate);\n\nout_fput:\n\tfput(file);\n\nout_nattch:\n\tdown_write(&shm_ids(ns).rwsem);\n\tshp = shm_lock(ns, shmid);\n\tshp->shm_nattch--;\n\n\tif (shm_may_destroy(shp))\n\t\tshm_destroy(ns, shp);\n\telse\n\t\tshm_unlock(shp);\n\tup_write(&shm_ids(ns).rwsem);\n\treturn err;\n\nout_unlock:\n\trcu_read_unlock();\nout:\n\treturn err;\n}\n\nSYSCALL_DEFINE3(shmat, int, shmid, char __user *, shmaddr, int, shmflg)\n{\n\tunsigned long ret;\n\tlong err;\n\n\terr = do_shmat(shmid, shmaddr, shmflg, &ret, SHMLBA);\n\tif (err)\n\t\treturn err;\n\tforce_successful_syscall_return();\n\treturn (long)ret;\n}\n\n#ifdef CONFIG_COMPAT\n\n#ifndef COMPAT_SHMLBA\n#define COMPAT_SHMLBA\tSHMLBA\n#endif\n\nCOMPAT_SYSCALL_DEFINE3(shmat, int, shmid, compat_uptr_t, shmaddr, int, shmflg)\n{\n\tunsigned long ret;\n\tlong err;\n\n\terr = do_shmat(shmid, compat_ptr(shmaddr), shmflg, &ret, COMPAT_SHMLBA);\n\tif (err)\n\t\treturn err;\n\tforce_successful_syscall_return();\n\treturn (long)ret;\n}\n#endif\n\n \nlong ksys_shmdt(char __user *shmaddr)\n{\n\tstruct mm_struct *mm = current->mm;\n\tstruct vm_area_struct *vma;\n\tunsigned long addr = (unsigned long)shmaddr;\n\tint retval = -EINVAL;\n#ifdef CONFIG_MMU\n\tloff_t size = 0;\n\tstruct file *file;\n\tVMA_ITERATOR(vmi, mm, addr);\n#endif\n\n\tif (addr & ~PAGE_MASK)\n\t\treturn retval;\n\n\tif (mmap_write_lock_killable(mm))\n\t\treturn -EINTR;\n\n\t \n\t \n\n#ifdef CONFIG_MMU\n\tfor_each_vma(vmi, vma) {\n\t\t \n\t\tif ((vma->vm_ops == &shm_vm_ops) &&\n\t\t\t(vma->vm_start - addr)/PAGE_SIZE == vma->vm_pgoff) {\n\n\t\t\t \n\t\t\tfile = vma->vm_file;\n\t\t\tsize = i_size_read(file_inode(vma->vm_file));\n\t\t\tdo_vma_munmap(&vmi, vma, vma->vm_start, vma->vm_end,\n\t\t\t\t      NULL, false);\n\t\t\t \n\t\t\tretval = 0;\n\t\t\tvma = vma_next(&vmi);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tsize = PAGE_ALIGN(size);\n\twhile (vma && (loff_t)(vma->vm_end - addr) <= size) {\n\t\t \n\t\tif ((vma->vm_ops == &shm_vm_ops) &&\n\t\t    ((vma->vm_start - addr)/PAGE_SIZE == vma->vm_pgoff) &&\n\t\t    (vma->vm_file == file)) {\n\t\t\tdo_vma_munmap(&vmi, vma, vma->vm_start, vma->vm_end,\n\t\t\t\t      NULL, false);\n\t\t}\n\n\t\tvma = vma_next(&vmi);\n\t}\n\n#else\t \n\tvma = vma_lookup(mm, addr);\n\t \n\tif (vma && vma->vm_start == addr && vma->vm_ops == &shm_vm_ops) {\n\t\tdo_munmap(mm, vma->vm_start, vma->vm_end - vma->vm_start, NULL);\n\t\tretval = 0;\n\t}\n\n#endif\n\n\tmmap_write_unlock(mm);\n\treturn retval;\n}\n\nSYSCALL_DEFINE1(shmdt, char __user *, shmaddr)\n{\n\treturn ksys_shmdt(shmaddr);\n}\n\n#ifdef CONFIG_PROC_FS\nstatic int sysvipc_shm_proc_show(struct seq_file *s, void *it)\n{\n\tstruct pid_namespace *pid_ns = ipc_seq_pid_ns(s);\n\tstruct user_namespace *user_ns = seq_user_ns(s);\n\tstruct kern_ipc_perm *ipcp = it;\n\tstruct shmid_kernel *shp;\n\tunsigned long rss = 0, swp = 0;\n\n\tshp = container_of(ipcp, struct shmid_kernel, shm_perm);\n\tshm_add_rss_swap(shp, &rss, &swp);\n\n#if BITS_PER_LONG <= 32\n#define SIZE_SPEC \"%10lu\"\n#else\n#define SIZE_SPEC \"%21lu\"\n#endif\n\n\tseq_printf(s,\n\t\t   \"%10d %10d  %4o \" SIZE_SPEC \" %5u %5u  \"\n\t\t   \"%5lu %5u %5u %5u %5u %10llu %10llu %10llu \"\n\t\t   SIZE_SPEC \" \" SIZE_SPEC \"\\n\",\n\t\t   shp->shm_perm.key,\n\t\t   shp->shm_perm.id,\n\t\t   shp->shm_perm.mode,\n\t\t   shp->shm_segsz,\n\t\t   pid_nr_ns(shp->shm_cprid, pid_ns),\n\t\t   pid_nr_ns(shp->shm_lprid, pid_ns),\n\t\t   shp->shm_nattch,\n\t\t   from_kuid_munged(user_ns, shp->shm_perm.uid),\n\t\t   from_kgid_munged(user_ns, shp->shm_perm.gid),\n\t\t   from_kuid_munged(user_ns, shp->shm_perm.cuid),\n\t\t   from_kgid_munged(user_ns, shp->shm_perm.cgid),\n\t\t   shp->shm_atim,\n\t\t   shp->shm_dtim,\n\t\t   shp->shm_ctim,\n\t\t   rss * PAGE_SIZE,\n\t\t   swp * PAGE_SIZE);\n\n\treturn 0;\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}