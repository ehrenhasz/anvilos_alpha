{
  "module_name": "ipc_sysctl.c",
  "hash_id": "c75ce3601f224a48bc74b74dc710fc4957473b17966eb638d220148bf45ef7c2",
  "original_prompt": "Ingested from linux-6.6.14/ipc/ipc_sysctl.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/ipc.h>\n#include <linux/nsproxy.h>\n#include <linux/sysctl.h>\n#include <linux/uaccess.h>\n#include <linux/capability.h>\n#include <linux/ipc_namespace.h>\n#include <linux/msg.h>\n#include <linux/slab.h>\n#include \"util.h\"\n\nstatic int proc_ipc_dointvec_minmax_orphans(struct ctl_table *table, int write,\n\t\tvoid *buffer, size_t *lenp, loff_t *ppos)\n{\n\tstruct ipc_namespace *ns =\n\t\tcontainer_of(table->data, struct ipc_namespace, shm_rmid_forced);\n\tint err;\n\n\terr = proc_dointvec_minmax(table, write, buffer, lenp, ppos);\n\n\tif (err < 0)\n\t\treturn err;\n\tif (ns->shm_rmid_forced)\n\t\tshm_destroy_orphaned(ns);\n\treturn err;\n}\n\nstatic int proc_ipc_auto_msgmni(struct ctl_table *table, int write,\n\t\tvoid *buffer, size_t *lenp, loff_t *ppos)\n{\n\tstruct ctl_table ipc_table;\n\tint dummy = 0;\n\n\tmemcpy(&ipc_table, table, sizeof(ipc_table));\n\tipc_table.data = &dummy;\n\n\tif (write)\n\t\tpr_info_once(\"writing to auto_msgmni has no effect\");\n\n\treturn proc_dointvec_minmax(&ipc_table, write, buffer, lenp, ppos);\n}\n\nstatic int proc_ipc_sem_dointvec(struct ctl_table *table, int write,\n\tvoid *buffer, size_t *lenp, loff_t *ppos)\n{\n\tstruct ipc_namespace *ns =\n\t\tcontainer_of(table->data, struct ipc_namespace, sem_ctls);\n\tint ret, semmni;\n\n\tsemmni = ns->sem_ctls[3];\n\tret = proc_dointvec(table, write, buffer, lenp, ppos);\n\n\tif (!ret)\n\t\tret = sem_check_semmni(ns);\n\n\t \n\tif (ret)\n\t\tns->sem_ctls[3] = semmni;\n\treturn ret;\n}\n\nint ipc_mni = IPCMNI;\nint ipc_mni_shift = IPCMNI_SHIFT;\nint ipc_min_cycle = RADIX_TREE_MAP_SIZE;\n\nstatic struct ctl_table ipc_sysctls[] = {\n\t{\n\t\t.procname\t= \"shmmax\",\n\t\t.data\t\t= &init_ipc_ns.shm_ctlmax,\n\t\t.maxlen\t\t= sizeof(init_ipc_ns.shm_ctlmax),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_doulongvec_minmax,\n\t},\n\t{\n\t\t.procname\t= \"shmall\",\n\t\t.data\t\t= &init_ipc_ns.shm_ctlall,\n\t\t.maxlen\t\t= sizeof(init_ipc_ns.shm_ctlall),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_doulongvec_minmax,\n\t},\n\t{\n\t\t.procname\t= \"shmmni\",\n\t\t.data\t\t= &init_ipc_ns.shm_ctlmni,\n\t\t.maxlen\t\t= sizeof(init_ipc_ns.shm_ctlmni),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= SYSCTL_ZERO,\n\t\t.extra2\t\t= &ipc_mni,\n\t},\n\t{\n\t\t.procname\t= \"shm_rmid_forced\",\n\t\t.data\t\t= &init_ipc_ns.shm_rmid_forced,\n\t\t.maxlen\t\t= sizeof(init_ipc_ns.shm_rmid_forced),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_ipc_dointvec_minmax_orphans,\n\t\t.extra1\t\t= SYSCTL_ZERO,\n\t\t.extra2\t\t= SYSCTL_ONE,\n\t},\n\t{\n\t\t.procname\t= \"msgmax\",\n\t\t.data\t\t= &init_ipc_ns.msg_ctlmax,\n\t\t.maxlen\t\t= sizeof(init_ipc_ns.msg_ctlmax),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= SYSCTL_ZERO,\n\t\t.extra2\t\t= SYSCTL_INT_MAX,\n\t},\n\t{\n\t\t.procname\t= \"msgmni\",\n\t\t.data\t\t= &init_ipc_ns.msg_ctlmni,\n\t\t.maxlen\t\t= sizeof(init_ipc_ns.msg_ctlmni),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= SYSCTL_ZERO,\n\t\t.extra2\t\t= &ipc_mni,\n\t},\n\t{\n\t\t.procname\t= \"auto_msgmni\",\n\t\t.data\t\t= NULL,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_ipc_auto_msgmni,\n\t\t.extra1\t\t= SYSCTL_ZERO,\n\t\t.extra2\t\t= SYSCTL_ONE,\n\t},\n\t{\n\t\t.procname\t=  \"msgmnb\",\n\t\t.data\t\t= &init_ipc_ns.msg_ctlmnb,\n\t\t.maxlen\t\t= sizeof(init_ipc_ns.msg_ctlmnb),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= SYSCTL_ZERO,\n\t\t.extra2\t\t= SYSCTL_INT_MAX,\n\t},\n\t{\n\t\t.procname\t= \"sem\",\n\t\t.data\t\t= &init_ipc_ns.sem_ctls,\n\t\t.maxlen\t\t= 4*sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_ipc_sem_dointvec,\n\t},\n#ifdef CONFIG_CHECKPOINT_RESTORE\n\t{\n\t\t.procname\t= \"sem_next_id\",\n\t\t.data\t\t= &init_ipc_ns.ids[IPC_SEM_IDS].next_id,\n\t\t.maxlen\t\t= sizeof(init_ipc_ns.ids[IPC_SEM_IDS].next_id),\n\t\t.mode\t\t= 0444,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= SYSCTL_ZERO,\n\t\t.extra2\t\t= SYSCTL_INT_MAX,\n\t},\n\t{\n\t\t.procname\t= \"msg_next_id\",\n\t\t.data\t\t= &init_ipc_ns.ids[IPC_MSG_IDS].next_id,\n\t\t.maxlen\t\t= sizeof(init_ipc_ns.ids[IPC_MSG_IDS].next_id),\n\t\t.mode\t\t= 0444,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= SYSCTL_ZERO,\n\t\t.extra2\t\t= SYSCTL_INT_MAX,\n\t},\n\t{\n\t\t.procname\t= \"shm_next_id\",\n\t\t.data\t\t= &init_ipc_ns.ids[IPC_SHM_IDS].next_id,\n\t\t.maxlen\t\t= sizeof(init_ipc_ns.ids[IPC_SHM_IDS].next_id),\n\t\t.mode\t\t= 0444,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= SYSCTL_ZERO,\n\t\t.extra2\t\t= SYSCTL_INT_MAX,\n\t},\n#endif\n\t{}\n};\n\nstatic struct ctl_table_set *set_lookup(struct ctl_table_root *root)\n{\n\treturn &current->nsproxy->ipc_ns->ipc_set;\n}\n\nstatic int set_is_seen(struct ctl_table_set *set)\n{\n\treturn &current->nsproxy->ipc_ns->ipc_set == set;\n}\n\nstatic int ipc_permissions(struct ctl_table_header *head, struct ctl_table *table)\n{\n\tint mode = table->mode;\n\n#ifdef CONFIG_CHECKPOINT_RESTORE\n\tstruct ipc_namespace *ns = current->nsproxy->ipc_ns;\n\n\tif (((table->data == &ns->ids[IPC_SEM_IDS].next_id) ||\n\t     (table->data == &ns->ids[IPC_MSG_IDS].next_id) ||\n\t     (table->data == &ns->ids[IPC_SHM_IDS].next_id)) &&\n\t    checkpoint_restore_ns_capable(ns->user_ns))\n\t\tmode = 0666;\n#endif\n\treturn mode;\n}\n\nstatic struct ctl_table_root set_root = {\n\t.lookup = set_lookup,\n\t.permissions = ipc_permissions,\n};\n\nbool setup_ipc_sysctls(struct ipc_namespace *ns)\n{\n\tstruct ctl_table *tbl;\n\n\tsetup_sysctl_set(&ns->ipc_set, &set_root, set_is_seen);\n\n\ttbl = kmemdup(ipc_sysctls, sizeof(ipc_sysctls), GFP_KERNEL);\n\tif (tbl) {\n\t\tint i;\n\n\t\tfor (i = 0; i < ARRAY_SIZE(ipc_sysctls); i++) {\n\t\t\tif (tbl[i].data == &init_ipc_ns.shm_ctlmax)\n\t\t\t\ttbl[i].data = &ns->shm_ctlmax;\n\n\t\t\telse if (tbl[i].data == &init_ipc_ns.shm_ctlall)\n\t\t\t\ttbl[i].data = &ns->shm_ctlall;\n\n\t\t\telse if (tbl[i].data == &init_ipc_ns.shm_ctlmni)\n\t\t\t\ttbl[i].data = &ns->shm_ctlmni;\n\n\t\t\telse if (tbl[i].data == &init_ipc_ns.shm_rmid_forced)\n\t\t\t\ttbl[i].data = &ns->shm_rmid_forced;\n\n\t\t\telse if (tbl[i].data == &init_ipc_ns.msg_ctlmax)\n\t\t\t\ttbl[i].data = &ns->msg_ctlmax;\n\n\t\t\telse if (tbl[i].data == &init_ipc_ns.msg_ctlmni)\n\t\t\t\ttbl[i].data = &ns->msg_ctlmni;\n\n\t\t\telse if (tbl[i].data == &init_ipc_ns.msg_ctlmnb)\n\t\t\t\ttbl[i].data = &ns->msg_ctlmnb;\n\n\t\t\telse if (tbl[i].data == &init_ipc_ns.sem_ctls)\n\t\t\t\ttbl[i].data = &ns->sem_ctls;\n#ifdef CONFIG_CHECKPOINT_RESTORE\n\t\t\telse if (tbl[i].data == &init_ipc_ns.ids[IPC_SEM_IDS].next_id)\n\t\t\t\ttbl[i].data = &ns->ids[IPC_SEM_IDS].next_id;\n\n\t\t\telse if (tbl[i].data == &init_ipc_ns.ids[IPC_MSG_IDS].next_id)\n\t\t\t\ttbl[i].data = &ns->ids[IPC_MSG_IDS].next_id;\n\n\t\t\telse if (tbl[i].data == &init_ipc_ns.ids[IPC_SHM_IDS].next_id)\n\t\t\t\ttbl[i].data = &ns->ids[IPC_SHM_IDS].next_id;\n#endif\n\t\t\telse\n\t\t\t\ttbl[i].data = NULL;\n\t\t}\n\n\t\tns->ipc_sysctls = __register_sysctl_table(&ns->ipc_set,\n\t\t\t\t\t\t\t  \"kernel\", tbl,\n\t\t\t\t\t\t\t  ARRAY_SIZE(ipc_sysctls));\n\t}\n\tif (!ns->ipc_sysctls) {\n\t\tkfree(tbl);\n\t\tretire_sysctl_set(&ns->ipc_set);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nvoid retire_ipc_sysctls(struct ipc_namespace *ns)\n{\n\tstruct ctl_table *tbl;\n\n\ttbl = ns->ipc_sysctls->ctl_table_arg;\n\tunregister_sysctl_table(ns->ipc_sysctls);\n\tretire_sysctl_set(&ns->ipc_set);\n\tkfree(tbl);\n}\n\nstatic int __init ipc_sysctl_init(void)\n{\n\tif (!setup_ipc_sysctls(&init_ipc_ns)) {\n\t\tpr_warn(\"ipc sysctl registration failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}\n\ndevice_initcall(ipc_sysctl_init);\n\nstatic int __init ipc_mni_extend(char *str)\n{\n\tipc_mni = IPCMNI_EXTEND;\n\tipc_mni_shift = IPCMNI_EXTEND_SHIFT;\n\tipc_min_cycle = IPCMNI_EXTEND_MIN_CYCLE;\n\tpr_info(\"IPCMNI extended to %d.\\n\", ipc_mni);\n\treturn 0;\n}\nearly_param(\"ipcmni_extend\", ipc_mni_extend);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}