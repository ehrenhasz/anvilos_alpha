{
  "module_name": "util.h",
  "hash_id": "858b18da410025c3ce8522711060f46828c0c99421faae89c972e6acde4a056e",
  "original_prompt": "Ingested from linux-6.6.14/ipc/util.h",
  "human_readable_source": " \n \n\n#ifndef _IPC_UTIL_H\n#define _IPC_UTIL_H\n\n#include <linux/unistd.h>\n#include <linux/err.h>\n#include <linux/ipc_namespace.h>\n\n \n#define IPCMNI_SHIFT\t\t15\n#define IPCMNI_EXTEND_SHIFT\t24\n#define IPCMNI_EXTEND_MIN_CYCLE\t(RADIX_TREE_MAP_SIZE * RADIX_TREE_MAP_SIZE)\n#define IPCMNI\t\t\t(1 << IPCMNI_SHIFT)\n#define IPCMNI_EXTEND\t\t(1 << IPCMNI_EXTEND_SHIFT)\n\n#ifdef CONFIG_SYSVIPC_SYSCTL\nextern int ipc_mni;\nextern int ipc_mni_shift;\nextern int ipc_min_cycle;\n\n#define ipcmni_seq_shift()\tipc_mni_shift\n#define IPCMNI_IDX_MASK\t\t((1 << ipc_mni_shift) - 1)\n\n#else  \n\n#define ipc_mni\t\t\tIPCMNI\n#define ipc_min_cycle\t\t((int)RADIX_TREE_MAP_SIZE)\n#define ipcmni_seq_shift()\tIPCMNI_SHIFT\n#define IPCMNI_IDX_MASK\t\t((1 << IPCMNI_SHIFT) - 1)\n#endif  \n\nvoid sem_init(void);\nvoid msg_init(void);\nvoid shm_init(void);\n\nstruct ipc_namespace;\nstruct pid_namespace;\n\n#ifdef CONFIG_POSIX_MQUEUE\nextern void mq_clear_sbinfo(struct ipc_namespace *ns);\n#else\nstatic inline void mq_clear_sbinfo(struct ipc_namespace *ns) { }\n#endif\n\n#ifdef CONFIG_SYSVIPC\nvoid sem_init_ns(struct ipc_namespace *ns);\nint msg_init_ns(struct ipc_namespace *ns);\nvoid shm_init_ns(struct ipc_namespace *ns);\n\nvoid sem_exit_ns(struct ipc_namespace *ns);\nvoid msg_exit_ns(struct ipc_namespace *ns);\nvoid shm_exit_ns(struct ipc_namespace *ns);\n#else\nstatic inline void sem_init_ns(struct ipc_namespace *ns) { }\nstatic inline int msg_init_ns(struct ipc_namespace *ns) { return 0; }\nstatic inline void shm_init_ns(struct ipc_namespace *ns) { }\n\nstatic inline void sem_exit_ns(struct ipc_namespace *ns) { }\nstatic inline void msg_exit_ns(struct ipc_namespace *ns) { }\nstatic inline void shm_exit_ns(struct ipc_namespace *ns) { }\n#endif\n\n \nstruct ipc_params {\n\tkey_t key;\n\tint flg;\n\tunion {\n\t\tsize_t size;\t \n\t\tint nsems;\t \n\t} u;\t\t\t \n};\n\n \nstruct ipc_ops {\n\tint (*getnew)(struct ipc_namespace *, struct ipc_params *);\n\tint (*associate)(struct kern_ipc_perm *, int);\n\tint (*more_checks)(struct kern_ipc_perm *, struct ipc_params *);\n};\n\nstruct seq_file;\nstruct ipc_ids;\n\nvoid ipc_init_ids(struct ipc_ids *ids);\n#ifdef CONFIG_PROC_FS\nvoid __init ipc_init_proc_interface(const char *path, const char *header,\n\t\tint ids, int (*show)(struct seq_file *, void *));\nstruct pid_namespace *ipc_seq_pid_ns(struct seq_file *);\n#else\n#define ipc_init_proc_interface(path, header, ids, show) do {} while (0)\n#endif\n\n#define IPC_SEM_IDS\t0\n#define IPC_MSG_IDS\t1\n#define IPC_SHM_IDS\t2\n\n#define ipcid_to_idx(id)  ((id) & IPCMNI_IDX_MASK)\n#define ipcid_to_seqx(id) ((id) >> ipcmni_seq_shift())\n#define ipcid_seq_max()\t  (INT_MAX >> ipcmni_seq_shift())\n\n \nint ipc_addid(struct ipc_ids *, struct kern_ipc_perm *, int);\n\n \nvoid ipc_rmid(struct ipc_ids *, struct kern_ipc_perm *);\n\n \nvoid ipc_set_key_private(struct ipc_ids *, struct kern_ipc_perm *);\n\n \nint ipcperms(struct ipc_namespace *ns, struct kern_ipc_perm *ipcp, short flg);\n\n \nstatic inline int ipc_get_maxidx(struct ipc_ids *ids)\n{\n\tif (ids->in_use == 0)\n\t\treturn -1;\n\n\tif (ids->in_use == ipc_mni)\n\t\treturn ipc_mni - 1;\n\n\treturn ids->max_idx;\n}\n\n \nbool ipc_rcu_getref(struct kern_ipc_perm *ptr);\nvoid ipc_rcu_putref(struct kern_ipc_perm *ptr,\n\t\t\tvoid (*func)(struct rcu_head *head));\n\nstruct kern_ipc_perm *ipc_obtain_object_idr(struct ipc_ids *ids, int id);\n\nvoid kernel_to_ipc64_perm(struct kern_ipc_perm *in, struct ipc64_perm *out);\nvoid ipc64_perm_to_ipc_perm(struct ipc64_perm *in, struct ipc_perm *out);\nint ipc_update_perm(struct ipc64_perm *in, struct kern_ipc_perm *out);\nstruct kern_ipc_perm *ipcctl_obtain_check(struct ipc_namespace *ns,\n\t\t\t\t\t     struct ipc_ids *ids, int id, int cmd,\n\t\t\t\t\t     struct ipc64_perm *perm, int extra_perm);\n\nstatic inline void ipc_update_pid(struct pid **pos, struct pid *pid)\n{\n\tstruct pid *old = *pos;\n\tif (old != pid) {\n\t\t*pos = get_pid(pid);\n\t\tput_pid(old);\n\t}\n}\n\n#ifdef CONFIG_ARCH_WANT_IPC_PARSE_VERSION\nint ipc_parse_version(int *cmd);\n#endif\n\nextern void free_msg(struct msg_msg *msg);\nextern struct msg_msg *load_msg(const void __user *src, size_t len);\nextern struct msg_msg *copy_msg(struct msg_msg *src, struct msg_msg *dst);\nextern int store_msg(void __user *dest, struct msg_msg *msg, size_t len);\n\nstatic inline int ipc_checkid(struct kern_ipc_perm *ipcp, int id)\n{\n\treturn ipcid_to_seqx(id) != ipcp->seq;\n}\n\nstatic inline void ipc_lock_object(struct kern_ipc_perm *perm)\n{\n\tspin_lock(&perm->lock);\n}\n\nstatic inline void ipc_unlock_object(struct kern_ipc_perm *perm)\n{\n\tspin_unlock(&perm->lock);\n}\n\nstatic inline void ipc_assert_locked_object(struct kern_ipc_perm *perm)\n{\n\tassert_spin_locked(&perm->lock);\n}\n\nstatic inline void ipc_unlock(struct kern_ipc_perm *perm)\n{\n\tipc_unlock_object(perm);\n\trcu_read_unlock();\n}\n\n \nstatic inline bool ipc_valid_object(struct kern_ipc_perm *perm)\n{\n\treturn !perm->deleted;\n}\n\nstruct kern_ipc_perm *ipc_obtain_object_check(struct ipc_ids *ids, int id);\nint ipcget(struct ipc_namespace *ns, struct ipc_ids *ids,\n\t\t\tconst struct ipc_ops *ops, struct ipc_params *params);\nvoid free_ipcs(struct ipc_namespace *ns, struct ipc_ids *ids,\n\t\tvoid (*free)(struct ipc_namespace *, struct kern_ipc_perm *));\n\nstatic inline int sem_check_semmni(struct ipc_namespace *ns) {\n\t \n\treturn ((ns->sem_ctls[3] < 0) || (ns->sem_ctls[3] > ipc_mni))\n\t\t? -ERANGE : 0;\n}\n\n#ifdef CONFIG_COMPAT\n#include <linux/compat.h>\nstruct compat_ipc_perm {\n\tkey_t key;\n\t__compat_uid_t uid;\n\t__compat_gid_t gid;\n\t__compat_uid_t cuid;\n\t__compat_gid_t cgid;\n\tcompat_mode_t mode;\n\tunsigned short seq;\n};\n\nvoid to_compat_ipc_perm(struct compat_ipc_perm *, struct ipc64_perm *);\nvoid to_compat_ipc64_perm(struct compat_ipc64_perm *, struct ipc64_perm *);\nint get_compat_ipc_perm(struct ipc64_perm *, struct compat_ipc_perm __user *);\nint get_compat_ipc64_perm(struct ipc64_perm *,\n\t\t\t  struct compat_ipc64_perm __user *);\n\nstatic inline int compat_ipc_parse_version(int *cmd)\n{\n\tint version = *cmd & IPC_64;\n\t*cmd &= ~IPC_64;\n\treturn version;\n}\n\nlong compat_ksys_old_semctl(int semid, int semnum, int cmd, int arg);\nlong compat_ksys_old_msgctl(int msqid, int cmd, void __user *uptr);\nlong compat_ksys_msgrcv(int msqid, compat_uptr_t msgp, compat_ssize_t msgsz,\n\t\t\tcompat_long_t msgtyp, int msgflg);\nlong compat_ksys_msgsnd(int msqid, compat_uptr_t msgp,\n\t\t       compat_ssize_t msgsz, int msgflg);\nlong compat_ksys_old_shmctl(int shmid, int cmd, void __user *uptr);\n\n#endif\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}