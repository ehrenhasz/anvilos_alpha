{
  "module_name": "msgutil.c",
  "hash_id": "e588da7c0310231092cdcd81d934f0dac2115b320180c9f9b71d8364e046c988",
  "original_prompt": "Ingested from linux-6.6.14/ipc/msgutil.c",
  "human_readable_source": "\n \n\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/ipc.h>\n#include <linux/msg.h>\n#include <linux/ipc_namespace.h>\n#include <linux/utsname.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/sched.h>\n\n#include \"util.h\"\n\nDEFINE_SPINLOCK(mq_lock);\n\n \nstruct ipc_namespace init_ipc_ns = {\n\t.ns.count = REFCOUNT_INIT(1),\n\t.user_ns = &init_user_ns,\n\t.ns.inum = PROC_IPC_INIT_INO,\n#ifdef CONFIG_IPC_NS\n\t.ns.ops = &ipcns_operations,\n#endif\n};\n\nstruct msg_msgseg {\n\tstruct msg_msgseg *next;\n\t \n};\n\n#define DATALEN_MSG\t((size_t)PAGE_SIZE-sizeof(struct msg_msg))\n#define DATALEN_SEG\t((size_t)PAGE_SIZE-sizeof(struct msg_msgseg))\n\n\nstatic struct msg_msg *alloc_msg(size_t len)\n{\n\tstruct msg_msg *msg;\n\tstruct msg_msgseg **pseg;\n\tsize_t alen;\n\n\talen = min(len, DATALEN_MSG);\n\tmsg = kmalloc(sizeof(*msg) + alen, GFP_KERNEL_ACCOUNT);\n\tif (msg == NULL)\n\t\treturn NULL;\n\n\tmsg->next = NULL;\n\tmsg->security = NULL;\n\n\tlen -= alen;\n\tpseg = &msg->next;\n\twhile (len > 0) {\n\t\tstruct msg_msgseg *seg;\n\n\t\tcond_resched();\n\n\t\talen = min(len, DATALEN_SEG);\n\t\tseg = kmalloc(sizeof(*seg) + alen, GFP_KERNEL_ACCOUNT);\n\t\tif (seg == NULL)\n\t\t\tgoto out_err;\n\t\t*pseg = seg;\n\t\tseg->next = NULL;\n\t\tpseg = &seg->next;\n\t\tlen -= alen;\n\t}\n\n\treturn msg;\n\nout_err:\n\tfree_msg(msg);\n\treturn NULL;\n}\n\nstruct msg_msg *load_msg(const void __user *src, size_t len)\n{\n\tstruct msg_msg *msg;\n\tstruct msg_msgseg *seg;\n\tint err = -EFAULT;\n\tsize_t alen;\n\n\tmsg = alloc_msg(len);\n\tif (msg == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\talen = min(len, DATALEN_MSG);\n\tif (copy_from_user(msg + 1, src, alen))\n\t\tgoto out_err;\n\n\tfor (seg = msg->next; seg != NULL; seg = seg->next) {\n\t\tlen -= alen;\n\t\tsrc = (char __user *)src + alen;\n\t\talen = min(len, DATALEN_SEG);\n\t\tif (copy_from_user(seg + 1, src, alen))\n\t\t\tgoto out_err;\n\t}\n\n\terr = security_msg_msg_alloc(msg);\n\tif (err)\n\t\tgoto out_err;\n\n\treturn msg;\n\nout_err:\n\tfree_msg(msg);\n\treturn ERR_PTR(err);\n}\n#ifdef CONFIG_CHECKPOINT_RESTORE\nstruct msg_msg *copy_msg(struct msg_msg *src, struct msg_msg *dst)\n{\n\tstruct msg_msgseg *dst_pseg, *src_pseg;\n\tsize_t len = src->m_ts;\n\tsize_t alen;\n\n\tif (src->m_ts > dst->m_ts)\n\t\treturn ERR_PTR(-EINVAL);\n\n\talen = min(len, DATALEN_MSG);\n\tmemcpy(dst + 1, src + 1, alen);\n\n\tfor (dst_pseg = dst->next, src_pseg = src->next;\n\t     src_pseg != NULL;\n\t     dst_pseg = dst_pseg->next, src_pseg = src_pseg->next) {\n\n\t\tlen -= alen;\n\t\talen = min(len, DATALEN_SEG);\n\t\tmemcpy(dst_pseg + 1, src_pseg + 1, alen);\n\t}\n\n\tdst->m_type = src->m_type;\n\tdst->m_ts = src->m_ts;\n\n\treturn dst;\n}\n#else\nstruct msg_msg *copy_msg(struct msg_msg *src, struct msg_msg *dst)\n{\n\treturn ERR_PTR(-ENOSYS);\n}\n#endif\nint store_msg(void __user *dest, struct msg_msg *msg, size_t len)\n{\n\tsize_t alen;\n\tstruct msg_msgseg *seg;\n\n\talen = min(len, DATALEN_MSG);\n\tif (copy_to_user(dest, msg + 1, alen))\n\t\treturn -1;\n\n\tfor (seg = msg->next; seg != NULL; seg = seg->next) {\n\t\tlen -= alen;\n\t\tdest = (char __user *)dest + alen;\n\t\talen = min(len, DATALEN_SEG);\n\t\tif (copy_to_user(dest, seg + 1, alen))\n\t\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nvoid free_msg(struct msg_msg *msg)\n{\n\tstruct msg_msgseg *seg;\n\n\tsecurity_msg_msg_free(msg);\n\n\tseg = msg->next;\n\tkfree(msg);\n\twhile (seg != NULL) {\n\t\tstruct msg_msgseg *tmp = seg->next;\n\n\t\tcond_resched();\n\t\tkfree(seg);\n\t\tseg = tmp;\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}