{
  "module_name": "sem.c",
  "hash_id": "30891e6e9dd544020575e0b57f0af1065c098554d081b2cef57d3a38311e9de1",
  "original_prompt": "Ingested from linux-6.6.14/ipc/sem.c",
  "human_readable_source": "\n \n\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/security.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/capability.h>\n#include <linux/seq_file.h>\n#include <linux/rwsem.h>\n#include <linux/nsproxy.h>\n#include <linux/ipc_namespace.h>\n#include <linux/sched/wake_q.h>\n#include <linux/nospec.h>\n#include <linux/rhashtable.h>\n\n#include <linux/uaccess.h>\n#include \"util.h\"\n\n \nstruct sem {\n\tint\tsemval;\t\t \n\t \n\tstruct pid *sempid;\n\tspinlock_t\tlock;\t \n\tstruct list_head pending_alter;  \n\t\t\t\t\t \n\tstruct list_head pending_const;  \n\t\t\t\t\t \n\ttime64_t\t sem_otime;\t \n} ____cacheline_aligned_in_smp;\n\n \nstruct sem_array {\n\tstruct kern_ipc_perm\tsem_perm;\t \n\ttime64_t\t\tsem_ctime;\t \n\tstruct list_head\tpending_alter;\t \n\t\t\t\t\t\t \n\tstruct list_head\tpending_const;\t \n\t\t\t\t\t\t \n\tstruct list_head\tlist_id;\t \n\tint\t\t\tsem_nsems;\t \n\tint\t\t\tcomplex_count;\t \n\tunsigned int\t\tuse_global_lock; \n\n\tstruct sem\t\tsems[];\n} __randomize_layout;\n\n \nstruct sem_queue {\n\tstruct list_head\tlist;\t  \n\tstruct task_struct\t*sleeper;  \n\tstruct sem_undo\t\t*undo;\t  \n\tstruct pid\t\t*pid;\t  \n\tint\t\t\tstatus;\t  \n\tstruct sembuf\t\t*sops;\t  \n\tstruct sembuf\t\t*blocking;  \n\tint\t\t\tnsops;\t  \n\tbool\t\t\talter;\t  \n\tbool                    dupsop;\t  \n};\n\n \nstruct sem_undo {\n\tstruct list_head\tlist_proc;\t \n\tstruct rcu_head\t\trcu;\t\t \n\tstruct sem_undo_list\t*ulp;\t\t \n\tstruct list_head\tlist_id;\t \n\tint\t\t\tsemid;\t\t \n\tshort\t\t\tsemadj[];\t \n\t\t\t\t\t\t \n};\n\n \nstruct sem_undo_list {\n\trefcount_t\t\trefcnt;\n\tspinlock_t\t\tlock;\n\tstruct list_head\tlist_proc;\n};\n\n\n#define sem_ids(ns)\t((ns)->ids[IPC_SEM_IDS])\n\nstatic int newary(struct ipc_namespace *, struct ipc_params *);\nstatic void freeary(struct ipc_namespace *, struct kern_ipc_perm *);\n#ifdef CONFIG_PROC_FS\nstatic int sysvipc_sem_proc_show(struct seq_file *s, void *it);\n#endif\n\n#define SEMMSL_FAST\t256  \n#define SEMOPM_FAST\t64   \n\n \n#define USE_GLOBAL_LOCK_HYSTERESIS\t10\n\n \n\n#define sc_semmsl\tsem_ctls[0]\n#define sc_semmns\tsem_ctls[1]\n#define sc_semopm\tsem_ctls[2]\n#define sc_semmni\tsem_ctls[3]\n\nvoid sem_init_ns(struct ipc_namespace *ns)\n{\n\tns->sc_semmsl = SEMMSL;\n\tns->sc_semmns = SEMMNS;\n\tns->sc_semopm = SEMOPM;\n\tns->sc_semmni = SEMMNI;\n\tns->used_sems = 0;\n\tipc_init_ids(&ns->ids[IPC_SEM_IDS]);\n}\n\n#ifdef CONFIG_IPC_NS\nvoid sem_exit_ns(struct ipc_namespace *ns)\n{\n\tfree_ipcs(ns, &sem_ids(ns), freeary);\n\tidr_destroy(&ns->ids[IPC_SEM_IDS].ipcs_idr);\n\trhashtable_destroy(&ns->ids[IPC_SEM_IDS].key_ht);\n}\n#endif\n\nvoid __init sem_init(void)\n{\n\tsem_init_ns(&init_ipc_ns);\n\tipc_init_proc_interface(\"sysvipc/sem\",\n\t\t\t\t\"       key      semid perms      nsems   uid   gid  cuid  cgid      otime      ctime\\n\",\n\t\t\t\tIPC_SEM_IDS, sysvipc_sem_proc_show);\n}\n\n \nstatic void unmerge_queues(struct sem_array *sma)\n{\n\tstruct sem_queue *q, *tq;\n\n\t \n\tif (sma->complex_count)\n\t\treturn;\n\t \n\tlist_for_each_entry_safe(q, tq, &sma->pending_alter, list) {\n\t\tstruct sem *curr;\n\t\tcurr = &sma->sems[q->sops[0].sem_num];\n\n\t\tlist_add_tail(&q->list, &curr->pending_alter);\n\t}\n\tINIT_LIST_HEAD(&sma->pending_alter);\n}\n\n \nstatic void merge_queues(struct sem_array *sma)\n{\n\tint i;\n\tfor (i = 0; i < sma->sem_nsems; i++) {\n\t\tstruct sem *sem = &sma->sems[i];\n\n\t\tlist_splice_init(&sem->pending_alter, &sma->pending_alter);\n\t}\n}\n\nstatic void sem_rcu_free(struct rcu_head *head)\n{\n\tstruct kern_ipc_perm *p = container_of(head, struct kern_ipc_perm, rcu);\n\tstruct sem_array *sma = container_of(p, struct sem_array, sem_perm);\n\n\tsecurity_sem_free(&sma->sem_perm);\n\tkvfree(sma);\n}\n\n \nstatic void complexmode_enter(struct sem_array *sma)\n{\n\tint i;\n\tstruct sem *sem;\n\n\tif (sma->use_global_lock > 0)  {\n\t\t \n\t\tWRITE_ONCE(sma->use_global_lock, USE_GLOBAL_LOCK_HYSTERESIS);\n\t\treturn;\n\t}\n\tWRITE_ONCE(sma->use_global_lock, USE_GLOBAL_LOCK_HYSTERESIS);\n\n\tfor (i = 0; i < sma->sem_nsems; i++) {\n\t\tsem = &sma->sems[i];\n\t\tspin_lock(&sem->lock);\n\t\tspin_unlock(&sem->lock);\n\t}\n}\n\n \nstatic void complexmode_tryleave(struct sem_array *sma)\n{\n\tif (sma->complex_count)  {\n\t\t \n\t\treturn;\n\t}\n\tif (sma->use_global_lock == 1) {\n\n\t\t \n\t\tsmp_store_release(&sma->use_global_lock, 0);\n\t} else {\n\t\tWRITE_ONCE(sma->use_global_lock,\n\t\t\t\tsma->use_global_lock-1);\n\t}\n}\n\n#define SEM_GLOBAL_LOCK\t(-1)\n \nstatic inline int sem_lock(struct sem_array *sma, struct sembuf *sops,\n\t\t\t      int nsops)\n{\n\tstruct sem *sem;\n\tint idx;\n\n\tif (nsops != 1) {\n\t\t \n\t\tipc_lock_object(&sma->sem_perm);\n\n\t\t \n\t\tcomplexmode_enter(sma);\n\t\treturn SEM_GLOBAL_LOCK;\n\t}\n\n\t \n\tidx = array_index_nospec(sops->sem_num, sma->sem_nsems);\n\tsem = &sma->sems[idx];\n\n\t \n\tif (!READ_ONCE(sma->use_global_lock)) {\n\t\t \n\t\tspin_lock(&sem->lock);\n\n\t\t \n\t\tif (!smp_load_acquire(&sma->use_global_lock)) {\n\t\t\t \n\t\t\treturn sops->sem_num;\n\t\t}\n\t\tspin_unlock(&sem->lock);\n\t}\n\n\t \n\tipc_lock_object(&sma->sem_perm);\n\n\tif (sma->use_global_lock == 0) {\n\t\t \n\t\tspin_lock(&sem->lock);\n\n\t\tipc_unlock_object(&sma->sem_perm);\n\t\treturn sops->sem_num;\n\t} else {\n\t\t \n\t\treturn SEM_GLOBAL_LOCK;\n\t}\n}\n\nstatic inline void sem_unlock(struct sem_array *sma, int locknum)\n{\n\tif (locknum == SEM_GLOBAL_LOCK) {\n\t\tunmerge_queues(sma);\n\t\tcomplexmode_tryleave(sma);\n\t\tipc_unlock_object(&sma->sem_perm);\n\t} else {\n\t\tstruct sem *sem = &sma->sems[locknum];\n\t\tspin_unlock(&sem->lock);\n\t}\n}\n\n \nstatic inline struct sem_array *sem_obtain_object(struct ipc_namespace *ns, int id)\n{\n\tstruct kern_ipc_perm *ipcp = ipc_obtain_object_idr(&sem_ids(ns), id);\n\n\tif (IS_ERR(ipcp))\n\t\treturn ERR_CAST(ipcp);\n\n\treturn container_of(ipcp, struct sem_array, sem_perm);\n}\n\nstatic inline struct sem_array *sem_obtain_object_check(struct ipc_namespace *ns,\n\t\t\t\t\t\t\tint id)\n{\n\tstruct kern_ipc_perm *ipcp = ipc_obtain_object_check(&sem_ids(ns), id);\n\n\tif (IS_ERR(ipcp))\n\t\treturn ERR_CAST(ipcp);\n\n\treturn container_of(ipcp, struct sem_array, sem_perm);\n}\n\nstatic inline void sem_lock_and_putref(struct sem_array *sma)\n{\n\tsem_lock(sma, NULL, -1);\n\tipc_rcu_putref(&sma->sem_perm, sem_rcu_free);\n}\n\nstatic inline void sem_rmid(struct ipc_namespace *ns, struct sem_array *s)\n{\n\tipc_rmid(&sem_ids(ns), &s->sem_perm);\n}\n\nstatic struct sem_array *sem_alloc(size_t nsems)\n{\n\tstruct sem_array *sma;\n\n\tif (nsems > (INT_MAX - sizeof(*sma)) / sizeof(sma->sems[0]))\n\t\treturn NULL;\n\n\tsma = kvzalloc(struct_size(sma, sems, nsems), GFP_KERNEL_ACCOUNT);\n\tif (unlikely(!sma))\n\t\treturn NULL;\n\n\treturn sma;\n}\n\n \nstatic int newary(struct ipc_namespace *ns, struct ipc_params *params)\n{\n\tint retval;\n\tstruct sem_array *sma;\n\tkey_t key = params->key;\n\tint nsems = params->u.nsems;\n\tint semflg = params->flg;\n\tint i;\n\n\tif (!nsems)\n\t\treturn -EINVAL;\n\tif (ns->used_sems + nsems > ns->sc_semmns)\n\t\treturn -ENOSPC;\n\n\tsma = sem_alloc(nsems);\n\tif (!sma)\n\t\treturn -ENOMEM;\n\n\tsma->sem_perm.mode = (semflg & S_IRWXUGO);\n\tsma->sem_perm.key = key;\n\n\tsma->sem_perm.security = NULL;\n\tretval = security_sem_alloc(&sma->sem_perm);\n\tif (retval) {\n\t\tkvfree(sma);\n\t\treturn retval;\n\t}\n\n\tfor (i = 0; i < nsems; i++) {\n\t\tINIT_LIST_HEAD(&sma->sems[i].pending_alter);\n\t\tINIT_LIST_HEAD(&sma->sems[i].pending_const);\n\t\tspin_lock_init(&sma->sems[i].lock);\n\t}\n\n\tsma->complex_count = 0;\n\tsma->use_global_lock = USE_GLOBAL_LOCK_HYSTERESIS;\n\tINIT_LIST_HEAD(&sma->pending_alter);\n\tINIT_LIST_HEAD(&sma->pending_const);\n\tINIT_LIST_HEAD(&sma->list_id);\n\tsma->sem_nsems = nsems;\n\tsma->sem_ctime = ktime_get_real_seconds();\n\n\t \n\tretval = ipc_addid(&sem_ids(ns), &sma->sem_perm, ns->sc_semmni);\n\tif (retval < 0) {\n\t\tipc_rcu_putref(&sma->sem_perm, sem_rcu_free);\n\t\treturn retval;\n\t}\n\tns->used_sems += nsems;\n\n\tsem_unlock(sma, -1);\n\trcu_read_unlock();\n\n\treturn sma->sem_perm.id;\n}\n\n\n \nstatic int sem_more_checks(struct kern_ipc_perm *ipcp, struct ipc_params *params)\n{\n\tstruct sem_array *sma;\n\n\tsma = container_of(ipcp, struct sem_array, sem_perm);\n\tif (params->u.nsems > sma->sem_nsems)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nlong ksys_semget(key_t key, int nsems, int semflg)\n{\n\tstruct ipc_namespace *ns;\n\tstatic const struct ipc_ops sem_ops = {\n\t\t.getnew = newary,\n\t\t.associate = security_sem_associate,\n\t\t.more_checks = sem_more_checks,\n\t};\n\tstruct ipc_params sem_params;\n\n\tns = current->nsproxy->ipc_ns;\n\n\tif (nsems < 0 || nsems > ns->sc_semmsl)\n\t\treturn -EINVAL;\n\n\tsem_params.key = key;\n\tsem_params.flg = semflg;\n\tsem_params.u.nsems = nsems;\n\n\treturn ipcget(ns, &sem_ids(ns), &sem_ops, &sem_params);\n}\n\nSYSCALL_DEFINE3(semget, key_t, key, int, nsems, int, semflg)\n{\n\treturn ksys_semget(key, nsems, semflg);\n}\n\n \nstatic int perform_atomic_semop_slow(struct sem_array *sma, struct sem_queue *q)\n{\n\tint result, sem_op, nsops;\n\tstruct pid *pid;\n\tstruct sembuf *sop;\n\tstruct sem *curr;\n\tstruct sembuf *sops;\n\tstruct sem_undo *un;\n\n\tsops = q->sops;\n\tnsops = q->nsops;\n\tun = q->undo;\n\n\tfor (sop = sops; sop < sops + nsops; sop++) {\n\t\tint idx = array_index_nospec(sop->sem_num, sma->sem_nsems);\n\t\tcurr = &sma->sems[idx];\n\t\tsem_op = sop->sem_op;\n\t\tresult = curr->semval;\n\n\t\tif (!sem_op && result)\n\t\t\tgoto would_block;\n\n\t\tresult += sem_op;\n\t\tif (result < 0)\n\t\t\tgoto would_block;\n\t\tif (result > SEMVMX)\n\t\t\tgoto out_of_range;\n\n\t\tif (sop->sem_flg & SEM_UNDO) {\n\t\t\tint undo = un->semadj[sop->sem_num] - sem_op;\n\t\t\t \n\t\t\tif (undo < (-SEMAEM - 1) || undo > SEMAEM)\n\t\t\t\tgoto out_of_range;\n\t\t\tun->semadj[sop->sem_num] = undo;\n\t\t}\n\n\t\tcurr->semval = result;\n\t}\n\n\tsop--;\n\tpid = q->pid;\n\twhile (sop >= sops) {\n\t\tipc_update_pid(&sma->sems[sop->sem_num].sempid, pid);\n\t\tsop--;\n\t}\n\n\treturn 0;\n\nout_of_range:\n\tresult = -ERANGE;\n\tgoto undo;\n\nwould_block:\n\tq->blocking = sop;\n\n\tif (sop->sem_flg & IPC_NOWAIT)\n\t\tresult = -EAGAIN;\n\telse\n\t\tresult = 1;\n\nundo:\n\tsop--;\n\twhile (sop >= sops) {\n\t\tsem_op = sop->sem_op;\n\t\tsma->sems[sop->sem_num].semval -= sem_op;\n\t\tif (sop->sem_flg & SEM_UNDO)\n\t\t\tun->semadj[sop->sem_num] += sem_op;\n\t\tsop--;\n\t}\n\n\treturn result;\n}\n\nstatic int perform_atomic_semop(struct sem_array *sma, struct sem_queue *q)\n{\n\tint result, sem_op, nsops;\n\tstruct sembuf *sop;\n\tstruct sem *curr;\n\tstruct sembuf *sops;\n\tstruct sem_undo *un;\n\n\tsops = q->sops;\n\tnsops = q->nsops;\n\tun = q->undo;\n\n\tif (unlikely(q->dupsop))\n\t\treturn perform_atomic_semop_slow(sma, q);\n\n\t \n\tfor (sop = sops; sop < sops + nsops; sop++) {\n\t\tint idx = array_index_nospec(sop->sem_num, sma->sem_nsems);\n\n\t\tcurr = &sma->sems[idx];\n\t\tsem_op = sop->sem_op;\n\t\tresult = curr->semval;\n\n\t\tif (!sem_op && result)\n\t\t\tgoto would_block;  \n\n\t\tresult += sem_op;\n\t\tif (result < 0)\n\t\t\tgoto would_block;\n\n\t\tif (result > SEMVMX)\n\t\t\treturn -ERANGE;\n\n\t\tif (sop->sem_flg & SEM_UNDO) {\n\t\t\tint undo = un->semadj[sop->sem_num] - sem_op;\n\n\t\t\t \n\t\t\tif (undo < (-SEMAEM - 1) || undo > SEMAEM)\n\t\t\t\treturn -ERANGE;\n\t\t}\n\t}\n\n\tfor (sop = sops; sop < sops + nsops; sop++) {\n\t\tcurr = &sma->sems[sop->sem_num];\n\t\tsem_op = sop->sem_op;\n\n\t\tif (sop->sem_flg & SEM_UNDO) {\n\t\t\tint undo = un->semadj[sop->sem_num] - sem_op;\n\n\t\t\tun->semadj[sop->sem_num] = undo;\n\t\t}\n\t\tcurr->semval += sem_op;\n\t\tipc_update_pid(&curr->sempid, q->pid);\n\t}\n\n\treturn 0;\n\nwould_block:\n\tq->blocking = sop;\n\treturn sop->sem_flg & IPC_NOWAIT ? -EAGAIN : 1;\n}\n\nstatic inline void wake_up_sem_queue_prepare(struct sem_queue *q, int error,\n\t\t\t\t\t     struct wake_q_head *wake_q)\n{\n\tstruct task_struct *sleeper;\n\n\tsleeper = get_task_struct(q->sleeper);\n\n\t \n\tsmp_store_release(&q->status, error);\n\n\twake_q_add_safe(wake_q, sleeper);\n}\n\nstatic void unlink_queue(struct sem_array *sma, struct sem_queue *q)\n{\n\tlist_del(&q->list);\n\tif (q->nsops > 1)\n\t\tsma->complex_count--;\n}\n\n \nstatic inline int check_restart(struct sem_array *sma, struct sem_queue *q)\n{\n\t \n\tif (!list_empty(&sma->pending_alter))\n\t\treturn 1;\n\n\t \n\tif (q->nsops > 1)\n\t\treturn 1;\n\n\t \n\treturn 0;\n}\n\n \nstatic int wake_const_ops(struct sem_array *sma, int semnum,\n\t\t\t  struct wake_q_head *wake_q)\n{\n\tstruct sem_queue *q, *tmp;\n\tstruct list_head *pending_list;\n\tint semop_completed = 0;\n\n\tif (semnum == -1)\n\t\tpending_list = &sma->pending_const;\n\telse\n\t\tpending_list = &sma->sems[semnum].pending_const;\n\n\tlist_for_each_entry_safe(q, tmp, pending_list, list) {\n\t\tint error = perform_atomic_semop(sma, q);\n\n\t\tif (error > 0)\n\t\t\tcontinue;\n\t\t \n\t\tunlink_queue(sma, q);\n\n\t\twake_up_sem_queue_prepare(q, error, wake_q);\n\t\tif (error == 0)\n\t\t\tsemop_completed = 1;\n\t}\n\n\treturn semop_completed;\n}\n\n \nstatic int do_smart_wakeup_zero(struct sem_array *sma, struct sembuf *sops,\n\t\t\t\tint nsops, struct wake_q_head *wake_q)\n{\n\tint i;\n\tint semop_completed = 0;\n\tint got_zero = 0;\n\n\t \n\tif (sops) {\n\t\tfor (i = 0; i < nsops; i++) {\n\t\t\tint num = sops[i].sem_num;\n\n\t\t\tif (sma->sems[num].semval == 0) {\n\t\t\t\tgot_zero = 1;\n\t\t\t\tsemop_completed |= wake_const_ops(sma, num, wake_q);\n\t\t\t}\n\t\t}\n\t} else {\n\t\t \n\t\tfor (i = 0; i < sma->sem_nsems; i++) {\n\t\t\tif (sma->sems[i].semval == 0) {\n\t\t\t\tgot_zero = 1;\n\t\t\t\tsemop_completed |= wake_const_ops(sma, i, wake_q);\n\t\t\t}\n\t\t}\n\t}\n\t \n\tif (got_zero)\n\t\tsemop_completed |= wake_const_ops(sma, -1, wake_q);\n\n\treturn semop_completed;\n}\n\n\n \nstatic int update_queue(struct sem_array *sma, int semnum, struct wake_q_head *wake_q)\n{\n\tstruct sem_queue *q, *tmp;\n\tstruct list_head *pending_list;\n\tint semop_completed = 0;\n\n\tif (semnum == -1)\n\t\tpending_list = &sma->pending_alter;\n\telse\n\t\tpending_list = &sma->sems[semnum].pending_alter;\n\nagain:\n\tlist_for_each_entry_safe(q, tmp, pending_list, list) {\n\t\tint error, restart;\n\n\t\t \n\t\tif (semnum != -1 && sma->sems[semnum].semval == 0)\n\t\t\tbreak;\n\n\t\terror = perform_atomic_semop(sma, q);\n\n\t\t \n\t\tif (error > 0)\n\t\t\tcontinue;\n\n\t\tunlink_queue(sma, q);\n\n\t\tif (error) {\n\t\t\trestart = 0;\n\t\t} else {\n\t\t\tsemop_completed = 1;\n\t\t\tdo_smart_wakeup_zero(sma, q->sops, q->nsops, wake_q);\n\t\t\trestart = check_restart(sma, q);\n\t\t}\n\n\t\twake_up_sem_queue_prepare(q, error, wake_q);\n\t\tif (restart)\n\t\t\tgoto again;\n\t}\n\treturn semop_completed;\n}\n\n \nstatic void set_semotime(struct sem_array *sma, struct sembuf *sops)\n{\n\tif (sops == NULL) {\n\t\tsma->sems[0].sem_otime = ktime_get_real_seconds();\n\t} else {\n\t\tsma->sems[sops[0].sem_num].sem_otime =\n\t\t\t\t\t\tktime_get_real_seconds();\n\t}\n}\n\n \nstatic void do_smart_update(struct sem_array *sma, struct sembuf *sops, int nsops,\n\t\t\t    int otime, struct wake_q_head *wake_q)\n{\n\tint i;\n\n\totime |= do_smart_wakeup_zero(sma, sops, nsops, wake_q);\n\n\tif (!list_empty(&sma->pending_alter)) {\n\t\t \n\t\totime |= update_queue(sma, -1, wake_q);\n\t} else {\n\t\tif (!sops) {\n\t\t\t \n\t\t\tfor (i = 0; i < sma->sem_nsems; i++)\n\t\t\t\totime |= update_queue(sma, i, wake_q);\n\t\t} else {\n\t\t\t \n\t\t\tfor (i = 0; i < nsops; i++) {\n\t\t\t\tif (sops[i].sem_op > 0) {\n\t\t\t\t\totime |= update_queue(sma,\n\t\t\t\t\t\t\t      sops[i].sem_num, wake_q);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (otime)\n\t\tset_semotime(sma, sops);\n}\n\n \nstatic int check_qop(struct sem_array *sma, int semnum, struct sem_queue *q,\n\t\t\tbool count_zero)\n{\n\tstruct sembuf *sop = q->blocking;\n\n\t \n\tpr_info_once(\"semctl(GETNCNT/GETZCNT) is since 3.16 Single Unix Specification compliant.\\n\"\n\t\t\t\"The task %s (%d) triggered the difference, watch for misbehavior.\\n\",\n\t\t\tcurrent->comm, task_pid_nr(current));\n\n\tif (sop->sem_num != semnum)\n\t\treturn 0;\n\n\tif (count_zero && sop->sem_op == 0)\n\t\treturn 1;\n\tif (!count_zero && sop->sem_op < 0)\n\t\treturn 1;\n\n\treturn 0;\n}\n\n \nstatic int count_semcnt(struct sem_array *sma, ushort semnum,\n\t\t\tbool count_zero)\n{\n\tstruct list_head *l;\n\tstruct sem_queue *q;\n\tint semcnt;\n\n\tsemcnt = 0;\n\t \n\tif (count_zero)\n\t\tl = &sma->sems[semnum].pending_const;\n\telse\n\t\tl = &sma->sems[semnum].pending_alter;\n\n\tlist_for_each_entry(q, l, list) {\n\t\t \n\t\tsemcnt++;\n\t}\n\n\t \n\tlist_for_each_entry(q, &sma->pending_alter, list) {\n\t\tsemcnt += check_qop(sma, semnum, q, count_zero);\n\t}\n\tif (count_zero) {\n\t\tlist_for_each_entry(q, &sma->pending_const, list) {\n\t\t\tsemcnt += check_qop(sma, semnum, q, count_zero);\n\t\t}\n\t}\n\treturn semcnt;\n}\n\n \nstatic void freeary(struct ipc_namespace *ns, struct kern_ipc_perm *ipcp)\n{\n\tstruct sem_undo *un, *tu;\n\tstruct sem_queue *q, *tq;\n\tstruct sem_array *sma = container_of(ipcp, struct sem_array, sem_perm);\n\tint i;\n\tDEFINE_WAKE_Q(wake_q);\n\n\t \n\tipc_assert_locked_object(&sma->sem_perm);\n\tlist_for_each_entry_safe(un, tu, &sma->list_id, list_id) {\n\t\tlist_del(&un->list_id);\n\t\tspin_lock(&un->ulp->lock);\n\t\tun->semid = -1;\n\t\tlist_del_rcu(&un->list_proc);\n\t\tspin_unlock(&un->ulp->lock);\n\t\tkvfree_rcu(un, rcu);\n\t}\n\n\t \n\tlist_for_each_entry_safe(q, tq, &sma->pending_const, list) {\n\t\tunlink_queue(sma, q);\n\t\twake_up_sem_queue_prepare(q, -EIDRM, &wake_q);\n\t}\n\n\tlist_for_each_entry_safe(q, tq, &sma->pending_alter, list) {\n\t\tunlink_queue(sma, q);\n\t\twake_up_sem_queue_prepare(q, -EIDRM, &wake_q);\n\t}\n\tfor (i = 0; i < sma->sem_nsems; i++) {\n\t\tstruct sem *sem = &sma->sems[i];\n\t\tlist_for_each_entry_safe(q, tq, &sem->pending_const, list) {\n\t\t\tunlink_queue(sma, q);\n\t\t\twake_up_sem_queue_prepare(q, -EIDRM, &wake_q);\n\t\t}\n\t\tlist_for_each_entry_safe(q, tq, &sem->pending_alter, list) {\n\t\t\tunlink_queue(sma, q);\n\t\t\twake_up_sem_queue_prepare(q, -EIDRM, &wake_q);\n\t\t}\n\t\tipc_update_pid(&sem->sempid, NULL);\n\t}\n\n\t \n\tsem_rmid(ns, sma);\n\tsem_unlock(sma, -1);\n\trcu_read_unlock();\n\n\twake_up_q(&wake_q);\n\tns->used_sems -= sma->sem_nsems;\n\tipc_rcu_putref(&sma->sem_perm, sem_rcu_free);\n}\n\nstatic unsigned long copy_semid_to_user(void __user *buf, struct semid64_ds *in, int version)\n{\n\tswitch (version) {\n\tcase IPC_64:\n\t\treturn copy_to_user(buf, in, sizeof(*in));\n\tcase IPC_OLD:\n\t    {\n\t\tstruct semid_ds out;\n\n\t\tmemset(&out, 0, sizeof(out));\n\n\t\tipc64_perm_to_ipc_perm(&in->sem_perm, &out.sem_perm);\n\n\t\tout.sem_otime\t= in->sem_otime;\n\t\tout.sem_ctime\t= in->sem_ctime;\n\t\tout.sem_nsems\t= in->sem_nsems;\n\n\t\treturn copy_to_user(buf, &out, sizeof(out));\n\t    }\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic time64_t get_semotime(struct sem_array *sma)\n{\n\tint i;\n\ttime64_t res;\n\n\tres = sma->sems[0].sem_otime;\n\tfor (i = 1; i < sma->sem_nsems; i++) {\n\t\ttime64_t to = sma->sems[i].sem_otime;\n\n\t\tif (to > res)\n\t\t\tres = to;\n\t}\n\treturn res;\n}\n\nstatic int semctl_stat(struct ipc_namespace *ns, int semid,\n\t\t\t int cmd, struct semid64_ds *semid64)\n{\n\tstruct sem_array *sma;\n\ttime64_t semotime;\n\tint err;\n\n\tmemset(semid64, 0, sizeof(*semid64));\n\n\trcu_read_lock();\n\tif (cmd == SEM_STAT || cmd == SEM_STAT_ANY) {\n\t\tsma = sem_obtain_object(ns, semid);\n\t\tif (IS_ERR(sma)) {\n\t\t\terr = PTR_ERR(sma);\n\t\t\tgoto out_unlock;\n\t\t}\n\t} else {  \n\t\tsma = sem_obtain_object_check(ns, semid);\n\t\tif (IS_ERR(sma)) {\n\t\t\terr = PTR_ERR(sma);\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\t \n\tif (cmd == SEM_STAT_ANY)\n\t\taudit_ipc_obj(&sma->sem_perm);\n\telse {\n\t\terr = -EACCES;\n\t\tif (ipcperms(ns, &sma->sem_perm, S_IRUGO))\n\t\t\tgoto out_unlock;\n\t}\n\n\terr = security_sem_semctl(&sma->sem_perm, cmd);\n\tif (err)\n\t\tgoto out_unlock;\n\n\tipc_lock_object(&sma->sem_perm);\n\n\tif (!ipc_valid_object(&sma->sem_perm)) {\n\t\tipc_unlock_object(&sma->sem_perm);\n\t\terr = -EIDRM;\n\t\tgoto out_unlock;\n\t}\n\n\tkernel_to_ipc64_perm(&sma->sem_perm, &semid64->sem_perm);\n\tsemotime = get_semotime(sma);\n\tsemid64->sem_otime = semotime;\n\tsemid64->sem_ctime = sma->sem_ctime;\n#ifndef CONFIG_64BIT\n\tsemid64->sem_otime_high = semotime >> 32;\n\tsemid64->sem_ctime_high = sma->sem_ctime >> 32;\n#endif\n\tsemid64->sem_nsems = sma->sem_nsems;\n\n\tif (cmd == IPC_STAT) {\n\t\t \n\t\terr = 0;\n\t} else {\n\t\t \n\t\terr = sma->sem_perm.id;\n\t}\n\tipc_unlock_object(&sma->sem_perm);\nout_unlock:\n\trcu_read_unlock();\n\treturn err;\n}\n\nstatic int semctl_info(struct ipc_namespace *ns, int semid,\n\t\t\t int cmd, void __user *p)\n{\n\tstruct seminfo seminfo;\n\tint max_idx;\n\tint err;\n\n\terr = security_sem_semctl(NULL, cmd);\n\tif (err)\n\t\treturn err;\n\n\tmemset(&seminfo, 0, sizeof(seminfo));\n\tseminfo.semmni = ns->sc_semmni;\n\tseminfo.semmns = ns->sc_semmns;\n\tseminfo.semmsl = ns->sc_semmsl;\n\tseminfo.semopm = ns->sc_semopm;\n\tseminfo.semvmx = SEMVMX;\n\tseminfo.semmnu = SEMMNU;\n\tseminfo.semmap = SEMMAP;\n\tseminfo.semume = SEMUME;\n\tdown_read(&sem_ids(ns).rwsem);\n\tif (cmd == SEM_INFO) {\n\t\tseminfo.semusz = sem_ids(ns).in_use;\n\t\tseminfo.semaem = ns->used_sems;\n\t} else {\n\t\tseminfo.semusz = SEMUSZ;\n\t\tseminfo.semaem = SEMAEM;\n\t}\n\tmax_idx = ipc_get_maxidx(&sem_ids(ns));\n\tup_read(&sem_ids(ns).rwsem);\n\tif (copy_to_user(p, &seminfo, sizeof(struct seminfo)))\n\t\treturn -EFAULT;\n\treturn (max_idx < 0) ? 0 : max_idx;\n}\n\nstatic int semctl_setval(struct ipc_namespace *ns, int semid, int semnum,\n\t\tint val)\n{\n\tstruct sem_undo *un;\n\tstruct sem_array *sma;\n\tstruct sem *curr;\n\tint err;\n\tDEFINE_WAKE_Q(wake_q);\n\n\tif (val > SEMVMX || val < 0)\n\t\treturn -ERANGE;\n\n\trcu_read_lock();\n\tsma = sem_obtain_object_check(ns, semid);\n\tif (IS_ERR(sma)) {\n\t\trcu_read_unlock();\n\t\treturn PTR_ERR(sma);\n\t}\n\n\tif (semnum < 0 || semnum >= sma->sem_nsems) {\n\t\trcu_read_unlock();\n\t\treturn -EINVAL;\n\t}\n\n\n\tif (ipcperms(ns, &sma->sem_perm, S_IWUGO)) {\n\t\trcu_read_unlock();\n\t\treturn -EACCES;\n\t}\n\n\terr = security_sem_semctl(&sma->sem_perm, SETVAL);\n\tif (err) {\n\t\trcu_read_unlock();\n\t\treturn -EACCES;\n\t}\n\n\tsem_lock(sma, NULL, -1);\n\n\tif (!ipc_valid_object(&sma->sem_perm)) {\n\t\tsem_unlock(sma, -1);\n\t\trcu_read_unlock();\n\t\treturn -EIDRM;\n\t}\n\n\tsemnum = array_index_nospec(semnum, sma->sem_nsems);\n\tcurr = &sma->sems[semnum];\n\n\tipc_assert_locked_object(&sma->sem_perm);\n\tlist_for_each_entry(un, &sma->list_id, list_id)\n\t\tun->semadj[semnum] = 0;\n\n\tcurr->semval = val;\n\tipc_update_pid(&curr->sempid, task_tgid(current));\n\tsma->sem_ctime = ktime_get_real_seconds();\n\t \n\tdo_smart_update(sma, NULL, 0, 0, &wake_q);\n\tsem_unlock(sma, -1);\n\trcu_read_unlock();\n\twake_up_q(&wake_q);\n\treturn 0;\n}\n\nstatic int semctl_main(struct ipc_namespace *ns, int semid, int semnum,\n\t\tint cmd, void __user *p)\n{\n\tstruct sem_array *sma;\n\tstruct sem *curr;\n\tint err, nsems;\n\tushort fast_sem_io[SEMMSL_FAST];\n\tushort *sem_io = fast_sem_io;\n\tDEFINE_WAKE_Q(wake_q);\n\n\trcu_read_lock();\n\tsma = sem_obtain_object_check(ns, semid);\n\tif (IS_ERR(sma)) {\n\t\trcu_read_unlock();\n\t\treturn PTR_ERR(sma);\n\t}\n\n\tnsems = sma->sem_nsems;\n\n\terr = -EACCES;\n\tif (ipcperms(ns, &sma->sem_perm, cmd == SETALL ? S_IWUGO : S_IRUGO))\n\t\tgoto out_rcu_wakeup;\n\n\terr = security_sem_semctl(&sma->sem_perm, cmd);\n\tif (err)\n\t\tgoto out_rcu_wakeup;\n\n\tswitch (cmd) {\n\tcase GETALL:\n\t{\n\t\tushort __user *array = p;\n\t\tint i;\n\n\t\tsem_lock(sma, NULL, -1);\n\t\tif (!ipc_valid_object(&sma->sem_perm)) {\n\t\t\terr = -EIDRM;\n\t\t\tgoto out_unlock;\n\t\t}\n\t\tif (nsems > SEMMSL_FAST) {\n\t\t\tif (!ipc_rcu_getref(&sma->sem_perm)) {\n\t\t\t\terr = -EIDRM;\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t\tsem_unlock(sma, -1);\n\t\t\trcu_read_unlock();\n\t\t\tsem_io = kvmalloc_array(nsems, sizeof(ushort),\n\t\t\t\t\t\tGFP_KERNEL);\n\t\t\tif (sem_io == NULL) {\n\t\t\t\tipc_rcu_putref(&sma->sem_perm, sem_rcu_free);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\n\t\t\trcu_read_lock();\n\t\t\tsem_lock_and_putref(sma);\n\t\t\tif (!ipc_valid_object(&sma->sem_perm)) {\n\t\t\t\terr = -EIDRM;\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t}\n\t\tfor (i = 0; i < sma->sem_nsems; i++)\n\t\t\tsem_io[i] = sma->sems[i].semval;\n\t\tsem_unlock(sma, -1);\n\t\trcu_read_unlock();\n\t\terr = 0;\n\t\tif (copy_to_user(array, sem_io, nsems*sizeof(ushort)))\n\t\t\terr = -EFAULT;\n\t\tgoto out_free;\n\t}\n\tcase SETALL:\n\t{\n\t\tint i;\n\t\tstruct sem_undo *un;\n\n\t\tif (!ipc_rcu_getref(&sma->sem_perm)) {\n\t\t\terr = -EIDRM;\n\t\t\tgoto out_rcu_wakeup;\n\t\t}\n\t\trcu_read_unlock();\n\n\t\tif (nsems > SEMMSL_FAST) {\n\t\t\tsem_io = kvmalloc_array(nsems, sizeof(ushort),\n\t\t\t\t\t\tGFP_KERNEL);\n\t\t\tif (sem_io == NULL) {\n\t\t\t\tipc_rcu_putref(&sma->sem_perm, sem_rcu_free);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t}\n\n\t\tif (copy_from_user(sem_io, p, nsems*sizeof(ushort))) {\n\t\t\tipc_rcu_putref(&sma->sem_perm, sem_rcu_free);\n\t\t\terr = -EFAULT;\n\t\t\tgoto out_free;\n\t\t}\n\n\t\tfor (i = 0; i < nsems; i++) {\n\t\t\tif (sem_io[i] > SEMVMX) {\n\t\t\t\tipc_rcu_putref(&sma->sem_perm, sem_rcu_free);\n\t\t\t\terr = -ERANGE;\n\t\t\t\tgoto out_free;\n\t\t\t}\n\t\t}\n\t\trcu_read_lock();\n\t\tsem_lock_and_putref(sma);\n\t\tif (!ipc_valid_object(&sma->sem_perm)) {\n\t\t\terr = -EIDRM;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tfor (i = 0; i < nsems; i++) {\n\t\t\tsma->sems[i].semval = sem_io[i];\n\t\t\tipc_update_pid(&sma->sems[i].sempid, task_tgid(current));\n\t\t}\n\n\t\tipc_assert_locked_object(&sma->sem_perm);\n\t\tlist_for_each_entry(un, &sma->list_id, list_id) {\n\t\t\tfor (i = 0; i < nsems; i++)\n\t\t\t\tun->semadj[i] = 0;\n\t\t}\n\t\tsma->sem_ctime = ktime_get_real_seconds();\n\t\t \n\t\tdo_smart_update(sma, NULL, 0, 0, &wake_q);\n\t\terr = 0;\n\t\tgoto out_unlock;\n\t}\n\t \n\t}\n\terr = -EINVAL;\n\tif (semnum < 0 || semnum >= nsems)\n\t\tgoto out_rcu_wakeup;\n\n\tsem_lock(sma, NULL, -1);\n\tif (!ipc_valid_object(&sma->sem_perm)) {\n\t\terr = -EIDRM;\n\t\tgoto out_unlock;\n\t}\n\n\tsemnum = array_index_nospec(semnum, nsems);\n\tcurr = &sma->sems[semnum];\n\n\tswitch (cmd) {\n\tcase GETVAL:\n\t\terr = curr->semval;\n\t\tgoto out_unlock;\n\tcase GETPID:\n\t\terr = pid_vnr(curr->sempid);\n\t\tgoto out_unlock;\n\tcase GETNCNT:\n\t\terr = count_semcnt(sma, semnum, 0);\n\t\tgoto out_unlock;\n\tcase GETZCNT:\n\t\terr = count_semcnt(sma, semnum, 1);\n\t\tgoto out_unlock;\n\t}\n\nout_unlock:\n\tsem_unlock(sma, -1);\nout_rcu_wakeup:\n\trcu_read_unlock();\n\twake_up_q(&wake_q);\nout_free:\n\tif (sem_io != fast_sem_io)\n\t\tkvfree(sem_io);\n\treturn err;\n}\n\nstatic inline unsigned long\ncopy_semid_from_user(struct semid64_ds *out, void __user *buf, int version)\n{\n\tswitch (version) {\n\tcase IPC_64:\n\t\tif (copy_from_user(out, buf, sizeof(*out)))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\tcase IPC_OLD:\n\t    {\n\t\tstruct semid_ds tbuf_old;\n\n\t\tif (copy_from_user(&tbuf_old, buf, sizeof(tbuf_old)))\n\t\t\treturn -EFAULT;\n\n\t\tout->sem_perm.uid\t= tbuf_old.sem_perm.uid;\n\t\tout->sem_perm.gid\t= tbuf_old.sem_perm.gid;\n\t\tout->sem_perm.mode\t= tbuf_old.sem_perm.mode;\n\n\t\treturn 0;\n\t    }\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\n \nstatic int semctl_down(struct ipc_namespace *ns, int semid,\n\t\t       int cmd, struct semid64_ds *semid64)\n{\n\tstruct sem_array *sma;\n\tint err;\n\tstruct kern_ipc_perm *ipcp;\n\n\tdown_write(&sem_ids(ns).rwsem);\n\trcu_read_lock();\n\n\tipcp = ipcctl_obtain_check(ns, &sem_ids(ns), semid, cmd,\n\t\t\t\t      &semid64->sem_perm, 0);\n\tif (IS_ERR(ipcp)) {\n\t\terr = PTR_ERR(ipcp);\n\t\tgoto out_unlock1;\n\t}\n\n\tsma = container_of(ipcp, struct sem_array, sem_perm);\n\n\terr = security_sem_semctl(&sma->sem_perm, cmd);\n\tif (err)\n\t\tgoto out_unlock1;\n\n\tswitch (cmd) {\n\tcase IPC_RMID:\n\t\tsem_lock(sma, NULL, -1);\n\t\t \n\t\tfreeary(ns, ipcp);\n\t\tgoto out_up;\n\tcase IPC_SET:\n\t\tsem_lock(sma, NULL, -1);\n\t\terr = ipc_update_perm(&semid64->sem_perm, ipcp);\n\t\tif (err)\n\t\t\tgoto out_unlock0;\n\t\tsma->sem_ctime = ktime_get_real_seconds();\n\t\tbreak;\n\tdefault:\n\t\terr = -EINVAL;\n\t\tgoto out_unlock1;\n\t}\n\nout_unlock0:\n\tsem_unlock(sma, -1);\nout_unlock1:\n\trcu_read_unlock();\nout_up:\n\tup_write(&sem_ids(ns).rwsem);\n\treturn err;\n}\n\nstatic long ksys_semctl(int semid, int semnum, int cmd, unsigned long arg, int version)\n{\n\tstruct ipc_namespace *ns;\n\tvoid __user *p = (void __user *)arg;\n\tstruct semid64_ds semid64;\n\tint err;\n\n\tif (semid < 0)\n\t\treturn -EINVAL;\n\n\tns = current->nsproxy->ipc_ns;\n\n\tswitch (cmd) {\n\tcase IPC_INFO:\n\tcase SEM_INFO:\n\t\treturn semctl_info(ns, semid, cmd, p);\n\tcase IPC_STAT:\n\tcase SEM_STAT:\n\tcase SEM_STAT_ANY:\n\t\terr = semctl_stat(ns, semid, cmd, &semid64);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tif (copy_semid_to_user(p, &semid64, version))\n\t\t\terr = -EFAULT;\n\t\treturn err;\n\tcase GETALL:\n\tcase GETVAL:\n\tcase GETPID:\n\tcase GETNCNT:\n\tcase GETZCNT:\n\tcase SETALL:\n\t\treturn semctl_main(ns, semid, semnum, cmd, p);\n\tcase SETVAL: {\n\t\tint val;\n#if defined(CONFIG_64BIT) && defined(__BIG_ENDIAN)\n\t\t \n\t\tval = arg >> 32;\n#else\n\t\t \n\t\tval = arg;\n#endif\n\t\treturn semctl_setval(ns, semid, semnum, val);\n\t}\n\tcase IPC_SET:\n\t\tif (copy_semid_from_user(&semid64, p, version))\n\t\t\treturn -EFAULT;\n\t\tfallthrough;\n\tcase IPC_RMID:\n\t\treturn semctl_down(ns, semid, cmd, &semid64);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nSYSCALL_DEFINE4(semctl, int, semid, int, semnum, int, cmd, unsigned long, arg)\n{\n\treturn ksys_semctl(semid, semnum, cmd, arg, IPC_64);\n}\n\n#ifdef CONFIG_ARCH_WANT_IPC_PARSE_VERSION\nlong ksys_old_semctl(int semid, int semnum, int cmd, unsigned long arg)\n{\n\tint version = ipc_parse_version(&cmd);\n\n\treturn ksys_semctl(semid, semnum, cmd, arg, version);\n}\n\nSYSCALL_DEFINE4(old_semctl, int, semid, int, semnum, int, cmd, unsigned long, arg)\n{\n\treturn ksys_old_semctl(semid, semnum, cmd, arg);\n}\n#endif\n\n#ifdef CONFIG_COMPAT\n\nstruct compat_semid_ds {\n\tstruct compat_ipc_perm sem_perm;\n\told_time32_t sem_otime;\n\told_time32_t sem_ctime;\n\tcompat_uptr_t sem_base;\n\tcompat_uptr_t sem_pending;\n\tcompat_uptr_t sem_pending_last;\n\tcompat_uptr_t undo;\n\tunsigned short sem_nsems;\n};\n\nstatic int copy_compat_semid_from_user(struct semid64_ds *out, void __user *buf,\n\t\t\t\t\tint version)\n{\n\tmemset(out, 0, sizeof(*out));\n\tif (version == IPC_64) {\n\t\tstruct compat_semid64_ds __user *p = buf;\n\t\treturn get_compat_ipc64_perm(&out->sem_perm, &p->sem_perm);\n\t} else {\n\t\tstruct compat_semid_ds __user *p = buf;\n\t\treturn get_compat_ipc_perm(&out->sem_perm, &p->sem_perm);\n\t}\n}\n\nstatic int copy_compat_semid_to_user(void __user *buf, struct semid64_ds *in,\n\t\t\t\t\tint version)\n{\n\tif (version == IPC_64) {\n\t\tstruct compat_semid64_ds v;\n\t\tmemset(&v, 0, sizeof(v));\n\t\tto_compat_ipc64_perm(&v.sem_perm, &in->sem_perm);\n\t\tv.sem_otime\t = lower_32_bits(in->sem_otime);\n\t\tv.sem_otime_high = upper_32_bits(in->sem_otime);\n\t\tv.sem_ctime\t = lower_32_bits(in->sem_ctime);\n\t\tv.sem_ctime_high = upper_32_bits(in->sem_ctime);\n\t\tv.sem_nsems = in->sem_nsems;\n\t\treturn copy_to_user(buf, &v, sizeof(v));\n\t} else {\n\t\tstruct compat_semid_ds v;\n\t\tmemset(&v, 0, sizeof(v));\n\t\tto_compat_ipc_perm(&v.sem_perm, &in->sem_perm);\n\t\tv.sem_otime = in->sem_otime;\n\t\tv.sem_ctime = in->sem_ctime;\n\t\tv.sem_nsems = in->sem_nsems;\n\t\treturn copy_to_user(buf, &v, sizeof(v));\n\t}\n}\n\nstatic long compat_ksys_semctl(int semid, int semnum, int cmd, int arg, int version)\n{\n\tvoid __user *p = compat_ptr(arg);\n\tstruct ipc_namespace *ns;\n\tstruct semid64_ds semid64;\n\tint err;\n\n\tns = current->nsproxy->ipc_ns;\n\n\tif (semid < 0)\n\t\treturn -EINVAL;\n\n\tswitch (cmd & (~IPC_64)) {\n\tcase IPC_INFO:\n\tcase SEM_INFO:\n\t\treturn semctl_info(ns, semid, cmd, p);\n\tcase IPC_STAT:\n\tcase SEM_STAT:\n\tcase SEM_STAT_ANY:\n\t\terr = semctl_stat(ns, semid, cmd, &semid64);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tif (copy_compat_semid_to_user(p, &semid64, version))\n\t\t\terr = -EFAULT;\n\t\treturn err;\n\tcase GETVAL:\n\tcase GETPID:\n\tcase GETNCNT:\n\tcase GETZCNT:\n\tcase GETALL:\n\tcase SETALL:\n\t\treturn semctl_main(ns, semid, semnum, cmd, p);\n\tcase SETVAL:\n\t\treturn semctl_setval(ns, semid, semnum, arg);\n\tcase IPC_SET:\n\t\tif (copy_compat_semid_from_user(&semid64, p, version))\n\t\t\treturn -EFAULT;\n\t\tfallthrough;\n\tcase IPC_RMID:\n\t\treturn semctl_down(ns, semid, cmd, &semid64);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nCOMPAT_SYSCALL_DEFINE4(semctl, int, semid, int, semnum, int, cmd, int, arg)\n{\n\treturn compat_ksys_semctl(semid, semnum, cmd, arg, IPC_64);\n}\n\n#ifdef CONFIG_ARCH_WANT_COMPAT_IPC_PARSE_VERSION\nlong compat_ksys_old_semctl(int semid, int semnum, int cmd, int arg)\n{\n\tint version = compat_ipc_parse_version(&cmd);\n\n\treturn compat_ksys_semctl(semid, semnum, cmd, arg, version);\n}\n\nCOMPAT_SYSCALL_DEFINE4(old_semctl, int, semid, int, semnum, int, cmd, int, arg)\n{\n\treturn compat_ksys_old_semctl(semid, semnum, cmd, arg);\n}\n#endif\n#endif\n\n \nstatic inline int get_undo_list(struct sem_undo_list **undo_listp)\n{\n\tstruct sem_undo_list *undo_list;\n\n\tundo_list = current->sysvsem.undo_list;\n\tif (!undo_list) {\n\t\tundo_list = kzalloc(sizeof(*undo_list), GFP_KERNEL_ACCOUNT);\n\t\tif (undo_list == NULL)\n\t\t\treturn -ENOMEM;\n\t\tspin_lock_init(&undo_list->lock);\n\t\trefcount_set(&undo_list->refcnt, 1);\n\t\tINIT_LIST_HEAD(&undo_list->list_proc);\n\n\t\tcurrent->sysvsem.undo_list = undo_list;\n\t}\n\t*undo_listp = undo_list;\n\treturn 0;\n}\n\nstatic struct sem_undo *__lookup_undo(struct sem_undo_list *ulp, int semid)\n{\n\tstruct sem_undo *un;\n\n\tlist_for_each_entry_rcu(un, &ulp->list_proc, list_proc,\n\t\t\t\tspin_is_locked(&ulp->lock)) {\n\t\tif (un->semid == semid)\n\t\t\treturn un;\n\t}\n\treturn NULL;\n}\n\nstatic struct sem_undo *lookup_undo(struct sem_undo_list *ulp, int semid)\n{\n\tstruct sem_undo *un;\n\n\tassert_spin_locked(&ulp->lock);\n\n\tun = __lookup_undo(ulp, semid);\n\tif (un) {\n\t\tlist_del_rcu(&un->list_proc);\n\t\tlist_add_rcu(&un->list_proc, &ulp->list_proc);\n\t}\n\treturn un;\n}\n\n \nstatic struct sem_undo *find_alloc_undo(struct ipc_namespace *ns, int semid)\n{\n\tstruct sem_array *sma;\n\tstruct sem_undo_list *ulp;\n\tstruct sem_undo *un, *new;\n\tint nsems, error;\n\n\terror = get_undo_list(&ulp);\n\tif (error)\n\t\treturn ERR_PTR(error);\n\n\trcu_read_lock();\n\tspin_lock(&ulp->lock);\n\tun = lookup_undo(ulp, semid);\n\tspin_unlock(&ulp->lock);\n\tif (likely(un != NULL))\n\t\tgoto out;\n\n\t \n\t \n\tsma = sem_obtain_object_check(ns, semid);\n\tif (IS_ERR(sma)) {\n\t\trcu_read_unlock();\n\t\treturn ERR_CAST(sma);\n\t}\n\n\tnsems = sma->sem_nsems;\n\tif (!ipc_rcu_getref(&sma->sem_perm)) {\n\t\trcu_read_unlock();\n\t\tun = ERR_PTR(-EIDRM);\n\t\tgoto out;\n\t}\n\trcu_read_unlock();\n\n\t \n\tnew = kvzalloc(struct_size(new, semadj, nsems), GFP_KERNEL_ACCOUNT);\n\tif (!new) {\n\t\tipc_rcu_putref(&sma->sem_perm, sem_rcu_free);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\t \n\trcu_read_lock();\n\tsem_lock_and_putref(sma);\n\tif (!ipc_valid_object(&sma->sem_perm)) {\n\t\tsem_unlock(sma, -1);\n\t\trcu_read_unlock();\n\t\tkvfree(new);\n\t\tun = ERR_PTR(-EIDRM);\n\t\tgoto out;\n\t}\n\tspin_lock(&ulp->lock);\n\n\t \n\tun = lookup_undo(ulp, semid);\n\tif (un) {\n\t\tspin_unlock(&ulp->lock);\n\t\tkvfree(new);\n\t\tgoto success;\n\t}\n\t \n\tnew->ulp = ulp;\n\tnew->semid = semid;\n\tassert_spin_locked(&ulp->lock);\n\tlist_add_rcu(&new->list_proc, &ulp->list_proc);\n\tipc_assert_locked_object(&sma->sem_perm);\n\tlist_add(&new->list_id, &sma->list_id);\n\tun = new;\n\tspin_unlock(&ulp->lock);\nsuccess:\n\tsem_unlock(sma, -1);\nout:\n\treturn un;\n}\n\nlong __do_semtimedop(int semid, struct sembuf *sops,\n\t\tunsigned nsops, const struct timespec64 *timeout,\n\t\tstruct ipc_namespace *ns)\n{\n\tint error = -EINVAL;\n\tstruct sem_array *sma;\n\tstruct sembuf *sop;\n\tstruct sem_undo *un;\n\tint max, locknum;\n\tbool undos = false, alter = false, dupsop = false;\n\tstruct sem_queue queue;\n\tunsigned long dup = 0;\n\tktime_t expires, *exp = NULL;\n\tbool timed_out = false;\n\n\tif (nsops < 1 || semid < 0)\n\t\treturn -EINVAL;\n\tif (nsops > ns->sc_semopm)\n\t\treturn -E2BIG;\n\n\tif (timeout) {\n\t\tif (!timespec64_valid(timeout))\n\t\t\treturn -EINVAL;\n\t\texpires = ktime_add_safe(ktime_get(),\n\t\t\t\ttimespec64_to_ktime(*timeout));\n\t\texp = &expires;\n\t}\n\n\n\tmax = 0;\n\tfor (sop = sops; sop < sops + nsops; sop++) {\n\t\tunsigned long mask = 1ULL << ((sop->sem_num) % BITS_PER_LONG);\n\n\t\tif (sop->sem_num >= max)\n\t\t\tmax = sop->sem_num;\n\t\tif (sop->sem_flg & SEM_UNDO)\n\t\t\tundos = true;\n\t\tif (dup & mask) {\n\t\t\t \n\t\t\tdupsop = true;\n\t\t}\n\t\tif (sop->sem_op != 0) {\n\t\t\talter = true;\n\t\t\tdup |= mask;\n\t\t}\n\t}\n\n\tif (undos) {\n\t\t \n\t\tun = find_alloc_undo(ns, semid);\n\t\tif (IS_ERR(un)) {\n\t\t\terror = PTR_ERR(un);\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\tun = NULL;\n\t\trcu_read_lock();\n\t}\n\n\tsma = sem_obtain_object_check(ns, semid);\n\tif (IS_ERR(sma)) {\n\t\trcu_read_unlock();\n\t\terror = PTR_ERR(sma);\n\t\tgoto out;\n\t}\n\n\terror = -EFBIG;\n\tif (max >= sma->sem_nsems) {\n\t\trcu_read_unlock();\n\t\tgoto out;\n\t}\n\n\terror = -EACCES;\n\tif (ipcperms(ns, &sma->sem_perm, alter ? S_IWUGO : S_IRUGO)) {\n\t\trcu_read_unlock();\n\t\tgoto out;\n\t}\n\n\terror = security_sem_semop(&sma->sem_perm, sops, nsops, alter);\n\tif (error) {\n\t\trcu_read_unlock();\n\t\tgoto out;\n\t}\n\n\terror = -EIDRM;\n\tlocknum = sem_lock(sma, sops, nsops);\n\t \n\tif (!ipc_valid_object(&sma->sem_perm))\n\t\tgoto out_unlock;\n\t \n\tif (un && un->semid == -1)\n\t\tgoto out_unlock;\n\n\tqueue.sops = sops;\n\tqueue.nsops = nsops;\n\tqueue.undo = un;\n\tqueue.pid = task_tgid(current);\n\tqueue.alter = alter;\n\tqueue.dupsop = dupsop;\n\n\terror = perform_atomic_semop(sma, &queue);\n\tif (error == 0) {  \n\t\tDEFINE_WAKE_Q(wake_q);\n\n\t\t \n\t\tif (alter)\n\t\t\tdo_smart_update(sma, sops, nsops, 1, &wake_q);\n\t\telse\n\t\t\tset_semotime(sma, sops);\n\n\t\tsem_unlock(sma, locknum);\n\t\trcu_read_unlock();\n\t\twake_up_q(&wake_q);\n\n\t\tgoto out;\n\t}\n\tif (error < 0)  \n\t\tgoto out_unlock;\n\n\t \n\tif (nsops == 1) {\n\t\tstruct sem *curr;\n\t\tint idx = array_index_nospec(sops->sem_num, sma->sem_nsems);\n\t\tcurr = &sma->sems[idx];\n\n\t\tif (alter) {\n\t\t\tif (sma->complex_count) {\n\t\t\t\tlist_add_tail(&queue.list,\n\t\t\t\t\t\t&sma->pending_alter);\n\t\t\t} else {\n\n\t\t\t\tlist_add_tail(&queue.list,\n\t\t\t\t\t\t&curr->pending_alter);\n\t\t\t}\n\t\t} else {\n\t\t\tlist_add_tail(&queue.list, &curr->pending_const);\n\t\t}\n\t} else {\n\t\tif (!sma->complex_count)\n\t\t\tmerge_queues(sma);\n\n\t\tif (alter)\n\t\t\tlist_add_tail(&queue.list, &sma->pending_alter);\n\t\telse\n\t\t\tlist_add_tail(&queue.list, &sma->pending_const);\n\n\t\tsma->complex_count++;\n\t}\n\n\tdo {\n\t\t \n\t\tWRITE_ONCE(queue.status, -EINTR);\n\t\tqueue.sleeper = current;\n\n\t\t \n\t\t__set_current_state(TASK_INTERRUPTIBLE);\n\t\tsem_unlock(sma, locknum);\n\t\trcu_read_unlock();\n\n\t\ttimed_out = !schedule_hrtimeout_range(exp,\n\t\t\t\tcurrent->timer_slack_ns, HRTIMER_MODE_ABS);\n\n\t\t \n\t\trcu_read_lock();\n\t\terror = READ_ONCE(queue.status);\n\t\tif (error != -EINTR) {\n\t\t\t \n\t\t\tsmp_acquire__after_ctrl_dep();\n\t\t\trcu_read_unlock();\n\t\t\tgoto out;\n\t\t}\n\n\t\tlocknum = sem_lock(sma, sops, nsops);\n\n\t\tif (!ipc_valid_object(&sma->sem_perm))\n\t\t\tgoto out_unlock;\n\n\t\t \n\t\terror = READ_ONCE(queue.status);\n\n\t\t \n\t\tif (error != -EINTR)\n\t\t\tgoto out_unlock;\n\n\t\t \n\t\tif (timed_out)\n\t\t\terror = -EAGAIN;\n\t} while (error == -EINTR && !signal_pending(current));  \n\n\tunlink_queue(sma, &queue);\n\nout_unlock:\n\tsem_unlock(sma, locknum);\n\trcu_read_unlock();\nout:\n\treturn error;\n}\n\nstatic long do_semtimedop(int semid, struct sembuf __user *tsops,\n\t\tunsigned nsops, const struct timespec64 *timeout)\n{\n\tstruct sembuf fast_sops[SEMOPM_FAST];\n\tstruct sembuf *sops = fast_sops;\n\tstruct ipc_namespace *ns;\n\tint ret;\n\n\tns = current->nsproxy->ipc_ns;\n\tif (nsops > ns->sc_semopm)\n\t\treturn -E2BIG;\n\tif (nsops < 1)\n\t\treturn -EINVAL;\n\n\tif (nsops > SEMOPM_FAST) {\n\t\tsops = kvmalloc_array(nsops, sizeof(*sops), GFP_KERNEL);\n\t\tif (sops == NULL)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tif (copy_from_user(sops, tsops, nsops * sizeof(*tsops))) {\n\t\tret =  -EFAULT;\n\t\tgoto out_free;\n\t}\n\n\tret = __do_semtimedop(semid, sops, nsops, timeout, ns);\n\nout_free:\n\tif (sops != fast_sops)\n\t\tkvfree(sops);\n\n\treturn ret;\n}\n\nlong ksys_semtimedop(int semid, struct sembuf __user *tsops,\n\t\t     unsigned int nsops, const struct __kernel_timespec __user *timeout)\n{\n\tif (timeout) {\n\t\tstruct timespec64 ts;\n\t\tif (get_timespec64(&ts, timeout))\n\t\t\treturn -EFAULT;\n\t\treturn do_semtimedop(semid, tsops, nsops, &ts);\n\t}\n\treturn do_semtimedop(semid, tsops, nsops, NULL);\n}\n\nSYSCALL_DEFINE4(semtimedop, int, semid, struct sembuf __user *, tsops,\n\t\tunsigned int, nsops, const struct __kernel_timespec __user *, timeout)\n{\n\treturn ksys_semtimedop(semid, tsops, nsops, timeout);\n}\n\n#ifdef CONFIG_COMPAT_32BIT_TIME\nlong compat_ksys_semtimedop(int semid, struct sembuf __user *tsems,\n\t\t\t    unsigned int nsops,\n\t\t\t    const struct old_timespec32 __user *timeout)\n{\n\tif (timeout) {\n\t\tstruct timespec64 ts;\n\t\tif (get_old_timespec32(&ts, timeout))\n\t\t\treturn -EFAULT;\n\t\treturn do_semtimedop(semid, tsems, nsops, &ts);\n\t}\n\treturn do_semtimedop(semid, tsems, nsops, NULL);\n}\n\nSYSCALL_DEFINE4(semtimedop_time32, int, semid, struct sembuf __user *, tsems,\n\t\t       unsigned int, nsops,\n\t\t       const struct old_timespec32 __user *, timeout)\n{\n\treturn compat_ksys_semtimedop(semid, tsems, nsops, timeout);\n}\n#endif\n\nSYSCALL_DEFINE3(semop, int, semid, struct sembuf __user *, tsops,\n\t\tunsigned, nsops)\n{\n\treturn do_semtimedop(semid, tsops, nsops, NULL);\n}\n\n \n\nint copy_semundo(unsigned long clone_flags, struct task_struct *tsk)\n{\n\tstruct sem_undo_list *undo_list;\n\tint error;\n\n\tif (clone_flags & CLONE_SYSVSEM) {\n\t\terror = get_undo_list(&undo_list);\n\t\tif (error)\n\t\t\treturn error;\n\t\trefcount_inc(&undo_list->refcnt);\n\t\ttsk->sysvsem.undo_list = undo_list;\n\t} else\n\t\ttsk->sysvsem.undo_list = NULL;\n\n\treturn 0;\n}\n\n \nvoid exit_sem(struct task_struct *tsk)\n{\n\tstruct sem_undo_list *ulp;\n\n\tulp = tsk->sysvsem.undo_list;\n\tif (!ulp)\n\t\treturn;\n\ttsk->sysvsem.undo_list = NULL;\n\n\tif (!refcount_dec_and_test(&ulp->refcnt))\n\t\treturn;\n\n\tfor (;;) {\n\t\tstruct sem_array *sma;\n\t\tstruct sem_undo *un;\n\t\tint semid, i;\n\t\tDEFINE_WAKE_Q(wake_q);\n\n\t\tcond_resched();\n\n\t\trcu_read_lock();\n\t\tun = list_entry_rcu(ulp->list_proc.next,\n\t\t\t\t    struct sem_undo, list_proc);\n\t\tif (&un->list_proc == &ulp->list_proc) {\n\t\t\t \n\t\t\tspin_lock(&ulp->lock);\n\t\t\tspin_unlock(&ulp->lock);\n\t\t\trcu_read_unlock();\n\t\t\tbreak;\n\t\t}\n\t\tspin_lock(&ulp->lock);\n\t\tsemid = un->semid;\n\t\tspin_unlock(&ulp->lock);\n\n\t\t \n\t\tif (semid == -1) {\n\t\t\trcu_read_unlock();\n\t\t\tcontinue;\n\t\t}\n\n\t\tsma = sem_obtain_object_check(tsk->nsproxy->ipc_ns, semid);\n\t\t \n\t\tif (IS_ERR(sma)) {\n\t\t\trcu_read_unlock();\n\t\t\tcontinue;\n\t\t}\n\n\t\tsem_lock(sma, NULL, -1);\n\t\t \n\t\tif (!ipc_valid_object(&sma->sem_perm)) {\n\t\t\tsem_unlock(sma, -1);\n\t\t\trcu_read_unlock();\n\t\t\tcontinue;\n\t\t}\n\t\tun = __lookup_undo(ulp, semid);\n\t\tif (un == NULL) {\n\t\t\t \n\t\t\tsem_unlock(sma, -1);\n\t\t\trcu_read_unlock();\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tipc_assert_locked_object(&sma->sem_perm);\n\t\tlist_del(&un->list_id);\n\n\t\tspin_lock(&ulp->lock);\n\t\tlist_del_rcu(&un->list_proc);\n\t\tspin_unlock(&ulp->lock);\n\n\t\t \n\t\tfor (i = 0; i < sma->sem_nsems; i++) {\n\t\t\tstruct sem *semaphore = &sma->sems[i];\n\t\t\tif (un->semadj[i]) {\n\t\t\t\tsemaphore->semval += un->semadj[i];\n\t\t\t\t \n\t\t\t\tif (semaphore->semval < 0)\n\t\t\t\t\tsemaphore->semval = 0;\n\t\t\t\tif (semaphore->semval > SEMVMX)\n\t\t\t\t\tsemaphore->semval = SEMVMX;\n\t\t\t\tipc_update_pid(&semaphore->sempid, task_tgid(current));\n\t\t\t}\n\t\t}\n\t\t \n\t\tdo_smart_update(sma, NULL, 0, 1, &wake_q);\n\t\tsem_unlock(sma, -1);\n\t\trcu_read_unlock();\n\t\twake_up_q(&wake_q);\n\n\t\tkvfree_rcu(un, rcu);\n\t}\n\tkfree(ulp);\n}\n\n#ifdef CONFIG_PROC_FS\nstatic int sysvipc_sem_proc_show(struct seq_file *s, void *it)\n{\n\tstruct user_namespace *user_ns = seq_user_ns(s);\n\tstruct kern_ipc_perm *ipcp = it;\n\tstruct sem_array *sma = container_of(ipcp, struct sem_array, sem_perm);\n\ttime64_t sem_otime;\n\n\t \n\tcomplexmode_enter(sma);\n\n\tsem_otime = get_semotime(sma);\n\n\tseq_printf(s,\n\t\t   \"%10d %10d  %4o %10u %5u %5u %5u %5u %10llu %10llu\\n\",\n\t\t   sma->sem_perm.key,\n\t\t   sma->sem_perm.id,\n\t\t   sma->sem_perm.mode,\n\t\t   sma->sem_nsems,\n\t\t   from_kuid_munged(user_ns, sma->sem_perm.uid),\n\t\t   from_kgid_munged(user_ns, sma->sem_perm.gid),\n\t\t   from_kuid_munged(user_ns, sma->sem_perm.cuid),\n\t\t   from_kgid_munged(user_ns, sma->sem_perm.cgid),\n\t\t   sem_otime,\n\t\t   sma->sem_ctime);\n\n\tcomplexmode_tryleave(sma);\n\n\treturn 0;\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}