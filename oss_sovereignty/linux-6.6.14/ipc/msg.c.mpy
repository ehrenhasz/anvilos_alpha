{
  "module_name": "msg.c",
  "hash_id": "e5341ec65f68073a4be3f55c00fda85f0a9a3b0cc9ee4b1ed047b9d9f13a837b",
  "original_prompt": "Ingested from linux-6.6.14/ipc/msg.c",
  "human_readable_source": "\n \n\n#include <linux/capability.h>\n#include <linux/msg.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/proc_fs.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <linux/sched/wake_q.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/seq_file.h>\n#include <linux/rwsem.h>\n#include <linux/nsproxy.h>\n#include <linux/ipc_namespace.h>\n#include <linux/rhashtable.h>\n#include <linux/percpu_counter.h>\n\n#include <asm/current.h>\n#include <linux/uaccess.h>\n#include \"util.h\"\n\n \nstruct msg_queue {\n\tstruct kern_ipc_perm q_perm;\n\ttime64_t q_stime;\t\t \n\ttime64_t q_rtime;\t\t \n\ttime64_t q_ctime;\t\t \n\tunsigned long q_cbytes;\t\t \n\tunsigned long q_qnum;\t\t \n\tunsigned long q_qbytes;\t\t \n\tstruct pid *q_lspid;\t\t \n\tstruct pid *q_lrpid;\t\t \n\n\tstruct list_head q_messages;\n\tstruct list_head q_receivers;\n\tstruct list_head q_senders;\n} __randomize_layout;\n\n \n\n \nstruct msg_receiver {\n\tstruct list_head\tr_list;\n\tstruct task_struct\t*r_tsk;\n\n\tint\t\t\tr_mode;\n\tlong\t\t\tr_msgtype;\n\tlong\t\t\tr_maxsize;\n\n\tstruct msg_msg\t\t*r_msg;\n};\n\n \nstruct msg_sender {\n\tstruct list_head\tlist;\n\tstruct task_struct\t*tsk;\n\tsize_t                  msgsz;\n};\n\n#define SEARCH_ANY\t\t1\n#define SEARCH_EQUAL\t\t2\n#define SEARCH_NOTEQUAL\t\t3\n#define SEARCH_LESSEQUAL\t4\n#define SEARCH_NUMBER\t\t5\n\n#define msg_ids(ns)\t((ns)->ids[IPC_MSG_IDS])\n\nstatic inline struct msg_queue *msq_obtain_object(struct ipc_namespace *ns, int id)\n{\n\tstruct kern_ipc_perm *ipcp = ipc_obtain_object_idr(&msg_ids(ns), id);\n\n\tif (IS_ERR(ipcp))\n\t\treturn ERR_CAST(ipcp);\n\n\treturn container_of(ipcp, struct msg_queue, q_perm);\n}\n\nstatic inline struct msg_queue *msq_obtain_object_check(struct ipc_namespace *ns,\n\t\t\t\t\t\t\tint id)\n{\n\tstruct kern_ipc_perm *ipcp = ipc_obtain_object_check(&msg_ids(ns), id);\n\n\tif (IS_ERR(ipcp))\n\t\treturn ERR_CAST(ipcp);\n\n\treturn container_of(ipcp, struct msg_queue, q_perm);\n}\n\nstatic inline void msg_rmid(struct ipc_namespace *ns, struct msg_queue *s)\n{\n\tipc_rmid(&msg_ids(ns), &s->q_perm);\n}\n\nstatic void msg_rcu_free(struct rcu_head *head)\n{\n\tstruct kern_ipc_perm *p = container_of(head, struct kern_ipc_perm, rcu);\n\tstruct msg_queue *msq = container_of(p, struct msg_queue, q_perm);\n\n\tsecurity_msg_queue_free(&msq->q_perm);\n\tkfree(msq);\n}\n\n \nstatic int newque(struct ipc_namespace *ns, struct ipc_params *params)\n{\n\tstruct msg_queue *msq;\n\tint retval;\n\tkey_t key = params->key;\n\tint msgflg = params->flg;\n\n\tmsq = kmalloc(sizeof(*msq), GFP_KERNEL_ACCOUNT);\n\tif (unlikely(!msq))\n\t\treturn -ENOMEM;\n\n\tmsq->q_perm.mode = msgflg & S_IRWXUGO;\n\tmsq->q_perm.key = key;\n\n\tmsq->q_perm.security = NULL;\n\tretval = security_msg_queue_alloc(&msq->q_perm);\n\tif (retval) {\n\t\tkfree(msq);\n\t\treturn retval;\n\t}\n\n\tmsq->q_stime = msq->q_rtime = 0;\n\tmsq->q_ctime = ktime_get_real_seconds();\n\tmsq->q_cbytes = msq->q_qnum = 0;\n\tmsq->q_qbytes = ns->msg_ctlmnb;\n\tmsq->q_lspid = msq->q_lrpid = NULL;\n\tINIT_LIST_HEAD(&msq->q_messages);\n\tINIT_LIST_HEAD(&msq->q_receivers);\n\tINIT_LIST_HEAD(&msq->q_senders);\n\n\t \n\tretval = ipc_addid(&msg_ids(ns), &msq->q_perm, ns->msg_ctlmni);\n\tif (retval < 0) {\n\t\tipc_rcu_putref(&msq->q_perm, msg_rcu_free);\n\t\treturn retval;\n\t}\n\n\tipc_unlock_object(&msq->q_perm);\n\trcu_read_unlock();\n\n\treturn msq->q_perm.id;\n}\n\nstatic inline bool msg_fits_inqueue(struct msg_queue *msq, size_t msgsz)\n{\n\treturn msgsz + msq->q_cbytes <= msq->q_qbytes &&\n\t\t1 + msq->q_qnum <= msq->q_qbytes;\n}\n\nstatic inline void ss_add(struct msg_queue *msq,\n\t\t\t  struct msg_sender *mss, size_t msgsz)\n{\n\tmss->tsk = current;\n\tmss->msgsz = msgsz;\n\t \n\t__set_current_state(TASK_INTERRUPTIBLE);\n\tlist_add_tail(&mss->list, &msq->q_senders);\n}\n\nstatic inline void ss_del(struct msg_sender *mss)\n{\n\tif (mss->list.next)\n\t\tlist_del(&mss->list);\n}\n\nstatic void ss_wakeup(struct msg_queue *msq,\n\t\t      struct wake_q_head *wake_q, bool kill)\n{\n\tstruct msg_sender *mss, *t;\n\tstruct task_struct *stop_tsk = NULL;\n\tstruct list_head *h = &msq->q_senders;\n\n\tlist_for_each_entry_safe(mss, t, h, list) {\n\t\tif (kill)\n\t\t\tmss->list.next = NULL;\n\n\t\t \n\t\telse if (stop_tsk == mss->tsk)\n\t\t\tbreak;\n\t\t \n\t\telse if (!msg_fits_inqueue(msq, mss->msgsz)) {\n\t\t\tif (!stop_tsk)\n\t\t\t\tstop_tsk = mss->tsk;\n\n\t\t\tlist_move_tail(&mss->list, &msq->q_senders);\n\t\t\tcontinue;\n\t\t}\n\n\t\twake_q_add(wake_q, mss->tsk);\n\t}\n}\n\nstatic void expunge_all(struct msg_queue *msq, int res,\n\t\t\tstruct wake_q_head *wake_q)\n{\n\tstruct msg_receiver *msr, *t;\n\n\tlist_for_each_entry_safe(msr, t, &msq->q_receivers, r_list) {\n\t\tstruct task_struct *r_tsk;\n\n\t\tr_tsk = get_task_struct(msr->r_tsk);\n\n\t\t \n\t\tsmp_store_release(&msr->r_msg, ERR_PTR(res));\n\t\twake_q_add_safe(wake_q, r_tsk);\n\t}\n}\n\n \nstatic void freeque(struct ipc_namespace *ns, struct kern_ipc_perm *ipcp)\n\t__releases(RCU)\n\t__releases(&msq->q_perm)\n{\n\tstruct msg_msg *msg, *t;\n\tstruct msg_queue *msq = container_of(ipcp, struct msg_queue, q_perm);\n\tDEFINE_WAKE_Q(wake_q);\n\n\texpunge_all(msq, -EIDRM, &wake_q);\n\tss_wakeup(msq, &wake_q, true);\n\tmsg_rmid(ns, msq);\n\tipc_unlock_object(&msq->q_perm);\n\twake_up_q(&wake_q);\n\trcu_read_unlock();\n\n\tlist_for_each_entry_safe(msg, t, &msq->q_messages, m_list) {\n\t\tpercpu_counter_sub_local(&ns->percpu_msg_hdrs, 1);\n\t\tfree_msg(msg);\n\t}\n\tpercpu_counter_sub_local(&ns->percpu_msg_bytes, msq->q_cbytes);\n\tipc_update_pid(&msq->q_lspid, NULL);\n\tipc_update_pid(&msq->q_lrpid, NULL);\n\tipc_rcu_putref(&msq->q_perm, msg_rcu_free);\n}\n\nlong ksys_msgget(key_t key, int msgflg)\n{\n\tstruct ipc_namespace *ns;\n\tstatic const struct ipc_ops msg_ops = {\n\t\t.getnew = newque,\n\t\t.associate = security_msg_queue_associate,\n\t};\n\tstruct ipc_params msg_params;\n\n\tns = current->nsproxy->ipc_ns;\n\n\tmsg_params.key = key;\n\tmsg_params.flg = msgflg;\n\n\treturn ipcget(ns, &msg_ids(ns), &msg_ops, &msg_params);\n}\n\nSYSCALL_DEFINE2(msgget, key_t, key, int, msgflg)\n{\n\treturn ksys_msgget(key, msgflg);\n}\n\nstatic inline unsigned long\ncopy_msqid_to_user(void __user *buf, struct msqid64_ds *in, int version)\n{\n\tswitch (version) {\n\tcase IPC_64:\n\t\treturn copy_to_user(buf, in, sizeof(*in));\n\tcase IPC_OLD:\n\t{\n\t\tstruct msqid_ds out;\n\n\t\tmemset(&out, 0, sizeof(out));\n\n\t\tipc64_perm_to_ipc_perm(&in->msg_perm, &out.msg_perm);\n\n\t\tout.msg_stime\t\t= in->msg_stime;\n\t\tout.msg_rtime\t\t= in->msg_rtime;\n\t\tout.msg_ctime\t\t= in->msg_ctime;\n\n\t\tif (in->msg_cbytes > USHRT_MAX)\n\t\t\tout.msg_cbytes\t= USHRT_MAX;\n\t\telse\n\t\t\tout.msg_cbytes\t= in->msg_cbytes;\n\t\tout.msg_lcbytes\t\t= in->msg_cbytes;\n\n\t\tif (in->msg_qnum > USHRT_MAX)\n\t\t\tout.msg_qnum\t= USHRT_MAX;\n\t\telse\n\t\t\tout.msg_qnum\t= in->msg_qnum;\n\n\t\tif (in->msg_qbytes > USHRT_MAX)\n\t\t\tout.msg_qbytes\t= USHRT_MAX;\n\t\telse\n\t\t\tout.msg_qbytes\t= in->msg_qbytes;\n\t\tout.msg_lqbytes\t\t= in->msg_qbytes;\n\n\t\tout.msg_lspid\t\t= in->msg_lspid;\n\t\tout.msg_lrpid\t\t= in->msg_lrpid;\n\n\t\treturn copy_to_user(buf, &out, sizeof(out));\n\t}\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic inline unsigned long\ncopy_msqid_from_user(struct msqid64_ds *out, void __user *buf, int version)\n{\n\tswitch (version) {\n\tcase IPC_64:\n\t\tif (copy_from_user(out, buf, sizeof(*out)))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\tcase IPC_OLD:\n\t{\n\t\tstruct msqid_ds tbuf_old;\n\n\t\tif (copy_from_user(&tbuf_old, buf, sizeof(tbuf_old)))\n\t\t\treturn -EFAULT;\n\n\t\tout->msg_perm.uid\t= tbuf_old.msg_perm.uid;\n\t\tout->msg_perm.gid\t= tbuf_old.msg_perm.gid;\n\t\tout->msg_perm.mode\t= tbuf_old.msg_perm.mode;\n\n\t\tif (tbuf_old.msg_qbytes == 0)\n\t\t\tout->msg_qbytes\t= tbuf_old.msg_lqbytes;\n\t\telse\n\t\t\tout->msg_qbytes\t= tbuf_old.msg_qbytes;\n\n\t\treturn 0;\n\t}\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\n \nstatic int msgctl_down(struct ipc_namespace *ns, int msqid, int cmd,\n\t\t\tstruct ipc64_perm *perm, int msg_qbytes)\n{\n\tstruct kern_ipc_perm *ipcp;\n\tstruct msg_queue *msq;\n\tint err;\n\n\tdown_write(&msg_ids(ns).rwsem);\n\trcu_read_lock();\n\n\tipcp = ipcctl_obtain_check(ns, &msg_ids(ns), msqid, cmd,\n\t\t\t\t      perm, msg_qbytes);\n\tif (IS_ERR(ipcp)) {\n\t\terr = PTR_ERR(ipcp);\n\t\tgoto out_unlock1;\n\t}\n\n\tmsq = container_of(ipcp, struct msg_queue, q_perm);\n\n\terr = security_msg_queue_msgctl(&msq->q_perm, cmd);\n\tif (err)\n\t\tgoto out_unlock1;\n\n\tswitch (cmd) {\n\tcase IPC_RMID:\n\t\tipc_lock_object(&msq->q_perm);\n\t\t \n\t\tfreeque(ns, ipcp);\n\t\tgoto out_up;\n\tcase IPC_SET:\n\t{\n\t\tDEFINE_WAKE_Q(wake_q);\n\n\t\tif (msg_qbytes > ns->msg_ctlmnb &&\n\t\t    !capable(CAP_SYS_RESOURCE)) {\n\t\t\terr = -EPERM;\n\t\t\tgoto out_unlock1;\n\t\t}\n\n\t\tipc_lock_object(&msq->q_perm);\n\t\terr = ipc_update_perm(perm, ipcp);\n\t\tif (err)\n\t\t\tgoto out_unlock0;\n\n\t\tmsq->q_qbytes = msg_qbytes;\n\n\t\tmsq->q_ctime = ktime_get_real_seconds();\n\t\t \n\t\texpunge_all(msq, -EAGAIN, &wake_q);\n\t\t \n\t\tss_wakeup(msq, &wake_q, false);\n\t\tipc_unlock_object(&msq->q_perm);\n\t\twake_up_q(&wake_q);\n\n\t\tgoto out_unlock1;\n\t}\n\tdefault:\n\t\terr = -EINVAL;\n\t\tgoto out_unlock1;\n\t}\n\nout_unlock0:\n\tipc_unlock_object(&msq->q_perm);\nout_unlock1:\n\trcu_read_unlock();\nout_up:\n\tup_write(&msg_ids(ns).rwsem);\n\treturn err;\n}\n\nstatic int msgctl_info(struct ipc_namespace *ns, int msqid,\n\t\t\t int cmd, struct msginfo *msginfo)\n{\n\tint err;\n\tint max_idx;\n\n\t \n\terr = security_msg_queue_msgctl(NULL, cmd);\n\tif (err)\n\t\treturn err;\n\n\tmemset(msginfo, 0, sizeof(*msginfo));\n\tmsginfo->msgmni = ns->msg_ctlmni;\n\tmsginfo->msgmax = ns->msg_ctlmax;\n\tmsginfo->msgmnb = ns->msg_ctlmnb;\n\tmsginfo->msgssz = MSGSSZ;\n\tmsginfo->msgseg = MSGSEG;\n\tdown_read(&msg_ids(ns).rwsem);\n\tif (cmd == MSG_INFO)\n\t\tmsginfo->msgpool = msg_ids(ns).in_use;\n\tmax_idx = ipc_get_maxidx(&msg_ids(ns));\n\tup_read(&msg_ids(ns).rwsem);\n\tif (cmd == MSG_INFO) {\n\t\tmsginfo->msgmap = min_t(int,\n\t\t\t\t     percpu_counter_sum(&ns->percpu_msg_hdrs),\n\t\t\t\t     INT_MAX);\n\t\tmsginfo->msgtql = min_t(int,\n\t\t                     percpu_counter_sum(&ns->percpu_msg_bytes),\n\t\t\t\t     INT_MAX);\n\t} else {\n\t\tmsginfo->msgmap = MSGMAP;\n\t\tmsginfo->msgpool = MSGPOOL;\n\t\tmsginfo->msgtql = MSGTQL;\n\t}\n\treturn (max_idx < 0) ? 0 : max_idx;\n}\n\nstatic int msgctl_stat(struct ipc_namespace *ns, int msqid,\n\t\t\t int cmd, struct msqid64_ds *p)\n{\n\tstruct msg_queue *msq;\n\tint err;\n\n\tmemset(p, 0, sizeof(*p));\n\n\trcu_read_lock();\n\tif (cmd == MSG_STAT || cmd == MSG_STAT_ANY) {\n\t\tmsq = msq_obtain_object(ns, msqid);\n\t\tif (IS_ERR(msq)) {\n\t\t\terr = PTR_ERR(msq);\n\t\t\tgoto out_unlock;\n\t\t}\n\t} else {  \n\t\tmsq = msq_obtain_object_check(ns, msqid);\n\t\tif (IS_ERR(msq)) {\n\t\t\terr = PTR_ERR(msq);\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\t \n\tif (cmd == MSG_STAT_ANY)\n\t\taudit_ipc_obj(&msq->q_perm);\n\telse {\n\t\terr = -EACCES;\n\t\tif (ipcperms(ns, &msq->q_perm, S_IRUGO))\n\t\t\tgoto out_unlock;\n\t}\n\n\terr = security_msg_queue_msgctl(&msq->q_perm, cmd);\n\tif (err)\n\t\tgoto out_unlock;\n\n\tipc_lock_object(&msq->q_perm);\n\n\tif (!ipc_valid_object(&msq->q_perm)) {\n\t\tipc_unlock_object(&msq->q_perm);\n\t\terr = -EIDRM;\n\t\tgoto out_unlock;\n\t}\n\n\tkernel_to_ipc64_perm(&msq->q_perm, &p->msg_perm);\n\tp->msg_stime  = msq->q_stime;\n\tp->msg_rtime  = msq->q_rtime;\n\tp->msg_ctime  = msq->q_ctime;\n#ifndef CONFIG_64BIT\n\tp->msg_stime_high = msq->q_stime >> 32;\n\tp->msg_rtime_high = msq->q_rtime >> 32;\n\tp->msg_ctime_high = msq->q_ctime >> 32;\n#endif\n\tp->msg_cbytes = msq->q_cbytes;\n\tp->msg_qnum   = msq->q_qnum;\n\tp->msg_qbytes = msq->q_qbytes;\n\tp->msg_lspid  = pid_vnr(msq->q_lspid);\n\tp->msg_lrpid  = pid_vnr(msq->q_lrpid);\n\n\tif (cmd == IPC_STAT) {\n\t\t \n\t\terr = 0;\n\t} else {\n\t\t \n\t\terr = msq->q_perm.id;\n\t}\n\n\tipc_unlock_object(&msq->q_perm);\nout_unlock:\n\trcu_read_unlock();\n\treturn err;\n}\n\nstatic long ksys_msgctl(int msqid, int cmd, struct msqid_ds __user *buf, int version)\n{\n\tstruct ipc_namespace *ns;\n\tstruct msqid64_ds msqid64;\n\tint err;\n\n\tif (msqid < 0 || cmd < 0)\n\t\treturn -EINVAL;\n\n\tns = current->nsproxy->ipc_ns;\n\n\tswitch (cmd) {\n\tcase IPC_INFO:\n\tcase MSG_INFO: {\n\t\tstruct msginfo msginfo;\n\t\terr = msgctl_info(ns, msqid, cmd, &msginfo);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tif (copy_to_user(buf, &msginfo, sizeof(struct msginfo)))\n\t\t\terr = -EFAULT;\n\t\treturn err;\n\t}\n\tcase MSG_STAT:\t \n\tcase MSG_STAT_ANY:\n\tcase IPC_STAT:\n\t\terr = msgctl_stat(ns, msqid, cmd, &msqid64);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tif (copy_msqid_to_user(buf, &msqid64, version))\n\t\t\terr = -EFAULT;\n\t\treturn err;\n\tcase IPC_SET:\n\t\tif (copy_msqid_from_user(&msqid64, buf, version))\n\t\t\treturn -EFAULT;\n\t\treturn msgctl_down(ns, msqid, cmd, &msqid64.msg_perm,\n\t\t\t\t   msqid64.msg_qbytes);\n\tcase IPC_RMID:\n\t\treturn msgctl_down(ns, msqid, cmd, NULL, 0);\n\tdefault:\n\t\treturn  -EINVAL;\n\t}\n}\n\nSYSCALL_DEFINE3(msgctl, int, msqid, int, cmd, struct msqid_ds __user *, buf)\n{\n\treturn ksys_msgctl(msqid, cmd, buf, IPC_64);\n}\n\n#ifdef CONFIG_ARCH_WANT_IPC_PARSE_VERSION\nlong ksys_old_msgctl(int msqid, int cmd, struct msqid_ds __user *buf)\n{\n\tint version = ipc_parse_version(&cmd);\n\n\treturn ksys_msgctl(msqid, cmd, buf, version);\n}\n\nSYSCALL_DEFINE3(old_msgctl, int, msqid, int, cmd, struct msqid_ds __user *, buf)\n{\n\treturn ksys_old_msgctl(msqid, cmd, buf);\n}\n#endif\n\n#ifdef CONFIG_COMPAT\n\nstruct compat_msqid_ds {\n\tstruct compat_ipc_perm msg_perm;\n\tcompat_uptr_t msg_first;\n\tcompat_uptr_t msg_last;\n\told_time32_t msg_stime;\n\told_time32_t msg_rtime;\n\told_time32_t msg_ctime;\n\tcompat_ulong_t msg_lcbytes;\n\tcompat_ulong_t msg_lqbytes;\n\tunsigned short msg_cbytes;\n\tunsigned short msg_qnum;\n\tunsigned short msg_qbytes;\n\tcompat_ipc_pid_t msg_lspid;\n\tcompat_ipc_pid_t msg_lrpid;\n};\n\nstatic int copy_compat_msqid_from_user(struct msqid64_ds *out, void __user *buf,\n\t\t\t\t\tint version)\n{\n\tmemset(out, 0, sizeof(*out));\n\tif (version == IPC_64) {\n\t\tstruct compat_msqid64_ds __user *p = buf;\n\t\tif (get_compat_ipc64_perm(&out->msg_perm, &p->msg_perm))\n\t\t\treturn -EFAULT;\n\t\tif (get_user(out->msg_qbytes, &p->msg_qbytes))\n\t\t\treturn -EFAULT;\n\t} else {\n\t\tstruct compat_msqid_ds __user *p = buf;\n\t\tif (get_compat_ipc_perm(&out->msg_perm, &p->msg_perm))\n\t\t\treturn -EFAULT;\n\t\tif (get_user(out->msg_qbytes, &p->msg_qbytes))\n\t\t\treturn -EFAULT;\n\t}\n\treturn 0;\n}\n\nstatic int copy_compat_msqid_to_user(void __user *buf, struct msqid64_ds *in,\n\t\t\t\t\tint version)\n{\n\tif (version == IPC_64) {\n\t\tstruct compat_msqid64_ds v;\n\t\tmemset(&v, 0, sizeof(v));\n\t\tto_compat_ipc64_perm(&v.msg_perm, &in->msg_perm);\n\t\tv.msg_stime\t = lower_32_bits(in->msg_stime);\n\t\tv.msg_stime_high = upper_32_bits(in->msg_stime);\n\t\tv.msg_rtime\t = lower_32_bits(in->msg_rtime);\n\t\tv.msg_rtime_high = upper_32_bits(in->msg_rtime);\n\t\tv.msg_ctime\t = lower_32_bits(in->msg_ctime);\n\t\tv.msg_ctime_high = upper_32_bits(in->msg_ctime);\n\t\tv.msg_cbytes = in->msg_cbytes;\n\t\tv.msg_qnum = in->msg_qnum;\n\t\tv.msg_qbytes = in->msg_qbytes;\n\t\tv.msg_lspid = in->msg_lspid;\n\t\tv.msg_lrpid = in->msg_lrpid;\n\t\treturn copy_to_user(buf, &v, sizeof(v));\n\t} else {\n\t\tstruct compat_msqid_ds v;\n\t\tmemset(&v, 0, sizeof(v));\n\t\tto_compat_ipc_perm(&v.msg_perm, &in->msg_perm);\n\t\tv.msg_stime = in->msg_stime;\n\t\tv.msg_rtime = in->msg_rtime;\n\t\tv.msg_ctime = in->msg_ctime;\n\t\tv.msg_cbytes = in->msg_cbytes;\n\t\tv.msg_qnum = in->msg_qnum;\n\t\tv.msg_qbytes = in->msg_qbytes;\n\t\tv.msg_lspid = in->msg_lspid;\n\t\tv.msg_lrpid = in->msg_lrpid;\n\t\treturn copy_to_user(buf, &v, sizeof(v));\n\t}\n}\n\nstatic long compat_ksys_msgctl(int msqid, int cmd, void __user *uptr, int version)\n{\n\tstruct ipc_namespace *ns;\n\tint err;\n\tstruct msqid64_ds msqid64;\n\n\tns = current->nsproxy->ipc_ns;\n\n\tif (msqid < 0 || cmd < 0)\n\t\treturn -EINVAL;\n\n\tswitch (cmd & (~IPC_64)) {\n\tcase IPC_INFO:\n\tcase MSG_INFO: {\n\t\tstruct msginfo msginfo;\n\t\terr = msgctl_info(ns, msqid, cmd, &msginfo);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tif (copy_to_user(uptr, &msginfo, sizeof(struct msginfo)))\n\t\t\terr = -EFAULT;\n\t\treturn err;\n\t}\n\tcase IPC_STAT:\n\tcase MSG_STAT:\n\tcase MSG_STAT_ANY:\n\t\terr = msgctl_stat(ns, msqid, cmd, &msqid64);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tif (copy_compat_msqid_to_user(uptr, &msqid64, version))\n\t\t\terr = -EFAULT;\n\t\treturn err;\n\tcase IPC_SET:\n\t\tif (copy_compat_msqid_from_user(&msqid64, uptr, version))\n\t\t\treturn -EFAULT;\n\t\treturn msgctl_down(ns, msqid, cmd, &msqid64.msg_perm, msqid64.msg_qbytes);\n\tcase IPC_RMID:\n\t\treturn msgctl_down(ns, msqid, cmd, NULL, 0);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nCOMPAT_SYSCALL_DEFINE3(msgctl, int, msqid, int, cmd, void __user *, uptr)\n{\n\treturn compat_ksys_msgctl(msqid, cmd, uptr, IPC_64);\n}\n\n#ifdef CONFIG_ARCH_WANT_COMPAT_IPC_PARSE_VERSION\nlong compat_ksys_old_msgctl(int msqid, int cmd, void __user *uptr)\n{\n\tint version = compat_ipc_parse_version(&cmd);\n\n\treturn compat_ksys_msgctl(msqid, cmd, uptr, version);\n}\n\nCOMPAT_SYSCALL_DEFINE3(old_msgctl, int, msqid, int, cmd, void __user *, uptr)\n{\n\treturn compat_ksys_old_msgctl(msqid, cmd, uptr);\n}\n#endif\n#endif\n\nstatic int testmsg(struct msg_msg *msg, long type, int mode)\n{\n\tswitch (mode) {\n\tcase SEARCH_ANY:\n\tcase SEARCH_NUMBER:\n\t\treturn 1;\n\tcase SEARCH_LESSEQUAL:\n\t\tif (msg->m_type <= type)\n\t\t\treturn 1;\n\t\tbreak;\n\tcase SEARCH_EQUAL:\n\t\tif (msg->m_type == type)\n\t\t\treturn 1;\n\t\tbreak;\n\tcase SEARCH_NOTEQUAL:\n\t\tif (msg->m_type != type)\n\t\t\treturn 1;\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic inline int pipelined_send(struct msg_queue *msq, struct msg_msg *msg,\n\t\t\t\t struct wake_q_head *wake_q)\n{\n\tstruct msg_receiver *msr, *t;\n\n\tlist_for_each_entry_safe(msr, t, &msq->q_receivers, r_list) {\n\t\tif (testmsg(msg, msr->r_msgtype, msr->r_mode) &&\n\t\t    !security_msg_queue_msgrcv(&msq->q_perm, msg, msr->r_tsk,\n\t\t\t\t\t       msr->r_msgtype, msr->r_mode)) {\n\n\t\t\tlist_del(&msr->r_list);\n\t\t\tif (msr->r_maxsize < msg->m_ts) {\n\t\t\t\twake_q_add(wake_q, msr->r_tsk);\n\n\t\t\t\t \n\t\t\t\tsmp_store_release(&msr->r_msg, ERR_PTR(-E2BIG));\n\t\t\t} else {\n\t\t\t\tipc_update_pid(&msq->q_lrpid, task_pid(msr->r_tsk));\n\t\t\t\tmsq->q_rtime = ktime_get_real_seconds();\n\n\t\t\t\twake_q_add(wake_q, msr->r_tsk);\n\n\t\t\t\t \n\t\t\t\tsmp_store_release(&msr->r_msg, msg);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic long do_msgsnd(int msqid, long mtype, void __user *mtext,\n\t\tsize_t msgsz, int msgflg)\n{\n\tstruct msg_queue *msq;\n\tstruct msg_msg *msg;\n\tint err;\n\tstruct ipc_namespace *ns;\n\tDEFINE_WAKE_Q(wake_q);\n\n\tns = current->nsproxy->ipc_ns;\n\n\tif (msgsz > ns->msg_ctlmax || (long) msgsz < 0 || msqid < 0)\n\t\treturn -EINVAL;\n\tif (mtype < 1)\n\t\treturn -EINVAL;\n\n\tmsg = load_msg(mtext, msgsz);\n\tif (IS_ERR(msg))\n\t\treturn PTR_ERR(msg);\n\n\tmsg->m_type = mtype;\n\tmsg->m_ts = msgsz;\n\n\trcu_read_lock();\n\tmsq = msq_obtain_object_check(ns, msqid);\n\tif (IS_ERR(msq)) {\n\t\terr = PTR_ERR(msq);\n\t\tgoto out_unlock1;\n\t}\n\n\tipc_lock_object(&msq->q_perm);\n\n\tfor (;;) {\n\t\tstruct msg_sender s;\n\n\t\terr = -EACCES;\n\t\tif (ipcperms(ns, &msq->q_perm, S_IWUGO))\n\t\t\tgoto out_unlock0;\n\n\t\t \n\t\tif (!ipc_valid_object(&msq->q_perm)) {\n\t\t\terr = -EIDRM;\n\t\t\tgoto out_unlock0;\n\t\t}\n\n\t\terr = security_msg_queue_msgsnd(&msq->q_perm, msg, msgflg);\n\t\tif (err)\n\t\t\tgoto out_unlock0;\n\n\t\tif (msg_fits_inqueue(msq, msgsz))\n\t\t\tbreak;\n\n\t\t \n\t\tif (msgflg & IPC_NOWAIT) {\n\t\t\terr = -EAGAIN;\n\t\t\tgoto out_unlock0;\n\t\t}\n\n\t\t \n\t\tss_add(msq, &s, msgsz);\n\n\t\tif (!ipc_rcu_getref(&msq->q_perm)) {\n\t\t\terr = -EIDRM;\n\t\t\tgoto out_unlock0;\n\t\t}\n\n\t\tipc_unlock_object(&msq->q_perm);\n\t\trcu_read_unlock();\n\t\tschedule();\n\n\t\trcu_read_lock();\n\t\tipc_lock_object(&msq->q_perm);\n\n\t\tipc_rcu_putref(&msq->q_perm, msg_rcu_free);\n\t\t \n\t\tif (!ipc_valid_object(&msq->q_perm)) {\n\t\t\terr = -EIDRM;\n\t\t\tgoto out_unlock0;\n\t\t}\n\t\tss_del(&s);\n\n\t\tif (signal_pending(current)) {\n\t\t\terr = -ERESTARTNOHAND;\n\t\t\tgoto out_unlock0;\n\t\t}\n\n\t}\n\n\tipc_update_pid(&msq->q_lspid, task_tgid(current));\n\tmsq->q_stime = ktime_get_real_seconds();\n\n\tif (!pipelined_send(msq, msg, &wake_q)) {\n\t\t \n\t\tlist_add_tail(&msg->m_list, &msq->q_messages);\n\t\tmsq->q_cbytes += msgsz;\n\t\tmsq->q_qnum++;\n\t\tpercpu_counter_add_local(&ns->percpu_msg_bytes, msgsz);\n\t\tpercpu_counter_add_local(&ns->percpu_msg_hdrs, 1);\n\t}\n\n\terr = 0;\n\tmsg = NULL;\n\nout_unlock0:\n\tipc_unlock_object(&msq->q_perm);\n\twake_up_q(&wake_q);\nout_unlock1:\n\trcu_read_unlock();\n\tif (msg != NULL)\n\t\tfree_msg(msg);\n\treturn err;\n}\n\nlong ksys_msgsnd(int msqid, struct msgbuf __user *msgp, size_t msgsz,\n\t\t int msgflg)\n{\n\tlong mtype;\n\n\tif (get_user(mtype, &msgp->mtype))\n\t\treturn -EFAULT;\n\treturn do_msgsnd(msqid, mtype, msgp->mtext, msgsz, msgflg);\n}\n\nSYSCALL_DEFINE4(msgsnd, int, msqid, struct msgbuf __user *, msgp, size_t, msgsz,\n\t\tint, msgflg)\n{\n\treturn ksys_msgsnd(msqid, msgp, msgsz, msgflg);\n}\n\n#ifdef CONFIG_COMPAT\n\nstruct compat_msgbuf {\n\tcompat_long_t mtype;\n\tchar mtext[1];\n};\n\nlong compat_ksys_msgsnd(int msqid, compat_uptr_t msgp,\n\t\t       compat_ssize_t msgsz, int msgflg)\n{\n\tstruct compat_msgbuf __user *up = compat_ptr(msgp);\n\tcompat_long_t mtype;\n\n\tif (get_user(mtype, &up->mtype))\n\t\treturn -EFAULT;\n\treturn do_msgsnd(msqid, mtype, up->mtext, (ssize_t)msgsz, msgflg);\n}\n\nCOMPAT_SYSCALL_DEFINE4(msgsnd, int, msqid, compat_uptr_t, msgp,\n\t\t       compat_ssize_t, msgsz, int, msgflg)\n{\n\treturn compat_ksys_msgsnd(msqid, msgp, msgsz, msgflg);\n}\n#endif\n\nstatic inline int convert_mode(long *msgtyp, int msgflg)\n{\n\tif (msgflg & MSG_COPY)\n\t\treturn SEARCH_NUMBER;\n\t \n\tif (*msgtyp == 0)\n\t\treturn SEARCH_ANY;\n\tif (*msgtyp < 0) {\n\t\tif (*msgtyp == LONG_MIN)  \n\t\t\t*msgtyp = LONG_MAX;\n\t\telse\n\t\t\t*msgtyp = -*msgtyp;\n\t\treturn SEARCH_LESSEQUAL;\n\t}\n\tif (msgflg & MSG_EXCEPT)\n\t\treturn SEARCH_NOTEQUAL;\n\treturn SEARCH_EQUAL;\n}\n\nstatic long do_msg_fill(void __user *dest, struct msg_msg *msg, size_t bufsz)\n{\n\tstruct msgbuf __user *msgp = dest;\n\tsize_t msgsz;\n\n\tif (put_user(msg->m_type, &msgp->mtype))\n\t\treturn -EFAULT;\n\n\tmsgsz = (bufsz > msg->m_ts) ? msg->m_ts : bufsz;\n\tif (store_msg(msgp->mtext, msg, msgsz))\n\t\treturn -EFAULT;\n\treturn msgsz;\n}\n\n#ifdef CONFIG_CHECKPOINT_RESTORE\n \nstatic inline struct msg_msg *prepare_copy(void __user *buf, size_t bufsz)\n{\n\tstruct msg_msg *copy;\n\n\t \n\tcopy = load_msg(buf, bufsz);\n\tif (!IS_ERR(copy))\n\t\tcopy->m_ts = bufsz;\n\treturn copy;\n}\n\nstatic inline void free_copy(struct msg_msg *copy)\n{\n\tif (copy)\n\t\tfree_msg(copy);\n}\n#else\nstatic inline struct msg_msg *prepare_copy(void __user *buf, size_t bufsz)\n{\n\treturn ERR_PTR(-ENOSYS);\n}\n\nstatic inline void free_copy(struct msg_msg *copy)\n{\n}\n#endif\n\nstatic struct msg_msg *find_msg(struct msg_queue *msq, long *msgtyp, int mode)\n{\n\tstruct msg_msg *msg, *found = NULL;\n\tlong count = 0;\n\n\tlist_for_each_entry(msg, &msq->q_messages, m_list) {\n\t\tif (testmsg(msg, *msgtyp, mode) &&\n\t\t    !security_msg_queue_msgrcv(&msq->q_perm, msg, current,\n\t\t\t\t\t       *msgtyp, mode)) {\n\t\t\tif (mode == SEARCH_LESSEQUAL && msg->m_type != 1) {\n\t\t\t\t*msgtyp = msg->m_type - 1;\n\t\t\t\tfound = msg;\n\t\t\t} else if (mode == SEARCH_NUMBER) {\n\t\t\t\tif (*msgtyp == count)\n\t\t\t\t\treturn msg;\n\t\t\t} else\n\t\t\t\treturn msg;\n\t\t\tcount++;\n\t\t}\n\t}\n\n\treturn found ?: ERR_PTR(-EAGAIN);\n}\n\nstatic long do_msgrcv(int msqid, void __user *buf, size_t bufsz, long msgtyp, int msgflg,\n\t       long (*msg_handler)(void __user *, struct msg_msg *, size_t))\n{\n\tint mode;\n\tstruct msg_queue *msq;\n\tstruct ipc_namespace *ns;\n\tstruct msg_msg *msg, *copy = NULL;\n\tDEFINE_WAKE_Q(wake_q);\n\n\tns = current->nsproxy->ipc_ns;\n\n\tif (msqid < 0 || (long) bufsz < 0)\n\t\treturn -EINVAL;\n\n\tif (msgflg & MSG_COPY) {\n\t\tif ((msgflg & MSG_EXCEPT) || !(msgflg & IPC_NOWAIT))\n\t\t\treturn -EINVAL;\n\t\tcopy = prepare_copy(buf, min_t(size_t, bufsz, ns->msg_ctlmax));\n\t\tif (IS_ERR(copy))\n\t\t\treturn PTR_ERR(copy);\n\t}\n\tmode = convert_mode(&msgtyp, msgflg);\n\n\trcu_read_lock();\n\tmsq = msq_obtain_object_check(ns, msqid);\n\tif (IS_ERR(msq)) {\n\t\trcu_read_unlock();\n\t\tfree_copy(copy);\n\t\treturn PTR_ERR(msq);\n\t}\n\n\tfor (;;) {\n\t\tstruct msg_receiver msr_d;\n\n\t\tmsg = ERR_PTR(-EACCES);\n\t\tif (ipcperms(ns, &msq->q_perm, S_IRUGO))\n\t\t\tgoto out_unlock1;\n\n\t\tipc_lock_object(&msq->q_perm);\n\n\t\t \n\t\tif (!ipc_valid_object(&msq->q_perm)) {\n\t\t\tmsg = ERR_PTR(-EIDRM);\n\t\t\tgoto out_unlock0;\n\t\t}\n\n\t\tmsg = find_msg(msq, &msgtyp, mode);\n\t\tif (!IS_ERR(msg)) {\n\t\t\t \n\t\t\tif ((bufsz < msg->m_ts) && !(msgflg & MSG_NOERROR)) {\n\t\t\t\tmsg = ERR_PTR(-E2BIG);\n\t\t\t\tgoto out_unlock0;\n\t\t\t}\n\t\t\t \n\t\t\tif (msgflg & MSG_COPY) {\n\t\t\t\tmsg = copy_msg(msg, copy);\n\t\t\t\tgoto out_unlock0;\n\t\t\t}\n\n\t\t\tlist_del(&msg->m_list);\n\t\t\tmsq->q_qnum--;\n\t\t\tmsq->q_rtime = ktime_get_real_seconds();\n\t\t\tipc_update_pid(&msq->q_lrpid, task_tgid(current));\n\t\t\tmsq->q_cbytes -= msg->m_ts;\n\t\t\tpercpu_counter_sub_local(&ns->percpu_msg_bytes, msg->m_ts);\n\t\t\tpercpu_counter_sub_local(&ns->percpu_msg_hdrs, 1);\n\t\t\tss_wakeup(msq, &wake_q, false);\n\n\t\t\tgoto out_unlock0;\n\t\t}\n\n\t\t \n\t\tif (msgflg & IPC_NOWAIT) {\n\t\t\tmsg = ERR_PTR(-ENOMSG);\n\t\t\tgoto out_unlock0;\n\t\t}\n\n\t\tlist_add_tail(&msr_d.r_list, &msq->q_receivers);\n\t\tmsr_d.r_tsk = current;\n\t\tmsr_d.r_msgtype = msgtyp;\n\t\tmsr_d.r_mode = mode;\n\t\tif (msgflg & MSG_NOERROR)\n\t\t\tmsr_d.r_maxsize = INT_MAX;\n\t\telse\n\t\t\tmsr_d.r_maxsize = bufsz;\n\n\t\t \n\t\tWRITE_ONCE(msr_d.r_msg, ERR_PTR(-EAGAIN));\n\n\t\t \n\t\t__set_current_state(TASK_INTERRUPTIBLE);\n\n\t\tipc_unlock_object(&msq->q_perm);\n\t\trcu_read_unlock();\n\t\tschedule();\n\n\t\t \n\t\trcu_read_lock();\n\n\t\t \n\t\tmsg = READ_ONCE(msr_d.r_msg);\n\t\tif (msg != ERR_PTR(-EAGAIN)) {\n\t\t\t \n\t\t\tsmp_acquire__after_ctrl_dep();\n\n\t\t\tgoto out_unlock1;\n\t\t}\n\n\t\t  \n\t\tipc_lock_object(&msq->q_perm);\n\n\t\tmsg = READ_ONCE(msr_d.r_msg);\n\t\tif (msg != ERR_PTR(-EAGAIN))\n\t\t\tgoto out_unlock0;\n\n\t\tlist_del(&msr_d.r_list);\n\t\tif (signal_pending(current)) {\n\t\t\tmsg = ERR_PTR(-ERESTARTNOHAND);\n\t\t\tgoto out_unlock0;\n\t\t}\n\n\t\tipc_unlock_object(&msq->q_perm);\n\t}\n\nout_unlock0:\n\tipc_unlock_object(&msq->q_perm);\n\twake_up_q(&wake_q);\nout_unlock1:\n\trcu_read_unlock();\n\tif (IS_ERR(msg)) {\n\t\tfree_copy(copy);\n\t\treturn PTR_ERR(msg);\n\t}\n\n\tbufsz = msg_handler(buf, msg, bufsz);\n\tfree_msg(msg);\n\n\treturn bufsz;\n}\n\nlong ksys_msgrcv(int msqid, struct msgbuf __user *msgp, size_t msgsz,\n\t\t long msgtyp, int msgflg)\n{\n\treturn do_msgrcv(msqid, msgp, msgsz, msgtyp, msgflg, do_msg_fill);\n}\n\nSYSCALL_DEFINE5(msgrcv, int, msqid, struct msgbuf __user *, msgp, size_t, msgsz,\n\t\tlong, msgtyp, int, msgflg)\n{\n\treturn ksys_msgrcv(msqid, msgp, msgsz, msgtyp, msgflg);\n}\n\n#ifdef CONFIG_COMPAT\nstatic long compat_do_msg_fill(void __user *dest, struct msg_msg *msg, size_t bufsz)\n{\n\tstruct compat_msgbuf __user *msgp = dest;\n\tsize_t msgsz;\n\n\tif (put_user(msg->m_type, &msgp->mtype))\n\t\treturn -EFAULT;\n\n\tmsgsz = (bufsz > msg->m_ts) ? msg->m_ts : bufsz;\n\tif (store_msg(msgp->mtext, msg, msgsz))\n\t\treturn -EFAULT;\n\treturn msgsz;\n}\n\nlong compat_ksys_msgrcv(int msqid, compat_uptr_t msgp, compat_ssize_t msgsz,\n\t\t\tcompat_long_t msgtyp, int msgflg)\n{\n\treturn do_msgrcv(msqid, compat_ptr(msgp), (ssize_t)msgsz, (long)msgtyp,\n\t\t\t msgflg, compat_do_msg_fill);\n}\n\nCOMPAT_SYSCALL_DEFINE5(msgrcv, int, msqid, compat_uptr_t, msgp,\n\t\t       compat_ssize_t, msgsz, compat_long_t, msgtyp,\n\t\t       int, msgflg)\n{\n\treturn compat_ksys_msgrcv(msqid, msgp, msgsz, msgtyp, msgflg);\n}\n#endif\n\nint msg_init_ns(struct ipc_namespace *ns)\n{\n\tint ret;\n\n\tns->msg_ctlmax = MSGMAX;\n\tns->msg_ctlmnb = MSGMNB;\n\tns->msg_ctlmni = MSGMNI;\n\n\tret = percpu_counter_init(&ns->percpu_msg_bytes, 0, GFP_KERNEL);\n\tif (ret)\n\t\tgoto fail_msg_bytes;\n\tret = percpu_counter_init(&ns->percpu_msg_hdrs, 0, GFP_KERNEL);\n\tif (ret)\n\t\tgoto fail_msg_hdrs;\n\tipc_init_ids(&ns->ids[IPC_MSG_IDS]);\n\treturn 0;\n\nfail_msg_hdrs:\n\tpercpu_counter_destroy(&ns->percpu_msg_bytes);\nfail_msg_bytes:\n\treturn ret;\n}\n\n#ifdef CONFIG_IPC_NS\nvoid msg_exit_ns(struct ipc_namespace *ns)\n{\n\tfree_ipcs(ns, &msg_ids(ns), freeque);\n\tidr_destroy(&ns->ids[IPC_MSG_IDS].ipcs_idr);\n\trhashtable_destroy(&ns->ids[IPC_MSG_IDS].key_ht);\n\tpercpu_counter_destroy(&ns->percpu_msg_bytes);\n\tpercpu_counter_destroy(&ns->percpu_msg_hdrs);\n}\n#endif\n\n#ifdef CONFIG_PROC_FS\nstatic int sysvipc_msg_proc_show(struct seq_file *s, void *it)\n{\n\tstruct pid_namespace *pid_ns = ipc_seq_pid_ns(s);\n\tstruct user_namespace *user_ns = seq_user_ns(s);\n\tstruct kern_ipc_perm *ipcp = it;\n\tstruct msg_queue *msq = container_of(ipcp, struct msg_queue, q_perm);\n\n\tseq_printf(s,\n\t\t   \"%10d %10d  %4o  %10lu %10lu %5u %5u %5u %5u %5u %5u %10llu %10llu %10llu\\n\",\n\t\t   msq->q_perm.key,\n\t\t   msq->q_perm.id,\n\t\t   msq->q_perm.mode,\n\t\t   msq->q_cbytes,\n\t\t   msq->q_qnum,\n\t\t   pid_nr_ns(msq->q_lspid, pid_ns),\n\t\t   pid_nr_ns(msq->q_lrpid, pid_ns),\n\t\t   from_kuid_munged(user_ns, msq->q_perm.uid),\n\t\t   from_kgid_munged(user_ns, msq->q_perm.gid),\n\t\t   from_kuid_munged(user_ns, msq->q_perm.cuid),\n\t\t   from_kgid_munged(user_ns, msq->q_perm.cgid),\n\t\t   msq->q_stime,\n\t\t   msq->q_rtime,\n\t\t   msq->q_ctime);\n\n\treturn 0;\n}\n#endif\n\nvoid __init msg_init(void)\n{\n\tmsg_init_ns(&init_ipc_ns);\n\n\tipc_init_proc_interface(\"sysvipc/msg\",\n\t\t\t\t\"       key      msqid perms      cbytes       qnum lspid lrpid   uid   gid  cuid  cgid      stime      rtime      ctime\\n\",\n\t\t\t\tIPC_MSG_IDS, sysvipc_msg_proc_show);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}