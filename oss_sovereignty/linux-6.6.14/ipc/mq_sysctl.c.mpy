{
  "module_name": "mq_sysctl.c",
  "hash_id": "ec9197e6e5d43c55c7195cbd6a8df5ed6620ded3131c300210343bf99a82e3ea",
  "original_prompt": "Ingested from linux-6.6.14/ipc/mq_sysctl.c",
  "human_readable_source": "\n \n\n#include <linux/nsproxy.h>\n#include <linux/ipc_namespace.h>\n#include <linux/sysctl.h>\n\n#include <linux/stat.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n\nstatic int msg_max_limit_min = MIN_MSGMAX;\nstatic int msg_max_limit_max = HARD_MSGMAX;\n\nstatic int msg_maxsize_limit_min = MIN_MSGSIZEMAX;\nstatic int msg_maxsize_limit_max = HARD_MSGSIZEMAX;\n\nstatic struct ctl_table mq_sysctls[] = {\n\t{\n\t\t.procname\t= \"queues_max\",\n\t\t.data\t\t= &init_ipc_ns.mq_queues_max,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n\t{\n\t\t.procname\t= \"msg_max\",\n\t\t.data\t\t= &init_ipc_ns.mq_msg_max,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= &msg_max_limit_min,\n\t\t.extra2\t\t= &msg_max_limit_max,\n\t},\n\t{\n\t\t.procname\t= \"msgsize_max\",\n\t\t.data\t\t= &init_ipc_ns.mq_msgsize_max,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= &msg_maxsize_limit_min,\n\t\t.extra2\t\t= &msg_maxsize_limit_max,\n\t},\n\t{\n\t\t.procname\t= \"msg_default\",\n\t\t.data\t\t= &init_ipc_ns.mq_msg_default,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= &msg_max_limit_min,\n\t\t.extra2\t\t= &msg_max_limit_max,\n\t},\n\t{\n\t\t.procname\t= \"msgsize_default\",\n\t\t.data\t\t= &init_ipc_ns.mq_msgsize_default,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= &msg_maxsize_limit_min,\n\t\t.extra2\t\t= &msg_maxsize_limit_max,\n\t},\n\t{}\n};\n\nstatic struct ctl_table_set *set_lookup(struct ctl_table_root *root)\n{\n\treturn &current->nsproxy->ipc_ns->mq_set;\n}\n\nstatic int set_is_seen(struct ctl_table_set *set)\n{\n\treturn &current->nsproxy->ipc_ns->mq_set == set;\n}\n\nstatic struct ctl_table_root set_root = {\n\t.lookup = set_lookup,\n};\n\nbool setup_mq_sysctls(struct ipc_namespace *ns)\n{\n\tstruct ctl_table *tbl;\n\n\tsetup_sysctl_set(&ns->mq_set, &set_root, set_is_seen);\n\n\ttbl = kmemdup(mq_sysctls, sizeof(mq_sysctls), GFP_KERNEL);\n\tif (tbl) {\n\t\tint i;\n\n\t\tfor (i = 0; i < ARRAY_SIZE(mq_sysctls); i++) {\n\t\t\tif (tbl[i].data == &init_ipc_ns.mq_queues_max)\n\t\t\t\ttbl[i].data = &ns->mq_queues_max;\n\n\t\t\telse if (tbl[i].data == &init_ipc_ns.mq_msg_max)\n\t\t\t\ttbl[i].data = &ns->mq_msg_max;\n\n\t\t\telse if (tbl[i].data == &init_ipc_ns.mq_msgsize_max)\n\t\t\t\ttbl[i].data = &ns->mq_msgsize_max;\n\n\t\t\telse if (tbl[i].data == &init_ipc_ns.mq_msg_default)\n\t\t\t\ttbl[i].data = &ns->mq_msg_default;\n\n\t\t\telse if (tbl[i].data == &init_ipc_ns.mq_msgsize_default)\n\t\t\t\ttbl[i].data = &ns->mq_msgsize_default;\n\t\t\telse\n\t\t\t\ttbl[i].data = NULL;\n\t\t}\n\n\t\tns->mq_sysctls = __register_sysctl_table(&ns->mq_set,\n\t\t\t\t\t\t\t \"fs/mqueue\", tbl,\n\t\t\t\t\t\t\t ARRAY_SIZE(mq_sysctls));\n\t}\n\tif (!ns->mq_sysctls) {\n\t\tkfree(tbl);\n\t\tretire_sysctl_set(&ns->mq_set);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nvoid retire_mq_sysctls(struct ipc_namespace *ns)\n{\n\tstruct ctl_table *tbl;\n\n\ttbl = ns->mq_sysctls->ctl_table_arg;\n\tunregister_sysctl_table(ns->mq_sysctls);\n\tretire_sysctl_set(&ns->mq_set);\n\tkfree(tbl);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}