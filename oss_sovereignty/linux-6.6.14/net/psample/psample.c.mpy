{
  "module_name": "psample.c",
  "hash_id": "dd84d207a799e8155e8b73d2e86404d4dc5009a8310b1b9f21d45bae0550be30",
  "original_prompt": "Ingested from linux-6.6.14/net/psample/psample.c",
  "human_readable_source": "\n \n\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/skbuff.h>\n#include <linux/module.h>\n#include <linux/timekeeping.h>\n#include <net/net_namespace.h>\n#include <net/sock.h>\n#include <net/netlink.h>\n#include <net/genetlink.h>\n#include <net/psample.h>\n#include <linux/spinlock.h>\n#include <net/ip_tunnels.h>\n#include <net/dst_metadata.h>\n\n#define PSAMPLE_MAX_PACKET_SIZE 0xffff\n\nstatic LIST_HEAD(psample_groups_list);\nstatic DEFINE_SPINLOCK(psample_groups_lock);\n\n \nenum psample_nl_multicast_groups {\n\tPSAMPLE_NL_MCGRP_CONFIG,\n\tPSAMPLE_NL_MCGRP_SAMPLE,\n};\n\nstatic const struct genl_multicast_group psample_nl_mcgrps[] = {\n\t[PSAMPLE_NL_MCGRP_CONFIG] = { .name = PSAMPLE_NL_MCGRP_CONFIG_NAME },\n\t[PSAMPLE_NL_MCGRP_SAMPLE] = { .name = PSAMPLE_NL_MCGRP_SAMPLE_NAME,\n\t\t\t\t      .flags = GENL_UNS_ADMIN_PERM },\n};\n\nstatic struct genl_family psample_nl_family __ro_after_init;\n\nstatic int psample_group_nl_fill(struct sk_buff *msg,\n\t\t\t\t struct psample_group *group,\n\t\t\t\t enum psample_command cmd, u32 portid, u32 seq,\n\t\t\t\t int flags)\n{\n\tvoid *hdr;\n\tint ret;\n\n\thdr = genlmsg_put(msg, portid, seq, &psample_nl_family, flags, cmd);\n\tif (!hdr)\n\t\treturn -EMSGSIZE;\n\n\tret = nla_put_u32(msg, PSAMPLE_ATTR_SAMPLE_GROUP, group->group_num);\n\tif (ret < 0)\n\t\tgoto error;\n\n\tret = nla_put_u32(msg, PSAMPLE_ATTR_GROUP_REFCOUNT, group->refcount);\n\tif (ret < 0)\n\t\tgoto error;\n\n\tret = nla_put_u32(msg, PSAMPLE_ATTR_GROUP_SEQ, group->seq);\n\tif (ret < 0)\n\t\tgoto error;\n\n\tgenlmsg_end(msg, hdr);\n\treturn 0;\n\nerror:\n\tgenlmsg_cancel(msg, hdr);\n\treturn -EMSGSIZE;\n}\n\nstatic int psample_nl_cmd_get_group_dumpit(struct sk_buff *msg,\n\t\t\t\t\t   struct netlink_callback *cb)\n{\n\tstruct psample_group *group;\n\tint start = cb->args[0];\n\tint idx = 0;\n\tint err;\n\n\tspin_lock_bh(&psample_groups_lock);\n\tlist_for_each_entry(group, &psample_groups_list, list) {\n\t\tif (!net_eq(group->net, sock_net(msg->sk)))\n\t\t\tcontinue;\n\t\tif (idx < start) {\n\t\t\tidx++;\n\t\t\tcontinue;\n\t\t}\n\t\terr = psample_group_nl_fill(msg, group, PSAMPLE_CMD_NEW_GROUP,\n\t\t\t\t\t    NETLINK_CB(cb->skb).portid,\n\t\t\t\t\t    cb->nlh->nlmsg_seq, NLM_F_MULTI);\n\t\tif (err)\n\t\t\tbreak;\n\t\tidx++;\n\t}\n\n\tspin_unlock_bh(&psample_groups_lock);\n\tcb->args[0] = idx;\n\treturn msg->len;\n}\n\nstatic const struct genl_small_ops psample_nl_ops[] = {\n\t{\n\t\t.cmd = PSAMPLE_CMD_GET_GROUP,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.dumpit = psample_nl_cmd_get_group_dumpit,\n\t\t \n\t}\n};\n\nstatic struct genl_family psample_nl_family __ro_after_init = {\n\t.name\t\t= PSAMPLE_GENL_NAME,\n\t.version\t= PSAMPLE_GENL_VERSION,\n\t.maxattr\t= PSAMPLE_ATTR_MAX,\n\t.netnsok\t= true,\n\t.module\t\t= THIS_MODULE,\n\t.mcgrps\t\t= psample_nl_mcgrps,\n\t.small_ops\t= psample_nl_ops,\n\t.n_small_ops\t= ARRAY_SIZE(psample_nl_ops),\n\t.resv_start_op\t= PSAMPLE_CMD_GET_GROUP + 1,\n\t.n_mcgrps\t= ARRAY_SIZE(psample_nl_mcgrps),\n};\n\nstatic void psample_group_notify(struct psample_group *group,\n\t\t\t\t enum psample_command cmd)\n{\n\tstruct sk_buff *msg;\n\tint err;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_ATOMIC);\n\tif (!msg)\n\t\treturn;\n\n\terr = psample_group_nl_fill(msg, group, cmd, 0, 0, NLM_F_MULTI);\n\tif (!err)\n\t\tgenlmsg_multicast_netns(&psample_nl_family, group->net, msg, 0,\n\t\t\t\t\tPSAMPLE_NL_MCGRP_CONFIG, GFP_ATOMIC);\n\telse\n\t\tnlmsg_free(msg);\n}\n\nstatic struct psample_group *psample_group_create(struct net *net,\n\t\t\t\t\t\t  u32 group_num)\n{\n\tstruct psample_group *group;\n\n\tgroup = kzalloc(sizeof(*group), GFP_ATOMIC);\n\tif (!group)\n\t\treturn NULL;\n\n\tgroup->net = net;\n\tgroup->group_num = group_num;\n\tlist_add_tail(&group->list, &psample_groups_list);\n\n\tpsample_group_notify(group, PSAMPLE_CMD_NEW_GROUP);\n\treturn group;\n}\n\nstatic void psample_group_destroy(struct psample_group *group)\n{\n\tpsample_group_notify(group, PSAMPLE_CMD_DEL_GROUP);\n\tlist_del(&group->list);\n\tkfree_rcu(group, rcu);\n}\n\nstatic struct psample_group *\npsample_group_lookup(struct net *net, u32 group_num)\n{\n\tstruct psample_group *group;\n\n\tlist_for_each_entry(group, &psample_groups_list, list)\n\t\tif ((group->group_num == group_num) && (group->net == net))\n\t\t\treturn group;\n\treturn NULL;\n}\n\nstruct psample_group *psample_group_get(struct net *net, u32 group_num)\n{\n\tstruct psample_group *group;\n\n\tspin_lock_bh(&psample_groups_lock);\n\n\tgroup = psample_group_lookup(net, group_num);\n\tif (!group) {\n\t\tgroup = psample_group_create(net, group_num);\n\t\tif (!group)\n\t\t\tgoto out;\n\t}\n\tgroup->refcount++;\n\nout:\n\tspin_unlock_bh(&psample_groups_lock);\n\treturn group;\n}\nEXPORT_SYMBOL_GPL(psample_group_get);\n\nvoid psample_group_take(struct psample_group *group)\n{\n\tspin_lock_bh(&psample_groups_lock);\n\tgroup->refcount++;\n\tspin_unlock_bh(&psample_groups_lock);\n}\nEXPORT_SYMBOL_GPL(psample_group_take);\n\nvoid psample_group_put(struct psample_group *group)\n{\n\tspin_lock_bh(&psample_groups_lock);\n\n\tif (--group->refcount == 0)\n\t\tpsample_group_destroy(group);\n\n\tspin_unlock_bh(&psample_groups_lock);\n}\nEXPORT_SYMBOL_GPL(psample_group_put);\n\n#ifdef CONFIG_INET\nstatic int __psample_ip_tun_to_nlattr(struct sk_buff *skb,\n\t\t\t      struct ip_tunnel_info *tun_info)\n{\n\tunsigned short tun_proto = ip_tunnel_info_af(tun_info);\n\tconst void *tun_opts = ip_tunnel_info_opts(tun_info);\n\tconst struct ip_tunnel_key *tun_key = &tun_info->key;\n\tint tun_opts_len = tun_info->options_len;\n\n\tif (tun_key->tun_flags & TUNNEL_KEY &&\n\t    nla_put_be64(skb, PSAMPLE_TUNNEL_KEY_ATTR_ID, tun_key->tun_id,\n\t\t\t PSAMPLE_TUNNEL_KEY_ATTR_PAD))\n\t\treturn -EMSGSIZE;\n\n\tif (tun_info->mode & IP_TUNNEL_INFO_BRIDGE &&\n\t    nla_put_flag(skb, PSAMPLE_TUNNEL_KEY_ATTR_IPV4_INFO_BRIDGE))\n\t\treturn -EMSGSIZE;\n\n\tswitch (tun_proto) {\n\tcase AF_INET:\n\t\tif (tun_key->u.ipv4.src &&\n\t\t    nla_put_in_addr(skb, PSAMPLE_TUNNEL_KEY_ATTR_IPV4_SRC,\n\t\t\t\t    tun_key->u.ipv4.src))\n\t\t\treturn -EMSGSIZE;\n\t\tif (tun_key->u.ipv4.dst &&\n\t\t    nla_put_in_addr(skb, PSAMPLE_TUNNEL_KEY_ATTR_IPV4_DST,\n\t\t\t\t    tun_key->u.ipv4.dst))\n\t\t\treturn -EMSGSIZE;\n\t\tbreak;\n\tcase AF_INET6:\n\t\tif (!ipv6_addr_any(&tun_key->u.ipv6.src) &&\n\t\t    nla_put_in6_addr(skb, PSAMPLE_TUNNEL_KEY_ATTR_IPV6_SRC,\n\t\t\t\t     &tun_key->u.ipv6.src))\n\t\t\treturn -EMSGSIZE;\n\t\tif (!ipv6_addr_any(&tun_key->u.ipv6.dst) &&\n\t\t    nla_put_in6_addr(skb, PSAMPLE_TUNNEL_KEY_ATTR_IPV6_DST,\n\t\t\t\t     &tun_key->u.ipv6.dst))\n\t\t\treturn -EMSGSIZE;\n\t\tbreak;\n\t}\n\tif (tun_key->tos &&\n\t    nla_put_u8(skb, PSAMPLE_TUNNEL_KEY_ATTR_TOS, tun_key->tos))\n\t\treturn -EMSGSIZE;\n\tif (nla_put_u8(skb, PSAMPLE_TUNNEL_KEY_ATTR_TTL, tun_key->ttl))\n\t\treturn -EMSGSIZE;\n\tif ((tun_key->tun_flags & TUNNEL_DONT_FRAGMENT) &&\n\t    nla_put_flag(skb, PSAMPLE_TUNNEL_KEY_ATTR_DONT_FRAGMENT))\n\t\treturn -EMSGSIZE;\n\tif ((tun_key->tun_flags & TUNNEL_CSUM) &&\n\t    nla_put_flag(skb, PSAMPLE_TUNNEL_KEY_ATTR_CSUM))\n\t\treturn -EMSGSIZE;\n\tif (tun_key->tp_src &&\n\t    nla_put_be16(skb, PSAMPLE_TUNNEL_KEY_ATTR_TP_SRC, tun_key->tp_src))\n\t\treturn -EMSGSIZE;\n\tif (tun_key->tp_dst &&\n\t    nla_put_be16(skb, PSAMPLE_TUNNEL_KEY_ATTR_TP_DST, tun_key->tp_dst))\n\t\treturn -EMSGSIZE;\n\tif ((tun_key->tun_flags & TUNNEL_OAM) &&\n\t    nla_put_flag(skb, PSAMPLE_TUNNEL_KEY_ATTR_OAM))\n\t\treturn -EMSGSIZE;\n\tif (tun_opts_len) {\n\t\tif (tun_key->tun_flags & TUNNEL_GENEVE_OPT &&\n\t\t    nla_put(skb, PSAMPLE_TUNNEL_KEY_ATTR_GENEVE_OPTS,\n\t\t\t    tun_opts_len, tun_opts))\n\t\t\treturn -EMSGSIZE;\n\t\telse if (tun_key->tun_flags & TUNNEL_ERSPAN_OPT &&\n\t\t\t nla_put(skb, PSAMPLE_TUNNEL_KEY_ATTR_ERSPAN_OPTS,\n\t\t\t\t tun_opts_len, tun_opts))\n\t\t\treturn -EMSGSIZE;\n\t}\n\n\treturn 0;\n}\n\nstatic int psample_ip_tun_to_nlattr(struct sk_buff *skb,\n\t\t\t    struct ip_tunnel_info *tun_info)\n{\n\tstruct nlattr *nla;\n\tint err;\n\n\tnla = nla_nest_start_noflag(skb, PSAMPLE_ATTR_TUNNEL);\n\tif (!nla)\n\t\treturn -EMSGSIZE;\n\n\terr = __psample_ip_tun_to_nlattr(skb, tun_info);\n\tif (err) {\n\t\tnla_nest_cancel(skb, nla);\n\t\treturn err;\n\t}\n\n\tnla_nest_end(skb, nla);\n\n\treturn 0;\n}\n\nstatic int psample_tunnel_meta_len(struct ip_tunnel_info *tun_info)\n{\n\tunsigned short tun_proto = ip_tunnel_info_af(tun_info);\n\tconst struct ip_tunnel_key *tun_key = &tun_info->key;\n\tint tun_opts_len = tun_info->options_len;\n\tint sum = nla_total_size(0);\t \n\n\tif (tun_key->tun_flags & TUNNEL_KEY)\n\t\tsum += nla_total_size_64bit(sizeof(u64));\n\n\tif (tun_info->mode & IP_TUNNEL_INFO_BRIDGE)\n\t\tsum += nla_total_size(0);\n\n\tswitch (tun_proto) {\n\tcase AF_INET:\n\t\tif (tun_key->u.ipv4.src)\n\t\t\tsum += nla_total_size(sizeof(u32));\n\t\tif (tun_key->u.ipv4.dst)\n\t\t\tsum += nla_total_size(sizeof(u32));\n\t\tbreak;\n\tcase AF_INET6:\n\t\tif (!ipv6_addr_any(&tun_key->u.ipv6.src))\n\t\t\tsum += nla_total_size(sizeof(struct in6_addr));\n\t\tif (!ipv6_addr_any(&tun_key->u.ipv6.dst))\n\t\t\tsum += nla_total_size(sizeof(struct in6_addr));\n\t\tbreak;\n\t}\n\tif (tun_key->tos)\n\t\tsum += nla_total_size(sizeof(u8));\n\tsum += nla_total_size(sizeof(u8));\t \n\tif (tun_key->tun_flags & TUNNEL_DONT_FRAGMENT)\n\t\tsum += nla_total_size(0);\n\tif (tun_key->tun_flags & TUNNEL_CSUM)\n\t\tsum += nla_total_size(0);\n\tif (tun_key->tp_src)\n\t\tsum += nla_total_size(sizeof(u16));\n\tif (tun_key->tp_dst)\n\t\tsum += nla_total_size(sizeof(u16));\n\tif (tun_key->tun_flags & TUNNEL_OAM)\n\t\tsum += nla_total_size(0);\n\tif (tun_opts_len) {\n\t\tif (tun_key->tun_flags & TUNNEL_GENEVE_OPT)\n\t\t\tsum += nla_total_size(tun_opts_len);\n\t\telse if (tun_key->tun_flags & TUNNEL_ERSPAN_OPT)\n\t\t\tsum += nla_total_size(tun_opts_len);\n\t}\n\n\treturn sum;\n}\n#endif\n\nvoid psample_sample_packet(struct psample_group *group, struct sk_buff *skb,\n\t\t\t   u32 sample_rate, const struct psample_metadata *md)\n{\n\tktime_t tstamp = ktime_get_real();\n\tint out_ifindex = md->out_ifindex;\n\tint in_ifindex = md->in_ifindex;\n\tu32 trunc_size = md->trunc_size;\n#ifdef CONFIG_INET\n\tstruct ip_tunnel_info *tun_info;\n#endif\n\tstruct sk_buff *nl_skb;\n\tint data_len;\n\tint meta_len;\n\tvoid *data;\n\tint ret;\n\n\tmeta_len = (in_ifindex ? nla_total_size(sizeof(u16)) : 0) +\n\t\t   (out_ifindex ? nla_total_size(sizeof(u16)) : 0) +\n\t\t   (md->out_tc_valid ? nla_total_size(sizeof(u16)) : 0) +\n\t\t   (md->out_tc_occ_valid ? nla_total_size_64bit(sizeof(u64)) : 0) +\n\t\t   (md->latency_valid ? nla_total_size_64bit(sizeof(u64)) : 0) +\n\t\t   nla_total_size(sizeof(u32)) +\t \n\t\t   nla_total_size(sizeof(u32)) +\t \n\t\t   nla_total_size(sizeof(u32)) +\t \n\t\t   nla_total_size(sizeof(u32)) +\t \n\t\t   nla_total_size_64bit(sizeof(u64)) +\t \n\t\t   nla_total_size(sizeof(u16));\t\t \n\n#ifdef CONFIG_INET\n\ttun_info = skb_tunnel_info(skb);\n\tif (tun_info)\n\t\tmeta_len += psample_tunnel_meta_len(tun_info);\n#endif\n\n\tdata_len = min(skb->len, trunc_size);\n\tif (meta_len + nla_total_size(data_len) > PSAMPLE_MAX_PACKET_SIZE)\n\t\tdata_len = PSAMPLE_MAX_PACKET_SIZE - meta_len - NLA_HDRLEN\n\t\t\t    - NLA_ALIGNTO;\n\n\tnl_skb = genlmsg_new(meta_len + nla_total_size(data_len), GFP_ATOMIC);\n\tif (unlikely(!nl_skb))\n\t\treturn;\n\n\tdata = genlmsg_put(nl_skb, 0, 0, &psample_nl_family, 0,\n\t\t\t   PSAMPLE_CMD_SAMPLE);\n\tif (unlikely(!data))\n\t\tgoto error;\n\n\tif (in_ifindex) {\n\t\tret = nla_put_u16(nl_skb, PSAMPLE_ATTR_IIFINDEX, in_ifindex);\n\t\tif (unlikely(ret < 0))\n\t\t\tgoto error;\n\t}\n\n\tif (out_ifindex) {\n\t\tret = nla_put_u16(nl_skb, PSAMPLE_ATTR_OIFINDEX, out_ifindex);\n\t\tif (unlikely(ret < 0))\n\t\t\tgoto error;\n\t}\n\n\tret = nla_put_u32(nl_skb, PSAMPLE_ATTR_SAMPLE_RATE, sample_rate);\n\tif (unlikely(ret < 0))\n\t\tgoto error;\n\n\tret = nla_put_u32(nl_skb, PSAMPLE_ATTR_ORIGSIZE, skb->len);\n\tif (unlikely(ret < 0))\n\t\tgoto error;\n\n\tret = nla_put_u32(nl_skb, PSAMPLE_ATTR_SAMPLE_GROUP, group->group_num);\n\tif (unlikely(ret < 0))\n\t\tgoto error;\n\n\tret = nla_put_u32(nl_skb, PSAMPLE_ATTR_GROUP_SEQ, group->seq++);\n\tif (unlikely(ret < 0))\n\t\tgoto error;\n\n\tif (md->out_tc_valid) {\n\t\tret = nla_put_u16(nl_skb, PSAMPLE_ATTR_OUT_TC, md->out_tc);\n\t\tif (unlikely(ret < 0))\n\t\t\tgoto error;\n\t}\n\n\tif (md->out_tc_occ_valid) {\n\t\tret = nla_put_u64_64bit(nl_skb, PSAMPLE_ATTR_OUT_TC_OCC,\n\t\t\t\t\tmd->out_tc_occ, PSAMPLE_ATTR_PAD);\n\t\tif (unlikely(ret < 0))\n\t\t\tgoto error;\n\t}\n\n\tif (md->latency_valid) {\n\t\tret = nla_put_u64_64bit(nl_skb, PSAMPLE_ATTR_LATENCY,\n\t\t\t\t\tmd->latency, PSAMPLE_ATTR_PAD);\n\t\tif (unlikely(ret < 0))\n\t\t\tgoto error;\n\t}\n\n\tret = nla_put_u64_64bit(nl_skb, PSAMPLE_ATTR_TIMESTAMP,\n\t\t\t\tktime_to_ns(tstamp), PSAMPLE_ATTR_PAD);\n\tif (unlikely(ret < 0))\n\t\tgoto error;\n\n\tret = nla_put_u16(nl_skb, PSAMPLE_ATTR_PROTO,\n\t\t\t  be16_to_cpu(skb->protocol));\n\tif (unlikely(ret < 0))\n\t\tgoto error;\n\n\tif (data_len) {\n\t\tint nla_len = nla_total_size(data_len);\n\t\tstruct nlattr *nla;\n\n\t\tnla = skb_put(nl_skb, nla_len);\n\t\tnla->nla_type = PSAMPLE_ATTR_DATA;\n\t\tnla->nla_len = nla_attr_size(data_len);\n\n\t\tif (skb_copy_bits(skb, 0, nla_data(nla), data_len))\n\t\t\tgoto error;\n\t}\n\n#ifdef CONFIG_INET\n\tif (tun_info) {\n\t\tret = psample_ip_tun_to_nlattr(nl_skb, tun_info);\n\t\tif (unlikely(ret < 0))\n\t\t\tgoto error;\n\t}\n#endif\n\n\tgenlmsg_end(nl_skb, data);\n\tgenlmsg_multicast_netns(&psample_nl_family, group->net, nl_skb, 0,\n\t\t\t\tPSAMPLE_NL_MCGRP_SAMPLE, GFP_ATOMIC);\n\n\treturn;\nerror:\n\tpr_err_ratelimited(\"Could not create psample log message\\n\");\n\tnlmsg_free(nl_skb);\n}\nEXPORT_SYMBOL_GPL(psample_sample_packet);\n\nstatic int __init psample_module_init(void)\n{\n\treturn genl_register_family(&psample_nl_family);\n}\n\nstatic void __exit psample_module_exit(void)\n{\n\tgenl_unregister_family(&psample_nl_family);\n}\n\nmodule_init(psample_module_init);\nmodule_exit(psample_module_exit);\n\nMODULE_AUTHOR(\"Yotam Gigi <yotam.gi@gmail.com>\");\nMODULE_DESCRIPTION(\"netlink channel for packet sampling\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}