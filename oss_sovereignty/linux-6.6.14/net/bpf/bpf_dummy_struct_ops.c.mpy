{
  "module_name": "bpf_dummy_struct_ops.c",
  "hash_id": "941d4c1ae71822f06e1b1ef8e219d5e82a808273743b88f99bada220d06b9e25",
  "original_prompt": "Ingested from linux-6.6.14/net/bpf/bpf_dummy_struct_ops.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf.h>\n#include <linux/btf.h>\n\nextern struct bpf_struct_ops bpf_bpf_dummy_ops;\n\n \ntypedef int (*dummy_ops_test_ret_fn)(struct bpf_dummy_ops_state *state, ...);\n\nstruct bpf_dummy_ops_test_args {\n\tu64 args[MAX_BPF_FUNC_ARGS];\n\tstruct bpf_dummy_ops_state state;\n};\n\nstatic struct bpf_dummy_ops_test_args *\ndummy_ops_init_args(const union bpf_attr *kattr, unsigned int nr)\n{\n\t__u32 size_in;\n\tstruct bpf_dummy_ops_test_args *args;\n\tvoid __user *ctx_in;\n\tvoid __user *u_state;\n\n\tsize_in = kattr->test.ctx_size_in;\n\tif (size_in != sizeof(u64) * nr)\n\t\treturn ERR_PTR(-EINVAL);\n\n\targs = kzalloc(sizeof(*args), GFP_KERNEL);\n\tif (!args)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tctx_in = u64_to_user_ptr(kattr->test.ctx_in);\n\tif (copy_from_user(args->args, ctx_in, size_in))\n\t\tgoto out;\n\n\t \n\tu_state = u64_to_user_ptr(args->args[0]);\n\tif (u_state && copy_from_user(&args->state, u_state,\n\t\t\t\t      sizeof(args->state)))\n\t\tgoto out;\n\n\treturn args;\nout:\n\tkfree(args);\n\treturn ERR_PTR(-EFAULT);\n}\n\nstatic int dummy_ops_copy_args(struct bpf_dummy_ops_test_args *args)\n{\n\tvoid __user *u_state;\n\n\tu_state = u64_to_user_ptr(args->args[0]);\n\tif (u_state && copy_to_user(u_state, &args->state, sizeof(args->state)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstatic int dummy_ops_call_op(void *image, struct bpf_dummy_ops_test_args *args)\n{\n\tdummy_ops_test_ret_fn test = (void *)image;\n\tstruct bpf_dummy_ops_state *state = NULL;\n\n\t \n\tif (args->args[0])\n\t\tstate = &args->state;\n\treturn test(state, args->args[1], args->args[2],\n\t\t    args->args[3], args->args[4]);\n}\n\nextern const struct bpf_link_ops bpf_struct_ops_link_lops;\n\nint bpf_struct_ops_test_run(struct bpf_prog *prog, const union bpf_attr *kattr,\n\t\t\t    union bpf_attr __user *uattr)\n{\n\tconst struct bpf_struct_ops *st_ops = &bpf_bpf_dummy_ops;\n\tconst struct btf_type *func_proto;\n\tstruct bpf_dummy_ops_test_args *args;\n\tstruct bpf_tramp_links *tlinks;\n\tstruct bpf_tramp_link *link = NULL;\n\tvoid *image = NULL;\n\tunsigned int op_idx;\n\tint prog_ret;\n\tint err;\n\n\tif (prog->aux->attach_btf_id != st_ops->type_id)\n\t\treturn -EOPNOTSUPP;\n\n\tfunc_proto = prog->aux->attach_func_proto;\n\targs = dummy_ops_init_args(kattr, btf_type_vlen(func_proto));\n\tif (IS_ERR(args))\n\t\treturn PTR_ERR(args);\n\n\ttlinks = kcalloc(BPF_TRAMP_MAX, sizeof(*tlinks), GFP_KERNEL);\n\tif (!tlinks) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\timage = bpf_jit_alloc_exec(PAGE_SIZE);\n\tif (!image) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\tset_vm_flush_reset_perms(image);\n\n\tlink = kzalloc(sizeof(*link), GFP_USER);\n\tif (!link) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\t \n\tbpf_prog_inc(prog);\n\tbpf_link_init(&link->link, BPF_LINK_TYPE_STRUCT_OPS, &bpf_struct_ops_link_lops, prog);\n\n\top_idx = prog->expected_attach_type;\n\terr = bpf_struct_ops_prepare_trampoline(tlinks, link,\n\t\t\t\t\t\t&st_ops->func_models[op_idx],\n\t\t\t\t\t\timage, image + PAGE_SIZE);\n\tif (err < 0)\n\t\tgoto out;\n\n\tset_memory_rox((long)image, 1);\n\tprog_ret = dummy_ops_call_op(image, args);\n\n\terr = dummy_ops_copy_args(args);\n\tif (err)\n\t\tgoto out;\n\tif (put_user(prog_ret, &uattr->test.retval))\n\t\terr = -EFAULT;\nout:\n\tkfree(args);\n\tbpf_jit_free_exec(image);\n\tif (link)\n\t\tbpf_link_put(&link->link);\n\tkfree(tlinks);\n\treturn err;\n}\n\nstatic int bpf_dummy_init(struct btf *btf)\n{\n\treturn 0;\n}\n\nstatic bool bpf_dummy_ops_is_valid_access(int off, int size,\n\t\t\t\t\t  enum bpf_access_type type,\n\t\t\t\t\t  const struct bpf_prog *prog,\n\t\t\t\t\t  struct bpf_insn_access_aux *info)\n{\n\treturn bpf_tracing_btf_ctx_access(off, size, type, prog, info);\n}\n\nstatic int bpf_dummy_ops_check_member(const struct btf_type *t,\n\t\t\t\t      const struct btf_member *member,\n\t\t\t\t      const struct bpf_prog *prog)\n{\n\tu32 moff = __btf_member_bit_offset(t, member) / 8;\n\n\tswitch (moff) {\n\tcase offsetof(struct bpf_dummy_ops, test_sleepable):\n\t\tbreak;\n\tdefault:\n\t\tif (prog->aux->sleepable)\n\t\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int bpf_dummy_ops_btf_struct_access(struct bpf_verifier_log *log,\n\t\t\t\t\t   const struct bpf_reg_state *reg,\n\t\t\t\t\t   int off, int size)\n{\n\tconst struct btf_type *state;\n\tconst struct btf_type *t;\n\ts32 type_id;\n\n\ttype_id = btf_find_by_name_kind(reg->btf, \"bpf_dummy_ops_state\",\n\t\t\t\t\tBTF_KIND_STRUCT);\n\tif (type_id < 0)\n\t\treturn -EINVAL;\n\n\tt = btf_type_by_id(reg->btf, reg->btf_id);\n\tstate = btf_type_by_id(reg->btf, type_id);\n\tif (t != state) {\n\t\tbpf_log(log, \"only access to bpf_dummy_ops_state is supported\\n\");\n\t\treturn -EACCES;\n\t}\n\n\tif (off + size > sizeof(struct bpf_dummy_ops_state)) {\n\t\tbpf_log(log, \"write access at off %d with size %d\\n\", off, size);\n\t\treturn -EACCES;\n\t}\n\n\treturn NOT_INIT;\n}\n\nstatic const struct bpf_verifier_ops bpf_dummy_verifier_ops = {\n\t.is_valid_access = bpf_dummy_ops_is_valid_access,\n\t.btf_struct_access = bpf_dummy_ops_btf_struct_access,\n};\n\nstatic int bpf_dummy_init_member(const struct btf_type *t,\n\t\t\t\t const struct btf_member *member,\n\t\t\t\t void *kdata, const void *udata)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic int bpf_dummy_reg(void *kdata)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic void bpf_dummy_unreg(void *kdata)\n{\n}\n\nstruct bpf_struct_ops bpf_bpf_dummy_ops = {\n\t.verifier_ops = &bpf_dummy_verifier_ops,\n\t.init = bpf_dummy_init,\n\t.check_member = bpf_dummy_ops_check_member,\n\t.init_member = bpf_dummy_init_member,\n\t.reg = bpf_dummy_reg,\n\t.unreg = bpf_dummy_unreg,\n\t.name = \"bpf_dummy_ops\",\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}