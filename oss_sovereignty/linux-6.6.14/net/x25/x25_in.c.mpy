{
  "module_name": "x25_in.c",
  "hash_id": "724789aaeaac3fd8c5f07a9821525971b5b6e3a7a57de42fdbc5f3a734ac989c",
  "original_prompt": "Ingested from linux-6.6.14/net/x25/x25_in.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"X25: \" fmt\n\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/skbuff.h>\n#include <net/sock.h>\n#include <net/tcp_states.h>\n#include <net/x25.h>\n\nstatic int x25_queue_rx_frame(struct sock *sk, struct sk_buff *skb, int more)\n{\n\tstruct sk_buff *skbo, *skbn = skb;\n\tstruct x25_sock *x25 = x25_sk(sk);\n\n\tif (more) {\n\t\tx25->fraglen += skb->len;\n\t\tskb_queue_tail(&x25->fragment_queue, skb);\n\t\tskb_set_owner_r(skb, sk);\n\t\treturn 0;\n\t}\n\n\tif (x25->fraglen > 0) {\t \n\t\tint len = x25->fraglen + skb->len;\n\n\t\tif ((skbn = alloc_skb(len, GFP_ATOMIC)) == NULL){\n\t\t\tkfree_skb(skb);\n\t\t\treturn 1;\n\t\t}\n\n\t\tskb_queue_tail(&x25->fragment_queue, skb);\n\n\t\tskb_reset_transport_header(skbn);\n\n\t\tskbo = skb_dequeue(&x25->fragment_queue);\n\t\tskb_copy_from_linear_data(skbo, skb_put(skbn, skbo->len),\n\t\t\t\t\t  skbo->len);\n\t\tkfree_skb(skbo);\n\n\t\twhile ((skbo =\n\t\t\tskb_dequeue(&x25->fragment_queue)) != NULL) {\n\t\t\tskb_pull(skbo, (x25->neighbour->extended) ?\n\t\t\t\t\tX25_EXT_MIN_LEN : X25_STD_MIN_LEN);\n\t\t\tskb_copy_from_linear_data(skbo,\n\t\t\t\t\t\t  skb_put(skbn, skbo->len),\n\t\t\t\t\t\t  skbo->len);\n\t\t\tkfree_skb(skbo);\n\t\t}\n\n\t\tx25->fraglen = 0;\n\t}\n\n\tskb_set_owner_r(skbn, sk);\n\tskb_queue_tail(&sk->sk_receive_queue, skbn);\n\tif (!sock_flag(sk, SOCK_DEAD))\n\t\tsk->sk_data_ready(sk);\n\n\treturn 0;\n}\n\n \nstatic int x25_state1_machine(struct sock *sk, struct sk_buff *skb, int frametype)\n{\n\tstruct x25_address source_addr, dest_addr;\n\tint len;\n\tstruct x25_sock *x25 = x25_sk(sk);\n\n\tswitch (frametype) {\n\tcase X25_CALL_ACCEPTED: {\n\n\t\tx25_stop_timer(sk);\n\t\tx25->condition = 0x00;\n\t\tx25->vs        = 0;\n\t\tx25->va        = 0;\n\t\tx25->vr        = 0;\n\t\tx25->vl        = 0;\n\t\tx25->state     = X25_STATE_3;\n\t\tsk->sk_state   = TCP_ESTABLISHED;\n\t\t \n\t\tif (!pskb_may_pull(skb, X25_STD_MIN_LEN))\n\t\t\tgoto out_clear;\n\t\tskb_pull(skb, X25_STD_MIN_LEN);\n\n\t\tlen = x25_parse_address_block(skb, &source_addr,\n\t\t\t\t\t      &dest_addr);\n\t\tif (len > 0)\n\t\t\tskb_pull(skb, len);\n\t\telse if (len < 0)\n\t\t\tgoto out_clear;\n\n\t\tlen = x25_parse_facilities(skb, &x25->facilities,\n\t\t\t\t\t   &x25->dte_facilities,\n\t\t\t\t\t   &x25->vc_facil_mask);\n\t\tif (len > 0)\n\t\t\tskb_pull(skb, len);\n\t\telse if (len < 0)\n\t\t\tgoto out_clear;\n\t\t \n\t\tif (skb->len > 0) {\n\t\t\tif (skb->len > X25_MAX_CUD_LEN)\n\t\t\t\tgoto out_clear;\n\n\t\t\tskb_copy_bits(skb, 0, x25->calluserdata.cuddata,\n\t\t\t\tskb->len);\n\t\t\tx25->calluserdata.cudlength = skb->len;\n\t\t}\n\t\tif (!sock_flag(sk, SOCK_DEAD))\n\t\t\tsk->sk_state_change(sk);\n\t\tbreak;\n\t}\n\tcase X25_CALL_REQUEST:\n\t\t \n\t\tx25->causediag.cause      = 0x01;\n\t\tx25->causediag.diagnostic = 0x48;\n\n\t\tx25_write_internal(sk, X25_CLEAR_REQUEST);\n\t\tx25_disconnect(sk, EISCONN, 0x01, 0x48);\n\t\tbreak;\n\n\tcase X25_CLEAR_REQUEST:\n\t\tif (!pskb_may_pull(skb, X25_STD_MIN_LEN + 2))\n\t\t\tgoto out_clear;\n\n\t\tx25_write_internal(sk, X25_CLEAR_CONFIRMATION);\n\t\tx25_disconnect(sk, ECONNREFUSED, skb->data[3], skb->data[4]);\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n\nout_clear:\n\tx25_write_internal(sk, X25_CLEAR_REQUEST);\n\tx25->state = X25_STATE_2;\n\tx25_start_t23timer(sk);\n\treturn 0;\n}\n\n \nstatic int x25_state2_machine(struct sock *sk, struct sk_buff *skb, int frametype)\n{\n\tswitch (frametype) {\n\n\t\tcase X25_CLEAR_REQUEST:\n\t\t\tif (!pskb_may_pull(skb, X25_STD_MIN_LEN + 2))\n\t\t\t\tgoto out_clear;\n\n\t\t\tx25_write_internal(sk, X25_CLEAR_CONFIRMATION);\n\t\t\tx25_disconnect(sk, 0, skb->data[3], skb->data[4]);\n\t\t\tbreak;\n\n\t\tcase X25_CLEAR_CONFIRMATION:\n\t\t\tx25_disconnect(sk, 0, 0, 0);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\n\treturn 0;\n\nout_clear:\n\tx25_write_internal(sk, X25_CLEAR_REQUEST);\n\tx25_start_t23timer(sk);\n\treturn 0;\n}\n\n \nstatic int x25_state3_machine(struct sock *sk, struct sk_buff *skb, int frametype, int ns, int nr, int q, int d, int m)\n{\n\tint queued = 0;\n\tint modulus;\n\tstruct x25_sock *x25 = x25_sk(sk);\n\n\tmodulus = (x25->neighbour->extended) ? X25_EMODULUS : X25_SMODULUS;\n\n\tswitch (frametype) {\n\n\t\tcase X25_RESET_REQUEST:\n\t\t\tx25_write_internal(sk, X25_RESET_CONFIRMATION);\n\t\t\tx25_stop_timer(sk);\n\t\t\tx25->condition = 0x00;\n\t\t\tx25->vs        = 0;\n\t\t\tx25->vr        = 0;\n\t\t\tx25->va        = 0;\n\t\t\tx25->vl        = 0;\n\t\t\tx25_requeue_frames(sk);\n\t\t\tbreak;\n\n\t\tcase X25_CLEAR_REQUEST:\n\t\t\tif (!pskb_may_pull(skb, X25_STD_MIN_LEN + 2))\n\t\t\t\tgoto out_clear;\n\n\t\t\tx25_write_internal(sk, X25_CLEAR_CONFIRMATION);\n\t\t\tx25_disconnect(sk, 0, skb->data[3], skb->data[4]);\n\t\t\tbreak;\n\n\t\tcase X25_RR:\n\t\tcase X25_RNR:\n\t\t\tif (!x25_validate_nr(sk, nr)) {\n\t\t\t\tx25_clear_queues(sk);\n\t\t\t\tx25_write_internal(sk, X25_RESET_REQUEST);\n\t\t\t\tx25_start_t22timer(sk);\n\t\t\t\tx25->condition = 0x00;\n\t\t\t\tx25->vs        = 0;\n\t\t\t\tx25->vr        = 0;\n\t\t\t\tx25->va        = 0;\n\t\t\t\tx25->vl        = 0;\n\t\t\t\tx25->state     = X25_STATE_4;\n\t\t\t} else {\n\t\t\t\tx25_frames_acked(sk, nr);\n\t\t\t\tif (frametype == X25_RNR) {\n\t\t\t\t\tx25->condition |= X25_COND_PEER_RX_BUSY;\n\t\t\t\t} else {\n\t\t\t\t\tx25->condition &= ~X25_COND_PEER_RX_BUSY;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase X25_DATA:\t \n\t\t\tx25->condition &= ~X25_COND_PEER_RX_BUSY;\n\t\t\tif ((ns != x25->vr) || !x25_validate_nr(sk, nr)) {\n\t\t\t\tx25_clear_queues(sk);\n\t\t\t\tx25_write_internal(sk, X25_RESET_REQUEST);\n\t\t\t\tx25_start_t22timer(sk);\n\t\t\t\tx25->condition = 0x00;\n\t\t\t\tx25->vs        = 0;\n\t\t\t\tx25->vr        = 0;\n\t\t\t\tx25->va        = 0;\n\t\t\t\tx25->vl        = 0;\n\t\t\t\tx25->state     = X25_STATE_4;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tx25_frames_acked(sk, nr);\n\t\t\tif (ns == x25->vr) {\n\t\t\t\tif (x25_queue_rx_frame(sk, skb, m) == 0) {\n\t\t\t\t\tx25->vr = (x25->vr + 1) % modulus;\n\t\t\t\t\tqueued = 1;\n\t\t\t\t} else {\n\t\t\t\t\t \n\t\t\t\t\tx25_clear_queues(sk);\n\t\t\t\t\tx25_write_internal(sk, X25_RESET_REQUEST);\n\t\t\t\t\tx25_start_t22timer(sk);\n\t\t\t\t\tx25->condition = 0x00;\n\t\t\t\t\tx25->vs        = 0;\n\t\t\t\t\tx25->vr        = 0;\n\t\t\t\t\tx25->va        = 0;\n\t\t\t\t\tx25->vl        = 0;\n\t\t\t\t\tx25->state     = X25_STATE_4;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (atomic_read(&sk->sk_rmem_alloc) >\n\t\t\t\t    (sk->sk_rcvbuf >> 1))\n\t\t\t\t\tx25->condition |= X25_COND_OWN_RX_BUSY;\n\t\t\t}\n\t\t\t \n\t\t\tif (((x25->vl + x25->facilities.winsize_in) % modulus) == x25->vr) {\n\t\t\t\tx25->condition &= ~X25_COND_ACK_PENDING;\n\t\t\t\tx25_stop_timer(sk);\n\t\t\t\tx25_enquiry_response(sk);\n\t\t\t} else {\n\t\t\t\tx25->condition |= X25_COND_ACK_PENDING;\n\t\t\t\tx25_start_t2timer(sk);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase X25_INTERRUPT_CONFIRMATION:\n\t\t\tclear_bit(X25_INTERRUPT_FLAG, &x25->flags);\n\t\t\tbreak;\n\n\t\tcase X25_INTERRUPT:\n\t\t\tif (sock_flag(sk, SOCK_URGINLINE))\n\t\t\t\tqueued = !sock_queue_rcv_skb(sk, skb);\n\t\t\telse {\n\t\t\t\tskb_set_owner_r(skb, sk);\n\t\t\t\tskb_queue_tail(&x25->interrupt_in_queue, skb);\n\t\t\t\tqueued = 1;\n\t\t\t}\n\t\t\tsk_send_sigurg(sk);\n\t\t\tx25_write_internal(sk, X25_INTERRUPT_CONFIRMATION);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tpr_warn(\"unknown %02X in state 3\\n\", frametype);\n\t\t\tbreak;\n\t}\n\n\treturn queued;\n\nout_clear:\n\tx25_write_internal(sk, X25_CLEAR_REQUEST);\n\tx25->state = X25_STATE_2;\n\tx25_start_t23timer(sk);\n\treturn 0;\n}\n\n \nstatic int x25_state4_machine(struct sock *sk, struct sk_buff *skb, int frametype)\n{\n\tstruct x25_sock *x25 = x25_sk(sk);\n\n\tswitch (frametype) {\n\n\t\tcase X25_RESET_REQUEST:\n\t\t\tx25_write_internal(sk, X25_RESET_CONFIRMATION);\n\t\t\tfallthrough;\n\t\tcase X25_RESET_CONFIRMATION: {\n\t\t\tx25_stop_timer(sk);\n\t\t\tx25->condition = 0x00;\n\t\t\tx25->va        = 0;\n\t\t\tx25->vr        = 0;\n\t\t\tx25->vs        = 0;\n\t\t\tx25->vl        = 0;\n\t\t\tx25->state     = X25_STATE_3;\n\t\t\tx25_requeue_frames(sk);\n\t\t\tbreak;\n\t\t}\n\t\tcase X25_CLEAR_REQUEST:\n\t\t\tif (!pskb_may_pull(skb, X25_STD_MIN_LEN + 2))\n\t\t\t\tgoto out_clear;\n\n\t\t\tx25_write_internal(sk, X25_CLEAR_CONFIRMATION);\n\t\t\tx25_disconnect(sk, 0, skb->data[3], skb->data[4]);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\n\treturn 0;\n\nout_clear:\n\tx25_write_internal(sk, X25_CLEAR_REQUEST);\n\tx25->state = X25_STATE_2;\n\tx25_start_t23timer(sk);\n\treturn 0;\n}\n\n \nstatic int x25_state5_machine(struct sock *sk, struct sk_buff *skb, int frametype)\n{\n\tstruct x25_sock *x25 = x25_sk(sk);\n\n\tswitch (frametype) {\n\t\tcase X25_CLEAR_REQUEST:\n\t\t\tif (!pskb_may_pull(skb, X25_STD_MIN_LEN + 2)) {\n\t\t\t\tx25_write_internal(sk, X25_CLEAR_REQUEST);\n\t\t\t\tx25->state = X25_STATE_2;\n\t\t\t\tx25_start_t23timer(sk);\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tx25_write_internal(sk, X25_CLEAR_CONFIRMATION);\n\t\t\tx25_disconnect(sk, 0, skb->data[3], skb->data[4]);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\n \nint x25_process_rx_frame(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct x25_sock *x25 = x25_sk(sk);\n\tint queued = 0, frametype, ns, nr, q, d, m;\n\n\tif (x25->state == X25_STATE_0)\n\t\treturn 0;\n\n\tframetype = x25_decode(sk, skb, &ns, &nr, &q, &d, &m);\n\n\tswitch (x25->state) {\n\tcase X25_STATE_1:\n\t\tqueued = x25_state1_machine(sk, skb, frametype);\n\t\tbreak;\n\tcase X25_STATE_2:\n\t\tqueued = x25_state2_machine(sk, skb, frametype);\n\t\tbreak;\n\tcase X25_STATE_3:\n\t\tqueued = x25_state3_machine(sk, skb, frametype, ns, nr, q, d, m);\n\t\tbreak;\n\tcase X25_STATE_4:\n\t\tqueued = x25_state4_machine(sk, skb, frametype);\n\t\tbreak;\n\tcase X25_STATE_5:\n\t\tqueued = x25_state5_machine(sk, skb, frametype);\n\t\tbreak;\n\t}\n\n\tx25_kick(sk);\n\n\treturn queued;\n}\n\nint x25_backlog_rcv(struct sock *sk, struct sk_buff *skb)\n{\n\tint queued = x25_process_rx_frame(sk, skb);\n\n\tif (!queued)\n\t\tkfree_skb(skb);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}