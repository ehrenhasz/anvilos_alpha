{
  "module_name": "x25_route.c",
  "hash_id": "7a6d94642b1792d5c95c1a7cb0742c751c95cdd97488c7a94444ff53275ed8f5",
  "original_prompt": "Ingested from linux-6.6.14/net/x25/x25_route.c",
  "human_readable_source": "\n \n\n#include <linux/if_arp.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <net/x25.h>\n\nLIST_HEAD(x25_route_list);\nDEFINE_RWLOCK(x25_route_list_lock);\n\n \nstatic int x25_add_route(struct x25_address *address, unsigned int sigdigits,\n\t\t\t struct net_device *dev)\n{\n\tstruct x25_route *rt;\n\tint rc = -EINVAL;\n\n\twrite_lock_bh(&x25_route_list_lock);\n\n\tlist_for_each_entry(rt, &x25_route_list, node) {\n\t\tif (!memcmp(&rt->address, address, sigdigits) &&\n\t\t    rt->sigdigits == sigdigits)\n\t\t\tgoto out;\n\t}\n\n\trt = kmalloc(sizeof(*rt), GFP_ATOMIC);\n\trc = -ENOMEM;\n\tif (!rt)\n\t\tgoto out;\n\n\tstrcpy(rt->address.x25_addr, \"000000000000000\");\n\tmemcpy(rt->address.x25_addr, address->x25_addr, sigdigits);\n\n\trt->sigdigits = sigdigits;\n\trt->dev       = dev;\n\trefcount_set(&rt->refcnt, 1);\n\n\tlist_add(&rt->node, &x25_route_list);\n\trc = 0;\nout:\n\twrite_unlock_bh(&x25_route_list_lock);\n\treturn rc;\n}\n\n \nstatic void __x25_remove_route(struct x25_route *rt)\n{\n\tif (rt->node.next) {\n\t\tlist_del(&rt->node);\n\t\tx25_route_put(rt);\n\t}\n}\n\nstatic int x25_del_route(struct x25_address *address, unsigned int sigdigits,\n\t\t\t struct net_device *dev)\n{\n\tstruct x25_route *rt;\n\tint rc = -EINVAL;\n\n\twrite_lock_bh(&x25_route_list_lock);\n\n\tlist_for_each_entry(rt, &x25_route_list, node) {\n\t\tif (!memcmp(&rt->address, address, sigdigits) &&\n\t\t    rt->sigdigits == sigdigits && rt->dev == dev) {\n\t\t\t__x25_remove_route(rt);\n\t\t\trc = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\twrite_unlock_bh(&x25_route_list_lock);\n\treturn rc;\n}\n\n \nvoid x25_route_device_down(struct net_device *dev)\n{\n\tstruct x25_route *rt;\n\tstruct list_head *entry, *tmp;\n\n\twrite_lock_bh(&x25_route_list_lock);\n\n\tlist_for_each_safe(entry, tmp, &x25_route_list) {\n\t\trt = list_entry(entry, struct x25_route, node);\n\n\t\tif (rt->dev == dev)\n\t\t\t__x25_remove_route(rt);\n\t}\n\twrite_unlock_bh(&x25_route_list_lock);\n}\n\n \nstruct net_device *x25_dev_get(char *devname)\n{\n\tstruct net_device *dev = dev_get_by_name(&init_net, devname);\n\n\tif (dev && (!(dev->flags & IFF_UP) || dev->type != ARPHRD_X25)) {\n\t\tdev_put(dev);\n\t\tdev = NULL;\n\t}\n\n\treturn dev;\n}\n\n \nstruct x25_route *x25_get_route(struct x25_address *addr)\n{\n\tstruct x25_route *rt, *use = NULL;\n\n\tread_lock_bh(&x25_route_list_lock);\n\n\tlist_for_each_entry(rt, &x25_route_list, node) {\n\t\tif (!memcmp(&rt->address, addr, rt->sigdigits)) {\n\t\t\tif (!use)\n\t\t\t\tuse = rt;\n\t\t\telse if (rt->sigdigits > use->sigdigits)\n\t\t\t\tuse = rt;\n\t\t}\n\t}\n\n\tif (use)\n\t\tx25_route_hold(use);\n\n\tread_unlock_bh(&x25_route_list_lock);\n\treturn use;\n}\n\n \nint x25_route_ioctl(unsigned int cmd, void __user *arg)\n{\n\tstruct x25_route_struct rt;\n\tstruct net_device *dev;\n\tint rc = -EINVAL;\n\n\tif (cmd != SIOCADDRT && cmd != SIOCDELRT)\n\t\tgoto out;\n\n\trc = -EFAULT;\n\tif (copy_from_user(&rt, arg, sizeof(rt)))\n\t\tgoto out;\n\n\trc = -EINVAL;\n\tif (rt.sigdigits > 15)\n\t\tgoto out;\n\n\tdev = x25_dev_get(rt.device);\n\tif (!dev)\n\t\tgoto out;\n\n\tif (cmd == SIOCADDRT)\n\t\trc = x25_add_route(&rt.address, rt.sigdigits, dev);\n\telse\n\t\trc = x25_del_route(&rt.address, rt.sigdigits, dev);\n\tdev_put(dev);\nout:\n\treturn rc;\n}\n\n \nvoid __exit x25_route_free(void)\n{\n\tstruct x25_route *rt;\n\tstruct list_head *entry, *tmp;\n\n\twrite_lock_bh(&x25_route_list_lock);\n\tlist_for_each_safe(entry, tmp, &x25_route_list) {\n\t\trt = list_entry(entry, struct x25_route, node);\n\t\t__x25_remove_route(rt);\n\t}\n\twrite_unlock_bh(&x25_route_list_lock);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}