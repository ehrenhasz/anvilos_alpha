{
  "module_name": "x25_forward.c",
  "hash_id": "1a04fb036744af83f39dbe91d9e0dba2bc7073f0deca5ab4b12a7c839ab7c0b1",
  "original_prompt": "Ingested from linux-6.6.14/net/x25/x25_forward.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"X25: \" fmt\n\n#include <linux/if_arp.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <net/x25.h>\n\nLIST_HEAD(x25_forward_list);\nDEFINE_RWLOCK(x25_forward_list_lock);\n\nint x25_forward_call(struct x25_address *dest_addr, struct x25_neigh *from,\n\t\t\tstruct sk_buff *skb, int lci)\n{\n\tstruct x25_route *rt;\n\tstruct x25_neigh *neigh_new = NULL;\n\tstruct x25_forward *x25_frwd, *new_frwd;\n\tstruct sk_buff *skbn;\n\tshort same_lci = 0;\n\tint rc = 0;\n\n\tif ((rt = x25_get_route(dest_addr)) == NULL)\n\t\tgoto out_no_route;\n\n\tif ((neigh_new = x25_get_neigh(rt->dev)) == NULL) {\n\t\t \n\t\tgoto out_put_route;\n\t}\n\n\t \n\tif (rt->dev == from->dev) {\n\t\tgoto out_put_nb;\n\t}\n\n\t \n\tread_lock_bh(&x25_forward_list_lock);\n\tlist_for_each_entry(x25_frwd, &x25_forward_list, node) {\n\t\tif (x25_frwd->lci == lci) {\n\t\t\tpr_warn(\"call request for lci which is already registered!, transmitting but not registering new pair\\n\");\n\t\t\tsame_lci = 1;\n\t\t}\n\t}\n\tread_unlock_bh(&x25_forward_list_lock);\n\n\t \n\tif (!same_lci){\n\t\tif ((new_frwd = kmalloc(sizeof(struct x25_forward),\n\t\t\t\t\t\tGFP_ATOMIC)) == NULL){\n\t\t\trc = -ENOMEM;\n\t\t\tgoto out_put_nb;\n\t\t}\n\t\tnew_frwd->lci = lci;\n\t\tnew_frwd->dev1 = rt->dev;\n\t\tnew_frwd->dev2 = from->dev;\n\t\twrite_lock_bh(&x25_forward_list_lock);\n\t\tlist_add(&new_frwd->node, &x25_forward_list);\n\t\twrite_unlock_bh(&x25_forward_list_lock);\n\t}\n\n\t \n\tif ( (skbn = skb_clone(skb, GFP_ATOMIC)) == NULL){\n\t\tgoto out_put_nb;\n\t}\n\tx25_transmit_link(skbn, neigh_new);\n\trc = 1;\n\n\nout_put_nb:\n\tx25_neigh_put(neigh_new);\n\nout_put_route:\n\tx25_route_put(rt);\n\nout_no_route:\n\treturn rc;\n}\n\n\nint x25_forward_data(int lci, struct x25_neigh *from, struct sk_buff *skb) {\n\n\tstruct x25_forward *frwd;\n\tstruct net_device *peer = NULL;\n\tstruct x25_neigh *nb;\n\tstruct sk_buff *skbn;\n\tint rc = 0;\n\n\tread_lock_bh(&x25_forward_list_lock);\n\tlist_for_each_entry(frwd, &x25_forward_list, node) {\n\t\tif (frwd->lci == lci) {\n\t\t\t \n\t\t\tif (from->dev == frwd->dev1) {\n\t\t\t\tpeer = frwd->dev2;\n\t\t\t} else {\n\t\t\t\tpeer = frwd->dev1;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tread_unlock_bh(&x25_forward_list_lock);\n\n\tif ( (nb = x25_get_neigh(peer)) == NULL)\n\t\tgoto out;\n\n\tif ( (skbn = pskb_copy(skb, GFP_ATOMIC)) == NULL){\n\t\tgoto output;\n\n\t}\n\tx25_transmit_link(skbn, nb);\n\n\trc = 1;\noutput:\n\tx25_neigh_put(nb);\nout:\n\treturn rc;\n}\n\nvoid x25_clear_forward_by_lci(unsigned int lci)\n{\n\tstruct x25_forward *fwd, *tmp;\n\n\twrite_lock_bh(&x25_forward_list_lock);\n\n\tlist_for_each_entry_safe(fwd, tmp, &x25_forward_list, node) {\n\t\tif (fwd->lci == lci) {\n\t\t\tlist_del(&fwd->node);\n\t\t\tkfree(fwd);\n\t\t}\n\t}\n\twrite_unlock_bh(&x25_forward_list_lock);\n}\n\n\nvoid x25_clear_forward_by_dev(struct net_device *dev)\n{\n\tstruct x25_forward *fwd, *tmp;\n\n\twrite_lock_bh(&x25_forward_list_lock);\n\n\tlist_for_each_entry_safe(fwd, tmp, &x25_forward_list, node) {\n\t\tif ((fwd->dev1 == dev) || (fwd->dev2 == dev)){\n\t\t\tlist_del(&fwd->node);\n\t\t\tkfree(fwd);\n\t\t}\n\t}\n\twrite_unlock_bh(&x25_forward_list_lock);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}