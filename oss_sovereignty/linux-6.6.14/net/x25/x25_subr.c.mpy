{
  "module_name": "x25_subr.c",
  "hash_id": "5ad135e0694a4c4206ddde67c0fa552f0b72f10f01694a92b65061b5caf9155c",
  "original_prompt": "Ingested from linux-6.6.14/net/x25/x25_subr.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"X25: \" fmt\n\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/skbuff.h>\n#include <net/sock.h>\n#include <net/tcp_states.h>\n#include <net/x25.h>\n\n \nvoid x25_clear_queues(struct sock *sk)\n{\n\tstruct x25_sock *x25 = x25_sk(sk);\n\n\tskb_queue_purge(&sk->sk_write_queue);\n\tskb_queue_purge(&x25->ack_queue);\n\tskb_queue_purge(&x25->interrupt_in_queue);\n\tskb_queue_purge(&x25->interrupt_out_queue);\n\tskb_queue_purge(&x25->fragment_queue);\n}\n\n\n \nvoid x25_frames_acked(struct sock *sk, unsigned short nr)\n{\n\tstruct sk_buff *skb;\n\tstruct x25_sock *x25 = x25_sk(sk);\n\tint modulus = x25->neighbour->extended ? X25_EMODULUS : X25_SMODULUS;\n\n\t \n\tif (x25->va != nr)\n\t\twhile (skb_peek(&x25->ack_queue) && x25->va != nr) {\n\t\t\tskb = skb_dequeue(&x25->ack_queue);\n\t\t\tkfree_skb(skb);\n\t\t\tx25->va = (x25->va + 1) % modulus;\n\t\t}\n}\n\nvoid x25_requeue_frames(struct sock *sk)\n{\n\tstruct sk_buff *skb, *skb_prev = NULL;\n\n\t \n\twhile ((skb = skb_dequeue(&x25_sk(sk)->ack_queue)) != NULL) {\n\t\tif (!skb_prev)\n\t\t\tskb_queue_head(&sk->sk_write_queue, skb);\n\t\telse\n\t\t\tskb_append(skb_prev, skb, &sk->sk_write_queue);\n\t\tskb_prev = skb;\n\t}\n}\n\n \nint x25_validate_nr(struct sock *sk, unsigned short nr)\n{\n\tstruct x25_sock *x25 = x25_sk(sk);\n\tunsigned short vc = x25->va;\n\tint modulus = x25->neighbour->extended ? X25_EMODULUS : X25_SMODULUS;\n\n\twhile (vc != x25->vs) {\n\t\tif (nr == vc)\n\t\t\treturn 1;\n\t\tvc = (vc + 1) % modulus;\n\t}\n\n\treturn nr == x25->vs ? 1 : 0;\n}\n\n \nvoid x25_write_internal(struct sock *sk, int frametype)\n{\n\tstruct x25_sock *x25 = x25_sk(sk);\n\tstruct sk_buff *skb;\n\tunsigned char  *dptr;\n\tunsigned char  facilities[X25_MAX_FAC_LEN];\n\tunsigned char  addresses[1 + X25_ADDR_LEN];\n\tunsigned char  lci1, lci2;\n\t \n\tint len = X25_MAX_L2_LEN + X25_EXT_MIN_LEN;\n\n\t \n\tswitch (frametype) {\n\tcase X25_CALL_REQUEST:\n\t\tlen += 1 + X25_ADDR_LEN + X25_MAX_FAC_LEN + X25_MAX_CUD_LEN;\n\t\tbreak;\n\tcase X25_CALL_ACCEPTED:  \n\t\tif (x25->facilities.reverse & 0x80) {\n\t\t\tlen += 1 + X25_MAX_FAC_LEN + X25_MAX_CUD_LEN;\n\t\t} else {\n\t\t\tlen += 1 + X25_MAX_FAC_LEN;\n\t\t}\n\t\tbreak;\n\tcase X25_CLEAR_REQUEST:\n\tcase X25_RESET_REQUEST:\n\t\tlen += 2;\n\t\tbreak;\n\tcase X25_RR:\n\tcase X25_RNR:\n\tcase X25_REJ:\n\tcase X25_CLEAR_CONFIRMATION:\n\tcase X25_INTERRUPT_CONFIRMATION:\n\tcase X25_RESET_CONFIRMATION:\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"invalid frame type %02X\\n\", frametype);\n\t\treturn;\n\t}\n\n\tif ((skb = alloc_skb(len, GFP_ATOMIC)) == NULL)\n\t\treturn;\n\n\t \n\tskb_reserve(skb, X25_MAX_L2_LEN);\n\n\t \n\tdptr = skb_put(skb, 2);\n\n\tlci1 = (x25->lci >> 8) & 0x0F;\n\tlci2 = (x25->lci >> 0) & 0xFF;\n\n\tif (x25->neighbour->extended) {\n\t\t*dptr++ = lci1 | X25_GFI_EXTSEQ;\n\t\t*dptr++ = lci2;\n\t} else {\n\t\t*dptr++ = lci1 | X25_GFI_STDSEQ;\n\t\t*dptr++ = lci2;\n\t}\n\n\t \n\tswitch (frametype) {\n\n\t\tcase X25_CALL_REQUEST:\n\t\t\tdptr    = skb_put(skb, 1);\n\t\t\t*dptr++ = X25_CALL_REQUEST;\n\t\t\tlen     = x25_addr_aton(addresses, &x25->dest_addr,\n\t\t\t\t\t\t&x25->source_addr);\n\t\t\tskb_put_data(skb, addresses, len);\n\t\t\tlen     = x25_create_facilities(facilities,\n\t\t\t\t\t&x25->facilities,\n\t\t\t\t\t&x25->dte_facilities,\n\t\t\t\t\tx25->neighbour->global_facil_mask);\n\t\t\tskb_put_data(skb, facilities, len);\n\t\t\tskb_put_data(skb, x25->calluserdata.cuddata,\n\t\t\t\t     x25->calluserdata.cudlength);\n\t\t\tx25->calluserdata.cudlength = 0;\n\t\t\tbreak;\n\n\t\tcase X25_CALL_ACCEPTED:\n\t\t\tdptr    = skb_put(skb, 2);\n\t\t\t*dptr++ = X25_CALL_ACCEPTED;\n\t\t\t*dptr++ = 0x00;\t\t \n\t\t\tlen     = x25_create_facilities(facilities,\n\t\t\t\t\t\t\t&x25->facilities,\n\t\t\t\t\t\t\t&x25->dte_facilities,\n\t\t\t\t\t\t\tx25->vc_facil_mask);\n\t\t\tskb_put_data(skb, facilities, len);\n\n\t\t\t \n\t\t\tif(x25->facilities.reverse & 0x80) {\n\t\t\t\tskb_put_data(skb,\n\t\t\t\t\t     x25->calluserdata.cuddata,\n\t\t\t\t\t     x25->calluserdata.cudlength);\n\t\t\t}\n\t\t\tx25->calluserdata.cudlength = 0;\n\t\t\tbreak;\n\n\t\tcase X25_CLEAR_REQUEST:\n\t\t\tdptr    = skb_put(skb, 3);\n\t\t\t*dptr++ = frametype;\n\t\t\t*dptr++ = x25->causediag.cause;\n\t\t\t*dptr++ = x25->causediag.diagnostic;\n\t\t\tbreak;\n\n\t\tcase X25_RESET_REQUEST:\n\t\t\tdptr    = skb_put(skb, 3);\n\t\t\t*dptr++ = frametype;\n\t\t\t*dptr++ = 0x00;\t\t \n\t\t\t*dptr++ = 0x00;\t\t \n\t\t\tbreak;\n\n\t\tcase X25_RR:\n\t\tcase X25_RNR:\n\t\tcase X25_REJ:\n\t\t\tif (x25->neighbour->extended) {\n\t\t\t\tdptr     = skb_put(skb, 2);\n\t\t\t\t*dptr++  = frametype;\n\t\t\t\t*dptr++  = (x25->vr << 1) & 0xFE;\n\t\t\t} else {\n\t\t\t\tdptr     = skb_put(skb, 1);\n\t\t\t\t*dptr    = frametype;\n\t\t\t\t*dptr++ |= (x25->vr << 5) & 0xE0;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase X25_CLEAR_CONFIRMATION:\n\t\tcase X25_INTERRUPT_CONFIRMATION:\n\t\tcase X25_RESET_CONFIRMATION:\n\t\t\tdptr  = skb_put(skb, 1);\n\t\t\t*dptr = frametype;\n\t\t\tbreak;\n\t}\n\n\tx25_transmit_link(skb, x25->neighbour);\n}\n\n \nint x25_decode(struct sock *sk, struct sk_buff *skb, int *ns, int *nr, int *q,\n\t       int *d, int *m)\n{\n\tstruct x25_sock *x25 = x25_sk(sk);\n\tunsigned char *frame;\n\n\tif (!pskb_may_pull(skb, X25_STD_MIN_LEN))\n\t\treturn X25_ILLEGAL;\n\tframe = skb->data;\n\n\t*ns = *nr = *q = *d = *m = 0;\n\n\tswitch (frame[2]) {\n\tcase X25_CALL_REQUEST:\n\tcase X25_CALL_ACCEPTED:\n\tcase X25_CLEAR_REQUEST:\n\tcase X25_CLEAR_CONFIRMATION:\n\tcase X25_INTERRUPT:\n\tcase X25_INTERRUPT_CONFIRMATION:\n\tcase X25_RESET_REQUEST:\n\tcase X25_RESET_CONFIRMATION:\n\tcase X25_RESTART_REQUEST:\n\tcase X25_RESTART_CONFIRMATION:\n\tcase X25_REGISTRATION_REQUEST:\n\tcase X25_REGISTRATION_CONFIRMATION:\n\tcase X25_DIAGNOSTIC:\n\t\treturn frame[2];\n\t}\n\n\tif (x25->neighbour->extended) {\n\t\tif (frame[2] == X25_RR  ||\n\t\t    frame[2] == X25_RNR ||\n\t\t    frame[2] == X25_REJ) {\n\t\t\tif (!pskb_may_pull(skb, X25_EXT_MIN_LEN))\n\t\t\t\treturn X25_ILLEGAL;\n\t\t\tframe = skb->data;\n\n\t\t\t*nr = (frame[3] >> 1) & 0x7F;\n\t\t\treturn frame[2];\n\t\t}\n\t} else {\n\t\tif ((frame[2] & 0x1F) == X25_RR  ||\n\t\t    (frame[2] & 0x1F) == X25_RNR ||\n\t\t    (frame[2] & 0x1F) == X25_REJ) {\n\t\t\t*nr = (frame[2] >> 5) & 0x07;\n\t\t\treturn frame[2] & 0x1F;\n\t\t}\n\t}\n\n\tif (x25->neighbour->extended) {\n\t\tif ((frame[2] & 0x01) == X25_DATA) {\n\t\t\tif (!pskb_may_pull(skb, X25_EXT_MIN_LEN))\n\t\t\t\treturn X25_ILLEGAL;\n\t\t\tframe = skb->data;\n\n\t\t\t*q  = (frame[0] & X25_Q_BIT) == X25_Q_BIT;\n\t\t\t*d  = (frame[0] & X25_D_BIT) == X25_D_BIT;\n\t\t\t*m  = (frame[3] & X25_EXT_M_BIT) == X25_EXT_M_BIT;\n\t\t\t*nr = (frame[3] >> 1) & 0x7F;\n\t\t\t*ns = (frame[2] >> 1) & 0x7F;\n\t\t\treturn X25_DATA;\n\t\t}\n\t} else {\n\t\tif ((frame[2] & 0x01) == X25_DATA) {\n\t\t\t*q  = (frame[0] & X25_Q_BIT) == X25_Q_BIT;\n\t\t\t*d  = (frame[0] & X25_D_BIT) == X25_D_BIT;\n\t\t\t*m  = (frame[2] & X25_STD_M_BIT) == X25_STD_M_BIT;\n\t\t\t*nr = (frame[2] >> 5) & 0x07;\n\t\t\t*ns = (frame[2] >> 1) & 0x07;\n\t\t\treturn X25_DATA;\n\t\t}\n\t}\n\n\tpr_debug(\"invalid PLP frame %3ph\\n\", frame);\n\n\treturn X25_ILLEGAL;\n}\n\nvoid x25_disconnect(struct sock *sk, int reason, unsigned char cause,\n\t\t    unsigned char diagnostic)\n{\n\tstruct x25_sock *x25 = x25_sk(sk);\n\n\tx25_clear_queues(sk);\n\tx25_stop_timer(sk);\n\n\tx25->lci   = 0;\n\tx25->state = X25_STATE_0;\n\n\tx25->causediag.cause      = cause;\n\tx25->causediag.diagnostic = diagnostic;\n\n\tsk->sk_state     = TCP_CLOSE;\n\tsk->sk_err       = reason;\n\tsk->sk_shutdown |= SEND_SHUTDOWN;\n\n\tif (!sock_flag(sk, SOCK_DEAD)) {\n\t\tsk->sk_state_change(sk);\n\t\tsock_set_flag(sk, SOCK_DEAD);\n\t}\n\tif (x25->neighbour) {\n\t\tread_lock_bh(&x25_list_lock);\n\t\tx25_neigh_put(x25->neighbour);\n\t\tx25->neighbour = NULL;\n\t\tread_unlock_bh(&x25_list_lock);\n\t}\n}\n\n \nvoid x25_check_rbuf(struct sock *sk)\n{\n\tstruct x25_sock *x25 = x25_sk(sk);\n\n\tif (atomic_read(&sk->sk_rmem_alloc) < (sk->sk_rcvbuf >> 1) &&\n\t    (x25->condition & X25_COND_OWN_RX_BUSY)) {\n\t\tx25->condition &= ~X25_COND_OWN_RX_BUSY;\n\t\tx25->condition &= ~X25_COND_ACK_PENDING;\n\t\tx25->vl         = x25->vr;\n\t\tx25_write_internal(sk, X25_RR);\n\t\tx25_stop_timer(sk);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}