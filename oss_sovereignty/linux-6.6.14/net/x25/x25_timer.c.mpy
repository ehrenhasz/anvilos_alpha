{
  "module_name": "x25_timer.c",
  "hash_id": "0b52c2f6629bb8add78c2c84bee3bd5c4fcb9f997ecdfdd34a38f290f4348f4b",
  "original_prompt": "Ingested from linux-6.6.14/net/x25/x25_timer.c",
  "human_readable_source": "\n \n\n#include <linux/errno.h>\n#include <linux/jiffies.h>\n#include <linux/timer.h>\n#include <net/sock.h>\n#include <net/tcp_states.h>\n#include <net/x25.h>\n\nstatic void x25_heartbeat_expiry(struct timer_list *t);\nstatic void x25_timer_expiry(struct timer_list *t);\n\nvoid x25_init_timers(struct sock *sk)\n{\n\tstruct x25_sock *x25 = x25_sk(sk);\n\n\ttimer_setup(&x25->timer, x25_timer_expiry, 0);\n\n\t \n\tsk->sk_timer.function = x25_heartbeat_expiry;\n}\n\nvoid x25_start_heartbeat(struct sock *sk)\n{\n\tmod_timer(&sk->sk_timer, jiffies + 5 * HZ);\n}\n\nvoid x25_stop_heartbeat(struct sock *sk)\n{\n\tdel_timer(&sk->sk_timer);\n}\n\nvoid x25_start_t2timer(struct sock *sk)\n{\n\tstruct x25_sock *x25 = x25_sk(sk);\n\n\tmod_timer(&x25->timer, jiffies + x25->t2);\n}\n\nvoid x25_start_t21timer(struct sock *sk)\n{\n\tstruct x25_sock *x25 = x25_sk(sk);\n\n\tmod_timer(&x25->timer, jiffies + x25->t21);\n}\n\nvoid x25_start_t22timer(struct sock *sk)\n{\n\tstruct x25_sock *x25 = x25_sk(sk);\n\n\tmod_timer(&x25->timer, jiffies + x25->t22);\n}\n\nvoid x25_start_t23timer(struct sock *sk)\n{\n\tstruct x25_sock *x25 = x25_sk(sk);\n\n\tmod_timer(&x25->timer, jiffies + x25->t23);\n}\n\nvoid x25_stop_timer(struct sock *sk)\n{\n\tdel_timer(&x25_sk(sk)->timer);\n}\n\nunsigned long x25_display_timer(struct sock *sk)\n{\n\tstruct x25_sock *x25 = x25_sk(sk);\n\n\tif (!timer_pending(&x25->timer))\n\t\treturn 0;\n\n\treturn x25->timer.expires - jiffies;\n}\n\nstatic void x25_heartbeat_expiry(struct timer_list *t)\n{\n\tstruct sock *sk = from_timer(sk, t, sk_timer);\n\n\tbh_lock_sock(sk);\n\tif (sock_owned_by_user(sk))  \n\t\tgoto restart_heartbeat;\n\n\tswitch (x25_sk(sk)->state) {\n\n\t\tcase X25_STATE_0:\n\t\t\t \n\t\t\tif (sock_flag(sk, SOCK_DESTROY) ||\n\t\t\t    (sk->sk_state == TCP_LISTEN &&\n\t\t\t     sock_flag(sk, SOCK_DEAD))) {\n\t\t\t\tbh_unlock_sock(sk);\n\t\t\t\tx25_destroy_socket_from_timer(sk);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase X25_STATE_3:\n\t\t\t \n\t\t\tx25_check_rbuf(sk);\n\t\t\tbreak;\n\t}\nrestart_heartbeat:\n\tx25_start_heartbeat(sk);\n\tbh_unlock_sock(sk);\n}\n\n \nstatic inline void x25_do_timer_expiry(struct sock * sk)\n{\n\tstruct x25_sock *x25 = x25_sk(sk);\n\n\tswitch (x25->state) {\n\n\t\tcase X25_STATE_3:\t \n\t\t\tif (x25->condition & X25_COND_ACK_PENDING) {\n\t\t\t\tx25->condition &= ~X25_COND_ACK_PENDING;\n\t\t\t\tx25_enquiry_response(sk);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase X25_STATE_1:\t \n\t\tcase X25_STATE_4:\t \n\t\t\tx25_write_internal(sk, X25_CLEAR_REQUEST);\n\t\t\tx25->state = X25_STATE_2;\n\t\t\tx25_start_t23timer(sk);\n\t\t\tbreak;\n\n\t\tcase X25_STATE_2:\t \n\t\t\tx25_disconnect(sk, ETIMEDOUT, 0, 0);\n\t\t\tbreak;\n\t}\n}\n\nstatic void x25_timer_expiry(struct timer_list *t)\n{\n\tstruct x25_sock *x25 = from_timer(x25, t, timer);\n\tstruct sock *sk = &x25->sk;\n\n\tbh_lock_sock(sk);\n\tif (sock_owned_by_user(sk)) {  \n\t\tif (x25_sk(sk)->state == X25_STATE_3)\n\t\t\tx25_start_t2timer(sk);\n\t} else\n\t\tx25_do_timer_expiry(sk);\n\tbh_unlock_sock(sk);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}