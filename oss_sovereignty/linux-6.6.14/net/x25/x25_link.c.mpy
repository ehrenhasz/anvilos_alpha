{
  "module_name": "x25_link.c",
  "hash_id": "71ac9135628d5cfcf9cce09cadf861ba5cb722efb5adc7b5e4b17c3776d74966",
  "original_prompt": "Ingested from linux-6.6.14/net/x25/x25_link.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"X25: \" fmt\n\n#include <linux/kernel.h>\n#include <linux/jiffies.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/netdevice.h>\n#include <linux/skbuff.h>\n#include <linux/uaccess.h>\n#include <linux/init.h>\n#include <net/x25.h>\n\nLIST_HEAD(x25_neigh_list);\nDEFINE_RWLOCK(x25_neigh_list_lock);\n\nstatic void x25_t20timer_expiry(struct timer_list *);\n\nstatic void x25_transmit_restart_confirmation(struct x25_neigh *nb);\nstatic void x25_transmit_restart_request(struct x25_neigh *nb);\n\n \nstatic inline void x25_start_t20timer(struct x25_neigh *nb)\n{\n\tmod_timer(&nb->t20timer, jiffies + nb->t20);\n}\n\nstatic void x25_t20timer_expiry(struct timer_list *t)\n{\n\tstruct x25_neigh *nb = from_timer(nb, t, t20timer);\n\n\tx25_transmit_restart_request(nb);\n\n\tx25_start_t20timer(nb);\n}\n\nstatic inline void x25_stop_t20timer(struct x25_neigh *nb)\n{\n\tdel_timer(&nb->t20timer);\n}\n\n \nvoid x25_link_control(struct sk_buff *skb, struct x25_neigh *nb,\n\t\t      unsigned short frametype)\n{\n\tstruct sk_buff *skbn;\n\n\tswitch (frametype) {\n\tcase X25_RESTART_REQUEST:\n\t\tswitch (nb->state) {\n\t\tcase X25_LINK_STATE_0:\n\t\t\t \n\t\t\tnb->state = X25_LINK_STATE_3;\n\t\t\tx25_transmit_restart_confirmation(nb);\n\t\t\tbreak;\n\t\tcase X25_LINK_STATE_2:\n\t\t\tx25_stop_t20timer(nb);\n\t\t\tnb->state = X25_LINK_STATE_3;\n\t\t\tbreak;\n\t\tcase X25_LINK_STATE_3:\n\t\t\t \n\t\t\tx25_kill_by_neigh(nb);\n\n\t\t\tx25_transmit_restart_confirmation(nb);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase X25_RESTART_CONFIRMATION:\n\t\tswitch (nb->state) {\n\t\tcase X25_LINK_STATE_2:\n\t\t\tx25_stop_t20timer(nb);\n\t\t\tnb->state = X25_LINK_STATE_3;\n\t\t\tbreak;\n\t\tcase X25_LINK_STATE_3:\n\t\t\t \n\t\t\tx25_kill_by_neigh(nb);\n\n\t\t\tx25_transmit_restart_request(nb);\n\t\t\tnb->state = X25_LINK_STATE_2;\n\t\t\tx25_start_t20timer(nb);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase X25_DIAGNOSTIC:\n\t\tif (!pskb_may_pull(skb, X25_STD_MIN_LEN + 4))\n\t\t\tbreak;\n\n\t\tpr_warn(\"diagnostic #%d - %02X %02X %02X\\n\",\n\t\t       skb->data[3], skb->data[4],\n\t\t       skb->data[5], skb->data[6]);\n\t\tbreak;\n\n\tdefault:\n\t\tpr_warn(\"received unknown %02X with LCI 000\\n\",\n\t\t       frametype);\n\t\tbreak;\n\t}\n\n\tif (nb->state == X25_LINK_STATE_3)\n\t\twhile ((skbn = skb_dequeue(&nb->queue)) != NULL)\n\t\t\tx25_send_frame(skbn, nb);\n}\n\n \nstatic void x25_transmit_restart_request(struct x25_neigh *nb)\n{\n\tunsigned char *dptr;\n\tint len = X25_MAX_L2_LEN + X25_STD_MIN_LEN + 2;\n\tstruct sk_buff *skb = alloc_skb(len, GFP_ATOMIC);\n\n\tif (!skb)\n\t\treturn;\n\n\tskb_reserve(skb, X25_MAX_L2_LEN);\n\n\tdptr = skb_put(skb, X25_STD_MIN_LEN + 2);\n\n\t*dptr++ = nb->extended ? X25_GFI_EXTSEQ : X25_GFI_STDSEQ;\n\t*dptr++ = 0x00;\n\t*dptr++ = X25_RESTART_REQUEST;\n\t*dptr++ = 0x00;\n\t*dptr++ = 0;\n\n\tskb->sk = NULL;\n\n\tx25_send_frame(skb, nb);\n}\n\n \nstatic void x25_transmit_restart_confirmation(struct x25_neigh *nb)\n{\n\tunsigned char *dptr;\n\tint len = X25_MAX_L2_LEN + X25_STD_MIN_LEN;\n\tstruct sk_buff *skb = alloc_skb(len, GFP_ATOMIC);\n\n\tif (!skb)\n\t\treturn;\n\n\tskb_reserve(skb, X25_MAX_L2_LEN);\n\n\tdptr = skb_put(skb, X25_STD_MIN_LEN);\n\n\t*dptr++ = nb->extended ? X25_GFI_EXTSEQ : X25_GFI_STDSEQ;\n\t*dptr++ = 0x00;\n\t*dptr++ = X25_RESTART_CONFIRMATION;\n\n\tskb->sk = NULL;\n\n\tx25_send_frame(skb, nb);\n}\n\n \nvoid x25_transmit_clear_request(struct x25_neigh *nb, unsigned int lci,\n\t\t\t\tunsigned char cause)\n{\n\tunsigned char *dptr;\n\tint len = X25_MAX_L2_LEN + X25_STD_MIN_LEN + 2;\n\tstruct sk_buff *skb = alloc_skb(len, GFP_ATOMIC);\n\n\tif (!skb)\n\t\treturn;\n\n\tskb_reserve(skb, X25_MAX_L2_LEN);\n\n\tdptr = skb_put(skb, X25_STD_MIN_LEN + 2);\n\n\t*dptr++ = ((lci >> 8) & 0x0F) | (nb->extended ?\n\t\t\t\t\t X25_GFI_EXTSEQ :\n\t\t\t\t\t X25_GFI_STDSEQ);\n\t*dptr++ = (lci >> 0) & 0xFF;\n\t*dptr++ = X25_CLEAR_REQUEST;\n\t*dptr++ = cause;\n\t*dptr++ = 0x00;\n\n\tskb->sk = NULL;\n\n\tx25_send_frame(skb, nb);\n}\n\nvoid x25_transmit_link(struct sk_buff *skb, struct x25_neigh *nb)\n{\n\tswitch (nb->state) {\n\tcase X25_LINK_STATE_0:\n\t\tskb_queue_tail(&nb->queue, skb);\n\t\tnb->state = X25_LINK_STATE_1;\n\t\tx25_establish_link(nb);\n\t\tbreak;\n\tcase X25_LINK_STATE_1:\n\tcase X25_LINK_STATE_2:\n\t\tskb_queue_tail(&nb->queue, skb);\n\t\tbreak;\n\tcase X25_LINK_STATE_3:\n\t\tx25_send_frame(skb, nb);\n\t\tbreak;\n\t}\n}\n\n \nvoid x25_link_established(struct x25_neigh *nb)\n{\n\tswitch (nb->state) {\n\tcase X25_LINK_STATE_0:\n\tcase X25_LINK_STATE_1:\n\t\tx25_transmit_restart_request(nb);\n\t\tnb->state = X25_LINK_STATE_2;\n\t\tx25_start_t20timer(nb);\n\t\tbreak;\n\t}\n}\n\n \n\nvoid x25_link_terminated(struct x25_neigh *nb)\n{\n\tnb->state = X25_LINK_STATE_0;\n\tskb_queue_purge(&nb->queue);\n\tx25_stop_t20timer(nb);\n\n\t \n\tx25_kill_by_neigh(nb);\n}\n\n \nvoid x25_link_device_up(struct net_device *dev)\n{\n\tstruct x25_neigh *nb = kmalloc(sizeof(*nb), GFP_ATOMIC);\n\n\tif (!nb)\n\t\treturn;\n\n\tskb_queue_head_init(&nb->queue);\n\ttimer_setup(&nb->t20timer, x25_t20timer_expiry, 0);\n\n\tdev_hold(dev);\n\tnb->dev      = dev;\n\tnb->state    = X25_LINK_STATE_0;\n\tnb->extended = 0;\n\t \n\tnb->global_facil_mask = X25_MASK_REVERSE |\n\t\t\t\t       X25_MASK_THROUGHPUT |\n\t\t\t\t       X25_MASK_PACKET_SIZE |\n\t\t\t\t       X25_MASK_WINDOW_SIZE;\n\tnb->t20      = sysctl_x25_restart_request_timeout;\n\trefcount_set(&nb->refcnt, 1);\n\n\twrite_lock_bh(&x25_neigh_list_lock);\n\tlist_add(&nb->node, &x25_neigh_list);\n\twrite_unlock_bh(&x25_neigh_list_lock);\n}\n\n \nstatic void __x25_remove_neigh(struct x25_neigh *nb)\n{\n\tif (nb->node.next) {\n\t\tlist_del(&nb->node);\n\t\tx25_neigh_put(nb);\n\t}\n}\n\n \nvoid x25_link_device_down(struct net_device *dev)\n{\n\tstruct x25_neigh *nb;\n\tstruct list_head *entry, *tmp;\n\n\twrite_lock_bh(&x25_neigh_list_lock);\n\n\tlist_for_each_safe(entry, tmp, &x25_neigh_list) {\n\t\tnb = list_entry(entry, struct x25_neigh, node);\n\n\t\tif (nb->dev == dev) {\n\t\t\t__x25_remove_neigh(nb);\n\t\t\tdev_put(dev);\n\t\t}\n\t}\n\n\twrite_unlock_bh(&x25_neigh_list_lock);\n}\n\n \nstruct x25_neigh *x25_get_neigh(struct net_device *dev)\n{\n\tstruct x25_neigh *nb, *use = NULL;\n\n\tread_lock_bh(&x25_neigh_list_lock);\n\tlist_for_each_entry(nb, &x25_neigh_list, node) {\n\t\tif (nb->dev == dev) {\n\t\t\tuse = nb;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (use)\n\t\tx25_neigh_hold(use);\n\tread_unlock_bh(&x25_neigh_list_lock);\n\treturn use;\n}\n\n \nint x25_subscr_ioctl(unsigned int cmd, void __user *arg)\n{\n\tstruct x25_subscrip_struct x25_subscr;\n\tstruct x25_neigh *nb;\n\tstruct net_device *dev;\n\tint rc = -EINVAL;\n\n\tif (cmd != SIOCX25GSUBSCRIP && cmd != SIOCX25SSUBSCRIP)\n\t\tgoto out;\n\n\trc = -EFAULT;\n\tif (copy_from_user(&x25_subscr, arg, sizeof(x25_subscr)))\n\t\tgoto out;\n\n\trc = -EINVAL;\n\tif ((dev = x25_dev_get(x25_subscr.device)) == NULL)\n\t\tgoto out;\n\n\tif ((nb = x25_get_neigh(dev)) == NULL)\n\t\tgoto out_dev_put;\n\n\tdev_put(dev);\n\n\tif (cmd == SIOCX25GSUBSCRIP) {\n\t\tread_lock_bh(&x25_neigh_list_lock);\n\t\tx25_subscr.extended\t     = nb->extended;\n\t\tx25_subscr.global_facil_mask = nb->global_facil_mask;\n\t\tread_unlock_bh(&x25_neigh_list_lock);\n\t\trc = copy_to_user(arg, &x25_subscr,\n\t\t\t\t  sizeof(x25_subscr)) ? -EFAULT : 0;\n\t} else {\n\t\trc = -EINVAL;\n\t\tif (!(x25_subscr.extended && x25_subscr.extended != 1)) {\n\t\t\trc = 0;\n\t\t\twrite_lock_bh(&x25_neigh_list_lock);\n\t\t\tnb->extended\t     = x25_subscr.extended;\n\t\t\tnb->global_facil_mask = x25_subscr.global_facil_mask;\n\t\t\twrite_unlock_bh(&x25_neigh_list_lock);\n\t\t}\n\t}\n\tx25_neigh_put(nb);\nout:\n\treturn rc;\nout_dev_put:\n\tdev_put(dev);\n\tgoto out;\n}\n\n\n \nvoid __exit x25_link_free(void)\n{\n\tstruct x25_neigh *nb;\n\tstruct list_head *entry, *tmp;\n\n\twrite_lock_bh(&x25_neigh_list_lock);\n\n\tlist_for_each_safe(entry, tmp, &x25_neigh_list) {\n\t\tstruct net_device *dev;\n\n\t\tnb = list_entry(entry, struct x25_neigh, node);\n\t\tdev = nb->dev;\n\t\t__x25_remove_neigh(nb);\n\t\tdev_put(dev);\n\t}\n\twrite_unlock_bh(&x25_neigh_list_lock);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}