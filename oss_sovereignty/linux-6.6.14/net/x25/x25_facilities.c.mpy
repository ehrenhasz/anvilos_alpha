{
  "module_name": "x25_facilities.c",
  "hash_id": "d134b0355018008777a4bfe3a82385493ca19ed07d2989e4da9b8fe570424cbf",
  "original_prompt": "Ingested from linux-6.6.14/net/x25/x25_facilities.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"X25: \" fmt\n\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/skbuff.h>\n#include <net/sock.h>\n#include <net/x25.h>\n\n \nint x25_parse_facilities(struct sk_buff *skb, struct x25_facilities *facilities,\n\t\tstruct x25_dte_facilities *dte_facs, unsigned long *vc_fac_mask)\n{\n\tunsigned char *p;\n\tunsigned int len;\n\n\t*vc_fac_mask = 0;\n\n\t \n\tdte_facs->calling_len = 0;\n\tdte_facs->called_len = 0;\n\tmemset(dte_facs->called_ae, '\\0', sizeof(dte_facs->called_ae));\n\tmemset(dte_facs->calling_ae, '\\0', sizeof(dte_facs->calling_ae));\n\n\tif (!pskb_may_pull(skb, 1))\n\t\treturn 0;\n\n\tlen = skb->data[0];\n\n\tif (!pskb_may_pull(skb, 1 + len))\n\t\treturn -1;\n\n\tp = skb->data + 1;\n\n\twhile (len > 0) {\n\t\tswitch (*p & X25_FAC_CLASS_MASK) {\n\t\tcase X25_FAC_CLASS_A:\n\t\t\tif (len < 2)\n\t\t\t\treturn -1;\n\t\t\tswitch (*p) {\n\t\t\tcase X25_FAC_REVERSE:\n\t\t\t\tif((p[1] & 0x81) == 0x81) {\n\t\t\t\t\tfacilities->reverse = p[1] & 0x81;\n\t\t\t\t\t*vc_fac_mask |= X25_MASK_REVERSE;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif((p[1] & 0x01) == 0x01) {\n\t\t\t\t\tfacilities->reverse = p[1] & 0x01;\n\t\t\t\t\t*vc_fac_mask |= X25_MASK_REVERSE;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif((p[1] & 0x80) == 0x80) {\n\t\t\t\t\tfacilities->reverse = p[1] & 0x80;\n\t\t\t\t\t*vc_fac_mask |= X25_MASK_REVERSE;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif(p[1] == 0x00) {\n\t\t\t\t\tfacilities->reverse\n\t\t\t\t\t\t= X25_DEFAULT_REVERSE;\n\t\t\t\t\t*vc_fac_mask |= X25_MASK_REVERSE;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfallthrough;\n\t\t\tcase X25_FAC_THROUGHPUT:\n\t\t\t\tfacilities->throughput = p[1];\n\t\t\t\t*vc_fac_mask |= X25_MASK_THROUGHPUT;\n\t\t\t\tbreak;\n\t\t\tcase X25_MARKER:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tpr_debug(\"unknown facility \"\n\t\t\t\t       \"%02X, value %02X\\n\",\n\t\t\t\t       p[0], p[1]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tp   += 2;\n\t\t\tlen -= 2;\n\t\t\tbreak;\n\t\tcase X25_FAC_CLASS_B:\n\t\t\tif (len < 3)\n\t\t\t\treturn -1;\n\t\t\tswitch (*p) {\n\t\t\tcase X25_FAC_PACKET_SIZE:\n\t\t\t\tfacilities->pacsize_in  = p[1];\n\t\t\t\tfacilities->pacsize_out = p[2];\n\t\t\t\t*vc_fac_mask |= X25_MASK_PACKET_SIZE;\n\t\t\t\tbreak;\n\t\t\tcase X25_FAC_WINDOW_SIZE:\n\t\t\t\tfacilities->winsize_in  = p[1];\n\t\t\t\tfacilities->winsize_out = p[2];\n\t\t\t\t*vc_fac_mask |= X25_MASK_WINDOW_SIZE;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tpr_debug(\"unknown facility \"\n\t\t\t\t       \"%02X, values %02X, %02X\\n\",\n\t\t\t\t       p[0], p[1], p[2]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tp   += 3;\n\t\t\tlen -= 3;\n\t\t\tbreak;\n\t\tcase X25_FAC_CLASS_C:\n\t\t\tif (len < 4)\n\t\t\t\treturn -1;\n\t\t\tpr_debug(\"unknown facility %02X, \"\n\t\t\t       \"values %02X, %02X, %02X\\n\",\n\t\t\t       p[0], p[1], p[2], p[3]);\n\t\t\tp   += 4;\n\t\t\tlen -= 4;\n\t\t\tbreak;\n\t\tcase X25_FAC_CLASS_D:\n\t\t\tif (len < p[1] + 2)\n\t\t\t\treturn -1;\n\t\t\tswitch (*p) {\n\t\t\tcase X25_FAC_CALLING_AE:\n\t\t\t\tif (p[1] > X25_MAX_DTE_FACIL_LEN || p[1] <= 1)\n\t\t\t\t\treturn -1;\n\t\t\t\tif (p[2] > X25_MAX_AE_LEN)\n\t\t\t\t\treturn -1;\n\t\t\t\tdte_facs->calling_len = p[2];\n\t\t\t\tmemcpy(dte_facs->calling_ae, &p[3], p[1] - 1);\n\t\t\t\t*vc_fac_mask |= X25_MASK_CALLING_AE;\n\t\t\t\tbreak;\n\t\t\tcase X25_FAC_CALLED_AE:\n\t\t\t\tif (p[1] > X25_MAX_DTE_FACIL_LEN || p[1] <= 1)\n\t\t\t\t\treturn -1;\n\t\t\t\tif (p[2] > X25_MAX_AE_LEN)\n\t\t\t\t\treturn -1;\n\t\t\t\tdte_facs->called_len = p[2];\n\t\t\t\tmemcpy(dte_facs->called_ae, &p[3], p[1] - 1);\n\t\t\t\t*vc_fac_mask |= X25_MASK_CALLED_AE;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tpr_debug(\"unknown facility %02X,\"\n\t\t\t\t\t\"length %d\\n\", p[0], p[1]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tlen -= p[1] + 2;\n\t\t\tp += p[1] + 2;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn p - skb->data;\n}\n\n \nint x25_create_facilities(unsigned char *buffer,\n\t\tstruct x25_facilities *facilities,\n\t\tstruct x25_dte_facilities *dte_facs, unsigned long facil_mask)\n{\n\tunsigned char *p = buffer + 1;\n\tint len;\n\n\tif (!facil_mask) {\n\t\t \n\t\tbuffer[0] = 0;\n\t\tlen = 1;  \n\t\treturn len;\n\t}\n\n\tif (facilities->reverse && (facil_mask & X25_MASK_REVERSE)) {\n\t\t*p++ = X25_FAC_REVERSE;\n\t\t*p++ = facilities->reverse;\n\t}\n\n\tif (facilities->throughput && (facil_mask & X25_MASK_THROUGHPUT)) {\n\t\t*p++ = X25_FAC_THROUGHPUT;\n\t\t*p++ = facilities->throughput;\n\t}\n\n\tif ((facilities->pacsize_in || facilities->pacsize_out) &&\n\t    (facil_mask & X25_MASK_PACKET_SIZE)) {\n\t\t*p++ = X25_FAC_PACKET_SIZE;\n\t\t*p++ = facilities->pacsize_in ? : facilities->pacsize_out;\n\t\t*p++ = facilities->pacsize_out ? : facilities->pacsize_in;\n\t}\n\n\tif ((facilities->winsize_in || facilities->winsize_out) &&\n\t    (facil_mask & X25_MASK_WINDOW_SIZE)) {\n\t\t*p++ = X25_FAC_WINDOW_SIZE;\n\t\t*p++ = facilities->winsize_in ? : facilities->winsize_out;\n\t\t*p++ = facilities->winsize_out ? : facilities->winsize_in;\n\t}\n\n\tif (facil_mask & (X25_MASK_CALLING_AE|X25_MASK_CALLED_AE)) {\n\t\t*p++ = X25_MARKER;\n\t\t*p++ = X25_DTE_SERVICES;\n\t}\n\n\tif (dte_facs->calling_len && (facil_mask & X25_MASK_CALLING_AE)) {\n\t\tunsigned int bytecount = (dte_facs->calling_len + 1) >> 1;\n\t\t*p++ = X25_FAC_CALLING_AE;\n\t\t*p++ = 1 + bytecount;\n\t\t*p++ = dte_facs->calling_len;\n\t\tmemcpy(p, dte_facs->calling_ae, bytecount);\n\t\tp += bytecount;\n\t}\n\n\tif (dte_facs->called_len && (facil_mask & X25_MASK_CALLED_AE)) {\n\t\tunsigned int bytecount = (dte_facs->called_len % 2) ?\n\t\tdte_facs->called_len / 2 + 1 :\n\t\tdte_facs->called_len / 2;\n\t\t*p++ = X25_FAC_CALLED_AE;\n\t\t*p++ = 1 + bytecount;\n\t\t*p++ = dte_facs->called_len;\n\t\tmemcpy(p, dte_facs->called_ae, bytecount);\n\t\tp+=bytecount;\n\t}\n\n\tlen       = p - buffer;\n\tbuffer[0] = len - 1;\n\n\treturn len;\n}\n\n \nint x25_negotiate_facilities(struct sk_buff *skb, struct sock *sk,\n\t\tstruct x25_facilities *new, struct x25_dte_facilities *dte)\n{\n\tstruct x25_sock *x25 = x25_sk(sk);\n\tstruct x25_facilities *ours = &x25->facilities;\n\tstruct x25_facilities theirs;\n\tint len;\n\n\tmemset(&theirs, 0, sizeof(theirs));\n\tmemcpy(new, ours, sizeof(*new));\n\tmemset(dte, 0, sizeof(*dte));\n\n\tlen = x25_parse_facilities(skb, &theirs, dte, &x25->vc_facil_mask);\n\tif (len < 0)\n\t\treturn len;\n\n\t \n\tif ((theirs.reverse & 0x01 ) && (ours->reverse & 0x01)) {\n\t\tSOCK_DEBUG(sk, \"X.25: rejecting reverse charging request\\n\");\n\t\treturn -1;\n\t}\n\n\tnew->reverse = theirs.reverse;\n\n\tif (theirs.throughput) {\n\t\tint theirs_in =  theirs.throughput & 0x0f;\n\t\tint theirs_out = theirs.throughput & 0xf0;\n\t\tint ours_in  = ours->throughput & 0x0f;\n\t\tint ours_out = ours->throughput & 0xf0;\n\t\tif (!ours_in || theirs_in < ours_in) {\n\t\t\tSOCK_DEBUG(sk, \"X.25: inbound throughput negotiated\\n\");\n\t\t\tnew->throughput = (new->throughput & 0xf0) | theirs_in;\n\t\t}\n\t\tif (!ours_out || theirs_out < ours_out) {\n\t\t\tSOCK_DEBUG(sk,\n\t\t\t\t\"X.25: outbound throughput negotiated\\n\");\n\t\t\tnew->throughput = (new->throughput & 0x0f) | theirs_out;\n\t\t}\n\t}\n\n\tif (theirs.pacsize_in && theirs.pacsize_out) {\n\t\tif (theirs.pacsize_in < ours->pacsize_in) {\n\t\t\tSOCK_DEBUG(sk, \"X.25: packet size inwards negotiated down\\n\");\n\t\t\tnew->pacsize_in = theirs.pacsize_in;\n\t\t}\n\t\tif (theirs.pacsize_out < ours->pacsize_out) {\n\t\t\tSOCK_DEBUG(sk, \"X.25: packet size outwards negotiated down\\n\");\n\t\t\tnew->pacsize_out = theirs.pacsize_out;\n\t\t}\n\t}\n\n\tif (theirs.winsize_in && theirs.winsize_out) {\n\t\tif (theirs.winsize_in < ours->winsize_in) {\n\t\t\tSOCK_DEBUG(sk, \"X.25: window size inwards negotiated down\\n\");\n\t\t\tnew->winsize_in = theirs.winsize_in;\n\t\t}\n\t\tif (theirs.winsize_out < ours->winsize_out) {\n\t\t\tSOCK_DEBUG(sk, \"X.25: window size outwards negotiated down\\n\");\n\t\t\tnew->winsize_out = theirs.winsize_out;\n\t\t}\n\t}\n\n\treturn len;\n}\n\n \nvoid x25_limit_facilities(struct x25_facilities *facilities,\n\t\t\t  struct x25_neigh *nb)\n{\n\n\tif (!nb->extended) {\n\t\tif (facilities->winsize_in  > 7) {\n\t\t\tpr_debug(\"incoming winsize limited to 7\\n\");\n\t\t\tfacilities->winsize_in = 7;\n\t\t}\n\t\tif (facilities->winsize_out > 7) {\n\t\t\tfacilities->winsize_out = 7;\n\t\t\tpr_debug(\"outgoing winsize limited to 7\\n\");\n\t\t}\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}