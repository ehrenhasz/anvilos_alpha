{
  "module_name": "x25_dev.c",
  "hash_id": "c6308307d58a845ef8fc10ecf1d7811e23f440188aa0c7917e2ed4f2d73ea655",
  "original_prompt": "Ingested from linux-6.6.14/net/x25/x25_dev.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"X25: \" fmt\n\n#include <linux/kernel.h>\n#include <linux/netdevice.h>\n#include <linux/skbuff.h>\n#include <linux/slab.h>\n#include <net/sock.h>\n#include <linux/if_arp.h>\n#include <net/x25.h>\n#include <net/x25device.h>\n\nstatic int x25_receive_data(struct sk_buff *skb, struct x25_neigh *nb)\n{\n\tstruct sock *sk;\n\tunsigned short frametype;\n\tunsigned int lci;\n\n\tif (!pskb_may_pull(skb, X25_STD_MIN_LEN))\n\t\treturn 0;\n\n\tframetype = skb->data[2];\n\tlci = ((skb->data[0] << 8) & 0xF00) + ((skb->data[1] << 0) & 0x0FF);\n\n\t \n\tif (lci == 0) {\n\t\tx25_link_control(skb, nb, frametype);\n\t\treturn 0;\n\t}\n\n\t \n\tif ((sk = x25_find_socket(lci, nb)) != NULL) {\n\t\tint queued = 1;\n\n\t\tskb_reset_transport_header(skb);\n\t\tbh_lock_sock(sk);\n\t\tif (!sock_owned_by_user(sk)) {\n\t\t\tqueued = x25_process_rx_frame(sk, skb);\n\t\t} else {\n\t\t\tqueued = !sk_add_backlog(sk, skb, READ_ONCE(sk->sk_rcvbuf));\n\t\t}\n\t\tbh_unlock_sock(sk);\n\t\tsock_put(sk);\n\t\treturn queued;\n\t}\n\n\t \n\tif (frametype == X25_CALL_REQUEST)\n\t\treturn x25_rx_call_request(skb, nb, lci);\n\n\t \n\n\tif (x25_forward_data(lci, nb, skb)) {\n\t\tif (frametype == X25_CLEAR_CONFIRMATION) {\n\t\t\tx25_clear_forward_by_lci(lci);\n\t\t}\n\t\tkfree_skb(skb);\n\t\treturn 1;\n\t}\n\n \n\n\tif (frametype != X25_CLEAR_CONFIRMATION)\n\t\tpr_debug(\"x25_receive_data(): unknown frame type %2x\\n\",frametype);\n\n\treturn 0;\n}\n\nint x25_lapb_receive_frame(struct sk_buff *skb, struct net_device *dev,\n\t\t\t   struct packet_type *ptype, struct net_device *orig_dev)\n{\n\tstruct sk_buff *nskb;\n\tstruct x25_neigh *nb;\n\n\tif (!net_eq(dev_net(dev), &init_net))\n\t\tgoto drop;\n\n\tnskb = skb_copy(skb, GFP_ATOMIC);\n\tif (!nskb)\n\t\tgoto drop;\n\tkfree_skb(skb);\n\tskb = nskb;\n\n\t \n\tnb = x25_get_neigh(dev);\n\tif (!nb) {\n\t\tpr_debug(\"unknown neighbour - %s\\n\", dev->name);\n\t\tgoto drop;\n\t}\n\n\tif (!pskb_may_pull(skb, 1)) {\n\t\tx25_neigh_put(nb);\n\t\tgoto drop;\n\t}\n\n\tswitch (skb->data[0]) {\n\n\tcase X25_IFACE_DATA:\n\t\tskb_pull(skb, 1);\n\t\tif (x25_receive_data(skb, nb)) {\n\t\t\tx25_neigh_put(nb);\n\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n\n\tcase X25_IFACE_CONNECT:\n\t\tx25_link_established(nb);\n\t\tbreak;\n\n\tcase X25_IFACE_DISCONNECT:\n\t\tx25_link_terminated(nb);\n\t\tbreak;\n\t}\n\tx25_neigh_put(nb);\ndrop:\n\tkfree_skb(skb);\nout:\n\treturn 0;\n}\n\nvoid x25_establish_link(struct x25_neigh *nb)\n{\n\tstruct sk_buff *skb;\n\tunsigned char *ptr;\n\n\tswitch (nb->dev->type) {\n\tcase ARPHRD_X25:\n\t\tif ((skb = alloc_skb(1, GFP_ATOMIC)) == NULL) {\n\t\t\tpr_err(\"x25_dev: out of memory\\n\");\n\t\t\treturn;\n\t\t}\n\t\tptr  = skb_put(skb, 1);\n\t\t*ptr = X25_IFACE_CONNECT;\n\t\tbreak;\n\n\tdefault:\n\t\treturn;\n\t}\n\n\tskb->protocol = htons(ETH_P_X25);\n\tskb->dev      = nb->dev;\n\n\tdev_queue_xmit(skb);\n}\n\nvoid x25_terminate_link(struct x25_neigh *nb)\n{\n\tstruct sk_buff *skb;\n\tunsigned char *ptr;\n\n\tif (nb->dev->type != ARPHRD_X25)\n\t\treturn;\n\n\tskb = alloc_skb(1, GFP_ATOMIC);\n\tif (!skb) {\n\t\tpr_err(\"x25_dev: out of memory\\n\");\n\t\treturn;\n\t}\n\n\tptr  = skb_put(skb, 1);\n\t*ptr = X25_IFACE_DISCONNECT;\n\n\tskb->protocol = htons(ETH_P_X25);\n\tskb->dev      = nb->dev;\n\tdev_queue_xmit(skb);\n}\n\nvoid x25_send_frame(struct sk_buff *skb, struct x25_neigh *nb)\n{\n\tunsigned char *dptr;\n\n\tskb_reset_network_header(skb);\n\n\tswitch (nb->dev->type) {\n\tcase ARPHRD_X25:\n\t\tdptr  = skb_push(skb, 1);\n\t\t*dptr = X25_IFACE_DATA;\n\t\tbreak;\n\n\tdefault:\n\t\tkfree_skb(skb);\n\t\treturn;\n\t}\n\n\tskb->protocol = htons(ETH_P_X25);\n\tskb->dev      = nb->dev;\n\n\tdev_queue_xmit(skb);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}