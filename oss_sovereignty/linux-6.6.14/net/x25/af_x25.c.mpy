{
  "module_name": "af_x25.c",
  "hash_id": "5a0aae322cf60ec08d1a3184954ff6c1177bdacb7749c624c3ae113602fc7c9e",
  "original_prompt": "Ingested from linux-6.6.14/net/x25/af_x25.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"X25: \" fmt\n\n#include <linux/module.h>\n#include <linux/capability.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/sched/signal.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/netdevice.h>\n#include <linux/if_arp.h>\n#include <linux/skbuff.h>\n#include <linux/slab.h>\n#include <net/sock.h>\n#include <net/tcp_states.h>\n#include <linux/uaccess.h>\n#include <linux/fcntl.h>\n#include <linux/termios.h>\t \n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/compat.h>\n#include <linux/ctype.h>\n\n#include <net/x25.h>\n#include <net/compat.h>\n\nint sysctl_x25_restart_request_timeout = X25_DEFAULT_T20;\nint sysctl_x25_call_request_timeout    = X25_DEFAULT_T21;\nint sysctl_x25_reset_request_timeout   = X25_DEFAULT_T22;\nint sysctl_x25_clear_request_timeout   = X25_DEFAULT_T23;\nint sysctl_x25_ack_holdback_timeout    = X25_DEFAULT_T2;\nint sysctl_x25_forward                 = 0;\n\nHLIST_HEAD(x25_list);\nDEFINE_RWLOCK(x25_list_lock);\n\nstatic const struct proto_ops x25_proto_ops;\n\nstatic const struct x25_address null_x25_address = {\"               \"};\n\n#ifdef CONFIG_COMPAT\nstruct compat_x25_subscrip_struct {\n\tchar device[200-sizeof(compat_ulong_t)];\n\tcompat_ulong_t global_facil_mask;\n\tcompat_uint_t extended;\n};\n#endif\n\n\nint x25_parse_address_block(struct sk_buff *skb,\n\t\tstruct x25_address *called_addr,\n\t\tstruct x25_address *calling_addr)\n{\n\tunsigned char len;\n\tint needed;\n\tint rc;\n\n\tif (!pskb_may_pull(skb, 1)) {\n\t\t \n\t\trc = 0;\n\t\tgoto empty;\n\t}\n\n\tlen = *skb->data;\n\tneeded = 1 + ((len >> 4) + (len & 0x0f) + 1) / 2;\n\n\tif (!pskb_may_pull(skb, needed)) {\n\t\t \n\t\trc = -1;\n\t\tgoto empty;\n\t}\n\n\treturn x25_addr_ntoa(skb->data, called_addr, calling_addr);\n\nempty:\n\t*called_addr->x25_addr = 0;\n\t*calling_addr->x25_addr = 0;\n\n\treturn rc;\n}\n\n\nint x25_addr_ntoa(unsigned char *p, struct x25_address *called_addr,\n\t\t  struct x25_address *calling_addr)\n{\n\tunsigned int called_len, calling_len;\n\tchar *called, *calling;\n\tunsigned int i;\n\n\tcalled_len  = (*p >> 0) & 0x0F;\n\tcalling_len = (*p >> 4) & 0x0F;\n\n\tcalled  = called_addr->x25_addr;\n\tcalling = calling_addr->x25_addr;\n\tp++;\n\n\tfor (i = 0; i < (called_len + calling_len); i++) {\n\t\tif (i < called_len) {\n\t\t\tif (i % 2 != 0) {\n\t\t\t\t*called++ = ((*p >> 0) & 0x0F) + '0';\n\t\t\t\tp++;\n\t\t\t} else {\n\t\t\t\t*called++ = ((*p >> 4) & 0x0F) + '0';\n\t\t\t}\n\t\t} else {\n\t\t\tif (i % 2 != 0) {\n\t\t\t\t*calling++ = ((*p >> 0) & 0x0F) + '0';\n\t\t\t\tp++;\n\t\t\t} else {\n\t\t\t\t*calling++ = ((*p >> 4) & 0x0F) + '0';\n\t\t\t}\n\t\t}\n\t}\n\n\t*called = *calling = '\\0';\n\n\treturn 1 + (called_len + calling_len + 1) / 2;\n}\n\nint x25_addr_aton(unsigned char *p, struct x25_address *called_addr,\n\t\t  struct x25_address *calling_addr)\n{\n\tunsigned int called_len, calling_len;\n\tchar *called, *calling;\n\tint i;\n\n\tcalled  = called_addr->x25_addr;\n\tcalling = calling_addr->x25_addr;\n\n\tcalled_len  = strlen(called);\n\tcalling_len = strlen(calling);\n\n\t*p++ = (calling_len << 4) | (called_len << 0);\n\n\tfor (i = 0; i < (called_len + calling_len); i++) {\n\t\tif (i < called_len) {\n\t\t\tif (i % 2 != 0) {\n\t\t\t\t*p |= (*called++ - '0') << 0;\n\t\t\t\tp++;\n\t\t\t} else {\n\t\t\t\t*p = 0x00;\n\t\t\t\t*p |= (*called++ - '0') << 4;\n\t\t\t}\n\t\t} else {\n\t\t\tif (i % 2 != 0) {\n\t\t\t\t*p |= (*calling++ - '0') << 0;\n\t\t\t\tp++;\n\t\t\t} else {\n\t\t\t\t*p = 0x00;\n\t\t\t\t*p |= (*calling++ - '0') << 4;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 1 + (called_len + calling_len + 1) / 2;\n}\n\n \nstatic void x25_remove_socket(struct sock *sk)\n{\n\twrite_lock_bh(&x25_list_lock);\n\tsk_del_node_init(sk);\n\twrite_unlock_bh(&x25_list_lock);\n}\n\n \nstatic int x25_device_event(struct notifier_block *this, unsigned long event,\n\t\t\t    void *ptr)\n{\n\tstruct net_device *dev = netdev_notifier_info_to_dev(ptr);\n\tstruct x25_neigh *nb;\n\n\tif (!net_eq(dev_net(dev), &init_net))\n\t\treturn NOTIFY_DONE;\n\n\tif (dev->type == ARPHRD_X25) {\n\t\tswitch (event) {\n\t\tcase NETDEV_REGISTER:\n\t\tcase NETDEV_POST_TYPE_CHANGE:\n\t\t\tx25_link_device_up(dev);\n\t\t\tbreak;\n\t\tcase NETDEV_DOWN:\n\t\t\tnb = x25_get_neigh(dev);\n\t\t\tif (nb) {\n\t\t\t\tx25_link_terminated(nb);\n\t\t\t\tx25_neigh_put(nb);\n\t\t\t}\n\t\t\tx25_route_device_down(dev);\n\t\t\tbreak;\n\t\tcase NETDEV_PRE_TYPE_CHANGE:\n\t\tcase NETDEV_UNREGISTER:\n\t\t\tx25_link_device_down(dev);\n\t\t\tbreak;\n\t\tcase NETDEV_CHANGE:\n\t\t\tif (!netif_carrier_ok(dev)) {\n\t\t\t\tnb = x25_get_neigh(dev);\n\t\t\t\tif (nb) {\n\t\t\t\t\tx25_link_terminated(nb);\n\t\t\t\t\tx25_neigh_put(nb);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn NOTIFY_DONE;\n}\n\n \nstatic void x25_insert_socket(struct sock *sk)\n{\n\twrite_lock_bh(&x25_list_lock);\n\tsk_add_node(sk, &x25_list);\n\twrite_unlock_bh(&x25_list_lock);\n}\n\n \nstatic struct sock *x25_find_listener(struct x25_address *addr,\n\t\t\t\t\tstruct sk_buff *skb)\n{\n\tstruct sock *s;\n\tstruct sock *next_best;\n\n\tread_lock_bh(&x25_list_lock);\n\tnext_best = NULL;\n\n\tsk_for_each(s, &x25_list)\n\t\tif ((!strcmp(addr->x25_addr,\n\t\t\tx25_sk(s)->source_addr.x25_addr) ||\n\t\t\t\t!strcmp(x25_sk(s)->source_addr.x25_addr,\n\t\t\t\t\tnull_x25_address.x25_addr)) &&\n\t\t\t\t\ts->sk_state == TCP_LISTEN) {\n\t\t\t \n\t\t\tif (x25_sk(s)->cudmatchlength > 0 &&\n\t\t\t\tskb->len >= x25_sk(s)->cudmatchlength) {\n\t\t\t\tif((memcmp(x25_sk(s)->calluserdata.cuddata,\n\t\t\t\t\tskb->data,\n\t\t\t\t\tx25_sk(s)->cudmatchlength)) == 0) {\n\t\t\t\t\tsock_hold(s);\n\t\t\t\t\tgoto found;\n\t\t\t\t }\n\t\t\t} else\n\t\t\t\tnext_best = s;\n\t\t}\n\tif (next_best) {\n\t\ts = next_best;\n\t\tsock_hold(s);\n\t\tgoto found;\n\t}\n\ts = NULL;\nfound:\n\tread_unlock_bh(&x25_list_lock);\n\treturn s;\n}\n\n \nstatic struct sock *__x25_find_socket(unsigned int lci, struct x25_neigh *nb)\n{\n\tstruct sock *s;\n\n\tsk_for_each(s, &x25_list)\n\t\tif (x25_sk(s)->lci == lci && x25_sk(s)->neighbour == nb) {\n\t\t\tsock_hold(s);\n\t\t\tgoto found;\n\t\t}\n\ts = NULL;\nfound:\n\treturn s;\n}\n\nstruct sock *x25_find_socket(unsigned int lci, struct x25_neigh *nb)\n{\n\tstruct sock *s;\n\n\tread_lock_bh(&x25_list_lock);\n\ts = __x25_find_socket(lci, nb);\n\tread_unlock_bh(&x25_list_lock);\n\treturn s;\n}\n\n \nstatic unsigned int x25_new_lci(struct x25_neigh *nb)\n{\n\tunsigned int lci = 1;\n\tstruct sock *sk;\n\n\twhile ((sk = x25_find_socket(lci, nb)) != NULL) {\n\t\tsock_put(sk);\n\t\tif (++lci == 4096) {\n\t\t\tlci = 0;\n\t\t\tbreak;\n\t\t}\n\t\tcond_resched();\n\t}\n\n\treturn lci;\n}\n\n \nstatic void __x25_destroy_socket(struct sock *);\n\n \nstatic void x25_destroy_timer(struct timer_list *t)\n{\n\tstruct sock *sk = from_timer(sk, t, sk_timer);\n\n\tx25_destroy_socket_from_timer(sk);\n}\n\n \nstatic void __x25_destroy_socket(struct sock *sk)\n{\n\tstruct sk_buff *skb;\n\n\tx25_stop_heartbeat(sk);\n\tx25_stop_timer(sk);\n\n\tx25_remove_socket(sk);\n\tx25_clear_queues(sk);\t\t \n\n\twhile ((skb = skb_dequeue(&sk->sk_receive_queue)) != NULL) {\n\t\tif (skb->sk != sk) {\t\t \n\t\t\t \n\t\t\tskb->sk->sk_state = TCP_LISTEN;\n\t\t\tsock_set_flag(skb->sk, SOCK_DEAD);\n\t\t\tx25_start_heartbeat(skb->sk);\n\t\t\tx25_sk(skb->sk)->state = X25_STATE_0;\n\t\t}\n\n\t\tkfree_skb(skb);\n\t}\n\n\tif (sk_has_allocations(sk)) {\n\t\t \n\t\tsk->sk_timer.expires  = jiffies + 10 * HZ;\n\t\tsk->sk_timer.function = x25_destroy_timer;\n\t\tadd_timer(&sk->sk_timer);\n\t} else {\n\t\t \n\t\t__sock_put(sk);\n\t}\n}\n\nvoid x25_destroy_socket_from_timer(struct sock *sk)\n{\n\tsock_hold(sk);\n\tbh_lock_sock(sk);\n\t__x25_destroy_socket(sk);\n\tbh_unlock_sock(sk);\n\tsock_put(sk);\n}\n\n \n\nstatic int x25_setsockopt(struct socket *sock, int level, int optname,\n\t\t\t  sockptr_t optval, unsigned int optlen)\n{\n\tint opt;\n\tstruct sock *sk = sock->sk;\n\tint rc = -ENOPROTOOPT;\n\n\tif (level != SOL_X25 || optname != X25_QBITINCL)\n\t\tgoto out;\n\n\trc = -EINVAL;\n\tif (optlen < sizeof(int))\n\t\tgoto out;\n\n\trc = -EFAULT;\n\tif (copy_from_sockptr(&opt, optval, sizeof(int)))\n\t\tgoto out;\n\n\tif (opt)\n\t\tset_bit(X25_Q_BIT_FLAG, &x25_sk(sk)->flags);\n\telse\n\t\tclear_bit(X25_Q_BIT_FLAG, &x25_sk(sk)->flags);\n\trc = 0;\nout:\n\treturn rc;\n}\n\nstatic int x25_getsockopt(struct socket *sock, int level, int optname,\n\t\t\t  char __user *optval, int __user *optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tint val, len, rc = -ENOPROTOOPT;\n\n\tif (level != SOL_X25 || optname != X25_QBITINCL)\n\t\tgoto out;\n\n\trc = -EFAULT;\n\tif (get_user(len, optlen))\n\t\tgoto out;\n\n\tlen = min_t(unsigned int, len, sizeof(int));\n\n\trc = -EINVAL;\n\tif (len < 0)\n\t\tgoto out;\n\n\trc = -EFAULT;\n\tif (put_user(len, optlen))\n\t\tgoto out;\n\n\tval = test_bit(X25_Q_BIT_FLAG, &x25_sk(sk)->flags);\n\trc = copy_to_user(optval, &val, len) ? -EFAULT : 0;\nout:\n\treturn rc;\n}\n\nstatic int x25_listen(struct socket *sock, int backlog)\n{\n\tstruct sock *sk = sock->sk;\n\tint rc = -EOPNOTSUPP;\n\n\tlock_sock(sk);\n\tif (sock->state != SS_UNCONNECTED) {\n\t\trc = -EINVAL;\n\t\trelease_sock(sk);\n\t\treturn rc;\n\t}\n\n\tif (sk->sk_state != TCP_LISTEN) {\n\t\tmemset(&x25_sk(sk)->dest_addr, 0, X25_ADDR_LEN);\n\t\tsk->sk_max_ack_backlog = backlog;\n\t\tsk->sk_state           = TCP_LISTEN;\n\t\trc = 0;\n\t}\n\trelease_sock(sk);\n\n\treturn rc;\n}\n\nstatic struct proto x25_proto = {\n\t.name\t  = \"X25\",\n\t.owner\t  = THIS_MODULE,\n\t.obj_size = sizeof(struct x25_sock),\n};\n\nstatic struct sock *x25_alloc_socket(struct net *net, int kern)\n{\n\tstruct x25_sock *x25;\n\tstruct sock *sk = sk_alloc(net, AF_X25, GFP_ATOMIC, &x25_proto, kern);\n\n\tif (!sk)\n\t\tgoto out;\n\n\tsock_init_data(NULL, sk);\n\n\tx25 = x25_sk(sk);\n\tskb_queue_head_init(&x25->ack_queue);\n\tskb_queue_head_init(&x25->fragment_queue);\n\tskb_queue_head_init(&x25->interrupt_in_queue);\n\tskb_queue_head_init(&x25->interrupt_out_queue);\nout:\n\treturn sk;\n}\n\nstatic int x25_create(struct net *net, struct socket *sock, int protocol,\n\t\t      int kern)\n{\n\tstruct sock *sk;\n\tstruct x25_sock *x25;\n\tint rc = -EAFNOSUPPORT;\n\n\tif (!net_eq(net, &init_net))\n\t\tgoto out;\n\n\trc = -ESOCKTNOSUPPORT;\n\tif (sock->type != SOCK_SEQPACKET)\n\t\tgoto out;\n\n\trc = -EINVAL;\n\tif (protocol)\n\t\tgoto out;\n\n\trc = -ENOMEM;\n\tif ((sk = x25_alloc_socket(net, kern)) == NULL)\n\t\tgoto out;\n\n\tx25 = x25_sk(sk);\n\n\tsock_init_data(sock, sk);\n\n\tx25_init_timers(sk);\n\n\tsock->ops    = &x25_proto_ops;\n\tsk->sk_protocol = protocol;\n\tsk->sk_backlog_rcv = x25_backlog_rcv;\n\n\tx25->t21   = sysctl_x25_call_request_timeout;\n\tx25->t22   = sysctl_x25_reset_request_timeout;\n\tx25->t23   = sysctl_x25_clear_request_timeout;\n\tx25->t2    = sysctl_x25_ack_holdback_timeout;\n\tx25->state = X25_STATE_0;\n\tx25->cudmatchlength = 0;\n\tset_bit(X25_ACCPT_APPRV_FLAG, &x25->flags);\t \n\t\t\t\t\t\t\t \n\n\tx25->facilities.winsize_in  = X25_DEFAULT_WINDOW_SIZE;\n\tx25->facilities.winsize_out = X25_DEFAULT_WINDOW_SIZE;\n\tx25->facilities.pacsize_in  = X25_DEFAULT_PACKET_SIZE;\n\tx25->facilities.pacsize_out = X25_DEFAULT_PACKET_SIZE;\n\tx25->facilities.throughput  = 0;\t \n\tx25->facilities.reverse     = X25_DEFAULT_REVERSE;\n\tx25->dte_facilities.calling_len = 0;\n\tx25->dte_facilities.called_len = 0;\n\tmemset(x25->dte_facilities.called_ae, '\\0',\n\t\t\tsizeof(x25->dte_facilities.called_ae));\n\tmemset(x25->dte_facilities.calling_ae, '\\0',\n\t\t\tsizeof(x25->dte_facilities.calling_ae));\n\n\trc = 0;\nout:\n\treturn rc;\n}\n\nstatic struct sock *x25_make_new(struct sock *osk)\n{\n\tstruct sock *sk = NULL;\n\tstruct x25_sock *x25, *ox25;\n\n\tif (osk->sk_type != SOCK_SEQPACKET)\n\t\tgoto out;\n\n\tif ((sk = x25_alloc_socket(sock_net(osk), 0)) == NULL)\n\t\tgoto out;\n\n\tx25 = x25_sk(sk);\n\n\tsk->sk_type        = osk->sk_type;\n\tsk->sk_priority    = osk->sk_priority;\n\tsk->sk_protocol    = osk->sk_protocol;\n\tsk->sk_rcvbuf      = osk->sk_rcvbuf;\n\tsk->sk_sndbuf      = osk->sk_sndbuf;\n\tsk->sk_state       = TCP_ESTABLISHED;\n\tsk->sk_backlog_rcv = osk->sk_backlog_rcv;\n\tsock_copy_flags(sk, osk);\n\n\tox25 = x25_sk(osk);\n\tx25->t21        = ox25->t21;\n\tx25->t22        = ox25->t22;\n\tx25->t23        = ox25->t23;\n\tx25->t2         = ox25->t2;\n\tx25->flags\t= ox25->flags;\n\tx25->facilities = ox25->facilities;\n\tx25->dte_facilities = ox25->dte_facilities;\n\tx25->cudmatchlength = ox25->cudmatchlength;\n\n\tclear_bit(X25_INTERRUPT_FLAG, &x25->flags);\n\tx25_init_timers(sk);\nout:\n\treturn sk;\n}\n\nstatic int x25_release(struct socket *sock)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct x25_sock *x25;\n\n\tif (!sk)\n\t\treturn 0;\n\n\tx25 = x25_sk(sk);\n\n\tsock_hold(sk);\n\tlock_sock(sk);\n\tswitch (x25->state) {\n\n\t\tcase X25_STATE_0:\n\t\tcase X25_STATE_2:\n\t\t\tx25_disconnect(sk, 0, 0, 0);\n\t\t\t__x25_destroy_socket(sk);\n\t\t\tgoto out;\n\n\t\tcase X25_STATE_1:\n\t\tcase X25_STATE_3:\n\t\tcase X25_STATE_4:\n\t\t\tx25_clear_queues(sk);\n\t\t\tx25_write_internal(sk, X25_CLEAR_REQUEST);\n\t\t\tx25_start_t23timer(sk);\n\t\t\tx25->state = X25_STATE_2;\n\t\t\tsk->sk_state\t= TCP_CLOSE;\n\t\t\tsk->sk_shutdown\t|= SEND_SHUTDOWN;\n\t\t\tsk->sk_state_change(sk);\n\t\t\tsock_set_flag(sk, SOCK_DEAD);\n\t\t\tsock_set_flag(sk, SOCK_DESTROY);\n\t\t\tbreak;\n\n\t\tcase X25_STATE_5:\n\t\t\tx25_write_internal(sk, X25_CLEAR_REQUEST);\n\t\t\tx25_disconnect(sk, 0, 0, 0);\n\t\t\t__x25_destroy_socket(sk);\n\t\t\tgoto out;\n\t}\n\n\tsock_orphan(sk);\nout:\n\trelease_sock(sk);\n\tsock_put(sk);\n\treturn 0;\n}\n\nstatic int x25_bind(struct socket *sock, struct sockaddr *uaddr, int addr_len)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sockaddr_x25 *addr = (struct sockaddr_x25 *)uaddr;\n\tint len, i, rc = 0;\n\n\tif (addr_len != sizeof(struct sockaddr_x25) ||\n\t    addr->sx25_family != AF_X25 ||\n\t    strnlen(addr->sx25_addr.x25_addr, X25_ADDR_LEN) == X25_ADDR_LEN) {\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t \n\tif (strcmp(addr->sx25_addr.x25_addr, null_x25_address.x25_addr)) {\n\n\t\tlen = strlen(addr->sx25_addr.x25_addr);\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tif (!isdigit(addr->sx25_addr.x25_addr[i])) {\n\t\t\t\trc = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\n\tlock_sock(sk);\n\tif (sock_flag(sk, SOCK_ZAPPED)) {\n\t\tx25_sk(sk)->source_addr = addr->sx25_addr;\n\t\tx25_insert_socket(sk);\n\t\tsock_reset_flag(sk, SOCK_ZAPPED);\n\t} else {\n\t\trc = -EINVAL;\n\t}\n\trelease_sock(sk);\n\tSOCK_DEBUG(sk, \"x25_bind: socket is bound\\n\");\nout:\n\treturn rc;\n}\n\nstatic int x25_wait_for_connection_establishment(struct sock *sk)\n{\n\tDECLARE_WAITQUEUE(wait, current);\n\tint rc;\n\n\tadd_wait_queue_exclusive(sk_sleep(sk), &wait);\n\tfor (;;) {\n\t\t__set_current_state(TASK_INTERRUPTIBLE);\n\t\trc = -ERESTARTSYS;\n\t\tif (signal_pending(current))\n\t\t\tbreak;\n\t\trc = sock_error(sk);\n\t\tif (rc) {\n\t\t\tsk->sk_socket->state = SS_UNCONNECTED;\n\t\t\tbreak;\n\t\t}\n\t\trc = -ENOTCONN;\n\t\tif (sk->sk_state == TCP_CLOSE) {\n\t\t\tsk->sk_socket->state = SS_UNCONNECTED;\n\t\t\tbreak;\n\t\t}\n\t\trc = 0;\n\t\tif (sk->sk_state != TCP_ESTABLISHED) {\n\t\t\trelease_sock(sk);\n\t\t\tschedule();\n\t\t\tlock_sock(sk);\n\t\t} else\n\t\t\tbreak;\n\t}\n\t__set_current_state(TASK_RUNNING);\n\tremove_wait_queue(sk_sleep(sk), &wait);\n\treturn rc;\n}\n\nstatic int x25_connect(struct socket *sock, struct sockaddr *uaddr,\n\t\t       int addr_len, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct x25_sock *x25 = x25_sk(sk);\n\tstruct sockaddr_x25 *addr = (struct sockaddr_x25 *)uaddr;\n\tstruct x25_route *rt;\n\tint rc = 0;\n\n\tlock_sock(sk);\n\tif (sk->sk_state == TCP_ESTABLISHED && sock->state == SS_CONNECTING) {\n\t\tsock->state = SS_CONNECTED;\n\t\tgoto out;  \n\t}\n\n\trc = -ECONNREFUSED;\n\tif (sk->sk_state == TCP_CLOSE && sock->state == SS_CONNECTING) {\n\t\tsock->state = SS_UNCONNECTED;\n\t\tgoto out;\n\t}\n\n\trc = -EISCONN;\t \n\tif (sk->sk_state == TCP_ESTABLISHED)\n\t\tgoto out;\n\n\trc = -EALREADY;\t \n\tif (sk->sk_state == TCP_SYN_SENT)\n\t\tgoto out;\n\n\tsk->sk_state   = TCP_CLOSE;\n\tsock->state = SS_UNCONNECTED;\n\n\trc = -EINVAL;\n\tif (addr_len != sizeof(struct sockaddr_x25) ||\n\t    addr->sx25_family != AF_X25 ||\n\t    strnlen(addr->sx25_addr.x25_addr, X25_ADDR_LEN) == X25_ADDR_LEN)\n\t\tgoto out;\n\n\trc = -ENETUNREACH;\n\trt = x25_get_route(&addr->sx25_addr);\n\tif (!rt)\n\t\tgoto out;\n\n\tx25->neighbour = x25_get_neigh(rt->dev);\n\tif (!x25->neighbour)\n\t\tgoto out_put_route;\n\n\tx25_limit_facilities(&x25->facilities, x25->neighbour);\n\n\tx25->lci = x25_new_lci(x25->neighbour);\n\tif (!x25->lci)\n\t\tgoto out_put_neigh;\n\n\trc = -EINVAL;\n\tif (sock_flag(sk, SOCK_ZAPPED))  \n\t\tgoto out_put_neigh;\n\n\tif (!strcmp(x25->source_addr.x25_addr, null_x25_address.x25_addr))\n\t\tmemset(&x25->source_addr, '\\0', X25_ADDR_LEN);\n\n\tx25->dest_addr = addr->sx25_addr;\n\n\t \n\tsock->state   = SS_CONNECTING;\n\tsk->sk_state  = TCP_SYN_SENT;\n\n\tx25->state = X25_STATE_1;\n\n\tx25_write_internal(sk, X25_CALL_REQUEST);\n\n\tx25_start_heartbeat(sk);\n\tx25_start_t21timer(sk);\n\n\t \n\trc = -EINPROGRESS;\n\tif (sk->sk_state != TCP_ESTABLISHED && (flags & O_NONBLOCK))\n\t\tgoto out;\n\n\trc = x25_wait_for_connection_establishment(sk);\n\tif (rc)\n\t\tgoto out_put_neigh;\n\n\tsock->state = SS_CONNECTED;\n\trc = 0;\nout_put_neigh:\n\tif (rc && x25->neighbour) {\n\t\tread_lock_bh(&x25_list_lock);\n\t\tx25_neigh_put(x25->neighbour);\n\t\tx25->neighbour = NULL;\n\t\tread_unlock_bh(&x25_list_lock);\n\t\tx25->state = X25_STATE_0;\n\t}\nout_put_route:\n\tx25_route_put(rt);\nout:\n\trelease_sock(sk);\n\treturn rc;\n}\n\nstatic int x25_wait_for_data(struct sock *sk, long timeout)\n{\n\tDECLARE_WAITQUEUE(wait, current);\n\tint rc = 0;\n\n\tadd_wait_queue_exclusive(sk_sleep(sk), &wait);\n\tfor (;;) {\n\t\t__set_current_state(TASK_INTERRUPTIBLE);\n\t\tif (sk->sk_shutdown & RCV_SHUTDOWN)\n\t\t\tbreak;\n\t\trc = -ERESTARTSYS;\n\t\tif (signal_pending(current))\n\t\t\tbreak;\n\t\trc = -EAGAIN;\n\t\tif (!timeout)\n\t\t\tbreak;\n\t\trc = 0;\n\t\tif (skb_queue_empty(&sk->sk_receive_queue)) {\n\t\t\trelease_sock(sk);\n\t\t\ttimeout = schedule_timeout(timeout);\n\t\t\tlock_sock(sk);\n\t\t} else\n\t\t\tbreak;\n\t}\n\t__set_current_state(TASK_RUNNING);\n\tremove_wait_queue(sk_sleep(sk), &wait);\n\treturn rc;\n}\n\nstatic int x25_accept(struct socket *sock, struct socket *newsock, int flags,\n\t\t      bool kern)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sock *newsk;\n\tstruct sk_buff *skb;\n\tint rc = -EINVAL;\n\n\tif (!sk)\n\t\tgoto out;\n\n\trc = -EOPNOTSUPP;\n\tif (sk->sk_type != SOCK_SEQPACKET)\n\t\tgoto out;\n\n\tlock_sock(sk);\n\trc = -EINVAL;\n\tif (sk->sk_state != TCP_LISTEN)\n\t\tgoto out2;\n\n\trc = x25_wait_for_data(sk, sk->sk_rcvtimeo);\n\tif (rc)\n\t\tgoto out2;\n\tskb = skb_dequeue(&sk->sk_receive_queue);\n\trc = -EINVAL;\n\tif (!skb->sk)\n\t\tgoto out2;\n\tnewsk\t\t = skb->sk;\n\tsock_graft(newsk, newsock);\n\n\t \n\tskb->sk = NULL;\n\tkfree_skb(skb);\n\tsk_acceptq_removed(sk);\n\tnewsock->state = SS_CONNECTED;\n\trc = 0;\nout2:\n\trelease_sock(sk);\nout:\n\treturn rc;\n}\n\nstatic int x25_getname(struct socket *sock, struct sockaddr *uaddr,\n\t\t       int peer)\n{\n\tstruct sockaddr_x25 *sx25 = (struct sockaddr_x25 *)uaddr;\n\tstruct sock *sk = sock->sk;\n\tstruct x25_sock *x25 = x25_sk(sk);\n\tint rc = 0;\n\n\tif (peer) {\n\t\tif (sk->sk_state != TCP_ESTABLISHED) {\n\t\t\trc = -ENOTCONN;\n\t\t\tgoto out;\n\t\t}\n\t\tsx25->sx25_addr = x25->dest_addr;\n\t} else\n\t\tsx25->sx25_addr = x25->source_addr;\n\n\tsx25->sx25_family = AF_X25;\n\trc = sizeof(*sx25);\n\nout:\n\treturn rc;\n}\n\nint x25_rx_call_request(struct sk_buff *skb, struct x25_neigh *nb,\n\t\t\tunsigned int lci)\n{\n\tstruct sock *sk;\n\tstruct sock *make;\n\tstruct x25_sock *makex25;\n\tstruct x25_address source_addr, dest_addr;\n\tstruct x25_facilities facilities;\n\tstruct x25_dte_facilities dte_facilities;\n\tint len, addr_len, rc;\n\n\t \n\tskb_pull(skb, X25_STD_MIN_LEN);\n\n\t \n\taddr_len = x25_parse_address_block(skb, &source_addr, &dest_addr);\n\tif (addr_len <= 0)\n\t\tgoto out_clear_request;\n\tskb_pull(skb, addr_len);\n\n\t \n\tif (!pskb_may_pull(skb, 1))\n\t\tgoto out_clear_request;\n\tlen = skb->data[0] + 1;\n\tif (!pskb_may_pull(skb, len))\n\t\tgoto out_clear_request;\n\tskb_pull(skb,len);\n\n\t \n\tif (skb->len > X25_MAX_CUD_LEN)\n\t\tgoto out_clear_request;\n\n\t \n\tif (!pskb_may_pull(skb, skb->len))\n\t\tgoto out_clear_request;\n\n\t \n\tsk = x25_find_listener(&source_addr,skb);\n\tskb_push(skb,len);\n\n\tif (sk != NULL && sk_acceptq_is_full(sk)) {\n\t\tgoto out_sock_put;\n\t}\n\n\t \n\tif (sk == NULL) {\n\t\tskb_push(skb, addr_len + X25_STD_MIN_LEN);\n\t\tif (sysctl_x25_forward &&\n\t\t\t\tx25_forward_call(&dest_addr, nb, skb, lci) > 0)\n\t\t{\n\t\t\t \n\t\t\tkfree_skb(skb);\n\t\t\trc = 1;\n\t\t\tgoto out;\n\t\t} else {\n\t\t\t \n\t\t\tgoto out_clear_request;\n\t\t}\n\t}\n\n\t \n\tlen = x25_negotiate_facilities(skb, sk, &facilities, &dte_facilities);\n\tif (len == -1)\n\t\tgoto out_sock_put;\n\n\t \n\n\tx25_limit_facilities(&facilities, nb);\n\n\t \n\tmake = x25_make_new(sk);\n\tif (!make)\n\t\tgoto out_sock_put;\n\n\t \n\tskb_pull(skb, len);\n\n\tskb->sk     = make;\n\tmake->sk_state = TCP_ESTABLISHED;\n\n\tmakex25 = x25_sk(make);\n\tmakex25->lci           = lci;\n\tmakex25->dest_addr     = dest_addr;\n\tmakex25->source_addr   = source_addr;\n\tx25_neigh_hold(nb);\n\tmakex25->neighbour     = nb;\n\tmakex25->facilities    = facilities;\n\tmakex25->dte_facilities= dte_facilities;\n\tmakex25->vc_facil_mask = x25_sk(sk)->vc_facil_mask;\n\t \n\tmakex25->vc_facil_mask &= ~X25_MASK_REVERSE;\n\t \n\tmakex25->vc_facil_mask &= ~X25_MASK_CALLING_AE;\n\tmakex25->cudmatchlength = x25_sk(sk)->cudmatchlength;\n\n\t \n\tif (test_bit(X25_ACCPT_APPRV_FLAG, &makex25->flags)) {\n\t\tx25_write_internal(make, X25_CALL_ACCEPTED);\n\t\tmakex25->state = X25_STATE_3;\n\t} else {\n\t\tmakex25->state = X25_STATE_5;\n\t}\n\n\t \n\tskb_copy_from_linear_data(skb, makex25->calluserdata.cuddata, skb->len);\n\tmakex25->calluserdata.cudlength = skb->len;\n\n\tsk_acceptq_added(sk);\n\n\tx25_insert_socket(make);\n\n\tskb_queue_head(&sk->sk_receive_queue, skb);\n\n\tx25_start_heartbeat(make);\n\n\tif (!sock_flag(sk, SOCK_DEAD))\n\t\tsk->sk_data_ready(sk);\n\trc = 1;\n\tsock_put(sk);\nout:\n\treturn rc;\nout_sock_put:\n\tsock_put(sk);\nout_clear_request:\n\trc = 0;\n\tx25_transmit_clear_request(nb, lci, 0x01);\n\tgoto out;\n}\n\nstatic int x25_sendmsg(struct socket *sock, struct msghdr *msg, size_t len)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct x25_sock *x25 = x25_sk(sk);\n\tDECLARE_SOCKADDR(struct sockaddr_x25 *, usx25, msg->msg_name);\n\tstruct sockaddr_x25 sx25;\n\tstruct sk_buff *skb;\n\tunsigned char *asmptr;\n\tint noblock = msg->msg_flags & MSG_DONTWAIT;\n\tsize_t size;\n\tint qbit = 0, rc = -EINVAL;\n\n\tlock_sock(sk);\n\tif (msg->msg_flags & ~(MSG_DONTWAIT|MSG_OOB|MSG_EOR|MSG_CMSG_COMPAT))\n\t\tgoto out;\n\n\t \n\tif (!(msg->msg_flags & (MSG_EOR|MSG_OOB)))\n\t\tgoto out;\n\n\trc = -EADDRNOTAVAIL;\n\tif (sock_flag(sk, SOCK_ZAPPED))\n\t\tgoto out;\n\n\trc = -EPIPE;\n\tif (sk->sk_shutdown & SEND_SHUTDOWN) {\n\t\tsend_sig(SIGPIPE, current, 0);\n\t\tgoto out;\n\t}\n\n\trc = -ENETUNREACH;\n\tif (!x25->neighbour)\n\t\tgoto out;\n\n\tif (usx25) {\n\t\trc = -EINVAL;\n\t\tif (msg->msg_namelen < sizeof(sx25))\n\t\t\tgoto out;\n\t\tmemcpy(&sx25, usx25, sizeof(sx25));\n\t\trc = -EISCONN;\n\t\tif (strcmp(x25->dest_addr.x25_addr, sx25.sx25_addr.x25_addr))\n\t\t\tgoto out;\n\t\trc = -EINVAL;\n\t\tif (sx25.sx25_family != AF_X25)\n\t\t\tgoto out;\n\t} else {\n\t\t \n\t\trc = -ENOTCONN;\n\t\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\t\tgoto out;\n\n\t\tsx25.sx25_family = AF_X25;\n\t\tsx25.sx25_addr   = x25->dest_addr;\n\t}\n\n\t \n\tif (len > 65535) {\n\t\trc = -EMSGSIZE;\n\t\tgoto out;\n\t}\n\n\tSOCK_DEBUG(sk, \"x25_sendmsg: sendto: Addresses built.\\n\");\n\n\t \n\tSOCK_DEBUG(sk, \"x25_sendmsg: sendto: building packet.\\n\");\n\n\tif ((msg->msg_flags & MSG_OOB) && len > 32)\n\t\tlen = 32;\n\n\tsize = len + X25_MAX_L2_LEN + X25_EXT_MIN_LEN;\n\n\trelease_sock(sk);\n\tskb = sock_alloc_send_skb(sk, size, noblock, &rc);\n\tlock_sock(sk);\n\tif (!skb)\n\t\tgoto out;\n\tX25_SKB_CB(skb)->flags = msg->msg_flags;\n\n\tskb_reserve(skb, X25_MAX_L2_LEN + X25_EXT_MIN_LEN);\n\n\t \n\tSOCK_DEBUG(sk, \"x25_sendmsg: Copying user data\\n\");\n\n\tskb_reset_transport_header(skb);\n\tskb_put(skb, len);\n\n\trc = memcpy_from_msg(skb_transport_header(skb), msg, len);\n\tif (rc)\n\t\tgoto out_kfree_skb;\n\n\t \n\tif (test_bit(X25_Q_BIT_FLAG, &x25->flags)) {\n\t\tif (!pskb_may_pull(skb, 1))\n\t\t\tgoto out_kfree_skb;\n\n\t\tqbit = skb->data[0];\n\t\tskb_pull(skb, 1);\n\t}\n\n\t \n\tSOCK_DEBUG(sk, \"x25_sendmsg: Building X.25 Header.\\n\");\n\n\tif (msg->msg_flags & MSG_OOB) {\n\t\tif (x25->neighbour->extended) {\n\t\t\tasmptr    = skb_push(skb, X25_STD_MIN_LEN);\n\t\t\t*asmptr++ = ((x25->lci >> 8) & 0x0F) | X25_GFI_EXTSEQ;\n\t\t\t*asmptr++ = (x25->lci >> 0) & 0xFF;\n\t\t\t*asmptr++ = X25_INTERRUPT;\n\t\t} else {\n\t\t\tasmptr    = skb_push(skb, X25_STD_MIN_LEN);\n\t\t\t*asmptr++ = ((x25->lci >> 8) & 0x0F) | X25_GFI_STDSEQ;\n\t\t\t*asmptr++ = (x25->lci >> 0) & 0xFF;\n\t\t\t*asmptr++ = X25_INTERRUPT;\n\t\t}\n\t} else {\n\t\tif (x25->neighbour->extended) {\n\t\t\t \n\t\t\tasmptr    = skb_push(skb, X25_EXT_MIN_LEN);\n\t\t\t*asmptr++ = ((x25->lci >> 8) & 0x0F) | X25_GFI_EXTSEQ;\n\t\t\t*asmptr++ = (x25->lci >> 0) & 0xFF;\n\t\t\t*asmptr++ = X25_DATA;\n\t\t\t*asmptr++ = X25_DATA;\n\t\t} else {\n\t\t\t \n\t\t\tasmptr    = skb_push(skb, X25_STD_MIN_LEN);\n\t\t\t*asmptr++ = ((x25->lci >> 8) & 0x0F) | X25_GFI_STDSEQ;\n\t\t\t*asmptr++ = (x25->lci >> 0) & 0xFF;\n\t\t\t*asmptr++ = X25_DATA;\n\t\t}\n\n\t\tif (qbit)\n\t\t\tskb->data[0] |= X25_Q_BIT;\n\t}\n\n\tSOCK_DEBUG(sk, \"x25_sendmsg: Built header.\\n\");\n\tSOCK_DEBUG(sk, \"x25_sendmsg: Transmitting buffer\\n\");\n\n\trc = -ENOTCONN;\n\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\tgoto out_kfree_skb;\n\n\tif (msg->msg_flags & MSG_OOB)\n\t\tskb_queue_tail(&x25->interrupt_out_queue, skb);\n\telse {\n\t\trc = x25_output(sk, skb);\n\t\tlen = rc;\n\t\tif (rc < 0)\n\t\t\tkfree_skb(skb);\n\t\telse if (test_bit(X25_Q_BIT_FLAG, &x25->flags))\n\t\t\tlen++;\n\t}\n\n\tx25_kick(sk);\n\trc = len;\nout:\n\trelease_sock(sk);\n\treturn rc;\nout_kfree_skb:\n\tkfree_skb(skb);\n\tgoto out;\n}\n\n\nstatic int x25_recvmsg(struct socket *sock, struct msghdr *msg, size_t size,\n\t\t       int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct x25_sock *x25 = x25_sk(sk);\n\tDECLARE_SOCKADDR(struct sockaddr_x25 *, sx25, msg->msg_name);\n\tsize_t copied;\n\tint qbit, header_len;\n\tstruct sk_buff *skb;\n\tunsigned char *asmptr;\n\tint rc = -ENOTCONN;\n\n\tlock_sock(sk);\n\n\tif (x25->neighbour == NULL)\n\t\tgoto out;\n\n\theader_len = x25->neighbour->extended ?\n\t\tX25_EXT_MIN_LEN : X25_STD_MIN_LEN;\n\n\t \n\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\tgoto out;\n\n\tif (flags & MSG_OOB) {\n\t\trc = -EINVAL;\n\t\tif (sock_flag(sk, SOCK_URGINLINE) ||\n\t\t    !skb_peek(&x25->interrupt_in_queue))\n\t\t\tgoto out;\n\n\t\tskb = skb_dequeue(&x25->interrupt_in_queue);\n\n\t\tif (!pskb_may_pull(skb, X25_STD_MIN_LEN))\n\t\t\tgoto out_free_dgram;\n\n\t\tskb_pull(skb, X25_STD_MIN_LEN);\n\n\t\t \n\t\tif (test_bit(X25_Q_BIT_FLAG, &x25->flags)) {\n\t\t\tasmptr  = skb_push(skb, 1);\n\t\t\t*asmptr = 0x00;\n\t\t}\n\n\t\tmsg->msg_flags |= MSG_OOB;\n\t} else {\n\t\t \n\t\trelease_sock(sk);\n\t\tskb = skb_recv_datagram(sk, flags, &rc);\n\t\tlock_sock(sk);\n\t\tif (!skb)\n\t\t\tgoto out;\n\n\t\tif (!pskb_may_pull(skb, header_len))\n\t\t\tgoto out_free_dgram;\n\n\t\tqbit = (skb->data[0] & X25_Q_BIT) == X25_Q_BIT;\n\n\t\tskb_pull(skb, header_len);\n\n\t\tif (test_bit(X25_Q_BIT_FLAG, &x25->flags)) {\n\t\t\tasmptr  = skb_push(skb, 1);\n\t\t\t*asmptr = qbit;\n\t\t}\n\t}\n\n\tskb_reset_transport_header(skb);\n\tcopied = skb->len;\n\n\tif (copied > size) {\n\t\tcopied = size;\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t}\n\n\t \n\tmsg->msg_flags |= MSG_EOR;\n\n\trc = skb_copy_datagram_msg(skb, 0, msg, copied);\n\tif (rc)\n\t\tgoto out_free_dgram;\n\n\tif (sx25) {\n\t\tsx25->sx25_family = AF_X25;\n\t\tsx25->sx25_addr   = x25->dest_addr;\n\t\tmsg->msg_namelen = sizeof(*sx25);\n\t}\n\n\tx25_check_rbuf(sk);\n\trc = copied;\nout_free_dgram:\n\tskb_free_datagram(sk, skb);\nout:\n\trelease_sock(sk);\n\treturn rc;\n}\n\n\nstatic int x25_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct x25_sock *x25 = x25_sk(sk);\n\tvoid __user *argp = (void __user *)arg;\n\tint rc;\n\n\tswitch (cmd) {\n\tcase TIOCOUTQ: {\n\t\tint amount;\n\n\t\tamount = sk->sk_sndbuf - sk_wmem_alloc_get(sk);\n\t\tif (amount < 0)\n\t\t\tamount = 0;\n\t\trc = put_user(amount, (unsigned int __user *)argp);\n\t\tbreak;\n\t}\n\n\tcase TIOCINQ: {\n\t\tstruct sk_buff *skb;\n\t\tint amount = 0;\n\t\t \n\t\tlock_sock(sk);\n\t\tif ((skb = skb_peek(&sk->sk_receive_queue)) != NULL)\n\t\t\tamount = skb->len;\n\t\trelease_sock(sk);\n\t\trc = put_user(amount, (unsigned int __user *)argp);\n\t\tbreak;\n\t}\n\n\tcase SIOCGIFADDR:\n\tcase SIOCSIFADDR:\n\tcase SIOCGIFDSTADDR:\n\tcase SIOCSIFDSTADDR:\n\tcase SIOCGIFBRDADDR:\n\tcase SIOCSIFBRDADDR:\n\tcase SIOCGIFNETMASK:\n\tcase SIOCSIFNETMASK:\n\tcase SIOCGIFMETRIC:\n\tcase SIOCSIFMETRIC:\n\t\trc = -EINVAL;\n\t\tbreak;\n\tcase SIOCADDRT:\n\tcase SIOCDELRT:\n\t\trc = -EPERM;\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\tbreak;\n\t\trc = x25_route_ioctl(cmd, argp);\n\t\tbreak;\n\tcase SIOCX25GSUBSCRIP:\n\t\trc = x25_subscr_ioctl(cmd, argp);\n\t\tbreak;\n\tcase SIOCX25SSUBSCRIP:\n\t\trc = -EPERM;\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\tbreak;\n\t\trc = x25_subscr_ioctl(cmd, argp);\n\t\tbreak;\n\tcase SIOCX25GFACILITIES: {\n\t\tlock_sock(sk);\n\t\trc = copy_to_user(argp, &x25->facilities,\n\t\t\t\t  sizeof(x25->facilities))\n\t\t\t? -EFAULT : 0;\n\t\trelease_sock(sk);\n\t\tbreak;\n\t}\n\n\tcase SIOCX25SFACILITIES: {\n\t\tstruct x25_facilities facilities;\n\t\trc = -EFAULT;\n\t\tif (copy_from_user(&facilities, argp, sizeof(facilities)))\n\t\t\tbreak;\n\t\trc = -EINVAL;\n\t\tlock_sock(sk);\n\t\tif (sk->sk_state != TCP_LISTEN &&\n\t\t    sk->sk_state != TCP_CLOSE)\n\t\t\tgoto out_fac_release;\n\t\tif (facilities.pacsize_in < X25_PS16 ||\n\t\t    facilities.pacsize_in > X25_PS4096)\n\t\t\tgoto out_fac_release;\n\t\tif (facilities.pacsize_out < X25_PS16 ||\n\t\t    facilities.pacsize_out > X25_PS4096)\n\t\t\tgoto out_fac_release;\n\t\tif (facilities.winsize_in < 1 ||\n\t\t    facilities.winsize_in > 127)\n\t\t\tgoto out_fac_release;\n\t\tif (facilities.throughput) {\n\t\t\tint out = facilities.throughput & 0xf0;\n\t\t\tint in  = facilities.throughput & 0x0f;\n\t\t\tif (!out)\n\t\t\t\tfacilities.throughput |=\n\t\t\t\t\tX25_DEFAULT_THROUGHPUT << 4;\n\t\t\telse if (out < 0x30 || out > 0xD0)\n\t\t\t\tgoto out_fac_release;\n\t\t\tif (!in)\n\t\t\t\tfacilities.throughput |=\n\t\t\t\t\tX25_DEFAULT_THROUGHPUT;\n\t\t\telse if (in < 0x03 || in > 0x0D)\n\t\t\t\tgoto out_fac_release;\n\t\t}\n\t\tif (facilities.reverse &&\n\t\t    (facilities.reverse & 0x81) != 0x81)\n\t\t\tgoto out_fac_release;\n\t\tx25->facilities = facilities;\n\t\trc = 0;\nout_fac_release:\n\t\trelease_sock(sk);\n\t\tbreak;\n\t}\n\n\tcase SIOCX25GDTEFACILITIES: {\n\t\tlock_sock(sk);\n\t\trc = copy_to_user(argp, &x25->dte_facilities,\n\t\t\t\t  sizeof(x25->dte_facilities));\n\t\trelease_sock(sk);\n\t\tif (rc)\n\t\t\trc = -EFAULT;\n\t\tbreak;\n\t}\n\n\tcase SIOCX25SDTEFACILITIES: {\n\t\tstruct x25_dte_facilities dtefacs;\n\t\trc = -EFAULT;\n\t\tif (copy_from_user(&dtefacs, argp, sizeof(dtefacs)))\n\t\t\tbreak;\n\t\trc = -EINVAL;\n\t\tlock_sock(sk);\n\t\tif (sk->sk_state != TCP_LISTEN &&\n\t\t    sk->sk_state != TCP_CLOSE)\n\t\t\tgoto out_dtefac_release;\n\t\tif (dtefacs.calling_len > X25_MAX_AE_LEN)\n\t\t\tgoto out_dtefac_release;\n\t\tif (dtefacs.called_len > X25_MAX_AE_LEN)\n\t\t\tgoto out_dtefac_release;\n\t\tx25->dte_facilities = dtefacs;\n\t\trc = 0;\nout_dtefac_release:\n\t\trelease_sock(sk);\n\t\tbreak;\n\t}\n\n\tcase SIOCX25GCALLUSERDATA: {\n\t\tlock_sock(sk);\n\t\trc = copy_to_user(argp, &x25->calluserdata,\n\t\t\t\t  sizeof(x25->calluserdata))\n\t\t\t? -EFAULT : 0;\n\t\trelease_sock(sk);\n\t\tbreak;\n\t}\n\n\tcase SIOCX25SCALLUSERDATA: {\n\t\tstruct x25_calluserdata calluserdata;\n\n\t\trc = -EFAULT;\n\t\tif (copy_from_user(&calluserdata, argp, sizeof(calluserdata)))\n\t\t\tbreak;\n\t\trc = -EINVAL;\n\t\tif (calluserdata.cudlength > X25_MAX_CUD_LEN)\n\t\t\tbreak;\n\t\tlock_sock(sk);\n\t\tx25->calluserdata = calluserdata;\n\t\trelease_sock(sk);\n\t\trc = 0;\n\t\tbreak;\n\t}\n\n\tcase SIOCX25GCAUSEDIAG: {\n\t\tlock_sock(sk);\n\t\trc = copy_to_user(argp, &x25->causediag, sizeof(x25->causediag))\n\t\t\t? -EFAULT : 0;\n\t\trelease_sock(sk);\n\t\tbreak;\n\t}\n\n\tcase SIOCX25SCAUSEDIAG: {\n\t\tstruct x25_causediag causediag;\n\t\trc = -EFAULT;\n\t\tif (copy_from_user(&causediag, argp, sizeof(causediag)))\n\t\t\tbreak;\n\t\tlock_sock(sk);\n\t\tx25->causediag = causediag;\n\t\trelease_sock(sk);\n\t\trc = 0;\n\t\tbreak;\n\n\t}\n\n\tcase SIOCX25SCUDMATCHLEN: {\n\t\tstruct x25_subaddr sub_addr;\n\t\trc = -EINVAL;\n\t\tlock_sock(sk);\n\t\tif(sk->sk_state != TCP_CLOSE)\n\t\t\tgoto out_cud_release;\n\t\trc = -EFAULT;\n\t\tif (copy_from_user(&sub_addr, argp,\n\t\t\t\t   sizeof(sub_addr)))\n\t\t\tgoto out_cud_release;\n\t\trc = -EINVAL;\n\t\tif (sub_addr.cudmatchlength > X25_MAX_CUD_LEN)\n\t\t\tgoto out_cud_release;\n\t\tx25->cudmatchlength = sub_addr.cudmatchlength;\n\t\trc = 0;\nout_cud_release:\n\t\trelease_sock(sk);\n\t\tbreak;\n\t}\n\n\tcase SIOCX25CALLACCPTAPPRV: {\n\t\trc = -EINVAL;\n\t\tlock_sock(sk);\n\t\tif (sk->sk_state == TCP_CLOSE) {\n\t\t\tclear_bit(X25_ACCPT_APPRV_FLAG, &x25->flags);\n\t\t\trc = 0;\n\t\t}\n\t\trelease_sock(sk);\n\t\tbreak;\n\t}\n\n\tcase SIOCX25SENDCALLACCPT:  {\n\t\trc = -EINVAL;\n\t\tlock_sock(sk);\n\t\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\t\tgoto out_sendcallaccpt_release;\n\t\t \n\t\tif (test_bit(X25_ACCPT_APPRV_FLAG, &x25->flags))\n\t\t\tgoto out_sendcallaccpt_release;\n\t\tx25_write_internal(sk, X25_CALL_ACCEPTED);\n\t\tx25->state = X25_STATE_3;\n\t\trc = 0;\nout_sendcallaccpt_release:\n\t\trelease_sock(sk);\n\t\tbreak;\n\t}\n\n\tdefault:\n\t\trc = -ENOIOCTLCMD;\n\t\tbreak;\n\t}\n\n\treturn rc;\n}\n\nstatic const struct net_proto_family x25_family_ops = {\n\t.family =\tAF_X25,\n\t.create =\tx25_create,\n\t.owner\t=\tTHIS_MODULE,\n};\n\n#ifdef CONFIG_COMPAT\nstatic int compat_x25_subscr_ioctl(unsigned int cmd,\n\t\tstruct compat_x25_subscrip_struct __user *x25_subscr32)\n{\n\tstruct compat_x25_subscrip_struct x25_subscr;\n\tstruct x25_neigh *nb;\n\tstruct net_device *dev;\n\tint rc = -EINVAL;\n\n\trc = -EFAULT;\n\tif (copy_from_user(&x25_subscr, x25_subscr32, sizeof(*x25_subscr32)))\n\t\tgoto out;\n\n\trc = -EINVAL;\n\tdev = x25_dev_get(x25_subscr.device);\n\tif (dev == NULL)\n\t\tgoto out;\n\n\tnb = x25_get_neigh(dev);\n\tif (nb == NULL)\n\t\tgoto out_dev_put;\n\n\tdev_put(dev);\n\n\tif (cmd == SIOCX25GSUBSCRIP) {\n\t\tread_lock_bh(&x25_neigh_list_lock);\n\t\tx25_subscr.extended = nb->extended;\n\t\tx25_subscr.global_facil_mask = nb->global_facil_mask;\n\t\tread_unlock_bh(&x25_neigh_list_lock);\n\t\trc = copy_to_user(x25_subscr32, &x25_subscr,\n\t\t\t\tsizeof(*x25_subscr32)) ? -EFAULT : 0;\n\t} else {\n\t\trc = -EINVAL;\n\t\tif (x25_subscr.extended == 0 || x25_subscr.extended == 1) {\n\t\t\trc = 0;\n\t\t\twrite_lock_bh(&x25_neigh_list_lock);\n\t\t\tnb->extended = x25_subscr.extended;\n\t\t\tnb->global_facil_mask = x25_subscr.global_facil_mask;\n\t\t\twrite_unlock_bh(&x25_neigh_list_lock);\n\t\t}\n\t}\n\tx25_neigh_put(nb);\nout:\n\treturn rc;\nout_dev_put:\n\tdev_put(dev);\n\tgoto out;\n}\n\nstatic int compat_x25_ioctl(struct socket *sock, unsigned int cmd,\n\t\t\t\tunsigned long arg)\n{\n\tvoid __user *argp = compat_ptr(arg);\n\tint rc = -ENOIOCTLCMD;\n\n\tswitch(cmd) {\n\tcase TIOCOUTQ:\n\tcase TIOCINQ:\n\t\trc = x25_ioctl(sock, cmd, (unsigned long)argp);\n\t\tbreak;\n\tcase SIOCGIFADDR:\n\tcase SIOCSIFADDR:\n\tcase SIOCGIFDSTADDR:\n\tcase SIOCSIFDSTADDR:\n\tcase SIOCGIFBRDADDR:\n\tcase SIOCSIFBRDADDR:\n\tcase SIOCGIFNETMASK:\n\tcase SIOCSIFNETMASK:\n\tcase SIOCGIFMETRIC:\n\tcase SIOCSIFMETRIC:\n\t\trc = -EINVAL;\n\t\tbreak;\n\tcase SIOCADDRT:\n\tcase SIOCDELRT:\n\t\trc = -EPERM;\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\tbreak;\n\t\trc = x25_route_ioctl(cmd, argp);\n\t\tbreak;\n\tcase SIOCX25GSUBSCRIP:\n\t\trc = compat_x25_subscr_ioctl(cmd, argp);\n\t\tbreak;\n\tcase SIOCX25SSUBSCRIP:\n\t\trc = -EPERM;\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\tbreak;\n\t\trc = compat_x25_subscr_ioctl(cmd, argp);\n\t\tbreak;\n\tcase SIOCX25GFACILITIES:\n\tcase SIOCX25SFACILITIES:\n\tcase SIOCX25GDTEFACILITIES:\n\tcase SIOCX25SDTEFACILITIES:\n\tcase SIOCX25GCALLUSERDATA:\n\tcase SIOCX25SCALLUSERDATA:\n\tcase SIOCX25GCAUSEDIAG:\n\tcase SIOCX25SCAUSEDIAG:\n\tcase SIOCX25SCUDMATCHLEN:\n\tcase SIOCX25CALLACCPTAPPRV:\n\tcase SIOCX25SENDCALLACCPT:\n\t\trc = x25_ioctl(sock, cmd, (unsigned long)argp);\n\t\tbreak;\n\tdefault:\n\t\trc = -ENOIOCTLCMD;\n\t\tbreak;\n\t}\n\treturn rc;\n}\n#endif\n\nstatic const struct proto_ops x25_proto_ops = {\n\t.family =\tAF_X25,\n\t.owner =\tTHIS_MODULE,\n\t.release =\tx25_release,\n\t.bind =\t\tx25_bind,\n\t.connect =\tx25_connect,\n\t.socketpair =\tsock_no_socketpair,\n\t.accept =\tx25_accept,\n\t.getname =\tx25_getname,\n\t.poll =\t\tdatagram_poll,\n\t.ioctl =\tx25_ioctl,\n#ifdef CONFIG_COMPAT\n\t.compat_ioctl = compat_x25_ioctl,\n#endif\n\t.gettstamp =\tsock_gettstamp,\n\t.listen =\tx25_listen,\n\t.shutdown =\tsock_no_shutdown,\n\t.setsockopt =\tx25_setsockopt,\n\t.getsockopt =\tx25_getsockopt,\n\t.sendmsg =\tx25_sendmsg,\n\t.recvmsg =\tx25_recvmsg,\n\t.mmap =\t\tsock_no_mmap,\n};\n\nstatic struct packet_type x25_packet_type __read_mostly = {\n\t.type =\tcpu_to_be16(ETH_P_X25),\n\t.func =\tx25_lapb_receive_frame,\n};\n\nstatic struct notifier_block x25_dev_notifier = {\n\t.notifier_call = x25_device_event,\n};\n\nvoid x25_kill_by_neigh(struct x25_neigh *nb)\n{\n\tstruct sock *s;\n\n\twrite_lock_bh(&x25_list_lock);\n\n\tsk_for_each(s, &x25_list) {\n\t\tif (x25_sk(s)->neighbour == nb) {\n\t\t\twrite_unlock_bh(&x25_list_lock);\n\t\t\tlock_sock(s);\n\t\t\tx25_disconnect(s, ENETUNREACH, 0, 0);\n\t\t\trelease_sock(s);\n\t\t\twrite_lock_bh(&x25_list_lock);\n\t\t}\n\t}\n\twrite_unlock_bh(&x25_list_lock);\n\n\t \n\tx25_clear_forward_by_dev(nb->dev);\n}\n\nstatic int __init x25_init(void)\n{\n\tint rc;\n\n\trc = proto_register(&x25_proto, 0);\n\tif (rc)\n\t\tgoto out;\n\n\trc = sock_register(&x25_family_ops);\n\tif (rc)\n\t\tgoto out_proto;\n\n\tdev_add_pack(&x25_packet_type);\n\n\trc = register_netdevice_notifier(&x25_dev_notifier);\n\tif (rc)\n\t\tgoto out_sock;\n\n\trc = x25_register_sysctl();\n\tif (rc)\n\t\tgoto out_dev;\n\n\trc = x25_proc_init();\n\tif (rc)\n\t\tgoto out_sysctl;\n\n\tpr_info(\"Linux Version 0.2\\n\");\n\nout:\n\treturn rc;\nout_sysctl:\n\tx25_unregister_sysctl();\nout_dev:\n\tunregister_netdevice_notifier(&x25_dev_notifier);\nout_sock:\n\tdev_remove_pack(&x25_packet_type);\n\tsock_unregister(AF_X25);\nout_proto:\n\tproto_unregister(&x25_proto);\n\tgoto out;\n}\nmodule_init(x25_init);\n\nstatic void __exit x25_exit(void)\n{\n\tx25_proc_exit();\n\tx25_link_free();\n\tx25_route_free();\n\n\tx25_unregister_sysctl();\n\n\tunregister_netdevice_notifier(&x25_dev_notifier);\n\n\tdev_remove_pack(&x25_packet_type);\n\n\tsock_unregister(AF_X25);\n\tproto_unregister(&x25_proto);\n}\nmodule_exit(x25_exit);\n\nMODULE_AUTHOR(\"Jonathan Naylor <g4klx@g4klx.demon.co.uk>\");\nMODULE_DESCRIPTION(\"The X.25 Packet Layer network layer protocol\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS_NETPROTO(PF_X25);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}