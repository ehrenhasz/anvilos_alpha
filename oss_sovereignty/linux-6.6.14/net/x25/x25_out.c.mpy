{
  "module_name": "x25_out.c",
  "hash_id": "af98a55a9a2a1a8678b0f249d062580f6fa2653906b9595090f0a47bf873a335",
  "original_prompt": "Ingested from linux-6.6.14/net/x25/x25_out.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <linux/socket.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/skbuff.h>\n#include <net/sock.h>\n#include <net/x25.h>\n\nstatic int x25_pacsize_to_bytes(unsigned int pacsize)\n{\n\tint bytes = 1;\n\n\tif (!pacsize)\n\t\treturn 128;\n\n\twhile (pacsize-- > 0)\n\t\tbytes *= 2;\n\n\treturn bytes;\n}\n\n \nint x25_output(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct sk_buff *skbn;\n\tunsigned char header[X25_EXT_MIN_LEN];\n\tint err, frontlen, len;\n\tint sent=0, noblock = X25_SKB_CB(skb)->flags & MSG_DONTWAIT;\n\tstruct x25_sock *x25 = x25_sk(sk);\n\tint header_len = x25->neighbour->extended ? X25_EXT_MIN_LEN :\n\t\t\t\t\t\t    X25_STD_MIN_LEN;\n\tint max_len = x25_pacsize_to_bytes(x25->facilities.pacsize_out);\n\n\tif (skb->len - header_len > max_len) {\n\t\t \n\t\tskb_copy_from_linear_data(skb, header, header_len);\n\t\tskb_pull(skb, header_len);\n\n\t\tfrontlen = skb_headroom(skb);\n\n\t\twhile (skb->len > 0) {\n\t\t\trelease_sock(sk);\n\t\t\tskbn = sock_alloc_send_skb(sk, frontlen + max_len,\n\t\t\t\t\t\t   noblock, &err);\n\t\t\tlock_sock(sk);\n\t\t\tif (!skbn) {\n\t\t\t\tif (err == -EWOULDBLOCK && noblock){\n\t\t\t\t\tkfree_skb(skb);\n\t\t\t\t\treturn sent;\n\t\t\t\t}\n\t\t\t\tSOCK_DEBUG(sk, \"x25_output: fragment alloc\"\n\t\t\t\t\t       \" failed, err=%d, %d bytes \"\n\t\t\t\t\t       \"sent\\n\", err, sent);\n\t\t\t\treturn err;\n\t\t\t}\n\n\t\t\tskb_reserve(skbn, frontlen);\n\n\t\t\tlen = max_len > skb->len ? skb->len : max_len;\n\n\t\t\t \n\t\t\tskb_copy_from_linear_data(skb, skb_put(skbn, len), len);\n\t\t\tskb_pull(skb, len);\n\n\t\t\t \n\t\t\tskb_push(skbn, header_len);\n\t\t\tskb_copy_to_linear_data(skbn, header, header_len);\n\n\t\t\tif (skb->len > 0) {\n\t\t\t\tif (x25->neighbour->extended)\n\t\t\t\t\tskbn->data[3] |= X25_EXT_M_BIT;\n\t\t\t\telse\n\t\t\t\t\tskbn->data[2] |= X25_STD_M_BIT;\n\t\t\t}\n\n\t\t\tskb_queue_tail(&sk->sk_write_queue, skbn);\n\t\t\tsent += len;\n\t\t}\n\n\t\tkfree_skb(skb);\n\t} else {\n\t\tskb_queue_tail(&sk->sk_write_queue, skb);\n\t\tsent = skb->len - header_len;\n\t}\n\treturn sent;\n}\n\n \nstatic void x25_send_iframe(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct x25_sock *x25 = x25_sk(sk);\n\n\tif (!skb)\n\t\treturn;\n\n\tif (x25->neighbour->extended) {\n\t\tskb->data[2]  = (x25->vs << 1) & 0xFE;\n\t\tskb->data[3] &= X25_EXT_M_BIT;\n\t\tskb->data[3] |= (x25->vr << 1) & 0xFE;\n\t} else {\n\t\tskb->data[2] &= X25_STD_M_BIT;\n\t\tskb->data[2] |= (x25->vs << 1) & 0x0E;\n\t\tskb->data[2] |= (x25->vr << 5) & 0xE0;\n\t}\n\n\tx25_transmit_link(skb, x25->neighbour);\n}\n\nvoid x25_kick(struct sock *sk)\n{\n\tstruct sk_buff *skb, *skbn;\n\tunsigned short start, end;\n\tint modulus;\n\tstruct x25_sock *x25 = x25_sk(sk);\n\n\tif (x25->state != X25_STATE_3)\n\t\treturn;\n\n\t \n\tif (skb_peek(&x25->interrupt_out_queue) != NULL &&\n\t\t!test_and_set_bit(X25_INTERRUPT_FLAG, &x25->flags)) {\n\n\t\tskb = skb_dequeue(&x25->interrupt_out_queue);\n\t\tx25_transmit_link(skb, x25->neighbour);\n\t}\n\n\tif (x25->condition & X25_COND_PEER_RX_BUSY)\n\t\treturn;\n\n\tif (!skb_peek(&sk->sk_write_queue))\n\t\treturn;\n\n\tmodulus = x25->neighbour->extended ? X25_EMODULUS : X25_SMODULUS;\n\n\tstart   = skb_peek(&x25->ack_queue) ? x25->vs : x25->va;\n\tend     = (x25->va + x25->facilities.winsize_out) % modulus;\n\n\tif (start == end)\n\t\treturn;\n\n\tx25->vs = start;\n\n\t \n\n\tskb = skb_dequeue(&sk->sk_write_queue);\n\n\tdo {\n\t\tif ((skbn = skb_clone(skb, GFP_ATOMIC)) == NULL) {\n\t\t\tskb_queue_head(&sk->sk_write_queue, skb);\n\t\t\tbreak;\n\t\t}\n\n\t\tskb_set_owner_w(skbn, sk);\n\n\t\t \n\t\tx25_send_iframe(sk, skbn);\n\n\t\tx25->vs = (x25->vs + 1) % modulus;\n\n\t\t \n\t\tskb_queue_tail(&x25->ack_queue, skb);\n\n\t} while (x25->vs != end &&\n\t\t (skb = skb_dequeue(&sk->sk_write_queue)) != NULL);\n\n\tx25->vl         = x25->vr;\n\tx25->condition &= ~X25_COND_ACK_PENDING;\n\n\tx25_stop_timer(sk);\n}\n\n \n\nvoid x25_enquiry_response(struct sock *sk)\n{\n\tstruct x25_sock *x25 = x25_sk(sk);\n\n\tif (x25->condition & X25_COND_OWN_RX_BUSY)\n\t\tx25_write_internal(sk, X25_RNR);\n\telse\n\t\tx25_write_internal(sk, X25_RR);\n\n\tx25->vl         = x25->vr;\n\tx25->condition &= ~X25_COND_ACK_PENDING;\n\n\tx25_stop_timer(sk);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}