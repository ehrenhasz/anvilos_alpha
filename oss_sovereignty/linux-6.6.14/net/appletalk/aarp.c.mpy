{
  "module_name": "aarp.c",
  "hash_id": "761ebfbdab8f7fd26f8675485d8f4e72b9817e8b11e50a4b1cb335d56d2c8deb",
  "original_prompt": "Ingested from linux-6.6.14/net/appletalk/aarp.c",
  "human_readable_source": "\n \n\n#include <linux/if_arp.h>\n#include <linux/slab.h>\n#include <net/sock.h>\n#include <net/datalink.h>\n#include <net/psnap.h>\n#include <linux/atalk.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/etherdevice.h>\n\nint sysctl_aarp_expiry_time = AARP_EXPIRY_TIME;\nint sysctl_aarp_tick_time = AARP_TICK_TIME;\nint sysctl_aarp_retransmit_limit = AARP_RETRANSMIT_LIMIT;\nint sysctl_aarp_resolve_time = AARP_RESOLVE_TIME;\n\n \n \nstruct aarp_entry {\n\t \n\tunsigned long\t\tlast_sent;\n\tstruct sk_buff_head\tpacket_queue;\n\tint\t\t\tstatus;\n\tunsigned long\t\texpires_at;\n\tstruct atalk_addr\ttarget_addr;\n\tstruct net_device\t*dev;\n\tchar\t\t\thwaddr[ETH_ALEN];\n\tunsigned short\t\txmit_count;\n\tstruct aarp_entry\t*next;\n};\n\n \nstatic struct aarp_entry *resolved[AARP_HASH_SIZE];\nstatic struct aarp_entry *unresolved[AARP_HASH_SIZE];\nstatic struct aarp_entry *proxies[AARP_HASH_SIZE];\nstatic int unresolved_count;\n\n \nstatic DEFINE_RWLOCK(aarp_lock);\n\n \nstatic struct timer_list aarp_timer;\n\n \nstatic void __aarp_expire(struct aarp_entry *a)\n{\n\tskb_queue_purge(&a->packet_queue);\n\tkfree(a);\n}\n\n \nstatic void __aarp_send_query(struct aarp_entry *a)\n{\n\tstatic unsigned char aarp_eth_multicast[ETH_ALEN] =\n\t\t\t\t\t{ 0x09, 0x00, 0x07, 0xFF, 0xFF, 0xFF };\n\tstruct net_device *dev = a->dev;\n\tstruct elapaarp *eah;\n\tint len = dev->hard_header_len + sizeof(*eah) + aarp_dl->header_length;\n\tstruct sk_buff *skb = alloc_skb(len, GFP_ATOMIC);\n\tstruct atalk_addr *sat = atalk_find_dev_addr(dev);\n\n\tif (!skb)\n\t\treturn;\n\n\tif (!sat) {\n\t\tkfree_skb(skb);\n\t\treturn;\n\t}\n\n\t \n\tskb_reserve(skb, dev->hard_header_len + aarp_dl->header_length);\n\tskb_reset_network_header(skb);\n\tskb_reset_transport_header(skb);\n\tskb_put(skb, sizeof(*eah));\n\tskb->protocol    = htons(ETH_P_ATALK);\n\tskb->dev\t = dev;\n\teah\t\t = aarp_hdr(skb);\n\n\t \n\teah->hw_type\t = htons(AARP_HW_TYPE_ETHERNET);\n\teah->pa_type\t = htons(ETH_P_ATALK);\n\teah->hw_len\t = ETH_ALEN;\n\teah->pa_len\t = AARP_PA_ALEN;\n\teah->function\t = htons(AARP_REQUEST);\n\n\tether_addr_copy(eah->hw_src, dev->dev_addr);\n\n\teah->pa_src_zero = 0;\n\teah->pa_src_net\t = sat->s_net;\n\teah->pa_src_node = sat->s_node;\n\n\teth_zero_addr(eah->hw_dst);\n\n\teah->pa_dst_zero = 0;\n\teah->pa_dst_net\t = a->target_addr.s_net;\n\teah->pa_dst_node = a->target_addr.s_node;\n\n\t \n\taarp_dl->request(aarp_dl, skb, aarp_eth_multicast);\n\t \n\ta->xmit_count++;\n\ta->last_sent = jiffies;\n}\n\n \nstatic void aarp_send_reply(struct net_device *dev, struct atalk_addr *us,\n\t\t\t    struct atalk_addr *them, unsigned char *sha)\n{\n\tstruct elapaarp *eah;\n\tint len = dev->hard_header_len + sizeof(*eah) + aarp_dl->header_length;\n\tstruct sk_buff *skb = alloc_skb(len, GFP_ATOMIC);\n\n\tif (!skb)\n\t\treturn;\n\n\t \n\tskb_reserve(skb, dev->hard_header_len + aarp_dl->header_length);\n\tskb_reset_network_header(skb);\n\tskb_reset_transport_header(skb);\n\tskb_put(skb, sizeof(*eah));\n\tskb->protocol    = htons(ETH_P_ATALK);\n\tskb->dev\t = dev;\n\teah\t\t = aarp_hdr(skb);\n\n\t \n\teah->hw_type\t = htons(AARP_HW_TYPE_ETHERNET);\n\teah->pa_type\t = htons(ETH_P_ATALK);\n\teah->hw_len\t = ETH_ALEN;\n\teah->pa_len\t = AARP_PA_ALEN;\n\teah->function\t = htons(AARP_REPLY);\n\n\tether_addr_copy(eah->hw_src, dev->dev_addr);\n\n\teah->pa_src_zero = 0;\n\teah->pa_src_net\t = us->s_net;\n\teah->pa_src_node = us->s_node;\n\n\tif (!sha)\n\t\teth_zero_addr(eah->hw_dst);\n\telse\n\t\tether_addr_copy(eah->hw_dst, sha);\n\n\teah->pa_dst_zero = 0;\n\teah->pa_dst_net\t = them->s_net;\n\teah->pa_dst_node = them->s_node;\n\n\t \n\taarp_dl->request(aarp_dl, skb, sha);\n}\n\n \n\nstatic void aarp_send_probe(struct net_device *dev, struct atalk_addr *us)\n{\n\tstruct elapaarp *eah;\n\tint len = dev->hard_header_len + sizeof(*eah) + aarp_dl->header_length;\n\tstruct sk_buff *skb = alloc_skb(len, GFP_ATOMIC);\n\tstatic unsigned char aarp_eth_multicast[ETH_ALEN] =\n\t\t\t\t\t{ 0x09, 0x00, 0x07, 0xFF, 0xFF, 0xFF };\n\n\tif (!skb)\n\t\treturn;\n\n\t \n\tskb_reserve(skb, dev->hard_header_len + aarp_dl->header_length);\n\tskb_reset_network_header(skb);\n\tskb_reset_transport_header(skb);\n\tskb_put(skb, sizeof(*eah));\n\tskb->protocol    = htons(ETH_P_ATALK);\n\tskb->dev\t = dev;\n\teah\t\t = aarp_hdr(skb);\n\n\t \n\teah->hw_type\t = htons(AARP_HW_TYPE_ETHERNET);\n\teah->pa_type\t = htons(ETH_P_ATALK);\n\teah->hw_len\t = ETH_ALEN;\n\teah->pa_len\t = AARP_PA_ALEN;\n\teah->function\t = htons(AARP_PROBE);\n\n\tether_addr_copy(eah->hw_src, dev->dev_addr);\n\n\teah->pa_src_zero = 0;\n\teah->pa_src_net\t = us->s_net;\n\teah->pa_src_node = us->s_node;\n\n\teth_zero_addr(eah->hw_dst);\n\n\teah->pa_dst_zero = 0;\n\teah->pa_dst_net\t = us->s_net;\n\teah->pa_dst_node = us->s_node;\n\n\t \n\taarp_dl->request(aarp_dl, skb, aarp_eth_multicast);\n}\n\n \n\nstatic void __aarp_expire_timer(struct aarp_entry **n)\n{\n\tstruct aarp_entry *t;\n\n\twhile (*n)\n\t\t \n\t\tif (time_after(jiffies, (*n)->expires_at)) {\n\t\t\tt = *n;\n\t\t\t*n = (*n)->next;\n\t\t\t__aarp_expire(t);\n\t\t} else\n\t\t\tn = &((*n)->next);\n}\n\n \nstatic void __aarp_kick(struct aarp_entry **n)\n{\n\tstruct aarp_entry *t;\n\n\twhile (*n)\n\t\t \n\t\tif ((*n)->xmit_count >= sysctl_aarp_retransmit_limit) {\n\t\t\tt = *n;\n\t\t\t*n = (*n)->next;\n\t\t\t__aarp_expire(t);\n\t\t} else {\n\t\t\t__aarp_send_query(*n);\n\t\t\tn = &((*n)->next);\n\t\t}\n}\n\n \nstatic void __aarp_expire_device(struct aarp_entry **n, struct net_device *dev)\n{\n\tstruct aarp_entry *t;\n\n\twhile (*n)\n\t\tif ((*n)->dev == dev) {\n\t\t\tt = *n;\n\t\t\t*n = (*n)->next;\n\t\t\t__aarp_expire(t);\n\t\t} else\n\t\t\tn = &((*n)->next);\n}\n\n \nstatic void aarp_expire_timeout(struct timer_list *unused)\n{\n\tint ct;\n\n\twrite_lock_bh(&aarp_lock);\n\n\tfor (ct = 0; ct < AARP_HASH_SIZE; ct++) {\n\t\t__aarp_expire_timer(&resolved[ct]);\n\t\t__aarp_kick(&unresolved[ct]);\n\t\t__aarp_expire_timer(&unresolved[ct]);\n\t\t__aarp_expire_timer(&proxies[ct]);\n\t}\n\n\twrite_unlock_bh(&aarp_lock);\n\tmod_timer(&aarp_timer, jiffies +\n\t\t\t       (unresolved_count ? sysctl_aarp_tick_time :\n\t\t\t\tsysctl_aarp_expiry_time));\n}\n\n \nstatic int aarp_device_event(struct notifier_block *this, unsigned long event,\n\t\t\t     void *ptr)\n{\n\tstruct net_device *dev = netdev_notifier_info_to_dev(ptr);\n\tint ct;\n\n\tif (!net_eq(dev_net(dev), &init_net))\n\t\treturn NOTIFY_DONE;\n\n\tif (event == NETDEV_DOWN) {\n\t\twrite_lock_bh(&aarp_lock);\n\n\t\tfor (ct = 0; ct < AARP_HASH_SIZE; ct++) {\n\t\t\t__aarp_expire_device(&resolved[ct], dev);\n\t\t\t__aarp_expire_device(&unresolved[ct], dev);\n\t\t\t__aarp_expire_device(&proxies[ct], dev);\n\t\t}\n\n\t\twrite_unlock_bh(&aarp_lock);\n\t}\n\treturn NOTIFY_DONE;\n}\n\n \nstatic void __aarp_expire_all(struct aarp_entry **n)\n{\n\tstruct aarp_entry *t;\n\n\twhile (*n) {\n\t\tt = *n;\n\t\t*n = (*n)->next;\n\t\t__aarp_expire(t);\n\t}\n}\n\n \nstatic void aarp_purge(void)\n{\n\tint ct;\n\n\twrite_lock_bh(&aarp_lock);\n\tfor (ct = 0; ct < AARP_HASH_SIZE; ct++) {\n\t\t__aarp_expire_all(&resolved[ct]);\n\t\t__aarp_expire_all(&unresolved[ct]);\n\t\t__aarp_expire_all(&proxies[ct]);\n\t}\n\twrite_unlock_bh(&aarp_lock);\n}\n\n \nstatic struct aarp_entry *aarp_alloc(void)\n{\n\tstruct aarp_entry *a = kmalloc(sizeof(*a), GFP_ATOMIC);\n\n\tif (a)\n\t\tskb_queue_head_init(&a->packet_queue);\n\treturn a;\n}\n\n \nstatic struct aarp_entry *__aarp_find_entry(struct aarp_entry *list,\n\t\t\t\t\t    struct net_device *dev,\n\t\t\t\t\t    struct atalk_addr *sat)\n{\n\twhile (list) {\n\t\tif (list->target_addr.s_net == sat->s_net &&\n\t\t    list->target_addr.s_node == sat->s_node &&\n\t\t    list->dev == dev)\n\t\t\tbreak;\n\t\tlist = list->next;\n\t}\n\n\treturn list;\n}\n\n \nvoid aarp_proxy_remove(struct net_device *dev, struct atalk_addr *sa)\n{\n\tint hash = sa->s_node % (AARP_HASH_SIZE - 1);\n\tstruct aarp_entry *a;\n\n\twrite_lock_bh(&aarp_lock);\n\n\ta = __aarp_find_entry(proxies[hash], dev, sa);\n\tif (a)\n\t\ta->expires_at = jiffies - 1;\n\n\twrite_unlock_bh(&aarp_lock);\n}\n\n \nstatic struct atalk_addr *__aarp_proxy_find(struct net_device *dev,\n\t\t\t\t\t    struct atalk_addr *sa)\n{\n\tint hash = sa->s_node % (AARP_HASH_SIZE - 1);\n\tstruct aarp_entry *a = __aarp_find_entry(proxies[hash], dev, sa);\n\n\treturn a ? sa : NULL;\n}\n\n \nstatic void aarp_send_probe_phase1(struct atalk_iface *iface)\n{\n\tstruct ifreq atreq;\n\tstruct sockaddr_at *sa = (struct sockaddr_at *)&atreq.ifr_addr;\n\tconst struct net_device_ops *ops = iface->dev->netdev_ops;\n\n\tsa->sat_addr.s_node = iface->address.s_node;\n\tsa->sat_addr.s_net = ntohs(iface->address.s_net);\n\n\t \n\tif (!(ops->ndo_do_ioctl(iface->dev, &atreq, SIOCSIFADDR))) {\n\t\tops->ndo_do_ioctl(iface->dev, &atreq, SIOCGIFADDR);\n\t\tif (iface->address.s_net != htons(sa->sat_addr.s_net) ||\n\t\t    iface->address.s_node != sa->sat_addr.s_node)\n\t\t\tiface->status |= ATIF_PROBE_FAIL;\n\n\t\tiface->address.s_net  = htons(sa->sat_addr.s_net);\n\t\tiface->address.s_node = sa->sat_addr.s_node;\n\t}\n}\n\n\nvoid aarp_probe_network(struct atalk_iface *atif)\n{\n\tif (atif->dev->type == ARPHRD_LOCALTLK ||\n\t    atif->dev->type == ARPHRD_PPP)\n\t\taarp_send_probe_phase1(atif);\n\telse {\n\t\tunsigned int count;\n\n\t\tfor (count = 0; count < AARP_RETRANSMIT_LIMIT; count++) {\n\t\t\taarp_send_probe(atif->dev, &atif->address);\n\n\t\t\t \n\t\t\tmsleep(100);\n\n\t\t\tif (atif->status & ATIF_PROBE_FAIL)\n\t\t\t\tbreak;\n\t\t}\n\t}\n}\n\nint aarp_proxy_probe_network(struct atalk_iface *atif, struct atalk_addr *sa)\n{\n\tint hash, retval = -EPROTONOSUPPORT;\n\tstruct aarp_entry *entry;\n\tunsigned int count;\n\n\t \n\tif (atif->dev->type == ARPHRD_LOCALTLK ||\n\t    atif->dev->type == ARPHRD_PPP)\n\t\tgoto out;\n\n\t \n\tentry = aarp_alloc();\n\tretval = -ENOMEM;\n\tif (!entry)\n\t\tgoto out;\n\n\tentry->expires_at = -1;\n\tentry->status = ATIF_PROBE;\n\tentry->target_addr.s_node = sa->s_node;\n\tentry->target_addr.s_net = sa->s_net;\n\tentry->dev = atif->dev;\n\n\twrite_lock_bh(&aarp_lock);\n\n\thash = sa->s_node % (AARP_HASH_SIZE - 1);\n\tentry->next = proxies[hash];\n\tproxies[hash] = entry;\n\n\tfor (count = 0; count < AARP_RETRANSMIT_LIMIT; count++) {\n\t\taarp_send_probe(atif->dev, sa);\n\n\t\t \n\t\twrite_unlock_bh(&aarp_lock);\n\t\tmsleep(100);\n\t\twrite_lock_bh(&aarp_lock);\n\n\t\tif (entry->status & ATIF_PROBE_FAIL)\n\t\t\tbreak;\n\t}\n\n\tif (entry->status & ATIF_PROBE_FAIL) {\n\t\tentry->expires_at = jiffies - 1;  \n\t\tretval = -EADDRINUSE;  \n\t} else {  \n\t\tentry->status &= ~ATIF_PROBE;\n\t\tretval = 1;\n\t}\n\n\twrite_unlock_bh(&aarp_lock);\nout:\n\treturn retval;\n}\n\n \nint aarp_send_ddp(struct net_device *dev, struct sk_buff *skb,\n\t\t  struct atalk_addr *sa, void *hwaddr)\n{\n\tstatic char ddp_eth_multicast[ETH_ALEN] =\n\t\t{ 0x09, 0x00, 0x07, 0xFF, 0xFF, 0xFF };\n\tint hash;\n\tstruct aarp_entry *a;\n\n\tskb_reset_network_header(skb);\n\n\t \n\tif (dev->type == ARPHRD_LOCALTLK) {\n\t\tstruct atalk_addr *at = atalk_find_dev_addr(dev);\n\t\tstruct ddpehdr *ddp = (struct ddpehdr *)skb->data;\n\t\tint ft = 2;\n\n\t\t \n\n\t\tif ((!ddp->deh_snet || at->s_net == ddp->deh_snet) &&\n\t\t    (!ddp->deh_dnet || at->s_net == ddp->deh_dnet)) {\n\t\t\tskb_pull(skb, sizeof(*ddp) - 4);\n\n\t\t\t \n\t\t\t*((__be16 *)skb->data) = htons(skb->len);\n\t\t\tft = 1;\n\t\t}\n\t\t \n\n\t\tskb_push(skb, 3);\n\t\tskb->data[0] = sa->s_node;\n\t\tskb->data[1] = at->s_node;\n\t\tskb->data[2] = ft;\n\t\tskb->dev     = dev;\n\t\tgoto sendit;\n\t}\n\n\t \n\tif (dev->type == ARPHRD_PPP) {\n\t\tskb->protocol = htons(ETH_P_PPPTALK);\n\t\tskb->dev = dev;\n\t\tgoto sendit;\n\t}\n\n\t \n\tif (dev->type != ARPHRD_ETHER)\n\t\tgoto free_it;\n\n\tskb->dev = dev;\n\tskb->protocol = htons(ETH_P_ATALK);\n\thash = sa->s_node % (AARP_HASH_SIZE - 1);\n\n\t \n\tif (sa->s_node == ATADDR_BCAST) {\n\t\t \n\t\tddp_dl->request(ddp_dl, skb, ddp_eth_multicast);\n\t\tgoto sent;\n\t}\n\n\twrite_lock_bh(&aarp_lock);\n\ta = __aarp_find_entry(resolved[hash], dev, sa);\n\n\tif (a) {  \n\t\ta->expires_at = jiffies + (sysctl_aarp_expiry_time * 10);\n\t\tddp_dl->request(ddp_dl, skb, a->hwaddr);\n\t\twrite_unlock_bh(&aarp_lock);\n\t\tgoto sent;\n\t}\n\n\t \n\ta = __aarp_find_entry(unresolved[hash], dev, sa);\n\tif (a) {  \n\t\tskb_queue_tail(&a->packet_queue, skb);\n\t\tgoto out_unlock;\n\t}\n\n\t \n\ta = aarp_alloc();\n\tif (!a) {\n\t\t \n\t\twrite_unlock_bh(&aarp_lock);\n\t\tgoto free_it;\n\t}\n\n\t \n\tskb_queue_tail(&a->packet_queue, skb);\n\ta->expires_at\t = jiffies + sysctl_aarp_resolve_time;\n\ta->dev\t\t = dev;\n\ta->next\t\t = unresolved[hash];\n\ta->target_addr\t = *sa;\n\ta->xmit_count\t = 0;\n\tunresolved[hash] = a;\n\tunresolved_count++;\n\n\t \n\t__aarp_send_query(a);\n\n\t \n\n\tif (unresolved_count == 1)\n\t\tmod_timer(&aarp_timer, jiffies + sysctl_aarp_tick_time);\n\n\t \nout_unlock:\n\twrite_unlock_bh(&aarp_lock);\n\n\t \n\tgoto sent;\n\nsendit:\n\tif (skb->sk)\n\t\tskb->priority = skb->sk->sk_priority;\n\tif (dev_queue_xmit(skb))\n\t\tgoto drop;\nsent:\n\treturn NET_XMIT_SUCCESS;\nfree_it:\n\tkfree_skb(skb);\ndrop:\n\treturn NET_XMIT_DROP;\n}\nEXPORT_SYMBOL(aarp_send_ddp);\n\n \nstatic void __aarp_resolved(struct aarp_entry **list, struct aarp_entry *a,\n\t\t\t    int hash)\n{\n\tstruct sk_buff *skb;\n\n\twhile (*list)\n\t\tif (*list == a) {\n\t\t\tunresolved_count--;\n\t\t\t*list = a->next;\n\n\t\t\t \n\t\t\ta->next = resolved[hash];\n\t\t\tresolved[hash] = a;\n\n\t\t\t \n\t\t\twhile ((skb = skb_dequeue(&a->packet_queue)) != NULL) {\n\t\t\t\ta->expires_at = jiffies +\n\t\t\t\t\t\tsysctl_aarp_expiry_time * 10;\n\t\t\t\tddp_dl->request(ddp_dl, skb, a->hwaddr);\n\t\t\t}\n\t\t} else\n\t\t\tlist = &((*list)->next);\n}\n\n \nstatic int aarp_rcv(struct sk_buff *skb, struct net_device *dev,\n\t\t    struct packet_type *pt, struct net_device *orig_dev)\n{\n\tstruct elapaarp *ea = aarp_hdr(skb);\n\tint hash, ret = 0;\n\t__u16 function;\n\tstruct aarp_entry *a;\n\tstruct atalk_addr sa, *ma, da;\n\tstruct atalk_iface *ifa;\n\n\tif (!net_eq(dev_net(dev), &init_net))\n\t\tgoto out0;\n\n\t \n\tif (dev->type != ARPHRD_ETHER)\n\t\tgoto out0;\n\n\t \n\tif (!skb_pull(skb, sizeof(*ea)))\n\t\tgoto out0;\n\n\tfunction = ntohs(ea->function);\n\n\t \n\tif (function < AARP_REQUEST || function > AARP_PROBE ||\n\t    ea->hw_len != ETH_ALEN || ea->pa_len != AARP_PA_ALEN ||\n\t    ea->pa_src_zero || ea->pa_dst_zero)\n\t\tgoto out0;\n\n\t \n\thash = ea->pa_src_node % (AARP_HASH_SIZE - 1);\n\n\t \n\tsa.s_node = ea->pa_src_node;\n\tsa.s_net = ea->pa_src_net;\n\n\t \n\tifa = atalk_find_dev(dev);\n\tif (!ifa)\n\t\tgoto out1;\n\n\tif (ifa->status & ATIF_PROBE &&\n\t    ifa->address.s_node == ea->pa_dst_node &&\n\t    ifa->address.s_net == ea->pa_dst_net) {\n\t\tifa->status |= ATIF_PROBE_FAIL;  \n\t\tgoto out1;\n\t}\n\n\t \n\tda.s_node = ea->pa_dst_node;\n\tda.s_net  = ea->pa_dst_net;\n\n\twrite_lock_bh(&aarp_lock);\n\ta = __aarp_find_entry(proxies[hash], dev, &da);\n\n\tif (a && a->status & ATIF_PROBE) {\n\t\ta->status |= ATIF_PROBE_FAIL;\n\t\t \n\t\tgoto unlock;\n\t}\n\n\tswitch (function) {\n\tcase AARP_REPLY:\n\t\tif (!unresolved_count)\t \n\t\t\tbreak;\n\n\t\t \n\t\ta = __aarp_find_entry(unresolved[hash], dev, &sa);\n\t\tif (!a || dev != a->dev)\n\t\t\tbreak;\n\n\t\t \n\t\tether_addr_copy(a->hwaddr, ea->hw_src);\n\t\t__aarp_resolved(&unresolved[hash], a, hash);\n\t\tif (!unresolved_count)\n\t\t\tmod_timer(&aarp_timer,\n\t\t\t\t  jiffies + sysctl_aarp_expiry_time);\n\t\tbreak;\n\n\tcase AARP_REQUEST:\n\tcase AARP_PROBE:\n\n\t\t \n\n\t\tsa.s_node = ea->pa_dst_node;\n\t\tsa.s_net  = ea->pa_dst_net;\n\n\t\t \n\t\tma = __aarp_proxy_find(dev, &sa);\n\t\tif (!ma)\n\t\t\tma = &ifa->address;\n\t\telse {  \n\t\t\tda.s_node = sa.s_node;\n\t\t\tda.s_net = sa.s_net;\n\t\t\tma = &da;\n\t\t}\n\n\t\tif (function == AARP_PROBE) {\n\t\t\t \n\t\t\ta = __aarp_find_entry(resolved[sa.s_node %\n\t\t\t\t\t\t       (AARP_HASH_SIZE - 1)],\n\t\t\t\t\t      skb->dev, &sa);\n\n\t\t\t \n\t\t\tif (a) {\n\t\t\t\ta->expires_at = jiffies - 1;\n\t\t\t\tmod_timer(&aarp_timer, jiffies +\n\t\t\t\t\t  sysctl_aarp_tick_time);\n\t\t\t}\n\t\t}\n\n\t\tif (sa.s_node != ma->s_node)\n\t\t\tbreak;\n\n\t\tif (sa.s_net && ma->s_net && sa.s_net != ma->s_net)\n\t\t\tbreak;\n\n\t\tsa.s_node = ea->pa_src_node;\n\t\tsa.s_net = ea->pa_src_net;\n\n\t\t \n\t\taarp_send_reply(dev, ma, &sa, ea->hw_src);\n\t\tbreak;\n\t}\n\nunlock:\n\twrite_unlock_bh(&aarp_lock);\nout1:\n\tret = 1;\nout0:\n\tkfree_skb(skb);\n\treturn ret;\n}\n\nstatic struct notifier_block aarp_notifier = {\n\t.notifier_call = aarp_device_event,\n};\n\nstatic unsigned char aarp_snap_id[] = { 0x00, 0x00, 0x00, 0x80, 0xF3 };\n\nint __init aarp_proto_init(void)\n{\n\tint rc;\n\n\taarp_dl = register_snap_client(aarp_snap_id, aarp_rcv);\n\tif (!aarp_dl) {\n\t\tprintk(KERN_CRIT \"Unable to register AARP with SNAP.\\n\");\n\t\treturn -ENOMEM;\n\t}\n\ttimer_setup(&aarp_timer, aarp_expire_timeout, 0);\n\taarp_timer.expires  = jiffies + sysctl_aarp_expiry_time;\n\tadd_timer(&aarp_timer);\n\trc = register_netdevice_notifier(&aarp_notifier);\n\tif (rc) {\n\t\tdel_timer_sync(&aarp_timer);\n\t\tunregister_snap_client(aarp_dl);\n\t}\n\treturn rc;\n}\n\n \nvoid aarp_device_down(struct net_device *dev)\n{\n\tint ct;\n\n\twrite_lock_bh(&aarp_lock);\n\n\tfor (ct = 0; ct < AARP_HASH_SIZE; ct++) {\n\t\t__aarp_expire_device(&resolved[ct], dev);\n\t\t__aarp_expire_device(&unresolved[ct], dev);\n\t\t__aarp_expire_device(&proxies[ct], dev);\n\t}\n\n\twrite_unlock_bh(&aarp_lock);\n}\n\n#ifdef CONFIG_PROC_FS\n \nstatic struct aarp_entry *iter_next(struct aarp_iter_state *iter, loff_t *pos)\n{\n\tint ct = iter->bucket;\n\tstruct aarp_entry **table = iter->table;\n\tloff_t off = 0;\n\tstruct aarp_entry *entry;\n\n rescan:\n\twhile (ct < AARP_HASH_SIZE) {\n\t\tfor (entry = table[ct]; entry; entry = entry->next) {\n\t\t\tif (!pos || ++off == *pos) {\n\t\t\t\titer->table = table;\n\t\t\t\titer->bucket = ct;\n\t\t\t\treturn entry;\n\t\t\t}\n\t\t}\n\t\t++ct;\n\t}\n\n\tif (table == resolved) {\n\t\tct = 0;\n\t\ttable = unresolved;\n\t\tgoto rescan;\n\t}\n\tif (table == unresolved) {\n\t\tct = 0;\n\t\ttable = proxies;\n\t\tgoto rescan;\n\t}\n\treturn NULL;\n}\n\nstatic void *aarp_seq_start(struct seq_file *seq, loff_t *pos)\n\t__acquires(aarp_lock)\n{\n\tstruct aarp_iter_state *iter = seq->private;\n\n\tread_lock_bh(&aarp_lock);\n\titer->table     = resolved;\n\titer->bucket    = 0;\n\n\treturn *pos ? iter_next(iter, pos) : SEQ_START_TOKEN;\n}\n\nstatic void *aarp_seq_next(struct seq_file *seq, void *v, loff_t *pos)\n{\n\tstruct aarp_entry *entry = v;\n\tstruct aarp_iter_state *iter = seq->private;\n\n\t++*pos;\n\n\t \n\tif (v == SEQ_START_TOKEN)\n\t\tentry = iter_next(iter, NULL);\n\n\t \n\telse if (entry->next)\n\t\tentry = entry->next;\n\n\t \n\telse {\n\t\t++iter->bucket;\n\t\tentry = iter_next(iter, NULL);\n\t}\n\treturn entry;\n}\n\nstatic void aarp_seq_stop(struct seq_file *seq, void *v)\n\t__releases(aarp_lock)\n{\n\tread_unlock_bh(&aarp_lock);\n}\n\nstatic const char *dt2str(unsigned long ticks)\n{\n\tstatic char buf[32];\n\n\tsprintf(buf, \"%ld.%02ld\", ticks / HZ, ((ticks % HZ) * 100) / HZ);\n\n\treturn buf;\n}\n\nstatic int aarp_seq_show(struct seq_file *seq, void *v)\n{\n\tstruct aarp_iter_state *iter = seq->private;\n\tstruct aarp_entry *entry = v;\n\tunsigned long now = jiffies;\n\n\tif (v == SEQ_START_TOKEN)\n\t\tseq_puts(seq,\n\t\t\t \"Address  Interface   Hardware Address\"\n\t\t\t \"   Expires LastSend  Retry Status\\n\");\n\telse {\n\t\tseq_printf(seq, \"%04X:%02X  %-12s\",\n\t\t\t   ntohs(entry->target_addr.s_net),\n\t\t\t   (unsigned int) entry->target_addr.s_node,\n\t\t\t   entry->dev ? entry->dev->name : \"????\");\n\t\tseq_printf(seq, \"%pM\", entry->hwaddr);\n\t\tseq_printf(seq, \" %8s\",\n\t\t\t   dt2str((long)entry->expires_at - (long)now));\n\t\tif (iter->table == unresolved)\n\t\t\tseq_printf(seq, \" %8s %6hu\",\n\t\t\t\t   dt2str(now - entry->last_sent),\n\t\t\t\t   entry->xmit_count);\n\t\telse\n\t\t\tseq_puts(seq, \"                \");\n\t\tseq_printf(seq, \" %s\\n\",\n\t\t\t   (iter->table == resolved) ? \"resolved\"\n\t\t\t   : (iter->table == unresolved) ? \"unresolved\"\n\t\t\t   : (iter->table == proxies) ? \"proxies\"\n\t\t\t   : \"unknown\");\n\t}\n\treturn 0;\n}\n\nconst struct seq_operations aarp_seq_ops = {\n\t.start  = aarp_seq_start,\n\t.next   = aarp_seq_next,\n\t.stop   = aarp_seq_stop,\n\t.show   = aarp_seq_show,\n};\n#endif\n\n \nvoid aarp_cleanup_module(void)\n{\n\tdel_timer_sync(&aarp_timer);\n\tunregister_netdevice_notifier(&aarp_notifier);\n\tunregister_snap_client(aarp_dl);\n\taarp_purge();\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}