{
  "module_name": "atalk_proc.c",
  "hash_id": "39fb617b5b6f01a884b098594f4e82783ff34a97f5d1350b2e5ffb29b1d1f715",
  "original_prompt": "Ingested from linux-6.6.14/net/appletalk/atalk_proc.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <net/net_namespace.h>\n#include <net/sock.h>\n#include <linux/atalk.h>\n#include <linux/export.h>\n\n\nstatic __inline__ struct atalk_iface *atalk_get_interface_idx(loff_t pos)\n{\n\tstruct atalk_iface *i;\n\n\tfor (i = atalk_interfaces; pos && i; i = i->next)\n\t\t--pos;\n\n\treturn i;\n}\n\nstatic void *atalk_seq_interface_start(struct seq_file *seq, loff_t *pos)\n\t__acquires(atalk_interfaces_lock)\n{\n\tloff_t l = *pos;\n\n\tread_lock_bh(&atalk_interfaces_lock);\n\treturn l ? atalk_get_interface_idx(--l) : SEQ_START_TOKEN;\n}\n\nstatic void *atalk_seq_interface_next(struct seq_file *seq, void *v, loff_t *pos)\n{\n\tstruct atalk_iface *i;\n\n\t++*pos;\n\tif (v == SEQ_START_TOKEN) {\n\t\ti = NULL;\n\t\tif (atalk_interfaces)\n\t\t\ti = atalk_interfaces;\n\t\tgoto out;\n\t}\n\ti = v;\n\ti = i->next;\nout:\n\treturn i;\n}\n\nstatic void atalk_seq_interface_stop(struct seq_file *seq, void *v)\n\t__releases(atalk_interfaces_lock)\n{\n\tread_unlock_bh(&atalk_interfaces_lock);\n}\n\nstatic int atalk_seq_interface_show(struct seq_file *seq, void *v)\n{\n\tstruct atalk_iface *iface;\n\n\tif (v == SEQ_START_TOKEN) {\n\t\tseq_puts(seq, \"Interface        Address   Networks  \"\n\t\t\t      \"Status\\n\");\n\t\tgoto out;\n\t}\n\n\tiface = v;\n\tseq_printf(seq, \"%-16s %04X:%02X  %04X-%04X  %d\\n\",\n\t\t   iface->dev->name, ntohs(iface->address.s_net),\n\t\t   iface->address.s_node, ntohs(iface->nets.nr_firstnet),\n\t\t   ntohs(iface->nets.nr_lastnet), iface->status);\nout:\n\treturn 0;\n}\n\nstatic __inline__ struct atalk_route *atalk_get_route_idx(loff_t pos)\n{\n\tstruct atalk_route *r;\n\n\tfor (r = atalk_routes; pos && r; r = r->next)\n\t\t--pos;\n\n\treturn r;\n}\n\nstatic void *atalk_seq_route_start(struct seq_file *seq, loff_t *pos)\n\t__acquires(atalk_routes_lock)\n{\n\tloff_t l = *pos;\n\n\tread_lock_bh(&atalk_routes_lock);\n\treturn l ? atalk_get_route_idx(--l) : SEQ_START_TOKEN;\n}\n\nstatic void *atalk_seq_route_next(struct seq_file *seq, void *v, loff_t *pos)\n{\n\tstruct atalk_route *r;\n\n\t++*pos;\n\tif (v == SEQ_START_TOKEN) {\n\t\tr = NULL;\n\t\tif (atalk_routes)\n\t\t\tr = atalk_routes;\n\t\tgoto out;\n\t}\n\tr = v;\n\tr = r->next;\nout:\n\treturn r;\n}\n\nstatic void atalk_seq_route_stop(struct seq_file *seq, void *v)\n\t__releases(atalk_routes_lock)\n{\n\tread_unlock_bh(&atalk_routes_lock);\n}\n\nstatic int atalk_seq_route_show(struct seq_file *seq, void *v)\n{\n\tstruct atalk_route *rt;\n\n\tif (v == SEQ_START_TOKEN) {\n\t\tseq_puts(seq, \"Target        Router  Flags Dev\\n\");\n\t\tgoto out;\n\t}\n\n\tif (atrtr_default.dev) {\n\t\trt = &atrtr_default;\n\t\tseq_printf(seq, \"Default     %04X:%02X  %-4d  %s\\n\",\n\t\t\t       ntohs(rt->gateway.s_net), rt->gateway.s_node,\n\t\t\t       rt->flags, rt->dev->name);\n\t}\n\n\trt = v;\n\tseq_printf(seq, \"%04X:%02X     %04X:%02X  %-4d  %s\\n\",\n\t\t   ntohs(rt->target.s_net), rt->target.s_node,\n\t\t   ntohs(rt->gateway.s_net), rt->gateway.s_node,\n\t\t   rt->flags, rt->dev->name);\nout:\n\treturn 0;\n}\n\nstatic void *atalk_seq_socket_start(struct seq_file *seq, loff_t *pos)\n\t__acquires(atalk_sockets_lock)\n{\n\tread_lock_bh(&atalk_sockets_lock);\n\treturn seq_hlist_start_head(&atalk_sockets, *pos);\n}\n\nstatic void *atalk_seq_socket_next(struct seq_file *seq, void *v, loff_t *pos)\n{\n\treturn seq_hlist_next(v, &atalk_sockets, pos);\n}\n\nstatic void atalk_seq_socket_stop(struct seq_file *seq, void *v)\n\t__releases(atalk_sockets_lock)\n{\n\tread_unlock_bh(&atalk_sockets_lock);\n}\n\nstatic int atalk_seq_socket_show(struct seq_file *seq, void *v)\n{\n\tstruct sock *s;\n\tstruct atalk_sock *at;\n\n\tif (v == SEQ_START_TOKEN) {\n\t\tseq_printf(seq, \"Type Local_addr  Remote_addr Tx_queue \"\n\t\t\t\t\"Rx_queue St UID\\n\");\n\t\tgoto out;\n\t}\n\n\ts = sk_entry(v);\n\tat = at_sk(s);\n\n\tseq_printf(seq, \"%02X   %04X:%02X:%02X  %04X:%02X:%02X  %08X:%08X \"\n\t\t\t\"%02X %u\\n\",\n\t\t   s->sk_type, ntohs(at->src_net), at->src_node, at->src_port,\n\t\t   ntohs(at->dest_net), at->dest_node, at->dest_port,\n\t\t   sk_wmem_alloc_get(s),\n\t\t   sk_rmem_alloc_get(s),\n\t\t   s->sk_state,\n\t\t   from_kuid_munged(seq_user_ns(seq), sock_i_uid(s)));\nout:\n\treturn 0;\n}\n\nstatic const struct seq_operations atalk_seq_interface_ops = {\n\t.start  = atalk_seq_interface_start,\n\t.next   = atalk_seq_interface_next,\n\t.stop   = atalk_seq_interface_stop,\n\t.show   = atalk_seq_interface_show,\n};\n\nstatic const struct seq_operations atalk_seq_route_ops = {\n\t.start  = atalk_seq_route_start,\n\t.next   = atalk_seq_route_next,\n\t.stop   = atalk_seq_route_stop,\n\t.show   = atalk_seq_route_show,\n};\n\nstatic const struct seq_operations atalk_seq_socket_ops = {\n\t.start  = atalk_seq_socket_start,\n\t.next   = atalk_seq_socket_next,\n\t.stop   = atalk_seq_socket_stop,\n\t.show   = atalk_seq_socket_show,\n};\n\nint __init atalk_proc_init(void)\n{\n\tif (!proc_mkdir(\"atalk\", init_net.proc_net))\n\t\treturn -ENOMEM;\n\n\tif (!proc_create_seq(\"atalk/interface\", 0444, init_net.proc_net,\n\t\t\t    &atalk_seq_interface_ops))\n\t\tgoto out;\n\n\tif (!proc_create_seq(\"atalk/route\", 0444, init_net.proc_net,\n\t\t\t    &atalk_seq_route_ops))\n\t\tgoto out;\n\n\tif (!proc_create_seq(\"atalk/socket\", 0444, init_net.proc_net,\n\t\t\t    &atalk_seq_socket_ops))\n\t\tgoto out;\n\n\tif (!proc_create_seq_private(\"atalk/arp\", 0444, init_net.proc_net,\n\t\t\t\t     &aarp_seq_ops,\n\t\t\t\t     sizeof(struct aarp_iter_state), NULL))\n\t\tgoto out;\n\n\treturn 0;\n\nout:\n\tremove_proc_subtree(\"atalk\", init_net.proc_net);\n\treturn -ENOMEM;\n}\n\nvoid atalk_proc_exit(void)\n{\n\tremove_proc_subtree(\"atalk\", init_net.proc_net);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}