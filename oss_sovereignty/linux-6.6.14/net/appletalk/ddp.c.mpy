{
  "module_name": "ddp.c",
  "hash_id": "15e09e3328312f11022f715c78e2404d4e76fa96614d0e5e9899636d6b4bafd8",
  "original_prompt": "Ingested from linux-6.6.14/net/appletalk/ddp.c",
  "human_readable_source": "\n \n\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/if_arp.h>\n#include <linux/termios.h>\t \n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <net/datalink.h>\n#include <net/psnap.h>\n#include <net/sock.h>\n#include <net/tcp_states.h>\n#include <net/route.h>\n#include <net/compat.h>\n#include <linux/atalk.h>\n#include <linux/highmem.h>\n\nstruct datalink_proto *ddp_dl, *aarp_dl;\nstatic const struct proto_ops atalk_dgram_ops;\n\n \n\nHLIST_HEAD(atalk_sockets);\nDEFINE_RWLOCK(atalk_sockets_lock);\n\nstatic inline void __atalk_insert_socket(struct sock *sk)\n{\n\tsk_add_node(sk, &atalk_sockets);\n}\n\nstatic inline void atalk_remove_socket(struct sock *sk)\n{\n\twrite_lock_bh(&atalk_sockets_lock);\n\tsk_del_node_init(sk);\n\twrite_unlock_bh(&atalk_sockets_lock);\n}\n\nstatic struct sock *atalk_search_socket(struct sockaddr_at *to,\n\t\t\t\t\tstruct atalk_iface *atif)\n{\n\tstruct sock *s;\n\n\tread_lock_bh(&atalk_sockets_lock);\n\tsk_for_each(s, &atalk_sockets) {\n\t\tstruct atalk_sock *at = at_sk(s);\n\n\t\tif (to->sat_port != at->src_port)\n\t\t\tcontinue;\n\n\t\tif (to->sat_addr.s_net == ATADDR_ANYNET &&\n\t\t    to->sat_addr.s_node == ATADDR_BCAST)\n\t\t\tgoto found;\n\n\t\tif (to->sat_addr.s_net == at->src_net &&\n\t\t    (to->sat_addr.s_node == at->src_node ||\n\t\t     to->sat_addr.s_node == ATADDR_BCAST ||\n\t\t     to->sat_addr.s_node == ATADDR_ANYNODE))\n\t\t\tgoto found;\n\n\t\t \n\t\tif (to->sat_addr.s_node == ATADDR_ANYNODE &&\n\t\t    to->sat_addr.s_net != ATADDR_ANYNET &&\n\t\t    atif->address.s_node == at->src_node) {\n\t\t\tto->sat_addr.s_node = atif->address.s_node;\n\t\t\tgoto found;\n\t\t}\n\t}\n\ts = NULL;\nfound:\n\tread_unlock_bh(&atalk_sockets_lock);\n\treturn s;\n}\n\n \nstatic struct sock *atalk_find_or_insert_socket(struct sock *sk,\n\t\t\t\t\t\tstruct sockaddr_at *sat)\n{\n\tstruct sock *s;\n\tstruct atalk_sock *at;\n\n\twrite_lock_bh(&atalk_sockets_lock);\n\tsk_for_each(s, &atalk_sockets) {\n\t\tat = at_sk(s);\n\n\t\tif (at->src_net == sat->sat_addr.s_net &&\n\t\t    at->src_node == sat->sat_addr.s_node &&\n\t\t    at->src_port == sat->sat_port)\n\t\t\tgoto found;\n\t}\n\ts = NULL;\n\t__atalk_insert_socket(sk);  \nfound:\n\twrite_unlock_bh(&atalk_sockets_lock);\n\treturn s;\n}\n\nstatic void atalk_destroy_timer(struct timer_list *t)\n{\n\tstruct sock *sk = from_timer(sk, t, sk_timer);\n\n\tif (sk_has_allocations(sk)) {\n\t\tsk->sk_timer.expires = jiffies + SOCK_DESTROY_TIME;\n\t\tadd_timer(&sk->sk_timer);\n\t} else\n\t\tsock_put(sk);\n}\n\nstatic inline void atalk_destroy_socket(struct sock *sk)\n{\n\tatalk_remove_socket(sk);\n\tskb_queue_purge(&sk->sk_receive_queue);\n\n\tif (sk_has_allocations(sk)) {\n\t\ttimer_setup(&sk->sk_timer, atalk_destroy_timer, 0);\n\t\tsk->sk_timer.expires\t= jiffies + SOCK_DESTROY_TIME;\n\t\tadd_timer(&sk->sk_timer);\n\t} else\n\t\tsock_put(sk);\n}\n\n \n\n \nstruct atalk_route *atalk_routes;\nDEFINE_RWLOCK(atalk_routes_lock);\n\nstruct atalk_iface *atalk_interfaces;\nDEFINE_RWLOCK(atalk_interfaces_lock);\n\n \nstruct atalk_route atrtr_default;\n\n \n \nstatic void atif_drop_device(struct net_device *dev)\n{\n\tstruct atalk_iface **iface = &atalk_interfaces;\n\tstruct atalk_iface *tmp;\n\n\twrite_lock_bh(&atalk_interfaces_lock);\n\twhile ((tmp = *iface) != NULL) {\n\t\tif (tmp->dev == dev) {\n\t\t\t*iface = tmp->next;\n\t\t\tdev_put(dev);\n\t\t\tkfree(tmp);\n\t\t\tdev->atalk_ptr = NULL;\n\t\t} else\n\t\t\tiface = &tmp->next;\n\t}\n\twrite_unlock_bh(&atalk_interfaces_lock);\n}\n\nstatic struct atalk_iface *atif_add_device(struct net_device *dev,\n\t\t\t\t\t   struct atalk_addr *sa)\n{\n\tstruct atalk_iface *iface = kzalloc(sizeof(*iface), GFP_KERNEL);\n\n\tif (!iface)\n\t\tgoto out;\n\n\tdev_hold(dev);\n\tiface->dev = dev;\n\tdev->atalk_ptr = iface;\n\tiface->address = *sa;\n\tiface->status = 0;\n\n\twrite_lock_bh(&atalk_interfaces_lock);\n\tiface->next = atalk_interfaces;\n\tatalk_interfaces = iface;\n\twrite_unlock_bh(&atalk_interfaces_lock);\nout:\n\treturn iface;\n}\n\n \nstatic int atif_probe_device(struct atalk_iface *atif)\n{\n\tint netrange = ntohs(atif->nets.nr_lastnet) -\n\t\t\tntohs(atif->nets.nr_firstnet) + 1;\n\tint probe_net = ntohs(atif->address.s_net);\n\tint probe_node = atif->address.s_node;\n\tint netct, nodect;\n\n\t \n\tif (probe_net == ATADDR_ANYNET) {\n\t\tprobe_net = ntohs(atif->nets.nr_firstnet);\n\t\tif (netrange)\n\t\t\tprobe_net += jiffies % netrange;\n\t}\n\tif (probe_node == ATADDR_ANYNODE)\n\t\tprobe_node = jiffies & 0xFF;\n\n\t \n\tatif->status |= ATIF_PROBE;\n\tfor (netct = 0; netct <= netrange; netct++) {\n\t\t \n\t\tatif->address.s_net = htons(probe_net);\n\t\tfor (nodect = 0; nodect < 256; nodect++) {\n\t\t\tatif->address.s_node = (nodect + probe_node) & 0xFF;\n\t\t\tif (atif->address.s_node > 0 &&\n\t\t\t    atif->address.s_node < 254) {\n\t\t\t\t \n\t\t\t\taarp_probe_network(atif);\n\n\t\t\t\tif (!(atif->status & ATIF_PROBE_FAIL)) {\n\t\t\t\t\tatif->status &= ~ATIF_PROBE;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tatif->status &= ~ATIF_PROBE_FAIL;\n\t\t}\n\t\tprobe_net++;\n\t\tif (probe_net > ntohs(atif->nets.nr_lastnet))\n\t\t\tprobe_net = ntohs(atif->nets.nr_firstnet);\n\t}\n\tatif->status &= ~ATIF_PROBE;\n\n\treturn -EADDRINUSE;\t \n}\n\n\n \nstatic int atif_proxy_probe_device(struct atalk_iface *atif,\n\t\t\t\t   struct atalk_addr *proxy_addr)\n{\n\tint netrange = ntohs(atif->nets.nr_lastnet) -\n\t\t\tntohs(atif->nets.nr_firstnet) + 1;\n\t \n\tint probe_net = ntohs(atif->address.s_net);\n\tint probe_node = ATADDR_ANYNODE;\t     \n\tint netct, nodect;\n\n\t \n\tif (probe_net == ATADDR_ANYNET) {\n\t\tprobe_net = ntohs(atif->nets.nr_firstnet);\n\t\tif (netrange)\n\t\t\tprobe_net += jiffies % netrange;\n\t}\n\n\tif (probe_node == ATADDR_ANYNODE)\n\t\tprobe_node = jiffies & 0xFF;\n\n\t \n\tfor (netct = 0; netct <= netrange; netct++) {\n\t\t \n\t\tproxy_addr->s_net = htons(probe_net);\n\t\tfor (nodect = 0; nodect < 256; nodect++) {\n\t\t\tproxy_addr->s_node = (nodect + probe_node) & 0xFF;\n\t\t\tif (proxy_addr->s_node > 0 &&\n\t\t\t    proxy_addr->s_node < 254) {\n\t\t\t\t \n\t\t\t\tint ret = aarp_proxy_probe_network(atif,\n\t\t\t\t\t\t\t\t    proxy_addr);\n\n\t\t\t\tif (ret != -EADDRINUSE)\n\t\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t\tprobe_net++;\n\t\tif (probe_net > ntohs(atif->nets.nr_lastnet))\n\t\t\tprobe_net = ntohs(atif->nets.nr_firstnet);\n\t}\n\n\treturn -EADDRINUSE;\t \n}\n\n\nstruct atalk_addr *atalk_find_dev_addr(struct net_device *dev)\n{\n\tstruct atalk_iface *iface = dev->atalk_ptr;\n\treturn iface ? &iface->address : NULL;\n}\n\nstatic struct atalk_addr *atalk_find_primary(void)\n{\n\tstruct atalk_iface *fiface = NULL;\n\tstruct atalk_addr *retval;\n\tstruct atalk_iface *iface;\n\n\t \n\tread_lock_bh(&atalk_interfaces_lock);\n\tfor (iface = atalk_interfaces; iface; iface = iface->next) {\n\t\tif (!fiface && !(iface->dev->flags & IFF_LOOPBACK))\n\t\t\tfiface = iface;\n\t\tif (!(iface->dev->flags & (IFF_LOOPBACK | IFF_POINTOPOINT))) {\n\t\t\tretval = &iface->address;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (fiface)\n\t\tretval = &fiface->address;\n\telse if (atalk_interfaces)\n\t\tretval = &atalk_interfaces->address;\n\telse\n\t\tretval = NULL;\nout:\n\tread_unlock_bh(&atalk_interfaces_lock);\n\treturn retval;\n}\n\n \nstatic struct atalk_iface *atalk_find_anynet(int node, struct net_device *dev)\n{\n\tstruct atalk_iface *iface = dev->atalk_ptr;\n\n\tif (!iface || iface->status & ATIF_PROBE)\n\t\tgoto out_err;\n\n\tif (node != ATADDR_BCAST &&\n\t    iface->address.s_node != node &&\n\t    node != ATADDR_ANYNODE)\n\t\tgoto out_err;\nout:\n\treturn iface;\nout_err:\n\tiface = NULL;\n\tgoto out;\n}\n\n \nstatic struct atalk_iface *atalk_find_interface(__be16 net, int node)\n{\n\tstruct atalk_iface *iface;\n\n\tread_lock_bh(&atalk_interfaces_lock);\n\tfor (iface = atalk_interfaces; iface; iface = iface->next) {\n\t\tif ((node == ATADDR_BCAST ||\n\t\t     node == ATADDR_ANYNODE ||\n\t\t     iface->address.s_node == node) &&\n\t\t    iface->address.s_net == net &&\n\t\t    !(iface->status & ATIF_PROBE))\n\t\t\tbreak;\n\n\t\t \n\t\tif (node == ATADDR_ANYNODE && net != ATADDR_ANYNET &&\n\t\t    ntohs(iface->nets.nr_firstnet) <= ntohs(net) &&\n\t\t    ntohs(net) <= ntohs(iface->nets.nr_lastnet))\n\t\t\tbreak;\n\t}\n\tread_unlock_bh(&atalk_interfaces_lock);\n\treturn iface;\n}\n\n\n \nstatic struct atalk_route *atrtr_find(struct atalk_addr *target)\n{\n\t \n\tstruct atalk_route *net_route = NULL;\n\tstruct atalk_route *r;\n\n\tread_lock_bh(&atalk_routes_lock);\n\tfor (r = atalk_routes; r; r = r->next) {\n\t\tif (!(r->flags & RTF_UP))\n\t\t\tcontinue;\n\n\t\tif (r->target.s_net == target->s_net) {\n\t\t\tif (r->flags & RTF_HOST) {\n\t\t\t\t \n\t\t\t\tif (r->target.s_node == target->s_node)\n\t\t\t\t\tgoto out;\n\t\t\t} else\n\t\t\t\t \n\t\t\t\tnet_route = r;\n\t\t}\n\t}\n\n\t \n\tif (net_route)\n\t\tr = net_route;\n\telse if (atrtr_default.dev)\n\t\tr = &atrtr_default;\n\telse  \n\t\tr = NULL;\nout:\n\tread_unlock_bh(&atalk_routes_lock);\n\treturn r;\n}\n\n\n \nstruct net_device *atrtr_get_dev(struct atalk_addr *sa)\n{\n\tstruct atalk_route *atr = atrtr_find(sa);\n\treturn atr ? atr->dev : NULL;\n}\n\n \nstatic void atrtr_set_default(struct net_device *dev)\n{\n\tatrtr_default.dev\t     = dev;\n\tatrtr_default.flags\t     = RTF_UP;\n\tatrtr_default.gateway.s_net  = htons(0);\n\tatrtr_default.gateway.s_node = 0;\n}\n\n \nstatic int atrtr_create(struct rtentry *r, struct net_device *devhint)\n{\n\tstruct sockaddr_at *ta = (struct sockaddr_at *)&r->rt_dst;\n\tstruct sockaddr_at *ga = (struct sockaddr_at *)&r->rt_gateway;\n\tstruct atalk_route *rt;\n\tstruct atalk_iface *iface, *riface;\n\tint retval = -EINVAL;\n\n\t \n\n\t \n\tif (ta->sat_family != AF_APPLETALK ||\n\t    (!devhint && ga->sat_family != AF_APPLETALK))\n\t\tgoto out;\n\n\t \n\twrite_lock_bh(&atalk_routes_lock);\n\tfor (rt = atalk_routes; rt; rt = rt->next) {\n\t\tif (r->rt_flags != rt->flags)\n\t\t\tcontinue;\n\n\t\tif (ta->sat_addr.s_net == rt->target.s_net) {\n\t\t\tif (!(rt->flags & RTF_HOST))\n\t\t\t\tbreak;\n\t\t\tif (ta->sat_addr.s_node == rt->target.s_node)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!devhint) {\n\t\triface = NULL;\n\n\t\tread_lock_bh(&atalk_interfaces_lock);\n\t\tfor (iface = atalk_interfaces; iface; iface = iface->next) {\n\t\t\tif (!riface &&\n\t\t\t    ntohs(ga->sat_addr.s_net) >=\n\t\t\t\t\tntohs(iface->nets.nr_firstnet) &&\n\t\t\t    ntohs(ga->sat_addr.s_net) <=\n\t\t\t\t\tntohs(iface->nets.nr_lastnet))\n\t\t\t\triface = iface;\n\n\t\t\tif (ga->sat_addr.s_net == iface->address.s_net &&\n\t\t\t    ga->sat_addr.s_node == iface->address.s_node)\n\t\t\t\triface = iface;\n\t\t}\n\t\tread_unlock_bh(&atalk_interfaces_lock);\n\n\t\tretval = -ENETUNREACH;\n\t\tif (!riface)\n\t\t\tgoto out_unlock;\n\n\t\tdevhint = riface->dev;\n\t}\n\n\tif (!rt) {\n\t\trt = kzalloc(sizeof(*rt), GFP_ATOMIC);\n\n\t\tretval = -ENOBUFS;\n\t\tif (!rt)\n\t\t\tgoto out_unlock;\n\n\t\trt->next = atalk_routes;\n\t\tatalk_routes = rt;\n\t}\n\n\t \n\trt->target  = ta->sat_addr;\n\tdev_hold(devhint);\n\trt->dev     = devhint;\n\trt->flags   = r->rt_flags;\n\trt->gateway = ga->sat_addr;\n\n\tretval = 0;\nout_unlock:\n\twrite_unlock_bh(&atalk_routes_lock);\nout:\n\treturn retval;\n}\n\n \nstatic int atrtr_delete(struct atalk_addr *addr)\n{\n\tstruct atalk_route **r = &atalk_routes;\n\tint retval = 0;\n\tstruct atalk_route *tmp;\n\n\twrite_lock_bh(&atalk_routes_lock);\n\twhile ((tmp = *r) != NULL) {\n\t\tif (tmp->target.s_net == addr->s_net &&\n\t\t    (!(tmp->flags&RTF_GATEWAY) ||\n\t\t     tmp->target.s_node == addr->s_node)) {\n\t\t\t*r = tmp->next;\n\t\t\tdev_put(tmp->dev);\n\t\t\tkfree(tmp);\n\t\t\tgoto out;\n\t\t}\n\t\tr = &tmp->next;\n\t}\n\tretval = -ENOENT;\nout:\n\twrite_unlock_bh(&atalk_routes_lock);\n\treturn retval;\n}\n\n \nstatic void atrtr_device_down(struct net_device *dev)\n{\n\tstruct atalk_route **r = &atalk_routes;\n\tstruct atalk_route *tmp;\n\n\twrite_lock_bh(&atalk_routes_lock);\n\twhile ((tmp = *r) != NULL) {\n\t\tif (tmp->dev == dev) {\n\t\t\t*r = tmp->next;\n\t\t\tdev_put(dev);\n\t\t\tkfree(tmp);\n\t\t} else\n\t\t\tr = &tmp->next;\n\t}\n\twrite_unlock_bh(&atalk_routes_lock);\n\n\tif (atrtr_default.dev == dev)\n\t\tatrtr_set_default(NULL);\n}\n\n \nstatic inline void atalk_dev_down(struct net_device *dev)\n{\n\tatrtr_device_down(dev);\t \n\taarp_device_down(dev);\t \n\tatif_drop_device(dev);\t \n}\n\n \nstatic int ddp_device_event(struct notifier_block *this, unsigned long event,\n\t\t\t    void *ptr)\n{\n\tstruct net_device *dev = netdev_notifier_info_to_dev(ptr);\n\n\tif (!net_eq(dev_net(dev), &init_net))\n\t\treturn NOTIFY_DONE;\n\n\tif (event == NETDEV_DOWN)\n\t\t \n\t\tatalk_dev_down(dev);\n\n\treturn NOTIFY_DONE;\n}\n\n \n \nstatic int atif_ioctl(int cmd, void __user *arg)\n{\n\tstatic char aarp_mcast[6] = { 0x09, 0x00, 0x00, 0xFF, 0xFF, 0xFF };\n\tstruct ifreq atreq;\n\tstruct atalk_netrange *nr;\n\tstruct sockaddr_at *sa;\n\tstruct net_device *dev;\n\tstruct atalk_iface *atif;\n\tint ct;\n\tint limit;\n\tstruct rtentry rtdef;\n\tint add_route;\n\n\tif (get_user_ifreq(&atreq, NULL, arg))\n\t\treturn -EFAULT;\n\n\tdev = __dev_get_by_name(&init_net, atreq.ifr_name);\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\tsa = (struct sockaddr_at *)&atreq.ifr_addr;\n\tatif = atalk_find_dev(dev);\n\n\tswitch (cmd) {\n\tcase SIOCSIFADDR:\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\treturn -EPERM;\n\t\tif (sa->sat_family != AF_APPLETALK)\n\t\t\treturn -EINVAL;\n\t\tif (dev->type != ARPHRD_ETHER &&\n\t\t    dev->type != ARPHRD_LOOPBACK &&\n\t\t    dev->type != ARPHRD_LOCALTLK &&\n\t\t    dev->type != ARPHRD_PPP)\n\t\t\treturn -EPROTONOSUPPORT;\n\n\t\tnr = (struct atalk_netrange *)&sa->sat_zero[0];\n\t\tadd_route = 1;\n\n\t\t \n\t\tif ((dev->flags & IFF_POINTOPOINT) &&\n\t\t    atalk_find_interface(sa->sat_addr.s_net,\n\t\t\t\t\t sa->sat_addr.s_node)) {\n\t\t\tprintk(KERN_DEBUG \"AppleTalk: point-to-point \"\n\t\t\t       \"interface added with \"\n\t\t\t       \"existing address\\n\");\n\t\t\tadd_route = 0;\n\t\t}\n\n\t\t \n\t\tif (dev->type == ARPHRD_ETHER && nr->nr_phase != 2)\n\t\t\treturn -EPROTONOSUPPORT;\n\t\tif (sa->sat_addr.s_node == ATADDR_BCAST ||\n\t\t    sa->sat_addr.s_node == 254)\n\t\t\treturn -EINVAL;\n\t\tif (atif) {\n\t\t\t \n\t\t\tif (atif->status & ATIF_PROBE)\n\t\t\t\treturn -EBUSY;\n\n\t\t\tatif->address.s_net  = sa->sat_addr.s_net;\n\t\t\tatif->address.s_node = sa->sat_addr.s_node;\n\t\t\tatrtr_device_down(dev);\t \n\t\t} else {\n\t\t\tatif = atif_add_device(dev, &sa->sat_addr);\n\t\t\tif (!atif)\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\t\tatif->nets = *nr;\n\n\t\t \n\n\t\tif (!(dev->flags & IFF_LOOPBACK) &&\n\t\t    !(dev->flags & IFF_POINTOPOINT) &&\n\t\t    atif_probe_device(atif) < 0) {\n\t\t\tatif_drop_device(dev);\n\t\t\treturn -EADDRINUSE;\n\t\t}\n\n\t\t \n\t\tsa = (struct sockaddr_at *)&rtdef.rt_gateway;\n\t\tsa->sat_family = AF_APPLETALK;\n\t\tsa->sat_addr.s_net  = atif->address.s_net;\n\t\tsa->sat_addr.s_node = atif->address.s_node;\n\t\tsa = (struct sockaddr_at *)&rtdef.rt_dst;\n\t\trtdef.rt_flags = RTF_UP;\n\t\tsa->sat_family = AF_APPLETALK;\n\t\tsa->sat_addr.s_node = ATADDR_ANYNODE;\n\t\tif (dev->flags & IFF_LOOPBACK ||\n\t\t    dev->flags & IFF_POINTOPOINT)\n\t\t\trtdef.rt_flags |= RTF_HOST;\n\n\t\t \n\t\tif (nr->nr_firstnet == htons(0) &&\n\t\t    nr->nr_lastnet == htons(0xFFFE)) {\n\t\t\tsa->sat_addr.s_net = atif->address.s_net;\n\t\t\tatrtr_create(&rtdef, dev);\n\t\t\tatrtr_set_default(dev);\n\t\t} else {\n\t\t\tlimit = ntohs(nr->nr_lastnet);\n\t\t\tif (limit - ntohs(nr->nr_firstnet) > 4096) {\n\t\t\t\tprintk(KERN_WARNING \"Too many routes/\"\n\t\t\t\t       \"iface.\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tif (add_route)\n\t\t\t\tfor (ct = ntohs(nr->nr_firstnet);\n\t\t\t\t     ct <= limit; ct++) {\n\t\t\t\t\tsa->sat_addr.s_net = htons(ct);\n\t\t\t\t\tatrtr_create(&rtdef, dev);\n\t\t\t\t}\n\t\t}\n\t\tdev_mc_add_global(dev, aarp_mcast);\n\t\treturn 0;\n\n\tcase SIOCGIFADDR:\n\t\tif (!atif)\n\t\t\treturn -EADDRNOTAVAIL;\n\n\t\tsa->sat_family = AF_APPLETALK;\n\t\tsa->sat_addr = atif->address;\n\t\tbreak;\n\n\tcase SIOCGIFBRDADDR:\n\t\tif (!atif)\n\t\t\treturn -EADDRNOTAVAIL;\n\n\t\tsa->sat_family = AF_APPLETALK;\n\t\tsa->sat_addr.s_net = atif->address.s_net;\n\t\tsa->sat_addr.s_node = ATADDR_BCAST;\n\t\tbreak;\n\n\tcase SIOCATALKDIFADDR:\n\tcase SIOCDIFADDR:\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\treturn -EPERM;\n\t\tif (sa->sat_family != AF_APPLETALK)\n\t\t\treturn -EINVAL;\n\t\tatalk_dev_down(dev);\n\t\tbreak;\n\n\tcase SIOCSARP:\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\treturn -EPERM;\n\t\tif (sa->sat_family != AF_APPLETALK)\n\t\t\treturn -EINVAL;\n\t\t \n\t\tif (dev->type != ARPHRD_ETHER)\n\t\t\treturn -EPROTONOSUPPORT;\n\n\t\t \n\t\tif (!atif)\n\t\t\treturn -EADDRNOTAVAIL;\n\n\t\tnr = (struct atalk_netrange *)&(atif->nets);\n\t\t \n\t\tif (dev->type == ARPHRD_ETHER && nr->nr_phase != 2)\n\t\t\treturn -EPROTONOSUPPORT;\n\n\t\tif (sa->sat_addr.s_node == ATADDR_BCAST ||\n\t\t    sa->sat_addr.s_node == 254)\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\tif (atif_proxy_probe_device(atif, &(sa->sat_addr)) < 0)\n\t\t\treturn -EADDRINUSE;\n\n\t\t \n\t\tbreak;\n\n\tcase SIOCDARP:\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\treturn -EPERM;\n\t\tif (sa->sat_family != AF_APPLETALK)\n\t\t\treturn -EINVAL;\n\t\tif (!atif)\n\t\t\treturn -EADDRNOTAVAIL;\n\n\t\t \n\t\taarp_proxy_remove(atif->dev, &(sa->sat_addr));\n\t\treturn 0;\n\t}\n\n\treturn put_user_ifreq(&atreq, arg);\n}\n\nstatic int atrtr_ioctl_addrt(struct rtentry *rt)\n{\n\tstruct net_device *dev = NULL;\n\n\tif (rt->rt_dev) {\n\t\tchar name[IFNAMSIZ];\n\n\t\tif (copy_from_user(name, rt->rt_dev, IFNAMSIZ-1))\n\t\t\treturn -EFAULT;\n\t\tname[IFNAMSIZ-1] = '\\0';\n\n\t\tdev = __dev_get_by_name(&init_net, name);\n\t\tif (!dev)\n\t\t\treturn -ENODEV;\n\t}\n\treturn atrtr_create(rt, dev);\n}\n\n \nstatic int atrtr_ioctl(unsigned int cmd, void __user *arg)\n{\n\tstruct rtentry rt;\n\n\tif (copy_from_user(&rt, arg, sizeof(rt)))\n\t\treturn -EFAULT;\n\n\tswitch (cmd) {\n\tcase SIOCDELRT:\n\t\tif (rt.rt_dst.sa_family != AF_APPLETALK)\n\t\t\treturn -EINVAL;\n\t\treturn atrtr_delete(&((struct sockaddr_at *)\n\t\t\t\t      &rt.rt_dst)->sat_addr);\n\n\tcase SIOCADDRT:\n\t\treturn atrtr_ioctl_addrt(&rt);\n\t}\n\treturn -EINVAL;\n}\n\n \n\n \nstatic unsigned long atalk_sum_partial(const unsigned char *data,\n\t\t\t\t       int len, unsigned long sum)\n{\n\t \n\twhile (len--) {\n\t\tsum += *data++;\n\t\tsum = rol16(sum, 1);\n\t}\n\treturn sum;\n}\n\n \nstatic unsigned long atalk_sum_skb(const struct sk_buff *skb, int offset,\n\t\t\t\t   int len, unsigned long sum)\n{\n\tint start = skb_headlen(skb);\n\tstruct sk_buff *frag_iter;\n\tint i, copy;\n\n\t \n\tif ((copy = start - offset) > 0) {\n\t\tif (copy > len)\n\t\t\tcopy = len;\n\t\tsum = atalk_sum_partial(skb->data + offset, copy, sum);\n\t\tif ((len -= copy) == 0)\n\t\t\treturn sum;\n\n\t\toffset += copy;\n\t}\n\n\t \n\tfor (i = 0; i < skb_shinfo(skb)->nr_frags; i++) {\n\t\tint end;\n\t\tconst skb_frag_t *frag = &skb_shinfo(skb)->frags[i];\n\t\tWARN_ON(start > offset + len);\n\n\t\tend = start + skb_frag_size(frag);\n\t\tif ((copy = end - offset) > 0) {\n\t\t\tu8 *vaddr;\n\n\t\t\tif (copy > len)\n\t\t\t\tcopy = len;\n\t\t\tvaddr = kmap_atomic(skb_frag_page(frag));\n\t\t\tsum = atalk_sum_partial(vaddr + skb_frag_off(frag) +\n\t\t\t\t\t\toffset - start, copy, sum);\n\t\t\tkunmap_atomic(vaddr);\n\n\t\t\tif (!(len -= copy))\n\t\t\t\treturn sum;\n\t\t\toffset += copy;\n\t\t}\n\t\tstart = end;\n\t}\n\n\tskb_walk_frags(skb, frag_iter) {\n\t\tint end;\n\n\t\tWARN_ON(start > offset + len);\n\n\t\tend = start + frag_iter->len;\n\t\tif ((copy = end - offset) > 0) {\n\t\t\tif (copy > len)\n\t\t\t\tcopy = len;\n\t\t\tsum = atalk_sum_skb(frag_iter, offset - start,\n\t\t\t\t\t    copy, sum);\n\t\t\tif ((len -= copy) == 0)\n\t\t\t\treturn sum;\n\t\t\toffset += copy;\n\t\t}\n\t\tstart = end;\n\t}\n\n\tBUG_ON(len > 0);\n\n\treturn sum;\n}\n\nstatic __be16 atalk_checksum(const struct sk_buff *skb, int len)\n{\n\tunsigned long sum;\n\n\t \n\tsum = atalk_sum_skb(skb, 4, len-4, 0);\n\n\t \n\treturn sum ? htons((unsigned short)sum) : htons(0xFFFF);\n}\n\nstatic struct proto ddp_proto = {\n\t.name\t  = \"DDP\",\n\t.owner\t  = THIS_MODULE,\n\t.obj_size = sizeof(struct atalk_sock),\n};\n\n \nstatic int atalk_create(struct net *net, struct socket *sock, int protocol,\n\t\t\tint kern)\n{\n\tstruct sock *sk;\n\tint rc = -ESOCKTNOSUPPORT;\n\n\tif (!net_eq(net, &init_net))\n\t\treturn -EAFNOSUPPORT;\n\n\t \n\tif (sock->type != SOCK_RAW && sock->type != SOCK_DGRAM)\n\t\tgoto out;\n\n\trc = -EPERM;\n\tif (sock->type == SOCK_RAW && !kern && !capable(CAP_NET_RAW))\n\t\tgoto out;\n\n\trc = -ENOMEM;\n\tsk = sk_alloc(net, PF_APPLETALK, GFP_KERNEL, &ddp_proto, kern);\n\tif (!sk)\n\t\tgoto out;\n\trc = 0;\n\tsock->ops = &atalk_dgram_ops;\n\tsock_init_data(sock, sk);\n\n\t \n\tsock_set_flag(sk, SOCK_ZAPPED);\nout:\n\treturn rc;\n}\n\n \nstatic int atalk_release(struct socket *sock)\n{\n\tstruct sock *sk = sock->sk;\n\n\tif (sk) {\n\t\tsock_hold(sk);\n\t\tlock_sock(sk);\n\n\t\tsock_orphan(sk);\n\t\tsock->sk = NULL;\n\t\tatalk_destroy_socket(sk);\n\n\t\trelease_sock(sk);\n\t\tsock_put(sk);\n\t}\n\treturn 0;\n}\n\n \nstatic int atalk_pick_and_bind_port(struct sock *sk, struct sockaddr_at *sat)\n{\n\tint retval;\n\n\twrite_lock_bh(&atalk_sockets_lock);\n\n\tfor (sat->sat_port = ATPORT_RESERVED;\n\t     sat->sat_port < ATPORT_LAST;\n\t     sat->sat_port++) {\n\t\tstruct sock *s;\n\n\t\tsk_for_each(s, &atalk_sockets) {\n\t\t\tstruct atalk_sock *at = at_sk(s);\n\n\t\t\tif (at->src_net == sat->sat_addr.s_net &&\n\t\t\t    at->src_node == sat->sat_addr.s_node &&\n\t\t\t    at->src_port == sat->sat_port)\n\t\t\t\tgoto try_next_port;\n\t\t}\n\n\t\t \n\t\t__atalk_insert_socket(sk);\n\t\tat_sk(sk)->src_port = sat->sat_port;\n\t\tretval = 0;\n\t\tgoto out;\n\ntry_next_port:;\n\t}\n\n\tretval = -EBUSY;\nout:\n\twrite_unlock_bh(&atalk_sockets_lock);\n\treturn retval;\n}\n\nstatic int atalk_autobind(struct sock *sk)\n{\n\tstruct atalk_sock *at = at_sk(sk);\n\tstruct sockaddr_at sat;\n\tstruct atalk_addr *ap = atalk_find_primary();\n\tint n = -EADDRNOTAVAIL;\n\n\tif (!ap || ap->s_net == htons(ATADDR_ANYNET))\n\t\tgoto out;\n\n\tat->src_net  = sat.sat_addr.s_net  = ap->s_net;\n\tat->src_node = sat.sat_addr.s_node = ap->s_node;\n\n\tn = atalk_pick_and_bind_port(sk, &sat);\n\tif (!n)\n\t\tsock_reset_flag(sk, SOCK_ZAPPED);\nout:\n\treturn n;\n}\n\n \nstatic int atalk_bind(struct socket *sock, struct sockaddr *uaddr, int addr_len)\n{\n\tstruct sockaddr_at *addr = (struct sockaddr_at *)uaddr;\n\tstruct sock *sk = sock->sk;\n\tstruct atalk_sock *at = at_sk(sk);\n\tint err;\n\n\tif (!sock_flag(sk, SOCK_ZAPPED) ||\n\t    addr_len != sizeof(struct sockaddr_at))\n\t\treturn -EINVAL;\n\n\tif (addr->sat_family != AF_APPLETALK)\n\t\treturn -EAFNOSUPPORT;\n\n\tlock_sock(sk);\n\tif (addr->sat_addr.s_net == htons(ATADDR_ANYNET)) {\n\t\tstruct atalk_addr *ap = atalk_find_primary();\n\n\t\terr = -EADDRNOTAVAIL;\n\t\tif (!ap)\n\t\t\tgoto out;\n\n\t\tat->src_net  = addr->sat_addr.s_net = ap->s_net;\n\t\tat->src_node = addr->sat_addr.s_node = ap->s_node;\n\t} else {\n\t\terr = -EADDRNOTAVAIL;\n\t\tif (!atalk_find_interface(addr->sat_addr.s_net,\n\t\t\t\t\t  addr->sat_addr.s_node))\n\t\t\tgoto out;\n\n\t\tat->src_net  = addr->sat_addr.s_net;\n\t\tat->src_node = addr->sat_addr.s_node;\n\t}\n\n\tif (addr->sat_port == ATADDR_ANYPORT) {\n\t\terr = atalk_pick_and_bind_port(sk, addr);\n\n\t\tif (err < 0)\n\t\t\tgoto out;\n\t} else {\n\t\tat->src_port = addr->sat_port;\n\n\t\terr = -EADDRINUSE;\n\t\tif (atalk_find_or_insert_socket(sk, addr))\n\t\t\tgoto out;\n\t}\n\n\tsock_reset_flag(sk, SOCK_ZAPPED);\n\terr = 0;\nout:\n\trelease_sock(sk);\n\treturn err;\n}\n\n \nstatic int atalk_connect(struct socket *sock, struct sockaddr *uaddr,\n\t\t\t int addr_len, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct atalk_sock *at = at_sk(sk);\n\tstruct sockaddr_at *addr;\n\tint err;\n\n\tsk->sk_state   = TCP_CLOSE;\n\tsock->state = SS_UNCONNECTED;\n\n\tif (addr_len != sizeof(*addr))\n\t\treturn -EINVAL;\n\n\taddr = (struct sockaddr_at *)uaddr;\n\n\tif (addr->sat_family != AF_APPLETALK)\n\t\treturn -EAFNOSUPPORT;\n\n\tif (addr->sat_addr.s_node == ATADDR_BCAST &&\n\t    !sock_flag(sk, SOCK_BROADCAST)) {\n#if 1\n\t\tpr_warn(\"atalk_connect: %s is broken and did not set SO_BROADCAST.\\n\",\n\t\t\tcurrent->comm);\n#else\n\t\treturn -EACCES;\n#endif\n\t}\n\n\tlock_sock(sk);\n\terr = -EBUSY;\n\tif (sock_flag(sk, SOCK_ZAPPED))\n\t\tif (atalk_autobind(sk) < 0)\n\t\t\tgoto out;\n\n\terr = -ENETUNREACH;\n\tif (!atrtr_get_dev(&addr->sat_addr))\n\t\tgoto out;\n\n\tat->dest_port = addr->sat_port;\n\tat->dest_net  = addr->sat_addr.s_net;\n\tat->dest_node = addr->sat_addr.s_node;\n\n\tsock->state  = SS_CONNECTED;\n\tsk->sk_state = TCP_ESTABLISHED;\n\terr = 0;\nout:\n\trelease_sock(sk);\n\treturn err;\n}\n\n \nstatic int atalk_getname(struct socket *sock, struct sockaddr *uaddr,\n\t\t\t int peer)\n{\n\tstruct sockaddr_at sat;\n\tstruct sock *sk = sock->sk;\n\tstruct atalk_sock *at = at_sk(sk);\n\tint err;\n\n\tlock_sock(sk);\n\terr = -ENOBUFS;\n\tif (sock_flag(sk, SOCK_ZAPPED))\n\t\tif (atalk_autobind(sk) < 0)\n\t\t\tgoto out;\n\n\tmemset(&sat, 0, sizeof(sat));\n\n\tif (peer) {\n\t\terr = -ENOTCONN;\n\t\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\t\tgoto out;\n\n\t\tsat.sat_addr.s_net  = at->dest_net;\n\t\tsat.sat_addr.s_node = at->dest_node;\n\t\tsat.sat_port\t    = at->dest_port;\n\t} else {\n\t\tsat.sat_addr.s_net  = at->src_net;\n\t\tsat.sat_addr.s_node = at->src_node;\n\t\tsat.sat_port\t    = at->src_port;\n\t}\n\n\tsat.sat_family = AF_APPLETALK;\n\tmemcpy(uaddr, &sat, sizeof(sat));\n\terr = sizeof(struct sockaddr_at);\n\nout:\n\trelease_sock(sk);\n\treturn err;\n}\n\n#if IS_ENABLED(CONFIG_IPDDP)\nstatic __inline__ int is_ip_over_ddp(struct sk_buff *skb)\n{\n\treturn skb->data[12] == 22;\n}\n\nstatic int handle_ip_over_ddp(struct sk_buff *skb)\n{\n\tstruct net_device *dev = __dev_get_by_name(&init_net, \"ipddp0\");\n\tstruct net_device_stats *stats;\n\n\t \n\tif (!dev) {\n\t\tkfree_skb(skb);\n\t\treturn NET_RX_DROP;\n\t}\n\n\tskb->protocol = htons(ETH_P_IP);\n\tskb_pull(skb, 13);\n\tskb->dev   = dev;\n\tskb_reset_transport_header(skb);\n\n\tstats = netdev_priv(dev);\n\tstats->rx_packets++;\n\tstats->rx_bytes += skb->len + 13;\n\treturn netif_rx(skb);   \n}\n#else\n \n#define is_ip_over_ddp(skb) 0\n#define handle_ip_over_ddp(skb) 0\n#endif\n\nstatic int atalk_route_packet(struct sk_buff *skb, struct net_device *dev,\n\t\t\t      struct ddpehdr *ddp, __u16 len_hops, int origlen)\n{\n\tstruct atalk_route *rt;\n\tstruct atalk_addr ta;\n\n\t \n\tif (skb->pkt_type != PACKET_HOST || !ddp->deh_dnet) {\n\t\t \n\t\tif (dev->type == ARPHRD_PPP)\n\t\t\tprintk(KERN_DEBUG \"AppleTalk: didn't forward broadcast \"\n\t\t\t\t\t  \"packet received from PPP iface\\n\");\n\t\tgoto free_it;\n\t}\n\n\tta.s_net  = ddp->deh_dnet;\n\tta.s_node = ddp->deh_dnode;\n\n\t \n\trt = atrtr_find(&ta);\n\t \n\tlen_hops += 1 << 10;\n\tif (!rt || !(len_hops & (15 << 10)))\n\t\tgoto free_it;\n\n\t \n\n\t \n\n\tif (rt->flags & RTF_GATEWAY) {\n\t\tta.s_net  = rt->gateway.s_net;\n\t\tta.s_node = rt->gateway.s_node;\n\t}\n\n\t \n\tskb_trim(skb, min_t(unsigned int, origlen,\n\t\t\t    (rt->dev->hard_header_len +\n\t\t\t     ddp_dl->header_length + (len_hops & 1023))));\n\n\t \n\tddp->deh_len_hops = htons(len_hops);\n\n\t \n\tif (skb_headroom(skb) < 22) {\n\t\t \n\t\tstruct sk_buff *nskb = skb_realloc_headroom(skb, 32);\n\t\tkfree_skb(skb);\n\t\tskb = nskb;\n\t} else\n\t\tskb = skb_unshare(skb, GFP_ATOMIC);\n\n\t \n\tif (skb == NULL)\n\t\tgoto drop;\n\n\tif (aarp_send_ddp(rt->dev, skb, &ta, NULL) == NET_XMIT_DROP)\n\t\treturn NET_RX_DROP;\n\treturn NET_RX_SUCCESS;\nfree_it:\n\tkfree_skb(skb);\ndrop:\n\treturn NET_RX_DROP;\n}\n\n \nstatic int atalk_rcv(struct sk_buff *skb, struct net_device *dev,\n\t\t     struct packet_type *pt, struct net_device *orig_dev)\n{\n\tstruct ddpehdr *ddp;\n\tstruct sock *sock;\n\tstruct atalk_iface *atif;\n\tstruct sockaddr_at tosat;\n\tint origlen;\n\t__u16 len_hops;\n\n\tif (!net_eq(dev_net(dev), &init_net))\n\t\tgoto drop;\n\n\t \n\tif (!(skb = skb_share_check(skb, GFP_ATOMIC)))\n\t\tgoto out;\n\n\t \n\tif (!pskb_may_pull(skb, sizeof(*ddp)))\n\t\tgoto drop;\n\n\tddp = ddp_hdr(skb);\n\n\tlen_hops = ntohs(ddp->deh_len_hops);\n\n\t \n\toriglen = skb->len;\n\tskb_trim(skb, min_t(unsigned int, skb->len, len_hops & 1023));\n\n\t \n\tif (skb->len < sizeof(*ddp) || skb->len < (len_hops & 1023)) {\n\t\tpr_debug(\"AppleTalk: dropping corrupted frame (deh_len=%u, \"\n\t\t\t \"skb->len=%u)\\n\", len_hops & 1023, skb->len);\n\t\tgoto drop;\n\t}\n\n\t \n\tif (ddp->deh_sum &&\n\t    atalk_checksum(skb, len_hops & 1023) != ddp->deh_sum)\n\t\t \n\t\tgoto drop;\n\n\t \n\tif (!ddp->deh_dnet)\t \n\t\tatif = atalk_find_anynet(ddp->deh_dnode, dev);\n\telse\n\t\tatif = atalk_find_interface(ddp->deh_dnet, ddp->deh_dnode);\n\n\tif (!atif) {\n\t\t \n\t\treturn atalk_route_packet(skb, dev, ddp, len_hops, origlen);\n\t}\n\n\t \n\tif (is_ip_over_ddp(skb))\n\t\treturn handle_ip_over_ddp(skb);\n\t \n\ttosat.sat_addr.s_net  = ddp->deh_dnet;\n\ttosat.sat_addr.s_node = ddp->deh_dnode;\n\ttosat.sat_port\t      = ddp->deh_dport;\n\n\tsock = atalk_search_socket(&tosat, atif);\n\tif (!sock)  \n\t\tgoto drop;\n\n\t \n\tif (sock_queue_rcv_skb(sock, skb) < 0)\n\t\tgoto drop;\n\n\treturn NET_RX_SUCCESS;\n\ndrop:\n\tkfree_skb(skb);\nout:\n\treturn NET_RX_DROP;\n\n}\n\n \nstatic int ltalk_rcv(struct sk_buff *skb, struct net_device *dev,\n\t\t     struct packet_type *pt, struct net_device *orig_dev)\n{\n\tif (!net_eq(dev_net(dev), &init_net))\n\t\tgoto freeit;\n\n\t \n\tif (skb_mac_header(skb)[2] == 1) {\n\t\tstruct ddpehdr *ddp;\n\t\t \n\t\tstruct atalk_addr *ap = atalk_find_dev_addr(dev);\n\n\t\tif (!ap || skb->len < sizeof(__be16) || skb->len > 1023)\n\t\t\tgoto freeit;\n\n\t\t \n\t\tif (!(skb = skb_share_check(skb, GFP_ATOMIC)))\n\t\t\treturn 0;\n\n\t\t \n\t\tddp = skb_push(skb, sizeof(*ddp) - 4);\n\n\t\t \n\n\t\t \n\n\t\tddp->deh_dnode = skb_mac_header(skb)[0];      \n\t\tddp->deh_snode = skb_mac_header(skb)[1];      \n\n\t\tddp->deh_dnet  = ap->s_net;\t \n\t\tddp->deh_snet  = ap->s_net;\n\t\tddp->deh_sum   = 0;\t\t \n\t\t \n\t\t \n\t\tddp->deh_len_hops = htons(skb->len + (DDP_MAXHOPS << 10));\n\t}\n\tskb_reset_transport_header(skb);\n\n\treturn atalk_rcv(skb, dev, pt, orig_dev);\nfreeit:\n\tkfree_skb(skb);\n\treturn 0;\n}\n\nstatic int atalk_sendmsg(struct socket *sock, struct msghdr *msg, size_t len)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct atalk_sock *at = at_sk(sk);\n\tDECLARE_SOCKADDR(struct sockaddr_at *, usat, msg->msg_name);\n\tint flags = msg->msg_flags;\n\tint loopback = 0;\n\tstruct sockaddr_at local_satalk, gsat;\n\tstruct sk_buff *skb;\n\tstruct net_device *dev;\n\tstruct ddpehdr *ddp;\n\tint size, hard_header_len;\n\tstruct atalk_route *rt, *rt_lo = NULL;\n\tint err;\n\n\tif (flags & ~(MSG_DONTWAIT|MSG_CMSG_COMPAT))\n\t\treturn -EINVAL;\n\n\tif (len > DDP_MAXSZ)\n\t\treturn -EMSGSIZE;\n\n\tlock_sock(sk);\n\tif (usat) {\n\t\terr = -EBUSY;\n\t\tif (sock_flag(sk, SOCK_ZAPPED))\n\t\t\tif (atalk_autobind(sk) < 0)\n\t\t\t\tgoto out;\n\n\t\terr = -EINVAL;\n\t\tif (msg->msg_namelen < sizeof(*usat) ||\n\t\t    usat->sat_family != AF_APPLETALK)\n\t\t\tgoto out;\n\n\t\terr = -EPERM;\n\t\t \n\t\tif (usat->sat_addr.s_node == ATADDR_BCAST &&\n\t\t    !sock_flag(sk, SOCK_BROADCAST)) {\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\terr = -ENOTCONN;\n\t\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\t\tgoto out;\n\t\tusat = &local_satalk;\n\t\tusat->sat_family      = AF_APPLETALK;\n\t\tusat->sat_port\t      = at->dest_port;\n\t\tusat->sat_addr.s_node = at->dest_node;\n\t\tusat->sat_addr.s_net  = at->dest_net;\n\t}\n\n\t \n\tSOCK_DEBUG(sk, \"SK %p: Got address.\\n\", sk);\n\n\t \n\tsize = sizeof(struct ddpehdr) + len + ddp_dl->header_length;\n\n\tif (usat->sat_addr.s_net || usat->sat_addr.s_node == ATADDR_ANYNODE) {\n\t\trt = atrtr_find(&usat->sat_addr);\n\t} else {\n\t\tstruct atalk_addr at_hint;\n\n\t\tat_hint.s_node = 0;\n\t\tat_hint.s_net  = at->src_net;\n\n\t\trt = atrtr_find(&at_hint);\n\t}\n\terr = -ENETUNREACH;\n\tif (!rt)\n\t\tgoto out;\n\n\tdev = rt->dev;\n\n\tSOCK_DEBUG(sk, \"SK %p: Size needed %d, device %s\\n\",\n\t\t\tsk, size, dev->name);\n\n\thard_header_len = dev->hard_header_len;\n\t \n\tif (usat->sat_addr.s_node == ATADDR_BCAST &&\n\t    (dev->flags & IFF_LOOPBACK || !(rt->flags & RTF_GATEWAY))) {\n\t\tstruct atalk_addr at_lo;\n\n\t\tat_lo.s_node = 0;\n\t\tat_lo.s_net  = 0;\n\n\t\trt_lo = atrtr_find(&at_lo);\n\n\t\tif (rt_lo && rt_lo->dev->hard_header_len > hard_header_len)\n\t\t\thard_header_len = rt_lo->dev->hard_header_len;\n\t}\n\n\tsize += hard_header_len;\n\trelease_sock(sk);\n\tskb = sock_alloc_send_skb(sk, size, (flags & MSG_DONTWAIT), &err);\n\tlock_sock(sk);\n\tif (!skb)\n\t\tgoto out;\n\n\tskb_reserve(skb, ddp_dl->header_length);\n\tskb_reserve(skb, hard_header_len);\n\tskb->dev = dev;\n\n\tSOCK_DEBUG(sk, \"SK %p: Begin build.\\n\", sk);\n\n\tddp = skb_put(skb, sizeof(struct ddpehdr));\n\tddp->deh_len_hops  = htons(len + sizeof(*ddp));\n\tddp->deh_dnet  = usat->sat_addr.s_net;\n\tddp->deh_snet  = at->src_net;\n\tddp->deh_dnode = usat->sat_addr.s_node;\n\tddp->deh_snode = at->src_node;\n\tddp->deh_dport = usat->sat_port;\n\tddp->deh_sport = at->src_port;\n\n\tSOCK_DEBUG(sk, \"SK %p: Copy user data (%zd bytes).\\n\", sk, len);\n\n\terr = memcpy_from_msg(skb_put(skb, len), msg, len);\n\tif (err) {\n\t\tkfree_skb(skb);\n\t\terr = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tif (sk->sk_no_check_tx)\n\t\tddp->deh_sum = 0;\n\telse\n\t\tddp->deh_sum = atalk_checksum(skb, len + sizeof(*ddp));\n\n\t \n\tif (ddp->deh_dnode == ATADDR_BCAST &&\n\t    !(rt->flags & RTF_GATEWAY) && !(dev->flags & IFF_LOOPBACK)) {\n\t\tstruct sk_buff *skb2 = skb_copy(skb, GFP_KERNEL);\n\n\t\tif (skb2) {\n\t\t\tloopback = 1;\n\t\t\tSOCK_DEBUG(sk, \"SK %p: send out(copy).\\n\", sk);\n\t\t\t \n\t\t\taarp_send_ddp(dev, skb2, &usat->sat_addr, NULL);\n\t\t}\n\t}\n\n\tif (dev->flags & IFF_LOOPBACK || loopback) {\n\t\tSOCK_DEBUG(sk, \"SK %p: Loop back.\\n\", sk);\n\t\t \n\t\tskb_orphan(skb);\n\t\tif (ddp->deh_dnode == ATADDR_BCAST) {\n\t\t\tif (!rt_lo) {\n\t\t\t\tkfree_skb(skb);\n\t\t\t\terr = -ENETUNREACH;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tdev = rt_lo->dev;\n\t\t\tskb->dev = dev;\n\t\t}\n\t\tddp_dl->request(ddp_dl, skb, dev->dev_addr);\n\t} else {\n\t\tSOCK_DEBUG(sk, \"SK %p: send out.\\n\", sk);\n\t\tif (rt->flags & RTF_GATEWAY) {\n\t\t    gsat.sat_addr = rt->gateway;\n\t\t    usat = &gsat;\n\t\t}\n\n\t\t \n\t\taarp_send_ddp(dev, skb, &usat->sat_addr, NULL);\n\t}\n\tSOCK_DEBUG(sk, \"SK %p: Done write (%zd).\\n\", sk, len);\n\nout:\n\trelease_sock(sk);\n\treturn err ? : len;\n}\n\nstatic int atalk_recvmsg(struct socket *sock, struct msghdr *msg, size_t size,\n\t\t\t int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct ddpehdr *ddp;\n\tint copied = 0;\n\tint offset = 0;\n\tint err = 0;\n\tstruct sk_buff *skb;\n\n\tskb = skb_recv_datagram(sk, flags, &err);\n\tlock_sock(sk);\n\n\tif (!skb)\n\t\tgoto out;\n\n\t \n\tddp = ddp_hdr(skb);\n\tcopied = ntohs(ddp->deh_len_hops) & 1023;\n\n\tif (sk->sk_type != SOCK_RAW) {\n\t\toffset = sizeof(*ddp);\n\t\tcopied -= offset;\n\t}\n\n\tif (copied > size) {\n\t\tcopied = size;\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t}\n\terr = skb_copy_datagram_msg(skb, offset, msg, copied);\n\n\tif (!err && msg->msg_name) {\n\t\tDECLARE_SOCKADDR(struct sockaddr_at *, sat, msg->msg_name);\n\t\tsat->sat_family      = AF_APPLETALK;\n\t\tsat->sat_port        = ddp->deh_sport;\n\t\tsat->sat_addr.s_node = ddp->deh_snode;\n\t\tsat->sat_addr.s_net  = ddp->deh_snet;\n\t\tmsg->msg_namelen     = sizeof(*sat);\n\t}\n\n\tskb_free_datagram(sk, skb);\t \n\nout:\n\trelease_sock(sk);\n\treturn err ? : copied;\n}\n\n\n \nstatic int atalk_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg)\n{\n\tint rc = -ENOIOCTLCMD;\n\tstruct sock *sk = sock->sk;\n\tvoid __user *argp = (void __user *)arg;\n\n\tswitch (cmd) {\n\t \n\tcase TIOCOUTQ: {\n\t\tlong amount = sk->sk_sndbuf - sk_wmem_alloc_get(sk);\n\n\t\tif (amount < 0)\n\t\t\tamount = 0;\n\t\trc = put_user(amount, (int __user *)argp);\n\t\tbreak;\n\t}\n\tcase TIOCINQ: {\n\t\tstruct sk_buff *skb;\n\t\tlong amount = 0;\n\n\t\tspin_lock_irq(&sk->sk_receive_queue.lock);\n\t\tskb = skb_peek(&sk->sk_receive_queue);\n\t\tif (skb)\n\t\t\tamount = skb->len - sizeof(struct ddpehdr);\n\t\tspin_unlock_irq(&sk->sk_receive_queue.lock);\n\t\trc = put_user(amount, (int __user *)argp);\n\t\tbreak;\n\t}\n\t \n\tcase SIOCADDRT:\n\tcase SIOCDELRT:\n\t\trc = -EPERM;\n\t\tif (capable(CAP_NET_ADMIN))\n\t\t\trc = atrtr_ioctl(cmd, argp);\n\t\tbreak;\n\t \n\tcase SIOCGIFADDR:\n\tcase SIOCSIFADDR:\n\tcase SIOCGIFBRDADDR:\n\tcase SIOCATALKDIFADDR:\n\tcase SIOCDIFADDR:\n\tcase SIOCSARP:\t\t \n\tcase SIOCDARP:\t\t \n\t\trtnl_lock();\n\t\trc = atif_ioctl(cmd, argp);\n\t\trtnl_unlock();\n\t\tbreak;\n\t}\n\n\treturn rc;\n}\n\n\n#ifdef CONFIG_COMPAT\nstatic int atalk_compat_routing_ioctl(struct sock *sk, unsigned int cmd,\n\t\tstruct compat_rtentry __user *ur)\n{\n\tcompat_uptr_t rtdev;\n\tstruct rtentry rt;\n\n\tif (copy_from_user(&rt.rt_dst, &ur->rt_dst,\n\t\t\t3 * sizeof(struct sockaddr)) ||\n\t    get_user(rt.rt_flags, &ur->rt_flags) ||\n\t    get_user(rt.rt_metric, &ur->rt_metric) ||\n\t    get_user(rt.rt_mtu, &ur->rt_mtu) ||\n\t    get_user(rt.rt_window, &ur->rt_window) ||\n\t    get_user(rt.rt_irtt, &ur->rt_irtt) ||\n\t    get_user(rtdev, &ur->rt_dev))\n\t\treturn -EFAULT;\n\n\tswitch (cmd) {\n\tcase SIOCDELRT:\n\t\tif (rt.rt_dst.sa_family != AF_APPLETALK)\n\t\t\treturn -EINVAL;\n\t\treturn atrtr_delete(&((struct sockaddr_at *)\n\t\t\t\t      &rt.rt_dst)->sat_addr);\n\n\tcase SIOCADDRT:\n\t\trt.rt_dev = compat_ptr(rtdev);\n\t\treturn atrtr_ioctl_addrt(&rt);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\nstatic int atalk_compat_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg)\n{\n\tvoid __user *argp = compat_ptr(arg);\n\tstruct sock *sk = sock->sk;\n\n\tswitch (cmd) {\n\tcase SIOCADDRT:\n\tcase SIOCDELRT:\n\t\treturn atalk_compat_routing_ioctl(sk, cmd, argp);\n\t \n\tcase SIOCATALKDIFADDR:\n\t\treturn atalk_ioctl(sock, cmd, (unsigned long)argp);\n\tdefault:\n\t\treturn -ENOIOCTLCMD;\n\t}\n}\n#endif  \n\n\nstatic const struct net_proto_family atalk_family_ops = {\n\t.family\t\t= PF_APPLETALK,\n\t.create\t\t= atalk_create,\n\t.owner\t\t= THIS_MODULE,\n};\n\nstatic const struct proto_ops atalk_dgram_ops = {\n\t.family\t\t= PF_APPLETALK,\n\t.owner\t\t= THIS_MODULE,\n\t.release\t= atalk_release,\n\t.bind\t\t= atalk_bind,\n\t.connect\t= atalk_connect,\n\t.socketpair\t= sock_no_socketpair,\n\t.accept\t\t= sock_no_accept,\n\t.getname\t= atalk_getname,\n\t.poll\t\t= datagram_poll,\n\t.ioctl\t\t= atalk_ioctl,\n\t.gettstamp\t= sock_gettstamp,\n#ifdef CONFIG_COMPAT\n\t.compat_ioctl\t= atalk_compat_ioctl,\n#endif\n\t.listen\t\t= sock_no_listen,\n\t.shutdown\t= sock_no_shutdown,\n\t.sendmsg\t= atalk_sendmsg,\n\t.recvmsg\t= atalk_recvmsg,\n\t.mmap\t\t= sock_no_mmap,\n};\n\nstatic struct notifier_block ddp_notifier = {\n\t.notifier_call\t= ddp_device_event,\n};\n\nstatic struct packet_type ltalk_packet_type __read_mostly = {\n\t.type\t\t= cpu_to_be16(ETH_P_LOCALTALK),\n\t.func\t\t= ltalk_rcv,\n};\n\nstatic struct packet_type ppptalk_packet_type __read_mostly = {\n\t.type\t\t= cpu_to_be16(ETH_P_PPPTALK),\n\t.func\t\t= atalk_rcv,\n};\n\nstatic unsigned char ddp_snap_id[] = { 0x08, 0x00, 0x07, 0x80, 0x9B };\n\n \nEXPORT_SYMBOL(atrtr_get_dev);\nEXPORT_SYMBOL(atalk_find_dev_addr);\n\n \nstatic int __init atalk_init(void)\n{\n\tint rc;\n\n\trc = proto_register(&ddp_proto, 0);\n\tif (rc)\n\t\tgoto out;\n\n\trc = sock_register(&atalk_family_ops);\n\tif (rc)\n\t\tgoto out_proto;\n\n\tddp_dl = register_snap_client(ddp_snap_id, atalk_rcv);\n\tif (!ddp_dl) {\n\t\tpr_crit(\"Unable to register DDP with SNAP.\\n\");\n\t\trc = -ENOMEM;\n\t\tgoto out_sock;\n\t}\n\n\tdev_add_pack(&ltalk_packet_type);\n\tdev_add_pack(&ppptalk_packet_type);\n\n\trc = register_netdevice_notifier(&ddp_notifier);\n\tif (rc)\n\t\tgoto out_snap;\n\n\trc = aarp_proto_init();\n\tif (rc)\n\t\tgoto out_dev;\n\n\trc = atalk_proc_init();\n\tif (rc)\n\t\tgoto out_aarp;\n\n\trc = atalk_register_sysctl();\n\tif (rc)\n\t\tgoto out_proc;\nout:\n\treturn rc;\nout_proc:\n\tatalk_proc_exit();\nout_aarp:\n\taarp_cleanup_module();\nout_dev:\n\tunregister_netdevice_notifier(&ddp_notifier);\nout_snap:\n\tdev_remove_pack(&ppptalk_packet_type);\n\tdev_remove_pack(&ltalk_packet_type);\n\tunregister_snap_client(ddp_dl);\nout_sock:\n\tsock_unregister(PF_APPLETALK);\nout_proto:\n\tproto_unregister(&ddp_proto);\n\tgoto out;\n}\nmodule_init(atalk_init);\n\n \nstatic void __exit atalk_exit(void)\n{\n#ifdef CONFIG_SYSCTL\n\tatalk_unregister_sysctl();\n#endif  \n\tatalk_proc_exit();\n\taarp_cleanup_module();\t \n\tunregister_netdevice_notifier(&ddp_notifier);\n\tdev_remove_pack(&ltalk_packet_type);\n\tdev_remove_pack(&ppptalk_packet_type);\n\tunregister_snap_client(ddp_dl);\n\tsock_unregister(PF_APPLETALK);\n\tproto_unregister(&ddp_proto);\n}\nmodule_exit(atalk_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Alan Cox <alan@lxorguk.ukuu.org.uk>\");\nMODULE_DESCRIPTION(\"AppleTalk 0.20\\n\");\nMODULE_ALIAS_NETPROTO(PF_APPLETALK);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}