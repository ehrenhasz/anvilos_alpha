{
  "module_name": "messenger.c",
  "hash_id": "7a8e1cc8f02045c68bf86a071f735e5f75bf624d18b3fc9a2e90d8cbf7766bca",
  "original_prompt": "Ingested from linux-6.6.14/net/ceph/messenger.c",
  "human_readable_source": "\n#include <linux/ceph/ceph_debug.h>\n\n#include <linux/crc32c.h>\n#include <linux/ctype.h>\n#include <linux/highmem.h>\n#include <linux/inet.h>\n#include <linux/kthread.h>\n#include <linux/net.h>\n#include <linux/nsproxy.h>\n#include <linux/sched/mm.h>\n#include <linux/slab.h>\n#include <linux/socket.h>\n#include <linux/string.h>\n#ifdef\tCONFIG_BLOCK\n#include <linux/bio.h>\n#endif\t \n#include <linux/dns_resolver.h>\n#include <net/tcp.h>\n#include <trace/events/sock.h>\n\n#include <linux/ceph/ceph_features.h>\n#include <linux/ceph/libceph.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/export.h>\n\n \n\n \n\n#define CON_SOCK_STATE_NEW\t\t0\t \n#define CON_SOCK_STATE_CLOSED\t\t1\t \n#define CON_SOCK_STATE_CONNECTING\t2\t \n#define CON_SOCK_STATE_CONNECTED\t3\t \n#define CON_SOCK_STATE_CLOSING\t\t4\t \n\nstatic bool con_flag_valid(unsigned long con_flag)\n{\n\tswitch (con_flag) {\n\tcase CEPH_CON_F_LOSSYTX:\n\tcase CEPH_CON_F_KEEPALIVE_PENDING:\n\tcase CEPH_CON_F_WRITE_PENDING:\n\tcase CEPH_CON_F_SOCK_CLOSED:\n\tcase CEPH_CON_F_BACKOFF:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nvoid ceph_con_flag_clear(struct ceph_connection *con, unsigned long con_flag)\n{\n\tBUG_ON(!con_flag_valid(con_flag));\n\n\tclear_bit(con_flag, &con->flags);\n}\n\nvoid ceph_con_flag_set(struct ceph_connection *con, unsigned long con_flag)\n{\n\tBUG_ON(!con_flag_valid(con_flag));\n\n\tset_bit(con_flag, &con->flags);\n}\n\nbool ceph_con_flag_test(struct ceph_connection *con, unsigned long con_flag)\n{\n\tBUG_ON(!con_flag_valid(con_flag));\n\n\treturn test_bit(con_flag, &con->flags);\n}\n\nbool ceph_con_flag_test_and_clear(struct ceph_connection *con,\n\t\t\t\t  unsigned long con_flag)\n{\n\tBUG_ON(!con_flag_valid(con_flag));\n\n\treturn test_and_clear_bit(con_flag, &con->flags);\n}\n\nbool ceph_con_flag_test_and_set(struct ceph_connection *con,\n\t\t\t\tunsigned long con_flag)\n{\n\tBUG_ON(!con_flag_valid(con_flag));\n\n\treturn test_and_set_bit(con_flag, &con->flags);\n}\n\n \n\nstatic struct kmem_cache\t*ceph_msg_cache;\n\n#ifdef CONFIG_LOCKDEP\nstatic struct lock_class_key socket_class;\n#endif\n\nstatic void queue_con(struct ceph_connection *con);\nstatic void cancel_con(struct ceph_connection *con);\nstatic void ceph_con_workfn(struct work_struct *);\nstatic void con_fault(struct ceph_connection *con);\n\n \n#define ADDR_STR_COUNT_LOG\t5\t \n#define ADDR_STR_COUNT\t\t(1 << ADDR_STR_COUNT_LOG)\n#define ADDR_STR_COUNT_MASK\t(ADDR_STR_COUNT - 1)\n#define MAX_ADDR_STR_LEN\t64\t \n\nstatic char addr_str[ADDR_STR_COUNT][MAX_ADDR_STR_LEN];\nstatic atomic_t addr_str_seq = ATOMIC_INIT(0);\n\nstruct page *ceph_zero_page;\t\t \n\nconst char *ceph_pr_addr(const struct ceph_entity_addr *addr)\n{\n\tint i;\n\tchar *s;\n\tstruct sockaddr_storage ss = addr->in_addr;  \n\tstruct sockaddr_in *in4 = (struct sockaddr_in *)&ss;\n\tstruct sockaddr_in6 *in6 = (struct sockaddr_in6 *)&ss;\n\n\ti = atomic_inc_return(&addr_str_seq) & ADDR_STR_COUNT_MASK;\n\ts = addr_str[i];\n\n\tswitch (ss.ss_family) {\n\tcase AF_INET:\n\t\tsnprintf(s, MAX_ADDR_STR_LEN, \"(%d)%pI4:%hu\",\n\t\t\t le32_to_cpu(addr->type), &in4->sin_addr,\n\t\t\t ntohs(in4->sin_port));\n\t\tbreak;\n\n\tcase AF_INET6:\n\t\tsnprintf(s, MAX_ADDR_STR_LEN, \"(%d)[%pI6c]:%hu\",\n\t\t\t le32_to_cpu(addr->type), &in6->sin6_addr,\n\t\t\t ntohs(in6->sin6_port));\n\t\tbreak;\n\n\tdefault:\n\t\tsnprintf(s, MAX_ADDR_STR_LEN, \"(unknown sockaddr family %hu)\",\n\t\t\t ss.ss_family);\n\t}\n\n\treturn s;\n}\nEXPORT_SYMBOL(ceph_pr_addr);\n\nvoid ceph_encode_my_addr(struct ceph_messenger *msgr)\n{\n\tif (!ceph_msgr2(from_msgr(msgr))) {\n\t\tmemcpy(&msgr->my_enc_addr, &msgr->inst.addr,\n\t\t       sizeof(msgr->my_enc_addr));\n\t\tceph_encode_banner_addr(&msgr->my_enc_addr);\n\t}\n}\n\n \nstatic struct workqueue_struct *ceph_msgr_wq;\n\nstatic int ceph_msgr_slab_init(void)\n{\n\tBUG_ON(ceph_msg_cache);\n\tceph_msg_cache = KMEM_CACHE(ceph_msg, 0);\n\tif (!ceph_msg_cache)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic void ceph_msgr_slab_exit(void)\n{\n\tBUG_ON(!ceph_msg_cache);\n\tkmem_cache_destroy(ceph_msg_cache);\n\tceph_msg_cache = NULL;\n}\n\nstatic void _ceph_msgr_exit(void)\n{\n\tif (ceph_msgr_wq) {\n\t\tdestroy_workqueue(ceph_msgr_wq);\n\t\tceph_msgr_wq = NULL;\n\t}\n\n\tBUG_ON(!ceph_zero_page);\n\tput_page(ceph_zero_page);\n\tceph_zero_page = NULL;\n\n\tceph_msgr_slab_exit();\n}\n\nint __init ceph_msgr_init(void)\n{\n\tif (ceph_msgr_slab_init())\n\t\treturn -ENOMEM;\n\n\tBUG_ON(ceph_zero_page);\n\tceph_zero_page = ZERO_PAGE(0);\n\tget_page(ceph_zero_page);\n\n\t \n\tceph_msgr_wq = alloc_workqueue(\"ceph-msgr\", WQ_MEM_RECLAIM, 0);\n\tif (ceph_msgr_wq)\n\t\treturn 0;\n\n\tpr_err(\"msgr_init failed to create workqueue\\n\");\n\t_ceph_msgr_exit();\n\n\treturn -ENOMEM;\n}\n\nvoid ceph_msgr_exit(void)\n{\n\tBUG_ON(ceph_msgr_wq == NULL);\n\n\t_ceph_msgr_exit();\n}\n\nvoid ceph_msgr_flush(void)\n{\n\tflush_workqueue(ceph_msgr_wq);\n}\nEXPORT_SYMBOL(ceph_msgr_flush);\n\n \n\nstatic void con_sock_state_init(struct ceph_connection *con)\n{\n\tint old_state;\n\n\told_state = atomic_xchg(&con->sock_state, CON_SOCK_STATE_CLOSED);\n\tif (WARN_ON(old_state != CON_SOCK_STATE_NEW))\n\t\tprintk(\"%s: unexpected old state %d\\n\", __func__, old_state);\n\tdout(\"%s con %p sock %d -> %d\\n\", __func__, con, old_state,\n\t     CON_SOCK_STATE_CLOSED);\n}\n\nstatic void con_sock_state_connecting(struct ceph_connection *con)\n{\n\tint old_state;\n\n\told_state = atomic_xchg(&con->sock_state, CON_SOCK_STATE_CONNECTING);\n\tif (WARN_ON(old_state != CON_SOCK_STATE_CLOSED))\n\t\tprintk(\"%s: unexpected old state %d\\n\", __func__, old_state);\n\tdout(\"%s con %p sock %d -> %d\\n\", __func__, con, old_state,\n\t     CON_SOCK_STATE_CONNECTING);\n}\n\nstatic void con_sock_state_connected(struct ceph_connection *con)\n{\n\tint old_state;\n\n\told_state = atomic_xchg(&con->sock_state, CON_SOCK_STATE_CONNECTED);\n\tif (WARN_ON(old_state != CON_SOCK_STATE_CONNECTING))\n\t\tprintk(\"%s: unexpected old state %d\\n\", __func__, old_state);\n\tdout(\"%s con %p sock %d -> %d\\n\", __func__, con, old_state,\n\t     CON_SOCK_STATE_CONNECTED);\n}\n\nstatic void con_sock_state_closing(struct ceph_connection *con)\n{\n\tint old_state;\n\n\told_state = atomic_xchg(&con->sock_state, CON_SOCK_STATE_CLOSING);\n\tif (WARN_ON(old_state != CON_SOCK_STATE_CONNECTING &&\n\t\t\told_state != CON_SOCK_STATE_CONNECTED &&\n\t\t\told_state != CON_SOCK_STATE_CLOSING))\n\t\tprintk(\"%s: unexpected old state %d\\n\", __func__, old_state);\n\tdout(\"%s con %p sock %d -> %d\\n\", __func__, con, old_state,\n\t     CON_SOCK_STATE_CLOSING);\n}\n\nstatic void con_sock_state_closed(struct ceph_connection *con)\n{\n\tint old_state;\n\n\told_state = atomic_xchg(&con->sock_state, CON_SOCK_STATE_CLOSED);\n\tif (WARN_ON(old_state != CON_SOCK_STATE_CONNECTED &&\n\t\t    old_state != CON_SOCK_STATE_CLOSING &&\n\t\t    old_state != CON_SOCK_STATE_CONNECTING &&\n\t\t    old_state != CON_SOCK_STATE_CLOSED))\n\t\tprintk(\"%s: unexpected old state %d\\n\", __func__, old_state);\n\tdout(\"%s con %p sock %d -> %d\\n\", __func__, con, old_state,\n\t     CON_SOCK_STATE_CLOSED);\n}\n\n \n\n \nstatic void ceph_sock_data_ready(struct sock *sk)\n{\n\tstruct ceph_connection *con = sk->sk_user_data;\n\n\ttrace_sk_data_ready(sk);\n\n\tif (atomic_read(&con->msgr->stopping)) {\n\t\treturn;\n\t}\n\n\tif (sk->sk_state != TCP_CLOSE_WAIT) {\n\t\tdout(\"%s %p state = %d, queueing work\\n\", __func__,\n\t\t     con, con->state);\n\t\tqueue_con(con);\n\t}\n}\n\n \nstatic void ceph_sock_write_space(struct sock *sk)\n{\n\tstruct ceph_connection *con = sk->sk_user_data;\n\n\t \n\tif (ceph_con_flag_test(con, CEPH_CON_F_WRITE_PENDING)) {\n\t\tif (sk_stream_is_writeable(sk)) {\n\t\t\tdout(\"%s %p queueing write work\\n\", __func__, con);\n\t\t\tclear_bit(SOCK_NOSPACE, &sk->sk_socket->flags);\n\t\t\tqueue_con(con);\n\t\t}\n\t} else {\n\t\tdout(\"%s %p nothing to write\\n\", __func__, con);\n\t}\n}\n\n \nstatic void ceph_sock_state_change(struct sock *sk)\n{\n\tstruct ceph_connection *con = sk->sk_user_data;\n\n\tdout(\"%s %p state = %d sk_state = %u\\n\", __func__,\n\t     con, con->state, sk->sk_state);\n\n\tswitch (sk->sk_state) {\n\tcase TCP_CLOSE:\n\t\tdout(\"%s TCP_CLOSE\\n\", __func__);\n\t\tfallthrough;\n\tcase TCP_CLOSE_WAIT:\n\t\tdout(\"%s TCP_CLOSE_WAIT\\n\", __func__);\n\t\tcon_sock_state_closing(con);\n\t\tceph_con_flag_set(con, CEPH_CON_F_SOCK_CLOSED);\n\t\tqueue_con(con);\n\t\tbreak;\n\tcase TCP_ESTABLISHED:\n\t\tdout(\"%s TCP_ESTABLISHED\\n\", __func__);\n\t\tcon_sock_state_connected(con);\n\t\tqueue_con(con);\n\t\tbreak;\n\tdefault:\t \n\t\tbreak;\n\t}\n}\n\n \nstatic void set_sock_callbacks(struct socket *sock,\n\t\t\t       struct ceph_connection *con)\n{\n\tstruct sock *sk = sock->sk;\n\tsk->sk_user_data = con;\n\tsk->sk_data_ready = ceph_sock_data_ready;\n\tsk->sk_write_space = ceph_sock_write_space;\n\tsk->sk_state_change = ceph_sock_state_change;\n}\n\n\n \n\n \nint ceph_tcp_connect(struct ceph_connection *con)\n{\n\tstruct sockaddr_storage ss = con->peer_addr.in_addr;  \n\tstruct socket *sock;\n\tunsigned int noio_flag;\n\tint ret;\n\n\tdout(\"%s con %p peer_addr %s\\n\", __func__, con,\n\t     ceph_pr_addr(&con->peer_addr));\n\tBUG_ON(con->sock);\n\n\t \n\tnoio_flag = memalloc_noio_save();\n\tret = sock_create_kern(read_pnet(&con->msgr->net), ss.ss_family,\n\t\t\t       SOCK_STREAM, IPPROTO_TCP, &sock);\n\tmemalloc_noio_restore(noio_flag);\n\tif (ret)\n\t\treturn ret;\n\tsock->sk->sk_allocation = GFP_NOFS;\n\tsock->sk->sk_use_task_frag = false;\n\n#ifdef CONFIG_LOCKDEP\n\tlockdep_set_class(&sock->sk->sk_lock, &socket_class);\n#endif\n\n\tset_sock_callbacks(sock, con);\n\n\tcon_sock_state_connecting(con);\n\tret = kernel_connect(sock, (struct sockaddr *)&ss, sizeof(ss),\n\t\t\t     O_NONBLOCK);\n\tif (ret == -EINPROGRESS) {\n\t\tdout(\"connect %s EINPROGRESS sk_state = %u\\n\",\n\t\t     ceph_pr_addr(&con->peer_addr),\n\t\t     sock->sk->sk_state);\n\t} else if (ret < 0) {\n\t\tpr_err(\"connect %s error %d\\n\",\n\t\t       ceph_pr_addr(&con->peer_addr), ret);\n\t\tsock_release(sock);\n\t\treturn ret;\n\t}\n\n\tif (ceph_test_opt(from_msgr(con->msgr), TCP_NODELAY))\n\t\ttcp_sock_set_nodelay(sock->sk);\n\n\tcon->sock = sock;\n\treturn 0;\n}\n\n \nint ceph_con_close_socket(struct ceph_connection *con)\n{\n\tint rc = 0;\n\n\tdout(\"%s con %p sock %p\\n\", __func__, con, con->sock);\n\tif (con->sock) {\n\t\trc = con->sock->ops->shutdown(con->sock, SHUT_RDWR);\n\t\tsock_release(con->sock);\n\t\tcon->sock = NULL;\n\t}\n\n\t \n\tceph_con_flag_clear(con, CEPH_CON_F_SOCK_CLOSED);\n\n\tcon_sock_state_closed(con);\n\treturn rc;\n}\n\nstatic void ceph_con_reset_protocol(struct ceph_connection *con)\n{\n\tdout(\"%s con %p\\n\", __func__, con);\n\n\tceph_con_close_socket(con);\n\tif (con->in_msg) {\n\t\tWARN_ON(con->in_msg->con != con);\n\t\tceph_msg_put(con->in_msg);\n\t\tcon->in_msg = NULL;\n\t}\n\tif (con->out_msg) {\n\t\tWARN_ON(con->out_msg->con != con);\n\t\tceph_msg_put(con->out_msg);\n\t\tcon->out_msg = NULL;\n\t}\n\tif (con->bounce_page) {\n\t\t__free_page(con->bounce_page);\n\t\tcon->bounce_page = NULL;\n\t}\n\n\tif (ceph_msgr2(from_msgr(con->msgr)))\n\t\tceph_con_v2_reset_protocol(con);\n\telse\n\t\tceph_con_v1_reset_protocol(con);\n}\n\n \nstatic void ceph_msg_remove(struct ceph_msg *msg)\n{\n\tlist_del_init(&msg->list_head);\n\n\tceph_msg_put(msg);\n}\n\nstatic void ceph_msg_remove_list(struct list_head *head)\n{\n\twhile (!list_empty(head)) {\n\t\tstruct ceph_msg *msg = list_first_entry(head, struct ceph_msg,\n\t\t\t\t\t\t\tlist_head);\n\t\tceph_msg_remove(msg);\n\t}\n}\n\nvoid ceph_con_reset_session(struct ceph_connection *con)\n{\n\tdout(\"%s con %p\\n\", __func__, con);\n\n\tWARN_ON(con->in_msg);\n\tWARN_ON(con->out_msg);\n\tceph_msg_remove_list(&con->out_queue);\n\tceph_msg_remove_list(&con->out_sent);\n\tcon->out_seq = 0;\n\tcon->in_seq = 0;\n\tcon->in_seq_acked = 0;\n\n\tif (ceph_msgr2(from_msgr(con->msgr)))\n\t\tceph_con_v2_reset_session(con);\n\telse\n\t\tceph_con_v1_reset_session(con);\n}\n\n \nvoid ceph_con_close(struct ceph_connection *con)\n{\n\tmutex_lock(&con->mutex);\n\tdout(\"con_close %p peer %s\\n\", con, ceph_pr_addr(&con->peer_addr));\n\tcon->state = CEPH_CON_S_CLOSED;\n\n\tceph_con_flag_clear(con, CEPH_CON_F_LOSSYTX);   \n\tceph_con_flag_clear(con, CEPH_CON_F_KEEPALIVE_PENDING);\n\tceph_con_flag_clear(con, CEPH_CON_F_WRITE_PENDING);\n\tceph_con_flag_clear(con, CEPH_CON_F_BACKOFF);\n\n\tceph_con_reset_protocol(con);\n\tceph_con_reset_session(con);\n\tcancel_con(con);\n\tmutex_unlock(&con->mutex);\n}\nEXPORT_SYMBOL(ceph_con_close);\n\n \nvoid ceph_con_open(struct ceph_connection *con,\n\t\t   __u8 entity_type, __u64 entity_num,\n\t\t   struct ceph_entity_addr *addr)\n{\n\tmutex_lock(&con->mutex);\n\tdout(\"con_open %p %s\\n\", con, ceph_pr_addr(addr));\n\n\tWARN_ON(con->state != CEPH_CON_S_CLOSED);\n\tcon->state = CEPH_CON_S_PREOPEN;\n\n\tcon->peer_name.type = (__u8) entity_type;\n\tcon->peer_name.num = cpu_to_le64(entity_num);\n\n\tmemcpy(&con->peer_addr, addr, sizeof(*addr));\n\tcon->delay = 0;       \n\tmutex_unlock(&con->mutex);\n\tqueue_con(con);\n}\nEXPORT_SYMBOL(ceph_con_open);\n\n \nbool ceph_con_opened(struct ceph_connection *con)\n{\n\tif (ceph_msgr2(from_msgr(con->msgr)))\n\t\treturn ceph_con_v2_opened(con);\n\n\treturn ceph_con_v1_opened(con);\n}\n\n \nvoid ceph_con_init(struct ceph_connection *con, void *private,\n\tconst struct ceph_connection_operations *ops,\n\tstruct ceph_messenger *msgr)\n{\n\tdout(\"con_init %p\\n\", con);\n\tmemset(con, 0, sizeof(*con));\n\tcon->private = private;\n\tcon->ops = ops;\n\tcon->msgr = msgr;\n\n\tcon_sock_state_init(con);\n\n\tmutex_init(&con->mutex);\n\tINIT_LIST_HEAD(&con->out_queue);\n\tINIT_LIST_HEAD(&con->out_sent);\n\tINIT_DELAYED_WORK(&con->work, ceph_con_workfn);\n\n\tcon->state = CEPH_CON_S_CLOSED;\n}\nEXPORT_SYMBOL(ceph_con_init);\n\n \nu32 ceph_get_global_seq(struct ceph_messenger *msgr, u32 gt)\n{\n\tu32 ret;\n\n\tspin_lock(&msgr->global_seq_lock);\n\tif (msgr->global_seq < gt)\n\t\tmsgr->global_seq = gt;\n\tret = ++msgr->global_seq;\n\tspin_unlock(&msgr->global_seq_lock);\n\treturn ret;\n}\n\n \nvoid ceph_con_discard_sent(struct ceph_connection *con, u64 ack_seq)\n{\n\tstruct ceph_msg *msg;\n\tu64 seq;\n\n\tdout(\"%s con %p ack_seq %llu\\n\", __func__, con, ack_seq);\n\twhile (!list_empty(&con->out_sent)) {\n\t\tmsg = list_first_entry(&con->out_sent, struct ceph_msg,\n\t\t\t\t       list_head);\n\t\tWARN_ON(msg->needs_out_seq);\n\t\tseq = le64_to_cpu(msg->hdr.seq);\n\t\tif (seq > ack_seq)\n\t\t\tbreak;\n\n\t\tdout(\"%s con %p discarding msg %p seq %llu\\n\", __func__, con,\n\t\t     msg, seq);\n\t\tceph_msg_remove(msg);\n\t}\n}\n\n \nvoid ceph_con_discard_requeued(struct ceph_connection *con, u64 reconnect_seq)\n{\n\tstruct ceph_msg *msg;\n\tu64 seq;\n\n\tdout(\"%s con %p reconnect_seq %llu\\n\", __func__, con, reconnect_seq);\n\twhile (!list_empty(&con->out_queue)) {\n\t\tmsg = list_first_entry(&con->out_queue, struct ceph_msg,\n\t\t\t\t       list_head);\n\t\tif (msg->needs_out_seq)\n\t\t\tbreak;\n\t\tseq = le64_to_cpu(msg->hdr.seq);\n\t\tif (seq > reconnect_seq)\n\t\t\tbreak;\n\n\t\tdout(\"%s con %p discarding msg %p seq %llu\\n\", __func__, con,\n\t\t     msg, seq);\n\t\tceph_msg_remove(msg);\n\t}\n}\n\n#ifdef CONFIG_BLOCK\n\n \nstatic void ceph_msg_data_bio_cursor_init(struct ceph_msg_data_cursor *cursor,\n\t\t\t\t\tsize_t length)\n{\n\tstruct ceph_msg_data *data = cursor->data;\n\tstruct ceph_bio_iter *it = &cursor->bio_iter;\n\n\tcursor->resid = min_t(size_t, length, data->bio_length);\n\t*it = data->bio_pos;\n\tif (cursor->resid < it->iter.bi_size)\n\t\tit->iter.bi_size = cursor->resid;\n\n\tBUG_ON(cursor->resid < bio_iter_len(it->bio, it->iter));\n}\n\nstatic struct page *ceph_msg_data_bio_next(struct ceph_msg_data_cursor *cursor,\n\t\t\t\t\t\tsize_t *page_offset,\n\t\t\t\t\t\tsize_t *length)\n{\n\tstruct bio_vec bv = bio_iter_iovec(cursor->bio_iter.bio,\n\t\t\t\t\t   cursor->bio_iter.iter);\n\n\t*page_offset = bv.bv_offset;\n\t*length = bv.bv_len;\n\treturn bv.bv_page;\n}\n\nstatic bool ceph_msg_data_bio_advance(struct ceph_msg_data_cursor *cursor,\n\t\t\t\t\tsize_t bytes)\n{\n\tstruct ceph_bio_iter *it = &cursor->bio_iter;\n\tstruct page *page = bio_iter_page(it->bio, it->iter);\n\n\tBUG_ON(bytes > cursor->resid);\n\tBUG_ON(bytes > bio_iter_len(it->bio, it->iter));\n\tcursor->resid -= bytes;\n\tbio_advance_iter(it->bio, &it->iter, bytes);\n\n\tif (!cursor->resid)\n\t\treturn false;    \n\n\tif (!bytes || (it->iter.bi_size && it->iter.bi_bvec_done &&\n\t\t       page == bio_iter_page(it->bio, it->iter)))\n\t\treturn false;\t \n\n\tif (!it->iter.bi_size) {\n\t\tit->bio = it->bio->bi_next;\n\t\tit->iter = it->bio->bi_iter;\n\t\tif (cursor->resid < it->iter.bi_size)\n\t\t\tit->iter.bi_size = cursor->resid;\n\t}\n\n\tBUG_ON(cursor->resid < bio_iter_len(it->bio, it->iter));\n\treturn true;\n}\n#endif  \n\nstatic void ceph_msg_data_bvecs_cursor_init(struct ceph_msg_data_cursor *cursor,\n\t\t\t\t\tsize_t length)\n{\n\tstruct ceph_msg_data *data = cursor->data;\n\tstruct bio_vec *bvecs = data->bvec_pos.bvecs;\n\n\tcursor->resid = min_t(size_t, length, data->bvec_pos.iter.bi_size);\n\tcursor->bvec_iter = data->bvec_pos.iter;\n\tcursor->bvec_iter.bi_size = cursor->resid;\n\n\tBUG_ON(cursor->resid < bvec_iter_len(bvecs, cursor->bvec_iter));\n}\n\nstatic struct page *ceph_msg_data_bvecs_next(struct ceph_msg_data_cursor *cursor,\n\t\t\t\t\t\tsize_t *page_offset,\n\t\t\t\t\t\tsize_t *length)\n{\n\tstruct bio_vec bv = bvec_iter_bvec(cursor->data->bvec_pos.bvecs,\n\t\t\t\t\t   cursor->bvec_iter);\n\n\t*page_offset = bv.bv_offset;\n\t*length = bv.bv_len;\n\treturn bv.bv_page;\n}\n\nstatic bool ceph_msg_data_bvecs_advance(struct ceph_msg_data_cursor *cursor,\n\t\t\t\t\tsize_t bytes)\n{\n\tstruct bio_vec *bvecs = cursor->data->bvec_pos.bvecs;\n\tstruct page *page = bvec_iter_page(bvecs, cursor->bvec_iter);\n\n\tBUG_ON(bytes > cursor->resid);\n\tBUG_ON(bytes > bvec_iter_len(bvecs, cursor->bvec_iter));\n\tcursor->resid -= bytes;\n\tbvec_iter_advance(bvecs, &cursor->bvec_iter, bytes);\n\n\tif (!cursor->resid)\n\t\treturn false;    \n\n\tif (!bytes || (cursor->bvec_iter.bi_bvec_done &&\n\t\t       page == bvec_iter_page(bvecs, cursor->bvec_iter)))\n\t\treturn false;\t \n\n\tBUG_ON(cursor->resid < bvec_iter_len(bvecs, cursor->bvec_iter));\n\treturn true;\n}\n\n \nstatic void ceph_msg_data_pages_cursor_init(struct ceph_msg_data_cursor *cursor,\n\t\t\t\t\tsize_t length)\n{\n\tstruct ceph_msg_data *data = cursor->data;\n\tint page_count;\n\n\tBUG_ON(data->type != CEPH_MSG_DATA_PAGES);\n\n\tBUG_ON(!data->pages);\n\tBUG_ON(!data->length);\n\n\tcursor->resid = min(length, data->length);\n\tpage_count = calc_pages_for(data->alignment, (u64)data->length);\n\tcursor->page_offset = data->alignment & ~PAGE_MASK;\n\tcursor->page_index = 0;\n\tBUG_ON(page_count > (int)USHRT_MAX);\n\tcursor->page_count = (unsigned short)page_count;\n\tBUG_ON(length > SIZE_MAX - cursor->page_offset);\n}\n\nstatic struct page *\nceph_msg_data_pages_next(struct ceph_msg_data_cursor *cursor,\n\t\t\t\t\tsize_t *page_offset, size_t *length)\n{\n\tstruct ceph_msg_data *data = cursor->data;\n\n\tBUG_ON(data->type != CEPH_MSG_DATA_PAGES);\n\n\tBUG_ON(cursor->page_index >= cursor->page_count);\n\tBUG_ON(cursor->page_offset >= PAGE_SIZE);\n\n\t*page_offset = cursor->page_offset;\n\t*length = min_t(size_t, cursor->resid, PAGE_SIZE - *page_offset);\n\treturn data->pages[cursor->page_index];\n}\n\nstatic bool ceph_msg_data_pages_advance(struct ceph_msg_data_cursor *cursor,\n\t\t\t\t\t\tsize_t bytes)\n{\n\tBUG_ON(cursor->data->type != CEPH_MSG_DATA_PAGES);\n\n\tBUG_ON(cursor->page_offset + bytes > PAGE_SIZE);\n\n\t \n\n\tcursor->resid -= bytes;\n\tcursor->page_offset = (cursor->page_offset + bytes) & ~PAGE_MASK;\n\tif (!bytes || cursor->page_offset)\n\t\treturn false;\t \n\n\tif (!cursor->resid)\n\t\treturn false;    \n\n\t \n\n\tBUG_ON(cursor->page_index >= cursor->page_count);\n\tcursor->page_index++;\n\treturn true;\n}\n\n \nstatic void\nceph_msg_data_pagelist_cursor_init(struct ceph_msg_data_cursor *cursor,\n\t\t\t\t\tsize_t length)\n{\n\tstruct ceph_msg_data *data = cursor->data;\n\tstruct ceph_pagelist *pagelist;\n\tstruct page *page;\n\n\tBUG_ON(data->type != CEPH_MSG_DATA_PAGELIST);\n\n\tpagelist = data->pagelist;\n\tBUG_ON(!pagelist);\n\n\tif (!length)\n\t\treturn;\t\t \n\n\tBUG_ON(list_empty(&pagelist->head));\n\tpage = list_first_entry(&pagelist->head, struct page, lru);\n\n\tcursor->resid = min(length, pagelist->length);\n\tcursor->page = page;\n\tcursor->offset = 0;\n}\n\nstatic struct page *\nceph_msg_data_pagelist_next(struct ceph_msg_data_cursor *cursor,\n\t\t\t\tsize_t *page_offset, size_t *length)\n{\n\tstruct ceph_msg_data *data = cursor->data;\n\tstruct ceph_pagelist *pagelist;\n\n\tBUG_ON(data->type != CEPH_MSG_DATA_PAGELIST);\n\n\tpagelist = data->pagelist;\n\tBUG_ON(!pagelist);\n\n\tBUG_ON(!cursor->page);\n\tBUG_ON(cursor->offset + cursor->resid != pagelist->length);\n\n\t \n\t*page_offset = cursor->offset & ~PAGE_MASK;\n\t*length = min_t(size_t, cursor->resid, PAGE_SIZE - *page_offset);\n\treturn cursor->page;\n}\n\nstatic bool ceph_msg_data_pagelist_advance(struct ceph_msg_data_cursor *cursor,\n\t\t\t\t\t\tsize_t bytes)\n{\n\tstruct ceph_msg_data *data = cursor->data;\n\tstruct ceph_pagelist *pagelist;\n\n\tBUG_ON(data->type != CEPH_MSG_DATA_PAGELIST);\n\n\tpagelist = data->pagelist;\n\tBUG_ON(!pagelist);\n\n\tBUG_ON(cursor->offset + cursor->resid != pagelist->length);\n\tBUG_ON((cursor->offset & ~PAGE_MASK) + bytes > PAGE_SIZE);\n\n\t \n\n\tcursor->resid -= bytes;\n\tcursor->offset += bytes;\n\t \n\tif (!bytes || cursor->offset & ~PAGE_MASK)\n\t\treturn false;\t \n\n\tif (!cursor->resid)\n\t\treturn false;    \n\n\t \n\n\tBUG_ON(list_is_last(&cursor->page->lru, &pagelist->head));\n\tcursor->page = list_next_entry(cursor->page, lru);\n\treturn true;\n}\n\nstatic void ceph_msg_data_iter_cursor_init(struct ceph_msg_data_cursor *cursor,\n\t\t\t\t\t   size_t length)\n{\n\tstruct ceph_msg_data *data = cursor->data;\n\n\tcursor->iov_iter = data->iter;\n\tcursor->lastlen = 0;\n\tiov_iter_truncate(&cursor->iov_iter, length);\n\tcursor->resid = iov_iter_count(&cursor->iov_iter);\n}\n\nstatic struct page *ceph_msg_data_iter_next(struct ceph_msg_data_cursor *cursor,\n\t\t\t\t\t    size_t *page_offset, size_t *length)\n{\n\tstruct page *page;\n\tssize_t len;\n\n\tif (cursor->lastlen)\n\t\tiov_iter_revert(&cursor->iov_iter, cursor->lastlen);\n\n\tlen = iov_iter_get_pages2(&cursor->iov_iter, &page, PAGE_SIZE,\n\t\t\t\t  1, page_offset);\n\tBUG_ON(len < 0);\n\n\tcursor->lastlen = len;\n\n\t \n\tVM_BUG_ON_PAGE(!PageWriteback(page) && page_count(page) < 2, page);\n\tput_page(page);\n\n\t*length = min_t(size_t, len, cursor->resid);\n\treturn page;\n}\n\nstatic bool ceph_msg_data_iter_advance(struct ceph_msg_data_cursor *cursor,\n\t\t\t\t       size_t bytes)\n{\n\tBUG_ON(bytes > cursor->resid);\n\tcursor->resid -= bytes;\n\n\tif (bytes < cursor->lastlen) {\n\t\tcursor->lastlen -= bytes;\n\t} else {\n\t\tiov_iter_advance(&cursor->iov_iter, bytes - cursor->lastlen);\n\t\tcursor->lastlen = 0;\n\t}\n\n\treturn cursor->resid;\n}\n\n \nstatic void __ceph_msg_data_cursor_init(struct ceph_msg_data_cursor *cursor)\n{\n\tsize_t length = cursor->total_resid;\n\n\tswitch (cursor->data->type) {\n\tcase CEPH_MSG_DATA_PAGELIST:\n\t\tceph_msg_data_pagelist_cursor_init(cursor, length);\n\t\tbreak;\n\tcase CEPH_MSG_DATA_PAGES:\n\t\tceph_msg_data_pages_cursor_init(cursor, length);\n\t\tbreak;\n#ifdef CONFIG_BLOCK\n\tcase CEPH_MSG_DATA_BIO:\n\t\tceph_msg_data_bio_cursor_init(cursor, length);\n\t\tbreak;\n#endif  \n\tcase CEPH_MSG_DATA_BVECS:\n\t\tceph_msg_data_bvecs_cursor_init(cursor, length);\n\t\tbreak;\n\tcase CEPH_MSG_DATA_ITER:\n\t\tceph_msg_data_iter_cursor_init(cursor, length);\n\t\tbreak;\n\tcase CEPH_MSG_DATA_NONE:\n\tdefault:\n\t\t \n\t\tbreak;\n\t}\n\tcursor->need_crc = true;\n}\n\nvoid ceph_msg_data_cursor_init(struct ceph_msg_data_cursor *cursor,\n\t\t\t       struct ceph_msg *msg, size_t length)\n{\n\tBUG_ON(!length);\n\tBUG_ON(length > msg->data_length);\n\tBUG_ON(!msg->num_data_items);\n\n\tcursor->total_resid = length;\n\tcursor->data = msg->data;\n\tcursor->sr_resid = 0;\n\n\t__ceph_msg_data_cursor_init(cursor);\n}\n\n \nstruct page *ceph_msg_data_next(struct ceph_msg_data_cursor *cursor,\n\t\t\t\tsize_t *page_offset, size_t *length)\n{\n\tstruct page *page;\n\n\tswitch (cursor->data->type) {\n\tcase CEPH_MSG_DATA_PAGELIST:\n\t\tpage = ceph_msg_data_pagelist_next(cursor, page_offset, length);\n\t\tbreak;\n\tcase CEPH_MSG_DATA_PAGES:\n\t\tpage = ceph_msg_data_pages_next(cursor, page_offset, length);\n\t\tbreak;\n#ifdef CONFIG_BLOCK\n\tcase CEPH_MSG_DATA_BIO:\n\t\tpage = ceph_msg_data_bio_next(cursor, page_offset, length);\n\t\tbreak;\n#endif  \n\tcase CEPH_MSG_DATA_BVECS:\n\t\tpage = ceph_msg_data_bvecs_next(cursor, page_offset, length);\n\t\tbreak;\n\tcase CEPH_MSG_DATA_ITER:\n\t\tpage = ceph_msg_data_iter_next(cursor, page_offset, length);\n\t\tbreak;\n\tcase CEPH_MSG_DATA_NONE:\n\tdefault:\n\t\tpage = NULL;\n\t\tbreak;\n\t}\n\n\tBUG_ON(!page);\n\tBUG_ON(*page_offset + *length > PAGE_SIZE);\n\tBUG_ON(!*length);\n\tBUG_ON(*length > cursor->resid);\n\n\treturn page;\n}\n\n \nvoid ceph_msg_data_advance(struct ceph_msg_data_cursor *cursor, size_t bytes)\n{\n\tbool new_piece;\n\n\tBUG_ON(bytes > cursor->resid);\n\tswitch (cursor->data->type) {\n\tcase CEPH_MSG_DATA_PAGELIST:\n\t\tnew_piece = ceph_msg_data_pagelist_advance(cursor, bytes);\n\t\tbreak;\n\tcase CEPH_MSG_DATA_PAGES:\n\t\tnew_piece = ceph_msg_data_pages_advance(cursor, bytes);\n\t\tbreak;\n#ifdef CONFIG_BLOCK\n\tcase CEPH_MSG_DATA_BIO:\n\t\tnew_piece = ceph_msg_data_bio_advance(cursor, bytes);\n\t\tbreak;\n#endif  \n\tcase CEPH_MSG_DATA_BVECS:\n\t\tnew_piece = ceph_msg_data_bvecs_advance(cursor, bytes);\n\t\tbreak;\n\tcase CEPH_MSG_DATA_ITER:\n\t\tnew_piece = ceph_msg_data_iter_advance(cursor, bytes);\n\t\tbreak;\n\tcase CEPH_MSG_DATA_NONE:\n\tdefault:\n\t\tBUG();\n\t\tbreak;\n\t}\n\tcursor->total_resid -= bytes;\n\n\tif (!cursor->resid && cursor->total_resid) {\n\t\tcursor->data++;\n\t\t__ceph_msg_data_cursor_init(cursor);\n\t\tnew_piece = true;\n\t}\n\tcursor->need_crc = new_piece;\n}\n\nu32 ceph_crc32c_page(u32 crc, struct page *page, unsigned int page_offset,\n\t\t     unsigned int length)\n{\n\tchar *kaddr;\n\n\tkaddr = kmap(page);\n\tBUG_ON(kaddr == NULL);\n\tcrc = crc32c(crc, kaddr + page_offset, length);\n\tkunmap(page);\n\n\treturn crc;\n}\n\nbool ceph_addr_is_blank(const struct ceph_entity_addr *addr)\n{\n\tstruct sockaddr_storage ss = addr->in_addr;  \n\tstruct in_addr *addr4 = &((struct sockaddr_in *)&ss)->sin_addr;\n\tstruct in6_addr *addr6 = &((struct sockaddr_in6 *)&ss)->sin6_addr;\n\n\tswitch (ss.ss_family) {\n\tcase AF_INET:\n\t\treturn addr4->s_addr == htonl(INADDR_ANY);\n\tcase AF_INET6:\n\t\treturn ipv6_addr_any(addr6);\n\tdefault:\n\t\treturn true;\n\t}\n}\nEXPORT_SYMBOL(ceph_addr_is_blank);\n\nint ceph_addr_port(const struct ceph_entity_addr *addr)\n{\n\tswitch (get_unaligned(&addr->in_addr.ss_family)) {\n\tcase AF_INET:\n\t\treturn ntohs(get_unaligned(&((struct sockaddr_in *)&addr->in_addr)->sin_port));\n\tcase AF_INET6:\n\t\treturn ntohs(get_unaligned(&((struct sockaddr_in6 *)&addr->in_addr)->sin6_port));\n\t}\n\treturn 0;\n}\n\nvoid ceph_addr_set_port(struct ceph_entity_addr *addr, int p)\n{\n\tswitch (get_unaligned(&addr->in_addr.ss_family)) {\n\tcase AF_INET:\n\t\tput_unaligned(htons(p), &((struct sockaddr_in *)&addr->in_addr)->sin_port);\n\t\tbreak;\n\tcase AF_INET6:\n\t\tput_unaligned(htons(p), &((struct sockaddr_in6 *)&addr->in_addr)->sin6_port);\n\t\tbreak;\n\t}\n}\n\n \nstatic int ceph_pton(const char *str, size_t len, struct ceph_entity_addr *addr,\n\t\tchar delim, const char **ipend)\n{\n\tmemset(&addr->in_addr, 0, sizeof(addr->in_addr));\n\n\tif (in4_pton(str, len, (u8 *)&((struct sockaddr_in *)&addr->in_addr)->sin_addr.s_addr, delim, ipend)) {\n\t\tput_unaligned(AF_INET, &addr->in_addr.ss_family);\n\t\treturn 0;\n\t}\n\n\tif (in6_pton(str, len, (u8 *)&((struct sockaddr_in6 *)&addr->in_addr)->sin6_addr.s6_addr, delim, ipend)) {\n\t\tput_unaligned(AF_INET6, &addr->in_addr.ss_family);\n\t\treturn 0;\n\t}\n\n\treturn -EINVAL;\n}\n\n \n#ifdef CONFIG_CEPH_LIB_USE_DNS_RESOLVER\nstatic int ceph_dns_resolve_name(const char *name, size_t namelen,\n\t\tstruct ceph_entity_addr *addr, char delim, const char **ipend)\n{\n\tconst char *end, *delim_p;\n\tchar *colon_p, *ip_addr = NULL;\n\tint ip_len, ret;\n\n\t \n\tdelim_p = memchr(name, delim, namelen);\n\tcolon_p = memchr(name, ':', namelen);\n\n\tif (delim_p && colon_p)\n\t\tend = delim_p < colon_p ? delim_p : colon_p;\n\telse if (!delim_p && colon_p)\n\t\tend = colon_p;\n\telse {\n\t\tend = delim_p;\n\t\tif (!end)  \n\t\t\tend = name + namelen;\n\t}\n\n\tif (end <= name)\n\t\treturn -EINVAL;\n\n\t \n\tip_len = dns_query(current->nsproxy->net_ns,\n\t\t\t   NULL, name, end - name, NULL, &ip_addr, NULL, false);\n\tif (ip_len > 0)\n\t\tret = ceph_pton(ip_addr, ip_len, addr, -1, NULL);\n\telse\n\t\tret = -ESRCH;\n\n\tkfree(ip_addr);\n\n\t*ipend = end;\n\n\tpr_info(\"resolve '%.*s' (ret=%d): %s\\n\", (int)(end - name), name,\n\t\t\tret, ret ? \"failed\" : ceph_pr_addr(addr));\n\n\treturn ret;\n}\n#else\nstatic inline int ceph_dns_resolve_name(const char *name, size_t namelen,\n\t\tstruct ceph_entity_addr *addr, char delim, const char **ipend)\n{\n\treturn -EINVAL;\n}\n#endif\n\n \nstatic int ceph_parse_server_name(const char *name, size_t namelen,\n\t\tstruct ceph_entity_addr *addr, char delim, const char **ipend)\n{\n\tint ret;\n\n\tret = ceph_pton(name, namelen, addr, delim, ipend);\n\tif (ret)\n\t\tret = ceph_dns_resolve_name(name, namelen, addr, delim, ipend);\n\n\treturn ret;\n}\n\n \nint ceph_parse_ips(const char *c, const char *end,\n\t\t   struct ceph_entity_addr *addr,\n\t\t   int max_count, int *count, char delim)\n{\n\tint i, ret = -EINVAL;\n\tconst char *p = c;\n\n\tdout(\"parse_ips on '%.*s'\\n\", (int)(end-c), c);\n\tfor (i = 0; i < max_count; i++) {\n\t\tchar cur_delim = delim;\n\t\tconst char *ipend;\n\t\tint port;\n\n\t\tif (*p == '[') {\n\t\t\tcur_delim = ']';\n\t\t\tp++;\n\t\t}\n\n\t\tret = ceph_parse_server_name(p, end - p, &addr[i], cur_delim,\n\t\t\t\t\t     &ipend);\n\t\tif (ret)\n\t\t\tgoto bad;\n\t\tret = -EINVAL;\n\n\t\tp = ipend;\n\n\t\tif (cur_delim == ']') {\n\t\t\tif (*p != ']') {\n\t\t\t\tdout(\"missing matching ']'\\n\");\n\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tp++;\n\t\t}\n\n\t\t \n\t\tif (p < end && *p == ':') {\n\t\t\tport = 0;\n\t\t\tp++;\n\t\t\twhile (p < end && *p >= '0' && *p <= '9') {\n\t\t\t\tport = (port * 10) + (*p - '0');\n\t\t\t\tp++;\n\t\t\t}\n\t\t\tif (port == 0)\n\t\t\t\tport = CEPH_MON_PORT;\n\t\t\telse if (port > 65535)\n\t\t\t\tgoto bad;\n\t\t} else {\n\t\t\tport = CEPH_MON_PORT;\n\t\t}\n\n\t\tceph_addr_set_port(&addr[i], port);\n\t\t \n\t\taddr[i].type = CEPH_ENTITY_ADDR_TYPE_LEGACY;\n\t\taddr[i].nonce = 0;\n\n\t\tdout(\"%s got %s\\n\", __func__, ceph_pr_addr(&addr[i]));\n\n\t\tif (p == end)\n\t\t\tbreak;\n\t\tif (*p != delim)\n\t\t\tgoto bad;\n\t\tp++;\n\t}\n\n\tif (p != end)\n\t\tgoto bad;\n\n\tif (count)\n\t\t*count = i + 1;\n\treturn 0;\n\nbad:\n\treturn ret;\n}\n\n \nvoid ceph_con_process_message(struct ceph_connection *con)\n{\n\tstruct ceph_msg *msg = con->in_msg;\n\n\tBUG_ON(con->in_msg->con != con);\n\tcon->in_msg = NULL;\n\n\t \n\tif (con->peer_name.type == 0)\n\t\tcon->peer_name = msg->hdr.src;\n\n\tcon->in_seq++;\n\tmutex_unlock(&con->mutex);\n\n\tdout(\"===== %p %llu from %s%lld %d=%s len %d+%d+%d (%u %u %u) =====\\n\",\n\t     msg, le64_to_cpu(msg->hdr.seq),\n\t     ENTITY_NAME(msg->hdr.src),\n\t     le16_to_cpu(msg->hdr.type),\n\t     ceph_msg_type_name(le16_to_cpu(msg->hdr.type)),\n\t     le32_to_cpu(msg->hdr.front_len),\n\t     le32_to_cpu(msg->hdr.middle_len),\n\t     le32_to_cpu(msg->hdr.data_len),\n\t     con->in_front_crc, con->in_middle_crc, con->in_data_crc);\n\tcon->ops->dispatch(con, msg);\n\n\tmutex_lock(&con->mutex);\n}\n\n \nstatic int queue_con_delay(struct ceph_connection *con, unsigned long delay)\n{\n\tif (!con->ops->get(con)) {\n\t\tdout(\"%s %p ref count 0\\n\", __func__, con);\n\t\treturn -ENOENT;\n\t}\n\n\tif (delay >= HZ)\n\t\tdelay = round_jiffies_relative(delay);\n\n\tdout(\"%s %p %lu\\n\", __func__, con, delay);\n\tif (!queue_delayed_work(ceph_msgr_wq, &con->work, delay)) {\n\t\tdout(\"%s %p - already queued\\n\", __func__, con);\n\t\tcon->ops->put(con);\n\t\treturn -EBUSY;\n\t}\n\n\treturn 0;\n}\n\nstatic void queue_con(struct ceph_connection *con)\n{\n\t(void) queue_con_delay(con, 0);\n}\n\nstatic void cancel_con(struct ceph_connection *con)\n{\n\tif (cancel_delayed_work(&con->work)) {\n\t\tdout(\"%s %p\\n\", __func__, con);\n\t\tcon->ops->put(con);\n\t}\n}\n\nstatic bool con_sock_closed(struct ceph_connection *con)\n{\n\tif (!ceph_con_flag_test_and_clear(con, CEPH_CON_F_SOCK_CLOSED))\n\t\treturn false;\n\n#define CASE(x)\t\t\t\t\t\t\t\t\\\n\tcase CEPH_CON_S_ ## x:\t\t\t\t\t\t\\\n\t\tcon->error_msg = \"socket closed (con state \" #x \")\";\t\\\n\t\tbreak;\n\n\tswitch (con->state) {\n\tCASE(CLOSED);\n\tCASE(PREOPEN);\n\tCASE(V1_BANNER);\n\tCASE(V1_CONNECT_MSG);\n\tCASE(V2_BANNER_PREFIX);\n\tCASE(V2_BANNER_PAYLOAD);\n\tCASE(V2_HELLO);\n\tCASE(V2_AUTH);\n\tCASE(V2_AUTH_SIGNATURE);\n\tCASE(V2_SESSION_CONNECT);\n\tCASE(V2_SESSION_RECONNECT);\n\tCASE(OPEN);\n\tCASE(STANDBY);\n\tdefault:\n\t\tBUG();\n\t}\n#undef CASE\n\n\treturn true;\n}\n\nstatic bool con_backoff(struct ceph_connection *con)\n{\n\tint ret;\n\n\tif (!ceph_con_flag_test_and_clear(con, CEPH_CON_F_BACKOFF))\n\t\treturn false;\n\n\tret = queue_con_delay(con, con->delay);\n\tif (ret) {\n\t\tdout(\"%s: con %p FAILED to back off %lu\\n\", __func__,\n\t\t\tcon, con->delay);\n\t\tBUG_ON(ret == -ENOENT);\n\t\tceph_con_flag_set(con, CEPH_CON_F_BACKOFF);\n\t}\n\n\treturn true;\n}\n\n \n\nstatic void con_fault_finish(struct ceph_connection *con)\n{\n\tdout(\"%s %p\\n\", __func__, con);\n\n\t \n\tif (con->v1.auth_retry) {\n\t\tdout(\"auth_retry %d, invalidating\\n\", con->v1.auth_retry);\n\t\tif (con->ops->invalidate_authorizer)\n\t\t\tcon->ops->invalidate_authorizer(con);\n\t\tcon->v1.auth_retry = 0;\n\t}\n\n\tif (con->ops->fault)\n\t\tcon->ops->fault(con);\n}\n\n \nstatic void ceph_con_workfn(struct work_struct *work)\n{\n\tstruct ceph_connection *con = container_of(work, struct ceph_connection,\n\t\t\t\t\t\t   work.work);\n\tbool fault;\n\n\tmutex_lock(&con->mutex);\n\twhile (true) {\n\t\tint ret;\n\n\t\tif ((fault = con_sock_closed(con))) {\n\t\t\tdout(\"%s: con %p SOCK_CLOSED\\n\", __func__, con);\n\t\t\tbreak;\n\t\t}\n\t\tif (con_backoff(con)) {\n\t\t\tdout(\"%s: con %p BACKOFF\\n\", __func__, con);\n\t\t\tbreak;\n\t\t}\n\t\tif (con->state == CEPH_CON_S_STANDBY) {\n\t\t\tdout(\"%s: con %p STANDBY\\n\", __func__, con);\n\t\t\tbreak;\n\t\t}\n\t\tif (con->state == CEPH_CON_S_CLOSED) {\n\t\t\tdout(\"%s: con %p CLOSED\\n\", __func__, con);\n\t\t\tBUG_ON(con->sock);\n\t\t\tbreak;\n\t\t}\n\t\tif (con->state == CEPH_CON_S_PREOPEN) {\n\t\t\tdout(\"%s: con %p PREOPEN\\n\", __func__, con);\n\t\t\tBUG_ON(con->sock);\n\t\t}\n\n\t\tif (ceph_msgr2(from_msgr(con->msgr)))\n\t\t\tret = ceph_con_v2_try_read(con);\n\t\telse\n\t\t\tret = ceph_con_v1_try_read(con);\n\t\tif (ret < 0) {\n\t\t\tif (ret == -EAGAIN)\n\t\t\t\tcontinue;\n\t\t\tif (!con->error_msg)\n\t\t\t\tcon->error_msg = \"socket error on read\";\n\t\t\tfault = true;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (ceph_msgr2(from_msgr(con->msgr)))\n\t\t\tret = ceph_con_v2_try_write(con);\n\t\telse\n\t\t\tret = ceph_con_v1_try_write(con);\n\t\tif (ret < 0) {\n\t\t\tif (ret == -EAGAIN)\n\t\t\t\tcontinue;\n\t\t\tif (!con->error_msg)\n\t\t\t\tcon->error_msg = \"socket error on write\";\n\t\t\tfault = true;\n\t\t}\n\n\t\tbreak;\t \n\t}\n\tif (fault)\n\t\tcon_fault(con);\n\tmutex_unlock(&con->mutex);\n\n\tif (fault)\n\t\tcon_fault_finish(con);\n\n\tcon->ops->put(con);\n}\n\n \nstatic void con_fault(struct ceph_connection *con)\n{\n\tdout(\"fault %p state %d to peer %s\\n\",\n\t     con, con->state, ceph_pr_addr(&con->peer_addr));\n\n\tpr_warn(\"%s%lld %s %s\\n\", ENTITY_NAME(con->peer_name),\n\t\tceph_pr_addr(&con->peer_addr), con->error_msg);\n\tcon->error_msg = NULL;\n\n\tWARN_ON(con->state == CEPH_CON_S_STANDBY ||\n\t\tcon->state == CEPH_CON_S_CLOSED);\n\n\tceph_con_reset_protocol(con);\n\n\tif (ceph_con_flag_test(con, CEPH_CON_F_LOSSYTX)) {\n\t\tdout(\"fault on LOSSYTX channel, marking CLOSED\\n\");\n\t\tcon->state = CEPH_CON_S_CLOSED;\n\t\treturn;\n\t}\n\n\t \n\tlist_splice_init(&con->out_sent, &con->out_queue);\n\n\t \n\tif (list_empty(&con->out_queue) &&\n\t    !ceph_con_flag_test(con, CEPH_CON_F_KEEPALIVE_PENDING)) {\n\t\tdout(\"fault %p setting STANDBY clearing WRITE_PENDING\\n\", con);\n\t\tceph_con_flag_clear(con, CEPH_CON_F_WRITE_PENDING);\n\t\tcon->state = CEPH_CON_S_STANDBY;\n\t} else {\n\t\t \n\t\tcon->state = CEPH_CON_S_PREOPEN;\n\t\tif (!con->delay) {\n\t\t\tcon->delay = BASE_DELAY_INTERVAL;\n\t\t} else if (con->delay < MAX_DELAY_INTERVAL) {\n\t\t\tcon->delay *= 2;\n\t\t\tif (con->delay > MAX_DELAY_INTERVAL)\n\t\t\t\tcon->delay = MAX_DELAY_INTERVAL;\n\t\t}\n\t\tceph_con_flag_set(con, CEPH_CON_F_BACKOFF);\n\t\tqueue_con(con);\n\t}\n}\n\nvoid ceph_messenger_reset_nonce(struct ceph_messenger *msgr)\n{\n\tu32 nonce = le32_to_cpu(msgr->inst.addr.nonce) + 1000000;\n\tmsgr->inst.addr.nonce = cpu_to_le32(nonce);\n\tceph_encode_my_addr(msgr);\n}\n\n \nvoid ceph_messenger_init(struct ceph_messenger *msgr,\n\t\t\t struct ceph_entity_addr *myaddr)\n{\n\tspin_lock_init(&msgr->global_seq_lock);\n\n\tif (myaddr) {\n\t\tmemcpy(&msgr->inst.addr.in_addr, &myaddr->in_addr,\n\t\t       sizeof(msgr->inst.addr.in_addr));\n\t\tceph_addr_set_port(&msgr->inst.addr, 0);\n\t}\n\n\t \n\tmsgr->inst.addr.type = CEPH_ENTITY_ADDR_TYPE_ANY;\n\n\t \n\tdo {\n\t\tget_random_bytes(&msgr->inst.addr.nonce,\n\t\t\t\t sizeof(msgr->inst.addr.nonce));\n\t} while (!msgr->inst.addr.nonce);\n\tceph_encode_my_addr(msgr);\n\n\tatomic_set(&msgr->stopping, 0);\n\twrite_pnet(&msgr->net, get_net(current->nsproxy->net_ns));\n\n\tdout(\"%s %p\\n\", __func__, msgr);\n}\n\nvoid ceph_messenger_fini(struct ceph_messenger *msgr)\n{\n\tput_net(read_pnet(&msgr->net));\n}\n\nstatic void msg_con_set(struct ceph_msg *msg, struct ceph_connection *con)\n{\n\tif (msg->con)\n\t\tmsg->con->ops->put(msg->con);\n\n\tmsg->con = con ? con->ops->get(con) : NULL;\n\tBUG_ON(msg->con != con);\n}\n\nstatic void clear_standby(struct ceph_connection *con)\n{\n\t \n\tif (con->state == CEPH_CON_S_STANDBY) {\n\t\tdout(\"clear_standby %p and ++connect_seq\\n\", con);\n\t\tcon->state = CEPH_CON_S_PREOPEN;\n\t\tcon->v1.connect_seq++;\n\t\tWARN_ON(ceph_con_flag_test(con, CEPH_CON_F_WRITE_PENDING));\n\t\tWARN_ON(ceph_con_flag_test(con, CEPH_CON_F_KEEPALIVE_PENDING));\n\t}\n}\n\n \nvoid ceph_con_send(struct ceph_connection *con, struct ceph_msg *msg)\n{\n\t \n\tmsg->hdr.src = con->msgr->inst.name;\n\tBUG_ON(msg->front.iov_len != le32_to_cpu(msg->hdr.front_len));\n\tmsg->needs_out_seq = true;\n\n\tmutex_lock(&con->mutex);\n\n\tif (con->state == CEPH_CON_S_CLOSED) {\n\t\tdout(\"con_send %p closed, dropping %p\\n\", con, msg);\n\t\tceph_msg_put(msg);\n\t\tmutex_unlock(&con->mutex);\n\t\treturn;\n\t}\n\n\tmsg_con_set(msg, con);\n\n\tBUG_ON(!list_empty(&msg->list_head));\n\tlist_add_tail(&msg->list_head, &con->out_queue);\n\tdout(\"----- %p to %s%lld %d=%s len %d+%d+%d -----\\n\", msg,\n\t     ENTITY_NAME(con->peer_name), le16_to_cpu(msg->hdr.type),\n\t     ceph_msg_type_name(le16_to_cpu(msg->hdr.type)),\n\t     le32_to_cpu(msg->hdr.front_len),\n\t     le32_to_cpu(msg->hdr.middle_len),\n\t     le32_to_cpu(msg->hdr.data_len));\n\n\tclear_standby(con);\n\tmutex_unlock(&con->mutex);\n\n\t \n\tif (!ceph_con_flag_test_and_set(con, CEPH_CON_F_WRITE_PENDING))\n\t\tqueue_con(con);\n}\nEXPORT_SYMBOL(ceph_con_send);\n\n \nvoid ceph_msg_revoke(struct ceph_msg *msg)\n{\n\tstruct ceph_connection *con = msg->con;\n\n\tif (!con) {\n\t\tdout(\"%s msg %p null con\\n\", __func__, msg);\n\t\treturn;\t\t \n\t}\n\n\tmutex_lock(&con->mutex);\n\tif (list_empty(&msg->list_head)) {\n\t\tWARN_ON(con->out_msg == msg);\n\t\tdout(\"%s con %p msg %p not linked\\n\", __func__, con, msg);\n\t\tmutex_unlock(&con->mutex);\n\t\treturn;\n\t}\n\n\tdout(\"%s con %p msg %p was linked\\n\", __func__, con, msg);\n\tmsg->hdr.seq = 0;\n\tceph_msg_remove(msg);\n\n\tif (con->out_msg == msg) {\n\t\tWARN_ON(con->state != CEPH_CON_S_OPEN);\n\t\tdout(\"%s con %p msg %p was sending\\n\", __func__, con, msg);\n\t\tif (ceph_msgr2(from_msgr(con->msgr)))\n\t\t\tceph_con_v2_revoke(con);\n\t\telse\n\t\t\tceph_con_v1_revoke(con);\n\t\tceph_msg_put(con->out_msg);\n\t\tcon->out_msg = NULL;\n\t} else {\n\t\tdout(\"%s con %p msg %p not current, out_msg %p\\n\", __func__,\n\t\t     con, msg, con->out_msg);\n\t}\n\tmutex_unlock(&con->mutex);\n}\n\n \nvoid ceph_msg_revoke_incoming(struct ceph_msg *msg)\n{\n\tstruct ceph_connection *con = msg->con;\n\n\tif (!con) {\n\t\tdout(\"%s msg %p null con\\n\", __func__, msg);\n\t\treturn;\t\t \n\t}\n\n\tmutex_lock(&con->mutex);\n\tif (con->in_msg == msg) {\n\t\tWARN_ON(con->state != CEPH_CON_S_OPEN);\n\t\tdout(\"%s con %p msg %p was recving\\n\", __func__, con, msg);\n\t\tif (ceph_msgr2(from_msgr(con->msgr)))\n\t\t\tceph_con_v2_revoke_incoming(con);\n\t\telse\n\t\t\tceph_con_v1_revoke_incoming(con);\n\t\tceph_msg_put(con->in_msg);\n\t\tcon->in_msg = NULL;\n\t} else {\n\t\tdout(\"%s con %p msg %p not current, in_msg %p\\n\", __func__,\n\t\t     con, msg, con->in_msg);\n\t}\n\tmutex_unlock(&con->mutex);\n}\n\n \nvoid ceph_con_keepalive(struct ceph_connection *con)\n{\n\tdout(\"con_keepalive %p\\n\", con);\n\tmutex_lock(&con->mutex);\n\tclear_standby(con);\n\tceph_con_flag_set(con, CEPH_CON_F_KEEPALIVE_PENDING);\n\tmutex_unlock(&con->mutex);\n\n\tif (!ceph_con_flag_test_and_set(con, CEPH_CON_F_WRITE_PENDING))\n\t\tqueue_con(con);\n}\nEXPORT_SYMBOL(ceph_con_keepalive);\n\nbool ceph_con_keepalive_expired(struct ceph_connection *con,\n\t\t\t       unsigned long interval)\n{\n\tif (interval > 0 &&\n\t    (con->peer_features & CEPH_FEATURE_MSGR_KEEPALIVE2)) {\n\t\tstruct timespec64 now;\n\t\tstruct timespec64 ts;\n\t\tktime_get_real_ts64(&now);\n\t\tjiffies_to_timespec64(interval, &ts);\n\t\tts = timespec64_add(con->last_keepalive_ack, ts);\n\t\treturn timespec64_compare(&now, &ts) >= 0;\n\t}\n\treturn false;\n}\n\nstatic struct ceph_msg_data *ceph_msg_data_add(struct ceph_msg *msg)\n{\n\tBUG_ON(msg->num_data_items >= msg->max_data_items);\n\treturn &msg->data[msg->num_data_items++];\n}\n\nstatic void ceph_msg_data_destroy(struct ceph_msg_data *data)\n{\n\tif (data->type == CEPH_MSG_DATA_PAGES && data->own_pages) {\n\t\tint num_pages = calc_pages_for(data->alignment, data->length);\n\t\tceph_release_page_vector(data->pages, num_pages);\n\t} else if (data->type == CEPH_MSG_DATA_PAGELIST) {\n\t\tceph_pagelist_release(data->pagelist);\n\t}\n}\n\nvoid ceph_msg_data_add_pages(struct ceph_msg *msg, struct page **pages,\n\t\t\t     size_t length, size_t alignment, bool own_pages)\n{\n\tstruct ceph_msg_data *data;\n\n\tBUG_ON(!pages);\n\tBUG_ON(!length);\n\n\tdata = ceph_msg_data_add(msg);\n\tdata->type = CEPH_MSG_DATA_PAGES;\n\tdata->pages = pages;\n\tdata->length = length;\n\tdata->alignment = alignment & ~PAGE_MASK;\n\tdata->own_pages = own_pages;\n\n\tmsg->data_length += length;\n}\nEXPORT_SYMBOL(ceph_msg_data_add_pages);\n\nvoid ceph_msg_data_add_pagelist(struct ceph_msg *msg,\n\t\t\t\tstruct ceph_pagelist *pagelist)\n{\n\tstruct ceph_msg_data *data;\n\n\tBUG_ON(!pagelist);\n\tBUG_ON(!pagelist->length);\n\n\tdata = ceph_msg_data_add(msg);\n\tdata->type = CEPH_MSG_DATA_PAGELIST;\n\trefcount_inc(&pagelist->refcnt);\n\tdata->pagelist = pagelist;\n\n\tmsg->data_length += pagelist->length;\n}\nEXPORT_SYMBOL(ceph_msg_data_add_pagelist);\n\n#ifdef\tCONFIG_BLOCK\nvoid ceph_msg_data_add_bio(struct ceph_msg *msg, struct ceph_bio_iter *bio_pos,\n\t\t\t   u32 length)\n{\n\tstruct ceph_msg_data *data;\n\n\tdata = ceph_msg_data_add(msg);\n\tdata->type = CEPH_MSG_DATA_BIO;\n\tdata->bio_pos = *bio_pos;\n\tdata->bio_length = length;\n\n\tmsg->data_length += length;\n}\nEXPORT_SYMBOL(ceph_msg_data_add_bio);\n#endif\t \n\nvoid ceph_msg_data_add_bvecs(struct ceph_msg *msg,\n\t\t\t     struct ceph_bvec_iter *bvec_pos)\n{\n\tstruct ceph_msg_data *data;\n\n\tdata = ceph_msg_data_add(msg);\n\tdata->type = CEPH_MSG_DATA_BVECS;\n\tdata->bvec_pos = *bvec_pos;\n\n\tmsg->data_length += bvec_pos->iter.bi_size;\n}\nEXPORT_SYMBOL(ceph_msg_data_add_bvecs);\n\nvoid ceph_msg_data_add_iter(struct ceph_msg *msg,\n\t\t\t    struct iov_iter *iter)\n{\n\tstruct ceph_msg_data *data;\n\n\tdata = ceph_msg_data_add(msg);\n\tdata->type = CEPH_MSG_DATA_ITER;\n\tdata->iter = *iter;\n\n\tmsg->data_length += iov_iter_count(&data->iter);\n}\n\n \nstruct ceph_msg *ceph_msg_new2(int type, int front_len, int max_data_items,\n\t\t\t       gfp_t flags, bool can_fail)\n{\n\tstruct ceph_msg *m;\n\n\tm = kmem_cache_zalloc(ceph_msg_cache, flags);\n\tif (m == NULL)\n\t\tgoto out;\n\n\tm->hdr.type = cpu_to_le16(type);\n\tm->hdr.priority = cpu_to_le16(CEPH_MSG_PRIO_DEFAULT);\n\tm->hdr.front_len = cpu_to_le32(front_len);\n\n\tINIT_LIST_HEAD(&m->list_head);\n\tkref_init(&m->kref);\n\n\t \n\tif (front_len) {\n\t\tm->front.iov_base = kvmalloc(front_len, flags);\n\t\tif (m->front.iov_base == NULL) {\n\t\t\tdout(\"ceph_msg_new can't allocate %d bytes\\n\",\n\t\t\t     front_len);\n\t\t\tgoto out2;\n\t\t}\n\t} else {\n\t\tm->front.iov_base = NULL;\n\t}\n\tm->front_alloc_len = m->front.iov_len = front_len;\n\n\tif (max_data_items) {\n\t\tm->data = kmalloc_array(max_data_items, sizeof(*m->data),\n\t\t\t\t\tflags);\n\t\tif (!m->data)\n\t\t\tgoto out2;\n\n\t\tm->max_data_items = max_data_items;\n\t}\n\n\tdout(\"ceph_msg_new %p front %d\\n\", m, front_len);\n\treturn m;\n\nout2:\n\tceph_msg_put(m);\nout:\n\tif (!can_fail) {\n\t\tpr_err(\"msg_new can't create type %d front %d\\n\", type,\n\t\t       front_len);\n\t\tWARN_ON(1);\n\t} else {\n\t\tdout(\"msg_new can't create type %d front %d\\n\", type,\n\t\t     front_len);\n\t}\n\treturn NULL;\n}\nEXPORT_SYMBOL(ceph_msg_new2);\n\nstruct ceph_msg *ceph_msg_new(int type, int front_len, gfp_t flags,\n\t\t\t      bool can_fail)\n{\n\treturn ceph_msg_new2(type, front_len, 0, flags, can_fail);\n}\nEXPORT_SYMBOL(ceph_msg_new);\n\n \nstatic int ceph_alloc_middle(struct ceph_connection *con, struct ceph_msg *msg)\n{\n\tint type = le16_to_cpu(msg->hdr.type);\n\tint middle_len = le32_to_cpu(msg->hdr.middle_len);\n\n\tdout(\"alloc_middle %p type %d %s middle_len %d\\n\", msg, type,\n\t     ceph_msg_type_name(type), middle_len);\n\tBUG_ON(!middle_len);\n\tBUG_ON(msg->middle);\n\n\tmsg->middle = ceph_buffer_new(middle_len, GFP_NOFS);\n\tif (!msg->middle)\n\t\treturn -ENOMEM;\n\treturn 0;\n}\n\n \nint ceph_con_in_msg_alloc(struct ceph_connection *con,\n\t\t\t  struct ceph_msg_header *hdr, int *skip)\n{\n\tint middle_len = le32_to_cpu(hdr->middle_len);\n\tstruct ceph_msg *msg;\n\tint ret = 0;\n\n\tBUG_ON(con->in_msg != NULL);\n\tBUG_ON(!con->ops->alloc_msg);\n\n\tmutex_unlock(&con->mutex);\n\tmsg = con->ops->alloc_msg(con, hdr, skip);\n\tmutex_lock(&con->mutex);\n\tif (con->state != CEPH_CON_S_OPEN) {\n\t\tif (msg)\n\t\t\tceph_msg_put(msg);\n\t\treturn -EAGAIN;\n\t}\n\tif (msg) {\n\t\tBUG_ON(*skip);\n\t\tmsg_con_set(msg, con);\n\t\tcon->in_msg = msg;\n\t} else {\n\t\t \n\t\tif (*skip)\n\t\t\treturn 0;\n\n\t\tcon->error_msg = \"error allocating memory for incoming message\";\n\t\treturn -ENOMEM;\n\t}\n\tmemcpy(&con->in_msg->hdr, hdr, sizeof(*hdr));\n\n\tif (middle_len && !con->in_msg->middle) {\n\t\tret = ceph_alloc_middle(con, con->in_msg);\n\t\tif (ret < 0) {\n\t\t\tceph_msg_put(con->in_msg);\n\t\t\tcon->in_msg = NULL;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nvoid ceph_con_get_out_msg(struct ceph_connection *con)\n{\n\tstruct ceph_msg *msg;\n\n\tBUG_ON(list_empty(&con->out_queue));\n\tmsg = list_first_entry(&con->out_queue, struct ceph_msg, list_head);\n\tWARN_ON(msg->con != con);\n\n\t \n\tlist_move_tail(&msg->list_head, &con->out_sent);\n\n\t \n\tif (msg->needs_out_seq) {\n\t\tmsg->hdr.seq = cpu_to_le64(++con->out_seq);\n\t\tmsg->needs_out_seq = false;\n\n\t\tif (con->ops->reencode_message)\n\t\t\tcon->ops->reencode_message(msg);\n\t}\n\n\t \n\tWARN_ON(con->out_msg);\n\tcon->out_msg = ceph_msg_get(msg);\n}\n\n \nstatic void ceph_msg_free(struct ceph_msg *m)\n{\n\tdout(\"%s %p\\n\", __func__, m);\n\tkvfree(m->front.iov_base);\n\tkfree(m->data);\n\tkmem_cache_free(ceph_msg_cache, m);\n}\n\nstatic void ceph_msg_release(struct kref *kref)\n{\n\tstruct ceph_msg *m = container_of(kref, struct ceph_msg, kref);\n\tint i;\n\n\tdout(\"%s %p\\n\", __func__, m);\n\tWARN_ON(!list_empty(&m->list_head));\n\n\tmsg_con_set(m, NULL);\n\n\t \n\tif (m->middle) {\n\t\tceph_buffer_put(m->middle);\n\t\tm->middle = NULL;\n\t}\n\n\tfor (i = 0; i < m->num_data_items; i++)\n\t\tceph_msg_data_destroy(&m->data[i]);\n\n\tif (m->pool)\n\t\tceph_msgpool_put(m->pool, m);\n\telse\n\t\tceph_msg_free(m);\n}\n\nstruct ceph_msg *ceph_msg_get(struct ceph_msg *msg)\n{\n\tdout(\"%s %p (was %d)\\n\", __func__, msg,\n\t     kref_read(&msg->kref));\n\tkref_get(&msg->kref);\n\treturn msg;\n}\nEXPORT_SYMBOL(ceph_msg_get);\n\nvoid ceph_msg_put(struct ceph_msg *msg)\n{\n\tdout(\"%s %p (was %d)\\n\", __func__, msg,\n\t     kref_read(&msg->kref));\n\tkref_put(&msg->kref, ceph_msg_release);\n}\nEXPORT_SYMBOL(ceph_msg_put);\n\nvoid ceph_msg_dump(struct ceph_msg *msg)\n{\n\tpr_debug(\"msg_dump %p (front_alloc_len %d length %zd)\\n\", msg,\n\t\t msg->front_alloc_len, msg->data_length);\n\tprint_hex_dump(KERN_DEBUG, \"header: \",\n\t\t       DUMP_PREFIX_OFFSET, 16, 1,\n\t\t       &msg->hdr, sizeof(msg->hdr), true);\n\tprint_hex_dump(KERN_DEBUG, \" front: \",\n\t\t       DUMP_PREFIX_OFFSET, 16, 1,\n\t\t       msg->front.iov_base, msg->front.iov_len, true);\n\tif (msg->middle)\n\t\tprint_hex_dump(KERN_DEBUG, \"middle: \",\n\t\t\t       DUMP_PREFIX_OFFSET, 16, 1,\n\t\t\t       msg->middle->vec.iov_base,\n\t\t\t       msg->middle->vec.iov_len, true);\n\tprint_hex_dump(KERN_DEBUG, \"footer: \",\n\t\t       DUMP_PREFIX_OFFSET, 16, 1,\n\t\t       &msg->footer, sizeof(msg->footer), true);\n}\nEXPORT_SYMBOL(ceph_msg_dump);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}