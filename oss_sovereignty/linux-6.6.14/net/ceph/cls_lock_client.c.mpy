{
  "module_name": "cls_lock_client.c",
  "hash_id": "630964ad06eb836e0bdebb3deb91b9eb50023f949fa6da3cd3b54082e6d98c9a",
  "original_prompt": "Ingested from linux-6.6.14/net/ceph/cls_lock_client.c",
  "human_readable_source": "\n#include <linux/ceph/ceph_debug.h>\n\n#include <linux/types.h>\n#include <linux/slab.h>\n\n#include <linux/ceph/cls_lock_client.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/libceph.h>\n\n \nint ceph_cls_lock(struct ceph_osd_client *osdc,\n\t\t  struct ceph_object_id *oid,\n\t\t  struct ceph_object_locator *oloc,\n\t\t  char *lock_name, u8 type, char *cookie,\n\t\t  char *tag, char *desc, u8 flags)\n{\n\tint lock_op_buf_size;\n\tint name_len = strlen(lock_name);\n\tint cookie_len = strlen(cookie);\n\tint tag_len = strlen(tag);\n\tint desc_len = strlen(desc);\n\tvoid *p, *end;\n\tstruct page *lock_op_page;\n\tstruct timespec64 mtime;\n\tint ret;\n\n\tlock_op_buf_size = name_len + sizeof(__le32) +\n\t\t\t   cookie_len + sizeof(__le32) +\n\t\t\t   tag_len + sizeof(__le32) +\n\t\t\t   desc_len + sizeof(__le32) +\n\t\t\t   sizeof(struct ceph_timespec) +\n\t\t\t    \n\t\t\t   sizeof(u8) + sizeof(u8) +\n\t\t\t   CEPH_ENCODING_START_BLK_LEN;\n\tif (lock_op_buf_size > PAGE_SIZE)\n\t\treturn -E2BIG;\n\n\tlock_op_page = alloc_page(GFP_NOIO);\n\tif (!lock_op_page)\n\t\treturn -ENOMEM;\n\n\tp = page_address(lock_op_page);\n\tend = p + lock_op_buf_size;\n\n\t \n\tceph_start_encoding(&p, 1, 1,\n\t\t\t    lock_op_buf_size - CEPH_ENCODING_START_BLK_LEN);\n\tceph_encode_string(&p, end, lock_name, name_len);\n\tceph_encode_8(&p, type);\n\tceph_encode_string(&p, end, cookie, cookie_len);\n\tceph_encode_string(&p, end, tag, tag_len);\n\tceph_encode_string(&p, end, desc, desc_len);\n\t \n\tmemset(&mtime, 0, sizeof(mtime));\n\tceph_encode_timespec64(p, &mtime);\n\tp += sizeof(struct ceph_timespec);\n\tceph_encode_8(&p, flags);\n\n\tdout(\"%s lock_name %s type %d cookie %s tag %s desc %s flags 0x%x\\n\",\n\t     __func__, lock_name, type, cookie, tag, desc, flags);\n\tret = ceph_osdc_call(osdc, oid, oloc, \"lock\", \"lock\",\n\t\t\t     CEPH_OSD_FLAG_WRITE, lock_op_page,\n\t\t\t     lock_op_buf_size, NULL, NULL);\n\n\tdout(\"%s: status %d\\n\", __func__, ret);\n\t__free_page(lock_op_page);\n\treturn ret;\n}\nEXPORT_SYMBOL(ceph_cls_lock);\n\n \nint ceph_cls_unlock(struct ceph_osd_client *osdc,\n\t\t    struct ceph_object_id *oid,\n\t\t    struct ceph_object_locator *oloc,\n\t\t    char *lock_name, char *cookie)\n{\n\tint unlock_op_buf_size;\n\tint name_len = strlen(lock_name);\n\tint cookie_len = strlen(cookie);\n\tvoid *p, *end;\n\tstruct page *unlock_op_page;\n\tint ret;\n\n\tunlock_op_buf_size = name_len + sizeof(__le32) +\n\t\t\t     cookie_len + sizeof(__le32) +\n\t\t\t     CEPH_ENCODING_START_BLK_LEN;\n\tif (unlock_op_buf_size > PAGE_SIZE)\n\t\treturn -E2BIG;\n\n\tunlock_op_page = alloc_page(GFP_NOIO);\n\tif (!unlock_op_page)\n\t\treturn -ENOMEM;\n\n\tp = page_address(unlock_op_page);\n\tend = p + unlock_op_buf_size;\n\n\t \n\tceph_start_encoding(&p, 1, 1,\n\t\t\t    unlock_op_buf_size - CEPH_ENCODING_START_BLK_LEN);\n\tceph_encode_string(&p, end, lock_name, name_len);\n\tceph_encode_string(&p, end, cookie, cookie_len);\n\n\tdout(\"%s lock_name %s cookie %s\\n\", __func__, lock_name, cookie);\n\tret = ceph_osdc_call(osdc, oid, oloc, \"lock\", \"unlock\",\n\t\t\t     CEPH_OSD_FLAG_WRITE, unlock_op_page,\n\t\t\t     unlock_op_buf_size, NULL, NULL);\n\n\tdout(\"%s: status %d\\n\", __func__, ret);\n\t__free_page(unlock_op_page);\n\treturn ret;\n}\nEXPORT_SYMBOL(ceph_cls_unlock);\n\n \nint ceph_cls_break_lock(struct ceph_osd_client *osdc,\n\t\t\tstruct ceph_object_id *oid,\n\t\t\tstruct ceph_object_locator *oloc,\n\t\t\tchar *lock_name, char *cookie,\n\t\t\tstruct ceph_entity_name *locker)\n{\n\tint break_op_buf_size;\n\tint name_len = strlen(lock_name);\n\tint cookie_len = strlen(cookie);\n\tstruct page *break_op_page;\n\tvoid *p, *end;\n\tint ret;\n\n\tbreak_op_buf_size = name_len + sizeof(__le32) +\n\t\t\t    cookie_len + sizeof(__le32) +\n\t\t\t    sizeof(u8) + sizeof(__le64) +\n\t\t\t    CEPH_ENCODING_START_BLK_LEN;\n\tif (break_op_buf_size > PAGE_SIZE)\n\t\treturn -E2BIG;\n\n\tbreak_op_page = alloc_page(GFP_NOIO);\n\tif (!break_op_page)\n\t\treturn -ENOMEM;\n\n\tp = page_address(break_op_page);\n\tend = p + break_op_buf_size;\n\n\t \n\tceph_start_encoding(&p, 1, 1,\n\t\t\t    break_op_buf_size - CEPH_ENCODING_START_BLK_LEN);\n\tceph_encode_string(&p, end, lock_name, name_len);\n\tceph_encode_copy(&p, locker, sizeof(*locker));\n\tceph_encode_string(&p, end, cookie, cookie_len);\n\n\tdout(\"%s lock_name %s cookie %s locker %s%llu\\n\", __func__, lock_name,\n\t     cookie, ENTITY_NAME(*locker));\n\tret = ceph_osdc_call(osdc, oid, oloc, \"lock\", \"break_lock\",\n\t\t\t     CEPH_OSD_FLAG_WRITE, break_op_page,\n\t\t\t     break_op_buf_size, NULL, NULL);\n\n\tdout(\"%s: status %d\\n\", __func__, ret);\n\t__free_page(break_op_page);\n\treturn ret;\n}\nEXPORT_SYMBOL(ceph_cls_break_lock);\n\nint ceph_cls_set_cookie(struct ceph_osd_client *osdc,\n\t\t\tstruct ceph_object_id *oid,\n\t\t\tstruct ceph_object_locator *oloc,\n\t\t\tchar *lock_name, u8 type, char *old_cookie,\n\t\t\tchar *tag, char *new_cookie)\n{\n\tint cookie_op_buf_size;\n\tint name_len = strlen(lock_name);\n\tint old_cookie_len = strlen(old_cookie);\n\tint tag_len = strlen(tag);\n\tint new_cookie_len = strlen(new_cookie);\n\tvoid *p, *end;\n\tstruct page *cookie_op_page;\n\tint ret;\n\n\tcookie_op_buf_size = name_len + sizeof(__le32) +\n\t\t\t     old_cookie_len + sizeof(__le32) +\n\t\t\t     tag_len + sizeof(__le32) +\n\t\t\t     new_cookie_len + sizeof(__le32) +\n\t\t\t     sizeof(u8) + CEPH_ENCODING_START_BLK_LEN;\n\tif (cookie_op_buf_size > PAGE_SIZE)\n\t\treturn -E2BIG;\n\n\tcookie_op_page = alloc_page(GFP_NOIO);\n\tif (!cookie_op_page)\n\t\treturn -ENOMEM;\n\n\tp = page_address(cookie_op_page);\n\tend = p + cookie_op_buf_size;\n\n\t \n\tceph_start_encoding(&p, 1, 1,\n\t\t\t    cookie_op_buf_size - CEPH_ENCODING_START_BLK_LEN);\n\tceph_encode_string(&p, end, lock_name, name_len);\n\tceph_encode_8(&p, type);\n\tceph_encode_string(&p, end, old_cookie, old_cookie_len);\n\tceph_encode_string(&p, end, tag, tag_len);\n\tceph_encode_string(&p, end, new_cookie, new_cookie_len);\n\n\tdout(\"%s lock_name %s type %d old_cookie %s tag %s new_cookie %s\\n\",\n\t     __func__, lock_name, type, old_cookie, tag, new_cookie);\n\tret = ceph_osdc_call(osdc, oid, oloc, \"lock\", \"set_cookie\",\n\t\t\t     CEPH_OSD_FLAG_WRITE, cookie_op_page,\n\t\t\t     cookie_op_buf_size, NULL, NULL);\n\n\tdout(\"%s: status %d\\n\", __func__, ret);\n\t__free_page(cookie_op_page);\n\treturn ret;\n}\nEXPORT_SYMBOL(ceph_cls_set_cookie);\n\nvoid ceph_free_lockers(struct ceph_locker *lockers, u32 num_lockers)\n{\n\tint i;\n\n\tfor (i = 0; i < num_lockers; i++)\n\t\tkfree(lockers[i].id.cookie);\n\tkfree(lockers);\n}\nEXPORT_SYMBOL(ceph_free_lockers);\n\nstatic int decode_locker(void **p, void *end, struct ceph_locker *locker)\n{\n\tu8 struct_v;\n\tu32 len;\n\tchar *s;\n\tint ret;\n\n\tret = ceph_start_decoding(p, end, 1, \"locker_id_t\", &struct_v, &len);\n\tif (ret)\n\t\treturn ret;\n\n\tceph_decode_copy(p, &locker->id.name, sizeof(locker->id.name));\n\ts = ceph_extract_encoded_string(p, end, NULL, GFP_NOIO);\n\tif (IS_ERR(s))\n\t\treturn PTR_ERR(s);\n\n\tlocker->id.cookie = s;\n\n\tret = ceph_start_decoding(p, end, 1, \"locker_info_t\", &struct_v, &len);\n\tif (ret)\n\t\treturn ret;\n\n\t*p += sizeof(struct ceph_timespec);  \n\n\tret = ceph_decode_entity_addr(p, end, &locker->info.addr);\n\tif (ret)\n\t\treturn ret;\n\n\tlen = ceph_decode_32(p);\n\t*p += len;  \n\n\tdout(\"%s %s%llu cookie %s addr %s\\n\", __func__,\n\t     ENTITY_NAME(locker->id.name), locker->id.cookie,\n\t     ceph_pr_addr(&locker->info.addr));\n\treturn 0;\n}\n\nstatic int decode_lockers(void **p, void *end, u8 *type, char **tag,\n\t\t\t  struct ceph_locker **lockers, u32 *num_lockers)\n{\n\tu8 struct_v;\n\tu32 struct_len;\n\tchar *s;\n\tint i;\n\tint ret;\n\n\tret = ceph_start_decoding(p, end, 1, \"cls_lock_get_info_reply\",\n\t\t\t\t  &struct_v, &struct_len);\n\tif (ret)\n\t\treturn ret;\n\n\t*num_lockers = ceph_decode_32(p);\n\t*lockers = kcalloc(*num_lockers, sizeof(**lockers), GFP_NOIO);\n\tif (!*lockers)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < *num_lockers; i++) {\n\t\tret = decode_locker(p, end, *lockers + i);\n\t\tif (ret)\n\t\t\tgoto err_free_lockers;\n\t}\n\n\t*type = ceph_decode_8(p);\n\ts = ceph_extract_encoded_string(p, end, NULL, GFP_NOIO);\n\tif (IS_ERR(s)) {\n\t\tret = PTR_ERR(s);\n\t\tgoto err_free_lockers;\n\t}\n\n\t*tag = s;\n\treturn 0;\n\nerr_free_lockers:\n\tceph_free_lockers(*lockers, *num_lockers);\n\treturn ret;\n}\n\n \nint ceph_cls_lock_info(struct ceph_osd_client *osdc,\n\t\t       struct ceph_object_id *oid,\n\t\t       struct ceph_object_locator *oloc,\n\t\t       char *lock_name, u8 *type, char **tag,\n\t\t       struct ceph_locker **lockers, u32 *num_lockers)\n{\n\tint get_info_op_buf_size;\n\tint name_len = strlen(lock_name);\n\tstruct page *get_info_op_page, *reply_page;\n\tsize_t reply_len = PAGE_SIZE;\n\tvoid *p, *end;\n\tint ret;\n\n\tget_info_op_buf_size = name_len + sizeof(__le32) +\n\t\t\t       CEPH_ENCODING_START_BLK_LEN;\n\tif (get_info_op_buf_size > PAGE_SIZE)\n\t\treturn -E2BIG;\n\n\tget_info_op_page = alloc_page(GFP_NOIO);\n\tif (!get_info_op_page)\n\t\treturn -ENOMEM;\n\n\treply_page = alloc_page(GFP_NOIO);\n\tif (!reply_page) {\n\t\t__free_page(get_info_op_page);\n\t\treturn -ENOMEM;\n\t}\n\n\tp = page_address(get_info_op_page);\n\tend = p + get_info_op_buf_size;\n\n\t \n\tceph_start_encoding(&p, 1, 1,\n\t\t\t    get_info_op_buf_size - CEPH_ENCODING_START_BLK_LEN);\n\tceph_encode_string(&p, end, lock_name, name_len);\n\n\tdout(\"%s lock_name %s\\n\", __func__, lock_name);\n\tret = ceph_osdc_call(osdc, oid, oloc, \"lock\", \"get_info\",\n\t\t\t     CEPH_OSD_FLAG_READ, get_info_op_page,\n\t\t\t     get_info_op_buf_size, &reply_page, &reply_len);\n\n\tdout(\"%s: status %d\\n\", __func__, ret);\n\tif (ret >= 0) {\n\t\tp = page_address(reply_page);\n\t\tend = p + reply_len;\n\n\t\tret = decode_lockers(&p, end, type, tag, lockers, num_lockers);\n\t}\n\n\t__free_page(get_info_op_page);\n\t__free_page(reply_page);\n\treturn ret;\n}\nEXPORT_SYMBOL(ceph_cls_lock_info);\n\nint ceph_cls_assert_locked(struct ceph_osd_request *req, int which,\n\t\t\t   char *lock_name, u8 type, char *cookie, char *tag)\n{\n\tint assert_op_buf_size;\n\tint name_len = strlen(lock_name);\n\tint cookie_len = strlen(cookie);\n\tint tag_len = strlen(tag);\n\tstruct page **pages;\n\tvoid *p, *end;\n\tint ret;\n\n\tassert_op_buf_size = name_len + sizeof(__le32) +\n\t\t\t     cookie_len + sizeof(__le32) +\n\t\t\t     tag_len + sizeof(__le32) +\n\t\t\t     sizeof(u8) + CEPH_ENCODING_START_BLK_LEN;\n\tif (assert_op_buf_size > PAGE_SIZE)\n\t\treturn -E2BIG;\n\n\tret = osd_req_op_cls_init(req, which, \"lock\", \"assert_locked\");\n\tif (ret)\n\t\treturn ret;\n\n\tpages = ceph_alloc_page_vector(1, GFP_NOIO);\n\tif (IS_ERR(pages))\n\t\treturn PTR_ERR(pages);\n\n\tp = page_address(pages[0]);\n\tend = p + assert_op_buf_size;\n\n\t \n\tceph_start_encoding(&p, 1, 1,\n\t\t\t    assert_op_buf_size - CEPH_ENCODING_START_BLK_LEN);\n\tceph_encode_string(&p, end, lock_name, name_len);\n\tceph_encode_8(&p, type);\n\tceph_encode_string(&p, end, cookie, cookie_len);\n\tceph_encode_string(&p, end, tag, tag_len);\n\tWARN_ON(p != end);\n\n\tosd_req_op_cls_request_data_pages(req, which, pages, assert_op_buf_size,\n\t\t\t\t\t  0, false, true);\n\treturn 0;\n}\nEXPORT_SYMBOL(ceph_cls_assert_locked);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}