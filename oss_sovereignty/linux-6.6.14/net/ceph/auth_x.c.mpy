{
  "module_name": "auth_x.c",
  "hash_id": "0bc7d4ceeece9c165d358932caca42cbfa1373724e2539cf91d34f72a4c1cf37",
  "original_prompt": "Ingested from linux-6.6.14/net/ceph/auth_x.c",
  "human_readable_source": "\n\n#include <linux/ceph/ceph_debug.h>\n\n#include <linux/err.h>\n#include <linux/module.h>\n#include <linux/random.h>\n#include <linux/slab.h>\n\n#include <linux/ceph/decode.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/ceph_features.h>\n#include <linux/ceph/libceph.h>\n#include <linux/ceph/messenger.h>\n\n#include \"crypto.h\"\n#include \"auth_x.h\"\n#include \"auth_x_protocol.h\"\n\nstatic void ceph_x_validate_tickets(struct ceph_auth_client *ac, int *pneed);\n\nstatic int ceph_x_is_authenticated(struct ceph_auth_client *ac)\n{\n\tstruct ceph_x_info *xi = ac->private;\n\tint missing;\n\tint need;   \n\n\tceph_x_validate_tickets(ac, &need);\n\tmissing = ac->want_keys & ~xi->have_keys;\n\tWARN_ON((need & missing) != missing);\n\tdout(\"%s want 0x%x have 0x%x missing 0x%x -> %d\\n\", __func__,\n\t     ac->want_keys, xi->have_keys, missing, !missing);\n\treturn !missing;\n}\n\nstatic int ceph_x_should_authenticate(struct ceph_auth_client *ac)\n{\n\tstruct ceph_x_info *xi = ac->private;\n\tint need;\n\n\tceph_x_validate_tickets(ac, &need);\n\tdout(\"%s want 0x%x have 0x%x need 0x%x -> %d\\n\", __func__,\n\t     ac->want_keys, xi->have_keys, need, !!need);\n\treturn !!need;\n}\n\nstatic int ceph_x_encrypt_offset(void)\n{\n\treturn sizeof(u32) + sizeof(struct ceph_x_encrypt_header);\n}\n\nstatic int ceph_x_encrypt_buflen(int ilen)\n{\n\treturn ceph_x_encrypt_offset() + ilen + 16;\n}\n\nstatic int ceph_x_encrypt(struct ceph_crypto_key *secret, void *buf,\n\t\t\t  int buf_len, int plaintext_len)\n{\n\tstruct ceph_x_encrypt_header *hdr = buf + sizeof(u32);\n\tint ciphertext_len;\n\tint ret;\n\n\thdr->struct_v = 1;\n\thdr->magic = cpu_to_le64(CEPHX_ENC_MAGIC);\n\n\tret = ceph_crypt(secret, true, buf + sizeof(u32), buf_len - sizeof(u32),\n\t\t\t plaintext_len + sizeof(struct ceph_x_encrypt_header),\n\t\t\t &ciphertext_len);\n\tif (ret)\n\t\treturn ret;\n\n\tceph_encode_32(&buf, ciphertext_len);\n\treturn sizeof(u32) + ciphertext_len;\n}\n\nstatic int __ceph_x_decrypt(struct ceph_crypto_key *secret, void *p,\n\t\t\t    int ciphertext_len)\n{\n\tstruct ceph_x_encrypt_header *hdr = p;\n\tint plaintext_len;\n\tint ret;\n\n\tret = ceph_crypt(secret, false, p, ciphertext_len, ciphertext_len,\n\t\t\t &plaintext_len);\n\tif (ret)\n\t\treturn ret;\n\n\tif (le64_to_cpu(hdr->magic) != CEPHX_ENC_MAGIC) {\n\t\tpr_err(\"%s bad magic\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\treturn plaintext_len - sizeof(*hdr);\n}\n\nstatic int ceph_x_decrypt(struct ceph_crypto_key *secret, void **p, void *end)\n{\n\tint ciphertext_len;\n\tint ret;\n\n\tceph_decode_32_safe(p, end, ciphertext_len, e_inval);\n\tceph_decode_need(p, end, ciphertext_len, e_inval);\n\n\tret = __ceph_x_decrypt(secret, *p, ciphertext_len);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t*p += ciphertext_len;\n\treturn ret;\n\ne_inval:\n\treturn -EINVAL;\n}\n\n \nstatic struct ceph_x_ticket_handler *\nget_ticket_handler(struct ceph_auth_client *ac, int service)\n{\n\tstruct ceph_x_ticket_handler *th;\n\tstruct ceph_x_info *xi = ac->private;\n\tstruct rb_node *parent = NULL, **p = &xi->ticket_handlers.rb_node;\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\tth = rb_entry(parent, struct ceph_x_ticket_handler, node);\n\t\tif (service < th->service)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (service > th->service)\n\t\t\tp = &(*p)->rb_right;\n\t\telse\n\t\t\treturn th;\n\t}\n\n\t \n\tth = kzalloc(sizeof(*th), GFP_NOFS);\n\tif (!th)\n\t\treturn ERR_PTR(-ENOMEM);\n\tth->service = service;\n\trb_link_node(&th->node, parent, p);\n\trb_insert_color(&th->node, &xi->ticket_handlers);\n\treturn th;\n}\n\nstatic void remove_ticket_handler(struct ceph_auth_client *ac,\n\t\t\t\t  struct ceph_x_ticket_handler *th)\n{\n\tstruct ceph_x_info *xi = ac->private;\n\n\tdout(\"remove_ticket_handler %p %d\\n\", th, th->service);\n\trb_erase(&th->node, &xi->ticket_handlers);\n\tceph_crypto_key_destroy(&th->session_key);\n\tif (th->ticket_blob)\n\t\tceph_buffer_put(th->ticket_blob);\n\tkfree(th);\n}\n\nstatic int process_one_ticket(struct ceph_auth_client *ac,\n\t\t\t      struct ceph_crypto_key *secret,\n\t\t\t      void **p, void *end)\n{\n\tstruct ceph_x_info *xi = ac->private;\n\tint type;\n\tu8 tkt_struct_v, blob_struct_v;\n\tstruct ceph_x_ticket_handler *th;\n\tvoid *dp, *dend;\n\tint dlen;\n\tchar is_enc;\n\tstruct timespec64 validity;\n\tvoid *tp, *tpend;\n\tvoid **ptp;\n\tstruct ceph_crypto_key new_session_key = { 0 };\n\tstruct ceph_buffer *new_ticket_blob;\n\ttime64_t new_expires, new_renew_after;\n\tu64 new_secret_id;\n\tint ret;\n\n\tceph_decode_need(p, end, sizeof(u32) + 1, bad);\n\n\ttype = ceph_decode_32(p);\n\tdout(\" ticket type %d %s\\n\", type, ceph_entity_type_name(type));\n\n\ttkt_struct_v = ceph_decode_8(p);\n\tif (tkt_struct_v != 1)\n\t\tgoto bad;\n\n\tth = get_ticket_handler(ac, type);\n\tif (IS_ERR(th)) {\n\t\tret = PTR_ERR(th);\n\t\tgoto out;\n\t}\n\n\t \n\tdp = *p + ceph_x_encrypt_offset();\n\tret = ceph_x_decrypt(secret, p, end);\n\tif (ret < 0)\n\t\tgoto out;\n\tdout(\" decrypted %d bytes\\n\", ret);\n\tdend = dp + ret;\n\n\tceph_decode_8_safe(&dp, dend, tkt_struct_v, bad);\n\tif (tkt_struct_v != 1)\n\t\tgoto bad;\n\n\tret = ceph_crypto_key_decode(&new_session_key, &dp, dend);\n\tif (ret)\n\t\tgoto out;\n\n\tceph_decode_need(&dp, dend, sizeof(struct ceph_timespec), bad);\n\tceph_decode_timespec64(&validity, dp);\n\tdp += sizeof(struct ceph_timespec);\n\tnew_expires = ktime_get_real_seconds() + validity.tv_sec;\n\tnew_renew_after = new_expires - (validity.tv_sec / 4);\n\tdout(\" expires=%llu renew_after=%llu\\n\", new_expires,\n\t     new_renew_after);\n\n\t \n\tceph_decode_8_safe(p, end, is_enc, bad);\n\tif (is_enc) {\n\t\t \n\t\ttp = *p + ceph_x_encrypt_offset();\n\t\tret = ceph_x_decrypt(&th->session_key, p, end);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tdout(\" encrypted ticket, decrypted %d bytes\\n\", ret);\n\t\tptp = &tp;\n\t\ttpend = tp + ret;\n\t} else {\n\t\t \n\t\tptp = p;\n\t\ttpend = end;\n\t}\n\tceph_decode_32_safe(ptp, tpend, dlen, bad);\n\tdout(\" ticket blob is %d bytes\\n\", dlen);\n\tceph_decode_need(ptp, tpend, 1 + sizeof(u64), bad);\n\tblob_struct_v = ceph_decode_8(ptp);\n\tif (blob_struct_v != 1)\n\t\tgoto bad;\n\n\tnew_secret_id = ceph_decode_64(ptp);\n\tret = ceph_decode_buffer(&new_ticket_blob, ptp, tpend);\n\tif (ret)\n\t\tgoto out;\n\n\t \n\tceph_crypto_key_destroy(&th->session_key);\n\tif (th->ticket_blob)\n\t\tceph_buffer_put(th->ticket_blob);\n\tth->session_key = new_session_key;\n\tth->ticket_blob = new_ticket_blob;\n\tth->secret_id = new_secret_id;\n\tth->expires = new_expires;\n\tth->renew_after = new_renew_after;\n\tth->have_key = true;\n\tdout(\" got ticket service %d (%s) secret_id %lld len %d\\n\",\n\t     type, ceph_entity_type_name(type), th->secret_id,\n\t     (int)th->ticket_blob->vec.iov_len);\n\txi->have_keys |= th->service;\n\treturn 0;\n\nbad:\n\tret = -EINVAL;\nout:\n\tceph_crypto_key_destroy(&new_session_key);\n\treturn ret;\n}\n\nstatic int ceph_x_proc_ticket_reply(struct ceph_auth_client *ac,\n\t\t\t\t    struct ceph_crypto_key *secret,\n\t\t\t\t    void **p, void *end)\n{\n\tu8 reply_struct_v;\n\tu32 num;\n\tint ret;\n\n\tceph_decode_8_safe(p, end, reply_struct_v, bad);\n\tif (reply_struct_v != 1)\n\t\treturn -EINVAL;\n\n\tceph_decode_32_safe(p, end, num, bad);\n\tdout(\"%d tickets\\n\", num);\n\n\twhile (num--) {\n\t\tret = process_one_ticket(ac, secret, p, end);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n\nbad:\n\treturn -EINVAL;\n}\n\n \nstatic int encrypt_authorizer(struct ceph_x_authorizer *au,\n\t\t\t      u64 *server_challenge)\n{\n\tstruct ceph_x_authorize_a *msg_a;\n\tstruct ceph_x_authorize_b *msg_b;\n\tvoid *p, *end;\n\tint ret;\n\n\tmsg_a = au->buf->vec.iov_base;\n\tWARN_ON(msg_a->ticket_blob.secret_id != cpu_to_le64(au->secret_id));\n\tp = (void *)(msg_a + 1) + le32_to_cpu(msg_a->ticket_blob.blob_len);\n\tend = au->buf->vec.iov_base + au->buf->vec.iov_len;\n\n\tmsg_b = p + ceph_x_encrypt_offset();\n\tmsg_b->struct_v = 2;\n\tmsg_b->nonce = cpu_to_le64(au->nonce);\n\tif (server_challenge) {\n\t\tmsg_b->have_challenge = 1;\n\t\tmsg_b->server_challenge_plus_one =\n\t\t    cpu_to_le64(*server_challenge + 1);\n\t} else {\n\t\tmsg_b->have_challenge = 0;\n\t\tmsg_b->server_challenge_plus_one = 0;\n\t}\n\n\tret = ceph_x_encrypt(&au->session_key, p, end - p, sizeof(*msg_b));\n\tif (ret < 0)\n\t\treturn ret;\n\n\tp += ret;\n\tif (server_challenge) {\n\t\tWARN_ON(p != end);\n\t} else {\n\t\tWARN_ON(p > end);\n\t\tau->buf->vec.iov_len = p - au->buf->vec.iov_base;\n\t}\n\n\treturn 0;\n}\n\nstatic void ceph_x_authorizer_cleanup(struct ceph_x_authorizer *au)\n{\n\tceph_crypto_key_destroy(&au->session_key);\n\tif (au->buf) {\n\t\tceph_buffer_put(au->buf);\n\t\tau->buf = NULL;\n\t}\n}\n\nstatic int ceph_x_build_authorizer(struct ceph_auth_client *ac,\n\t\t\t\t   struct ceph_x_ticket_handler *th,\n\t\t\t\t   struct ceph_x_authorizer *au)\n{\n\tint maxlen;\n\tstruct ceph_x_authorize_a *msg_a;\n\tstruct ceph_x_authorize_b *msg_b;\n\tint ret;\n\tint ticket_blob_len =\n\t\t(th->ticket_blob ? th->ticket_blob->vec.iov_len : 0);\n\n\tdout(\"build_authorizer for %s %p\\n\",\n\t     ceph_entity_type_name(th->service), au);\n\n\tceph_crypto_key_destroy(&au->session_key);\n\tret = ceph_crypto_key_clone(&au->session_key, &th->session_key);\n\tif (ret)\n\t\tgoto out_au;\n\n\tmaxlen = sizeof(*msg_a) + ticket_blob_len +\n\t\tceph_x_encrypt_buflen(sizeof(*msg_b));\n\tdout(\"  need len %d\\n\", maxlen);\n\tif (au->buf && au->buf->alloc_len < maxlen) {\n\t\tceph_buffer_put(au->buf);\n\t\tau->buf = NULL;\n\t}\n\tif (!au->buf) {\n\t\tau->buf = ceph_buffer_new(maxlen, GFP_NOFS);\n\t\tif (!au->buf) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out_au;\n\t\t}\n\t}\n\tau->service = th->service;\n\tWARN_ON(!th->secret_id);\n\tau->secret_id = th->secret_id;\n\n\tmsg_a = au->buf->vec.iov_base;\n\tmsg_a->struct_v = 1;\n\tmsg_a->global_id = cpu_to_le64(ac->global_id);\n\tmsg_a->service_id = cpu_to_le32(th->service);\n\tmsg_a->ticket_blob.struct_v = 1;\n\tmsg_a->ticket_blob.secret_id = cpu_to_le64(th->secret_id);\n\tmsg_a->ticket_blob.blob_len = cpu_to_le32(ticket_blob_len);\n\tif (ticket_blob_len) {\n\t\tmemcpy(msg_a->ticket_blob.blob, th->ticket_blob->vec.iov_base,\n\t\t       th->ticket_blob->vec.iov_len);\n\t}\n\tdout(\" th %p secret_id %lld %lld\\n\", th, th->secret_id,\n\t     le64_to_cpu(msg_a->ticket_blob.secret_id));\n\n\tget_random_bytes(&au->nonce, sizeof(au->nonce));\n\tret = encrypt_authorizer(au, NULL);\n\tif (ret) {\n\t\tpr_err(\"failed to encrypt authorizer: %d\", ret);\n\t\tgoto out_au;\n\t}\n\n\tdout(\" built authorizer nonce %llx len %d\\n\", au->nonce,\n\t     (int)au->buf->vec.iov_len);\n\treturn 0;\n\nout_au:\n\tceph_x_authorizer_cleanup(au);\n\treturn ret;\n}\n\nstatic int ceph_x_encode_ticket(struct ceph_x_ticket_handler *th,\n\t\t\t\tvoid **p, void *end)\n{\n\tceph_decode_need(p, end, 1 + sizeof(u64), bad);\n\tceph_encode_8(p, 1);\n\tceph_encode_64(p, th->secret_id);\n\tif (th->ticket_blob) {\n\t\tconst char *buf = th->ticket_blob->vec.iov_base;\n\t\tu32 len = th->ticket_blob->vec.iov_len;\n\n\t\tceph_encode_32_safe(p, end, len, bad);\n\t\tceph_encode_copy_safe(p, end, buf, len, bad);\n\t} else {\n\t\tceph_encode_32_safe(p, end, 0, bad);\n\t}\n\n\treturn 0;\nbad:\n\treturn -ERANGE;\n}\n\nstatic bool need_key(struct ceph_x_ticket_handler *th)\n{\n\tif (!th->have_key)\n\t\treturn true;\n\n\treturn ktime_get_real_seconds() >= th->renew_after;\n}\n\nstatic bool have_key(struct ceph_x_ticket_handler *th)\n{\n\tif (th->have_key && ktime_get_real_seconds() >= th->expires) {\n\t\tdout(\"ticket %d (%s) secret_id %llu expired\\n\", th->service,\n\t\t     ceph_entity_type_name(th->service), th->secret_id);\n\t\tth->have_key = false;\n\t}\n\n\treturn th->have_key;\n}\n\nstatic void ceph_x_validate_tickets(struct ceph_auth_client *ac, int *pneed)\n{\n\tint want = ac->want_keys;\n\tstruct ceph_x_info *xi = ac->private;\n\tint service;\n\n\t*pneed = ac->want_keys & ~(xi->have_keys);\n\n\tfor (service = 1; service <= want; service <<= 1) {\n\t\tstruct ceph_x_ticket_handler *th;\n\n\t\tif (!(ac->want_keys & service))\n\t\t\tcontinue;\n\n\t\tif (*pneed & service)\n\t\t\tcontinue;\n\n\t\tth = get_ticket_handler(ac, service);\n\t\tif (IS_ERR(th)) {\n\t\t\t*pneed |= service;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (need_key(th))\n\t\t\t*pneed |= service;\n\t\tif (!have_key(th))\n\t\t\txi->have_keys &= ~service;\n\t}\n}\n\nstatic int ceph_x_build_request(struct ceph_auth_client *ac,\n\t\t\t\tvoid *buf, void *end)\n{\n\tstruct ceph_x_info *xi = ac->private;\n\tint need;\n\tstruct ceph_x_request_header *head = buf;\n\tvoid *p;\n\tint ret;\n\tstruct ceph_x_ticket_handler *th =\n\t\tget_ticket_handler(ac, CEPH_ENTITY_TYPE_AUTH);\n\n\tif (IS_ERR(th))\n\t\treturn PTR_ERR(th);\n\n\tceph_x_validate_tickets(ac, &need);\n\tdout(\"%s want 0x%x have 0x%x need 0x%x\\n\", __func__, ac->want_keys,\n\t     xi->have_keys, need);\n\n\tif (need & CEPH_ENTITY_TYPE_AUTH) {\n\t\tstruct ceph_x_authenticate *auth = (void *)(head + 1);\n\t\tvoid *enc_buf = xi->auth_authorizer.enc_buf;\n\t\tstruct ceph_x_challenge_blob *blob = enc_buf +\n\t\t\t\t\t\t\tceph_x_encrypt_offset();\n\t\tu64 *u;\n\n\t\tp = auth + 1;\n\t\tif (p > end)\n\t\t\treturn -ERANGE;\n\n\t\tdout(\" get_auth_session_key\\n\");\n\t\thead->op = cpu_to_le16(CEPHX_GET_AUTH_SESSION_KEY);\n\n\t\t \n\t\tget_random_bytes(&auth->client_challenge, sizeof(u64));\n\t\tblob->client_challenge = auth->client_challenge;\n\t\tblob->server_challenge = cpu_to_le64(xi->server_challenge);\n\t\tret = ceph_x_encrypt(&xi->secret, enc_buf, CEPHX_AU_ENC_BUF_LEN,\n\t\t\t\t     sizeof(*blob));\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tauth->struct_v = 3;   \n\t\tauth->key = 0;\n\t\tfor (u = (u64 *)enc_buf; u + 1 <= (u64 *)(enc_buf + ret); u++)\n\t\t\tauth->key ^= *(__le64 *)u;\n\t\tdout(\" server_challenge %llx client_challenge %llx key %llx\\n\",\n\t\t     xi->server_challenge, le64_to_cpu(auth->client_challenge),\n\t\t     le64_to_cpu(auth->key));\n\n\t\t \n\t\tret = ceph_x_encode_ticket(th, &p, end);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\t \n\t\tneed = ac->want_keys & ~CEPH_ENTITY_TYPE_AUTH;\n\t\tWARN_ON(!need);\n\t\tceph_encode_32_safe(&p, end, need, e_range);\n\t\treturn p - buf;\n\t}\n\n\tif (need) {\n\t\tdout(\" get_principal_session_key\\n\");\n\t\tret = ceph_x_build_authorizer(ac, th, &xi->auth_authorizer);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tp = buf;\n\t\tceph_encode_16_safe(&p, end, CEPHX_GET_PRINCIPAL_SESSION_KEY,\n\t\t\t\t    e_range);\n\t\tceph_encode_copy_safe(&p, end,\n\t\t\txi->auth_authorizer.buf->vec.iov_base,\n\t\t\txi->auth_authorizer.buf->vec.iov_len, e_range);\n\t\tceph_encode_8_safe(&p, end, 1, e_range);\n\t\tceph_encode_32_safe(&p, end, need, e_range);\n\t\treturn p - buf;\n\t}\n\n\treturn 0;\n\ne_range:\n\treturn -ERANGE;\n}\n\nstatic int decode_con_secret(void **p, void *end, u8 *con_secret,\n\t\t\t     int *con_secret_len)\n{\n\tint len;\n\n\tceph_decode_32_safe(p, end, len, bad);\n\tceph_decode_need(p, end, len, bad);\n\n\tdout(\"%s len %d\\n\", __func__, len);\n\tif (con_secret) {\n\t\tif (len > CEPH_MAX_CON_SECRET_LEN) {\n\t\t\tpr_err(\"connection secret too big %d\\n\", len);\n\t\t\tgoto bad_memzero;\n\t\t}\n\t\tmemcpy(con_secret, *p, len);\n\t\t*con_secret_len = len;\n\t}\n\tmemzero_explicit(*p, len);\n\t*p += len;\n\treturn 0;\n\nbad_memzero:\n\tmemzero_explicit(*p, len);\nbad:\n\tpr_err(\"failed to decode connection secret\\n\");\n\treturn -EINVAL;\n}\n\nstatic int handle_auth_session_key(struct ceph_auth_client *ac, u64 global_id,\n\t\t\t\t   void **p, void *end,\n\t\t\t\t   u8 *session_key, int *session_key_len,\n\t\t\t\t   u8 *con_secret, int *con_secret_len)\n{\n\tstruct ceph_x_info *xi = ac->private;\n\tstruct ceph_x_ticket_handler *th;\n\tvoid *dp, *dend;\n\tint len;\n\tint ret;\n\n\t \n\tret = ceph_x_proc_ticket_reply(ac, &xi->secret, p, end);\n\tif (ret)\n\t\treturn ret;\n\n\tceph_auth_set_global_id(ac, global_id);\n\tif (*p == end) {\n\t\t \n\t\tWARN_ON(session_key || con_secret);\n\t\treturn 0;\n\t}\n\n\tth = get_ticket_handler(ac, CEPH_ENTITY_TYPE_AUTH);\n\tif (IS_ERR(th))\n\t\treturn PTR_ERR(th);\n\n\tif (session_key) {\n\t\tmemcpy(session_key, th->session_key.key, th->session_key.len);\n\t\t*session_key_len = th->session_key.len;\n\t}\n\n\t \n\tceph_decode_32_safe(p, end, len, e_inval);\n\tdout(\"%s connection secret blob len %d\\n\", __func__, len);\n\tif (len > 0) {\n\t\tdp = *p + ceph_x_encrypt_offset();\n\t\tret = ceph_x_decrypt(&th->session_key, p, *p + len);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tdout(\"%s decrypted %d bytes\\n\", __func__, ret);\n\t\tdend = dp + ret;\n\n\t\tret = decode_con_secret(&dp, dend, con_secret, con_secret_len);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\tceph_decode_32_safe(p, end, len, e_inval);\n\tdout(\"%s service tickets blob len %d\\n\", __func__, len);\n\tif (len > 0) {\n\t\tret = ceph_x_proc_ticket_reply(ac, &th->session_key,\n\t\t\t\t\t       p, *p + len);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n\ne_inval:\n\treturn -EINVAL;\n}\n\nstatic int ceph_x_handle_reply(struct ceph_auth_client *ac, u64 global_id,\n\t\t\t       void *buf, void *end,\n\t\t\t       u8 *session_key, int *session_key_len,\n\t\t\t       u8 *con_secret, int *con_secret_len)\n{\n\tstruct ceph_x_info *xi = ac->private;\n\tstruct ceph_x_ticket_handler *th;\n\tint len = end - buf;\n\tint result;\n\tvoid *p;\n\tint op;\n\tint ret;\n\n\tif (xi->starting) {\n\t\t \n\t\tstruct ceph_x_server_challenge *sc = buf;\n\n\t\tif (len != sizeof(*sc))\n\t\t\treturn -EINVAL;\n\t\txi->server_challenge = le64_to_cpu(sc->server_challenge);\n\t\tdout(\"handle_reply got server challenge %llx\\n\",\n\t\t     xi->server_challenge);\n\t\txi->starting = false;\n\t\txi->have_keys &= ~CEPH_ENTITY_TYPE_AUTH;\n\t\treturn -EAGAIN;\n\t}\n\n\tp = buf;\n\tceph_decode_16_safe(&p, end, op, e_inval);\n\tceph_decode_32_safe(&p, end, result, e_inval);\n\tdout(\"handle_reply op %d result %d\\n\", op, result);\n\tswitch (op) {\n\tcase CEPHX_GET_AUTH_SESSION_KEY:\n\t\t \n\t\tret = handle_auth_session_key(ac, global_id, &p, end,\n\t\t\t\t\t      session_key, session_key_len,\n\t\t\t\t\t      con_secret, con_secret_len);\n\t\tbreak;\n\n\tcase CEPHX_GET_PRINCIPAL_SESSION_KEY:\n\t\tth = get_ticket_handler(ac, CEPH_ENTITY_TYPE_AUTH);\n\t\tif (IS_ERR(th))\n\t\t\treturn PTR_ERR(th);\n\n\t\t \n\t\tret = ceph_x_proc_ticket_reply(ac, &th->session_key, &p, end);\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tif (ret)\n\t\treturn ret;\n\tif (ac->want_keys == xi->have_keys)\n\t\treturn 0;\n\treturn -EAGAIN;\n\ne_inval:\n\treturn -EINVAL;\n}\n\nstatic void ceph_x_destroy_authorizer(struct ceph_authorizer *a)\n{\n\tstruct ceph_x_authorizer *au = (void *)a;\n\n\tceph_x_authorizer_cleanup(au);\n\tkfree(au);\n}\n\nstatic int ceph_x_create_authorizer(\n\tstruct ceph_auth_client *ac, int peer_type,\n\tstruct ceph_auth_handshake *auth)\n{\n\tstruct ceph_x_authorizer *au;\n\tstruct ceph_x_ticket_handler *th;\n\tint ret;\n\n\tth = get_ticket_handler(ac, peer_type);\n\tif (IS_ERR(th))\n\t\treturn PTR_ERR(th);\n\n\tau = kzalloc(sizeof(*au), GFP_NOFS);\n\tif (!au)\n\t\treturn -ENOMEM;\n\n\tau->base.destroy = ceph_x_destroy_authorizer;\n\n\tret = ceph_x_build_authorizer(ac, th, au);\n\tif (ret) {\n\t\tkfree(au);\n\t\treturn ret;\n\t}\n\n\tauth->authorizer = (struct ceph_authorizer *) au;\n\tauth->authorizer_buf = au->buf->vec.iov_base;\n\tauth->authorizer_buf_len = au->buf->vec.iov_len;\n\tauth->authorizer_reply_buf = au->enc_buf;\n\tauth->authorizer_reply_buf_len = CEPHX_AU_ENC_BUF_LEN;\n\tauth->sign_message = ac->ops->sign_message;\n\tauth->check_message_signature = ac->ops->check_message_signature;\n\n\treturn 0;\n}\n\nstatic int ceph_x_update_authorizer(\n\tstruct ceph_auth_client *ac, int peer_type,\n\tstruct ceph_auth_handshake *auth)\n{\n\tstruct ceph_x_authorizer *au;\n\tstruct ceph_x_ticket_handler *th;\n\n\tth = get_ticket_handler(ac, peer_type);\n\tif (IS_ERR(th))\n\t\treturn PTR_ERR(th);\n\n\tau = (struct ceph_x_authorizer *)auth->authorizer;\n\tif (au->secret_id < th->secret_id) {\n\t\tdout(\"ceph_x_update_authorizer service %u secret %llu < %llu\\n\",\n\t\t     au->service, au->secret_id, th->secret_id);\n\t\treturn ceph_x_build_authorizer(ac, th, au);\n\t}\n\treturn 0;\n}\n\n \nstatic int decrypt_authorizer_challenge(struct ceph_crypto_key *secret,\n\t\t\t\t\tvoid *challenge, int challenge_len,\n\t\t\t\t\tu64 *server_challenge)\n{\n\tvoid *dp, *dend;\n\tint ret;\n\n\t \n\tret = __ceph_x_decrypt(secret, challenge, challenge_len);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdout(\"%s decrypted %d bytes\\n\", __func__, ret);\n\tdp = challenge + sizeof(struct ceph_x_encrypt_header);\n\tdend = dp + ret;\n\n\tceph_decode_skip_8(&dp, dend, e_inval);   \n\tceph_decode_64_safe(&dp, dend, *server_challenge, e_inval);\n\tdout(\"%s server_challenge %llu\\n\", __func__, *server_challenge);\n\treturn 0;\n\ne_inval:\n\treturn -EINVAL;\n}\n\nstatic int ceph_x_add_authorizer_challenge(struct ceph_auth_client *ac,\n\t\t\t\t\t   struct ceph_authorizer *a,\n\t\t\t\t\t   void *challenge, int challenge_len)\n{\n\tstruct ceph_x_authorizer *au = (void *)a;\n\tu64 server_challenge;\n\tint ret;\n\n\tret = decrypt_authorizer_challenge(&au->session_key, challenge,\n\t\t\t\t\t   challenge_len, &server_challenge);\n\tif (ret) {\n\t\tpr_err(\"failed to decrypt authorize challenge: %d\", ret);\n\t\treturn ret;\n\t}\n\n\tret = encrypt_authorizer(au, &server_challenge);\n\tif (ret) {\n\t\tpr_err(\"failed to encrypt authorizer w/ challenge: %d\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int decrypt_authorizer_reply(struct ceph_crypto_key *secret,\n\t\t\t\t    void **p, void *end, u64 *nonce_plus_one,\n\t\t\t\t    u8 *con_secret, int *con_secret_len)\n{\n\tvoid *dp, *dend;\n\tu8 struct_v;\n\tint ret;\n\n\tdp = *p + ceph_x_encrypt_offset();\n\tret = ceph_x_decrypt(secret, p, end);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdout(\"%s decrypted %d bytes\\n\", __func__, ret);\n\tdend = dp + ret;\n\n\tceph_decode_8_safe(&dp, dend, struct_v, e_inval);\n\tceph_decode_64_safe(&dp, dend, *nonce_plus_one, e_inval);\n\tdout(\"%s nonce_plus_one %llu\\n\", __func__, *nonce_plus_one);\n\tif (struct_v >= 2) {\n\t\tret = decode_con_secret(&dp, dend, con_secret, con_secret_len);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n\ne_inval:\n\treturn -EINVAL;\n}\n\nstatic int ceph_x_verify_authorizer_reply(struct ceph_auth_client *ac,\n\t\t\t\t\t  struct ceph_authorizer *a,\n\t\t\t\t\t  void *reply, int reply_len,\n\t\t\t\t\t  u8 *session_key, int *session_key_len,\n\t\t\t\t\t  u8 *con_secret, int *con_secret_len)\n{\n\tstruct ceph_x_authorizer *au = (void *)a;\n\tu64 nonce_plus_one;\n\tint ret;\n\n\tif (session_key) {\n\t\tmemcpy(session_key, au->session_key.key, au->session_key.len);\n\t\t*session_key_len = au->session_key.len;\n\t}\n\n\tret = decrypt_authorizer_reply(&au->session_key, &reply,\n\t\t\t\t       reply + reply_len, &nonce_plus_one,\n\t\t\t\t       con_secret, con_secret_len);\n\tif (ret)\n\t\treturn ret;\n\n\tif (nonce_plus_one != au->nonce + 1) {\n\t\tpr_err(\"failed to authenticate server\\n\");\n\t\treturn -EPERM;\n\t}\n\n\treturn 0;\n}\n\nstatic void ceph_x_reset(struct ceph_auth_client *ac)\n{\n\tstruct ceph_x_info *xi = ac->private;\n\n\tdout(\"reset\\n\");\n\txi->starting = true;\n\txi->server_challenge = 0;\n}\n\nstatic void ceph_x_destroy(struct ceph_auth_client *ac)\n{\n\tstruct ceph_x_info *xi = ac->private;\n\tstruct rb_node *p;\n\n\tdout(\"ceph_x_destroy %p\\n\", ac);\n\tceph_crypto_key_destroy(&xi->secret);\n\n\twhile ((p = rb_first(&xi->ticket_handlers)) != NULL) {\n\t\tstruct ceph_x_ticket_handler *th =\n\t\t\trb_entry(p, struct ceph_x_ticket_handler, node);\n\t\tremove_ticket_handler(ac, th);\n\t}\n\n\tceph_x_authorizer_cleanup(&xi->auth_authorizer);\n\n\tkfree(ac->private);\n\tac->private = NULL;\n}\n\nstatic void invalidate_ticket(struct ceph_auth_client *ac, int peer_type)\n{\n\tstruct ceph_x_ticket_handler *th;\n\n\tth = get_ticket_handler(ac, peer_type);\n\tif (IS_ERR(th))\n\t\treturn;\n\n\tif (th->have_key) {\n\t\tdout(\"ticket %d (%s) secret_id %llu invalidated\\n\",\n\t\t     th->service, ceph_entity_type_name(th->service),\n\t\t     th->secret_id);\n\t\tth->have_key = false;\n\t}\n}\n\nstatic void ceph_x_invalidate_authorizer(struct ceph_auth_client *ac,\n\t\t\t\t\t int peer_type)\n{\n\t \n\tinvalidate_ticket(ac, peer_type);\n\tinvalidate_ticket(ac, CEPH_ENTITY_TYPE_AUTH);\n}\n\nstatic int calc_signature(struct ceph_x_authorizer *au, struct ceph_msg *msg,\n\t\t\t  __le64 *psig)\n{\n\tvoid *enc_buf = au->enc_buf;\n\tint ret;\n\n\tif (!CEPH_HAVE_FEATURE(msg->con->peer_features, CEPHX_V2)) {\n\t\tstruct {\n\t\t\t__le32 len;\n\t\t\t__le32 header_crc;\n\t\t\t__le32 front_crc;\n\t\t\t__le32 middle_crc;\n\t\t\t__le32 data_crc;\n\t\t} __packed *sigblock = enc_buf + ceph_x_encrypt_offset();\n\n\t\tsigblock->len = cpu_to_le32(4*sizeof(u32));\n\t\tsigblock->header_crc = msg->hdr.crc;\n\t\tsigblock->front_crc = msg->footer.front_crc;\n\t\tsigblock->middle_crc = msg->footer.middle_crc;\n\t\tsigblock->data_crc =  msg->footer.data_crc;\n\n\t\tret = ceph_x_encrypt(&au->session_key, enc_buf,\n\t\t\t\t     CEPHX_AU_ENC_BUF_LEN, sizeof(*sigblock));\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\t*psig = *(__le64 *)(enc_buf + sizeof(u32));\n\t} else {\n\t\tstruct {\n\t\t\t__le32 header_crc;\n\t\t\t__le32 front_crc;\n\t\t\t__le32 front_len;\n\t\t\t__le32 middle_crc;\n\t\t\t__le32 middle_len;\n\t\t\t__le32 data_crc;\n\t\t\t__le32 data_len;\n\t\t\t__le32 seq_lower_word;\n\t\t} __packed *sigblock = enc_buf;\n\t\tstruct {\n\t\t\t__le64 a, b, c, d;\n\t\t} __packed *penc = enc_buf;\n\t\tint ciphertext_len;\n\n\t\tsigblock->header_crc = msg->hdr.crc;\n\t\tsigblock->front_crc = msg->footer.front_crc;\n\t\tsigblock->front_len = msg->hdr.front_len;\n\t\tsigblock->middle_crc = msg->footer.middle_crc;\n\t\tsigblock->middle_len = msg->hdr.middle_len;\n\t\tsigblock->data_crc =  msg->footer.data_crc;\n\t\tsigblock->data_len = msg->hdr.data_len;\n\t\tsigblock->seq_lower_word = *(__le32 *)&msg->hdr.seq;\n\n\t\t \n\t\tret = ceph_crypt(&au->session_key, true, enc_buf,\n\t\t\t\t CEPHX_AU_ENC_BUF_LEN, sizeof(*sigblock),\n\t\t\t\t &ciphertext_len);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t*psig = penc->a ^ penc->b ^ penc->c ^ penc->d;\n\t}\n\n\treturn 0;\n}\n\nstatic int ceph_x_sign_message(struct ceph_auth_handshake *auth,\n\t\t\t       struct ceph_msg *msg)\n{\n\t__le64 sig;\n\tint ret;\n\n\tif (ceph_test_opt(from_msgr(msg->con->msgr), NOMSGSIGN))\n\t\treturn 0;\n\n\tret = calc_signature((struct ceph_x_authorizer *)auth->authorizer,\n\t\t\t     msg, &sig);\n\tif (ret)\n\t\treturn ret;\n\n\tmsg->footer.sig = sig;\n\tmsg->footer.flags |= CEPH_MSG_FOOTER_SIGNED;\n\treturn 0;\n}\n\nstatic int ceph_x_check_message_signature(struct ceph_auth_handshake *auth,\n\t\t\t\t\t  struct ceph_msg *msg)\n{\n\t__le64 sig_check;\n\tint ret;\n\n\tif (ceph_test_opt(from_msgr(msg->con->msgr), NOMSGSIGN))\n\t\treturn 0;\n\n\tret = calc_signature((struct ceph_x_authorizer *)auth->authorizer,\n\t\t\t     msg, &sig_check);\n\tif (ret)\n\t\treturn ret;\n\tif (sig_check == msg->footer.sig)\n\t\treturn 0;\n\tif (msg->footer.flags & CEPH_MSG_FOOTER_SIGNED)\n\t\tdout(\"ceph_x_check_message_signature %p has signature %llx \"\n\t\t     \"expect %llx\\n\", msg, msg->footer.sig, sig_check);\n\telse\n\t\tdout(\"ceph_x_check_message_signature %p sender did not set \"\n\t\t     \"CEPH_MSG_FOOTER_SIGNED\\n\", msg);\n\treturn -EBADMSG;\n}\n\nstatic const struct ceph_auth_client_ops ceph_x_ops = {\n\t.is_authenticated = ceph_x_is_authenticated,\n\t.should_authenticate = ceph_x_should_authenticate,\n\t.build_request = ceph_x_build_request,\n\t.handle_reply = ceph_x_handle_reply,\n\t.create_authorizer = ceph_x_create_authorizer,\n\t.update_authorizer = ceph_x_update_authorizer,\n\t.add_authorizer_challenge = ceph_x_add_authorizer_challenge,\n\t.verify_authorizer_reply = ceph_x_verify_authorizer_reply,\n\t.invalidate_authorizer = ceph_x_invalidate_authorizer,\n\t.reset =  ceph_x_reset,\n\t.destroy = ceph_x_destroy,\n\t.sign_message = ceph_x_sign_message,\n\t.check_message_signature = ceph_x_check_message_signature,\n};\n\n\nint ceph_x_init(struct ceph_auth_client *ac)\n{\n\tstruct ceph_x_info *xi;\n\tint ret;\n\n\tdout(\"ceph_x_init %p\\n\", ac);\n\tret = -ENOMEM;\n\txi = kzalloc(sizeof(*xi), GFP_NOFS);\n\tif (!xi)\n\t\tgoto out;\n\n\tret = -EINVAL;\n\tif (!ac->key) {\n\t\tpr_err(\"no secret set (for auth_x protocol)\\n\");\n\t\tgoto out_nomem;\n\t}\n\n\tret = ceph_crypto_key_clone(&xi->secret, ac->key);\n\tif (ret < 0) {\n\t\tpr_err(\"cannot clone key: %d\\n\", ret);\n\t\tgoto out_nomem;\n\t}\n\n\txi->starting = true;\n\txi->ticket_handlers = RB_ROOT;\n\n\tac->protocol = CEPH_AUTH_CEPHX;\n\tac->private = xi;\n\tac->ops = &ceph_x_ops;\n\treturn 0;\n\nout_nomem:\n\tkfree(xi);\nout:\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}