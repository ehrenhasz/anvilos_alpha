{
  "module_name": "crypto.c",
  "hash_id": "362d8033974cf23069cf9f48305fc83778e11098b063bcedb7ec58f6c54f282e",
  "original_prompt": "Ingested from linux-6.6.14/net/ceph/crypto.c",
  "human_readable_source": "\n\n#include <linux/ceph/ceph_debug.h>\n\n#include <linux/err.h>\n#include <linux/scatterlist.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <crypto/aes.h>\n#include <crypto/skcipher.h>\n#include <linux/key-type.h>\n#include <linux/sched/mm.h>\n\n#include <keys/ceph-type.h>\n#include <keys/user-type.h>\n#include <linux/ceph/decode.h>\n#include \"crypto.h\"\n\n \nstatic int set_secret(struct ceph_crypto_key *key, void *buf)\n{\n\tunsigned int noio_flag;\n\tint ret;\n\n\tkey->key = NULL;\n\tkey->tfm = NULL;\n\n\tswitch (key->type) {\n\tcase CEPH_CRYPTO_NONE:\n\t\treturn 0;  \n\tcase CEPH_CRYPTO_AES:\n\t\tbreak;\n\tdefault:\n\t\treturn -ENOTSUPP;\n\t}\n\n\tif (!key->len)\n\t\treturn -EINVAL;\n\n\tkey->key = kmemdup(buf, key->len, GFP_NOIO);\n\tif (!key->key) {\n\t\tret = -ENOMEM;\n\t\tgoto fail;\n\t}\n\n\t \n\tnoio_flag = memalloc_noio_save();\n\tkey->tfm = crypto_alloc_sync_skcipher(\"cbc(aes)\", 0, 0);\n\tmemalloc_noio_restore(noio_flag);\n\tif (IS_ERR(key->tfm)) {\n\t\tret = PTR_ERR(key->tfm);\n\t\tkey->tfm = NULL;\n\t\tgoto fail;\n\t}\n\n\tret = crypto_sync_skcipher_setkey(key->tfm, key->key, key->len);\n\tif (ret)\n\t\tgoto fail;\n\n\treturn 0;\n\nfail:\n\tceph_crypto_key_destroy(key);\n\treturn ret;\n}\n\nint ceph_crypto_key_clone(struct ceph_crypto_key *dst,\n\t\t\t  const struct ceph_crypto_key *src)\n{\n\tmemcpy(dst, src, sizeof(struct ceph_crypto_key));\n\treturn set_secret(dst, src->key);\n}\n\nint ceph_crypto_key_encode(struct ceph_crypto_key *key, void **p, void *end)\n{\n\tif (*p + sizeof(u16) + sizeof(key->created) +\n\t    sizeof(u16) + key->len > end)\n\t\treturn -ERANGE;\n\tceph_encode_16(p, key->type);\n\tceph_encode_copy(p, &key->created, sizeof(key->created));\n\tceph_encode_16(p, key->len);\n\tceph_encode_copy(p, key->key, key->len);\n\treturn 0;\n}\n\nint ceph_crypto_key_decode(struct ceph_crypto_key *key, void **p, void *end)\n{\n\tint ret;\n\n\tceph_decode_need(p, end, 2*sizeof(u16) + sizeof(key->created), bad);\n\tkey->type = ceph_decode_16(p);\n\tceph_decode_copy(p, &key->created, sizeof(key->created));\n\tkey->len = ceph_decode_16(p);\n\tceph_decode_need(p, end, key->len, bad);\n\tret = set_secret(key, *p);\n\tmemzero_explicit(*p, key->len);\n\t*p += key->len;\n\treturn ret;\n\nbad:\n\tdout(\"failed to decode crypto key\\n\");\n\treturn -EINVAL;\n}\n\nint ceph_crypto_key_unarmor(struct ceph_crypto_key *key, const char *inkey)\n{\n\tint inlen = strlen(inkey);\n\tint blen = inlen * 3 / 4;\n\tvoid *buf, *p;\n\tint ret;\n\n\tdout(\"crypto_key_unarmor %s\\n\", inkey);\n\tbuf = kmalloc(blen, GFP_NOFS);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\tblen = ceph_unarmor(buf, inkey, inkey+inlen);\n\tif (blen < 0) {\n\t\tkfree(buf);\n\t\treturn blen;\n\t}\n\n\tp = buf;\n\tret = ceph_crypto_key_decode(key, &p, p + blen);\n\tkfree(buf);\n\tif (ret)\n\t\treturn ret;\n\tdout(\"crypto_key_unarmor key %p type %d len %d\\n\", key,\n\t     key->type, key->len);\n\treturn 0;\n}\n\nvoid ceph_crypto_key_destroy(struct ceph_crypto_key *key)\n{\n\tif (key) {\n\t\tkfree_sensitive(key->key);\n\t\tkey->key = NULL;\n\t\tif (key->tfm) {\n\t\t\tcrypto_free_sync_skcipher(key->tfm);\n\t\t\tkey->tfm = NULL;\n\t\t}\n\t}\n}\n\nstatic const u8 *aes_iv = (u8 *)CEPH_AES_IV;\n\n \nstatic int setup_sgtable(struct sg_table *sgt, struct scatterlist *prealloc_sg,\n\t\t\t const void *buf, unsigned int buf_len)\n{\n\tstruct scatterlist *sg;\n\tconst bool is_vmalloc = is_vmalloc_addr(buf);\n\tunsigned int off = offset_in_page(buf);\n\tunsigned int chunk_cnt = 1;\n\tunsigned int chunk_len = PAGE_ALIGN(off + buf_len);\n\tint i;\n\tint ret;\n\n\tif (buf_len == 0) {\n\t\tmemset(sgt, 0, sizeof(*sgt));\n\t\treturn -EINVAL;\n\t}\n\n\tif (is_vmalloc) {\n\t\tchunk_cnt = chunk_len >> PAGE_SHIFT;\n\t\tchunk_len = PAGE_SIZE;\n\t}\n\n\tif (chunk_cnt > 1) {\n\t\tret = sg_alloc_table(sgt, chunk_cnt, GFP_NOFS);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else {\n\t\tWARN_ON(chunk_cnt != 1);\n\t\tsg_init_table(prealloc_sg, 1);\n\t\tsgt->sgl = prealloc_sg;\n\t\tsgt->nents = sgt->orig_nents = 1;\n\t}\n\n\tfor_each_sg(sgt->sgl, sg, sgt->orig_nents, i) {\n\t\tstruct page *page;\n\t\tunsigned int len = min(chunk_len - off, buf_len);\n\n\t\tif (is_vmalloc)\n\t\t\tpage = vmalloc_to_page(buf);\n\t\telse\n\t\t\tpage = virt_to_page(buf);\n\n\t\tsg_set_page(sg, page, len, off);\n\n\t\toff = 0;\n\t\tbuf += len;\n\t\tbuf_len -= len;\n\t}\n\tWARN_ON(buf_len != 0);\n\n\treturn 0;\n}\n\nstatic void teardown_sgtable(struct sg_table *sgt)\n{\n\tif (sgt->orig_nents > 1)\n\t\tsg_free_table(sgt);\n}\n\nstatic int ceph_aes_crypt(const struct ceph_crypto_key *key, bool encrypt,\n\t\t\t  void *buf, int buf_len, int in_len, int *pout_len)\n{\n\tSYNC_SKCIPHER_REQUEST_ON_STACK(req, key->tfm);\n\tstruct sg_table sgt;\n\tstruct scatterlist prealloc_sg;\n\tchar iv[AES_BLOCK_SIZE] __aligned(8);\n\tint pad_byte = AES_BLOCK_SIZE - (in_len & (AES_BLOCK_SIZE - 1));\n\tint crypt_len = encrypt ? in_len + pad_byte : in_len;\n\tint ret;\n\n\tWARN_ON(crypt_len > buf_len);\n\tif (encrypt)\n\t\tmemset(buf + in_len, pad_byte, pad_byte);\n\tret = setup_sgtable(&sgt, &prealloc_sg, buf, crypt_len);\n\tif (ret)\n\t\treturn ret;\n\n\tmemcpy(iv, aes_iv, AES_BLOCK_SIZE);\n\tskcipher_request_set_sync_tfm(req, key->tfm);\n\tskcipher_request_set_callback(req, 0, NULL, NULL);\n\tskcipher_request_set_crypt(req, sgt.sgl, sgt.sgl, crypt_len, iv);\n\n\t \n\tif (encrypt)\n\t\tret = crypto_skcipher_encrypt(req);\n\telse\n\t\tret = crypto_skcipher_decrypt(req);\n\tskcipher_request_zero(req);\n\tif (ret) {\n\t\tpr_err(\"%s %scrypt failed: %d\\n\", __func__,\n\t\t       encrypt ? \"en\" : \"de\", ret);\n\t\tgoto out_sgt;\n\t}\n\t \n\n\tif (encrypt) {\n\t\t*pout_len = crypt_len;\n\t} else {\n\t\tpad_byte = *(char *)(buf + in_len - 1);\n\t\tif (pad_byte > 0 && pad_byte <= AES_BLOCK_SIZE &&\n\t\t    in_len >= pad_byte) {\n\t\t\t*pout_len = in_len - pad_byte;\n\t\t} else {\n\t\t\tpr_err(\"%s got bad padding %d on in_len %d\\n\",\n\t\t\t       __func__, pad_byte, in_len);\n\t\t\tret = -EPERM;\n\t\t\tgoto out_sgt;\n\t\t}\n\t}\n\nout_sgt:\n\tteardown_sgtable(&sgt);\n\treturn ret;\n}\n\nint ceph_crypt(const struct ceph_crypto_key *key, bool encrypt,\n\t       void *buf, int buf_len, int in_len, int *pout_len)\n{\n\tswitch (key->type) {\n\tcase CEPH_CRYPTO_NONE:\n\t\t*pout_len = in_len;\n\t\treturn 0;\n\tcase CEPH_CRYPTO_AES:\n\t\treturn ceph_aes_crypt(key, encrypt, buf, buf_len, in_len,\n\t\t\t\t      pout_len);\n\tdefault:\n\t\treturn -ENOTSUPP;\n\t}\n}\n\nstatic int ceph_key_preparse(struct key_preparsed_payload *prep)\n{\n\tstruct ceph_crypto_key *ckey;\n\tsize_t datalen = prep->datalen;\n\tint ret;\n\tvoid *p;\n\n\tret = -EINVAL;\n\tif (datalen <= 0 || datalen > 32767 || !prep->data)\n\t\tgoto err;\n\n\tret = -ENOMEM;\n\tckey = kmalloc(sizeof(*ckey), GFP_KERNEL);\n\tif (!ckey)\n\t\tgoto err;\n\n\t \n\tp = (void *)prep->data;\n\tret = ceph_crypto_key_decode(ckey, &p, (char*)prep->data+datalen);\n\tif (ret < 0)\n\t\tgoto err_ckey;\n\n\tprep->payload.data[0] = ckey;\n\tprep->quotalen = datalen;\n\treturn 0;\n\nerr_ckey:\n\tkfree(ckey);\nerr:\n\treturn ret;\n}\n\nstatic void ceph_key_free_preparse(struct key_preparsed_payload *prep)\n{\n\tstruct ceph_crypto_key *ckey = prep->payload.data[0];\n\tceph_crypto_key_destroy(ckey);\n\tkfree(ckey);\n}\n\nstatic void ceph_key_destroy(struct key *key)\n{\n\tstruct ceph_crypto_key *ckey = key->payload.data[0];\n\n\tceph_crypto_key_destroy(ckey);\n\tkfree(ckey);\n}\n\nstruct key_type key_type_ceph = {\n\t.name\t\t= \"ceph\",\n\t.preparse\t= ceph_key_preparse,\n\t.free_preparse\t= ceph_key_free_preparse,\n\t.instantiate\t= generic_key_instantiate,\n\t.destroy\t= ceph_key_destroy,\n};\n\nint __init ceph_crypto_init(void)\n{\n\treturn register_key_type(&key_type_ceph);\n}\n\nvoid ceph_crypto_shutdown(void)\n{\n\tunregister_key_type(&key_type_ceph);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}