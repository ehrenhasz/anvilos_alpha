{
  "module_name": "msgpool.c",
  "hash_id": "00a4b25debc7f393f495f709cdf58dc15af712de512b71c0ca8fd29e38382e19",
  "original_prompt": "Ingested from linux-6.6.14/net/ceph/msgpool.c",
  "human_readable_source": "\n#include <linux/ceph/ceph_debug.h>\n\n#include <linux/err.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/vmalloc.h>\n\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/msgpool.h>\n\nstatic void *msgpool_alloc(gfp_t gfp_mask, void *arg)\n{\n\tstruct ceph_msgpool *pool = arg;\n\tstruct ceph_msg *msg;\n\n\tmsg = ceph_msg_new2(pool->type, pool->front_len, pool->max_data_items,\n\t\t\t    gfp_mask, true);\n\tif (!msg) {\n\t\tdout(\"msgpool_alloc %s failed\\n\", pool->name);\n\t} else {\n\t\tdout(\"msgpool_alloc %s %p\\n\", pool->name, msg);\n\t\tmsg->pool = pool;\n\t}\n\treturn msg;\n}\n\nstatic void msgpool_free(void *element, void *arg)\n{\n\tstruct ceph_msgpool *pool = arg;\n\tstruct ceph_msg *msg = element;\n\n\tdout(\"msgpool_release %s %p\\n\", pool->name, msg);\n\tmsg->pool = NULL;\n\tceph_msg_put(msg);\n}\n\nint ceph_msgpool_init(struct ceph_msgpool *pool, int type,\n\t\t      int front_len, int max_data_items, int size,\n\t\t      const char *name)\n{\n\tdout(\"msgpool %s init\\n\", name);\n\tpool->type = type;\n\tpool->front_len = front_len;\n\tpool->max_data_items = max_data_items;\n\tpool->pool = mempool_create(size, msgpool_alloc, msgpool_free, pool);\n\tif (!pool->pool)\n\t\treturn -ENOMEM;\n\tpool->name = name;\n\treturn 0;\n}\n\nvoid ceph_msgpool_destroy(struct ceph_msgpool *pool)\n{\n\tdout(\"msgpool %s destroy\\n\", pool->name);\n\tmempool_destroy(pool->pool);\n}\n\nstruct ceph_msg *ceph_msgpool_get(struct ceph_msgpool *pool, int front_len,\n\t\t\t\t  int max_data_items)\n{\n\tstruct ceph_msg *msg;\n\n\tif (front_len > pool->front_len ||\n\t    max_data_items > pool->max_data_items) {\n\t\tpr_warn_ratelimited(\"%s need %d/%d, pool %s has %d/%d\\n\",\n\t\t    __func__, front_len, max_data_items, pool->name,\n\t\t    pool->front_len, pool->max_data_items);\n\t\tWARN_ON_ONCE(1);\n\n\t\t \n\t\treturn ceph_msg_new2(pool->type, front_len, max_data_items,\n\t\t\t\t     GFP_NOFS, false);\n\t}\n\n\tmsg = mempool_alloc(pool->pool, GFP_NOFS);\n\tdout(\"msgpool_get %s %p\\n\", pool->name, msg);\n\treturn msg;\n}\n\nvoid ceph_msgpool_put(struct ceph_msgpool *pool, struct ceph_msg *msg)\n{\n\tdout(\"msgpool_put %s %p\\n\", pool->name, msg);\n\n\t \n\tmsg->front.iov_len = pool->front_len;\n\tmsg->hdr.front_len = cpu_to_le32(pool->front_len);\n\n\tmsg->data_length = 0;\n\tmsg->num_data_items = 0;\n\n\tkref_init(&msg->kref);   \n\tmempool_free(msg, pool->pool);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}