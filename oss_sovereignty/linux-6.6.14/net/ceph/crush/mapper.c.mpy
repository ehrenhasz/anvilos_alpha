{
  "module_name": "mapper.c",
  "hash_id": "88eae4879d37d22663a37e44b81bd4986f0417a25f7599dd65dfb84af511cc7d",
  "original_prompt": "Ingested from linux-6.6.14/net/ceph/crush/mapper.c",
  "human_readable_source": " \n\n#ifdef __KERNEL__\n# include <linux/string.h>\n# include <linux/slab.h>\n# include <linux/bug.h>\n# include <linux/kernel.h>\n# include <linux/crush/crush.h>\n# include <linux/crush/hash.h>\n# include <linux/crush/mapper.h>\n#else\n# include \"crush_compat.h\"\n# include \"crush.h\"\n# include \"hash.h\"\n# include \"mapper.h\"\n#endif\n#include \"crush_ln_table.h\"\n\n#define dprintk(args...)  \n\n \n\n \nint crush_find_rule(const struct crush_map *map, int ruleset, int type, int size)\n{\n\t__u32 i;\n\n\tfor (i = 0; i < map->max_rules; i++) {\n\t\tif (map->rules[i] &&\n\t\t    map->rules[i]->mask.ruleset == ruleset &&\n\t\t    map->rules[i]->mask.type == type &&\n\t\t    map->rules[i]->mask.min_size <= size &&\n\t\t    map->rules[i]->mask.max_size >= size)\n\t\t\treturn i;\n\t}\n\treturn -1;\n}\n\n \n\n \nstatic int bucket_perm_choose(const struct crush_bucket *bucket,\n\t\t\t      struct crush_work_bucket *work,\n\t\t\t      int x, int r)\n{\n\tunsigned int pr = r % bucket->size;\n\tunsigned int i, s;\n\n\t \n\tif (work->perm_x != (__u32)x || work->perm_n == 0) {\n\t\tdprintk(\"bucket %d new x=%d\\n\", bucket->id, x);\n\t\twork->perm_x = x;\n\n\t\t \n\t\tif (pr == 0) {\n\t\t\ts = crush_hash32_3(bucket->hash, x, bucket->id, 0) %\n\t\t\t\tbucket->size;\n\t\t\twork->perm[0] = s;\n\t\t\twork->perm_n = 0xffff;    \n\t\t\tgoto out;\n\t\t}\n\n\t\tfor (i = 0; i < bucket->size; i++)\n\t\t\twork->perm[i] = i;\n\t\twork->perm_n = 0;\n\t} else if (work->perm_n == 0xffff) {\n\t\t \n\t\tfor (i = 1; i < bucket->size; i++)\n\t\t\twork->perm[i] = i;\n\t\twork->perm[work->perm[0]] = 0;\n\t\twork->perm_n = 1;\n\t}\n\n\t \n\tfor (i = 0; i < work->perm_n; i++)\n\t\tdprintk(\" perm_choose have %d: %d\\n\", i, work->perm[i]);\n\twhile (work->perm_n <= pr) {\n\t\tunsigned int p = work->perm_n;\n\t\t \n\t\tif (p < bucket->size - 1) {\n\t\t\ti = crush_hash32_3(bucket->hash, x, bucket->id, p) %\n\t\t\t\t(bucket->size - p);\n\t\t\tif (i) {\n\t\t\t\tunsigned int t = work->perm[p + i];\n\t\t\t\twork->perm[p + i] = work->perm[p];\n\t\t\t\twork->perm[p] = t;\n\t\t\t}\n\t\t\tdprintk(\" perm_choose swap %d with %d\\n\", p, p+i);\n\t\t}\n\t\twork->perm_n++;\n\t}\n\tfor (i = 0; i < bucket->size; i++)\n\t\tdprintk(\" perm_choose  %d: %d\\n\", i, work->perm[i]);\n\n\ts = work->perm[pr];\nout:\n\tdprintk(\" perm_choose %d sz=%d x=%d r=%d (%d) s=%d\\n\", bucket->id,\n\t\tbucket->size, x, r, pr, s);\n\treturn bucket->items[s];\n}\n\n \nstatic int bucket_uniform_choose(const struct crush_bucket_uniform *bucket,\n\t\t\t\t struct crush_work_bucket *work, int x, int r)\n{\n\treturn bucket_perm_choose(&bucket->h, work, x, r);\n}\n\n \nstatic int bucket_list_choose(const struct crush_bucket_list *bucket,\n\t\t\t      int x, int r)\n{\n\tint i;\n\n\tfor (i = bucket->h.size-1; i >= 0; i--) {\n\t\t__u64 w = crush_hash32_4(bucket->h.hash, x, bucket->h.items[i],\n\t\t\t\t\t r, bucket->h.id);\n\t\tw &= 0xffff;\n\t\tdprintk(\"list_choose i=%d x=%d r=%d item %d weight %x \"\n\t\t\t\"sw %x rand %llx\",\n\t\t\ti, x, r, bucket->h.items[i], bucket->item_weights[i],\n\t\t\tbucket->sum_weights[i], w);\n\t\tw *= bucket->sum_weights[i];\n\t\tw = w >> 16;\n\t\t \n\t\tif (w < bucket->item_weights[i]) {\n\t\t\treturn bucket->h.items[i];\n\t\t}\n\t}\n\n\tdprintk(\"bad list sums for bucket %d\\n\", bucket->h.id);\n\treturn bucket->h.items[0];\n}\n\n\n \nstatic int height(int n)\n{\n\tint h = 0;\n\twhile ((n & 1) == 0) {\n\t\th++;\n\t\tn = n >> 1;\n\t}\n\treturn h;\n}\n\nstatic int left(int x)\n{\n\tint h = height(x);\n\treturn x - (1 << (h-1));\n}\n\nstatic int right(int x)\n{\n\tint h = height(x);\n\treturn x + (1 << (h-1));\n}\n\nstatic int terminal(int x)\n{\n\treturn x & 1;\n}\n\nstatic int bucket_tree_choose(const struct crush_bucket_tree *bucket,\n\t\t\t      int x, int r)\n{\n\tint n;\n\t__u32 w;\n\t__u64 t;\n\n\t \n\tn = bucket->num_nodes >> 1;\n\n\twhile (!terminal(n)) {\n\t\tint l;\n\t\t \n\t\tw = bucket->node_weights[n];\n\t\tt = (__u64)crush_hash32_4(bucket->h.hash, x, n, r,\n\t\t\t\t\t  bucket->h.id) * (__u64)w;\n\t\tt = t >> 32;\n\n\t\t \n\t\tl = left(n);\n\t\tif (t < bucket->node_weights[l])\n\t\t\tn = l;\n\t\telse\n\t\t\tn = right(n);\n\t}\n\n\treturn bucket->h.items[n >> 1];\n}\n\n\n \n\nstatic int bucket_straw_choose(const struct crush_bucket_straw *bucket,\n\t\t\t       int x, int r)\n{\n\t__u32 i;\n\tint high = 0;\n\t__u64 high_draw = 0;\n\t__u64 draw;\n\n\tfor (i = 0; i < bucket->h.size; i++) {\n\t\tdraw = crush_hash32_3(bucket->h.hash, x, bucket->h.items[i], r);\n\t\tdraw &= 0xffff;\n\t\tdraw *= bucket->straws[i];\n\t\tif (i == 0 || draw > high_draw) {\n\t\t\thigh = i;\n\t\t\thigh_draw = draw;\n\t\t}\n\t}\n\treturn bucket->h.items[high];\n}\n\n \nstatic __u64 crush_ln(unsigned int xin)\n{\n\tunsigned int x = xin;\n\tint iexpon, index1, index2;\n\t__u64 RH, LH, LL, xl64, result;\n\n\tx++;\n\n\t \n\tiexpon = 15;\n\n\t \n\tif (!(x & 0x18000)) {\n\t\tint bits = __builtin_clz(x & 0x1FFFF) - 16;\n\t\tx <<= bits;\n\t\tiexpon = 15 - bits;\n\t}\n\n\tindex1 = (x >> 8) << 1;\n\t \n\tRH = __RH_LH_tbl[index1 - 256];\n\t \n\tLH = __RH_LH_tbl[index1 + 1 - 256];\n\n\t \n\txl64 = (__s64)x * RH;\n\txl64 >>= 48;\n\n\tresult = iexpon;\n\tresult <<= (12 + 32);\n\n\tindex2 = xl64 & 0xff;\n\t \n\tLL = __LL_tbl[index2];\n\n\tLH = LH + LL;\n\n\tLH >>= (48 - 12 - 32);\n\tresult += LH;\n\n\treturn result;\n}\n\n\n \n\nstatic __u32 *get_choose_arg_weights(const struct crush_bucket_straw2 *bucket,\n\t\t\t\t     const struct crush_choose_arg *arg,\n\t\t\t\t     int position)\n{\n\tif (!arg || !arg->weight_set)\n\t\treturn bucket->item_weights;\n\n\tif (position >= arg->weight_set_size)\n\t\tposition = arg->weight_set_size - 1;\n\treturn arg->weight_set[position].weights;\n}\n\nstatic __s32 *get_choose_arg_ids(const struct crush_bucket_straw2 *bucket,\n\t\t\t\t const struct crush_choose_arg *arg)\n{\n\tif (!arg || !arg->ids)\n\t\treturn bucket->h.items;\n\n\treturn arg->ids;\n}\n\nstatic int bucket_straw2_choose(const struct crush_bucket_straw2 *bucket,\n\t\t\t\tint x, int r,\n\t\t\t\tconst struct crush_choose_arg *arg,\n\t\t\t\tint position)\n{\n\tunsigned int i, high = 0;\n\tunsigned int u;\n\t__s64 ln, draw, high_draw = 0;\n\t__u32 *weights = get_choose_arg_weights(bucket, arg, position);\n\t__s32 *ids = get_choose_arg_ids(bucket, arg);\n\n\tfor (i = 0; i < bucket->h.size; i++) {\n\t\tdprintk(\"weight 0x%x item %d\\n\", weights[i], ids[i]);\n\t\tif (weights[i]) {\n\t\t\tu = crush_hash32_3(bucket->h.hash, x, ids[i], r);\n\t\t\tu &= 0xffff;\n\n\t\t\t \n\t\t\tln = crush_ln(u) - 0x1000000000000ll;\n\n\t\t\t \n\t\t\tdraw = div64_s64(ln, weights[i]);\n\t\t} else {\n\t\t\tdraw = S64_MIN;\n\t\t}\n\n\t\tif (i == 0 || draw > high_draw) {\n\t\t\thigh = i;\n\t\t\thigh_draw = draw;\n\t\t}\n\t}\n\n\treturn bucket->h.items[high];\n}\n\n\nstatic int crush_bucket_choose(const struct crush_bucket *in,\n\t\t\t       struct crush_work_bucket *work,\n\t\t\t       int x, int r,\n\t\t\t       const struct crush_choose_arg *arg,\n\t\t\t       int position)\n{\n\tdprintk(\" crush_bucket_choose %d x=%d r=%d\\n\", in->id, x, r);\n\tBUG_ON(in->size == 0);\n\tswitch (in->alg) {\n\tcase CRUSH_BUCKET_UNIFORM:\n\t\treturn bucket_uniform_choose(\n\t\t\t(const struct crush_bucket_uniform *)in,\n\t\t\twork, x, r);\n\tcase CRUSH_BUCKET_LIST:\n\t\treturn bucket_list_choose((const struct crush_bucket_list *)in,\n\t\t\t\t\t  x, r);\n\tcase CRUSH_BUCKET_TREE:\n\t\treturn bucket_tree_choose((const struct crush_bucket_tree *)in,\n\t\t\t\t\t  x, r);\n\tcase CRUSH_BUCKET_STRAW:\n\t\treturn bucket_straw_choose(\n\t\t\t(const struct crush_bucket_straw *)in,\n\t\t\tx, r);\n\tcase CRUSH_BUCKET_STRAW2:\n\t\treturn bucket_straw2_choose(\n\t\t\t(const struct crush_bucket_straw2 *)in,\n\t\t\tx, r, arg, position);\n\tdefault:\n\t\tdprintk(\"unknown bucket %d alg %d\\n\", in->id, in->alg);\n\t\treturn in->items[0];\n\t}\n}\n\n \nstatic int is_out(const struct crush_map *map,\n\t\t  const __u32 *weight, int weight_max,\n\t\t  int item, int x)\n{\n\tif (item >= weight_max)\n\t\treturn 1;\n\tif (weight[item] >= 0x10000)\n\t\treturn 0;\n\tif (weight[item] == 0)\n\t\treturn 1;\n\tif ((crush_hash32_2(CRUSH_HASH_RJENKINS1, x, item) & 0xffff)\n\t    < weight[item])\n\t\treturn 0;\n\treturn 1;\n}\n\n \nstatic int crush_choose_firstn(const struct crush_map *map,\n\t\t\t       struct crush_work *work,\n\t\t\t       const struct crush_bucket *bucket,\n\t\t\t       const __u32 *weight, int weight_max,\n\t\t\t       int x, int numrep, int type,\n\t\t\t       int *out, int outpos,\n\t\t\t       int out_size,\n\t\t\t       unsigned int tries,\n\t\t\t       unsigned int recurse_tries,\n\t\t\t       unsigned int local_retries,\n\t\t\t       unsigned int local_fallback_retries,\n\t\t\t       int recurse_to_leaf,\n\t\t\t       unsigned int vary_r,\n\t\t\t       unsigned int stable,\n\t\t\t       int *out2,\n\t\t\t       int parent_r,\n\t\t\t       const struct crush_choose_arg *choose_args)\n{\n\tint rep;\n\tunsigned int ftotal, flocal;\n\tint retry_descent, retry_bucket, skip_rep;\n\tconst struct crush_bucket *in = bucket;\n\tint r;\n\tint i;\n\tint item = 0;\n\tint itemtype;\n\tint collide, reject;\n\tint count = out_size;\n\n\tdprintk(\"CHOOSE%s bucket %d x %d outpos %d numrep %d tries %d recurse_tries %d local_retries %d local_fallback_retries %d parent_r %d stable %d\\n\",\n\t\trecurse_to_leaf ? \"_LEAF\" : \"\",\n\t\tbucket->id, x, outpos, numrep,\n\t\ttries, recurse_tries, local_retries, local_fallback_retries,\n\t\tparent_r, stable);\n\n\tfor (rep = stable ? 0 : outpos; rep < numrep && count > 0 ; rep++) {\n\t\t \n\t\tftotal = 0;\n\t\tskip_rep = 0;\n\t\tdo {\n\t\t\tretry_descent = 0;\n\t\t\tin = bucket;                \n\n\t\t\t \n\t\t\tflocal = 0;\n\t\t\tdo {\n\t\t\t\tcollide = 0;\n\t\t\t\tretry_bucket = 0;\n\t\t\t\tr = rep + parent_r;\n\t\t\t\t \n\t\t\t\tr += ftotal;\n\n\t\t\t\t \n\t\t\t\tif (in->size == 0) {\n\t\t\t\t\treject = 1;\n\t\t\t\t\tgoto reject;\n\t\t\t\t}\n\t\t\t\tif (local_fallback_retries > 0 &&\n\t\t\t\t    flocal >= (in->size>>1) &&\n\t\t\t\t    flocal > local_fallback_retries)\n\t\t\t\t\titem = bucket_perm_choose(\n\t\t\t\t\t\tin, work->work[-1-in->id],\n\t\t\t\t\t\tx, r);\n\t\t\t\telse\n\t\t\t\t\titem = crush_bucket_choose(\n\t\t\t\t\t\tin, work->work[-1-in->id],\n\t\t\t\t\t\tx, r,\n\t\t\t\t\t\t(choose_args ?\n\t\t\t\t\t\t &choose_args[-1-in->id] : NULL),\n\t\t\t\t\t\toutpos);\n\t\t\t\tif (item >= map->max_devices) {\n\t\t\t\t\tdprintk(\"   bad item %d\\n\", item);\n\t\t\t\t\tskip_rep = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t \n\t\t\t\tif (item < 0)\n\t\t\t\t\titemtype = map->buckets[-1-item]->type;\n\t\t\t\telse\n\t\t\t\t\titemtype = 0;\n\t\t\t\tdprintk(\"  item %d type %d\\n\", item, itemtype);\n\n\t\t\t\t \n\t\t\t\tif (itemtype != type) {\n\t\t\t\t\tif (item >= 0 ||\n\t\t\t\t\t    (-1-item) >= map->max_buckets) {\n\t\t\t\t\t\tdprintk(\"   bad item type %d\\n\", type);\n\t\t\t\t\t\tskip_rep = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tin = map->buckets[-1-item];\n\t\t\t\t\tretry_bucket = 1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t \n\t\t\t\tfor (i = 0; i < outpos; i++) {\n\t\t\t\t\tif (out[i] == item) {\n\t\t\t\t\t\tcollide = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treject = 0;\n\t\t\t\tif (!collide && recurse_to_leaf) {\n\t\t\t\t\tif (item < 0) {\n\t\t\t\t\t\tint sub_r;\n\t\t\t\t\t\tif (vary_r)\n\t\t\t\t\t\t\tsub_r = r >> (vary_r-1);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tsub_r = 0;\n\t\t\t\t\t\tif (crush_choose_firstn(\n\t\t\t\t\t\t\t    map,\n\t\t\t\t\t\t\t    work,\n\t\t\t\t\t\t\t    map->buckets[-1-item],\n\t\t\t\t\t\t\t    weight, weight_max,\n\t\t\t\t\t\t\t    x, stable ? 1 : outpos+1, 0,\n\t\t\t\t\t\t\t    out2, outpos, count,\n\t\t\t\t\t\t\t    recurse_tries, 0,\n\t\t\t\t\t\t\t    local_retries,\n\t\t\t\t\t\t\t    local_fallback_retries,\n\t\t\t\t\t\t\t    0,\n\t\t\t\t\t\t\t    vary_r,\n\t\t\t\t\t\t\t    stable,\n\t\t\t\t\t\t\t    NULL,\n\t\t\t\t\t\t\t    sub_r,\n\t\t\t\t\t\t\t    choose_args) <= outpos)\n\t\t\t\t\t\t\t \n\t\t\t\t\t\t\treject = 1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t \n\t\t\t\t\t\tout2[outpos] = item;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!reject && !collide) {\n\t\t\t\t\t \n\t\t\t\t\tif (itemtype == 0)\n\t\t\t\t\t\treject = is_out(map, weight,\n\t\t\t\t\t\t\t\tweight_max,\n\t\t\t\t\t\t\t\titem, x);\n\t\t\t\t}\n\nreject:\n\t\t\t\tif (reject || collide) {\n\t\t\t\t\tftotal++;\n\t\t\t\t\tflocal++;\n\n\t\t\t\t\tif (collide && flocal <= local_retries)\n\t\t\t\t\t\t \n\t\t\t\t\t\tretry_bucket = 1;\n\t\t\t\t\telse if (local_fallback_retries > 0 &&\n\t\t\t\t\t\t flocal <= in->size + local_fallback_retries)\n\t\t\t\t\t\t \n\t\t\t\t\t\tretry_bucket = 1;\n\t\t\t\t\telse if (ftotal < tries)\n\t\t\t\t\t\t \n\t\t\t\t\t\tretry_descent = 1;\n\t\t\t\t\telse\n\t\t\t\t\t\t \n\t\t\t\t\t\tskip_rep = 1;\n\t\t\t\t\tdprintk(\"  reject %d  collide %d  \"\n\t\t\t\t\t\t\"ftotal %u  flocal %u\\n\",\n\t\t\t\t\t\treject, collide, ftotal,\n\t\t\t\t\t\tflocal);\n\t\t\t\t}\n\t\t\t} while (retry_bucket);\n\t\t} while (retry_descent);\n\n\t\tif (skip_rep) {\n\t\t\tdprintk(\"skip rep\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tdprintk(\"CHOOSE got %d\\n\", item);\n\t\tout[outpos] = item;\n\t\toutpos++;\n\t\tcount--;\n#ifndef __KERNEL__\n\t\tif (map->choose_tries && ftotal <= map->choose_total_tries)\n\t\t\tmap->choose_tries[ftotal]++;\n#endif\n\t}\n\n\tdprintk(\"CHOOSE returns %d\\n\", outpos);\n\treturn outpos;\n}\n\n\n \nstatic void crush_choose_indep(const struct crush_map *map,\n\t\t\t       struct crush_work *work,\n\t\t\t       const struct crush_bucket *bucket,\n\t\t\t       const __u32 *weight, int weight_max,\n\t\t\t       int x, int left, int numrep, int type,\n\t\t\t       int *out, int outpos,\n\t\t\t       unsigned int tries,\n\t\t\t       unsigned int recurse_tries,\n\t\t\t       int recurse_to_leaf,\n\t\t\t       int *out2,\n\t\t\t       int parent_r,\n\t\t\t       const struct crush_choose_arg *choose_args)\n{\n\tconst struct crush_bucket *in = bucket;\n\tint endpos = outpos + left;\n\tint rep;\n\tunsigned int ftotal;\n\tint r;\n\tint i;\n\tint item = 0;\n\tint itemtype;\n\tint collide;\n\n\tdprintk(\"CHOOSE%s INDEP bucket %d x %d outpos %d numrep %d\\n\", recurse_to_leaf ? \"_LEAF\" : \"\",\n\t\tbucket->id, x, outpos, numrep);\n\n\t \n\tfor (rep = outpos; rep < endpos; rep++) {\n\t\tout[rep] = CRUSH_ITEM_UNDEF;\n\t\tif (out2)\n\t\t\tout2[rep] = CRUSH_ITEM_UNDEF;\n\t}\n\n\tfor (ftotal = 0; left > 0 && ftotal < tries; ftotal++) {\n#ifdef DEBUG_INDEP\n\t\tif (out2 && ftotal) {\n\t\t\tdprintk(\"%u %d a: \", ftotal, left);\n\t\t\tfor (rep = outpos; rep < endpos; rep++) {\n\t\t\t\tdprintk(\" %d\", out[rep]);\n\t\t\t}\n\t\t\tdprintk(\"\\n\");\n\t\t\tdprintk(\"%u %d b: \", ftotal, left);\n\t\t\tfor (rep = outpos; rep < endpos; rep++) {\n\t\t\t\tdprintk(\" %d\", out2[rep]);\n\t\t\t}\n\t\t\tdprintk(\"\\n\");\n\t\t}\n#endif\n\t\tfor (rep = outpos; rep < endpos; rep++) {\n\t\t\tif (out[rep] != CRUSH_ITEM_UNDEF)\n\t\t\t\tcontinue;\n\n\t\t\tin = bucket;   \n\n\t\t\t \n\t\t\tfor (;;) {\n\t\t\t\t \n\t\t\t\tr = rep + parent_r;\n\n\t\t\t\t \n\t\t\t\tif (in->alg == CRUSH_BUCKET_UNIFORM &&\n\t\t\t\t    in->size % numrep == 0)\n\t\t\t\t\t \n\t\t\t\t\tr += (numrep+1) * ftotal;\n\t\t\t\telse\n\t\t\t\t\t \n\t\t\t\t\tr += numrep * ftotal;\n\n\t\t\t\t \n\t\t\t\tif (in->size == 0) {\n\t\t\t\t\tdprintk(\"   empty bucket\\n\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\titem = crush_bucket_choose(\n\t\t\t\t\tin, work->work[-1-in->id],\n\t\t\t\t\tx, r,\n\t\t\t\t\t(choose_args ?\n\t\t\t\t\t &choose_args[-1-in->id] : NULL),\n\t\t\t\t\toutpos);\n\t\t\t\tif (item >= map->max_devices) {\n\t\t\t\t\tdprintk(\"   bad item %d\\n\", item);\n\t\t\t\t\tout[rep] = CRUSH_ITEM_NONE;\n\t\t\t\t\tif (out2)\n\t\t\t\t\t\tout2[rep] = CRUSH_ITEM_NONE;\n\t\t\t\t\tleft--;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t \n\t\t\t\tif (item < 0)\n\t\t\t\t\titemtype = map->buckets[-1-item]->type;\n\t\t\t\telse\n\t\t\t\t\titemtype = 0;\n\t\t\t\tdprintk(\"  item %d type %d\\n\", item, itemtype);\n\n\t\t\t\t \n\t\t\t\tif (itemtype != type) {\n\t\t\t\t\tif (item >= 0 ||\n\t\t\t\t\t    (-1-item) >= map->max_buckets) {\n\t\t\t\t\t\tdprintk(\"   bad item type %d\\n\", type);\n\t\t\t\t\t\tout[rep] = CRUSH_ITEM_NONE;\n\t\t\t\t\t\tif (out2)\n\t\t\t\t\t\t\tout2[rep] =\n\t\t\t\t\t\t\t\tCRUSH_ITEM_NONE;\n\t\t\t\t\t\tleft--;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tin = map->buckets[-1-item];\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t \n\t\t\t\tcollide = 0;\n\t\t\t\tfor (i = outpos; i < endpos; i++) {\n\t\t\t\t\tif (out[i] == item) {\n\t\t\t\t\t\tcollide = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (collide)\n\t\t\t\t\tbreak;\n\n\t\t\t\tif (recurse_to_leaf) {\n\t\t\t\t\tif (item < 0) {\n\t\t\t\t\t\tcrush_choose_indep(\n\t\t\t\t\t\t\tmap,\n\t\t\t\t\t\t\twork,\n\t\t\t\t\t\t\tmap->buckets[-1-item],\n\t\t\t\t\t\t\tweight, weight_max,\n\t\t\t\t\t\t\tx, 1, numrep, 0,\n\t\t\t\t\t\t\tout2, rep,\n\t\t\t\t\t\t\trecurse_tries, 0,\n\t\t\t\t\t\t\t0, NULL, r,\n\t\t\t\t\t\t\tchoose_args);\n\t\t\t\t\t\tif (out2[rep] == CRUSH_ITEM_NONE) {\n\t\t\t\t\t\t\t \n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t \n\t\t\t\t\t\tout2[rep] = item;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t \n\t\t\t\tif (itemtype == 0 &&\n\t\t\t\t    is_out(map, weight, weight_max, item, x))\n\t\t\t\t\tbreak;\n\n\t\t\t\t \n\t\t\t\tout[rep] = item;\n\t\t\t\tleft--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tfor (rep = outpos; rep < endpos; rep++) {\n\t\tif (out[rep] == CRUSH_ITEM_UNDEF) {\n\t\t\tout[rep] = CRUSH_ITEM_NONE;\n\t\t}\n\t\tif (out2 && out2[rep] == CRUSH_ITEM_UNDEF) {\n\t\t\tout2[rep] = CRUSH_ITEM_NONE;\n\t\t}\n\t}\n#ifndef __KERNEL__\n\tif (map->choose_tries && ftotal <= map->choose_total_tries)\n\t\tmap->choose_tries[ftotal]++;\n#endif\n#ifdef DEBUG_INDEP\n\tif (out2) {\n\t\tdprintk(\"%u %d a: \", ftotal, left);\n\t\tfor (rep = outpos; rep < endpos; rep++) {\n\t\t\tdprintk(\" %d\", out[rep]);\n\t\t}\n\t\tdprintk(\"\\n\");\n\t\tdprintk(\"%u %d b: \", ftotal, left);\n\t\tfor (rep = outpos; rep < endpos; rep++) {\n\t\t\tdprintk(\" %d\", out2[rep]);\n\t\t}\n\t\tdprintk(\"\\n\");\n\t}\n#endif\n}\n\n\n \nvoid crush_init_workspace(const struct crush_map *map, void *v)\n{\n\tstruct crush_work *w = v;\n\t__s32 b;\n\n\t \n\tv += sizeof(struct crush_work);\n\tw->work = v;\n\tv += map->max_buckets * sizeof(struct crush_work_bucket *);\n\tfor (b = 0; b < map->max_buckets; ++b) {\n\t\tif (!map->buckets[b])\n\t\t\tcontinue;\n\n\t\tw->work[b] = v;\n\t\tswitch (map->buckets[b]->alg) {\n\t\tdefault:\n\t\t\tv += sizeof(struct crush_work_bucket);\n\t\t\tbreak;\n\t\t}\n\t\tw->work[b]->perm_x = 0;\n\t\tw->work[b]->perm_n = 0;\n\t\tw->work[b]->perm = v;\n\t\tv += map->buckets[b]->size * sizeof(__u32);\n\t}\n\tBUG_ON(v - (void *)w != map->working_size);\n}\n\n \nint crush_do_rule(const struct crush_map *map,\n\t\t  int ruleno, int x, int *result, int result_max,\n\t\t  const __u32 *weight, int weight_max,\n\t\t  void *cwin, const struct crush_choose_arg *choose_args)\n{\n\tint result_len;\n\tstruct crush_work *cw = cwin;\n\tint *a = cwin + map->working_size;\n\tint *b = a + result_max;\n\tint *c = b + result_max;\n\tint *w = a;\n\tint *o = b;\n\tint recurse_to_leaf;\n\tint wsize = 0;\n\tint osize;\n\tconst struct crush_rule *rule;\n\t__u32 step;\n\tint i, j;\n\tint numrep;\n\tint out_size;\n\t \n\tint choose_tries = map->choose_total_tries + 1;\n\tint choose_leaf_tries = 0;\n\t \n\tint choose_local_retries = map->choose_local_tries;\n\tint choose_local_fallback_retries = map->choose_local_fallback_tries;\n\n\tint vary_r = map->chooseleaf_vary_r;\n\tint stable = map->chooseleaf_stable;\n\n\tif ((__u32)ruleno >= map->max_rules) {\n\t\tdprintk(\" bad ruleno %d\\n\", ruleno);\n\t\treturn 0;\n\t}\n\n\trule = map->rules[ruleno];\n\tresult_len = 0;\n\n\tfor (step = 0; step < rule->len; step++) {\n\t\tint firstn = 0;\n\t\tconst struct crush_rule_step *curstep = &rule->steps[step];\n\n\t\tswitch (curstep->op) {\n\t\tcase CRUSH_RULE_TAKE:\n\t\t\tif ((curstep->arg1 >= 0 &&\n\t\t\t     curstep->arg1 < map->max_devices) ||\n\t\t\t    (-1-curstep->arg1 >= 0 &&\n\t\t\t     -1-curstep->arg1 < map->max_buckets &&\n\t\t\t     map->buckets[-1-curstep->arg1])) {\n\t\t\t\tw[0] = curstep->arg1;\n\t\t\t\twsize = 1;\n\t\t\t} else {\n\t\t\t\tdprintk(\" bad take value %d\\n\", curstep->arg1);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase CRUSH_RULE_SET_CHOOSE_TRIES:\n\t\t\tif (curstep->arg1 > 0)\n\t\t\t\tchoose_tries = curstep->arg1;\n\t\t\tbreak;\n\n\t\tcase CRUSH_RULE_SET_CHOOSELEAF_TRIES:\n\t\t\tif (curstep->arg1 > 0)\n\t\t\t\tchoose_leaf_tries = curstep->arg1;\n\t\t\tbreak;\n\n\t\tcase CRUSH_RULE_SET_CHOOSE_LOCAL_TRIES:\n\t\t\tif (curstep->arg1 >= 0)\n\t\t\t\tchoose_local_retries = curstep->arg1;\n\t\t\tbreak;\n\n\t\tcase CRUSH_RULE_SET_CHOOSE_LOCAL_FALLBACK_TRIES:\n\t\t\tif (curstep->arg1 >= 0)\n\t\t\t\tchoose_local_fallback_retries = curstep->arg1;\n\t\t\tbreak;\n\n\t\tcase CRUSH_RULE_SET_CHOOSELEAF_VARY_R:\n\t\t\tif (curstep->arg1 >= 0)\n\t\t\t\tvary_r = curstep->arg1;\n\t\t\tbreak;\n\n\t\tcase CRUSH_RULE_SET_CHOOSELEAF_STABLE:\n\t\t\tif (curstep->arg1 >= 0)\n\t\t\t\tstable = curstep->arg1;\n\t\t\tbreak;\n\n\t\tcase CRUSH_RULE_CHOOSELEAF_FIRSTN:\n\t\tcase CRUSH_RULE_CHOOSE_FIRSTN:\n\t\t\tfirstn = 1;\n\t\t\tfallthrough;\n\t\tcase CRUSH_RULE_CHOOSELEAF_INDEP:\n\t\tcase CRUSH_RULE_CHOOSE_INDEP:\n\t\t\tif (wsize == 0)\n\t\t\t\tbreak;\n\n\t\t\trecurse_to_leaf =\n\t\t\t\tcurstep->op ==\n\t\t\t\t CRUSH_RULE_CHOOSELEAF_FIRSTN ||\n\t\t\t\tcurstep->op ==\n\t\t\t\tCRUSH_RULE_CHOOSELEAF_INDEP;\n\n\t\t\t \n\t\t\tosize = 0;\n\n\t\t\tfor (i = 0; i < wsize; i++) {\n\t\t\t\tint bno;\n\t\t\t\tnumrep = curstep->arg1;\n\t\t\t\tif (numrep <= 0) {\n\t\t\t\t\tnumrep += result_max;\n\t\t\t\t\tif (numrep <= 0)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tj = 0;\n\t\t\t\t \n\t\t\t\tbno = -1 - w[i];\n\t\t\t\tif (bno < 0 || bno >= map->max_buckets) {\n\t\t\t\t\t \n\t\t\t\t\tdprintk(\"  bad w[i] %d\\n\", w[i]);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (firstn) {\n\t\t\t\t\tint recurse_tries;\n\t\t\t\t\tif (choose_leaf_tries)\n\t\t\t\t\t\trecurse_tries =\n\t\t\t\t\t\t\tchoose_leaf_tries;\n\t\t\t\t\telse if (map->chooseleaf_descend_once)\n\t\t\t\t\t\trecurse_tries = 1;\n\t\t\t\t\telse\n\t\t\t\t\t\trecurse_tries = choose_tries;\n\t\t\t\t\tosize += crush_choose_firstn(\n\t\t\t\t\t\tmap,\n\t\t\t\t\t\tcw,\n\t\t\t\t\t\tmap->buckets[bno],\n\t\t\t\t\t\tweight, weight_max,\n\t\t\t\t\t\tx, numrep,\n\t\t\t\t\t\tcurstep->arg2,\n\t\t\t\t\t\to+osize, j,\n\t\t\t\t\t\tresult_max-osize,\n\t\t\t\t\t\tchoose_tries,\n\t\t\t\t\t\trecurse_tries,\n\t\t\t\t\t\tchoose_local_retries,\n\t\t\t\t\t\tchoose_local_fallback_retries,\n\t\t\t\t\t\trecurse_to_leaf,\n\t\t\t\t\t\tvary_r,\n\t\t\t\t\t\tstable,\n\t\t\t\t\t\tc+osize,\n\t\t\t\t\t\t0,\n\t\t\t\t\t\tchoose_args);\n\t\t\t\t} else {\n\t\t\t\t\tout_size = ((numrep < (result_max-osize)) ?\n\t\t\t\t\t\t    numrep : (result_max-osize));\n\t\t\t\t\tcrush_choose_indep(\n\t\t\t\t\t\tmap,\n\t\t\t\t\t\tcw,\n\t\t\t\t\t\tmap->buckets[bno],\n\t\t\t\t\t\tweight, weight_max,\n\t\t\t\t\t\tx, out_size, numrep,\n\t\t\t\t\t\tcurstep->arg2,\n\t\t\t\t\t\to+osize, j,\n\t\t\t\t\t\tchoose_tries,\n\t\t\t\t\t\tchoose_leaf_tries ?\n\t\t\t\t\t\t   choose_leaf_tries : 1,\n\t\t\t\t\t\trecurse_to_leaf,\n\t\t\t\t\t\tc+osize,\n\t\t\t\t\t\t0,\n\t\t\t\t\t\tchoose_args);\n\t\t\t\t\tosize += out_size;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (recurse_to_leaf)\n\t\t\t\t \n\t\t\t\tmemcpy(o, c, osize*sizeof(*o));\n\n\t\t\t \n\t\t\tswap(o, w);\n\t\t\twsize = osize;\n\t\t\tbreak;\n\n\n\t\tcase CRUSH_RULE_EMIT:\n\t\t\tfor (i = 0; i < wsize && result_len < result_max; i++) {\n\t\t\t\tresult[result_len] = w[i];\n\t\t\t\tresult_len++;\n\t\t\t}\n\t\t\twsize = 0;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tdprintk(\" unknown op %d at step %d\\n\",\n\t\t\t\tcurstep->op, step);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn result_len;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}