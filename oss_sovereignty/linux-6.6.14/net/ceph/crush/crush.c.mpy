{
  "module_name": "crush.c",
  "hash_id": "356992375c571733a7066f5d63135bd4d3620e16198ba0e2ec82f0485a80af8a",
  "original_prompt": "Ingested from linux-6.6.14/net/ceph/crush/crush.c",
  "human_readable_source": "\n#ifdef __KERNEL__\n# include <linux/slab.h>\n# include <linux/crush/crush.h>\n#else\n# include \"crush_compat.h\"\n# include \"crush.h\"\n#endif\n\nconst char *crush_bucket_alg_name(int alg)\n{\n\tswitch (alg) {\n\tcase CRUSH_BUCKET_UNIFORM: return \"uniform\";\n\tcase CRUSH_BUCKET_LIST: return \"list\";\n\tcase CRUSH_BUCKET_TREE: return \"tree\";\n\tcase CRUSH_BUCKET_STRAW: return \"straw\";\n\tcase CRUSH_BUCKET_STRAW2: return \"straw2\";\n\tdefault: return \"unknown\";\n\t}\n}\n\n \nint crush_get_bucket_item_weight(const struct crush_bucket *b, int p)\n{\n\tif ((__u32)p >= b->size)\n\t\treturn 0;\n\n\tswitch (b->alg) {\n\tcase CRUSH_BUCKET_UNIFORM:\n\t\treturn ((struct crush_bucket_uniform *)b)->item_weight;\n\tcase CRUSH_BUCKET_LIST:\n\t\treturn ((struct crush_bucket_list *)b)->item_weights[p];\n\tcase CRUSH_BUCKET_TREE:\n\t\treturn ((struct crush_bucket_tree *)b)->node_weights[crush_calc_tree_node(p)];\n\tcase CRUSH_BUCKET_STRAW:\n\t\treturn ((struct crush_bucket_straw *)b)->item_weights[p];\n\tcase CRUSH_BUCKET_STRAW2:\n\t\treturn ((struct crush_bucket_straw2 *)b)->item_weights[p];\n\t}\n\treturn 0;\n}\n\nvoid crush_destroy_bucket_uniform(struct crush_bucket_uniform *b)\n{\n\tkfree(b->h.items);\n\tkfree(b);\n}\n\nvoid crush_destroy_bucket_list(struct crush_bucket_list *b)\n{\n\tkfree(b->item_weights);\n\tkfree(b->sum_weights);\n\tkfree(b->h.items);\n\tkfree(b);\n}\n\nvoid crush_destroy_bucket_tree(struct crush_bucket_tree *b)\n{\n\tkfree(b->h.items);\n\tkfree(b->node_weights);\n\tkfree(b);\n}\n\nvoid crush_destroy_bucket_straw(struct crush_bucket_straw *b)\n{\n\tkfree(b->straws);\n\tkfree(b->item_weights);\n\tkfree(b->h.items);\n\tkfree(b);\n}\n\nvoid crush_destroy_bucket_straw2(struct crush_bucket_straw2 *b)\n{\n\tkfree(b->item_weights);\n\tkfree(b->h.items);\n\tkfree(b);\n}\n\nvoid crush_destroy_bucket(struct crush_bucket *b)\n{\n\tswitch (b->alg) {\n\tcase CRUSH_BUCKET_UNIFORM:\n\t\tcrush_destroy_bucket_uniform((struct crush_bucket_uniform *)b);\n\t\tbreak;\n\tcase CRUSH_BUCKET_LIST:\n\t\tcrush_destroy_bucket_list((struct crush_bucket_list *)b);\n\t\tbreak;\n\tcase CRUSH_BUCKET_TREE:\n\t\tcrush_destroy_bucket_tree((struct crush_bucket_tree *)b);\n\t\tbreak;\n\tcase CRUSH_BUCKET_STRAW:\n\t\tcrush_destroy_bucket_straw((struct crush_bucket_straw *)b);\n\t\tbreak;\n\tcase CRUSH_BUCKET_STRAW2:\n\t\tcrush_destroy_bucket_straw2((struct crush_bucket_straw2 *)b);\n\t\tbreak;\n\t}\n}\n\n \nvoid crush_destroy(struct crush_map *map)\n{\n\t \n\tif (map->buckets) {\n\t\t__s32 b;\n\t\tfor (b = 0; b < map->max_buckets; b++) {\n\t\t\tif (map->buckets[b] == NULL)\n\t\t\t\tcontinue;\n\t\t\tcrush_destroy_bucket(map->buckets[b]);\n\t\t}\n\t\tkfree(map->buckets);\n\t}\n\n\t \n\tif (map->rules) {\n\t\t__u32 b;\n\t\tfor (b = 0; b < map->max_rules; b++)\n\t\t\tcrush_destroy_rule(map->rules[b]);\n\t\tkfree(map->rules);\n\t}\n\n#ifndef __KERNEL__\n\tkfree(map->choose_tries);\n#else\n\tclear_crush_names(&map->type_names);\n\tclear_crush_names(&map->names);\n\tclear_choose_args(map);\n#endif\n\tkfree(map);\n}\n\nvoid crush_destroy_rule(struct crush_rule *rule)\n{\n\tkfree(rule);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}