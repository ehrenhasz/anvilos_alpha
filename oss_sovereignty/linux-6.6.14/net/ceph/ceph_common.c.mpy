{
  "module_name": "ceph_common.c",
  "hash_id": "32c030da9acae9af12eaaf61677e88053bf3ea7eaa5824f564c6f254f619da3a",
  "original_prompt": "Ingested from linux-6.6.14/net/ceph/ceph_common.c",
  "human_readable_source": "\n\n#include <linux/ceph/ceph_debug.h>\n#include <linux/backing-dev.h>\n#include <linux/ctype.h>\n#include <linux/fs.h>\n#include <linux/inet.h>\n#include <linux/in6.h>\n#include <linux/key.h>\n#include <keys/ceph-type.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/nsproxy.h>\n#include <linux/fs_parser.h>\n#include <linux/sched.h>\n#include <linux/sched/mm.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/statfs.h>\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n\n\n#include <linux/ceph/ceph_features.h>\n#include <linux/ceph/libceph.h>\n#include <linux/ceph/debugfs.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/mon_client.h>\n#include <linux/ceph/auth.h>\n#include \"crypto.h\"\n\n\n \nbool libceph_compatible(void *data)\n{\n\treturn true;\n}\nEXPORT_SYMBOL(libceph_compatible);\n\nstatic int param_get_supported_features(char *buffer,\n\t\t\t\t\tconst struct kernel_param *kp)\n{\n\treturn sprintf(buffer, \"0x%llx\", CEPH_FEATURES_SUPPORTED_DEFAULT);\n}\nstatic const struct kernel_param_ops param_ops_supported_features = {\n\t.get = param_get_supported_features,\n};\nmodule_param_cb(supported_features, &param_ops_supported_features, NULL,\n\t\t0444);\n\nconst char *ceph_msg_type_name(int type)\n{\n\tswitch (type) {\n\tcase CEPH_MSG_SHUTDOWN: return \"shutdown\";\n\tcase CEPH_MSG_PING: return \"ping\";\n\tcase CEPH_MSG_AUTH: return \"auth\";\n\tcase CEPH_MSG_AUTH_REPLY: return \"auth_reply\";\n\tcase CEPH_MSG_MON_MAP: return \"mon_map\";\n\tcase CEPH_MSG_MON_GET_MAP: return \"mon_get_map\";\n\tcase CEPH_MSG_MON_SUBSCRIBE: return \"mon_subscribe\";\n\tcase CEPH_MSG_MON_SUBSCRIBE_ACK: return \"mon_subscribe_ack\";\n\tcase CEPH_MSG_STATFS: return \"statfs\";\n\tcase CEPH_MSG_STATFS_REPLY: return \"statfs_reply\";\n\tcase CEPH_MSG_MON_GET_VERSION: return \"mon_get_version\";\n\tcase CEPH_MSG_MON_GET_VERSION_REPLY: return \"mon_get_version_reply\";\n\tcase CEPH_MSG_MDS_MAP: return \"mds_map\";\n\tcase CEPH_MSG_FS_MAP_USER: return \"fs_map_user\";\n\tcase CEPH_MSG_CLIENT_SESSION: return \"client_session\";\n\tcase CEPH_MSG_CLIENT_RECONNECT: return \"client_reconnect\";\n\tcase CEPH_MSG_CLIENT_REQUEST: return \"client_request\";\n\tcase CEPH_MSG_CLIENT_REQUEST_FORWARD: return \"client_request_forward\";\n\tcase CEPH_MSG_CLIENT_REPLY: return \"client_reply\";\n\tcase CEPH_MSG_CLIENT_CAPS: return \"client_caps\";\n\tcase CEPH_MSG_CLIENT_CAPRELEASE: return \"client_cap_release\";\n\tcase CEPH_MSG_CLIENT_QUOTA: return \"client_quota\";\n\tcase CEPH_MSG_CLIENT_SNAP: return \"client_snap\";\n\tcase CEPH_MSG_CLIENT_LEASE: return \"client_lease\";\n\tcase CEPH_MSG_POOLOP_REPLY: return \"poolop_reply\";\n\tcase CEPH_MSG_POOLOP: return \"poolop\";\n\tcase CEPH_MSG_MON_COMMAND: return \"mon_command\";\n\tcase CEPH_MSG_MON_COMMAND_ACK: return \"mon_command_ack\";\n\tcase CEPH_MSG_OSD_MAP: return \"osd_map\";\n\tcase CEPH_MSG_OSD_OP: return \"osd_op\";\n\tcase CEPH_MSG_OSD_OPREPLY: return \"osd_opreply\";\n\tcase CEPH_MSG_WATCH_NOTIFY: return \"watch_notify\";\n\tcase CEPH_MSG_OSD_BACKOFF: return \"osd_backoff\";\n\tdefault: return \"unknown\";\n\t}\n}\nEXPORT_SYMBOL(ceph_msg_type_name);\n\n \nint ceph_check_fsid(struct ceph_client *client, struct ceph_fsid *fsid)\n{\n\tif (client->have_fsid) {\n\t\tif (ceph_fsid_compare(&client->fsid, fsid)) {\n\t\t\tpr_err(\"bad fsid, had %pU got %pU\",\n\t\t\t       &client->fsid, fsid);\n\t\t\treturn -1;\n\t\t}\n\t} else {\n\t\tmemcpy(&client->fsid, fsid, sizeof(*fsid));\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL(ceph_check_fsid);\n\nstatic int strcmp_null(const char *s1, const char *s2)\n{\n\tif (!s1 && !s2)\n\t\treturn 0;\n\tif (s1 && !s2)\n\t\treturn -1;\n\tif (!s1 && s2)\n\t\treturn 1;\n\treturn strcmp(s1, s2);\n}\n\nint ceph_compare_options(struct ceph_options *new_opt,\n\t\t\t struct ceph_client *client)\n{\n\tstruct ceph_options *opt1 = new_opt;\n\tstruct ceph_options *opt2 = client->options;\n\tint ofs = offsetof(struct ceph_options, mon_addr);\n\tint i;\n\tint ret;\n\n\t \n\tif (!net_eq(current->nsproxy->net_ns, read_pnet(&client->msgr.net)))\n\t\treturn -1;\n\n\tret = memcmp(opt1, opt2, ofs);\n\tif (ret)\n\t\treturn ret;\n\n\tret = strcmp_null(opt1->name, opt2->name);\n\tif (ret)\n\t\treturn ret;\n\n\tif (opt1->key && !opt2->key)\n\t\treturn -1;\n\tif (!opt1->key && opt2->key)\n\t\treturn 1;\n\tif (opt1->key && opt2->key) {\n\t\tif (opt1->key->type != opt2->key->type)\n\t\t\treturn -1;\n\t\tif (opt1->key->created.tv_sec != opt2->key->created.tv_sec)\n\t\t\treturn -1;\n\t\tif (opt1->key->created.tv_nsec != opt2->key->created.tv_nsec)\n\t\t\treturn -1;\n\t\tif (opt1->key->len != opt2->key->len)\n\t\t\treturn -1;\n\t\tif (opt1->key->key && !opt2->key->key)\n\t\t\treturn -1;\n\t\tif (!opt1->key->key && opt2->key->key)\n\t\t\treturn 1;\n\t\tif (opt1->key->key && opt2->key->key) {\n\t\t\tret = memcmp(opt1->key->key, opt2->key->key, opt1->key->len);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\tret = ceph_compare_crush_locs(&opt1->crush_locs, &opt2->crush_locs);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tfor (i = 0; i < opt1->num_mon; i++) {\n\t\tif (ceph_monmap_contains(client->monc.monmap,\n\t\t\t\t &opt1->mon_addr[i]))\n\t\t\treturn 0;\n\t}\n\treturn -1;\n}\nEXPORT_SYMBOL(ceph_compare_options);\n\nint ceph_parse_fsid(const char *str, struct ceph_fsid *fsid)\n{\n\tint i = 0;\n\tchar tmp[3];\n\tint err = -EINVAL;\n\tint d;\n\n\tdout(\"%s '%s'\\n\", __func__, str);\n\ttmp[2] = 0;\n\twhile (*str && i < 16) {\n\t\tif (ispunct(*str)) {\n\t\t\tstr++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!isxdigit(str[0]) || !isxdigit(str[1]))\n\t\t\tbreak;\n\t\ttmp[0] = str[0];\n\t\ttmp[1] = str[1];\n\t\tif (sscanf(tmp, \"%x\", &d) < 1)\n\t\t\tbreak;\n\t\tfsid->fsid[i] = d & 0xff;\n\t\ti++;\n\t\tstr += 2;\n\t}\n\n\tif (i == 16)\n\t\terr = 0;\n\tdout(\"%s ret %d got fsid %pU\\n\", __func__, err, fsid);\n\treturn err;\n}\nEXPORT_SYMBOL(ceph_parse_fsid);\n\n \nenum {\n\tOpt_osdkeepalivetimeout,\n\tOpt_mount_timeout,\n\tOpt_osd_idle_ttl,\n\tOpt_osd_request_timeout,\n\t \n\tOpt_fsid,\n\tOpt_name,\n\tOpt_secret,\n\tOpt_key,\n\tOpt_ip,\n\tOpt_crush_location,\n\tOpt_read_from_replica,\n\tOpt_ms_mode,\n\t \n\tOpt_share,\n\tOpt_crc,\n\tOpt_cephx_require_signatures,\n\tOpt_cephx_sign_messages,\n\tOpt_tcp_nodelay,\n\tOpt_abort_on_full,\n\tOpt_rxbounce,\n};\n\nenum {\n\tOpt_read_from_replica_no,\n\tOpt_read_from_replica_balance,\n\tOpt_read_from_replica_localize,\n};\n\nstatic const struct constant_table ceph_param_read_from_replica[] = {\n\t{\"no\",\t\tOpt_read_from_replica_no},\n\t{\"balance\",\tOpt_read_from_replica_balance},\n\t{\"localize\",\tOpt_read_from_replica_localize},\n\t{}\n};\n\nenum ceph_ms_mode {\n\tOpt_ms_mode_legacy,\n\tOpt_ms_mode_crc,\n\tOpt_ms_mode_secure,\n\tOpt_ms_mode_prefer_crc,\n\tOpt_ms_mode_prefer_secure\n};\n\nstatic const struct constant_table ceph_param_ms_mode[] = {\n\t{\"legacy\",\t\tOpt_ms_mode_legacy},\n\t{\"crc\",\t\t\tOpt_ms_mode_crc},\n\t{\"secure\",\t\tOpt_ms_mode_secure},\n\t{\"prefer-crc\",\t\tOpt_ms_mode_prefer_crc},\n\t{\"prefer-secure\",\tOpt_ms_mode_prefer_secure},\n\t{}\n};\n\nstatic const struct fs_parameter_spec ceph_parameters[] = {\n\tfsparam_flag\t(\"abort_on_full\",\t\tOpt_abort_on_full),\n\t__fsparam\t(NULL, \"cephx_require_signatures\", Opt_cephx_require_signatures,\n\t\t\t fs_param_neg_with_no|fs_param_deprecated, NULL),\n\tfsparam_flag_no (\"cephx_sign_messages\",\t\tOpt_cephx_sign_messages),\n\tfsparam_flag_no (\"crc\",\t\t\t\tOpt_crc),\n\tfsparam_string\t(\"crush_location\",\t\tOpt_crush_location),\n\tfsparam_string\t(\"fsid\",\t\t\tOpt_fsid),\n\tfsparam_string\t(\"ip\",\t\t\t\tOpt_ip),\n\tfsparam_string\t(\"key\",\t\t\t\tOpt_key),\n\tfsparam_u32\t(\"mount_timeout\",\t\tOpt_mount_timeout),\n\tfsparam_string\t(\"name\",\t\t\tOpt_name),\n\tfsparam_u32\t(\"osd_idle_ttl\",\t\tOpt_osd_idle_ttl),\n\tfsparam_u32\t(\"osd_request_timeout\",\t\tOpt_osd_request_timeout),\n\tfsparam_u32\t(\"osdkeepalive\",\t\tOpt_osdkeepalivetimeout),\n\tfsparam_enum\t(\"read_from_replica\",\t\tOpt_read_from_replica,\n\t\t\t ceph_param_read_from_replica),\n\tfsparam_flag\t(\"rxbounce\",\t\t\tOpt_rxbounce),\n\tfsparam_enum\t(\"ms_mode\",\t\t\tOpt_ms_mode,\n\t\t\t ceph_param_ms_mode),\n\tfsparam_string\t(\"secret\",\t\t\tOpt_secret),\n\tfsparam_flag_no (\"share\",\t\t\tOpt_share),\n\tfsparam_flag_no (\"tcp_nodelay\",\t\t\tOpt_tcp_nodelay),\n\t{}\n};\n\nstruct ceph_options *ceph_alloc_options(void)\n{\n\tstruct ceph_options *opt;\n\n\topt = kzalloc(sizeof(*opt), GFP_KERNEL);\n\tif (!opt)\n\t\treturn NULL;\n\n\topt->crush_locs = RB_ROOT;\n\topt->mon_addr = kcalloc(CEPH_MAX_MON, sizeof(*opt->mon_addr),\n\t\t\t\tGFP_KERNEL);\n\tif (!opt->mon_addr) {\n\t\tkfree(opt);\n\t\treturn NULL;\n\t}\n\n\topt->flags = CEPH_OPT_DEFAULT;\n\topt->osd_keepalive_timeout = CEPH_OSD_KEEPALIVE_DEFAULT;\n\topt->mount_timeout = CEPH_MOUNT_TIMEOUT_DEFAULT;\n\topt->osd_idle_ttl = CEPH_OSD_IDLE_TTL_DEFAULT;\n\topt->osd_request_timeout = CEPH_OSD_REQUEST_TIMEOUT_DEFAULT;\n\topt->read_from_replica = CEPH_READ_FROM_REPLICA_DEFAULT;\n\topt->con_modes[0] = CEPH_CON_MODE_UNKNOWN;\n\topt->con_modes[1] = CEPH_CON_MODE_UNKNOWN;\n\treturn opt;\n}\nEXPORT_SYMBOL(ceph_alloc_options);\n\nvoid ceph_destroy_options(struct ceph_options *opt)\n{\n\tdout(\"destroy_options %p\\n\", opt);\n\tif (!opt)\n\t\treturn;\n\n\tceph_clear_crush_locs(&opt->crush_locs);\n\tkfree(opt->name);\n\tif (opt->key) {\n\t\tceph_crypto_key_destroy(opt->key);\n\t\tkfree(opt->key);\n\t}\n\tkfree(opt->mon_addr);\n\tkfree(opt);\n}\nEXPORT_SYMBOL(ceph_destroy_options);\n\n \nstatic int get_secret(struct ceph_crypto_key *dst, const char *name,\n\t\t      struct p_log *log)\n{\n\tstruct key *ukey;\n\tint key_err;\n\tint err = 0;\n\tstruct ceph_crypto_key *ckey;\n\n\tukey = request_key(&key_type_ceph, name, NULL);\n\tif (IS_ERR(ukey)) {\n\t\t \n\t\tkey_err = PTR_ERR(ukey);\n\t\tswitch (key_err) {\n\t\tcase -ENOKEY:\n\t\t\terror_plog(log, \"Failed due to key not found: %s\",\n\t\t\t       name);\n\t\t\tbreak;\n\t\tcase -EKEYEXPIRED:\n\t\t\terror_plog(log, \"Failed due to expired key: %s\",\n\t\t\t       name);\n\t\t\tbreak;\n\t\tcase -EKEYREVOKED:\n\t\t\terror_plog(log, \"Failed due to revoked key: %s\",\n\t\t\t       name);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terror_plog(log, \"Failed due to key error %d: %s\",\n\t\t\t       key_err, name);\n\t\t}\n\t\terr = -EPERM;\n\t\tgoto out;\n\t}\n\n\tckey = ukey->payload.data[0];\n\terr = ceph_crypto_key_clone(dst, ckey);\n\tif (err)\n\t\tgoto out_key;\n\t \n\nout_key:\n\tkey_put(ukey);\nout:\n\treturn err;\n}\n\nint ceph_parse_mon_ips(const char *buf, size_t len, struct ceph_options *opt,\n\t\t       struct fc_log *l, char delim)\n{\n\tstruct p_log log = {.prefix = \"libceph\", .log = l};\n\tint ret;\n\n\t \n\tret = ceph_parse_ips(buf, buf + len, opt->mon_addr, CEPH_MAX_MON,\n\t\t\t     &opt->num_mon, delim);\n\tif (ret) {\n\t\terror_plog(&log, \"Failed to parse monitor IPs: %d\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(ceph_parse_mon_ips);\n\nint ceph_parse_param(struct fs_parameter *param, struct ceph_options *opt,\n\t\t     struct fc_log *l)\n{\n\tstruct fs_parse_result result;\n\tint token, err;\n\tstruct p_log log = {.prefix = \"libceph\", .log = l};\n\n\ttoken = __fs_parse(&log, ceph_parameters, param, &result);\n\tdout(\"%s fs_parse '%s' token %d\\n\", __func__, param->key, token);\n\tif (token < 0)\n\t\treturn token;\n\n\tswitch (token) {\n\tcase Opt_ip:\n\t\terr = ceph_parse_ips(param->string,\n\t\t\t\t     param->string + param->size,\n\t\t\t\t     &opt->my_addr, 1, NULL, ',');\n\t\tif (err) {\n\t\t\terror_plog(&log, \"Failed to parse ip: %d\", err);\n\t\t\treturn err;\n\t\t}\n\t\topt->flags |= CEPH_OPT_MYIP;\n\t\tbreak;\n\n\tcase Opt_fsid:\n\t\terr = ceph_parse_fsid(param->string, &opt->fsid);\n\t\tif (err) {\n\t\t\terror_plog(&log, \"Failed to parse fsid: %d\", err);\n\t\t\treturn err;\n\t\t}\n\t\topt->flags |= CEPH_OPT_FSID;\n\t\tbreak;\n\tcase Opt_name:\n\t\tkfree(opt->name);\n\t\topt->name = param->string;\n\t\tparam->string = NULL;\n\t\tbreak;\n\tcase Opt_secret:\n\t\tceph_crypto_key_destroy(opt->key);\n\t\tkfree(opt->key);\n\n\t\topt->key = kzalloc(sizeof(*opt->key), GFP_KERNEL);\n\t\tif (!opt->key)\n\t\t\treturn -ENOMEM;\n\t\terr = ceph_crypto_key_unarmor(opt->key, param->string);\n\t\tif (err) {\n\t\t\terror_plog(&log, \"Failed to parse secret: %d\", err);\n\t\t\treturn err;\n\t\t}\n\t\tbreak;\n\tcase Opt_key:\n\t\tceph_crypto_key_destroy(opt->key);\n\t\tkfree(opt->key);\n\n\t\topt->key = kzalloc(sizeof(*opt->key), GFP_KERNEL);\n\t\tif (!opt->key)\n\t\t\treturn -ENOMEM;\n\t\treturn get_secret(opt->key, param->string, &log);\n\tcase Opt_crush_location:\n\t\tceph_clear_crush_locs(&opt->crush_locs);\n\t\terr = ceph_parse_crush_location(param->string,\n\t\t\t\t\t\t&opt->crush_locs);\n\t\tif (err) {\n\t\t\terror_plog(&log, \"Failed to parse CRUSH location: %d\",\n\t\t\t\t   err);\n\t\t\treturn err;\n\t\t}\n\t\tbreak;\n\tcase Opt_read_from_replica:\n\t\tswitch (result.uint_32) {\n\t\tcase Opt_read_from_replica_no:\n\t\t\topt->read_from_replica = 0;\n\t\t\tbreak;\n\t\tcase Opt_read_from_replica_balance:\n\t\t\topt->read_from_replica = CEPH_OSD_FLAG_BALANCE_READS;\n\t\t\tbreak;\n\t\tcase Opt_read_from_replica_localize:\n\t\t\topt->read_from_replica = CEPH_OSD_FLAG_LOCALIZE_READS;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tBUG();\n\t\t}\n\t\tbreak;\n\tcase Opt_ms_mode:\n\t\tswitch (result.uint_32) {\n\t\tcase Opt_ms_mode_legacy:\n\t\t\topt->con_modes[0] = CEPH_CON_MODE_UNKNOWN;\n\t\t\topt->con_modes[1] = CEPH_CON_MODE_UNKNOWN;\n\t\t\tbreak;\n\t\tcase Opt_ms_mode_crc:\n\t\t\topt->con_modes[0] = CEPH_CON_MODE_CRC;\n\t\t\topt->con_modes[1] = CEPH_CON_MODE_UNKNOWN;\n\t\t\tbreak;\n\t\tcase Opt_ms_mode_secure:\n\t\t\topt->con_modes[0] = CEPH_CON_MODE_SECURE;\n\t\t\topt->con_modes[1] = CEPH_CON_MODE_UNKNOWN;\n\t\t\tbreak;\n\t\tcase Opt_ms_mode_prefer_crc:\n\t\t\topt->con_modes[0] = CEPH_CON_MODE_CRC;\n\t\t\topt->con_modes[1] = CEPH_CON_MODE_SECURE;\n\t\t\tbreak;\n\t\tcase Opt_ms_mode_prefer_secure:\n\t\t\topt->con_modes[0] = CEPH_CON_MODE_SECURE;\n\t\t\topt->con_modes[1] = CEPH_CON_MODE_CRC;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tBUG();\n\t\t}\n\t\tbreak;\n\n\tcase Opt_osdkeepalivetimeout:\n\t\t \n\t\tif (result.uint_32 < 1 || result.uint_32 > INT_MAX / 1000)\n\t\t\tgoto out_of_range;\n\t\topt->osd_keepalive_timeout =\n\t\t    msecs_to_jiffies(result.uint_32 * 1000);\n\t\tbreak;\n\tcase Opt_osd_idle_ttl:\n\t\t \n\t\tif (result.uint_32 < 1 || result.uint_32 > INT_MAX / 1000)\n\t\t\tgoto out_of_range;\n\t\topt->osd_idle_ttl = msecs_to_jiffies(result.uint_32 * 1000);\n\t\tbreak;\n\tcase Opt_mount_timeout:\n\t\t \n\t\tif (result.uint_32 > INT_MAX / 1000)\n\t\t\tgoto out_of_range;\n\t\topt->mount_timeout = msecs_to_jiffies(result.uint_32 * 1000);\n\t\tbreak;\n\tcase Opt_osd_request_timeout:\n\t\t \n\t\tif (result.uint_32 > INT_MAX / 1000)\n\t\t\tgoto out_of_range;\n\t\topt->osd_request_timeout =\n\t\t    msecs_to_jiffies(result.uint_32 * 1000);\n\t\tbreak;\n\n\tcase Opt_share:\n\t\tif (!result.negated)\n\t\t\topt->flags &= ~CEPH_OPT_NOSHARE;\n\t\telse\n\t\t\topt->flags |= CEPH_OPT_NOSHARE;\n\t\tbreak;\n\tcase Opt_crc:\n\t\tif (!result.negated)\n\t\t\topt->flags &= ~CEPH_OPT_NOCRC;\n\t\telse\n\t\t\topt->flags |= CEPH_OPT_NOCRC;\n\t\tbreak;\n\tcase Opt_cephx_require_signatures:\n\t\tif (!result.negated)\n\t\t\twarn_plog(&log, \"Ignoring cephx_require_signatures\");\n\t\telse\n\t\t\twarn_plog(&log, \"Ignoring nocephx_require_signatures, use nocephx_sign_messages\");\n\t\tbreak;\n\tcase Opt_cephx_sign_messages:\n\t\tif (!result.negated)\n\t\t\topt->flags &= ~CEPH_OPT_NOMSGSIGN;\n\t\telse\n\t\t\topt->flags |= CEPH_OPT_NOMSGSIGN;\n\t\tbreak;\n\tcase Opt_tcp_nodelay:\n\t\tif (!result.negated)\n\t\t\topt->flags |= CEPH_OPT_TCP_NODELAY;\n\t\telse\n\t\t\topt->flags &= ~CEPH_OPT_TCP_NODELAY;\n\t\tbreak;\n\n\tcase Opt_abort_on_full:\n\t\topt->flags |= CEPH_OPT_ABORT_ON_FULL;\n\t\tbreak;\n\tcase Opt_rxbounce:\n\t\topt->flags |= CEPH_OPT_RXBOUNCE;\n\t\tbreak;\n\n\tdefault:\n\t\tBUG();\n\t}\n\n\treturn 0;\n\nout_of_range:\n\treturn inval_plog(&log, \"%s out of range\", param->key);\n}\nEXPORT_SYMBOL(ceph_parse_param);\n\nint ceph_print_client_options(struct seq_file *m, struct ceph_client *client,\n\t\t\t      bool show_all)\n{\n\tstruct ceph_options *opt = client->options;\n\tsize_t pos = m->count;\n\tstruct rb_node *n;\n\n\tif (opt->name) {\n\t\tseq_puts(m, \"name=\");\n\t\tseq_escape(m, opt->name, \", \\t\\n\\\\\");\n\t\tseq_putc(m, ',');\n\t}\n\tif (opt->key)\n\t\tseq_puts(m, \"secret=<hidden>,\");\n\n\tif (!RB_EMPTY_ROOT(&opt->crush_locs)) {\n\t\tseq_puts(m, \"crush_location=\");\n\t\tfor (n = rb_first(&opt->crush_locs); ; ) {\n\t\t\tstruct crush_loc_node *loc =\n\t\t\t    rb_entry(n, struct crush_loc_node, cl_node);\n\n\t\t\tseq_printf(m, \"%s:%s\", loc->cl_loc.cl_type_name,\n\t\t\t\t   loc->cl_loc.cl_name);\n\t\t\tn = rb_next(n);\n\t\t\tif (!n)\n\t\t\t\tbreak;\n\n\t\t\tseq_putc(m, '|');\n\t\t}\n\t\tseq_putc(m, ',');\n\t}\n\tif (opt->read_from_replica == CEPH_OSD_FLAG_BALANCE_READS) {\n\t\tseq_puts(m, \"read_from_replica=balance,\");\n\t} else if (opt->read_from_replica == CEPH_OSD_FLAG_LOCALIZE_READS) {\n\t\tseq_puts(m, \"read_from_replica=localize,\");\n\t}\n\tif (opt->con_modes[0] != CEPH_CON_MODE_UNKNOWN) {\n\t\tif (opt->con_modes[0] == CEPH_CON_MODE_CRC &&\n\t\t    opt->con_modes[1] == CEPH_CON_MODE_UNKNOWN) {\n\t\t\tseq_puts(m, \"ms_mode=crc,\");\n\t\t} else if (opt->con_modes[0] == CEPH_CON_MODE_SECURE &&\n\t\t\t   opt->con_modes[1] == CEPH_CON_MODE_UNKNOWN) {\n\t\t\tseq_puts(m, \"ms_mode=secure,\");\n\t\t} else if (opt->con_modes[0] == CEPH_CON_MODE_CRC &&\n\t\t\t   opt->con_modes[1] == CEPH_CON_MODE_SECURE) {\n\t\t\tseq_puts(m, \"ms_mode=prefer-crc,\");\n\t\t} else if (opt->con_modes[0] == CEPH_CON_MODE_SECURE &&\n\t\t\t   opt->con_modes[1] == CEPH_CON_MODE_CRC) {\n\t\t\tseq_puts(m, \"ms_mode=prefer-secure,\");\n\t\t}\n\t}\n\n\tif (opt->flags & CEPH_OPT_FSID)\n\t\tseq_printf(m, \"fsid=%pU,\", &opt->fsid);\n\tif (opt->flags & CEPH_OPT_NOSHARE)\n\t\tseq_puts(m, \"noshare,\");\n\tif (opt->flags & CEPH_OPT_NOCRC)\n\t\tseq_puts(m, \"nocrc,\");\n\tif (opt->flags & CEPH_OPT_NOMSGSIGN)\n\t\tseq_puts(m, \"nocephx_sign_messages,\");\n\tif ((opt->flags & CEPH_OPT_TCP_NODELAY) == 0)\n\t\tseq_puts(m, \"notcp_nodelay,\");\n\tif (show_all && (opt->flags & CEPH_OPT_ABORT_ON_FULL))\n\t\tseq_puts(m, \"abort_on_full,\");\n\tif (opt->flags & CEPH_OPT_RXBOUNCE)\n\t\tseq_puts(m, \"rxbounce,\");\n\n\tif (opt->mount_timeout != CEPH_MOUNT_TIMEOUT_DEFAULT)\n\t\tseq_printf(m, \"mount_timeout=%d,\",\n\t\t\t   jiffies_to_msecs(opt->mount_timeout) / 1000);\n\tif (opt->osd_idle_ttl != CEPH_OSD_IDLE_TTL_DEFAULT)\n\t\tseq_printf(m, \"osd_idle_ttl=%d,\",\n\t\t\t   jiffies_to_msecs(opt->osd_idle_ttl) / 1000);\n\tif (opt->osd_keepalive_timeout != CEPH_OSD_KEEPALIVE_DEFAULT)\n\t\tseq_printf(m, \"osdkeepalivetimeout=%d,\",\n\t\t    jiffies_to_msecs(opt->osd_keepalive_timeout) / 1000);\n\tif (opt->osd_request_timeout != CEPH_OSD_REQUEST_TIMEOUT_DEFAULT)\n\t\tseq_printf(m, \"osd_request_timeout=%d,\",\n\t\t\t   jiffies_to_msecs(opt->osd_request_timeout) / 1000);\n\n\t \n\tif (m->count != pos)\n\t\tm->count--;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(ceph_print_client_options);\n\nstruct ceph_entity_addr *ceph_client_addr(struct ceph_client *client)\n{\n\treturn &client->msgr.inst.addr;\n}\nEXPORT_SYMBOL(ceph_client_addr);\n\nu64 ceph_client_gid(struct ceph_client *client)\n{\n\treturn client->monc.auth->global_id;\n}\nEXPORT_SYMBOL(ceph_client_gid);\n\n \nstruct ceph_client *ceph_create_client(struct ceph_options *opt, void *private)\n{\n\tstruct ceph_client *client;\n\tstruct ceph_entity_addr *myaddr = NULL;\n\tint err;\n\n\terr = wait_for_random_bytes();\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\n\tclient = kzalloc(sizeof(*client), GFP_KERNEL);\n\tif (client == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tclient->private = private;\n\tclient->options = opt;\n\n\tmutex_init(&client->mount_mutex);\n\tinit_waitqueue_head(&client->auth_wq);\n\tclient->auth_err = 0;\n\n\tclient->extra_mon_dispatch = NULL;\n\tclient->supported_features = CEPH_FEATURES_SUPPORTED_DEFAULT;\n\tclient->required_features = CEPH_FEATURES_REQUIRED_DEFAULT;\n\n\tif (!ceph_test_opt(client, NOMSGSIGN))\n\t\tclient->required_features |= CEPH_FEATURE_MSG_AUTH;\n\n\t \n\tif (ceph_test_opt(client, MYIP))\n\t\tmyaddr = &client->options->my_addr;\n\n\tceph_messenger_init(&client->msgr, myaddr);\n\n\t \n\terr = ceph_monc_init(&client->monc, client);\n\tif (err < 0)\n\t\tgoto fail;\n\terr = ceph_osdc_init(&client->osdc, client);\n\tif (err < 0)\n\t\tgoto fail_monc;\n\n\treturn client;\n\nfail_monc:\n\tceph_monc_stop(&client->monc);\nfail:\n\tceph_messenger_fini(&client->msgr);\n\tkfree(client);\n\treturn ERR_PTR(err);\n}\nEXPORT_SYMBOL(ceph_create_client);\n\nvoid ceph_destroy_client(struct ceph_client *client)\n{\n\tdout(\"destroy_client %p\\n\", client);\n\n\tatomic_set(&client->msgr.stopping, 1);\n\n\t \n\tceph_osdc_stop(&client->osdc);\n\tceph_monc_stop(&client->monc);\n\tceph_messenger_fini(&client->msgr);\n\n\tceph_debugfs_client_cleanup(client);\n\n\tceph_destroy_options(client->options);\n\n\tkfree(client);\n\tdout(\"destroy_client %p done\\n\", client);\n}\nEXPORT_SYMBOL(ceph_destroy_client);\n\nvoid ceph_reset_client_addr(struct ceph_client *client)\n{\n\tceph_messenger_reset_nonce(&client->msgr);\n\tceph_monc_reopen_session(&client->monc);\n\tceph_osdc_reopen_osds(&client->osdc);\n}\nEXPORT_SYMBOL(ceph_reset_client_addr);\n\n \nstatic bool have_mon_and_osd_map(struct ceph_client *client)\n{\n\treturn client->monc.monmap && client->monc.monmap->epoch &&\n\t       client->osdc.osdmap && client->osdc.osdmap->epoch;\n}\n\n \nint __ceph_open_session(struct ceph_client *client, unsigned long started)\n{\n\tunsigned long timeout = client->options->mount_timeout;\n\tlong err;\n\n\t \n\terr = ceph_monc_open_session(&client->monc);\n\tif (err < 0)\n\t\treturn err;\n\n\twhile (!have_mon_and_osd_map(client)) {\n\t\tif (timeout && time_after_eq(jiffies, started + timeout))\n\t\t\treturn -ETIMEDOUT;\n\n\t\t \n\t\tdout(\"mount waiting for mon_map\\n\");\n\t\terr = wait_event_interruptible_timeout(client->auth_wq,\n\t\t\thave_mon_and_osd_map(client) || (client->auth_err < 0),\n\t\t\tceph_timeout_jiffies(timeout));\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tif (client->auth_err < 0)\n\t\t\treturn client->auth_err;\n\t}\n\n\tpr_info(\"client%llu fsid %pU\\n\", ceph_client_gid(client),\n\t\t&client->fsid);\n\tceph_debugfs_client_init(client);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(__ceph_open_session);\n\nint ceph_open_session(struct ceph_client *client)\n{\n\tint ret;\n\tunsigned long started = jiffies;   \n\n\tdout(\"open_session start\\n\");\n\tmutex_lock(&client->mount_mutex);\n\n\tret = __ceph_open_session(client, started);\n\n\tmutex_unlock(&client->mount_mutex);\n\treturn ret;\n}\nEXPORT_SYMBOL(ceph_open_session);\n\nint ceph_wait_for_latest_osdmap(struct ceph_client *client,\n\t\t\t\tunsigned long timeout)\n{\n\tu64 newest_epoch;\n\tint ret;\n\n\tret = ceph_monc_get_version(&client->monc, \"osdmap\", &newest_epoch);\n\tif (ret)\n\t\treturn ret;\n\n\tif (client->osdc.osdmap->epoch >= newest_epoch)\n\t\treturn 0;\n\n\tceph_osdc_maybe_request_map(&client->osdc);\n\treturn ceph_monc_wait_osdmap(&client->monc, newest_epoch, timeout);\n}\nEXPORT_SYMBOL(ceph_wait_for_latest_osdmap);\n\nstatic int __init init_ceph_lib(void)\n{\n\tint ret = 0;\n\n\tceph_debugfs_init();\n\n\tret = ceph_crypto_init();\n\tif (ret < 0)\n\t\tgoto out_debugfs;\n\n\tret = ceph_msgr_init();\n\tif (ret < 0)\n\t\tgoto out_crypto;\n\n\tret = ceph_osdc_setup();\n\tif (ret < 0)\n\t\tgoto out_msgr;\n\n\tpr_info(\"loaded (mon/osd proto %d/%d)\\n\",\n\t\tCEPH_MONC_PROTOCOL, CEPH_OSDC_PROTOCOL);\n\n\treturn 0;\n\nout_msgr:\n\tceph_msgr_exit();\nout_crypto:\n\tceph_crypto_shutdown();\nout_debugfs:\n\tceph_debugfs_cleanup();\n\treturn ret;\n}\n\nstatic void __exit exit_ceph_lib(void)\n{\n\tdout(\"exit_ceph_lib\\n\");\n\tWARN_ON(!ceph_strings_empty());\n\n\tceph_osdc_cleanup();\n\tceph_msgr_exit();\n\tceph_crypto_shutdown();\n\tceph_debugfs_cleanup();\n}\n\nmodule_init(init_ceph_lib);\nmodule_exit(exit_ceph_lib);\n\nMODULE_AUTHOR(\"Sage Weil <sage@newdream.net>\");\nMODULE_AUTHOR(\"Yehuda Sadeh <yehuda@hq.newdream.net>\");\nMODULE_AUTHOR(\"Patience Warnick <patience@newdream.net>\");\nMODULE_DESCRIPTION(\"Ceph core library\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}