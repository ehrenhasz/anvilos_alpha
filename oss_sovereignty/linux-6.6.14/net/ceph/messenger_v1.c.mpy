{
  "module_name": "messenger_v1.c",
  "hash_id": "e56b27a5f353255e69dd815be7ac472aec39b32dc1c47e1a096625aa7b797a04",
  "original_prompt": "Ingested from linux-6.6.14/net/ceph/messenger_v1.c",
  "human_readable_source": "\n#include <linux/ceph/ceph_debug.h>\n\n#include <linux/bvec.h>\n#include <linux/crc32c.h>\n#include <linux/net.h>\n#include <linux/socket.h>\n#include <net/sock.h>\n\n#include <linux/ceph/ceph_features.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/libceph.h>\n#include <linux/ceph/messenger.h>\n\n \nstatic char tag_msg = CEPH_MSGR_TAG_MSG;\nstatic char tag_ack = CEPH_MSGR_TAG_ACK;\nstatic char tag_keepalive = CEPH_MSGR_TAG_KEEPALIVE;\nstatic char tag_keepalive2 = CEPH_MSGR_TAG_KEEPALIVE2;\n\n \nstatic int ceph_tcp_recvmsg(struct socket *sock, void *buf, size_t len)\n{\n\tstruct kvec iov = {buf, len};\n\tstruct msghdr msg = { .msg_flags = MSG_DONTWAIT | MSG_NOSIGNAL };\n\tint r;\n\n\tif (!buf)\n\t\tmsg.msg_flags |= MSG_TRUNC;\n\n\tiov_iter_kvec(&msg.msg_iter, ITER_DEST, &iov, 1, len);\n\tr = sock_recvmsg(sock, &msg, msg.msg_flags);\n\tif (r == -EAGAIN)\n\t\tr = 0;\n\treturn r;\n}\n\nstatic int ceph_tcp_recvpage(struct socket *sock, struct page *page,\n\t\t     int page_offset, size_t length)\n{\n\tstruct bio_vec bvec;\n\tstruct msghdr msg = { .msg_flags = MSG_DONTWAIT | MSG_NOSIGNAL };\n\tint r;\n\n\tBUG_ON(page_offset + length > PAGE_SIZE);\n\tbvec_set_page(&bvec, page, length, page_offset);\n\tiov_iter_bvec(&msg.msg_iter, ITER_DEST, &bvec, 1, length);\n\tr = sock_recvmsg(sock, &msg, msg.msg_flags);\n\tif (r == -EAGAIN)\n\t\tr = 0;\n\treturn r;\n}\n\n \nstatic int ceph_tcp_sendmsg(struct socket *sock, struct kvec *iov,\n\t\t\t    size_t kvlen, size_t len, bool more)\n{\n\tstruct msghdr msg = { .msg_flags = MSG_DONTWAIT | MSG_NOSIGNAL };\n\tint r;\n\n\tif (more)\n\t\tmsg.msg_flags |= MSG_MORE;\n\telse\n\t\tmsg.msg_flags |= MSG_EOR;   \n\n\tr = kernel_sendmsg(sock, &msg, iov, kvlen, len);\n\tif (r == -EAGAIN)\n\t\tr = 0;\n\treturn r;\n}\n\n \nstatic int ceph_tcp_sendpage(struct socket *sock, struct page *page,\n\t\t\t     int offset, size_t size, int more)\n{\n\tstruct msghdr msg = {\n\t\t.msg_flags = MSG_DONTWAIT | MSG_NOSIGNAL | more,\n\t};\n\tstruct bio_vec bvec;\n\tint ret;\n\n\t \n\tif (sendpage_ok(page))\n\t\tmsg.msg_flags |= MSG_SPLICE_PAGES;\n\n\tbvec_set_page(&bvec, page, size, offset);\n\tiov_iter_bvec(&msg.msg_iter, ITER_SOURCE, &bvec, 1, size);\n\n\tret = sock_sendmsg(sock, &msg);\n\tif (ret == -EAGAIN)\n\t\tret = 0;\n\n\treturn ret;\n}\n\nstatic void con_out_kvec_reset(struct ceph_connection *con)\n{\n\tBUG_ON(con->v1.out_skip);\n\n\tcon->v1.out_kvec_left = 0;\n\tcon->v1.out_kvec_bytes = 0;\n\tcon->v1.out_kvec_cur = &con->v1.out_kvec[0];\n}\n\nstatic void con_out_kvec_add(struct ceph_connection *con,\n\t\t\t\tsize_t size, void *data)\n{\n\tint index = con->v1.out_kvec_left;\n\n\tBUG_ON(con->v1.out_skip);\n\tBUG_ON(index >= ARRAY_SIZE(con->v1.out_kvec));\n\n\tcon->v1.out_kvec[index].iov_len = size;\n\tcon->v1.out_kvec[index].iov_base = data;\n\tcon->v1.out_kvec_left++;\n\tcon->v1.out_kvec_bytes += size;\n}\n\n \nstatic int con_out_kvec_skip(struct ceph_connection *con)\n{\n\tint skip = 0;\n\n\tif (con->v1.out_kvec_bytes > 0) {\n\t\tskip = con->v1.out_kvec_cur[con->v1.out_kvec_left - 1].iov_len;\n\t\tBUG_ON(con->v1.out_kvec_bytes < skip);\n\t\tBUG_ON(!con->v1.out_kvec_left);\n\t\tcon->v1.out_kvec_bytes -= skip;\n\t\tcon->v1.out_kvec_left--;\n\t}\n\n\treturn skip;\n}\n\nstatic size_t sizeof_footer(struct ceph_connection *con)\n{\n\treturn (con->peer_features & CEPH_FEATURE_MSG_AUTH) ?\n\t    sizeof(struct ceph_msg_footer) :\n\t    sizeof(struct ceph_msg_footer_old);\n}\n\nstatic void prepare_message_data(struct ceph_msg *msg, u32 data_len)\n{\n\t \n\tif (!msg->sparse_read)\n\t\tceph_msg_data_cursor_init(&msg->cursor, msg, data_len);\n}\n\n \nstatic void prepare_write_message_footer(struct ceph_connection *con)\n{\n\tstruct ceph_msg *m = con->out_msg;\n\n\tm->footer.flags |= CEPH_MSG_FOOTER_COMPLETE;\n\n\tdout(\"prepare_write_message_footer %p\\n\", con);\n\tcon_out_kvec_add(con, sizeof_footer(con), &m->footer);\n\tif (con->peer_features & CEPH_FEATURE_MSG_AUTH) {\n\t\tif (con->ops->sign_message)\n\t\t\tcon->ops->sign_message(m);\n\t\telse\n\t\t\tm->footer.sig = 0;\n\t} else {\n\t\tm->old_footer.flags = m->footer.flags;\n\t}\n\tcon->v1.out_more = m->more_to_follow;\n\tcon->v1.out_msg_done = true;\n}\n\n \nstatic void prepare_write_message(struct ceph_connection *con)\n{\n\tstruct ceph_msg *m;\n\tu32 crc;\n\n\tcon_out_kvec_reset(con);\n\tcon->v1.out_msg_done = false;\n\n\t \n\tif (con->in_seq > con->in_seq_acked) {\n\t\tcon->in_seq_acked = con->in_seq;\n\t\tcon_out_kvec_add(con, sizeof (tag_ack), &tag_ack);\n\t\tcon->v1.out_temp_ack = cpu_to_le64(con->in_seq_acked);\n\t\tcon_out_kvec_add(con, sizeof(con->v1.out_temp_ack),\n\t\t\t&con->v1.out_temp_ack);\n\t}\n\n\tceph_con_get_out_msg(con);\n\tm = con->out_msg;\n\n\tdout(\"prepare_write_message %p seq %lld type %d len %d+%d+%zd\\n\",\n\t     m, con->out_seq, le16_to_cpu(m->hdr.type),\n\t     le32_to_cpu(m->hdr.front_len), le32_to_cpu(m->hdr.middle_len),\n\t     m->data_length);\n\tWARN_ON(m->front.iov_len != le32_to_cpu(m->hdr.front_len));\n\tWARN_ON(m->data_length != le32_to_cpu(m->hdr.data_len));\n\n\t \n\tcon_out_kvec_add(con, sizeof (tag_msg), &tag_msg);\n\tcon_out_kvec_add(con, sizeof(con->v1.out_hdr), &con->v1.out_hdr);\n\tcon_out_kvec_add(con, m->front.iov_len, m->front.iov_base);\n\n\tif (m->middle)\n\t\tcon_out_kvec_add(con, m->middle->vec.iov_len,\n\t\t\tm->middle->vec.iov_base);\n\n\t \n\tcrc = crc32c(0, &m->hdr, offsetof(struct ceph_msg_header, crc));\n\tcon->out_msg->hdr.crc = cpu_to_le32(crc);\n\tmemcpy(&con->v1.out_hdr, &con->out_msg->hdr, sizeof(con->v1.out_hdr));\n\n\t \n\tcrc = crc32c(0, m->front.iov_base, m->front.iov_len);\n\tcon->out_msg->footer.front_crc = cpu_to_le32(crc);\n\tif (m->middle) {\n\t\tcrc = crc32c(0, m->middle->vec.iov_base,\n\t\t\t\tm->middle->vec.iov_len);\n\t\tcon->out_msg->footer.middle_crc = cpu_to_le32(crc);\n\t} else\n\t\tcon->out_msg->footer.middle_crc = 0;\n\tdout(\"%s front_crc %u middle_crc %u\\n\", __func__,\n\t     le32_to_cpu(con->out_msg->footer.front_crc),\n\t     le32_to_cpu(con->out_msg->footer.middle_crc));\n\tcon->out_msg->footer.flags = 0;\n\n\t \n\tcon->out_msg->footer.data_crc = 0;\n\tif (m->data_length) {\n\t\tprepare_message_data(con->out_msg, m->data_length);\n\t\tcon->v1.out_more = 1;   \n\t} else {\n\t\t \n\t\tprepare_write_message_footer(con);\n\t}\n\n\tceph_con_flag_set(con, CEPH_CON_F_WRITE_PENDING);\n}\n\n \nstatic void prepare_write_ack(struct ceph_connection *con)\n{\n\tdout(\"prepare_write_ack %p %llu -> %llu\\n\", con,\n\t     con->in_seq_acked, con->in_seq);\n\tcon->in_seq_acked = con->in_seq;\n\n\tcon_out_kvec_reset(con);\n\n\tcon_out_kvec_add(con, sizeof (tag_ack), &tag_ack);\n\n\tcon->v1.out_temp_ack = cpu_to_le64(con->in_seq_acked);\n\tcon_out_kvec_add(con, sizeof(con->v1.out_temp_ack),\n\t\t\t &con->v1.out_temp_ack);\n\n\tcon->v1.out_more = 1;   \n\tceph_con_flag_set(con, CEPH_CON_F_WRITE_PENDING);\n}\n\n \nstatic void prepare_write_seq(struct ceph_connection *con)\n{\n\tdout(\"prepare_write_seq %p %llu -> %llu\\n\", con,\n\t     con->in_seq_acked, con->in_seq);\n\tcon->in_seq_acked = con->in_seq;\n\n\tcon_out_kvec_reset(con);\n\n\tcon->v1.out_temp_ack = cpu_to_le64(con->in_seq_acked);\n\tcon_out_kvec_add(con, sizeof(con->v1.out_temp_ack),\n\t\t\t &con->v1.out_temp_ack);\n\n\tceph_con_flag_set(con, CEPH_CON_F_WRITE_PENDING);\n}\n\n \nstatic void prepare_write_keepalive(struct ceph_connection *con)\n{\n\tdout(\"prepare_write_keepalive %p\\n\", con);\n\tcon_out_kvec_reset(con);\n\tif (con->peer_features & CEPH_FEATURE_MSGR_KEEPALIVE2) {\n\t\tstruct timespec64 now;\n\n\t\tktime_get_real_ts64(&now);\n\t\tcon_out_kvec_add(con, sizeof(tag_keepalive2), &tag_keepalive2);\n\t\tceph_encode_timespec64(&con->v1.out_temp_keepalive2, &now);\n\t\tcon_out_kvec_add(con, sizeof(con->v1.out_temp_keepalive2),\n\t\t\t\t &con->v1.out_temp_keepalive2);\n\t} else {\n\t\tcon_out_kvec_add(con, sizeof(tag_keepalive), &tag_keepalive);\n\t}\n\tceph_con_flag_set(con, CEPH_CON_F_WRITE_PENDING);\n}\n\n \n\nstatic int get_connect_authorizer(struct ceph_connection *con)\n{\n\tstruct ceph_auth_handshake *auth;\n\tint auth_proto;\n\n\tif (!con->ops->get_authorizer) {\n\t\tcon->v1.auth = NULL;\n\t\tcon->v1.out_connect.authorizer_protocol = CEPH_AUTH_UNKNOWN;\n\t\tcon->v1.out_connect.authorizer_len = 0;\n\t\treturn 0;\n\t}\n\n\tauth = con->ops->get_authorizer(con, &auth_proto, con->v1.auth_retry);\n\tif (IS_ERR(auth))\n\t\treturn PTR_ERR(auth);\n\n\tcon->v1.auth = auth;\n\tcon->v1.out_connect.authorizer_protocol = cpu_to_le32(auth_proto);\n\tcon->v1.out_connect.authorizer_len =\n\t\tcpu_to_le32(auth->authorizer_buf_len);\n\treturn 0;\n}\n\n \nstatic void prepare_write_banner(struct ceph_connection *con)\n{\n\tcon_out_kvec_add(con, strlen(CEPH_BANNER), CEPH_BANNER);\n\tcon_out_kvec_add(con, sizeof (con->msgr->my_enc_addr),\n\t\t\t\t\t&con->msgr->my_enc_addr);\n\n\tcon->v1.out_more = 0;\n\tceph_con_flag_set(con, CEPH_CON_F_WRITE_PENDING);\n}\n\nstatic void __prepare_write_connect(struct ceph_connection *con)\n{\n\tcon_out_kvec_add(con, sizeof(con->v1.out_connect),\n\t\t\t &con->v1.out_connect);\n\tif (con->v1.auth)\n\t\tcon_out_kvec_add(con, con->v1.auth->authorizer_buf_len,\n\t\t\t\t con->v1.auth->authorizer_buf);\n\n\tcon->v1.out_more = 0;\n\tceph_con_flag_set(con, CEPH_CON_F_WRITE_PENDING);\n}\n\nstatic int prepare_write_connect(struct ceph_connection *con)\n{\n\tunsigned int global_seq = ceph_get_global_seq(con->msgr, 0);\n\tint proto;\n\tint ret;\n\n\tswitch (con->peer_name.type) {\n\tcase CEPH_ENTITY_TYPE_MON:\n\t\tproto = CEPH_MONC_PROTOCOL;\n\t\tbreak;\n\tcase CEPH_ENTITY_TYPE_OSD:\n\t\tproto = CEPH_OSDC_PROTOCOL;\n\t\tbreak;\n\tcase CEPH_ENTITY_TYPE_MDS:\n\t\tproto = CEPH_MDSC_PROTOCOL;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\tdout(\"prepare_write_connect %p cseq=%d gseq=%d proto=%d\\n\", con,\n\t     con->v1.connect_seq, global_seq, proto);\n\n\tcon->v1.out_connect.features =\n\t\tcpu_to_le64(from_msgr(con->msgr)->supported_features);\n\tcon->v1.out_connect.host_type = cpu_to_le32(CEPH_ENTITY_TYPE_CLIENT);\n\tcon->v1.out_connect.connect_seq = cpu_to_le32(con->v1.connect_seq);\n\tcon->v1.out_connect.global_seq = cpu_to_le32(global_seq);\n\tcon->v1.out_connect.protocol_version = cpu_to_le32(proto);\n\tcon->v1.out_connect.flags = 0;\n\n\tret = get_connect_authorizer(con);\n\tif (ret)\n\t\treturn ret;\n\n\t__prepare_write_connect(con);\n\treturn 0;\n}\n\n \nstatic int write_partial_kvec(struct ceph_connection *con)\n{\n\tint ret;\n\n\tdout(\"write_partial_kvec %p %d left\\n\", con, con->v1.out_kvec_bytes);\n\twhile (con->v1.out_kvec_bytes > 0) {\n\t\tret = ceph_tcp_sendmsg(con->sock, con->v1.out_kvec_cur,\n\t\t\t\t       con->v1.out_kvec_left,\n\t\t\t\t       con->v1.out_kvec_bytes,\n\t\t\t\t       con->v1.out_more);\n\t\tif (ret <= 0)\n\t\t\tgoto out;\n\t\tcon->v1.out_kvec_bytes -= ret;\n\t\tif (!con->v1.out_kvec_bytes)\n\t\t\tbreak;             \n\n\t\t \n\t\twhile (ret >= con->v1.out_kvec_cur->iov_len) {\n\t\t\tBUG_ON(!con->v1.out_kvec_left);\n\t\t\tret -= con->v1.out_kvec_cur->iov_len;\n\t\t\tcon->v1.out_kvec_cur++;\n\t\t\tcon->v1.out_kvec_left--;\n\t\t}\n\t\t \n\t\tif (ret) {\n\t\t\tcon->v1.out_kvec_cur->iov_len -= ret;\n\t\t\tcon->v1.out_kvec_cur->iov_base += ret;\n\t\t}\n\t}\n\tcon->v1.out_kvec_left = 0;\n\tret = 1;\nout:\n\tdout(\"write_partial_kvec %p %d left in %d kvecs ret = %d\\n\", con,\n\t     con->v1.out_kvec_bytes, con->v1.out_kvec_left, ret);\n\treturn ret;   \n}\n\n \nstatic int write_partial_message_data(struct ceph_connection *con)\n{\n\tstruct ceph_msg *msg = con->out_msg;\n\tstruct ceph_msg_data_cursor *cursor = &msg->cursor;\n\tbool do_datacrc = !ceph_test_opt(from_msgr(con->msgr), NOCRC);\n\tu32 crc;\n\n\tdout(\"%s %p msg %p\\n\", __func__, con, msg);\n\n\tif (!msg->num_data_items)\n\t\treturn -EINVAL;\n\n\t \n\tcrc = do_datacrc ? le32_to_cpu(msg->footer.data_crc) : 0;\n\twhile (cursor->total_resid) {\n\t\tstruct page *page;\n\t\tsize_t page_offset;\n\t\tsize_t length;\n\t\tint ret;\n\n\t\tif (!cursor->resid) {\n\t\t\tceph_msg_data_advance(cursor, 0);\n\t\t\tcontinue;\n\t\t}\n\n\t\tpage = ceph_msg_data_next(cursor, &page_offset, &length);\n\t\tret = ceph_tcp_sendpage(con->sock, page, page_offset, length,\n\t\t\t\t\tMSG_MORE);\n\t\tif (ret <= 0) {\n\t\t\tif (do_datacrc)\n\t\t\t\tmsg->footer.data_crc = cpu_to_le32(crc);\n\n\t\t\treturn ret;\n\t\t}\n\t\tif (do_datacrc && cursor->need_crc)\n\t\t\tcrc = ceph_crc32c_page(crc, page, page_offset, length);\n\t\tceph_msg_data_advance(cursor, (size_t)ret);\n\t}\n\n\tdout(\"%s %p msg %p done\\n\", __func__, con, msg);\n\n\t \n\tif (do_datacrc)\n\t\tmsg->footer.data_crc = cpu_to_le32(crc);\n\telse\n\t\tmsg->footer.flags |= CEPH_MSG_FOOTER_NOCRC;\n\tcon_out_kvec_reset(con);\n\tprepare_write_message_footer(con);\n\n\treturn 1;\t \n}\n\n \nstatic int write_partial_skip(struct ceph_connection *con)\n{\n\tint ret;\n\n\tdout(\"%s %p %d left\\n\", __func__, con, con->v1.out_skip);\n\twhile (con->v1.out_skip > 0) {\n\t\tsize_t size = min(con->v1.out_skip, (int)PAGE_SIZE);\n\n\t\tret = ceph_tcp_sendpage(con->sock, ceph_zero_page, 0, size,\n\t\t\t\t\tMSG_MORE);\n\t\tif (ret <= 0)\n\t\t\tgoto out;\n\t\tcon->v1.out_skip -= ret;\n\t}\n\tret = 1;\nout:\n\treturn ret;\n}\n\n \nstatic void prepare_read_banner(struct ceph_connection *con)\n{\n\tdout(\"prepare_read_banner %p\\n\", con);\n\tcon->v1.in_base_pos = 0;\n}\n\nstatic void prepare_read_connect(struct ceph_connection *con)\n{\n\tdout(\"prepare_read_connect %p\\n\", con);\n\tcon->v1.in_base_pos = 0;\n}\n\nstatic void prepare_read_ack(struct ceph_connection *con)\n{\n\tdout(\"prepare_read_ack %p\\n\", con);\n\tcon->v1.in_base_pos = 0;\n}\n\nstatic void prepare_read_seq(struct ceph_connection *con)\n{\n\tdout(\"prepare_read_seq %p\\n\", con);\n\tcon->v1.in_base_pos = 0;\n\tcon->v1.in_tag = CEPH_MSGR_TAG_SEQ;\n}\n\nstatic void prepare_read_tag(struct ceph_connection *con)\n{\n\tdout(\"prepare_read_tag %p\\n\", con);\n\tcon->v1.in_base_pos = 0;\n\tcon->v1.in_tag = CEPH_MSGR_TAG_READY;\n}\n\nstatic void prepare_read_keepalive_ack(struct ceph_connection *con)\n{\n\tdout(\"prepare_read_keepalive_ack %p\\n\", con);\n\tcon->v1.in_base_pos = 0;\n}\n\n \nstatic int prepare_read_message(struct ceph_connection *con)\n{\n\tdout(\"prepare_read_message %p\\n\", con);\n\tBUG_ON(con->in_msg != NULL);\n\tcon->v1.in_base_pos = 0;\n\tcon->in_front_crc = con->in_middle_crc = con->in_data_crc = 0;\n\treturn 0;\n}\n\nstatic int read_partial(struct ceph_connection *con,\n\t\t\tint end, int size, void *object)\n{\n\twhile (con->v1.in_base_pos < end) {\n\t\tint left = end - con->v1.in_base_pos;\n\t\tint have = size - left;\n\t\tint ret = ceph_tcp_recvmsg(con->sock, object + have, left);\n\t\tif (ret <= 0)\n\t\t\treturn ret;\n\t\tcon->v1.in_base_pos += ret;\n\t}\n\treturn 1;\n}\n\n \nstatic int read_partial_banner(struct ceph_connection *con)\n{\n\tint size;\n\tint end;\n\tint ret;\n\n\tdout(\"read_partial_banner %p at %d\\n\", con, con->v1.in_base_pos);\n\n\t \n\tsize = strlen(CEPH_BANNER);\n\tend = size;\n\tret = read_partial(con, end, size, con->v1.in_banner);\n\tif (ret <= 0)\n\t\tgoto out;\n\n\tsize = sizeof(con->v1.actual_peer_addr);\n\tend += size;\n\tret = read_partial(con, end, size, &con->v1.actual_peer_addr);\n\tif (ret <= 0)\n\t\tgoto out;\n\tceph_decode_banner_addr(&con->v1.actual_peer_addr);\n\n\tsize = sizeof(con->v1.peer_addr_for_me);\n\tend += size;\n\tret = read_partial(con, end, size, &con->v1.peer_addr_for_me);\n\tif (ret <= 0)\n\t\tgoto out;\n\tceph_decode_banner_addr(&con->v1.peer_addr_for_me);\n\nout:\n\treturn ret;\n}\n\nstatic int read_partial_connect(struct ceph_connection *con)\n{\n\tint size;\n\tint end;\n\tint ret;\n\n\tdout(\"read_partial_connect %p at %d\\n\", con, con->v1.in_base_pos);\n\n\tsize = sizeof(con->v1.in_reply);\n\tend = size;\n\tret = read_partial(con, end, size, &con->v1.in_reply);\n\tif (ret <= 0)\n\t\tgoto out;\n\n\tif (con->v1.auth) {\n\t\tsize = le32_to_cpu(con->v1.in_reply.authorizer_len);\n\t\tif (size > con->v1.auth->authorizer_reply_buf_len) {\n\t\t\tpr_err(\"authorizer reply too big: %d > %zu\\n\", size,\n\t\t\t       con->v1.auth->authorizer_reply_buf_len);\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tend += size;\n\t\tret = read_partial(con, end, size,\n\t\t\t\t   con->v1.auth->authorizer_reply_buf);\n\t\tif (ret <= 0)\n\t\t\tgoto out;\n\t}\n\n\tdout(\"read_partial_connect %p tag %d, con_seq = %u, g_seq = %u\\n\",\n\t     con, con->v1.in_reply.tag,\n\t     le32_to_cpu(con->v1.in_reply.connect_seq),\n\t     le32_to_cpu(con->v1.in_reply.global_seq));\nout:\n\treturn ret;\n}\n\n \nstatic int verify_hello(struct ceph_connection *con)\n{\n\tif (memcmp(con->v1.in_banner, CEPH_BANNER, strlen(CEPH_BANNER))) {\n\t\tpr_err(\"connect to %s got bad banner\\n\",\n\t\t       ceph_pr_addr(&con->peer_addr));\n\t\tcon->error_msg = \"protocol error, bad banner\";\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int process_banner(struct ceph_connection *con)\n{\n\tstruct ceph_entity_addr *my_addr = &con->msgr->inst.addr;\n\n\tdout(\"process_banner on %p\\n\", con);\n\n\tif (verify_hello(con) < 0)\n\t\treturn -1;\n\n\t \n\tif (memcmp(&con->peer_addr, &con->v1.actual_peer_addr,\n\t\t   sizeof(con->peer_addr)) != 0 &&\n\t    !(ceph_addr_is_blank(&con->v1.actual_peer_addr) &&\n\t      con->v1.actual_peer_addr.nonce == con->peer_addr.nonce)) {\n\t\tpr_warn(\"wrong peer, want %s/%u, got %s/%u\\n\",\n\t\t\tceph_pr_addr(&con->peer_addr),\n\t\t\tle32_to_cpu(con->peer_addr.nonce),\n\t\t\tceph_pr_addr(&con->v1.actual_peer_addr),\n\t\t\tle32_to_cpu(con->v1.actual_peer_addr.nonce));\n\t\tcon->error_msg = \"wrong peer at address\";\n\t\treturn -1;\n\t}\n\n\t \n\tif (ceph_addr_is_blank(my_addr)) {\n\t\tmemcpy(&my_addr->in_addr,\n\t\t       &con->v1.peer_addr_for_me.in_addr,\n\t\t       sizeof(con->v1.peer_addr_for_me.in_addr));\n\t\tceph_addr_set_port(my_addr, 0);\n\t\tceph_encode_my_addr(con->msgr);\n\t\tdout(\"process_banner learned my addr is %s\\n\",\n\t\t     ceph_pr_addr(my_addr));\n\t}\n\n\treturn 0;\n}\n\nstatic int process_connect(struct ceph_connection *con)\n{\n\tu64 sup_feat = from_msgr(con->msgr)->supported_features;\n\tu64 req_feat = from_msgr(con->msgr)->required_features;\n\tu64 server_feat = le64_to_cpu(con->v1.in_reply.features);\n\tint ret;\n\n\tdout(\"process_connect on %p tag %d\\n\", con, con->v1.in_tag);\n\n\tif (con->v1.auth) {\n\t\tint len = le32_to_cpu(con->v1.in_reply.authorizer_len);\n\n\t\t \n\t\tif (con->v1.in_reply.tag ==\n\t\t\t\tCEPH_MSGR_TAG_CHALLENGE_AUTHORIZER) {\n\t\t\tret = con->ops->add_authorizer_challenge(\n\t\t\t\tcon, con->v1.auth->authorizer_reply_buf, len);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\n\t\t\tcon_out_kvec_reset(con);\n\t\t\t__prepare_write_connect(con);\n\t\t\tprepare_read_connect(con);\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (len) {\n\t\t\tret = con->ops->verify_authorizer_reply(con);\n\t\t\tif (ret < 0) {\n\t\t\t\tcon->error_msg = \"bad authorize reply\";\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\n\tswitch (con->v1.in_reply.tag) {\n\tcase CEPH_MSGR_TAG_FEATURES:\n\t\tpr_err(\"%s%lld %s feature set mismatch,\"\n\t\t       \" my %llx < server's %llx, missing %llx\\n\",\n\t\t       ENTITY_NAME(con->peer_name),\n\t\t       ceph_pr_addr(&con->peer_addr),\n\t\t       sup_feat, server_feat, server_feat & ~sup_feat);\n\t\tcon->error_msg = \"missing required protocol features\";\n\t\treturn -1;\n\n\tcase CEPH_MSGR_TAG_BADPROTOVER:\n\t\tpr_err(\"%s%lld %s protocol version mismatch,\"\n\t\t       \" my %d != server's %d\\n\",\n\t\t       ENTITY_NAME(con->peer_name),\n\t\t       ceph_pr_addr(&con->peer_addr),\n\t\t       le32_to_cpu(con->v1.out_connect.protocol_version),\n\t\t       le32_to_cpu(con->v1.in_reply.protocol_version));\n\t\tcon->error_msg = \"protocol version mismatch\";\n\t\treturn -1;\n\n\tcase CEPH_MSGR_TAG_BADAUTHORIZER:\n\t\tcon->v1.auth_retry++;\n\t\tdout(\"process_connect %p got BADAUTHORIZER attempt %d\\n\", con,\n\t\t     con->v1.auth_retry);\n\t\tif (con->v1.auth_retry == 2) {\n\t\t\tcon->error_msg = \"connect authorization failure\";\n\t\t\treturn -1;\n\t\t}\n\t\tcon_out_kvec_reset(con);\n\t\tret = prepare_write_connect(con);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tprepare_read_connect(con);\n\t\tbreak;\n\n\tcase CEPH_MSGR_TAG_RESETSESSION:\n\t\t \n\t\tdout(\"process_connect got RESET peer seq %u\\n\",\n\t\t     le32_to_cpu(con->v1.in_reply.connect_seq));\n\t\tpr_info(\"%s%lld %s session reset\\n\",\n\t\t\tENTITY_NAME(con->peer_name),\n\t\t\tceph_pr_addr(&con->peer_addr));\n\t\tceph_con_reset_session(con);\n\t\tcon_out_kvec_reset(con);\n\t\tret = prepare_write_connect(con);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tprepare_read_connect(con);\n\n\t\t \n\t\tmutex_unlock(&con->mutex);\n\t\tif (con->ops->peer_reset)\n\t\t\tcon->ops->peer_reset(con);\n\t\tmutex_lock(&con->mutex);\n\t\tif (con->state != CEPH_CON_S_V1_CONNECT_MSG)\n\t\t\treturn -EAGAIN;\n\t\tbreak;\n\n\tcase CEPH_MSGR_TAG_RETRY_SESSION:\n\t\t \n\t\tdout(\"process_connect got RETRY_SESSION my seq %u, peer %u\\n\",\n\t\t     le32_to_cpu(con->v1.out_connect.connect_seq),\n\t\t     le32_to_cpu(con->v1.in_reply.connect_seq));\n\t\tcon->v1.connect_seq = le32_to_cpu(con->v1.in_reply.connect_seq);\n\t\tcon_out_kvec_reset(con);\n\t\tret = prepare_write_connect(con);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tprepare_read_connect(con);\n\t\tbreak;\n\n\tcase CEPH_MSGR_TAG_RETRY_GLOBAL:\n\t\t \n\t\tdout(\"process_connect got RETRY_GLOBAL my %u peer_gseq %u\\n\",\n\t\t     con->v1.peer_global_seq,\n\t\t     le32_to_cpu(con->v1.in_reply.global_seq));\n\t\tceph_get_global_seq(con->msgr,\n\t\t\t\t    le32_to_cpu(con->v1.in_reply.global_seq));\n\t\tcon_out_kvec_reset(con);\n\t\tret = prepare_write_connect(con);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tprepare_read_connect(con);\n\t\tbreak;\n\n\tcase CEPH_MSGR_TAG_SEQ:\n\tcase CEPH_MSGR_TAG_READY:\n\t\tif (req_feat & ~server_feat) {\n\t\t\tpr_err(\"%s%lld %s protocol feature mismatch,\"\n\t\t\t       \" my required %llx > server's %llx, need %llx\\n\",\n\t\t\t       ENTITY_NAME(con->peer_name),\n\t\t\t       ceph_pr_addr(&con->peer_addr),\n\t\t\t       req_feat, server_feat, req_feat & ~server_feat);\n\t\t\tcon->error_msg = \"missing required protocol features\";\n\t\t\treturn -1;\n\t\t}\n\n\t\tWARN_ON(con->state != CEPH_CON_S_V1_CONNECT_MSG);\n\t\tcon->state = CEPH_CON_S_OPEN;\n\t\tcon->v1.auth_retry = 0;     \n\t\tcon->v1.peer_global_seq =\n\t\t\tle32_to_cpu(con->v1.in_reply.global_seq);\n\t\tcon->v1.connect_seq++;\n\t\tcon->peer_features = server_feat;\n\t\tdout(\"process_connect got READY gseq %d cseq %d (%d)\\n\",\n\t\t     con->v1.peer_global_seq,\n\t\t     le32_to_cpu(con->v1.in_reply.connect_seq),\n\t\t     con->v1.connect_seq);\n\t\tWARN_ON(con->v1.connect_seq !=\n\t\t\tle32_to_cpu(con->v1.in_reply.connect_seq));\n\n\t\tif (con->v1.in_reply.flags & CEPH_MSG_CONNECT_LOSSY)\n\t\t\tceph_con_flag_set(con, CEPH_CON_F_LOSSYTX);\n\n\t\tcon->delay = 0;       \n\n\t\tif (con->v1.in_reply.tag == CEPH_MSGR_TAG_SEQ) {\n\t\t\tprepare_write_seq(con);\n\t\t\tprepare_read_seq(con);\n\t\t} else {\n\t\t\tprepare_read_tag(con);\n\t\t}\n\t\tbreak;\n\n\tcase CEPH_MSGR_TAG_WAIT:\n\t\t \n\t\tcon->error_msg = \"protocol error, got WAIT as client\";\n\t\treturn -1;\n\n\tdefault:\n\t\tcon->error_msg = \"protocol error, garbage tag during connect\";\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\n \nstatic int read_partial_ack(struct ceph_connection *con)\n{\n\tint size = sizeof(con->v1.in_temp_ack);\n\tint end = size;\n\n\treturn read_partial(con, end, size, &con->v1.in_temp_ack);\n}\n\n \nstatic void process_ack(struct ceph_connection *con)\n{\n\tu64 ack = le64_to_cpu(con->v1.in_temp_ack);\n\n\tif (con->v1.in_tag == CEPH_MSGR_TAG_ACK)\n\t\tceph_con_discard_sent(con, ack);\n\telse\n\t\tceph_con_discard_requeued(con, ack);\n\n\tprepare_read_tag(con);\n}\n\nstatic int read_partial_message_chunk(struct ceph_connection *con,\n\t\t\t\t      struct kvec *section,\n\t\t\t\t      unsigned int sec_len, u32 *crc)\n{\n\tint ret, left;\n\n\tBUG_ON(!section);\n\n\twhile (section->iov_len < sec_len) {\n\t\tBUG_ON(section->iov_base == NULL);\n\t\tleft = sec_len - section->iov_len;\n\t\tret = ceph_tcp_recvmsg(con->sock, (char *)section->iov_base +\n\t\t\t\t       section->iov_len, left);\n\t\tif (ret <= 0)\n\t\t\treturn ret;\n\t\tsection->iov_len += ret;\n\t}\n\tif (section->iov_len == sec_len)\n\t\t*crc = crc32c(*crc, section->iov_base, section->iov_len);\n\n\treturn 1;\n}\n\nstatic inline int read_partial_message_section(struct ceph_connection *con,\n\t\t\t\t\t       struct kvec *section,\n\t\t\t\t\t       unsigned int sec_len, u32 *crc)\n{\n\t*crc = 0;\n\treturn read_partial_message_chunk(con, section, sec_len, crc);\n}\n\nstatic int read_sparse_msg_extent(struct ceph_connection *con, u32 *crc)\n{\n\tstruct ceph_msg_data_cursor *cursor = &con->in_msg->cursor;\n\tbool do_bounce = ceph_test_opt(from_msgr(con->msgr), RXBOUNCE);\n\n\tif (do_bounce && unlikely(!con->bounce_page)) {\n\t\tcon->bounce_page = alloc_page(GFP_NOIO);\n\t\tif (!con->bounce_page) {\n\t\t\tpr_err(\"failed to allocate bounce page\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\twhile (cursor->sr_resid > 0) {\n\t\tstruct page *page, *rpage;\n\t\tsize_t off, len;\n\t\tint ret;\n\n\t\tpage = ceph_msg_data_next(cursor, &off, &len);\n\t\trpage = do_bounce ? con->bounce_page : page;\n\n\t\t \n\t\tlen = min_t(int, len, cursor->sr_resid);\n\t\tret = ceph_tcp_recvpage(con->sock, rpage, (int)off, len);\n\t\tif (ret <= 0)\n\t\t\treturn ret;\n\t\t*crc = ceph_crc32c_page(*crc, rpage, off, ret);\n\t\tceph_msg_data_advance(cursor, (size_t)ret);\n\t\tcursor->sr_resid -= ret;\n\t\tif (do_bounce)\n\t\t\tmemcpy_page(page, off, rpage, off, ret);\n\t}\n\treturn 1;\n}\n\nstatic int read_sparse_msg_data(struct ceph_connection *con)\n{\n\tstruct ceph_msg_data_cursor *cursor = &con->in_msg->cursor;\n\tbool do_datacrc = !ceph_test_opt(from_msgr(con->msgr), NOCRC);\n\tu32 crc = 0;\n\tint ret = 1;\n\n\tif (do_datacrc)\n\t\tcrc = con->in_data_crc;\n\n\tdo {\n\t\tif (con->v1.in_sr_kvec.iov_base)\n\t\t\tret = read_partial_message_chunk(con,\n\t\t\t\t\t\t\t &con->v1.in_sr_kvec,\n\t\t\t\t\t\t\t con->v1.in_sr_len,\n\t\t\t\t\t\t\t &crc);\n\t\telse if (cursor->sr_resid > 0)\n\t\t\tret = read_sparse_msg_extent(con, &crc);\n\n\t\tif (ret <= 0) {\n\t\t\tif (do_datacrc)\n\t\t\t\tcon->in_data_crc = crc;\n\t\t\treturn ret;\n\t\t}\n\n\t\tmemset(&con->v1.in_sr_kvec, 0, sizeof(con->v1.in_sr_kvec));\n\t\tret = con->ops->sparse_read(con, cursor,\n\t\t\t\t(char **)&con->v1.in_sr_kvec.iov_base);\n\t\tcon->v1.in_sr_len = ret;\n\t} while (ret > 0);\n\n\tif (do_datacrc)\n\t\tcon->in_data_crc = crc;\n\n\treturn ret < 0 ? ret : 1;   \n}\n\nstatic int read_partial_msg_data(struct ceph_connection *con)\n{\n\tstruct ceph_msg_data_cursor *cursor = &con->in_msg->cursor;\n\tbool do_datacrc = !ceph_test_opt(from_msgr(con->msgr), NOCRC);\n\tstruct page *page;\n\tsize_t page_offset;\n\tsize_t length;\n\tu32 crc = 0;\n\tint ret;\n\n\tif (do_datacrc)\n\t\tcrc = con->in_data_crc;\n\twhile (cursor->total_resid) {\n\t\tif (!cursor->resid) {\n\t\t\tceph_msg_data_advance(cursor, 0);\n\t\t\tcontinue;\n\t\t}\n\n\t\tpage = ceph_msg_data_next(cursor, &page_offset, &length);\n\t\tret = ceph_tcp_recvpage(con->sock, page, page_offset, length);\n\t\tif (ret <= 0) {\n\t\t\tif (do_datacrc)\n\t\t\t\tcon->in_data_crc = crc;\n\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (do_datacrc)\n\t\t\tcrc = ceph_crc32c_page(crc, page, page_offset, ret);\n\t\tceph_msg_data_advance(cursor, (size_t)ret);\n\t}\n\tif (do_datacrc)\n\t\tcon->in_data_crc = crc;\n\n\treturn 1;\t \n}\n\nstatic int read_partial_msg_data_bounce(struct ceph_connection *con)\n{\n\tstruct ceph_msg_data_cursor *cursor = &con->in_msg->cursor;\n\tstruct page *page;\n\tsize_t off, len;\n\tu32 crc;\n\tint ret;\n\n\tif (unlikely(!con->bounce_page)) {\n\t\tcon->bounce_page = alloc_page(GFP_NOIO);\n\t\tif (!con->bounce_page) {\n\t\t\tpr_err(\"failed to allocate bounce page\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\tcrc = con->in_data_crc;\n\twhile (cursor->total_resid) {\n\t\tif (!cursor->resid) {\n\t\t\tceph_msg_data_advance(cursor, 0);\n\t\t\tcontinue;\n\t\t}\n\n\t\tpage = ceph_msg_data_next(cursor, &off, &len);\n\t\tret = ceph_tcp_recvpage(con->sock, con->bounce_page, 0, len);\n\t\tif (ret <= 0) {\n\t\t\tcon->in_data_crc = crc;\n\t\t\treturn ret;\n\t\t}\n\n\t\tcrc = crc32c(crc, page_address(con->bounce_page), ret);\n\t\tmemcpy_to_page(page, off, page_address(con->bounce_page), ret);\n\n\t\tceph_msg_data_advance(cursor, ret);\n\t}\n\tcon->in_data_crc = crc;\n\n\treturn 1;\t \n}\n\n \nstatic int read_partial_message(struct ceph_connection *con)\n{\n\tstruct ceph_msg *m = con->in_msg;\n\tint size;\n\tint end;\n\tint ret;\n\tunsigned int front_len, middle_len, data_len;\n\tbool do_datacrc = !ceph_test_opt(from_msgr(con->msgr), NOCRC);\n\tbool need_sign = (con->peer_features & CEPH_FEATURE_MSG_AUTH);\n\tu64 seq;\n\tu32 crc;\n\n\tdout(\"read_partial_message con %p msg %p\\n\", con, m);\n\n\t \n\tsize = sizeof(con->v1.in_hdr);\n\tend = size;\n\tret = read_partial(con, end, size, &con->v1.in_hdr);\n\tif (ret <= 0)\n\t\treturn ret;\n\n\tcrc = crc32c(0, &con->v1.in_hdr, offsetof(struct ceph_msg_header, crc));\n\tif (cpu_to_le32(crc) != con->v1.in_hdr.crc) {\n\t\tpr_err(\"read_partial_message bad hdr crc %u != expected %u\\n\",\n\t\t       crc, con->v1.in_hdr.crc);\n\t\treturn -EBADMSG;\n\t}\n\n\tfront_len = le32_to_cpu(con->v1.in_hdr.front_len);\n\tif (front_len > CEPH_MSG_MAX_FRONT_LEN)\n\t\treturn -EIO;\n\tmiddle_len = le32_to_cpu(con->v1.in_hdr.middle_len);\n\tif (middle_len > CEPH_MSG_MAX_MIDDLE_LEN)\n\t\treturn -EIO;\n\tdata_len = le32_to_cpu(con->v1.in_hdr.data_len);\n\tif (data_len > CEPH_MSG_MAX_DATA_LEN)\n\t\treturn -EIO;\n\n\t \n\tseq = le64_to_cpu(con->v1.in_hdr.seq);\n\tif ((s64)seq - (s64)con->in_seq < 1) {\n\t\tpr_info(\"skipping %s%lld %s seq %lld expected %lld\\n\",\n\t\t\tENTITY_NAME(con->peer_name),\n\t\t\tceph_pr_addr(&con->peer_addr),\n\t\t\tseq, con->in_seq + 1);\n\t\tcon->v1.in_base_pos = -front_len - middle_len - data_len -\n\t\t\t\t      sizeof_footer(con);\n\t\tcon->v1.in_tag = CEPH_MSGR_TAG_READY;\n\t\treturn 1;\n\t} else if ((s64)seq - (s64)con->in_seq > 1) {\n\t\tpr_err(\"read_partial_message bad seq %lld expected %lld\\n\",\n\t\t       seq, con->in_seq + 1);\n\t\tcon->error_msg = \"bad message sequence # for incoming message\";\n\t\treturn -EBADE;\n\t}\n\n\t \n\tif (!con->in_msg) {\n\t\tint skip = 0;\n\n\t\tdout(\"got hdr type %d front %d data %d\\n\", con->v1.in_hdr.type,\n\t\t     front_len, data_len);\n\t\tret = ceph_con_in_msg_alloc(con, &con->v1.in_hdr, &skip);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tBUG_ON((!con->in_msg) ^ skip);\n\t\tif (skip) {\n\t\t\t \n\t\t\tdout(\"alloc_msg said skip message\\n\");\n\t\t\tcon->v1.in_base_pos = -front_len - middle_len -\n\t\t\t\t\t      data_len - sizeof_footer(con);\n\t\t\tcon->v1.in_tag = CEPH_MSGR_TAG_READY;\n\t\t\tcon->in_seq++;\n\t\t\treturn 1;\n\t\t}\n\n\t\tBUG_ON(!con->in_msg);\n\t\tBUG_ON(con->in_msg->con != con);\n\t\tm = con->in_msg;\n\t\tm->front.iov_len = 0;     \n\t\tif (m->middle)\n\t\t\tm->middle->vec.iov_len = 0;\n\n\t\t \n\n\t\tif (data_len)\n\t\t\tprepare_message_data(con->in_msg, data_len);\n\t}\n\n\t \n\tret = read_partial_message_section(con, &m->front, front_len,\n\t\t\t\t\t   &con->in_front_crc);\n\tif (ret <= 0)\n\t\treturn ret;\n\n\t \n\tif (m->middle) {\n\t\tret = read_partial_message_section(con, &m->middle->vec,\n\t\t\t\t\t\t   middle_len,\n\t\t\t\t\t\t   &con->in_middle_crc);\n\t\tif (ret <= 0)\n\t\t\treturn ret;\n\t}\n\n\t \n\tif (data_len) {\n\t\tif (!m->num_data_items)\n\t\t\treturn -EIO;\n\n\t\tif (m->sparse_read)\n\t\t\tret = read_sparse_msg_data(con);\n\t\telse if (ceph_test_opt(from_msgr(con->msgr), RXBOUNCE))\n\t\t\tret = read_partial_msg_data_bounce(con);\n\t\telse\n\t\t\tret = read_partial_msg_data(con);\n\t\tif (ret <= 0)\n\t\t\treturn ret;\n\t}\n\n\t \n\tsize = sizeof_footer(con);\n\tend += size;\n\tret = read_partial(con, end, size, &m->footer);\n\tif (ret <= 0)\n\t\treturn ret;\n\n\tif (!need_sign) {\n\t\tm->footer.flags = m->old_footer.flags;\n\t\tm->footer.sig = 0;\n\t}\n\n\tdout(\"read_partial_message got msg %p %d (%u) + %d (%u) + %d (%u)\\n\",\n\t     m, front_len, m->footer.front_crc, middle_len,\n\t     m->footer.middle_crc, data_len, m->footer.data_crc);\n\n\t \n\tif (con->in_front_crc != le32_to_cpu(m->footer.front_crc)) {\n\t\tpr_err(\"read_partial_message %p front crc %u != exp. %u\\n\",\n\t\t       m, con->in_front_crc, m->footer.front_crc);\n\t\treturn -EBADMSG;\n\t}\n\tif (con->in_middle_crc != le32_to_cpu(m->footer.middle_crc)) {\n\t\tpr_err(\"read_partial_message %p middle crc %u != exp %u\\n\",\n\t\t       m, con->in_middle_crc, m->footer.middle_crc);\n\t\treturn -EBADMSG;\n\t}\n\tif (do_datacrc &&\n\t    (m->footer.flags & CEPH_MSG_FOOTER_NOCRC) == 0 &&\n\t    con->in_data_crc != le32_to_cpu(m->footer.data_crc)) {\n\t\tpr_err(\"read_partial_message %p data crc %u != exp. %u\\n\", m,\n\t\t       con->in_data_crc, le32_to_cpu(m->footer.data_crc));\n\t\treturn -EBADMSG;\n\t}\n\n\tif (need_sign && con->ops->check_message_signature &&\n\t    con->ops->check_message_signature(m)) {\n\t\tpr_err(\"read_partial_message %p signature check failed\\n\", m);\n\t\treturn -EBADMSG;\n\t}\n\n\treturn 1;  \n}\n\nstatic int read_keepalive_ack(struct ceph_connection *con)\n{\n\tstruct ceph_timespec ceph_ts;\n\tsize_t size = sizeof(ceph_ts);\n\tint ret = read_partial(con, size, size, &ceph_ts);\n\tif (ret <= 0)\n\t\treturn ret;\n\tceph_decode_timespec64(&con->last_keepalive_ack, &ceph_ts);\n\tprepare_read_tag(con);\n\treturn 1;\n}\n\n \nint ceph_con_v1_try_read(struct ceph_connection *con)\n{\n\tint ret = -1;\n\nmore:\n\tdout(\"try_read start %p state %d\\n\", con, con->state);\n\tif (con->state != CEPH_CON_S_V1_BANNER &&\n\t    con->state != CEPH_CON_S_V1_CONNECT_MSG &&\n\t    con->state != CEPH_CON_S_OPEN)\n\t\treturn 0;\n\n\tBUG_ON(!con->sock);\n\n\tdout(\"try_read tag %d in_base_pos %d\\n\", con->v1.in_tag,\n\t     con->v1.in_base_pos);\n\n\tif (con->state == CEPH_CON_S_V1_BANNER) {\n\t\tret = read_partial_banner(con);\n\t\tif (ret <= 0)\n\t\t\tgoto out;\n\t\tret = process_banner(con);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tcon->state = CEPH_CON_S_V1_CONNECT_MSG;\n\n\t\t \n\t\tret = prepare_write_connect(con);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tprepare_read_connect(con);\n\n\t\t \n\t\tgoto out;\n\t}\n\n\tif (con->state == CEPH_CON_S_V1_CONNECT_MSG) {\n\t\tret = read_partial_connect(con);\n\t\tif (ret <= 0)\n\t\t\tgoto out;\n\t\tret = process_connect(con);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tgoto more;\n\t}\n\n\tWARN_ON(con->state != CEPH_CON_S_OPEN);\n\n\tif (con->v1.in_base_pos < 0) {\n\t\t \n\t\tret = ceph_tcp_recvmsg(con->sock, NULL, -con->v1.in_base_pos);\n\t\tif (ret <= 0)\n\t\t\tgoto out;\n\t\tdout(\"skipped %d / %d bytes\\n\", ret, -con->v1.in_base_pos);\n\t\tcon->v1.in_base_pos += ret;\n\t\tif (con->v1.in_base_pos)\n\t\t\tgoto more;\n\t}\n\tif (con->v1.in_tag == CEPH_MSGR_TAG_READY) {\n\t\t \n\t\tret = ceph_tcp_recvmsg(con->sock, &con->v1.in_tag, 1);\n\t\tif (ret <= 0)\n\t\t\tgoto out;\n\t\tdout(\"try_read got tag %d\\n\", con->v1.in_tag);\n\t\tswitch (con->v1.in_tag) {\n\t\tcase CEPH_MSGR_TAG_MSG:\n\t\t\tprepare_read_message(con);\n\t\t\tbreak;\n\t\tcase CEPH_MSGR_TAG_ACK:\n\t\t\tprepare_read_ack(con);\n\t\t\tbreak;\n\t\tcase CEPH_MSGR_TAG_KEEPALIVE2_ACK:\n\t\t\tprepare_read_keepalive_ack(con);\n\t\t\tbreak;\n\t\tcase CEPH_MSGR_TAG_CLOSE:\n\t\t\tceph_con_close_socket(con);\n\t\t\tcon->state = CEPH_CON_S_CLOSED;\n\t\t\tgoto out;\n\t\tdefault:\n\t\t\tgoto bad_tag;\n\t\t}\n\t}\n\tif (con->v1.in_tag == CEPH_MSGR_TAG_MSG) {\n\t\tret = read_partial_message(con);\n\t\tif (ret <= 0) {\n\t\t\tswitch (ret) {\n\t\t\tcase -EBADMSG:\n\t\t\t\tcon->error_msg = \"bad crc/signature\";\n\t\t\t\tfallthrough;\n\t\t\tcase -EBADE:\n\t\t\t\tret = -EIO;\n\t\t\t\tbreak;\n\t\t\tcase -EIO:\n\t\t\t\tcon->error_msg = \"io error\";\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tgoto out;\n\t\t}\n\t\tif (con->v1.in_tag == CEPH_MSGR_TAG_READY)\n\t\t\tgoto more;\n\t\tceph_con_process_message(con);\n\t\tif (con->state == CEPH_CON_S_OPEN)\n\t\t\tprepare_read_tag(con);\n\t\tgoto more;\n\t}\n\tif (con->v1.in_tag == CEPH_MSGR_TAG_ACK ||\n\t    con->v1.in_tag == CEPH_MSGR_TAG_SEQ) {\n\t\t \n\t\tret = read_partial_ack(con);\n\t\tif (ret <= 0)\n\t\t\tgoto out;\n\t\tprocess_ack(con);\n\t\tgoto more;\n\t}\n\tif (con->v1.in_tag == CEPH_MSGR_TAG_KEEPALIVE2_ACK) {\n\t\tret = read_keepalive_ack(con);\n\t\tif (ret <= 0)\n\t\t\tgoto out;\n\t\tgoto more;\n\t}\n\nout:\n\tdout(\"try_read done on %p ret %d\\n\", con, ret);\n\treturn ret;\n\nbad_tag:\n\tpr_err(\"try_read bad tag %d\\n\", con->v1.in_tag);\n\tcon->error_msg = \"protocol error, garbage tag\";\n\tret = -1;\n\tgoto out;\n}\n\n \nint ceph_con_v1_try_write(struct ceph_connection *con)\n{\n\tint ret = 1;\n\n\tdout(\"try_write start %p state %d\\n\", con, con->state);\n\tif (con->state != CEPH_CON_S_PREOPEN &&\n\t    con->state != CEPH_CON_S_V1_BANNER &&\n\t    con->state != CEPH_CON_S_V1_CONNECT_MSG &&\n\t    con->state != CEPH_CON_S_OPEN)\n\t\treturn 0;\n\n\t \n\tif (con->state == CEPH_CON_S_PREOPEN) {\n\t\tBUG_ON(con->sock);\n\t\tcon->state = CEPH_CON_S_V1_BANNER;\n\n\t\tcon_out_kvec_reset(con);\n\t\tprepare_write_banner(con);\n\t\tprepare_read_banner(con);\n\n\t\tBUG_ON(con->in_msg);\n\t\tcon->v1.in_tag = CEPH_MSGR_TAG_READY;\n\t\tdout(\"try_write initiating connect on %p new state %d\\n\",\n\t\t     con, con->state);\n\t\tret = ceph_tcp_connect(con);\n\t\tif (ret < 0) {\n\t\t\tcon->error_msg = \"connect error\";\n\t\t\tgoto out;\n\t\t}\n\t}\n\nmore:\n\tdout(\"try_write out_kvec_bytes %d\\n\", con->v1.out_kvec_bytes);\n\tBUG_ON(!con->sock);\n\n\t \n\tif (con->v1.out_kvec_left) {\n\t\tret = write_partial_kvec(con);\n\t\tif (ret <= 0)\n\t\t\tgoto out;\n\t}\n\tif (con->v1.out_skip) {\n\t\tret = write_partial_skip(con);\n\t\tif (ret <= 0)\n\t\t\tgoto out;\n\t}\n\n\t \n\tif (con->out_msg) {\n\t\tif (con->v1.out_msg_done) {\n\t\t\tceph_msg_put(con->out_msg);\n\t\t\tcon->out_msg = NULL;    \n\t\t\tgoto do_next;\n\t\t}\n\n\t\tret = write_partial_message_data(con);\n\t\tif (ret == 1)\n\t\t\tgoto more;   \n\t\tif (ret == 0)\n\t\t\tgoto out;\n\t\tif (ret < 0) {\n\t\t\tdout(\"try_write write_partial_message_data err %d\\n\",\n\t\t\t     ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\ndo_next:\n\tif (con->state == CEPH_CON_S_OPEN) {\n\t\tif (ceph_con_flag_test_and_clear(con,\n\t\t\t\tCEPH_CON_F_KEEPALIVE_PENDING)) {\n\t\t\tprepare_write_keepalive(con);\n\t\t\tgoto more;\n\t\t}\n\t\t \n\t\tif (!list_empty(&con->out_queue)) {\n\t\t\tprepare_write_message(con);\n\t\t\tgoto more;\n\t\t}\n\t\tif (con->in_seq > con->in_seq_acked) {\n\t\t\tprepare_write_ack(con);\n\t\t\tgoto more;\n\t\t}\n\t}\n\n\t \n\tceph_con_flag_clear(con, CEPH_CON_F_WRITE_PENDING);\n\tdout(\"try_write nothing else to write.\\n\");\n\tret = 0;\nout:\n\tdout(\"try_write done on %p ret %d\\n\", con, ret);\n\treturn ret;\n}\n\nvoid ceph_con_v1_revoke(struct ceph_connection *con)\n{\n\tstruct ceph_msg *msg = con->out_msg;\n\n\tWARN_ON(con->v1.out_skip);\n\t \n\tif (con->v1.out_msg_done) {\n\t\tcon->v1.out_skip += con_out_kvec_skip(con);\n\t} else {\n\t\tWARN_ON(!msg->data_length);\n\t\tcon->v1.out_skip += sizeof_footer(con);\n\t}\n\t \n\tif (msg->data_length)\n\t\tcon->v1.out_skip += msg->cursor.total_resid;\n\tif (msg->middle)\n\t\tcon->v1.out_skip += con_out_kvec_skip(con);\n\tcon->v1.out_skip += con_out_kvec_skip(con);\n\n\tdout(\"%s con %p out_kvec_bytes %d out_skip %d\\n\", __func__, con,\n\t     con->v1.out_kvec_bytes, con->v1.out_skip);\n}\n\nvoid ceph_con_v1_revoke_incoming(struct ceph_connection *con)\n{\n\tunsigned int front_len = le32_to_cpu(con->v1.in_hdr.front_len);\n\tunsigned int middle_len = le32_to_cpu(con->v1.in_hdr.middle_len);\n\tunsigned int data_len = le32_to_cpu(con->v1.in_hdr.data_len);\n\n\t \n\tcon->v1.in_base_pos = con->v1.in_base_pos -\n\t\t\tsizeof(struct ceph_msg_header) -\n\t\t\tfront_len -\n\t\t\tmiddle_len -\n\t\t\tdata_len -\n\t\t\tsizeof(struct ceph_msg_footer);\n\n\tcon->v1.in_tag = CEPH_MSGR_TAG_READY;\n\tcon->in_seq++;\n\n\tdout(\"%s con %p in_base_pos %d\\n\", __func__, con, con->v1.in_base_pos);\n}\n\nbool ceph_con_v1_opened(struct ceph_connection *con)\n{\n\treturn con->v1.connect_seq;\n}\n\nvoid ceph_con_v1_reset_session(struct ceph_connection *con)\n{\n\tcon->v1.connect_seq = 0;\n\tcon->v1.peer_global_seq = 0;\n}\n\nvoid ceph_con_v1_reset_protocol(struct ceph_connection *con)\n{\n\tcon->v1.out_skip = 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}