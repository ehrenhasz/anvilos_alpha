{
  "module_name": "debugfs.c",
  "hash_id": "08329817fbbf29c05806f50fb11b97fda9f0acfc1c769d4bd229b5bf71f8f46b",
  "original_prompt": "Ingested from linux-6.6.14/net/ceph/debugfs.c",
  "human_readable_source": "\n#include <linux/ceph/ceph_debug.h>\n\n#include <linux/device.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n\n#include <linux/ceph/libceph.h>\n#include <linux/ceph/mon_client.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/debugfs.h>\n\n#ifdef CONFIG_DEBUG_FS\n\n \n\nstatic struct dentry *ceph_debugfs_dir;\n\nstatic int monmap_show(struct seq_file *s, void *p)\n{\n\tint i;\n\tstruct ceph_client *client = s->private;\n\n\tif (client->monc.monmap == NULL)\n\t\treturn 0;\n\n\tseq_printf(s, \"epoch %d\\n\", client->monc.monmap->epoch);\n\tfor (i = 0; i < client->monc.monmap->num_mon; i++) {\n\t\tstruct ceph_entity_inst *inst =\n\t\t\t&client->monc.monmap->mon_inst[i];\n\n\t\tseq_printf(s, \"\\t%s%lld\\t%s\\n\",\n\t\t\t   ENTITY_NAME(inst->name),\n\t\t\t   ceph_pr_addr(&inst->addr));\n\t}\n\treturn 0;\n}\n\nstatic int osdmap_show(struct seq_file *s, void *p)\n{\n\tint i;\n\tstruct ceph_client *client = s->private;\n\tstruct ceph_osd_client *osdc = &client->osdc;\n\tstruct ceph_osdmap *map = osdc->osdmap;\n\tstruct rb_node *n;\n\n\tif (map == NULL)\n\t\treturn 0;\n\n\tdown_read(&osdc->lock);\n\tseq_printf(s, \"epoch %u barrier %u flags 0x%x\\n\", map->epoch,\n\t\t\tosdc->epoch_barrier, map->flags);\n\n\tfor (n = rb_first(&map->pg_pools); n; n = rb_next(n)) {\n\t\tstruct ceph_pg_pool_info *pi =\n\t\t\trb_entry(n, struct ceph_pg_pool_info, node);\n\n\t\tseq_printf(s, \"pool %lld '%s' type %d size %d min_size %d pg_num %u pg_num_mask %d flags 0x%llx lfor %u read_tier %lld write_tier %lld\\n\",\n\t\t\t   pi->id, pi->name, pi->type, pi->size, pi->min_size,\n\t\t\t   pi->pg_num, pi->pg_num_mask, pi->flags,\n\t\t\t   pi->last_force_request_resend, pi->read_tier,\n\t\t\t   pi->write_tier);\n\t}\n\tfor (i = 0; i < map->max_osd; i++) {\n\t\tstruct ceph_entity_addr *addr = &map->osd_addr[i];\n\t\tu32 state = map->osd_state[i];\n\t\tchar sb[64];\n\n\t\tseq_printf(s, \"osd%d\\t%s\\t%3d%%\\t(%s)\\t%3d%%\\t%2d\\n\",\n\t\t\t   i, ceph_pr_addr(addr),\n\t\t\t   ((map->osd_weight[i]*100) >> 16),\n\t\t\t   ceph_osdmap_state_str(sb, sizeof(sb), state),\n\t\t\t   ((ceph_get_primary_affinity(map, i)*100) >> 16),\n\t\t\t   ceph_get_crush_locality(map, i,\n\t\t\t\t\t   &client->options->crush_locs));\n\t}\n\tfor (n = rb_first(&map->pg_temp); n; n = rb_next(n)) {\n\t\tstruct ceph_pg_mapping *pg =\n\t\t\trb_entry(n, struct ceph_pg_mapping, node);\n\n\t\tseq_printf(s, \"pg_temp %llu.%x [\", pg->pgid.pool,\n\t\t\t   pg->pgid.seed);\n\t\tfor (i = 0; i < pg->pg_temp.len; i++)\n\t\t\tseq_printf(s, \"%s%d\", (i == 0 ? \"\" : \",\"),\n\t\t\t\t   pg->pg_temp.osds[i]);\n\t\tseq_printf(s, \"]\\n\");\n\t}\n\tfor (n = rb_first(&map->primary_temp); n; n = rb_next(n)) {\n\t\tstruct ceph_pg_mapping *pg =\n\t\t\trb_entry(n, struct ceph_pg_mapping, node);\n\n\t\tseq_printf(s, \"primary_temp %llu.%x %d\\n\", pg->pgid.pool,\n\t\t\t   pg->pgid.seed, pg->primary_temp.osd);\n\t}\n\tfor (n = rb_first(&map->pg_upmap); n; n = rb_next(n)) {\n\t\tstruct ceph_pg_mapping *pg =\n\t\t\trb_entry(n, struct ceph_pg_mapping, node);\n\n\t\tseq_printf(s, \"pg_upmap %llu.%x [\", pg->pgid.pool,\n\t\t\t   pg->pgid.seed);\n\t\tfor (i = 0; i < pg->pg_upmap.len; i++)\n\t\t\tseq_printf(s, \"%s%d\", (i == 0 ? \"\" : \",\"),\n\t\t\t\t   pg->pg_upmap.osds[i]);\n\t\tseq_printf(s, \"]\\n\");\n\t}\n\tfor (n = rb_first(&map->pg_upmap_items); n; n = rb_next(n)) {\n\t\tstruct ceph_pg_mapping *pg =\n\t\t\trb_entry(n, struct ceph_pg_mapping, node);\n\n\t\tseq_printf(s, \"pg_upmap_items %llu.%x [\", pg->pgid.pool,\n\t\t\t   pg->pgid.seed);\n\t\tfor (i = 0; i < pg->pg_upmap_items.len; i++)\n\t\t\tseq_printf(s, \"%s%d->%d\", (i == 0 ? \"\" : \",\"),\n\t\t\t\t   pg->pg_upmap_items.from_to[i][0],\n\t\t\t\t   pg->pg_upmap_items.from_to[i][1]);\n\t\tseq_printf(s, \"]\\n\");\n\t}\n\n\tup_read(&osdc->lock);\n\treturn 0;\n}\n\nstatic int monc_show(struct seq_file *s, void *p)\n{\n\tstruct ceph_client *client = s->private;\n\tstruct ceph_mon_generic_request *req;\n\tstruct ceph_mon_client *monc = &client->monc;\n\tstruct rb_node *rp;\n\tint i;\n\n\tmutex_lock(&monc->mutex);\n\n\tfor (i = 0; i < ARRAY_SIZE(monc->subs); i++) {\n\t\tseq_printf(s, \"have %s %u\", ceph_sub_str[i],\n\t\t\t   monc->subs[i].have);\n\t\tif (monc->subs[i].want)\n\t\t\tseq_printf(s, \" want %llu%s\",\n\t\t\t\t   le64_to_cpu(monc->subs[i].item.start),\n\t\t\t\t   (monc->subs[i].item.flags &\n\t\t\t\t\tCEPH_SUBSCRIBE_ONETIME ?  \"\" : \"+\"));\n\t\tseq_putc(s, '\\n');\n\t}\n\tseq_printf(s, \"fs_cluster_id %d\\n\", monc->fs_cluster_id);\n\n\tfor (rp = rb_first(&monc->generic_request_tree); rp; rp = rb_next(rp)) {\n\t\t__u16 op;\n\t\treq = rb_entry(rp, struct ceph_mon_generic_request, node);\n\t\top = le16_to_cpu(req->request->hdr.type);\n\t\tif (op == CEPH_MSG_STATFS)\n\t\t\tseq_printf(s, \"%llu statfs\\n\", req->tid);\n\t\telse if (op == CEPH_MSG_MON_GET_VERSION)\n\t\t\tseq_printf(s, \"%llu mon_get_version\", req->tid);\n\t\telse\n\t\t\tseq_printf(s, \"%llu unknown\\n\", req->tid);\n\t}\n\n\tmutex_unlock(&monc->mutex);\n\treturn 0;\n}\n\nstatic void dump_spgid(struct seq_file *s, const struct ceph_spg *spgid)\n{\n\tseq_printf(s, \"%llu.%x\", spgid->pgid.pool, spgid->pgid.seed);\n\tif (spgid->shard != CEPH_SPG_NOSHARD)\n\t\tseq_printf(s, \"s%d\", spgid->shard);\n}\n\nstatic void dump_target(struct seq_file *s, struct ceph_osd_request_target *t)\n{\n\tint i;\n\n\tseq_printf(s, \"osd%d\\t%llu.%x\\t\", t->osd, t->pgid.pool, t->pgid.seed);\n\tdump_spgid(s, &t->spgid);\n\tseq_puts(s, \"\\t[\");\n\tfor (i = 0; i < t->up.size; i++)\n\t\tseq_printf(s, \"%s%d\", (!i ? \"\" : \",\"), t->up.osds[i]);\n\tseq_printf(s, \"]/%d\\t[\", t->up.primary);\n\tfor (i = 0; i < t->acting.size; i++)\n\t\tseq_printf(s, \"%s%d\", (!i ? \"\" : \",\"), t->acting.osds[i]);\n\tseq_printf(s, \"]/%d\\te%u\\t\", t->acting.primary, t->epoch);\n\tif (t->target_oloc.pool_ns) {\n\t\tseq_printf(s, \"%*pE/%*pE\\t0x%x\",\n\t\t\t(int)t->target_oloc.pool_ns->len,\n\t\t\tt->target_oloc.pool_ns->str,\n\t\t\tt->target_oid.name_len, t->target_oid.name, t->flags);\n\t} else {\n\t\tseq_printf(s, \"%*pE\\t0x%x\", t->target_oid.name_len,\n\t\t\tt->target_oid.name, t->flags);\n\t}\n\tif (t->paused)\n\t\tseq_puts(s, \"\\tP\");\n}\n\nstatic void dump_request(struct seq_file *s, struct ceph_osd_request *req)\n{\n\tint i;\n\n\tseq_printf(s, \"%llu\\t\", req->r_tid);\n\tdump_target(s, &req->r_t);\n\n\tseq_printf(s, \"\\t%d\", req->r_attempts);\n\n\tfor (i = 0; i < req->r_num_ops; i++) {\n\t\tstruct ceph_osd_req_op *op = &req->r_ops[i];\n\n\t\tseq_printf(s, \"%s%s\", (i == 0 ? \"\\t\" : \",\"),\n\t\t\t   ceph_osd_op_name(op->op));\n\t\tif (op->op == CEPH_OSD_OP_WATCH)\n\t\t\tseq_printf(s, \"-%s\",\n\t\t\t\t   ceph_osd_watch_op_name(op->watch.op));\n\t\telse if (op->op == CEPH_OSD_OP_CALL)\n\t\t\tseq_printf(s, \"-%s/%s\", op->cls.class_name,\n\t\t\t\t   op->cls.method_name);\n\t}\n\n\tseq_putc(s, '\\n');\n}\n\nstatic void dump_requests(struct seq_file *s, struct ceph_osd *osd)\n{\n\tstruct rb_node *n;\n\n\tmutex_lock(&osd->lock);\n\tfor (n = rb_first(&osd->o_requests); n; n = rb_next(n)) {\n\t\tstruct ceph_osd_request *req =\n\t\t    rb_entry(n, struct ceph_osd_request, r_node);\n\n\t\tdump_request(s, req);\n\t}\n\n\tmutex_unlock(&osd->lock);\n}\n\nstatic void dump_linger_request(struct seq_file *s,\n\t\t\t\tstruct ceph_osd_linger_request *lreq)\n{\n\tseq_printf(s, \"%llu\\t\", lreq->linger_id);\n\tdump_target(s, &lreq->t);\n\n\tseq_printf(s, \"\\t%u\\t%s%s/%d\\n\", lreq->register_gen,\n\t\t   lreq->is_watch ? \"W\" : \"N\", lreq->committed ? \"C\" : \"\",\n\t\t   lreq->last_error);\n}\n\nstatic void dump_linger_requests(struct seq_file *s, struct ceph_osd *osd)\n{\n\tstruct rb_node *n;\n\n\tmutex_lock(&osd->lock);\n\tfor (n = rb_first(&osd->o_linger_requests); n; n = rb_next(n)) {\n\t\tstruct ceph_osd_linger_request *lreq =\n\t\t    rb_entry(n, struct ceph_osd_linger_request, node);\n\n\t\tdump_linger_request(s, lreq);\n\t}\n\n\tmutex_unlock(&osd->lock);\n}\n\nstatic void dump_snapid(struct seq_file *s, u64 snapid)\n{\n\tif (snapid == CEPH_NOSNAP)\n\t\tseq_puts(s, \"head\");\n\telse if (snapid == CEPH_SNAPDIR)\n\t\tseq_puts(s, \"snapdir\");\n\telse\n\t\tseq_printf(s, \"%llx\", snapid);\n}\n\nstatic void dump_name_escaped(struct seq_file *s, unsigned char *name,\n\t\t\t      size_t len)\n{\n\tsize_t i;\n\n\tfor (i = 0; i < len; i++) {\n\t\tif (name[i] == '%' || name[i] == ':' || name[i] == '/' ||\n\t\t    name[i] < 32 || name[i] >= 127) {\n\t\t\tseq_printf(s, \"%%%02x\", name[i]);\n\t\t} else {\n\t\t\tseq_putc(s, name[i]);\n\t\t}\n\t}\n}\n\nstatic void dump_hoid(struct seq_file *s, const struct ceph_hobject_id *hoid)\n{\n\tif (hoid->snapid == 0 && hoid->hash == 0 && !hoid->is_max &&\n\t    hoid->pool == S64_MIN) {\n\t\tseq_puts(s, \"MIN\");\n\t\treturn;\n\t}\n\tif (hoid->is_max) {\n\t\tseq_puts(s, \"MAX\");\n\t\treturn;\n\t}\n\tseq_printf(s, \"%lld:%08x:\", hoid->pool, hoid->hash_reverse_bits);\n\tdump_name_escaped(s, hoid->nspace, hoid->nspace_len);\n\tseq_putc(s, ':');\n\tdump_name_escaped(s, hoid->key, hoid->key_len);\n\tseq_putc(s, ':');\n\tdump_name_escaped(s, hoid->oid, hoid->oid_len);\n\tseq_putc(s, ':');\n\tdump_snapid(s, hoid->snapid);\n}\n\nstatic void dump_backoffs(struct seq_file *s, struct ceph_osd *osd)\n{\n\tstruct rb_node *n;\n\n\tmutex_lock(&osd->lock);\n\tfor (n = rb_first(&osd->o_backoffs_by_id); n; n = rb_next(n)) {\n\t\tstruct ceph_osd_backoff *backoff =\n\t\t    rb_entry(n, struct ceph_osd_backoff, id_node);\n\n\t\tseq_printf(s, \"osd%d\\t\", osd->o_osd);\n\t\tdump_spgid(s, &backoff->spgid);\n\t\tseq_printf(s, \"\\t%llu\\t\", backoff->id);\n\t\tdump_hoid(s, backoff->begin);\n\t\tseq_putc(s, '\\t');\n\t\tdump_hoid(s, backoff->end);\n\t\tseq_putc(s, '\\n');\n\t}\n\n\tmutex_unlock(&osd->lock);\n}\n\nstatic int osdc_show(struct seq_file *s, void *pp)\n{\n\tstruct ceph_client *client = s->private;\n\tstruct ceph_osd_client *osdc = &client->osdc;\n\tstruct rb_node *n;\n\n\tdown_read(&osdc->lock);\n\tseq_printf(s, \"REQUESTS %d homeless %d\\n\",\n\t\t   atomic_read(&osdc->num_requests),\n\t\t   atomic_read(&osdc->num_homeless));\n\tfor (n = rb_first(&osdc->osds); n; n = rb_next(n)) {\n\t\tstruct ceph_osd *osd = rb_entry(n, struct ceph_osd, o_node);\n\n\t\tdump_requests(s, osd);\n\t}\n\tdump_requests(s, &osdc->homeless_osd);\n\n\tseq_puts(s, \"LINGER REQUESTS\\n\");\n\tfor (n = rb_first(&osdc->osds); n; n = rb_next(n)) {\n\t\tstruct ceph_osd *osd = rb_entry(n, struct ceph_osd, o_node);\n\n\t\tdump_linger_requests(s, osd);\n\t}\n\tdump_linger_requests(s, &osdc->homeless_osd);\n\n\tseq_puts(s, \"BACKOFFS\\n\");\n\tfor (n = rb_first(&osdc->osds); n; n = rb_next(n)) {\n\t\tstruct ceph_osd *osd = rb_entry(n, struct ceph_osd, o_node);\n\n\t\tdump_backoffs(s, osd);\n\t}\n\n\tup_read(&osdc->lock);\n\treturn 0;\n}\n\nstatic int client_options_show(struct seq_file *s, void *p)\n{\n\tstruct ceph_client *client = s->private;\n\tint ret;\n\n\tret = ceph_print_client_options(s, client, true);\n\tif (ret)\n\t\treturn ret;\n\n\tseq_putc(s, '\\n');\n\treturn 0;\n}\n\nDEFINE_SHOW_ATTRIBUTE(monmap);\nDEFINE_SHOW_ATTRIBUTE(osdmap);\nDEFINE_SHOW_ATTRIBUTE(monc);\nDEFINE_SHOW_ATTRIBUTE(osdc);\nDEFINE_SHOW_ATTRIBUTE(client_options);\n\nvoid __init ceph_debugfs_init(void)\n{\n\tceph_debugfs_dir = debugfs_create_dir(\"ceph\", NULL);\n}\n\nvoid ceph_debugfs_cleanup(void)\n{\n\tdebugfs_remove(ceph_debugfs_dir);\n}\n\nvoid ceph_debugfs_client_init(struct ceph_client *client)\n{\n\tchar name[80];\n\n\tsnprintf(name, sizeof(name), \"%pU.client%lld\", &client->fsid,\n\t\t client->monc.auth->global_id);\n\n\tdout(\"ceph_debugfs_client_init %p %s\\n\", client, name);\n\n\tclient->debugfs_dir = debugfs_create_dir(name, ceph_debugfs_dir);\n\n\tclient->monc.debugfs_file = debugfs_create_file(\"monc\",\n\t\t\t\t\t\t      0400,\n\t\t\t\t\t\t      client->debugfs_dir,\n\t\t\t\t\t\t      client,\n\t\t\t\t\t\t      &monc_fops);\n\n\tclient->osdc.debugfs_file = debugfs_create_file(\"osdc\",\n\t\t\t\t\t\t      0400,\n\t\t\t\t\t\t      client->debugfs_dir,\n\t\t\t\t\t\t      client,\n\t\t\t\t\t\t      &osdc_fops);\n\n\tclient->debugfs_monmap = debugfs_create_file(\"monmap\",\n\t\t\t\t\t0400,\n\t\t\t\t\tclient->debugfs_dir,\n\t\t\t\t\tclient,\n\t\t\t\t\t&monmap_fops);\n\n\tclient->debugfs_osdmap = debugfs_create_file(\"osdmap\",\n\t\t\t\t\t0400,\n\t\t\t\t\tclient->debugfs_dir,\n\t\t\t\t\tclient,\n\t\t\t\t\t&osdmap_fops);\n\n\tclient->debugfs_options = debugfs_create_file(\"client_options\",\n\t\t\t\t\t0400,\n\t\t\t\t\tclient->debugfs_dir,\n\t\t\t\t\tclient,\n\t\t\t\t\t&client_options_fops);\n}\n\nvoid ceph_debugfs_client_cleanup(struct ceph_client *client)\n{\n\tdout(\"ceph_debugfs_client_cleanup %p\\n\", client);\n\tdebugfs_remove(client->debugfs_options);\n\tdebugfs_remove(client->debugfs_osdmap);\n\tdebugfs_remove(client->debugfs_monmap);\n\tdebugfs_remove(client->osdc.debugfs_file);\n\tdebugfs_remove(client->monc.debugfs_file);\n\tdebugfs_remove(client->debugfs_dir);\n}\n\n#else   \n\nvoid __init ceph_debugfs_init(void)\n{\n}\n\nvoid ceph_debugfs_cleanup(void)\n{\n}\n\nvoid ceph_debugfs_client_init(struct ceph_client *client)\n{\n}\n\nvoid ceph_debugfs_client_cleanup(struct ceph_client *client)\n{\n}\n\n#endif   \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}