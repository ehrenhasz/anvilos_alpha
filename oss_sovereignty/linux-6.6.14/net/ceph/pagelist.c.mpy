{
  "module_name": "pagelist.c",
  "hash_id": "37d4096c9bef6f5f36ce0e22ed9df36c4d2ee8a274e32d365f7d6ad45293008b",
  "original_prompt": "Ingested from linux-6.6.14/net/ceph/pagelist.c",
  "human_readable_source": "\n#include <linux/module.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/ceph/pagelist.h>\n\nstruct ceph_pagelist *ceph_pagelist_alloc(gfp_t gfp_flags)\n{\n\tstruct ceph_pagelist *pl;\n\n\tpl = kmalloc(sizeof(*pl), gfp_flags);\n\tif (!pl)\n\t\treturn NULL;\n\n\tINIT_LIST_HEAD(&pl->head);\n\tpl->mapped_tail = NULL;\n\tpl->length = 0;\n\tpl->room = 0;\n\tINIT_LIST_HEAD(&pl->free_list);\n\tpl->num_pages_free = 0;\n\trefcount_set(&pl->refcnt, 1);\n\n\treturn pl;\n}\nEXPORT_SYMBOL(ceph_pagelist_alloc);\n\nstatic void ceph_pagelist_unmap_tail(struct ceph_pagelist *pl)\n{\n\tif (pl->mapped_tail) {\n\t\tstruct page *page = list_entry(pl->head.prev, struct page, lru);\n\t\tkunmap(page);\n\t\tpl->mapped_tail = NULL;\n\t}\n}\n\nvoid ceph_pagelist_release(struct ceph_pagelist *pl)\n{\n\tif (!refcount_dec_and_test(&pl->refcnt))\n\t\treturn;\n\tceph_pagelist_unmap_tail(pl);\n\twhile (!list_empty(&pl->head)) {\n\t\tstruct page *page = list_first_entry(&pl->head, struct page,\n\t\t\t\t\t\t     lru);\n\t\tlist_del(&page->lru);\n\t\t__free_page(page);\n\t}\n\tceph_pagelist_free_reserve(pl);\n\tkfree(pl);\n}\nEXPORT_SYMBOL(ceph_pagelist_release);\n\nstatic int ceph_pagelist_addpage(struct ceph_pagelist *pl)\n{\n\tstruct page *page;\n\n\tif (!pl->num_pages_free) {\n\t\tpage = __page_cache_alloc(GFP_NOFS);\n\t} else {\n\t\tpage = list_first_entry(&pl->free_list, struct page, lru);\n\t\tlist_del(&page->lru);\n\t\t--pl->num_pages_free;\n\t}\n\tif (!page)\n\t\treturn -ENOMEM;\n\tpl->room += PAGE_SIZE;\n\tceph_pagelist_unmap_tail(pl);\n\tlist_add_tail(&page->lru, &pl->head);\n\tpl->mapped_tail = kmap(page);\n\treturn 0;\n}\n\nint ceph_pagelist_append(struct ceph_pagelist *pl, const void *buf, size_t len)\n{\n\twhile (pl->room < len) {\n\t\tsize_t bit = pl->room;\n\t\tint ret;\n\n\t\tmemcpy(pl->mapped_tail + (pl->length & ~PAGE_MASK),\n\t\t       buf, bit);\n\t\tpl->length += bit;\n\t\tpl->room -= bit;\n\t\tbuf += bit;\n\t\tlen -= bit;\n\t\tret = ceph_pagelist_addpage(pl);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tmemcpy(pl->mapped_tail + (pl->length & ~PAGE_MASK), buf, len);\n\tpl->length += len;\n\tpl->room -= len;\n\treturn 0;\n}\nEXPORT_SYMBOL(ceph_pagelist_append);\n\n \nint ceph_pagelist_reserve(struct ceph_pagelist *pl, size_t space)\n{\n\tif (space <= pl->room)\n\t\treturn 0;\n\tspace -= pl->room;\n\tspace = (space + PAGE_SIZE - 1) >> PAGE_SHIFT;    \n\n\twhile (space > pl->num_pages_free) {\n\t\tstruct page *page = __page_cache_alloc(GFP_NOFS);\n\t\tif (!page)\n\t\t\treturn -ENOMEM;\n\t\tlist_add_tail(&page->lru, &pl->free_list);\n\t\t++pl->num_pages_free;\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL(ceph_pagelist_reserve);\n\n \nint ceph_pagelist_free_reserve(struct ceph_pagelist *pl)\n{\n\twhile (!list_empty(&pl->free_list)) {\n\t\tstruct page *page = list_first_entry(&pl->free_list,\n\t\t\t\t\t\t     struct page, lru);\n\t\tlist_del(&page->lru);\n\t\t__free_page(page);\n\t\t--pl->num_pages_free;\n\t}\n\tBUG_ON(pl->num_pages_free);\n\treturn 0;\n}\nEXPORT_SYMBOL(ceph_pagelist_free_reserve);\n\n \nvoid ceph_pagelist_set_cursor(struct ceph_pagelist *pl,\n\t\t\t      struct ceph_pagelist_cursor *c)\n{\n\tc->pl = pl;\n\tc->page_lru = pl->head.prev;\n\tc->room = pl->room;\n}\nEXPORT_SYMBOL(ceph_pagelist_set_cursor);\n\n \nint ceph_pagelist_truncate(struct ceph_pagelist *pl,\n\t\t\t   struct ceph_pagelist_cursor *c)\n{\n\tstruct page *page;\n\n\tif (pl != c->pl)\n\t\treturn -EINVAL;\n\tceph_pagelist_unmap_tail(pl);\n\twhile (pl->head.prev != c->page_lru) {\n\t\tpage = list_entry(pl->head.prev, struct page, lru);\n\t\t \n\t\tlist_move_tail(&page->lru, &pl->free_list);\n\t\t++pl->num_pages_free;\n\t}\n\tpl->room = c->room;\n\tif (!list_empty(&pl->head)) {\n\t\tpage = list_entry(pl->head.prev, struct page, lru);\n\t\tpl->mapped_tail = kmap(page);\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL(ceph_pagelist_truncate);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}