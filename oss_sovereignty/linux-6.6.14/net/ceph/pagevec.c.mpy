{
  "module_name": "pagevec.c",
  "hash_id": "db233fca36db093aa05d30897a0824025cb6e4babae66435568acf7849343f97",
  "original_prompt": "Ingested from linux-6.6.14/net/ceph/pagevec.c",
  "human_readable_source": "\n#include <linux/ceph/ceph_debug.h>\n\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/writeback.h>\n\n#include <linux/ceph/libceph.h>\n\nvoid ceph_put_page_vector(struct page **pages, int num_pages, bool dirty)\n{\n\tint i;\n\n\tfor (i = 0; i < num_pages; i++) {\n\t\tif (dirty)\n\t\t\tset_page_dirty_lock(pages[i]);\n\t\tput_page(pages[i]);\n\t}\n\tkvfree(pages);\n}\nEXPORT_SYMBOL(ceph_put_page_vector);\n\nvoid ceph_release_page_vector(struct page **pages, int num_pages)\n{\n\tint i;\n\n\tfor (i = 0; i < num_pages; i++)\n\t\t__free_pages(pages[i], 0);\n\tkfree(pages);\n}\nEXPORT_SYMBOL(ceph_release_page_vector);\n\n \nstruct page **ceph_alloc_page_vector(int num_pages, gfp_t flags)\n{\n\tstruct page **pages;\n\tint i;\n\n\tpages = kmalloc_array(num_pages, sizeof(*pages), flags);\n\tif (!pages)\n\t\treturn ERR_PTR(-ENOMEM);\n\tfor (i = 0; i < num_pages; i++) {\n\t\tpages[i] = __page_cache_alloc(flags);\n\t\tif (pages[i] == NULL) {\n\t\t\tceph_release_page_vector(pages, i);\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\t}\n\t}\n\treturn pages;\n}\nEXPORT_SYMBOL(ceph_alloc_page_vector);\n\n \nint ceph_copy_user_to_page_vector(struct page **pages,\n\t\t\t\t\t const void __user *data,\n\t\t\t\t\t loff_t off, size_t len)\n{\n\tint i = 0;\n\tint po = off & ~PAGE_MASK;\n\tint left = len;\n\tint l, bad;\n\n\twhile (left > 0) {\n\t\tl = min_t(int, PAGE_SIZE-po, left);\n\t\tbad = copy_from_user(page_address(pages[i]) + po, data, l);\n\t\tif (bad == l)\n\t\t\treturn -EFAULT;\n\t\tdata += l - bad;\n\t\tleft -= l - bad;\n\t\tpo += l - bad;\n\t\tif (po == PAGE_SIZE) {\n\t\t\tpo = 0;\n\t\t\ti++;\n\t\t}\n\t}\n\treturn len;\n}\nEXPORT_SYMBOL(ceph_copy_user_to_page_vector);\n\nvoid ceph_copy_to_page_vector(struct page **pages,\n\t\t\t\t    const void *data,\n\t\t\t\t    loff_t off, size_t len)\n{\n\tint i = 0;\n\tsize_t po = off & ~PAGE_MASK;\n\tsize_t left = len;\n\n\twhile (left > 0) {\n\t\tsize_t l = min_t(size_t, PAGE_SIZE-po, left);\n\n\t\tmemcpy(page_address(pages[i]) + po, data, l);\n\t\tdata += l;\n\t\tleft -= l;\n\t\tpo += l;\n\t\tif (po == PAGE_SIZE) {\n\t\t\tpo = 0;\n\t\t\ti++;\n\t\t}\n\t}\n}\nEXPORT_SYMBOL(ceph_copy_to_page_vector);\n\nvoid ceph_copy_from_page_vector(struct page **pages,\n\t\t\t\t    void *data,\n\t\t\t\t    loff_t off, size_t len)\n{\n\tint i = 0;\n\tsize_t po = off & ~PAGE_MASK;\n\tsize_t left = len;\n\n\twhile (left > 0) {\n\t\tsize_t l = min_t(size_t, PAGE_SIZE-po, left);\n\n\t\tmemcpy(data, page_address(pages[i]) + po, l);\n\t\tdata += l;\n\t\tleft -= l;\n\t\tpo += l;\n\t\tif (po == PAGE_SIZE) {\n\t\t\tpo = 0;\n\t\t\ti++;\n\t\t}\n\t}\n}\nEXPORT_SYMBOL(ceph_copy_from_page_vector);\n\n \nvoid ceph_zero_page_vector_range(int off, int len, struct page **pages)\n{\n\tint i = off >> PAGE_SHIFT;\n\n\toff &= ~PAGE_MASK;\n\n\tdout(\"zero_page_vector_page %u~%u\\n\", off, len);\n\n\t \n\tif (off) {\n\t\tint end = min((int)PAGE_SIZE, off + len);\n\t\tdout(\"zeroing %d %p head from %d\\n\", i, pages[i],\n\t\t     (int)off);\n\t\tzero_user_segment(pages[i], off, end);\n\t\tlen -= (end - off);\n\t\ti++;\n\t}\n\twhile (len >= PAGE_SIZE) {\n\t\tdout(\"zeroing %d %p len=%d\\n\", i, pages[i], len);\n\t\tzero_user_segment(pages[i], 0, PAGE_SIZE);\n\t\tlen -= PAGE_SIZE;\n\t\ti++;\n\t}\n\t \n\tif (len) {\n\t\tdout(\"zeroing %d %p tail to %d\\n\", i, pages[i], (int)len);\n\t\tzero_user_segment(pages[i], 0, len);\n\t}\n}\nEXPORT_SYMBOL(ceph_zero_page_vector_range);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}