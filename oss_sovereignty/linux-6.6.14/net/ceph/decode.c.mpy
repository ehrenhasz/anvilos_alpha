{
  "module_name": "decode.c",
  "hash_id": "165d0f581e7fda61447619fdb474756627fb2a3a6f05d2cbce4f3f5865c8ef64",
  "original_prompt": "Ingested from linux-6.6.14/net/ceph/decode.c",
  "human_readable_source": "\n#include <linux/ceph/ceph_debug.h>\n\n#include <linux/inet.h>\n\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>   \n\nstatic int\nceph_decode_entity_addr_versioned(void **p, void *end,\n\t\t\t\t  struct ceph_entity_addr *addr)\n{\n\tint ret;\n\tu8 struct_v;\n\tu32 struct_len, addr_len;\n\tvoid *struct_end;\n\n\tret = ceph_start_decoding(p, end, 1, \"entity_addr_t\", &struct_v,\n\t\t\t\t  &struct_len);\n\tif (ret)\n\t\tgoto bad;\n\n\tret = -EINVAL;\n\tstruct_end = *p + struct_len;\n\n\tceph_decode_copy_safe(p, end, &addr->type, sizeof(addr->type), bad);\n\n\tceph_decode_copy_safe(p, end, &addr->nonce, sizeof(addr->nonce), bad);\n\n\tceph_decode_32_safe(p, end, addr_len, bad);\n\tif (addr_len > sizeof(addr->in_addr))\n\t\tgoto bad;\n\n\tmemset(&addr->in_addr, 0, sizeof(addr->in_addr));\n\tif (addr_len) {\n\t\tceph_decode_copy_safe(p, end, &addr->in_addr, addr_len, bad);\n\n\t\taddr->in_addr.ss_family =\n\t\t\tle16_to_cpu((__force __le16)addr->in_addr.ss_family);\n\t}\n\n\t \n\t*p = struct_end;\n\tret = 0;\nbad:\n\treturn ret;\n}\n\nstatic int\nceph_decode_entity_addr_legacy(void **p, void *end,\n\t\t\t       struct ceph_entity_addr *addr)\n{\n\tint ret = -EINVAL;\n\n\t \n\tceph_decode_skip_n(p, end, 3, bad);\n\n\t \n\taddr->type = CEPH_ENTITY_ADDR_TYPE_LEGACY;\n\tceph_decode_copy_safe(p, end, &addr->nonce, sizeof(addr->nonce), bad);\n\tmemset(&addr->in_addr, 0, sizeof(addr->in_addr));\n\tceph_decode_copy_safe(p, end, &addr->in_addr,\n\t\t\t      sizeof(addr->in_addr), bad);\n\taddr->in_addr.ss_family =\n\t\t\tbe16_to_cpu((__force __be16)addr->in_addr.ss_family);\n\tret = 0;\nbad:\n\treturn ret;\n}\n\nint\nceph_decode_entity_addr(void **p, void *end, struct ceph_entity_addr *addr)\n{\n\tu8 marker;\n\n\tceph_decode_8_safe(p, end, marker, bad);\n\tif (marker == 1)\n\t\treturn ceph_decode_entity_addr_versioned(p, end, addr);\n\telse if (marker == 0)\n\t\treturn ceph_decode_entity_addr_legacy(p, end, addr);\nbad:\n\treturn -EINVAL;\n}\nEXPORT_SYMBOL(ceph_decode_entity_addr);\n\n \nint ceph_decode_entity_addrvec(void **p, void *end, bool msgr2,\n\t\t\t       struct ceph_entity_addr *addr)\n{\n\t__le32 my_type = msgr2 ? CEPH_ENTITY_ADDR_TYPE_MSGR2 :\n\t\t\t\t CEPH_ENTITY_ADDR_TYPE_LEGACY;\n\tstruct ceph_entity_addr tmp_addr;\n\tint addr_cnt;\n\tbool found;\n\tu8 marker;\n\tint ret;\n\tint i;\n\n\tceph_decode_8_safe(p, end, marker, e_inval);\n\tif (marker != 2) {\n\t\tpr_err(\"bad addrvec marker %d\\n\", marker);\n\t\treturn -EINVAL;\n\t}\n\n\tceph_decode_32_safe(p, end, addr_cnt, e_inval);\n\tdout(\"%s addr_cnt %d\\n\", __func__, addr_cnt);\n\n\tfound = false;\n\tfor (i = 0; i < addr_cnt; i++) {\n\t\tret = ceph_decode_entity_addr(p, end, &tmp_addr);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tdout(\"%s i %d addr %s\\n\", __func__, i, ceph_pr_addr(&tmp_addr));\n\t\tif (tmp_addr.type == my_type) {\n\t\t\tif (found) {\n\t\t\t\tpr_err(\"another match of type %d in addrvec\\n\",\n\t\t\t\t       le32_to_cpu(my_type));\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tmemcpy(addr, &tmp_addr, sizeof(*addr));\n\t\t\tfound = true;\n\t\t}\n\t}\n\n\tif (found)\n\t\treturn 0;\n\n\tif (!addr_cnt)\n\t\treturn 0;   \n\n\tif (addr_cnt == 1 && !memchr_inv(&tmp_addr, 0, sizeof(tmp_addr)))\n\t\treturn 0;   \n\n\tpr_err(\"no match of type %d in addrvec\\n\", le32_to_cpu(my_type));\n\treturn -ENOENT;\n\ne_inval:\n\treturn -EINVAL;\n}\nEXPORT_SYMBOL(ceph_decode_entity_addrvec);\n\nstatic int get_sockaddr_encoding_len(sa_family_t family)\n{\n\tunion {\n\t\tstruct sockaddr sa;\n\t\tstruct sockaddr_in sin;\n\t\tstruct sockaddr_in6 sin6;\n\t} u;\n\n\tswitch (family) {\n\tcase AF_INET:\n\t\treturn sizeof(u.sin);\n\tcase AF_INET6:\n\t\treturn sizeof(u.sin6);\n\tdefault:\n\t\treturn sizeof(u);\n\t}\n}\n\nint ceph_entity_addr_encoding_len(const struct ceph_entity_addr *addr)\n{\n\tsa_family_t family = get_unaligned(&addr->in_addr.ss_family);\n\tint addr_len = get_sockaddr_encoding_len(family);\n\n\treturn 1 + CEPH_ENCODING_START_BLK_LEN + 4 + 4 + 4 + addr_len;\n}\n\nvoid ceph_encode_entity_addr(void **p, const struct ceph_entity_addr *addr)\n{\n\tsa_family_t family = get_unaligned(&addr->in_addr.ss_family);\n\tint addr_len = get_sockaddr_encoding_len(family);\n\n\tceph_encode_8(p, 1);   \n\tceph_start_encoding(p, 1, 1, sizeof(addr->type) +\n\t\t\t\t     sizeof(addr->nonce) +\n\t\t\t\t     sizeof(u32) + addr_len);\n\tceph_encode_copy(p, &addr->type, sizeof(addr->type));\n\tceph_encode_copy(p, &addr->nonce, sizeof(addr->nonce));\n\n\tceph_encode_32(p, addr_len);\n\tceph_encode_16(p, family);\n\tceph_encode_copy(p, addr->in_addr.__data, addr_len - sizeof(family));\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}