{
  "module_name": "string_table.c",
  "hash_id": "580d448f3f57d9d5f6a7455434ae6409dc5bf1250f99a706a2f1e9a4dec64337",
  "original_prompt": "Ingested from linux-6.6.14/net/ceph/string_table.c",
  "human_readable_source": "\n#include <linux/slab.h>\n#include <linux/gfp.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/ceph/string_table.h>\n\nstatic DEFINE_SPINLOCK(string_tree_lock);\nstatic struct rb_root string_tree = RB_ROOT;\n\nstruct ceph_string *ceph_find_or_create_string(const char* str, size_t len)\n{\n\tstruct ceph_string *cs, *exist;\n\tstruct rb_node **p, *parent;\n\tint ret;\n\n\texist = NULL;\n\tspin_lock(&string_tree_lock);\n\tp = &string_tree.rb_node;\n\twhile (*p) {\n\t\texist = rb_entry(*p, struct ceph_string, node);\n\t\tret = ceph_compare_string(exist, str, len);\n\t\tif (ret > 0)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (ret < 0)\n\t\t\tp = &(*p)->rb_right;\n\t\telse\n\t\t\tbreak;\n\t\texist = NULL;\n\t}\n\tif (exist && !kref_get_unless_zero(&exist->kref)) {\n\t\trb_erase(&exist->node, &string_tree);\n\t\tRB_CLEAR_NODE(&exist->node);\n\t\texist = NULL;\n\t}\n\tspin_unlock(&string_tree_lock);\n\tif (exist)\n\t\treturn exist;\n\n\tcs = kmalloc(sizeof(*cs) + len + 1, GFP_NOFS);\n\tif (!cs)\n\t\treturn NULL;\n\n\tkref_init(&cs->kref);\n\tcs->len = len;\n\tmemcpy(cs->str, str, len);\n\tcs->str[len] = 0;\n\nretry:\n\texist = NULL;\n\tparent = NULL;\n\tp = &string_tree.rb_node;\n\tspin_lock(&string_tree_lock);\n\twhile (*p) {\n\t\tparent = *p;\n\t\texist = rb_entry(*p, struct ceph_string, node);\n\t\tret = ceph_compare_string(exist, str, len);\n\t\tif (ret > 0)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (ret < 0)\n\t\t\tp = &(*p)->rb_right;\n\t\telse\n\t\t\tbreak;\n\t\texist = NULL;\n\t}\n\tret = 0;\n\tif (!exist) {\n\t\trb_link_node(&cs->node, parent, p);\n\t\trb_insert_color(&cs->node, &string_tree);\n\t} else if (!kref_get_unless_zero(&exist->kref)) {\n\t\trb_erase(&exist->node, &string_tree);\n\t\tRB_CLEAR_NODE(&exist->node);\n\t\tret = -EAGAIN;\n\t}\n\tspin_unlock(&string_tree_lock);\n\tif (ret == -EAGAIN)\n\t\tgoto retry;\n\n\tif (exist) {\n\t\tkfree(cs);\n\t\tcs = exist;\n\t}\n\n\treturn cs;\n}\nEXPORT_SYMBOL(ceph_find_or_create_string);\n\nvoid ceph_release_string(struct kref *ref)\n{\n\tstruct ceph_string *cs = container_of(ref, struct ceph_string, kref);\n\n\tspin_lock(&string_tree_lock);\n\tif (!RB_EMPTY_NODE(&cs->node)) {\n\t\trb_erase(&cs->node, &string_tree);\n\t\tRB_CLEAR_NODE(&cs->node);\n\t}\n\tspin_unlock(&string_tree_lock);\n\n\tkfree_rcu(cs, rcu);\n}\nEXPORT_SYMBOL(ceph_release_string);\n\nbool ceph_strings_empty(void)\n{\n\treturn RB_EMPTY_ROOT(&string_tree);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}