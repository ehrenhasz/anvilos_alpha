{
  "module_name": "auth.c",
  "hash_id": "e153509f55825940f8b26207b49e3a8ff3159dca74719ebbe6ea365e190161b2",
  "original_prompt": "Ingested from linux-6.6.14/net/ceph/auth.c",
  "human_readable_source": "\n#include <linux/ceph/ceph_debug.h>\n\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n\n#include <linux/ceph/types.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/libceph.h>\n#include <linux/ceph/messenger.h>\n#include \"auth_none.h\"\n#include \"auth_x.h\"\n\n\n \nstatic u32 supported_protocols[] = {\n\tCEPH_AUTH_NONE,\n\tCEPH_AUTH_CEPHX\n};\n\nstatic int init_protocol(struct ceph_auth_client *ac, int proto)\n{\n\tdout(\"%s proto %d\\n\", __func__, proto);\n\n\tswitch (proto) {\n\tcase CEPH_AUTH_NONE:\n\t\treturn ceph_auth_none_init(ac);\n\tcase CEPH_AUTH_CEPHX:\n\t\treturn ceph_x_init(ac);\n\tdefault:\n\t\tpr_err(\"bad auth protocol %d\\n\", proto);\n\t\treturn -EINVAL;\n\t}\n}\n\nvoid ceph_auth_set_global_id(struct ceph_auth_client *ac, u64 global_id)\n{\n\tdout(\"%s global_id %llu\\n\", __func__, global_id);\n\n\tif (!global_id)\n\t\tpr_err(\"got zero global_id\\n\");\n\n\tif (ac->global_id && global_id != ac->global_id)\n\t\tpr_err(\"global_id changed from %llu to %llu\\n\", ac->global_id,\n\t\t       global_id);\n\n\tac->global_id = global_id;\n}\n\n \nstruct ceph_auth_client *ceph_auth_init(const char *name,\n\t\t\t\t\tconst struct ceph_crypto_key *key,\n\t\t\t\t\tconst int *con_modes)\n{\n\tstruct ceph_auth_client *ac;\n\n\tac = kzalloc(sizeof(*ac), GFP_NOFS);\n\tif (!ac)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmutex_init(&ac->mutex);\n\tac->negotiating = true;\n\tif (name)\n\t\tac->name = name;\n\telse\n\t\tac->name = CEPH_AUTH_NAME_DEFAULT;\n\tac->key = key;\n\tac->preferred_mode = con_modes[0];\n\tac->fallback_mode = con_modes[1];\n\n\tdout(\"%s name '%s' preferred_mode %d fallback_mode %d\\n\", __func__,\n\t     ac->name, ac->preferred_mode, ac->fallback_mode);\n\treturn ac;\n}\n\nvoid ceph_auth_destroy(struct ceph_auth_client *ac)\n{\n\tdout(\"auth_destroy %p\\n\", ac);\n\tif (ac->ops)\n\t\tac->ops->destroy(ac);\n\tkfree(ac);\n}\n\n \nvoid ceph_auth_reset(struct ceph_auth_client *ac)\n{\n\tmutex_lock(&ac->mutex);\n\tdout(\"auth_reset %p\\n\", ac);\n\tif (ac->ops && !ac->negotiating)\n\t\tac->ops->reset(ac);\n\tac->negotiating = true;\n\tmutex_unlock(&ac->mutex);\n}\n\n \nint ceph_auth_entity_name_encode(const char *name, void **p, void *end)\n{\n\tint len = strlen(name);\n\n\tif (*p + 2*sizeof(u32) + len > end)\n\t\treturn -ERANGE;\n\tceph_encode_32(p, CEPH_ENTITY_TYPE_CLIENT);\n\tceph_encode_32(p, len);\n\tceph_encode_copy(p, name, len);\n\treturn 0;\n}\n\n \nint ceph_auth_build_hello(struct ceph_auth_client *ac, void *buf, size_t len)\n{\n\tstruct ceph_mon_request_header *monhdr = buf;\n\tvoid *p = monhdr + 1, *end = buf + len, *lenp;\n\tint i, num;\n\tint ret;\n\n\tmutex_lock(&ac->mutex);\n\tdout(\"auth_build_hello\\n\");\n\tmonhdr->have_version = 0;\n\tmonhdr->session_mon = cpu_to_le16(-1);\n\tmonhdr->session_mon_tid = 0;\n\n\tceph_encode_32(&p, CEPH_AUTH_UNKNOWN);   \n\n\tlenp = p;\n\tp += sizeof(u32);\n\n\tceph_decode_need(&p, end, 1 + sizeof(u32), bad);\n\tceph_encode_8(&p, 1);\n\tnum = ARRAY_SIZE(supported_protocols);\n\tceph_encode_32(&p, num);\n\tceph_decode_need(&p, end, num * sizeof(u32), bad);\n\tfor (i = 0; i < num; i++)\n\t\tceph_encode_32(&p, supported_protocols[i]);\n\n\tret = ceph_auth_entity_name_encode(ac->name, &p, end);\n\tif (ret < 0)\n\t\tgoto out;\n\tceph_decode_need(&p, end, sizeof(u64), bad);\n\tceph_encode_64(&p, ac->global_id);\n\n\tceph_encode_32(&lenp, p - lenp - sizeof(u32));\n\tret = p - buf;\nout:\n\tmutex_unlock(&ac->mutex);\n\treturn ret;\n\nbad:\n\tret = -ERANGE;\n\tgoto out;\n}\n\nstatic int build_request(struct ceph_auth_client *ac, bool add_header,\n\t\t\t void *buf, int buf_len)\n{\n\tvoid *end = buf + buf_len;\n\tvoid *p;\n\tint ret;\n\n\tp = buf;\n\tif (add_header) {\n\t\t \n\t\tceph_encode_64_safe(&p, end, 0, e_range);\n\t\tceph_encode_16_safe(&p, end, -1, e_range);\n\t\tceph_encode_64_safe(&p, end, 0, e_range);\n\t\tceph_encode_32_safe(&p, end, ac->protocol, e_range);\n\t}\n\n\tceph_encode_need(&p, end, sizeof(u32), e_range);\n\tret = ac->ops->build_request(ac, p + sizeof(u32), end);\n\tif (ret < 0) {\n\t\tpr_err(\"auth protocol '%s' building request failed: %d\\n\",\n\t\t       ceph_auth_proto_name(ac->protocol), ret);\n\t\treturn ret;\n\t}\n\tdout(\" built request %d bytes\\n\", ret);\n\tceph_encode_32(&p, ret);\n\treturn p + ret - buf;\n\ne_range:\n\treturn -ERANGE;\n}\n\n \nint ceph_handle_auth_reply(struct ceph_auth_client *ac,\n\t\t\t   void *buf, size_t len,\n\t\t\t   void *reply_buf, size_t reply_len)\n{\n\tvoid *p = buf;\n\tvoid *end = buf + len;\n\tint protocol;\n\ts32 result;\n\tu64 global_id;\n\tvoid *payload, *payload_end;\n\tint payload_len;\n\tchar *result_msg;\n\tint result_msg_len;\n\tint ret = -EINVAL;\n\n\tmutex_lock(&ac->mutex);\n\tdout(\"handle_auth_reply %p %p\\n\", p, end);\n\tceph_decode_need(&p, end, sizeof(u32) * 3 + sizeof(u64), bad);\n\tprotocol = ceph_decode_32(&p);\n\tresult = ceph_decode_32(&p);\n\tglobal_id = ceph_decode_64(&p);\n\tpayload_len = ceph_decode_32(&p);\n\tpayload = p;\n\tp += payload_len;\n\tceph_decode_need(&p, end, sizeof(u32), bad);\n\tresult_msg_len = ceph_decode_32(&p);\n\tresult_msg = p;\n\tp += result_msg_len;\n\tif (p != end)\n\t\tgoto bad;\n\n\tdout(\" result %d '%.*s' gid %llu len %d\\n\", result, result_msg_len,\n\t     result_msg, global_id, payload_len);\n\n\tpayload_end = payload + payload_len;\n\n\tif (ac->negotiating) {\n\t\t \n\t\tif (!protocol && result < 0) {\n\t\t\tret = result;\n\t\t\tgoto out;\n\t\t}\n\t\t \n\t\tif (ac->protocol && ac->protocol != protocol) {\n\t\t\tac->ops->destroy(ac);\n\t\t\tac->protocol = 0;\n\t\t\tac->ops = NULL;\n\t\t}\n\t\tif (ac->protocol != protocol) {\n\t\t\tret = init_protocol(ac, protocol);\n\t\t\tif (ret) {\n\t\t\t\tpr_err(\"auth protocol '%s' init failed: %d\\n\",\n\t\t\t\t       ceph_auth_proto_name(protocol), ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tac->negotiating = false;\n\t}\n\n\tif (result) {\n\t\tpr_err(\"auth protocol '%s' mauth authentication failed: %d\\n\",\n\t\t       ceph_auth_proto_name(ac->protocol), result);\n\t\tret = result;\n\t\tgoto out;\n\t}\n\n\tret = ac->ops->handle_reply(ac, global_id, payload, payload_end,\n\t\t\t\t    NULL, NULL, NULL, NULL);\n\tif (ret == -EAGAIN) {\n\t\tret = build_request(ac, true, reply_buf, reply_len);\n\t\tgoto out;\n\t} else if (ret) {\n\t\tgoto out;\n\t}\n\nout:\n\tmutex_unlock(&ac->mutex);\n\treturn ret;\n\nbad:\n\tpr_err(\"failed to decode auth msg\\n\");\n\tret = -EINVAL;\n\tgoto out;\n}\n\nint ceph_build_auth(struct ceph_auth_client *ac,\n\t\t    void *msg_buf, size_t msg_len)\n{\n\tint ret = 0;\n\n\tmutex_lock(&ac->mutex);\n\tif (ac->ops->should_authenticate(ac))\n\t\tret = build_request(ac, true, msg_buf, msg_len);\n\tmutex_unlock(&ac->mutex);\n\treturn ret;\n}\n\nint ceph_auth_is_authenticated(struct ceph_auth_client *ac)\n{\n\tint ret = 0;\n\n\tmutex_lock(&ac->mutex);\n\tif (ac->ops)\n\t\tret = ac->ops->is_authenticated(ac);\n\tmutex_unlock(&ac->mutex);\n\treturn ret;\n}\nEXPORT_SYMBOL(ceph_auth_is_authenticated);\n\nint __ceph_auth_get_authorizer(struct ceph_auth_client *ac,\n\t\t\t       struct ceph_auth_handshake *auth,\n\t\t\t       int peer_type, bool force_new,\n\t\t\t       int *proto, int *pref_mode, int *fallb_mode)\n{\n\tint ret;\n\n\tmutex_lock(&ac->mutex);\n\tif (force_new && auth->authorizer) {\n\t\tceph_auth_destroy_authorizer(auth->authorizer);\n\t\tauth->authorizer = NULL;\n\t}\n\tif (!auth->authorizer)\n\t\tret = ac->ops->create_authorizer(ac, peer_type, auth);\n\telse if (ac->ops->update_authorizer)\n\t\tret = ac->ops->update_authorizer(ac, peer_type, auth);\n\telse\n\t\tret = 0;\n\tif (ret)\n\t\tgoto out;\n\n\t*proto = ac->protocol;\n\tif (pref_mode && fallb_mode) {\n\t\t*pref_mode = ac->preferred_mode;\n\t\t*fallb_mode = ac->fallback_mode;\n\t}\n\nout:\n\tmutex_unlock(&ac->mutex);\n\treturn ret;\n}\nEXPORT_SYMBOL(__ceph_auth_get_authorizer);\n\nvoid ceph_auth_destroy_authorizer(struct ceph_authorizer *a)\n{\n\ta->destroy(a);\n}\nEXPORT_SYMBOL(ceph_auth_destroy_authorizer);\n\nint ceph_auth_add_authorizer_challenge(struct ceph_auth_client *ac,\n\t\t\t\t       struct ceph_authorizer *a,\n\t\t\t\t       void *challenge_buf,\n\t\t\t\t       int challenge_buf_len)\n{\n\tint ret = 0;\n\n\tmutex_lock(&ac->mutex);\n\tif (ac->ops && ac->ops->add_authorizer_challenge)\n\t\tret = ac->ops->add_authorizer_challenge(ac, a, challenge_buf,\n\t\t\t\t\t\t\tchallenge_buf_len);\n\tmutex_unlock(&ac->mutex);\n\treturn ret;\n}\nEXPORT_SYMBOL(ceph_auth_add_authorizer_challenge);\n\nint ceph_auth_verify_authorizer_reply(struct ceph_auth_client *ac,\n\t\t\t\t      struct ceph_authorizer *a,\n\t\t\t\t      void *reply, int reply_len,\n\t\t\t\t      u8 *session_key, int *session_key_len,\n\t\t\t\t      u8 *con_secret, int *con_secret_len)\n{\n\tint ret = 0;\n\n\tmutex_lock(&ac->mutex);\n\tif (ac->ops && ac->ops->verify_authorizer_reply)\n\t\tret = ac->ops->verify_authorizer_reply(ac, a,\n\t\t\treply, reply_len, session_key, session_key_len,\n\t\t\tcon_secret, con_secret_len);\n\tmutex_unlock(&ac->mutex);\n\treturn ret;\n}\nEXPORT_SYMBOL(ceph_auth_verify_authorizer_reply);\n\nvoid ceph_auth_invalidate_authorizer(struct ceph_auth_client *ac, int peer_type)\n{\n\tmutex_lock(&ac->mutex);\n\tif (ac->ops && ac->ops->invalidate_authorizer)\n\t\tac->ops->invalidate_authorizer(ac, peer_type);\n\tmutex_unlock(&ac->mutex);\n}\nEXPORT_SYMBOL(ceph_auth_invalidate_authorizer);\n\n \n\nstatic bool contains(const int *arr, int cnt, int val)\n{\n\tint i;\n\n\tfor (i = 0; i < cnt; i++) {\n\t\tif (arr[i] == val)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic int encode_con_modes(void **p, void *end, int pref_mode, int fallb_mode)\n{\n\tWARN_ON(pref_mode == CEPH_CON_MODE_UNKNOWN);\n\tif (fallb_mode != CEPH_CON_MODE_UNKNOWN) {\n\t\tceph_encode_32_safe(p, end, 2, e_range);\n\t\tceph_encode_32_safe(p, end, pref_mode, e_range);\n\t\tceph_encode_32_safe(p, end, fallb_mode, e_range);\n\t} else {\n\t\tceph_encode_32_safe(p, end, 1, e_range);\n\t\tceph_encode_32_safe(p, end, pref_mode, e_range);\n\t}\n\n\treturn 0;\n\ne_range:\n\treturn -ERANGE;\n}\n\n \nint ceph_auth_get_request(struct ceph_auth_client *ac, void *buf, int buf_len)\n{\n\tint proto = ac->key ? CEPH_AUTH_CEPHX : CEPH_AUTH_NONE;\n\tvoid *end = buf + buf_len;\n\tvoid *lenp;\n\tvoid *p;\n\tint ret;\n\n\tmutex_lock(&ac->mutex);\n\tif (ac->protocol == CEPH_AUTH_UNKNOWN) {\n\t\tret = init_protocol(ac, proto);\n\t\tif (ret) {\n\t\t\tpr_err(\"auth protocol '%s' init failed: %d\\n\",\n\t\t\t       ceph_auth_proto_name(proto), ret);\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\tWARN_ON(ac->protocol != proto);\n\t\tac->ops->reset(ac);\n\t}\n\n\tp = buf;\n\tceph_encode_32_safe(&p, end, ac->protocol, e_range);\n\tret = encode_con_modes(&p, end, ac->preferred_mode, ac->fallback_mode);\n\tif (ret)\n\t\tgoto out;\n\n\tlenp = p;\n\tp += 4;   \n\n\tceph_encode_8_safe(&p, end, CEPH_AUTH_MODE_MON, e_range);\n\tret = ceph_auth_entity_name_encode(ac->name, &p, end);\n\tif (ret)\n\t\tgoto out;\n\n\tceph_encode_64_safe(&p, end, ac->global_id, e_range);\n\tceph_encode_32(&lenp, p - lenp - 4);\n\tret = p - buf;\n\nout:\n\tmutex_unlock(&ac->mutex);\n\treturn ret;\n\ne_range:\n\tret = -ERANGE;\n\tgoto out;\n}\n\nint ceph_auth_handle_reply_more(struct ceph_auth_client *ac, void *reply,\n\t\t\t\tint reply_len, void *buf, int buf_len)\n{\n\tint ret;\n\n\tmutex_lock(&ac->mutex);\n\tret = ac->ops->handle_reply(ac, 0, reply, reply + reply_len,\n\t\t\t\t    NULL, NULL, NULL, NULL);\n\tif (ret == -EAGAIN)\n\t\tret = build_request(ac, false, buf, buf_len);\n\telse\n\t\tWARN_ON(ret >= 0);\n\tmutex_unlock(&ac->mutex);\n\treturn ret;\n}\n\nint ceph_auth_handle_reply_done(struct ceph_auth_client *ac,\n\t\t\t\tu64 global_id, void *reply, int reply_len,\n\t\t\t\tu8 *session_key, int *session_key_len,\n\t\t\t\tu8 *con_secret, int *con_secret_len)\n{\n\tint ret;\n\n\tmutex_lock(&ac->mutex);\n\tret = ac->ops->handle_reply(ac, global_id, reply, reply + reply_len,\n\t\t\t\t    session_key, session_key_len,\n\t\t\t\t    con_secret, con_secret_len);\n\tWARN_ON(ret == -EAGAIN || ret > 0);\n\tmutex_unlock(&ac->mutex);\n\treturn ret;\n}\n\nbool ceph_auth_handle_bad_method(struct ceph_auth_client *ac,\n\t\t\t\t int used_proto, int result,\n\t\t\t\t const int *allowed_protos, int proto_cnt,\n\t\t\t\t const int *allowed_modes, int mode_cnt)\n{\n\tmutex_lock(&ac->mutex);\n\tWARN_ON(used_proto != ac->protocol);\n\n\tif (result == -EOPNOTSUPP) {\n\t\tif (!contains(allowed_protos, proto_cnt, ac->protocol)) {\n\t\t\tpr_err(\"auth protocol '%s' not allowed\\n\",\n\t\t\t       ceph_auth_proto_name(ac->protocol));\n\t\t\tgoto not_allowed;\n\t\t}\n\t\tif (!contains(allowed_modes, mode_cnt, ac->preferred_mode) &&\n\t\t    (ac->fallback_mode == CEPH_CON_MODE_UNKNOWN ||\n\t\t     !contains(allowed_modes, mode_cnt, ac->fallback_mode))) {\n\t\t\tpr_err(\"preferred mode '%s' not allowed\\n\",\n\t\t\t       ceph_con_mode_name(ac->preferred_mode));\n\t\t\tif (ac->fallback_mode == CEPH_CON_MODE_UNKNOWN)\n\t\t\t\tpr_err(\"no fallback mode\\n\");\n\t\t\telse\n\t\t\t\tpr_err(\"fallback mode '%s' not allowed\\n\",\n\t\t\t\t       ceph_con_mode_name(ac->fallback_mode));\n\t\t\tgoto not_allowed;\n\t\t}\n\t}\n\n\tWARN_ON(result == -EOPNOTSUPP || result >= 0);\n\tpr_err(\"auth protocol '%s' msgr authentication failed: %d\\n\",\n\t       ceph_auth_proto_name(ac->protocol), result);\n\n\tmutex_unlock(&ac->mutex);\n\treturn true;\n\nnot_allowed:\n\tmutex_unlock(&ac->mutex);\n\treturn false;\n}\n\nint ceph_auth_get_authorizer(struct ceph_auth_client *ac,\n\t\t\t     struct ceph_auth_handshake *auth,\n\t\t\t     int peer_type, void *buf, int *buf_len)\n{\n\tvoid *end = buf + *buf_len;\n\tint pref_mode, fallb_mode;\n\tint proto;\n\tvoid *p;\n\tint ret;\n\n\tret = __ceph_auth_get_authorizer(ac, auth, peer_type, true, &proto,\n\t\t\t\t\t &pref_mode, &fallb_mode);\n\tif (ret)\n\t\treturn ret;\n\n\tp = buf;\n\tceph_encode_32_safe(&p, end, proto, e_range);\n\tret = encode_con_modes(&p, end, pref_mode, fallb_mode);\n\tif (ret)\n\t\treturn ret;\n\n\tceph_encode_32_safe(&p, end, auth->authorizer_buf_len, e_range);\n\t*buf_len = p - buf;\n\treturn 0;\n\ne_range:\n\treturn -ERANGE;\n}\nEXPORT_SYMBOL(ceph_auth_get_authorizer);\n\nint ceph_auth_handle_svc_reply_more(struct ceph_auth_client *ac,\n\t\t\t\t    struct ceph_auth_handshake *auth,\n\t\t\t\t    void *reply, int reply_len,\n\t\t\t\t    void *buf, int *buf_len)\n{\n\tvoid *end = buf + *buf_len;\n\tvoid *p;\n\tint ret;\n\n\tret = ceph_auth_add_authorizer_challenge(ac, auth->authorizer,\n\t\t\t\t\t\t reply, reply_len);\n\tif (ret)\n\t\treturn ret;\n\n\tp = buf;\n\tceph_encode_32_safe(&p, end, auth->authorizer_buf_len, e_range);\n\t*buf_len = p - buf;\n\treturn 0;\n\ne_range:\n\treturn -ERANGE;\n}\nEXPORT_SYMBOL(ceph_auth_handle_svc_reply_more);\n\nint ceph_auth_handle_svc_reply_done(struct ceph_auth_client *ac,\n\t\t\t\t    struct ceph_auth_handshake *auth,\n\t\t\t\t    void *reply, int reply_len,\n\t\t\t\t    u8 *session_key, int *session_key_len,\n\t\t\t\t    u8 *con_secret, int *con_secret_len)\n{\n\treturn ceph_auth_verify_authorizer_reply(ac, auth->authorizer,\n\t\treply, reply_len, session_key, session_key_len,\n\t\tcon_secret, con_secret_len);\n}\nEXPORT_SYMBOL(ceph_auth_handle_svc_reply_done);\n\nbool ceph_auth_handle_bad_authorizer(struct ceph_auth_client *ac,\n\t\t\t\t     int peer_type, int used_proto, int result,\n\t\t\t\t     const int *allowed_protos, int proto_cnt,\n\t\t\t\t     const int *allowed_modes, int mode_cnt)\n{\n\tmutex_lock(&ac->mutex);\n\tWARN_ON(used_proto != ac->protocol);\n\n\tif (result == -EOPNOTSUPP) {\n\t\tif (!contains(allowed_protos, proto_cnt, ac->protocol)) {\n\t\t\tpr_err(\"auth protocol '%s' not allowed by %s\\n\",\n\t\t\t       ceph_auth_proto_name(ac->protocol),\n\t\t\t       ceph_entity_type_name(peer_type));\n\t\t\tgoto not_allowed;\n\t\t}\n\t\tif (!contains(allowed_modes, mode_cnt, ac->preferred_mode) &&\n\t\t    (ac->fallback_mode == CEPH_CON_MODE_UNKNOWN ||\n\t\t     !contains(allowed_modes, mode_cnt, ac->fallback_mode))) {\n\t\t\tpr_err(\"preferred mode '%s' not allowed by %s\\n\",\n\t\t\t       ceph_con_mode_name(ac->preferred_mode),\n\t\t\t       ceph_entity_type_name(peer_type));\n\t\t\tif (ac->fallback_mode == CEPH_CON_MODE_UNKNOWN)\n\t\t\t\tpr_err(\"no fallback mode\\n\");\n\t\t\telse\n\t\t\t\tpr_err(\"fallback mode '%s' not allowed by %s\\n\",\n\t\t\t\t       ceph_con_mode_name(ac->fallback_mode),\n\t\t\t\t       ceph_entity_type_name(peer_type));\n\t\t\tgoto not_allowed;\n\t\t}\n\t}\n\n\tWARN_ON(result == -EOPNOTSUPP || result >= 0);\n\tpr_err(\"auth protocol '%s' authorization to %s failed: %d\\n\",\n\t       ceph_auth_proto_name(ac->protocol),\n\t       ceph_entity_type_name(peer_type), result);\n\n\tif (ac->ops->invalidate_authorizer)\n\t\tac->ops->invalidate_authorizer(ac, peer_type);\n\n\tmutex_unlock(&ac->mutex);\n\treturn true;\n\nnot_allowed:\n\tmutex_unlock(&ac->mutex);\n\treturn false;\n}\nEXPORT_SYMBOL(ceph_auth_handle_bad_authorizer);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}