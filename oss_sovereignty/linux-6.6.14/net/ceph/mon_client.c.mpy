{
  "module_name": "mon_client.c",
  "hash_id": "84b17c3749ea012e02d48699c1b43af3ec16b3d3bb9817ffccd501920c8c5384",
  "original_prompt": "Ingested from linux-6.6.14/net/ceph/mon_client.c",
  "human_readable_source": "\n#include <linux/ceph/ceph_debug.h>\n\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/random.h>\n#include <linux/sched.h>\n\n#include <linux/ceph/ceph_features.h>\n#include <linux/ceph/mon_client.h>\n#include <linux/ceph/libceph.h>\n#include <linux/ceph/debugfs.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/auth.h>\n\n \n\nstatic const struct ceph_connection_operations mon_con_ops;\n\nstatic int __validate_auth(struct ceph_mon_client *monc);\n\nstatic int decode_mon_info(void **p, void *end, bool msgr2,\n\t\t\t   struct ceph_entity_addr *addr)\n{\n\tvoid *mon_info_end;\n\tu32 struct_len;\n\tu8 struct_v;\n\tint ret;\n\n\tret = ceph_start_decoding(p, end, 1, \"mon_info_t\", &struct_v,\n\t\t\t\t  &struct_len);\n\tif (ret)\n\t\treturn ret;\n\n\tmon_info_end = *p + struct_len;\n\tceph_decode_skip_string(p, end, e_inval);   \n\tret = ceph_decode_entity_addrvec(p, end, msgr2, addr);\n\tif (ret)\n\t\treturn ret;\n\n\t*p = mon_info_end;\n\treturn 0;\n\ne_inval:\n\treturn -EINVAL;\n}\n\n \nstatic struct ceph_monmap *ceph_monmap_decode(void **p, void *end, bool msgr2)\n{\n\tstruct ceph_monmap *monmap = NULL;\n\tstruct ceph_fsid fsid;\n\tu32 struct_len;\n\tint blob_len;\n\tint num_mon;\n\tu8 struct_v;\n\tu32 epoch;\n\tint ret;\n\tint i;\n\n\tceph_decode_32_safe(p, end, blob_len, e_inval);\n\tceph_decode_need(p, end, blob_len, e_inval);\n\n\tret = ceph_start_decoding(p, end, 6, \"monmap\", &struct_v, &struct_len);\n\tif (ret)\n\t\tgoto fail;\n\n\tdout(\"%s struct_v %d\\n\", __func__, struct_v);\n\tceph_decode_copy_safe(p, end, &fsid, sizeof(fsid), e_inval);\n\tceph_decode_32_safe(p, end, epoch, e_inval);\n\tif (struct_v >= 6) {\n\t\tu32 feat_struct_len;\n\t\tu8 feat_struct_v;\n\n\t\t*p += sizeof(struct ceph_timespec);   \n\t\t*p += sizeof(struct ceph_timespec);   \n\n\t\tret = ceph_start_decoding(p, end, 1, \"mon_feature_t\",\n\t\t\t\t\t  &feat_struct_v, &feat_struct_len);\n\t\tif (ret)\n\t\t\tgoto fail;\n\n\t\t*p += feat_struct_len;   \n\n\t\tret = ceph_start_decoding(p, end, 1, \"mon_feature_t\",\n\t\t\t\t\t  &feat_struct_v, &feat_struct_len);\n\t\tif (ret)\n\t\t\tgoto fail;\n\n\t\t*p += feat_struct_len;   \n\t}\n\tceph_decode_32_safe(p, end, num_mon, e_inval);\n\n\tdout(\"%s fsid %pU epoch %u num_mon %d\\n\", __func__, &fsid, epoch,\n\t     num_mon);\n\tif (num_mon > CEPH_MAX_MON)\n\t\tgoto e_inval;\n\n\tmonmap = kmalloc(struct_size(monmap, mon_inst, num_mon), GFP_NOIO);\n\tif (!monmap) {\n\t\tret = -ENOMEM;\n\t\tgoto fail;\n\t}\n\tmonmap->fsid = fsid;\n\tmonmap->epoch = epoch;\n\tmonmap->num_mon = num_mon;\n\n\t \n\tfor (i = 0; i < num_mon; i++) {\n\t\tstruct ceph_entity_inst *inst = &monmap->mon_inst[i];\n\n\t\tceph_decode_skip_string(p, end, e_inval);   \n\t\tinst->name.type = CEPH_ENTITY_TYPE_MON;\n\t\tinst->name.num = cpu_to_le64(i);\n\n\t\tif (struct_v >= 6)\n\t\t\tret = decode_mon_info(p, end, msgr2, &inst->addr);\n\t\telse\n\t\t\tret = ceph_decode_entity_addr(p, end, &inst->addr);\n\t\tif (ret)\n\t\t\tgoto fail;\n\n\t\tdout(\"%s mon%d addr %s\\n\", __func__, i,\n\t\t     ceph_pr_addr(&inst->addr));\n\t}\n\n\treturn monmap;\n\ne_inval:\n\tret = -EINVAL;\nfail:\n\tkfree(monmap);\n\treturn ERR_PTR(ret);\n}\n\n \nint ceph_monmap_contains(struct ceph_monmap *m, struct ceph_entity_addr *addr)\n{\n\tint i;\n\n\tfor (i = 0; i < m->num_mon; i++) {\n\t\tif (ceph_addr_equal_no_type(addr, &m->mon_inst[i].addr))\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\n \nstatic void __send_prepared_auth_request(struct ceph_mon_client *monc, int len)\n{\n\tmonc->pending_auth = 1;\n\tmonc->m_auth->front.iov_len = len;\n\tmonc->m_auth->hdr.front_len = cpu_to_le32(len);\n\tceph_msg_revoke(monc->m_auth);\n\tceph_msg_get(monc->m_auth);   \n\tceph_con_send(&monc->con, monc->m_auth);\n}\n\n \nstatic void __close_session(struct ceph_mon_client *monc)\n{\n\tdout(\"__close_session closing mon%d\\n\", monc->cur_mon);\n\tceph_msg_revoke(monc->m_auth);\n\tceph_msg_revoke_incoming(monc->m_auth_reply);\n\tceph_msg_revoke(monc->m_subscribe);\n\tceph_msg_revoke_incoming(monc->m_subscribe_ack);\n\tceph_con_close(&monc->con);\n\n\tmonc->pending_auth = 0;\n\tceph_auth_reset(monc->auth);\n}\n\n \nstatic void pick_new_mon(struct ceph_mon_client *monc)\n{\n\tint old_mon = monc->cur_mon;\n\n\tBUG_ON(monc->monmap->num_mon < 1);\n\n\tif (monc->monmap->num_mon == 1) {\n\t\tmonc->cur_mon = 0;\n\t} else {\n\t\tint max = monc->monmap->num_mon;\n\t\tint o = -1;\n\t\tint n;\n\n\t\tif (monc->cur_mon >= 0) {\n\t\t\tif (monc->cur_mon < monc->monmap->num_mon)\n\t\t\t\to = monc->cur_mon;\n\t\t\tif (o >= 0)\n\t\t\t\tmax--;\n\t\t}\n\n\t\tn = get_random_u32_below(max);\n\t\tif (o >= 0 && n >= o)\n\t\t\tn++;\n\n\t\tmonc->cur_mon = n;\n\t}\n\n\tdout(\"%s mon%d -> mon%d out of %d mons\\n\", __func__, old_mon,\n\t     monc->cur_mon, monc->monmap->num_mon);\n}\n\n \nstatic void __open_session(struct ceph_mon_client *monc)\n{\n\tint ret;\n\n\tpick_new_mon(monc);\n\n\tmonc->hunting = true;\n\tif (monc->had_a_connection) {\n\t\tmonc->hunt_mult *= CEPH_MONC_HUNT_BACKOFF;\n\t\tif (monc->hunt_mult > CEPH_MONC_HUNT_MAX_MULT)\n\t\t\tmonc->hunt_mult = CEPH_MONC_HUNT_MAX_MULT;\n\t}\n\n\tmonc->sub_renew_after = jiffies;  \n\tmonc->sub_renew_sent = 0;\n\n\tdout(\"%s opening mon%d\\n\", __func__, monc->cur_mon);\n\tceph_con_open(&monc->con, CEPH_ENTITY_TYPE_MON, monc->cur_mon,\n\t\t      &monc->monmap->mon_inst[monc->cur_mon].addr);\n\n\t \n\tceph_con_keepalive(&monc->con);\n\tif (ceph_msgr2(monc->client)) {\n\t\tmonc->pending_auth = 1;\n\t\treturn;\n\t}\n\n\t \n\tret = ceph_auth_build_hello(monc->auth,\n\t\t\t\t    monc->m_auth->front.iov_base,\n\t\t\t\t    monc->m_auth->front_alloc_len);\n\tBUG_ON(ret <= 0);\n\t__send_prepared_auth_request(monc, ret);\n}\n\nstatic void reopen_session(struct ceph_mon_client *monc)\n{\n\tif (!monc->hunting)\n\t\tpr_info(\"mon%d %s session lost, hunting for new mon\\n\",\n\t\t    monc->cur_mon, ceph_pr_addr(&monc->con.peer_addr));\n\n\t__close_session(monc);\n\t__open_session(monc);\n}\n\nvoid ceph_monc_reopen_session(struct ceph_mon_client *monc)\n{\n\tmutex_lock(&monc->mutex);\n\treopen_session(monc);\n\tmutex_unlock(&monc->mutex);\n}\n\nstatic void un_backoff(struct ceph_mon_client *monc)\n{\n\tmonc->hunt_mult /= 2;  \n\tif (monc->hunt_mult < 1)\n\t\tmonc->hunt_mult = 1;\n\tdout(\"%s hunt_mult now %d\\n\", __func__, monc->hunt_mult);\n}\n\n \nstatic void __schedule_delayed(struct ceph_mon_client *monc)\n{\n\tunsigned long delay;\n\n\tif (monc->hunting)\n\t\tdelay = CEPH_MONC_HUNT_INTERVAL * monc->hunt_mult;\n\telse\n\t\tdelay = CEPH_MONC_PING_INTERVAL;\n\n\tdout(\"__schedule_delayed after %lu\\n\", delay);\n\tmod_delayed_work(system_wq, &monc->delayed_work,\n\t\t\t round_jiffies_relative(delay));\n}\n\nconst char *ceph_sub_str[] = {\n\t[CEPH_SUB_MONMAP] = \"monmap\",\n\t[CEPH_SUB_OSDMAP] = \"osdmap\",\n\t[CEPH_SUB_FSMAP]  = \"fsmap.user\",\n\t[CEPH_SUB_MDSMAP] = \"mdsmap\",\n};\n\n \nstatic void __send_subscribe(struct ceph_mon_client *monc)\n{\n\tstruct ceph_msg *msg = monc->m_subscribe;\n\tvoid *p = msg->front.iov_base;\n\tvoid *const end = p + msg->front_alloc_len;\n\tint num = 0;\n\tint i;\n\n\tdout(\"%s sent %lu\\n\", __func__, monc->sub_renew_sent);\n\n\tBUG_ON(monc->cur_mon < 0);\n\n\tif (!monc->sub_renew_sent)\n\t\tmonc->sub_renew_sent = jiffies | 1;  \n\n\tmsg->hdr.version = cpu_to_le16(2);\n\n\tfor (i = 0; i < ARRAY_SIZE(monc->subs); i++) {\n\t\tif (monc->subs[i].want)\n\t\t\tnum++;\n\t}\n\tBUG_ON(num < 1);  \n\tceph_encode_32(&p, num);\n\tfor (i = 0; i < ARRAY_SIZE(monc->subs); i++) {\n\t\tchar buf[32];\n\t\tint len;\n\n\t\tif (!monc->subs[i].want)\n\t\t\tcontinue;\n\n\t\tlen = sprintf(buf, \"%s\", ceph_sub_str[i]);\n\t\tif (i == CEPH_SUB_MDSMAP &&\n\t\t    monc->fs_cluster_id != CEPH_FS_CLUSTER_ID_NONE)\n\t\t\tlen += sprintf(buf + len, \".%d\", monc->fs_cluster_id);\n\n\t\tdout(\"%s %s start %llu flags 0x%x\\n\", __func__, buf,\n\t\t     le64_to_cpu(monc->subs[i].item.start),\n\t\t     monc->subs[i].item.flags);\n\t\tceph_encode_string(&p, end, buf, len);\n\t\tmemcpy(p, &monc->subs[i].item, sizeof(monc->subs[i].item));\n\t\tp += sizeof(monc->subs[i].item);\n\t}\n\n\tBUG_ON(p > end);\n\tmsg->front.iov_len = p - msg->front.iov_base;\n\tmsg->hdr.front_len = cpu_to_le32(msg->front.iov_len);\n\tceph_msg_revoke(msg);\n\tceph_con_send(&monc->con, ceph_msg_get(msg));\n}\n\nstatic void handle_subscribe_ack(struct ceph_mon_client *monc,\n\t\t\t\t struct ceph_msg *msg)\n{\n\tunsigned int seconds;\n\tstruct ceph_mon_subscribe_ack *h = msg->front.iov_base;\n\n\tif (msg->front.iov_len < sizeof(*h))\n\t\tgoto bad;\n\tseconds = le32_to_cpu(h->duration);\n\n\tmutex_lock(&monc->mutex);\n\tif (monc->sub_renew_sent) {\n\t\t \n\t\tmonc->sub_renew_after = monc->sub_renew_sent +\n\t\t\t\t\t    (seconds >> 1) * HZ - 1;\n\t\tdout(\"%s sent %lu duration %d renew after %lu\\n\", __func__,\n\t\t     monc->sub_renew_sent, seconds, monc->sub_renew_after);\n\t\tmonc->sub_renew_sent = 0;\n\t} else {\n\t\tdout(\"%s sent %lu renew after %lu, ignoring\\n\", __func__,\n\t\t     monc->sub_renew_sent, monc->sub_renew_after);\n\t}\n\tmutex_unlock(&monc->mutex);\n\treturn;\nbad:\n\tpr_err(\"got corrupt subscribe-ack msg\\n\");\n\tceph_msg_dump(msg);\n}\n\n \nstatic bool __ceph_monc_want_map(struct ceph_mon_client *monc, int sub,\n\t\t\t\t u32 epoch, bool continuous)\n{\n\t__le64 start = cpu_to_le64(epoch);\n\tu8 flags = !continuous ? CEPH_SUBSCRIBE_ONETIME : 0;\n\n\tdout(\"%s %s epoch %u continuous %d\\n\", __func__, ceph_sub_str[sub],\n\t     epoch, continuous);\n\n\tif (monc->subs[sub].want &&\n\t    monc->subs[sub].item.start == start &&\n\t    monc->subs[sub].item.flags == flags)\n\t\treturn false;\n\n\tmonc->subs[sub].item.start = start;\n\tmonc->subs[sub].item.flags = flags;\n\tmonc->subs[sub].want = true;\n\n\treturn true;\n}\n\nbool ceph_monc_want_map(struct ceph_mon_client *monc, int sub, u32 epoch,\n\t\t\tbool continuous)\n{\n\tbool need_request;\n\n\tmutex_lock(&monc->mutex);\n\tneed_request = __ceph_monc_want_map(monc, sub, epoch, continuous);\n\tmutex_unlock(&monc->mutex);\n\n\treturn need_request;\n}\nEXPORT_SYMBOL(ceph_monc_want_map);\n\n \nstatic void __ceph_monc_got_map(struct ceph_mon_client *monc, int sub,\n\t\t\t\tu32 epoch)\n{\n\tdout(\"%s %s epoch %u\\n\", __func__, ceph_sub_str[sub], epoch);\n\n\tif (monc->subs[sub].want) {\n\t\tif (monc->subs[sub].item.flags & CEPH_SUBSCRIBE_ONETIME)\n\t\t\tmonc->subs[sub].want = false;\n\t\telse\n\t\t\tmonc->subs[sub].item.start = cpu_to_le64(epoch + 1);\n\t}\n\n\tmonc->subs[sub].have = epoch;\n}\n\nvoid ceph_monc_got_map(struct ceph_mon_client *monc, int sub, u32 epoch)\n{\n\tmutex_lock(&monc->mutex);\n\t__ceph_monc_got_map(monc, sub, epoch);\n\tmutex_unlock(&monc->mutex);\n}\nEXPORT_SYMBOL(ceph_monc_got_map);\n\nvoid ceph_monc_renew_subs(struct ceph_mon_client *monc)\n{\n\tmutex_lock(&monc->mutex);\n\t__send_subscribe(monc);\n\tmutex_unlock(&monc->mutex);\n}\nEXPORT_SYMBOL(ceph_monc_renew_subs);\n\n \nint ceph_monc_wait_osdmap(struct ceph_mon_client *monc, u32 epoch,\n\t\t\t  unsigned long timeout)\n{\n\tunsigned long started = jiffies;\n\tlong ret;\n\n\tmutex_lock(&monc->mutex);\n\twhile (monc->subs[CEPH_SUB_OSDMAP].have < epoch) {\n\t\tmutex_unlock(&monc->mutex);\n\n\t\tif (timeout && time_after_eq(jiffies, started + timeout))\n\t\t\treturn -ETIMEDOUT;\n\n\t\tret = wait_event_interruptible_timeout(monc->client->auth_wq,\n\t\t\t\t     monc->subs[CEPH_SUB_OSDMAP].have >= epoch,\n\t\t\t\t     ceph_timeout_jiffies(timeout));\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tmutex_lock(&monc->mutex);\n\t}\n\n\tmutex_unlock(&monc->mutex);\n\treturn 0;\n}\nEXPORT_SYMBOL(ceph_monc_wait_osdmap);\n\n \nint ceph_monc_open_session(struct ceph_mon_client *monc)\n{\n\tmutex_lock(&monc->mutex);\n\t__ceph_monc_want_map(monc, CEPH_SUB_MONMAP, 0, true);\n\t__ceph_monc_want_map(monc, CEPH_SUB_OSDMAP, 0, false);\n\t__open_session(monc);\n\t__schedule_delayed(monc);\n\tmutex_unlock(&monc->mutex);\n\treturn 0;\n}\nEXPORT_SYMBOL(ceph_monc_open_session);\n\nstatic void ceph_monc_handle_map(struct ceph_mon_client *monc,\n\t\t\t\t struct ceph_msg *msg)\n{\n\tstruct ceph_client *client = monc->client;\n\tstruct ceph_monmap *monmap;\n\tvoid *p, *end;\n\n\tmutex_lock(&monc->mutex);\n\n\tdout(\"handle_monmap\\n\");\n\tp = msg->front.iov_base;\n\tend = p + msg->front.iov_len;\n\n\tmonmap = ceph_monmap_decode(&p, end, ceph_msgr2(client));\n\tif (IS_ERR(monmap)) {\n\t\tpr_err(\"problem decoding monmap, %d\\n\",\n\t\t       (int)PTR_ERR(monmap));\n\t\tceph_msg_dump(msg);\n\t\tgoto out;\n\t}\n\n\tif (ceph_check_fsid(client, &monmap->fsid) < 0) {\n\t\tkfree(monmap);\n\t\tgoto out;\n\t}\n\n\tkfree(monc->monmap);\n\tmonc->monmap = monmap;\n\n\t__ceph_monc_got_map(monc, CEPH_SUB_MONMAP, monc->monmap->epoch);\n\tclient->have_fsid = true;\n\nout:\n\tmutex_unlock(&monc->mutex);\n\twake_up_all(&client->auth_wq);\n}\n\n \nDEFINE_RB_FUNCS(generic_request, struct ceph_mon_generic_request, tid, node)\n\nstatic void release_generic_request(struct kref *kref)\n{\n\tstruct ceph_mon_generic_request *req =\n\t\tcontainer_of(kref, struct ceph_mon_generic_request, kref);\n\n\tdout(\"%s greq %p request %p reply %p\\n\", __func__, req, req->request,\n\t     req->reply);\n\tWARN_ON(!RB_EMPTY_NODE(&req->node));\n\n\tif (req->reply)\n\t\tceph_msg_put(req->reply);\n\tif (req->request)\n\t\tceph_msg_put(req->request);\n\n\tkfree(req);\n}\n\nstatic void put_generic_request(struct ceph_mon_generic_request *req)\n{\n\tif (req)\n\t\tkref_put(&req->kref, release_generic_request);\n}\n\nstatic void get_generic_request(struct ceph_mon_generic_request *req)\n{\n\tkref_get(&req->kref);\n}\n\nstatic struct ceph_mon_generic_request *\nalloc_generic_request(struct ceph_mon_client *monc, gfp_t gfp)\n{\n\tstruct ceph_mon_generic_request *req;\n\n\treq = kzalloc(sizeof(*req), gfp);\n\tif (!req)\n\t\treturn NULL;\n\n\treq->monc = monc;\n\tkref_init(&req->kref);\n\tRB_CLEAR_NODE(&req->node);\n\tinit_completion(&req->completion);\n\n\tdout(\"%s greq %p\\n\", __func__, req);\n\treturn req;\n}\n\nstatic void register_generic_request(struct ceph_mon_generic_request *req)\n{\n\tstruct ceph_mon_client *monc = req->monc;\n\n\tWARN_ON(req->tid);\n\n\tget_generic_request(req);\n\treq->tid = ++monc->last_tid;\n\tinsert_generic_request(&monc->generic_request_tree, req);\n}\n\nstatic void send_generic_request(struct ceph_mon_client *monc,\n\t\t\t\t struct ceph_mon_generic_request *req)\n{\n\tWARN_ON(!req->tid);\n\n\tdout(\"%s greq %p tid %llu\\n\", __func__, req, req->tid);\n\treq->request->hdr.tid = cpu_to_le64(req->tid);\n\tceph_con_send(&monc->con, ceph_msg_get(req->request));\n}\n\nstatic void __finish_generic_request(struct ceph_mon_generic_request *req)\n{\n\tstruct ceph_mon_client *monc = req->monc;\n\n\tdout(\"%s greq %p tid %llu\\n\", __func__, req, req->tid);\n\terase_generic_request(&monc->generic_request_tree, req);\n\n\tceph_msg_revoke(req->request);\n\tceph_msg_revoke_incoming(req->reply);\n}\n\nstatic void finish_generic_request(struct ceph_mon_generic_request *req)\n{\n\t__finish_generic_request(req);\n\tput_generic_request(req);\n}\n\nstatic void complete_generic_request(struct ceph_mon_generic_request *req)\n{\n\tif (req->complete_cb)\n\t\treq->complete_cb(req);\n\telse\n\t\tcomplete_all(&req->completion);\n\tput_generic_request(req);\n}\n\nstatic void cancel_generic_request(struct ceph_mon_generic_request *req)\n{\n\tstruct ceph_mon_client *monc = req->monc;\n\tstruct ceph_mon_generic_request *lookup_req;\n\n\tdout(\"%s greq %p tid %llu\\n\", __func__, req, req->tid);\n\n\tmutex_lock(&monc->mutex);\n\tlookup_req = lookup_generic_request(&monc->generic_request_tree,\n\t\t\t\t\t    req->tid);\n\tif (lookup_req) {\n\t\tWARN_ON(lookup_req != req);\n\t\tfinish_generic_request(req);\n\t}\n\n\tmutex_unlock(&monc->mutex);\n}\n\nstatic int wait_generic_request(struct ceph_mon_generic_request *req)\n{\n\tint ret;\n\n\tdout(\"%s greq %p tid %llu\\n\", __func__, req, req->tid);\n\tret = wait_for_completion_interruptible(&req->completion);\n\tif (ret)\n\t\tcancel_generic_request(req);\n\telse\n\t\tret = req->result;  \n\n\treturn ret;\n}\n\nstatic struct ceph_msg *get_generic_reply(struct ceph_connection *con,\n\t\t\t\t\t struct ceph_msg_header *hdr,\n\t\t\t\t\t int *skip)\n{\n\tstruct ceph_mon_client *monc = con->private;\n\tstruct ceph_mon_generic_request *req;\n\tu64 tid = le64_to_cpu(hdr->tid);\n\tstruct ceph_msg *m;\n\n\tmutex_lock(&monc->mutex);\n\treq = lookup_generic_request(&monc->generic_request_tree, tid);\n\tif (!req) {\n\t\tdout(\"get_generic_reply %lld dne\\n\", tid);\n\t\t*skip = 1;\n\t\tm = NULL;\n\t} else {\n\t\tdout(\"get_generic_reply %lld got %p\\n\", tid, req->reply);\n\t\t*skip = 0;\n\t\tm = ceph_msg_get(req->reply);\n\t\t \n\t}\n\tmutex_unlock(&monc->mutex);\n\treturn m;\n}\n\n \nstatic void handle_statfs_reply(struct ceph_mon_client *monc,\n\t\t\t\tstruct ceph_msg *msg)\n{\n\tstruct ceph_mon_generic_request *req;\n\tstruct ceph_mon_statfs_reply *reply = msg->front.iov_base;\n\tu64 tid = le64_to_cpu(msg->hdr.tid);\n\n\tdout(\"%s msg %p tid %llu\\n\", __func__, msg, tid);\n\n\tif (msg->front.iov_len != sizeof(*reply))\n\t\tgoto bad;\n\n\tmutex_lock(&monc->mutex);\n\treq = lookup_generic_request(&monc->generic_request_tree, tid);\n\tif (!req) {\n\t\tmutex_unlock(&monc->mutex);\n\t\treturn;\n\t}\n\n\treq->result = 0;\n\t*req->u.st = reply->st;  \n\t__finish_generic_request(req);\n\tmutex_unlock(&monc->mutex);\n\n\tcomplete_generic_request(req);\n\treturn;\n\nbad:\n\tpr_err(\"corrupt statfs reply, tid %llu\\n\", tid);\n\tceph_msg_dump(msg);\n}\n\n \nint ceph_monc_do_statfs(struct ceph_mon_client *monc, u64 data_pool,\n\t\t\tstruct ceph_statfs *buf)\n{\n\tstruct ceph_mon_generic_request *req;\n\tstruct ceph_mon_statfs *h;\n\tint ret = -ENOMEM;\n\n\treq = alloc_generic_request(monc, GFP_NOFS);\n\tif (!req)\n\t\tgoto out;\n\n\treq->request = ceph_msg_new(CEPH_MSG_STATFS, sizeof(*h), GFP_NOFS,\n\t\t\t\t    true);\n\tif (!req->request)\n\t\tgoto out;\n\n\treq->reply = ceph_msg_new(CEPH_MSG_STATFS_REPLY, 64, GFP_NOFS, true);\n\tif (!req->reply)\n\t\tgoto out;\n\n\treq->u.st = buf;\n\treq->request->hdr.version = cpu_to_le16(2);\n\n\tmutex_lock(&monc->mutex);\n\tregister_generic_request(req);\n\t \n\th = req->request->front.iov_base;\n\th->monhdr.have_version = 0;\n\th->monhdr.session_mon = cpu_to_le16(-1);\n\th->monhdr.session_mon_tid = 0;\n\th->fsid = monc->monmap->fsid;\n\th->contains_data_pool = (data_pool != CEPH_NOPOOL);\n\th->data_pool = cpu_to_le64(data_pool);\n\tsend_generic_request(monc, req);\n\tmutex_unlock(&monc->mutex);\n\n\tret = wait_generic_request(req);\nout:\n\tput_generic_request(req);\n\treturn ret;\n}\nEXPORT_SYMBOL(ceph_monc_do_statfs);\n\nstatic void handle_get_version_reply(struct ceph_mon_client *monc,\n\t\t\t\t     struct ceph_msg *msg)\n{\n\tstruct ceph_mon_generic_request *req;\n\tu64 tid = le64_to_cpu(msg->hdr.tid);\n\tvoid *p = msg->front.iov_base;\n\tvoid *end = p + msg->front_alloc_len;\n\tu64 handle;\n\n\tdout(\"%s msg %p tid %llu\\n\", __func__, msg, tid);\n\n\tceph_decode_need(&p, end, 2*sizeof(u64), bad);\n\thandle = ceph_decode_64(&p);\n\tif (tid != 0 && tid != handle)\n\t\tgoto bad;\n\n\tmutex_lock(&monc->mutex);\n\treq = lookup_generic_request(&monc->generic_request_tree, handle);\n\tif (!req) {\n\t\tmutex_unlock(&monc->mutex);\n\t\treturn;\n\t}\n\n\treq->result = 0;\n\treq->u.newest = ceph_decode_64(&p);\n\t__finish_generic_request(req);\n\tmutex_unlock(&monc->mutex);\n\n\tcomplete_generic_request(req);\n\treturn;\n\nbad:\n\tpr_err(\"corrupt mon_get_version reply, tid %llu\\n\", tid);\n\tceph_msg_dump(msg);\n}\n\nstatic struct ceph_mon_generic_request *\n__ceph_monc_get_version(struct ceph_mon_client *monc, const char *what,\n\t\t\tceph_monc_callback_t cb, u64 private_data)\n{\n\tstruct ceph_mon_generic_request *req;\n\n\treq = alloc_generic_request(monc, GFP_NOIO);\n\tif (!req)\n\t\tgoto err_put_req;\n\n\treq->request = ceph_msg_new(CEPH_MSG_MON_GET_VERSION,\n\t\t\t\t    sizeof(u64) + sizeof(u32) + strlen(what),\n\t\t\t\t    GFP_NOIO, true);\n\tif (!req->request)\n\t\tgoto err_put_req;\n\n\treq->reply = ceph_msg_new(CEPH_MSG_MON_GET_VERSION_REPLY, 32, GFP_NOIO,\n\t\t\t\t  true);\n\tif (!req->reply)\n\t\tgoto err_put_req;\n\n\treq->complete_cb = cb;\n\treq->private_data = private_data;\n\n\tmutex_lock(&monc->mutex);\n\tregister_generic_request(req);\n\t{\n\t\tvoid *p = req->request->front.iov_base;\n\t\tvoid *const end = p + req->request->front_alloc_len;\n\n\t\tceph_encode_64(&p, req->tid);  \n\t\tceph_encode_string(&p, end, what, strlen(what));\n\t\tWARN_ON(p != end);\n\t}\n\tsend_generic_request(monc, req);\n\tmutex_unlock(&monc->mutex);\n\n\treturn req;\n\nerr_put_req:\n\tput_generic_request(req);\n\treturn ERR_PTR(-ENOMEM);\n}\n\n \nint ceph_monc_get_version(struct ceph_mon_client *monc, const char *what,\n\t\t\t  u64 *newest)\n{\n\tstruct ceph_mon_generic_request *req;\n\tint ret;\n\n\treq = __ceph_monc_get_version(monc, what, NULL, 0);\n\tif (IS_ERR(req))\n\t\treturn PTR_ERR(req);\n\n\tret = wait_generic_request(req);\n\tif (!ret)\n\t\t*newest = req->u.newest;\n\n\tput_generic_request(req);\n\treturn ret;\n}\nEXPORT_SYMBOL(ceph_monc_get_version);\n\n \nint ceph_monc_get_version_async(struct ceph_mon_client *monc, const char *what,\n\t\t\t\tceph_monc_callback_t cb, u64 private_data)\n{\n\tstruct ceph_mon_generic_request *req;\n\n\treq = __ceph_monc_get_version(monc, what, cb, private_data);\n\tif (IS_ERR(req))\n\t\treturn PTR_ERR(req);\n\n\tput_generic_request(req);\n\treturn 0;\n}\nEXPORT_SYMBOL(ceph_monc_get_version_async);\n\nstatic void handle_command_ack(struct ceph_mon_client *monc,\n\t\t\t       struct ceph_msg *msg)\n{\n\tstruct ceph_mon_generic_request *req;\n\tvoid *p = msg->front.iov_base;\n\tvoid *const end = p + msg->front_alloc_len;\n\tu64 tid = le64_to_cpu(msg->hdr.tid);\n\n\tdout(\"%s msg %p tid %llu\\n\", __func__, msg, tid);\n\n\tceph_decode_need(&p, end, sizeof(struct ceph_mon_request_header) +\n\t\t\t\t\t\t\t    sizeof(u32), bad);\n\tp += sizeof(struct ceph_mon_request_header);\n\n\tmutex_lock(&monc->mutex);\n\treq = lookup_generic_request(&monc->generic_request_tree, tid);\n\tif (!req) {\n\t\tmutex_unlock(&monc->mutex);\n\t\treturn;\n\t}\n\n\treq->result = ceph_decode_32(&p);\n\t__finish_generic_request(req);\n\tmutex_unlock(&monc->mutex);\n\n\tcomplete_generic_request(req);\n\treturn;\n\nbad:\n\tpr_err(\"corrupt mon_command ack, tid %llu\\n\", tid);\n\tceph_msg_dump(msg);\n}\n\nstatic __printf(2, 0)\nint do_mon_command_vargs(struct ceph_mon_client *monc, const char *fmt,\n\t\t\t va_list ap)\n{\n\tstruct ceph_mon_generic_request *req;\n\tstruct ceph_mon_command *h;\n\tint ret = -ENOMEM;\n\tint len;\n\n\treq = alloc_generic_request(monc, GFP_NOIO);\n\tif (!req)\n\t\tgoto out;\n\n\treq->request = ceph_msg_new(CEPH_MSG_MON_COMMAND, 256, GFP_NOIO, true);\n\tif (!req->request)\n\t\tgoto out;\n\n\treq->reply = ceph_msg_new(CEPH_MSG_MON_COMMAND_ACK, 512, GFP_NOIO,\n\t\t\t\t  true);\n\tif (!req->reply)\n\t\tgoto out;\n\n\tmutex_lock(&monc->mutex);\n\tregister_generic_request(req);\n\th = req->request->front.iov_base;\n\th->monhdr.have_version = 0;\n\th->monhdr.session_mon = cpu_to_le16(-1);\n\th->monhdr.session_mon_tid = 0;\n\th->fsid = monc->monmap->fsid;\n\th->num_strs = cpu_to_le32(1);\n\tlen = vsprintf(h->str, fmt, ap);\n\th->str_len = cpu_to_le32(len);\n\tsend_generic_request(monc, req);\n\tmutex_unlock(&monc->mutex);\n\n\tret = wait_generic_request(req);\nout:\n\tput_generic_request(req);\n\treturn ret;\n}\n\nstatic __printf(2, 3)\nint do_mon_command(struct ceph_mon_client *monc, const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\n\tva_start(ap, fmt);\n\tret = do_mon_command_vargs(monc, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}\n\nint ceph_monc_blocklist_add(struct ceph_mon_client *monc,\n\t\t\t    struct ceph_entity_addr *client_addr)\n{\n\tint ret;\n\n\tret = do_mon_command(monc,\n\t\t\t     \"{ \\\"prefix\\\": \\\"osd blocklist\\\", \\\n\t\t\t\t\\\"blocklistop\\\": \\\"add\\\", \\\n\t\t\t\t\\\"addr\\\": \\\"%pISpc/%u\\\" }\",\n\t\t\t     &client_addr->in_addr,\n\t\t\t     le32_to_cpu(client_addr->nonce));\n\tif (ret == -EINVAL) {\n\t\t \n\t\tret = do_mon_command(monc,\n\t\t\t\t     \"{ \\\"prefix\\\": \\\"osd blacklist\\\", \\\n\t\t\t\t\t\\\"blacklistop\\\": \\\"add\\\", \\\n\t\t\t\t\t\\\"addr\\\": \\\"%pISpc/%u\\\" }\",\n\t\t\t\t     &client_addr->in_addr,\n\t\t\t\t     le32_to_cpu(client_addr->nonce));\n\t}\n\tif (ret)\n\t\treturn ret;\n\n\t \n\treturn ceph_wait_for_latest_osdmap(monc->client, 0);\n}\nEXPORT_SYMBOL(ceph_monc_blocklist_add);\n\n \nstatic void __resend_generic_request(struct ceph_mon_client *monc)\n{\n\tstruct ceph_mon_generic_request *req;\n\tstruct rb_node *p;\n\n\tfor (p = rb_first(&monc->generic_request_tree); p; p = rb_next(p)) {\n\t\treq = rb_entry(p, struct ceph_mon_generic_request, node);\n\t\tceph_msg_revoke(req->request);\n\t\tceph_msg_revoke_incoming(req->reply);\n\t\tceph_con_send(&monc->con, ceph_msg_get(req->request));\n\t}\n}\n\n \nstatic void delayed_work(struct work_struct *work)\n{\n\tstruct ceph_mon_client *monc =\n\t\tcontainer_of(work, struct ceph_mon_client, delayed_work.work);\n\n\tdout(\"monc delayed_work\\n\");\n\tmutex_lock(&monc->mutex);\n\tif (monc->hunting) {\n\t\tdout(\"%s continuing hunt\\n\", __func__);\n\t\treopen_session(monc);\n\t} else {\n\t\tint is_auth = ceph_auth_is_authenticated(monc->auth);\n\t\tif (ceph_con_keepalive_expired(&monc->con,\n\t\t\t\t\t       CEPH_MONC_PING_TIMEOUT)) {\n\t\t\tdout(\"monc keepalive timeout\\n\");\n\t\t\tis_auth = 0;\n\t\t\treopen_session(monc);\n\t\t}\n\n\t\tif (!monc->hunting) {\n\t\t\tceph_con_keepalive(&monc->con);\n\t\t\t__validate_auth(monc);\n\t\t\tun_backoff(monc);\n\t\t}\n\n\t\tif (is_auth &&\n\t\t    !(monc->con.peer_features & CEPH_FEATURE_MON_STATEFUL_SUB)) {\n\t\t\tunsigned long now = jiffies;\n\n\t\t\tdout(\"%s renew subs? now %lu renew after %lu\\n\",\n\t\t\t     __func__, now, monc->sub_renew_after);\n\t\t\tif (time_after_eq(now, monc->sub_renew_after))\n\t\t\t\t__send_subscribe(monc);\n\t\t}\n\t}\n\t__schedule_delayed(monc);\n\tmutex_unlock(&monc->mutex);\n}\n\n \nstatic int build_initial_monmap(struct ceph_mon_client *monc)\n{\n\t__le32 my_type = ceph_msgr2(monc->client) ?\n\t\tCEPH_ENTITY_ADDR_TYPE_MSGR2 : CEPH_ENTITY_ADDR_TYPE_LEGACY;\n\tstruct ceph_options *opt = monc->client->options;\n\tint num_mon = opt->num_mon;\n\tint i;\n\n\t \n\tmonc->monmap = kzalloc(struct_size(monc->monmap, mon_inst, num_mon),\n\t\t\t       GFP_KERNEL);\n\tif (!monc->monmap)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < num_mon; i++) {\n\t\tstruct ceph_entity_inst *inst = &monc->monmap->mon_inst[i];\n\n\t\tmemcpy(&inst->addr.in_addr, &opt->mon_addr[i].in_addr,\n\t\t       sizeof(inst->addr.in_addr));\n\t\tinst->addr.type = my_type;\n\t\tinst->addr.nonce = 0;\n\t\tinst->name.type = CEPH_ENTITY_TYPE_MON;\n\t\tinst->name.num = cpu_to_le64(i);\n\t}\n\tmonc->monmap->num_mon = num_mon;\n\treturn 0;\n}\n\nint ceph_monc_init(struct ceph_mon_client *monc, struct ceph_client *cl)\n{\n\tint err;\n\n\tdout(\"init\\n\");\n\tmemset(monc, 0, sizeof(*monc));\n\tmonc->client = cl;\n\tmutex_init(&monc->mutex);\n\n\terr = build_initial_monmap(monc);\n\tif (err)\n\t\tgoto out;\n\n\t \n\t \n\tmonc->auth = ceph_auth_init(cl->options->name, cl->options->key,\n\t\t\t\t    cl->options->con_modes);\n\tif (IS_ERR(monc->auth)) {\n\t\terr = PTR_ERR(monc->auth);\n\t\tgoto out_monmap;\n\t}\n\tmonc->auth->want_keys =\n\t\tCEPH_ENTITY_TYPE_AUTH | CEPH_ENTITY_TYPE_MON |\n\t\tCEPH_ENTITY_TYPE_OSD | CEPH_ENTITY_TYPE_MDS;\n\n\t \n\terr = -ENOMEM;\n\tmonc->m_subscribe_ack = ceph_msg_new(CEPH_MSG_MON_SUBSCRIBE_ACK,\n\t\t\t\t     sizeof(struct ceph_mon_subscribe_ack),\n\t\t\t\t     GFP_KERNEL, true);\n\tif (!monc->m_subscribe_ack)\n\t\tgoto out_auth;\n\n\tmonc->m_subscribe = ceph_msg_new(CEPH_MSG_MON_SUBSCRIBE, 128,\n\t\t\t\t\t GFP_KERNEL, true);\n\tif (!monc->m_subscribe)\n\t\tgoto out_subscribe_ack;\n\n\tmonc->m_auth_reply = ceph_msg_new(CEPH_MSG_AUTH_REPLY, 4096,\n\t\t\t\t\t  GFP_KERNEL, true);\n\tif (!monc->m_auth_reply)\n\t\tgoto out_subscribe;\n\n\tmonc->m_auth = ceph_msg_new(CEPH_MSG_AUTH, 4096, GFP_KERNEL, true);\n\tmonc->pending_auth = 0;\n\tif (!monc->m_auth)\n\t\tgoto out_auth_reply;\n\n\tceph_con_init(&monc->con, monc, &mon_con_ops,\n\t\t      &monc->client->msgr);\n\n\tmonc->cur_mon = -1;\n\tmonc->had_a_connection = false;\n\tmonc->hunt_mult = 1;\n\n\tINIT_DELAYED_WORK(&monc->delayed_work, delayed_work);\n\tmonc->generic_request_tree = RB_ROOT;\n\tmonc->last_tid = 0;\n\n\tmonc->fs_cluster_id = CEPH_FS_CLUSTER_ID_NONE;\n\n\treturn 0;\n\nout_auth_reply:\n\tceph_msg_put(monc->m_auth_reply);\nout_subscribe:\n\tceph_msg_put(monc->m_subscribe);\nout_subscribe_ack:\n\tceph_msg_put(monc->m_subscribe_ack);\nout_auth:\n\tceph_auth_destroy(monc->auth);\nout_monmap:\n\tkfree(monc->monmap);\nout:\n\treturn err;\n}\nEXPORT_SYMBOL(ceph_monc_init);\n\nvoid ceph_monc_stop(struct ceph_mon_client *monc)\n{\n\tdout(\"stop\\n\");\n\tcancel_delayed_work_sync(&monc->delayed_work);\n\n\tmutex_lock(&monc->mutex);\n\t__close_session(monc);\n\tmonc->cur_mon = -1;\n\tmutex_unlock(&monc->mutex);\n\n\t \n\tceph_msgr_flush();\n\n\tceph_auth_destroy(monc->auth);\n\n\tWARN_ON(!RB_EMPTY_ROOT(&monc->generic_request_tree));\n\n\tceph_msg_put(monc->m_auth);\n\tceph_msg_put(monc->m_auth_reply);\n\tceph_msg_put(monc->m_subscribe);\n\tceph_msg_put(monc->m_subscribe_ack);\n\n\tkfree(monc->monmap);\n}\nEXPORT_SYMBOL(ceph_monc_stop);\n\nstatic void finish_hunting(struct ceph_mon_client *monc)\n{\n\tif (monc->hunting) {\n\t\tdout(\"%s found mon%d\\n\", __func__, monc->cur_mon);\n\t\tmonc->hunting = false;\n\t\tmonc->had_a_connection = true;\n\t\tun_backoff(monc);\n\t\t__schedule_delayed(monc);\n\t}\n}\n\nstatic void finish_auth(struct ceph_mon_client *monc, int auth_err,\n\t\t\tbool was_authed)\n{\n\tdout(\"%s auth_err %d was_authed %d\\n\", __func__, auth_err, was_authed);\n\tWARN_ON(auth_err > 0);\n\n\tmonc->pending_auth = 0;\n\tif (auth_err) {\n\t\tmonc->client->auth_err = auth_err;\n\t\twake_up_all(&monc->client->auth_wq);\n\t\treturn;\n\t}\n\n\tif (!was_authed && ceph_auth_is_authenticated(monc->auth)) {\n\t\tdout(\"%s authenticated, starting session global_id %llu\\n\",\n\t\t     __func__, monc->auth->global_id);\n\n\t\tmonc->client->msgr.inst.name.type = CEPH_ENTITY_TYPE_CLIENT;\n\t\tmonc->client->msgr.inst.name.num =\n\t\t\t\t\tcpu_to_le64(monc->auth->global_id);\n\n\t\t__send_subscribe(monc);\n\t\t__resend_generic_request(monc);\n\n\t\tpr_info(\"mon%d %s session established\\n\", monc->cur_mon,\n\t\t\tceph_pr_addr(&monc->con.peer_addr));\n\t}\n}\n\nstatic void handle_auth_reply(struct ceph_mon_client *monc,\n\t\t\t      struct ceph_msg *msg)\n{\n\tbool was_authed;\n\tint ret;\n\n\tmutex_lock(&monc->mutex);\n\twas_authed = ceph_auth_is_authenticated(monc->auth);\n\tret = ceph_handle_auth_reply(monc->auth, msg->front.iov_base,\n\t\t\t\t     msg->front.iov_len,\n\t\t\t\t     monc->m_auth->front.iov_base,\n\t\t\t\t     monc->m_auth->front_alloc_len);\n\tif (ret > 0) {\n\t\t__send_prepared_auth_request(monc, ret);\n\t} else {\n\t\tfinish_auth(monc, ret, was_authed);\n\t\tfinish_hunting(monc);\n\t}\n\tmutex_unlock(&monc->mutex);\n}\n\nstatic int __validate_auth(struct ceph_mon_client *monc)\n{\n\tint ret;\n\n\tif (monc->pending_auth)\n\t\treturn 0;\n\n\tret = ceph_build_auth(monc->auth, monc->m_auth->front.iov_base,\n\t\t\t      monc->m_auth->front_alloc_len);\n\tif (ret <= 0)\n\t\treturn ret;  \n\t__send_prepared_auth_request(monc, ret);\n\treturn 0;\n}\n\nint ceph_monc_validate_auth(struct ceph_mon_client *monc)\n{\n\tint ret;\n\n\tmutex_lock(&monc->mutex);\n\tret = __validate_auth(monc);\n\tmutex_unlock(&monc->mutex);\n\treturn ret;\n}\nEXPORT_SYMBOL(ceph_monc_validate_auth);\n\nstatic int mon_get_auth_request(struct ceph_connection *con,\n\t\t\t\tvoid *buf, int *buf_len,\n\t\t\t\tvoid **authorizer, int *authorizer_len)\n{\n\tstruct ceph_mon_client *monc = con->private;\n\tint ret;\n\n\tmutex_lock(&monc->mutex);\n\tret = ceph_auth_get_request(monc->auth, buf, *buf_len);\n\tmutex_unlock(&monc->mutex);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t*buf_len = ret;\n\t*authorizer = NULL;\n\t*authorizer_len = 0;\n\treturn 0;\n}\n\nstatic int mon_handle_auth_reply_more(struct ceph_connection *con,\n\t\t\t\t      void *reply, int reply_len,\n\t\t\t\t      void *buf, int *buf_len,\n\t\t\t\t      void **authorizer, int *authorizer_len)\n{\n\tstruct ceph_mon_client *monc = con->private;\n\tint ret;\n\n\tmutex_lock(&monc->mutex);\n\tret = ceph_auth_handle_reply_more(monc->auth, reply, reply_len,\n\t\t\t\t\t  buf, *buf_len);\n\tmutex_unlock(&monc->mutex);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t*buf_len = ret;\n\t*authorizer = NULL;\n\t*authorizer_len = 0;\n\treturn 0;\n}\n\nstatic int mon_handle_auth_done(struct ceph_connection *con,\n\t\t\t\tu64 global_id, void *reply, int reply_len,\n\t\t\t\tu8 *session_key, int *session_key_len,\n\t\t\t\tu8 *con_secret, int *con_secret_len)\n{\n\tstruct ceph_mon_client *monc = con->private;\n\tbool was_authed;\n\tint ret;\n\n\tmutex_lock(&monc->mutex);\n\tWARN_ON(!monc->hunting);\n\twas_authed = ceph_auth_is_authenticated(monc->auth);\n\tret = ceph_auth_handle_reply_done(monc->auth, global_id,\n\t\t\t\t\t  reply, reply_len,\n\t\t\t\t\t  session_key, session_key_len,\n\t\t\t\t\t  con_secret, con_secret_len);\n\tfinish_auth(monc, ret, was_authed);\n\tif (!ret)\n\t\tfinish_hunting(monc);\n\tmutex_unlock(&monc->mutex);\n\treturn 0;\n}\n\nstatic int mon_handle_auth_bad_method(struct ceph_connection *con,\n\t\t\t\t      int used_proto, int result,\n\t\t\t\t      const int *allowed_protos, int proto_cnt,\n\t\t\t\t      const int *allowed_modes, int mode_cnt)\n{\n\tstruct ceph_mon_client *monc = con->private;\n\tbool was_authed;\n\n\tmutex_lock(&monc->mutex);\n\tWARN_ON(!monc->hunting);\n\twas_authed = ceph_auth_is_authenticated(monc->auth);\n\tceph_auth_handle_bad_method(monc->auth, used_proto, result,\n\t\t\t\t    allowed_protos, proto_cnt,\n\t\t\t\t    allowed_modes, mode_cnt);\n\tfinish_auth(monc, -EACCES, was_authed);\n\tmutex_unlock(&monc->mutex);\n\treturn 0;\n}\n\n \nstatic void mon_dispatch(struct ceph_connection *con, struct ceph_msg *msg)\n{\n\tstruct ceph_mon_client *monc = con->private;\n\tint type = le16_to_cpu(msg->hdr.type);\n\n\tswitch (type) {\n\tcase CEPH_MSG_AUTH_REPLY:\n\t\thandle_auth_reply(monc, msg);\n\t\tbreak;\n\n\tcase CEPH_MSG_MON_SUBSCRIBE_ACK:\n\t\thandle_subscribe_ack(monc, msg);\n\t\tbreak;\n\n\tcase CEPH_MSG_STATFS_REPLY:\n\t\thandle_statfs_reply(monc, msg);\n\t\tbreak;\n\n\tcase CEPH_MSG_MON_GET_VERSION_REPLY:\n\t\thandle_get_version_reply(monc, msg);\n\t\tbreak;\n\n\tcase CEPH_MSG_MON_COMMAND_ACK:\n\t\thandle_command_ack(monc, msg);\n\t\tbreak;\n\n\tcase CEPH_MSG_MON_MAP:\n\t\tceph_monc_handle_map(monc, msg);\n\t\tbreak;\n\n\tcase CEPH_MSG_OSD_MAP:\n\t\tceph_osdc_handle_map(&monc->client->osdc, msg);\n\t\tbreak;\n\n\tdefault:\n\t\t \n\t\tif (monc->client->extra_mon_dispatch &&\n\t\t    monc->client->extra_mon_dispatch(monc->client, msg) == 0)\n\t\t\tbreak;\n\n\t\tpr_err(\"received unknown message type %d %s\\n\", type,\n\t\t       ceph_msg_type_name(type));\n\t}\n\tceph_msg_put(msg);\n}\n\n \nstatic struct ceph_msg *mon_alloc_msg(struct ceph_connection *con,\n\t\t\t\t      struct ceph_msg_header *hdr,\n\t\t\t\t      int *skip)\n{\n\tstruct ceph_mon_client *monc = con->private;\n\tint type = le16_to_cpu(hdr->type);\n\tint front_len = le32_to_cpu(hdr->front_len);\n\tstruct ceph_msg *m = NULL;\n\n\t*skip = 0;\n\n\tswitch (type) {\n\tcase CEPH_MSG_MON_SUBSCRIBE_ACK:\n\t\tm = ceph_msg_get(monc->m_subscribe_ack);\n\t\tbreak;\n\tcase CEPH_MSG_STATFS_REPLY:\n\tcase CEPH_MSG_MON_COMMAND_ACK:\n\t\treturn get_generic_reply(con, hdr, skip);\n\tcase CEPH_MSG_AUTH_REPLY:\n\t\tm = ceph_msg_get(monc->m_auth_reply);\n\t\tbreak;\n\tcase CEPH_MSG_MON_GET_VERSION_REPLY:\n\t\tif (le64_to_cpu(hdr->tid) != 0)\n\t\t\treturn get_generic_reply(con, hdr, skip);\n\n\t\t \n\t\tfallthrough;\n\tcase CEPH_MSG_MON_MAP:\n\tcase CEPH_MSG_MDS_MAP:\n\tcase CEPH_MSG_OSD_MAP:\n\tcase CEPH_MSG_FS_MAP_USER:\n\t\tm = ceph_msg_new(type, front_len, GFP_NOFS, false);\n\t\tif (!m)\n\t\t\treturn NULL;\t \n\t\tbreak;\n\t}\n\n\tif (!m) {\n\t\tpr_info(\"alloc_msg unknown type %d\\n\", type);\n\t\t*skip = 1;\n\t} else if (front_len > m->front_alloc_len) {\n\t\tpr_warn(\"mon_alloc_msg front %d > prealloc %d (%u#%llu)\\n\",\n\t\t\tfront_len, m->front_alloc_len,\n\t\t\t(unsigned int)con->peer_name.type,\n\t\t\tle64_to_cpu(con->peer_name.num));\n\t\tceph_msg_put(m);\n\t\tm = ceph_msg_new(type, front_len, GFP_NOFS, false);\n\t}\n\n\treturn m;\n}\n\n \nstatic void mon_fault(struct ceph_connection *con)\n{\n\tstruct ceph_mon_client *monc = con->private;\n\n\tmutex_lock(&monc->mutex);\n\tdout(\"%s mon%d\\n\", __func__, monc->cur_mon);\n\tif (monc->cur_mon >= 0) {\n\t\tif (!monc->hunting) {\n\t\t\tdout(\"%s hunting for new mon\\n\", __func__);\n\t\t\treopen_session(monc);\n\t\t\t__schedule_delayed(monc);\n\t\t} else {\n\t\t\tdout(\"%s already hunting\\n\", __func__);\n\t\t}\n\t}\n\tmutex_unlock(&monc->mutex);\n}\n\n \nstatic struct ceph_connection *mon_get_con(struct ceph_connection *con)\n{\n\treturn con;\n}\n\nstatic void mon_put_con(struct ceph_connection *con)\n{\n}\n\nstatic const struct ceph_connection_operations mon_con_ops = {\n\t.get = mon_get_con,\n\t.put = mon_put_con,\n\t.alloc_msg = mon_alloc_msg,\n\t.dispatch = mon_dispatch,\n\t.fault = mon_fault,\n\t.get_auth_request = mon_get_auth_request,\n\t.handle_auth_reply_more = mon_handle_auth_reply_more,\n\t.handle_auth_done = mon_handle_auth_done,\n\t.handle_auth_bad_method = mon_handle_auth_bad_method,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}