{
  "module_name": "lapb_out.c",
  "hash_id": "72cc973e747367a6798f7a0b36423e9ccf4bdc66fd6a9e0fa330d8f96c9ea0c3",
  "original_prompt": "Ingested from linux-6.6.14/net/lapb/lapb_out.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/socket.h>\n#include <linux/in.h>\n#include <linux/kernel.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/sockios.h>\n#include <linux/net.h>\n#include <linux/inet.h>\n#include <linux/skbuff.h>\n#include <linux/slab.h>\n#include <net/sock.h>\n#include <linux/uaccess.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/interrupt.h>\n#include <net/lapb.h>\n\n \nstatic void lapb_send_iframe(struct lapb_cb *lapb, struct sk_buff *skb, int poll_bit)\n{\n\tunsigned char *frame;\n\n\tif (!skb)\n\t\treturn;\n\n\tif (lapb->mode & LAPB_EXTENDED) {\n\t\tframe = skb_push(skb, 2);\n\n\t\tframe[0] = LAPB_I;\n\t\tframe[0] |= lapb->vs << 1;\n\t\tframe[1] = poll_bit ? LAPB_EPF : 0;\n\t\tframe[1] |= lapb->vr << 1;\n\t} else {\n\t\tframe = skb_push(skb, 1);\n\n\t\t*frame = LAPB_I;\n\t\t*frame |= poll_bit ? LAPB_SPF : 0;\n\t\t*frame |= lapb->vr << 5;\n\t\t*frame |= lapb->vs << 1;\n\t}\n\n\tlapb_dbg(1, \"(%p) S%d TX I(%d) S%d R%d\\n\",\n\t\t lapb->dev, lapb->state, poll_bit, lapb->vs, lapb->vr);\n\n\tlapb_transmit_buffer(lapb, skb, LAPB_COMMAND);\n}\n\nvoid lapb_kick(struct lapb_cb *lapb)\n{\n\tstruct sk_buff *skb, *skbn;\n\tunsigned short modulus, start, end;\n\n\tmodulus = (lapb->mode & LAPB_EXTENDED) ? LAPB_EMODULUS : LAPB_SMODULUS;\n\tstart = !skb_peek(&lapb->ack_queue) ? lapb->va : lapb->vs;\n\tend   = (lapb->va + lapb->window) % modulus;\n\n\tif (!(lapb->condition & LAPB_PEER_RX_BUSY_CONDITION) &&\n\t    start != end && skb_peek(&lapb->write_queue)) {\n\t\tlapb->vs = start;\n\n\t\t \n\t\tskb = skb_dequeue(&lapb->write_queue);\n\n\t\tdo {\n\t\t\tskbn = skb_copy(skb, GFP_ATOMIC);\n\t\t\tif (!skbn) {\n\t\t\t\tskb_queue_head(&lapb->write_queue, skb);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (skb->sk)\n\t\t\t\tskb_set_owner_w(skbn, skb->sk);\n\n\t\t\t \n\t\t\tlapb_send_iframe(lapb, skbn, LAPB_POLLOFF);\n\n\t\t\tlapb->vs = (lapb->vs + 1) % modulus;\n\n\t\t\t \n\t\t\tskb_queue_tail(&lapb->ack_queue, skb);\n\n\t\t} while (lapb->vs != end && (skb = skb_dequeue(&lapb->write_queue)) != NULL);\n\n\t\tlapb->condition &= ~LAPB_ACK_PENDING_CONDITION;\n\n\t\tif (!lapb_t1timer_running(lapb))\n\t\t\tlapb_start_t1timer(lapb);\n\t}\n}\n\nvoid lapb_transmit_buffer(struct lapb_cb *lapb, struct sk_buff *skb, int type)\n{\n\tunsigned char *ptr;\n\n\tptr = skb_push(skb, 1);\n\n\tif (lapb->mode & LAPB_MLP) {\n\t\tif (lapb->mode & LAPB_DCE) {\n\t\t\tif (type == LAPB_COMMAND)\n\t\t\t\t*ptr = LAPB_ADDR_C;\n\t\t\tif (type == LAPB_RESPONSE)\n\t\t\t\t*ptr = LAPB_ADDR_D;\n\t\t} else {\n\t\t\tif (type == LAPB_COMMAND)\n\t\t\t\t*ptr = LAPB_ADDR_D;\n\t\t\tif (type == LAPB_RESPONSE)\n\t\t\t\t*ptr = LAPB_ADDR_C;\n\t\t}\n\t} else {\n\t\tif (lapb->mode & LAPB_DCE) {\n\t\t\tif (type == LAPB_COMMAND)\n\t\t\t\t*ptr = LAPB_ADDR_A;\n\t\t\tif (type == LAPB_RESPONSE)\n\t\t\t\t*ptr = LAPB_ADDR_B;\n\t\t} else {\n\t\t\tif (type == LAPB_COMMAND)\n\t\t\t\t*ptr = LAPB_ADDR_B;\n\t\t\tif (type == LAPB_RESPONSE)\n\t\t\t\t*ptr = LAPB_ADDR_A;\n\t\t}\n\t}\n\n\tlapb_dbg(2, \"(%p) S%d TX %3ph\\n\", lapb->dev, lapb->state, skb->data);\n\n\tif (!lapb_data_transmit(lapb, skb))\n\t\tkfree_skb(skb);\n}\n\nvoid lapb_establish_data_link(struct lapb_cb *lapb)\n{\n\tlapb->condition = 0x00;\n\tlapb->n2count   = 0;\n\n\tif (lapb->mode & LAPB_EXTENDED) {\n\t\tlapb_dbg(1, \"(%p) S%d TX SABME(1)\\n\", lapb->dev, lapb->state);\n\t\tlapb_send_control(lapb, LAPB_SABME, LAPB_POLLON, LAPB_COMMAND);\n\t} else {\n\t\tlapb_dbg(1, \"(%p) S%d TX SABM(1)\\n\", lapb->dev, lapb->state);\n\t\tlapb_send_control(lapb, LAPB_SABM, LAPB_POLLON, LAPB_COMMAND);\n\t}\n\n\tlapb_start_t1timer(lapb);\n\tlapb_stop_t2timer(lapb);\n}\n\nvoid lapb_enquiry_response(struct lapb_cb *lapb)\n{\n\tlapb_dbg(1, \"(%p) S%d TX RR(1) R%d\\n\",\n\t\t lapb->dev, lapb->state, lapb->vr);\n\n\tlapb_send_control(lapb, LAPB_RR, LAPB_POLLON, LAPB_RESPONSE);\n\n\tlapb->condition &= ~LAPB_ACK_PENDING_CONDITION;\n}\n\nvoid lapb_timeout_response(struct lapb_cb *lapb)\n{\n\tlapb_dbg(1, \"(%p) S%d TX RR(0) R%d\\n\",\n\t\t lapb->dev, lapb->state, lapb->vr);\n\tlapb_send_control(lapb, LAPB_RR, LAPB_POLLOFF, LAPB_RESPONSE);\n\n\tlapb->condition &= ~LAPB_ACK_PENDING_CONDITION;\n}\n\nvoid lapb_check_iframes_acked(struct lapb_cb *lapb, unsigned short nr)\n{\n\tif (lapb->vs == nr) {\n\t\tlapb_frames_acked(lapb, nr);\n\t\tlapb_stop_t1timer(lapb);\n\t\tlapb->n2count = 0;\n\t} else if (lapb->va != nr) {\n\t\tlapb_frames_acked(lapb, nr);\n\t\tlapb_start_t1timer(lapb);\n\t}\n}\n\nvoid lapb_check_need_response(struct lapb_cb *lapb, int type, int pf)\n{\n\tif (type == LAPB_COMMAND && pf)\n\t\tlapb_enquiry_response(lapb);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}