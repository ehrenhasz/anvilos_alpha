{
  "module_name": "lapb_subr.c",
  "hash_id": "949af1f07c81f28115716c3d4bac8090b848d792bd2d07e5a863af21510bffb5",
  "original_prompt": "Ingested from linux-6.6.14/net/lapb/lapb_subr.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/socket.h>\n#include <linux/in.h>\n#include <linux/kernel.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/sockios.h>\n#include <linux/net.h>\n#include <linux/inet.h>\n#include <linux/skbuff.h>\n#include <linux/slab.h>\n#include <net/sock.h>\n#include <linux/uaccess.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/interrupt.h>\n#include <net/lapb.h>\n\n \nvoid lapb_clear_queues(struct lapb_cb *lapb)\n{\n\tskb_queue_purge(&lapb->write_queue);\n\tskb_queue_purge(&lapb->ack_queue);\n}\n\n \nvoid lapb_frames_acked(struct lapb_cb *lapb, unsigned short nr)\n{\n\tstruct sk_buff *skb;\n\tint modulus;\n\n\tmodulus = (lapb->mode & LAPB_EXTENDED) ? LAPB_EMODULUS : LAPB_SMODULUS;\n\n\t \n\tif (lapb->va != nr)\n\t\twhile (skb_peek(&lapb->ack_queue) && lapb->va != nr) {\n\t\t\tskb = skb_dequeue(&lapb->ack_queue);\n\t\t\tkfree_skb(skb);\n\t\t\tlapb->va = (lapb->va + 1) % modulus;\n\t\t}\n}\n\nvoid lapb_requeue_frames(struct lapb_cb *lapb)\n{\n\tstruct sk_buff *skb, *skb_prev = NULL;\n\n\t \n\twhile ((skb = skb_dequeue(&lapb->ack_queue)) != NULL) {\n\t\tif (!skb_prev)\n\t\t\tskb_queue_head(&lapb->write_queue, skb);\n\t\telse\n\t\t\tskb_append(skb_prev, skb, &lapb->write_queue);\n\t\tskb_prev = skb;\n\t}\n}\n\n \nint lapb_validate_nr(struct lapb_cb *lapb, unsigned short nr)\n{\n\tunsigned short vc = lapb->va;\n\tint modulus;\n\n\tmodulus = (lapb->mode & LAPB_EXTENDED) ? LAPB_EMODULUS : LAPB_SMODULUS;\n\n\twhile (vc != lapb->vs) {\n\t\tif (nr == vc)\n\t\t\treturn 1;\n\t\tvc = (vc + 1) % modulus;\n\t}\n\n\treturn nr == lapb->vs;\n}\n\n \nint lapb_decode(struct lapb_cb *lapb, struct sk_buff *skb,\n\t\tstruct lapb_frame *frame)\n{\n\tframe->type = LAPB_ILLEGAL;\n\n\tlapb_dbg(2, \"(%p) S%d RX %3ph\\n\", lapb->dev, lapb->state, skb->data);\n\n\t \n\tif (!pskb_may_pull(skb, 2))\n\t\treturn -1;\n\n\tif (lapb->mode & LAPB_MLP) {\n\t\tif (lapb->mode & LAPB_DCE) {\n\t\t\tif (skb->data[0] == LAPB_ADDR_D)\n\t\t\t\tframe->cr = LAPB_COMMAND;\n\t\t\tif (skb->data[0] == LAPB_ADDR_C)\n\t\t\t\tframe->cr = LAPB_RESPONSE;\n\t\t} else {\n\t\t\tif (skb->data[0] == LAPB_ADDR_C)\n\t\t\t\tframe->cr = LAPB_COMMAND;\n\t\t\tif (skb->data[0] == LAPB_ADDR_D)\n\t\t\t\tframe->cr = LAPB_RESPONSE;\n\t\t}\n\t} else {\n\t\tif (lapb->mode & LAPB_DCE) {\n\t\t\tif (skb->data[0] == LAPB_ADDR_B)\n\t\t\t\tframe->cr = LAPB_COMMAND;\n\t\t\tif (skb->data[0] == LAPB_ADDR_A)\n\t\t\t\tframe->cr = LAPB_RESPONSE;\n\t\t} else {\n\t\t\tif (skb->data[0] == LAPB_ADDR_A)\n\t\t\t\tframe->cr = LAPB_COMMAND;\n\t\t\tif (skb->data[0] == LAPB_ADDR_B)\n\t\t\t\tframe->cr = LAPB_RESPONSE;\n\t\t}\n\t}\n\n\tskb_pull(skb, 1);\n\n\tif (lapb->mode & LAPB_EXTENDED) {\n\t\tif (!(skb->data[0] & LAPB_S)) {\n\t\t\tif (!pskb_may_pull(skb, 2))\n\t\t\t\treturn -1;\n\t\t\t \n\t\t\tframe->type       = LAPB_I;\n\t\t\tframe->ns         = (skb->data[0] >> 1) & 0x7F;\n\t\t\tframe->nr         = (skb->data[1] >> 1) & 0x7F;\n\t\t\tframe->pf         = skb->data[1] & LAPB_EPF;\n\t\t\tframe->control[0] = skb->data[0];\n\t\t\tframe->control[1] = skb->data[1];\n\t\t\tskb_pull(skb, 2);\n\t\t} else if ((skb->data[0] & LAPB_U) == 1) {\n\t\t\tif (!pskb_may_pull(skb, 2))\n\t\t\t\treturn -1;\n\t\t\t \n\t\t\tframe->type       = skb->data[0] & 0x0F;\n\t\t\tframe->nr         = (skb->data[1] >> 1) & 0x7F;\n\t\t\tframe->pf         = skb->data[1] & LAPB_EPF;\n\t\t\tframe->control[0] = skb->data[0];\n\t\t\tframe->control[1] = skb->data[1];\n\t\t\tskb_pull(skb, 2);\n\t\t} else if ((skb->data[0] & LAPB_U) == 3) {\n\t\t\t \n\t\t\tframe->type       = skb->data[0] & ~LAPB_SPF;\n\t\t\tframe->pf         = skb->data[0] & LAPB_SPF;\n\t\t\tframe->control[0] = skb->data[0];\n\t\t\tframe->control[1] = 0x00;\n\t\t\tskb_pull(skb, 1);\n\t\t}\n\t} else {\n\t\tif (!(skb->data[0] & LAPB_S)) {\n\t\t\t \n\t\t\tframe->type = LAPB_I;\n\t\t\tframe->ns   = (skb->data[0] >> 1) & 0x07;\n\t\t\tframe->nr   = (skb->data[0] >> 5) & 0x07;\n\t\t\tframe->pf   = skb->data[0] & LAPB_SPF;\n\t\t} else if ((skb->data[0] & LAPB_U) == 1) {\n\t\t\t \n\t\t\tframe->type = skb->data[0] & 0x0F;\n\t\t\tframe->nr   = (skb->data[0] >> 5) & 0x07;\n\t\t\tframe->pf   = skb->data[0] & LAPB_SPF;\n\t\t} else if ((skb->data[0] & LAPB_U) == 3) {\n\t\t\t \n\t\t\tframe->type = skb->data[0] & ~LAPB_SPF;\n\t\t\tframe->pf   = skb->data[0] & LAPB_SPF;\n\t\t}\n\n\t\tframe->control[0] = skb->data[0];\n\n\t\tskb_pull(skb, 1);\n\t}\n\n\treturn 0;\n}\n\n \nvoid lapb_send_control(struct lapb_cb *lapb, int frametype,\n\t\t       int poll_bit, int type)\n{\n\tstruct sk_buff *skb;\n\tunsigned char  *dptr;\n\n\tif ((skb = alloc_skb(LAPB_HEADER_LEN + 3, GFP_ATOMIC)) == NULL)\n\t\treturn;\n\n\tskb_reserve(skb, LAPB_HEADER_LEN + 1);\n\n\tif (lapb->mode & LAPB_EXTENDED) {\n\t\tif ((frametype & LAPB_U) == LAPB_U) {\n\t\t\tdptr   = skb_put(skb, 1);\n\t\t\t*dptr  = frametype;\n\t\t\t*dptr |= poll_bit ? LAPB_SPF : 0;\n\t\t} else {\n\t\t\tdptr     = skb_put(skb, 2);\n\t\t\tdptr[0]  = frametype;\n\t\t\tdptr[1]  = (lapb->vr << 1);\n\t\t\tdptr[1] |= poll_bit ? LAPB_EPF : 0;\n\t\t}\n\t} else {\n\t\tdptr   = skb_put(skb, 1);\n\t\t*dptr  = frametype;\n\t\t*dptr |= poll_bit ? LAPB_SPF : 0;\n\t\tif ((frametype & LAPB_U) == LAPB_S)\t \n\t\t\t*dptr |= (lapb->vr << 5);\n\t}\n\n\tlapb_transmit_buffer(lapb, skb, type);\n}\n\n \nvoid lapb_transmit_frmr(struct lapb_cb *lapb)\n{\n\tstruct sk_buff *skb;\n\tunsigned char  *dptr;\n\n\tif ((skb = alloc_skb(LAPB_HEADER_LEN + 7, GFP_ATOMIC)) == NULL)\n\t\treturn;\n\n\tskb_reserve(skb, LAPB_HEADER_LEN + 1);\n\n\tif (lapb->mode & LAPB_EXTENDED) {\n\t\tdptr    = skb_put(skb, 6);\n\t\t*dptr++ = LAPB_FRMR;\n\t\t*dptr++ = lapb->frmr_data.control[0];\n\t\t*dptr++ = lapb->frmr_data.control[1];\n\t\t*dptr++ = (lapb->vs << 1) & 0xFE;\n\t\t*dptr   = (lapb->vr << 1) & 0xFE;\n\t\tif (lapb->frmr_data.cr == LAPB_RESPONSE)\n\t\t\t*dptr |= 0x01;\n\t\tdptr++;\n\t\t*dptr++ = lapb->frmr_type;\n\n\t\tlapb_dbg(1, \"(%p) S%d TX FRMR %5ph\\n\",\n\t\t\t lapb->dev, lapb->state,\n\t\t\t &skb->data[1]);\n\t} else {\n\t\tdptr    = skb_put(skb, 4);\n\t\t*dptr++ = LAPB_FRMR;\n\t\t*dptr++ = lapb->frmr_data.control[0];\n\t\t*dptr   = (lapb->vs << 1) & 0x0E;\n\t\t*dptr  |= (lapb->vr << 5) & 0xE0;\n\t\tif (lapb->frmr_data.cr == LAPB_RESPONSE)\n\t\t\t*dptr |= 0x10;\n\t\tdptr++;\n\t\t*dptr++ = lapb->frmr_type;\n\n\t\tlapb_dbg(1, \"(%p) S%d TX FRMR %3ph\\n\",\n\t\t\t lapb->dev, lapb->state, &skb->data[1]);\n\t}\n\n\tlapb_transmit_buffer(lapb, skb, LAPB_RESPONSE);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}