{
  "module_name": "lapb_in.c",
  "hash_id": "822794b7198021b83cb9ee6ca0230ac0d3f3eee41628c3bd363f83ffe9e3723a",
  "original_prompt": "Ingested from linux-6.6.14/net/lapb/lapb_in.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/socket.h>\n#include <linux/in.h>\n#include <linux/kernel.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/sockios.h>\n#include <linux/net.h>\n#include <linux/inet.h>\n#include <linux/netdevice.h>\n#include <linux/skbuff.h>\n#include <linux/slab.h>\n#include <net/sock.h>\n#include <linux/uaccess.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/interrupt.h>\n#include <net/lapb.h>\n\n \nstatic void lapb_state0_machine(struct lapb_cb *lapb, struct sk_buff *skb,\n\t\t\t\tstruct lapb_frame *frame)\n{\n\tswitch (frame->type) {\n\tcase LAPB_SABM:\n\t\tlapb_dbg(1, \"(%p) S0 RX SABM(%d)\\n\", lapb->dev, frame->pf);\n\t\tif (lapb->mode & LAPB_EXTENDED) {\n\t\t\tlapb_dbg(1, \"(%p) S0 TX DM(%d)\\n\",\n\t\t\t\t lapb->dev, frame->pf);\n\t\t\tlapb_send_control(lapb, LAPB_DM, frame->pf,\n\t\t\t\t\t  LAPB_RESPONSE);\n\t\t} else {\n\t\t\tlapb_dbg(1, \"(%p) S0 TX UA(%d)\\n\",\n\t\t\t\t lapb->dev, frame->pf);\n\t\t\tlapb_dbg(0, \"(%p) S0 -> S3\\n\", lapb->dev);\n\t\t\tlapb_send_control(lapb, LAPB_UA, frame->pf,\n\t\t\t\t\t  LAPB_RESPONSE);\n\t\t\tlapb_stop_t1timer(lapb);\n\t\t\tlapb_stop_t2timer(lapb);\n\t\t\tlapb->state     = LAPB_STATE_3;\n\t\t\tlapb->condition = 0x00;\n\t\t\tlapb->n2count   = 0;\n\t\t\tlapb->vs        = 0;\n\t\t\tlapb->vr        = 0;\n\t\t\tlapb->va        = 0;\n\t\t\tlapb_connect_indication(lapb, LAPB_OK);\n\t\t}\n\t\tbreak;\n\n\tcase LAPB_SABME:\n\t\tlapb_dbg(1, \"(%p) S0 RX SABME(%d)\\n\", lapb->dev, frame->pf);\n\t\tif (lapb->mode & LAPB_EXTENDED) {\n\t\t\tlapb_dbg(1, \"(%p) S0 TX UA(%d)\\n\",\n\t\t\t\t lapb->dev, frame->pf);\n\t\t\tlapb_dbg(0, \"(%p) S0 -> S3\\n\", lapb->dev);\n\t\t\tlapb_send_control(lapb, LAPB_UA, frame->pf,\n\t\t\t\t\t  LAPB_RESPONSE);\n\t\t\tlapb_stop_t1timer(lapb);\n\t\t\tlapb_stop_t2timer(lapb);\n\t\t\tlapb->state     = LAPB_STATE_3;\n\t\t\tlapb->condition = 0x00;\n\t\t\tlapb->n2count   = 0;\n\t\t\tlapb->vs        = 0;\n\t\t\tlapb->vr        = 0;\n\t\t\tlapb->va        = 0;\n\t\t\tlapb_connect_indication(lapb, LAPB_OK);\n\t\t} else {\n\t\t\tlapb_dbg(1, \"(%p) S0 TX DM(%d)\\n\",\n\t\t\t\t lapb->dev, frame->pf);\n\t\t\tlapb_send_control(lapb, LAPB_DM, frame->pf,\n\t\t\t\t\t  LAPB_RESPONSE);\n\t\t}\n\t\tbreak;\n\n\tcase LAPB_DISC:\n\t\tlapb_dbg(1, \"(%p) S0 RX DISC(%d)\\n\", lapb->dev, frame->pf);\n\t\tlapb_dbg(1, \"(%p) S0 TX UA(%d)\\n\", lapb->dev, frame->pf);\n\t\tlapb_send_control(lapb, LAPB_UA, frame->pf, LAPB_RESPONSE);\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\tkfree_skb(skb);\n}\n\n \nstatic void lapb_state1_machine(struct lapb_cb *lapb, struct sk_buff *skb,\n\t\t\t\tstruct lapb_frame *frame)\n{\n\tswitch (frame->type) {\n\tcase LAPB_SABM:\n\t\tlapb_dbg(1, \"(%p) S1 RX SABM(%d)\\n\", lapb->dev, frame->pf);\n\t\tif (lapb->mode & LAPB_EXTENDED) {\n\t\t\tlapb_dbg(1, \"(%p) S1 TX DM(%d)\\n\",\n\t\t\t\t lapb->dev, frame->pf);\n\t\t\tlapb_send_control(lapb, LAPB_DM, frame->pf,\n\t\t\t\t\t  LAPB_RESPONSE);\n\t\t} else {\n\t\t\tlapb_dbg(1, \"(%p) S1 TX UA(%d)\\n\",\n\t\t\t\t lapb->dev, frame->pf);\n\t\t\tlapb_send_control(lapb, LAPB_UA, frame->pf,\n\t\t\t\t\t  LAPB_RESPONSE);\n\t\t}\n\t\tbreak;\n\n\tcase LAPB_SABME:\n\t\tlapb_dbg(1, \"(%p) S1 RX SABME(%d)\\n\", lapb->dev, frame->pf);\n\t\tif (lapb->mode & LAPB_EXTENDED) {\n\t\t\tlapb_dbg(1, \"(%p) S1 TX UA(%d)\\n\",\n\t\t\t\t lapb->dev, frame->pf);\n\t\t\tlapb_send_control(lapb, LAPB_UA, frame->pf,\n\t\t\t\t\t  LAPB_RESPONSE);\n\t\t} else {\n\t\t\tlapb_dbg(1, \"(%p) S1 TX DM(%d)\\n\",\n\t\t\t\t lapb->dev, frame->pf);\n\t\t\tlapb_send_control(lapb, LAPB_DM, frame->pf,\n\t\t\t\t\t  LAPB_RESPONSE);\n\t\t}\n\t\tbreak;\n\n\tcase LAPB_DISC:\n\t\tlapb_dbg(1, \"(%p) S1 RX DISC(%d)\\n\", lapb->dev, frame->pf);\n\t\tlapb_dbg(1, \"(%p) S1 TX DM(%d)\\n\", lapb->dev, frame->pf);\n\t\tlapb_send_control(lapb, LAPB_DM, frame->pf, LAPB_RESPONSE);\n\t\tbreak;\n\n\tcase LAPB_UA:\n\t\tlapb_dbg(1, \"(%p) S1 RX UA(%d)\\n\", lapb->dev, frame->pf);\n\t\tif (frame->pf) {\n\t\t\tlapb_dbg(0, \"(%p) S1 -> S3\\n\", lapb->dev);\n\t\t\tlapb_stop_t1timer(lapb);\n\t\t\tlapb_stop_t2timer(lapb);\n\t\t\tlapb->state     = LAPB_STATE_3;\n\t\t\tlapb->condition = 0x00;\n\t\t\tlapb->n2count   = 0;\n\t\t\tlapb->vs        = 0;\n\t\t\tlapb->vr        = 0;\n\t\t\tlapb->va        = 0;\n\t\t\tlapb_connect_confirmation(lapb, LAPB_OK);\n\t\t}\n\t\tbreak;\n\n\tcase LAPB_DM:\n\t\tlapb_dbg(1, \"(%p) S1 RX DM(%d)\\n\", lapb->dev, frame->pf);\n\t\tif (frame->pf) {\n\t\t\tlapb_dbg(0, \"(%p) S1 -> S0\\n\", lapb->dev);\n\t\t\tlapb_clear_queues(lapb);\n\t\t\tlapb->state = LAPB_STATE_0;\n\t\t\tlapb_start_t1timer(lapb);\n\t\t\tlapb_stop_t2timer(lapb);\n\t\t\tlapb_disconnect_indication(lapb, LAPB_REFUSED);\n\t\t}\n\t\tbreak;\n\t}\n\n\tkfree_skb(skb);\n}\n\n \nstatic void lapb_state2_machine(struct lapb_cb *lapb, struct sk_buff *skb,\n\t\t\t\tstruct lapb_frame *frame)\n{\n\tswitch (frame->type) {\n\tcase LAPB_SABM:\n\tcase LAPB_SABME:\n\t\tlapb_dbg(1, \"(%p) S2 RX {SABM,SABME}(%d)\\n\",\n\t\t\t lapb->dev, frame->pf);\n\t\tlapb_dbg(1, \"(%p) S2 TX DM(%d)\\n\", lapb->dev, frame->pf);\n\t\tlapb_send_control(lapb, LAPB_DM, frame->pf, LAPB_RESPONSE);\n\t\tbreak;\n\n\tcase LAPB_DISC:\n\t\tlapb_dbg(1, \"(%p) S2 RX DISC(%d)\\n\", lapb->dev, frame->pf);\n\t\tlapb_dbg(1, \"(%p) S2 TX UA(%d)\\n\", lapb->dev, frame->pf);\n\t\tlapb_send_control(lapb, LAPB_UA, frame->pf, LAPB_RESPONSE);\n\t\tbreak;\n\n\tcase LAPB_UA:\n\t\tlapb_dbg(1, \"(%p) S2 RX UA(%d)\\n\", lapb->dev, frame->pf);\n\t\tif (frame->pf) {\n\t\t\tlapb_dbg(0, \"(%p) S2 -> S0\\n\", lapb->dev);\n\t\t\tlapb->state = LAPB_STATE_0;\n\t\t\tlapb_start_t1timer(lapb);\n\t\t\tlapb_stop_t2timer(lapb);\n\t\t\tlapb_disconnect_confirmation(lapb, LAPB_OK);\n\t\t}\n\t\tbreak;\n\n\tcase LAPB_DM:\n\t\tlapb_dbg(1, \"(%p) S2 RX DM(%d)\\n\", lapb->dev, frame->pf);\n\t\tif (frame->pf) {\n\t\t\tlapb_dbg(0, \"(%p) S2 -> S0\\n\", lapb->dev);\n\t\t\tlapb->state = LAPB_STATE_0;\n\t\t\tlapb_start_t1timer(lapb);\n\t\t\tlapb_stop_t2timer(lapb);\n\t\t\tlapb_disconnect_confirmation(lapb, LAPB_NOTCONNECTED);\n\t\t}\n\t\tbreak;\n\n\tcase LAPB_I:\n\tcase LAPB_REJ:\n\tcase LAPB_RNR:\n\tcase LAPB_RR:\n\t\tlapb_dbg(1, \"(%p) S2 RX {I,REJ,RNR,RR}(%d)\\n\",\n\t\t       lapb->dev, frame->pf);\n\t\tlapb_dbg(1, \"(%p) S2 RX DM(%d)\\n\", lapb->dev, frame->pf);\n\t\tif (frame->pf)\n\t\t\tlapb_send_control(lapb, LAPB_DM, frame->pf,\n\t\t\t\t\t  LAPB_RESPONSE);\n\t\tbreak;\n\t}\n\n\tkfree_skb(skb);\n}\n\n \nstatic void lapb_state3_machine(struct lapb_cb *lapb, struct sk_buff *skb,\n\t\t\t\tstruct lapb_frame *frame)\n{\n\tint queued = 0;\n\tint modulus = (lapb->mode & LAPB_EXTENDED) ? LAPB_EMODULUS :\n\t\t\t\t\t\t     LAPB_SMODULUS;\n\n\tswitch (frame->type) {\n\tcase LAPB_SABM:\n\t\tlapb_dbg(1, \"(%p) S3 RX SABM(%d)\\n\", lapb->dev, frame->pf);\n\t\tif (lapb->mode & LAPB_EXTENDED) {\n\t\t\tlapb_dbg(1, \"(%p) S3 TX DM(%d)\\n\",\n\t\t\t\t lapb->dev, frame->pf);\n\t\t\tlapb_send_control(lapb, LAPB_DM, frame->pf,\n\t\t\t\t\t  LAPB_RESPONSE);\n\t\t} else {\n\t\t\tlapb_dbg(1, \"(%p) S3 TX UA(%d)\\n\",\n\t\t\t\t lapb->dev, frame->pf);\n\t\t\tlapb_send_control(lapb, LAPB_UA, frame->pf,\n\t\t\t\t\t  LAPB_RESPONSE);\n\t\t\tlapb_stop_t1timer(lapb);\n\t\t\tlapb_stop_t2timer(lapb);\n\t\t\tlapb->condition = 0x00;\n\t\t\tlapb->n2count   = 0;\n\t\t\tlapb->vs        = 0;\n\t\t\tlapb->vr        = 0;\n\t\t\tlapb->va        = 0;\n\t\t\tlapb_requeue_frames(lapb);\n\t\t}\n\t\tbreak;\n\n\tcase LAPB_SABME:\n\t\tlapb_dbg(1, \"(%p) S3 RX SABME(%d)\\n\", lapb->dev, frame->pf);\n\t\tif (lapb->mode & LAPB_EXTENDED) {\n\t\t\tlapb_dbg(1, \"(%p) S3 TX UA(%d)\\n\",\n\t\t\t\t lapb->dev, frame->pf);\n\t\t\tlapb_send_control(lapb, LAPB_UA, frame->pf,\n\t\t\t\t\t  LAPB_RESPONSE);\n\t\t\tlapb_stop_t1timer(lapb);\n\t\t\tlapb_stop_t2timer(lapb);\n\t\t\tlapb->condition = 0x00;\n\t\t\tlapb->n2count   = 0;\n\t\t\tlapb->vs        = 0;\n\t\t\tlapb->vr        = 0;\n\t\t\tlapb->va        = 0;\n\t\t\tlapb_requeue_frames(lapb);\n\t\t} else {\n\t\t\tlapb_dbg(1, \"(%p) S3 TX DM(%d)\\n\",\n\t\t\t\t lapb->dev, frame->pf);\n\t\t\tlapb_send_control(lapb, LAPB_DM, frame->pf,\n\t\t\t\t\t  LAPB_RESPONSE);\n\t\t}\n\t\tbreak;\n\n\tcase LAPB_DISC:\n\t\tlapb_dbg(1, \"(%p) S3 RX DISC(%d)\\n\", lapb->dev, frame->pf);\n\t\tlapb_dbg(0, \"(%p) S3 -> S0\\n\", lapb->dev);\n\t\tlapb_clear_queues(lapb);\n\t\tlapb_send_control(lapb, LAPB_UA, frame->pf, LAPB_RESPONSE);\n\t\tlapb_start_t1timer(lapb);\n\t\tlapb_stop_t2timer(lapb);\n\t\tlapb->state = LAPB_STATE_0;\n\t\tlapb_disconnect_indication(lapb, LAPB_OK);\n\t\tbreak;\n\n\tcase LAPB_DM:\n\t\tlapb_dbg(1, \"(%p) S3 RX DM(%d)\\n\", lapb->dev, frame->pf);\n\t\tlapb_dbg(0, \"(%p) S3 -> S0\\n\", lapb->dev);\n\t\tlapb_clear_queues(lapb);\n\t\tlapb->state = LAPB_STATE_0;\n\t\tlapb_start_t1timer(lapb);\n\t\tlapb_stop_t2timer(lapb);\n\t\tlapb_disconnect_indication(lapb, LAPB_NOTCONNECTED);\n\t\tbreak;\n\n\tcase LAPB_RNR:\n\t\tlapb_dbg(1, \"(%p) S3 RX RNR(%d) R%d\\n\",\n\t\t\t lapb->dev, frame->pf, frame->nr);\n\t\tlapb->condition |= LAPB_PEER_RX_BUSY_CONDITION;\n\t\tlapb_check_need_response(lapb, frame->cr, frame->pf);\n\t\tif (lapb_validate_nr(lapb, frame->nr)) {\n\t\t\tlapb_check_iframes_acked(lapb, frame->nr);\n\t\t} else {\n\t\t\tlapb->frmr_data = *frame;\n\t\t\tlapb->frmr_type = LAPB_FRMR_Z;\n\t\t\tlapb_transmit_frmr(lapb);\n\t\t\tlapb_dbg(0, \"(%p) S3 -> S4\\n\", lapb->dev);\n\t\t\tlapb_start_t1timer(lapb);\n\t\t\tlapb_stop_t2timer(lapb);\n\t\t\tlapb->state   = LAPB_STATE_4;\n\t\t\tlapb->n2count = 0;\n\t\t}\n\t\tbreak;\n\n\tcase LAPB_RR:\n\t\tlapb_dbg(1, \"(%p) S3 RX RR(%d) R%d\\n\",\n\t\t\t lapb->dev, frame->pf, frame->nr);\n\t\tlapb->condition &= ~LAPB_PEER_RX_BUSY_CONDITION;\n\t\tlapb_check_need_response(lapb, frame->cr, frame->pf);\n\t\tif (lapb_validate_nr(lapb, frame->nr)) {\n\t\t\tlapb_check_iframes_acked(lapb, frame->nr);\n\t\t} else {\n\t\t\tlapb->frmr_data = *frame;\n\t\t\tlapb->frmr_type = LAPB_FRMR_Z;\n\t\t\tlapb_transmit_frmr(lapb);\n\t\t\tlapb_dbg(0, \"(%p) S3 -> S4\\n\", lapb->dev);\n\t\t\tlapb_start_t1timer(lapb);\n\t\t\tlapb_stop_t2timer(lapb);\n\t\t\tlapb->state   = LAPB_STATE_4;\n\t\t\tlapb->n2count = 0;\n\t\t}\n\t\tbreak;\n\n\tcase LAPB_REJ:\n\t\tlapb_dbg(1, \"(%p) S3 RX REJ(%d) R%d\\n\",\n\t\t\t lapb->dev, frame->pf, frame->nr);\n\t\tlapb->condition &= ~LAPB_PEER_RX_BUSY_CONDITION;\n\t\tlapb_check_need_response(lapb, frame->cr, frame->pf);\n\t\tif (lapb_validate_nr(lapb, frame->nr)) {\n\t\t\tlapb_frames_acked(lapb, frame->nr);\n\t\t\tlapb_stop_t1timer(lapb);\n\t\t\tlapb->n2count = 0;\n\t\t\tlapb_requeue_frames(lapb);\n\t\t} else {\n\t\t\tlapb->frmr_data = *frame;\n\t\t\tlapb->frmr_type = LAPB_FRMR_Z;\n\t\t\tlapb_transmit_frmr(lapb);\n\t\t\tlapb_dbg(0, \"(%p) S3 -> S4\\n\", lapb->dev);\n\t\t\tlapb_start_t1timer(lapb);\n\t\t\tlapb_stop_t2timer(lapb);\n\t\t\tlapb->state   = LAPB_STATE_4;\n\t\t\tlapb->n2count = 0;\n\t\t}\n\t\tbreak;\n\n\tcase LAPB_I:\n\t\tlapb_dbg(1, \"(%p) S3 RX I(%d) S%d R%d\\n\",\n\t\t\t lapb->dev, frame->pf, frame->ns, frame->nr);\n\t\tif (!lapb_validate_nr(lapb, frame->nr)) {\n\t\t\tlapb->frmr_data = *frame;\n\t\t\tlapb->frmr_type = LAPB_FRMR_Z;\n\t\t\tlapb_transmit_frmr(lapb);\n\t\t\tlapb_dbg(0, \"(%p) S3 -> S4\\n\", lapb->dev);\n\t\t\tlapb_start_t1timer(lapb);\n\t\t\tlapb_stop_t2timer(lapb);\n\t\t\tlapb->state   = LAPB_STATE_4;\n\t\t\tlapb->n2count = 0;\n\t\t\tbreak;\n\t\t}\n\t\tif (lapb->condition & LAPB_PEER_RX_BUSY_CONDITION)\n\t\t\tlapb_frames_acked(lapb, frame->nr);\n\t\telse\n\t\t\tlapb_check_iframes_acked(lapb, frame->nr);\n\n\t\tif (frame->ns == lapb->vr) {\n\t\t\tint cn;\n\t\t\tcn = lapb_data_indication(lapb, skb);\n\t\t\tqueued = 1;\n\t\t\t \n\t\t\tif (cn == NET_RX_DROP) {\n\t\t\t\tpr_debug(\"rx congestion\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tlapb->vr = (lapb->vr + 1) % modulus;\n\t\t\tlapb->condition &= ~LAPB_REJECT_CONDITION;\n\t\t\tif (frame->pf)\n\t\t\t\tlapb_enquiry_response(lapb);\n\t\t\telse {\n\t\t\t\tif (!(lapb->condition &\n\t\t\t\t      LAPB_ACK_PENDING_CONDITION)) {\n\t\t\t\t\tlapb->condition |= LAPB_ACK_PENDING_CONDITION;\n\t\t\t\t\tlapb_start_t2timer(lapb);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (lapb->condition & LAPB_REJECT_CONDITION) {\n\t\t\t\tif (frame->pf)\n\t\t\t\t\tlapb_enquiry_response(lapb);\n\t\t\t} else {\n\t\t\t\tlapb_dbg(1, \"(%p) S3 TX REJ(%d) R%d\\n\",\n\t\t\t\t\t lapb->dev, frame->pf, lapb->vr);\n\t\t\t\tlapb->condition |= LAPB_REJECT_CONDITION;\n\t\t\t\tlapb_send_control(lapb, LAPB_REJ, frame->pf,\n\t\t\t\t\t\t  LAPB_RESPONSE);\n\t\t\t\tlapb->condition &= ~LAPB_ACK_PENDING_CONDITION;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase LAPB_FRMR:\n\t\tlapb_dbg(1, \"(%p) S3 RX FRMR(%d) %5ph\\n\",\n\t\t\t lapb->dev, frame->pf,\n\t\t\t skb->data);\n\t\tlapb_establish_data_link(lapb);\n\t\tlapb_dbg(0, \"(%p) S3 -> S1\\n\", lapb->dev);\n\t\tlapb_requeue_frames(lapb);\n\t\tlapb->state = LAPB_STATE_1;\n\t\tbreak;\n\n\tcase LAPB_ILLEGAL:\n\t\tlapb_dbg(1, \"(%p) S3 RX ILLEGAL(%d)\\n\", lapb->dev, frame->pf);\n\t\tlapb->frmr_data = *frame;\n\t\tlapb->frmr_type = LAPB_FRMR_W;\n\t\tlapb_transmit_frmr(lapb);\n\t\tlapb_dbg(0, \"(%p) S3 -> S4\\n\", lapb->dev);\n\t\tlapb_start_t1timer(lapb);\n\t\tlapb_stop_t2timer(lapb);\n\t\tlapb->state   = LAPB_STATE_4;\n\t\tlapb->n2count = 0;\n\t\tbreak;\n\t}\n\n\tif (!queued)\n\t\tkfree_skb(skb);\n}\n\n \nstatic void lapb_state4_machine(struct lapb_cb *lapb, struct sk_buff *skb,\n\t\t\t\tstruct lapb_frame *frame)\n{\n\tswitch (frame->type) {\n\tcase LAPB_SABM:\n\t\tlapb_dbg(1, \"(%p) S4 RX SABM(%d)\\n\", lapb->dev, frame->pf);\n\t\tif (lapb->mode & LAPB_EXTENDED) {\n\t\t\tlapb_dbg(1, \"(%p) S4 TX DM(%d)\\n\",\n\t\t\t\t lapb->dev, frame->pf);\n\t\t\tlapb_send_control(lapb, LAPB_DM, frame->pf,\n\t\t\t\t\t  LAPB_RESPONSE);\n\t\t} else {\n\t\t\tlapb_dbg(1, \"(%p) S4 TX UA(%d)\\n\",\n\t\t\t\t lapb->dev, frame->pf);\n\t\t\tlapb_dbg(0, \"(%p) S4 -> S3\\n\", lapb->dev);\n\t\t\tlapb_send_control(lapb, LAPB_UA, frame->pf,\n\t\t\t\t\t  LAPB_RESPONSE);\n\t\t\tlapb_stop_t1timer(lapb);\n\t\t\tlapb_stop_t2timer(lapb);\n\t\t\tlapb->state     = LAPB_STATE_3;\n\t\t\tlapb->condition = 0x00;\n\t\t\tlapb->n2count   = 0;\n\t\t\tlapb->vs        = 0;\n\t\t\tlapb->vr        = 0;\n\t\t\tlapb->va        = 0;\n\t\t\tlapb_connect_indication(lapb, LAPB_OK);\n\t\t}\n\t\tbreak;\n\n\tcase LAPB_SABME:\n\t\tlapb_dbg(1, \"(%p) S4 RX SABME(%d)\\n\", lapb->dev, frame->pf);\n\t\tif (lapb->mode & LAPB_EXTENDED) {\n\t\t\tlapb_dbg(1, \"(%p) S4 TX UA(%d)\\n\",\n\t\t\t\t lapb->dev, frame->pf);\n\t\t\tlapb_dbg(0, \"(%p) S4 -> S3\\n\", lapb->dev);\n\t\t\tlapb_send_control(lapb, LAPB_UA, frame->pf,\n\t\t\t\t\t  LAPB_RESPONSE);\n\t\t\tlapb_stop_t1timer(lapb);\n\t\t\tlapb_stop_t2timer(lapb);\n\t\t\tlapb->state     = LAPB_STATE_3;\n\t\t\tlapb->condition = 0x00;\n\t\t\tlapb->n2count   = 0;\n\t\t\tlapb->vs        = 0;\n\t\t\tlapb->vr        = 0;\n\t\t\tlapb->va        = 0;\n\t\t\tlapb_connect_indication(lapb, LAPB_OK);\n\t\t} else {\n\t\t\tlapb_dbg(1, \"(%p) S4 TX DM(%d)\\n\",\n\t\t\t\t lapb->dev, frame->pf);\n\t\t\tlapb_send_control(lapb, LAPB_DM, frame->pf,\n\t\t\t\t\t  LAPB_RESPONSE);\n\t\t}\n\t\tbreak;\n\t}\n\n\tkfree_skb(skb);\n}\n\n \nvoid lapb_data_input(struct lapb_cb *lapb, struct sk_buff *skb)\n{\n\tstruct lapb_frame frame;\n\n\tif (lapb_decode(lapb, skb, &frame) < 0) {\n\t\tkfree_skb(skb);\n\t\treturn;\n\t}\n\n\tswitch (lapb->state) {\n\tcase LAPB_STATE_0:\n\t\tlapb_state0_machine(lapb, skb, &frame); break;\n\tcase LAPB_STATE_1:\n\t\tlapb_state1_machine(lapb, skb, &frame); break;\n\tcase LAPB_STATE_2:\n\t\tlapb_state2_machine(lapb, skb, &frame); break;\n\tcase LAPB_STATE_3:\n\t\tlapb_state3_machine(lapb, skb, &frame); break;\n\tcase LAPB_STATE_4:\n\t\tlapb_state4_machine(lapb, skb, &frame); break;\n\t}\n\n\tlapb_kick(lapb);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}