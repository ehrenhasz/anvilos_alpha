{
  "module_name": "lapb_iface.c",
  "hash_id": "9099f4e244eddb7a2ec384ee9203c2df2f1700bc20773647227ba47b343e8dc2",
  "original_prompt": "Ingested from linux-6.6.14/net/lapb/lapb_iface.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/socket.h>\n#include <linux/in.h>\n#include <linux/kernel.h>\n#include <linux/jiffies.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/sockios.h>\n#include <linux/net.h>\n#include <linux/inet.h>\n#include <linux/if_arp.h>\n#include <linux/skbuff.h>\n#include <linux/slab.h>\n#include <net/sock.h>\n#include <linux/uaccess.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/interrupt.h>\n#include <linux/stat.h>\n#include <linux/init.h>\n#include <net/lapb.h>\n\nstatic LIST_HEAD(lapb_list);\nstatic DEFINE_RWLOCK(lapb_list_lock);\n\n \nstatic void lapb_free_cb(struct lapb_cb *lapb)\n{\n\tkfree(lapb);\n}\n\nstatic __inline__ void lapb_hold(struct lapb_cb *lapb)\n{\n\trefcount_inc(&lapb->refcnt);\n}\n\nstatic __inline__ void lapb_put(struct lapb_cb *lapb)\n{\n\tif (refcount_dec_and_test(&lapb->refcnt))\n\t\tlapb_free_cb(lapb);\n}\n\n \nstatic void __lapb_remove_cb(struct lapb_cb *lapb)\n{\n\tif (lapb->node.next) {\n\t\tlist_del(&lapb->node);\n\t\tlapb_put(lapb);\n\t}\n}\n\n \nstatic void __lapb_insert_cb(struct lapb_cb *lapb)\n{\n\tlist_add(&lapb->node, &lapb_list);\n\tlapb_hold(lapb);\n}\n\nstatic struct lapb_cb *__lapb_devtostruct(struct net_device *dev)\n{\n\tstruct lapb_cb *lapb, *use = NULL;\n\n\tlist_for_each_entry(lapb, &lapb_list, node) {\n\t\tif (lapb->dev == dev) {\n\t\t\tuse = lapb;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (use)\n\t\tlapb_hold(use);\n\n\treturn use;\n}\n\nstatic struct lapb_cb *lapb_devtostruct(struct net_device *dev)\n{\n\tstruct lapb_cb *rc;\n\n\tread_lock_bh(&lapb_list_lock);\n\trc = __lapb_devtostruct(dev);\n\tread_unlock_bh(&lapb_list_lock);\n\n\treturn rc;\n}\n \nstatic struct lapb_cb *lapb_create_cb(void)\n{\n\tstruct lapb_cb *lapb = kzalloc(sizeof(*lapb), GFP_ATOMIC);\n\n\tif (!lapb)\n\t\tgoto out;\n\n\tskb_queue_head_init(&lapb->write_queue);\n\tskb_queue_head_init(&lapb->ack_queue);\n\n\ttimer_setup(&lapb->t1timer, NULL, 0);\n\ttimer_setup(&lapb->t2timer, NULL, 0);\n\tlapb->t1timer_running = false;\n\tlapb->t2timer_running = false;\n\n\tlapb->t1      = LAPB_DEFAULT_T1;\n\tlapb->t2      = LAPB_DEFAULT_T2;\n\tlapb->n2      = LAPB_DEFAULT_N2;\n\tlapb->mode    = LAPB_DEFAULT_MODE;\n\tlapb->window  = LAPB_DEFAULT_WINDOW;\n\tlapb->state   = LAPB_STATE_0;\n\n\tspin_lock_init(&lapb->lock);\n\trefcount_set(&lapb->refcnt, 1);\nout:\n\treturn lapb;\n}\n\nint lapb_register(struct net_device *dev,\n\t\t  const struct lapb_register_struct *callbacks)\n{\n\tstruct lapb_cb *lapb;\n\tint rc = LAPB_BADTOKEN;\n\n\twrite_lock_bh(&lapb_list_lock);\n\n\tlapb = __lapb_devtostruct(dev);\n\tif (lapb) {\n\t\tlapb_put(lapb);\n\t\tgoto out;\n\t}\n\n\tlapb = lapb_create_cb();\n\trc = LAPB_NOMEM;\n\tif (!lapb)\n\t\tgoto out;\n\n\tlapb->dev       = dev;\n\tlapb->callbacks = callbacks;\n\n\t__lapb_insert_cb(lapb);\n\n\tlapb_start_t1timer(lapb);\n\n\trc = LAPB_OK;\nout:\n\twrite_unlock_bh(&lapb_list_lock);\n\treturn rc;\n}\nEXPORT_SYMBOL(lapb_register);\n\nint lapb_unregister(struct net_device *dev)\n{\n\tstruct lapb_cb *lapb;\n\tint rc = LAPB_BADTOKEN;\n\n\twrite_lock_bh(&lapb_list_lock);\n\tlapb = __lapb_devtostruct(dev);\n\tif (!lapb)\n\t\tgoto out;\n\tlapb_put(lapb);\n\n\t \n\twhile (refcount_read(&lapb->refcnt) > 2)\n\t\tusleep_range(1, 10);\n\n\tspin_lock_bh(&lapb->lock);\n\n\tlapb_stop_t1timer(lapb);\n\tlapb_stop_t2timer(lapb);\n\n\tlapb_clear_queues(lapb);\n\n\tspin_unlock_bh(&lapb->lock);\n\n\t \n\tdel_timer_sync(&lapb->t1timer);\n\tdel_timer_sync(&lapb->t2timer);\n\n\t__lapb_remove_cb(lapb);\n\n\tlapb_put(lapb);\n\trc = LAPB_OK;\nout:\n\twrite_unlock_bh(&lapb_list_lock);\n\treturn rc;\n}\nEXPORT_SYMBOL(lapb_unregister);\n\nint lapb_getparms(struct net_device *dev, struct lapb_parms_struct *parms)\n{\n\tint rc = LAPB_BADTOKEN;\n\tstruct lapb_cb *lapb = lapb_devtostruct(dev);\n\n\tif (!lapb)\n\t\tgoto out;\n\n\tspin_lock_bh(&lapb->lock);\n\n\tparms->t1      = lapb->t1 / HZ;\n\tparms->t2      = lapb->t2 / HZ;\n\tparms->n2      = lapb->n2;\n\tparms->n2count = lapb->n2count;\n\tparms->state   = lapb->state;\n\tparms->window  = lapb->window;\n\tparms->mode    = lapb->mode;\n\n\tif (!timer_pending(&lapb->t1timer))\n\t\tparms->t1timer = 0;\n\telse\n\t\tparms->t1timer = (lapb->t1timer.expires - jiffies) / HZ;\n\n\tif (!timer_pending(&lapb->t2timer))\n\t\tparms->t2timer = 0;\n\telse\n\t\tparms->t2timer = (lapb->t2timer.expires - jiffies) / HZ;\n\n\tspin_unlock_bh(&lapb->lock);\n\tlapb_put(lapb);\n\trc = LAPB_OK;\nout:\n\treturn rc;\n}\nEXPORT_SYMBOL(lapb_getparms);\n\nint lapb_setparms(struct net_device *dev, struct lapb_parms_struct *parms)\n{\n\tint rc = LAPB_BADTOKEN;\n\tstruct lapb_cb *lapb = lapb_devtostruct(dev);\n\n\tif (!lapb)\n\t\tgoto out;\n\n\tspin_lock_bh(&lapb->lock);\n\n\trc = LAPB_INVALUE;\n\tif (parms->t1 < 1 || parms->t2 < 1 || parms->n2 < 1)\n\t\tgoto out_put;\n\n\tif (lapb->state == LAPB_STATE_0) {\n\t\tif (parms->mode & LAPB_EXTENDED) {\n\t\t\tif (parms->window < 1 || parms->window > 127)\n\t\t\t\tgoto out_put;\n\t\t} else {\n\t\t\tif (parms->window < 1 || parms->window > 7)\n\t\t\t\tgoto out_put;\n\t\t}\n\t\tlapb->mode    = parms->mode;\n\t\tlapb->window  = parms->window;\n\t}\n\n\tlapb->t1    = parms->t1 * HZ;\n\tlapb->t2    = parms->t2 * HZ;\n\tlapb->n2    = parms->n2;\n\n\trc = LAPB_OK;\nout_put:\n\tspin_unlock_bh(&lapb->lock);\n\tlapb_put(lapb);\nout:\n\treturn rc;\n}\nEXPORT_SYMBOL(lapb_setparms);\n\nint lapb_connect_request(struct net_device *dev)\n{\n\tstruct lapb_cb *lapb = lapb_devtostruct(dev);\n\tint rc = LAPB_BADTOKEN;\n\n\tif (!lapb)\n\t\tgoto out;\n\n\tspin_lock_bh(&lapb->lock);\n\n\trc = LAPB_OK;\n\tif (lapb->state == LAPB_STATE_1)\n\t\tgoto out_put;\n\n\trc = LAPB_CONNECTED;\n\tif (lapb->state == LAPB_STATE_3 || lapb->state == LAPB_STATE_4)\n\t\tgoto out_put;\n\n\tlapb_establish_data_link(lapb);\n\n\tlapb_dbg(0, \"(%p) S0 -> S1\\n\", lapb->dev);\n\tlapb->state = LAPB_STATE_1;\n\n\trc = LAPB_OK;\nout_put:\n\tspin_unlock_bh(&lapb->lock);\n\tlapb_put(lapb);\nout:\n\treturn rc;\n}\nEXPORT_SYMBOL(lapb_connect_request);\n\nstatic int __lapb_disconnect_request(struct lapb_cb *lapb)\n{\n\tswitch (lapb->state) {\n\tcase LAPB_STATE_0:\n\t\treturn LAPB_NOTCONNECTED;\n\n\tcase LAPB_STATE_1:\n\t\tlapb_dbg(1, \"(%p) S1 TX DISC(1)\\n\", lapb->dev);\n\t\tlapb_dbg(0, \"(%p) S1 -> S0\\n\", lapb->dev);\n\t\tlapb_send_control(lapb, LAPB_DISC, LAPB_POLLON, LAPB_COMMAND);\n\t\tlapb->state = LAPB_STATE_0;\n\t\tlapb_start_t1timer(lapb);\n\t\treturn LAPB_NOTCONNECTED;\n\n\tcase LAPB_STATE_2:\n\t\treturn LAPB_OK;\n\t}\n\n\tlapb_clear_queues(lapb);\n\tlapb->n2count = 0;\n\tlapb_send_control(lapb, LAPB_DISC, LAPB_POLLON, LAPB_COMMAND);\n\tlapb_start_t1timer(lapb);\n\tlapb_stop_t2timer(lapb);\n\tlapb->state = LAPB_STATE_2;\n\n\tlapb_dbg(1, \"(%p) S3 DISC(1)\\n\", lapb->dev);\n\tlapb_dbg(0, \"(%p) S3 -> S2\\n\", lapb->dev);\n\n\treturn LAPB_OK;\n}\n\nint lapb_disconnect_request(struct net_device *dev)\n{\n\tstruct lapb_cb *lapb = lapb_devtostruct(dev);\n\tint rc = LAPB_BADTOKEN;\n\n\tif (!lapb)\n\t\tgoto out;\n\n\tspin_lock_bh(&lapb->lock);\n\n\trc = __lapb_disconnect_request(lapb);\n\n\tspin_unlock_bh(&lapb->lock);\n\tlapb_put(lapb);\nout:\n\treturn rc;\n}\nEXPORT_SYMBOL(lapb_disconnect_request);\n\nint lapb_data_request(struct net_device *dev, struct sk_buff *skb)\n{\n\tstruct lapb_cb *lapb = lapb_devtostruct(dev);\n\tint rc = LAPB_BADTOKEN;\n\n\tif (!lapb)\n\t\tgoto out;\n\n\tspin_lock_bh(&lapb->lock);\n\n\trc = LAPB_NOTCONNECTED;\n\tif (lapb->state != LAPB_STATE_3 && lapb->state != LAPB_STATE_4)\n\t\tgoto out_put;\n\n\tskb_queue_tail(&lapb->write_queue, skb);\n\tlapb_kick(lapb);\n\trc = LAPB_OK;\nout_put:\n\tspin_unlock_bh(&lapb->lock);\n\tlapb_put(lapb);\nout:\n\treturn rc;\n}\nEXPORT_SYMBOL(lapb_data_request);\n\nint lapb_data_received(struct net_device *dev, struct sk_buff *skb)\n{\n\tstruct lapb_cb *lapb = lapb_devtostruct(dev);\n\tint rc = LAPB_BADTOKEN;\n\n\tif (lapb) {\n\t\tspin_lock_bh(&lapb->lock);\n\t\tlapb_data_input(lapb, skb);\n\t\tspin_unlock_bh(&lapb->lock);\n\t\tlapb_put(lapb);\n\t\trc = LAPB_OK;\n\t}\n\n\treturn rc;\n}\nEXPORT_SYMBOL(lapb_data_received);\n\nvoid lapb_connect_confirmation(struct lapb_cb *lapb, int reason)\n{\n\tif (lapb->callbacks->connect_confirmation)\n\t\tlapb->callbacks->connect_confirmation(lapb->dev, reason);\n}\n\nvoid lapb_connect_indication(struct lapb_cb *lapb, int reason)\n{\n\tif (lapb->callbacks->connect_indication)\n\t\tlapb->callbacks->connect_indication(lapb->dev, reason);\n}\n\nvoid lapb_disconnect_confirmation(struct lapb_cb *lapb, int reason)\n{\n\tif (lapb->callbacks->disconnect_confirmation)\n\t\tlapb->callbacks->disconnect_confirmation(lapb->dev, reason);\n}\n\nvoid lapb_disconnect_indication(struct lapb_cb *lapb, int reason)\n{\n\tif (lapb->callbacks->disconnect_indication)\n\t\tlapb->callbacks->disconnect_indication(lapb->dev, reason);\n}\n\nint lapb_data_indication(struct lapb_cb *lapb, struct sk_buff *skb)\n{\n\tif (lapb->callbacks->data_indication)\n\t\treturn lapb->callbacks->data_indication(lapb->dev, skb);\n\n\tkfree_skb(skb);\n\treturn NET_RX_SUCCESS;  \n}\n\nint lapb_data_transmit(struct lapb_cb *lapb, struct sk_buff *skb)\n{\n\tint used = 0;\n\n\tif (lapb->callbacks->data_transmit) {\n\t\tlapb->callbacks->data_transmit(lapb->dev, skb);\n\t\tused = 1;\n\t}\n\n\treturn used;\n}\n\n \nstatic int lapb_device_event(struct notifier_block *this, unsigned long event,\n\t\t\t     void *ptr)\n{\n\tstruct net_device *dev = netdev_notifier_info_to_dev(ptr);\n\tstruct lapb_cb *lapb;\n\n\tif (!net_eq(dev_net(dev), &init_net))\n\t\treturn NOTIFY_DONE;\n\n\tif (dev->type != ARPHRD_X25)\n\t\treturn NOTIFY_DONE;\n\n\tlapb = lapb_devtostruct(dev);\n\tif (!lapb)\n\t\treturn NOTIFY_DONE;\n\n\tspin_lock_bh(&lapb->lock);\n\n\tswitch (event) {\n\tcase NETDEV_UP:\n\t\tlapb_dbg(0, \"(%p) Interface up: %s\\n\", dev, dev->name);\n\n\t\tif (netif_carrier_ok(dev)) {\n\t\t\tlapb_dbg(0, \"(%p): Carrier is already up: %s\\n\", dev,\n\t\t\t\t dev->name);\n\t\t\tif (lapb->mode & LAPB_DCE) {\n\t\t\t\tlapb_start_t1timer(lapb);\n\t\t\t} else {\n\t\t\t\tif (lapb->state == LAPB_STATE_0) {\n\t\t\t\t\tlapb->state = LAPB_STATE_1;\n\t\t\t\t\tlapb_establish_data_link(lapb);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase NETDEV_GOING_DOWN:\n\t\tif (netif_carrier_ok(dev))\n\t\t\t__lapb_disconnect_request(lapb);\n\t\tbreak;\n\tcase NETDEV_DOWN:\n\t\tlapb_dbg(0, \"(%p) Interface down: %s\\n\", dev, dev->name);\n\t\tlapb_dbg(0, \"(%p) S%d -> S0\\n\", dev, lapb->state);\n\t\tlapb_clear_queues(lapb);\n\t\tlapb->state = LAPB_STATE_0;\n\t\tlapb->n2count   = 0;\n\t\tlapb_stop_t1timer(lapb);\n\t\tlapb_stop_t2timer(lapb);\n\t\tbreak;\n\tcase NETDEV_CHANGE:\n\t\tif (netif_carrier_ok(dev)) {\n\t\t\tlapb_dbg(0, \"(%p): Carrier detected: %s\\n\", dev,\n\t\t\t\t dev->name);\n\t\t\tif (lapb->mode & LAPB_DCE) {\n\t\t\t\tlapb_start_t1timer(lapb);\n\t\t\t} else {\n\t\t\t\tif (lapb->state == LAPB_STATE_0) {\n\t\t\t\t\tlapb->state = LAPB_STATE_1;\n\t\t\t\t\tlapb_establish_data_link(lapb);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tlapb_dbg(0, \"(%p) Carrier lost: %s\\n\", dev, dev->name);\n\t\t\tlapb_dbg(0, \"(%p) S%d -> S0\\n\", dev, lapb->state);\n\t\t\tlapb_clear_queues(lapb);\n\t\t\tlapb->state = LAPB_STATE_0;\n\t\t\tlapb->n2count   = 0;\n\t\t\tlapb_stop_t1timer(lapb);\n\t\t\tlapb_stop_t2timer(lapb);\n\t\t}\n\t\tbreak;\n\t}\n\n\tspin_unlock_bh(&lapb->lock);\n\tlapb_put(lapb);\n\treturn NOTIFY_DONE;\n}\n\nstatic struct notifier_block lapb_dev_notifier = {\n\t.notifier_call = lapb_device_event,\n};\n\nstatic int __init lapb_init(void)\n{\n\treturn register_netdevice_notifier(&lapb_dev_notifier);\n}\n\nstatic void __exit lapb_exit(void)\n{\n\tWARN_ON(!list_empty(&lapb_list));\n\n\tunregister_netdevice_notifier(&lapb_dev_notifier);\n}\n\nMODULE_AUTHOR(\"Jonathan Naylor <g4klx@g4klx.demon.co.uk>\");\nMODULE_DESCRIPTION(\"The X.25 Link Access Procedure B link layer protocol\");\nMODULE_LICENSE(\"GPL\");\n\nmodule_init(lapb_init);\nmodule_exit(lapb_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}