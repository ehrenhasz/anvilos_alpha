{
  "module_name": "lapb_timer.c",
  "hash_id": "419fc106c54f6e4eb6e55603ecb9ec4c51bcec5763625b6b4c49052b6c3e4b7c",
  "original_prompt": "Ingested from linux-6.6.14/net/lapb/lapb_timer.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/socket.h>\n#include <linux/in.h>\n#include <linux/kernel.h>\n#include <linux/jiffies.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/sockios.h>\n#include <linux/net.h>\n#include <linux/inet.h>\n#include <linux/skbuff.h>\n#include <net/sock.h>\n#include <linux/uaccess.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/interrupt.h>\n#include <net/lapb.h>\n\nstatic void lapb_t1timer_expiry(struct timer_list *);\nstatic void lapb_t2timer_expiry(struct timer_list *);\n\nvoid lapb_start_t1timer(struct lapb_cb *lapb)\n{\n\tdel_timer(&lapb->t1timer);\n\n\tlapb->t1timer.function = lapb_t1timer_expiry;\n\tlapb->t1timer.expires  = jiffies + lapb->t1;\n\n\tlapb->t1timer_running = true;\n\tadd_timer(&lapb->t1timer);\n}\n\nvoid lapb_start_t2timer(struct lapb_cb *lapb)\n{\n\tdel_timer(&lapb->t2timer);\n\n\tlapb->t2timer.function = lapb_t2timer_expiry;\n\tlapb->t2timer.expires  = jiffies + lapb->t2;\n\n\tlapb->t2timer_running = true;\n\tadd_timer(&lapb->t2timer);\n}\n\nvoid lapb_stop_t1timer(struct lapb_cb *lapb)\n{\n\tlapb->t1timer_running = false;\n\tdel_timer(&lapb->t1timer);\n}\n\nvoid lapb_stop_t2timer(struct lapb_cb *lapb)\n{\n\tlapb->t2timer_running = false;\n\tdel_timer(&lapb->t2timer);\n}\n\nint lapb_t1timer_running(struct lapb_cb *lapb)\n{\n\treturn lapb->t1timer_running;\n}\n\nstatic void lapb_t2timer_expiry(struct timer_list *t)\n{\n\tstruct lapb_cb *lapb = from_timer(lapb, t, t2timer);\n\n\tspin_lock_bh(&lapb->lock);\n\tif (timer_pending(&lapb->t2timer))  \n\t\tgoto out;\n\tif (!lapb->t2timer_running)  \n\t\tgoto out;\n\n\tif (lapb->condition & LAPB_ACK_PENDING_CONDITION) {\n\t\tlapb->condition &= ~LAPB_ACK_PENDING_CONDITION;\n\t\tlapb_timeout_response(lapb);\n\t}\n\tlapb->t2timer_running = false;\n\nout:\n\tspin_unlock_bh(&lapb->lock);\n}\n\nstatic void lapb_t1timer_expiry(struct timer_list *t)\n{\n\tstruct lapb_cb *lapb = from_timer(lapb, t, t1timer);\n\n\tspin_lock_bh(&lapb->lock);\n\tif (timer_pending(&lapb->t1timer))  \n\t\tgoto out;\n\tif (!lapb->t1timer_running)  \n\t\tgoto out;\n\n\tswitch (lapb->state) {\n\n\t\t \n\t\tcase LAPB_STATE_0:\n\t\t\tif (lapb->mode & LAPB_DCE &&\n\t\t\t    lapb->n2count != lapb->n2) {\n\t\t\t\tlapb->n2count++;\n\t\t\t\tlapb_send_control(lapb, LAPB_DM, LAPB_POLLOFF, LAPB_RESPONSE);\n\t\t\t} else {\n\t\t\t\tlapb->state = LAPB_STATE_1;\n\t\t\t\tlapb_establish_data_link(lapb);\n\t\t\t}\n\t\t\tbreak;\n\n\t\t \n\t\tcase LAPB_STATE_1:\n\t\t\tif (lapb->n2count == lapb->n2) {\n\t\t\t\tlapb_clear_queues(lapb);\n\t\t\t\tlapb->state = LAPB_STATE_0;\n\t\t\t\tlapb_disconnect_indication(lapb, LAPB_TIMEDOUT);\n\t\t\t\tlapb_dbg(0, \"(%p) S1 -> S0\\n\", lapb->dev);\n\t\t\t\tlapb->t1timer_running = false;\n\t\t\t\tgoto out;\n\t\t\t} else {\n\t\t\t\tlapb->n2count++;\n\t\t\t\tif (lapb->mode & LAPB_EXTENDED) {\n\t\t\t\t\tlapb_dbg(1, \"(%p) S1 TX SABME(1)\\n\",\n\t\t\t\t\t\t lapb->dev);\n\t\t\t\t\tlapb_send_control(lapb, LAPB_SABME, LAPB_POLLON, LAPB_COMMAND);\n\t\t\t\t} else {\n\t\t\t\t\tlapb_dbg(1, \"(%p) S1 TX SABM(1)\\n\",\n\t\t\t\t\t\t lapb->dev);\n\t\t\t\t\tlapb_send_control(lapb, LAPB_SABM, LAPB_POLLON, LAPB_COMMAND);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\t \n\t\tcase LAPB_STATE_2:\n\t\t\tif (lapb->n2count == lapb->n2) {\n\t\t\t\tlapb_clear_queues(lapb);\n\t\t\t\tlapb->state = LAPB_STATE_0;\n\t\t\t\tlapb_disconnect_confirmation(lapb, LAPB_TIMEDOUT);\n\t\t\t\tlapb_dbg(0, \"(%p) S2 -> S0\\n\", lapb->dev);\n\t\t\t\tlapb->t1timer_running = false;\n\t\t\t\tgoto out;\n\t\t\t} else {\n\t\t\t\tlapb->n2count++;\n\t\t\t\tlapb_dbg(1, \"(%p) S2 TX DISC(1)\\n\", lapb->dev);\n\t\t\t\tlapb_send_control(lapb, LAPB_DISC, LAPB_POLLON, LAPB_COMMAND);\n\t\t\t}\n\t\t\tbreak;\n\n\t\t \n\t\tcase LAPB_STATE_3:\n\t\t\tif (lapb->n2count == lapb->n2) {\n\t\t\t\tlapb_clear_queues(lapb);\n\t\t\t\tlapb->state = LAPB_STATE_0;\n\t\t\t\tlapb_stop_t2timer(lapb);\n\t\t\t\tlapb_disconnect_indication(lapb, LAPB_TIMEDOUT);\n\t\t\t\tlapb_dbg(0, \"(%p) S3 -> S0\\n\", lapb->dev);\n\t\t\t\tlapb->t1timer_running = false;\n\t\t\t\tgoto out;\n\t\t\t} else {\n\t\t\t\tlapb->n2count++;\n\t\t\t\tlapb_requeue_frames(lapb);\n\t\t\t\tlapb_kick(lapb);\n\t\t\t}\n\t\t\tbreak;\n\n\t\t \n\t\tcase LAPB_STATE_4:\n\t\t\tif (lapb->n2count == lapb->n2) {\n\t\t\t\tlapb_clear_queues(lapb);\n\t\t\t\tlapb->state = LAPB_STATE_0;\n\t\t\t\tlapb_disconnect_indication(lapb, LAPB_TIMEDOUT);\n\t\t\t\tlapb_dbg(0, \"(%p) S4 -> S0\\n\", lapb->dev);\n\t\t\t\tlapb->t1timer_running = false;\n\t\t\t\tgoto out;\n\t\t\t} else {\n\t\t\t\tlapb->n2count++;\n\t\t\t\tlapb_transmit_frmr(lapb);\n\t\t\t}\n\t\t\tbreak;\n\t}\n\n\tlapb_start_t1timer(lapb);\n\nout:\n\tspin_unlock_bh(&lapb->lock);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}