{
  "module_name": "strparser.c",
  "hash_id": "d6010d1a591de18252cfae75c067d92fa89e40bc43b4babe6cbe8688cbad3f5b",
  "original_prompt": "Ingested from linux-6.6.14/net/strparser/strparser.c",
  "human_readable_source": "\n \n\n#include <linux/bpf.h>\n#include <linux/errno.h>\n#include <linux/errqueue.h>\n#include <linux/file.h>\n#include <linux/in.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/net.h>\n#include <linux/netdevice.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/skbuff.h>\n#include <linux/socket.h>\n#include <linux/uaccess.h>\n#include <linux/workqueue.h>\n#include <net/strparser.h>\n#include <net/netns/generic.h>\n#include <net/sock.h>\n\nstatic struct workqueue_struct *strp_wq;\n\nstatic inline struct _strp_msg *_strp_msg(struct sk_buff *skb)\n{\n\treturn (struct _strp_msg *)((void *)skb->cb +\n\t\toffsetof(struct sk_skb_cb, strp));\n}\n\n \nstatic void strp_abort_strp(struct strparser *strp, int err)\n{\n\t \n\n\tcancel_delayed_work(&strp->msg_timer_work);\n\n\tif (strp->stopped)\n\t\treturn;\n\n\tstrp->stopped = 1;\n\n\tif (strp->sk) {\n\t\tstruct sock *sk = strp->sk;\n\n\t\t \n\t\tsk->sk_err = -err;\n\t\tsk_error_report(sk);\n\t}\n}\n\nstatic void strp_start_timer(struct strparser *strp, long timeo)\n{\n\tif (timeo && timeo != LONG_MAX)\n\t\tmod_delayed_work(strp_wq, &strp->msg_timer_work, timeo);\n}\n\n \nstatic void strp_parser_err(struct strparser *strp, int err,\n\t\t\t    read_descriptor_t *desc)\n{\n\tdesc->error = err;\n\tkfree_skb(strp->skb_head);\n\tstrp->skb_head = NULL;\n\tstrp->cb.abort_parser(strp, err);\n}\n\nstatic inline int strp_peek_len(struct strparser *strp)\n{\n\tif (strp->sk) {\n\t\tstruct socket *sock = strp->sk->sk_socket;\n\n\t\treturn sock->ops->peek_len(sock);\n\t}\n\n\t \n\n\treturn INT_MAX;\n}\n\n \nstatic int __strp_recv(read_descriptor_t *desc, struct sk_buff *orig_skb,\n\t\t       unsigned int orig_offset, size_t orig_len,\n\t\t       size_t max_msg_size, long timeo)\n{\n\tstruct strparser *strp = (struct strparser *)desc->arg.data;\n\tstruct _strp_msg *stm;\n\tstruct sk_buff *head, *skb;\n\tsize_t eaten = 0, cand_len;\n\tssize_t extra;\n\tint err;\n\tbool cloned_orig = false;\n\n\tif (strp->paused)\n\t\treturn 0;\n\n\thead = strp->skb_head;\n\tif (head) {\n\t\t \n\t\tif (unlikely(orig_offset)) {\n\t\t\t \n\t\t\torig_skb = skb_clone(orig_skb, GFP_ATOMIC);\n\t\t\tif (!orig_skb) {\n\t\t\t\tSTRP_STATS_INCR(strp->stats.mem_fail);\n\t\t\t\tdesc->error = -ENOMEM;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (!pskb_pull(orig_skb, orig_offset)) {\n\t\t\t\tSTRP_STATS_INCR(strp->stats.mem_fail);\n\t\t\t\tkfree_skb(orig_skb);\n\t\t\t\tdesc->error = -ENOMEM;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tcloned_orig = true;\n\t\t\torig_offset = 0;\n\t\t}\n\n\t\tif (!strp->skb_nextp) {\n\t\t\t \n\t\t\terr = skb_unclone(head, GFP_ATOMIC);\n\t\t\tif (err) {\n\t\t\t\tSTRP_STATS_INCR(strp->stats.mem_fail);\n\t\t\t\tdesc->error = err;\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tif (unlikely(skb_shinfo(head)->frag_list)) {\n\t\t\t\t \n\t\t\t\tif (WARN_ON(head->next)) {\n\t\t\t\t\tdesc->error = -EINVAL;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\n\t\t\t\tskb = alloc_skb_for_msg(head);\n\t\t\t\tif (!skb) {\n\t\t\t\t\tSTRP_STATS_INCR(strp->stats.mem_fail);\n\t\t\t\t\tdesc->error = -ENOMEM;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\n\t\t\t\tstrp->skb_nextp = &head->next;\n\t\t\t\tstrp->skb_head = skb;\n\t\t\t\thead = skb;\n\t\t\t} else {\n\t\t\t\tstrp->skb_nextp =\n\t\t\t\t    &skb_shinfo(head)->frag_list;\n\t\t\t}\n\t\t}\n\t}\n\n\twhile (eaten < orig_len) {\n\t\t \n\t\tskb = skb_clone(orig_skb, GFP_ATOMIC);\n\t\tif (!skb) {\n\t\t\tSTRP_STATS_INCR(strp->stats.mem_fail);\n\t\t\tdesc->error = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\n\t\tcand_len = orig_len - eaten;\n\n\t\thead = strp->skb_head;\n\t\tif (!head) {\n\t\t\thead = skb;\n\t\t\tstrp->skb_head = head;\n\t\t\t \n\t\t\tstrp->skb_nextp = NULL;\n\t\t\tstm = _strp_msg(head);\n\t\t\tmemset(stm, 0, sizeof(*stm));\n\t\t\tstm->strp.offset = orig_offset + eaten;\n\t\t} else {\n\t\t\t \n\t\t\tif (skb_has_frag_list(skb)) {\n\t\t\t\terr = skb_unclone(skb, GFP_ATOMIC);\n\t\t\t\tif (err) {\n\t\t\t\t\tSTRP_STATS_INCR(strp->stats.mem_fail);\n\t\t\t\t\tdesc->error = err;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tstm = _strp_msg(head);\n\t\t\t*strp->skb_nextp = skb;\n\t\t\tstrp->skb_nextp = &skb->next;\n\t\t\thead->data_len += skb->len;\n\t\t\thead->len += skb->len;\n\t\t\thead->truesize += skb->truesize;\n\t\t}\n\n\t\tif (!stm->strp.full_len) {\n\t\t\tssize_t len;\n\n\t\t\tlen = (*strp->cb.parse_msg)(strp, head);\n\n\t\t\tif (!len) {\n\t\t\t\t \n\t\t\t\tif (!stm->accum_len) {\n\t\t\t\t\t \n\t\t\t\t\tstrp_start_timer(strp, timeo);\n\t\t\t\t}\n\t\t\t\tstm->accum_len += cand_len;\n\t\t\t\teaten += cand_len;\n\t\t\t\tSTRP_STATS_INCR(strp->stats.need_more_hdr);\n\t\t\t\tWARN_ON(eaten != orig_len);\n\t\t\t\tbreak;\n\t\t\t} else if (len < 0) {\n\t\t\t\tif (len == -ESTRPIPE && stm->accum_len) {\n\t\t\t\t\tlen = -ENODATA;\n\t\t\t\t\tstrp->unrecov_intr = 1;\n\t\t\t\t} else {\n\t\t\t\t\tstrp->interrupted = 1;\n\t\t\t\t}\n\t\t\t\tstrp_parser_err(strp, len, desc);\n\t\t\t\tbreak;\n\t\t\t} else if (len > max_msg_size) {\n\t\t\t\t \n\t\t\t\tSTRP_STATS_INCR(strp->stats.msg_too_big);\n\t\t\t\tstrp_parser_err(strp, -EMSGSIZE, desc);\n\t\t\t\tbreak;\n\t\t\t} else if (len <= (ssize_t)head->len -\n\t\t\t\t\t  skb->len - stm->strp.offset) {\n\t\t\t\t \n\t\t\t\tSTRP_STATS_INCR(strp->stats.bad_hdr_len);\n\t\t\t\tstrp_parser_err(strp, -EPROTO, desc);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tstm->strp.full_len = len;\n\t\t}\n\n\t\textra = (ssize_t)(stm->accum_len + cand_len) -\n\t\t\tstm->strp.full_len;\n\n\t\tif (extra < 0) {\n\t\t\t \n\t\t\tif (stm->strp.full_len - stm->accum_len >\n\t\t\t    strp_peek_len(strp)) {\n\t\t\t\t \n\n\t\t\t\tif (!stm->accum_len) {\n\t\t\t\t\t \n\t\t\t\t\tstrp_start_timer(strp, timeo);\n\t\t\t\t}\n\n\t\t\t\tstm->accum_len += cand_len;\n\t\t\t\teaten += cand_len;\n\t\t\t\tstrp->need_bytes = stm->strp.full_len -\n\t\t\t\t\t\t       stm->accum_len;\n\t\t\t\tSTRP_STATS_ADD(strp->stats.bytes, cand_len);\n\t\t\t\tdesc->count = 0;  \n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tstm->accum_len += cand_len;\n\t\t\teaten += cand_len;\n\t\t\tWARN_ON(eaten != orig_len);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\n\t\tWARN_ON(extra > cand_len);\n\n\t\teaten += (cand_len - extra);\n\n\t\t \n\t\tcancel_delayed_work(&strp->msg_timer_work);\n\t\tstrp->skb_head = NULL;\n\t\tstrp->need_bytes = 0;\n\t\tSTRP_STATS_INCR(strp->stats.msgs);\n\n\t\t \n\t\tstrp->cb.rcv_msg(strp, head);\n\n\t\tif (unlikely(strp->paused)) {\n\t\t\t \n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (cloned_orig)\n\t\tkfree_skb(orig_skb);\n\n\tSTRP_STATS_ADD(strp->stats.bytes, eaten);\n\n\treturn eaten;\n}\n\nint strp_process(struct strparser *strp, struct sk_buff *orig_skb,\n\t\t unsigned int orig_offset, size_t orig_len,\n\t\t size_t max_msg_size, long timeo)\n{\n\tread_descriptor_t desc;  \n\n\tdesc.arg.data = strp;\n\n\treturn __strp_recv(&desc, orig_skb, orig_offset, orig_len,\n\t\t\t   max_msg_size, timeo);\n}\nEXPORT_SYMBOL_GPL(strp_process);\n\nstatic int strp_recv(read_descriptor_t *desc, struct sk_buff *orig_skb,\n\t\t     unsigned int orig_offset, size_t orig_len)\n{\n\tstruct strparser *strp = (struct strparser *)desc->arg.data;\n\n\treturn __strp_recv(desc, orig_skb, orig_offset, orig_len,\n\t\t\t   strp->sk->sk_rcvbuf, strp->sk->sk_rcvtimeo);\n}\n\nstatic int default_read_sock_done(struct strparser *strp, int err)\n{\n\treturn err;\n}\n\n \nstatic int strp_read_sock(struct strparser *strp)\n{\n\tstruct socket *sock = strp->sk->sk_socket;\n\tread_descriptor_t desc;\n\n\tif (unlikely(!sock || !sock->ops || !sock->ops->read_sock))\n\t\treturn -EBUSY;\n\n\tdesc.arg.data = strp;\n\tdesc.error = 0;\n\tdesc.count = 1;  \n\n\t \n\tsock->ops->read_sock(strp->sk, &desc, strp_recv);\n\n\tdesc.error = strp->cb.read_sock_done(strp, desc.error);\n\n\treturn desc.error;\n}\n\n \nvoid strp_data_ready(struct strparser *strp)\n{\n\tif (unlikely(strp->stopped) || strp->paused)\n\t\treturn;\n\n\t \n\tif (sock_owned_by_user_nocheck(strp->sk)) {\n\t\tqueue_work(strp_wq, &strp->work);\n\t\treturn;\n\t}\n\n\tif (strp->need_bytes) {\n\t\tif (strp_peek_len(strp) < strp->need_bytes)\n\t\t\treturn;\n\t}\n\n\tif (strp_read_sock(strp) == -ENOMEM)\n\t\tqueue_work(strp_wq, &strp->work);\n}\nEXPORT_SYMBOL_GPL(strp_data_ready);\n\nstatic void do_strp_work(struct strparser *strp)\n{\n\t \n\tstrp->cb.lock(strp);\n\n\tif (unlikely(strp->stopped))\n\t\tgoto out;\n\n\tif (strp->paused)\n\t\tgoto out;\n\n\tif (strp_read_sock(strp) == -ENOMEM)\n\t\tqueue_work(strp_wq, &strp->work);\n\nout:\n\tstrp->cb.unlock(strp);\n}\n\nstatic void strp_work(struct work_struct *w)\n{\n\tdo_strp_work(container_of(w, struct strparser, work));\n}\n\nstatic void strp_msg_timeout(struct work_struct *w)\n{\n\tstruct strparser *strp = container_of(w, struct strparser,\n\t\t\t\t\t      msg_timer_work.work);\n\n\t \n\tSTRP_STATS_INCR(strp->stats.msg_timeouts);\n\tstrp->cb.lock(strp);\n\tstrp->cb.abort_parser(strp, -ETIMEDOUT);\n\tstrp->cb.unlock(strp);\n}\n\nstatic void strp_sock_lock(struct strparser *strp)\n{\n\tlock_sock(strp->sk);\n}\n\nstatic void strp_sock_unlock(struct strparser *strp)\n{\n\trelease_sock(strp->sk);\n}\n\nint strp_init(struct strparser *strp, struct sock *sk,\n\t      const struct strp_callbacks *cb)\n{\n\n\tif (!cb || !cb->rcv_msg || !cb->parse_msg)\n\t\treturn -EINVAL;\n\n\t \n\n\tif (!sk) {\n\t\tif (!cb->lock || !cb->unlock)\n\t\t\treturn -EINVAL;\n\t}\n\n\tmemset(strp, 0, sizeof(*strp));\n\n\tstrp->sk = sk;\n\n\tstrp->cb.lock = cb->lock ? : strp_sock_lock;\n\tstrp->cb.unlock = cb->unlock ? : strp_sock_unlock;\n\tstrp->cb.rcv_msg = cb->rcv_msg;\n\tstrp->cb.parse_msg = cb->parse_msg;\n\tstrp->cb.read_sock_done = cb->read_sock_done ? : default_read_sock_done;\n\tstrp->cb.abort_parser = cb->abort_parser ? : strp_abort_strp;\n\n\tINIT_DELAYED_WORK(&strp->msg_timer_work, strp_msg_timeout);\n\tINIT_WORK(&strp->work, strp_work);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(strp_init);\n\n \nvoid __strp_unpause(struct strparser *strp)\n{\n\tstrp->paused = 0;\n\n\tif (strp->need_bytes) {\n\t\tif (strp_peek_len(strp) < strp->need_bytes)\n\t\t\treturn;\n\t}\n\tstrp_read_sock(strp);\n}\nEXPORT_SYMBOL_GPL(__strp_unpause);\n\nvoid strp_unpause(struct strparser *strp)\n{\n\tstrp->paused = 0;\n\n\t \n\tsmp_mb();\n\n\tqueue_work(strp_wq, &strp->work);\n}\nEXPORT_SYMBOL_GPL(strp_unpause);\n\n \nvoid strp_done(struct strparser *strp)\n{\n\tWARN_ON(!strp->stopped);\n\n\tcancel_delayed_work_sync(&strp->msg_timer_work);\n\tcancel_work_sync(&strp->work);\n\n\tif (strp->skb_head) {\n\t\tkfree_skb(strp->skb_head);\n\t\tstrp->skb_head = NULL;\n\t}\n}\nEXPORT_SYMBOL_GPL(strp_done);\n\nvoid strp_stop(struct strparser *strp)\n{\n\tstrp->stopped = 1;\n}\nEXPORT_SYMBOL_GPL(strp_stop);\n\nvoid strp_check_rcv(struct strparser *strp)\n{\n\tqueue_work(strp_wq, &strp->work);\n}\nEXPORT_SYMBOL_GPL(strp_check_rcv);\n\nstatic int __init strp_dev_init(void)\n{\n\tBUILD_BUG_ON(sizeof(struct sk_skb_cb) >\n\t\t     sizeof_field(struct sk_buff, cb));\n\n\tstrp_wq = create_singlethread_workqueue(\"kstrp\");\n\tif (unlikely(!strp_wq))\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\ndevice_initcall(strp_dev_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}