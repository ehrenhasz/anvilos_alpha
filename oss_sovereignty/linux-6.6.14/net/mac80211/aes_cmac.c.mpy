{
  "module_name": "aes_cmac.c",
  "hash_id": "d134cb8aad7c73fcaf19757d65ba325fd16aa96a8f40256857480b9ef5f0587a",
  "original_prompt": "Ingested from linux-6.6.14/net/mac80211/aes_cmac.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/crypto.h>\n#include <linux/export.h>\n#include <linux/err.h>\n#include <crypto/aes.h>\n\n#include <net/mac80211.h>\n#include \"key.h\"\n#include \"aes_cmac.h\"\n\n#define CMAC_TLEN 8  \n#define CMAC_TLEN_256 16  \n#define AAD_LEN 20\n\nstatic const u8 zero[CMAC_TLEN_256];\n\nvoid ieee80211_aes_cmac(struct crypto_shash *tfm, const u8 *aad,\n\t\t\tconst u8 *data, size_t data_len, u8 *mic)\n{\n\tSHASH_DESC_ON_STACK(desc, tfm);\n\tu8 out[AES_BLOCK_SIZE];\n\tconst __le16 *fc;\n\n\tdesc->tfm = tfm;\n\n\tcrypto_shash_init(desc);\n\tcrypto_shash_update(desc, aad, AAD_LEN);\n\tfc = (const __le16 *)aad;\n\tif (ieee80211_is_beacon(*fc)) {\n\t\t \n\t\tcrypto_shash_update(desc, zero, 8);\n\t\tcrypto_shash_update(desc, data + 8, data_len - 8 - CMAC_TLEN);\n\t} else {\n\t\tcrypto_shash_update(desc, data, data_len - CMAC_TLEN);\n\t}\n\tcrypto_shash_finup(desc, zero, CMAC_TLEN, out);\n\n\tmemcpy(mic, out, CMAC_TLEN);\n}\n\nvoid ieee80211_aes_cmac_256(struct crypto_shash *tfm, const u8 *aad,\n\t\t\t    const u8 *data, size_t data_len, u8 *mic)\n{\n\tSHASH_DESC_ON_STACK(desc, tfm);\n\tconst __le16 *fc;\n\n\tdesc->tfm = tfm;\n\n\tcrypto_shash_init(desc);\n\tcrypto_shash_update(desc, aad, AAD_LEN);\n\tfc = (const __le16 *)aad;\n\tif (ieee80211_is_beacon(*fc)) {\n\t\t \n\t\tcrypto_shash_update(desc, zero, 8);\n\t\tcrypto_shash_update(desc, data + 8,\n\t\t\t\t    data_len - 8 - CMAC_TLEN_256);\n\t} else {\n\t\tcrypto_shash_update(desc, data, data_len - CMAC_TLEN_256);\n\t}\n\tcrypto_shash_finup(desc, zero, CMAC_TLEN_256, mic);\n}\n\nstruct crypto_shash *ieee80211_aes_cmac_key_setup(const u8 key[],\n\t\t\t\t\t\t  size_t key_len)\n{\n\tstruct crypto_shash *tfm;\n\n\ttfm = crypto_alloc_shash(\"cmac(aes)\", 0, 0);\n\tif (!IS_ERR(tfm)) {\n\t\tint err = crypto_shash_setkey(tfm, key, key_len);\n\n\t\tif (err) {\n\t\t\tcrypto_free_shash(tfm);\n\t\t\treturn ERR_PTR(err);\n\t\t}\n\t}\n\n\treturn tfm;\n}\n\nvoid ieee80211_aes_cmac_key_free(struct crypto_shash *tfm)\n{\n\tcrypto_free_shash(tfm);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}