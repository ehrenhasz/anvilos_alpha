{
  "module_name": "ethtool.c",
  "hash_id": "3803c5e7e73c36cdcb4946f18fa3ff33585a96bbbe8e6ebcebb1e36c8e990353",
  "original_prompt": "Ingested from linux-6.6.14/net/mac80211/ethtool.c",
  "human_readable_source": "\n \n#include <linux/types.h>\n#include <net/cfg80211.h>\n#include \"ieee80211_i.h\"\n#include \"sta_info.h\"\n#include \"driver-ops.h\"\n\nstatic int ieee80211_set_ringparam(struct net_device *dev,\n\t\t\t\t   struct ethtool_ringparam *rp,\n\t\t\t\t   struct kernel_ethtool_ringparam *kernel_rp,\n\t\t\t\t   struct netlink_ext_ack *extack)\n{\n\tstruct ieee80211_local *local = wiphy_priv(dev->ieee80211_ptr->wiphy);\n\n\tif (rp->rx_mini_pending != 0 || rp->rx_jumbo_pending != 0)\n\t\treturn -EINVAL;\n\n\treturn drv_set_ringparam(local, rp->tx_pending, rp->rx_pending);\n}\n\nstatic void ieee80211_get_ringparam(struct net_device *dev,\n\t\t\t\t    struct ethtool_ringparam *rp,\n\t\t\t\t    struct kernel_ethtool_ringparam *kernel_rp,\n\t\t\t\t    struct netlink_ext_ack *extack)\n{\n\tstruct ieee80211_local *local = wiphy_priv(dev->ieee80211_ptr->wiphy);\n\n\tmemset(rp, 0, sizeof(*rp));\n\n\tdrv_get_ringparam(local, &rp->tx_pending, &rp->tx_max_pending,\n\t\t\t  &rp->rx_pending, &rp->rx_max_pending);\n}\n\nstatic const char ieee80211_gstrings_sta_stats[][ETH_GSTRING_LEN] = {\n\t\"rx_packets\", \"rx_bytes\",\n\t\"rx_duplicates\", \"rx_fragments\", \"rx_dropped\",\n\t\"tx_packets\", \"tx_bytes\",\n\t\"tx_filtered\", \"tx_retry_failed\", \"tx_retries\",\n\t\"sta_state\", \"txrate\", \"rxrate\", \"signal\",\n\t\"channel\", \"noise\", \"ch_time\", \"ch_time_busy\",\n\t\"ch_time_ext_busy\", \"ch_time_rx\", \"ch_time_tx\"\n};\n#define STA_STATS_LEN\tARRAY_SIZE(ieee80211_gstrings_sta_stats)\n\nstatic int ieee80211_get_sset_count(struct net_device *dev, int sset)\n{\n\tstruct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);\n\tint rv = 0;\n\n\tif (sset == ETH_SS_STATS)\n\t\trv += STA_STATS_LEN;\n\n\trv += drv_get_et_sset_count(sdata, sset);\n\n\tif (rv == 0)\n\t\treturn -EOPNOTSUPP;\n\treturn rv;\n}\n\nstatic void ieee80211_get_stats(struct net_device *dev,\n\t\t\t\tstruct ethtool_stats *stats,\n\t\t\t\tu64 *data)\n{\n\tstruct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);\n\tstruct ieee80211_chanctx_conf *chanctx_conf;\n\tstruct ieee80211_channel *channel;\n\tstruct sta_info *sta;\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct station_info sinfo;\n\tstruct survey_info survey;\n\tint i, q;\n#define STA_STATS_SURVEY_LEN 7\n\n\tmemset(data, 0, sizeof(u64) * STA_STATS_LEN);\n\n#define ADD_STA_STATS(sta)\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\\\n\t\tdata[i++] += sinfo.rx_packets;\t\t\t\\\n\t\tdata[i++] += sinfo.rx_bytes;\t\t\t\\\n\t\tdata[i++] += (sta)->rx_stats.num_duplicates;\t\\\n\t\tdata[i++] += (sta)->rx_stats.fragments;\t\t\\\n\t\tdata[i++] += sinfo.rx_dropped_misc;\t\t\\\n\t\t\t\t\t\t\t\t\\\n\t\tdata[i++] += sinfo.tx_packets;\t\t\t\\\n\t\tdata[i++] += sinfo.tx_bytes;\t\t\t\\\n\t\tdata[i++] += (sta)->status_stats.filtered;\t\\\n\t\tdata[i++] += sinfo.tx_failed;\t\t\t\\\n\t\tdata[i++] += sinfo.tx_retries;\t\t\t\\\n\t} while (0)\n\n\t \n\n\tmutex_lock(&local->sta_mtx);\n\n\tif (sdata->vif.type == NL80211_IFTYPE_STATION) {\n\t\tsta = sta_info_get_bss(sdata, sdata->deflink.u.mgd.bssid);\n\n\t\tif (!(sta && !WARN_ON(sta->sdata->dev != dev)))\n\t\t\tgoto do_survey;\n\n\t\tmemset(&sinfo, 0, sizeof(sinfo));\n\t\tsta_set_sinfo(sta, &sinfo, false);\n\n\t\ti = 0;\n\t\tADD_STA_STATS(&sta->deflink);\n\n\t\tdata[i++] = sta->sta_state;\n\n\n\t\tif (sinfo.filled & BIT_ULL(NL80211_STA_INFO_TX_BITRATE))\n\t\t\tdata[i] = 100000ULL *\n\t\t\t\tcfg80211_calculate_bitrate(&sinfo.txrate);\n\t\ti++;\n\t\tif (sinfo.filled & BIT_ULL(NL80211_STA_INFO_RX_BITRATE))\n\t\t\tdata[i] = 100000ULL *\n\t\t\t\tcfg80211_calculate_bitrate(&sinfo.rxrate);\n\t\ti++;\n\n\t\tif (sinfo.filled & BIT_ULL(NL80211_STA_INFO_SIGNAL_AVG))\n\t\t\tdata[i] = (u8)sinfo.signal_avg;\n\t\ti++;\n\t} else {\n\t\tlist_for_each_entry(sta, &local->sta_list, list) {\n\t\t\t \n\t\t\tif (sta->sdata->dev != dev)\n\t\t\t\tcontinue;\n\n\t\t\tmemset(&sinfo, 0, sizeof(sinfo));\n\t\t\tsta_set_sinfo(sta, &sinfo, false);\n\t\t\ti = 0;\n\t\t\tADD_STA_STATS(&sta->deflink);\n\t\t}\n\t}\n\ndo_survey:\n\ti = STA_STATS_LEN - STA_STATS_SURVEY_LEN;\n\t \n\tsurvey.filled = 0;\n\n\trcu_read_lock();\n\tchanctx_conf = rcu_dereference(sdata->vif.bss_conf.chanctx_conf);\n\tif (chanctx_conf)\n\t\tchannel = chanctx_conf->def.chan;\n\telse\n\t\tchannel = NULL;\n\trcu_read_unlock();\n\n\tif (channel) {\n\t\tq = 0;\n\t\tdo {\n\t\t\tsurvey.filled = 0;\n\t\t\tif (drv_get_survey(local, q, &survey) != 0) {\n\t\t\t\tsurvey.filled = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tq++;\n\t\t} while (channel != survey.channel);\n\t}\n\n\tif (survey.filled)\n\t\tdata[i++] = survey.channel->center_freq;\n\telse\n\t\tdata[i++] = 0;\n\tif (survey.filled & SURVEY_INFO_NOISE_DBM)\n\t\tdata[i++] = (u8)survey.noise;\n\telse\n\t\tdata[i++] = -1LL;\n\tif (survey.filled & SURVEY_INFO_TIME)\n\t\tdata[i++] = survey.time;\n\telse\n\t\tdata[i++] = -1LL;\n\tif (survey.filled & SURVEY_INFO_TIME_BUSY)\n\t\tdata[i++] = survey.time_busy;\n\telse\n\t\tdata[i++] = -1LL;\n\tif (survey.filled & SURVEY_INFO_TIME_EXT_BUSY)\n\t\tdata[i++] = survey.time_ext_busy;\n\telse\n\t\tdata[i++] = -1LL;\n\tif (survey.filled & SURVEY_INFO_TIME_RX)\n\t\tdata[i++] = survey.time_rx;\n\telse\n\t\tdata[i++] = -1LL;\n\tif (survey.filled & SURVEY_INFO_TIME_TX)\n\t\tdata[i++] = survey.time_tx;\n\telse\n\t\tdata[i++] = -1LL;\n\n\tmutex_unlock(&local->sta_mtx);\n\n\tif (WARN_ON(i != STA_STATS_LEN))\n\t\treturn;\n\n\tdrv_get_et_stats(sdata, stats, &(data[STA_STATS_LEN]));\n}\n\nstatic void ieee80211_get_strings(struct net_device *dev, u32 sset, u8 *data)\n{\n\tstruct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);\n\tint sz_sta_stats = 0;\n\n\tif (sset == ETH_SS_STATS) {\n\t\tsz_sta_stats = sizeof(ieee80211_gstrings_sta_stats);\n\t\tmemcpy(data, ieee80211_gstrings_sta_stats, sz_sta_stats);\n\t}\n\tdrv_get_et_strings(sdata, sset, &(data[sz_sta_stats]));\n}\n\nstatic int ieee80211_get_regs_len(struct net_device *dev)\n{\n\treturn 0;\n}\n\nstatic void ieee80211_get_regs(struct net_device *dev,\n\t\t\t       struct ethtool_regs *regs,\n\t\t\t       void *data)\n{\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\n\tregs->version = wdev->wiphy->hw_version;\n\tregs->len = 0;\n}\n\nconst struct ethtool_ops ieee80211_ethtool_ops = {\n\t.get_drvinfo = cfg80211_get_drvinfo,\n\t.get_regs_len = ieee80211_get_regs_len,\n\t.get_regs = ieee80211_get_regs,\n\t.get_link = ethtool_op_get_link,\n\t.get_ringparam = ieee80211_get_ringparam,\n\t.set_ringparam = ieee80211_set_ringparam,\n\t.get_strings = ieee80211_get_strings,\n\t.get_ethtool_stats = ieee80211_get_stats,\n\t.get_sset_count = ieee80211_get_sset_count,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}