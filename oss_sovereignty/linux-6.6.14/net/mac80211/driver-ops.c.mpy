{
  "module_name": "driver-ops.c",
  "hash_id": "3859c31a46c7836eedfa5a0d72d762d042dcce6b0cbd73fe9c4d6d90806ce90c",
  "original_prompt": "Ingested from linux-6.6.14/net/mac80211/driver-ops.c",
  "human_readable_source": "\n \n#include <net/mac80211.h>\n#include \"ieee80211_i.h\"\n#include \"trace.h\"\n#include \"driver-ops.h\"\n#include \"debugfs_sta.h\"\n#include \"debugfs_netdev.h\"\n\nint drv_start(struct ieee80211_local *local)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tif (WARN_ON(local->started))\n\t\treturn -EALREADY;\n\n\ttrace_drv_start(local);\n\tlocal->started = true;\n\t \n\tsmp_mb();\n\tret = local->ops->start(&local->hw);\n\ttrace_drv_return_int(local, ret);\n\n\tif (ret)\n\t\tlocal->started = false;\n\n\treturn ret;\n}\n\nvoid drv_stop(struct ieee80211_local *local)\n{\n\tmight_sleep();\n\n\tif (WARN_ON(!local->started))\n\t\treturn;\n\n\ttrace_drv_stop(local);\n\tlocal->ops->stop(&local->hw);\n\ttrace_drv_return_void(local);\n\n\t \n\ttasklet_disable(&local->tasklet);\n\ttasklet_enable(&local->tasklet);\n\n\tbarrier();\n\n\tlocal->started = false;\n}\n\nint drv_add_interface(struct ieee80211_local *local,\n\t\t      struct ieee80211_sub_if_data *sdata)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tif (WARN_ON(sdata->vif.type == NL80211_IFTYPE_AP_VLAN ||\n\t\t    (sdata->vif.type == NL80211_IFTYPE_MONITOR &&\n\t\t     !ieee80211_hw_check(&local->hw, WANT_MONITOR_VIF) &&\n\t\t     !(sdata->u.mntr.flags & MONITOR_FLAG_ACTIVE))))\n\t\treturn -EINVAL;\n\n\ttrace_drv_add_interface(local, sdata);\n\tret = local->ops->add_interface(&local->hw, &sdata->vif);\n\ttrace_drv_return_int(local, ret);\n\n\tif (ret == 0)\n\t\tsdata->flags |= IEEE80211_SDATA_IN_DRIVER;\n\n\treturn ret;\n}\n\nint drv_change_interface(struct ieee80211_local *local,\n\t\t\t struct ieee80211_sub_if_data *sdata,\n\t\t\t enum nl80211_iftype type, bool p2p)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tif (!check_sdata_in_driver(sdata))\n\t\treturn -EIO;\n\n\ttrace_drv_change_interface(local, sdata, type, p2p);\n\tret = local->ops->change_interface(&local->hw, &sdata->vif, type, p2p);\n\ttrace_drv_return_int(local, ret);\n\treturn ret;\n}\n\nvoid drv_remove_interface(struct ieee80211_local *local,\n\t\t\t  struct ieee80211_sub_if_data *sdata)\n{\n\tmight_sleep();\n\n\tif (!check_sdata_in_driver(sdata))\n\t\treturn;\n\n\ttrace_drv_remove_interface(local, sdata);\n\tlocal->ops->remove_interface(&local->hw, &sdata->vif);\n\tsdata->flags &= ~IEEE80211_SDATA_IN_DRIVER;\n\ttrace_drv_return_void(local);\n}\n\n__must_check\nint drv_sta_state(struct ieee80211_local *local,\n\t\t  struct ieee80211_sub_if_data *sdata,\n\t\t  struct sta_info *sta,\n\t\t  enum ieee80211_sta_state old_state,\n\t\t  enum ieee80211_sta_state new_state)\n{\n\tint ret = 0;\n\n\tmight_sleep();\n\n\tsdata = get_bss_sdata(sdata);\n\tif (!check_sdata_in_driver(sdata))\n\t\treturn -EIO;\n\n\ttrace_drv_sta_state(local, sdata, &sta->sta, old_state, new_state);\n\tif (local->ops->sta_state) {\n\t\tret = local->ops->sta_state(&local->hw, &sdata->vif, &sta->sta,\n\t\t\t\t\t    old_state, new_state);\n\t} else if (old_state == IEEE80211_STA_AUTH &&\n\t\t   new_state == IEEE80211_STA_ASSOC) {\n\t\tret = drv_sta_add(local, sdata, &sta->sta);\n\t\tif (ret == 0) {\n\t\t\tsta->uploaded = true;\n\t\t\tif (rcu_access_pointer(sta->sta.rates))\n\t\t\t\tdrv_sta_rate_tbl_update(local, sdata, &sta->sta);\n\t\t}\n\t} else if (old_state == IEEE80211_STA_ASSOC &&\n\t\t   new_state == IEEE80211_STA_AUTH) {\n\t\tdrv_sta_remove(local, sdata, &sta->sta);\n\t}\n\ttrace_drv_return_int(local, ret);\n\treturn ret;\n}\n\n__must_check\nint drv_sta_set_txpwr(struct ieee80211_local *local,\n\t\t      struct ieee80211_sub_if_data *sdata,\n\t\t      struct sta_info *sta)\n{\n\tint ret = -EOPNOTSUPP;\n\n\tmight_sleep();\n\n\tsdata = get_bss_sdata(sdata);\n\tif (!check_sdata_in_driver(sdata))\n\t\treturn -EIO;\n\n\ttrace_drv_sta_set_txpwr(local, sdata, &sta->sta);\n\tif (local->ops->sta_set_txpwr)\n\t\tret = local->ops->sta_set_txpwr(&local->hw, &sdata->vif,\n\t\t\t\t\t\t&sta->sta);\n\ttrace_drv_return_int(local, ret);\n\treturn ret;\n}\n\nvoid drv_sta_rc_update(struct ieee80211_local *local,\n\t\t       struct ieee80211_sub_if_data *sdata,\n\t\t       struct ieee80211_sta *sta, u32 changed)\n{\n\tsdata = get_bss_sdata(sdata);\n\tif (!check_sdata_in_driver(sdata))\n\t\treturn;\n\n\tWARN_ON(changed & IEEE80211_RC_SUPP_RATES_CHANGED &&\n\t\t(sdata->vif.type != NL80211_IFTYPE_ADHOC &&\n\t\t sdata->vif.type != NL80211_IFTYPE_MESH_POINT));\n\n\ttrace_drv_sta_rc_update(local, sdata, sta, changed);\n\tif (local->ops->sta_rc_update)\n\t\tlocal->ops->sta_rc_update(&local->hw, &sdata->vif,\n\t\t\t\t\t  sta, changed);\n\n\ttrace_drv_return_void(local);\n}\n\nint drv_conf_tx(struct ieee80211_local *local,\n\t\tstruct ieee80211_link_data *link, u16 ac,\n\t\tconst struct ieee80211_tx_queue_params *params)\n{\n\tstruct ieee80211_sub_if_data *sdata = link->sdata;\n\tint ret = -EOPNOTSUPP;\n\n\tmight_sleep();\n\n\tif (!check_sdata_in_driver(sdata))\n\t\treturn -EIO;\n\n\tif (sdata->vif.active_links &&\n\t    !(sdata->vif.active_links & BIT(link->link_id)))\n\t\treturn 0;\n\n\tif (params->cw_min == 0 || params->cw_min > params->cw_max) {\n\t\t \n\t\tWARN_ONCE(local->ops->conf_tx,\n\t\t\t  \"%s: invalid CW_min/CW_max: %d/%d\\n\",\n\t\t\t  sdata->name, params->cw_min, params->cw_max);\n\t\treturn -EINVAL;\n\t}\n\n\ttrace_drv_conf_tx(local, sdata, link->link_id, ac, params);\n\tif (local->ops->conf_tx)\n\t\tret = local->ops->conf_tx(&local->hw, &sdata->vif,\n\t\t\t\t\t  link->link_id, ac, params);\n\ttrace_drv_return_int(local, ret);\n\treturn ret;\n}\n\nu64 drv_get_tsf(struct ieee80211_local *local,\n\t\tstruct ieee80211_sub_if_data *sdata)\n{\n\tu64 ret = -1ULL;\n\n\tmight_sleep();\n\n\tif (!check_sdata_in_driver(sdata))\n\t\treturn ret;\n\n\ttrace_drv_get_tsf(local, sdata);\n\tif (local->ops->get_tsf)\n\t\tret = local->ops->get_tsf(&local->hw, &sdata->vif);\n\ttrace_drv_return_u64(local, ret);\n\treturn ret;\n}\n\nvoid drv_set_tsf(struct ieee80211_local *local,\n\t\t struct ieee80211_sub_if_data *sdata,\n\t\t u64 tsf)\n{\n\tmight_sleep();\n\n\tif (!check_sdata_in_driver(sdata))\n\t\treturn;\n\n\ttrace_drv_set_tsf(local, sdata, tsf);\n\tif (local->ops->set_tsf)\n\t\tlocal->ops->set_tsf(&local->hw, &sdata->vif, tsf);\n\ttrace_drv_return_void(local);\n}\n\nvoid drv_offset_tsf(struct ieee80211_local *local,\n\t\t    struct ieee80211_sub_if_data *sdata,\n\t\t    s64 offset)\n{\n\tmight_sleep();\n\n\tif (!check_sdata_in_driver(sdata))\n\t\treturn;\n\n\ttrace_drv_offset_tsf(local, sdata, offset);\n\tif (local->ops->offset_tsf)\n\t\tlocal->ops->offset_tsf(&local->hw, &sdata->vif, offset);\n\ttrace_drv_return_void(local);\n}\n\nvoid drv_reset_tsf(struct ieee80211_local *local,\n\t\t   struct ieee80211_sub_if_data *sdata)\n{\n\tmight_sleep();\n\n\tif (!check_sdata_in_driver(sdata))\n\t\treturn;\n\n\ttrace_drv_reset_tsf(local, sdata);\n\tif (local->ops->reset_tsf)\n\t\tlocal->ops->reset_tsf(&local->hw, &sdata->vif);\n\ttrace_drv_return_void(local);\n}\n\nint drv_assign_vif_chanctx(struct ieee80211_local *local,\n\t\t\t   struct ieee80211_sub_if_data *sdata,\n\t\t\t   struct ieee80211_bss_conf *link_conf,\n\t\t\t   struct ieee80211_chanctx *ctx)\n{\n\tint ret = 0;\n\n\tdrv_verify_link_exists(sdata, link_conf);\n\tif (!check_sdata_in_driver(sdata))\n\t\treturn -EIO;\n\n\tif (sdata->vif.active_links &&\n\t    !(sdata->vif.active_links & BIT(link_conf->link_id)))\n\t\treturn 0;\n\n\ttrace_drv_assign_vif_chanctx(local, sdata, link_conf, ctx);\n\tif (local->ops->assign_vif_chanctx) {\n\t\tWARN_ON_ONCE(!ctx->driver_present);\n\t\tret = local->ops->assign_vif_chanctx(&local->hw,\n\t\t\t\t\t\t     &sdata->vif,\n\t\t\t\t\t\t     link_conf,\n\t\t\t\t\t\t     &ctx->conf);\n\t}\n\ttrace_drv_return_int(local, ret);\n\n\treturn ret;\n}\n\nvoid drv_unassign_vif_chanctx(struct ieee80211_local *local,\n\t\t\t      struct ieee80211_sub_if_data *sdata,\n\t\t\t      struct ieee80211_bss_conf *link_conf,\n\t\t\t      struct ieee80211_chanctx *ctx)\n{\n\tmight_sleep();\n\n\tdrv_verify_link_exists(sdata, link_conf);\n\tif (!check_sdata_in_driver(sdata))\n\t\treturn;\n\n\tif (sdata->vif.active_links &&\n\t    !(sdata->vif.active_links & BIT(link_conf->link_id)))\n\t\treturn;\n\n\ttrace_drv_unassign_vif_chanctx(local, sdata, link_conf, ctx);\n\tif (local->ops->unassign_vif_chanctx) {\n\t\tWARN_ON_ONCE(!ctx->driver_present);\n\t\tlocal->ops->unassign_vif_chanctx(&local->hw,\n\t\t\t\t\t\t &sdata->vif,\n\t\t\t\t\t\t link_conf,\n\t\t\t\t\t\t &ctx->conf);\n\t}\n\ttrace_drv_return_void(local);\n}\n\nint drv_switch_vif_chanctx(struct ieee80211_local *local,\n\t\t\t   struct ieee80211_vif_chanctx_switch *vifs,\n\t\t\t   int n_vifs, enum ieee80211_chanctx_switch_mode mode)\n{\n\tint ret = 0;\n\tint i;\n\n\tmight_sleep();\n\n\tif (!local->ops->switch_vif_chanctx)\n\t\treturn -EOPNOTSUPP;\n\n\tfor (i = 0; i < n_vifs; i++) {\n\t\tstruct ieee80211_chanctx *new_ctx =\n\t\t\tcontainer_of(vifs[i].new_ctx,\n\t\t\t\t     struct ieee80211_chanctx,\n\t\t\t\t     conf);\n\t\tstruct ieee80211_chanctx *old_ctx =\n\t\t\tcontainer_of(vifs[i].old_ctx,\n\t\t\t\t     struct ieee80211_chanctx,\n\t\t\t\t     conf);\n\n\t\tWARN_ON_ONCE(!old_ctx->driver_present);\n\t\tWARN_ON_ONCE((mode == CHANCTX_SWMODE_SWAP_CONTEXTS &&\n\t\t\t      new_ctx->driver_present) ||\n\t\t\t     (mode == CHANCTX_SWMODE_REASSIGN_VIF &&\n\t\t\t      !new_ctx->driver_present));\n\t}\n\n\ttrace_drv_switch_vif_chanctx(local, vifs, n_vifs, mode);\n\tret = local->ops->switch_vif_chanctx(&local->hw,\n\t\t\t\t\t     vifs, n_vifs, mode);\n\ttrace_drv_return_int(local, ret);\n\n\tif (!ret && mode == CHANCTX_SWMODE_SWAP_CONTEXTS) {\n\t\tfor (i = 0; i < n_vifs; i++) {\n\t\t\tstruct ieee80211_chanctx *new_ctx =\n\t\t\t\tcontainer_of(vifs[i].new_ctx,\n\t\t\t\t\t     struct ieee80211_chanctx,\n\t\t\t\t\t     conf);\n\t\t\tstruct ieee80211_chanctx *old_ctx =\n\t\t\t\tcontainer_of(vifs[i].old_ctx,\n\t\t\t\t\t     struct ieee80211_chanctx,\n\t\t\t\t\t     conf);\n\n\t\t\tnew_ctx->driver_present = true;\n\t\t\told_ctx->driver_present = false;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nint drv_ampdu_action(struct ieee80211_local *local,\n\t\t     struct ieee80211_sub_if_data *sdata,\n\t\t     struct ieee80211_ampdu_params *params)\n{\n\tint ret = -EOPNOTSUPP;\n\n\tmight_sleep();\n\n\tif (!sdata)\n\t\treturn -EIO;\n\n\tsdata = get_bss_sdata(sdata);\n\tif (!check_sdata_in_driver(sdata))\n\t\treturn -EIO;\n\n\ttrace_drv_ampdu_action(local, sdata, params);\n\n\tif (local->ops->ampdu_action)\n\t\tret = local->ops->ampdu_action(&local->hw, &sdata->vif, params);\n\n\ttrace_drv_return_int(local, ret);\n\n\treturn ret;\n}\n\nvoid drv_link_info_changed(struct ieee80211_local *local,\n\t\t\t   struct ieee80211_sub_if_data *sdata,\n\t\t\t   struct ieee80211_bss_conf *info,\n\t\t\t   int link_id, u64 changed)\n{\n\tmight_sleep();\n\n\tif (WARN_ON_ONCE(changed & (BSS_CHANGED_BEACON |\n\t\t\t\t    BSS_CHANGED_BEACON_ENABLED) &&\n\t\t\t sdata->vif.type != NL80211_IFTYPE_AP &&\n\t\t\t sdata->vif.type != NL80211_IFTYPE_ADHOC &&\n\t\t\t sdata->vif.type != NL80211_IFTYPE_MESH_POINT &&\n\t\t\t sdata->vif.type != NL80211_IFTYPE_OCB))\n\t\treturn;\n\n\tif (WARN_ON_ONCE(sdata->vif.type == NL80211_IFTYPE_P2P_DEVICE ||\n\t\t\t sdata->vif.type == NL80211_IFTYPE_NAN ||\n\t\t\t (sdata->vif.type == NL80211_IFTYPE_MONITOR &&\n\t\t\t  !sdata->vif.bss_conf.mu_mimo_owner &&\n\t\t\t  !(changed & BSS_CHANGED_TXPOWER))))\n\t\treturn;\n\n\tif (!check_sdata_in_driver(sdata))\n\t\treturn;\n\n\tif (sdata->vif.active_links &&\n\t    !(sdata->vif.active_links & BIT(link_id)))\n\t\treturn;\n\n\ttrace_drv_link_info_changed(local, sdata, info, changed);\n\tif (local->ops->link_info_changed)\n\t\tlocal->ops->link_info_changed(&local->hw, &sdata->vif,\n\t\t\t\t\t      info, changed);\n\telse if (local->ops->bss_info_changed)\n\t\tlocal->ops->bss_info_changed(&local->hw, &sdata->vif,\n\t\t\t\t\t     info, changed);\n\ttrace_drv_return_void(local);\n}\n\nint drv_set_key(struct ieee80211_local *local,\n\t\tenum set_key_cmd cmd,\n\t\tstruct ieee80211_sub_if_data *sdata,\n\t\tstruct ieee80211_sta *sta,\n\t\tstruct ieee80211_key_conf *key)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tsdata = get_bss_sdata(sdata);\n\tif (!check_sdata_in_driver(sdata))\n\t\treturn -EIO;\n\n\tif (WARN_ON(key->link_id >= 0 && sdata->vif.active_links &&\n\t\t    !(sdata->vif.active_links & BIT(key->link_id))))\n\t\treturn -ENOLINK;\n\n\ttrace_drv_set_key(local, cmd, sdata, sta, key);\n\tret = local->ops->set_key(&local->hw, cmd, &sdata->vif, sta, key);\n\ttrace_drv_return_int(local, ret);\n\treturn ret;\n}\n\nint drv_change_vif_links(struct ieee80211_local *local,\n\t\t\t struct ieee80211_sub_if_data *sdata,\n\t\t\t u16 old_links, u16 new_links,\n\t\t\t struct ieee80211_bss_conf *old[IEEE80211_MLD_MAX_NUM_LINKS])\n{\n\tstruct ieee80211_link_data *link;\n\tunsigned long links_to_add;\n\tunsigned long links_to_rem;\n\tunsigned int link_id;\n\tint ret = -EOPNOTSUPP;\n\n\tmight_sleep();\n\n\tif (!check_sdata_in_driver(sdata))\n\t\treturn -EIO;\n\n\tif (old_links == new_links)\n\t\treturn 0;\n\n\tlinks_to_add = ~old_links & new_links;\n\tlinks_to_rem = old_links & ~new_links;\n\n\tfor_each_set_bit(link_id, &links_to_rem, IEEE80211_MLD_MAX_NUM_LINKS) {\n\t\tlink = rcu_access_pointer(sdata->link[link_id]);\n\n\t\tieee80211_link_debugfs_drv_remove(link);\n\t}\n\n\ttrace_drv_change_vif_links(local, sdata, old_links, new_links);\n\tif (local->ops->change_vif_links)\n\t\tret = local->ops->change_vif_links(&local->hw, &sdata->vif,\n\t\t\t\t\t\t   old_links, new_links, old);\n\ttrace_drv_return_int(local, ret);\n\n\tif (ret)\n\t\treturn ret;\n\n\tif (!local->in_reconfig) {\n\t\tfor_each_set_bit(link_id, &links_to_add,\n\t\t\t\t IEEE80211_MLD_MAX_NUM_LINKS) {\n\t\t\tlink = rcu_access_pointer(sdata->link[link_id]);\n\n\t\t\tieee80211_link_debugfs_drv_add(link);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint drv_change_sta_links(struct ieee80211_local *local,\n\t\t\t struct ieee80211_sub_if_data *sdata,\n\t\t\t struct ieee80211_sta *sta,\n\t\t\t u16 old_links, u16 new_links)\n{\n\tstruct sta_info *info = container_of(sta, struct sta_info, sta);\n\tstruct link_sta_info *link_sta;\n\tunsigned long links_to_add;\n\tunsigned long links_to_rem;\n\tunsigned int link_id;\n\tint ret = -EOPNOTSUPP;\n\n\tmight_sleep();\n\n\tif (!check_sdata_in_driver(sdata))\n\t\treturn -EIO;\n\n\told_links &= sdata->vif.active_links;\n\tnew_links &= sdata->vif.active_links;\n\n\tif (old_links == new_links)\n\t\treturn 0;\n\n\tlinks_to_add = ~old_links & new_links;\n\tlinks_to_rem = old_links & ~new_links;\n\n\tfor_each_set_bit(link_id, &links_to_rem, IEEE80211_MLD_MAX_NUM_LINKS) {\n\t\tlink_sta = rcu_dereference_protected(info->link[link_id],\n\t\t\t\t\t\t     lockdep_is_held(&local->sta_mtx));\n\n\t\tieee80211_link_sta_debugfs_drv_remove(link_sta);\n\t}\n\n\ttrace_drv_change_sta_links(local, sdata, sta, old_links, new_links);\n\tif (local->ops->change_sta_links)\n\t\tret = local->ops->change_sta_links(&local->hw, &sdata->vif, sta,\n\t\t\t\t\t\t   old_links, new_links);\n\ttrace_drv_return_int(local, ret);\n\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (local->in_reconfig)\n\t\treturn 0;\n\n\tfor_each_set_bit(link_id, &links_to_add, IEEE80211_MLD_MAX_NUM_LINKS) {\n\t\tlink_sta = rcu_dereference_protected(info->link[link_id],\n\t\t\t\t\t\t     lockdep_is_held(&local->sta_mtx));\n\t\tieee80211_link_sta_debugfs_drv_add(link_sta);\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}