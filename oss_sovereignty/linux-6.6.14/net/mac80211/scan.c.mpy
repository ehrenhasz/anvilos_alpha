{
  "module_name": "scan.c",
  "hash_id": "2ed85e24ad90def63bcf4161151de235ee51fe8ad519160f6b8d084a7a5a492c",
  "original_prompt": "Ingested from linux-6.6.14/net/mac80211/scan.c",
  "human_readable_source": "\n \n\n#include <linux/if_arp.h>\n#include <linux/etherdevice.h>\n#include <linux/rtnetlink.h>\n#include <net/sch_generic.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/random.h>\n#include <net/mac80211.h>\n\n#include \"ieee80211_i.h\"\n#include \"driver-ops.h\"\n#include \"mesh.h\"\n\n#define IEEE80211_PROBE_DELAY (HZ / 33)\n#define IEEE80211_CHANNEL_TIME (HZ / 33)\n#define IEEE80211_PASSIVE_CHANNEL_TIME (HZ / 9)\n\nvoid ieee80211_rx_bss_put(struct ieee80211_local *local,\n\t\t\t  struct ieee80211_bss *bss)\n{\n\tif (!bss)\n\t\treturn;\n\tcfg80211_put_bss(local->hw.wiphy,\n\t\t\t container_of((void *)bss, struct cfg80211_bss, priv));\n}\n\nstatic bool is_uapsd_supported(struct ieee802_11_elems *elems)\n{\n\tu8 qos_info;\n\n\tif (elems->wmm_info && elems->wmm_info_len == 7\n\t    && elems->wmm_info[5] == 1)\n\t\tqos_info = elems->wmm_info[6];\n\telse if (elems->wmm_param && elems->wmm_param_len == 24\n\t\t && elems->wmm_param[5] == 1)\n\t\tqos_info = elems->wmm_param[6];\n\telse\n\t\t \n\t\treturn false;\n\n\treturn qos_info & IEEE80211_WMM_IE_AP_QOSINFO_UAPSD;\n}\n\nstruct inform_bss_update_data {\n\tstruct ieee80211_rx_status *rx_status;\n\tbool beacon;\n};\n\nvoid ieee80211_inform_bss(struct wiphy *wiphy,\n\t\t\t  struct cfg80211_bss *cbss,\n\t\t\t  const struct cfg80211_bss_ies *ies,\n\t\t\t  void *data)\n{\n\tstruct ieee80211_local *local = wiphy_priv(wiphy);\n\tstruct inform_bss_update_data *update_data = data;\n\tstruct ieee80211_bss *bss = (void *)cbss->priv;\n\tstruct ieee80211_rx_status *rx_status;\n\tstruct ieee802_11_elems *elems;\n\tint clen, srlen;\n\n\t \n\tif (!update_data)\n\t\treturn;\n\n\telems = ieee802_11_parse_elems(ies->data, ies->len, false, NULL);\n\tif (!elems)\n\t\treturn;\n\n\trx_status = update_data->rx_status;\n\n\tif (update_data->beacon)\n\t\tbss->device_ts_beacon = rx_status->device_timestamp;\n\telse\n\t\tbss->device_ts_presp = rx_status->device_timestamp;\n\n\tif (elems->parse_error) {\n\t\tif (update_data->beacon)\n\t\t\tbss->corrupt_data |= IEEE80211_BSS_CORRUPT_BEACON;\n\t\telse\n\t\t\tbss->corrupt_data |= IEEE80211_BSS_CORRUPT_PROBE_RESP;\n\t} else {\n\t\tif (update_data->beacon)\n\t\t\tbss->corrupt_data &= ~IEEE80211_BSS_CORRUPT_BEACON;\n\t\telse\n\t\t\tbss->corrupt_data &= ~IEEE80211_BSS_CORRUPT_PROBE_RESP;\n\t}\n\n\t \n\tif (elems->erp_info && (!elems->parse_error ||\n\t\t\t\t!(bss->valid_data & IEEE80211_BSS_VALID_ERP))) {\n\t\tbss->erp_value = elems->erp_info[0];\n\t\tbss->has_erp_value = true;\n\t\tif (!elems->parse_error)\n\t\t\tbss->valid_data |= IEEE80211_BSS_VALID_ERP;\n\t}\n\n\t \n\tif (!elems->parse_error ||\n\t    !(bss->valid_data & IEEE80211_BSS_VALID_RATES)) {\n\t\tsrlen = 0;\n\t\tif (elems->supp_rates) {\n\t\t\tclen = IEEE80211_MAX_SUPP_RATES;\n\t\t\tif (clen > elems->supp_rates_len)\n\t\t\t\tclen = elems->supp_rates_len;\n\t\t\tmemcpy(bss->supp_rates, elems->supp_rates, clen);\n\t\t\tsrlen += clen;\n\t\t}\n\t\tif (elems->ext_supp_rates) {\n\t\t\tclen = IEEE80211_MAX_SUPP_RATES - srlen;\n\t\t\tif (clen > elems->ext_supp_rates_len)\n\t\t\t\tclen = elems->ext_supp_rates_len;\n\t\t\tmemcpy(bss->supp_rates + srlen, elems->ext_supp_rates,\n\t\t\t       clen);\n\t\t\tsrlen += clen;\n\t\t}\n\t\tif (srlen) {\n\t\t\tbss->supp_rates_len = srlen;\n\t\t\tif (!elems->parse_error)\n\t\t\t\tbss->valid_data |= IEEE80211_BSS_VALID_RATES;\n\t\t}\n\t}\n\n\tif (!elems->parse_error ||\n\t    !(bss->valid_data & IEEE80211_BSS_VALID_WMM)) {\n\t\tbss->wmm_used = elems->wmm_param || elems->wmm_info;\n\t\tbss->uapsd_supported = is_uapsd_supported(elems);\n\t\tif (!elems->parse_error)\n\t\t\tbss->valid_data |= IEEE80211_BSS_VALID_WMM;\n\t}\n\n\tif (update_data->beacon) {\n\t\tstruct ieee80211_supported_band *sband =\n\t\t\tlocal->hw.wiphy->bands[rx_status->band];\n\t\tif (!(rx_status->encoding == RX_ENC_HT) &&\n\t\t    !(rx_status->encoding == RX_ENC_VHT))\n\t\t\tbss->beacon_rate =\n\t\t\t\t&sband->bitrates[rx_status->rate_idx];\n\t}\n\n\tif (elems->vht_cap_elem)\n\t\tbss->vht_cap_info =\n\t\t\tle32_to_cpu(elems->vht_cap_elem->vht_cap_info);\n\telse\n\t\tbss->vht_cap_info = 0;\n\n\tkfree(elems);\n}\n\nstruct ieee80211_bss *\nieee80211_bss_info_update(struct ieee80211_local *local,\n\t\t\t  struct ieee80211_rx_status *rx_status,\n\t\t\t  struct ieee80211_mgmt *mgmt, size_t len,\n\t\t\t  struct ieee80211_channel *channel)\n{\n\tbool beacon = ieee80211_is_beacon(mgmt->frame_control) ||\n\t\t      ieee80211_is_s1g_beacon(mgmt->frame_control);\n\tstruct cfg80211_bss *cbss;\n\tstruct inform_bss_update_data update_data = {\n\t\t.rx_status = rx_status,\n\t\t.beacon = beacon,\n\t};\n\tstruct cfg80211_inform_bss bss_meta = {\n\t\t.boottime_ns = rx_status->boottime_ns,\n\t\t.drv_data = (void *)&update_data,\n\t};\n\tbool signal_valid;\n\tstruct ieee80211_sub_if_data *scan_sdata;\n\n\tif (rx_status->flag & RX_FLAG_NO_SIGNAL_VAL)\n\t\tbss_meta.signal = 0;  \n\telse if (ieee80211_hw_check(&local->hw, SIGNAL_DBM))\n\t\tbss_meta.signal = rx_status->signal * 100;\n\telse if (ieee80211_hw_check(&local->hw, SIGNAL_UNSPEC))\n\t\tbss_meta.signal = (rx_status->signal * 100) / local->hw.max_signal;\n\n\tbss_meta.scan_width = NL80211_BSS_CHAN_WIDTH_20;\n\tif (rx_status->bw == RATE_INFO_BW_5)\n\t\tbss_meta.scan_width = NL80211_BSS_CHAN_WIDTH_5;\n\telse if (rx_status->bw == RATE_INFO_BW_10)\n\t\tbss_meta.scan_width = NL80211_BSS_CHAN_WIDTH_10;\n\n\tbss_meta.chan = channel;\n\n\trcu_read_lock();\n\tscan_sdata = rcu_dereference(local->scan_sdata);\n\tif (scan_sdata && scan_sdata->vif.type == NL80211_IFTYPE_STATION &&\n\t    scan_sdata->vif.cfg.assoc &&\n\t    ieee80211_have_rx_timestamp(rx_status)) {\n\t\tbss_meta.parent_tsf =\n\t\t\tieee80211_calculate_rx_timestamp(local, rx_status,\n\t\t\t\t\t\t\t len + FCS_LEN, 24);\n\t\tether_addr_copy(bss_meta.parent_bssid,\n\t\t\t\tscan_sdata->vif.bss_conf.bssid);\n\t}\n\trcu_read_unlock();\n\n\tcbss = cfg80211_inform_bss_frame_data(local->hw.wiphy, &bss_meta,\n\t\t\t\t\t      mgmt, len, GFP_ATOMIC);\n\tif (!cbss)\n\t\treturn NULL;\n\n\t \n\tsignal_valid = channel == cbss->channel;\n\tif (!signal_valid)\n\t\trx_status->flag |= RX_FLAG_NO_SIGNAL_VAL;\n\n\treturn (void *)cbss->priv;\n}\n\nstatic bool ieee80211_scan_accept_presp(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t\tu32 scan_flags, const u8 *da)\n{\n\tif (!sdata)\n\t\treturn false;\n\t \n\tif (scan_flags & NL80211_SCAN_FLAG_ACCEPT_BCAST_PROBE_RESP &&\n\t    is_broadcast_ether_addr(da))\n\t\treturn true;\n\tif (scan_flags & NL80211_SCAN_FLAG_RANDOM_ADDR)\n\t\treturn true;\n\treturn ether_addr_equal(da, sdata->vif.addr);\n}\n\nvoid ieee80211_scan_rx(struct ieee80211_local *local, struct sk_buff *skb)\n{\n\tstruct ieee80211_rx_status *rx_status = IEEE80211_SKB_RXCB(skb);\n\tstruct ieee80211_sub_if_data *sdata1, *sdata2;\n\tstruct ieee80211_mgmt *mgmt = (void *)skb->data;\n\tstruct ieee80211_bss *bss;\n\tstruct ieee80211_channel *channel;\n\tsize_t min_hdr_len = offsetof(struct ieee80211_mgmt,\n\t\t\t\t      u.probe_resp.variable);\n\n\tif (!ieee80211_is_probe_resp(mgmt->frame_control) &&\n\t    !ieee80211_is_beacon(mgmt->frame_control) &&\n\t    !ieee80211_is_s1g_beacon(mgmt->frame_control))\n\t\treturn;\n\n\tif (ieee80211_is_s1g_beacon(mgmt->frame_control)) {\n\t\tif (ieee80211_is_s1g_short_beacon(mgmt->frame_control))\n\t\t\tmin_hdr_len = offsetof(struct ieee80211_ext,\n\t\t\t\t\t       u.s1g_short_beacon.variable);\n\t\telse\n\t\t\tmin_hdr_len = offsetof(struct ieee80211_ext,\n\t\t\t\t\t       u.s1g_beacon);\n\t}\n\n\tif (skb->len < min_hdr_len)\n\t\treturn;\n\n\tsdata1 = rcu_dereference(local->scan_sdata);\n\tsdata2 = rcu_dereference(local->sched_scan_sdata);\n\n\tif (likely(!sdata1 && !sdata2))\n\t\treturn;\n\n\tif (test_and_clear_bit(SCAN_BEACON_WAIT, &local->scanning)) {\n\t\t \n\t\tset_bit(SCAN_BEACON_DONE, &local->scanning);\n\t\twiphy_delayed_work_queue(local->hw.wiphy, &local->scan_work, 0);\n\t}\n\n\tif (ieee80211_is_probe_resp(mgmt->frame_control)) {\n\t\tstruct cfg80211_scan_request *scan_req;\n\t\tstruct cfg80211_sched_scan_request *sched_scan_req;\n\t\tu32 scan_req_flags = 0, sched_scan_req_flags = 0;\n\n\t\tscan_req = rcu_dereference(local->scan_req);\n\t\tsched_scan_req = rcu_dereference(local->sched_scan_req);\n\n\t\tif (scan_req)\n\t\t\tscan_req_flags = scan_req->flags;\n\n\t\tif (sched_scan_req)\n\t\t\tsched_scan_req_flags = sched_scan_req->flags;\n\n\t\t \n\t\tif (!ieee80211_scan_accept_presp(sdata1, scan_req_flags,\n\t\t\t\t\t\t mgmt->da) &&\n\t\t    !ieee80211_scan_accept_presp(sdata2, sched_scan_req_flags,\n\t\t\t\t\t\t mgmt->da))\n\t\t\treturn;\n\t}\n\n\tchannel = ieee80211_get_channel_khz(local->hw.wiphy,\n\t\t\t\t\tieee80211_rx_status_to_khz(rx_status));\n\n\tif (!channel || channel->flags & IEEE80211_CHAN_DISABLED)\n\t\treturn;\n\n\tbss = ieee80211_bss_info_update(local, rx_status,\n\t\t\t\t\tmgmt, skb->len,\n\t\t\t\t\tchannel);\n\tif (bss)\n\t\tieee80211_rx_bss_put(local, bss);\n}\n\nstatic void\nieee80211_prepare_scan_chandef(struct cfg80211_chan_def *chandef,\n\t\t\t       enum nl80211_bss_scan_width scan_width)\n{\n\tmemset(chandef, 0, sizeof(*chandef));\n\tswitch (scan_width) {\n\tcase NL80211_BSS_CHAN_WIDTH_5:\n\t\tchandef->width = NL80211_CHAN_WIDTH_5;\n\t\tbreak;\n\tcase NL80211_BSS_CHAN_WIDTH_10:\n\t\tchandef->width = NL80211_CHAN_WIDTH_10;\n\t\tbreak;\n\tdefault:\n\t\tchandef->width = NL80211_CHAN_WIDTH_20_NOHT;\n\t\tbreak;\n\t}\n}\n\n \nstatic bool ieee80211_prep_hw_scan(struct ieee80211_sub_if_data *sdata)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct cfg80211_scan_request *req;\n\tstruct cfg80211_chan_def chandef;\n\tu8 bands_used = 0;\n\tint i, ielen, n_chans;\n\tu32 flags = 0;\n\n\treq = rcu_dereference_protected(local->scan_req,\n\t\t\t\t\tlockdep_is_held(&local->mtx));\n\n\tif (test_bit(SCAN_HW_CANCELLED, &local->scanning))\n\t\treturn false;\n\n\tif (ieee80211_hw_check(&local->hw, SINGLE_SCAN_ON_ALL_BANDS)) {\n\t\tfor (i = 0; i < req->n_channels; i++) {\n\t\t\tlocal->hw_scan_req->req.channels[i] = req->channels[i];\n\t\t\tbands_used |= BIT(req->channels[i]->band);\n\t\t}\n\n\t\tn_chans = req->n_channels;\n\t} else {\n\t\tdo {\n\t\t\tif (local->hw_scan_band == NUM_NL80211_BANDS)\n\t\t\t\treturn false;\n\n\t\t\tn_chans = 0;\n\n\t\t\tfor (i = 0; i < req->n_channels; i++) {\n\t\t\t\tif (req->channels[i]->band !=\n\t\t\t\t    local->hw_scan_band)\n\t\t\t\t\tcontinue;\n\t\t\t\tlocal->hw_scan_req->req.channels[n_chans] =\n\t\t\t\t\t\t\treq->channels[i];\n\t\t\t\tn_chans++;\n\t\t\t\tbands_used |= BIT(req->channels[i]->band);\n\t\t\t}\n\n\t\t\tlocal->hw_scan_band++;\n\t\t} while (!n_chans);\n\t}\n\n\tlocal->hw_scan_req->req.n_channels = n_chans;\n\tieee80211_prepare_scan_chandef(&chandef, req->scan_width);\n\n\tif (req->flags & NL80211_SCAN_FLAG_MIN_PREQ_CONTENT)\n\t\tflags |= IEEE80211_PROBE_FLAG_MIN_CONTENT;\n\n\tielen = ieee80211_build_preq_ies(sdata,\n\t\t\t\t\t (u8 *)local->hw_scan_req->req.ie,\n\t\t\t\t\t local->hw_scan_ies_bufsize,\n\t\t\t\t\t &local->hw_scan_req->ies,\n\t\t\t\t\t req->ie, req->ie_len,\n\t\t\t\t\t bands_used, req->rates, &chandef,\n\t\t\t\t\t flags);\n\tlocal->hw_scan_req->req.ie_len = ielen;\n\tlocal->hw_scan_req->req.no_cck = req->no_cck;\n\tether_addr_copy(local->hw_scan_req->req.mac_addr, req->mac_addr);\n\tether_addr_copy(local->hw_scan_req->req.mac_addr_mask,\n\t\t\treq->mac_addr_mask);\n\tether_addr_copy(local->hw_scan_req->req.bssid, req->bssid);\n\n\treturn true;\n}\n\nstatic void __ieee80211_scan_completed(struct ieee80211_hw *hw, bool aborted)\n{\n\tstruct ieee80211_local *local = hw_to_local(hw);\n\tbool hw_scan = test_bit(SCAN_HW_SCANNING, &local->scanning);\n\tbool was_scanning = local->scanning;\n\tstruct cfg80211_scan_request *scan_req;\n\tstruct ieee80211_sub_if_data *scan_sdata;\n\tstruct ieee80211_sub_if_data *sdata;\n\n\tlockdep_assert_held(&local->mtx);\n\n\t \n\tif (WARN_ON(!local->scanning && !aborted))\n\t\taborted = true;\n\n\tif (WARN_ON(!local->scan_req))\n\t\treturn;\n\n\tscan_sdata = rcu_dereference_protected(local->scan_sdata,\n\t\t\t\t\t       lockdep_is_held(&local->mtx));\n\n\tif (hw_scan && !aborted &&\n\t    !ieee80211_hw_check(&local->hw, SINGLE_SCAN_ON_ALL_BANDS) &&\n\t    ieee80211_prep_hw_scan(scan_sdata)) {\n\t\tint rc;\n\n\t\trc = drv_hw_scan(local,\n\t\t\trcu_dereference_protected(local->scan_sdata,\n\t\t\t\t\t\t  lockdep_is_held(&local->mtx)),\n\t\t\tlocal->hw_scan_req);\n\n\t\tif (rc == 0)\n\t\t\treturn;\n\n\t\t \n\t\tmemset(&local->scan_info, 0, sizeof(local->scan_info));\n\t\taborted = true;\n\t}\n\n\tkfree(local->hw_scan_req);\n\tlocal->hw_scan_req = NULL;\n\n\tscan_req = rcu_dereference_protected(local->scan_req,\n\t\t\t\t\t     lockdep_is_held(&local->mtx));\n\n\tRCU_INIT_POINTER(local->scan_req, NULL);\n\tRCU_INIT_POINTER(local->scan_sdata, NULL);\n\n\tlocal->scanning = 0;\n\tlocal->scan_chandef.chan = NULL;\n\n\tsynchronize_rcu();\n\n\tif (scan_req != local->int_scan_req) {\n\t\tlocal->scan_info.aborted = aborted;\n\t\tcfg80211_scan_done(scan_req, &local->scan_info);\n\t}\n\n\t \n\tieee80211_hw_config(local, 0);\n\n\tif (!hw_scan && was_scanning) {\n\t\tieee80211_configure_filter(local);\n\t\tdrv_sw_scan_complete(local, scan_sdata);\n\t\tieee80211_offchannel_return(local);\n\t}\n\n\tieee80211_recalc_idle(local);\n\n\tieee80211_mlme_notify_scan_completed(local);\n\tieee80211_ibss_notify_scan_completed(local);\n\n\t \n\tlist_for_each_entry_rcu(sdata, &local->interfaces, list) {\n\t\tif (ieee80211_sdata_running(sdata))\n\t\t\twiphy_work_queue(sdata->local->hw.wiphy, &sdata->work);\n\t}\n\n\tif (was_scanning)\n\t\tieee80211_start_next_roc(local);\n}\n\nvoid ieee80211_scan_completed(struct ieee80211_hw *hw,\n\t\t\t      struct cfg80211_scan_info *info)\n{\n\tstruct ieee80211_local *local = hw_to_local(hw);\n\n\ttrace_api_scan_completed(local, info->aborted);\n\n\tset_bit(SCAN_COMPLETED, &local->scanning);\n\tif (info->aborted)\n\t\tset_bit(SCAN_ABORTED, &local->scanning);\n\n\tmemcpy(&local->scan_info, info, sizeof(*info));\n\n\twiphy_delayed_work_queue(local->hw.wiphy, &local->scan_work, 0);\n}\nEXPORT_SYMBOL(ieee80211_scan_completed);\n\nstatic int ieee80211_start_sw_scan(struct ieee80211_local *local,\n\t\t\t\t   struct ieee80211_sub_if_data *sdata)\n{\n\t \n\tif (local->use_chanctx)\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tdrv_sw_scan_start(local, sdata, local->scan_addr);\n\n\tlocal->leave_oper_channel_time = jiffies;\n\tlocal->next_scan_state = SCAN_DECISION;\n\tlocal->scan_channel_idx = 0;\n\n\tieee80211_offchannel_stop_vifs(local);\n\n\t \n\tieee80211_flush_queues(local, NULL, false);\n\n\tieee80211_configure_filter(local);\n\n\t \n\tieee80211_hw_config(local, 0);\n\n\twiphy_delayed_work_queue(local->hw.wiphy, &local->scan_work, 0);\n\n\treturn 0;\n}\n\nstatic bool __ieee80211_can_leave_ch(struct ieee80211_sub_if_data *sdata)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct ieee80211_sub_if_data *sdata_iter;\n\n\tif (!ieee80211_is_radar_required(local))\n\t\treturn true;\n\n\tif (!regulatory_pre_cac_allowed(local->hw.wiphy))\n\t\treturn false;\n\n\tmutex_lock(&local->iflist_mtx);\n\tlist_for_each_entry(sdata_iter, &local->interfaces, list) {\n\t\tif (sdata_iter->wdev.cac_started) {\n\t\t\tmutex_unlock(&local->iflist_mtx);\n\t\t\treturn false;\n\t\t}\n\t}\n\tmutex_unlock(&local->iflist_mtx);\n\n\treturn true;\n}\n\nstatic bool ieee80211_can_scan(struct ieee80211_local *local,\n\t\t\t       struct ieee80211_sub_if_data *sdata)\n{\n\tif (!__ieee80211_can_leave_ch(sdata))\n\t\treturn false;\n\n\tif (!list_empty(&local->roc_list))\n\t\treturn false;\n\n\tif (sdata->vif.type == NL80211_IFTYPE_STATION &&\n\t    sdata->u.mgd.flags & IEEE80211_STA_CONNECTION_POLL)\n\t\treturn false;\n\n\treturn true;\n}\n\nvoid ieee80211_run_deferred_scan(struct ieee80211_local *local)\n{\n\tlockdep_assert_held(&local->mtx);\n\n\tif (!local->scan_req || local->scanning)\n\t\treturn;\n\n\tif (!ieee80211_can_scan(local,\n\t\t\t\trcu_dereference_protected(\n\t\t\t\t\tlocal->scan_sdata,\n\t\t\t\t\tlockdep_is_held(&local->mtx))))\n\t\treturn;\n\n\twiphy_delayed_work_queue(local->hw.wiphy, &local->scan_work,\n\t\t\t\t round_jiffies_relative(0));\n}\n\nstatic void ieee80211_send_scan_probe_req(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t\t  const u8 *src, const u8 *dst,\n\t\t\t\t\t  const u8 *ssid, size_t ssid_len,\n\t\t\t\t\t  const u8 *ie, size_t ie_len,\n\t\t\t\t\t  u32 ratemask, u32 flags, u32 tx_flags,\n\t\t\t\t\t  struct ieee80211_channel *channel)\n{\n\tstruct sk_buff *skb;\n\n\tskb = ieee80211_build_probe_req(sdata, src, dst, ratemask, channel,\n\t\t\t\t\tssid, ssid_len,\n\t\t\t\t\tie, ie_len, flags);\n\n\tif (skb) {\n\t\tif (flags & IEEE80211_PROBE_FLAG_RANDOM_SN) {\n\t\t\tstruct ieee80211_hdr *hdr = (void *)skb->data;\n\t\t\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\t\t\tu16 sn = get_random_u16();\n\n\t\t\tinfo->control.flags |= IEEE80211_TX_CTRL_NO_SEQNO;\n\t\t\thdr->seq_ctrl =\n\t\t\t\tcpu_to_le16(IEEE80211_SN_TO_SEQ(sn));\n\t\t}\n\t\tIEEE80211_SKB_CB(skb)->flags |= tx_flags;\n\t\tieee80211_tx_skb_tid_band(sdata, skb, 7, channel->band);\n\t}\n}\n\nstatic void ieee80211_scan_state_send_probe(struct ieee80211_local *local,\n\t\t\t\t\t    unsigned long *next_delay)\n{\n\tint i;\n\tstruct ieee80211_sub_if_data *sdata;\n\tstruct cfg80211_scan_request *scan_req;\n\tenum nl80211_band band = local->hw.conf.chandef.chan->band;\n\tu32 flags = 0, tx_flags;\n\n\tscan_req = rcu_dereference_protected(local->scan_req,\n\t\t\t\t\t     lockdep_is_held(&local->mtx));\n\n\ttx_flags = IEEE80211_TX_INTFL_OFFCHAN_TX_OK;\n\tif (scan_req->no_cck)\n\t\ttx_flags |= IEEE80211_TX_CTL_NO_CCK_RATE;\n\tif (scan_req->flags & NL80211_SCAN_FLAG_MIN_PREQ_CONTENT)\n\t\tflags |= IEEE80211_PROBE_FLAG_MIN_CONTENT;\n\tif (scan_req->flags & NL80211_SCAN_FLAG_RANDOM_SN)\n\t\tflags |= IEEE80211_PROBE_FLAG_RANDOM_SN;\n\n\tsdata = rcu_dereference_protected(local->scan_sdata,\n\t\t\t\t\t  lockdep_is_held(&local->mtx));\n\n\tfor (i = 0; i < scan_req->n_ssids; i++)\n\t\tieee80211_send_scan_probe_req(\n\t\t\tsdata, local->scan_addr, scan_req->bssid,\n\t\t\tscan_req->ssids[i].ssid, scan_req->ssids[i].ssid_len,\n\t\t\tscan_req->ie, scan_req->ie_len,\n\t\t\tscan_req->rates[band], flags,\n\t\t\ttx_flags, local->hw.conf.chandef.chan);\n\n\t \n\t*next_delay = IEEE80211_CHANNEL_TIME;\n\tlocal->next_scan_state = SCAN_DECISION;\n}\n\nstatic int __ieee80211_start_scan(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t  struct cfg80211_scan_request *req)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tbool hw_scan = local->ops->hw_scan;\n\tint rc;\n\n\tlockdep_assert_held(&local->mtx);\n\n\tif (local->scan_req)\n\t\treturn -EBUSY;\n\n\tif (!__ieee80211_can_leave_ch(sdata))\n\t\treturn -EBUSY;\n\n\tif (!ieee80211_can_scan(local, sdata)) {\n\t\t \n\t\trcu_assign_pointer(local->scan_req, req);\n\t\trcu_assign_pointer(local->scan_sdata, sdata);\n\t\treturn 0;\n\t}\n\n again:\n\tif (hw_scan) {\n\t\tu8 *ies;\n\n\t\tlocal->hw_scan_ies_bufsize = local->scan_ies_len + req->ie_len;\n\n\t\tif (ieee80211_hw_check(&local->hw, SINGLE_SCAN_ON_ALL_BANDS)) {\n\t\t\tint i, n_bands = 0;\n\t\t\tu8 bands_counted = 0;\n\n\t\t\tfor (i = 0; i < req->n_channels; i++) {\n\t\t\t\tif (bands_counted & BIT(req->channels[i]->band))\n\t\t\t\t\tcontinue;\n\t\t\t\tbands_counted |= BIT(req->channels[i]->band);\n\t\t\t\tn_bands++;\n\t\t\t}\n\n\t\t\tlocal->hw_scan_ies_bufsize *= n_bands;\n\t\t}\n\n\t\tlocal->hw_scan_req = kmalloc(\n\t\t\t\tsizeof(*local->hw_scan_req) +\n\t\t\t\treq->n_channels * sizeof(req->channels[0]) +\n\t\t\t\tlocal->hw_scan_ies_bufsize, GFP_KERNEL);\n\t\tif (!local->hw_scan_req)\n\t\t\treturn -ENOMEM;\n\n\t\tlocal->hw_scan_req->req.ssids = req->ssids;\n\t\tlocal->hw_scan_req->req.n_ssids = req->n_ssids;\n\t\ties = (u8 *)local->hw_scan_req +\n\t\t\tsizeof(*local->hw_scan_req) +\n\t\t\treq->n_channels * sizeof(req->channels[0]);\n\t\tlocal->hw_scan_req->req.ie = ies;\n\t\tlocal->hw_scan_req->req.flags = req->flags;\n\t\teth_broadcast_addr(local->hw_scan_req->req.bssid);\n\t\tlocal->hw_scan_req->req.duration = req->duration;\n\t\tlocal->hw_scan_req->req.duration_mandatory =\n\t\t\treq->duration_mandatory;\n\n\t\tlocal->hw_scan_band = 0;\n\t\tlocal->hw_scan_req->req.n_6ghz_params = req->n_6ghz_params;\n\t\tlocal->hw_scan_req->req.scan_6ghz_params =\n\t\t\treq->scan_6ghz_params;\n\t\tlocal->hw_scan_req->req.scan_6ghz = req->scan_6ghz;\n\n\t\t \n\t}\n\n\trcu_assign_pointer(local->scan_req, req);\n\trcu_assign_pointer(local->scan_sdata, sdata);\n\n\tif (req->flags & NL80211_SCAN_FLAG_RANDOM_ADDR)\n\t\tget_random_mask_addr(local->scan_addr,\n\t\t\t\t     req->mac_addr,\n\t\t\t\t     req->mac_addr_mask);\n\telse\n\t\tmemcpy(local->scan_addr, sdata->vif.addr, ETH_ALEN);\n\n\tif (hw_scan) {\n\t\t__set_bit(SCAN_HW_SCANNING, &local->scanning);\n\t} else if ((req->n_channels == 1) &&\n\t\t   (req->channels[0] == local->_oper_chandef.chan)) {\n\t\t \n\t\tunsigned long next_delay;\n\n\t\t__set_bit(SCAN_ONCHANNEL_SCANNING, &local->scanning);\n\n\t\tieee80211_recalc_idle(local);\n\n\t\t \n\t\tdrv_sw_scan_start(local, sdata, local->scan_addr);\n\n\t\tieee80211_configure_filter(local);  \n\n\t\t \n\t\tieee80211_hw_config(local, 0);\n\n\t\tif ((req->channels[0]->flags & (IEEE80211_CHAN_NO_IR |\n\t\t\t\t\t\tIEEE80211_CHAN_RADAR)) ||\n\t\t    !req->n_ssids) {\n\t\t\tnext_delay = IEEE80211_PASSIVE_CHANNEL_TIME;\n\t\t\tif (req->n_ssids)\n\t\t\t\tset_bit(SCAN_BEACON_WAIT, &local->scanning);\n\t\t} else {\n\t\t\tieee80211_scan_state_send_probe(local, &next_delay);\n\t\t\tnext_delay = IEEE80211_CHANNEL_TIME;\n\t\t}\n\n\t\t \n\t\twiphy_delayed_work_queue(local->hw.wiphy, &local->scan_work,\n\t\t\t\t\t next_delay);\n\t\treturn 0;\n\t} else {\n\t\t \n\t\t__set_bit(SCAN_SW_SCANNING, &local->scanning);\n\t}\n\n\tieee80211_recalc_idle(local);\n\n\tif (hw_scan) {\n\t\tWARN_ON(!ieee80211_prep_hw_scan(sdata));\n\t\trc = drv_hw_scan(local, sdata, local->hw_scan_req);\n\t} else {\n\t\trc = ieee80211_start_sw_scan(local, sdata);\n\t}\n\n\tif (rc) {\n\t\tkfree(local->hw_scan_req);\n\t\tlocal->hw_scan_req = NULL;\n\t\tlocal->scanning = 0;\n\n\t\tieee80211_recalc_idle(local);\n\n\t\tlocal->scan_req = NULL;\n\t\tRCU_INIT_POINTER(local->scan_sdata, NULL);\n\t}\n\n\tif (hw_scan && rc == 1) {\n\t\t \n\t\tif (ieee80211_vif_type_p2p(&sdata->vif) ==\n\t\t\t\tNL80211_IFTYPE_P2P_GO)\n\t\t\treturn -EOPNOTSUPP;\n\t\thw_scan = false;\n\t\tgoto again;\n\t}\n\n\treturn rc;\n}\n\nstatic unsigned long\nieee80211_scan_get_channel_time(struct ieee80211_channel *chan)\n{\n\t \n\tif (chan->flags & (IEEE80211_CHAN_NO_IR | IEEE80211_CHAN_RADAR))\n\t\treturn IEEE80211_PASSIVE_CHANNEL_TIME;\n\treturn IEEE80211_PROBE_DELAY + IEEE80211_CHANNEL_TIME;\n}\n\nstatic void ieee80211_scan_state_decision(struct ieee80211_local *local,\n\t\t\t\t\t  unsigned long *next_delay)\n{\n\tbool associated = false;\n\tbool tx_empty = true;\n\tbool bad_latency;\n\tstruct ieee80211_sub_if_data *sdata;\n\tstruct ieee80211_channel *next_chan;\n\tenum mac80211_scan_state next_scan_state;\n\tstruct cfg80211_scan_request *scan_req;\n\n\t \n\tmutex_lock(&local->iflist_mtx);\n\tlist_for_each_entry(sdata, &local->interfaces, list) {\n\t\tif (!ieee80211_sdata_running(sdata))\n\t\t\tcontinue;\n\n\t\tif (sdata->vif.type == NL80211_IFTYPE_STATION) {\n\t\t\tif (sdata->u.mgd.associated) {\n\t\t\t\tassociated = true;\n\n\t\t\t\tif (!qdisc_all_tx_empty(sdata->dev)) {\n\t\t\t\t\ttx_empty = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tmutex_unlock(&local->iflist_mtx);\n\n\tscan_req = rcu_dereference_protected(local->scan_req,\n\t\t\t\t\t     lockdep_is_held(&local->mtx));\n\n\tnext_chan = scan_req->channels[local->scan_channel_idx];\n\n\t \n\n\tbad_latency = time_after(jiffies +\n\t\t\t\t ieee80211_scan_get_channel_time(next_chan),\n\t\t\t\t local->leave_oper_channel_time + HZ / 8);\n\n\tif (associated && !tx_empty) {\n\t\tif (scan_req->flags & NL80211_SCAN_FLAG_LOW_PRIORITY)\n\t\t\tnext_scan_state = SCAN_ABORT;\n\t\telse\n\t\t\tnext_scan_state = SCAN_SUSPEND;\n\t} else if (associated && bad_latency) {\n\t\tnext_scan_state = SCAN_SUSPEND;\n\t} else {\n\t\tnext_scan_state = SCAN_SET_CHANNEL;\n\t}\n\n\tlocal->next_scan_state = next_scan_state;\n\n\t*next_delay = 0;\n}\n\nstatic void ieee80211_scan_state_set_channel(struct ieee80211_local *local,\n\t\t\t\t\t     unsigned long *next_delay)\n{\n\tint skip;\n\tstruct ieee80211_channel *chan;\n\tenum nl80211_bss_scan_width oper_scan_width;\n\tstruct cfg80211_scan_request *scan_req;\n\n\tscan_req = rcu_dereference_protected(local->scan_req,\n\t\t\t\t\t     lockdep_is_held(&local->mtx));\n\n\tskip = 0;\n\tchan = scan_req->channels[local->scan_channel_idx];\n\n\tlocal->scan_chandef.chan = chan;\n\tlocal->scan_chandef.center_freq1 = chan->center_freq;\n\tlocal->scan_chandef.freq1_offset = chan->freq_offset;\n\tlocal->scan_chandef.center_freq2 = 0;\n\n\t \n\tif (chan->band == NL80211_BAND_S1GHZ) {\n\t\tlocal->scan_chandef.width = ieee80211_s1g_channel_width(chan);\n\t\tgoto set_channel;\n\t}\n\n\tswitch (scan_req->scan_width) {\n\tcase NL80211_BSS_CHAN_WIDTH_5:\n\t\tlocal->scan_chandef.width = NL80211_CHAN_WIDTH_5;\n\t\tbreak;\n\tcase NL80211_BSS_CHAN_WIDTH_10:\n\t\tlocal->scan_chandef.width = NL80211_CHAN_WIDTH_10;\n\t\tbreak;\n\tdefault:\n\tcase NL80211_BSS_CHAN_WIDTH_20:\n\t\t \n\t\toper_scan_width = cfg80211_chandef_to_scan_width(\n\t\t\t\t\t&local->_oper_chandef);\n\t\tif (chan == local->_oper_chandef.chan &&\n\t\t    oper_scan_width == scan_req->scan_width)\n\t\t\tlocal->scan_chandef = local->_oper_chandef;\n\t\telse\n\t\t\tlocal->scan_chandef.width = NL80211_CHAN_WIDTH_20_NOHT;\n\t\tbreak;\n\tcase NL80211_BSS_CHAN_WIDTH_1:\n\tcase NL80211_BSS_CHAN_WIDTH_2:\n\t\t \n\t\tWARN_ON(1);\n\t\tbreak;\n\t}\n\nset_channel:\n\tif (ieee80211_hw_config(local, IEEE80211_CONF_CHANGE_CHANNEL))\n\t\tskip = 1;\n\n\t \n\tlocal->scan_channel_idx++;\n\n\tif (skip) {\n\t\t \n\t\tlocal->next_scan_state = SCAN_DECISION;\n\t\treturn;\n\t}\n\n\t \n\tif ((chan->flags & (IEEE80211_CHAN_NO_IR | IEEE80211_CHAN_RADAR)) ||\n\t    !scan_req->n_ssids) {\n\t\t*next_delay = IEEE80211_PASSIVE_CHANNEL_TIME;\n\t\tlocal->next_scan_state = SCAN_DECISION;\n\t\tif (scan_req->n_ssids)\n\t\t\tset_bit(SCAN_BEACON_WAIT, &local->scanning);\n\t\treturn;\n\t}\n\n\t \n\t*next_delay = IEEE80211_PROBE_DELAY;\n\tlocal->next_scan_state = SCAN_SEND_PROBE;\n}\n\nstatic void ieee80211_scan_state_suspend(struct ieee80211_local *local,\n\t\t\t\t\t unsigned long *next_delay)\n{\n\t \n\tlocal->scan_chandef.chan = NULL;\n\tieee80211_hw_config(local, IEEE80211_CONF_CHANGE_CHANNEL);\n\n\t \n\tieee80211_offchannel_return(local);\n\n\t*next_delay = HZ / 5;\n\t \n\tlocal->next_scan_state = SCAN_RESUME;\n}\n\nstatic void ieee80211_scan_state_resume(struct ieee80211_local *local,\n\t\t\t\t\tunsigned long *next_delay)\n{\n\tieee80211_offchannel_stop_vifs(local);\n\n\tif (local->ops->flush) {\n\t\tieee80211_flush_queues(local, NULL, false);\n\t\t*next_delay = 0;\n\t} else\n\t\t*next_delay = HZ / 10;\n\n\t \n\tlocal->leave_oper_channel_time = jiffies;\n\n\t \n\tlocal->next_scan_state = SCAN_SET_CHANNEL;\n}\n\nvoid ieee80211_scan_work(struct wiphy *wiphy, struct wiphy_work *work)\n{\n\tstruct ieee80211_local *local =\n\t\tcontainer_of(work, struct ieee80211_local, scan_work.work);\n\tstruct ieee80211_sub_if_data *sdata;\n\tstruct cfg80211_scan_request *scan_req;\n\tunsigned long next_delay = 0;\n\tbool aborted;\n\n\tmutex_lock(&local->mtx);\n\n\tif (!ieee80211_can_run_worker(local)) {\n\t\taborted = true;\n\t\tgoto out_complete;\n\t}\n\n\tsdata = rcu_dereference_protected(local->scan_sdata,\n\t\t\t\t\t  lockdep_is_held(&local->mtx));\n\tscan_req = rcu_dereference_protected(local->scan_req,\n\t\t\t\t\t     lockdep_is_held(&local->mtx));\n\n\t \n\tif (test_bit(SCAN_ONCHANNEL_SCANNING, &local->scanning)) {\n\t\taborted = test_and_clear_bit(SCAN_ABORTED, &local->scanning);\n\t\tgoto out_complete;\n\t}\n\n\tif (test_and_clear_bit(SCAN_COMPLETED, &local->scanning)) {\n\t\taborted = test_and_clear_bit(SCAN_ABORTED, &local->scanning);\n\t\tgoto out_complete;\n\t}\n\n\tif (!sdata || !scan_req)\n\t\tgoto out;\n\n\tif (!local->scanning) {\n\t\tint rc;\n\n\t\tRCU_INIT_POINTER(local->scan_req, NULL);\n\t\tRCU_INIT_POINTER(local->scan_sdata, NULL);\n\n\t\trc = __ieee80211_start_scan(sdata, scan_req);\n\t\tif (rc) {\n\t\t\t \n\t\t\trcu_assign_pointer(local->scan_req, scan_req);\n\t\t\taborted = true;\n\t\t\tgoto out_complete;\n\t\t} else\n\t\t\tgoto out;\n\t}\n\n\tclear_bit(SCAN_BEACON_WAIT, &local->scanning);\n\n\t \n\tdo {\n\t\tif (!ieee80211_sdata_running(sdata)) {\n\t\t\taborted = true;\n\t\t\tgoto out_complete;\n\t\t}\n\n\t\tif (test_and_clear_bit(SCAN_BEACON_DONE, &local->scanning) &&\n\t\t    local->next_scan_state == SCAN_DECISION)\n\t\t\tlocal->next_scan_state = SCAN_SEND_PROBE;\n\n\t\tswitch (local->next_scan_state) {\n\t\tcase SCAN_DECISION:\n\t\t\t \n\t\t\tif (local->scan_channel_idx >= scan_req->n_channels) {\n\t\t\t\taborted = false;\n\t\t\t\tgoto out_complete;\n\t\t\t}\n\t\t\tieee80211_scan_state_decision(local, &next_delay);\n\t\t\tbreak;\n\t\tcase SCAN_SET_CHANNEL:\n\t\t\tieee80211_scan_state_set_channel(local, &next_delay);\n\t\t\tbreak;\n\t\tcase SCAN_SEND_PROBE:\n\t\t\tieee80211_scan_state_send_probe(local, &next_delay);\n\t\t\tbreak;\n\t\tcase SCAN_SUSPEND:\n\t\t\tieee80211_scan_state_suspend(local, &next_delay);\n\t\t\tbreak;\n\t\tcase SCAN_RESUME:\n\t\t\tieee80211_scan_state_resume(local, &next_delay);\n\t\t\tbreak;\n\t\tcase SCAN_ABORT:\n\t\t\taborted = true;\n\t\t\tgoto out_complete;\n\t\t}\n\t} while (next_delay == 0);\n\n\twiphy_delayed_work_queue(local->hw.wiphy, &local->scan_work,\n\t\t\t\t next_delay);\n\tgoto out;\n\nout_complete:\n\t__ieee80211_scan_completed(&local->hw, aborted);\nout:\n\tmutex_unlock(&local->mtx);\n}\n\nint ieee80211_request_scan(struct ieee80211_sub_if_data *sdata,\n\t\t\t   struct cfg80211_scan_request *req)\n{\n\tint res;\n\n\tmutex_lock(&sdata->local->mtx);\n\tres = __ieee80211_start_scan(sdata, req);\n\tmutex_unlock(&sdata->local->mtx);\n\n\treturn res;\n}\n\nint ieee80211_request_ibss_scan(struct ieee80211_sub_if_data *sdata,\n\t\t\t\tconst u8 *ssid, u8 ssid_len,\n\t\t\t\tstruct ieee80211_channel **channels,\n\t\t\t\tunsigned int n_channels,\n\t\t\t\tenum nl80211_bss_scan_width scan_width)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tint ret = -EBUSY, i, n_ch = 0;\n\tenum nl80211_band band;\n\n\tmutex_lock(&local->mtx);\n\n\t \n\tif (local->scan_req)\n\t\tgoto unlock;\n\n\t \n\tif (!channels) {\n\t\tint max_n;\n\n\t\tfor (band = 0; band < NUM_NL80211_BANDS; band++) {\n\t\t\tif (!local->hw.wiphy->bands[band] ||\n\t\t\t    band == NL80211_BAND_6GHZ)\n\t\t\t\tcontinue;\n\n\t\t\tmax_n = local->hw.wiphy->bands[band]->n_channels;\n\t\t\tfor (i = 0; i < max_n; i++) {\n\t\t\t\tstruct ieee80211_channel *tmp_ch =\n\t\t\t\t    &local->hw.wiphy->bands[band]->channels[i];\n\n\t\t\t\tif (tmp_ch->flags & (IEEE80211_CHAN_NO_IR |\n\t\t\t\t\t\t     IEEE80211_CHAN_DISABLED))\n\t\t\t\t\tcontinue;\n\n\t\t\t\tlocal->int_scan_req->channels[n_ch] = tmp_ch;\n\t\t\t\tn_ch++;\n\t\t\t}\n\t\t}\n\n\t\tif (WARN_ON_ONCE(n_ch == 0))\n\t\t\tgoto unlock;\n\n\t\tlocal->int_scan_req->n_channels = n_ch;\n\t} else {\n\t\tfor (i = 0; i < n_channels; i++) {\n\t\t\tif (channels[i]->flags & (IEEE80211_CHAN_NO_IR |\n\t\t\t\t\t\t  IEEE80211_CHAN_DISABLED))\n\t\t\t\tcontinue;\n\n\t\t\tlocal->int_scan_req->channels[n_ch] = channels[i];\n\t\t\tn_ch++;\n\t\t}\n\n\t\tif (WARN_ON_ONCE(n_ch == 0))\n\t\t\tgoto unlock;\n\n\t\tlocal->int_scan_req->n_channels = n_ch;\n\t}\n\n\tlocal->int_scan_req->ssids = &local->scan_ssid;\n\tlocal->int_scan_req->n_ssids = 1;\n\tlocal->int_scan_req->scan_width = scan_width;\n\tmemcpy(local->int_scan_req->ssids[0].ssid, ssid, IEEE80211_MAX_SSID_LEN);\n\tlocal->int_scan_req->ssids[0].ssid_len = ssid_len;\n\n\tret = __ieee80211_start_scan(sdata, sdata->local->int_scan_req);\n unlock:\n\tmutex_unlock(&local->mtx);\n\treturn ret;\n}\n\nvoid ieee80211_scan_cancel(struct ieee80211_local *local)\n{\n\t \n\tlockdep_assert_wiphy(local->hw.wiphy);\n\n\t \n\n\tmutex_lock(&local->mtx);\n\tif (!local->scan_req)\n\t\tgoto out;\n\n\t \n\tif (test_bit(SCAN_HW_SCANNING, &local->scanning) &&\n\t    test_bit(SCAN_COMPLETED, &local->scanning)) {\n\t\tset_bit(SCAN_HW_CANCELLED, &local->scanning);\n\t\tgoto out;\n\t}\n\n\tif (test_bit(SCAN_HW_SCANNING, &local->scanning)) {\n\t\t \n\t\tset_bit(SCAN_HW_CANCELLED, &local->scanning);\n\t\tif (local->ops->cancel_hw_scan)\n\t\t\tdrv_cancel_hw_scan(local,\n\t\t\t\trcu_dereference_protected(local->scan_sdata,\n\t\t\t\t\t\tlockdep_is_held(&local->mtx)));\n\t\tgoto out;\n\t}\n\n\twiphy_delayed_work_cancel(local->hw.wiphy, &local->scan_work);\n\t \n\tmemset(&local->scan_info, 0, sizeof(local->scan_info));\n\t__ieee80211_scan_completed(&local->hw, true);\nout:\n\tmutex_unlock(&local->mtx);\n}\n\nint __ieee80211_request_sched_scan_start(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t\tstruct cfg80211_sched_scan_request *req)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct ieee80211_scan_ies sched_scan_ies = {};\n\tstruct cfg80211_chan_def chandef;\n\tint ret, i, iebufsz, num_bands = 0;\n\tu32 rate_masks[NUM_NL80211_BANDS] = {};\n\tu8 bands_used = 0;\n\tu8 *ie;\n\tu32 flags = 0;\n\n\tiebufsz = local->scan_ies_len + req->ie_len;\n\n\tlockdep_assert_held(&local->mtx);\n\n\tif (!local->ops->sched_scan_start)\n\t\treturn -ENOTSUPP;\n\n\tfor (i = 0; i < NUM_NL80211_BANDS; i++) {\n\t\tif (local->hw.wiphy->bands[i]) {\n\t\t\tbands_used |= BIT(i);\n\t\t\trate_masks[i] = (u32) -1;\n\t\t\tnum_bands++;\n\t\t}\n\t}\n\n\tif (req->flags & NL80211_SCAN_FLAG_MIN_PREQ_CONTENT)\n\t\tflags |= IEEE80211_PROBE_FLAG_MIN_CONTENT;\n\n\tie = kcalloc(iebufsz, num_bands, GFP_KERNEL);\n\tif (!ie) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tieee80211_prepare_scan_chandef(&chandef, req->scan_width);\n\n\tieee80211_build_preq_ies(sdata, ie, num_bands * iebufsz,\n\t\t\t\t &sched_scan_ies, req->ie,\n\t\t\t\t req->ie_len, bands_used, rate_masks, &chandef,\n\t\t\t\t flags);\n\n\tret = drv_sched_scan_start(local, sdata, req, &sched_scan_ies);\n\tif (ret == 0) {\n\t\trcu_assign_pointer(local->sched_scan_sdata, sdata);\n\t\trcu_assign_pointer(local->sched_scan_req, req);\n\t}\n\n\tkfree(ie);\n\nout:\n\tif (ret) {\n\t\t \n\t\tRCU_INIT_POINTER(local->sched_scan_sdata, NULL);\n\t\tRCU_INIT_POINTER(local->sched_scan_req, NULL);\n\t}\n\n\treturn ret;\n}\n\nint ieee80211_request_sched_scan_start(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t       struct cfg80211_sched_scan_request *req)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tint ret;\n\n\tmutex_lock(&local->mtx);\n\n\tif (rcu_access_pointer(local->sched_scan_sdata)) {\n\t\tmutex_unlock(&local->mtx);\n\t\treturn -EBUSY;\n\t}\n\n\tret = __ieee80211_request_sched_scan_start(sdata, req);\n\n\tmutex_unlock(&local->mtx);\n\treturn ret;\n}\n\nint ieee80211_request_sched_scan_stop(struct ieee80211_local *local)\n{\n\tstruct ieee80211_sub_if_data *sched_scan_sdata;\n\tint ret = -ENOENT;\n\n\tmutex_lock(&local->mtx);\n\n\tif (!local->ops->sched_scan_stop) {\n\t\tret = -ENOTSUPP;\n\t\tgoto out;\n\t}\n\n\t \n\tRCU_INIT_POINTER(local->sched_scan_req, NULL);\n\n\tsched_scan_sdata = rcu_dereference_protected(local->sched_scan_sdata,\n\t\t\t\t\t\tlockdep_is_held(&local->mtx));\n\tif (sched_scan_sdata) {\n\t\tret = drv_sched_scan_stop(local, sched_scan_sdata);\n\t\tif (!ret)\n\t\t\tRCU_INIT_POINTER(local->sched_scan_sdata, NULL);\n\t}\nout:\n\tmutex_unlock(&local->mtx);\n\n\treturn ret;\n}\n\nvoid ieee80211_sched_scan_results(struct ieee80211_hw *hw)\n{\n\tstruct ieee80211_local *local = hw_to_local(hw);\n\n\ttrace_api_sched_scan_results(local);\n\n\tcfg80211_sched_scan_results(hw->wiphy, 0);\n}\nEXPORT_SYMBOL(ieee80211_sched_scan_results);\n\nvoid ieee80211_sched_scan_end(struct ieee80211_local *local)\n{\n\tmutex_lock(&local->mtx);\n\n\tif (!rcu_access_pointer(local->sched_scan_sdata)) {\n\t\tmutex_unlock(&local->mtx);\n\t\treturn;\n\t}\n\n\tRCU_INIT_POINTER(local->sched_scan_sdata, NULL);\n\n\t \n\tRCU_INIT_POINTER(local->sched_scan_req, NULL);\n\n\tmutex_unlock(&local->mtx);\n\n\tcfg80211_sched_scan_stopped_locked(local->hw.wiphy, 0);\n}\n\nvoid ieee80211_sched_scan_stopped_work(struct wiphy *wiphy,\n\t\t\t\t       struct wiphy_work *work)\n{\n\tstruct ieee80211_local *local =\n\t\tcontainer_of(work, struct ieee80211_local,\n\t\t\t     sched_scan_stopped_work);\n\n\tieee80211_sched_scan_end(local);\n}\n\nvoid ieee80211_sched_scan_stopped(struct ieee80211_hw *hw)\n{\n\tstruct ieee80211_local *local = hw_to_local(hw);\n\n\ttrace_api_sched_scan_stopped(local);\n\n\t \n\tif (local->in_reconfig)\n\t\treturn;\n\n\twiphy_work_queue(hw->wiphy, &local->sched_scan_stopped_work);\n}\nEXPORT_SYMBOL(ieee80211_sched_scan_stopped);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}