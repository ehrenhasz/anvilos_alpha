{
  "module_name": "s1g.c",
  "hash_id": "3c3098510b5c1f50ff517175d4deb0106acafc9afcaf24e27a466e8ea52d12f1",
  "original_prompt": "Ingested from linux-6.6.14/net/mac80211/s1g.c",
  "human_readable_source": "\n \n#include <linux/ieee80211.h>\n#include <net/mac80211.h>\n#include \"ieee80211_i.h\"\n#include \"driver-ops.h\"\n\nvoid ieee80211_s1g_sta_rate_init(struct sta_info *sta)\n{\n\t \n\tsta->deflink.tx_stats.last_rate.flags |= IEEE80211_TX_RC_S1G_MCS;\n\tsta->deflink.rx_stats.last_rate =\n\t\t\tSTA_STATS_FIELD(TYPE, STA_STATS_RATE_TYPE_S1G);\n}\n\nbool ieee80211_s1g_is_twt_setup(struct sk_buff *skb)\n{\n\tstruct ieee80211_mgmt *mgmt = (struct ieee80211_mgmt *)skb->data;\n\n\tif (likely(!ieee80211_is_action(mgmt->frame_control)))\n\t\treturn false;\n\n\tif (likely(mgmt->u.action.category != WLAN_CATEGORY_S1G))\n\t\treturn false;\n\n\treturn mgmt->u.action.u.s1g.action_code == WLAN_S1G_TWT_SETUP;\n}\n\nstatic void\nieee80211_s1g_send_twt_setup(struct ieee80211_sub_if_data *sdata, const u8 *da,\n\t\t\t     const u8 *bssid, struct ieee80211_twt_setup *twt)\n{\n\tint len = IEEE80211_MIN_ACTION_SIZE + 4 + twt->length;\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct ieee80211_mgmt *mgmt;\n\tstruct sk_buff *skb;\n\n\tskb = dev_alloc_skb(local->hw.extra_tx_headroom + len);\n\tif (!skb)\n\t\treturn;\n\n\tskb_reserve(skb, local->hw.extra_tx_headroom);\n\tmgmt = skb_put_zero(skb, len);\n\tmgmt->frame_control = cpu_to_le16(IEEE80211_FTYPE_MGMT |\n\t\t\t\t\t  IEEE80211_STYPE_ACTION);\n\tmemcpy(mgmt->da, da, ETH_ALEN);\n\tmemcpy(mgmt->sa, sdata->vif.addr, ETH_ALEN);\n\tmemcpy(mgmt->bssid, bssid, ETH_ALEN);\n\n\tmgmt->u.action.category = WLAN_CATEGORY_S1G;\n\tmgmt->u.action.u.s1g.action_code = WLAN_S1G_TWT_SETUP;\n\tmemcpy(mgmt->u.action.u.s1g.variable, twt, 3 + twt->length);\n\n\tIEEE80211_SKB_CB(skb)->flags |= IEEE80211_TX_INTFL_DONT_ENCRYPT |\n\t\t\t\t\tIEEE80211_TX_INTFL_MLME_CONN_TX |\n\t\t\t\t\tIEEE80211_TX_CTL_REQ_TX_STATUS;\n\tieee80211_tx_skb(sdata, skb);\n}\n\nstatic void\nieee80211_s1g_send_twt_teardown(struct ieee80211_sub_if_data *sdata,\n\t\t\t\tconst u8 *da, const u8 *bssid, u8 flowid)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct ieee80211_mgmt *mgmt;\n\tstruct sk_buff *skb;\n\tu8 *id;\n\n\tskb = dev_alloc_skb(local->hw.extra_tx_headroom +\n\t\t\t    IEEE80211_MIN_ACTION_SIZE + 2);\n\tif (!skb)\n\t\treturn;\n\n\tskb_reserve(skb, local->hw.extra_tx_headroom);\n\tmgmt = skb_put_zero(skb, IEEE80211_MIN_ACTION_SIZE + 2);\n\tmgmt->frame_control = cpu_to_le16(IEEE80211_FTYPE_MGMT |\n\t\t\t\t\t  IEEE80211_STYPE_ACTION);\n\tmemcpy(mgmt->da, da, ETH_ALEN);\n\tmemcpy(mgmt->sa, sdata->vif.addr, ETH_ALEN);\n\tmemcpy(mgmt->bssid, bssid, ETH_ALEN);\n\n\tmgmt->u.action.category = WLAN_CATEGORY_S1G;\n\tmgmt->u.action.u.s1g.action_code = WLAN_S1G_TWT_TEARDOWN;\n\tid = (u8 *)mgmt->u.action.u.s1g.variable;\n\t*id = flowid;\n\n\tIEEE80211_SKB_CB(skb)->flags |= IEEE80211_TX_INTFL_DONT_ENCRYPT |\n\t\t\t\t\tIEEE80211_TX_CTL_REQ_TX_STATUS;\n\tieee80211_tx_skb(sdata, skb);\n}\n\nstatic void\nieee80211_s1g_rx_twt_setup(struct ieee80211_sub_if_data *sdata,\n\t\t\t   struct sta_info *sta, struct sk_buff *skb)\n{\n\tstruct ieee80211_mgmt *mgmt = (void *)skb->data;\n\tstruct ieee80211_twt_setup *twt = (void *)mgmt->u.action.u.s1g.variable;\n\tstruct ieee80211_twt_params *twt_agrt = (void *)twt->params;\n\n\ttwt_agrt->req_type &= cpu_to_le16(~IEEE80211_TWT_REQTYPE_REQUEST);\n\n\t \n\tif (twt->control & IEEE80211_TWT_CONTROL_NEG_TYPE_BROADCAST) {\n\t\ttwt_agrt->req_type &=\n\t\t\t~cpu_to_le16(IEEE80211_TWT_REQTYPE_SETUP_CMD);\n\t\ttwt_agrt->req_type |=\n\t\t\tle16_encode_bits(TWT_SETUP_CMD_REJECT,\n\t\t\t\t\t IEEE80211_TWT_REQTYPE_SETUP_CMD);\n\t\tgoto out;\n\t}\n\n\t \n\ttwt->control |= IEEE80211_TWT_CONTROL_RX_DISABLED;\n\n\tdrv_add_twt_setup(sdata->local, sdata, &sta->sta, twt);\nout:\n\tieee80211_s1g_send_twt_setup(sdata, mgmt->sa, sdata->vif.addr, twt);\n}\n\nstatic void\nieee80211_s1g_rx_twt_teardown(struct ieee80211_sub_if_data *sdata,\n\t\t\t      struct sta_info *sta, struct sk_buff *skb)\n{\n\tstruct ieee80211_mgmt *mgmt = (struct ieee80211_mgmt *)skb->data;\n\n\tdrv_twt_teardown_request(sdata->local, sdata, &sta->sta,\n\t\t\t\t mgmt->u.action.u.s1g.variable[0]);\n}\n\nstatic void\nieee80211_s1g_tx_twt_setup_fail(struct ieee80211_sub_if_data *sdata,\n\t\t\t\tstruct sta_info *sta, struct sk_buff *skb)\n{\n\tstruct ieee80211_mgmt *mgmt = (struct ieee80211_mgmt *)skb->data;\n\tstruct ieee80211_twt_setup *twt = (void *)mgmt->u.action.u.s1g.variable;\n\tstruct ieee80211_twt_params *twt_agrt = (void *)twt->params;\n\tu8 flowid = le16_get_bits(twt_agrt->req_type,\n\t\t\t\t  IEEE80211_TWT_REQTYPE_FLOWID);\n\n\tdrv_twt_teardown_request(sdata->local, sdata, &sta->sta, flowid);\n\n\tieee80211_s1g_send_twt_teardown(sdata, mgmt->sa, sdata->vif.addr,\n\t\t\t\t\tflowid);\n}\n\nvoid ieee80211_s1g_rx_twt_action(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t struct sk_buff *skb)\n{\n\tstruct ieee80211_mgmt *mgmt = (struct ieee80211_mgmt *)skb->data;\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct sta_info *sta;\n\n\tmutex_lock(&local->sta_mtx);\n\n\tsta = sta_info_get_bss(sdata, mgmt->sa);\n\tif (!sta)\n\t\tgoto out;\n\n\tswitch (mgmt->u.action.u.s1g.action_code) {\n\tcase WLAN_S1G_TWT_SETUP:\n\t\tieee80211_s1g_rx_twt_setup(sdata, sta, skb);\n\t\tbreak;\n\tcase WLAN_S1G_TWT_TEARDOWN:\n\t\tieee80211_s1g_rx_twt_teardown(sdata, sta, skb);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\nout:\n\tmutex_unlock(&local->sta_mtx);\n}\n\nvoid ieee80211_s1g_status_twt_action(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t     struct sk_buff *skb)\n{\n\tstruct ieee80211_mgmt *mgmt = (struct ieee80211_mgmt *)skb->data;\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct sta_info *sta;\n\n\tmutex_lock(&local->sta_mtx);\n\n\tsta = sta_info_get_bss(sdata, mgmt->da);\n\tif (!sta)\n\t\tgoto out;\n\n\tswitch (mgmt->u.action.u.s1g.action_code) {\n\tcase WLAN_S1G_TWT_SETUP:\n\t\t \n\t\tieee80211_s1g_tx_twt_setup_fail(sdata, sta, skb);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\nout:\n\tmutex_unlock(&local->sta_mtx);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}