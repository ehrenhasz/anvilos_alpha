{
  "module_name": "mlme.c",
  "hash_id": "7f8d63cf96113299a1ee421d1ebce306e19fdc0ba998323a7d1baf01c9e3dc98",
  "original_prompt": "Ingested from linux-6.6.14/net/mac80211/mlme.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/fips.h>\n#include <linux/if_ether.h>\n#include <linux/skbuff.h>\n#include <linux/if_arp.h>\n#include <linux/etherdevice.h>\n#include <linux/moduleparam.h>\n#include <linux/rtnetlink.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <net/mac80211.h>\n#include <asm/unaligned.h>\n\n#include \"ieee80211_i.h\"\n#include \"driver-ops.h\"\n#include \"rate.h\"\n#include \"led.h\"\n#include \"fils_aead.h\"\n\n#define IEEE80211_AUTH_TIMEOUT\t\t(HZ / 5)\n#define IEEE80211_AUTH_TIMEOUT_LONG\t(HZ / 2)\n#define IEEE80211_AUTH_TIMEOUT_SHORT\t(HZ / 10)\n#define IEEE80211_AUTH_TIMEOUT_SAE\t(HZ * 2)\n#define IEEE80211_AUTH_MAX_TRIES\t3\n#define IEEE80211_AUTH_WAIT_ASSOC\t(HZ * 5)\n#define IEEE80211_AUTH_WAIT_SAE_RETRY\t(HZ * 2)\n#define IEEE80211_ASSOC_TIMEOUT\t\t(HZ / 5)\n#define IEEE80211_ASSOC_TIMEOUT_LONG\t(HZ / 2)\n#define IEEE80211_ASSOC_TIMEOUT_SHORT\t(HZ / 10)\n#define IEEE80211_ASSOC_MAX_TRIES\t3\n\nstatic int max_nullfunc_tries = 2;\nmodule_param(max_nullfunc_tries, int, 0644);\nMODULE_PARM_DESC(max_nullfunc_tries,\n\t\t \"Maximum nullfunc tx tries before disconnecting (reason 4).\");\n\nstatic int max_probe_tries = 5;\nmodule_param(max_probe_tries, int, 0644);\nMODULE_PARM_DESC(max_probe_tries,\n\t\t \"Maximum probe tries before disconnecting (reason 4).\");\n\n \nstatic int beacon_loss_count = 7;\nmodule_param(beacon_loss_count, int, 0644);\nMODULE_PARM_DESC(beacon_loss_count,\n\t\t \"Number of beacon intervals before we decide beacon was lost.\");\n\n \n#define IEEE80211_CONNECTION_IDLE_TIME\t(30 * HZ)\n \nstatic int probe_wait_ms = 500;\nmodule_param(probe_wait_ms, int, 0644);\nMODULE_PARM_DESC(probe_wait_ms,\n\t\t \"Maximum time(ms) to wait for probe response\"\n\t\t \" before disconnecting (reason 4).\");\n\n \n#define IEEE80211_SIGNAL_AVE_MIN_COUNT\t4\n\n \nstatic u16\nieee80211_extract_dis_subch_bmap(const struct ieee80211_eht_operation *eht_oper,\n\t\t\t\t struct cfg80211_chan_def *chandef, u16 bitmap)\n{\n\tstruct ieee80211_eht_operation_info *info = (void *)eht_oper->optional;\n\tstruct cfg80211_chan_def ap_chandef = *chandef;\n\tu32 ap_center_freq, local_center_freq;\n\tu32 ap_bw, local_bw;\n\tint ap_start_freq, local_start_freq;\n\tu16 shift, mask;\n\n\tif (!(eht_oper->params & IEEE80211_EHT_OPER_INFO_PRESENT) ||\n\t    !(eht_oper->params &\n\t      IEEE80211_EHT_OPER_DISABLED_SUBCHANNEL_BITMAP_PRESENT))\n\t\treturn 0;\n\n\t \n\tieee80211_chandef_eht_oper(eht_oper, true, true, &ap_chandef);\n\tap_center_freq = ap_chandef.center_freq1;\n\tap_bw = 20 * BIT(u8_get_bits(info->control,\n\t\t\t\t     IEEE80211_EHT_OPER_CHAN_WIDTH));\n\tap_start_freq = ap_center_freq - ap_bw / 2;\n\tlocal_center_freq = chandef->center_freq1;\n\tlocal_bw = 20 * BIT(ieee80211_chan_width_to_rx_bw(chandef->width));\n\tlocal_start_freq = local_center_freq - local_bw / 2;\n\tshift = (local_start_freq - ap_start_freq) / 20;\n\tmask = BIT(local_bw / 20) - 1;\n\n\treturn (bitmap >> shift) & mask;\n}\n\n \nstatic void\nieee80211_handle_puncturing_bitmap(struct ieee80211_link_data *link,\n\t\t\t\t   const struct ieee80211_eht_operation *eht_oper,\n\t\t\t\t   u16 bitmap, u64 *changed)\n{\n\tstruct cfg80211_chan_def *chandef = &link->conf->chandef;\n\tu16 extracted;\n\tu64 _changed = 0;\n\n\tif (!changed)\n\t\tchanged = &_changed;\n\n\twhile (chandef->width > NL80211_CHAN_WIDTH_40) {\n\t\textracted =\n\t\t\tieee80211_extract_dis_subch_bmap(eht_oper, chandef,\n\t\t\t\t\t\t\t bitmap);\n\n\t\tif (cfg80211_valid_disable_subchannel_bitmap(&bitmap,\n\t\t\t\t\t\t\t     chandef))\n\t\t\tbreak;\n\t\tlink->u.mgd.conn_flags |=\n\t\t\tieee80211_chandef_downgrade(chandef);\n\t\t*changed |= BSS_CHANGED_BANDWIDTH;\n\t}\n\n\tif (chandef->width <= NL80211_CHAN_WIDTH_40)\n\t\textracted = 0;\n\n\tif (link->conf->eht_puncturing != extracted) {\n\t\tlink->conf->eht_puncturing = extracted;\n\t\t*changed |= BSS_CHANGED_EHT_PUNCTURING;\n\t}\n}\n\n \nstatic void run_again(struct ieee80211_sub_if_data *sdata,\n\t\t      unsigned long timeout)\n{\n\tsdata_assert_lock(sdata);\n\n\tif (!timer_pending(&sdata->u.mgd.timer) ||\n\t    time_before(timeout, sdata->u.mgd.timer.expires))\n\t\tmod_timer(&sdata->u.mgd.timer, timeout);\n}\n\nvoid ieee80211_sta_reset_beacon_monitor(struct ieee80211_sub_if_data *sdata)\n{\n\tif (sdata->vif.driver_flags & IEEE80211_VIF_BEACON_FILTER)\n\t\treturn;\n\n\tif (ieee80211_hw_check(&sdata->local->hw, CONNECTION_MONITOR))\n\t\treturn;\n\n\tmod_timer(&sdata->u.mgd.bcn_mon_timer,\n\t\t  round_jiffies_up(jiffies + sdata->u.mgd.beacon_timeout));\n}\n\nvoid ieee80211_sta_reset_conn_monitor(struct ieee80211_sub_if_data *sdata)\n{\n\tstruct ieee80211_if_managed *ifmgd = &sdata->u.mgd;\n\n\tif (unlikely(!ifmgd->associated))\n\t\treturn;\n\n\tif (ifmgd->probe_send_count)\n\t\tifmgd->probe_send_count = 0;\n\n\tif (ieee80211_hw_check(&sdata->local->hw, CONNECTION_MONITOR))\n\t\treturn;\n\n\tmod_timer(&ifmgd->conn_mon_timer,\n\t\t  round_jiffies_up(jiffies + IEEE80211_CONNECTION_IDLE_TIME));\n}\n\nstatic int ecw2cw(int ecw)\n{\n\treturn (1 << ecw) - 1;\n}\n\nstatic ieee80211_conn_flags_t\nieee80211_determine_chantype(struct ieee80211_sub_if_data *sdata,\n\t\t\t     struct ieee80211_link_data *link,\n\t\t\t     ieee80211_conn_flags_t conn_flags,\n\t\t\t     struct ieee80211_supported_band *sband,\n\t\t\t     struct ieee80211_channel *channel,\n\t\t\t     u32 vht_cap_info,\n\t\t\t     const struct ieee80211_ht_operation *ht_oper,\n\t\t\t     const struct ieee80211_vht_operation *vht_oper,\n\t\t\t     const struct ieee80211_he_operation *he_oper,\n\t\t\t     const struct ieee80211_eht_operation *eht_oper,\n\t\t\t     const struct ieee80211_s1g_oper_ie *s1g_oper,\n\t\t\t     struct cfg80211_chan_def *chandef, bool tracking)\n{\n\tstruct cfg80211_chan_def vht_chandef;\n\tstruct ieee80211_sta_ht_cap sta_ht_cap;\n\tieee80211_conn_flags_t ret;\n\tu32 ht_cfreq;\n\n\tmemset(chandef, 0, sizeof(struct cfg80211_chan_def));\n\tchandef->chan = channel;\n\tchandef->width = NL80211_CHAN_WIDTH_20_NOHT;\n\tchandef->center_freq1 = channel->center_freq;\n\tchandef->freq1_offset = channel->freq_offset;\n\n\tif (channel->band == NL80211_BAND_6GHZ) {\n\t\tif (!ieee80211_chandef_he_6ghz_oper(sdata, he_oper, eht_oper,\n\t\t\t\t\t\t    chandef)) {\n\t\t\tmlme_dbg(sdata,\n\t\t\t\t \"bad 6 GHz operation, disabling HT/VHT/HE/EHT\\n\");\n\t\t\tret = IEEE80211_CONN_DISABLE_HT |\n\t\t\t      IEEE80211_CONN_DISABLE_VHT |\n\t\t\t      IEEE80211_CONN_DISABLE_HE |\n\t\t\t      IEEE80211_CONN_DISABLE_EHT;\n\t\t} else {\n\t\t\tret = 0;\n\t\t}\n\t\tvht_chandef = *chandef;\n\t\tgoto out;\n\t} else if (sband->band == NL80211_BAND_S1GHZ) {\n\t\tif (!ieee80211_chandef_s1g_oper(s1g_oper, chandef)) {\n\t\t\tsdata_info(sdata,\n\t\t\t\t   \"Missing S1G Operation Element? Trying operating == primary\\n\");\n\t\t\tchandef->width = ieee80211_s1g_channel_width(channel);\n\t\t}\n\n\t\tret = IEEE80211_CONN_DISABLE_HT | IEEE80211_CONN_DISABLE_40MHZ |\n\t\t      IEEE80211_CONN_DISABLE_VHT |\n\t\t      IEEE80211_CONN_DISABLE_80P80MHZ |\n\t\t      IEEE80211_CONN_DISABLE_160MHZ;\n\t\tgoto out;\n\t}\n\n\tmemcpy(&sta_ht_cap, &sband->ht_cap, sizeof(sta_ht_cap));\n\tieee80211_apply_htcap_overrides(sdata, &sta_ht_cap);\n\n\tif (!ht_oper || !sta_ht_cap.ht_supported) {\n\t\tmlme_dbg(sdata, \"HT operation missing / HT not supported\\n\");\n\t\tret = IEEE80211_CONN_DISABLE_HT |\n\t\t      IEEE80211_CONN_DISABLE_VHT |\n\t\t      IEEE80211_CONN_DISABLE_HE |\n\t\t      IEEE80211_CONN_DISABLE_EHT;\n\t\tgoto out;\n\t}\n\n\tchandef->width = NL80211_CHAN_WIDTH_20;\n\n\tht_cfreq = ieee80211_channel_to_frequency(ht_oper->primary_chan,\n\t\t\t\t\t\t  channel->band);\n\t \n\tif (!tracking && channel->center_freq != ht_cfreq) {\n\t\t \n\t\tsdata_info(sdata,\n\t\t\t   \"Wrong control channel: center-freq: %d ht-cfreq: %d ht->primary_chan: %d band: %d - Disabling HT\\n\",\n\t\t\t   channel->center_freq, ht_cfreq,\n\t\t\t   ht_oper->primary_chan, channel->band);\n\t\tret = IEEE80211_CONN_DISABLE_HT |\n\t\t      IEEE80211_CONN_DISABLE_VHT |\n\t\t      IEEE80211_CONN_DISABLE_HE |\n\t\t      IEEE80211_CONN_DISABLE_EHT;\n\t\tgoto out;\n\t}\n\n\t \n\tif (sta_ht_cap.cap & IEEE80211_HT_CAP_SUP_WIDTH_20_40) {\n\t\tieee80211_chandef_ht_oper(ht_oper, chandef);\n\t} else {\n\t\tmlme_dbg(sdata, \"40 MHz not supported\\n\");\n\t\t \n\t\tret = IEEE80211_CONN_DISABLE_VHT;\n\t\t \n\t\tret |= IEEE80211_CONN_DISABLE_40MHZ;\n\t\tgoto out;\n\t}\n\n\tif (!vht_oper || !sband->vht_cap.vht_supported) {\n\t\tmlme_dbg(sdata, \"VHT operation missing / VHT not supported\\n\");\n\t\tret = IEEE80211_CONN_DISABLE_VHT;\n\t\tgoto out;\n\t}\n\n\tvht_chandef = *chandef;\n\tif (!(conn_flags & IEEE80211_CONN_DISABLE_HE) &&\n\t    he_oper &&\n\t    (le32_to_cpu(he_oper->he_oper_params) &\n\t     IEEE80211_HE_OPERATION_VHT_OPER_INFO)) {\n\t\tstruct ieee80211_vht_operation he_oper_vht_cap;\n\n\t\t \n\t\tmemcpy(&he_oper_vht_cap, he_oper->optional, 3);\n\t\the_oper_vht_cap.basic_mcs_set = cpu_to_le16(0);\n\n\t\tif (!ieee80211_chandef_vht_oper(&sdata->local->hw, vht_cap_info,\n\t\t\t\t\t\t&he_oper_vht_cap, ht_oper,\n\t\t\t\t\t\t&vht_chandef)) {\n\t\t\tif (!(conn_flags & IEEE80211_CONN_DISABLE_HE))\n\t\t\t\tsdata_info(sdata,\n\t\t\t\t\t   \"HE AP VHT information is invalid, disabling HE\\n\");\n\t\t\tret = IEEE80211_CONN_DISABLE_HE | IEEE80211_CONN_DISABLE_EHT;\n\t\t\tgoto out;\n\t\t}\n\t} else if (!ieee80211_chandef_vht_oper(&sdata->local->hw,\n\t\t\t\t\t       vht_cap_info,\n\t\t\t\t\t       vht_oper, ht_oper,\n\t\t\t\t\t       &vht_chandef)) {\n\t\tif (!(conn_flags & IEEE80211_CONN_DISABLE_VHT))\n\t\t\tsdata_info(sdata,\n\t\t\t\t   \"AP VHT information is invalid, disabling VHT\\n\");\n\t\tret = IEEE80211_CONN_DISABLE_VHT;\n\t\tgoto out;\n\t}\n\n\tif (!cfg80211_chandef_valid(&vht_chandef)) {\n\t\tif (!(conn_flags & IEEE80211_CONN_DISABLE_VHT))\n\t\t\tsdata_info(sdata,\n\t\t\t\t   \"AP VHT information is invalid, disabling VHT\\n\");\n\t\tret = IEEE80211_CONN_DISABLE_VHT;\n\t\tgoto out;\n\t}\n\n\tif (cfg80211_chandef_identical(chandef, &vht_chandef)) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tif (!cfg80211_chandef_compatible(chandef, &vht_chandef)) {\n\t\tif (!(conn_flags & IEEE80211_CONN_DISABLE_VHT))\n\t\t\tsdata_info(sdata,\n\t\t\t\t   \"AP VHT information doesn't match HT, disabling VHT\\n\");\n\t\tret = IEEE80211_CONN_DISABLE_VHT;\n\t\tgoto out;\n\t}\n\n\t*chandef = vht_chandef;\n\n\t \n\tif (eht_oper && (eht_oper->params & IEEE80211_EHT_OPER_INFO_PRESENT)) {\n\t\tstruct cfg80211_chan_def eht_chandef = *chandef;\n\n\t\tieee80211_chandef_eht_oper(eht_oper,\n\t\t\t\t\t   eht_chandef.width ==\n\t\t\t\t\t   NL80211_CHAN_WIDTH_160,\n\t\t\t\t\t   false, &eht_chandef);\n\n\t\tif (!cfg80211_chandef_valid(&eht_chandef)) {\n\t\t\tif (!(conn_flags & IEEE80211_CONN_DISABLE_EHT))\n\t\t\t\tsdata_info(sdata,\n\t\t\t\t\t   \"AP EHT information is invalid, disabling EHT\\n\");\n\t\t\tret = IEEE80211_CONN_DISABLE_EHT;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (!cfg80211_chandef_compatible(chandef, &eht_chandef)) {\n\t\t\tif (!(conn_flags & IEEE80211_CONN_DISABLE_EHT))\n\t\t\t\tsdata_info(sdata,\n\t\t\t\t\t   \"AP EHT information is incompatible, disabling EHT\\n\");\n\t\t\tret = IEEE80211_CONN_DISABLE_EHT;\n\t\t\tgoto out;\n\t\t}\n\n\t\t*chandef = eht_chandef;\n\t}\n\n\tret = 0;\n\nout:\n\t \n\tif (tracking &&\n\t    cfg80211_chandef_identical(chandef, &link->conf->chandef))\n\t\treturn ret;\n\n\t \n\tif (ret & IEEE80211_CONN_DISABLE_VHT)\n\t\tvht_chandef = *chandef;\n\n\t \n\twhile (!cfg80211_chandef_usable(sdata->local->hw.wiphy, chandef,\n\t\t\t\t\ttracking ? 0 :\n\t\t\t\t\t\t   IEEE80211_CHAN_DISABLED)) {\n\t\tif (WARN_ON(chandef->width == NL80211_CHAN_WIDTH_20_NOHT)) {\n\t\t\tret = IEEE80211_CONN_DISABLE_HT |\n\t\t\t      IEEE80211_CONN_DISABLE_VHT |\n\t\t\t      IEEE80211_CONN_DISABLE_HE |\n\t\t\t      IEEE80211_CONN_DISABLE_EHT;\n\t\t\tbreak;\n\t\t}\n\n\t\tret |= ieee80211_chandef_downgrade(chandef);\n\t}\n\n\tif (!he_oper || !cfg80211_chandef_usable(sdata->wdev.wiphy, chandef,\n\t\t\t\t\t\t IEEE80211_CHAN_NO_HE))\n\t\tret |= IEEE80211_CONN_DISABLE_HE | IEEE80211_CONN_DISABLE_EHT;\n\n\tif (!eht_oper || !cfg80211_chandef_usable(sdata->wdev.wiphy, chandef,\n\t\t\t\t\t\t  IEEE80211_CHAN_NO_EHT))\n\t\tret |= IEEE80211_CONN_DISABLE_EHT;\n\n\tif (chandef->width != vht_chandef.width && !tracking)\n\t\tsdata_info(sdata,\n\t\t\t   \"capabilities/regulatory prevented using AP HT/VHT configuration, downgraded\\n\");\n\n\tWARN_ON_ONCE(!cfg80211_chandef_valid(chandef));\n\treturn ret;\n}\n\nstatic int ieee80211_config_bw(struct ieee80211_link_data *link,\n\t\t\t       const struct ieee80211_ht_cap *ht_cap,\n\t\t\t       const struct ieee80211_vht_cap *vht_cap,\n\t\t\t       const struct ieee80211_ht_operation *ht_oper,\n\t\t\t       const struct ieee80211_vht_operation *vht_oper,\n\t\t\t       const struct ieee80211_he_operation *he_oper,\n\t\t\t       const struct ieee80211_eht_operation *eht_oper,\n\t\t\t       const struct ieee80211_s1g_oper_ie *s1g_oper,\n\t\t\t       const u8 *bssid, u64 *changed)\n{\n\tstruct ieee80211_sub_if_data *sdata = link->sdata;\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct ieee80211_if_managed *ifmgd = &sdata->u.mgd;\n\tstruct ieee80211_channel *chan = link->conf->chandef.chan;\n\tstruct ieee80211_supported_band *sband =\n\t\tlocal->hw.wiphy->bands[chan->band];\n\tstruct cfg80211_chan_def chandef;\n\tu16 ht_opmode;\n\tieee80211_conn_flags_t flags;\n\tu32 vht_cap_info = 0;\n\tint ret;\n\n\t \n\tif (link->u.mgd.conn_flags & IEEE80211_CONN_DISABLE_HT || !ht_oper)\n\t\treturn 0;\n\n\t \n\tif (link->u.mgd.conn_flags & IEEE80211_CONN_DISABLE_VHT)\n\t\tvht_oper = NULL;\n\n\t \n\tif (link->u.mgd.conn_flags & IEEE80211_CONN_DISABLE_HE ||\n\t    !ieee80211_get_he_iftype_cap_vif(sband, &sdata->vif)) {\n\t\the_oper = NULL;\n\t\teht_oper = NULL;\n\t}\n\n\t \n\tif (link->u.mgd.conn_flags & IEEE80211_CONN_DISABLE_EHT ||\n\t    !ieee80211_get_eht_iftype_cap_vif(sband, &sdata->vif))\n\t\teht_oper = NULL;\n\n\t \n\tht_opmode = le16_to_cpu(ht_oper->operation_mode);\n\tif (link->conf->ht_operation_mode != ht_opmode) {\n\t\t*changed |= BSS_CHANGED_HT;\n\t\tlink->conf->ht_operation_mode = ht_opmode;\n\t}\n\n\tif (vht_cap)\n\t\tvht_cap_info = le32_to_cpu(vht_cap->vht_cap_info);\n\n\t \n\tflags = ieee80211_determine_chantype(sdata, link,\n\t\t\t\t\t     link->u.mgd.conn_flags,\n\t\t\t\t\t     sband, chan, vht_cap_info,\n\t\t\t\t\t     ht_oper, vht_oper,\n\t\t\t\t\t     he_oper, eht_oper,\n\t\t\t\t\t     s1g_oper, &chandef, true);\n\n\t \n\tif (link->u.mgd.conn_flags & IEEE80211_CONN_DISABLE_80P80MHZ &&\n\t    chandef.width == NL80211_CHAN_WIDTH_80P80)\n\t\tflags |= ieee80211_chandef_downgrade(&chandef);\n\tif (link->u.mgd.conn_flags & IEEE80211_CONN_DISABLE_160MHZ &&\n\t    chandef.width == NL80211_CHAN_WIDTH_160)\n\t\tflags |= ieee80211_chandef_downgrade(&chandef);\n\tif (link->u.mgd.conn_flags & IEEE80211_CONN_DISABLE_40MHZ &&\n\t    chandef.width > NL80211_CHAN_WIDTH_20)\n\t\tflags |= ieee80211_chandef_downgrade(&chandef);\n\n\tif (cfg80211_chandef_identical(&chandef, &link->conf->chandef))\n\t\treturn 0;\n\n\tlink_info(link,\n\t\t  \"AP %pM changed bandwidth, new config is %d.%03d MHz, width %d (%d.%03d/%d MHz)\\n\",\n\t\t  link->u.mgd.bssid, chandef.chan->center_freq,\n\t\t  chandef.chan->freq_offset, chandef.width,\n\t\t  chandef.center_freq1, chandef.freq1_offset,\n\t\t  chandef.center_freq2);\n\n\tif (flags != (link->u.mgd.conn_flags &\n\t\t\t\t(IEEE80211_CONN_DISABLE_HT |\n\t\t\t\t IEEE80211_CONN_DISABLE_VHT |\n\t\t\t\t IEEE80211_CONN_DISABLE_HE |\n\t\t\t\t IEEE80211_CONN_DISABLE_EHT |\n\t\t\t\t IEEE80211_CONN_DISABLE_40MHZ |\n\t\t\t\t IEEE80211_CONN_DISABLE_80P80MHZ |\n\t\t\t\t IEEE80211_CONN_DISABLE_160MHZ |\n\t\t\t\t IEEE80211_CONN_DISABLE_320MHZ)) ||\n\t    !cfg80211_chandef_valid(&chandef)) {\n\t\tsdata_info(sdata,\n\t\t\t   \"AP %pM changed caps/bw in a way we can't support (0x%x/0x%x) - disconnect\\n\",\n\t\t\t   link->u.mgd.bssid, flags, ifmgd->flags);\n\t\treturn -EINVAL;\n\t}\n\n\tret = ieee80211_link_change_bandwidth(link, &chandef, changed);\n\n\tif (ret) {\n\t\tsdata_info(sdata,\n\t\t\t   \"AP %pM changed bandwidth to incompatible one - disconnect\\n\",\n\t\t\t   link->u.mgd.bssid);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n \n\nstatic void ieee80211_add_ht_ie(struct ieee80211_sub_if_data *sdata,\n\t\t\t\tstruct sk_buff *skb, u8 ap_ht_param,\n\t\t\t\tstruct ieee80211_supported_band *sband,\n\t\t\t\tstruct ieee80211_channel *channel,\n\t\t\t\tenum ieee80211_smps_mode smps,\n\t\t\t\tieee80211_conn_flags_t conn_flags)\n{\n\tu8 *pos;\n\tu32 flags = channel->flags;\n\tu16 cap;\n\tstruct ieee80211_sta_ht_cap ht_cap;\n\n\tBUILD_BUG_ON(sizeof(ht_cap) != sizeof(sband->ht_cap));\n\n\tmemcpy(&ht_cap, &sband->ht_cap, sizeof(ht_cap));\n\tieee80211_apply_htcap_overrides(sdata, &ht_cap);\n\n\t \n\tcap = ht_cap.cap;\n\n\tswitch (ap_ht_param & IEEE80211_HT_PARAM_CHA_SEC_OFFSET) {\n\tcase IEEE80211_HT_PARAM_CHA_SEC_ABOVE:\n\t\tif (flags & IEEE80211_CHAN_NO_HT40PLUS) {\n\t\t\tcap &= ~IEEE80211_HT_CAP_SUP_WIDTH_20_40;\n\t\t\tcap &= ~IEEE80211_HT_CAP_SGI_40;\n\t\t}\n\t\tbreak;\n\tcase IEEE80211_HT_PARAM_CHA_SEC_BELOW:\n\t\tif (flags & IEEE80211_CHAN_NO_HT40MINUS) {\n\t\t\tcap &= ~IEEE80211_HT_CAP_SUP_WIDTH_20_40;\n\t\t\tcap &= ~IEEE80211_HT_CAP_SGI_40;\n\t\t}\n\t\tbreak;\n\t}\n\n\t \n\tif (conn_flags & IEEE80211_CONN_DISABLE_40MHZ) {\n\t\tcap &= ~IEEE80211_HT_CAP_SUP_WIDTH_20_40;\n\t\tcap &= ~IEEE80211_HT_CAP_SGI_40;\n\t}\n\n\t \n\tcap &= ~IEEE80211_HT_CAP_SM_PS;\n\tswitch (smps) {\n\tcase IEEE80211_SMPS_AUTOMATIC:\n\tcase IEEE80211_SMPS_NUM_MODES:\n\t\tWARN_ON(1);\n\t\tfallthrough;\n\tcase IEEE80211_SMPS_OFF:\n\t\tcap |= WLAN_HT_CAP_SM_PS_DISABLED <<\n\t\t\tIEEE80211_HT_CAP_SM_PS_SHIFT;\n\t\tbreak;\n\tcase IEEE80211_SMPS_STATIC:\n\t\tcap |= WLAN_HT_CAP_SM_PS_STATIC <<\n\t\t\tIEEE80211_HT_CAP_SM_PS_SHIFT;\n\t\tbreak;\n\tcase IEEE80211_SMPS_DYNAMIC:\n\t\tcap |= WLAN_HT_CAP_SM_PS_DYNAMIC <<\n\t\t\tIEEE80211_HT_CAP_SM_PS_SHIFT;\n\t\tbreak;\n\t}\n\n\t \n\tpos = skb_put(skb, sizeof(struct ieee80211_ht_cap) + 2);\n\tieee80211_ie_build_ht_cap(pos, &ht_cap, cap);\n}\n\n \nstatic bool ieee80211_add_vht_ie(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t struct sk_buff *skb,\n\t\t\t\t struct ieee80211_supported_band *sband,\n\t\t\t\t struct ieee80211_vht_cap *ap_vht_cap,\n\t\t\t\t ieee80211_conn_flags_t conn_flags)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tu8 *pos;\n\tu32 cap;\n\tstruct ieee80211_sta_vht_cap vht_cap;\n\tu32 mask, ap_bf_sts, our_bf_sts;\n\tbool mu_mimo_owner = false;\n\n\tBUILD_BUG_ON(sizeof(vht_cap) != sizeof(sband->vht_cap));\n\n\tmemcpy(&vht_cap, &sband->vht_cap, sizeof(vht_cap));\n\tieee80211_apply_vhtcap_overrides(sdata, &vht_cap);\n\n\t \n\tcap = vht_cap.cap;\n\n\tif (conn_flags & IEEE80211_CONN_DISABLE_80P80MHZ) {\n\t\tu32 bw = cap & IEEE80211_VHT_CAP_SUPP_CHAN_WIDTH_MASK;\n\n\t\tcap &= ~IEEE80211_VHT_CAP_SUPP_CHAN_WIDTH_MASK;\n\t\tif (bw == IEEE80211_VHT_CAP_SUPP_CHAN_WIDTH_160MHZ ||\n\t\t    bw == IEEE80211_VHT_CAP_SUPP_CHAN_WIDTH_160_80PLUS80MHZ)\n\t\t\tcap |= IEEE80211_VHT_CAP_SUPP_CHAN_WIDTH_160MHZ;\n\t}\n\n\tif (conn_flags & IEEE80211_CONN_DISABLE_160MHZ) {\n\t\tcap &= ~IEEE80211_VHT_CAP_SHORT_GI_160;\n\t\tcap &= ~IEEE80211_VHT_CAP_SUPP_CHAN_WIDTH_MASK;\n\t}\n\n\t \n\tif (!(ap_vht_cap->vht_cap_info &\n\t\t\tcpu_to_le32(IEEE80211_VHT_CAP_SU_BEAMFORMER_CAPABLE)))\n\t\tcap &= ~(IEEE80211_VHT_CAP_SU_BEAMFORMEE_CAPABLE |\n\t\t\t IEEE80211_VHT_CAP_MU_BEAMFORMEE_CAPABLE);\n\telse if (!(ap_vht_cap->vht_cap_info &\n\t\t\tcpu_to_le32(IEEE80211_VHT_CAP_MU_BEAMFORMER_CAPABLE)))\n\t\tcap &= ~IEEE80211_VHT_CAP_MU_BEAMFORMEE_CAPABLE;\n\n\t \n\tif (cap & IEEE80211_VHT_CAP_MU_BEAMFORMEE_CAPABLE) {\n\t\tbool disable_mu_mimo = false;\n\t\tstruct ieee80211_sub_if_data *other;\n\n\t\tlist_for_each_entry_rcu(other, &local->interfaces, list) {\n\t\t\tif (other->vif.bss_conf.mu_mimo_owner) {\n\t\t\t\tdisable_mu_mimo = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (disable_mu_mimo)\n\t\t\tcap &= ~IEEE80211_VHT_CAP_MU_BEAMFORMEE_CAPABLE;\n\t\telse\n\t\t\tmu_mimo_owner = true;\n\t}\n\n\tmask = IEEE80211_VHT_CAP_BEAMFORMEE_STS_MASK;\n\n\tap_bf_sts = le32_to_cpu(ap_vht_cap->vht_cap_info) & mask;\n\tour_bf_sts = cap & mask;\n\n\tif (ap_bf_sts < our_bf_sts) {\n\t\tcap &= ~mask;\n\t\tcap |= ap_bf_sts;\n\t}\n\n\t \n\tpos = skb_put(skb, sizeof(struct ieee80211_vht_cap) + 2);\n\tieee80211_ie_build_vht_cap(pos, &vht_cap, cap);\n\n\treturn mu_mimo_owner;\n}\n\n \nstatic void ieee80211_add_he_ie(struct ieee80211_sub_if_data *sdata,\n\t\t\t\tstruct sk_buff *skb,\n\t\t\t\tstruct ieee80211_supported_band *sband,\n\t\t\t\tenum ieee80211_smps_mode smps_mode,\n\t\t\t\tieee80211_conn_flags_t conn_flags)\n{\n\tu8 *pos, *pre_he_pos;\n\tconst struct ieee80211_sta_he_cap *he_cap;\n\tu8 he_cap_size;\n\n\the_cap = ieee80211_get_he_iftype_cap_vif(sband, &sdata->vif);\n\tif (WARN_ON(!he_cap))\n\t\treturn;\n\n\t \n\the_cap_size =\n\t\t2 + 1 + sizeof(he_cap->he_cap_elem) +\n\t\tieee80211_he_mcs_nss_size(&he_cap->he_cap_elem) +\n\t\tieee80211_he_ppe_size(he_cap->ppe_thres[0],\n\t\t\t\t      he_cap->he_cap_elem.phy_cap_info);\n\tpos = skb_put(skb, he_cap_size);\n\tpre_he_pos = pos;\n\tpos = ieee80211_ie_build_he_cap(conn_flags,\n\t\t\t\t\tpos, he_cap, pos + he_cap_size);\n\t \n\tskb_trim(skb, skb->len - (pre_he_pos + he_cap_size - pos));\n\n\tieee80211_ie_build_he_6ghz_cap(sdata, smps_mode, skb);\n}\n\nstatic void ieee80211_add_eht_ie(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t struct sk_buff *skb,\n\t\t\t\t struct ieee80211_supported_band *sband)\n{\n\tu8 *pos;\n\tconst struct ieee80211_sta_he_cap *he_cap;\n\tconst struct ieee80211_sta_eht_cap *eht_cap;\n\tu8 eht_cap_size;\n\n\the_cap = ieee80211_get_he_iftype_cap_vif(sband, &sdata->vif);\n\teht_cap = ieee80211_get_eht_iftype_cap_vif(sband, &sdata->vif);\n\n\t \n\tif (WARN_ON(!he_cap || !eht_cap))\n\t\treturn;\n\n\teht_cap_size =\n\t\t2 + 1 + sizeof(eht_cap->eht_cap_elem) +\n\t\tieee80211_eht_mcs_nss_size(&he_cap->he_cap_elem,\n\t\t\t\t\t   &eht_cap->eht_cap_elem,\n\t\t\t\t\t   false) +\n\t\tieee80211_eht_ppe_size(eht_cap->eht_ppe_thres[0],\n\t\t\t\t       eht_cap->eht_cap_elem.phy_cap_info);\n\tpos = skb_put(skb, eht_cap_size);\n\tieee80211_ie_build_eht_cap(pos, he_cap, eht_cap, pos + eht_cap_size,\n\t\t\t\t   false);\n}\n\nstatic void ieee80211_assoc_add_rates(struct sk_buff *skb,\n\t\t\t\t      enum nl80211_chan_width width,\n\t\t\t\t      struct ieee80211_supported_band *sband,\n\t\t\t\t      struct ieee80211_mgd_assoc_data *assoc_data)\n{\n\tunsigned int shift = ieee80211_chanwidth_get_shift(width);\n\tunsigned int rates_len, supp_rates_len;\n\tu32 rates = 0;\n\tint i, count;\n\tu8 *pos;\n\n\tif (assoc_data->supp_rates_len) {\n\t\t \n\t\trates_len = ieee80211_parse_bitrates(width, sband,\n\t\t\t\t\t\t     assoc_data->supp_rates,\n\t\t\t\t\t\t     assoc_data->supp_rates_len,\n\t\t\t\t\t\t     &rates);\n\t} else {\n\t\t \n\t\trates_len = sband->n_bitrates;\n\t\tfor (i = 0; i < sband->n_bitrates; i++)\n\t\t\trates |= BIT(i);\n\t}\n\n\tsupp_rates_len = rates_len;\n\tif (supp_rates_len > 8)\n\t\tsupp_rates_len = 8;\n\n\tpos = skb_put(skb, supp_rates_len + 2);\n\t*pos++ = WLAN_EID_SUPP_RATES;\n\t*pos++ = supp_rates_len;\n\n\tcount = 0;\n\tfor (i = 0; i < sband->n_bitrates; i++) {\n\t\tif (BIT(i) & rates) {\n\t\t\tint rate = DIV_ROUND_UP(sband->bitrates[i].bitrate,\n\t\t\t\t\t\t5 * (1 << shift));\n\t\t\t*pos++ = (u8)rate;\n\t\t\tif (++count == 8)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (rates_len > count) {\n\t\tpos = skb_put(skb, rates_len - count + 2);\n\t\t*pos++ = WLAN_EID_EXT_SUPP_RATES;\n\t\t*pos++ = rates_len - count;\n\n\t\tfor (i++; i < sband->n_bitrates; i++) {\n\t\t\tif (BIT(i) & rates) {\n\t\t\t\tint rate;\n\n\t\t\t\trate = DIV_ROUND_UP(sband->bitrates[i].bitrate,\n\t\t\t\t\t\t    5 * (1 << shift));\n\t\t\t\t*pos++ = (u8)rate;\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic size_t ieee80211_add_before_ht_elems(struct sk_buff *skb,\n\t\t\t\t\t    const u8 *elems,\n\t\t\t\t\t    size_t elems_len,\n\t\t\t\t\t    size_t offset)\n{\n\tsize_t noffset;\n\n\tstatic const u8 before_ht[] = {\n\t\tWLAN_EID_SSID,\n\t\tWLAN_EID_SUPP_RATES,\n\t\tWLAN_EID_EXT_SUPP_RATES,\n\t\tWLAN_EID_PWR_CAPABILITY,\n\t\tWLAN_EID_SUPPORTED_CHANNELS,\n\t\tWLAN_EID_RSN,\n\t\tWLAN_EID_QOS_CAPA,\n\t\tWLAN_EID_RRM_ENABLED_CAPABILITIES,\n\t\tWLAN_EID_MOBILITY_DOMAIN,\n\t\tWLAN_EID_FAST_BSS_TRANSITION,\t \n\t\tWLAN_EID_RIC_DATA,\t\t \n\t\tWLAN_EID_SUPPORTED_REGULATORY_CLASSES,\n\t};\n\tstatic const u8 after_ric[] = {\n\t\tWLAN_EID_SUPPORTED_REGULATORY_CLASSES,\n\t\tWLAN_EID_HT_CAPABILITY,\n\t\tWLAN_EID_BSS_COEX_2040,\n\t\t \n\t\tWLAN_EID_EXT_CAPABILITY,\n\t\tWLAN_EID_QOS_TRAFFIC_CAPA,\n\t\tWLAN_EID_TIM_BCAST_REQ,\n\t\tWLAN_EID_INTERWORKING,\n\t\t \n\t\tWLAN_EID_VHT_CAPABILITY,\n\t\tWLAN_EID_OPMODE_NOTIF,\n\t};\n\n\tif (!elems_len)\n\t\treturn offset;\n\n\tnoffset = ieee80211_ie_split_ric(elems, elems_len,\n\t\t\t\t\t before_ht,\n\t\t\t\t\t ARRAY_SIZE(before_ht),\n\t\t\t\t\t after_ric,\n\t\t\t\t\t ARRAY_SIZE(after_ric),\n\t\t\t\t\t offset);\n\tskb_put_data(skb, elems + offset, noffset - offset);\n\n\treturn noffset;\n}\n\nstatic size_t ieee80211_add_before_vht_elems(struct sk_buff *skb,\n\t\t\t\t\t     const u8 *elems,\n\t\t\t\t\t     size_t elems_len,\n\t\t\t\t\t     size_t offset)\n{\n\tstatic const u8 before_vht[] = {\n\t\t \n\t\tWLAN_EID_BSS_COEX_2040,\n\t\tWLAN_EID_EXT_CAPABILITY,\n\t\tWLAN_EID_QOS_TRAFFIC_CAPA,\n\t\tWLAN_EID_TIM_BCAST_REQ,\n\t\tWLAN_EID_INTERWORKING,\n\t\t \n\t};\n\tsize_t noffset;\n\n\tif (!elems_len)\n\t\treturn offset;\n\n\t \n\tnoffset = ieee80211_ie_split(elems, elems_len,\n\t\t\t\t     before_vht, ARRAY_SIZE(before_vht),\n\t\t\t\t     offset);\n\tskb_put_data(skb, elems + offset, noffset - offset);\n\n\treturn noffset;\n}\n\nstatic size_t ieee80211_add_before_he_elems(struct sk_buff *skb,\n\t\t\t\t\t    const u8 *elems,\n\t\t\t\t\t    size_t elems_len,\n\t\t\t\t\t    size_t offset)\n{\n\tstatic const u8 before_he[] = {\n\t\t \n\t\tWLAN_EID_OPMODE_NOTIF,\n\t\tWLAN_EID_EXTENSION, WLAN_EID_EXT_FUTURE_CHAN_GUIDANCE,\n\t\t \n\t\tWLAN_EID_EXTENSION, WLAN_EID_EXT_FILS_SESSION,\n\t\tWLAN_EID_EXTENSION, WLAN_EID_EXT_FILS_PUBLIC_KEY,\n\t\tWLAN_EID_EXTENSION, WLAN_EID_EXT_FILS_KEY_CONFIRM,\n\t\tWLAN_EID_EXTENSION, WLAN_EID_EXT_FILS_HLP_CONTAINER,\n\t\tWLAN_EID_EXTENSION, WLAN_EID_EXT_FILS_IP_ADDR_ASSIGN,\n\t\t \n\t};\n\tsize_t noffset;\n\n\tif (!elems_len)\n\t\treturn offset;\n\n\t \n\tnoffset = ieee80211_ie_split(elems, elems_len,\n\t\t\t\t     before_he, ARRAY_SIZE(before_he),\n\t\t\t\t     offset);\n\tskb_put_data(skb, elems + offset, noffset - offset);\n\n\treturn noffset;\n}\n\n#define PRESENT_ELEMS_MAX\t8\n#define PRESENT_ELEM_EXT_OFFS\t0x100\n\nstatic void ieee80211_assoc_add_ml_elem(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t\tstruct sk_buff *skb, u16 capab,\n\t\t\t\t\tconst struct element *ext_capa,\n\t\t\t\t\tconst u16 *present_elems);\n\nstatic size_t ieee80211_assoc_link_elems(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t\t struct sk_buff *skb, u16 *capab,\n\t\t\t\t\t const struct element *ext_capa,\n\t\t\t\t\t const u8 *extra_elems,\n\t\t\t\t\t size_t extra_elems_len,\n\t\t\t\t\t unsigned int link_id,\n\t\t\t\t\t struct ieee80211_link_data *link,\n\t\t\t\t\t u16 *present_elems)\n{\n\tenum nl80211_iftype iftype = ieee80211_vif_type_p2p(&sdata->vif);\n\tstruct ieee80211_if_managed *ifmgd = &sdata->u.mgd;\n\tstruct ieee80211_mgd_assoc_data *assoc_data = ifmgd->assoc_data;\n\tstruct cfg80211_bss *cbss = assoc_data->link[link_id].bss;\n\tstruct ieee80211_channel *chan = cbss->channel;\n\tconst struct ieee80211_sband_iftype_data *iftd;\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct ieee80211_supported_band *sband;\n\tenum nl80211_chan_width width = NL80211_CHAN_WIDTH_20;\n\tstruct ieee80211_chanctx_conf *chanctx_conf;\n\tenum ieee80211_smps_mode smps_mode;\n\tu16 orig_capab = *capab;\n\tsize_t offset = 0;\n\tint present_elems_len = 0;\n\tu8 *pos;\n\tint i;\n\n#define ADD_PRESENT_ELEM(id) do {\t\t\t\t\t\\\n\t \t\t\\\n\tif (!WARN_ON(present_elems_len >= PRESENT_ELEMS_MAX - 1))\t\\\n\t\tpresent_elems[present_elems_len++] = (id);\t\t\\\n} while (0)\n#define ADD_PRESENT_EXT_ELEM(id) ADD_PRESENT_ELEM(PRESENT_ELEM_EXT_OFFS | (id))\n\n\tif (link)\n\t\tsmps_mode = link->smps_mode;\n\telse if (sdata->u.mgd.powersave)\n\t\tsmps_mode = IEEE80211_SMPS_DYNAMIC;\n\telse\n\t\tsmps_mode = IEEE80211_SMPS_OFF;\n\n\tif (link) {\n\t\t \n\t\trcu_read_lock();\n\t\tchanctx_conf = rcu_dereference(link->conf->chanctx_conf);\n\t\tif (chanctx_conf)\n\t\t\twidth = chanctx_conf->def.width;\n\t\trcu_read_unlock();\n\t}\n\n\tsband = local->hw.wiphy->bands[chan->band];\n\tiftd = ieee80211_get_sband_iftype_data(sband, iftype);\n\n\tif (sband->band == NL80211_BAND_2GHZ) {\n\t\t*capab |= WLAN_CAPABILITY_SHORT_SLOT_TIME;\n\t\t*capab |= WLAN_CAPABILITY_SHORT_PREAMBLE;\n\t}\n\n\tif ((cbss->capability & WLAN_CAPABILITY_SPECTRUM_MGMT) &&\n\t    ieee80211_hw_check(&local->hw, SPECTRUM_MGMT))\n\t\t*capab |= WLAN_CAPABILITY_SPECTRUM_MGMT;\n\n\tif (sband->band != NL80211_BAND_S1GHZ)\n\t\tieee80211_assoc_add_rates(skb, width, sband, assoc_data);\n\n\tif (*capab & WLAN_CAPABILITY_SPECTRUM_MGMT ||\n\t    *capab & WLAN_CAPABILITY_RADIO_MEASURE) {\n\t\tstruct cfg80211_chan_def chandef = {\n\t\t\t.width = width,\n\t\t\t.chan = chan,\n\t\t};\n\n\t\tpos = skb_put(skb, 4);\n\t\t*pos++ = WLAN_EID_PWR_CAPABILITY;\n\t\t*pos++ = 2;\n\t\t*pos++ = 0;  \n\t\t  \n\t\t*pos++ = ieee80211_chandef_max_power(&chandef);\n\t\tADD_PRESENT_ELEM(WLAN_EID_PWR_CAPABILITY);\n\t}\n\n\t \n\tif (*capab & WLAN_CAPABILITY_SPECTRUM_MGMT &&\n\t    (sband->band != NL80211_BAND_6GHZ ||\n\t     !ext_capa || ext_capa->datalen < 1 ||\n\t     !(ext_capa->data[0] & WLAN_EXT_CAPA1_EXT_CHANNEL_SWITCHING))) {\n\t\t \n\t\tpos = skb_put(skb, 2 * sband->n_channels + 2);\n\t\t*pos++ = WLAN_EID_SUPPORTED_CHANNELS;\n\t\t*pos++ = 2 * sband->n_channels;\n\t\tfor (i = 0; i < sband->n_channels; i++) {\n\t\t\tint cf = sband->channels[i].center_freq;\n\n\t\t\t*pos++ = ieee80211_frequency_to_channel(cf);\n\t\t\t*pos++ = 1;  \n\t\t}\n\t\tADD_PRESENT_ELEM(WLAN_EID_SUPPORTED_CHANNELS);\n\t}\n\n\t \n\toffset = ieee80211_add_before_ht_elems(skb, extra_elems,\n\t\t\t\t\t       extra_elems_len,\n\t\t\t\t\t       offset);\n\n\tif (sband->band != NL80211_BAND_6GHZ &&\n\t    !(assoc_data->link[link_id].conn_flags & IEEE80211_CONN_DISABLE_HT)) {\n\t\tieee80211_add_ht_ie(sdata, skb,\n\t\t\t\t    assoc_data->link[link_id].ap_ht_param,\n\t\t\t\t    sband, chan, smps_mode,\n\t\t\t\t    assoc_data->link[link_id].conn_flags);\n\t\tADD_PRESENT_ELEM(WLAN_EID_HT_CAPABILITY);\n\t}\n\n\t \n\toffset = ieee80211_add_before_vht_elems(skb, extra_elems,\n\t\t\t\t\t\textra_elems_len,\n\t\t\t\t\t\toffset);\n\n\tif (sband->band != NL80211_BAND_6GHZ &&\n\t    !(assoc_data->link[link_id].conn_flags & IEEE80211_CONN_DISABLE_VHT)) {\n\t\tbool mu_mimo_owner =\n\t\t\tieee80211_add_vht_ie(sdata, skb, sband,\n\t\t\t\t\t     &assoc_data->link[link_id].ap_vht_cap,\n\t\t\t\t\t     assoc_data->link[link_id].conn_flags);\n\n\t\tif (link)\n\t\t\tlink->conf->mu_mimo_owner = mu_mimo_owner;\n\t\tADD_PRESENT_ELEM(WLAN_EID_VHT_CAPABILITY);\n\t}\n\n\t \n\tif (assoc_data->link[link_id].conn_flags & IEEE80211_CONN_DISABLE_HT ||\n\t    (sband->band == NL80211_BAND_5GHZ &&\n\t     assoc_data->link[link_id].conn_flags & IEEE80211_CONN_DISABLE_VHT))\n\t\tassoc_data->link[link_id].conn_flags |=\n\t\t\tIEEE80211_CONN_DISABLE_HE |\n\t\t\tIEEE80211_CONN_DISABLE_EHT;\n\n\t \n\toffset = ieee80211_add_before_he_elems(skb, extra_elems,\n\t\t\t\t\t       extra_elems_len,\n\t\t\t\t\t       offset);\n\n\tif (!(assoc_data->link[link_id].conn_flags & IEEE80211_CONN_DISABLE_HE)) {\n\t\tieee80211_add_he_ie(sdata, skb, sband, smps_mode,\n\t\t\t\t    assoc_data->link[link_id].conn_flags);\n\t\tADD_PRESENT_EXT_ELEM(WLAN_EID_EXT_HE_CAPABILITY);\n\t}\n\n\t \n\tif (!(assoc_data->link[link_id].conn_flags & IEEE80211_CONN_DISABLE_EHT))\n\t\tADD_PRESENT_EXT_ELEM(WLAN_EID_EXT_EHT_CAPABILITY);\n\n\tif (link_id == assoc_data->assoc_link_id)\n\t\tieee80211_assoc_add_ml_elem(sdata, skb, orig_capab, ext_capa,\n\t\t\t\t\t    present_elems);\n\n\t \n\tpresent_elems = NULL;\n\n\tif (!(assoc_data->link[link_id].conn_flags & IEEE80211_CONN_DISABLE_EHT))\n\t\tieee80211_add_eht_ie(sdata, skb, sband);\n\n\tif (sband->band == NL80211_BAND_S1GHZ) {\n\t\tieee80211_add_aid_request_ie(sdata, skb);\n\t\tieee80211_add_s1g_capab_ie(sdata, &sband->s1g_cap, skb);\n\t}\n\n\tif (iftd && iftd->vendor_elems.data && iftd->vendor_elems.len)\n\t\tskb_put_data(skb, iftd->vendor_elems.data, iftd->vendor_elems.len);\n\n\tif (link)\n\t\tlink->u.mgd.conn_flags = assoc_data->link[link_id].conn_flags;\n\n\treturn offset;\n}\n\nstatic void ieee80211_add_non_inheritance_elem(struct sk_buff *skb,\n\t\t\t\t\t       const u16 *outer,\n\t\t\t\t\t       const u16 *inner)\n{\n\tunsigned int skb_len = skb->len;\n\tbool at_extension = false;\n\tbool added = false;\n\tint i, j;\n\tu8 *len, *list_len = NULL;\n\n\tskb_put_u8(skb, WLAN_EID_EXTENSION);\n\tlen = skb_put(skb, 1);\n\tskb_put_u8(skb, WLAN_EID_EXT_NON_INHERITANCE);\n\n\tfor (i = 0; i < PRESENT_ELEMS_MAX && outer[i]; i++) {\n\t\tu16 elem = outer[i];\n\t\tbool have_inner = false;\n\n\t\t \n\t\tWARN_ON(at_extension && elem < PRESENT_ELEM_EXT_OFFS);\n\n\t\t \n\t\tif (!at_extension && elem >= PRESENT_ELEM_EXT_OFFS) {\n\t\t\tat_extension = true;\n\t\t\tif (!list_len)\n\t\t\t\tskb_put_u8(skb, 0);\n\t\t\tlist_len = NULL;\n\t\t}\n\n\t\tfor (j = 0; j < PRESENT_ELEMS_MAX && inner[j]; j++) {\n\t\t\tif (elem == inner[j]) {\n\t\t\t\thave_inner = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (have_inner)\n\t\t\tcontinue;\n\n\t\tif (!list_len) {\n\t\t\tlist_len = skb_put(skb, 1);\n\t\t\t*list_len = 0;\n\t\t}\n\t\t*list_len += 1;\n\t\tskb_put_u8(skb, (u8)elem);\n\t\tadded = true;\n\t}\n\n\t \n\tif (added && (!at_extension || !list_len))\n\t\tskb_put_u8(skb, 0);\n\n\t \n\tif (!added)\n\t\tskb_trim(skb, skb_len);\n\telse\n\t\t*len = skb->len - skb_len - 2;\n}\n\nstatic void ieee80211_assoc_add_ml_elem(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t\tstruct sk_buff *skb, u16 capab,\n\t\t\t\t\tconst struct element *ext_capa,\n\t\t\t\t\tconst u16 *outer_present_elems)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct ieee80211_if_managed *ifmgd = &sdata->u.mgd;\n\tstruct ieee80211_mgd_assoc_data *assoc_data = ifmgd->assoc_data;\n\tstruct ieee80211_multi_link_elem *ml_elem;\n\tstruct ieee80211_mle_basic_common_info *common;\n\tconst struct wiphy_iftype_ext_capab *ift_ext_capa;\n\t__le16 eml_capa = 0, mld_capa_ops = 0;\n\tunsigned int link_id;\n\tu8 *ml_elem_len;\n\tvoid *capab_pos;\n\n\tif (!ieee80211_vif_is_mld(&sdata->vif))\n\t\treturn;\n\n\tift_ext_capa = cfg80211_get_iftype_ext_capa(local->hw.wiphy,\n\t\t\t\t\t\t    ieee80211_vif_type_p2p(&sdata->vif));\n\tif (ift_ext_capa) {\n\t\teml_capa = cpu_to_le16(ift_ext_capa->eml_capabilities);\n\t\tmld_capa_ops = cpu_to_le16(ift_ext_capa->mld_capa_and_ops);\n\t}\n\n\tskb_put_u8(skb, WLAN_EID_EXTENSION);\n\tml_elem_len = skb_put(skb, 1);\n\tskb_put_u8(skb, WLAN_EID_EXT_EHT_MULTI_LINK);\n\tml_elem = skb_put(skb, sizeof(*ml_elem));\n\tml_elem->control =\n\t\tcpu_to_le16(IEEE80211_ML_CONTROL_TYPE_BASIC |\n\t\t\t    IEEE80211_MLC_BASIC_PRES_MLD_CAPA_OP);\n\tcommon = skb_put(skb, sizeof(*common));\n\tcommon->len = sizeof(*common) +\n\t\t      2;   \n\tmemcpy(common->mld_mac_addr, sdata->vif.addr, ETH_ALEN);\n\n\t \n\tif (eml_capa &\n\t    cpu_to_le16((IEEE80211_EML_CAP_EMLSR_SUPP |\n\t\t\t IEEE80211_EML_CAP_EMLMR_SUPPORT))) {\n\t\tcommon->len += 2;  \n\t\tml_elem->control |=\n\t\t\tcpu_to_le16(IEEE80211_MLC_BASIC_PRES_EML_CAPA);\n\t\tskb_put_data(skb, &eml_capa, sizeof(eml_capa));\n\t}\n\t \n\tmld_capa_ops &= ~cpu_to_le16(IEEE80211_MLD_CAP_OP_TID_TO_LINK_MAP_NEG_SUPP);\n\tskb_put_data(skb, &mld_capa_ops, sizeof(mld_capa_ops));\n\n\tfor (link_id = 0; link_id < IEEE80211_MLD_MAX_NUM_LINKS; link_id++) {\n\t\tu16 link_present_elems[PRESENT_ELEMS_MAX] = {};\n\t\tconst u8 *extra_elems;\n\t\tsize_t extra_elems_len;\n\t\tsize_t extra_used;\n\t\tu8 *subelem_len = NULL;\n\t\t__le16 ctrl;\n\n\t\tif (!assoc_data->link[link_id].bss ||\n\t\t    link_id == assoc_data->assoc_link_id)\n\t\t\tcontinue;\n\n\t\textra_elems = assoc_data->link[link_id].elems;\n\t\textra_elems_len = assoc_data->link[link_id].elems_len;\n\n\t\tskb_put_u8(skb, IEEE80211_MLE_SUBELEM_PER_STA_PROFILE);\n\t\tsubelem_len = skb_put(skb, 1);\n\n\t\tctrl = cpu_to_le16(link_id |\n\t\t\t\t   IEEE80211_MLE_STA_CONTROL_COMPLETE_PROFILE |\n\t\t\t\t   IEEE80211_MLE_STA_CONTROL_STA_MAC_ADDR_PRESENT);\n\t\tskb_put_data(skb, &ctrl, sizeof(ctrl));\n\t\tskb_put_u8(skb, 1 + ETH_ALEN);  \n\t\tskb_put_data(skb, assoc_data->link[link_id].addr,\n\t\t\t     ETH_ALEN);\n\t\t \n\t\tcapab_pos = skb_put(skb, 2);\n\n\t\textra_used = ieee80211_assoc_link_elems(sdata, skb, &capab,\n\t\t\t\t\t\t\text_capa,\n\t\t\t\t\t\t\textra_elems,\n\t\t\t\t\t\t\textra_elems_len,\n\t\t\t\t\t\t\tlink_id, NULL,\n\t\t\t\t\t\t\tlink_present_elems);\n\t\tif (extra_elems)\n\t\t\tskb_put_data(skb, extra_elems + extra_used,\n\t\t\t\t     extra_elems_len - extra_used);\n\n\t\tput_unaligned_le16(capab, capab_pos);\n\n\t\tieee80211_add_non_inheritance_elem(skb, outer_present_elems,\n\t\t\t\t\t\t   link_present_elems);\n\n\t\tieee80211_fragment_element(skb, subelem_len,\n\t\t\t\t\t   IEEE80211_MLE_SUBELEM_FRAGMENT);\n\t}\n\n\tieee80211_fragment_element(skb, ml_elem_len, WLAN_EID_FRAGMENT);\n}\n\nstatic int ieee80211_send_assoc(struct ieee80211_sub_if_data *sdata)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct ieee80211_if_managed *ifmgd = &sdata->u.mgd;\n\tstruct ieee80211_mgd_assoc_data *assoc_data = ifmgd->assoc_data;\n\tstruct ieee80211_link_data *link;\n\tstruct sk_buff *skb;\n\tstruct ieee80211_mgmt *mgmt;\n\tu8 *pos, qos_info, *ie_start;\n\tsize_t offset, noffset;\n\tu16 capab = WLAN_CAPABILITY_ESS, link_capab;\n\t__le16 listen_int;\n\tstruct element *ext_capa = NULL;\n\tenum nl80211_iftype iftype = ieee80211_vif_type_p2p(&sdata->vif);\n\tstruct ieee80211_prep_tx_info info = {};\n\tunsigned int link_id, n_links = 0;\n\tu16 present_elems[PRESENT_ELEMS_MAX] = {};\n\tvoid *capab_pos;\n\tsize_t size;\n\tint ret;\n\n\t \n\tif (assoc_data->ie_len)\n\t\text_capa = (void *)cfg80211_find_elem(WLAN_EID_EXT_CAPABILITY,\n\t\t\t\t\t\t      assoc_data->ie,\n\t\t\t\t\t\t      assoc_data->ie_len);\n\n\tsdata_assert_lock(sdata);\n\n\tsize = local->hw.extra_tx_headroom +\n\t       sizeof(*mgmt) +  \n\t       2 + assoc_data->ssid_len +  \n\t       assoc_data->ie_len +  \n\t       (assoc_data->fils_kek_len ? 16   : 0) +\n\t       9;  \n\n\tfor (link_id = 0; link_id < IEEE80211_MLD_MAX_NUM_LINKS; link_id++) {\n\t\tstruct cfg80211_bss *cbss = assoc_data->link[link_id].bss;\n\t\tconst struct ieee80211_sband_iftype_data *iftd;\n\t\tstruct ieee80211_supported_band *sband;\n\n\t\tif (!cbss)\n\t\t\tcontinue;\n\n\t\tsband = local->hw.wiphy->bands[cbss->channel->band];\n\n\t\tn_links++;\n\t\t \n\t\tsize += assoc_data->link[link_id].elems_len;\n\t\t \n\t\tsize += 4 + sband->n_bitrates;\n\t\t \n\t\tsize += 2 + 2 * sband->n_channels;\n\n\t\tiftd = ieee80211_get_sband_iftype_data(sband, iftype);\n\t\tif (iftd)\n\t\t\tsize += iftd->vendor_elems.len;\n\n\t\t \n\t\tsize += 4;\n\n\t\t \n\t\tsize += 2 + sizeof(struct ieee80211_ht_cap);\n\t\tsize += 2 + sizeof(struct ieee80211_vht_cap);\n\t\tsize += 2 + 1 + sizeof(struct ieee80211_he_cap_elem) +\n\t\t\tsizeof(struct ieee80211_he_mcs_nss_supp) +\n\t\t\tIEEE80211_HE_PPE_THRES_MAX_LEN;\n\n\t\tif (sband->band == NL80211_BAND_6GHZ)\n\t\t\tsize += 2 + 1 + sizeof(struct ieee80211_he_6ghz_capa);\n\n\t\tsize += 2 + 1 + sizeof(struct ieee80211_eht_cap_elem) +\n\t\t\tsizeof(struct ieee80211_eht_mcs_nss_supp) +\n\t\t\tIEEE80211_EHT_PPE_THRES_MAX_LEN;\n\n\t\t \n\t\tsize += 2 + 2 + PRESENT_ELEMS_MAX;\n\n\t\t \n\t\tif (cbss->capability & WLAN_CAPABILITY_PRIVACY)\n\t\t\tcapab |= WLAN_CAPABILITY_PRIVACY;\n\t}\n\n\tif (ieee80211_vif_is_mld(&sdata->vif)) {\n\t\t \n\t\tsize += sizeof(struct ieee80211_multi_link_elem);\n\t\t \n\t\tsize += sizeof(struct ieee80211_mle_basic_common_info) +\n\t\t\t2 +  \n\t\t\t2;  \n\n\t\t \n\t\tsize += (n_links - 1) *\n\t\t\t(1 + 1 +  \n\t\t\t 2 +  \n\t\t\t 1 + ETH_ALEN + 2  );\n\t}\n\n\tlink = sdata_dereference(sdata->link[assoc_data->assoc_link_id], sdata);\n\tif (WARN_ON(!link))\n\t\treturn -EINVAL;\n\n\tif (WARN_ON(!assoc_data->link[assoc_data->assoc_link_id].bss))\n\t\treturn -EINVAL;\n\n\tskb = alloc_skb(size, GFP_KERNEL);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tskb_reserve(skb, local->hw.extra_tx_headroom);\n\n\tif (ifmgd->flags & IEEE80211_STA_ENABLE_RRM)\n\t\tcapab |= WLAN_CAPABILITY_RADIO_MEASURE;\n\n\t \n\tif (ieee80211_hw_check(&local->hw, SUPPORTS_ONLY_HE_MULTI_BSSID) &&\n\t    !(link->u.mgd.conn_flags & IEEE80211_CONN_DISABLE_HE) &&\n\t    ext_capa && ext_capa->datalen >= 3)\n\t\text_capa->data[2] |= WLAN_EXT_CAPA3_MULTI_BSSID_SUPPORT;\n\n\tmgmt = skb_put_zero(skb, 24);\n\tmemcpy(mgmt->da, sdata->vif.cfg.ap_addr, ETH_ALEN);\n\tmemcpy(mgmt->sa, sdata->vif.addr, ETH_ALEN);\n\tmemcpy(mgmt->bssid, sdata->vif.cfg.ap_addr, ETH_ALEN);\n\n\tlisten_int = cpu_to_le16(assoc_data->s1g ?\n\t\t\tieee80211_encode_usf(local->hw.conf.listen_interval) :\n\t\t\tlocal->hw.conf.listen_interval);\n\tif (!is_zero_ether_addr(assoc_data->prev_ap_addr)) {\n\t\tskb_put(skb, 10);\n\t\tmgmt->frame_control = cpu_to_le16(IEEE80211_FTYPE_MGMT |\n\t\t\t\t\t\t  IEEE80211_STYPE_REASSOC_REQ);\n\t\tcapab_pos = &mgmt->u.reassoc_req.capab_info;\n\t\tmgmt->u.reassoc_req.listen_interval = listen_int;\n\t\tmemcpy(mgmt->u.reassoc_req.current_ap,\n\t\t       assoc_data->prev_ap_addr, ETH_ALEN);\n\t\tinfo.subtype = IEEE80211_STYPE_REASSOC_REQ;\n\t} else {\n\t\tskb_put(skb, 4);\n\t\tmgmt->frame_control = cpu_to_le16(IEEE80211_FTYPE_MGMT |\n\t\t\t\t\t\t  IEEE80211_STYPE_ASSOC_REQ);\n\t\tcapab_pos = &mgmt->u.assoc_req.capab_info;\n\t\tmgmt->u.assoc_req.listen_interval = listen_int;\n\t\tinfo.subtype = IEEE80211_STYPE_ASSOC_REQ;\n\t}\n\n\t \n\tpos = skb_put(skb, 2 + assoc_data->ssid_len);\n\tie_start = pos;\n\t*pos++ = WLAN_EID_SSID;\n\t*pos++ = assoc_data->ssid_len;\n\tmemcpy(pos, assoc_data->ssid, assoc_data->ssid_len);\n\n\t \n\tlink_capab = capab;\n\toffset = ieee80211_assoc_link_elems(sdata, skb, &link_capab,\n\t\t\t\t\t    ext_capa,\n\t\t\t\t\t    assoc_data->ie,\n\t\t\t\t\t    assoc_data->ie_len,\n\t\t\t\t\t    assoc_data->assoc_link_id, link,\n\t\t\t\t\t    present_elems);\n\tput_unaligned_le16(link_capab, capab_pos);\n\n\t \n\tif (assoc_data->ie_len) {\n\t\tnoffset = ieee80211_ie_split_vendor(assoc_data->ie,\n\t\t\t\t\t\t    assoc_data->ie_len,\n\t\t\t\t\t\t    offset);\n\t\tskb_put_data(skb, assoc_data->ie + offset, noffset - offset);\n\t\toffset = noffset;\n\t}\n\n\tif (assoc_data->wmm) {\n\t\tif (assoc_data->uapsd) {\n\t\t\tqos_info = ifmgd->uapsd_queues;\n\t\t\tqos_info |= (ifmgd->uapsd_max_sp_len <<\n\t\t\t\t     IEEE80211_WMM_IE_STA_QOSINFO_SP_SHIFT);\n\t\t} else {\n\t\t\tqos_info = 0;\n\t\t}\n\n\t\tpos = ieee80211_add_wmm_info_ie(skb_put(skb, 9), qos_info);\n\t}\n\n\t \n\tif (assoc_data->ie_len) {\n\t\tnoffset = assoc_data->ie_len;\n\t\tskb_put_data(skb, assoc_data->ie + offset, noffset - offset);\n\t}\n\n\tif (assoc_data->fils_kek_len) {\n\t\tret = fils_encrypt_assoc_req(skb, assoc_data);\n\t\tif (ret < 0) {\n\t\t\tdev_kfree_skb(skb);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tpos = skb_tail_pointer(skb);\n\tkfree(ifmgd->assoc_req_ies);\n\tifmgd->assoc_req_ies = kmemdup(ie_start, pos - ie_start, GFP_ATOMIC);\n\tif (!ifmgd->assoc_req_ies) {\n\t\tdev_kfree_skb(skb);\n\t\treturn -ENOMEM;\n\t}\n\n\tifmgd->assoc_req_ies_len = pos - ie_start;\n\n\tdrv_mgd_prepare_tx(local, sdata, &info);\n\n\tIEEE80211_SKB_CB(skb)->flags |= IEEE80211_TX_INTFL_DONT_ENCRYPT;\n\tif (ieee80211_hw_check(&local->hw, REPORTS_TX_ACK_STATUS))\n\t\tIEEE80211_SKB_CB(skb)->flags |= IEEE80211_TX_CTL_REQ_TX_STATUS |\n\t\t\t\t\t\tIEEE80211_TX_INTFL_MLME_CONN_TX;\n\tieee80211_tx_skb(sdata, skb);\n\n\treturn 0;\n}\n\nvoid ieee80211_send_pspoll(struct ieee80211_local *local,\n\t\t\t   struct ieee80211_sub_if_data *sdata)\n{\n\tstruct ieee80211_pspoll *pspoll;\n\tstruct sk_buff *skb;\n\n\tskb = ieee80211_pspoll_get(&local->hw, &sdata->vif);\n\tif (!skb)\n\t\treturn;\n\n\tpspoll = (struct ieee80211_pspoll *) skb->data;\n\tpspoll->frame_control |= cpu_to_le16(IEEE80211_FCTL_PM);\n\n\tIEEE80211_SKB_CB(skb)->flags |= IEEE80211_TX_INTFL_DONT_ENCRYPT;\n\tieee80211_tx_skb(sdata, skb);\n}\n\nvoid ieee80211_send_nullfunc(struct ieee80211_local *local,\n\t\t\t     struct ieee80211_sub_if_data *sdata,\n\t\t\t     bool powersave)\n{\n\tstruct sk_buff *skb;\n\tstruct ieee80211_hdr_3addr *nullfunc;\n\tstruct ieee80211_if_managed *ifmgd = &sdata->u.mgd;\n\n\tskb = ieee80211_nullfunc_get(&local->hw, &sdata->vif, -1,\n\t\t\t\t     !ieee80211_hw_check(&local->hw,\n\t\t\t\t\t\t\t DOESNT_SUPPORT_QOS_NDP));\n\tif (!skb)\n\t\treturn;\n\n\tnullfunc = (struct ieee80211_hdr_3addr *) skb->data;\n\tif (powersave)\n\t\tnullfunc->frame_control |= cpu_to_le16(IEEE80211_FCTL_PM);\n\n\tIEEE80211_SKB_CB(skb)->flags |= IEEE80211_TX_INTFL_DONT_ENCRYPT |\n\t\t\t\t\tIEEE80211_TX_INTFL_OFFCHAN_TX_OK;\n\n\tif (ieee80211_hw_check(&local->hw, REPORTS_TX_ACK_STATUS))\n\t\tIEEE80211_SKB_CB(skb)->flags |= IEEE80211_TX_CTL_REQ_TX_STATUS;\n\n\tif (ifmgd->flags & IEEE80211_STA_CONNECTION_POLL)\n\t\tIEEE80211_SKB_CB(skb)->flags |= IEEE80211_TX_CTL_USE_MINRATE;\n\n\tieee80211_tx_skb(sdata, skb);\n}\n\nvoid ieee80211_send_4addr_nullfunc(struct ieee80211_local *local,\n\t\t\t\t   struct ieee80211_sub_if_data *sdata)\n{\n\tstruct sk_buff *skb;\n\tstruct ieee80211_hdr *nullfunc;\n\t__le16 fc;\n\n\tif (WARN_ON(sdata->vif.type != NL80211_IFTYPE_STATION))\n\t\treturn;\n\n\tskb = dev_alloc_skb(local->hw.extra_tx_headroom + 30);\n\tif (!skb)\n\t\treturn;\n\n\tskb_reserve(skb, local->hw.extra_tx_headroom);\n\n\tnullfunc = skb_put_zero(skb, 30);\n\tfc = cpu_to_le16(IEEE80211_FTYPE_DATA | IEEE80211_STYPE_NULLFUNC |\n\t\t\t IEEE80211_FCTL_FROMDS | IEEE80211_FCTL_TODS);\n\tnullfunc->frame_control = fc;\n\tmemcpy(nullfunc->addr1, sdata->deflink.u.mgd.bssid, ETH_ALEN);\n\tmemcpy(nullfunc->addr2, sdata->vif.addr, ETH_ALEN);\n\tmemcpy(nullfunc->addr3, sdata->deflink.u.mgd.bssid, ETH_ALEN);\n\tmemcpy(nullfunc->addr4, sdata->vif.addr, ETH_ALEN);\n\n\tIEEE80211_SKB_CB(skb)->flags |= IEEE80211_TX_INTFL_DONT_ENCRYPT;\n\tIEEE80211_SKB_CB(skb)->flags |= IEEE80211_TX_CTL_USE_MINRATE;\n\tieee80211_tx_skb(sdata, skb);\n}\n\n \nstatic void ieee80211_chswitch_work(struct wiphy *wiphy,\n\t\t\t\t    struct wiphy_work *work)\n{\n\tstruct ieee80211_link_data *link =\n\t\tcontainer_of(work, struct ieee80211_link_data,\n\t\t\t     u.mgd.chswitch_work.work);\n\tstruct ieee80211_sub_if_data *sdata = link->sdata;\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct ieee80211_if_managed *ifmgd = &sdata->u.mgd;\n\tint ret;\n\n\tif (!ieee80211_sdata_running(sdata))\n\t\treturn;\n\n\tsdata_lock(sdata);\n\tmutex_lock(&local->mtx);\n\tmutex_lock(&local->chanctx_mtx);\n\n\tif (!ifmgd->associated)\n\t\tgoto out;\n\n\tif (!link->conf->csa_active)\n\t\tgoto out;\n\n\t \n\n\tif (link->reserved_chanctx) {\n\t\t \n\t\tif (link->reserved_ready)\n\t\t\tgoto out;\n\n\t\tret = ieee80211_link_use_reserved_context(link);\n\t\tif (ret) {\n\t\t\tsdata_info(sdata,\n\t\t\t\t   \"failed to use reserved channel context, disconnecting (err=%d)\\n\",\n\t\t\t\t   ret);\n\t\t\twiphy_work_queue(sdata->local->hw.wiphy,\n\t\t\t\t\t &ifmgd->csa_connection_drop_work);\n\t\t\tgoto out;\n\t\t}\n\n\t\tgoto out;\n\t}\n\n\tif (!cfg80211_chandef_identical(&link->conf->chandef,\n\t\t\t\t\t&link->csa_chandef)) {\n\t\tsdata_info(sdata,\n\t\t\t   \"failed to finalize channel switch, disconnecting\\n\");\n\t\twiphy_work_queue(sdata->local->hw.wiphy,\n\t\t\t\t &ifmgd->csa_connection_drop_work);\n\t\tgoto out;\n\t}\n\n\tlink->u.mgd.csa_waiting_bcn = true;\n\n\tieee80211_sta_reset_beacon_monitor(sdata);\n\tieee80211_sta_reset_conn_monitor(sdata);\n\nout:\n\tmutex_unlock(&local->chanctx_mtx);\n\tmutex_unlock(&local->mtx);\n\tsdata_unlock(sdata);\n}\n\nstatic void ieee80211_chswitch_post_beacon(struct ieee80211_link_data *link)\n{\n\tstruct ieee80211_sub_if_data *sdata = link->sdata;\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct ieee80211_if_managed *ifmgd = &sdata->u.mgd;\n\tint ret;\n\n\tsdata_assert_lock(sdata);\n\n\tWARN_ON(!link->conf->csa_active);\n\n\tif (link->csa_block_tx) {\n\t\tieee80211_wake_vif_queues(local, sdata,\n\t\t\t\t\t  IEEE80211_QUEUE_STOP_REASON_CSA);\n\t\tlink->csa_block_tx = false;\n\t}\n\n\tlink->conf->csa_active = false;\n\tlink->u.mgd.csa_waiting_bcn = false;\n\t \n\tlink->u.mgd.beacon_crc_valid = false;\n\n\tret = drv_post_channel_switch(sdata);\n\tif (ret) {\n\t\tsdata_info(sdata,\n\t\t\t   \"driver post channel switch failed, disconnecting\\n\");\n\t\twiphy_work_queue(sdata->local->hw.wiphy,\n\t\t\t\t &ifmgd->csa_connection_drop_work);\n\t\treturn;\n\t}\n\n\tcfg80211_ch_switch_notify(sdata->dev, &link->reserved_chandef, 0, 0);\n}\n\nvoid ieee80211_chswitch_done(struct ieee80211_vif *vif, bool success)\n{\n\tstruct ieee80211_sub_if_data *sdata = vif_to_sdata(vif);\n\tstruct ieee80211_if_managed *ifmgd = &sdata->u.mgd;\n\n\tif (WARN_ON(ieee80211_vif_is_mld(&sdata->vif)))\n\t\tsuccess = false;\n\n\ttrace_api_chswitch_done(sdata, success);\n\tif (!success) {\n\t\tsdata_info(sdata,\n\t\t\t   \"driver channel switch failed, disconnecting\\n\");\n\t\twiphy_work_queue(sdata->local->hw.wiphy,\n\t\t\t\t &ifmgd->csa_connection_drop_work);\n\t} else {\n\t\twiphy_delayed_work_queue(sdata->local->hw.wiphy,\n\t\t\t\t\t &sdata->deflink.u.mgd.chswitch_work,\n\t\t\t\t\t 0);\n\t}\n}\nEXPORT_SYMBOL(ieee80211_chswitch_done);\n\nstatic void\nieee80211_sta_abort_chanswitch(struct ieee80211_link_data *link)\n{\n\tstruct ieee80211_sub_if_data *sdata = link->sdata;\n\tstruct ieee80211_local *local = sdata->local;\n\n\tif (!local->ops->abort_channel_switch)\n\t\treturn;\n\n\tmutex_lock(&local->mtx);\n\n\tmutex_lock(&local->chanctx_mtx);\n\tieee80211_link_unreserve_chanctx(link);\n\tmutex_unlock(&local->chanctx_mtx);\n\n\tif (link->csa_block_tx)\n\t\tieee80211_wake_vif_queues(local, sdata,\n\t\t\t\t\t  IEEE80211_QUEUE_STOP_REASON_CSA);\n\n\tlink->csa_block_tx = false;\n\tlink->conf->csa_active = false;\n\n\tmutex_unlock(&local->mtx);\n\n\tdrv_abort_channel_switch(sdata);\n}\n\nstatic void\nieee80211_sta_process_chanswitch(struct ieee80211_link_data *link,\n\t\t\t\t u64 timestamp, u32 device_timestamp,\n\t\t\t\t struct ieee802_11_elems *elems,\n\t\t\t\t bool beacon)\n{\n\tstruct ieee80211_sub_if_data *sdata = link->sdata;\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct ieee80211_if_managed *ifmgd = &sdata->u.mgd;\n\tstruct cfg80211_bss *cbss = link->u.mgd.bss;\n\tstruct ieee80211_chanctx_conf *conf;\n\tstruct ieee80211_chanctx *chanctx;\n\tenum nl80211_band current_band;\n\tstruct ieee80211_csa_ie csa_ie;\n\tstruct ieee80211_channel_switch ch_switch;\n\tstruct ieee80211_bss *bss;\n\tunsigned long timeout;\n\tint res;\n\n\tsdata_assert_lock(sdata);\n\n\tif (!cbss)\n\t\treturn;\n\n\tcurrent_band = cbss->channel->band;\n\tbss = (void *)cbss->priv;\n\tres = ieee80211_parse_ch_switch_ie(sdata, elems, current_band,\n\t\t\t\t\t   bss->vht_cap_info,\n\t\t\t\t\t   link->u.mgd.conn_flags,\n\t\t\t\t\t   link->u.mgd.bssid, &csa_ie);\n\n\tif (!res) {\n\t\tch_switch.timestamp = timestamp;\n\t\tch_switch.device_timestamp = device_timestamp;\n\t\tch_switch.block_tx = csa_ie.mode;\n\t\tch_switch.chandef = csa_ie.chandef;\n\t\tch_switch.count = csa_ie.count;\n\t\tch_switch.delay = csa_ie.max_switch_time;\n\t}\n\n\tif (res < 0)\n\t\tgoto lock_and_drop_connection;\n\n\tif (beacon && link->conf->csa_active &&\n\t    !link->u.mgd.csa_waiting_bcn) {\n\t\tif (res)\n\t\t\tieee80211_sta_abort_chanswitch(link);\n\t\telse\n\t\t\tdrv_channel_switch_rx_beacon(sdata, &ch_switch);\n\t\treturn;\n\t} else if (link->conf->csa_active || res) {\n\t\t \n\t\treturn;\n\t}\n\n\tif (link->conf->chandef.chan->band !=\n\t    csa_ie.chandef.chan->band) {\n\t\tsdata_info(sdata,\n\t\t\t   \"AP %pM switches to different band (%d MHz, width:%d, CF1/2: %d/%d MHz), disconnecting\\n\",\n\t\t\t   link->u.mgd.bssid,\n\t\t\t   csa_ie.chandef.chan->center_freq,\n\t\t\t   csa_ie.chandef.width, csa_ie.chandef.center_freq1,\n\t\t\t   csa_ie.chandef.center_freq2);\n\t\tgoto lock_and_drop_connection;\n\t}\n\n\tif (!cfg80211_chandef_usable(local->hw.wiphy, &csa_ie.chandef,\n\t\t\t\t     IEEE80211_CHAN_DISABLED)) {\n\t\tsdata_info(sdata,\n\t\t\t   \"AP %pM switches to unsupported channel \"\n\t\t\t   \"(%d.%03d MHz, width:%d, CF1/2: %d.%03d/%d MHz), \"\n\t\t\t   \"disconnecting\\n\",\n\t\t\t   link->u.mgd.bssid,\n\t\t\t   csa_ie.chandef.chan->center_freq,\n\t\t\t   csa_ie.chandef.chan->freq_offset,\n\t\t\t   csa_ie.chandef.width, csa_ie.chandef.center_freq1,\n\t\t\t   csa_ie.chandef.freq1_offset,\n\t\t\t   csa_ie.chandef.center_freq2);\n\t\tgoto lock_and_drop_connection;\n\t}\n\n\tif (cfg80211_chandef_identical(&csa_ie.chandef,\n\t\t\t\t       &link->conf->chandef) &&\n\t    (!csa_ie.mode || !beacon)) {\n\t\tif (link->u.mgd.csa_ignored_same_chan)\n\t\t\treturn;\n\t\tsdata_info(sdata,\n\t\t\t   \"AP %pM tries to chanswitch to same channel, ignore\\n\",\n\t\t\t   link->u.mgd.bssid);\n\t\tlink->u.mgd.csa_ignored_same_chan = true;\n\t\treturn;\n\t}\n\n\t \n\tieee80211_teardown_tdls_peers(sdata);\n\n\tmutex_lock(&local->mtx);\n\tmutex_lock(&local->chanctx_mtx);\n\tconf = rcu_dereference_protected(link->conf->chanctx_conf,\n\t\t\t\t\t lockdep_is_held(&local->chanctx_mtx));\n\tif (!conf) {\n\t\tsdata_info(sdata,\n\t\t\t   \"no channel context assigned to vif?, disconnecting\\n\");\n\t\tgoto drop_connection;\n\t}\n\n\tchanctx = container_of(conf, struct ieee80211_chanctx, conf);\n\n\tif (local->use_chanctx &&\n\t    !ieee80211_hw_check(&local->hw, CHANCTX_STA_CSA)) {\n\t\tsdata_info(sdata,\n\t\t\t   \"driver doesn't support chan-switch with channel contexts\\n\");\n\t\tgoto drop_connection;\n\t}\n\n\tif (drv_pre_channel_switch(sdata, &ch_switch)) {\n\t\tsdata_info(sdata,\n\t\t\t   \"preparing for channel switch failed, disconnecting\\n\");\n\t\tgoto drop_connection;\n\t}\n\n\tres = ieee80211_link_reserve_chanctx(link, &csa_ie.chandef,\n\t\t\t\t\t     chanctx->mode, false);\n\tif (res) {\n\t\tsdata_info(sdata,\n\t\t\t   \"failed to reserve channel context for channel switch, disconnecting (err=%d)\\n\",\n\t\t\t   res);\n\t\tgoto drop_connection;\n\t}\n\tmutex_unlock(&local->chanctx_mtx);\n\n\tlink->conf->csa_active = true;\n\tlink->csa_chandef = csa_ie.chandef;\n\tlink->csa_block_tx = csa_ie.mode;\n\tlink->u.mgd.csa_ignored_same_chan = false;\n\tlink->u.mgd.beacon_crc_valid = false;\n\n\tif (link->csa_block_tx)\n\t\tieee80211_stop_vif_queues(local, sdata,\n\t\t\t\t\t  IEEE80211_QUEUE_STOP_REASON_CSA);\n\tmutex_unlock(&local->mtx);\n\n\tcfg80211_ch_switch_started_notify(sdata->dev, &csa_ie.chandef,\n\t\t\t\t\t  link->link_id, csa_ie.count,\n\t\t\t\t\t  csa_ie.mode, 0);\n\n\tif (local->ops->channel_switch) {\n\t\t \n\t\tdrv_channel_switch(local, sdata, &ch_switch);\n\t\treturn;\n\t}\n\n\t \n\ttimeout = TU_TO_JIFFIES((max_t(int, csa_ie.count, 1) - 1) *\n\t\t\t\tcbss->beacon_interval);\n\twiphy_delayed_work_queue(local->hw.wiphy,\n\t\t\t\t &link->u.mgd.chswitch_work,\n\t\t\t\t timeout);\n\treturn;\n lock_and_drop_connection:\n\tmutex_lock(&local->mtx);\n\tmutex_lock(&local->chanctx_mtx);\n drop_connection:\n\t \n\tlink->conf->csa_active = true;\n\tlink->csa_block_tx = csa_ie.mode;\n\n\twiphy_work_queue(sdata->local->hw.wiphy,\n\t\t\t &ifmgd->csa_connection_drop_work);\n\tmutex_unlock(&local->chanctx_mtx);\n\tmutex_unlock(&local->mtx);\n}\n\nstatic bool\nieee80211_find_80211h_pwr_constr(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t struct ieee80211_channel *channel,\n\t\t\t\t const u8 *country_ie, u8 country_ie_len,\n\t\t\t\t const u8 *pwr_constr_elem,\n\t\t\t\t int *chan_pwr, int *pwr_reduction)\n{\n\tstruct ieee80211_country_ie_triplet *triplet;\n\tint chan = ieee80211_frequency_to_channel(channel->center_freq);\n\tint i, chan_increment;\n\tbool have_chan_pwr = false;\n\n\t \n\tif (country_ie_len % 2 || country_ie_len < IEEE80211_COUNTRY_IE_MIN_LEN)\n\t\treturn false;\n\n\ttriplet = (void *)(country_ie + 3);\n\tcountry_ie_len -= 3;\n\n\tswitch (channel->band) {\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\tfallthrough;\n\tcase NL80211_BAND_2GHZ:\n\tcase NL80211_BAND_60GHZ:\n\tcase NL80211_BAND_LC:\n\t\tchan_increment = 1;\n\t\tbreak;\n\tcase NL80211_BAND_5GHZ:\n\t\tchan_increment = 4;\n\t\tbreak;\n\tcase NL80211_BAND_6GHZ:\n\t\t \n\t\treturn false;\n\t}\n\n\t \n\twhile (country_ie_len >= 3) {\n\t\tu8 first_channel = triplet->chans.first_channel;\n\n\t\tif (first_channel >= IEEE80211_COUNTRY_EXTENSION_ID)\n\t\t\tgoto next;\n\n\t\tfor (i = 0; i < triplet->chans.num_channels; i++) {\n\t\t\tif (first_channel + i * chan_increment == chan) {\n\t\t\t\thave_chan_pwr = true;\n\t\t\t\t*chan_pwr = triplet->chans.max_power;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (have_chan_pwr)\n\t\t\tbreak;\n\n next:\n\t\ttriplet++;\n\t\tcountry_ie_len -= 3;\n\t}\n\n\tif (have_chan_pwr && pwr_constr_elem)\n\t\t*pwr_reduction = *pwr_constr_elem;\n\telse\n\t\t*pwr_reduction = 0;\n\n\treturn have_chan_pwr;\n}\n\nstatic void ieee80211_find_cisco_dtpc(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t      struct ieee80211_channel *channel,\n\t\t\t\t      const u8 *cisco_dtpc_ie,\n\t\t\t\t      int *pwr_level)\n{\n\t \n\t*pwr_level = (__s8)cisco_dtpc_ie[4];\n}\n\nstatic u64 ieee80211_handle_pwr_constr(struct ieee80211_link_data *link,\n\t\t\t\t       struct ieee80211_channel *channel,\n\t\t\t\t       struct ieee80211_mgmt *mgmt,\n\t\t\t\t       const u8 *country_ie, u8 country_ie_len,\n\t\t\t\t       const u8 *pwr_constr_ie,\n\t\t\t\t       const u8 *cisco_dtpc_ie)\n{\n\tstruct ieee80211_sub_if_data *sdata = link->sdata;\n\tbool has_80211h_pwr = false, has_cisco_pwr = false;\n\tint chan_pwr = 0, pwr_reduction_80211h = 0;\n\tint pwr_level_cisco, pwr_level_80211h;\n\tint new_ap_level;\n\t__le16 capab = mgmt->u.probe_resp.capab_info;\n\n\tif (ieee80211_is_s1g_beacon(mgmt->frame_control))\n\t\treturn 0;\t \n\n\tif (country_ie &&\n\t    (capab & cpu_to_le16(WLAN_CAPABILITY_SPECTRUM_MGMT) ||\n\t     capab & cpu_to_le16(WLAN_CAPABILITY_RADIO_MEASURE))) {\n\t\thas_80211h_pwr = ieee80211_find_80211h_pwr_constr(\n\t\t\tsdata, channel, country_ie, country_ie_len,\n\t\t\tpwr_constr_ie, &chan_pwr, &pwr_reduction_80211h);\n\t\tpwr_level_80211h =\n\t\t\tmax_t(int, 0, chan_pwr - pwr_reduction_80211h);\n\t}\n\n\tif (cisco_dtpc_ie) {\n\t\tieee80211_find_cisco_dtpc(\n\t\t\tsdata, channel, cisco_dtpc_ie, &pwr_level_cisco);\n\t\thas_cisco_pwr = true;\n\t}\n\n\tif (!has_80211h_pwr && !has_cisco_pwr)\n\t\treturn 0;\n\n\t \n\tif (has_80211h_pwr &&\n\t    (!has_cisco_pwr || pwr_level_80211h <= pwr_level_cisco)) {\n\t\tnew_ap_level = pwr_level_80211h;\n\n\t\tif (link->ap_power_level == new_ap_level)\n\t\t\treturn 0;\n\n\t\tsdata_dbg(sdata,\n\t\t\t  \"Limiting TX power to %d (%d - %d) dBm as advertised by %pM\\n\",\n\t\t\t  pwr_level_80211h, chan_pwr, pwr_reduction_80211h,\n\t\t\t  link->u.mgd.bssid);\n\t} else {   \n\t\tnew_ap_level = pwr_level_cisco;\n\n\t\tif (link->ap_power_level == new_ap_level)\n\t\t\treturn 0;\n\n\t\tsdata_dbg(sdata,\n\t\t\t  \"Limiting TX power to %d dBm as advertised by %pM\\n\",\n\t\t\t  pwr_level_cisco, link->u.mgd.bssid);\n\t}\n\n\tlink->ap_power_level = new_ap_level;\n\tif (__ieee80211_recalc_txpower(sdata))\n\t\treturn BSS_CHANGED_TXPOWER;\n\treturn 0;\n}\n\n \nstatic void ieee80211_enable_ps(struct ieee80211_local *local,\n\t\t\t\tstruct ieee80211_sub_if_data *sdata)\n{\n\tstruct ieee80211_conf *conf = &local->hw.conf;\n\n\t \n\tif (local->scanning)\n\t\treturn;\n\n\tif (conf->dynamic_ps_timeout > 0 &&\n\t    !ieee80211_hw_check(&local->hw, SUPPORTS_DYNAMIC_PS)) {\n\t\tmod_timer(&local->dynamic_ps_timer, jiffies +\n\t\t\t  msecs_to_jiffies(conf->dynamic_ps_timeout));\n\t} else {\n\t\tif (ieee80211_hw_check(&local->hw, PS_NULLFUNC_STACK))\n\t\t\tieee80211_send_nullfunc(local, sdata, true);\n\n\t\tif (ieee80211_hw_check(&local->hw, PS_NULLFUNC_STACK) &&\n\t\t    ieee80211_hw_check(&local->hw, REPORTS_TX_ACK_STATUS))\n\t\t\treturn;\n\n\t\tconf->flags |= IEEE80211_CONF_PS;\n\t\tieee80211_hw_config(local, IEEE80211_CONF_CHANGE_PS);\n\t}\n}\n\nstatic void ieee80211_change_ps(struct ieee80211_local *local)\n{\n\tstruct ieee80211_conf *conf = &local->hw.conf;\n\n\tif (local->ps_sdata) {\n\t\tieee80211_enable_ps(local, local->ps_sdata);\n\t} else if (conf->flags & IEEE80211_CONF_PS) {\n\t\tconf->flags &= ~IEEE80211_CONF_PS;\n\t\tieee80211_hw_config(local, IEEE80211_CONF_CHANGE_PS);\n\t\tdel_timer_sync(&local->dynamic_ps_timer);\n\t\tcancel_work_sync(&local->dynamic_ps_enable_work);\n\t}\n}\n\nstatic bool ieee80211_powersave_allowed(struct ieee80211_sub_if_data *sdata)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct ieee80211_if_managed *mgd = &sdata->u.mgd;\n\tstruct sta_info *sta = NULL;\n\tbool authorized = false;\n\n\tif (!mgd->powersave)\n\t\treturn false;\n\n\tif (mgd->broken_ap)\n\t\treturn false;\n\n\tif (!mgd->associated)\n\t\treturn false;\n\n\tif (mgd->flags & IEEE80211_STA_CONNECTION_POLL)\n\t\treturn false;\n\n\tif (!(local->hw.wiphy->flags & WIPHY_FLAG_SUPPORTS_MLO) &&\n\t    !sdata->deflink.u.mgd.have_beacon)\n\t\treturn false;\n\n\trcu_read_lock();\n\tsta = sta_info_get(sdata, sdata->vif.cfg.ap_addr);\n\tif (sta)\n\t\tauthorized = test_sta_flag(sta, WLAN_STA_AUTHORIZED);\n\trcu_read_unlock();\n\n\treturn authorized;\n}\n\n \nvoid ieee80211_recalc_ps(struct ieee80211_local *local)\n{\n\tstruct ieee80211_sub_if_data *sdata, *found = NULL;\n\tint count = 0;\n\tint timeout;\n\n\tif (!ieee80211_hw_check(&local->hw, SUPPORTS_PS) ||\n\t    ieee80211_hw_check(&local->hw, SUPPORTS_DYNAMIC_PS)) {\n\t\tlocal->ps_sdata = NULL;\n\t\treturn;\n\t}\n\n\tlist_for_each_entry(sdata, &local->interfaces, list) {\n\t\tif (!ieee80211_sdata_running(sdata))\n\t\t\tcontinue;\n\t\tif (sdata->vif.type == NL80211_IFTYPE_AP) {\n\t\t\t \n\t\t\tcount = 0;\n\t\t\tbreak;\n\t\t}\n\t\tif (sdata->vif.type != NL80211_IFTYPE_STATION)\n\t\t\tcontinue;\n\t\tfound = sdata;\n\t\tcount++;\n\t}\n\n\tif (count == 1 && ieee80211_powersave_allowed(found)) {\n\t\tu8 dtimper = found->deflink.u.mgd.dtim_period;\n\n\t\ttimeout = local->dynamic_ps_forced_timeout;\n\t\tif (timeout < 0)\n\t\t\ttimeout = 100;\n\t\tlocal->hw.conf.dynamic_ps_timeout = timeout;\n\n\t\t \n\t\tif (!dtimper)\n\t\t\tdtimper = 1;\n\n\t\tlocal->hw.conf.ps_dtim_period = dtimper;\n\t\tlocal->ps_sdata = found;\n\t} else {\n\t\tlocal->ps_sdata = NULL;\n\t}\n\n\tieee80211_change_ps(local);\n}\n\nvoid ieee80211_recalc_ps_vif(struct ieee80211_sub_if_data *sdata)\n{\n\tbool ps_allowed = ieee80211_powersave_allowed(sdata);\n\n\tif (sdata->vif.cfg.ps != ps_allowed) {\n\t\tsdata->vif.cfg.ps = ps_allowed;\n\t\tieee80211_vif_cfg_change_notify(sdata, BSS_CHANGED_PS);\n\t}\n}\n\nvoid ieee80211_dynamic_ps_disable_work(struct work_struct *work)\n{\n\tstruct ieee80211_local *local =\n\t\tcontainer_of(work, struct ieee80211_local,\n\t\t\t     dynamic_ps_disable_work);\n\n\tif (local->hw.conf.flags & IEEE80211_CONF_PS) {\n\t\tlocal->hw.conf.flags &= ~IEEE80211_CONF_PS;\n\t\tieee80211_hw_config(local, IEEE80211_CONF_CHANGE_PS);\n\t}\n\n\tieee80211_wake_queues_by_reason(&local->hw,\n\t\t\t\t\tIEEE80211_MAX_QUEUE_MAP,\n\t\t\t\t\tIEEE80211_QUEUE_STOP_REASON_PS,\n\t\t\t\t\tfalse);\n}\n\nvoid ieee80211_dynamic_ps_enable_work(struct work_struct *work)\n{\n\tstruct ieee80211_local *local =\n\t\tcontainer_of(work, struct ieee80211_local,\n\t\t\t     dynamic_ps_enable_work);\n\tstruct ieee80211_sub_if_data *sdata = local->ps_sdata;\n\tstruct ieee80211_if_managed *ifmgd;\n\tunsigned long flags;\n\tint q;\n\n\t \n\tif (!sdata)\n\t\treturn;\n\n\tifmgd = &sdata->u.mgd;\n\n\tif (local->hw.conf.flags & IEEE80211_CONF_PS)\n\t\treturn;\n\n\tif (local->hw.conf.dynamic_ps_timeout > 0) {\n\t\t \n\t\tif (drv_tx_frames_pending(local)) {\n\t\t\tmod_timer(&local->dynamic_ps_timer, jiffies +\n\t\t\t\t  msecs_to_jiffies(\n\t\t\t\t  local->hw.conf.dynamic_ps_timeout));\n\t\t\treturn;\n\t\t}\n\n\t\t \n\t\tspin_lock_irqsave(&local->queue_stop_reason_lock, flags);\n\t\tfor (q = 0; q < local->hw.queues; q++) {\n\t\t\tif (local->queue_stop_reasons[q]) {\n\t\t\t\tspin_unlock_irqrestore(&local->queue_stop_reason_lock,\n\t\t\t\t\t\t       flags);\n\t\t\t\tmod_timer(&local->dynamic_ps_timer, jiffies +\n\t\t\t\t\t  msecs_to_jiffies(\n\t\t\t\t\t  local->hw.conf.dynamic_ps_timeout));\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tspin_unlock_irqrestore(&local->queue_stop_reason_lock, flags);\n\t}\n\n\tif (ieee80211_hw_check(&local->hw, PS_NULLFUNC_STACK) &&\n\t    !(ifmgd->flags & IEEE80211_STA_NULLFUNC_ACKED)) {\n\t\tif (drv_tx_frames_pending(local)) {\n\t\t\tmod_timer(&local->dynamic_ps_timer, jiffies +\n\t\t\t\t  msecs_to_jiffies(\n\t\t\t\t  local->hw.conf.dynamic_ps_timeout));\n\t\t} else {\n\t\t\tieee80211_send_nullfunc(local, sdata, true);\n\t\t\t \n\t\t\tieee80211_flush_queues(local, sdata, false);\n\t\t}\n\t}\n\n\tif (!(ieee80211_hw_check(&local->hw, REPORTS_TX_ACK_STATUS) &&\n\t      ieee80211_hw_check(&local->hw, PS_NULLFUNC_STACK)) ||\n\t    (ifmgd->flags & IEEE80211_STA_NULLFUNC_ACKED)) {\n\t\tifmgd->flags &= ~IEEE80211_STA_NULLFUNC_ACKED;\n\t\tlocal->hw.conf.flags |= IEEE80211_CONF_PS;\n\t\tieee80211_hw_config(local, IEEE80211_CONF_CHANGE_PS);\n\t}\n}\n\nvoid ieee80211_dynamic_ps_timer(struct timer_list *t)\n{\n\tstruct ieee80211_local *local = from_timer(local, t, dynamic_ps_timer);\n\n\tieee80211_queue_work(&local->hw, &local->dynamic_ps_enable_work);\n}\n\nvoid ieee80211_dfs_cac_timer_work(struct work_struct *work)\n{\n\tstruct delayed_work *delayed_work = to_delayed_work(work);\n\tstruct ieee80211_link_data *link =\n\t\tcontainer_of(delayed_work, struct ieee80211_link_data,\n\t\t\t     dfs_cac_timer_work);\n\tstruct cfg80211_chan_def chandef = link->conf->chandef;\n\tstruct ieee80211_sub_if_data *sdata = link->sdata;\n\n\tmutex_lock(&sdata->local->mtx);\n\tif (sdata->wdev.cac_started) {\n\t\tieee80211_link_release_channel(link);\n\t\tcfg80211_cac_event(sdata->dev, &chandef,\n\t\t\t\t   NL80211_RADAR_CAC_FINISHED,\n\t\t\t\t   GFP_KERNEL);\n\t}\n\tmutex_unlock(&sdata->local->mtx);\n}\n\nstatic bool\n__ieee80211_sta_handle_tspec_ac_params(struct ieee80211_sub_if_data *sdata)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct ieee80211_if_managed *ifmgd = &sdata->u.mgd;\n\tbool ret = false;\n\tint ac;\n\n\tif (local->hw.queues < IEEE80211_NUM_ACS)\n\t\treturn false;\n\n\tfor (ac = 0; ac < IEEE80211_NUM_ACS; ac++) {\n\t\tstruct ieee80211_sta_tx_tspec *tx_tspec = &ifmgd->tx_tspec[ac];\n\t\tint non_acm_ac;\n\t\tunsigned long now = jiffies;\n\n\t\tif (tx_tspec->action == TX_TSPEC_ACTION_NONE &&\n\t\t    tx_tspec->admitted_time &&\n\t\t    time_after(now, tx_tspec->time_slice_start + HZ)) {\n\t\t\ttx_tspec->consumed_tx_time = 0;\n\t\t\ttx_tspec->time_slice_start = now;\n\n\t\t\tif (tx_tspec->downgraded)\n\t\t\t\ttx_tspec->action =\n\t\t\t\t\tTX_TSPEC_ACTION_STOP_DOWNGRADE;\n\t\t}\n\n\t\tswitch (tx_tspec->action) {\n\t\tcase TX_TSPEC_ACTION_STOP_DOWNGRADE:\n\t\t\t \n\t\t\tif (drv_conf_tx(local, &sdata->deflink, ac,\n\t\t\t\t\t&sdata->deflink.tx_conf[ac]))\n\t\t\t\tlink_err(&sdata->deflink,\n\t\t\t\t\t \"failed to set TX queue parameters for queue %d\\n\",\n\t\t\t\t\t ac);\n\t\t\ttx_tspec->action = TX_TSPEC_ACTION_NONE;\n\t\t\ttx_tspec->downgraded = false;\n\t\t\tret = true;\n\t\t\tbreak;\n\t\tcase TX_TSPEC_ACTION_DOWNGRADE:\n\t\t\tif (time_after(now, tx_tspec->time_slice_start + HZ)) {\n\t\t\t\ttx_tspec->action = TX_TSPEC_ACTION_NONE;\n\t\t\t\tret = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t \n\t\t\tfor (non_acm_ac = ac + 1;\n\t\t\t     non_acm_ac < IEEE80211_NUM_ACS;\n\t\t\t     non_acm_ac++)\n\t\t\t\tif (!(sdata->wmm_acm & BIT(7 - 2 * non_acm_ac)))\n\t\t\t\t\tbreak;\n\t\t\t \n\t\t\tif (non_acm_ac >= IEEE80211_NUM_ACS)\n\t\t\t\tnon_acm_ac = IEEE80211_AC_BK;\n\t\t\tif (drv_conf_tx(local, &sdata->deflink, ac,\n\t\t\t\t\t&sdata->deflink.tx_conf[non_acm_ac]))\n\t\t\t\tlink_err(&sdata->deflink,\n\t\t\t\t\t \"failed to set TX queue parameters for queue %d\\n\",\n\t\t\t\t\t ac);\n\t\t\ttx_tspec->action = TX_TSPEC_ACTION_NONE;\n\t\t\tret = true;\n\t\t\tschedule_delayed_work(&ifmgd->tx_tspec_wk,\n\t\t\t\ttx_tspec->time_slice_start + HZ - now + 1);\n\t\t\tbreak;\n\t\tcase TX_TSPEC_ACTION_NONE:\n\t\t\t \n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nvoid ieee80211_sta_handle_tspec_ac_params(struct ieee80211_sub_if_data *sdata)\n{\n\tif (__ieee80211_sta_handle_tspec_ac_params(sdata))\n\t\tieee80211_link_info_change_notify(sdata, &sdata->deflink,\n\t\t\t\t\t\t  BSS_CHANGED_QOS);\n}\n\nstatic void ieee80211_sta_handle_tspec_ac_params_wk(struct work_struct *work)\n{\n\tstruct ieee80211_sub_if_data *sdata;\n\n\tsdata = container_of(work, struct ieee80211_sub_if_data,\n\t\t\t     u.mgd.tx_tspec_wk.work);\n\tieee80211_sta_handle_tspec_ac_params(sdata);\n}\n\nvoid ieee80211_mgd_set_link_qos_params(struct ieee80211_link_data *link)\n{\n\tstruct ieee80211_sub_if_data *sdata = link->sdata;\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct ieee80211_if_managed *ifmgd = &sdata->u.mgd;\n\tstruct ieee80211_tx_queue_params *params = link->tx_conf;\n\tu8 ac;\n\n\tfor (ac = 0; ac < IEEE80211_NUM_ACS; ac++) {\n\t\tmlme_dbg(sdata,\n\t\t\t \"WMM AC=%d acm=%d aifs=%d cWmin=%d cWmax=%d txop=%d uapsd=%d, downgraded=%d\\n\",\n\t\t\t ac, params[ac].acm,\n\t\t\t params[ac].aifs, params[ac].cw_min, params[ac].cw_max,\n\t\t\t params[ac].txop, params[ac].uapsd,\n\t\t\t ifmgd->tx_tspec[ac].downgraded);\n\t\tif (!ifmgd->tx_tspec[ac].downgraded &&\n\t\t    drv_conf_tx(local, link, ac, &params[ac]))\n\t\t\tlink_err(link,\n\t\t\t\t \"failed to set TX queue parameters for AC %d\\n\",\n\t\t\t\t ac);\n\t}\n}\n\n \nstatic bool\nieee80211_sta_wmm_params(struct ieee80211_local *local,\n\t\t\t struct ieee80211_link_data *link,\n\t\t\t const u8 *wmm_param, size_t wmm_param_len,\n\t\t\t const struct ieee80211_mu_edca_param_set *mu_edca)\n{\n\tstruct ieee80211_sub_if_data *sdata = link->sdata;\n\tstruct ieee80211_tx_queue_params params[IEEE80211_NUM_ACS];\n\tstruct ieee80211_if_managed *ifmgd = &sdata->u.mgd;\n\tsize_t left;\n\tint count, mu_edca_count, ac;\n\tconst u8 *pos;\n\tu8 uapsd_queues = 0;\n\n\tif (!local->ops->conf_tx)\n\t\treturn false;\n\n\tif (local->hw.queues < IEEE80211_NUM_ACS)\n\t\treturn false;\n\n\tif (!wmm_param)\n\t\treturn false;\n\n\tif (wmm_param_len < 8 || wmm_param[5]   != 1)\n\t\treturn false;\n\n\tif (ifmgd->flags & IEEE80211_STA_UAPSD_ENABLED)\n\t\tuapsd_queues = ifmgd->uapsd_queues;\n\n\tcount = wmm_param[6] & 0x0f;\n\t \n\tmu_edca_count = mu_edca ? mu_edca->mu_qos_info & 0x0f : -1;\n\tif (count == link->u.mgd.wmm_last_param_set &&\n\t    mu_edca_count == link->u.mgd.mu_edca_last_param_set)\n\t\treturn false;\n\tlink->u.mgd.wmm_last_param_set = count;\n\tlink->u.mgd.mu_edca_last_param_set = mu_edca_count;\n\n\tpos = wmm_param + 8;\n\tleft = wmm_param_len - 8;\n\n\tmemset(&params, 0, sizeof(params));\n\n\tsdata->wmm_acm = 0;\n\tfor (; left >= 4; left -= 4, pos += 4) {\n\t\tint aci = (pos[0] >> 5) & 0x03;\n\t\tint acm = (pos[0] >> 4) & 0x01;\n\t\tbool uapsd = false;\n\n\t\tswitch (aci) {\n\t\tcase 1:  \n\t\t\tac = IEEE80211_AC_BK;\n\t\t\tif (acm)\n\t\t\t\tsdata->wmm_acm |= BIT(1) | BIT(2);  \n\t\t\tif (uapsd_queues & IEEE80211_WMM_IE_STA_QOSINFO_AC_BK)\n\t\t\t\tuapsd = true;\n\t\t\tparams[ac].mu_edca = !!mu_edca;\n\t\t\tif (mu_edca)\n\t\t\t\tparams[ac].mu_edca_param_rec = mu_edca->ac_bk;\n\t\t\tbreak;\n\t\tcase 2:  \n\t\t\tac = IEEE80211_AC_VI;\n\t\t\tif (acm)\n\t\t\t\tsdata->wmm_acm |= BIT(4) | BIT(5);  \n\t\t\tif (uapsd_queues & IEEE80211_WMM_IE_STA_QOSINFO_AC_VI)\n\t\t\t\tuapsd = true;\n\t\t\tparams[ac].mu_edca = !!mu_edca;\n\t\t\tif (mu_edca)\n\t\t\t\tparams[ac].mu_edca_param_rec = mu_edca->ac_vi;\n\t\t\tbreak;\n\t\tcase 3:  \n\t\t\tac = IEEE80211_AC_VO;\n\t\t\tif (acm)\n\t\t\t\tsdata->wmm_acm |= BIT(6) | BIT(7);  \n\t\t\tif (uapsd_queues & IEEE80211_WMM_IE_STA_QOSINFO_AC_VO)\n\t\t\t\tuapsd = true;\n\t\t\tparams[ac].mu_edca = !!mu_edca;\n\t\t\tif (mu_edca)\n\t\t\t\tparams[ac].mu_edca_param_rec = mu_edca->ac_vo;\n\t\t\tbreak;\n\t\tcase 0:  \n\t\tdefault:\n\t\t\tac = IEEE80211_AC_BE;\n\t\t\tif (acm)\n\t\t\t\tsdata->wmm_acm |= BIT(0) | BIT(3);  \n\t\t\tif (uapsd_queues & IEEE80211_WMM_IE_STA_QOSINFO_AC_BE)\n\t\t\t\tuapsd = true;\n\t\t\tparams[ac].mu_edca = !!mu_edca;\n\t\t\tif (mu_edca)\n\t\t\t\tparams[ac].mu_edca_param_rec = mu_edca->ac_be;\n\t\t\tbreak;\n\t\t}\n\n\t\tparams[ac].aifs = pos[0] & 0x0f;\n\n\t\tif (params[ac].aifs < 2) {\n\t\t\tlink_info(link,\n\t\t\t\t  \"AP has invalid WMM params (AIFSN=%d for ACI %d), will use 2\\n\",\n\t\t\t\t  params[ac].aifs, aci);\n\t\t\tparams[ac].aifs = 2;\n\t\t}\n\t\tparams[ac].cw_max = ecw2cw((pos[1] & 0xf0) >> 4);\n\t\tparams[ac].cw_min = ecw2cw(pos[1] & 0x0f);\n\t\tparams[ac].txop = get_unaligned_le16(pos + 2);\n\t\tparams[ac].acm = acm;\n\t\tparams[ac].uapsd = uapsd;\n\n\t\tif (params[ac].cw_min == 0 ||\n\t\t    params[ac].cw_min > params[ac].cw_max) {\n\t\t\tlink_info(link,\n\t\t\t\t  \"AP has invalid WMM params (CWmin/max=%d/%d for ACI %d), using defaults\\n\",\n\t\t\t\t  params[ac].cw_min, params[ac].cw_max, aci);\n\t\t\treturn false;\n\t\t}\n\t\tieee80211_regulatory_limit_wmm_params(sdata, &params[ac], ac);\n\t}\n\n\t \n\tfor (ac = 0; ac < IEEE80211_NUM_ACS; ac++) {\n\t\tif (params[ac].cw_min == 0) {\n\t\t\tlink_info(link,\n\t\t\t\t  \"AP has invalid WMM params (missing AC %d), using defaults\\n\",\n\t\t\t\t  ac);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tfor (ac = 0; ac < IEEE80211_NUM_ACS; ac++)\n\t\tlink->tx_conf[ac] = params[ac];\n\n\tieee80211_mgd_set_link_qos_params(link);\n\n\t \n\tlink->conf->qos = true;\n\treturn true;\n}\n\nstatic void __ieee80211_stop_poll(struct ieee80211_sub_if_data *sdata)\n{\n\tlockdep_assert_held(&sdata->local->mtx);\n\n\tsdata->u.mgd.flags &= ~IEEE80211_STA_CONNECTION_POLL;\n\tieee80211_run_deferred_scan(sdata->local);\n}\n\nstatic void ieee80211_stop_poll(struct ieee80211_sub_if_data *sdata)\n{\n\tmutex_lock(&sdata->local->mtx);\n\t__ieee80211_stop_poll(sdata);\n\tmutex_unlock(&sdata->local->mtx);\n}\n\nstatic u64 ieee80211_handle_bss_capability(struct ieee80211_link_data *link,\n\t\t\t\t\t   u16 capab, bool erp_valid, u8 erp)\n{\n\tstruct ieee80211_bss_conf *bss_conf = link->conf;\n\tstruct ieee80211_supported_band *sband;\n\tu64 changed = 0;\n\tbool use_protection;\n\tbool use_short_preamble;\n\tbool use_short_slot;\n\n\tsband = ieee80211_get_link_sband(link);\n\tif (!sband)\n\t\treturn changed;\n\n\tif (erp_valid) {\n\t\tuse_protection = (erp & WLAN_ERP_USE_PROTECTION) != 0;\n\t\tuse_short_preamble = (erp & WLAN_ERP_BARKER_PREAMBLE) == 0;\n\t} else {\n\t\tuse_protection = false;\n\t\tuse_short_preamble = !!(capab & WLAN_CAPABILITY_SHORT_PREAMBLE);\n\t}\n\n\tuse_short_slot = !!(capab & WLAN_CAPABILITY_SHORT_SLOT_TIME);\n\tif (sband->band == NL80211_BAND_5GHZ ||\n\t    sband->band == NL80211_BAND_6GHZ)\n\t\tuse_short_slot = true;\n\n\tif (use_protection != bss_conf->use_cts_prot) {\n\t\tbss_conf->use_cts_prot = use_protection;\n\t\tchanged |= BSS_CHANGED_ERP_CTS_PROT;\n\t}\n\n\tif (use_short_preamble != bss_conf->use_short_preamble) {\n\t\tbss_conf->use_short_preamble = use_short_preamble;\n\t\tchanged |= BSS_CHANGED_ERP_PREAMBLE;\n\t}\n\n\tif (use_short_slot != bss_conf->use_short_slot) {\n\t\tbss_conf->use_short_slot = use_short_slot;\n\t\tchanged |= BSS_CHANGED_ERP_SLOT;\n\t}\n\n\treturn changed;\n}\n\nstatic u64 ieee80211_link_set_associated(struct ieee80211_link_data *link,\n\t\t\t\t\t struct cfg80211_bss *cbss)\n{\n\tstruct ieee80211_sub_if_data *sdata = link->sdata;\n\tstruct ieee80211_bss_conf *bss_conf = link->conf;\n\tstruct ieee80211_bss *bss = (void *)cbss->priv;\n\tu64 changed = BSS_CHANGED_QOS;\n\n\t \n\tsdata->u.mgd.beacon_timeout =\n\t\tusecs_to_jiffies(ieee80211_tu_to_usec(beacon_loss_count *\n\t\t\t\t\t\t      bss_conf->beacon_int));\n\n\tchanged |= ieee80211_handle_bss_capability(link,\n\t\t\t\t\t\t   bss_conf->assoc_capability,\n\t\t\t\t\t\t   bss->has_erp_value,\n\t\t\t\t\t\t   bss->erp_value);\n\n\tieee80211_check_rate_mask(link);\n\n\tlink->u.mgd.bss = cbss;\n\tmemcpy(link->u.mgd.bssid, cbss->bssid, ETH_ALEN);\n\n\tif (sdata->vif.p2p ||\n\t    sdata->vif.driver_flags & IEEE80211_VIF_GET_NOA_UPDATE) {\n\t\tconst struct cfg80211_bss_ies *ies;\n\n\t\trcu_read_lock();\n\t\ties = rcu_dereference(cbss->ies);\n\t\tif (ies) {\n\t\t\tint ret;\n\n\t\t\tret = cfg80211_get_p2p_attr(\n\t\t\t\t\ties->data, ies->len,\n\t\t\t\t\tIEEE80211_P2P_ATTR_ABSENCE_NOTICE,\n\t\t\t\t\t(u8 *) &bss_conf->p2p_noa_attr,\n\t\t\t\t\tsizeof(bss_conf->p2p_noa_attr));\n\t\t\tif (ret >= 2) {\n\t\t\t\tlink->u.mgd.p2p_noa_index =\n\t\t\t\t\tbss_conf->p2p_noa_attr.index;\n\t\t\t\tchanged |= BSS_CHANGED_P2P_PS;\n\t\t\t}\n\t\t}\n\t\trcu_read_unlock();\n\t}\n\n\tif (link->u.mgd.have_beacon) {\n\t\tbss_conf->beacon_rate = bss->beacon_rate;\n\t\tchanged |= BSS_CHANGED_BEACON_INFO;\n\t} else {\n\t\tbss_conf->beacon_rate = NULL;\n\t}\n\n\t \n\tif (sdata->vif.driver_flags & IEEE80211_VIF_SUPPORTS_CQM_RSSI &&\n\t    bss_conf->cqm_rssi_thold)\n\t\tchanged |= BSS_CHANGED_CQM;\n\n\treturn changed;\n}\n\nstatic void ieee80211_set_associated(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t     struct ieee80211_mgd_assoc_data *assoc_data,\n\t\t\t\t     u64 changed[IEEE80211_MLD_MAX_NUM_LINKS])\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct ieee80211_vif_cfg *vif_cfg = &sdata->vif.cfg;\n\tu64 vif_changed = BSS_CHANGED_ASSOC;\n\tunsigned int link_id;\n\n\tsdata->u.mgd.associated = true;\n\n\tfor (link_id = 0; link_id < IEEE80211_MLD_MAX_NUM_LINKS; link_id++) {\n\t\tstruct cfg80211_bss *cbss = assoc_data->link[link_id].bss;\n\t\tstruct ieee80211_link_data *link;\n\n\t\tif (!cbss ||\n\t\t    assoc_data->link[link_id].status != WLAN_STATUS_SUCCESS)\n\t\t\tcontinue;\n\n\t\tif (ieee80211_vif_is_mld(&sdata->vif) &&\n\t\t    !(ieee80211_vif_usable_links(&sdata->vif) & BIT(link_id)))\n\t\t\tcontinue;\n\n\t\tlink = sdata_dereference(sdata->link[link_id], sdata);\n\t\tif (WARN_ON(!link))\n\t\t\treturn;\n\n\t\tchanged[link_id] |= ieee80211_link_set_associated(link, cbss);\n\t}\n\n\t \n\tieee80211_stop_poll(sdata);\n\n\tieee80211_led_assoc(local, 1);\n\n\tvif_cfg->assoc = 1;\n\n\t \n\tif (vif_cfg->arp_addr_cnt)\n\t\tvif_changed |= BSS_CHANGED_ARP_FILTER;\n\n\tif (ieee80211_vif_is_mld(&sdata->vif)) {\n\t\tfor (link_id = 0;\n\t\t     link_id < IEEE80211_MLD_MAX_NUM_LINKS;\n\t\t     link_id++) {\n\t\t\tstruct ieee80211_link_data *link;\n\t\t\tstruct cfg80211_bss *cbss = assoc_data->link[link_id].bss;\n\n\t\t\tif (!cbss ||\n\t\t\t    !(BIT(link_id) &\n\t\t\t      ieee80211_vif_usable_links(&sdata->vif)) ||\n\t\t\t    assoc_data->link[link_id].status != WLAN_STATUS_SUCCESS)\n\t\t\t\tcontinue;\n\n\t\t\tlink = sdata_dereference(sdata->link[link_id], sdata);\n\t\t\tif (WARN_ON(!link))\n\t\t\t\treturn;\n\n\t\t\tieee80211_link_info_change_notify(sdata, link,\n\t\t\t\t\t\t\t  changed[link_id]);\n\n\t\t\tieee80211_recalc_smps(sdata, link);\n\t\t}\n\n\t\tieee80211_vif_cfg_change_notify(sdata, vif_changed);\n\t} else {\n\t\tieee80211_bss_info_change_notify(sdata,\n\t\t\t\t\t\t vif_changed | changed[0]);\n\t}\n\n\tmutex_lock(&local->iflist_mtx);\n\tieee80211_recalc_ps(local);\n\tmutex_unlock(&local->iflist_mtx);\n\n\t \n\tif (!ieee80211_vif_is_mld(&sdata->vif))\n\t\tieee80211_recalc_smps(sdata, &sdata->deflink);\n\tieee80211_recalc_ps_vif(sdata);\n\n\tnetif_carrier_on(sdata->dev);\n}\n\nstatic void ieee80211_set_disassoc(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t   u16 stype, u16 reason, bool tx,\n\t\t\t\t   u8 *frame_buf)\n{\n\tstruct ieee80211_if_managed *ifmgd = &sdata->u.mgd;\n\tstruct ieee80211_local *local = sdata->local;\n\tunsigned int link_id;\n\tu64 changed = 0;\n\tstruct ieee80211_prep_tx_info info = {\n\t\t.subtype = stype,\n\t};\n\n\tsdata_assert_lock(sdata);\n\n\tif (WARN_ON_ONCE(tx && !frame_buf))\n\t\treturn;\n\n\tif (WARN_ON(!ifmgd->associated))\n\t\treturn;\n\n\tieee80211_stop_poll(sdata);\n\n\tifmgd->associated = false;\n\n\t \n\tsdata->deflink.u.mgd.bss = NULL;\n\n\tnetif_carrier_off(sdata->dev);\n\n\t \n\tif (local->hw.conf.flags & IEEE80211_CONF_PS) {\n\t\tlocal->hw.conf.flags &= ~IEEE80211_CONF_PS;\n\t\tieee80211_hw_config(local, IEEE80211_CONF_CHANGE_PS);\n\t}\n\tlocal->ps_sdata = NULL;\n\n\t \n\tieee80211_recalc_ps_vif(sdata);\n\n\t \n\tsynchronize_net();\n\n\t \n\tif (tx)\n\t\tieee80211_flush_queues(local, sdata, true);\n\n\t \n\tif (tx || frame_buf) {\n\t\t \n\t\tif (ieee80211_hw_check(&local->hw, DEAUTH_NEED_MGD_TX_PREP) &&\n\t\t    !sdata->deflink.u.mgd.have_beacon) {\n\t\t\tdrv_mgd_prepare_tx(sdata->local, sdata, &info);\n\t\t}\n\n\t\tieee80211_send_deauth_disassoc(sdata, sdata->vif.cfg.ap_addr,\n\t\t\t\t\t       sdata->vif.cfg.ap_addr, stype,\n\t\t\t\t\t       reason, tx, frame_buf);\n\t}\n\n\t \n\tif (tx)\n\t\tieee80211_flush_queues(local, sdata, false);\n\n\tdrv_mgd_complete_tx(sdata->local, sdata, &info);\n\n\t \n\teth_zero_addr(sdata->deflink.u.mgd.bssid);\n\teth_zero_addr(sdata->vif.cfg.ap_addr);\n\n\tsdata->vif.cfg.ssid_len = 0;\n\n\t \n\tsta_info_flush(sdata);\n\n\t \n\tif (!ieee80211_vif_is_mld(&sdata->vif))\n\t\tchanged |= ieee80211_reset_erp_info(sdata);\n\n\tieee80211_led_assoc(local, 0);\n\tchanged |= BSS_CHANGED_ASSOC;\n\tsdata->vif.cfg.assoc = false;\n\n\tsdata->deflink.u.mgd.p2p_noa_index = -1;\n\tmemset(&sdata->vif.bss_conf.p2p_noa_attr, 0,\n\t       sizeof(sdata->vif.bss_conf.p2p_noa_attr));\n\n\t \n\tmemset(&ifmgd->ht_capa, 0, sizeof(ifmgd->ht_capa));\n\tmemset(&ifmgd->ht_capa_mask, 0, sizeof(ifmgd->ht_capa_mask));\n\tmemset(&ifmgd->vht_capa, 0, sizeof(ifmgd->vht_capa));\n\tmemset(&ifmgd->vht_capa_mask, 0, sizeof(ifmgd->vht_capa_mask));\n\n\t \n\tmemset(sdata->vif.bss_conf.mu_group.membership, 0,\n\t       sizeof(sdata->vif.bss_conf.mu_group.membership));\n\tmemset(sdata->vif.bss_conf.mu_group.position, 0,\n\t       sizeof(sdata->vif.bss_conf.mu_group.position));\n\tif (!ieee80211_vif_is_mld(&sdata->vif))\n\t\tchanged |= BSS_CHANGED_MU_GROUPS;\n\tsdata->vif.bss_conf.mu_mimo_owner = false;\n\n\tsdata->deflink.ap_power_level = IEEE80211_UNSET_POWER_LEVEL;\n\n\tdel_timer_sync(&local->dynamic_ps_timer);\n\tcancel_work_sync(&local->dynamic_ps_enable_work);\n\n\t \n\tif (sdata->vif.cfg.arp_addr_cnt)\n\t\tchanged |= BSS_CHANGED_ARP_FILTER;\n\n\tsdata->vif.bss_conf.qos = false;\n\tif (!ieee80211_vif_is_mld(&sdata->vif)) {\n\t\tchanged |= BSS_CHANGED_QOS;\n\t\t \n\t\tchanged |= BSS_CHANGED_BSSID | BSS_CHANGED_HT;\n\t\tieee80211_bss_info_change_notify(sdata, changed);\n\t} else {\n\t\tieee80211_vif_cfg_change_notify(sdata, changed);\n\t}\n\n\t \n\tieee80211_set_wmm_default(&sdata->deflink, false, false);\n\n\tdel_timer_sync(&sdata->u.mgd.conn_mon_timer);\n\tdel_timer_sync(&sdata->u.mgd.bcn_mon_timer);\n\tdel_timer_sync(&sdata->u.mgd.timer);\n\n\tsdata->vif.bss_conf.dtim_period = 0;\n\tsdata->vif.bss_conf.beacon_rate = NULL;\n\n\tsdata->deflink.u.mgd.have_beacon = false;\n\tsdata->deflink.u.mgd.tracking_signal_avg = false;\n\tsdata->deflink.u.mgd.disable_wmm_tracking = false;\n\n\tifmgd->flags = 0;\n\tsdata->deflink.u.mgd.conn_flags = 0;\n\tmutex_lock(&local->mtx);\n\n\tfor (link_id = 0; link_id < ARRAY_SIZE(sdata->link); link_id++) {\n\t\tstruct ieee80211_link_data *link;\n\n\t\tlink = sdata_dereference(sdata->link[link_id], sdata);\n\t\tif (!link)\n\t\t\tcontinue;\n\t\tieee80211_link_release_channel(link);\n\t}\n\n\tsdata->vif.bss_conf.csa_active = false;\n\tsdata->deflink.u.mgd.csa_waiting_bcn = false;\n\tsdata->deflink.u.mgd.csa_ignored_same_chan = false;\n\tif (sdata->deflink.csa_block_tx) {\n\t\tieee80211_wake_vif_queues(local, sdata,\n\t\t\t\t\t  IEEE80211_QUEUE_STOP_REASON_CSA);\n\t\tsdata->deflink.csa_block_tx = false;\n\t}\n\tmutex_unlock(&local->mtx);\n\n\t \n\tmemset(ifmgd->tx_tspec, 0, sizeof(ifmgd->tx_tspec));\n\tcancel_delayed_work_sync(&ifmgd->tx_tspec_wk);\n\n\tsdata->vif.bss_conf.pwr_reduction = 0;\n\tsdata->vif.bss_conf.tx_pwr_env_num = 0;\n\tmemset(sdata->vif.bss_conf.tx_pwr_env, 0,\n\t       sizeof(sdata->vif.bss_conf.tx_pwr_env));\n\n\tieee80211_vif_set_links(sdata, 0, 0);\n}\n\nstatic void ieee80211_reset_ap_probe(struct ieee80211_sub_if_data *sdata)\n{\n\tstruct ieee80211_if_managed *ifmgd = &sdata->u.mgd;\n\tstruct ieee80211_local *local = sdata->local;\n\n\tmutex_lock(&local->mtx);\n\tif (!(ifmgd->flags & IEEE80211_STA_CONNECTION_POLL))\n\t\tgoto out;\n\n\t__ieee80211_stop_poll(sdata);\n\n\tmutex_lock(&local->iflist_mtx);\n\tieee80211_recalc_ps(local);\n\tmutex_unlock(&local->iflist_mtx);\n\n\tif (ieee80211_hw_check(&sdata->local->hw, CONNECTION_MONITOR))\n\t\tgoto out;\n\n\t \n\tieee80211_sta_reset_beacon_monitor(sdata);\n\n\tmod_timer(&ifmgd->conn_mon_timer,\n\t\t  round_jiffies_up(jiffies +\n\t\t\t\t   IEEE80211_CONNECTION_IDLE_TIME));\nout:\n\tmutex_unlock(&local->mtx);\n}\n\nstatic void ieee80211_sta_tx_wmm_ac_notify(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t\t   struct ieee80211_hdr *hdr,\n\t\t\t\t\t   u16 tx_time)\n{\n\tstruct ieee80211_if_managed *ifmgd = &sdata->u.mgd;\n\tu16 tid;\n\tint ac;\n\tstruct ieee80211_sta_tx_tspec *tx_tspec;\n\tunsigned long now = jiffies;\n\n\tif (!ieee80211_is_data_qos(hdr->frame_control))\n\t\treturn;\n\n\ttid = ieee80211_get_tid(hdr);\n\tac = ieee80211_ac_from_tid(tid);\n\ttx_tspec = &ifmgd->tx_tspec[ac];\n\n\tif (likely(!tx_tspec->admitted_time))\n\t\treturn;\n\n\tif (time_after(now, tx_tspec->time_slice_start + HZ)) {\n\t\ttx_tspec->consumed_tx_time = 0;\n\t\ttx_tspec->time_slice_start = now;\n\n\t\tif (tx_tspec->downgraded) {\n\t\t\ttx_tspec->action = TX_TSPEC_ACTION_STOP_DOWNGRADE;\n\t\t\tschedule_delayed_work(&ifmgd->tx_tspec_wk, 0);\n\t\t}\n\t}\n\n\tif (tx_tspec->downgraded)\n\t\treturn;\n\n\ttx_tspec->consumed_tx_time += tx_time;\n\n\tif (tx_tspec->consumed_tx_time >= tx_tspec->admitted_time) {\n\t\ttx_tspec->downgraded = true;\n\t\ttx_tspec->action = TX_TSPEC_ACTION_DOWNGRADE;\n\t\tschedule_delayed_work(&ifmgd->tx_tspec_wk, 0);\n\t}\n}\n\nvoid ieee80211_sta_tx_notify(struct ieee80211_sub_if_data *sdata,\n\t\t\t     struct ieee80211_hdr *hdr, bool ack, u16 tx_time)\n{\n\tieee80211_sta_tx_wmm_ac_notify(sdata, hdr, tx_time);\n\n\tif (!ieee80211_is_any_nullfunc(hdr->frame_control) ||\n\t    !sdata->u.mgd.probe_send_count)\n\t\treturn;\n\n\tif (ack)\n\t\tsdata->u.mgd.probe_send_count = 0;\n\telse\n\t\tsdata->u.mgd.nullfunc_failed = true;\n\twiphy_work_queue(sdata->local->hw.wiphy, &sdata->work);\n}\n\nstatic void ieee80211_mlme_send_probe_req(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t\t  const u8 *src, const u8 *dst,\n\t\t\t\t\t  const u8 *ssid, size_t ssid_len,\n\t\t\t\t\t  struct ieee80211_channel *channel)\n{\n\tstruct sk_buff *skb;\n\n\tskb = ieee80211_build_probe_req(sdata, src, dst, (u32)-1, channel,\n\t\t\t\t\tssid, ssid_len, NULL, 0,\n\t\t\t\t\tIEEE80211_PROBE_FLAG_DIRECTED);\n\tif (skb)\n\t\tieee80211_tx_skb(sdata, skb);\n}\n\nstatic void ieee80211_mgd_probe_ap_send(struct ieee80211_sub_if_data *sdata)\n{\n\tstruct ieee80211_if_managed *ifmgd = &sdata->u.mgd;\n\tu8 *dst = sdata->vif.cfg.ap_addr;\n\tu8 unicast_limit = max(1, max_probe_tries - 3);\n\tstruct sta_info *sta;\n\n\tif (WARN_ON(ieee80211_vif_is_mld(&sdata->vif)))\n\t\treturn;\n\n\t \n\tif (ifmgd->probe_send_count >= unicast_limit)\n\t\tdst = NULL;\n\n\t \n\tifmgd->probe_send_count++;\n\n\tif (dst) {\n\t\tmutex_lock(&sdata->local->sta_mtx);\n\t\tsta = sta_info_get(sdata, dst);\n\t\tif (!WARN_ON(!sta))\n\t\t\tieee80211_check_fast_rx(sta);\n\t\tmutex_unlock(&sdata->local->sta_mtx);\n\t}\n\n\tif (ieee80211_hw_check(&sdata->local->hw, REPORTS_TX_ACK_STATUS)) {\n\t\tifmgd->nullfunc_failed = false;\n\t\tieee80211_send_nullfunc(sdata->local, sdata, false);\n\t} else {\n\t\tieee80211_mlme_send_probe_req(sdata, sdata->vif.addr, dst,\n\t\t\t\t\t      sdata->vif.cfg.ssid,\n\t\t\t\t\t      sdata->vif.cfg.ssid_len,\n\t\t\t\t\t      sdata->deflink.u.mgd.bss->channel);\n\t}\n\n\tifmgd->probe_timeout = jiffies + msecs_to_jiffies(probe_wait_ms);\n\trun_again(sdata, ifmgd->probe_timeout);\n}\n\nstatic void ieee80211_mgd_probe_ap(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t   bool beacon)\n{\n\tstruct ieee80211_if_managed *ifmgd = &sdata->u.mgd;\n\tbool already = false;\n\n\tif (WARN_ON_ONCE(ieee80211_vif_is_mld(&sdata->vif)))\n\t\treturn;\n\n\tif (!ieee80211_sdata_running(sdata))\n\t\treturn;\n\n\tsdata_lock(sdata);\n\n\tif (!ifmgd->associated)\n\t\tgoto out;\n\n\tmutex_lock(&sdata->local->mtx);\n\n\tif (sdata->local->tmp_channel || sdata->local->scanning) {\n\t\tmutex_unlock(&sdata->local->mtx);\n\t\tgoto out;\n\t}\n\n\tif (sdata->local->suspending) {\n\t\t \n\t\tmutex_unlock(&sdata->local->mtx);\n\t\tieee80211_reset_ap_probe(sdata);\n\t\tgoto out;\n\t}\n\n\tif (beacon) {\n\t\tmlme_dbg_ratelimited(sdata,\n\t\t\t\t     \"detected beacon loss from AP (missed %d beacons) - probing\\n\",\n\t\t\t\t     beacon_loss_count);\n\n\t\tieee80211_cqm_beacon_loss_notify(&sdata->vif, GFP_KERNEL);\n\t}\n\n\t \n\tif (ifmgd->flags & IEEE80211_STA_CONNECTION_POLL)\n\t\talready = true;\n\n\tifmgd->flags |= IEEE80211_STA_CONNECTION_POLL;\n\n\tmutex_unlock(&sdata->local->mtx);\n\n\tif (already)\n\t\tgoto out;\n\n\tmutex_lock(&sdata->local->iflist_mtx);\n\tieee80211_recalc_ps(sdata->local);\n\tmutex_unlock(&sdata->local->iflist_mtx);\n\n\tifmgd->probe_send_count = 0;\n\tieee80211_mgd_probe_ap_send(sdata);\n out:\n\tsdata_unlock(sdata);\n}\n\nstruct sk_buff *ieee80211_ap_probereq_get(struct ieee80211_hw *hw,\n\t\t\t\t\t  struct ieee80211_vif *vif)\n{\n\tstruct ieee80211_sub_if_data *sdata = vif_to_sdata(vif);\n\tstruct ieee80211_if_managed *ifmgd = &sdata->u.mgd;\n\tstruct cfg80211_bss *cbss;\n\tstruct sk_buff *skb;\n\tconst struct element *ssid;\n\tint ssid_len;\n\n\tif (WARN_ON(sdata->vif.type != NL80211_IFTYPE_STATION ||\n\t\t    ieee80211_vif_is_mld(&sdata->vif)))\n\t\treturn NULL;\n\n\tsdata_assert_lock(sdata);\n\n\tif (ifmgd->associated)\n\t\tcbss = sdata->deflink.u.mgd.bss;\n\telse if (ifmgd->auth_data)\n\t\tcbss = ifmgd->auth_data->bss;\n\telse if (ifmgd->assoc_data && ifmgd->assoc_data->link[0].bss)\n\t\tcbss = ifmgd->assoc_data->link[0].bss;\n\telse\n\t\treturn NULL;\n\n\trcu_read_lock();\n\tssid = ieee80211_bss_get_elem(cbss, WLAN_EID_SSID);\n\tif (WARN_ONCE(!ssid || ssid->datalen > IEEE80211_MAX_SSID_LEN,\n\t\t      \"invalid SSID element (len=%d)\",\n\t\t      ssid ? ssid->datalen : -1))\n\t\tssid_len = 0;\n\telse\n\t\tssid_len = ssid->datalen;\n\n\tskb = ieee80211_build_probe_req(sdata, sdata->vif.addr, cbss->bssid,\n\t\t\t\t\t(u32) -1, cbss->channel,\n\t\t\t\t\tssid->data, ssid_len,\n\t\t\t\t\tNULL, 0, IEEE80211_PROBE_FLAG_DIRECTED);\n\trcu_read_unlock();\n\n\treturn skb;\n}\nEXPORT_SYMBOL(ieee80211_ap_probereq_get);\n\nstatic void ieee80211_report_disconnect(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t\tconst u8 *buf, size_t len, bool tx,\n\t\t\t\t\tu16 reason, bool reconnect)\n{\n\tstruct ieee80211_event event = {\n\t\t.type = MLME_EVENT,\n\t\t.u.mlme.data = tx ? DEAUTH_TX_EVENT : DEAUTH_RX_EVENT,\n\t\t.u.mlme.reason = reason,\n\t};\n\n\tif (tx)\n\t\tcfg80211_tx_mlme_mgmt(sdata->dev, buf, len, reconnect);\n\telse\n\t\tcfg80211_rx_mlme_mgmt(sdata->dev, buf, len);\n\n\tdrv_event_callback(sdata->local, sdata, &event);\n}\n\nstatic void ___ieee80211_disconnect(struct ieee80211_sub_if_data *sdata)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct ieee80211_if_managed *ifmgd = &sdata->u.mgd;\n\tu8 frame_buf[IEEE80211_DEAUTH_FRAME_LEN];\n\tbool tx;\n\n\tif (!ifmgd->associated)\n\t\treturn;\n\n\t \n\ttx = ieee80211_vif_is_mld(&sdata->vif) ||\n\t\t!sdata->deflink.csa_block_tx;\n\n\tif (!ifmgd->driver_disconnect) {\n\t\tunsigned int link_id;\n\n\t\t \n\t\tfor (link_id = 0;\n\t\t     link_id < ARRAY_SIZE(sdata->link);\n\t\t     link_id++) {\n\t\t\tstruct ieee80211_link_data *link;\n\n\t\t\tlink = sdata_dereference(sdata->link[link_id], sdata);\n\t\t\tif (!link)\n\t\t\t\tcontinue;\n\t\t\tcfg80211_unlink_bss(local->hw.wiphy, link->u.mgd.bss);\n\t\t\tlink->u.mgd.bss = NULL;\n\t\t}\n\t}\n\n\tieee80211_set_disassoc(sdata, IEEE80211_STYPE_DEAUTH,\n\t\t\t       ifmgd->driver_disconnect ?\n\t\t\t\t\tWLAN_REASON_DEAUTH_LEAVING :\n\t\t\t\t\tWLAN_REASON_DISASSOC_DUE_TO_INACTIVITY,\n\t\t\t       tx, frame_buf);\n\tmutex_lock(&local->mtx);\n\t \n\tsdata->vif.bss_conf.csa_active = false;\n\tsdata->deflink.u.mgd.csa_waiting_bcn = false;\n\tif (sdata->deflink.csa_block_tx) {\n\t\tieee80211_wake_vif_queues(local, sdata,\n\t\t\t\t\t  IEEE80211_QUEUE_STOP_REASON_CSA);\n\t\tsdata->deflink.csa_block_tx = false;\n\t}\n\tmutex_unlock(&local->mtx);\n\n\tieee80211_report_disconnect(sdata, frame_buf, sizeof(frame_buf), tx,\n\t\t\t\t    WLAN_REASON_DISASSOC_DUE_TO_INACTIVITY,\n\t\t\t\t    ifmgd->reconnect);\n\tifmgd->reconnect = false;\n}\n\nstatic void __ieee80211_disconnect(struct ieee80211_sub_if_data *sdata)\n{\n\tsdata_lock(sdata);\n\t___ieee80211_disconnect(sdata);\n\tsdata_unlock(sdata);\n}\n\nstatic void ieee80211_beacon_connection_loss_work(struct wiphy *wiphy,\n\t\t\t\t\t\t  struct wiphy_work *work)\n{\n\tstruct ieee80211_sub_if_data *sdata =\n\t\tcontainer_of(work, struct ieee80211_sub_if_data,\n\t\t\t     u.mgd.beacon_connection_loss_work);\n\tstruct ieee80211_if_managed *ifmgd = &sdata->u.mgd;\n\n\tif (ifmgd->connection_loss) {\n\t\tsdata_info(sdata, \"Connection to AP %pM lost\\n\",\n\t\t\t   sdata->vif.cfg.ap_addr);\n\t\t__ieee80211_disconnect(sdata);\n\t\tifmgd->connection_loss = false;\n\t} else if (ifmgd->driver_disconnect) {\n\t\tsdata_info(sdata,\n\t\t\t   \"Driver requested disconnection from AP %pM\\n\",\n\t\t\t   sdata->vif.cfg.ap_addr);\n\t\t__ieee80211_disconnect(sdata);\n\t\tifmgd->driver_disconnect = false;\n\t} else {\n\t\tif (ifmgd->associated)\n\t\t\tsdata->deflink.u.mgd.beacon_loss_count++;\n\t\tieee80211_mgd_probe_ap(sdata, true);\n\t}\n}\n\nstatic void ieee80211_csa_connection_drop_work(struct wiphy *wiphy,\n\t\t\t\t\t       struct wiphy_work *work)\n{\n\tstruct ieee80211_sub_if_data *sdata =\n\t\tcontainer_of(work, struct ieee80211_sub_if_data,\n\t\t\t     u.mgd.csa_connection_drop_work);\n\n\t__ieee80211_disconnect(sdata);\n}\n\nvoid ieee80211_beacon_loss(struct ieee80211_vif *vif)\n{\n\tstruct ieee80211_sub_if_data *sdata = vif_to_sdata(vif);\n\tstruct ieee80211_hw *hw = &sdata->local->hw;\n\n\ttrace_api_beacon_loss(sdata);\n\n\tsdata->u.mgd.connection_loss = false;\n\twiphy_work_queue(hw->wiphy, &sdata->u.mgd.beacon_connection_loss_work);\n}\nEXPORT_SYMBOL(ieee80211_beacon_loss);\n\nvoid ieee80211_connection_loss(struct ieee80211_vif *vif)\n{\n\tstruct ieee80211_sub_if_data *sdata = vif_to_sdata(vif);\n\tstruct ieee80211_hw *hw = &sdata->local->hw;\n\n\ttrace_api_connection_loss(sdata);\n\n\tsdata->u.mgd.connection_loss = true;\n\twiphy_work_queue(hw->wiphy, &sdata->u.mgd.beacon_connection_loss_work);\n}\nEXPORT_SYMBOL(ieee80211_connection_loss);\n\nvoid ieee80211_disconnect(struct ieee80211_vif *vif, bool reconnect)\n{\n\tstruct ieee80211_sub_if_data *sdata = vif_to_sdata(vif);\n\tstruct ieee80211_hw *hw = &sdata->local->hw;\n\n\ttrace_api_disconnect(sdata, reconnect);\n\n\tif (WARN_ON(sdata->vif.type != NL80211_IFTYPE_STATION))\n\t\treturn;\n\n\tsdata->u.mgd.driver_disconnect = true;\n\tsdata->u.mgd.reconnect = reconnect;\n\twiphy_work_queue(hw->wiphy, &sdata->u.mgd.beacon_connection_loss_work);\n}\nEXPORT_SYMBOL(ieee80211_disconnect);\n\nstatic void ieee80211_destroy_auth_data(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t\tbool assoc)\n{\n\tstruct ieee80211_mgd_auth_data *auth_data = sdata->u.mgd.auth_data;\n\n\tsdata_assert_lock(sdata);\n\n\tif (!assoc) {\n\t\t \n\t\tdel_timer_sync(&sdata->u.mgd.timer);\n\t\tsta_info_destroy_addr(sdata, auth_data->ap_addr);\n\n\t\t \n\t\tsdata->deflink.u.mgd.conn_flags = 0;\n\t\teth_zero_addr(sdata->deflink.u.mgd.bssid);\n\t\tieee80211_link_info_change_notify(sdata, &sdata->deflink,\n\t\t\t\t\t\t  BSS_CHANGED_BSSID);\n\t\tsdata->u.mgd.flags = 0;\n\n\t\tmutex_lock(&sdata->local->mtx);\n\t\tieee80211_link_release_channel(&sdata->deflink);\n\t\tieee80211_vif_set_links(sdata, 0, 0);\n\t\tmutex_unlock(&sdata->local->mtx);\n\t}\n\n\tcfg80211_put_bss(sdata->local->hw.wiphy, auth_data->bss);\n\tkfree(auth_data);\n\tsdata->u.mgd.auth_data = NULL;\n}\n\nenum assoc_status {\n\tASSOC_SUCCESS,\n\tASSOC_REJECTED,\n\tASSOC_TIMEOUT,\n\tASSOC_ABANDON,\n};\n\nstatic void ieee80211_destroy_assoc_data(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t\t enum assoc_status status)\n{\n\tstruct ieee80211_mgd_assoc_data *assoc_data = sdata->u.mgd.assoc_data;\n\n\tsdata_assert_lock(sdata);\n\n\tif (status != ASSOC_SUCCESS) {\n\t\t \n\t\tdel_timer_sync(&sdata->u.mgd.timer);\n\t\tsta_info_destroy_addr(sdata, assoc_data->ap_addr);\n\n\t\tsdata->deflink.u.mgd.conn_flags = 0;\n\t\teth_zero_addr(sdata->deflink.u.mgd.bssid);\n\t\tieee80211_link_info_change_notify(sdata, &sdata->deflink,\n\t\t\t\t\t\t  BSS_CHANGED_BSSID);\n\t\tsdata->u.mgd.flags = 0;\n\t\tsdata->vif.bss_conf.mu_mimo_owner = false;\n\n\t\tif (status != ASSOC_REJECTED) {\n\t\t\tstruct cfg80211_assoc_failure data = {\n\t\t\t\t.timeout = status == ASSOC_TIMEOUT,\n\t\t\t};\n\t\t\tint i;\n\n\t\t\tBUILD_BUG_ON(ARRAY_SIZE(data.bss) !=\n\t\t\t\t     ARRAY_SIZE(assoc_data->link));\n\n\t\t\tfor (i = 0; i < ARRAY_SIZE(data.bss); i++)\n\t\t\t\tdata.bss[i] = assoc_data->link[i].bss;\n\n\t\t\tif (ieee80211_vif_is_mld(&sdata->vif))\n\t\t\t\tdata.ap_mld_addr = assoc_data->ap_addr;\n\n\t\t\tcfg80211_assoc_failure(sdata->dev, &data);\n\t\t}\n\n\t\tmutex_lock(&sdata->local->mtx);\n\t\tieee80211_link_release_channel(&sdata->deflink);\n\t\tieee80211_vif_set_links(sdata, 0, 0);\n\t\tmutex_unlock(&sdata->local->mtx);\n\t}\n\n\tkfree(assoc_data);\n\tsdata->u.mgd.assoc_data = NULL;\n}\n\nstatic void ieee80211_auth_challenge(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t     struct ieee80211_mgmt *mgmt, size_t len)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct ieee80211_mgd_auth_data *auth_data = sdata->u.mgd.auth_data;\n\tconst struct element *challenge;\n\tu8 *pos;\n\tu32 tx_flags = 0;\n\tstruct ieee80211_prep_tx_info info = {\n\t\t.subtype = IEEE80211_STYPE_AUTH,\n\t};\n\n\tpos = mgmt->u.auth.variable;\n\tchallenge = cfg80211_find_elem(WLAN_EID_CHALLENGE, pos,\n\t\t\t\t       len - (pos - (u8 *)mgmt));\n\tif (!challenge)\n\t\treturn;\n\tauth_data->expected_transaction = 4;\n\tdrv_mgd_prepare_tx(sdata->local, sdata, &info);\n\tif (ieee80211_hw_check(&local->hw, REPORTS_TX_ACK_STATUS))\n\t\ttx_flags = IEEE80211_TX_CTL_REQ_TX_STATUS |\n\t\t\t   IEEE80211_TX_INTFL_MLME_CONN_TX;\n\tieee80211_send_auth(sdata, 3, auth_data->algorithm, 0,\n\t\t\t    (void *)challenge,\n\t\t\t    challenge->datalen + sizeof(*challenge),\n\t\t\t    auth_data->ap_addr, auth_data->ap_addr,\n\t\t\t    auth_data->key, auth_data->key_len,\n\t\t\t    auth_data->key_idx, tx_flags);\n}\n\nstatic bool ieee80211_mark_sta_auth(struct ieee80211_sub_if_data *sdata)\n{\n\tstruct ieee80211_if_managed *ifmgd = &sdata->u.mgd;\n\tconst u8 *ap_addr = ifmgd->auth_data->ap_addr;\n\tstruct sta_info *sta;\n\tbool result = true;\n\n\tsdata_info(sdata, \"authenticated\\n\");\n\tifmgd->auth_data->done = true;\n\tifmgd->auth_data->timeout = jiffies + IEEE80211_AUTH_WAIT_ASSOC;\n\tifmgd->auth_data->timeout_started = true;\n\trun_again(sdata, ifmgd->auth_data->timeout);\n\n\t \n\tmutex_lock(&sdata->local->sta_mtx);\n\tsta = sta_info_get(sdata, ap_addr);\n\tif (!sta) {\n\t\tWARN_ONCE(1, \"%s: STA %pM not found\", sdata->name, ap_addr);\n\t\tresult = false;\n\t\tgoto out;\n\t}\n\tif (sta_info_move_state(sta, IEEE80211_STA_AUTH)) {\n\t\tsdata_info(sdata, \"failed moving %pM to auth\\n\", ap_addr);\n\t\tresult = false;\n\t\tgoto out;\n\t}\n\nout:\n\tmutex_unlock(&sdata->local->sta_mtx);\n\treturn result;\n}\n\nstatic void ieee80211_rx_mgmt_auth(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t   struct ieee80211_mgmt *mgmt, size_t len)\n{\n\tstruct ieee80211_if_managed *ifmgd = &sdata->u.mgd;\n\tu16 auth_alg, auth_transaction, status_code;\n\tstruct ieee80211_event event = {\n\t\t.type = MLME_EVENT,\n\t\t.u.mlme.data = AUTH_EVENT,\n\t};\n\tstruct ieee80211_prep_tx_info info = {\n\t\t.subtype = IEEE80211_STYPE_AUTH,\n\t};\n\n\tsdata_assert_lock(sdata);\n\n\tif (len < 24 + 6)\n\t\treturn;\n\n\tif (!ifmgd->auth_data || ifmgd->auth_data->done)\n\t\treturn;\n\n\tif (!ether_addr_equal(ifmgd->auth_data->ap_addr, mgmt->bssid))\n\t\treturn;\n\n\tauth_alg = le16_to_cpu(mgmt->u.auth.auth_alg);\n\tauth_transaction = le16_to_cpu(mgmt->u.auth.auth_transaction);\n\tstatus_code = le16_to_cpu(mgmt->u.auth.status_code);\n\n\tif (auth_alg != ifmgd->auth_data->algorithm ||\n\t    (auth_alg != WLAN_AUTH_SAE &&\n\t     auth_transaction != ifmgd->auth_data->expected_transaction) ||\n\t    (auth_alg == WLAN_AUTH_SAE &&\n\t     (auth_transaction < ifmgd->auth_data->expected_transaction ||\n\t      auth_transaction > 2))) {\n\t\tsdata_info(sdata, \"%pM unexpected authentication state: alg %d (expected %d) transact %d (expected %d)\\n\",\n\t\t\t   mgmt->sa, auth_alg, ifmgd->auth_data->algorithm,\n\t\t\t   auth_transaction,\n\t\t\t   ifmgd->auth_data->expected_transaction);\n\t\tgoto notify_driver;\n\t}\n\n\tif (status_code != WLAN_STATUS_SUCCESS) {\n\t\tcfg80211_rx_mlme_mgmt(sdata->dev, (u8 *)mgmt, len);\n\n\t\tif (auth_alg == WLAN_AUTH_SAE &&\n\t\t    (status_code == WLAN_STATUS_ANTI_CLOG_REQUIRED ||\n\t\t     (auth_transaction == 1 &&\n\t\t      (status_code == WLAN_STATUS_SAE_HASH_TO_ELEMENT ||\n\t\t       status_code == WLAN_STATUS_SAE_PK)))) {\n\t\t\t \n\t\t\tifmgd->auth_data->waiting = true;\n\t\t\tifmgd->auth_data->timeout =\n\t\t\t\tjiffies + IEEE80211_AUTH_WAIT_SAE_RETRY;\n\t\t\tifmgd->auth_data->timeout_started = true;\n\t\t\trun_again(sdata, ifmgd->auth_data->timeout);\n\t\t\tgoto notify_driver;\n\t\t}\n\n\t\tsdata_info(sdata, \"%pM denied authentication (status %d)\\n\",\n\t\t\t   mgmt->sa, status_code);\n\t\tieee80211_destroy_auth_data(sdata, false);\n\t\tevent.u.mlme.status = MLME_DENIED;\n\t\tevent.u.mlme.reason = status_code;\n\t\tdrv_event_callback(sdata->local, sdata, &event);\n\t\tgoto notify_driver;\n\t}\n\n\tswitch (ifmgd->auth_data->algorithm) {\n\tcase WLAN_AUTH_OPEN:\n\tcase WLAN_AUTH_LEAP:\n\tcase WLAN_AUTH_FT:\n\tcase WLAN_AUTH_SAE:\n\tcase WLAN_AUTH_FILS_SK:\n\tcase WLAN_AUTH_FILS_SK_PFS:\n\tcase WLAN_AUTH_FILS_PK:\n\t\tbreak;\n\tcase WLAN_AUTH_SHARED_KEY:\n\t\tif (ifmgd->auth_data->expected_transaction != 4) {\n\t\t\tieee80211_auth_challenge(sdata, mgmt, len);\n\t\t\t \n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tWARN_ONCE(1, \"invalid auth alg %d\",\n\t\t\t  ifmgd->auth_data->algorithm);\n\t\tgoto notify_driver;\n\t}\n\n\tevent.u.mlme.status = MLME_SUCCESS;\n\tinfo.success = 1;\n\tdrv_event_callback(sdata->local, sdata, &event);\n\tif (ifmgd->auth_data->algorithm != WLAN_AUTH_SAE ||\n\t    (auth_transaction == 2 &&\n\t     ifmgd->auth_data->expected_transaction == 2)) {\n\t\tif (!ieee80211_mark_sta_auth(sdata))\n\t\t\treturn;  \n\t} else if (ifmgd->auth_data->algorithm == WLAN_AUTH_SAE &&\n\t\t   auth_transaction == 2) {\n\t\tsdata_info(sdata, \"SAE peer confirmed\\n\");\n\t\tifmgd->auth_data->peer_confirmed = true;\n\t}\n\n\tcfg80211_rx_mlme_mgmt(sdata->dev, (u8 *)mgmt, len);\nnotify_driver:\n\tdrv_mgd_complete_tx(sdata->local, sdata, &info);\n}\n\n#define case_WLAN(type) \\\n\tcase WLAN_REASON_##type: return #type\n\nconst char *ieee80211_get_reason_code_string(u16 reason_code)\n{\n\tswitch (reason_code) {\n\tcase_WLAN(UNSPECIFIED);\n\tcase_WLAN(PREV_AUTH_NOT_VALID);\n\tcase_WLAN(DEAUTH_LEAVING);\n\tcase_WLAN(DISASSOC_DUE_TO_INACTIVITY);\n\tcase_WLAN(DISASSOC_AP_BUSY);\n\tcase_WLAN(CLASS2_FRAME_FROM_NONAUTH_STA);\n\tcase_WLAN(CLASS3_FRAME_FROM_NONASSOC_STA);\n\tcase_WLAN(DISASSOC_STA_HAS_LEFT);\n\tcase_WLAN(STA_REQ_ASSOC_WITHOUT_AUTH);\n\tcase_WLAN(DISASSOC_BAD_POWER);\n\tcase_WLAN(DISASSOC_BAD_SUPP_CHAN);\n\tcase_WLAN(INVALID_IE);\n\tcase_WLAN(MIC_FAILURE);\n\tcase_WLAN(4WAY_HANDSHAKE_TIMEOUT);\n\tcase_WLAN(GROUP_KEY_HANDSHAKE_TIMEOUT);\n\tcase_WLAN(IE_DIFFERENT);\n\tcase_WLAN(INVALID_GROUP_CIPHER);\n\tcase_WLAN(INVALID_PAIRWISE_CIPHER);\n\tcase_WLAN(INVALID_AKMP);\n\tcase_WLAN(UNSUPP_RSN_VERSION);\n\tcase_WLAN(INVALID_RSN_IE_CAP);\n\tcase_WLAN(IEEE8021X_FAILED);\n\tcase_WLAN(CIPHER_SUITE_REJECTED);\n\tcase_WLAN(DISASSOC_UNSPECIFIED_QOS);\n\tcase_WLAN(DISASSOC_QAP_NO_BANDWIDTH);\n\tcase_WLAN(DISASSOC_LOW_ACK);\n\tcase_WLAN(DISASSOC_QAP_EXCEED_TXOP);\n\tcase_WLAN(QSTA_LEAVE_QBSS);\n\tcase_WLAN(QSTA_NOT_USE);\n\tcase_WLAN(QSTA_REQUIRE_SETUP);\n\tcase_WLAN(QSTA_TIMEOUT);\n\tcase_WLAN(QSTA_CIPHER_NOT_SUPP);\n\tcase_WLAN(MESH_PEER_CANCELED);\n\tcase_WLAN(MESH_MAX_PEERS);\n\tcase_WLAN(MESH_CONFIG);\n\tcase_WLAN(MESH_CLOSE);\n\tcase_WLAN(MESH_MAX_RETRIES);\n\tcase_WLAN(MESH_CONFIRM_TIMEOUT);\n\tcase_WLAN(MESH_INVALID_GTK);\n\tcase_WLAN(MESH_INCONSISTENT_PARAM);\n\tcase_WLAN(MESH_INVALID_SECURITY);\n\tcase_WLAN(MESH_PATH_ERROR);\n\tcase_WLAN(MESH_PATH_NOFORWARD);\n\tcase_WLAN(MESH_PATH_DEST_UNREACHABLE);\n\tcase_WLAN(MAC_EXISTS_IN_MBSS);\n\tcase_WLAN(MESH_CHAN_REGULATORY);\n\tcase_WLAN(MESH_CHAN);\n\tdefault: return \"<unknown>\";\n\t}\n}\n\nstatic void ieee80211_rx_mgmt_deauth(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t     struct ieee80211_mgmt *mgmt, size_t len)\n{\n\tstruct ieee80211_if_managed *ifmgd = &sdata->u.mgd;\n\tu16 reason_code = le16_to_cpu(mgmt->u.deauth.reason_code);\n\n\tsdata_assert_lock(sdata);\n\n\tif (len < 24 + 2)\n\t\treturn;\n\n\tif (!ether_addr_equal(mgmt->bssid, mgmt->sa)) {\n\t\tieee80211_tdls_handle_disconnect(sdata, mgmt->sa, reason_code);\n\t\treturn;\n\t}\n\n\tif (ifmgd->associated &&\n\t    ether_addr_equal(mgmt->bssid, sdata->vif.cfg.ap_addr)) {\n\t\tsdata_info(sdata, \"deauthenticated from %pM (Reason: %u=%s)\\n\",\n\t\t\t   sdata->vif.cfg.ap_addr, reason_code,\n\t\t\t   ieee80211_get_reason_code_string(reason_code));\n\n\t\tieee80211_set_disassoc(sdata, 0, 0, false, NULL);\n\n\t\tieee80211_report_disconnect(sdata, (u8 *)mgmt, len, false,\n\t\t\t\t\t    reason_code, false);\n\t\treturn;\n\t}\n\n\tif (ifmgd->assoc_data &&\n\t    ether_addr_equal(mgmt->bssid, ifmgd->assoc_data->ap_addr)) {\n\t\tsdata_info(sdata,\n\t\t\t   \"deauthenticated from %pM while associating (Reason: %u=%s)\\n\",\n\t\t\t   ifmgd->assoc_data->ap_addr, reason_code,\n\t\t\t   ieee80211_get_reason_code_string(reason_code));\n\n\t\tieee80211_destroy_assoc_data(sdata, ASSOC_ABANDON);\n\n\t\tcfg80211_rx_mlme_mgmt(sdata->dev, (u8 *)mgmt, len);\n\t\treturn;\n\t}\n}\n\n\nstatic void ieee80211_rx_mgmt_disassoc(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t       struct ieee80211_mgmt *mgmt, size_t len)\n{\n\tstruct ieee80211_if_managed *ifmgd = &sdata->u.mgd;\n\tu16 reason_code;\n\n\tsdata_assert_lock(sdata);\n\n\tif (len < 24 + 2)\n\t\treturn;\n\n\tif (!ifmgd->associated ||\n\t    !ether_addr_equal(mgmt->bssid, sdata->vif.cfg.ap_addr))\n\t\treturn;\n\n\treason_code = le16_to_cpu(mgmt->u.disassoc.reason_code);\n\n\tif (!ether_addr_equal(mgmt->bssid, mgmt->sa)) {\n\t\tieee80211_tdls_handle_disconnect(sdata, mgmt->sa, reason_code);\n\t\treturn;\n\t}\n\n\tsdata_info(sdata, \"disassociated from %pM (Reason: %u=%s)\\n\",\n\t\t   sdata->vif.cfg.ap_addr, reason_code,\n\t\t   ieee80211_get_reason_code_string(reason_code));\n\n\tieee80211_set_disassoc(sdata, 0, 0, false, NULL);\n\n\tieee80211_report_disconnect(sdata, (u8 *)mgmt, len, false, reason_code,\n\t\t\t\t    false);\n}\n\nstatic void ieee80211_get_rates(struct ieee80211_supported_band *sband,\n\t\t\t\tu8 *supp_rates, unsigned int supp_rates_len,\n\t\t\t\tu32 *rates, u32 *basic_rates,\n\t\t\t\tbool *have_higher_than_11mbit,\n\t\t\t\tint *min_rate, int *min_rate_index,\n\t\t\t\tint shift)\n{\n\tint i, j;\n\n\tfor (i = 0; i < supp_rates_len; i++) {\n\t\tint rate = supp_rates[i] & 0x7f;\n\t\tbool is_basic = !!(supp_rates[i] & 0x80);\n\n\t\tif ((rate * 5 * (1 << shift)) > 110)\n\t\t\t*have_higher_than_11mbit = true;\n\n\t\t \n\t\tif (supp_rates[i] == (0x80 | BSS_MEMBERSHIP_SELECTOR_HT_PHY) ||\n\t\t    supp_rates[i] == (0x80 | BSS_MEMBERSHIP_SELECTOR_VHT_PHY) ||\n\t\t    supp_rates[i] == (0x80 | BSS_MEMBERSHIP_SELECTOR_HE_PHY) ||\n\t\t    supp_rates[i] == (0x80 | BSS_MEMBERSHIP_SELECTOR_EHT_PHY) ||\n\t\t    supp_rates[i] == (0x80 | BSS_MEMBERSHIP_SELECTOR_SAE_H2E))\n\t\t\tcontinue;\n\n\t\tfor (j = 0; j < sband->n_bitrates; j++) {\n\t\t\tstruct ieee80211_rate *br;\n\t\t\tint brate;\n\n\t\t\tbr = &sband->bitrates[j];\n\n\t\t\tbrate = DIV_ROUND_UP(br->bitrate, (1 << shift) * 5);\n\t\t\tif (brate == rate) {\n\t\t\t\t*rates |= BIT(j);\n\t\t\t\tif (is_basic)\n\t\t\t\t\t*basic_rates |= BIT(j);\n\t\t\t\tif ((rate * 5) < *min_rate) {\n\t\t\t\t\t*min_rate = rate * 5;\n\t\t\t\t\t*min_rate_index = j;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic bool ieee80211_twt_req_supported(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t\tstruct ieee80211_supported_band *sband,\n\t\t\t\t\tconst struct link_sta_info *link_sta,\n\t\t\t\t\tconst struct ieee802_11_elems *elems)\n{\n\tconst struct ieee80211_sta_he_cap *own_he_cap =\n\t\tieee80211_get_he_iftype_cap_vif(sband, &sdata->vif);\n\n\tif (elems->ext_capab_len < 10)\n\t\treturn false;\n\n\tif (!(elems->ext_capab[9] & WLAN_EXT_CAPA10_TWT_RESPONDER_SUPPORT))\n\t\treturn false;\n\n\treturn link_sta->pub->he_cap.he_cap_elem.mac_cap_info[0] &\n\t\tIEEE80211_HE_MAC_CAP0_TWT_RES &&\n\t\town_he_cap &&\n\t\t(own_he_cap->he_cap_elem.mac_cap_info[0] &\n\t\t\tIEEE80211_HE_MAC_CAP0_TWT_REQ);\n}\n\nstatic u64 ieee80211_recalc_twt_req(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t    struct ieee80211_supported_band *sband,\n\t\t\t\t    struct ieee80211_link_data *link,\n\t\t\t\t    struct link_sta_info *link_sta,\n\t\t\t\t    struct ieee802_11_elems *elems)\n{\n\tbool twt = ieee80211_twt_req_supported(sdata, sband, link_sta, elems);\n\n\tif (link->conf->twt_requester != twt) {\n\t\tlink->conf->twt_requester = twt;\n\t\treturn BSS_CHANGED_TWT;\n\t}\n\treturn 0;\n}\n\nstatic bool ieee80211_twt_bcast_support(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t\tstruct ieee80211_bss_conf *bss_conf,\n\t\t\t\t\tstruct ieee80211_supported_band *sband,\n\t\t\t\t\tstruct link_sta_info *link_sta)\n{\n\tconst struct ieee80211_sta_he_cap *own_he_cap =\n\t\tieee80211_get_he_iftype_cap_vif(sband, &sdata->vif);\n\n\treturn bss_conf->he_support &&\n\t\t(link_sta->pub->he_cap.he_cap_elem.mac_cap_info[2] &\n\t\t\tIEEE80211_HE_MAC_CAP2_BCAST_TWT) &&\n\t\town_he_cap &&\n\t\t(own_he_cap->he_cap_elem.mac_cap_info[2] &\n\t\t\tIEEE80211_HE_MAC_CAP2_BCAST_TWT);\n}\n\nstatic bool ieee80211_assoc_config_link(struct ieee80211_link_data *link,\n\t\t\t\t\tstruct link_sta_info *link_sta,\n\t\t\t\t\tstruct cfg80211_bss *cbss,\n\t\t\t\t\tstruct ieee80211_mgmt *mgmt,\n\t\t\t\t\tconst u8 *elem_start,\n\t\t\t\t\tunsigned int elem_len,\n\t\t\t\t\tu64 *changed)\n{\n\tstruct ieee80211_sub_if_data *sdata = link->sdata;\n\tstruct ieee80211_mgd_assoc_data *assoc_data = sdata->u.mgd.assoc_data;\n\tstruct ieee80211_bss_conf *bss_conf = link->conf;\n\tstruct ieee80211_local *local = sdata->local;\n\tunsigned int link_id = link->link_id;\n\tstruct ieee80211_elems_parse_params parse_params = {\n\t\t.start = elem_start,\n\t\t.len = elem_len,\n\t\t.link_id = link_id == assoc_data->assoc_link_id ? -1 : link_id,\n\t\t.from_ap = true,\n\t};\n\tbool is_6ghz = cbss->channel->band == NL80211_BAND_6GHZ;\n\tbool is_s1g = cbss->channel->band == NL80211_BAND_S1GHZ;\n\tconst struct cfg80211_bss_ies *bss_ies = NULL;\n\tstruct ieee80211_supported_band *sband;\n\tstruct ieee802_11_elems *elems;\n\tconst __le16 prof_bss_param_ch_present =\n\t\tcpu_to_le16(IEEE80211_MLE_STA_CONTROL_BSS_PARAM_CHANGE_CNT_PRESENT);\n\tu16 capab_info;\n\tbool ret;\n\n\telems = ieee802_11_parse_elems_full(&parse_params);\n\tif (!elems)\n\t\treturn false;\n\n\tif (link_id == assoc_data->assoc_link_id) {\n\t\tcapab_info = le16_to_cpu(mgmt->u.assoc_resp.capab_info);\n\n\t\t \n\t\tassoc_data->link[link_id].status = WLAN_STATUS_SUCCESS;\n\t\tif (elems->ml_basic) {\n\t\t\tif (!(elems->ml_basic->control &\n\t\t\t\t\tcpu_to_le16(IEEE80211_MLC_BASIC_PRES_BSS_PARAM_CH_CNT))) {\n\t\t\t\tret = false;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tlink->u.mgd.bss_param_ch_cnt =\n\t\t\t\tieee80211_mle_get_bss_param_ch_cnt(elems->ml_basic);\n\t\t}\n\t} else if (!elems->prof ||\n\t\t   !(elems->prof->control & prof_bss_param_ch_present)) {\n\t\tret = false;\n\t\tgoto out;\n\t} else {\n\t\tconst u8 *ptr = elems->prof->variable +\n\t\t\t\telems->prof->sta_info_len - 1;\n\n\t\t \n\t\tcapab_info = get_unaligned_le16(ptr);\n\t\tassoc_data->link[link_id].status = get_unaligned_le16(ptr + 2);\n\t\tlink->u.mgd.bss_param_ch_cnt =\n\t\t\tieee80211_mle_basic_sta_prof_bss_param_ch_cnt(elems->prof);\n\n\t\tif (assoc_data->link[link_id].status != WLAN_STATUS_SUCCESS) {\n\t\t\tlink_info(link, \"association response status code=%u\\n\",\n\t\t\t\t  assoc_data->link[link_id].status);\n\t\t\tret = true;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (!is_s1g && !elems->supp_rates) {\n\t\tsdata_info(sdata, \"no SuppRates element in AssocResp\\n\");\n\t\tret = false;\n\t\tgoto out;\n\t}\n\n\tlink->u.mgd.tdls_chan_switch_prohibited =\n\t\telems->ext_capab && elems->ext_capab_len >= 5 &&\n\t\t(elems->ext_capab[4] & WLAN_EXT_CAPA5_TDLS_CH_SW_PROHIBITED);\n\n\t \n\tif (!is_6ghz &&\n\t    ((assoc_data->wmm && !elems->wmm_param) ||\n\t     (!(link->u.mgd.conn_flags & IEEE80211_CONN_DISABLE_HT) &&\n\t      (!elems->ht_cap_elem || !elems->ht_operation)) ||\n\t     (!(link->u.mgd.conn_flags & IEEE80211_CONN_DISABLE_VHT) &&\n\t      (!elems->vht_cap_elem || !elems->vht_operation)))) {\n\t\tconst struct cfg80211_bss_ies *ies;\n\t\tstruct ieee802_11_elems *bss_elems;\n\n\t\trcu_read_lock();\n\t\ties = rcu_dereference(cbss->ies);\n\t\tif (ies)\n\t\t\tbss_ies = kmemdup(ies, sizeof(*ies) + ies->len,\n\t\t\t\t\t  GFP_ATOMIC);\n\t\trcu_read_unlock();\n\t\tif (!bss_ies) {\n\t\t\tret = false;\n\t\t\tgoto out;\n\t\t}\n\n\t\tparse_params.start = bss_ies->data;\n\t\tparse_params.len = bss_ies->len;\n\t\tparse_params.bss = cbss;\n\t\tbss_elems = ieee802_11_parse_elems_full(&parse_params);\n\t\tif (!bss_elems) {\n\t\t\tret = false;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (assoc_data->wmm &&\n\t\t    !elems->wmm_param && bss_elems->wmm_param) {\n\t\t\telems->wmm_param = bss_elems->wmm_param;\n\t\t\tsdata_info(sdata,\n\t\t\t\t   \"AP bug: WMM param missing from AssocResp\\n\");\n\t\t}\n\n\t\t \n\t\tif (!elems->ht_cap_elem && bss_elems->ht_cap_elem &&\n\t\t    !(link->u.mgd.conn_flags & IEEE80211_CONN_DISABLE_HT)) {\n\t\t\telems->ht_cap_elem = bss_elems->ht_cap_elem;\n\t\t\tsdata_info(sdata,\n\t\t\t\t   \"AP bug: HT capability missing from AssocResp\\n\");\n\t\t}\n\t\tif (!elems->ht_operation && bss_elems->ht_operation &&\n\t\t    !(link->u.mgd.conn_flags & IEEE80211_CONN_DISABLE_HT)) {\n\t\t\telems->ht_operation = bss_elems->ht_operation;\n\t\t\tsdata_info(sdata,\n\t\t\t\t   \"AP bug: HT operation missing from AssocResp\\n\");\n\t\t}\n\t\tif (!elems->vht_cap_elem && bss_elems->vht_cap_elem &&\n\t\t    !(link->u.mgd.conn_flags & IEEE80211_CONN_DISABLE_VHT)) {\n\t\t\telems->vht_cap_elem = bss_elems->vht_cap_elem;\n\t\t\tsdata_info(sdata,\n\t\t\t\t   \"AP bug: VHT capa missing from AssocResp\\n\");\n\t\t}\n\t\tif (!elems->vht_operation && bss_elems->vht_operation &&\n\t\t    !(link->u.mgd.conn_flags & IEEE80211_CONN_DISABLE_VHT)) {\n\t\t\telems->vht_operation = bss_elems->vht_operation;\n\t\t\tsdata_info(sdata,\n\t\t\t\t   \"AP bug: VHT operation missing from AssocResp\\n\");\n\t\t}\n\n\t\tkfree(bss_elems);\n\t}\n\n\t \n\tif (!is_6ghz && !(link->u.mgd.conn_flags & IEEE80211_CONN_DISABLE_HT) &&\n\t    (!elems->wmm_param || !elems->ht_cap_elem || !elems->ht_operation)) {\n\t\tsdata_info(sdata,\n\t\t\t   \"HT AP is missing WMM params or HT capability/operation\\n\");\n\t\tret = false;\n\t\tgoto out;\n\t}\n\n\tif (!is_6ghz && !(link->u.mgd.conn_flags & IEEE80211_CONN_DISABLE_VHT) &&\n\t    (!elems->vht_cap_elem || !elems->vht_operation)) {\n\t\tsdata_info(sdata,\n\t\t\t   \"VHT AP is missing VHT capability/operation\\n\");\n\t\tret = false;\n\t\tgoto out;\n\t}\n\n\tif (is_6ghz && !(link->u.mgd.conn_flags & IEEE80211_CONN_DISABLE_HE) &&\n\t    !elems->he_6ghz_capa) {\n\t\tsdata_info(sdata,\n\t\t\t   \"HE 6 GHz AP is missing HE 6 GHz band capability\\n\");\n\t\tret = false;\n\t\tgoto out;\n\t}\n\n\tif (WARN_ON(!link->conf->chandef.chan)) {\n\t\tret = false;\n\t\tgoto out;\n\t}\n\tsband = local->hw.wiphy->bands[link->conf->chandef.chan->band];\n\n\tif (!(link->u.mgd.conn_flags & IEEE80211_CONN_DISABLE_HE) &&\n\t    (!elems->he_cap || !elems->he_operation)) {\n\t\tsdata_info(sdata,\n\t\t\t   \"HE AP is missing HE capability/operation\\n\");\n\t\tret = false;\n\t\tgoto out;\n\t}\n\n\t \n\tif (elems->ht_cap_elem && !(link->u.mgd.conn_flags & IEEE80211_CONN_DISABLE_HT))\n\t\tieee80211_ht_cap_ie_to_sta_ht_cap(sdata, sband,\n\t\t\t\t\t\t  elems->ht_cap_elem,\n\t\t\t\t\t\t  link_sta);\n\n\tif (elems->vht_cap_elem &&\n\t    !(link->u.mgd.conn_flags & IEEE80211_CONN_DISABLE_VHT)) {\n\t\tconst struct ieee80211_vht_cap *bss_vht_cap = NULL;\n\t\tconst struct cfg80211_bss_ies *ies;\n\n\t\t \n\t\trcu_read_lock();\n\t\ties = rcu_dereference(cbss->ies);\n\t\tif (ies) {\n\t\t\tconst struct element *elem;\n\n\t\t\telem = cfg80211_find_elem(WLAN_EID_VHT_CAPABILITY,\n\t\t\t\t\t\t  ies->data, ies->len);\n\t\t\tif (elem && elem->datalen >= sizeof(*bss_vht_cap))\n\t\t\t\tbss_vht_cap = (const void *)elem->data;\n\t\t}\n\n\t\tieee80211_vht_cap_ie_to_sta_vht_cap(sdata, sband,\n\t\t\t\t\t\t    elems->vht_cap_elem,\n\t\t\t\t\t\t    bss_vht_cap, link_sta);\n\t\trcu_read_unlock();\n\t}\n\n\tif (elems->he_operation && !(link->u.mgd.conn_flags & IEEE80211_CONN_DISABLE_HE) &&\n\t    elems->he_cap) {\n\t\tieee80211_he_cap_ie_to_sta_he_cap(sdata, sband,\n\t\t\t\t\t\t  elems->he_cap,\n\t\t\t\t\t\t  elems->he_cap_len,\n\t\t\t\t\t\t  elems->he_6ghz_capa,\n\t\t\t\t\t\t  link_sta);\n\n\t\tbss_conf->he_support = link_sta->pub->he_cap.has_he;\n\t\tif (elems->rsnx && elems->rsnx_len &&\n\t\t    (elems->rsnx[0] & WLAN_RSNX_CAPA_PROTECTED_TWT) &&\n\t\t    wiphy_ext_feature_isset(local->hw.wiphy,\n\t\t\t\t\t    NL80211_EXT_FEATURE_PROTECTED_TWT))\n\t\t\tbss_conf->twt_protected = true;\n\t\telse\n\t\t\tbss_conf->twt_protected = false;\n\n\t\t*changed |= ieee80211_recalc_twt_req(sdata, sband, link,\n\t\t\t\t\t\t     link_sta, elems);\n\n\t\tif (elems->eht_operation && elems->eht_cap &&\n\t\t    !(link->u.mgd.conn_flags & IEEE80211_CONN_DISABLE_EHT)) {\n\t\t\tieee80211_eht_cap_ie_to_sta_eht_cap(sdata, sband,\n\t\t\t\t\t\t\t    elems->he_cap,\n\t\t\t\t\t\t\t    elems->he_cap_len,\n\t\t\t\t\t\t\t    elems->eht_cap,\n\t\t\t\t\t\t\t    elems->eht_cap_len,\n\t\t\t\t\t\t\t    link_sta);\n\n\t\t\tbss_conf->eht_support = link_sta->pub->eht_cap.has_eht;\n\t\t\t*changed |= BSS_CHANGED_EHT_PUNCTURING;\n\t\t} else {\n\t\t\tbss_conf->eht_support = false;\n\t\t}\n\t} else {\n\t\tbss_conf->he_support = false;\n\t\tbss_conf->twt_requester = false;\n\t\tbss_conf->twt_protected = false;\n\t\tbss_conf->eht_support = false;\n\t}\n\n\tbss_conf->twt_broadcast =\n\t\tieee80211_twt_bcast_support(sdata, bss_conf, sband, link_sta);\n\n\tif (bss_conf->he_support) {\n\t\tbss_conf->he_bss_color.color =\n\t\t\tle32_get_bits(elems->he_operation->he_oper_params,\n\t\t\t\t      IEEE80211_HE_OPERATION_BSS_COLOR_MASK);\n\t\tbss_conf->he_bss_color.partial =\n\t\t\tle32_get_bits(elems->he_operation->he_oper_params,\n\t\t\t\t      IEEE80211_HE_OPERATION_PARTIAL_BSS_COLOR);\n\t\tbss_conf->he_bss_color.enabled =\n\t\t\t!le32_get_bits(elems->he_operation->he_oper_params,\n\t\t\t\t       IEEE80211_HE_OPERATION_BSS_COLOR_DISABLED);\n\n\t\tif (bss_conf->he_bss_color.enabled)\n\t\t\t*changed |= BSS_CHANGED_HE_BSS_COLOR;\n\n\t\tbss_conf->htc_trig_based_pkt_ext =\n\t\t\tle32_get_bits(elems->he_operation->he_oper_params,\n\t\t\t\t      IEEE80211_HE_OPERATION_DFLT_PE_DURATION_MASK);\n\t\tbss_conf->frame_time_rts_th =\n\t\t\tle32_get_bits(elems->he_operation->he_oper_params,\n\t\t\t\t      IEEE80211_HE_OPERATION_RTS_THRESHOLD_MASK);\n\n\t\tbss_conf->uora_exists = !!elems->uora_element;\n\t\tif (elems->uora_element)\n\t\t\tbss_conf->uora_ocw_range = elems->uora_element[0];\n\n\t\tieee80211_he_op_ie_to_bss_conf(&sdata->vif, elems->he_operation);\n\t\tieee80211_he_spr_ie_to_bss_conf(&sdata->vif, elems->he_spr);\n\t\t \n\t}\n\n\tif (cbss->transmitted_bss) {\n\t\tbss_conf->nontransmitted = true;\n\t\tether_addr_copy(bss_conf->transmitter_bssid,\n\t\t\t\tcbss->transmitted_bss->bssid);\n\t\tbss_conf->bssid_indicator = cbss->max_bssid_indicator;\n\t\tbss_conf->bssid_index = cbss->bssid_index;\n\t}\n\n\t \n\n\t \n\tif (elems->opmode_notif &&\n\t    !(*elems->opmode_notif & IEEE80211_OPMODE_NOTIF_RX_NSS_TYPE_BF)) {\n\t\tu8 nss;\n\n\t\tnss = *elems->opmode_notif & IEEE80211_OPMODE_NOTIF_RX_NSS_MASK;\n\t\tnss >>= IEEE80211_OPMODE_NOTIF_RX_NSS_SHIFT;\n\t\tnss += 1;\n\t\tlink_sta->pub->rx_nss = nss;\n\t}\n\n\t \n\tlink->u.mgd.wmm_last_param_set = -1;\n\tlink->u.mgd.mu_edca_last_param_set = -1;\n\n\tif (link->u.mgd.disable_wmm_tracking) {\n\t\tieee80211_set_wmm_default(link, false, false);\n\t} else if (!ieee80211_sta_wmm_params(local, link, elems->wmm_param,\n\t\t\t\t\t     elems->wmm_param_len,\n\t\t\t\t\t     elems->mu_edca_param_set)) {\n\t\t \n\t\tieee80211_set_wmm_default(link, false, true);\n\t\t \n\t\tlink->u.mgd.disable_wmm_tracking = true;\n\t}\n\n\tif (elems->max_idle_period_ie) {\n\t\tbss_conf->max_idle_period =\n\t\t\tle16_to_cpu(elems->max_idle_period_ie->max_idle_period);\n\t\tbss_conf->protected_keep_alive =\n\t\t\t!!(elems->max_idle_period_ie->idle_options &\n\t\t\t   WLAN_IDLE_OPTIONS_PROTECTED_KEEP_ALIVE);\n\t\t*changed |= BSS_CHANGED_KEEP_ALIVE;\n\t} else {\n\t\tbss_conf->max_idle_period = 0;\n\t\tbss_conf->protected_keep_alive = false;\n\t}\n\n\t \n\tbss_conf->assoc_capability = capab_info;\n\n\tret = true;\nout:\n\tkfree(elems);\n\tkfree(bss_ies);\n\treturn ret;\n}\n\nstatic int ieee80211_mgd_setup_link_sta(struct ieee80211_link_data *link,\n\t\t\t\t\tstruct sta_info *sta,\n\t\t\t\t\tstruct link_sta_info *link_sta,\n\t\t\t\t\tstruct cfg80211_bss *cbss)\n{\n\tstruct ieee80211_sub_if_data *sdata = link->sdata;\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct ieee80211_bss *bss = (void *)cbss->priv;\n\tu32 rates = 0, basic_rates = 0;\n\tbool have_higher_than_11mbit = false;\n\tint min_rate = INT_MAX, min_rate_index = -1;\n\t \n\tint shift = ieee80211_vif_get_shift(&sdata->vif);\n\tstruct ieee80211_supported_band *sband;\n\n\tmemcpy(link_sta->addr, cbss->bssid, ETH_ALEN);\n\tmemcpy(link_sta->pub->addr, cbss->bssid, ETH_ALEN);\n\n\t \n\tif (cbss->channel->band == NL80211_BAND_S1GHZ) {\n\t\tieee80211_s1g_sta_rate_init(sta);\n\t\treturn 0;\n\t}\n\n\tsband = local->hw.wiphy->bands[cbss->channel->band];\n\n\tieee80211_get_rates(sband, bss->supp_rates, bss->supp_rates_len,\n\t\t\t    &rates, &basic_rates, &have_higher_than_11mbit,\n\t\t\t    &min_rate, &min_rate_index, shift);\n\n\t \n\tif (min_rate_index < 0) {\n\t\tlink_info(link, \"No legacy rates in association response\\n\");\n\t\treturn -EINVAL;\n\t} else if (!basic_rates) {\n\t\tlink_info(link, \"No basic rates, using min rate instead\\n\");\n\t\tbasic_rates = BIT(min_rate_index);\n\t}\n\n\tif (rates)\n\t\tlink_sta->pub->supp_rates[cbss->channel->band] = rates;\n\telse\n\t\tlink_info(link, \"No rates found, keeping mandatory only\\n\");\n\n\tlink->conf->basic_rates = basic_rates;\n\n\t \n\tlink->operating_11g_mode = sband->band == NL80211_BAND_2GHZ &&\n\t\t\t\t   have_higher_than_11mbit;\n\n\treturn 0;\n}\n\nstatic u8 ieee80211_max_rx_chains(struct ieee80211_link_data *link,\n\t\t\t\t  struct cfg80211_bss *cbss)\n{\n\tstruct ieee80211_he_mcs_nss_supp *he_mcs_nss_supp;\n\tconst struct element *ht_cap_elem, *vht_cap_elem;\n\tconst struct cfg80211_bss_ies *ies;\n\tconst struct ieee80211_ht_cap *ht_cap;\n\tconst struct ieee80211_vht_cap *vht_cap;\n\tconst struct ieee80211_he_cap_elem *he_cap;\n\tconst struct element *he_cap_elem;\n\tu16 mcs_80_map, mcs_160_map;\n\tint i, mcs_nss_size;\n\tbool support_160;\n\tu8 chains = 1;\n\n\tif (link->u.mgd.conn_flags & IEEE80211_CONN_DISABLE_HT)\n\t\treturn chains;\n\n\tht_cap_elem = ieee80211_bss_get_elem(cbss, WLAN_EID_HT_CAPABILITY);\n\tif (ht_cap_elem && ht_cap_elem->datalen >= sizeof(*ht_cap)) {\n\t\tht_cap = (void *)ht_cap_elem->data;\n\t\tchains = ieee80211_mcs_to_chains(&ht_cap->mcs);\n\t\t \n\t}\n\n\tif (link->u.mgd.conn_flags & IEEE80211_CONN_DISABLE_VHT)\n\t\treturn chains;\n\n\tvht_cap_elem = ieee80211_bss_get_elem(cbss, WLAN_EID_VHT_CAPABILITY);\n\tif (vht_cap_elem && vht_cap_elem->datalen >= sizeof(*vht_cap)) {\n\t\tu8 nss;\n\t\tu16 tx_mcs_map;\n\n\t\tvht_cap = (void *)vht_cap_elem->data;\n\t\ttx_mcs_map = le16_to_cpu(vht_cap->supp_mcs.tx_mcs_map);\n\t\tfor (nss = 8; nss > 0; nss--) {\n\t\t\tif (((tx_mcs_map >> (2 * (nss - 1))) & 3) !=\n\t\t\t\t\tIEEE80211_VHT_MCS_NOT_SUPPORTED)\n\t\t\t\tbreak;\n\t\t}\n\t\t \n\t\tchains = max(chains, nss);\n\t}\n\n\tif (link->u.mgd.conn_flags & IEEE80211_CONN_DISABLE_HE)\n\t\treturn chains;\n\n\ties = rcu_dereference(cbss->ies);\n\the_cap_elem = cfg80211_find_ext_elem(WLAN_EID_EXT_HE_CAPABILITY,\n\t\t\t\t\t     ies->data, ies->len);\n\n\tif (!he_cap_elem || he_cap_elem->datalen < sizeof(*he_cap))\n\t\treturn chains;\n\n\t \n\the_cap = (void *)(he_cap_elem->data + 1);\n\tmcs_nss_size = ieee80211_he_mcs_nss_size(he_cap);\n\n\t \n\tif (he_cap_elem->datalen < 1 + mcs_nss_size + sizeof(*he_cap))\n\t\treturn chains;\n\n\t \n\the_mcs_nss_supp = (void *)(he_cap + 1);\n\n\tmcs_80_map = le16_to_cpu(he_mcs_nss_supp->tx_mcs_80);\n\n\tfor (i = 7; i >= 0; i--) {\n\t\tu8 mcs_80 = mcs_80_map >> (2 * i) & 3;\n\n\t\tif (mcs_80 != IEEE80211_VHT_MCS_NOT_SUPPORTED) {\n\t\t\tchains = max_t(u8, chains, i + 1);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tsupport_160 = he_cap->phy_cap_info[0] &\n\t\t      IEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_160MHZ_IN_5G;\n\n\tif (!support_160)\n\t\treturn chains;\n\n\tmcs_160_map = le16_to_cpu(he_mcs_nss_supp->tx_mcs_160);\n\tfor (i = 7; i >= 0; i--) {\n\t\tu8 mcs_160 = mcs_160_map >> (2 * i) & 3;\n\n\t\tif (mcs_160 != IEEE80211_VHT_MCS_NOT_SUPPORTED) {\n\t\t\tchains = max_t(u8, chains, i + 1);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn chains;\n}\n\nstatic bool\nieee80211_verify_peer_he_mcs_support(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t     const struct cfg80211_bss_ies *ies,\n\t\t\t\t     const struct ieee80211_he_operation *he_op)\n{\n\tconst struct element *he_cap_elem;\n\tconst struct ieee80211_he_cap_elem *he_cap;\n\tstruct ieee80211_he_mcs_nss_supp *he_mcs_nss_supp;\n\tu16 mcs_80_map_tx, mcs_80_map_rx;\n\tu16 ap_min_req_set;\n\tint mcs_nss_size;\n\tint nss;\n\n\the_cap_elem = cfg80211_find_ext_elem(WLAN_EID_EXT_HE_CAPABILITY,\n\t\t\t\t\t     ies->data, ies->len);\n\n\tif (!he_cap_elem)\n\t\treturn false;\n\n\t \n\tif (he_cap_elem->datalen < 1 + sizeof(*he_cap)) {\n\t\tsdata_info(sdata,\n\t\t\t   \"Invalid HE elem, Disable HE\\n\");\n\t\treturn false;\n\t}\n\n\t \n\the_cap = (void *)(he_cap_elem->data + 1);\n\tmcs_nss_size = ieee80211_he_mcs_nss_size(he_cap);\n\n\t \n\tif (he_cap_elem->datalen < 1 + sizeof(*he_cap) + mcs_nss_size) {\n\t\tsdata_info(sdata,\n\t\t\t   \"Invalid HE elem with nss size, Disable HE\\n\");\n\t\treturn false;\n\t}\n\n\t \n\the_mcs_nss_supp = (void *)(he_cap + 1);\n\n\tmcs_80_map_tx = le16_to_cpu(he_mcs_nss_supp->tx_mcs_80);\n\tmcs_80_map_rx = le16_to_cpu(he_mcs_nss_supp->rx_mcs_80);\n\n\t \n\tif ((mcs_80_map_tx & 0x3) == IEEE80211_HE_MCS_NOT_SUPPORTED ||\n\t    (mcs_80_map_rx & 0x3) == IEEE80211_HE_MCS_NOT_SUPPORTED) {\n\t\tsdata_info(sdata,\n\t\t\t   \"Missing mandatory rates for 1 Nss, rx 0x%x, tx 0x%x, disable HE\\n\",\n\t\t\t   mcs_80_map_tx, mcs_80_map_rx);\n\t\treturn false;\n\t}\n\n\tif (!he_op)\n\t\treturn true;\n\n\tap_min_req_set = le16_to_cpu(he_op->he_mcs_nss_set);\n\n\t \n\tif (!ap_min_req_set)\n\t\treturn true;\n\n\t \n\tfor (nss = 8; nss > 0; nss--) {\n\t\tu8 ap_op_val = (ap_min_req_set >> (2 * (nss - 1))) & 3;\n\t\tu8 ap_rx_val;\n\t\tu8 ap_tx_val;\n\n\t\tif (ap_op_val == IEEE80211_HE_MCS_NOT_SUPPORTED)\n\t\t\tcontinue;\n\n\t\tap_rx_val = (mcs_80_map_rx >> (2 * (nss - 1))) & 3;\n\t\tap_tx_val = (mcs_80_map_tx >> (2 * (nss - 1))) & 3;\n\n\t\tif (ap_rx_val == IEEE80211_HE_MCS_NOT_SUPPORTED ||\n\t\t    ap_tx_val == IEEE80211_HE_MCS_NOT_SUPPORTED ||\n\t\t    ap_rx_val < ap_op_val || ap_tx_val < ap_op_val) {\n\t\t\tsdata_info(sdata,\n\t\t\t\t   \"Invalid rates for %d Nss, rx %d, tx %d oper %d, disable HE\\n\",\n\t\t\t\t   nss, ap_rx_val, ap_rx_val, ap_op_val);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\nstatic bool\nieee80211_verify_sta_he_mcs_support(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t    struct ieee80211_supported_band *sband,\n\t\t\t\t    const struct ieee80211_he_operation *he_op)\n{\n\tconst struct ieee80211_sta_he_cap *sta_he_cap =\n\t\tieee80211_get_he_iftype_cap_vif(sband, &sdata->vif);\n\tu16 ap_min_req_set;\n\tint i;\n\n\tif (!sta_he_cap || !he_op)\n\t\treturn false;\n\n\tap_min_req_set = le16_to_cpu(he_op->he_mcs_nss_set);\n\n\t \n\tif (!ap_min_req_set)\n\t\treturn true;\n\n\t \n\tfor (i = 0; i < 3; i++) {\n\t\tconst struct ieee80211_he_mcs_nss_supp *sta_mcs_nss_supp =\n\t\t\t&sta_he_cap->he_mcs_nss_supp;\n\t\tu16 sta_mcs_map_rx =\n\t\t\tle16_to_cpu(((__le16 *)sta_mcs_nss_supp)[2 * i]);\n\t\tu16 sta_mcs_map_tx =\n\t\t\tle16_to_cpu(((__le16 *)sta_mcs_nss_supp)[2 * i + 1]);\n\t\tu8 nss;\n\t\tbool verified = true;\n\n\t\t \n\t\tfor (nss = 8; nss > 0; nss--) {\n\t\t\tu8 sta_rx_val = (sta_mcs_map_rx >> (2 * (nss - 1))) & 3;\n\t\t\tu8 sta_tx_val = (sta_mcs_map_tx >> (2 * (nss - 1))) & 3;\n\t\t\tu8 ap_val = (ap_min_req_set >> (2 * (nss - 1))) & 3;\n\n\t\t\tif (ap_val == IEEE80211_HE_MCS_NOT_SUPPORTED)\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tif (sta_rx_val == IEEE80211_HE_MCS_NOT_SUPPORTED ||\n\t\t\t    sta_tx_val == IEEE80211_HE_MCS_NOT_SUPPORTED ||\n\t\t\t    (ap_val > sta_rx_val) || (ap_val > sta_tx_val)) {\n\t\t\t\tverified = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (verified)\n\t\t\treturn true;\n\t}\n\n\t \n\treturn false;\n}\n\nstatic u8\nieee80211_get_eht_cap_mcs_nss(const struct ieee80211_sta_he_cap *sta_he_cap,\n\t\t\t      const struct ieee80211_sta_eht_cap *sta_eht_cap,\n\t\t\t      unsigned int idx, int bw)\n{\n\tu8 he_phy_cap0 = sta_he_cap->he_cap_elem.phy_cap_info[0];\n\tu8 eht_phy_cap0 = sta_eht_cap->eht_cap_elem.phy_cap_info[0];\n\n\t \n\tif (!(he_phy_cap0 & IEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_MASK_ALL))\n\t\treturn sta_eht_cap->eht_mcs_nss_supp.only_20mhz.rx_tx_max_nss[idx];\n\n\t \n\tif (idx > 0)\n\t\tidx--;\n\n\tswitch (bw) {\n\tcase 0:\n\t\treturn sta_eht_cap->eht_mcs_nss_supp.bw._80.rx_tx_max_nss[idx];\n\tcase 1:\n\t\tif (!(he_phy_cap0 &\n\t\t      (IEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_160MHZ_IN_5G |\n\t\t       IEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_80PLUS80_MHZ_IN_5G)))\n\t\t\treturn 0xff;  \n\t\treturn sta_eht_cap->eht_mcs_nss_supp.bw._160.rx_tx_max_nss[idx];\n\tcase 2:\n\t\tif (!(eht_phy_cap0 & IEEE80211_EHT_PHY_CAP0_320MHZ_IN_6GHZ))\n\t\t\treturn 0xff;  \n\t\treturn sta_eht_cap->eht_mcs_nss_supp.bw._320.rx_tx_max_nss[idx];\n\t}\n\n\tWARN_ON(1);\n\treturn 0;\n}\n\nstatic bool\nieee80211_verify_sta_eht_mcs_support(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t     struct ieee80211_supported_band *sband,\n\t\t\t\t     const struct ieee80211_eht_operation *eht_op)\n{\n\tconst struct ieee80211_sta_he_cap *sta_he_cap =\n\t\tieee80211_get_he_iftype_cap_vif(sband, &sdata->vif);\n\tconst struct ieee80211_sta_eht_cap *sta_eht_cap =\n\t\tieee80211_get_eht_iftype_cap_vif(sband, &sdata->vif);\n\tconst struct ieee80211_eht_mcs_nss_supp_20mhz_only *req;\n\tunsigned int i;\n\n\tif (!sta_he_cap || !sta_eht_cap || !eht_op)\n\t\treturn false;\n\n\treq = &eht_op->basic_mcs_nss;\n\n\tfor (i = 0; i < ARRAY_SIZE(req->rx_tx_max_nss); i++) {\n\t\tu8 req_rx_nss, req_tx_nss;\n\t\tunsigned int bw;\n\n\t\treq_rx_nss = u8_get_bits(req->rx_tx_max_nss[i],\n\t\t\t\t\t IEEE80211_EHT_MCS_NSS_RX);\n\t\treq_tx_nss = u8_get_bits(req->rx_tx_max_nss[i],\n\t\t\t\t\t IEEE80211_EHT_MCS_NSS_TX);\n\n\t\tfor (bw = 0; bw < 3; bw++) {\n\t\t\tu8 have, have_rx_nss, have_tx_nss;\n\n\t\t\thave = ieee80211_get_eht_cap_mcs_nss(sta_he_cap,\n\t\t\t\t\t\t\t     sta_eht_cap,\n\t\t\t\t\t\t\t     i, bw);\n\t\t\thave_rx_nss = u8_get_bits(have,\n\t\t\t\t\t\t  IEEE80211_EHT_MCS_NSS_RX);\n\t\t\thave_tx_nss = u8_get_bits(have,\n\t\t\t\t\t\t  IEEE80211_EHT_MCS_NSS_TX);\n\n\t\t\tif (req_rx_nss > have_rx_nss ||\n\t\t\t    req_tx_nss > have_tx_nss)\n\t\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\nstatic int ieee80211_prep_channel(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t  struct ieee80211_link_data *link,\n\t\t\t\t  struct cfg80211_bss *cbss,\n\t\t\t\t  ieee80211_conn_flags_t *conn_flags)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tconst struct ieee80211_ht_cap *ht_cap = NULL;\n\tconst struct ieee80211_ht_operation *ht_oper = NULL;\n\tconst struct ieee80211_vht_operation *vht_oper = NULL;\n\tconst struct ieee80211_he_operation *he_oper = NULL;\n\tconst struct ieee80211_eht_operation *eht_oper = NULL;\n\tconst struct ieee80211_s1g_oper_ie *s1g_oper = NULL;\n\tstruct ieee80211_supported_band *sband;\n\tstruct cfg80211_chan_def chandef;\n\tbool is_6ghz = cbss->channel->band == NL80211_BAND_6GHZ;\n\tbool is_5ghz = cbss->channel->band == NL80211_BAND_5GHZ;\n\tstruct ieee80211_bss *bss = (void *)cbss->priv;\n\tstruct ieee80211_elems_parse_params parse_params = {\n\t\t.link_id = -1,\n\t\t.from_ap = true,\n\t};\n\tstruct ieee802_11_elems *elems;\n\tconst struct cfg80211_bss_ies *ies;\n\tint ret;\n\tu32 i;\n\tbool have_80mhz;\n\n\trcu_read_lock();\n\n\ties = rcu_dereference(cbss->ies);\n\tparse_params.start = ies->data;\n\tparse_params.len = ies->len;\n\telems = ieee802_11_parse_elems_full(&parse_params);\n\tif (!elems) {\n\t\trcu_read_unlock();\n\t\treturn -ENOMEM;\n\t}\n\n\tsband = local->hw.wiphy->bands[cbss->channel->band];\n\n\t*conn_flags &= ~(IEEE80211_CONN_DISABLE_40MHZ |\n\t\t\t IEEE80211_CONN_DISABLE_80P80MHZ |\n\t\t\t IEEE80211_CONN_DISABLE_160MHZ);\n\n\t \n\tif (!sband->ht_cap.ht_supported && !is_6ghz) {\n\t\tmlme_dbg(sdata, \"HT not supported, disabling HT/VHT/HE/EHT\\n\");\n\t\t*conn_flags |= IEEE80211_CONN_DISABLE_HT;\n\t\t*conn_flags |= IEEE80211_CONN_DISABLE_VHT;\n\t\t*conn_flags |= IEEE80211_CONN_DISABLE_HE;\n\t\t*conn_flags |= IEEE80211_CONN_DISABLE_EHT;\n\t}\n\n\tif (!sband->vht_cap.vht_supported && is_5ghz) {\n\t\tmlme_dbg(sdata, \"VHT not supported, disabling VHT/HE/EHT\\n\");\n\t\t*conn_flags |= IEEE80211_CONN_DISABLE_VHT;\n\t\t*conn_flags |= IEEE80211_CONN_DISABLE_HE;\n\t\t*conn_flags |= IEEE80211_CONN_DISABLE_EHT;\n\t}\n\n\tif (!ieee80211_get_he_iftype_cap_vif(sband, &sdata->vif)) {\n\t\tmlme_dbg(sdata, \"HE not supported, disabling HE and EHT\\n\");\n\t\t*conn_flags |= IEEE80211_CONN_DISABLE_HE;\n\t\t*conn_flags |= IEEE80211_CONN_DISABLE_EHT;\n\t}\n\n\tif (!ieee80211_get_eht_iftype_cap_vif(sband, &sdata->vif)) {\n\t\tmlme_dbg(sdata, \"EHT not supported, disabling EHT\\n\");\n\t\t*conn_flags |= IEEE80211_CONN_DISABLE_EHT;\n\t}\n\n\tif (!(*conn_flags & IEEE80211_CONN_DISABLE_HT) && !is_6ghz) {\n\t\tht_oper = elems->ht_operation;\n\t\tht_cap = elems->ht_cap_elem;\n\n\t\tif (!ht_cap) {\n\t\t\t*conn_flags |= IEEE80211_CONN_DISABLE_HT;\n\t\t\tht_oper = NULL;\n\t\t}\n\t}\n\n\tif (!(*conn_flags & IEEE80211_CONN_DISABLE_VHT) && !is_6ghz) {\n\t\tvht_oper = elems->vht_operation;\n\t\tif (vht_oper && !ht_oper) {\n\t\t\tvht_oper = NULL;\n\t\t\tsdata_info(sdata,\n\t\t\t\t   \"AP advertised VHT without HT, disabling HT/VHT/HE\\n\");\n\t\t\t*conn_flags |= IEEE80211_CONN_DISABLE_HT;\n\t\t\t*conn_flags |= IEEE80211_CONN_DISABLE_VHT;\n\t\t\t*conn_flags |= IEEE80211_CONN_DISABLE_HE;\n\t\t\t*conn_flags |= IEEE80211_CONN_DISABLE_EHT;\n\t\t}\n\n\t\tif (!elems->vht_cap_elem) {\n\t\t\t*conn_flags |= IEEE80211_CONN_DISABLE_VHT;\n\t\t\tvht_oper = NULL;\n\t\t}\n\t}\n\n\tif (!(*conn_flags & IEEE80211_CONN_DISABLE_HE)) {\n\t\the_oper = elems->he_operation;\n\n\t\tif (link && is_6ghz) {\n\t\t\tstruct ieee80211_bss_conf *bss_conf;\n\t\t\tu8 j = 0;\n\n\t\t\tbss_conf = link->conf;\n\n\t\t\tif (elems->pwr_constr_elem)\n\t\t\t\tbss_conf->pwr_reduction = *elems->pwr_constr_elem;\n\n\t\t\tBUILD_BUG_ON(ARRAY_SIZE(bss_conf->tx_pwr_env) !=\n\t\t\t\t     ARRAY_SIZE(elems->tx_pwr_env));\n\n\t\t\tfor (i = 0; i < elems->tx_pwr_env_num; i++) {\n\t\t\t\tif (elems->tx_pwr_env_len[i] >\n\t\t\t\t    sizeof(bss_conf->tx_pwr_env[j]))\n\t\t\t\t\tcontinue;\n\n\t\t\t\tbss_conf->tx_pwr_env_num++;\n\t\t\t\tmemcpy(&bss_conf->tx_pwr_env[j], elems->tx_pwr_env[i],\n\t\t\t\t       elems->tx_pwr_env_len[i]);\n\t\t\t\tj++;\n\t\t\t}\n\t\t}\n\n\t\tif (!ieee80211_verify_peer_he_mcs_support(sdata, ies, he_oper) ||\n\t\t    !ieee80211_verify_sta_he_mcs_support(sdata, sband, he_oper))\n\t\t\t*conn_flags |= IEEE80211_CONN_DISABLE_HE |\n\t\t\t\t       IEEE80211_CONN_DISABLE_EHT;\n\t}\n\n\t \n\tif (!(*conn_flags &\n\t\t\t(IEEE80211_CONN_DISABLE_HE |\n\t\t\t IEEE80211_CONN_DISABLE_EHT)) &&\n\t    he_oper) {\n\t\tconst struct cfg80211_bss_ies *cbss_ies;\n\t\tconst struct element *eht_ml_elem;\n\t\tconst u8 *eht_oper_ie;\n\n\t\tcbss_ies = rcu_dereference(cbss->ies);\n\t\teht_oper_ie = cfg80211_find_ext_ie(WLAN_EID_EXT_EHT_OPERATION,\n\t\t\t\t\t\t   cbss_ies->data, cbss_ies->len);\n\t\tif (eht_oper_ie && eht_oper_ie[1] >=\n\t\t    1 + sizeof(struct ieee80211_eht_operation))\n\t\t\teht_oper = (void *)(eht_oper_ie + 3);\n\t\telse\n\t\t\teht_oper = NULL;\n\n\t\tif (!ieee80211_verify_sta_eht_mcs_support(sdata, sband, eht_oper))\n\t\t\t*conn_flags |= IEEE80211_CONN_DISABLE_EHT;\n\n\t\teht_ml_elem = cfg80211_find_ext_elem(WLAN_EID_EXT_EHT_MULTI_LINK,\n\t\t\t\t\t\t     cbss_ies->data, cbss_ies->len);\n\n\t\t \n\t\tif (!(*conn_flags & IEEE80211_CONN_DISABLE_EHT) &&\n\t\t    eht_ml_elem &&\n\t\t    ieee80211_mle_type_ok(eht_ml_elem->data + 1,\n\t\t\t\t\t  IEEE80211_ML_CONTROL_TYPE_BASIC,\n\t\t\t\t\t  eht_ml_elem->datalen - 1)) {\n\t\t\tsdata->vif.cfg.eml_cap =\n\t\t\t\tieee80211_mle_get_eml_cap(eht_ml_elem->data + 1);\n\t\t\tsdata->vif.cfg.eml_med_sync_delay =\n\t\t\t\tieee80211_mle_get_eml_med_sync_delay(eht_ml_elem->data + 1);\n\t\t}\n\t}\n\n\t \n\thave_80mhz = false;\n\tfor (i = 0; i < sband->n_channels; i++) {\n\t\tif (sband->channels[i].flags & (IEEE80211_CHAN_DISABLED |\n\t\t\t\t\t\tIEEE80211_CHAN_NO_80MHZ))\n\t\t\tcontinue;\n\n\t\thave_80mhz = true;\n\t\tbreak;\n\t}\n\n\tif (!have_80mhz) {\n\t\tsdata_info(sdata, \"80 MHz not supported, disabling VHT\\n\");\n\t\t*conn_flags |= IEEE80211_CONN_DISABLE_VHT;\n\t}\n\n\tif (sband->band == NL80211_BAND_S1GHZ) {\n\t\ts1g_oper = elems->s1g_oper;\n\t\tif (!s1g_oper)\n\t\t\tsdata_info(sdata,\n\t\t\t\t   \"AP missing S1G operation element?\\n\");\n\t}\n\n\t*conn_flags |=\n\t\tieee80211_determine_chantype(sdata, link, *conn_flags,\n\t\t\t\t\t     sband,\n\t\t\t\t\t     cbss->channel,\n\t\t\t\t\t     bss->vht_cap_info,\n\t\t\t\t\t     ht_oper, vht_oper,\n\t\t\t\t\t     he_oper, eht_oper,\n\t\t\t\t\t     s1g_oper,\n\t\t\t\t\t     &chandef, false);\n\n\tif (link)\n\t\tlink->needed_rx_chains =\n\t\t\tmin(ieee80211_max_rx_chains(link, cbss),\n\t\t\t    local->rx_chains);\n\n\trcu_read_unlock();\n\t \n\tkfree(elems);\n\telems = NULL;\n\n\tif (*conn_flags & IEEE80211_CONN_DISABLE_HE && is_6ghz) {\n\t\tsdata_info(sdata, \"Rejecting non-HE 6/7 GHz connection\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!link)\n\t\treturn 0;\n\n\t \n\tlink->smps_mode = IEEE80211_SMPS_OFF;\n\n\tmutex_lock(&local->mtx);\n\t \n\tret = ieee80211_link_use_channel(link, &chandef,\n\t\t\t\t\t IEEE80211_CHANCTX_SHARED);\n\n\t \n\tif (chandef.width == NL80211_CHAN_WIDTH_5 ||\n\t    chandef.width == NL80211_CHAN_WIDTH_10)\n\t\tgoto out;\n\n\twhile (ret && chandef.width != NL80211_CHAN_WIDTH_20_NOHT) {\n\t\t*conn_flags |=\n\t\t\tieee80211_chandef_downgrade(&chandef);\n\t\tret = ieee80211_link_use_channel(link, &chandef,\n\t\t\t\t\t\t IEEE80211_CHANCTX_SHARED);\n\t}\n out:\n\tmutex_unlock(&local->mtx);\n\treturn ret;\n}\n\nstatic bool ieee80211_get_dtim(const struct cfg80211_bss_ies *ies,\n\t\t\t       u8 *dtim_count, u8 *dtim_period)\n{\n\tconst u8 *tim_ie = cfg80211_find_ie(WLAN_EID_TIM, ies->data, ies->len);\n\tconst u8 *idx_ie = cfg80211_find_ie(WLAN_EID_MULTI_BSSID_IDX, ies->data,\n\t\t\t\t\t ies->len);\n\tconst struct ieee80211_tim_ie *tim = NULL;\n\tconst struct ieee80211_bssid_index *idx;\n\tbool valid = tim_ie && tim_ie[1] >= 2;\n\n\tif (valid)\n\t\ttim = (void *)(tim_ie + 2);\n\n\tif (dtim_count)\n\t\t*dtim_count = valid ? tim->dtim_count : 0;\n\n\tif (dtim_period)\n\t\t*dtim_period = valid ? tim->dtim_period : 0;\n\n\t \n\tif (!idx_ie || idx_ie[1] < 3)\n\t\treturn valid;\n\n\tidx = (void *)(idx_ie + 2);\n\n\tif (dtim_count)\n\t\t*dtim_count = idx->dtim_count;\n\n\tif (dtim_period)\n\t\t*dtim_period = idx->dtim_period;\n\n\treturn true;\n}\n\nstatic bool ieee80211_assoc_success(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t    struct ieee80211_mgmt *mgmt,\n\t\t\t\t    struct ieee802_11_elems *elems,\n\t\t\t\t    const u8 *elem_start, unsigned int elem_len)\n{\n\tstruct ieee80211_if_managed *ifmgd = &sdata->u.mgd;\n\tstruct ieee80211_mgd_assoc_data *assoc_data = ifmgd->assoc_data;\n\tstruct ieee80211_local *local = sdata->local;\n\tunsigned int link_id;\n\tstruct sta_info *sta;\n\tu64 changed[IEEE80211_MLD_MAX_NUM_LINKS] = {};\n\tu16 valid_links = 0, dormant_links = 0;\n\tint err;\n\n\tmutex_lock(&sdata->local->sta_mtx);\n\t \n\tsta = sta_info_get(sdata, assoc_data->ap_addr);\n\tif (WARN_ON(!sta))\n\t\tgoto out_err;\n\n\tif (ieee80211_vif_is_mld(&sdata->vif)) {\n\t\tfor (link_id = 0; link_id < IEEE80211_MLD_MAX_NUM_LINKS; link_id++) {\n\t\t\tif (!assoc_data->link[link_id].bss)\n\t\t\t\tcontinue;\n\n\t\t\tvalid_links |= BIT(link_id);\n\t\t\tif (assoc_data->link[link_id].disabled)\n\t\t\t\tdormant_links |= BIT(link_id);\n\n\t\t\tif (link_id != assoc_data->assoc_link_id) {\n\t\t\t\terr = ieee80211_sta_allocate_link(sta, link_id);\n\t\t\t\tif (err)\n\t\t\t\t\tgoto out_err;\n\t\t\t}\n\t\t}\n\n\t\tieee80211_vif_set_links(sdata, valid_links, dormant_links);\n\t}\n\n\tfor (link_id = 0; link_id < IEEE80211_MLD_MAX_NUM_LINKS; link_id++) {\n\t\tstruct cfg80211_bss *cbss = assoc_data->link[link_id].bss;\n\t\tstruct ieee80211_link_data *link;\n\t\tstruct link_sta_info *link_sta;\n\n\t\tif (!cbss)\n\t\t\tcontinue;\n\n\t\tlink = sdata_dereference(sdata->link[link_id], sdata);\n\t\tif (WARN_ON(!link))\n\t\t\tgoto out_err;\n\n\t\tif (ieee80211_vif_is_mld(&sdata->vif))\n\t\t\tlink_info(link,\n\t\t\t\t  \"local address %pM, AP link address %pM%s\\n\",\n\t\t\t\t  link->conf->addr,\n\t\t\t\t  assoc_data->link[link_id].bss->bssid,\n\t\t\t\t  link_id == assoc_data->assoc_link_id ?\n\t\t\t\t\t\" (assoc)\" : \"\");\n\n\t\tlink_sta = rcu_dereference_protected(sta->link[link_id],\n\t\t\t\t\t\t     lockdep_is_held(&local->sta_mtx));\n\t\tif (WARN_ON(!link_sta))\n\t\t\tgoto out_err;\n\n\t\tif (!link->u.mgd.have_beacon) {\n\t\t\tconst struct cfg80211_bss_ies *ies;\n\n\t\t\trcu_read_lock();\n\t\t\ties = rcu_dereference(cbss->beacon_ies);\n\t\t\tif (ies)\n\t\t\t\tlink->u.mgd.have_beacon = true;\n\t\t\telse\n\t\t\t\ties = rcu_dereference(cbss->ies);\n\t\t\tieee80211_get_dtim(ies,\n\t\t\t\t\t   &link->conf->sync_dtim_count,\n\t\t\t\t\t   &link->u.mgd.dtim_period);\n\t\t\tlink->conf->beacon_int = cbss->beacon_interval;\n\t\t\trcu_read_unlock();\n\t\t}\n\n\t\tlink->conf->dtim_period = link->u.mgd.dtim_period ?: 1;\n\n\t\tif (link_id != assoc_data->assoc_link_id) {\n\t\t\terr = ieee80211_prep_channel(sdata, link, cbss,\n\t\t\t\t\t\t     &link->u.mgd.conn_flags);\n\t\t\tif (err) {\n\t\t\t\tlink_info(link, \"prep_channel failed\\n\");\n\t\t\t\tgoto out_err;\n\t\t\t}\n\t\t}\n\n\t\terr = ieee80211_mgd_setup_link_sta(link, sta, link_sta,\n\t\t\t\t\t\t   assoc_data->link[link_id].bss);\n\t\tif (err)\n\t\t\tgoto out_err;\n\n\t\tif (!ieee80211_assoc_config_link(link, link_sta,\n\t\t\t\t\t\t assoc_data->link[link_id].bss,\n\t\t\t\t\t\t mgmt, elem_start, elem_len,\n\t\t\t\t\t\t &changed[link_id]))\n\t\t\tgoto out_err;\n\n\t\tif (assoc_data->link[link_id].status != WLAN_STATUS_SUCCESS) {\n\t\t\tvalid_links &= ~BIT(link_id);\n\t\t\tieee80211_sta_remove_link(sta, link_id);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (link_id != assoc_data->assoc_link_id) {\n\t\t\terr = ieee80211_sta_activate_link(sta, link_id);\n\t\t\tif (err)\n\t\t\t\tgoto out_err;\n\t\t}\n\t}\n\n\t \n\tieee80211_vif_set_links(sdata, valid_links, dormant_links);\n\n\trate_control_rate_init(sta);\n\n\tif (ifmgd->flags & IEEE80211_STA_MFP_ENABLED) {\n\t\tset_sta_flag(sta, WLAN_STA_MFP);\n\t\tsta->sta.mfp = true;\n\t} else {\n\t\tsta->sta.mfp = false;\n\t}\n\n\tieee80211_sta_set_max_amsdu_subframes(sta, elems->ext_capab,\n\t\t\t\t\t      elems->ext_capab_len);\n\n\tsta->sta.wme = (elems->wmm_param || elems->s1g_capab) &&\n\t\t       local->hw.queues >= IEEE80211_NUM_ACS;\n\n\terr = sta_info_move_state(sta, IEEE80211_STA_ASSOC);\n\tif (!err && !(ifmgd->flags & IEEE80211_STA_CONTROL_PORT))\n\t\terr = sta_info_move_state(sta, IEEE80211_STA_AUTHORIZED);\n\tif (err) {\n\t\tsdata_info(sdata,\n\t\t\t   \"failed to move station %pM to desired state\\n\",\n\t\t\t   sta->sta.addr);\n\t\tWARN_ON(__sta_info_destroy(sta));\n\t\tgoto out_err;\n\t}\n\n\tif (sdata->wdev.use_4addr)\n\t\tdrv_sta_set_4addr(local, sdata, &sta->sta, true);\n\n\tmutex_unlock(&sdata->local->sta_mtx);\n\n\tieee80211_set_associated(sdata, assoc_data, changed);\n\n\t \n\tif (ifmgd->use_4addr)\n\t\tieee80211_send_4addr_nullfunc(local, sdata);\n\n\t \n\tieee80211_sta_reset_beacon_monitor(sdata);\n\tieee80211_sta_reset_conn_monitor(sdata);\n\n\treturn true;\nout_err:\n\teth_zero_addr(sdata->vif.cfg.ap_addr);\n\tmutex_unlock(&sdata->local->sta_mtx);\n\treturn false;\n}\n\nstatic void ieee80211_rx_mgmt_assoc_resp(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t\t struct ieee80211_mgmt *mgmt,\n\t\t\t\t\t size_t len)\n{\n\tstruct ieee80211_if_managed *ifmgd = &sdata->u.mgd;\n\tstruct ieee80211_mgd_assoc_data *assoc_data = ifmgd->assoc_data;\n\tu16 capab_info, status_code, aid;\n\tstruct ieee80211_elems_parse_params parse_params = {\n\t\t.bss = NULL,\n\t\t.link_id = -1,\n\t\t.from_ap = true,\n\t};\n\tstruct ieee802_11_elems *elems;\n\tint ac;\n\tconst u8 *elem_start;\n\tunsigned int elem_len;\n\tbool reassoc;\n\tstruct ieee80211_event event = {\n\t\t.type = MLME_EVENT,\n\t\t.u.mlme.data = ASSOC_EVENT,\n\t};\n\tstruct ieee80211_prep_tx_info info = {};\n\tstruct cfg80211_rx_assoc_resp resp = {\n\t\t.uapsd_queues = -1,\n\t};\n\tu8 ap_mld_addr[ETH_ALEN] __aligned(2);\n\tunsigned int link_id;\n\n\tsdata_assert_lock(sdata);\n\n\tif (!assoc_data)\n\t\treturn;\n\n\tif (!ether_addr_equal(assoc_data->ap_addr, mgmt->bssid) ||\n\t    !ether_addr_equal(assoc_data->ap_addr, mgmt->sa))\n\t\treturn;\n\n\t \n\n\tif (len < 24 + 6)\n\t\treturn;\n\n\treassoc = ieee80211_is_reassoc_resp(mgmt->frame_control);\n\tcapab_info = le16_to_cpu(mgmt->u.assoc_resp.capab_info);\n\tstatus_code = le16_to_cpu(mgmt->u.assoc_resp.status_code);\n\tif (assoc_data->s1g)\n\t\telem_start = mgmt->u.s1g_assoc_resp.variable;\n\telse\n\t\telem_start = mgmt->u.assoc_resp.variable;\n\n\t \n\tinfo.subtype = reassoc ? IEEE80211_STYPE_REASSOC_REQ :\n\t\t\t\t IEEE80211_STYPE_ASSOC_REQ;\n\n\tif (assoc_data->fils_kek_len &&\n\t    fils_decrypt_assoc_resp(sdata, (u8 *)mgmt, &len, assoc_data) < 0)\n\t\treturn;\n\n\telem_len = len - (elem_start - (u8 *)mgmt);\n\tparse_params.start = elem_start;\n\tparse_params.len = elem_len;\n\telems = ieee802_11_parse_elems_full(&parse_params);\n\tif (!elems)\n\t\tgoto notify_driver;\n\n\tif (elems->aid_resp)\n\t\taid = le16_to_cpu(elems->aid_resp->aid);\n\telse if (assoc_data->s1g)\n\t\taid = 0;  \n\telse\n\t\taid = le16_to_cpu(mgmt->u.assoc_resp.aid);\n\n\t \n\taid &= 0x7ff;\n\n\tsdata_info(sdata,\n\t\t   \"RX %sssocResp from %pM (capab=0x%x status=%d aid=%d)\\n\",\n\t\t   reassoc ? \"Rea\" : \"A\", assoc_data->ap_addr,\n\t\t   capab_info, status_code, (u16)(aid & ~(BIT(15) | BIT(14))));\n\n\tifmgd->broken_ap = false;\n\n\tif (status_code == WLAN_STATUS_ASSOC_REJECTED_TEMPORARILY &&\n\t    elems->timeout_int &&\n\t    elems->timeout_int->type == WLAN_TIMEOUT_ASSOC_COMEBACK) {\n\t\tu32 tu, ms;\n\n\t\tcfg80211_assoc_comeback(sdata->dev, assoc_data->ap_addr,\n\t\t\t\t\tle32_to_cpu(elems->timeout_int->value));\n\n\t\ttu = le32_to_cpu(elems->timeout_int->value);\n\t\tms = tu * 1024 / 1000;\n\t\tsdata_info(sdata,\n\t\t\t   \"%pM rejected association temporarily; comeback duration %u TU (%u ms)\\n\",\n\t\t\t   assoc_data->ap_addr, tu, ms);\n\t\tassoc_data->timeout = jiffies + msecs_to_jiffies(ms);\n\t\tassoc_data->timeout_started = true;\n\t\tif (ms > IEEE80211_ASSOC_TIMEOUT)\n\t\t\trun_again(sdata, assoc_data->timeout);\n\t\tgoto notify_driver;\n\t}\n\n\tif (status_code != WLAN_STATUS_SUCCESS) {\n\t\tsdata_info(sdata, \"%pM denied association (code=%d)\\n\",\n\t\t\t   assoc_data->ap_addr, status_code);\n\t\tevent.u.mlme.status = MLME_DENIED;\n\t\tevent.u.mlme.reason = status_code;\n\t\tdrv_event_callback(sdata->local, sdata, &event);\n\t} else {\n\t\tif (aid == 0 || aid > IEEE80211_MAX_AID) {\n\t\t\tsdata_info(sdata,\n\t\t\t\t   \"invalid AID value %d (out of range), turn off PS\\n\",\n\t\t\t\t   aid);\n\t\t\taid = 0;\n\t\t\tifmgd->broken_ap = true;\n\t\t}\n\n\t\tif (ieee80211_vif_is_mld(&sdata->vif)) {\n\t\t\tif (!elems->ml_basic) {\n\t\t\t\tsdata_info(sdata,\n\t\t\t\t\t   \"MLO association with %pM but no multi-link element in response!\\n\",\n\t\t\t\t\t   assoc_data->ap_addr);\n\t\t\t\tgoto abandon_assoc;\n\t\t\t}\n\n\t\t\tif (le16_get_bits(elems->ml_basic->control,\n\t\t\t\t\t  IEEE80211_ML_CONTROL_TYPE) !=\n\t\t\t\t\tIEEE80211_ML_CONTROL_TYPE_BASIC) {\n\t\t\t\tsdata_info(sdata,\n\t\t\t\t\t   \"bad multi-link element (control=0x%x)\\n\",\n\t\t\t\t\t   le16_to_cpu(elems->ml_basic->control));\n\t\t\t\tgoto abandon_assoc;\n\t\t\t} else {\n\t\t\t\tstruct ieee80211_mle_basic_common_info *common;\n\n\t\t\t\tcommon = (void *)elems->ml_basic->variable;\n\n\t\t\t\tif (memcmp(assoc_data->ap_addr,\n\t\t\t\t\t   common->mld_mac_addr, ETH_ALEN)) {\n\t\t\t\t\tsdata_info(sdata,\n\t\t\t\t\t\t   \"AP MLD MAC address mismatch: got %pM expected %pM\\n\",\n\t\t\t\t\t\t   common->mld_mac_addr,\n\t\t\t\t\t\t   assoc_data->ap_addr);\n\t\t\t\t\tgoto abandon_assoc;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tsdata->vif.cfg.aid = aid;\n\n\t\tif (!ieee80211_assoc_success(sdata, mgmt, elems,\n\t\t\t\t\t     elem_start, elem_len)) {\n\t\t\t \n\t\t\tieee80211_destroy_assoc_data(sdata, ASSOC_TIMEOUT);\n\t\t\tgoto notify_driver;\n\t\t}\n\t\tevent.u.mlme.status = MLME_SUCCESS;\n\t\tdrv_event_callback(sdata->local, sdata, &event);\n\t\tsdata_info(sdata, \"associated\\n\");\n\n\t\tinfo.success = 1;\n\t}\n\n\tfor (link_id = 0; link_id < IEEE80211_MLD_MAX_NUM_LINKS; link_id++) {\n\t\tstruct ieee80211_link_data *link;\n\n\t\tif (!assoc_data->link[link_id].bss)\n\t\t\tcontinue;\n\n\t\tresp.links[link_id].bss = assoc_data->link[link_id].bss;\n\t\tether_addr_copy(resp.links[link_id].addr,\n\t\t\t\tassoc_data->link[link_id].addr);\n\t\tresp.links[link_id].status = assoc_data->link[link_id].status;\n\n\t\tlink = sdata_dereference(sdata->link[link_id], sdata);\n\t\tif (!link)\n\t\t\tcontinue;\n\n\t\t \n\t\tresp.uapsd_queues = 0;\n\t\tfor (ac = 0; ac < IEEE80211_NUM_ACS; ac++)\n\t\t\tif (link->tx_conf[ac].uapsd)\n\t\t\t\tresp.uapsd_queues |= ieee80211_ac_to_qos_mask[ac];\n\t}\n\n\tif (ieee80211_vif_is_mld(&sdata->vif)) {\n\t\tether_addr_copy(ap_mld_addr, sdata->vif.cfg.ap_addr);\n\t\tresp.ap_mld_addr = ap_mld_addr;\n\t}\n\n\tieee80211_destroy_assoc_data(sdata,\n\t\t\t\t     status_code == WLAN_STATUS_SUCCESS ?\n\t\t\t\t\tASSOC_SUCCESS :\n\t\t\t\t\tASSOC_REJECTED);\n\n\tresp.buf = (u8 *)mgmt;\n\tresp.len = len;\n\tresp.req_ies = ifmgd->assoc_req_ies;\n\tresp.req_ies_len = ifmgd->assoc_req_ies_len;\n\tcfg80211_rx_assoc_resp(sdata->dev, &resp);\nnotify_driver:\n\tdrv_mgd_complete_tx(sdata->local, sdata, &info);\n\tkfree(elems);\n\treturn;\nabandon_assoc:\n\tieee80211_destroy_assoc_data(sdata, ASSOC_ABANDON);\n\tgoto notify_driver;\n}\n\nstatic void ieee80211_rx_bss_info(struct ieee80211_link_data *link,\n\t\t\t\t  struct ieee80211_mgmt *mgmt, size_t len,\n\t\t\t\t  struct ieee80211_rx_status *rx_status)\n{\n\tstruct ieee80211_sub_if_data *sdata = link->sdata;\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct ieee80211_bss *bss;\n\tstruct ieee80211_channel *channel;\n\n\tsdata_assert_lock(sdata);\n\n\tchannel = ieee80211_get_channel_khz(local->hw.wiphy,\n\t\t\t\t\tieee80211_rx_status_to_khz(rx_status));\n\tif (!channel)\n\t\treturn;\n\n\tbss = ieee80211_bss_info_update(local, rx_status, mgmt, len, channel);\n\tif (bss) {\n\t\tlink->conf->beacon_rate = bss->beacon_rate;\n\t\tieee80211_rx_bss_put(local, bss);\n\t}\n}\n\n\nstatic void ieee80211_rx_mgmt_probe_resp(struct ieee80211_link_data *link,\n\t\t\t\t\t struct sk_buff *skb)\n{\n\tstruct ieee80211_sub_if_data *sdata = link->sdata;\n\tstruct ieee80211_mgmt *mgmt = (void *)skb->data;\n\tstruct ieee80211_if_managed *ifmgd;\n\tstruct ieee80211_rx_status *rx_status = (void *) skb->cb;\n\tstruct ieee80211_channel *channel;\n\tsize_t baselen, len = skb->len;\n\n\tifmgd = &sdata->u.mgd;\n\n\tsdata_assert_lock(sdata);\n\n\t \n\tchannel = ieee80211_get_channel(sdata->local->hw.wiphy,\n\t\t\t\t\trx_status->freq);\n\tif (!channel)\n\t\treturn;\n\n\tif (!ether_addr_equal(mgmt->da, sdata->vif.addr) &&\n\t    (channel->band != NL80211_BAND_6GHZ ||\n\t     !is_broadcast_ether_addr(mgmt->da)))\n\t\treturn;  \n\n\tbaselen = (u8 *) mgmt->u.probe_resp.variable - (u8 *) mgmt;\n\tif (baselen > len)\n\t\treturn;\n\n\tieee80211_rx_bss_info(link, mgmt, len, rx_status);\n\n\tif (ifmgd->associated &&\n\t    ether_addr_equal(mgmt->bssid, link->u.mgd.bssid))\n\t\tieee80211_reset_ap_probe(sdata);\n}\n\n \nstatic const u64 care_about_ies =\n\t(1ULL << WLAN_EID_COUNTRY) |\n\t(1ULL << WLAN_EID_ERP_INFO) |\n\t(1ULL << WLAN_EID_CHANNEL_SWITCH) |\n\t(1ULL << WLAN_EID_PWR_CONSTRAINT) |\n\t(1ULL << WLAN_EID_HT_CAPABILITY) |\n\t(1ULL << WLAN_EID_HT_OPERATION) |\n\t(1ULL << WLAN_EID_EXT_CHANSWITCH_ANN);\n\nstatic void ieee80211_handle_beacon_sig(struct ieee80211_link_data *link,\n\t\t\t\t\tstruct ieee80211_if_managed *ifmgd,\n\t\t\t\t\tstruct ieee80211_bss_conf *bss_conf,\n\t\t\t\t\tstruct ieee80211_local *local,\n\t\t\t\t\tstruct ieee80211_rx_status *rx_status)\n{\n\tstruct ieee80211_sub_if_data *sdata = link->sdata;\n\n\t \n\n\tif (!link->u.mgd.tracking_signal_avg) {\n\t\tlink->u.mgd.tracking_signal_avg = true;\n\t\tewma_beacon_signal_init(&link->u.mgd.ave_beacon_signal);\n\t\tlink->u.mgd.last_cqm_event_signal = 0;\n\t\tlink->u.mgd.count_beacon_signal = 1;\n\t\tlink->u.mgd.last_ave_beacon_signal = 0;\n\t} else {\n\t\tlink->u.mgd.count_beacon_signal++;\n\t}\n\n\tewma_beacon_signal_add(&link->u.mgd.ave_beacon_signal,\n\t\t\t       -rx_status->signal);\n\n\tif (ifmgd->rssi_min_thold != ifmgd->rssi_max_thold &&\n\t    link->u.mgd.count_beacon_signal >= IEEE80211_SIGNAL_AVE_MIN_COUNT) {\n\t\tint sig = -ewma_beacon_signal_read(&link->u.mgd.ave_beacon_signal);\n\t\tint last_sig = link->u.mgd.last_ave_beacon_signal;\n\t\tstruct ieee80211_event event = {\n\t\t\t.type = RSSI_EVENT,\n\t\t};\n\n\t\t \n\t\tif (sig > ifmgd->rssi_max_thold &&\n\t\t    (last_sig <= ifmgd->rssi_min_thold || last_sig == 0)) {\n\t\t\tlink->u.mgd.last_ave_beacon_signal = sig;\n\t\t\tevent.u.rssi.data = RSSI_EVENT_HIGH;\n\t\t\tdrv_event_callback(local, sdata, &event);\n\t\t} else if (sig < ifmgd->rssi_min_thold &&\n\t\t\t   (last_sig >= ifmgd->rssi_max_thold ||\n\t\t\t   last_sig == 0)) {\n\t\t\tlink->u.mgd.last_ave_beacon_signal = sig;\n\t\t\tevent.u.rssi.data = RSSI_EVENT_LOW;\n\t\t\tdrv_event_callback(local, sdata, &event);\n\t\t}\n\t}\n\n\tif (bss_conf->cqm_rssi_thold &&\n\t    link->u.mgd.count_beacon_signal >= IEEE80211_SIGNAL_AVE_MIN_COUNT &&\n\t    !(sdata->vif.driver_flags & IEEE80211_VIF_SUPPORTS_CQM_RSSI)) {\n\t\tint sig = -ewma_beacon_signal_read(&link->u.mgd.ave_beacon_signal);\n\t\tint last_event = link->u.mgd.last_cqm_event_signal;\n\t\tint thold = bss_conf->cqm_rssi_thold;\n\t\tint hyst = bss_conf->cqm_rssi_hyst;\n\n\t\tif (sig < thold &&\n\t\t    (last_event == 0 || sig < last_event - hyst)) {\n\t\t\tlink->u.mgd.last_cqm_event_signal = sig;\n\t\t\tieee80211_cqm_rssi_notify(\n\t\t\t\t&sdata->vif,\n\t\t\t\tNL80211_CQM_RSSI_THRESHOLD_EVENT_LOW,\n\t\t\t\tsig, GFP_KERNEL);\n\t\t} else if (sig > thold &&\n\t\t\t   (last_event == 0 || sig > last_event + hyst)) {\n\t\t\tlink->u.mgd.last_cqm_event_signal = sig;\n\t\t\tieee80211_cqm_rssi_notify(\n\t\t\t\t&sdata->vif,\n\t\t\t\tNL80211_CQM_RSSI_THRESHOLD_EVENT_HIGH,\n\t\t\t\tsig, GFP_KERNEL);\n\t\t}\n\t}\n\n\tif (bss_conf->cqm_rssi_low &&\n\t    link->u.mgd.count_beacon_signal >= IEEE80211_SIGNAL_AVE_MIN_COUNT) {\n\t\tint sig = -ewma_beacon_signal_read(&link->u.mgd.ave_beacon_signal);\n\t\tint last_event = link->u.mgd.last_cqm_event_signal;\n\t\tint low = bss_conf->cqm_rssi_low;\n\t\tint high = bss_conf->cqm_rssi_high;\n\n\t\tif (sig < low &&\n\t\t    (last_event == 0 || last_event >= low)) {\n\t\t\tlink->u.mgd.last_cqm_event_signal = sig;\n\t\t\tieee80211_cqm_rssi_notify(\n\t\t\t\t&sdata->vif,\n\t\t\t\tNL80211_CQM_RSSI_THRESHOLD_EVENT_LOW,\n\t\t\t\tsig, GFP_KERNEL);\n\t\t} else if (sig > high &&\n\t\t\t   (last_event == 0 || last_event <= high)) {\n\t\t\tlink->u.mgd.last_cqm_event_signal = sig;\n\t\t\tieee80211_cqm_rssi_notify(\n\t\t\t\t&sdata->vif,\n\t\t\t\tNL80211_CQM_RSSI_THRESHOLD_EVENT_HIGH,\n\t\t\t\tsig, GFP_KERNEL);\n\t\t}\n\t}\n}\n\nstatic bool ieee80211_rx_our_beacon(const u8 *tx_bssid,\n\t\t\t\t    struct cfg80211_bss *bss)\n{\n\tif (ether_addr_equal(tx_bssid, bss->bssid))\n\t\treturn true;\n\tif (!bss->transmitted_bss)\n\t\treturn false;\n\treturn ether_addr_equal(tx_bssid, bss->transmitted_bss->bssid);\n}\n\nstatic bool ieee80211_config_puncturing(struct ieee80211_link_data *link,\n\t\t\t\t\tconst struct ieee80211_eht_operation *eht_oper,\n\t\t\t\t\tu64 *changed)\n{\n\tu16 bitmap = 0, extracted;\n\n\tif ((eht_oper->params & IEEE80211_EHT_OPER_INFO_PRESENT) &&\n\t    (eht_oper->params &\n\t     IEEE80211_EHT_OPER_DISABLED_SUBCHANNEL_BITMAP_PRESENT)) {\n\t\tconst struct ieee80211_eht_operation_info *info =\n\t\t\t(void *)eht_oper->optional;\n\t\tconst u8 *disable_subchannel_bitmap = info->optional;\n\n\t\tbitmap = get_unaligned_le16(disable_subchannel_bitmap);\n\t}\n\n\textracted = ieee80211_extract_dis_subch_bmap(eht_oper,\n\t\t\t\t\t\t     &link->conf->chandef,\n\t\t\t\t\t\t     bitmap);\n\n\t \n\tif (!(*changed & BSS_CHANGED_BANDWIDTH) &&\n\t    extracted == link->conf->eht_puncturing)\n\t\treturn true;\n\n\tif (!cfg80211_valid_disable_subchannel_bitmap(&bitmap,\n\t\t\t\t\t\t      &link->conf->chandef)) {\n\t\tlink_info(link,\n\t\t\t  \"Got an invalid disable subchannel bitmap from AP %pM: bitmap = 0x%x, bw = 0x%x. disconnect\\n\",\n\t\t\t  link->u.mgd.bssid,\n\t\t\t  bitmap,\n\t\t\t  link->conf->chandef.width);\n\t\treturn false;\n\t}\n\n\tieee80211_handle_puncturing_bitmap(link, eht_oper, bitmap, changed);\n\treturn true;\n}\n\nstatic void ieee80211_ml_reconf_work(struct wiphy *wiphy,\n\t\t\t\t     struct wiphy_work *work)\n{\n\tstruct ieee80211_sub_if_data *sdata =\n\t\tcontainer_of(work, struct ieee80211_sub_if_data,\n\t\t\t     u.mgd.ml_reconf_work.work);\n\tu16 new_valid_links, new_active_links, new_dormant_links;\n\tint ret;\n\n\tsdata_lock(sdata);\n\tif (!sdata->u.mgd.removed_links) {\n\t\tsdata_unlock(sdata);\n\t\treturn;\n\t}\n\n\tsdata_info(sdata,\n\t\t   \"MLO Reconfiguration: work: valid=0x%x, removed=0x%x\\n\",\n\t\t   sdata->vif.valid_links, sdata->u.mgd.removed_links);\n\n\tnew_valid_links = sdata->vif.valid_links & ~sdata->u.mgd.removed_links;\n\tif (new_valid_links == sdata->vif.valid_links) {\n\t\tsdata_unlock(sdata);\n\t\treturn;\n\t}\n\n\tif (!new_valid_links ||\n\t    !(new_valid_links & ~sdata->vif.dormant_links)) {\n\t\tsdata_info(sdata, \"No valid links after reconfiguration\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tnew_active_links = sdata->vif.active_links & ~sdata->u.mgd.removed_links;\n\tif (new_active_links != sdata->vif.active_links) {\n\t\tif (!new_active_links)\n\t\t\tnew_active_links =\n\t\t\t\tBIT(ffs(new_valid_links &\n\t\t\t\t\t~sdata->vif.dormant_links) - 1);\n\n\t\tret = __ieee80211_set_active_links(&sdata->vif,\n\t\t\t\t\t\t   new_active_links);\n\t\tif (ret) {\n\t\t\tsdata_info(sdata,\n\t\t\t\t   \"Failed setting active links\\n\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tnew_dormant_links = sdata->vif.dormant_links & ~sdata->u.mgd.removed_links;\n\n\tret = ieee80211_vif_set_links(sdata, new_valid_links,\n\t\t\t\t      new_dormant_links);\n\tif (ret)\n\t\tsdata_info(sdata, \"Failed setting valid links\\n\");\n\nout:\n\tif (!ret)\n\t\tcfg80211_links_removed(sdata->dev, sdata->u.mgd.removed_links);\n\telse\n\t\t___ieee80211_disconnect(sdata);\n\n\tsdata->u.mgd.removed_links = 0;\n\n\tsdata_unlock(sdata);\n}\n\nstatic void ieee80211_ml_reconfiguration(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t\t struct ieee802_11_elems *elems)\n{\n\tconst struct ieee80211_multi_link_elem *ml;\n\tconst struct element *sub;\n\tssize_t ml_len;\n\tunsigned long removed_links = 0;\n\tu16 link_removal_timeout[IEEE80211_MLD_MAX_NUM_LINKS] = {};\n\tu8 link_id;\n\tu32 delay;\n\n\tif (!ieee80211_vif_is_mld(&sdata->vif) || !elems->ml_reconf)\n\t\treturn;\n\n\tml_len = cfg80211_defragment_element(elems->ml_reconf_elem,\n\t\t\t\t\t     elems->ie_start,\n\t\t\t\t\t     elems->total_len,\n\t\t\t\t\t     elems->scratch_pos,\n\t\t\t\t\t     elems->scratch + elems->scratch_len -\n\t\t\t\t\t     elems->scratch_pos,\n\t\t\t\t\t     WLAN_EID_FRAGMENT);\n\tif (ml_len < 0)\n\t\treturn;\n\n\telems->ml_reconf = (const void *)elems->scratch_pos;\n\telems->ml_reconf_len = ml_len;\n\tml = elems->ml_reconf;\n\n\t \n\tfor_each_mle_subelement(sub, (u8 *)ml, ml_len) {\n\t\tstruct ieee80211_mle_per_sta_profile *prof = (void *)sub->data;\n\t\tu8 *pos = prof->variable;\n\t\tu16 control;\n\n\t\tif (sub->id != IEEE80211_MLE_SUBELEM_PER_STA_PROFILE)\n\t\t\tcontinue;\n\n\t\tif (!ieee80211_mle_reconf_sta_prof_size_ok(sub->data,\n\t\t\t\t\t\t\t   sub->datalen))\n\t\t\treturn;\n\n\t\tcontrol = le16_to_cpu(prof->control);\n\t\tlink_id = control & IEEE80211_MLE_STA_RECONF_CONTROL_LINK_ID;\n\n\t\tremoved_links |= BIT(link_id);\n\n\t\t \n\t\tif (control &\n\t\t    IEEE80211_MLE_STA_RECONF_CONTROL_STA_MAC_ADDR_PRESENT)\n\t\t\tpos += 6;\n\n\t\t \n\t\tif (control &\n\t\t    IEEE80211_MLE_STA_RECONF_CONTROL_AP_REM_TIMER_PRESENT)\n\t\t\tlink_removal_timeout[link_id] = le16_to_cpu(*(__le16 *)pos);\n\t}\n\n\tremoved_links &= sdata->vif.valid_links;\n\tif (!removed_links) {\n\t\t \n\t\tif (sdata->u.mgd.removed_links) {\n\t\t\tsdata->u.mgd.removed_links = 0;\n\t\t\twiphy_delayed_work_cancel(sdata->local->hw.wiphy,\n\t\t\t\t\t\t  &sdata->u.mgd.ml_reconf_work);\n\t\t}\n\t\treturn;\n\t}\n\n\tdelay = 0;\n\tfor_each_set_bit(link_id, &removed_links, IEEE80211_MLD_MAX_NUM_LINKS) {\n\t\tstruct ieee80211_bss_conf *link_conf =\n\t\t\tsdata_dereference(sdata->vif.link_conf[link_id], sdata);\n\t\tu32 link_delay;\n\n\t\tif (!link_conf) {\n\t\t\tremoved_links &= ~BIT(link_id);\n\t\t\tcontinue;\n\t\t}\n\n\t\tlink_delay = link_conf->beacon_int *\n\t\t\tlink_removal_timeout[link_id];\n\n\t\tif (!delay)\n\t\t\tdelay = link_delay;\n\t\telse\n\t\t\tdelay = min(delay, link_delay);\n\t}\n\n\tsdata->u.mgd.removed_links = removed_links;\n\twiphy_delayed_work_queue(sdata->local->hw.wiphy,\n\t\t\t\t &sdata->u.mgd.ml_reconf_work,\n\t\t\t\t TU_TO_JIFFIES(delay));\n}\n\nstatic void ieee80211_rx_mgmt_beacon(struct ieee80211_link_data *link,\n\t\t\t\t     struct ieee80211_hdr *hdr, size_t len,\n\t\t\t\t     struct ieee80211_rx_status *rx_status)\n{\n\tstruct ieee80211_sub_if_data *sdata = link->sdata;\n\tstruct ieee80211_if_managed *ifmgd = &sdata->u.mgd;\n\tstruct ieee80211_bss_conf *bss_conf = &sdata->vif.bss_conf;\n\tstruct ieee80211_vif_cfg *vif_cfg = &sdata->vif.cfg;\n\tstruct ieee80211_mgmt *mgmt = (void *) hdr;\n\tsize_t baselen;\n\tstruct ieee802_11_elems *elems;\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct ieee80211_chanctx_conf *chanctx_conf;\n\tstruct ieee80211_supported_band *sband;\n\tstruct ieee80211_channel *chan;\n\tstruct link_sta_info *link_sta;\n\tstruct sta_info *sta;\n\tu64 changed = 0;\n\tbool erp_valid;\n\tu8 erp_value = 0;\n\tu32 ncrc = 0;\n\tu8 *bssid, *variable = mgmt->u.beacon.variable;\n\tu8 deauth_buf[IEEE80211_DEAUTH_FRAME_LEN];\n\tstruct ieee80211_elems_parse_params parse_params = {\n\t\t.link_id = -1,\n\t\t.from_ap = true,\n\t};\n\n\tsdata_assert_lock(sdata);\n\n\t \n\tbssid = ieee80211_get_bssid(hdr, len, sdata->vif.type);\n\tif (ieee80211_is_s1g_beacon(mgmt->frame_control)) {\n\t\tstruct ieee80211_ext *ext = (void *) mgmt;\n\n\t\tif (ieee80211_is_s1g_short_beacon(ext->frame_control))\n\t\t\tvariable = ext->u.s1g_short_beacon.variable;\n\t\telse\n\t\t\tvariable = ext->u.s1g_beacon.variable;\n\t}\n\n\tbaselen = (u8 *) variable - (u8 *) mgmt;\n\tif (baselen > len)\n\t\treturn;\n\n\tparse_params.start = variable;\n\tparse_params.len = len - baselen;\n\n\trcu_read_lock();\n\tchanctx_conf = rcu_dereference(link->conf->chanctx_conf);\n\tif (!chanctx_conf) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\tif (ieee80211_rx_status_to_khz(rx_status) !=\n\t    ieee80211_channel_to_khz(chanctx_conf->def.chan)) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\tchan = chanctx_conf->def.chan;\n\trcu_read_unlock();\n\n\tif (ifmgd->assoc_data && ifmgd->assoc_data->need_beacon &&\n\t    !WARN_ON(ieee80211_vif_is_mld(&sdata->vif)) &&\n\t    ieee80211_rx_our_beacon(bssid, ifmgd->assoc_data->link[0].bss)) {\n\t\tparse_params.bss = ifmgd->assoc_data->link[0].bss;\n\t\telems = ieee802_11_parse_elems_full(&parse_params);\n\t\tif (!elems)\n\t\t\treturn;\n\n\t\tieee80211_rx_bss_info(link, mgmt, len, rx_status);\n\n\t\tif (elems->dtim_period)\n\t\t\tlink->u.mgd.dtim_period = elems->dtim_period;\n\t\tlink->u.mgd.have_beacon = true;\n\t\tifmgd->assoc_data->need_beacon = false;\n\t\tif (ieee80211_hw_check(&local->hw, TIMING_BEACON_ONLY)) {\n\t\t\tlink->conf->sync_tsf =\n\t\t\t\tle64_to_cpu(mgmt->u.beacon.timestamp);\n\t\t\tlink->conf->sync_device_ts =\n\t\t\t\trx_status->device_timestamp;\n\t\t\tlink->conf->sync_dtim_count = elems->dtim_count;\n\t\t}\n\n\t\tif (elems->mbssid_config_ie)\n\t\t\tbss_conf->profile_periodicity =\n\t\t\t\telems->mbssid_config_ie->profile_periodicity;\n\t\telse\n\t\t\tbss_conf->profile_periodicity = 0;\n\n\t\tif (elems->ext_capab_len >= 11 &&\n\t\t    (elems->ext_capab[10] & WLAN_EXT_CAPA11_EMA_SUPPORT))\n\t\t\tbss_conf->ema_ap = true;\n\t\telse\n\t\t\tbss_conf->ema_ap = false;\n\n\t\t \n\t\tifmgd->assoc_data->timeout = jiffies;\n\t\tifmgd->assoc_data->timeout_started = true;\n\t\trun_again(sdata, ifmgd->assoc_data->timeout);\n\t\tkfree(elems);\n\t\treturn;\n\t}\n\n\tif (!ifmgd->associated ||\n\t    !ieee80211_rx_our_beacon(bssid, link->u.mgd.bss))\n\t\treturn;\n\tbssid = link->u.mgd.bssid;\n\n\tif (!(rx_status->flag & RX_FLAG_NO_SIGNAL_VAL))\n\t\tieee80211_handle_beacon_sig(link, ifmgd, bss_conf,\n\t\t\t\t\t    local, rx_status);\n\n\tif (ifmgd->flags & IEEE80211_STA_CONNECTION_POLL) {\n\t\tmlme_dbg_ratelimited(sdata,\n\t\t\t\t     \"cancelling AP probe due to a received beacon\\n\");\n\t\tieee80211_reset_ap_probe(sdata);\n\t}\n\n\t \n\tieee80211_sta_reset_beacon_monitor(sdata);\n\n\t \n\tif (!ieee80211_is_s1g_beacon(hdr->frame_control))\n\t\tncrc = crc32_be(0, (void *)&mgmt->u.beacon.beacon_int, 4);\n\tparse_params.bss = link->u.mgd.bss;\n\tparse_params.filter = care_about_ies;\n\tparse_params.crc = ncrc;\n\telems = ieee802_11_parse_elems_full(&parse_params);\n\tif (!elems)\n\t\treturn;\n\tncrc = elems->crc;\n\n\tif (ieee80211_hw_check(&local->hw, PS_NULLFUNC_STACK) &&\n\t    ieee80211_check_tim(elems->tim, elems->tim_len, vif_cfg->aid)) {\n\t\tif (local->hw.conf.dynamic_ps_timeout > 0) {\n\t\t\tif (local->hw.conf.flags & IEEE80211_CONF_PS) {\n\t\t\t\tlocal->hw.conf.flags &= ~IEEE80211_CONF_PS;\n\t\t\t\tieee80211_hw_config(local,\n\t\t\t\t\t\t    IEEE80211_CONF_CHANGE_PS);\n\t\t\t}\n\t\t\tieee80211_send_nullfunc(local, sdata, false);\n\t\t} else if (!local->pspolling && sdata->u.mgd.powersave) {\n\t\t\tlocal->pspolling = true;\n\n\t\t\t \n\t\t\tieee80211_send_pspoll(local, sdata);\n\t\t}\n\t}\n\n\tif (sdata->vif.p2p ||\n\t    sdata->vif.driver_flags & IEEE80211_VIF_GET_NOA_UPDATE) {\n\t\tstruct ieee80211_p2p_noa_attr noa = {};\n\t\tint ret;\n\n\t\tret = cfg80211_get_p2p_attr(variable,\n\t\t\t\t\t    len - baselen,\n\t\t\t\t\t    IEEE80211_P2P_ATTR_ABSENCE_NOTICE,\n\t\t\t\t\t    (u8 *) &noa, sizeof(noa));\n\t\tif (ret >= 2) {\n\t\t\tif (link->u.mgd.p2p_noa_index != noa.index) {\n\t\t\t\t \n\t\t\t\tlink->u.mgd.p2p_noa_index = noa.index;\n\t\t\t\tmemcpy(&bss_conf->p2p_noa_attr, &noa, sizeof(noa));\n\t\t\t\tchanged |= BSS_CHANGED_P2P_PS;\n\t\t\t\t \n\t\t\t\tlink->u.mgd.beacon_crc_valid = false;\n\t\t\t}\n\t\t} else if (link->u.mgd.p2p_noa_index != -1) {\n\t\t\t \n\t\t\tlink->u.mgd.p2p_noa_index = -1;\n\t\t\tmemset(&bss_conf->p2p_noa_attr, 0, sizeof(bss_conf->p2p_noa_attr));\n\t\t\tchanged |= BSS_CHANGED_P2P_PS;\n\t\t\tlink->u.mgd.beacon_crc_valid = false;\n\t\t}\n\t}\n\n\tif (link->u.mgd.csa_waiting_bcn)\n\t\tieee80211_chswitch_post_beacon(link);\n\n\t \n\tif (ieee80211_hw_check(&local->hw, TIMING_BEACON_ONLY) &&\n\t    !ieee80211_is_s1g_beacon(hdr->frame_control)) {\n\t\tlink->conf->sync_tsf =\n\t\t\tle64_to_cpu(mgmt->u.beacon.timestamp);\n\t\tlink->conf->sync_device_ts =\n\t\t\trx_status->device_timestamp;\n\t\tlink->conf->sync_dtim_count = elems->dtim_count;\n\t}\n\n\tif ((ncrc == link->u.mgd.beacon_crc && link->u.mgd.beacon_crc_valid) ||\n\t    ieee80211_is_s1g_short_beacon(mgmt->frame_control))\n\t\tgoto free;\n\tlink->u.mgd.beacon_crc = ncrc;\n\tlink->u.mgd.beacon_crc_valid = true;\n\n\tieee80211_rx_bss_info(link, mgmt, len, rx_status);\n\n\tieee80211_sta_process_chanswitch(link, rx_status->mactime,\n\t\t\t\t\t rx_status->device_timestamp,\n\t\t\t\t\t elems, true);\n\n\tif (!link->u.mgd.disable_wmm_tracking &&\n\t    ieee80211_sta_wmm_params(local, link, elems->wmm_param,\n\t\t\t\t     elems->wmm_param_len,\n\t\t\t\t     elems->mu_edca_param_set))\n\t\tchanged |= BSS_CHANGED_QOS;\n\n\t \n\tif (!link->u.mgd.have_beacon) {\n\t\t \n\t\tbss_conf->dtim_period = elems->dtim_period ?: 1;\n\n\t\tchanged |= BSS_CHANGED_BEACON_INFO;\n\t\tlink->u.mgd.have_beacon = true;\n\n\t\tmutex_lock(&local->iflist_mtx);\n\t\tieee80211_recalc_ps(local);\n\t\tmutex_unlock(&local->iflist_mtx);\n\n\t\tieee80211_recalc_ps_vif(sdata);\n\t}\n\n\tif (elems->erp_info) {\n\t\terp_valid = true;\n\t\terp_value = elems->erp_info[0];\n\t} else {\n\t\terp_valid = false;\n\t}\n\n\tif (!ieee80211_is_s1g_beacon(hdr->frame_control))\n\t\tchanged |= ieee80211_handle_bss_capability(link,\n\t\t\t\tle16_to_cpu(mgmt->u.beacon.capab_info),\n\t\t\t\terp_valid, erp_value);\n\n\tmutex_lock(&local->sta_mtx);\n\tsta = sta_info_get(sdata, sdata->vif.cfg.ap_addr);\n\tif (WARN_ON(!sta)) {\n\t\tmutex_unlock(&local->sta_mtx);\n\t\tgoto free;\n\t}\n\tlink_sta = rcu_dereference_protected(sta->link[link->link_id],\n\t\t\t\t\t     lockdep_is_held(&local->sta_mtx));\n\tif (WARN_ON(!link_sta)) {\n\t\tmutex_unlock(&local->sta_mtx);\n\t\tgoto free;\n\t}\n\n\tif (WARN_ON(!link->conf->chandef.chan))\n\t\tgoto free;\n\n\tsband = local->hw.wiphy->bands[link->conf->chandef.chan->band];\n\n\tchanged |= ieee80211_recalc_twt_req(sdata, sband, link, link_sta, elems);\n\n\tif (ieee80211_config_bw(link, elems->ht_cap_elem,\n\t\t\t\telems->vht_cap_elem, elems->ht_operation,\n\t\t\t\telems->vht_operation, elems->he_operation,\n\t\t\t\telems->eht_operation,\n\t\t\t\telems->s1g_oper, bssid, &changed)) {\n\t\tmutex_unlock(&local->sta_mtx);\n\t\tsdata_info(sdata,\n\t\t\t   \"failed to follow AP %pM bandwidth change, disconnect\\n\",\n\t\t\t   bssid);\n\t\tieee80211_set_disassoc(sdata, IEEE80211_STYPE_DEAUTH,\n\t\t\t\t       WLAN_REASON_DEAUTH_LEAVING,\n\t\t\t\t       true, deauth_buf);\n\t\tieee80211_report_disconnect(sdata, deauth_buf,\n\t\t\t\t\t    sizeof(deauth_buf), true,\n\t\t\t\t\t    WLAN_REASON_DEAUTH_LEAVING,\n\t\t\t\t\t    false);\n\t\tgoto free;\n\t}\n\n\tif (elems->opmode_notif)\n\t\tieee80211_vht_handle_opmode(sdata, link_sta,\n\t\t\t\t\t    *elems->opmode_notif,\n\t\t\t\t\t    rx_status->band);\n\tmutex_unlock(&local->sta_mtx);\n\n\tchanged |= ieee80211_handle_pwr_constr(link, chan, mgmt,\n\t\t\t\t\t       elems->country_elem,\n\t\t\t\t\t       elems->country_elem_len,\n\t\t\t\t\t       elems->pwr_constr_elem,\n\t\t\t\t\t       elems->cisco_dtpc_elem);\n\n\tif (elems->eht_operation &&\n\t    !(link->u.mgd.conn_flags & IEEE80211_CONN_DISABLE_EHT)) {\n\t\tif (!ieee80211_config_puncturing(link, elems->eht_operation,\n\t\t\t\t\t\t &changed)) {\n\t\t\tieee80211_set_disassoc(sdata, IEEE80211_STYPE_DEAUTH,\n\t\t\t\t\t       WLAN_REASON_DEAUTH_LEAVING,\n\t\t\t\t\t       true, deauth_buf);\n\t\t\tieee80211_report_disconnect(sdata, deauth_buf,\n\t\t\t\t\t\t    sizeof(deauth_buf), true,\n\t\t\t\t\t\t    WLAN_REASON_DEAUTH_LEAVING,\n\t\t\t\t\t\t    false);\n\t\t\tgoto free;\n\t\t}\n\t}\n\n\tieee80211_ml_reconfiguration(sdata, elems);\n\n\tieee80211_link_info_change_notify(sdata, link, changed);\nfree:\n\tkfree(elems);\n}\n\nvoid ieee80211_sta_rx_queued_ext(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t struct sk_buff *skb)\n{\n\tstruct ieee80211_link_data *link = &sdata->deflink;\n\tstruct ieee80211_rx_status *rx_status;\n\tstruct ieee80211_hdr *hdr;\n\tu16 fc;\n\n\trx_status = (struct ieee80211_rx_status *) skb->cb;\n\thdr = (struct ieee80211_hdr *) skb->data;\n\tfc = le16_to_cpu(hdr->frame_control);\n\n\tsdata_lock(sdata);\n\tswitch (fc & IEEE80211_FCTL_STYPE) {\n\tcase IEEE80211_STYPE_S1G_BEACON:\n\t\tieee80211_rx_mgmt_beacon(link, hdr, skb->len, rx_status);\n\t\tbreak;\n\t}\n\tsdata_unlock(sdata);\n}\n\nvoid ieee80211_sta_rx_queued_mgmt(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t  struct sk_buff *skb)\n{\n\tstruct ieee80211_link_data *link = &sdata->deflink;\n\tstruct ieee80211_rx_status *rx_status;\n\tstruct ieee80211_mgmt *mgmt;\n\tu16 fc;\n\tint ies_len;\n\n\trx_status = (struct ieee80211_rx_status *) skb->cb;\n\tmgmt = (struct ieee80211_mgmt *) skb->data;\n\tfc = le16_to_cpu(mgmt->frame_control);\n\n\tsdata_lock(sdata);\n\n\tif (rx_status->link_valid) {\n\t\tlink = sdata_dereference(sdata->link[rx_status->link_id],\n\t\t\t\t\t sdata);\n\t\tif (!link)\n\t\t\tgoto out;\n\t}\n\n\tswitch (fc & IEEE80211_FCTL_STYPE) {\n\tcase IEEE80211_STYPE_BEACON:\n\t\tieee80211_rx_mgmt_beacon(link, (void *)mgmt,\n\t\t\t\t\t skb->len, rx_status);\n\t\tbreak;\n\tcase IEEE80211_STYPE_PROBE_RESP:\n\t\tieee80211_rx_mgmt_probe_resp(link, skb);\n\t\tbreak;\n\tcase IEEE80211_STYPE_AUTH:\n\t\tieee80211_rx_mgmt_auth(sdata, mgmt, skb->len);\n\t\tbreak;\n\tcase IEEE80211_STYPE_DEAUTH:\n\t\tieee80211_rx_mgmt_deauth(sdata, mgmt, skb->len);\n\t\tbreak;\n\tcase IEEE80211_STYPE_DISASSOC:\n\t\tieee80211_rx_mgmt_disassoc(sdata, mgmt, skb->len);\n\t\tbreak;\n\tcase IEEE80211_STYPE_ASSOC_RESP:\n\tcase IEEE80211_STYPE_REASSOC_RESP:\n\t\tieee80211_rx_mgmt_assoc_resp(sdata, mgmt, skb->len);\n\t\tbreak;\n\tcase IEEE80211_STYPE_ACTION:\n\t\tif (!sdata->u.mgd.associated ||\n\t\t    !ether_addr_equal(mgmt->bssid, sdata->vif.cfg.ap_addr))\n\t\t\tbreak;\n\n\t\tif (mgmt->u.action.category == WLAN_CATEGORY_SPECTRUM_MGMT) {\n\t\t\tstruct ieee802_11_elems *elems;\n\n\t\t\ties_len = skb->len -\n\t\t\t\t  offsetof(struct ieee80211_mgmt,\n\t\t\t\t\t   u.action.u.chan_switch.variable);\n\n\t\t\tif (ies_len < 0)\n\t\t\t\tbreak;\n\n\t\t\t \n\t\t\telems = ieee802_11_parse_elems(\n\t\t\t\t\tmgmt->u.action.u.chan_switch.variable,\n\t\t\t\t\ties_len, true, NULL);\n\n\t\t\tif (elems && !elems->parse_error)\n\t\t\t\tieee80211_sta_process_chanswitch(link,\n\t\t\t\t\t\t\t\t rx_status->mactime,\n\t\t\t\t\t\t\t\t rx_status->device_timestamp,\n\t\t\t\t\t\t\t\t elems, false);\n\t\t\tkfree(elems);\n\t\t} else if (mgmt->u.action.category == WLAN_CATEGORY_PUBLIC) {\n\t\t\tstruct ieee802_11_elems *elems;\n\n\t\t\ties_len = skb->len -\n\t\t\t\t  offsetof(struct ieee80211_mgmt,\n\t\t\t\t\t   u.action.u.ext_chan_switch.variable);\n\n\t\t\tif (ies_len < 0)\n\t\t\t\tbreak;\n\n\t\t\t \n\t\t\telems = ieee802_11_parse_elems(\n\t\t\t\t\tmgmt->u.action.u.ext_chan_switch.variable,\n\t\t\t\t\ties_len, true, NULL);\n\n\t\t\tif (elems && !elems->parse_error) {\n\t\t\t\t \n\t\t\t\telems->ext_chansw_ie =\n\t\t\t\t\t&mgmt->u.action.u.ext_chan_switch.data;\n\n\t\t\t\tieee80211_sta_process_chanswitch(link,\n\t\t\t\t\t\t\t\t rx_status->mactime,\n\t\t\t\t\t\t\t\t rx_status->device_timestamp,\n\t\t\t\t\t\t\t\t elems, false);\n\t\t\t}\n\n\t\t\tkfree(elems);\n\t\t}\n\t\tbreak;\n\t}\nout:\n\tsdata_unlock(sdata);\n}\n\nstatic void ieee80211_sta_timer(struct timer_list *t)\n{\n\tstruct ieee80211_sub_if_data *sdata =\n\t\tfrom_timer(sdata, t, u.mgd.timer);\n\n\twiphy_work_queue(sdata->local->hw.wiphy, &sdata->work);\n}\n\nvoid ieee80211_sta_connection_lost(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t   u8 reason, bool tx)\n{\n\tu8 frame_buf[IEEE80211_DEAUTH_FRAME_LEN];\n\n\tieee80211_set_disassoc(sdata, IEEE80211_STYPE_DEAUTH, reason,\n\t\t\t       tx, frame_buf);\n\n\tieee80211_report_disconnect(sdata, frame_buf, sizeof(frame_buf), true,\n\t\t\t\t    reason, false);\n}\n\nstatic int ieee80211_auth(struct ieee80211_sub_if_data *sdata)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct ieee80211_if_managed *ifmgd = &sdata->u.mgd;\n\tstruct ieee80211_mgd_auth_data *auth_data = ifmgd->auth_data;\n\tu32 tx_flags = 0;\n\tu16 trans = 1;\n\tu16 status = 0;\n\tstruct ieee80211_prep_tx_info info = {\n\t\t.subtype = IEEE80211_STYPE_AUTH,\n\t};\n\n\tsdata_assert_lock(sdata);\n\n\tif (WARN_ON_ONCE(!auth_data))\n\t\treturn -EINVAL;\n\n\tauth_data->tries++;\n\n\tif (auth_data->tries > IEEE80211_AUTH_MAX_TRIES) {\n\t\tsdata_info(sdata, \"authentication with %pM timed out\\n\",\n\t\t\t   auth_data->ap_addr);\n\n\t\t \n\t\tcfg80211_unlink_bss(local->hw.wiphy, auth_data->bss);\n\n\t\treturn -ETIMEDOUT;\n\t}\n\n\tif (auth_data->algorithm == WLAN_AUTH_SAE)\n\t\tinfo.duration = jiffies_to_msecs(IEEE80211_AUTH_TIMEOUT_SAE);\n\n\tdrv_mgd_prepare_tx(local, sdata, &info);\n\n\tsdata_info(sdata, \"send auth to %pM (try %d/%d)\\n\",\n\t\t   auth_data->ap_addr, auth_data->tries,\n\t\t   IEEE80211_AUTH_MAX_TRIES);\n\n\tauth_data->expected_transaction = 2;\n\n\tif (auth_data->algorithm == WLAN_AUTH_SAE) {\n\t\ttrans = auth_data->sae_trans;\n\t\tstatus = auth_data->sae_status;\n\t\tauth_data->expected_transaction = trans;\n\t}\n\n\tif (ieee80211_hw_check(&local->hw, REPORTS_TX_ACK_STATUS))\n\t\ttx_flags = IEEE80211_TX_CTL_REQ_TX_STATUS |\n\t\t\t   IEEE80211_TX_INTFL_MLME_CONN_TX;\n\n\tieee80211_send_auth(sdata, trans, auth_data->algorithm, status,\n\t\t\t    auth_data->data, auth_data->data_len,\n\t\t\t    auth_data->ap_addr, auth_data->ap_addr,\n\t\t\t    NULL, 0, 0, tx_flags);\n\n\tif (tx_flags == 0) {\n\t\tif (auth_data->algorithm == WLAN_AUTH_SAE)\n\t\t\tauth_data->timeout = jiffies +\n\t\t\t\tIEEE80211_AUTH_TIMEOUT_SAE;\n\t\telse\n\t\t\tauth_data->timeout = jiffies + IEEE80211_AUTH_TIMEOUT;\n\t} else {\n\t\tauth_data->timeout =\n\t\t\tround_jiffies_up(jiffies + IEEE80211_AUTH_TIMEOUT_LONG);\n\t}\n\n\tauth_data->timeout_started = true;\n\trun_again(sdata, auth_data->timeout);\n\n\treturn 0;\n}\n\nstatic int ieee80211_do_assoc(struct ieee80211_sub_if_data *sdata)\n{\n\tstruct ieee80211_mgd_assoc_data *assoc_data = sdata->u.mgd.assoc_data;\n\tstruct ieee80211_local *local = sdata->local;\n\tint ret;\n\n\tsdata_assert_lock(sdata);\n\n\tassoc_data->tries++;\n\tif (assoc_data->tries > IEEE80211_ASSOC_MAX_TRIES) {\n\t\tsdata_info(sdata, \"association with %pM timed out\\n\",\n\t\t\t   assoc_data->ap_addr);\n\n\t\t \n\t\tcfg80211_unlink_bss(local->hw.wiphy,\n\t\t\t\t    assoc_data->link[assoc_data->assoc_link_id].bss);\n\n\t\treturn -ETIMEDOUT;\n\t}\n\n\tsdata_info(sdata, \"associate with %pM (try %d/%d)\\n\",\n\t\t   assoc_data->ap_addr, assoc_data->tries,\n\t\t   IEEE80211_ASSOC_MAX_TRIES);\n\tret = ieee80211_send_assoc(sdata);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!ieee80211_hw_check(&local->hw, REPORTS_TX_ACK_STATUS)) {\n\t\tassoc_data->timeout = jiffies + IEEE80211_ASSOC_TIMEOUT;\n\t\tassoc_data->timeout_started = true;\n\t\trun_again(sdata, assoc_data->timeout);\n\t} else {\n\t\tassoc_data->timeout =\n\t\t\tround_jiffies_up(jiffies +\n\t\t\t\t\t IEEE80211_ASSOC_TIMEOUT_LONG);\n\t\tassoc_data->timeout_started = true;\n\t\trun_again(sdata, assoc_data->timeout);\n\t}\n\n\treturn 0;\n}\n\nvoid ieee80211_mgd_conn_tx_status(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t  __le16 fc, bool acked)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\n\tsdata->u.mgd.status_fc = fc;\n\tsdata->u.mgd.status_acked = acked;\n\tsdata->u.mgd.status_received = true;\n\n\twiphy_work_queue(local->hw.wiphy, &sdata->work);\n}\n\nvoid ieee80211_sta_work(struct ieee80211_sub_if_data *sdata)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct ieee80211_if_managed *ifmgd = &sdata->u.mgd;\n\n\tsdata_lock(sdata);\n\n\tif (ifmgd->status_received) {\n\t\t__le16 fc = ifmgd->status_fc;\n\t\tbool status_acked = ifmgd->status_acked;\n\n\t\tifmgd->status_received = false;\n\t\tif (ifmgd->auth_data && ieee80211_is_auth(fc)) {\n\t\t\tif (status_acked) {\n\t\t\t\tif (ifmgd->auth_data->algorithm ==\n\t\t\t\t    WLAN_AUTH_SAE)\n\t\t\t\t\tifmgd->auth_data->timeout =\n\t\t\t\t\t\tjiffies +\n\t\t\t\t\t\tIEEE80211_AUTH_TIMEOUT_SAE;\n\t\t\t\telse\n\t\t\t\t\tifmgd->auth_data->timeout =\n\t\t\t\t\t\tjiffies +\n\t\t\t\t\t\tIEEE80211_AUTH_TIMEOUT_SHORT;\n\t\t\t\trun_again(sdata, ifmgd->auth_data->timeout);\n\t\t\t} else {\n\t\t\t\tifmgd->auth_data->timeout = jiffies - 1;\n\t\t\t}\n\t\t\tifmgd->auth_data->timeout_started = true;\n\t\t} else if (ifmgd->assoc_data &&\n\t\t\t   (ieee80211_is_assoc_req(fc) ||\n\t\t\t    ieee80211_is_reassoc_req(fc))) {\n\t\t\tif (status_acked) {\n\t\t\t\tifmgd->assoc_data->timeout =\n\t\t\t\t\tjiffies + IEEE80211_ASSOC_TIMEOUT_SHORT;\n\t\t\t\trun_again(sdata, ifmgd->assoc_data->timeout);\n\t\t\t} else {\n\t\t\t\tifmgd->assoc_data->timeout = jiffies - 1;\n\t\t\t}\n\t\t\tifmgd->assoc_data->timeout_started = true;\n\t\t}\n\t}\n\n\tif (ifmgd->auth_data && ifmgd->auth_data->timeout_started &&\n\t    time_after(jiffies, ifmgd->auth_data->timeout)) {\n\t\tif (ifmgd->auth_data->done || ifmgd->auth_data->waiting) {\n\t\t\t \n\t\t\tieee80211_destroy_auth_data(sdata, false);\n\t\t} else if (ieee80211_auth(sdata)) {\n\t\t\tu8 ap_addr[ETH_ALEN];\n\t\t\tstruct ieee80211_event event = {\n\t\t\t\t.type = MLME_EVENT,\n\t\t\t\t.u.mlme.data = AUTH_EVENT,\n\t\t\t\t.u.mlme.status = MLME_TIMEOUT,\n\t\t\t};\n\n\t\t\tmemcpy(ap_addr, ifmgd->auth_data->ap_addr, ETH_ALEN);\n\n\t\t\tieee80211_destroy_auth_data(sdata, false);\n\n\t\t\tcfg80211_auth_timeout(sdata->dev, ap_addr);\n\t\t\tdrv_event_callback(sdata->local, sdata, &event);\n\t\t}\n\t} else if (ifmgd->auth_data && ifmgd->auth_data->timeout_started)\n\t\trun_again(sdata, ifmgd->auth_data->timeout);\n\n\tif (ifmgd->assoc_data && ifmgd->assoc_data->timeout_started &&\n\t    time_after(jiffies, ifmgd->assoc_data->timeout)) {\n\t\tif ((ifmgd->assoc_data->need_beacon &&\n\t\t     !sdata->deflink.u.mgd.have_beacon) ||\n\t\t    ieee80211_do_assoc(sdata)) {\n\t\t\tstruct ieee80211_event event = {\n\t\t\t\t.type = MLME_EVENT,\n\t\t\t\t.u.mlme.data = ASSOC_EVENT,\n\t\t\t\t.u.mlme.status = MLME_TIMEOUT,\n\t\t\t};\n\n\t\t\tieee80211_destroy_assoc_data(sdata, ASSOC_TIMEOUT);\n\t\t\tdrv_event_callback(sdata->local, sdata, &event);\n\t\t}\n\t} else if (ifmgd->assoc_data && ifmgd->assoc_data->timeout_started)\n\t\trun_again(sdata, ifmgd->assoc_data->timeout);\n\n\tif (ifmgd->flags & IEEE80211_STA_CONNECTION_POLL &&\n\t    ifmgd->associated) {\n\t\tu8 *bssid = sdata->deflink.u.mgd.bssid;\n\t\tint max_tries;\n\n\t\tif (ieee80211_hw_check(&local->hw, REPORTS_TX_ACK_STATUS))\n\t\t\tmax_tries = max_nullfunc_tries;\n\t\telse\n\t\t\tmax_tries = max_probe_tries;\n\n\t\t \n\t\tif (!ifmgd->probe_send_count)\n\t\t\tieee80211_reset_ap_probe(sdata);\n\t\telse if (ifmgd->nullfunc_failed) {\n\t\t\tif (ifmgd->probe_send_count < max_tries) {\n\t\t\t\tmlme_dbg(sdata,\n\t\t\t\t\t \"No ack for nullfunc frame to AP %pM, try %d/%i\\n\",\n\t\t\t\t\t bssid, ifmgd->probe_send_count,\n\t\t\t\t\t max_tries);\n\t\t\t\tieee80211_mgd_probe_ap_send(sdata);\n\t\t\t} else {\n\t\t\t\tmlme_dbg(sdata,\n\t\t\t\t\t \"No ack for nullfunc frame to AP %pM, disconnecting.\\n\",\n\t\t\t\t\t bssid);\n\t\t\t\tieee80211_sta_connection_lost(sdata,\n\t\t\t\t\tWLAN_REASON_DISASSOC_DUE_TO_INACTIVITY,\n\t\t\t\t\tfalse);\n\t\t\t}\n\t\t} else if (time_is_after_jiffies(ifmgd->probe_timeout))\n\t\t\trun_again(sdata, ifmgd->probe_timeout);\n\t\telse if (ieee80211_hw_check(&local->hw, REPORTS_TX_ACK_STATUS)) {\n\t\t\tmlme_dbg(sdata,\n\t\t\t\t \"Failed to send nullfunc to AP %pM after %dms, disconnecting\\n\",\n\t\t\t\t bssid, probe_wait_ms);\n\t\t\tieee80211_sta_connection_lost(sdata,\n\t\t\t\tWLAN_REASON_DISASSOC_DUE_TO_INACTIVITY, false);\n\t\t} else if (ifmgd->probe_send_count < max_tries) {\n\t\t\tmlme_dbg(sdata,\n\t\t\t\t \"No probe response from AP %pM after %dms, try %d/%i\\n\",\n\t\t\t\t bssid, probe_wait_ms,\n\t\t\t\t ifmgd->probe_send_count, max_tries);\n\t\t\tieee80211_mgd_probe_ap_send(sdata);\n\t\t} else {\n\t\t\t \n\t\t\tmlme_dbg(sdata,\n\t\t\t\t \"No probe response from AP %pM after %dms, disconnecting.\\n\",\n\t\t\t\t bssid, probe_wait_ms);\n\n\t\t\tieee80211_sta_connection_lost(sdata,\n\t\t\t\tWLAN_REASON_DISASSOC_DUE_TO_INACTIVITY, false);\n\t\t}\n\t}\n\n\tsdata_unlock(sdata);\n}\n\nstatic void ieee80211_sta_bcn_mon_timer(struct timer_list *t)\n{\n\tstruct ieee80211_sub_if_data *sdata =\n\t\tfrom_timer(sdata, t, u.mgd.bcn_mon_timer);\n\n\tif (WARN_ON(ieee80211_vif_is_mld(&sdata->vif)))\n\t\treturn;\n\n\tif (sdata->vif.bss_conf.csa_active &&\n\t    !sdata->deflink.u.mgd.csa_waiting_bcn)\n\t\treturn;\n\n\tif (sdata->vif.driver_flags & IEEE80211_VIF_BEACON_FILTER)\n\t\treturn;\n\n\tsdata->u.mgd.connection_loss = false;\n\twiphy_work_queue(sdata->local->hw.wiphy,\n\t\t\t &sdata->u.mgd.beacon_connection_loss_work);\n}\n\nstatic void ieee80211_sta_conn_mon_timer(struct timer_list *t)\n{\n\tstruct ieee80211_sub_if_data *sdata =\n\t\tfrom_timer(sdata, t, u.mgd.conn_mon_timer);\n\tstruct ieee80211_if_managed *ifmgd = &sdata->u.mgd;\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct sta_info *sta;\n\tunsigned long timeout;\n\n\tif (WARN_ON(ieee80211_vif_is_mld(&sdata->vif)))\n\t\treturn;\n\n\tif (sdata->vif.bss_conf.csa_active &&\n\t    !sdata->deflink.u.mgd.csa_waiting_bcn)\n\t\treturn;\n\n\tsta = sta_info_get(sdata, sdata->vif.cfg.ap_addr);\n\tif (!sta)\n\t\treturn;\n\n\ttimeout = sta->deflink.status_stats.last_ack;\n\tif (time_before(sta->deflink.status_stats.last_ack, sta->deflink.rx_stats.last_rx))\n\t\ttimeout = sta->deflink.rx_stats.last_rx;\n\ttimeout += IEEE80211_CONNECTION_IDLE_TIME;\n\n\t \n\tif (time_is_after_jiffies(timeout)) {\n\t\tmod_timer(&ifmgd->conn_mon_timer, round_jiffies_up(timeout));\n\t\treturn;\n\t}\n\n\tieee80211_queue_work(&local->hw, &ifmgd->monitor_work);\n}\n\nstatic void ieee80211_sta_monitor_work(struct work_struct *work)\n{\n\tstruct ieee80211_sub_if_data *sdata =\n\t\tcontainer_of(work, struct ieee80211_sub_if_data,\n\t\t\t     u.mgd.monitor_work);\n\n\tieee80211_mgd_probe_ap(sdata, false);\n}\n\nstatic void ieee80211_restart_sta_timer(struct ieee80211_sub_if_data *sdata)\n{\n\tif (sdata->vif.type == NL80211_IFTYPE_STATION) {\n\t\t__ieee80211_stop_poll(sdata);\n\n\t\t \n\t\tif (!ieee80211_hw_check(&sdata->local->hw, CONNECTION_MONITOR))\n\t\t\tieee80211_queue_work(&sdata->local->hw,\n\t\t\t\t\t     &sdata->u.mgd.monitor_work);\n\t}\n}\n\n#ifdef CONFIG_PM\nvoid ieee80211_mgd_quiesce(struct ieee80211_sub_if_data *sdata)\n{\n\tstruct ieee80211_if_managed *ifmgd = &sdata->u.mgd;\n\tu8 frame_buf[IEEE80211_DEAUTH_FRAME_LEN];\n\n\tsdata_lock(sdata);\n\n\tif (ifmgd->auth_data || ifmgd->assoc_data) {\n\t\tconst u8 *ap_addr = ifmgd->auth_data ?\n\t\t\t\tifmgd->auth_data->ap_addr :\n\t\t\t\tifmgd->assoc_data->ap_addr;\n\n\t\t \n\t\tieee80211_send_deauth_disassoc(sdata, ap_addr, ap_addr,\n\t\t\t\t\t       IEEE80211_STYPE_DEAUTH,\n\t\t\t\t\t       WLAN_REASON_DEAUTH_LEAVING,\n\t\t\t\t\t       false, frame_buf);\n\t\tif (ifmgd->assoc_data)\n\t\t\tieee80211_destroy_assoc_data(sdata, ASSOC_ABANDON);\n\t\tif (ifmgd->auth_data)\n\t\t\tieee80211_destroy_auth_data(sdata, false);\n\t\tcfg80211_tx_mlme_mgmt(sdata->dev, frame_buf,\n\t\t\t\t      IEEE80211_DEAUTH_FRAME_LEN,\n\t\t\t\t      false);\n\t}\n\n\t \n\tif (ifmgd->associated && !sdata->local->wowlan) {\n\t\tu8 bssid[ETH_ALEN];\n\t\tstruct cfg80211_deauth_request req = {\n\t\t\t.reason_code = WLAN_REASON_DEAUTH_LEAVING,\n\t\t\t.bssid = bssid,\n\t\t};\n\n\t\tmemcpy(bssid, sdata->vif.cfg.ap_addr, ETH_ALEN);\n\t\tieee80211_mgd_deauth(sdata, &req);\n\t}\n\n\tsdata_unlock(sdata);\n}\n#endif\n\nvoid ieee80211_sta_restart(struct ieee80211_sub_if_data *sdata)\n{\n\tstruct ieee80211_if_managed *ifmgd = &sdata->u.mgd;\n\n\tsdata_lock(sdata);\n\tif (!ifmgd->associated) {\n\t\tsdata_unlock(sdata);\n\t\treturn;\n\t}\n\n\tif (sdata->flags & IEEE80211_SDATA_DISCONNECT_RESUME) {\n\t\tsdata->flags &= ~IEEE80211_SDATA_DISCONNECT_RESUME;\n\t\tmlme_dbg(sdata, \"driver requested disconnect after resume\\n\");\n\t\tieee80211_sta_connection_lost(sdata,\n\t\t\t\t\t      WLAN_REASON_UNSPECIFIED,\n\t\t\t\t\t      true);\n\t\tsdata_unlock(sdata);\n\t\treturn;\n\t}\n\n\tif (sdata->flags & IEEE80211_SDATA_DISCONNECT_HW_RESTART) {\n\t\tsdata->flags &= ~IEEE80211_SDATA_DISCONNECT_HW_RESTART;\n\t\tmlme_dbg(sdata, \"driver requested disconnect after hardware restart\\n\");\n\t\tieee80211_sta_connection_lost(sdata,\n\t\t\t\t\t      WLAN_REASON_UNSPECIFIED,\n\t\t\t\t\t      true);\n\t\tsdata_unlock(sdata);\n\t\treturn;\n\t}\n\n\tsdata_unlock(sdata);\n}\n\nstatic void ieee80211_request_smps_mgd_work(struct wiphy *wiphy,\n\t\t\t\t\t    struct wiphy_work *work)\n{\n\tstruct ieee80211_link_data *link =\n\t\tcontainer_of(work, struct ieee80211_link_data,\n\t\t\t     u.mgd.request_smps_work);\n\n\tsdata_lock(link->sdata);\n\t__ieee80211_request_smps_mgd(link->sdata, link,\n\t\t\t\t     link->u.mgd.driver_smps_mode);\n\tsdata_unlock(link->sdata);\n}\n\n \nvoid ieee80211_sta_setup_sdata(struct ieee80211_sub_if_data *sdata)\n{\n\tstruct ieee80211_if_managed *ifmgd = &sdata->u.mgd;\n\n\tINIT_WORK(&ifmgd->monitor_work, ieee80211_sta_monitor_work);\n\twiphy_work_init(&ifmgd->beacon_connection_loss_work,\n\t\t\tieee80211_beacon_connection_loss_work);\n\twiphy_work_init(&ifmgd->csa_connection_drop_work,\n\t\t\tieee80211_csa_connection_drop_work);\n\tINIT_DELAYED_WORK(&ifmgd->tdls_peer_del_work,\n\t\t\t  ieee80211_tdls_peer_del_work);\n\twiphy_delayed_work_init(&ifmgd->ml_reconf_work,\n\t\t\t\tieee80211_ml_reconf_work);\n\ttimer_setup(&ifmgd->timer, ieee80211_sta_timer, 0);\n\ttimer_setup(&ifmgd->bcn_mon_timer, ieee80211_sta_bcn_mon_timer, 0);\n\ttimer_setup(&ifmgd->conn_mon_timer, ieee80211_sta_conn_mon_timer, 0);\n\tINIT_DELAYED_WORK(&ifmgd->tx_tspec_wk,\n\t\t\t  ieee80211_sta_handle_tspec_ac_params_wk);\n\n\tifmgd->flags = 0;\n\tifmgd->powersave = sdata->wdev.ps;\n\tifmgd->uapsd_queues = sdata->local->hw.uapsd_queues;\n\tifmgd->uapsd_max_sp_len = sdata->local->hw.uapsd_max_sp_len;\n\t \n\tspin_lock_init(&ifmgd->teardown_lock);\n\tifmgd->teardown_skb = NULL;\n\tifmgd->orig_teardown_skb = NULL;\n}\n\nvoid ieee80211_mgd_setup_link(struct ieee80211_link_data *link)\n{\n\tstruct ieee80211_sub_if_data *sdata = link->sdata;\n\tstruct ieee80211_local *local = sdata->local;\n\tunsigned int link_id = link->link_id;\n\n\tlink->u.mgd.p2p_noa_index = -1;\n\tlink->u.mgd.conn_flags = 0;\n\tlink->conf->bssid = link->u.mgd.bssid;\n\n\twiphy_work_init(&link->u.mgd.request_smps_work,\n\t\t\tieee80211_request_smps_mgd_work);\n\tif (local->hw.wiphy->features & NL80211_FEATURE_DYNAMIC_SMPS)\n\t\tlink->u.mgd.req_smps = IEEE80211_SMPS_AUTOMATIC;\n\telse\n\t\tlink->u.mgd.req_smps = IEEE80211_SMPS_OFF;\n\n\twiphy_delayed_work_init(&link->u.mgd.chswitch_work,\n\t\t\t\tieee80211_chswitch_work);\n\n\tif (sdata->u.mgd.assoc_data)\n\t\tether_addr_copy(link->conf->addr,\n\t\t\t\tsdata->u.mgd.assoc_data->link[link_id].addr);\n\telse if (!is_valid_ether_addr(link->conf->addr))\n\t\teth_random_addr(link->conf->addr);\n}\n\n \nvoid ieee80211_mlme_notify_scan_completed(struct ieee80211_local *local)\n{\n\tstruct ieee80211_sub_if_data *sdata;\n\n\t \n\trcu_read_lock();\n\tlist_for_each_entry_rcu(sdata, &local->interfaces, list) {\n\t\tif (ieee80211_sdata_running(sdata))\n\t\t\tieee80211_restart_sta_timer(sdata);\n\t}\n\trcu_read_unlock();\n}\n\nstatic int ieee80211_prep_connection(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t     struct cfg80211_bss *cbss, s8 link_id,\n\t\t\t\t     const u8 *ap_mld_addr, bool assoc,\n\t\t\t\t     bool override)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct ieee80211_if_managed *ifmgd = &sdata->u.mgd;\n\tstruct ieee80211_bss *bss = (void *)cbss->priv;\n\tstruct sta_info *new_sta = NULL;\n\tstruct ieee80211_link_data *link;\n\tbool have_sta = false;\n\tbool mlo;\n\tint err;\n\n\tif (link_id >= 0) {\n\t\tmlo = true;\n\t\tif (WARN_ON(!ap_mld_addr))\n\t\t\treturn -EINVAL;\n\t\terr = ieee80211_vif_set_links(sdata, BIT(link_id), 0);\n\t} else {\n\t\tif (WARN_ON(ap_mld_addr))\n\t\t\treturn -EINVAL;\n\t\tap_mld_addr = cbss->bssid;\n\t\terr = ieee80211_vif_set_links(sdata, 0, 0);\n\t\tlink_id = 0;\n\t\tmlo = false;\n\t}\n\n\tif (err)\n\t\treturn err;\n\n\tlink = sdata_dereference(sdata->link[link_id], sdata);\n\tif (WARN_ON(!link)) {\n\t\terr = -ENOLINK;\n\t\tgoto out_err;\n\t}\n\n\tif (WARN_ON(!ifmgd->auth_data && !ifmgd->assoc_data)) {\n\t\terr = -EINVAL;\n\t\tgoto out_err;\n\t}\n\n\t \n\tif (local->in_reconfig) {\n\t\terr = -EBUSY;\n\t\tgoto out_err;\n\t}\n\n\tif (assoc) {\n\t\trcu_read_lock();\n\t\thave_sta = sta_info_get(sdata, ap_mld_addr);\n\t\trcu_read_unlock();\n\t}\n\n\tif (!have_sta) {\n\t\tif (mlo)\n\t\t\tnew_sta = sta_info_alloc_with_link(sdata, ap_mld_addr,\n\t\t\t\t\t\t\t   link_id, cbss->bssid,\n\t\t\t\t\t\t\t   GFP_KERNEL);\n\t\telse\n\t\t\tnew_sta = sta_info_alloc(sdata, ap_mld_addr, GFP_KERNEL);\n\n\t\tif (!new_sta) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out_err;\n\t\t}\n\n\t\tnew_sta->sta.mlo = mlo;\n\t}\n\n\t \n\tif (new_sta) {\n\t\tconst struct cfg80211_bss_ies *ies;\n\t\tstruct link_sta_info *link_sta;\n\n\t\trcu_read_lock();\n\t\tlink_sta = rcu_dereference(new_sta->link[link_id]);\n\t\tif (WARN_ON(!link_sta)) {\n\t\t\trcu_read_unlock();\n\t\t\tsta_info_free(local, new_sta);\n\t\t\terr = -EINVAL;\n\t\t\tgoto out_err;\n\t\t}\n\n\t\terr = ieee80211_mgd_setup_link_sta(link, new_sta,\n\t\t\t\t\t\t   link_sta, cbss);\n\t\tif (err) {\n\t\t\trcu_read_unlock();\n\t\t\tsta_info_free(local, new_sta);\n\t\t\tgoto out_err;\n\t\t}\n\n\t\tmemcpy(link->u.mgd.bssid, cbss->bssid, ETH_ALEN);\n\n\t\t \n\t\tlink->conf->beacon_int = cbss->beacon_interval;\n\t\ties = rcu_dereference(cbss->beacon_ies);\n\t\tif (ies) {\n\t\t\tlink->conf->sync_tsf = ies->tsf;\n\t\t\tlink->conf->sync_device_ts =\n\t\t\t\tbss->device_ts_beacon;\n\n\t\t\tieee80211_get_dtim(ies,\n\t\t\t\t\t   &link->conf->sync_dtim_count,\n\t\t\t\t\t   NULL);\n\t\t} else if (!ieee80211_hw_check(&sdata->local->hw,\n\t\t\t\t\t       TIMING_BEACON_ONLY)) {\n\t\t\ties = rcu_dereference(cbss->proberesp_ies);\n\t\t\t \n\t\t\tlink->conf->sync_tsf = ies->tsf;\n\t\t\tlink->conf->sync_device_ts =\n\t\t\t\tbss->device_ts_presp;\n\t\t\tlink->conf->sync_dtim_count = 0;\n\t\t} else {\n\t\t\tlink->conf->sync_tsf = 0;\n\t\t\tlink->conf->sync_device_ts = 0;\n\t\t\tlink->conf->sync_dtim_count = 0;\n\t\t}\n\t\trcu_read_unlock();\n\t}\n\n\tif (new_sta || override) {\n\t\terr = ieee80211_prep_channel(sdata, link, cbss,\n\t\t\t\t\t     &link->u.mgd.conn_flags);\n\t\tif (err) {\n\t\t\tif (new_sta)\n\t\t\t\tsta_info_free(local, new_sta);\n\t\t\tgoto out_err;\n\t\t}\n\t}\n\n\tif (new_sta) {\n\t\t \n\t\tieee80211_link_info_change_notify(sdata, link,\n\t\t\t\t\t\t  BSS_CHANGED_BSSID |\n\t\t\t\t\t\t  BSS_CHANGED_BASIC_RATES |\n\t\t\t\t\t\t  BSS_CHANGED_BEACON_INT);\n\n\t\tif (assoc)\n\t\t\tsta_info_pre_move_state(new_sta, IEEE80211_STA_AUTH);\n\n\t\terr = sta_info_insert(new_sta);\n\t\tnew_sta = NULL;\n\t\tif (err) {\n\t\t\tsdata_info(sdata,\n\t\t\t\t   \"failed to insert STA entry for the AP (error %d)\\n\",\n\t\t\t\t   err);\n\t\t\tgoto out_err;\n\t\t}\n\t} else\n\t\tWARN_ON_ONCE(!ether_addr_equal(link->u.mgd.bssid, cbss->bssid));\n\n\t \n\tif (local->scanning)\n\t\tieee80211_scan_cancel(local);\n\n\treturn 0;\n\nout_err:\n\tieee80211_link_release_channel(&sdata->deflink);\n\tieee80211_vif_set_links(sdata, 0, 0);\n\treturn err;\n}\n\n \nint ieee80211_mgd_auth(struct ieee80211_sub_if_data *sdata,\n\t\t       struct cfg80211_auth_request *req)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct ieee80211_if_managed *ifmgd = &sdata->u.mgd;\n\tstruct ieee80211_mgd_auth_data *auth_data;\n\tu16 auth_alg;\n\tint err;\n\tbool cont_auth;\n\n\t \n\n\tswitch (req->auth_type) {\n\tcase NL80211_AUTHTYPE_OPEN_SYSTEM:\n\t\tauth_alg = WLAN_AUTH_OPEN;\n\t\tbreak;\n\tcase NL80211_AUTHTYPE_SHARED_KEY:\n\t\tif (fips_enabled)\n\t\t\treturn -EOPNOTSUPP;\n\t\tauth_alg = WLAN_AUTH_SHARED_KEY;\n\t\tbreak;\n\tcase NL80211_AUTHTYPE_FT:\n\t\tauth_alg = WLAN_AUTH_FT;\n\t\tbreak;\n\tcase NL80211_AUTHTYPE_NETWORK_EAP:\n\t\tauth_alg = WLAN_AUTH_LEAP;\n\t\tbreak;\n\tcase NL80211_AUTHTYPE_SAE:\n\t\tauth_alg = WLAN_AUTH_SAE;\n\t\tbreak;\n\tcase NL80211_AUTHTYPE_FILS_SK:\n\t\tauth_alg = WLAN_AUTH_FILS_SK;\n\t\tbreak;\n\tcase NL80211_AUTHTYPE_FILS_SK_PFS:\n\t\tauth_alg = WLAN_AUTH_FILS_SK_PFS;\n\t\tbreak;\n\tcase NL80211_AUTHTYPE_FILS_PK:\n\t\tauth_alg = WLAN_AUTH_FILS_PK;\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (ifmgd->assoc_data)\n\t\treturn -EBUSY;\n\n\tauth_data = kzalloc(sizeof(*auth_data) + req->auth_data_len +\n\t\t\t    req->ie_len, GFP_KERNEL);\n\tif (!auth_data)\n\t\treturn -ENOMEM;\n\n\tmemcpy(auth_data->ap_addr,\n\t       req->ap_mld_addr ?: req->bss->bssid,\n\t       ETH_ALEN);\n\tauth_data->bss = req->bss;\n\tauth_data->link_id = req->link_id;\n\n\tif (req->auth_data_len >= 4) {\n\t\tif (req->auth_type == NL80211_AUTHTYPE_SAE) {\n\t\t\t__le16 *pos = (__le16 *) req->auth_data;\n\n\t\t\tauth_data->sae_trans = le16_to_cpu(pos[0]);\n\t\t\tauth_data->sae_status = le16_to_cpu(pos[1]);\n\t\t}\n\t\tmemcpy(auth_data->data, req->auth_data + 4,\n\t\t       req->auth_data_len - 4);\n\t\tauth_data->data_len += req->auth_data_len - 4;\n\t}\n\n\t \n\tcont_auth = ifmgd->auth_data && req->bss == ifmgd->auth_data->bss &&\n\t\t    ifmgd->auth_data->link_id == req->link_id;\n\n\tif (req->ie && req->ie_len) {\n\t\tmemcpy(&auth_data->data[auth_data->data_len],\n\t\t       req->ie, req->ie_len);\n\t\tauth_data->data_len += req->ie_len;\n\t}\n\n\tif (req->key && req->key_len) {\n\t\tauth_data->key_len = req->key_len;\n\t\tauth_data->key_idx = req->key_idx;\n\t\tmemcpy(auth_data->key, req->key, req->key_len);\n\t}\n\n\tauth_data->algorithm = auth_alg;\n\n\t \n\n\tif (ifmgd->auth_data) {\n\t\tif (cont_auth && req->auth_type == NL80211_AUTHTYPE_SAE) {\n\t\t\tauth_data->peer_confirmed =\n\t\t\t\tifmgd->auth_data->peer_confirmed;\n\t\t}\n\t\tieee80211_destroy_auth_data(sdata, cont_auth);\n\t}\n\n\t \n\tifmgd->auth_data = auth_data;\n\n\t \n\tif (cont_auth && req->auth_type == NL80211_AUTHTYPE_SAE &&\n\t    auth_data->peer_confirmed && auth_data->sae_trans == 2)\n\t\tieee80211_mark_sta_auth(sdata);\n\n\tif (ifmgd->associated) {\n\t\tu8 frame_buf[IEEE80211_DEAUTH_FRAME_LEN];\n\n\t\tsdata_info(sdata,\n\t\t\t   \"disconnect from AP %pM for new auth to %pM\\n\",\n\t\t\t   sdata->vif.cfg.ap_addr, auth_data->ap_addr);\n\t\tieee80211_set_disassoc(sdata, IEEE80211_STYPE_DEAUTH,\n\t\t\t\t       WLAN_REASON_UNSPECIFIED,\n\t\t\t\t       false, frame_buf);\n\n\t\tieee80211_report_disconnect(sdata, frame_buf,\n\t\t\t\t\t    sizeof(frame_buf), true,\n\t\t\t\t\t    WLAN_REASON_UNSPECIFIED,\n\t\t\t\t\t    false);\n\t}\n\n\tsdata_info(sdata, \"authenticate with %pM\\n\", auth_data->ap_addr);\n\n\t \n\tmemcpy(sdata->vif.cfg.ap_addr, auth_data->ap_addr, ETH_ALEN);\n\n\terr = ieee80211_prep_connection(sdata, req->bss, req->link_id,\n\t\t\t\t\treq->ap_mld_addr, cont_auth, false);\n\tif (err)\n\t\tgoto err_clear;\n\n\terr = ieee80211_auth(sdata);\n\tif (err) {\n\t\tsta_info_destroy_addr(sdata, auth_data->ap_addr);\n\t\tgoto err_clear;\n\t}\n\n\t \n\tcfg80211_ref_bss(local->hw.wiphy, auth_data->bss);\n\treturn 0;\n\n err_clear:\n\tif (!ieee80211_vif_is_mld(&sdata->vif)) {\n\t\teth_zero_addr(sdata->deflink.u.mgd.bssid);\n\t\tieee80211_link_info_change_notify(sdata, &sdata->deflink,\n\t\t\t\t\t\t  BSS_CHANGED_BSSID);\n\t\tmutex_lock(&sdata->local->mtx);\n\t\tieee80211_link_release_channel(&sdata->deflink);\n\t\tmutex_unlock(&sdata->local->mtx);\n\t}\n\tifmgd->auth_data = NULL;\n\tkfree(auth_data);\n\treturn err;\n}\n\nstatic ieee80211_conn_flags_t\nieee80211_setup_assoc_link(struct ieee80211_sub_if_data *sdata,\n\t\t\t   struct ieee80211_mgd_assoc_data *assoc_data,\n\t\t\t   struct cfg80211_assoc_request *req,\n\t\t\t   ieee80211_conn_flags_t conn_flags,\n\t\t\t   unsigned int link_id)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tconst struct cfg80211_bss_ies *beacon_ies;\n\tstruct ieee80211_supported_band *sband;\n\tconst struct element *ht_elem, *vht_elem;\n\tstruct ieee80211_link_data *link;\n\tstruct cfg80211_bss *cbss;\n\tstruct ieee80211_bss *bss;\n\tbool is_5ghz, is_6ghz;\n\n\tcbss = assoc_data->link[link_id].bss;\n\tif (WARN_ON(!cbss))\n\t\treturn 0;\n\n\tbss = (void *)cbss->priv;\n\n\tsband = local->hw.wiphy->bands[cbss->channel->band];\n\tif (WARN_ON(!sband))\n\t\treturn 0;\n\n\tlink = sdata_dereference(sdata->link[link_id], sdata);\n\tif (WARN_ON(!link))\n\t\treturn 0;\n\n\tis_5ghz = cbss->channel->band == NL80211_BAND_5GHZ;\n\tis_6ghz = cbss->channel->band == NL80211_BAND_6GHZ;\n\n\t \n\tif (!req->ap_mld_addr) {\n\t\tassoc_data->supp_rates = bss->supp_rates;\n\t\tassoc_data->supp_rates_len = bss->supp_rates_len;\n\t}\n\n\t \n\tif (req->links[link_id].elems_len) {\n\t\tmemcpy(assoc_data->ie_pos, req->links[link_id].elems,\n\t\t       req->links[link_id].elems_len);\n\t\tassoc_data->link[link_id].elems = assoc_data->ie_pos;\n\t\tassoc_data->link[link_id].elems_len = req->links[link_id].elems_len;\n\t\tassoc_data->ie_pos += req->links[link_id].elems_len;\n\t}\n\n\trcu_read_lock();\n\tht_elem = ieee80211_bss_get_elem(cbss, WLAN_EID_HT_OPERATION);\n\tif (ht_elem && ht_elem->datalen >= sizeof(struct ieee80211_ht_operation))\n\t\tassoc_data->link[link_id].ap_ht_param =\n\t\t\t((struct ieee80211_ht_operation *)(ht_elem->data))->ht_param;\n\telse if (!is_6ghz)\n\t\tconn_flags |= IEEE80211_CONN_DISABLE_HT;\n\tvht_elem = ieee80211_bss_get_elem(cbss, WLAN_EID_VHT_CAPABILITY);\n\tif (vht_elem && vht_elem->datalen >= sizeof(struct ieee80211_vht_cap)) {\n\t\tmemcpy(&assoc_data->link[link_id].ap_vht_cap, vht_elem->data,\n\t\t       sizeof(struct ieee80211_vht_cap));\n\t} else if (is_5ghz) {\n\t\tlink_info(link,\n\t\t\t  \"VHT capa missing/short, disabling VHT/HE/EHT\\n\");\n\t\tconn_flags |= IEEE80211_CONN_DISABLE_VHT |\n\t\t\t      IEEE80211_CONN_DISABLE_HE |\n\t\t\t      IEEE80211_CONN_DISABLE_EHT;\n\t}\n\trcu_read_unlock();\n\n\tlink->u.mgd.beacon_crc_valid = false;\n\tlink->u.mgd.dtim_period = 0;\n\tlink->u.mgd.have_beacon = false;\n\n\t \n\tif (!(conn_flags & IEEE80211_CONN_DISABLE_HT)) {\n\t\tstruct ieee80211_sta_ht_cap sta_ht_cap;\n\n\t\tmemcpy(&sta_ht_cap, &sband->ht_cap, sizeof(sta_ht_cap));\n\t\tieee80211_apply_htcap_overrides(sdata, &sta_ht_cap);\n\t}\n\n\tlink->conf->eht_puncturing = 0;\n\n\trcu_read_lock();\n\tbeacon_ies = rcu_dereference(cbss->beacon_ies);\n\tif (beacon_ies) {\n\t\tconst struct ieee80211_eht_operation *eht_oper;\n\t\tconst struct element *elem;\n\t\tu8 dtim_count = 0;\n\n\t\tieee80211_get_dtim(beacon_ies, &dtim_count,\n\t\t\t\t   &link->u.mgd.dtim_period);\n\n\t\tsdata->deflink.u.mgd.have_beacon = true;\n\n\t\tif (ieee80211_hw_check(&local->hw, TIMING_BEACON_ONLY)) {\n\t\t\tlink->conf->sync_tsf = beacon_ies->tsf;\n\t\t\tlink->conf->sync_device_ts = bss->device_ts_beacon;\n\t\t\tlink->conf->sync_dtim_count = dtim_count;\n\t\t}\n\n\t\telem = cfg80211_find_ext_elem(WLAN_EID_EXT_MULTIPLE_BSSID_CONFIGURATION,\n\t\t\t\t\t      beacon_ies->data, beacon_ies->len);\n\t\tif (elem && elem->datalen >= 3)\n\t\t\tlink->conf->profile_periodicity = elem->data[2];\n\t\telse\n\t\t\tlink->conf->profile_periodicity = 0;\n\n\t\telem = cfg80211_find_elem(WLAN_EID_EXT_CAPABILITY,\n\t\t\t\t\t  beacon_ies->data, beacon_ies->len);\n\t\tif (elem && elem->datalen >= 11 &&\n\t\t    (elem->data[10] & WLAN_EXT_CAPA11_EMA_SUPPORT))\n\t\t\tlink->conf->ema_ap = true;\n\t\telse\n\t\t\tlink->conf->ema_ap = false;\n\n\t\telem = cfg80211_find_ext_elem(WLAN_EID_EXT_EHT_OPERATION,\n\t\t\t\t\t      beacon_ies->data, beacon_ies->len);\n\t\teht_oper = (const void *)(elem->data + 1);\n\n\t\tif (elem &&\n\t\t    ieee80211_eht_oper_size_ok((const void *)(elem->data + 1),\n\t\t\t\t\t       elem->datalen - 1) &&\n\t\t    (eht_oper->params & IEEE80211_EHT_OPER_INFO_PRESENT) &&\n\t\t    (eht_oper->params & IEEE80211_EHT_OPER_DISABLED_SUBCHANNEL_BITMAP_PRESENT)) {\n\t\t\tconst struct ieee80211_eht_operation_info *info =\n\t\t\t\t(void *)eht_oper->optional;\n\t\t\tconst u8 *disable_subchannel_bitmap = info->optional;\n\t\t\tu16 bitmap;\n\n\t\t\tbitmap = get_unaligned_le16(disable_subchannel_bitmap);\n\t\t\tif (cfg80211_valid_disable_subchannel_bitmap(&bitmap,\n\t\t\t\t\t\t\t\t     &link->conf->chandef))\n\t\t\t\tieee80211_handle_puncturing_bitmap(link,\n\t\t\t\t\t\t\t\t   eht_oper,\n\t\t\t\t\t\t\t\t   bitmap,\n\t\t\t\t\t\t\t\t   NULL);\n\t\t\telse\n\t\t\t\tconn_flags |= IEEE80211_CONN_DISABLE_EHT;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\tif (bss->corrupt_data) {\n\t\tchar *corrupt_type = \"data\";\n\n\t\tif (bss->corrupt_data & IEEE80211_BSS_CORRUPT_BEACON) {\n\t\t\tif (bss->corrupt_data & IEEE80211_BSS_CORRUPT_PROBE_RESP)\n\t\t\t\tcorrupt_type = \"beacon and probe response\";\n\t\t\telse\n\t\t\t\tcorrupt_type = \"beacon\";\n\t\t} else if (bss->corrupt_data & IEEE80211_BSS_CORRUPT_PROBE_RESP) {\n\t\t\tcorrupt_type = \"probe response\";\n\t\t}\n\t\tsdata_info(sdata, \"associating to AP %pM with corrupt %s\\n\",\n\t\t\t   cbss->bssid, corrupt_type);\n\t}\n\n\tif (link->u.mgd.req_smps == IEEE80211_SMPS_AUTOMATIC) {\n\t\tif (sdata->u.mgd.powersave)\n\t\t\tlink->smps_mode = IEEE80211_SMPS_DYNAMIC;\n\t\telse\n\t\t\tlink->smps_mode = IEEE80211_SMPS_OFF;\n\t} else {\n\t\tlink->smps_mode = link->u.mgd.req_smps;\n\t}\n\n\treturn conn_flags;\n}\n\nint ieee80211_mgd_assoc(struct ieee80211_sub_if_data *sdata,\n\t\t\tstruct cfg80211_assoc_request *req)\n{\n\tunsigned int assoc_link_id = req->link_id < 0 ? 0 : req->link_id;\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct ieee80211_if_managed *ifmgd = &sdata->u.mgd;\n\tstruct ieee80211_mgd_assoc_data *assoc_data;\n\tconst struct element *ssid_elem;\n\tstruct ieee80211_vif_cfg *vif_cfg = &sdata->vif.cfg;\n\tieee80211_conn_flags_t conn_flags = 0;\n\tstruct ieee80211_link_data *link;\n\tstruct cfg80211_bss *cbss;\n\tstruct ieee80211_bss *bss;\n\tbool override;\n\tint i, err;\n\tsize_t size = sizeof(*assoc_data) + req->ie_len;\n\n\tfor (i = 0; i < IEEE80211_MLD_MAX_NUM_LINKS; i++)\n\t\tsize += req->links[i].elems_len;\n\n\t \n\tif (sdata->u.mgd.use_4addr && req->link_id >= 0)\n\t\treturn -EOPNOTSUPP;\n\n\tassoc_data = kzalloc(size, GFP_KERNEL);\n\tif (!assoc_data)\n\t\treturn -ENOMEM;\n\n\tcbss = req->link_id < 0 ? req->bss : req->links[req->link_id].bss;\n\n\trcu_read_lock();\n\tssid_elem = ieee80211_bss_get_elem(cbss, WLAN_EID_SSID);\n\tif (!ssid_elem || ssid_elem->datalen > sizeof(assoc_data->ssid)) {\n\t\trcu_read_unlock();\n\t\tkfree(assoc_data);\n\t\treturn -EINVAL;\n\t}\n\tmemcpy(assoc_data->ssid, ssid_elem->data, ssid_elem->datalen);\n\tassoc_data->ssid_len = ssid_elem->datalen;\n\tmemcpy(vif_cfg->ssid, assoc_data->ssid, assoc_data->ssid_len);\n\tvif_cfg->ssid_len = assoc_data->ssid_len;\n\trcu_read_unlock();\n\n\tif (req->ap_mld_addr) {\n\t\tfor (i = 0; i < IEEE80211_MLD_MAX_NUM_LINKS; i++) {\n\t\t\tif (!req->links[i].bss)\n\t\t\t\tcontinue;\n\t\t\tlink = sdata_dereference(sdata->link[i], sdata);\n\t\t\tif (link)\n\t\t\t\tether_addr_copy(assoc_data->link[i].addr,\n\t\t\t\t\t\tlink->conf->addr);\n\t\t\telse\n\t\t\t\teth_random_addr(assoc_data->link[i].addr);\n\t\t}\n\t} else {\n\t\tmemcpy(assoc_data->link[0].addr, sdata->vif.addr, ETH_ALEN);\n\t}\n\n\tassoc_data->s1g = cbss->channel->band == NL80211_BAND_S1GHZ;\n\n\tmemcpy(assoc_data->ap_addr,\n\t       req->ap_mld_addr ?: req->bss->bssid,\n\t       ETH_ALEN);\n\n\tif (ifmgd->associated) {\n\t\tu8 frame_buf[IEEE80211_DEAUTH_FRAME_LEN];\n\n\t\tsdata_info(sdata,\n\t\t\t   \"disconnect from AP %pM for new assoc to %pM\\n\",\n\t\t\t   sdata->vif.cfg.ap_addr, assoc_data->ap_addr);\n\t\tieee80211_set_disassoc(sdata, IEEE80211_STYPE_DEAUTH,\n\t\t\t\t       WLAN_REASON_UNSPECIFIED,\n\t\t\t\t       false, frame_buf);\n\n\t\tieee80211_report_disconnect(sdata, frame_buf,\n\t\t\t\t\t    sizeof(frame_buf), true,\n\t\t\t\t\t    WLAN_REASON_UNSPECIFIED,\n\t\t\t\t\t    false);\n\t}\n\n\tif (ifmgd->auth_data && !ifmgd->auth_data->done) {\n\t\terr = -EBUSY;\n\t\tgoto err_free;\n\t}\n\n\tif (ifmgd->assoc_data) {\n\t\terr = -EBUSY;\n\t\tgoto err_free;\n\t}\n\n\tif (ifmgd->auth_data) {\n\t\tbool match;\n\n\t\t \n\t\tmatch = ether_addr_equal(ifmgd->auth_data->ap_addr,\n\t\t\t\t\t assoc_data->ap_addr) &&\n\t\t\tifmgd->auth_data->link_id == req->link_id;\n\t\tieee80211_destroy_auth_data(sdata, match);\n\t}\n\n\t \n\n\tbss = (void *)cbss->priv;\n\tassoc_data->wmm = bss->wmm_used &&\n\t\t\t  (local->hw.queues >= IEEE80211_NUM_ACS);\n\n\t \n\tfor (i = 0; i < req->crypto.n_ciphers_pairwise; i++) {\n\t\tif (req->crypto.ciphers_pairwise[i] == WLAN_CIPHER_SUITE_WEP40 ||\n\t\t    req->crypto.ciphers_pairwise[i] == WLAN_CIPHER_SUITE_TKIP ||\n\t\t    req->crypto.ciphers_pairwise[i] == WLAN_CIPHER_SUITE_WEP104) {\n\t\t\tconn_flags |= IEEE80211_CONN_DISABLE_HT;\n\t\t\tconn_flags |= IEEE80211_CONN_DISABLE_VHT;\n\t\t\tconn_flags |= IEEE80211_CONN_DISABLE_HE;\n\t\t\tconn_flags |= IEEE80211_CONN_DISABLE_EHT;\n\t\t\tnetdev_info(sdata->dev,\n\t\t\t\t    \"disabling HT/VHT/HE due to WEP/TKIP use\\n\");\n\t\t}\n\t}\n\n\t \n\tif (!bss->wmm_used) {\n\t\tconn_flags |= IEEE80211_CONN_DISABLE_HT;\n\t\tconn_flags |= IEEE80211_CONN_DISABLE_VHT;\n\t\tconn_flags |= IEEE80211_CONN_DISABLE_HE;\n\t\tconn_flags |= IEEE80211_CONN_DISABLE_EHT;\n\t\tnetdev_info(sdata->dev,\n\t\t\t    \"disabling HT/VHT/HE as WMM/QoS is not supported by the AP\\n\");\n\t}\n\n\tif (req->flags & ASSOC_REQ_DISABLE_HT) {\n\t\tmlme_dbg(sdata, \"HT disabled by flag, disabling HT/VHT/HE\\n\");\n\t\tconn_flags |= IEEE80211_CONN_DISABLE_HT;\n\t\tconn_flags |= IEEE80211_CONN_DISABLE_VHT;\n\t\tconn_flags |= IEEE80211_CONN_DISABLE_HE;\n\t\tconn_flags |= IEEE80211_CONN_DISABLE_EHT;\n\t}\n\n\tif (req->flags & ASSOC_REQ_DISABLE_VHT) {\n\t\tmlme_dbg(sdata, \"VHT disabled by flag, disabling VHT\\n\");\n\t\tconn_flags |= IEEE80211_CONN_DISABLE_VHT;\n\t}\n\n\tif (req->flags & ASSOC_REQ_DISABLE_HE) {\n\t\tmlme_dbg(sdata, \"HE disabled by flag, disabling HE/EHT\\n\");\n\t\tconn_flags |= IEEE80211_CONN_DISABLE_HE;\n\t\tconn_flags |= IEEE80211_CONN_DISABLE_EHT;\n\t}\n\n\tif (req->flags & ASSOC_REQ_DISABLE_EHT)\n\t\tconn_flags |= IEEE80211_CONN_DISABLE_EHT;\n\n\tmemcpy(&ifmgd->ht_capa, &req->ht_capa, sizeof(ifmgd->ht_capa));\n\tmemcpy(&ifmgd->ht_capa_mask, &req->ht_capa_mask,\n\t       sizeof(ifmgd->ht_capa_mask));\n\n\tmemcpy(&ifmgd->vht_capa, &req->vht_capa, sizeof(ifmgd->vht_capa));\n\tmemcpy(&ifmgd->vht_capa_mask, &req->vht_capa_mask,\n\t       sizeof(ifmgd->vht_capa_mask));\n\n\tmemcpy(&ifmgd->s1g_capa, &req->s1g_capa, sizeof(ifmgd->s1g_capa));\n\tmemcpy(&ifmgd->s1g_capa_mask, &req->s1g_capa_mask,\n\t       sizeof(ifmgd->s1g_capa_mask));\n\n\tif (req->ie && req->ie_len) {\n\t\tmemcpy(assoc_data->ie, req->ie, req->ie_len);\n\t\tassoc_data->ie_len = req->ie_len;\n\t\tassoc_data->ie_pos = assoc_data->ie + assoc_data->ie_len;\n\t} else {\n\t\tassoc_data->ie_pos = assoc_data->ie;\n\t}\n\n\tif (req->fils_kek) {\n\t\t \n\t\tif (WARN_ON(req->fils_kek_len > FILS_MAX_KEK_LEN)) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto err_free;\n\t\t}\n\t\tmemcpy(assoc_data->fils_kek, req->fils_kek,\n\t\t       req->fils_kek_len);\n\t\tassoc_data->fils_kek_len = req->fils_kek_len;\n\t}\n\n\tif (req->fils_nonces)\n\t\tmemcpy(assoc_data->fils_nonces, req->fils_nonces,\n\t\t       2 * FILS_NONCE_LEN);\n\n\t \n\tassoc_data->timeout = jiffies;\n\tassoc_data->timeout_started = true;\n\n\tassoc_data->assoc_link_id = assoc_link_id;\n\n\tif (req->ap_mld_addr) {\n\t\tfor (i = 0; i < ARRAY_SIZE(assoc_data->link); i++) {\n\t\t\tassoc_data->link[i].conn_flags = conn_flags;\n\t\t\tassoc_data->link[i].bss = req->links[i].bss;\n\t\t\tassoc_data->link[i].disabled = req->links[i].disabled;\n\t\t}\n\n\t\t \n\t\terr = ieee80211_vif_set_links(sdata, BIT(assoc_link_id), 0);\n\t\tif (err)\n\t\t\tgoto err_clear;\n\t} else {\n\t\tassoc_data->link[0].conn_flags = conn_flags;\n\t\tassoc_data->link[0].bss = cbss;\n\t}\n\n\tlink = sdata_dereference(sdata->link[assoc_link_id], sdata);\n\tif (WARN_ON(!link)) {\n\t\terr = -EINVAL;\n\t\tgoto err_clear;\n\t}\n\n\t \n\tconn_flags |= link->u.mgd.conn_flags;\n\tconn_flags |= ieee80211_setup_assoc_link(sdata, assoc_data, req,\n\t\t\t\t\t\t conn_flags, assoc_link_id);\n\toverride = link->u.mgd.conn_flags != conn_flags;\n\tlink->u.mgd.conn_flags |= conn_flags;\n\n\tif (WARN((sdata->vif.driver_flags & IEEE80211_VIF_SUPPORTS_UAPSD) &&\n\t\t ieee80211_hw_check(&local->hw, PS_NULLFUNC_STACK),\n\t     \"U-APSD not supported with HW_PS_NULLFUNC_STACK\\n\"))\n\t\tsdata->vif.driver_flags &= ~IEEE80211_VIF_SUPPORTS_UAPSD;\n\n\tif (bss->wmm_used && bss->uapsd_supported &&\n\t    (sdata->vif.driver_flags & IEEE80211_VIF_SUPPORTS_UAPSD)) {\n\t\tassoc_data->uapsd = true;\n\t\tifmgd->flags |= IEEE80211_STA_UAPSD_ENABLED;\n\t} else {\n\t\tassoc_data->uapsd = false;\n\t\tifmgd->flags &= ~IEEE80211_STA_UAPSD_ENABLED;\n\t}\n\n\tif (req->prev_bssid)\n\t\tmemcpy(assoc_data->prev_ap_addr, req->prev_bssid, ETH_ALEN);\n\n\tif (req->use_mfp) {\n\t\tifmgd->mfp = IEEE80211_MFP_REQUIRED;\n\t\tifmgd->flags |= IEEE80211_STA_MFP_ENABLED;\n\t} else {\n\t\tifmgd->mfp = IEEE80211_MFP_DISABLED;\n\t\tifmgd->flags &= ~IEEE80211_STA_MFP_ENABLED;\n\t}\n\n\tif (req->flags & ASSOC_REQ_USE_RRM)\n\t\tifmgd->flags |= IEEE80211_STA_ENABLE_RRM;\n\telse\n\t\tifmgd->flags &= ~IEEE80211_STA_ENABLE_RRM;\n\n\tif (req->crypto.control_port)\n\t\tifmgd->flags |= IEEE80211_STA_CONTROL_PORT;\n\telse\n\t\tifmgd->flags &= ~IEEE80211_STA_CONTROL_PORT;\n\n\tsdata->control_port_protocol = req->crypto.control_port_ethertype;\n\tsdata->control_port_no_encrypt = req->crypto.control_port_no_encrypt;\n\tsdata->control_port_over_nl80211 =\n\t\t\t\t\treq->crypto.control_port_over_nl80211;\n\tsdata->control_port_no_preauth = req->crypto.control_port_no_preauth;\n\n\t \n\tifmgd->assoc_data = assoc_data;\n\n\tfor (i = 0; i < ARRAY_SIZE(assoc_data->link); i++) {\n\t\tif (!assoc_data->link[i].bss)\n\t\t\tcontinue;\n\t\tif (i == assoc_data->assoc_link_id)\n\t\t\tcontinue;\n\t\t \n\t\terr = ieee80211_prep_channel(sdata, NULL, assoc_data->link[i].bss,\n\t\t\t\t\t     &assoc_data->link[i].conn_flags);\n\t\tif (err)\n\t\t\tgoto err_clear;\n\t}\n\n\t \n\tmemcpy(sdata->vif.cfg.ap_addr, assoc_data->ap_addr, ETH_ALEN);\n\n\terr = ieee80211_prep_connection(sdata, cbss, req->link_id,\n\t\t\t\t\treq->ap_mld_addr, true, override);\n\tif (err)\n\t\tgoto err_clear;\n\n\tassoc_data->link[assoc_data->assoc_link_id].conn_flags =\n\t\tlink->u.mgd.conn_flags;\n\n\tif (ieee80211_hw_check(&sdata->local->hw, NEED_DTIM_BEFORE_ASSOC)) {\n\t\tconst struct cfg80211_bss_ies *beacon_ies;\n\n\t\trcu_read_lock();\n\t\tbeacon_ies = rcu_dereference(req->bss->beacon_ies);\n\n\t\tif (beacon_ies) {\n\t\t\t \n\t\t\tsdata_info(sdata, \"waiting for beacon from %pM\\n\",\n\t\t\t\t   link->u.mgd.bssid);\n\t\t\tassoc_data->timeout = TU_TO_EXP_TIME(req->bss->beacon_interval);\n\t\t\tassoc_data->timeout_started = true;\n\t\t\tassoc_data->need_beacon = true;\n\t\t}\n\t\trcu_read_unlock();\n\t}\n\n\trun_again(sdata, assoc_data->timeout);\n\n\treturn 0;\n err_clear:\n\teth_zero_addr(sdata->deflink.u.mgd.bssid);\n\tieee80211_link_info_change_notify(sdata, &sdata->deflink,\n\t\t\t\t\t  BSS_CHANGED_BSSID);\n\tifmgd->assoc_data = NULL;\n err_free:\n\tkfree(assoc_data);\n\treturn err;\n}\n\nint ieee80211_mgd_deauth(struct ieee80211_sub_if_data *sdata,\n\t\t\t struct cfg80211_deauth_request *req)\n{\n\tstruct ieee80211_if_managed *ifmgd = &sdata->u.mgd;\n\tu8 frame_buf[IEEE80211_DEAUTH_FRAME_LEN];\n\tbool tx = !req->local_state_change;\n\tstruct ieee80211_prep_tx_info info = {\n\t\t.subtype = IEEE80211_STYPE_DEAUTH,\n\t};\n\n\tif (ifmgd->auth_data &&\n\t    ether_addr_equal(ifmgd->auth_data->ap_addr, req->bssid)) {\n\t\tsdata_info(sdata,\n\t\t\t   \"aborting authentication with %pM by local choice (Reason: %u=%s)\\n\",\n\t\t\t   req->bssid, req->reason_code,\n\t\t\t   ieee80211_get_reason_code_string(req->reason_code));\n\n\t\tdrv_mgd_prepare_tx(sdata->local, sdata, &info);\n\t\tieee80211_send_deauth_disassoc(sdata, req->bssid, req->bssid,\n\t\t\t\t\t       IEEE80211_STYPE_DEAUTH,\n\t\t\t\t\t       req->reason_code, tx,\n\t\t\t\t\t       frame_buf);\n\t\tieee80211_destroy_auth_data(sdata, false);\n\t\tieee80211_report_disconnect(sdata, frame_buf,\n\t\t\t\t\t    sizeof(frame_buf), true,\n\t\t\t\t\t    req->reason_code, false);\n\t\tdrv_mgd_complete_tx(sdata->local, sdata, &info);\n\t\treturn 0;\n\t}\n\n\tif (ifmgd->assoc_data &&\n\t    ether_addr_equal(ifmgd->assoc_data->ap_addr, req->bssid)) {\n\t\tsdata_info(sdata,\n\t\t\t   \"aborting association with %pM by local choice (Reason: %u=%s)\\n\",\n\t\t\t   req->bssid, req->reason_code,\n\t\t\t   ieee80211_get_reason_code_string(req->reason_code));\n\n\t\tdrv_mgd_prepare_tx(sdata->local, sdata, &info);\n\t\tieee80211_send_deauth_disassoc(sdata, req->bssid, req->bssid,\n\t\t\t\t\t       IEEE80211_STYPE_DEAUTH,\n\t\t\t\t\t       req->reason_code, tx,\n\t\t\t\t\t       frame_buf);\n\t\tieee80211_destroy_assoc_data(sdata, ASSOC_ABANDON);\n\t\tieee80211_report_disconnect(sdata, frame_buf,\n\t\t\t\t\t    sizeof(frame_buf), true,\n\t\t\t\t\t    req->reason_code, false);\n\t\treturn 0;\n\t}\n\n\tif (ifmgd->associated &&\n\t    ether_addr_equal(sdata->vif.cfg.ap_addr, req->bssid)) {\n\t\tsdata_info(sdata,\n\t\t\t   \"deauthenticating from %pM by local choice (Reason: %u=%s)\\n\",\n\t\t\t   req->bssid, req->reason_code,\n\t\t\t   ieee80211_get_reason_code_string(req->reason_code));\n\n\t\tieee80211_set_disassoc(sdata, IEEE80211_STYPE_DEAUTH,\n\t\t\t\t       req->reason_code, tx, frame_buf);\n\t\tieee80211_report_disconnect(sdata, frame_buf,\n\t\t\t\t\t    sizeof(frame_buf), true,\n\t\t\t\t\t    req->reason_code, false);\n\t\tdrv_mgd_complete_tx(sdata->local, sdata, &info);\n\t\treturn 0;\n\t}\n\n\treturn -ENOTCONN;\n}\n\nint ieee80211_mgd_disassoc(struct ieee80211_sub_if_data *sdata,\n\t\t\t   struct cfg80211_disassoc_request *req)\n{\n\tu8 frame_buf[IEEE80211_DEAUTH_FRAME_LEN];\n\n\tif (!sdata->u.mgd.associated ||\n\t    memcmp(sdata->vif.cfg.ap_addr, req->ap_addr, ETH_ALEN))\n\t\treturn -ENOTCONN;\n\n\tsdata_info(sdata,\n\t\t   \"disassociating from %pM by local choice (Reason: %u=%s)\\n\",\n\t\t   req->ap_addr, req->reason_code,\n\t\t   ieee80211_get_reason_code_string(req->reason_code));\n\n\tieee80211_set_disassoc(sdata, IEEE80211_STYPE_DISASSOC,\n\t\t\t       req->reason_code, !req->local_state_change,\n\t\t\t       frame_buf);\n\n\tieee80211_report_disconnect(sdata, frame_buf, sizeof(frame_buf), true,\n\t\t\t\t    req->reason_code, false);\n\n\treturn 0;\n}\n\nvoid ieee80211_mgd_stop_link(struct ieee80211_link_data *link)\n{\n\twiphy_work_cancel(link->sdata->local->hw.wiphy,\n\t\t\t  &link->u.mgd.request_smps_work);\n\twiphy_delayed_work_cancel(link->sdata->local->hw.wiphy,\n\t\t\t\t  &link->u.mgd.chswitch_work);\n}\n\nvoid ieee80211_mgd_stop(struct ieee80211_sub_if_data *sdata)\n{\n\tstruct ieee80211_if_managed *ifmgd = &sdata->u.mgd;\n\n\t \n\tcancel_work_sync(&ifmgd->monitor_work);\n\twiphy_work_cancel(sdata->local->hw.wiphy,\n\t\t\t  &ifmgd->beacon_connection_loss_work);\n\twiphy_work_cancel(sdata->local->hw.wiphy,\n\t\t\t  &ifmgd->csa_connection_drop_work);\n\tcancel_delayed_work_sync(&ifmgd->tdls_peer_del_work);\n\twiphy_delayed_work_cancel(sdata->local->hw.wiphy,\n\t\t\t\t  &ifmgd->ml_reconf_work);\n\n\tsdata_lock(sdata);\n\tif (ifmgd->assoc_data)\n\t\tieee80211_destroy_assoc_data(sdata, ASSOC_TIMEOUT);\n\tif (ifmgd->auth_data)\n\t\tieee80211_destroy_auth_data(sdata, false);\n\tspin_lock_bh(&ifmgd->teardown_lock);\n\tif (ifmgd->teardown_skb) {\n\t\tkfree_skb(ifmgd->teardown_skb);\n\t\tifmgd->teardown_skb = NULL;\n\t\tifmgd->orig_teardown_skb = NULL;\n\t}\n\tkfree(ifmgd->assoc_req_ies);\n\tifmgd->assoc_req_ies = NULL;\n\tifmgd->assoc_req_ies_len = 0;\n\tspin_unlock_bh(&ifmgd->teardown_lock);\n\tdel_timer_sync(&ifmgd->timer);\n\tsdata_unlock(sdata);\n}\n\nvoid ieee80211_cqm_rssi_notify(struct ieee80211_vif *vif,\n\t\t\t       enum nl80211_cqm_rssi_threshold_event rssi_event,\n\t\t\t       s32 rssi_level,\n\t\t\t       gfp_t gfp)\n{\n\tstruct ieee80211_sub_if_data *sdata = vif_to_sdata(vif);\n\n\ttrace_api_cqm_rssi_notify(sdata, rssi_event, rssi_level);\n\n\tcfg80211_cqm_rssi_notify(sdata->dev, rssi_event, rssi_level, gfp);\n}\nEXPORT_SYMBOL(ieee80211_cqm_rssi_notify);\n\nvoid ieee80211_cqm_beacon_loss_notify(struct ieee80211_vif *vif, gfp_t gfp)\n{\n\tstruct ieee80211_sub_if_data *sdata = vif_to_sdata(vif);\n\n\ttrace_api_cqm_beacon_loss_notify(sdata->local, sdata);\n\n\tcfg80211_cqm_beacon_loss_notify(sdata->dev, gfp);\n}\nEXPORT_SYMBOL(ieee80211_cqm_beacon_loss_notify);\n\nstatic void _ieee80211_enable_rssi_reports(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t\t    int rssi_min_thold,\n\t\t\t\t\t    int rssi_max_thold)\n{\n\ttrace_api_enable_rssi_reports(sdata, rssi_min_thold, rssi_max_thold);\n\n\tif (WARN_ON(sdata->vif.type != NL80211_IFTYPE_STATION))\n\t\treturn;\n\n\t \n\tsdata->u.mgd.rssi_min_thold = rssi_min_thold*16;\n\tsdata->u.mgd.rssi_max_thold = rssi_max_thold*16;\n}\n\nvoid ieee80211_enable_rssi_reports(struct ieee80211_vif *vif,\n\t\t\t\t    int rssi_min_thold,\n\t\t\t\t    int rssi_max_thold)\n{\n\tstruct ieee80211_sub_if_data *sdata = vif_to_sdata(vif);\n\n\tWARN_ON(rssi_min_thold == rssi_max_thold ||\n\t\trssi_min_thold > rssi_max_thold);\n\n\t_ieee80211_enable_rssi_reports(sdata, rssi_min_thold,\n\t\t\t\t       rssi_max_thold);\n}\nEXPORT_SYMBOL(ieee80211_enable_rssi_reports);\n\nvoid ieee80211_disable_rssi_reports(struct ieee80211_vif *vif)\n{\n\tstruct ieee80211_sub_if_data *sdata = vif_to_sdata(vif);\n\n\t_ieee80211_enable_rssi_reports(sdata, 0, 0);\n}\nEXPORT_SYMBOL(ieee80211_disable_rssi_reports);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}